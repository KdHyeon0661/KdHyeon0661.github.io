---
layout: post
title: 영상처리 - 손실 없는 JPEG 변환
date: 2025-10-09 23:25:23 +0900
category: 영상처리
---
# — **jpegtran 방식(transupp.h) 완전 정리**

> 목표
> - **재압축 없이**(DCT 계수 재양자화 없음) **회전(90/180/270)**, **반전(H/V)**, **전치/대각반전**, **크롭(타일/MCU 경계 기반)** 수행
> - **속도 빠름**, **화질 손실 0** (단, MCU 경계/샘플링 제약 준수)
> - EXIF Orientation을 **실제 픽셀에 반영**하고 Orientation=1로 **패치**(메타보존은 이전 섹션과 결합)
> - libjpeg(-turbo) + `transupp.h`(IJG의 jpegtran 유틸 코드) 사용

---

## 핵심 개념: 왜 “손실 없는가?”

JPEG는 8×8 블록 DCT 계수로 이미지를 표현합니다. **손실 없는 변환**은
- **계수 자체를 재계산/재양자화하지 않고**,
- **블록(혹은 MCU) 단위로 재배열**하거나 **부호만 바꾸는 수준**으로 처리합니다.

### MCU 경계란?

샘플링(Chroma subsampling)에 따라 “작업 최소 단위”가 달라집니다.

- 4:4:4 → MCU = **8×8**
- 4:2:2 → MCU = **16×8**
- 4:2:0 → MCU = **16×16**

> **정리**
> - 90°/270° 회전, H/V 반전 등은 **MCU 경계에 딱 맞는** 너비/높이가 아닐 경우 잉여 블록이 생깁니다.
> - `transupp`는 **trim** 옵션으로 남는 가장자리 **버림**(crop) 또는 **perfect** 옵션으로 **완벽히 나누어떨어질 때만** 허용합니다.

---

## 빌드 준비 (VS/vcpkg 예시)

- libjpeg(-turbo) 설치 (이미 진행했다고 가정)
- **`transupp.c`, `transupp.h`** 를 **프로젝트에 추가**
  - IJG 소스 패키지(jpegtran가 포함된 배포)에서 가져옵니다.
  - libjpeg(-turbo)에도 호환되는 `transupp`가 포함되어 있습니다(버전에 맞게).

```text
/yourproj
  |-- jpeglib.h, jconfig.h, jmorecfg.h ...
  |-- transupp.h, transupp.c   ← 추가
  |-- your .cpp/.h ...
```

> **주의**: `transupp.c`는 **C** 파일입니다. C++ 프로젝트면 **C로 컴파일**(확장자 `.c`) 하거나 `extern "C"` 처리.

---

## 지원 변환 종류(JXFORM_CODE)

`transupp.h`의 열거형(대표만 표기):

- `JXFORM_NONE`
- `JXFORM_FLIP_H`(**좌우반전**), `JXFORM_FLIP_V`(**상하반전**)
- `JXFORM_TRANSPOSE`(전치: x↔y)
- `JXFORM_TRANSVERSE`(대각 반전: 전치 후 좌우반전과 동치)
- `JXFORM_ROT_90`, `JXFORM_ROT_180`, `JXFORM_ROT_270`

추가 플래그:
- `perfect` : 변환이 **완벽 조건**일 때만 수행(아니면 실패 반환)
- `trim` : 남는 가장자리 **버림** 허용(손실 없는 의미에서의 ‘자연 크롭’)
- `force_grayscale` : 그레이스케일 강제(여기선 사용 안 함)
- `crop` + `crop_*` : **크롭** 파라미터(픽셀/MCU 단위, 아래 설명)

---

## 파이프라인 흐름 (jpegtran과 동일)

1) **소스 열기** → `jpeg_read_header()`
2) **계수 읽기** → `jpeg_read_coefficients()`
3) **변환 워크스페이스 요청** → `jtransform_request_workspace()`
4) **목표 압축기(dst) 초기화 & 핵심 매개변수 복사** → `jpeg_copy_critical_parameters()`
5) **(옵션) 크롭/회전에 따른 파라미터 조정** → `jtransform_adjust_parameters()`
6) **계수 쓰기 시작** → `jpeg_write_coefficients()`
7) **마커 복사**(EXIF/XMP/ICC/Adobe 등) → `jcopy_markers_execute()`
8) **변환 실행** → `jtransform_execute_transformation()`
9) **마무리** → `jpeg_finish_compress() / jpeg_finish_decompress()`

> **메타데이터 보존**: 앞서 만든 `EXIF/IPTC/XMP/ICC 재주입` 모듈을 그대로 쓰거나, `jcopy_markers_*` 헬퍼를 사용해도 됩니다.
> 고급 제어(프라이버시, Orientation 패치)는 **직접 재주입 방식**을 추천.

---

## 코드 — “손실 없는 회전/반전/크롭” 통합 함수

### 헤더/타입

```cpp
// LosslessJpeg.hpp
#pragma once
#include <string>
#include <jpeglib.h>

// transupp/jinclude 헤더 (C 모듈)
extern "C" {
#include "transupp.h"      // jtransform_*, jcopy_markers_* APIs
#include "jerror.h"

}

enum class LLJpegXform {
    None,
    Rot90, Rot180, Rot270,
    FlipH, FlipV,
    Transpose, Transverse
};

struct LLJpegCrop {
    bool   enable = false;
    // 크롭 사각형 (픽셀 단위 권장; MCU 단위도 가능)
    int    x = 0, y = 0, w = 0, h = 0;
    bool   useMCU = false; // true면 MCU 단위 좌표/크기
    // crop 정합성: transupp는 내부적으로 경계/사이즈 조정. trim/perfect와 조합.
};

struct LLJpegOptions {
    bool perfect = false;  // 완벽 조건 아닐 시 실패
    bool trim    = true;   // 잉여 MCU 버림 허용
    bool copyMarkersAll = true; // jcopy_markers_* 사용
};

// 성공 시 true
bool JpegLosslessTransform(const std::wstring& inPath,
                           const std::wstring& outPath,
                           LLJpegXform xform,
                           const LLJpegCrop* crop, // nullptr 허용
                           const LLJpegOptions& opt);
```

### 구현

```cpp
// LosslessJpeg.cpp
#include "LosslessJpeg.hpp"
#include <cstdio>
#include <algorithm>

static JXFORM_CODE ToJxform(LLJpegXform xf){
    switch(xf){
        case LLJpegXform::Rot90:      return JXFORM_ROT_90;
        case LLJpegXform::Rot180:     return JXFORM_ROT_180;
        case LLJpegXform::Rot270:     return JXFORM_ROT_270;
        case LLJpegXform::FlipH:      return JXFORM_FLIP_H;
        case LLJpegXform::FlipV:      return JXFORM_FLIP_V;
        case LLJpegXform::Transpose:  return JXFORM_TRANSPOSE;
        case LLJpegXform::Transverse: return JXFORM_TRANSVERSE;
        default:                      return JXFORM_NONE;
    }
}

static void SetupCrop(jpeg_transform_info& t, const LLJpegCrop& c){
    t.crop = TRUE;
    t.crop_width_set  = JCROP_POS;
    t.crop_height_set = JCROP_POS;
    t.crop_xoffset_set = JCROP_POS;
    t.crop_yoffset_set = JCROP_POS;

    t.crop_width  = c.w;
    t.crop_height = c.h;
    t.crop_xoffset = c.x;
    t.crop_yoffset = c.y;
    t.crop_units = c.useMCU ? JCROP_UNITS_MCU : JCROP_UNITS_PIXEL;
}

bool JpegLosslessTransform(const std::wstring& inPath,
                           const std::wstring& outPath,
                           LLJpegXform xform,
                           const LLJpegCrop* crop,
                           const LLJpegOptions& opt)
{
    FILE* fin=nullptr;  _wfopen_s(&fin,  inPath.c_str(),  L"rb");
    if(!fin) return false;
    FILE* fout=nullptr; _wfopen_s(&fout, outPath.c_str(), L"wb");
    if(!fout){ fclose(fin); return false; }

    jpeg_decompress_struct srcinfo{}; jpeg_error_mgr jsrcerr{};
    srcinfo.err = jpeg_std_error(&jsrcerr);
    jpeg_create_decompress(&srcinfo);
    jpeg_stdio_src(&srcinfo, fin);

    jpeg_compress_struct dstinfo{}; jpeg_error_mgr jdsterr{};
    dstinfo.err = jpeg_std_error(&jdsterr);
    jpeg_create_compress(&dstinfo);
    jpeg_stdio_dest(&dstinfo, fout);

    // 변환 옵션 설정
    jpeg_transform_info transformopt{};
    transformopt.transform = ToJxform(xform);
    transformopt.trim      = opt.trim ? TRUE : FALSE;
    transformopt.perfect   = opt.perfect ? TRUE : FALSE;
    transformopt.force_grayscale = FALSE;
    transformopt.crop = FALSE;

    if (crop && crop->enable){
        SetupCrop(transformopt, *crop);
    }

    // 메타 복사 옵션 (jpegtran API)
    JCOPY_OPTION copyopt = opt.copyMarkersAll ? JCOPYOPT_ALL : JCOPYOPT_NONE;
    jcopy_markers_setup(&srcinfo, copyopt);

    // 헤더 파싱
    if (jpeg_read_header(&srcinfo, TRUE) != JPEG_HEADER_OK){
        jpeg_destroy_compress(&dstinfo);
        jpeg_destroy_decompress(&srcinfo);
        fclose(fin); fclose(fout);
        return false;
    }

    // 워크스페이스 요청 (크롭/회전 위한 준비)
    jtransform_request_workspace(&srcinfo, &transformopt);

    // 계수 읽기(소스)
    jvirt_barray_ptr* src_coef_arrays = jpeg_read_coefficients(&srcinfo);

    // dst 핵심 파라미터 복사
    jpeg_copy_critical_parameters(&srcinfo, &dstinfo);

    // 파라미터 조정(변환/크롭 반영) → 목적지 계수 배열 반환
    jvirt_barray_ptr* dst_coef_arrays =
        jtransform_adjust_parameters(&srcinfo, &dstinfo, src_coef_arrays, &transformopt);

    // 목적지 계수 쓰기 시작
    jpeg_write_coefficients(&dstinfo, dst_coef_arrays);

    // 메타 복사
    jcopy_markers_execute(&srcinfo, &dstinfo, copyopt);

    // 변환 실행(실제 계수 재배열/반전 등)
    jtransform_execute_transformation(&srcinfo, &dstinfo, src_coef_arrays, &transformopt);

    // 완료
    jpeg_finish_compress(&dstinfo);
    jpeg_finish_decompress(&srcinfo);

    jpeg_destroy_compress(&dstinfo);
    jpeg_destroy_decompress(&srcinfo);

    fclose(fin); fclose(fout);
    return true;
}
```

---

## 사용 예제 & 상황

### EXIF Orientation **손실 없이 반영**

EXIF Orientation → jpegtran 매핑:

| EXIF | 의미                | jpegtran 변환           |
|------|---------------------|-------------------------|
| 1    | 정상                | 없음                    |
| 2    | 좌우 반전           | `FlipH`                |
| 3    | 180° 회전           | `Rot180`               |
| 4    | 상하 반전           | `FlipV`                |
| 5    | 전치 후 좌우반전    | `Transverse`           |
| 6    | 90° CW              | `Rot90`                |
| 7    | 대각반전(전치 후 상하)| `Transpose`         |
| 8    | 90° CCW             | `Rot270`               |

```cpp
// Orientation 값을 읽어왔다고 가정(이전 EXIF 파서 파트 참고)
int exifOrientation = 6; // 예: 6(90° CW)
LLJpegXform xf = LLJpegXform::Rot90;

LLJpegOptions opt;
opt.perfect = false; // 샘플링/크기 제약으로 perfect 실패할 수 있음
opt.trim = true;     // 잉여 MCU 버림 허용

JpegLosslessTransform(L"in.jpg", L"out.jpg", xf, nullptr, opt);

// 저장 후 EXIF Orientation=1로 패치 (메타 재주입 로직에서 처리)
```

> **Tip**: Orientation을 픽셀에 반영했으면, **EXIF Orientation 태그를 1로 수정**해 이중 회전을 방지하세요(앞선 메타 파트 참고).

---

### **회전 90°** (4:2:0에서 perfect)

- 이미지 폭/높이가 **MCU(16×16)** 배수이면 `perfect=true` 로 완전 보존
- 배수가 아니면 `trim=true` 로 **끝단 잘라내기**(실질적 크롭)

```cpp
LLJpegOptions o; o.perfect = true; o.trim = false; // 완벽 조건 강제
bool ok = JpegLosslessTransform(L"in420.jpg", L"rot90.jpg", LLJpegXform::Rot90, nullptr, o);
if (!ok) {
    // perfect 실패 → MCU 경계가 맞지 않음
    o.perfect = false; o.trim = true; // 가장자리 버리고 재시도
    JpegLosslessTransform(L"in420.jpg", L"rot90_trim.jpg", LLJpegXform::Rot90, nullptr, o);
}
```

---

### **수평 반전(H-Flip)** (웹캠 좌우 반전 교정 등)

```cpp
LLJpegOptions o; o.trim = true;
JpegLosslessTransform(L"cam.jpg", L"flipH.jpg", LLJpegXform::FlipH, nullptr, o);
```

---

### **MCU 단위 크롭** (절대 손실 없는 자르기)

- 4:2:0 샘플링에서 (x,y,w,h)를 **16의 배수**로 설정하면 **완전 무손실**
- transupp의 **픽셀 단위** 크롭을 써도 내부적으로 MCU 정렬/트림을 수행하지만,
  “완전 통제”가 필요하면 **MCU 단위**로 지정하세요.

```cpp
LLJpegCrop c;
c.enable = true;
c.useMCU = true; // MCU 단위 지정
c.x = 4;  c.y = 2;  // MCU 오프셋
c.w = 16; c.h = 20; // MCU 크기(예: 16x20 MCU 블록)

LLJpegOptions o; o.trim = true; o.perfect = true; // perfect는 MCU 크기로면 OK
JpegLosslessTransform(L"in420.jpg", L"crop_mcu.jpg", LLJpegXform::None, &c, o);
```

---

### **픽셀 단위 크롭** (내부에서 MCU 트림 허용)

```cpp
LLJpegCrop c;
c.enable = true;
c.useMCU = false; // 픽셀 단위
c.x = 37; c.y = 19; c.w = 800; c.h = 600;

LLJpegOptions o; o.trim = true; // MCU 경계 밖 픽셀은 버림
JpegLosslessTransform(L"in.jpg", L"crop.jpg", LLJpegXform::None, &c, o);
```

---

## 수학/제약(요약)

### **perfect 조건**(예: 90°/270° 회전)

- 폭/높이가 **MCU 크기의 배수**여야 **완전 보존**
- 4:2:0 → MCU=16×16 → `width % 16 == 0 && height % 16 == 0`
- 만족 못하면 **trim**으로 남는 가장자리를 **잘라내** 손실 없는 결과 생성(사실상 “자연 크롭”)

### 크롭의 무손실성

- **MCU 경계**로 정확히 잘라야 **진정한 무손실**
- 픽셀 단위로 지정 후 내부 정렬(또는 trim)도 `계수 복호화/재양자화 없음`의 의미에서 **손실 없음**이지만,
  **경계의 몇 픽셀은 버리는 효과**가 있으므로 “영역 보존” 측면에선 주의.

> 수식(개념)
- MCU 크기:
  \[
  W_{MCU} = 8 \cdot \max_i(H\_s^{(i)}),\quad
  H_{MCU} = 8 \cdot \max_i(V\_s^{(i)})
  \]
  (i는 컴포넌트 인덱스, H/V는 샘플링 팩터)
- perfect 회전 조건(90°/270°):
  \[
  W \equiv 0 \ (\mathrm{mod}\ W_{MCU}),\quad
  H \equiv 0 \ (\mathrm{mod}\ H_{MCU})
  \]

---

## 메타데이터와의 결합

- 위 예제는 `jcopy_markers_*` 로 **원본 마커(Exif/IPTC/XMP/ICC/Adobe)** 를 **그대로 복사**합니다.
- 이전 섹션의 **정교한 정책 필터(프라이버시/GPS 제거, Orientation=1 패치)** 를 사용하려면
  - `jcopy_markers_*` 대신 **수동 재주입** 경로(`jpeg_write_marker`)를 사용
  - 또는 변환 후 **EXIF 블록만 교체**
- **Orientation 처리 플로우**(권장):
  1) 원본 EXIF Orientation 읽기
  2) **해당하는 jpegtran 변환 수행**
  3) 저장 시 EXIF Orientation **1로 패치** (중복 회전 방지)

---

## 흔한 에러/디버그 포인트

- `perfect` 실패: 샘플링/크기 → MCU 배수 불일치. `trim=true`로 재시도.
- 크롭이 기대와 다르게 잘림: 픽셀 단위 지정 시 내부 MCU 정렬 영향. **MCU 단위**로 지정해 정확 제어.
- CMYK/YCCK 파일: 이 파이프라인은 **색공간 변환 없이 계수만 재배열**하므로 CMYK/YCCK도 손실 없이 변환 가능. 표시용은 별도(CMYK→RGB) 처리 필요(앞 장 참고).
- 프로그레시브 JPEG: transupp는 **진행형(progressive)** 도 지원(계수 레벨). 단, 일부 특수 JPEG(희귀 조합)에서 제한 있을 수 있음.
- 산술 부호화(arithmetic) JPEG: 빌드 옵션에 따라 지원/미지원. 입력이 산술 코딩이면 **디코더 지원 필요**.

---

## 간단 CLI 예시(테스트 도구)

```cpp
// lljpeg_cli.cpp
#include "LosslessJpeg.hpp"
#include <iostream>

int wmain(int argc, wchar_t** argv){
    if (argc < 4){
        std::wcout << L"usage: lljpeg <in> <out> <op> [args]\n";
        std::wcout << L"op: rot90|rot180|rot270|fliph|flipv|transpose|transverse|crop\n";
        std::wcout << L"crop args: x y w h [mcu=0/1]\n";
        return 0;
    }
    std::wstring in = argv[1], out = argv[2], op = argv[3];

    LLJpegXform xf = LLJpegXform::None;
    if (op==L"rot90") xf=LLJpegXform::Rot90;
    else if (op==L"rot180") xf=LLJpegXform::Rot180;
    else if (op==L"rot270") xf=LLJpegXform::Rot270;
    else if (op==L"fliph") xf=LLJpegXform::FlipH;
    else if (op==L"flipv") xf=LLJpegXform::FlipV;
    else if (op==L"transpose") xf=LLJpegXform::Transpose;
    else if (op==L"transverse") xf=LLJpegXform::Transverse;

    LLJpegCrop crop{}; LLJpegCrop* pc=nullptr;
    if (op==L"crop" && argc>=8){
        crop.enable=true; crop.x=_wtoi(argv[4]); crop.y=_wtoi(argv[5]);
        crop.w=_wtoi(argv[6]); crop.h=_wtoi(argv[7]);
        crop.useMCU = (argc>=9 ? (_wtoi(argv[8])!=0) : 0);
        pc=&crop;
    }

    LLJpegOptions opt; opt.perfect=false; opt.trim=true; opt.copyMarkersAll=true;

    bool ok = JpegLosslessTransform(in, out, xf, pc, opt);
    std::wcout << (ok ? L"OK\n" : L"FAILED\n");
    return ok?0:1;
}
```

---

## 테스트 시나리오 체크리스트

- [ ] 4:2:0 JPEG에 **rot90 perfect**: 폭/높이를 16의 배수로 맞춘 샘플로 성공 확인
- [ ] **trim vs no-trim** 비교: rot90에서 가장자리 차이 확인
- [ ] **픽셀/MCU 크롭**: 결과 크기와 좌표 정합 검증
- [ ] **EXIF Orientation** 보정: 6, 8, 3 등 케이스 모두 수행 후 Orientation=1 패치
- [ ] **CMYK/YCCK** 샘플도 손실 없이 변환되는지(표시용 색은 별도)
- [ ] **메타데이터 보존**: 이전 섹션 로직과 결합하여 EXIF/XMP/ICC 유지 확인

---

## 결론

- `transupp.h`(jpegtran 엔진)는 JPEG **계수 레벨**에서 **무손실 변환**을 제공합니다.
- **회전/반전/전치/크롭**을 조합하고, `perfect/trim`으로 **MCU 제약**을 유연하게 처리하세요.
- **메타데이터 보존 + Orientation 패치 + ICC/CMYK 대응**과 결합하면,
  “**품질 0 손실, 메타 유지, 정확한 색**”의 **프로덕션급 이미지 파이프라인**을 구축할 수 있습니다.
