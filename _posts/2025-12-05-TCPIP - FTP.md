---
layout: post
title: TCPIP - FTP
date: 2025-12-05 20:25:23 +0900
category: TCPIP
---
# 파일 전송 프로토콜 (FTP)

## FTP 개요, 역사 및 표준

### FTP의 설계 철학과 역사적 배경
파일 전송 프로토콜(File Transfer Protocol, FTP)은 1971년 ARPANET에서 처음 개발되어 현재까지 사용되는 가장 오래된 인터넷 프로토콜 중 하나입니다. FTP는 신뢰성 있는 파일 전송을 위한 완전한 기능의 솔루션으로 설계되었으며, "모든 파일 전송 요구사항을 충족하는 통합 프로토콜"이라는 철학을 따릅니다.

### 역사적 발전
FTP의 역사적 발전:
- **1971년**: RFC 114로 최초 명세화 (ARPANET 시대)
- **1973년**: 현재의 FTP 모델 도입 (RFC 354)
- **1985년**: RFC 959으로 현대 FTP 표준 확립
- **1990년대**: 보안 확장(FTPS) 및 확장 기능 추가
- **2000년대**: IPv6 및 현대적 확장 지원

### 표준 문서 계보
| RFC 번호 | 연도 | 주요 내용 | 상태 |
|----------|------|-----------|------|
| RFC 959  | 1985 | FTP 사양 (기본) | 인터넷 표준 |
| RFC 2228 | 1997 | 보안 확장 | 제안 표준 |
| RFC 2389 | 1998 | 특징 협상 메커니즘 | 제안 표준 |
| RFC 2428 | 1998 | IPv6 및 NAT 확장 | 제안 표준 |
| RFC 3659 | 2007 | 확장 파일 전송 | 제안 표준 |

## FTP 개념과 일반 동작

### FTP 운영 모델
FTP의 가장 독특한 특징은 제어 연결과 데이터 연결을 분리한 이중 연결 아키텍처입니다:

```
클라이언트                     서버
    | ----- 제어 연결 (포트 21) -----> |
    | (명령어/응답 교환)               |
    |                                  |
    | ----- 데이터 연결 ---- 생성 ---> |
    | (실제 파일 전송)                 |
```

### 핵심 구성 요소
1. **PI (Protocol Interpreter)**: 제어 연결 관리
2. **DTP (Data Transfer Process)**: 데이터 연결 관리
3. **FTP 명령어**: 클라이언트 → 서버 (텍스트 기반)
4. **응답 코드**: 서버 → 클라이언트 (3자리 숫자 코드)

### 세션 상태 관리
FTP는 상태 유지(stateful) 프로토콜로 다음과 같은 상태를 유지합니다:
- 로그인 상태 유지
- 현재 작업 디렉토리 추적
- 전송 모드 설정 저장
- 데이터 연결 상태 관리

## FTP 연결 설정 및 인증

### 연결 설정 과정
```
1. TCP 연결: 클라이언트 → 서버 (포트 21)
2. 서버 환영 메시지: "220 Service ready"
3. 사용자 인증:
   USER username
   PASS password
4. 성공 응답: "230 User logged in"
```

### 익명 FTP 접근
공개 파일 배포를 위한 메커니즘:
- 사용자: anonymous 또는 ftp
- 비밀번호: 이메일 주소 또는 아무 값

보안 관행:
- 익명 사용자 제한된 디렉토리만 접근
- 쓰기 권한 제한 또는 완전 차단
- 업로드된 파일 검증

### 인증 예시
```
클라이언트: USER anonymous
서버: 331 User name okay, need password
클라이언트: PASS guest@example.com
서버: 230 User logged in
```

## FTP 데이터 연결 관리

### 데이터 연결 유형

#### 액티브 모드 (기본/일반)
액티브 모드에서 클라이언트는 데이터 수신을 위한 포트를 개방하고, 서버는 해당 포트로 연결을 시작합니다:

```
1. 클라이언트가 임시 포트 열기 (예: 1024)
2. 클라이언트: PORT 192,168,1,100,4,0 (192.168.1.100:1024)
   (포트 계산: 4×256 + 0 = 1024)
3. 서버: 포트 20에서 → 클라이언트 1024포트로 연결
```

문제점:
- 클라이언트 측 방화벽 차단 가능성
- NAT 환경에서 문제 발생

#### 패시브 모드 (PASV)
패시브 모드에서 서버는 데이터 수신을 위한 포트를 개방하고, 클라이언트는 해당 포트로 연결을 시작합니다:

```
1. 클라이언트: PASV
2. 서버: 227 Entering Passive Mode (192,168,1,1,4,1)
   (IP: 192.168.1.1, 포트: 4×256 + 1 = 1025)
3. 클라이언트: 서버의 1025포트로 연결
```

장점:
- 클라이언트 측 방화벽 문제 해결
- NAT 환경에서 더 나은 호환성

### 포트 사용 요약
액티브 모드:
- 서버 데이터 포트: 20 (고정)
- 클라이언트 데이터 포트: 임시 포트 (>1023)

패시브 모드:
- 서버 데이터 포트: 임시 포트 (>1023)
- 클라이언트 데이터 포트: 임시 포트 (>1023)

### 현대적 관행
대부분의 현대 FTP 클라이언트는 기본적으로 패시브 모드를 사용하며, 이는 방화벽/NAT 환경에서 더 나은 호환성을 제공합니다. FTP 서버 구성 시 패시브 포트 범위를 지정해야 합니다.

## FTP 데이터 통신 및 전송 모드

### 데이터 전송 절차
```
1. 제어 연결에서 전송 명령어 (RETR, STOR 등)
2. 데이터 연결 설정 (액티브/패시브)
3. 실제 데이터 전송
4. 데이터 연결 종료
5. 제어 연결에서 완료 확인
```

### 주요 전송 명령어
- 파일 다운로드: `RETR filename`
- 파일 업로드: `STOR filename`
- 디렉토리 목록: `LIST` (또는 `NLST`)
- 디렉토리 변경: `CWD directory`
- 현재 디렉토리 확인: `PWD`
- 파일 삭제: `DELE filename`
- 파일 이름 변경: `RNFR oldname` → `RNTO newname`

### FTP 응답 코드 체계
FTP 응답 코드는 3자리 숫자로 구성됩니다:
- **1xx**: 긍정적 예비 응답 (작업 진행 중)
- **2xx**: 긍정적 완료 응답 (작업 성공)
- **3xx**: 긍정적 중간 응답 (추가 정보 필요)
- **4xx**: 일시적 부정적 완료 응답 (일시적 실패)
- **5xx**: 영구적 부정적 완료 응답 (영구적 실패)

#### 주요 응답 코드
| 코드 | 의미 | 설명 |
|------|------|------|
| 125 | 데이터 연결 열림 | 데이터 전송 준비 완료 |
| 150 | 파일 상태 확인 | 파일 전송 준비 중 |
| 200 | 명령어 성공 | |
| 220 | 서비스 준비 | 새 사용자 접속 가능 |
| 221 | 서비스 종료 | 제어 연결 종료 |
| 226 | 전송 완료 | 데이터 연결 종료 |
| 227 | 패시브 모드 진입 | 패시브 모드 포트 정보 |
| 230 | 사용자 로그인 | 인증 성공 |
| 250 | 요청된 파일 작업 완료 | |
| 331 | 사용자명 확인 | 비밀번호 필요 |
| 425 | 데이터 연결 열 수 없음 | |
| 426 | 연결 종료, 전송 중단 | |
| 450 | 요청된 파일 작업 불가 | 파일 사용 중 등 |
| 500 | 구문 오류 | 인식할 수 없는 명령어 |
| 530 | 로그인되지 않음 | |
| 550 | 요청된 작업 불가 | 파일 없음, 권한 없음 |

## FTP 데이터 표현

### 데이터 타입 (TYPE 명령어)

#### 1. ASCII (A) 모드
텍스트 파일 전송을 위한 모드:
```
클라이언트: TYPE A
서버: 200 Type set to A
```

특징:
- 줄 끝 변환 수행 (CRLF ↔ 시스템별 줄 끝)
- 예: Windows(CRLF) ↔ Unix(LF) 변환
- 사용처: 텍스트 파일, 소스 코드, 구성 파일

#### 2. 이미지/바이너리 (I) 모드
바이너리 파일 전송을 위한 모드:
```
클라이언트: TYPE I
서버: 200 Type set to I
```

특징:
- 원본 그대로 전송 (변환 없음)
- 모든 바이트가 변경 없이 전송됨
- 사용처: 실행 파일, 이미지, 압축 파일, 동영상

#### 3. EBCDIC (E) 모드
메인프레임 시스템용 모드 (현재 거의 사용 안 함)

#### 4. 로컬 (L) 모드
사용자 정의 바이트 크기 모드

### 데이터 구조 (STRU 명령어)

#### 1. 파일 구조 (F)
기본 구조, 연속된 바이트 스트림:
```
클라이언트: STRU F
서버: 200 Structure set to F
```

#### 2. 레코드 구조 (R)
레코드 기반 파일 (메인프레임):
```
클라이언트: STRU R
서버: 200 Structure set to R
```

#### 3. 페이지 구조 (P)
페이지 기반 파일 (TOPS-20):
```
클라이언트: STRU P
서버: 200 Structure set to P
```

### 전송 모드 (MODE 명령어)

#### 1. 스트림 모드 (S)
기본 모드, 데이터를 연속 스트림으로 전송:
```
클라이언트: MODE S
서버: 200 Mode set to S
```

특징:
- 데이터 끝 표시: 연결 종료로 표시
- 가장 효율적이고 널리 사용됨

#### 2. 블록 모드 (B)
데이터를 블록으로 분할하여 전송:
```
클라이언트: MODE B
서버: 200 Mode set to B
```

특징:
- 각 블록에 헤더 포함
- 재시작 지점 표시 가능
- 신뢰성 높지만 오버헤드 있음

#### 3. 압축 모드 (C)
단순한 런-렝스 압축 사용:
```
클라이언트: MODE C
서버: 200 Mode set to C
```

특징:
- 효율성 낮아 현대에 거의 사용 안 함

### 형식 제어 (FORM 명령어)
- **비프린트 (N)**: 기본, 형식 제어 없음
- **텔레타입 (T)**: 텔레타입 형식 제어
- **카리지 리턴 (C)**: ASA 캐리지 리턴 제어

### 실제 파일 전송 예시

#### 텍스트 파일 전송 (Windows → Unix):
```
1. 클라이언트: TYPE A
2. 서버: 200 Type set to A
3. 클라이언트: RETR document.txt
4. 서버: 150 Opening ASCII mode data connection
5. 서버: CRLF → LF 변환 수행
6. 서버: 226 Transfer complete
```

#### 바이너리 파일 전송:
```
1. 클라이언트: TYPE I
2. 서버: 200 Type set to I
3. 클라이언트: RETR image.jpg
4. 서버: 150 Opening BINARY mode data connection
5. 서버: 데이터 그대로 전송 (변환 없음)
6. 서버: 226 Transfer complete
```

## FTP 확장 기능

### 확장 파일 전송 (RFC 3659)

#### 파일 크기 확인 (SIZE)
파일 크기를 확인하는 명령어:
```
클라이언트: SIZE filename
서버: 213 1048576  (1MB 파일)
```

#### 파일 수정 시간 (MDTM)
파일 수정 시간 확인 및 설정:
```
클라이언트: MDTM filename
서버: 213 20240101120000  (2024-01-01 12:00:00)

클라이언트: MDTM 20240101120000 filename
서버: 213 File modification time set
```

#### 전송 재개 (REST)
전송 중단 후 재개 지점 지정:
```
클라이언트: REST 4096
서버: 350 Restarting at 4096. Send STORE or RETRIEVE
클라이언트: RETR largefile.zip
서버: 150 Opening BINARY mode data connection
```

### 특징 협상 (FEAT)
서버 지원 기능 확인:
```
클라이언트: FEAT
서버: 211-Extensions supported:
      MDTM
      SIZE
      REST STREAM
      UTF8
      ...
서버: 211 End
```

### UTF-8 지원 (OPTS UTF8)
유니코드 파일명 지원:
```
클라이언트: OPTS UTF8 ON
서버: 200 UTF8 set to on
```

## FTP 보안 확장

### FTPS (FTP over SSL/TLS)
FTP의 보안 문제를 해결하기 위한 확장:

#### 암호화 방식
1. **암시적 FTPS**: 기본적으로 SSL/TLS 사용 (포트 990)
2. **명시적 FTPS**: STARTTLS 명령어로 암호화 시작 (포트 21)

#### 보안 통신 설정
```
1. 클라이언트: AUTH TLS
2. 서버: 234 Proceed with negotiation
3. SSL/TLS 핸드셰이크 수행
4. 클라이언트: PBSZ 0
5. 서버: 200 PBSZ set to 0
6. 클라이언트: PROT P
7. 서버: 200 Protection set to Private
```

#### 보안 레벨
- **C (Clear)**: 암호화 없음
- **S (Safe)**: 암호화만 수행
- **E (Confidential)**: 암호화와 무결성 검사
- **P (Private)**: 완전한 보안 (암호화 + 무결성 + 압축)

### SFTP (SSH File Transfer Protocol)
참고: SFTP는 FTP와 다른 프로토콜로, SSH를 통해 파일을 전송합니다. FTP와 혼동하지 않아야 합니다.

## FTP 성능 최적화

### 버퍼링 및 파이프라이닝
효율적인 전송을 위한 기법:
- 양방향 버퍼 사용
- 여러 명령어 연속 전송
- 데이터 압축 (애플리케이션 수준)

### 대용량 파일 전송 최적화
1. **블록 사이즈 조정**: 네트워크 MTU에 맞춤
2. **윈도우 사이즈 최적화**: TCP 윈도우 사이즈 조정
3. **병렬 전송**: 여러 파일 동시 전송

### 모니터링 및 로깅
FTP 전송 모니터링:
- 전송 진행률 표시
- 대역폭 사용량 모니터링
- 오류 로깅 및 진단

## FTP 클라이언트와 서버 구현

### FTP 클라이언트 아키텍처
일반적인 FTP 클라이언트 구성:
```
사용자 인터페이스
    ↓
FTP 프로토콜 엔진
    ↓
네트워크 계층 (TCP/IP)
    ↓
소켓 인터페이스
```

### FTP 서버 아키텍처
FTP 서버의 주요 구성 요소:
```
클라이언트 연결 관리자
    ↓
인증 및 권한 관리
    ↓
세션 상태 관리자
    ↓
데이터 전송 관리자
    ↓
파일 시스템 인터페이스
```

### FTP 서버 구성 예시 (vsftpd)
```bash
# vsftpd 구성 파일 예시
listen=YES
anonymous_enable=YES
local_enable=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_std_format=YES
pasv_min_port=40000
pasv_max_port=50000
```

## FTP의 현대적 대안

### FTP의 제한점
1. **보안 취약성**: 평문 전송, 인증 정보 노출
2. **방화벽 문제**: 액티브 모드의 연결 문제
3. **NAT 호환성**: IP 주소 변환 문제
4. **유니코드 지원 제한**: 전통적 ASCII 중심

### 현대적 대안 프로토콜

#### 1. SFTP (SSH File Transfer Protocol)
- SSH를 통한 암호화된 파일 전송
- 단일 포트(22) 사용
- 강력한 인증 및 암호화
- 파일 권한 및 속성 보존

#### 2. FTPS (FTP over SSL/TLS)
- FTP의 보안 확장
- SSL/TLS 암호화 지원
- 기존 FTP 호환성 유지

#### 3. HTTPS/WebDAV
- 웹 기반 파일 전송
- HTTP/HTTPS 프로토콜 사용
- 브라우저 호환성

#### 4. SCP (Secure Copy)
- SSH 기반 간단한 파일 복사
- 명령어 라인 중심
- 빠르고 간단한 사용

### 선택 가이드
| 요구사항 | 권장 프로토콜 | 이유 |
|----------|---------------|------|
| 최대 보안 | SFTP | 강력한 암호화 및 인증 |
| 레거시 호환 | FTPS | 기존 FTP와 호환 |
| 웹 통합 | HTTPS/WebDAV | 브라우저 접근 용이 |
| 자동화 | SCP | 스크립트 통합 용이 |
| 대용량 전송 | FTP/FTPS | 효율적 대용량 처리 |

## 결론

FTP는 50년이 넘는 역사를 가진 프로토콜이지만, 그 기본 설계 원리는 현대적 파일 전송의 근간이 되었습니다. 제어와 데이터 연결의 분리, 다양한 전송 모드 지원, 이기종 시스템 간의 호환성 보장은 모두 오늘날의 파일 전송 시스템에 깊은 영향을 미쳤습니다.

FTP의 가장 뛰어난 설계 특징은 **이중 연결 아키텍처**입니다. 이는 단순한 기술적 선택을 넘어, 파일 전송의 본질적 특성(제어 정보와 대용량 데이터의 분리)을 깊이 이해한 결과입니다. 제어 연결을 통해 실시간 명령어 교환이 가능하면서도, 데이터 연결을 통한 효율적 대용량 전송이 가능한 이 구조는 수많은 후속 프로토콜에 영혼을 주었습니다.

액티브와 패시브 모드의 구분은 네트워크 환경의 변화에 적응하는 FTP의 유연성을 보여줍니다. 초기 클라이언트-서버 모델에서 발전하여 방화벽과 NAT가 보편화된 현대 인터넷에서도 작동할 수 있도록 한 이러한 적응력은 프로토콜의 장수 비결 중 하나입니다.

데이터 표현 시스템(TYPE, STRU, MODE)은 FTP가 다양한 컴퓨팅 환경을 포괄하려는 야심을 반영합니다. ASCII와 이진 모드의 구분은 텍스트와 바이너리 데이터의 근본적 차이를 인식한 것이며, EBCDIC 지원은 당시 주류였던 메인프레임 시스템과의 호환성을 고려한 실용적 결정이었습니다.

현대적으로 FTP는 보안 취약성(평문 전송)과 복잡성 때문에 점차 SFTP, HTTPS, 클라우드 스토리지 서비스로 대체되고 있지만, 여전히 내부 네트워크, 레거시 시스템, 특수 목적 파일 전송에서 중요한 역할을 합니다. 특히 FTPS(FTP over SSL/TLS)와 같은 보안 확장은 프로토콜의 지속적 적응 능력을 입증합니다.

FTP의 진정한 유산은 파일 전송이라는 복잡한 작업을 체계적으로 분해하고 구조화한 방법론에 있습니다. 이는 단순한 프로토콜 지식을 넘어, 복잡한 시스템을 설계할 때 고려해야 할 다양한 요구사항(성능, 호환성, 보안, 사용 편의성) 사이의 균형을 찾는 방법을 가르쳐 줍니다. 이러한 설계 사고방식은 모든 시스템 아키텍트와 엔지니어에게 귀중한 교훈을 제공합니다.

최종적으로, FTP는 기술의 진화 과정에서 중요한 이정표로서, 단순함과 복잡성, 호환성과 혁신, 실용성과 이상 사이의 지속적인 균형 추구를 보여줍니다. 이것이 FTP가 시대를 초월하여 여전히 연구되고 학습되는 이유입니다.