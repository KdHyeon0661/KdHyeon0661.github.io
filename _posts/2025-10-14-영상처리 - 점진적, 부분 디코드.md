---
layout: post
title: 영상처리 - 점진적/부분 디코드
date: 2025-10-14 14:25:23 +0900
category: 영상처리
---
# 점진적/부분 디코드(썸네일/ROI/스케일) — **libjpeg(-turbo)로 1/2 · 1/4 · 1/8 스케일 디코딩 & ROI(crop/skip) 활용**

> 목표  
> - 대용량 JPEG를 **초고속 미리보기**로 보여주기 위해 **IDCT 스케일링**(1/2, 1/4, 1/8)과 **부분 디코드(ROI)** 를 결합  
> - 갤러리/스크롤/타일 보기에서 **메모리/연산량**을 획기적으로 절감  
> - (옵션) **프로그레시브 JPEG**는 **coarse→fine** 점진 디스플레이  
> - 예제는 **libjpeg(-turbo)** + C++ + `IppDib(BGRA32)` 기준.  
> - 코드 블록은 모두 한 번만 ```로 감쌉니다.

---

## 0) 배경지식 — 왜 “스케일 디코드/ROI”가 빠른가?

- libjpeg 계열은 **IDCT 단계 자체를 축소(Scaling)** 해서 **1/2, 1/4, 1/8** 해상도로 바로 복원할 수 있어요.  
  즉, **원본을 전부 디코드한 뒤 리사이즈**하는 게 아니라, **디코드 자체가 작아진 해상도로** 일어나므로  
  연산량이 대략 \( 1/s^2 \) (s = 2, 4, 8)에 비례해 줄어듭니다:
  \[
  \text{Ops}(s) \approx \frac{W \times H}{s^2}
  \]
- **ROI(Region of Interest)** 는 **필요한 영역만** 디코드하도록 `jpeg_crop_scanline`(수평)과  
  `jpeg_skip_scanlines` 또는 **행 버리기**(수직)를 사용합니다.  
  전체를 디코드 후 잘라내는 것보다 **I/O/CPU** 를 크게 줄입니다.

> 스케일 지원: 1/1, 1/2, 1/4, 1/8 (정확히 이 4단계만 하드웨어/IDCT 레벨에서 효율적)  
> ROI 지원: libjpeg v8 API(또는 libjpeg-turbo의 v8 호환 빌드)에서 `jpeg_crop_scanline`, `jpeg_skip_scanlines` 가 제공됨.  
> 빌드에 따라 없을 수도 있으므로 **폴백** 구현을 함께 제공하면 안전합니다.

---

## 1) 준비 — 빌드 & 런타임 팁

- vcpkg:
  ```powershell
  .\vcpkg\vcpkg install libjpeg-turbo:x64-windows
  ```
- 속도 지향 옵션(권장):
  - `cinfo.dct_method = JDCT_IFAST;`
  - `cinfo.do_fancy_upsampling = FALSE;` (특히 축소 디코드 시 체감 큼)
- 출력 색공간:
  - 표준: `JCS_RGB` → BGRA로 직접 포장
  - libjpeg-turbo 확장 색공간이 있다면(컴파일 시 `JCS_EXTENSIONS`) `JCS_EXT_BGRX` 등을 사용해 BGRA 복사를 줄일 수 있음 (아래 코드에 선택 경로 포함)

---

## 2) **스케일 디코드**(1/2 · 1/4 · 1/8) — 썸네일/타일에 최적

### 2.1 API 핵심
- `cinfo.scale_num = 1; cinfo.scale_denom = {1,2,4,8};`
- `jpeg_read_header()` **이후**, `jpeg_start_decompress()` **이전**에 설정
- `cinfo.output_width`, `cinfo.output_height`가 **스케일된 값**으로 확정됨

### 2.2 예제 — 1/4 스케일로 BGRA32 디코드
```cpp
#include <jpeglib.h>
#include <vector>
#include <string>
#include <cstdio>
#include <algorithm>
#include "IppDib.h"

bool DecodeJPEG_Scaled(const std::wstring& path, int denom /*1|2|4|8*/, IppDib& out)
{
    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"rb");
    if(!fp) return false;

    jpeg_decompress_struct cinfo{}; jpeg_error_mgr jerr{};
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    jpeg_stdio_src(&cinfo, fp);

    if (jpeg_read_header(&cinfo, TRUE) != JPEG_HEADER_OK){
        jpeg_destroy_decompress(&cinfo); fclose(fp); return false;
    }

    // 1) 스케일 설정
    cinfo.scale_num = 1;
    cinfo.scale_denom = (denom==2||denom==4||denom==8)? denom : 1;

    // 속도 지향
    cinfo.dct_method = JDCT_IFAST;
    cinfo.do_fancy_upsampling = FALSE;

    // 2) 출력 색공간 설정
#ifdef JCS_EXTENSIONS
    cinfo.out_color_space = JCS_EXT_BGRX; // libjpeg-turbo 확장 (B,G,R,X)
#else
    cinfo.out_color_space = JCS_RGB;      // 표준 경로
#endif

    jpeg_start_decompress(&cinfo);

    const int W = cinfo.output_width;
    const int H = cinfo.output_height;
    const int C = cinfo.output_components; // turbo 확장 경로면 4, 표준 RGB면 3

    out.create(W, H, 32);

    std::vector<uint8_t> row(W * C);
    while (cinfo.output_scanline < cinfo.output_height){
        JSAMPROW rp = row.data();
        jpeg_read_scanlines(&cinfo, &rp, 1);

        uint8_t* dst = (uint8_t*)out.bits() + (size_t)(cinfo.output_scanline-1)*out.stride();

#ifdef JCS_EXTENSIONS
        // BGRX → BGRA(=X 무시 후 A=255)
        for (int x=0;x<W;++x){
            dst[x*4+0]=row[x*4+0];
            dst[x*4+1]=row[x*4+1];
            dst[x*4+2]=row[x*4+2];
            dst[x*4+3]=255;
        }
#else
        // RGB → BGRA
        for (int x=0;x<W;++x){
            uint8_t R=row[x*3+0], G=row[x*3+1], B=row[x*3+2];
            dst[x*4+0]=B; dst[x*4+1]=G; dst[x*4+2]=R; dst[x*4+3]=255;
        }
#endif
    }

    jpeg_finish_decompress(&cinfo);
    jpeg_destroy_decompress(&cinfo);
    fclose(fp);
    return true;
}
```

> **실전 팁**  
> - 갤러리 썸네일(최대 한 변 256px 등)은 **1/4** 또는 **1/8** 디코드가 체감 성능 최고.  
> - 큰 프리뷰(예: 긴 변 1024px)는 **1/2** 디코드가 적합. 이후 필요 시 원본 해상도로 **지연 로딩**.

---

## 3) **부분 디코드(ROI)** — 수평 crop + 수직 skip

### 3.1 핵심 흐름
- **수평 ROI**: `jpeg_crop_scanline(&cinfo, &xoffset, &width)`  
  - 호출 시점: `jpeg_read_header()` 이후, **`jpeg_start_decompress()` 이전**.  
  - JPEG 내부 제약(iMCU 경계)에 맞게 `xoffset/width` 가 **조정**되어 돌아옵니다.  
  - 이후 `cinfo.output_width` 는 **ROI 폭**으로 바뀝니다.
- **수직 ROI**: `jpeg_skip_scanlines(&cinfo, rows_to_skip)` 또는  
  **행을 읽어 버리기**(폴백). 호출 시점은 **디코드 루프 중**.

> **버전 호환**  
> - `jpeg_crop_scanline`/`jpeg_skip_scanlines` 는 **v8 API**(또는 turbo v8 호환 빌드).  
> - 없는 빌드에서는 **수평은 전행 디코드 후 서브코피**, **수직은 행을 읽어서 버리기** 로 폴백.

### 3.2 예제 — ROI + 스케일 결합(갤러리 중앙 타일만)
```cpp
#include <jpeglib.h>
#include <vector>
#include <string>
#include <cstdio>
#include "IppDib.h"

struct ROI { int x, y, w, h; }; // 원하는 ROI(원본 좌표계)
enum class ScaleDen { S1=1, S2=2, S4=4, S8=8 };

bool DecodeJPEG_ROI_Scaled(const std::wstring& path, ROI roi, ScaleDen sden, IppDib& out)
{
    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"rb");
    if(!fp) return false;

    jpeg_decompress_struct c{}; jpeg_error_mgr jerr{};
    c.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&c);
    jpeg_stdio_src(&c, fp);

    if (jpeg_read_header(&c, TRUE) != JPEG_HEADER_OK){
        jpeg_destroy_decompress(&c); fclose(fp); return false;
    }

    // 1) 스케일 설정
    c.scale_num = 1; c.scale_denom = (int)sden;

    // 2) 수평 crop 시도 (v8/turbo v8호환 빌드에서만)
    JDIMENSION xoff = (roi.x >= 0 ? (JDIMENSION)roi.x : 0);
    JDIMENSION reqW = (roi.w > 0 ? (JDIMENSION)roi.w : c.image_width);
#if JPEG_LIB_VERSION >= 80
    jpeg_crop_scanline(&c, &xoff, &reqW); // 내부적으로 iMCU 경계에 맞춰 조정
    // 주의: jpeg_crop_scanline 호출 후 c.output_width는 아직 모름(스타트 후 확정)
#endif

    // 속도 지향
    c.dct_method = JDCT_IFAST;
    c.do_fancy_upsampling = FALSE;
#ifdef JCS_EXTENSIONS
    c.out_color_space = JCS_EXT_BGRX;
#else
    c.out_color_space = JCS_RGB;
#endif

    jpeg_start_decompress(&c);

    // 3) 수직 skip (상단 roi.y 만큼)
    int skipTop = std::max(0, roi.y);
#if JPEG_LIB_VERSION >= 80
    if (skipTop > 0) jpeg_skip_scanlines(&c, (JDIMENSION)skipTop);
#else
    // 폴백: skipTop 줄만 읽어 버리기
    std::vector<uint8_t> dummy(c.output_width * c.output_components);
    while (skipTop-- > 0 && c.output_scanline < c.output_height){
        JSAMPROW rp = dummy.data();
        jpeg_read_scanlines(&c, &rp, 1);
    }
#endif

    // 4) 실제 출력 크기(스케일·crop 적용 결과)
    int W = c.output_width;
    int H = std::min<int>(c.output_height - c.output_scanline, roi.h > 0 ? roi.h : (int)c.output_height);

    out.create(W, H, 32);

    std::vector<uint8_t> row(W * c.output_components);
    int written = 0;
    while (c.output_scanline < c.output_height && written < H){
        JSAMPROW rp = row.data();
        jpeg_read_scanlines(&c, &rp, 1);

        uint8_t* dst = (uint8_t*)out.bits() + (size_t)written*out.stride();
#ifdef JCS_EXTENSIONS
        for (int x=0;x<W;++x){
            dst[x*4+0]=row[x*4+0];
            dst[x*4+1]=row[x*4+1];
            dst[x*4+2]=row[x*4+2];
            dst[x*4+3]=255;
        }
#else
        for (int x=0;x<W;++x){
            uint8_t R=row[x*3+0], G=row[x*3+1], B=row[x*3+2];
            dst[x*4+0]=B; dst[x*4+1]=G; dst[x*4+2]=R; dst[x*4+3]=255;
        }
#endif
        ++written;
    }

    jpeg_finish_decompress(&c);
    jpeg_destroy_decompress(&c);
    fclose(fp);
    return true;
}
```

> **주의**  
> - `jpeg_crop_scanline` 은 **수평**만 다룹니다. 수직은 `jpeg_skip_scanlines`(있으면) 또는 **행 버리기**.  
> - ROI와 스케일을 함께 쓰면, **ROI 좌표**도 **스케일링 결과에 맞춰** 내부적으로 정렬/절단됩니다(정확치 않은 픽셀 경계는 인근으로 조정될 수 있음).

---

## 4) **프로그레시브 JPEG** — 점진적(스캔별) 디스플레이

프로그레시브 JPEG는 **여러 스캔**으로 구성되어, **대략적** → **정밀** 순서로 디코드됩니다.  
libjpeg는 **buffered-image** 모드로 “스캔 단위” 출력이 가능합니다:

### 4.1 흐름
1) `jpeg_read_header()`  
2) `cinfo.buffered_image = TRUE;`  
3) `jpeg_start_decompress()`  
4) `while (!jpeg_input_complete(&cinfo)) {`
   - `jpeg_consume_input(&cinfo)` 로 입력 전진
   - 새 스캔 준비 시 `jpeg_start_output(&cinfo, cinfo.output_scan_number)`  
   - **한 번 전체 프레임**을 스캔라인 루프로 읽어 **“거친 프리뷰”** 제공  
   - `jpeg_finish_output(&cinfo)`  
  `}`  
5) 마지막 스캔까지 출력 끝나면 `jpeg_finish_decompress()`

### 4.2 예제 — 콜백으로 “스캔별 프리뷰” 전달
```cpp
#include <functional>

// 콜백: (scan_no, total_scans, preview_image)
using ProgressiveFrameCb = std::function<void(int,int,const IppDib&)>;

bool DecodeJPEG_ProgressivePreview(const std::wstring& path, ProgressiveFrameCb cb)
{
    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"rb");
    if(!fp) return false;

    jpeg_decompress_struct c{}; jpeg_error_mgr jerr{};
    c.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&c);
    jpeg_stdio_src(&c, fp);

    if (jpeg_read_header(&c, TRUE) != JPEG_HEADER_OK){
        jpeg_destroy_decompress(&c); fclose(fp); return false;
    }

    // 스케일도 가능(원하면)
    c.scale_num=1; c.scale_denom=2; // 예: 1/2 프리뷰
#ifdef JCS_EXTENSIONS
    c.out_color_space=JCS_EXT_BGRX;
#else
    c.out_color_space=JCS_RGB;
#endif
    c.dct_method=JDCT_IFAST;
    c.do_fancy_upsampling=FALSE;

    c.buffered_image = TRUE; // 중요
    jpeg_start_decompress(&c);

    if (!jpeg_has_multiple_scans(&c)){
        // 프로그레시브가 아니면 일반 디코드로 한 번 출력
        IppDib img; img.create(c.output_width, c.output_height, 32);
        std::vector<uint8_t> row(c.output_width*c.output_components);
        while (c.output_scanline < c.output_height){
            JSAMPROW rp=row.data();
            jpeg_read_scanlines(&c, &rp, 1);
            uint8_t* d=(uint8_t*)img.bits() + (size_t)(c.output_scanline-1)*img.stride();
#ifdef JCS_EXTENSIONS
            for (int x=0;x<img.width();++x){
                d[x*4+0]=row[x*4+0]; d[x*4+1]=row[x*4+1]; d[x*4+2]=row[x*4+2]; d[x*4+3]=255;
            }
#else
            for (int x=0;x<img.width();++x){
                uint8_t R=row[x*3+0],G=row[x*3+1],B=row[x*3+2];
                d[x*4+0]=B; d[x*4+1]=G; d[x*4+2]=R; d[x*4+3]=255;
            }
#endif
        }
        if (cb) cb(1,1,img);
        jpeg_finish_decompress(&c);
        jpeg_destroy_decompress(&c);
        fclose(fp);
        return true;
    }

    // 프로그레시브: 스캔별로 coarse→fine 미리보기
    while (!jpeg_input_complete(&c)){
        // 입력을 가능한 만큼 소비
        while (jpeg_consume_input(&c) == JPEG_SUSPENDED){ /* 소스가 스트리밍이면 대기 */ }

        // 현재까지의 스캔 넘버
        int scanNo = c.output_scan_number;

        // 이 스캔 출력 시작
        jpeg_start_output(&c, scanNo);

        IppDib img; img.create(c.output_width, c.output_height, 32);
        std::vector<uint8_t> row(c.output_width*c.output_components);
        JDIMENSION saved_scanline = c.output_scanline; // 일부 코덱은 0으로 시작
        c.output_scanline = 0;

        while (c.output_scanline < c.output_height){
            JSAMPROW rp=row.data();
            jpeg_read_scanlines(&c, &rp, 1);
            uint8_t* d=(uint8_t*)img.bits() + (size_t)(c.output_scanline-1)*img.stride();
#ifdef JCS_EXTENSIONS
            for (int x=0;x<img.width();++x){
                d[x*4+0]=row[x*4+0]; d[x*4+1]=row[x*4+1]; d[x*4+2]=row[x*4+2]; d[x*4+3]=255;
            }
#else
            for (int x=0;x<img.width();++x){
                uint8_t R=row[x*3+0],G=row[x*3+1],B=row[x*3+2];
                d[x*4+0]=B; d[x*4+1]=G; d[x*4+2]=R; d[x*4+3]=255;
            }
#endif
        }

        jpeg_finish_output(&c);

        if (cb) cb(scanNo, /*unknown total*/ 0, img);
        (void)saved_scanline; // (참고 변수)
    }

    jpeg_finish_decompress(&c);
    jpeg_destroy_decompress(&c);
    fclose(fp);
    return true;
}
```

> **UI 전략**  
> - 처음엔 **1/4 스케일 + 프로그레시브 1~2 스캔**으로 **즉시 그림자 썸네일** →  
>   사용자가 멈춰서 볼 때 **1/2 스케일** 또는 **원본**을 슬로우 로딩.  
> - 목록/그리드 스크롤에서는 **스케일 디코드만**으로 충분한 경우가 많음.

---

## 5) 시나리오 모음

### 5.1 갤러리 스크롤용 썸네일 파이프라인
1) 목록에 진입 → 파일 경로만 확보  
2) 각 아이템에 대해 **1/4 스케일** 비동기 디코드 → `IppDib` 전달 → 즉시 그리기  
3) 화면에 보이는 항목만 **원본 해상도 캐시** 예약(사용자 정지 시)  
4) 스크롤 벗어난 썸네일/원본은 **LRU 캐시**로 정리

```cpp
IppDib thumb;
DecodeJPEG_Scaled(path, /*denom=*/4, thumb); // 1/4
// thumb 그리기: StretchDIBits(...) or BitBlt cached HBITMAP
```

### 5.2 미리보기 창에서 **중앙 ROI** 만 빠르게
- 큰 세로 사진을 띄울 때 중앙 영역만 먼저 보고 싶다면:

```cpp
ROI roi{ centerX - 512, centerY - 512, 1024, 1024 };
IppDib tile;
DecodeJPEG_ROI_Scaled(path, roi, ScaleDen::S2, tile); // 1/2 스케일 + ROI
```

### 5.3 Progressive Coarse Preview → Final
- 네트워크에서 스트리밍으로 JPEG이 들어오는 동안 **대략화면** → **정밀화면** 을 순차 갱신

```cpp
DecodeJPEG_ProgressivePreview(urlTmpFile, [&](int scanNo, int total, const IppDib& img){
    // scanNo 올라갈수록 선명 → UI에 즉시 반영
    InvalidatePreviewWith(img);
});
```

---

## 6) 제약·디테일

- **스케일 단계**: 1/1, 1/2, 1/4, 1/8 만 **IDCT 스케일**로 가속. 그 외 배율은 **후처리 리사이즈** 권장.  
- **ROI 정확도**: iMCU 경계로 **보정**될 수 있음(수평 `jpeg_crop_scanline`이 내부 조정).  
- **색공간**: CMYK/YCCK, ICC 등은 **표시 정확도** 관점에서 별도 처리 필요(이전 장 참고).  
- **프로그레시브**: 일부 코덱/파일에서는 스캔 수가 일정치 않음(“총 스캔 수”는 사전에 모를 수 있음).  
- **빌드 차이**: 어떤 빌드는 v8 API(크롭/스킵)가 비활성일 수 있음 → **폴백 경로** 제공이 안전.  
- **성능**: libjpeg-turbo는 SIMD(AVX2/NEON 등)로 **자동 가속**. 멀티코어에서는 **이미지 단위 병렬**이 효과적.  
- **메모리**: 스케일 디코드로 **행 버퍼 크기**가 줄어들고, ROI로 **출력 버퍼**도 더 작아짐.

---

## 7) (선택) 간단 벤치 지표(개념)

원본 \( 6000 \times 4000 \) 을 가정하면:

- 1/2 스케일: 3000×2000 → 연산량 약 \( \frac{1}{4} \)  
- 1/4 스케일: 1500×1000 → 연산량 약 \( \frac{1}{16} \)  
- 1/8 스케일: 750×500 → 연산량 약 \( \frac{1}{64} \)

ROI를 1024×1024로 제한하면, 추가로 **해당 영역만** 복원하므로 I/O/캐시 미스가 크게 줄어듭니다.

---

## 8) 테스트 체크리스트

- [ ] 1/2 · 1/4 · 1/8 스케일 결과의 **가로/세로** 계산이 기대와 일치하는지  
- [ ] `jpeg_crop_scanline` 적용 후 `cinfo.output_width` 확인(보정 폭)  
- [ ] 수직 skip과 폴백(행 버리기) 결과가 시각적으로 동일한지  
- [ ] Progressive 파일에서 **스캔별 업데이트**가 부드럽게 동작하는지  
- [ ] CMYK/YCCK, EXIF Orientation, ICC 포함 샘플과의 **결합 동작**(이전 장 코드)  
- [ ] 대용량 앨범에서 **스크롤 FPS**와 **메모리** 추이를 측정

---

## 9) 마무리

- **IDCT 스케일 디코드**(1/2 · 1/4 · 1/8)와 **ROI(crop/skip)** 를 쓰면,  
  **미리보기/타일/스크롤** 성능이 체감 수준으로 향상됩니다.  
- Progressive JPEG는 **스캔별 coarse→fine** 표시로 UX를 더 개선할 수 있습니다.  
- 앞서 구현한 **EXIF/ICC/CMYK/메타 보존/무손실 변환**과 자연스럽게 결합하여,  
  “**빠르고 정확하며 메타 안전한**” JPEG 파이프라인을 완성하세요.