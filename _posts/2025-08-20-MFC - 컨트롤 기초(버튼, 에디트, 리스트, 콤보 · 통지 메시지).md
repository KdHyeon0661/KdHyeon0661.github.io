---
layout: post
title: MFC - 컨트롤 기초 버튼, 에디트, 리스트, 콤보 · 통지 메시지
date: 2025-08-20 23:25:23 +0900
category: MFC
---
# 컨트롤 기초 : 버튼 / 에디트 / 리스트 / 콤보 · 통지 메시지 이해 (확장판 · 실전 스니펫 듬뿍)

요청하신 문서에 **부족했던 고급 포인트**와 **실전 스니펫**을 대폭 보강했습니다.
핵심은 `WM_COMMAND`/`WM_NOTIFY` 구분을 바탕으로 **소유권/수명/스타일/성능/접근성**까지 한 번에 잡는 것입니다.

---

## 큰 그림 리캡: WM_COMMAND vs WM_NOTIFY (+ 리플렉션)

- **고전 컨트롤(버튼/에디트/리스트박스/콤보박스)** → 주로 **`WM_COMMAND`** 통지
  - `BN_CLICKED`, `EN_CHANGE`, `LBN_SELCHANGE`, `CBN_SELCHANGE` …
- **공용 컨트롤(Common Controls, ComCtl32)** → 주로 **`WM_NOTIFY`** 통지
  - `NM_CLICK`, `LVN_ITEMCHANGED`, `NM_CUSTOMDRAW` …

```cpp
// WM_COMMAND 기반
ON_BN_CLICKED(IDC_BTN_OK, &CMainDlg::OnBnClickedOk)
ON_EN_CHANGE (IDC_EDIT_NAME, &CMainDlg::OnEnChangeName)
ON_LBN_SELCHANGE(IDC_LIST_ITEMS, &CMainDlg::OnLbnSelchangeItems)
ON_CBN_SELCHANGE(IDC_COMBO_COLOR, &CMainDlg::OnCbnSelchangeColor)

// WM_NOTIFY 기반
ON_NOTIFY(NM_CLICK,        IDC_LISTCTRL, &CMainDlg::OnListCtrlClick)
ON_NOTIFY(LVN_ITEMCHANGED, IDC_LISTCTRL, &CMainDlg::OnListCtrlItemChanged)
```

> **리플렉션(Reflection)**
> `ON_NOTIFY_REFLECT`, `ON_COMMAND_REFLECT`를 쓰면 **컨트롤 자신**이 통지를 **자기 자신으로 반사** 받아 처리합니다.
> 오너 드로우/커스텀 컨트롤 재사용 시 강력합니다.

---

## — Push / Check / Radio / Command Link

### 1-1. 스타일/모양 포인트

- `BS_DEFPUSHBUTTON`(기본 버튼), `BS_FLAT`(평평한 스타일), `BS_ICON`/`BS_BITMAP`(이미지 버튼)
- **체크/라디오 자동 토글**: `BS_AUTOCHECKBOX`, `BS_AUTORADIOBUTTON`
- **그룹 라디오**: **첫 라디오에 `WS_GROUP`**, 이후 **형제 라디오** 나열

```cpp
// 이미지 버튼: 리소스 아이콘 부착
HICON hIco = (HICON)LoadImage(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_PLAY),
                              IMAGE_ICON, 16,16, LR_DEFAULTCOLOR);
m_btnPlay.SendMessage(BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIco);
```

### 1-2. Command Link(비스타+ 현대식 버튼)

- 스타일: `BS_COMMANDLINK`
- 설명 텍스트: `BCM_SETNOTE`

```cpp
// 매니페스트/ComCtl32 v6 필요
m_cmdLink.ModifyStyle(0, BS_COMMANDLINK);
m_cmdLink.SetWindowTextW(L"백업 시작");
m_cmdLink.SendMessage(BCM_SETNOTE, 0, (LPARAM)L"증분 백업으로 빠르게 수행합니다.");
```

### 1-3. 체크/라디오 상태, 기본 버튼 제어

```cpp
m_chkFeature.SetCheck(BST_CHECKED);
BOOL on = (m_chkFeature.GetCheck()==BST_CHECKED);

// 현재 대화상자의 기본 버튼 변경(Enter 키)
SendMessage(DM_SETDEFID, (WPARAM)IDC_BTN_APPLY);
```

### 1-4. Owner-Draw(고급)

- 스타일: `BS_OWNERDRAW`
- `DrawItem`/`MeasureItem` 오버라이드하여 색/그림자/토글 효과 직접 그리기

```cpp
void CColorButton::DrawItem(LPDRAWITEMSTRUCT ds) {
    CDC dc; dc.Attach(ds->hDC);
    CRect r = ds->rcItem;
    dc.FillSolidRect(r, m_rgb);
    dc.DrawEdge(r, (ds->itemState & ODS_SELECTED)? EDGE_SUNKEN:EDGE_RAISED, BF_RECT);
    dc.Detach();
}
```

---

## — 단일/멀티/마스크/IME/클립보드

### 2-1. 자주 쓰는 스타일

- `ES_MULTILINE`, `ES_PASSWORD`, `ES_NUMBER`, `ES_READONLY`
- `WS_VSCROLL|ES_AUTOVSCROLL`, `ES_WANTRETURN`(멀티라인에서 Enter 허용)
- 큐 배너(플레이스홀더): `EM_SETCUEBANNER`

```cpp
m_editName.LimitText(50);
m_editName.SendMessage(EM_SETCUEBANNER, TRUE, (LPARAM)L"이름을 입력");
```

### 2-2. 통지 타이밍

- `EN_CHANGE`(매 키 입력 후) — **가벼운 처리만**
- `EN_UPDATE`(그리기 직전) — 커서/스크롤 반영 전
- `EN_KILLFOCUS` — **완화 검증** 위치로 좋음

```cpp
void CMainDlg::OnEnKillfocusAge() {
    CString s; GetDlgItemText(IDC_EDIT_AGE, s);
    if (!IsNumeric(s)) { AfxMessageBox(L"숫자만 입력!"); GetDlgItem(IDC_EDIT_AGE)->SetFocus(); }
}
```

### 2-3. 마스크/필터(간단 키 필터)

```cpp
BOOL CMainDlg::PreTranslateMessage(MSG* p) {
    if (p->message==WM_CHAR && GetFocus()==GetDlgItem(IDC_EDIT_PHONE)) {
        const wchar_t ch=(wchar_t)p->wParam;
        if (!(iswdigit(ch) || ch==L'-' || ch==VK_BACK)) return TRUE; // 차단
    }
    return CDialogEx::PreTranslateMessage(p);
}
```

### 2-4. 선택/클립보드 조작

```cpp
m_editMemo.SetSel(0, -1);         // 전체 선택
m_editMemo.Copy();                // 복사
m_editMemo.Cut();                 // 잘라내기
m_editMemo.Paste();               // 붙여넣기
```

### 2-5. IME/유니코드 주의

- 한글/IME 조합 중에는 `EN_CHANGE` 타이밍이 다릅니다. **최종 확정**은 `WM_IME_COMPOSITION`의 `GCS_RESULTSTR`로 구분 가능.
- 일반 폼은 **최종 저장 시 `UpdateData(TRUE)`**로 검증하는 구조가 안정적입니다.

---

## 리스트: `CListBox` vs `CListCtrl` (보고서 모드/가상/정렬/편집)

### 3-1. `CListBox` (가벼운 문자열 목록)

- 선택 통지: `LBN_SELCHANGE`
- 다중 선택: `LBS_EXTENDEDSEL`

```cpp
int i = m_lb.AddString(L"Apple");
m_lb.SetItemData(i, 42);
for (int sel=-1; (sel=m_lb.GetSel(sel))!=-1; ) { /* sel 사용 */ }
```

### 3-2. `CListCtrl` 기본 세팅(보고서 모드)

```cpp
m_lv.ModifyStyle(0, LVS_REPORT);
m_lv.SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_DOUBLEBUFFER);
m_lv.InsertColumn(0, L"이름", LVCFMT_LEFT, 160);
m_lv.InsertColumn(1, L"크기", LVCFMT_RIGHT, 80);
int row = m_lv.InsertItem(0, L"Report.docx");
m_lv.SetItemText(row, 1, L"24 KB");
```

#### 체크박스 + 상태 비트

```cpp
m_lv.SetExtendedStyle(m_lv.GetExtendedStyle()|LVS_EX_CHECKBOXES);

static BOOL GetRowChecked(CListCtrl& lv, int i) {
    UINT state = lv.GetItemState(i, LVIS_STATEIMAGEMASK);
    int img = (state >> 12) - 1;                // 0=unchecked, 1=checked
    return img==1;
}
static void SetRowChecked(CListCtrl& lv, int i, BOOL on) {
    lv.SetItemState(i, INDEXTOSTATEIMAGEMASK(on?2:1), LVIS_STATEIMAGEMASK);
}
```

#### 정렬(헤더 클릭) · 자연/숫자/날짜 정렬 예시

```cpp
void CMainDlg::OnListCtrlColumnClick(NMHDR* p, LRESULT* r) {
    int col = ((NMLISTVIEW*)p)->iSubItem;
    const bool asc = m_sortCol==col ? !m_sortAsc : true;
    m_sortCol = col; m_sortAsc = asc;

    struct Ctx { CListCtrl* lv; int col; bool asc; } ctx{ &m_lv, col, asc };
    m_lv.SortItems([](LPARAM a, LPARAM b, LPARAM ctxLP)->int {
        auto& ctx = *(Ctx*)ctxLP;
        CString sa = ctx.lv->GetItemText((int)a, ctx.col);
        CString sb = ctx.lv->GetItemText((int)b, ctx.col);
        // 숫자 우선 비교
        bool na = IsAllDigits(sa), nb = IsAllDigits(sb);
        int cmp = 0;
        if (na && nb) cmp = _wtoi(sa) - _wtoi(sb);
        else cmp = sa.CompareNoCase(sb); // (실무: 자연 정렬 알고리즘 권장)
        return ctx.asc ? cmp : -cmp;
    }, (LPARAM)&ctx);
    *r = 0;
}
```

#### 가상 리스트(`LVS_OWNERDATA`) — 10만 행도 쾌적

```cpp
m_lv.ModifyStyle(0, LVS_OWNERDATA);
m_lv.SetItemCountEx(totalRows, LVSICF_NOINVALIDATEALL|LVSICF_NOSCROLL);

ON_NOTIFY(LVN_GETDISPINFO, IDC_LISTCTRL, &CMainDlg::OnGetDispInfo)

void CMainDlg::OnGetDispInfo(NMHDR* n, LRESULT* r) {
    auto* di = (NMLVDISPINFO*)n;
    if (di->item.mask & LVIF_TEXT) {
        auto row = di->item.iItem, col = di->item.iSubItem;
        auto txt = LookupCell(row, col); // 캐시/페이징 전략 추천
        _tcsncpy_s(di->item.pszText, di->item.cchTextMax, txt, _TRUNCATE);
    }
    *r = 0;
}
```

#### NM_CUSTOMDRAW — 행/셀 색상

```cpp
ON_NOTIFY(NM_CUSTOMDRAW, IDC_LISTCTRL, &CMainDlg::OnListCustomDraw)

void CMainDlg::OnListCustomDraw(NMHDR* n, LRESULT* r) {
    auto* cd = (NMLVCUSTOMDRAW*)n;
    switch (cd->nmcd.dwDrawStage) {
    case CDDS_PREPAINT:    *r = CDRF_NOTIFYITEMDRAW; return;
    case CDDS_ITEMPREPAINT:
        cd->clrTextBk = RGB(250, 252, 255);      // 행 배경
        *r = CDRF_NOTIFYSUBITEMDRAW; return;
    case CDDS_SUBITEM | CDDS_ITEMPREPAINT:
        if (cd->iSubItem==1) cd->clrText = RGB(0, 80, 160); // 크기 열 파랑
        *r = CDRF_DODEFAULT; return;
    }
    *r = CDRF_DODEFAULT;
}
```

#### 인플레이스 편집(서브아이템)

```cpp
void CMainDlg::EditSubItem(int row, int col) {
    CRect rc; m_lv.GetSubItemRect(row, col, LVIR_LABEL, rc);
    CString txt = m_lv.GetItemText(row, col);
    if (m_editInPlace.m_hWnd==nullptr) m_editInPlace.Create(WS_CHILD|WS_BORDER|ES_AUTOHSCROLL, rc, &m_lv, 1001);
    m_editInPlace.MoveWindow(rc); m_editInPlace.SetWindowText(txt);
    m_editInPlace.ShowWindow(SW_SHOW); m_editInPlace.SetFocus();
    m_editRow=row; m_editCol=col;
}
```

---

## — 드롭다운/입력형/오토컴플리트/오너드로우

### 4-1. 스타일 & 통지

- `CBS_DROPDOWNLIST`(선택 전용, **권장**), `CBS_DROPDOWN`(입력+목록), `CBS_SIMPLE`
- 통지: `CBN_SELCHANGE`, `CBN_EDITCHANGE`, `CBN_DROPDOWN/CLOSEUP`

```cpp
int idx = m_cmb.AddString(L"Red");
m_cmb.SetItemData(idx, RGB(255,0,0));
m_cmb.SetCurSel(0);

void CMainDlg::OnCbnSelchangeColor() {
    int sel = m_cmb.GetCurSel();
    COLORREF rgb = (COLORREF)m_cmb.GetItemData(sel);
    ApplyColor(rgb);
}
```

### 4-2. 자동완성(간단형)

- **입력형(`CBS_DROPDOWN`)**에서 `CBN_EDITCHANGE`로 목록 필터/완성
- 쉘 자동완성(파일 경로 등): `SHAutoComplete(hEdit, SHACF_FILESYS_ONLY)` (Shlwapi)

```cpp
#include <Shlwapi.h> #pragma comment(lib,"Shlwapi.lib")

BOOL CMainDlg::OnInitDialog(){
    auto hEdit = m_cmb.GetComboBoxCtrl()->m_hWnd;
    SHAutoComplete(hEdit, SHACF_FILESYS_ONLY);
    return TRUE;
}
```

### 4-3. 오너 드로우 콤보(색상 미리보기)

- 스타일: `CBS_OWNERDRAWFIXED`/`CBS_HASSTRINGS`
- `DrawItem`/`MeasureItem` 오버라이드

```cpp
void CColorCombo::DrawItem(LPDRAWITEMSTRUCT ds){
    CDC dc; dc.Attach(ds->hDC); CRect r=ds->rcItem;
    if (ds->itemID!=UINT(-1)) {
        COLORREF c = (COLORREF)GetItemData(ds->itemID);
        dc.FillSolidRect(r, c);
        dc.FrameRect(r, &CBrush(::GetSysColor(COLOR_WINDOWTEXT)));
    }
    dc.Detach();
}
```

---

## 공통 패턴 보강: 컨텍스트 메뉴/툴팁/드래그드롭/색상/IME

### 5-1. 컨텍스트 메뉴(우클릭)

```cpp
void CMainDlg::OnContextMenu(CWnd* pWnd, CPoint pt){
    CMenu m; m.LoadMenu(IDR_POPUP_MAIN);
    CMenu* pop = m.GetSubMenu(0);
    pop->TrackPopupMenu(TPM_RIGHTBUTTON, pt.x, pt.y, this);
}
```

### 5-2. 툴팁(`CToolTipCtrl`)

```cpp
BOOL CMainDlg::OnInitDialog(){
    m_tip.Create(this); m_tip.AddTool(GetDlgItem(IDC_BTN_OK), L"저장하고 닫기");
    m_tip.Activate(TRUE); return TRUE;
}
BOOL CMainDlg::PreTranslateMessage(MSG* p){ m_tip.RelayEvent(p); return CDialogEx::PreTranslateMessage(p); }
```

### 5-3. 파일 드래그 & 드롭

```cpp
BOOL CMainDlg::OnInitDialog(){ DragAcceptFiles(); return TRUE; }
void CMainDlg::OnDropFiles(HDROP h){
    wchar_t path[MAX_PATH]; DragQueryFile(h, 0, path, MAX_PATH);
    DragFinish(h);
    // TODO: 파일 열기
}
```

### 5-4. 색상/폰트 일괄 적용(컨트롤 색 칠하기)

```cpp
HBRUSH CMainDlg::OnCtlColor(CDC* dc, CWnd* wnd, UINT nCtlColor){
    if (nCtlColor==CTLCOLOR_STATIC) {
        dc->SetBkMode(TRANSPARENT);
        return (HBRUSH)::GetStockObject(HOLLOW_BRUSH);
    }
    return CDialogEx::OnCtlColor(dc, wnd, nCtlColor);
}
```

---

## 성능/안정성 체크리스트(추가)

1. **대량 업데이트 전** `SetRedraw(FALSE)` → 작업 → `SetRedraw(TRUE); Invalidate();`
2. 리스트뷰 다량 갱신: **이미지/텍스트 캐시** + 배치(`SetItemCountEx`)
3. **가상 리스트**로 1e5+ 행 스크롤 최적화
4. `EN_CHANGE`에서 **DB/네트워크 호출 금지**(타이머로 디바운스)
5. **UI 스레드 규칙**: 백그라운드 결과는 **`PostMessage`**로 반영
6. **DPI**: 열 너비/아이콘 크기/여백을 DPI에 맞춰 계산(`GetDpiForWindow`)
7. **접근성**: 라벨-컨트롤 짝 맞추기(스크린리더), Tab 순서/Default 버튼 점검

---

## DDX/DDV 보강 포인트

- `DDX_CBIndex`/`DDX_LBIndex`(인덱스), `DDX_CBString`/`DDX_LBString`(텍스트)
- `DDX_Check`(체크박스), `DDX_Control`(컨트롤 핸들)
- **초기 표시**: `UpdateData(FALSE)` / **저장 검증**: `UpdateData(TRUE)`

```cpp
void CMainDlg::DoDataExchange(CDataExchange* dx){
    CDialogEx::DoDataExchange(dx);
    DDX_Control(dx, IDC_LISTCTRL, m_lv);
    DDX_Text   (dx, IDC_EDIT_NAME, m_name);
    DDX_Check  (dx, IDC_CHK_FEATURE, m_featureOn);
    DDX_CBIndex(dx, IDC_COMBO_COLOR, m_selColor);
    DDV_MinMaxInt(dx, m_age, 1, 120);
}
```

---

## 자주 까먹는 “작지만 중요한” 것들

- `IDC_STATIC`은 **공용 ID** → **바인딩 금지** (바인딩 필요하면 새 ID)
- 라디오 그룹: 첫 항목에 **`WS_GROUP`**, 그룹 분리 시 **새 그룹의 첫 컨트롤도 `WS_GROUP`**
- 다국어/폭넓은 문장 대비: 컨트롤 폭은 **텍스트 측정**(`CDC::GetTextExtent`) 후 여유분
- 헤더 리오더/열 숨김: `LVS_EX_HEADERDRAGDROP`, `HDF_FIXEDWIDTH` 응용
- 리스트뷰 **Label Tip**(너무 긴 텍스트 말줄임 툴팁): `LVS_EX_LABELTIP`
- 컨트롤 공통 단축키(예: F1 도움말, Del 삭제): **가속기**에 등록하면 라우팅이 편해짐

---

## 원클릭 스타터(정리된 메시지 맵)

```cpp
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    // 버튼/체크/라디오
    ON_BN_CLICKED(IDC_BTN_OK,        &CMainDlg::OnBnClickedOk)
    ON_BN_CLICKED(IDC_CHK_FEATURE,   &CMainDlg::OnBnClickedFeature)
    ON_BN_CLICKED(IDC_RAD_MODE_A,    &CMainDlg::OnBnClickedModeA)
    ON_BN_CLICKED(IDC_RAD_MODE_B,    &CMainDlg::OnBnClickedModeB)

    // 에디트
    ON_EN_CHANGE   (IDC_EDIT_NAME,   &CMainDlg::OnEnChangeName)
    ON_EN_KILLFOCUS(IDC_EDIT_AGE,    &CMainDlg::OnEnKillfocusAge)

    // 리스트박스/콤보
    ON_LBN_SELCHANGE(IDC_LIST_ITEMS, &CMainDlg::OnLbnSelchangeItems)
    ON_CBN_SELCHANGE(IDC_COMBO_COLOR,&CMainDlg::OnCbnSelchangeColor)
    ON_CBN_EDITCHANGE(IDC_COMBO_SEARCH,&CMainDlg::OnCbnEditchangeSearch)

    // 리스트컨트롤
    ON_NOTIFY(NM_CLICK,        IDC_LISTCTRL, &CMainDlg::OnListCtrlClick)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LISTCTRL, &CMainDlg::OnListCtrlItemChanged)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_LISTCTRL, &CMainDlg::OnListCtrlColumnClick)
    ON_NOTIFY(NM_CUSTOMDRAW,   IDC_LISTCTRL, &CMainDlg::OnListCustomDraw)
    ON_NOTIFY(LVN_GETDISPINFO, IDC_LISTCTRL, &CMainDlg::OnGetDispInfo)

    // 컨텍스트 메뉴/드롭
    ON_WM_CONTEXTMENU()
    ON_WM_DROPFILES()
END_MESSAGE_MAP()
```
