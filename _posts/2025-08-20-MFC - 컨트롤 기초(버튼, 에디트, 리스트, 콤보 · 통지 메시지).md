---
layout: post
title: MFC - 컨트롤 기초 버튼, 에디트, 리스트, 콤보 · 통지 메시지
date: 2025-08-20 23:25:23 +0900
category: MFC
---
# 컨트롤 기초 : 버튼 / 에디트 / 리스트 / 콤보 · 통지 메시지 이해

이 글은 MFC에서 **기본 컨트롤(버튼·에디트·리스트·콤보)**를 다루는 방법과, 컨트롤이 보내는 **통지 메시지(Notifications)**를 **메시지 맵**으로 처리하는 패턴을 정리합니다. 각 절마다 **자주 쓰는 스타일/플래그/핸들러**와 **실전 팁**을 담았습니다.

---

## 0) 큰 그림: WM_COMMAND vs WM_NOTIFY

- **버튼/에디트/리스트박스/콤보박스**(고전 컨트롤) → 주로 **`WM_COMMAND`**로 통지  
  - 예: `BN_CLICKED`, `EN_CHANGE`, `LBN_SELCHANGE`, `CBN_SELCHANGE`
- **공용 컨트롤(Common Controls)**(`CListCtrl`, `CTreeCtrl` 등) → **`WM_NOTIFY`**로 통지  
  - 예: `NM_CLICK`, `LVN_ITEMCHANGED`, `NM_CUSTOMDRAW`

**메시지 맵 매크로**
```cpp
// WM_COMMAND 기반
ON_BN_CLICKED(IDC_BTN_OK, &CMainDlg::OnBnClickedOk)
ON_EN_CHANGE (IDC_EDIT_NAME, &CMainDlg::OnEnChangeName)
ON_LBN_SELCHANGE(IDC_LIST_ITEMS, &CMainDlg::OnLbnSelchangeItems)
ON_CBN_SELCHANGE(IDC_COMBO_COLOR, &CMainDlg::OnCbnSelchangeColor)

// WM_NOTIFY 기반
ON_NOTIFY(NM_CLICK, IDC_LISTCTRL, &CMainDlg::OnListCtrlClick)
ON_NOTIFY(LVN_ITEMCHANGED, IDC_LISTCTRL, &CMainDlg::OnListCtrlItemChanged)
```

> 팁: `ON_NOTIFY_REFLECT`를 사용하면 **컨트롤 자신(서브클래스)**이 통지를 **자기 자신에게 반사(reflect)** 받아 처리할 수 있습니다(재사용·격리 용이).

---

## 1) 버튼(Button) — Push/Check/Radio

### 1-1. 주요 스타일
- **BS_PUSHBUTTON / BS_DEFPUSHBUTTON**: 일반/기본(Enter) 버튼
- **BS_AUTOCHECKBOX / BS_AUTO3STATE**: 체크박스(자동 체크 토글)
- **BS_AUTORADIOBUTTON**: 라디오 버튼(자동 그룹 동작)
- **WS_TABSTOP**: Tab 이동 대상

### 1-2. 자주 쓰는 통지와 핸들러
- `BN_CLICKED` : 클릭됨(버튼/체크/라디오 공통)
- `BN_SETFOCUS/BN_KILLFOCUS` : 포커스 진입/이탈
- 라디오 그룹: **그룹의 첫 라디오에 `WS_GROUP`**, 이후 **형제 라디오들**을 배치

```cpp
void CMainDlg::OnBnClickedOk()            { AfxMessageBox(_T("OK 클릭")); }
void CMainDlg::OnBnClickedCheckFeature()  {
    BOOL checked = (m_chkFeature.GetCheck() == BST_CHECKED);
    // 옵션 활성/비활성 등 UI 갱신
}
void CMainDlg::OnBnClickedRadioModeA()    { m_mode = 0; }
void CMainDlg::OnBnClickedRadioModeB()    { m_mode = 1; }
```

### 1-3. 상태 제어
```cpp
// 체크박스/라디오 상태
m_chkFeature.SetCheck(BST_CHECKED);
BOOL on = (m_chkFeature.GetCheck() == BST_CHECKED);

// 버튼 활성/비활성
GetDlgItem(IDC_BTN_APPLY)->EnableWindow(TRUE);

// 기본 버튼(Enter 반응) 지정
SendMessage(DM_SETDEFID, IDOK, 0);
```

> 실무 팁  
> - **디폴트 버튼**은 한 화면에 하나만. Enter 키 동작 혼선을 줄입니다.  
> - 체크/라디오는 **상태 주도적(UI 업데이트)**로 흐름을 구성하고, 최종 적용 시 한 번에 검증/저장하는 패턴이 깔끔합니다.

---

## 2) 에디트(Edit) — 단일/멀티라인, 입력 제한

### 2-1. 주요 스타일
- **ES_MULTILINE**: 다중 라인  
- **ES_PASSWORD**: 비밀번호 표시  
- **ES_NUMBER**: 숫자만 허용(로케일 숫자키만, 소수점·부호 등은 직접 처리 필요)  
- **ES_READONLY**: 읽기 전용  
- **WS_VSCROLL/ES_AUTOVSCROLL**: 자동 스크롤  
- **ES_WANTRETURN**: 멀티라인에서 Enter 입력 허용

### 2-2. 통지
- `EN_CHANGE` : 내용 변경(자주 발생)  
- `EN_UPDATE` : 그리기 직전(커서/스크롤 반영 전)  
- `EN_KILLFOCUS` : 포커스 이탈 시점(완화 검증에 유용)

```cpp
void CMainDlg::OnEnChangeName() {
    CString s; m_editName.GetWindowText(s);
    // 실시간 길이 제한/버튼 활성화 등 가벼운 처리만
}
void CMainDlg::OnEnKillfocusAge() {
    CString s; GetDlgItemText(IDC_EDIT_AGE, s);
    // 숫자 엄격 검증은 여기서 or OK 직전(DDV)에서
}
```

### 2-3. 입력 제어/편의
```cpp
// 길이 제한
m_editName.LimitText(50);

// 선택/커서
m_editName.SetSel(0, -1);   // 전체 선택
m_editName.ReplaceSel(_T("기본 텍스트"));

// 큐 배너(플레이스홀더, Vista+)
m_editName.SendMessage(EM_SETCUEBANNER, TRUE, (LPARAM)L"이름을 입력");

// 숫자 필터(문자 단위): EN_CHANGE 남용 대신 OnChar에서 가볍게
void CMainDlg::OnChar(UINT ch, UINT repCnt, UINT flags) {
    if (GetFocus() == GetDlgItem(IDC_EDIT_AGE)) {
        if (!(isdigit(ch) || ch==VK_BACK)) return; // 차단
    }
    CDialogEx::OnChar(ch, repCnt, flags);
}
```

> 실무 팁  
> - **무거운 검증/DB 조회**는 `EN_CHANGE`에서 하지 마세요(키 입력마다 발생).  
> - 최종 저장 시 `UpdateData(TRUE)` + `DDV_…`로 **확정 검증**, 그 외에는 **포커스 이탈/타이머** 등으로 분산.

---

## 3) 리스트 두 종류: CListBox vs CListCtrl

### 3-1. `CListBox` (고전 리스트 박스)
- 간단한 문자열 목록, 선택 모드: `LBS_EXTENDEDSEL`(다중), `LBS_SORT`(자동 정렬)
- 통지: `LBN_SELCHANGE`, `LBN_DBLCLK`, `LBN_KILLFOCUS`

```cpp
// 아이템 추가/삭제/선택
int idx = m_listBox.AddString(_T("Apple"));
m_listBox.SetItemData(idx, 123);       // 추가 메타(정수/포인터)
m_listBox.DeleteString(sel);

// 선택된 항목들 순회(다중 선택)
CArray<int,int> sel;
for (int i=-1; (i=m_listBox.GetSel(i))!=-1; ) { sel.Add(i); }
```

> 장점: 구현 간단, 가벼움.  
> 한계: **열/서브아이템 없음**, 아이콘/체크박스/가상화 어려움 → 복잡한 그리드성 목록은 **`CListCtrl`**을 사용.

### 3-2. `CListCtrl` (공용 컨트롤: 리스트 뷰)
- 뷰 모드: `LVS_REPORT`(가장 흔함, 헤더+열), `LVS_ICON`, `LVS_SMALLICON`, `LVS_LIST`
- 확장 스타일: `LVS_EX_FULLROWSELECT`, `LVS_EX_GRIDLINES`, `LVS_EX_CHECKBOXES`, `LVS_EX_DOUBLEBUFFER`
- 통지: `NM_CLICK`, `NM_DBLCLK`, `LVN_ITEMCHANGED`, `LVN_COLUMNCLICK`, `NM_CUSTOMDRAW`, `LVN_GETDISPINFO`(가상 모드)

```cpp
// 초기화(헤더/열/확장 스타일)
m_listCtrl.SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_DOUBLEBUFFER);
m_listCtrl.InsertColumn(0, _T("이름"), LVCFMT_LEFT, 140);
m_listCtrl.InsertColumn(1, _T("크기"), LVCFMT_RIGHT, 80);

// 행/서브아이템
int row = m_listCtrl.InsertItem(0, _T("Report.docx"));
m_listCtrl.SetItemText(row, 1, _T("24 KB"));
```

#### (1) 클릭/더블클릭/NM_CLICK
```cpp
void CMainDlg::OnListCtrlClick(NMHDR* pNMHDR, LRESULT* pResult) {
    LPNMITEMACTIVATE p = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
    int row = p->iItem; // -1이면 빈 영역
    int col = p->iSubItem;
    if (row >= 0) { /* 선택/편집 등 처리 */ }
    *pResult = 0;
}
```

#### (2) 선택 변경 `LVN_ITEMCHANGED`
```cpp
void CMainDlg::OnListCtrlItemChanged(NMHDR* pNMHDR, LRESULT* pResult) {
    LPNMLISTVIEW p = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);
    if ((p->uChanged & LVIF_STATE) &&
        (p->uNewState & LVIS_SELECTED) != (p->uOldState & LVIS_SELECTED)) {
        // 선택 상태가 바뀜
    }
    *pResult = 0;
}
```

#### (3) 정렬 `LVN_COLUMNCLICK`
```cpp
void CMainDlg::OnListCtrlColumnClick(NMHDR* pNMHDR, LRESULT* pResult) {
    auto p = reinterpret_cast<NMLISTVIEW*>(pNMHDR);
    int col = p->iSubItem;
    m_listCtrl.SortItems([](LPARAM a, LPARAM b, LPARAM colPtr)->int {
        int col = (int)colPtr;
        // a/b는 SetItemData에 넣은 값. 실제 비교 로직 구현
        return /* <0,0,>0 */;
    }, (LPARAM)col);
    *pResult = 0;
}
```

#### (4) 가상 리스트(대량 데이터) `LVS_OWNERDATA`
- 항목 수만 지정하고, 표시 시점에 `LVN_GETDISPINFO`로 텍스트/이미지를 **지연 공급**  
- 10만 행 이상도 **빠르게 스크롤**

```cpp
// 생성 시 스타일에 LVS_OWNERDATA 추가
m_listCtrl.ModifyStyle(0, LVS_OWNERDATA);
m_listCtrl.SetItemCountEx(totalRows, LVSICF_NOINVALIDATEALL|LVSICF_NOSCROLL);

void CMainDlg::OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult) {
    NMLVDISPINFO* di = (NMLVDISPINFO*)pNMHDR;
    if (di->item.mask & LVIF_TEXT) {
        // di->item.iItem, di->item.iSubItem 기준으로 버퍼 채우기
        _tcscpy_s(di->item.pszText, di->item.cchTextMax, LookupCell(di->item.iItem, di->item.iSubItem));
    }
    *pResult = 0;
}
```

> 실무 팁  
> - 대량 데이터는 **가상 모드** 강력 추천.  
> - 체크박스는 `LVS_EX_CHECKBOXES` 추가 + `GetCheck/SetCheck` 계열 대신 **상태 비트(LVIS_STATEIMAGEMASK)**를 다룹니다.  
> - **더블 버퍼링**(`LVS_EX_DOUBLEBUFFER`)로 깜빡임 감소.

---

## 4) 콤보박스(Combo) — 입력형/선택형

### 4-1. 스타일
- **CBS_DROPDOWNLIST**: **선택 전용**(사용자가 입력 못함·UI 안정) — 추천
- **CBS_DROPDOWN**: **입력 + 드롭다운**(자동완성 UX 가능)
- **CBS_SIMPLE**: 상시 펼친 리스트

### 4-2. 통지
- `CBN_SELCHANGE` : 선택 변경  
- `CBN_EDITCHANGE` : 입력 텍스트 변경(입력형 스타일에서만)  
- `CBN_CLOSEUP/DROPDOWN` : 드롭다운 열림/닫힘

```cpp
void CMainDlg::OnCbnSelchangeColor() {
    int sel = m_comboColor.GetCurSel();
    CString text; m_comboColor.GetLBText(sel, text);
    // 색상 적용 등
}

void CMainDlg::OnCbnEditchangeSearch() {
    CString key; m_comboSearch.GetWindowText(key);
    // 인메모리 필터/자동완성 등 (비싼 작업은 타이머/쓰레드로)
}
```

### 4-3. 항목/데이터
```cpp
m_comboColor.AddString(_T("Red"));
int idx = m_comboColor.AddString(_T("Green"));
m_comboColor.SetItemData(idx, 0x00FF00); // ARGB 등 메타 저장
m_comboColor.SetCurSel(0);
```

> 실무 팁  
> - 폼에서 **저장 가능한 값**은 `SetItemData`에 넣어두고, 화면에는 **사용자 친화 문자열**을 노출하면 모델/뷰 분리가 쉬워집니다.  
> - 입력형(`CBS_DROPDOWN`)은 오타/중복 입력 이슈가 있으므로, **목록 표준화가 중요**하면 `CBS_DROPDOWNLIST`를 쓰세요.

---

## 5) 통지 메시지(NM_*, LBN_*, CBN_*, EN_*) 요점표

| 컨트롤 | 주 통지 | 의미/타이밍 | 비고 |
|---|---|---|---|
| Button | `BN_CLICKED` | 클릭 | 체크/라디오 포함 |
| Edit | `EN_CHANGE` | 텍스트 변경시마다 | 무거운 작업 금지 |
| Edit | `EN_KILLFOCUS` | 포커스 이탈 | 완화 검증 위치 |
| ListBox | `LBN_SELCHANGE` | 선택 변경 | 다중 선택은 반복 조회 |
| ComboBox | `CBN_SELCHANGE` | 선택 변경 | 텍스트는 `GetWindowText` |
| ComboBox | `CBN_EDITCHANGE` | 입력 변경 | 입력형일 때만 |
| ListCtrl | `NM_CLICK` | 셀/행 클릭 | `LPNMITEMACTIVATE` 사용 |
| ListCtrl | `LVN_ITEMCHANGED` | 선택/체크 변경 | 상태 비트 비교 |
| ListCtrl | `LVN_COLUMNCLICK` | 헤더 클릭 | 정렬 트리거 |
| ListCtrl | `LVN_GETDISPINFO` | 가상 모드 텍스트 공급 | 대량 데이터 |

---

## 6) DDX/DDV와 바인딩 포인트

- **문자열/정수 바인딩**: `DDX_Text`  
- **체크박스(BOOL)**: `DDX_Check`  
- **콤보/리스트 인덱스**: `DDX_CBIndex` / `DDX_LBIndex`  
- **컨트롤 핸들 캡처**: `DDX_Control` → 멤버로 `CEdit`, `CListCtrl` 등 받기

```cpp
void CMainDlg::DoDataExchange(CDataExchange* pDX) {
    CDialogEx::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_LISTCTRL, m_listCtrl);
    DDX_Text   (pDX, IDC_EDIT_NAME, m_name);
    DDX_Check  (pDX, IDC_CHK_FEATURE, m_featureOn);
    DDX_CBIndex(pDX, IDC_COMBO_COLOR, m_selColor);
    // DDV_MinMaxInt(pDX, m_age, 1, 120) 등 검증 추가
}
```

> 실무 팁  
> - **초기 표시**: `UpdateData(FALSE)`  
> - **저장/검증**: `UpdateData(TRUE)` (OK 직전)  
> - 바인딩과 **성능 부담**을 혼동하지 마세요. 고빈도 이벤트에서 `UpdateData(TRUE)` 남용 금지.

---

## 7) 커스텀 드로잉 & 메시지 리플렉션(고급 입문)

- **Owner-Draw**(리스트박스/콤보박스): `LBS_OWNERDRAWFIXED/VARIABLE`, `CBS_OWNERDRAW…` + `MeasureItem/DrawItem` 오버라이드
- **Custom Draw**(리스트컨트롤 등): `NM_CUSTOMDRAW`에서 단계별 색/폰트/배경 커스터마이즈
- **메시지 리플렉션**: `ON_NOTIFY_REFLECT(NM_CUSTOMDRAW, OnCustomDraw)`처럼 **컨트롤 자신**이 처리

```cpp
void CColorList::OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult) {
    LPNMLVCUSTOMDRAW cd = reinterpret_cast<LPNMLVCUSTOMDRAW>(pNMHDR);
    if (cd->nmcd.dwDrawStage == CDDS_ITEMPREPAINT) {
        // 행 단위 색상 변경
        cd->clrTextBk = RGB(245, 250, 255);
        *pResult = CDRF_DODEFAULT;
        return;
    }
    *pResult = CDRF_DODEFAULT;
}
```

---

## 8) 안정성과 UX를 위한 체크리스트

1. **WS_TABSTOP / Tab Order** 정리: 키보드 이동 동선 점검  
2. **IDC_STATIC 바인딩 금지**: 데이터 바인딩하려면 **개별 ID** 부여  
3. **대량 목록은 가상 모드**: `LVS_OWNERDATA + LVN_GETDISPINFO`  
4. **EN_CHANGE 남용 금지**: 가벼운 표시만, 무거운 작업은 이탈/확정 시  
5. **DPI/High-DPI**: 폰트/간격/열 너비를 DPI 기준으로 계산  
6. **스레드 안전**: UI 업데이트는 **UI 스레드(PostMessage/SendMessage)**로  
7. **성능**: 대량 변경 전 `SetRedraw(FALSE)`, 끝나면 `SetRedraw(TRUE); Invalidate()`  

---

## 9) 빠른 스타터 스니펫 (한 화면 요약)

```cpp
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_BN_CLICKED     (IDC_BTN_OK,        &CMainDlg::OnBnClickedOk)
    ON_EN_CHANGE      (IDC_EDIT_NAME,     &CMainDlg::OnEnChangeName)
    ON_LBN_SELCHANGE  (IDC_LIST_ITEMS,    &CMainDlg::OnLbnSelchangeItems)
    ON_CBN_SELCHANGE  (IDC_COMBO_COLOR,   &CMainDlg::OnCbnSelchangeColor)
    ON_NOTIFY         (NM_CLICK, IDC_LISTCTRL, &CMainDlg::OnListCtrlClick)
    ON_NOTIFY         (LVN_ITEMCHANGED, IDC_LISTCTRL, &CMainDlg::OnListCtrlItemChanged)
END_MESSAGE_MAP()
```