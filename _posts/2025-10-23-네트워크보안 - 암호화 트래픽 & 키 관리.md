---
layout: post
title: 네트워크보안 - 암호화 트래픽 & 키 관리
date: 2025-10-23 22:25:23 +0900
category: 네트워크보안
---
# 암호화 트래픽 & 키 관리

> 목표: TLS 1.2/1.3의 차이점과 보안 속성(PFS/0-RTT)을 정확히 이해하고,
> PKI·인증서(OCSP/Stapling 포함)·가시성(JA3/JA4)·컴플라이언스 이슈(SSL Inspection)를 체계적으로 다룬다.
> 마지막으로 **내부 mTLS 구축**과 **클라이언트 인증 운영 팁**을 랩 형태로 정리한다.

---

## TLS 1.2/1.3, Cipher Suite, PFS, 0-RTT 리스크

### TLS 1.2 vs 1.3 핵심 비교

| 항목 | TLS 1.2 | TLS 1.3 |
|---|---|---|
| 핸드셰이크 왕복 | 통상 2 RTT | 1 RTT (0-RTT 지원 시 특정 재접속은 0 RTT) |
| Cipher Suite 구성 | **키교환 + 서명 + 대칭암호 + MAC** 혼합 명명 | **AEAD(대칭) + Hash** 중심으로 단순화 (키교환/서명은 별도 확장으로) |
| 암호군 | RSA, (EC)DH, CBC+HMAC, GCM 등 | **(EC)DHE + AEAD(GCM/CHACHA20-POLY1305)** 고정, 레거시 제거 |
| PFS(Forward Secrecy) | **옵션**(DHE/ECDHE 사용 시) | **기본**(DHE/ECDHE 필수) |
| 레거시 제거 | 미흡(취약 스위트 가능) | 다수 제거(예: RSA key exchange, static DH, CBC) |
| 재개(Resumption) | Session ID/Session Ticket | PSK + 0-RTT(선택) |

**결론**: 신규 서비스는 **TLS 1.3 우선**. 1.2는 **안전 스위트만 허용**(ECDHE + AES-GCM/CHACHA20).

---

### Cipher Suite & 운영 권장(서버 우선)

- **TLS 1.3(권장 기본)**
  - `TLS_AES_128_GCM_SHA256`
  - `TLS_AES_256_GCM_SHA384`
  - `TLS_CHACHA20_POLY1305_SHA256` (모바일/저성능 CPU 유리)
- **TLS 1.2(레거시 호환)**
  - **허용**: `ECDHE-ECDSA-AES128-GCM-SHA256`, `ECDHE-RSA-AES128-GCM-SHA256`, (AES256 변형 포함), `ECDHE-ECDSA-CHACHA20-POLY1305`, `ECDHE-RSA-CHACHA20-POLY1305`
  - **차단**: `RC4`, `3DES`, `AES-CBC`(+비표준 MAC), `RSA key exchange`, `EXPORT`, `NULL` 등

---

### PFS(Perfect Forward Secrecy)

- **의미**: 장기 키(서버 프라이빗 키)가 유출되어도, **과거 세션**은 개별 **에페메럴(Ephemeral) DH 키** 덕에 복호화 불가.
- **실무 포인트**
  - 1.3 사용 시 자동 PFS
  - 1.2 사용 시 **ECDHE** 필수, 정적 RSA 키교환 금지
  - TLS 종료 장비(프록시/LB)에서도 **ECDHE 강제**

---

### 0-RTT(Zero-RTT) 재전송 리스크

- **문제**: 0-RTT 데이터는 **리플레이** 가능(서버가 같은 Early Data를 재수용할 수 있음).
- **대응**
  - **멱등 요청만 허용**(GET/HEAD) — 상태변경 API는 Early Data 거부
  - 서버에서 **anti-replay** 창 관리(세션 티켓/토큰·윈도)
  - 정책적으로 **0-RTT 비활성화**(보수적 환경)

**Nginx(1.25+)에서 0-RTT 비활성 예시**
```nginx
ssl_early_data off;
```

---

### 서버 설정 예시 (Nginx)

```nginx
server {
  listen 443 ssl http2;
  server_name example.com;

  ssl_protocols TLSv1.2 TLSv1.3;             # 1.3 우선, 1.2는 안전 스위트만
  ssl_ciphers   'ECDHE+AESGCM:ECDHE+CHACHA20:!aNULL:!MD5:!RC4:!3DES:!AES128-SHA';
  ssl_prefer_server_ciphers on;

  # OCSP Stapling은 7.2.4 참조
  # HSTS는 7.2.5 참조

  add_header X-Content-Type-Options nosniff always;
  add_header X-Frame-Options DENY always;

  location / { root /var/www/html; index index.html; }
}
```

---

## PKI/인증서/OCSP·Stapling, HSTS·HPKP(역사·교훈)

### PKI 계층 요약

- **Root CA**(오프라인 권장) → **Intermediate CA** → **Server/Client Certificate**
- **CRL/OCSP**로 폐지 상태 전파, **OCSP Stapling**으로 실시간성/프라이버시 개선

### 내부 PKI vs 공인 CA

- **외부 웹 서비스**: 공인 CA(브라우저 신뢰)
- **내부(mTLS)**: **사내 CA(루트/중간)** + MDM/자동배포
- **운영 포인트**
  - 루트 키는 **HSM** 또는 오프라인 보관
  - 인터미디어트 키도 가능한 **HSM/KMS** 바인딩
  - 발급·폐기·갱신 **수명 정책(Short-lived certs)**

---

### OCSP & OCSP Stapling

- **OCSP**: 인증서 폐지 상태를 실시간 질의(클라 → CA).
  - 단점: **개인정보/추적**(어떤 도메인 접속했는지 CA가 알 수 있음), 가용성 문제 시 소통 이슈.
- **Stapling**: 서버가 CA로부터 받은 **OCSP 응답**을 **핸드셰이크에 첨부**(클라가 직접 CA에 묻지 않음).
  - 장점: 프라이버시/지연 개선, 대규모 서비스 권장
  - **Must-Staple**(TLS Feature 확장): 스테이플링 없으면 실패 — 운영 난이도↑

**Nginx에서 OCSP Stapling**
```nginx
ssl_stapling on;
ssl_stapling_verify on;
resolver 1.1.1.1 1.0.0.1 valid=300s;
resolver_timeout 5s;
```
> 체인 파일(`fullchain.pem`)과 중간 인증서 설정을 정확히 해야 한다.

---

### 인증서 체인·Stapling 점검

```bash
# 서버 체인 점검

openssl s_client -connect example.com:443 -servername example.com -showcerts </dev/null

# OCSP Stapling 수신 확인

openssl s_client -connect example.com:443 -servername example.com -status </dev/null | grep -i "OCSP response"
```

---

### HSTS·HPKP(역사·교훈)

- **HSTS(Strict-Transport-Security)**: 사이트에 **HTTPS만** 허용(최소 6~12개월+서브도메인+preload 권장).
  - 장점: 초회 평문/다운그레이드 공격 차단
  - 주의: **롤백 어려움**(preload 등록 시 특히) — 도메인/서브도메인 전략을 신중히 설계
- **HPKP(Public Key Pinning)**: **운영 난이도·리스크 과도**(키 분실/오설정 → 자체 DoS)로 **사장**.
  - **교훈**: 핀 고정은 클라가 아닌 **CA/CT 로그·CAA 레코드**·자동화된 **키 롤오버**로 대체

**Nginx HSTS 스니펫**
```nginx
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
```

---

### CAA·CT 로그·자동화

- **CAA DNS 레코드**: 특정 CA만 발급 가능하도록 제한 → 오발급 저감
- **CT 로그**: 공인 CA 발급 인증서는 CT에 기록 → **오발급 모니터링**
- **자동화**: ACME(Let’s Encrypt 등)·cert-manager(K8s)로 발급/갱신 **무중단**

---

## TLS 가시성: JA3/JA4, SSL Inspection의 법·컴플라이언스

### JA3/JA4 개념

- **JA3**: TLS ClientHello의 **Cipher Suites/Extensions/Version** 등을 정규화해 만든 **클라이언트 지문**(MD5 해시).
- **JA3S**: 서버 측(ServerHello) 지문.
- **JA4**: HTTP 등 다른 L7 특징까지 포함한 **지문 확장 프레임워크**(내성/안정성 강화 목적).

**활용**
- **NDR/SIEM**에서 **비정상 클라이언트**(멀웨어/툴킷) 탐지
- **허용 목록**(사내 표준 브라우저/SDK)과 비교(오탐 주의)

**Suricata EVE JSON 예(개념)**
```json
{
  "event_type": "tls",
  "src_ip": "10.0.0.5",
  "tls": {
    "sni": "api.example.com",
    "ja3_hash": "769f...e9a",
    "version": "TLS 1.3"
  }
}
```

---

### SSL Inspection(복호) — 법·윤리·컴플라이언스

- **장점**: 내부에서 악성 트래픽 탐지/차단 정확도↑
- **리스크**:
  - **프라이버시**(개인정보/민감데이터 열람), **법적 근거** 필요(근로자/고객 고지·동의·내부 규정)
  - **보안 표면 증가**(프록시가 키를 보유 → 타겟이 됨)
  - **TLS 최신 기능 호환성**(H3/QUIC, ALPN, 최신 확장)
- **대안/절충**:
  - **메타데이터 가시성**(SNI/JA3/도메인 평판) + **mTLS(내부)**
  - **카테고리 기반 복호 정책**(금융/키체인/헬스케어 트래픽 제외)
  - 엄격한 **키 관리/접근 통제/감사 로깅/보존 기간** 설정

---

### NetFlow/IPFIX + TLS 메타 결합

- 세션 수준 **바이트/패킷/지연**과 TLS **SNI/버전/JA3**을 **상관 분석**하면, 복호 없이도 이상 행위 탐지 가능
- 예: **새로운 JA3 + 이례적 대용량 업로드 + 신생 도메인** → 경보

---

## 실습: 내부 mTLS 구축, 클라이언트 인증 운영 팁

> 목표: **사내 CA**로 서버/클라이언트 인증서를 발급하고,
> **Nginx(또는 Envoy/HAProxy)**에서 **mTLS**를 강제, **운영 점검**까지 한 번에.

### 랩 구성

```
[CA/PKI] ── 발급/폐기/체인 관리
   │
   ├─ server.example.local  (Nginx/Envoy/HAProxy)
   └─ client (curl/browser/service)
```

---

### 사내 CA·정책 포인트

- 루트 CA는 **오프라인/HSM**(랩은 파일로 대체)
- **서버 인증서**와 **클라이언트 인증서**를 **서로 다른 인터미디어트**에서 발급(용도 분리)
- **EKU(Extended Key Usage)**:
  - 서버 cert: `TLS Web Server Authentication`
  - 클라 cert: `TLS Web Client Authentication`
- 수명: **단기(예: 90일)** + **자동 갱신**(MDM/에이전트)

---

### OpenSSL로 미니 PKI(랩용)

#### 루트 CA 생성(랩)

```bash
# 루트 키/자체서명

openssl req -x509 -newkey rsa:4096 -days 3650 -nodes \
  -keyout root.key -out root.crt -subj "/CN=Lab Root CA"
```

#### 서버용 인터미디어트

```bash
# 서버 중간 CA 키/CSR

openssl req -new -newkey rsa:4096 -nodes \
  -keyout int_srv.key -out int_srv.csr -subj "/CN=Lab Intermediate Server CA"

# 루트로 서명

openssl x509 -req -in int_srv.csr -CA root.crt -CAkey root.key -CAcreateserial \
  -out int_srv.crt -days 1825 -extfile <(printf "basicConstraints=CA:TRUE,pathlen:0")
cat int_srv.crt root.crt > int_srv_chain.crt
```

#### 클라이언트용 인터미디어트

```bash
openssl req -new -newkey rsa:4096 -nodes \
  -keyout int_cli.key -out int_cli.csr -subj "/CN=Lab Intermediate Client CA"
openssl x509 -req -in int_cli.csr -CA root.crt -CAkey root.key -CAcreateserial \
  -out int_cli.crt -days 1825 -extfile <(printf "basicConstraints=CA:TRUE,pathlen:0")
cat int_cli.crt root.crt > int_cli_chain.crt
```

#### 서버 인증서 발급

```bash
openssl req -new -newkey rsa:2048 -nodes \
  -keyout srv.key -out srv.csr -subj "/CN=server.example.local"
# SAN 지정(테스트 도메인 추가 가능)

openssl x509 -req -in srv.csr -CA int_srv.crt -CAkey int_srv.key -CAcreateserial \
  -out srv.crt -days 180 \
  -extfile <(printf "subjectAltName=DNS:server.example.local,IP:10.0.0.10\nextendedKeyUsage=serverAuth")
cat srv.crt int_srv.crt root.crt > srv_fullchain.pem
```

#### 클라이언트 인증서 발급

```bash
openssl req -new -newkey rsa:2048 -nodes \
  -keyout cli.key -out cli.csr -subj "/CN=developer01"
openssl x509 -req -in cli.csr -CA int_cli.crt -CAkey int_cli.key -CAcreateserial \
  -out cli.crt -days 180 \
  -extfile <(printf "extendedKeyUsage=clientAuth")
# 브라우저 테스트용 P12 번들

openssl pkcs12 -export -inkey cli.key -in cli.crt -certfile int_cli_chain.crt \
  -out cli.p12 -passout pass:
```

---

### Nginx에서 mTLS 강제

```nginx
server {
  listen 443 ssl http2;
  server_name server.example.local;

  # 서버 인증서 체인
  ssl_certificate     /etc/nginx/certs/srv_fullchain.pem;   # srv + int_srv + root
  ssl_certificate_key /etc/nginx/certs/srv.key;

  # 클라이언트 인증: 클라 CA 체인 지정(누구를 신뢰할지)
  ssl_client_certificate /etc/nginx/certs/int_cli_chain.crt;  # int_cli + root
  ssl_verify_client on;     # (on|optional|off)
  ssl_verify_depth 2;

  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_ciphers 'ECDHE+AESGCM:ECDHE+CHACHA20:!aNULL:!MD5:!RC4:!3DES';

  location /secure/ {
    # mTLS 결과를 백엔드에 전달해 권한 매핑
    proxy_set_header X-Client-Verify $ssl_client_verify;   # SUCCESS/FAILED/NONE
    proxy_set_header X-Client-DN     $ssl_client_s_dn;     # subject DN
    proxy_pass http://app:8080/;
  }
}
```

**접속 테스트**
```bash
# 클라 인증서 없이 → 400/403이어야 함

curl -vk https://server.example.local/secure/

# 클라 인증서로 성공

curl -vk --cert cli.crt --key cli.key https://server.example.local/secure/
# P12 사용(브라우저): cli.p12 임포트 후 접속

```

---

### Envoy/HAProxy 예시(요약)

**Envoy (static resources, 핵심만)**
```yaml
static_resources:
  listeners:
  - name: https_listener
    address: { socket_address: { address: 0.0.0.0, port_value: 443 } }
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: ingress
          route_config: { ... }
          http_filters: [{ name: envoy.filters.http.router }]
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
          common_tls_context:
            tls_certificates:
            - certificate_chain: { filename: "/certs/srv_fullchain.pem" }
              private_key:       { filename: "/certs/srv.key" }
            validation_context:
              trusted_ca: { filename: "/certs/int_cli_chain.crt" }  # 클라 CA
              match_subject_alt_names:
              - exact: developer01   # 선택적 제약
          require_client_certificate: true
```

**HAProxy (핵심만)**
```haproxy
frontend fe_https
  bind :443 ssl crt /etc/pki/srv_fullchain.pem ca-file /etc/pki/int_cli_chain.crt verify required
  http-request set-header X-Client-Verify %[ssl_c_used]
  http-request set-header X-Client-DN     %[ssl_c_s_dn]
  default_backend be_app
```

---

### 애플리케이션 계층에서의 인증 연계

- 프록시가 전달하는 헤더(`X-Client-Verify`, `X-Client-DN`)를 **ID 매핑**(사번/이메일/역할)과 연결
- 중요: 헤더 **위조 방지** — **프록시 바로 뒤에서만 신뢰**, 내부 hop에서 재설정(or 제거)

**Express 예**
```js
app.use("/secure", (req, res, next) => {
  if (req.get("X-Client-Verify") !== "SUCCESS") return res.status(403).end();
  const dn = req.get("X-Client-DN") || "";
  // DN → 사내 계정 매핑(예: /CN=developer01 → dev01)
  req.user = mapDnToUser(dn);
  next();
});
```

---

### 운영 팁: 발급·배포·회수 자동화

- **MDM/엔드포인트 관리**로 P12/키체인 배포, 만료 15~30일 전 **사전 재발급**
- **단기 수명(≤90일)** + 자동 갱신 → 폐지/도난 리스크 완화
- **키 사용 권한 최소화**(서버 계정 권한분리, 파일 접근 ACL, at-rest 암호화)
- **감사 로깅**: 누가 언제 어떤 인증서 발급/폐기/접속했는지(Privacy by Design)

---

### 점검·트러블슈팅 체크리스트

**핸드셰이크/스위트**
- [ ] TLS 1.3 우선, 1.2는 **ECDHE + GCM/CHACHA**만 허용
- [ ] 서버 우선 암호선택, 레거시 스위트 제거

**OCSP/체인**
- [ ] 체인 파일 순서 정확(leaf → intermediate → root)
- [ ] OCSP stapling 정상(만료 전 자동 갱신)

**HSTS**
- [ ] 프리로드 전 사전 테스트(서브도메인 영향 포함)
- [ ] 롤백 전략 문서화

**mTLS**
- [ ] 서버/클라 CA **분리**(EKU 분리)
- [ ] 클라 인증 실패 시 명확한 오류 페이지/가이드
- [ ] 헤더 위변조 방지(프록시 경계 내 신뢰)

**0-RTT**
- [ ] 멱등 요청만 허용 또는 **비활성화**
- [ ] Anti-replay 윈도 설정

---

### 보너스: Python으로 인증서 파싱·검증(점검 스크립트)

```python
# cert_info.py : PEM 인증서 정보를 요약 출력

from cryptography import x509
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.backends import default_backend
import sys, datetime

pem = open(sys.argv[1], "rb").read()
cert = x509.load_pem_x509_certificate(pem, default_backend())
print("Subject:", cert.subject.rfc4514_string())
print("Issuer :", cert.issuer.rfc4514_string())
print("NotBefore:", cert.not_valid_before)
print("NotAfter :", cert.not_valid_after)
print("SAN     :", [e.value for e in cert.extensions.get_extension_for_class(
    x509.SubjectAlternativeName).value.get_values_for_type(x509.DNSName)])
print("SigAlg  :", cert.signature_hash_algorithm.name)
print("KeyUsage:", cert.extensions.get_extension_for_class(x509.ExtendedKeyUsage).value)
days_left = (cert.not_valid_after - datetime.datetime.utcnow()).days
print("Days left:", days_left)
if days_left < 30:
    print("[WARN] Certificate expires in <30 days")
```

---

## 요약

- **TLS 1.3 우선**, 1.2는 **안전 스위트**만 허용. **PFS는 기본**이다.
- **0-RTT는 리플레이 리스크**—멱등 요청만 허용하거나 **비활성화**.
- **PKI는 설계가 전부**: 루트/중간 분리, EKU/체인/OCSP Stapling, 단기 수명+자동화.
- **가시성은 메타데이터로**: JA3/JA4, NetFlow, SNI/ALPN을 상관 분석.
- **mTLS는 내부 보안의 핵심**: 사내 CA, 자동 발급·회수, 프록시 연동, 헤더 위변조 방지.
- 모든 변경은 **랩에서 회귀 테스트 후 단계적 적용**이 정답이다.
