---
layout: post
title: Avalonia - 크로스플랫폼 배포 및 자동 업데이트
date: 2025-03-04 19:20:23 +0900
category: Avalonia
---
# Avalonia 애플리케이션의 크로스플랫폼 배포 및 자동 업데이트

## 0. 빌드 전략 개요

### Self-contained vs Framework-dependent

| 유형 | 런타임 포함 | 장점 | 단점 | 권장 |
|---|---|---|---|---|
| Self-contained | 포함 | 대상 PC 사전 요구 없음, 설치 간편 | 바이너리 커짐, 보안 업데이트는 앱 재배포 필요 | 배포 시 권장 |
| Framework-dependent | 미포함 | 패키지 작음 | 대상 PC에 .NET 런타임 설치 필요 | 내부 배포/개발 환경 |

> 실전 팁: Self-contained + `PublishSingleFile=true` 조합을 기본값으로 하되, **리플렉션/리소스 로딩** 많은 앱은 `PublishTrimmed`는 신중히 검토한다(잘못 트리밍되면 런타임 예외).

---

## 1. 기본 빌드 명령 (플랫폼별 RID)

### 공통 옵션

```bash
dotnet publish MyApp.csproj -c Release -r <RID> \
  --self-contained true \
  -p:PublishSingleFile=true \
  -p:IncludeNativeLibrariesForSelfExtract=true \
  -p:DebugType=embedded
```

- `PublishSingleFile`: 단일 실행 파일로 묶기
- `IncludeNativeLibrariesForSelfExtract`: 네이티브 라이브러리 압축 포함
- `DebugType=embedded`: 심볼 내장(간단 배포용)

### 대표 RID

| 플랫폼 | RID |
|---|---|
| Windows x64 | win-x64 |
| Linux glibc x64 | linux-x64 |
| Linux ARM64 | linux-arm64 |
| macOS Intel | osx-x64 |
| macOS Apple Silicon | osx-arm64 |

> 주의: macOS는 `arm64`/`x64` 이원 배포가 흔하다. 필요 시 **유니버설 바이너리** 병합도 가능하지만 일반적으로는 아키텍처별 별도 패키징을 권장한다.

---

## 2. Windows 배포: EXE(단일 파일)·MSIX·Squirrel

### 2.1 단일 EXE 퍼블리시

```bash
dotnet publish -c Release -r win-x64 \
  --self-contained true \
  -p:PublishSingleFile=true -p:IncludeNativeLibrariesForSelfExtract=true \
  -o out/win-x64
```

생성 결과: `out/win-x64/MyApp.exe`

### 2.2 MSIX 설치 패키지(대기업/엔터프라이즈 선호)

- 장점: 배포/업데이트 체계, 레지스트리/파일 격리, 서명 필수
- 단점: 작성과 서명·인증서 준비 필요

대략적 워크플로:
1) `Windows Application Packaging Project` 추가 또는 `makeappx.exe`/`signtool.exe` 수동 사용  
2) `AppxManifest.xml` 작성(아이콘/앱ID/Capabilities)  
3) 코드서명 인증서로 서명(`signtool`)  
4) 내부 배포/Intune/Endpoint Manager 또는 MS Store로 배포

### 2.3 Squirrel.Windows(자동 업데이트 포함)

#### 도구 설치

```bash
dotnet tool install --global Squirrel
# 또는 choco install squirrel.windows
```

#### Squirrel용 파일(Releasify)

```bash
# 1) 먼저 win-x64 publish 산출
dotnet publish -c Release -r win-x64 --self-contained true -o publish/win

# 2) Squirrel 릴리시파이
squirrel --releasify publish/win/MyApp.exe \
  --releaseDir artifacts/squirrel
```

산출물:
- `Setup.exe` (부트스트랩 설치기)
- `RELEASES` (업데이트 인덱스)
- `MyApp-x.y.z-full.nupkg` (+ delta nupkg)

#### 앱 코드에서 업데이트

```csharp
// Program/App 시작 시 적절 타이밍에
using Squirrel;

public static async Task CheckAndApplyUpdatesAsync()
{
    using var mgr = new UpdateManager("https://example.com/myapp/releases");
    var updates = await mgr.CheckForUpdate();
    if (updates.ReleasesToApply.Any())
    {
        await mgr.DownloadReleases(updates.ReleasesToApply);
        await mgr.ApplyReleases(updates);
        // 재시작 필요
        UpdateManager.RestartApp();
    }
}
```

> 보안: 업데이트 경로는 **TLS** 필수, 파일 **서명** 유지. 릴리즈 노트 표시/롤백 전략 포함.

---

## 3. macOS 배포: .app 번들·DMG·서명·노터라이즈

### 3.1 .app 번들 생성

```bash
dotnet publish -c Release -r osx-arm64 --self-contained true -o out/osx-arm64
```

디렉터리 구성:
```
MyApp.app/
  Contents/
    Info.plist
    MacOS/MyApp          # 실행 파일
    Resources/AppIcon.icns
```

`Info.plist` 최소 예:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
 "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleName</key><string>MyApp</string>
  <key>CFBundleIdentifier</key><string>com.example.myapp</string>
  <key>CFBundleVersion</key><string>1.2.0</string>
  <key>CFBundleShortVersionString</key><string>1.2.0</string>
  <key>LSMinimumSystemVersion</key><string>11.0</string>
  <key>NSHighResolutionCapable</key><true/>
</dict>
</plist>
```

### 3.2 코드 서명

```bash
codesign --deep --force --options runtime \
  --sign "Developer ID Application: Your Name (TEAMID)" \
  MyApp.app
```

### 3.3 노터라이즈(필수)

```bash
xcrun notarytool submit MyApp.app \
  --apple-id "appleid@example.com" \
  --team-id "TEAMID" \
  --password "@keychain:AC_PASSWORD" \
  --wait

xcrun stapler staple MyApp.app
```

### 3.4 DMG 패키징

```bash
hdiutil create -volname "MyApp" -srcfolder MyApp.app -ov -format UDZO MyApp.dmg
```

> 실전 팁: Apple Silicon과 Intel 별도 빌드 제공이 일반적. 자동 업데이트는 Sparkle(네이티브)나 커스텀/Zip 기반 프레임워크를 조합.

---

## 4. Linux 배포: AppImage / DEB / RPM / Flatpak

### 4.1 AppImage (배포 간단)

AppDir 구성:
```
AppDir/
  AppRun
  MyApp.desktop
  MyApp.png
  usr/bin/MyApp
```

`AppRun`:

```bash
#!/usr/bin/env bash
DIR="$(dirname "$(readlink -f "$0")")"
exec "$DIR/usr/bin/MyApp" "$@"
```

`MyApp.desktop`:

```ini
[Desktop Entry]
Type=Application
Name=MyApp
Exec=MyApp
Icon=MyApp
Categories=Utility;
```

빌드:

```bash
chmod +x AppDir/AppRun
appimagetool AppDir MyApp-x86_64.AppImage
```

### 4.2 DEB (Ubuntu/Debian)

구성:
```
MyApp_1.2.0/
  DEBIAN/control
  usr/share/myapp/   # 실행 파일/리소스
  usr/bin/myapp      # 런처(심볼릭/래퍼)
  usr/share/applications/myapp.desktop
  usr/share/icons/hicolor/256x256/apps/myapp.png
```

`DEBIAN/control` 예:

```text
Package: myapp
Version: 1.2.0
Section: utils
Priority: optional
Architecture: amd64
Maintainer: You <you@example.com>
Description: My cross-platform Avalonia app
```

패키징:

```bash
dpkg-deb --build MyApp_1.2.0
```

### 4.3 RPM(RHEL/Fedora), Flatpak/Snap

- RPM: `rpmbuild` 스펙 파일로 빌드
- Flatpak: 샌드박스 장점, `flatpak-builder`로 manifest 기반
- Snap: `snapcraft`로 YAML 기반 빌드(스냅 스토어)

> 기업 내부라면 DEB/RPM, 퍼블릭 배포라면 AppImage/Flatpak도 고려.

---

## 5. 자동 업데이트 전략

### 5.1 Squirrel.Windows (Windows 전용)

- 장점: 검증된 Windows 업데이트 UX, delta 패치
- 적용: 위 2.3 참조

### 5.2 Avalonia.Extensions.Update (크로스)

```bash
dotnet add package Avalonia.Extensions.Update
```

기본 사용:

```csharp
var svc = new Avalonia.Extensions.Update.UpdateService(
    new Avalonia.Extensions.Update.UpdateOptions
    {
        // 서버의 업데이트 엔드포인트/전략 설정
        Endpoint = "https://example.com/myapp/updates.json",
        AppName = "MyApp"
    });

var info = await svc.CheckUpdateAsync();
if (info.IsAvailable)
{
    await svc.DownloadAsync(info, progress: p => Console.WriteLine($"{p:P0}"));
    await svc.ApplyAsync(info);
    Environment.Exit(0); // 재시작 유도
}
```

업데이트 메타(JSON) 예:

```json
{
  "latest": "1.2.0",
  "files": {
    "win-x64": "https://cdn.example.com/MyApp-1.2.0-win.zip",
    "osx-arm64": "https://cdn.example.com/MyApp-1.2.0-osx-arm64.zip",
    "linux-x64": "https://cdn.example.com/MyApp-1.2.0-linux-x64.tar.gz"
  },
  "sha256": {
    "win-x64": "08c4...ef",
    "osx-arm64": "a1b2...34",
    "linux-x64": "de9f...84"
  },
  "notes": "버그 수정 및 성능 개선"
}
```

> 핵심: **플랫폼별 패키지·해시**를 제공, 다운로드 후 **해시 검증** 및 **서명 검증**(가능 시)을 수행.

### 5.3 커스텀 업데이트(Zip 기반)

#### 서버 버전 파일

```json
{
  "version": "1.2.0",
  "url": "https://cdn.example.com/MyApp-1.2.0-win.zip",
  "sha256": "08c4...ef",
  "mandatory": false
}
```

#### 클라이언트 구현

```csharp
public sealed class CustomUpdater
{
    private readonly HttpClient _http = new();

    public async Task<UpdateInfo?> CheckAsync(Uri jsonUri, Version current)
    {
        var json = await _http.GetStringAsync(jsonUri);
        var info = JsonSerializer.Deserialize<UpdateInfo>(json);
        if (info is null) return null;
        return new Version(info.version) > current ? info : null;
    }

    public async Task DownloadAndApplyAsync(UpdateInfo info, string appDir)
    {
        var tmp = Path.Combine(appDir, "update.tmp");
        Directory.CreateDirectory(tmp);

        var zipPath = Path.Combine(tmp, "update.zip");
        using (var fs = File.Create(zipPath))
        using (var rs = await _http.GetStreamAsync(info.url))
            await rs.CopyToAsync(fs);

        // 해시 검증
        using (var fs2 = File.OpenRead(zipPath))
        {
            var sha = Convert.ToHexString(System.Security.Cryptography.SHA256.HashData(fs2)).ToLowerInvariant();
            if (!sha.Equals(info.sha256, StringComparison.OrdinalIgnoreCase))
                throw new InvalidOperationException("무결성 검증 실패");
        }

        // 압축 해제(임시 폴더)
        System.IO.Compression.ZipFile.ExtractToDirectory(zipPath, tmp, overwriteFiles: true);

        // 안전 적용 전략:
        // 1) 현재 실행 파일/리소스를 백업
        // 2) 파일 교체
        // 3) 재시작
        // Windows: 실행중 파일 교체 제약 → 외부 "Updater" 프로세스 사용 권장
    }

    public record UpdateInfo(string version, string url, string sha256, bool mandatory);
}
```

> 중요한 실전 포인트  
> - Windows: 실행 중 파일 Lock → **외부 Updater** (작은 콘솔/서비스) 프로세스가 종료 감지 후 교체  
> - macOS: .app 번들 교체 시 **서명 유지**·노터라이즈된 번들로 교체  
> - Linux: AppImage라면 자체 업데이트(스쿼시FS 교체) 또는 재배포

---

## 6. 업데이트 UX 설계

### 6.1 기본 뷰모델/뷰

```csharp
public sealed class UpdateViewModel : ReactiveUI.ReactiveObject
{
    private readonly IMyUpdater _updater;

    public bool IsChecking { get; private set; }
    public bool IsAvailable { get; private set; }
    public string? LatestVersion { get; private set; }
    public double Progress { get; private set; }
    public string? Notes { get; private set; }

    public ReactiveCommand<Unit, Unit> CheckCommand { get; }
    public ReactiveCommand<Unit, Unit> ApplyCommand { get; }

    public UpdateViewModel(IMyUpdater updater)
    {
        _updater = updater;

        CheckCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            IsChecking = true; this.RaisePropertyChanged(nameof(IsChecking));
            var res = await _updater.CheckAsync();
            IsChecking = false; this.RaisePropertyChanged(nameof(IsChecking));

            if (res is { } info)
            {
                IsAvailable = true;
                LatestVersion = info.Version;
                Notes = info.ReleaseNotes;
            }
            else
            {
                IsAvailable = false; LatestVersion = null; Notes = null;
            }
            this.RaisePropertyChanged(nameof(IsAvailable));
            this.RaisePropertyChanged(nameof(LatestVersion));
            this.RaisePropertyChanged(nameof(Notes));
        });

        ApplyCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            await _updater.DownloadAndApplyAsync(p =>
            {
                Progress = p;
                this.RaisePropertyChanged(nameof(Progress));
            });
        }, this.WhenAnyValue(x => x.IsAvailable));
    }
}
```

XAML:

```xml
<StackPanel Spacing="8" Margin="16">
  <Button Content="업데이트 확인" Command="{Binding CheckCommand}" IsEnabled="{Binding IsChecking, Converter={StaticResource InverseBool}}"/>
  <TextBlock Text="{Binding LatestVersion, StringFormat=새 버전: {0}}" />
  <ScrollViewer MaxHeight="150">
    <TextBlock Text="{Binding Notes}" TextWrapping="Wrap"/>
  </ScrollViewer>
  <ProgressBar Minimum="0" Maximum="1" Value="{Binding Progress}" Height="8"/>
  <Button Content="업데이트 적용" Command="{Binding ApplyCommand}" IsEnabled="{Binding IsAvailable}"/>
</StackPanel>
```

### 6.2 UX 베스트프랙티스

- 자동 체크(앱 시작 후 비동기) + 사용자가 수동으로 재확인 가능  
- 변경 로그(릴리즈 노트) 표시  
- 다운로드 진행률/남은 시간(대략) 표시  
- 강제 업데이트 플래그(`mandatory`) 지원  
- 중단/재시도/로그 수집

---

## 7. 보안·무결성·롤백

| 항목 | 권장 |
|---|---|
| TLS | 업데이트 엔드포인트 HTTPS 필수 |
| 서명 | Windows 코드서명, macOS 서명+노터라이즈, 배포 zip 서명/해시 |
| 해시 검증 | SHA-256 등으로 파일 무결성 확인 |
| 롤백 | 적용 전 백업, 실패 시 자동 복구 루틴 |
| 권한 | 관리자/UAC 필요 여부 명확화(설치 경로에 따라 다름) |
| 장애 대응 | 실패 로그/추적, 재시작 로직 안전화 |

---

## 8. CI/CD: GitHub Actions 매트릭스 빌드 + 릴리즈

### 8.1 매트릭스 예시

```yaml
name: build-release

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  publish:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: windows-latest
            rid: win-x64
            ext: zip
          - os: ubuntu-latest
            rid: linux-x64
            ext: tar.gz
          - os: macos-latest
            rid: osx-arm64
            ext: zip
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Publish
        run: dotnet publish src/MyApp/MyApp.csproj -c Release -r ${{ matrix.rid }} --self-contained true -p:PublishSingleFile=true -o publish/${{ matrix.rid }}

      - name: Pack artifact (zip/tar)
        shell: bash
        run: |
          cd publish/${{ matrix.rid }}
          if [ "${{ matrix.ext }}" = "zip" ]; then
            7z a ../../MyApp-${{ matrix.rid }}.zip *
          else
            tar -czf ../../MyApp-${{ matrix.rid }}.tar.gz *
          fi

      - name: Upload release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            MyApp-${{ matrix.rid }}.zip
            MyApp-${{ matrix.rid }}.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

> 확장: Windows에서 Squirrel Releasify 실행 후 `RELEASES` / `Setup.exe` 업로드. macOS에선 서명/노터라이즈 단계를 별 Job으로 추가.

---

## 9. 성능·용량 튜닝

| 옵션 | 설명 | 주의 |
|---|---|---|
| ReadyToRun | 시작 속도 개선 | 바이너리 증가 |
| PGO | 프로파일 기반 최적화 | 수집/적용 번거로움 |
| PublishTrimmed | 미사용 코드 제거 | 리플렉션·XAML 로딩 주의(실패 위험) |
| Invariant Globalization | ICU 제외로 용량↓ | 국제화 기능 제한 |

예:

```bash
dotnet publish -c Release -r win-x64 --self-contained true \
  -p:PublishSingleFile=true -p:ReadyToRun=true -p:InvariantGlobalization=true
```

Avalonia는 리플렉션/XAML 로딩이 많아 `PublishTrimmed=true`는 **케이스 바이 케이스**.

---

## 10. 플랫폼별 체크리스트

### Windows
- 코드서명 인증서 준비(기업 환경에선 EV 권장)  
- SmartScreen 경고 방지(평판 형성까지 시간 필요)  
- Squirrel/MSIX 중 선택(요구사항·배포 채널에 따라)

### macOS
- Apple Developer 계정  
- 서명 + 노터라이즈, 번들 구조/권한(Entitlements)  
- DMG 패키징 및 Gatekeeper 통과

### Linux
- AppImage: 가장 간단  
- DEB/RPM: 배포 리포지토리 운영 시 표준  
- Flatpak/Snap: 스토어 생태계(샌드박스 고려)

---

## 11. 통합 예시: 업데이트 뷰 + 서비스 연결

```csharp
public interface IAppUpdateService
{
    Task<(bool available, string version, string notes)> CheckAsync();
    Task DownloadAsync(IProgress<double> progress);
    Task ApplyAsync();
}

public sealed class AppUpdateService : IAppUpdateService
{
    private readonly IUpdateBackend _backend; // Squirrel/AvaloniaUpdate/Custom 중 하나 주입

    public AppUpdateService(IUpdateBackend backend) { _backend = backend; }

    public Task<(bool, string, string)> CheckAsync() => _backend.CheckAsync();
    public Task DownloadAsync(IProgress<double> progress) => _backend.DownloadAsync(progress);
    public Task ApplyAsync() => _backend.ApplyAsync();
}
```

DI 등록:

```csharp
services.AddSingleton<IUpdateBackend, SquirrelBackend>(); // 또는 CustomBackend
services.AddSingleton<IAppUpdateService, AppUpdateService>();
services.AddTransient<UpdateViewModel>();
```

---

## 12. 장애/롤백 시나리오

1) 다운로드 실패 → 재시도·미러 경로  
2) 검증 실패 → 사용자 경고·로그 제출  
3) 적용 실패 → 자동 롤백(백업 복원)  
4) 재시작 실패 → 진단 모드/세이프 모드 진입(플러그인 비활성화 등)

---

## 13. 문서/메타데이터 관리

- `CHANGELOG.md`: 릴리즈 노트 자동 노출  
- `version.json`: 앱 내부/업데이트 서버 동기화  
- 빌드 넘버: CI에서 `GitTag`(vX.Y.Z) → 앱 어셈블리 버전에 주입

`Directory.Build.props` 예:

```xml
<Project>
  <PropertyGroup>
    <Version>1.2.0</Version>
    <Authors>Your Team</Authors>
    <Company>Your Company</Company>
    <Product>MyApp</Product>
    <NeutralLanguage>en</NeutralLanguage>
  </PropertyGroup>
</Project>
```

---

## 결론

- 배포는 **Self-contained + SingleFile**을 기본축으로 잡고, 플랫폼별 특수 요구(서명/노터라이즈/패키지 형식)를 덧붙인다.
- 자동 업데이트는 **Windows=Squirrel**이 간명, 그 외 플랫폼은 **Zip/커스텀 또는 Avalonia.Extensions.Update**로 일관성 있게.
- 보안·무결성·롤백·UX까지 포함한 **운영 시나리오**를 설계하면, 장기간 안정적으로 배포/업데이트 파이프라인을 굴릴 수 있다.

필요하면 실제 레포 템플릿(솔루션 구조·GitHub Actions·Squirrel/DMG/AppImage 스크립트) 형태로 이어서 제공하겠다.