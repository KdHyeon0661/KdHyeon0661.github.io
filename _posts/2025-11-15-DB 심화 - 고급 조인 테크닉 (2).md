---
layout: post
title: DB 심화 - 고급 조인 테크닉 (2)
date: 2025-11-15 15:25:23 +0900
category: DB 심화
---
# 고급 조인 테크닉 2

실행 후에는 다음으로 **실측 플랜**을 확인하세요.

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

---

## 공통 실습 스키마

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

-- 고객, 주문, 주문상세, 상품, 가격이력(선분), 상태이력(점/선분 혼합) 구성
DROP TABLE CUST        PURGE;
DROP TABLE ORD         PURGE;
DROP TABLE OI          PURGE;
DROP TABLE PROD        PURGE;
DROP TABLE PRICE_EVT   PURGE;
DROP TABLE STATUS_EVT  PURGE;

CREATE TABLE CUST(
  CUST_ID   NUMBER       PRIMARY KEY,
  REGION    VARCHAR2(8)  NOT NULL,     -- 'APAC','EMEA','AMER','KOR','JPN'
  SEGMENT   VARCHAR2(8)  NOT NULL      -- 'VIP','GOLD','SILVER','GEN'
);

CREATE TABLE ORD(
  ORDER_ID  NUMBER       PRIMARY KEY,
  CUST_ID   NUMBER       NOT NULL,
  ORDER_DT  DATE         NOT NULL,
  STATUS    VARCHAR2(8)  NOT NULL
);

CREATE TABLE OI(
  ORDER_ID  NUMBER       NOT NULL,
  LINE_NO   NUMBER       NOT NULL,
  PROD_ID   NUMBER       NOT NULL,
  QTY       NUMBER       NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY (ORDER_ID, LINE_NO)
);

CREATE TABLE PROD(
  PROD_ID   NUMBER       PRIMARY KEY,
  CATEGORY  VARCHAR2(12) NOT NULL
);

-- 가격 '선분' 이력: (시작일, 다음 시작일-1) 구간 유효
CREATE TABLE PRICE_EVT(
  PROD_ID   NUMBER NOT NULL,
  EVT_DT    DATE   NOT NULL,      -- 시작 경계
  NEW_PRICE NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_PRICE_EVT PRIMARY KEY (PROD_ID, EVT_DT)
);

-- 상태 '점' 이력(스냅샷처럼 당일의 상태만 기록되기도 함) + 간단 선분 케이스 혼재
CREATE TABLE STATUS_EVT(
  CUST_ID   NUMBER NOT NULL,
  EVT_DT    DATE   NOT NULL,
  STATUS    VARCHAR2(10) NOT NULL,    -- 'ACTIVE','SUSPEND','LEAVE' 등
  CONSTRAINT PK_STATUS_EVT PRIMARY KEY (CUST_ID, EVT_DT)
);

-- 인덱스
CREATE INDEX IX_ORD_CUST   ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_OI_PROD    ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER   ON OI(ORDER_ID);
CREATE INDEX IX_PE_EVT     ON PRICE_EVT(PROD_ID, EVT_DT);
CREATE INDEX IX_ST_EVT     ON STATUS_EVT(CUST_ID, EVT_DT);

-- 샘플 데이터
BEGIN
  FOR c IN 1..10000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,5) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' WHEN 2 THEN 'AMER' WHEN 3 THEN 'KOR' ELSE 'JPN' END,
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..3000 LOOP
    INSERT INTO PROD VALUES( p
      , CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FASH'
                      WHEN 2 THEN 'FOOD' WHEN 3 THEN 'HOME' ELSE 'TOY' END );
  END LOOP;

  FOR o IN 1..60000 LOOP
    INSERT INTO ORD VALUES(
      o, MOD(o,10000)+1,
      DATE '2024-01-01' + MOD(o,365),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  FOR i IN 1..180000 LOOP
    INSERT INTO OI VALUES(
      MOD(i,60000)+1,
      1 + MOD(i,3),
      MOD(i,3000)+1,
      1 + MOD(i,5),
      ROUND(DBMS_RANDOM.VALUE(10,800),2)
    );
  END LOOP;

  -- 가격 이력(선분): 상품 몇 개만 복수 변경
  INSERT INTO PRICE_EVT VALUES(10,  DATE '2024-01-01', 100);
  INSERT INTO PRICE_EVT VALUES(10,  DATE '2024-02-01', 120);
  INSERT INTO PRICE_EVT VALUES(10,  DATE '2024-03-10', 130);
  INSERT INTO PRICE_EVT VALUES(11,  DATE '2024-01-20',  80);
  INSERT INTO PRICE_EVT VALUES(11,  DATE '2024-04-01',  95);

  -- 고객 상태 점/선분 혼합: 같은 고객 여러 날짜에 상태 기록
  INSERT INTO STATUS_EVT VALUES(1,  DATE '2024-01-01','ACTIVE');
  INSERT INTO STATUS_EVT VALUES(1,  DATE '2024-03-01','SUSPEND');
  INSERT INTO STATUS_EVT VALUES(1,  DATE '2024-04-01','ACTIVE');
  INSERT INTO STATUS_EVT VALUES(2,  DATE '2024-02-01','ACTIVE');
  INSERT INTO STATUS_EVT VALUES(2,  DATE '2024-05-01','LEAVE');

  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OI'  , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PRICE_EVT', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'STATUS_EVT',cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

# 징검다리(Bridge / Stepping-Stone) 테이블 조인을 이용한 튜닝

> **아이디어**: 대형 팩트 ↔ 대형 팩트의 직접 조인을 피하고,
> **중간에 “작고 선택도 좋은 키 집합(브리지)”**을 세워 **범위를 급격히 축소**한 뒤 최종 조인.

## 패턴 A — “조건 요약 브리지”로 대형 조인 축소

**요구**: “2024-03월에 **KOR·VIP** 고객이 구매한 **ELEC** 카테고리 **상품**의 매출 합계”

### 브리지 없이 (직접 4-way 조인)

```sql
SELECT SUM(i.amount) AS total_amt
FROM   ORD  o
JOIN   OI   i ON i.order_id = o.order_id
JOIN   CUST c ON c.cust_id  = o.cust_id
JOIN   PROD p ON p.prod_id  = i.prod_id
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
AND    c.region = 'KOR'
AND    c.segment = 'VIP'
AND    p.category = 'ELEC';
```
- **단점**: 초대형 조인에서 **조기 프루닝**이 어렵다면 불필요한 스캔/해시가 발생.

### 브리지 도입 — “작은 키 집합”부터 만든 후 최종 결합

```sql
WITH C_BRIDGE AS (   -- 고객 징검다리
  SELECT /*+ MATERIALIZE */
         c.cust_id
  FROM   CUST c
  WHERE  c.region = 'KOR'
  AND    c.segment = 'VIP'
),
P_BRIDGE AS (        -- 상품 징검다리
  SELECT /*+ MATERIALIZE */
         p.prod_id
  FROM   PROD p
  WHERE  p.category = 'ELEC'
),
O_BRIDGE AS (        -- 주문 징검다리 (기간 + 고객브리지)
  SELECT /*+ MATERIALIZE */ o.order_id
  FROM   ORD o
  JOIN   C_BRIDGE cb ON cb.cust_id = o.cust_id
  WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
)
SELECT /*+ ORDERED LEADING(o_b i p_b) USE_NL(i) USE_NL(p_b) */
       SUM(i.amount) AS total_amt
FROM   O_BRIDGE o_b
JOIN   OI      i   ON i.order_id = o_b.order_id
JOIN   P_BRIDGE p_b ON p_b.prod_id = i.prod_id;
```

**핵심**
- 브리지는 각각 **단일 컬럼 키**로 **작게** 만든다(`MATERIALIZE`로 재사용).
- 최종 조인은 **브리지 ↔ 팩트(세부)** 중심 → **랜덤 I/O** 최소화(특히 `USE_NL` + 인덱스).

**언제 효과적인가?**
- 원본 조건이 **서로 다른 테이블**에 흩어져 있고, 각 조건이 **선택도가 높아** 결합하면 **키 집합이 매우 작아질 때**.

## 패턴 B — “기간/버전 브리지”로 선분조인 후보 축소

> 선분조인은 비등치 조건이라 해시/정렬 비용이 클 수 있음.
> **기간키 브리지**를 먼저 만들어 **후보 구간**만 남긴 후 조인.

예: “3월 주문에 적용되는 **유효 가격 구간**만 뽑아 연결”

```sql
WITH PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVT
),
-- 기간키 브리지: 3월 주문이 실제로 존재하는 (prod_id, 기간) 후보만
CAND_SEG AS (
  SELECT /*+ MATERIALIZE */
         DISTINCT s.prod_id, p.start_dt, p.end_dt, p.new_price
  FROM   OI s
  JOIN   ORD o ON o.order_id = s.order_id
  JOIN   PRICE_SEG p
         ON p.prod_id = s.prod_id
        AND o.order_dt >= p.start_dt
        AND o.order_dt <  p.end_dt
  WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
)
SELECT /*+ ORDERED USE_NL(i) */
       o.order_id, i.line_no, i.prod_id, i.qty, c.new_price,
       i.qty * c.new_price AS revenue
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
JOIN   CAND_SEG c
       ON c.prod_id = i.prod_id
      AND o.order_dt >= c.start_dt
      AND o.order_dt <  c.end_dt
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
```

**효과**
- 원래 **PRICE_SEG 전체**와 비등치 조인하던 것을, **3월에 실제로 참조된 구간 후보(CAND_SEG)**로 축소.
- 이후 동일 조건을 한 번 더 쓰지만(실조인) 후보가 작아 전체 비용이 급감.

---

# 점이력 조회 (Point-in-Time Lookup)

> **“특정 시점 T에서의 상태/값”**을 찾아 붙이는 패턴.
> 점이력은 **그 날 한 줄**만 기록된 경우가 많아 `MAX(EVT_DT) ≤ T` 형태를 쓴다.
> (Flashback Query로 `AS OF`도 가능)

## ROW_NUMBER (Top-1 per key at T)

예: 주문일 당시 **고객 상태**를 붙이기

```sql
-- 주문일자(POINT)에 맞는 고객 상태(이전 발생일 중 가장 최신)를 붙임
WITH S_AT AS (
  SELECT s.cust_id, s.evt_dt, s.status
  FROM   STATUS_EVT s
),
O AS (
  SELECT order_id, cust_id, order_dt
  FROM   ORD
  WHERE  order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-10'
),
LKP AS (
  SELECT /*+ ORDERED */
         o.order_id, o.cust_id, o.order_dt,
         -- 해당 cust_id에 대해 EVT_DT ≤ order_dt인 것 중 최신 1건
         (SELECT status
          FROM   (
            SELECT se.status
                 , ROW_NUMBER() OVER(ORDER BY se.evt_dt DESC) rn
            FROM   STATUS_EVT se
            WHERE  se.cust_id = o.cust_id
            AND    se.evt_dt <= o.order_dt
          )
          WHERE rn = 1
         ) AS status_at_order
  FROM   O o
)
SELECT * FROM LKP;
```

**실무 권장**: 상관 서브쿼리 대신, **APPLY(LATERAL)**가 더 빠르고 읽기 좋다.

```sql
SELECT o.order_id, o.cust_id, v.status_at
FROM   ORD o
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(se IX_ST_EVT) */
         se.status AS status_at
  FROM   STATUS_EVT se
  WHERE  se.cust_id = o.cust_id
  AND    se.evt_dt <= o.order_dt
  FETCH FIRST 1 ROWS ONLY
) v
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-10';
```

- `IX_ST_EVT(cust_id, evt_dt)` **역순 인덱스 + Stopkey**로 **랜덤 I/O 최소화**.

## Flashback Query로 **SCN/시간** 기준 조회

```sql
-- 예: 어제 23:59:59 시점의 고객 상태 스냅샷 (UNDO/FBDA 설정 필요)
SELECT /*+ AS OF TIMESTAMP */ *
FROM   STATUS_EVT AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL '1' DAY)
WHERE  cust_id IN (1,2,3);
```

- Flashback은 **Undo 보존**에 의존. 지속 보장 필요하면 **Flashback Data Archive**(Total Recall) 고려.

---

# 선분이력 조인 (Interval/Temporal Join)

> **선분(시작~끝) 구간**을 미리 만들어두고, 포인트 테이블과 **비등치**로 매칭.
> (가격, 등급, 담당자, 계약 등)

## 선분 만들기(PRICE_EVT → PRICE_SEG)

```sql
WITH PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVT
)
SELECT * FROM PRICE_SEG ORDER BY prod_id, start_dt;
```

## 포인트(주문일)와 매칭

```sql
WITH PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVT
)
SELECT o.order_id, i.line_no, i.prod_id, i.qty,
       p.new_price, i.qty*p.new_price AS revenue
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
JOIN   PRICE_SEG p
       ON p.prod_id = i.prod_id
      AND o.order_dt >= p.start_dt
      AND o.order_dt <  p.end_dt
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
```

---

# 선분이력 조인 **튜닝**

## 인덱스/파티션 설계

- **선분 테이블(PRICE_SEG/PRICE_EVT)**
  - 인덱스: `(prod_id, start_dt)` or `(prod_id, start_dt, end_dt)`
  - **파티셔닝**: `RANGE(start_dt)` 또는 `RANGE(evt_dt)`로 **기간 프루닝**
- **포인트 테이블(ORD/OI)**
  - 기간 조회가 잦다면 `RANGE(order_dt)` 파티션 + `order_dt` 프루닝

## 조인 순서/메소드

- **드라이빙**: 보통 **포인트(ORD)** → 선분(PRICE_SEG).
- 메소드:
  - **NL + 역순 인덱스**: (prod_id, start_dt) 인덱스 → **소량 다회 조회**에 유리
  - **HASH**: 대량 배치/리포트, 후보 선분을 먼저 줄인 뒤 해시조인
- 힌트 예시:
```sql
SELECT /*+ ORDERED LEADING(o i p) USE_NL(i) USE_NL(p) INDEX(p IX_PE_EVT) */ ...
```

## “후보 선분 브리지”로 후보 줄이기 (앞 1.2 참조)

- 대량 기간에서는 직접 비등치 조인보다 **CAND_SEG**(후보 구간) 브리지로 먼저 축소.

## 교집합/겹침 판정 최적화

- 겹침 조건: `s.end_dt > p.start_dt AND s.start_dt < p.end_dt`
- **정규화**: 시작<끝이 보장되도록 입력 검증.
- **Edge 포함 여부**(<= vs <)를 **일관되게** 유지(중복/누락 방지).

## 메모리/Temp

- 해시/정렬이 필요한 경우 `+MEMSTATS`로 **PGA/TempSpc** 확인 →
  **빌드 입력 축소**(필터·DISTINCT/집계), `MATERIALIZE`로 재사용.

---

# “조인에 실패한 레코드” 읽기 (Unmatched Rows)

> **품질 점검/결손 데이터** 찾기.
> 대표적으로 **ANTI-JOIN**(`NOT EXISTS`, `LEFT OUTER ... WHERE right IS NULL`), **SEMijoin** 등.

## 왼쪽에는 있는데 오른쪽에 **없는** 키 (ANTI-JOIN)

예: 주문상세 OI에 있으나 상품 PROD에 **존재하지 않는** PROD_ID (데이터 정합성 점검)

```sql
-- 패턴 1) NOT EXISTS (권장)
SELECT /*+ USE_NL(o) */ DISTINCT i.prod_id
FROM   OI i
WHERE  NOT EXISTS (
  SELECT 1 FROM PROD p WHERE p.prod_id = i.prod_id
);

-- 패턴 2) OUTER JOIN + NULL 필터
SELECT DISTINCT i.prod_id
FROM   OI i
LEFT   JOIN PROD p ON p.prod_id = i.prod_id
WHERE  p.prod_id IS NULL;
```

- **NOT EXISTS**가 일반적으로 읽기량이 적고 옵티마이저가 잘 최적화.
- `DISTINCT`는 중복 키만 제거하기 위한 최소 사용.

## 오른쪽에는 있는데 왼쪽에 **매칭 주문이 없는** 상품 (Right-ANTI)

```sql
SELECT p.prod_id
FROM   PROD p
WHERE  NOT EXISTS (
  SELECT 1 FROM OI i WHERE i.prod_id = p.prod_id
);
```

## 선분 매칭 실패: 포인트가 어떤 구간에도 속하지 않음

```sql
WITH PRICE_SEG AS (
  SELECT prod_id, evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt
  FROM   PRICE_EVT
)
SELECT /*+ ORDERED USE_NL(i) */ DISTINCT i.prod_id
FROM   OI i
JOIN   ORD o ON o.order_id = i.order_id
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
AND    NOT EXISTS (
  SELECT 1
  FROM   PRICE_SEG p
  WHERE  p.prod_id = i.prod_id
  AND    o.order_dt >= p.start_dt
  AND    o.order_dt <  p.end_dt
);
```

- 데이터 결손/가격 미정/이력 단절을 쉽게 검출.

## FULL OUTER로 **양쪽 결손** 한 번에 보기

```sql
SELECT COALESCE(l.key, r.key) AS key
     , CASE WHEN l.key IS NULL THEN 'RIGHT_ONLY'
            WHEN r.key IS NULL THEN 'LEFT_ONLY'
            ELSE 'BOTH' END AS where_is
FROM (SELECT DISTINCT prod_id AS key FROM OI)  l
FULL OUTER JOIN
     (SELECT DISTINCT prod_id AS key FROM PROD) r
  ON r.key = l.key
WHERE l.key IS NULL OR r.key IS NULL;  -- 미매칭만
```

---

# 실전 시나리오 종합

> **목표**: 3월 기간 동안 KOR·VIP 고객의 주문에 대해
> 1) **징검다리 조인**으로 후보를 축소해 매출 계산,
> 2) 주문일 **점이력(고객 상태)** 붙이기,
> 3) 주문일 유효 **가격(선분)** 붙이기,
> 4) **선분조인 튜닝**(후보 브리지),
> 5) **미매칭 상품/가격** 검출.

```sql
WITH
C_BRIDGE AS (
  SELECT /*+ MATERIALIZE */
         cust_id
  FROM   CUST
  WHERE  region='KOR' AND segment='VIP'
),
O_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ o.order_id, o.cust_id, o.order_dt
  FROM   ORD o
  JOIN   C_BRIDGE c ON c.cust_id = o.cust_id
  WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
),
PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVT
),
-- 선분 후보만: 3월에 실제로 조회되는 (prod_id, 구간)만 추림
P_CAND AS (
  SELECT /*+ MATERIALIZE */ DISTINCT p.prod_id, p.start_dt, p.end_dt, p.new_price
  FROM   OI i
  JOIN   O_BRIDGE o ON o.order_id = i.order_id
  JOIN   PRICE_SEG p
         ON p.prod_id = i.prod_id
        AND o.order_dt >= p.start_dt
        AND o.order_dt <  p.end_dt
),
-- 점이력: 주문일 당시 고객 상태 Top-1
S_AT AS (
  SELECT o.order_id,
         (SELECT se.status
          FROM   STATUS_EVT se
          WHERE  se.cust_id = o.cust_id
          AND    se.evt_dt <= o.order_dt
          ORDER  BY se.evt_dt DESC
          FETCH FIRST 1 ROWS ONLY) AS status_at
  FROM   O_BRIDGE o
)
SELECT /*+ ORDERED LEADING(o_b i p_c s_at) USE_NL(i) USE_NL(p_c) */
       o_b.order_id, i.line_no, i.prod_id,
       i.qty, p_c.new_price, i.qty*p_c.new_price AS revenue,
       s_at.status_at
FROM   O_BRIDGE o_b
JOIN   OI       i    ON i.order_id = o_b.order_id
JOIN   P_CAND   p_c  ON p_c.prod_id = i.prod_id
                    AND o_b.order_dt >= p_c.start_dt
                    AND o_b.order_dt <  p_c.end_dt
LEFT   JOIN S_AT s_at ON s_at.order_id = o_b.order_id;
```

- **브리지**(C_BRIDGE, O_BRIDGE, P_CAND)로 **범위 축소**
- **점이력**은 **Top-1**(APPLY 또는 `FETCH FIRST 1`)
- **선분조인**은 후보 선분으로 최적화

**미매칭 검출(가격 선분 없음)**

```sql
SELECT DISTINCT i.prod_id
FROM   OI i
JOIN   O_BRIDGE o ON o.order_id = i.order_id
LEFT   JOIN P_CAND p ON p.prod_id = i.prod_id
                    AND o.order_dt >= p.start_dt
                    AND o.order_dt <  p.end_dt
WHERE  p.prod_id IS NULL;
```

---

# 체크리스트

- [ ] **징검다리 조인**: 조건별 **작은 키 집합**을 먼저 만들어 **최종 팩트**와 결합. `MATERIALIZE`로 재사용.
- [ ] **점이력**: `ROW_NUMBER()`/`APPLY` + **역순 인덱스**(키, 시점)로 Top-1.
- [ ] **선분이력**: `LEAD`로 **구간화** → 포인트와 **비등치**. 경계 포함 규칙(<= vs <) 통일.
- [ ] **선분 튜닝**: (키, start_dt) 인덱스, 기간 파티셔닝, **후보 선분 브리지** 축소, 조인 순서/메소드 고정.
- [ ] **미매칭 읽기**: `NOT EXISTS`(권장), `LEFT OUTER ... IS NULL`, `FULL OUTER` 패턴.
- [ ] **실측 검증**: `DBMS_XPLAN ... +IOSTATS +MEMSTATS`로 **Buffers/TempSpc/Elapsed** 확인.
- [ ] **통계/히스토그램** 최신화, 바인드 값 스큐 시 **ACS(Adaptive Cursor Sharing)** 고려.

---

## 자주 쓰는 힌트 스니펫

```sql
/* 브리지 재사용 */
WITH B AS (SELECT /*+ MATERIALIZE */ ... FROM ...) SELECT ...

/* 조인 순서/메소드 고정 */
SELECT /*+ ORDERED LEADING(o i p) USE_NL(i) USE_NL(p) */ ...

/* 선분 후보 축소 후 해시 */
SELECT /*+ USE_HASH(p) */ ...

/* Top-1 per key (APPLY) */
SELECT ...
FROM   T
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(s idx_key_time) */ ...
  FROM   S WHERE S.key=T.key AND S.time<=T.time
  FETCH FIRST 1 ROWS ONLY
) v;
```

---

### 요약

- **징검다리 조인**은 “**작은 키 집합**을 먼저 만든 뒤 결합”하는 기법으로, **대형 조인의 I/O와 해시/정렬 비용**을 극적으로 줄입니다.
- **점이력**은 **Top-1 per key at time**(APPLY/ROW_NUMBER)로, **선분이력**은 `LEAD` 기반 **구간화 + 비등치 조인**이 정석입니다.
- **선분 조인 튜닝**의 핵심은 **후보 축소(브리지)**, **인덱스/파티션 프루닝**, **조인 순서/메소드** 선택입니다.
- **미매칭(조인 실패) 레코드**는 `NOT EXISTS`/OUTER-NULL 필터로 빠르게 검출하세요.
- 끝으로, 항상 **DBMS_XPLAN 실측**으로 검증해 “읽은 블록 수”와 “Temp/PGA 사용”을 확인하는 습관이 성능을 보장합니다.
