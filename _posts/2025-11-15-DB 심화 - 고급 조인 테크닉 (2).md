---
layout: post
title: DB 심화 - 고급 조인 테크닉 (2)
date: 2025-11-15 15:25:23 +0900
category: DB 심화
---
# Oracle 고급 조인 테크닉 2 — 징검다리(Bridge) 조인, 점/선분 이력(Temporal) 조인, 미매칭(ANTI/FULL OUTER) 탐지, 그리고 실전 튜닝 패턴

## 0. 실측 플랜 확인 루틴(필수)

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL,NULL,
         'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS +ALIAS +NOTE'
));
```

### 0.1 무엇을 봐야 하나?
- **E-Rows vs A-Rows**: 카디널리티 오판 지점이 어디인지  
- **Buffers / Reads / Writes**: 논리/물리 I/O 규모  
- **TempSpc / PGA**: 정렬·해시 스필 여부  
- **Join Method / Order**: NL/HJ/SMJ, 드라이빙 방향  
- **Predicate 위치**: access vs filter, 푸시다운/추론 성공 여부

---

## 1. 공통 실습 스키마/데이터/통계

> 사용자가 제공한 스키마를 그대로 채택한다.

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

DROP TABLE CUST        PURGE;
DROP TABLE ORD         PURGE;
DROP TABLE OI          PURGE;
DROP TABLE PROD        PURGE;
DROP TABLE PRICE_EVT   PURGE;
DROP TABLE STATUS_EVT  PURGE;

CREATE TABLE CUST(
  CUST_ID   NUMBER       PRIMARY KEY,
  REGION    VARCHAR2(8)  NOT NULL,
  SEGMENT   VARCHAR2(8)  NOT NULL
);

CREATE TABLE ORD(
  ORDER_ID  NUMBER       PRIMARY KEY,
  CUST_ID   NUMBER       NOT NULL,
  ORDER_DT  DATE         NOT NULL,
  STATUS    VARCHAR2(8)  NOT NULL
);

CREATE TABLE OI(
  ORDER_ID  NUMBER       NOT NULL,
  LINE_NO   NUMBER       NOT NULL,
  PROD_ID   NUMBER       NOT NULL,
  QTY       NUMBER       NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY (ORDER_ID, LINE_NO)
);

CREATE TABLE PROD(
  PROD_ID   NUMBER       PRIMARY KEY,
  CATEGORY  VARCHAR2(12) NOT NULL
);

CREATE TABLE PRICE_EVT(
  PROD_ID   NUMBER NOT NULL,
  EVT_DT    DATE   NOT NULL,
  NEW_PRICE NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_PRICE_EVT PRIMARY KEY (PROD_ID, EVT_DT)
);

CREATE TABLE STATUS_EVT(
  CUST_ID   NUMBER NOT NULL,
  EVT_DT    DATE   NOT NULL,
  STATUS    VARCHAR2(10) NOT NULL,
  CONSTRAINT PK_STATUS_EVT PRIMARY KEY (CUST_ID, EVT_DT)
);

CREATE INDEX IX_ORD_CUST   ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_OI_PROD    ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER   ON OI(ORDER_ID);
CREATE INDEX IX_PE_EVT     ON PRICE_EVT(PROD_ID, EVT_DT);
CREATE INDEX IX_ST_EVT     ON STATUS_EVT(CUST_ID, EVT_DT);

BEGIN
  FOR c IN 1..10000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,5)
        WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA'
        WHEN 2 THEN 'AMER' WHEN 3 THEN 'KOR' ELSE 'JPN' END,
      CASE MOD(c,4)
        WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..3000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5)
        WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FASH'
        WHEN 2 THEN 'FOOD' WHEN 3 THEN 'HOME' ELSE 'TOY' END
    );
  END LOOP;

  FOR o IN 1..60000 LOOP
    INSERT INTO ORD VALUES(
      o, MOD(o,10000)+1,
      DATE '2024-01-01' + MOD(o,365),
      CASE MOD(o,4)
        WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID'
        WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  FOR i IN 1..180000 LOOP
    INSERT INTO OI VALUES(
      MOD(i,60000)+1,
      1 + MOD(i,3),
      MOD(i,3000)+1,
      1 + MOD(i,5),
      ROUND(DBMS_RANDOM.VALUE(10,800),2)
    );
  END LOOP;

  INSERT INTO PRICE_EVT VALUES(10,  DATE '2024-01-01', 100);
  INSERT INTO PRICE_EVT VALUES(10,  DATE '2024-02-01', 120);
  INSERT INTO PRICE_EVT VALUES(10,  DATE '2024-03-10', 130);
  INSERT INTO PRICE_EVT VALUES(11,  DATE '2024-01-20',  80);
  INSERT INTO PRICE_EVT VALUES(11,  DATE '2024-04-01',  95);

  INSERT INTO STATUS_EVT VALUES(1,  DATE '2024-01-01','ACTIVE');
  INSERT INTO STATUS_EVT VALUES(1,  DATE '2024-03-01','SUSPEND');
  INSERT INTO STATUS_EVT VALUES(1,  DATE '2024-04-01','ACTIVE');
  INSERT INTO STATUS_EVT VALUES(2,  DATE '2024-02-01','ACTIVE');
  INSERT INTO STATUS_EVT VALUES(2,  DATE '2024-05-01','LEAVE');

  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OI'  , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PRICE_EVT', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'STATUS_EVT',cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

## 2. 왜 “고급 조인 테크닉”이 필요한가?

옵티마이저의 조인 비용은 크게 다음에 달려 있다.

1) **입력 행수(E-Rows)**
2) **조인 키 분포(중복/스큐)**
3) **드라이빙 방향**
4) **조인 방법(NL/HJ/SMJ)**
5) **조인 조건 형태(등치 vs 비등치/범위)**

특히 **대형 팩트 ↔ 대형 팩트**, **시간 이력(비등치)**, **결손 탐지(ANTI)**는  
“기본 조인만으로는 비용이 폭발”하는 영역이라, 구조적으로 입력을 줄이는 테크닉이 필요하다.

---

## 3. 징검다리(Bridge / Stepping-Stone) 테이블 조인

### 3.1 개념
**대형 ↔ 대형 직접 조인을 피하고**,  
중간에 **작고, 선택도가 좋고, 키만 가진 브리지 집합을 먼저 만든 뒤** 최종 조인한다.

**핵심 효과**
- **입력 행수 급감**
- 드라이빙 집합이 작아져 **NL+인덱스 경로가 급격히 싸짐**
- 해시/정렬 필요량(빌드 입력) 감소 → **PGA/TEMP 절약**

### 3.2 구조 그림(개념)

```
[ Big Fact A ] ----direct join---- [ Big Fact B ]  (비싸고 흔들림)
         |
         |  조건별로 먼저 줄여 "Key-only"로
         v
     [ Bridge Key Set ] ----small join----> [ Big Fact B ]
```

### 3.3 브리지 설계 원칙 6가지
1) **키만 남겨 폭을 최소화**
2) 가능한 **단일 컬럼 키 집합**으로 만들 것  
3) **선택도가 높은 조건을 최우선으로 브리지에 반영**
4) 재사용되면 `MATERIALIZE`(또는 GTT)로 고정
5) 브리지 집합은 **중복 제거(DISTINCT)** 를 고려  
   - 단, Distinct 자체 비용이 크면 선행 필터가 충분히 작은지 확인
6) 브리지 생성 단계에서 **조기 프루닝(파티션/인덱스)** 이 되게 설계

---

## 4. 브리지 패턴 A — “조건 요약 브리지”로 4-way 대형 조인 축소

### 4.1 요구
“2024-03에 KOR·VIP 고객이 구매한 ELEC 카테고리 상품 매출 합계”

### 4.2 브리지 없이 (직접 4-way)

```sql
SELECT SUM(i.amount) AS total_amt
FROM   ORD  o
JOIN   OI   i ON i.order_id = o.order_id
JOIN   CUST c ON c.cust_id  = o.cust_id
JOIN   PROD p ON p.prod_id  = i.prod_id
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
AND    c.region = 'KOR'
AND    c.segment = 'VIP'
AND    p.category = 'ELEC';
```

**문제 지점**
- 필터가 서로 다른 테이블에 흩어져 있어  
  초기 단계에서 입력 축소가 잘 안 되면  
  `ORD×OI` 또는 `OI×PROD`에서 **대형 빌드/스캔**이 발생.

### 4.3 브리지 도입

```sql
WITH C_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ c.cust_id
  FROM   CUST c
  WHERE  c.region = 'KOR'
  AND    c.segment = 'VIP'
),
P_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ p.prod_id
  FROM   PROD p
  WHERE  p.category = 'ELEC'
),
O_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ o.order_id
  FROM   ORD o
  JOIN   C_BRIDGE cb ON cb.cust_id = o.cust_id
  WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
)
SELECT /*+ ORDERED LEADING(o_b i p_b) USE_NL(i) USE_NL(p_b) */
       SUM(i.amount) AS total_amt
FROM   O_BRIDGE o_b
JOIN   OI      i   ON i.order_id = o_b.order_id
JOIN   P_BRIDGE p_b ON p_b.prod_id = i.prod_id;
```

### 4.4 왜 이게 빨라지나? (비용 관점)
- `C_BRIDGE` 크기: 고객의 일부(선택도 높음)  
- `P_BRIDGE` 크기: 카테고리 일부  
- `O_BRIDGE` 크기: **기간 + 고객 필터**가 합쳐져 매우 작아짐  
- 최종 단계에서 `OI`를 NL로 타도  
  *inner 반복 횟수 자체가 작음* → 랜덤 I/O가 줄어 cost가 급락.

### 4.5 변형 1 — 브리지를 **세션 GTT**로 고정
브리지가 여러 SQL에서 재사용될 때 유리.

```sql
CREATE GLOBAL TEMPORARY TABLE C_BRIDGE_GTT(
  CUST_ID NUMBER PRIMARY KEY
) ON COMMIT DELETE ROWS;

INSERT /*+ APPEND */ INTO C_BRIDGE_GTT
SELECT cust_id FROM cust
WHERE region='KOR' AND segment='VIP';

COMMIT;

SELECT /*+ ORDERED LEADING(o c_gtt i p) USE_NL(o) USE_NL(i) */
       SUM(i.amount)
FROM   C_BRIDGE_GTT c_gtt
JOIN   ORD o ON o.cust_id=c_gtt.cust_id
JOIN   OI  i ON i.order_id=o.order_id
JOIN   PROD p ON p.prod_id=i.prod_id
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
AND    p.category='ELEC';
```

- GTT는 통계가 없으면 DS가 붙을 수 있으니  
  **세션에서 수동 통계** 또는 **고정 힌트**를 병행한다.

### 4.6 변형 2 — 브리지 생성에서 `DISTINCT`로 중복 제거

```sql
WITH O_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ DISTINCT o.order_id
  FROM   ORD o
  JOIN   CUST c ON c.cust_id=o.cust_id
  WHERE  c.region='KOR' AND c.segment='VIP'
  AND    o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
)
SELECT SUM(i.amount)
FROM   O_BRIDGE o_b
JOIN   OI i ON i.order_id=o_b.order_id;
```

- `ORDER_ID`가 중복될 가능성이 있는 경로(복수 조인 경유)라면 Distinct가 안정적.  
- 단, Distinct 비용이 크면 **브리지의 입력을 더 줄이는 것이 먼저**.

---

## 5. 브리지 패턴 B — “기간/버전 브리지”로 선분조인 후보 축소

### 5.1 선분조인의 본질적 어려움
선분(Interval) 조인은 보통

```sql
T.point_dt >= S.start_dt AND T.point_dt < S.end_dt
```

같은 **비등치 조건**이라,
- 인덱스가 있어도 “범위 매칭” 비용이 커지고
- 해시/정렬 조인이 섞이면 TEMP/PGA가 커진다.

### 5.2 구간화(PRICE_EVT → PRICE_SEG)

```sql
WITH PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31')
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVT
)
SELECT * FROM PRICE_SEG ORDER BY prod_id, start_dt;
```

### 5.3 후보 선분 브리지(CAND_SEG) 도입

```sql
WITH PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVT
),
CAND_SEG AS (
  SELECT /*+ MATERIALIZE */
         DISTINCT s.prod_id, p.start_dt, p.end_dt, p.new_price
  FROM   OI s
  JOIN   ORD o ON o.order_id = s.order_id
  JOIN   PRICE_SEG p
         ON p.prod_id = s.prod_id
        AND o.order_dt >= p.start_dt
        AND o.order_dt <  p.end_dt
  WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
)
SELECT /*+ ORDERED USE_NL(i) */
       o.order_id, i.line_no, i.prod_id, i.qty, c.new_price,
       i.qty * c.new_price AS revenue
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
JOIN   CAND_SEG c
       ON c.prod_id = i.prod_id
      AND o.order_dt >= c.start_dt
      AND o.order_dt <  c.end_dt
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
```

### 5.4 이중 조건을 “왜 한 번 더 쓰는가?”
- 1차 조인으로 **후보 구간만 뽑고**  
- 2차 조인에서 **실매칭을 수행**한다.

후보가 충분히 작아지면,  
2차 비등치 조인의 비용은 **거의 무시될 정도로 떨어진다.**

---

## 6. 점이력(Point-in-Time) 조회

### 6.1 문제 유형
“시점 T에서 유효한 상태/값”을 찾아 붙이기

- 고객 상태(활성/정지/탈퇴)  
- 계정 등급, 담당자, 룰 버전, 계약 상태  
- “당시”를 찾아야 해서 보통 **EVT_DT ≤ T 중 가장 최신 1건**이다.

### 6.2 가장 기본 패턴: LATERAL(APPLY) + Stopkey

```sql
SELECT o.order_id, o.cust_id, o.order_dt, v.status_at
FROM   ORD o
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(se IX_ST_EVT) */
         se.status AS status_at
  FROM   STATUS_EVT se
  WHERE  se.cust_id = o.cust_id
  AND    se.evt_dt <= o.order_dt
  FETCH FIRST 1 ROWS ONLY
) v
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-10';
```

**성능 근거**
- `IX_ST_EVT(cust_id, evt_dt)` 인덱스를  
  **역순 스캔 + Stopkey**로  
  최신 1건만 빠르게 찾는다.

### 6.3 변형 1 — ROW_NUMBER() 기반 Top-1 per key
APPLY를 못 쓰는 환경/스타일일 때.

```sql
WITH O AS (
  SELECT order_id, cust_id, order_dt
  FROM   ORD
  WHERE  order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-10'
),
S AS (
  SELECT o.order_id, o.cust_id, o.order_dt,
         se.status,
         ROW_NUMBER() OVER(
           PARTITION BY o.order_id
           ORDER BY se.evt_dt DESC
         ) rn
  FROM   O o
  JOIN   STATUS_EVT se
         ON se.cust_id=o.cust_id
        AND se.evt_dt<=o.order_dt
)
SELECT order_id, cust_id, order_dt, status AS status_at
FROM   S
WHERE  rn=1;
```

**주의**
- `O×STATUS_EVT` 조인이 커질 수 있다.  
- 입력이 크면 APPLY가 더 안정적일 수 있음.

### 6.4 변형 2 — 분석함수 `KEEP (DENSE_RANK LAST)`
Oracle에서 자주 쓰는 간결 패턴.

```sql
SELECT o.order_id,
       MAX(se.status) KEEP (DENSE_RANK LAST ORDER BY se.evt_dt) AS status_at
FROM   ORD o
JOIN   STATUS_EVT se
       ON se.cust_id=o.cust_id
      AND se.evt_dt<=o.order_dt
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-10'
GROUP  BY o.order_id;
```

- 그룹당 최신값 1건만 남기므로 결과 폭이 작아짐.

---

## 7. 선분이력(Interval/Temporal) 조인

### 7.1 선분의 의미
각 이벤트는 “시작”만 기록되고,  
**다음 이벤트 직전까지 유효**한 구간이 된다.

즉,

- 시작: `EVT_DT`  
- 끝: `LEAD(EVT_DT)` (없으면 무한대)

### 7.2 기본 구간화 + 매칭

```sql
WITH PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVT
)
SELECT o.order_id, i.line_no, i.prod_id, i.qty,
       p.new_price, i.qty*p.new_price AS revenue
FROM   ORD o
JOIN   OI  i ON i.order_id=o.order_id
JOIN   PRICE_SEG p
       ON p.prod_id=i.prod_id
      AND o.order_dt>=p.start_dt
      AND o.order_dt<p.end_dt
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
```

### 7.3 경계 포함 규칙(매우 중요)
- 일반적으로 **[start, end)** 반개구간을 쓴다.

즉,

```sql
point_dt >= start_dt AND point_dt < end_dt
```

**이유**
- 이벤트가 바로 붙어 있을 때  
  **중복 매칭/누락 방지**가 가장 단순하다.

---

## 8. 선분조인 튜닝 핵심

### 8.1 인덱스
- 선분 테이블:
  - `(prod_id, evt_dt)` 또는 `(prod_id, start_dt)`  
  - end_dt는 파생값이라 인덱스에 굳이 포함하지 않아도 됨
- 포인트 테이블:
  - `(order_dt)` 기반 파티션/인덱스 프루닝

### 8.2 조인 순서
- 보통 **포인트(ORD/OI) → 선분(PRICE_SEG)** 드라이빙이 유리  
- 이유: 포인트는 기간 필터로 입력 축소가 먼저 가능

### 8.3 조인 방법
- 소량 포인트 → **NL + 인덱스**  
- 대량 포인트/배치 →  
  1) 후보 선분을 브리지로 줄인 뒤  
  2) **HASH**로 얹는 전략이 안정적

### 8.4 Temp/PGA 관리
- `+MEMSTATS`에서
  - `PGA_used_mem`, `PGA_alloc_mem`  
  - `TempSpc`  
  를 보라.
- 스필이 보이면
  - 브리지로 빌드 입력을 더 줄이거나  
  - 선행 집계/중복 제거로 입력 폭을 줄여라.

---

## 9. “조인에 실패한 레코드” 읽기(미매칭 탐지)

### 9.1 ANTI-JOIN (왼쪽은 있는데 오른쪽에 없음)

#### 패턴 1: NOT EXISTS (권장)

```sql
SELECT DISTINCT i.prod_id
FROM   OI i
WHERE  NOT EXISTS (
  SELECT 1 FROM PROD p WHERE p.prod_id=i.prod_id
);
```

#### 패턴 2: LEFT OUTER + NULL 필터

```sql
SELECT DISTINCT i.prod_id
FROM   OI i
LEFT   JOIN PROD p ON p.prod_id=i.prod_id
WHERE  p.prod_id IS NULL;
```

### 9.2 RIGHT-ANTI (오른쪽만 존재)

```sql
SELECT p.prod_id
FROM   PROD p
WHERE  NOT EXISTS (
  SELECT 1 FROM OI i WHERE i.prod_id=p.prod_id
);
```

### 9.3 선분 미매칭(어떤 구간에도 안 들어감)

```sql
WITH PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt
  FROM   PRICE_EVT
)
SELECT DISTINCT i.prod_id
FROM   OI i
JOIN   ORD o ON o.order_id=i.order_id
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
AND    NOT EXISTS (
  SELECT 1
  FROM   PRICE_SEG p
  WHERE  p.prod_id=i.prod_id
  AND    o.order_dt>=p.start_dt
  AND    o.order_dt<p.end_dt
);
```

### 9.4 FULL OUTER로 양쪽 결손 한 번에

```sql
SELECT COALESCE(l.key, r.key) AS key,
       CASE WHEN l.key IS NULL THEN 'RIGHT_ONLY'
            WHEN r.key IS NULL THEN 'LEFT_ONLY'
            ELSE 'BOTH' END AS where_is
FROM (SELECT DISTINCT prod_id AS key FROM OI)   l
FULL OUTER JOIN
     (SELECT DISTINCT prod_id AS key FROM PROD) r
  ON r.key=l.key
WHERE l.key IS NULL OR r.key IS NULL;
```

---

## 10. 종합 실전 시나리오(브리지 + 점이력 + 선분 + 미매칭)

> 3월 KOR·VIP 고객의 주문에  
> (1) 주문 키를 브리지로 축소 후  
> (2) 주문일 고객 상태(점이력)  
> (3) 주문일 적용 가격(선분이력)  
> 을 붙이고  
> (4) 가격 미정 구간을 검출한다.

```sql
WITH
C_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ cust_id
  FROM   CUST
  WHERE  region='KOR' AND segment='VIP'
),
O_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ o.order_id, o.cust_id, o.order_dt
  FROM   ORD o
  JOIN   C_BRIDGE c ON c.cust_id=o.cust_id
  WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
),
PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVT
),
P_CAND AS (
  SELECT /*+ MATERIALIZE */ DISTINCT p.prod_id, p.start_dt, p.end_dt, p.new_price
  FROM   OI i
  JOIN   O_BRIDGE o ON o.order_id=i.order_id
  JOIN   PRICE_SEG p
         ON p.prod_id=i.prod_id
        AND o.order_dt>=p.start_dt
        AND o.order_dt<p.end_dt
),
S_AT AS (
  SELECT o.order_id,
         (SELECT se.status
          FROM   STATUS_EVT se
          WHERE  se.cust_id=o.cust_id
          AND    se.evt_dt<=o.order_dt
          ORDER  BY se.evt_dt DESC
          FETCH FIRST 1 ROWS ONLY) AS status_at
  FROM   O_BRIDGE o
)
SELECT /*+ ORDERED LEADING(o_b i p_c s_at) USE_NL(i) USE_NL(p_c) */
       o_b.order_id, i.line_no, i.prod_id,
       i.qty, p_c.new_price, i.qty*p_c.new_price AS revenue,
       s_at.status_at
FROM   O_BRIDGE o_b
JOIN   OI      i   ON i.order_id=o_b.order_id
JOIN   P_CAND  p_c ON p_c.prod_id=i.prod_id
                  AND o_b.order_dt>=p_c.start_dt
                  AND o_b.order_dt<p_c.end_dt
LEFT   JOIN S_AT s_at ON s_at.order_id=o_b.order_id;
```

### 10.1 가격 미매칭 검출

```sql
SELECT DISTINCT i.prod_id
FROM   OI i
JOIN   O_BRIDGE o ON o.order_id=i.order_id
LEFT   JOIN P_CAND p ON p.prod_id=i.prod_id
                    AND o.order_dt>=p.start_dt
                    AND o.order_dt<p.end_dt
WHERE  p.prod_id IS NULL;
```

---

## 11. 브리지/점/선분 조인의 실패 케이스와 대응

### 11.1 브리지가 오히려 느린 경우
- 브리지 조건의 선택도가 낮아 **집합이 거의 줄지 않을 때**
- `MATERIALIZE`가 과도한 TEMP를 유발할 때
- 브리지 생성 단계에서 이미 대형 해시/정렬이 발생할 때

**대응**
- 브리지 조건을 더 조밀하게(범위/상관 조건 추가)
- 브리지 단계를 2번으로 쪼갬(먼저 가장 강한 필터)
- Distinct/Group By를 “브리지에서가 아니라 더 아래에서” 수행

### 11.2 점이력에서 성능이 안 나오는 경우
- (key, evt_dt) 인덱스가 없거나 CF가 나쁜 경우
- 포인트 입력이 매우 큰데 APPLY를 무조건 NL로 타는 경우

**대응**
- 인덱스 필수: `STATUS_EVT(cust_id, evt_dt)`
- 대량 배치라면  
  - 포인트를 기간·키로 어느 정도 줄인 뒤  
  - ROW_NUMBER/KEEP 패턴으로 **세트 기반 처리** 전환

### 11.3 선분조인에서 중복/누락이 생기는 경우
- 경계 포함 규칙이 혼재됨  
- start/end 생성 로직이 잘못됨(동일 EVT_DT, 역전, Null)

**대응**
- 반개구간([start,end)) 규칙을 명문화
- 입력에서 `EVT_DT` 유일성/정렬성 보장
- 동일일 다중 이벤트는 **업무 규칙으로 우선순위 정리**

---

## 12. 운영 체크리스트(요약)

- [ ] 브리지:
  - 조건별 **키-only** 집합  
  - **선택도 높은 조건 먼저**  
  - 재사용 시 `MATERIALIZE`/GTT  
- [ ] 점이력:
  - APPLY/Top-1 per key  
  - 역순 인덱스 + Stopkey  
- [ ] 선분이력:
  - `LEAD`로 구간화  
  - **[start,end)** 규칙 통일  
  - 후보 브리지로 비등치 입력 축소  
- [ ] 미매칭:
  - `NOT EXISTS` 우선  
  - 선분 미매칭은 `NOT EXISTS`로 구간 커버 검사  
- [ ] 실측:
  - `E/A Rows`, `Buffers`, `TempSpc`, `PGA` 확인  
  - 오판 지점부터 통계/구조/힌트로 교정

---

## 13. 결론

고급 조인 테크닉의 본질은 단순하다.

1) **대형 입력을 구조적으로 줄이고(브리지)**  
2) **시간 이력은 Top-1/구간화로 정형화하고(점/선분)**  
3) **미매칭을 명시적으로 드러내며(ANTI/FULL OUTER)**  
4) **실측으로 확인해 사실 기반으로 고친다.**

- 브리지는 “대형 조인을 작은 키 집합 조인으로 변환”하는 기술이고,  
- 점이력은 “시점 T에서 최신 1건 매칭”의 정석이며,  
- 선분이력은 “구간화 + 반개구간 룰 + 후보 축소”가 튜닝의 핵심이다.  

이 세 가지를 체계적으로 쓰면  
팩트-팩트, 시간 이력, 데이터 품질 검증까지  
조인 성능/안정성을 동시에 잡을 수 있다.