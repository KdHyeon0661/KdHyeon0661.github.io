---
layout: post
title: DB 심화 - 고급 조인 테크닉 (2)
date: 2025-11-15 15:25:23 +0900
category: DB 심화
---
# Oracle 고급 조인 테크닉 2 — 징검다리 조인, 점/선분 이력 조인, 미매칭 탐지, 실전 튜닝 패턴

## 실측 플랜 확인 루틴(필수)

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL,NULL,
         'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS +ALIAS +NOTE'
));
```

### 분석 포인트

- **E-Rows vs A-Rows**: 카디널리티 추정 오류 지점 파악
- **Buffers / Reads / Writes**: 논리/물리 I/O 규모 분석
- **TempSpc / PGA**: 정렬·해시 스필 발생 여부 확인
- **Join Method / Order**: NL/HJ/SMJ 방식과 드라이빙 방향 검토
- **Predicate 위치**: access vs filter 조건, 푸시다운/추론 성공 여부 분석

---

## 공통 실습 스키마/데이터/통계

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

DROP TABLE CUST        PURGE;
DROP TABLE ORD         PURGE;
DROP TABLE OI          PURGE;
DROP TABLE PROD        PURGE;
DROP TABLE PRICE_EVT   PURGE;
DROP TABLE STATUS_EVT  PURGE;

CREATE TABLE CUST(
  CUST_ID   NUMBER       PRIMARY KEY,
  REGION    VARCHAR2(8)  NOT NULL,
  SEGMENT   VARCHAR2(8)  NOT NULL
);

CREATE TABLE ORD(
  ORDER_ID  NUMBER       PRIMARY KEY,
  CUST_ID   NUMBER       NOT NULL,
  ORDER_DT  DATE         NOT NULL,
  STATUS    VARCHAR2(8)  NOT NULL
);

CREATE TABLE OI(
  ORDER_ID  NUMBER       NOT NULL,
  LINE_NO   NUMBER       NOT NULL,
  PROD_ID   NUMBER       NOT NULL,
  QTY       NUMBER       NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY (ORDER_ID, LINE_NO)
);

CREATE TABLE PROD(
  PROD_ID   NUMBER       PRIMARY KEY,
  CATEGORY  VARCHAR2(12) NOT NULL
);

CREATE TABLE PRICE_EVT(
  PROD_ID   NUMBER NOT NULL,
  EVT_DT    DATE   NOT NULL,
  NEW_PRICE NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_PRICE_EVT PRIMARY KEY (PROD_ID, EVT_DT)
);

CREATE TABLE STATUS_EVT(
  CUST_ID   NUMBER NOT NULL,
  EVT_DT    DATE   NOT NULL,
  STATUS    VARCHAR2(10) NOT NULL,
  CONSTRAINT PK_STATUS_EVT PRIMARY KEY (CUST_ID, EVT_DT)
);

CREATE INDEX IX_ORD_CUST   ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_OI_PROD    ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER   ON OI(ORDER_ID);
CREATE INDEX IX_PE_EVT     ON PRICE_EVT(PROD_ID, EVT_DT);
CREATE INDEX IX_ST_EVT     ON STATUS_EVT(CUST_ID, EVT_DT);

BEGIN
  -- 고객 데이터 생성
  FOR c IN 1..10000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,5)
        WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA'
        WHEN 2 THEN 'AMER' WHEN 3 THEN 'KOR' ELSE 'JPN' END,
      CASE MOD(c,4)
        WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  -- 상품 데이터 생성
  FOR p IN 1..3000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5)
        WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FASH'
        WHEN 2 THEN 'FOOD' WHEN 3 THEN 'HOME' ELSE 'TOY' END
    );
  END LOOP;

  -- 주문 데이터 생성
  FOR o IN 1..60000 LOOP
    INSERT INTO ORD VALUES(
      o, MOD(o,10000)+1,
      DATE '2024-01-01' + MOD(o,365),
      CASE MOD(o,4)
        WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID'
        WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  -- 주문 상세 데이터 생성
  FOR i IN 1..180000 LOOP
    INSERT INTO OI VALUES(
      MOD(i,60000)+1,
      1 + MOD(i,3),
      MOD(i,3000)+1,
      1 + MOD(i,5),
      ROUND(DBMS_RANDOM.VALUE(10,800),2)
    );
  END LOOP;

  -- 가격 이력 데이터 생성
  INSERT INTO PRICE_EVT VALUES(10,  DATE '2024-01-01', 100);
  INSERT INTO PRICE_EVT VALUES(10,  DATE '2024-02-01', 120);
  INSERT INTO PRICE_EVT VALUES(10,  DATE '2024-03-10', 130);
  INSERT INTO PRICE_EVT VALUES(11,  DATE '2024-01-20',  80);
  INSERT INTO PRICE_EVT VALUES(11,  DATE '2024-04-01',  95);

  -- 상태 이력 데이터 생성
  INSERT INTO STATUS_EVT VALUES(1,  DATE '2024-01-01','ACTIVE');
  INSERT INTO STATUS_EVT VALUES(1,  DATE '2024-03-01','SUSPEND');
  INSERT INTO STATUS_EVT VALUES(1,  DATE '2024-04-01','ACTIVE');
  INSERT INTO STATUS_EVT VALUES(2,  DATE '2024-02-01','ACTIVE');
  INSERT INTO STATUS_EVT VALUES(2,  DATE '2024-05-01','LEAVE');

  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OI'  , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PRICE_EVT', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'STATUS_EVT',cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

## "고급 조인 테크닉"의 필요성

옵티마이저의 조인 비용 결정은 다음과 같은 요소에 크게 의존합니다:

1. **입력 행 수(E-Rows)**
2. **조인 키 분포(중복/스큐)**
3. **드라이빙 방향**
4. **조인 방법(NL/HJ/SMJ)**
5. **조인 조건 형태(등치 vs 비등치/범위)**

특히 **대형 팩트 ↔ 대형 팩트 조인**, **시간 이력 조인(비등치)**, **결손 데이터 탐지(ANTI JOIN)**와 같은 복잡한 조인 시나리오에서는 기본 조인 방식만으로는 비용이 폭발적으로 증가할 수 있습니다. 이러한 상황에서 구조적으로 입력을 줄이는 고급 조인 테크닉이 필요합니다.

---

## 징검다리(Bridge) 테이블 조인

### 개념과 원리

징검다리 조인은 **대형 테이블 간의 직접적인 조인을 피하기 위해** 중간에 작고 선택도가 높은 브리지 집합을 생성하여 조인 경로를 최적화하는 기법입니다. 이 브리지 집합은 주로 키 컬럼만 포함하여 최소한의 데이터를 유지합니다.

**핵심 효과**
- **입력 행 수 급격히 감소**
- 작은 드라이빙 집합으로 인해 **NL+인덱스 조인 경로가 효율적**이 됨
- 해시/정렬 작업 필요량 감소 → **PGA/TEMP 자원 절약**

### 구조적 이해

```
[ 대형 팩트 테이블 A ] ---- 직접 조인 ---- [ 대형 팩트 테이블 B ]
         (비용이 높고 실행계획 변동성 큼)
              |
              |  조건별로 먼저 축소하여 "키만 포함"된 집합 생성
              v
      [ 브리지 키 집합 ] ---- 효율적 조인 ----> [ 대형 팩트 테이블 B ]
```

### 브리지 설계 원칙

1. **키 컬럼만 유지하여 데이터 폭 최소화**
2. 가능한 **단일 컬럼 키 집합**으로 구성
3. **선택도가 가장 높은 조건을 우선적으로 브리지에 반영**
4. 재사용이 필요한 경우 `MATERIALIZE` 힌트나 GTT 활용
5. 브리지 집합에서 **중복 제거(DISTINCT)** 고려
   - 단, DISTINCT 비용이 높으면 선행 필터링으로 입력 크기 축소 확인
6. 브리지 생성 단계에서 **조기 프루닝(파티션/인덱스)** 가능하도록 설계

---

## 브리지 패턴 A — "조건 요약 브리지"로 4-way 대형 조인 최적화

### 요구사항 분석
"2024년 3월 동안 KOR 지역 VIP 고객이 구매한 ELEC 카테고리 상품의 매출 합계 조회"

### 브리지 없이 직접 4-way 조인 시도

```sql
SELECT SUM(i.amount) AS total_amt
FROM   ORD  o
JOIN   OI   i ON i.order_id = o.order_id
JOIN   CUST c ON c.cust_id  = o.cust_id
JOIN   PROD p ON p.prod_id  = i.prod_id
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
AND    c.region = 'KOR'
AND    c.segment = 'VIP'
AND    p.category = 'ELEC';
```

**문제점 분석**
- 필터 조건이 여러 테이블에 분산되어 있어 초기 단계에서 입력 축소가 어려움
- `ORD×OI` 또는 `OI×PROD` 조인에서 대형 빌드/스캔 발생 가능성 높음
- 실행계획 변동성으로 인한 성능 불안정성 위험

### 브리지 도입을 통한 최적화

```sql
WITH C_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ c.cust_id
  FROM   CUST c
  WHERE  c.region = 'KOR'
  AND    c.segment = 'VIP'
),
P_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ p.prod_id
  FROM   PROD p
  WHERE  p.category = 'ELEC'
),
O_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ o.order_id
  FROM   ORD o
  JOIN   C_BRIDGE cb ON cb.cust_id = o.cust_id
  WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
)
SELECT /*+ ORDERED LEADING(o_b i p_b) USE_NL(i) USE_NL(p_b) */
       SUM(i.amount) AS total_amt
FROM   O_BRIDGE o_b
JOIN   OI      i   ON i.order_id = o_b.order_id
JOIN   P_BRIDGE p_b ON p_b.prod_id = i.prod_id;
```

### 성능 개선 원리 분석

- **C_BRIDGE 크기**: 특정 지역과 세그먼트에 해당하는 고객만 포함(선택도 높음)
- **P_BRIDGE 크기**: 특정 카테고리 상품만 포함
- **O_BRIDGE 크기**: 기간 조건과 고객 필터가 결합되어 크기 급감
- **최종 조인**: OI 테이블을 NL 조인으로 접근하지만, 내부 반복 횟수가 적어 랜덤 I/O 비용 감소

### 변형 패턴 1 — 세션 GTT 활용

여러 SQL에서 브리지를 재사용해야 할 경우 GTT가 유리합니다.

```sql
CREATE GLOBAL TEMPORARY TABLE C_BRIDGE_GTT(
  CUST_ID NUMBER PRIMARY KEY
) ON COMMIT DELETE ROWS;

INSERT /*+ APPEND */ INTO C_BRIDGE_GTT
SELECT cust_id FROM cust
WHERE region='KOR' AND segment='VIP';

COMMIT;

SELECT /*+ ORDERED LEADING(o c_gtt i p) USE_NL(o) USE_NL(i) */
       SUM(i.amount)
FROM   C_BRIDGE_GTT c_gtt
JOIN   ORD o ON o.cust_id=c_gtt.cust_id
JOIN   OI  i ON i.order_id=o.order_id
JOIN   PROD p ON p.prod_id=i.prod_id
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
AND    p.category='ELEC';
```

**주의사항**: GTT는 통계 정보가 없을 수 있으므로, 세션에서 수동 통계 수집이나 고정 힌트 사용을 고려해야 합니다.

### 변형 패턴 2 — DISTINCT를 활용한 중복 제거

```sql
WITH O_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ DISTINCT o.order_id
  FROM   ORD o
  JOIN   CUST c ON c.cust_id=o.cust_id
  WHERE  c.region='KOR' AND c.segment='VIP'
  AND    o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
)
SELECT SUM(i.amount)
FROM   O_BRIDGE o_b
JOIN   OI i ON i.order_id=o_b.order_id;
```

- `ORDER_ID`가 중복될 가능성이 있는 경로에서 DISTINCT 사용이 안정적입니다.
- 단, DISTINCT 자체의 비용이 크면 브리지 입력을 더 줄이는 전략이 우선입니다.

---

## 브리지 패턴 B — "기간/버전 브리지"로 선분조인 후보 축소

### 선분조인의 근본적 어려움

선분(Interval) 조인은 일반적으로 다음과 같은 비등치 조건을 사용합니다:

```sql
T.point_dt >= S.start_dt AND T.point_dt < S.end_dt
```

이러한 **비등치 조건**은 다음과 같은 문제를 야기합니다:
- 인덱스가 존재해도 "범위 매칭" 비용이 증가
- 해시/정렬 조인과 결합 시 TEMP/PGA 사용량 급증

### 구간화 전환(PRICE_EVT → PRICE_SEG)

```sql
WITH PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31')
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVT
)
SELECT * FROM PRICE_SEG ORDER BY prod_id, start_dt;
```

### 후보 선분 브리지 도입

```sql
WITH PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVT
),
CAND_SEG AS (
  SELECT /*+ MATERIALIZE */
         DISTINCT s.prod_id, p.start_dt, p.end_dt, p.new_price
  FROM   OI s
  JOIN   ORD o ON o.order_id = s.order_id
  JOIN   PRICE_SEG p
         ON p.prod_id = s.prod_id
        AND o.order_dt >= p.start_dt
        AND o.order_dt <  p.end_dt
  WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
)
SELECT /*+ ORDERED USE_NL(i) */
       o.order_id, i.line_no, i.prod_id, i.qty, c.new_price,
       i.qty * c.new_price AS revenue
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
JOIN   CAND_SEG c
       ON c.prod_id = i.prod_id
      AND o.order_dt >= c.start_dt
      AND o.order_dt <  c.end_dt
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
```

### 이중 조건 사용의 전략적 이유

- **1차 조인**: 실제 매칭 가능한 후보 구간만 추출
- **2차 조인**: 축소된 후보 집합을 기반으로 최종 매칭 수행

후보 집합이 충분히 축소되면, 2차 비등치 조인의 비용은 무시할 수 있을 정도로 감소합니다.

---

## 점이력(Point-in-Time) 조회

### 문제 정의
"시점 T에서 유효한 상태 또는 값"을 찾아 연결하는 작업입니다. 주로 다음 상황에 적용됩니다:
- 고객 상태(활성/정지/탈퇴) 조회
- 계정 등급, 담당자, 룰 버전, 계약 상태 확인
- 특정 시점의 "최신 유효한" 레코드 찾기

### 기본 패턴: LATERAL(APPLY) + Stopkey

```sql
SELECT o.order_id, o.cust_id, o.order_dt, v.status_at
FROM   ORD o
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(se IX_ST_EVT) */
         se.status AS status_at
  FROM   STATUS_EVT se
  WHERE  se.cust_id = o.cust_id
  AND    se.evt_dt <= o.order_dt
  FETCH FIRST 1 ROWS ONLY
) v
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-10';
```

**성능 최적화 근거**
- `IX_ST_EVT(cust_id, evt_dt)` 인덱스를 **역순 스캔 + Stopkey**로 활용
- 최신 1건만 빠르게 찾아 성능 극대화

### 변형 패턴 1 — ROW_NUMBER() 기반 Top-1 per key

APPLY를 사용할 수 없는 환경이나 스타일 선호도에 따른 대안입니다.

```sql
WITH O AS (
  SELECT order_id, cust_id, order_dt
  FROM   ORD
  WHERE  order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-10'
),
S AS (
  SELECT o.order_id, o.cust_id, o.order_dt,
         se.status,
         ROW_NUMBER() OVER(
           PARTITION BY o.order_id
           ORDER BY se.evt_dt DESC
         ) rn
  FROM   O o
  JOIN   STATUS_EVT se
         ON se.cust_id=o.cust_id
        AND se.evt_dt<=o.order_dt
)
SELECT order_id, cust_id, order_dt, status AS status_at
FROM   S
WHERE  rn=1;
```

**주의사항**: `O×STATUS_EVT` 조인의 크기가 커질 수 있으므로, 대량 데이터 처리 시 APPLY 방식이 더 안정적일 수 있습니다.

### 변형 패턴 2 — 분석함수 `KEEP (DENSE_RANK LAST)`

Oracle에서 자주 사용되는 간결한 패턴입니다.

```sql
SELECT o.order_id,
       MAX(se.status) KEEP (DENSE_RANK LAST ORDER BY se.evt_dt) AS status_at
FROM   ORD o
JOIN   STATUS_EVT se
       ON se.cust_id=o.cust_id
      AND se.evt_dt<=o.order_dt
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-10'
GROUP  BY o.order_id;
```

- 그룹별 최신값 1건만 유지하므로 결과 집합 크기가 감소합니다.

---

## 선분이력(Interval/Temporal) 조인

### 선분의 개념적 이해
각 이벤트는 "시작 시점"만 기록되며, **다음 이벤트 발생 직전까지 유효한 구간**을 형성합니다. 즉:
- 시작: `EVT_DT`
- 끝: `LEAD(EVT_DT)` (다음 이벤트가 없으면 무한대 날짜로 설정)

### 기본 구간화 및 매칭 패턴

```sql
WITH PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVT
)
SELECT o.order_id, i.line_no, i.prod_id, i.qty,
       p.new_price, i.qty*p.new_price AS revenue
FROM   ORD o
JOIN   OI  i ON i.order_id=o.order_id
JOIN   PRICE_SEG p
       ON p.prod_id=i.prod_id
      AND o.order_dt>=p.start_dt
      AND o.order_dt<p.end_dt
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
```

### 경계 포함 규칙의 중요성

일반적으로 **[start, end)** 반개구간 방식을 사용합니다:

```sql
point_dt >= start_dt AND point_dt < end_dt
```

**이유**
- 이벤트가 연속적으로 발생하는 경우 **중복 매칭 또는 누락 방지**가 용이합니다.
- 경계 처리의 일관성을 유지할 수 있습니다.

---

## 선분조인 튜닝 핵심 전략

### 인덱스 설계 가이드

- **선분 테이블 인덱스**:
  - `(prod_id, evt_dt)` 또는 `(prod_id, start_dt)`
  - end_dt는 파생 컬럼이므로 인덱스 포함 필수 아님
- **포인트 테이블 인덱스**:
  - `(order_dt)` 기반 파티셔닝 또는 인덱스 프루닝 활용

### 조인 순서 최적화

일반적으로 **포인트 테이블(ORD/OI) → 선분 테이블(PRICE_SEG)** 순서가 유리합니다:
- 이유: 포인트 테이블에서 기간 필터를 적용하여 입력을 먼저 축소 가능

### 조인 방법 선택 기준

- **소량 포인트 데이터**: **NL + 인덱스** 조인 적합
- **대량 포인트/배치 처리**:
  1. 후보 선분을 브리지로 축소한 후
  2. **해시 조인** 적용이 안정적

### TEMP/PGA 자원 관리

`+MEMSTATS` 옵션으로 다음 지표를 모니터링합니다:
- `PGA_used_mem`, `PGA_alloc_mem`
- `TempSpc`

스필 발생 시 대응 전략:
- 브리지를 활용하여 빌드 입력 크기 축소
- 선행 집계 또는 중복 제거로 입력 폭 감소

---

## "조인에 실패한 레코드" 탐지(미매칭 검출)

### ANTI-JOIN (왼쪽 테이블에만 존재하는 레코드)

#### 패턴 1: NOT EXISTS (권장 방식)

```sql
SELECT DISTINCT i.prod_id
FROM   OI i
WHERE  NOT EXISTS (
  SELECT 1 FROM PROD p WHERE p.prod_id=i.prod_id
);
```

#### 패턴 2: LEFT OUTER JOIN + NULL 필터

```sql
SELECT DISTINCT i.prod_id
FROM   OI i
LEFT   JOIN PROD p ON p.prod_id=i.prod_id
WHERE  p.prod_id IS NULL;
```

### RIGHT-ANTI JOIN (오른쪽 테이블에만 존재하는 레코드)

```sql
SELECT p.prod_id
FROM   PROD p
WHERE  NOT EXISTS (
  SELECT 1 FROM OI i WHERE i.prod_id=p.prod_id
);
```

### 선분 미매칭 검출 (어떤 구간에도 속하지 않는 레코드)

```sql
WITH PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt
  FROM   PRICE_EVT
)
SELECT DISTINCT i.prod_id
FROM   OI i
JOIN   ORD o ON o.order_id=i.order_id
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
AND    NOT EXISTS (
  SELECT 1
  FROM   PRICE_SEG p
  WHERE  p.prod_id=i.prod_id
  AND    o.order_dt>=p.start_dt
  AND    o.order_dt<p.end_dt
);
```

### FULL OUTER JOIN으로 양쪽 결손 동시 검출

```sql
SELECT COALESCE(l.key, r.key) AS key,
       CASE WHEN l.key IS NULL THEN 'RIGHT_ONLY'
            WHEN r.key IS NULL THEN 'LEFT_ONLY'
            ELSE 'BOTH' END AS where_is
FROM (SELECT DISTINCT prod_id AS key FROM OI)   l
FULL OUTER JOIN
     (SELECT DISTINCT prod_id AS key FROM PROD) r
  ON r.key=l.key
WHERE l.key IS NULL OR r.key IS NULL;
```

---

## 종합 실전 시나리오(브리지 + 점이력 + 선분 + 미매칭 통합)

### 요구사항
"3월 KOR 지역 VIP 고객의 주문에 대해:
1. 주문 키를 브리지로 축소
2. 주문일 기준 고객 상태(점이력) 추가
3. 주문일 적용 가격(선분이력) 추가
4. 가격 미정 구간 검출"

### 통합 솔루션

```sql
WITH
C_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ cust_id
  FROM   CUST
  WHERE  region='KOR' AND segment='VIP'
),
O_BRIDGE AS (
  SELECT /*+ MATERIALIZE */ o.order_id, o.cust_id, o.order_dt
  FROM   ORD o
  JOIN   C_BRIDGE c ON c.cust_id=o.cust_id
  WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
),
PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVT
),
P_CAND AS (
  SELECT /*+ MATERIALIZE */ DISTINCT p.prod_id, p.start_dt, p.end_dt, p.new_price
  FROM   OI i
  JOIN   O_BRIDGE o ON o.order_id=i.order_id
  JOIN   PRICE_SEG p
         ON p.prod_id=i.prod_id
        AND o.order_dt>=p.start_dt
        AND o.order_dt<p.end_dt
),
S_AT AS (
  SELECT o.order_id,
         (SELECT se.status
          FROM   STATUS_EVT se
          WHERE  se.cust_id=o.cust_id
          AND    se.evt_dt<=o.order_dt
          ORDER  BY se.evt_dt DESC
          FETCH FIRST 1 ROWS ONLY) AS status_at
  FROM   O_BRIDGE o
)
SELECT /*+ ORDERED LEADING(o_b i p_c s_at) USE_NL(i) USE_NL(p_c) */
       o_b.order_id, i.line_no, i.prod_id,
       i.qty, p_c.new_price, i.qty*p_c.new_price AS revenue,
       s_at.status_at
FROM   O_BRIDGE o_b
JOIN   OI      i   ON i.order_id=o_b.order_id
JOIN   P_CAND  p_c ON p_c.prod_id=i.prod_id
                  AND o_b.order_dt>=p_c.start_dt
                  AND o_b.order_dt<p_c.end_dt
LEFT   JOIN S_AT s_at ON s_at.order_id=o_b.order_id;
```

### 가격 미매칭 구간 검출

```sql
SELECT DISTINCT i.prod_id
FROM   OI i
JOIN   O_BRIDGE o ON o.order_id=i.order_id
LEFT   JOIN P_CAND p ON p.prod_id=i.prod_id
                    AND o.order_dt>=p.start_dt
                    AND o.order_dt<p.end_dt
WHERE  p.prod_id IS NULL;
```

---

## 브리지/점/선분 조인의 실패 케이스와 대응 전략

### 브리지 접근법이 오히려 느린 경우

- **원인**: 브리지 조건의 선택도가 낮아 집합 크기 감소 효과 미비
- **원인**: `MATERIALIZE`로 인한 과도한 TEMP 사용
- **원인**: 브리지 생성 단계에서 이미 대형 해시/정렬 발생

**대응 전략**
- 브리지 조건을 더 구체적으로 조정(범위/상관 조건 추가)
- 브리지 단계를 다단계로 분할(가장 강력한 필터 우선 적용)
- DISTINCT/Group By를 브리지가 아닌 후속 단계에서 수행

### 점이력 조회 성능 저하

- **원인**: (key, evt_dt) 인덱스 부재 또는 클러스터링 팩터 불량
- **원인**: 대량 포인트 입력에 APPLY를 무조건 NL 조인으로 처리

**대응 전략**
- 필수 인덱스 생성: `STATUS_EVT(cust_id, evt_dt)`
- 대량 배치 처리 시:
  - 포인트를 기간과 키로 선별적 축소 후
  - ROW_NUMBER/KEEP 패턴으로 **세트 기반 처리** 전환

### 선분조인에서 중복/누락 발생

- **원인**: 경계 포함 규칙의 불일치
- **원인**: start/end 생성 로직 오류(동일 EVT_DT, 시간 역전, NULL 값)

**대응 전략**
- 반개구간([start,end)) 규칙을 명확히 정의하고 일관되게 적용
- 입력 데이터의 `EVT_DT` 유일성과 정렬성 보장
- 동일일 다중 이벤트는 **업무 규칙으로 우선순위 결정**

---

## 운영 환경에서의 검증과 모니터링

### 성능 분석 체크리스트

- **브리지 전략 검토**:
  - 조건별 **키 전용** 집합 생성 여부 확인
  - **선택도 높은 조건 우선** 적용 여부 검토
  - 재사용성 고려 시 `MATERIALIZE`/GTT 활용 검증

- **점이력 조회 최적화**:
  - APPLY/Top-1 per key 패턴 적용
  - 역순 인덱스 + Stopkey 활용 검토

- **선분이력 처리**:
  - `LEAD` 함수를 활용한 구간화 구현
  - **[start,end)** 규칙 일관성 검증
  - 후보 브리지로 비등치 입력 축소 검토

- **미매칭 탐지**:
  - `NOT EXISTS` 패턴 우선 사용
  - 선분 미매칭은 `NOT EXISTS`로 구간 커버리지 검증

- **실측 데이터 분석**:
  - `E-Rows/A-Rows` 비교로 카디널리티 추정 정확도 확인
  - `Buffers`, `TempSpc`, `PGA` 사용량 모니터링
  - 오판 지점 식별 후 통계/구조/힌트 기반 교정

---

## 결론

고급 조인 테크닉의 본질은 복잡한 조인 시나리오를 체계적으로 해결하는 방법론에 있습니다:

1. **대형 입력을 구조적으로 축소하는 브리지 전략**은 대형 테이블 간의 직접 조인 비용을 급격히 감소시킵니다. 핵심은 조건별 키 집합을 생성하여 조인 경로를 단순화하고, 선택도가 높은 조건을 우선적으로 적용하는 것입니다.

2. **점이력 조회**는 특정 시점의 최신 상태를 효율적으로 찾는 기술로, LATERAL(APPLY)과 역순 인덱스 스캔을 결합한 Stopkey 패턴이 가장 효과적입니다. 대량 처리 시에는 세트 기반 접근법도 고려해야 합니다.

3. **선분이력 처리**는 시간 구간 기반의 조인을 체계화하는 기술입니다. LEAD 함수를 활용한 구간 생성과 반개구간([start,end)) 규칙의 일관적 적용이 핵심이며, 후보 브리지를 통한 입력 축소가 성능 개선의 열쇠입니다.

4. **미매칭 탐지**는 데이터 무결성 검증과 결손 데이터 식별에 필수적입니다. NOT EXISTS 패턴의 명시적 사용과 FULL OUTER JOIN을 활용한 양방향 검증이 효과적입니다.

5. **실측 기반 검증**은 모든 튜닝의 완성 단계입니다. DBMS_XPLAN의 ALLSTATS LAST 옵션을 활용한 실행계획 분석, 카디널리티 추정 정확도 확인, 자원 사용량 모니터링을 통해 튜닝 효과를 객관적으로 평가해야 합니다.

이러한 고급 조인 테크닉을 종합적으로 활용하면 대용량 데이터 처리, 시간 이력 관리, 데이터 품질 검증 등 복잡한 비즈니스 요구사항을 성능과 안정성 측면에서 동시에 충족시킬 수 있습니다. 각 기법의 장단점을 이해하고 상황에 맞게 적절히 조합하는 것이 전문가의 역량입니다.