---
layout: post
title: MFC - ARM64, ARM64EC 포팅
date: 2025-09-22 14:25:23 +0900
category: MFC
---
# ARM64/ARM64EC 포팅 완전 가이드
**x64 포인터·정수 이슈는 이미 해결했다고 가정**하고, 여기서는 **ARM64/ARM64EC 차이**, **플러그인 혼합 실행(ARM64EC)**, **NEON 최적화**, **함수 포인터 크로싱(crossing) 규칙**을 **실전 중심**으로 깊게 다룹니다.

---

## 0. 큰 그림과 의사결정 트리

### 왜 ARM64EC인가?
- **점진적 이행(hybrid ABI)**: x64 프로세스(에뮬레이션)에서 **ARM64EC로 컴파일된 코드**를 **네이티브 속도**로 실행.
- **플러그인/서드파티 보존**: 호스트 또는 플러그인을 ARM64EC로 바꾸면 **x64 바이너리와 상호 호출** 가능.
- **목표 상태**: 최종적으로 **순수 ARM64**(전부 네이티브)면 최고지만, 현실적으로 **ARM64EC → ARM64** 순서가 안전.

### 어떤 타깃을 고를까?
| 시나리오 | 권장 타깃 | 이유 |
|---|---|---|
| 기존 x64 호스트 + 오래된 x64 플러그인 유지 | **호스트 = ARM64EC** | x64 플러그인 그대로 유지 + 새 코드 ARM64 네이티브 속도 |
| SDK/라이브러리 제공자(개발자 대상) | **듀얼(ARM64 + ARM64EC)** | 순수 ARM64 앱도, x64/ARM64EC 앱도 모두 지원 |
| 배포 대상이 100% 최신 Arm 디바이스 | **순수 ARM64** | 단순·최고 성능 |
| 복잡한 플러그인 생태계(서드파티 다수) | **호스트 ARM64EC** | 믹스&매치 유연성, 다운타임 최소화 |

---

## 1. 아키텍처 핵심 개념 정리

### 1.1 ARM64 vs ARM64EC vs x64 (Windows)
- **ARM64**: 순수 Arm64 ABI. **Arm 코어에서 네이티브** 실행. x64 코드와 **직접** 호출 불가.
- **ARM64EC**: **x64와 상호 호출 가능한 하이브리드 ABI**.
  - x64 프로세스(에뮬레이션)에서도 ARM64EC 함수 **네이티브 실행**(브리지/썽킹 제공).
  - **호스트/플러그인 혼합**에 적합.
- **x64**: 기존 64비트 x86. Arm 장치에서는 **에뮬레이션**으로 실행.

> 실무 규칙
> - **ARM64 ↔ x64**: 직접 호출 불가(서로 ABI 다름).
> - **ARM64EC ↔ x64**: **가능**(ARM64EC가 x64-callable 엔트리 제공).
> - **ARM64EC ↔ ARM64**: 동일 프로세스에서 **가능**(Arm 네이티브).
> - **결론**: 혼합이 필요하면 **ARM64EC**가 연결고리.

### 1.2 바이너리 호환·조합 테이블
| 프로세스(호스트) | 로드할 수 있는 모듈 |
|---|---|
| **x64 프로세스(에뮬)** | x64, **ARM64EC**(상호 호출), *(ARM64는 불가)* |
| **ARM64EC 프로세스** | x64, **ARM64EC**, ARM64 (섞어서 가능) |
| **ARM64 프로세스** | ARM64, **ARM64EC** *(x64는 직접 불가)* |

> 배포 팁
> - 호스트를 **ARM64EC**로 만들면 “x64 유산 + 새 ARM64 코드”를 **한곳에서** 수용할 수 있습니다.

---

## 2. 빌드 시스템/툴체인 체크리스트

### 2.1 구성
- **MSVC**: 최신 툴셋(ARM64/ARM64EC 지원).
- **플랫폼 툴셋**: `v143` 이상 권장.
- **구성(Configurations)**: `x64`, `ARM64`, `ARM64EC` **3종**을 나란히 준비해 멀티 타깃 빌드.

### 2.2 프로젝트 설정(핵심)
- **Configuration Type**: DLL / EXE.
- **Platform**: `ARM64` 또는 `ARM64EC`.
- **C/C++**:
  - `/Zc:__cplusplus` (표준 준수), `/std:c++20` 이상 권장
  - `/O2` 또는 `/O2 /GL`(LTCG)
  - **ARM64EC**: 일반 C/C++ 옵션 동일. 인라인 어셈 금지(아래 참고).
- **링커**:
  - **서드파티 정적 라이브러리**는 **타깃 아키텍처 동일** 필요.
    - ARM64EC 모듈에 **x64 정적 라이브러리**를 **링크할 수 없습니다**(서로 다른 코드 아키텍처).
    - DLL로 분리하고, 호출 경계에서 ARM64EC 브리지를 사용.

### 2.3 코드 베이스 공통 규약(요약)
- **인라인 어셈 금지**: MSVC는 ARM64/ARM64EC에서 `__asm` 미지원. → **컴파일러 인트린식** 사용.
- **SSE/AVX 인트린식**: ARM에서는 사용 불가. → **NEON** 인트린식으로 포팅.
- **포인터 크기 8바이트**: x64와 동일. 포인터-정수 변환 시 **명시적 캐스팅**(이미 해결했다고 하셨으니 유지).
- **정렬/패킹**: ARM64는 **정렬에 민감** → `#pragma pack` 남용 금지, ABI 경계(struct) 검사.

---

## 3. 함수 포인터 “크로싱” 규칙(***가장 중요***)

**문제**: 서로 다른 “퍼스낼리티”(x64, ARM64, ARM64EC) 간에 **함수 포인터를 직접 저장/호출**하면? → **크래시/UB 위험**.

### 3.1 안전 규칙
1. **경계에서는 항상 “API 표면(Export)”을 통과**:
   - `extern "C"` + 명확한 서명(호출 규약 포함: Windows는 기본 `__cdecl` 유사)으로 **DLL export**를 마련.
   - `GetProcAddress`로 **해당 퍼스낼리티용 엔트리**를 얻어 호출.
2. **콜백도 Export를 통해 등록**:
   - x64 쪽이 콜백을 요구하면, **ARM64EC에서 x64-callable 콜백 엔트리**를 export 하여 **주소를 넘김**.
   - 반대도 동일. “직접 함수 포인터 전달”을 피하고 **얇은 래퍼(Thunk)** 를 둔다.
3. **함수 포인터 비교/연산 금지**:
   - 퍼스낼리티가 섞이면 포인터 비트 표현이 **스텁**일 수 있음. **동등성 비교·주소 연산 금지**.
4. **std::function/Delegate 보관 주의**:
   - **퍼스낼리티 경계**를 넘어 캐럿/캡처된 함수포인터를 저장하지 말고, 항상 **Export된 C API 콜백**을 **등록/해제**하는 패턴 사용.

### 3.2 안전한 패턴(요약 코드)

/* 헤더(공유) */
```cpp
// C API(언어 중립/ABI 안정)
extern "C" {

// x64/ARM64/ARM64EC 어디서나 동일한 서명
typedef void (*PFN_LOG)(int level, const wchar_t* msg);

// 호스트가 제공하는 등록 함수 (Export)
__declspec(dllexport) void RegisterLogger(PFN_LOG cb);

// 플러그인이 제공하는 진입점 (Export)
__declspec(dllexport) void PluginEntry();

}
```

/* ARM64EC 플러그인 쪽 */
```cpp
// ARM64EC 모듈: 이 함수는 x64에서도 호출 가능(엔트리 썽크 제공)
extern "C" __declspec(dllexport)
void PluginEntry() {
    // 안전: Export 경유로 받은 콜백만 사용. 지역 함수포인터 직접 전달 금지.
}
```

/* x64 호스트 */
```cpp
auto pReg = (decltype(&RegisterLogger))GetProcAddress(hMod, "RegisterLogger");
pReg(/* x64-callable 함수 포인터 */ + 얇은 래퍼);

static void __stdcall X64Log(int level, const wchar_t* msg) {
    // ...
}
```

> 포인트
> - **GetProcAddress**를 경계로 사용하면 OS/로더가 **맞는 썽크 주소**를 줍니다.
> - **직접 멤버포인터/람다 캡처 포인터**를 서로 주고받지 마세요.

---

## 4. ARM64EC 플러그인 혼합 실행(설계 패턴)

### 4.1 플러그인 생태계별 전략
- **호스트 = ARM64EC**
  - **x64 플러그인**: 그대로 로드(에뮬), **ARM64EC 플러그인**: 네이티브, **ARM64 플러그인**: 네이티브.
  - → 가장 유연. **호스트만 ARM64EC**로 바꾸면 이행가능성 최대.
- **호스트 = ARM64**
  - **x64 플러그인 로드 불가**.
  - **ARM64/ARM64EC 플러그인만** 허용. (서드파티가 따라오지 못하면 어려움)
- **호스트 = x64**(그대로)
  - **ARM64EC 플러그인**만 네이티브 혜택, x64는 에뮬.
  - 점진 이행 시작점으로 무난.

### 4.2 로딩/등록 시퀀스(의사 코드)
```
Host(ARM64EC)
 ├─ LoadLibraryW(plugin.dll)
 ├─ GetProcAddress("PluginEntry")
 ├─ GetProcAddress("RegisterXxx")
 ├─ Register 콜백들(PFN_*)
 └─ PluginEntry() 호출
```

- **ABI 문서화**: Export 함수 서명/메모리 소유권(new/free)/스레드 모델을 **C 헤더로 고정**.
- **버전 협상**: `GetVersion()` 또는 `Init(ABI_VERSION, &caps)` 제공.
- **예외 경계**: C 경계에서 **C++ 예외 금지**(넘기지 말고 **에러코드로 변환**).

---

## 5. NEON 최적화(Arm SIMD) — SSE에서 옮겨오기

### 5.1 기본 원칙
- **SSE/AVX → NEON** 매핑:
  - `__m128` ≈ `float32x4_t`, `int32x4_t`
  - Add: `_mm_add_ps` → `vaddq_f32`
  - Mul: `_mm_mul_ps` → `vmulq_f32`
  - FMA: `_mm_fmadd_ps` → `vfmaq_f32` (Armv8.2+)
- **정렬**: 16바이트 정렬 권장(Windows 런타임은 기본 16바이트 맞음).
- **로드/스토어**: `vld1q_f32`, `vst1q_f32` (경계 정렬 신경).
- **분기 줄이기**: **SIMD 친화적 루프**(unroll + prefetch).
- **메모리 순서**: CPU는 약한 메모리 모델. 공유 데이터는 **Interlocked/atomic** 사용.

### 5.2 예제: 4-원소 벡터 곱-합(FMA)

/* 스칼라 → NEON */
```cpp
#include <arm64intr.h>     // 또는 <arm_neon.h> (MSVC/Clang-cl)

inline float Dot4_NEON(const float* a, const float* b) {
    float32x4_t va = vld1q_f32(a);
    float32x4_t vb = vld1q_f32(b);
#if defined(__ARM_FEATURE_FMA)
    // (a*b)의 수평 합
    float32x4_t m = vmulq_f32(va, vb);
    float32x2_t sum2 = vadd_f32(vget_low_f32(m), vget_high_f32(m));
    float32x2_t sum1 = vpadd_f32(sum2, sum2);
    return vget_lane_f32(sum1, 0);
#else
    // FMA 미사용 경로
    float32x4_t m = vmulq_f32(va, vb);
    float32x2_t s = vadd_f32(vget_low_f32(m), vget_high_f32(m));
    float32x2_t t = vpadd_f32(s, s);
    return vget_lane_f32(t, 0);
#endif
}
```

### 5.3 예제: 색 변환(행렬 × 픽셀)
/* 3×3 RGB 매트릭스 적용 */
```cpp
struct Mat3 { float m[9]; };

inline void RGBx1_NEON(const float* rgb, const Mat3& M, float* out) {
    float32x4_t r = vld1q_dup_f32(rgb + 0);   // rrrr
    float32x4_t g = vld1q_dup_f32(rgb + 1);   // gggg
    float32x4_t b = vld1q_dup_f32(rgb + 2);   // bbbb

    float32x4_t m0 = vld1q_f32(M.m + 0);      // m00 m01 m02 m03(패딩)
    float32x4_t m1 = vld1q_f32(M.m + 3);
    float32x4_t m2 = vld1q_f32(M.m + 6);

    float32x4_t x = vmulq_f32(r, m0);
    x = vmlaq_f32(x, g, m1);
    x = vmlaq_f32(x, b, m2);

    out[0] = vgetq_lane_f32(x, 0);
    out[1] = vgetq_lane_f32(x, 1);
    out[2] = vgetq_lane_f32(x, 2);
}
```

### 5.4 성능 팁
- **루프 언롤**: 4~8배 언롤 + `__prefetch`(Clang/LLVM) 또는 MSVC의 `__prefetch` 대체(가능 시).
- **메모리 레이아웃**: SoA(구조의 배열)로 바꾸면 SIMD 효율↑.
- **분기/NaN 검사 최소화**: 마스크 연산으로 대체.
- **스칼라 폴백**: Armv8.2 FMA 미지원 장치 고려시 **폴백 경로** 유지.

---

## 6. ABI/호출 규약/스택 규율 주의점

### 6.1 호출 규약
- Windows는 각 아키텍처별 **독자적 호출 규약**.
- **ARM64EC**는 **x64와 상호 호출 가능한 엔트리**를 제공(컴파일러가 썽크 처리).
- **개발자 관점**: C/C++ 레벨에서 **별도 어노테이션 불필요**. 단, **인라인 어셈/수동 prolog/epilog 금지**.

### 6.2 스택/프레임
- **스택 16바이트 정렬 필수**.
- **가변 인자 함수(…​)**: 크로싱 경계에 두지 마세요(서명 안정성 저하). 고정 서명 C API로 대체.

### 6.3 구조체/정렬
- 구조체는 **자연 정렬** 유지. `#pragma pack(push, 1)` 같은 패킹은 **파일 포맷/온디스크 구조**에만 국한.
- **ABI 경계에 노출되는 구조체**는 **static_assert(sizeof, alignof)** 로 타깃별 동일성 점검.

---

## 7. 원자성/메모리 모델/Interlocked

- Arm은 **약한 메모리 모델**: x86보다 **재정렬 가능성↑**.
- **규칙**:
  1) 스레드 간 공유 변수는 **std::atomic**(C++20) 또는 **InterlockedXXX**(WinAPI) 사용.
  2) 릴리즈-어커이어 질서로 **출력-소비** 관계 보장.
  3) 스핀락에서 `YieldProcessor`(ARM64 대응 NOP 힌트) 호출.

```cpp
#include <atomic>
std::atomic<bool> ready{false};

// producer
data = Make();
ready.store(true, std::memory_order_release);

// consumer
while (!ready.load(std::memory_order_acquire)) { /* spin */ }
Use(data);
```

---

## 8. 이미지 처리/오디오 DSP 등 NEON 튜닝 실전 템플릿

### 8.1 대량 배열 변환(선형 변환 + 클램프)
```cpp
// out[i] = clamp(a * in[i] + b, 0, 255)
void TransformClamp_NEON(const uint8_t* in, uint8_t* out, size_t n, float a, float b) {
    size_t i = 0;
    float32x4_t va = vdupq_n_f32(a);
    float32x4_t vb = vdupq_n_f32(b);
    uint8x8_t  z   = vdup_n_u8(0);
    uint8x8_t  mx  = vdup_n_u8(255);

    for (; i + 8 <= n; i += 8) {
        uint8x8_t x8 = vld1_u8(in + i);
        uint16x8_t x16 = vmovl_u8(x8);
        uint32x4_t lo = vmovl_u16(vget_low_u16(x16));
        uint32x4_t hi = vmovl_u16(vget_high_u16(x16));

        float32x4_t flo = vcvtq_f32_u32(lo);
        float32x4_t fhi = vcvtq_f32_u32(hi);

        flo = vmlaq_f32(vb, flo, va);
        fhi = vmlaq_f32(vb, fhi, va);

        // 0~255 clamp
        flo = vmaxq_f32(vdupq_n_f32(0.f), vminq_f32(flo, vdupq_n_f32(255.f)));
        fhi = vmaxq_f32(vdupq_n_f32(0.f), vminq_f32(fhi, vdupq_n_f32(255.f)));

        uint32x4_t ulo = vcvtq_u32_f32(flo);
        uint32x4_t uhi = vcvtq_u32_f32(fhi);

        uint16x8_t u16 = vcombine_u16(vmovn_u32(ulo), vmovn_u32(uhi));
        uint8x8_t  u8  = vmovn_u16(u16);

        vst1_u8(out + i, u8);
    }

    // 꼬리 처리
    for (; i < n; ++i) {
        float t = a * in[i] + b;
        t = t < 0 ? 0 : (t > 255 ? 255 : t);
        out[i] = (uint8_t)(t + 0.5f);
    }
}
```

### 8.2 오디오: FIR 4탭(단순 샘플)
```cpp
float32x4_t tap = vld1q_f32(coeff); // c0..c3
for (size_t i=0; i+4<=n; i+=4) {
    float32x4_t x = vld1q_f32(&in[i]);
    acc = vmlaq_f32(acc, x, tap);
}
```

---

## 9. 테스트/검증 전략(ARM 장비 없이도)

- **CI 매트릭스**: `x64`, `ARM64`, `ARM64EC` 3 타깃 빌드(Clang-cl 병행 추천).
- **런타임 자가 검증**: 기능 플래그(NEON/버전) 로깅, 성능 카운터(높은 분해능 타이머) 수집.
- **에뮬 + 디바이스**: 로직 테스트는 에뮬로 충분, **성능/메모리/전력**은 실기기에서 최종 검증.
- **동등성 테스트**: SIMD 경로 vs 스칼라 경로 **bit-for-bit** 또는 공차 비교.

---

## 10. 흔한 함정과 회피책

| 함정 | 원인 | 해결 |
|---|---|---|
| **크로싱 포인터 직접 호출** | x64 포인터를 ARM64EC 함수에 직접 캐스팅 | **항상 Export + GetProcAddress** 사용, 콜백도 C API |
| **정적 라이브러리 혼합 링크 실패** | ARM64EC 프로젝트에 x64 `.lib` 링크 | 아키텍처 동일한 정적 lib만 링크. 이종은 DLL 경계로 분리 |
| **인라인 어셈 오류** | ARM64(EC)에서 `__asm` 불가 | **인트린식**로 대체 |
| **성능 저하** | 오토벡터화 실패, 경계 미정렬 | 명시적 NEON, 16B 정렬, SoA 재배열, 언롤/프리패치 |
| **오류 시나리오 불일치** | 약한 메모리 모델 | `std::atomic`/Interlocked, fence 사용 |
| **구조체 호환 깨짐** | `#pragma pack(1)` 남용 | ABI 경계 struct는 자연 정렬, 버전 필드·크기 필드 포함 |

---

## 11. 마이그레이션 로드맵(추천)

1) **경계 정리**: 모듈 간 통신을 **C 헤더(Export)** 로 고정, 에러코드·메모리 규약 명시.
2) **호스트를 ARM64EC** 로 빌드: 기존 x64 플러그인 즉시 살아남.
3) **핵심 Hotpath를 NEON 포팅**: 성능 체감이 큰 루틴부터.
4) **서드파티 의존성 분류**: 소스 빌드 가능(ARM64 타깃) vs x64 바이너리만 존재(DLL 경계로).
5) **순수 ARM64 분리 배포**: 시장/고객군이 따라오면 ARM64 전환 채널 개설.
6) **장기**: 모든 플러그인/SDK ARM64(EC) 제공 → ARM64 순정 채널로 통합.

---

## 12. 미세 사항 Q&A

### Q1. 가변인자(…​) 함수는 쓸 수 있나?
- 같은 퍼스낼리티 내부에서는 가능. **경계(Export)** 에서는 **고정 프로토콜**로 바꾸세요.

### Q2. 예외(C++ throw)는 경계 넘나들 수 있나?
- **No**. **C 경계**에서는 예외를 **에러코드/HRESULT** 로 변환하고, 반대쪽에서 복구.

### Q3. 런타임에 내 모듈이 어떤 퍼스낼리티인지 알 수 있나?
- 빌드 타깃으로 구분하는 것이 안전. 필요하면 **진단 Export**로 보고(log)하도록.

### Q4. x64 전용 인스트럭션(SSE) 의존 코드가 많다?
- **SSE 래퍼 계층**을 만들고, ARM64에서는 NEON 백엔드를 선택하는 **헤더온리 어댑터** 방식을 추천.

---

## 13. 레퍼런스 구현 스니펫(안전한 경계 설계)

### 13.1 공용 헤더(api.h)
```cpp
#pragma once
#include <stdint.h>

#ifdef _WIN32
  #define API_EXPORT __declspec(dllexport)
  #define API_IMPORT __declspec(dllimport)
#else
  #define API_EXPORT
  #define API_IMPORT
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct ApiVersion {
    uint16_t major, minor;
} ApiVersion;

typedef void (*PFN_Log)(int level, const wchar_t* msg);

typedef struct HostCallbacks {
    PFN_Log log;
} HostCallbacks;

// 플러그인이 제공
API_EXPORT int  Plugin_Init(ApiVersion ver, const HostCallbacks* host);
API_EXPORT void Plugin_Shutdown(void);

// 호스트가 제공(선택)
API_EXPORT void Host_QueryCaps(/*out*/uint32_t* caps);

#ifdef __cplusplus
}
#endif
```

### 13.2 플러그인(ARM64EC) 구현 포인트
```cpp
#include "api.h"
static HostCallbacks g_host{};

extern "C" API_EXPORT
int Plugin_Init(ApiVersion ver, const HostCallbacks* host) {
    g_host = *host; // 콜백 보관(주의: 경계 바깥 포인터 저장 OK? → Export 받은 주소만, 내부 포인터 금지)
    if (g_host.log) g_host.log(1, L"Plugin_Init (ARM64EC)");
    return 0;
}

extern "C" API_EXPORT
void Plugin_Shutdown() {
    if (g_host.log) g_host.log(1, L"Plugin_Shutdown");
}
```

### 13.3 호스트(ARM64EC 또는 x64) 로더
```cpp
using TInit     = int  (*)(ApiVersion, const HostCallbacks*);
using TShutdown = void (*)();

static void __stdcall HostLog(int level, const wchar_t* msg) {
    // x64/ARM64EC 어디서든 안전
    // ... 로그 출력 ...
}

void LoadPlugin(const wchar_t* path) {
    HMODULE h = LoadLibraryW(path);
    if (!h) return;

    auto init = reinterpret_cast<TInit>(GetProcAddress(h, "Plugin_Init"));
    auto quit = reinterpret_cast<TShutdown>(GetProcAddress(h, "Plugin_Shutdown"));

    HostCallbacks cb{ HostLog };
    if (init) init(ApiVersion{1,0}, &cb);

    // ... 사용 ...
    if (quit) quit();
    FreeLibrary(h);
}
```

> 이 패턴이면 **x64 ↔ ARM64EC** 간 **포인터 크로싱 문제** 없이 안전하게 왕복합니다.

---

## 14. 디버깅·프로파일링 팁

- **디버깅 심볼 분리**: 아키텍처별 `.pdb` 분리 저장.
- **성능 추적**: 고분해능 타이머(`QueryPerformanceCounter`)로 Hotpath 판별.
- **ETW/TraceLogging**: 퍼스낼리티 별 코드 경로 로깅(“ARM64EC/NEON 활성” 등).
- **크래시 덤프**: 아키텍처 마다 스택/레지스터 레이아웃 상이 — **미니덤프 수집 자동화**.

---

## 15. 체크리스트(마지막 요약)

1. **경계는 항상 C Export** (GetProcAddress 기반, 콜백도 동일).
2. **인라인 어셈 X** — 인트린식으로 전환.
3. **정적 라이브러리 아키텍처 동일** — 이종은 DLL로 분리.
4. **NEON 최적화** — SoA/정렬/언롤/폴백 준비.
5. **atomic/Interlocked** — Arm 약한 메모리 모델 대응.
6. **ABI 구조체 검증** — sizeof/align static_assert.
7. **빌드 매트릭스** — x64/ARM64/ARM64EC 모두 빌드·테스트.
8. **호스트 ARM64EC 권장** — 플러그인 혼합 생태계에 최적.

---

## 16. 부록: 문제해결 모음

| 증상 | 진단 포인트 | 해결 |
|---|---|---|
| x64에서 ARM64EC 함수 호출 시 즉시 크래시 | 함수포인터 직접 캐스팅 호출 | **Export + GetProcAddress**로 썽크 얻어 호출 |
| ARM64EC 링크 에러(LIB 불일치) | x64 정적 lib 링크 시도 | 아키텍처 맞는 lib로 교체, 또는 DLL 경계로 분리 |
| 성능이 x64 에뮬과 큰 차이 없음 | Hotpath 미포팅, 메모리 병목 | NEON 포팅, 캐시 친화 레이아웃, 언롤/프리패치 |
| 구조체 깨짐 | pack(1) 유산 | 자연 정렬로 복귀, 버전 필드로 호환 |
| 드문 데이터 레이스 | Arm 리오더링 | std::atomic/Interlocked, fence 삽입 |
