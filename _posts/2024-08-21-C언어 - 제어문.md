---
layout: post
title: C - 제어문
date: 2024-08-21 19:20:23 +0900
category: C
---
# 제어문: 조건문과 반복문 완벽 가이드

## 시작하기 전: 제어문의 핵심 요약

제어문은 프로그램의 흐름을 결정하는 기본 도구입니다. 조건에 따라 다른 코드를 실행하거나, 특정 작업을 반복적으로 수행하는 데 사용됩니다. C 언어에는 다양한 제어문이 있으며, 각각의 특성과 적절한 사용 시기를 이해하는 것이 중요합니다.

먼저 제어문의 모든 요소를 포함한 간단한 예제를 살펴보겠습니다:

```c
#include <stdio.h>

int main(void) {
    // 조건문 예제
    int score = 85;
    
    // if-else 문
    if (score >= 90) puts("A 학점");
    else if (score >= 80) puts("B 학점");
    else puts("C 이하");
    
    // switch 문
    int menu = 2;
    switch (menu) {
        case 1: puts("커피"); break;
        case 2: puts("차");   break;
        default: puts("잘못된 선택");
    }
    
    // 반복문과 제어 키워드
    for (int i = 0; i < 5; ++i) {
        if (i == 2) continue;  // 2는 건너뜀
        if (i == 4) break;     // 4에서 반복 종료
        printf("%d ", i);      // 0 1 3 출력
    }
    puts("");
    
    // while 문
    int i = 0;
    while (i < 3) printf("%d ", i++); // 0 1 2
    puts("");
    
    // do-while 문
    int j = 0;
    do {
        printf("%d ", j++);
    } while (j < 2); // 0 1
    puts("");
    
    return 0;
}
```

## 조건문: 프로그램의 결정 지점

### if-else 문: 가장 기본적인 조건 분기

if-else 문은 조건에 따라 다른 코드 블록을 실행합니다. 기본적인 구조부터 살펴보겠습니다:

```c
int score = 85;

if (score >= 90) {
    printf("A 학점\n");
} else if (score >= 80) {
    printf("B 학점\n");
} else {
    printf("C 이하\n");
}
```

#### 중괄호를 항상 사용하세요

한 줄짜리 if 문이라도 중괄호를 사용하는 것이 좋습니다. 이렇게 하면 코드를 수정할 때 발생할 수 있는 실수를 방지할 수 있습니다:

```c
// 좋지 않은 예: 중괄호 없음
if (condition)
    do_something();  // 나중에 코드 추가하면 문제 발생 가능

// 좋은 예: 중괄호 사용
if (condition) {
    do_something();  // 안전하게 코드 추가 가능
}
```

#### 논리 연산자와 함께 사용하기

여러 조건을 조합할 때는 논리 연산자를 사용합니다. 특히 중요한 것은 **단락 평가**입니다. 즉, 첫 번째 조건만으로 결과가 결정되면 나머지 조건은 평가하지 않습니다:

```c
// ptr이 NULL인지 먼저 확인
if (ptr != NULL && ptr->size > 0) {
    /* 안전하게 ptr->size 접근 가능 */
}
// 첫 번째 조건(ptr != NULL)이 false면 두 번째 조건은 평가하지 않음
```

이 특성은 특히 포인터나 배열 접근 전에 유효성 검사를 할 때 매우 유용합니다.

### switch 문: 여러 경우에 대한 명확한 분기

switch 문은 하나의 변수나 표현식 값에 따라 여러 경로 중 하나를 선택할 때 사용됩니다:

```c
int menu = 2;

switch (menu) {
    case 1:
        printf("커피 주문\n");
        break;
    case 2:
        printf("차 주문\n");
        break;
    case 3:
        printf("주스 주문\n");
        break;
    default:
        printf("잘못된 선택입니다.\n");
        break;
}
```

#### 주의사항: break 문의 중요성

switch 문에서 가장 중요한 점은 각 case 뒤에 break 문을 사용하는 것입니다. break를 생략하면 의도치 않게 다음 case까지 실행되는 **fallthrough 현상**이 발생할 수 있습니다:

```c
// 의도치 않은 fallthrough 예제
int value = 1;
switch (value) {
    case 1:
        printf("1번 실행\n");
        // break;  // 누락!
    case 2:
        printf("2번 실행\n");  // 의도치 않게 이것도 실행됨
        break;
}
```

의도적으로 fallthrough를 사용해야 할 때는 반드시 주석으로 표시해야 합니다:

```c
switch (grade) {
    case 'A':
        bonus += 10;
        /* fallthrough - 의도적으로 다음 케이스도 실행 */
    case 'B':
        bonus += 5;
        break;
    // ...
}
```

#### enum과 함께 사용하기

switch 문은 enum과 함께 사용할 때 특히 효과적입니다. 코드의 가독성이 크게 향상됩니다:

```c
typedef enum { STATE_IDLE, STATE_RUNNING, STATE_PAUSED } AppState;

AppState current = STATE_RUNNING;

switch (current) {
    case STATE_IDLE:
        printf("대기 중\n");
        break;
    case STATE_RUNNING:
        printf("실행 중\n");
        break;
    case STATE_PAUSED:
        printf("일시 정지\n");
        break;
}
```

## 반복문: 작업의 반복 수행

### while 문: 조건이 참인 동안 반복

while 문은 조건이 참인 동안 코드 블록을 반복 실행합니다:

```c
int count = 0;
while (count < 5) {
    printf("카운트: %d\n", count);
    count++;
}
```

while 문의 특징은 **최소 0번** 실행될 수 있다는 점입니다. 조건이 처음부터 거짓이면 한 번도 실행되지 않습니다.

### for 문: 가장 일반적인 반복문

for 문은 초기화, 조건 검사, 증감 세 부분으로 구성되어 있어 반복 횟수를 명확히 제어할 수 있습니다:

```c
for (int i = 0; i < 10; i++) {
    printf("%d ", i);
}
```

#### for 문의 다양한 활용

for 문은 단순한 카운팅 외에도 다양한 방식으로 활용할 수 있습니다:

```c
// 다중 변수 사용
for (int i = 0, j = 10; i < j; i++, j--) {
    printf("i=%d, j=%d\n", i, j);
}

// 조건부 생략
for (;;) {  // 무한 루프
    if (should_exit()) break;
    // 작업 수행
}
```

### do-while 문: 최소 한 번은 실행되는 반복문

do-while 문은 코드 블록을 먼저 실행한 후 조건을 검사합니다. 따라서 **최소 한 번은 무조건 실행**됩니다:

```c
int input;
do {
    printf("1부터 10 사이의 숫자를 입력하세요: ");
    scanf("%d", &input);
} while (input < 1 || input > 10);  // 조건이 참이면 다시 반복
```

do-while 문의 중요한 특징은 마지막에 **세미콜론이 필수**라는 점입니다. 이를 잊어버리면 컴파일 오류가 발생합니다.

## 루프 제어: break와 continue

### break: 루프 중간에서 탈출하기

break 문은 현재 실행 중인 루프를 즉시 종료합니다:

```c
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;  // i가 5가 되면 루프 종료
    }
    printf("%d ", i);  // 0 1 2 3 4
}
```

### continue: 현재 반복 건너뛰기

continue 문은 현재 반복을 건너뛰고 다음 반복으로 넘어갑니다:

```c
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) {
        continue;  // 짝수는 건너뛰기
    }
    printf("%d ", i);  // 1 3 5 7 9 (홀수만 출력)
}
```

#### 중첩된 루프에서의 break

중첩된 루프에서 break는 가장 안쪽의 루프만 탈출합니다. 모든 루프를 한 번에 탈출하려면 추가적인 방법이 필요합니다:

```c
// 방법 1: 플래그 변수 사용
int found = 0;
for (int i = 0; i < 10 && !found; i++) {
    for (int j = 0; j < 10; j++) {
        if (array[i][j] == target) {
            found = 1;
            break;  // 안쪽 루프만 탈출
        }
    }
}

// 방법 2: goto 사용 (신중하게)
for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
        if (array[i][j] == target) {
            goto search_complete;  // 모든 루프 탈출
        }
    }
}
search_complete:
    // 검색 완료 후 처리
```

## 실전 예제: 메뉴 시스템 구현

실제 프로그램에서 자주 사용되는 메뉴 시스템을 구현해 보겠습니다:

```c
#include <stdio.h>
#include <stdlib.h>

void clear_input_buffer(void) {
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        // 입력 버퍼 비우기
    }
}

int main(void) {
    int choice;
    
    while (1) {  // 무한 루프
        // 메뉴 출력
        printf("\n=== 메뉴 ===\n");
        printf("1. 데이터 추가\n");
        printf("2. 데이터 조회\n");
        printf("3. 데이터 수정\n");
        printf("4. 데이터 삭제\n");
        printf("0. 프로그램 종료\n");
        printf("선택: ");
        
        // 사용자 입력 받기
        if (scanf("%d", &choice) != 1) {
            printf("숫자를 입력해주세요.\n");
            clear_input_buffer();
            continue;
        }
        
        // 선택에 따른 처리
        switch (choice) {
            case 1:
                printf("데이터를 추가합니다...\n");
                // 실제 추가 로직
                break;
                
            case 2:
                printf("데이터를 조회합니다...\n");
                // 실제 조회 로직
                break;
                
            case 3:
                printf("데이터를 수정합니다...\n");
                // 실제 수정 로직
                break;
                
            case 4:
                printf("데이터를 삭제합니다...\n");
                // 실제 삭제 로직
                break;
                
            case 0:
                printf("프로그램을 종료합니다.\n");
                return 0;  // 프로그램 종료
                
            default:
                printf("잘못된 선택입니다. 다시 시도하세요.\n");
                break;
        }
    }
    
    return 0;
}
```

## 알고리즘 예제로 이해하기

### 합계 계산하기

```c
// 1부터 100까지의 합 계산
int sum = 0;
for (int i = 1; i <= 100; i++) {
    sum += i;
}
printf("1부터 100까지의 합: %d\n", sum);

// 수학 공식으로 검증 (n(n+1)/2)
printf("공식으로 계산한 값: %d\n", 100 * 101 / 2);
```

### 최대공약수 구하기 (유클리드 알고리즘)

```c
// 반복문을 사용한 유클리드 알고리즘
int gcd(int a, int b) {
    while (b != 0) {
        int remainder = a % b;
        a = b;
        b = remainder;
    }
    return a;
}

int main(void) {
    int num1 = 56, num2 = 98;
    printf("%d와 %d의 최대공약수: %d\n", num1, num2, gcd(num1, num2));
    return 0;
}
```

### 소수 판별하기

```c
#include <math.h>
#include <stdbool.h>

bool is_prime(int n) {
    if (n < 2) return false;  // 2 미만은 소수가 아님
    
    // 2는 유일한 짝수 소수
    if (n == 2) return true;
    if (n % 2 == 0) return false;  // 짝수는 소수가 아님
    
    // 3부터 √n까지 홀수로 나누어 떨어지는지 확인
    for (int i = 3; i * i <= n; i += 2) {
        if (n % i == 0) {
            return false;  // 나누어 떨어지면 소수가 아님
        }
    }
    return true;  // 어떤 수로도 나누어 떨어지지 않으면 소수
}

int main(void) {
    int number = 17;
    if (is_prime(number)) {
        printf("%d는 소수입니다.\n", number);
    } else {
        printf("%d는 소수가 아닙니다.\n", number);
    }
    return 0;
}
```

## 주의할 점과 모범 사례

### 1. 무한 루프 방지

무한 루프는 종료 조건이 제대로 설정되지 않았을 때 발생합니다:

```c
// 위험한 예제: 무한 루프
int i = 0;
while (i < 10) {  // i가 증가하지 않음
    printf("%d\n", i);
    // i++;  // 이 줄이 없으면 무한 루프!
}

// 안전한 예제
int i = 0;
while (i < 10) {
    printf("%d\n", i);
    i++;  // 반드시 조건 변경
}
```

### 2. 부동소수점 비교 주의

부동소수점을 조건문에서 비교할 때는 주의가 필요합니다:

```c
// 부정확한 비교 (절대 피하세요!)
float f = 0.1 + 0.2;
if (f == 0.3) {  // 거의 항상 false!
    printf("같습니다.\n");
}

// 올바른 비교 방법
float tolerance = 0.000001;
if (fabs(f - 0.3) < tolerance) {
    printf("거의 같습니다.\n");
}
```

### 3. 복잡한 조건의 가독성

복잡한 조건문은 가독성을 위해 변수로 분리하는 것이 좋습니다:

```c
// 읽기 어려운 조건
if ((age >= 18 && age <= 65) && (income > 3000 || savings > 10000) && !has_debt) {
    // ...
}

// 읽기 쉬운 조건
bool is_adult = age >= 18 && age <= 65;
bool has_income = income > 3000 || savings > 10000;
bool is_eligible = is_adult && has_income && !has_debt;

if (is_eligible) {
    // ...
}
```

## 디버깅 팁

### 1. 조건문 디버깅

조건문이 예상대로 작동하지 않을 때는 중간 값을 확인하세요:

```c
int a = 5, b = 10;
printf("a=%d, b=%d, a<b=%d\n", a, b, a < b);  // 중간 값 확인

if (a < b) {
    printf("a가 b보다 작습니다.\n");
}
```

### 2. 반복문 디버깅

반복문에서 문제가 발생할 때는 루프 변수의 값을 추적하세요:

```c
for (int i = 0; i < 10; i++) {
    printf("루프 시작: i=%d\n", i);  // 디버깅 출력
    
    // 작업 수행
    
    printf("루프 끝: i=%d\n", i);  // 디버깅 출력
}
```

## 마무리

제어문은 프로그램의 논리를 구성하는 기본 요소입니다. 각 제어문의 특징을 이해하고 적절한 상황에 사용하는 것이 중요합니다. 기억해야 할 핵심 원칙은 다음과 같습니다:

1. **가독성을 우선하세요** - 복잡한 조건은 변수로 분리하고, 중괄호는 항상 사용하세요
2. **switch 문에는 break를 잊지 마세요** - fallthrough는 의도적일 때만 사용하세요
3. **반복문은 종료 조건을 명확히 하세요** - 무한 루프를 방지하세요
4. **적절한 제어문을 선택하세요** - 상황에 맞는 제어문을 사용하세요
