---
layout: post
title: C - 제어문
date: 2024-08-21 19:20:23 +0900
category: C
---
# 제어문 : 조건문과 반복문

## 0. 워밍업: 이 장에서 다루는 모든 개념을 한 번에

```c
#include <stdio.h>

int main(void) {
    int score = 85;
    if (score >= 90) puts("A");
    else if (score >= 80) puts("B");
    else puts("C or below");

    int menu = 2;
    switch (menu) {
        case 1: puts("커피"); break;
        case 2: puts("차");   break;
        default: puts("잘못된 선택");
    }

    for (int i = 0; i < 5; ++i) {
        if (i == 2) continue;  // 2는 생략
        if (i == 4) break;     // 4부터 중단
        printf("%d ", i);      // 0 1 3
    }
    puts("");

    int i = 0;
    while (i < 3) printf("%d ", i++); // 0 1 2
    puts("");

    int j = 0;
    do { printf("%d ", j++); } while (j < 2); // 0 1
    puts("");

    return 0;
}
```

---

## 1. 조건문 (if / else if / else)

### 1.1 기본형과 모범 스타일
```c
int score = 85;

if (score >= 90) {
    printf("A 학점\n");
} else if (score >= 80) {
    printf("B 학점\n");
} else {
    printf("C 이하\n");
}
```

- **항상 중괄호 `{}`** 사용 권장(1줄이라도). 이후 코드 변경 시 “매듭” 오류 방지.
- **조건은 불리언 컨텍스트**: C에서는 `0==false`, `0이외==true`.

### 1.2 “매달린 else(dangling else)” 방지
```c
// 나쁜 예: 가독성/버그 위험
if (a)
    if (b) action1();
    else action2(); // else는 항상 가장 가까운 if에 결합

// 좋은 예: 중괄호로 의도 명확화
if (a) {
    if (b) action1();
    else   action2();
}
```

### 1.3 비교/논리 연산의 단락 평가
```c
if (ptr != NULL && ptr->size > 0) {
    /* 안전: 좌항이 false면 우항 평가하지 않음 */
}
```

### 1.4 범위 검증 패턴
```c
int x = read_value();
if (x < 0 || x > 100) {
    fprintf(stderr, "범위를 벗어남\n");
} else {
    printf("OK: %d\n", x);
}
```

---

## 2. `switch` 문 — 분기 테이블/상태기계의 친구

### 2.1 기본형
```c
int menu = 2;

switch (menu) {
    case 1:
        printf("커피\n");
        break;
    case 2:
        printf("차\n");
        break;
    default:
        printf("잘못된 선택\n");
        break; // 관례상 default에도 break
}
```

- **`break` 필수**: 누락 시 **fallthrough**(아래 case로 흐름이 계속) 발생.
- `default`는 선택적이나 **권장**(예외 케이스 명시).

### 2.2 의도적인 fallthrough는 주석/속성으로 표시
```c
switch (c) {
    case 'A':
        bonus += 10;
        /* fallthrough */   // GCC/Clang 분석기 힌트
    case 'B':
        bonus += 5;
        break;
    default:
        break;
}
```
> 일부 컴파일러/표준에서는 `[[fallthrough]];`(지원 여부 확인) 또는 `__attribute__((fallthrough))` 사용.

### 2.3 `enum`과 함께 쓰기(가독성/검사 향상)
```c
typedef enum { ST_INIT, ST_RUN, ST_STOP } State;
State st = ST_INIT;

switch (st) {
    case ST_INIT: /* ... */ break;
    case ST_RUN:  /* ... */ break;
    case ST_STOP: /* ... */ break;
    default: /* 미처리 상태 경고용 */ break;
}
```

### 2.4 `switch` vs if-else
- **분기 수가 많고** 값 비교일 때 `switch` 선호.
- 범위 비교(예: `0 <= x && x < 10`)는 `if-else`가 간단.

---

## 3. 반복문 — while / for / do-while

### 3.1 `while` — 조건을 먼저 본다
```c
int i = 0;
while (i < 5) {
    printf("%d\n", i);
    i++;
}
```

- 진입 전에 조건 검사 → **0회** 실행 가능.

### 3.2 `for` — 카운터/컬렉션 인덱스에 최적
```c
for (int i = 0; i < 5; ++i) {
    printf("%d\n", i);
}
```

- C99부터 초기 선언 가능(`-std=c99` 이상).
- **오프바이원** 방지: `i < n` vs `i <= n-1` 동일 의미지만 전자를 선호.

#### 복합 초기화/증감
```c
for (int i = 0, j = n-1; i < j; ++i, --j) {
    // 양끝에서 가운데로 수렴
}
```

### 3.3 `do-while` — 최소 1회 실행
```c
int i = 0;
do {
    printf("%d\n", i);
    i++;
} while (i < 5);
```

- **세미콜론** `while (cond);` 필수(누락 주의).

### 3.4 무한 루프와 안전 탈출
```c
for (;;) {           // while(1)과 동일
    int cmd = read_cmd();
    if (cmd == QUIT) break;
    handle(cmd);
}
```

- 바쁜 대기(busy-wait) 루프는 CPU 점유 위험 → 입출력 대기/슬립/이벤트 사용 고려.

---

## 4. `break` / `continue` — 반복 제어

```c
for (int i = 0; i < 5; ++i) {
    if (i == 2) continue; // 2는 출력 생략
    if (i == 4) break;    // 4부터 중단
    printf("%d\n", i);    // 0, 1, 3
}
```

### 4.1 중첩 루프에서의 탈출
- C에는 **라벨드 break**가 없습니다(Java와 다름). 대안:
  1) **플래그 변수**로 외부 루프 종료 유도
  2) **`goto`** (합리적 사용; 논쟁 여지 있으나 실무에서 가끔 유용)
```c
int found = 0;
for (int i = 0; i < N && !found; ++i) {
    for (int j = 0; j < M; ++j) {
        if (A[i][j] == target) { found = 1; break; }
    }
}
```
```c
for (int i = 0; i < N; ++i) {
    for (int j = 0; j < M; ++j) {
        if (A[i][j] == target) goto OUT;
    }
}
OUT: /* 정리/후처리 */
```

### 4.2 `switch`가 루프 안에 있을 때의 `continue`
- `continue`는 **`switch`를 건너뛰는 것이 아니라 “루프의 다음 반복으로”** 이동합니다.
```c
for (int i = 0; i < 5; ++i) {
    switch (i) {
        case 2: /* ... */ continue; // for의 다음 반복으로
        default: break;
    }
    // i==2이면 이 줄은 실행되지 않음
}
```

---

## 5. 입력 검증/메뉴 루프 — 실전 스켈레톤

```c
#include <stdio.h>

static void show_menu(void) {
    puts("1) add");
    puts("2) sub");
    puts("0) quit");
}

int main(void) {
    int sel;
    for (;;) {
        show_menu();
        printf("> ");
        if (scanf("%d", &sel) != 1) {
            // 입력 스트림 정리
            int ch; while ((ch = getchar()) != '\n' && ch != EOF) {}
            puts("숫자를 입력하세요.");
            continue;
        }
        switch (sel) {
            case 1: puts("add..."); break;
            case 2: puts("sub..."); break;
            case 0: puts("bye");    goto END; // 또는 break; 후 if로 종료
            default: puts("잘못된 선택");
        }
    }
END:
    return 0;
}
```

> 보안/안전성 측면에서는 `scanf`보다 `fgets`+파싱(`strtol`)이 일반적으로 안전합니다.

---

## 6. 알고리즘 루프 예제 모음

### 6.1 합/평균(정수 나눗셈 주의)
```c
int sum = 0;
for (int i = 1; i <= 100; ++i) sum += i;
double avg = (double)sum / 100.0; // 캐스팅으로 실수 나눗셈
```

수식 검증:
$$
1 + 2 + \cdots + n = \frac{n(n+1)}{2}
$$

### 6.2 최대공약수(GCD) — 유클리드 반복
```c
int gcd(int a, int b) {
    while (b != 0) {
        int r = a % b;
        a = b; b = r;
    }
    return a;
}
```

### 6.3 소수 판별 — 루트 n 까지
```c
#include <math.h>
int is_prime(int n) {
    if (n < 2) return 0;
    for (int i = 2; i*i <= n; ++i) {
        if (n % i == 0) return 0;
    }
    return 1;
}
```

### 6.4 FizzBuzz — 분기/나머지/continue
```c
for (int i = 1; i <= 100; ++i) {
    if (i % 15 == 0) { puts("FizzBuzz"); continue; }
    if (i % 3  == 0) { puts("Fizz");     continue; }
    if (i % 5  == 0) { puts("Buzz");     continue; }
    printf("%d\n", i);
}
```

---

## 7. 경계·함정·성능 팁

### 7.1 오프바이원(Off-by-one)
- `i < n` vs `i <= n-1` → 전자 선호(명료).

### 7.2 루프 변수의 **타입/부호** 일치
```c
size_t n = get_len();
for (size_t i = 0; i < n; ++i) { /* ... */ } // 부호 혼합 경고 줄이기
```

### 7.3 루프 내부에서 조건/비용 줄이기
- 불변 값은 루프 밖으로 호이스팅(컴파일러가 대체로 해줌).
- 분기 예측: 흔한 경로 먼저 배치.

### 7.4 `do-while`의 세미콜론
```c
do { work(); } while (cond); // <- 세미콜론 필수
```

### 7.5 잘못된 빈문장
```c
while (i < n);   // ← 여기 세미콜론 때문에 루프 본문이 비어있음(버그)
    i++;         // 루프 밖에서 1번만 실행
```

---

## 8. 미니 프로젝트: 간단한 토큰 스캐너(state machine with switch)

요구: 공백으로 구분된 정수/기호를 읽어서 줄 단위로 토큰화해 출력.
- `if/else`와 `switch`를 섞어 상태 전이를 구현한다.
- 루프 제어(`break/continue`), 입력 검증, 경계 처리 포함.

```c
#include <stdio.h>
#include <ctype.h>

typedef enum { S_INIT, S_NUM, S_SYM } State;

int main(void) {
    State st = S_INIT;
    int ch;
    int num = 0, has_num = 0;

    while ((ch = getchar()) != EOF) {
        switch (st) {
        case S_INIT:
            if (isdigit(ch)) {
                st = S_NUM;
                num = ch - '0';
                has_num = 1;
            } else if (isspace(ch)) {
                if (ch == '\n') puts(""); // 줄 구분
                // 공백은 무시
            } else {
                st = S_SYM;
                putchar(ch);
                putchar(' ');
                st = S_INIT;
            }
            break;

        case S_NUM:
            if (isdigit(ch)) {
                num = num * 10 + (ch - '0');
            } else {
                printf("%d ", num);
                has_num = 0;
                st = S_INIT;
                // 현재 문자는 다시 해석
                if (isspace(ch)) {
                    if (ch == '\n') puts("");
                } else {
                    putchar(ch);
                    putchar(' ');
                }
            }
            break;

        case S_SYM:
            // 본 예제에서는 한 글자 기호만 처리하므로 바로 INIT로 이동
            st = S_INIT;
            break;
        }
    }
    if (has_num) printf("%d", num);
    return 0;
}
```

입력:
```
123 + 7
```
출력(한 줄):
```
123 + 7
```

---

## 9. 테스트 체크리스트(제어문 관점)

- 모든 분기(`if/else`/`switch`) **각 케이스 최소 1회** 커버.
- `for/while/do-while`에서 **0회/1회/여러 회** 모두 검증.
- 중첩 루프 탈출 경로(정상 종료, `break`, 예외 경로) 검증.
- 경계값: 빈 입력, 매우 큰 반복 수, 음수/0/양수 조건 분리.

---

## 10. 요약

| 문법 | 핵심 |
|------|------|
| `if ~ else if ~ else` | 논리 단락 평가, 괄호/중괄호로 의도 명확화 |
| `switch` | `break` 필수, `default` 권장, enum과 궁합 좋음 |
| `while` | 선조건 검사, 0회 가능 |
| `for` | 카운터/인덱스 루프 표준형, 오프바이원 주의 |
| `do-while` | 최소 1회 실행, 세미콜론 필수 |
| `break/continue` | 루프 제어; `switch`+루프 혼용 시 의미 재확인 |
