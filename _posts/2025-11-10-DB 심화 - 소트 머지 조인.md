---
layout: post
title: DB 심화 - 소트 머지 조인
date: 2025-11-10 17:25:23 +0900
category: DB 심화
---
# 소트 머지 조인(Sort Merge Join, SMJ) 완전 정리 (Oracle)

소트 머지 조인(Sort Merge Join, 이하 SMJ)은 **“정렬 → 병합 스캔”**이라는 단순한 아이디어로,  
대용량/범위(비등치) 조인에서 여전히 매우 중요한 조인 방식이다.

---

## 0. 공통 세션 설정 및 기본 개념

```sql
ALTER SESSION SET nls_date_format           = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level          = ALL;          -- ALLSTATS LAST
ALTER SESSION SET optimizer_features_enable = '19.1.0';     -- 환경에 맞게 (19c 기준 예시)
ALTER SESSION SET workarea_size_policy      = AUTO;         -- 소트/해시 작업 메모리 자동 관리
```

- `statistics_level = ALL`  
  실행 후 `DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')`로  
  **행 수 / 버퍼 / 물리 I/O / PGA 사용량 / TEMP 사용량**까지 모두 확인할 수 있게 하는 설정이다.
- `workarea_size_policy = AUTO`  
  정렬·해시 작업(워크에어리어)을 **PGA 집합 타깃** 기준으로 자동 관리하도록 한다.

간단한 비용 감각:

- SMJ에서 핵심은  
  1) 두 입력을 **조인 키 기준으로 정렬**하는 비용  
  2) 정렬된 두 스트림을 **순차 스캔하며 병합**하는 비용
- 전체 비용을 매우 단순화하면:

  $$
  \text{Cost}_{SMJ} \approx
  \text{Cost}_{Sort(left)} +
  \text{Cost}_{Sort(right)} +
  \text{Cost}_{MergeScan}
  $$

  여기서 `MergeScan`은 대개 **순차 스캔** 위주이므로 비교적 예측 가능하고 안정적이다.  
  반대로, 정렬 비용은 **PGA/TEMP** 상황에 따라 크게 달라진다.

---

## 1. 실습용 데이터 모델

기본 조인 구조는 다음과 같다.

- CUST: 고객
- ORD: 주문 헤더
- OI: 주문 상세
- PROMO: 프로모션 기간 (비등치·범위 조인용)

```sql
-- 고객
DROP TABLE CUST PURGE;
CREATE TABLE CUST (
  CUST_ID  NUMBER       PRIMARY KEY,
  REGION   VARCHAR2(6)  NOT NULL
);

-- 주문 헤더(왼편에서 자주 사용)
DROP TABLE ORD PURGE;
CREATE TABLE ORD (
  ORDER_ID NUMBER       PRIMARY KEY,
  CUST_ID  NUMBER       NOT NULL,
  ORDER_DT DATE         NOT NULL,
  STATUS   VARCHAR2(8)  NOT NULL
);

-- 주문 상세(오른편에서 조인)
DROP TABLE OI PURGE;
CREATE TABLE OI (
  ORDER_ID NUMBER       NOT NULL,
  ITEM_NO  NUMBER       NOT NULL,
  PROD_ID  NUMBER       NOT NULL,
  QTY      NUMBER       NOT NULL,
  AMOUNT   NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY (ORDER_ID, ITEM_NO)
);

-- 프로모션(비등치 조인 예시: 주문일이 프로모션 기간에 속하면 매칭)
DROP TABLE PROMO PURGE;
CREATE TABLE PROMO (
  PROMO_ID   NUMBER       PRIMARY KEY,
  START_DT   DATE         NOT NULL,
  END_DT     DATE         NOT NULL,
  CATEGORY   VARCHAR2(10) NOT NULL
);
```

인덱스 및 데이터 로딩:

```sql
-- 인덱스
CREATE INDEX IX_ORD_CDT     ON ORD(CUST_ID, ORDER_DT, ORDER_ID);
CREATE INDEX IX_OI_ORDER    ON OI(ORDER_ID, ITEM_NO);
CREATE INDEX IX_PROMO_RANGE ON PROMO(START_DT, END_DT);  -- 범위 조인 데모용(전략 다양)

-- 샘플 데이터 로딩 (규모는 환경에 맞게)
BEGIN
  FOR c IN 1..50000 LOOP
    INSERT INTO CUST VALUES (c,
      CASE MOD(c,3)
           WHEN 0 THEN 'APAC'
           WHEN 1 THEN 'EMEA'
           ELSE        'AMER'
      END
    );
  END LOOP;

  FOR o IN 1..300000 LOOP
    INSERT INTO ORD VALUES (
      o,
      MOD(o,50000)+1,
      DATE '2024-01-01' + MOD(o,540),
      CASE MOD(o,4)
           WHEN 0 THEN 'NEW'
           WHEN 1 THEN 'PAID'
           WHEN 2 THEN 'SHIP'
           ELSE        'DONE'
      END
    );
  END LOOP;

  FOR x IN 1..300000 LOOP
    INSERT INTO OI VALUES (
      x, 1, MOD(x,20000)+1,
      TRUNC(DBMS_RANDOM.VALUE(1,5)),
      ROUND(DBMS_RANDOM.VALUE(10,2000),2)
    );
    IF MOD(x,3)=0 THEN
      INSERT INTO OI VALUES (
        x, 2, MOD(x+7,20000)+1,
        TRUNC(DBMS_RANDOM.VALUE(1,5)),
        ROUND(DBMS_RANDOM.VALUE(10,2000),2)
      );
    END IF;
  END LOOP;

  FOR p IN 1..5000 LOOP
    INSERT INTO PROMO VALUES (
      p,
      DATE '2024-01-01' + (p*2),         -- 겹치기도 하고 비는 날도 있게
      DATE '2024-01-01' + (p*2) + 10,
      CASE MOD(p,4)
           WHEN 0 THEN 'ELEC'
           WHEN 1 THEN 'FASH'
           WHEN 2 THEN 'FOOD'
           ELSE        'HOME'
      END
    );
  END LOOP;
  COMMIT;
END;
/
```

통계 수집:

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'CUST',
    cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'ORD',
    cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'OI',
    cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'PROMO',
    cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

이제부터 모든 예제는 이 스키마 위에서 돌아간다고 가정한다.

---

## 2. 소트 머지 조인 기본 메커니즘

### 2.1 직관적 동작

SMJ는 **두 입력을 조인 키 기준으로 정렬**한 뒤,  
**정렬된 두 스트림을 병합 스캔**하면서 매칭되는 행을 찾아낸다.

1. **왼쪽(first) 입력**을 조인 키 기준으로 정렬
2. **오른쪽(second) 입력**을 동일 키 기준으로 정렬
3. 두 정렬된 스트림을 한 번씩 스캔하면서 키를 비교
   - 왼쪽 키 < 오른쪽 키 → 왼쪽 행 이동
   - 왼쪽 키 > 오른쪽 키 → 오른쪽 행 이동
   - 같으면(등치 조인) 해당 키 구간의 카티시안 결합 출력

등치 조인 의사 코드(개념):

```text
i ← 첫째 입력의 첫 행, j ← 둘째 입력의 첫 행
while i, j 둘 다 끝나지 않았다:
  if i.key < j.key:
    i ← 다음
  elif i.key > j.key:
    j ← 다음
  else:  -- i.key == j.key
    동일한 키 구간을 모두 출력(카티시안 in-key 구간)
    i, j 각각 다음 키 구간으로 이동
```

### 2.2 해시/NL과의 비교

- **Nested Loops Join(NL)**  
  한쪽(Outer)에서 한 행씩 뽑아 다른 쪽(Inner)을 인덱스로 찾는 구조.  
  소량 Outer + 잘 정렬된 인덱스가 있을 때 탁월하지만, 대량 Outer에서 랜덤 I/O 폭발 위험.
- **Hash Join**  
  한 입력(Build)을 메모리(또는 디스크)에 해시 테이블로 만들고,  
  다른 입력(Probe)의 각 키로 해시 탐색. **등치 조인에 최적화**.
- **Sort Merge Join**  
  정렬 비용이 들지만, 정렬만 끝나면 **순차 스캔**으로 병합.  
  **비등치 조인(범위, BETWEEN)**까지 자연스럽게 다루는 게 큰 장점.

대략적 비용 비교(등치 조인 기준, 매우 단순화):

- NL:  
  $$
  \text{Cost}_{NL} \approx \text{Outer Rows} \times \text{Cost}_{Inner Lookup}
  $$
- Hash Join:  
  $$
  \text{Cost}_{HJ} \approx \text{Cost}_{Build} + \text{Cost}_{Probe}
  $$
- Sort Merge Join:  
  $$
  \text{Cost}_{SMJ} \approx \text{Cost}_{Sort(left)} +
  \text{Cost}_{Sort(right)} + \text{Cost}_{MergeScan}
  $$

---

## 3. SMJ의 실행 계획 패턴 읽기

### 3.1 기본 등치 조인 예제

```sql
-- 고객의 주문(헤더)과 주문상세를 ORDER_ID로 조인
-- SMJ 강제: USE_MERGE
SELECT /*+ LEADING(o) USE_MERGE(i) FULL(o) FULL(i) */
       o.order_id, o.cust_id, i.item_no, i.amount
FROM   ORD o
JOIN   OI  i
  ON   i.order_id = o.order_id
WHERE  o.status = 'PAID';

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')
);
```

예상되는 주요 연산자(요지):

- `SORT JOIN` (ORD)
- `SORT JOIN` (OI)
- `MERGE JOIN`

`ALLSTATS LAST`에서 봐야 할 핵심:

- 각 정렬 단계의
  - `A-Rows` (실제 정렬된 행 수)
  - `Buffers`, `Read Requests` (논리/물리 I/O)
  - `TempSpc` (MB) – **정렬이 TEMP를 얼마나 썼는지**
- `MERGE JOIN` 단계의 `A-Rows` – 조인 결과 크기

메모리 측면에서:

- `workarea_size_policy = AUTO` 환경에서  
  **정렬에 필요한 메모리 요구량 > 세션이 할당받은 PGA 워크에어리어**이면
  - **1-pass sort** 또는 **multi-pass sort**로 전환
  - 이때 `TempSpc` 사용량과 물리 I/O가 증가한다.

---

## 4. SMJ의 특징 (장점/단점, 메모리·TEMP 관점)

### 4.1 장점

1. **대용량에서 안정적인 성능**
   - 큰 테이블끼리의 조인에서, 정렬만 끝나면 나머지는 **순차 스캔**이라 I/O 패턴이 예측 가능하다.
2. **비등치(범위) 조인 자연 지원**
   - `A.key BETWEEN B.start_key AND B.end_key` 같은 패턴을  
     비교적 자연스럽게 처리할 수 있다.
3. **이미 정렬된 스트림/인덱스를 활용 가능**
   - 한쪽 또는 양쪽이 조인 키로 **이미 정렬**되어 있으면 `SORT JOIN`을 생략할 수 있다.
4. **배치/집계형 쿼리와 궁합**
   - “전 기간/대량 범위” 집계에서는 조기 종료가 어려우므로, SMJ의 정렬 비용이 상대적으로 감당 가능하다.

### 4.2 단점·주의사항

1. **정렬 비용이 크다**
   - 양쪽 모두에 정렬이 필요하면 정렬량이 큼.
   - PGA가 부족하면 TEMP를 써야 하며, 이는 곧 디스크 I/O 증가를 의미.
2. **Top-N/부분범위 처리에는 부적합**
   - 결과의 일부만 빨리 보고 싶을 때, NL이 훨씬 유리할 수 있다.
3. **해시 조인보다 느린 경우**
   - 등치 조인에서, 충분한 메모리로 해시 조인이 수행되면  
     SMJ보다 해시 조인이 더 빠른 경우가 많다.
4. **인덱스 정렬 대체의 양날의 검**
   - 인덱스 스캔으로 정렬을 대체할 수 있지만, 인덱스가 테이블 물리 순서와 맞지 않으면  
     **랜덤 I/O**를 유발하여 오히려 느려질 수 있다.

---

## 5. first(왼쪽) 입력의 정렬을 인덱스 스캔으로 대체하기

핵심 아이디어:

- SMJ에서 왼쪽 입력에 대해 필요한 정렬이  
  **“해당 인덱스 스캔의 출력 순서”와 동일**하다면,  
  `SORT JOIN`을 수행하는 대신 **인덱스 스캔 결과를 그대로 사용**할 수 있다.

### 5.1 케이스 A – 왼쪽만 인덱스로 정렬 대체

조건:

- 조인 키가 `ORDER_ID`.
- `ORD` 테이블의 PK가 `ORDER_ID`이므로, PK 기반 `INDEX FULL SCAN`은  
  `ORDER_ID` 순서를 보장한다.

```sql
-- 왼쪽(ORD)을 PK로 정렬 대체
SELECT /*+ LEADING(o) USE_MERGE(i)
           INDEX_ASC(o)     -- PK(ORDER_ID) 순으로
           FULL(i) */       -- 오른쪽은 전체 정렬
       o.order_id, o.cust_id, i.item_no, i.amount
FROM   ORD o
JOIN   OI  i
  ON   i.order_id = o.order_id
WHERE  o.status = 'PAID';

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')
);
```

계획에서 확인:

- 왼쪽에 `SORT JOIN`이 사라지고, `INDEX FULL SCAN` 또는 `INDEX RANGE SCAN`이 나타나는지.
- `TempSpc`에서 왼쪽 정렬의 TEMP 사용량이 사라졌는지.
- 대신 `Buffers`가 얼마나 늘었는지(인덱스 + 테이블 랜덤 I/O).

주의:

- PK 인덱스 스캔은 **인덱스 순서**로 테이블 블록을 랜덤 방문할 수 있다.
- **클러스터링 팩터**가 나쁘면 Buffers/Reads가 커질 수 있다.

### 5.2 케이스 B – 양쪽 모두 인덱스로 정렬 대체

OI도 `ORDER_ID`가 PK 선두이면, 이론적으로 오른쪽도 인덱스로 정렬 대체 가능하다.

```sql
SELECT /*+ LEADING(o) USE_MERGE(i)
           INDEX_ASC(o) INDEX_ASC(i) */
       o.order_id, o.cust_id, i.item_no, i.amount
FROM   ORD o
JOIN   OI  i
  ON   i.order_id = o.order_id
WHERE  o.status = 'PAID';

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')
);
```

비교 포인트:

- 양쪽 모두 `SORT JOIN`이 사라지는지.
- TEMP 사용량이 확 줄었는지.
- 대신 인덱스 기반 랜덤 I/O가 얼마나 늘었는지.

실전 요령:

- 양쪽 정렬 대체가 항상 이득은 아니다.
- 다음 식을 염두에 두고 실측하자.

  $$
  \text{이득 여부} \approx
  (\text{줄어든 TEMP I/O} + \text{줄어든 정렬 CPU}) -
  (\text{늘어난 랜덤 I/O})
  $$

---

## 6. first 집합이 이미 정렬된 경우: 파이프라인 정렬 재사용

실무에서 자주 나오는 패턴:

- 어떤 서브쿼리에서 `ORDER BY key`로 이미 정렬된 집합을 만들고,
- 그 결과를 그대로 SMJ의 왼쪽 입력으로 공급하고 싶다.

```sql
-- 왼쪽 서브쿼리에서 ORDER_ID 기준 정렬된 결과를 만들고,
-- 그 흐름을 그대로 SMJ 왼쪽에 공급
SELECT /*+ USE_MERGE(i) */
       o2.order_id, o2.cust_id, i.item_no, i.amount
FROM  (
        SELECT /*+ FULL(o) */
               o.order_id, o.cust_id
        FROM   ORD o
        WHERE  o.status = 'PAID'
        ORDER  BY o.order_id  -- 이미 정렬
      ) o2
JOIN  OI i
  ON  i.order_id = o2.order_id;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')
);
```

옵티마이저가 서브쿼리 정렬을 **SMJ 왼쪽 SORT JOIN과 통합**할 수 있다면:

- 불필요한 중복 정렬이 제거된다.
- 계획 상  
  - 서브쿼리에서 `SORT ORDER BY`가 남아있고  
  - 상위에서 별도의 `SORT JOIN`이 사라지거나  
  - 혹은 서브쿼리가 **인라인 뷰 머지**되어 전체적으로 한 번만 정렬하는 형태로 나올 수 있다.

이런 패턴은 다음과 같은 상황에서 특히 유용하다.

- 윈도 함수/집계 결과를 정렬해 놓고, 그 결과를 다른 테이블과 조인
- 파티션 스캔 후 파티션 내 정렬을 재사용해서 조인

---

## 7. 비등치(범위/밴드) 조인에서의 소트 머지 조인

해시 조인은 원칙적으로 **등치 조인**에 최적화되어 있다.  
비등치 조인을 직접 처리하려면 내부적으로 범위를 분리하거나 다른 전략이 필요하다.

SMJ는 두 입력을 **범위 조건과 호환되는 정렬 기준**으로 정렬함으로써  
비등치 조인을 자연스럽게 다룰 수 있다.

### 7.1 기본 범위 조인 예: 주문일이 프로모션 기간에 속하면 매칭

```sql
-- 주문일이 PROMO(START_DT..END_DT)에 속하면 매칭
-- SMJ 강제 + 정렬 전략
SELECT /*+ LEADING(o) USE_MERGE(p) FULL(o) FULL(p) */
       o.order_id, o.order_dt, p.promo_id, p.category
FROM   ORD   o
JOIN   PROMO p
  ON   o.order_dt BETWEEN p.START_DT AND p.END_DT
WHERE  o.status = 'PAID';

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')
);
```

메커니즘(개념):

1. `ORD`를 `ORDER_DT` 기준으로 정렬  
2. `PROMO`를 `START_DT` 또는 `END_DT` 기준으로 정렬  
3. 병합 단계에서 각 `PROMO` 기간 범위에 해당하는 `ORD` 행들을 스캔

실제 구현은 더 복잡하지만, 요지는:

- 범위 조인도 **정렬된 두 스트림** 위에서 **한 번의 병합 패스**로 처리할 수 있다는 것.

해시 조인 강제 시:

```sql
-- 해시 조인 시도 — 비등치에서는 비효율적이거나 다른 내부 변형 필요
SELECT /*+ LEADING(o) USE_HASH(p) FULL(o) FULL(p) */
       COUNT(*)
FROM   ORD o
JOIN   PROMO p
  ON   o.order_dt BETWEEN p.start_dt AND p.end_dt
WHERE  o.status = 'PAID';
```

- 대개 SMJ보다 불리하거나, 옵티마이저가 다른 전략으로 바꾸어 버린다.

### 7.2 인덱스로 정렬 대체 (범위 조인의 한쪽)

왼쪽 입력(ORD)에 `ORDER_DT` 선두 인덱스가 있다면:

```sql
-- 개념 예시(인덱스 IX_ORD_DTO(ORDER_DT, ORDER_ID)이 있다고 가정)
-- CREATE INDEX IX_ORD_DTO ON ORD(ORDER_DT, ORDER_ID);

SELECT /*+ LEADING(o) USE_MERGE(p)
           INDEX_ASC(o /*IX_ORD_DTO*/) FULL(p) */
       o.order_id, o.order_dt, p.promo_id, p.category
FROM   ORD   o
JOIN   PROMO p
  ON   o.order_dt BETWEEN p.start_dt AND p.end_dt
WHERE  o.status = 'PAID';
```

- 왼쪽의 `SORT JOIN`을 없애고 인덱스 스캔으로 대체할 수 있다.
- 오른쪽(PROMO)은 여전히 정렬이 필요할 수 있으며,  
  (START_DT, END_DT) 복합 인덱스를 쓸지, 파티션 프루닝을併用할지 등은 상황에 따라 다르다.

비등치/범위 조인에서의 핵심 요령:

1. **SMJ 우선 고려**  
   범위/기간 매핑 문제는 SMJ의 강점 영역이다.
2. 정렬량을 줄이는 방법
   - 기간을 미리 좁히는 WHERE 조건
   - 파티셔닝 + 파티션 프루닝
   - 인덱스 기반 정렬 대체
3. `ALLSTATS LAST`로 정렬의 `TempSpc`, `Buffers`, `Elapsed`를 반드시 확인

---

## 8. 밴드 조인(band join) 예시와 주의사항

밴드 조인 예:

- `A.key`와 `B.key`의 차이가 일정 범위 안에 있을 때만 매칭

```sql
-- 밴드 조인 예: 주문 금액이 특정 기준 금액 주변의 밴드 내에 있을 때 매칭 (예시용)
-- 실제로는 금액이 아니라 날짜/시간축 밴드가 더 흔하다.

-- 보조 테이블: 기준 금액 구간
DROP TABLE THRESH PURGE;
CREATE TABLE THRESH (
  ID      NUMBER PRIMARY KEY,
  AMT_MIN NUMBER NOT NULL,
  AMT_MAX NUMBER NOT NULL
);

BEGIN
  INSERT INTO THRESH VALUES (1,  0,  1000);
  INSERT INTO THRESH VALUES (2,1000,  5000);
  INSERT INTO THRESH VALUES (3,5000, 20000);
  COMMIT;
END;
/

-- OI.amount가 THRESH의 밴드에 속하는 주문 상세 찾기
SELECT /*+ USE_MERGE(t) FULL(i) FULL(t) */
       i.order_id, i.item_no, i.amount, t.id AS band_id
FROM   OI i
JOIN   THRESH t
  ON   i.amount BETWEEN t.amt_min AND t.amt_max;
```

병합 조인 메커니즘:

- `OI`를 `amount` 기준 정렬
- `THRESH`를 `amt_min`/`amt_max` 기준 정렬
- 스캔하면서 각 밴드에 해당하는 행들을 매칭

주의:

- 밴드가 넓고 중첩이 많을수록, 조인 결과가 매우 커질 수 있다.
- 조인 결과의 상한은 다음과 같이 생각할 수 있다.

  $$
  |A \bowtie_{band} B| \le
  \sum_{b \in B}
  (\text{A에서 b 범위에 들어오는 행 수})
  $$

- 밴드 조인은 일반적으로 **카디널리티 추정이 어렵고**,  
  옵티마이저가 보수적으로 잡으면 SMJ/해시 모두 비용을 크게 잡을 수 있다.

---

## 9. 힌트로 소트 머지 조인 제어하기

### 9.1 핵심 힌트

- `/*+ USE_MERGE(t) */`  
  테이블 t를 대상으로 SMJ 사용 유도.
- `/*+ NO_USE_NL(t) NO_USE_HASH(t) */`  
  t와의 조인에서 NL/HJ를 배제하여 SMJ를 강하게 유도.
- `/*+ ORDERED */` 또는 `/*+ LEADING(a b c) */`  
  조인 입력 순서를 고정하여 **왼쪽/오른쪽**을 제어.
- `/*+ FULL(t) */`  
  정렬 전에 **Full Scan**을 유도.
- `/*+ INDEX_ASC(t idx) */`, `/*+ INDEX_DESC(t idx) */`  
  이 인덱스 순서를 이용해 정렬을 대체.
- `/*+ PARALLEL(t n) */`  
  대용량 정렬/병합에 병렬 수행을 적용.

힌트 조합 예:

```sql
-- ORD ↔ OI 등치 조인을 SMJ로 고정하고,
-- 왼쪽은 PK(ORDER_ID) 인덱스, 오른쪽은 Full Scan 사용
SELECT /*+ LEADING(o) USE_MERGE(i)
           INDEX_ASC(o) FULL(i)
           NO_USE_HASH(i) NO_USE_NL(i) */
       o.order_id, o.cust_id, i.item_no, i.amount
FROM   ORD o
JOIN   OI  i
  ON   i.order_id = o.order_id
WHERE  o.status = 'PAID';
```

### 9.2 파라미터/환경 이슈 (개념적 이해용)

- SMJ 선호도는 옵티마이저 버전·파라미터에 따라 조금씩 달라질 수 있다.
- 일반적으로:
  - 메모리가 넉넉하면 **해시 조인** 선호
  - 범위/비등치 조인이 있으면 **SMJ** 쪽이 더 매력적

따라서 SMJ를 일관되게 사용하려면:

- **힌트** 또는 **SQL Plan Management**(Plan Baseline)를 사용해 안정화하는 편이 좋다.

---

## 10. 실전 튜닝 절차 – SMJ vs Hash vs NL

### 10.1 비교 실습 세트

```sql
-- A) 양쪽 정렬(베이스라인)
SELECT /*+ LEADING(o) USE_MERGE(i) FULL(o) FULL(i) */
       o.order_id, i.item_no
FROM   ORD o JOIN OI i
ON     i.order_id = o.order_id
WHERE  o.status = 'PAID';

-- B) 왼쪽 정렬 대체(ORDER_ID PK 순서)
SELECT /*+ LEADING(o) USE_MERGE(i) INDEX_ASC(o) FULL(i) */
       o.order_id, i.item_no
FROM   ORD o JOIN OI i
ON     i.order_id = o.order_id
WHERE  o.status = 'PAID';

-- C) 양쪽 정렬 대체(가능시)
SELECT /*+ LEADING(o) USE_MERGE(i) INDEX_ASC(o) INDEX_ASC(i) */
       o.order_id, i.item_no
FROM   ORD o JOIN OI i
ON     i.order_id = o.order_id
WHERE  o.status = 'PAID';

-- 실행 후 각각:
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')
);
```

비교할 항목:

- `SORT JOIN` 단계의 존재 여부
- 각 쿼리의 `TempSpc` (MB)
- `Buffers`, `Read Requests`, `Elapsed`
- 인덱스 기반 랜덤 I/O 증가 여부

### 10.2 “이미 정렬된 파이프라인” 재사용 예 다시 보기

```sql
WITH O_SORT AS (
  SELECT /*+ FULL(o) */
         o.order_id
  FROM   ORD o
  WHERE  o.order_dt >= DATE '2024-06-01'
  ORDER  BY o.order_id
)
SELECT /*+ USE_MERGE(i) */
       s.order_id, i.item_no, i.amount
FROM   O_SORT s
JOIN   OI     i
  ON   i.order_id = s.order_id;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')
);
```

- `O_SORT`에서 이미 한 번 정렬한 것을  
  SMJ에서 재사용하는지 확인.
- “정렬이 중복되어 있지 않은가?”가 핵심 체크 포인트.

### 10.3 SMJ vs Hash Join 수치 비교

동일 조인에 대해:

```sql
-- SMJ
SELECT /*+ LEADING(o) USE_MERGE(i) FULL(o) FULL(i) */
       COUNT(*)
FROM   ORD o
JOIN   OI  i
  ON   i.order_id = o.order_id
WHERE  o.status = 'PAID';

-- 해시 조인
SELECT /*+ LEADING(o) USE_HASH(i) FULL(o) FULL(i) */
       COUNT(*)
FROM   ORD o
JOIN   OI  i
  ON   i.order_id = o.order_id
WHERE  o.status = 'PAID';

-- 두 쿼리를 각각 실행한 뒤
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')
);
```

- `Buffers`, `Read Requests`, `TempSpc`(정렬 vs 해시), `PGA` 사용량 비교
- 대체로:
  - 등치 조인 + 충분한 메모리 → 해시 조인이 유리한 경우 많음
  - 비등치 조인 → SMJ 우위

---

## 11. 메모리·TEMP 관점에서의 SMJ 이해

정렬(소트)은 워크에어리어(Workarea)에서 이루어지며,  
Oracle은 대략 다음과 같이 동작한다(개념):

1. 각 정렬 작업마다 “필요 메모리 요구량”을 계산
2. `workarea_size_policy = AUTO` 에 따라
   - “최적치” 만큼 PGA를 할당하려 시도
3. 실제 할당된 메모리가 “필요량”보다 충분하면:
   - **optimal sort** – TEMP 없이 메모리 내에서 정렬 완료
4. 부족하면:
   - **one-pass sort** 또는 **multi-pass sort** –  
     일부 데이터를 TEMP에 쓰고, 다시 읽으면서 정렬

정렬 비용을 단순화하면:

- 메모리 내 정렬:

  $$
  \text{Cost}_{sort}^{in\text{-}memory}
  \approx
  c_1 \cdot n \log n
  $$

- 디스크를 사용하는 정렬:

  $$
  \text{Cost}_{sort}^{disk}
  \approx
  c_1 \cdot n \log n + c_2 \cdot n\_\text{disk\_reads} + c_3 \cdot n\_\text{disk\_writes}
  $$

여기서 `c_2, c_3`는 디스크 I/O 비용 계수로,  
PGA가 부족할수록 `n_disk_reads`, `n_disk_writes`가 증가한다.

실무적으로는 `MEMSTATS` 정보에서:

- `Optimal` / `Onepass` / `Multipass`  
- 각 단계의 `TempSpc` 사용량(MB)  
을 보고 판단한다.

---

## 12. 실무 체크리스트

SMJ를 선택/튜닝할 때 다음 체크리스트를 사용하는 것이 좋다.

1. **조인 메소드 후보 선정**
   - 등치/비등치 여부
   - 양쪽 데이터량
   - 정렬/Top-N/부분범위 요구사항
   - OLTP/OLAP 패턴
2. **정렬량/정렬 비용 가늠**
   - `ALLSTATS LAST + MEMSTATS`로 `TempSpc`와 sort pass 확인
   - 파티션 프루닝, 서브쿼리 재사용으로 정렬 대상 줄일 수 있는지
3. **정렬 대체(인덱스/이미 정렬된 스트림)**
   - 한쪽 또는 양쪽 조인 키 선두 인덱스로 정렬 대체 가능한지
   - 인덱스 스캔 I/O vs 정렬 I/O를 비교(숫자로)
4. **비등치/범위 조인**
   - 기간 매핑/밴드 조인이라면 SMJ 우선 고려
   - 조인 조건을 SARGable하게 유지(불필요한 함수 적용 지양)
5. **플랜 안정화**
   - 힌트: `USE_MERGE`, `NO_USE_HASH`, `NO_USE_NL`, `LEADING`, `ORDERED`
   - SQL Plan Management로 정상 플랜을 baseline으로 고정
6. **PGA/TEMP 자원**
   - `pga_aggregate_target`, `pga_aggregate_limit` 정책
   - TEMP 테이블스페이스 용량/IOPS
   - 병렬 수행 시 동시성까지 고려해 서버 리소스 계획

---

## 13. 요약

- **소트 머지 조인(SMJ)** 는  
  **두 입력을 조인 키 기준으로 정렬 → 정렬된 스트림을 병합 스캔**하는 방식이다.
- 장점
  - 대용량에서 **순차 스캔 기반의 안정적인 성능**
  - **비등치(범위/밴드) 조인**을 자연스럽게 처리
  - **이미 정렬된 스트림/인덱스**를 활용해 정렬 비용을 줄일 수 있음
- 단점
  - 정렬 비용(PGA/TEMP)이 크며, 잘못 튜닝하면 TEMP I/O 병목 가능
  - Top-N/부분범위에서는 NL이 더 적합할 수 있음
  - 등치 조인 + 충분한 메모리에서는 해시 조인이 종종 더 빠름
- 실전 핵심 포인트
  - **first(왼쪽) 입력**의 정렬을
    - **인덱스 스캔**으로 대체하거나
    - **이미 정렬된 파이프라인**을 활용하여  
    정렬 비용을 크게 줄일 수 있다.
  - **비등치/범위 조인**은 SMJ의 강점이므로, 별도의 인덱스 설계·파티셔닝과 결합해 활용하자.
  - 항상  
    `DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')`  
    를 통해 **Buffers/Reads/TempSpc/PGA**를 수치로 검증한 뒤,  
    해시/SMJ/NL을 비교해 최종 선택을 결정해야 한다.

이 글의 예제들을 로컬/개발 DB에서 실제로 실행해 보면서,  
SMJ 플랜이 어떻게 바뀌고, 정렬·TEMP 사용량이 어떻게 달라지는지 살펴보면  
실무에서 SMJ를 선택/배제하는 감각을 훨씬 명확하게 체득할 수 있다.