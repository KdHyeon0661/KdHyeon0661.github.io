---
layout: post
title: DB 심화 - 소트 머지 조인
date: 2025-11-10 17:25:23 +0900
category: DB 심화
---
# 소트 머지 조인(Sort Merge Join, SMJ) 완전 정리 (Oracle)

소트 머지 조인(Sort Merge Join, 이하 SMJ)은 "정렬 → 병합 스캔"이라는 단순하지만 강력한 아이디어를 바탕으로, 대용량 조인과 비등치(범위) 조인에서 여전히 중요한 역할을 하는 조인 방식입니다. 이 문서에서는 SMJ의 동작 원리부터 실무 적용까지 체계적으로 살펴보겠습니다.

## 기본 개념 및 환경 설정

SMJ의 기본 아이디어는 간단합니다: 두 입력 집합을 조인 키 기준으로 각각 정렬한 후, 정렬된 결과를 병합하면서 매칭되는 행들을 찾는 방식입니다.

실습을 위한 기본 환경 설정:

```sql
ALTER SESSION SET nls_date_format           = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level          = ALL;
ALTER SESSION SET optimizer_features_enable = '19.1.0';
ALTER SESSION SET workarea_size_policy      = AUTO;
```

`statistics_level = ALL` 설정은 상세한 실행 통계를 수집하게 하며, `workarea_size_policy = AUTO`는 정렬 작업에 필요한 메모리를 자동으로 관리하도록 합니다.

## 실습 데이터 모델 구성

실습을 위해 전형적인 주문 처리 시스템 모델을 구성합니다:

```sql
-- 고객 테이블
DROP TABLE CUST PURGE;
CREATE TABLE CUST (
  CUST_ID  NUMBER       PRIMARY KEY,
  REGION   VARCHAR2(6)  NOT NULL
);

-- 주문 헤더 테이블
DROP TABLE ORD PURGE;
CREATE TABLE ORD (
  ORDER_ID NUMBER       PRIMARY KEY,
  CUST_ID  NUMBER       NOT NULL,
  ORDER_DT DATE         NOT NULL,
  STATUS   VARCHAR2(8)  NOT NULL
);

-- 주문 상세 테이블
DROP TABLE OI PURGE;
CREATE TABLE OI (
  ORDER_ID NUMBER       NOT NULL,
  ITEM_NO  NUMBER       NOT NULL,
  PROD_ID  NUMBER       NOT NULL,
  QTY      NUMBER       NOT NULL,
  AMOUNT   NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY (ORDER_ID, ITEM_NO)
);

-- 프로모션 테이블 (비등치 조인 실습용)
DROP TABLE PROMO PURGE;
CREATE TABLE PROMO (
  PROMO_ID   NUMBER       PRIMARY KEY,
  START_DT   DATE         NOT NULL,
  END_DT     DATE         NOT NULL,
  CATEGORY   VARCHAR2(10) NOT NULL
);
```

데이터 로딩 및 인덱스 생성:

```sql
-- 필수 인덱스 생성
CREATE INDEX IX_ORD_CDT     ON ORD(CUST_ID, ORDER_DT, ORDER_ID);
CREATE INDEX IX_OI_ORDER    ON OI(ORDER_ID, ITEM_NO);
CREATE INDEX IX_PROMO_RANGE ON PROMO(START_DT, END_DT);

-- 샘플 데이터 로딩 (간소화된 버전)
BEGIN
  -- 고객 5만 명
  FOR c IN 1..50000 LOOP
    INSERT INTO CUST VALUES (c, CASE MOD(c,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END);
  END LOOP;

  -- 주문 30만 건  
  FOR o IN 1..300000 LOOP
    INSERT INTO ORD VALUES (
      o,
      MOD(o,50000)+1,
      DATE '2024-01-01' + MOD(o,540),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;
  
  COMMIT;
END;
/

-- 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'CUST', cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'ORD', cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'OI', cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'PROMO', cascade=>TRUE);
END;
/
```

## SMJ의 기본 동작 메커니즘

### 동작 원리

SMJ는 다음 세 단계로 구성됩니다:

1. **정렬 단계**: 두 입력 집합을 각각 조인 키 기준으로 정렬
2. **병합 단계**: 정렬된 두 스트림을 동시에 스캔하면서 키 비교
3. **매칭 단계**: 일치하는 키를 찾아 결과 생성

의사 코드로 표현하면 다음과 같습니다:

```
i ← 첫 번째 입력의 첫 행
j ← 두 번째 입력의 첫 행

while i와 j가 모두 끝나지 않았을 때:
    if i.key < j.key:
        i를 다음 행으로 이동
    elif i.key > j.key:
        j를 다음 행으로 이동
    else:  # i.key == j.key
        현재 키에 해당하는 모든 행 매칭
        i와 j를 다음 키 구간으로 이동
```

### 다른 조인 방식과의 비교

**Nested Loops Join(NLJ)**:
- 장점: 작은 Outer 집합 + 효율적인 Inner 인덱스 있을 때 빠름
- 단점: 대량 데이터에서 랜덤 I/O 폭발 가능성

**Hash Join**:
- 장점: 등치 조인에서 매우 효율적, 메모리 내 처리 가능
- 단점: 비등치 조인 처리 어려움, 메모리 부족 시 성능 저하

**Sort Merge Join**:
- 장점: 대용량 데이터에서 안정적, 비등치 조인 자연스럽게 처리
- 단점: 정렬 비용 발생, Top-N 쿼리에 비효율적

## SMJ 실행 계획 분석

기본적인 SMJ 쿼리의 실행 계획을 살펴보겠습니다:

```sql
-- 기본 SMJ 쿼리
SELECT /*+ LEADING(o) USE_MERGE(i) FULL(o) FULL(i) */
       o.order_id, o.cust_id, i.item_no, i.amount
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
WHERE  o.status = 'PAID';

-- 실행 계획 확인
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, NULL,
    'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'
  )
);
```

실행 계획에서 주목해야 할 부분:
1. `SORT JOIN` 연산자: 각 입력의 정렬 작업을 나타냄
2. `MERGE JOIN` 연산자: 정렬된 결과의 병합 작업
3. `TempSpc`: 정렬을 위해 사용한 임시 공간 크기
4. `Buffers`/`Reads`: 논리적/물리적 I/O 양

## 인덱스를 활용한 정렬 최적화

SMJ의 성능은 정렬 비용에 크게 의존합니다. 인덱스를 적절히 활용하면 정렬 작업을 줄일 수 있습니다.

### 단일 인덱스 정렬 대체

```sql
-- 왼쪽 입력만 인덱스로 정렬 대체
SELECT /*+ LEADING(o) USE_MERGE(i)
           INDEX_ASC(o)     -- PK(ORDER_ID) 순서 사용
           FULL(i) */
       o.order_id, o.cust_id, i.item_no, i.amount
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
WHERE  o.status = 'PAID';
```

이 쿼리에서 `INDEX_ASC(o)` 힌트는 ORD 테이블의 PK 인덱스를 사용하여 정렬 순서를 제공합니다. 실행 계획에서 왼쪽의 `SORT JOIN`이 사라지고 `INDEX FULL SCAN`으로 대체된 것을 확인할 수 있습니다.

### 양쪽 인덱스 정렬 대체

```sql
-- 양쪽 모두 인덱스로 정렬 대체
SELECT /*+ LEADING(o) USE_MERGE(i)
           INDEX_ASC(o) INDEX_ASC(i) */
       o.order_id, o.cust_id, i.item_no, i.amount
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
WHERE  o.status = 'PAID';
```

두 테이블 모두 조인 키로 정렬된 인덱스가 있을 경우, 양쪽의 정렬 작업을 모두 제거할 수 있습니다. 이 경우 TEMP 사용량이 크게 줄어들지만, 인덱스 기반의 랜덤 I/O가 증가할 수 있습니다.

## 이미 정렬된 데이터의 재활용

서브쿼리에서 이미 정렬된 결과를 SMJ에 재사용할 수 있습니다:

```sql
-- 서브쿼리에서 정렬 후 SMJ에 재사용
SELECT /*+ USE_MERGE(i) */
       o2.order_id, o2.cust_id, i.item_no, i.amount
FROM  (
        SELECT /*+ FULL(o) */
               o.order_id, o.cust_id
        FROM   ORD o
        WHERE  o.status = 'PAID'
        ORDER  BY o.order_id  -- 이미 정렬됨
      ) o2
JOIN  OI i ON i.order_id = o2.order_id;
```

옵티마이저는 서브쿼리의 정렬 결과를 SMJ의 정렬 작업으로 재사용할 수 있습니다. 실행 계획에서 불필요한 중복 정렬이 제거된 것을 확인할 수 있습니다.

## 비등치(범위) 조인에서의 SMJ

SMJ의 가장 큰 강점은 비등치 조인을 자연스럽게 처리할 수 있다는 점입니다:

```sql
-- 주문일이 프로모션 기간에 속하는 경우 매칭
SELECT /*+ LEADING(o) USE_MERGE(p) FULL(o) FULL(p) */
       o.order_id, o.order_dt, p.promo_id, p.category
FROM   ORD   o
JOIN   PROMO p ON o.order_dt BETWEEN p.START_DT AND p.END_DT
WHERE  o.status = 'PAID';
```

비등치 조인에서 SMJ는 다음과 같이 동작합니다:
1. ORD 테이블을 ORDER_DT 기준으로 정렬
2. PROMO 테이블을 START_DT 기준으로 정렬
3. 정렬된 두 스트림을 병합하면서 기간 조건 확인

이러한 범위 조인은 해시 조인으로 처리하기 어렵기 때문에 SMJ가 더 적합한 경우가 많습니다.

### 밴드 조인(Band Join) 예제

```sql
-- 금액 밴드에 따른 매칭 (예제용 테이블)
DROP TABLE THRESH PURGE;
CREATE TABLE THRESH (
  ID      NUMBER PRIMARY KEY,
  AMT_MIN NUMBER NOT NULL,
  AMT_MAX NUMBER NOT NULL
);

BEGIN
  INSERT INTO THRESH VALUES (1,   0, 1000);
  INSERT INTO THRESH VALUES (2,1000, 5000);
  INSERT INTO THRESH VALUES (3,5000,20000);
  COMMIT;
END;
/

-- 밴드 조인 쿼리
SELECT /*+ USE_MERGE(t) FULL(i) FULL(t) */
       i.order_id, i.item_no, i.amount, t.id AS band_id
FROM   OI i
JOIN   THRESH t ON i.amount BETWEEN t.amt_min AND t.amt_max;
```

## 성능 튜닝을 위한 실전 기법

### 힌트를 통한 조인 방식 제어

```sql
-- 다양한 힌트 조합 예제
SELECT /*+ LEADING(o) USE_MERGE(i)           -- SMJ 사용
           INDEX_ASC(o) FULL(i)              -- 왼쪽 인덱스, 오른쪽 풀스캔
           NO_USE_HASH(i) NO_USE_NL(i) */    -- 다른 조인 방식 배제
       o.order_id, o.cust_id, i.item_no, i.amount
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
WHERE  o.status = 'PAID';
```

주요 힌트 설명:
- `USE_MERGE`: SMJ 사용 유도
- `NO_USE_HASH`/`NO_USE_NL`: 특정 조인 방식 배제
- `LEADING`/`ORDERED`: 조인 순서 제어
- `INDEX_ASC`/`INDEX_DESC`: 인덱스 스캔 방향 지정

### 성능 비교를 위한 실험 설계

다양한 접근 방식의 성능을 비교해보겠습니다:

```sql
-- 1. 기본 SMJ (양쪽 정렬)
SELECT /*+ LEADING(o) USE_MERGE(i) FULL(o) FULL(i) */
       COUNT(*) FROM ORD o JOIN OI i ON i.order_id = o.order_id;

-- 2. 왼쪽 인덱스 정렬 대체  
SELECT /*+ LEADING(o) USE_MERGE(i) INDEX_ASC(o) FULL(i) */
       COUNT(*) FROM ORD o JOIN OI i ON i.order_id = o.order_id;

-- 3. 해시 조인 비교
SELECT /*+ LEADING(o) USE_HASH(i) FULL(o) FULL(i) */
       COUNT(*) FROM ORD o JOIN OI i ON i.order_id = o.order_id;
```

각 쿼리의 실행 계획을 비교하면서 다음 항목을 확인합니다:
- 정렬 작업의 존재 여부
- TEMP 공간 사용량(`TempSpc`)
- I/O 통계(`Buffers`, `Reads`)
- 실행 시간(`Elapsed`)

### 메모리 및 TEMP 공간 관리

SMJ의 성능은 메모리 사용량과 밀접한 관련이 있습니다:

```sql
-- 정렬 관련 세션 통계 확인
SELECT name, value
FROM   v$mystat s
JOIN   v$statname n ON n.statistic# = s.statistic#
WHERE  n.name IN ('sorts (memory)', 'sorts (disk)', 
                  'workarea executions - optimal',
                  'workarea executions - onepass',
                  'workarea executions - multipass');
```

정렬 작업의 효율성 판단 기준:
- **Optimal**: 메모리 내에서 완전히 처리됨
- **Onepass**: 일부 데이터를 TEMP에 쓰고 한 번 읽음
- **Multipass**: TEMP를 여러 번 왕복하며 처리됨

## 실무 적용 시 고려사항

### SMJ가 적합한 상황

1. **대용량 데이터 조인**: 안정적인 순차 스캔 패턴 제공
2. **비등치 조인**: 범위, BETWEEN 조건 포함 조인
3. **이미 정렬된 데이터 활용**: 인덱스나 서브쿼리 결과 재사용 가능
4. **메모리 제약 환경**: 해시 조인보다 메모리 요구량이 적을 수 있음

### SMJ가 부적합한 상황

1. **Top-N 쿼리**: 전체 정렬 후 상위 N개 선택하는 방식 비효율적
2. **작은 데이터셋**: NLJ가 더 빠를 수 있음
3. **등치 조인 + 충분한 메모리**: 해시 조인이 더 효율적일 수 있음
4. **빠른 응답 시간 요구**: 정렬로 인한 초기 지연 발생

### 파티셔닝과의 조합

대용량 테이블의 SMJ 성능을 향상시키기 위해 파티셔닝을 활용할 수 있습니다:

```sql
-- 파티션된 테이블과의 SMJ
CREATE TABLE ORD_PARTITIONED
PARTITION BY RANGE (order_dt) (
  PARTITION p1 VALUES LESS THAN (DATE '2024-07-01'),
  PARTITION p2 VALUES LESS THAN (DATE '2024-10-01'),
  PARTITION p3 VALUES LESS THAN (MAXVALUE)
) AS SELECT * FROM ORD;

-- 파티션 프루닝이 적용된 SMJ
SELECT /*+ USE_MERGE(i) */
       o.order_id, i.item_no
FROM   ORD_PARTITIONED o
JOIN   OI i ON i.order_id = o.order_id
WHERE  o.order_dt >= DATE '2024-07-01';
```

## 고급 튜닝 기법

### 병렬 처리 활용

대용량 데이터의 SMJ 성능을 개선하기 위해 병렬 처리를 적용할 수 있습니다:

```sql
-- 병렬 SMJ 예제
SELECT /*+ PARALLEL(o,4) PARALLEL(i,4) USE_MERGE(i) */
       o.order_id, i.item_no, SUM(i.amount)
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
GROUP BY o.order_id, i.item_no;
```

### 통계 정보의 중요성

정확한 통계 정보는 옵티마이저가 적절한 조인 방식을 선택하는 데 필수적입니다:

```sql
-- 통계 정보 확인
SELECT table_name, num_rows, blocks, last_analyzed
FROM   user_tables 
WHERE  table_name IN ('ORD', 'OI', 'PROMO');

-- 컬럼 통계 확인
SELECT column_name, num_distinct, density, histogram
FROM   user_tab_col_statistics
WHERE  table_name = 'ORD';
```

## 모니터링 및 문제 진단

### 실행 계획 심층 분석

```sql
-- 상세 실행 계획 분석
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
         'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS +COST +BYTES +PARTITION'
       ));
```

분석 포인트:
- 정렬 패스(Optimal/Onepass/Multipass) 확인
- TEMP 공간 사용량 모니터링
- 각 단계의 실제 행 수 비교
- 예상 비용 대비 실제 성능 평가

### 성능 문제 진단

SMJ 성능 문제 발생 시 확인할 사항:

1. **정렬 효율성**: `TempSpc` 사용량이 과도한지 확인
2. **메모리 부족**: PGA 사용량과 `workarea_size_policy` 설정 확인
3. **인덱스 활용**: 불필요한 정렬 작업이 있는지 확인
4. **데이터 편향**: 조인 키의 분포가 균등한지 확인

## 결론

소트 머지 조인(SMJ)은 Oracle 데이터베이스에서 중요한 조인 방식 중 하나로, 대용량 데이터 처리와 비등치 조인에서 뛰어난 성능을 발휘합니다. SMJ의 효과적인 활용을 위해 다음 원칙을 기억하세요:

1. **상황에 맞는 조인 방식 선택**: SMJ는 비등치 조인과 대용량 데이터 처리에 강점을 가지지만, 등치 조인에서는 해시 조인이, 작은 데이터셋에서는 NLJ가 더 효율적일 수 있습니다.

2. **정렬 비용 최소화**: 인덱스를 활용한 정렬 대체, 이미 정렬된 데이터의 재사용, 파티션 프루닝 등을 통해 정렬 비용을 줄이는 것이 성능 개선의 핵심입니다.

3. **시스템 리소스 관리**: SMJ의 성능은 메모리와 TEMP 공간 사용에 크게 영향을 받습니다. 적절한 PGA 설정과 TEMP 테이블스페이스 관리가 필요합니다.

4. **체계적인 모니터링**: 실행 계획 분석과 성능 통계 모니터링을 통해 SMJ의 동작을 이해하고 문제를 조기에 발견하는 것이 중요합니다.

5. **실험적 접근**: 이론적 지식과 실제 성능 측정을 결합하여 최적의 조인 전략을 수립하세요. 동일한 쿼리에 대해 SMJ, 해시 조인, NLJ를 각각 적용해보고 실제 성능을 비교하는 것이 가장 효과적인 학습 방법입니다.

SMJ는 단순한 개념에서 출발했지만, 현대의 복잡한 데이터 처리 요구사항을 충족시키는 강력한 도구로 진화해왔습니다. 정렬과 병합이라는 기본 원리를 이해하고, 다양한 최적화 기법을 적용한다면 대규모 데이터 조인 작업에서 안정적이고 효율적인 성능을 달성할 수 있을 것입니다.