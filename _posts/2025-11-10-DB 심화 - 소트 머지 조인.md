---
layout: post
title: DB 심화 - 소트 머지 조인
date: 2025-11-10 17:25:23 +0900
category: DB 심화
---
# 소트 머지 조인(Sort-Merge Join) 완전 정리 (Oracle)

— **기본 메커니즘 → 특징(장단/메모리·TEMP 관점) → 실전 제어 힌트와 케이스 스터디**
- **first 입력(왼쪽 입력)** 에서 **소트 연산을 인덱스 스캔으로 대체**하는 요령
- **first 집합이 이미 정렬되어 있는 경우** 소트 생략
- **등치(=)가 아닌 조인(비등치, 범위·밴드 조인)**에 SMJ를 적용하는 법
- 모든 예제는 그대로 **실행 가능한 SQL**로 제공 (계획은 `DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')`)

---

## 공통 세션 설정

```sql
ALTER SESSION SET nls_date_format        = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level       = ALL;          -- ALLSTATS LAST
ALTER SESSION SET optimizer_features_enable = '19.1.0';  -- 환경에 맞게
ALTER SESSION SET workarea_size_policy   = AUTO;         -- 소트/해시 작업 메모리 자동 관리
```

> **팁**
> - `+IOSTATS +MEMSTATS` 옵션으로 **정렬의 PGA/TEMP 사용량**을 바로 확인합니다.
> - SMJ는 대개 **둘 다(또는 한 쪽) 정렬 → 병합 스캔** 구조이므로, **PGA 부족 시 TEMP 사용**이 성능에 직접 영향.

---

# 실습용 데이터 모델

```sql
-- 고객
DROP TABLE CUST PURGE;
CREATE TABLE CUST (
  CUST_ID  NUMBER       PRIMARY KEY,
  REGION   VARCHAR2(6)  NOT NULL
);

-- 주문 헤더(왼편에서 자주 사용)
DROP TABLE ORD PURGE;
CREATE TABLE ORD (
  ORDER_ID NUMBER       PRIMARY KEY,
  CUST_ID  NUMBER       NOT NULL,
  ORDER_DT DATE         NOT NULL,
  STATUS   VARCHAR2(8)  NOT NULL
);

-- 주문 상세(오른편에서 조인)
DROP TABLE OI PURGE;
CREATE TABLE OI (
  ORDER_ID NUMBER       NOT NULL,
  ITEM_NO  NUMBER       NOT NULL,
  PROD_ID  NUMBER       NOT NULL,
  QTY      NUMBER       NOT NULL,
  AMOUNT   NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY (ORDER_ID, ITEM_NO)
);

-- 프로모션(비등치 조인 예시: 주문일이 프로모션 기간에 속하면 매칭)
DROP TABLE PROMO PURGE;
CREATE TABLE PROMO (
  PROMO_ID   NUMBER       PRIMARY KEY,
  START_DT   DATE         NOT NULL,
  END_DT     DATE         NOT NULL,
  CATEGORY   VARCHAR2(10) NOT NULL
);

-- 인덱스
CREATE INDEX IX_ORD_CDT     ON ORD(CUST_ID, ORDER_DT, ORDER_ID);
CREATE INDEX IX_OI_ORDER    ON OI(ORDER_ID, ITEM_NO);
CREATE INDEX IX_PROMO_RANGE ON PROMO(START_DT, END_DT);  -- 범위 조인 데모용(단, 실제 최적화는 전략 다양)

-- 샘플 데이터 로딩 (규모는 환경에 맞게)
BEGIN
  FOR c IN 1..50000 LOOP
    INSERT INTO CUST VALUES (c, CASE MOD(c,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END);
  END LOOP;

  FOR o IN 1..300000 LOOP
    INSERT INTO ORD VALUES (
      o,
      MOD(o,50000)+1,
      DATE '2024-01-01' + MOD(o,540),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  FOR x IN 1..300000 LOOP
    INSERT INTO OI VALUES (
      x, 1, MOD(x,20000)+1,
      TRUNC(DBMS_RANDOM.VALUE(1,5)),
      ROUND(DBMS_RANDOM.VALUE(10,2000),2)
    );
    IF MOD(x,3)=0 THEN
      INSERT INTO OI VALUES (
        x, 2, MOD(x+7,20000)+1,
        TRUNC(DBMS_RANDOM.VALUE(1,5)),
        ROUND(DBMS_RANDOM.VALUE(10,2000),2)
      );
    END IF;
  END LOOP;

  FOR p IN 1..5000 LOOP
    INSERT INTO PROMO VALUES (
      p,
      DATE '2024-01-01' + (p*2),         -- 겹치기도 하고 비는 날도 있게
      DATE '2024-01-01' + (p*2) + 10,
      CASE MOD(p,4) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FASH' WHEN 2 THEN 'FOOD' ELSE 'HOME' END
    );
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'CUST',  cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'ORD',   cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'OI',    cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'PROMO', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

# 소트 머지 조인(SMJ) **기본 메커니즘**

## 직관

1) **왼쪽(first) 입력**을 **조인 키 기준으로 정렬**한다.
2) **오른쪽(second) 입력**도 **같은 키 기준으로 정렬**한다.
3) 두 정렬된 스트림을 **병합 스캔**하면서 **키 비교**로 매칭을 출력한다.

- **정렬 비용**은 크지만, 정렬만 끝나면 **순차 스캔**이어서 대량 처리에 안정적.
- **해시 조인과 달리 비등치(범위) 조건**도 자연스럽게 처리 가능.

## 의사 코드(등치 조인)

```text
i ← 첫째 입력의 첫 행, j ← 둘째 입력의 첫 행
while i, j 둘 다 끝나지 않았다:
  if i.key < j.key:   i ← 다음
  elif i.key > j.key: j ← 다음
  else:  -- i.key == j.key
    동일한 키 구간을 모두 출력(카티시안 in-key 구간)
    i, j 각각 다음 구간으로 이동
```

> **메모리/디스크 관점**
> - 정렬은 **PGA** 우선, 부족하면 **TEMP** 사용.
> - 병합 단계 자체는 대체로 스트리밍(순차)이라 **I/O 패턴이 예측 가능**.

---

# 소트 머지 조인의 **특징**

### 장점

- **대용량**에서 **안정적**(순차 스캔 기반)
- **비등치(≤, <, BETWEEN, 범위)** 조인을 **자연스럽게 지원**
- 두 입력이 **이미 정렬**되어 있거나 **정렬 대체(인덱스 스캔) 가능**하면 소트 비용 감소
- **일괄 처리/배치 집계**에서 좋은 선택지가 되는 경우가 많음

### 단점/주의

- **정렬 비용(PGA/TEMP)**이 클 수 있음 → 메모리 정책·TEMP I/O 민감
- 작은 결과 Top-N/부분범위 같은 **조기 종료**는 NL이 유리
- **등치 대량 조인**에서 적절한 해시 조인이 **더 빠른** 경우도 많음
- 정렬을 인덱스로 대체할 때 **인덱스 선택/스캔 양**을 잘못 잡으면 오히려 느려질 수 있음

---

# **기본 SMJ 예제** (등치 조인)

```sql
-- 고객의 주문(헤더)과 주문상세를 ORDER_ID로 조인
-- SMJ 강제: USE_MERGE
SELECT /*+ LEADING(o) USE_MERGE(i) FULL(o) FULL(i) */
       o.order_id, o.cust_id, i.item_no, i.amount
FROM   ORD o
JOIN   OI  i
  ON   i.order_id = o.order_id
WHERE  o.status = 'PAID';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

**기대 계획(요지)**
- `SORT JOIN`(왼쪽), `SORT JOIN`(오른쪽), `MERGE JOIN`
- `+MEMSTATS` 로 **TempSpc**/PGA 사용을 확인 → **정렬 비용** 체감

---

# **first 입력에서 소트 생략**: 인덱스로 정렬 대체

> 핵심: first(왼쪽) 입력이 **조인 키 순으로 이미 정렬**된 형태로 공급되면, 옵티마이저가 해당 쪽의 **SORT JOIN**을 **생략**할 수 있습니다.
> 가장 흔한 방법은 **조인 키 선두 인덱스 Range/Full Scan**을 통해 **정렬된 흐름**을 직접 뽑아내는 것.

## 케이스 A — 왼쪽 입력(ORD)을 **인덱스 스캔**으로 정렬 대체

```sql
-- 목표: 왼쪽(ORD) 정렬을 IX_ORD_CDT로 대체 (조인 키: ORDER_ID)
-- 다만 IX_ORD_CDT의 선두는 (CUST_ID, ORDER_DT, ORDER_ID)라 조인키 단독 완전순서가 아님.
-- "ORDER_ID" 단독 완전 순서를 보장하려면 PK(ORDER_ID) 기반 정렬이 낫다.
-- 따라서 ORD의 PK(ORDER_ID)로 Full Scan(순방향) 또는 Range Scan을 활용하면 SORT JOIN 생략 가능.

-- 힌트로 의도 명시
SELECT /*+ LEADING(o) USE_MERGE(i)
           INDEX_ASC(o)     -- PK(ORDER_ID) 순으로
           FULL(i) */       -- 오른쪽은 전체 정렬
       o.order_id, o.cust_id, i.item_no, i.amount
FROM   ORD o
JOIN   OI  i
  ON   i.order_id = o.order_id
WHERE  o.status = 'PAID';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

**포인트**
- 계획에서 **왼쪽의 `SORT JOIN`이 사라지고 `INDEX FULL SCAN`(또는 RANGE SCAN)** 으로 대체될 수 있습니다.
- 오른쪽은 여전히 정렬 필요 → 오른쪽에 대해서도 인덱스로 정렬 대체를 시도할 수 있음(다음 예).

## 케이스 B — 양쪽 모두 **정렬 대체** (두 쪽 다 인덱스 순서)

```sql
-- 오른쪽(OI)은 PK (ORDER_ID, ITEM_NO) 이므로 ORDER_ID 순서를 포함.
-- ORDER_ID 단독 완전순서를 쓰려면 ITEM_NO 영향 없이 ORDER_ID 기준으로 묶인 흐름이 필요.
-- 실무에서는 조인키 단독/Leading 인덱스가 이상적 (예: OI(ORDER_ID) 또는 파티션 키)
-- 데모로 PK 사용 + 옵티마이저 판단에 맡기되, FULL 대신 INDEX 지시

SELECT /*+ LEADING(o) USE_MERGE(i)
           INDEX_ASC(o) INDEX_ASC(i) */
       o.order_id, o.cust_id, i.item_no, i.amount
FROM   ORD o
JOIN   OI  i
  ON   i.order_id = o.order_id
WHERE  o.status = 'PAID';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

**효과**
- 양쪽 모두에서 `SORT JOIN`이 **줄거나 사라질** 수 있습니다.
- **주의**: 인덱스 기반 정렬 대체는 **I/O 패턴(랜덤/순차)**, **클러스터링 팩터**, **선택도**에 따라 **오히려 불리**할 수 있음.
  항상 `ALLSTATS LAST`로 **Buffers/Reads/TempSpc**를 비교하세요.

---

# **first 집합이 이미 정렬**되어 있을 때 (소트 생략)

> 예: 파티션 키/PK 순으로 **파티션 프루닝 + 파티션 내 순차 스캔**을 할 때, 혹은 **Window/Group**에서 나온 **정렬된 중간 결과**를 그대로 SMJ의 왼쪽 입력으로 공급할 때.

## 파이프라인 정렬 재사용

```sql
-- 왼쪽 서브쿼리에서 ORDER_ID 기준 정렬된 결과를 만들고,
-- 그 흐름을 그대로 SMJ 왼쪽에 공급
SELECT /*+ USE_MERGE(i) */
       o2.order_id, o2.cust_id, i.item_no, i.amount
FROM  (
        SELECT /*+ FULL(o) */ o.order_id, o.cust_id
        FROM   ORD o
        WHERE  o.status = 'PAID'
        ORDER  BY o.order_id  -- 이미 정렬
      ) o2
JOIN  OI i
  ON  i.order_id = o2.order_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

- 옵티마이저는 종종 **서브쿼리 Sort → SMJ 왼쪽 Sort 생략**으로 계획을 짭니다(버전/쿼리 구조에 의존).
- 실행계획을 통해 **중복 정렬이 제거**되었는지 확인하세요.

---

# **비등치 조인(≤, BETWEEN 등)** — SMJ의 강점

> 해시 조인은 원칙적으로 **등치** 조인에 최적화.
> **SMJ는 범위/밴드** 조인을 자연스럽게 처리할 수 있어 **기간 매핑**류에 매우 유용.

## “주문일이 프로모션 기간에 속하는” 비등치 조인

```sql
-- 주문일이 PROMO(START_DT..END_DT)에 속하면 매칭
-- SMJ 강제 + 정렬 전략
SELECT /*+ LEADING(o) USE_MERGE(p) FULL(o) FULL(p) */
       o.order_id, o.order_dt, p.promo_id, p.category
FROM   ORD   o
JOIN   PROMO p
  ON   o.ORDER_DT BETWEEN p.START_DT AND p.END_DT
WHERE  o.status = 'PAID';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

**계획 핵심**
- `SORT JOIN`(ORDER_DT 기준), `SORT JOIN`(START_DT/END_DT 조합 또는 옵티마이저 내부 전략), `MERGE JOIN`
- `+MEMSTATS` 로 정렬의 **PGA/TEMP** 소비 확인

## 인덱스로 정렬 대체(가능한 경우)

- 왼쪽(ORD): `ORDER_DT` 선두 인덱스가 있으면 **왼쪽 Sort 생략** 가능
- 오른쪽(PROMO): 비등치라 단순한 단일 키 정렬로 충분하지 않을 수 있으나,
  **(START_DT, END_DT)** 복합 인덱스로 **스윕** 전략을 택하거나, 파티션 프루닝을 병행해 비용 감소

```sql
-- 왼쪽 정렬 대체 예(ORDER_DT 선두 인덱스가 있다고 가정할 때)
-- ※ 데모 스키마에는 IX_ORD_CDT(cust_id, order_dt, order_id) 있음 → ORDER_DT 단독 완전순서 보장 아님.
-- 실제 현장에서는 (ORDER_DT, ORDER_ID) 같은 보조 인덱스를 추가해 정렬 대체를 명확히 하기도 합니다.

-- 개념 예시(인덱스가 있다고 가정):
-- CREATE INDEX IX_ORD_DTO  ON ORD(ORDER_DT, ORDER_ID);

SELECT /*+ LEADING(o) USE_MERGE(p)
           INDEX_ASC(o /*IX_ORD_DTO*/) FULL(p) */
       o.order_id, o.order_dt, p.promo_id, p.category
FROM   ORD   o
JOIN   PROMO p
  ON   o.order_dt BETWEEN p.start_dt AND p.end_dt
WHERE  o.status = 'PAID';
```

> **핵심 요령**
> 1) 비등치 조인은 **SMJ**로 자연스럽게 처리
> 2) **정렬 대체**를 노리되, **두 입력의 “정렬 기준”이 조인 알고리즘에 맞게** 제공되는지 확인
> 3) 항상 `ALLSTATS LAST`로 **Buffers/Reads/TempSpc** 비교

---

# **힌트로 SMJ 제어** 요약

- `/*+ USE_MERGE(t) */` : t를 대상으로 SMJ 사용 유도
- `/*+ NO_USE_NL(t) NO_USE_HASH(t) */` : 다른 조인 메소드 배제
- `/*+ ORDERED */` 또는 `/*+ LEADING(a b c) */` : 조인 입력 순서 고정 (왼쪽/오른쪽 제어)
- `/*+ FULL(t) */` : 풀 스캔 유도(정렬 전 블록 순차 스캔 유리한 경우)
- `/*+ INDEX_ASC(t idx) */` : **정렬 대체**(해당 인덱스 순으로 **오름차순** 스캔)
- `/*+ INDEX_DESC(t idx) */` : 내림차순 필요 시
- `/*+ PARALLEL(t n) */` : 대용량 정렬/병합 병렬화(서버 리소스·TEMP 정책 고려)

---

# 실전 튜닝 절차(체크리스트)

1) **조인 메소드 후보 비교**
   - 해시 vs SMJ vs NL: 현재 쿼리의 **데이터 양/필터링/정렬 요구/비등치 여부**로 1차 감.
2) **정렬 비용 가늠**
   - `+MEMSTATS` 로 TEMPSpc/PGA 사용량 확인. TEMP가 크면 I/O 병목 위험.
   - 파티션 프루닝, 서브쿼리 단계 정렬 재사용 등으로 **정렬량 축소**.
3) **정렬 대체(인덱스 스캔)** 검토
   - **조인 키 선두 인덱스**로 **한쪽 또는 양쪽**의 `SORT JOIN` 제거
   - 인덱스 스캔 I/O vs 정렬 I/O **숫자 비교**(Buffers/Reads/Elapsed)
4) **비등치 조인**이면 SMJ 우선 고려
   - 기간 매핑·밴드 조인: SMJ 기본 + 정렬량 최소화 전략
5) **플랜 고정/안정화**
   - 힌트/SQL Plan Management로 의도 유지
   - 히스토그램/ACS(Adaptive Cursor Sharing)로 값별 분포 차에 대응
6) **자원·운영**
   - `pga_aggregate_target`/`pga_aggregate_limit` 정책, TEMP 용량/IOPS 점검
   - 병렬 사용 시 동시성/서버 리소스 한도 관리

---

# 케이스 스터디

## “왼쪽만 정렬 대체” vs “양쪽 정렬” 비교

```sql
-- A) 양쪽 정렬(베이스라인)
SELECT /*+ LEADING(o) USE_MERGE(i) FULL(o) FULL(i) */
       o.order_id, i.item_no
FROM   ORD o JOIN OI i
ON     i.order_id = o.order_id
WHERE  o.status = 'PAID';

-- B) 왼쪽 정렬 대체(ORDER_ID PK 순서)
SELECT /*+ LEADING(o) USE_MERGE(i) INDEX_ASC(o) FULL(i) */
       o.order_id, i.item_no
FROM   ORD o JOIN OI i
ON     i.order_id = o.order_id
WHERE  o.status = 'PAID';

-- C) 양쪽 정렬 대체(가능시)
SELECT /*+ LEADING(o) USE_MERGE(i) INDEX_ASC(o) INDEX_ASC(i) */
       o.order_id, i.item_no
FROM   ORD o JOIN OI i
ON     i.order_id = o.order_id
WHERE  o.status = 'PAID';

-- 실행 후 각각:
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

**비교 포인트**
- `SORT JOIN` 단계 유무/TempSpc
- Buffers/Reads/Elapsed 차이
- 인덱스 스캔이 **랜덤 I/O**를 늘려 **오히려 느려지는지** 여부 (데이터 물리 배치·클러스터링 팩터 영향)

## “왼쪽이 이미 정렬된 파이프라인” 재사용

```sql
-- 주문 집합을 ORDER_ID 순으로 먼저 정리(정렬 비용은 어차피 필요)
-- 그 결과를 SMJ 왼쪽으로 바로 공급(중복 정렬 제거 기대)

WITH O_SORT AS (
  SELECT /*+ FULL(o) */
         o.order_id
  FROM   ORD o
  WHERE  o.order_dt >= DATE '2024-06-01'
  ORDER  BY o.order_id
)
SELECT /*+ USE_MERGE(i) */
       s.order_id, i.item_no, i.amount
FROM   O_SORT s
JOIN   OI     i
  ON   i.order_id = s.order_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

- 계획에서 **왼쪽 SORT JOIN**이 사라졌는지 확인
- 전체적으로 **정렬 한 번만** 하고 **병합**으로 직행하는지 체크

## 비등치(기간 매핑) — SMJ vs 해시 비교

```sql
-- SMJ 강제 (비등치)
SELECT /*+ LEADING(o) USE_MERGE(p) FULL(o) FULL(p) */
       COUNT(*)
FROM   ORD o
JOIN   PROMO p
  ON   o.order_dt BETWEEN p.start_dt AND p.end_dt
WHERE  o.status = 'PAID';

-- (참고) 해시 조인 시도 — 보통 비등치에서는 비효율/불가하거나 내부 변형 필요
SELECT /*+ LEADING(o) USE_HASH(p) FULL(o) FULL(p) */
       COUNT(*)
FROM   ORD o
JOIN   PROMO p
  ON   o.order_dt BETWEEN p.start_dt AND p.end_dt
WHERE  o.status = 'PAID';
```

- 일반적으로 **SMJ가 유리**(혹은 유일)
- `+MEMSTATS`로 정렬에 쓴 메모리/TEMP 확인 → **인덱스·파티셔닝**으로 줄일 여지 탐색

---

# 소트 비용을 줄이는 실무 팁

- **파티셔닝 + 로컬 인덱스**: 파티션 프루닝으로 **정렬 대상량**을 줄임
- **조인키 선두 인덱스**로 **정렬 대체**(양쪽 이상적)
- **서브쿼리에서 이미 정렬된 스트림**을 만들고 재사용(중복 정렬 제거)
- **PGA 정책** 튜닝(자동 정책 권장, 단 서버 메모리·동시성 고려)
- **TEMP 디스크 성능**(IOPS, Tempfile 수)과 **자동 확장 정책** 모니터링
- **병렬**: 대용량 정렬/병합을 빨리 끝내되, 시스템 리소스 경합 주의

---

# 요약

- **소트 머지 조인(SMJ)** 은 **정렬 → 병합 스캔**으로 동작하며,
  **대용량·비등치 조인**에서 **안정적인 성능**을 제공.
- **first(왼쪽) 입력**이 **이미 정렬**되어 있거나, **인덱스 스캔으로 정렬 대체**가 가능하면
  **SORT JOIN**을 **생략**해 **PGA/TEMP 비용**을 크게 줄일 수 있음.
- **비등치(기간/밴드)** 조인은 SMJ의 강세 영역.
- 항상 `ALLSTATS LAST +IOSTATS +MEMSTATS`로 **Buffers/Reads/TempSpc**를 확인하고,
  **해시/SMJ/NL**을 **실측 비교**해 최적을 선택하라.

> **실무 판단 키워드**
> - **정렬량**(줄일 수 있는가?)
> - **비등치 조인 여부**(SMJ 강점)
> - **인덱스 정렬 대체**(한쪽/양쪽)
> - **PGA/TEMP 여유**와 **동시성**
