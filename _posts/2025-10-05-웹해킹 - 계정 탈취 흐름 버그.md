---
layout: post
title: 웹해킹 - 
date: 2025-10-05 23:25:23 +0900
category: 웹해킹
---
# 17. 계정 탈취 흐름 버그 (Password Reset Poisoning)

## 0) 한눈에 보기 (Executive Summary)

- **문제(정의)**  
  비밀번호 재설정 링크를 만들 때 서버가 **요청의 `Host`나 `X-Forwarded-Host/Proto` 같은 헤더를 신뢰**하면,  
  프록시·WAF·CDN 뒤에 있을 때 **Host Header Injection**과 결합하여 **공격자 도메인**으로 된 재설정 URL이  
  **피해자 이메일로 발송**됩니다. 피해자가 클릭하면 토큰이 공격자에게 노출되거나 중간자 페이지를 거쳐 탈취됩니다.

- **핵심 원인**  
  - 앱이 `req.get('Host')`/`request.get_host()`/`url_for(..., _external=True)`/`request.build_absolute_uri(...)` 등  
    **요청 기반 호스트/스킴**으로 절대 URL을 생성.  
  - 프록시가 `X-Forwarded-Host/Proto` 를 **그대로** 백엔드로 전달, 백엔드가 이를 신뢰.

- **핵심 방어**  
  1) **서버 고정 베이스 URL**(예: `https://app.example.com`)에서만 절대 링크 생성 — **요청 Host 무시**  
  2) 프록시에서 **수신 Host 검증/재작성**, `X-Forwarded-*` **화이트리스트/정규화**  
  3) 토큰은 **짧은 TTL·1회성·스코프 한정** + **장치/세션 바인딩(선택)**  
  4) 이메일 템플릿/클릭 UX **피싱 안전화**(도메인 노출, 복구 코드 옵션 병행)  
  5) **로깅/탐지/테스트 자동화**: 리셋 링크 호스트가 **정책 도메인 외**면 실패 처리·경보

---

## 1) 위협 모델 & 시나리오(개념)

1. 사용자가 “비밀번호 재설정”을 요청.  
2. 서버가 `https://${요청 Host}/reset?token=...` 로 링크 생성.  
3. 공격자가 프록시/중간 노드에 **`Host: evil.tld`**(또는 `X-Forwarded-Host: evil.tld`)를 주입한 상태로 요청을 만들도록 유도.  
4. 시스템이 그 값을 믿고 **`https://evil.tld/reset?...`** 링크를 메일로 발송.  
5. 피해자가 클릭 → 공격자 사이트가 **토큰 수집** 또는 **정상 도메인으로 리다이렉션**해 내부에서 재설정 완료.

> 실제 악용은 여러 변형이 있으나, **공통분모는 “링크의 베이스를 요청에서 가져왔다”**입니다.

---

## 2) 실전 징후(로그/행동)

- 비밀번호 재설정 메일 속 링크 호스트가 **환경 변수의 공식 도메인과 불일치**.  
- 엣지/CDN 로그에 **`X-Forwarded-Host`가 생소한 값**으로 다수 관찰.  
- 사용자 신고: “비밀번호 재설정 메일 링크가 **이상한 도메인**이었어요.”

---

## 3) “안전 재현” 점검(스테이징 전용) — **막혀야 정상 ✅**

> 아래는 **차단 확인**용입니다. 운영/타 시스템 금지.

### 3.1 Host 헤더 변화 시도
```bash
# (프록시 직결 환경에서만) Host를 바꿔 요청
curl -si -H 'Host: evil.tld' https://staging.example.com/auth/reset/start \
  -d 'email=user@company.tld'
# 기대: 앱이 생성하는 링크의 호스트는 항상 https://staging.example.com
# (로그/메일 미리보기로 확인)
```

### 3.2 X-Forwarded-* 주입 시도
```bash
curl -si https://staging.example.com/auth/reset/start \
  -H 'X-Forwarded-Host: evil.tld' \
  -H 'X-Forwarded-Proto: http' \
  -d 'email=user@company.tld'
# 기대: 링크는 고정 베이스 URL, 스킴은 https, 요청 헤더 무시
```

### 3.3 링크 무결성 검사
- 발송된 링크를 파싱하여 **호스트/스킴이 정책 도메인과 일치**하는지 테스트에서 강제.  
- 불일치 시 **발송 자체 실패**(큐에서 drop)하도록 구성.

---

## 4) 안전 설계 원칙

1) **링크 생성은 환경 변수/설정의 “고정 베이스 URL”에서만**  
   - 예: `APP_BASE_URL=https://app.example.com`  
   - 멀티 테넌트·지역 환경은 **화이트리스트**에서 매핑.

2) **요청에서 온 Host/Proto/Port는 절대 사용하지 않기**  
   - `req.get('Host')`, `request.get_host()`, `url_for(..., _external=True)` 등 **금지**.  
   - 서버 뒤 프록시/로드밸런서는 **항상** 백엔드로 **고정 Host를 주입(재작성)**.

3) **프록시 신뢰 경계 설정**  
   - 프록시에선 **허용 호스트 목록** 외 요청은 400/리다이렉트.  
   - `X-Forwarded-*` 헤더는 **직접 무시**하거나, **신뢰 경로에서만 덮어쓰기**.

4) **토큰 하드닝**  
   - **짧은 TTL(예: 10–15분), 1회성, 스코프=reset**  
   - **사용자·디바이스·IP 대역 바인딩(선택)**  
   - 사용 후 즉시 폐기, 여러 번 실패 시 rate-limit.

5) **이메일 & UX 안전화**  
   - 클릭 URL을 **문자 그대로** 표시(숨김 링크 지양) + **공식 도메인 명시**  
   - “링크가 보이지 않으면 **코드 입력** 방식” 대안 제공(6–8자리 OOB code).

---

## 5) 구현 레시피 — 앱 코드

### 5.1 Node/Express

```js
// config/baseUrl.ts
export const BASE_URL = process.env.APP_BASE_URL; // e.g. https://app.example.com
if (!/^https:\/\/[a-z0-9.-]+(:\d+)?$/i.test(BASE_URL || "")) {
  throw new Error("Invalid APP_BASE_URL");
}

// routes/auth.ts
import { BASE_URL } from "../config/baseUrl";
import crypto from "node:crypto";
import { addMinutes, isBefore } from "date-fns";
import express from "express";
const router = express.Router();

function issueResetToken(userId) {
  const token = crypto.randomBytes(32).toString("base64url");
  const exp = addMinutes(new Date(), 15).toISOString();
  // DB: token(hash), userId, exp, used=false, scope='pwd_reset'
  return { token, exp };
}

router.post("/auth/reset/start", async (req, res) => {
  const { email } = req.body || {};
  // (존재 유무 노출 방지) 항상 200, 내부적으로만 처리
  const user = await findUserByEmail(email);
  if (user) {
    const { token, exp } = issueResetToken(user.id);
    const url = new URL("/auth/reset/finish", BASE_URL);  // ✅ 요청 Host 무시
    url.searchParams.set("token", token);
    await sendResetEmail(email, url.toString(), exp);
  }
  return res.json({ ok: true });
});

router.post("/auth/reset/finish", async (req, res) => {
  const { token, password } = req.body || {};
  const rec = await findToken(token, "pwd_reset");
  if (!rec || rec.used || isBefore(new Date(rec.exp), new Date())) {
    return res.status(400).json({ error: "invalid_or_expired" });
  }
  await updatePassword(rec.userId, password);
  await markTokenUsed(rec.id);
  return res.json({ ok: true });
});

export default router;
```

> **포인트**  
> - **`new URL(path, BASE_URL)`** 로만 절대 URL 생성.  
> - **요청 객체(req)의 Host/Proto/Origin은 일절 사용하지 않음**.

#### Express: **Host 신뢰 금지 미들웨어(선택)**
```js
app.use((req, _res, next) => {
  // 위험 헤더가 들어오면 로깅/드롭
  const bad = ['x-forwarded-host','x-forwarded-proto','x-forwarded-port']
    .filter(h => req.headers[h]);
  if (bad.length) req.log?.warn({ bad }, "Forwarded headers present");
  next();
});
```

---

### 5.2 NestJS

```ts
// app.config.ts
export const AppConfig = () => ({
  baseUrl: process.env.APP_BASE_URL,  // ✅ 환경에서 고정
});

// auth.service.ts
@Injectable()
export class AuthService {
  constructor(private cfg: ConfigService, private mail: MailerService) {}

  async startReset(email: string) {
    const user = await this.userRepo.findByEmail(email);
    if (!user) return;
    const token = await this.tokenSvc.issue("pwd_reset", user.id, 15 * 60);
    const base = this.cfg.getOrThrow<string>("baseUrl");
    const link = new URL("/auth/reset/finish", base);
    link.searchParams.set("token", token);
    await this.mail.send("reset", { to: email, link: link.toString() });
  }
}
```

---

### 5.3 Spring Boot (Java)

```java
// application.yml
app:
  base-url: https://app.example.com

// ResetLinkService.java
@Service
public class ResetLinkService {
  @Value("${app.base-url}") private String baseUrl;
  public URI build(String token) {
    return UriComponentsBuilder.fromUriString(baseUrl)
      .path("/auth/reset/finish").queryParam("token", token).build().toUri();
  }
}

// AuthController.java
@PostMapping("/auth/reset/start")
public ResponseEntity<?> start(@RequestBody ResetStartDto dto) {
  userService.ifExists(dto.email(), user -> {
    var token = tokenSvc.issue("pwd_reset", user.getId(), Duration.ofMinutes(15));
    var link = resetLinkService.build(token);
    mailer.sendReset(user.getEmail(), link.toString());
  });
  return ResponseEntity.ok(Map.of("ok", true));
}
```

> **주의**: `ServletUriComponentsBuilder.fromCurrentContextPath()` 같은 **요청 기반 빌더 사용 금지**.  
> **반드시** `@Value("${app.base-url}")` 등 **설정에서 가져오십시오**.

---

### 5.4 Django

```python
# settings.py
APP_BASE_URL = "https://app.example.com"

# views.py
from django.conf import settings
from urllib.parse import urljoin, urlencode

@api_view(["POST"])
def reset_start(request):
    email = request.data.get("email")
    user = get_user(email)
    if user:
        token = issue_token(user.id, scope="pwd_reset", ttl=15*60)
        link = urljoin(settings.APP_BASE_URL, "/auth/reset/finish")
        link = f"{link}?{urlencode({'token': token})}"
        send_mail("Reset", f"Click: {link}", settings.DEFAULT_FROM_EMAIL, [email])
    return Response({"ok": True})
```

> **주의**: `request.build_absolute_uri()` 로 호스트를 만들지 마십시오.

---

### 5.5 Rails

```rb
# config/environments/production.rb
Rails.application.routes.default_url_options[:host] = "app.example.com"
Rails.application.routes.default_url_options[:protocol] = "https"

# mailers/user_mailer.rb
def reset_password(user, token)
  @url = reset_finish_url(token: token)  # ✅ default_url_options 기반
  mail to: user.email, subject: "Reset your password"
end
```

> **주의**: 컨트롤러의 `request.host`/`request.protocol` 을 링크 생성에 사용하지 마세요.

---

## 6) 프록시/CDN — 신뢰 경계 강제

### 6.1 Nginx

```nginx
# 1) 허용 호스트 화이트리스트 (기타는 400 또는 301)
map $host $allowed_host {
    default 0;
    app.example.com 1;
    staging.example.com 1;
}
server {
    if ($allowed_host = 0) { return 400; }
    # 2) 백엔드로 Host를 항상 고정하여 전달
    proxy_set_header Host app.example.com;
    # 3) X-Forwarded-* 은 프록시가 책임지고 정확히 설정
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header X-Forwarded-Host app.example.com;
    proxy_pass http://app_backend;
}
```

### 6.2 HAProxy

```haproxy
acl good_host hdr(host) -i app.example.com staging.example.com
http-request deny if !good_host
http-request set-header Host app.example.com
http-request set-header X-Forwarded-Proto https
```

> 핵심: **경계에서 고정** → 백엔드는 **환경 변수의 베이스 URL만 신뢰**.

---

## 7) 토큰 설계(하드닝)

- **성질**: 1회성 / 짧은 TTL(10–15분) / 스코프(`pwd_reset`) / 사용자 ID 포함  
- **저장**: 토큰 **해시(SHA-256)**만 DB에 저장(유출 대비)  
- **사용 시**:  
  - 만료·사용 여부 체크 → 사용 후 즉시 **폐기**  
  - (선택) **클릭 컨텍스트 검증**: 발급 시점의 **브라우저 바인딩/장치 식별자**를 저장하고 큰 괴리 시 2차 확인  
  - (선택) 토큰을 **OOB 코드(6–8자리)**와 **동시 요구**(링크+코드 2요소)

```ts
// Node 예: 토큰 해시 저장
const token = crypto.randomBytes(32).toString("base64url");
const hash = crypto.createHash("sha256").update(token).digest("hex");
await db.insert({ userId, scope:'pwd_reset', hash, exp, used:false });
```

---

## 8) 이메일/UX 보강

- **링크 노출**: HTML 앵커의 텍스트와 `href`를 **동일하게**(숨김 링크 금지).  
- **도메인 가시화**: “우리의 공식 도메인: **app.example.com**” 문구 삽입.  
- **대체 수단**: 링크 대신/병행으로 **6–8자리 코드** 제공(앱 내 입력 창).  
- **CTA 전 안내**: “브라우저 주소창이 **app.example.com**인지 확인하세요.”

HTML 템플릿 예:
```html
<p>비밀번호 재설정 링크 (15분 유효):</p>
<p><a href="https://app.example.com/auth/reset/finish?token=...">
https://app.example.com/auth/reset/finish?token=...</a></p>
<p>주소창의 도메인이 <b>app.example.com</b>인지 확인하세요. 링크가 열리지 않으면
코드 <b>123 456</b>를 앱의 '코드로 재설정' 페이지에 입력하세요.</p>
```

---

## 9) 로깅/탐지

- **로그 필드**: `ts`, `route`, `email_hash`, `link_host`, `link_scheme`, `token_id`, `client_ip`, `forwarded_host`  
- **경보 룰**:
  - `link_host != APP_BASE_URL.host` 발생 시 **즉시 경보 + 발송 중단**  
  - `forwarded_host`가 정책 외 값일 때 비율 상승  
  - 실패 토큰 시도(만료/이미 사용) 급증

Splunk 예:
```spl
index=app route="/auth/reset/start" link_host!="app.example.com"
| stats count by link_host, client_ip
```

---

## 10) 테스트/CI 자동화

- **단위 테스트**: 링크 생성기가 **환경변수 베이스**만 사용함을 검증.  
- **통합 테스트**: 가짜 `Host`/`X-Forwarded-Host`를 보내도 **메일에 항상 공식 도메인**이 들어가는지 확인.  
- **보안 테스트**: E2E에서 이메일 프리뷰(API/로그)로 호스트 검증 → 불일치 시 실패.

Node + Jest 예:
```ts
it('reset link uses APP_BASE_URL only', async () => {
  process.env.APP_BASE_URL = "https://app.example.com";
  const res = await request(app)
    .post('/auth/reset/start')
    .set('Host','evil.tld')
    .set('X-Forwarded-Host','evil.tld')
    .send({ email:'u@example.com' })
    .expect(200);
  const mail = getLastMail(); // 테스트 더블
  expect(mail.body).toContain("https://app.example.com/auth/reset/finish?");
  expect(mail.body).not.toContain("evil.tld");
});
```

---

## 11) 관련 안티패턴 총정리 (피해야 할 것)

- `req.get('Host')` / `request.get_host()` / `request.host_url` / `url_for(..., _external=True)`(요청 기반)  
- 프록시에서 **임의 Host/XFH**를 **그대로** 백엔드에 전달  
- 토큰 **장수명/재사용 가능**  
- 이메일에 **숨김 링크(보이는 텍스트 ≠ href)**  
- 멀티 도메인을 **코드에서 문자열 조립**(검증 없음) — 반드시 **화이트리스트 매핑**  
- `http` 스킴 생성(혼합 콘텐츠·다운그레이드)

---

## 12) 체크리스트 (현장용)

- [ ] **APP_BASE_URL** 등 설정에서만 절대 URL 생성(호스트/스킴 고정)  
- [ ] 프록시/LB에서 Host **화이트리스트 검증** + 백엔드로 **고정 Host 재작성**  
- [ ] `X-Forwarded-*`는 **신뢰 경계 안**에서만 세팅, 앱은 **요청 헤더 무시**  
- [ ] 토큰 **1회성/짧은 TTL/스코프 한정/해시 저장**  
- [ ] 재설정 엔드포인트 **rate-limit/브루트포스 방지**  
- [ ] 이메일 템플릿에 **공식 도메인 명시** + **코드 방식 대안**  
- [ ] 로깅: `link_host`/`forwarded_host` 캡처, 불일치 경보  
- [ ] CI/E2E: Host/XFH 주입에도 **항상 공식 도메인 링크** 생성 확인  
- [ ] 문서화: 운영자가 **공식 베이스 URL 변경 절차**와 **허용 호스트 목록**을 관리

---

## 맺음말

**Password Reset Poisoning**은 “요청에서 베이스 URL을 가져온다”는 **사소한 편의**가  
**계정 탈취**로 이어지는 전형적인 사례입니다.  
**고정 베이스 URL**, **프록시 경계에서의 재작성/검증**, **짧고 강한 토큰**, **피싱 친화도 낮춘 UX**를  
표준으로 삼으면 이 문제를 **구조적으로 차단**할 수 있습니다.