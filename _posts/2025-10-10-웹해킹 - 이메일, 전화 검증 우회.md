---
layout: post
title: 웹해킹 - 이메일/전화 검증 우회
date: 2025-10-10 14:25:23 +0900
category: 웹해킹
---
# 이메일/전화 검증 우회

**— 문제: 토큰 재사용 · 중복 전송 · 레이스(동시성) — 방어: 1회성 토큰 · 최단 TTL · 서버 저장 상태 · 원자적(atomic) 업데이트**

## 한눈에 보기 (Executive Summary)

- **취약 원인**
  1) **토큰 재사용**: 같은 OTP/링크가 여러 번 통과(‘사용됨’ 표시가 서버에 없거나 레이스로 미적용).
  2) **중복 전송**: 연타/네트워크 재시도로 **다수의 유효 토큰**이 동시에 살아남음(가장 오래된 것도 통과).
  3) **레이스(동시성)**: 동시에 검증 요청이 들어오면 **둘 다 성공**하는 타이밍 창 존재.

- **핵심 방어**
  - **1회성 토큰 + 최단 TTL**: SMS 2–3분, 이메일 링크 10–15분, 사용 즉시 무효화.
  - **서버 저장 상태(Stateful)**: “발급·시도·성공/실패·만료”를 **서버**가 기록하고 판정(클라이언트 주장 불신).
  - **원자적 업데이트**: `UPDATE ... WHERE used=false AND expires_at>now()`로 **한 번만 성공**.
  - **중복 전송 통제**: **재전송 쿨다운(>30–60s)**, **최신 토큰만 유효**, **Idempotency-Key**로 전송 API 멱등화.
  - **시도 제한/속도 제한**: 3–5회 실패/코드당, 10–20회/하루/채널별, IP·디바이스별 rate-limit.

---

## 위협 모델 & 실패 패턴

### 토큰 재사용 (Replay)

- **상황**: 사용자가 코드를 한 번 입력해 성공한 뒤, 공격자가 **같은 코드**로 API를 다시 호출 → 또 성공.
- **원인**: DB에 “used” 플래그가 없거나, “검증 → 플래그 설정”이 **트랜잭션 밖**에서 이루어져 경합 시 누락.

### 중복 전송 (Duplicate issuance)

- **상황**: “코드 다시 보내기” 빠른 연타/네트워크 재시도로 **서로 다른 토큰 다수가 유효**.
- **원인**: 발급을 멱등화하지 않음, “가장 최신 토큰만 유효” 정책이 없음, 재전송 쿨다운 없음.

### 성공

- **상황**: 같은 토큰으로 **동시에 두 요청**이 날아와 둘 다 `used=false`를 보고 **둘 다 성공**.
- **원인**: “조회 후 업데이트” 2단계 로직, 행 잠금/원자 비교-갱신 미적용.

### 스코프/바인딩 누락

- **상황**: 전화 인증 토큰을 이메일 인증 API에 제출하거나, **다른 사용자/채널**에 제출해도 통과.
- **원인**: 토큰에 **purpose(목적)/channel(채널)/subject(사용자·주소)** 바인딩이 없음.

---

## 설계 원칙 (패턴)

1) **토큰 스키마**
   - 랜덤 6–8자리 숫자(사용성) 또는 base32/URL-safe(링크·앱 공용).
   - 서버에는 **해시**(SHA-256 등)만 저장.
   - **필드**: `token_hash`, `user_id`, `channel('email'|'sms')`, `destination(주소)`, `purpose('signup'|'login'|'reset'...)`, `issued_at`, `expires_at`, `used_at`, `attempts`, `max_attempts`, `version(낙관적 락)`, `latest(boolean)`.

2) **최신 토큰만 유효**
   - 발급 시 **기존 ‘latest=true’ 토큰을 모두 ‘false’**로 내리고, **새 토큰만 latest=true**.
   - 검증 시 **latest=true**인 레코드만 조회/검증.

3) **원자적 검증**
   - `UPDATE ... SET used_at=now() WHERE token_hash=? AND used_at IS NULL AND expires_at>now() AND latest=true RETURNING *`
   - 반환 없으면 실패. → **동시 두 호출 중 하나만 성공**.

4) **멱등 전송**
   - 전송 API는 **Idempotency-Key**(헤더/클라 생성)를 받아 **동일 키 재시도**는 **같은 토큰**을 재사용.
   - 또는 “최근 발급 후 60초 내면 **같은 토큰 재전송**” 정책.

5) **레이스·폭주 방지**
   - **쿨다운**: 동일 채널·목적·대상에 대해 30–60초 사이 재발급 거부(혹은 재전송).
   - **시도 제한**: `attempts++` 를 **원자적**으로 증가, 초과 시 블록.

6) **스코프 바인딩**
   - 토큰은 **purpose + channel + destination + user_id**에 **엄격히 묶음**.
   - 검증 시 4개 모두 일치해야 통과.

7) **TTL (권장)**
   - SMS/앱 OTP: **2–3분**.
   - 이메일 링크: **10–15분**.
   - UI엔 “남은 시간” 표시(사용성 ↑, 무한 재전송 ↓).

---

## 데이터 모델 (예: Postgres)

```sql
CREATE TABLE verify_token (
  id             bigserial PRIMARY KEY,
  token_hash     text NOT NULL,            -- SHA-256(base64url(token))
  user_id        uuid NOT NULL,
  channel        text NOT NULL CHECK (channel IN ('email','sms')),
  destination    text NOT NULL,            -- E.164 phone / canonical email
  purpose        text NOT NULL,            -- 'signup'|'login'|'reset'|'change'
  issued_at      timestamptz NOT NULL DEFAULT now(),
  expires_at     timestamptz NOT NULL,
  used_at        timestamptz NULL,
  attempts       int NOT NULL DEFAULT 0,
  max_attempts   int NOT NULL DEFAULT 5,
  latest         boolean NOT NULL DEFAULT true,
  version        int NOT NULL DEFAULT 0
);

-- 같은 컨텍스트의 "최신 토큰"은 하나만 허용 (부분 유니크 인덱스)
CREATE UNIQUE INDEX verify_token_latest_uniq
  ON verify_token (user_id, channel, destination, purpose)
  WHERE latest = true;

-- 빠른 조회용
CREATE INDEX verify_token_fast_lookup ON verify_token (token_hash, purpose);
```

---

## Node.js/Express + Postgres/Prisma (예제)

### — **멱등 + 최신만 유효 + 쿨다운**

```ts
// utils/otp.ts
import crypto from "node:crypto";
export function genNumericOtp(len = 6) {
  // 000000~999999 균등, 앞자리 0 허용
  const n = crypto.randomInt(0, 10 ** len);
  return n.toString().padStart(len, "0");
}
export function sha256b64url(s: string) {
  return crypto.createHash("sha256").update(s).digest("base64url");
}

// routes/verify.ts
router.post("/verify/issue", async (req, res) => {
  const { userId, purpose, channel, destination } = normalize(req.body);
  const idemKey = req.get("Idempotency-Key") || null;

  // 1) 쿨다운(60s) — 최신 토큰이 있고 60초 내면 재사용
  const latest = await prisma.verify_token.findFirst({
    where: { user_id: userId, purpose, channel, destination, latest: true },
    orderBy: { issued_at: "desc" }
  });
  const now = new Date();
  const withinCooldown = latest && (now.getTime() - latest.issued_at.getTime()) < 60_000;

  let token, tokenHash, expiresAt;
  if (withinCooldown && idemKey) {
    // 멱등 재시도 — 기존 토큰 재전송
    token = null; // 우리는 평문 토큰을 저장하지 않으므로, 재전송 시 새 토큰을 만들 수밖에 없음.
    // 전략 1: 쿨다운 동안은 "성공"만 응답하고, 실제 전송은 하지 않음(UX 주의)
    // 전략 2(권장): 평문 토큰을 절대 저장하지 않으므로, 쿨다운 동안에도 "새 토큰 생성" + 기존 latest=false 처리
  }

  // 2) 새 토큰 생성
  token = genNumericOtp(6);
  tokenHash = sha256b64url(token);
  expiresAt = new Date(Date.now() + 3 * 60_000); // 3분

  await prisma.$transaction(async (tx) => {
    // 기존 latest=false
    await tx.verify_token.updateMany({
      where: { user_id: userId, purpose, channel, destination, latest: true },
      data: { latest: false }
    });
    // 새 토큰 insert
    await tx.verify_token.create({
      data: {
        token_hash: tokenHash,
        user_id: userId,
        purpose, channel, destination,
        expires_at: expiresAt,
        latest: true
      }
    });
  });

  // 3) 전송 (실서비스에선 SMS/Email 공급자 호출)
  await sendOtp(channel, destination, token);

  // 4) 응답: 남은 시간 등만
  return res.json({ ok: true, ttlSec: 180 });
});
```

> **포인트**
> - 평문 토큰은 **서버에 저장하지 않음**(유출 대비).
> - 새 토큰을 만들 때 **기존 latest를 false**로 내려 **항상 최신만 유효**.
> - “재전송”은 보안상 **“같은 토큰 재전송”보다 “새 토큰 발급 + 최신만 유효”**가 안전합니다.

### 검증 — **원자 UPDATE + 시도 제한**

```ts
router.post("/verify/confirm", async (req, res) => {
  const { userId, purpose, channel, destination, code } = normalize(req.body);
  const tokenHash = sha256b64url(code);

  // 1) 원자적 소비(consume)
  const updated = await prisma.$executeRawUnsafe<any[]>(`
    UPDATE verify_token
       SET used_at = now()
     WHERE token_hash = $1
       AND user_id = $2
       AND purpose = $3
       AND channel = $4
       AND destination = $5
       AND latest = true
       AND used_at IS NULL
       AND expires_at > now()
     RETURNING id;
  `, tokenHash, userId, purpose, channel, destination);

  if (Array.isArray(updated) && updated.length === 1) {
    // 2) 성공 처리: 사용자 상태 갱신 등 (ex. email_verified=true)
    await markVerified(userId, channel, destination, purpose);
    return res.json({ ok: true });
  }

  // 3) 실패: 시도 카운트 + rate limit
  await prisma.$executeRawUnsafe(`
    UPDATE verify_token
       SET attempts = attempts + 1
     WHERE user_id=$1 AND purpose=$2 AND channel=$3 AND destination=$4 AND latest=true
  `, userId, purpose, channel, destination);

  const vt = await prisma.verify_token.findFirst({
    where: { user_id: userId, purpose, channel, destination, latest: true }
  });
  if (vt && vt.attempts >= vt.max_attempts) {
    // 차단/쿨다운
    return res.status(429).json({ ok: false, error: "too_many_attempts" });
  }
  return res.status(400).json({ ok: false, error: "invalid_or_expired" });
});
```

> **원자성**: “조회 후 업데이트”가 아니라 **조건부 UPDATE + RETURNING**으로 **단 1회만 성공**시킵니다.
> **시도 카운트**도 **서버가** 관리해야 하며, **코드당/시간당/하루당** 제한을 함께 둡니다.

---

## Redis(또는 캐시)로 구현하는 **속도 제한 & 레이스 방지**

### 재전송 쿨다운(키: `otp:issue:{purpose}:{dest}`)

```js
// 60초 내 재발급 금지
const key = `otp:issue:${purpose}:${channel}:${destination}`;
const ok = await redis.set(key, "1", { NX: true, EX: 60 });
if (!ok) return res.status(429).json({ ok:false, error:"cooldown" });
```

### 확인 시도 제한(슬라이딩 윈도우)

```js
const key = `otp:attempts:${purpose}:${channel}:${destination}:${today()}`;
const tries = await redis.incr(key);
if (tries === 1) await redis.expire(key, 86400);
if (tries > 20) return res.status(429).json({ ok:false, error:"rate_limited" });
```

### **Lua 스크립트**로 “검증 + 소비”를 **원자적**으로

```lua
-- verify_consume.lua
-- KEYS[1] = token_key (e.g., "otp:token:<hash>")
-- token_key value: JSON {expires, used, latest, user, channel, dest, purpose}
-- 원자적으로 used=false -> true 로 바꾸고 TTL 체크
local v = redis.call('GET', KEYS[1])
if not v then return 0 end
local obj = cjson.decode(v)
if obj.used or obj.expires < tonumber(ARGV[1]) or (not obj.latest) then return 0 end
obj.used = true
redis.call('SET', KEYS[1], cjson.encode(obj))
return 1
```

> RDBMS를 주 저장소로 쓰되, **고속 제한·쿨다운**은 Redis가 효율적입니다.

---

## 스코프 바인딩 & 상태 머신

### 스코프/컨텍스트 모델

- `purpose`: `signup | login | reset | change_email | change_phone`
- `channel`: `email | sms`
- `destination`: `user@example.com` / `+821012345678` (E.164)
- `subject`: `user_id` (사용자 없음(회원가입)이라면 `pending_user_id`/세션 토큰)

**검증 시** 이 4가지가 모두 일치해야 합니다. (다르면 **무조건 실패**)

### 상태 전이(State)

```
ISSUED -> (EXPIRED | USED | MAX_ATTEMPTS)
USED   -> (VERIFIED flag set, others invalidated)
```

- “Change” 흐름(이메일/전화 변경): **새 연락처 검증 성공 + 기존 연락처 확인(선택)** + **계정 비밀번호 확인**을 결합(고위험).
- “로그인 OTP”(passwordless)는 **기존 세션 전부 무효화** 또는 **동일 디바이스 바인딩**을 고려.

---

## 이메일 vs SMS: 실무 팁

- **이메일 링크**: 긴 랜덤(32바이트) **URL 토큰** + 10–15분 TTL.
- **SMS 코드**: 6자리 숫자 + 2–3분 TTL.
- **메시지 콘텐츠**: 코드만 노출(민감 정보 포함 X). “유효시간·요청자 본인 여부 안내” 포함.
- **국제 전화**: 항상 **E.164** 정규화(+국가코드). VoIP/임시 번호 **블록**(공급자 분석).

---

## UI/UX로 보안 보조

- **비가시적 쿨다운 표시**: “다시 보내기(59초)” 카운트다운으로 과도한 전송 방지.
- **남은 시간 표시**: 사용자 혼란 ↓, 오타·재전송 ↓.
- **자동 채움**: iOS/Android SMS-OTP 자동 인식(문구 템플릿) 사용. (하지만 **자동 제출은 금지**)

---

## 프레임워크별 간단 예

### Spring Boot — 조건부 UPDATE

```java
@Repository
public interface VerifyTokenRepo extends JpaRepository<VerifyToken, Long> {
  @Modifying
  @Query("""
    UPDATE VerifyToken v SET v.usedAt = CURRENT_TIMESTAMP
     WHERE v.tokenHash = :hash AND v.userId=:uid AND v.purpose=:purpose
       AND v.channel=:channel AND v.destination=:dest
       AND v.latest=true AND v.usedAt IS NULL AND v.expiresAt > CURRENT_TIMESTAMP
  """)
  int consume(@Param("hash") String hash, @Param("uid") UUID uid,
              @Param("purpose") String purpose, @Param("channel") String channel,
              @Param("dest") String dest);
}
```

### Django — `update(...)`로 원자 소비

```python
cnt = (VerifyToken.objects
       .filter(token_hash=token_hash, user=user, purpose=purpose,
               channel=channel, destination=dest, latest=True,
               used_at__isnull=True, expires_at__gt=timezone.now())
       .update(used_at=timezone.now()))
if cnt == 1:
    mark_verified(user, channel, dest, purpose)
else:
    increase_attempts(user, purpose, channel, dest)
```

---

## 전송 API 멱등화(Idempotency-Key)

```ts
// 공통 미들웨어: 같은 키면 같은 응답 되돌려줌
app.use(async (req, res, next) => {
  const key = req.get("Idempotency-Key");
  if (!key) return next();
  const cacheKey = `idem:${req.path}:${key}`;
  const cached = await redis.get(cacheKey);
  if (cached) return res.json(JSON.parse(cached));
  const json = res.json.bind(res);
  res.json = (body: any) => {
    redis.set(cacheKey, JSON.stringify(body), { EX: 60 }); // 1분 보관
    return json(body);
  };
  next();
});
```

---

## 관측/로깅/탐지

- **로그 필드**: `purpose`, `channel`, `dest_hash`, `issued`, `verified`, `ttl`, `attempts`, `ip`, `device_id`.
- **탐지 룰**
  - 목적/대상별 **발급 대비 성공률** 급락 → 인수인계/전송 실패.
  - IP/디바이스별 발급/시도 급증 → **폭주/공격**.
  - “latest=false 토큰으로 성공 시도” 포착 → **재사용/리플레이 탐지**.

---

## — **막혀야 정상**

### 레이스: 동일 코드 동시 제출 → 단 1회만 성공

```ts
it('race: only one confirm succeeds', async () => {
  const { code, ctx } = await issueFor(user);
  const req = () => request(app).post('/verify/confirm').send({ ...ctx, code });
  const [a, b] = await Promise.all([req(), req()]);
  const codes = [a.status, b.status].sort();
  expect(codes).toEqual([200, 400]); // 하나만 성공
});
```

### 중복 전송 → 최신만 통과

```ts
it('only latest token works', async () => {
  const first = await issueFor(user);        // code1
  await wait(1500);
  const second = await issueFor(user);       // code2 -> latest
  expect(await confirm(first.code, first.ctx)).toHaveProperty('status', 400);
  expect(await confirm(second.code, second.ctx)).toHaveProperty('status', 200);
});
```

### 스코프/바인딩 확인

```ts
it('wrong channel/destination fails', async () => {
  const { code, ctx } = await issueFor(user, { channel:'sms', dest:'+8210...' });
  const bad = { ...ctx, channel:'email', dest:'user@example.com' };
  expect(await confirm(code, bad)).toHaveProperty('status', 400);
});
```

---

## 안티패턴(피해야 할 것)

- **클라이언트 저장 상태**(“이 코드는 이미 사용했어”를 클라가 기억) → 서버 권한 없음.
- **조회 후 업데이트**(두 단계) → 레이스에서 둘 다 성공.
- **여러 개의 유효 토큰**(재전송을 “추가 발급”으로 구현) → 어느 것이든 통과.
- **긴 TTL(>10분)**, **무제한 재시도**.
- **스코프/채널 바인딩 없음** → 다른 목적/대상에서 재사용.
- **이미 사용한 토큰 재사용 허용**(“성공 후에도 true로 안 바꿈”).
- **토큰 평문 저장**.

---

## 체크리스트 (현장용)

- [ ] 토큰은 **1회성**, 성공 시 **즉시 used_at 설정**(원자 UPDATE)
- [ ] **최신(latest=true) 토큰만 유효**, 발급 시 이전 latest=false
- [ ] TTL: SMS 2–3분, 이메일 링크 10–15분 (UI 남은 시간 표기)
- [ ] **쿨다운 30–60s**, 재전송은 새 토큰 발급(과거 무효)
- [ ] **시도 제한**: 코드당 3–5회, 일/대상 10–20회, IP/디바이스 rate-limit
- [ ] **스코프 바인딩**: purpose+channel+destination+user_id 모두 일치 필요
- [ ] **서버 저장 상태**: attempts/used/expires를 DB/Redis에 기록
- [ ] **Idempotency-Key** 로 전송 멱등화
- [ ] 전화번호 **E.164 정규화**, 이메일 **표준화**
- [ ] 로깅/경보: 발급↔성공률, latest=false 사용 시도, 레이스 실패율
- [ ] CI: 레이스/중복/스코프 테스트 자동화

---

## 맺음말

이메일·전화 검증은 **간단해 보여도 동시성·상태·전송 신뢰성** 문제가 얽히면 쉽게 뚫립니다.
**서버 주도의 상태 머신 + 1회성/최단 TTL + 최신만 유효 + 원자 업데이트** 조합을 표준으로 삼으면
토큰 재사용·중복 전송·레이스에 의한 우회를 **구조적으로 차단**할 수 있습니다.
