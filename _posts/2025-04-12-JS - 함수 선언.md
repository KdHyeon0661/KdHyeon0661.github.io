---
layout: post
title: JavaScript - 함수 선언
date: 2025-04-12 21:20:23 +0900
category: JavaScript
---
# 함수 선언 방법 (function 선언식, 함수 표현식, 화살표 함수 등)

## 0) 빠른 로드맵

| 구분 | 호이스팅 | `this` | `arguments` | `new` | 주 용도 |
|---|---|---|---|---|---|
| **함수 선언식** | O(함수 객체까지) | 동적 결정 | O | O | 라이브러리/토대 함수 |
| **함수 표현식** | 식이라 X (변수는 선언만 호이스팅) | 동적 결정 | O | O | 지역 정의/콜백 |
| **화살표 함수** | 식이라 X (변수는 선언만 호이스팅) | **렉시컬** | **없음** | **불가** | 콜백/간단 연산 |
| **메서드 단축 표기** | (프로퍼티 정의 시점) | 동적 결정 + `super` | O | O | 객체/클래스 메서드 |
| **제너레이터 `function*`** | 선언식/표현식과 동일 | 동적 결정 | O | O | 이터러블/코루틴 |
| **`async` 함수** | 선언식/표현식과 동일 | 동적 결정 | O | O | 비동기 순차화 |

---

## 1) 함수 선언식 (Function Declaration)

### 기본 형태 & 호이스팅
```js
console.log(add(2, 3)); // 5 — 선언식은 함수 객체까지 호이스팅
function add(a, b) { return a + b; }
```
- **전역/함수 스코프의 시작 시점**에 **함수 바인딩 + 함수 객체**가 준비된다.
- 블록 안 선언식은 환경에 따라 다르게 동작했지만(구 브라우저), **모듈/엄격 모드 기준**으로는 **블록 스코프에 함수가 생성**된다. 안정성을 위해 블록 내부는 **함수 표현식**을 권장.

### 이름/길이/프로토타입
```js
function greet(name) { return `Hello, ${name}`; }
console.log(greet.name);   // "greet"
console.log(greet.length); // 1 (선언된 파라미터 수)
console.log(greet.prototype); // { constructor: f }
```

---

## 2) 함수 표현식 (Function Expression)

### 익명/이름 있는 함수 표현식
```js
const f1 = function (x) { return x * 2; };   // 익명
const f2 = function double(x) { return x * 2; }; // 이름 있음

console.log(f2.name); // "double"
```
- **이름 있는 함수 표현식**은 내부 재귀/디버깅에 유리. 외부 바인딩 이름이 변경되어도 내부 이름으로 재귀 가능.

### 호이스팅 규칙
```js
// console.log(sum(1,2)); // ReferenceError: TDZ
const sum = function (a,b){ return a+b; };
```
- 변수는 호이스팅되지만(선언만), 초기화 전 **TDZ**라 접근 불가.

---

## 3) 화살표 함수 (Arrow Function)

### 문법 축약 & 암시적 반환
```js
const inc  = x => x + 1;
const pair = (a, b) => ({ a, b }); // 객체 리터럴은 괄호로 감싸기
```

### 렉시컬 this / arguments 없음 / new 불가
```js
const counter = {
  n: 0,
  incLater() {
    setTimeout(() => { // 화살표: this는 상위(incLater의 this=counter)
      this.n++;
      console.log(this.n);
    }, 0);
  }
};
counter.incLater();

const fx = (...args) => args; // arguments 대신 **rest** 사용
// new fx(); // TypeError: 화살표는 생성자 불가
```

### 금기: 객체 메서드에 화살표을 기본으로 쓰지 말 것
```js
const obj = {
  x: 1,
  m() { console.log(this.x); },     // 1 (메서드 단축 표기 권장)
  a: () => console.log(this.x),     // 전역/외부 this → undefined 가능
};
obj.m();
obj.a(); // 상황에 따라 undefined
```

> **원칙**: 메서드/생성자/오버라이드가 필요한 곳 → `function`/메서드 표기.  
> 콜백/간단 매핑/상위 `this`가 필요할 때 → 화살표.

---

## 4) 즉시 실행 함수(IIFE)와 초기화 패턴

```js
(function () {
  // 모듈 초기화, 프라이빗 스코프
  const secret = 42;
  console.log("init");
})();
```

- 모듈(ESM) 시대에는 파일 스코프 자체가 격리되므로 IIFE 필요성 ↓.  
  단, **브라우저 비모듈 스크립트**나 **즉각 초기화**에는 여전히 유용.

---

## 5) 생성자 함수, `new`, `new.target`

### 생성자 함수 규칙
```js
function Person(name) {
  // 암묵적으로 this = Object.create(Person.prototype)
  this.name = name;
  // 암묵적으로 return this
}
const p = new Person("Alice");
console.log(p instanceof Person); // true
```

### `new.target`으로 잘못된 호출 방지
```js
function Service() {
  if (!new.target) throw new Error("use new");
}
new Service(); // OK
// Service();  // Error
```

### 프로토타입 메서드 부여
```js
function Point(x, y) { this.x = x; this.y = y; }
Point.prototype.len = function () { return Math.hypot(this.x, this.y); };
console.log(new Point(3,4).len()); // 5
```

> 화살표 함수는 **프로토타입이 없고 new 불가** — 생성자 금지.

---

## 6) 메서드 단축 표기 & `super`

```js
const base = { hi() { return "base"; } };
const obj  = {
  __proto__: base,
  hi() {
    return super.hi() + " + obj"; // super는 메서드 단축 표기에서만 안전
  }
};
console.log(obj.hi()); // "base + obj"
```

---

## 7) `this` 바인딩 — 호출 방식에 의해 결정(화살표 제외)

### 7.1 기본 규칙
- **메서드 호출**: `obj.m()` → `this === obj`.
- **단독 호출**: `f()` → 비엄격: 전역 객체, 엄격: `undefined`.
- **생성자 호출**: `new F()` → 새 인스턴스.
- **`call/apply/bind`**로 명시 바인딩.

```js
function show(){ console.log(this.tag); }
const o = { tag:"O", show };
show.call(o); // O
const s = show.bind({tag:"B"}); s(); // B
```

### 7.2 DOM 이벤트 리스너
```js
button.addEventListener("click", function(){
  // this === button
});
button.addEventListener("click", () => {
  // this === 상위(대개 window/module undefined)
});
```

---

## 8) `arguments` vs Rest 파라미터

```js
function legacy() {
  console.log(arguments.length, arguments[0]);
}
const modern = (...args) => {
  console.log(args.length, args[0]);
};
legacy(1,2);  // 2 1
modern(1,2);  // 2 1
```
- `arguments`는 **유사배열 객체**(화살표 없음).  
- **Rest(`...args`)**는 진짜 배열, 타입 안정/TS 친화, 디폴트 파라미터와 잘 맞는다.

---

## 9) 디폴트/구조분해 파라미터 & 검증

```js
function createUser(id, { email, role = "user" } = {}) {
  if (!email) throw new Error("email required");
  return { id, email, role };
}
console.log(createUser(1, { email: "a@b.com" })); // { id:1, email:..., role:"user" }
```

---

## 10) 제너레이터 함수 `function*` & `yield`

```js
function* idGen(start=0) {
  let n = start;
  while (true) yield n++;
}
const g = idGen(10);
console.log(g.next().value); // 10
console.log(g.next().value); // 11
```
- **이터레이터 + 이터러블** 동시 구현.  
- 복잡한 순회/상태 기계/코루틴 스타일에 유용.

---

## 11) `async` 함수 & `await`

```js
async function fetchText(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(r.statusText);
  return r.text();
}
```
- `async` 함수는 **Promise**를 반환.  
- `for await...of`와 결합하면 스트림형 처리 가능.

---

## 12) 함수의 속성: `name`, `length`, `prototype`

```js
function f(a, b=0, ...rest) {}
console.log(f.name);   // "f"
console.log(f.length); // 1 (디폴트 이후/Rest 제외)
console.log("prototype" in f); // true (화살표는 false)
```

---

## 13) 블록 내부 함수 선언 — 안전 가이드

```js
if (cond) {
  // 상황에 따라 구현체를 고르려면 다음이 안전
  const impl = function () { /* ... */ };
  impl();
}
```
- **표준화 이후** 블록 내 함수도 블록 스코프가 되지만, 오래된 런타임/번들러 호환성을 고려하면 **표현식 + const**를 권장.

---

## 14) 모듈 스코프 vs 스크립트 스코프

- **ESM(모듈)**: 파일 스코프 격리, 최상단 `this===undefined`, top-level await 가능.
- **스크립트**: 전역 `var`는 `window`에 붙음. IIFE로 충돌 완화.

---

## 15) 설계 패턴과 베스트 프랙티스

### 15.1 API 함수(선언식) + 내부 구현(표현식)
```js
export function parse(input) { return _parseImpl(input); }
const _parseImpl = function (s) { /* 세부 구현 */ };
```

### 15.2 전략 주입(콜백은 화살표)
```js
function process(list, mapFn = x => x) {
  return list.map(mapFn);
}
```

### 15.3 부분 적용/커링(화살표가 간결)
```js
const add = a => b => a + b;
const add10 = add(10);
```

### 15.4 팩토리 vs 생성자
```js
function makePoint(x,y){ return {x,y, len(){return Math.hypot(x,y);} }; }
// new Point(x,y) 패턴과 선택적으로 병행
```

---

## 16) 금기/함정 모음

1. **메서드에 화살표 남용**: `this`가 모호해짐.  
2. **`arguments` 의존**: 대신 **rest**를 쓰자.  
3. **블록 함수 선언 남발**: 표현식 권장.  
4. **생성자에서 `return` 객체**를 명시적으로 돌려주면 `this`가 무시됨.  
5. **`bind` 잊고 메서드 분리 호출**
   ```js
   const { push } = Array.prototype;
   // push([1,2], 3) // TypeError — this 바인딩 없음
   ```

---

## 17) 실전 예제 모음

### 17.1 `this` 비교: 선언식/메서드/화살표
```js
function who(){ return this?.tag; }
const ctx = { tag: "CTX", who };
console.log(ctx.who());     // "CTX"
console.log(who());         // undefined(엄격 모드)

const obj = {
  tag: "OBJ",
  method() { return this.tag; },
  arrow:  () => this?.tag    // 상위 스코프의 this
};
console.log(obj.method()); // "OBJ"
console.log(obj.arrow());  // undefined 가능
```

### 17.2 `call/apply/bind`
```js
function sum(a,b){ return this.k + a + b; }
const k10 = { k: 10 };
console.log(sum.call(k10, 1, 2));   // 13
console.log(sum.apply(k10, [1, 2])); // 13

const plus10 = sum.bind(k10, 1); // a=1 고정
console.log(plus10(5)); // 16
```

### 17.3 제너레이터로 청크 순회
```js
function* chunks(arr, n=2){
  for (let i=0; i<arr.length; i+=n) yield arr.slice(i, i+n);
}
for (const c of chunks([1,2,3,4,5], 2)) console.log(c); // [1,2],[3,4],[5]
```

### 17.4 async 함수와 에러 경계
```js
async function safe(fn) {
  try { return [await fn(), null]; }
  catch (e) { return [null, e]; }
}
```

### 17.5 이름 있는 함수 표현식으로 재귀
```js
const fact = function f(n){ return n<=1 ? 1 : n * f(n-1); };
console.log(fact(5)); // 120
```

---

## 18) 퀵 레퍼런스 (요약 표)

| 항목 | 선언식 | 표현식 | 화살표 | 메서드 표기 | 제너레이터 | async |
|---|---|---|---|---|---|---|
| 문법 | `function f(){}` | `const f=function(){}` | `const f=()=>{}` | `m(){}` | `function* g(){}` | `async function a(){}` |
| hoisting | 함수 객체까지 | 변수 선언만 | 변수 선언만 | 프로퍼티 정의 시 | 선언식/표현식 규칙 | 선언식/표현식 규칙 |
| this | 동적 | 동적 | **렉시컬** | 동적(+super) | 동적 | 동적 |
| arguments | O | O | **X** | O | O | O |
| new | O | O | **X** | O(메서드는 보통 아님) | O | O |
| 주 용도 | 공용 API | 지역/콜백 | 콜백/간결 | 객체/클래스 | 순회/코루틴 | 비동기 |

---

## 19) 미니 퀴즈

```js
// Q1: 출력?
console.log(A());      // ?
function A(){ return 1; }
const B = function(){ return 2; };
// console.log(B());   // ?

// Q2: 무엇이 잘못?
const X = {
  v: 1,
  inc: () => { this.v++; } // ?
};

// Q3: 생성자 검사
function S(){ if (!new.target) throw Error("use new"); }
S();        // ?
new S();    // ?

// Q4: arguments 대체
const sum = (...xs) => xs.reduce((a,b)=>a+b,0);
```

**힌트**  
- Q1: 선언식은 호이스팅됨, 표현식은 TDZ/초기화 전 호출 불가.  
- Q2: 화살표의 `this`는 상위 스코프 → `X`가 아님. 메서드 표기로.  
- Q3: `S()`는 오류, `new S()`는 정상.

---

## 20) 결론 & 베스트 프랙티스

- **API/토대 함수**: 선언식(`function f(){}`) — 호이스팅으로 사용 편의/가독성 ↑.  
- **지역 구현/콜백**: 표현식/화살표(`const f = () => {}`) — 스코프·TDZ 명료.  
- **메서드/오버라이드**: **메서드 단축 표기** 또는 `function` — `this/super` 안전.  
- **생성자/프로토타입**: `function` + `new.target` 체크.  
- **콜백에서의 this**: 상위 this가 필요하면 **화살표**, 필요 없으면 보통 함수.  
- `arguments` 대신 **rest** 사용, 블록 내부는 **표현식 권장**.

의도와 실행 모델을 일치시키는 선언 방식을 선택하라.  
그것만으로도 **디버깅 비용**을 줄이고, **API 표면**을 안정적으로 유지할 수 있다.