---
layout: post
title: 알고리즘 - 순열과 조합
date: 2025-01-20 21:20:23 +0900
category: 알고리즘
---
# 순열과 조합 완전 정리

## 0. 용어와 표기

- \(n\): 전체 원소 수, \(r\): 뽑는 수, \(n!\): 팩토리얼
- **순열**: **순서가 중요**한 뽑기  
  $$ {}_{n}P_{r} = \frac{n!}{(n-r)!} $$
- **조합**: **순서가 중요하지 않**은 뽑기  
  $$ {n \choose r} = \frac{n!}{r!(n-r)!} $$

“순서가 중요하면 순열, 아니면 조합”이라는 핵심 기준을 일관되게 유지하자.

---

## 1. 순열과 조합의 차이 — 확장 비교표

| 구분 | 순열 \( {}_{n}P_{r} \) | 조합 \( {n \choose r} \) |
|---|---|---|
| 순서 | 중요 | 중요하지 않음 |
| 개수 | \( \dfrac{n!}{(n-r)!} \) | \( \dfrac{n!}{r!(n-r)!} \) |
| 대표 활용 | 경로/스케줄, 연산자 배치, 배치 문제 | 팀 구성, 부분집합, 선택 |
| 생성 | `itertools.permutations(arr, r)` | `itertools.combinations(arr, r)` |
| 복잡도 | 생성 자체가 지수적(\(nPr\)) | 지수적(\(nCr\)) |
| 중복 허용 변형 | 중복 순열 \(n^r\), 다중집합 순열 | 중복 조합 \({n+r-1 \choose r}\) |

---

## 2. 감으로 시작 — 예시 재정리

`[1,2,3]`에서 2개를 고른다면:
- 순열: (1,2), (2,1), (1,3), (3,1), (2,3), (3,2) → 6개  
  수식 \( {}_{3}P_{2} = 3 \times 2 = 6 \)
- 조합: (1,2), (1,3), (2,3) → 3개  
  수식 \( {3 \choose 2} = 3 \)

---

## 3. 파이썬에서의 기초 — `itertools`

```python
from itertools import permutations, combinations, product, combinations_with_replacement

arr = [1, 2, 3]

# 순열 (중복 없이 순서 중요)
for p in permutations(arr, 2):
    print("perm:", p)  # (1,2),(1,3),(2,1),(2,3),(3,1),(3,2)

# 조합 (순서 무관)
for c in combinations(arr, 2):
    print("comb:", c)  # (1,2),(1,3),(2,3)

# 중복 순열(중복 허용, 순서 중요) -> n^r 모든 데카르트 곱
for p in product(arr, repeat=2):
    print("prod:", p)  # (1,1),(1,2),...

# 중복 조합(순서 무관, 중복 허용)
for c in combinations_with_replacement(arr, 2):
    print("cwr:", c)   # (1,1),(1,2),(1,3),(2,2),(2,3),(3,3)
```

- 중복 순열의 경우의 수: \( n^r \)  
- 중복 조합의 경우의 수: \( {n+r-1 \choose r} \)

---

## 4. 직접 구현 — 재귀/백트래킹 템플릿 (안전한 기본형)

### 4.1 순열(중복 없는 선택)

```python
def permute(arr, r):
    n = len(arr)
    used = [False]*n
    path = []
    def dfs():
        if len(path) == r:
            yield path[:]
            return
        for i in range(n):
            if not used[i]:
                used[i] = True
                path.append(arr[i])
                yield from dfs()
                path.pop()
                used[i] = False
    yield from dfs()
```

### 4.2 조합(오름차순 인덱스 증가)

```python
def combine(arr, r):
    n = len(arr)
    path = []
    def dfs(start):
        if len(path) == r:
            yield path[:]
            return
        for i in range(start, n):
            path.append(arr[i])
            yield from dfs(i+1)
            path.pop()
    yield from dfs(0)
```

- 위 형태는 **메모리 복사 최소화**, **yield 기반**으로 대량 생성에 적합.

---

## 5. 중복 원소가 있는 경우의 순열/조합

### 5.1 멀티셋 순열(같은 값 중복 방지)

```python
from collections import Counter

def permute_multiset(arr):
    cnt = Counter(arr)
    path, n = [], len(arr)
    def dfs():
        if len(path) == n:
            yield path[:]
            return
        for x in list(cnt.keys()):
            if cnt[x] > 0:
                cnt[x] -= 1
                path.append(x)
                yield from dfs()
                path.pop()
                cnt[x] += 1
    yield from dfs()
```

- 전체 개수는
  $$
  \frac{n!}{\prod_{v} \alpha_v!}
  $$
  (\(\alpha_v\): 값 \(v\)의 중복도)

### 5.2 조합에서 중복 원소 처리
- **값 자체가 중복**되어도 “조합(집합적 선택)”에서는 중복된 결과를 제거해야 하므로, **정렬+스킵** 패턴 사용.

```python
def unique_combinations(arr, r):
    arr = sorted(arr)
    n = len(arr)
    path = []
    def dfs(start, need):
        if need == 0:
            yield path[:]
            return
        prev = None
        for i in range(start, n - need + 1):
            if arr[i] == prev:  # 같은 값 시작 스킵
                continue
            prev = arr[i]
            path.append(arr[i])
            yield from dfs(i+1, need-1)
            path.pop()
    yield from dfs(0, r)
```

---

## 6. 조합론 정체성(항등식) — 문제 풀이에 바로 쓰는 공식

1) 대칭성  
   $$
   {n \choose r} = {n \choose n-r}
   $$

2) 파스칼 항등식  
   $$
   {n \choose r} = {n-1 \choose r} + {n-1 \choose r-1}
   $$
   → DP/삼각형 표 구성의 기본

3) 이항정리  
   $$
   (x+y)^n = \sum_{r=0}^{n} {n \choose r} x^{n-r} y^{r}
   $$

4) 중복 조합(별과 막대/Stars and Bars)  
   $$
   \text{중복조합}(n, r) = {n+r-1 \choose r}
   $$

5) 이항계수 합  
   $$
   \sum_{r=0}^{n} {n \choose r} = 2^n,\quad 
   \sum_{r=0}^{n} r {n \choose r} = n 2^{n-1}
   $$

6) 멀티노미얼 계수(다항정리)  
   $$
   \frac{n!}{\alpha_1! \alpha_2! \cdots \alpha_k!}
   $$
   (\(\sum \alpha_i = n\)): 서로 다른 \(k\)종을 주어진 분할로 배치

---

## 7. 생성 전략 고급: 사전식(lexicographic)/비트마스크/다음 순열

### 7.1 사전식 다음 순열(next_permutation) — O(n)

- 아이디어:  
  (1) 뒤에서 처음 감소하는 위치 \(i\)를 찾음  
  (2) \(i\) 뒤에서 \(a[i]\)보다 큰 가장 오른쪽 원소 \(j\)를 찾음  
  (3) \(a[i]\)↔\(a[j]\) 교환, suffix를 역순 정렬

```python
def next_permutation(a):
    n = len(a)
    i = n - 2
    while i >= 0 and a[i] >= a[i+1]:
        i -= 1
    if i == -1:
        return False
    j = n - 1
    while a[j] <= a[i]:
        j -= 1
    a[i], a[j] = a[j], a[i]
    a[i+1:] = reversed(a[i+1:])
    return True
```

### 7.2 조합의 사전식 다음 조합(비트마스크)

- 크기 \(r\)인 조합을 비트마스크로 표현해 **다음 조합**으로 이동(스치워츠/거싱 알고리즘)

```python
def next_combination(x):
    # x: r개의 1을 가진 비트마스크, 다음 사전식 조합 마스크
    u = x & -x
    v = x + u
    if v == 0:  # overflow
        return 0
    return v + (((v ^ x) // u) >> 2)
```

- 예: `x=0b00101100` (세 개의 1) → 다음 조합의 비트마스크 계산

### 7.3 부분집합 열거(비트마스크)

```python
def all_subsets(arr):
    n = len(arr)
    for mask in range(1<<n):
        yield [arr[i] for i in range(n) if mask & (1<<i)]
```

- 전체 \(2^n\)개, \(n\le 20\) 정도에서 실전 가능.

---

## 8. 랭킹/언랭킹 — 순열/조합의 인덱스화

### 8.1 팩토리얼 진법(순열 랭킹/언랭킹)

- 순열 \(p\)의 **사전식 순서 index**(0-based)를 계산:
  $$
  \mathrm{rank}(p) = \sum_{i=0}^{n-1} \big(\text{p[i]보다 뒤에 있는 작은 수의 개수}\big) \cdot (n-1-i)!
  $$

```python
import math

def perm_rank(p):  # p: 0..n-1의 순열
    n = len(p)
    rank = 0
    used = [False]*n
    for i in range(n):
        smaller = sum(1 for x in range(p[i]) if not used[x])
        rank += smaller * math.factorial(n-1-i)
        used[p[i]] = True
    return rank

def perm_unrank(n, rank):
    # n 길이 순열 중 사전식 순서가 rank인 것
    import math
    elems = list(range(n))
    res = []
    for i in range(n-1, -1, -1):
        f = math.factorial(i)
        idx = rank // f
        rank %= f
        res.append(elems.pop(idx))
    return res
```

### 8.2 조합 랭킹/언랭킹

- 조합 \(C = \{c_1<\cdots<c_r\}\)의 rank:
  $$
  \mathrm{rank}(C) = \sum_{i=1}^{r} {c_i \choose i}
  $$
  (0-based, 원소는 0..n-1)

```python
import math

def nCr(n, r):
    if r < 0 or r > n: return 0
    return math.comb(n, r)

def comb_rank(n, comb):  # comb: sorted indices
    rank = 0
    for i, ci in enumerate(comb, 1):
        rank += nCr(ci, i)
    return rank

def comb_unrank(n, r, rank):
    res = []
    x = n - 1
    for i in range(r, 0, -1):
        while nCr(x, i) > rank:
            x -= 1
        res.append(x)
        rank -= nCr(x, i)
        x -= 1
    return res[::-1]
```

---

## 9. 모듈러 조합 — 큰 수에서의 \(nCr \bmod M\)

### 9.1 소수 모듈러 \(M=p\): 팩토리얼과 페르마

- 전처리:
  $$
  \text{fac}[i]=i!\bmod p,\quad
  \text{invfac}[i] = (i!)^{-1} \bmod p
  $$
- 페르마 소정리: \(a^{p-1}\equiv 1\pmod p\) → \(a^{-1}\equiv a^{p-2}\pmod p\)

```python
def modpow(a, e, p):
    r = 1
    a %= p
    while e:
        if e & 1: r = (r*a) % p
        a = (a*a) % p
        e >>= 1
    return r

def prepare_fac(p, N):
    fac = [1]*(N+1)
    for i in range(2, N+1):
        fac[i] = fac[i-1]*i % p
    invfac = [1]*(N+1)
    invfac[N] = modpow(fac[N], p-2, p)
    for i in range(N, 0, -1):
        invfac[i-1] = invfac[i]*i % p
    return fac, invfac

def nCr_mod_p(n, r, p, fac, invfac):
    if r < 0 or r > n: return 0
    return fac[n] * invfac[r] % p * invfac[n-r] % p
```

### 9.2 루카스 정리 — \(n,p\)가 매우 커도 가능

- \(p\)가 소수일 때:
  $$
  {n \choose r} \equiv \prod {n_i \choose r_i} \pmod p
  $$
  여기서 \(n_i, r_i\)는 각각 \(p\)진법 자릿수

```python
def nCr_lucas(n, r, p, fac, invfac):
    res = 1
    while n > 0 or r > 0:
        ni = n % p
        ri = r % p
        if ri > ni: 
            return 0
        res = res * nCr_mod_p(ni, ri, p, fac, invfac) % p
        n //= p
        r //= p
    return res
```

- 전처리 크기는 \(p-1\)까지만 있으면 충분.

---

## 10. DP와 백트래킹 — 실전 템플릿과 가지치기

### 10.1 조합 생성 + 제약(예: 암호 만들기, 모음≥1/자음≥2)

```python
def comb_with_constraints(chars, r):
    chars = sorted(chars)
    path = []
    vowels = set("aeiou")
    def ok():
        v = sum(ch in vowels for ch in path)
        c = len(path) - v
        return v >= 1 and c >= 2
    def dfs(start):
        if len(path) == r:
            if ok(): 
                yield ''.join(path)
            return
        # 남은 자리 수보다 남은 원소가 적으면 중단(프루닝)
        for i in range(start, len(chars) - ((r - len(path)) - 1)):
            path.append(chars[i])
            yield from dfs(i+1)
            path.pop()
    yield from dfs(0)
```

### 10.2 순열 + 평가(연산자 끼워넣기) — 상/하한 바운딩

- 현재까지의 최소/최대 가능 범위를 추정해 쓸모없는 탐색을 가지치기  
- 예: 남은 연산자를 모두 `+`로 쓰면 상한, 모두 `-`로 쓰면 하한 등을 계산

---

## 11. 실전 문제(BOJ) — 풀이 전략 정리와 예제

### 11.1 순열 관련

1) **10974 — 모든 순열**  
   전형: `itertools.permutations(range(1,n+1))`; 출력 형식 주의

```python
from itertools import permutations
n = int(input())
for p in permutations(range(1, n+1)):
    print(*p)
```

2) **15649 — N과 M (1)**  
   재귀 백트래킹 + 방문 배열

```python
n, m = map(int, input().split())
used = [False]*(n+1)
path = []
def dfs():
    if len(path) == m:
        print(*path)
        return
    for x in range(1, n+1):
        if not used[x]:
            used[x] = True
            path.append(x)
            dfs()
            path.pop()
            used[x] = False
dfs()
```

3) **14888 — 연산자 끼워넣기**  
   연산자 멀티셋 순열 + 평가(혹은 재귀로 연산자 카운트 소진)

```python
import sys
input = sys.stdin.readline
n = int(input())
nums = list(map(int, input().split()))
add, sub, mul, div = map(int, input().split())
mn, mx = 10**18, -10**18

def apply(a, b, op):
    if op == 0: return a + b
    if op == 1: return a - b
    if op == 2: return a * b
    if op == 3:
        if a < 0:
            return -((-a)//b)
        return a // b

def dfs(i, a, A, S, M, D):
    global mn, mx
    if i == n:
        mn = min(mn, a); mx = max(mx, a)
        return
    b = nums[i]
    if A: dfs(i+1, apply(a,b,0), A-1, S, M, D)
    if S: dfs(i+1, apply(a,b,1), A, S-1, M, D)
    if M: dfs(i+1, apply(a,b,2), A, S, M-1, D)
    if D: dfs(i+1, apply(a,b,3), A, S, M, D-1)

dfs(1, nums[0], add, sub, mul, div)
print(mx, mn, sep='\n')
```

### 11.2 조합 관련

1) **15650 — N과 M (2)**  
   오름차순 조합

```python
n, m = map(int, input().split())
path = []
def dfs(start):
    if len(path) == m:
        print(*path)
        return
    for x in range(start, n+1):
        path.append(x)
        dfs(x+1)
        path.pop()
dfs(1)
```

2) **6603 — 로또**  
   입력 묶음마다 6개 조합 출력

```python
from itertools import combinations
import sys
for line in sys.stdin:
    data = list(map(int, line.split()))
    if data[0] == 0: break
    k, arr = data[0], data[1:]
    for c in combinations(arr, 6):
        print(*c)
    print()
```

3) **1759 — 암호 만들기**  
   10.1의 제약 조합 템플릿으로 해결 가능(모음≥1, 자음≥2)

---

## 12. 복잡도/현실적인 한계와 변경 전략

- 순열/조합 **생성 자체가 지수적**:  
  - \( {}_{10}P_5 = 30,240 \) → 가능  
  - \( {}_{20}P_{10} \sim 6.7\times 10^{12} \) → 불가  
- 해법:
  1) **세는 문제**로 바꾸기(수학식/DP)  
  2) **조건을 이용한 가지치기**  
  3) **중간 결과 압축(메모이제이션)**  
  4) **meet-in-the-middle**: 반으로 나눠 합성

---

## 13. 자주 쓰는 수학/파이썬 API

### 13.1 `math.comb`, `math.perm`

```python
import math
print(math.comb(5, 2))  # 10
print(math.perm(5, 2))  # 20
```

### 13.2 큰 수 모듈러 조합(전처리 예)

```python
MOD = 1_000_000_007
NMAX = 1_000_000

fac = [1]*(NMAX+1)
for i in range(2, NMAX+1):
    fac[i] = fac[i-1]*i % MOD

invfac = [1]*(NMAX+1)
invfac[NMAX] = pow(fac[NMAX], MOD-2, MOD)
for i in range(NMAX, 0, -1):
    invfac[i-1] = invfac[i]*i % MOD

def nCr_mod(n, r):
    if r < 0 or r > n: return 0
    return fac[n]*invfac[r]%MOD*invfac[n-r]%MOD
```

---

## 14. 체크리스트 — 현업/시험에서 틀리는 포인트

1) 조합에서 **정렬/스킵 누락**으로 중복 결과 발생  
2) 나눗셈 내림 규칙(정수 나눗셈) 언어별 차이(파이썬 음수 나눗셈 처리)  
3) \(n,r\) 범위 커질 때 **팩토리얼 오버플로/시간 초과** → 모듈러/전처리/루카스  
4) 출력 형식(공백/줄바꿈)  
5) 재귀 한도(`sys.setrecursionlimit`)  
6) `itertools`는 **생성 순서**가 사전식임을 활용

---

## 15. 유형별 빠른 결정 가이드

| 문제 유형 | 권장 기법 |
|---|---|
| 모든 순열/조합 출력 | `itertools` 또는 템플릿(작은 n) |
| 제약 조합(최소/최대 개수 조건) | 조합 DFS + 프루닝 |
| 중복 원소 포함 순열 | `Counter` 기반 멀티셋 순열 |
| 개수만 계산(큰 n) | 수식/DP/모듈러 조합 |
| 다음 경우 하나만 생성 | `next_permutation` / 비트마스크 조합 |
| 인덱스↔케이스 변환 | 랭킹/언랭킹(팩토리얼 진법/조합 랭킹) |

---

## 16. 예제 모음 — 통합 연습

### 16.1 “합이 K인 부분집합의 개수” (조합+부분집합/DP)

- \(n\le 40\) → **meet-in-the-middle** 추천  
- \(n\le 20\) → 비트마스크로 전탐색 가능

```python
def count_subset_sum(arr, K):
    # n <= 20 정도
    n = len(arr)
    cnt = 0
    for mask in range(1<<n):
        s = 0
        for i in range(n):
            if mask & (1<<i):
                s += arr[i]
        if s == K:
            cnt += 1
    return cnt
```

### 16.2 “중복 조합으로 금액 만들기” (코인 변화)

- 중복으로 선택 가능, 순서 무관 → 중복 조합 카운팅 DP

```python
def coin_change_ways(coins, target):
    dp = [0]*(target+1)
    dp[0] = 1
    for c in coins:
        for s in range(c, target+1):
            dp[s] += dp[s-c]
    return dp[target]
```

---

## 17. 수식 요약

- 순열:
  $$
  {}_{n}P_{r} = \frac{n!}{(n-r)!}
  $$
- 조합:
  $$
  {n \choose r} = \frac{n!}{r!(n-r)!}
  $$
- 중복 순열:
  $$
  n^r
  $$
- 중복 조합:
  $$
  {n+r-1 \choose r}
  $$
- 파스칼:
  $$
  {n \choose r} = {n-1 \choose r} + {n-1 \choose r-1}
  $$
- 이항정리:
  $$
  (x+y)^n = \sum_{r=0}^{n} {n \choose r} x^{n-r} y^{r}
  $$

---

## 결론

초안의 핵심(차이/예시/표준 라이브러리/간단 구현/대표 문제)을 기반으로, **중복 허용/멀티셋, 생성 알고리즘, 랭킹/언랭킹, 모듈러 조합, DP/백트래킹 템플릿, 가지치기, 실제 대회 규모에서의 경계와 최적화**를 충분히 확장했다.  
실전에서는 **정의→생성/카운팅 결정→제약 모델링→프루닝/DP→모듈러/전처리** 순으로 문제를 구조화하라. 그러면 “순열/조합이 필요한가?”에서 출발해 **지수적 생성을 정말로 해야 하는지** 혹은 **수학/DP로 세기만 하면 되는지**를 빠르게 판단할 수 있다.