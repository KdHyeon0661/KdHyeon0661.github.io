---
layout: post
title: 운영체제 - 리눅스 시스템 (2)
date: 2025-11-05 18:25:23 +0900
category: 운영체제
---
# Chapter 21 — Windows 10 (2)

## Terminal Services and Fast User Switching

### 개념과 구조

- **Terminal Services(RDS)**: 하나의 Windows 커널 위에 **여러 사용자 세션(Session 1,2,…)**을 동시 제공. 각 세션은 **고유의 Window Station/Desktops/오브젝트 네임스페이스 일부**를 갖고, **세션 0**은 서비스만 사용(사용자 대화형 금지).
- **Fast User Switching(FUS)**: 현재 로그온 사용자의 애플리케이션을 **로그오프 없이 유지**한 채, 다른 사용자를 **추가 로그인**해 세션을 전환. Winlogon/GPU/DWM가 **세션 간 그래픽 콘솔**을 스위칭.
- **RDP(3389/TCP/UDP)**: GDI/DirectX 프레임을 **가상 채널**로 전송(그래픽/입력/오디오/프린트/클립보드). **NLA(CredSSP) + TLS** 로 인증/암호화.

핵심 컴포넌트
- `TermService`(서비스), **Winlogon**, **LSASS**(NLA), **rdpclip.exe**(클립보드), **DWM**(세션별 합성), **WDDM**(GPU 멀티 세션 스케줄링).
- API: **WTS*** (WTSEnumerateSessions, WTSQuerySessionInformation, WTSLogoffSession, WTSSendMessage), **ALPC** 기반 내부 IPC.

### 관리·관측 명령

```cmd
qwinsta                 :: 세션 나열(=query session)
quser                   :: 사용자/세션 상태
tscon <id> /dest:console:: 세션 전환(관리자)
logoff <id>             :: 특정 세션 로그오프
query termserver        :: 터미널 서버 정보
```

PowerShell로 세션/프로세스 매핑:
```powershell
Get-Process -IncludeUserName | Sort-Object SessionId,ProcessName |
  Select-Object SessionId,Id,ProcessName,UserName | Format-Table -Auto
```

### 예제 — WTS API로 세션 나열·메시지 보내기(C/C++)

```cpp
// wts_list_send.cpp : 세션 나열 후, 활성 세션에 메시지 전송
#include <windows.h>
#include <wtsapi32.h>
#include <stdio.h>
#pragma comment(lib, "Wtsapi32.lib")

int main() {
    PWTS_SESSION_INFO p = nullptr; DWORD count = 0;
    if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &p, &count)) {
        for (DWORD i=0;i<count;i++) {
            printf("SessionId=%lu, State=%d, WinStation=%ls\n",
                   p[i].SessionId, p[i].State, p[i].pWinStationName);
        }
        WTSFreeMemory(p);
    }
    DWORD sess = WTSGetActiveConsoleSessionId();
    DWORD resp=0;
    WTSSendMessageW(WTS_CURRENT_SERVER_HANDLE,
        sess, L"Maintenance", 22, L"5분 후 재부팅 예정입니다.", 28,
        MB_OK | MB_ICONINFORMATION, 30, &resp, TRUE);
    return 0;
}
```

### RDP 보안·성능 팁

- **NLA 필수**(계정 보호), **클립보드/프린터 리다이렉션 제한**, RD Gateway로 외부 접근 시 **TLS 강제**.
- **GPU 가속/프레임 제한**: WAN 환경에서는 비디오 재생 최적화 옵션 사용. 서버는 NIC **RSS/Receive Side Scaling**, **RSC**(Receive Segment Coalescing) 확인.
- 문제 해결: `Event Viewer → Applications and Services Logs → Microsoft → Windows → TerminalServices-*`, `netsh trace start capture=yes scenario=RemoteDesktop`.

---

## File System

### NTFS 핵심

- 모든 파일은 **MFT(마스터 파일 테이블)** 의 **속성(Attribute)** 집합. 데이터는 레지던트/논레지던트로 저장, 이름은 여러 개(하드링크).
- **보안**: ACL(DACL/SACL) + 상속, **EFS**(파일 단위 암호화), **BitLocker**(볼륨).
- **기능**: **압축**, **스파스**, **대체 데이터 스트림(ADS)**, **재분석 지점(Reparse Point)**(심볼릭 링크/점프션), **USN 저널**(변경 로그), **쿼터**, **VSS**(스냅샷).

경로/호환성
- **long path**: `\\?\C:\very\long\...` 접두사 또는 정책/레지스트리로 긴 경로 허용.
- **Per-directory case sensitivity**(WSL 호환): `fsutil file setCaseSensitiveInfo <dir> enable`.
- WOW64 리디렉션: `System32` ↔ `SysWOW64`(32비트 프로세스는 리디렉션됨).

### 링크/재분석 지점

```cmd
:: 하드링크(같은 볼륨 내)
fsutil hardlink create new_hardlink.txt original.txt

:: 디렉터리 점프션(동일 볼륨)
mklink /J data_link D:\Data

:: 심볼릭 링크(파일/디렉터리, 관리자 또는 개발자 모드)
mklink my.conf C:\etc\real.conf
mklink /D tools C:\SDK\Tools
```

### 대체 데이터 스트림(ADS)

```powershell
Set-Content -Path .\report.txt -Value "main"
Set-Content -Path .\report.txt:meta -Value "confidential"
Get-Item -Path .\report.txt -Stream *     # ADS 목록
Get-Content .\report.txt:meta
```

C/C++로 스트림 나열(Backup API 사용 간단 예):
```cpp
// list_streams.cpp : FindFirstStreamW로 ADS 나열
#include <windows.h>
#include <stdio.h>

int wmain(int argc, wchar_t** argv){
    if(argc<2){ wprintf(L"usage: %s <file>\n", argv[0]); return 1; }
    WIN32_FIND_STREAM_DATA d; HANDLE h=FindFirstStreamW(argv[1], FindStreamInfoStandard, &d, 0);
    if(h==INVALID_HANDLE_VALUE){ wprintf(L"no streams or error\n"); return 0; }
    do{ wprintf(L"%s (%lld bytes)\n", d.cStreamName, (long long)d.StreamSize.QuadPart); }
    while(FindNextStreamW(h, &d));
    FindClose(h); return 0;
}
```

### 스파스/압축/EFS 실습

```cmd
fsutil file createnew sparse.bin 10737418240
fsutil sparse setflag sparse.bin
fsutil sparse queryflag sparse.bin
compact /c big.log         :: NTFS 압축
cipher /E /A secrets       :: EFS(사용자 키 필요)
```

C#으로 스파스 파일 플래그 설정:
```csharp
using System;
using System.IO;
using System.Runtime.InteropServices;
class S {
  const uint FSCTL_SET_SPARSE = 0x900C4;
  [DllImport("kernel32", SetLastError=true)]
  static extern bool DeviceIoControl(IntPtr h, uint c, IntPtr inb, int inbs, IntPtr outb, int outbs, out int r, IntPtr o);
  static void Main(){
    using var fs = new FileStream("sparse.dat", FileMode.Create, FileAccess.ReadWrite, FileShare.None);
    DeviceIoControl(fs.SafeFileHandle.DangerousGetHandle(), FSCTL_SET_SPARSE, IntPtr.Zero, 0, IntPtr.Zero, 0, out _, IntPtr.Zero);
    fs.SetLength(1L<<34); // 16 GiB logical
  }
}
```

### USN 저널/VSS/쿼터

```cmd
fsutil usn queryjournal C:
vssadmin list shadows
fsutil quota track C:
fsutil quota modify C: 1 10737418240 CONTOSO\alice   :: 10GiB soft/hard 동일
```

### File Change 감시(Watcher)

```csharp
using System;
using System.IO;
class Watch {
  static void Main(){
    var w = new FileSystemWatcher(@"C:\logs"){IncludeSubdirectories=true,EnableRaisingEvents=true};
    w.Changed += (_,e)=> Console.WriteLine($"{e.ChangeType}: {e.FullPath}");
    w.Created += (_,e)=> Console.WriteLine($"Created: {e.FullPath}");
    w.Deleted += (_,e)=> Console.WriteLine($"Deleted: {e.FullPath}");
    Console.ReadLine();
  }
}
```

### NTFS 권한/ACL 팁

```powershell
# 특정 폴더에 사용자 전용 권한 부여(상속 차단)

$acl = Get-Acl C:\Data
$rule = New-Object System.Security.AccessControl.FileSystemAccessRule("CONTOSO\alice","Modify","ContainerInherit, ObjectInherit","None","Allow")
$acl.SetAccessRuleProtection($true,$false)
$acl.AddAccessRule($rule)
Set-Acl C:\Data $acl
```

---

## Networking

### 아키텍처 개요

- **Winsock**(user) ↔ **AFD.SYS** ↔ **TCPIP.SYS** ↔ **NDIS/Miniport**. 커널 HTTP 서버 **HTTP.SYS** 위에 IIS/HttpListener가 동작.
- **WFP(Windows Filtering Platform)**: 방화벽/IPS/필터 드라이버가 레이어별로 패킷을 검사/변경.
- **SMB3**: 암호화/다중채널/투명 페일오버. **RDMA(SMB Direct)** 지원 NIC에서 초저지연.
- 오프로딩: **RSS**, **RSC**, **TSO**, **Checksum Offload**, **LSO/GSO**.

상태 점검
```powershell
Get-NetAdapter | ft Name,Status,LinkSpeed
Get-NetAdapterAdvancedProperty -Name * | ft Name, DisplayName, DisplayValue
Get-NetTCPConnection | Group-Object State | ft Count,Name
```

Windows Firewall 규칙
```powershell
New-NetFirewallRule -DisplayName "Allow-MyApp" -Direction Inbound -Protocol TCP -LocalPort 5000 -Action Allow
```

네트워크 트레이스(내장 ETW)
```powershell
netsh trace start capture=yes persistent=no scenario=InternetClient level=verbose
# 재현 후

netsh trace stop   # .etl 생성 → Microsoft Message Analyzer/WPA에서 분석
```

### 예제 — Winsock TCP 에코 서버(간단, select)

```cpp
// ws_echo.cpp : 빌드 시 Ws2_32.lib 링크
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#pragma comment(lib,"Ws2_32.lib")

int main(){
    WSADATA w; WSAStartup(MAKEWORD(2,2), &w);
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    sockaddr_in a = {}; a.sin_family=AF_INET; a.sin_port=htons(9000); a.sin_addr.s_addr=htonl(INADDR_ANY);
    bind(s,(sockaddr*)&a,sizeof(a)); listen(s, SOMAXCONN);

    fd_set r; char buf[1<<16]; SOCKET cs[FD_SETSIZE]={}; int ncs=0;
    for(;;){
        FD_ZERO(&r); FD_SET(s,&r);
        for(int i=0;i<ncs;i++) FD_SET(cs[i],&r);
        select(0,&r,nullptr,nullptr,nullptr);
        if(FD_ISSET(s,&r)){ SOCKET c=accept(s,nullptr,nullptr); if(ncs<FD_SETSIZE) cs[ncs++]=c; }
        for(int i=0;i<ncs;i++){
            if(FD_ISSET(cs[i],&r)){
                int n = recv(cs[i],buf,sizeof(buf),0);
                if(n>0) send(cs[i],buf,n,0);
                else { closesocket(cs[i]); cs[i]=cs[--ncs]; i--; }
            }
        }
    }
}
```

### 최소 서버(C#)

```csharp
using System;
using System.Net;
using System.Text;

class H {
  static void Main(){
    var l = new HttpListener();
    l.Prefixes.Add("http://+:8080/"); l.Start();
    Console.WriteLine("Listening 8080...");
    for(;;){
      var c = l.GetContext();
      var b = Encoding.UTF8.GetBytes("OK");
      c.Response.ContentLength64 = b.Length;
      c.Response.OutputStream.Write(b,0,b.Length);
      c.Response.Close();
    }
  }
}
```
예약 필요(관리자 1회):
```cmd
netsh http add urlacl url=http://+:8080/ user=Everyone
```

### SMB/공유/자격 증명

```powershell
New-SmbShare -Name "Public" -Path "D:\Public" -FullAccess "CONTOSO\IT"
New-SmbMapping -LocalPath Z: -RemotePath \\filesrv\Public -UserName CONTOSO\alice -Password (Read-Host -AsSecureString)
```

### DNS/프록시/암호화

- DNS: `Get-DnsClientServerAddress`, NRPT(기업용), DoH(버전 의존).
- WinHTTP/WinINet: 서버 앱은 **WinHTTP**, 사용자 앱은 **WinINet** 권장.
- TLS: **SChannel**. 인증서 저장소(MMC Certificates snap-in)에서 관리, `netsh http show sslcert`로 바인딩 확인.

---

## Programmer Interface

### API 스펙트럼

- **Win32**: 파일/프로세스/스레드/동기화/윈도우 메시지/레지스트리.
- **Native(Nt/Zw)**: 문서화 적음(호환성 리스크).
- **COM/Automation**: 객체 모델, STA/MTA, 레지스트리 기반 활성화.
- **WinRT(Windows Runtime)**: 현대 COM(메타데이터), UWP/WinUI.
- **.NET**: CLR 기반 BCL, P/Invoke로 Win32 호출.
- **ETW**: 저오버헤드 추적(커널/사용자).
- **WMI/PowerShell**: 관리 자동화.

### 프로세스 생성·보안 토큰·임퍼스네이션

```cpp
// create_suspended_impersonate.cpp : 프로세스 생성→보안 토큰 확인(요약)
#include <windows.h>
#include <stdio.h>

int main(){
    STARTUPINFOW si{sizeof(si)}; PROCESS_INFORMATION pi{};
    CreateProcessW(L"C:\\Windows\\System32\\notepad.exe", NULL, NULL, NULL, FALSE,
                   CREATE_SUSPENDED, NULL, NULL, &si, &pi);

    HANDLE hTok = NULL;
    if (OpenProcessToken(pi.hProcess, TOKEN_QUERY, &hTok)) {
        DWORD sz=0; GetTokenInformation(hTok, TokenUser, NULL, 0, &sz);
        PTOKEN_USER tu = (PTOKEN_USER)LocalAlloc(0, sz);
        if(GetTokenInformation(hTok, TokenUser, tu, sz, &sz)){
            printf("token ok\n");
        }
        CloseHandle(hTok); LocalFree(tu);
    }
    ResumeThread(pi.hThread);
    CloseHandle(pi.hThread); CloseHandle(pi.hProcess);
}
```

### 핸들 상속/누수 방지

- 기본: `bInheritHandles=FALSE`, 필요한 핸들만 `SetHandleInformation(h, HANDLE_FLAG_INHERIT, …)` 후 명시 전달.
- **O_CLOEXEC 유사**: Windows는 **`HANDLE_FLAG_INHERIT` 비활성**이 기본. Job Object로 후속 프로세스 제어.

### P/Invoke — 하드링크 생성(C#)

```csharp
using System; using System.Runtime.InteropServices;
class HLinks {
  [DllImport("Kernel32.dll", CharSet=CharSet.Unicode, SetLastError=true)]
  static extern bool CreateHardLinkW(string newName, string existing, IntPtr sec);
  static void Main(){
    if(!CreateHardLinkW("copy.dat", "origin.dat", IntPtr.Zero))
      Console.WriteLine(Marshal.GetLastWin32Error());
  }
}
```

### COM 기초 — File Open Dialog 사용(C++)

```cpp
// com_filedialog.cpp : CoInitializeEx → IFileDialog
#include <windows.h>
#include <shobjidl.h>
#include <stdio.h>

int wmain(){
    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    IFileDialog* dlg=nullptr;
    if (SUCCEEDED(CoCreateInstance(CLSID_FileOpenDialog,nullptr,CLSCTX_INPROC_SERVER,IID_PPV_ARGS(&dlg)))) {
        if (SUCCEEDED(dlg->Show(NULL))) {
            IShellItem* item; if (SUCCEEDED(dlg->GetResult(&item))) {
                PWSTR path; item->GetDisplayName(SIGDN_FILESYSPATH, &path);
                wprintf(L"Selected: %ls\n", path); CoTaskMemFree(path); item->Release();
            }
        }
        dlg->Release();
    }
    CoUninitialize(); return 0;
}
```

### 로깅(C#)

```csharp
using System.Diagnostics.Tracing;
[EventSource(Name="Demo.App")]
public sealed class LogSrc : EventSource {
  public static LogSrc Log = new LogSrc();
  [Event(1, Level=EventLevel.Informational)] public void Started(string v)=>WriteEvent(1,v);
  [Event(2, Level=EventLevel.Error)] public void Fail(string msg,int code)=>WriteEvent(2,msg,code);
}
class Program { static void Main(){ LogSrc.Log.Started("1.0"); try { throw new Exception("oops"); } catch { LogSrc.Log.Fail("oops", 1);} } }
```
수집:
```powershell
wpr -start GeneralProfile -filemode
# 실행 후

wpr -stop app.etl
```

### 레지스트리/권한

```csharp
using Microsoft.Win32;
class R { static void Main(){
  using var k = Registry.CurrentUser.CreateSubKey(@"Software\DemoApp", true);
  k.SetValue("Level", 3, RegistryValueKind.DWord);
}}
```

### 쓰레드풀/IOCP 개념 요약

- **Overlapped I/O** + **I/O 완료 포트(IOCP)**: 대규모 소켓/파일 I/O에 효율적.
- .NET `SocketAsyncEventArgs`, `ThreadPoolBoundHandle`는 IOCP 위 래퍼.
- 핵심 패턴: 핸들을 `CreateIoCompletionPort` 로 포트에 연결 → `ReadFile/WriteFile`(OVERLAPPED) → `GetQueuedCompletionStatus` 루프에서 완료 처리.

(간단 패턴 스니펫 — C++)
```cpp
// pseudo_iocp.cpp (핵심 구조만)
HANDLE iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);
SOCKET s = /*…*/;
CreateIoCompletionPort((HANDLE)s, iocp, (ULONG_PTR)s, 0);
WSAOVERLAPPED ol = {}; WSABUF b{.len=8192, .buf=(CHAR*)malloc(8192)};
DWORD flags=0; WSARecv(s, &b, 1, NULL, &flags, &ol, NULL);
for(;;){
  DWORD nb; ULONG_PTR key; LPOVERLAPPED pol;
  GetQueuedCompletionStatus(iocp, &nb, &key, &pol, INFINITE);
  // nb 바이트 완료 처리 → 다음 요청 재등록
}
```

### 보안: ACL·무결성·AppContainer

- 파일/프로세스/레지스트리는 **보안 설명자(Security Descriptor)** 기반.
- **무결성 레벨(IL)**: Low/Medium/High/System — 브라우저/스토어앱 샌드박싱.
- **AppContainer**: UWP/샌드박스 프로세스 권한 모델(능력 Capabilities 선언).

AppContainer 실행(도구 필요)이나 **AppLocker/WDAC** 로 실행 제어: 관리 환경에서는 **서명 기반 화이트리스트**가 권장.

---

## 21.7.A 실전 시나리오 — “로그 수집·업데이트 안전화”

1) **서비스(Worker)** 로 동작, **Job Object** 로 하위 프로세스 제한.
2) 파일 I/O는 **NTFS 압축 + 대용량은 스파스**.
3) 전송은 **HTTP.sys + TLS**, 방화벽 인바운드 최소.
4) 업그레이드는 **핸들 상속 금지** + **파일 교체는 VSS 스냅샷**에서 원자적 복사.
5) 관측은 **ETW 이벤트** + WPR/WPA 분석.

---

## 문제 해결 체크리스트

- **세션 문제(RDP/FUS)**: `qwinsta`, 이벤트 로그(TerminalServices-*) 확인, NLA 실패(시간 동기화/자격 증명 정책) 점검.
- **파일 문제**: 경로 길이/권한/ADS/스파스/트랜잭션 잔재(TxF는 사용 지양) 확인. USN/VSS 상태 점검.
- **네트워크 성능**: RSS/RSC/TSO 설정, NIC 드라이버 최신화, `netsh trace`/Perf ETW로 RTT/재전송/큐 길이 진단.
- **API 호환**: Native API 의존 최소화, Win32/COM/WinRT의 명세된 계약 사용. 32/64bit 리디렉션 주의.

---

# 요약

- **Terminal Services/FUS**: 세션 분리와 안전한 RDP(의무 NLA/TLS), WTS API로 세션 제어.
- **File System**: NTFS 고급 기능(ADS/스파스/링크/USN/VSS)과 권한/경로 모델을 이해하면 대규모 배포·백업·보안이 쉬워진다.
- **Networking**: Winsock↔TCPIP.sys, WFP/Firewall, HTTP.sys/SMB3·오프로딩으로 안정성과 성능 확보.
- **Programmer Interface**: Win32/COM/WinRT/.NET/ETW 를 상황에 맞게 선택하고, 보안(토큰/ACL/IL/AppContainer)과 비동기 패턴(IOCP)으로 **안전하고 확장 가능한** Windows 앱을 설계하라.
