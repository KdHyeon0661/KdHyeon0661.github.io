---
layout: post
title: 논리회로설계 - 다단 게이트 회로 · NAND, NOR 설계 심화
date: 2025-09-03 16:25:23 +0900
category: 논리회로설계
---
# 다단 게이트 회로 · NAND/NOR 설계 심화 — **다단 NAND·NOR 회로 설계**, **게이트 심벌 변환(버블 로직)**, **2단(2-level)·다중 출력 회로**, **다중 출력 NAND/NOR 네트워크**

> 표기: \(+\)=OR, \(\cdot\) 또는 생략=AND, \(\overline{X}\)=NOT \(X\), \(X'=\overline{X}\), \(\oplus\)=XOR.
> 목표: (1) 임의의 부울식을 **NAND-only** 또는 **NOR-only**의 **다단(multilevel)** 회로로 체계적으로 구현, (2) **게이트 심벌(ANSI/IEC)** 과 **버블 로직**을 오가며 **극성 변환**, (3) **2단(2-level)**·**다중 출력** 설계 절차를 완비, (4) **다중 출력 NAND/NOR 네트워크**를 실제 예제로 완성하고 **검증 코드**까지 제공한다.
> 전제: (최소식 획득은 K-map/퀘인–맥클러스키/Espresso 등) — 본 문서는 **회로 합성·표현**에 초점.

---

## 한눈개요 — 2단 vs 다단, NAND vs NOR

- **2단(2-level)**: SOP→**NAND–NAND**, POS→**NOR–NOR**로 직결. 구조 단순·검증 용이.
- **다단(>2)**: 인수화/공유로 **팬인·배선·리터럴**을 줄여 **지연·전력**을 낮출 수 있음.
- **CMOS 물리 직관**: 같은 팬인이라면 일반적으로 **NAND가 NOR보다 빠름**(NOR의 pMOS 직렬 탓). 큰 팬인은 **분해/균형 트리**로.

---

## 다단 **NAND-only** / **NOR-only** 회로 설계

### 보편성(Functional Completeness)과 치환 레시피

- **NAND만으로**
  \[
  \overline{A}=A\,\text{NAND}\,A,\quad
  AB=\overline{(A\,\text{NAND}\,B)},\quad
  A+B=\overline{\overline{A}\cdot \overline{B}}=\overline{(A\,\text{NAND}\,A)\ (B\,\text{NAND}\,B)}
  \]
- **NOR만으로**
  \[
  \overline{A}=A\,\text{NOR}\,A,\quad
  A+B=\overline{A\,\text{NOR}\,B},\quad
  AB=\overline{\overline{A}+\overline{B}}=\overline{(A\,\text{NOR}\,A)+(B\,\text{NOR}\,B)}
  \]

> 핵심: **드모르간**과 **버블 푸시**(§2)를 반복해서 **모든 연산을 NAND 또는 NOR로 흡수**한다.

### 다단 **NAND-only** 합성 절차(실무 체크리스트)

1) **형태 선택**: 식을 SOP/계층형으로 **인수화**(팬인 분해).
2) **AND/OR를 NAND로 치환**:
   - \(X\cdot Y=\overline{(X\ \text{NAND}\ Y)}\) → 출력 보수 1개 생김
   - \(X+Y=\overline{\overline{X}\cdot \overline{Y}}\) → **입력 보수** 후 NAND
3) **보수 균형 맞추기**: 경로별 보수 개수 맞추거나 **출력에서 한 번만** 보수 제거.
4) **팬인 제한 준수**: 큰 NAND는 **두 단계**로 쪼개고, 공유 신호는 **한 번만 생성**.
5) **해저드**: 인접 항의 **중첩(합의항)**으로 글리치 여지 축소.

**예시 1 — NAND-only(다단)**
\[
F=(A+B)C+\overline{A}D
\]
- 보조:
  \[
  N_1=\text{NAND}(A,B)=\overline{A+B},\quad
  N_2=\text{NAND}(N_1,C)=\overline{\overline{A+B}\cdot C}=\overline{(A+B)C}
  \]
- \(\overline{A}=\text{NAND}(A,A)\),\ \(N_3=\text{NAND}(\overline{A},D)=\overline{\overline{A}D}\)
- 최종: \(F=\text{NAND}(N_2,N_3)=\overline{\,\overline{(A+B)C}\cdot \overline{\overline{A}D}\,}\)
→ **모든 게이트 NAND**. 출력 극성 **정상**(보수 균형 완료).

**예시 2 — 인수화로 단계/팬인 최적화**
\[
G=AB+AC+AD=A(B+C+D)
\]
- 큰 \(A\)-팬인을 줄이려면 \((B+C)\), \((S+D)\)를 **작은 NAND** 여러 개로 구성하고 마지막에 \(A\)와 결합.
→ 큰 한 게이트보다 **작은 팬인의 균형 트리**가 CMOS에서 대체로 유리.

### 다단 **NOR-only**(쌍대)

- OR는 1단 NOR로 보수, AND는 **입력 보수** 후 NOR.
- 출력에서 보수 균형 맞춤. 팬인이 커지면 NOR는 불리하므로 **분해/트리화**.

---

## **게이트 심벌 변환(버블 로직)** — ANSI/IEC와 극성

### 심벌 표기 요약

- **ANSI**: OR=곡선, AND=평평, **버블(작은 원) = 부정**.
- **IEC**: 직사각형 블록 + **핀 버블**로 극성 표기. **active-low**는 \(\overline{\text{RESET}}\), `*_L` 등.

### 규칙(암기 4줄)

1) **출력에 버블**이 붙으면 **NAND/NOR**.
2) **입력 버블**은 **입력 보수**와 동등.
3) **마주보는 버블**은 **상쇄**(인버터 2개 제거).
4) OR(출력 버블)+모든 입력 버블 ↔ **NAND**, AND(출력 버블)+모든 입력 버블 ↔ **NOR**.

**텍스트 변환 예 — POS→NOR-NOR**
```
F = (A + B) · (C + D)
M1 = NOR(A,B) = (A+B)'
M2 = NOR(C,D) = (C+D)'
F  = NOR(M1', M2')'   ; 버블 푸시로 중간 인버터를 앞/뒤에서 상쇄
→ 최종: 1단 NOR 2개, 2단 NOR 1개
```

### 네거티브 로직 해석(이중성)

- **양로직 NAND = 음로직 OR**, **양로직 NOR = 음로직 AND**.
- 문서화 시 극성 아이콘/버블을 명확히 표시하면 회로의 **이중 해석**이 가능.

---

## 설계** — 정석 매핑

### SOP → **NAND–NAND**

\[
F=P_1+P_2+\cdots+P_k=\overline{\overline{P_1}\cdot\cdots\cdot\overline{P_k}}
\]
- 1단: \(N_i=\text{NAND}(\text{리터럴들})=\overline{P_i}\)
- 2단: \(F=\text{NAND}(N_1,\dots,N_k)\)
- **보수 리터럴**(\(\overline{A}\))은 **입력 버블**(인버터)만으로.

### POS → **NOR–NOR**

\[
F=S_1S_2\cdots S_t=\overline{\overline{S_1}+\cdots+\overline{S_t}}
\]
- 1단: \(M_j=\text{NOR}(\text{리터럴들})=\overline{S_j}\)
- 2단: \(F=\text{NOR}(M_1,\dots,M_t)\)

### 2단 설계 팁

- [공유] **공통 곱항/합항**은 1단에서 **단 한 번** 생성(다중 출력 §4).
- [팬인] 라이브러리 상한(NAND3/NOR2 등) 초과 시 **분할/트리화**.
- [해저드] K-map에서 **중첩(합의항)** 추가로 글리치 여지 축소.

---

## **다중 출력** 설계 — 공유와 선택

### 전략

- \(\{F_k\}\)의 최소 SOP/POS를 얻고, **공유 항**을 1단에서 한 번만 생성 → 출력별 2단에서 **선택**.

### 다중 출력 **NAND–NAND**(SOP 기반)

- 1단: \(P_i\) → \(N_i=\overline{P_i}\) **한 번만** 만든다.
- 출력 \(F_k=\overline{\prod_{i\in\mathcal{S}_k}\overline{P_i}}\).

### 다중 출력 **NOR–NOR**(POS 기반)

- 1단: \(S_j\) → \(M_j=\overline{S_j}\) **한 번만** 만든다.
- 출력 \(F_k=\overline{\sum_{j\in\mathcal{T}_k}\overline{S_j}}\).

### 주의

- 공유 노드 **팬아웃 증가** → 버퍼링/업사이징.
- 출력 간 커플링 글리치 가능 → 필요 시 **레지스터 분리**.

---

## **다중 출력 NAND/NOR 네트워크 — 완전 예제**

### 사양

\[
\begin{aligned}
F_1 &= AB + AC + \overline{B}D \\
F_2 &= \overline{A}C + BD
\end{aligned}
\quad\Rightarrow\quad
\text{공유 곱항: } AC,\ BD
\]

### + 공유**

```verilog
module multi_out_nand(
  input  logic A,B,C,D,
  output logic F1,F2
);
  // 입력 보수(입력 버블 역할)
  logic nA = ~A, nB = ~B;

  // 1단: 공유 곱항을 각각 1번만 NAND로 생성(출력은 보수)
  logic nP1, nP2, nP3, nP4, nP5;
  assign nP1 = ~(A  & B);     // (AB)'
  assign nP2 = ~(A  & C);     // (AC)'
  assign nP3 = ~(nB & D);     // (B' D)'
  assign nP4 = ~(nA & C);     // (A' C)'
  assign nP5 = ~(B  & D);     // (BD)'

  // 2단: 출력별 선택(NAND)
  assign F1 = ~(nP1 & nP2 & nP3); // AB + AC + B'D
  assign F2 = ~(nP4 & nP5);       // A'C + BD
endmodule
```

### 동일 사양의 **NOR–NOR(2단, POS)** 스케치

- 각 출력의 POS를 작성 → 공유 **합항**을 1단 NOR로 한 번만 생성 → 2단 NOR로 결합.

### 해저드 안전화(옵션)

- \(F_1\)의 \(AB\)–\(AC\) 경계 정적-1 해저드 가능 → **합의항 \(BC\)** 추가:
  \[
  F_1' = AB + AC + \underline{BC} + \overline{B}D
  \]
- 구현: 1단에 \(BC\)용 NAND 1개 추가, 2단 \(F_1\) 입력에만 연결(다른 출력 영향 없음).

---

## 성능·물리 고려 — 팬인/팬아웃, 지연, 전력

### 팬인·지연(논리적 노력 직관)

- **인버터**: \(g\!\approx\!1\), \(p\!\approx\!1\)
- **NAND2**: \(g\!\approx\!4/3\), **NOR2**: \(g\!\approx\!5/3\) (공정/셀마다 다름, 경향만)
- 큰 팬인은 \(g,p\) 모두 증가 → **균형 트리**가 유리.

### 팬아웃·배선

- 공유 노드 팬아웃↑ → **버퍼/업사이징**.
- 긴 배선 RC↑ → **리피터 삽입**·경로 분할.

### 전력·글리치

- 합의항으로 중첩을 만들면 **불필요 토글↓**.
- 동기 경계에 **레지스터** 배치로 글리치 흡수.

---

## 버블 로직 실전 변환 — 손으로 하는 절차

1) **목표 게이트군**(NAND-only/NOR-only) 결정.
2) 각 서브식에 버블을 추가/이동하며 **드모르간** 적용.
3) **마주보는 버블을 상쇄**하고 **입력 버블**로 보수 리터럴 처리.
4) 동일 극성의 연속 게이트는 **게이트 종류 교환**으로 합칠 수 있는지 확인(AOI/OAI 대체).

**간단 표(동등성)**
| 원형 | 버블 이동 후 동치 |
|---|---|
| OR + 입력 버블 전부 + 출력 버블 | NAND |
| AND + 입력 버블 전부 + 출력 버블 | NOR |
| NAND(양로직) | OR(음로직) |
| NOR(양로직) | AND(음로직) |

---

## 검증 코드 — 진리표/심볼릭 등가성

### Python 진리표로 **다중 출력 회로** 검증

```python
from itertools import product

def F1_ref(A,B,C,D):
    return (A and B) or (A and C) or ((not B) and D)

def F2_ref(A,B,C,D):
    return ((not A) and C) or (B and D)

def multi_out_nand(A,B,C,D):
    nA, nB = (not A), (not B)
    nP1 = not (A and B)
    nP2 = not (A and C)
    nP3 = not (nB and D)
    nP4 = not (nA and C)
    nP5 = not (B and D)
    F1 = not (nP1 and nP2 and nP3)
    F2 = not (nP4 and nP5)
    return F1, F2

ok = True
for A,B,C,D in product([0,1],[0,1],[0,1],[0,1]):
    f1r, f2r = F1_ref(A,B,C,D), F2_ref(A,B,C,D)
    f1m, f2m = multi_out_nand(A,B,C,D)
    ok &= (f1r==f1m and f2r==f2m)
print("Equivalent:", ok)
```

### `sympy`로 최소식·등가성(선택)

```python
# pip install sympy

from sympy import symbols
from sympy.logic.boolalg import simplify_logic, Equivalent
A,B,C,D = symbols('A B C D')
F1 = (A&B) | (A&C) | (~B&D)
F2 = (~A&C) | (B&D)
print("F1 (DNF):", simplify_logic(F1, form='dnf'))
print("F2 (DNF):", simplify_logic(F2, form='dnf'))
# NAND-only 네트워크의 불식과 등가성도 검증 가능(전개해서 Equivalent 확인)

```

---

## 패턴 라이브러리 — 자주 쓰는 변환 레시피

- **XOR**: \(A\oplus B = \overline{A}B + A\overline{B}\) → 1단 NAND 2개 + 2단 NAND 1개 + 입력 보수 2개(혹은 카리 체인/XOR 셀 사용).
- **MUX**: \(Y=\overline{S}D_0 + SD_1\) → NAND-only: \(nS=\text{NAND}(S,S)\), \(n0=\text{NAND}(nS,D_0)\), \(n1=\text{NAND}(S,D_1)\), \(Y=\text{NAND}(n0,n1)\).
- **대형 OR/AND**: 균형 트리 + **AOI/OAI**로 레벨/지연 축소.

---

## 실전 체크리스트

- [ ] **최소 SOP/POS** 확보(공유 항 표시).
- [ ] **SOP→NAND–NAND**, **POS→NOR–NOR** 스케치 후 **버블 푸시**로 인버터 최소화.
- [ ] **공유 1단**(product/sum term)을 한 번만 생성하고 **출력별 선택**.
- [ ] **팬인 상한** 준수(분해/트리화), **팬아웃** 버퍼링.
- [ ] **해저드**는 합의항/중첩으로 완화, 동기 경계로 흡수.
- [ ] 문서화 시 **ANSI/IEC** 심벌·active-low 핀 일관 유지.

---

## 연습문제(스스로 검증 스크립트로 확인 권장)

1) \(F=AB+\overline{A}C+BC\) 를 **2단 NAND–NAND**로 설계하라.
   - (a) 필수 **입력 인버터 수**, (b) 각 게이트 **팬인**, (c) 정적-1 해저드 여부와 **합의항** 제시.

2) \(F=(A+B)(A+\overline{C})(B+D)\) 를 **2단 NOR–NOR**로 구현하고, **NOR3 금지** 제약이 있을 때 **다단 분해** 설계를 제시하라.

3) \(F=AC+BD\) 를 (a) **NAND–NAND**, (b) **NOR–NOR**로 각각 구현하고, **균형 트리**로 분해했을 때 지연이 줄어드는 이유를 **논리적 노력** 관점으로 설명하라.

4) 다중 출력: \(F_1=AB+AC+\overline{B}D,\ F_2=\overline{A}C+BD\).
   - (a) 공유 곱항을 1단에서 한 번만 생성, (b) 각 출력 2단으로 선택, (c) Python 진리표로 등가성 확인.

5) 심벌 변환: AND 게이트 **입력 2개 버블 + 출력 버블**이 **NOR**과 동치임을 **버블 푸시** 도식으로 증명하라.

---

## 포켓 요약

- **SOP→NAND–NAND**, **POS→NOR–NOR**, 버블 푸시로 **인버터 최소화**.
- 다단에서는 **인수화/공유/트리화**로 **팬인·배선·지연**을 줄인다.
- 같은 팬인이라면 **NAND가 NOR보다 대체로 빠름** — 큰 NOR은 피하고 분해.
- 다중 출력은 **공유 1단 + 출력별 선택**, 해저드는 **합의항/중첩**으로 완화.
- 검증은 **진리표/심볼릭 동치**로 자동화하고, 문서화는 **ANSI/IEC + 버블 로직** 일관 유지.
