---
layout: post
title: Data Structure - μ—°κ²° λ¦¬μ¤νΈ κ³ κΈ‰
date: 2024-12-09 20:20:23 +0900
category: Data Structure
---
# νΉμν• μ—°κ²° λ¦¬μ¤νΈλ“¤

μ•μ„ λ‹¨μΌ(Singly), μ΄μ¤‘(Doubly), μ›ν•(Circular) μ—°κ²° λ¦¬μ¤νΈλ¥Ό μ‚΄ν΄λ΄¤μµλ‹λ‹¤.  
μ΄λ² κΈ€μ—μ„λ” **λ³΄λ‹¤ κ³ κΈ‰μ΄κ±°λ‚ νΉμν• μ—°κ²° λ¦¬μ¤νΈ κµ¬μ΅°λ“¤**μ„ μ†κ°ν•©λ‹λ‹¤.

---

## 1. λ‹¤μ¤‘ μ—°κ²° λ¦¬μ¤νΈ (Multi-level / Multi-pointer Linked List)

### κµ¬μ΅°

λ…Έλ“κ°€ **2κ° μ΄μƒμ λ°©ν–¥(ν¬μΈν„°)**μΌλ΅ μ—°κ²°λλ” λ¦¬μ¤νΈμ…λ‹λ‹¤. μ£Όλ΅ **2μ°¨μ› μ΄μƒμ λ°μ΄ν„°**λ¥Ό ν‘ν„ν•  λ• μ‚¬μ©λ©λ‹λ‹¤.

μ:  
- ν‘ ν•νƒ λ°μ΄ν„° (μ¤ν”„λ λ“μ‹νΈ)
- νΈλ¦¬μ λ¦¬μ¤νΈ ν‘ν„
- μ§€ν• λ§µ, λ§μΈν¬λν”„νΈ μ›”λ“ κµ¬μ„± λ“±

### κµ¬μ΅° μμ‹ (2D μ—°κ²° λ¦¬μ¤νΈ)

```cpp
struct Node {
    int data;
    Node* right;
    Node* down;
};
```

### μ‚¬μ© μ

```cpp
Node* createMatrix(int rows, int cols) {
    Node* head = nullptr;
    std::vector<Node*> prevRow(cols, nullptr);

    for (int i = 0; i < rows; ++i) {
        Node* rowHead = nullptr;
        Node* prev = nullptr;
        for (int j = 0; j < cols; ++j) {
            Node* newNode = new Node{i * cols + j, nullptr, nullptr};
            if (!rowHead) rowHead = newNode;
            if (prev) prev->right = newNode;
            if (i > 0) prevRow[j]->down = newNode;
            prevRow[j] = newNode;
            prev = newNode;
        }
        if (!head) head = rowHead;
    }
    return head;
}
```

---

## 2. μ¤ν‚µ λ¦¬μ¤νΈ (Skip List)

### κ°λ…

μ •λ ¬λ μ—°κ²° λ¦¬μ¤νΈμ— **λ‹¤λ‹¨κ³„ ν¬μΈν„°λ¥Ό μ¶”κ°€**ν•μ—¬, μ΄μ§„ νƒμƒ‰μ²λΌ λΉ λ¥΄κ² νƒμƒ‰μ΄ κ°€λ¥ν• κµ¬μ΅°μ…λ‹λ‹¤.  
μ‚½μ…/μ‚­μ /νƒμƒ‰ λ¨λ‘ ν‰κ· μ μΌλ΅ `O(log n)` μ‹κ°„μ— μν–‰λ©λ‹λ‹¤.

> μ •λ ¬λ λ°μ΄ν„°κ°€ λ§μ€ κ²½μ°, νΈλ¦¬λ³΄λ‹¤ κµ¬ν„μ΄ κ°„λ‹¨ν•λ©΄μ„λ„ λ†’μ€ μ„±λ¥μ„ κΈ°λ€ν•  μ μμµλ‹λ‹¤.

### κµ¬μ΅°

κ° λ…Έλ“λ” **λ‹¤μμ ν¬μΈν„°**(λ‹¤μ λ λ²¨ ν¬μΈν„° ν¬ν•¨)λ¥Ό κ°€μ§‘λ‹λ‹¤.

```cpp
struct SkipNode {
    int val;
    std::vector<SkipNode*> forward;
    SkipNode(int level, int val) : val(val), forward(level + 1, nullptr) {}
};
```

### κ°„λ‹¨ν• κ°λ…λ„

```
Level 2:  A ------------> E
Level 1:  A --> B --> C --> E
Level 0:  A -> B -> C -> D -> E
```

### μ¥μ 

- λ™μ  νΈλ¦¬ κµ¬μ΅° μ—†μ΄λ„ `O(log n)` νƒμƒ‰ κ°€λ¥
- ν•΄μ‹ ν…μ΄λΈ”λ³΄λ‹¤ μμ°¨ μ ‘κ·Όμ΄ μ©μ΄

### μ‹¤μ‚¬μ© μ

- Redis λ‚΄λ¶€μ—μ„ μ¤μ½”μ–΄ μ •λ ¬μ„ μ„ν•΄ μ‚¬μ©
- MemTable (LSM-tree κΈ°λ° DB)

---

## 3. XOR μ—°κ²° λ¦¬μ¤νΈ (XOR Linked List)

### κ°λ…

**prev**μ™€ **next** ν¬μΈν„°λ¥Ό ν•λ‚λ΅ μ¤„μ—¬ λ©”λ¨λ¦¬λ¥Ό μ μ•½ν•λ ¤λ” νΉμ κµ¬μ΅°μ…λ‹λ‹¤.

- `node->npx = prev ^ next` (XOR μ—°μ‚° μ‚¬μ©)
- λ‹¨λ°©ν–¥ νƒμƒ‰λ§ κ°€λ¥ν•λ©°, μ΄μ „ μ£Όμ†λ¥Ό λ°λ“μ‹ κΈ°μ–µν•κ³  μμ–΄μ•Ό λ‹¤μ λ…Έλ“λ¥Ό μ• μ μμ

### κµ¬μ΅°

```cpp
struct Node {
    int data;
    Node* npx;  // XOR(prev, next)
};
```

### μ£Όμ μ‚¬ν•­

- μ‹¤μ  μ‚¬μ©μ€ λ“λ­…λ‹λ‹¤
- λ””λ²„κΉ… λ° μ μ§€λ³΄μ λ§¤μ° μ–΄λ ¤μ›€
- C++μ—μ„  `uintptr_t` λ“±μ„ μ‚¬μ©ν•΄μ•Ό μ•μ „ν•κ² κµ¬ν„ κ°€λ¥

---

## 4. μ„Όν‹°λ„¬ λ…Έλ“λ¥Ό κ°€μ§„ μ—°κ²° λ¦¬μ¤νΈ (Sentinel Nodes)

### κ°λ…

**ν—¤λ“/ν…μΌ λ…Έλ“μ— λ”λ―Έ λ…Έλ“**λ¥Ό λ―Έλ¦¬ μƒμ„±ν•΄λ‘μ–΄, μ‚½μ…/μ‚­μ  λ΅μ§μ„ λ‹¨μν™”ν•λ” ν…ν¬λ‹‰μ…λ‹λ‹¤.

### μ¥μ 

- μ—£μ§€ μΌ€μ΄μ¤λ¥Ό μ¤„μ„ (λΉ λ¦¬μ¤νΈ, λ¨Έλ¦¬/κΌ¬λ¦¬ μ‚½μ… λ“±)
- ν•­μƒ μ¤‘κ°„ μ‚½μ…μ²λΌ μ²λ¦¬ κ°€λ¥

### κµ¬μ΅°

```cpp
struct Node {
    int data;
    Node* prev;
    Node* next;
};

struct List {
    Node* sentinel;
    List() {
        sentinel = new Node{-1, nullptr, nullptr};
        sentinel->next = sentinel->prev = sentinel;
    }
};
```

---

## 5. Unrolled Linked List (λ¶„ν•΄λ μ—°κ²° λ¦¬μ¤νΈ)

### κ°λ…

κ° λ…Έλ“κ°€ λ°μ΄ν„°λ¥Ό ν•λ‚λ§ κ°€μ§€μ§€ μ•κ³  **μ—¬λ¬ κ°μ μ”μ†(μ‘μ€ λ°°μ—΄)**λ¥Ό μ €μ¥ν•λ” κµ¬μ΅°μ…λ‹λ‹¤.

### νΉμ§•

- **μΊμ‹ μΉν™”μ **
- μΌλ° μ—°κ²° λ¦¬μ¤νΈλ³΄λ‹¤ κ³µκ°„ ν¨μ¨κ³Ό μ ‘κ·Ό ν¨μ¨μ΄ μΆ‹μ

```cpp
struct UnrolledNode {
    std::vector<int> values;
    UnrolledNode* next;
};
```

### μ‚¬μ© μ

- Pythonμ deque λ‚΄λ¶€ κµ¬ν„
- μΌλ¶€ ν…μ¤νΈ νΈμ§‘κΈ° (μ¤„ λ‹¨μ„ μΊμ‹ μ €μ¥)

---

## 6. Self-referential / Looping List

### κ°λ…

λ…Έλ“κ°€ μκΈ° μμ‹ μ„ μ°Έμ΅°ν•κ±°λ‚ μν™μ„ ν•μ„±ν• λ¦¬μ¤νΈμ…λ‹λ‹¤.  
μ΄λ” μΌλ°μ μΈ μ›ν• λ¦¬μ¤νΈμ™€ λ‹¬λ¦¬ **νΉμ • μ΅°κ±΄ ν•μ— μΌλ¶€ λ…Έλ“λ§ λ£¨ν”„λ¥Ό ν•μ„±**ν•  μ μμµλ‹λ‹¤.

### μ£Ό μ©λ„

- λ£¨ν”„ νƒμ§€ μ•κ³ λ¦¬μ¦ (Floydβ€™s cycle detection λ“±)
- λ©”λ¨λ¦¬ κ²€μ‚¬ ν…μ¤νΈ

---

## π” μ •λ¦¬

| μ΄λ¦„ | νΉμ§• | μ‚¬μ© μ©λ„ |
|------|------|-----------|
| λ‹¤μ¤‘ μ—°κ²° λ¦¬μ¤νΈ | λ…Έλ“κ°€ μƒ/ν•/μΆ/μ° λ“± λ‹¤λ°©ν–¥ μ—°κ²° | 2D λ°μ΄ν„°, μ§€ν• λ“± |
| μ¤ν‚µ λ¦¬μ¤νΈ | λΉ λ¥Έ νƒμƒ‰μ© κ³„μΈµν• λ¦¬μ¤νΈ | Redis λ“± DB λ‚΄λ¶€ |
| XOR λ¦¬μ¤νΈ | ν¬μΈν„° ν•λ‚λ΅ prev/next λ™μ‹ ν‘ν„ | μ΄λ΅ μ  ν¥λ―Έ, λ©”λ¨λ¦¬ μµμ ν™” |
| μ„Όν‹°λ„¬ λ¦¬μ¤νΈ | λ”λ―Έ λ…Έλ“λ΅ μ‚½μ…/μ‚­μ  λ‹¨μν™” | μ•μ •μ„± μλ” κµ¬ν„ |
| Unrolled λ¦¬μ¤νΈ | ν• λ…Έλ“μ— μ—¬λ¬ κ°’ μ €μ¥ | μΊμ‹ μµμ ν™” |
| λ£¨ν”„ λ¦¬μ¤νΈ | μν™ κ²€μ¶ λ©μ  | μ•κ³ λ¦¬μ¦ ν…μ¤νΈ |