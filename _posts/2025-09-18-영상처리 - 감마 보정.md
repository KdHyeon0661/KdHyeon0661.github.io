---
layout: post
title: 영상처리 - 감마 보정
date: 2025-09-18 21:25:23 +0900
category: 영상처리
---
# 감마 보정

## 1) 개념: 지수(멱) 변환과 감마 보정

### 1.1 지수(멱) 변환(Power-law transform)
정규화된 픽셀값 \(x \in [0,1]\)에 대해, 지수 \( \gamma>0 \)를 적용하는 변환:

\[
y \;=\; x^{\,\gamma}
\]

- \( \gamma > 1 \)이면 **어두워지고**, \( \gamma < 1 \)이면 **밝아진다**.
- 8-bit 채널 \(v \in \{0..255\}\)에 직접 쓰면:

\[
v' \;=\; \left\lfloor 255 \cdot \left(\frac{v}{255}\right)^{\gamma} + 0.5 \right\rfloor
\]

### 1.2 감마 보정(Gamma correction)의 맥락
디스플레이/이미지 파이프라인에서는 흔히 **비선형 응답**(sRGB 등)을 쓰므로, “감마”라는 단어가 다음 두 맥락에서 섞입니다.

1) **단순 감마(파워 변환)**: 바로 위 수식처럼 **채널 값 자체**에 \(\gamma\) 지수를 적용(본 장 기본).  
2) **sRGB 인지 변환**: sRGB의 비선형을 **선형화** 후 \(\gamma\) 적용 → 다시 sRGB로 **재인코딩**.  
   - 이 경우, 연산은 지각 밝기와 더 가깝게 반응합니다.

> 본 장은 **두 경로를 모두 지원**합니다. 기본은 **단순 감마**이며, 체크박스로 **sRGB 인지** 모드를 토글할 수 있게 하겠습니다.

---

## 2) 구현 전략: **LUT(룩업 테이블)** 기반

슬라이더/스핀/에디트 변경마다 모든 픽셀에 `powf`를 호출하면 느립니다.  
**256개의 LUT**를 한 번 만들고 **치환**하면 매우 빠릅니다.

- 입력 8-bit \(v\) → 정규화 \(x = v/255\) → 변환 \(y=f(x)\) → \(v'=\lfloor 255y+0.5\rfloor\)
- LUT는 채널 색상(B,G,R) 모두에 재사용(알파 제외)

---

## 3) 핵심 코드: LUT 생성/적용

아래 파일들을 프로젝트에 추가합니다.

### 3.1 `Gamma.h` — 공용 유틸 + LUT 생성 (단순/ sRGB 인지)

```cpp
#pragma once
#include <cstdint>
#include <cmath>
#include <algorithm>

inline uint8_t clamp_u8_int(int v) {
    return (uint8_t)std::min(255, std::max(0, v));
}
inline uint8_t clamp_u8_float(float v) {
    if (v < 0.f) v = 0.f; else if (v > 255.f) v = 255.f;
    return (uint8_t)std::lround(v);
}

// --- 단순 감마 LUT: y = x^gamma ---
inline void BuildGammaLUT_Power(double gamma, uint8_t lut[256]) {
    if (gamma <= 0.0) gamma = 0.0001; // 안전 가드
    for (int v=0; v<256; ++v) {
        double x = (double)v / 255.0;
        double y = std::pow(x, gamma);         // 단순 파워
        lut[v] = clamp_u8_float((float)(y * 255.0));
    }
}

// --- sRGB 보정 LUT ---
// sRGB EOTF(정규화 채널값 sRGB -> 선형)
inline double sRGB_to_linear(double cs) {
    return (cs <= 0.04045) ? (cs / 12.92) : std::pow((cs + 0.055) / 1.055, 2.4);
}
// sRGB OETF(선형 -> sRGB)
inline double linear_to_sRGB(double cl) {
    return (cl <= 0.0031308) ? (12.92 * cl) : (1.055 * std::pow(cl, 1.0/2.4) - 0.055);
}

// sRGB 인지 감마: s -> lin -> pow(gamma) -> s
inline void BuildGammaLUT_sRGB(double gamma, uint8_t lut[256]) {
    if (gamma <= 0.0) gamma = 0.0001;
    for (int v=0; v<256; ++v) {
        double cs = (double)v / 255.0;
        double cl = sRGB_to_linear(cs);
        double yl = std::pow(cl, gamma);            // 선형 공간에서 감마 적용
        if (yl < 0.0) yl = 0.0; if (yl > 1.0) yl = 1.0;
        double ys = linear_to_sRGB(yl);
        lut[v] = clamp_u8_float((float)(ys * 255.0));
    }
}
```

### 3.2 `GammaApply.h` — DIB(BGRA32) / IppImage 적용

```cpp
#pragma once
#include <cstdint>
#include "IppDib.h"
#include "IppImage.h"

// BGRA32 DIB B,G,R 채널에 LUT 적용 (A 보존)
inline void ApplyGamma_ToDIB_BGRA32(IppDib& dib, const uint8_t lut[256]) {
    if (!dib) return;
    for (int y=0; y<dib.height(); ++y) {
        uint8_t* row = (uint8_t*)dib.bits() + (size_t)y * dib.stride();
        for (int x=0; x<dib.width(); ++x) {
            uint8_t* p = &row[x*4];
            p[0] = lut[p[0]]; // B
            p[1] = lut[p[1]]; // G
            p[2] = lut[p[2]]; // R
            // p[3] : alpha 유지
        }
    }
}

// (선택) IppImage 버전
inline void ApplyGamma_ToBGR24(IppImage<uint8_t,3>& img, const uint8_t lut[256]) {
    if (!img) return;
    for (int y=0; y<img.height(); ++y) {
        uint8_t* r = reinterpret_cast<uint8_t*>(img.rowp(y));
        for (int x=0; x<img.width(); ++x) {
            uint8_t* p = &r[x*3];
            p[0] = lut[p[0]];
            p[1] = lut[p[1]];
            p[2] = lut[p[2]];
        }
    }
}
inline void ApplyGamma_ToGray8(IppImage<uint8_t,1>& img, const uint8_t lut[256]) {
    if (!img) return;
    for (int y=0; y<img.height(); ++y) {
        uint8_t* r = img.rowp(y);
        for (int x=0; x<img.width(); ++x) r[x] = lut[r[x]];
    }
}
```

---

## 4) 감마 보정 **대화 상자** (실숫값 입력, 미리보기/Reset, sRGB 옵션)

### 4.1 리소스 ID — `res/resource.h` 추가

```cpp
// Dialog
#define IDD_GAMMA                      320

// Controls
#define IDC_EDIT_GAMMA                 1101
#define IDC_SPIN_GAMMA                 1102
#define IDC_CHECK_PREVIEW              1103
#define IDC_CHECK_SRGBAWARE            1104
#define IDC_BTN_RESET                  1105

// Menu command
#define ID_IMAGE_GAMMA                 40300
```

### 4.2 대화 상자 템플릿 — `res/ImageTool.rc` 추가

- **실숫값 입력**을 위해 `EDIT` + `UPDOWN`(스핀)을 사용합니다.  
- 스핀은 0.10~5.00 범위, **스텝 0.01** 로 동작(스핀 값은 내부적으로 ×100 정수로 처리).

```rc
#include "resource.h"
#include <windows.h>
#include <commctrl.h>

IDD_GAMMA DIALOGEX 0, 0, 240, 120
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Gamma Correction"
FONT 9, "Segoe UI"
BEGIN
    LTEXT       "Gamma (0.10 .. 5.00):", -1,      10, 12, 110, 10
    EDITTEXT    IDC_EDIT_GAMMA,                     125,10, 60, 14, ES_AUTOHSCROLL | WS_TABSTOP
    CONTROL     "", IDC_SPIN_GAMMA, UPDOWN_CLASS,   UDS_SETBUDDYINT | UDS_ARROWKEYS | UDS_ALIGNRIGHT, 190,10, 12,14

    AUTOCHECKBOX "Preview",     IDC_CHECK_PREVIEW,   10, 40,  60, 11, WS_TABSTOP
    AUTOCHECKBOX "sRGB-aware",  IDC_CHECK_SRGBAWARE, 80, 40,  70, 11, WS_TABSTOP
    PUSHBUTTON   "Reset",       IDC_BTN_RESET,      160, 40,  40, 14, WS_TABSTOP

    DEFPUSHBUTTON "OK",    IDOK,     90,  85, 50, 14
    PUSHBUTTON   "Cancel", IDCANCEL, 150, 85, 50, 14
END
```

> **UI 정책**  
> - 기본 감마 = **1.00** (변화 없음)  
> - Preview 기본 **On**  
> - sRGB-aware는 **Off**(선택 기능)

---

## 5) 대화 상자 클래스 — **미리보기** 안전 구현

- 시작 시 **원본 백업**  
- 입력이 바뀔 때마다: **백업 → 현재 프레임 복사 → LUT 적용 → 즉시 갱신**  
- `OK`면 적용 상태 유지, `Cancel`이면 **원본 복원**

### 5.1 `GammaDlg.h`

```cpp
#pragma once
#include <vector>
#include <string>
#include <cwchar>
#include <commctrl.h>
#include "resource.h"
#include "IppDib.h"
#include "Gamma.h"
#include "GammaApply.h"

class GammaDlg {
public:
    GammaDlg(HWND owner, IppDib& dib)
        : owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND h, UINT m, WPARAM w, LPARAM l);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);
    INT_PTR OnNotify(HWND h, WPARAM w, LPARAM l);

    void BackupOriginal();
    void RestoreOriginal();
    void RepaintOwner();

    void SetGammaText(HWND h, double g);
    double GetGammaFromEdit(HWND h) const;   // 문자열 → double, 클램프
    int    GammaToSpin(double g) const;      // 0.10~5.00 → 10..500
    double SpinToGamma(int s) const;         // 10..500 → 0.10~5.00

    void ApplyPreview(HWND h);
    void ResetToDefault();

private:
    HWND   owner_ = nullptr;
    HWND   hDlg_  = nullptr;
    IppDib& dib_;

    // 원본 백업
    std::vector<uint8_t> backup_;
    int width_ = 0, height_ = 0, stride_ = 0;

    // 상태
    double gamma_ = 1.0;     // 0.10 .. 5.00
    bool   preview_ = true;
    bool   srgbAware_ = false;
};
```

### 5.2 `GammaDlg.cpp`

```cpp
#include "GammaDlg.h"

INT_PTR GammaDlg::DoModal() {
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_GAMMA),
                           owner_, DlgProc, (LPARAM)this);
}

INT_PTR CALLBACK GammaDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m == WM_INITDIALOG) {
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self = reinterpret_cast<GammaDlg*>(l);
        self->hDlg_ = h;
        return self->OnInit(h);
    }
    auto* self = reinterpret_cast<GammaDlg*>(GetWindowLongPtrW(h, GWLP_USERDATA));
    if (!self) return FALSE;

    switch (m) {
    case WM_COMMAND: return self->OnCommand(h, w, l);
    case WM_NOTIFY:  return self->OnNotify(h, w, l);
    default:         return FALSE;
    }
}

INT_PTR GammaDlg::OnInit(HWND h) {
    // UpDown 설정: 10..500 (=> 0.10 .. 5.00), 스텝 1 (=> 0.01)
    HWND hSpin = GetDlgItem(h, IDC_SPIN_GAMMA);
    SendMessageW(hSpin, UDM_SETRANGE, 0, MAKELPARAM(500, 10));
    SendMessageW(hSpin, UDM_SETBUDDY, (WPARAM)GetDlgItem(h, IDC_EDIT_GAMMA), 0);
    SendMessageW(hSpin, UDM_SETPOS, 0, MAKELPARAM(GammaToSpin(gamma_), 0));

    // 기본값 세팅
    SetGammaText(h, gamma_);
    CheckDlgButton(h, IDC_CHECK_PREVIEW,   BST_CHECKED); preview_   = true;
    CheckDlgButton(h, IDC_CHECK_SRGBAWARE, BST_UNCHECKED); srgbAware_ = false;

    BackupOriginal();
    return TRUE;
}

void GammaDlg::BackupOriginal() {
    if (!dib_) return;
    width_  = dib_.width();
    height_ = dib_.height();
    stride_ = dib_.stride();
    backup_.resize((size_t)height_ * stride_);
    for (int y=0; y<height_; ++y) {
        const uint8_t* s = (const uint8_t*)dib_.bits() + (size_t)y * stride_;
        std::memcpy(backup_.data() + (size_t)y * stride_, s, (size_t)stride_);
    }
}

void GammaDlg::RestoreOriginal() {
    if (!dib_ || backup_.empty()) return;
    for (int y=0; y<height_; ++y) {
        uint8_t* d = (uint8_t*)dib_.bits() + (size_t)y * stride_;
        std::memcpy(d, backup_.data() + (size_t)y * stride_, (size_t)stride_);
    }
    RepaintOwner();
}

void GammaDlg::RepaintOwner() {
    InvalidateRect(owner_, nullptr, FALSE);
    UpdateWindow(owner_);
}

void GammaDlg::SetGammaText(HWND h, double g) {
    wchar_t buf[64];
    swprintf(buf, 64, L"%.2f", g);
    SetDlgItemTextW(h, IDC_EDIT_GAMMA, buf);
}

double GammaDlg::GetGammaFromEdit(HWND h) const {
    wchar_t buf[64]; GetDlgItemTextW(h, IDC_EDIT_GAMMA, buf, 64);
    wchar_t* end = nullptr;
    double g = std::wcstod(buf, &end);
    if (end == buf) g = 1.0; // 파싱 실패 → 1.00
    if (g < 0.10) g = 0.10;
    if (g > 5.00) g = 5.00;
    return g;
}
int GammaDlg::GammaToSpin(double g) const {
    int v = (int)std::lround(g * 100.0); // 1.23 -> 123
    if (v < 10) v = 10; if (v > 500) v = 500;
    return v;
}
double GammaDlg::SpinToGamma(int s) const {
    if (s < 10) s = 10; if (s > 500) s = 500;
    return s / 100.0;
}

void GammaDlg::ApplyPreview(HWND h) {
    if (!dib_) return;
    preview_   = (IsDlgButtonChecked(h, IDC_CHECK_PREVIEW)   == BST_CHECKED);
    srgbAware_ = (IsDlgButtonChecked(h, IDC_CHECK_SRGBAWARE) == BST_CHECKED);
    gamma_ = GetGammaFromEdit(h);

    if (!preview_) {
        RestoreOriginal();
        return;
    }

    // 원본 → 현재 프레임 복사
    for (int y=0; y<height_; ++y) {
        uint8_t* d = (uint8_t*)dib_.bits() + (size_t)y * stride_;
        std::memcpy(d, backup_.data() + (size_t)y * stride_, (size_t)stride_);
    }

    // LUT 생성 & 적용
    uint8_t lut[256];
    if (srgbAware_) BuildGammaLUT_sRGB(gamma_, lut);
    else            BuildGammaLUT_Power(gamma_, lut);

    ApplyGamma_ToDIB_BGRA32(dib_, lut);
    RepaintOwner();
}

void GammaDlg::ResetToDefault() {
    gamma_ = 1.00;
    SetGammaText(hDlg_, gamma_);
    SendDlgItemMessageW(hDlg_, IDC_SPIN_GAMMA, UDM_SETPOS, 0, MAKELPARAM(GammaToSpin(gamma_),0));
    ApplyPreview(hDlg_);
}

INT_PTR GammaDlg::OnCommand(HWND h, WPARAM w, LPARAM) {
    switch (LOWORD(w)) {
    case IDC_EDIT_GAMMA:
        if (HIWORD(w) == EN_CHANGE) {
            // 에디트가 바뀌면 스핀도 동기화
            double g = GetGammaFromEdit(h);
            SendDlgItemMessageW(h, IDC_SPIN_GAMMA, UDM_SETPOS, 0, MAKELPARAM(GammaToSpin(g),0));
            ApplyPreview(h);
            return TRUE;
        }
        break;

    case IDC_CHECK_PREVIEW:
    case IDC_CHECK_SRGBAWARE:
        ApplyPreview(h);
        return TRUE;

    case IDC_BTN_RESET:
        ResetToDefault();
        return TRUE;

    case IDOK:
        if (!preview_) {
            // 미리보기 Off 였다면, 원본으로 돌린 뒤 한 번 적용
            RestoreOriginal();
            uint8_t lut[256];
            if (srgbAware_) BuildGammaLUT_sRGB(gamma_, lut);
            else            BuildGammaLUT_Power(gamma_, lut);
            ApplyGamma_ToDIB_BGRA32(dib_, lut);
            RepaintOwner();
        }
        EndDialog(h, IDOK);
        return TRUE;

    case IDCANCEL:
        RestoreOriginal();
        EndDialog(h, IDCANCEL);
        return TRUE;
    }
    return FALSE;
}

INT_PTR GammaDlg::OnNotify(HWND h, WPARAM, LPARAM l) {
    NMHDR* nm = (NMHDR*)l;
    if (nm->idFrom == IDC_SPIN_GAMMA && nm->code == UDN_DELTAPOS) {
        // 스핀 조절 → 에디트/적용 동기화
        int pos = (int)SendDlgItemMessageW(h, IDC_SPIN_GAMMA, UDM_GETPOS, 0, 0);
        // UDM_GETPOS 상위 워드에 에러 플래그가 담기므로 마스킹
        pos &= 0xFFFF;
        // UDN_DELTAPOS는 누적 처리를 OS가 해줌. 여기서는 에디트만 동기화
        double g = SpinToGamma(pos);
        SetGammaText(h, g);
        ApplyPreview(h);
        return TRUE;
    }
    return FALSE;
}
```

---

## 6) 메뉴/가속기 추가 및 연결

### 6.1 `res/ImageTool.rc` — 메뉴/가속기

```rc
POPUP "&Image"
BEGIN
    MENUITEM "Brightness / Contrast...\tCtrl+B", ID_IMAGE_BRIGHTCONTRAST
    MENUITEM "Gamma Correction...\tCtrl+G",     ID_IMAGE_GAMMA
END

IDR_ACCEL ACCELERATORS
BEGIN
    "G",  ID_IMAGE_GAMMA, VIRTKEY, CONTROL
END
```

### 6.2 `main_multiwin.cpp` — 이벤트 핸들러

```cpp
#include "GammaDlg.h"

// ... WndProc의 WM_COMMAND 스위치문에 추가 ...
case ID_IMAGE_GAMMA:
    if (st && st->dib) {
        GammaDlg dlg(hWnd, st->dib);
        if (dlg.DoModal() == IDOK) {
            OutputBasicInfo(st);       // (5.5절에서 만든 기능) 정보창 갱신
            UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 7) 동작 확인 체크리스트

- [ ] **Gamma = 1.00** → 변화 없음  
- [ ] **Gamma > 1.00** → 전체적으로 **어두워짐** (예: 2.20)  
- [ ] **Gamma < 1.00** → **밝아짐** (예: 0.45)  
- [ ] **Preview On/Off** 동작: Off 시 원본 유지, OK에서만 적용  
- [ ] **Reset** → 1.00으로 복귀  
- [ ] **sRGB-aware** 체크 시, 하이라이트/섀도우의 변화가 **지각적으로 더 자연**스러움  
- [ ] 대형 이미지에서도 스핀/에디트 변경이 **즉시 반응**(LUT 치환만 수행)

---

## 8) 세부 팁 & 변형

1) **값 범위**  
   - 감마는 보통 \(0.10 \sim 5.00\)이면 충분. 0에 가까우면 수치 불안정하므로 **0.10** 하한 추천.  
2) **디바운스**  
   - 에디트에 직접 타이핑 시 깜빡임이 느껴지면, `SetTimer`(예: 20ms) 기반으로 **입력 디바운스** 후 `ApplyPreview` 호출.  
3) **ROI만 적용**  
   - LUT 치환 루프에서 `(x,y)` 범위를 조건으로 제한하면 부분 감마 적용 가능(선택 과제).  
4) **IppImage 기반**  
   - IppDib 대신 `FromIppDib/ToIppDib` + `ApplyGamma_ToBGR24/Gray8`로 처리하면 포맷 일반화에 유리.  
5) **반전/밝기/대비와의 조합**  
   - LUT를 **연쇄**(합성)할 수도 있지만, 대화 상자에서는 보통 개별 기능으로 분리 운영.

---

## 9) 요약

- 감마(멱 변환) \(y = x^{\gamma}\): \( \gamma>1 \) **어두워짐**, \( \gamma<1 \) **밝아짐**  
- **LUT 기반**으로 고속 구현(슬라이더/스핀 실시간 미리보기 가능)  
- **sRGB 인지 옵션**으로 지각적으로 자연스러운 변화 지원  
- **실숫값 입력 대화 상자**: 0.10~5.00, Preview/Reset, 스핀(0.01 step)  
- 메뉴/가속기 연동으로 워크플로우 완성
