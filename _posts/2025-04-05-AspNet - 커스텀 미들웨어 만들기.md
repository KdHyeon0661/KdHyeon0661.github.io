---
layout: post
title: AspNet - 커스텀 미들웨어 만들기
date: 2025-04-05 22:20:23 +0900
category: AspNet
---
# ASP.NET Core 커스텀 미들웨어 만들기

## 미들웨어 핵심 개념 리마인드

- **미들웨어**는 요청/응답 파이프라인을 통과하는 구성 요소.
- 등록 순서가 곧 실행 순서이며, `await _next(context)` 호출 전/후에 **전처리/후처리**가 가능하다.
- 미들웨어는 **전역 관심사**(로깅, 보안, 추적, 압축, 제한, 관측)를 깔끔하게 모듈화한다.

요청의 흐름(개념):

```
Use(M1) → Use(M2) → Use(M3) → (엔드포인트 실행) → 응답 반환 → M3 후처리 → M2 후처리 → M1 후처리
```

---

## 클래스 기반 미들웨어 — 표준 템플릿

### 기본 형태

```csharp
public sealed class RequestLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestLoggingMiddleware> _logger;

    public RequestLoggingMiddleware(RequestDelegate next, ILogger<RequestLoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    // 반드시 async/Task
    public async Task InvokeAsync(HttpContext context)
    {
        _logger.LogInformation("Request {Method} {Path}", context.Request.Method, context.Request.Path);

        await _next(context); // 다음으로 넘김

        _logger.LogInformation("Response {StatusCode}", context.Response.StatusCode);
    }
}
```

등록:

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.UseMiddleware<RequestLoggingMiddleware>();

app.MapGet("/", () => "ok");
app.Run();
```

### 확장 메서드(Extension) 패턴

```csharp
public static class RequestLoggingMiddlewareExtensions
{
    public static IApplicationBuilder UseRequestLogging(this IApplicationBuilder app)
        => app.UseMiddleware<RequestLoggingMiddleware>();
}
```

사용:

```csharp
app.UseRequestLogging();
```

> 팀 표준으로 **모든 커스텀 미들웨어에 Extension**을 제공하면 가독성과 재사용성이 좋아진다.

---

## 인라인 미들웨어 — 빠른 스파이크용

```csharp
app.Use(async (ctx, next) =>
{
    var start = Stopwatch.GetTimestamp();
    await next(); // 다음 실행
    var elapsedMs = (Stopwatch.GetTimestamp() - start) * 1000.0 / Stopwatch.Frequency;
    app.Logger.LogInformation("[Inline] {Path} took {Elapsed:F2}ms", ctx.Request.Path, elapsedMs);
});
```

- 간단 로직, 임시 디버깅에 효과적.
- 재사용/테스트가 필요해지면 **클래스화**하라.

---

## 응답 헤더/바디 가로채기

### 응답 헤더 추가

```csharp
public sealed class CustomHeaderMiddleware
{
    private readonly RequestDelegate _next;
    public CustomHeaderMiddleware(RequestDelegate next) => _next = next;

    public async Task InvokeAsync(HttpContext context)
    {
        context.Response.OnStarting(() =>
        {
            context.Response.Headers.TryAdd("X-Powered-By", "ASP.NET Core Middleware");
            context.Response.Headers.TryAdd("X-Correlation-Id", context.TraceIdentifier);
            return Task.CompletedTask;
        });

        await _next(context);
    }
}
```

### 응답 바디 변환 (MemoryStream 사용)

{% raw %}
```csharp
public sealed class ResponseWrappingMiddleware
{
    private readonly RequestDelegate _next;
    public ResponseWrappingMiddleware(RequestDelegate next) => _next = next;

    public async Task InvokeAsync(HttpContext ctx)
    {
        var originalBody = ctx.Response.Body;
        await using var mem = new MemoryStream();
        ctx.Response.Body = mem;

        await _next(ctx); // 실제 핸들러 실행 → 응답 내용이 mem에 기록

        mem.Seek(0, SeekOrigin.Begin);
        var original = await new StreamReader(mem).ReadToEndAsync();

        // 예: JSON 래핑
        var wrapped = $"{{\"success\":true,\"data\":{original}}}";

        ctx.Response.ContentType = "application/json; charset=utf-8";
        ctx.Response.ContentLength = Encoding.UTF8.GetByteCount(wrapped);
        await ctx.Response.WriteAsync(wrapped, Encoding.UTF8);

        ctx.Response.Body = originalBody;
    }
}
```
{% endraw %}

> 큰 응답에 대한 전체 버퍼링은 메모리 부담이 있으므로 신중히 사용하라. 스트리밍 환경에서는 적합하지 않다.

---

## 요청 바디 가로채기(읽기/재사용)

기본적으로 Request.Body는 **전진형(Forward-only)** 스트림이다. 여러 번 읽으려면 **EnableBuffering**이 필요하다.

```csharp
public sealed class RequestBodyLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestBodyLoggingMiddleware> _logger;

    public RequestBodyLoggingMiddleware(RequestDelegate next, ILogger<RequestBodyLoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext ctx)
    {
        if (ctx.Request.ContentLength is > 0 &&
            (ctx.Request.ContentType?.Contains("application/json") ?? false))
        {
            ctx.Request.EnableBuffering(bufferThreshold: 1024 * 30); // 30KB까지 메모리, 초과 시 임시파일
            using var reader = new StreamReader(ctx.Request.Body, Encoding.UTF8, leaveOpen: true);
            var body = await reader.ReadToEndAsync();
            _logger.LogInformation("RequestBody: {Body}", body);
            ctx.Request.Body.Position = 0; // 다음 미들웨어/모델바인딩에서 다시 읽을 수 있도록 초기화
        }

        await _next(ctx);
    }
}
```

---

## 단락(Short-Circuit)과 조건부 실행

### 단락: 조건에 따라 파이프라인을 즉시 종료

```csharp
public sealed class IpBlockMiddleware
{
    private readonly RequestDelegate _next;
    private readonly HashSet<string> _blocked = new(StringComparer.OrdinalIgnoreCase)
    {
        "192.168.0.10"
    };

    public IpBlockMiddleware(RequestDelegate next) => _next = next;

    public async Task InvokeAsync(HttpContext ctx)
    {
        var remoteIp = ctx.Connection.RemoteIpAddress?.ToString();
        if (remoteIp != null && _blocked.Contains(remoteIp))
        {
            ctx.Response.StatusCode = StatusCodes.Status403Forbidden;
            await ctx.Response.WriteAsync("Forbidden");
            return; // short-circuit
        }
        await _next(ctx);
    }
}
```

### 분기(Branch): `MapWhen` / `UseWhen`

```csharp
app.MapWhen(ctx => ctx.Request.Path.StartsWithSegments("/health"),
    branch =>
    {
        branch.Run(async ctx =>
        {
            ctx.Response.ContentType = "text/plain";
            await ctx.Response.WriteAsync("OK");
        });
    });

app.UseWhen(ctx => ctx.Request.Path.StartsWithSegments("/api"),
    branch => branch.UseMiddleware<RequestLoggingMiddleware>());
```

- `MapWhen`은 분기 내에서 **파이프라인 종료**를 자주 사용.
- `UseWhen`은 조건부로 **일부 미들웨어만** 추가한다.

---

## 전역 예외 처리 미들웨어

컨트롤러/핸들러 이전에 발생한 예외를 **일관된 형식**으로 변환한다.

```csharp
public sealed class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;

    public GlobalExceptionMiddleware(RequestDelegate next, ILogger<GlobalExceptionMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext ctx)
    {
        try
        {
            await _next(ctx);
        }
        catch (OperationCanceledException) when (ctx.RequestAborted.IsCancellationRequested)
        {
            ctx.Response.StatusCode = StatusCodes.Status499ClientClosedRequest; // 관례적 코드
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception");

            ctx.Response.Clear();
            ctx.Response.StatusCode = StatusCodes.Status500InternalServerError;
            ctx.Response.ContentType = "application/json; charset=utf-8";
            var payload = "{\"success\":false,\"error\":\"Internal Server Error\"}";
            await ctx.Response.WriteAsync(payload, Encoding.UTF8);
        }
    }
}
```

등록 순서(추천):

```csharp
app.UseMiddleware<GlobalExceptionMiddleware>();
// 이후 라우팅/인증/인가 등
```

---

## 옵션(Options) + DI 패턴

미들웨어를 **옵션화**하면 환경별/배포별로 동작을 쉽게 조정할 수 있다.

```csharp
public sealed class HeaderOptions
{
    public bool AddServerHeader { get; set; } = true;
    public string ServerName { get; set; } = "MyServer";
}

public sealed class ServerHeaderMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IOptions<HeaderOptions> _opt;

    public ServerHeaderMiddleware(RequestDelegate next, IOptions<HeaderOptions> opt)
    {
        _next = next;
        _opt = opt;
    }

    public async Task InvokeAsync(HttpContext ctx)
    {
        if (_opt.Value.AddServerHeader)
        {
            ctx.Response.OnStarting(() =>
            {
                ctx.Response.Headers["Server"] = _opt.Value.ServerName;
                return Task.CompletedTask;
            });
        }
        await _next(ctx);
    }
}
```

등록:

```csharp
builder.Services.Configure<HeaderOptions>(builder.Configuration.GetSection("HeaderOptions"));
app.UseMiddleware<ServerHeaderMiddleware>();
```

`appsettings.json`:

```json
{
  "HeaderOptions": {
    "AddServerHeader": true,
    "ServerName": "Prod-Gateway"
  }
}
```

---

## 관측/추적: Correlation Id & Logging Scope

```csharp
public sealed class CorrelationIdMiddleware
{
    public const string HeaderName = "X-Correlation-Id";
    private readonly RequestDelegate _next;
    private readonly ILogger<CorrelationIdMiddleware> _logger;

    public CorrelationIdMiddleware(RequestDelegate next, ILogger<CorrelationIdMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext ctx)
    {
        var id = ctx.Request.Headers.TryGetValue(HeaderName, out var h) && !StringValues.IsNullOrEmpty(h)
            ? h.ToString()
            : Guid.NewGuid().ToString("n");

        using (_logger.BeginScope(new Dictionary<string, object> { ["CorrelationId"] = id }))
        {
            ctx.Response.OnStarting(() =>
            {
                ctx.Response.Headers[HeaderName] = id;
                return Task.CompletedTask;
            });
            await _next(ctx);
        }
    }
}
```

- 모든 로그에 `CorrelationId`가 스코프로 묶여 찍히므로 분산 추적/디버깅이 쉬워진다.
- OpenTelemetry를 병행하면 TraceId/SpanId로도 연계 가능.

---

## 보안 헤더/정책 미들웨어 샘플

```csharp
public sealed class SecurityHeadersMiddleware
{
    private readonly RequestDelegate _next;
    public SecurityHeadersMiddleware(RequestDelegate next) => _next = next;

    public async Task InvokeAsync(HttpContext ctx)
    {
        var h = ctx.Response.Headers;
        h["X-Content-Type-Options"] = "nosniff";
        h["X-Frame-Options"] = "DENY";
        h["Referrer-Policy"] = "no-referrer";
        // 최소 CSP 샘플 (필요에 맞게 조정)
        h["Content-Security-Policy"] = "default-src 'self'; img-src 'self' data:; object-src 'none'";

        await _next(ctx);
    }
}
```

> HSTS, HTTPS Redirection, Anti-forgery, SameSite, 쿠키 보안 플래그 등과 함께 종합적으로 구성하라.

---

## 레이트 리미팅(요청 제한) — 간단 샘플 구현

프로덕션에서는 .NET 내장 RateLimiter(미들웨어 아님) 또는 게이트웨이/WAF 사용을 권장. 이해를 위한 간단 미들웨어:

```csharp
public sealed class SimpleRateLimitMiddleware
{
    private readonly RequestDelegate _next;
    private static readonly ConcurrentDictionary<string, (int Count, DateTime WindowStart)> Store = new();

    private readonly int _limit = 60;            // 60 req
    private readonly TimeSpan _window = TimeSpan.FromMinutes(1); // per 1 min

    public SimpleRateLimitMiddleware(RequestDelegate next) => _next = next;

    public async Task InvokeAsync(HttpContext ctx)
    {
        var key = ctx.Connection.RemoteIpAddress?.ToString() ?? "unknown";
        var now = DateTime.UtcNow;

        var entry = Store.AddOrUpdate(key,
            _ => (1, now),
            (_, old) =>
            {
                var (count, start) = old;
                if (now - start > _window) return (1, now);
                return (count + 1, start);
            });

        if (entry.Count > _limit)
        {
            ctx.Response.StatusCode = StatusCodes.Status429TooManyRequests;
            ctx.Response.Headers["Retry-After"] = "60";
            await ctx.Response.WriteAsync("Too Many Requests");
            return;
        }

        await _next(ctx);
    }
}
```

> 다중 인스턴스에서는 분산 스토리지(Redis 등)로 치환해야 한다.

---

## 미들웨어 순서 — 실전 배선 예시

```csharp
// 1. 예외/보안/추적
app.UseMiddleware<GlobalExceptionMiddleware>();
app.UseMiddleware<SecurityHeadersMiddleware>();
app.UseMiddleware<CorrelationIdMiddleware>();

// 2. 정적 파일
app.UseStaticFiles();

// 3. 라우팅
app.UseRouting();

// 4. 인증/인가
app.UseAuthentication();
app.UseAuthorization();

// 5. API 전/후처리
app.UseMiddleware<RequestLoggingMiddleware>();
app.UseMiddleware<ServerHeaderMiddleware>();

// 6. 엔드포인트 실행
app.MapControllers();
app.MapGet("/", () => "ok");
```

**원칙**
- 예외 처리 → 가장 앞.
- 정적 파일 → 초반(필요시 캐시/압축).
- 라우팅 → 인증/인가 **이전**.
- 인증 → 인가 **이전**.
- 엔드포인트 매핑 → 마지막.

---

## Minimal API/Controller와의 경계

- **미들웨어**: 전역 횡단 관심사를 처리(로그, 정책, 보안 헤더, 추적, 제한).
- **필터(Controller/Razor)**: MVC 파이프라인 내부(모델 바인딩/액션 실행 전후).
  전역 + 엔드포인트 로컬 처리를 적절히 분배하라.

---

## 취소 토큰/타임아웃

```csharp
public sealed class TimeoutMiddleware
{
    private readonly RequestDelegate _next;
    private readonly TimeSpan _timeout = TimeSpan.FromSeconds(10);

    public TimeoutMiddleware(RequestDelegate next) => _next = next;

    public async Task InvokeAsync(HttpContext ctx)
    {
        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ctx.RequestAborted);
        cts.CancelAfter(_timeout);

        var task = _next(ctx);
        var delay = Task.Delay(Timeout.InfiniteTimeSpan, cts.Token);
        var completed = await Task.WhenAny(task, delay);
        if (completed != task)
        {
            ctx.Response.StatusCode = StatusCodes.Status504GatewayTimeout;
            await ctx.Response.WriteAsync("Gateway Timeout");
        }
        else
        {
            await task; // 정상 완료
        }
    }
}
```

> 주의: 장시간 실행 작업은 백엔드에서 별도 큐/워커에 위임하는 아키텍처가 더 안전하다.

---

## 단위 테스트(테스트 서버 없이)

미들웨어는 **RequestDelegate 더블**을 주입해 순수 단위 테스트가 가능하다.

```csharp
[Fact]
public async Task IpBlockMiddleware_Returns403_ForBlockedIp()
{
    var context = new DefaultHttpContext();
    context.Connection.RemoteIpAddress = IPAddress.Parse("192.168.0.10");
    context.Response.Body = new MemoryStream();

    var next = new RequestDelegate(_ => Task.CompletedTask);
    var mw = new IpBlockMiddleware(next);

    await mw.InvokeAsync(context);

    Assert.Equal(StatusCodes.Status403Forbidden, context.Response.StatusCode);
}
```

---

## 통합 테스트(WebApplicationFactory)

```csharp
public class AppFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.Configure(app =>
        {
            app.UseMiddleware<GlobalExceptionMiddleware>();
            app.MapGet("/boom", () => throw new InvalidOperationException("x"));
        });
    }
}

[Fact]
public async Task GlobalExceptionMiddleware_Returns500()
{
    await using var factory = new AppFactory();
    var client = factory.CreateClient();
    var res = await client.GetAsync("/boom");
    Assert.Equal(HttpStatusCode.InternalServerError, res.StatusCode);
}
```

---

## 성능/메모리 팁

- **할당 최소화**: Hot path에서 `string.Format` 대신 구조화 로그(`_logger.LogInformation("… {Arg}", arg)`) 사용.
- **버퍼링 주의**: 요청/응답 전체 버퍼링은 대용량에서 비효율. 필요 시에만 활성화.
- **비동기 I/O**: 모든 I/O는 `await` 사용. 동기 I/O는 스레드 고갈 유발.
- **캐시/압축**: 정적 파일/응답 캐싱, 압축 미들웨어 활용.
- **순서 최적화**: 빈번히 단락될 가능성이 큰 미들웨어는 앞단 배치.

---

## 배포/운영 체크리스트

| 항목 | 권장 |
|------|-----|
| HTTPS 강제 | `UseHttpsRedirection`, 프록시 환경시 `ForwardedHeaders` 설정 |
| HSTS | 프로덕션에서만 활성화 |
| 보안 헤더 | CSP, XFO, XCTO 등 기본값 점검 |
| 로깅 | 구조화 로깅 + Correlation Id + 보존 정책 |
| 관측 | OpenTelemetry/Prometheus/HealthCheck 엔드포인트 |
| 에러 페이지 | 개발/운영 분리(`UseDeveloperExceptionPage`는 개발에서만) |
| 스로틀링 | 게이트웨이/WAF/분산 RateLimit |

---

## 완성 예 — 대표 커스텀 미들웨어 묶음

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.Configure<HeaderOptions>(builder.Configuration.GetSection("HeaderOptions"));
var app = builder.Build();

// 1. 예외/보안/추적
app.UseMiddleware<GlobalExceptionMiddleware>();
app.UseMiddleware<SecurityHeadersMiddleware>();
app.UseMiddleware<CorrelationIdMiddleware>();

// 2. 정적 파일
app.UseStaticFiles();

// 3. 라우팅
app.UseRouting();

// 4. 인증/인가
app.UseAuthentication();
app.UseAuthorization();

// 5. API 전/후처리
app.UseMiddleware<RequestLoggingMiddleware>();
app.UseMiddleware<ServerHeaderMiddleware>();
app.UseMiddleware<SimpleRateLimitMiddleware>();

// 6. 조건부/분기
app.UseWhen(ctx => ctx.Request.Path.StartsWithSegments("/api"),
    branch => branch.UseMiddleware<RequestBodyLoggingMiddleware>());

app.MapWhen(ctx => ctx.Request.Path == "/health", b => b.Run(async ctx =>
{
    ctx.Response.ContentType = "text/plain";
    await ctx.Response.WriteAsync("OK");
}));

// 7. 엔드포인트
app.MapGet("/", () => Results.Ok(new { message = "hello" }));

app.Run();
```

---

## 요약

- 커스텀 미들웨어는 **전역 관심사**를 모듈화하는 표준 도구다.
- **클래스 + Extension** 패턴으로 일관성 있게 제공하고, **옵션/DI**로 동작을 외부화하라.
- **분기/단락/순서**가 기능 동작과 성능을 결정한다.
- 응답/요청 바디 가로채기는 강력하지만 **버퍼링 비용**을 이해하고 사용하라.
- **전역 예외 처리**, **보안 헤더**, **추적 스코프**, **레이트 리미팅** 등은 미들웨어로 설계하면 재사용과 표준화가 수월하다.
- **단위/통합 테스트**와 관측을 함께 도입해 운영 신뢰성을 확보하라.
