---
layout: post
title: Spring - 메시징 & 비동기
date: 2025-10-16 19:25:23 +0900
category: Spring
---
# 13. 메시징 & 비동기 — 이벤트, 브로커(Kafka/RabbitMQ), @Async/스케줄/리트라이

> 목표: **도메인 이벤트**와 **스프링 애플리케이션 이벤트**를 구분해 바르게 쓰고, **Kafka/RabbitMQ**의 핵심 패턴을 Spring 생태계에서 실무적으로 적용하며, **@Async/스케줄링/리트라이·백오프**까지 한 번에 정리한다.  
> 전제: Spring Boot 3.3+, Java 21 기준. 예제는 최대한 **실행 가능한 코드 조각** 위주로 제시한다.

---

## A. 이벤트 발행/구독 — ApplicationEvent vs Domain Event

### A-1. 두 이벤트의 의도와 차이
- **ApplicationEvent**: 스프링 컨테이너 내부 협력(테크니컬 이벤트). 예) 캐시 초기화 완료, 설정 리로드.
- **Domain Event**: 비즈니스 사실의 발생. 예) `OrderPlaced`, `PaymentCompleted`. 서비스 경계를 넘어 전달될 수 있음(동기/비동기, 브로커 사용).

> 원칙: **도메인 핵심은 Domain Event로 모델링**, 컨테이너 안쪽 기술적 관심사는 ApplicationEvent 사용.

---

### A-2. ApplicationEvent 빠른 예제

#### 1. 이벤트 타입
```java
public record CacheWarmupCompleted(String cacheName, Instant at) {}
```

#### 2. 발행
```java
@Service
@RequiredArgsConstructor
public class CacheWarmupService {
  private final ApplicationEventPublisher publisher;

  @PostConstruct
  public void warmup() {
    // ... 캐시 프리로딩
    publisher.publishEvent(new CacheWarmupCompleted("product", Instant.now()));
  }
}
```

#### 3. 수신자
```java
@Component
@Slf4j
public class WarmupListener {
  @EventListener
  public void on(CacheWarmupCompleted e) {
    log.info("Cache {} warmed at {}", e.cacheName(), e.at());
  }
}
```

> 동기 실행이 기본. **비동기**로 받고 싶으면 `@EnableAsync` + `@Async`를 리스너에 붙인다(아래 D-2 참고).

---

### A-3. Domain Event 패턴 — 엔티티에서 이벤트 수집

#### 1. 도메인 이벤트 인터페이스/마커
```java
public interface DomainEvent {}
public record OrderPlaced(Long orderId, String userId, long total) implements DomainEvent {}
```

#### 2. 엔티티가 이벤트를 발생·보관
```java
@Entity
@Getter
public class Order {
  @Id @GeneratedValue private Long id;
  private String userId;
  private long total;
  @Transient private final List<DomainEvent> events = new ArrayList<>();

  public static Order place(String userId, long total) {
    Order o = new Order();
    o.userId = userId; o.total = total;
    o.events.add(new OrderPlaced(null, userId, total)); // id는 저장 후 채움
    return o;
  }

  public List<DomainEvent> pullEvents() { // 수거 & 비우기
    var copy = List.copyOf(events);
    events.clear();
    return copy;
  }
}
```

#### 3. 트랜잭션 내에서 이벤트 수거 & 발행(Outbox 없이, 내부 이벤트)
```java
@Service
@RequiredArgsConstructor
public class OrderService {
  private final OrderRepository repo;
  private final ApplicationEventPublisher publisher;

  @Transactional
  public Long create(String userId, long total) {
    Order saved = repo.save(Order.place(userId, total));
    // PK 부여 후 이벤트 보정
    var withId = new OrderPlaced(saved.getId(), saved.getUserId(), saved.getTotal());
    publisher.publishEvent(withId); // 현재 트랜잭션 완료 전에 발행됨
    return saved.getId();
  }
}
```

> **주의**: DB 커밋 실패 시 이미 발행된 이벤트와 **불일치**가 생김. 외부 브로커로 내보낼 땐 **Transactional Outbox** 패턴으로 정합성을 보장하라.

---

### A-4. TransactionalEventListener — 커밋 이후 실행
```java
@Component
public class DomainEventHandlers {

  // 트랜잭션 "커밋 후"에 호출 → DB 정합성 확보
  @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
  public void onOrderPlaced(OrderPlaced e) {
    // 이 지점에서 외부 브로커 전송을 트리거(단, Outbox 권장)
  }
}
```

---

### A-5. Transactional Outbox + 폴러/스트리머

#### 1. Outbox 테이블
```sql
create table outbox (
  id bigserial primary key,
  aggregate_type varchar(100),
  aggregate_id varchar(100),
  type varchar(200),        -- 이벤트 타입
  payload jsonb not null,
  headers jsonb,
  created_at timestamptz default now(),
  published boolean default false
);
create index on outbox(published, created_at);
```

#### 2. 저장 트랜잭션 내 Outbox 기록
```java
@Service
@RequiredArgsConstructor
public class OrderOutboxService {
  private final OrderRepository repo;
  private final OutboxRepository outboxRepo;
  private final ObjectMapper om;

  @Transactional
  public Long create(String userId, long total) {
    Order o = repo.save(Order.place(userId, total));
    var evt = new OrderPlaced(o.getId(), o.getUserId(), o.getTotal());
    var box = new Outbox("Order", String.valueOf(o.getId()),
        evt.getClass().getName(), om.valueToTree(evt), null);
    outboxRepo.save(box); // 같은 트랜잭션에서 기록
    return o.getId();
  }
}
```

#### 3. 별도 배경 작업이 Outbox → 브로커 전송 & 마킹
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class OutboxRelayer {
  private final OutboxRepository repo;
  private final KafkaTemplate<String, String> kafka;
  private final ObjectMapper om;

  @Scheduled(fixedDelay = 1000)
  @Transactional
  public void relay() {
    List<Outbox> batch = repo.findTop100ByPublishedFalseOrderByCreatedAtAsc();
    for (Outbox o : batch) {
      kafka.send("order.events", o.aggregateId(), o.payload().toString());
      o.markPublished();
    }
  }
}
```

> 장점: **원자성(DB)** 보장 + **최소 한 번 전송**.  
> 주의: **중복 수신** 대비 **idempotency**(소비자에서 키 기준 중복 필터링, 상태머신 설계).

---

## B. 메시지 브로커 기본 패턴 — Kafka / RabbitMQ

### B-1. Kafka 핵심 개념 & Spring Kafka

- **Topic**: 메시지 스트림의 이름. **Partition**으로 수평 확장.  
- **Key**: 파티션 라우팅 기준(동일 키 → 동일 파티션 → 순서 보장).  
- **Offset**: 파티션 내 위치.  
- **Consumer Group**: 그룹 내 파티션을 **분산 소비**, 오프셋을 그룹 단위로 관리.

#### 의존성
```kotlin
dependencies {
  implementation("org.springframework.kafka:spring-kafka")
}
```

#### 프로듀서/컨슈머 설정
```yaml
spring:
  kafka:
    bootstrap-servers: localhost:9092
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
      properties:
        spring.json.add.type.headers: false
    consumer:
      group-id: order-consumers
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.value.default.type: com.example.events.OrderPlaced
      auto-offset-reset: latest
    listener:
      ack-mode: RECORD   # 수동 커밋은 MANUAL로
```

#### 프로듀서
```java
@Service
@RequiredArgsConstructor
public class OrderEventProducer {
  private final KafkaTemplate<String, Object> template;

  public void publish(OrderPlaced evt) {
    template.send("order.events", String.valueOf(evt.orderId()), evt);
  }
}
```

#### 컨슈머(동시성, 리트라이, DLT)
```java
@Component
@Slf4j
public class OrderEventListener {

  @KafkaListener(topics = "order.events", groupId = "billing",
      concurrency = "3", containerFactory = "kafkaListenerContainerFactory")
  public void on(OrderPlaced evt) {
    log.info("consume {}", evt);
    // 비즈니스 처리 (멱등화 필요)
  }
}
```

#### 컨테이너 팩토리(에러핸들링 + DLT)
{% raw %}
```java
@Configuration
public class KafkaListenerConfig {

  @Bean
  ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory(
      ConsumerFactory<String, Object> cf, KafkaTemplate<String, Object> tpl) {
    var f = new ConcurrentKafkaListenerContainerFactory<String, Object>();
    f.setConsumerFactory(cf);
    // 1) 동기 재시도(간단)
    f.setCommonErrorHandler(new DefaultErrorHandler(
        // 백오프(지수 + 지터)
        new ExponentialBackOffWithMaxRetries(5) {{
          setInitialInterval(200L);
          setMultiplier(2.0);
          setMaxInterval(5_000L);
        }},
        // 실패 시 DLT로 보내기
        new DeadLetterPublishingRecoverer(tpl,
          (record, ex) -> new TopicPartition(record.topic() + ".DLT", record.partition()))
    ));
    f.getContainerProperties().setAckMode(ContainerProperties.AckMode.RECORD);
    return f;
  }
}
```
{% endraw %}

> **운영 팁**  
> - **키 설계**: 멱등/순서가 필요한 단위(주문 ID 등)를 키로.  
> - **스키마**: JSON 스키마·Avro·Protobuf 사용 + **스키마 레지스트리**.  
> - **Exactly-Once**: Kafka 거래적 프로듀서 + idempotent consumer 패턴(복잡도↑). 실무는 **At-Least-Once + 멱등성**이 표준.

---

### B-2. RabbitMQ 핵심 개념 & Spring AMQP

- **Exchange**: 메시지 라우팅(Direct/Topic/Fanout/Headers).  
- **Queue**: 메시지가 실제 저장되는 곳.  
- **Binding**: Exchange와 Queue 연결(라우팅키).  
- **ACK/NACK**: 소비자 확인 기반 재전송.

#### 의존성
```kotlin
dependencies {
  implementation("org.springframework.boot:spring-boot-starter-amqp")
}
```

#### 선언/설정(코드로 인프라 생성)
```java
@Configuration
public class RabbitConfig {

  // Exchange / Queue / Binding
  @Bean TopicExchange orderExchange() { return new TopicExchange("order.ex"); }
  @Bean Queue billingQueue() { return QueueBuilder.durable("billing.q")
      .withArgument("x-dead-letter-exchange", "dlx.ex").build(); }
  @Bean Binding bindBilling() { return BindingBuilder.bind(billingQueue())
      .to(orderExchange()).with("order.*"); }

  // DLX & DLQ
  @Bean TopicExchange dlx() { return new TopicExchange("dlx.ex"); }
  @Bean Queue dlq() { return QueueBuilder.durable("billing.dlq").build(); }
  @Bean Binding bindDLQ() { return BindingBuilder.bind(dlq()).to(dlx()).with("#"); }

  @Bean public Jackson2JsonMessageConverter converter() { return new Jackson2JsonMessageConverter(); }
}
```

#### 발행
```java
@Service
@RequiredArgsConstructor
public class BillingPublisher {
  private final RabbitTemplate template;

  public void publish(OrderPlaced evt) {
    template.convertAndSend("order.ex", "order.placed", evt);
  }
}
```

#### 소비(리스너)
```java
@Component
@Slf4j
public class BillingConsumer {

  @RabbitListener(queues = "billing.q")
  public void on(OrderPlaced evt) {
    log.info("billing handle {}", evt);
    // 예외 발생 시 → NACK → 재시도 → 실패 누적 → DLX 로 이동
  }
}
```

> **운영 팁**  
> - **지연/예약 메시지**: TTL+DLX, 또는 delayed exchange 플러그인.  
> - **메시지 크기**: RabbitMQ는 **작은 메시지 고속 처리**에 강함. 큰 블롭은 **스토리지/S3** + 메시지엔 **참조**만.  
> - **멱등성**: 메시지 ID(`messageId`/헤더) 기반 중복 방지 저장소.

---

### B-3. Kafka vs RabbitMQ 선택 가이드(요약)
- **Kafka**: 대용량 스트림, 파티션 기반 확장/순서, 이벤트 소싱/로그 → **분석/스트리밍 파이프라인**에 강함.  
- **RabbitMQ**: 라우팅 유연성, 리퀘스트/리플라이, 지연/우선순위 큐, 쉬운 패턴 → **업무 이벤트/작업큐**에 강함.  
- 혼합 운용도 잦음(업무 이벤트는 RabbitMQ, 데이터 스트림은 Kafka).

---

## C. @Async, 스케줄링, 리트라이/백오프

### C-1. @Async — 스레드 풀·컨텍스트 전파

#### 설정
```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

  @Bean(name = "appExecutor")
  public Executor appExecutor() {
    var pool = new ThreadPoolTaskExecutor();
    pool.setThreadNamePrefix("async-");
    pool.setCorePoolSize(8);
    pool.setMaxPoolSize(32);
    pool.setQueueCapacity(1000);
    pool.initialize();
    return pool;
  }

  @Override
  public Executor getAsyncExecutor() { return appExecutor(); }

  @Override
  public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
    return (ex, method, params) -> LoggerFactory.getLogger(method.getDeclaringClass())
      .error("async error in {} with params {}", method.getName(), Arrays.toString(params), ex);
  }
}
```

#### 사용
```java
@Service
public class MailService {

  @Async("appExecutor")
  public CompletableFuture<Void> sendWelcome(String email) {
    // 메일 전송 (외부 I/O)
    return CompletableFuture.completedFuture(null);
  }
}
```

> **주의**  
> - **self-invocation**(자기자신 호출) 시 프록시 미적용. 다른 빈에서 호출하자.  
> - **MDC/보안 컨텍스트**는 기본 전파되지 않음 → `TaskDecorator`로 전파.

#### MDC 전파
```java
@Bean
public TaskDecorator mdcTaskDecorator() {
  return runnable -> {
    Map<String, String> contextMap = MDC.getCopyOfContextMap();
    return () -> {
      if (contextMap != null) MDC.setContextMap(contextMap);
      try { runnable.run(); } finally { MDC.clear(); }
    };
  };
}
```

---

### C-2. 스케줄링 — @Scheduled / TaskScheduler / Quartz

#### 사용
```java
@Configuration
@EnableScheduling
class SchedulingConfig { }

@Component
@Slf4j
public class ReportJob {
  @Scheduled(cron = "0 0/5 * * * *", zone = "Asia/Seoul") // 매 5분
  public void generate() { log.info("generate report"); }

  @Scheduled(fixedDelay = 10_000L, initialDelay = 5_000L)
  public void sync() { /* 이전 실행 끝난 후 10초 뒤 호출 */ }
}
```

> **fixedRate**: 간격 기준 호출(중첩 가능). **fixedDelay**: 완료 기준.

#### 커스텀 스케줄러(풀/동시성 제어)
```java
@Bean
public ThreadPoolTaskScheduler scheduler() {
  var s = new ThreadPoolTaskScheduler();
  s.setPoolSize(4);
  s.setThreadNamePrefix("sched-");
  s.initialize();
  return s;
}
```

> 미션 크고 신뢰성 중요하면 **Quartz** 고려(미스 파이어 정책, 잡 지속성).

---

### C-3. 리트라이/백오프 — Spring Retry & Resilience4j

#### Spring Retry (애너테이션 기반)
```kotlin
dependencies { implementation("org.springframework.retry:spring-retry") }
```
```java
@Configuration
@EnableRetry
class RetryConfig { }
```

```java
@Service
public class PaymentClient {

  @Retryable(
    value = { IOException.class, TimeoutException.class },
    maxAttempts = 5,
    backoff = @Backoff(delay = 200, multiplier = 2.0, maxDelay = 5000, random = true))
  public Receipt charge(String userId, long amount) throws IOException {
    // 외부 결제 호출
    return new Receipt(...);
  }

  @Recover
  public Receipt recover(Exception ex, String userId, long amount) {
    // 최종 실패 시 보상/알림
    return Receipt.failed(...);
  }
}
```

> **지터(jitter)**를 주어 **쏠림** 방지. `random=true` 또는 직접 랜덤 구현.

#### Resilience4j (회로차단/버스트 제어)
```kotlin
dependencies { implementation("io.github.resilience4j:resilience4j-spring-boot3") }
```

```yaml
resilience4j:
  retry.instances.payment:
    max-attempts: 3
    wait-duration: 300ms
  circuitbreaker.instances.payment:
    sliding-window-size: 20
    failure-rate-threshold: 50
    wait-duration-in-open-state: 30s
```

```java
@Service
@RequiredArgsConstructor
public class Paying {
  private final ExternalPay pay;

  @Retry(name = "payment")
  @CircuitBreaker(name = "payment", fallbackMethod = "fallback")
  public Receipt pay(String u, long a) { return pay.charge(u, a); }

  Receipt fallback(Throwable t, String u, long a) { return Receipt.failed(...); }
}
```

---

## D. 멱등성, 순서, 트랜잭션 경계 — 실무 안전장치

1) **멱등성 키**: 요청(또는 메시지) 단위 고유 ID 부여 → 처리 기록 테이블/캐시에 저장하고 **중복 무시**.  
2) **순서 보장**: Kafka 키 기반 파티셔닝, RabbitMQ는 **단일 소비자** 또는 SEDA 스테이지로 **순서 민감 구간을 좁혀라**.  
3) **Saga/보상 트랜잭션**: 분산 트랜잭션 대신 **상태 기반 보상 흐름**을 이벤트로 모델링.  
4) **오류 채널**: DLT/DLQ에 쌓인 메시지는 **별도 소비자**로 관제/재처리 UI 제공.  
5) **관측성**: 메시지에 **traceId**/상관관계 ID를 헤더로 포함. 소비자에서 MDC 주입 후 로깅.

```java
// Kafka 헤더에 traceId 전달
template.executeInTransaction(tpl -> {
  ProducerRecord<String, Object> r = new ProducerRecord<>("order.events", key, evt);
  r.headers().add("traceId", getTraceId().getBytes(StandardCharsets.UTF_8));
  tpl.send(r);
  return null;
});
```

소비자에서:
```java
@KafkaListener(topics = "order.events")
public void on(OrderPlaced evt, @Header("traceId") Optional<String> trace) {
  trace.ifPresent(id -> MDC.put("traceId", id));
  try { /* ... */ } finally { MDC.clear(); }
}
```

---

## E. 테스트 — 내장/컨테이너로 신뢰 확보

### E-1. Kafka: spring-kafka-test (EmbeddedKafka)
```kotlin
testImplementation("org.springframework.kafka:spring-kafka-test")
```
```java
@EmbeddedKafka(partitions = 1, topics = {"order.events"})
@SpringBootTest
class KafkaFlowTest {

  @Autowired KafkaTemplate<String, Object> template;
  @Autowired BlockingQueue<ConsumerRecord<String, Object>> records;

  @Test
  void flow() throws Exception {
    template.send("order.events", "1", new OrderPlaced(1L,"u",100));
    var rec = records.poll(5, TimeUnit.SECONDS);
    assertThat(rec).isNotNull();
  }
}
```

### E-2. RabbitMQ: Testcontainers
```kotlin
testImplementation("org.testcontainers:rabbitmq")
```
```java
@Testcontainers
@SpringBootTest
class RabbitFlowTest {
  @Container static RabbitMQContainer RABBIT = new RabbitMQContainer("rabbitmq:3.13-management");
  @DynamicPropertySource
  static void props(DynamicPropertyRegistry r){
    r.add("spring.rabbitmq.addresses", RABBIT::getAmqpUrl);
  }
  @Test void ok(){ /* publish and assert consumption */ }
}
```

---

## F. 보안/운영 체크리스트

- **Kafka 보안**: SASL_SSL, ACL(토픽 단위 읽기/쓰기), 토픽 수명주기/파티션 계획.  
- **RabbitMQ 보안**: VHost 분리, 사용자 권한 최소화, TLS.  
- **백프레셔**: Kafka 소비자 `max.poll.interval.ms`/`max.poll.records` 튜닝, RabbitMQ Prefetch.  
- **리밸런스**: Kafka 소비자 롱런 작업 → **핸드오프/재처리 설계**.  
- **스키마 진화**: backward/forward 호환, 필드 optional 기본.  
- **재시도 전략**: 빠른 재시도(네트워크 일시 장애) vs 느린 재시도(비즈니스 실패) 분리, DLT 도입.  
- **데이터 보존**: Kafka 토픽 `retention.ms`/`bytes`, RabbitMQ TTL/큐 용량, 모니터링 알람.  
- **장애 대응**: 컨슈머 다운 시 재처리 가능(멱등성), 운영 대시보드(소비 레이턴시/랙).  
- **관측성**: 메시지 왕복 시간, 재시도 횟수, DLT 규모, 처리율 TPS, 실패율.

---

## G. 미니 레퍼런스(치트시트)

**Kafka Listener Ack 모드**  
- `RECORD`: 레코드마다 커밋  
- `BATCH`: 배치마다  
- `MANUAL(_IMMEDIATE)`: 코드에서 `ack.acknowledge()`  

**RabbitMQ Exchange**  
- Direct(정확매칭), Topic(와일드카드), Fanout(브로드캐스트), Headers(헤더 기반)

**@Scheduled**  
- `fixedRate`, `fixedDelay`, `cron`, `zone`  
- 병렬 방지: 싱글 스케줄러/락(분산 락: Redis/DB)

**Spring Retry 속성**  
- `maxAttempts`, `backoff.delay`, `multiplier`, `maxDelay`, `random`

---

## H. 한 페이지 요약

- **도메인 이벤트**는 비즈니스 사실을 모델링하고, 외부로 내보낼 땐 **Transactional Outbox**로 정합성을 지켜라.  
- **Kafka**는 스트림·파티션·스키마 레지스트리와 함께 **At-Least-Once + 멱등성**을 표준으로, **DLT**로 실패를 격리하라.  
- **RabbitMQ**는 교환/큐/라우팅으로 업무 이벤트·작업큐에 최적. TTL/DLX/지연 큐로 재시도·스케줄을 만들 수 있다.  
- **@Async/스케줄링/리트라이**는 **풀/컨텍스트 전파/백오프·지터**를 갖추고, 장기 작업은 **잡 시스템/브로커**로 넘겨라.  
- 전 구간에 **멱등성·순서·관측성(traceId)**을 심어 장애·중복·확장에도 흔들리지 않는 **비동기 아키텍처**를 완성한다.