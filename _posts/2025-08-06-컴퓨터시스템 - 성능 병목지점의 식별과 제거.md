---
layout: post
title: 컴퓨터시스템 - 성능 병목지점의 식별과 제거
date: 2025-08-06 17:20:23 +0900
category: 컴퓨터시스템
---
# 성능 병목지점의 식별과 제거 — 절차·도구·기술·검증까지

> 목표: “**어디가 느린가? 왜 느린가? 어떻게 고칠까? 정말 빨라졌나?**”를  
> **분석 → 개선 → 검증**의 주기로 끝까지 밀어붙이는 실전 가이드.  
> 수학식은 MathJax, 코드는 C/셸 예시로 제시한다.

---

## 0) 한눈 요약 (TL;DR 체크리스트)

1. **문제 정의**: p95 지연/처리량/비용 중 무엇을 줄이나? 목표 수치 고정.  
2. **탐침(계측)**: 샘플링 프로파일 + 하드웨어 카운터 + I/O/락 대기.  
3. **상한 계산**: Amdahl / Little / Roofline으로 “불가능선”을 먼저 그린다.  
4. **우선순위**: 상위 10% 핫패스부터 (콜스택/플레임그래프 기준).  
5. **작은 변경→재측정**: 한 번에 하나, 중앙값+p95, 회귀 테스트로 고정.

---

## 1) 병목 식별: 관찰 → 가설 → 증명

### 1.1 5분 트리아지(빠른 가설 테스트)

증상 | 즉시 보는 값 | 해석 힌트 | 5분 조치
---|---|---|---
CPU 낮음, 지연 높음 | iowait↑, syscalls↑ | I/O 대기 | 비동기/배치 경로로 한 구간 교체
CPU 100%, IPC 낮음 | `perf stat` IPC<1, LLC-miss↑ | 메모리 바운드 | 스트라이드1 재작성 샘플·타일링
p99만 나쁨 | 큐 길이↑, 락 대기↑ | 경합/폭주 | 큐/동시성 제한·락 범위 축소
분기 미스↑ | `branch-misses`↑ | 조건 패턴 불규칙 | 브랜치리스/테이블 루ック업
컨텍스트 스위치↑ | `cs`, `sched`↑ | 과다 스레딩 | 코어=스레드(또는 2×)로 제한

### 1.2 도구 모음(최소 필수)

```bash
# 전체 감: CPU/메모리/로드큐
top | htop
vmstat 1
pidstat -wt 1

# CPU/캐시/분기/메모리 카운터
perf stat -e cycles,instructions,branches,branch-misses,\
L1-dcache-loads,L1-dcache-load-misses,LLC-load-misses,\
dTLB-load-misses,stalled-cycles-frontend,stalled-cycles-backend ./app

# 샘플링 프로파일 + 플레임그래프
perf record -F 997 -g -- ./app && perf report

# I/O·디스크
iostat -xz 1
strace -c ./app

# 락 경합(가능한 환경)
perf lock record ./app && perf lock report
```

### 1.3 상한 계산(“얼마까지 빨라질 수 있나?”)

- **Amdahl**  
  \[
  \text{Speedup}=\frac{1}{(1-p)+\frac{p}{s}}
  \]
  \(p\): 최적화 가능한 비율, \(s\): 그 부분 가속비.
- **Little의 법칙**  
  \[
  L=\lambda W
  \]
  큐가 길어지면 \(W\)(대기)가 폭증 → **테일 지연(p95)**이 급등.
- **Roofline**  
  \[
  \text{Perf}\le\min(\text{Peak FLOPs},\ \text{AI}\cdot \text{BW}),\quad
  \text{AI}=\frac{\text{FLOPs}}{\text{Bytes}}
  \]
  메모리 바운드면 **연산 최적화** 대신 **데이터 이동**을 줄여야 한다.

---

## 2) 병목 유형별 식별 신호와 제거 전략

### 2.1 CPU-연산 바운드 (컴퓨트)

**신호**: IPC 높음(≥2), 캐시미스 낮음, ALU 사용률 높음.  
**전략**:
- **알고리즘 개선**: \(O(n^2)\to O(n\log n)\).  
- **벡터화**: `restrict`/정렬/브랜치 제거로 자동 벡터화 유도.
- **루프 언롤/강도감소**: 분기·곱셈 제거.
- **멀티스레딩**: 독립 작업 분할(리듀스/스캔은 결합법칙 유지 주의).

```c
// 벡터화 친화 SAXPY
void saxpy(int n, float *restrict x, float *restrict y, float a){
  float aa=a;
  #pragma omp simd
  for(int i=0;i<n;i++){
    float xi=x[i], yi=y[i];
    y[i]=yi + aa*xi;
  }
}
```

---

### 2.2 메모리 바운드 (캐시/DRAM/MLP)

**신호**: IPC<1, `LLC-load-misses`↑, `stalled-cycles-backend`↑.  
**전략**:
- **연속 접근/타일링(블로킹)**: L1/L2 재사용 극대화.
- **데이터 레이아웃**: AoS→**SoA**, 패딩으로 충돌 완화.
- **스칼라 치환**: 같은 원소는 한 번만 로드 후 레지스터 재사용.
- **프리패치**: 규칙적 패턴에 `__builtin_prefetch`.
- **TLB/NUMA**: Huge page, first-touch, 바인딩.

```c
// 타일링 스케치
for (int ii=0; ii<n; ii+=B)
  for (int jj=0; jj<n; jj+=B)
    for (int i=ii; i<min(ii+B,n); ++i){
      float acc=0;
      for (int j=jj; j<min(jj+B,n); ++j) acc+=A[i*n+j]*x[j];
      y[i]+=acc;
    }
```

---

### 2.3 분기 병목

**신호**: `branch-misses`↑, p95 스파이크(예측 실패 시 페널티).  
**전략**:
- **브랜치리스**(마스크/테이블)·**분기 확률 정렬**·작은 분기 인라인.
```c
// max(0,x) branchless
static inline int relu(int x){ int m=x>>31; return (x^m)-m; }
```

---

### 2.4 락/동기화 경합

**신호**: 락 대기 상위, `perf lock report` 핫락, run queue↑.  
**전략**:
- **샤딩/파티션 락**: 전역 → N개 락.
- **락 범위 축소**·핫섹션 분리·읽기 다수면 **RW락**.
- **Per-thread 누적 → 최종 머지** (false sharing 방지 패딩).

```c
#define P 64
typedef struct { _Alignas(64) long v; } pad64;
pad64 cnt[P]; // 샤딩
void add(int tid,long x){ cnt[tid].v += x; }
long total(){ long s=0; for(int i=0;i<P;i++) s+=cnt[i].v; return s; }
```

---

### 2.5 I/O/네트워크/스토리지

**신호**: iowait↑, 디스크 util 100%, syscalls↑, RTT 변동↑.  
**전략**:
- **배치 I/O**: `readv/writev`, `sendfile`, 비동기(uring).
- **순차화/압축**: 랜덤 → 스트리밍, 압축레벨 **실측**으로 결정.
- **커넥션·쿼리 합치기**: N+1 제거, 벌크 API.

---

### 2.6 외부 서비스/DB 병목

**신호**: 외부 왕복 많은 핫스택, DB CPU↑/슬로우쿼리.  
**전략**:
- **인덱스/커버링**·필요 컬럼만 전송.
- **캐시/TTL**·쓰기 배치·파티셔닝.
- **서킷 브레이커/리트라이 백오프**(테일 안정화).

---

## 3) 개선 설계: “한 번에 하나, 작게, 검증 가능하게”

### 3.1 변경의 단위화
- **핵심 루프 하나**, **쿼리 한 개**, **락 한 군데**씩.  
- 변경 전/후를 **동일 입력**으로 N회 반복, **중앙값+95% CI** 보고.

### 3.2 정확성/안전
- **단위 테스트** + 경계값(오버플로/NaN/빈 입력).  
- 병렬화/락 변경 시 **TSAN**(가능 언어), 데드락 텐플릿 제거.

### 3.3 배포 전략
- 카나리/트래픽 5% → 25% → 100% 단계적 확대.  
- 회귀 임계선: p95, 에러율, 자원 상한을 자동 감시.

---

## 4) 검증: 측정법과 보고 형식

### 4.1 최소 측정 틀(C)

```c
#include <time.h>
double now(){ struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
              return t.tv_sec + t.tv_nsec*1e-9; }
```

- **프로토콜**: 워밍업→N회 실행→중앙값/표준편차.  
- **하드웨어 카운터**(핵심): `cycles, instructions, IPC, LLC-miss, branch-miss, dTLB-miss`.

### 4.2 결과 보고 템플릿

- **성능**: `T_old → T_new (−X%)`, p50/p95, 처리량(RPS/MB/s).  
- **원인**: “CSE+인라인→분기제거, SoA→LLC miss −35%”.  
- **증거**: `perf stat/report` 스크린샷/숫자, flamegraph 전/후.  
- **여파**: 바이너리 크기±, 메모리 사용±, 링크/빌드 시간±.  
- **추가 리스크**: 수치 오차/정밀도, ABI 영향 등.

---

## 5) 미니 사례 3종

### 5.1 메모리 바운드 루프 1.7×
- **전**: AoS, 무작위 접근, IPC=0.6, LLC-miss 30%.  
- **개선**: SoA + 타일링(64×64) + 스칼라치환 + `#pragma omp simd`.  
- **후**: IPC=1.3, LLC-miss 11%, 시간 −41%.

### 5.2 락 경합 해소로 p95 −28%
- **전**: 전역 맵+뮤텍스, 쓰기 적지만 읽기 다수.  
- **개선**: RW락 + 샤딩(64-way) + per-thread 집계.  
- **후**: 락 대기 70%↓, p95 320→230ms.

### 5.3 I/O 배치로 처리량 +2.2×
- **전**: 4KB 단위 `write()` 연속 호출.  
- **개선**: `writev()`로 1MB 배치, 압축레벨 6→3(실측 최적).  
- **후**: syscalls −93%, MB/s +120%.

---

## 6) 안티패턴(피해야 할 것)

- **측정 없이 대수술**: 무엇이 효과였는지 모른다.  
- **한 번에 여러 변경**: 회귀 분석 불가.  
- **p50만 개선**: 사용자 체감은 p95/p99.  
- **과도한 언롤/인라인**: I-cache 압박으로 역효과.  
- **무제한 캐시**: 정합성/메모리 폭주.

---

## 7) 실전 플레이북(요약 순서)

1) **핫스팟 식별**: 플레임그래프 Top 10.  
2) **상한 계산**: Amdahl/Little/Roofline → 노선 결정.  
3) **빠른 가설 실험**: 5분 조치(배치/브랜치리스/스트라이드1).  
4) **근본 수정**: 레이아웃(SoA), 타일링, 락 구조, 쿼리 설계.  
5) **검증**: p95/IPC/미스율, 회귀 알람.  
6) **반복**: 다음 병목으로 이동(병목은 이동한다).

---

## 8) 부록: 매핑 표 — 증상 ↔ 원인 ↔ 처방

증상 | 카운터/징후 | 1차 처방 | 2차 처방
---|---|---|---
IPC<1, LLC-miss↑ | backend bound | 타일·SoA·프리패치 | 알고리즘/데이터 재구성
branch-miss↑ | bad speculation | 분기 단순화·브랜치리스 | 테이블화/프로파일 지시
락 대기↑ | lock contention | 샤딩/RW락 | 락없는 구조/작업 흐름 변경
iowait↑ | 디스크/네트워크 | 배치·비동기 | 포맷·압축·전송경로 개편
dTLB-miss↑ | TLB 병목 | Huge page | 페이지 로컬리티/NUMA 바인딩

---

### 마무리

병목 제거는 **과학적 실험(측정·가설·검증)** 과 **공학적 절제(한 번에 하나)** 의 합이다.  
핵심은 **데이터 이동을 줄이고(메모리/IO)**, **경합을 줄이며(락/큐)**, **CPU가 쉬지 않게(벡터/TLP/MLP)** 하는 것.  
이 템플릿을 반복 적용하면, 어떤 스택이든 “어디가 느린지”를 빠르게 찾고 **지속적으로** 빨라질 수 있다.