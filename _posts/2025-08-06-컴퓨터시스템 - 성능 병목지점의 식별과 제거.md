---
layout: post
title: 컴퓨터시스템 - 성능 병목지점의 식별과 제거
date: 2025-08-06 17:20:23 +0900
category: 컴퓨터시스템
---
# 성능 병목지점의 식별과 제거

## 0. 한눈 요약 (TL;DR 체크리스트)

1. **문제 정의**: p95 지연/처리량/비용 중 **목표 지표** 수치화(예: p95 320ms → 200ms).  
2. **탐침(계측)**: 샘플링 프로파일 + 하드웨어 카운터 + I/O/락/GC 대기 **동시에** 수집.  
3. **상한 계산**: Amdahl / Little / Roofline으로 “**불가능선**”을 먼저 긋는다.  
4. **우선순위**: 플레임그래프 상위 10% **핫패스**부터(콜스택 기준).  
5. **작은 변경→재측정**: 한 번에 하나, 중앙값+p95, 신뢰구간·회귀 테스트로 고정.  
6. **병목은 이동한다**: 다음 상위 병목으로 반복.

---

## 1. 병목 식별: 관찰 → 가설 → 증명

### 1.1 5분 트리아지(빠른 가설 테스트)

증상 | 즉시 보는 값(1분) | 해석 힌트 | 5분 조치(작은 가설 실험)
---|---|---|---
CPU 낮음·지연 높음 | iowait↑, `strace -c`에서 I/O 비중↑ | I/O 대기 | 비동기/배치 경로로 **한 구간** 교체
CPU 100%, IPC<1 | `perf stat`에서 LLC-miss↑, backend stalled↑ | 메모리 바운드 | **스트라이드 1**로 재작성한 **샘플 루틴**으로 비교
p99만 나쁨 | run queue↑, 락 대기↑ | 경합·폭주 | **동시성 절반**으로 줄여 p99 변화 확인
분기 미스↑ | `branch-misses`↑ | 불규칙 조건 | 브랜치리스/테이블화 **한 지점** 적용
컨텍스트 스위치↑ | `cs`, `sched:sched_switch`↑ | 과다 스레딩 | 스레드/코어≈1~2×로 제한

### 1.2 도구 모음(최소 필수, 리눅스 예)

```bash
# 전체 감(5초면 윤곽)
htop            # CPU/메모리/러닝큐
vmstat 1        # r/b/csw/us/sy/wa/ins/outs
pidstat -wt 1   # 스레드/컨텍스트 스위치/대기

# CPU/캐시/분기/메모리 카운터
perf stat -e cycles,instructions,IPC,branches,branch-misses,\
L1-dcache-load-misses,LLC-load-misses,dTLB-load-misses,\
stalled-cycles-frontend,stalled-cycles-backend -- ./app

# 샘플링 프로파일 + 플레임그래프 뼈대
perf record -F 997 -g -- ./app
perf report

# I/O와 시스템콜 감
iostat -xz 1
strace -c ./app

# 락 경합(가능 환경)
perf lock record -- ./app
perf lock report
```

> **팁**: 프로파일은 **샘플링**으로 시작(저오버헤드). 필요한 곳에만 **정밀 계측**을 추가한다.

### 1.3 상한 계산(“얼마까지 빨라질 수 있나?”)

- **Amdahl**  
  $$
  \text{Speedup}=\frac{1}{(1-p)+\frac{p}{s}}
  $$
  예) 총 시간의 35%가 JSON 변환( \(p=0.35\) ). 이 구간을 무한대 속도로 만들어도 전체 속도향상은  
  $$
  S_{\max}=\frac{1}{0.65+0}=1.538\quad(\approx 1.54\times)
  $$
  → **과투자 방지**에 필수.

- **Little의 법칙**  
  $$
  L=\lambda W
  $$
  평균 동시 요청수 \(L\), 처리율 \(\lambda\), 평균 체류시간 \(W\).  
  큐 이용률 \(\rho\)가 0.8→0.9가 되면 M/M/1에서 대기 \(W_q\)는
  $$
  W_q \approx \frac{\rho}{\mu(1-\rho)}
  $$
  로 급증 → **p95/p99 테일 지연**은 종종 코드보다 **큐잉** 문제.

- **Roofline**  
  $$
  \text{Perf}\le\min(\text{Peak FLOPs},\ \text{AI}\cdot \text{BW}),\quad
  \text{AI}=\frac{\text{FLOPs}}{\text{Bytes}}
  $$
  예) SAXPY: 요소당 2 FLOP, 24B 이동 → \(\text{AI}\approx 0.083\ \text{FLOP/B}\) → **메모리 바운드**.  
  → 연산 최적화보다 **데이터 이동 최소화**(타일링/SoA/프리패치)가 맞다.

---

## 2. 병목 유형별 식별 신호와 제거 전략

### 2.1 CPU-연산 바운드(컴퓨트 중심)

**신호**: IPC 높음(≥2), LLC 미스 낮음, ALU/FP 사용률 높음.  
**전략**:
- **알고리즘 개선**: \(O(n^2)\to O(n\log n)\), 선형 시간화.  
- **벡터화**: `restrict`/정렬/브랜치 제거, 누적을 레지스터에.  
- **언롤·강도감소**: 곱셈→시프트/합산, 불변 상수 호이스팅.  
- **멀티스레딩**: 독립 작업 분할(리듀스·스캔은 결합법칙 확인).

```c
// 벡터화 친화 SAXPY
void saxpy(int n, float *restrict x, float *restrict y, float a){
  float aa=a;
  #pragma omp simd
  for(int i=0;i<n;i++){
    float xi=x[i], yi=y[i];
    y[i]=yi + aa*xi;    // 분기 없음, 연속 접근
  }
}
```

---

### 2.2 메모리 바운드(캐시/DRAM/MLP)

**신호**: IPC<1, `LLC-load-misses`↑, `stalled-cycles-backend`↑, dTLB-miss↑.  
**전략**:
- **연속 접근/타일링**으로 L1/L2 재사용 극대화.  
- **데이터 레이아웃**: AoS→**SoA**, 패딩으로 세트 충돌 완화.  
- **스칼라 치환**: 같은 원소를 한 번만 로드하여 레지스터 재사용.  
- **프리패치**: 규칙적 패턴에 `__builtin_prefetch`.  
- **TLB/NUMA**: Huge page, first-touch, 바인딩.

```c
// 타일링 스케치(행렬-벡터)
for (int ii=0; ii<n; ii+=B)
  for (int i=ii; i< (ii+B<n?ii+B:n); ++i){
    float acc=0;
    for (int j=0; j<n; ++j) acc += A[i*n+j]*x[j]; // B를 조정해 L1/L2에 붙이기
    y[i]+=acc;
  }
```

---

### 2.3 분기 병목(예측 실패)

**신호**: `branch-misses`↑, 분포상의 **테일 스파이크**.  
**전략**:  
- **브랜치리스**(마스크·테이블), **확률 높은 쪽**을 **fall-through**.  
- **작은 분기 인라인**(호출 경계 제거).

```c
// max(0,x) branchless (정수)
static inline int relu_i32(int x){ int m=x>>31; return (x^m)-m; }
```

---

### 2.4 락/동기화 경합

**신호**: `perf lock report`에서 핫락, run queue↑, 선점/컨텍스트 스위치↑.  
**전략**:
- **샤딩/파티션 락**: 전역 → N개 락.  
- **락 범위 축소**·핫섹션 분리·읽기 다수면 **RW락**.  
- **Per-thread 누적 → 최종 머지**(폴스 셰어링 방지 패딩).

```c
#define P 64
typedef struct { _Alignas(64) long v; } pad64;
static pad64 cnt[P]; // 스레드별 샤드
void add(int tid,long x){ cnt[tid].v += x; }
long total(){ long s=0; for(int i=0;i<P;i++) s+=cnt[i].v; return s; }
```

---

### 2.5 I/O/네트워크/스토리지

**신호**: iowait↑, 디스크 util 100%, `strace -c`에서 read/write 비율↑, RTT 변동↑.  
**전략**:
- **배치 I/O**: `readv/writev`, `sendfile`, 비동기(uring/overl랩드).  
- **순차화/압축 레벨 실측**: 랜덤→스트리밍, Zstd 레벨 자동 탐색.  
- **쿼리·커넥션 합치기**: N+1 제거, 벌크 API.

```c
// writev: N번 write → 1회
#include <sys/uio.h>
ssize_t flush_many(int fd, const struct iovec *iov, int n){
  return writev(fd, iov, n);
}
```

---

### 2.6 외부 서비스/DB 병목

**신호**: 플레임에 외부 호출 스택, 슬로우쿼리↑, DB CPU↑.  
**전략**:
- **커버링 인덱스**·필요 컬럼만 전송.  
- **캐시/TTL**·쓰기 배치·파티셔닝.  
- **서킷 브레이커/리트라이 백오프**(테일 안정화).

---

### 2.7 언어 런타임/할당/GC

**신호**: GC 스톱더월드, 할당률↑, 메모리 단편화.  
**전략**:
- **객체/버퍼 재사용**(pool), **슬라이스/뷰**로 zero-copy.  
- **대용량 장수 데이터**는 **Huge page**·고정 버퍼.  
- **먼저** 할당 패턴을 줄이고, **그 다음** GC 파라미터 조정.

---

## 3. 개선 설계: “한 번에 하나, 작게, 검증 가능하게”

### 3.1 변경 단위화와 실험 설계
- **핵심 루프 하나**, **쿼리 하나**, **락 하나**씩 바꾸고 비교.  
- 동일 입력·동일 warm-up으로 N회 반복 → **중앙값+95% CI** 보고.

### 3.2 정확성·안전
- 단위 테스트 + 경계·난 케이스(오버플로/NaN/빈 입력).  
- 병렬화/락 변경 시 **TSAN**(가능 언어), 타임아웃/서킷 브레이커로 장애 격리.

### 3.3 배포 전략
- 카나리(5%→25%→100%), 롤백 스위치.  
- 회귀 임계: p95, 에러율, 자원 사용량(코어/메모리/IOPS).

---

## 4. 검증: 측정법과 보고 형식

### 4.1 최소 측정 틀(C, p50/p95/표준편차/간단 CI)

```c
// bench_core.c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

static double now(){ struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
  return t.tv_sec + t.tv_nsec*1e-9; }

static volatile double sink;
static void workload(int n){ double s=0; for(int i=0;i<n;i++) s+= (i*1315423911u)%1009; sink=s; }

static int cmpd(const void* a,const void* b){
  double x=*(const double*)a,y=*(const double*)b; return (x<y)?-1:(x>y);
}

int main(int argc,char**argv){
  int runs = (argc>1)? atoi(argv[1]) : 31;
  int N    = (argc>2)? atoi(argv[2]) : 1000000;
  double *t = malloc(sizeof(double)*runs);
  for(int i=0;i<runs;i++){
    for(int w=0;w<3;w++) workload(10000); // 워밍업
    double t0=now(); workload(N); double t1=now(); t[i]=t1-t0;
  }
  qsort(t, runs, sizeof(double), cmpd);
  double sum=0,sum2=0; for(int i=0;i<runs;i++){ sum+=t[i]; sum2+=t[i]*t[i]; }
  double mean=sum/runs, sd=sqrt((sum2/runs)-(mean*mean));
  int p50=(int)(0.50*(runs-1)), p95=(int)(0.95*(runs-1));
  double ci95 = 1.96*sd/sqrt((double)runs);
  printf("runs=%d mean=%.6f sd=%.6f 95%%CI=±%.6f p50=%.6f p95=%.6f\n",
         runs, mean, sd, ci95, t[p50], t[p95]);
  free(t);
}
```

### 4.2 하드웨어 카운터로 “원인” 확인

```bash
gcc -O3 -march=native -flto bench_core.c -o bench && ./bench 31 1500000
perf stat -e cycles,instructions,IPC,\
L1-dcache-loads,L1-dcache-load-misses,\
LLC-loads,LLC-load-misses,\
dTLB-loads,dTLB-load-misses,\
branches,branch-misses \
./bench 31 1500000
```

**해석 예시(가이드라인)**  
- **IPC<1 & LLC-miss↑**: 메모리 바운드 가능성↑ → 타일·SoA·프리패치 실험.  
- **branch-miss↑**: 브랜치리스·확률 정렬.  
- **dTLB-miss↑**: Huge page·데이터 레이아웃/배치 수정.  
- **stalled backend↑**: 데이터 대기(MLP 낮음) → 독립 로드 병렬화/언롤.

### 4.3 보고 템플릿(현장용)

- **성능**: `T_old → T_new (−X%)`, p50/p95, 처리량(RPS/MB/s).  
- **원인**: “SoA+타일링 → LLC-miss −36%, IPC 0.71→1.12”.  
- **증거**: `perf stat/report` 수치·플레임그래프 전/후.  
- **부수효과**: 바이너리 크기±, 메모리±, 빌드·링크 시간±.  
- **리스크**: 수치 오차·정밀도, ABI 안정성, 분기 최적화로 인한 결과 변화(부동소수점).

---

## 5. 미니 사례 4종(숫자·코드·처방)

### 5.1 메모리 바운드 루프 1.7×

- **전**: AoS, 무작위 접근 → IPC=0.60, LLC-miss 30%, p95=88ms.  
- **개선**: SoA 변환 + 타일 64×64 + 스칼라 치환 + `#pragma omp simd`.  
- **후**: IPC=1.28, LLC-miss 11%, p95=52ms(−41%).

```c
typedef struct { float *x,*y,*z; } vec3_soa;
float energy(vec3_soa v,int n){
  __builtin_assume_aligned(v.x,64);
  float s=0.0f;
  #pragma omp simd reduction(+:s)
  for(int i=0;i<n;i++){
    float dx=v.x[i], dy=v.y[i], dz=v.z[i];
    s += dx*dx + dy*dy + dz*dz;
  }
  return s;
}
```

### 5.2 락 경합 해소로 p95 −28%

- **전**: 전역맵 + 뮤텍스, 읽기 95%·쓰기 5%, p95=320ms.  
- **개선**: RW락 + 64-way 샤딩 + per-thread 누적 → 최종 머지.  
- **후**: 락 대기 70%↓, p95=230ms(−28%).

### 5.3 I/O 배치로 처리량 +2.2×

- **전**: 4KB `write()` 수천 회, syscalls↑, iowait↑.  
- **개선**: `writev()` 1MB 배치 + Zstd 레벨 6→3(실측 최적).  
- **후**: syscalls −93%, MB/s +120%.

### 5.4 분기 병목 제거로 1.3×

- **전**: 작은 `clamp()`가 루프 내 다단 호출, `branch-miss`↑.  
- **개선**: `static inline` + 분기 없는 clamp 대체.  
- **후**: 분기미스 −80%, 루프 시간 −23%.

```c
static inline int clamp_branchless(int x,int lo,int hi){
  // lo<=x<=hi 로 클램프 (정수)
  int xlo = x - lo;  int xhi = hi - x;
  int s1 = xlo >> 31; // x<lo ? -1 : 0
  int s2 = xhi >> 31; // x>hi ? -1 : 0
  // x < lo → lo, x > hi → hi, else x
  return (x & ~s1 & ~s2) | (lo & s1) | (hi & s2);
}
```

---

## 6. 안티패턴(피해야 할 것)

- **측정 없이 대수술**: 원인 불명, 회귀 위험↑.  
- **한 번에 여러 변경**: 효과·리스크 분리 불가.  
- **p50만 개선**: 체감은 p95/p99.  
- **과도한 인라인/언롤**: I-cache 미스로 역효과.  
- **무제한 캐시**: 정합성·메모리 폭주.

---

## 7. 실전 플레이북(순서형 요약)

1) **핫스팟 식별**: 플레임 Top 10 함수/경로.  
2) **상한 계산**: Amdahl/Little/Roofline → **노선 선택**.  
3) **5분 가설 실험**: 스트라이드1·브랜치리스·배치 I/O **소규모** 적용.  
4) **근본 수정**: SoA/타일링/락 구조/쿼리 벌크화.  
5) **검증**: p95/IPC/미스율, 95% CI, 회귀 알람.  
6) **반복**: 다음 병목으로 이동(“병목은 이동한다”).

---

## 8. 부록 A — 수식·판정 가이드

- **속도향상**  
  $$
  S=\frac{T_{\text{old}}}{T_{\text{new}}}
  $$
- **Amdahl**  
  $$
  \text{Speedup}=\frac{1}{(1-p)+\frac{p}{s}}
  $$
- **Little**  
  $$
  L=\lambda W,\quad W_q\approx\frac{\rho}{\mu(1-\rho)}
  $$
- **Roofline**  
  $$
  \text{Perf}\le \min(\text{PeakFLOPs},\ \text{AI}\cdot \text{BW}),\quad
  \text{AI}=\frac{\text{FLOPs}}{\text{Bytes}}
  $$

**판정 테이블(요약)**

증상 | 카운터/징후 | 1차 처방 | 2차 처방
---|---|---|---
IPC<1, LLC-miss↑ | backend bound | 타일·SoA·프리패치 | 알고리즘/레아이웃 재설계
branch-miss↑ | bad speculation | 브랜치리스·확률정렬 | 테이블화/프로파일 지시
락 대기↑ | lock contention | 샤딩/RW락 | 락없는 구조/워크플로 변경
iowait↑ | 디스크/네트워크 | 배치·비동기 | 포맷·압축·전송경로 개편
dTLB-miss↑ | TLB 병목 | Huge page | 페이지 로컬리티/NUMA 바인딩

---

## 9. 부록 B — 자동 수집 셸 스니펫(10분 프로파일 패킷)

```bash
#!/usr/bin/env bash
APP=${1:-./app}
RUN="${APP} ${@:2}"

echo "[1/5] quick stat"
perf stat -e cycles,instructions,IPC,branches,branch-misses,\
L1-dcache-load-misses,LLC-load-misses,dTLB-load-misses \
-- $RUN 2>&1 | tee perf.stat.txt

echo "[2/5] sampling profile"
perf record -F 997 -g -- $RUN
perf report --stdio | tee perf.report.txt

echo "[3/5] syscall mix"
strace -c $RUN 2>&1 | tee strace.c.txt

echo "[4/5] io/disk"
(iostat -xz 1 & pid=$!; sleep 5; kill $pid) | tee iostat.txt

echo "[5/5] locks (if supported)"
perf lock record -- $RUN
perf lock report --stdio | tee perf.lock.txt
```

> 산출물(`perf.stat.txt`, `perf.report.txt`, `strace.c.txt`, `iostat.txt`, `perf.lock.txt`)을 결과 보고서에 **그대로 인용**하면, “왜 빨라졌는지”를 **증거 기반**으로 설명할 수 있다.

---

## 10. 맺음말

병목 제거는 **과학적 실험(측정·가설·검증)** 과 **공학적 절제(한 번에 하나)** 의 합이다.  
핵심은 **데이터 이동을 줄이고(메모리·I/O)**, **경합을 줄이며(락·큐)**, **CPU가 쉬지 않게(벡터·TLP·MLP)** 만드는 것.  
이 문서의 절차·표·코드·스니펫을 **그대로** 적용하면, 어떤 스택이든 “어디가 느린지”를 빠르게 찾고 **지속적으로** 빨라질 것이다.