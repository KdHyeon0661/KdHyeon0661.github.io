---
layout: post
title: 운영체제 - 동기화 도구 (1)
date: 2025-10-20 17:25:23 +0900
category: 운영체제
---
# Chapter 6 — Synchronization Tools

본 장은 **공유 자원에 대한 동시 접근**이 왜 위험한지를 실험으로 보여 주고,
그 해결을 위한 **임계구역(Critical Section) 문제**의 정식 요건을 정리한 뒤,
고전적 해법인 **피터슨(Peterson) 알고리즘**을 **코드/불변식 증명** 레벨로 파헤친다.

---

## Background

### 왜 동기화가 필요한가

멀티스레드/멀티코어 환경에서 여러 실행 단위가 **동일한 메모리 셀**을 읽고 쓰면 **경쟁 조건(Race Condition)** 이 발생한다.
결과는 타이밍에 의존 → **재현이 어렵고**, **테스트 환경이 바뀌면 증상이 달라진다**.

#### 예제 A — 데이터 레이스의 가시화(의도적 버그)

```cpp
// race_demo.cpp : 동일 변수에 동시 write — 보호 없음
#include <thread>
#include <vector>
#include <iostream>

int main(){
    const int T=4, N=500000;
    int counter=0; // 보호되지 않은 공유 변수
    std::vector<std::thread> th;
    for(int t=0;t<T;t++) th.emplace_back([&]{ for(int i=0;i<N;i++) counter++; });
    for(auto& x:th) x.join();
    std::cout<<"counter="<<counter<<" (expected="<<T*N<<")\n";
}
```
```bash
g++ -O2 -std=c++17 race_demo.cpp -o race && ./race
# counter 값이 기대치보다 작게(혹은 운 좋으면 같게) 나타난다.

```

**원인**: CPU는 `counter++`를 **읽기→증가→쓰기** 세 단계로 나눠 수행한다.
두 스레드가 같은 값을 읽으면 **증가 2번이 1번처럼 사라지는 Lost Update**가 발생.

---

### 병행 실행과 메모리 일관성

현대 CPU는 **파이프라인·Out-of-Order·캐시**를 사용하고, 컴파일러도 **재배치**를 한다.
따라서, 코드의 소스 순서 ≠ 실제 관측 순서. 이 때문에 “보이는 순서”를 정의해야 한다.

- **순차일관성(Sequential Consistency)**:
  $$\text{모든 연산이 어떤 단일한 총순서로 실행된 것처럼 보인다.}$$
  Peterson 알고리즘 같은 고전적 소프트웨어 락은 **순차일관성**을 전제한다.
- 약한 메모리 모델(ARM/POWER, 심지어 x86의 Store→Load)은 **배리어**가 필요.

---

### 동기화 원시(Primitives)

- **뮤텍스/스핀락**: 상호배제 보장(커널 혹은 사용자 공간 구현)
- **세마포어**: 정량적 자원 카운팅(0/1이면 이진 세마포어)
- **조건변수**: 상태 변화 알림(대기/깨우기)
- **원자적 연산**: CAS, fetch_add 등(락 프리 구조의 기반)
- **메모리 배리어**: 컴파일러/CPU 재배치 억제, 가시성 순서 지정

> 본 절에서는 **고전적 소프트웨어 해법**(Peterson)을 먼저 다루고,
> 하드웨어 원자 연산/OS 락은 이후 장에서 체계적으로 확장한다.

---

## The Critical-Section Problem

**임계구역(CS)**: 여러 스레드가 **동시에 접근하면 안 되는 공유 자원**을 조작하는 코드 구간.
해결 목표는 다음 3요건을 만족하는 **프로토콜(진입/퇴출/잔여 구역)**을 설계하는 것.

### 세 가지 요건 (모든 해법의 채점표)

1. **상호배제 (Mutual Exclusion)**
   임계구역에 **동시에 둘 이상 진입하지 않는다.**
   $$\neg(\text{CS}_i \wedge \text{CS}_j) \ \forall i\neq j.$$

2. **진행(Progress)**
   임계구역에 들어가려는 스레드가 존재하고, 실제로 **CS 내부가 비어** 있는 경우,
   **언제든 잔여 구역에 있는 스레드만이** 다음 진입자를 결정해야 하며,
   결정은 **유한 시간 안에** 내려져야 한다.
   (*임계구역에 이미 들어간 스레드가 결정에 관여하면 안 됨.*)

3. **한정 대기(Bounded Waiting)**
   어떤 스레드가 진입 요청을 한 시점부터, **그 이후에 다른 스레드가 CS에 들어가는 횟수**는 **유한**해야 한다.
   즉, **기아(Starvation)** 가 존재하면 안 된다.

### 왜 스핀? 왜 블록?

- **스핀 대기**: 바쁜 루프(polling). 짧은 임계구역, 커널 진입 회피에 유리.
- **블록 대기**: 커널로 진입해 수면/깨우기. 긴 임계구역/컨텐션이 높은 경우에 유리.

### 잘못된(혹은 불완전한) 시도들

#### 실패 예 1 — 단일 플래그

```c
// broken1.c : flag[i]==true 이면 내가 CS에 있음
volatile int flag[2]={0,0};
void enter(int i){ flag[i]=1; /* 바로 진입 */ }
void leave(int i){ flag[i]=0; }
```
- **동시 설정** 시 상호배제 깨짐.

#### 실패 예 2 — turn만 사용

```c
volatile int turn=0;
void enter(int i){ while(turn!=i){} /* wait */ } // 다른 쪽 차례까지 영원 대기 가능
void leave(int i){ turn=1-i; }
```
- 둘 다 진입 원치 않아도 특정 쪽만 계속 권한을 가짐 → **진행 위배**.

#### 실패 예 3 — flag + turn 조합의 아슬아슬한 변형

순서/재배치에 취약. 올바른 해법인 **Peterson**은 이 조합을 **엄밀히** 구성한다.

---

## Peterson’s Solution (2-프로세서 전용, 순차일관성 가정)

### 알고리즘

두 스레드 \(i\in\{0,1\}\) 에 대해:

- `flag[i]`: “**나 들어갈 거야**” 의사 표시
- `turn`: **상대에게 양보**한 마지막 주체

```c
// peterson.h — 두 스레드 전용. 메모리 모델: 순차일관성(혹은 적절한 배리어)
typedef struct {
    volatile int flag[2];
    volatile int turn;
} peterson_t;

static inline void peterson_init(peterson_t* p){
    p->flag[0]=p->flag[1]=0; p->turn=0;
}

static inline void peterson_enter(peterson_t* p, int i){
    int j = 1 - i;
    p->flag[i] = 1;          // 내가 들어가고 싶다
    p->turn = j;             // 상대에게 우선권 양보
    while (p->flag[j] && p->turn == j) { /* busy wait */ }
}

static inline void peterson_leave(peterson_t* p, int i){
    p->flag[i] = 0;          // 나는 이제 관심 없음
}
```

> **직관**: 나도 원하지만(`flag[i]=1`) **마지막 양보는 상대에게** 했기에(`turn=j`),
> **둘 다 원하면** 항상 **turn이 가리키는 쪽이 양보**하고, 다른 쪽이 들어간다.
> 나중에 빠져나오면 상대가 들어가고, 그 다음엔 내 차례가 돌아온다 → **한정 대기** 충족.

---

### 상호배제 증명 스케치(불변식)

**가정**: 순차일관성(모든 스레드에서 읽기/쓰기가 **하나의 총순서**에서 일어난다).

불변식 \(I\):
> 두 스레드가 모두 `flag[i]=flag[j]=1` 이고 **동시에** `CS`에 있을 수는 없다.

**증명 아이디어**
- 두 스레드가 동시에 루프를 통과하려면, 각각 `while (flag[other] && turn==other)` 조건이 **거짓**이어야 한다.
- 둘 다 거짓이려면, **각자** `turn==내가` 이어야 한다.
- 그러나 `turn`은 **스칼라 단일 변수** → 동시에 서로 다른 값을 가질 수 없음 → 모순.
따라서 상호배제.

---

### 진행(Progress) 증명 스케치

- 임계구역에 진입하려는 스레드가 있고 CS가 비어 있다면,
  상대가 진입 의사가 없거나(`flag[j]=0`) 내게 양보했을 때(`turn!=j`) 루프를 **즉시 통과**한다.
- 누가 다음에 들어갈지 결정하는 자는 **잔여 구역에 있는 스레드**만(양보/의사표시 조작).
- 변수 갱신은 유한 시간에 일어나므로 **진행** 만족.

---

### 한정 대기(Bounded Waiting) 스케치

- 내가 진입 요청(`flag[i]=1`)을 걸면, 그 이후 **상대가 CS에 들어갈 수 있는 횟수**는 많아야 **1회**.
  이유: 상대가 나가기 전에 `turn`은 **나**로 바뀌지 않으며, 내가 계속 요청 중이므로 다음 턴엔 **내가** 들어간다.

---

### 실제 코드로 관측(2스레드 카운터)

```cpp
// peterson_demo.cpp — Peterson으로 보호 vs 보호 없음 비교
#include <thread>
#include <iostream>
#include <vector>
#include <atomic>
#include <chrono>

struct Peterson {
    volatile int flag[2]; volatile int turn;
    Peterson(){ flag[0]=flag[1]=0; turn=0; }
    void enter(int i){
        int j=1-i;
        flag[i]=1;
        turn=j;
        while(flag[j] && turn==j) { /* spin */ }
    }
    void leave(int i){ flag[i]=0; }
};

int main(){
    const int N=2'000'000;
    // 1) 보호 없음
    {
        int x=0;
        std::thread t0([&]{ for(int i=0;i<N;i++) x++; });
        std::thread t1([&]{ for(int i=0;i<N;i++) x++; });
        t0.join(); t1.join();
        std::cout<<"[No lock] x="<<x<<" (expected="<<2*N<<")\n";
    }
    // 2) Peterson 보호
    {
        int x=0; Peterson P;
        auto f=[&](int id){
            for(int i=0;i<N;i++){
                P.enter(id);
                x++;            // 임계 구역
                P.leave(id);
            }
        };
        std::thread t0(f,0), t1(f,1);
        t0.join(); t1.join();
        std::cout<<"[Peterson] x="<<x<<" (expected="<<2*N<<")\n";
    }
}
```
```bash
g++ -O2 -std=c++17 peterson_demo.cpp -o pdemo && ./pdemo
# [No lock] x=... (종종 작음)
# [Peterson] x=4000000 (정확)

```

> **주의**: 위 구현은 **순차일관성**을 암묵적으로 가정한다.
> 강한 x86에서도 이 예제는 보통 잘 동작하지만, **엄밀하게는 배리어가 필요**하다(특히 ARM/POWER).

---

### 현대 CPU에서의 주의점(메모리 장벽)

#### 왜 “`volatile`만으론 부족한가?”

- `volatile`은 **컴파일러**의 최적화(레지스터 캐싱 등)를 줄일 뿐,
  **코어 간 가시성 순서**(Load/Store 재배치)는 통제하지 **못한다**.

#### C/C++ 표준 원자와 배리어 버전

```cpp
// peterson_atomic.cpp — 원자 + 명시적 메모리 오더
#include <atomic>

struct PetersonAto {
    std::atomic<bool> flag[2];
    std::atomic<int>  turn;
    PetersonAto(){ flag[0]=false; flag[1]=false; turn.store(0, std::memory_order_relaxed); }

    void enter(int i){
        int j=1-i;
        flag[i].store(true, std::memory_order_relaxed);
        std::atomic_thread_fence(std::memory_order_release); // flag[i] 이전 write들을 내보낸다
        turn.store(j, std::memory_order_relaxed);
        // 상대의 flag==true 를 관측하고, turn==j 이면 양보
        for(;;){
            std::atomic_thread_fence(std::memory_order_acquire); // 이후 read가 앞 write를 본다
            if(!flag[j].load(std::memory_order_relaxed) || turn.load(std::memory_order_relaxed)!=j) break;
        }
    }
    void leave(int i){
        std::atomic_thread_fence(std::memory_order_release);
        flag[i].store(false, std::memory_order_relaxed);
    }
};
```

> **설명**
> - `release/acquire` 장벽으로 **happens-before** 관계를 형성해 **가시성/순서**를 확보.
> - 간결하게는 모든 R/W에 `seq_cst`를 써도 된다(단, 비용↑).

---

### 한계와 적용 범위

- **2스레드 전용**: 3개 이상 스레드에는 적용 불가(확장판은 Lamport Bakery 등).
- **스핀 대기**: 긴 임계구역/컨텐션 환경에서는 **비효율**.
- **메모리 모델 의존**: 약한 메모리 모델에서는 **배리어가 필요**.
- **OS/런타임 제공 락**이 있는 실제 시스템에서는 보통 **뮤텍스/스핀락**을 사용한다.
  (뮤텍스는 커널 도움을 받아 **공정성/대기 차단** 등 부가 보장을 제공 가능)

---

### 비교 — Dekker, Bakery, Test-and-Set 기반 락

| 기법 | 스레드 수 | 필요 가정 | 공정성/한정대기 | 비고 |
|---|---:|---|---|---|
| **Dekker** | 2 | 순차일관성 | OK | 최초의 올바른 해법, 바쁜 대기 |
| **Peterson** | 2 | 순차일관성(또는 배리어) | OK | 코드 간결, 실전 학습 표준 |
| **Bakery (Lamport)** | N | 정수 비교 원자성 | OK | 번호표 기반, 캐시 부담↑ |
| **TAS 스핀락** | N | 하드웨어 원자성(CAS/TAS) | 불공정 가능 | 간단/빠름, 실전에서 backoff·티켓락·MCS로 발전 |

---

## 부록: 실험 과제 & 자동 검증 힌트

### A. 무한 루프/기아 재현하기

Peterson에서 `turn` 갱신/관측 순서를 의도적으로 **약화**(배리어 제거)해 ARM 시뮬레이터/실기기에서 **행동 차이**를 관찰하라.

### B. 간단 모델체킹(아이디어)

상태를 `flag[2]∈{0,1}`, `turn∈{0,1}`, 각 스레드 PC(진입/대기/CS/퇴출)로 정의하고,
**상태 그래프**를 완전 탐색하여 “`CS0 ∧ CS1`” 상태가 존재하지 않음을 확인한다.

### C. 스핀락 vs 뮤텍스 비교

같은 임계구역 길이/경합도에서 **스핀 시간**과 **블록 전환**의 임계점을 측정하라.
짧은 CS(수십 ns~수 μs)는 스핀이 유리, 그 이상은 뮤텍스가 유리해지는 지점이 있다.

---

## 요약

- **6.1**: 동시성 버그는 **타이밍 의존**이라 재현이 어렵다. 메모리 모델/배리어의 의미를 이해해야 한다.
- **6.2**: 임계구역 문제의 **3요건(상호배제·진행·한정대기)** 는 모든 해법의 기준.
- **6.3**: **Peterson 알고리즘**은 2스레드에서 이 3요건을 **순차일관성** 하에 만족시키는 고전 해법이다.
  실제 하드웨어에서는 **원자/배리어**로 가정을 보강하거나, **OS 제공 락**을 사용한다.

---

## 빠른 실습 체크리스트

1) `race_demo.cpp`를 여러 코어에서 반복 실행해 **비결정성**을 체감한다.
2) `peterson_demo.cpp`로 **정확성 회복**을 확인한다.
3) `peterson_atomic.cpp`로 **배리어의 필요성**을 코드로 익힌다.
4) 컨텐션을 높여 **스핀 대기 비용**을 관찰하고, 같은 시나리오에서 **뮤텍스**와 비교한다.
5) Bakery/TAS 스핀락으로 확장해 **N-way** 설계 감각을 익힌다.
