---
layout: post
title: C++ - 메모리 관리
date: 2024-09-18 19:20:23 +0900
category: Cpp
---
# 메모리 관리와 스마트 포인터: C++ 자원 관리의 핵심

## 스마트 포인터가 필요한 이유: RAII와 예외 안전

C++ 프로그래밍에서 가장 까다로운 문제 중 하나는 메모리와 자원을 안전하게 관리하는 것입니다. 전통적인 C++의 `new`와 `delete`는 개발자가 모든 실행 경로에서 정확히 짝을 맞춰야 합니다. 예외가 발생하거나 로직이 복잡해지면 메모리 누수, 이중 해제, 댕글링 포인터 같은 문제가 쉽게 발생합니다.

이를 해결하기 위한 C++의 핵심 디자인 패턴이 **RAII(Resource Acquisition Is Initialization)**입니다. 자원 획득(생성)을 객체 초기화 시점에, 자원 해제를 객체 소멸자에서 자동으로 처리하는 원칙입니다. 스마트 포인터는 이 RAII 원칙을 메모리 관리에 적용한 구현체입니다.

```cpp
// 전통적인 방식 - 위험
void riskyFunction() {
    Resource* resource = new Resource();
    if (errorCondition()) {
        return;  // 메모리 누수!
    }
    // ... 작업 수행 ...
    delete resource;  // 모든 경로에서 delete를 호출해야 함
}

// 스마트 포인터 사용 - 안전
void safeFunction() {
    auto resource = std::make_unique<Resource>();
    if (errorCondition()) {
        return;  // unique_ptr 소멸자가 자동으로 메모리 해제
    }
    // ... 작업 수행 ...
    // 함수 종료 시 자동으로 메모리 해제
}
```

---

## 스마트 포인터 종류와 특징

### 1. std::unique_ptr - 단독 소유권

`unique_ptr`은 가장 가변이고 효율적인 스마트 포인터입니다. 하나의 객체에 대해 하나의 소유자만 존재하도록 보장하며, 복사가 불가능하고 이동만 가능합니다.

```cpp
#include <memory>
#include <iostream>

class Resource {
public:
    Resource() { std::cout << "Resource 생성\n"; }
    ~Resource() { std::cout << "Resource 소멸\n"; }
    void use() { std::cout << "Resource 사용\n"; }
};

int main() {
    // 기본 사용법
    std::unique_ptr<Resource> ptr1 = std::make_unique<Resource>();
    ptr1->use();
    
    // 소유권 이동
    std::unique_ptr<Resource> ptr2 = std::move(ptr1);  // ptr1은 nullptr이 됨
    
    if (!ptr1) {
        std::cout << "ptr1은 더 이상 소유권이 없음\n";
    }
    
    // 배열 지원
    std::unique_ptr<int[]> array = std::make_unique<int[]>(10);
    array[0] = 100;
    array[9] = 900;
    
    // 커스텀 삭제자 (파일, 소켓 등에 사용)
    struct FileDeleter {
        void operator()(FILE* file) {
            if (file) fclose(file);
            std::cout << "파일 닫힘\n";
        }
    };
    
    std::unique_ptr<FILE, FileDeleter> filePtr(fopen("test.txt", "w"));
    if (filePtr) {
        fprintf(filePtr.get(), "Hello, World!");
    }
    // 파일은 자동으로 닫힘
}
```

**핵심 특징:**
- **단일 소유권**: 한 번에 하나의 `unique_ptr`만 객체를 소유
- **이동 전용**: 복사 불가, 이동만 가능
- **오버헤드 최소**: raw 포인터와 동일한 크기 (컨트롤 블록 없음)
- **배열 지원**: `std::unique_ptr<T[]>` 형태로 동적 배열 관리

### 2. std::shared_ptr - 공유 소유권

`shared_ptr`은 여러 소유자가 동일한 객체를 공유할 수 있게 합니다. 참조 카운트(reference counting) 방식으로 동작하며, 마지막 소유자가 사라질 때 객체를 파괴합니다.

```cpp
#include <memory>
#include <iostream>

class SharedResource {
public:
    SharedResource() { std::cout << "SharedResource 생성\n"; }
    ~SharedResource() { std::cout << "SharedResource 소멸\n"; }
};

int main() {
    // shared_ptr 생성
    auto resource = std::make_shared<SharedResource>();
    std::cout << "참조 카운트: " << resource.use_count() << "\n";  // 1
    
    {
        // 복사 생성 - 참조 카운트 증가
        auto resource2 = resource;
        std::cout << "참조 카운트: " << resource.use_count() << "\n";  // 2
    }  // resource2 소멸 - 참조 카운트 감소
    
    std::cout << "참조 카운트: " << resource.use_count() << "\n";  // 1
    
    // make_shared vs 직접 생성
    auto p1 = std::make_shared<int>(42);  // 권장: 한 번의 할당
    std::shared_ptr<int> p2(new int(42));  // 비권장: 두 번의 할당
    
    // 스레드 간 공유
    auto sharedData = std::make_shared<std::vector<int>>();
    
    // std::thread t1([sharedData] { sharedData->push_back(1); });
    // std::thread t2([sharedData] { sharedData->push_back(2); });
}
```

**핵심 특징:**
- **참조 카운팅**: `use_count()`로 현재 소유자 수 확인 가능
- **원자적 연산**: 멀티스레드 환경에서 안전한 참조 카운트 관리
- **오버헤드**: 컨트롤 블록을 위한 추가 메모리와 원자적 연산 비용
- **순환 참조 문제**: 서로를 가리키는 `shared_ptr`은 메모리 누수 발생 가능

### 3. std::weak_ptr - 약한 참조

`weak_ptr`은 `shared_ptr`이 관리하는 객체를 관찰만 하고, 소유권은 가지지 않습니다. 순환 참조 문제를 해결하거나 객체의 생존 여부만 확인할 때 사용합니다.

```cpp
#include <memory>
#include <iostream>

class Observer {
public:
    void observe(const std::weak_ptr<int>& wp) {
        if (auto sp = wp.lock()) {  // weak_ptr을 shared_ptr로 변환 시도
            std::cout << "값: " << *sp << "\n";
        } else {
            std::cout << "객체가 이미 소멸됨\n";
        }
    }
};

int main() {
    Observer observer;
    std::weak_ptr<int> wp;
    
    {
        auto sp = std::make_shared<int>(100);
        wp = sp;  // weak_ptr은 참조 카운트를 증가시키지 않음
        std::cout << "참조 카운트: " << sp.use_count() << "\n";  // 1
        
        observer.observe(wp);  // 값: 100
    }  // sp 소멸, int 객체 파괴
    
    observer.observe(wp);  // 객체가 이미 소멸됨
}
```

**핵심 특징:**
- **소유권 없음**: 참조 카운트를 증가시키지 않음
- **객체 접근**: `lock()` 메서드로 안전하게 접근 가능
- **순환 참조 해결**: 순환 구조에서 한쪽을 `weak_ptr`로 사용
- **캐시 구현**: 객체 생존 여부 확인용으로 유용

---

## 실전 활용 패턴

### 1. 팩토리 함수에서의 사용

```cpp
#include <memory>
#include <vector>

class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() const = 0;
};

class Circle : public Shape {
public:
    void draw() const override { /* 원 그리기 */ }
};

class Square : public Shape {
public:
    void draw() const override { /* 사각형 그리기 */ }
};

// 팩토리 함수: 소유권을 호출자에게 전달
std::unique_ptr<Shape> createShape(const std::string& type) {
    if (type == "circle") {
        return std::make_unique<Circle>();
    } else if (type == "square") {
        return std::make_unique<Square>();
    }
    return nullptr;
}

int main() {
    auto shapes = std::vector<std::unique_ptr<Shape>>();
    shapes.push_back(createShape("circle"));
    shapes.push_back(createShape("square"));
    
    for (const auto& shape : shapes) {
        shape->draw();
    }
}
```

### 2. 순환 참조 문제와 해결

```cpp
#include <memory>
#include <iostream>

// 문제: 순환 참조
class BadNode {
public:
    std::shared_ptr<BadNode> next;
    ~BadNode() { std::cout << "BadNode 소멸\n"; }
};

// 해결: weak_ptr 사용
class GoodNode : public std::enable_shared_from_this<GoodNode> {
public:
    std::shared_ptr<GoodNode> next;
    std::weak_ptr<GoodNode> prev;  // 한쪽은 weak_ptr로
    
    ~GoodNode() { std::cout << "GoodNode 소멸\n"; }
    
    // shared_ptr로부터 weak_ptr 생성
    std::weak_ptr<GoodNode> getWeak() {
        return shared_from_this();
    }
};

void demonstrateCycle() {
    // 순환 참조 문제
    {
        auto node1 = std::make_shared<BadNode>();
        auto node2 = std::make_shared<BadNode>();
        node1->next = node2;
        node2->next = node1;  // 순환 참조!
        // node1과 node2는 영원히 소멸되지 않음
    }
    
    // 순환 참조 해결
    {
        auto node1 = std::make_shared<GoodNode>();
        auto node2 = std::make_shared<GoodNode>();
        node1->next = node2;
        node2->prev = node1->getWeak();  // weak_ptr 사용
        // node1과 node2가 정상적으로 소멸됨
    }
}
```

### 3. enable_shared_from_this

```cpp
#include <memory>
#include <iostream>

class Object : public std::enable_shared_from_this<Object> {
    int value;
public:
    Object(int v) : value(v) {}
    
    // this 포인터로부터 shared_ptr 생성
    std::shared_ptr<Object> getShared() {
        return shared_from_this();
    }
    
    // 콜백 등록 (weak_ptr로 캡처하여 순환 참조 방지)
    std::function<void()> createCallback() {
        std::weak_ptr<Object> weakSelf = shared_from_this();
        return [weakSelf]() {
            if (auto self = weakSelf.lock()) {
                std::cout << "콜백 실행, 값: " << self->value << "\n";
            }
        };
    }
};

int main() {
    auto obj = std::make_shared<Object>(42);
    auto callback = obj->createCallback();
    callback();  // 콜백 실행
    
    // 여러 곳에서 동일 객체 공유
    auto anotherRef = obj->getShared();
    std::cout << "참조 카운트: " << obj.use_count() << "\n";  // 2
}
```

### 4. 커스텀 삭제자

```cpp
#include <memory>
#include <iostream>

// 다양한 리소스에 대한 커스텀 삭제자
struct FileDeleter {
    void operator()(FILE* file) const {
        if (file) {
            fclose(file);
            std::cout << "파일이 닫혔습니다.\n";
        }
    }
};

struct ArrayDeleter {
    void operator()(int* arr) const {
        delete[] arr;
        std::cout << "배열이 삭제되었습니다.\n";
    }
};

// 타입 별칭으로 사용 편의성 향상
using FilePtr = std::unique_ptr<FILE, FileDeleter>;
using IntArrayPtr = std::unique_ptr<int[], ArrayDeleter>;

int main() {
    // 파일 자동 관리
    FilePtr file(fopen("example.txt", "w"));
    if (file) {
        fprintf(file.get(), "Hello, File!");
    }  // 자동으로 fclose 호출
    
    // 배열 자동 관리
    IntArrayPtr arr(new int[100]);
    arr[0] = 1;
    arr[99] = 100;
    // 자동으로 delete[] 호출
}
```

---

## 성능 고려사항

### 1. 메모리 오버헤드 비교

```cpp
#include <iostream>
#include <memory>

struct Data {
    int values[100];
};

int main() {
    // 메모리 사용량 비교
    Data* rawPtr = new Data();
    std::unique_ptr<Data> uniquePtr = std::make_unique<Data>();
    std::shared_ptr<Data> sharedPtr = std::make_shared<Data>();
    
    std::cout << "raw pointer 크기: " << sizeof(rawPtr) << " bytes\n";
    std::cout << "unique_ptr 크기: " << sizeof(uniquePtr) << " bytes\n";
    std::cout << "shared_ptr 크기: " << sizeof(sharedPtr) << " bytes\n";
    
    delete rawPtr;
}
```

**결과 분석:**
- `unique_ptr`: raw 포인터와 동일한 크기 (보통 8바이트)
- `shared_ptr`: 컨트롤 블록을 위한 추가 메모리 필요 (보통 16바이트)
- `make_shared`: 객체와 컨트롤 블록을 한 번에 할당하여 최적화

### 2. 성능 최적화 팁

```cpp
// 나쁜 예: 불필요한 참조 카운트 증가
void processBad(const std::shared_ptr<Data>& data) {
    // data 사용
}

// 좋은 예: 참조만 필요한 경우
void processGood(const Data& data) {
    // data 사용
}

// shared_ptr을 값으로 전달해야 할 때
void transferOwnership(std::shared_ptr<Data> data) {
    // 소유권 이전
}

int main() {
    auto data = std::make_shared<Data>();
    
    // 불필요한 참조 카운트 증가
    processBad(data);
    
    // 참조 카운트 증가 없음
    processGood(*data);
    
    // 명시적인 소유권 이전
    transferOwnership(data);  // data는 nullptr이 됨
}
```

---

## 멀티스레드 환경에서의 사용

### 1. 스레드 안전성

```cpp
#include <memory>
#include <thread>
#include <vector>
#include <iostream>

class ThreadSafeResource {
    std::shared_ptr<int> data;
    mutable std::mutex mutex;
    
public:
    ThreadSafeResource() : data(std::make_shared<int>(0)) {}
    
    void increment() {
        std::lock_guard<std::mutex> lock(mutex);
        (*data)++;
    }
    
    int getValue() const {
        std::lock_guard<std::mutex> lock(mutex);
        return *data;
    }
    
    // shared_ptr 자체는 스레드 안전하지만
    // 객체 접근은 동기화 필요
    std::shared_ptr<int> getSharedData() {
        std::lock_guard<std::mutex> lock(mutex);
        return data;  // 참조 카운트 증가는 원자적
    }
};

void worker(std::shared_ptr<ThreadSafeResource> resource, int id) {
    for (int i = 0; i < 1000; ++i) {
        resource->increment();
    }
    std::cout << "스레드 " << id << " 완료\n";
}

int main() {
    auto resource = std::make_shared<ThreadSafeResource>();
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(worker, resource, i);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "최종 값: " << resource->getValue() << "\n";  // 10000
}
```

**스레드 안전성 정리:**
- `shared_ptr`의 **참조 카운트 연산**은 원자적 (스레드 안전)
- `shared_ptr` **객체 자체**에 대한 동시 접근은 스레드 안전하지 않음
- `shared_ptr`이 가리키는 **데이터**에 대한 접근은 추가 동기화 필요

---

## 실전 가이드: 어떤 스마트 포인터를 선택할 것인가?

### 선택 가이드라인

1. **단일 소유권이 명확한 경우** → `std::unique_ptr`
   ```cpp
   // 소유권이 명확히 한 곳에 있는 경우
   class Document {
       std::unique_ptr<Content> content;  // Document만 소유
   public:
       Document() : content(std::make_unique<Content>()) {}
   };
   ```

2. **여러 곳에서 공유해야 하는 경우** → `std::shared_ptr`
   ```cpp
   // 여러 컴포넌트가 동일 객체 공유
   class Cache {
       std::shared_ptr<Database> db;  // 여러 Cache 인스턴스가 공유
   };
   ```

3. **순환 참조 가능성이 있는 경우** → `std::weak_ptr`
   ```cpp
   // 양방향 관계에서 한쪽은 weak_ptr 사용
   class TreeNode {
       std::shared_ptr<TreeNode> child;
       std::weak_ptr<TreeNode> parent;  // 순환 방지
   };
   ```

4. **API 설계 시**
   - **소유권 이전**을 나타낼 때: `std::unique_ptr` 매개변수
   - **공유 소유권**을 나타낼 때: `std::shared_ptr` 매개변수
   - **옵셔널 읽기 전용** 접근: raw 포인터 또는 참조
   - **객체 관찰만**: `std::weak_ptr` 매개변수

### 안티 패턴과 주의사항

```cpp
// ❌ 나쁜 예: 스마트 포인터의 오용
void antiPatterns() {
    // 1. 불필요한 shared_ptr 사용
    auto localObj = std::make_shared<int>(42);  // unique_ptr로 충분
    
    // 2. this를 shared_ptr로 변환 (enable_shared_from_this 없이)
    // std::shared_ptr<MyClass> ptr(this);  // 매우 위험!
    
    // 3. 배열을 잘못된 스마트 포인터로 관리
    // std::unique_ptr<int> arr(new int[10]);  // 메모리 누수!
    // std::unique_ptr<int[]> arr(new int[10]);  // 올바른 방법
    
    // 4. 순환 참조
    struct BadNode {
        std::shared_ptr<BadNode> other;
    };
    auto n1 = std::make_shared<BadNode>();
    auto n2 = std::make_shared<BadNode>();
    n1->other = n2;
    n2->other = n1;  // 메모리 누수!
    
    // 5. 참조 카운트에 의존한 로직
    auto ptr = std::make_shared<int>(10);
    if (ptr.use_count() == 1) {  // 신뢰할 수 없음 (경쟁 조건)
        // ...
    }
}
```

---

## 고급 활용: 타입 지우기와 가상 소멸자

```cpp
#include <memory>
#include <iostream>
#include <vector>

// 타입 지우기(Type Erasure) 패턴
class AnyResource {
    struct Concept {
        virtual ~Concept() = default;
        virtual void use() = 0;
    };
    
    template<typename T>
    struct Model : Concept {
        T resource;
        Model(T&& r) : resource(std::move(r)) {}
        void use() override { resource.use(); }
    };
    
    std::unique_ptr<Concept> pimpl;
    
public:
    template<typename T>
    AnyResource(T&& r) 
        : pimpl(std::make_unique<Model<T>>(std::forward<T>(r))) {}
    
    void use() { pimpl->use(); }
};

class File { public: void use() { std::cout << "파일 사용\n"; } };
class Socket { public: void use() { std::cout << "소켓 사용\n"; } };

int main() {
    std::vector<AnyResource> resources;
    resources.emplace_back(File());
    resources.emplace_back(Socket());
    
    for (auto& res : resources) {
        res.use();
    }
}
```

---

## 결론: 현대적인 C++ 메모리 관리 철학

스마트 포인터는 C++에서 메모리 관리를 안전하고 효율적으로 만드는 핵심 도구입니다. 올바르게 사용할 때의 핵심 원칙은 다음과 같습니다:

1. **"new와 delete는 가능한 사용하지 말라"** - 스마트 포인터를 기본으로 사용하세요.
2. **소유권을 명시적으로 표현하라** - `unique_ptr`은 단독 소유권, `shared_ptr`은 공유 소유권을 의미합니다.
3. **RAII를 생활화하라** - 자원 획득은 생성자에서, 해제는 소멸자에서 처리하도록 설계하세요.
4. **순환 참조에 주의하라** - `weak_ptr`을 활용하여 순환 구조에서의 메모리 누수를 방지하세요.
5. **성능을 고려하라** - `unique_ptr`이 가장 가볍고, `shared_ptr`은 오버헤드가 있습니다.
6. **멀티스레드 환경을 고려하라** - `shared_ptr`의 참조 카운트는 안전하지만, 객체 접근은 별도 동기화가 필요합니다.

스마트 포인터는 단순히 메모리 누수를 방지하는 도구를 넘어, C++ 코드의 설계 의도를 명확히 전달하고, 리소스 수명 관리를 체계적으로 할 수 있게 합니다. 현대 C++ 코드에서는 raw 포인터 대신 스마트 포인터를 기본으로 사용하고, 소유권과 수명 관리에 대한 의도를 타입 시스템을 통해 명확히 표현하는 것이 좋은 습관입니다.