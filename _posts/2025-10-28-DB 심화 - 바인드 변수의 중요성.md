---
layout: post
title: DB 심화 - 바인드 변수의 중요성
date: 2025-10-28 19:25:23 +0900
category: DB 심화
---
# 바인드 변수의 중요성(Oracle 중심)

> **핵심 한 줄**: *바인드 변수*를 쓰면 **커서 공유**가 잘 되어 **하드 파싱**이 줄고, **뮤텍스/래치 경합**이 사라지며, **메모리/CPU**가 절약되고, **SQL 인젝션**까지 막을 수 있다. 바인드 피킹/스큐 같은 *예외 상황*은 **히스토그램 + ACS + 플랜 안정화**로 관리한다.

---

## 왜 바인드 변수인가? (문제 → 원인 → 해법)

- **문제**: 트래픽이 오를수록 **`parse count (hard)`** 와 `library cache: mutex X/S` 대기가 폭증, CPU는 한가한데 응답은 느리다.
- **원인**: 같은 형태의 SQL이 **리터럴 값만 달라** 수천 개 **Parent 커서**로 쪼개지고, 매번 **하드 파싱**과 **최적화**를 반복.
- **해법**: **바인드 변수**로 텍스트를 **정규화**해 **Parent 1개 + 필요한 Child 소수**만 유지 → **소프트 파싱** 중심으로 전환.

---

## 개념 정리: 바인드 변수와 커서 공유

- **바인드 변수**: 값(리터럴)을 SQL 텍스트에서 분리, **자리표시자(:p1, :dt 등)** 로 전달.
- **효과**: 텍스트가 동일해져 **Parent 커서(SQL_ID)** 가 **하나**로 합쳐지고, 조건이 같으면 **Child**(실행 단위)도 재사용.
- **수학적 직관**:
  $$ \text{하드파싱 부하} \propto \#\text{Parent} \times (\text{Child 생성율}) $$
  **Parent**를 1개로 만들면 하드파싱 부하가 **선형↓**.

---

## 첫 번째 데모 — 리터럴 남용 vs 바인드 변수
### 실험 테이블

```sql
CREATE TABLE t_demo_bind (
  id   NUMBER PRIMARY KEY,
  rgn  VARCHAR2(10),
  amt  NUMBER,
  dt   DATE
);

INSERT /*+ APPEND */ INTO t_demo_bind
SELECT level,
       CASE MOD(level,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END,
       ROUND(DBMS_RANDOM.VALUE(10,1000),2),
       DATE '2025-10-01' + MOD(level, 30)
FROM dual CONNECT BY level <= 200000;
COMMIT;

CREATE INDEX ix_t_demo_bind_rgn_dt ON t_demo_bind(rgn, dt);
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'T_DEMO_BIND',cascade=>TRUE,
     method_opt=>'FOR COLUMNS SIZE 75 rgn SIZE 75 dt');
```

### 리터럴 남용(나쁜 예)

```sql
-- 같은 구조, 값만 다름 → Parent 커서 폭증
SELECT /* literal-demo */ COUNT(*) FROM t_demo_bind WHERE rgn='APAC';
SELECT /* literal-demo */ COUNT(*) FROM t_demo_bind WHERE rgn='EMEA';
SELECT /* literal-demo */ COUNT(*) FROM t_demo_bind WHERE rgn='AMER';
-- 애플리케이션은 매 요청마다 값이 달라지므로 Parent가 끝도 없이 늘어난다.
```

### 바인드 변수(좋은 예)

```sql
VAR r VARCHAR2(10); EXEC :r := 'APAC';
SELECT /* bind-demo */ COUNT(*) FROM t_demo_bind WHERE rgn=:r;

EXEC :r := 'EMEA';
SELECT /* bind-demo */ COUNT(*) FROM t_demo_bind WHERE rgn=:r;

EXEC :r := 'AMER';
SELECT /* bind-demo */ COUNT(*) FROM t_demo_bind WHERE rgn=:r;
```

### 관찰 스크립트

```sql
-- Parent/Child/파싱 비교
SELECT sql_id, COUNT(*) children, SUM(parse_calls) parse_calls, SUM(executions) execs
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* literal-demo */%'
   OR  sql_text LIKE 'SELECT /* bind-demo */%'
GROUP  BY sql_id
ORDER  BY children DESC;

-- 시스템 파싱 지표
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('parse count (total)','parse count (hard)','parse time elapsed');
```
**예상 결과**
- *리터럴*: **SQL_ID(Parent)** 가 여러 개, `parse_calls`↑.
- *바인드*: **SQL_ID 1개**에 **Child 소수**, `parse_calls`↓ → **소프트 파싱** 위주.

---

## 성능 관점: 무엇이 정확히 좋아지는가?

1) **하드 파싱 감소** → CPU/라이브러리 캐시 경합 감소.
2) **뮤텍스/래치 대기 감소**: `library cache: mutex X/S`, `cursor: pin S wait on X` 감소.
3) **메모리 절감**: 커서/플랜 힙 중복 적재가 줄어 **Shared Pool** 안정.
4) **플랜 안정성 개선**: 동일 텍스트 유지 → **플랜 베이스라인/SPM** 적용이 쉬움.
5) **보안**: **SQL Injection** 방어(값이 따로 전달되어 **파서가 구조를 바꾸지 않음**).

---

## 보안 데모 — 바인드 변수 vs SQL 인젝션
### 취약한 코드(동적 리터럴 결합)

```plsql
DECLARE
  v_user VARCHAR2(30) := :p_user;
  v_sql  VARCHAR2(4000);
  v_cnt  NUMBER;
BEGIN
  v_sql := 'SELECT COUNT(*) FROM accounts WHERE owner = '''||v_user||'''';
  EXECUTE IMMEDIATE v_sql INTO v_cnt; -- ❌ 취약
  DBMS_OUTPUT.PUT_LINE('cnt='||v_cnt);
END;
/
```
- `:p_user`에 `'ADMIN' OR '1'='1` 같은 페이로드가 들어오면 전체 행 카운트가 노출.

### 안전한 코드(바인드 사용)

```plsql
DECLARE
  v_user VARCHAR2(30) := :p_user;
  v_cnt  NUMBER;
BEGIN
  EXECUTE IMMEDIATE
    'SELECT COUNT(*) FROM accounts WHERE owner = :b1'
    INTO v_cnt
    USING v_user; -- ✅ 파서가 구조를 안전하게 고정
  DBMS_OUTPUT.PUT_LINE('cnt='||v_cnt);
END;
/
```

---

## & ACS(Adaptive Cursor Sharing)

> 바인드 변수의 **실행 품질**은 *초기 피킹 값*과 *스큐*에 영향을 받는다. 이를 **히스토그램 + ACS + 통계 피드백**으로 제어.

### 현상 요약

- **바인드 피킹**: 첫 실행시 바인드 값으로 선택도 추정 → 플랜 고정 가능.
- **스큐**: 값에 따라 행수 편차가 매우 크면 *한 플랜*이 **모든 값에 최적**이 아니게 된다.
- **ACS**: 바인드 분포를 학습, **Child 커서**를 값 범위별로 분리(예: APAC→Hash Join, AMER→NL).

### 관찰 예제

```sql
-- 스큐 컬럼에 히스토그램
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'T_DEMO_BIND',cascade=>TRUE,
     method_opt=>'FOR COLUMNS SIZE 75 rgn');

VAR r VARCHAR2(10);

EXEC :r := 'APAC'; -- 고빈도
SELECT /* acs-demo */ SUM(amt) FROM t_demo_bind WHERE rgn=:r;

EXEC :r := 'AMER'; -- 저빈도
SELECT /* acs-demo */ SUM(amt) FROM t_demo_bind WHERE rgn=:r;

-- Child/ACS 상태
SELECT sql_id, child_number, is_bind_sensitive, is_bind_aware, plan_hash_value
FROM   v$sql WHERE sql_text LIKE 'SELECT /* acs-demo */%'
ORDER  BY child_number;

-- Child 분기 이유
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_text LIKE 'SELECT /* acs-demo */%'
  AND  reason IS NOT NULL AND reason <> 'N';
```

### 운영 가이드

- **스큐 컬럼**엔 **히스토그램**(도수분포) 생성으로 **카디널리티 정확화**.
- ACS가 필요한 만큼만 **Child**를 만든다면 *문제가 아니라 이점*.
- Child 과다 시 **히스토그램 정밀도** 조정, **쿼리 의도**를 명확히(범위 분기), 필요하면 **SPM**으로 플랜 제한.

---

## 애플리케이션 레이어에서의 바인드 — 언어별 예제

### Java(JDBC)

```java
String sql = "SELECT SUM(amt) FROM t_demo_bind WHERE rgn = ? AND dt BETWEEN ? AND ?";
try (PreparedStatement ps = conn.prepareStatement(sql)) {
    ps.setString(1, region);        // 바인드 #1
    ps.setDate(2, java.sql.Date.valueOf(from)); // #2
    ps.setDate(3, java.sql.Date.valueOf(to));   // #3
    try (ResultSet rs = ps.executeQuery()) {
        if (rs.next()) { return rs.getBigDecimal(1); }
    }
}
```

### Python (cx_Oracle / oracledb)

```python
sql = "SELECT COUNT(*) FROM t_demo_bind WHERE rgn = :r AND dt >= :d1"
cur.execute(sql, r="APAC", d1=datetime.date(2025,10,1))
count, = cur.fetchone()
```

### .NET (ODP.NET)

```csharp
var cmd = new OracleCommand(
    "SELECT SUM(amt) FROM t_demo_bind WHERE rgn = :r AND dt BETWEEN :d1 AND :d2", conn);
cmd.Parameters.Add(new OracleParameter("r", "APAC"));
cmd.Parameters.Add(new OracleParameter("d1", new DateTime(2025,10,1)));
cmd.Parameters.Add(new OracleParameter("d2", new DateTime(2025,10,31)));
var result = cmd.ExecuteScalar();
```

> **주의**: 바인드 **타입/길이 일치**는 매우 중요. 세션/드라이버가 **NVARCHAR2 vs VARCHAR2**를 달리 매핑하면 **Child 분기(BIND_MISMATCH)** 가 발생.

---

## 날짜/문자 바인드 모범사례

### 날짜 비교 — 함수 제거 & 범위식

```sql
-- ❌ 나쁜 예: 컬럼에 함수
WHERE TRUNC(dt) = DATE '2025-10-15'

-- ✅ 좋은 예: 바인드 + 범위
WHERE dt >= :d1 AND dt < :d2
```
- 옵티마이저는 **함수로 감싼 컬럼**의 인덱스/통계를 활용하기 어렵다.

### NLS/언어 이슈

```sql
-- ❌ 나쁜 예: 문자열 날짜 + NLS 의존
WHERE dt = '2025/10/15'

-- ✅ 좋은 예: DATE 바인드
WHERE dt = :d
```
- **NLS_DATE_LANGUAGE/FORMAT** 차이는 Child 분기/카디널리티 왜곡 원인.

---

## 바인드 변수의 “함정”과 올바른 처방

### 바인드 피킹 플랜 오류

- **증상**: 특정 값에서만 느리다.
- **처방**: 히스토그램 + ACS. 필요한 경우 **값대별 SQL 분기**(업무 의도 반영) 또는 **SPM**.

### `CURSOR_SHARING=FORCE`의 유혹

- **장점**: 리터럴 폭주를 빠르게 진정.
- **단점**: 히스토그램 기반 선택도 무력화 → 플랜 품질 저하 가능.
- **원칙**: **응급시 임시** 사용, 근본 해결은 **앱 바인드 전환**.

### Child 폭증(환경 불일치)

- **증상**: Parent 1개에 Child 수십~수백.
- **원인**: 세션 파라미터/NLS/바인드 타입 불일치, 스키마 해석 차이.
- **처방**: **세션 환경 표준화**, **바인드 타입/길이 고정**, 로그인 트리거/풀 설정.

---

## 운영 중 점검 스크립트 묶음

### 파싱 부담/커서 공유 현황

```sql
-- 시스템 파싱 지표
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('parse count (total)','parse count (hard)','parse time elapsed');

-- Parent/Child 현황(패턴 매칭)
SELECT sql_id, COUNT(*) children, SUM(parse_calls) parse_calls, SUM(executions) execs
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* bind-demo */%'
GROUP  BY sql_id
ORDER  BY children DESC;
```

### 공유 실패 이유

```sql
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_text LIKE 'SELECT /* bind-demo */%'
  AND  reason IS NOT NULL AND reason <> 'N'
ORDER  BY child_number;
```

### 바인드 캡처/피킹 확인

```sql
SELECT sql_id, child_number, is_bind_sensitive, is_bind_aware,
       plan_hash_value, last_active_time
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* acs-demo */%'
ORDER  BY child_number;

-- 커서 라인 통계 + 피킹된 바인드
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  sql_id => '&&SQL_ID', child_number => NULL,
  format => 'ALLSTATS LAST +PEEKED_BINDS +PREDICATE +NOTE +OUTLINE'));
```

---

## 보고서/배치에서의 바인드 전략

### “값이 매번 바뀌는 대용량 보고서”

- **바인드**는 파싱 측면에서 필수.
- 정렬/집계가 크면 **정렬 회피 인덱스**·**선행 집계 MV** 고려.
- **PGA/Temp 정책**과 함께 **플랜 안정화(SPM)** 로 재현성 확보.

### “소수 값만 매우 큰 스큐”

- 값대별로 **의도적 SQL 분기**(예: VIP 지역은 별도 SQL) 또는 **힌트/베이스라인**으로 플랜 강제.
- 이때도 **텍스트 관리**를 해 Parent 수가 불필요하게 늘지 않도록 템플릿 고정.

---

## 바인드 변수 체크리스트(암기 카드)

1) **모든 DML/SELECT** — 기본은 **바인드**.
2) **날짜/숫자/문자 타입** — **일관된 타입/길이**로 매핑.
3) **함수 제거** — **컬럼에 함수 금지**, 범위식으로 전개.
4) **스큐 컬럼 히스토그램 + ACS** — 바인드 품질 보장.
5) **세션 환경 표준화** — Child 폭증 방지(NLS/optimizer_mode 등).
6) **플랜 안정화** — SPM/Baseline, 필요 시 값대 분기.
7) **보안** — 동적 SQL은 **EXECUTE IMMEDIATE … USING** 패턴(문자 결합 금지).
8) **응급용** — `CURSOR_SHARING=FORCE`는 **임시**, 결국 **앱 수정**이 정답.

---

## 미니 종합 실습: “바인드 전환 전/후” 효과 증명

1) **리터럴 모드**로 1만 회 호출(값 랜덤) → `parse count (hard)`/`mutex` 대기 관찰.
2) **바인드 모드**로 동일 호출 → 파싱 지표/대기 이벤트 비교.

```plsql
-- 12.1 리터럴 부하 생성 (주의: 테스트 환경에서만)
BEGIN
  FOR i IN 1..10000 LOOP
    EXECUTE IMMEDIATE
      'SELECT /* lit-load */ COUNT(*) FROM t_demo_bind WHERE rgn='''||
      CASE MOD(i,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END ||'''';
  END LOOP;
END;
/

-- 12.2 바인드 부하 생성 (동일 횟수)
DECLARE
  v_rgn VARCHAR2(10);
  v_cnt NUMBER;
BEGIN
  FOR i IN 1..10000 LOOP
    v_rgn := CASE MOD(i,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END;
    EXECUTE IMMEDIATE
      'SELECT /* bind-load */ COUNT(*) FROM t_demo_bind WHERE rgn=:b1'
      INTO v_cnt USING v_rgn;
  END LOOP;
END;
/

-- 12.3 전/후 지표 비교
SELECT name, value FROM v$sysstat
WHERE  name IN ('parse count (total)','parse count (hard)','parse time elapsed')
ORDER  BY name;

-- 라이브러리 캐시 관련 대기(ASH, 최근 15분)
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '15' MINUTE; EXEC :t2 := SYSTIMESTAMP;
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event IN ('library cache: mutex X','library cache: mutex S','cursor: pin S wait on X')
GROUP  BY event ORDER BY samples DESC;
```
**결과 해석**
- 바인드 모드에서 `parse count (hard)`가 **현저히 감소**, 라이브러리 캐시 관련 대기도 **급감**해야 정상.

---

## 결론

- 바인드 변수는 **성능(파싱 비용↓, 경합↓)**, **안정성(플랜/메모리)**, **보안(SQLi 방지)** 을 동시에 달성하는 **최소비용·최대효익**의 기본기다.
- *예외*: 바인드 피킹/스큐로 **값에 따라 최적 플랜이 달라지는 경우** — **히스토그램 + ACS + SPM**으로 관리하고, 필요 시 **값대 분리**로 의도를 명시하라.
- **실무 원칙**:
  1) **무조건 바인드**로 시작,
  2) **카디널리티 정확화**로 품질을 보정,
  3) **플랜 안정화**로 변동을 봉인,
  4) **지표로 증명**(AWR/ASH/XPLAN) — *감(感)*이 아닌 *수치*로.

> **요약**: *바인드 변수 = 커서 공유 = 소프트 파싱 = 시스템이 숨 쉬는 시간.*
> 바인드를 습관화하면, 병목의 8할은 시작도 전에 사라진다.
