---
layout: post
title: ì˜ìƒì²˜ë¦¬ - ì›€ì§ì„ ë²¡í„° ì¶”ì •
date: 2025-10-09 17:25:23 +0900
category: ì˜ìƒì²˜ë¦¬
---
# | **ì›€ì§ì„ ë²¡í„° ì¶”ì • (Block Matching Motion Estimation)**

## ë¸”ë¡ ë§¤ì¹­ ì›€ì§ì„ ì¶”ì • ë°©ë²•

### ì •ì˜ (ë¸”ë¡ ê¸°ë°˜ ëª¨ì…˜, ì •ìˆ˜/ì„œë¸Œí”½ì…€)

ì˜ìƒ \(I_{t-1}\) (ì´ì „ í”„ë ˆì„)ê³¼ \(I_t\) (í˜„ì¬ í”„ë ˆì„)ê°€ ìˆì„ ë•Œ, ì˜ìƒ ì¢Œí‘œ \((x,y)\) ì—ì„œ **ë¸”ë¡** \(\Omega=\{(i,j)\mid 0\le i,j<B\}\) ë¥¼ ì¡ì•„, íƒìƒ‰ ì˜ì—­ \(\mathcal{S}=\{(u,v)\mid -R\le u,v\le R\}\) ë‚´ì—ì„œ **ìœ ì‚¬ë„(ì˜¤ì°¨)** ê°€ ìµœì†Œê°€ ë˜ëŠ” **ì›€ì§ì„ ë²¡í„°** \(\mathbf{d}(x,y)=(u^\*,v^\*)\) ë¥¼ ì°¾ìŠµë‹ˆë‹¤.

- **SAD (Sum of Absolute Differences)**
  \[
  E_{\text{SAD}}(x,y; u,v) \;=\; \sum_{(i,j)\in \Omega} \left| I_t(x+i,y+j) \;-\; I_{t-1}(x+i+u, y+j+v) \right|
  \]
- **SSD (Sum of Squared Differences)**
  \[
  E_{\text{SSD}}(x,y; u,v) \;=\; \sum_{(i,j)\in \Omega} \left( I_t(x+i,y+j) \;-\; I_{t-1}(x+i+u, y+j+v) \right)^2
  \]

\[
\hat{\mathbf{d}}(x,y) \;=\; \arg\min_{(u,v)\in\mathcal{S}} E(x,y;u,v)
\]

> ì¼ë°˜ì ìœ¼ë¡œ **SAD** ê°€ ë¹ ë¥´ê³  ê°•ì¸í•©ë‹ˆë‹¤. ì¡°ëª… ì˜¤í”„ì…‹/ìŠ¤ì¼€ì¼ ë³€í™”ê°€ í¬ë©´ **ZNCC**(ì •ê·œí™” ìƒê´€)ë„ ì„ íƒì§€ì§€ë§Œ, ë³¸ ì ˆì€ **SAD/SSD** ì¤‘ì‹¬ì˜ **ì „ìˆ˜ íƒìƒ‰(Full Search)** ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

### ê²½ê³„/ì •í•© ì‹¤íŒ¨

- **ê²½ê³„**: \((x+u, y+v)\) ë¡œ ë¸”ë¡ì´ ì´ì „ í”„ë ˆì„ ê²½ê³„ë¥¼ ë²—ì–´ë‚˜ë©´ í•´ë‹¹ í›„ë³´ë¥¼ **ë¬´íš¨** ë˜ëŠ” íŒ¨ë”©(ê²½ê³„ ë³µì œ) ì²˜ë¦¬. ì—¬ê¸°ì„œëŠ” **ë¬´íš¨**ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
- **ì •í•© ì‹¤íŒ¨**: í…ìŠ¤ì²˜ê°€ ì ê±°ë‚˜ ì¡°ëª…ì´ ê¸‰ë³€í•˜ë©´ ë¹„ìš©ì´ ë‚®ì€ í›„ë³´ê°€ ì—†ì„ ìˆ˜ ìˆìŒ â†’ **ìµœì†Œ ë¹„ìš©ì´ ì„ê³„ì¹˜ ì´ìƒ**ì´ë©´ (0,0)ìœ¼ë¡œ í´ë¨í”„ í•˜ê±°ë‚˜, ë¹„ìš© ë§µì„ ì‹œê°í™”í•˜ì—¬ í›„ì²˜ë¦¬(í‰í™œí™”/ë¯¸ë””ì–¸) í•©ë‹ˆë‹¤.

### ì •ë°€í™”

ì •ìˆ˜ í™”ì†Œì—ì„œ ìµœì  \((u_0,v_0)\) ì„ ì°¾ì€ ë’¤, ê·¸ ì£¼ë³€ \((u_0\pm\frac12, v_0)\), \((u_0, v_0\pm\frac12)\), \((u_0\pm\frac12, v_0\pm\frac12)\) ë¥¼ **ì–‘ì„ í˜• ë³´ê°„**ìœ¼ë¡œ í‰ê°€í•˜ì—¬ ë” ë‚®ì€ ë¹„ìš©ì„ ì„ íƒí•©ë‹ˆë‹¤.

---

## `IppFullSearch` í´ë˜ìŠ¤ ì„¤ê³„

### API ëª©í‘œ

- ì…ë ¥: `prev`(t-1), `cur`(t) â€” `IppImage<float>` (0..1)
- íŒŒë¼ë¯¸í„°: ë¸”ë¡ í¬ê¸° B, íƒìƒ‰ ë°˜ê²½ R, ë¹„ìš©í•¨ìˆ˜(SAD/SSD), **í•˜í”„í ** on/off, **ìŠ¤í…**(í‘œì‹œ ê°„ê²©)
- ì¶œë ¥: **ëª¨ì…˜ í•„ë“œ**(ë¸”ë¡ ê·¸ë¦¬ë“œì— ëŒ€ì‘í•˜ëŠ” MV), **ë¹„ìš© ë§µ**, **ì˜¤ë²„ë ˆì´ ë“œë¡œì‰**

### ìë£Œ êµ¬ì¡°

- **ê·¸ë¦¬ë“œ**: \(\lfloor W/B \rfloor \times \lfloor H/B \rfloor\) í¬ê¸°
- `MV` : `{float dx, dy; float cost;}`
- `MVField` : `{int gridW, gridH; std::vector<MV> data;}`

---

## êµ¬í˜„ â€” `IppFullSearch.hpp / .cpp`

### í—¤ë”

```cpp
// IppFullSearch.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <algorithm>
#include <cmath>
#include "IppImage.h"
#include "IppDib.h"

enum class MVMetric { SAD, SSD };

struct MV {
    float dx=0, dy=0;  // (u,v)
    float cost=0;      // ìµœì†Œ ë¹„ìš©
};

struct MVField {
    int gridW=0, gridH=0, block=0;
    std::vector<MV> data; // size = gridW*gridH
    MV& at(int gx,int gy){ return data[gy*gridW + gx]; }
    const MV& at(int gx,int gy) const { return data[gy*gridW + gx]; }
    explicit operator bool() const { return gridW>0 && gridH>0 && (int)data.size()==gridW*gridH; }
};

struct FSParams {
    int block = 16;           // B
    int search = 8;           // R
    MVMetric metric = MVMetric::SAD;
    bool halfpel = true;      // ì„œë¸Œí”½ì…€ ì •ë°€í™”
    int stepVis = 1;          // ì‹œê°í™” ê°„ê²©(=ê·¸ë¦¬ë“œì—ì„œ ìƒ˜í”Œë§ ìŠ¤í…)
    float rejectThr = -1.0f;  // ì •í•© ê±°ë¶€ ì„ê³„(<=0 ì´ë©´ ë¯¸ì‚¬ìš©). SAD/SSD ìŠ¤ì¼€ì¼ì— ë§ì¶° ì„¤ì •.
};

class IppFullSearch {
public:
    // prev, cur : 0..1 ê·¸ë ˆì´ìŠ¤ì¼€ì¼
    MVField compute(const IppImage<float>& prev, const IppImage<float>& cur, const FSParams& p);

    // ì˜¤ë²„ë ˆì´(í™”ì‚´í‘œ) â€” frame ìœ„ì— ëª¨ì…˜ì„ ê·¸ë¦½ë‹ˆë‹¤.
    // color: (R,G,B), thickness: ì„  ë‘ê»˜, skip: ì‹œê°í™” ê°„ê²© (p.stepVisì™€ ë³„ë„ë¡œ ì¶”ê°€ downsample)
    void drawOverlay(IppDib& frame, const MVField& mv, uint8_t R=255, uint8_t G=64, uint8_t B=64,
                     int thickness=2, int skip=1, float scale=1.0f);

private:
    // ì½”ì–´ ë¹„ìš© ê³„ì‚°
    float blockCost_SAD(const IppImage<float>& A, const IppImage<float>& B,
                        int ax,int ay, int bx,int by, int Bsize);
    float blockCost_SSD(const IppImage<float>& A, const IppImage<float>& B,
                        int ax,int ay, int bx,int by, int Bsize);

    // ê²½ê³„ ì²´í¬
    static inline bool validBlock(const IppImage<float>& img, int x,int y, int B);

    // í•˜í”„í  ìƒ˜í”Œ
    static inline float sampleBilinear(const IppImage<float>& img, float x, float y);

    // í•˜í”„í  ê·¼ë°© íƒìƒ‰
    float refineHalfpel(const IppImage<float>& prev, const IppImage<float>& cur,
                        int x,int y, int u0,int v0, int B, MVMetric met, float baseCost, float& outdx, float& outdy);
};
```

### êµ¬í˜„

```cpp
// IppFullSearch.cpp
#include "IppFullSearch.hpp"
#include <cstring>
#include <limits>

inline bool IppFullSearch::validBlock(const IppImage<float>& img, int x,int y, int B){
    return x>=0 && y>=0 && x+B<=img.width() && y+B<=img.height();
}

// ì–‘ì„ í˜• ìƒ˜í”Œ (ì¢Œí‘œëŠ” í”½ì…€ ì¤‘ì‹¬ ê¸°ì¤€ ì•„ë‹˜, ë‹¨ìˆœ [0..W), [0..H) ì—°ì†)
inline float IppFullSearch::sampleBilinear(const IppImage<float>& img, float x, float y){
    // ê²½ê³„ clamp
    if (x < 0) x=0; if (y < 0) y=0;
    if (x > img.width()-1)  x = img.width()-1;
    if (y > img.height()-1) y = img.height()-1;

    int x0 = (int)std::floor(x), y0 = (int)std::floor(y);
    int x1 = std::min(x0+1, img.width()-1);
    int y1 = std::min(y0+1, img.height()-1);
    float wx = x - x0, wy = y - y0;

    float p00 = img.rowf(y0)[x0];
    float p10 = img.rowf(y0)[x1];
    float p01 = img.rowf(y1)[x0];
    float p11 = img.rowf(y1)[x1];

    return (1-wx)*((1-wy)*p00 + wy*p01) + wx*((1-wy)*p10 + wy*p11);
}

float IppFullSearch::blockCost_SAD(const IppImage<float>& A, const IppImage<float>& B,
                                   int ax,int ay, int bx,int by, int Bsize){
    float c=0.f;
    for(int j=0;j<Bsize;++j){
        const float* ra = A.rowf(ay+j)+ax;
        const float* rb = B.rowf(by+j)+bx;
        for(int i=0;i<Bsize;++i){
            c += std::fabs(ra[i]-rb[i]);
        }
    }
    return c;
}

float IppFullSearch::blockCost_SSD(const IppImage<float>& A, const IppImage<float>& B,
                                   int ax,int ay, int bx,int by, int Bsize){
    float c=0.f;
    for(int j=0;j<Bsize;++j){
        const float* ra = A.rowf(ay+j)+ax;
        const float* rb = B.rowf(by+j)+bx;
        for(int i=0;i<Bsize;++i){
            float d = ra[i]-rb[i];
            c += d*d;
        }
    }
    return c;
}

// í•˜í”„í : ì •ìˆ˜ (u0,v0) ì£¼ë³€ 8ê°œ ì§€ì (Â±0.5) + ì¤‘ì‹¬ ë³´ì • ê²€ì‚¬
float IppFullSearch::refineHalfpel(const IppImage<float>& prev, const IppImage<float>& cur,
                                   int x,int y, int u0,int v0, int B, MVMetric met,
                                   float baseCost, float& outdx, float& outdy)
{
    // í‰ê°€ í›„ë³´: (u0+du, v0+dv), du,dv âˆˆ { -0.5, 0, +0.5 } (ì¤‘ì‹¬ í¬í•¨ 9ê°œ)
    float best = baseCost;
    outdx = (float)u0; outdy = (float)v0;

    const float offs[3] = {-0.5f, 0.0f, +0.5f};
    for (float dv : offs){
        for (float du : offs){
            if (du==0 && dv==0) continue;
            // ê²½ê³„ ì²´í¬: prevì—ì„œ ì°¸ì¡°
            if (!validBlock(prev, (int)std::floor(x+u0-1), (int)std::floor(y+v0-1), B+2))
                continue; // ì†Œí­ ì—¬ìœ  ë²”ìœ„ í•„ìš”

            float c=0.f;
            if (met==MVMetric::SAD){
                for(int j=0;j<B;++j){
                    for(int i=0;i<B;++i){
                        float curv = cur.rowf(y+j)[x+i];
                        float px = (float)(x+i) + u0 + du;
                        float py = (float)(y+j) + v0 + dv;
                        float prevv = sampleBilinear(prev, px, py);
                        c += std::fabs(curv - prevv);
                    }
                }
            }else{
                for(int j=0;j<B;++j){
                    for(int i=0;i<B;++i){
                        float curv = cur.rowf(y+j)[x+i];
                        float px = (float)(x+i) + u0 + du;
                        float py = (float)(y+j) + v0 + dv;
                        float prevv = sampleBilinear(prev, px, py);
                        float d = curv - prevv;
                        c += d*d;
                    }
                }
            }
            if (c < best){
                best = c; outdx = (float)u0 + du; outdy = (float)v0 + dv;
            }
        }
    }
    return best;
}

MVField IppFullSearch::compute(const IppImage<float>& prev, const IppImage<float>& cur, const FSParams& p){
    MVField f;
    const int W = cur.width(), H = cur.height();
    if (W<=0 || H<=0 || prev.width()!=W || prev.height()!=H || p.block<=0) return f;

    const int B  = p.block;
    const int R  = p.search;
    const int GW = W / B;
    const int GH = H / B;
    f.gridW = GW; f.gridH = GH; f.block = B;
    f.data.assign(GW*GH, MV{});

    for(int gy=0; gy<GH; ++gy){
        int y = gy*B;
        for(int gx=0; gx<GW; ++gx){
            int x = gx*B;

            // í˜„ì¬ ë¸”ë¡ì€ cur(x:x+B, y:y+B)
            if (!validBlock(cur, x,y,B)) continue;

            float best = std::numeric_limits<float>::infinity();
            int bestu=0, bestv=0;

            // ì •ìˆ˜ ì „ìˆ˜ íƒìƒ‰
            for(int v=-R; v<=R; ++v){
                for(int u=-R; u<=R; ++u){
                    int bx = x + u, by = y + v;
                    if (!validBlock(prev, bx,by,B)) continue;

                    float c;
                    if (p.metric==MVMetric::SAD) c = blockCost_SAD(cur, prev, x,y, bx,by, B);
                    else                          c = blockCost_SSD(cur, prev, x,y, bx,by, B);

                    if (c < best){ best = c; bestu=u; bestv=v; }
                }
            }

            float dx=(float)bestu, dy=(float)bestv;
            float finalCost = best;

            // ì •í•© í’ˆì§ˆì´ ë‚˜ì˜ë©´ (ì˜µì…˜) ê±°ë¶€
            if (p.rejectThr>0.f && best > p.rejectThr){
                dx=0; dy=0; // ë³´ìˆ˜ì 
            }else if (p.halfpel){
                // í•˜í”„í  ì •ë°€í™”
                finalCost = refineHalfpel(prev, cur, x,y, bestu,bestv, B, p.metric, best, dx,dy);
            }

            MV mv; mv.dx=dx; mv.dy=dy; mv.cost=finalCost;
            f.at(gx,gy) = mv;
        }
    }
    return f;
}

// í”½ì…€ì— ì„  ê·¸ë¦¬ê¸°(ê°„ë‹¨ Bresenham)
static inline void putPixel(IppDib& d,int x,int y,uint8_t R,uint8_t G,uint8_t B){
    if ((unsigned)x>=(unsigned)d.width() || (unsigned)y>=(unsigned)d.height()) return;
    uint8_t* p=(uint8_t*)d.bits()+y*d.stride()+x*4;
    p[0]=B; p[1]=G; p[2]=R;
}
static void drawLine(IppDib& d, int x0,int y0,int x1,int y1,uint8_t R,uint8_t G,uint8_t B,int t){
    // thickness t: ì£¼ë³€ ì˜¤í”„ì…‹ ë°˜ë³µ
    auto drawThin=[&](int a,int b,int c,int e){
        int dx=std::abs(c-a), sx=a<c?1:-1;
        int dy=-std::abs(e-b), sy=b<e?1:-1;
        int err=dx+dy, e2;
        while(true){
            putPixel(d,a,b,R,G,B);
            if (a==c && b==e) break;
            e2=2*err;
            if (e2>=dy){ err+=dy; a+=sx; }
            if (e2<=dx){ err+=dx; b+=sy; }
        }
    };
    for(int oy=-t/2; oy<=t/2; ++oy){
        for(int ox=-t/2; ox<=t/2; ++ox){
            drawThin(x0+ox, y0+oy, x1+ox, y1+oy);
        }
    }
}
static void drawArrow(IppDib& d, int x0,int y0,int x1,int y1, uint8_t R,uint8_t G,uint8_t B,int t){
    drawLine(d, x0,y0, x1,y1, R,G,B,t);
    // ê°„ë‹¨í•œ í™”ì‚´ì´‰
    float ang = std::atan2f((float)(y1-y0),(float)(x1-x0));
    float len = 6.f;
    int ax = (int)std::lround(x1 - len*std::cos(ang-0.6f));
    int ay = (int)std::lround(y1 - len*std::sin(ang-0.6f));
    int bx = (int)std::lround(x1 - len*std::cos(ang+0.6f));
    int by = (int)std::lround(y1 - len*std::sin(ang+0.6f));
    drawLine(d, x1,y1, ax,ay, R,G,B,t);
    drawLine(d, x1,y1, bx,by, R,G,B,t);
}

void IppFullSearch::drawOverlay(IppDib& frame, const MVField& mv, uint8_t R,uint8_t G,uint8_t B,
                                int thickness, int skip, float scale)
{
    if (!mv) return;
    const int B = mv.block;
    for(int gy=0; gy<mv.gridH; gy+=std::max(1,skip)){
        for(int gx=0; gx<mv.gridW; gx+=std::max(1,skip)){
            const MV& v = mv.at(gx,gy);
            // ë¸”ë¡ ì¤‘ì‹¬
            int cx = gx*B + B/2;
            int cy = gy*B + B/2;
            int ex = (int)std::lround(cx + v.dx*scale);
            int ey = (int)std::lround(cy + v.dy*scale);
            drawArrow(frame, cx,cy, ex,ey, R,G,B, thickness);
        }
    }
}
```

---

## ë©”ë‰´ & ëŒ€í™” ìƒì â€” â€œ**ì›€ì§ì„ ë²¡í„°â€¦**â€

### ë¦¬ì†ŒìŠ¤ ID

```cpp
// resource.h (ì¶”ê°€)
#define ID_MENU_MOTION_VECTORS        16300

#define IDD_MV_DLG                    5400
#define IDC_CMB_MV_PREV               5401
#define IDC_CMB_MV_CUR                5402
#define IDC_EDIT_MV_BLOCK             5403
#define IDC_EDIT_MV_SEARCH            5404
#define IDC_CMB_MV_METRIC             5405
#define IDC_CHK_MV_HALF               5406
#define IDC_EDIT_MV_REJTHR            5407
#define IDC_EDIT_MV_VISSTEP           5408
#define IDC_EDIT_MV_SCALE             5409
#define IDC_CHK_MV_NEWWIN             5410

```

### ë©”ë‰´ / RC

```rc
// ImageTool.rc (ì¼ë¶€)
POPUP "&Analyze"
BEGIN
    MENUITEM "Motion Vectors...\tCtrl+Shift+V", ID_MENU_MOTION_VECTORS
END

IDD_MV_DLG DIALOGEX 0,0, 360, 186
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Motion Vectors (Block Matching)"
FONT 9, "Segoe UI"
BEGIN
    LTEXT "Prev:", -1,  12, 12, 28, 10
    COMBOBOX IDC_CMB_MV_PREV, 44,10, 120,72, CBS_DROPDOWNLIST|WS_VSCROLL|WS_TABSTOP
    LTEXT "Cur:", -1,   176, 12, 24, 10
    COMBOBOX IDC_CMB_MV_CUR,  202,10, 120,72, CBS_DROPDOWNLIST|WS_VSCROLL|WS_TABSTOP

    LTEXT "Block:", -1, 12, 38, 32,10
    EDITTEXT IDC_EDIT_MV_BLOCK, 48,36, 32,14, ES_NUMBER
    LTEXT "Search:", -1, 88, 38, 36,10
    EDITTEXT IDC_EDIT_MV_SEARCH, 128,36, 32,14, ES_NUMBER
    LTEXT "Metric:", -1, 176,38, 36,10
    COMBOBOX IDC_CMB_MV_METRIC, 216,36, 60,70, CBS_DROPDOWNLIST|WS_VSCROLL|WS_TABSTOP
    AUTOCHECKBOX "Half-pel", IDC_CHK_MV_HALF, 282, 38, 60,10

    LTEXT "RejectThr:", -1, 12, 58, 50,10
    EDITTEXT IDC_EDIT_MV_REJTHR, 66,56, 50,14, ES_AUTOHSCROLL
    LTEXT "VisStep:", -1, 128,58, 40,10
    EDITTEXT IDC_EDIT_MV_VISSTEP, 172,56, 28,14, ES_NUMBER
    LTEXT "Scale:", -1, 208,58, 32,10
    EDITTEXT IDC_EDIT_MV_SCALE, 244,56, 32,14, ES_AUTOHSCROLL

    AUTOCHECKBOX "Open overlay in new window", IDC_CHK_MV_NEWWIN, 12, 78, 150,12

    DEFPUSHBUTTON "Run", IDOK,  222, 154, 48,16
    PUSHBUTTON    "Cancel", IDCANCEL, 276,154, 48,16
END
```

### ëŒ€í™” ìƒì ì½”ë“œ

```cpp
// MotionVectorDlg.h
#pragma once
#include <vector>
#include <string>
#include "resource.h"
#include "IppDib.h"
#include "IppImage.h"
#include "IppFullSearch.hpp"

// ê¸°ì¡´ ìœ í‹¸ (ì•ì ˆì—ì„œ ì‚¬ìš©)
// ì—´ë ¤ìˆëŠ” ë¬¸ì„œ(ìœˆë„ìš°) ëª©ë¡
struct DocRef { HWND hwnd; IppDib* dib; std::wstring title; };
std::vector<DocRef> GetOpenDocs();
HWND CreateDocWindowFromDib(const IppDib& dib, const std::wstring& title);
bool DibToGray01(const IppDib& src, IppImage<float>& g); // BGRA32 â†’ Gray[0,1]

class MotionVectorDlg {
public:
    MotionVectorDlg(HWND owner) : owner_(owner) {}
    INT_PTR DoModal();
private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM);
    void Run(HWND h);

private:
    HWND owner_{};
    std::vector<DocRef> docs_;
};
```

```cpp
// MotionVectorDlg.cpp
#include "MotionVectorDlg.h"
#include <cwchar>

INT_PTR MotionVectorDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_MV_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK MotionVectorDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        return ((MotionVectorDlg*)l)->OnInit(h); }
    auto* self=(MotionVectorDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w);
    return FALSE;
}
INT_PTR MotionVectorDlg::OnInit(HWND h){
    docs_ = GetOpenDocs();
    HWND c1=GetDlgItem(h, IDC_CMB_MV_PREV);
    HWND c2=GetDlgItem(h, IDC_CMB_MV_CUR);

    int isel=0, jsel= (docs_.size()>1? 1:0);
    for(size_t i=0;i<docs_.size();++i){
        SendMessageW(c1, CB_ADDSTRING, 0, (LPARAM)docs_[i].title.c_str());
        SendMessageW(c2, CB_ADDSTRING, 0, (LPARAM)docs_[i].title.c_str());
    }
    SendMessageW(c1, CB_SETCURSEL, isel, 0);
    SendMessageW(c2, CB_SETCURSEL, jsel, 0);

    HWND m=GetDlgItem(h, IDC_CMB_MV_METRIC);
    SendMessageW(m, CB_ADDSTRING, 0, (LPARAM)L"SAD");
    SendMessageW(m, CB_ADDSTRING, 0, (LPARAM)L"SSD");
    SendMessageW(m, CB_SETCURSEL, 0, 0);

    SetDlgItemInt(h, IDC_EDIT_MV_BLOCK, 16, FALSE);
    SetDlgItemInt(h, IDC_EDIT_MV_SEARCH, 8, FALSE);
    CheckDlgButton(h, IDC_CHK_MV_HALF, BST_CHECKED);
    SetDlgItemTextW(h, IDC_EDIT_MV_REJTHR, L"-1"); // ë¯¸ì‚¬ìš©
    SetDlgItemInt(h, IDC_EDIT_MV_VISSTEP, 1, FALSE);
    SetDlgItemTextW(h, IDC_EDIT_MV_SCALE, L"1.0");
    CheckDlgButton(h, IDC_CHK_MV_NEWWIN, BST_CHECKED);
    return TRUE;
}
INT_PTR MotionVectorDlg::OnCommand(HWND h, WPARAM w){
    switch(LOWORD(w)){
    case IDOK:    Run(h); EndDialog(h, IDOK); return TRUE;
    case IDCANCEL: EndDialog(h, IDCANCEL);    return TRUE;
    }
    return FALSE;
}

void MotionVectorDlg::Run(HWND h){
    int ip=(int)SendDlgItemMessageW(h, IDC_CMB_MV_PREV, CB_GETCURSEL, 0, 0);
    int ic=(int)SendDlgItemMessageW(h, IDC_CMB_MV_CUR,  CB_GETCURSEL, 0, 0);
    if (ip<0||ic<0||ip>=(int)docs_.size()||ic>=(int)docs_.size()){
        MessageBoxW(h, L"ë¬¸ì„œ ì„ íƒì„ í™•ì¸í•˜ì„¸ìš”.", L"Motion Vectors", MB_ICONWARNING); return;
    }
    IppDib* pPrev=docs_[ip].dib;
    IppDib* pCur =docs_[ic].dib;
    if (!pPrev || !*pPrev || !pCur || !*pCur){
        MessageBoxW(h, L"ì˜ìƒì´ ë¹„ì—ˆìŠµë‹ˆë‹¤.", L"Motion Vectors", MB_ICONERROR); return;
    }
    if (pPrev->width()!=pCur->width() || pPrev->height()!=pCur->height()){
        MessageBoxW(h, L"ì´ì „/í˜„ì¬ ì˜ìƒì˜ í¬ê¸°ê°€ ë‹¤ë¦…ë‹ˆë‹¤.", L"Motion Vectors", MB_ICONERROR); return;
    }

    BOOL ok=FALSE;
    int B=GetDlgItemInt(h, IDC_EDIT_MV_BLOCK, &ok, FALSE); if (!ok||B<4) B=16;
    int R=GetDlgItemInt(h, IDC_EDIT_MV_SEARCH, &ok, FALSE); if (!ok||R<1) R=8;
    int msel=(int)SendDlgItemMessageW(h, IDC_CMB_MV_METRIC, CB_GETCURSEL, 0, 0);
    MVMetric met = (msel==1? MVMetric::SSD : MVMetric::SAD);
    bool half = (IsDlgButtonChecked(h, IDC_CHK_MV_HALF)==BST_CHECKED);

    wchar_t tb[64]; GetDlgItemTextW(h, IDC_EDIT_MV_REJTHR, tb, 64);
    float rej = (float)_wtof(tb);
    int vis=GetDlgItemInt(h, IDC_EDIT_MV_VISSTEP, &ok, FALSE); if (!ok||vis<1) vis=1;
    wchar_t ts[64]; GetDlgItemTextW(h, IDC_EDIT_MV_SCALE, ts, 64);
    float sc = (float)_wtof(ts); if (sc<=0) sc=1.f;
    bool newwin=(IsDlgButtonChecked(h, IDC_CHK_MV_NEWWIN)==BST_CHECKED);

    // ê·¸ë ˆì´ ë³€í™˜
    IppImage<float> gPrev,gCur;
    if (!DibToGray01(*pPrev, gPrev) || !DibToGray01(*pCur, gCur)){
        MessageBoxW(h, L"ê·¸ë ˆì´ ë³€í™˜ ì‹¤íŒ¨", L"Motion Vectors", MB_ICONERROR); return;
    }

    FSParams param; param.block=B; param.search=R; param.metric=met; param.halfpel=half;
    param.rejectThr=rej; param.stepVis=vis;

    IppFullSearch fs;
    MVField mv = fs.compute(gPrev, gCur, param);
    if (!mv){ MessageBoxW(h, L"ê³„ì‚° ì‹¤íŒ¨", L"Motion Vectors", MB_ICONERROR); return; }

    // ì˜¤ë²„ë ˆì´
    IppDib overlay = *pCur;
    fs.drawOverlay(overlay, mv, 255,64,64, 2, param.stepVis, sc);

    if (newwin) CreateDocWindowFromDib(overlay, L"Motion Vectors");
    else { *pCur = overlay; InvalidateRect(docs_[ic].hwnd, nullptr, FALSE); }
}
```

### ë©”ë‰´ í•¸ë“¤ëŸ¬

```cpp
// main_multiwin.cpp (ë°œì·Œ)
#include "MotionVectorDlg.h"

case ID_MENU_MOTION_VECTORS:
{
    MotionVectorDlg dlg(hWnd);
    dlg.DoModal();
}
return 0;
```

---

## ì˜ˆì œ & ìƒí™©

### **ìˆœìˆ˜ í‰í–‰ ì´ë™(í•©ì„± ë°ì´í„°)**

- **ìƒí™©**: `prev` ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ **+4**, ì•„ë˜ë¡œ **+2**ë§Œí¼ ì‹œí”„íŠ¸í•œ `cur` ë¥¼ ìƒì„±.
- **ì„¤ì •**: `B=16, R=8, Metric=SAD, Half-pel=Off`
- **ê²°ê³¼**: ëŒ€ë¶€ë¶„ì˜ ê·¸ë¦¬ë“œì—ì„œ \((+4, +2)\) ê²€ì¶œ. ê²½ê³„ ê·¼ì²˜ëŠ” íƒìƒ‰ í›„ë³´ ë¶€ì¡±ìœ¼ë¡œ (0,0) ë˜ëŠ” ê·¼ì‚¬ì¹˜.

```cpp
// synth_shift_test.cpp (ìš”ì§€)
IppDib prev=MakeChecker(320,240);     // ì„ì˜ íŒ¨í„´
IppDib cur =ShiftImage(prev, +4,+2);  // ì •ìˆ˜ ì´ë™
// ...
// ëŒ€í™”ìƒìì—ì„œ prev=prev, cur=cur ì„ íƒ í›„ Run
```

### **ë³´í–‰ ì˜ìƒ (ì‹¤ì‚¬)**

- **ìƒí™©**: ë³´í–‰ì ì˜ìƒì˜ ì—°ì† ë‘ í”„ë ˆì„.
- **ì„¤ì •**: `B=16, R=8, Metric=SAD, Half-pel=On, VisStep=2, Scale=2.0`
- **ê²°ê³¼**: ë‹¤ë¦¬/íŒ” ì£¼ë³€ì—ì„œ í° ë²¡í„°, ì •ì  ë°°ê²½ì€ (0,0)ì— ê°€ê¹Œì›€. í•˜í”„í ë¡œ ë¯¸ì„¸ ì´ë™ì´ ë¶€ë“œëŸ½ê²Œ í‘œí˜„.

### **ì¡°ëª… ë³€í™” / ì§ˆê° ë¶€ì¡±**

- **ìƒí™©**: ì‹¤ë‚´ì—ì„œ ì¡°ëª…ì´ ê¹œë¹¡ì—¬ ì „ì²´ ë°ê¸° ë³€í™”.
- **ëŒ€ì‘**: `SSD` ë³´ë‹¤ `SAD` ì„ í˜¸. `rejectThr` ë¥¼ ì ë‹¹íˆ ë†’ì—¬ ì• ë§¤í•œ ë¸”ë¡ì€ (0,0) ìœ¼ë¡œ ê±°ë¶€.

---

## ì„±ëŠ¥ & í’ˆì§ˆ íŒ

- **B / R ì„ íƒ**: í° BëŠ” ì•ˆì •(ë…¸ì´ì¦ˆ í‰ê· í™”) vs. ì„¸ë¶€ ì›€ì§ì„ ì†Œì‹¤. Rì€ ì¶©ë¶„í•´ì•¼ í•˜ì§€ë§Œ \((2R+1)^2\) ë¡œ ë¹„ìš© ì¦ê°€.
- **Early Break**: SAD/SSD ëˆ„ì ì´ **í˜„ì¬ best** ë¥¼ ì´ˆê³¼í•˜ë©´ ë‚´ë¶€ ë£¨í”„ ì¤‘ë‹¨(ë¯¸ì„¸ ìµœì í™” ê°€ëŠ¥).
- **í”¼ë¼ë¯¸ë“œ(ë©€í‹°ìŠ¤ì¼€ì¼)**: Frameì„ ë‹¤ìš´ìƒ˜í”Œë§í•´ coarse-to-fine ê²€ìƒ‰ â†’ Rì„ ì¤„ì´ë˜ ì „ì—­ ì´ë™ì— ê°•ì¸.
- **í›„ì²˜ë¦¬**: MV í•„ë“œë¥¼ 3Ã—3 **ë¯¸ë””ì–¸** ìœ¼ë¡œ í•œ ë²ˆ ì •ë¦¬ â†’ ì™¸ë€ ì œê±°.
- **í•˜í”„í  ì£¼ì˜**: ê²½ê³„ì—ì„œ ë³´ê°„ ìƒ˜í”Œì´ ë¶€ì¡±í•˜ì§€ ì•Šê²Œ **ì¡°ê¸ˆ ë„‰ë„‰í•œ ìœ íš¨ì„± ê²€ì‚¬**(ìœ„ ì½”ë“œì—ì„œ +2 ì—¬ìœ ) í•„ìš”.

---

## ìˆ˜í•™ ë³´ì¶©

- **SAD / SSD ë‹¨ìœ„**
  \[
  \text{SAD} \in [0, B^2],\qquad \text{SSD} \in [0, B^2]
  \]
  (ì…ë ¥ì€ \([0,1]\) ì •ê·œí™” ê°’ì´ë¯€ë¡œ ìµœëŒ€ ì°¨ì´ëŠ” 1)
  `rejectThr` ëŠ” ì˜ˆ: \(B=16\) â‡’ \(B^2=256\). ì •í•©ì´ ë‚˜ìœ ë¸”ë¡ë§Œ ê±°ë¶€í•˜ë ¤ë©´ `SAD > 50~80` ìˆ˜ì¤€ë¶€í„° ì‹œë„.

- **í•˜í”„í  í›„ë³´**: 8ë°©í–¥ + ì¤‘ì‹¬ 1ê°œ = 9ê°œ. ë” ê³ ê¸‰ìœ¼ë¡œëŠ” 2ì°¨ ê³¡ë©´ ê·¼ì‚¬(íŒ¨ëŸ¬ë³¼ë¼ ë³´ê°„)ë„ ê°€ëŠ¥.

---

## ìš”ì•½

- ë¸”ë¡ ë§¤ì¹­ ëª¨ì…˜ ì¶”ì •ì˜ í•µì‹¬ì€ **ë¹„ìš©í•¨ìˆ˜**(SAD/SSD)ì™€ **íƒìƒ‰ ì „ëµ**ì…ë‹ˆë‹¤.
- ë³¸ ì ˆì˜ **`IppFullSearch`** ëŠ”
  - ì •ìˆ˜ ì „ìˆ˜ íƒìƒ‰ + (ì˜µì…˜) **í•˜í”„í  ì •ë°€í™”**
  - **ê±°ë¶€ ì„ê³„ì¹˜**, **ì˜¤ë²„ë ˆì´ ì‹œê°í™”(í™”ì‚´í‘œ)**
  - ê°„ë‹¨í•œ **ë©”ë‰´/ëŒ€í™” ìƒì** ë¡œ ë°”ë¡œ ì‹¤ìŠµ ê°€ëŠ¥í•œ í˜•íƒœ
- ì´ ëª¨ë“ˆì€ ì¶”í›„ **í”¼ë¼ë¯¸ë“œ ê²€ìƒ‰**, **ZNCC/ë¹„íŠ¸ì½”ìŠ¤íŠ¸** ë“±ìœ¼ë¡œ í™•ì¥í•´ë„ ì¸í„°í˜ì´ìŠ¤ê°€ ìœ ì§€ë©ë‹ˆë‹¤.
- ë‹¤ìŒ ë‹¨ê³„: **AviView**ì—ì„œ í”„ë ˆì„ \(t{-}1\) â†” \(t\) ìë™ ê³µê¸‰(ì¬ìƒ ë„ì¤‘ â€œí˜„ì¬â†”ì´ì „â€ ëª¨ì…˜ í•„ë“œ ê°±ì‹ )ìœ¼ë¡œ **ì‹¤ì‹œê°„ MV ë³´ê¸°**ë¥¼ êµ¬í˜„í•´ë³´ì„¸ìš”. ğŸš€
