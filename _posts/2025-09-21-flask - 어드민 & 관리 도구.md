---
layout: post
title: flask - 어드민 & 관리 도구
date: 2025-09-21 16:25:23 +0900
category: flask
---
# 14. 어드민 & 관리 도구

> 이 장은 **Flask-Admin / Flask-AppBuilder 비교**, **RBAC(역할 기반 접근 제어)**, **감사 로그(audit log)**, **운영 툴킷(임퍼소네이션, 벌크 액션, 엑스포트, 플래그 토글, 점검 모드 등)** 를 실전 관점에서 정리한다.  
> 모든 코드는 ``` 로 감싸며, 수식이 필요하면 반드시 $$...$$ 로 표기한다(본 장은 수식이 거의 없음).

---

## 14.1 개요 — “어드민”의 역할과 요구사항

- **운영/지원**: 사용자 계정/결제/주문 상태 변경, 환불/정정 처리
- **관측/드릴다운**: KPI, 오류/이상 징후 포착 후 레코드 조회
- **통제**: 기능 토글(Feature Flag), 차단/제재, 공지/배너
- **준법/추적**: **감사 로그**, 접근권한 최소화, 데이터 마스킹
- **안전**: CSRF/XSS/권한 상승 보호, 임퍼소네이션 기록, 승인 워크플로

> **원칙**: “**빠르게 만들되, 위험은 통제**”. 프레임워크가 제공하는 **CRUD 자동화**를 적극 활용하고, **권한/감사/승인**은 반드시 붙인다.

---

## 14.2 Flask-Admin vs Flask-AppBuilder (FAB) 비교

| 항목 | Flask-Admin | Flask-AppBuilder(FAB) |
|---|---|---|
| 철학 | “가벼운 CRUD 스캐폴딩” – **ModelView** 위젯화 | “배터리 포함” – **보안/권한/메뉴/차트** 통합 |
| 보안 | 내장 X → **Flask-Login/Flask-Security-Too** 등 직접 연동 | **내장 RBAC/권한 매트릭스**(PermissionView, Role) |
| 설정 난이도 | 낮음(시작 쉬움), 커스텀은 코드 작성 | 초기가 약간 무겁지만 **표준화** 쉬움 |
| 데이터소스 | SQLAlchemy 중심, 파일/몽고 등 플러그인 | SQLA 중심(권장), REST API 자동화 가능 |
| 뷰 확장 | `ModelView`/`BaseView` 오버라이드 | `ModelView` 유사 + **Chart, Master-Detail** 제공 |
| 생태계 | 넓음(예제 풍부), 자유도 높음 | Airflow/ Superset 출신과 유사 패턴, 기업 관리용 적합 |
| 추천 용도 | **작고 민첩한 팀**, 빠른 CRUD, 섬세한 커스터마이징 | **조직형 어드민**, 권한 매트릭스/정책 표준화 필요 |

> **의사결정 가이드**  
> - “빠르게 CRUD + 우리 보안 그대로” → **Flask-Admin**  
> - “역할/권한 표준, 승인/메뉴/차트까지” → **FAB**

---

## 14.3 공통 스캐폴딩

```
app/
├─ __init__.py                 # create_app
├─ extensions.py               # db, login, security, cache...
├─ models/                     # User, Role, Domain models...
├─ admin/                      # Admin (Flask-Admin or FAB)
│  ├─ fa/                      # Flask-Admin 구현
│  └─ fab/                     # FAB 구현
├─ security/                   # RBAC, decorators
├─ audit/                      # audit model & hooks
└─ blueprints/                 # site/api
```

```python
# app/extensions.py
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager
db = SQLAlchemy()
login = LoginManager()
def init_extensions(app):
    db.init_app(app)
    login.init_app(app)
    login.login_view = "auth.login"
```

---

## 14.4 Flask-Admin: 시작하기 & ModelView 커스터마이징

### 14.4.1 설치 & 부트스트랩

```bash
pip install flask-admin
```

```python
# app/admin/fa/__init__.py
from flask_admin import Admin
from flask_admin.contrib.sqla import ModelView
from flask import redirect, url_for, request
from flask_login import current_user

admin = Admin(name="Backoffice", template_mode="bootstrap4")

class SecureModelView(ModelView):
    def is_accessible(self):
        return current_user.is_authenticated and current_user.has_role("admin")
    def inaccessible_callback(self, name, **kwargs):
        return redirect(url_for("auth.login", next=request.url))

def init_admin(app, db, models):
    admin.init_app(app)
    # 예: 사용자/주문 모델 추가
    admin.add_view(SecureModelView(models.User, db.session, category="Accounts"))
    admin.add_view(SecureModelView(models.Order, db.session, category="Orders"))
```

앱에 장착:

```python
# app/__init__.py
from .extensions import init_extensions, db
from .admin.fa import init_admin
from . import models
def create_app():
    app = Flask(__name__)
    app.config.from_object("config.Prod")
    init_extensions(app)
    with app.app_context():
        init_admin(app, db, models)
    return app
```

### 14.4.2 ModelView 주요 옵션

```python
class OrderAdmin(SecureModelView):
    can_view_details = True
    can_export = True
    export_types = ["csv", "xlsx"]
    column_searchable_list = ("id", "user.email", "status")
    column_filters = ("status", "created_at")
    column_default_sort = ("created_at", True)  # desc
    column_exclude_list = ("internal_note",)
    form_excluded_columns = ("created_at", "updated_at")
    form_choices = {"status": [("pending","Pending"),("paid","Paid"),("canceled","Canceled")]}
    page_size = 50

    # 레코드 별 액션 버튼
    def _refund_formatter(view, context, model, name):
        if model.status == "paid":
            return f'<a class="btn btn-sm btn-danger" href="/admin/orders/{model.id}/refund">Refund</a>'
        return ""
    column_formatters = {"refund": _refund_formatter}
    column_list = ("id","user","total","status","created_at","refund")

    # CSRF는 Flask-WTF 연계 권장(전역)
```

**벌크 액션**:

```python
from flask_admin.actions import action

class OrderAdmin(SecureModelView):
    @action("mark_paid", "Mark Paid", "선택 레코드를 Paid 처리?")
    def action_mark_paid(self, ids):
        q = self.session.query(self.model).filter(self.model.id.in_(ids))
        count = 0
        for o in q.all():
            if o.status == "pending":
                o.status = "paid"; count += 1
        self.session.commit()
        self.flash(f"{count} rows updated.", "success")
```

### 14.4.3 관계형 편집(Inline Model)

```python
from flask_admin.model.form import InlineFormAdmin

class OrderItemInline(InlineFormAdmin):
    form_columns = ("product", "quantity", "price")

class OrderAdmin(SecureModelView):
    inline_models = (OrderItemInline(OrderItem),)
```

### 14.4.4 파일 업로드 필드(안전 설정)

```python
from flask_admin.form import FileUploadField
from wtforms import Form

class ProductForm(Form):
    image = FileUploadField("Image")

class ProductAdmin(SecureModelView):
    form = ProductForm
    # 실제 저장 훅 오버라이드
    def on_model_change(self, form, model, is_created):
        f = form.image.data
        if f:
            # 화이트리스트/MIME 스니핑/바이러스 검사 후 저장(13장 참고)
            path = save_safe_image(f)
            model.image_path = path
```

> **중요**: 어드민 업로드도 “사용자 업로드”와 동일한 **보안 검증 파이프라인**을 태운다.

---

## 14.5 Flask-AppBuilder(FAB): 내장 RBAC와 통합 어드민

### 14.5.1 설치 & 초기화

```bash
pip install flask-appbuilder
```

FAB는 자체 App 팩토리와 보안 모델을 제공한다.

```python
# app/admin/fab/app.py
from flask_appbuilder import AppBuilder, SQLA
from flask import Flask

db = SQLA()
appbuilder = AppBuilder()

def create_fab_app():
    app = Flask(__name__)
    app.config.from_object("config.FAB")
    db.init_app(app)
    appbuilder.init_app(app, db.session)
    return app
```

### 14.5.2 ModelView 등록

```python
# app/admin/fab/views.py
from flask_appbuilder import ModelView
from .app import appbuilder, db
from app.models import User, Order, OrderItem

class OrderModelView(ModelView):
    datamodel = SQLAInterface(Order)
    list_columns = ["id","user","total","status","created_at"]
    show_fieldsets = [
        ("Summary", {"fields":["id","user","status","total","created_at"]}),
        ("Items", {"fields":["items"]})
    ]
    add_columns = ["user","status","total"]
    edit_columns = ["status"]
    base_order = ("created_at","desc")
    base_filters = [["status", FilterEqual, "paid"]]  # 기본 필터

appbuilder.add_view(
    OrderModelView, "Orders", icon="fa-shopping-cart", category="Sales"
)
```

### 14.5.3 내장 보안 모델 & 권한

- FAB는 **Permission(View)** × **Role** 매핑을 제공  
- 각 View는 자동으로 `can_list`, `can_show`, `can_add`, `can_edit`, `can_delete` 권한이 생김
- UI로 **역할에 권한을 부여**할 수 있어, 보안 정책의 코드 의존도를 낮춤

> **장점**: **권한 매트릭스**를 **비개발자(운영자)** 도 관리 가능.  
> **주의**: 반드시 **감사 로그**와 **변경 승인**(민감 액션) 패턴을 곁들일 것.

---

## 14.6 RBAC(역할 기반 접근 제어) 설계

### 14.6.1 최소 모델

```python
# app/models/auth.py
from app.extensions import db
roles_users = db.Table("roles_users",
    db.Column("user_id", db.Integer, db.ForeignKey("users.id")),
    db.Column("role_id", db.Integer, db.ForeignKey("roles.id"))
)

class Role(db.Model):
    __tablename__="roles"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True)
    permissions = db.relationship("Permission", secondary="roles_permissions", backref="roles")

class Permission(db.Model):
    __tablename__="permissions"
    id = db.Column(db.Integer, primary_key=True)
    code = db.Column(db.String(100), unique=True)  # ex) "order.refund"

roles_permissions = db.Table("roles_permissions",
    db.Column("role_id", db.Integer, db.ForeignKey("roles.id")),
    db.Column("permission_id", db.Integer, db.ForeignKey("permissions.id"))
)

class User(db.Model):
    __tablename__="users"
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, index=True)
    roles = db.relationship(Role, secondary=roles_users, backref="users")

    def has_role(self, name): return any(r.name == name for r in self.roles)
    def can(self, code): return any(code in {p.code for p in r.permissions} for r in self.roles)
```

### 14.6.2 권한 데코레이터

```python
# app/security/perm.py
from functools import wraps
from flask import abort
from flask_login import current_user, login_required

def require_perm(code: str):
    def deco(fn):
        @wraps(fn)
        @login_required
        def _(*a, **kw):
            if not current_user.can(code):
                abort(403)
            return fn(*a, **kw)
        return _
    return deco
```

사용:

```python
@orders_bp.post("/<int:id>/refund")
@require_perm("order.refund")
def refund(id):
    ...
```

### 14.6.3 민감 액션: 재인증/이중승인

- **fresh login**(8장) 요구: 비밀번호 다시 입력
- **이중 승인**: 요청자 ≠ 승인자, 또는 **두 명의 관리자** 서명

```python
# 간단 승인 모델
class Approval(db.Model):
    __tablename__="approvals"
    id = db.Column(db.Integer, primary_key=True)
    subject_type = db.Column(db.String(50))
    subject_id = db.Column(db.Integer)
    action = db.Column(db.String(50))
    requested_by = db.Column(db.Integer, index=True)
    approved_by = db.Column(db.Integer, nullable=True)
    status = db.Column(db.String(20), default="pending")
```

---

## 14.7 감사 로그(Audit Log) — 누가, 무엇을, 언제, 왜

### 14.7.1 모델 & 스키마

```python
# app/audit/models.py
from app.extensions import db
from datetime import datetime, timezone

class AuditLog(db.Model):
    __tablename__="audit_logs"
    id = db.Column(db.Integer, primary_key=True)
    actor_id = db.Column(db.Integer, index=True)
    ip = db.Column(db.String(45))
    ua = db.Column(db.String(200))
    action = db.Column(db.String(100))       # ex) 'order.refund'
    entity = db.Column(db.String(50))        # 'Order'
    entity_id = db.Column(db.Integer)
    before = db.Column(db.JSON)
    after = db.Column(db.JSON)
    reason = db.Column(db.String(200))
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
```

### 14.7.2 SQLAlchemy 이벤트로 변경 감지

```python
# app/audit/hooks.py
from sqlalchemy import event, inspect
from flask import g, request
from app.audit.models import AuditLog
from app.extensions import db

def _asdict(obj):
    mapper = inspect(obj).mapper
    return {col.key: getattr(obj, col.key) for col in mapper.columns}

@event.listens_for(db.session, "before_flush")
def capture_changes(session, flush_context, instances):
    if request:  # 어드민 요청(백그라운드 작업은 별도 정책)
        actor_id = getattr(getattr(g, "current_user", None) or getattr(request, "user", None), "id", None)
        ip = request.headers.get("X-Forwarded-For", request.remote_addr)
        ua = request.headers.get("User-Agent")
    else:
        actor_id = None; ip=None; ua=None

    for obj in session.new:
        session.add(AuditLog(actor_id=actor_id, ip=ip, ua=ua, action="create",
                             entity=obj.__class__.__name__, entity_id=getattr(obj,"id",None),
                             before=None, after=_asdict(obj)))
    for obj in session.dirty:
        state = inspect(obj)
        if not state.has_changes(): continue
        before = {a.key: state.attrs[a.key].history.deleted[0] for a in state.mapper.column_attrs if state.attrs[a.key].history.deleted}
        after  = {a.key: getattr(obj, a.key) for a in state.mapper.column_attrs if state.attrs[a.key].history.added}
        session.add(AuditLog(actor_id=actor_id, ip=ip, ua=ua, action="update",
                             entity=obj.__class__.__name__, entity_id=getattr(obj,"id",None),
                             before=before, after=after))
    for obj in session.deleted:
        session.add(AuditLog(actor_id=actor_id, ip=ip, ua=ua, action="delete",
                             entity=obj.__class__.__name__, entity_id=getattr(obj,"id",None),
                             before=_asdict(obj), after=None))
```

> **주의**: 대량 업데이트/하위 엔티티 변경은 로그 폭증 가능 → **민감 모델만 화이트리스트** 또는 **필드 필터**.

### 14.7.3 어드민에서 감사 로그 보기(Flask-Admin)

```python
class AuditAdmin(SecureModelView):
    can_create = False; can_edit = False; can_delete = False
    column_list = ("created_at","actor_id","action","entity","entity_id")
    column_filters = ("action","entity","actor_id","created_at")
    column_searchable_list = ("entity","entity_id")

admin.add_view(AuditAdmin(AuditLog, db.session, category="Security"))
```

---

## 14.8 운영 툴킷 — 현업에서 바로 쓰는 기능 모음

### 14.8.1 임퍼소네이션(사용자 대리 로그인)

- UI에서 “사용자처럼 보기” 버튼 → **임시 세션 생성**, 상단 배너에 **Impersonating User #id** 표시
- **감사 로그**에 원 관리자/대상 사용자 기록

```python
# app/admin/impersonate.py
from flask_login import login_user
from app.audit.models import AuditLog
from app.models import User
from app.extensions import db
from flask import redirect, url_for, flash

@admin_bp.post("/impersonate/<int:user_id>")
@require_perm("user.impersonate")
def impersonate(user_id):
    target = User.query.get_or_404(user_id)
    login_user(target, remember=False, fresh=False)
    db.session.add(AuditLog(actor_id=current_user.id, action="impersonate",
                            entity="User", entity_id=user_id, before=None, after=None))
    db.session.commit()
    flash(f"Impersonating {target.email}", "warning")
    return redirect(url_for("site.home"))
```

배너:

```jinja
{% if current_user and session.get("impersonating") %}
<div class="alert alert-warning">Impersonating {{ current_user.email }} —
  <a href="{{ url_for('admin.stop_impersonate') }}">Stop</a>
</div>
{% endif %}
```

### 14.8.2 데이터 고치기(데이터 픽스 스크립트)

- “**데이터 정정**”는 **작업 큐 + 승인**으로.  
- 어드민에서 파라미터 입력 → Celery 태스크 제출 → 결과/감사 기록

```python
@admin_bp.post("/fix/emails-normalize")
@require_perm("ops.fix")
def fix_emails():
    job = normalize_emails.delay()  # 이메일을 소문자/trim
    return {"task_id": job.id}, 202
```

### 14.8.3 엑스포트/리포트(스트리밍 CSV)

```python
from flask import Response
import csv, io

@admin_bp.get("/export/orders.csv")
@require_perm("report.export")
def export_orders():
    def generate():
        yield "id,user,total,status,created_at\n"
        for r in db.session.execute("SELECT id,user_id,total,status,created_at FROM orders ORDER BY id DESC"):
            yield f"{r.id},{r.user_id},{r.total},{r.status},{r.created_at.isoformat()}\n"
    return Response(generate(), mimetype="text/csv",
                    headers={"Content-Disposition": "attachment; filename=orders.csv"})
```

### 14.8.4 Feature Flag 토글러

```python
# app/models/flag.py
class FeatureFlag(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True)
    enabled = db.Column(db.Boolean, default=False)

def is_enabled(name: str) -> bool:
    f = FeatureFlag.query.filter_by(name=name).one_or_none()
    return bool(f and f.enabled)
```

어드민에서 `FeatureFlag` ModelView 추가 → 런타임 조건 분기:

```python
if is_enabled("new_checkout"):
    return render_template("checkout_v2.html")
return render_template("checkout_v1.html")
```

### 14.8.5 점검 모드/배너

```python
# app/ops/banner.py
from flask import g

MAINTENANCE = {"enabled": False, "message": ""}

@app.before_request
def banner():
    g.maintenance = MAINTENANCE

# 템플릿에서
{% if g.maintenance.enabled %}
<div class="alert alert-info">{{ g.maintenance.message }}</div>
{% endif %}
```

어드민에서 메시지 수정 UI 제공(권한 보호).

### 14.8.6 위험 액션 “드라이런(dry-run)”

- 환불/삭제 같은 위험 액션은 **dry-run** 버튼 제공 → 영향 레코드/금액 미리보기
- 실제 실행에는 **확인 모달 + 승인자 지정 + 감사 로그** 필수

---

## 14.9 보안 강화 포인트(어드민 특화)

- **이중 인증(MFA)**: 관리자/스태프 필수  
- **IP 제한**(사내 VPN) 또는 **Just-In-Time 접근**(임시 권한 발급)  
- **CSRF 보호**: Flask-WTF CSRF 전역 적용  
- **오버포스팅 방지**: `form_excluded_columns` 엄격히, 서버에서 허용 필드만 매핑  
- **민감 필드 마스킹**: PII/토큰은 list에서 숨기고 details에서 제한  
- **로그아웃/세션 제한**: Idle/Absolute 타임아웃(8장)  
- **SQL 주입 방지**: Admin 커스텀 쿼리 시 바인딩 사용  
- **파일 업로드 보안**: 화이트리스트/MIME 스니핑/바이러스 스캔(13장)  
- **감사 로그**: **모든 어드민 변경/로그인/임퍼소네이션** 기록

---

## 14.10 성능/운영

- **대량 그리드**: 서버 페이징/인덱스, `column_default_sort` 최적화  
- **슬로우 쿼리**: 관리자 화면에서 필터 조합이 복잡 → **쿼리 로그/인덱스 추가**  
- **읽기 전용 복제본**: 레포트/리스트는 리드 레플리카에서(쓰기 분리)  
- **캐싱**: 자주 쓰는 필터 결과 캐시(10장)  
- **권한/메뉴 캐시**: FAB 권한 매트릭스 캐시로 응답성 개선

---

## 14.11 테스트

### 14.11.1 접근 제어 테스트

```python
def test_admin_requires_login(client):
    r = client.get("/admin/")  # Flask-Admin index
    assert r.status_code in (302, 401)

def test_role_can_access(admin_client):
    r = admin_client.get("/admin/order/")
    assert r.status_code == 200
```

### 14.11.2 감사 로그 단언

```python
def test_audit_on_update(admin_client, db_session, order):
    r = admin_client.post(f"/admin/order/edit/?id={order.id}",
                          data={"status":"paid"}, follow_redirects=True)
    assert r.status_code == 200
    log = AuditLog.query.filter_by(entity="Order", entity_id=order.id, action="update").order_by(AuditLog.id.desc()).first()
    assert log is not None
    assert log.after.get("status") == "paid"
```

---

## 14.12 붙여넣기 스타터 — Flask-Admin 최소구성

```python
# admin_bootstrap.py
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager, UserMixin, login_user, current_user
from flask_admin import Admin
from flask_admin.contrib.sqla import ModelView

app = Flask(__name__)
app.config.update(SQLALCHEMY_DATABASE_URI="sqlite:///dev.db", SECRET_KEY="dev")
db = SQLAlchemy(app)
login = LoginManager(app)

roles_users = db.Table("roles_users",
    db.Column("user_id", db.Integer, db.ForeignKey("user.id")),
    db.Column("role_id", db.Integer, db.ForeignKey("role.id"))
)

class Role(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True)

class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True)
    roles = db.relationship(Role, secondary=roles_users, backref="users")
    def has_role(self, name): return any(r.name == name for r in self.roles)

class Order(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer)
    total = db.Column(db.Float)
    status = db.Column(db.String(20))

class SecureModelView(ModelView):
    def is_accessible(self):
        return current_user.is_authenticated and current_user.has_role("admin")

admin = Admin(app, name="Backoffice")
admin.add_view(SecureModelView(Order, db.session))

@app.route("/login-as-admin")
def login_as_admin():
    u = User.query.filter_by(email="admin@example.com").first()
    login_user(u)
    return "ok"

if __name__ == "__main__":
    with app.app_context():
        db.create_all()
        if not User.query.first():
            admin_role = Role(name="admin"); db.session.add(admin_role); db.session.commit()
            u = User(email="admin@example.com"); u.roles.append(admin_role)
            db.session.add(u); db.session.commit()
    app.run(debug=True)
```

---

## 14.13 붙여넣기 스타터 — Flask-AppBuilder 최소구성

```python
# fab_bootstrap.py
from flask import Flask
from flask_appbuilder import AppBuilder, SQLA
from flask_appbuilder.models.sqla.interface import SQLAInterface
from flask_appbuilder import ModelView
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import Column, Integer, String, Float

app = Flask(__name__)
app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///fab.db"
app.config["CSRF_ENABLED"] = True
db = SQLA(app)
appbuilder = AppBuilder(app, db.session)

class Order(db.Model):
    id = Column(Integer, primary_key=True)
    user_email = Column(String(120))
    total = Column(Float)
    status = Column(String(20))

class OrderView(ModelView):
    datamodel = SQLAInterface(Order)
    list_columns = ["id","user_email","total","status"]

appbuilder.add_view(OrderView, "Orders", icon="fa-shopping-cart", category="Sales")

if __name__ == "__main__":
    db.create_all()
    app.run(debug=True)
```

---

## 14.14 흔한 안티패턴

- **어드민 = 루트 권한 전부**: 롤 세분화 없이 모든 것이 가능한 어드민 1종 → 사고 시 피해 막대  
- **감사 로그 부재**: 누가 무엇을 바꿨는지 추적 불가  
- **오버포스팅**: 클라이언트가 숨겨진 필드를 POST로 주입 → **서버 화이트리스트** 필수  
- **PII 노출**: 리스트 그리드에 주민번호/카드 16자리 그대로 → **마스킹/부분화**  
- **대량 액션에 Dry-Run 없음**: 한 번에 수천 건 잘못 변경 → **사전 미리보기**  
- **업로드 검증 생략**: 어드민이라서 괜찮겠지… → **아님**. 동일 정책 적용  
- **FAB 권한 매트릭스 무분별 오픈**: 운영자가 편하다고 `can_delete` 전파 → 주기적 리뷰 필요

---

## 14.15 체크리스트

- [ ] **프레임워크 선택**: Flask-Admin(경량) vs FAB(통합 RBAC)  
- [ ] **인증/인가**: RBAC, 최소권한, 민감 액션 재인증/이중승인  
- [ ] **감사 로그**: CRUD/로그인/임퍼소네이션/플래그 변경 기록  
- [ ] **벌크 액션**: 확인 모달, Dry-Run, 롤백 플랜  
- [ ] **엑스포트**: 스트리밍, PII 마스킹, 접근 통제  
- [ ] **파일 처리**: 화이트리스트, 스니핑, 스캔(13장)  
- [ ] **Feature Flags**: 토글 UI + 로깅  
- [ ] **점검 모드/배너**: 신속 안내  
- [ ] **성능**: 인덱스/서버 페이징, 슬로우쿼리 모니터  
- [ ] **테스트**: 권한/감사/위험 액션 단언
