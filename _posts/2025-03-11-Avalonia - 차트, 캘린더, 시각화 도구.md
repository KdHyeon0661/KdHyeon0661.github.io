---
layout: post
title: Avalonia - 차트, 캘린더, 시각화 도구
date: 2025-03-11 20:20:23 +0900
category: Avalonia
---
# Avalonia에서 차트, 캘린더, 시각화 도구 사용하기

## 0. 프로젝트 준비

```bash
dotnet add package LiveChartsCore.SkiaSharpView.Avalonia
dotnet add package OxyPlot.Avalonia
# 선택: 시간/타이머/리액티브
dotnet add package ReactiveUI
dotnet add package Microsoft.Extensions.DependencyInjection
```

네임스페이스:

```xml
xmlns:lvc="clr-namespace:LiveChartsCore.SkiaSharpView.Avalonia;assembly=LiveChartsCore.SkiaSharpView.Avalonia"
xmlns:oxy="clr-namespace:OxyPlot.Avalonia;assembly=OxyPlot.Avalonia"
```

---

## 1. LiveCharts2 — 빠르게 시작하기

### 1.1 기본 꺾은선 차트 (View + ViewModel)

**View (MainWindow.axaml)**

```xml
<lvc:CartesianChart Series="{Binding LineSeries}">
  <lvc:CartesianChart.XAxes>
    <lvc:Axis Labels="{Binding Labels}" Name="X" />
  </lvc:CartesianChart.XAxes>
  <lvc:CartesianChart.YAxes>
    <lvc:Axis Name="Y" MinLimit="0" MaxLimit="10" />
  </lvc:CartesianChart.YAxes>
</lvc:CartesianChart>
```

**ViewModel**

```csharp
using LiveChartsCore;
using LiveChartsCore.SkiaSharpView;

public class MainWindowViewModel
{
    public ISeries[] LineSeries { get; }
    public string[] Labels { get; }

    public MainWindowViewModel()
    {
        LineSeries = new ISeries[]
        {
            new LineSeries<double>
            {
                Values = new double[] { 3, 5, 7, 4, 6, 8 },
                Name = "Series A"
            }
        };

        Labels = new[] { "Jan", "Feb", "Mar", "Apr", "May", "Jun" };
    }
}
```

포인트:
- `ISeries[]`는 하나 이상의 시리즈를 담는 배열/컬렉션
- `Axis`의 `Labels`는 범주형 라벨에 적합
- 범위 제약: `MinLimit`, `MaxLimit`

---

## 2. 막대/파이/분산/영역 등 다양한 시리즈

### 2.1 막대 차트

```xml
<lvc:CartesianChart Series="{Binding BarSeries}">
  <lvc:CartesianChart.XAxes>
    <lvc:Axis Labels="{Binding Labels}"/>
  </lvc:CartesianChart.XAxes>
</lvc:CartesianChart>
```

```csharp
public class BarViewModel
{
    public ISeries[] BarSeries { get; }
    public string[] Labels { get; }

    public BarViewModel()
    {
        BarSeries = new ISeries[]
        {
            new ColumnSeries<double> { Values = new double[] { 10, 4, 6, 8, 12 }, Name = "Sales" }
        };
        Labels = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
    }
}
```

### 2.2 파이 차트

```xml
<lvc:PieChart Series="{Binding PieSeries}" />
```

```csharp
public class PieViewModel
{
    public ISeries[] PieSeries { get; }

    public PieViewModel()
    {
        PieSeries = new ISeries[]
        {
            new PieSeries<double> { Name = "A", Values = new[] { 40.0 } },
            new PieSeries<double> { Name = "B", Values = new[] { 30.0 } },
            new PieSeries<double> { Name = "C", Values = new[] { 30.0 } }
        };
    }
}
```

### 2.3 분산/버블/영역

```csharp
public class MixedViewModel
{
    public ISeries[] Series { get; }

    public MixedViewModel()
    {
        Series = new ISeries[]
        {
            new LineSeries<double>   { Name="Line",  Values = new double[] { 2, 3, 5, 4, 6 } },
            new AreaSeries<double>   { Name="Area",  Values = new double[] { 1, 2, 2, 3, 2 } },
            new ScatterSeries<double>{ Name="Scatter", Values = new double[] { 1, 5, 2, 6, 3 } }
        };
    }
}
```

---

## 3. 실시간 업데이트 — ObservableValue, ObservableCollection

### 3.1 ObservableValue로 고속 업데이트

```csharp
using LiveChartsCore.Defaults;

public class RealtimeViewModel
{
    private readonly ObservableValue _value = new(0);

    public ISeries[] Series { get; }

    public RealtimeViewModel()
    {
        Series = new ISeries[]
        {
            new LineSeries<ObservableValue> { Values = new[] { _value } }
        };

        // 타이머로 값 갱신
        var timer = new System.Threading.Timer(_ =>
        {
            _value.Value += 1; // 바뀌면 차트 자동 갱신
        }, null, 0, 500);
    }
}
```

### 3.2 Rolling 버퍼(최근 N개만 유지)

```csharp
public class RollingViewModel
{
    private readonly List<ObservableValue> _buffer = new();
    public ISeries[] Series { get; }

    public RollingViewModel()
    {
        // 초기 50개 버퍼
        for (int i = 0; i < 50; i++) _buffer.Add(new ObservableValue(0));

        Series = new ISeries[]
        {
            new LineSeries<ObservableValue> { Values = _buffer }
        };

        var rnd = new Random();
        var timer = new System.Threading.Timer(_ =>
        {
            App.Current?.Dispatcher?.Post(() =>
            {
                _buffer.Add(new ObservableValue(rnd.Next(0, 10)));
                if (_buffer.Count > 120) _buffer.RemoveAt(0);
            });
        }, null, 0, 250);
    }
}
```

---

## 4. 축 포맷팅, 다중 축, 툴팁/범례 템플릿

### 4.1 축 포맷팅

```xml
<lvc:CartesianChart Series="{Binding Series}">
  <lvc:CartesianChart.XAxes>
    <lvc:Axis Name="X" LabelsRotation="45" Labeler="{Binding XLabeler}" />
  </lvc:CartesianChart.XAxes>
  <lvc:CartesianChart.YAxes>
    <lvc:Axis Name="Y" Labeler="{Binding YLabeler}"/>
  </lvc:CartesianChart.YAxes>
</lvc:CartesianChart>
```

```csharp
public class AxisViewModel
{
    public ISeries[] Series { get; }
    public Func<double, string> XLabeler { get; }
    public Func<double, string> YLabeler { get; }

    public AxisViewModel()
    {
        Series = new ISeries[] { new LineSeries<double> { Values = new double[] { 1000, 2300, 3500 } } };

        XLabeler = v => $"W{(int)v}";
        YLabeler = v => $"{v / 1000:0.#}k";
    }
}
```

### 4.2 2축(왼쪽/오른쪽)

```xml
<lvc:CartesianChart Series="{Binding Series}">
  <lvc:CartesianChart.YAxes>
    <lvc:Axis Name="LeftAxis"  Position="Start" />
    <lvc:Axis Name="RightAxis" Position="End" />
  </lvc:CartesianChart.YAxes>
</lvc:CartesianChart>
```

```csharp
public class TwoAxisViewModel
{
    public ISeries[] Series { get; }

    public TwoAxisViewModel()
    {
        Series = new ISeries[]
        {
            new LineSeries<double> { Values = new double[] { 1, 2, 3, 4 }, ScalesYAt=0, Name="Temp" },
            new ColumnSeries<double> { Values = new double[] { 10, 40, 20, 30 }, ScalesYAt=1, Name="Volume" }
        };
    }
}
```

### 4.3 툴팁/범례 커스터마이징(기본: LiveCharts2 템플릿 사용 권장)

툴팁 내용 포맷 변경은 시리즈의 `Mapping` 또는 값 포맷터로 처리하고, 범례는 차트의 범례 위치 속성으로 간단히 배치한다.  
복잡한 툴팁 UI가 필요하면 Chart 주변에 별도의 정보 패널을 두고 마우스 히트테스트 이벤트를 바인딩하는 구조를 추천한다.

---

## 5. OxyPlot — 가벼운 학술/보고서 중심 시각화

### 5.1 기본 선형 예제

```xml
<oxy:PlotView Model="{Binding PlotModel}" />
```

```csharp
using OxyPlot;
using OxyPlot.Axes;
using OxyPlot.Series;

public class OxyMainViewModel
{
    public PlotModel PlotModel { get; } = new PlotModel { Title = "OxyPlot Example" };

    public OxyMainViewModel()
    {
        PlotModel.Axes.Add(new LinearAxis { Position = AxisPosition.Left, Title = "Y" });
        PlotModel.Axes.Add(new LinearAxis { Position = AxisPosition.Bottom, Title = "X" });

        var line = new LineSeries { Title = "Trend" };
        line.Points.Add(new DataPoint(0, 0));
        line.Points.Add(new DataPoint(10, 18));
        line.Points.Add(new DataPoint(20, 12));
        PlotModel.Series.Add(line);
    }
}
```

장점: 렌더 비용이 낮고, 정적인 출력(보고서, PDF 내보내기)에 적합.  
단점: 고급 애니메이션/실시간 시나리오는 LiveCharts2 대비 제약.

---

## 6. 날짜 선택/일정 시각화 — DatePicker와 커스텀 캘린더

Avalonia에는 내장된 풀기능 월 달력 컨트롤은 없으나 **DatePicker** 혹은 **ItemsRepeater/UniformGrid**를 이용해 간단히 구성 가능하다.

### 6.1 DatePicker

```xml
<DatePicker SelectedDate="{Binding SelectedDate}" />
```

```csharp
public class DatePickerViewModel : ReactiveUI.ReactiveObject
{
    private DateTimeOffset? _selectedDate = DateTimeOffset.Now;
    public DateTimeOffset? SelectedDate
    {
        get => _selectedDate;
        set => this.RaiseAndSetIfChanged(ref _selectedDate, value);
    }
}
```

### 6.2 간단한 월 달력(Custom)

**뷰 모델**

```csharp
public record CalendarCell(DateTime Date, bool IsCurrentMonth, bool HasEvents);

public class CalendarViewModel : ReactiveUI.ReactiveObject
{
    private DateTime _current = DateTime.Today;
    public ObservableCollection<CalendarCell> Cells { get; } = new();

    public ReactiveUI.ReactiveCommand<Unit, Unit> PrevMonth { get; }
    public ReactiveUI.ReactiveCommand<Unit, Unit> NextMonth { get; }

    private readonly HashSet<DateTime> _eventDays = new(); // 예: 이벤트 날짜

    public string MonthTitle => _current.ToString("yyyy MMMM");

    public CalendarViewModel()
    {
        PrevMonth = ReactiveUI.ReactiveCommand.Create(() => { _current = _current.AddMonths(-1); Build(); });
        NextMonth = ReactiveUI.ReactiveCommand.Create(() => { _current = _current.AddMonths(1); Build(); });
        Build();
    }

    private void Build()
    {
        Cells.Clear();
        var first = new DateTime(_current.Year, _current.Month, 1);
        int offset = ((int)first.DayOfWeek + 6) % 7; // 월요일 시작처럼 정렬하고 싶다면 조정
        var start = first.AddDays(-offset);
        for (int i = 0; i < 42; i++)
        {
            var d = start.AddDays(i);
            Cells.Add(new CalendarCell(d, d.Month == _current.Month, _eventDays.Contains(d.Date)));
        }
        this.RaisePropertyChanged(nameof(MonthTitle));
    }
}
```

**뷰 (예시)**

```xml
<Grid RowDefinitions="Auto,Auto,*" Margin="8">
  <StackPanel Orientation="Horizontal" Spacing="8">
    <Button Content="Prev" Command="{Binding PrevMonth}" />
    <TextBlock Text="{Binding MonthTitle}" FontSize="16" />
    <Button Content="Next" Command="{Binding NextMonth}" />
  </StackPanel>

  <UniformGrid Rows="1" Columns="7" Margin="0,8,0,0">
    <TextBlock Text="Mon" HorizontalAlignment="Center"/>
    <TextBlock Text="Tue" HorizontalAlignment="Center"/>
    <TextBlock Text="Wed" HorizontalAlignment="Center"/>
    <TextBlock Text="Thu" HorizontalAlignment="Center"/>
    <TextBlock Text="Fri" HorizontalAlignment="Center"/>
    <TextBlock Text="Sat" HorizontalAlignment="Center"/>
    <TextBlock Text="Sun" HorizontalAlignment="Center"/>
  </UniformGrid>

  <ItemsControl Grid.Row="2" Items="{Binding Cells}">
    <ItemsControl.ItemsPanel>
      <ItemsPanelTemplate>
        <UniformGrid Rows="6" Columns="7"/>
      </ItemsPanelTemplate>
    </ItemsControl.ItemsPanel>
    <ItemsControl.ItemTemplate>
      <DataTemplate>
        <Border Margin="2" CornerRadius="4"
                Background="{Binding IsCurrentMonth, Converter={StaticResource BoolToBrushConverter}}">
          <StackPanel Margin="6">
            <TextBlock Text="{Binding Date.Day}" HorizontalAlignment="Left"/>
            <Ellipse Width="6" Height="6" Fill="Red" IsVisible="{Binding HasEvents}" HorizontalAlignment="Right"/>
          </StackPanel>
        </Border>
      </DataTemplate>
    </ItemsControl.ItemTemplate>
  </ItemsControl>
</Grid>
```

- `BoolToBrushConverter`는 현재월과 이전/다음 월의 셀 배경을 구분
- `HasEvents` 표시용 작은 점을 통해 일정 유무 가시화
- 날짜 클릭 시 `Command` 바인딩을 추가해 상세 패널 갱신 가능

---

## 7. 캘린더와 차트의 연동

예: 특정 날짜 선택 시 해당 날짜의 매출/지표를 차트에 반영

**ViewModel**

```csharp
public class CalendarChartViewModel : ReactiveUI.ReactiveObject
{
    private readonly Dictionary<DateTime, double[]> _dailySeries = new();
    private DateTime _selected = DateTime.Today;

    public ObservableCollection<ISeries> Series { get; } = new();
    public DateTime Selected
    {
        get => _selected;
        set
        {
            this.RaiseAndSetIfChanged(ref _selected, value);
            LoadFor(_selected);
        }
    }

    public CalendarChartViewModel()
    {
        // 예제 데이터
        var rnd = new Random();
        for (int i = -30; i <= 0; i++)
        {
            var day = DateTime.Today.AddDays(i);
            _dailySeries[day] = Enumerable.Range(0, 24).Select(_ => rnd.Next(0, 100)).Select(x => (double)x).ToArray();
        }
        LoadFor(_selected);
    }

    private void LoadFor(DateTime day)
    {
        Series.Clear();
        if (_dailySeries.TryGetValue(day.Date, out var vals))
        {
            Series.Add(new LineSeries<double> { Values = vals, Name = day.ToShortDateString() });
        }
    }
}
```

**View (일부)**

```xml
<Grid ColumnDefinitions="320,*">
  <!-- 왼쪽: 달력 -->
  <!-- 달력 셀 클릭 시 Selected를 갱신하도록 Command/Binding 구성 -->

  <!-- 오른쪽: 차트 -->
  <lvc:CartesianChart Grid.Column="1" Series="{Binding Series}"/>
</Grid>
```

---

## 8. 데이터 서비스/DI/테스트 설계

### 8.1 서비스 계약

```csharp
public interface IMetricService
{
    Task<IReadOnlyList<(DateTime time, double value)>> GetHourlyAsync(DateTime day, CancellationToken ct = default);
}
```

### 8.2 차트용 ViewModel

```csharp
public class MetricsChartViewModel : ReactiveUI.ReactiveObject
{
    private readonly IMetricService _svc;

    public ObservableCollection<ISeries> Series { get; } = new();

    public MetricsChartViewModel(IMetricService svc)
    {
        _svc = svc;
    }

    public async Task LoadAsync(DateTime day, CancellationToken ct = default)
    {
        var data = await _svc.GetHourlyAsync(day, ct);
        Series.Clear();
        Series.Add(new LineSeries<double> { Values = data.Select(d => d.value).ToArray(), Name = day.ToShortDateString() });
    }
}
```

### 8.3 DI 등록

```csharp
var services = new ServiceCollection();
services.AddSingleton<IMetricService, MetricService>();
services.AddTransient<MetricsChartViewModel>();
var provider = services.BuildServiceProvider();
```

### 8.4 단위 테스트 (서비스 목)

```csharp
[Fact]
public async Task LoadAsync_BindsSeries()
{
    var mock = new Mock<IMetricService>();
    mock.Setup(s => s.GetHourlyAsync(It.IsAny<DateTime>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync(Enumerable.Range(0, 24).Select(h => (DateTime.Today.AddHours(h), (double)h)).ToList());

    var vm = new MetricsChartViewModel(mock.Object);
    await vm.LoadAsync(DateTime.Today);

    Assert.Single(vm.Series);
}
```

---

## 9. 내보내기/스크린샷 — 보고서 연계

Avalonia 컨트롤은 `RenderTargetBitmap`으로 캡처 가능하다. 차트 컨트롤을 PNG로 저장해 보고서에 포함한다.

```csharp
using Avalonia;
using Avalonia.Controls;
using Avalonia.Media.Imaging;
using Avalonia.Platform;

public static class VisualExport
{
    public static async Task SaveToPngAsync(Control control, string path)
    {
        var pixelSize = new PixelSize((int)control.Bounds.Width, (int)control.Bounds.Height);
        var size = new Size(control.Bounds.Width, control.Bounds.Height);

        using var rtb = new RenderTargetBitmap(pixelSize, new Vector(96, 96));
        control.Measure(size);
        control.Arrange(new Rect(size));
        rtb.Render(control);

        await using var fs = File.Open(path, FileMode.Create);
        rtb.Save(fs);
    }
}
```

> OxyPlot은 자체적으로 `PngExporter`가 있어 데이터 기반 출력에도 용이하다.

---

## 10. 테마/스타일/모션

- LiveCharts2는 SkiaSharp 기반 렌더링. 다크/라이트 테마에 맞춰 **축/라벨 색상**을 지정
- 전환 애니메이션은 LiveCharts2가 제공하며, 페이지 전환/패널 표시 등 UI 전반 모션은 Avalonia의 `Transitions`/`Avalonia.Animation`을 함께 사용
- 성능상 변화를 최소화하려면 차트의 **Points 수를 제한**하거나 **다운샘플링** 전략을 적용

---

## 11. 성능/최적화 팁

| 항목 | 권장 |
|------|------|
| 데이터 수 | 수만 포인트 이상이면 집계/리샘플링 |
| 업데이트 빈도 | 100~500ms 단위 버퍼링 후 갱신 |
| 바인딩 비용 | `ObservableValue`/배열로 직접 갱신, 불필요한 컬렉션 리셋 지양 |
| 축/라벨 | 라벨 회전/포맷은 간결하게, 범위를 고정해 자동 축계산 최소화 |
| 하드웨어 | SkiaSharp 렌더가 CPU를 사용하므로 대량 시리즈는 수량/빈도 조절 |

---

## 12. 고급 시나리오

### 12.1 히트맵/밀도 시각화(LiveCharts2 HeatSeries)

시간대별/영역별 강도를 색으로 표현할 때 유용하다. 대량 데이터는 샘플링 후 사용.

```csharp
// 개념 예시: LiveCharts2 HeatSeries<double> 사용
// 실제 프로젝트에서는 2D 배열 혹은 좌표+값 목록으로 구성
```

### 12.2 줌/팬(OxyPlot)

OxyPlot은 기본 상호작용(줌/팬)이 강점. 보고서/분석용 도구에 적합.  
LiveCharts2에서도 사용자 상호작용을 일부 제공하지만 정밀 분석은 OxyPlot 선택을 고려.

### 12.3 일정 밀도 맵(달력 + 열지도 결합)

월 캘린더 각 셀 배경을 **값의 크기에 따라 브러시**로 채워 **히트 캘린더**를 구현할 수 있다.  
값→색상 매핑은 `IValueConverter`로 구성.

---

## 13. LiveCharts vs OxyPlot 요약

| 항목 | LiveCharts2 | OxyPlot |
|------|-------------|---------|
| 렌더 | SkiaSharp, 애니메이션 중심 | 벡터/정적, 상호작용(줌/팬) 강함 |
| 실시간 | 강함(ObservableValue, 버퍼 전략) | 가능하나 애니메이션 제약 |
| 테마/스타일 | 현대적, 시각적 효과 | 학술/보고서 스타일 |
| 내보내기 | 컨트롤 캡처/Skia 활용 | PngExporter 등 도구 다수 |
| 대용량 | 다운샘플링 필요 | 정적 분석엔 적합 |

둘을 상호보완적으로 **동일 앱 내에서 혼용**해도 무방하다.

---

## 14. 마무리 체크리스트

- MVVM 기준으로 ViewModel에 **Series/Labels**만 노출
- 실시간은 **ObservableValue/버퍼링**으로 최소한의 변경만 전달
- 축 포맷/라벨 최소화로 렌더 비용 절감
- 보고서/수출용은 OxyPlot의 **Export** 기능 적극 활용
- 캘린더는 **DatePicker**로 간단히, 필요하다면 **UniformGrid 기반 커스텀** 구현
- 차트-캘린더 연동으로 날짜 선택 → 차트 데이터 재바인딩

---

## 부록 A. 간단한 통합 샘플(달력 + 일별 시계열)

**View**

```xml
<Grid ColumnDefinitions="320,*" Margin="12">
  <!-- 좌측: 달력 -->
  <local:MonthCalendar DataContext="{Binding Calendar}" />

  <!-- 우측: 시계열 -->
  <lvc:CartesianChart Grid.Column="1"
                      Series="{Binding Chart.Series}">
    <lvc:CartesianChart.XAxes>
      <lvc:Axis Name="Hour" Labeler="{Binding Chart.HourLabeler}" />
    </lvc:CartesianChart.XAxes>
    <lvc:CartesianChart.YAxes>
      <lvc:Axis Name="Value" />
    </lvc:CartesianChart.YAxes>
  </lvc:CartesianChart>
</Grid>
```

**ViewModel(상위)**

```csharp
public class DashboardViewModel
{
    public CalendarViewModel Calendar { get; }
    public MetricsChartViewModel Chart { get; }

    public DashboardViewModel(IMetricService svc)
    {
        Calendar = new CalendarViewModel();
        Chart = new MetricsChartViewModel(svc);

        // 달력에서 날짜가 바뀔 때 차트 로드
        Calendar.WhenAnyValue(c => c.SelectedDate)
                .Where(d => d.HasValue)
                .Subscribe(async d => await Chart.LoadAsync(d!.Value.DateTime));
    }
}
```

**MetricService 예시**

```csharp
public class MetricService : IMetricService
{
    public Task<IReadOnlyList<(DateTime time, double value)>> GetHourlyAsync(DateTime day, CancellationToken ct = default)
    {
        var rnd = new Random(day.Day);
        var list = Enumerable.Range(0, 24)
            .Select(h => (day.AddHours(h), rnd.NextDouble() * 100))
            .ToList()
            .AsReadOnly();
        return Task.FromResult<IReadOnlyList<(DateTime, double)>>(list);
    }
}
```

---

## 부록 B. 오류 원인 진단과 해결 요약

| 증상 | 진단 | 해결 |
|------|------|------|
| 차트가 갱신 안 됨 | 기존 배열 참조 유지 | `ObservableValue` 사용 또는 새 배열 할당 |
| 프레임 드랍 | 데이터 과다/라벨 과도 | 다운샘플링, 라벨 축소, 업데이트 주기 늘리기 |
| 라벨 겹침 | 축 범위/회전 미설정 | `LabelsRotation`, `MinStep` 조정 |
| 어두운 테마에서 흐릿 | 글자/축색 기본값 | 축/글자 색 직접 지정 |

---

## 결론

- **LiveCharts2**는 현대적 UI와 실시간 갱신에 강점, **OxyPlot**은 분석/보고서 친화적이다.
- 캘린더는 **DatePicker**부터 **UniformGrid 기반 커스텀**까지 요구사항에 맞게 선택한다.
- MVVM을 유지하면서 서비스/DI/테스트 설계를 병행하면 유지보수성과 확장성을 동시에 확보할 수 있다.
- 대용량/실시간 환경에서는 **다운샘플링/버퍼링/축 포맷 최소화**로 성능을 확보한다.