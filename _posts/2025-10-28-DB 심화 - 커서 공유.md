---
layout: post
title: DB 심화 - 커서 공유
date: 2025-10-28 18:25:23 +0900
category: DB 심화
---
# 커서 공유(Cursor Sharing)

## 큰 그림 요약

- **커서(Cursor)**: 파싱된 SQL/PLSQL의 **실행 가능 객체**. **파스 트리 + 실행계획 + 런타임 메타**를 담는다.
- **Parent / Child**
  - **Parent 커서**: **텍스트(정규화된 SQL)** 단위의 식별자. 흔히 **`SQL_ID`** 로 식별.
  - **Child 커서**: 같은 텍스트라도 **환경(파라미터/바인드 패턴/스키마)** 차이로 분기된 **실행 단위**.
- **커서 공유(Cursor Sharing)**: 기존 **Parent/Child**를 **재사용(소프트 파싱)** 하여 **하드 파싱 비용과 동시성 경합**을 줄이는 행위.
- **실무 원칙**
  1) **바인드 변수**를 사용(리터럴 남발 금지).
  2) **세션 환경**을 표준화(옵티마이저/NLS/DATE 설정 등).
  3) **스큐 컬럼 히스토그램 + ACS**로 Child 남발은 줄이고 **필요한 Child만 유지**.
  4) **DDL/통계 변경**은 저부하 시간에 배포(Invalidation 폭주 방지).

---

## 커서란 무엇인가?
### 커서의 내부 구성(요지)

- **Parent**: 텍스트 키(정규화된 SQL 문자열).
- **Child**: 실행환경별 인스턴스(플랜/옵티마이저 환경/바인드 메타/권한 등).
- **Heaps**: 파스 트리, 실행계획, Predicate/Projection, Outline/힌트, 통계 등 세부 힙으로 저장.
- **위치**: **Shared Pool → Library Cache** (KGL 네임스페이스 `SQL AREA`).

### 커서 수명주기(요약)

1) **파싱**: 텍스트 해싱 → Parent 탐색 → Child 재사용 가능성 판단 → 없으면 **하드 파싱**.
2) **최적화**: CBO가 카디널리티/비용 산정 후 플랜 결정(Child가 이 정보를 가짐).
3) **실행/페치**: Row-Source 트리 실행.
4) **재사용**: 동일 텍스트+환경이면 **소프트 파싱**으로 Child 재사용.

---

## 커서 공유의 이점과 확인 방법
### 이점

- **하드 파싱 감소** → `parse time elapsed`↓, `library cache: mutex X/S` 경합↓.
- **라이브러리 캐시 메모리**/CPU 절감, 플랜 안정성↑(SPM 병행 시).

### 공유 여부 관찰(핵심 뷰)

```sql
-- 최근에 활성화된 동일 SQL의 Parent/Child 현황
SELECT sql_id, COUNT(*) AS child_cnt,
       SUM(parse_calls) parse_calls, SUM(executions) execs
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* demo */%'
GROUP  BY sql_id
ORDER  BY child_cnt DESC;

-- Child가 왜 분기(공유 실패)했는지
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_id = :sql_id
  AND  reason IS NOT NULL AND reason <> 'N'
ORDER  BY child_number;

-- 시스템 파싱 지표
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('parse count (total)','parse count (hard)','parse time elapsed');
```

---

## 예제로 보는 **커서 공유의 기본** (리터럴 vs 바인드)
### 실습 테이블

```sql
CREATE TABLE t_demo (
  id    NUMBER PRIMARY KEY,
  rgn   VARCHAR2(10),
  amt   NUMBER,
  dt    DATE
);

INSERT /*+ APPEND */ INTO t_demo
SELECT level,
       CASE MOD(level,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END,
       ROUND(DBMS_RANDOM.VALUE(10,1000),2),
       DATE '2025-10-01' + MOD(level, 15)
FROM dual CONNECT BY level <= 100000;

COMMIT;
CREATE INDEX ix_t_demo_rgn_dt ON t_demo(rgn, dt);
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'T_DEMO',cascade=>TRUE, method_opt=>'FOR COLUMNS SIZE 75 rgn');
```

### 리터럴 사용(나쁜 예)

```sql
-- 같은 구조인데 값만 다른 SQL → Parent 자체가 다수 생성될 수 있음
SELECT /* demo */ COUNT(*) FROM t_demo WHERE rgn='APAC';
SELECT /* demo */ COUNT(*) FROM t_demo WHERE rgn='EMEA';
SELECT /* demo */ COUNT(*) FROM t_demo WHERE rgn='AMER';
```

### 바인드 사용(좋은 예)

```sql
VAR r VARCHAR2(10); EXEC :r := 'APAC';
SELECT /* demo */ COUNT(*) FROM t_demo WHERE rgn=:r;

EXEC :r := 'EMEA';
SELECT /* demo */ COUNT(*) FROM t_demo WHERE rgn=:r;

EXEC :r := 'AMER';
SELECT /* demo */ COUNT(*) FROM t_demo WHERE rgn=:r;
```

### 결과 관찰 포인트

- 리터럴 방식은 **Parent(=SQL_ID)가 여러 개** 생기고, 각 Parent마다 **Child**도 존재 → **하드 파싱 증가**.
- 바인드 방식은 **Parent 1개** 아래 **Child 수 소수**(필요시 ACS로 분기).
- 확인:
```sql
SELECT sql_id, child_number, executions, parse_calls
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* demo */ COUNT(*) FROM t_demo%'
ORDER  BY sql_id, child_number;
```

---

## **Child 커서를 공유하지 못하는** 대표 케이스 (같은 Parent인데 Child가 늘어남)

> “텍스트는 같지만 **환경이 달라** 같은 Child를 재사용하지 못하는 상황들”

### 바인드 관련 불일치

- **타입/길이 불일치**, **NCHAR/NVARCHAR2 vs VARCHAR2**, **숫자→문자 비교** 혼용 등
```sql
-- 세션 A
VAR r VARCHAR2(10); EXEC :r := 'APAC';
SELECT /* child-bind */ COUNT(*) FROM t_demo WHERE rgn=:r;

-- 세션 B (다른 타입 바인드)
VAR r NVARCHAR2(10); EXEC :r := N'APAC';
SELECT /* child-bind */ COUNT(*) FROM t_demo WHERE rgn=:r;

-- 결과: 같은 Parent 텍스트지만 바인드 메타 차이로 Child 분기
```
확인:
```sql
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_text LIKE 'SELECT /* child-bind */ COUNT(*) FROM t_demo%'
  AND  reason IS NOT NULL AND reason <> 'N';
-- 흔한 이유: BIND_MISMATCH, TRANSLATION_MISMATCH, BIND_EQUIV_FAILURE 등
```

### 옵티마이저 환경 불일치

- `optimizer_mode`, `optimizer_features_enable`, `nls_comp`, `nls_sort`, `cursor_sharing` 등 **세션 파라미터** 차이
```sql
-- 세션 A
ALTER SESSION SET optimizer_mode=ALL_ROWS;
SELECT /* child-env */ COUNT(*) FROM t_demo WHERE rgn=:r;

-- 세션 B
ALTER SESSION SET optimizer_mode=FIRST_ROWS;
SELECT /* child-env */ COUNT(*) FROM t_demo WHERE rgn=:r;

-- 같은 Parent 텍스트지만 환경 차이 → Child 분기 (OPTIMIZER_MISMATCH 등)
```
확인:
```sql
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_text LIKE 'SELECT /* child-env */ COUNT(*) FROM t_demo%'
  AND  reason IS NOT NULL AND reason <> 'N';
```

### 스키마/권한/뷰 확장 차이(파싱 스키마가 다른 경우)

- 동일 텍스트라도 **파싱 스키마**에 따라 **참조 오브젝트**가 달라질 수 있음.
```sql
-- USER1, USER2 모두 T_DEMO가 있고 동명의 뷰/시노님 구조가 다르다고 가정
-- 각 사용자 세션에서 같은 텍스트 실행 → Child 분기 혹은 Parent가 달라질 수 있음
SELECT /* child-schema */ COUNT(*) FROM t_demo WHERE rgn=:r;
```
- 이유: `AUTH_CHECK_MISMATCH`, `TRANSLATION_MISMATCH` 등.

### 바인드 스큐(ACS)로 Child 분기

- 값 분포 **스큐**가 크면 **Adaptive Cursor Sharing**이 **Child를 여러 개** 만든다.
```sql
VAR r VARCHAR2(10);

EXEC :r := 'APAC'; -- 자주 등장, 선택도 낮음(행 많음)
SELECT /* child-acs */ SUM(amt) FROM t_demo WHERE rgn=:r;

EXEC :r := 'AMER'; -- 드묾, 선택도 높음(행 적음)
SELECT /* child-acs */ SUM(amt) FROM t_demo WHERE rgn=:r;

-- 바인드 민감/어웨어 확인
SELECT sql_id, child_number, is_bind_sensitive, is_bind_aware, plan_hash_value
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* child-acs */ SUM(amt)%'
ORDER  BY child_number;
```
- 의도된 분기는 **공유 실패가 아니라 “적응형 최적화”** 이므로 문제 아님(과도 분기는 점검).

### 통계/환경 변화에 따른 재파싱 & Child 추가

- 통계 재수집/DDL/권한 변경 → **Invalidation** 발생, 이후 실행 시 **새 Child**가 생길 수 있다.
```sql
-- 다른 세션에서 인덱스 추가
CREATE INDEX ix_t_demo_dt ON t_demo(dt);
-- 다시 실행하면 parse_calls/child 증가 가능
```

---

## **Parent 커서를 공유하지 못하는** 대표 케이스 (텍스트가 달라 Parent 자체가 분리)

> “**텍스트(정규화 결과)** 가 다르면 Parent가 다르다 → `SQL_ID` 별개”

### 리터럴 값 차이

```sql
-- 값이 바뀌면 Parent가 다른 경우가 대부분
SELECT /* parent-lit */ COUNT(*) FROM t_demo WHERE rgn='APAC';
SELECT /* parent-lit */ COUNT(*) FROM t_demo WHERE rgn='EMEA';
```
- **해결**: **바인드 변수** 사용. (혹은 임시 방편 `CURSOR_SHARING=FORCE` 고려)

### 힌트/주석/공백/대소문자 등 텍스트 차이

```sql
-- 힌트/주석이 다르면 보통 서로 다른 Parent로 간주될 수 있다
SELECT /*+ INDEX(t_demo ix_t_demo_rgn_dt) */ COUNT(*) FROM t_demo WHERE rgn=:r;
SELECT /* parent-hint */ COUNT(*) FROM t_demo WHERE rgn=:r;

-- (주석/힌트 처리와 정규화 규칙에 따라 다르므로) 실무에선 "문자 그대로 동일"을 원칙으로 관리
```

### 스키마 접두/오브젝트 명시 차이

```sql
-- USER1에서:
SELECT /* parent-schema */ COUNT(*) FROM user1.t_demo WHERE rgn=:r;
-- USER2에서:
SELECT /* parent-schema */ COUNT(*) FROM user2.t_demo WHERE rgn=:r;
```
- **오브젝트 명시**가 다르면 텍스트 자체가 달라 Parent도 다름.

### SQL 리라이트(코드 생성기/ORM)로 텍스트 변형

- ORM이 조건이 없는 경우 `WHERE 1=1`을 붙이거나 **컬럼 순서**/JOIN 순서를 자주 바꾸면 **Parent 폭증**.
- **대응**: SQL 템플릿 **고정**, 조건만 바인드로 대입.

---

## `CURSOR_SHARING` 파라미터와 주의

- 값: **`EXACT`(기본)**, `FORCE` (과거 `SIMILAR`는 비권장/제거).
- `FORCE`: 리터럴을 내부적으로 바인드로 치환해 **Parent 감소** 효과.
  - **주의**: **선택도/히스토그램** 기반 최적화가 왜곡될 수 있음(플랜 품질 저하).
  - **권고**: 앱 수정이 불가한 **응급 시** 임시로 사용하고, **바인드 전환**이 정석.

```sql
-- (테스트 전용) 세션 단 적용
ALTER SESSION SET cursor_sharing=FORCE;
```

---

## “왜 공유 안 됐는지”를 밝히는 **진단 절차**

1) **Parent/Child 현황**과 **parse_calls** 확인
2) `V$SQL_SHARED_CURSOR`에서 **reason** 열 조회
3) 세션 파라미터/바인드 메타/스키마/권한/옵티마이저 환경 비교
4) 필요 시 **XPLAN(ALLSTATS LAST +PEEKED_BINDS +NOTE)** 확인(바인드 피킹/Adaptive 표기)
5) 통계/DDL/권한 변경 타이밍과 **Invalidation** 여부 점검

**샘플 스크립트**
```sql
-- 1) 같은 SQL 후보 찾기
SELECT sql_id, COUNT(*) children, SUM(parse_calls) parse_calls
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* check */%'
GROUP  BY sql_id
ORDER  BY children DESC;

-- 2) 공유 실패 이유
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_id=:sql_id
  AND  reason IS NOT NULL AND reason <> 'N'
ORDER  BY child_number;

-- 3) 바인드 민감/어웨어(ACS)
SELECT sql_id, child_number, is_bind_sensitive, is_bind_aware,
       plan_hash_value, last_active_time
FROM   v$sql
WHERE  sql_id=:sql_id
ORDER  BY child_number;
```

---

## 실전 시나리오와 처방

### “리터럴 폭주로 Parent 폭증”

- **증상**: 같은 패턴의 SQL이 값만 달라 **SQL_ID 수천 개**, `parse count (hard)`↑, `library cache: mutex X`↑.
- **처방**:
  1) **바인드 전환**(ORM/DAO 레벨)
  2) 임시로 `CURSOR_SHARING=FORCE`(품질 저하 감수), **후속 바인드 전환** 필수
  3) `SESSION_CACHED_CURSORS` ↑로 소프트 파싱 향상
- **검증**: Parent/Child 수 감소, 하드파싱 지표↓.

### “Child 폭증(환경 불일치)”

- **증상**: Parent는 하나인데 Child가 수십~수백, `V$SQL_SHARED_CURSOR.reason` 다수.
- **원인**: 세션 파라미터/바인드 메타 불일치, 스키마 참조 차이, NLS/옵티마이저 설정 혼재.
- **처방**:
  - **세션 파라미터 표준화**(로그인 트리거나 풀 설정으로 강제)
  - **바인드 타입 고정**(프레임워크 매핑 통일)
  - 파싱 스키마/시노님/뷰 해석의 **일관성** 확보
- **검증**: Child 수 안정, 공유 실패 `reason` 감소.

### “배포/통계 수집 직후 Invalidations 폭주”

- **증상**: 배포 시각에 `library cache lock/pin`/**뮤텍스** 대기 급증, 하드파싱 스파이크.
- **처방**:
  - **저부하 윈도우**에서 **순차** 배포/재컴파일
  - 대규모 통계 수집은 **분산/증분**(`DBMS_STATS` 옵션)
  - 장수행 세션 **드레인** 후 작업
- **검증**: 배포 시각의 대기 이벤트/파싱 피크 완화.

### “ACS 남발로 Child 과다”

- **증상**: 스큐 처리 과정에서 **Child가 과도** 발생(바인드 구간이 지나치게 세분).
- **처방**:
  - 히스토그램 정밀도 재점검(과도/과소), **쿼리 구조 개선**으로 스큐 완화
  - 필요 시 **SPM(Baseline)** 으로 플랜 안정
- **검증**: Child 수/플랜 변동성 감소.

---

## 개발·운영 체크리스트 (*암기 카드*)

1) **바인드 변수** 사용 — Parent 폭증 차단.
2) **세션 환경 표준화** — Child 폭증 차단(옵티마이저/NLS/타임존/언어 등).
3) **바인드 타입 일치** — BIND_MISMATCH 예방.
4) **DDL/통계 변경 윈도우링** — Invalidations 폭주 방지.
5) **ACS/히스토그램** — 필요한 범위에서만 Child 분기.
6) **`V$SQL_SHARED_CURSOR` 정기 점검** — 이유(reason) 상위 항목 제거.
7) **`SESSION_CACHED_CURSORS` 적정** — 소프트 파싱 향상.
8) **SPM(SQL Plan Baseline)** — 좋은 플랜을 장기 보존, 변동성↓.

---

## 부록 — 빠른 재현 패키지(통째로 복붙)

```sql
-- (1) 테스트 전 상태 점검
SELECT name, value FROM v$sysstat
WHERE  name IN ('parse count (total)','parse count (hard)','parse time elapsed');

-- (2) 리터럴 vs 바인드 비교 실행
SELECT /* demo */ COUNT(*) FROM t_demo WHERE rgn='APAC';
SELECT /* demo */ COUNT(*) FROM t_demo WHERE rgn='EMEA';
VAR r VARCHAR2(10); EXEC :r :='APAC';
SELECT /* demo */ COUNT(*) FROM t_demo WHERE rgn=:r;

-- (3) Parent/Child/Parsing 확인
SELECT sql_id, COUNT(*) children, SUM(parse_calls) parse_calls, SUM(executions) execs
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* demo */ COUNT(*) FROM t_demo%'
GROUP  BY sql_id
ORDER  BY children DESC;

-- (4) Child 분기 이유(환경/바인드/권한 불일치 등)
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_text LIKE 'SELECT /* demo */ COUNT(*) FROM t_demo%'
  AND  reason IS NOT NULL AND reason <> 'N'
ORDER BY child_number;

-- (5) ACS 여부
SELECT sql_id, child_number, is_bind_sensitive, is_bind_aware, plan_hash_value
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* demo */ COUNT(*) FROM t_demo%'
ORDER  BY child_number;
```

---

## 마무리

- **Parent 공유 실패**는 **텍스트가 달라** 생기고, **Child 공유 실패**는 **환경이 달라** 생긴다.
- 가장 큰 지렛대는 **바인드 변수**와 **환경 표준화**.
- 남은 변동성은 **ACS/히스토그램/플랜 안정화(SPM)** 로 다룬다.
- *증상(하드파싱/뮤텍스 대기) → 원인(리터럴/환경 불일치/Invalidation) → 처방(바인드/표준화/윈도우링/ACS/SPM)* 의 루틴을 **자동화**하면 커서 공유는 **안정적인 기본기**가 된다.

> **한 줄 요약**
> **Parent는 텍스트, Child는 환경**이다. 텍스트는 **바인드로 하나로** 묶고, 환경은 **표준화**하라. 그러면 커서는 **공유**되고 시스템은 **매끈하게** 돈다.
