---
layout: post
title: 영상처리 - 영상 분할 (C#)
date: 2025-12-11 16:30:23 +0900
category: 영상처리
---
# 영상 분할

## 영상 분할의 개요

영상 분할(Image Segmentation)은 영상 내의 픽셀을 의미 있는 영역(region) 또는 객체(object) 단위로 나누는 과정으로, 객체 인식, 물체 추적, 의료 영상 분석 등 다양한 컴퓨터 비전 응용의 핵심 전처리 단계이다.

### 분할 방법 분류표

| 분류 | 방법 | 특징 | 적용 분야 |
|------|------|------|-----------|
| **임계값 기반** | 전역/지역 이진화, Otsu | 구현 간단, 속도 빠름 | 문서 스캔, 바코드 인식 |
| **영역 기반** | 영역 확장, 분할 및 병합 | 물체 내부 일관성 보장 | 의료 영상(세포 분할) |
| **경계 기반** | 에지 검출, 외곽선 추적 | 객체 경계 강조 | 객체 인식, 형상 분석 |
| **클러스터링** | K-means, Mean-shift | 통계적 모델 기반 | 위성 영상, 시멘틱 분할 |
| **딥러닝** | CNN, U-Net, Mask R-CNN | 최고 정확도, 데이터 의존 | 자율주행, 의료 진단 |

### 분할 처리 파이프라인

```
원본 영상 → 전처리(노이즈 제거) → 분할 알고리즘 적용 → 후처리(작은 영역 제거) → 분할 결과
        ↓                    ↓                    ↓                    ↓
    평활화, 샤프닝   임계값/에지/영역   모폴로지 연산   객체별 마스크 생성
```

---

## 이진화(Thresholding)

### 이진화의 수학적 모델

영상 $I(x,y)$를 임계값 $T$를 기준으로 두 개의 클래스로 분할:

$$
g(x,y) =
\begin{cases}
1 (\text{전경}) & \text{if } f(x,y) \ge T \\
0 (\text{배경}) & \text{if } f(x,y) < T
\end{cases}
$$

### 임계값 선택 방법 비교

| 방법 | 공식 | 장점 | 단점 |
|------|------|------|------|
| **고정 임계값** | $T = \text{constant}$ | 빠름, 구현 간단 | 조명 변화에 취약 |
| **평균 임계값** | $T = \frac{1}{N}\sum I(x,y)$ | 전체 밝기 고려 | 균일하지 않은 영상 부적합 |
| **히스토그램 골** | 히스토그램 최소값 | 명확한 모드 분리시 효과적 | 노이즈 민감 |
| **Otsu** | 클래스 간 분산 최대화 | 자동 선택, 통계적 최적 | 바이모달 히스토그램 필요 |

### 전역 이진화 고성능 구현

```csharp
public class GlobalThresholder
{
    public enum ThresholdMode
    {
        Fixed,      // 고정 임계값
        Mean,       // 평균 임계값
        Median,     // 중앙값 임계값
        Percentile  // 백분위 임계값
    }
    
    public unsafe Bitmap ApplyGlobalThreshold(Bitmap src, ThresholdMode mode, int fixedValue = 128)
    {
        Bitmap dst = new Bitmap(src.Width, src.Height);
        Rectangle rect = new Rectangle(0, 0, src.Width, src.Height);
        
        BitmapData srcData = src.LockBits(rect, 
            ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
        BitmapData dstData = dst.LockBits(rect,
            ImageLockMode.WriteOnly, PixelFormat.Format1bppIndexed);
        
        int threshold = fixedValue;
        
        // 임계값 계산
        switch (mode)
        {
            case ThresholdMode.Mean:
                threshold = CalculateMeanThreshold(srcData);
                break;
            case ThresholdMode.Median:
                threshold = CalculateMedianThreshold(srcData);
                break;
            case ThresholdMode.Percentile:
                threshold = CalculatePercentileThreshold(srcData, 70); // 상위 30%
                break;
        }
        
        // 이진화 적용
        int strideSrc = srcData.Stride;
        int strideDst = dstData.Stride;
        
        byte* srcPtr = (byte*)srcData.Scan0;
        byte* dstPtr = (byte*)dstData.Scan0;
        
        for (int y = 0; y < src.Height; y++)
        {
            byte* srcRow = srcPtr + (y * strideSrc);
            byte* dstRow = dstPtr + (y * strideDst);
            
            int dstBit = 0;
            for (int x = 0; x < src.Width; x++)
            {
                // 그레이스케일 변환 (Y = 0.299R + 0.587G + 0.114B)
                int gray = (int)(0.299 * srcRow[x * 3 + 2] + 
                                 0.587 * srcRow[x * 3 + 1] + 
                                 0.114 * srcRow[x * 3]);
                
                // 이진화
                bool isForeground = gray >= threshold;
                
                // 1bpp 형식으로 저장 (8픽셀씩 패킹)
                if (isForeground)
                {
                    dstRow[dstBit >> 3] |= (byte)(1 << (7 - (dstBit & 7)));
                }
                
                dstBit++;
            }
        }
        
        src.UnlockBits(srcData);
        dst.UnlockBits(dstData);
        
        return dst;
    }
    
    private unsafe int CalculateMeanThreshold(BitmapData data)
    {
        long sum = 0;
        int count = data.Width * data.Height;
        
        byte* ptr = (byte*)data.Scan0;
        int stride = data.Stride;
        
        for (int y = 0; y < data.Height; y++)
        {
            byte* row = ptr + (y * stride);
            for (int x = 0; x < data.Width; x++)
            {
                int gray = (int)(0.299 * row[x * 3 + 2] + 
                                 0.587 * row[x * 3 + 1] + 
                                 0.114 * row[x * 3]);
                sum += gray;
            }
        }
        
        return (int)(sum / count);
    }
}
```

### 다중 임계값 이진화

```
히스토그램과 다중 임계값:

        ▲
        │      배경        객체1       객체2
        │     ┌───┐      ┌───┐     ┌───┐
    빈도 │     │   │      │   │     │   │
        │     │   │      │   │     │   │
        └─────┼───┼──────┼───┼─────┼───┼─────▶ 명도
               T1        T2        T3
```

```csharp
public Bitmap MultiThreshold(Bitmap src, int[] thresholds)
{
    // 임계값 정렬 및 클래스 수 확인
    Array.Sort(thresholds);
    int classCount = thresholds.Length + 1;
    
    // 클래스별 색상 매핑
    Color[] classColors = new Color[classCount];
    for (int i = 0; i < classCount; i++)
    {
        int intensity = (i * 255) / (classCount - 1);
        classColors[i] = Color.FromArgb(intensity, intensity, intensity);
    }
    
    Bitmap dst = new Bitmap(src.Width, src.Height);
    
    for (int y = 0; y < src.Height; y++)
    {
        for (int x = 0; x < src.Width; x++)
        {
            Color c = src.GetPixel(x, y);
            int gray = (c.R + c.G + c.B) / 3;
            
            // 클래스 결정
            int classIndex = 0;
            for (int i = 0; i < thresholds.Length; i++)
            {
                if (gray >= thresholds[i])
                    classIndex = i + 1;
                else
                    break;
            }
            
            dst.SetPixel(x, y, classColors[classIndex]);
        }
    }
    
    return dst;
}
```

---

## 적응형 이진화와 Otsu 알고리즘

### 적응형 이진화 (Adaptive Thresholding)

국부적 조명 변화에 강건한 이진화 방법으로, 각 픽셀 주변의 국부 평균이나 가중 평균을 사용한다.

**수식:**
$$
T(x,y) = \mu(x,y) - C
$$
여기서 $\mu(x,y)$는 $(x,y)$ 주변 윈도우의 평균 밝기, $C$는 상수.

### Otsu 알고리즘의 상세 이론

Otsu 방법은 히스토그램이 바이모달(bimodal)일 때 최적으로 작동하며, 클래스 간 분산을 최대화하는 임계값을 선택한다.

#### 알고리즘 상세 단계:

1. **히스토그램 정규화:**
   $$
   p(i) = \frac{n_i}{N}, \quad i = 0,1,\ldots,L-1
   $$
   여기서 $n_i$는 명도 $i$의 빈도, $N$은 총 픽셀 수, $L$은 명도 레벨 수(일반적으로 256).

2. **누적 확률 계산:**
   $$
   \omega_0(t) = \sum_{i=0}^{t} p(i), \quad \omega_1(t) = \sum_{i=t+1}^{L-1} p(i) = 1 - \omega_0(t)
   $$

3. **클래스 평균 계산:**
   $$
   \mu_0(t) = \frac{\sum_{i=0}^{t} i \cdot p(i)}{\omega_0(t)}, \quad
   \mu_1(t) = \frac{\sum_{i=t+1}^{L-1} i \cdot p(i)}{\omega_1(t)}
   $$

4. **전체 평균:**
   $$
   \mu_T = \sum_{i=0}^{L-1} i \cdot p(i)
   $$

5. **클래스 간 분산:**
   $$
   \sigma_b^2(t) = \omega_0(t) \omega_1(t) [\mu_0(t) - \mu_1(t)]^2
   $$

6. **최적 임계값:**
   $$
   T^* = \arg\max_{0 \le t < L} \sigma_b^2(t)
   $$

#### Otsu 알고리즘 최적화 구현

```csharp
public class OtsuThresholder
{
    public int CalculateOtsuThreshold(int[] histogram)
    {
        int totalPixels = 0;
        double sumIntensity = 0;
        
        // 히스토그램 통계 계산
        for (int i = 0; i < 256; i++)
        {
            totalPixels += histogram[i];
            sumIntensity += i * histogram[i];
        }
        
        double sumBackground = 0;
        int weightBackground = 0;
        int weightForeground;
        
        double maxVariance = 0;
        int optimalThreshold = 0;
        
        // 효율적인 누적 계산
        for (int t = 0; t < 256; t++)
        {
            weightBackground += histogram[t];
            if (weightBackground == 0) continue;
            
            weightForeground = totalPixels - weightBackground;
            if (weightForeground == 0) break;
            
            sumBackground += t * histogram[t];
            
            double meanBackground = sumBackground / weightBackground;
            double meanForeground = (sumIntensity - sumBackground) / weightForeground;
            
            // 클래스 간 분산 계산
            double variance = weightBackground * weightForeground * 
                             Math.Pow(meanBackground - meanForeground, 2);
            
            if (variance > maxVariance)
            {
                maxVariance = variance;
                optimalThreshold = t;
            }
        }
        
        return optimalThreshold;
    }
    
    // 멀티스레드 히스토그램 계산
    public unsafe int[] ComputeHistogramParallel(Bitmap src)
    {
        int[] histogram = new int[256];
        int width = src.Width;
        int height = src.Height;
        Rectangle rect = new Rectangle(0, 0, width, height);
        
        BitmapData data = src.LockBits(rect, 
            ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
        
        int stride = data.Stride;
        byte* ptr = (byte*)data.Scan0;
        
        // 병렬 히스토그램 계산
        Parallel.For(0, height, y =>
        {
            byte* row = ptr + (y * stride);
            int[] localHist = new int[256];
            
            for (int x = 0; x < width; x++)
            {
                // 그레이스케일 변환
                int gray = (int)(0.299 * row[x * 3 + 2] + 
                                 0.587 * row[x * 3 + 1] + 
                                 0.114 * row[x * 3]);
                localHist[gray]++;
            }
            
            // 전역 히스토그램에 병합 (락 필요)
            lock (histogram)
            {
                for (int i = 0; i < 256; i++)
                    histogram[i] += localHist[i];
            }
        });
        
        src.UnlockBits(data);
        return histogram;
    }
    
    // 자동 Otsu 이진화 전체 프로세스
    public Bitmap ApplyOtsuThreshold(Bitmap src)
    {
        int[] histogram = ComputeHistogramParallel(src);
        int threshold = CalculateOtsuThreshold(histogram);
        
        GlobalThresholder thresholder = new GlobalThresholder();
        return thresholder.ApplyGlobalThreshold(src, 
            GlobalThresholder.ThresholdMode.Fixed, threshold);
    }
}
```

### 적응형 이진화 구현

```csharp
public class AdaptiveThresholder
{
    public enum AdaptiveMethod
    {
        Mean,       // 국부 평균
        Gaussian,   // 가우시안 가중 평균
        Median      // 국부 중앙값
    }
    
    public Bitmap ApplyAdaptiveThreshold(Bitmap src, int blockSize, int constant, 
                                         AdaptiveMethod method = AdaptiveMethod.Mean)
    {
        Bitmap dst = new Bitmap(src.Width, src.Height);
        int halfSize = blockSize / 2;
        
        // 그레이스케일 변환
        Bitmap gray = ConvertToGrayscale(src);
        
        for (int y = 0; y < gray.Height; y++)
        {
            for (int x = 0; x < gray.Width; x++)
            {
                // 국부 영역 계산
                int sum = 0;
                int count = 0;
                
                for (int j = -halfSize; j <= halfSize; j++)
                {
                    for (int i = -halfSize; i <= halfSize; i++)
                    {
                        int nx = x + i;
                        int ny = y + j;
                        
                        if (nx >= 0 && nx < gray.Width && ny >= 0 && ny < gray.Height)
                        {
                            int pixelValue = gray.GetPixel(nx, ny).R;
                            
                            if (method == AdaptiveMethod.Gaussian)
                            {
                                // 가우시안 가중치 적용
                                double distance = Math.Sqrt(i * i + j * j);
                                double weight = Math.Exp(-distance * distance / (2 * halfSize * halfSize));
                                sum += (int)(pixelValue * weight);
                            }
                            else
                            {
                                sum += pixelValue;
                            }
                            count++;
                        }
                    }
                }
                
                // 국부 임계값 계산
                int localThreshold = sum / count - constant;
                
                // 이진화
                int currentValue = gray.GetPixel(x, y).R;
                int result = (currentValue >= localThreshold) ? 255 : 0;
                
                dst.SetPixel(x, y, Color.FromArgb(result, result, result));
            }
        }
        
        return dst;
    }
    
    private Bitmap ConvertToGrayscale(Bitmap src)
    {
        // 그레이스케일 변환 구현
        // ... (생략)
        return src;
    }
}
```

---

## 연결 성분 레이블링(Connected Component Labeling)

### 연결성 정의와 비교

```
4-연결성 vs 8-연결성:

  4-연결성 (상하좌우)     8-연결성 (상하좌우 + 대각선)
      [ ]                    [ ][ ][ ]
      [X][ ]                 [ ][X][ ]
      [ ]                    [ ][ ][ ]
```

**수학적 정의:**
- 4-연결성: $(x,y)$와 $(x',y')$가 인접할 조건: $|x-x'| + |y-y'| = 1$
- 8-연결성: $(x,y)$와 $(x',y')$가 인접할 조건: $\max(|x-x'|, |y-y'|) = 1$

### 연결성에 따른 레이블링 결과 비교표

| 특징 | 4-연결성 | 8-연결성 |
|------|----------|----------|
| **대각선 연결** | 인정 안함 | 인정함 |
| **객체 수** | 더 많음 | 더 적음 |
| **객체 크기** | 더 작음 | 더 큼 |
| **노이즈 영향** | 덜 민감 | 더 민감 |
| **계산 비용** | 낮음 | 높음 |

### 병합-찾기(Union-Find) 최적화 구현

```csharp
public class OptimizedUnionFind
{
    private int[] parent;
    private int[] rank;
    
    public OptimizedUnionFind(int size)
    {
        parent = new int[size];
        rank = new int[size];
        
        for (int i = 0; i < size; i++)
        {
            parent[i] = i;
            rank[i] = 0;
        }
    }
    
    // 경로 압축(Path Compression)을 적용한 Find
    public int Find(int x)
    {
        // 재귀 대신 반복문 사용 (스택 오버플로 방지)
        while (parent[x] != x)
        {
            parent[x] = parent[parent[x]]; // 경로 압축
            x = parent[x];
        }
        return x;
    }
    
    // 랭크 기반 합병(Union by Rank)
    public void Union(int x, int y)
    {
        int rootX = Find(x);
        int rootY = Find(y);
        
        if (rootX == rootY) return;
        
        // 낮은 랭크 트리를 높은 랭크 트리에 붙임
        if (rank[rootX] < rank[rootY])
        {
            parent[rootX] = rootY;
        }
        else if (rank[rootX] > rank[rootY])
        {
            parent[rootY] = rootX;
        }
        else
        {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
    }
    
    // 모든 레이블 압축(일반화)
    public void CompressAll()
    {
        for (int i = 0; i < parent.Length; i++)
        {
            Find(i);
        }
    }
}
```

### 2패스 레이블링 완전 구현

```csharp
public class ConnectedComponentLabeler
{
    public enum Connectivity { Four, Eight }
    
    public class LabelingResult
    {
        public int[,] Labels { get; set; }
        public int ComponentCount { get; set; }
        public Dictionary<int, List<Point>> Components { get; set; }
        public Dictionary<int, Rectangle> BoundingBoxes { get; set; }
    }
    
    public LabelingResult Label(Bitmap binaryImage, Connectivity connectivity)
    {
        int width = binaryImage.Width;
        int height = binaryImage.Height;
        int[,] labels = new int[height, width];
        
        // 1차 패스: 임시 레이블 할당
        int nextLabel = 1;
        OptimizedUnionFind uf = new OptimizedUnionFind(width * height + 1);
        
        // 첫 번째 행 처리
        for (int x = 0; x < width; x++)
        {
            if (IsForeground(binaryImage, x, 0))
            {
                int left = (x > 0) ? labels[0, x - 1] : 0;
                
                if (left > 0)
                {
                    labels[0, x] = left;
                }
                else
                {
                    labels[0, x] = nextLabel++;
                }
            }
        }
        
        // 나머지 행 처리
        for (int y = 1; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (!IsForeground(binaryImage, x, y))
                    continue;
                
                // 이웃 레이블 확인
                List<int> neighborLabels = new List<int>();
                
                // 왼쪽
                if (x > 0 && labels[y, x - 1] > 0)
                    neighborLabels.Add(labels[y, x - 1]);
                
                // 위쪽
                if (labels[y - 1, x] > 0)
                    neighborLabels.Add(labels[y - 1, x]);
                
                // 8-연결성일 경우 대각선도 확인
                if (connectivity == Connectivity.Eight)
                {
                    if (x > 0 && y > 0 && labels[y - 1, x - 1] > 0)
                        neighborLabels.Add(labels[y - 1, x - 1]);
                    if (x < width - 1 && y > 0 && labels[y - 1, x + 1] > 0)
                        neighborLabels.Add(labels[y - 1, x + 1]);
                }
                
                if (neighborLabels.Count == 0)
                {
                    // 새로운 레이블
                    labels[y, x] = nextLabel++;
                }
                else
                {
                    // 최소 레이블 사용
                    int minLabel = neighborLabels.Min();
                    labels[y, x] = minLabel;
                    
                    // 등가 관계 기록
                    foreach (int neighborLabel in neighborLabels)
                    {
                        if (neighborLabel != minLabel)
                        {
                            uf.Union(minLabel, neighborLabel);
                        }
                    }
                }
            }
        }
        
        // 2차 패스: 레이블 통합
        Dictionary<int, int> labelMap = new Dictionary<int, int>();
        int finalLabel = 1;
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (labels[y, x] > 0)
                {
                    int root = uf.Find(labels[y, x]);
                    
                    if (!labelMap.ContainsKey(root))
                    {
                        labelMap[root] = finalLabel++;
                    }
                    
                    labels[y, x] = labelMap[root];
                }
            }
        }
        
        // 컴포넌트 정보 수집
        return CollectComponentInfo(labels, finalLabel - 1);
    }
    
    private LabelingResult CollectComponentInfo(int[,] labels, int componentCount)
    {
        int height = labels.GetLength(0);
        int width = labels.GetLength(1);
        
        Dictionary<int, List<Point>> components = new Dictionary<int, List<Point>>();
        Dictionary<int, Rectangle> boundingBoxes = new Dictionary<int, Rectangle>();
        
        for (int i = 1; i <= componentCount; i++)
        {
            components[i] = new List<Point>();
            boundingBoxes[i] = new Rectangle(int.MaxValue, int.MaxValue, 0, 0);
        }
        
        // 각 픽셀을 해당 컴포넌트에 추가
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                int label = labels[y, x];
                if (label > 0)
                {
                    Point p = new Point(x, y);
                    components[label].Add(p);
                    
                    // 바운딩 박스 업데이트
                    Rectangle rect = boundingBoxes[label];
                    rect.X = Math.Min(rect.X, x);
                    rect.Y = Math.Min(rect.Y, y);
                    rect.Width = Math.Max(rect.Width, x - rect.X + 1);
                    rect.Height = Math.Max(rect.Height, y - rect.Y + 1);
                    boundingBoxes[label] = rect;
                }
            }
        }
        
        return new LabelingResult
        {
            Labels = labels,
            ComponentCount = componentCount,
            Components = components,
            BoundingBoxes = boundingBoxes
        };
    }
    
    private bool IsForeground(Bitmap image, int x, int y)
    {
        Color c = image.GetPixel(x, y);
        return c.R > 128; // 이진화된 이미지 가정
    }
}
```

### 병렬 레이블링 알고리즘 (BBDT - Block-Based with Decision Tree)

```csharp
public class ParallelLabeler
{
    public int[,] LabelParallel(Bitmap binaryImage)
    {
        int width = binaryImage.Width;
        int height = binaryImage.Height;
        
        // 블록 크기 설정 (캐시 친화적)
        int blockSize = 64;
        int blockX = (width + blockSize - 1) / blockSize;
        int blockY = (height + blockSize - 1) / blockSize;
        
        int[,] globalLabels = new int[height, width];
        
        // 각 블록 독립적으로 레이블링
        Parallel.For(0, blockY * blockX, blockIndex =>
        {
            int by = blockIndex / blockX;
            int bx = blockIndex % blockX;
            
            int startY = by * blockSize;
            int startX = bx * blockSize;
            int endY = Math.Min(startY + blockSize, height);
            int endX = Math.Min(startX + blockSize, width);
            
            // 블록 내부 레이블링
            LabelBlock(binaryImage, globalLabels, startX, endX, startY, endY);
        });
        
        // 블록 간 경계 처리
        MergeBlockBoundaries(globalLabels, width, height, blockSize);
        
        return globalLabels;
    }
    
    private void LabelBlock(Bitmap image, int[,] labels, 
                           int startX, int endX, int startY, int endY)
    {
        // 블록 내부 간단한 레이블링 구현
        // ... (생략)
    }
    
    private void MergeBlockBoundaries(int[,] labels, int width, int height, int blockSize)
    {
        // 블록 경계에서 등가 관계 처리
        // ... (생략)
    }
}
```

---

## 외곽선 추적 (Contour Tracing)

### 외곽선 추적 알고리즘 비교

| 알고리즘 | 방향 | 특징 | 시간 복잡도 |
|----------|------|------|------------|
| **Moore Neighbor** | 8방향 | 단순, 완전 | $O(n \cdot c)$ |
| **Square Tracing** | 4방향 | 빠름, 불완전 | $O(n)$ |
| **Radial Sweep** | 방사형 | 복잡, 정확 | $O(n \log n)$ |
| **Theo Pavlidis** | 혼합 | 효율적, 정확 | $O(n)$ |

### Moore Neighbor 알고리즘 상세

```
Moore 이웃 탐색 순서 (시계방향):
    3  2  1
    4  X  0
    5  6  7
    
시작 방향: 0(오른쪽)
다음 검색 시작: (현재방향 + 6) % 8
```

### 체인 코드(Chain Code) 표현

```
Freeman 체인 코드 (8-방향):
    3  2  1
    4     0
    5  6  7
    
예: 사각형 외곽선 = 0,0,0,0,2,2,2,2,4,4,4,4,6,6,6,6
```

### 고급 외곽선 추적 구현

```csharp
public class ContourTracer
{
    public class Contour
    {
        public List<Point> Points { get; set; }
        public bool IsClosed { get; set; }
        public Point StartPoint { get; set; }
        public List<int> ChainCode { get; set; }
    }
    
    public List<Contour> FindAllContours(Bitmap binaryImage)
    {
        int width = binaryImage.Width;
        int height = binaryImage.Height;
        bool[,] visited = new bool[height, width];
        List<Contour> contours = new List<Contour>();
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (IsForeground(binaryImage, x, y) && !visited[y, x])
                {
                    // 외곽선 시작점 찾기
                    Point startPoint = FindStartPoint(binaryImage, x, y, visited);
                    
                    if (startPoint.X != -1)
                    {
                        Contour contour = TraceContour(binaryImage, startPoint, visited);
                        contours.Add(contour);
                    }
                }
            }
        }
        
        return contours;
    }
    
    private Contour TraceContour(Bitmap image, Point start, bool[,] visited)
    {
        List<Point> points = new List<Point>();
        List<int> chainCode = new List<int>();
        
        // 방향 벡터 (8-방향)
        Point[] directions = 
        {
            new Point(1, 0),   // 0: 동
            new Point(1, -1),  // 1: 북동
            new Point(0, -1),  // 2: 북
            new Point(-1, -1), // 3: 북서
            new Point(-1, 0),  // 4: 서
            new Point(-1, 1),  // 5: 남서
            new Point(0, 1),   // 6: 남
            new Point(1, 1)    // 7: 남동
        };
        
        Point current = start;
        int startDirection = 0; // 오른쪽부터 시작
        
        do
        {
            points.Add(current);
            visited[current.Y, current.X] = true;
            
            bool foundNext = false;
            
            // Moore Neighbor 탐색
            for (int i = 0; i < 8; i++)
            {
                int dirIndex = (startDirection + i) % 8;
                Point dir = directions[dirIndex];
                
                Point next = new Point(current.X + dir.X, current.Y + dir.Y);
                
                // 경계 검사
                if (next.X < 0 || next.X >= image.Width || 
                    next.Y < 0 || next.Y >= image.Height)
                    continue;
                
                if (IsForeground(image, next.X, next.Y))
                {
                    // 체인 코드 추가
                    chainCode.Add(dirIndex);
                    
                    current = next;
                    startDirection = (dirIndex + 5) % 8; // 다음 검색 시작 방향
                    foundNext = true;
                    break;
                }
            }
            
            if (!foundNext)
                break;
            
        } while (current != start && points.Count < image.Width * image.Height);
        
        bool isClosed = (current == start);
        
        return new Contour
        {
            Points = points,
            IsClosed = isClosed,
            StartPoint = start,
            ChainCode = chainCode
        };
    }
    
    private Point FindStartPoint(Bitmap image, int startX, int startY, bool[,] visited)
    {
        // BFS를 사용하여 연결된 영역에서 외곽선 시작점 찾기
        Queue<Point> queue = new Queue<Point>();
        queue.Enqueue(new Point(startX, startY));
        
        while (queue.Count > 0)
        {
            Point p = queue.Dequeue();
            
            if (visited[p.Y, p.X])
                continue;
                
            // 외곽선 조건: 주변에 배경 픽셀이 있는 전경 픽셀
            if (IsForeground(image, p.X, p.Y) && HasBackgroundNeighbor(image, p.X, p.Y))
            {
                return p;
            }
            
            visited[p.Y, p.X] = true;
            
            // 4-방향 이웃 추가
            Point[] neighbors = 
            {
                new Point(p.X + 1, p.Y),
                new Point(p.X - 1, p.Y),
                new Point(p.X, p.Y + 1),
                new Point(p.X, p.Y - 1)
            };
            
            foreach (Point neighbor in neighbors)
            {
                if (neighbor.X >= 0 && neighbor.X < image.Width &&
                    neighbor.Y >= 0 && neighbor.Y < image.Height &&
                    !visited[neighbor.Y, neighbor.X] &&
                    IsForeground(image, neighbor.X, neighbor.Y))
                {
                    queue.Enqueue(neighbor);
                }
            }
        }
        
        return new Point(-1, -1); // 시작점 없음
    }
    
    private bool HasBackgroundNeighbor(Bitmap image, int x, int y)
    {
        // 8-방향 이웃 중 배경이 있는지 확인
        for (int dy = -1; dy <= 1; dy++)
        {
            for (int dx = -1; dx <= 1; dx++)
            {
                if (dx == 0 && dy == 0)
                    continue;
                    
                int nx = x + dx;
                int ny = y + dy;
                
                if (nx >= 0 && nx < image.Width && ny >= 0 && ny < image.Height)
                {
                    if (!IsForeground(image, nx, ny))
                        return true;
                }
                else
                {
                    // 영상 경계는 배경으로 간주
                    return true;
                }
            }
        }
        
        return false;
    }
    
    private bool IsForeground(Bitmap image, int x, int y)
    {
        Color c = image.GetPixel(x, y);
        return c.R > 128;
    }
    
    // 외곽선 특징 추출
    public Dictionary<string, double> ExtractContourFeatures(Contour contour)
    {
        Dictionary<string, double> features = new Dictionary<string, double>();
        
        if (contour.Points.Count < 3)
            return features;
        
        // 둘레(Perimeter)
        double perimeter = 0;
        for (int i = 0; i < contour.Points.Count; i++)
        {
            Point p1 = contour.Points[i];
            Point p2 = contour.Points[(i + 1) % contour.Points.Count];
            perimeter += Math.Sqrt(Math.Pow(p2.X - p1.X, 2) + Math.Pow(p2.Y - p1.Y, 2));
        }
        features["Perimeter"] = perimeter;
        
        // 면적(Area) - 신발끈 공식(Shoelace formula)
        double area = 0;
        for (int i = 0; i < contour.Points.Count; i++)
        {
            Point p1 = contour.Points[i];
            Point p2 = contour.Points[(i + 1) % contour.Points.Count];
            area += p1.X * p2.Y - p2.X * p1.Y;
        }
        area = Math.Abs(area) / 2.0;
        features["Area"] = area;
        
        // 원형도(Circularity)
        if (perimeter > 0)
        {
            double circularity = (4 * Math.PI * area) / (perimeter * perimeter);
            features["Circularity"] = circularity;
        }
        
        // 컴팩트도(Compactness)
        if (area > 0)
        {
            double compactness = perimeter * perimeter / area;
            features["Compactness"] = compactness;
        }
        
        return features;
    }
}
```

---

## 실제 응용 사례

### 1. 문서 이미지 이진화 (Document Binarization)

```csharp
public class DocumentBinarizer
{
    public Bitmap BinarizeDocument(Bitmap scannedDocument)
    {
        // 1. 조명 보정
        Bitmap illuminated = CorrectIllumination(scannedDocument);
        
        // 2. Sauvola 적응형 이진화 (문서에 특화)
        Bitmap binary = ApplySauvolaThreshold(illuminated);
        
        // 3. 모폴로지 후처리
        binary = RemoveNoise(binary);
        
        return binary;
    }
    
    private Bitmap ApplySauvolaThreshold(Bitmap src, int windowSize = 15, double k = 0.2)
    {
        // Sauvola 알고리즘: T = m * (1 + k * (s/R - 1))
        // m: 국부 평균, s: 국부 표준편차, R: 표준편차 최대값(128)
        // ... 구현 생략
        return src;
    }
}
```

### 2. 의료 영상 세포 분할 (Cell Segmentation)

```csharp
public class CellSegmenter
{
    public Bitmap SegmentCells(Bitmap microscopeImage)
    {
        // 1. 전처리: 가우시안 블러로 노이즈 제거
        Bitmap smoothed = ApplyGaussianBlur(microscopeImage, 1.5);
        
        // 2. Otsu 이진화
        OtsuThresholder otsu = new OtsuThresholder();
        Bitmap binary = otsu.ApplyOtsuThreshold(smoothed);
        
        // 3. 워터셰드 알고리즘 적용 (과분할 방지)
        binary = ApplyWatershed(binary);
        
        // 4. 연결 성분 분석
        ConnectedComponentLabeler labeler = new ConnectedComponentLabeler();
        var result = labeler.Label(binary, ConnectedComponentLabeler.Connectivity.Eight);
        
        // 5. 크기 필터링 (너무 작은 영역 제거)
        return FilterBySize(result, minSize: 50, maxSize: 5000);
    }
}
```

### 3. 산업 검사 (Industrial Inspection)

```csharp
public class DefectDetector
{
    public List<Rectangle> DetectDefects(Bitmap productImage, Bitmap templateImage)
    {
        // 1. 템플릿 매칭으로 위치 보정
        Point offset = TemplateMatch(productImage, templateImage);
        
        // 2. 차영상 계산
        Bitmap difference = CalculateDifference(productImage, templateImage, offset);
        
        // 3. 적응형 이진화로 결함 영역 추출
        AdaptiveThresholder thresholder = new AdaptiveThresholder();
        Bitmap defectsBinary = thresholder.ApplyAdaptiveThreshold(difference, 20, 10);
        
        // 4. 연결 성분 레이블링
        ConnectedComponentLabeler labeler = new ConnectedComponentLabeler();
        var result = labeler.Label(defectsBinary, ConnectedComponentLabeler.Connectivity.Four);
        
        // 5. 결함 후보 필터링
        return FilterDefects(result.BoundingBoxes.Values.ToList());
    }
}
```

---

## 성능 최적화 기법

### 1. 메모리 접근 패턴 최적화

```csharp
public class CacheOptimizedProcessor
{
    // 캐시 친화적인 메모리 접근
    public unsafe void ProcessTiled(Bitmap image)
    {
        // 타일 단위 처리 (64x64 블록)
        int tileSize = 64;
        int width = image.Width;
        int height = image.Height;
        
        for (int tileY = 0; tileY < height; tileY += tileSize)
        {
            for (int tileX = 0; tileX < width; tileX += tileX += tileSize)
            {
                int endY = Math.Min(tileY + tileSize, height);
                int endX = Math.Min(tileX + tileSize, width);
                
                // 타일 내부 처리
                ProcessTile(image, tileX, endX, tileY, endY);
            }
        }
    }
}
```

### 2. SIMD(단일 명령 다중 데이터) 활용

```csharp
// System.Numerics 네임스페이스 사용
public unsafe void ProcessVectorized(byte[] imageData)
{
    // 16바이트(128비트) 단위 처리
    int vectorSize = Vector<byte>.Count;
    
    fixed (byte* ptr = imageData)
    {
        for (int i = 0; i < imageData.Length; i += vectorSize)
        {
            // 벡터 로드
            Vector<byte> vector = new Vector<byte>(ptr + i);
            
            // 벡터 연산 (예: 임계값 비교)
            Vector<byte> threshold = new Vector<byte>(128);
            Vector<byte> result = Vector.GreaterThan(vector, threshold);
            
            // 결과 저장
            result.CopyTo(imageData, i);
        }
    }
}
```

### 3. GPU 가속 (C#에서의 접근)

```csharp
// ILGPU 또는 CUDAfy.Net 사용 예시
public class GpuAcceleratedThreshold
{
    /*
    [Cudafy]
    public static void ThresholdKernel(GThread thread, byte[] input, byte[] output, int threshold)
    {
        int idx = thread.blockIdx.x * thread.blockDim.x + thread.threadIdx.x;
        
        if (idx < input.Length)
        {
            output[idx] = (input[idx] >= threshold) ? (byte)255 : (byte)0;
        }
    }
    */
}
```

---

## 정리

### 영상 분할 알고리즘 선택 가이드

| 시나리오 | 추천 알고리즘 | 이유 |
|----------|--------------|------|
| **고속 문서 처리** | Otsu 이진화 | 빠르고 문서에 효과적 |
| **조명 변화 환경** | 적응형 이진화 | 국부 조명 보정 |
| **정확한 객체 분리** | 연결 성분 레이블링 | 객체 단위 분석 가능 |
| **형상 분석 필요** | 외곽선 추적 | 경계 정보 보존 |
| **복잡한 배경** | 워터셰드/Mean-shift | 영역 기반 분할 |
| **최고 정확도** | 딥러닝 분할(U-Net) | 데이터 기반 최적화 |

### 향후 발전 방향

1. **딥러닝 기반 분할**: U-Net, Mask R-CNN, DeepLab 등의 신경망으로 전통적 알고리즘 대체
2. **실시간 분할**: 모바일 및 임베디드 시스템을 위한 경량화 알고리즘
3. **3D 영상 분할**: 의료 CT/MRI, 자율주행 LiDAR 데이터 처리
4. **시멘틱 분할**: 픽셀 단위 클래스 분류로 객체 의미 이해
5. **인스턴스 분할**: 동일 클래스 내 개별 객체 구분

영상 분할은 컴퓨터 비전의 핵심 기술로, 알고리즘 선택은 응용 분야의 요구사항(속도, 정확도, 자원 제약)에 따라 결정되어야 한다. 전통적인 방법은 여전히 많은 실시간 응용에서 유효하며, 딥러닝 기반 방법은 높은 정확도가 요구되는 복잡한 작업에 적합하다.