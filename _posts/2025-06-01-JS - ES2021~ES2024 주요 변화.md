---
layout: post
title: JavaScript - ES2021~ES2024 주요 변화
date: 2025-06-01 21:20:23 +0900
category: JavaScript
---
# 🚀 ES2021~ES2024 주요 변화 정리

---

## 🗓️ 목차

1. [ES2021 (ES12)](#es2021-es12)
2. [ES2022 (ES13)](#es2022-es13)
3. [ES2023 (ES14)](#es2023-es14)
4. [ES2024 (ES15)](#es2024-es15)
5. [마무리 및 참고 링크](#마무리-및-참고-링크)

---

## 📘 ES2021 (ES12)

### ✅ 1. String.prototype.replaceAll

```js
'hello world'.replaceAll('l', '_'); // "he__o wor_d"
```

- 기존 `replace()`는 첫 번째 항목만 교체
- `replaceAll()`은 **모든 일치 항목**을 한 번에 변경

---

### ✅ 2. Promise.any()

> 첫 번째 **성공한 Promise만 반환** (나머지는 무시)

```js
const p1 = Promise.reject("fail");
const p2 = Promise.resolve("success");

Promise.any([p1, p2]).then(console.log); // "success"
```

- 모두 실패하면 `AggregateError` 발생

---

### ✅ 3. WeakRef & FinalizationRegistry

> **가비지 컬렉션 관찰 및 약한 참조 처리** 가능

```js
const obj = { data: 123 };
const ref = new WeakRef(obj);

console.log(ref.deref()); // obj가 살아있다면 반환
```

- `FinalizationRegistry`는 객체 소멸 시 콜백 실행

---

### ✅ 4. 논리 할당 연산자 (Logical Assignment Operators)

```js
a ||= b;   // a가 falsy면 b를 대입
a &&= b;   // a가 truthy면 b를 대입
a ??= b;   // a가 null/undefined면 b를 대입
```

---

## 📙 ES2022 (ES13)

### ✅ 1. class 필드 선언 및 접근 제어자

```js
class Person {
  name = 'Kim';       // public 필드
  #age = 20;          // private 필드

  getAge() {
    return this.#age;
  }
}
```

- `#` 표기법으로 **private 필드** 정의 가능
- constructor 없이도 필드 초기화 가능

---

### ✅ 2. top-level await

```js
const data = await fetch('/api/data').then(r => r.json());
```

- 모듈 스코프에서도 `await` 사용 가능 (단, `type="module"` 필요)

---

### ✅ 3. Object.hasOwn

```js
Object.hasOwn({ a: 1 }, 'a'); // true
```

- 기존 `hasOwnProperty()`보다 안전하고 간결한 대체

---

### ✅ 4. Error cause

```js
try {
  throw new Error("DB 오류", { cause: "접속 실패" });
} catch (e) {
  console.log(e.cause); // "접속 실패"
}
```

- 오류의 원인을 명시적으로 추적 가능

---

## 📕 ES2023 (ES14)

### ✅ 1. Array findLast / findLastIndex

```js
const arr = [1, 2, 3, 4, 5];

arr.findLast(v => v % 2 === 1);       // 5
arr.findLastIndex(v => v % 2 === 1);  // 4
```

- 뒤에서부터 조건 탐색

---

### ✅ 2. Array grouping: toSorted, toSpliced, with

```js
const arr = [3, 1, 2];
arr.toSorted(); // [1, 2, 3] - 원본 유지

const original = [1, 2, 3];
original.with(1, 9); // [1, 9, 3]
```

- **불변성 유지하는 메서드**들 추가
- 기존 `sort()`, `splice()`는 원본을 수정 → 새 메서드는 **복사본 반환**

---

### ✅ 3. Symbol as WeakMap keys (불가)

- 논의되었으나 **채택되지 않음**

---

### ✅ 4. `#private` 필드에서 `in` 연산자

```js
class Foo {
  #secret = 42;
}
const f = new Foo();
console.log(#secret in f); // true
```

- `#필드 in 객체`로 **private 필드 존재 여부 확인 가능**

---

## 📗 ES2024 (ES15)

> TC39 Stage 4로 확정된 기능

### ✅ 1. Set Methods 확장

```js
const a = new Set([1, 2, 3]);
const b = new Set([3, 4, 5]);

a.union(b);        // Set {1, 2, 3, 4, 5}
a.intersection(b); // Set {3}
a.difference(b);   // Set {1, 2}
```

- 기존엔 유틸 함수로만 구현 가능했으나, **Set 자체에 메서드 추가**

---

### ✅ 2. Array.prototype.toSorted / toReversed (정식 도입)

- ES2023에서 비공식 → ES2024에서 표준화

```js
const arr = [3, 2, 1];
arr.toReversed(); // [1, 2, 3]
```

---

### ✅ 3. JSON.parse()에 reviver에서 `this` 바인딩

```js
JSON.parse('{"a":1}', function (key, value) {
  console.log(this); // 상위 객체를 가리킴
  return value;
});
```

- `reviver` 함수에서 `this`가 **상위 객체를 참조**하게 됨

---

### ✅ 4. Async Context Tracking (실험적)

- `AsyncLocalStorage`처럼 비동기 흐름에서 **컨텍스트를 자동 유지**
- 고급 로깅, 트랜잭션, 추적 등에 활용

---

## 🧾 마무리 및 참고 링크

| 버전 | 주요 기능 |
|------|-----------|
| ES2021 | `replaceAll`, `Promise.any`, `WeakRef`, 논리 할당 연산자 |
| ES2022 | 클래스 필드, `top-level await`, `hasOwn`, 오류 cause |
| ES2023 | `findLast`, `toSorted`, `with`, private `in` |
| ES2024 | Set 메서드 확장, `toReversed`, JSON `this` 바인딩 |

---

### 🔗 참고 문서

- [TC39 Proposal List](https://github.com/tc39/proposals)
- [MDN ECMAScript 업데이트](https://developer.mozilla.org/ko/docs/Web/JavaScript/New_in_JavaScript)
- [2ality 블로그 (ES 업데이트 설명)](https://2ality.com/)