---
layout: post
title: JavaScript - ES2021~ES2024 주요 변화
date: 2025-06-01 21:20:23 +0900
category: JavaScript
---
# ES2021 → ES2025 주요 변화 정리(확장판)

## ES2021(ES12)

### `String.prototype.replaceAll`

```js
'hello world'.replaceAll('l', '_'); // "he__o wor_d"
```
- `replace()`는 첫 일치만 바꾸고, `replaceAll()`은 **모든 일치**를 교체합니다.
- 정규식을 쓰면 전역 플래그(`/g`)가 필요 없습니다.

### `Promise.any` — **첫 성공**만 반환

```js
const p1 = Promise.reject('fail');
const p2 = Promise.resolve('ok');
const p3 = new Promise(r => setTimeout(() => r('late ok'), 10));

const result = await Promise.any([p1, p2, p3]);
console.log(result); // "ok"
```
- 전부 거부되면 `AggregateError`가 발생합니다.
- **써먹기**: 다중 엔드포인트/캐시/미러 중 가장 먼저 성공하는 응답을 채택.

### `WeakRef`, `FinalizationRegistry` — 약한 참조/소멸 콜백

```js
const registry = new FinalizationRegistry(token => {
  console.log('GC finalized:', token);
});

let obj = { id: 1 };
const ref = new WeakRef(obj);
registry.register(obj, obj.id);

obj = null;          // GC 대상
// GC 시 registry 콜백이 호출될 수 있음
```
- **주의**: GC 타이밍은 비결정적입니다. **로직 의존 금지**(진단/캐시 힌트 용도).

### 논리 할당 연산자

```js
a ||= b;  // a가 falsy면 b로
a &&= b;  // a가 truthy면 b로
a ??= b;  // a가 null/undefined면 b로
```
- 옵셔널 체이닝·널 병합과 조합하여 깔끔한 기본값/가드 패턴 구성.

> 더 읽기(개념/레퍼런스): `Promise.any`, WeakRef, 논리 할당은 MDN에 잘 정리되어 있습니다.

---

## ES2022(ES13)

### 필드

```js
class Person {
  name = 'Kim';   // public
  #age = 20;      // private

  getAge() { return this.#age; }
}
```
- 프라이빗 필드는 **언어 차원 은닉**(리플렉션/프로퍼티 열거로 접근 불가).

### **Top-level `await`**(ESM)

```js
// index.mjs  (또는 <script type="module">)
const data = await (await fetch('/api')).json();
console.log(data);
```
- 모듈 스코프 최상위에서 `await` 사용 가능.
- **번들러/로더**가 모듈 의존성 그래프를 async로 평가합니다.

### `Object.hasOwn` — 안전한 own-prop 체크

```js
Object.hasOwn({ a: 1 }, 'a');  // true
```

### `Error` cause

```js
try {
  tryConnect();
} catch (e) {
  throw new Error('DB 연결 실패', { cause: e });
}
```
- 장애 **원인 체인**을 보존해 로그/알람의 가독성을 개선.

---

## ES2023(ES14)

### `findLast` / `findLastIndex`

```js
const arr = [1,2,3,4,5];
arr.findLast(v => v % 2 === 1);       // 5
arr.findLastIndex(v => v % 2 === 1);  // 4
```
- 뒤에서 앞으로 조건 탐색. **최근 데이터 우선** 검색에 간편.

### *Change-Array-by-Copy* 계열 (불변 메서드)

```js
const xs = [3,1,2];

xs.toSorted();     // [1,2,3], 원본 유지
xs.toReversed();   // [2,1,3] 같은 컨셉 (정식 도입은 ES2024 문단 참고)
[1,2,3].with(1,9)  // [1,9,3]
[1,2,3].toSpliced(1,1,7); // [1,7,3]
```
- 기존 `sort/splice/reverse`는 **원본 변경**, 새 메서드는 **복사본 반환** → 리액티브/불변 상태 관리에 유리.

### 프라이빗 필드 존재 검사

```js
class Foo { #secret = 42; }
const f = new Foo();
console.log(#secret in f);  // true
```

---

## ES2024(ES15)

> ES2024에는 개발자 체감도가 높은 **병렬/정규식/배열/버퍼** 관련 제안들이 다수 Stage 4(표준 반영)로 승격되었습니다. 종합 요약은 아래를 참고.

### 한눈 요약

- **Well-Formed Unicode Strings**(문자열 정규화/깨짐 방지)
- **Array Grouping**: `Object.groupBy`, `Map.groupBy`
- **Resizable/ growable SharedArrayBuffer**
- **Atomics.waitAsync**
- **RegExp `/v` flag**(세분화된 문자셋/클래스)
- **ArrayBuffer 전송/이전(transfer)**,
  **`Promise.withResolvers`**(프라미스 외부 resolve/reject 얻기)

> 위 항목들은 ES2024 Stage 4 모음 페이지에서 확인 가능합니다. 각 항목은 런타임/브라우저에 따라 도입 시점이 다릅니다.

#### 예시: `Object.groupBy`, `Map.groupBy`

```js
const users = [
  { name: 'Kim', team: 'A' },
  { name: 'Lee', team: 'B' },
  { name: 'Park', team: 'A' },
];

// 객체 그룹핑
const byTeam = Object.groupBy(users, u => u.team);
// { A: [{...},{...}], B: [{...}] }

// 키-보존 맵 그룹핑
const byMap = Map.groupBy(users, u => u.team);
// Map(2) { 'A' => [...], 'B' => [...] }
```

#### 예시: RegExp `/v` 플래그(새 문자셋 문법)

```js
// 유니코드 클래스 세분화, 프로퍼티 클래스 개선 등
const re = /\p{Script=Hangul}/v;
console.log(re.test('한')); // true
```
- `/v`는 유니코드 속성/문자셋 정의를 **더 일관되고 강력하게** 만듭니다.
  (세부 문법은 각 엔진 문서/MDN 참고)

---

## ES2025(ES16, **가장 최근 정식판**)

> 2025년판 ECMA-262(16th edition)가 공식 공개되었습니다. 핵심 기능은 아래 링크와 요약을 참고하세요.

### `Set` 메서드 대거 추가

**합집합/교집합/차집합/대칭차** 등 수학 연산을 표준 메서드로 지원합니다.
```js
const A = new Set([1,2,3]);
const B = new Set([3,4,5]);

A.union(B);         // Set {1,2,3,4,5}
A.intersection(B);  // Set {3}
A.difference(B);    // Set {1,2}
A.symmetricDifference(B); // Set {1,2,4,5}

A.isSubsetOf(B);     // false
A.isSupersetOf(B);   // false
A.isDisjointFrom(B); // false
```
- 더 이상 유틸 함수 없이 **표준 API**로 집합 연산 가독성/성능/타이핑 향상.
- ES2025 기능 개요 페이지에도 포함.

### 정규식 확장
#### **중복 이름 캡처 그룹 허용**

```js
const re = /(?<id>\d+)-(?<id>\d+)/;
const m = re.exec('12-34');
console.log(m.groups.id); // "34" (마지막 매치가 노출)
```
- 도구/엔진 간 **이식성 향상**(다른 구현들과의 정합성).
- ES2025 하이라이트 항목 중 하나.

#### **RegExp Modifiers**

- 정규식 **수준에서 플래그/옵션을 보다 유연하게** 지정하는 문법(런타임별 제공 방식에 유의).
- ES2025 항목 요약 참고.

#### `RegExp.escape`

```js
// 사용자 입력을 안전하게 리터럴로 매칭
const safe = RegExp.escape('(a+b)*c?');
const re2 = new RegExp(safe);
console.log(re2.test('(a+b)*c?')); // true
```
- 입력 이스케이프 유틸을 표준화. (임의 문자 → 리터럴)

### **Import Attributes & JSON Modules**

```js
// 모듈 가져오기에 메타데이터 부여
import data from './config.json' with { type: 'json' };

console.log(data.title); // JSON을 모듈처럼
```
- **JSON을 네이티브 모듈**로 다루고, import에 **속성(attribute)**을 부가하여
  **로더/번들러가 의도를 명확히** 해석하도록 합니다.

### **Iterator Helpers(동기)** — 반복자 유틸 표준화

```js
// 가독성 높은 파이프라이닝
const sum = [1,2,3,4]
  .values()                // 이터레이터
  .map(x => x * 2)
  .filter(x => x % 3 === 0)
  .reduce((a,b) => a + b, 0);

console.log(sum); // 6 (2*3만 누적)
```
- `map/filter/take/drop/flatMap/reduce/toArray` 등 **이터레이터 체이닝**을 표준으로.
- ES2025 항목 요약에 *Sync Iterator helpers*로 수록.

### `Promise.try`

```js
// 동기/비동기를 동일한 표면적에서 래핑
const p = Promise.try(() => possiblyThrowsOrReturns());
p.then(console.log).catch(console.error);
```
- 콜백이 **즉시 예외를 던져도** Promise 거부로 변환 → **일관된 async 흐름**.

### **Float16**(number/TypedArray 계열)

```js
// 예시: Float16Array (엔진 지원 확인)
const buf = new ArrayBuffer(10 * 2);
const f16 = new Float16Array(buf);
f16[0] = 1.5;
// 메모리/대역 최적화가 필요한 그래픽/ML 숫자 처리에 유용
```
- 16-bit 부동소수 지원으로 **메모리 밀도** 향상. (런타임 지원 상태 확인)

---

## 마이그레이션 팁 & 체크리스트

### 불변 메서드로 사이드이펙트 차단

- `toSorted / toSpliced / with / toReversed`로 **원본 보존**.
- 리액티브 상태관리(Redux 등)에서 구조적 공유와 함께 성능 이점.

### 정규식 정리

- `/v` 플래그(ES2024), **중복 캡처명**(ES2025), `RegExp.escape`를 도입하면
  - 국제화(Unicode)와 **사용자 입력 이스케이프** 문제가 표준 API 안에서 해결됩니다.

### 집합 연산 → 표준 `Set` 메서드로 치환

- 유틸·Lodash 의존 코드를 `A.union(B)` 등으로 치환해 **의도/성능/타이핑** 개선.

### 모듈 로딩

- JSON을 import하는 로더 규칙/번들러 옵션을 **Import Attributes** 기반으로 명확화.
- Node/브라우저의 호환표 및 번들러(예: Vite/Webpack) 버전 확인 필수.

### 이터레이터 유틸 표준으로 정리

- 커스텀 이터레이터 유틸을 *Iterator Helpers*로 통일해 **코드 일관성** 확보.

---

## 브라우저/런타임 호환성 메모

- **최신 기능**은 브라우저/Node의 **도입 버전**을 확인하세요(바벨·SWC/코어-JS 폴리필 전략 병행).
- 서버/엣지(Cloudflare Workers, Deno, Bun 등) 런타임은 **지원 선행**인 경우가 많습니다.
- TLA(Top-level await), Import Attributes, JSON Modules은 **번들러/로더 설정**을 동반합니다.

---

## 참고 링크

- ES2024 Stage 4(정리): *A close look at ECMAScript 2024* (항목별 요약)
- ES2025 정식 공개(ECMA 공식 뉴스): **ECMAScript® 2025 Language Specification published**
- ES2025 기능 하이라이트(요약 페이지): **ES2025: What's new**(Set 메서드, JSON 모듈, RegExp 확장, Iterator helpers 등)
- 개별 기능/배경 설명(추가 읽기): Dr. Axel의 ECMAScript 시리즈(문법 변화 해설)
- MDN JavaScript 가이드(메모리/WeakRef 등): 개념·API 레퍼런스

---

## 부록: 빠른 스니펫 모음

### Set 연산 치환 가이드

```js
// before (유틸)
const union = (A, B) => new Set([...A, ...B]);

// after (표준)
A.union(B);

// 교집합/차집합/대칭차, 부분집합/상위집합 체크도 표준 메서드로 대체
```

### 안전한 사용자 입력 정규식화

```js
const input = '(sale)+? [today]';
const re = new RegExp(RegExp.escape(input)); // ES2025
console.log(re.source); // \(sale\)\+\?\ $$today$$
```

### Iterator Helpers로 느슨한 파이프라인

```js
const evensSquared = [1,2,3,4,5,6]
  .values()
  .filter(n => n % 2 === 0)
  .map(n => n*n)
  .toArray(); // [4,16,36]
```

### Import Attributes + JSON 모듈

```js
// 브라우저/번들러 지원 필요
import conf from './app.config.json' with { type: 'json' };
```

---

### 마무리

- **ES2021→ES2023**: DX(개발자 경험) 품질을 끌어올린 문법/불변 메서드/오류 원인 체인
- **ES2024**: 정규식·버퍼·그룹핑·원자적 동기화 등 **플랫폼 성능·표현력 강화**
- **ES2025**: 집합/정규식/모듈/이터레이터/프라미스/수치형까지 **언어 표준 API의 빈 구멍을 본격 보강**

새 기능을 **즉시 전면 도입**하기보다는, **폴리필·번들 설정·호환성**을 체크하고
**테스트(예: Jest/Vitest)와 릴리즈 플래그**로 점진적으로 확장하는 전략을 권장합니다.
