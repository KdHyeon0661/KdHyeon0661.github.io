---
layout: post
title: 알고리즘 - DFS와 BFS
date: 2025-01-29 20:20:23 +0900
category: 알고리즘
---
# DFS & BFS 완전 정리

## 기본 개념 요약

### DFS(깊이 우선)

- 현재 정점에서 **깊게** 내려가며 방문. **재귀/스택**으로 구현.
- 모든 경로 탐색, 백트래킹, 사이클 검출, 위상 정렬(DFS 스택) 등에 적합.

### BFS(너비 우선)

- 시작점으로부터 **가까운 순서**(레벨 순)로 방문. **큐**로 구현.
- **무가중 그래프 최단거리**에 적합. 멀티소스(여러 시작점) 확장 쉬움.

### 시간·공간 복잡도

- 그래프를 인접 리스트로 표현하면, DFS/BFS 모두
  $$
  O(V+E)
  $$
- 인접 행렬은 간선 조회가 \(O(1)\)이지만 전체 탐색이 \(O(V^2)\).

---

## 그래프 표현과 방문 관리

### 인접 리스트 vs 인접 행렬

- **인접 리스트**: 희소 그래프에 유리, 메모리 \(O(V+E)\), 순회 \(O(V+E)\). **실전 기본**
- **인접 행렬**: 조밀 그래프에 단순, 메모리 \(O(V^2)\), 순회 \(O(V^2)\)

### 방문 관리(visited)와 부모(parent)

- 방문 마킹: 재방문/무한루프 방지.
- **경로 복원**: BFS는 `parent[next]=cur` 저장 후, 도착점에서 역추적.

```python
def restore_path(parent, s, t):
    path = []
    cur = t
    while cur != -1:
        path.append(cur)
        cur = parent[cur]
    path.reverse()
    return path if path and path[0] == s else []
```

---

## DFS — 템플릿과 응용

### 재귀 DFS(정점 번호가 1..N, 오름차순 방문)

```python
import sys
sys.setrecursionlimit(1_000_000)
input = sys.stdin.readline

def dfs(u):
    visited[u] = True
    # 처리 (예: print(u, end=' '))
    for v in graph[u]:
        if not visited[v]:
            dfs(v)
```

- **정렬 1회**: 출력 순서 요구가 있으면, 입력 후 `for g in graph: g.sort()`.

### 스택 반복 DFS(재귀 제한 환경)

```python
def dfs_iter(start):
    stack = [start]
    while stack:
        u = stack.pop()
        if visited[u]:
            continue
        visited[u] = True
        # 처리
        # 오름차순 방문을 원하면 역순으로 push
        for v in reversed(graph[u]):
            if not visited[v]:
                stack.append(v)
```

### 연결 요소 세기(무방향)

```python
def count_components(n, graph):
    visited = [False]*(n+1)
    def dfs(u):
        visited[u] = True
        for v in graph[u]:
            if not visited[v]:
                dfs(v)
    cnt = 0
    for u in range(1, n+1):
        if not visited[u]:
            cnt += 1
            dfs(u)
    return cnt
```

### 사이클 판별

- **무방향**: DFS 중, 이웃이 방문됨 && 그 이웃이 부모가 아니면 사이클.
- **방향**: 방문색(0/1/2)로 **역방향 간선** 발견 시 사이클.

```python
# 방향 그래프 사이클

def has_cycle_directed(graph, n):
    color = [0]*(n+1)  # 0:unseen, 1:visiting, 2:done
    def dfs(u):
        color[u] = 1
        for v in graph[u]:
            if color[v] == 0 and dfs(v): return True
            if color[v] == 1: return True
        color[u] = 2
        return False
    return any(dfs(u) for u in range(1, n+1) if color[u]==0)
```

### 위상 정렬(DFS 후행 스택)

- DAG에서 DFS 종료 순서를 거꾸로 모으면 위상순서.

```python
def topo_sort_dfs(graph, n):
    sys.setrecursionlimit(1_000_000)
    visited = [False]*(n+1)
    order = []
    def dfs(u):
        visited[u] = True
        for v in graph[u]:
            if not visited[v]:
                dfs(v)
        order.append(u)
    for u in range(1, n+1):
        if not visited[u]:
            dfs(u)
    order.reverse()
    return order
```

---

## BFS — 템플릿과 최단거리

### 단일 시작점 최단거리(무가중)

```python
from collections import deque

def bfs_shortest(n, graph, s):
    dist = [-1]*(n+1)
    parent = [-1]*(n+1)
    q = deque([s])
    dist[s] = 0
    while q:
        u = q.popleft()
        for v in graph[u]:
            if dist[v] == -1:
                dist[v] = dist[u] + 1
                parent[v] = u
                q.append(v)
    return dist, parent
```

- 무가중(간선비용=1) 그래프에서 **BFS = 최단거리**.

### 다중 시작점 BFS

- 여러 시작점에서 동시 확산. 거리 초기값 0으로 넣고 시작.

```python
def multi_source_bfs(starts, n, graph):
    from collections import deque
    INF = 10**18
    dist = [INF]*(n+1)
    q = deque()
    for s in starts:
        dist[s] = 0
        q.append(s)
    while q:
        u = q.popleft()
        for v in graph[u]:
            if dist[v] == INF:
                dist[v] = dist[u] + 1
                q.append(v)
    return dist
```

### 0-1 BFS(간선 가중 0 또는 1)

- 비용 0은 **덱 앞**, 비용 1은 **덱 뒤**에 넣는다. 다익스트라보다 빠름.

```python
from collections import deque

def zero_one_bfs(n, graph01, s):
    # graph01[u] = [(v, w)] with w in {0,1}
    INF = 10**18
    dist = [INF]*(n+1)
    dist[s] = 0
    dq = deque([s])
    while dq:
        u = dq.popleft()
        for v, w in graph01[u]:
            nd = dist[u] + w
            if nd < dist[v]:
                dist[v] = nd
                if w == 0:
                    dq.appendleft(v)
                else:
                    dq.append(v)
    return dist
```

- 일반 가중치(양수)는 **다익스트라**를 사용.

---

## 격자(2D/3D) 탐색 — 패턴과 실전

### 2D 격자 BFS 템플릿

```python
from collections import deque

def bfs_grid(grid):
    n, m = len(grid), len(grid[0])
    dist = [[-1]*m for _ in range(n)]
    q = deque()
    # 시작점들 push, dist[...] = 0
    dx = [-1,1,0,0]
    dy = [0,0,-1,1]
    while q:
        x, y = q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 <= nx < n and 0 <= ny < m and dist[nx][ny] == -1:
                # 통과 판단(벽/조건)
                dist[nx][ny] = dist[x][y] + 1
                q.append((nx, ny))
    return dist
```

### 3D 격자 BFS 템플릿

```python
dx = [-1,1,0,0,0,0]
dy = [0,0,-1,1,0,0]
dz = [0,0,0,0,-1,1]
```

- 핵심: **경계 체크와 통과 조건**만 정확히.

---

## 백준 실전 문제 묶음

### — DFS와 BFS(기본 정렬 + 방문 순서)

(원고 코드와 동일 구조, 반복 DFS 버전만 추가)

```python
import sys
from collections import deque
input = sys.stdin.readline

n, m, v = map(int, input().split())
graph = [[] for _ in range(n+1)]
for _ in range(m):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)
for g in graph:
    g.sort()

visited = [False]*(n+1)

def dfs(u):
    visited[u] = True
    print(u, end=' ')
    for w in graph[u]:
        if not visited[w]:
            dfs(w)

def bfs(s):
    q = deque([s])
    visited = [False]*(n+1)
    visited[s] = True
    while q:
        u = q.popleft()
        print(u, end=' ')
        for w in graph[u]:
            if not visited[w]:
                visited[w] = True
                q.append(w)

dfs(v); print()
bfs(v)
```

### — 미로 탐색(BFS 최단거리)

(원고와 동일, I/O 최적화)

```python
import sys
from collections import deque
input = sys.stdin.readline

n, m = map(int, input().split())
maze = [list(map(int, input().strip())) for _ in range(n)]

dist = [[-1]*m for _ in range(n)]
dx = [-1,1,0,0]
dy = [0,0,-1,1]

q = deque([(0,0)])
dist[0][0] = 0

while q:
    x, y = q.popleft()
    for i in range(4):
        nx, ny = x+dx[i], y+dy[i]
        if 0 <= nx < n and 0 <= ny < m:
            if maze[nx][ny] == 1 and dist[nx][ny] == -1:
                dist[nx][ny] = dist[x][y] + 1
                q.append((nx, ny))

# 칸 수 요구면 +1

print(dist[n-1][m-1] + 1)
```

### — 토마토(3D BFS)

(원고 코드와 동일 아이디어, 다중 시작점)

```python
import sys
from collections import deque
input = sys.stdin.readline

m, n, h = map(int, input().split())
box = [[list(map(int, input().split())) for _ in range(n)] for _ in range(h)]

dx = [-1,1,0,0,0,0]
dy = [0,0,-1,1,0,0]
dz = [0,0,0,0,-1,1]

q = deque()
for z in range(h):
    for x in range(n):
        for y in range(m):
            if box[z][x][y] == 1:
                q.append((z,x,y))

while q:
    z,x,y = q.popleft()
    for i in range(6):
        nz, nx, ny = z+dz[i], x+dx[i], y+dy[i]
        if 0 <= nz < h and 0 <= nx < n and 0 <= ny < m:
            if box[nz][nx][ny] == 0:
                box[nz][nx][ny] = box[z][x][y] + 1
                q.append((nz,nx,ny))

ans = 0
for z in range(h):
    for x in range(n):
        for y in range(m):
            if box[z][x][y] == 0:
                print(-1); sys.exit(0)
            ans = max(ans, box[z][x][y])
print(ans - 1)
```

### — 연결 요소의 개수(무방향 그래프)

```python
import sys
sys.setrecursionlimit(1_000_000)
input = sys.stdin.readline

n, m = map(int, input().split())
g = [[] for _ in range(n+1)]
for _ in range(m):
    a,b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

vis = [False]*(n+1)

def dfs(u):
    vis[u] = True
    for v in g[u]:
        if not vis[v]:
            dfs(v)

cnt = 0
for u in range(1, n+1):
    if not vis[u]:
        cnt += 1
        dfs(u)
print(cnt)
```

### — 바이러스(DFS/BFS 동일)

```python
from collections import deque
import sys
input = sys.stdin.readline

n = int(input())
m = int(input())
g = [[] for _ in range(n+1)]
for _ in range(m):
    a,b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

vis = [False]*(n+1)
q = deque([1])
vis[1] = True
ans = 0
while q:
    u = q.popleft()
    for v in g[u]:
        if not vis[v]:
            vis[v] = True
            ans += 1
            q.append(v)
print(ans)
```

### — 숨바꼭질(BFS on 상태공간: 위치 그래프)

```python
from collections import deque
import sys
input = sys.stdin.readline

N, K = map(int, input().split())
MAX = 100000
dist = [-1]*(MAX+1)
q = deque([N])
dist[N] = 0
while q:
    x = q.popleft()
    if x == K:
        print(dist[x]); break
    for nx in (x-1, x+1, x*2):
        if 0 <= nx <= MAX and dist[nx] == -1:
            dist[nx] = dist[x] + 1
            q.append(nx)
```

### — 유기농 배추(격자 DFS/BFS, 연결 요소)

```python
import sys
sys.setrecursionlimit(1_000_000)
input = sys.stdin.readline

t = int(input())
dx = [-1,1,0,0]
dy = [0,0,-1,1]

for _ in range(t):
    m,n,k = map(int, input().split())
    grid = [[0]*m for _ in range(n)]
    for _ in range(k):
        x,y = map(int, input().split())
        grid[y][x] = 1
    vis = [[False]*m for _ in range(n)]

    def dfs(x,y):
        vis[x][y] = True
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 <= nx < n and 0 <= ny < m:
                if grid[nx][ny] and not vis[nx][ny]:
                    dfs(nx,ny)

    cnt = 0
    for i in range(n):
        for j in range(m):
            if grid[i][j] and not vis[i][j]:
                cnt += 1
                dfs(i,j)
    print(cnt)
```

### — ABCDE(깊이 5 경로 존재 여부: DFS with depth)

```python
import sys
sys.setrecursionlimit(1_000_000)
input = sys.stdin.readline
n, m = map(int, input().split())
g = [[] for _ in range(n)]
for _ in range(m):
    a,b = map(int, input().split())
    g[a].append(b); g[b].append(a)

vis = [False]*n
found = False

def dfs(u, depth):
    global found
    if depth == 4:
        found = True; return
    vis[u] = True
    for v in g[u]:
        if not vis[v]:
            dfs(v, depth+1)
            if found: return
    vis[u] = False

for i in range(n):
    dfs(i, 0)
    if found: break
print(1 if found else 0)
```

### — 토마토(2D BFS, 멀티소스)

- 7569의 2D 버전. 아이디어 동일(큐 초기화에 익은 토마토 모두).

### — 다리 만들기(섬 라벨링 + BFS 확장)

- 1단계: DFS/BFS로 각 섬에 라벨 부여.
- 2단계: 각 섬의 **가장자리에서 동시에** BFS 확장 → 다른 섬 도달 거리 최소.

### — 줄 세우기(위상 정렬: BFS Kahn)

```python
from collections import deque
import sys
input = sys.stdin.readline
n, m = map(int, input().split())
g = [[] for _ in range(n+1)]
ind = [0]*(n+1)
for _ in range(m):
    a,b = map(int, input().split())
    g[a].append(b)
    ind[b] += 1

q = deque(i for i in range(1, n+1) if ind[i]==0)
order = []
while q:
    u = q.popleft()
    order.append(u)
    for v in g[u]:
        ind[v] -= 1
        if ind[v] == 0:
            q.append(v)
print(*order)
```

---

## 상태가 있는 BFS(격자 확장)

### 벽을 한 번 부술 수 있는 BFS(상태 차원 추가)

- `visited[x][y][broken]`로 상태를 분리.

```python
from collections import deque

def bfs_break_wall(grid):
    n, m = len(grid), len(grid[0])
    INF = 10**9
    dist = [[[INF]*2 for _ in range(m)] for __ in range(n)]
    dq = deque()
    dist[0][0][0] = 0
    dq.append((0,0,0))
    dx,dy = [-1,1,0,0],[0,0,-1,1]
    while dq:
        x,y,b = dq.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 <= nx < n and 0 <= ny < m:
                w = grid[nx][ny]
                if w == 0 and dist[nx][ny][b] == INF:
                    dist[nx][ny][b] = dist[x][y][b] + 1
                    dq.append((nx,ny,b))
                if w == 1 and b == 0 and dist[nx][ny][1] == INF:
                    dist[nx][ny][1] = dist[x][y][0] + 1
                    dq.append((nx,ny,1))
    return min(dist[n-1][m-1])
```

### 열쇠/문(비트마스크로 키 상태)

- `visited[x][y][keymask]` — 키 획득 시 `keymask |= (1<<k)`.

---

## DFS/BFS 선택 가이드

| 목적 | 추천 |
|---|---|
| 무가중 최단거리 | BFS |
| 퍼짐/전염/기간 계산 | BFS(멀티소스) |
| 모든 경로/조합/제약 탐색 | DFS + 백트래킹 |
| DAG 위상 정렬 | DFS(후행 스택) / BFS(Kahn) |
| 사이클 판정 | DFS(색/부모) |
| 0-1 가중 | 0-1 BFS |
| 양의 가중 | 다익스트라 |

---

## 실전 최적화 팁

1) **입출력**: `input = sys.stdin.readline`
2) **정렬 1회**: 방문 순서 요구 시 간선 리스트 정렬
3) **재귀 한도/반복 전환**: 깊은 DFS는 스택 버전 고려
4) **메모리**: 방문배열 `bool`/`bytearray`/비트마스크로 절약
5) **중복방문 차단**: BFS는 `visited`를 **enqueue 직후** 마킹(중복 큐잉 방지)
6) **경계/통과조건**: 격자 문제는 **범위/벽/방문** 3가지 체크 순서 습관화

---

## 수학·정리

- 인접 리스트에서 DFS/BFS 총 비용:
  $$
  O(V+E)
  $$
- 무가중 최단거리(레벨):
  $$
  \text{dist}[v] = \text{레이어 번호} = \min \text{엣지 수}
  $$

---

## 디버깅 체크리스트

- 방문 직전/직후 마킹 시점 혼동(특히 BFS)
- 격자 경계 오탈자( \(0 \le x < N,\, 0 \le y < M\) )
- 3D 인덱스 순서(z,x,y) 혼동
- 정렬 누락으로 출력/채점 순서 불일치(BOJ 1260 등)
- 경로 복원 시 parent 초기값/단절 처리
- 멀티소스 초기화 누락(dist/visited)

---

## 마무리

- **DFS**는 완전탐색·백트래킹·사이클·위상정렬에, **BFS**는 무가중 최단거리·퍼짐 모델링에 강하다.
- 격자·그래프 공통 패턴과 방문·경계·통과 조건의 3요소를 표준화하면 실전에서 실수를 크게 줄일 수 있다.
- 상태가 붙는 문제(벽, 키, 비용 0/1)는 **차원을 늘리는 BFS**나 **0-1 BFS**로 자연스럽게 확장하라.
- 입력 크기가 커질수록 **I/O 최적화, 정렬 1회, 방문 시점, 메모리 관리**가 합격선을 가른다.
