---
layout: post
title: Avalonia - 다국어(i18n) 지원 및 리소스 로딩 구조
date: 2025-02-01 21:20:23 +0900
category: Avalonia
---
# Avalonia 다국어(i18n) 지원 및 리소스 로딩 구조

## 0. 무엇을 만들 것인가

- 표준 `.resx` 기반 다국어 시스템(권장)
- ViewModel/XAML에서 **타입 안전**하게 문자열 로드
- **실시간 언어 전환**(언어 토글 → UI 전체 재바인딩)
- 문화권별 표시(날짜/숫자/통화/단위)와 플러럴(복수형) 처리
- 선택적으로 **JSON 동적 리소스**(외부 관리/핫리로드)
- DI/테스트 가능한 설계

---

## 1. 디렉터리/파일 구조(권장안)

```
MyApp/
├── Resources/
│   ├── Strings.resx
│   ├── Strings.ko.resx
│   ├── Strings.en.resx
│   └── Strings.ja.resx            // 필요 시 추가
├── I18n/
│   ├── ILocalizer.cs
│   ├── ResxLocalizer.cs
│   ├── JsonLocalizer.cs           // 선택
│   ├── LocalizationManager.cs     // 언어 전환 이벤트/옵저버블 허브
│   ├── LocExtension.cs            // XAML 전용 마크업 확장
│   ├── LocalizeBinding.cs         // 바인딩용 헬퍼(선택)
│   └── CultureFormatters.cs       // 날짜/숫자 포맷 도우미
├── Services/
│   └── SettingsService.cs         // 사용 언어 저장/복원
├── ViewModels/
│   ├── MainViewModel.cs
│   └── SettingsViewModel.cs       // 언어 토글/저장 버튼
├── Views/
│   ├── MainView.axaml
│   └── SettingsView.axaml
└── App.axaml / App.axaml.cs
```

> `.resx`는 빌드시 **Strings.resources.dll** 형태의 위성 어셈블리로 문화권별 폴더(bin/…/ko/…)에 생성된다.

---

## 2. 리소스(.resx) 정의와 생성 규칙

### 2.1 기본 리소스(`Strings.resx`)
| Name       | Value           |
|------------|------------------|
| App_Title  | Avalonia 예제     |
| Hello      | 안녕하세요         |
| ItemsCount | 항목 수: {0}개    |

### 2.2 영어(`Strings.en.resx`)
| Name       | Value            |
|------------|-------------------|
| App_Title  | Avalonia Sample   |
| Hello      | Hello             |
| ItemsCount | Items: {0}        |

> `{0}`, `{1}` 등은 `string.Format` 자리표시자. **문화권 서식**이 필요하면 후술할 `CultureInfo`를 함께 사용한다.

---

## 3. 로컬라이저 인터페이스와 구현

### 3.1 ILocalizer (DI/테스트 친화)
```csharp
// I18n/ILocalizer.cs
using System.Globalization;

namespace MyApp.I18n;

public interface ILocalizer
{
    CultureInfo CurrentCulture { get; }
    string this[string key] { get; }
    string Format(string key, params object[] args);

    // 캡션/툴팁/메시지 등 용도별 네임스페이스를 분리하고 싶다면 필요에 맞게 확장:
    // string Caption(string key);
}
```

### 3.2 ResxLocalizer (권장 기본 구현)
```csharp
// I18n/ResxLocalizer.cs
using System;
using System.Globalization;
using System.Resources;

namespace MyApp.I18n;

public sealed class ResxLocalizer : ILocalizer
{
    private readonly ResourceManager _rm;
    private CultureInfo _culture;

    public ResxLocalizer(string baseName, Type anchorType, CultureInfo initial)
    {
        _rm = new ResourceManager(baseName, anchorType.Assembly);
        _culture = initial;
    }

    public CultureInfo CurrentCulture => _culture;

    public void SetCulture(CultureInfo culture) => _culture = culture;

    public string this[string key]
        => _rm.GetString(key, _culture) ?? $"!!{key}!!";

    public string Format(string key, params object[] args)
    {
        var fmt = this[key];
        return string.Format(_culture, fmt, args);
    }
}
```

> `baseName` 예: `"MyApp.Resources.Strings"`, `anchorType`는 같은 어셈블리에 있는 아무 타입.

---

## 4. 런타임 전환/브로드캐스트: LocalizationManager

언어가 바뀌면 **모든 구독자(ViewModel, MarkupExtension)가 재평가**되어야 한다. 옵저버블/이벤트 허브로 관리한다.

```csharp
// I18n/LocalizationManager.cs
using System;
using System.Globalization;

namespace MyApp.I18n;

public sealed class LocalizationManager
{
    public event EventHandler? LanguageChanged;

    public ILocalizer Localizer { get; }
    public LocalizationManager(ILocalizer localizer) => Localizer = localizer;

    public CultureInfo CurrentCulture => Localizer.CurrentCulture;

    public void SetCulture(CultureInfo culture)
    {
        if (!Equals(culture, Localizer.CurrentCulture))
        {
            (Localizer as ResxLocalizer)?.SetCulture(culture);
            System.Threading.Thread.CurrentThread.CurrentCulture = culture;
            System.Threading.Thread.CurrentThread.CurrentUICulture = culture;

            LanguageChanged?.Invoke(this, EventArgs.Empty);
        }
    }
}
```

> UI 스레드 외 작업에서 포맷팅이 다르게 나올 수 있으므로, 백그라운드 작업이 Thread.CurrentCulture를 따르도록 주의(필요 시 `CultureInfo.CurrentCulture` 캡처).

---

## 5. App 초기화/DI 등록

```csharp
// App.axaml.cs
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml;
using Microsoft.Extensions.DependencyInjection;
using System.Globalization;
using MyApp.I18n;
using MyApp.Services;

namespace MyApp;

public partial class App : Application
{
    public static ServiceProvider Services = default!;

    public override void Initialize() => AvaloniaXamlLoader.Load(this);

    public override void OnFrameworkInitializationCompleted()
    {
        var sc = new ServiceCollection();

        // SettingsService: 사용자 설정(언어) 저장/로드
        sc.AddSingleton<SettingsService>();

        // Localizer + Manager
        var initialCulture = LoadCultureFromSettings(sc); // ko-KR / en-US 등
        var localizer = new ResxLocalizer("MyApp.Resources.Strings", typeof(App), initialCulture);
        var manager = new LocalizationManager(localizer);
        sc.AddSingleton<ILocalizer>(localizer);
        sc.AddSingleton(manager);

        // ViewModels, 기타 서비스 등록...
        // sc.AddTransient<MainViewModel>(); sc.AddTransient<SettingsViewModel>(); ...

        Services = sc.BuildServiceProvider();

        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            desktop.MainWindow = new MainWindow
            {
                DataContext = Services.GetRequiredService<MainViewModel>()
            };
        }

        base.OnFrameworkInitializationCompleted();
    }

    private CultureInfo LoadCultureFromSettings(ServiceCollection sc)
    {
        var tmp = new SettingsService(); // 임시. 실제로는 DI 빌드 뒤 GetRequiredService로 불러도 됨.
        var cultureName = tmp.LoadLanguageOrDefault("ko-KR"); // 사용자 설정 로드
        return new CultureInfo(cultureName);
    }
}
```

---

## 6. ViewModel에서 사용 — 실시간 갱신

```csharp
// ViewModels/MainViewModel.cs
using MyApp.I18n;
using ReactiveUI;
using System;

public sealed class MainViewModel : ReactiveObject
{
    private readonly LocalizationManager _loc;

    public MainViewModel(LocalizationManager loc)
    {
        _loc = loc;
        _loc.LanguageChanged += (_, __) =>
        {
            this.RaisePropertyChanged(nameof(AppTitle));
            this.RaisePropertyChanged(nameof(Greeting));
            this.RaisePropertyChanged(nameof(Summary));
        };
    }

    public string AppTitle => _loc.Localizer["App_Title"];
    public string Greeting => _loc.Localizer["Hello"];

    private int _count = 5;
    public int Count
    {
        get => _count;
        set { this.RaiseAndSetIfChanged(ref _count, value); this.RaisePropertyChanged(nameof(Summary)); }
    }

    public string Summary => _loc.Localizer.Format("ItemsCount", Count);
}
```

### XAML
```xml
<!-- Views/MainView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:vm="clr-namespace:MyApp.ViewModels"
             x:Class="MyApp.Views.MainView">
  <UserControl.DataContext>
    <vm:MainViewModel />
  </UserControl.DataContext>

  <StackPanel Margin="20" Spacing="8">
    <TextBlock Text="{Binding AppTitle}" FontSize="20"/>
    <TextBlock Text="{Binding Greeting}" />
    <NumericUpDown Value="{Binding Count}" Minimum="0"/>
    <TextBlock Text="{Binding Summary}" FontWeight="Bold"/>
  </StackPanel>
</UserControl>
```

> 핵심: `LanguageChanged` 시 필요한 속성들에 대해 `RaisePropertyChanged` 호출.

---

## 7. 언어 전환 UI + 설정 저장

```csharp
// ViewModels/SettingsViewModel.cs
using MyApp.I18n;
using MyApp.Services;
using ReactiveUI;
using System;
using System.Globalization;
using System.Reactive;

public sealed class SettingsViewModel : ReactiveObject
{
    private readonly LocalizationManager _loc;
    private readonly SettingsService _settings;

    public SettingsViewModel(LocalizationManager loc, SettingsService settings)
    {
        _loc = loc; _settings = settings;

        SwitchToKoreanCommand = ReactiveCommand.Create(() => Switch("ko-KR"));
        SwitchToEnglishCommand = ReactiveCommand.Create(() => Switch("en-US"));
        SwitchToJapaneseCommand = ReactiveCommand.Create(() => Switch("ja-JP"));
    }

    public ReactiveCommand<Unit, Unit> SwitchToKoreanCommand { get; }
    public ReactiveCommand<Unit, Unit> SwitchToEnglishCommand { get; }
    public ReactiveCommand<Unit, Unit> SwitchToJapaneseCommand { get; }

    private void Switch(string culture)
    {
        _loc.SetCulture(new CultureInfo(culture));
        _settings.SaveLanguage(culture);
    }
}
```

```xml
<!-- Views/SettingsView.axaml -->
<StackPanel Spacing="10" Margin="20">
  <Button Content="한국어" Command="{Binding SwitchToKoreanCommand}"/>
  <Button Content="English" Command="{Binding SwitchToEnglishCommand}"/>
  <Button Content="日本語" Command="{Binding SwitchToJapaneseCommand}"/>
</StackPanel>
```

---

## 8. XAML에서 직접 키를 쓰고 싶다 — MarkupExtension

```csharp
// I18n/LocExtension.cs
using Avalonia.Markup.Xaml;
using MyApp.I18n;
using System;

namespace MyApp.I18n;

public sealed class LocExtension : MarkupExtension
{
    public string Key { get; set; }
    public LocExtension(string key) => Key = key;

    public override object ProvideValue(IServiceProvider serviceProvider)
    {
        // DI 접근: App.Services 사용 (간편)
        var lm = App.Services.GetService(typeof(LocalizationManager)) as LocalizationManager;
        if (lm == null) return $"!!{Key}!!";

        // 실시간 갱신: 확장만으로는 한계. 바인딩/Attached Behavior로 키워줄 수 있음.
        return lm.Localizer[Key];
    }
}
```

```xml
<!-- Views/MainView.axaml, 고정 문자열에 적합 -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:i18n="clr-namespace:MyApp.I18n">
  <TextBlock Text="{i18n:Loc App_Title}"/>
</UserControl>
```

> MarkupExtension은 **초기 평가 시점에만** 적용. **실시간 전환**을 원하면 ViewModel 경유 또는 `Binding + LanguageChanged 트리거` 전략을 권장.

---

## 9. 문화권 포맷 도우미(날짜/숫자/통화 등)

```csharp
// I18n/CultureFormatters.cs
using System;
using System.Globalization;

namespace MyApp.I18n;

public static class CultureFormatters
{
    public static string Date(DateTimeOffset dt, CultureInfo culture, string? format = null)
        => format == null ? dt.ToString(culture) : dt.ToString(format, culture);

    public static string Number(double value, CultureInfo culture, string? format = "N")
        => value.ToString(format, culture);

    public static string Currency(decimal value, CultureInfo culture, string? format = "C")
        => value.ToString(format, culture);
}
```

ViewModel 예:
```csharp
public string NowShort => CultureFormatters.Date(DateTimeOffset.Now, _loc.CurrentCulture, "yyyy-MM-dd");
public string Salary => CultureFormatters.Currency(1234567.89m, _loc.CurrentCulture);
public string Ratio  => CultureFormatters.Number(0.12345, _loc.CurrentCulture, "P2"); // 12.35%
```

---

## 10. 플러럴(복수형) 간단 처리

영어/프랑스어 등은 복수형 규칙이 다르다. 간단 규칙은 **키 분기**로 처리:

```
Strings.en.resx
- Items_Zero = No items
- Items_One  = 1 item
- Items_Many = {0} items
```

```csharp
public string ItemsText(int count)
{
    var loc = _loc.Localizer;
    return count switch
    {
        0 => loc["Items_Zero"],
        1 => loc["Items_One"],
        _ => loc.Format("Items_Many", count)
    };
}
```

> 고급(카테고리별 복잡 규칙)은 ICU MessageFormat 라이브러리/커스텀 파서 도입을 고려.

---

## 11. JSON 기반(선택) — 동적 로딩/핫리로드

### 11.1 JSON 스키마
```json
{
  "App_Title": "Avalonia Sample",
  "Hello": "Hello",
  "ItemsCount": "Items: {0}"
}
```

### 11.2 JsonLocalizer
```csharp
// I18n/JsonLocalizer.cs
using System.Collections.Concurrent;
using System.Globalization;
using System.Text.Json;

namespace MyApp.I18n;

public sealed class JsonLocalizer : ILocalizer, IDisposable
{
    private readonly string _basePath;
    private CultureInfo _culture;
    private ConcurrentDictionary<string, string> _dict = new();

    private FileSystemWatcher? _watcher;

    public JsonLocalizer(string basePath, CultureInfo initial, bool watch = true)
    {
        _basePath = basePath;
        _culture  = initial;
        Load();
        if (watch) StartWatcher();
    }

    public CultureInfo CurrentCulture => _culture;

    public void SetCulture(CultureInfo culture)
    {
        _culture = culture;
        Load();
    }

    public string this[string key] => _dict.TryGetValue(key, out var v) ? v : $"!!{key}!!";

    public string Format(string key, params object[] args)
        => string.Format(_culture, this[key], args);

    private void Load()
    {
        var path = System.IO.Path.Combine(_basePath, $"{_culture.TwoLetterISOLanguageName}.json");
        if (!File.Exists(path))
        {
            // fallback: neutral → en.json
            path = System.IO.Path.Combine(_basePath, "en.json");
        }

        var json = File.ReadAllText(path);
        var map = JsonSerializer.Deserialize<Dictionary<string, string>>(json) ?? new();
        _dict = new ConcurrentDictionary<string, string>(map);
    }

    private void StartWatcher()
    {
        _watcher = new FileSystemWatcher(_basePath, "*.json")
        {
            NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.Size | NotifyFilters.Attributes | NotifyFilters.FileName
        };
        _watcher.Changed += (_, __) => Load();
        _watcher.Created += (_, __) => Load();
        _watcher.Renamed += (_, __) => Load();
        _watcher.EnableRaisingEvents = true;
    }

    public void Dispose() => _watcher?.Dispose();
}
```

> JSON은 **번역 핫리로드**가 장점. 다만 .resx보다 로딩/성능/배포 일관성은 떨어질 수 있다.

---

## 12. ValueConverter로 Enum/상태 → 문자열

```csharp
// I18n/EnumToLocalizedStringConverter.cs
using Avalonia.Data.Converters;
using System;
using System.Globalization;

namespace MyApp.I18n;

public sealed class EnumToLocalizedStringConverter : IValueConverter
{
    public string Prefix { get; set; } = "Enum_"; // 리소스 키 접두사

    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is Enum e)
        {
            var key = $"{Prefix}{e.GetType().Name}_{e}";
            var loc = (ILocalizer)App.Services.GetService(typeof(ILocalizer))!;
            return loc[key];
        }
        return value?.ToString();
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture) 
        => throw new NotSupportedException();
}
```

XAML:
```xml
<UserControl.Resources>
  <i18n:EnumToLocalizedStringConverter x:Key="EnumLoc" Prefix="Enum_"/>
</UserControl.Resources>

<TextBlock Text="{Binding Status, Converter={StaticResource EnumLoc}}"/>
```

리소스:
```
Enum_Status_Ready = 준비됨
Enum_Status_Running = 실행 중
Enum_Status_Done = 완료
```

---

## 13. Error/Validation 메시지 현지화

- `ReactiveUI.Validation`/`INotifyDataErrorInfo`로 생성되는 오류 메시지를 키로 매핑:
  - 검증 로직 내에서 `loc["Err_Required"]`, `loc.Format("Err_Range", min, max)` 사용.
- 뷰에서는 `ToolTip`/스타일에서 그대로 출력.

---

## 14. Navigation/Tab/다중 ViewModel과의 결합

- **LocalizationManager**는 싱글턴.
- 각 ViewModel은 `LanguageChanged`에 구독하고 **자신이 노출하는 모든 문자열 속성**에서 `RaisePropertyChanged`.
- Tab/Navigation 구조에서도 동일 패턴: 현재 뷰만 갱신해도 되지만, 전체 전파가 더 단순.

---

## 15. 테스트 전략

### 15.1 ResxLocalizer 단위 테스트
```csharp
[Fact]
public void ResxLocalizer_Should_Return_Fallback_When_Key_Missing()
{
    var loc = new ResxLocalizer("MyApp.Resources.Strings", typeof(App), new CultureInfo("en-US"));
    loc["NotExist"].Should().Be("!!NotExist!!");
}
```

### 15.2 언어 전환 이벤트 테스트
```csharp
[Fact]
public void Manager_Should_Raise_LanguageChanged()
{
    var loc = new ResxLocalizer("MyApp.Resources.Strings", typeof(App), new CultureInfo("ko-KR"));
    var mgr = new LocalizationManager(loc);

    bool raised = false;
    mgr.LanguageChanged += (_, __) => raised = true;

    mgr.SetCulture(new CultureInfo("en-US"));
    raised.Should().BeTrue();
}
```

### 15.3 ViewModel 반응 테스트
```csharp
[Fact]
public void ViewModel_Should_Recompute_Properties_On_Language_Change()
{
    var loc = new ResxLocalizer("MyApp.Resources.Strings", typeof(App), new CultureInfo("ko-KR"));
    var mgr = new LocalizationManager(loc);
    var vm = new MainViewModel(mgr);

    var oldTitle = vm.AppTitle;
    mgr.SetCulture(new CultureInfo("en-US"));
    vm.AppTitle.Should().NotBe(oldTitle);
}
```

---

## 16. 위성 어셈블리/배포 체크리스트

- **SingleFile Publish** 시 위성 어셈블리가 누락되지 않도록 `PublishTrimmed` 환경에서 리소스 보존 옵션 확인.
- Self-contained/Framework-dependent 모두 **문화를 포함**해야 한다. 런타임 폴더 구조:
  ```
  MyApp.exe
  en/
    MyApp.resources.dll
  ko/
    MyApp.resources.dll
  ```
- CI/CD에서 특정 문화권만 포함하려면 `SatelliteResourceLanguages` MSBuild 속성 활용.

---

## 17. 성능/캐시

- `ResourceManager`는 내부적으로 캐시가 있으므로, 별도 캐시는 대부분 불필요.
- 빈번한 `string.Format`은 가벼우나, 대량 포맷팅 시 **문자열 빌더**/배치 포맷 고려.
- JSON 로컬라이저는 파일 감시/파싱 비용 → 프로덕션에선 감시 비활성 또는 배치 갱신 권장.

---

## 18. 실전 종합 예시

### ViewModel(일부)
```csharp
public sealed class DashboardViewModel : ReactiveObject
{
    private readonly LocalizationManager _loc;

    public DashboardViewModel(LocalizationManager loc)
    {
        _loc = loc;
        _loc.LanguageChanged += (_, __) =>
        {
            this.RaisePropertyChanged(nameof(Header));
            this.RaisePropertyChanged(nameof(KpiText));
            this.RaisePropertyChanged(nameof(NowText));
        };
    }

    public string Header => _loc.Localizer["Dashboard_Header"];

    private int _kpi = 1234;
    public int KPI
    {
        get => _kpi;
        set { this.RaiseAndSetIfChanged(ref _kpi, value); this.RaisePropertyChanged(nameof(KpiText)); }
    }

    public string KpiText => _loc.Localizer.Format("KPI_Value", KPI);

    public string NowText => CultureFormatters.Date(DateTimeOffset.Now, _loc.CurrentCulture, "f");
}
```

### 리소스
```
Strings.resx
- Dashboard_Header = 대시보드
- KPI_Value = 현재 KPI: {0}
Strings.en.resx
- Dashboard_Header = Dashboard
- KPI_Value = Current KPI: {0}
```

### XAML
```xml
<StackPanel Spacing="8">
  <TextBlock Text="{Binding Header}" FontSize="22"/>
  <TextBlock Text="{Binding KpiText}" />
  <TextBlock Text="{Binding NowText}" />
</StackPanel>
```

---

## 19. 자주 겪는 문제와 해결

| 문제 | 원인 | 해결 |
|------|------|------|
| 문자열이 영어로만 보임 | 위성 어셈블리 미포함 | 빌드 아웃풋에 `ko/MyApp.resources.dll` 존재 여부 확인 |
| 런타임 전환이 안 됨 | MarkupExtension은 초기만 평가 | ViewModel 경유, 또는 `LanguageChanged` 구독 후 속성 Raise |
| 날짜/숫자 포맷이 문화권과 다름 | `Thread.CurrentCulture` 미설정 | 전환 시 `CurrentCulture/UICulture` 동시 설정 |
| JSON 리소스가 바뀌어도 반영 안 됨 | 핫리로드/감시 미구현 | `FileSystemWatcher` 도입 또는 리로드 API 호출 |
| Enum 텍스트 현지화 어려움 | 키 매핑 누락 | Converter로 타입명+값을 키 합성 |

---

## 20. 결론 및 선택 가이드

- **규모/정적 번역**: `.resx` + `ResourceManager`(권장, 표준, 성능/배포 안정)
- **외부 번역/핫리로드**: `JsonLocalizer`(선택), 작업 중 번역 갱신 용이
- **실시간 전환**: `LocalizationManager.LanguageChanged` + ViewModel `RaisePropertyChanged`
- **문화권 포맷**: `CultureInfo` 기반 포맷 도우미 일원화
- **테스트/DI**: `ILocalizer`/`LocalizationManager` 분리, 단위 테스트 용이

---

## 부록 A) SettingsService (언어 저장/복원)
```csharp
// Services/SettingsService.cs
using System.Text.Json;

namespace MyApp.Services;

public sealed class SettingsService
{
    private const string FilePath = "settings.json";
    public void SaveLanguage(string culture) 
        => Save(new Settings { Language = culture });

    public string LoadLanguageOrDefault(string fallback)
    {
        var s = Load();
        return string.IsNullOrWhiteSpace(s.Language) ? fallback : s.Language!;
    }

    private static void Save(Settings s)
    {
        var json = JsonSerializer.Serialize(s, new JsonSerializerOptions { WriteIndented = true });
        File.WriteAllText(FilePath, json);
    }

    private static Settings Load()
    {
        if (!File.Exists(FilePath)) return new Settings();
        return JsonSerializer.Deserialize<Settings>(File.ReadAllText(FilePath)) ?? new Settings();
    }

    private sealed class Settings { public string? Language { get; set; } }
}
```

---

## 부록 B) 간단 바인딩 헬퍼(선택)

동적 키 변경이 필요한 곳(예: DataTemplate 내부)에서 쓸 수 있는, 키-바인딩 객체:

```csharp
// I18n/LocalizeBinding.cs
using MyApp.I18n;
using ReactiveUI;

public sealed class LocalizeBinding : ReactiveObject
{
    private readonly LocalizationManager _lm;

    public LocalizeBinding(LocalizationManager lm, string key)
    {
        _lm = lm;
        Key = key;
        _lm.LanguageChanged += (_, __) => this.RaisePropertyChanged(nameof(Text));
    }

    public string Key { get; }
    public string Text => _lm.Localizer[Key];
}
```

XAML(리소스로 만들어 두고 필요한 곳에서 Binding):
```xml
<UserControl.Resources>
  <vm:LocalizeBinding x:Key="LocHeader" Key="Dashboard_Header"/>
</UserControl.Resources>

<TextBlock Text="{Binding Text, Source={StaticResource LocHeader}}"/>
```

---

## 부록 C) 다국어 DatePicker/NumberPicker 포맷

- Avalonia 기본 템플릿은 **OS/문화권** 설정을 따름.
- 표시 문자열은 `StringFormat`과 `CultureInfo`를 함께 사용하거나, ViewModel로 포맷된 문자열 노출.

```xml
<TextBlock Text="{Binding SomeDate, StringFormat='{}{0:yyyy-MM-dd}'}"/>
```

문화권에 따라 다르게:
```csharp
public string SomeDateText => SomeDate.ToString("d", _loc.CurrentCulture);
```