---
layout: post
title: ì´ì‚°ìˆ˜í•™ - ì‹ ì¥ íŠ¸ë¦¬ì™€ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬
date: 2025-07-03 19:20:23 +0900
category: ì´ì‚°ìˆ˜í•™
---
# ì‹ ì¥ íŠ¸ë¦¬ì™€ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (Spanning Trees & Minimum Spanning Trees)

## 0. í•œëˆˆ ê°œìš”

- **ì‹ ì¥ íŠ¸ë¦¬(ST)**: ì—°ê²° ë¬´ë°©í–¥ ê·¸ë˜í”„ $$G=(V,E)$$ì—ì„œ ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ê³  ì‚¬ì´í´ì´ ì—†ëŠ” ë¶€ë¶„ê·¸ë˜í”„. ê°„ì„  ìˆ˜ëŠ” í•­ìƒ $$|V|-1$$.
- **ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST)**: ê°€ì¤‘ì¹˜ $$w:E\to\mathbb{R}$$ì—ì„œ ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ë©´ì„œ **ì´ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì†Œ**ì¸ ì‹ ì¥ íŠ¸ë¦¬.
- **ëŒ€í‘œ ì•Œê³ ë¦¬ì¦˜**:
  - **Kruskal**: ê°„ì„ ì„ ê°€ë²¼ìš´ ìˆœìœ¼ë¡œ ì •ë ¬ + **Union-Find(ì„œë¡œì†Œ ì§‘í•©)** â†’ $$O(E\log E)$$
  - **Prim**: í•˜ë‚˜ì˜ ì •ì ì—ì„œ ì‹œì‘í•´ **ìµœì†Œ ë‹¨ì ˆ ê°„ì„ **ì„ í™•ì¥(ìš°ì„ ìˆœìœ„ í) â†’ $$O(E\log V)$$
  - **BorÅ¯vka**: ê° ì»´í¬ë„ŒíŠ¸ì—ì„œ ê°€ì¥ ì‹¼ ê°„ì„  ì„ íƒ(ë³‘ë ¬/ëŒ€ê·œëª¨ ìœ ë¦¬).
- **í•µì‹¬ ì •ë¦¬**:
  - **Cut Property**: ì„ì˜ì˜ ì»·ì„ ê°€ë¡œì§€ë¥´ëŠ” **ìµœì†Œ ê°€ì¤‘ì¹˜ ê°„ì„ **ì€ ì–´ë–¤ MSTì—ë„ í¬í•¨.
  - **Cycle Property**: ì„ì˜ì˜ ì‚¬ì´í´ì—ì„œ **ìµœëŒ€ ê°€ì¤‘ì¹˜ ê°„ì„ **ì€ ì–´ë–¤ MSTì—ë„ í¬í•¨ë  ìˆ˜ ì—†ìŒ.
- **ê³ ê¸‰**:
  - **ìœ ì¼ì„±**: ëª¨ë“  ê°„ì„  ê°€ì¤‘ì¹˜ê°€ **ëª¨ë‘ ì„œë¡œ ë‹¤ë¥´ë©´** MSTëŠ” **ìœ ì¼**.
  - **ê°œìˆ˜**: ë¬´ê°€ì¤‘ ê·¸ë˜í”„ì˜ **ì‹ ì¥ íŠ¸ë¦¬ ê°œìˆ˜**ëŠ” **Matrix-Tree ì •ë¦¬**ë¡œ ë¼í”Œë¼ì‹œì•ˆ ì†Œí–‰ë ¬ì˜ í–‰ë ¬ì‹ìœ¼ë¡œ ê³„ì‚°.
  - **2-Best MST**: MSTì— ì—†ëŠ” ê°„ì„ ì„ í•œ ê°œ ì¶”ê°€í•´ ìƒê¸°ëŠ” ì‚¬ì´í´ì—ì„œ **ìµœëŒ€ ê°„ì„ ì„ ëŒ€ì²´**.
  - **Directed MST**(Arborescence): **Edmonds/Chuâ€“Liu** ì•Œê³ ë¦¬ì¦˜.

---

## 1. ì‹ ì¥ íŠ¸ë¦¬ (Spanning Tree)

### 1.1 ì •ì˜
- ì—°ê²° ë¬´ë°©í–¥ ê·¸ë˜í”„ $$G=(V,E)$$ì˜ **ì‹ ì¥ íŠ¸ë¦¬** $$T=(V,E_T)$$ëŠ”
  $$E_T\subseteq E,\; |E_T|=|V|-1,\; T \text{ê°€ íŠ¸ë¦¬(ë¬´ì‚¬ì´í´/ì—°ê²°)}.$$

### 1.2 ê¸°ë³¸ ì„±ì§ˆ
- íŠ¸ë¦¬ì˜ ê°„ì„  ìˆ˜: $$|E_T|=|V|-1$$.
- **ì—°ê²° + ë¬´ì‚¬ì´í´ â‡” íŠ¸ë¦¬** (ì–´ëŠ í•œ ì¡°ê±´ê³¼ $$|V|-1$$ë„ ë™ì¹˜ì ).
- í•˜ë‚˜ì˜ ê·¸ë˜í”„ì—ëŠ” **ì—¬ëŸ¬ ì‹ ì¥ íŠ¸ë¦¬**ê°€ ì¡´ì¬í•  ìˆ˜ ìˆìŒ.

### 1.3 ì˜ˆ(ë¬´ê°€ì¤‘)
```
A â€” B
|  /
C
```
ê°€ëŠ¥ ì‹ ì¥ íŠ¸ë¦¬(ê°„ì„  2ê°œ ì„ íƒ):
- Aâ€”B, Bâ€”C / Aâ€”C, Câ€”B / Aâ€”B, Aâ€”C

---

## 2. ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (MST)

### 2.1 ì •ì˜
- ê°€ì¤‘ì¹˜ $$w:E\to\mathbb{R}$$ì— ëŒ€í•´, **ëª¨ë“  ì •ì ì„ ì—°ê²°**í•˜ë©´ì„œ
  $$\sum_{e\in E_T} w(e)$$ ê°€ **ìµœì†Œ**ì¸ ì‹ ì¥ íŠ¸ë¦¬.

### 2.2 ì¡´ì¬/ìœ ì¼ì„±
- **ì—°ê²°** ê·¸ë˜í”„ì´ë©´ **í•­ìƒ ì¡´ì¬**.
- ëª¨ë“  ê°„ì„  ê°€ì¤‘ì¹˜ê°€ **ì„œë¡œ ë‹¤ë¥¸ ê²½ìš°**, **MSTëŠ” ìœ ì¼**.

---

## 3. MSTì˜ í•µì‹¬ ì„±ì§ˆ

### 3.1 Cut Property (ì»· ì„±ì§ˆ)
- ì„ì˜ì˜ ì»· $$ (S, V\setminus S) $$ì„ ê°€ë¡œì§€ë¥´ëŠ” ê°„ì„ ë“¤ ì¤‘ **ê°€ì¥ ê°€ë²¼ìš´ ê°„ì„ **ì€ **ì–´ë–¤ MSTì—ë„ í¬í•¨**.

### 3.2 Cycle Property (ì‚¬ì´í´ ì„±ì§ˆ)
- ì„ì˜ì˜ ì‚¬ì´í´ì—ì„œ **ê°€ì¥ ë¬´ê±°ìš´ ê°„ì„ **ì€ **ì–´ë–¤ MSTì—ë„ í¬í•¨ë  ìˆ˜ ì—†ìŒ**.

> ë‘ ì„±ì§ˆì€ KruskalÂ·Primì˜ **ì •ë‹¹ì„±**ê³¼ **ì•ˆì „í•œ ì„ íƒ(safe edge)**ì˜ ê·¼ê±°ê°€ ëœë‹¤.

---

## 4. ì•Œê³ ë¦¬ì¦˜

### 4.1 Kruskal (ê°„ì„  ì¤‘ì‹¬)
1. ê°„ì„ ì„ ê°€ì¤‘ì¹˜ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬.
2. ìˆœì„œëŒ€ë¡œ ë³´ë©° ë‘ ëì ì´ **ë‹¤ë¥¸ ì»´í¬ë„ŒíŠ¸**ì´ë©´ ì±„íƒ(Union-Findë¡œ íŒì •).
3. ê°„ì„ ì´ $$|V|-1$$ê°œ ë˜ë©´ ì¢…ë£Œ.

- ì‹œê°„ë³µì¡ë„: $$O(E\log E)$$ (ì •ë ¬ ì§€ë°°; Union-FindëŠ” ê±°ì˜ ìƒìˆ˜ ìƒì‡„).
- í¬ì†Œ ê·¸ë˜í”„, ê°„ì„  ë¦¬ìŠ¤íŠ¸ ì…ë ¥ì— ìœ ë¦¬.

#### Python (ê°„ì„  ì§‘í•© â†’ MST ê°„ì„ /ì´í•© ë°˜í™˜)
```python
class UnionFind:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x):
        while self.p[x]!=x:
            self.p[x] = self.p[self.p[x]]  # path halving
            x = self.p[x]
        return x
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra==rb: return False
        if self.r[ra]<self.r[rb]: ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra]==self.r[rb]: self.r[ra]+=1
        return True

def kruskal_mst(n, edges):
    """
    n: ì •ì  ìˆ˜(0..n-1),
    edges: (u,v,w) ë¦¬ìŠ¤íŠ¸(ë¬´ë°©í–¥, u<v ê¶Œì¥)
    ë°˜í™˜: (mst_edges, total_weight)
    """
    uf = UnionFind(n)
    mst, total = [], 0
    edges = sorted(edges, key=lambda x: x[2])
    for u,v,w in edges:
        if uf.union(u,v):
            mst.append((u,v,w))
            total += w
            if len(mst)==n-1:
                break
    # ì—°ê²°ì´ ì•„ë‹ˆë©´ forestê°€ ë‚˜ì˜´(ê°„ì„  < n-1)
    return mst, total
```

---

### 4.2 Prim (ì •ì  ì¤‘ì‹¬)
1. ì„ì˜ì˜ ì‹œì‘ ì •ì ì—ì„œ ì¶œë°œ.
2. í˜„ì¬ íŠ¸ë¦¬ì—ì„œ ë°”ê¹¥ ì •ì ìœ¼ë¡œ ë‚˜ê°€ëŠ” **ìµœì†Œ ê°€ì¤‘ì¹˜ ê°„ì„ **ì„ ì„ íƒí•˜ì—¬ í™•ì¥.
3. ëª¨ë“  ì •ì ì´ í¬í•¨ë  ë•Œê¹Œì§€ ë°˜ë³µ.

- í™/ìš°ì„ ìˆœìœ„ í ì‚¬ìš© ì‹œ: $$O(E\log V)$$
- ì¸ì ‘ í–‰ë ¬/ë°°ì—´ë§Œìœ¼ë¡œëŠ” $$O(V^2)$$ (ì¡°ë°€ ê·¸ë˜í”„ì— ê´œì°®ìŒ).
- **ì—°ì†ì ì¸ ë„¤íŠ¸ì›Œí¬ í™•ì¥ ì‹œ êµ¬í˜„ ê°„ë‹¨**.

#### Python (ì¸ì ‘ë¦¬ìŠ¤íŠ¸ â†’ MST ê°„ì„ /ê°€ì¤‘ì¹˜)
```python
import heapq

def prim_mst(adj, start=0):
    """
    adj: ë”•íŠ¸ ë˜ëŠ” ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ ì¸ì ‘ë¦¬ìŠ¤íŠ¸, adj[u] = [(v,w), ...]
    start: ì‹œì‘ ì •ì 
    ë°˜í™˜: (mst_edges, total_weight)
    """
    n = len(adj)
    visited = [False]*n
    heap = [(0, -1, start)]  # (w, parent, node)
    mst, total = [], 0

    while heap and len(mst)<n:
        w,p,u = heapq.heappop(heap)
        if visited[u]:
            continue
        visited[u] = True
        if p!=-1:
            mst.append((p,u,w))
            total += w
        for v,w2 in adj[u]:
            if not visited[v]:
                heapq.heappush(heap, (w2,u,v))
    # ì—°ê²°ì´ ì•„ë‹ˆë©´ mst ê¸¸ì´ < n-1
    return mst, total
```

---

### 4.3 BorÅ¯vka (ë³´ë£¨ë¸Œì¹´)
- ê° ì»´í¬ë„ŒíŠ¸ë§ˆë‹¤ **ê°€ì¥ ì‹¼ ë°”ê¹¥ ê°„ì„ **ì„ ë™ì‹œì— ì±„íƒ â†’ ì»´í¬ë„ŒíŠ¸ ìˆ˜ê°€ ë¹ ë¥´ê²Œ ì¤€ë‹¤(ëŒ€ê°œ 2ë°° ì´ìƒ ì¶•ì†Œ).
- ë³‘ë ¬/ë¶„ì‚° í™˜ê²½ì—ì„œ ìœ ë¦¬, êµ¬í˜„ì€ Kruskal+Primë³´ë‹¤ ë³µì¡í•  ìˆ˜ ìˆìœ¼ë‚˜ í° ê·¸ë˜í”„ì—ì„œ íš¨ìœ¨ì .

---

## 5. ì˜¬ë°”ë¦„(ì •ë‹¹ì„±) ìŠ¤ì¼€ì¹˜

### 5.1 Kruskalì˜ ì •ë‹¹ì„±
- í˜„ì¬ **ì»´í¬ë„ŒíŠ¸ ì»·**ì„ ê°€ë¡œì§€ë¥´ëŠ” ê°„ì„  ì¤‘ **ìµœì†Œ ê°„ì„ **ì„ íƒí•¨ â†’ Cut Propertyì— ì˜í•´ **ì•ˆì „**.
- ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šê²Œë§Œ ê³ ë¥´ë©´, $$|V|-1$$ê°œê°€ ë˜ë©´ íŠ¸ë¦¬ê°€ ëœë‹¤.

### 5.2 Primì˜ ì •ë‹¹ì„±
- í˜„ì¬ íŠ¸ë¦¬ $$T$$ì™€ ë°”ê¹¥ì˜ ì»·ì„ ê°€ë¡œì§€ë¥´ëŠ” **ìµœì†Œ ê°„ì„ **ì„ ë§¤ë²ˆ ì„ íƒ â†’ Cut Propertyë¡œ ì•ˆì „.
- ë°˜ë³µ í™•ì¥ìœ¼ë¡œ ëª¨ë“  ì •ì ì„ ë®ìœ¼ë©´ MST.

---

## 6. ì‹¤ì „ ì´ìŠˆ & íŒ

- **ìŒìˆ˜ ê°€ì¤‘ì¹˜**: MSTëŠ” **ìŒìˆ˜ë„ ë¬¸ì œ ì—†ìŒ**(ìµœë‹¨ê²½ë¡œì™€ ë‹¬ë¦¬).
- **ìê¸°ë£¨í”„/ë©€í‹°ì—ì§€**: ìê¸°ë£¨í”„ëŠ” ë¬´ì‹œ, ë©€í‹°ì—ì§€ëŠ” **ë” ì‹¼ ê²ƒë§Œ** ê³ ë ¤.
- **ê·¸ë˜í”„ê°€ ë¹„ì—°ê²°**: MST ëŒ€ì‹  **ìµœì†Œ ì‹ ì¥ ìˆ²(MSF)**ê°€ ë‚˜ì˜´(ì»´í¬ë„ŒíŠ¸ë³„ MST).
- **ë™ë¥ (ë™ì¼ ê°€ì¤‘ì¹˜)**: MSTê°€ **ì—¬ëŸ¬ ê°œ** ê°€ëŠ¥â€”ê²°ê³¼ê°€ ë‹¬ë¼ë„ ì´í•© ê°™ìŒ.
- **ìœ ì¼ì„± íŒì •**: ëª¨ë“  ê°„ì„  ê°€ì¤‘ì¹˜ê°€ ì„œë¡œ ë‹¤ë¥´ë©´ MST ìœ ì¼.
  - ì¼ë°˜ ì¼€ì´ìŠ¤: Kruskal ìˆ˜í–‰ ì¤‘ **ë™ì¼ ê°€ì¤‘ì¹˜ ê°„ì„ **ì„ ì–´ë–¤ ê²ƒì„ íƒí•´ë„ ê²°ê³¼ê°€ ê°™ë‹¤ë©´ ìœ ì¼, ì•„ë‹ˆë©´ ë‹¤ì¤‘.
- **ë°ì´í„° êµ¬ì¡°**:
  - Kruskal: **Union-Find**ëŠ” **ê²½ë¡œì••ì¶• + ë­í¬/ì‚¬ì´ì¦ˆ** í•„ìˆ˜.
  - Prim: í™ì— ì¤‘ë³µì´ ë“¤ì–´ê°€ë¯€ë¡œ **visited ì²´í¬**ë¡œ ë¬´ì‹œ.
- **ì„±ëŠ¥ ì„ íƒ**:
  - **í¬ì†Œ ê·¸ë˜í”„**: Kruskal or Prim(ì¸ì ‘ë¦¬ìŠ¤íŠ¸+í™).
  - **ì¡°ë°€ ê·¸ë˜í”„**: Prim(ì¸ì ‘í–‰ë ¬, $$O(V^2)$$)ë„ ê°€ëŠ¥.
- **ì¦ë¶„ ì—…ë°ì´íŠ¸**: ê°„ì„  ì¶”ê°€/ì‚­ì œê°€ ì¦ìœ¼ë©´ **ë™ì  MST** ìë£Œêµ¬ì¡°(ê³ ê¸‰).

---

## 7. ì˜ˆì œ: ì†ìœ¼ë¡œ ë”°ë¼ê°€ê¸°

### 7.1 ê·¸ë˜í”„
ì •ì  0..5, ê°„ì„ (ë¬´ë°©í–¥):

| e | (u,v) | w |
|---|-------|---|
| e1 | (0,1) | 4 |
| e2 | (0,2) | 2 |
| e3 | (1,2) | 1 |
| e4 | (1,3) | 5 |
| e5 | (2,3) | 8 |
| e6 | (2,4) | 10 |
| e7 | (3,4) | 2 |
| e8 | (3,5) | 6 |
| e9 | (4,5) | 3 |

### 7.2 Kruskal
- ì •ë ¬: e3(1), e2(2), e7(2), e9(3), e1(4), e4(5), e8(6), e5(8), e6(10)
- ì„ íƒ:
  - e3(1): {1,2} ì—°ê²°
  - e2(2): 0â€“2 ì¶”ê°€
  - e7(2): 3â€“4 ì¶”ê°€
  - e9(3): 4â€“5 ì¶”ê°€ â†’ í˜„ì¬ ì»´í¬ë„ŒíŠ¸ {3,4,5}
  - e1(4): 0â€“1 ì¶”ê°€(ì‚¬ì´í´ ì—†ìŒ)
  - ì´ì œ ë‚¨ì€ ì»´í¬ë„ŒíŠ¸ë¥¼ ì—°ê²°í•˜ë ¤ë©´ {0,1,2}ì™€ {3,4,5} ì‚¬ì´ ìµœì†Œ ê°„ì„ : e4(5) vs e5(8) vs e6(10) â†’ **e4(5)** ì±„íƒ
- ì´ 5ê°œ ê°„ì„ (ì •ì  6ê°œ â†’ 5ê°œê°€ MST ê°„ì„  ìˆ˜):
  $$\{e3(1), e2(2), e7(2), e9(3), e4(5)\}$$
- ê°€ì¤‘ì¹˜ í•©: $$1+2+2+3+5=13$$

### 7.3 Prim (start=0)
- 0ì—ì„œ ì‹œì‘: í›„ë³´ {(0,1):4, (0,2):2} â†’ (0,2) ì±„íƒ
- T={0,2}; í›„ë³´ì— (2,1):1, (2,3):8, (2,4):10 ì¶”ê°€ â†’ ìµœì†Œ (2,1):1
- T={0,2,1}; í›„ë³´ì— (1,3):5 ì¶”ê°€ â†’ ìµœì†Œ (1,3):5 vs (2,3):8 vs (2,4):10 â†’ (1,3)=5
- T={0,2,1,3}; í›„ë³´ì— (3,4):2, (3,5):6 ì¶”ê°€ â†’ ìµœì†Œ (3,4)=2
- T={0,2,1,3,4}; í›„ë³´ì— (4,5):3 ì¶”ê°€ â†’ ìµœì†Œ (4,5)=3
- ì™„ì„±, í•©ì€ ë™ì¼ **13**.

---

## 8. ê³ ê¸‰ ì£¼ì œ

### 8.1 MST ìœ ì¼ì„± ì¶©ë¶„ì¡°ê±´
- ëª¨ë“  ê°„ì„  ê°€ì¤‘ì¹˜ê°€ **ì„œë¡œ ë‹¤ë¥´ë©´** MSTëŠ” **ìœ ì¼**.
- ì¦ëª… ì•„ì´ë””ì–´: ë™ë¥ ì´ ì—†ìœ¼ë¯€ë¡œ ê° ì»·ì—ì„œ **ìœ ì¼í•œ ìµœì†Œ ê°„ì„ **ì´ í•­ìƒ ê³ ì •ì ìœ¼ë¡œ ì„ íƒë¨.

### 8.2 ì‹ ì¥ íŠ¸ë¦¬ì˜ ê°œìˆ˜ (ë¬´ê°€ì¤‘) â€” Matrix-Tree ì •ë¦¬
- **ë¼í”Œë¼ì‹œì•ˆ** $$L=D-A$$ (D: ì°¨ìˆ˜ëŒ€ê°, A: ì¸ì ‘í–‰ë ¬).
- ì„ì˜ì˜ í–‰/ì—´ í•˜ë‚˜ ì œê±°í•œ **ì†Œí–‰ë ¬**ì˜ í–‰ë ¬ì‹ì´ **ì‹ ì¥ íŠ¸ë¦¬ ê°œìˆ˜**.
- ê°€ì¤‘ ê·¸ë˜í”„ì˜ ê²½ìš° ê°€ì¤‘ ë¼í”Œë¼ì‹œì•ˆìœ¼ë¡œ **ê°€ì¤‘ ì‹ ì¥ íŠ¸ë¦¬ ìˆ˜**.

#### Python(ì •í™• ì •ìˆ˜ ì—°ì‚°) â€” ê°€ê°ì†Œ ì†Œê±°ë¡œ det
```python
from fractions import Fraction

def matrix_tree_num_spanning_trees(adj):
    """
    adj: n x n ì¸ì ‘í–‰ë ¬(ì •ìˆ˜ ê°€ì¤‘=1 ë¬´ê°€ì¤‘), ë¬´ë°©í–¥
    ë°˜í™˜: ì‹ ì¥ íŠ¸ë¦¬ ê°œìˆ˜(ì •ìˆ˜)
    """
    n = len(adj)
    # ë¼í”Œë¼ì‹œì•ˆ L = D - A
    L = [[0]*n for _ in range(n)]
    for i in range(n):
        deg = 0
        for j in range(n):
            deg += adj[i][j]
        for j in range(n):
            L[i][j] = (deg if i==j else 0) - adj[i][j]

    # ì†Œí–‰ë ¬(0í–‰0ì—´ ì œê±°)
    M = [[Fraction(L[i+1][j+1]) for j in range(n-1)] for i in range(n-1)]

    # í–‰ë ¬ì‹(ë¶„ìˆ˜ ê°€ìš°ìŠ¤ ì†Œê±°)
    det = Fraction(1)
    sz = n-1
    for c in range(sz):
        # pivot
        p = None
        for r in range(c, sz):
            if M[r][c] != 0:
                p = r; break
        if p is None:
            return 0
        if p != c:
            M[c], M[p] = M[p], M[c]
            det *= -1
        piv = M[c][c]
        det *= piv
        # normalize row c
        for j in range(c, sz):
            M[c][j] /= piv
        # eliminate others
        for r in range(sz):
            if r==c: continue
            factor = M[r][c]
            if factor!=0:
                for j in range(c, sz):
                    M[r][j] -= factor*M[c][j]
    return det.numerator // det.denominator
```

### 8.3 ë‘ ë²ˆì§¸ë¡œ ì¢‹ì€ MST (Second-Best MST)
- MST $$T$$ë¥¼ êµ¬í•˜ê³ , **MSTì— ì—†ëŠ” ê°„ì„ ** $$e=(u,v)$$ì„ í•˜ë‚˜ ì¶”ê°€í•˜ë©´ ì‚¬ì´í´ í˜•ì„±.
- ê·¸ ì‚¬ì´í´ì—ì„œ **ìµœëŒ€ ê°€ì¤‘ì¹˜ ê°„ì„ **ì„ ì œê±°í•˜ì—¬ **í›„ë³´ íŠ¸ë¦¬** ìƒì„±.
- ëª¨ë“  $$e\notin T$$ì— ëŒ€í•´ ìµœì†Œ ì¦ê°€ëŸ‰ì„ ì¡°ì‚¬ â†’ **ë‘ ë²ˆì§¸ë¡œ ì‘ì€ ê°€ì¤‘ì¹˜**.
- ëŒ€ê·œëª¨ì—ì„œëŠ” **LCA+max-edge ì¿¼ë¦¬**(binary lifting)ë¡œ ê²½ë¡œ ìµœëŒ€ ê°„ì„  ì¡°íšŒë¥¼ ë¹ ë¥´ê²Œ.

### 8.4 Directed MST (Arborescence)
- ë¿Œë¦¬ $$r$$ê°€ ì£¼ì–´ì§ˆ ë•Œ, ëª¨ë“  ì •ì ìœ¼ë¡œ í–¥í•˜ëŠ” **ìœ í–¥ ìµœì†Œ ì‹ ì¥ ìˆ˜ëª©**: **Edmonds/Chuâ€“Liu** ì•Œê³ ë¦¬ì¦˜.
- ë¬´ë°©í–¥ MSTì™€ëŠ” ì „í˜€ ë‹¤ë¥¸ ì¡°ê±´ê³¼ ì ˆì°¨(ì‚¬ì´í´ ì¶•ì•½ ë“±)ê°€ í•„ìš”.

---

## 9. ì‹¤ë¬´/ì½”ë”© ì²´í¬ë¦¬ìŠ¤íŠ¸

- ì…ë ¥ì´ **0-index/1-index**ì¸ì§€ ì¼ì¹˜.
- **ìê¸°ë£¨í”„/ì¤‘ë³µê°„ì„ ** ì •ë¦¬(ìê¸°ë£¨í”„ ì œê±°, ì¤‘ë³µì€ ìµœì†Œ ê°€ì¤‘ ì„ íƒ).
- Primì˜ í™ì€ **ì¤‘ë³µ ì—”íŠ¸ë¦¬**ê°€ ë§ë‹¤ â†’ **visited**ë¡œ í•„í„°.
- Kruskalì€ Union-Findì˜ **ê²½ë¡œì••ì¶• + ë­í¬** í•„ìˆ˜.
- **ë¹„ì—°ê²°** ëŒ€ë¹„: MST ëŒ€ì‹  **MSF** ì²˜ë¦¬(ê²°ê³¼ ê°„ì„  ìˆ˜ < $$|V|-1$$ì´ë©´ ê²½ê³ ).
- **ë™ë¥  ì²˜ë¦¬**ê°€ ê²°ê³¼ì— ì˜í–¥â€”ìœ ë‹ˆí¬ê°€ ì•„ë‹ˆë©´ MSTê°€ ì—¬ëŸ¬ ê°œ.
- **í…ŒìŠ¤íŠ¸**: ì†í’€ì´ ê°€ëŠ¥í•œ ì†Œê·œëª¨ ê·¸ë˜í”„ â†’ ëŒ€ê·œëª¨ ëœë¤ â†’ ë³‘ë ¬/ì—£ì§€ì¼€ì´ìŠ¤.
- **ê°€ì¤‘ì¹˜ íƒ€ì…**: int/float í˜¼ìš© ì£¼ì˜(ë¹„êµ, ì •ë ¬ ì•ˆì •ì„±).

---

## ğŸ”§ ì¢…í•© ì˜ˆì œ ì½”ë“œ (Kruskal/Prim/ê²€ì¦/Matrix-Tree)

```python
from fractions import Fraction
import heapq

# ---------- Union-Find ----------
class UnionFind:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0]*n
        self.comp = n
    def find(self, x):
        while self.p[x]!=x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra==rb: return False
        if self.r[ra]<self.r[rb]: ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra]==self.r[rb]: self.r[ra]+=1
        self.comp -= 1
        return True

# ---------- Kruskal ----------
def kruskal_mst(n, edges):
    uf = UnionFind(n)
    mst, total = [], 0
    edges = sorted(edges, key=lambda x: x[2])
    for u,v,w in edges:
        if uf.union(u,v):
            mst.append((u,v,w))
            total += w
            if len(mst)==n-1:
                break
    return mst, total

# ---------- Prim ----------
def prim_mst(adj, start=0):
    n = len(adj)
    visited = [False]*n
    heap = [(0, -1, start)]
    mst, total = [], 0
    while heap and len(mst)<n:
        w,p,u = heapq.heappop(heap)
        if visited[u]: continue
        visited[u] = True
        if p!=-1:
            mst.append((p,u,w))
            total += w
        for v,w2 in adj[u]:
            if not visited[v]:
                heapq.heappush(heap,(w2,u,v))
    return mst, total

# ---------- Matrix-Tree (ë¬´ê°€ì¤‘: ì¸ì ‘í–‰ë ¬) ----------
def num_spanning_trees(adj):
    n = len(adj)
    L = [[0]*n for _ in range(n)]
    for i in range(n):
        deg = 0
        for j in range(n):
            deg += adj[i][j]
        for j in range(n):
            L[i][j] = (deg if i==j else 0) - adj[i][j]
    M = [[Fraction(L[i+1][j+1]) for j in range(n-1)] for i in range(n-1)]
    det = Fraction(1)
    sz = n-1
    for c in range(sz):
        p=None
        for r in range(c,sz):
            if M[r][c]!=0:
                p=r; break
        if p is None:
            return 0
        if p!=c:
            M[c], M[p] = M[p], M[c]
            det *= -1
        piv = M[c][c]
        det *= piv
        for j in range(c,sz):
            M[c][j] /= piv
        for r in range(sz):
            if r==c: continue
            f = M[r][c]
            if f!=0:
                for j in range(c,sz):
                    M[r][j] -= f*M[c][j]
    return det.numerator // det.denominator

# ---------- Demo ----------
if __name__ == "__main__":
    n = 6
    edges = [
        (0,1,4),(0,2,2),(1,2,1),(1,3,5),
        (2,3,8),(2,4,10),(3,4,2),(3,5,6),(4,5,3)
    ]
    mst_k, w_k = kruskal_mst(n, edges)
    print("Kruskal MST:", mst_k, "total:", w_k)

    # build adjacency list for Prim
    adj = [[] for _ in range(n)]
    for u,v,w in edges:
        adj[u].append((v,w))
        adj[v].append((u,w))
    mst_p, w_p = prim_mst(adj, start=0)
    print("Prim   MST:", mst_p, "total:", w_p)

    # ë¬´ê°€ì¤‘ ì˜ˆ(ì‚¼ê°í˜• K3)ì˜ ì‹ ì¥ íŠ¸ë¦¬ ê°œìˆ˜: 3
    adj_u = [
        [0,1,1],
        [1,0,1],
        [1,1,0]
    ]
    print("K3 spanning trees:", num_spanning_trees(adj_u))
```

**ì˜ˆìƒ ì¶œë ¥(ê°€ì¤‘ì¹˜ í•© ë™ì¼ 13)**
```
Kruskal MST: [(1, 2, 1), (0, 2, 2), (3, 4, 2), (4, 5, 3), (1, 3, 5)] total: 13
Prim   MST: [(0, 2, 2), (2, 1, 1), (1, 3, 5), (3, 4, 2), (4, 5, 3)] total: 13
K3 spanning trees: 3
```

---

## 10. ì—°ìŠµ ë¬¸ì œ

1. **ì»·/ì‚¬ì´í´ ì„±ì§ˆ**ì„ ì‚¬ìš©í•´ KruskalÂ·Primì˜ **ì•ˆì „ ê°„ì„  ì„ íƒ**ì„ ê°ê° ì¦ëª…(ìŠ¤ì¼€ì¹˜)í•˜ë¼.
2. ë‹¤ìŒ ê·¸ë˜í”„ì˜ MSTë¥¼ **Kruskal**ë¡œ ì°¾ê³ (ê°„ì„  ì„ íƒ ìˆœì„œ ëª…ì‹œ), ë™ì¼ ê·¸ë˜í”„ë¥¼ **Prim**ìœ¼ë¡œë„ í’€ì–´ ê²°ê³¼ ê°€ì¤‘ì¹˜ê°€ ê°™ìŒì„ ë³´ì´ë¼.
3. ëª¨ë“  ê°„ì„  ê°€ì¤‘ì¹˜ê°€ ì„œë¡œ ë‹¤ë¥¸ ê²½ìš° **ìœ ì¼ì„±**ì„ ì¦ëª…í•˜ë¼.
4. ë‹¤ìŒ ë¬´ê°€ì¤‘ ê·¸ë˜í”„ì˜ **ì‹ ì¥ íŠ¸ë¦¬ ê°œìˆ˜**ë¥¼ **Matrix-Tree**ë¡œ ê³„ì‚°í•˜ë¼(ë¼í”Œë¼ì‹œì•ˆ ì‘ì„±â†’ì†Œí–‰ë ¬â†’í–‰ë ¬ì‹).
5. ì£¼ì–´ì§„ MSTì— ëŒ€í•´, **ë‘ ë²ˆì§¸ë¡œ ì¢‹ì€ MST**ë¥¼ ì°¾ëŠ” ì ˆì°¨ë¥¼ ì†ìœ¼ë¡œ ìˆ˜í–‰í•˜ë¼(ì‚¬ì´í´ ìµœëŒ€ ê°„ì„  êµí™˜).

---

## 11. í•µì‹¬ ìš”ì•½

- **ST**: ì—°ê²°+ë¬´ì‚¬ì´í´ì˜ $$|V|-1$$ê°„ì„  ë¶€ë¶„ê·¸ë˜í”„.
- **MST**: ëª¨ë“  ì •ì ì„ ì‡ëŠ” íŠ¸ë¦¬ ì¤‘ **ê°€ì¤‘ì¹˜ í•© ìµœì†Œ**.
- **Cut/Cycle Property**: ì•ˆì „/ë°°ì œ ê°„ì„  ì„ íƒì˜ ê·¼ê±°.
- **Kruskal**: $$O(E\log E)$$, **Union-Find** í•„ìˆ˜.
- **Prim**: $$O(E\log V)$$(í™) ë˜ëŠ” $$O(V^2)$$(ì¡°ë°€).
- **Matrix-Tree**: ë¼í”Œë¼ì‹œì•ˆ ì†Œí–‰ë ¬ì˜ det = ì‹ ì¥ íŠ¸ë¦¬ ê°œìˆ˜.
- **ìœ ì¼ì„±**: ê°€ì¤‘ì¹˜ ëª¨ë‘ ë‹¤ë¥´ë©´ MST ìœ ì¼.
- **ì‹¤ë¬´**: ì…ë ¥ ì •ì œ, ë¹„ì—°ê²°=MSF, ë™ë¥ ì²˜ë¦¬, ì„±ëŠ¥/ë°ì´í„°êµ¬ì¡° ì„ íƒ, ê²€ì¦ ìë™í™”.
