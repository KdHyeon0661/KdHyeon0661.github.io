---
layout: post
title: ì´ì‚°ìˆ˜í•™ - ì‹ ì¥ íŠ¸ë¦¬ì™€ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬
date: 2025-07-03 19:20:23 +0900
category: ì´ì‚°ìˆ˜í•™
---
# ğŸŒ² ì‹ ì¥ íŠ¸ë¦¬ì™€ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬

ê·¸ë˜í”„ ì´ë¡ ì—ì„œ **ì‹ ì¥ íŠ¸ë¦¬**ì™€ **ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST)**ëŠ”  
ë„¤íŠ¸ì›Œí¬ êµ¬ì„±, ë„ë¡œ ê±´ì„¤, íšŒë¡œ ì„¤ê³„ ë“±ì—ì„œ ìì£¼ ë“±ì¥í•˜ëŠ” í•µì‹¬ ê°œë…ì…ë‹ˆë‹¤.  
íŠ¹íˆ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ëŠ” ë¬¸ì œì—ì„œ í•„ìˆ˜ì ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.

---

## ğŸŒ¿ ì‹ ì¥ íŠ¸ë¦¬ (Spanning Tree)

### ğŸ“Œ ì •ì˜

> **ì‹ ì¥ íŠ¸ë¦¬(Spanning Tree)**ë€,  
> ì—°ê²°ëœ ë¬´ë°©í–¥ ê·¸ë˜í”„ \( G = (V, E) \)ì—ì„œ  
> **ëª¨ë“  ì •ì ì´ ì—°ê²°ë˜ë©° ì‚¬ì´í´ì´ ì—†ëŠ” ë¶€ë¶„ ê·¸ë˜í”„**ì…ë‹ˆë‹¤.

ì¦‰,
- ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ê³ ,
- ì •ì ë“¤ ì‚¬ì´ë¥¼ ì—°ê²°í•˜ë©°,
- **ì‚¬ì´í´ì´ ì—†ì–´ íŠ¸ë¦¬ êµ¬ì¡°**ë¥¼ ê°€ì§

### ğŸ“ ì„±ì§ˆ

- **ì •ì  ê°œìˆ˜ \( n \)**ì¼ ë•Œ, ì‹ ì¥ íŠ¸ë¦¬ëŠ” í•­ìƒ **ê°„ì„  ìˆ˜ = \( n - 1 \)**
- í•˜ë‚˜ì˜ ì—°ê²° ê·¸ë˜í”„ì—ì„œ ì—¬ëŸ¬ ê°œì˜ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŒ
- **ì‚¬ì´í´ì´ ì—†ìŒ + ì—°ê²°ë˜ì–´ ìˆìŒ â‡’ íŠ¸ë¦¬**

### ğŸ§® ì˜ˆì‹œ

ê·¸ë˜í”„:
```
A â€” B
|  /
C
```

ê°€ëŠ¥í•œ ì‹ ì¥ íŠ¸ë¦¬ë“¤:
- Aâ€”B, Bâ€”C
- Aâ€”C, Câ€”B
- Aâ€”B, Aâ€”C

ê° ê²½ìš° ê°„ì„  ìˆ˜ = 2 = 3 - 1 (ì •ì  ìˆ˜ - 1)

---

## ğŸ’° ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (Minimum Spanning Tree, MST)

### ğŸ“Œ ì •ì˜

> **ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST)**ëŠ”  
> **ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ì—ì„œ ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ë˜,  
> ì „ì²´ ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì†Œ**ì¸ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ë§í•©ë‹ˆë‹¤.

ì¦‰,
- ëª¨ë“  ì •ì ì„ ì—°ê²°í•´ì•¼ í•˜ë©°,
- **ìµœì†Œí•œì˜ ë¹„ìš©ìœ¼ë¡œ** ì—°ê²°í•´ì•¼ í•¨

---

## ğŸ§  ì£¼ìš” ì•Œê³ ë¦¬ì¦˜

### âœ… 1. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ (Kruskal's Algorithm)

- **ê°„ì„  ì¤‘ì‹¬ ì ‘ê·¼**
- ëª¨ë“  ê°„ì„ ì„ ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
- **ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡** ì‘ì€ ê°„ì„ ë¶€í„° ì„ íƒ
- **ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ(Union-Find)** ì‚¬ìš©

#### ì‹œê°„ë³µì¡ë„:
\[
O(E \log E)
\]

#### Python ì˜ˆì‹œ:
```python
def kruskal(n, edges):
    parent = list(range(n))
    
    def find(u):
        while parent[u] != u:
            parent[u] = parent[parent[u]]
            u = parent[u]
        return u
    
    def union(u, v):
        root_u, root_v = find(u), find(v)
        if root_u == root_v:
            return False
        parent[root_v] = root_u
        return True
    
    mst = []
    edges.sort(key=lambda x: x[2])
    
    for u, v, w in edges:
        if union(u, v):
            mst.append((u, v, w))
    return mst
```

---

### âœ… 2. í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ (Primâ€™s Algorithm)

- **ì •ì  ì¤‘ì‹¬ ì ‘ê·¼**
- í•œ ì •ì ì—ì„œ ì‹œì‘í•´, ì¸ì ‘ ê°„ì„  ì¤‘ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„  ì„ íƒ
- **BFS ë˜ëŠ” ìš°ì„ ìˆœìœ„ í(Heap)** ê¸°ë°˜

#### ì‹œê°„ë³µì¡ë„:
\[
O(E \log V)
\]

#### Python ì˜ˆì‹œ:
```python
import heapq

def prim(graph, start):
    visited = set()
    heap = [(0, start)]
    mst_weight = 0

    while heap:
        weight, u = heapq.heappop(heap)
        if u in visited:
            continue
        visited.add(u)
        mst_weight += weight

        for v, w in graph[u]:
            if v not in visited:
                heapq.heappush(heap, (w, v))
    return mst_weight
```

---

## ğŸ“ MST ê´€ë ¨ ì„±ì§ˆ

### ğŸ“ ì •ë¦¬

- MSTëŠ” ê·¸ë˜í”„ì˜ **ì‚¬ì´í´ì„ í¬í•¨í•˜ì§€ ì•ŠëŠ” ê°€ì¥ ì €ë ´í•œ ì—°ê²° êµ¬ì¡°**
- ê·¸ë˜í”„ê°€ ì—°ê²°ë˜ì–´ ìˆë‹¤ë©´, **í•­ìƒ MSTê°€ ì¡´ì¬**
- í•˜ë‚˜ì˜ ê·¸ë˜í”„ì—ì„œ **MSTëŠ” ìœ ì¼í•˜ì§€ ì•Šì„ ìˆ˜ë„ ìˆìŒ**

### ğŸ’¡ ì¤‘ìš”í•œ ì„±ì§ˆë“¤

- **Cut Property**: ì–´ë–¤ ì •ì  ì§‘í•© \( S \)ê³¼ \( V \setminus S \) ì‚¬ì´ì˜ ìµœì†Œ ê°€ì¤‘ì¹˜ ê°„ì„ ì€ MSTì— ë°˜ë“œì‹œ í¬í•¨ëœë‹¤.
- **Cycle Property**: ì‚¬ì´í´ì—ì„œ ê°€ì¥ í° ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§„ ê°„ì„ ì€ MSTì— í¬í•¨ë˜ì§€ ì•ŠëŠ”ë‹¤.

---

## ğŸ“Š ì‘ìš© ë¶„ì•¼

| ë¶„ì•¼ | ì„¤ëª… |
|------|------|
| ë„¤íŠ¸ì›Œí¬ ì„¤ê³„ | ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì»´í“¨í„°/ì¥ë¹„ ì—°ê²° |
| ë„ë¡œ/ì² ë„ ì„¤ê³„ | ìµœì†Œ ê±°ë¦¬ë¡œ ë„ì‹œ ì—°ê²° |
| íšŒë¡œ ì„¤ê³„ | íš¨ìœ¨ì ì¸ ë°°ì„  ì—°ê²° |
| êµ°ì§‘í™” | MST ê¸°ë°˜ ê³„ì¸µì  êµ°ì§‘í™” (Hierarchical Clustering) |
| ë¬¼ë¥˜ | ë¬¼ë¥˜ ê±°ì  ê°„ ìµœì†Œ ê²½ë¡œ êµ¬ì„± |