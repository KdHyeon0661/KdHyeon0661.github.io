---
layout: post
title: 이산수학 - 신장 트리와 최소 신장 트리
date: 2025-07-03 19:20:23 +0900
category: 이산수학
---
# 🌲 신장 트리와 최소 신장 트리

그래프 이론에서 **신장 트리**와 **최소 신장 트리(MST)**는  
네트워크 구성, 도로 건설, 회로 설계 등에서 자주 등장하는 핵심 개념입니다.  
특히 최소 비용으로 모든 정점을 연결하는 문제에서 필수적으로 사용됩니다.

---

## 🌿 신장 트리 (Spanning Tree)

### 📌 정의

> **신장 트리(Spanning Tree)**란,  
> 연결된 무방향 그래프 \( G = (V, E) \)에서  
> **모든 정점이 연결되며 사이클이 없는 부분 그래프**입니다.

즉,
- 그래프의 모든 정점을 포함하고,
- 정점들 사이를 연결하며,
- **사이클이 없어 트리 구조**를 가짐

### 📐 성질

- **정점 개수 \( n \)**일 때, 신장 트리는 항상 **간선 수 = \( n - 1 \)**
- 하나의 연결 그래프에서 여러 개의 신장 트리를 만들 수 있음
- **사이클이 없음 + 연결되어 있음 ⇒ 트리**

### 🧮 예시

그래프:
```
A — B
|  /
C
```

가능한 신장 트리들:
- A—B, B—C
- A—C, C—B
- A—B, A—C

각 경우 간선 수 = 2 = 3 - 1 (정점 수 - 1)

---

## 💰 최소 신장 트리 (Minimum Spanning Tree, MST)

### 📌 정의

> **최소 신장 트리(MST)**는  
> **가중치 그래프에서 모든 정점을 연결하되,  
> 전체 간선의 가중치 합이 최소**인 신장 트리를 말합니다.

즉,
- 모든 정점을 연결해야 하며,
- **최소한의 비용으로** 연결해야 함

---

## 🧠 주요 알고리즘

### ✅ 1. 크루스칼 알고리즘 (Kruskal's Algorithm)

- **간선 중심 접근**
- 모든 간선을 가중치 기준으로 정렬
- **사이클이 생기지 않도록** 작은 간선부터 선택
- **유니온 파인드(Union-Find)** 사용

#### 시간복잡도:
\[
O(E \log E)
\]

#### Python 예시:
```python
def kruskal(n, edges):
    parent = list(range(n))
    
    def find(u):
        while parent[u] != u:
            parent[u] = parent[parent[u]]
            u = parent[u]
        return u
    
    def union(u, v):
        root_u, root_v = find(u), find(v)
        if root_u == root_v:
            return False
        parent[root_v] = root_u
        return True
    
    mst = []
    edges.sort(key=lambda x: x[2])
    
    for u, v, w in edges:
        if union(u, v):
            mst.append((u, v, w))
    return mst
```

---

### ✅ 2. 프림 알고리즘 (Prim’s Algorithm)

- **정점 중심 접근**
- 한 정점에서 시작해, 인접 간선 중 가장 가중치가 작은 간선 선택
- **BFS 또는 우선순위 큐(Heap)** 기반

#### 시간복잡도:
\[
O(E \log V)
\]

#### Python 예시:
```python
import heapq

def prim(graph, start):
    visited = set()
    heap = [(0, start)]
    mst_weight = 0

    while heap:
        weight, u = heapq.heappop(heap)
        if u in visited:
            continue
        visited.add(u)
        mst_weight += weight

        for v, w in graph[u]:
            if v not in visited:
                heapq.heappush(heap, (w, v))
    return mst_weight
```

---

## 📐 MST 관련 성질

### 📎 정리

- MST는 그래프의 **사이클을 포함하지 않는 가장 저렴한 연결 구조**
- 그래프가 연결되어 있다면, **항상 MST가 존재**
- 하나의 그래프에서 **MST는 유일하지 않을 수도 있음**

### 💡 중요한 성질들

- **Cut Property**: 어떤 정점 집합 \( S \)과 \( V \setminus S \) 사이의 최소 가중치 간선은 MST에 반드시 포함된다.
- **Cycle Property**: 사이클에서 가장 큰 가중치를 가진 간선은 MST에 포함되지 않는다.

---

## 📊 응용 분야

| 분야 | 설명 |
|------|------|
| 네트워크 설계 | 최소 비용으로 컴퓨터/장비 연결 |
| 도로/철도 설계 | 최소 거리로 도시 연결 |
| 회로 설계 | 효율적인 배선 연결 |
| 군집화 | MST 기반 계층적 군집화 (Hierarchical Clustering) |
| 물류 | 물류 거점 간 최소 경로 구성 |