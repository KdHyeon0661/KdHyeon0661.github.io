---
layout: post
title: 선형대수 - 가우스-조르당 소거법
date: 2025-05-14 21:20:23 +0900
category: 선형대수
---
# 가우스-조르당 소거법 (Gauss–Jordan Elimination) — 연립 1차 방정식의 완전 해법

## 1. 개념 요약

가우스 소거법이 확대행렬 $$[\ \mathbf{A}\mid \mathbf{b}\ ]$$ 를 **위 삼각형(REF)** 으로 만든 뒤 **후방대입**으로 해를 구하는 절차라면,
가우스-조르당 소거법은 한 걸음 더 나아가 **피벗 열의 위·아래를 모두 0** 으로 만들어 **기약 행 사다리꼴(RREF)** 에 도달합니다.
RREF이면 해를 **그대로 읽을 수** 있고, 자유변수도 즉시 파악됩니다.

---

## 2. RREF(기약 행 사다리꼴) 정의와 성질

행렬 $$\mathbf{R}$$ 이 다음을 만족하면 **RREF** 입니다.

1. 각 0이 아닌 행의 **첫 비영 원소(피벗)** 는 1이다.
2. 각 피벗은 **그 열의 유일한 비영 원소**(위·아래 모두 0)이다.
3. 아래쪽 행일수록 피벗의 열 인덱스가 크다(사다리꼴).
4. 모든 0인 행은 하단에 위치한다.

중요 성질:

- **유일성**: 임의의 행렬에 대해 RREF는 **유일**하다.
- **해 판정**: 확대행렬 RREF에서 $$[0\ \cdots\ 0\ |\ c]$$, $$c\neq 0$$ 행이 나타나면 **불일치(무해)**.
- **자유변수**: 피벗이 없는 열은 자유변수. 피벗 열은 기저·랭크와 직결.

---

## 3. 허용되는 기본 행 연산

1) 행 교환: $$R_i \leftrightarrow R_j$$
2) 스칼라 배: $$R_i \leftarrow c\,R_i\ (c\neq 0)$$
3) 행 대치: $$R_i \leftarrow R_i + c\,R_j$$

이 연산들은 해 집합을 **불변**으로 둡니다.

---

## 4. 알고리즘(부분 피벗팅 포함) — 개요

입력: $$[\ \mathbf{A}\mid \mathbf{b}\ ]\in\mathbb{R}^{m\times(n+1)}$$

1) 열을 왼쪽부터 순회하며, 현재 열에서 **절댓값 최대의 피벗**을 찾아 해당 행을 위로 올린다(부분 피벗팅).
2) 그 행을 피벗으로 **정규화(피벗=1)** 한다.
3) 같은 열의 다른 모든 행에서 피벗을 이용해 **위·아래를 0** 으로 만든다.
4) 다음 열로 진행. 끝나면 RREF에 도달.

수치 안정성 때문에 1)의 부분 피벗팅이 강력히 권장됩니다.

---

## 5. 해의 분류(랭크 관점)

- $$r(\mathbf{A})=\operatorname{rank}(\mathbf{A}),\quad r([\mathbf{A}\mid\mathbf{b}])$$

Rouché–Capelli 정리:

- **해 존재**: $$r(\mathbf{A})=r([\mathbf{A}\mid\mathbf{b}]).$$
- **유일해**: 위가 성립하고 $$r(\mathbf{A})=n.$$
- **무한해**: 위가 성립하고 $$r(\mathbf{A})<n$$ (자유변수 개수 $$=n-r(\mathbf{A})$$).
- **무해**: $$r(\mathbf{A})<r([\mathbf{A}\mid\mathbf{b}]).$$

---

## 6. 손계산 예제

### 6.1 유일해 예제

$$
\begin{cases}
x+2y+z=4\\
2x+3y+5z=9\\
-\,x+y+2z=2
\end{cases}
\quad\Longrightarrow\quad
\left[
\begin{array}{ccc|c}
1&2&1&4\\
2&3&5&9\\
-1&1&2&2
\end{array}
\right]
$$

1) 열1 피벗=1(이미 최대), 아래/위 제거:
$$R_2\leftarrow R_2-2R_1,\ R_3\leftarrow R_3+R_1 \Rightarrow
\left[
\begin{array}{ccc|c}
1&2&1&4\\
0&-1&3&1\\
0&3&3&6
\end{array}
\right]
$$

2) 열2 피벗 행을 정규화: $$R_2\leftarrow -R_2$$
$$
\left[
\begin{array}{ccc|c}
1&2&1&4\\
0&1&-3&-1\\
0&3&3&6
\end{array}
\right]
$$
위·아래 제거: $$R_1\leftarrow R_1-2R_2,\ R_3\leftarrow R_3-3R_2$$
$$
\left[
\begin{array}{ccc|c}
1&0&7&6\\
0&1&-3&-1\\
0&0&12&9
\end{array}
\right]
$$

3) 열3 피벗 정규화: $$R_3\leftarrow \tfrac{1}{12}R_3$$
위·아래 제거: $$R_1\leftarrow R_1-7R_3,\ R_2\leftarrow R_2+3R_3$$

최종 RREF:
$$
\left[
\begin{array}{ccc|c}
1&0&0&\tfrac{5}{4}\\
0&1&0&\tfrac{1}{4}\\
0&0&1&\tfrac{3}{4}
\end{array}
\right]
$$

따라서 $$x=\tfrac{5}{4},\ y=\tfrac{1}{4},\ z=\tfrac{3}{4}.$$

---

### 6.2 무해(불일치) 예제

$$
\begin{cases}
x+y=1\\
2x+2y=3
\end{cases}
\Rightarrow
\left[
\begin{array}{cc|c}
1&1&1\\
2&2&3
\end{array}
\right]
$$

소거하면 마지막 행이 $$[0\ 0\ |\ 1]$$ 꼴(즉 $$0=1$$)이 되어 **해 없음**.
랭크로는 $$r(\mathbf{A})=1,\ r([\mathbf{A}\mid\mathbf{b}])=2.$$

---

### 6.3 무한해(자유변수 1개) 예제

$$
\begin{cases}
x+2y+z=0\\
2x+4y+2z=0
\end{cases}
\Rightarrow
\left[
\begin{array}{ccc|c}
1&2&1&0\\
2&4&2&0
\end{array}
\right]
$$

두 번째 행은 첫 행의 배. RREF는
$$
\left[
\begin{array}{ccc|c}
1&2&1&0\\[2pt]
0&0&0&0
\end{array}
\right]
$$
피벗 열은 1열, 자유변수는 2·3열. $$y=s,\ z=t$$ 로 두면
$$
x=-2s-t,\quad
\mathbf{x}=\begin{bmatrix}-2s-t\\ s\\ t\end{bmatrix},\ s,t\in\mathbb{R}.
$$

---

## 7. 응용 1 — 역행렬 계산

정방행렬 $$\mathbf{A}\in\mathbb{R}^{n\times n}$$ 이 가역이면,
$$
\left[\ \mathbf{A}\ \middle|\ \mathbf{I}\ \right]\ \xRightarrow{\text{Gauss–Jordan}}\
\left[\ \mathbf{I}\ \middle|\ \mathbf{A}^{-1}\ \right].
$$

중간에 피벗이 0으로 막히거나 RREF 좌블록이 $$\mathbf{I}$$ 가 아니면 **특이행렬**이라 역행렬이 없습니다.

---

## 8. 응용 2 — 랭크, 기저, 영공간

- **랭크**: RREF의 피벗 행 수.
- **열공간 기저**: 원래 행렬의 **피벗 열**(원본에서 뽑기).
- **행공간 기저**: RREF의 0이 아닌 행들.
- **영공간 기저**: RREF에서 자유변수에 각각 1을 주고 피벗 변수는 식으로 표현해 얻는 특해 벡터들.

---

## 9. 수치 안정성과 복잡도

- 연산량: 가우스-조르당은 대략 $$O(n^3)$$ 이나, 가우스 소거보다 **상수배가 더 큼**(위·아래 모두 0으로 만들어야 해서).
- **부분 피벗팅**으로 반올림 오차를 줄인다.
- **스케일링(정규화)**, **클리핑(작은 수를 0으로)**, **조건수 $$\kappa(\mathbf{A})$$ 점검**이 실무에 유리.
- ill-conditioned(예: Hilbert) 행렬은 작은 데이터 교란에도 해가 크게 변한다.

---

## 10. PyTorch 구현 예제

아래 코드는 교육 목적으로 RREF(부분 피벗팅), 해 분류, 역행렬 계산을 제공합니다.
실전에서는 `torch.linalg.solve`, `torch.linalg.inv`, `torch.linalg.lu_factor` 등을 권장합니다.

```python
import torch
torch.set_printoptions(precision=6, sci_mode=False)
DT = torch.float64

def rref(A, b=None, atol=1e-12):
    """
    Gauss–Jordan with partial pivoting.
    If b is given, runs on [A|b] and returns the transformed matrix and pivot columns.
    """
    if b is not None:
        Ab = torch.cat([A.clone().to(DT), b.clone().to(DT).reshape(-1,1)], dim=1)
    else:
        Ab = A.clone().to(DT)

    m, n_ext = Ab.shape
    n = n_ext if b is None else n_ext - 1

    row = 0
    pivot_cols = []
    for col in range(n):
        # partial pivoting: pick row with largest |entry|
        piv = torch.argmax(torch.abs(Ab[row:, col])) + row
        if abs(Ab[piv, col]) < atol:
            continue  # no pivot in this column (free variable)
        if piv != row:
            Ab[[row, piv], :] = Ab[[piv, row], :]

        # scale pivot row
        Ab[row, :] = Ab[row, :] / Ab[row, col]

        # eliminate above and below
        for r in range(m):
            if r == row:
                continue
            factor = Ab[r, col]
            if abs(factor) > atol:
                Ab[r, :] -= factor * Ab[row, :]

        pivot_cols.append(col)
        row += 1
        if row == m:
            break

    # small values to zero (cleaning)
    Ab[torch.abs(Ab) < atol] = 0.0
    return Ab, pivot_cols

def classify(A, b, atol=1e-10):
    A = A.to(DT); b = b.to(DT).reshape(-1,1)
    Ab = torch.cat([A, b], dim=1)
    rA  = int(torch.linalg.matrix_rank(A, atol=atol).item())
    rAb = int(torch.linalg.matrix_rank(Ab, atol=atol).item())
    m, n = A.shape
    if rA < rAb:
        return "inconsistent", rA, rAb, None
    elif rA == n:
        return "unique", rA, rAb, 0
    else:
        return "infinite", rA, rAb, n - rA

def solve_via_gauss_jordan(A, b, atol=1e-12):
    """
    Solve Ax=b by reducing [A|b] to RREF.
    Returns: kind, x (if unique), param (if infinite: basis vectors)
    """
    m, n = A.shape
    Ab_rref, piv = rref(A, b)
    kind, rA, rAb, free = classify(A, b)
    if kind == "inconsistent":
        return kind, None, None

    if kind == "unique":
        # RREF must be [I|x]
        x = Ab_rref[:, -1]
        return kind, x, None

    # infinite solutions: construct parametric solution
    # Identify pivot and free columns
    pivot_set = set(piv)
    free_cols = [j for j in range(n) if j not in pivot_set]

    # RREF structure: pivot variables expressed in terms of free variables
    # For each free variable fk set to unit vector e_k, get a basis vector of nullspace
    R = Ab_rref[:, :n]
    rhs = Ab_rref[:, -1]

    # particular solution: set all free vars to 0
    x_part = torch.zeros(n, dtype=DT)
    for i, pc in enumerate(piv):
        x_part[pc] = rhs[i]

    basis = []
    for fc in free_cols:
        vec = torch.zeros(n, dtype=DT)
        vec[fc] = 1.0
        # pivot variables = -R[pivot_row, free_col]
        for i, pc in enumerate(piv):
            vec[pc] = -R[i, fc]
        basis.append(vec)

    return kind, x_part, basis

def invert_via_gauss_jordan(A, atol=1e-12):
    """
    Compute A^{-1} by [A|I] -> [I|A^{-1}] if invertible.
    """
    n, m = A.shape
    assert n == m, "square matrix required"
    I = torch.eye(n, dtype=DT)
    Aug = torch.cat([A.clone().to(DT), I], dim=1)
    Aug_rref, piv = rref(Aug)
    left = Aug_rref[:, :n]
    right = Aug_rref[:, n:]
    if not torch.allclose(left, torch.eye(n, dtype=DT), atol=1e-9, rtol=0):
        raise RuntimeError("singular matrix (no inverse)")
    return right

# 1. Unique solution test
A1 = torch.tensor([[1.,2.,1.],
                   [2.,3.,5.],
                   [-1.,1.,2.]], dtype=DT)
b1 = torch.tensor([4.,9.,2.], dtype=DT)
kind, x, basis = solve_via_gauss_jordan(A1, b1)
print("Case1:", kind, "x=", x)

# 2. Inconsistent test
A2 = torch.tensor([[1.,1.],
                   [2.,2.]], dtype=DT)
b2 = torch.tensor([1.,3.], dtype=DT)
print("Case2:", classify(A2, b2))
R2, piv2 = rref(A2, b2); print("RREF(A2|b2)=\n", R2)

# 3. Infinite solutions test
A3 = torch.tensor([[1.,2.,1.],
                   [2.,4.,2.]], dtype=DT)
b3 = torch.tensor([0.,0.], dtype=DT)
kind, x_part, basis = solve_via_gauss_jordan(A3, b3)
print("Case3:", kind, "x_part=", x_part, "basis=", basis)

# 4. Inverse via Gauss–Jordan
A4 = torch.tensor([[2.,1.],
                   [5.,3.]], dtype=DT)
A4_inv = invert_via_gauss_jordan(A4)
print("A4_inv=\n", A4_inv, "\ncheck A4*A4_inv=\n", A4@A4_inv)
```

설명 요점:

- `rref` 는 부분 피벗팅을 사용하여 열마다 위·아래를 제거해 RREF를 생성합니다.
- `classify` 는 랭크 비교로 해의 존재/개수를 판정합니다.
- `solve_via_gauss_jordan` 은 유일해/무한해를 구분해 해를 반환합니다(무한해일 때는 특정해와 영공간 기저).
- `invert_via_gauss_jordan` 은 $$[\mathbf{A}\mid\mathbf{I}] \to [\mathbf{I}\mid\mathbf{A}^{-1}]$$ 절차를 수행합니다.

---

## 11. 체크리스트와 팁

1) 행렬 스케일이 크게 다르면 열/행 정규화로 수치안정성 향상.
2) 피벗 절댓값이 너무 작으면(허용오차 아래) 다른 행과 교환하거나, 완전 피벗팅(열 교환)도 고려.
3) RREF의 좌블록이 $$\mathbf{I}$$ 가 아니면 역행렬은 존재하지 않는다.
4) 자유변수 개수는 곧 영공간 차원(랭크-널리티 정리: $$\operatorname{rank}+\operatorname{nullity}=n$$).
5) 대규모·실무: 가우스-조르당보다 **LU/QR/SVD** 를 우선 고려(성능·안정성).

---

## 12. 요약

- 가우스-조르당 소거법은 확대행렬을 **RREF** 로 만들어 해를 즉시 읽고, 자유변수·랭크·영공간을 한눈에 제공합니다.
- **부분 피벗팅**이 수치적 필수 요소이고, 역행렬·랭크·기저 계산 등 다양한 응용에 직결됩니다.
- 성능 측면에서 가우스 소거+후방대입, 또는 LU/QR/SVD가 실무 기본 해법이며, 가우스-조르당은 **개념 이해·작은 문제**에 특히 유용합니다.
