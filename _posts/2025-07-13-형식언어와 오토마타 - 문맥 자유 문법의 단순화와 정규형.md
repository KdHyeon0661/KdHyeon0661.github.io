---
layout: post
title: 형식언어와 오토마타 - 문맥 자유 문법의 단순화와 정규형
date: 2025-07-13 17:20:23 +0900
category: 형식언어와 오토마타
---
# 문맥 자유 문법(CFG)의 **단순화와 정규형**

## 0. 로드맵

- **왜 단순화?** 파싱 효율·정확성, 정규형(CNF/GNF) 전환, 이론 증명 기반.
- **단계 한눈에**  
  1) **쓸모없는 기호 제거**(생성 불가능 + 도달 불가능)  
  2) **ε-생성 규칙 제거**(nullable 계산)  
  3) **단위(유닛) 규칙 제거**(A→B)  
  4) **정리/중복 제거**  
  5) **정규형 변환**: **CNF**(CYK용) / **GNF**(Top-down용)
- **실전**: 모든 단계의 **파이썬 구현** 제공 + **예제 문법** 풀 변환 흐름 + **CYK 검사** 연동.

---

## 1. 단순화(simplification)란?

> **단순화**는 문법의 언어를 유지하면서, 파싱/분석을 방해하는 **불필요한 규칙/기호를 체계적으로 제거**하는 과정.

### 기대 효과
- 파서 상태공간 축소 → **속도/메모리** 개선
- 정규형 변환(CNF/GNF) 사전 정리
- 증명/검증(멤버십, 동치성, 추론) 간결화

### 보존 불변식(Invariants)
- 변환 후 문법 \(G'\)에 대해 **언어 동치**:  
  $$L(G')=L(G)\quad(\text{단, }S\Rightarrow^*\varepsilon\text{ 처리 시 예외 규칙에 유의})$$

---

## 2. 쓸모없는 기호 제거

단계는 **두 축**으로 나누어 수행:

### 2.1 생성 불가능(Non-Generating) 기호 제거
- 정의: **어떤 터미널 문자열도** 유도하지 못하는 비터미널.
- 알고리즘(고정점):
  1) \(A\to w,\; w\in\Sigma^*\)면 \(A\)를 **생성 가능**으로 표시.
  2) \(A\to X_1\cdots X_k\)가 있고, 모든 \(X_i\)가 생성 가능이라면 \(A\)도 생성 가능.
  3) 수렴까지 반복. **생성 가능**이 아닌 기호와 관련 규칙을 제거.

### 2.2 도달 불가능(Unreachable) 기호 제거
- 정의: 시작기호 \(S\)에서 **도달할 수 없는** 비터미널/터미널.
- 알고리즘(BFS/DFS):
  1) \(S\)에서 시작해 규칙 RHS로 **그래프 탐색**.
  2) 방문되지 않은 기호와 관련 규칙 제거.

> **권장 순서**: *생성 불가능 제거 → 도달 불가능 제거* (둘 다 한 번씩 수행하고, 후속 단계 뒤에 한 번 더 정리해 주면 깔끔).

---

## 3. ε-생성 규칙 제거

### 3.1 정의
- **ε-규칙**: \(A\to\varepsilon\).
- CNF에서는 원칙적으로 **금지**, 단 **\(S\to\varepsilon\)**(언어가 빈 문자열을 포함)만 허용.

### 3.2 핵심 아이디어
- **nullable 집합** \(N_{\text{nullable}}\): \(\varepsilon\)을 유도 가능한 비터미널들의 집합.
- 모든 규칙 \(A\to X_1\cdots X_k\)에 대해, **nullable 심볼의 부분집합을 생략**하여 새 규칙을 생성.
  - 전부 생략해 \(\varepsilon\)이 되는 경우는 **시작 기호가 ε을 포함할 때만** 유지.

### 3.3 nullable 계산(고정점)
1) \(A\to\varepsilon\)이면 \(A\in N_{\text{nullable}}\).
2) \(A\to X_1\cdots X_k\)이고 모든 \(X_i\in N_{\text{nullable}}\)이면 \(A\)도 nullable.
3) 수렴까지 반복.

---

## 4. 단위(유닛) 규칙 제거

### 4.1 정의
- **단위 규칙**: \(A\to B\) (RHS가 단일 비터미널).

### 4.2 전략
- **Unit-closure** 계산: 각 \(A\)에 대해 단위규칙 경로로 도달 가능한 모든 \(B\) 집합 \(U(A)\).
- \(A\to B\) 및 \(B\to \alpha\) (단, \(\alpha\)가 단위가 아님) 이면 **\(A\to\alpha\)** 추가.
- 단위 규칙은 제거.

---

## 5. 정리 규칙(분해/중간기호 도입)

- RHS 길이가 긴 규칙을 **이항화**(길이 2 규칙 연쇄)  
  예: \(A\to BCD \Rightarrow A\to B X_1,\; X_1\to C D\)
- 터미널이 비터미널과 섞여 있으면 **프리터미널** 도입  
  예: \(A\to aB\Rightarrow A\to X_a B,\; X_a\to a\)

---

## 6. 정규형(Normal Forms)

### 6.1 CNF(Chomsky Normal Form)
- 규칙 형태:
  1) \(A\to BC\) (둘 다 비터미널)
  2) \(A\to a\) (단말 1개)
  3) **예외**: \(S\to\varepsilon\) (언어가 ε 포함 시)
- **CYK 알고리즘** 등에서 필수.

### 6.2 GNF(Greibach Normal Form)
- 규칙 형태: \(A\to a\alpha\) (항상 **터미널로 시작**), \(\alpha\in V^*\).
- **Top-down(LL) 파싱**과 상성이 좋다.
- 변환은 CNF보다 까다롭고, **좌측 재귀 제거**와 **비터미널 순서화**가 핵심.

---

## 7. 학습 예제(핵심 패턴 모두 포함)

다음 문법 \(G\) (일부 교재에서 많이 쓰는 예):

```
S → A S A | a B | ε
A → B | S | a
B → b B | ε
```

- **ε-규칙**: \(S\to\varepsilon,\; B\to\varepsilon\)
- **단위규칙**: \(A\to B,\; A\to S\)
- **혼합RHS**: \(S\to aB\) (단말+비단말)
- **이항화 필요**: \(S\to A S A\)

이 문법을 **단계별로** 정리:  
1) 생성 불가능/도달 불가능 제거(여기선 모두 생성·도달 가능이라 가정)  
2) **nullable 계산**: \(S,B\) nullable → 이에 따라 \(S\to ASA\)에서 \(A\) 생략 조합 생성 등  
3) **ε-규칙 제거**(단, 시작 기호 ε은 보존 의사결정 필요)  
4) **단위 규칙 제거**: \(A\to B/S\) 제거하고 대체  
5) **프리터미널 도입**: \(a,b\)  
6) **이항화**: 길이 ≥3 RHS 분해  
7) **CNF 완성**  
(아래 코드를 돌리면 전체 결과를 깔끔히 얻을 수 있음)

---

## 8. 파이썬 구현: **단순화 + CNF 변환** (교육용 레퍼런스)

> **약속**: 대문자(`A`,`S`,`X1` 등) = 비터미널, 소문자(`a`,`b`) = 터미널

```python
# -*- coding: utf-8 -*-
from collections import defaultdict, deque
from typing import List, Tuple, Dict, Set

Symbol = str
RHS = Tuple[Symbol, ...]

class CFG:
    def __init__(self, start: Symbol):
        self.start: Symbol = start
        self.vars: Set[Symbol] = set([start])
        self.terms: Set[Symbol] = set()
        # rules[A] = list of RHS tuples
        self.rules: Dict[Symbol, List[RHS]] = defaultdict(list)

    def add(self, A: Symbol, rhs: List[Symbol]):
        self.vars.add(A)
        tup = tuple(rhs)
        for s in tup:
            # Heuristic: lowercase => terminal, uppercase => variable
            if s and s[0].islower():
                self.terms.add(s)
            else:
                self.vars.add(s)
        self.rules[A].append(tup)

    def pretty(self) -> str:
        lines = [f"Start: {self.start}"]
        for A in sorted(self.rules.keys()):
            rhss = [" ".join(rhs) if rhs else "ε" for rhs in self.rules[A]]
            lines.append(f"{A} → " + " | ".join(rhss))
        return "\n".join(lines)

def remove_non_generating(cfg: CFG) -> CFG:
    generating = set()
    changed = True
    while changed:
        changed = False
        for A, rhss in cfg.rules.items():
            for rhs in rhss:
                if all(((s in cfg.terms) or (s in generating)) for s in rhs):
                    if A not in generating:
                        generating.add(A); changed = True
    # filter
    new = CFG(cfg.start)
    for A in cfg.rules:
        if A in generating or A == cfg.start:
            for rhs in cfg.rules[A]:
                if all((s in cfg.terms) or (s in generating)) for s in rhs:
                    new.add(A, list(rhs))
    # terms cleanup
    new.terms = {t for t in new.terms if any(t in rhs for rhss in new.rules.values() for rhs in rhss)}
    return new

def remove_unreachable(cfg: CFG) -> CFG:
    reachableV = set([cfg.start])
    reachableT = set()
    q = deque([cfg.start])
    while q:
        A = q.popleft()
        for rhs in cfg.rules.get(A, []):
            for s in rhs:
                if s in cfg.terms:
                    reachableT.add(s)
                else:
                    if s not in reachableV:
                        reachableV.add(s); q.append(s)
    # filter
    new = CFG(cfg.start)
    for A in cfg.rules:
        if A in reachableV:
            for rhs in cfg.rules[A]:
                if all((s in reachableV) or (s in cfg.terms)) for s in rhs:
                    new.add(A, list(rhs))
    new.terms = reachableT
    return new

def compute_nullable(cfg: CFG) -> Set[Symbol]:
    nullable = set()
    changed = True
    while changed:
        changed = False
        for A, rhss in cfg.rules.items():
            for rhs in rhss:
                if len(rhs) == 0:  # ε
                    if A not in nullable:
                        nullable.add(A); changed = True
                else:
                    if all((s in nullable) for s in rhs if s not in cfg.terms):
                        # 주의: 터미널이 있으면 nullable X
                        if all((s not in cfg.terms) for s in rhs):  # 모든 RHS 심볼이 비단말이고 모두 nullable
                            if A not in nullable:
                                nullable.add(A); changed = True
    return nullable

def remove_epsilon(cfg: CFG, preserve_start_epsilon=True) -> CFG:
    nullable = compute_nullable(cfg)
    S_can_epsilon = (cfg.start in nullable)
    new = CFG(cfg.start)

    def gen_subsets(rhs: RHS) -> Set[RHS]:
        # nullable 비단말 제거 조합 생성 (단, 터미널은 유지)
        idxs = [i for i, s in enumerate(rhs) if (s in nullable and s not in cfg.terms)]
        res = set()
        m = len(idxs)
        # 비트마스크로 부분집합
        for mask in range(1<<m):
            out = []
            skip = set(i for j, i in enumerate(idxs) if (mask>>j)&1)
            for i, s in enumerate(rhs):
                if i in skip: 
                    continue
                out.append(s)
            res.add(tuple(out))
        return res

    for A, rhss in cfg.rules.items():
        for rhs in rhss:
            if len(rhs) == 0:
                # ε 규칙은 일단 제거 (나중에 S->ε 복원 고려)
                continue
            # 조합 생성
            for cand in gen_subsets(rhs):
                if len(cand) == 0:
                    # 완전 소거 → ε
                    if preserve_start_epsilon and A == cfg.start and S_can_epsilon:
                        new.add(A, [])  # S→ε 보존
                else:
                    new.add(A, list(cand))

    # 중복 제거
    for A in list(new.rules.keys()):
        uniq = []
        seen = set()
        for rhs in new.rules[A]:
            if rhs not in seen:
                seen.add(rhs); uniq.append(rhs)
        new.rules[A] = uniq
    new.terms = cfg.terms.copy()
    new.vars = set(new.rules.keys())
    return new

def remove_unit(cfg: CFG) -> CFG:
    # Unit-closure
    U = {A: set([A]) for A in cfg.rules.keys()}
    changed = True
    while changed:
        changed = False
        for A, rhss in cfg.rules.items():
            for rhs in rhss:
                if len(rhs) == 1 and rhs[0] not in cfg.terms:  # A->B
                    B = rhs[0]
                    for C in U[B]:
                        if C not in U[A]:
                            U[A].add(C); changed = True
    new = CFG(cfg.start)
    # 복사: A는 U(A)에서 비-단위 규칙을 상속
    for A in cfg.rules:
        for B in U[A]:
            for rhs in cfg.rules.get(B, []):
                if len(rhs) == 1 and rhs[0] not in cfg.terms:
                    continue  # 단위 규칙 skip
                new.add(A, list(rhs))
    # 중복 제거
    for A in list(new.rules.keys()):
        uniq = []
        seen = set()
        for rhs in new.rules[A]:
            if rhs not in seen:
                seen.add(rhs); uniq.append(rhs)
        new.rules[A] = uniq
    new.terms = cfg.terms.copy()
    return new

def to_cnf(cfg: CFG) -> CFG:
    # 0) useless 제거(생성불가→도달불가 순)
    g = remove_non_generating(cfg)
    g = remove_unreachable(g)

    # 1) ε 제거 (S→ε 보존 여부는 입력에 따름)
    g = remove_epsilon(g, preserve_start_epsilon=True)

    # 2) 단위 제거
    g = remove_unit(g)

    # 3) 시작기호 새로 만들기(필수는 아니지만 안전)
    S0 = g.start + "'"
    while S0 in g.vars:
        S0 += "'"
    g2 = CFG(S0)
    g2.add(S0, [g.start])
    # 나머지 복사
    for A, rhss in g.rules.items():
        for rhs in rhss:
            g2.add(A, list(rhs))
    g2.terms = g.terms.copy()

    # 4) 터미널 격리: 비터미널 옆에 터미널이 있으면 프리터미널 도입
    preterm = {}
    def pre(A: Symbol) -> Symbol:
        if A in preterm: return preterm[A]
        X = f"X_{A}"
        k = 1
        while X in g2.vars or X in g2.terms:
            X = f"X_{A}_{k}"; k += 1
        preterm[A] = X
        g2.add(X, [A])  # X_A -> a
        return X

    # 스캔하며 치환
    tmp = CFG(g2.start)
    tmp.terms = g2.terms.copy()
    for A, rhss in g2.rules.items():
        for rhs in rhss:
            if len(rhs) == 1 and rhs[0] in g2.terms:
                # A -> a (OK)
                tmp.add(A, list(rhs))
                continue
            # 섞인 RHS에서 터미널을 프리터미널로 대체
            new_rhs = []
            for s in rhs:
                if s in g2.terms:
                    new_rhs.append(pre(s))
                else:
                    new_rhs.append(s)
            tmp.add(A, new_rhs)
    g2 = tmp

    # 5) 이항화: 길이>2 RHS 분해
    out = CFG(g2.start)
    out.terms = g2.terms.copy()
    counter = 1

    def fresh():
        nonlocal counter
        X = f"Y{counter}"
        counter += 1
        while X in out.vars:
            X = f"Y{counter}"; counter += 1
        return X

    for A, rhss in g2.rules.items():
        for rhs in rhss:
            if len(rhs) <= 2:
                out.add(A, list(rhs))
            else:
                # 체인 분해
                curr = rhs[0]
                rest = list(rhs[1:])
                while len(rest) > 1:
                    Y = fresh()
                    out.add(A, [curr, Y])
                    A = Y
                    curr = rest[0]
                    rest = rest[1:]
                out.add(A, [curr, rest[0]])

    # 중복/정리
    for A in list(out.rules.keys()):
        uniq, seen = [], set()
        for rhs in out.rules[A]:
            if rhs not in seen:
                seen.add(rhs); uniq.append(rhs)
        out.rules[A] = uniq
    return out

# ---------- 데모: 예제 문법 구성 ----------
def demo_cfg():
    G = CFG("S")
    G.add("S", ["A","S","A"])
    G.add("S", ["a","B"])
    G.add("S", [])              # ε
    G.add("A", ["B"])
    G.add("A", ["S"])
    G.add("A", ["a"])
    G.add("B", ["b","B"])
    G.add("B", [])              # ε
    return G

if __name__ == "__main__":
    G = demo_cfg()
    print("=== Original CFG ===")
    print(G.pretty())
    C = to_cnf(G)
    print("\n=== CNF ===")
    print(C.pretty())
```

### 구현 노트
- **nullable 계산**에서 “터미널 포함 RHS는 nullable X”를 구분(ε 유도는 **비단말**만 제거 가능).
- **S→ε** 보존: `remove_epsilon(..., preserve_start_epsilon=True)`.
- **프리터미널** `X_a → a` 자동 도입.
- **이항화** 시 새 비터미널(`Y1,Y2,...`) 자동 생성.

---

## 9. CNF 결과 검증: CYK 연동

위 `to_cnf` 결과를 **CYK**로 검사하려면, 다음과 같은 **unary/binary 인덱싱**이 필요합니다.  
(이미 보유하신 CYK 구현이 있다면 CNF를 그대로 투입하시면 됩니다.)

핵심은 **CNF의 규칙 집합**을  
- \(A\to a\) 형태 → `unary[a] = {A}`  
- \(A\to BC\) 형태 → `binary[(B,C)] = {A}`  
로 인덱싱하고, 표 채우기만 하면 됩니다.

> 참고: 제가 이전에 드린 CYK 레퍼런스 코드를 그대로 쓰시면 CNF를 `CNFGrammar` 객체에 옮겨 담아 `cyk_membership_with_tree`를 호출해 수용여부/트리까지 확인할 수 있습니다.

---

## 10. GNF(Greibach 정규형) 변환 개요 + 스켈레톤

> **목표 형태**: \(A\to a\alpha\) (항상 터미널로 시작)  
> **전략**: 비터미널의 토폴로지 정렬 + **좌측 재귀 제거** + “앞쪽 비터미널 치환” 반복

1) **단순화 선행**: 쓸모없는/ε/유닛 제거  
2) **비터미널 순서화**: \(A_1,\dots,A_n\)  
3) 각 \(A_i\)에 대해, 규칙 \(A_i\to A_j\gamma\) (with \(j<i\))를 **\(A_j\)의 우변**으로 치환  
4) **직접 좌측 재귀** 제거(표준 기법)  
5) 모든 규칙이 터미널로 시작될 때까지 3–4 반복

파이썬 스켈레톤(아이디어만):

```python
def to_gnf_skeleton(cfg: CFG) -> CFG:
    # 0) 단순화(ε/유닛/쓸모없는) 먼저 수행 가정
    G = remove_unit(remove_epsilon(remove_unreachable(remove_non_generating(cfg))))
    order = sorted(G.rules.keys())  # 간단 정렬(실전은 의존관계 기반 정렬 권장)

    def substitute(Ai, Aj):
        """Ai -> Aj γ 형태를 Aj의 RHS로 확장"""
        new_rhss = []
        changed = False
        for rhs in G.rules[Ai]:
            if len(rhs)>0 and rhs[0]==Aj:
                tail = rhs[1:]
                for beta in G.rules[Aj]:
                    new_rhss.append(tuple(list(beta)+list(tail)))
                changed = True
            else:
                new_rhss.append(rhs)
        if changed:
            G.rules[Ai] = new_rhss

    # 1) 상위 비터미널로 시작하는 룰을 앞에서부터 제거
    for i, Ai in enumerate(order):
        for j in range(i):
            Aj = order[j]
            substitute(Ai, Aj)

        # 2) Ai의 직접 좌측 재귀 제거
        # Ai -> Ai α | β 를 Ai -> β R, R -> α R | ε 형태로 변환
        alphas, betas = [], []
        for rhs in G.rules[Ai]:
            if len(rhs)>0 and rhs[0]==Ai:
                alphas.append(rhs[1:])
            else:
                betas.append(rhs)
        if alphas:
            R = Ai+"_R"
            G.vars.add(R)
            G.rules[R] = []
            new_ai = []
            for beta in betas:
                new_ai.append(tuple(list(beta)+[R]))
            G.rules[Ai] = new_ai
            # R rules
            for alpha in alphas:
                G.rules[R].append(tuple(list(alpha)+[R]))
            G.rules[R].append(tuple())  # ε

    # 3) 맨 앞 심볼이 터미널이 되도록 반복치환(남은 비터미널 맨앞 규칙들 제거)
    # (실전은 FIRST 집합, 무한루프 방지 등 안전장치 다수 필요)
    # 여기서는 스켈레톤이므로 생략.

    return G
```

> **주의**: GNF 변환은 구현 난도가 높습니다(무한 치환 방지, FIRST/FOLLOW, 순서화 등).  
> 실전에선 **검증된 라이브러리/도구**(예: NLTK, parsing toolkits)를 권장합니다.  
> 여기서는 **아이디어/골격**을 제시하는 수준으로 제한합니다.

---

## 11. 복잡도/주의점/베스트프랙티스

### 복잡도(대략)
- 쓸모없는 제거: \(O(|P|\cdot |V|)\)~\(O(|P|\cdot |V|^2)\)
- ε 제거: 부분집합 조합 → 최악 지수이나 실제는 **nullable 위치 수**에 비례
- 유닛 제거: 그래프 닫힘 \(O(|V|^3)\)~\(O(|V|^2)\)
- 이항화/프리터미널: 규칙 수 선형~약간 증가
- CNF 전체: 보통 **규칙 수가 증가**함(합리적 범위)

### 함정/에지 케이스
- **시작기호 ε**: CNF에서 \(S\to\varepsilon\)만 예외 허용.  
- ε 제거 후 **새로운 단위 규칙이 생길 수 있음** → 단위 제거를 ε 제거 **이후**에.  
- 단위 제거 시 **순환(A→B→A)** 반드시 클로저로 해결.  
- 프리터미널 이름 충돌 회피(위 코드에서 자동 유니크).  
- 최종 정리: 중복 규칙/죽은 비터미널 한 번 더 정리.

### 실무 팁
- CNF 결과를 **CYK**로 곧장 테스트(샘플 스트링) → 회귀 검증.
- GNF는 교육/연구/특수 파서(Top-down) 최적화용. 일반 파서 생성기는 LR/LL을 권장.

---

## 12. “상황 예제” 시나리오

### (A) DSL 프로토타입 파서
1) 사양 문법 작성(사소한 ε/유닛 섞여 있음)
2) 위 파이썬으로 **CNF 변환**
3) **CYK**로 문법 테스트 스위트(샘플) 전량 **멤버십** 확인
4) 통과 후, 엔진은 LR/LL 구현으로 이식 (단순화 과정에서 설계 결함도 쉽게 발견)

### (B) 교육/연구
- **CNF**로 언어 동치·폐포성·멤버십을 증명하는 실험  
- **GNF**로 LL 파서의 **예측 정확성**·FIRST 집합 활용 검증

---

## 13. 마무리 요약

| 단계 | 핵심 포인트 |
|---|---|
| 쓸모없는 제거 | 생성 불가능/도달 불가능 기호와 규칙 제거(고정점 + DFS) |
| ε 제거 | **nullable** 집합으로 부분집합 조합 생성(단, \(S\to\varepsilon\) 예외) |
| 단위 제거 | unit-closure로 비-단위 규칙 상속, A→B 제거 |
| CNF | \(A\to BC\) 또는 \(A\to a\) (예외 \(S\to\varepsilon\)) + 프리터미널 + 이항화 |
| GNF | \(A\to a\alpha\) (터미널 선두), 좌측 재귀 제거 + 비터미널 순서화 |
| 검증 | CYK(멤버십, \(O(n^3)\)), 필요 시 파스 트리 복원/포레스트(SPPF) |

> **핵심**: 단순화는 **언어를 보존**하면서 **분석과 파싱을 쉽게** 만들기 위한 절차다.  
> CNF/GNF는 각각 **CYK/Top-down**에 최적화된 표준형이며,  
> 제공한 **파이썬 레퍼런스**로 손쉽게 실험·검증을 반복할 수 있다.