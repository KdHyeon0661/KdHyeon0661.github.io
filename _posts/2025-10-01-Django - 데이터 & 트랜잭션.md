---
layout: post
title: Django - 데이터 & 트랜잭션
date: 2025-10-01 19:25:23 +0900
category: Django
---
# 3. 데이터 & 트랜잭션

## A. 고급 ORM — 어노테이션/서브쿼리/집계, Raw SQL, 성능 팁

### A-1. 모델 준비 (예제 공통)
```python
# apps/store/models.py
from django.db import models
from django.conf import settings

class Shop(models.Model):
    name = models.CharField(max_length=80)
    is_active = models.BooleanField(default=True)

class Category(models.Model):
    name = models.CharField(max_length=80, unique=True)

class Product(models.Model):
    shop = models.ForeignKey(Shop, on_delete=models.CASCADE, related_name="products")
    category = models.ForeignKey(Category, on_delete=models.PROTECT, related_name="products")
    name = models.CharField(max_length=120)
    price = models.PositiveIntegerField()
    stock = models.PositiveIntegerField(default=0)
    rating = models.DecimalField(max_digits=3, decimal_places=2, default=0)  # 0~5
    is_public = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)

class Order(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    shop = models.ForeignKey(Shop, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    paid = models.BooleanField(default=False)

class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="items")
    product = models.ForeignKey(Product, on_delete=models.PROTECT)
    quantity = models.PositiveIntegerField(default=1)
    unit_price = models.PositiveIntegerField()   # 주문 시점 가격 스냅샷
```

---

### A-2. 어노테이션(Annotation) & 표현식(Expression)

#### 합계/평균/Case-When/조건부 필드
```python
from django.db.models import Sum, Avg, F, Case, When, Value, IntegerField, BooleanField

# 1) 상품별 매출(주문 완료 기준)
from apps.store.models import Product, OrderItem
sales = Product.objects.annotate(
    revenue=Sum(
        Case(
            When(orderitem__order__paid=True,
                 then=F("orderitem__quantity") * F("orderitem__unit_price")),
            default=Value(0),
            output_field=IntegerField(),
        )
    )
).order_by("-revenue")

# 2) 재고 부족 플래그
low_stock = Product.objects.annotate(
    is_low=Case(
        When(stock__lte=5, then=Value(True)),
        default=Value(False),
        output_field=BooleanField(),
    )
)
```

#### 순위/윈도우 함수(PostgreSQL 등)
```python
from django.db.models import Window
from django.db.models.functions import Rank, DenseRank

ranked = Product.objects.annotate(
    price_rank=Window(
        expression=Rank(),
        partition_by=[F("category")],
        order_by=F("price").desc()
    )
).filter(price_rank__lte=3)  # 카테고리별 상위 3개
```

---

### A-3. 서브쿼리(Subquery) & Exists

#### 가장 최근 주문 시각(서브쿼리)
```python
from django.db.models import OuterRef, Subquery, DateTimeField, Max
from apps.store.models import Order

last_order = Order.objects.filter(
    shop=OuterRef("pk"),
    paid=True
).order_by("-created_at").values("created_at")[:1]

shops = Shop.objects.annotate(
    last_paid_at=Subquery(last_order, output_field=DateTimeField())
).order_by("-last_paid_at")
```

#### Exists로 “상품 보유 여부” 플래그
```python
from django.db.models import Exists

has_public_products = Product.objects.filter(
    shop=OuterRef("pk"), is_public=True
)
shops = Shop.objects.annotate(
    has_public=Exists(has_public_products)
).filter(has_public=True)
```

---

### A-4. 집계(Aggregation) & 그룹화

#### 카테고리별 통계
```python
from django.db.models import Count

stats = Product.objects.values("category__name").annotate(
    cnt=Count("id"),
    avg_price=Avg("price"),
    sum_stock=Sum("stock"),
).order_by("-cnt")
```

#### 다중 그룹 키 & Having 조건
```python
# shop + category 묶음 평균가가 2만원 이상인 그룹
qs = Product.objects.values("shop__name", "category__name").annotate(
    avg_price=Avg("price")
).filter(avg_price__gte=20000).order_by("-avg_price")
```

---

### A-5. F/Q/Raw SQL & 커스텀 함수

#### F/Q
```python
from django.db.models import Q, F

# 가격>=5만원 또는 재고>=100
qs = Product.objects.filter(Q(price__gte=50000) | Q(stock__gte=100))

# price를 10% 인상 (원자적 업데이트)
Product.objects.filter(is_public=True).update(price=F("price") * 1.1)
```

#### Raw SQL (주의해서 사용)
```python
from django.db import connection

def top_selling(limit=10):
    with connection.cursor() as cur:
        cur.execute("""
            SELECT p.id, p.name, SUM(oi.quantity * oi.unit_price) as revenue
            FROM store_product p
            JOIN store_orderitem oi ON oi.product_id = p.id
            JOIN store_order o ON o.id = oi.order_id AND o.paid = TRUE
            GROUP BY p.id, p.name
            ORDER BY revenue DESC
            LIMIT %s
        """, [limit])
        rows = cur.fetchall()
    return rows
```

> Raw SQL 팁  
> - **SQL 인젝션 방지**: 매개변수 바인딩 사용  
> - **DB 이식성 저하**: 최소화하고 ORM API로 대체 가능성 검토  
> - **스키마 리팩토링** 시 SQL 업데이트 필요

#### `raw()` / `RawSQL`
```python
from django.db.models.expressions import RawSQL

Product.objects.annotate(
    price_bucket=RawSQL("CASE WHEN price>=50000 THEN %s ELSE %s END", ["HIGH", "LOW"])
)
```

---

### A-6. N+1 방지: `select_related` / `prefetch_related`

```python
# FK/OneToOne: select_related (JOIN)
orders = OrderItem.objects.select_related("order", "product__shop").all()

# M2M/역참조: prefetch_related
prods = Product.objects.prefetch_related("orderitem_set").all()

# 고급: Prefetch로 정렬/필터 커스터마이즈
from django.db.models import Prefetch
latest_paid = Prefetch(
    "orderitem_set__order",
    queryset=Order.objects.filter(paid=True).order_by("-created_at"),
    to_attr="paid_orders"
)
prods = Product.objects.prefetch_related(latest_paid)
# 사용: prod.paid_orders[0] (있다면)
```

---

### A-7. 대량 작업 & 저장 비용 줄이기

```python
# 1) bulk_create
Product.objects.bulk_create([
    Product(shop=shop, category=cat, name="A", price=10000),
    Product(shop=shop, category=cat, name="B", price=15000),
], ignore_conflicts=True)

# 2) bulk_update
prods = list(Product.objects.filter(shop=shop)[:100])
for p in prods: p.stock += 10
Product.objects.bulk_update(prods, ["stock"])

# 3) update_or_create / get_or_create
p, created = Product.objects.update_or_create(
    shop=shop, name="C", defaults={"price": 12000}
)
```

> **주의**: bulk 계열은 `save()` 훅/시그널/검증이 호출되지 않습니다.

---

### A-8. 인덱스/쿼리 계획/튜닝 팁

- 자주 필터/정렬하는 컬럼에 **인덱스** 추가 (`models.Index`, `db_index=True`)  
- 복합 인덱스(예: `(shop_id, is_public, price)`), **쿼리 접두 일치** 활용  
- PostgreSQL: **Partial Index**, **GIN/JSONB**, **Trigram**, **B-Tree** 최적 조합  
- DB에서 **EXPLAIN** 으로 쿼리 계획 확인, 과도한 Seq Scan 주의  
- ORM 절약: 필요 컬럼만 `values()/values_list()`, **페이징**시 전체 카운트 비용 고려

---

## B. 트랜잭션 — atomic, 격리수준, 낙관/비관 락, 일관성 패턴

### B-1. `transaction.atomic()` — 단위 작업 경계

```python
from django.db import transaction

def place_order(user, cart_items):
    with transaction.atomic():
        order = Order.objects.create(user=user, shop=cart_items[0].product.shop)
        items = []
        for c in cart_items:
            # 재고 확인 & 차감
            p = Product.objects.select_for_update().get(pk=c.product_id)
            if p.stock < c.quantity:
                raise ValueError("재고 부족")
            p.stock -= c.quantity
            p.save(update_fields=["stock"])
            items.append(OrderItem(order=order, product=p, quantity=c.quantity, unit_price=p.price))
        OrderItem.objects.bulk_create(items)
        # 결제 성공 시
        order.paid = True
        order.save(update_fields=["paid"])
    return order
```

- **원자성**: 블록 전체가 성공/실패.  
- 예외 발생 시 **롤백**.  
- 중첩 atomic 시 내부에서 에러 → **savepoint** 롤백.

### B-2. 격리수준(각 DB 설정에 따름)

- SQLite: 기본 **SERIALIZABLE** 에 준하나 단일-작성자 특성  
- PostgreSQL: 기본 **READ COMMITTED**  
- MySQL(InnoDB): 기본 **REPEATABLE READ**  
- Django에서 직접 격리수준을 바꾸기보다, DB 설정/세션 레벨에서 제어하는 편.

### B-3. 비관 락(SELECT ... FOR UPDATE)

```python
def decrement_stock(product_id, qty):
    from django.db.models import F
    with transaction.atomic():
        p = Product.objects.select_for_update().get(pk=product_id)
        if p.stock < qty:
            return False
        p.stock = F("stock") - qty
        p.save(update_fields=["stock"])
        return True
```

- 행 잠금으로 **경합 조건** 방지.  
- 교착상태(deadlock)에 대비해 **재시도 로직**을 둘 것.

### B-4. 낙관 락(버전 컬럼/갱신 조건)

```python
# 모델에 버전 필드 추가
class Product(models.Model):
    # ...
    version = models.PositiveIntegerField(default=0)

def optimistic_update(product_id, qty):
    from django.db.models import F
    updated = Product.objects.filter(
        pk=product_id, stock__gte=qty
    ).update(stock=F("stock") - qty, version=F("version") + 1)
    return updated == 1  # 1행만 갱신되면 성공
```

- **조건부 업데이트**로 레이스 방지. 실패 시 클라이언트에 **재시도/새로고침** 요구.

### B-5. 일관성 패턴

- **PRG(Post-Redirect-Get)**: 중복 제출 방지  
- **Outbox 패턴**: DB 트랜잭션 내 이벤트 레코드 저장 → 별도 워커가 외부 시스템(메시지/웹훅)으로 전달  
- **Saga/보상 트랜잭션**: 분산 작업에서 단계별 보상 로직  
- **Idempotency 키**: 외부 호출/결제 재시도에서 동일 키면 **한 번만 처리**

```python
# Idempotency 키 예 (단순화)
class PaymentRequest(models.Model):
    idempotency_key = models.CharField(max_length=64, unique=True)
    status = models.CharField(max_length=16, default="NEW")

def process_payment(user, key, amount):
    with transaction.atomic():
        req, created = PaymentRequest.objects.get_or_create(
            idempotency_key=key, defaults={"status": "LOCKED"}
        )
        if not created and req.status != "NEW":
            return  # 이미 처리됨
        # 외부 결제 호출...
        req.status = "DONE"
        req.save(update_fields=["status"])
```

---

## C. 다중 DB — 라우팅, 읽기/쓰기 분리, 샤딩 전략

### C-1. 설정에서 DB 여러 개 선언
```python
# settings.py
DATABASES = {
    "default": {  # write/master
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "app_main",
        "USER": "app",
        "PASSWORD": "secret",
        "HOST": "db-master",
        "PORT": "5432",
    },
    "replica": {  # read replica
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "app_main",
        "USER": "app_ro",
        "PASSWORD": "secret",
        "HOST": "db-replica",
        "PORT": "5432",
    },
    # 샤드/아카이브 등 더 추가 가능
}
```

### C-2. DB 라우터 (읽기/쓰기 분리 기본 패턴)
```python
# apps/common/dbrouters.py
import random

class ReadWriteRouter:
    def db_for_read(self, model, **hints):
        return "replica"
    def db_for_write(self, model, **hints):
        return "default"
    def allow_relation(self, obj1, obj2, **hints):
        return True
    def allow_migrate(self, db, app_label, model_name=None, **hints):
        # 마이그레이션은 기본 DB에만
        return db == "default"
```

```python
# settings.py
DATABASE_ROUTERS = ["apps.common.dbrouters.ReadWriteRouter"]
```

> **주의**: 쓰기 직후 읽기 시 **복제 지연(replication lag)** 으로 최신 데이터가 리플리카에 없을 수 있습니다.  
> → **강제 기본 DB로 읽기**(컨텍스트 매니저) 또는 **버튼/스피너**로 사용자에게 약간 대기.

### C-3. DB 선택 강제 (`using()`)

```python
# 강제로 master에서 읽기
prod = Product.objects.using("default").get(pk=1)

# 특정 트랜잭션/뷰에서 master 고정
from django.db import connections
with connections["default"].cursor() as cur:
    cur.execute("SELECT 1")
```

또는 **미들웨어/데코레이터**로 요청 단위 “master stickiness”를 구현:
```python
# 예: POST/로그인/결제 등은 이후 몇 초간 master로 고정
from django.utils.deprecation import MiddlewareMixin
import time

class MasterStickyMiddleware(MiddlewareMixin):
    WINDOW = 3  # 초
    def process_request(self, request):
        ts = request.session.get("_master_ts", 0)
        request.use_master = (time.time() - ts) <= self.WINDOW
    def process_response(self, request, response):
        if request.method == "POST" and hasattr(request, "use_master"):
            request.session["_master_ts"] = time.time()
        return response
```

라우터에서 `request.use_master` 플래그를 읽게 하려면 **thread local**/contextvars 로 전달하는 방식이 일반적입니다.

### C-4. 샤딩(Sharding) — 키 기반 분산

- **수평 분할**: 사용자/조직 ID hash로 샤드 선택  
- Django 라우터가 `db_for_read/write` 에서 **샤드 이름 반환**  
- **장점**: 단일 DB 한계를 넘어 확장  
- **단점**: 조인/집계 어려움, 크로스 샤드 쿼리 별도 처리

샘플(아주 단순화):
```python
# apps/common/dbrouters.py
def shard_for_user(user_id, n=4):
    return f"shard_{user_id % n}"

class ShardRouter:
    def db_for_read(self, model, **hints):
        user_id = hints.get("user_id")
        if user_id is not None:
            return shard_for_user(user_id)
        return "default"
    def db_for_write(self, model, **hints):
        return self.db_for_read(model, **hints)
```

사용:
```python
UserProfile.objects.using(shard_for_user(user.id)).get(user=user)
```

> **운영 팁**: 샤드 수 증설/데이터 리밸런싱, 글로벌 카운트/랭킹의 **집계 파이프라인**(스트리밍/배치)이 필요.

---

## D. 캐시 — 로컬/Redis, per-view & per-site & low-level, 키 전략

### D-1. 캐시 백엔드 설정

```python
# settings.py
CACHES = {
  "default": {
    "BACKEND": "django.core.cache.backends.locmem.LocMemCache",  # 개발/싱글톤
    "LOCATION": "unique-app"
  },
  "redis": {
    "BACKEND": "django_redis.cache.RedisCache",
    "LOCATION": "redis://redis:6379/1",
    "OPTIONS": {"CLIENT_CLASS": "django_redis.client.DefaultClient"}
  }
}
```

> 운영은 **Redis** 권장. 멀티 프로세스/멀티 서버 간 일관성을 보장.

### D-2. Per-site, Per-view 캐시

#### 전역(사이트) 캐시 미들웨어
```python
MIDDLEWARE = [
    "django.middleware.cache.UpdateCacheMiddleware",   # 1
    # ... (중간에 다른 미들웨어)
    "django.middleware.cache.FetchFromCacheMiddleware" # 마지막 근처
]

CACHE_MIDDLEWARE_ALIAS = "redis"
CACHE_MIDDLEWARE_SECONDS = 60
CACHE_MIDDLEWARE_KEY_PREFIX = "site-v1"
```

> 로그인/세션 의존 페이지는 **Vary: Cookie** 로 분리되므로 캐시 효율↓.  
> 인증 분기가 많다면 per-site 보다는 **per-view** 또는 **low-level** 캐시를 권장.

#### 뷰 단위 캐시 데코레이터
```python
from django.views.decorators.cache import cache_page

@cache_page(60 * 2, cache="redis", key_prefix="pv1")
def trending_products(request):
    # 무거운 집계 뷰
    ...
```

### D-3. 템플릿 프래그먼트 캐시
{% raw %}
```html
{% load cache %}
{% cache 120 "hot-cards" request.user.pk %}
  {% include "includes/_hot_cards.html" %}
{% endcache %}
```
{% endraw %}

- **키 구성**에 사용자/권한/언어/디바이스 등 **파편화 변수**를 반영.

### D-4. Low-level 캐시 API

```python
from django.core.cache import cache
from django_redis import get_redis_connection

def get_product_detail(pid):
    key = f"prod:v1:{pid}"
    data = cache.get(key)
    if data is not None:
        return data
    # DB 조회
    p = Product.objects.select_related("shop", "category").get(pk=pid)
    data = {
        "id": p.id, "name": p.name, "shop": p.shop.name,
        "category": p.category.name, "price": p.price, "rating": str(p.rating),
    }
    cache.set(key, data, timeout=300)
    return data

def invalidate_product(pid):
    cache.delete(f"prod:v1:{pid}")

# Redis Lua/atomic 연산이 필요할 때
r = get_redis_connection("redis")
r.incr(f"metrics:pv:{pid}")
```

### D-5. 캐시 키 전략 & 무효화

- **버전 접두사**: `prod:v1:{id}` → 스키마/출력 변경 시 **v2**로 전환  
- **네임스페이스별 만료**: `ns:v1:*` 패턴을 모아두고 **Set**에 키를 기록 → 무효화 시 Set 스캔  
- **태그드 캐시**(라이브러리): 여러 키를 **태그**로 묶어 일괄 삭제  
- **Write-through**: DB 저장과 동시에 캐시 업데이트  
- **Cache-aside**(권장): 조회 시 캐시 조회→미스면 DB→캐시 저장, 쓰기 시 캐시 삭제

### D-6. 일관성/경합/병목 주의점

- **Dogpile(스탬피드)** 방지: **lock** 또는 **early expiration + background refresh**  
- **Hot Key**: 단일 키 집중 사용 시 **분산 키**(shard suffix), TTL 단축, CDN/에지 레이어 활용  
- **TTL 전략**: 핵심 데이터는 짧게, 대시보드/통계는 길게  
- **큰 값**: 압축/분할(하지만 Redis max memory 정책과 네트워크 비용 고려)

### D-7. 캐시 & 보안

- 인증/개인화 데이터는 **퍼블릭 캐시 금지**  
- 응답 헤더로 **Cache-Control**/`Vary` 정확히 세팅  
- **서명 URL/권한 검사**가 필요한 객체는 캐시하지 않거나, **권한별 키** 분리

---

## E. 통합 예제 — “트렌딩 상품 API”: 집계+캐시+읽기/쓰기 분리+일관성

### E-1. 뷰 로직
```python
# apps/store/api.py
from django.http import JsonResponse
from django.core.cache import cache
from django.db.models import Sum, F
from django.db import transaction
from apps.store.models import Product, OrderItem, Order

CACHE_KEY = "api:trending:v2"

def trending_api(request):
    data = cache.get(CACHE_KEY)
    if data is None:
        # 캐시 미스 → 무거운 집계 (읽기 전용, replica 사용)
        qs = (OrderItem.objects.using("replica")
              .filter(order__paid=True)
              .values("product__id", "product__name")
              .annotate(rev=Sum(F("quantity") * F("unit_price")))
              .order_by("-rev")[:10])
        data = [{"id": r["product__id"], "name": r["product__name"], "rev": int(r["rev"] or 0)} for r in qs]
        cache.set(CACHE_KEY, data, 60)  # 1분 캐시
    return JsonResponse({"items": data})
```

### E-2. 쓰기(주문 완료) 시 캐시 무효화
```python
def mark_paid(order_id):
    with transaction.atomic():
        o = Order.objects.select_for_update().get(pk=order_id)
        o.paid = True
        o.save(update_fields=["paid"])
        # 집계에 영향 → 캐시 무효화
        from django.core.cache import cache
        cache.delete(CACHE_KEY)
```

> 복제 지연으로 인한 “갓 결제한 주문이 트렌딩에 즉시 반영되지 않는” 문제를 줄이기 위해 **master stickiness**(짧은 시간 master 읽기)나 **UI 레벨 안내**를 적용.

---

## F. 운영 체크리스트 (요약)

**ORM/성능**
- [ ] `select_related/prefetch_related`로 N+1 차단  
- [ ] 어노테이션/집계는 필요한 컬럼만, 인덱스 설계 수반  
- [ ] Raw SQL은 바인딩 사용/테스트 케이스 보유  
- [ ] 쿼리 로그/슬로우 쿼리 모니터링(APM, PG Stat, MySQL Slow Log)

**트랜잭션/락**
- [ ] `atomic` 경계 명확화, 예외/재시도 정책  
- [ ] 비관락(`select_for_update`) vs 낙관락(조건부 업데이트) 선택  
- [ ] 외부 시스템 연동은 Outbox/Idempotency로 일관성 확보

**다중 DB**
- [ ] 라우터로 읽기/쓰기 분리, master stickiness  
- [ ] 복제 지연 고려(UX/정책), 강제 master 읽기 경로 제공  
- [ ] 샤딩은 키 설계/운영 도구/집계 파이프라인 준비

**캐시**
- [ ] Redis 운영/모니터링, 키 버전/네임스페이스 설계  
- [ ] 무효화 전략(Cache-aside/태그/버전)  
- [ ] 스탬피드·Hot key 방지, 민감 데이터 캐시 금지  
- [ ] 응답 헤더(Cache-Control/Vary) 일관화

---

## G. 추가 스니펫 모음

### G-1. `only()/defer()` 로 컬럼 슬림화
```python
qs = Product.objects.only("id", "name")  # 그 외 필드는 접근 시 추가 쿼리
```

### G-2. `values_list(flat=True)` 로 가벼운 리스트
```python
pids = list(Product.objects.filter(is_public=True).values_list("id", flat=True))
```

### G-3. 반복 조회에 `in_bulk()`
```python
items = Product.objects.in_bulk([1,2,3])  # {1: Product(...), 2: ...}
```

### G-4. DB 함수 조합
```python
from django.db.models.functions import Coalesce, Lower
qs = Product.objects.annotate(
    norm_name=Lower("name"),
    stock_safe=Coalesce("stock", 0),
)
```

### G-5. Redis 분산 락(간단 예)
```python
import time
from django_redis import get_redis_connection

def with_lock(key, ttl=10):
    r = get_redis_connection("redis")
    token = str(time.time())
    if r.set(f"lock:{key}", token, nx=True, ex=ttl):
        try:
            yield
        finally:
            # 토큰 확인 후 해제 (소유자만)
            if r.get(f"lock:{key}") == token.encode():
                r.delete(f"lock:{key}")

# 사용 예
for _ in with_lock("rebuild-trending"):
    rebuild_trending()
```

---

## 마무리

- **고급 ORM**으로 복잡 집계/랭킹/조건식을 **선언적**으로 표현하고, N+1·인덱스·쿼리계획에 민감하게 반응하세요.  
- **트랜잭션**은 `atomic` 경계·락 전략(비관/낙관)·Outbox/Idempotency를 조합해 **데이터 일관성**을 유지하세요.  
- **다중 DB**는 라우팅/읽기·쓰기 분리/샤딩으로 확장성을 확보하되, **복제 지연**과 **운영 난이도**를 항상 고려하세요.  
- **캐시**는 Redis 중심으로 **키 버전/무효화/스탬피드 방지**를 체계화하고, 민감 데이터를 캐시하지 않는 보안 원칙을 지키세요.