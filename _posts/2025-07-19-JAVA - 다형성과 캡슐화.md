---
layout: post
title: Java - 다형성과 캡슐화
date: 2025-07-19 18:20:23 +0900
category: Java
---
# 다형성(Polymorphism)과 캡슐화(Encapsulation)

Java는 대표적인 **객체지향 프로그래밍 언어**로서, 객체지향의 4대 특성인  
**추상화(Abstraction), 캡슐화(Encapsulation), 상속(Inheritance), 다형성(Polymorphism)**을 지원합니다.

이 글에서는 이 중에서 **다형성**과 **캡슐화**에 대해 자세히 설명합니다.

---

## ✅ 다형성 (Polymorphism)

### 1. 정의

다형성이란, **하나의 이름(인터페이스나 클래스)이 여러 형태로 동작할 수 있는 성질**을 의미합니다.

즉, 같은 메서드 호출이 객체의 타입에 따라 **다르게 동작**하는 것을 말합니다.

> "여러 형태를 가질 수 있는 능력"

---

### 2. 다형성의 종류

1. **컴파일타임 다형성 (정적 바인딩)**  
   - 메서드 오버로딩 (Overloading)
   - 생성자 오버로딩

2. **런타임 다형성 (동적 바인딩)**  
   - 메서드 오버라이딩 (Overriding)
   - 업캐스팅 + 동적 디스패치

---

### 3. 예시

```java
class Animal {
    void sound() {
        System.out.println("동물이 소리를 냅니다");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("야옹");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();  // 업캐스팅
        myAnimal.sound();             // 멍멍

        myAnimal = new Cat();
        myAnimal.sound();             // 야옹
    }
}
```

- `Animal` 타입으로 정의했지만, 실제로는 `Dog`, `Cat` 객체가 저장되어 있어 **각자 고유의 구현체가 실행**됩니다.

---

### 4. 다형성의 핵심: 업캐스팅과 동적 디스패치

- **업캐스팅(Upcasting)**: 자식 객체를 부모 타입으로 참조하는 것.
- **동적 디스패치(Dynamic Dispatch)**: 메서드 호출 시 실제 객체의 타입에 따라 **런타임에 메서드를 결정**하는 것.

---

### 5. 다형성의 장점

- 코드의 **유연성** 증가
- **인터페이스 기반 설계** 가능
- **의존성 역전 원칙(DIP)** 실현
- **전략 패턴, 상태 패턴** 등 다양한 디자인 패턴 구현에 필수

---

## ✅ 캡슐화 (Encapsulation)

### 1. 정의

캡슐화란, **객체의 내부 상태(데이터)를 외부에서 직접 접근하지 못하도록 보호**하고,  
**공개된 메서드를 통해서만 접근**하도록 하는 원칙입니다.

즉, **데이터 보호 + 인터페이스 제공**이라는 두 가지 목적을 가집니다.

> "정보 은닉 + 공개된 접근자"

---

### 2. 캡슐화 구현 방법

1. **필드(멤버 변수)는 `private`으로 선언**
2. **`getter` / `setter` 메서드로 접근 제어**

---

### 3. 예시

```java
class BankAccount {
    private int balance = 0;

    public int getBalance() {
        return balance;
    }

    public void deposit(int amount) {
        if (amount > 0)
            balance += amount;
    }

    public void withdraw(int amount) {
        if (amount > 0 && balance >= amount)
            balance -= amount;
    }
}
```

- 외부에서는 `balance`에 직접 접근할 수 없고, 오직 `deposit()`과 `withdraw()` 메서드를 통해서만 변경 가능

---

### 4. 캡슐화의 장점

- **데이터 보호**: 잘못된 값으로부터 내부 상태 보호
- **유지보수 용이성**: 내부 구현을 수정해도 외부 코드에 영향 없음
- **일관된 데이터 접근 제어**: 유효성 검사 가능
- **보안성 증가**

---

### 5. 캡슐화와 접근 제어자

| 접근 제어자 | 클래스 내부 | 같은 패키지 | 하위 클래스 | 외부 |
|-------------|-------------|--------------|--------------|------|
| `private`   | ✅ 가능      | ❌ 불가       | ❌ 불가       | ❌ 불가 |
| `default`   | ✅ 가능      | ✅ 가능       | ❌ 불가       | ❌ 불가 |
| `protected` | ✅ 가능      | ✅ 가능       | ✅ 가능       | ❌ 불가 |
| `public`    | ✅ 가능      | ✅ 가능       | ✅ 가능       | ✅ 가능 |

- 캡슐화를 위해 보통 **필드는 `private`**, **메서드는 `public` 또는 `protected`**로 선언함

---

### 6. 자바빈(JavaBean) 패턴

캡슐화된 객체를 정의할 때 자주 쓰이는 패턴

```java
public class User {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

---

## ✅ 정리

| 항목       | 다형성 (Polymorphism)                             | 캡슐화 (Encapsulation)                             |
|------------|---------------------------------------------------|-----------------------------------------------------|
| 목적       | **다양한 방식의 실행 가능성 확보**                 | **데이터 보호 및 제어된 접근 제공**                 |
| 핵심 원리  | **동적 디스패치 + 업캐스팅**                       | **정보 은닉 + 접근자 메서드**                       |
| 대표 개념  | 메서드 오버라이딩, 인터페이스, 추상 클래스         | private 변수 + public getter/setter                |
| 장점       | 코드 확장성, 유지보수 용이, 유연성                  | 보안, 안정성, 유지보수 편리                        |
| 설계 사용처| 전략 패턴, 상태 패턴, 템플릿 메서드 패턴 등         | 도메인 모델, 엔티티 설계, JavaBean 등               |

---

## ✅ 결론

- **다형성**은 객체마다 서로 다른 방식으로 **동일한 메서드를 실행**할 수 있게 만들어줍니다.
- **캡슐화**는 객체의 내부를 숨기고, 외부에서는 **제공된 인터페이스로만 조작**하도록 제한합니다.
- 둘 다 객체지향의 핵심 원리이며, 소프트웨어의 **유지보수성, 확장성, 안정성**을 향상시키는 중요한 도구입니다.
