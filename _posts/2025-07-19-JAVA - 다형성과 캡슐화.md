---
layout: post
title: Java - 다형성과 캡슐화
date: 2025-07-19 18:20:23 +0900
category: Java
---
# 다형성(Polymorphism)과 캡슐화(Encapsulation)

## 1. 다형성 (Polymorphism)

### 1.1 정의와 큰 그림
- **다형성**: 동일한 메시지(메서드 호출)가 **실제 객체의 타입**에 따라 서로 다른 동작을 수행하는 성질.
- 이때 **정적 바인딩(컴파일타임)** 과 **동적 바인딩(런타임)** 이 공존합니다.

| 구분 | 메커니즘 | 예 |
|---|---|---|
| **컴파일타임 다형성** | **오버로딩**(메서드/생성자) | `print(int)`, `print(String)` |
| **런타임 다형성** | **오버라이딩 + 동적 디스패치** | `Animal a = new Dog(); a.sound();` |

> “**호출부는 고정(상위 타입)**, **구현은 가변(하위 타입)**” 구조가 확장·변경에 유리합니다.

---

### 1.2 업캐스팅/다운캐스팅과 동적 디스패치
```java
abstract class Animal {
    abstract void sound();
}

class Dog extends Animal {
    @Override void sound() { System.out.println("멍멍"); }
}

class Cat extends Animal {
    @Override void sound() { System.out.println("야옹"); }
}

public class Demo {
    static void makeSound(Animal a) { a.sound(); } // 상위 타입 API

    public static void main(String[] args) {
        Animal a = new Dog(); // 업캐스팅
        makeSound(a);         // 동적 디스패치 → Dog.sound()

        a = new Cat();
        makeSound(a);         // → Cat.sound()
    }
}
```
- **업캐스팅**: 하위 객체를 상위 타입 참조에 담음(안전).
- **동적 디스패치**: **인스턴스 메서드**는 **런타임에 실제 객체 타입**으로 바인딩.
- **다운캐스팅**은 `instanceof`(또는 **패턴 매칭**)로 안전 확인 후 사용:
```java
Object o = getObject();
if (o instanceof String s) { // Java 16+ 패턴 매칭
    System.out.println(s.toUpperCase());
}
```

---

### 1.3 오버로딩 vs 오버라이딩 — 확실한 구분
| 항목 | 오버로딩(컴파일타임) | 오버라이딩(런타임) |
|---|---|---|
| 정의 | 동일 이름, **매개변수 시그니처 다름** | 상위 메서드를 **하위에서 재정의** |
| 결정 시점 | 컴파일 | 런타임 |
| 반환 타입 | 상관없음(다를 수 있음) | **공변 반환 타입** 허용(하위 타입으로 좁힐 수 있음) |
| 적용 대상 | 동일 클래스 내 | 상속 관계 |

> **정적 멤버(필드/메서드)** 는 **오버라이딩이 아니라 숨김(hiding)** 입니다. 다형성 대상은 **인스턴스 메서드**임에 유의.

---

### 1.4 인터페이스 기반 다형성과 전략 패턴
```java
interface Payment {
    boolean pay(int amount);
}

class CardPayment implements Payment {
    public boolean pay(int amount) { System.out.println("카드 결제"); return true; }
}

class KakaoPay implements Payment {
    public boolean pay(int amount) { System.out.println("카카오페이 결제"); return true; }
}

class CheckoutService {
    private final Payment payment; // 상위 타입 의존

    CheckoutService(Payment payment) { this.payment = payment; }

    boolean checkout(int amount) { return payment.pay(amount); }
}

public class StrategyDemo {
    public static void main(String[] args) {
        CheckoutService s1 = new CheckoutService(new CardPayment());
        CheckoutService s2 = new CheckoutService(new KakaoPay());
        s1.checkout(10000); s2.checkout(12000);
    }
}
```
- **전략(Strategy)**: 로직을 **인터페이스**로 추상화하고 런타임에 구현체를 바꿔 끼움 → **OCP(개방-폐쇄 원칙)** 실천.

---

### 1.5 다형성 컬렉션: 공통 인터페이스로 묶기
```java
interface Shape { double area(); }

class Rect implements Shape {
    private final double w, h;
    Rect(double w, double h) { this.w = w; this.h = h; }
    public double area() { return w * h; }
}

class Circle implements Shape {
    private final double r;
    Circle(double r) { this.r = r; }
    public double area() { return Math.PI * r * r; }
}

class ShapeUtil {
    static double sumArea(java.util.List<Shape> shapes) {
        return shapes.stream().mapToDouble(Shape::area).sum();
    }
}
```
- **다형적 호출**로 새 도형 추가 시 기존 코드 수정 없이 확장.

---

### 1.6 sealed 클래스와 switch 패턴 매칭 (Java 17+)
```java
sealed interface Expr permits Num, Add {}
record Num(int value) implements Expr {}
record Add(Expr left, Expr right) implements Expr {}

static int eval(Expr e) {
    return switch (e) {
        case Num n      -> n.value();
        case Add a      -> eval(a.left()) + eval(a.right());
    };
}
```
- **유한한 하위 타입 집합**을 고정(모델 안정), `switch`가 **완전성**을 컴파일러가 체크.

---

### 1.7 성능 관점: JIT와 다형성
- **`final` 메서드/클래스**, **sealed 집합이 작은 경우** 등은 JIT가 **devirtualization(inline)** 하기 쉬워 성능 유리.
- 반대로 깊은 상속/광범위한 동적 바인딩은 인라이닝 어렵게 하므로, **핫패스**에서는 인터페이스 분리/구조 단순화가 성능에 도움.

---

## 2. 캡슐화 (Encapsulation)

### 2.1 정의
- **내부 상태(필드)를 숨기고**, **공개된 메서드(계약)** 로만 접근/변경하게 하는 원칙.  
- 목적: **불변식(invariant) 보존**, **데이터 보호**, **교체 가능성** 확보.

---

### 2.2 접근 제어와 정보 은닉
| 멤버 | 권장 기본 |
|---|---|
| 필드 | `private` |
| 메서드(API) | `public`/`protected` (패키지 API는 `default`) |
| 생성자 | 경우에 따라 `private`(팩토리), `public`(일반) |

```java
public class BankAccount {
    private int balance;

    public void deposit(int amount) {
        if (amount <= 0) throw new IllegalArgumentException();
        balance += amount;
    }
    public void withdraw(int amount) {
        if (amount <= 0 || amount > balance) throw new IllegalArgumentException();
        balance -= amount;
    }
    public int getBalance() { return balance; } // 읽기 전용
}
```
- **불변식**: 잔액은 항상 0 이상. 이 규칙을 **메서드 내부에서만** 유지·검증.

---

### 2.3 컬렉션 캡슐화 — 방어적 복사/불변 뷰
```java
public class Order {
    private final java.util.List<String> items = new java.util.ArrayList<>();

    public void addItem(String i) { items.add(i); }

    public java.util.List<String> getItems() {
        return java.util.Collections.unmodifiableList(items); // 외부 수정 차단
        // 또는 return new ArrayList<>(items); // 방어적 복사
    }
}
```
- **내부 컬렉션 참조를 그대로 노출**하면 외부에서 무단 변경 가능 → 캡슐화 파괴.

---

### 2.4 불변(Immutable) 객체로 강한 캡슐화
```java
public final class Money {
    private final int amount;
    private final String currency;

    public Money(int amount, String currency) {
        if (amount < 0) throw new IllegalArgumentException();
        this.amount = amount;
        this.currency = java.util.Objects.requireNonNull(currency);
    }
    public int amount() { return amount; }
    public String currency() { return currency; }

    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) throw new IllegalArgumentException();
        return new Money(this.amount + other.amount, currency);
    }
}
```
- **모든 필드 `final`**, **세터 없음** → 생성 시점 이후 상태 불변, 동시성에도 안전.

---

### 2.5 복잡한 생성 제약 — 빌더와 팩토리
```java
public class User {
    private final String id;
    private final String email;
    private final String name;

    private User(String id, String email, String name) { /* 검증 후 할당 */ 
        this.id = id; this.email = email; this.name = name;
    }

    public static User of(String id, String email, String name) {
        // 유효성 검증 캡슐화
        if (!email.contains("@")) throw new IllegalArgumentException();
        return new User(id, email, name);
    }
}
```
- **생성 로직을 팩토리/빌더에 캡슐화** → 외부는 간결한 계약만 사용.

---

### 2.6 모듈/패키지 경계로의 확장 (Java 9+)
- `module-info.java` 의 `exports`/`opens` 로 **공개 패키지 최소화**.
- 내부 구현 패키지는 미공개로 두어 **강한 캡슐화** 실현.

---

## 3. 다형성과 캡슐화의 상호작용: 설계 가이드

1) **인터페이스에 프로그래밍**  
```java
interface Mailer { void send(String to, String body); }

class SmtpMailer implements Mailer { /* ... */ }
class MockMailer implements Mailer { /* for test */ }

class SignUpService {
    private final Mailer mailer;
    SignUpService(Mailer mailer) { this.mailer = mailer; }

    void signUp(String email) {
        // ...
        mailer.send(email, "Welcome");
    }
}
```
- 구현을 캡슐화하고, 다형성으로 교체성 확보(테스트/운영 분리).

2) **상태 전파를 막는 캡슐화**  
- 서비스/도메인 객체가 **외부 mutable 상태**를 잡고 흔들지 않도록, **불변 값**을 전달하고, 필요시 **복사본**을 사용.

3) **OCP/DIP**  
- 기능 확장은 **새 클래스를 추가**하여 다형성으로 처리, 기존 코드 수정 최소화.

---

## 4. 실전 패턴 예제

### 4.1 상태(State) 패턴 — 다형성으로 분기 제거
```java
interface VendingState {
    void insertCoin(Context c, int coin);
    void pressButton(Context c);
}

class NoCoin implements VendingState {
    public void insertCoin(Context c, int coin) { c.add(coin); c.setState(new HasCoin()); }
    public void pressButton(Context c) { System.out.println("동전 필요"); }
}
class HasCoin implements VendingState {
    public void insertCoin(Context c, int coin) { c.add(coin); }
    public void pressButton(Context c) { c.dispense(); c.setState(new NoCoin()); }
}

class Context {
    private VendingState state = new NoCoin();
    private int amount = 0;
    void setState(VendingState s) { state = s; }
    void add(int c) { amount += c; }
    void dispense() { System.out.println("상품 배출: " + amount); amount = 0; }

    // 외부 API(계약)
    void insertCoin(int coin) { state.insertCoin(this, coin); }
    void pressButton() { state.pressButton(this); }
}
```
- `if/else` 나열이 아닌, **행동을 상태 객체**로 캡슐화 → 변경에 강함.

### 4.2 템플릿 메서드 vs 전략
- **템플릿(상속)**: 골격 알고리즘은 상위, 세부 훅은 하위.
- **전략(구성)**: 알고리즘 일부를 인터페이스로 외부 주입(더 유연, 테스트 용이).

---

## 5. 흔한 함정과 예방

| 함정 | 설명 | 예방 |
|---|---|---|
| `instanceof` 분기 남발 | 다형성 대신 타입 분기 | **메서드 추상화**/방문자/상태/전략 사용 |
| 생성자에서 오버라이드 호출 | 하위 필드 미초기화 상태에서 동작 | 생성자에서는 **`final` 메서드만 호출** |
| 내부 컬렉션 노출 | 참조 노출로 외부에서 수정 | **불변 뷰/방어적 복사** |
| 세터 남발 | 무제한 상태 변경 → 불변식 붕괴 | **불변/제한적 변이** + 유효성 검증 |
| 정적 메서드 남용 | 다형성·테스트 곤란 | 인터페이스로 추상화 후 **주입** |
| 필드/정적 메서드 “오버라이딩” 오해 | 필드/정적은 숨김(hiding), 다형성 아님 | **인스턴스 메서드**만 다형성 대상 |

---

## 6. 제네릭 & 캡슐화 — 안전한 협력 경계

### 6.1 불변/가변 협력과 PECS
- **PECS(Producer Extends, Consumer Super)**:
```java
static double sumAll(java.util.List<? extends Number> src) {
    return src.stream().mapToDouble(Number::doubleValue).sum();
}
static <T> void addAll(java.util.List<? super T> dst, java.util.List<? extends T> src) {
    dst.addAll(src);
}
```
- `extends`(읽기전용 생산자), `super`(쓰기 가능 소비자)로 **타입 안정성과 캡슐화**를 함께 담보.

---

## 7. 테스트 전략 — 다형성과 캡슐화의 힘

1) **인터페이스 모킹/대역 주입**
```java
class FakeMailer implements Mailer {
    public java.util.List<String> sent = new java.util.ArrayList<>();
    public void send(String to, String body) { sent.add(to + ":" + body); }
}
```

2) **불변 도메인**은 단위 테스트가 단순: 입력→출력(새 객체) 비교.

3) **시간/외부 IO 캡슐화**(예: `Clock`, `Repository`)로 **결정적 테스트** 확보.

---

## 8. 종합 체크리스트

- [ ] 상위 타입(인터페이스/추상클래스) 계약이 **변경에 열려** 있는가?
- [ ] 인스턴스 메서드만 다형성에 참여하도록 설계했는가?
- [ ] 필드/컬렉션 **캡슐화**(불변/방어적 복사)가 되어 있는가?
- [ ] 생성자에서 오버라이드 호출 금지, 불변식 확립 완료 후 공개되는가?
- [ ] 공장/빌더로 생성 제약을 캡슐화했는가?
- [ ] 모듈/패키지 경계를 활용해 **내부 구현을 숨겼는가?**
- [ ] 테스트 가능하도록 **의존을 인터페이스로 추상화**했는가?

---

## 9. 요약 표

| 항목 | 핵심 |
|---|---|
| **다형성** | 동일 호출, 상이한 구현. **오버라이딩 + 동적 디스패치**, 인터페이스 기반 설계, 전략/상태/방문자 등 |
| **캡슐화** | 내부 상태/불변식 보호. `private` 필드, 불변/방어적 복사, 팩토리/빌더, 모듈 경계 |
| **시너지** | 인터페이스로 **교체 가능성**을 열고, 캡슐화로 **안전성**을 보장 |
| **실전 포인트** | OCP/DIP, sealed로 모델 안정, JIT 인라이닝 고려, 테스트는 대역/`Clock` 주입 |

---

## 10. 부록: 간단 예제 모음

### 10.1 공변 반환 타입
```java
class Parent { Parent copy() { return new Parent(); } }
class Child  extends Parent {
    @Override Child copy() { return new Child(); } // 하위 타입으로 좁힘(공변)
}
```

### 10.2 정적 숨김과 필드 숨김(다형성 아님)
```java
class A { static void s() { System.out.println("A"); } int x = 1; }
class B extends A { static void s() { System.out.println("B"); } int x = 2; }

A a = new B();
a.s();        // A (정적: 참조 타입 기준) — 다형성 아님
System.out.println(a.x); // 1 (필드도 참조 타입 기준)
```

### 10.3 방문자(Visitor)로 `instanceof` 제거(스케치)
```java
interface Expr { <R> R accept(Visitor<R> v); }
interface Visitor<R> { R visit(Num n); R visit(Add a); }
final class Num implements Expr { int v; Num(int v){this.v=v;} public <R> R accept(Visitor<R> v){ return v.visit(this);} }
final class Add implements Expr { Expr l,r; Add(Expr l, Expr r){this.l=l; this.r=r;} public <R> R accept(Visitor<R> v){ return v.visit(this);} }

int eval(Expr e) {
    return e.accept(new Visitor<>() {
        public Integer visit(Num n){ return n.v; }
        public Integer visit(Add a){ return eval(a.l)+eval(a.r); }
    });
}
```

---

## 결론

- **다형성**으로 **확장 가능한 구조**를 만들고, **캡슐화**로 **안전한 경계**를 세우십시오.  
- 변경은 “새 구현 추가”로 수용하고, 내부는 숨긴 채 **계약만 안정적으로 유지**하십시오.  
- 이는 **유지보수성/확장성/테스트 용이성**을 동시에 끌어올리는 객체지향의 핵심 무기입니다.