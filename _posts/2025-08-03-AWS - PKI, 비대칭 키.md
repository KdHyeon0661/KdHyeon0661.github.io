---
layout: post
title: AWS - PKI, 비대칭 키
date: 2025-08-03 22:20:23 +0900
category: AWS
---
# PKI / 비대칭 키 사용 예제 (AWS KMS로 Sign / Verify)

## 한눈에 보는 흐름

1) **KMS 비대칭 서명 키 생성** (`KeyUsage=SIGN_VERIFY`, `KeySpec=RSA_* | ECC_*`)
2) **키 정책 + IAM**: `kms:Sign`, `kms:Verify`, `kms:GetPublicKey` 최소 권한 부여
3) **서명(Sign)**: KMS `Sign` API로 프라이빗 키 서명 (RAW 또는 DIGEST)
4) **검증(Verify)**:
   - (A) KMS `Verify`로 서버측 검증, 또는
   - (B) `GetPublicKey`로 공개키를 내려받아 **OpenSSL / cryptography / WebCrypto** 등으로 **오프라인 검증**
5) **운영**: 키 수명주기/교체, CloudTrail 감사, 알고리즘 일관성, 공개키 배포/캐시/버전 전략

---

## 핵심 개념 요약 (정확한 용어 정리)

- **KMS 비대칭 키 유형**
  - **RSA**: `RSA_2048`, `RSA_3072`, `RSA_4096`
  - **ECC (NIST P-계열)**: `ECC_NIST_P256`, `ECC_NIST_P384`, `ECC_NIST_P521`
- **KeyUsage**: `SIGN_VERIFY` 로 생성해야 **Sign/Verify** API 사용 가능
- **서명 알고리즘 (대표)**
  - **RSA**: `RSASSA_PKCS1_V1_5_SHA_256`, `RSASSA_PSS_SHA_256` (SHA-384/512 버전도 선택 가능)
  - **ECDSA**: `ECDSA_SHA_256`, `ECDSA_SHA_384`, `ECDSA_SHA_512`
- **MessageType**
  - `RAW`: KMS가 내부에서 **해시를 수행**한 뒤 서명
  - `DIGEST`: 호출자가 미리 계산한 해시(다이제스트)를 전달 → KMS는 **해시하지 않음**
- **서명 출력 형식**
  - **RSA**: 고정 길이 **원시 서명 바이트**
  - **ECDSA**: **ASN.1/DER** 인코딩의 (r, s) 시퀀스
- **프라이빗 키 내보내기 불가**: KMS는 **사설키를 절대 노출하지 않음**, 검증용 **공개키**만 `GetPublicKey`로 획득

---

## 키 생성 (CLI / CDK / CloudFormation)

### CLI로 비대칭 서명 키 생성

```bash
aws kms create-key \
  --description "App Signing Key (RSA-2048)" \
  --key-usage SIGN_VERIFY \
  --key-spec RSA_2048
```

```bash
aws kms create-key \
  --description "App Signing Key (ECC P-256)" \
  --key-usage SIGN_VERIFY \
  --key-spec ECC_NIST_P256
```

> 출력의 `KeyMetadata.KeyId` 또는 `Arn`을 기록합니다.
> 실무에서는 `alias`를 만들어 사용합니다.

```bash
aws kms create-alias --alias-name alias/app-signing --target-key-id <KeyId>
```

### CDK(TypeScript)로 생성 (권장 설정 포함)

```ts
import * as cdk from 'aws-cdk-lib';
import * as kms from 'aws-cdk-lib/aws-kms';

export class KmsSigningStack extends cdk.Stack {
  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const key = new kms.Key(this, 'SigningKey', {
      description: 'App Signing Key (ECC P-256)',
      alias: 'alias/app-signing',
      keySpec: kms.KeySpec.ECC_NIST_P256,
      keyUsage: kms.KeyUsage.SIGN_VERIFY,
      enableKeyRotation: true // ECC는 의미 제한적이지만 메타 수준에서 관리 지표로 둠
    });

    // 예: 애플리케이션 역할에 최소 권한 부여
    key.grant(new iam.Role(this, 'AppRole', {
      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com')
    }), 'kms:Sign', 'kms:Verify', 'kms:GetPublicKey', 'kms:DescribeKey');
  }
}
```

### CloudFormation 스니펫

```yaml
Resources:
  SigningKey:
    Type: AWS::KMS::Key
    Properties:
      Description: App Signing Key (RSA-3072)
      KeySpec: RSA_3072
      KeyUsage: SIGN_VERIFY
      Enabled: true
      EnableKeyRotation: true
      KeyPolicy:
        Version: "2012-10-17"
        Statement:
          - Sid: Admins
            Effect: Allow
            Principal: { AWS: arn:aws:iam::123456789012:root }
            Action: "kms:*"
            Resource: "*"
          - Sid: AllowAppSign
            Effect: Allow
            Principal: { AWS: arn:aws:iam::123456789012:role/MySigningRole }
            Action:
              - kms:Sign
              - kms:Verify
              - kms:GetPublicKey
              - kms:DescribeKey
            Resource: "*"
```

---

## 권한 설계 (키 정책 & IAM) — 최소 권한 원칙

- **키 정책**: **이 키에 대해** 누가 어떤 작업을 할 수 있는지(루트 권한)
- **IAM 정책**: **주체(사용자/역할)** 가 어떤 키에 어떤 동작을 할 수 있는지

### 예시 키 정책 (요지)

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AdminsAll",
      "Effect": "Allow",
      "Principal": { "AWS": "arn:aws:iam::123456789012:root" },
      "Action": "kms:*",
      "Resource": "*"
    },
    {
      "Sid": "AppSignVerify",
      "Effect": "Allow",
      "Principal": { "AWS": "arn:aws:iam::123456789012:role/MySigningRole" },
      "Action": [ "kms:Sign", "kms:Verify", "kms:GetPublicKey", "kms:DescribeKey" ],
      "Resource": "*"
    }
  ]
}
```

**실무 팁**
- `aws:SourceIp`, `aws:PrincipalTag`, `aws:RequestTag`, `kms:ViaService` 등의 **Condition**으로 범위를 **강하게 축소**
- **Grant**(임시 권한)로 상호작용할 외부/내부 서비스에 **세밀 권한 위임** 가능

---

## 서명(Sign) — CLI / Python / Node / Java / Go

> **MessageType 선택**
> - 메시지(원문)가 작고, 단순하면 `RAW`가 편합니다.
> - **대용량/반복 서명** 또는 **해시 재사용**이면 `DIGEST`가 유리합니다.

### CLI (RAW)

```bash
# 서명할 데이터(원문)

echo -n 'hello world' > data.txt

aws kms sign \
  --key-id alias/app-signing \
  --message fileb://data.txt \
  --signing-algorithm ECDSA_SHA_256 \
  --message-type RAW \
  --output json > sign-out.json

# 서명 추출 (base64 → 바이너리)

jq -r '.Signature' sign-out.json | base64 --decode > signature.bin
```

### Python (boto3, RAW)

```python
import boto3, base64, json

kms = boto3.client('kms', region_name='ap-northeast-2')
message = b'hello world'

resp = kms.sign(
    KeyId='alias/app-signing',
    Message=message,
    MessageType='RAW',
    SigningAlgorithm='ECDSA_SHA_256'
)
sig = resp['Signature']
open('signature.bin','wb').write(sig)
```

### Python (boto3, DIGEST) — 해시를 직접 계산

```python
import boto3, hashlib

kms = boto3.client('kms', region_name='ap-northeast-2')
message = b'large payload ...'
digest = hashlib.sha256(message).digest()

resp = kms.sign(
    KeyId='alias/app-signing',
    Message=digest,
    MessageType='DIGEST',
    SigningAlgorithm='RSASSA_PSS_SHA_256'
)
open('sig.bin','wb').write(resp['Signature'])
```

### Node.js (AWS SDK v3)

```js
import { KMSClient, SignCommand } from "@aws-sdk/client-kms";
import { createHash } from "crypto";

const kms = new KMSClient({ region: "ap-northeast-2" });

const message = Buffer.from("hello world");
const digest = createHash("sha256").update(message).digest();

const out = await kms.send(new SignCommand({
  KeyId: "alias/app-signing",
  Message: digest,
  MessageType: "DIGEST",
  SigningAlgorithm: "RSASSA_PKCS1_V1_5_SHA_256"
}));

await fs.promises.writeFile("sig.bin", out.Signature);
```

### Java (AWS SDK v2)

```java
KmsClient kms = KmsClient.builder().region(Region.AP_NORTHEAST_2).build();
byte[] message = "hello world".getBytes(StandardCharsets.UTF_8);

SignRequest req = SignRequest.builder()
    .keyId("alias/app-signing")
    .message(SdkBytes.fromByteArray(message))
    .messageType(MessageType.RAW)
    .signingAlgorithm(SigningAlgorithmSpec.ECDSA_SHA_256)
    .build();

SignResponse resp = kms.sign(req);
Files.write(Paths.get("signature.bin"), resp.signature().asByteArray());
```

### Go (AWS SDK v2)

```go
cli := kms.NewFromConfig(cfg)
msg := []byte("hello world")

out, err := cli.Sign(context.TODO(), &kms.SignInput{
    KeyId:            aws.String("alias/app-signing"),
    Message:          msg,
    MessageType:      types.MessageTypeRaw,
    SigningAlgorithm: types.SigningAlgorithmSpecEcdsaSha256,
})
if err != nil { panic(err) }
os.WriteFile("sig.bin", out.Signature, 0600)
```

---

## 검증(Verify) — KMS / 로컬(OpenSSL, cryptography, WebCrypto)

### KMS `Verify` (CLI)

```bash
aws kms verify \
  --key-id alias/app-signing \
  --message fileb://data.txt \
  --signature fileb://signature.bin \
  --signing-algorithm ECDSA_SHA_256 \
  --message-type RAW
# 출력의 "SignatureValid": true 확인

```

### KMS `verify` (Python)

```python
resp = kms.verify(
    KeyId='alias/app-signing',
    Message=message,
    Signature=sig,
    SigningAlgorithm='ECDSA_SHA_256',
    MessageType='RAW'
)
print(resp['SignatureValid'])
```

### 공개키 획득 + PEM 변환 (CLI)

```bash
aws kms get-public-key --key-id alias/app-signing \
  --output text --query PublicKey | base64 --decode > pubkey.der
openssl pkey -inform DER -pubin -in pubkey.der -out pubkey.pem
```

### OpenSSL로 검증

- **RSA-PSS**

```bash
openssl dgst -sha256 -verify pubkey.pem \
  -sigopt rsa_padding_mode:pss \
  -sigopt rsa_pss_saltlen:-1 \
  -signature signature.bin data.txt
```

- **RSA PKCS#1 v1.5**

```bash
openssl dgst -sha256 -verify pubkey.pem -signature signature.bin data.txt
```

- **ECDSA (DER 서명)**

```bash
openssl dgst -sha256 -verify pubkey.pem -signature signature.bin data.txt
```

### Python(cryptography)로 검증

```python
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, ec

pub = serialization.load_pem_public_key(open('pubkey.pem','rb').read())
msg = open('data.txt','rb').read()
sig = open('signature.bin','rb').read()

# RSA PKCS1 v1.5
# pub.verify(sig, msg, padding.PKCS1v15(), hashes.SHA256())

# RSA-PSS
# pub.verify(sig, msg, padding.PSS(mgf=padding.MGF1(hashes.SHA256()),
#                                  salt_length=padding.PSS.MAX_LENGTH), hashes.SHA256())

# ECDSA

pub.verify(sig, msg, ec.ECDSA(hashes.SHA256()))
print("ok")
```

### 브라우저 WebCrypto(오프라인 검증, ECDSA 예)

> KMS 공개키(PEM)를 **SPKI**로 가져오면 WebCrypto에서 import 가능.

```js
async function importPem(pem) {
  const b64 = pem.replace(/-----(BEGIN|END) PUBLIC KEY-----/g, "").replace(/\s+/g, "");
  const der = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
  return crypto.subtle.importKey(
    "spki", der.buffer, { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]
  );
}

async function verifyEcdsa(pubKey, messageBytes, signatureDer) {
  return crypto.subtle.verify(
    { name: "ECDSA", hash: "SHA-256" },
    pubKey,
    signatureDer, // DER 그대로 가능(브라우저 구현에 따라 raw (r|s) 필요 시 변환)
    messageBytes
  );
}
```

> 일부 환경은 **raw (r||s)** 64바이트를 요구합니다. 필요 시 DER↔raw 변환 함수를 추가하세요.

---

## RAW vs DIGEST — 선택 기준과 주의점

- **RAW**
  - 간단한 케이스(짧은 메시지)에 적합, KMS가 알아서 해시
  - 메시지 바이트가 곧 **정합성 기준(해시 입력)**

- **DIGEST**
  - 대용량 메시지, 동일 메시지 다중 서명, **외부(CPU/GPU)에서 해시 최적화** 시 적합
  - 반드시 **정확한 해시 바이트**(예: SHA-256 32바이트)를 전달해야 함

**정합성 주의**:
직렬화 형식(JSON 등)은 **정규화(canonicalization)** 를 적용해 서명 전에 **바이트 표현을 고정**하세요.
예: 키 순서/공백/부동소수점 표현 차이 → 해시/서명 결과 변경.

---

## RSA vs ECDSA — 운영 상 차이

- **RSA-PSS vs PKCS#1 v1.5**
  - 보안성/표준 권고 관점에서 **PSS** 선호. 검증 측과 **패딩/해시 설정** 일치가 중요
- **ECDSA**
  - 서명이 **ASN.1/DER(r,s)**. 일부 시스템은 **raw(r||s)** 를 기대 → 변환 필요
  - ECDSA는 **서명 난수(k)** 품질에 민감했지만, KMS 내부 구현은 안전하게 관리됨

---

## JWT/JWS, 서명 헤더, 포맷 호환

- **JWS/JWT(ES256/RS256)** 과 호환 시
  - **RS256** = `RSASSA_PKCS1_V1_5_SHA_256`
  - **ES256** = `ECDSA_SHA_256`
  - 단, **JWS에서 ECDSA 서명은 raw(r||s)** 를 사용 → **KMS DER를 raw로 변환** 필요
- **헤더/Canonicalization**
  - 헤더/페이로드 **Base64URL** 직렬화 후 dot-join(`header.payload`) 바이트를 해시/서명

**DER → raw 변환(Python 예시)**

```python
from cryptography.hazmat.primitives.asymmetric.utils import decode_dss_signature
r, s = decode_dss_signature(sig_der)
# P-256은 각 32바이트 고정

raw = r.to_bytes(32, 'big') + s.to_bytes(32, 'big')
```

---

## 에러·트러블슈팅

| 증상 | 원인 | 해결 |
|---|---|---|
| `AccessDeniedException` | 키 정책 또는 IAM 정책 미허용 | 키 정책/ IAM 교차 확인 (`kms:Sign/Verify/GetPublicKey`) |
| `UnsupportedOperationException` | 키 스펙/알고리즘 불일치 | `KeySpec`에 맞는 `SigningAlgorithm` 선택 |
| 검증 실패 | 패딩/해시 불일치, 메시지 직렬화 상이 | 알고리즘·해시·MessageType·직렬화 방식을 문서화·고정 |
| OpenSSL 실패 | ECDSA DER/raw 형식 혼동 | 형식 일치(DER↔raw 변환) |
| 높은 지연/비용 | Verify를 KMS에 매번 요청 | `GetPublicKey` 후 **오프라인 검증 + 캐시** 전략 |

---

## 운영·보안 베스트 프랙티스 (체크리스트)

- [ ] **Least Privilege**: `kms:Sign/Verify/GetPublicKey/DescribeKey`만 허용
- [ ] **CloudTrail**: 모든 KMS 호출 로깅 / Athena로 탐지 쿼리
- [ ] **공개키 배포/캐시**: 만료/교체(버전) 전략 수립
- [ ] **알고리즘 일관성**: 서비스 전 구간 문서화(패딩, 해시, MessageType)
- [ ] **Canonicalization**: JSON/문서 서명 시 바이트 표현 표준화
- [ ] **멀티리전/DR**: 다중 리전 키(또는 MRAK) 전략 검토
- [ ] **성능**: 대량 검증은 로컬, **서명만 KMS**. 필요 시 비동기 큐/버퍼링
- [ ] **키 수명주기**: 교체 계획(신규 공개키 사전 배포 → 컷오버 → 구키 폐기)
- [ ] **테스트**: 샘플 데이터로 end-to-end 서명/검증 CI 테스트

---

## 수식으로 보는 검증 로직 요지 (개념)

- **RSA-PSS 검증 개념**(해시 \(H(m)\), 서명 \(s\), 공개키 \(e, n\)):
  $$
  \text{Verify}_{\text{PSS}}(m, s, e, n) \stackrel{?}{=} \text{True}
  $$
  내부적으로 \( s^e \bmod n \) 과 PSS salt/마스크 절차가 일치하면 참을 반환.

- **ECDSA 검증 개념**(곡선 계수 \(G\), 공개키 \(Q\), 서명 \((r,s)\), 해시 \(z=H(m)\)):
  $$
  \begin{aligned}
  & w = s^{-1} \bmod n \\
  & u_1 = z \cdot w \bmod n,\quad u_2 = r \cdot w \bmod n \\
  & (x_1, y_1) = u_1 G + u_2 Q \\
  & \text{유효} \iff r \equiv x_1 \pmod{n}
  \end{aligned}
  $$

> 실코드는 라이브러리가 수행하며, **해시/곡선/서명 포맷**만 올바르게 맞추면 됩니다.

---

## 실전 시나리오 별 요약 예제

### API 토큰에 서명 (서버: KMS, 클라이언트: 로컬 검증)

- 서버: `Sign(RAW|DIGEST)` → 토큰과 `signature` 반환
- 클라이언트: `GetPublicKey`로 받은 PEM(캐시) → 로컬 검증(OpenSSL/crypto/WebCrypto)
- 장점: 저지연, KMS Verify 비용 절감

### 백오피스 승인 문서 서명 (장기 보관용)

- 문서 바이트 canonicalization → `DIGEST` → `Sign`
- 서명과 공개키(혹은 키 식별자) 함께 보관, 감사를 위해 CloudTrail 이벤트 저장
- ECDSA는 DER 시그니처 그대로 보관(표준 도구 호환)

### JWT(JWS) 발급

- 헤더/페이로드 Base64URL 직렬화 바이트에 대해 해시 → `DIGEST`로 `Sign`
- RS256/ES256 매칭. ES256은 **DER→raw 변환** 후 compact JWS에 삽입

---

## Quick Assets — 스니펫 모음

### 공개키 다운로드 & 검증 원라이너 (리눅스)

```bash
aws kms get-public-key --key-id alias/app-signing \
  --output text --query PublicKey | base64 --decode > pub.der && \
openssl pkey -inform DER -pubin -in pub.der -out pub.pem && \
openssl dgst -sha256 -verify pub.pem -signature signature.bin data.txt
```

### ECDSA DER ↔ raw 변환 (Node)

```js
import asn1 from 'asn1.js';

const EcdsaSig = asn1.define('EcdsaSig', function() {
  this.seq().obj(this.key('r').int(), this.key('s').int());
});

export function derToRawP256(der) {
  const { r, s } = EcdsaSig.decode(der, 'der');
  const rB = r.toArrayLike(Buffer, 'be', 32);
  const sB = s.toArrayLike(Buffer, 'be', 32);
  return Buffer.concat([rB, sB]);
}
```

---

## 마무리

- **핵심**: KMS 비대칭 키로 **안전하게 서명**, 공개키로 **광범위/저지연 검증**.
- **실수 방지 포인트**: 알고리즘/패딩/해시/MessageType/포맷(ECDSA DER↔raw) **일관성**.
- **운영**: 최소 권한, CloudTrail 감사, 공개키 배포/버전/교체 전략, 성능/비용 균형(서명=KMS, 검증=로컬).

> 본 가이드를 적용하면 **사설키 유출 리스크 없이** PKI 기반 서명 체계를 안정적으로 운영할 수 있습니다.
