---
layout: post
title: AWS - PKI, 비대칭 키
date: 2025-08-03 22:20:23 +0900
category: AWS
---
# 🔐 PKI / 비대칭 키 사용 예제 (AWS KMS로 Sign / Verify) — 완전 가이드

이 문서는 AWS KMS의 **비대칭 키(Asymmetric keys)** 를 사용해 디지털 서명을 생성하고 검증하는 전체 워크플로우를 **개념 + 설정 + CLI / SDK / 로컬 검증 예제**까지 자세히 설명합니다.  
주요 포인트는 다음과 같습니다.

- KMS에서 **비대칭 서명 전용 키**(SIGN_VERIFY) 생성  
- KMS `Sign` API로 **서명(서명은 프라이빗 키에서 수행)**  
- KMS `Verify` API로 **검증(서명 검증을 KMS에서 수행)**  
- 또는 `GetPublicKey`로 공개키를 받아 **로컬(OpenSSL / cryptography 등)에서 검증**  
- `MessageType` (RAW / DIGEST), 서명 알고리즘, 서명 형식(RSA vs ECDSA) 차이 주의

---

## 1) 핵심 개념 요약

- **비대칭 키 종류**: RSA (RSA_2048 / 3072 / 4096), ECC (ECC_NIST_P256/384/521) 등.  
- **KeyUsage**: `SIGN_VERIFY` 로 생성해야 Sign/Verify 연산 가능.  
- **서명 알고리즘(예)**:
  - RSA 계열: `RSASSA_PKCS1_V1_5_SHA_256`, `RSASSA_PSS_SHA_256` 등
  - ECDSA 계열: `ECDSA_SHA_256`, `ECDSA_SHA_384` 등
- **MessageType**:
  - `RAW`: KMS가 내부에서 먼저 해시(예: SHA-256) → 서명
  - `DIGEST`: 호출자가 미리 해시한 바이트(예: SHA-256 다이제스트)를 전달 (KMS는 해시하지 않음)
- **서명 출력**:
  - RSA 계열: 서명 바이트(원시 바이트)  
  - ECDSA 계열: ASN.1/DER 형식의 (r,s) 시퀀스 바이트

> **중요**: KMS는 **사설키(private key)를 노출하지 않음**. 공개키(public key)만 `GetPublicKey`로 가져올 수 있음.

---

## 2) 키 생성 (예 — AWS CLI)

비대칭 서명키를 생성하려면 `KeySpec`과 `KeyUsage`를 지정합니다.

```bash
aws kms create-key \
  --description "My signing key for app" \
  --key-usage SIGN_VERIFY \
  --key-spec RSA_2048
```

- `--key-spec` 예: `RSA_2048`, `RSA_3072`, `RSA_4096`, `ECC_NIST_P256`, `ECC_NIST_P384`, `ECC_NIST_P521`  
- 출력의 `KeyMetadata.KeyId` 또는 `Arn`을 기록해 둡니다.

---

## 3) KMS 키 정책 / IAM 권한 (예)

KMS 키 정책은 **누가 키를 사용할 수 있는지**를 제어합니다. 서명/검증/공개키 조회를 허용하는 간단한 예:

```json
{
  "Version": "2012-10-17",
  "Id": "key-policy-sign-verify",
  "Statement": [
    {
      "Sid": "AllowAdministrators",
      "Effect": "Allow",
      "Principal": {"AWS": "arn:aws:iam::123456789012:root"},
      "Action": "kms:*",
      "Resource": "*"
    },
    {
      "Sid": "AllowAppRoleToSign",
      "Effect": "Allow",
      "Principal": {"AWS": "arn:aws:iam::123456789012:role/MySigningRole"},
      "Action": [
        "kms:Sign",
        "kms:Verify",
        "kms:GetPublicKey",
        "kms:DescribeKey"
      ],
      "Resource": "*"
    }
  ]
}
```

- 추가로 `kms:Grant*` 권한이나 조건(`aws:SourceIp`, `aws:PrincipalTag`)을 넣어 세분화하세요.
- **IAM 정책**에도 `kms:Sign`, `kms:Verify`, `kms:GetPublicKey` 권한을 부여해야 정상 동작합니다.

---

## 4) 서명(Sign) — AWS CLI & boto3 예제

### (A) CLI — RAW 메시지 서명

```bash
# data.txt에 서명할 메시지(원문)를 둔다고 가정
aws kms sign \
  --key-id arn:aws:kms:ap-northeast-2:123456789012:key/EXAMPLE \
  --message fileb://data.txt \
  --signing-algorithm RSASSA_PKCS1_V1_5_SHA_256 \
  --message-type RAW \
  --output json > sign-output.json
```

`sign-output.json`에 `Signature` 가 base64로 담겨 있습니다.

### (B) Python (boto3) — RAW 메시지 서명

```python
import boto3
import base64

kms = boto3.client('kms', region_name='ap-northeast-2')

with open('data.txt','rb') as f:
    message = f.read()

resp = kms.sign(
    KeyId='arn:aws:kms:ap-northeast-2:123456789012:key/EXAMPLE',
    Message=message,
    MessageType='RAW',  # or 'DIGEST' if you pass a precomputed hash
    SigningAlgorithm='RSASSA_PKCS1_V1_5_SHA_256'
)

signature = resp['Signature']  # bytes
with open('signature.bin','wb') as fh:
    fh.write(signature)
print("Signature written to signature.bin")
```

- `SigningAlgorithm` 값은 키 타입에 맞게 선택하세요. (RSA에 PSS, PKCS1; ECC에 ECDSA_SHA_*)

---

## 5) KMS에서 검증(Verify) — 권장 방법

KMS `Verify` API로 서명 여부를 확인할 수 있습니다. (서버사이드 검증)

### (A) CLI

```bash
aws kms verify \
  --key-id arn:aws:kms:ap-northeast-2:123456789012:key/EXAMPLE \
  --message fileb://data.txt \
  --signature fileb://signature.bin \
  --signing-algorithm RSASSA_PKCS1_V1_5_SHA_256 \
  --message-type RAW
```

결과의 `SignatureValid` 필드가 `true`이면 검증 성공입니다.

### (B) boto3

```python
resp = kms.verify(
    KeyId='arn:aws:kms:ap-northeast-2:123456789012:key/EXAMPLE',
    Message=message,
    Signature=signature,
    SigningAlgorithm='RSASSA_PKCS1_V1_5_SHA_256',
    MessageType='RAW'
)
print(resp['SignatureValid'])  # True / False
```

---

## 6) 공개키 가져오기(GetPublicKey) + 로컬 검증 (OpenSSL / Python)

KMS `GetPublicKey` API로 공개키를 받아서 **오프라인(로컬)**에서 검증할 수 있습니다.  
이는 분산 아키텍처에서 "KMS에 매번 Verify 요청을 보내지 않도록" public key를 배포해 검증 성능을 높일 때 유용합니다.

### 공개키 다운로드 & PEM 변환 (CLI)

```bash
aws kms get-public-key --key-id arn:aws:kms:ap-northeast-2:123456789012:key/EXAMPLE \
  --output text --query PublicKey | base64 --decode > pubkey.der

# DER -> PEM (OpenSSL)
openssl pkey -inform DER -pubin -in pubkey.der -out pubkey.pem
```

### OpenSSL으로 검증 (RSA - PSS 예시)

RSA-PSS 서명 검증(예: RSASSA_PSS_SHA_256)의 경우 OpenSSL 옵션 필요:

```bash
# RSA-PSS (saltlen = same as hash = -1 for maximal)
openssl dgst -sha256 -verify pubkey.pem \
  -sigopt rsa_padding_mode:pss \
  -sigopt rsa_pss_saltlen:-1 \
  -signature signature.bin data.txt
```

결과가 `Verified OK` 이면 성공.

### OpenSSL으로 ECDSA 검증 (DER 서명)

```bash
openssl dgst -sha256 -verify pubkey.pem -signature signature.bin data.txt
```

ECDSA 서명은 KMS가 DER(ASN.1) 형식으로 반환하므로 OpenSSL에서 바로 검증 가능합니다.

### Python(cryptography) 로컬 검증 예 (RSA PKCS1 v1.5 & ECDSA)

```python
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, ec
from cryptography.hazmat.primitives.serialization import load_pem_public_key

# load public key
with open('pubkey.pem','rb') as f:
    pubkey = load_pem_public_key(f.read())

# RSA PKCS1 v1.5 verify
pubkey.verify(
    signature,                      # signature bytes from KMS
    message,                        # original message bytes
    padding.PKCS1v15(),
    hashes.SHA256()
)

# RSA-PSS verify
pubkey.verify(
    signature,
    message,
    padding.PSS(
        mgf=padding.MGF1(hashes.SHA256()),
        salt_length=padding.PSS.MAX_LENGTH
    ),
    hashes.SHA256()
)

# ECDSA verify (DER signature)
pubkey.verify(
    signature,
    message,
    ec.ECDSA(hashes.SHA256())
)
```

- ECDSA의 경우 KMS가 반환한 서명(ASN.1/DER)을 그대로 사용하면 됩니다.

---

## 7) MessageType: RAW vs DIGEST — 언제 무엇을 쓸까?

- **RAW**: 작은 메시지(로그, 토큰 등)를 바로 보내면 KMS가 내부에서 해시후 서명. 보통 사용하기 간단.  
- **DIGEST**: 전송 메시지가 크거나, 동일한 메시지에 대해 여러 번 서명/검증하려면 호출자가 미리 해시한 다이제스트(예: SHA-256)를 `Message`로 전달하고 `MessageType='DIGEST'`로 지정.  
  - 이 경우 KMS는 해시를 다시하지 않으므로, 호출자는 정확한 다이제스트(바이트)값을 전달해야 합니다.

**주의**: `DIGEST`를 사용할 때는 반드시 정확한 바이트(예: raw 32바이트 SHA-256)가 전달되는지 확인하세요.

---

## 8) 서명 형식 차이(RSA vs ECDSA) — 검증 시 주의점

- **RSA**: 서명은 고정 길이 바이트(키 길이). 검증할 때 패딩(PS S / PKCS#1 v1.5) 옵션을 정확히 매칭해야 함.  
- **ECDSA**: KMS가 반환하는 서명은 **ASN.1/DER** 포맷의 (r,s). 로컬 라이브러리(OpenSSL, cryptography)는 이 형식을 이해함.  
- 검증을 로컬에서 할 경우, KMS `SigningAlgorithm` 선택이 public-key 검증 쪽 구현과 일치해야 합니다.

---

## 9) 운영 팁 & 보안 모범 사례

- **사설키는 KMS 내부에만**: private key는 절대 노출 불가. 공개키만 배포하세요.  
- **키 정책 최소화**: `Sign/Verify/GetPublicKey`만 필요한 주체에만 허용하세요.  
- **CloudTrail 로깅 활성화**: KMS `Sign` / `Decrypt` 호출 기록을 감사하세요.  
- **public key 유효기간/배포 방식 설계**: 오프라인 검증을 위해 공개키를 배포할 때는 교체/만료 전략을 세우세요 (예: key versioning).  
- **Verify vs GetPublicKey 사용**:
  - KMS `Verify`는 안전하지만 레이턴시와 비용 발생.  
  - 대량 트래픽/저지연 검증이 필요하면 공개키를 캐시해 로컬 검증(오프라인)을 사용.  
- **알고리즘 일관성**: 생성→서명→검증의 알고리즘(SHA, padding) 설정을 문서화하여 불일치로 인한 실패 방지.  
- **메시지 포맷 표준화**: canonicalization 필요 시(예: JSON 서명) 바이트 포맷을 서비스 전체에서 동일하게 유지하세요.

---

## 10) 전체 예제 워크플로우 (요약)

1. `aws kms create-key --key-usage SIGN_VERIFY --key-spec ECC_NIST_P256` (또는 RSA)  
2. 키 정책에 애플리케이션 역할에 `kms:Sign`, `kms:GetPublicKey`, `kms:Verify` 권한 추가  
3. 애플리케이션에서 `Sign` 호출 → KMS가 private key로 서명 → 서명 바이트 반환  
4. 수신자(또는 검증자)는:
   - (옵션 A) KMS `Verify` API 호출로 원격 검증  
   - (옵션 B) `GetPublicKey` → 공개키 PEM으로 변환 → 로컬(OpenSSL / cryptography)으로 검증  
5. 검증 성공 시 메시지 무결성 및 송신자 인증 확보

---

### 참고(빠른 커맨드 모음)
```bash
# 1. Create asymmetric signing key
aws kms create-key --description "signing key" --key-usage SIGN_VERIFY --key-spec ECC_NIST_P256

# 2. Sign (CLI)
aws kms sign --key-id <keyid> --message fileb://data.txt --signing-algorithm ECDSA_SHA_256 --message-type RAW --output json

# 3. Get public key & convert
aws kms get-public-key --key-id <keyid> --output text --query PublicKey | base64 --decode > pub.der
openssl pkey -inform DER -pubin -in pub.der -out pub.pem

# 4. Verify with OpenSSL
openssl dgst -sha256 -verify pub.pem -signature signature.bin data.txt
```

---

### 결론

AWS KMS의 비대칭(Sign/Verify) 기능은 **사설키의 안전한 보관**, **표준 알고리즘( RSA / ECDSA ) 지원**, 그리고 **공개키 배포를 통한 오프라인 검증** 등 PKI를 클라우드 환경에서 안전하고 편리하게 구현할 수 있게 해줍니다.  
운영 시에는 **키 정책과 IAM 권한**, **MessageType / 서명 알고리즘 일치**, **공개키 배포 및 교체 전략**, **CloudTrail 감사**에 특히 주의하세요.
