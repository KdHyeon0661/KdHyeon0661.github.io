---
layout: post
title: 컴퓨터시스템 - 지역성
date: 2025-08-06 18:20:23 +0900
category: 컴퓨터시스템
---
# 지역성(Locality)

## 0. 개요 — “왜 지역성이 전부처럼 보이는가”

- CPU가 나노초 단위로 계산하더라도, **데이터가 제때 오지 않으면** 파이프라인은 멈춘다.  
- 지역성(Locality)은 **최근/근접 데이터 재사용**을 가정하여,  
  상단(레지스터/L1)에서 **대부분의 요청을 소화**하도록 돕는 **설계 원리**다.
- 핵심 효과는 **AMAT**(Average Memory Access Time) 단축과 **MLP**(메모리 병렬성) 확대.

---

## 1. 지역성의 두 축 — 시간·공간 (+파생 개념)

### 1.1 시간 지역성(Temporal)
- 가까운 미래에 **다시** 사용할 가능성이 높은 접근 경향.
- 예: 루프 누적 변수, 핫함수의 코드·상수 테이블.

### 1.2 공간 지역성(Spatial)
- 접근한 주소 **근처**의 데이터를 곧 사용할 가능성.
- 예: 배열 **순차** 접근, 함수 본문 **연속** 명령어 fetch.

### 1.3 파생 개념(실무에 자주 등장)
- **재사용 거리(Reuse Distance, Stack Distance)**: 두 번의 접근 사이 **서로 다른 유니크 주소 개수**.  
  → 분포를 누적하면 **MRC(Miss Ratio Curve)**를 얻고 캐시 용량-미스율 관계를 예측.
- **작업셋(Working Set)**: 관찰 창에서 **동시에 필요한** 고유 데이터 집합의 크기.  
- **스트라이드(Stride) 패턴**: 일정 간격 접근(예: `a[i+K]`). K가 커질수록 공간 지역성 약화.

---

## 2. 메모리 계층 & 캐시 동작 요약

```
레지스터 → L1I/L1D (코어 전용) → L2 (코어 전용/근접) → L3/LLC(소켓 공유)
                                     ↓
                                   DRAM
                                     ↓
                               SSD/HDD(스토리지)
```

- **라인(블록) 단위** 전송(일반적으로 64B). 한 바이트가 필요해도 **라인 전체가 이동**.  
- **세트-연관(Set-assoc)** 매핑 + **치환 정책**(LRU 근사).  
- **쓰기 정책**: write-back/allocate(보편) vs write-through/no-allocate(스트리밍).  
- **TLB**는 가상→물리 변환 캐시. **TLB reach = 엔트리×페이지크기**가 워킹셋보다 작으면 비용↑.

---

## 3. 성능 모델 — AMAT·3C(+1C)·MRC

### 3.1 AMAT
$$
\text{AMAT} = T_{L1} + m_1\big(T_{L2} + m_2\big(T_{L3} + m_3 T_\text{Mem}\big)\big)
$$
- \(m_k\): 레벨 \(k\) 미스율. 상위에서 미스를 줄일수록 **기하급수적 이득**.

### 3.2 3C(+1C) 미스 분해
- **Compulsory**: 처음 보는 데이터(콜드).  
- **Capacity**: 용량 부족 교체.  
- **Conflict**: 동일 세트로 몰려 충돌.  
- **Coherence(+1C)**: 멀티코어 쓰기 무효화(폴스 셰어링 포함).

### 3.3 MRC/재사용거리로 지역성 정량화
- 재사용거리 분포 \(D(x)\)로부터 **캐시 용량 \(C\)**에서의 미스율 \(M(C)\) 근사(**Stack property** 가정).  
- 실무 포인트: 파이프라인 단계별 **작업셋**을 줄이면 **모든 캐시**의 미스율이 동반 하락.

---

## 4. 지역성-좋고/나쁜 패턴 — 코드로 보는 체감

### 4.1 행-주도(row-major) vs 열-주도(column-major)

```c
// N×N 정수 배열 합산: 행-주도(좋음) vs 열-주도(나쁠 수 있음)
int sum_row(int (*a)[N]){
  int s=0;
  for(int i=0;i<N;i++)
    for(int j=0;j<N;j++)
      s += a[i][j];      // stride 1
  return s;
}

int sum_col(int (*a)[N]){
  int s=0;
  for(int j=0;j<N;j++)
    for(int i=0;i<N;i++)
      s += a[i][j];      // stride N → 라인/페이지 미스↑
  return s;
}
```

**효과**: 동일 연산이라도 **접근 순서**만 바꿔 큰 차이. 공간 지역성을 **캐시 라인**이 극대화.

### 4.2 AoS → SoA (구조체 배열 → 열지향)

```c
// AoS
typedef struct { float x,y,z; } V3;
void norm_aos(V3* v, int n){
  for(int i=0;i<n;i++){ float x=v[i].x, y=v[i].y, z=v[i].z; v[i].x = x*x+y*y+z*z; }
}

// SoA
typedef struct { float *x, *y, *z; } V3SoA;
void norm_soa(V3SoA v, int n){
  #pragma omp simd
  for(int i=0;i<n;i++){ float x=v.x[i], y=v.y[i], z=v.z[i]; v.x[i] = x*x+y*y+z*z; }
}
```

**효과**: 한 축(열)만 쓰는 루틴에서 **SoA가 연속 접근**을 보장 → 벡터화·대역 효율↑.

### 4.3 그래프·포인터 추적(나쁜 공간 지역성의 전형)
- 인접 리스트의 **랜덤 포인터**는 **라인 히트율**이 낮고, **MLP**도 1에 가깝다.  
- 대응: **정렬/압축(간선 재배치)**, **BFS-순회 순서 재배열** 등으로 지역성 회복.

---

## 5. 지역성 최적화 기술 총정리

### 5.1 루프 변환
- **Interchange**: 안/밖 루프 교환(행-주도화).  
- **Blocking/Strip-mining(타일링)**: 블록 크기를 **L1/L2 용량**에 맞춰 재사용 극대화.  
- **Fusion**: 같은 인덱스 범위를 한 번 훑으며 여러 연산 수행(메모리 통과 횟수 감소).  
- **Fission**: 캐시/레지스터 압박이 심할 때 루프 분리.

### 5.2 데이터 레이아웃
- **SoA 전환**, **정렬(Alignment)**, **패딩**으로 세트 충돌/폴스 셰어링 방지.  
- **압축 포맷**(bitset, packed)으로 **작업셋 축소**.

### 5.3 불필요한 참조 제거
- **스칼라 치환(SRA)**: 같은 원소 **한 번만 로드** 후 레지스터 재사용.  
- **루프 불변량 호이스팅**: 상수·포인터를 루프 밖으로.

```c
for(int i=0;i<n;i++){ float xi=x[i], yi=y[i]; y[i] = yi + a*xi; } // 중복로드 방지
```

### 5.4 프리패칭과 스트리밍
- **하드웨어 프리패처**: 순차/스트라이드 패턴 자동 추적.  
- **소프트웨어 프리패치**: 규칙적 패턴에서 거리 \(d\)를 지연/반복당 사이클로 추정해 튜닝.
```c
void sum_prefetch(const float *a,int n){
  float s=0;
  for (int i=0;i<n;i+=64){
    __builtin_prefetch(&a[i+256], 0, 1); // 예상 읽기
    for(int k=0;k<64 && i+k<n;k++) s+=a[i+k];
  } (void)s;
}
```
- **Non-temporal store**: “한 번 쓰고 안 보는” 큰 결과 버퍼는 캐시 오염 없이 내보내기.

### 5.5 TLB/NUMA
- **Huge Page**로 TLB reach↑, **First-touch**로 로컬 노드 배치.
```c
#pragma omp parallel for
for(long i=0;i<n;i++) a[i]=0; // 초기화도 병렬 → NUMA 로컬
```

### 5.6 동시성 & 폴스 셰어링
- 스레드 로컬/샤딩 + **라인 정렬/패딩**으로 무효화 폭주 방지.
```c
typedef struct { _Alignas(64) long v; } pad64;
static pad64 cnt[64];
```

---

## 6. 블로킹(타일) 행렬 곱 — 지역성의 교과서적 사례

```c
void gemm_blocked(int n, float *restrict A, float *restrict B, float *restrict C, int Bsz){
  for(int ii=0; ii<n; ii+=Bsz)
    for(int jj=0; jj<n; jj+=Bsz)
      for(int kk=0; kk<n; kk+=Bsz){
        int im = ii+Bsz < n ? ii+Bsz : n;
        int jm = jj+Bsz < n ? jj+Bsz : n;
        int km = kk+Bsz < n ? kk+Bsz : n;
        for(int i=ii;i<im;i++)
          for(int j=jj;j<jm;j++){
            float acc = C[i*n+j];
            for(int k=kk;k<km;k++) acc += A[i*n+k]*B[k*n+j];
            C[i*n+j] = acc;
          }
      }
}
```

**블록 크기 가이드(경험칙)**:
$$
B \approx \sqrt{\frac{\alpha \cdot C_\mathrm{cache}}{\text{element\_size}\cdot \text{(동시에 잡을 행렬 수)}}}
$$
- \(\alpha\): 메타데이터/연관도 여유 계수(0.5~0.8로 시작→실측 튜닝).

---

## 7. 지역성의 정량 모델 몇 가지

### 7.1 히트율·미스율
- $$\text{Hit Ratio}=\frac{\text{Hits}}{\text{Accesses}},\quad \text{Miss Ratio}=1-\text{Hit Ratio}$$
- AMAT와 결합하면 **지연 절감** 추정 가능.

### 7.2 재사용거리 → 미스율(MRC) 근사
- **Stack property**를 만족하는 캐시에 대해, 재사용거리 분포 \(D(x)\)로 용량 \(C\)에서의 미스율 \(M(C)\)를 계산.  
- 실무에서는 **샘플 기반 재사용거리 히스토그램**(발그린드·프로파일러)으로 캐시 용량 감도 분석.

---

## 8. 마이크로벤치 — “전/후” 실험 키트

### 8.1 공통 유틸(측정 타이머)
```c
#include <time.h>
double now_sec(){
  struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
  return t.tv_sec + t.tv_nsec*1e-9;
}
```

### 8.2 행 vs 열, 그리고 타일링
```c
#include <stdio.h>
#include <stdlib.h>
#ifndef N
#define N 4096
#endif

int (**make_mat)();
static int **mat;

void prepare(){
  mat = malloc(sizeof(*mat)*N);
  int *all = NULL;
  posix_memalign((void**)&all, 64, sizeof(int)*N*N);
  for(int i=0;i<N;i++){ mat[i] = all + i*N; }
  for(int i=0;i<N*N;i++) all[i] = i&1;
}

long long sum_row(int **a){
  long long s=0;
  for(int i=0;i<N;i++) for(int j=0;j<N;j++) s += a[i][j];
  return s;
}
long long sum_col(int **a){
  long long s=0;
  for(int j=0;j<N;j++) for(int i=0;i<N;i++) s += a[i][j];
  return s;
}

int main(){
  prepare();
  double t0=now_sec(); volatile long long r1=sum_row(mat); double t1=now_sec();
  volatile long long r2=sum_col(mat); double t2=now_sec();
  printf("row=%.3fs, col=%.3fs, diff=%lld\n", t1-t0, t2-t1, (long long)(r1-r2));
}
```

**컴파일/실행**
```bash
gcc -O3 -march=native bench.c -o bench
perf stat -e cycles,instructions,IPC,\
L1-dcache-load-misses,LLC-load-misses,dTLB-load-misses ./bench
```
- 기대: **row ≪ col**, LLC/dTLB 미스 차이 뚜렷.

### 8.3 스트라이드 스윕(캐시/라인/TLB 관찰)
```c
// 배열에서 stride를 바꿔가며 합산
double sweep_stride(double *a, int n, int stride){
  double s=0;
  for(int i=0;i<n;i+=stride) s += a[i];
  return s;
}
```
- stride=1,2,4,…,4096 을 돌리며 시간/미스율 로그 → **라인/페이지 경계**에서 기울기 변화.

### 8.4 AoS→SoA 전환 실험
- 동일 연산에서 **IPC↑, LLC miss↓, 벡터화 보고서** 확인(`-fopt-info-vec`).

### 8.5 프리패치 거리 튜닝
- `__builtin_prefetch(ptr+K)`의 **K**를 바꿔 중앙값 최소점 탐색(플랫폼별 상이).

---

## 9. 동시성 하에서의 지역성

- **스레드-데이터 바인딩**(작업 분할 시 파티션을 고정)으로 **캐시 재사용** 유지.  
- **폴스 셰어링 제거**: 스레드별 버퍼/카운터를 **라인 정렬**.  
- **Queue**: SPSC(한 생산자·한 소비자) 링버퍼는 캐시 친화적.

---

## 10. 파일/스토리지 계층의 지역성

- **페이지 캐시**와 **리드어헤드**가 순차 접근을 가속.  
- 랜덤 I/O는 병합/버퍼링으로 **순차화**(Merge/Compaction).  
- **압축 블록 크기**와 **I/O 블록 크기** 일치 → 중복 fetch 최소화.

---

## 11. 검증 — 올바른 측정 절차와 보고

### 11.1 실험 프로토콜
- **워밍업**(I$·D$·TLB), 동일 입력으로 **N회 반복**, **중앙값 + 95% CI**.  
- **카운터**: `IPC, LLC/dTLB-miss, stalled-frontend/backend, branch-misses`.  
- **환경 통제**: 고정 주파수(governor performance), 코어 고정, 동일 메모리 압력.

### 11.2 보고 양식(예)
- 성능: `row 0.73s → 0.41s (−44%)`, `col 1.89s`.  
- 원인: “row-major + 타일링 → **LLC miss −38%**, dTLB miss −62%”.  
- 증거: `perf stat/report`, 플레임그래프 전/후.  
- 부수효과: 바이너리 크기 +2%, 코드 복잡도 증가(주석 추가).  
- 리스크: 블록 크기 튜닝 민감, 다른 아키텍처에서 재검증 필요.

---

## 12. 자주 겪는 함정(FAQ)

- **과도한 인라인/언롤** → **I$/μop$ 압박**으로 역효과(프런트엔드 스톨↑).  
- **프리패치 남용** → 포트/대역 낭비, **거리** 튜닝 필수.  
- **Huge Page 만능이 아님**: 작은 워킹셋/랜덤 접근에는 이득 제한.  
- **SoA 전환의 비용**: API/직렬화와의 호환성 고려—핫패스만 교체.

---

## 13. 실전 체크리스트(바로 적용)

- [ ] 문제 지표: p95/처리량/비용을 **숫자**로 고정.  
- [ ] **접근 순서**: 행-주도? 스트라이드 1? 루프 interchange 검토.  
- [ ] **타일링**: L1/L2에 맞춘 블록 크기 실측 튜닝.  
- [ ] **레이아웃**: AoS→SoA, 정렬/패딩, 폴스 셰어링 방지.  
- [ ] **SRA/불변 호이스팅**: 중복 로드 제거.  
- [ ] **프리패치/스트리밍 저장**: 패턴/거리 타당성 검증.  
- [ ] **TLB/NUMA**: Huge Page, First-touch, 스레드 핀 고정.  
- [ ] `perf`로 IPC/미스율/스톨 원인 **숫자**로 확인.

---

## 14. 부록 — 간단 수식 모음

- **AMAT**  
  $$
  \text{AMAT} = T_{L1} + m_1\big(T_{L2} + m_2\big(T_{L3} + m_3 T_\text{Mem}\big)\big)
  $$
- **속도 향상 추정(미스율 변화)**  
  $$
  \Delta T \approx \Delta m_1\cdot T_{L2\downarrow} + m_1\cdot \Delta m_2\cdot T_{L3\downarrow} + \cdots
  $$
- **작업셋–미스율 직관**  
  캐시 용량 \(C\)에서 작업셋 \(W\le C\)이면 capacity miss 급감, \(W\gg C\)이면 포화.

---

## 15. 마무리

지역성은 **데이터 이동을 최소화**하는 설계·코드 습관의 총칭이다.  
핵심은,
1) **접근 순서**를 바꾸고(행-주도/타일링/SoA),  
2) **불필요한 로드**를 없애며(SRA/호이스팅),  
3) **TLB/NUMA/동시성**의 시스템 이슈를 함께 다루는 것.  
이 글의 코드와 측정 절차(AMAT·MRC 관점)를 루틴에 넣으면,  
“왜 빨라지는지”와 “어디까지 빨라질 수 있는지”를 **정량**으로 설명하며 성능을 끌어올릴 수 있다.