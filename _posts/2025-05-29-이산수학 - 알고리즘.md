---
layout: post
title: 이산수학 - 알고리즘
date: 2025-05-29 18:20:23 +0900
category: 이산수학
---
# 알고리즘(Algorithm)

## 알고리즘이란 무엇인가

**알고리즘(Algorithm)**은 어떤 문제를 해결하기 위한 **유한 단계의 명확한 절차**이다. 표준 요건:

- 명확성: 각 단계는 모호하지 않다.
- 유한성: 유한 시간/단계 내 종료한다.
- 입력: 0개 이상.
- 출력: 1개 이상.
- 효과성: 각 단계는 수행 가능하고 비용이 제한된다.

형식화된 관점에서, 알고리즘은 **튜링 기계**, **RAM 모델**, **λ-계산** 등 위에서 기술되며, 상수 요인 차이를 무시하면 다들 동치의 계산력을 갖는다.

---

## 알고리즘의 역사(아주 간략히)

- 유클리드(기원전): 최대공약수 알고리즘.
- 알 콰리즈미: 대수 절차 정리(algorithm 어원의 기원).
- 튜링: 계산 가능성의 형식화(튜링 기계).
- 폰 노이만: 프로그램 저장 방식의 체계화.

---

## 복잡도 분석: 시간/공간과 점근적 표기

### 점근적 표기 정의

$$
\begin{aligned}
&f(n)=O(g(n)) \iff \exists c>0,\ \exists n_0,\ \forall n\ge n_0:\ 0\le f(n)\le c\,g(n).\\
&f(n)=\Omega(g(n)) \iff \exists c>0,\ \exists n_0,\ \forall n\ge n_0:\ 0\le c\,g(n)\le f(n).\\
&f(n)=\Theta(g(n)) \iff f(n)=O(g(n))\ \text{이고}\ f(n)=\Omega(g(n)).\\
&f(n)=o(g(n)) \iff \lim_{n\to\infty}\frac{f(n)}{g(n)}=0.\\
&f(n)=\omega(g(n)) \iff \lim_{n\to\infty}\frac{f(n)}{g(n)}=\infty.
\end{aligned}
$$

시간 복잡도는 **기본 연산 횟수**의 점근적 상한/하한으로 정의한다. 공간 복잡도는 **추가 메모리 사용량**의 점근적 크기다.

### 모델과 단위 비용 가정

RAM 모델에서 산술·메모리 접근을 상수 시간으로 가정한다(워드 크기 제한 포함). 외부메모리/캐시 민감 분석이 필요할 때는 I/O 모델을 사용한다.

### 상용 표기와 서열

$$
1 \ll \log n \ll \sqrt n \ll n \ll n\log n \ll n^2 \ll n^3 \ll 2^n \ll n!\ .
$$

---

## 재귀와 마스터 정리

점화식 $$T(n)=a\,T(n/b)+f(n)$$, $$a\ge 1, b>1$$ 에 대해:

- (1) $$f(n)=O\!\left(n^{\log_b a-\epsilon}\right)$$ 이면 $$T(n)=\Theta\!\left(n^{\log_b a}\right).$$
- (2) $$f(n)=\Theta\!\left(n^{\log_b a}\log^k n\right)$$ 이면 $$T(n)=\Theta\!\left(n^{\log_b a}\log^{k+1} n\right).$$
- (3) $$f(n)=\Omega\!\left(n^{\log_b a+\epsilon}\right)$$ 이고 정규성 조건(예: $$a f(n/b)\le c f(n)$$ for some $$c<1$$)이면 $$T(n)=\Theta(f(n)).$$

예: 병합 정렬은 $$a=2,b=2,f(n)=\Theta(n)$$ 이므로 $$T(n)=\Theta(n\log n).$$

---

## 암ortized 분석: 동적 배열 push 예

용량이 꽉 찰 때마다 2배로 확장하는 push의 총 비용은 $$n$$ 번의 삽입에 대해 $$\Theta(n)$$, 즉 평균(암ortized) 비용은 $$\Theta(1)$$.

**포텐셜 방법**: 배열에 원소 수를 $$m$$, 용량을 $$C$$ 라면 포텐셜을 $$\Phi=2m-C$$ 로 둔다(음수는 0으로 클램프 가능). 삽입의 실제 비용 + 포텐셜 증가는 상수로 상계됨을 보일 수 있다.

---

## 올바름 증명: 루프 불변식, 전/후조건

**루프 불변식**은 루프의 각 반복 시작 시 참인 성질. 정당성 증명 3요소:

1) 초기화: 첫 진입 전에 참.
2) 유지: 한 반복 후에도 참.
3) 종료: 루프 종료 조건과 불변식을 함께 쓰면 사후조건 도출.

예: 삽입 정렬에서 불변식은 "인덱스 i 이전은 정렬되어 있다".

---

## 자료구조 요약(평균/최악)

| 구조 | 접근 | 검색 | 삽입 | 삭제 | 비고 |
|------|------|------|------|------|------|
| 배열 | O(1) | O(n) | O(n) | O(n) | 인덱스 접근 강점 |
| 연결리스트 | O(n) | O(n) | O(1)* | O(1)* | *포인터 알려짐 |
| 스택/큐 | O(n) | O(n) | O(1) | O(1) | push/pop, enqueue/dequeue |
| 힙(이진) | — | — | O(log n) | O(log n) | 최댓값/최솟값 우선 |
| 해시테이블 | — | O(1) | O(1) | O(1) | 충돌시 평균, 최악 O(n) |
| BST(평균) | O(log n) | O(log n) | O(log n) | O(log n) | 균형 필요 |
| Red-Black/AVL | O(log n) | O(log n) | O(log n) | O(log n) | 균형 보장 |
| 유니온-파인드 | — | — | α(n) | α(n) | 경로압축+랭크 |

---

## 대표 알고리즘 모음과 코드

### 최대공약수(유클리드)

```python
def gcd(a, b):
    while b:
        a, b = b, a % b
    return abs(a)
```

- 시간: O(log min(a,b)).
- 불변식: 각 반복에서 gcd(a,b)=gcd(b,a mod b).

### 이진 탐색(정렬 배열)

```python
def binary_search(a, x):
    lo, hi = 0, len(a) - 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if a[mid] == x:
            return mid
        if a[mid] < x:
            lo = mid + 1
        else:
            hi = mid - 1
    return -1
```

- 시간: O(log n).
- 전제: a는 오름차순 정렬.

### 정렬

#### 삽입 정렬(안정)

```python
def insertion_sort(a):
    for i in range(1, len(a)):
        key = a[i]
        j = i - 1
        while j >= 0 and a[j] > key:
            a[j+1] = a[j]
            j -= 1
        a[j+1] = key
    return a
```

- 최악: O(n^2). 작은 n, 거의 정렬된 데이터에 강함.

#### 병합 정렬(안정, O(n log n))

```python
def merge_sort(a):
    if len(a) <= 1:
        return a
    m = len(a) // 2
    L = merge_sort(a[:m])
    R = merge_sort(a[m:])
    i=j=0
    out=[]
    while i < len(L) and j < len(R):
        if L[i] <= R[j]:
            out.append(L[i]); i+=1
        else:
            out.append(R[j]); j+=1
    out.extend(L[i:]); out.extend(R[j:])
    return out
```

#### 퀵 정렬(평균 O(n log n), 제자리, 불안정)

```python
def quick_sort(a, lo=0, hi=None):
    if hi is None: hi = len(a)-1
    if lo >= hi: return
    p = partition(a, lo, hi)
    quick_sort(a, lo, p-1)
    quick_sort(a, p+1, hi)

def partition(a, lo, hi):
    pivot = a[hi]
    i = lo
    for j in range(lo, hi):
        if a[j] <= pivot:
            a[i], a[j] = a[j], a[i]
            i += 1
    a[i], a[hi] = a[hi], a[i]
    return i
```

- 피벗 선택 개선: 랜덤 피벗, 삼중 중앙값 등으로 최악 회피.

#### 힙 정렬(O(n log n), 제자리)

```python
def heap_sort(a):
    import heapq
    h = []
    for v in a:
        heapq.heappush(h, v)
    out = [heapq.heappop(h) for _ in range(len(h))]
    return out
```

- 표준 구현은 O(n) 빌드 + O(n log n) pop. 제자리 힙정렬은 배열 기반 heapify 사용.

### 선택(Quickselect, 평균 O(n))

```python
import random
def quickselect(a, k):
    if len(a) == 1: return a[0]
    pivot = random.choice(a)
    L = [x for x in a if x < pivot]
    E = [x for x in a if x == pivot]
    G = [x for x in a if x > pivot]
    if k < len(L): return quickselect(L, k)
    if k < len(L) + len(E): return pivot
    return quickselect(G, k - len(L) - len(E))
```

### 그래프 탐색: BFS/DFS

```python
from collections import deque

def bfs(adj, s):
    n = len(adj)
    dist = [-1]*n
    q = deque([s])
    dist[s]=0
    while q:
        u = q.popleft()
        for v in adj[u]:
            if dist[v] == -1:
                dist[v] = dist[u] + 1
                q.append(v)
    return dist

def dfs(adj, s):
    n=len(adj); seen=[False]*n; order=[]
    def go(u):
        seen[u]=True; order.append(u)
        for v in adj[u]:
            if not seen[v]: go(v)
    go(s)
    return order
```

- BFS: 최단 간선 수 거리(무가중).
- DFS: 위상정렬, 사이클 탐지, 컴포넌트.

### 최단경로: 다익스트라(양의 가중)

```python
import heapq

def dijkstra(adj_w, s):
    # adj_w[u] = list of (v, w)
    n=len(adj_w)
    INF=10**18
    dist=[INF]*n; dist[s]=0
    pq=[(0,s)]
    while pq:
        d,u=heapq.heappop(pq)
        if d!=dist[u]: continue
        for v,w in adj_w[u]:
            nd=d+w
            if nd<dist[v]:
                dist[v]=nd
                heapq.heappush(pq,(nd,v))
    return dist
```

- 시간: O((n+m) log n).
- 음수 가중이 있으면 벨만-포드 또는 SPFA(실무 주의) 사용.

### 최소 신장 트리: Kruskal + Union-Find

```python
class DSU:
    def __init__(self, n):
        self.p=list(range(n)); self.r=[0]*n
    def find(self, x):
        if self.p[x]!=x:
            self.p[x]=self.find(self.p[x])
        return self.p[x]
    def union(self, a, b):
        a=self.find(a); b=self.find(b)
        if a==b: return False
        if self.r[a]<self.r[b]: a,b=b,a
        self.p[b]=a
        if self.r[a]==self.r[b]: self.r[a]+=1
        return True

def kruskal(n, edges):
    # edges: (w,u,v)
    dsu=DSU(n); mst=[]; total=0
    for w,u,v in sorted(edges):
        if dsu.union(u,v):
            mst.append((u,v,w)); total+=w
    return total, mst
```

- 시간: O(m log m) ~ O(m α(n)).
- Prim(이진 힙)은 O(m log n) 도 유용.

### 위상 정렬(DAG)

```python
from collections import deque

def topo_sort(adj):
    n=len(adj)
    indeg=[0]*n
    for u in range(n):
        for v in adj[u]:
            indeg[v]+=1
    q=deque([i for i in range(n) if indeg[i]==0])
    out=[]
    while q:
        u=q.popleft(); out.append(u)
        for v in adj[u]:
            indeg[v]-=1
            if indeg[v]==0: q.append(v)
    if len(out)!=n: raise ValueError("cycle")
    return out
```

### 동적 계획법(DP)

#### LCS(최장 공통 부분수열)

```python
def lcs(a, b):
    n, m = len(a), len(b)
    dp = [[0]*(m+1) for _ in range(n+1)]
    for i in range(n-1, -1, -1):
        for j in range(m-1, -1, -1):
            if a[i]==b[j]:
                dp[i][j]=dp[i+1][j+1]+1
            else:
                dp[i][j]=max(dp[i+1][j], dp[i][j+1])
    # 복원은 포인터 추적
    return dp[0][0]
```

#### 0-1 배낭 문제

```python
def knapsack_01(W, wt, val):
    n=len(wt)
    dp=[0]*(W+1)
    for i in range(n):
        for w in range(W, wt[i]-1, -1):
            dp[w]=max(dp[w], dp[w-wt[i]]+val[i])
    return dp[W]
```

### 그리디

#### 활동 선택(최대 비중단 활동 수)

```python
def activity_selection(intervals):
    # intervals: (start, end)
    intervals=sorted(intervals, key=lambda x: x[1])
    res=[]; last_end=-10**18
    for s,e in intervals:
        if s>=last_end:
            res.append((s,e)); last_end=e
    return res
```

#### 허프만 코딩(최소 가중 경로 길이)

```python
import heapq
def huffman_cost(freqs):
    h=freqs[:]  # list of weights
    heapq.heapify(h)
    cost=0
    while len(h)>1:
        a=heapq.heappop(h); b=heapq.heappop(h)
        c=a+b; cost+=c
        heapq.heappush(h,c)
    return cost
```

### 문자열 알고리즘

#### KMP 전처리 및 검색

```python
def kmp_table(p):
    m=len(p); lps=[0]*m
    j=0
    for i in range(1,m):
        while j>0 and p[i]!=p[j]:
            j=lps[j-1]
        if p[i]==p[j]:
            j+=1; lps[i]=j
    return lps

def kmp_search(s, p):
    lps=kmp_table(p); i=j=0; res=[]
    while i<len(s):
        if s[i]==p[j]:
            i+=1; j+=1
            if j==len(p):
                res.append(i-j); j=lps[j-1]
        else:
            if j>0: j=lps[j-1]
            else: i+=1
    return res
```

- 시간: O(n+m).

#### 라빈-카프(해시 기반)

```python
def rabin_karp(s, p, base=257, mod=10**9+7):
    n, m = len(s), len(p)
    if m==0: return list(range(n+1))
    if m>n: return []
    power=1
    for _ in range(m-1): power=(power*base)%mod
    hp=0; hs=0
    for i in range(m):
        hp=(hp*base+ord(p[i]))%mod
        hs=(hs*base+ord(s[i]))%mod
    res=[]
    for i in range(n-m+1):
        if hp==hs and s[i:i+m]==p:
            res.append(i)
        if i<n-m:
            hs=(hs - ord(s[i])*power)%mod
            hs=(hs*base+ord(s[i+m]))%mod
    return res
```

### 수학 기반 루틴

#### 빠른 거듭제곱(제곱 분할)

```python
def mod_pow(a, e, mod):
    r=1; a%=mod
    while e>0:
        if e&1: r=(r*a)%mod
        a=(a*a)%mod; e>>=1
    return r
```

#### 에라토스테네스의 체

```python
def sieve(n):
    isprime=[True]*(n+1)
    isprime[0]=isprime[1]=False
    p=2
    while p*p<=n:
        if isprime[p]:
            for k in range(p*p, n+1, p):
                isprime[k]=False
        p+=1
    return [i for i,v in enumerate(isprime) if v]
```

---

## 백트래킹과 상태 공간 탐색

### N-Queen(해 넣기만 카운트)

```python
def nqueen_count(n):
    cols=set(); diag1=set(); diag2=set()
    ans=0
    def go(r):
        nonlocal ans
        if r==n:
            ans+=1; return
        for c in range(n):
            if c in cols or (r-c) in diag1 or (r+c) in diag2:
                continue
            cols.add(c); diag1.add(r-c); diag2.add(r+c)
            go(r+1)
            cols.remove(c); diag1.remove(r-c); diag2.remove(r+c)
    go(0)
    return ans
```

- 가지치기 핵심: 유망성 테스트의 O(1) 유지.

---

## 무작위화와 기대 분석

### 랜덤 퀵정렬: 기대 O(n log n)

피벗을 균등 무작위로 고르면 분할의 기대 균형이 확보된다. 표준 증명은 지표변수와 선형성으로 **비교 횟수의 기대값**을 $$\Theta(n\log n)$$ 으로 보인다.

### 저수지 샘플링(스트리밍에서 균등 1개)

```python
import random
def reservoir_sample(stream):
    res=None
    for i, x in enumerate(stream, start=1):
        if random.randrange(i)==0:
            res=x
    return res
```

- 어떤 위치의 원소도 확률 $$1/n$$ 로 선택됨(귀납/조건부 확률로 증명).

---

## 그래프 최단 경로 총정리

- 무가중: BFS.
- 양의 가중: 다익스트라.
- 음수 가중(음수 사이클 없음): 벨만-포드(모든 간선 완화를 n-1회).
- 모든 쌍: 플로이드-워셜(동적 계획, O(n^3)).

플로이드-워셜 점화:
$$
D^{(k)}[i,j]=\min\left(D^{(k-1)}[i,j],\ D^{(k-1)}[i,k]+D^{(k-1)}[k,j]\right).
$$

---

## NP-완비와 근사

- P, NP, NP-hard, NP-complete의 개념.
- 다항식 시간 환원으로 난이도 전달.
- 근사: 예를 들어, 가중치가 양수인 그래프의 MST는 TSP(메트릭) 2-근사 경로의 기반이 된다(더 엄밀한 버전은 크리스토피데스 1.5-근사).

---

## 캐시/메모리 계층을 고려한 설계

- **연속 접근**이 임의 접근보다 빠르다(지역성).
- 병합 정렬은 큰 순차 스캔 중심이라 캐시 친화적.
- 해시테이블/트리 튜닝: 로드 팩터, 페이지 크기 고려.
- 외부 메모리 모델: 블록 크기 $$B$$, 주 메모리 크기 $$M$$. I/O 복잡도 최적화 기법(분할 단계에서 블록 정렬, 멀티웨이 병합 등).

---

## 테스트, 벤치마킹, 디버깅

- 유닛 테스트: 경계값(빈 입력, 최대/최소 값, 중복 키).
- 난수 데이터와 최악 데이터 둘 다 실험.
- 성능 계측: 중복 실행, 워밍업, 변동 구간 제거.
- 정밀 시간 측정 시 시스템 노이즈 고려.

간단한 정렬 비교 스켈레톤:

```python
import random, time

def bench():
    funcs = [
        ("insertion", lambda a: insertion_sort(a[:])),
        ("merge", lambda a: merge_sort(a[:])),
        ("quick", lambda a: (lambda b: (quick_sort(b), b)) (a[:])[1]),
        ("heap", lambda a: heap_sort(a[:])),
    ]
    for n in [100, 1000, 5000]:
        a = [random.randint(0, 10**6) for _ in range(n)]
        print("n=", n)
        for name, f in funcs:
            b = a[:]
            t0=time.perf_counter()
            _=f(b)
            t1=time.perf_counter()
            print(name, round((t1-t0)*1000, 3), "ms")
```

---

## 면접/실무 체크리스트

- 정확성: 전제(정렬 여부, 가중 음수 여부)를 코드/문서로 고지했는가.
- 입력 크기: 최악 n, m에 대해 시간/공간이 감당 가능한가.
- 안정성/제자리성: 정렬/선택 알고리즘 특성 요구사항 충족 여부.
- 경계 처리: 빈 구조, 길이 1, 중복 키, 음수/0, 오버플로우.
- 난수/시드: 재현성 필요 시 시드 고정.
- 실패 모드: 메모리 부족, 타임아웃, 예외 처리.
- 테스트 커버리지: 정상·경계·오류·스트레스 케이스.

---

## 실전 활용 예시 시나리오

1) 로그 스트림에서 임의 이벤트 균등 샘플 → 저수지 샘플링.
2) URL 중복 제거 → 체계적 해시테이블, 로드팩터 제어.
3) 지도 최단 경로 → 도로는 양의 가중: 다익스트라 + 우선순위 큐. 대규모면 히어라키/전처리.
4) 자동완성 → Trie/접두사 배열, 혹은 정렬 + 이진탐색 범위 쿼리.
5) 대용량 정렬 → 외부 정렬(스풀 정렬, 멀티웨이 병합).

---

## 수학적 부가: 올바름/수행시간의 형식적 스케치

### 삽입 정렬 올바름(요지)

불변식: 반복 시작 시 항상 $$A[0..i-1]$$ 는 오름차순 정렬이며 원래 원소의 멀티셋과 동일. 초기화는 길이 1로 자명, 유지/종료는 교환 규칙으로 따른다. 종료 시 $$i=n$$ 이므로 전체 정렬.

### 병합 정렬 시간

$$
T(n)=2T(n/2)+\Theta(n)\Rightarrow T(n)=\Theta(n\log n)\ (\text{마스터 정리 2케이스}).
$$

---

## 연습문제

1) 선택 알고리즘(Quickselect)의 평균 시간 O(n) 증명을 지표변수로 스케치하라.
2) 동적 배열의 암ortized 상수 삽입을 포텐셜 함수로 증명하라.
3) KMP의 실패함수(lps)의 불변식을 기술하라.
4) Kruskal의 올바름을 컷 속성(cut property)로 설명하라.
5) 다익스트라의 부정 예: 음수 가중 간선 1개를 구성하고 왜 실패하는지 보여라.

---

## 부록: 추가 알고리즘 스니펫

### 벨만-포드(음수 가중 허용, 음수 사이클 검출)

```python
def bellman_ford(n, edges, s):
    INF=10**18
    dist=[INF]*n; dist[s]=0
    for _ in range(n-1):
        updated=False
        for u,v,w in edges:
            if dist[u]!=INF and dist[u]+w<dist[v]:
                dist[v]=dist[u]+w; updated=True
        if not updated: break
    # 음수 사이클 체크
    for u,v,w in edges:
        if dist[u]!=INF and dist[u]+w<dist[v]:
            raise ValueError("negative cycle")
    return dist
```

### 플로이드-워셜

```python
def floyd_warshall(dist):
    # dist: n x n, 자기 자신 0, 없으면 INF
    n=len(dist)
    for k in range(n):
        dk=dist[k]
        for i in range(n):
            di=dist[i]
            aik=di[k]
            if aik==float('inf'): continue
            s=aik
            for j in range(n):
                via=s+dk[j]
                if via<di[j]:
                    di[j]=via
    return dist
```

### LIS O(n log n) 길이

```python
import bisect
def lis_len(a):
    d=[]
    for x in a:
        i=bisect.bisect_left(d, x)
        if i==len(d): d.append(x)
        else: d[i]=x
    return len(d)
```

---

## 결론

알고리즘은 문제를 **정확하고 효율적으로** 해결하기 위한 언어다.
핵심은 세 가지 축이다:

1) **정확성**: 불변식/귀납으로 올바름을 보장.
2) **효율성**: 점근적 분석(시간/공간/암ortized/I-O)으로 현실적 성능을 예측.
3) **적합성**: 문제 구조(가중치, 제약, 데이터 규모/분포)와 환경(메모리, 캐시, 병렬성)에 맞게 기법을 고른다.

이 문서를 바탕으로 각 기법을 더 깊게 파고들면, 실무와 면접 모두에서 설계·분석·검증 역량을 빠르게 확장할 수 있다.
