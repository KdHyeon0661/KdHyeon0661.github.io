---
layout: post
title: 웹해킹 - 난독화
date: 2025-09-30 14:25:23 +0900
category: 웹해킹
---
# 🧩 난독화(Obfuscation) — 개념, 기법, 실무 적용, 한계와 우회 리스크까지 한 번에

## 0) 난독화란?

**난독화(Obfuscation)**는 소스/바이너리의 **의미는 유지**하면서도 **사람·도구가 분석하기 어렵게** 만드는 변환 기법입니다.  
목표는 크게 3가지:

1. **리버스 엔지니어링 비용 증가**(지식재산 보호)  
2. **자동화 공격/스크립트의 분석 지연**(안티-스크래핑/치트 방지 보조)  
3. **탐지 회피/무결성 강화**(악용 방지: 무결성 체크, 안티-디버깅, 탬퍼 감지 등과 결합)

> 핵심 원칙: **보안 레이어** 중 하나일 뿐. 서버 검증, 코드 서명, 비밀 관리, 접근 통제와 **함께** 써야 효과가 있습니다.

---

## 1) 위협 모델과 기대효과

### 1.1 공격자 모델
- **정적 리버스**: 난독화된 코드/바이너리를 디어셈블·디컴파일해서 의미를 추출  
- **동적 분석**: 런타임 훅킹·트레이싱·디버깅·메모리 덤프  
- **하이브리드**: 정적 분석으로 주요 지점을 파악하고, 동적으로 키/분기/테이블을 수집

### 1.2 난독화로 얻는 것
- **분석 시간·비용 상승**: 저숙련 크래커/봇은 이탈  
- **취약점 악용 속도 지연**: 패치까지의 **완충 시간** 확보  
- **지식재산 보호**: 알고리즘·룰셋·치트 탐지 로직의 직접 노출 감소

### 1.3 난독화로 **못** 얻는 것
- **절대적 비밀 보호**(특히 클라이언트 비밀키): 메모리·네트워크·런타임에서 결국 드러남  
- **취약점 자체 제거**: 취약 로직은 난독화해도 **취약**합니다

---

## 2) 난독화 주요 기법(언어 무관 개념)

| 분류 | 설명 | 예시/효과 |
|---|---|---|
| **식별자 난독화** | 변수/함수/클래스명을 무의미한 토큰으로 변경 | `calculateScore → a1, b2…` |
| **제어 흐름 변형** | 분기/루프를 평탄화(flattening), 난수 기반 점프, 스위치 테이블화 | 디컴파일 시 읽기 어려움 |
| **상수/문자열 암호화** | 문자열·숫자 상수를 런타임 복호화 | `"license:ok"` → 난수 배열 + 복호화 |
| **데드 코드 삽입** | 의미 없는 분기·연산 추가 | 분석가의 시야 분산 |
| **연산 난독화** | 단순 연산을 등가 변환·폴리모픽 변환 | `x+1 → (x^k)⊕((k^1)-…` |
| **가상화/인터프리터화** | 핵심 로직을 커스텀 바이트코드와 VM으로 실행 | 상업 도구(VMProtect 등) 계열 |
| **안티-디버깅/탬퍼** | 디버거 감지·CRC/해시 검증·무결성 체크 | 디버깅/패치 난이도 증가 |
| **리소스 스플릿/지연 로딩** | 민감 루틴을 외부 모듈·WASM로 분리, 사용 전까지 해석 불가 | 공격 타이밍 제한 |

---

## 3) 언어/플랫폼별 난독화 — “취약 → 적용 → 주의점” 실전

### 3.1 JavaScript/TypeScript(프런트엔드·Node)

#### 3.1.1 베이직: 식별자 축약 + 난독화
**원본**
```js
// src/payment.js
export function verifyCoupon(code, total) {
  if (!code) return total;
  if (code === "HELLO10") return total * 0.9;
  return total;
}
```

**Terser(축약) 결과(예시)**
```js
function n(o,t){return o?"HELLO10"===o?.9*t:t:t}export{n as verifyCoupon};
```
- 장점: **크기 감소 + 약한 가독성 저하**  
- 한계: 간단한 **beautify**로 쉽게 읽힘

**javascript-obfuscator(난독화) 결과(요약)**
```js
var _0x4d2a=['HELLO10'];function _0x3a1b(_0x5f29b4,_0x4655b8){...}
export function verifyCoupon(_0x2c2f9d,_0x1d7b2c){
  if(!_0x2c2f9d){return _0x1d7b2c;}
  if(_0x2c2f9d===_0x4d2a[0x0]){return 0.9*_0x1d7b2c;}
  return _0x1d7b2c;
}
```
- 문자열 테이블화, 인덱스 참조 → **정적 분석 비용↑**

#### 3.1.2 문자열 암호화 + 런타임 복호화
```js
const ENC = [0x15,0x07,0x1A,0x1A,0x0F,0x02,0x1E,0x1D]; // "HELLO10" XOR 예시
function dec(a){return String.fromCharCode(...a.map((c,i)=>c ^ (0x55+i)));}
export function verifyCoupon(c,t){const k=dec(ENC);return c&&c===k?t*0.9:t;}
```
- **디버깅 시 dec 결과는 메모리에 노출** → 키·중요 상수는 **서버 검증**이 정답

#### 3.1.3 빌드 파이프라인 예(프로그램 방식)
```js
// build/obfuscate.js
import JavaScriptObfuscator from 'javascript-obfuscator';
import fs from 'node:fs';

const src = fs.readFileSync('dist/app.js','utf8');
const { getObfuscatedCode } = JavaScriptObfuscator.obfuscate(src, {
  compact: true,
  controlFlowFlattening: true,
  deadCodeInjection: true,
  stringArray: true,
  stringArrayThreshold: 0.75,
  debugProtection: false
});
fs.writeFileSync('dist/app.obf.js', getObfuscatedCode());
console.log('[OK] obfuscated → dist/app.obf.js');
```

#### 3.1.4 프런트엔드 베스트 프랙티스
- **Source Map 분리 배포**(내부 전용): 고객 환경에는 미배포 또는 접근 제한  
- **중요 검증은 서버**: 할인율·권한·점수·제한 등  
- **WASM로 핵심 분리**: 공격자 난이도 상승(완전 보호 아님)

---

### 3.2 Java/Kotlin(Android)/JVM

#### 3.2.1 ProGuard/R8 기본(식별자 축약·리소스 최적화)
**Gradle**
```gradle
android {
  buildTypes {
    release {
      minifyEnabled true         // R8 활성화
      shrinkResources true
      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
    }
  }
}
```

**proguard-rules.pro**
```pro
# 공용 API/리플렉션 대상은 유지
-keep class com.example.api.** { *; }
-keepclassmembers class * {
  @com.google.gson.annotations.SerializedName <fields>;
}
# 로그 제거(예시)
-assumenosideeffects class android.util.Log { public static *** d(...); }
```

#### 3.2.2 문자열 암호화/런타임 복호화(예시)
```java
public final class Secret {
  private static final byte[] C = new byte[]{(byte)0x21,(byte)0x12,(byte)0x34};
  public static String dec() {
    StringBuilder sb = new StringBuilder();
    for (int i=0;i<C.length;i++) sb.append((char)(C[i] ^ (0x5A+i)));
    return sb.toString(); // "key" 예시
  }
}
```
- **Dex 디컴파일에 취약** → R8 난독화 + **네이티브/JNI**로 일부 이관, 그러나 **서버 검증**이 근본

#### 3.2.3 안드로이드 추가 레이어
- **Play Integrity / SafetyNet** 검사 결합  
- **Root/Frida/디버거 감지**(탬퍼 방지), 무결성 체크섬  
- **동적 코드 로딩 금지**(혹은 서명 검증)

---

### 3.3 iOS(Swift/Objective-C)
- Swift는 이름 난독화 효과가 상대적으로 제한 → **LLVM 기반 변환**(예: OLLVM)·**기호 숨김**·**링커 스크립트** 활용  
- **앱 무결성**(코드 서명)·**Jailbreak/디버거 감지**·**네트워크 측 검증**과 결합

**심볼 스트립(예시)**
```bash
# 빌드 시 Swift/ObjC 심볼 최소화(실제 프로젝트는 Xcode 설정에서)
strip -S -x MyApp.app/MyApp
```

---

### 3.4 .NET(C#/VB)

- **식별자 난독화 + 문자열 암호화 + 제어 흐름**: 상용/오픈소스 도구 다수  
- **IL이 풍부**하여 디컴파일이 쉬움 → **AOT(ReadyToRun)/네이티브 이미지**+ 난독화 병행

**문자열 지연 복호화(간단 예)**
```csharp
static string Dec(byte[] a){ for(int i=0;i<a.Length;i++) a[i]^=(byte)(0x6D+i); return Encoding.UTF8.GetString(a); }
public static bool Check(string s){ var k=Dec(new byte[]{0x01,0x0C,0x0C}); return s==k; } // "key"
```

---

### 3.5 Python

- 바이트코드 배포(.pyc)만으로는 **쉽게 디컴파일**됨  
- **C 확장/네이티브 래퍼**·**WASM/서버 사이드 이동**·**패키지 동적 분석 저해(런타임 결합)**로 난이도 상승

**간단한 런타임 복호화 예(교육용)**
```python
KEY = 0x55
ENC = [0x39,0x30,0x31]  # "api" XOR 예시
def dec():
    return ''.join(chr(c ^ KEY) for c in ENC)

def validate(token):
    return token == dec()
```

---

### 3.6 C/C++ 네이티브

- **제어 흐름 평탄화, 가상화, 상수 암호화, 안티-디버깅**  
- **하드닝**: `-fvisibility=hidden`, 심볼 스트립, CFI(Control-Flow Integrity), ASLR/DEP

**심볼 가시성 예**
```c
// gcc/clang: -fvisibility=hidden
__attribute__((visibility("default")))
int public_api(...){ ... }

static int secret_helper(...){ ... } // 외부 심볼에 노출되지 않음
```

---

### 3.7 WebAssembly(WASM)로 로직 이관

- 핵심 검증/연산을 WASM 모듈로 이전 → JS보다 분석 난이도 상승  
- **네트워크/메모리에서 평문 노출 가능** → **서버 검증이 여전히 필수**

---

## 4) “어디까지 난독화할 것인가?” 설계 가이드

1. **보호 대상 정의**: 정답/룰셋/치트 탐지/감사 로직 등  
2. **공격자 가정**: 프록시·후킹·디버거·메모리 덤프 가능 여부  
3. **기술 선택**: 경량(식별자/문자열) ↔ 중량(제어 흐름/가상화)  
4. **성능/안정성**: 난독화는 **디버깅·크래시 분석**을 어렵게 함 → **소스맵/심볼맵**을 내부에 안전 보관  
5. **운영 합의**: 고객지원·A/B 테스트·오류 리포팅 흐름에 영향 검토

---

## 5) 보안 아키텍처 결합(난독화 + X)

- **서버 권한검증**: 라이선스·결제·랭킹·인앱 구매 등 **서버가 최종 판정**  
- **무결성 검사**: 코드/리소스 해시를 런타임 검증(자체 서명 포함)  
- **탬퍼 감지**: 디버거/후킹 라이브러리 탐지 시 기능 축소·텔레메트리  
- **레이트 리미팅/행위 기반 탐지**: 클라이언트 변조 징후에 대한 서버측 방어  
- **키/비밀 관리**: 비밀은 **서버**에, 클라이언트에는 **토큰**(짧은 수명·스코프 제한)

---

## 6) 시나리오별 예제

### 6.1 프런트엔드: 할인 쿠폰 검증
- **나쁜 설계**: 프런트에서 쿠폰 문자열·할인율을 **전부** 결정 → 난독화 해도 쉽게 크랙  
- **좋은 설계**: 프런트는 **토큰 제출만**; 서버가 쿠폰 검증, 금액/세션·위험 신호 평가 → 응답은 **서명된 요약값**.  
- **난독화 역할**: **리스판스 조작/후킹**을 **지연**시켜 방어 룰 업데이트 시간 확보

### 6.2 모바일 게임: 안티-치트 보조
- **핵심 로직 일부**를 네이티브/WASM + 난독화  
- **서버 판정**(이상치 탐지/리플레이 검증) + **클라이언트 무결성**  
- **탬퍼 알림**으로 운영 측 차단 자동화

### 6.3 SaaS 브라우저 확장프로그램
- 확장코드 난독화 + **권한 최소화** + **CSP 강화**  
- 민감 API 키는 확장에 넣지 말고 **백엔드 프록시**

---

## 7) 테스트와 품질 보증

- **회귀 테스트**: 난독화 빌드 아티팩트에 대해 동일 테스트 스위트 실행  
- **소스맵/심볼맵 저장**: 크래시 리포트 역해석(사내 전용 저장소)  
- **퍼포먼스 벤치**: 제어 흐름/가상화는 오버헤드 큼 → 중요 경로는 경량 기법 우선  
- **디버그 스위치 철폐**: `DEBUG` 플래그·숨은 콘솔 제거  
- **릴리즈 서명**: 코드 서명으로 위·변조 감지

---

## 8) 디컴파일·디버깅 대응(개요 수준)

> **주의**: 아래 내용은 방어자 관점의 **검증/자체 점검**을 위한 요약입니다. 특정 제품·기술의 **구체적 우회**를 돕지 않습니다.

- **정적 검사**: beautify/AST 변환으로 구조 파악 → 취약 경로 탐색  
- **동적 검사**: 런타임에서 복호화된 문자열/테이블을 추출(메모리 스냅샷)  
- **훅킹/프록시**: 네트워크/파일/함수 경계에서 관찰  
- **결론**: **절대 보안은 불가**. 그래서 **서버 검증**과 **행위 기반 방어**가 필수입니다.

---

## 9) 운영 체크리스트(요약)

- [ ] **보호 대상 정의**(정책 문서화)  
- [ ] **빌드 파이프라인**에 난독화 스텝 포함(환경별 옵션)  
- [ ] **소스맵/심볼맵** 암호화 저장 + 권한 관리  
- [ ] **서버 검증/레이트 리미팅** 결합  
- [ ] **무결성·탬퍼 감지** 적용(알림 파이프라인)  
- [ ] **Crash/Telemetry** 역해석 체계(개발·CS 협업)  
- [ ] **정기 리스크 리뷰**: 성능/디버깅/유지보수 비용 평가

---

## 10) 실전 코드 묶음

### 10.1 Node: Terser + javascript-obfuscator 동시 적용
```json
// package.json (일부)
{
  "scripts": {
    "build": "rollup -c && node build/obfuscate.js"
  },
  "devDependencies": {
    "rollup": "^4",
    "terser": "^5",
    "javascript-obfuscator": "^4"
  }
}
```

```js
// rollup.config.js
import terser from '@rollup/plugin-terser';
export default {
  input: 'src/index.js',
  output: { file: 'dist/app.js', format: 'esm', sourcemap: false },
  plugins: [terser({ mangle: true, compress: true })]
};
```

```js
// build/obfuscate.js (앞서 소개한 것과 동일)
```

### 10.2 Android: R8 + 리플렉션 예외
```pro
# Gson/Retrofit 모델 유지
-keep class com.example.model.** { *; }
-keepattributes Signature,RuntimeVisibleAnnotations,AnnotationDefault
# Room/DI 프레임워크용 리플렉션 클래스 보존
-keep class androidx.room.** { *; }
-keep class dagger.** { *; }
```

### 10.3 .NET: 심볼 스트립(AOT 조합 예시)
```xml
<!-- .csproj -->
<PropertyGroup>
  <PublishReadyToRun>true</PublishReadyToRun>
  <DebugType>embedded</DebugType>
</PropertyGroup>
```

### 10.4 Python: C 확장으로 핵심 이관(개요)
```c
// ext/core.c
#include <Python.h>
static PyObject* validate(PyObject* self, PyObject* args){
  const char* s; if(!PyArg_ParseTuple(args, "s", &s)) return NULL;
  // 핵심 로직 (예시)
  int ok = strcmp(s,"key")==0;
  return PyBool_FromLong(ok);
}
static PyMethodDef M[]={{"validate",validate,METH_VARARGS,""}, {NULL,NULL,0,NULL}};
static struct PyModuleDef mod={PyModuleDef_HEAD_INIT,"core",NULL,-1,M};
PyMODINIT_FUNC PyInit_core(void){ return PyModule_Create(&mod); }
```

```python
# app.py
import core  # 네이티브 확장 모듈
def check(t): return core.validate(t)
```
> 바이너리라도 메모리·네트워크에서 정보가 보입니다. 최종 검증은 **서버**.

---

## 11) 자주 하는 실수 ↔ 올바른 대안

| 실수 | 문제 | 대안 |
|---|---|---|
| 클라이언트에 비밀키 저장 | 메모리/패킷에서 탈취 가능 | **서버에 보관**, 단기 토큰 사용 |
| 모든 파일에 최강 난독화 | 성능·디버깅 지옥 | **핵심 경로만** 강하게, 나머지는 경량 |
| 소스맵 공개 배포 | 역공학 쉬워짐 | 사내 전용 저장, 접근 통제 |
| 난독화 = 보안 | 취약점은 그대로 | 입력검증·권한·로깅·패치 체계 강화 |
| 리플렉션 클래스까지 축약 | 런타임 오류 | ProGuard/R8 **keep 규칙** 정교화 |

---

## 12) 결론

- 난독화는 **분석 비용을 올리는 보조 장치**입니다.  
- **서버 검증·권한관리·무결성·탬퍼 탐지**와 결합할 때 실효성이 생깁니다.  
- “무엇을, 왜, 어느 정도까지” 난독화할지 **명확히 정의**하고, 성능·유지보수·디버깅 비용을 **수치로 평가**하세요.  
- 가장 중요한 데이터와 결정은 **서버에**. 클라이언트 난독화는 **지연·완충** 역할로 바라보는 것이 현실적입니다.
