---
layout: post
title: 객체지향설계 - 불필요한 정보 제거와 핵심 행위 정의
date: 2025-07-15 21:20:23 +0900
category: 객체지향설계
---
# 불필요한 정보 제거와 핵심 행위 정의

## 1. 개념 개요

**불필요한 정보 제거(Irrelevant Information Removal)**와 **핵심 행위 정의(Core Behavior Definition)**는 **추상화(Abstraction)**의 두 기둥이다.

- **불필요한 정보 제거**: 모델링/설계 단계에서 **필요하지 않은 속성·연산**을 **애초에 포함하지 않거나** 외부 API에서 가리는 행위. 단순히 `private`로 숨기는 **사후 은닉**이 아니라, **사전 선별**이 핵심이다.
- **핵심 행위 정의**: 객체/컴포넌트가 **반드시 수행해야 하는 최소 동작**(역할)을 **계약과 함께 구체화**하는 일. **단일 책임(SRP)**과 **역할 중심 인터페이스(ISP)**로 이어진다.

> 목표: **작은 표면(Small Public Surface)**, **강한 불변식(Strong Invariants)**, **명확한 계약(Clear Contracts)**.

---

## 2. 불필요한 정보 제거 — 모델링 단계에서의 선별

### 2.1 의미와 범위
- **모델링 단계**: 요구·사용 시나리오에서 **관찰 가능한 결과**와 **결정에 필요한 데이터**만 고른다.
- **설계 단계**: 공개 API(메서드·DTO)에서 **내부 흐름·중간 상태·실험용 훅**을 드러내지 않는다.
- **구현 단계**: **캡슐화**와 **가시성 제어**로 내부를 닫고, **퍼사드/포트**로 단순한 외피를 제공한다.

### 2.2 커피 자판기 예시(확장)
초안의 구조를 유지하되, “공개 절차는 간결하게, 내부 단계는 은닉”을 강조한다.

```java
class CoffeeMachine {
    // 공개 API: 핵심 행위만 노출
    public void makeCoffee() {
        heatWater();    // 내부 단계
        grindBeans();   // 내부 단계
        brew();         // 내부 단계
        pour();         // 내부 단계
    }

    // 내부 구현: 외부에는 불필요
    private void heatWater()   { /* 센서/히터 제어 */ }
    private void grindBeans()  { /* 그라인더 RPM */ }
    private void brew()        { /* 압력/시간 제어 */ }
    private void pour()        { /* 컵 감지/용량 */ }
}
```

**모델링 원칙**
- 사용자가 “**어떤 결과를 얻는가**(커피 제공)”만 본다.
- “**어떻게 만드는가**”는 비공개다. 이후 히터 교체/알고리즘 변경 시 **외부 영향 0**.

### 2.3 제거 기준(현장 체크리스트)
- [ ] 이 데이터/메서드를 **외부 사용자가 실제로 필요**로 하는가?
- [ ] 해당 정보가 **결정을 바꾸는 신호**인가, **관찰 가능한 결과**인가?
- [ ] **변경 가능성이 높은 내부 세부**는 아닌가?
- [ ] 공개 시 **악용/오사용** 가능성이 커지지 않는가? (보안/무결성)
- [ ] 공개로 인해 **계약·호환성 유지 비용**이 급증하지 않는가?

---

## 3. 핵심 행위 정의 — 역할 중심 인터페이스

### 3.1 의미
객체/컴포넌트가 맡은 **역할(Role)**을 중심으로, 그 역할을 성립시키는 **최소 집합의 동작**만 정의한다.

```java
interface Vehicle {
    void accelerate();
    void brake();
    void turnLeft();
    void turnRight();
}
```

- `Vehicle`은 **주행** 역할만 표현한다.
- 오디오/에어컨/내비는 **별도의 역할**(인터페이스)로 분리한다(인터페이스 분리 원칙, ISP).

### 3.2 핵심 행위는 **계약**과 함께
핵심 메서드는 **전제조건(Pre)**, **사후조건(Post)**, **불변식(Inv)**을 명시해야 한다.

```java
interface BankAccount {
    /**
     * Pre: amount > 0
     * Post: balance == old(balance) + amount
     * Inv: balance >= 0
     */
    void deposit(int amount);

    /**
     * Pre: amount > 0 && balance >= amount
     * Post: balance == old(balance) - amount
     * Inv: balance >= 0
     */
    void withdraw(int amount);

    int balance();
}
```

- **핵심 행위** `deposit/withdraw`만 노출.
- 계약이 **핵심의 의미를 고정**하여 구현 교체에도 일관성 보장.

---

## 4. 수식으로 보는 “공개 표면 최소화”

공개 메서드 수 \(M\), 클라이언트 수 \(N\), 변경 빈도 \(F\), 결합 계수 \(C\)라 할 때 **변경 파급 위험**을:

$$
\text{Risk} \approx M \cdot N \cdot F \cdot C
$$

- **불필요한 정보 제거** → \(M \downarrow\)
- **역할 분리(ISP)** → 각 클라이언트가 쓰는 \(M\)이 분할되어 유효 \(M\downarrow\)
- **포트/어댑터** → 외부 시스템과의 \(C\downarrow\)

---

## 5. 실전: ATM 템플릿과 핵심 행위 고정

초안의 ATM 예를 **템플릿 메서드(Template Method)**로 명확화하고, 핵심만 추상화한다.

```java
abstract class ATM {
    public final void processTransaction() {
        authenticateUser();     // 핵심 1: 인증 (변하는 지점)
        selectTransactionType();// 고정 흐름(비공개 or final)
        performTransaction();   // 핵심 2: 거래 수행 (변하는 지점)
        printReceipt();         // 고정 흐름
    }

    protected abstract void authenticateUser();
    protected abstract void performTransaction();

    // 내부 세부: 외부로 공개 불가
    private void selectTransactionType(){ /* UI/메뉴 */ }
    private void printReceipt(){ /* 영수증 포맷 */ }
}
```

- **핵심 행위만 확장점**(hook)으로 제공 → 하위 클래스가 **필수 행위만** 구현.

### 5.1 전략 패턴으로 핵심 행위 주입
ATM의 인증/거래를 **전략**으로 분리하면, 더 강한 합성과 테스트 용이성 확보.

```java
interface AuthStrategy { void authenticate(); }
interface TxStrategy { void perform(); }

final class ATM2 {
    private final AuthStrategy auth;
    private final TxStrategy tx;
    ATM2(AuthStrategy auth, TxStrategy tx){ this.auth = auth; this.tx = tx; }

    public void processTransaction(){
        auth.authenticate();
        tx.perform();
    }
}
```

- **핵심은 고정**: 인증하고 거래한다.
- **구현은 주입**: OTP/지문/카드, 송금/출금 등 **불필요한 구현 차이는 숨김**.

---

## 6. 도메인 관점: 핵심/비핵심 구분(DDD)

**도메인 주도 설계(DDD)**에서는 다음을 먼저 구분한다.

- **Core Domain(핵심)**: 제품 차별화/핵심 가치. → **핵심 행위 정의**에 집중
- **Supporting/Generic**: 일반 기능(로그/감사/메일). → **불필요 노출 최소**, 라이브러리/외부 위임

```text
[Core Domain]
  └─ Payment(승인/정산/환불)  ← 인터페이스 + 계약

[Supporting/Generic]
  ├─ Logging    ← 퍼사드/어댑터 뒤로 숨김
  ├─ Monitoring ← 메트릭 인터페이스 뒤로
  └─ Mail       ← 포트/어댑터
```

- 핵심은 **가장 작은 표면**으로 **가장 강한 계약**을 갖게 하라.

---

## 7. 패턴으로 구현하는 “작게 드러내고 크게 숨기기”

### 7.1 퍼사드(Facade)
- 여러 내부 서브시스템을 하나의 **간단한 외피**로 노출.
```java
final class ReportingFacade {
    private final DataSource ds; private final TemplateEngine te; private final Mailer mailer;
    public void sendDailyReport(LocalDate day){
        var data = ds.query(day);
        var html = te.render("daily", data);
        mailer.send(html);
    }
}
```
- **핵심 행위**: “일일 리포트 보내기”만 공개. 내부는 감춤.

### 7.2 포트/어댑터(헥사고날)
- 외부 시스템 연계를 **역할 인터페이스(Port)** 로 제한, 구현은 **어댑터** 뒤에 숨김.

```java
interface PaymentPort { void pay(int amount, String key); } // Port(핵심 행위)
final class KakaoAdapter implements PaymentPort { public void pay(int a, String k){ /* API */ } }
```

### 7.3 템플릿/전략/상태
- **템플릿**: 고정 절차+핵심 훅
- **전략**: 알고리즘 교체(핵심은 동일 메시지)
- **상태**: 상태별 동작 교체(분기 제거)

---

## 8. 안티패턴과 리팩토링

| 냄새 | 문제 | 해결 |
|---|---|---|
| Kitchen-sink API | 무엇이 핵심인지 불명확, 과다 공개 | **퍼사드/역할 인터페이스**로 핵심만 노출 |
| 내부 상태 게터 남발 | 외부에서 상태 조작, 불변식 붕괴 | **명령 메서드**로 간접변경, 게터는 조회용만 |
| 유틸리티 정적 함수 범람 | 객체의 책임 부재, 테스트 어려움 | **역할 인터페이스** 도입, 의존 주입 |
| 지나친 설정 공개 | 설정=내부 결정이 외부로 노출 | **합리적 기본값**, 고급 설정은 내부 API 또는 빌더 수준 |
| 도메인/인프라 혼재 | 경계 모호 → 변경 파급 ↑ | **포트/어댑터**로 경계 확립 |

**리팩토링 레시피**
1) 공개 API 점검 → **사용되지 않는 메서드 제거**(사용량 측정 기반)
2) **핵심 시나리오**를 문장으로 기술 → 그 문장을 코드의 **퍼사드/유스케이스**로 승격
3) 상태 노출 게터 → **의미 있는 명령 메서드**로 치환 (`increaseStock(qty)` 등)
4) 비 핵심 기능 → **지원 서비스/어댑터**로 이동, 핵심에서 호출만

---

## 9. 테스트: 핵심을 계약으로 고정

### 9.1 계약 테스트(Contract Test)
역할 인터페이스에 대한 **공유 테스트**로, 구현 교체에도 핵심 행위가 유지되는지 검증.

```java
interface Payment {
    // Pre: amount > 0
    // Post: returns txId, idempotent for same key
    String pay(int amount, String idempotencyKey);
}

abstract class PaymentContract {
    protected abstract Payment sut();
    @org.junit.jupiter.api.Test
    void paysPositiveAmount(){
        var tx = sut().pay(1000, "key");
        org.junit.jupiter.api.Assertions.assertNotNull(tx);
    }
}
final class KakaoPayTest extends PaymentContract {
    protected Payment sut(){ return (a,k) -> "TX-1"; }
}
final class CardPayTest extends PaymentContract {
    protected Payment sut(){ return (a,k) -> "TX-2"; }
}
```

### 9.2 속성 기반 테스트(Property-based)
핵심 불변식을 자동 검증: 예) `balance >= 0`는 모든 입출금 시퀀스에 대해 유지.

---

## 10. 계량 지표로 살펴보기

- **CBO(Coupling Between Objects)**: 공개 표면이 크면 CBO↑ → 변경 파급↑
- **LCOM(Lack of Cohesion)**: 핵심 행위와 무관한 메서드가 많을수록 응집도↓
- **Public Surface Size(PSS)**: `public` 메서드 수/DTO 필드 수
- **Invariants Coverage(IC)**: 핵심 불변식을 테스트로 얼마나 덮는가(%)

간단한 위험 추정:
$$
\text{Stability} \approx \frac{\text{IC}}{1 + \text{PSS} \cdot \text{CBO}}
$$

---

## 11. 예제 묶음 — “핵심만 밖으로, 나머지는 안으로”

### 11.1 전자상거래 결제 퍼사드
```java
final class CheckoutFacade {
    private final PaymentPort payment;
    private final Inventory inv;
    private final Notifier notifier;

    public CheckoutFacade(PaymentPort payment, Inventory inv, Notifier notifier) {
        this.payment = payment; this.inv = inv; this.notifier = notifier;
    }

    // 핵심 행위: 결제 시도
    public String placeOrder(String sku, int qty, int amount, String key) {
        inv.reserve(sku, qty);               // 내부 협력
        var txId = payment.pay(amount, key); // 핵심 포트
        notifier.sendOrderConfirmed(txId);   // 내부 협력
        return txId;
    }
}
```

- 외부는 **“주문하기”**만 호출. 재고/알림/결제 세부는 내부로 숨김.

### 11.2 차량 역할 분리(핵심 vs 부가)
```java
interface Drivable  { void accelerate(); void brake(); }
interface Steerable { void turnLeft(); void turnRight(); }
interface Media     { void volumeUp(); void volumeDown(); }
final class Car implements Drivable, Steerable { /* 핵심만 구현 */ }
```

- **핵심 인터페이스**와 **부가 인터페이스**를 분리해 표면 축소.

---

## 12. 점진적 설계 절차(현장 가이드)

1) **시나리오/유스케이스**를 한 문장으로:
   “사용자가 **X**를 하면, 시스템은 **Y**를 보장한다.”
2) 그 문장을 **퍼사드/유스케이스 메서드**로 만든다(핵심 행위).
3) 내부 단계는 **비공개**로 내린다(불필요한 정보 제거).
4) 외부와의 통신은 **포트(역할 인터페이스)**로 한정한다.
5) 불변식·전제/사후를 **주석/어노테이션/테스트**로 고정한다.
6) **계약 테스트**로 구현 교체를 검증한다.
7) 사용되지 않는 공개 항목을 **주기적으로 제거**한다(측정 기반).

---

## 13. 비교 요약 표

| 축 | 불필요한 정보 제거 | 핵심 행위 정의 |
|---|---|---|
| 초점 | 숨길 것/버릴 것 | 드러낼 것/고정할 것 |
| 수단 | 캡슐화, 가시성, 퍼사드, 포트/어댑터 | 역할 인터페이스, 계약(Pre/Post/Inv) |
| 효과 | 표면 축소, 결합↓, 변경 파급↓ | 응집↑, 테스트 용이, 확장 용이 |
| 지표 | PSS↓, CBO↓ | LCOM↓, IC↑ |
| 패턴 | Facade, Adapter, Module | Strategy, Template Method, State |

---

## 14. 결론

- **불필요한 정보 제거**: **사전** 선별이 핵심이다. 내부 세부/중간 상태/실험용 훅은 **애초에 모델에 올리지 않거나** 외부 API에서 가린다.
- **핵심 행위 정의**: 역할을 중심으로 **최소 동작**을 계약과 함께 노출한다. 나머지는 합성/전략/어댑터 뒤로 감춘다.
- 두 원칙을 따르면, **작은 공개 표면 + 강한 불변식**이라는 안정적 구조가 만들어지고, **변경에 강하고 테스트 가능한 시스템**이 된다.

---

## 부록 A) 미니 체크리스트

- [ ] 유스케이스 한 문장으로 요약 가능한가?
- [ ] 공개 메서드는 **그 문장**과 직접 대응하는가?
- [ ] 불변식/전제/사후가 명시되어 있는가?
- [ ] 사용되지 않는 공개 항목이 남아 있지 않은가?
- [ ] 외부 시스템 의존은 **포트**로 격리되었는가?
- [ ] 핵심/비핵심이 분리되어 있는가(DDD 관점)?
- [ ] 계약 테스트로 구현 교체 가능성이 보장되는가?
