---
layout: post
title: Django - 성능 & 확장성
date: 2025-10-01 23:25:23 +0900
category: Django
---
# 7. 성능 & 확장성

## A. N+1 / 쿼리 최적화 — `select_related` / `prefetch_related`, 캐시-어웨어 쿼리

### A-1. N+1 문제란?
- 목록을 렌더링하면서 각 아이템의 관련 객체를 **반복적으로 개별 쿼리**하는 패턴.
- 증상: 리스트 1번 + 아이템 개수(N)번 = **N+1 쿼리**, 지연/CPU 증가/DB 과열.

### A-2. 모델 스케치 (공통 예제)
```python
# apps/shop/models.py
from django.db import models
from django.conf import settings

class Shop(models.Model):
    name = models.CharField(max_length=80)

class Product(models.Model):
    shop = models.ForeignKey(Shop, on_delete=models.CASCADE, related_name="products")
    name = models.CharField(max_length=120)
    price = models.PositiveIntegerField()
    rating = models.DecimalField(max_digits=3, decimal_places=2, default=0)

class Review(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name="reviews")
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    score = models.PositiveSmallIntegerField()
    body = models.TextField()
```

### A-3. `select_related` (FK/OneToOne → JOIN)
- 외래키/일대일처럼 **한 행으로 합칠 수 있는 관계**에 사용.
```python
# BEFORE: 각 product.shop 접근 때마다 쿼리
qs = Product.objects.all()
for p in qs:
    print(p.shop.name)  # N+1

# AFTER: 한 번에 JOIN
qs = Product.objects.select_related("shop")
for p in qs:
    print(p.shop.name)  # 1쿼리
```

### A-4. `prefetch_related` (M2M/역참조 → 별도 SELECT + in-memory 조인)
- 리뷰/태그 등 **다대다/역참조**에 사용.
```python
from django.db.models import Prefetch
qs = Product.objects.prefetch_related(
    Prefetch("reviews", queryset=Review.objects.select_related("user").order_by("-id"))
)
for p in qs:
    first = p.reviews.all()[0] if p.reviews.all() else None
```

> 팁: `select_related` 는 **JOIN** 이라서 행 수가 폭증할 수 있으니 필요한 관계만 지정.  
> `prefetch_related` 는 **두 번 SELECT** → Python join이므로 정렬/필터 커스터마이즈에 유리.

### A-5. 계산량 절감: 필요한 컬럼만 읽기
```python
# values()/values_list()/only()/defer()
qs = Product.objects.only("id", "name", "price")
ids = list(Product.objects.filter(price__gte=10000).values_list("id", flat=True))
```

### A-6. 페이지네이션 & 카운트 비용 줄이기
- 무제한 리스트 금지. `PageNumberPagination`/`LimitOffset`/커서 기반을 사용.
- 전체 카운트가 비싼 경우:
  - **커서 기반**으로 대체, 혹은 `estimated_count`(DB별 전략) 도입.
  - 매우 큰 테이블은 **materialized view/집계 테이블** 고려.

### A-7. 조건부 집계/어노테이션
```python
from django.db.models import Avg, F, Case, When, Value, IntegerField
qs = Product.objects.annotate(
    hot=Case(When(rating__gte=4.5, then=Value(1)), default=Value(0), output_field=IntegerField())
).order_by("-hot", "-rating")
```

### A-8. 캐시-어웨어 쿼리: 캐시 히트 전제의 쿼리 슬림화
- **low-level cache** 로 비싼 조합 결과를 저장 → 뷰는 캐시를 먼저 조회.
- 캐시 히트를 전제로 DB 쿼리 경량화: **필요한 열만**, **짧은 TTL**, **버전 키**.

```python
# apps/shop/cache_api.py
from django.core.cache import cache
from django.db.models import Sum, F
from .models import Product, Review

def get_top_products():
    key = "top_products:v2"
    data = cache.get(key)
    if data is not None:
        return data
    qs = Product.objects.values("id", "name").annotate(
        rev=Sum(F("reviews__score"))  # 예시 집계
    ).order_by("-rev")[:20]
    data = list(qs)
    cache.set(key, data, 60)  # 60초
    return data
```

### A-9. 인덱스 전략
- 자주 필터/정렬하는 필드에 `db_index=True` 또는 `models.Index`.
- **복합 인덱스**: `(shop_id, price)` 처럼 쿼리 패턴 접두 일치.
- Postgres: **Partial Index**, **GIN/Trigram**, JSONB 인덱스 등.

```python
# apps/shop/migrations/xxxx_add_indexes.py
from django.db import migrations, models

class Migration(migrations.Migration):
    dependencies = [...]
    operations = [
        migrations.AddIndex(
            model_name="product",
            index=models.Index(fields=["shop", "price"], name="shop_price_idx"),
        ),
    ]
```

### A-10. 슬로우 쿼리 모니터링 & 테스트 가드
```python
# 테스트에서 N+1 가드
from django.test.utils import CaptureQueriesContext
from django.db import connection

def test_product_list_queries(client):
    with CaptureQueriesContext(connection) as ctx:
        client.get("/products/")
    assert len(ctx.captured_queries) <= 10
```

---

## B. 템플릿/응답 최적화 — 스트리밍, GZip, HTTP/2, ETag/Last-Modified

### B-1. 템플릿 렌더링 비용 줄이기
- 템플릿 내부에서 **DB 접근**(역참조 호출) 금지 → 뷰에서 **프리페치/정리**.
- 반복 블록에서 **비싼 필터/태그** 최소화. 필요 시 **템플릿 프래그먼트 캐시**.

```html
{% load cache %}
{% cache 120 "product-cards" request.user.pk %}
  {% for p in products %}
    {% include "shop/_product_card.html" %}
  {% endfor %}
{% endcache %}
```

### B-2. 스트리밍 응답 (SSE/대용량 HTML)
- 큰 HTML/CSV를 **조각 단위로 전송**하면 **TTFB** 개선.

```python
# apps/core/views.py
from django.http import StreamingHttpResponse
import time

def csv_stream(request):
    def gen():
        yield "id,name\n"
        for i in range(100000):
            yield f"{i},item-{i}\n"
            if i % 1000 == 0:
                time.sleep(0.001)
    return StreamingHttpResponse(gen(), content_type="text/csv")
```

> 주의: 미들웨어/압축/리버스 프록시와의 상호작용(버퍼링) 확인.

### B-3. 압축(GZip/Brotli)
- WhiteNoise/리버스 프록시(Nginx/CloudFront)에서 **정적 자산 사전 압축**(gz/br).
- 동적 응답은 **웹 서버**(Nginx)에서 압축 처리 권장(애플리케이션 CPU 절약).

```nginx
gzip on;
gzip_types text/plain text/css application/json application/javascript text/xml application/xml;
gzip_min_length 1024;
```

> Brotli: `brotli on; brotli_types ...;` (더 높은 압축률, CPU 비용↑)

### B-4. HTTP/2 / HTTP/3 고려
- HTTP/2: **멀티플렉싱**으로 여러 리소스 동시 전송.
- HTTP/3(QUIC): 네트워크 품질이 나쁜 환경에서 **지연 감소**.
- 애플리케이션 레벨 변경은 적고, **웹 서버/로드밸런서** 설정 위주.

### B-5. 캐시 검증: `ETag` / `Last-Modified`
- 조건부 요청(If-None-Match / If-Modified-Since)으로 **304 Not Modified** 반환 → 네트워크/렌더 비용 절약.

```python
# apps/core/http.py
from django.utils.http import http_date
from django.utils.timezone import now
from django.http import HttpResponse, HttpResponseNotModified
import hashlib

def with_etag(body_bytes: bytes, req):
    etag = hashlib.md5(body_bytes).hexdigest()  # 간단 예시
    inm = req.headers.get("If-None-Match")
    if inm and inm == etag:
        return HttpResponseNotModified()
    resp = HttpResponse(body_bytes, content_type="text/plain")
    resp["ETag"] = etag
    return resp

def with_last_modified(body_bytes: bytes, req, last_dt):
    ims = req.headers.get("If-Modified-Since")
    if ims and http_date(last_dt.timestamp()) == ims:
        return HttpResponseNotModified()
    resp = HttpResponse(body_bytes, content_type="text/plain")
    resp["Last-Modified"] = http_date(last_dt.timestamp())
    return resp
```

> 실무에서는 **정적 파일 → 해시 파일명(Manifest)**, 동적 API는 **ETag/Last-Modified** 병행.

### B-6. 응답 헤더 튜닝
- `Cache-Control`: public/private, max-age, stale-while-revalidate.
- `Vary`: `Accept-Encoding`, `Cookie`, `Origin` 등 → 캐시 키 분리.

```python
from django.utils.cache import patch_cache_control

def set_cache(resp, seconds=60):
    patch_cache_control(resp, public=True, max_age=seconds, stale_while_revalidate=seconds)
    return resp
```

---

## C. 대용량 업로드/다운로드 — 청크/비동기, 서명 URL, 백그라운드 처리

### C-1. 업로드 전략 요약
- **직접 업로드**: 브라우저 → 오브젝트 스토리지(S3/GCS) **pre-signed URL** 로 전송.  
  서버는 **URL 발급 + 메타 기록**만 수행 → **앱 서버 부하 최소화**.
- **청크 업로드**: 파일을 **조각**으로 분할 전송 → 실패 조각만 재시도. (S3 Multipart, Tus, Resumable)
- 업로드 완료 후 **백그라운드 처리**(바이러스 스캔/썸네일/트랜스코딩).

### C-2. 서명 URL 발급 (S3 예시)
```python
# apps/storage/api.py
import boto3, mimetypes
from django.conf import settings
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

@api_view(["POST"])
@permission_classes([IsAuthenticated])
def create_presigned_upload(request):
    filename = request.data["filename"]
    ctype = mimetypes.guess_type(filename)[0] or "application/octet-stream"
    s3 = boto3.client("s3", region_name=settings.AWS_S3_REGION_NAME)
    key = f"uploads/{request.user.pk}/{filename}"
    url = s3.generate_presigned_url(
        "put_object",
        Params={"Bucket": settings.AWS_STORAGE_BUCKET_NAME, "Key": key, "ContentType": ctype, "ACL": "private"},
        ExpiresIn=600,
    )
    return Response({"upload_url": url, "key": key, "content_type": ctype})
```

**프런트(요약)**:
```javascript
// 1) 백엔드에 파일명 보내서 signed URL 받기
// 2) fetch PUT 으로 S3에 바로 업로드
await fetch(upload_url, { method:'PUT', headers:{'Content-Type': contentType}, body: file })
// 3) 완료 후 백엔드에 key 보고 → DB 레코드 생성
```

> 보안: 업로드 키 네임스페이스(사용자/조직), **크기 제한/확장자 제한**은 **클라이언트+서버에서** 모두 검증.

### C-3. S3 Multipart(청크) 업로드 스케치
- 대용량(수백 MB~수 GB)은 **Multipart** 필수. 실패 조각만 재시도 → 네트워크 효율↑.
- 프런트에서 조각화하고 **CreateMultipartUpload → UploadPart → CompleteMultipartUpload** 순서로 호출.  
  서버는 **권한/정책**을 검증하고 **일회성 서명**을 각 파트에 발급.

### C-4. 오프로딩(백그라운드 처리)
- 업로드 완료 후 Celery로 **바이러스 스캔 → 메타추출 → 썸네일 → DB 업데이트**.
- 처리 중 상태를 **WebSocket/폴링**으로 사용자에게 안내.

```python
# apps/assets/tasks.py
from celery import shared_task
from .models import Asset
from .utils import scan, make_thumb

@shared_task(bind=True, autoretry_for=(Exception,), retry_backoff=True)
def process_asset(self, asset_id):
    a = Asset.objects.get(pk=asset_id)
    if not scan(a.storage_key):  # 바이러스 스캔
        a.status = "REJECTED"
        a.save(update_fields=["status"])
        return
    make_thumb(a.storage_key)    # 썸네일 생성
    a.status = "READY"
    a.save(update_fields=["status"])
```

### C-5. 다운로드 최적화
- 앱 서버가 직접 파일을 **스트리밍**하기보다, **서명 URL(일시적 읽기 권한)** 로 **스토리지/CDN에서 바로 다운로드**.
- 사유/접근제어가 필요한 경우: 요청을 인증 → **302 리다이렉트**로 서명 URL 반환.

```python
# apps/assets/views.py
from django.shortcuts import redirect
import boto3
def download_private(request, key):
    # 권한 검사...
    s3 = boto3.client("s3")
    url = s3.generate_presigned_url("get_object", Params={"Bucket": "...", "Key": key}, ExpiresIn=60)
    return redirect(url)
```

### C-6. 대용량 응답의 서버-사이드 스트리밍 (필요시)
```python
# FileResponse with chunked file
from django.http import FileResponse
def big_file(request):
    file = open("/data/huge.bin", "rb")
    resp = FileResponse(file, as_attachment=True, filename="huge.bin")
    resp["X-Accel-Buffering"] = "no"  # Nginx가 버퍼링 안하도록(환경에 따라)
    return resp
```

> 가능하면 **Nginx/X-Sendfile/X-Accel-Redirect** 를 사용해 **커널 공간에서** 파일을 전달.

### C-7. 리버스 프록시(X-Accel / X-Sendfile)
- Django는 **권한만 확인** → 헤더(`X-Accel-Redirect`/`X-Sendfile`) 로 파일 경로를 웹 서버에 전달 → 웹 서버가 파일 전송 담당.

```python
# Django view
from django.http import HttpResponse

def protected_download(request, internal_path):
    # 권한 검사...
    resp = HttpResponse()
    resp["Content-Type"] = "application/octet-stream"
    resp["Content-Disposition"] = 'attachment; filename="data.bin"'
    resp["X-Accel-Redirect"] = f"/protected/{internal_path}"
    return resp
```

```nginx
location /protected/ {
  internal;
  alias /srv/private_files/;
}
```

---

## D. 실전 통합 예제 — “인기 상품 카드 목록: 캐시 + N+1 방지 + ETag + 이미지 서명 URL”

### D-1. 뷰 (쿼리 최적화 + 캐시)
```python
# apps/shop/views.py
from django.views.generic import TemplateView
from django.core.cache import cache
from django.db.models import Sum, F
from .models import Product, Review

class HotView(TemplateView):
    template_name = "shop/hot.html"
    CACHE_KEY = "shop:hot:v3"

    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        data = cache.get(self.CACHE_KEY)
        if data is None:
            qs = (Product.objects
                  .select_related("shop")
                  .prefetch_related("reviews")
                  .annotate(score=Sum(F("reviews__score")))
                  .order_by("-score")[:20])
            data = list(qs.values("id", "name", "price", "shop__name"))
            cache.set(self.CACHE_KEY, data, 60)
        ctx["items"] = data
        return ctx
```

### D-2. 템플릿(프래그먼트 캐시 + 지연 로딩)
```html
{% load cache static %}
{% cache 60 "hot-cards" %}
<div class="cards">
  {% for it in items %}
    <div class="card">
      <img loading="lazy" src="{% static 'img/placeholder.png' %}" data-src="/media/thumbs/{{ it.id }}.jpg" alt="">
      <h3>{{ it.name }}</h3>
      <p>{{ it.shop__name }} · {{ it.price|intcomma }}원</p>
    </div>
  {% endfor %}
</div>
<script>
  // 간단한 lazy loader (IntersectionObserver)
  const io = new IntersectionObserver(entries=>{
    entries.filter(e=>e.isIntersecting).forEach(e=>{
      const img = e.target; img.src = img.dataset.src; io.unobserve(img);
    })
  });
  document.querySelectorAll('img[loading="lazy"]').forEach(el=>io.observe(el));
</script>
{% endcache %}
```

### D-3. 이미지 다운로드(서명 URL 리다이렉트)
```python
# apps/assets/img.py
from django.shortcuts import redirect
import boto3

def signed_thumb(request, pid):
    # 권한/존재 확인 후
    s3 = boto3.client("s3")
    key = f"thumbs/{pid}.jpg"
    url = s3.generate_presigned_url("get_object", Params={"Bucket":"my-bucket","Key":key}, ExpiresIn=60)
    return redirect(url)
```

### D-4. ETag/Last-Modified 헤더 추가
```python
# apps/core/mixins.py
import hashlib
from django.http import HttpResponseNotModified

class ETagMixin:
    def add_etag(self, resp, payload: bytes):
        etag = hashlib.sha1(payload).hexdigest()
        if self.request.headers.get("If-None-Match") == etag:
            return HttpResponseNotModified()
        resp["ETag"] = etag
        return resp
```

---

## E. 운영 체크리스트 (요약)

**쿼리 최적화**
- [ ] 리스트/상세에 `select_related`/`prefetch_related` 적용  
- [ ] `only/values_list` 로 필요한 컬럼만  
- [ ] 인덱스/복합 인덱스/Partial Index 설계  
- [ ] 슬로우 쿼리 모니터링(APM/pg_stat_statements)

**응답/네트워크**
- [ ] 프래그먼트/뷰 캐시, ETag/Last-Modified  
- [ ] 정적 자산 해시 파일명 + Brotli/GZip + HTTP/2  
- [ ] 스트리밍 응답(큰 CSV/HTML) 시 버퍼링/프록시 설정 점검

**업로드/다운로드**
- [ ] Pre-signed URL(직접 업로드/다운로드)  
- [ ] Multipart/청크 업로드 + 실패 조각 재시도  
- [ ] 업로드 후 백그라운드 처리(썸네일/스캔)  
- [ ] X-Accel/X-Sendfile 로 큰 파일 전달

**캐시**
- [ ] 키 버전/네임스페이스, TTL/무효화 전략  
- [ ] 스탬피드 방지(lock/early refresh)  
- [ ] 민감 데이터 public 캐시 금지, `Vary` 정확히

---

## F. 추가 스니펫 모음

### F-1. 스탬피드 방지(분산 락)
```python
from django_redis import get_redis_connection
from django.core.cache import cache
import time

def cached_expensive(key, builder, ttl=60):
    val = cache.get(key)
    if val is not None:
        return val
    r = get_redis_connection("redis")
    lock = r.lock(f"lock:{key}", timeout=10)
    if lock.acquire(blocking=True, blocking_timeout=3):
        try:
            val = cache.get(key)
            if val is not None:
                return val
            val = builder()
            cache.set(key, val, ttl)
            return val
        finally:
            lock.release()
    # 락을 못 얻으면 짧게 기다렸다가 재시도
    time.sleep(0.1)
    return cache.get(key)  # 그래도 없으면 None
```

### F-2. 커서 기반 페이지네이션(DRF)
```python
from rest_framework.pagination import CursorPagination

class ProductCursorPagination(CursorPagination):
    page_size = 20
    ordering = "-id"  # 안정 정렬

# settings.py
REST_FRAMEWORK = { "DEFAULT_PAGINATION_CLASS": "apps.api.pagination.ProductCursorPagination" }
```

### F-3. N+1 자동 점검(개발용)
```python
# pip install django-querycount
MIDDLEWARE += ["querycount.middleware.QueryCountMiddleware"]
QUERYCOUNT = { "THRESHOLDS": {"MEDIUM": 50, "HIGH": 200} }
```

### F-4. X-Accel-Redirect 유틸
```python
from django.http import HttpResponse

def accel_download(internal_path, filename):
    resp = HttpResponse()
    resp["Content-Type"] = "application/octet-stream"
    resp["Content-Disposition"] = f'attachment; filename="{filename}"'
    resp["X-Accel-Redirect"] = f"/protected/{internal_path}"
    return resp
```

### F-5. Response 압축 미들웨어(간단 예시; 운영은 Nginx 권장)
```python
import gzip, io
class GZipMiddlewareLite:
    def __init__(self, get_response): self.get_response = get_response
    def __call__(self, request):
        resp = self.get_response(request)
        if "gzip" in request.headers.get("Accept-Encoding","") and len(resp.content) > 1024:
            out = io.BytesIO()
            with gzip.GzipFile(fileobj=out, mode="wb") as f:
                f.write(resp.content)
            resp.content = out.getvalue()
            resp["Content-Encoding"] = "gzip"
            resp["Content-Length"] = str(len(resp.content))
        return resp
```

---

## 마무리

- **데이터 경로 최적화**: `select_related/prefetch_related` + **인덱스** + **부분 컬럼 로딩**으로 DB 비용을 줄이고, **캐시-어웨어**하게 쿼리를 설계하세요.  
- **네트워크/렌더 경로 최적화**: **프래그먼트/뷰 캐시**, **ETag/Last-Modified**, **HTTP/2 + 압축**으로 바이트와 RTT를 절감하세요.  
- **대용량 파일 경로 최적화**: **서명 URL + Multipart**로 앱 서버를 비켜 가고, 후처리는 **비동기**로 보냅니다. 필요 시 **X-Accel/X-Sendfile**로 커널이 파일을 전송하게 하세요.
