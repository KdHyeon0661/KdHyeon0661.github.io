---
layout: post
title: 소켓프로그래밍 - 소켓 옵션
date: 2025-09-14 21:25:23 +0900
category: 소켓프로그래밍
---
## 소켓 옵션 제대로 이해하기

> 목표: **옵션 하나로 현장이 달라진다.** `SO_REUSEADDR`/`SO_REUSEPORT`, `SO_RCVBUF`/`SO_SNDBUF`, `TCP_NODELAY`, `SO_LINGER`, **Keepalive**(TCP\_KEEPIDLE/INTVL/KEEPCNT), `TCP_INFO`, `TCP_USER_TIMEOUT`, `TCP_DEFER_ACCEPT`, `TCP_FASTOPEN`, `TCP_CORK`(Linux) 등 **핵심/실무형 옵션**을 모두 정리한다.
> 그리고 **TIME\_WAIT/재기동/백로그(accept/SYN 큐)** 까지 연결하고, **전/후 지표 비교 실습**으로 손에 익힌다.
> 기준: **리눅스 커널/글리브c** + **C++23**. (BSD/macOS 차이는 각 항목에 주석)

---

### 옵션 세팅/조회 공통 유틸 (C++23)

실습과 예제에서 반복되는 **get/set 래퍼**를 먼저 준비한다.

```cpp
// sockopt.hpp
#pragma once
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <unistd.h>
#include <cstring>
#include <expected>
#include <system_error>
#include <string>
#include <print>

inline std::error_code last_errno(){ return {errno, std::generic_category()}; }

template <class T>
inline std::expected<void,std::error_code>
setopt(int fd, int level, int optname, const T& v) {
    if (::setsockopt(fd, level, optname, &v, sizeof(v)) == 0) return {};
    return std::unexpected(last_errno());
}

template <class T>
inline std::expected<T,std::error_code>
getoptv(int fd, int level, int optname) {
    T v{}; socklen_t len = sizeof(v);
    if (::getsockopt(fd, level, optname, &v, &len) == 0) return v;
    return std::unexpected(last_errno());
}

inline void print_errno(std::string_view tag) {
    std::print(stderr, "[{}] {}\n", tag, std::strerror(errno));
}
```

---

## 주소 재사용: `SO_REUSEADDR` / `SO_REUSEPORT`
### `SO_REUSEADDR` — 재기동/포트 회수의 기본

- **목적(리눅스)**: `TIME_WAIT`/`FIN_WAIT` 등 남아 있는 커널 엔트리 때문에 **바인드 실패(EADDRINUSE)** 를 완화.
- **서버 재기동** 시 거의 **필수**.
- **BSD/macOS**에서는 “**동일 (IP,PORT)** 중복 바인드 허용” 성격이 강해 **주의**. 리눅스와 의미가 다소 다름.

```cpp
// 사용 예
int yes = 1;
auto ok = setopt(sockfd, SOL_SOCKET, SO_REUSEADDR, yes);
if (!ok) print_errno("SO_REUSEADDR");
```

**요점**
- 리눅스: 같은 포트를 즉시 다시 `bind()` 하려면 켜두자.
- 다중 리스너 병렬 구동에는 `SO_REUSEPORT`를 쓰자.

### `SO_REUSEPORT` — 커널 로드밸런싱(멀티코어/멀티프로세스용)

- 목적: **여러 프로세스/스레드가 동일 (IP,PORT)** 를 동시에 `bind()`/`listen()` → 커널이 **연결을 분산**.
- NGINX/Envoy/Redis 등 **코어수만큼 리스너** 패턴에 쓰인다.

```cpp
int one = 1;
setopt(lfd, SOL_SOCKET, SO_REUSEADDR, one);
setopt(lfd, SOL_SOCKET, SO_REUSEPORT, one); // 다중 accept 파이프라인
```

**주의**
- 프로세스/스레드 간 **동일 backlog**/옵션을 맞추자.
- 리눅스 해시 기반 분배라 **완전 균등**은 보장되지 않지만, 스케일 아웃에 유용.

---

## 버퍼 크기: `SO_RCVBUF` / `SO_SNDBUF`
### 의미와 오토튜닝

- **수신 버퍼(`SO_RCVBUF`)**: 커널 **수신 큐** 크기 힌트. 크면 **백프레셔 늦게**, 작으면 **지연 짧게**.
- **송신 버퍼(`SO_SNDBUF`)**: 커널 **송신 큐** 크기 힌트. **BDP**를 채우려면 충분히 커야 함.
- 커널은 **오토튜닝**(자동 확장)을 수행. `setsockopt` 값이 **그대로** 적용되지 않을 수 있다(플랫폼/두 배 규칙 등).

```cpp
int rcv = 4<<20, snd = 4<<20; // 4MiB 힌트
setopt(fd, SOL_SOCKET, SO_RCVBUF, rcv);
setopt(fd, SOL_SOCKET, SO_SNDBUF, snd);
auto gr = getoptv<int>(fd, SOL_SOCKET, SO_RCVBUF);
auto gs = getoptv<int>(fd, SOL_SOCKET, SO_SNDBUF);
std::print("[buf] rcv={} snd={}\n", gr ? *gr : -1, gs ? *gs : -1);
```

**실무 팁**
- **RTT가 크거나** **대역폭이 큰** 링크에서 **BDP**를 계산해 **최소값**을 설정:
  $$
  \text{BDP} = \text{Bandwidth}\times\text{RTT}
  $$
- 지나치게 크면 **버퍼블로트**로 지연 증가. **측정 기반**으로 조정.

---

## 지연/패킷화: `TCP_NODELAY` / `TCP_CORK`(Linux)
### `TCP_NODELAY` — Nagle 비활성화(작은 메시지 지연 감소)

- **작은 payload**를 **즉시** 내보내도록.
- 라이브 채팅/실시간 제어 등 **지연 민감** 시 ON이 유리.

```cpp
int one = 1;
setopt(fd, IPPROTO_TCP, TCP_NODELAY, one);
```

**주의**
- 세그먼트 수 증가 → 헤더 오버헤드/CPU 부담 증가. **측정 후** 결정.

### `TCP_CORK`(Linux) — 묶어서 내보내기 (작은 세그먼트 억제)

- 반대로, 여러 쓰기 호출을 **코크로 막았다가** 큰 덩어리로 내보냄.
```cpp
int on = 1, off = 0;
setopt(fd, IPPROTO_TCP, TCP_CORK, on);
// ... write() 여러 번
setopt(fd, IPPROTO_TCP, TCP_CORK, off); // flush
```
- **HTTP/파일 전송** 등 “헤더→바디”를 **한 세그먼트**로 내보내고 싶을 때 유용.
- `TCP_NODELAY`와 **동시에 쓰지 말자**(정책 충돌).

---

## 종료 정책: `SO_LINGER`
### 개념

- `close()` 의 **행동**을 제어.
- `linger.l_onoff = 1, linger.l_linger = 0` → **RST 종료**: 큐에 남은 데이터 **폐기**, 상대는 **ECONNRESET**을 받는다.
- `l_onoff = 1, l_linger > 0` → `close()` 가 **최대 l\_linger** 동안 **블록**하며 전송을 시도.

```cpp
linger lg{.l_onoff=1, .l_linger=0}; // 즉시 RST
setopt(fd, SOL_SOCKET, SO_LINGER, lg);
```

**언제 유용한가?**
- **프로토콜 위반/보안**: 남은 데이터 무의미, **즉시 끊어야** 할 때.
- 평소엔 **기본(OFF)** 이 안전. 실수로 RST 종료하면 **데이터 유실**.

---

## Keepalive — 유휴 연결 생존/감지
### 왜 필요한가?

- NAT/방화벽/중간장비가 **유휴 TCP**를 **수 분~수 시간**에 끊는다.
- **Dead peer**(상대가 전원/네트워크를 잃음)를 **애플리케이션 레벨**에서 빨리 감지하고 싶을 때.

### 리눅스 옵션 3종

- `SO_KEEPALIVE` (켜기/끄기)
- `TCP_KEEPCNT` (실패 허용 횟수)
- `TCP_KEEPIDLE` (첫 keepalive까지 유휴 시간, 초)
- `TCP_KEEPINTVL` (keepalive 간격, 초)

```cpp
int ka = 1;
setopt(fd, SOL_SOCKET, SO_KEEPALIVE, ka);
int idle = 30;    setopt(fd, IPPROTO_TCP, TCP_KEEPIDLE,  idle);
int intvl = 10;   setopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, intvl);
int cnt = 3;      setopt(fd, IPPROTO_TCP, TCP_KEEPCNT,   cnt);
```

**동작**
- **유휴** `idle`초 후 **소형 keepalive probe** 전송. **응답 없음** → `intvl` 간격으로 `cnt`회 재시도. 실패 시 **연결 에러**로 간주.

**BSD/macOS 참고**
- macOS: `TCP_KEEPALIVE`(idle), `TCP_KEEPINTVL`, `TCP_KEEPCNT` 지원. 이름/단위 차이 주의.

---

## 타임아웃: `TCP_USER_TIMEOUT` (응용 관점의 송신 한계시간)

- 의미: 상대가 ACK을 보내지 않아 **송신 큐**가 지연될 때, **최대 대기 시간**.
- 초과 시 연결을 **에러**로 종료하여 **무한 대기**를 방지.

```cpp
int ms = 20000; // 20s
setopt(fd, IPPROTO_TCP, TCP_USER_TIMEOUT, ms);
```

---

## 수신 ACK 정책: `TCP_QUICKACK` (Linux, 비정규)

- 일부 커널에서 **Delayed ACK**를 완화. **지연 감소** 목적의 힌트.
- 지속적 보장은 아님(커널 상황에 따라 무시/재설정).

```cpp
int on = 1;
setopt(fd, IPPROTO_TCP, TCP_QUICKACK, on);
```

---

## 연결 수락/지연: `TCP_DEFER_ACCEPT` (Linux)

- **SYN 후 애플리케이션을 깨우지 않고**, **데이터가 도착**했을 때 `accept()`가 성공하도록 지연.
- 장점: **SYN flood 완화**, 불필요한 **빈 연결** 감소, 수신 데이터 즉시 처리.

```cpp
int sec = 5; // 데이터가 5초 내 오길 기다림
setopt(lfd, IPPROTO_TCP, TCP_DEFER_ACCEPT, sec);
```

---

## 초기 데이터: `TCP_FASTOPEN` (Linux)

- **TFO**: 3-way와 **동시에 데이터 전송**. 연결 지연 감소(특히 재연결).
- 서버/클라이언트 **각각 설정** 필요 + 커널/시스템 설정.

```cpp
// 서버
int qlen = 5;
setopt(lfd, IPPROTO_TCP, TCP_FASTOPEN, qlen);
// 클라이언트
int on = 1;
setopt(cfd, IPPROTO_TCP, TCP_FASTOPEN, on);
// connect/sendto(MSG_FASTOPEN) 등 패스 필요
```

**주의**
- 중간 장비/방화벽 호환성 이슈가 있을 수 있음. **환경 측정 필수**.

---

## 서비스 품질 힌트: `IP_TOS` (DSCP/ECN)

- DSCP(상위 6비트)에 **우선순위** 힌트를 담아 네트워크 장비가 **QoS**를 적용할 수 있게 한다. (환경 의존)

```cpp
int tos = 0x28; // DSCP=0x0A(예시) <<2 | ECN bits
setopt(fd, IPPROTO_IP, IP_TOS, tos);
```

---

## 관측: `TCP_INFO` — RTT/재전송/윈도우 등

- 연결의 상태를 **정수값**으로 얻는다. 튜닝/실험 필수 도구.

```cpp
#include <netinet/tcp.h>
#include <print>

void log_tcp_info(int fd, std::string_view tag) {
    tcp_info info{}; socklen_t len = sizeof(info);
    if (::getsockopt(fd, IPPROTO_TCP, TCP_INFO, &info, &len) == 0) {
        std::print("[tcp_info][{}] rtt={}us cwnd={} rcv_space={} snd_ssthresh={} retrans={}\n",
                   tag, info.tcpi_rtt, info.tcpi_snd_cwnd, info.tcpi_rcv_space,
                   info.tcpi_snd_ssthresh, info.tcpi_total_retrans);
    }
}
```

---

## TIME_WAIT / 재기동 / 백로그의 의미
### TIME\_WAIT — 누가 들어가나?

- **능동 종료(먼저 FIN 보낸 쪽)** 가 **TIME\_WAIT**.
- 목적: **지연된 패킷 소거**, **연결 재활용 충돌 방지**.

### 재기동과 `SO_REUSEADDR`

- 서버 재기동 시 이전 프로세스가 남긴 소켓들(TIME\_WAIT 등) 때문에 **EADDRINUSE** → `SO_REUSEADDR` 로 완화.
- 하지만 **커널 정책/포트 상태**에 따라 여전히 실패 가능 → **백오프/재시도** 준비.

### 백로그(두 종류)

- `listen(fd, backlog)` 의 **백로그** = **완료 큐(accept queue)** 힌트.
- 별개로 **SYN 큐**(half-open): `tcp_max_syn_backlog` (sysctl).
- 리눅스는 `backlog` 를 `somaxconn` 으로 **캡**한다.

```bash
# 확인

cat /proc/sys/net/core/somaxconn
cat /proc/sys/net/ipv4/tcp_max_syn_backlog
```

**SYN flood 대비**
- `syncookies` 활성화 가능. 단, 일부 기능 제약.
- `TCP_DEFER_ACCEPT` 로 **데이터 동반 연결**만 빨리 수락.

---

## 실습: 다양한 옵션의 **전/후 지표 비교**

> **목표**: 같은 부하에서 옵션 전/후 **RTT/재전송/처리량/지연** 변화를 **수치로** 확인.
> 준비: 6장에서 만들었던 **스루풋 서버/클라이언트**, 또는 간단 에코 서버 사용.

### 테스트 하네스(서버 측 옵션 플래그)

```cpp
// opt_server.cpp — 리스너/수락 소켓에 옵션을 걸고 echo 처리
// 빌드: g++ -std=c++23 -O2 opt_server.cpp -o opt_server
#include "sockopt.hpp"
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <vector>
#include <print>
#include <string>
#include <cstring>

int main(int argc, char** argv){
    // args: <port> [reuseport=0|1] [defer=0|sec] [rcvbuf_k=0] [sndbuf_k=0] [nodelay=0|1] [linger=off|rst|sec]
    if (argc < 2) {
        std::print(stderr, "usage: {} <port> [reuseport] [defer_sec] [rcvbuf_k] [sndbuf_k] [nodelay] [linger]\n", argv[0]);
        return 1;
    }
    const char* port = argv[1];
    int reuseport = (argc>2)? std::stoi(argv[2]) : 0;
    int defer_sec = (argc>3)? std::stoi(argv[3]) : 0;
    int rcvbuf_k  = (argc>4)? std::stoi(argv[4]) : 0;
    int sndbuf_k  = (argc>5)? std::stoi(argv[5]) : 0;
    int nodelay   = (argc>6)? std::stoi(argv[6]) : 0;
    std::string linger_arg = (argc>7)? argv[7] : "off";

    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(nullptr, port, &hints, &res)!=0) { perror("gai"); return 1; }

    int lfd=-1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        lfd = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (lfd < 0) continue;
        int one=1;
        setopt(lfd, SOL_SOCKET, SO_REUSEADDR, one);
        if (reuseport) setopt(lfd, SOL_SOCKET, SO_REUSEPORT, one);
        if (ai->ai_family == AF_INET6) {
            int v6only=0; setopt(lfd, IPPROTO_IPV6, IPV6_V6ONLY, v6only);
        }
        if (defer_sec>0) setopt(lfd, IPPROTO_TCP, TCP_DEFER_ACCEPT, defer_sec);
        if (::bind(lfd, ai->ai_addr, ai->ai_addrlen)==0 && ::listen(lfd, 512)==0) break;
        ::close(lfd); lfd=-1;
    }
    freeaddrinfo(res);
    if (lfd<0) { perror("listen"); return 1; }
    std::print("[server] listening on :{}\n", port);

    for(;;){
        sockaddr_storage ss{}; socklen_t slen=sizeof(ss);
        int cfd = ::accept(lfd, (sockaddr*)&ss, &slen);
        if (cfd<0){ if(errno==EINTR) continue; perror("accept"); continue; }

        // per-connection options
        if (nodelay) { int on=1; setopt(cfd, IPPROTO_TCP, TCP_NODELAY, on); }
        if (rcvbuf_k>0){ int sz=rcvbuf_k*1024; setopt(cfd, SOL_SOCKET, SO_RCVBUF, sz); }
        if (sndbuf_k>0){ int sz=sndbuf_k*1024; setopt(cfd, SOL_SOCKET, SO_SNDBUF, sz); }
        if (linger_arg == "rst") {
            linger lg{.l_onoff=1, .l_linger=0}; setopt(cfd, SOL_SOCKET, SO_LINGER, lg);
        } else if (linger_arg != "off") {
            int sec = std::stoi(linger_arg);
            linger lg{.l_onoff=1, .l_linger=sec}; setopt(cfd, SOL_SOCKET, SO_LINGER, lg);
        }

        // 간단 에코 (프레이밍 없이 raw, 테스트용)
        std::vector<char> buf(64<<10);
        for(;;){
            auto info = getoptv<tcp_info>(cfd, IPPROTO_TCP, TCP_INFO);
            if (info) {
                std::print("[tcp_info] rtt={}us cwnd={} rcv_space={} retrans={}\n",
                           info->tcpi_rtt, info->tcpi_snd_cwnd, info->tcpi_rcv_space, info->tcpi_total_retrans);
            }
            ssize_t n = ::recv(cfd, buf.data(), buf.size(), 0);
            if (n>0) {
                ssize_t w=0;
                while (w<n) {
                    ssize_t m = ::send(cfd, buf.data()+w, n-w, 0);
                    if (m>0) w+=m; else if (m<0 && errno==EINTR) continue; else break;
                }
                continue;
            } else if (n==0) {
                ::close(cfd); break;
            } else if (errno==EINTR) continue;
            else { perror("recv"); ::close(cfd); break; }
        }
    }
}
```

### 클라이언트 하네스(옵션 플래그/부하)

```cpp
// opt_client.cpp — 옵션 조합과 부하 패턴 전송
// 빌드: g++ -std=c++23 -O2 opt_client.cpp -o opt_client
#include "sockopt.hpp"
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <print>
#include <vector>
#include <string>
#include <chrono>

int main(int argc, char** argv){
    // args: <host> <port> [nodelay=0|1] [sndbuf_k=0] [rcvbuf_k=0] [keepalive=0|1] [idle] [intvl] [cnt]
    if (argc < 3) {
        std::print(stderr, "usage: {} <host> <port> [nodelay] [sndbuf_k] [rcvbuf_k] [keepalive] [idle] [intvl] [cnt]\n", argv[0]);
        return 1;
    }
    const char* host=argv[1]; const char* port=argv[2];
    int nodelay = (argc>3)? std::stoi(argv[3]) : 0;
    int sndbuf_k= (argc>4)? std::stoi(argv[4]) : 0;
    int rcvbuf_k= (argc>5)? std::stoi(argv[5]) : 0;
    int keepalive = (argc>6)? std::stoi(argv[6]) : 0;
    int idle=(argc>7)?std::stoi(argv[7]):60;
    int intvl=(argc>8)?std::stoi(argv[8]):10;
    int cnt=(argc>9)?std::stoi(argv[9]):3;

    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(host, port, &hints, &res)!=0) { perror("gai"); return 1; }
    int s=-1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        if (nodelay){ int on=1; setopt(s, IPPROTO_TCP, TCP_NODELAY, on); }
        if (sndbuf_k>0){ int sz=sndbuf_k*1024; setopt(s, SOL_SOCKET, SO_SNDBUF, sz); }
        if (rcvbuf_k>0){ int sz=rcvbuf_k*1024; setopt(s, SOL_SOCKET, SO_RCVBUF, sz); }
        if (keepalive){
            int on=1; setopt(s, SOL_SOCKET, SO_KEEPALIVE, on);
            setopt(s, IPPROTO_TCP, TCP_KEEPIDLE,  idle);
            setopt(s, IPPROTO_TCP, TCP_KEEPINTVL, intvl);
            setopt(s, IPPROTO_TCP, TCP_KEEPCNT,   cnt);
        }
        if (::connect(s, ai->ai_addr, ai->ai_addrlen)==0) break;
        ::close(s); s=-1;
    }
    freeaddrinfo(res);
    if (s<0){ perror("connect"); return 1; }

    // 부하: 작은 메시지 N회 + 큰 메시지 1회
    std::vector<char> small(64, 's');
    for (int i=0;i<10000;i++) ::send(s, small.data(), small.size(), 0);
    std::vector<char> big(1<<20, 'B'); // 1MiB
    auto t0 = std::chrono::steady_clock::now();
    size_t total=0;
    for (int i=0;i<64;i++){
        ssize_t n = ::send(s, big.data(), big.size(), 0);
        if (n>0) total += (size_t)n; else if (n<0 && errno==EINTR) { --i; continue; }
    }
    auto t1 = std::chrono::steady_clock::now();
    double sec = std::chrono::duration<double>(t1-t0).count();
    std::print("[client] bulk={} bytes in {:.3f}s → {:.3f} MB/s\n", total, sec, (total/1e6)/sec);

    // 서버 echo 읽기(drain)
    std::vector<char> buf(256<<10);
    while (::recv(s, buf.data(), buf.size(), 0) > 0) {}
    ::close(s);
}
```

### 실행 시나리오 (전/후 비교)

1) **기본값**
   - 서버: `./opt_server 9000 0 0 0 0 0 off`
   - 클라: `./opt_client 127.0.0.1 9000 0 0 0 0`
   - 관측: 작은 메시지 다량 전송 시 **지연**/처리량 값 기록.

2) **`TCP_NODELAY` ON**
   - 서버: 기본
   - 클라: `./opt_client 127.0.0.1 9000 1`
   - 관측: 작은 메시지 응답 지연 **감소**(세그먼트 증가 가능).

3) **버퍼 확장**
   - 서버: `./opt_server 9000 0 0 4096 4096 0 off` (4MiB rcv/snd)
   - 클라: `./opt_client 127.0.0.1 9000 0 4096 4096`
   - 관측: RTT가 큰 환경에서 **처리량 향상** (BDP 대비).

4) **Keepalive**
   - 클라: `./opt_client 127.0.0.1 9000 0 0 0 1 15 5 3`
   - 관측: 유휴 상태에서 **TCP_INFO** 재전송/RTT 변동, NAT 환경에서 **유휴 연결 유지** 확인.

5) **`SO_LINGER`=RST**
   - 서버: `./opt_server 9000 0 0 0 0 0 rst`
   - 관측: 클라이언트가 **읽기 전에 종료하면** `ECONNRESET`/데이터 유실. **정책적 사용**만.

6) **`TCP_DEFER_ACCEPT`**
   - 서버: `./opt_server 9000 0 5`
   - 관측: 단순 SYN만 오는 연결은 **accept 지연**. 데이터가 동반되면 빠르게 수락.

> 각 경우마다 `ss -tinp`/`tcpdump`/`strace -e trace=network`/`TCP_INFO` 로 **수치/상태**를 **로그**에 남겨 **전/후 비교표**를 만들어 보라.

---

## 옵션 개요 표 (요약 리마인드)

| 옵션 | 레벨 | 효과/목적 | 주의/비고 |
|---|---|---|---|
| `SO_REUSEADDR` | SOL\_SOCKET | 재기동/포트 회수 완화 | BSD 의미 상이(중복 바인드 주의) |
| `SO_REUSEPORT` | SOL\_SOCKET | 동일 (IP,PORT) 다중 리스너 | 커널 분산; N:M accept |
| `SO_RCVBUF/SO_SNDBUF` | SOL\_SOCKET | 커널 버퍼 힌트(오토튜닝) | BDP 대비/버퍼블로트 |
| `TCP_NODELAY` | IPPROTO\_TCP | Nagle off(지연↓) | 세그먼트↑/헤더오버헤드 |
| `TCP_CORK`(Linux) | IPPROTO\_TCP | 묶어 보내기 | NODELAY와 충돌 지양 |
| `SO_LINGER` | SOL\_SOCKET | close 동작 제어 | RST 종료는 데이터 유실 |
| `SO_KEEPALIVE` | SOL\_SOCKET | keepalive 켜기 | 하위 3옵션 조합 |
| `TCP_KEEPIDLE/INTVL/KEEPCNT` | IPPROTO\_TCP | KA 타이머/횟수 | 플랫폼명/단위 차이 |
| `TCP_USER_TIMEOUT` | IPPROTO\_TCP | 송신 ack 대기 한계 | 무한 블록 방지 |
| `TCP_DEFER_ACCEPT` | IPPROTO\_TCP | 데이터 올 때 accept | Linux 고유 |
| `TCP_FASTOPEN` | IPPROTO\_TCP | 초기 데이터 | 환경 호환성 체크 |
| `IP_TOS` | IPPROTO\_IP | DSCP/ECN 힌트 | 네트워크 정책 의존 |
| `TCP_QUICKACK` | IPPROTO\_TCP | ACK 지연 완화 힌트 | 지속보장 아님 |

---

## 숫자로 보는 튜닝 직관 (짧은 수식)

- **필요 윈도우 조건**
  $$
  \min\{\text{cwnd},\ \text{rwnd}\} \gtrsim \text{BDP}
  $$
- **BDP**
  $$
  \text{BDP} = \text{Bandwidth} \times \text{RTT}
  $$
- **손실 환경 처리량(직관)**
  $$
  \text{Throughput} \approx \frac{\text{MSS}}{\text{RTT}\sqrt{p}}
  $$

옵션 조합으로 **cwnd 성장**(손실↓/지연↓), **rwnd/버퍼**(수신 여유↑), **지연/세그먼트화**(NODELAY/CORK) 를 **상황 맞춤** 조정.

---

## 현장 체크리스트

- [ ] 재기동/포트 회수: **`SO_REUSEADDR`**. 멀티 워커: **`SO_REUSEPORT`**.
- [ ] RTT/대역폭에 맞춘 **버퍼 힌트**(`SO_RCVBUF/SO_SNDBUF`) — **BDP** 계산 후 적용.
- [ ] 작은 메시지 지연 감소: **`TCP_NODELAY`** (측정 기반). 묶기: **`TCP_CORK`**.
- [ ] 종료 정책: 기본 **linger OFF**. RST 종료는 **의도적 상황**에서만.
- [ ] 유휴 연결 생존/감지: **Keepalive 3종**. NAT/방화벽 환경 필수.
- [ ] 무한 대기 방지: **`TCP_USER_TIMEOUT`**.
- [ ] accept/SYN 큐/백로그: `somaxconn`/`tcp_max_syn_backlog`/`TCP_DEFER_ACCEPT` 점검.
- [ ] 관측 루틴: **`TCP_INFO`** 정기 로깅, `ss`/`tcpdump`/`strace` 병행.

---

### 마무리

옵션은 **마법**이 아니다. **링크·RTT·손실·부하 패턴**이라는 현실 위에 **정책**을 부여할 뿐이다. 이 장에서 정리한 옵션 조합과 실습 하네스를 활용해, **수치로 전/후를 비교**하는 습관을 들이면 현장 문제(“왜 느리지?” “왜 끊기지?”)에 **정확한 처방**을 내릴 수 있다. 다음 장에서는 **논블로킹 I/O + epoll** 로 넘어가 **옵션과 이벤트 루프**가 만나는 실전 구조를 세운다.
