---
layout: post
title: 디지털신호처리 - DFT를 이용한 선형 콘벌루션
date: 2025-11-11 19:25:23 +0900
category: 디지털신호처리
---
# DFT를 이용한 선형 콘벌루션

## 맥락과 목표

앞선 글에서 정리한 **DFT/IDFT 정의**, **원형(주기) 콘벌루션 정리**, **DFS/DTFT/Z-변환 연결**을 기반으로, 이번 글은 **DFT(FFT)로 “선형” 콘벌루션을 정확하고 효율적으로 수행**하는 방법을 한 자리에서 정리한다. 특히,

- 왜 주파수 영역의 곱이 **원형** 콘벌루션과 동치인가
- 어떻게 **제로패딩**으로 **선형** 콘벌루션을 정확히 얻는가
- 실시간/대용량에서 **Overlap-Add(OLA)**, **Overlap-Save(OLS)** 를 어떻게 구현/튜닝하는가
- 블록 길이 \(L\), FFT 길이 \(N\), 지연(latency), 수치 안정/정밀도, 고정소수점 스케일링
- **파티셔닝(partitioned convolution)** 으로 매우 긴 임펄스응답(IR)을 실시간 처리하는 법

---

## 선형 vs 원형 콘벌루션 — 관계 정리

### 정의

길이 \(L_x\), \(L_h\) 시퀀스 \(x[n], h[n]\)의 **선형** 콘벌루션:
$$
y[n] = (x*h)[n] = \sum_{m=-\infty}^{\infty} x[m]\;h[n-m], \quad L_y = L_x + L_h - 1.
$$

길이 \(N\)의 **원형**(주기 \(N\)) 콘벌루션:
$$
y_c[n] = \sum_{m=0}^{N-1} x[m]\;h[(n-m)\!\!\!\mod N].
$$

### DFT 곱 = 원형 콘벌루션

길이 \(N\) DFT/IDFT에 대해
$$
X[k]=\sum_{n=0}^{N-1}x[n]e^{-j2\pi kn/N},\quad
x[n]=\frac{1}{N}\sum_{k=0}^{N-1}X[k]e^{+j2\pi kn/N].
$$
그렇다면
$$
Y[k]=X[k]H[k]\ \Longleftrightarrow\ y[n]= (x\overset{N}{\circledast}h)[n].
$$

### 선형 결과를 얻는 **제로패딩 조건**

**핵심 조건**:
$$
N \;\ge\; L_x + L_h - 1.
$$
\(x,h\)를 각각 길이 \(N\)으로 0-패딩해 FFT→곱→IFFT 하면,
$$
y[n]=\text{IDFT}_N\{X[k]H[k]\}\ \Rightarrow\ \text{처음 }L_x+L_h-1\text{ 샘플이 선형 결과와 정확히 일치}.
$$

---

## 단발성(offline) 선형 콘벌루션 — 제로패딩 구현

### 절차 요약

1) \(N \gets 2^{\lceil\log_2(L_x+L_h-1)\rceil}\) (또는 그 이상)
2) \(x_z=[x,0,\dots,0],\ h_z=[h,0,\dots,0]\) (각 길이 \(N\))
3) \(X=\mathrm{FFT}(x_z),\ H=\mathrm{FFT}(h_z)\)
4) \(Y=X\cdot H\)
5) \(y=\mathrm{IFFT}(Y)\), 앞 \(L_x+L_h-1\) 샘플 취함

### GNU Octave 예제 — `conv`와 동일성 확인

```octave
clear; close all; clc
% (선택) FIR 설계를 위한 패키지
% pkg load signal

% 유틸: RMS 오차
rms_err = @(a,b) sqrt(mean(abs(a(:)-b(:)).^2));

% 신호와 필터
x = randn(1,1200);
h = hamming(81)';         % 예제 FIR (81 탭)
Ly = numel(x) + numel(h) - 1;

% 제로패딩 FFT 길이
N = 2^nextpow2(Ly);

% 패딩
xz = [x, zeros(1, N - numel(x))];
hz = [h, zeros(1, N - numel(h))];

% 주파수 영역 곱
Y = fft(xz) .* fft(hz);

% 시간 영역 복원 + 유효 길이 취함
y_fft = ifft(Y);
y_fft = y_fft(1:Ly);

% 참조
y_ref = conv(x, h);

fprintf("RMS error (FFT vs conv) = %.3e\n", rms_err(y_fft, y_ref));
```

---

## 실시간/대용량을 위한 블록 기반 — OLA/OLS

전체 길이를 한 번에 제로패딩하기 어렵거나 **실시간**인 경우, 입력을 **블록**으로 나눠 FFT-곱-IFFT를 반복한다. 이때 블록 간 **wrap-around**를 제거하는 구조가 **Overlap-Add(OLA)**, **Overlap-Save(OLS)**.

### 공통 파라미터

- 필터 길이 \(M=L_h\)
- 유효 입력 블록 길이 \(L\)
- FFT 길이 \(N\ge L+M-1\) (보통 \(2\)의 거듭제곱)
- 사전계산: \(H=\mathrm{FFT}_N([h,0,\dots])\)

**지연(latency)**: 일반적으로 한 블록 수준. 실시간 요구가 크면 \(L,N\)을 줄여 지연을 낮추되, CPU 부하가 증가.

---

## Overlap-Add (OLA)

### 아이디어

블록 \(x_b\) (\(L\) 샘플)을 길이 \(N\)으로 0-패딩 → FFT → \(H\)와 곱 → IFFT로 길이 \(N\) 출력 \(y_b\) 획득.
이 \(y_b\)를 **출력 버퍼에 겹쳐 더함**(뒤쪽 \(M-1\) 샘플이 다음 블록 앞쪽과 중첩).

### Octave 구현

```octave
function y = conv_ola(x, h, L)
  % x: 입력 (1xNx)
  % h: FIR 계수 (1xM)
  % L: 유효 입력 블록 길이
  M = numel(h);
  Nfft = 2^nextpow2(L + M - 1);
  H = fft([h, zeros(1, Nfft - M)]);
  Nx = numel(x);
  y = zeros(1, Nx + M - 1);

  in_idx = 1; out_idx = 1;
  while in_idx <= Nx
    xe = x(in_idx:min(in_idx + L - 1, Nx));
    Xb = fft([xe, zeros(1, Nfft - numel(xe))]);
    yb = ifft(Xb .* H);                  % 길이 Nfft
    y(out_idx : out_idx + Nfft - 1) += yb;
    in_idx += L;
    out_idx += L;
  endwhile

  % 길이 정합(넘친 tail이 있을 수도 있으므로 잘라준다)
  y = y(1 : Nx + M - 1);
endfunction

% 검증
clear; close all; clc
rms_err = @(a,b) sqrt(mean(abs(a(:)-b(:)).^2));
x = randn(1, 20000);
h = fir1(255, 0.2);    % 저역통과 FIR (256 taps)
L = 1024;
y_ola = conv_ola(x, h, L);
y_ref = conv(x, h);
printf("OLA vs conv RMS=%.3e\n", rms_err(y_ola, y_ref));
```

**장점**: 구현이 직관적(“겹침-더하기”).
**주의**: 출력 버퍼의 인덱스/길이 관리.

---

## Overlap-Save (OLS)

### 아이디어

길이 \(N\) FFT 블록의 **앞 \(M-1\)** 샘플은 이전 블록 tail(오버랩), 뒤 \(L=N-M+1\) 샘플은 새로운 입력.
IFFT 결과의 **앞 \(M-1\)** 샘플은 wrap-around 구간이므로 **버리고**, 뒤 \(L\) 샘플만 **저장**.

### Octave 구현

```octave
function y = conv_ols(x, h, Nfft)
  % x: 입력 (1xNx)
  % h: FIR 계수 (1xM)
  % Nfft: FFT 길이 (Nfft >= M), 유효 출력 L = Nfft - M + 1
  M = numel(h);
  if Nfft < M, error("Nfft must be >= M"); endif
  L = Nfft - M + 1;
  Nx = numel(x);

  H = fft([h, zeros(1, Nfft - M)]);
  y = zeros(1, Nx + M - 1);

  % 초기 오버랩(M-1 zeros)
  overlap = zeros(1, M-1);
  in_idx  = 1; out_idx = 1;

  while in_idx <= Nx
    xe  = x(in_idx : min(in_idx + L - 1, Nx));
    blk = [overlap, xe];
    if numel(blk) < Nfft
      blk = [blk, zeros(1, Nfft - numel(blk))];
    end
    Yb = ifft( fft(blk) .* H );
    yb = Yb(M:end);                       % 앞 M-1 샘플 버림(유효 L)

    % 출력 배치
    nout = min(L, Nx - in_idx + 1);
    y(out_idx : out_idx + nout - 1) = yb(1:nout);

    % 다음 루프 준비
    overlap = blk(end - (M-2) : end);
    in_idx  += L;
    out_idx += L;
  endwhile
endfunction

% 검증
clear; close all; clc
rms_err = @(a,b) sqrt(mean(abs(a(:)-b(:)).^2));
x = randn(1, 20000);
h = fir1(255, 0.2);
Nfft = 2048;
y_ols = conv_ols(x, h, Nfft);
y_ref = conv(x, h);
printf("OLS vs conv RMS=%.3e\n", rms_err(y_ols, y_ref));
```

**장점**: 출력은 “유효 구간만 저장” → 스트리밍에 적합.
**주의**: **버릴 샘플의 개수(앞 \(M-1\))** 와 오버랩 버퍼 업데이트를 정확히.

---

## OLA vs OLS — 선택 가이드

| 구분 | OLA | OLS |
|---|---|---|
| 입력 블록 | 새 샘플 \(L\)만 | 이전 tail \(M\!-\!1\) + 새 \(L\) |
| 출력 처리 | IFFT 전체를 겹쳐 더함 | IFFT 앞 \(M\!-\!1\) 버리고 뒤 \(L\)만 채택 |
| 구현 직관성 | 높음 | 인덱스 주의 필요 |
| 지연/성능 | 유사(선택한 \(L,N\)에 좌우) | 유사 |
| 실무 용례 | 오디오/통신 전반 | 스트리밍, 드라이버/펌웨어 등 |

둘 다 wrap-around를 제거하는 **정확한 선형 합성**이며, 선호/파이프라인 구조에 따라 선택한다.

---

## 블록 길이 \(L\), FFT 길이 \(N\) — 계산량·지연 트레이드오프

### 복잡도 근사

- 직접 선형 conv: \(\mathcal{O}(L_x L_h)\)
- FFT 기반 블록: 블록마다 \(2\cdot \mathrm{FFT}(N) + N\) 곱셈 \(\Rightarrow \mathcal{O}(N\log N)\)

**긴 FIR**(\(M\) 큼)일수록 FFT 이점이 커짐.

### 선택 원칙

- **제약**: \(N \ge L + M - 1\)
- 보통 \(N\)은 \(2\)의 거듭제곱
- 지연을 낮추려면 \(L\)↓, \(N\)↓ (대신 호출 빈도↑ → 총 연산량↑ 가능)
- 벤치마킹으로 하드웨어별 최적 \(L,N\) 탐색

### 간단한 탐색 코드

```octave
clear; clc
rms_err = @(a,b) sqrt(mean(abs(a(:)-b(:)).^2));
x = randn(1, 1e5);
M = 1024; h = fir1(M-1, 0.2);
L_list = [256 512 1024 2048 4096];
for L = L_list
  tic; y = conv_ola(x, h, L); t=toc;
  Nfft = 2^nextpow2(L + M - 1);
  printf("OLA: L=%4d, Nfft=%5d, time=%.3fs, len(y)=%d\n", L, Nfft, t, numel(y));
end
```

---

## 정렬(Alignment)·경계·시간축

- FIR 선형위상(대칭)일 때 군지연은 \((M-1)/2\) (참고용). **선형 콘벌루션 결과**는 그 지연을 포함하는 것이 정상.
- OLA/OLS 출력 인덱스는 **선형 conv와 동일한 시간축**으로 누적되도록 구현(상기 코드 참조).
- 마지막 블록의 패딩/트렁케이션을 명확히 처리해 **길이 \(L_x+L_h-1\)** 를 보장.

---

## 수치 안정·정밀도·스케일링

### 스케일

Octave의 `ifft`는 \(1/N\) 스케일을 내부에 포함. 추가 스케일 필요 없음(진폭 일치).

### 부동소수점

- 매우 긴 데이터에서는 누적 오차가 생길 수 있으므로 **double** 권장
- 덧셈 순서(큰 값 + 작은 값) 민감 → **겹침-더하기 순서**를 일정하게 유지
- DC drift 방지 위해 블록 평균 제거가 필요한 응용도 있음

### 고정소수점(정수) 개요

- FFT 전 **스케일링**으로 오버플로 방지(블록 플로팅: 블록별 지수 공유)
- IFFT 후 **반올림/포화(saturation)** 규칙 명확화
- Q-format 변환(예: 1.0 ↔ 32767) 및 headroom 예산 수립

---

## “창(window)”과 프레이밍에 관하여

- **선형 필터링(콘벌루션)** 자체에는 창이 **필요하지 않다**.
- 창은 **스펙트럼 분석**에서 누출 억제를 위해 사용한다(DFT 파트).
- **STFT 기반 처리**(예: 노이즈 억제, 위너 필터)는 프레임 창 + OLA 합성이 쓰이지만, 이는 본 글의 OLA/OLS(시간영역 선형 필터)와 목적·수학이 다르다.

---

## 파티셔닝(Partitioned Convolution) — 긴 IR을 빠르게

긴 IR \(h\)를 여러 **파티션**으로 나눠 각 파티션의 FFT를 사전계산→ **주파수 영역 누적**으로 처리 시간을 분산/단축.

### 개념

- \(h = [h^{(0)}, h^{(1)}, \ldots, h^{(P-1)}]\), 각 길이 \(B\)
- FFT 길이 \(N=2B\) (또는 그 이상)
- 프레임 \(b\)에서
  $$
  Y_b[k] = \sum_{p=0}^{P-1} X_{b-p}[k]\;H^{(p)}[k]
  $$
  을 계산(시간영역 해석으로는 OLA)

### 데모 구현(개념 강조)

```octave
function y = conv_partitioned(x, h, B)
  % x: 입력, h: 긴 IR, B: 파티션/프레임 길이
  Nfft = 2*B;
  P = ceil(numel(h)/B);
  Hs = cell(1,P);
  for p=1:P
    seg = h((p-1)*B+1 : min(p*B, numel(h)));
    Hs{p} = fft([seg, zeros(1, Nfft - numel(seg))]);
  end

  Lx = numel(x);
  y = zeros(1, Lx + numel(h) - 1);
  num_frames = ceil(Lx / B);
  Xbuf = cell(1,P);            % 최근 P개의 X FFT 보관

  for b=1:num_frames
    xb = x((b-1)*B+1 : min(b*B, Lx));
    Xb = fft([xb, zeros(1, Nfft - numel(xb))]);
    Xbuf = [{Xb}, Xbuf(1:end-1)];   % 새 프레임을 앞에 삽입

    Ysum = zeros(1, Nfft);
    for p=1:P
      if ~isempty(Xbuf{p})
        Ysum += Xbuf{p} .* Hs{p};
      end
    end
    yb = ifft(Ysum);           % 길이 Nfft

    % OLA 배치: 프레임 시작점에 더한다
    out_idx = (b-1)*B + 1;
    y(out_idx : out_idx + Nfft - 1) += yb;
  end
endfunction

% 검증
clear; close all; clc
rms_err = @(a,b) sqrt(mean(abs(a(:)-b(:)).^2));
x = randn(1, 8000);
h = randn(1, 5000) .* hamming(5000)';   % 길고 완만한 IR
B = 1024;
y_part = conv_partitioned(x, h, B);
y_ref  = conv(x, h);
printf("Partitioned vs conv RMS=%.3e\n", rms_err(y_part, y_ref));
```

**실무 팁**: 초기 수 ms는 **더 짧은 파티션**(저지연), 이후는 **긴 파티션**(효율)으로 처리하는 **하이브리드 파티셔닝**이 널리 쓰인다.

---

## 검증·단위테스트·벤치마크

### 단위테스트 포인트

- `conv`와 RMS/최대오차 비교
- 임펄스 입력 → 출력이 **정확히** \(h\)인지
- 스텝 입력 → 누적합 형태/안정성 점검
- 난수 반복 테스트(시드 고정), 경계 길이(매우 짧은/긴) 케이스

### 벤치마크 스케치

```octave
clear; close all; clc
rms_err = @(a,b) sqrt(mean(abs(a(:)-b(:)).^2));
x = randn(1, 5e5);
for M=[129, 257, 513, 1025, 2049]
  h = fir1(M-1, 0.2);
  L = 2^12;
  tic; y_ola = conv_ola(x, h, L);  t_ola=toc;
  Nfft = 2^nextpow2(L + M - 1);
  tic; y_ols = conv_ols(x, h, Nfft); t_ols=toc;
  tic; y_ref = conv(x, h);         t_ref=toc;
  printf("M=%4d | conv:%.2fs, OLA:%.2fs, OLS:%.2fs | err(OLA)=%.2e err(OLS)=%.2e\n", ...
    M, t_ref, t_ola, t_ols, rms_err(y_ola,y_ref), rms_err(y_ols,y_ref));
end
```

---

## 수학 요약(핵심 등식)

### 제로패딩에 의한 선형 결과

$$
\begin{aligned}
&N \ge L_x + L_h - 1,\quad x_z=\mathrm{zp}_N(x),\ h_z=\mathrm{zp}_N(h) \\
&y[n] = \mathrm{IDFT}_N\{\mathrm{DFT}_N(x_z)\,\mathrm{DFT}_N(h_z)\}[n] \\
&\Rightarrow\ y[n] = (x*h)[n],\quad 0\le n < L_x + L_h - 1.
\end{aligned}
$$

### OLA/OLS의 wrap 제거 원리(스케치)

- OLA: 블록 IFFT 결과의 뒤 \(M-1\) 샘플은 다음 블록의 앞 랩 구간과 **동일** → 시간축에서 **겹침-더하기**로 상쇄되어 **선형 합성**이 됨.
- OLS: 입력 블록에 **앞 \(M-1\)** 오버랩을 제공하면, IFFT의 앞 \(M-1\) 샘플이 wrap 구간이므로 **버림**으로 정확한 선형 구간만 남김.

---

## 자주 하는 실수와 점검표

- **\(N < L + M - 1\)**: wrap-around 발생 → 테일이 앞쪽으로 섞여 에러
- **OLS 버림 샘플 수 착오**: 앞 \(M-1\)을 정확히 버리지 않으면 경계 아티팩트
- **스케일 혼동**: IFFT의 \(1/N\)을 중복/누락 적용 → 진폭 불일치
- **지연 오해**: 블록 지연 vs 필터 고유 지연(군지연) 혼동 금지
- **메모리 재할당**: 동적 `append` 남발 → 성능/단편화 악화 → **사전할당** 권장
- **고정소수점 포화**: 스케일링 정책·포화/반올림 규칙을 명확히

---

## 확장: 멀티채널·실시간 오디오·GPU

- **멀티채널**: 채널 독립 OLA/OLS, 공통 IR이면 \(H\) 재사용
- **실시간 오디오**: 프레임(예: 128/256 샘플) 주기 내에 FFT 블록 처리 완료 필요 → 파티셔닝/하이브리드로 지연-성능 절충
- **GPU/Batched FFT**: 큰 \(N\), 다채널/다프레임에서 throughput 향상

---

## 연습문제 (풀이/코드 포함)

### 문제 1) 제로패딩 임계 조건 검증

**과제**: 무작위 \(L_x,L_h\)에 대해 \(N=L_x+L_h-2\)와 \(N=L_x+L_h-1\)에서 wrap-around 오차를 비교.

```octave
clear; close all; clc
rms_err = @(a,b) sqrt(mean(abs(a(:)-b(:)).^2));
for trial=1:6
  Lx=randi([50,200]); Lh=randi([30,120]);
  x=randn(1,Lx); h=randn(1,Lh); y_ref=conv(x,h); Ly=Lx+Lh-1;

  N1=Ly-1; N2=Ly;
  y1=ifft( fft([x zeros(1,N1-Lx)]) .* fft([h zeros(1,N1-Lh)]) ); y1=y1(1:Ly);
  y2=ifft( fft([x zeros(1,N2-Lx)]) .* fft([h zeros(1,N2-Lh)]) ); y2=y2(1:Ly);

  printf("Trial %d: N=Ly-1 err=%.2e | N=Ly err=%.2e\n", trial, rms_err(y1,y_ref), rms_err(y2,y_ref));
end
```

### 문제 2) OLA/OLS 동등성

**과제**: 동일 필터/신호에서 OLA, OLS, `conv` 결과를 모두 비교(오차·시간).
**힌트**: §4, §5 코드 재사용.

### 문제 3) 블록/FFT 길이 탐색

**과제**: 여러 \(L\), \(N\) 조합에서 실행시간과 지연(≈\(N/F_s\))을 테이블화.
**힌트**: §7.3.

### 문제 4) 파티셔닝 지연 vs 성능

**과제**: IR 길이를 바꾸며 `conv_partitioned`와 단일 OLA의 시간/최대지연/메모리 비교.

### 문제 5) 고정소수점 스케치

**과제**: 16-bit PCM 스케일(±32767)에 대해, 블록 부동 지수(shift)와 IFFT 후 포화 정책을 주석과 함께 설계.

---

## 결론

- 주파수 영역 곱은 **원형** 콘벌루션이지만, **제로패딩 조건**( \(N \ge L_x+L_h-1\) )을 만족하면 **선형** 결과를 정확히 얻을 수 있다.
- 실시간/대용량에서는 **OLA/OLS**가 표준이며, wrap-around를 제거하는 방식만 다를 뿐 **정확한 선형 합성**을 제공한다.
- 블록 길이/FFT 크기/지연/성능은 **트레이드오프**. 하드웨어를 기준으로 벤치마크해 최적점을 잡고, 긴 IR은 **파티셔닝/하이브리드**로 처리한다.
- 본문의 Octave 코드를 변형해 **정확성(=conv 일치)**, **지연**, **성능**을 직접 측정·검증하라.
