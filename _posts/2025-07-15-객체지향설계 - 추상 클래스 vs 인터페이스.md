---
layout: post
title: 객체지향설계 - 추상 클래스 vs 인터페이스
date: 2025-07-15 22:20:23 +0900
category: 객체지향설계
---
# 🧩 추상 클래스(Abstract Class) vs 인터페이스(Interface)

---

## 1. 개념 정의

| 구분 | 추상 클래스 | 인터페이스 |
|------|-------------|-------------|
| 정의 | **공통 동작을 정의하고 구현 일부도 포함하는 클래스** | **기능의 명세만 선언하는 일종의 계약(Contract)** |
| 목적 | **상속을 통한 코드 재사용 + 추상화** | **행동 규약 정의와 다형성 지원** |
| 상속 구조 | 단일 상속 | 다중 구현 가능 (Java 8 이후 default method 포함) |

---

## 2. 기본 문법 비교 (Java 기준)

### ✅ 추상 클래스

```java
abstract class Animal {
    String name;

    public Animal(String name) {
        this.name = name;
    }

    abstract void makeSound();

    void sleep() {
        System.out.println(name + " is sleeping");
    }
}
```

- `makeSound()`는 추상 메서드 → 반드시 구현해야 함
- `sleep()`은 일반 메서드 → 공통 구현 제공

### ✅ 인터페이스

```java
interface Flyable {
    void fly();
}

interface Swimable {
    void swim();
}
```

- 모든 메서드는 기본적으로 **추상(public abstract)** (Java 8 이전)
- Java 8부터 `default`, `static` 메서드 가능

---

## 3. 주요 차이점

| 항목 | 추상 클래스 | 인터페이스 |
|------|-------------|------------|
| 다중 상속 | ❌ 불가능 | ✅ 가능 |
| 상태(필드) | ✅ 인스턴스 변수 가질 수 있음 | ⚠️ 상수만 허용 (`public static final`) |
| 생성자 | ✅ 가짐 (하위 클래스 호출 시 사용됨) | ❌ 없음 |
| 접근 제어자 | public, protected, private 가능 | 대부분 public |
| 구현 가능 여부 | ✅ 구현 메서드 포함 가능 | 🔄 Java 8부터 `default` 메서드 가능 |
| 확장성 | 부모 클래스가 많을수록 제약 커짐 | 다양한 기능 조합에 유리 |

---

## 4. 공통점

- 모두 **다형성과 추상화**를 지원
- 모두 **객체의 공통 인터페이스 정의**에 사용
- 모두 **메서드 오버라이딩을 강제**할 수 있음
- 모두 **실체화(인스턴스화) 불가능**

---

## 5. 선택 기준

| 상황 | 추상 클래스 선택 | 인터페이스 선택 |
|------|------------------|------------------|
| 공통 로직 포함 여부 | ✅ 공통 필드/메서드 포함 시 유리 | ❌ 구현 불가능하거나 제한적 |
| 다중 상속 필요 | ❌ 단일 상속만 가능 | ✅ 여러 인터페이스 구현 가능 |
| 역할 중심 설계 | ❌ 실체 중심(‘is-a’) | ✅ 역할 중심(‘can-do’) |
| 진화 가능성 | ✅ 기존 메서드 수정 가능 | ⚠️ 기존 인터페이스 변경 시 영향 큼 |
| 자바 8 이상 | 일부 유사한 기능 가능 (`default`) | ✅ 더 유연해짐 |

---

## 6. 예시: 동물 + 기능 조합 모델링

```java
abstract class Animal {
    String name;

    public Animal(String name) {
        this.name = name;
    }

    abstract void makeSound();
}

interface Flyable {
    void fly();
}

interface Swimable {
    void swim();
}

class Duck extends Animal implements Flyable, Swimable {
    public Duck(String name) {
        super(name);
    }

    void makeSound() {
        System.out.println("Quack!");
    }

    public void fly() {
        System.out.println("Duck is flying!");
    }

    public void swim() {
        System.out.println("Duck is swimming!");
    }
}
```

- `Animal`은 **추상 클래스**로 공통 속성과 동작 정의
- `Flyable`, `Swimable`은 **인터페이스**로 추가 기능 명세
- `Duck`은 두 접근 모두 사용하여 유연한 모델링 가능

---

## 7. 요약 비교표

| 항목 | 추상 클래스 | 인터페이스 |
|------|-------------|-------------|
| 다중 상속 | ❌ | ✅ |
| 생성자 | ✅ | ❌ |
| 상태(멤버 변수) | ✅ | ⚠️ 상수만 가능 |
| 메서드 구현 | ✅ | ✅ (Java 8 이후 default) |
| 목적 | 공통 기능 재사용 | 기능 명세, 역할 정의 |
| 사용 예 | 동물, 차량 등 실체 모델 | 날 수 있음, 저장 가능 등 역할 모델 |

---

## 8. 현실 설계 조언

- **‘is-a’ 관계면 추상 클래스**, **‘can-do’ 관계면 인터페이스**
- **기능 조합**이 필요한 경우 인터페이스를 선호
- 자바 8 이상에서는 인터페이스 기능이 강화되어 일부 중복 가능
- 일반적으로 **인터페이스를 먼저 고려하고**, 공통 구현이 필요할 때 추상 클래스를 추가

---

## ✅ 결론

- **추상 클래스**는 공통 로직을 포함한 **기반 클래스**로서 강력하며,
- **인터페이스**는 객체 간의 **행동 계약**을 정의하여 **유연한 다형성**을 지원합니다.
- 실제 설계에서는 두 개념을 **혼합 사용**하여 유연하면서도 강력한 객체 구조를 만들 수 있습니다.