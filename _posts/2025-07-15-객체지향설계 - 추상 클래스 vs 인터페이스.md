---
layout: post
title: 객체지향설계 - 추상 클래스 vs 인터페이스
date: 2025-07-15 22:20:23 +0900
category: 객체지향설계
---
# 추상 클래스(Abstract Class) vs 인터페이스(Interface)

## 1. 개념 정의 (보강)

| 구분 | 추상 클래스 | 인터페이스 |
|---|---|---|
| 정의 | **공통 동작(일부 구현 포함)**을 제공하는 상위 클래스 | **행동의 계약(시그니처/의미)**을 선언하는 타입 |
| 목적 | **상속을 통한 재사용 + 템플릿 제공** | **역할 중심 다형성 + 느슨한 결합** |
| 상속 구조 | **단일 상속**(언어 제약) | **다중 구현** 가능 (Java 8+ `default`/`static`) |
| 상태(필드) | 인스턴스 상태 보유 가능 | (Java) 상수만; 구현체 내부 상태는 구현 클래스가 보유 |
| 생성자 | 가짐(하위에서 `super()` 호출) | 없음 |
| 용도 메타포 | “**종(種)**”의 공통 골격 | “**할 수 있음(can-do)**” 역할 태그/계약 |

> 요약: **실체·골격**이 필요하면 *추상 클래스*, **역할·계약**이 필요하면 *인터페이스*.

---

## 2. 기본 문법 비교 (Java 기준)

### 2.1 추상 클래스

```java
abstract class Animal {
    protected final String name;

    protected Animal(String name) { this.name = name; }

    abstract void makeSound();               // 반드시 구현(템플릿의 훅)

    void sleep() { System.out.println(name + " is sleeping"); } // 공통 구현
}
```

### 2.2 인터페이스

```java
interface Flyable {
    void fly();
    default int altitudeLimit() { return 120; } // Java 8+ default 메서드
    static Flyable noop() { return () -> {}; }  // Java 8+ static 메서드
}

interface Swimable {
    void swim();
}
```

---

## 3. 주요 차이점 (확장)

| 항목 | 추상 클래스 | 인터페이스 |
|---|---|---|
| 다중 상속 | ❌ (단일) | ✅ (여러 인터페이스 동시 구현) |
| 상태 필드 | ✅ 인스턴스 필드/보호 메서드 가능 | ⚠️ (Java) 상수만; 구현체가 자기 필드 가짐 |
| 생성자 | ✅ | ❌ |
| 접근 제어 | `public/protected/private` 모두 활용 | (Java) 메서드는 기본 `public`; `default/static/private` 메서드 허용(Java 9+) |
| 구현 포함 | ✅ 일반/추상 혼합 | ✅ `default`로 일부 구현 가능(그러나 상태는 X) |
| 공통 로직 공유 | **매우 적합** | 제한적(상태 없는 공통 로직) |
| API 진화 | 부모 변경 → 자식 영향 관리 용이 | `default` 없는 기존 메서드 변경은 파급 큼 → `default`/새 인터페이스로 진화 |

> 실무 팁: 공통 로직이 **상태를 동반**하면 추상 클래스로. **역할 혼합/조합**은 인터페이스로.

---

## 4. 공통점 (정리)

- **다형성**: 상위 타입(추상/인터페이스)으로 하위 구현을 다룬다.  
- **추상화**: “무엇을 할 수 있나”를 먼저 정의한다.  
- **인스턴스화 불가**: 직접 객체 생성 불가(추상/인터페이스).  
- **오버라이딩 강제**: 필수 메서드 구현을 강제할 수 있다.

---

## 5. 선택 기준 (보강)

| 상황 | 추상 클래스 선택 | 인터페이스 선택 |
|---|---|---|
| 공통 로직/상태 공유 | ✅ (공유 로직/필드/보호 훅) | ❌ (상태 없는 공통 로직만 가능) |
| 기능 다중 조합 | ❌ | ✅ (다중 구현) |
| ‘is-a’(종/골격) | ✅ | △ (역할로만 표현하면 가능) |
| ‘can-do’(역할) | △ | ✅ |
| 라이브러리 진화 | ✅ 상위 수정/보호 | ⚠️ 기존 메서드 변경 어려움 → `default`/새 인터페이스 |
| 테스트 용이성 | ✅ (스파이/부분 구현) | ✅ (목/스텁) |

**의사결정 트리**
1) **상태 동반 공통 로직** 공유가 핵심인가? → 추상 클래스  
2) **수평적 기능 조합**(로그/검증/추적)이 핵심인가? → 인터페이스  
3) 둘 다 필요한가? → 인터페이스(계약) + 추상 기본 클래스(공통 골격) **혼합**

---

## 6. 예시: 동물 + 기능 조합 (확장)

```java
abstract class Animal {
    protected final String name;
    protected Animal(String name){ this.name = name; }
    abstract void makeSound();
    void sleep(){ System.out.println(name + " zZ"); }
}

interface Flyable { void fly(); default String wingType(){ return "feather"; } }
interface Swimable { void swim(); }

class Duck extends Animal implements Flyable, Swimable {
    Duck(String name){ super(name); }
    @Override void makeSound(){ System.out.println("Quack!"); }
    @Override public void fly(){ System.out.println("Duck flying with " + wingType()); }
    @Override public void swim(){ System.out.println("Duck swimming"); }
}
```

- `Animal`: **골격/상태/공통 행위** 제공  
- `Flyable/Swimable`: **역할 조합**  
- `Duck`: 양쪽 장점을 결합

---

## 7. 충돌과 해소: default 메서드, 다중 구현

### 7.1 Java default 충돌

```java
interface A { default void f(){ System.out.println("A"); } }
interface B { default void f(){ System.out.println("B"); } }

class C implements A, B {
    @Override public void f(){ A.super.f(); } // 명시적 선택 or 커스텀 병합
}
```

### 7.2 C# 명시적 인터페이스 구현

```csharp
interface IFly { void Move(); }
interface ISwim{ void Move(); }

class Duck : IFly, ISwim {
    void IFly.Move()  => Console.WriteLine("Fly");
    void ISwim.Move() => Console.WriteLine("Swim");
    public void Move() => Console.WriteLine("Walk"); // 공용
}
```

### 7.3 Kotlin 다중 default 해소

```kotlin
interface A { fun f(){ println("A") } }
interface B { fun f(){ println("B") } }

class C : A, B {
    override fun f() {
        super<A>.f()       // 명시적 디스패치
        println("C")
    }
}
```

---

## 8. 언어별 비교 스냅샷

| 언어 | 추상 클래스 | 인터페이스/트레이트 | 특징 |
|---|---|---|---|
| **Java** | `abstract class` | `interface` + `default/static` | `default` 충돌은 구현에서 해소 |
| **C#** | `abstract class` | `interface`(+ default in C# 8) | **명시적 인터페이스 구현** 지원 |
| **Kotlin** | `abstract class`/`open` | `interface`(+ default) | `sealed` 클래스/인터페이스 |
| **Scala** | `abstract class` | `trait`(다중 믹스인) | 선형화 규칙으로 충돌 정리 |
| **Python** | `abc.ABC` | `abc.ABC`/프로토콜(PEP 544) | 덕 타이핑/정적 타입힌트와 혼용 |
| **TypeScript** | `abstract class` | `interface` | 컴파일 타임 전용 인터페이스 |
| **C++** | 추상 클래스(`=0`) | (언어적 인터페이스 없음) | 순수 가상 멤버로 인터페이스 표현 |

---

## 9. 패턴과의 연결

| 패턴 | 추상 클래스 활용 | 인터페이스 활용 |
|---|---|---|
| **Template Method** | 상위에 골격/훅 제공 | (대안) 전략/구성으로 치환 |
| **Strategy** | (드묾) | **역할**로 알고리즘 교체 |
| **Bridge** | 추상(Abstraction) 계층에 추상 클래스 | 구현(Implementor) 역할은 인터페이스 |
| **Adapter** | (드묾) | 대상 역할 인터페이스로 어댑팅 |
| **State** | 상태 베이스 추상 클래스 가능 | 상태 역할 인터페이스로 분리 |

---

## 10. 테스트/계약/LSP (리스코프 치환)

### 10.1 계약(전제/사후/불변식)으로 의미 고정

```java
interface Payment {
    // Pre: amount > 0
    // Post: returns txId, idempotent for same key
    String pay(int amount, String idempotencyKey);
}
```

### 10.2 계약 테스트(공유 테스트)

```java
abstract class PaymentContract {
    protected abstract Payment sut();

    @org.junit.jupiter.api.Test
    void payPositive() {
        var tx = sut().pay(1000, "k1");
        org.junit.jupiter.api.Assertions.assertNotNull(tx);
    }
}
```

- 구현이 추상 클래스든 인터페이스든, **상위 계약을 테스트로 고정**하면 LSP를 보장한다.

---

## 11. 성능·가상 디스패치(직관)

- **인터페이스 vs 클래스 가상 호출**: JVM은 `invokeinterface`/`invokevirtual`을 최적화(디가상화/인라이닝).  
- **`final`/`sealed`/단일 구현**이면 인라이닝 쉬워짐.  
- **핫패스**라면 측정 후: `final`/`sealed`/AOT/R2R, C++은 **정적 다형성(CRTP/템플릿)** 고려.

간단 모델:
$$
\text{CallCost} \approx \text{Base} + \alpha \cdot \text{Dispatch} - \beta \cdot \text{Devirtualization}
$$

---

## 12. 진화 전략(버전 호환)

- **인터페이스**: 기존 메서드 시그니처 변경은 파급 큼 →  
  1) **`default` 메서드**로 신규 동작 제공(주의: 모든 구현에 의미가 맞는지 검토)  
  2) **새 인터페이스** 추가하여 점진 이행  
- **추상 클래스**: 보호 훅 추가/공통 메서드 확장 쉬움. 단, **상속 계층 파급**에 주의.

---

## 13. 안티패턴과 리팩토링

| 냄새 | 원인 | 처방 |
|---|---|---|
| 거대 추상 클래스(God Abstract) | 공통 아닌 것까지 몰아넣음 | 인터페이스로 역할 분리(ISP), 합성으로 이관 |
| 인터페이스에 ‘데이터 게터’ 범람 | 절차적 조합, 의미 불명 | **의미 있는 명령** 노출(`reserve()`, `approve()`) |
| 인터페이스 변경 잦음 | 계약 불안정 | 코어/서포팅 분리, `default` 또는 새 인터페이스 |
| 다중 default 충돌 남발 | 역할 중복 | 구현에서 명시해소/설계 재검토 |
| 상속 남용 | 수평 기능도 상속 | **구성(Composition over Inheritance)** 로 이동 |

리팩토링 레시피:
1) 공통 로직이 상태 동반? → 추상 클래스 **도입**  
2) 수평 기능 섞임? → 인터페이스 **추출**, 구현은 **전략/어댑터**로  
3) 인터페이스 불안정? → 코어 최소화, 변동은 **서브 인터페이스**로 격리

---

## 14. 사례: 저장소 설계(혼합 전략)

```java
// 역할: 계약
public interface UserRepository {
    // Pre: id != null
    Optional<User> findById(String id);
    void save(User user);
}

// 공통 골격: 연결/재시도/메트릭
public abstract class AbstractJdbcUserRepo implements UserRepository {
    protected final DataSource ds;
    protected AbstractJdbcUserRepo(DataSource ds){ this.ds = ds; }

    protected <T> T withConn(SQLFunction<Connection,T> f){ /* 공통 재시도/트랜잭션 */ return null; }
}

// 구현: DB 방언별 확장
public final class PostgresUserRepo extends AbstractJdbcUserRepo {
    public PostgresUserRepo(DataSource ds){ super(ds); }
    public Optional<User> findById(String id){
        return withConn(c -> /* PG SQL */ null);
    }
    public void save(User u){
        withConn(c -> { /* upsert */ return null; });
    }
}
```

- **인터페이스**로 상위 계약을 고정, **추상 클래스**로 DB 공통 골격 재사용.

---

## 15. 추가 비교: Python/TypeScript/C++

### 15.1 Python `abc`
```python
from abc import ABC, abstractmethod

class Payment(ABC):
    @abstractmethod
    def pay(self, amount: int, key: str) -> str: ...
```
- **프로토콜(PEP 544)** 로 덕 타이핑 기반 계약도 가능.

### 15.2 TypeScript
```ts
interface Serializer<T> { serialize(v: T): string; }
abstract class BaseRepo<T> {
  constructor(protected readonly s: Serializer<T>) {}
  abstract save(v: T): void;
}
```
- 인터페이스는 **컴파일 타임 전용**, 런타임에는 소거.

### 15.3 C++ 순수 가상
```cpp
struct Payment {
    virtual std::string pay(int amount, const std::string& key) = 0;
    virtual ~Payment() = default;
};
```

---

## 16. 체크리스트

- [ ] **역할(인터페이스)** 과 **골격(추상 클래스)** 을 구분했는가?  
- [ ] 공통 로직이 **상태**를 동반하는가? → 추상 클래스  
- [ ] 수평 기능 조합이 필요한가? → 인터페이스 다중 구현  
- [ ] 계약(Pre/Post/Inv)이 문서/테스트로 고정되어 있는가?  
- [ ] 인터페이스 진화가 필요하면 `default`/새 인터페이스로 했는가?  
- [ ] 다중 `default` 충돌은 구현에서 명시 해소했는가?  
- [ ] 핫패스는 측정 후 최적화(디가상화/인라이닝)했는가?

---

## 17. 요약 비교표(최종)

| 항목 | 추상 클래스 | 인터페이스 |
|---|---|---|
| 핵심 개념 | **골격/공통 구현** 제공 | **역할/계약** 제공 |
| 상속/구현 | 단일 상속 | 다중 구현 |
| 상태/필드 | 가능 | (Java) 상수만 |
| 생성자 | 있음 | 없음 |
| 공통 로직 공유 | 매우 적합 | 상태 없는 로직만 |
| 진화 | 상위 변경 유연 | `default`/새 인터페이스로 우회 |
| 대표 패턴 | Template Method | Strategy/Adapter/Bridge |
| 사용 권장 | 실체·종(“is-a”) | 역할·조합(“can-do”) |
| 함께 쓰기 | **인터페이스 + 추상 기본 클래스** 혼합으로 최적화 |

---

## 18. 결론

- **인터페이스**는 시스템의 **경계와 역할**을 고정해 **느슨한 결합**과 **다형성**을 극대화한다.  
- **추상 클래스**는 **상태를 동반한 공통 골격**을 제공해 **재사용**과 **일관성**을 보장한다.  
- 실제 설계에서는 **인터페이스(계약) → 추상 기본 클래스(공통 구현) → 구체 클래스(세부)**의 3단 구성을 즐겨 쓰되, **합성(Strategy/Adapter/Bridge)** 으로 수평 기능을 조합하라.

> 실무 한 줄: **“계약은 인터페이스로, 골격은 추상 클래스로, 조합은 합성으로.”**