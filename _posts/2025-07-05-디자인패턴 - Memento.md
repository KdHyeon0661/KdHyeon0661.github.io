---
layout: post
title: 디자인패턴 - Template Method
date: 2025-07-05 18:20:23 +0900
category: 디자인패턴
---
# Memento (메멘토 패턴)

## 1. 개요와 의도

- **의도(Intent)**: 캡슐화를 위배하지 않고 객체의 **과거 상태 스냅샷**을 만들고, 이후 **복원**할 수 있게 한다.
- **핵심 원칙**
  - **Originator**: 상태의 주체. 스냅샷 생성/복원을 담당.
  - **Memento**: 상태 스냅샷. **불변(immutable)** 이고 **불투명(opaque)** 해야 한다(외부가 내용을 들여다보지 못함).
  - **Caretaker**: 스냅샷을 저장/관리(스택, 디스크, 네트워크 등). **내용을 해석하지 않는다**.

> 설계 규율: “Memento는 보관만, 의미는 Originator만.”

---

## 2. 구조(UML)와 역할

```
┌───────────────┐          creates/restores       ┌───────────────┐
│  Originator   │ ─────────────────────────────►  │    Memento    │
│  set/get/...  │ ◄─────────────────────────────  │  (opaque,     │
│  save/restore │                                 │   immutable)  │
└───────┬───────┘                                  └───────┬───────┘
        │                                                  │
        │ stores                                          │
        ▼                                                  ▼
┌────────────────┐                                 ┌───────────────┐
│   Caretaker    │  push/pop, capacity policy      │ Persistence    │
│  (History)     │ ───────────────────────────────►│ (disk/json)   │
└────────────────┘                                 └───────────────┘
```

- **캡슐화 보존**: Caretaker는 `Memento`의 내부를 보지 않는다(직렬화/암호화 시에도 의미를 모르는 페이로드).
- **불변성**: `Memento`는 생성 이후 변하지 않아야 레이스/부작용을 막을 수 있다.

---

## 3. 최소·정석 예제 (Python) — 불변 Memento + 바운디드 Undo/Redo

요구:
- 텍스트, 커서 위치, 선택 범위를 가진 에디터
- **Undo/Redo**, **최대 N개** 스냅샷 유지, **새 행동 발생 시 Redo 폐기**
- **캡슐화**: 외부는 스냅샷 내부를 들여다볼 수 없음

```python
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, List
from copy import deepcopy
import threading
import json

# -------------------------------
# Opaque, Immutable Memento
# -------------------------------
@dataclass(frozen=True)
class _EditorMemento:
    # 불변 스냅샷(외부에 공개하지 않을 내부 타입)
    _text: str
    _cursor: int
    _sel_from: Optional[int]
    _sel_to: Optional[int]

# -------------------------------
# Originator
# -------------------------------
class Editor:
    def __init__(self) -> None:
        self._text = ""
        self._cursor = 0
        self._sel_from: Optional[int] = None
        self._sel_to: Optional[int] = None

    # Domain ops
    def insert(self, s: str) -> None:
        left = self._text[:self._cursor]
        right = self._text[self._cursor:]
        self._text = left + s + right
        self._cursor += len(s)
        self._clear_selection()

    def delete(self, n: int) -> None:
        # 간단화를 위해 커서 뒤 n 문자 삭제
        self._text = self._text[:self._cursor] + self._text[self._cursor + n:]
        self._clear_selection()

    def move(self, pos: int) -> None:
        self._cursor = max(0, min(pos, len(self._text)))

    def select(self, a: int, b: int) -> None:
        a, b = sorted((max(0, a), max(0, b)))
        b = min(b, len(self._text))
        self._sel_from, self._sel_to = a, b

    def get_text(self) -> str:
        return self._text

    def status(self) -> str:
        return f"text='{self._text}', cursor={self._cursor}, sel=({self._sel_from},{self._sel_to})"

    # Memento API (only originator knows its fields)
    def save(self) -> _EditorMemento:
        return _EditorMemento(
            _text=deepcopy(self._text),
            _cursor=self._cursor,
            _sel_from=self._sel_from,
            _sel_to=self._sel_to,
        )

    def restore(self, m: _EditorMemento) -> None:
        self._text = m._text
        self._cursor = m._cursor
        self._sel_from = m._sel_from
        self._sel_to = m._sel_to

    def _clear_selection(self) -> None:
        self._sel_from = self._sel_to = None

# -------------------------------
# Caretaker: Bounded Undo/Redo
# -------------------------------
class History:
    def __init__(self, capacity: int = 50) -> None:
        self._undo: List[_EditorMemento] = []
        self._redo: List[_EditorMemento] = []
        self._cap = max(1, capacity)
        self._lock = threading.Lock()

    def snapshot(self, m: _EditorMemento) -> None:
        with self._lock:
            self._undo.append(m)
            self._redo.clear()
            if len(self._undo) > self._cap:
                self._undo.pop(0)

    def can_undo(self) -> bool:
        return len(self._undo) > 0

    def can_redo(self) -> bool:
        return len(self._redo) > 0

    def undo(self, originator: Editor) -> None:
        with self._lock:
            if not self._undo:
                return
            current = originator.save()
            last = self._undo.pop()
            self._redo.append(current)
            originator.restore(last)

    def redo(self, originator: Editor) -> None:
        with self._lock:
            if not self._redo:
                return
            current = originator.save()
            next_m = self._redo.pop()
            self._undo.append(current)
            originator.restore(next_m)

    # (선택) 직렬화: memento 자체는 불변 데이터 덩어리이므로 안전하게 dump 가능
    def dump_json(self) -> str:
        with self._lock:
            def to_dict(m: _EditorMemento):
                return {"text": m._text, "cursor": m._cursor, "sel_from": m._sel_from, "sel_to": m._sel_to}
            return json.dumps({
                "undo": [to_dict(m) for m in self._undo],
                "redo": [to_dict(m) for m in self._redo],
                "cap": self._cap
            })

# -------------------------------
# 사용 시나리오
# -------------------------------
if __name__ == "__main__":
    ed = Editor()
    hist = History(capacity=3)

    hist.snapshot(ed.save())     # 초기 상태 스냅샷

    ed.insert("Hello")
    hist.snapshot(ed.save())
    ed.insert(", world")
    hist.snapshot(ed.save())
    ed.move(5); ed.insert(" ")
    hist.snapshot(ed.save())

    print("[now]  ", ed.status())

    hist.undo(ed)
    print("[undo] ", ed.status())

    hist.undo(ed)
    print("[undo] ", ed.status())

    ed.insert("!!!")   # 새로운 행동 → redo 폐기
    hist.snapshot(ed.save())
    print("[act ] ", ed.status())

    hist.redo(ed)      # redo 불가(폐기됨)
    print("[redo] ", ed.status())
```

**실행 결과(예)**

```
[now]   text='Hello, world', cursor=6, sel=(None,None)
[undo]  text='Hello, world', cursor=5, sel=(None,None)
[undo]  text='Hello', cursor=5, sel=(None,None)
[act ]  text='Hello!!!', cursor=8, sel=(None,None)
[redo]  text='Hello!!!', cursor=8, sel=(None,None)
```

### 설계 포인트
- **불변 Memento**: `dataclass(frozen=True)`로 생성 후 수정 금지.
- **바운딩**: `capacity` 초과 시 가장 오래된 스냅샷 제거.
- **Redo 폐기 규칙**: 새 행동(`snapshot`)이 생성되면 `redo`는 비운다.
- **캡슐화**: `_EditorMemento`는 외부에 공개하지 않는 내부 타입(모듈 범위). Caretaker는 **to_dict** 정도만 책임.

---

## 4. 직렬화·저장소(디스크/네트워크) — 스냅샷 영속화

여러 문서/세션 간 **히스토리 공유**나 **프로세스 재시작 후 복원**을 원한다면 Memento를 **직렬화**해야 한다.

```python
import json
from dataclasses import asdict

# Originator 쪽에 직렬화/역직렬화 도우미를 둔다(의미를 아는 주체가 변환을 책임)
def memento_to_json(m: _EditorMemento) -> str:
    payload = {"text": m._text, "cursor": m._cursor, "sel_from": m._sel_from, "sel_to": m._sel_to}
    return json.dumps(payload, ensure_ascii=False)

def memento_from_json(js: str) -> _EditorMemento:
    d = json.loads(js)
    return _EditorMemento(d["text"], d["cursor"], d["sel_from"], d["sel_to"])
```

- **암호화/압축**: Caretaker는 “바이트 덩어리”로 다룰 수 있다.
- **버전 관리**: 필드 추가/변경을 대비해 **버전 필드**를 두는 것이 안전.

---

## 5. 대용량 상태를 위한 전략 — 스냅샷 vs 차등(Diff) 혼합

상태가 매우 크면 모든 단계에서 전체 스냅샷을 저장하기 어렵다. 선택지:

1) **간격 스냅샷(Checkpointing)** + 그 사이 **Diff** 저장
   - 예: 매 `K`단계마다 전체 스냅샷, 나머지는 역연산(패치)로 Undo
   - 복원 비용: 최악시 **$$O(K)$$** 패치 적용

2) **Copy-on-Write** 구조(공유 그래프)
   - 불변 자료구조(Persistent Vector/Map)를 쓰면 스냅샷 비용이 **공유 포인터 몇 개**로 제한

3) **압축**
   - JSON 대신 이진 포맷(MessagePack/CBOR), 델타 압축

> 저장 비용(스냅샷)과 복원 비용(패치 재생) 사이에는 일반적으로 **시간-공간 트레이드오프**가 있다.
> $$ \text{Total Cost} \approx \alpha \cdot \text{SnapshotSize} + \beta \cdot \text{ReplayLength} $$

### 아주 가벼운 Diff 예시(문서에 대한 append/remove 기반)
```python
from dataclasses import dataclass

@dataclass(frozen=True)
class _DiffMemento:
    # originator 의미를 아는 '미니 역연산'만 저장
    _op: str     # 'append' or 'remove'
    _payload: str

class Doc:
    def __init__(self):
        self._s = ""

    def append(self, t: str):
        self._s += t

    def remove(self, n: int):
        self._s = self._s[:-n] if n <= len(self._s) else ""

    def state(self) -> str:
        return self._s

    def save_diff_for_undo(self, op: str, payload: str) -> _DiffMemento:
        # 나중에 'undo' 할 수 있는 역연산 저장
        if op == "append":
            return _DiffMemento("remove", str(len(payload)))
        elif op == "remove":
            return _DiffMemento("append", payload)
        raise ValueError("unknown op")

    def apply_undo(self, m: _DiffMemento):
        if m._op == "remove":
            self.remove(int(m._payload))
        elif m._op == "append":
            self.append(m._payload)
```

- 이 방식은 **Command 패턴의 ‘역연산’**과 유사하다.
- 임의 수정에 강하지 않으니, 보통 **간헐적 스냅샷**과 **Diff**를 섞는다.

---

## 6. 스레드 안전과 동시성

- **불변 Memento** + **Caretaker 내부 락** → 기본 안전성 확보
- Originator가 멀티스레드에서 수정된다면 **수정/스냅샷 구간을 잠금**해야 한다.
- 별도 큐(비동기 저장)로 스냅샷을 **오프로딩**하면 응답성 향상.

---

## 7. Command 패턴과의 결합 — 실무에서 자주 쓰는 조합

- **Command**는 실행/취소/재실행을 돕는다.
- **Memento**는 “상태 덤프”를 보관한다.

하이브리드:
- **단일 객체 상태**는 Memento로 스냅샷(간단·안전).
- **복수 객체/외부 자원 연쇄 작업**은 Command로 역연산을 정의.
- 복잡한 도큐먼트 편집기는 실제로 **둘 다** 사용한다.

---

## 8. C# 간단 구현 (record로 불변성 강화)

```csharp
// Memento
public readonly record struct EditorMemento(string Text, int Cursor, int? SelFrom, int? SelTo);

// Originator
public class Editor {
    private string _text = "";
    private int _cursor = 0;
    private int? _selFrom, _selTo;

    public void Insert(string s) {
        _text = _text.Insert(_cursor, s);
        _cursor += s.Length;
        _selFrom = _selTo = null;
    }
    public void Move(int pos) {
        _cursor = Math.Clamp(pos, 0, _text.Length);
    }
    public string Status() => $"text='{_text}', cursor={_cursor}, sel=({_selFrom},{_selTo})";

    public EditorMemento Save() => new EditorMemento(_text, _cursor, _selFrom, _selTo);
    public void Restore(in EditorMemento m) {
        _text = m.Text; _cursor = m.Cursor; _selFrom = m.SelFrom; _selTo = m.SelTo;
    }
}

// Caretaker
public class History {
    private readonly int _cap;
    private readonly Stack<EditorMemento> _undo = new();
    private readonly Stack<EditorMemento> _redo = new();

    public History(int capacity = 50) => _cap = Math.Max(1, capacity);

    public void Snapshot(EditorMemento m) {
        _undo.Push(m);
        _redo.Clear();
        while (_undo.Count > _cap) _undo.TryPop(out _);
    }

    public void Undo(Editor originator) {
        if (_undo.Count == 0) return;
        var current = originator.Save();
        var last = _undo.Pop();
        _redo.Push(current);
        originator.Restore(last);
    }

    public void Redo(Editor originator) {
        if (_redo.Count == 0) return;
        var current = originator.Save();
        var next = _redo.Pop();
        _undo.Push(current);
        originator.Restore(next);
    }
}
```

---

## 9. 메모리/성능 정책

- **용량 제한**: `capacity`로 히스토리 메모리 상한.
  저장 비용은 스냅샷 크기를 `S`, 최대 개수를 `N`이라 하면 **$$O(N\cdot S)$$**.
- **스냅샷 빈도**: 모든 키 입력마다 저장하지 말고, **사용자 의미 단위(문장/명령 단위)**로 합친다.
- **GC 압력**: 큰 스냅샷은 Pool/버퍼 재사용 또는 영속 자료구조로 **할당량 감소**.
- **직렬화 비용**: JSON은 디버깅 친화적, 이진 포맷은 공간/속도 우수.

---

## 10. 검증 시나리오(테스트 체크리스트)

- [ ] 새 행동 후 Redo가 폐기되는가?
- [ ] capacity 경계를 넘을 때 가장 오래된 Undo가 제거되는가?
- [ ] 연속 Undo/Redo가 교차 적용되어도 상태가 정확하게 왕복되는가?
- [ ] 직렬화/역직렬화 후에도 동일 상태인가(라운드트립)?
- [ ] 다중 스레드에서 Race 없이 동작하는가(락/불변성 확인)?
- [ ] 큰 상태에서 시간/메모리 상한 내에 동작하는가?

---

## 11. 실무 예: 문서 편집기 명령 묶음(트랜잭션형 Undo)

여러 조작을 **하나의 Undo 단위로 묶기** 위한 “배치 스냅샷”:

```python
class TransactionalHistory(History):
    def __init__(self, capacity: int = 50) -> None:
        super().__init__(capacity)
        self._batch_open = False
        self._batch_base: Optional[_EditorMemento] = None

    def begin_batch(self, originator: Editor) -> None:
        if not self._batch_open:
            self._batch_open = True
            self._batch_base = originator.save()

    def end_batch(self, originator: Editor) -> None:
        if self._batch_open:
            self._batch_open = False
            # 시작 시점 스냅샷을 push(Undo 시 그리로 돌아감)
            super().snapshot(self._batch_base)  # type: ignore
            self._batch_base = None

    # snapshot 오버라이드: 배치중이면 무시하여 묶음 유지
    def snapshot(self, m: _EditorMemento) -> None:
        if self._batch_open:
            return
        super().snapshot(m)
```

- 드래그→여러 입력→서식 변경 같은 **복합 조작**을 하나로 Undo.

---

## 12. Memento vs Command vs Prototype vs Event Sourcing

| 패턴/기술        | 목적                         | 장점                                    | 단점/주의점                                  |
|------------------|------------------------------|-----------------------------------------|----------------------------------------------|
| **Memento**      | 상태 스냅샷/복원             | 캡슐화 보존, 단순, 신뢰성 높음          | 스냅샷 크기 부담, 빈번 저장 시 메모리↑       |
| **Command**      | 실행/취소/재실행(역연산)     | 세밀 제어, 외부자원까지 단위화 가능     | 역연산 정의 부담, 누락 위험                  |
| **Prototype**    | 객체 복제                     | 간단한 복원(복제 후 교체)               | 깊은 복제 비용, 외부자원/핸들 복제 어려움    |
| **Event Sourcing** | 이벤트 로그 재생으로 복원   | 트레이서빌리티, 감사를 위한 완전 이력    | 재생 비용, 스냅샷 병행 필요(체크포인트)      |

- 실무에서는 **Memento + Command + Checkpoint** 혼합이 흔하다.

---

## 13. 안티패턴·주의사항

- **Caretaker가 Memento 내부를 파헤치는 행위**: 캡슐화 파괴.
- **가변 Memento**: Undo 순서 바뀌거나 경쟁 상태로 버그 유발.
- **외부자원 핸들**(파일 핸들, 소켓 등)을 Memento에 담기: 복원 불가/위험. 대신 **재오픈 메타데이터**만 담는다.
- **스냅샷 남용**: 입력 한 글자마다 저장 → 메모리 폭주. **배치/스로틀링** 필요.

---

## 14. 수학적 측면(간단 모델링)

- 최대 스냅샷 개수: $$N$$, 각 스냅샷 평균 크기: $$S$$ 바이트, 평균 생성 빈도: 초당 $$\lambda$$
- 메모리 상한: $$M \le N \cdot S$$
- 평균 저장 대역폭: $$B \approx \lambda \cdot S$$
- 체크포인트 간 거리 $$K$$, 재생 길이 기대값 $$E[L]\approx K/2$$ (균등 분포 가정)
  → 복원 시간은 **스냅샷+패치 적용**으로 근사: $$T \approx T_{\text{snap}} + E[L]\cdot T_{\text{patch}}$$

---

## 15. “API 체크리스트” — 도입 전 질문

- [ ] Originator의 **핵심 상태 경계**는 어디까지인가? (캐시/파생값 제외)
- [ ] 스냅샷 **용량 전략(capacity/압축/간격)**은?
- [ ] Undo 단위는 **사용자 의미 단위**인가? (배치/그룹 필요)
- [ ] 직렬화/버전업/암호화 요구가 있는가?
- [ ] 다중 문서/멀티스레드/멀티탭에서 안전한가?

---

## 16. 요약

- **메멘토 패턴**은 상태 복원 문제에 대한 **가장 단순하고 안전한 기본 해법**이다.
- 실무에서는 다음을 권한다:
  1) **불변·불투명 Memento**,
  2) **바운디드 Undo/Redo**,
  3) **배치 스냅샷**,
  4) 필요 시 **직렬화/암호화/체크포인트+Diff** 혼합.

적절한 전략을 선택하면, 대규모 애플리케이션에서도 **예측 가능한 메모리/성능**으로 **안정적인 Undo/Redo**를 구현할 수 있다.
