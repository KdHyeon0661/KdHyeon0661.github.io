---
layout: post
title: 디자인패턴 - Template Method
date: 2025-07-05 18:20:23 +0900
category: 디자인패턴
---
# Memento (메멘토 패턴)

## ✅ 정의

**Memento 패턴(메멘토 패턴)**은 객체의 상태를 이전 시점으로 되돌릴 수 있도록,  
**객체 상태를 저장하고 복원할 수 있는 기능**을 제공하는 **행위 패턴(Behavioral Pattern)**입니다.

> “캡슐화를 유지하면서 객체의 이전 상태를 저장하고 복원하는 방법”

---

## 🎯 의도 (Intent)

- 객체의 상태를 저장해두고, **필요 시 복원(Undo)**할 수 있도록 한다.
- **내부 구현을 노출하지 않고**, 상태 저장과 복구 기능을 분리한다.

---

## 📦 구조 (UML)

```
┌────────────┐
│  Originator│◄────────────────────┐
├────────────┤                     │
│set_state() │                     │
│get_state() │                     │
│restore(mem)│────┐                │
└─────┬──────┘    │                │
      ▼           │                │
┌────────────┐    │        ┌────────────┐
│  Memento   │◄───┘        │ Caretaker  │
├────────────┤             ├────────────┤
│  state     │             │ save(memento)│
└────────────┘             │ restore()    │
                           └────────────┘
```

- **Originator**: 상태를 가지며, 이를 저장하거나 복원할 수 있는 객체
- **Memento**: 객체의 상태를 저장하는 캡슐 (보통 내부 상태만 저장)
- **Caretaker**: 상태를 저장하고 되돌리는 책임을 가짐 (Undo Manager 역할)

---

## 🧑‍💻 구현 예시 (Python)

```python
# Memento (상태 저장)
class Memento:
    def __init__(self, state):
        self._state = state

    def get_saved_state(self):
        return self._state

# Originator (상태의 주체)
class TextEditor:
    def __init__(self):
        self._text = ""

    def write(self, text):
        self._text += text

    def get_text(self):
        return self._text

    def save(self):
        return Memento(self._text)

    def restore(self, memento):
        self._text = memento.get_saved_state()

# Caretaker (관리자)
class History:
    def __init__(self):
        self._history = []

    def push(self, memento):
        self._history.append(memento)

    def pop(self):
        return self._history.pop() if self._history else None

# 사용 예시
editor = TextEditor()
history = History()

editor.write("안녕하세요. ")
history.push(editor.save())

editor.write("디자인 패턴 공부 중입니다.")
history.push(editor.save())

editor.write(" 메멘토 패턴입니다.")
print("📝 현재 상태:", editor.get_text())

# 복원
editor.restore(history.pop())
print("⏪ 복원 1:", editor.get_text())

editor.restore(history.pop())
print("⏪ 복원 2:", editor.get_text())
```

**출력 예시:**
```
📝 현재 상태: 안녕하세요. 디자인 패턴 공부 중입니다. 메멘토 패턴입니다.
⏪ 복원 1: 안녕하세요. 디자인 패턴 공부 중입니다.
⏪ 복원 2: 안녕하세요. 
```

---

## ✅ 장점

- 상태 저장 기능을 외부에서 **캡슐화된 방식으로 분리** 가능
- **Undo/Redo 기능 구현**에 최적
- 복원 시점마다 객체의 상태를 손쉽게 저장하고 되돌릴 수 있음
- Originator와 Caretaker의 **역할이 분리**되어 SRP 만족

---

## ⚠️ 단점

- 상태가 클 경우 → **메모리 사용 증가**
- 모든 상태를 저장할 경우 → 성능 저하 위험
- 복원 시점에 따라 **동기화 이슈** 발생 가능
- 불변성이 없다면 상태 누락 가능

---

## 📌 사용 사례

| 분야 | 예시 |
|------|------|
| 텍스트 편집기 | Undo/Redo 기능 |
| 게임 저장 | 캐릭터 상태 저장/복원 |
| 그래픽 툴 | 드로잉 작업의 히스토리 관리 |
| 워크플로우 엔진 | 실행 중단/재시작 시 상태 유지 |
| 트랜잭션 처리 | 특정 시점으로 되돌리기 |

---

## 🧠 Memento vs Command vs Prototype

| 패턴 | 목적 | 유사점 | 차이점 |
|------|------|--------|--------|
| Memento | 상태 복원 | 상태 저장 | 내부 구현 숨김, 불변 객체 사용 |
| Command | 요청 캡슐화 | 상태 복원 가능 | 복원 기능 외 실행/취소 포함 |
| Prototype | 객체 복제 | 상태 복제 | 완전한 복제, 복원은 목적 아님 |

---

## ✅ 실무 팁

- 객체 상태가 불변(immutable)하거나, `deepcopy` 가능한 경우 Memento 구현이 간단해짐
- 상태를 직렬화(JSON, pickle 등)하여 Memento로 사용할 수 있음
- 복잡한 객체일수록 Memento는 **상태의 핵심 정보만** 저장하는 것이 좋음
- Memento를 저장하는 Caretaker에 **최대 용량 제한**을 두는 것이 좋음 (Undo 스택 제한)

---

## 🧠 마무리

**Memento 패턴은 객체의 상태를 외부에 노출하지 않고도 저장 및 복원할 수 있게 해주는 강력한 도구**입니다.  
Undo/Redo, 게임 세이브, 편집 히스토리 등 다양한 분야에서 널리 쓰이며,  
**시간 흐름에 따른 상태 추적이 필요한 모든 상황에서 유용하게 활용**될 수 있습니다.
