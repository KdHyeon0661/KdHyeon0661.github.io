---
layout: post
title: Docker - 보안 강화
date: 2025-03-27 22:20:23 +0900
category: Docker
---
# Docker 보안 강화 방법

## 위협 모델 정의: 무엇으로부터 보호할 것인가?

효율적인 컨테이너 보안 전략을 수립하려면 먼저 방어해야 할 대상과 위협을 명확히 이해해야 합니다. 컨테이너 환경에서 주요 위협과 그에 대한 핵심 대응 방안은 다음과 같습니다.

| 위협 | 구체적인 예시 | 핵심 대응 전략 |
|---|---|---|
| 이미지 출처 불명 또는 취약점 | 임의의 공개 이미지 사용, 오래된 베이스 이미지, 악성 엔트리포인트 스크립트 | **이미지 서명, 취약점 스캔, 신뢰할 수 있는 레지스트리 사용, 최소화된 베이스 이미지** |
| 런타임 컨테이너 탈출 및 권한 상승 | `--privileged` 옵션 남용, 과도한 Linux Capabilities, 호스트 파일 시스템 마운트, 취약한 시스템 콜 사용 | **비루트 사용자 실행, 불필요한 Capabilities 제거, seccomp/AppArmor/SELinux 적용, 읽기 전용 파일 시스템** |
| 비밀 정보 유출 | 환경변수 노출, 애플리케이션 로그 기록, 도커 이미지 레이어나 히스토리 남김 | **Docker Secrets/외부 비밀 관리 도구 활용, BuildKit 시크릿 마운트, 로그 마스킹** |
| 자원 고갈 공격 (DoS) | 무제한 CPU/메모리 사용, 프로세스 수 과다 생성, 디스크 공간 고갈 | **cgroups를 통한 자원 제한, ulimits 설정, pidsLimit, OOM Killer 정책 구성** |
| Docker 데몬 노출 | TCP 2375 포트 공개, 과도한 `docker` 그룹 사용자 | **mTLS 활성화, Rootless Docker 도입, 소켓 접근 권한 최소화** |
| 네트워크 내 측면 이동 | 컨테이너 간 평면 네트워크를 이용한 공격 확대 | **네트워크 정책/분리, 불필요한 마운트 제거, NET_RAW Capability 차단** |

---

## 기본 원칙: 루트 권한 제거

컨테이너 내부에서 루트(root) 권한으로 애플리케이션을 실행하는 것은 가장 흔한 보안 위험 요소입니다. 컨테이너가 침해당할 경우 호스트 시스템으로의 권한 상승이 쉬워집니다.

### 안전한 Dockerfile 작성 패턴

```Dockerfile
FROM node:18-alpine

# 1. 패키지 설치를 하나의 RUN 명령으로 합치고, 불필요한 빌드 도구는 제거합니다.
RUN apk add --no-cache tini && \
    addgroup -S app && adduser -S -G app app

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .

# 2. 애플리케이션 파일의 소유권을 비루트 사용자로 변경합니다.
RUN chown -R app:app /app

# 3. 컨테이너 실행 시 비루트 사용자로 전환합니다.
USER app

# 4. 신호 처리를 위한 초기화 프로세스(tini)를 사용하여 좀비 프로세스를 방지합니다.
ENTRYPOINT ["/sbin/tini","--"]
CMD ["node","server.js"]
```

### 컨테이너 실행 시 사용자 강제 지정

```bash
docker run --user 10001:10001 myapp:latest
```

실행 중인 컨테이너의 사용자를 확인하려면:
```bash
docker exec -it <container_id> id
```

---

## 읽기 전용 파일 시스템 및 쓰기 경로 최소화

컨테이너의 파일 시스템을 읽기 전용으로 설정하면, 애플리케이션의 의도하지 않은 파일 수정이나 웹셸 업로드, 자가 변형(malware) 등을 방지할 수 있습니다.

### 기본 실행 옵션

```bash
docker run --read-only \
  --tmpfs /tmp \
  -v appdata:/var/lib/myapp \
  myapp:latest
```

### Docker Compose 구성 예시

```yaml
services:
  api:
    image: myorg/api:1.0.0
    read_only: true
    tmpfs:
      - /tmp
    volumes:
      - appdata:/var/lib/myapp
volumes:
  appdata:
```

> 앱이 반드시 기록해야 하는 경로(예: 업로드 폴더, 세션 데이터)는 **명시적으로 볼륨으로 분리**하여 관리합니다. 이렇게 하면 쓰기 권한이 필요한 영역을 정확히 통제할 수 있습니다.

---

## 최소 권한 원칙: Linux Capabilities 관리

Linux Capabilities는 루트 권한을 세분화한 것입니다. 컨테이너는 호스트의 커널을 공유하므로, 불필요한 Capabilities를 제거하는 것이 중요합니다.

### 모든 Capabilities 제거 후 필요한 것만 추가

```bash
docker run \
  --cap-drop ALL \
  --cap-add NET_BIND_SERVICE \  # 1024 미만의 포트에 바인딩할 때 필요
  myapp:latest
```

### 자주 사용되는 Capabilities 가이드라인

- **일반적인 웹 서버**: 대부분 추가 Capabilities가 필요하지 않습니다. `--cap-drop ALL`을 기본으로 적용하는 것을 권장합니다.
- **80/443 포트 사용**: 1024번 미만의 포트를 사용하려면 `NET_BIND_SERVICE` Capability가 필요합니다.
- **네트워크 스니핑/원시(raw) 소켓**: `NET_RAW` Capability는 컨테이너가 네트워크 패킷을 수신 대기할 수 있게 합니다. **보안상 이유로 절대 추가하지 마십시오.**

컨테이너 내부의 유효 Capabilities를 확인하는 방법:
```bash
grep CapEff /proc/1/status
```

---

## 시스템 콜 및 파일 접근 제한: seccomp, AppArmor, SELinux

### seccomp (Secure Computing Mode)

seccomp 프로필을 사용하여 컨테이너가 호출할 수 있는 시스템 콜을 제한할 수 있습니다. Docker는 기본적으로 허용 목록(allowlist) 기반의 seccomp 프로필을 제공합니다. 더 엄격한 프로필을 직접 정의할 수도 있습니다.

```json
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "archMap": [{ "architecture": "SCMP_ARCH_X86_64", "subArchitectures": ["SCMP_ARCH_X86", "SCMP_ARCH_X32"] }],
  "syscalls": [
    { "names": ["read","write","exit","futex","nanosleep","epoll_wait","epoll_ctl","clone3"], "action": "SCMP_ACT_ALLOW" },
    { "names": ["keyctl","add_key","request_key","mount","umount2","ptrace","kexec_load","open_by_handle_at"], "action": "SCMP_ACT_ERRNO" }
  ]
}
```
적용 방법:
```bash
docker run --security-opt seccomp=./seccomp-tight.json myapp
```

### AppArmor (Ubuntu 및 파생 배포판)

Docker는 기본 AppArmor 프로필(`docker-default`)을 제공합니다.
```bash
docker run --security-opt apparmor=docker-default myapp
```
고유한 프로필은 `/etc/apparmor.d/` 디렉터리에 정의할 수 있습니다.

### SELinux (RHEL, CentOS, Fedora, AlmaLinux)

SELinux가 활성화된 호스트에서는 볼륨 마운트 시 보안 컨텍스트 라벨을 지정해야 합니다.
- `:Z`: 해당 볼륨에 프라이빗(고유)한 SELinux 컨텍스트를 부여합니다. 다른 컨테이너와 공유되지 않습니다.
- `:z`: 다중 컨테이너가 공유할 수 있는 공유 SELinux 컨텍스트를 부여합니다.

```bash
docker run -v /data/app:/app/data:Z myapp
```

---

## 호스트 파일 시스템 마운트 최소화

호스트의 민감한 경로를 컨테이너에 마운트하는 것은 큰 위험을 초래합니다. 반드시 필요한 경우에도 읽기 전용(`:ro`)으로 마운트하십시오.

### 읽기 전용 마운트 예시

```bash
docker run -v /opt/certs:/etc/ssl/certs:ro myapp
```

### 위험한 경로 마운트 금지

다음 경로들은 특별한 이유 없이 마운트해서는 안 됩니다:
- `/var/run/docker.sock` (Docker 데몬 제어)
- `/proc`, `/sys` (호스트 커널 정보)
- 호스트의 루트 파일시스템(`/`)

정말로 필요한 경우(예: Docker 소켓을 통한 모니터링), Docker 소켓 프록시 도구를 사용하거나, 사이드카 패턴을 도입하거나, 필요한 최소한의 API만 노출하는 방안을 고려하십시오.

---

## 이미지 공급망 보안: 스캔, 서명, SBOM

### 취약점 스캔

이미지를 빌드한 후 및 배포 전에 정기적으로 취약점 스캔을 수행하세요.

```bash
trivy image --ignore-unfixed --severity HIGH,CRITICAL myorg/myapp:1.0.0
```

### CI/CD 파이프라인에 스캔 통합

심각도가 높은 취약점이 발견되면 빌드를 실패 처리하도록 설정합니다.

```yaml
- name: Trivy Security Scan
  uses: aquasecurity/trivy-action@0.20.0
  with:
    image-ref: myorg/myapp:latest
    vuln-type: 'os,library'
    severity: 'HIGH,CRITICAL'
    ignore-unfixed: true
```

### 이미지 서명 (Sigstore Cosign)

서명된 이미지만 배포 허용 정책을 통해 이미지 무결성과 출처를 검증할 수 있습니다.

서명 생성:
```bash
cosign sign my-registry.example.com/myorg/myapp:1.0.0
```

서명 검증:
```bash
cosign verify my-registry.example.com/myorg/myapp:1.0.0
```

### 소프트웨어 명세서(SBOM) 생성

SBOM은 이미지 내 포함된 모든 소프트웨어 구성 요소의 청사진입니다. 공급망 공격 분석 및 규정 준수에 필수적입니다.

```bash
docker scout sbom myorg/myapp:1.0.0 > sbom.spdx.json
```
`syft`나 `trivy sbom` 명령어도 사용할 수 있습니다.

> 운영 환경에서는 **"서명 검증 완료 + SBOM 생성 + 취약점 스캔 통과"** 이미지만 배포를 허용하는 정책을 OPA Gatekeeper나 Kyverno 같은 도구로 강제할 수 있습니다.

---

## 이미지 관리: 최신화, 최소화, 고정

- **`latest` 태그 피하기**: `latest` 태그는 항상 변할 수 있어 재현성을 해칩니다. 의미적 버전(`v1.2.3`)이나 커밋 해시를 사용하세요.
- **최소 베이스 이미지 선택**: `alpine`, `distroless`, `-slim` 태그의 이미지는 공격 표면(Attack Surface)을 줄여줍니다. 단, 애플리케이션이 특정 라이브러리(예: `glibc`)를 필요로 하는지 확인하세요.
- **멀티스테이지 빌드 활용**: 빌드 도구와 컴파일러 같은 불필요한 구성 요소가 최종 이미지에 포함되지 않도록 합니다.

```Dockerfile
FROM golang:1.22 AS build
WORKDIR /src
COPY . .
RUN CGO_ENABLED=0 go build -o app ./cmd/app

FROM gcr.io/distroless/static
COPY --from=build /src/app /app
USER 65532:65532
ENTRYPOINT ["/app"]
```

---

## Docker 데몬 및 소켓 접근 제어

### 원격 접근 시 mTLS 필수 적용

암호화되지 않은 TCP 포트(2375)로 Docker 데몬을 노출하는 것은 절대 금지됩니다. 원격 접근이 필요하면 mTLS를 반드시 활성화하세요.

```bash
dockerd --host tcp://0.0.0.0:2376 \
  --tlsverify \
  --tlscacert=/etc/docker/ca.pem \
  --tlscert=/etc/docker/server-cert.pem \
  --tlskey=/etc/docker/server-key.pem
```

클라이언트 측에서는 컨텍스트를 생성하여 안전하게 연결합니다.
```bash
docker context create prod \
  --docker "host=tcp://prod:2376,ca=/path/ca.pem,cert=/path/cert.pem,key=/path/key.pem"
```

### 로컬 Unix 소켓 권한 관리

`docker` 그룹에 속한 사용자는 사실상 루트 권한을 가집니다. 이 그룹에는 최소한의 인원과 CI 서비스 계정만 포함시켜야 합니다.
더 강력한 보안을 원한다면 **Rootless Docker** 모드를 도입하는 것을 고려하세요.

---

## 리소스 제한 설정 (서비스 거부 공격 방지)

### cgroups를 통한 제한

```bash
docker run \
  --cpus=1.0 \
  --memory=512m --memory-swap=512m \
  --pids-limit=256 \
  myapp
```

### 프로세스별 파일 제한(ulimits)

```bash
docker run --ulimit nofile=65535:65535 myapp
```

### Docker Compose 구성

```yaml
services:
  api:
    image: myorg/api
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
    pids_limit: 256
    ulimits:
      nofile:
        soft: 65535
        hard: 65535
```

---

## 네트워크 보안

- **불필요한 아웃바운드 트래픽 차단**: Kubernetes 환경에서는 NetworkPolicy를, Docker 단독 환경에서는 리버스 프록시나 호스트 방화벽을 통해 제어할 수 있습니다.
- **내부 DNS 확인**: 컨테이너 간 통신에 의존하는 내부 DNS 확인이 보안 정책과 충돌하지 않는지 점검하세요.
- **NET_RAW Capability 차단**: 기본 seccomp 프로필과 `--cap-drop ALL` 설정으로도 원시 소켓 접근을 제한할 수 있습니다.

---

## 런타임 침해 탐지 및 모니터링

- **행위 기반 탐지**: **Falco**나 **Tracee**와 같은 도구를 사용하여 권한 상승 시도, 셸 스폰, 의심스러운 파일 시스템 마운트 등 비정상적인 시스템 콜을 실시간으로 감지합니다.
- **중앙 집중식 로깅**: Docker의 `json-file` 로그 드라이버와 로그 회전 설정을 사용하고, Fluent Bit나 Vector를 통해 모든 로그를 중앙 시스템으로 수집하여 분석합니다.
- **메트릭 수집**: cAdvisor, Node Exporter, Containerd 메트릭을 Prometheus에 수집하고 Grafana 대시보드를 구성하여 컨테이너 자원 사용량과 성능을 지속적으로 모니터링합니다.

---

## Rootless Docker: 권한 상승 위험 근본적 감소

Rootless 모드는 Docker 데몬과 컨테이너를 모두 일반 사용자 권한으로 실행합니다. 이는 Docker 데몬이나 컨테이너 내의 취약점이 악용되더라도 호스트의 루트 권한으로 직접 이어지지 않게 하는 강력한 방어 계층입니다.

설치 및 사용:
```bash
dockerd-rootless-setuptool.sh install
systemctl --user enable docker --now
export DOCKER_HOST=unix://$XDG_RUNTIME_DIR/docker.sock
docker info | grep -i rootless
```

---

## 비밀 정보 관리 요약

- **환경변수 사용 금지**: 환경변수는 `docker inspect`, 프로세스 목록, 로그 등에 쉽게 노출됩니다.
- **전용 비밀 관리 도구 활용**: Docker Swarm Secrets, Kubernetes Secrets를 사용하거나, HashiCorp Vault, AWS Secrets Manager, GCP Secret Manager와 같은 외부 솔루션과 연동하세요.
- **빌드 시 비밀 전달**: Dockerfile 내에서 비밀을 사용해야 한다면 BuildKit의 시크릿 마운트 기능을 사용하세요.
```Dockerfile
# syntax=docker/dockerfile:1.6
RUN --mount=type=secret,id=npm_token bash -lc 'cat /run/secrets/npm_token > ~/.npmrc'
```
```bash
docker build --secret id=npm_token,src=.secrets/npm_token .
```

---

## 종합적인 보안 Docker Compose 구성 예시

다음은 위에서 설명한 여러 보안 원칙을 하나의 Compose 파일에 적용한 예시입니다.

```yaml
version: "3.9"
services:
  web:
    image: myorg/web:1.2.3
    user: "10001:10001"                # 비루트 사용자 실행
    read_only: true                    # 읽기 전용 파일 시스템
    tmpfs:
      - /tmp                           # 임시 파일 쓰기를 위한 tmpfs
    security_opt:
      - no-new-privileges:true        # 새로운 권한 획득 방지
      - seccomp=./seccomp-tight.json  # 사용자 정의 seccomp 프로필
      - apparmor=docker-default       # 기본 AppArmor 프로필 적용
    cap_drop:
      - ALL                           # 모든 Capabilities 제거
    cap_add:
      - NET_BIND_SERVICE              # 낮은 번호 포트 바인딩에 필요한 Capability만 추가
    pids_limit: 256                   # 최대 프로세스 수 제한
    ulimits:
      nofile:
        soft: 65535
        hard: 65535                   # 파일 디스크립터 제한
    environment:
      - APP_ENV=prod
    ports:
      - "8080:8080"
    volumes:
      - webdata:/var/lib/web          # 애플리케이션 데이터를 위한 전용 볼륨

volumes:
  webdata:
```

---

## VM 환경에서 Docker 사용 시 고려사항

가상 머신(VM) 위에서 Docker를 실행할 때는 몇 가지 추가적인 주의점이 있습니다.

- **중첩 가상화 성능**: 클라우드 VM 내에서 KVM을 다시 사용하는 경우 성능이 저하되거나 비활성화될 수 있습니다. 가능하면 호스트 OS에 직접 Docker를 설치하거나, 빌드용 VM과 런타임용 VM을 물리적으로 분리하는 아키텍처를 고려하세요.
- **이중 리소스 제한**: VM 자체에 자원 제한(예: 4 vCPU)이 걸려 있고, 그 안의 컨테이너에도 제한(예: 1 vCPU)을 걸면 실제 가용 자원이 더 줄어듭니다. VM 수준의 할당량이 컨테이너들의 상한 합보다 충분히 크도록 설계하세요.
- **복잡한 네트워크 스택**: VM의 가상 NIC, 호스트의 가상 스위치, Docker의 브리지와 iptables 규칙이 겹치면서 네트워크 성능 저하나 MTU 문제가 발생할 수 있습니다. VM과 Docker 모두에서 MTU 값을 일치시키고(예: 1450), 필요한 경우 포트 매핑과 네트워크 대역을 신중하게 계획하세요.
- **파일 시스템 경로 인지**: Docker Desktop for Mac/Windows는 호스트 파일 시스템을 VM 내부의 경로로 공유합니다. 컨테이너 입장에서는 이 VM 내부 경로를 마운트하는 것입니다. 대용량 I/O 작업이 필요한 경우, 데이터를 VM 내부 디스크로 먼저 복사한 후 볼륨으로 사용하는 것이 성능에 유리할 수 있습니다.
- **보안 정책 중첩**: 호스트 VM의 SELinux/AppArmor 정책과 컨테이너의 보안 프로필이 서로 충돌하여 정상 동작을 막을 수 있습니다. `audit.log`나 `dmesg` 출력을仔细히 확인하여 거부(denial) 메시지를 분석하고 정책을 조정하세요.

---

## 결론

Docker 컨테이너 보안은 단일 기술이나 설정이 아니라 여러 계층에 걸친 방어 체계를 구축하는 과정입니다. **비루트 사용자 실행, 읽기 전용 파일 시스템, 불필요한 Capabilities 제거, seccomp/AppArmor 보안 프로필 적용, 리소스 제한** 이 다섯 가지는 모든 컨테이너에 적용해야 할 핵심 보안 조치입니다.

이미지 공급망의 무결성을 보장하기 위해서는 CI/CD 파이프라인에 **자동화된 취약점 스캔, SBOM 생성, 이미지 서명**을 필수 단계로 통합해야 합니다. 그리고 이러한 정책을 런타임 환경(예: Kubernetes)에서 OPA Gatekeeper나 Kyverno를 통해 강제하고, Falco 같은 런타임 보안 모니터링 도구로 이상 행위를 탐지하는 것이 완전한 생명주기 보안을 구성합니다.

가상화 환경에서 Docker를 사용할 때는 성능, 네트워크, 보안 정책의 '이중 적용' 문제를 인지하고 설계해야 합니다. 모든 보안 설정은 실제 애플리케이션에 대한 충분한 테스트를 거쳐야 하며, 로그, 메트릭, 이벤트를 지속적으로 관찰하여 예상치 못한 문제를 신속히 발견하고 대응할 수 있는 가시성(Visibility)을 유지하는 것이 궁극적인 목표입니다.