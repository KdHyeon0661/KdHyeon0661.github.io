---
layout: post
title: Docker - 보안 강화
date: 2025-03-27 22:20:23 +0900
category: Docker
---
# Docker 보안 강화 방법

## 0. 위협 모델 먼저 정하자
컨테이너 보안은 “무엇을 막을 것인가”에 따라 설정이 달라진다.

| 위협 | 예시 | 핵심 대응 |
|---|---|---|
| 이미지 기원 불명/취약 | 임의 이미지 pull, 오래된 베이스, 악성 엔트리포인트 | **서명·스캔·신뢰 레지스트리·최소 베이스** |
| 런타임 탈출/권한 상승 | `--privileged`, 과도 Cap, 호스트 마운트, 취약 syscall | **비루트, Cap Drop, seccomp/AppArmor/SELinux, ReadOnly** |
| 비밀 유출 | env, 로그, 레이어, 히스토리 | **Secrets/외부 비밀 저장소, build secret, 마스킹** |
| 자원 고갈 | 무제한 CPU/메모리/프로세스/파일 | **cgroups limits, ulimits, pidsLimit, OOM 정책** |
| 데몬 노출 | TCP 2375, 광범위 docker 그룹 | **mTLS, rootless, 소켓 접근 최소** |
| 네트워크 측면이동 | 컨테이너 간 평면 | **네트워크 정책/분리, read-only mount, drop NET_RAW** |

---

## 1. 루트 권한 제거 (기본 중의 기본)

### 1.1 안전한 Dockerfile 패턴
```Dockerfile
FROM node:18-alpine

# 1. 패키지 설치는 한 RUN으로 묶고, 빌드 도구는 제거
RUN apk add --no-cache tini && \
    addgroup -S app && adduser -S -G app app

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .

# 2. 파일 소유권 조정
RUN chown -R app:app /app

# 3. 비루트로 전환
USER app

# 4. init 프로세스(tini)로 좀비 방지
ENTRYPOINT ["/sbin/tini","--"]
CMD ["node","server.js"]
```

### 1.2 컨테이너 실행 시 사용자 강제
```bash
docker run --user 10001:10001 myapp:latest
```

검증:
```bash
docker exec -it <cid> id
```

---

## 2. 읽기 전용 파일시스템 + 쓰기 경로 최소화

### 2.1 기본
```bash
docker run --read-only \
  --tmpfs /tmp \
  -v appdata:/var/lib/myapp \
  myapp:latest
```

### 2.2 Compose 예시
```yaml
services:
  api:
    image: myorg/api:1.0.0
    read_only: true
    tmpfs:
      - /tmp
    volumes:
      - appdata:/var/lib/myapp
volumes:
  appdata:
```

> 앱이 쓰는 경로를 **명시적으로 분리**하면, 의도치 않은 파일 변경·웹셸 업로드·자기변형을 억제한다.

---

## 3. 최소 권한: Linux Capabilities 다이어트

### 3.1 완전 제거 후 필요한 것만 추가
```bash
docker run \
  --cap-drop ALL \
  --cap-add NET_BIND_SERVICE \  # 1024 미만 포트 바인딩
  myapp:latest
```

### 3.2 자주 쓰는 Cap 가이드
- 일반 웹서버: 대체로 **불필요** (80/8080 사용) → `--cap-drop ALL` 권장
- 80/443 필요 시: `NET_BIND_SERVICE`
- 네트워크 스니핑/Raw 소켓은 금지: **`NET_RAW` 절대 추가하지 않기**

컨테이너 내 Cap 확인(리눅스):
```bash
grep CapEff /proc/1/status
```

---

## 4. seccomp/AppArmor/SELinux: 시스템콜·객체 접근 제한

### 4.1 seccomp 기본 적용
Docker는 기본 seccomp 프로파일을 제공한다. 엄격화 예시(일부 syscall 차단):
```json
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "archMap": [{ "architecture": "SCMP_ARCH_X86_64", "subArchitectures": ["SCMP_ARCH_X86", "SCMP_ARCH_X32"] }],
  "syscalls": [
    { "names": ["read","write","exit","futex","nanosleep","epoll_wait","epoll_ctl","clone3"], "action": "SCMP_ACT_ALLOW" },
    { "names": ["keyctl","add_key","request_key","mount","umount2","ptrace","kexec_load","open_by_handle_at"], "action": "SCMP_ACT_ERRNO" }
  ]
}
```
적용:
```bash
docker run --security-opt seccomp=./seccomp-tight.json myapp
```

### 4.2 AppArmor (Ubuntu 계열)
```bash
docker run --security-opt apparmor=docker-default myapp
```
사용자 정의는 `/etc/apparmor.d/`에 추가.

### 4.3 SELinux (RHEL/AlmaLinux)
- 볼륨 마운트 시 `:Z`(private) / `:z`(shared) 컨텍스트:
```bash
docker run -v /data/app:/app/data:Z myapp
```

---

## 5. 호스트 마운트 최소화

### 5.1 읽기 전용 마운트
```bash
docker run -v /opt/certs:/etc/ssl/certs:ro myapp
```

### 5.2 위험한 경로는 금지
- `/var/run/docker.sock`, `/proc`, `/sys`, 호스트 루트 `/`
- 정말 필요하다면 대안을 고려(예: socket proxy, sidecar, read-only bind + 좁은 API)

---

## 6. 이미지 공급망 보안: 스캔·서명·SBOM

### 6.1 취약점 스캔
```bash
trivy image --ignore-unfixed --severity HIGH,CRITICAL myorg/myapp:1.0.0
```

### 6.2 빌드시 리턴코드로 실패 처리 (CI)
```yaml
- name: Trivy
  uses: aquasecurity/trivy-action@v0.20.0
  with:
    image-ref: myorg/myapp:latest
    vuln-type: 'os,library'
    severity: 'HIGH,CRITICAL'
    ignore-unfixed: true
```

### 6.3 이미지 서명 (Sigstore Cosign)
서명:
```bash
cosign sign my-registry.example.com/myorg/myapp:1.0.0
```
검증:
```bash
cosign verify my-registry.example.com/myorg/myapp:1.0.0
```

### 6.4 SBOM 생성
```bash
docker scout sbom myorg/myapp:1.0.0 > sbom.spdx.json
```
또는 `syft`, `trivy sbom` 사용.

> 운영/클러스터 입장에선 “**서명된 이미지 + SBOM + 스캔 통과**”가 배포 허용 기준이 된다(Gatekeeper/Kyverno로 정책화 가능).

---

## 7. 최신 이미지/베이스 최소화·고정 태그
- `latest`는 **가변적** → 재현성 파괴.
- 최소 베이스: `alpine`/`distroless`/`slim` 계열. 단, 네이티브 의존(예: `glibc` 필요) 확인.
- 멀티스테이지로 빌드 의존 제거:
```Dockerfile
FROM golang:1.22 AS build
WORKDIR /src
COPY . .
RUN CGO_ENABLED=0 go build -o app ./cmd/app

FROM gcr.io/distroless/static
COPY --from=build /src/app /app
USER 65532:65532
ENTRYPOINT ["/app"]
```

---

## 8. Docker 데몬/소켓 접근 제어

### 8.1 원격 접근은 반드시 mTLS
```bash
dockerd --host tcp://0.0.0.0:2376 \
  --tlsverify \
  --tlscacert=/etc/docker/ca.pem \
  --tlscert=/etc/docker/server-cert.pem \
  --tlskey=/etc/docker/server-key.pem
```
클라이언트 Context:
```bash
docker context create prod \
  --docker "host=tcp://prod:2376,ca=/path/ca.pem,cert=/path/cert.pem,key=/path/key.pem"
```

### 8.2 로컬 소켓 권한
- `docker` 그룹은 **루트 동등 권한**. 최소 인원/CI만 포함.
- 더 강하게: **Rootless Docker** 도입(§12).

---

## 9. 리소스 제한(DoS 방지)

### 9.1 cgroups limits
```bash
docker run \
  --cpus=1.0 \
  --memory=512m --memory-swap=512m \
  --pids-limit=256 \
  myapp
```

### 9.2 ulimits
```bash
docker run --ulimit nofile=65535:65535 myapp
```

### 9.3 Compose
```yaml
services:
  api:
    image: myorg/api
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
    pids_limit: 256
    ulimits:
      nofile:
        soft: 65535
        hard: 65535
```

---

## 10. 네트워크 보안
- 불필요한 egress 차단(쿠버네티스면 **NetworkPolicy**, Docker Swarm/Compose면 리버스 프록시 경유)
- 컨테이너 이름 해석/내부 DNS 의존 확인
- `--cap-drop ALL`로도 남는 Raw 소켓 제한(기본 seccomp + NET_RAW 미부여)

---

## 11. 런타임 침해 탐지/감시
- **Falco**/Tracee: 의심스러운 syscall 감지(권한 상승/셸 스폰/마운트 시도)
- 로깅: `json-file` 회전 + 중앙 수집(Fluent Bit/Vector)
- 메트릭: cAdvisor/Node Exporter/Containerd metrics + 대시보드(Grafana)

---

## 12. Rootless Docker (강력 권장 시나리오)
루트 권한 없이 Docker 데몬+컨테이너를 일반 사용자로 구동.

설치:
```bash
dockerd-rootless-setuptool.sh install
systemctl --user enable docker --now
export DOCKER_HOST=unix://$XDG_RUNTIME_DIR/docker.sock
docker info | grep -i rootless
```
장점: 도커 취약점/오용이 **호스트 루트**로 직격되는 리스크를 대폭 축소.

---

## 13. Secrets 다루기(요약)
- **환경변수로 비밀 전달 금지**(프로세스/inspect/로그에 노출).
- Docker Swarm/K8s Secrets 또는 외부 비밀 관리(AWS Secrets Manager, Vault, GCP Secret Manager) 사용.
- BuildKit secret:
```Dockerfile
# syntax=docker/dockerfile:1.6
RUN --mount=type=secret,id=npm_token bash -lc 'cat /run/secrets/npm_token > ~/.npmrc'
```
빌드:
```bash
docker build --secret id=npm_token,src=.secrets/npm_token .
```

---

## 14. CI/CD 파이프라인 보안 플로우(샘플)
1) Lint (`hadolint`, `dockle`)
2) BuildKit 빌드(멀티스테이지, inline cache)
3) SBOM 생성(`syft`/`docker scout sbom`)
4) Trivy/Scout 스캔(High/Critical fail)
5) Cosign 서명(+ Rekor 투명 로그)
6) 서명 검증 후 레지스트리 푸시
7) 배포단 인증: **서명/스캔 통과/정책 만족** 시만 승인(OPA Gatekeeper/Kyverno)

---

## 15. 실행 예시: “잠그는 Compose”
```yaml
version: "3.9"
services:
  web:
    image: myorg/web:1.2.3
    user: "10001:10001"
    read_only: true
    tmpfs:
      - /tmp
    security_opt:
      - no-new-privileges:true
      - seccomp=./seccomp-tight.json
      - apparmor=docker-default
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    pids_limit: 256
    ulimits:
      nofile:
        soft: 65535
        hard: 65535
    environment:
      - APP_ENV=prod
    # secrets/비밀 마운트는 Swarm or 외부 비밀 저장소 권장
    ports:
      - "8080:8080"
    # 리드온리이므로 필요한 쓰기 볼륨만 명시
    volumes:
      - webdata:/var/lib/web

volumes:
  webdata:
```

---

## 16. 점검 체크리스트 (운영 전/주기적)

| 항목 | 확인 커맨드/방법 |
|---|---|
| 비루트 실행 | `docker exec -it <cid> id` |
| ReadOnly FS | `/proc/mounts` 확인, 파일 생성 시도 실패 |
| Cap Drop | `grep CapEff /proc/1/status` |
| seccomp/AppArmor/SELinux | `docker inspect`의 `SecurityOpt`, SELinux 컨텍스트 |
| 리소스 제한 | `docker inspect`의 `HostConfig` limits |
| 소켓 보호 | `ss -lntp | grep 2375` 없는지, mTLS 여부 |
| 이미지 스캔/서명 | CI 로그/서명 검증 결과 |
| 로그 회전 | `daemon.json` log-opts, 디스크 사용률 |
| 업데이트 | 베이스 이미지/런타임 CVE 주기 점검 |

---

# 도커를 VM 위에서 사용할 때 주의할 점 (확장)

## A) 성능/가상화
- **Nested virtualization**(예: 클라우드 VM 안에서 KVM/Hyper-V 재사용)이 비활성화/느릴 수 있다.
  → 가능하면 **호스트에 가까운 계층**에서 컨테이너를 구동하거나, **빌드 전용 VM**과 **런타임 VM**을 분리.
- Docker Desktop(macOS/Windows)은 내부에서 경량 VM을 사용한다. 파일 I/O는 **virtio-fs/9p** 경로를 타며 느릴 수 있어, **바인드 마운트 대신 볼륨**을 활용.

## B) 이중 리소스 제한
- VM 할당(예: 4 vCPU/8GB) 위에 컨테이너 제한(1 vCPU/512MB)이 겹치면 가용 자원이 더 줄어든다.
  → **VM 레벨 할당 > 컨테이너 상한 합 + 여유**로 설계.

## C) 네트워크 경로 복잡성
- VM NIC, 가상 스위치, Docker 브리지(iptables/NAT)가 겹쳐 **MTU 불일치/포트 충돌** 발생.
  → VM/도커 모두 **MTU**를 일치(예: 1450), 필요 시 브리지 대역/포트매핑 재설계.

## D) 경로/마운트 인지
- 호스트(macOS)의 `/Users/me/...`를 VM이 자동 공유하면, 컨테이너 입장에선 **VM 내부 경로**가 기준이다.
  → 대용량/핫패스 데이터는 **VM 내부 디스크**로 복사 후 볼륨 사용.

## E) 보안 정책 이중 적용
- VM의 SELinux/AppArmor + 컨테이너 보안(SELinux/AppArmor/seccomp)이 **중첩**되면, 정상 동작이 막힐 수 있다.
  → 거부 로그(auditd/AVC/aa-denied)를 보고 컨텍스트/프로파일 조정.

---

## 부록) 자주 쓰는 하드닝 옵션 모음

### run 명령 옵션
```bash
docker run \
  --user 10001:10001 \
  --read-only \
  --tmpfs /tmp \
  --cap-drop ALL \
  --cap-add NET_BIND_SERVICE \
  --security-opt=no-new-privileges:true \
  --security-opt seccomp=./seccomp-tight.json \
  --security-opt apparmor=docker-default \
  --pids-limit 256 \
  --memory 512m --memory-swap 512m \
  --cpus 1.0 \
  myapp:1.0.0
```

### Dockerfile 베스트 프랙티스
- 최소 베이스, 멀티스테이지, `USER` 필수, 루트 작업 후 즉시 권한 강등
- `ENTRYPOINT`에 `tini` 사용 (신뢰성 높은 시그널 처리)
- 환경변수로 비밀X, 레이어에 비밀 커밋 금지
- `.dockerignore` 관리(빌드 컨텍스트 축소)

---

## 결론
- **비루트/ReadOnly/Cap Drop/보안 프로파일/리소스 제한**이 컨테이너 하드닝의 **핵심 5요소**다.
- 공급망(서명·SBOM·스캔)을 **CI에서 자동화**하고, 런타임에선 **정책(OPA/Kyverno)+탐지(Falco)** 로 **배포-운영**을 잇는다.
- VM 위 Docker는 **성능·네트워크·보안 이중화**를 의식하고 설계하라.
- 모든 설정은 **가설→측정→조정** 루프로 검증하고, **로그/메트릭/이벤트**를 통해 **지속 가시성**을 확보하는 것이 최종 보안이다.
