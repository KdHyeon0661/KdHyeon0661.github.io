---
layout: post
title: C++ - 함수 객체, 람다, 구조적 바인딩
date: 2024-09-11 19:20:23 +0900
category: Cpp
---
# 함수 객체(Functor), 람다, 구조적 바인딩

## 0. 한눈에 보는 핵심

- **Functor**: `operator()`를 가진 객체. 상태를 담고 인라인 최적화가 쉬워 **콜백의 기본기**.
- **Lambda**: **즉석 함수**, 강력한 캡처, 제네릭·`constexpr`·`mutable` 가능, **Functor의 문법 설탕**.
- **std::function**: 다양한 호출자를 담는 **타입 지우개(type erasure)** 래퍼(약간의 오버헤드).
- **std::bind / bind_front**: 인자 고정/재배치. 현대 C++에서는 **람다 선호**, `bind_front`는 안전·명료.
- **구조적 바인딩**: `pair/tuple/array`·구조체를 **변수 분해**. 가독성/의도 표현 대폭 향상.

---

## 1. 함수 객체(Functor) — “함수처럼 호출되는 객체”

### 1.1 기초: 상태 없는 Functor

```cpp
#include <iostream>
struct Adder {
    int operator()(int a, int b) const { return a + b; } // 상태 無
};

int main() {
    Adder add;
    std::cout << add(3, 5) << "\n"; // 8
}
```

- `operator()`가 **호출 연산자**. 컴파일러가 인라인하기 좋아 **오버헤드가 거의 없음**.

### 1.2 상태 보유 Functor (커스텀 비교/해시/필터)

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

struct GreaterN {
    int n;
    explicit GreaterN(int n): n(n) {}
    bool operator()(int x) const { return x > n; }
};

int main(){
    std::vector<int> v{1,6,3,8,2};
    v.erase(std::remove_if(v.begin(), v.end(), GreaterN{5}), v.end());
    for(auto x: v) std::cout << x << ' '; // 6 8
}
```

- **상태 보유**가 쉽고, 템플릿으로 **정적 다형성**을 만들기 좋다.

### 1.3 템플릿 operator() — 제네릭 Functor

```cpp
#include <type_traits>
struct ToString {
    template <class T>
    auto operator()(T&& v) const {
        if constexpr (std::is_convertible_v<T, std::string>)
            return std::string(std::forward<T>(v));
        else
            return std::to_string(std::forward<T>(v));
    }
};
```

---

## 2. 람다 표현식 — “Functor의 즉석 제조기”

람다는 **컴파일러가 자동 생성하는 무명 Functor**. 문법만 다를 뿐 **실체는 Functor**다.

### 2.1 기초

```cpp
#include <iostream>
int main(){
    auto f = [](int x, int y){ return x + y; };
    std::cout << f(2,3) << "\n"; // 5
}
```

### 2.2 정렬 콜백

```cpp
#include <vector>
#include <algorithm>
#include <iostream>
int main(){
    std::vector<int> v{3,1,4};
    std::sort(v.begin(), v.end(), [](int a, int b){ return a > b; });
    for(int x: v) std::cout << x << ' '; // 4 3 1
}
```

### 2.3 캡처 목록 — 값/참조/혼합

```cpp
#include <iostream>
int main(){
    int x = 10, y = 20;

    auto by_val  = [x](int d){ return x + d; };     // 값 캡처(복사본)
    auto by_ref  = [&x](int d){ x += d; return x; };// 참조 캡처(원본 수정)
    auto mixed   = [=,&y](int d){ return x + (y += d); }; // x는 값, y는 참조

    std::cout << by_val(5) << "\n";   // 15 (x는 10 유지)
    std::cout << by_ref(5) << "\n";   // 15 (x → 15)
    std::cout << mixed(5) << "\n";    // 10 + (20+5) = 35
}
```

> **주의**: 참조 캡처는 **수명**을 신중히 관리(캡처 후 호출 시점에 대상이 살아있어야 한다).

### 2.4 init-capture (C++14~) — 캡처 시 계산·이동 캡처

```cpp
#include <memory>
#include <utility>
#include <iostream>

int main(){
    auto p = std::make_unique<int>(42);

    auto by_move = [q = std::move(p)]{
        return *q; // q는 람다 내부의 unique_ptr (p는 비어있음)
    };
    std::cout << by_move() << "\n"; // 42
}
```

- **이동 전용 타입**(예: `unique_ptr`)을 **안전하게 캡처** 가능.

### 2.5 반환 타입 추론/명시

```cpp
auto f = [](int a, int b){ return a + b; }; // 반환 타입 자동 추론

// 서로 다른 분기에서 타입이 다르면 명시 필요
auto g = [](int x)->double {
    if(x>=0) return x;
    return -0.5;
};
```

### 2.6 `mutable` 람다 — 캡처 사본 수정

```cpp
#include <iostream>
int main(){
    int x = 5;
    auto f = [x]() mutable { x += 10; return x; }; // 내부 사본 수정
    std::cout << f() << "\n"; // 15
    std::cout << x  << "\n"; // 5 (원본 불변)
}
```

### 2.7 제네릭 람다 (C++14~) / 템플릿 람다 (C++20~)

```cpp
// 제네릭 람다(C++14): 매개변수에 auto
auto apply = [](auto&& f, auto&& x){ return f(std::forward<decltype(x)>(x)); };

// 템플릿 람다(C++20): 람다 템플릿 파라미터
auto sum = []<class T, class U>(T a, U b){ return a + b; };
static_assert(std::is_same_v<decltype(sum(1,2.0)), double>);
```

### 2.8 `constexpr` 람다 (C++17~)

```cpp
constexpr auto square = [](int x){ return x*x; };
static_assert(square(4) == 16);
```

### 2.9 `this` 캡처와 안전 패턴

```cpp
struct Widget {
    int value{0};
    auto incr_lambda(){
        return [this]{ value++; }; // this 캡처
    }
};
```

- C++20: `[=, this]` 금지(중복). 대개 **`[this]` 또는 `[&]`** 명시.
- 구조적 수명: 람다가 **객체보다 오래** 살아선 안 된다(특히 GUI/콜백 등록 시 주의).

---

## 3. 호출자 추상화: `std::function`, `std::invoke`, `std::bind_front`, 그리고 `std::bind`

### 3.1 `std::function` — 다형 호출 래퍼(타입 지우개)

```cpp
#include <functional>
#include <iostream>

int main(){
    std::function<int(int,int)> op;

    op = [](int a,int b){ return a*b; };  // 람다
    std::cout << op(2,3) << "\n";         // 6

    op = std::plus<int>{};                // Functor
    std::cout << op(2,3) << "\n";         // 5
}
```

- 장점: **하나의 타입**으로 다양한 콜러블을 저장.
- 단점: **작은 오버헤드**(타입 지우개 + SBO 여부는 구현 의존).
- 팁: **핫패스**(고성능 루프)에는 템플릿 파라미터로 **직접 타입**을 받거나 **`auto`/`decltype`**를 사용.

### 3.2 `std::invoke` — 호출 통일 API

```cpp
#include <functional>
#include <iostream>

struct X { int plus(int a, int b){ return a+b; } };

int main(){
    X x;
    auto pm = &X::plus; // 멤버 함수 포인터
    std::cout << std::invoke(pm, x, 2, 3) << "\n"; // 5
}
```

- **함수/함수객체/멤버함수 포인터/멤버 포인터** 모두 동일 API로 호출.

### 3.3 `std::bind_front` (C++20) — 안전·간단한 인자 고정

```cpp
#include <functional>
#include <iostream>

int add(int a, int b, int c){ return a+b+c; }

int main(){
    auto add5 = std::bind_front(add, 5); // a=5 고정
    std::cout << add5(10, 20) << "\n";   // 35
}
```

- **대체**: 많은 경우 `std::bind` 대신 **람다** 또는 `bind_front`가 명확하고 안전.

### 3.4 `std::bind` — 사용할 때의 주의점

```cpp
#include <functional>
#include <iostream>

int mul(int a, int b){ return a*b; }

int main(){
    using std::placeholders::_1;
    auto twice = std::bind(mul, 2, _1);  // 두 번째 인자만 나중에
    std::cout << twice(7) << "\n";       // 14
}
```

- **주의**: 가독성·디버깅 난이도, **참조 붕괴/수명** 함정.
- 현대 C++ 권장: **람다로 대체**하거나 **`bind_front`** 사용.

---

## 4. 구조적 바인딩 (C++17) — “분해 선언”으로 의도 드러내기

### 4.1 `pair/tuple` 분해

```cpp
#include <tuple>
#include <iostream>

int main(){
    std::tuple<int, std::string> t{42, "hi"};
    auto [n, s] = t;           // 값 복사
    const auto& [rn, rs] = t;  // const 참조
    std::cout << rn << " " << rs << "\n"; // 42 hi
}
```

- **분해 선언**은 기본적으로 **새 변수**를 만든다. **참조로 받고 싶으면 `&`**.

### 4.2 `map` 순회

{% raw %}
```cpp
#include <map>
#include <string>
#include <iostream>

int main(){
    std::map<std::string,int> scores{{"Tom",90},{"Jane",85}};
    for(const auto& [name, score] : scores){
        std::cout << name << ": " << score << "\n";
    }
}
```
{% endraw %}

### 4.3 `if` 초기화 + 구조적 바인딩

```cpp
#include <unordered_map>
#include <string>
#include <iostream>

int main(){
    std::unordered_map<std::string,int> cnt;
    if (auto [it, inserted] = cnt.emplace("apple", 1); inserted){
        std::cout << "inserted: " << it->first << "\n";
    } else {
        std::cout << "already: " << it->second << "\n";
    }
}
```

### 4.4 배열/구조체도 가능 (규약 충족 시)

- 배열 크기/멤버 수가 고정이고 **`tuple_size/tuple_element/get`** 프로토콜을 제공하면 가능.
- 단순 **POD 구조체**도 멤버가 공개·규약 충족이면 분해 가능(컴파일러 지원 상황에 의존).

### 4.5 `std::tie`/`std::ignore`와 비교

```cpp
#include <tuple>
int a,b,c;
std::tie(a, std::ignore, c) = std::make_tuple(1,2,3); // 중간 무시
```

- **기존 참조 변수**에 바인딩하려면 `tie`.
- **새 변수를 선언**하려면 구조적 바인딩.

### 4.6 주의: 이름 충돌/수명/캡처

- 구조적 바인딩 변수는 **새 스코프의 이름**.
- **참조 분해** 시 원본 수명에 주의.
- 람다 캡처 시 **바인딩 이름**을 그대로 캡처하면 의도대로 동작.

---

## 5. 알고리즘·컨테이너·동시성에서의 실전 활용

### 5.1 커스텀 정렬/키 추출

{% raw %}
```cpp
#include <vector>
#include <string>
#include <algorithm>
#include <iostream>

struct User { int id; std::string name; };

int main(){
    std::vector<User> users{{2,"bob"},{1,"alice"},{3,"zoe"}};

    std::sort(users.begin(), users.end(),
              [](const User& a, const User& b){
                  return a.id < b.id; // 키 비교
              });

    for(const auto& [id, name] : users) // 구조적 바인딩 (public일 때)
        std::cout << id << ":" << name << "\n";
}
```
{% endraw %}

> 구조체 멤버가 `public`이면 구조적 바인딩이 잘 작동한다. 멤버 접근자가 필요하면 `get` 지원 등 추가 작업.

### 5.2 `ranges` + 람다 (C++20~)

```cpp
#include <ranges>
#include <vector>
#include <iostream>

int main(){
    std::vector<int> v{1,2,3,4,5};
    auto doubled = v | std::views::transform([](int x){ return x*2; })
                     | std::views::filter([](int x){ return x%4==0; });
    for(int x : doubled) std::cout << x << ' '; // 4 8
}
```

### 5.3 콜백 등록과 수명

```cpp
#include <functional>
#include <vector>

struct Dispatcher {
    std::vector<std::function<void(int)>> slots;
    void connect(std::function<void(int)> s){ slots.push_back(std::move(s)); }
    void emit(int v){ for(auto& s: slots) s(v); }
};

int main(){
    Dispatcher d;
    int alive = 0;
    d.connect([&alive](int v){ alive += v; });
    d.emit(3); // alive=3
}
```

- **참조 캡처**(여기서는 `alive`)가 **유효 범위** 안에 머무는지 항상 점검.

### 5.4 동시성: 람다와 스레드

```cpp
#include <thread>
#include <iostream>

int main(){
    int x = 0;
    std::thread th([&]{ for(int i=0;i<1'000'000;i++) x++; }); // 데이터 레이스 예
    th.join();
    std::cout << x << "\n";
}
```

- 콜백 안에서 공유 상태를 수정할 때는 **뮤텍스/원자**로 보호:

```cpp
#include <thread>
#include <atomic>
#include <iostream>

int main(){
    std::atomic<int> x{0};
    std::thread th([&]{ for(int i=0;i<1'000'000;i++) x.fetch_add(1, std::memory_order_relaxed); });
    th.join();
    std::cout << x.load() << "\n";
}
```

---

## 6. 성능·안전·가독성 체크리스트

1) **핫패스**에서 `std::function` 남용 금지
   - 가능한 **템플릿 매개변수**(정적 바인딩) 또는 **auto**로 받기.
2) 캡처는 **최소 권한 원칙**
   - `[]` → 아무것도 캡처하지 않음.
   - `[&]`/`[=]` 전역 캡처는 피하고 **명시 캡처** `[&x]`, `[x]` 선호.
3) **수명**
   - 참조 캡처/비동기 콜백은 **대상 객체 수명** 보장. 필요 시 **`shared_ptr`를 값 캡처**.
4) **`std::bind`보다 람다**
   - 디버깅 난이도・가독성・수명 문제 감소. 고정 인자는 **`bind_front`** 또는 **람다 디폴트**.
5) 구조적 바인딩은 **참조 의도면 `&` 명시**
   - 기본은 **복사**. 큰 객체라면 참조로 받아 비용 줄이기.
6) `mutable`는 **캡처 사본만 수정**
   - 바깥 상태 수정은 참조 캡처.
7) 제네릭 람다/템플릿 람다는 **가독성**을 해치지 않는 선에서 사용
   - 제약이 필요하면 **Concepts**로 명시.

---

## 7. 고급 스니펫 모음

### 7.1 가변 인자 로그 (폴드식)

```cpp
#include <iostream>
template <class... Ts>
void log(Ts&&... xs){
    (std::cout << ... << xs) << '\n'; // C++17 fold
}
```

### 7.2 완벽 전달 람다(래퍼)

```cpp
#include <utility>
auto forward_call = [](auto&& f, auto&&... args)
    -> decltype(auto) { return std::forward<decltype(f)>(f)(std::forward<decltype(args)>(args)...); };
```

### 7.3 `shared_ptr`를 값 캡처하여 수명 안전화

```cpp
#include <memory>
#include <functional>

struct Service { void work(){} };

std::function<void()> make_task(std::shared_ptr<Service> s){
    return [s = std::move(s)]{ s->work(); }; // 캡처로 수명 연장
}
```

### 7.4 `bind_front`로 멤버 함수 고정

```cpp
#include <functional>
#include <iostream>

struct Acc { int sum(int a,int b){ return a+b; } };

int main(){
    Acc acc;
    auto call = std::bind_front(&Acc::sum, &acc); // 첫 인자 this 고정
    std::cout << call(3,4) << "\n"; // 7
}
```

### 7.5 구조적 바인딩 + 파일 파싱 예시

```cpp
#include <string>
#include <vector>
#include <tuple>
#include <sstream>
#include <iostream>

std::tuple<std::string,int,double> parse_line(const std::string& line){
    std::istringstream iss(line);
    std::string name; int age; double height;
    iss >> name >> age >> height;
    return {name,age,height};
}

int main(){
    std::vector<std::string> lines{"kim 29 175.4", "lee 33 182.0"};
    for(const auto& ln: lines){
        auto [name, age, height] = parse_line(ln);
        std::cout << name << " " << age << " " << height << "\n";
    }
}
```

---

## 8. 복잡도·비용 모델(개념)

람다/함수객체 호출 비용은 보통 **정적 디스패치 + 인라이닝**으로 거의 0에 가깝다.
`std::function`은 내부적으로 **타입 지우개 + 간접 호출**을 하므로, 평균적으로 다음과 같은 비용이 더해진다:

$$
T_{\text{call}} \approx T_{\text{direct}} + T_{\text{indirection}} + T_{\text{SBO\_check}}
$$

- 많은 호출이 예상되는 루프라면 **직접 타입 매개변수**로 받는 것이 일반적으로 빠르다.

---

## 9. 비교 요약 표

| 요소 | 장점 | 단점 | 주용도 |
|---|---|---|---|
| Functor | 인라인/무오버헤드, 상태 보유 용이 | 문법 장황 | 고성능 콜백/정렬/해시/필터 |
| Lambda | 간결 문법, 강력 캡처, 제네릭/constexpr | 수명/캡처 함정 | 즉석 콜백, 알고리즘 인자 |
| std::function | 이종 콜러블 저장, 인터페이스 단순화 | 타입 지우개 오버헤드 | API 경계, 플러그인형 콜백 |
| std::bind | 인자 고정/재배치 | 가독성/수명 문제, 디버깅 난 | **구식**; 대체로 람다/`bind_front` |
| bind_front | 간단/안전한 부분 적용 | C++20 필요 | this/일부 인자 고정 |

---

## 10. 실전 과제(스스로 점검)

1) **람다로 커스텀 정렬**: 구조체 벡터를 **두 키(보조 키)** 로 정렬.
2) **콜백 레지스트리**: `std::function<void(int)>`로 이벤트 시스템 만들기(수명/스레드 안전 고려).
3) **파서**: 한 줄 문자열을 람다 파이프라인(`ranges`)으로 토큰화 → 구조적 바인딩으로 소비.
4) **성능 비교**: Functor vs 람다 vs `std::function` 호출 비용 마이크로벤치.
5) **캡처 안전화**: `shared_ptr` 값 캡처 버전과 참조 캡처 버전의 **크래시 재현/교정**.

---

# 결론

- **함수 객체와 람다**는 C++의 **콜백·정렬·필터·변환**을 지탱하는 핵심 축이다.
- **구조적 바인딩**은 의도와 데이터를 **짧고 명확하게** 드러내는 도구다.
- API 경계에서는 **`std::function`** 으로 단순화하고, 성능이 필요한 곳에서는 **정적 디스패치**로 오버헤드를 없애라.
- 수명/캡처/동시성의 함정을 피하면, 현대 C++는 **짧고, 빠르고, 안전한** 함수형 스타일을 충분히 제공한다.
