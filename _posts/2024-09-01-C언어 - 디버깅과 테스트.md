---
layout: post
title: C - ë””ë²„ê¹…ê³¼ í…ŒìŠ¤íŠ¸
date: 2024-09-01 19:20:23 +0900
category: C
---
# ë””ë²„ê¹…ê³¼ í…ŒìŠ¤íŠ¸: C ì–¸ì–´ í”„ë¡œê·¸ë¨ì˜ ê²¬ê³ ì„± í™•ë³´í•˜ê¸°

## ì™œ ë””ë²„ê¹…ê³¼ í…ŒìŠ¤íŠ¸ê°€ ì¤‘ìš”í•œê°€?

í”„ë¡œê·¸ë˜ë°ì—ì„œ ë²„ê·¸ëŠ” í”¼í•  ìˆ˜ ì—†ëŠ” í˜„ì‹¤ì…ë‹ˆë‹¤. ê°€ì¥ ìˆ™ë ¨ëœ í”„ë¡œê·¸ë˜ë¨¸ì¡°ì°¨ ì‹¤ìˆ˜ë¥¼ í•©ë‹ˆë‹¤. ì¤‘ìš”í•œ ê²ƒì€ ë²„ê·¸ë¥¼ ì–´ë–»ê²Œ ë°œê²¬í•˜ê³  í•´ê²°í•˜ëŠ”ê°€ì…ë‹ˆë‹¤. ë””ë²„ê¹…ê³¼ í…ŒìŠ¤íŠ¸ëŠ” ë‹¨ìˆœíˆ ë²„ê·¸ë¥¼ ì°¾ëŠ” ê²ƒ ì´ìƒìœ¼ë¡œ, ì½”ë“œì˜ ì‹ ë¢°ì„±ì„ ë†’ì´ê³  ìœ ì§€ë³´ìˆ˜ë¥¼ ìš©ì´í•˜ê²Œ í•©ë‹ˆë‹¤.

ì´ë²ˆ ì¥ì—ì„œëŠ” C í”„ë¡œê·¸ë˜ë°ì—ì„œ íš¨ê³¼ì ì¸ ë””ë²„ê¹…ê³¼ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ë‹¤ì–‘í•œ ë„êµ¬ì™€ ê¸°ë²•ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ê°„ë‹¨í•œ ì˜ˆì œë¶€í„° ì‹œì‘í•´ì„œ ì ì  ë” ë³µì¡í•œ ì‹œë‚˜ë¦¬ì˜¤ê¹Œì§€ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤.

## ê¸°ë³¸ ë„êµ¬: Assertions

### assert() í•¨ìˆ˜ì˜ ê¸°ë³¸ ì‚¬ìš©ë²•

`assert()`ëŠ” C í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— í¬í•¨ëœ ê°€ì¥ ê¸°ë³¸ì ì¸ ë””ë²„ê¹… ë„êµ¬ì…ë‹ˆë‹¤. í”„ë¡œê·¸ë¨ì˜ íŠ¹ì • ì§€ì ì—ì„œ ì¡°ê±´ì´ ì°¸ì¸ì§€ ê²€ì¦í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤:

```c
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

// ê°„ë‹¨í•œ ê³„ì‚° í•¨ìˆ˜
int divide(int numerator, int denominator) {
    // ë¶„ëª¨ê°€ 0ì´ ì•„ë‹Œì§€ í™•ì¸ (ê°œë°œ ì¤‘ì—ë§Œ í™œì„±í™”)
    assert(denominator != 0 && "0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
    return numerator / denominator;
}

// ë©”ëª¨ë¦¬ í• ë‹¹ ë˜í¼ í•¨ìˆ˜
void* safe_malloc(size_t size) {
    void* ptr = malloc(size);
    // ë©”ëª¨ë¦¬ í• ë‹¹ì´ ì„±ê³µí–ˆëŠ”ì§€ í™•ì¸
    assert(ptr != NULL && "ë©”ëª¨ë¦¬ í• ë‹¹ ì‹¤íŒ¨");
    return ptr;
}

int main(void) {
    printf("assert() ê¸°ë³¸ ì˜ˆì œ\n");
    
    // ì •ìƒì ì¸ ê²½ìš°
    printf("10 / 2 = %d\n", divide(10, 2));
    
    // ë¹„ì •ìƒì ì¸ ê²½ìš° (ê°œë°œ ì¤‘ì—ë§Œ ì‹¤íŒ¨)
    // printf("10 / 0 = %d\n", divide(10, 0)); // assert ì‹¤íŒ¨
    
    // ë©”ëª¨ë¦¬ í• ë‹¹
    int* numbers = (int*)safe_malloc(10 * sizeof(int));
    printf("ë©”ëª¨ë¦¬ í• ë‹¹ ì„±ê³µ\n");
    
    free(numbers);
    
    return 0;
}
```

### assertì˜ ì¤‘ìš”í•œ íŠ¹ì§•

1. **ê°œë°œ ì¤‘ì—ë§Œ í™œì„±í™”**: `-DNDEBUG` í”Œë˜ê·¸ë¡œ ì»´íŒŒì¼í•˜ë©´ assert ë¬¸ì´ ì œê±°ë©ë‹ˆë‹¤
2. **ì¡°ê±´ì´ ê±°ì§“ì¼ ë•Œ í”„ë¡œê·¸ë¨ ì¤‘ë‹¨**: assertê°€ ì‹¤íŒ¨í•˜ë©´ í”„ë¡œê·¸ë¨ì´ ì¦‰ì‹œ ì¢…ë£Œë©ë‹ˆë‹¤
3. **ì˜¤ë¥˜ ë©”ì‹œì§€ ì œê³µ**: ì‹¤íŒ¨í•œ ì¡°ê±´ê³¼ íŒŒì¼ëª…, ë¼ì¸ ë²ˆí˜¸ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤

```bash
# ê°œë°œ ëª¨ë“œ ì»´íŒŒì¼
gcc -g -O0 program.c -o program

# ë¦´ë¦¬ìŠ¤ ëª¨ë“œ ì»´íŒŒì¼ (assert ì œê±°)
gcc -DNDEBUG -O2 program.c -o program_release
```

### ì‚¬ìš©ì ì •ì˜ assert ë§¤í¬ë¡œ

í‘œì¤€ `assert()`ëŠ” ìœ ìš©í•˜ì§€ë§Œ ì œí•œì ì…ë‹ˆë‹¤. ë” ë§ì€ ì •ë³´ë¥¼ ì œê³µí•˜ëŠ” ì‚¬ìš©ì ì •ì˜ assertë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ê³ ê¸‰ ASSERT ë§¤í¬ë¡œ
#define CUSTOM_ASSERT(condition, message, ...) \
    do { \
        if (!(condition)) { \
            fprintf(stderr, "[ASSERT ì‹¤íŒ¨] %s:%d %s(): ", \
                    __FILE__, __LINE__, __func__); \
            fprintf(stderr, message, ##__VA_ARGS__); \
            fprintf(stderr, "\n"); \
            abort(); \
        } \
    } while(0)

// ë²„ì „ 2: ì¡°ê±´ê³¼ ì¶”ê°€ ì •ë³´
#define ASSERT_MSG(condition, fmt, ...) \
    do { \
        if (!(condition)) { \
            fprintf(stderr, "[ASSERT] %s:%d: " fmt "\n", \
                    __FILE__, __LINE__, ##__VA_ARGS__); \
            exit(EXIT_FAILURE); \
        } \
    } while(0)

// ë°°ì—´ ë²”ìœ„ ê²€ì‚¬
#define ASSERT_BOUNDS(index, size) \
    ASSERT_MSG((index) >= 0 && (index) < (size), \
               "ì¸ë±ìŠ¤ %dê°€ ë²”ìœ„ [0, %d)ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤", (index), (size))

void process_array(int* array, int size, int index) {
    // ë°°ì—´ ë²”ìœ„ ê²€ì‚¬
    ASSERT_BOUNDS(index, size);
    
    // ë°°ì—´ì´ NULLì´ ì•„ë‹Œì§€ ê²€ì‚¬
    ASSERT_MSG(array != NULL, "ë°°ì—´ í¬ì¸í„°ê°€ NULLì…ë‹ˆë‹¤");
    
    // ì‹¤ì œ ì‘ì—… ìˆ˜í–‰
    array[index] = 42;
    printf("array[%d] = %d\n", index, array[index]);
}

int main(void) {
    printf("ì‚¬ìš©ì ì •ì˜ assert ì˜ˆì œ\n");
    
    int numbers[5] = {1, 2, 3, 4, 5};
    
    // ì •ìƒì ì¸ í˜¸ì¶œ
    process_array(numbers, 5, 2);
    
    // ë¹„ì •ìƒì ì¸ í˜¸ì¶œ (ì‹¤íŒ¨)
    // process_array(numbers, 5, 10);  // ASSERT_BOUNDS ì‹¤íŒ¨
    // process_array(NULL, 5, 2);      // ASSERT_MSG ì‹¤íŒ¨
    
    return 0;
}
```

## ë¡œê¹…: í”„ë¡œê·¸ë¨ì˜ ê±´ê°• ìƒíƒœ ëª¨ë‹ˆí„°ë§

ë¡œê¹…ì€ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ ë°œìƒí•˜ëŠ” ì´ë²¤íŠ¸ë¥¼ ê¸°ë¡í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ë””ë²„ê¹…ì— ë§¤ìš° ìœ ìš©í•˜ë©°, íŠ¹íˆ ì¬í˜„í•˜ê¸° ì–´ë ¤ìš´ ë¬¸ì œë¥¼ í•´ê²°í•  ë•Œ í•„ìˆ˜ì ì…ë‹ˆë‹¤.

### ê¸°ë³¸ ë¡œê¹… ì‹œìŠ¤í…œ êµ¬í˜„

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>

// ë¡œê·¸ ë ˆë²¨ ì •ì˜
typedef enum {
    LOG_TRACE,   // ê°€ì¥ ìƒì„¸í•œ ì •ë³´
    LOG_DEBUG,   // ë””ë²„ê¹… ì •ë³´
    LOG_INFO,    // ì¼ë°˜ ì •ë³´
    LOG_WARN,    // ê²½ê³ 
    LOG_ERROR,   // ì˜¤ë¥˜
    LOG_FATAL    // ì¹˜ëª…ì  ì˜¤ë¥˜
} LogLevel;

// ë¡œê·¸ ë ˆë²¨ì„ ë¬¸ìì—´ë¡œ ë³€í™˜
static const char* log_level_strings[] = {
    "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "FATAL"
};

// ì „ì—­ ë¡œê·¸ ë ˆë²¨ (ê¸°ë³¸ê°’: INFO)
static LogLevel global_log_level = LOG_INFO;

// ë¡œê·¸ ë ˆë²¨ ì„¤ì •
void set_log_level(LogLevel level) {
    global_log_level = level;
}

// íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„±
void get_timestamp(char* buffer, size_t size) {
    time_t now = time(NULL);
    struct tm* timeinfo = localtime(&now);
    strftime(buffer, size, "%Y-%m-%d %H:%M:%S", timeinfo);
}

// ë¡œê·¸ ê¸°ë¡ í•¨ìˆ˜
void log_message(LogLevel level, const char* file, int line, 
                 const char* function, const char* format, ...) {
    
    // ë¡œê·¸ ë ˆë²¨ ì²´í¬
    if (level < global_log_level) {
        return;
    }
    
    // íƒ€ì„ìŠ¤íƒ¬í”„
    char timestamp[20];
    get_timestamp(timestamp, sizeof(timestamp));
    
    // ë¡œê·¸ ë ˆë²¨ ë¬¸ìì—´
    const char* level_str = log_level_strings[level];
    
    // íŒŒì¼ëª…ë§Œ ì¶”ì¶œ (ì „ì²´ ê²½ë¡œê°€ ì•„ë‹Œ)
    const char* filename = strrchr(file, '/');
    if (filename == NULL) {
        filename = strrchr(file, '\\');
    }
    if (filename != NULL) {
        filename++;  // '/' ë˜ëŠ” '\' ë‹¤ìŒ ë¬¸ìë¶€í„°
    } else {
        filename = file;
    }
    
    // ë¡œê·¸ ë©”ì‹œì§€ í¬ë§·íŒ…
    fprintf(stderr, "[%s] %s %s:%d %s(): ",
            timestamp, level_str, filename, line, function);
    
    // ê°€ë³€ ì¸ì ì²˜ë¦¬
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    
    fprintf(stderr, "\n");
    fflush(stderr);
}

// í¸ì˜ë¥¼ ìœ„í•œ ë§¤í¬ë¡œ
#define LOG_TRACE(...) log_message(LOG_TRACE, __FILE__, __LINE__, __func__, __VA_ARGS__)
#define LOG_DEBUG(...) log_message(LOG_DEBUG, __FILE__, __LINE__, __func__, __VA_ARGS__)
#define LOG_INFO(...)  log_message(LOG_INFO,  __FILE__, __LINE__, __func__, __VA_ARGS__)
#define LOG_WARN(...)  log_message(LOG_WARN,  __FILE__, __LINE__, __func__, __VA_ARGS__)
#define LOG_ERROR(...) log_message(LOG_ERROR, __FILE__, __LINE__, __func__, __VA_ARGS__)
#define LOG_FATAL(...) log_message(LOG_FATAL, __FILE__, __LINE__, __func__, __VA_ARGS__)

// ì˜¤ë¥˜ ì²˜ë¦¬ì™€ í•¨ê»˜ ë¡œê¹…
#define LOG_IF_ERROR(condition, message) \
    do { \
        if ((condition)) { \
            LOG_ERROR("%s: %s", (message), strerror(errno)); \
        } \
    } while(0)

// íŒŒì¼ ì‘ì—… ì˜ˆì œ
int safe_file_copy(const char* src, const char* dst) {
    LOG_INFO("íŒŒì¼ ë³µì‚¬ ì‹œì‘: %s -> %s", src, dst);
    
    FILE* source = fopen(src, "rb");
    LOG_IF_ERROR(source == NULL, "ì›ë³¸ íŒŒì¼ ì—´ê¸° ì‹¤íŒ¨");
    if (source == NULL) return -1;
    
    FILE* destination = fopen(dst, "wb");
    if (destination == NULL) {
        LOG_ERROR("ëŒ€ìƒ íŒŒì¼ ìƒì„± ì‹¤íŒ¨: %s", strerror(errno));
        fclose(source);
        return -1;
    }
    
    LOG_DEBUG("íŒŒì¼ ì—´ê¸° ì„±ê³µ, ë³µì‚¬ ì‹œì‘");
    
    // íŒŒì¼ ë³µì‚¬
    char buffer[4096];
    size_t bytes;
    size_t total_bytes = 0;
    
    while ((bytes = fread(buffer, 1, sizeof(buffer), source)) > 0) {
        size_t written = fwrite(buffer, 1, bytes, destination);
        if (written != bytes) {
            LOG_ERROR("íŒŒì¼ ì“°ê¸° ì˜¤ë¥˜: %sì—ì„œ %zuë°”ì´íŠ¸ ì¤‘ %zuë°”ì´íŠ¸ë§Œ ì”€", 
                     dst, bytes, written);
            fclose(source);
            fclose(destination);
            return -1;
        }
        total_bytes += written;
    }
    
    LOG_IF_ERROR(ferror(source), "íŒŒì¼ ì½ê¸° ì˜¤ë¥˜");
    
    fclose(source);
    fclose(destination);
    
    LOG_INFO("íŒŒì¼ ë³µì‚¬ ì™„ë£Œ: %zuë°”ì´íŠ¸ ë³µì‚¬ë¨", total_bytes);
    return 0;
}

int main(void) {
    // ë¡œê·¸ ë ˆë²¨ ì„¤ì • (ëª…ë ¹í–‰ ì¸ì ë“±ì—ì„œ ì„¤ì • ê°€ëŠ¥)
    set_log_level(LOG_DEBUG);
    
    LOG_TRACE("íŠ¸ë ˆì´ìŠ¤ ë©”ì‹œì§€ (ë§¤ìš° ìƒì„¸)");
    LOG_DEBUG("ë””ë²„ê·¸ ë©”ì‹œì§€");
    LOG_INFO("ì •ë³´ ë©”ì‹œì§€");
    LOG_WARN("ê²½ê³  ë©”ì‹œì§€");
    LOG_ERROR("ì˜¤ë¥˜ ë©”ì‹œì§€");
    
    // íŒŒì¼ ë³µì‚¬ ì‹œë„
    safe_file_copy("input.txt", "output.txt");
    
    // íŒŒì¼ì´ ì—†ì„ ë•Œì˜ ì˜¤ë¥˜ ì²˜ë¦¬
    safe_file_copy("nonexistent.txt", "output.txt");
    
    return 0;
}
```

### íŒŒì¼ ë¡œê¹… ì‹œìŠ¤í…œ

ì½˜ì†”ì—ë§Œ ë¡œê·¸ë¥¼ ì¶œë ¥í•˜ëŠ” ëŒ€ì‹  íŒŒì¼ì—ë„ ì €ì¥í•˜ëŠ” ë” ì™„ì „í•œ ë¡œê¹… ì‹œìŠ¤í…œ:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdarg.h>

// ë¡œê·¸ ê´€ë¦¬ì êµ¬ì¡°ì²´
typedef struct {
    FILE* file;
    int min_level;
    int use_console;
    char filename[256];
} Logger;

// ì „ì—­ ë¡œê±° ì¸ìŠ¤í„´ìŠ¤
static Logger global_logger = {0};

// ë¡œê±° ì´ˆê¸°í™”
int logger_init(const char* filename, int min_level, int use_console) {
    if (filename != NULL) {
        global_logger.file = fopen(filename, "a");
        if (global_logger.file == NULL) {
            return -1;
        }
        strncpy(global_logger.filename, filename, sizeof(global_logger.filename) - 1);
    }
    
    global_logger.min_level = min_level;
    global_logger.use_console = use_console;
    
    return 0;
}

// ë¡œê±° ì •ë¦¬
void logger_cleanup(void) {
    if (global_logger.file != NULL) {
        fclose(global_logger.file);
        global_logger.file = NULL;
    }
}

// ë¡œê·¸ ë ˆë²¨ ì´ë¦„
static const char* level_names[] = {
    "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "FATAL"
};

// ì‹¤ì œ ë¡œê·¸ ì‘ì„± í•¨ìˆ˜
void logger_write(int level, const char* file, int line, 
                  const char* function, const char* format, ...) {
    
    // ë ˆë²¨ ì²´í¬
    if (level < global_logger.min_level) {
        return;
    }
    
    // íƒ€ì„ìŠ¤íƒ¬í”„
    char timestamp[64];
    time_t now = time(NULL);
    struct tm* tm_info = localtime(&now);
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", tm_info);
    
    // íŒŒì¼ëª… ì¶”ì¶œ
    const char* basename = strrchr(file, '/');
    if (basename == NULL) basename = strrchr(file, '\\');
    if (basename != NULL) basename++;
    else basename = file;
    
    // ë©”ì‹œì§€ í¬ë§·íŒ…
    char message[1024];
    va_list args;
    va_start(args, format);
    vsnprintf(message, sizeof(message), format, args);
    va_end(args);
    
    // ë¡œê·¸ ë¼ì¸ ìƒì„±
    char log_line[2048];
    snprintf(log_line, sizeof(log_line),
             "[%s] [%s] %s:%d %s(): %s\n",
             timestamp, level_names[level], basename, line, function, message);
    
    // ì¶œë ¥
    if (global_logger.use_console) {
        fprintf(stderr, "%s", log_line);
        fflush(stderr);
    }
    
    if (global_logger.file != NULL) {
        fprintf(global_logger.file, "%s", log_line);
        fflush(global_logger.file);
    }
    
    // ì¹˜ëª…ì  ì˜¤ë¥˜ëŠ” í”„ë¡œê·¸ë¨ ì¢…ë£Œ
    if (level == 5) {  // FATAL
        logger_cleanup();
        exit(EXIT_FAILURE);
    }
}

// í¸ì˜ ë§¤í¬ë¡œ
#define LOGGER_TRACE(...) logger_write(0, __FILE__, __LINE__, __func__, __VA_ARGS__)
#define LOGGER_DEBUG(...) logger_write(1, __FILE__, __LINE__, __func__, __VA_ARGS__)
#define LOGGER_INFO(...)  logger_write(2, __FILE__, __LINE__, __func__, __VA_ARGS__)
#define LOGGER_WARN(...)  logger_write(3, __FILE__, __LINE__, __func__, __VA_ARGS__)
#define LOGGER_ERROR(...) logger_write(4, __FILE__, __LINE__, __func__, __VA_ARGS__)
#define LOGGER_FATAL(...) logger_write(5, __FILE__, __LINE__, __func__, __VA_ARGS__)

int main(void) {
    // ë¡œê±° ì´ˆê¸°í™” (ì½˜ì†”ê³¼ íŒŒì¼ ëª¨ë‘ ì¶œë ¥)
    if (logger_init("app.log", 1, 1) != 0) {
        fprintf(stderr, "ë¡œê±° ì´ˆê¸°í™” ì‹¤íŒ¨\n");
        return 1;
    }
    
    LOGGER_INFO("ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘");
    LOGGER_DEBUG("ë””ë²„ê·¸ ë©”ì‹œì§€ í…ŒìŠ¤íŠ¸");
    
    int value = 42;
    LOGGER_INFO("í˜„ì¬ ê°’: %d", value);
    
    // ì‹œë®¬ë ˆì´ì…˜: ì˜¤ë¥˜ ë°œìƒ
    FILE* test_file = fopen("test.txt", "r");
    if (test_file == NULL) {
        LOGGER_WARN("í…ŒìŠ¤íŠ¸ íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
    } else {
        fclose(test_file);
    }
    
    // ë³µì¡í•œ ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
    for (int i = 0; i < 3; i++) {
        LOGGER_TRACE("ë£¨í”„ ë°˜ë³µ %d", i);
        
        if (i == 1) {
            LOGGER_ERROR("ì˜ë„ì ì¸ ì˜¤ë¥˜ ë°œìƒ");
        }
    }
    
    LOGGER_INFO("ì• í”Œë¦¬ì¼€ì´ì…˜ ì¢…ë£Œ");
    
    // ë¡œê±° ì •ë¦¬
    logger_cleanup();
    
    return 0;
}
```

## GDB(GNU Debugger): ë¼ì¸ ë‹¨ìœ„ ë””ë²„ê¹…

GDBëŠ” C í”„ë¡œê·¸ë¨ì˜ ê°€ì¥ ê°•ë ¥í•œ ë””ë²„ê¹… ë„êµ¬ì…ë‹ˆë‹¤. í”„ë¡œê·¸ë¨ì„ í•œ ì¤„ì”© ì‹¤í–‰í•˜ë©´ì„œ ë³€ìˆ˜ ê°’ì„ ê²€ì‚¬í•˜ê³ , ì¤‘ë‹¨ì ì„ ì„¤ì •í•˜ë©°, í˜¸ì¶œ ìŠ¤íƒì„ ì¶”ì í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### GDB ê¸°ë³¸ ì‚¬ìš©ë²•

```c
// debug_example.c
#include <stdio.h>
#include <stdlib.h>

// ë²„ê·¸ê°€ ìˆëŠ” í•¨ìˆ˜
int buggy_function(int* array, int size) {
    int sum = 0;
    
    // ì˜ë„ì ì¸ ë²„ê·¸: i <= size (ë°°ì—´ ë²”ìœ„ ì´ˆê³¼)
    for (int i = 0; i <= size; i++) {
        sum += array[i];
    }
    
    return sum;
}

// ë˜ ë‹¤ë¥¸ ë²„ê·¸: ë©”ëª¨ë¦¬ ëˆ„ìˆ˜
void memory_leak_example(void) {
    int* ptr = malloc(100 * sizeof(int));
    
    // ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ í•´ì œí•˜ì§€ ì•ŠìŒ
    for (int i = 0; i < 100; i++) {
        ptr[i] = i;
    }
    
    // ì˜ë„ì ìœ¼ë¡œ í•´ì œí•˜ì§€ ì•ŠìŒ (ëˆ„ìˆ˜)
    // free(ptr);
}

int main(void) {
    printf("GDB ë””ë²„ê¹… ì˜ˆì œ\n");
    
    int numbers[5] = {1, 2, 3, 4, 5};
    
    // ë²„ê·¸ ìˆëŠ” í•¨ìˆ˜ í˜¸ì¶œ
    int result = buggy_function(numbers, 5);
    printf("í•©ê³„: %d\n", result);
    
    // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ í•¨ìˆ˜ í˜¸ì¶œ
    memory_leak_example();
    
    printf("í”„ë¡œê·¸ë¨ ì¢…ë£Œ\n");
    return 0;
}
```

### GDB ëª…ë ¹ì–´ ì‹¤ìŠµ

```bash
# ë””ë²„ê¹… ì •ë³´ í¬í•¨í•˜ì—¬ ì»´íŒŒì¼
gcc -g -O0 debug_example.c -o debug_example

# GDB ì‹¤í–‰
gdb ./debug_example

# GDB ë‚´ë¶€ ëª…ë ¹ì–´:
# 1. í”„ë¡œê·¸ë¨ ì‹œì‘
(gdb) run

# 2. ì¤‘ë‹¨ì  ì„¤ì •
(gdb) break main              # main í•¨ìˆ˜ ì‹œì‘ ì‹œ ì¤‘ë‹¨
(gdb) break debug_example.c:10  # 10ë²ˆì§¸ ì¤„ì—ì„œ ì¤‘ë‹¨
(gdb) break buggy_function    # í•¨ìˆ˜ ì§„ì… ì‹œ ì¤‘ë‹¨

# 3. ì¤‘ë‹¨ì  ëª©ë¡ í™•ì¸
(gdb) info breakpoints

# 4. í”„ë¡œê·¸ë¨ ê³„ì† ì‹¤í–‰
(gdb) continue                # ë‹¤ìŒ ì¤‘ë‹¨ì ê¹Œì§€ ì‹¤í–‰
(gdb) next                    # ë‹¤ìŒ ì¤„ ì‹¤í–‰ (í•¨ìˆ˜ í˜¸ì¶œ ê±´ë„ˆëœ€)
(gdb) step                    # ë‹¤ìŒ ì¤„ ì‹¤í–‰ (í•¨ìˆ˜ í˜¸ì¶œ ë“¤ì–´ê°)

# 5. ë³€ìˆ˜ ê°’ í™•ì¸
(gdb) print sum              # sum ë³€ìˆ˜ ê°’ ì¶œë ¥
(gdb) print array[0]         # ë°°ì—´ ìš”ì†Œ ê°’ ì¶œë ¥
(gdb) print/x sum            # 16ì§„ìˆ˜ë¡œ ì¶œë ¥
(gdb) print/d sum            # 10ì§„ìˆ˜ë¡œ ì¶œë ¥

# 6. í˜¸ì¶œ ìŠ¤íƒ í™•ì¸
(gdb) backtrace              # í•¨ìˆ˜ í˜¸ì¶œ ìŠ¤íƒ ì¶œë ¥
(gdb) frame 0                # 0ë²ˆ í”„ë ˆì„ìœ¼ë¡œ ì´ë™
(gdb) info locals            # í˜„ì¬ í”„ë ˆì„ì˜ ì§€ì—­ ë³€ìˆ˜ ì¶œë ¥
(gdb) info args              # í˜„ì¬ í•¨ìˆ˜ì˜ ì¸ì ì¶œë ¥

# 7. ê°ì‹œì  ì„¤ì • (ë³€ìˆ˜ ê°’ ë³€ê²½ ì‹œ ì¤‘ë‹¨)
(gdb) watch sum              # sum ê°’ì´ ë³€ê²½ë  ë•Œ ì¤‘ë‹¨

# 8. ì¡°ê±´ë¶€ ì¤‘ë‹¨ì 
(gdb) break 15 if i == 3     # 15ë²ˆ ì¤„ì—ì„œ iê°€ 3ì¼ ë•Œë§Œ ì¤‘ë‹¨

# 9. ë©”ëª¨ë¦¬ ê²€ì‚¬
(gdb) x/10x &array           # array ì£¼ì†Œë¶€í„° 10ê°œ ê°’ 16ì§„ìˆ˜ë¡œ ì¶œë ¥
(gdb) x/10d &array           # array ì£¼ì†Œë¶€í„° 10ê°œ ê°’ 10ì§„ìˆ˜ë¡œ ì¶œë ¥

# 10. ì½”ì–´ ë¤í”„ ë¶„ì„ (í”„ë¡œê·¸ë¨ í¬ë˜ì‹œ ì‹œ)
# ulimit -c unlimited        # ì½”ì–´ ë¤í”„ í—ˆìš©
# ./program                  # í¬ë˜ì‹œ ë°œìƒ
# gdb ./program core         # ì½”ì–´ ë¤í”„ ë¶„ì„
```

### ì‹¤ì œ GDB ì„¸ì…˜ ì˜ˆì œ

```
(gdb) break main
Breakpoint 1 at 0x1169: file debug_example.c, line 23.

(gdb) run
Starting program: /path/to/debug_example

Breakpoint 1, main () at debug_example.c:23
23          printf("GDB ë””ë²„ê¹… ì˜ˆì œ\n");

(gdb) next
24          int numbers[5] = {1, 2, 3, 4, 5};

(gdb) next
27          int result = buggy_function(numbers, 5);

(gdb) step
buggy_function (array=0x7fffffffdcc0, size=5) at debug_example.c:9
9           int sum = 0;

(gdb) next
12          for (int i = 0; i <= size; i++) {

(gdb) print size
$1 = 5

(gdb) break 13 if i == 5
Breakpoint 2 at 0x55555555517b: file debug_example.c, line 13.

(gdb) continue
Continuing.

Breakpoint 2, buggy_function (array=0x7fffffffdcc0, size=5) at debug_example.c:13
13              sum += array[i];

(gdb) print i
$2 = 5

(gdb) print array[i]
Cannot access memory at address 0x7fffffffdcf4

(gdb) backtrace
#0  buggy_function (array=0x7fffffffdcc0, size=5) at debug_example.c:13
#1  0x00005555555551b9 in main () at debug_example.c:27
```

## ë©”ëª¨ë¦¬ ë””ë²„ê¹… ë„êµ¬

### AddressSanitizer (ASan)

AddressSanitizerëŠ” ë©”ëª¨ë¦¬ ì˜¤ë¥˜ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ê°ì§€í•˜ëŠ” ë„êµ¬ì…ë‹ˆë‹¤:

```bash
# ASanìœ¼ë¡œ ì»´íŒŒì¼
gcc -g -fsanitize=address -fno-omit-frame-pointer debug_example.c -o debug_example_asan

# ì‹¤í–‰ (ë©”ëª¨ë¦¬ ì˜¤ë¥˜ ê°ì§€)
./debug_example_asan
```

### Valgrind

ValgrindëŠ” í”„ë¡œê·¸ë¨ì„ ê°€ìƒ ë¨¸ì‹ ì—ì„œ ì‹¤í–‰í•˜ë©° ë©”ëª¨ë¦¬ ì˜¤ë¥˜ë¥¼ ê²€ì¶œí•©ë‹ˆë‹¤:

```bash
# Valgrindë¡œ ë©”ëª¨ë¦¬ ê²€ì‚¬
valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./debug_example

# ì¼ë°˜ì ì¸ ì¶œë ¥ ì˜ˆ:
# ==12345== Invalid read of size 4
# ==12345==    at 0x1086B7: buggy_function (debug_example.c:13)
# ==12345==    by 0x108722: main (debug_example.c:27)
# ==12345==  Address 0x522d0a4 is 0 bytes after a block of size 20 alloc'd
# ==12345==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
# ==12345==    by 0x1086FB: main (debug_example.c:24)
```

## ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±

ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” ê°œë³„ í•¨ìˆ˜ë‚˜ ëª¨ë“ˆì´ ì˜ˆìƒëŒ€ë¡œ ë™ì‘í•˜ëŠ”ì§€ ê²€ì¦í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤:

```c
// calculator.h
#ifndef CALCULATOR_H
#define CALCULATOR_H

int add(int a, int b);
int subtract(int a, int b);
int multiply(int a, int b);
double divide(int a, int b);

#endif

// calculator.c
#include "calculator.h"

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

double divide(int a, int b) {
    if (b == 0) {
        return 0.0;  // ì‹¤ì œë¡œëŠ” ë” ë‚˜ì€ ì˜¤ë¥˜ ì²˜ë¦¬ê°€ í•„ìš”
    }
    return (double)a / b;
}

// test_calculator.c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "calculator.h"

// í…ŒìŠ¤íŠ¸ ë§¤í¬ë¡œ
#define TEST(expr, expected) \
    do { \
        int result = (expr); \
        if (result != (expected)) { \
            printf("í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: %s (ê¸°ëŒ€ê°’: %d, ì‹¤ì œê°’: %d)\n", \
                   #expr, (expected), result); \
            return 1; \
        } else { \
            printf("í…ŒìŠ¤íŠ¸ í†µê³¼: %s = %d\n", #expr, result); \
        } \
    } while(0)

#define TEST_DOUBLE(expr, expected, epsilon) \
    do { \
        double result = (expr); \
        if (fabs(result - (expected)) > (epsilon)) { \
            printf("í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: %s (ê¸°ëŒ€ê°’: %.6f, ì‹¤ì œê°’: %.6f)\n", \
                   #expr, (expected), result); \
            return 1; \
        } else { \
            printf("í…ŒìŠ¤íŠ¸ í†µê³¼: %s = %.6f\n", #expr, result); \
        } \
    } while(0)

// í…ŒìŠ¤íŠ¸ í•¨ìˆ˜
int test_addition(void) {
    printf("\n=== ë§ì…ˆ í…ŒìŠ¤íŠ¸ ===\n");
    TEST(add(2, 3), 5);
    TEST(add(-1, 1), 0);
    TEST(add(0, 0), 0);
    TEST(add(100, -50), 50);
    return 0;
}

int test_subtraction(void) {
    printf("\n=== ëº„ì…ˆ í…ŒìŠ¤íŠ¸ ===\n");
    TEST(subtract(5, 3), 2);
    TEST(subtract(3, 5), -2);
    TEST(subtract(0, 0), 0);
    TEST(subtract(-1, -1), 0);
    return 0;
}

int test_multiplication(void) {
    printf("\n=== ê³±ì…ˆ í…ŒìŠ¤íŠ¸ ===\n");
    TEST(multiply(4, 5), 20);
    TEST(multiply(-3, 4), -12);
    TEST(multiply(0, 100), 0);
    TEST(multiply(-2, -3), 6);
    return 0;
}

int test_division(void) {
    printf("\n=== ë‚˜ëˆ—ì…ˆ í…ŒìŠ¤íŠ¸ ===\n");
    TEST_DOUBLE(divide(10, 2), 5.0, 0.000001);
    TEST_DOUBLE(divide(7, 3), 2.333333, 0.000001);
    TEST_DOUBLE(divide(-10, 2), -5.0, 0.000001);
    TEST_DOUBLE(divide(0, 5), 0.0, 0.000001);
    TEST_DOUBLE(divide(5, 0), 0.0, 0.000001);  // 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ì²˜ë¦¬
    return 0;
}

// í…ŒìŠ¤íŠ¸ ëŸ¬ë„ˆ
typedef int (*TestFunction)(void);

typedef struct {
    const char* name;
    TestFunction function;
} TestCase;

int main(void) {
    printf("ê³„ì‚°ê¸° ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‹œì‘\n");
    
    TestCase test_cases[] = {
        {"ë§ì…ˆ", test_addition},
        {"ëº„ì…ˆ", test_subtraction},
        {"ê³±ì…ˆ", test_multiplication},
        {"ë‚˜ëˆ—ì…ˆ", test_division},
    };
    
    int total_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    int passed_tests = 0;
    int failed_tests = 0;
    
    for (int i = 0; i < total_tests; i++) {
        printf("\n--- %s í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ---\n", test_cases[i].name);
        
        if (test_cases[i].function() == 0) {
            printf("âœ“ %s í…ŒìŠ¤íŠ¸ í†µê³¼\n", test_cases[i].name);
            passed_tests++;
        } else {
            printf("âœ— %s í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨\n", test_cases[i].name);
            failed_tests++;
        }
    }
    
    printf("\n=== í…ŒìŠ¤íŠ¸ ê²°ê³¼ ===\n");
    printf("ì „ì²´ í…ŒìŠ¤íŠ¸: %d\n", total_tests);
    printf("í†µê³¼: %d\n", passed_tests);
    printf("ì‹¤íŒ¨: %d\n", failed_tests);
    
    if (failed_tests == 0) {
        printf("\nëª¨ë“  í…ŒìŠ¤íŠ¸ê°€ í†µê³¼í–ˆìŠµë‹ˆë‹¤! ğŸ‰\n");
        return 0;
    } else {
        printf("\nì¼ë¶€ í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\n");
        return 1;
    }
}
```

## í†µí•© í…ŒìŠ¤íŠ¸ ì˜ˆì œ

ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë³´ë‹¤ ë” í° ê·œëª¨ì˜ í†µí•© í…ŒìŠ¤íŠ¸ ì˜ˆì œ:

```c
// database.h
#ifndef DATABASE_H
#define DATABASE_H

typedef struct {
    int id;
    char name[50];
    int age;
    double salary;
} Employee;

// ë°ì´í„°ë² ì´ìŠ¤ í•¨ìˆ˜
void db_init(void);
int db_add_employee(const char* name, int age, double salary);
int db_find_employee(int id, Employee* result);
int db_update_employee(int id, const Employee* updates);
int db_delete_employee(int id);
int db_get_employee_count(void);
void db_cleanup(void);

#endif

// test_database.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "database.h"

// í…ŒìŠ¤íŠ¸ í—¬í¼ ë§¤í¬ë¡œ
#define TEST_START(name) \
    printf("\n=== %s í…ŒìŠ¤íŠ¸ ì‹œì‘ ===\n", (name))

#define TEST_END(name, result) \
    do { \
        if ((result)) { \
            printf("âœ“ %s í…ŒìŠ¤íŠ¸ í†µê³¼\n", (name)); \
        } else { \
            printf("âœ— %s í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨\n", (name)); \
        } \
    } while(0)

#define ASSERT(condition, message) \
    do { \
        if (!(condition)) { \
            printf("  ì‹¤íŒ¨: %s\n", (message)); \
            return 0; \
        } \
    } while(0)

// í…ŒìŠ¤íŠ¸ 1: ê¸°ë³¸ CRUD ì—°ì‚°
int test_basic_crud(void) {
    TEST_START("ê¸°ë³¸ CRUD ì—°ì‚°");
    
    // ì´ˆê¸°í™”
    db_init();
    
    // ì¶”ê°€ í…ŒìŠ¤íŠ¸
    int id1 = db_add_employee("í™ê¸¸ë™", 30, 50000.0);
    ASSERT(id1 > 0, "ì§ì› ì¶”ê°€ ì‹¤íŒ¨");
    
    int id2 = db_add_employee("ê¹€ì² ìˆ˜", 25, 45000.0);
    ASSERT(id2 > 0, "ë‘ ë²ˆì§¸ ì§ì› ì¶”ê°€ ì‹¤íŒ¨");
    ASSERT(id2 != id1, "ê³ ìœ  ID ìƒì„± ì‹¤íŒ¨");
    
    // ì¡°íšŒ í…ŒìŠ¤íŠ¸
    Employee emp;
    ASSERT(db_find_employee(id1, &emp) == 0, "ì§ì› ì¡°íšŒ ì‹¤íŒ¨");
    ASSERT(strcmp(emp.name, "í™ê¸¸ë™") == 0, "ì´ë¦„ ë¶ˆì¼ì¹˜");
    ASSERT(emp.age == 30, "ë‚˜ì´ ë¶ˆì¼ì¹˜");
    ASSERT(emp.salary == 50000.0, "ê¸‰ì—¬ ë¶ˆì¼ì¹˜");
    
    // ì—…ë°ì´íŠ¸ í…ŒìŠ¤íŠ¸
    Employee updates = {0, "í™ê¸¸ë™ ìˆ˜ì •", 31, 55000.0};
    ASSERT(db_update_employee(id1, &updates) == 0, "ì§ì› ì •ë³´ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨");
    
    ASSERT(db_find_employee(id1, &emp) == 0, "ì—…ë°ì´íŠ¸ í›„ ì¡°íšŒ ì‹¤íŒ¨");
    ASSERT(strcmp(emp.name, "í™ê¸¸ë™ ìˆ˜ì •") == 0, "ì—…ë°ì´íŠ¸ í›„ ì´ë¦„ ë¶ˆì¼ì¹˜");
    ASSERT(emp.age == 31, "ì—…ë°ì´íŠ¸ í›„ ë‚˜ì´ ë¶ˆì¼ì¹˜");
    ASSERT(emp.salary == 55000.0, "ì—…ë°ì´íŠ¸ í›„ ê¸‰ì—¬ ë¶ˆì¼ì¹˜");
    
    // ì‚­ì œ í…ŒìŠ¤íŠ¸
    ASSERT(db_delete_employee(id1) == 0, "ì§ì› ì‚­ì œ ì‹¤íŒ¨");
    ASSERT(db_find_employee(id1, &emp) != 0, "ì‚­ì œ í›„ì—ë„ ì§ì›ì´ ì¡´ì¬");
    
    // ì¹´ìš´íŠ¸ í…ŒìŠ¤íŠ¸
    ASSERT(db_get_employee_count() == 1, "ì§ì› ìˆ˜ ë¶ˆì¼ì¹˜");
    
    // ì •ë¦¬
    db_cleanup();
    
    return 1;
}

// í…ŒìŠ¤íŠ¸ 2: ì—ì§€ ì¼€ì´ìŠ¤
int test_edge_cases(void) {
    TEST_START("ì—ì§€ ì¼€ì´ìŠ¤");
    
    db_init();
    
    // ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ID ì¡°íšŒ
    Employee emp;
    ASSERT(db_find_employee(999, &emp) != 0, "ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ID ì¡°íšŒ ì„±ê³µ (ì‹¤íŒ¨í•´ì•¼ í•¨)");
    
    // ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ID ì—…ë°ì´íŠ¸
    Employee updates = {0, "ì—†ëŠ” ì‚¬ëŒ", 99, 99999.0};
    ASSERT(db_update_employee(999, &updates) != 0, "ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ID ì—…ë°ì´íŠ¸ ì„±ê³µ (ì‹¤íŒ¨í•´ì•¼ í•¨)");
    
    // ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ID ì‚­ì œ
    ASSERT(db_delete_employee(999) != 0, "ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ID ì‚­ì œ ì„±ê³µ (ì‹¤íŒ¨í•´ì•¼ í•¨)");
    
    // ë¹ˆ ì´ë¦„ ì¶”ê°€ ì‹œë„
    int id = db_add_employee("", 25, 30000.0);
    ASSERT(id > 0, "ë¹ˆ ì´ë¦„ ì¶”ê°€ ì‹¤íŒ¨");
    
    // ìŒìˆ˜ ë‚˜ì´ ì¶”ê°€ ì‹œë„
    id = db_add_employee("í…ŒìŠ¤íŠ¸", -5, 30000.0);
    ASSERT(id > 0, "ìŒìˆ˜ ë‚˜ì´ ì¶”ê°€ ì‹¤íŒ¨");
    
    // ìŒìˆ˜ ê¸‰ì—¬ ì¶”ê°€ ì‹œë„
    id = db_add_employee("í…ŒìŠ¤íŠ¸2", 25, -1000.0);
    ASSERT(id > 0, "ìŒìˆ˜ ê¸‰ì—¬ ì¶”ê°€ ì‹¤íŒ¨");
    
    db_cleanup();
    
    return 1;
}

// í…ŒìŠ¤íŠ¸ 3: ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (ëŒ€ëŸ‰ ë°ì´í„°)
int test_performance(void) {
    TEST_START("ì„±ëŠ¥ í…ŒìŠ¤íŠ¸");
    
    db_init();
    
    const int NUM_EMPLOYEES = 1000;
    int* ids = malloc(NUM_EMPLOYEES * sizeof(int));
    
    // ëŒ€ëŸ‰ ì¶”ê°€
    for (int i = 0; i < NUM_EMPLOYEES; i++) {
        char name[50];
        snprintf(name, sizeof(name), "ì§ì›%d", i);
        ids[i] = db_add_employee(name, 20 + (i % 40), 30000.0 + (i * 100));
        
        ASSERT(ids[i] > 0, "ëŒ€ëŸ‰ ì¶”ê°€ ì¤‘ ì‹¤íŒ¨");
        
        if (i % 100 == 0) {
            printf("  %dëª… ì¶”ê°€ ì™„ë£Œ\n", i);
        }
    }
    
    // ëŒ€ëŸ‰ ì¡°íšŒ
    Employee emp;
    for (int i = 0; i < NUM_EMPLOYEES; i++) {
        ASSERT(db_find_employee(ids[i], &emp) == 0, "ëŒ€ëŸ‰ ì¡°íšŒ ì¤‘ ì‹¤íŒ¨");
    }
    
    // ì¹´ìš´íŠ¸ í™•ì¸
    ASSERT(db_get_employee_count() == NUM_EMPLOYEES, "ì§ì› ìˆ˜ ë¶ˆì¼ì¹˜");
    
    // ëŒ€ëŸ‰ ì‚­ì œ
    for (int i = 0; i < NUM_EMPLOYEES; i++) {
        ASSERT(db_delete_employee(ids[i]) == 0, "ëŒ€ëŸ‰ ì‚­ì œ ì¤‘ ì‹¤íŒ¨");
    }
    
    // ìµœì¢… ì¹´ìš´íŠ¸ í™•ì¸
    ASSERT(db_get_employee_count() == 0, "ëª¨ë“  ì§ì› ì‚­ì œ í›„ ì¹´ìš´íŠ¸ ë¶ˆì¼ì¹˜");
    
    free(ids);
    db_cleanup();
    
    return 1;
}

// í…ŒìŠ¤íŠ¸ ëŸ¬ë„ˆ
int main(void) {
    printf("ë°ì´í„°ë² ì´ìŠ¤ í†µí•© í…ŒìŠ¤íŠ¸ ì‹œì‘\n");
    
    typedef struct {
        const char* name;
        int (*function)(void);
    } Test;
    
    Test tests[] = {
        {"ê¸°ë³¸ CRUD ì—°ì‚°", test_basic_crud},
        {"ì—ì§€ ì¼€ì´ìŠ¤", test_edge_cases},
        {"ì„±ëŠ¥ í…ŒìŠ¤íŠ¸", test_performance},
    };
    
    int total_tests = sizeof(tests) / sizeof(tests[0]);
    int passed = 0;
    int failed = 0;
    
    for (int i = 0; i < total_tests; i++) {
        if (tests[i].function()) {
            passed++;
        } else {
            failed++;
        }
    }
    
    printf("\n=== ìµœì¢… í…ŒìŠ¤íŠ¸ ê²°ê³¼ ===\n");
    printf("ì „ì²´ í…ŒìŠ¤íŠ¸: %d\n", total_tests);
    printf("í†µê³¼: %d\n", passed);
    printf("ì‹¤íŒ¨: %d\n", failed);
    
    if (failed == 0) {
        printf("\nğŸ‰ ëª¨ë“  í†µí•© í…ŒìŠ¤íŠ¸ í†µê³¼!\n");
        return 0;
    } else {
        printf("\nâš ï¸  ì¼ë¶€ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨\n");
        return 1;
    }
}
```

## ìë™í™”ëœ ë¹Œë“œì™€ í…ŒìŠ¤íŠ¸

Makefileì„ ì‚¬ìš©í•˜ì—¬ ë¹Œë“œ, í…ŒìŠ¤íŠ¸, ì •ë¦¬ë¥¼ ìë™í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```makefile
# Makefile
CC = gcc
CFLAGS = -Wall -Wextra -Werror -g
TEST_FLAGS = -fsanitize=address -fno-omit-frame-pointer
COVERAGE_FLAGS = --coverage

# íƒ€ê²Ÿ ì •ì˜
TARGET = myprogram
TEST_TARGET = test_program
COVERAGE_TARGET = coverage_report

# ì†ŒìŠ¤ íŒŒì¼
SRCS = main.c calculator.c database.c
TEST_SRCS = test_calculator.c test_database.c calculator.c database.c

# ê¸°ë³¸ íƒ€ê²Ÿ
all: $(TARGET)

# ë©”ì¸ í”„ë¡œê·¸ë¨ ë¹Œë“œ
$(TARGET): $(SRCS)
	$(CC) $(CFLAGS) $^ -o $@

# í…ŒìŠ¤íŠ¸ í”„ë¡œê·¸ë¨ ë¹Œë“œ
$(TEST_TARGET): $(TEST_SRCS)
	$(CC) $(CFLAGS) $(TEST_FLAGS) $^ -o $@

# í…ŒìŠ¤íŠ¸ ì‹¤í–‰
test: $(TEST_TARGET)
	./$(TEST_TARGET)

# ì»¤ë²„ë¦¬ì§€ ë¹Œë“œ ë° ë¦¬í¬íŠ¸ ìƒì„±
coverage: $(COVERAGE_TARGET)

$(COVERAGE_TARGET): $(TEST_SRCS)
	$(CC) $(CFLAGS) $(COVERAGE_FLAGS) $^ -o $(TEST_TARGET)
	./$(TEST_TARGET)
	gcov $(TEST_SRCS)
	lcov --capture --directory . --output-file coverage.info
	genhtml coverage.info --output-directory $(COVERAGE_TARGET)
	@echo "ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ê°€ $(COVERAGE_TARGET) ë””ë ‰í„°ë¦¬ì— ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤"

# ë””ë²„ê·¸ ë¹Œë“œ
debug: CFLAGS += -DDEBUG -O0
debug: $(TARGET)

# ë¦´ë¦¬ìŠ¤ ë¹Œë“œ
release: CFLAGS += -DNDEBUG -O2
release: $(TARGET)

# ë©”ëª¨ë¦¬ ê²€ì‚¬
memcheck: $(TARGET)
	valgrind --leak-check=full --show-leak-kinds=all ./$(TARGET)

# ì •ë¦¬
clean:
	rm -f $(TARGET) $(TEST_TARGET)
	rm -f *.gcno *.gcda *.gcov
	rm -f coverage.info
	rm -rf $(COVERAGE_TARGET)

# ë„ì›€ë§
help:
	@echo "ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´:"
	@echo "  make all       - ê¸°ë³¸ ë¹Œë“œ"
	@echo "  make debug     - ë””ë²„ê·¸ ë¹Œë“œ"
	@echo "  make release   - ë¦´ë¦¬ìŠ¤ ë¹Œë“œ"
	@echo "  make test      - í…ŒìŠ¤íŠ¸ ì‹¤í–‰"
	@echo "  make coverage  - ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìƒì„±"
	@echo "  make memcheck  - ë©”ëª¨ë¦¬ ê²€ì‚¬"
	@echo "  make clean     - ë¹Œë“œ íŒŒì¼ ì •ë¦¬"
	@echo "  make help      - ì´ ë„ì›€ë§ í‘œì‹œ"

.PHONY: all debug release test coverage memcheck clean help
```

## ê²°ë¡ 

ë””ë²„ê¹…ê³¼ í…ŒìŠ¤íŠ¸ëŠ” ì „ë¬¸ì ì¸ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œì˜ í•µì‹¬ ìš”ì†Œì…ë‹ˆë‹¤. ì´ë²ˆ ì¥ì—ì„œ ë‹¤ë£¬ ë‚´ìš©ì„ ìš”ì•½í•˜ë©´:

1. **Assertions**: ê°œë°œ ì¤‘ ê°€ì •ì„ ê²€ì¦í•˜ëŠ” ê°€ì¥ ê¸°ë³¸ì ì¸ ë„êµ¬ì…ë‹ˆë‹¤. ë¦´ë¦¬ìŠ¤ ë¹Œë“œì—ì„œëŠ” ì œê±°ë˜ë¯€ë¡œ, ì™¸ë¶€ ì…ë ¥ ê²€ì¦ì—ëŠ” ì‚¬ìš©í•˜ì§€ ë§ì•„ì•¼ í•©ë‹ˆë‹¤.

2. **ë¡œê¹…**: í”„ë¡œê·¸ë¨ì˜ ì‹¤í–‰ íë¦„ê³¼ ìƒíƒœë¥¼ ê¸°ë¡í•˜ëŠ” ì¤‘ìš”í•œ ë„êµ¬ì…ë‹ˆë‹¤. ì ì ˆí•œ ë¡œê·¸ ë ˆë²¨, íƒ€ì„ìŠ¤íƒ¬í”„, ì»¨í…ìŠ¤íŠ¸ ì •ë³´ë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.

3. **GDB**: ê°€ì¥ ê°•ë ¥í•œ ë””ë²„ê¹… ë„êµ¬ë¡œ, í”„ë¡œê·¸ë¨ì„ í•œ ì¤„ì”© ì‹¤í–‰í•˜ë©° ë³€ìˆ˜ ê°’ì„ ê²€ì‚¬í•˜ê³  ì¤‘ë‹¨ì ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

4. **ë©”ëª¨ë¦¬ ë””ë²„ê¹… ë„êµ¬**: AddressSanitizerì™€ ValgrindëŠ” ë©”ëª¨ë¦¬ ì˜¤ë¥˜ë¥¼ ê°ì§€í•˜ëŠ” ë° í•„ìˆ˜ì ì¸ ë„êµ¬ì…ë‹ˆë‹¤.

5. **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸**: ê°œë³„ í•¨ìˆ˜ë‚˜ ëª¨ë“ˆì˜ ì •í™•ì„±ì„ ê²€ì¦í•©ë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ëŠ” ìë™í™”ë˜ì–´ì•¼ í•˜ë©°, ì •ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.

6. **í†µí•© í…ŒìŠ¤íŠ¸**: ì—¬ëŸ¬ ëª¨ë“ˆì´ í•¨ê»˜ ì‘ë™í•˜ëŠ” ë°©ì‹ì„ ê²€ì¦í•©ë‹ˆë‹¤. ì‹¤ì œ ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤ì™€ ìœ ì‚¬í•œ í™˜ê²½ì—ì„œ ìˆ˜í–‰ë©ë‹ˆë‹¤.

7. **ìë™í™”**: Makefileì´ë‚˜ ë‹¤ë¥¸ ë¹Œë“œ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹Œë“œ, í…ŒìŠ¤íŠ¸, ë°°í¬ ê³¼ì •ì„ ìë™í™”í•´ì•¼ í•©ë‹ˆë‹¤.

íš¨ê³¼ì ì¸ ë””ë²„ê¹…ê³¼ í…ŒìŠ¤íŠ¸ ì „ëµì€ ë²„ê·¸ë¥¼ ì¡°ê¸°ì— ë°œê²¬í•˜ê³  ìˆ˜ì •í•˜ëŠ” ë¹„ìš©ì„ ì¤„ì—¬ì¤ë‹ˆë‹¤. ë” ì¤‘ìš”í•œ ê²ƒì€ ì½”ë“œì— ëŒ€í•œ í™•ì‹ ì„ ì£¼ê³ , ë¦¬íŒ©í† ë§ê³¼ ê¸°ëŠ¥ ì¶”ê°€ë¥¼ ì•ˆì „í•˜ê²Œ í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤ëŠ” ì ì…ë‹ˆë‹¤.

ì²˜ìŒì—ëŠ” ì´ëŸ¬í•œ ë„êµ¬ì™€ ê¸°ë²•ì´ ë¶€ë‹´ìŠ¤ëŸ¬ìš¸ ìˆ˜ ìˆì§€ë§Œ, ì¡°ê¸ˆì”© ë„ì…í•˜ê³  ìŠµê´€í™”í•˜ë©´ ê²°êµ­ ê°œë°œ íš¨ìœ¨ì„±ê³¼ ì½”ë“œ í’ˆì§ˆì´ í¬ê²Œ í–¥ìƒë  ê²ƒì…ë‹ˆë‹¤. ê°€ì¥ ì¤‘ìš”í•œ ê²ƒì€ ë²„ê·¸ê°€ ì—†ëŠ” ì™„ë²½í•œ ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ë²„ê·¸ë¥¼ íš¨ê³¼ì ìœ¼ë¡œ ì°¾ê³  í•´ê²°í•  ìˆ˜ ìˆëŠ” ì‹œìŠ¤í…œì„ ê°–ì¶”ëŠ” ê²ƒì…ë‹ˆë‹¤.