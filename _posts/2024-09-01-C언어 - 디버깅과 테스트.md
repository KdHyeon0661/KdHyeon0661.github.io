---
layout: post
title: C - 디버깅과 테스트
date: 2024-09-01 19:20:23 +0900
category: C
---
# 디버깅과 테스트: assert, gdb, 로그 출력

## 0. 한 화면 치트시트

```c
// 1) assert: 개발 중 불변조건
#include <assert.h>
assert(ptr != NULL);

// 2) 로그: 수준/위치/errno
#define LOGE(fmt, ...) fprintf(stderr,"[E]%s:%d %s: " fmt "\n",__FILE__,__LINE__,__func__,##__VA_ARGS__)
#define DIE(fmt, ...)  do{ LOGE(fmt,##__VA_ARGS__); exit(EXIT_FAILURE);}while(0)

// 3) gdb 컴파일/실행
//   -g: 디버그 심볼, -O0: 최적화 꺼서 라인매핑 용이
//   코어덤프: ulimit -c unlimited; gdb ./a.out core
//   자주 쓰는 명령: run, break, next, step, finish, print, bt, info locals

// 4) Sanitizer
//   gcc -g -O1 -fsanitize=address,undefined -fno-omit-frame-pointer main.c -o app

// 5) 커버리지
//   gcc -g -O0 --coverage main.c -o app && ./app && gcov main.c

// 6) 안전한 테스트 스켈레톤
#define ASSERT_EQ_INT(exp, got) do{ if((exp)!=(got)){ \
  fprintf(stderr,"ASSERT FAIL %s:%d: exp=%d got=%d\n",__FILE__,__LINE__,(exp),(got)); exit(1);} }while(0)
```

---

## 1. `assert` — 개발 중 불변조건을 빠르게 잡는 법

### 1.1 기본 사용

```c
#include <assert.h>

static int divide(int a, int b) {
    assert(b != 0);   // b가 0이면 즉시 abort
    return a / b;
}
```

- **목적**: “여기서는 반드시 ~~여야 한다”는 **개발자 가정**을 런타임에 확인.
- **릴리스 빌드에서 끄기**: `-DNDEBUG`(No Debug) 정의 시 **assert가 제거**됩니다.

```bash
gcc -g -O0 main.c -o app         # 개발
gcc -DNDEBUG -O2 main.c -o app   # 릴리스(assert 무시)
```

### 1.2 커스텀 assert (메시지 포함)

```c
#include <stdio.h>
#include <stdlib.h>

#define ASSERT(cond, fmt, ...) do{ \
    if(!(cond)){ \
        fprintf(stderr,"[ASSERT] %s:%d %s(): " fmt "\n", \
                __FILE__, __LINE__, __func__, ##__VA_ARGS__); \
        abort(); \
    } \
}while(0)

// 사용
// ASSERT(n > 0, "n must be positive, got=%d", n);
```

> `assert`는 **버그를 고치는 도구가 아니라 버그를 조기 발견**하게 돕는 도구입니다.  
> 외부 입력 검증(유효성 체크)은 `assert`가 아니라 **정상 제어 흐름**(if/return)로 처리하세요.

---

## 2. 로그(printf 디버깅) — 찍을 거면 제대로 찍자

### 2.1 최소 템플릿: 파일/라인/함수 + 수준

```c
#include <stdio.h>
#include <time.h>

static inline const char* now_str(char *buf, size_t n){
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    strftime(buf, n, "%Y-%m-%d %H:%M:%S", &tm);
    return buf;
}

enum { LOG_DEBUG=0, LOG_INFO=1, LOG_WARN=2, LOG_ERROR=3 };
#ifndef LOG_LEVEL
#define LOG_LEVEL LOG_DEBUG   // 빌드나 환경에서 조정 가능
#endif

#define LOG(level, fmt, ...) do{ \
    if((level) >= LOG_LEVEL){ \
        char _ts[20]; \
        fprintf(stderr,"[%s][%c]%s:%d %s(): " fmt "\n", \
          now_str(_ts,sizeof _ts), "DIWE"[level], __FILE__, __LINE__, __func__, ##__VA_ARGS__); \
        fflush(stderr); \
    } \
}while(0)

#define LOGD(...) LOG(LOG_DEBUG, __VA_ARGS__)
#define LOGI(...) LOG(LOG_INFO , __VA_ARGS__)
#define LOGW(...) LOG(LOG_WARN , __VA_ARGS__)
#define LOGE(...) LOG(LOG_ERROR, __VA_ARGS__)
```

사용 예:

```c
LOGD("count=%d", count);
LOGE("open failed: %s", strerror(errno));
```

### 2.2 파일로 남기기 + 줄버퍼링

```c
FILE *g_log;

void log_init(const char *path){
    g_log = fopen(path, "a");
    if(!g_log){ perror("fopen log"); exit(1); }
    setvbuf(g_log, NULL, _IOLBF, 0); // line buffered
}

#define FLOG(level, fmt, ...) do{ \
    if((level) >= LOG_LEVEL && g_log){ \
        char _ts[20]; \
        fprintf(g_log,"[%s][%c]%s:%d %s(): " fmt "\n", \
           now_str(_ts,sizeof _ts), "DIWE"[level], __FILE__, __LINE__, __func__, ##__VA_ARGS__); \
    } \
}while(0)
```

> **실서비스**에서는 `stderr` + 파일 병행을 추천.  
> 멀티스레드라면 뮤텍스/`flockfile()`로 직렬화하거나, OS 로거(syslog 등)를 고려.

### 2.3 `errno`, `perror`, `strerror`

```c
#include <errno.h>
#include <string.h>

FILE *fp = fopen("data.txt","r");
if(!fp){
    LOGE("fopen failed: %s", strerror(errno)); // 또는 perror("fopen");
    /* 복구 or 종료 */
}
```

---

## 3. gdb — 디버깅은 라인별로, 데이터로

### 3.1 준비/실행

```bash
# 심볼 포함, 최적화 낮춤
gcc -g -O0 main.c -o app
gdb ./app
```

### 3.2 자주 쓰는 명령어

| 명령 | 의미 |
|---|---|
| `run [args]` | 프로그램 실행 |
| `start` | `main` 진입 직후 중단 |
| `break 42` / `b file.c:42` | 42행 브레이크 |
| `break func` | 함수 진입 시 중단 |
| `delete N` | N번 브레이크 삭제 |
| `next` (`n`) | 다음 줄(함수 **넘어감**) |
| `step` (`s`) | 다음 줄(함수 **들어감**) |
| `finish` | 현재 함수 빠져나가기 |
| `continue` (`c`) | 다음 브레이크까지 실행 |
| `print x` (`p x`) | 변수/식 출력 |
| `ptype var` | 타입 확인 |
| `display expr` | 스텝마다 expr 자동 출력 |
| `bt` | 백트레이스(호출 스택) |
| `frame N` | N번째 프레임으로 이동 |
| `info locals` | 현재 프레임 지역변수 |
| `watch var` | var 값 변경 감시(멈춤) |
| `quit` | 종료 |

### 3.3 실전 미니 세션

```gdb
(gdb) break main
(gdb) run --input=data.txt
(gdb) next
(gdb) print i
$1 = 7
(gdb) step               # 함수 안으로
(gdb) bt                 # 호출 스택
(gdb) info locals
(gdb) watch arr[2]       # arr[2] 바뀌면 멈춤
(gdb) continue
```

### 3.4 세그폴트(코어덤프) 분석

```bash
ulimit -c unlimited         # 코어덤프 허용
./app                       # 크래시 발생 → core 파일 생성(플랫폼마다 이름 다름)
gdb ./app core              # 크래시 지점으로 바로 이동
(gdb) bt
(gdb) frame 0
(gdb) list
```

> 최적화 빌드에서는 라인 매핑이 어긋날 수 있으니, **재현 시에는 -g -O0**로.

---

## 4. 메모리 버그 탐지: Sanitizer와 Valgrind

### 4.1 Address/Undefined Sanitizer (권장)

```bash
# GCC/Clang
gcc -g -O1 -fsanitize=address,undefined -fno-omit-frame-pointer main.c -o app
./app
```

- **ASan**: 오버플로우/Use-After-Free/이중해제 등 즉시 리포트.
- **UBSan**: 0으로 나눔/정수 오버플로/미정의 동작 등을 경고.

> **테스트 타겟에 기본 적용**해 두면, 초기 단계에서 결함을 대거 제거.

### 4.2 Valgrind (메모리 누수/잘못된 접근)

```bash
valgrind --leak-check=full --track-origins=yes ./app
```

- 누수 보고서, 잘못된 읽기/쓰기 위치, 최초 할당 스택 트레이스까지 제공.

---

## 5. 유닛 테스트 — `assert`로도 충분히 시작할 수 있다

### 5.1 초간단 수동 테스트

```c
#include <assert.h>
static int square(int x){ return x*x; }

int main(void){
    assert(square(2) == 4);
    assert(square(-3) == 9);
    printf("All tests passed.\n");
}
```

### 5.2 작은 테스트 러너(테이블 주도 + 실패 메시지)

{% raw %}
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct { int in, want; } Case;

static int square(int x){ return x*x; }

static int run_cases(const Case *cs, size_t n){
    int fails = 0;
    for(size_t i=0;i<n;i++){
        int got = square(cs[i].in);
        if(got != cs[i].want){
            fprintf(stderr,"FAIL: in=%d want=%d got=%d (idx=%zu)\n",
                    cs[i].in, cs[i].want, got, i);
            fails++;
        }
    }
    return fails;
}

int main(void){
    Case cs[] = {{0,0}, {1,1}, {2,4}, {-3,9}, {5,25}};
    int fails = run_cases(cs, sizeof cs/sizeof *cs);
    if(fails){ fprintf(stderr,"%d case(s) failed\n", fails); return 1; }
    puts("OK");
    return 0;
}
```
{% endraw %}

> 규모가 커지면 **CUnit/Check/Unity** 같은 프레임워크 도입을 고려.

---

## 6. 커버리지(gcov/lcov) — 테스트가 코드를 얼마나 덮었나

```bash
# 빌드
gcc -g -O0 --coverage main.c -o app
# 실행
./app
# 라인 커버리지 출력
gcov main.c
```

HTML 리포트(lcov 예):

```bash
lcov --capture --directory . --output-file coverage.info
genhtml coverage.info --output-directory cov_html
```

> **라인 커버리지**만 높아도 결함이 사라지는 것은 아닙니다.  
> 분기/에지 커버리지, 임계 경로 테스트를 함께 설계하세요.

---

## 7. 흔한 버그, 이렇게 잡는다

### 7.1 오프바이원(경계 초과)

```c
// 버그
for(int i=0;i<=n;i++) buf[i]=0; // n까지 쓰면 n+1개 씀

// 수정
for(int i=0;i<n;i++)  buf[i]=0;
```

- **대응**: 경계조건(빈/최대/음수) 케이스를 반드시 테스트에 포함.

### 7.2 해제 후 사용(Use-After-Free)

```c
char *p = malloc(10);
free(p);
*p = 'X';   // UAF

// 습관
free(p); p = NULL;
```

- **ASan/Valgrind**로 즉시 탐지.

### 7.3 정수 오버플로

```c
int len = a + b;        // a,b가 큰 값이면 overflow
char *p = malloc(len);  // 의도보다 작은 할당 → 오버런

// 방어: 넓은 타입/검증
size_t slen = (size_t)a + (size_t)b;
if (slen < (size_t)a) DIE("overflow");
char *p = malloc(slen);
```

- **UBSan**이 잡아줍니다.

---

## 8. gdb: 실전 패턴 3가지

### 8.1 “어디서 터졌나?” — 순간 캡처

1) **코어덤프 허용** → `ulimit -c unlimited`  
2) 크래시 재현 → core 생성  
3) `gdb ./app core`  
4) `bt`, `frame 0`, `info locals`로 즉시 원인 파악

### 8.2 “누가 값을 바꾸나?” — 워치포인트

```gdb
(gdb) break suspicious_func
(gdb) run
(gdb) watch shared_count
(gdb) continue
# shared_count 변경 시점에 중단 → backtrace로 범인 확인
```

### 8.3 “함수 호출 경로/빈도” — 조건부 브레이크/디스플레이

```gdb
(gdb) break compute if x<0
(gdb) commands
> silent
> printf "x=%d\n", x
> continue
> end
```

---

## 9. Makefile 스니펫 — 디버그/릴리스/산타이저/커버리지

```make
CC:=gcc
CFLAGS_DEBUG:=-g -O0 -Wall -Wextra -Wconversion
CFLAGS_ASAN:=-g -O1 -fsanitize=address,undefined -fno-omit-frame-pointer
CFLAGS_REL:=-O2 -DNDEBUG
CFLAGS_COV:=--coverage -g -O0

.PHONY: all debug asan rel cov clean
all: debug

debug: main.c
	$(CC) $(CFLAGS_DEBUG) $< -o app

asan: main.c
	$(CC) $(CFLAGS_ASAN) $< -o app_asan

rel: main.c
	$(CC) $(CFLAGS_REL) $< -o app_rel

cov: main.c
	$(CC) $(CFLAGS_COV) $< -o app_cov

clean:
	rm -f app app_asan app_rel app_cov *.gcno *.gcda *.gcov
```

---

## 10. 헬퍼: 바이너리/메모리 덤프(디버깅 보조)

```c
#include <stdio.h>
#include <ctype.h>

void hexdump(const void *data, size_t len){
    const unsigned char *p = data;
    for(size_t i=0;i<len;i+=16){
        printf("%08zx  ", i);
        for(size_t j=0;j<16;j++){
            if(i+j<len) printf("%02x ", p[i+j]); else printf("   ");
        }
        printf(" ");
        for(size_t j=0;j<16 && i+j<len;j++){
            unsigned char c = p[i+j];
            printf("%c", isprint(c)? c : '.');
        }
        printf("\n");
    }
}
```

---

## 11. 테스트 전략: 무엇을 언제 어떻게

| 상황 | 전략 |
|---|---|
| 순수 함수(입력→출력) | **테이블 주도 테스트** + 경계값(0, 음수, 최대) |
| 상태/IO | 임시 파일/가짜 입력, **의존성 주입**으로 고립 |
| 동시성 | 레이스 감지(ThreadSanitizer) 또는 구조적 잠금 검증 |
| 실패 경로 | 고의 실패(파일 없음/권한 없음/메모리 부족) 시나리오도 테스트 |
| 회귀 방지 | **재현 테스트**를 추가하고 CI에서 상시 실행 |

---

## 12. 체크리스트

- [ ] 디버그 빌드: `-g -O0 -Wall -Wextra -Werror?`  
- [ ] 로그: 파일/라인/함수/타임스탬프/레벨  
- [ ] 외부 입력: `errno`/오류 메시지 **반드시 기록**  
- [ ] gdb: 브레이크/워치/`bt`/`info locals`  
- [ ] Sanitizer: `-fsanitize=address,undefined` 상시 켜기(테스트 타겟)  
- [ ] Valgrind: 릴리스 전 메모리 점검  
- [ ] 커버리지: 핵심 모듈 80%+ 목표(수치 집착 금지, **중요 경로** 우선)  
- [ ] 경계조건/실패경로/희귀 케이스 포함  
- [ ] `assert`는 내부 가정용, 외부 입력 검증은 **정상 로직**으로

---

## 13. 마무리 요약

| 도구/기법 | 핵심 가치 |
|---|---|
| `assert/NDEBUG` | 개발 중 불변조건, 릴리스에서 제거 가능 |
| 로그(레벨/타임스탬프) | 재현 불가 버그도 **증거로 복원** |
| gdb | 라인별/프레임별 **현미경** |
| 코어덤프 | 크래시 시점의 **스냅샷** |
| Sanitizer | 메모리/UB를 **즉시 격발** |
| Valgrind | 누수/잘못된 접근의 **정적에 가까운 검출** |
| 커버리지 | 테스트 공백 파악, 회귀 방지의 나침반 |
| 소형 테스트 러너 | 간단/빠른 피드백 루프 |