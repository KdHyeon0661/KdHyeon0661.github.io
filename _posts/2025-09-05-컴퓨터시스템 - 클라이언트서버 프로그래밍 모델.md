---
layout: post
title: 컴퓨터시스템 - 클라이언트-서버 프로그래밍 모델
date: 2025-09-05 21:20:23 +0900
category: 컴퓨터시스템
---
# 클라이언트–서버 프로그래밍 모델 (Client–Server Programming Model)

## 0. 큰 그림: 요청–응답의 생애주기

```text
[Client App] --(Request)--> [LB/Proxy] --(Request)--> [Server]
    ^                                                    |
    |------------------(Response)------------------------|
```

- **클라이언트**: 사용자 인터페이스, API 호출, 연결·재시도·타임아웃 관리  
- **서버**: 수신/파싱/인증 → 비즈니스 로직 → 저장소/캐시 → 응답 생성  
- **경계**: 전송 계층(TCP/UDP/QUIC) + 응용 프로토콜(HTTP/WS/gRPC 등)

---

## 1. 프로토콜·패러다임 빠른 비교

| 계층 | 선택지 | 특징/용도 |
|---|---|---|
| 전송 | **TCP** | 연결 지향, 순서/무결성 보장, 대부분의 API/웹 서비스 기본 |
| 전송 | **UDP** | 비연결, 손실 허용, 딜레이 민감(게임/스트리밍/DNS) |
| 전송 | **QUIC(HTTP/3)** | UDP 기반, 커넥션 마이그레이션, 헤드오브라인 차단 완화, TLS 1.3 내장 |
| 응용 | **HTTP/1.1** | 요청/응답, Keep-Alive, 파이프라이닝 한계 |
| 응용 | **HTTP/2** | 하나의 연결에 **멀티플렉싱**, 서버 푸시(실무에선 제한적) |
| 응용 | **HTTP/3** | QUIC 위, 핸드셰이크·복구 지연 감소 |
| 응용 | **WebSocket** | 양방향 지속 채널 |
| 응용 | **gRPC** | HTTP/2 기반 바이너리 RPC(프로토버퍼), 스트리밍 우수 |

> **실무 팁**: 대다수 백엔드는 **HTTP/1.1/2** 표준 API + **Reverse Proxy(L7)** 조합이 운영/관측/보안 면에서 유리. 초저지연·모바일 핸드오버가 중요하면 **HTTP/3/QUIC** 고려.

---

## 2. 서버 아키텍처 패턴

| 패턴 | 설명 | 장단점/적용 |
|---|---|---|
| 단일 스레드(블로킹) | `accept`→`read`→`write` 직렬 | 간단/학습용. 동시성 낮음 |
| **Prefork/Prethread** | 미리 만든 프로세스/스레드가 `accept` | 격리 강함(프로세스)·구현 쉬움, 컨텍스트 스위치↑ |
| **Thread-per-connection** | 연결마다 스레드 | 구현 쉬움, 대규모 연결에서 스레드 폭증 |
| **Reactor(이벤트 루프)** | `epoll/kqueue` + 비동기 상태기계 | 커넥션 수↑, 단일 코어 병목 주의 |
| **Multi-reactor + Thread pool** | 코어별 루프, 워커풀 | 현대 리눅스 일반형. `SO_REUSEPORT`로 수평 확장 |
| **Proactor (`io_uring`)** | 커널 비동기 제출/완료 큐 | syscalls↓, 초고성능; 리눅스 5.10+ 권장, 학습 곡선↑ |

---

## 3. 소켓 API 핵심(UNIX/Linux, C)

### 3.1 서버(기본형)
```c
int s = socket(AF_INET6, SOCK_STREAM, 0);            // v6 우선
int yes = 1;
setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof yes);
struct sockaddr_in6 a = { .sin6_family=AF_INET6, .sin6_port=htons(9000) };
bind(s, (struct sockaddr*)&a, sizeof a);
listen(s, SOMAXCONN);                                 // 커널 상한
for (;;) {
  int c = accept(s, NULL, NULL);
  // read/write 후 close(c)
}
```

### 3.2 클라이언트(주소 해석 + 연결)
```c
struct addrinfo hints = { .ai_family = AF_UNSPEC, .ai_socktype = SOCK_STREAM };
struct addrinfo *res; getaddrinfo("example.com", "443", &hints, &res);
int fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
connect(fd, res->ai_addr, res->ai_addrlen);
```

### 3.3 유용한 옵션
- `TCP_NODELAY`: Nagle 비활성(지연 민감 API)  
- `SO_KEEPALIVE`: 장기 유휴 연결 탐지  
- `SO_RCVBUF/SO_SNDBUF`: 버퍼 조정(트래픽 패턴따라 실측)  
- `SO_REUSEPORT`: 멀티 리스너 코어 분산  
- `IPV6_V6ONLY`: v6 소켓 v4-mapped 거부 여부

---

## 4. 동기 vs 비동기 I/O

| 구분 | 블로킹 | 논블로킹 + 이벤트 |
|---|---|---|
| 모델 | `read/write` 대기 | `O_NONBLOCK` + `epoll`(LT/ET) |
| 장점 | 코드 단순 | 커넥션 수↑, 지연/스루풋 우수 |
| 주의 | 스레드 다수 필요 | 상태기계, **부분 I/O/`EAGAIN`** 루프 |

### `epoll` 기본 골격
```c
int ep = epoll_create1(0);
struct epoll_event ev = {.events=EPOLLIN|EPOLLOUT|EPOLLET, .data.fd=fd};
epoll_ctl(ep, EPOLL_CTL_ADD, fd, &ev);
for(;;){
  struct epoll_event es[256];
  int n = epoll_wait(ep, es, 256, -1);
  for(int i=0;i<n;i++){
    int fd = es[i].data.fd;
    if (es[i].events & EPOLLIN)  {/* read until EAGAIN */}
    if (es[i].events & EPOLLOUT) {/* flush pending writes */}
  }
}
```
- **ET(엣지 트리거)** 는 한 이벤트 당 **버퍼를 바닥날 때까지** 반복 읽기/쓰기 필수.  
- **LT(레벨 트리거)** 는 단순하지만 wakeup 빈도↑.

---

## 5. 메시지 프레이밍(응용 계층의 핵심)

| 방식 | 설명 | 장단점/예시 |
|---|---|---|
| 고정 길이 | 헤더/본문이 고정 | 단순, 유연성↓ |
| 구분자 | `\n`, `\r\n\r\n` 등 | 텍스트 프로토콜(HTTP/SMTP 등) |
| 길이 프리픽스 | 4바이트 길이 + 본문 | 바이너리 일반형(Protobuf/TLV) |
| 청크(스트리밍) | 크기-데이터 반복 | HTTP/1.1 chunked, 대용량 스트림 |

**길이 프리픽스 예**
```c
uint32_t len = htonl(payload_len);
writen(fd, &len, 4);
writen(fd, payload, payload_len);
```

---

## 6. 견고한 I/O: 부분 I/O/`EINTR` 대처(RIO 패턴)

```c
ssize_t readn(int fd, void *buf, size_t n){
  size_t left=n; char *p=buf;
  while(left){
    ssize_t r=read(fd,p,left);
    if(r>0){ left-=r; p+=r; }
    else if(r==0) break;
    else if(errno==EINTR) continue;
    else if(errno==EAGAIN||errno==EWOULDBLOCK) break; // 논블로킹
    else return -1;
  } return (ssize_t)(n-left);
}
ssize_t writen(int fd,const void *buf,size_t n){
  size_t left=n; const char*p=buf;
  while(left){
    ssize_t w=write(fd,p,left);
    if(w>0){ left-=w; p+=w; }
    else if(w<0 && errno==EINTR) continue;
    else if(w<0 && (errno==EAGAIN||errno==EWOULDBLOCK)) return (ssize_t)(n-left);
    else return -1;
  } return (ssize_t)n;
}
```

---

## 7. 예제 1 — 스레드 풀 에코 서버(블로킹 I/O)

> 학습/내부망에 충분. 외부 대규모 트래픽은 `epoll`/멀티리액터 권장.

```c
// build: gcc -O2 -pthread server_threadpool.c -o tp && ./tp
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

#define PORT 9000
#define NWORK 8
#define QMAX  1024

static int q[QMAX], qh, qt;
static pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t  cv = PTHREAD_COND_INITIALIZER;

void *worker(void* _){
  for(;;){
    pthread_mutex_lock(&m);
    while(qh==qt) pthread_cond_wait(&cv,&m);
    int c = q[qt++ % QMAX];
    pthread_mutex_unlock(&m);

    char buf[8192];
    ssize_t n = read(c, buf, sizeof buf);
    if (n > 0) write(c, buf, (size_t)n);
    close(c);
  }
  return NULL;
}

int main(){
  int s = socket(AF_INET6, SOCK_STREAM, 0);
  int yes=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof yes);
  struct sockaddr_in6 a={0}; a.sin6_family=AF_INET6; a.sin6_port=htons(PORT);
  bind(s,(struct sockaddr*)&a,sizeof a); listen(s,1024);

  pthread_t th[NWORK];
  for(int i=0;i<NWORK;i++) pthread_create(&th[i],NULL,worker,NULL);

  for(;;){
    int c = accept(s,NULL,NULL);
    pthread_mutex_lock(&m);
    q[qh++ % QMAX] = c;
    pthread_cond_signal(&cv);
    pthread_mutex_unlock(&m);
  }
}
```

---

## 8. 예제 2 — `epoll` 기반(논블로킹) 에코 서버 스켈레톤

```c
// build: gcc -O2 ep_echo.c -o ep_echo
#include <sys/epoll.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

static void nb(int fd){ int f=fcntl(fd,F_GETFL); fcntl(fd,F_SETFL,f|O_NONBLOCK); }

int main(){
  int s = socket(AF_INET6, SOCK_STREAM, 0);
  int yes=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof yes);
  struct sockaddr_in6 a={0}; a.sin6_family=AF_INET6; a.sin6_port=htons(9001);
  bind(s,(struct sockaddr*)&a,sizeof a); listen(s, 4096); nb(s);

  int ep = epoll_create1(0);
  struct epoll_event ev={.events=EPOLLIN, .data.fd=s};
  epoll_ctl(ep, EPOLL_CTL_ADD, s, &ev);

  for(;;){
    struct epoll_event es[512];
    int n = epoll_wait(ep, es, 512, -1);
    for(int i=0;i<n;i++){
      int fd = es[i].data.fd;
      if (fd==s){ // accept loop
        for(;;){
          int c = accept(s, NULL, NULL);
          if (c<0){ if(errno==EAGAIN) break; else continue; }
          nb(c);
          struct epoll_event ec={.events=EPOLLIN|EPOLLET, .data.fd=c};
          epoll_ctl(ep, EPOLL_CTL_ADD, c, &ec);
        }
      } else if (es[i].events & EPOLLIN){
        for(;;){
          char b[8192];
          ssize_t r = read(fd, b, sizeof b);
          if (r>0){
            ssize_t w=0; while(w<r){ ssize_t k=write(fd,b+w,(size_t)(r-w));
              if(k>0) w+=k; else if(errno==EAGAIN) break; else { close(fd); break; }}
          } else if (r==0){ close(fd); break; }
          else if (errno==EAGAIN) break;
          else { close(fd); break; }
        }
      }
    }
  }
}
```

---

## 9. 예제 3 — HTTP/1.1 미니 서버(정적 “Hello”)

```c
// build: gcc -O2 http1_hello.c -o http_hello
// curl -v http://127.0.0.1:8080/
#include <netinet/in.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(){
  int s = socket(AF_INET, SOCK_STREAM, 0);
  int yes=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof yes);
  struct sockaddr_in a={0}; a.sin_family=AF_INET; a.sin_port=htons(8080); a.sin_addr.s_addr=htonl(INADDR_ANY);
  bind(s,(struct sockaddr*)&a,sizeof a); listen(s,1024);
  for(;;){
    int c = accept(s,NULL,NULL);
    char req[4096]; read(c, req, sizeof req); // 데모용 단순 수신
    const char* body="Hello, world\n";
    char hdr[256];
    int n = snprintf(hdr,sizeof hdr,"HTTP/1.1 200 OK\r\nContent-Length: %zu\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n", strlen(body));
    write(c, hdr, (size_t)n); write(c, body, strlen(body));
    close(c);
  }
}
```

---

## 10. 신뢰성: 재시도·아이들포턴시·데드라인·서킷브레이커

- **재시도**: 네트워크·서버 단절 시 지수 백오프(예: 100ms×2^k, Jitter)  
- **아이들포턴시(idempotency)**: 재시도로 **중복효과 방지**(PUT/GET은 보통 안전, POST는 **Idempotency-Key** 적용)  
- **데드라인/타임아웃**: **전체 요청 마감 시간**을 하위 RPC에 전파  
- **서킷 브레이커**: 오류율·지연이 임계 초과 시 단락(open) → 반쯤 회복 시 탐침(half-open)

---

## 11. 보안: TLS/mTLS·인증·권한·경계

- **TLS 1.2/1.3**: 서버 인증서, **HSTS**, 최신 암호군  
- **mTLS**: 내부 마이크로서비스 상호 인증  
- **OAuth2/OIDC + JWT**: 사용자/서비스 토큰  
- **입력 검증**: 크기 상한, 형식 스키마(예: JSON Schema), 압축폭탄 금지  
- **레이트 리밋**: 토큰 버킷/리키 버킷. API 키·IP·주체별 차등

---

## 12. 운영 관측성(Observability)

- **구조적 로그**(JSON): `ts, level, trace_id, span_id, method, path, status, latency_ms, bytes_in/out`  
- **메트릭**: RED(요청Rate·오류Error·지연Duration) / USE(자원Util·Saturation·Errors)  
- **트레이싱**: 분산 추적 헤더(예: W3C Trace Context), **샘플링** 전략

---

## 13. 성능·네트워크 이론 포인트

- **Little의 법칙**: 큐잉 시스템에서  
  $$L = \lambda \cdot W$$  
  (동시 처리 중인 평균 수 = 도착률 × 평균 지연)
- **대역폭–지연 곱(BDP)**:  
  $$\text{BDP} = \text{Bandwidth} \times \text{RTT}$$  
  긴 RTT/고대역 채널에서 윈도 크기/버퍼가 BDP 이상 필요.
- **TCP 옵션**: `TCP_NODELAY`(작은 요청 지연↓), `TCP_CORK`(대청크 모아쓰기)  
- **제로카피**: 파일→소켓 **`sendfile`**, 파일↔파일 **`copy_file_range`**  
- **현대 Linux**: 초고성능이면 **`io_uring`(liburing)** 고려

---

## 14. 상태(세션)와 스케일아웃

- **무상태(Stateless)** 서버 + **외부 세션 저장소**(Redis 등) → 수평 확장/롤링 배포 용이  
- **로드밸런싱**: L4(연결 라운드로빈/가중치) vs L7(경로/헤더 기반, WAF, 캐시)  
- **일관 해시**(Consistent Hashing): 캐시 샤딩·세션 스티키

---

## 15. 테스트·벤치마킹·배포

- **부하 도구**: `wrk`, `vegeta`, `hey`  
- **헬스체크**: liveness/readiness 엔드포인트  
- **배포**: 롤링/카나리/블루-그린, 자동 롤백  
- **systemd**: 서비스 유닛, `Restart=always`, 제한 `LimitNOFILE`

---

## 16. 클라이언트: 논블로킹 연결 + 타임아웃 스니펫

```c
#include <fcntl.h>
#include <poll.h>

int connect_with_timeout(int fd, const struct sockaddr*sa, socklen_t slen, int ms){
  int fl=fcntl(fd,F_GETFL); fcntl(fd,F_SETFL,fl|O_NONBLOCK);
  int r=connect(fd,sa,slen);
  if (r==0) return 0;
  if (errno!=EINPROGRESS) return -1;
  struct pollfd p={.fd=fd,.events=POLLOUT};
  r=poll(&p,1,ms);
  if (r==1 && (p.revents&POLLOUT)){
    int err=0; socklen_t len=sizeof err;
    getsockopt(fd,SOL_SOCKET,SO_ERROR,&err,&len);
    return err==0?0:-1;
  }
  return -1; // timeout or error
}
```

---

## 17. 체크리스트(현장용)

- [ ] **프레이밍**: 고정/구분자/길이/청크 중 선택·문서화  
- [ ] **I/O 모델**: 블로킹(스레드풀) vs 논블로킹(`epoll`/`io_uring`)  
- [ ] **부분 I/O** 처리: `readn/writen` 또는 RIO  
- [ ] **타임아웃/데드라인**: 클→서버 체인 전파, 재시도 전략(지수+Jitter)  
- [ ] **아이들포턴시**: 재시도 안전성, 키 도입  
- [ ] **TLS/mTLS**: 최신 프로토콜·암호군, 키 로테이션  
- [ ] **레이트 리밋/쿼터**: 토큰 버킷, 스로틀링 응답 코드(429)  
- [ ] **관측성**: 구조 로그·메트릭·트레이싱, 샘플링  
- [ ] **배포**: 롤링+헬스체크, **LimitNOFILE**, `SO_REUSEPORT`  
- [ ] **커널 튜닝**: `somaxconn`, 버퍼, RFS/NUMA 핀 고찰(실측 기반)

---

## 18. 확장: gRPC/HTTP2 스트리밍(개념 스케치)

- 스트리밍 RPC(서버/클라이언트/양방향)로 장기 연결 처리  
- 메시지 프레이밍은 프로토버퍼 길이 프리픽스, 흐름제어는 HTTP/2 윈도우 프레임  
- 브라우저 직접 호출은 **gRPC-Web**(프록시 변환) 고려

---

## 19. 마무리

클라이언트–서버는 **역할 분리**와 **계약(API·프로토콜)** 위에서 움직인다. 구현은 **소켓 + 견고한 I/O**라는 기초 위에, **이벤트 루프/스레드풀/오프로딩(제로카피)** 을 적절히 조합한다. 운영 단계에서는 **신뢰성(재시도/데드라인/서킷브레이커)**, **보안(TLS/mTLS/OAuth2)**, **관측성(RED/USE + 트레이싱)**, **배포/튜닝**이 품질을 좌우한다. 이 문서의 체크리스트와 스니펫을 템플릿으로 삼아, 요구사항(지연/처리량/내구성/비용)에 맞는 **가장 단순하면서도 충분한** 설계를 선택하라.