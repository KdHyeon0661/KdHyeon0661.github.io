---
layout: post
title: 컴퓨터시스템 - 클라이언트-서버 프로그래밍 모델
date: 2025-09-05 21:20:23 +0900
category: 컴퓨터시스템
---
# 클라이언트-서버 프로그래밍 모델(Client–Server Programming Model)

## 1. 개념

**클라이언트-서버 프로그래밍 모델**은 네트워크 상에서 서비스를 요청(Request)하는 **클라이언트(Client)**와, 요청을 처리하고 응답(Response)을 제공하는 **서버(Server)** 간의 상호작용을 기반으로 하는 소프트웨어 아키텍처 모델입니다.

- **클라이언트**: 사용자 인터페이스를 제공하고, 서버에 요청을 보내며, 응답을 받아 처리합니다.
- **서버**: 요청을 수신하고, 필요한 작업을 수행하며, 결과를 클라이언트에 반환합니다.

이 모델은 웹 서비스, 데이터베이스 접근, 파일 전송, 채팅 애플리케이션 등 대부분의 네트워크 애플리케이션에서 사용됩니다.

---

## 2. 기본 구조

```plaintext
[ Client ] <--Request--  Network  --Response--> [ Server ]
```

- **Request**: 데이터 조회, 명령 실행, 파일 다운로드 등의 요청
- **Response**: 요청 처리 결과, 오류 메시지, 상태 코드 등

---

## 3. 주요 특징

1. **역할 분리**
   - 클라이언트는 주로 사용자 경험(UI/UX)과 요청 전달 담당
   - 서버는 데이터 처리, 저장, 인증, 비즈니스 로직 담당

2. **네트워크 기반**
   - TCP, UDP, HTTP, WebSocket 등 다양한 전송 프로토콜 사용 가능

3. **확장성**
   - 서버를 확장(Scale up/out)하거나 클라이언트를 다수 연결 가능

4. **상호 독립성**
   - 클라이언트와 서버는 서로 독립적으로 개발·배포 가능
   - API 계약(Interface)이 유지되는 한 버전 업그레이드 가능

---

## 4. 동작 흐름(예: TCP 기반)

1. **서버 초기화**
   - 소켓 생성 → IP/포트 바인딩 → 연결 대기(listen)

2. **클라이언트 연결**
   - 소켓 생성 → 서버 IP/포트로 연결(connect)

3. **데이터 송수신**
   - 클라이언트 → 서버: 요청 데이터 전송
   - 서버 → 클라이언트: 처리 후 응답 데이터 전송

4. **연결 종료**
   - 클라이언트 또는 서버가 close 호출

---

## 5. 동기 vs 비동기 모델

| 구분 | 동기(Synchronous) | 비동기(Asynchronous) |
|------|-------------------|----------------------|
| 처리 방식 | 요청 → 대기 → 응답 | 요청 후 다른 작업 수행 가능 |
| 장점 | 구현 간단, 직관적 | 동시성·성능 우수 |
| 단점 | 대기 시간 길면 전체 지연 | 구현 복잡, 디버깅 어려움 |
| 예시 | 블로킹 TCP 소켓 | 논블로킹 소켓, epoll, select |

---

## 6. 서버 유형

1. **단일 스레드 서버**
   - 한 번에 하나의 요청만 처리
   - 구현 간단하지만 확장성 낮음

2. **멀티스레드/멀티프로세스 서버**
   - 요청마다 별도의 스레드/프로세스 생성
   - 동시 처리 가능하지만 스레드/프로세스 오버헤드 존재

3. **이벤트 기반 서버**
   - epoll/select/kqueue 기반 비동기 I/O
   - 소켓 이벤트를 감지해 처리, 높은 동시성 지원

---

## 7. 통신 프로토콜 선택

- **TCP**: 연결 지향, 신뢰성 보장, 순서 보장 → 채팅, 파일 전송, 웹 서비스
- **UDP**: 비연결, 신뢰성 낮지만 빠름 → 실시간 게임, 스트리밍
- **HTTP/HTTPS**: 웹 애플리케이션의 표준
- **WebSocket**: 양방향 실시간 통신

---

## 8. 클라이언트-서버 예제(TCP, C 언어)

### 서버 코드 (간단한 에코 서버)
```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 9000

int main() {
    int serv_sock = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in serv_addr = {0};
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(PORT);

    bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
    listen(serv_sock, 5);

    printf("Server listening on port %d...\n", PORT);

    while (1) {
        int clnt_sock;
        struct sockaddr_in clnt_addr;
        socklen_t clnt_len = sizeof(clnt_addr);
        clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_len);

        char buf[1024];
        ssize_t n = read(clnt_sock, buf, sizeof(buf));
        write(clnt_sock, buf, n); // Echo back
        close(clnt_sock);
    }
    close(serv_sock);
}
```

### 클라이언트 코드 (서버로 메시지 전송)
```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 9000

int main() {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in serv_addr = {0};
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);
    inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr);

    connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

    char *msg = "Hello Server!";
    write(sock, msg, strlen(msg));

    char buf[1024];
    ssize_t n = read(sock, buf, sizeof(buf));
    buf[n] = '\0';
    printf("Received: %s\n", buf);

    close(sock);
}
```

---

## 9. 장단점

### 장점
- 역할 분리로 유지보수·확장 용이
- 다중 클라이언트 지원 가능
- 서버 보안/관리 집중 가능

### 단점
- 네트워크 지연(latency) 발생 가능
- 서버에 과부하 시 전체 서비스 영향
- 서버 장애 시 모든 클라이언트에 영향

---

## 10. 성능 및 확장 고려사항

- **로드밸런싱**: 여러 서버에 요청 분산
- **캐싱**: 반복 요청 응답 속도 향상
- **비동기 I/O**: 높은 동시성 처리
- **보안**: TLS/SSL, 인증, 권한 관리
- **모니터링**: 로그, 지표, 알림 시스템 구축

---

## 11. 결론

클라이언트-서버 모델은 현대 네트워크 애플리케이션의 핵심 구조로, 프로토콜 선택, 서버 설계 패턴, I/O 모델, 확장성·보안 전략까지 종합적으로 고려해야 합니다. 특히, **프로토콜 특성과 I/O 모델의 선택**은 애플리케이션 성능과 안정성에 큰 영향을 미칩니다.