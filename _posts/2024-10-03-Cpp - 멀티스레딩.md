---
layout: post
title: C++ - 멀티스레딩
date: 2024-10-03 19:20:23 +0900
category: Cpp
---
# 멀티스레딩과 동기화 기초 정리

## 0. 빠른 개요

- 스레드: `std::thread`, `join()`, `detach()`, `joinable()`, 람다·가변인자 전달
- 락: `std::mutex`, `std::lock_guard`, `std::unique_lock`, `std::scoped_lock`, `std::try_lock`, `std::adopt_lock`
- 조건 변수: `std::condition_variable`(CV), **항상** “predicate + while” 패턴
- 원자 연산: `std::atomic`, `fetch_add`, CAS, 메모리 오더(`memory_order_seq_cst` 등)
- 비동기: `std::async`, `std::future`, `std::promise`/`std::packaged_task`
- 취소/정지: C++20 `std::jthread` + `stop_token` (협조적 취소)
- 병목과 한계: Amdahl’s Law, false sharing, I/O 바운드 vs CPU 바운드
- 실전: 생산자-소비자, 쓰레드 안전 로깅, 간단 스레드풀

---

## 1. `std::thread`: 스레드 생성과 종료

### 1.1 가장 단순한 생성

```cpp
#include <iostream>
#include <thread>

void task() { std::cout << "스레드에서 실행 중\n"; }

int main() {
    std::thread t(task);   // 새 스레드 시작
    t.join();              // 메인 스레드가 t의 종료를 기다림
}
```

### 1.2 람다 캡처와 인자 전달

```cpp
#include <thread>
#include <vector>
#include <iostream>

int main() {
    int n = 3;
    std::vector<std::thread> threads;
    threads.reserve(n);

    for (int i = 0; i < n; ++i) {
        threads.emplace_back([i] { std::cout << "hello from " << i << "\n"; });
    }
    for (auto& th : threads) th.join();
}
```

- **주의**: 람다에서 **참조 캡처**한 대상이 스레드보다 먼저 소멸하면 미정의 동작(UB).  
  안전하게 하려면 값 캡처 또는 **수명 보장**이 필요합니다.

### 1.3 `join()` vs `detach()`

- `join()`: **필수적**. 스레드 종료를 기다리며 **자원 회수**.
- `detach()`: 스레드를 **백그라운드로 떼어냄**. 주로 서비스/데몬성 작업에서.  
  남용하면 **프로세스 종료 시 미정의 동작**이나 **연결 해제된 스레드**가 남을 수 있음.

```cpp
std::thread t([]{ /* 긴 작업 */ });
// t.detach(); // 정말 필요한 경우만
if (t.joinable()) t.join();
```

---

## 2. 상호 배제: `std::mutex`와 RAII 락

### 2.1 raw lock/unlock (지양)

```cpp
#include <mutex>
std::mutex m;
int counter = 0;

void bad() {
    m.lock();
    ++counter;
    m.unlock();  // 예외 발생 시 unlock 미실행 → 데드락 위험
}
```

### 2.2 `std::lock_guard`: 가장 간단/안전한 RAII

```cpp
#include <mutex>
std::mutex m;
int counter = 0;

void good_basic() {
    std::lock_guard<std::mutex> lk(m); // 생성자에서 lock
    ++counter;
} // 소멸자에서 자동 unlock
```

### 2.3 `std::unique_lock`: 유연함(지연 잠금, 해제/재잠금, CV 연계)

```cpp
#include <mutex>
std::mutex m;

void flexible() {
    std::unique_lock<std::mutex> lk(m, std::defer_lock); // 일단 잠그지 않음
    // ... 준비 작업 ...
    lk.lock();  // 적절한 시점에 잠금
    // ... 임계 구역 ...
    lk.unlock(); // 중간 해제
    // ... 다른 작업 ...
    lk.lock();   // 다시 잠금
}
```

### 2.4 여러 락을 한 번에: `std::scoped_lock`/`std::lock`

```cpp
#include <mutex>
std::mutex m1, m2;

// 데드락 위험한 코드 (락 순서 불일치)
void deadlockish() {
    std::lock_guard<std::mutex> a(m1);
    std::lock_guard<std::mutex> b(m2); // 다른 스레드가 m2->m1 순서로 잡으면 교착
}

// 안전한 패턴
void safe() {
    std::scoped_lock lk(m1, m2); // 교착 없이 둘 다 잠금
    // ... 임계 구역 ...
}
```

또는 수동으로:

```cpp
std::unique_lock<std::mutex> a(m1, std::defer_lock);
std::unique_lock<std::mutex> b(m2, std::defer_lock);
std::lock(a, b);  // 교착 없는 동시 잠금
```

---

## 3. 조건 변수: 대기/통지 패턴 (생산자–소비자 기본기)

### 3.1 핵심 규칙

- **항상** `std::unique_lock`과 함께 사용
- **항상** `wait(lock, predicate)` 또는 `while(!pred) wait(lock)` 사용(스퍼리어스 웨이크업 대비)
- `notify_one()` vs `notify_all()` 의도적으로 선택

### 3.2 예제: 안전한 큐

```cpp
#include <condition_variable>
#include <mutex>
#include <queue>
#include <optional>

std::mutex mx;
std::condition_variable cv;
std::queue<int> q;
bool done = false; // 생산 종료 플래그

void producer() {
    for (int i = 0; i < 10; ++i) {
        {
            std::lock_guard<std::mutex> lk(mx);
            q.push(i);
        }
        cv.notify_one(); // 대기 중 소비자 깨우기
    }
    { std::lock_guard<std::mutex> lk(mx); done = true; }
    cv.notify_all(); // 모두 깨워 종료 전파
}

std::optional<int> consume_one() {
    std::unique_lock<std::mutex> lk(mx);
    cv.wait(lk, []{ return !q.empty() || done; }); // 스퍼리어스 웨이크업 방지
    if (!q.empty()) {
        int v = q.front(); q.pop();
        return v;
    }
    return std::nullopt; // done && empty
}
```

---

## 4. 여러 스레드에서 안전하게 출력하기

### 4.1 뮤텍스로 직렬화

```cpp
#include <mutex>
#include <iostream>

std::mutex print_mx;
void print_line(const std::string& s) {
    std::lock_guard<std::mutex> lk(print_mx);
    std::cout << s << "\n";
}
```

### 4.2 C++20 `std::osyncstream` (줄 단위 자동 동기화)

```cpp
#include <syncstream>
#include <iostream>

void print_line_sync(const std::string& s) {
    std::osyncstream(std::cout) << s << "\n";
}
```

---

## 5. `std::async` / `std::future` / `std::promise`

### 5.1 `std::async`: 간단한 비동기 실행

```cpp
#include <future>
#include <iostream>

int compute() { return 42; }

int main() {
    std::future<int> fut = std::async(std::launch::async, compute);
    std::cout << fut.get() << "\n"; // 결과 대기 + 수령
}
```

- 정책: `std::launch::async`(스레드 생성) vs `std::launch::deferred`(지연 실행; `get()/wait()`까지 미실행)
- 정책 생략 시 구현이 선택 (플랫폼/라이브러리 의존)

### 5.2 `std::promise`/`std::packaged_task`

```cpp
#include <future>
#include <thread>

int main() {
    std::promise<int> p;
    std::future<int> f = p.get_future();

    std::thread worker([pr = std::move(p)]() mutable {
        // 긴 계산 ...
        pr.set_value(123);
    });

    int v = f.get(); // 123
    worker.join();
}
```

---

## 6. 원자 연산과 메모리 모델: `std::atomic`

### 6.1 기본 원자 변수

```cpp
#include <atomic>
std::atomic<int> ai{0};

void increment() { ai.fetch_add(1, std::memory_order_relaxed); }
```

- `fetch_add`, `fetch_sub`, `compare_exchange_strong/weak`, `load`, `store`
- 기본 메모리 오더: `memory_order_seq_cst`(가장 강함).  
  성능 필요시 `relaxed/acquire/release/acq_rel`를 신중히 고려.

### 6.2 CAS(Compare-And-Swap) 패턴

```cpp
#include <atomic>

std::atomic<int> value{0};

void set_if_zero(int x) {
    int expected = 0;
    // expected != 0이면 expected가 실제 값으로 업데이트됨
    value.compare_exchange_strong(expected, x);
}
```

### 6.3 happens-before와 메모리 오더 개념

- **release → acquire**: 한 스레드가 `store(..., release)`로 기록한 것은  
  다른 스레드가 해당 원자에 대해 `load(..., acquire)`로 읽을 때 **순서 보장**.
- `relaxed`는 **원자성만** 보장, **재배치/순서** 보장 없음.

---

## 7. 병렬화의 한계: Amdahl’s Law & False Sharing

### 7.1 암달의 법칙

$$
S(N) = \frac{1}{(1 - P) + \frac{P}{N}}
$$

- \( P \): 병렬화 가능한 비율, \( N \): 스레드 수, \( S(N) \): 이론적 가속비
- 순차 비율 \( (1-P) \) 이 0이 아니면, 스레드를 무한히 늘려도 상한 존재.

### 7.2 False Sharing (거짓 공유)

- 서로 **다른 변수를 다른 스레드**가 사용하지만, 같은 캐시라인에 있어 **캐시 invalidation** 폭증 → 성능 급락
- 해결: 패딩/정렬

```cpp
#include <cstddef>
#include <new>

struct alignas(64) PaddedCounter {
    std::atomic<long long> v{0};
    char pad[64 - sizeof(std::atomic<long long>)]; // 플랫폼에 맞게 조정
};
```

---

## 8. 데드락/라이블락/기아: 진단과 회피

- **데드락**: 서로 상대 락을 기다려 **영원히 정지**
  - 회피: **고정된 락 순서**, `std::scoped_lock`/`std::lock`
- **라이블락**: 계속 상태가 바뀌지만 **진전 없음** (ex. 서로 양보만)
- **기아**: 특정 스레드가 우선순위/스케줄링 탓에 **기회 상실**

### 체크리스트

1. 락 **순서**를 명확히 정하라.
2. 한 함수에서 **여러 락을 잡지 말라**(가능하면 구조 리팩토링).
3. 락 범위를 **최소화**한다(임계 구역 축소).
4. `try_lock`로 타임아웃/백오프 전략 도입.

---

## 9. 스레드 취소/정지: C++20 `std::jthread` + `stop_token`

```cpp
#include <thread>
#include <stop_token>
#include <chrono>
#include <iostream>

void work(std::stop_token st) {
    while (!st.stop_requested()) {
        // 작업...
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
    std::cout << "stopped\n";
}

int main() {
    std::jthread jt(work); // 자동 join
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    jt.request_stop();     // 협조적 취소
}
```

- `std::jthread`는 소멸 시 `join()` 자동 호출.
- 장시간 루프는 **정지점**에서 `stop_requested()`를 체크해 협조적으로 종료.

---

## 10. 출력/로그 실전: 스레드 안전 로깅

```cpp
#include <mutex>
#include <fstream>
#include <string>

class Logger {
    std::mutex mx_;
    std::ofstream out_;
public:
    explicit Logger(const std::string& path) : out_(path, std::ios::app) {}
    void log(const std::string& line) {
        std::lock_guard<std::mutex> lk(mx_);
        out_ << line << '\n';
        out_.flush();
    }
};
```

- 단일 뮤텍스로 직렬화. 고성능이 필요하면 **락프리 큐 + 배경 쓰기 스레드**.

---

## 11. 실전 예제: 생산자–소비자(멀티)

```cpp
#include <condition_variable>
#include <mutex>
#include <queue>
#include <thread>
#include <vector>
#include <iostream>

class WorkQueue {
    std::mutex mx_;
    std::condition_variable cv_;
    std::queue<int> q_;
    bool done_ = false;
public:
    void push(int v) {
        {
            std::lock_guard<std::mutex> lk(mx_);
            q_.push(v);
        }
        cv_.notify_one();
    }
    void done() {
        {
            std::lock_guard<std::mutex> lk(mx_);
            done_ = true;
        }
        cv_.notify_all();
    }
    bool pop(int& out) {
        std::unique_lock<std::mutex> lk(mx_);
        cv_.wait(lk, [&]{ return !q_.empty() || done_; });
        if (q_.empty()) return false;
        out = q_.front(); q_.pop();
        return true;
    }
};

int main() {
    WorkQueue wq;
    std::vector<std::thread> workers;
    for (int i = 0; i < 4; ++i) {
        workers.emplace_back([&]{
            int x;
            while (wq.pop(x)) {
                // 작업 처리
                std::cout << "consume " << x << "\n";
            }
        });
    }
    for (int i = 0; i < 10; ++i) wq.push(i);
    wq.done();
    for (auto& th : workers) th.join();
}
```

---

## 12. 간단 스레드풀(학습용)

```cpp
#include <vector>
#include <queue>
#include <thread>
#include <condition_variable>
#include <functional>
#include <atomic>

class ThreadPool {
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex mx_;
    std::condition_variable cv_;
    std::atomic<bool> stop_{false};

    void worker() {
        while (!stop_) {
            std::function<void()> job;
            {
                std::unique_lock<std::mutex> lk(mx_);
                cv_.wait(lk, [&]{ return stop_ || !tasks_.empty(); });
                if (stop_ && tasks_.empty()) return;
                job = std::move(tasks_.front()); tasks_.pop();
            }
            job();
        }
    }

public:
    explicit ThreadPool(size_t n) {
        for (size_t i = 0; i < n; ++i) workers_.emplace_back([this]{ worker(); });
    }
    ~ThreadPool() {
        {
            std::lock_guard<std::mutex> lk(mx_);
            stop_ = true;
        }
        cv_.notify_all();
        for (auto& w : workers_) if (w.joinable()) w.join();
    }

    template <class F, class... Args>
    void enqueue(F&& f, Args&&... args) {
        {
            std::lock_guard<std::mutex> lk(mx_);
            tasks_.emplace([fn = std::forward<F>(f), ... as = std::forward<Args>(args)]() mutable {
                fn(std::move(as)...);
            });
        }
        cv_.notify_one();
    }
};
```

---

## 13. 성능/안전 체크리스트

1. **락 범위 최소화**: 임계 구역 안에서 I/O/할당을 피하라.  
2. **컨텐션 줄이기**: 분할락(sharding), RW 락(`std::shared_mutex`) 고려.  
   - 다수가 읽고 소수만 쓸 때: `std::shared_mutex` + `std::shared_lock`  
3. **원자/락 선택**: 단순 카운터는 `std::atomic`이 더 쉽고 빠름.  
4. **false sharing 회피**: 데이터 패딩/정렬(`alignas(64)`)로 캐시라인 분리.  
5. **정지 가능 설계**: 긴 루프엔 `stop_token` 체크 포인트.  
6. **TSAN**: ThreadSanitizer로 데이터 레이스 탐지.  
7. **예외 안전**: RAII로 lock/future/file 자동 해제.  
8. **정확한 모델**: CV는 항상 “predicate + while” 패턴.  
9. **락 순서 고정**: 다중락이 필요하면 `std::scoped_lock` 또는 `std::lock`.  
10. **메모리 오더**: 기본은 `seq_cst`. 성능 최적화가 **증명 가능**할 때만 완화.

---

## 14. 자주 하는 실수와 해결

- **문제**: `detach()` 남용 → 프로세스 종료 시 미정의 동작  
  **해결**: 가급적 `join()`; 백그라운드는 종료 시그널/정지 토큰 설계
- **문제**: CV `wait()`에 if 사용 → 스퍼리어스 웨이크업으로 빈 큐 pop  
  **해결**: `while (조건 아님) wait();` 또는 `wait(lock, pred)`
- **문제**: 락 잡고 긴 I/O → 전체 성능 하락  
  **해결**: 데이터만 빠르게 복사/이동 후 락 해제하고 I/O 수행
- **문제**: 람다에서 **참조 캡처** 대상이 먼저 소멸  
  **해결**: 값 캡처 또는 수명 보장(스레드 종료 관리)

---

## 15. 정리 표

| 주제 | 핵심 도구 | 요점 |
|---|---|---|
| 스레드 생성/종료 | `std::thread`, `join()` | `detach()`는 신중히 |
| 락(RAII) | `lock_guard`, `unique_lock`, `scoped_lock` | 예외 안전, 다중락은 `scoped_lock` |
| 조건 변수 | `condition_variable` | `predicate + while`, `notify_one/all` |
| 원자 | `std::atomic`, CAS | 필요 시 메모리 오더 |
| 비동기 | `async/future/promise` | 정책(즉시 vs 지연) 이해 |
| 취소 | `std::jthread`, `stop_token` | 협조적 취소 포인트 |
| 성능 이슈 | Amdahl, false sharing | 패딩/정렬, 임계구역 축소 |

---

## 16. 미니 퀴즈

1. 왜 CV `wait()` 에서 `if` 대신 `while`이 권장될까요?  
2. `std::scoped_lock(m1, m2)` 가 데드락을 예방하는 이유는?  
3. `std::atomic`에서 `memory_order_relaxed`는 어떤 보장을 주고 무엇은 보장하지 않을까요?

---

## 17. 마무리

멀티스레딩은 **도구 사용법**(스레드/락/CV/원자)과 **디자인 원칙**(수명 관리, 락 정책, 취소 협조, 데이터 레이아웃)을 함께 이해해야 합니다.  
이 글의 예제와 체크리스트를 기준으로, 작은 실험 → 측정 → 개선을 반복하면  
안정성과 성능을 모두 잡은 **현대 C++ 동시성 코드**를 빠르게 쌓아갈 수 있습니다.