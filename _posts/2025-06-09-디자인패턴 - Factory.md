---
layout: post
title: 디자인패턴 - Factory
date: 2025-06-09 23:20:23 +0900
category: 디자인패턴
---
# Factory Method(팩토리 메서드 패턴)

## 1. 정의(Definition)와 문제 배경

**팩토리 메서드 패턴(Factory Method Pattern)**은 **객체 생성 책임을 상위 타입(추상 클래스/인터페이스)에 선언**하고, **구체 생성은 하위 타입**이 담당하게 하여, 클라이언트가 **구체 클래스 이름에 의존하지 않도록 만드는** 생성 패턴이다.

- **핵심 목표**
  - 객체 생성 로직을 **캡슐화**한다.
  - 새로운 제품(구현) 추가 시 **기존 클라이언트 수정 없이** 확장(OCP).
  - 클라이언트는 **공통 인터페이스**만 의존한다.

**적용할 때의 전형적인 냄새**
- 코드 전반에 **`if/elif/else` 혹은 `switch`** 분기가 흩어져 있음(생성 분기 누수).
- 새 구현 추가 시 **여러 파일**을 같이 수정해야 함(개방–폐쇄 위반).
- 단위 테스트에서 **구체 타입 결합** 때문에 목/스텁 교체가 어려움.

---

## 2. 의도(Intent) — 왜 쓰는가

- 객체 생성 로직을 **한 곳으로 모아서 위임**한다.
- **확장 지점**(factoryMethod)을 명확히 하여, 기능 추가를 **변경이 아닌 확장**으로 수용한다.
- 프레임워크/플러그인 구조처럼 사용자는 **상위 계약**만 알고, 실제 구현은 독립적으로 교체/배포.

---

## 3. 구조(Structure) — 제공한 그림을 유지

아래 **구조 그림**은 사용자가 제공한 도식을 **그대로 보존**하였다.

```
        ┌──────────────────────┐
        │   Creator (추상 클래스) │
        ├──────────────────────┤
        │ + factoryMethod()    │◄──────┐
        │ + operation()        │       │
        └──────────────────────┘       │
                ▲                      │
                │                      │
 ┌──────────────────────┐     ┌─────────────────────┐
 │ ConcreteCreatorA     │     │ ConcreteCreatorB     │
 ├──────────────────────┤     ├─────────────────────┤
 │ + factoryMethod()    │     │ + factoryMethod()   │
 └──────────────────────┘     └─────────────────────┘
                │                      │
                ▼                      ▼
      ┌──────────────────┐   ┌──────────────────┐
      │ ProductA          │   │ ProductB         │
      └──────────────────┘   └──────────────────┘
```

**역할 해설**
- **Creator**: 공통 동작의 **골격(operation)**을 제공하고, 구체 생성은 **`factoryMethod()`**라는 훅(확장 지점)에 **위임**한다.
- **ConcreteCreatorX**: 어떤 **ProductX**를 만들지 **결정**한다.
- **Product**: 클라이언트가 의존하는 **공통 계약(인터페이스/추상)**.
- **ConcreteProductX**: 실제 동작을 수행하는 구현.

**흐름(시퀀스) 요약**
1) 클라이언트는 `Creator.operation()`을 호출한다.  
2) `operation()` 내부에서 `factoryMethod()`를 호출해 **제품 인스턴스**를 얻는다.  
3) 얻은 `Product`에 공통 프로세스의 나머지 단계를 위임한다.

---

## 4. 기본 구현 ① — GUI 버튼(파이썬)

```python
# 제품 인터페이스
class Button:
    def render(self):
        raise NotImplementedError

# 구체 제품
class WindowsButton(Button):
    def render(self):
        print("윈도우 스타일 버튼 렌더링")

class MacButton(Button):
    def render(self):
        print("맥 스타일 버튼 렌더링")

# Creator (상위 골격 제공)
class Dialog:
    def create_button(self) -> Button:
        raise NotImplementedError

    def render_window(self):
        # 공통 동작의 골격
        btn = self.create_button()
        # 이후 단계가 더 있다고 가정하면 여기서 추가 공통처리 가능
        btn.render()

# Concrete Creators
class WindowsDialog(Dialog):
    def create_button(self) -> Button:
        return WindowsButton()

class MacDialog(Dialog):
    def create_button(self) -> Button:
        return MacButton()

# 사용
def client_code(dialog: Dialog):
    dialog.render_window()

client_code(WindowsDialog())  # 윈도우 스타일 버튼 렌더링
client_code(MacDialog())      # 맥 스타일 버튼 렌더링
```

**핵심**
- `render_window()`는 **공통 시나리오의 틀**을 제공한다.
- 실제 어떤 버튼을 만들지는 **하위 클래스의 `create_button()`**이 책임진다.

---

## 5. 기본 구현 ② — 로깅 백엔드(C#)

```csharp
public interface ILogger { void Log(string msg); }

public class ConsoleLogger : ILogger
{
    public void Log(string msg) => Console.WriteLine(msg);
}

public class FileLogger : ILogger
{
    private readonly string _path;
    public FileLogger(string path) { _path = path; }
    public void Log(string msg) => File.AppendAllText(_path, msg + Environment.NewLine);
}

public abstract class LoggerFactory
{
    // 팩토리 메서드(확장 지점)
    public abstract ILogger Create();

    // 상위 골격(공통 흐름)
    public void Run(string msg)
    {
        var logger = Create();
        logger.Log(msg);
    }
}

public class ConsoleLoggerFactory : LoggerFactory
{
    public override ILogger Create() => new ConsoleLogger();
}

public class FileLoggerFactory : LoggerFactory
{
    private readonly string _path;
    public FileLoggerFactory(string path) => _path = path;
    public override ILogger Create() => new FileLogger(_path);
}
```

**테스트 팁**: `LoggerFactory`를 상속한 **테스트용 Creator**를 만들어, `Create()`에서 **목/스파이 로거**를 반환하게 하면 공통 골격(`Run`)을 검증하기 쉽다.

---

## 6. 장점/단점 — 실무 관점

**장점**
- 생성 로직과 사용 로직 분리 → **결합도 감소**.
- 새 구현 추가가 **변경이 아닌 확장**(OCP).
- **테스트 대체 용이**(목 제품 반환).

**단점**
- Creator/Product 계층이 늘면 **클래스 수 증가**.
- 단순한 경우 **과도한 추상화**가 될 수 있음.  
- 생성이 매우 단순하면 **정적 팩토리 메서드**나 **직접 생성**이 더 명료.

---

## 7. 사용 사례(확장)

| 도메인 | 구체 시나리오 | 팩토리 메서드 역할 |
|---|---|---|
| GUI 위젯 | OS/테마별 위젯 묶음 중 일부 | `createWidget()`이 테마별 제품 선택 |
| 데이터 접근 | 드라이버별 연결/쿼리기 | `createConnection()`으로 구현 선택 |
| 전송/메시징 | HTTP/gRPC/MQTT 클라이언트 | `createClient()`가 프로토콜별 구현 반환 |
| 암호화 | AES/ChaCha20 등 알고리즘 | `createCipher()`가 키/모드 기반 구현 생성 |
| 게임 | 캐릭터/무기/오브젝트 | `createEntity()`가 상황별 타입 생성 |
| 관측/로그 | 콘솔/파일/원격 APM | `createSink()`가 환경별 싱크 반환 |

---

## 8. 변형(Variants)과 구현 기법

### 8.1 매개변수화된 팩토리 메서드
한 Creator 내부에서 **키/옵션**으로 제품을 선택.

```python
class CryptoFactory:
    def create_cipher(self, algo: str):
        if algo == "AES": return AESCipher()
        if algo == "CHACHA20": return ChaCha20Cipher()
        raise ValueError("unknown algo")
```

- 장점: Creator 클래스를 남발하지 않음.
- 단점: 분기가 다시 커질 수 있다. 규모가 커지면 키별 **ConcreteCreator**로 승격.

### 8.2 등록(Registry) 기반
**키 → 생성자**를 등록/조회.

```python
class RegistryFactory:
    _reg = {}
    @classmethod
    def register(cls, key, ctor):
        if key in cls._reg:
            raise KeyError(f"duplicate key: {key}")
        cls._reg[key] = ctor

    @classmethod
    def create(cls, key, *a, **kw):
        if key not in cls._reg:
            raise KeyError(f"no such key: {key}")
        return cls._reg[key](*a, **kw)

# 사용 예
RegistryFactory.register("aes", AESCipher)
cipher = RegistryFactory.create("aes", key=b"...")
```

- 장점: 플러그인/런타임 확장에 적합.
- 주의: 등록 실패/중복, 보안·검증(신뢰하지 않는 플러그인 금지).

### 8.3 리플렉션/메타프로그래밍
문자열 이름 → 타입/클래스로 해석 후 생성.  
- 장점: 설정 파일로 구현을 교체하기 쉬움.  
- 단점: 타입 안전성 저하, 에러 발생 시점이 늦음.

### 8.4 제네릭/템플릿 팩토리(C#/C++)
컴파일 타임 제약으로 안정성 확보.

```csharp
public interface IProduct {}
public class DefaultFactory<T> where T : IProduct, new()
{
    public T Create() => new T();
}
```

---

## 9. DI/IoC 컨테이너와의 역할 분담

- **조립 문제**(객체 그래프 생성/주입)는 DI 컨테이너가 담당.
- **선택 문제**(런타임 조건에 따른 구현 선택)는 팩토리 메서드가 담당.

**실전 팁(C#)**
- `IServiceProvider`를 팩토리에 주입하고, 이름/태그/옵션을 받아 해당 구현을 **컨테이너에서 해석**해 꺼낸다.
- 다중 등록(예: `IEnumerable<ITransport>`) 후, 팩토리에서 **키 매칭**으로 한 구현을 선택.

---

## 10. 리팩토링 절차 — 거대 `switch` 제거

초기(나쁜 예):
```csharp
public ITransport Create(string scheme)
{
    switch (scheme)
    {
        case "http": return new HttpTransport(...);
        case "grpc": return new GrpcTransport(...);
        case "mqtt": return new MqttTransport(...);
        default: throw new NotSupportedException();
    }
}
```

절차
1) `TransportFactory` 추상 타입 도입, `Create()` 선언.  
2) `HttpTransportFactory` / `GrpcTransportFactory` / `MqttTransportFactory` 구현.  
3) 클라이언트는 `TransportFactory`만 의존.  
4) 결정 로직은 **구성(설정/DI/등록)**으로 이동.

개선(요지):
```csharp
public abstract class TransportFactory { public abstract ITransport Create(); }
public class HttpFactory : TransportFactory { public override ITransport Create() => new HttpTransport(...); }
// ... 다른 팩토리들
```

효과
- 새 프로토콜 추가 시 **새 팩토리 클래스만 작성**.
- 기존 클라이언트·공통 흐름은 **수정 없음**.

---

## 11. 테스트 전략 — 계약 테스트와 대체 용이성

### 11.1 파이썬(목 제품으로 공통 골격 검증)
```python
class Button:
    def render(self): raise NotImplementedError

class FakeButton(Button):
    def __init__(self): self.rendered = False
    def render(self): self.rendered = True

class TestDialog(Dialog):
    def create_button(self) -> Button:
        return FakeButton()

dlg = TestDialog()
dlg.render_window()
assert isinstance(dlg.create_button(), FakeButton)
```

### 11.2 C#(xUnit 예시)
```csharp
public class FakeLogger : ILogger
{
    public List<string> Logs { get; } = new();
    public void Log(string msg) => Logs.Add(msg);
}

public class FakeLoggerFactory : LoggerFactory
{
    public FakeLogger Last { get; private set; }
    public override ILogger Create() => Last = new FakeLogger();
}

// 테스트
[Fact]
public void Run_UsesProductFromFactory()
{
    var f = new FakeLoggerFactory();
    f.Run("hello");
    Assert.Contains("hello", f.Last.Logs);
}
```

**포인트**
- Creator의 공통 골격 검증(팩토리로부터 받은 제품을 통해 **의도된 흐름**이 수행되는가).
- 등록 기반은 **등록 실패/중복 키/예외 경로**까지 테스트.

---

## 12. 동시성·성능·수명 주의

- **비용**: 생성이 무거우면 팩토리 내부 **풀링/캐싱** 고려(단, 수명·경합 주의).
- **Thread-safety**: 팩토리가 **무상태(stateless)**면 가장 안전. 상태가 필요하면 동기화/불변 설계.
- **라이프사이클**: 팩토리(싱글턴) ↔ 제품(Transient/Scoped/Singleton) **범위를 구분**. DI 수명 범위와 충돌하지 않게 설계.

---

## 13. 비교 — 추상 팩토리/빌더/정적 팩토리

| 항목 | 팩토리 메서드 | 추상 팩토리 | 빌더 | 정적 팩토리(메서드) |
|---|---|---|---|---|
| 대상 | 보통 **단일 제품 축** | **제품군**(세트) | **복잡한 조립 단계** | 간단 생성 캡슐화 |
| 확장 포인트 | 하위 클래스 오버라이드 | 팩토리·제품군 추가 | 단계/옵션 확장 | 오버로딩/이름 구분 |
| 복잡도 | 중간 | 높음 | 중간~높음 | 낮음 |
| 장점 | 런타임 구현 교체 | 일관된 세트 보장 | 조립/옵션 분리 | 호출 간단/읽기 쉬움 |
| 단점 | 클래스 증가 | 인터페이스 다수 | 과한 fluent 위험 | 상속 확장 포인트 부족 |

---

## 14. 실전 시나리오 3선 — 설계→코드 스케치

### 14.1 결제 게이트웨이 다중화
- 문제: 국가/상황/프로모션에 따라 PG사 선택.
- 설계: `PaymentFlow.pay()`는 공통 흐름, `create_gateway()`가 PG 구현 선택(키/구성 기반).
- 포인트: 실패시 **재시도 전략**은 데코레이터/전략으로 분리, 팩토리는 **선택만** 담당.

### 14.2 데이터 소스 플러그인(등록 기반)
- 문제: CSV/Parquet/REST API 등 소스 다양.
- 설계: `Importer.run()`은 파이프라인 골격, `create_reader()`가 포맷별 리더 반환.
- 등록 팩토리로 서드파티가 **런타임 확장**.

```python
class Reader: ...
class CsvReader(Reader): ...
class ParquetReader(Reader): ...

class ReaderFactory:
    _map = {}
    @classmethod
    def register(cls, key, ctor): cls._map[key]=ctor
    @classmethod
    def create(cls, key, **opts): return cls._map[key](**opts)
```

### 14.3 관측/로그 싱크
- 문제: 콘솔/파일/원격(Elastic/APM)로 출력 경로 교체.
- 설계: `create_sink()`에서 구현 선택, 상위는 동일하게 `record()` 호출.

---

## 15. 흔한 실수/안티패턴

- **패턴 과잉**: 단순 생성까지 Creator/제품 계층을 만들지 말 것.
- **모든 것을 리플렉션**: 타입 안전성·성능·에러 시점 악화. 검증/화이트리스트 필수.
- **Creator에 비즈니스 로직 과다**: 공통 골격 vs 확장 훅의 **분리**가 핵심.
- **전역 싱글턴 팩토리**에 캐시를 마구 쌓음: 수명/경합/메모리 누수 위험.

---

## 16. 체크리스트(도입 전 자문)

- 새 구현 추가 시 **기존 코드 수정이 발생**하는가?  
- 생성 분기가 **여러 곳**에 흩어져 있는가?  
- **테스트에서 대체**가 쉬워지는가?  
- DI/IoC와 **역할 분담**이 명확한가(조립 vs 선택)?  
- 수명/동시성/예외 처리 계획이 있는가?

---

## 17. 부록 — UML 텍스트 표기 간단 규칙

- `A --> B` : A가 B를 **사용/의존**  
- `A -|> B` : A가 B를 **상속/구현**  
- 시퀀스 예: `Client -> Creator : operation()` / `Creator -> Creator : factoryMethod()` / `Creator -> Product : use()`

---

## 18. 요약(Conclusion)

팩토리 메서드는 **공통 골격과 확장 훅을 분리**하여, 제품 다양화 요구를 **변경 최소**로 수용한다.  
DI/IoC, 빌더, 추상 팩토리, 데코레이터/전략 등과 **역할을 분명히 나누어** 사용하면 가장 강력하다.  
가장 중요한 원칙은 **필요 이상 추상화 금지**다. 현재의 구체적 문제를 풀되, **합리적인 변화**를 매끄럽게 받아들이는 범위에서만 적용하라.