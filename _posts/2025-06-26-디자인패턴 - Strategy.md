---
layout: post
title: 디자인패턴 - Strategy
date: 2025-06-26 19:20:23 +0900
category: 디자인패턴
---
# Strategy (전략 패턴)

## ✅ 정의

**전략 패턴(Strategy Pattern)**은 **여러 알고리즘(전략)**을 정의하고, 이들 알고리즘을 **캡슐화하여 객체로 만들고**, **동적으로 교체할 수 있도록** 하는 행위 패턴입니다.  
클라이언트는 실행 중에 전략을 자유롭게 교체하며 동일한 인터페이스로 동작할 수 있습니다.

> “알고리즘을 런타임에 선택하고 바꿀 수 있게 만드는 패턴”

---

## 🎯 의도 (Intent)

- 알고리즘 군(群)을 정의하고, 각각을 캡슐화하여 교체 가능하게 함
- 알고리즘의 변경이 필요한 경우에도 **클라이언트 코드를 수정하지 않도록** 유연성을 제공

---

## 📦 구조 (UML)

```
┌────────────┐
│   Context  │─────────────┐
└────┬───────┘             │
     ▼                     │
┌────────────┐   uses      ▼
│  Strategy  │◄────────┐
└────┬───────┘         │
     ▼                 │
┌────────────┐    ┌────────────┐
│ConcreteStra│    │ConcreteStra│
│    teA     │    │    teB     │
└────────────┘    └────────────┘
```

- **Context**: 전략을 사용하는 클라이언트. 알고리즘을 전략 객체에 위임.
- **Strategy**: 알고리즘을 정의하는 인터페이스
- **ConcreteStrategy**: 실제 알고리즘 구현체

---

## 🧑‍💻 구현 예시 (Python)

```python
from abc import ABC, abstractmethod

# Strategy 인터페이스
class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount):
        pass

# 전략 A - 카드 결제
class CreditCardPayment(PaymentStrategy):
    def pay(self, amount):
        print(f"💳 카드로 {amount}원 결제했습니다.")

# 전략 B - 페이팔 결제
class PayPalPayment(PaymentStrategy):
    def pay(self, amount):
        print(f"📧 페이팔로 {amount}원 결제했습니다.")

# Context
class ShoppingCart:
    def __init__(self, strategy: PaymentStrategy):
        self.strategy = strategy

    def set_strategy(self, strategy: PaymentStrategy):
        self.strategy = strategy

    def checkout(self, amount):
        self.strategy.pay(amount)

# 사용 예시
cart = ShoppingCart(CreditCardPayment())
cart.checkout(10000)

cart.set_strategy(PayPalPayment())
cart.checkout(5000)
```

**출력 예시:**
```
💳 카드로 10000원 결제했습니다.
📧 페이팔로 5000원 결제했습니다.
```

---

## ✅ 장점

- **알고리즘을 캡슐화**하여 분리 가능 → 변경에 유연
- **Open-Closed Principle(OCP)** 적용 가능 (전략 추가 시 기존 코드를 건드리지 않음)
- 클라이언트 코드에서 조건문을 제거하여 **가독성 향상**

---

## ⚠️ 단점

- 전략 수가 많아지면 **클래스 수 증가**
- 클라이언트가 전략 간 차이를 이해하고 **선택 로직을 관리해야 함**
- 지나치게 단순한 로직에는 오히려 **오버엔지니어링**

---

## 📌 사용 사례

| 분야 | 예시 |
|------|------|
| 결제 시스템 | 신용카드, 페이팔, 포인트 등 전략 분리 |
| 정렬 알고리즘 | 버블 정렬, 퀵 정렬 등 알고리즘 선택 가능 |
| AI 행동 | 게임에서 캐릭터 전략을 상황에 따라 교체 |
| 텍스트 인코딩 | JSON, XML, YAML 등의 출력 포맷 전략화 |
| 할인 정책 | 요일, 멤버십, 쿠폰 등 다양한 할인 전략 적용 |

---

## 🧠 Strategy vs Template Method

| 항목 | Strategy | Template Method |
|------|----------|-----------------|
| 목적 | 알고리즘 교체 | 알고리즘 틀 고정, 세부만 변경 |
| 변경 방법 | 객체 교체 | 서브클래싱 |
| 유연성 | 높음 (동적 교체 가능) | 낮음 (상속 구조 고정) |
| 구현 방식 | 위임(Composition) | 상속(Inheritance) |

---

## ✅ 실무 팁

- 보통 if/else나 switch로 알고리즘 분기가 많다면 Strategy로 치환할 수 있음
- 런타임 전략 변경이 요구되는 시스템(예: 게임, 추천 알고리즘, 결제 등)에 매우 유용
- 팩토리 패턴과 함께 사용하면 **전략 선택 로직도 깔끔하게 유지 가능**

---

## 🧠 마무리

**전략 패턴은 "행위를 캡슐화"하는 대표적인 디자인 패턴으로**,  
**변화에 닫혀 있고 확장에 열려 있는(OCP)** 아키텍처를 만드는 데 효과적입니다.  
비즈니스 로직의 변경이나 확장이 빈번한 시스템에서는 전략 패턴을 통해 **복잡성을 낮추고 유연성을 확보할 수 있습니다.**
