---
layout: post
title: 디자인패턴 - Strategy
date: 2025-06-26 20:20:23 +0900
category: 디자인패턴
---
# Strategy (전략 패턴)

## 1. 정의

**전략 패턴(Strategy Pattern)**은 하나의 행위를 **여러 알고리즘(전략)**으로 교체 가능하게 만들기 위해, 알고리즘을 **공통 인터페이스로 캡슐화**하고 **런타임에 바인딩/교체**할 수 있도록 하는 행위 패턴이다.  
클라이언트(Context)는 전략 객체에 작업을 **위임**하며, 전략 교체 시 클라이언트 코드는 변경하지 않는다.

---

## 2. 구조 (UML)

```
┌────────────────┐          uses           ┌────────────────┐
│    Context     │────────────────────────▶│    Strategy    │ «interface»
│ - strategy     │                         └──────┬─────────┘
│ + setStrategy()│                                │
│ + execute()    │                                │
└────────────────┘                                │
                                                  │
                          ┌───────────────────────┴──────────────────────┐
                          │                                              │
                  ┌───────────────┐                              ┌───────────────┐
                  │ConcreteStrategyA│                              │ConcreteStrategyB│
                  └───────────────┘                              └───────────────┘
```

핵심 포인트
- **Context**는 전략의 생명주기를 소유하거나 외부로부터 주입받는다.
- **Strategy**는 단일 책임을 갖는 간결한 인터페이스여야 한다.
- **ConcreteStrategy**는 교체 가능한 다양한 알고리즘 구현체다.

---

## 3. 언제 쓰나: 코드 냄새로 진단

다음 상황이면 전략 패턴을 고려한다.

- 거대한 `if/elif/else` 또는 `switch`로 알고리즘을 분기한다.
- 신규 알고리즘 추가 때마다 **클라이언트 코드**를 수정해야 한다.
- 테스트에서 알고리즘 경로를 **독립적으로 대체/격리**하고 싶다.
- 런타임 조건(구성, 환경, 트래픽, 피처 플래그)으로 **행위를 바꾸고** 싶다.

안티패턴(냄새):

```python
def checkout(method, amount):
    if method == "card":
        ...
    elif method == "paypal":
        ...
    elif method == "point":
        ...
    else:
        raise ValueError("unknown")
```

문제: 알고리즘 증가 시 분기 폭발, 변경 파급, 테스트 복잡.

---

## 4. 기본 구현 (Python, 결제 전략)

```python
from abc import ABC, abstractmethod

# 1. Strategy 인터페이스
class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount: int) -> None:
        ...

# 2. 구체 전략들
class CreditCardPayment(PaymentStrategy):
    def pay(self, amount: int) -> None:
        print(f"카드로 {amount}원 결제")

class PayPalPayment(PaymentStrategy):
    def pay(self, amount: int) -> None:
        print(f"페이팔로 {amount}원 결제")

# 3. Context
class ShoppingCart:
    def __init__(self, strategy: PaymentStrategy):
        self._strategy = strategy

    def set_strategy(self, strategy: PaymentStrategy) -> None:
        self._strategy = strategy

    def checkout(self, amount: int) -> None:
        self._strategy.pay(amount)

# 사용
cart = ShoppingCart(CreditCardPayment())
cart.checkout(10000)
cart.set_strategy(PayPalPayment())
cart.checkout(5000)
```

출력
```
카드로 10000원 결제
페이팔로 5000원 결제
```

포인트
- **분기 제거**: 새로운 결제 수단 추가 시 Context/호출부 수정 불필요.
- **테스트 용이**: 가짜(Mock) 전략으로 결제 없이 로직 검증 가능.

---

## 5. 전략 주입 패턴: 생성자/세터/메서드 매개변수

전략 전달 방식과 시점은 유연하게 설계한다.

| 주입 시점          | 방법                         | 특징 |
|-------------------|------------------------------|------|
| 생성자 주입        | `__init__(strategy)`         | 불변성↑, 기본 전략 보장 |
| 세터 주입          | `set_strategy(strategy)`      | 런타임 교체 용이 |
| 메서드 인자 주입   | `execute(strategy, args…)`    | 호출 단위 커스터마이즈 |

---

## 6. 등록·선택: 전략 레지스트리와 팩토리

전략 선택 로직도 분기문으로 흩어지면 다시 냄새가 난다. **등록형 팩토리**로 캡슐화하자.

```python
from typing import Dict, Type

_REGISTRY: Dict[str, Type[PaymentStrategy]] = {}

def register_strategy(name: str):
    def deco(cls):
        _REGISTRY[name] = cls
        return cls
    return deco

@register_strategy("card")
class CreditCardPayment(PaymentStrategy):
    def pay(self, amount: int) -> None:
        print(f"카드로 {amount}원 결제")

@register_strategy("paypal")
class PayPalPayment(PaymentStrategy):
    def pay(self, amount: int) -> None:
        print(f"페이팔로 {amount}원 결제")

def make_strategy(name: str) -> PaymentStrategy:
    try:
        return _REGISTRY[name]()
    except KeyError:
        raise ValueError(f"알 수 없는 전략: {name}")

# 구성으로부터 선택
name_from_config = "paypal"
cart = ShoppingCart(make_strategy(name_from_config))
cart.checkout(12000)
```

장점
- 전략 추가는 **클래스 선언 + 애노테이션(데코레이터)** 만으로 등록.
- 구성/플래그/환경변수로 **선택 정책을 데이터화**.

---

## 7. 파라미터화·상태 있는 전략

전략이 외부 설정/상태를 가진다면 **불변 필드**로 주입하고, 동시성 안전을 고려한다.

```python
class ThresholdDiscount(PaymentStrategy):
    def __init__(self, threshold: int, rate: float):
        self._th = threshold
        self._rate = rate

    def pay(self, amount: int) -> None:
        payable = amount
        if amount >= self._th:
            payable = int(amount * (1 - self._rate))
        print(f"할인 적용 후 {payable}원 결제")
```

주의
- 공유 상태가 있다면 락/원자성/카운터를 설계하거나 **무상태(stateless)** 로 유지.

---

## 8. 비동기 전략(네트워크/IO)

비동기 호출이 필요한 전략은 `async` 버전을 분리한다.

```python
import asyncio
from abc import ABC, abstractmethod

class AsyncPaymentStrategy(ABC):
    @abstractmethod
    async def pay(self, amount: int) -> None: ...

class RemoteGatewayPayment(AsyncPaymentStrategy):
    def __init__(self, endpoint: str):
        self._ep = endpoint

    async def pay(self, amount: int) -> None:
        await asyncio.sleep(0.02)  # HTTP 호출 가정
        print(f"{self._ep} 로 {amount}원 결제 승인")

class AsyncCart:
    def __init__(self, strategy: AsyncPaymentStrategy):
        self._s = strategy
    async def checkout(self, amount: int):
        await self._s.pay(amount)

# 사용
async def main():
    cart = AsyncCart(RemoteGatewayPayment("https://pay.example"))
    await cart.checkout(9900)

# asyncio.run(main())
```

팁
- 동기/비동기 인터페이스를 **명확히 분리**해 혼합에 따른 데드락/블로킹을 방지.

---

## 9. 전략 조합: 파이프라인/데코레이터

전략을 **파이프라인**으로 합성하여 전처리/후처리를 만들 수 있다.

```python
class Pipeline(PaymentStrategy):
    def __init__(self, *strategies: PaymentStrategy):
        self._steps = strategies
    def pay(self, amount: int) -> None:
        amt = amount
        for s in self._steps:
            # 각 단계는 "금액 변환 전략"이라고 가정
            if hasattr(s, "transform"):
                amt = s.transform(amt)
            else:
                s.pay(amt)

class FeeAdder:
    def __init__(self, fee: int): self._fee = fee
    def transform(self, amount: int) -> int: return amount + self._fee

class LoggerStep:
    def transform(self, amount: int) -> int:
        print(f"로깅: {amount}")
        return amount

pipe = Pipeline(LoggerStep(), FeeAdder(300))
pipe.pay(1000)  # 1300을 다음 단계로 넘김
```

---

## 10. 자동 전략 선택: 규칙·스코어·확률적 탐색

### 10.1 규칙 기반
구성 규칙으로 전략을 고른다(국가, 고객 등급, 시간대).

```python
def choose_by_rule(ctx) -> str:
    if ctx.country == "KR": return "card"
    if ctx.is_enterprise:   return "invoice"
    return "paypal"
```

### 10.2 지표 기반
성과지표(전환율, 지연시간, 오류율)로 스코어를 계산해 고른다.

예: 지연시간 가중치 최소화  
\( \text{score} = \alpha \cdot \text{latency} + \beta \cdot \text{error\_rate} - \gamma \cdot \text{conversion} \)

### 10.3 멀티암드 밴딧(탐색-활용)
전략을 슬롯머신 암으로 보고, 관측 보상에 따라 선택 확률을 조정한다.  
UCB1(상한 신뢰 한계) 예:

$$
\text{UCB}_i = \bar{x}_i + c \sqrt{\frac{2 \ln n}{n_i}}
$$

- \(\bar{x}_i\): 전략 \(i\)의 평균 보상(예: 성공=1, 실패=0)  
- \(n_i\): 전략 \(i\)의 시도 횟수, \(n\): 전체 시도수, \(c>0\): 탐색 강도

\(\text{UCB}_i\) 가 큰 전략을 선택.  
탐색률이 필요한 경우 \(\epsilon\)-greedy도 사용 가능:
- 확률 \(\epsilon\)으로 임의 전략, \(1-\epsilon\)으로 최고 성과 전략.

---

## 11. 로깅·모니터링·추적성

- 선택한 전략, 입력, 결과, 소요시간, 오류를 **구조화 로그**로 남긴다.
- 메트릭: 전략별 성공률, 평균/분위수 지연시간, 오류율, 선택 분포.
- 분산 추적: Context에서 trace/span을 열고 전략 실행을 **하위 스팬**으로 추적.

간단 로거 데코레이터:

```python
import time
def logged(strategy_cls):
    class Logged(strategy_cls):
        def pay(self, amount: int) -> None:
            t0 = time.time()
            try:
                print(f"[strategy={strategy_cls.__name__}] start amount={amount}")
                return super().pay(amount)
            finally:
                print(f"[strategy={strategy_cls.__name__}] took={time.time()-t0:.4f}s")
    return Logged

@logged
class CreditCardPayment(PaymentStrategy):
    def pay(self, amount: int) -> None:
        print(f"카드로 {amount}원 결제")
```

---

## 12. 동시성·스레드 안전

- 전략이 **무상태/불변**이면 가장 안전하다.
- 공유 캐시/카운터가 필요하면 락/원자 연산/큐로 보호.
- Context에서 전략 교체가 잦다면 **읽기-쓰기 락** 또는 **스냅샷**으로 일관성 보장.

스냅샷 호출 예:

```python
import threading

class SafeContext:
    def __init__(self, strategy: PaymentStrategy):
        self._strategy = strategy
        self._lock = threading.RLock()

    def set_strategy(self, strategy: PaymentStrategy):
        with self._lock:
            self._strategy = strategy

    def checkout(self, amount: int):
        with self._lock:
            strat = self._strategy  # 스냅샷
        strat.pay(amount)
```

---

## 13. 언어별 구현 스케치

### 13.1 Java (함수형 전략 포함)

```java
interface SortStrategy { <T extends Comparable<T>> void sort(List<T> list); }

class QuickSort implements SortStrategy {
    public <T extends Comparable<T>> void sort(List<T> list) { /* ... */ }
}

class MergeSort implements SortStrategy {
    public <T extends Comparable<T>> void sort(List<T> list) { /* ... */ }
}

class Sorter {
    private SortStrategy s;
    public Sorter(SortStrategy s) { this.s = s; }
    public void setStrategy(SortStrategy s) { this.s = s; }
    public <T extends Comparable<T>> void sort(List<T> list) { s.sort(list); }
}

// 함수형 대체: Strategy를 람다로
SortStrategy lam = list -> Collections.sort(list); // 위임
```

### 13.2 C# (.NET, DI 컨테이너와 키드 서비스)

```csharp
public interface IPaymentStrategy { void Pay(int amount); }

public sealed class CardPayment : IPaymentStrategy { public void Pay(int amount) => Console.WriteLine($"카드 {amount}원"); }
public sealed class PaypalPayment : IPaymentStrategy { public void Pay(int amount) => Console.WriteLine($"페이팔 {amount}원"); }

public sealed class Cart {
    private IPaymentStrategy _s;
    public Cart(IPaymentStrategy s) => _s = s;
    public void SetStrategy(IPaymentStrategy s) => _s = s;
    public void Checkout(int amount) => _s.Pay(amount);
}

// .NET 8 Keyed DI 등록 예시
// builder.Services.AddKeyedScoped<IPaymentStrategy, CardPayment>("card");
// builder.Services.AddKeyedScoped<IPaymentStrategy, PaypalPayment>("paypal");
// var strat = sp.GetRequiredKeyedService<IPaymentStrategy>("card");
```

포인트
- C#에서는 **keyed services** 또는 `IEnumerable<IPaymentStrategy>` 주입 후 **이름→전략** 매핑으로 선택.

---

## 14. 정렬 전략 예(빅오 비교, 학습 목적)

```python
class SortStrategy(ABC):
    @abstractmethod
    def sort(self, data): ...

class QuickSort(SortStrategy):
    def sort(self, data):
        if len(data) <= 1: return data
        pivot = data[len(data)//2]
        left  = [x for x in data if x < pivot]
        mid   = [x for x in data if x == pivot]
        right = [x for x in data if x > pivot]
        return self.sort(left) + mid + self.sort(right)

class BubbleSort(SortStrategy):
    def sort(self, data):
        a = data[:]
        n = len(a)
        for i in range(n):
            for j in range(0, n-i-1):
                if a[j] > a[j+1]:
                    a[j], a[j+1] = a[j+1], a[j]
        return a

class Sorter:
    def __init__(self, s: SortStrategy): self.s = s
    def set_strategy(self, s: SortStrategy): self.s = s
    def run(self, data): return self.s.sort(data)

arr = [5,2,9,1,5,6]
sr = Sorter(QuickSort())
print(sr.run(arr))
sr.set_strategy(BubbleSort())
print(sr.run(arr))
```

복잡도(평균)
- 퀵소트: \(O(n \log n)\)
- 버블: \(O(n^2)\)

전략 교체로 **성능·안정성·메모리** 트레이드오프를 코드 변경 없이 비교 가능.

---

## 15. 테스트 전략

### 15.1 파라미터화 테스트

```python
import pytest

@pytest.mark.parametrize("name,expected", [
    ("card", "카드로 100원 결제"),
    ("paypal", "페이팔로 100원 결제"),
])
def test_payments(name, expected, capsys):
    s = make_strategy(name)
    cart = ShoppingCart(s)
    cart.checkout(100)
    assert expected in capsys.readouterr().out
```

### 15.2 속성 기반 테스트(전략 불변성)
- 동일 입력에 대해 전략 간 **규약** 확인(예: 소팅 후 비내림차순).

```python
def is_sorted(xs): return all(xs[i] <= xs[i+1] for i in range(len(xs)-1))

def test_sorters_property():
    import random
    data = [random.randint(0, 1000) for _ in range(200)]
    for strat in (QuickSort(), BubbleSort()):
        out = strat.sort(data)
        assert is_sorted(out)
        assert sorted(data) == out
```

---

## 16. Template Method, State와 비교

| 항목 | Strategy | Template Method | State |
|------|----------|-----------------|-------|
| 목적 | 알고리즘 교체(위임) | 공통 골격 고정, 부분만 재정의(상속) | 상태에 따른 행위 변경 |
| 교체 시점 | 런타임 가능 | 컴파일타임(상속) | 런타임, 전이 규칙 내재 |
| 구조 | 합성/위임 | 상속 | 상태 객체+전이 |
| 적용 | 결제/정렬/인코딩/압축 | 파이프라인 뼈대 | FSM, UI, 네트워킹 |

---

## 17. 안티패턴·주의점 체크리스트

- 전략 인터페이스가 **너무 비대**: 한 역할만 남겨 SRP 준수.
- 전략 선택 분기가 **여러 곳에 중복**: 등록형 팩토리로 캡슐화.
- 상태 있는 전략을 **여러 스레드에서 공유**: 불변/복제/락 설계.
- 전략이 **부수효과**를 남김: 명시하고 테스트에 후킹 지점 제공.
- 비동기 전략을 동기에서 **직접 대기**: 교착 우려, 레이어 분리.

---

## 18. 성능·운영 팁

- 단순 호출 오버헤드는 작다. 병목은 보통 **전략 내부 I/O/알고리즘**에 있다.
- 고빈도 호출에서 객체 생성 비용이 크다면 **전략 인스턴스 재사용**.
- 선택 정책은 **데이터화**(구성/피처 플래그)하여 배포 없이 전환 가능.
- 자동선택(밴딧) 실험 시 **로그 스키마**와 **오류/보상 정의**를 고정.

---

## 19. 도메인 예시: 할인 정책 전략(규칙+플래그)

```python
class Discount(ABC):
    @abstractmethod
    def apply(self, amount: int) -> int: ...

class NoDiscount(Discount):
    def apply(self, amount: int) -> int: return amount

class PercentDiscount(Discount):
    def __init__(self, pct: float): self._p = pct
    def apply(self, amount: int) -> int: return int(amount * (1 - self._p))

class FlatDiscount(Discount):
    def __init__(self, won: int): self._w = won
    def apply(self, amount: int) -> int: return max(0, amount - self._w)

DISCOUNTS = {
    "none": lambda: NoDiscount(),
    "pct10": lambda: PercentDiscount(0.10),
    "flat1000": lambda: FlatDiscount(1000),
}

def choose_discount(user, env) -> Discount:
    key = env.get("discount_key", "none")
    if user.is_vip: key = "pct10"
    return DISCOUNTS[key]()

def checkout(amount: int, user, env):
    d = choose_discount(user, env)
    payable = d.apply(amount)
    print(f"최종 결제액: {payable}")

# env = {"discount_key":"flat1000"}
```

---

## 20. 요약

- 전략 패턴은 **행위를 인터페이스로 캡슐화**하고 **런타임 선택/교체**를 가능케 하여, 변경-확장에 강한 구조를 만든다.
- **등록형 팩토리**, **구성 기반 선택**, **비동기/동시성 분리**, **파이프라인 합성**, **밴딧 기반 자동선택** 등과 결합하면 실무 유연성이 극대화된다.
- 테스트는 **파라미터화/속성 기반**으로 전략 간 계약을 검증하라.
- 단순 문제에 남용하지 말고, **분기 폭발·변경 빈도·테스트 요구**가 높은 곳에 적용하라.