---
layout: post
title: C# - 델리게이트, 람다, 이벤트
date: 2024-10-19 20:20:23 +0900
category: Csharp
---
# C# 델리게이트, 람다, 이벤트

## 소개: 메서드를 값으로 다루는 C#의 기능

C#은 함수형 프로그래밍의 개념을 객체 지향 언어에 통합한 강력한 기능들을 제공합니다. **델리게이트(Delegate)** 는 메서드를 참조하는 타입 안전한 방법을 제공하고, **람다(Lambda)** 는 익명 함수를 간결하게 표현하며, **이벤트(Event)** 는 객체 간의 느슨한 결합을 위한 발행-구독 패턴을 구현합니다. 이 세 가지 개념은 함께 사용되어 C#에서 반응형이고 유연한 애플리케이션을 구축하는 기반이 됩니다.

---

## 1. 델리게이트(Delegate): 타입 안전한 메서드 참조

델리게이트는 메서드를 참조할 수 있는 타입으로, C++의 함수 포인터나 JavaScript의 콜백 함수와 유사한 개념이지만 타입 안전성을 갖추고 있습니다.

### 기본 델리게이트 정의와 사용

```csharp
// 1. 델리게이트 타입 선언 (메서드 시그니처 정의)
public delegate int MathOperation(int a, int b);

// 2. 델리게이트와 호환되는 메서드 정의
public class Calculator
{
    public static int Add(int a, int b) => a + b;
    public static int Multiply(int a, int b) => a * b;
    public static int Subtract(int a, int b) => a - b;
}

// 3. 델리게이트 사용
class Program
{
    static void Main()
    {
        // 델리게이트 인스턴스 생성 및 메서드 할당
        MathOperation operation = Calculator.Add;
        
        // 델리게이트 호출 (할당된 메서드 실행)
        int result = operation(5, 3);  // 8
        Console.WriteLine($"5 + 3 = {result}");
        
        // 다른 메서드 할당
        operation = Calculator.Multiply;
        result = operation(5, 3);  // 15
        Console.WriteLine($"5 * 3 = {result}");
    }
}
```

### 델리게이트의 실용적 사용: 콜백 메커니즘

델리게이트는 콜백(callback) 메커니즘을 구현하는 데 자주 사용됩니다.

```csharp
public class DataProcessor
{
    // 데이터 처리 메서드 (콜백 델리게이트를 매개변수로 받음)
    public void ProcessData(int[] numbers, Action<int> processCallback)
    {
        foreach (int number in numbers)
        {
            // 각 숫자에 대해 콜백 호출
            processCallback(number);
        }
    }
    
    // 데이터 필터링 메서드 (반환값이 있는 델리게이트 사용)
    public List<int> FilterData(int[] numbers, Func<int, bool> filterCriteria)
    {
        var result = new List<int>();
        foreach (int number in numbers)
        {
            if (filterCriteria(number))
            {
                result.Add(number);
            }
        }
        return result;
    }
}

class Program
{
    static void Main()
    {
        var processor = new DataProcessor();
        int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        
        // 콜백 델리게이트 사용
        Console.WriteLine("각 숫자 출력:");
        processor.ProcessData(numbers, n => Console.Write($"{n} "));
        Console.WriteLine();
        
        // 필터링 델리게이트 사용
        Console.WriteLine("\n짝수만 필터링:");
        var evenNumbers = processor.FilterData(numbers, n => n % 2 == 0);
        Console.WriteLine(string.Join(", ", evenNumbers));
        
        Console.WriteLine("\n5보다 큰 수 필터링:");
        var greaterThanFive = processor.FilterData(numbers, n => n > 5);
        Console.WriteLine(string.Join(", ", greaterThanFive));
    }
}
```

### 멀티캐스트 델리게이트(Multicast Delegate)

한 델리게이트 인스턴스가 여러 메서드를 참조할 수 있습니다. 이는 이벤트 처리 시스템의 기반이 됩니다.

```csharp
public delegate void LogMessage(string message);

class Program
{
    static void LogToConsole(string message)
    {
        Console.WriteLine($"[CONSOLE] {message}");
    }
    
    static void LogToFile(string message)
    {
        // 파일 로깅 로직 (여기서는 간단히 출력)
        Console.WriteLine($"[FILE] {message}");
    }
    
    static void LogToDatabase(string message)
    {
        // 데이터베이스 로깅 로직 (여기서는 간단히 출력)
        Console.WriteLine($"[DATABASE] {message}");
    }
    
    static void Main()
    {
        LogMessage logger = LogToConsole;
        
        // 델리게이트에 메서드 추가 (멀티캐스트)
        logger += LogToFile;
        logger += LogToDatabase;
        
        // 모든 메서드 호출
        Console.WriteLine("모든 로거 호출:");
        logger("애플리케이션 시작됨");
        
        Console.WriteLine("\n파일 로거 제거 후:");
        logger -= LogToFile;  // 특정 메서드 제거
        logger("작업 진행 중");
        
        Console.WriteLine("\n모든 로거 제거 후:");
        logger -= LogToConsole;
        logger -= LogToDatabase;
        
        // 이제 logger는 null이거나 빈 델리게이트
        logger?.Invoke("이 메시지는 출력되지 않음");
    }
}
```

**주의사항**: 멀티캐스트 델리게이트에서 메서드 중 하나가 예외를 던지면 나머지 메서드들은 실행되지 않습니다. 또한, 반환값이 있는 델리게이트를 멀티캐스트로 사용하면 마지막으로 호출된 메서드의 반환값만 반환됩니다.

---

## 2. 제네릭 델리게이트: Func, Action, Predicate

C#은 일반적인 용도의 델리게이트 타입을 미리 정의해 두었습니다. 이를 사용하면 매번 새로운 델리게이트 타입을 정의하지 않아도 됩니다.

### Action 델리게이트

`Action` 델리게이트는 반환값이 없는 메서드를 참조합니다.

```csharp
// 기본 Action (매개변수 없음)
Action simpleAction = () => Console.WriteLine("Hello, World!");
simpleAction();

// 매개변수가 있는 Action
Action<string> greetAction = name => Console.WriteLine($"Hello, {name}!");
greetAction("Alice");

// 여러 매개변수가 있는 Action
Action<string, int> printInfo = (name, age) => 
    Console.WriteLine($"{name} is {age} years old");
printInfo("Bob", 30);
```

### Func 델리게이트

`Func` 델리게이트는 반환값이 있는 메서드를 참조합니다. 마지막 제네릭 타입 매개변수가 반환 타입을 지정합니다.

```csharp
// 매개변수 없이 int 반환
Func<int> getRandom = () => new Random().Next(1, 100);
Console.WriteLine($"랜덤 숫자: {getRandom()}");

// string 매개변수를 받아 int 반환
Func<string, int> stringLength = s => s.Length;
Console.WriteLine($"'Hello' 길이: {stringLength("Hello")}");

// 두 개의 int 매개변수를 받아 int 반환
Func<int, int, int> add = (a, b) => a + b;
Console.WriteLine($"3 + 5 = {add(3, 5)}");

// 세 개의 매개변수를 받아 string 반환
Func<int, int, int, string> createPoint = (x, y, z) => $"Point({x}, {y}, {z})";
Console.WriteLine(createPoint(1, 2, 3));
```

### Predicate 델리게이트

`Predicate<T>`는 `Func<T, bool>`과 동일하며, 조건을 테스트하는 메서드를 참조합니다.

```csharp
Predicate<int> isEven = n => n % 2 == 0;
Console.WriteLine($"4는 짝수인가? {isEven(4)}");  // True
Console.WriteLine($"7는 짝수인가? {isEven(7)}");  // False

// 리스트에서 Predicate 사용
List<int> numbers = new() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
List<int> evenNumbers = numbers.FindAll(isEven);
Console.WriteLine($"짝수들: {string.Join(", ", evenNumbers)}");
```

---

## 3. 람다 표현식(Lambda Expressions)

람다 표현식은 익명 함수를 간결하게 표현하는 방법입니다. 델리게이트나 LINQ 쿼리에서 널리 사용됩니다.

### 람다 표현식 기본 문법

```csharp
// 기본 람다 표현식
Func<int, int> square = x => x * x;
Console.WriteLine($"5의 제곱: {square(5)}");

// 여러 매개변수가 있는 람다
Func<int, int, int> multiply = (x, y) => x * y;
Console.WriteLine($"3 * 4 = {multiply(3, 4)}");

// 명시적 타입 지정 (컴파일러가 타입을 추론할 수 없을 때)
Func<double, double, double> divide = (double x, double y) => x / y;
Console.WriteLine($"10 / 3 = {divide(10, 3):F2}");

// 문장 람다 (여러 줄로 구성)
Action<string> printDetails = name =>
{
    string greeting = $"Hello, {name}!";
    Console.WriteLine(greeting);
    Console.WriteLine($"이름 길이: {name.Length}");
};
printDetails("Charlie");
```

### 람다와 클로저(Closure)

람다 표현식은 자신을 둘러싼 범위의 변수에 접근할 수 있습니다. 이를 클로저라고 합니다.

```csharp
class Program
{
    static void Main()
    {
        int baseNumber = 10;
        
        // baseNumber를 캡처하는 람다 (클로저)
        Func<int, int> addBase = x => x + baseNumber;
        
        Console.WriteLine($"10 + 5 = {addBase(5)}");  // 15
        
        // baseNumber 변경
        baseNumber = 20;
        Console.WriteLine($"20 + 5 = {addBase(5)}");  // 25 (람다는 변경된 값 참조)
        
        // 루프 변수와 클로저: 주의가 필요한 경우
        var actions = new List<Action>();
        
        for (int i = 0; i < 3; i++)
        {
            int captured = i;  // 지역 변수로 복사 (중요!)
            actions.Add(() => Console.WriteLine($"Captured value: {captured}"));
        }
        
        Console.WriteLine("\n클로저 실행:");
        foreach (var action in actions)
        {
            action();  // 0, 1, 2 출력
        }
        
        // 주의: 아래 코드는 3, 3, 3을 출력합니다!
        // for (int i = 0; i < 3; i++)
        // {
        //     actions.Add(() => Console.WriteLine($"Wrong: {i}"));
        // }
    }
}
```

**중요**: 루프 변수를 직접 캡처하면 모든 람다가 같은 변수를 참조하게 되어 의도하지 않은 결과가 발생할 수 있습니다. 루프 내부에서 지역 변수에 복사하여 사용하세요.

### LINQ에서의 람다 사용

람다는 LINQ(Language Integrated Query)와 함께 사용될 때 특히 강력합니다.

```csharp
using System.Linq;

class Program
{
    static void Main()
    {
        List<Person> people = new()
        {
            new Person("Alice", 25, "Engineer"),
            new Person("Bob", 30, "Designer"),
            new Person("Charlie", 22, "Student"),
            new Person("Diana", 35, "Manager"),
            new Person("Eve", 28, "Engineer")
        };
        
        // 람다를 사용한 LINQ 쿼리
        var engineers = people.Where(p => p.Job == "Engineer");
        Console.WriteLine("엔지니어들:");
        foreach (var person in engineers)
        {
            Console.WriteLine($"- {person.Name} ({person.Age}세)");
        }
        
        // 나이 순 정렬
        var sortedByAge = people.OrderBy(p => p.Age);
        Console.WriteLine("\n나이 순 정렬:");
        foreach (var person in sortedByAge)
        {
            Console.WriteLine($"- {person.Name}: {person.Age}세");
        }
        
        // 이름과 직업 선택
        var namesAndJobs = people.Select(p => new { p.Name, p.Job });
        Console.WriteLine("\n이름과 직업:");
        foreach (var item in namesAndJobs)
        {
            Console.WriteLine($"- {item.Name}: {item.Job}");
        }
        
        // 조건에 맞는 첫 번째 요소 찾기
        var firstYoungPerson = people.FirstOrDefault(p => p.Age < 25);
        if (firstYoungPerson != null)
        {
            Console.WriteLine($"\n25세 미만 첫 번째 사람: {firstYoungPerson.Name}");
        }
        
        // 모든 사람이 특정 조건을 만족하는지 확인
        bool allAdults = people.All(p => p.Age >= 18);
        Console.WriteLine($"\n모두 성인인가? {allAdults}");
    }
}

public class Person
{
    public string Name { get; }
    public int Age { get; }
    public string Job { get; }
    
    public Person(string name, int age, string job)
    {
        Name = name;
        Age = age;
        Job = job;
    }
}
```

---

## 4. 이벤트(Event): 발행-구독 패턴 구현

이벤트는 델리게이트를 기반으로 한 발행-구독(Publish-Subscribe) 패턴의 구현입니다. 객체 간의 느슨한 결합을 제공하며, UI 프로그래밍과 비동기 프로그래밍에서 핵심적인 역할을 합니다.

### 기본 이벤트 구현

```csharp
public class TemperatureSensor
{
    // 1. 델리게이트 타입 정의 (일반적으로 EventHandler 또는 EventHandler<T> 사용)
    public delegate void TemperatureChangedHandler(object sender, TemperatureChangedEventArgs e);
    
    // 2. 이벤트 선언
    public event TemperatureChangedHandler TemperatureChanged;
    
    private double _currentTemperature;
    
    public double CurrentTemperature
    {
        get => _currentTemperature;
        set
        {
            if (_currentTemperature != value)
            {
                double oldTemperature = _currentTemperature;
                _currentTemperature = value;
                
                // 3. 이벤트 발생 (발행)
                OnTemperatureChanged(oldTemperature, value);
            }
        }
    }
    
    // 4. 이벤트를 발생시키는 보호된 메서드 (표준 패턴)
    protected virtual void OnTemperatureChanged(double oldTemp, double newTemp)
    {
        // 이벤트에 구독자가 있는지 확인 후 호출
        TemperatureChanged?.Invoke(this, new TemperatureChangedEventArgs(oldTemp, newTemp));
    }
}

// 5. 이벤트 데이터를 담는 클래스 (EventArgs에서 상속)
public class TemperatureChangedEventArgs : EventArgs
{
    public double OldTemperature { get; }
    public double NewTemperature { get; }
    
    public TemperatureChangedEventArgs(double oldTemp, double newTemp)
    {
        OldTemperature = oldTemp;
        NewTemperature = newTemp;
    }
}

// 사용 예제
class Program
{
    static void Main()
    {
        var sensor = new TemperatureSensor();
        
        // 6. 이벤트 구독 (+= 연산자 사용)
        sensor.TemperatureChanged += OnTemperatureChanged;
        
        // 온도 변경 (이벤트 발생)
        Console.WriteLine("온도 변경 중...");
        sensor.CurrentTemperature = 20.5;
        sensor.CurrentTemperature = 22.0;
        sensor.CurrentTemperature = 21.8;
        
        // 7. 이벤트 구독 해지 (-= 연산자 사용)
        sensor.TemperatureChanged -= OnTemperatureChanged;
        
        // 이제 이벤트를 받지 않음
        sensor.CurrentTemperature = 23.0;
    }
    
    // 이벤트 핸들러 메서드
    static void OnTemperatureChanged(object sender, TemperatureChangedEventArgs e)
    {
        Console.WriteLine($"온도 변경: {e.OldTemperature:F1}°C → {e.NewTemperature:F1}°C");
    }
}
```

### 표준 이벤트 패턴(EventHandler<T> 사용)

.NET에서는 `EventHandler<TEventArgs>` 델리게이트를 사용하는 표준 패턴을 권장합니다.

```csharp
public class Button
{
    // EventHandler<T>를 사용한 표준 이벤트 선언
    public event EventHandler<ButtonClickedEventArgs> Clicked;
    
    public string Label { get; }
    
    public Button(string label)
    {
        Label = label;
    }
    
    public void Click()
    {
        Console.WriteLine($"버튼 '{Label}'이(가) 클릭되었습니다.");
        
        // 이벤트 발생
        OnClicked(new ButtonClickedEventArgs(DateTime.Now));
    }
    
    protected virtual void OnClicked(ButtonClickedEventArgs e)
    {
        Clicked?.Invoke(this, e);
    }
}

public class ButtonClickedEventArgs : EventArgs
{
    public DateTime ClickTime { get; }
    
    public ButtonClickedEventArgs(DateTime clickTime)
    {
        ClickTime = clickTime;
    }
}

// 사용 예제
class Program
{
    static void Main()
    {
        var button = new Button("확인");
        
        // 람다를 사용한 이벤트 구독
        button.Clicked += (sender, e) =>
        {
            if (sender is Button btn)
            {
                Console.WriteLine($"버튼 '{btn.Label}' 클릭 이벤트 처리");
                Console.WriteLine($"클릭 시간: {e.ClickTime:HH:mm:ss}");
            }
        };
        
        // 이벤트 발생
        button.Click();
        
        // 여러 핸들러 등록 (멀티캐스트)
        button.Clicked += (sender, e) => Console.WriteLine("추가 핸들러 실행");
        
        button.Click();
    }
}
```

### 이벤트 접근자 커스터마이징

이벤트의 add/remove 접근자를 커스터마이징하여 추가 로직을 구현할 수 있습니다.

```csharp
public class EventLogger
{
    private EventHandler<LogEventArgs> _logEvent;
    
    public event EventHandler<LogEventArgs> Logged
    {
        add
        {
            // 구독 시 추가 로직
            Console.WriteLine($"새 구독자 추가: {value.Method.Name}");
            _logEvent += value;
        }
        remove
        {
            // 구독 해지 시 추가 로직
            Console.WriteLine($"구독자 제거: {value.Method.Name}");
            _logEvent -= value;
        }
    }
    
    public void Log(string message)
    {
        Console.WriteLine($"로그: {message}");
        _logEvent?.Invoke(this, new LogEventArgs(message, DateTime.Now));
    }
}

public class LogEventArgs : EventArgs
{
    public string Message { get; }
    public DateTime Timestamp { get; }
    
    public LogEventArgs(string message, DateTime timestamp)
    {
        Message = message;
        Timestamp = timestamp;
    }
}
```

---

## 5. 실전 예제: 온도 모니터링 시스템

델리게이트, 람다, 이벤트를 모두 활용한 실용적인 예제를 살펴보겠습니다.

```csharp
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

// 델리게이트 정의
public delegate void AlertHandler(string alertMessage);

// 이벤트 데이터 클래스
public class TemperatureReadingEventArgs : EventArgs
{
    public double Temperature { get; }
    public DateTime ReadingTime { get; }
    
    public TemperatureReadingEventArgs(double temperature)
    {
        Temperature = temperature;
        ReadingTime = DateTime.Now;
    }
}

// 온도 센서 클래스
public class TemperatureSensor
{
    private readonly Random _random = new();
    private double _currentTemperature = 20.0;
    private bool _isMonitoring = false;
    
    // 이벤트 선언
    public event EventHandler<TemperatureReadingEventArgs> TemperatureRead;
    public event EventHandler<TemperatureReadingEventArgs> HighTemperatureAlert;
    public event EventHandler<TemperatureReadingEventArgs> LowTemperatureAlert;
    
    // 델리게이트를 사용한 알림 시스템
    public event AlertHandler CustomAlert;
    
    public double CurrentTemperature => _currentTemperature;
    
    // 온도 읽기 (시뮬레이션)
    public void ReadTemperature()
    {
        // 온도 변화 시뮬레이션 (-5 ~ +5도 변화)
        double change = (_random.NextDouble() * 10) - 5;
        _currentTemperature += change;
        
        // 온도 읽기 이벤트 발생
        var args = new TemperatureReadingEventArgs(_currentTemperature);
        OnTemperatureRead(args);
        
        // 알림 조건 확인
        CheckAlerts(args);
    }
    
    protected virtual void OnTemperatureRead(TemperatureReadingEventArgs e)
    {
        TemperatureRead?.Invoke(this, e);
    }
    
    private void CheckAlerts(TemperatureReadingEventArgs e)
    {
        if (e.Temperature > 30.0)
        {
            HighTemperatureAlert?.Invoke(this, e);
            CustomAlert?.Invoke($"고온 경고: {e.Temperature:F1}°C");
        }
        else if (e.Temperature < 10.0)
        {
            LowTemperatureAlert?.Invoke(this, e);
            CustomAlert?.Invoke($"저온 경고: {e.Temperature:F1}°C");
        }
    }
    
    // 모니터링 시작
    public async Task StartMonitoringAsync(CancellationToken cancellationToken = default)
    {
        _isMonitoring = true;
        
        while (_isMonitoring && !cancellationToken.IsCancellationRequested)
        {
            ReadTemperature();
            await Task.Delay(1000, cancellationToken); // 1초마다 읽기
        }
    }
    
    public void StopMonitoring()
    {
        _isMonitoring = false;
    }
}

// 모니터링 디스플레이 클래스
public class TemperatureDisplay
{
    public void SubscribeToSensor(TemperatureSensor sensor)
    {
        // 람다를 사용한 이벤트 구독
        sensor.TemperatureRead += (sender, e) =>
        {
            Console.WriteLine($"[{e.ReadingTime:HH:mm:ss}] 온도: {e.Temperature:F1}°C");
        };
        
        sensor.HighTemperatureAlert += (sender, e) =>
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"[주의] 고온: {e.Temperature:F1}°C");
            Console.ResetColor();
        };
        
        sensor.LowTemperatureAlert += (sender, e) =>
        {
            Console.ForegroundColor = ConsoleColor.Blue;
            Console.WriteLine($"[주의] 저온: {e.Temperature:F1}°C");
            Console.ResetColor();
        };
    }
}

// 로깅 서비스 클래스
public class TemperatureLogger
{
    private readonly List<string> _logEntries = new();
    
    public void SubscribeToSensor(TemperatureSensor sensor)
    {
        // 메서드를 사용한 이벤트 구독
        sensor.TemperatureRead += OnTemperatureRead;
        sensor.CustomAlert += OnCustomAlert;
    }
    
    private void OnTemperatureRead(object sender, TemperatureReadingEventArgs e)
    {
        string logEntry = $"{e.ReadingTime:yyyy-MM-dd HH:mm:ss} | 온도: {e.Temperature:F1}°C";
        _logEntries.Add(logEntry);
    }
    
    private void OnCustomAlert(string alertMessage)
    {
        string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} | 알림: {alertMessage}";
        _logEntries.Add(logEntry);
        Console.WriteLine($"[로그] {logEntry}");
    }
    
    public void PrintLog()
    {
        Console.WriteLine("\n=== 온도 로그 ===");
        foreach (var entry in _logEntries)
        {
            Console.WriteLine(entry);
        }
    }
}

// Func 델리게이트를 사용한 데이터 처리
public class TemperatureAnalyzer
{
    private readonly List<double> _temperatureReadings = new();
    
    // Func 델리게이트를 매개변수로 받는 메서드
    public double Analyze(Func<List<double>, double> analysisFunction)
    {
        return analysisFunction(_temperatureReadings);
    }
    
    public void AddReading(double temperature)
    {
        _temperatureReadings.Add(temperature);
    }
    
    public void PrintAnalysis()
    {
        if (_temperatureReadings.Count == 0)
        {
            Console.WriteLine("분석할 데이터가 없습니다.");
            return;
        }
        
        // 다양한 분석 함수 정의
        Func<List<double>, double> average = readings =>
            readings.Sum() / readings.Count;
        
        Func<List<double>, double> max = readings =>
            readings.Max();
        
        Func<List<double>, double> min = readings =>
            readings.Min();
        
        Console.WriteLine("\n=== 온도 분석 ===");
        Console.WriteLine($"평균 온도: {Analyze(average):F1}°C");
        Console.WriteLine($"최고 온도: {Analyze(max):F1}°C");
        Console.WriteLine($"최저 온도: {Analyze(min):F1}°C");
        
        // 람다를 직접 전달
        double range = Analyze(readings => readings.Max() - readings.Min());
        Console.WriteLine($"온도 범위: {range:F1}°C");
    }
}

// 메인 프로그램
class Program
{
    static async Task Main()
    {
        Console.WriteLine("온도 모니터링 시스템 시작\n");
        
        var sensor = new TemperatureSensor();
        var display = new TemperatureDisplay();
        var logger = new TemperatureLogger();
        var analyzer = new TemperatureAnalyzer();
        
        // 이벤트 구독
        display.SubscribeToSensor(sensor);
        logger.SubscribeToSensor(sensor);
        
        // 델리게이트를 사용한 추가 알림
        sensor.CustomAlert += message => Console.WriteLine($"\n[시스템] {message}\n");
        
        // 온도 데이터를 분석기에 전달
        sensor.TemperatureRead += (sender, e) => analyzer.AddReading(e.Temperature);
        
        // 모니터링 시작 (10초간)
        var cts = new CancellationTokenSource();
        var monitoringTask = sensor.StartMonitoringAsync(cts.Token);
        
        Console.WriteLine("모니터링 중... (10초 후 종료)");
        await Task.Delay(10000);
        
        // 모니터링 중지
        cts.Cancel();
        sensor.StopMonitoring();
        
        try
        {
            await monitoringTask;
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("모니터링이 취소되었습니다.");
        }
        
        // 결과 출력
        Console.WriteLine("\n=== 모니터링 종료 ===");
        analyzer.PrintAnalysis();
        logger.PrintLog();
    }
}
```

---

## 결론: 올바른 도구 선택의 중요성

델리게이트, 람다, 이벤트는 C#에서 강력하고 표현력 있는 코드를 작성하는 데 필수적인 도구입니다. 각각의 적절한 사용처를 이해하는 것이 중요합니다:

1. **델리게이트(Delegate)** 는 **메서드를 값으로 다룰 수 있게 해주는 타입 안전한 메커니즘**입니다. 콜백 패턴, 전략 패턴, 그리고 이벤트의 기반으로 사용됩니다.

2. **람다 표현식(Lambda Expressions)** 은 **간결한 익명 함수 구문**으로, 델리게이트를 더 읽기 쉽고 작성하기 쉽게 만들어 줍니다. LINQ 쿼리, 이벤트 핸들러, 함수형 프로그래밍 스타일에 특히 유용합니다.

3. **이벤트(Events)** 는 **발행-구독 패턴의 표준 구현**으로, 객체 간의 느슨한 결합을 가능하게 합니다. UI 프로그래밍, 비동기 프로그래밍, 관찰자 패턴 구현에 필수적입니다.

이 세 가지 개념을 효과적으로 사용하기 위한 핵심 원칙을 정리해 보겠습니다:

**델리게이트 사용 시**:
- 타입 안전성을 보장하기 위해 명시적인 델리게이트 타입이나 제네릭 델리게이트(`Func`, `Action`, `Predicate`)를 사용하세요.
- 멀티캐스트 델리게이트를 사용할 때는 예외 처리와 반환값 처리에 주의하세요.

**람다 사용 시**:
- 간단한 연산에는 식 람다를, 복잡한 로직에는 문 람다를 사용하세요.
- 클로저를 사용할 때, 특히 루프 변수를 캡처할 때는 주의하세요.

**이벤트 사용 시**:
- 표준 이벤트 패턴(`EventHandler<TEventArgs>`)을 따르세요.
- 이벤트를 발생시킬 때는 항상 null 조건 연산자(`?.`)를 사용하세요.
- 메모리 누수를 방지하기 위해 이벤트 구독을 적절히 해지하세요.

이러한 개념들을 숙달하면, 더 유연하고 유지보수하기 쉬우며, 반응형인 C# 애플리케이션을 구축할 수 있습니다. 실제 프로젝트에서는 이 세 가지 도구를 조합하여 복잡한 비즈니스 로직을 명확하고 효율적으로 표현할 수 있습니다.