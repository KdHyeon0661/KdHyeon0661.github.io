---
layout: post
title: C# - 델리게이트, 람다, 이벤트
date: 2024-10-19 20:20:23 +0900
category: Csharp
---
# C# 델리게이트, 람다, 이벤트

## 0. 큰 그림

- **Delegate**: “메서드를 값처럼” 담는 **타입** (타입 안정 함수 포인터)
- **Lambda**: 델리게이트(혹은 `Func/Action`)를 간결히 만드는 **익명 함수 표기**
- **Event**: 델리게이트 기반 **발행-구독**(Pub/Sub) 메커니즘, 외부는 **+= / -=** 으로 구독/해지

---

## 1. 델리게이트 기초

### 1.1 선언·할당·호출

```csharp
public delegate int Calculator(int a, int b); // 델리게이트 타입

static int Add(int x, int y) => x + y;

static void Demo()
{
    Calculator calc = Add;     // 메서드 그룹 변환
    int result = calc(3, 4);   // 7
    Console.WriteLine(result);
}
```

- **서명 일치**(매개변수/반환형)가 필수.
- “메서드 그룹 → 델리게이트” 변환은 컴파일러가 수행.

### 1.2 멀티캐스트 델리게이트(Invocation List)

```csharp
public delegate void Notifier(string msg);

static void A(string m) => Console.WriteLine($"A:{m}");
static void B(string m) => Console.WriteLine($"B:{m}");

static void Multi()
{
    Notifier n = A;
    n += B;                 // 합성
    n("Hello");             // A:Hello \n B:Hello
    n -= A;                 // 분리
}
```

- `void` 반환형일 때 **모든 구독자를 순서대로 호출**.
- 반환형이 있을 경우 **마지막 호출의 반환값**이 결과가 된다(일반적으로 멀티캐스트엔 `void` 사용 권장).
- **예외**가 델리게이트 체인 중 하나에서 발생하면 **이후 호출은 중단** → 개별 호출 보호가 필요(§9.2).

### 1.3 델리게이트 결합/비교/제거

```csharp
var n = (Notifier)Delegate.Combine((Notifier)A, (Notifier)B);
n = (Notifier)Delegate.Remove(n, (Notifier)A);
```

일반적으로 `+=`, `-=` 사용이 안전·간결.

---

## 2. 익명 메서드 & 람다

### 2.1 익명 메서드(구문적 유산)

```csharp
Calculator calc = delegate (int a, int b) { return a * b; };
```

오늘날은 **람다**가 표준.

### 2.2 람다 표현식

```csharp
Calculator plus = (a, b) => a + b;

Func<int,int,int> mul = (x, y) => x * y;   // 반환값 O
Action<string> log = s => Console.WriteLine(s); // 반환값 X
Predicate<int> isEven = x => x % 2 == 0;   // bool 반환
```

- **식 람다**: `(args) => expr`
- **문 람다**: `(args) => { statements }`

### 2.3 클로저(캡처) 주의

```csharp
var acts = new List<Action>();
for (int i = 0; i < 3; i++)
{
    int captured = i; // 반드시 복사 변수 사용
    acts.Add(() => Console.WriteLine(captured));
}
// 0,1,2
```

루프 변수 직접 캡처는 **의도와 다른 값**이 출력될 수 있음.

### 2.4 `Expression<TDelegate>` vs `Func<>`

- `Func<>`는 **런타임 실행 대상**(LINQ to Objects)
- `Expression<Func<...>>`는 **식 트리**로 **번역 가능**(예: EF Core→SQL)

---

## 3. Func / Action / Predicate 카탈로그

- `Func<T1,..,TResult>`: **반환값 O**
- `Action<T1,..,Tn>`: **반환값 X**
- `Predicate<T>`: **bool 반환** (사실상 `Func<T,bool>`)

```csharp
Func<string, int> len = s => s.Length;
Action<int> print = n => Console.WriteLine(n);
Predicate<string> hasAt = s => s.Contains('@');
```

---

## 4. 이벤트(Event) 기초

### 4.1 이벤트 선언·발생·구독

```csharp
public delegate void OnChanged();

public class Switch
{
    public event OnChanged Flipped; // 외부는 += / -=만 가능

    public void Flip() => Flipped?.Invoke(); // 발생(발행)
}

static void DemoEvent()
{
    var sw = new Switch();
    sw.Flipped += () => Console.WriteLine("On!");
    sw.Flip(); // On!
}
```

- `event` 키워드는 **인스턴스 외부에서 호출 금지**(발생은 내부만).
- 외부는 `+=`(구독), `-=`(해지)만 가능 → **캡슐화**.

### 4.2 .NET 표준 이벤트 패턴 (EventHandler)

```csharp
public class ValueChangedEventArgs : EventArgs
{
    public int OldValue { get; }
    public int NewValue { get; }
    public ValueChangedEventArgs(int oldV, int newV) => (OldValue, NewValue) = (oldV, newV);
}

public class Counter
{
    private int _value;
    public event EventHandler<ValueChangedEventArgs> ValueChanged;

    public int Value
    {
        get => _value;
        set
        {
            if (_value == value) return;
            var old = _value;
            _value = value;
            ValueChanged?.Invoke(this, new ValueChangedEventArgs(old, _value));
        }
    }
}
```

- 시그니처: `void Handler(object? sender, TEventArgs e)`
- **sender**: 이벤트 소스, **EventArgs**: 데이터 컨테이너

---

## 5. 이벤트 고급: 접근자, 접근 한정, 정적 이벤트

### 5.1 커스텀 add/remove 접근자

```csharp
public class Notifier
{
    private EventHandler _changed;

    public event EventHandler Changed
    {
        add    { _changed = (EventHandler)Delegate.Combine(_changed, value); }
        remove { _changed = (EventHandler)Delegate.Remove (_changed, value); }
    }

    protected void OnChanged() => _changed?.Invoke(this, EventArgs.Empty);
}
```

- 로깅/필터링/Weak-참조 래핑 등 **구독 관리 커스터마이즈** 가능.

### 5.2 접근 한정

```csharp
public event EventHandler Changed;             // 어디서나 += / -=
public event EventHandler ChangedInternal;     // (기본) 선언 위치 접근자
public event EventHandler ChangedPrivate;      // 클래스 내부에서만 선언 가능
```

> 이벤트 **발생은 항상 내부**. 외부는 호출 불가.

### 5.3 정적 이벤트

```csharp
public static event EventHandler GlobalNotified;
```

- **정적 이벤트는 누수·수명 관리 난이도↑** → 해지/정리 필수.

---

## 6. 스레드·동시성 고려

### 6.1 발행 시 널 체크 경쟁 상태

```csharp
// C# 6+ null 조건 호출로 원자적 참조 읽기
SomeEvent?.Invoke(this, EventArgs.Empty);
```

> 예전 패턴: 현지 복사 후 null 체크

```csharp
var handler = SomeEvent;
handler?.Invoke(this, EventArgs.Empty);
```

### 6.2 UI 스레드 마샬링(WPF/WinForms/Avalonia)

```csharp
// WPF 예
Application.Current.Dispatcher.Invoke(() => ViewModel.Count++);

// WinForms 예
this.BeginInvoke(new Action(() => label1.Text = "Updated"));
```

이벤트 핸들러가 **백그라운드 스레드**에서 올 수 있음을 항상 고려.

### 6.3 비동기 핸들러

- 이벤트는 전통적으로 **동기 `void`** 를 기대.
- `async void` 핸들러는 예외 전파/테스트가 어려움 → 가능하면 **커맨드/메시지 버스**로 감싸기.
- 필요시 **예외 포착·로그**를 강제:

```csharp
SomeEvent += async (s, e) =>
{
    try { await DoAsync(); }
    catch(Exception ex) { Log(ex); }
};
```

---

## 7. 예외·오류 복원력

### 7.1 멀티캐스트에서 한 핸들러 예외 → 전체 중단

보호 호출 유틸리티:

```csharp
public static class EventSafe
{
    public static void InvokeAll(EventHandler ev, object sender, EventArgs e, Action<Exception> onError)
    {
        if (ev is null) return;
        foreach (EventHandler h in ev.GetInvocationList())
        {
            try { h(sender, e); }
            catch (Exception ex) { onError(ex); }
        }
    }
}
```

### 7.2 델리게이트 체인 반환 규칙

- `void`가 아니라면 **마지막 호출**의 반환값만 남는다 → **멀티캐스트엔 `void`를 사용**.

---

## 8. 메모리 관리·누수 방지

### 8.1 이벤트는 **소스가 구독자를 참조**(강한 참조)

- 긴 생명 소스(싱글톤/정적 이벤트)에 짧은 생명 객체가 구독 → GC 불가 → **메모리 누수**
- 원칙: **항상 -= 해지**, 또는 **수명 스코프**에 묶기

```csharp
IDisposable Subscribe<T>(ref EventHandler<T> ev, EventHandler<T> handler)
{
    ev += handler;
    return new Unsubscriber(() => ev -= handler);
}

readonly struct Unsubscriber : IDisposable
{
    private readonly Action _dispose;
    public Unsubscriber(Action d) => _dispose = d;
    public void Dispose() => _dispose?.Invoke();
}
```

사용:

```csharp
using var sub = Subscribe(ref thing.Changed, OnChanged);
// scope 종료 시 자동 해지
```

### 8.2 Weak Event 패턴(간단 버전)

```csharp
public sealed class WeakHandler<T>
{
    private readonly WeakReference _target;
    private readonly MethodInfo _method;

    public WeakHandler(Delegate d)
    {
        _target = new WeakReference(d.Target);
        _method = d.Method;
    }

    public bool Invoke(object sender, T args)
    {
        var t = _target.Target;
        if (t is null) return false;
        _method.Invoke(t, new object[] { sender, args });
        return true;
    }
}
```

실전에서는 **WPF WeakEventManager**, **이벤트 중개자**(§10) 또는 **Rx** 권장.

---

## 9. 실전 패턴

### 9.1 이벤트 → 명령(Command)·콜백 래핑

```csharp
public class Button
{
    public event EventHandler Click;
    public void Fire() => Click?.Invoke(this, EventArgs.Empty);
}

public class Controller
{
    public Controller(Button b)
    {
        b.Click += OnClick;
    }
    private void OnClick(object? s, EventArgs e) => Execute();
    private void Execute() => Console.WriteLine("Run!");
}
```

UI에서는 **ICommand**(WPF/MAUI)로 바인딩하는 것이 테스트/바인딩에 유리.

### 9.2 안전 브로드캐스트(예외 격리)

```csharp
public static void BroadcastSafely(EventHandler ev, object sender, EventArgs e)
{
    foreach (EventHandler h in ev.GetInvocationList())
    {
        try { h(sender, e); }
        catch (Exception ex) { /* log */ }
    }
}
```

### 9.3 Event Aggregator (메시지 버스)

여러 모듈 간 결합도 ↓, 테스트/추적 용이:

```csharp
public interface IEvent {}

public sealed class EventBus
{
    private readonly Dictionary<Type, List<Delegate>> _subs = new();

    public IDisposable Subscribe<T>(Action<T> h) where T : IEvent
    {
        var t = typeof(T);
        if (!_subs.TryGetValue(t, out var list)) _subs[t] = list = new();
        list.Add(h);
        return new Unsubscriber(() => list.Remove(h));
    }

    public void Publish<T>(T e) where T : IEvent
    {
        if (_subs.TryGetValue(typeof(T), out var list))
            foreach (var d in list.ToArray())
                ((Action<T>)d)(e);
    }

    private sealed class Unsubscriber : IDisposable
    {
        private readonly Action _dispose;
        public Unsubscriber(Action d) => _dispose = d;
        public void Dispose() => _dispose();
    }
}
```

사용:

```csharp
public record UserLoggedIn(string Name) : IEvent;

var bus = new EventBus();
using var sub = bus.Subscribe<UserLoggedIn>(e => Console.WriteLine($"Hi {e.Name}"));
bus.Publish(new UserLoggedIn("Alice"));
```

### 9.4 Rx(Reactive Extensions) 대안

- **이벤트 → IObservable<T>**로 래핑하여 **구성·필터·스로틀/버퍼** 등 강력한 연산 사용:

```csharp
// System.Reactive.Linq
IObservable<EventPattern<EventArgs>> stream =
    Observable.FromEventPattern(h => btn.Click += h, h => btn.Click -= h);

using var sub = stream
    .Throttle(TimeSpan.FromMilliseconds(250))
    .Subscribe(_ => Console.WriteLine("Throttled click!"));
```

---

## 10. 비동기 이벤트 설계

전통 이벤트는 동기 `void`. 비동기는 다음처럼 **명시적 API**로:

```csharp
public interface IAsyncNotifier
{
    Task NotifyAsync(CancellationToken ct = default);
}

public class Worker : IAsyncNotifier
{
    public event Func<CancellationToken, Task> AsyncNotified;

    public Task NotifyAsync(CancellationToken ct = default) =>
        AsyncNotified is null
            ? Task.CompletedTask
            : Task.WhenAll(AsyncNotified
                .GetInvocationList()
                .Cast<Func<CancellationToken,Task>>()
                .Select(f => SafeCall(f, ct)));

    static async Task SafeCall(Func<CancellationToken,Task> f, CancellationToken ct)
    {
        try { await f(ct).ConfigureAwait(false); }
        catch (Exception ex) { /* log */ }
    }
}
```

- **반드시 `Task`를 반환**하여 예외/완료를 추적.
- 전통 `event`와 혼용하지 말고 **인터페이스로 분리**하는 것이 명확.

---

## 11. 성능·복잡도 직관

- 멀티캐스트 델리게이트 호출 비용은 **구독자 수**에 선형:

$$
T_{\text{invoke}} \approx \sum_{i=1}^{N} t_i \quad (\text{대략 } O(N))
$$

- 고빈도(핫패스) 이벤트는 **구독자 수 제한**, 또는 **폴링/관측 주기 조절** 고려.
- 빈번한 구독/해지 → **락 경합/할당** 비용 고려(특히 정적 이벤트).

---

## 12. 테스트·디버깅·로깅

- 구독 지점 로깅:

```csharp
btn.Click += Handler;
Console.WriteLine($"Subscribed {nameof(Handler)}");
btn.Click -= Handler;
```

- **InvocationList 덤프**로 구독자 추적:

```csharp
static void Dump(EventHandler ev)
{
    if (ev is null) return;
    foreach (var d in ev.GetInvocationList())
        Console.WriteLine($"{d.Method.DeclaringType?.Name}.{d.Method.Name}");
}
```

- **메모리 덤프**(정적 이벤트 누수), **WeakEvent** / **IDisposable 구독**로 예방.

---

## 13. 종합 예제 — “문서 다운로드 매니저”

요구:
1) **진행률** 이벤트(0~100%)
2) **상태 변경** 이벤트(Started/Completed/Failed)
3) **비동기 알림**(리스너가 비동기로 UI 업데이트)
4) 멀티 리스너 예외가 전체를 깨지 않게

```csharp
public enum DownloadState { None, Started, Progress, Completed, Failed }

public class ProgressEventArgs : EventArgs
{
    public int Percent { get; }
    public ProgressEventArgs(int p) => Percent = p;
}

public class StateEventArgs : EventArgs
{
    public DownloadState State { get; }
    public Exception Error { get; }
    public StateEventArgs(DownloadState s, Exception? e = null) => (State, Error) = (s, e);
}

public sealed class DownloadManager
{
    public event EventHandler<ProgressEventArgs> ProgressChanged;
    public event EventHandler<StateEventArgs> StateChanged;

    // async listener 패턴(§10)
    public event Func<StateEventArgs, Task> StateChangedAsync;

    private void RaiseProgress(int p)
    {
        var ev = ProgressChanged;
        if (ev is null) return;
        foreach (EventHandler<ProgressEventArgs> h in ev.GetInvocationList())
        {
            try { h(this, new ProgressEventArgs(p)); }
            catch (Exception ex) { /* log ex, continue */ }
        }
    }

    private void RaiseState(DownloadState s, Exception? e = null)
    {
        var ev = StateChanged;
        ev?.Invoke(this, new StateEventArgs(s, e));
    }

    private async Task RaiseStateAsync(DownloadState s, Exception? e = null)
    {
        var ev = StateChangedAsync;
        if (ev is null) return;
        var args = new StateEventArgs(s, e);
        var tasks = ev.GetInvocationList()
            .Cast<Func<StateEventArgs, Task>>()
            .Select(async f =>
            {
                try { await f(args).ConfigureAwait(false); }
                catch (Exception ex) { /* log */ }
            });
        await Task.WhenAll(tasks).ConfigureAwait(false);
    }

    public async Task DownloadAsync(Uri url, CancellationToken ct = default)
    {
        RaiseState(DownloadState.Started);
        await RaiseStateAsync(DownloadState.Started);

        try
        {
            for (int p = 0; p <= 100; p += 10)
            {
                ct.ThrowIfCancellationRequested();
                await Task.Delay(50, ct); // 모의 다운로드
                RaiseProgress(p);
            }
            RaiseState(DownloadState.Completed);
            await RaiseStateAsync(DownloadState.Completed);
        }
        catch (Exception ex)
        {
            RaiseState(DownloadState.Failed, ex);
            await RaiseStateAsync(DownloadState.Failed, ex);
        }
    }
}
```

사용:

```csharp
var dm = new DownloadManager();
dm.ProgressChanged += (s, e) => Console.WriteLine($"Progress: {e.Percent}%");
dm.StateChanged += (s, e) => Console.WriteLine($"State: {e.State} (sync)");

dm.StateChangedAsync += async e =>
{
    await Task.Delay(10);
    Console.WriteLine($"[Async] {e.State}");
};

await dm.DownloadAsync(new Uri("https://example.com/file.bin"));
```

---

## 14. 체크리스트

**설계**
- [ ] 외부 계약은 **event + EventHandler<T>**(표준 패턴) 사용
- [ ] 고빈도 이벤트는 **데이터 최소화**(작은 EventArgs)
- [ ] 비동기는 **Task 반환 API**로 분리(§10)

**안전성**
- [ ] 구독자 예외 **격리 처리**(§7.1)
- [ ] UI 업데이트는 **디스패처**로 마샬링(§6.2)
- [ ] 정적/싱글톤 이벤트는 **해지·수명 관리**(§8)

**성능**
- [ ] 멀티캐스트 호출 비용=구독자 수 선형(§11)
- [ ] 잦은 구독/해지의 할당/락 고려 → **일회 구독 + 재사용** 또는 **버스 도입**

**테스트**
- [ ] InvocationList 검사/로그
- [ ] 구독/해지 누락 시 누수 테스트(정적 이벤트 특히)

---

## 15. 요약

- **Delegate**: 타입 안정 **함수 참조**
- **Lambda**: 간결한 **익명 함수**(클로저 주의)
- **Event**: 델리게이트 기반 **Pub/Sub**. 외부는 `+= / -=`만, 발생은 내부.
- **표준 이벤트 패턴**: `EventHandler<TEventArgs>`
- **실전**: 예외 격리, 스레드 마샬링, 비동기 패턴 분리, 누수 방지(해지/Weak/Rx), 고빈도 비용 고려

이 가이드를 베이스로, UI(WinForms/WPF/MAUI), 서버(ASP.NET Core), 데이터 파이프라인, IoT 등 어디서든 **안전하고 확장 가능한 이벤트 아키텍처**를 설계할 수 있다.
