---
layout: post
title: 정보보안기사 - API/마이크로서비스 보안
date: 2025-11-09 20:25:23 +0900
category: 정보보안기사
---
# API/마이크로서비스 보안 — **인증·인가·레이트리밋·스키마 검증** (실전 예제·운영 체크리스트)

> **목표**  
> - API와 마이크로서비스의 보안을 “엣지→게이트웨이→서비스→데이터” 전 구간에 내장합니다.  
> - **인증(AuthN)**, **인가(AuthZ)**, **레이트리밋(Rate Limit)**, **스키마 검증(Schema Validation)**을 코드와 설정 예제로 설명합니다.  
> - 코드는 ``` 로 감싸고, 수식은 $$ 로 감쌉니다. 실환경 적용 전 반드시 스테이징에서 검증하세요.

---

## 0) 큰그림 (Edge → Mesh → Service → Data)

```
[Client/SPA] --(OIDC/OAuth2)--> [API Gateway (JWT 검증, Rate Limit, WAF, TLS)]
                                     |                \
                                     |(mTLS)           \ (OPA/외부 인가)
                                     v                 v
                           [Service Mesh/Envoy, mTLS, AuthZ]
                                     |
                                     v
                           [Microservices (입/출력 스키마 검증, ABAC)]
                                     |
                                     v
                               [DB (Row Level Security)]
```

- **엣지(API GW)**: TLS/HSTS, JWT·API키·mTLS 검증, IP/사용자/클라이언트별 레이트리밋, 스키마 1차 검증.  
- **메시/사이드카**: 서비스 간 **mTLS**, 서비스ID(SPIFFE) 기반 인가, 중앙 레이트리밋/감시.  
- **서비스**: 입력·출력 **스키마 검증**, **오브젝트/테넌트 수준 권한 검증**.  
- **데이터**: RLS(행 수준 보안), 최소권한 커넥션, 감사.

---

# 1) 인증(AuthN)

## 1.1 사용자→API (OIDC/OAuth2)

- **권장**:  
  - SPA/모바일: **Authorization Code + PKCE**.  
  - 서버→API(M2M): **Client Credentials**.  
  - 토큰: **JWT(Access, 짧은 수명)**, RS256/ES256, JWKS로 키 회전.

### [Node.js/Express] — **JWT 검증 + JWKS** (kid 회전 대응)
```javascript
// npm i express jsonwebtoken jwks-rsa helmet
const express = require('express');
const jwt = require('jsonwebtoken');
const jwks = require('jwks-rsa');
const helmet = require('helmet');

const app = express();
app.use(helmet());

const jwksClient = jwks({ jwksUri: 'https://idp.example.com/.well-known/jwks.json', cache: true, cacheMaxEntries: 5, cacheMaxAge: 10 * 60 * 1000 });

function getKey(header, cb) {
  jwksClient.getSigningKey(header.kid, (err, key) => {
    if (err) return cb(err);
    cb(null, key.getPublicKey());
  });
}

function requireJWT(aud) {
  return (req, res, next) => {
    const token = (req.headers.authorization || '').replace(/^Bearer /, '');
    jwt.verify(token, getKey, {
      algorithms: ['RS256', 'ES256'],
      audience: aud,
      issuer: 'https://idp.example.com'
    }, (err, decoded) => err ? res.sendStatus(401) : (req.user = decoded, next()));
  };
}

app.get('/me/orders', requireJWT('orders-api'), (req, res) => {
  res.json({ user: req.user.sub, orders: [] });
});

app.listen(8080);
```

**체크포인트**
- `iss/aud/exp/nbf/alg/kid` 검증, **`alg=none` 금지**.  
- **짧은 수명** Access 토큰(예: 5~15분). Refresh는 **회전**(1회용)·서버 저장.

---

## 1.2 서비스→서비스 (mTLS + SPIFFE/SVID)

- **원칙**: 서비스 간 통신은 **네트워크를 신뢰하지 않음**.  
- **mTLS**로 **상호 인증** + **ID(서비스 계정) 바인딩**.  
- SPIFFE/SPIRE를 사용하면 SVID(스핏피 ID)로 서비스 아이덴티티를 표준화.

### [Istio] 엄격 mTLS + 서비스 식별(요약)
```yaml
# mTLS 강제
apiVersion: security.istio.io/v1
kind: PeerAuthentication
metadata: { name: mesh-mtls }
spec: { mtls: { mode: STRICT } }

# orders 서비스로 호출 가능한 주체 제한 (AuthorizationPolicy)
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata: { name: orders-allow-web, namespace: prod }
spec:
  selector: { matchLabels: { app: orders } }
  rules:
  - from:
    - source:
        principals: ["spiffe://cluster.local/ns/prod/sa/web-sa"]
```

---

## 1.3 API 키 / HMAC 서명 (Webhook·레거시/단순 통합)

- **API 키**는 “이용자 식별자”이지 신뢰의 근거가 약합니다 → **범위를 제한**(권한 최소), **레이트리밋 강화**.  
- **HMAC 서명**: 본문+타임스탬프에 대해 **공유키**로 HMAC 생성·검증 → **재생공격 윈도우 축소**.

### [Node] HMAC 서명 검증 (Webhook)
```javascript
const crypto = require('crypto');

function verifyHMAC(req, secret) {
  const ts = req.headers['x-webhook-timestamp'];
  if (!ts || Math.abs(Date.now() - Number(ts)) > 5 * 60 * 1000) return false; // 5분 이내만 허용

  const body = JSON.stringify(req.body || {});
  const mac = crypto.createHmac('sha256', secret).update(ts + '.' + body).digest('hex');
  const sig = String(req.headers['x-webhook-signature'] || '');
  return crypto.timingSafeEqual(Buffer.from(mac), Buffer.from(sig));
}
```

---

# 2) 인가(AuthZ)

## 2.1 RBAC vs ABAC, 객체/테넌트 수준

- **RBAC**: 역할 기반(예: `admin`, `ops`, `user`). 단순·명료.  
- **ABAC**: 속성 기반(사용자·자원·환경 속성). 미세 제어.  
- **핵심**: **오브젝트 레벨 권한**(IDOR 방지) + **테넌트 격리**.

### [Express] 오브젝트(수평) + 역할(수직)
```javascript
function requireRole(role){ return (req,res,next)=> req.user.roles?.includes(role) ? next() : res.sendStatus(403); }

app.get('/orders/:id', async (req,res)=>{
  const o = await db('orders').where({ id: req.params.id, owner_id: req.user.sub }).first();
  if(!o) return res.sendStatus(404);
  res.json(o);
});

app.post('/admin/users', requireRole('admin'), async (req,res)=> { /* ... */ });
```

### [OPA/Rego + Envoy] ABAC (경로·메서드·클레임)
```rego
# package http.authz
default allow = false

allow {
  input.parsed_path = ["orders", id]
  input.parsed_method == "GET"
  input.jwt.payload.aud == "orders-api"
  input.jwt.payload.sub == data.orders[id].owner
}

# data.orders는 캐시/외부 조회로 소유권 확인(개념 예시)
```

### [PostgreSQL] Row Level Security (멀티테넌트)
```sql
-- 테넌트ID를 세션 변수(또는 JWT)로 바인딩하는 전략
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation ON orders
USING (tenant_id = current_setting('app.tenant_id')::uuid);

-- 애플리케이션 커넥션 시:
-- SET app.tenant_id = '<JWT의 tenant_id>';
```

---

# 3) 레이트리밋 (Rate Limiting)

## 3.1 알고리즘 요약

- **고정 윈도우**: 구현 간단, 경계 바이어스.  
- **슬라이딩 윈도우**: 정확, 구현/저장 부담.  
- **토큰 버킷(Token Bucket)**: 초과 대비 **버스트 허용** + 평균률 제어.

**토큰 버킷 직관**  
- 버킷 용량 \(C\), 초당 토큰 보충률 \(r\), 요청당 비용 \(c\).  
- 허용 조건: **현재 토큰 \(T \ge c\)**, 허용 후 \(T := T-c\); 시간 경과에 따라 \(T := \min(C, T + r\cdot \Delta t)\).

## 3.2 엣지/프록시에서 — NGINX

```nginx
# IP별 5r/s, 버스트 20
limit_req_zone $binary_remote_addr zone=req_ip:10m rate=5r/s;

server {
  listen 443 ssl http2;
  server_name api.example.com;

  location /v1/ {
    limit_req zone=req_ip burst=20 nodelay;
    proxy_pass http://app:8080;
  }
}
```

## 3.3 Envoy + Redis 전역 레이트리밋 (개념)

```yaml
# HTTP Connection Manager 내 필터 체인 일부
- name: envoy.filters.http.ratelimit
  typed_config:
    "@type": type.googleapis.com/envoy.extensions.filters.http.ratelimit.v3.RateLimit
    domain: "api"
    timeout: 0.05s
    failure_mode_deny: false
    rate_limit_service:
      grpc_service:
        envoy_grpc: { cluster_name: rate_limit_cluster }
```

**규칙**: `descriptor: [ { "key": "user", "value": "<sub>" }, { "key": "path", "value": "/orders" } ]` 로 **사용자·경로 단위** 제어.

## 3.4 애플리케이션 레벨 — Redis 토큰 버킷

```javascript
// npm i ioredis
const Redis = require('ioredis');
const redis = new Redis(process.env.REDIS_URL);

/** userId, key(메서드+경로), rate r/s, capacity C */
async function tokenBucket(userId, key, r=5, C=20) {
  const now = Date.now();
  const kState = `tb:${userId}:${key}:state`;
  const kTime  = `tb:${userId}:${key}:time`;
  const [state, prev] = await redis.mget(kState, kTime);
  let T = Number(state || C), t0 = Number(prev || now);
  const dt = Math.max(0, now - t0) / 1000;
  T = Math.min(C, T + r * dt);
  if (T < 1) return { ok:false, retryAfter: Math.ceil((1 - T)/r) };
  await redis.multi().set(kState, (T - 1).toFixed(3)).set(kTime, String(now)).exec();
  return { ok:true };
}

// 미들웨어
async function rateLimit(req, res, next) {
  const user = req.user?.sub || req.ip;
  const key = `${req.method}:${req.path.split('/')[1]}`;
  const { ok, retryAfter } = await tokenBucket(user, key, 10, 30);
  if (!ok) return res.set('Retry-After', String(retryAfter)).status(429).json({ error: 'rate_limited' });
  next();
}
```

**권장 정책**  
- **IP 별** 기본, **사용자/클라이언트ID 별** 추가, **민감 엔드포인트**(로그인/결제) 강화.  
- 응답에 `Retry-After`, 경고 헤더(`X-RateLimit-*`) 제공.

---

# 4) 스키마 검증 (Schema Validation)

## 4.1 OpenAPI/JSON Schema — 계약 우선

- **입력/출력 스키마**를 **명세**로 먼저 정의 → 서버/클라이언트 **코드 생성**.  
- **명세 린팅**(Spectral), **계약 테스트**로 **드리프트 방지**.

### [OpenAPI 3.1] — /orders POST 예시(발췌)
```yaml
openapi: 3.1.0
info: { title: Orders API, version: 1.0.0 }
paths:
  /orders:
    post:
      security: [{ bearerAuth: [] }]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/NewOrder'
      responses:
        '201':
          description: Created
          content:
            application/json:
              schema: { $ref: '#/components/schemas/Order' }
components:
  securitySchemes:
    bearerAuth: { type: http, scheme: bearer, bearerFormat: JWT }
  schemas:
    NewOrder:
      type: object
      required: [items, currency]
      properties:
        items:
          type: array
          minItems: 1
          items:
            type: object
            required: [sku, qty]
            properties:
              sku: { type: string, pattern: "^[A-Z0-9_-]{3,32}$" }
              qty: { type: integer, minimum: 1, maximum: 100 }
        currency: { type: string, enum: ["KRW","USD","EUR"] }
    Order:
      allOf:
        - $ref: '#/components/schemas/NewOrder'
        - type: object
          required: [id, owner, total]
          properties:
            id: { type: string, format: uuid }
            owner: { type: string } # user sub
            total: { type: integer, minimum: 0 }
```

## 4.2 서버에서 스키마 검증 — AJV (Node)

```javascript
// npm i ajv
const Ajv = require('ajv');
const ajv = new Ajv({ allErrors: true, removeAdditional: 'failing' });

const newOrderSchema = {/* 위 OpenAPI의 NewOrder에 해당 (JSON Schema) */};

const validateNewOrder = ajv.compile(newOrderSchema);

app.post('/orders', requireJWT('orders-api'), (req, res) => {
  if (!validateNewOrder(req.body)) return res.status(400).json({ error: 'invalid', details: validateNewOrder.errors });
  // ... 서버측 가격/재고 재평가(클라이언트 값 신뢰 금지)
  res.status(201).json({ ...req.body, id: uuid(), owner: req.user.sub, total: 12345 });
});
```

## 4.3 Python/FastAPI — 입력/출력 모델(Pydantic)

```python
# pip install fastapi uvicorn
from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel, Field, constr, conint
from uuid import UUID, uuid4

class Item(BaseModel):
    sku: constr(regex=r'^[A-Z0-9_-]{3,32}$')
    qty: conint(ge=1, le=100)

class NewOrder(BaseModel):
    items: list[Item] = Field(min_length=1)
    currency: constr(pattern='^(KRW|USD|EUR)$')

class Order(NewOrder):
    id: UUID
    owner: str
    total: conint(ge=0)

app = FastAPI()

@app.post("/orders", response_model=Order, status_code=201)
def create_order(order: NewOrder, user=Depends(require_jwt)):  # require_jwt은 생략
    # 서버측 가격 재계산 / 권한 검사
    return Order(**order.dict(), id=uuid4(), owner=user["sub"], total=12345)
```

**포인트**  
- **입/출력 모두 검증**(출력 검증은 데이터 누수 방지).  
- **정규화/캐논컬라이즈**(공백·케이스, Unicode).

---

# 5) 게이트웨이/메시 가드레일 (Envoy/NGINX)

## 5.1 Envoy — JWT + 외부 인가 + 레이트리밋 (요약)

```yaml
static_resources:
  listeners:
  - name: https
    address: { socket_address: { address: 0.0.0.0, port_value: 443 } }
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          route_config:
            virtual_hosts:
            - name: orders
              domains: ["api.example.com"]
              routes:
              - match: { prefix: "/orders" }
                route: { cluster: orders_svc }
          http_filters:
          - name: envoy.filters.http.jwt_authn
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
              providers:
                oidc:
                  issuer: "https://idp.example.com"
                  audiences: ["orders-api"]
                  remote_jwks: { http_uri: { uri: "https://idp.example.com/jwks.json", cluster: idp } }
              rules:
              - match: { prefix: "/orders" }
                requires: { provider_name: "oidc" }
          - name: envoy.filters.http.ratelimit
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.ratelimit.v3.RateLimit
              domain: "api"
              rate_limit_service: { grpc_service: { envoy_grpc: { cluster_name: rate_limit_cluster } } }
          - name: envoy.filters.http.ext_authz
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
              http_service:
                server_uri: { uri: "http://opa:8181", cluster: opa_cluster, timeout: 0.2s }
                path_prefix: /v1/data/http/authz/allow
          - name: envoy.filters.http.router
```

## 5.2 NGINX — TLS/HSTS + 헤더 위생 + 레이트리밋

```nginx
server {
  listen 443 ssl http2;
  server_name api.example.com;

  ssl_certificate /etc/nginx/fullchain.pem;
  ssl_certificate_key /etc/nginx/privkey.pem;
  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
  add_header X-Content-Type-Options "nosniff" always;
  add_header X-Frame-Options "DENY" always;

  limit_req_zone $binary_remote_addr zone=req:10m rate=10r/s;

  location /v1/ {
    limit_req zone=req burst=30 nodelay;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $remote_addr;
    proxy_pass http://svc:8080;
  }
}
```

---

# 6) 에러/로그/추적 (개인정보·보안)

- **표준 에러 스펙**(status, code, message, details) — 내부 스택/쿼리 노출 금지.  
- **구조화 로그(JSON)**, **Trace/Span ID**(분산 트레이싱), **PII 마스킹**.  
- **보안 이벤트**: 인증 실패/거부(403) 폭증, 레이트리밋(429), 인가 실패, 스키마 에러.

```json
{"ts":"2025-11-04T01:33:00+09:00","sev":"WARN","trace":"74de","actor":"user:42","path":"/orders/abcd","result":"deny","reason":"schema_invalid"}
```

---

# 7) 리플레이 방지·멱등성 (Idempotency)

## 7.1 멱등 키 (결제/주문)

- 클라이언트가 `Idempotency-Key` 헤더 제공 → **서버는 키별 “요청 본문 해시와 결과” 캐시**.  
- 재시도 시 **동일 결과 반환**, 중복 처리 방지.

### [Node + Redis] 멱등 구현 스케치
```javascript
async function idempotent(handler) {
  return async (req, res) => {
    const key = req.get('Idempotency-Key');
    if (!key) return res.status(400).json({ error: 'missing_idempotency_key' });

    const cacheKey = `idem:${key}`;
    const cached = await redis.get(cacheKey);
    if (cached) return res.set('Idempotency-Cache', 'HIT').status(200).send(cached);

    const result = await handler(req); // 실제 처리
    await redis.setex(cacheKey, 60 * 60, JSON.stringify(result));
    res.set('Idempotency-Cache', 'STORE').status(200).json(result);
  };
}
```

## 7.2 재생 공격(서명 요청) 타임윈도우

- 요청 헤더에 `Date` 또는 `X-Timestamp` 포함, **HMAC 서명**에 포함.  
- 서버는 **±5분** 등 윈도우 밖 요청 거부.

---

# 8) 자주 나오는 **취약 구성/반패턴** → 교정

1) **게이트웨이에서만 JWT 검증**하고 내부 서비스에서 **신뢰** → 내부 우회 시 IDOR/권한상승.  
   - **대응**: 서비스도 **`aud/iss/sub`** 재검증, **오브젝트 소유권** 검사.  
2) **CORS `*`+`credentials:true`** → 크로스 도메인 세션 노출.  
   - **대응**: 정확한 오리진 화이트리스트, 토큰 기반 권장.  
3) **스키마 미검증** → 큰 페이로드/오염 필드/타입 혼동.  
   - **대응**: 입력·출력 스키마 강제, 크기 제한(예: 1MB).  
4) **전역 레이트리밋만** → 특정 사용자/클라이언트 폭주 방치.  
   - **대응**: **IP+User+Client** 조합, 엔드포인트별 차등.  
5) **오류 상세 노출** → SQL/Stack/경로 유출.  
   - **대응**: 사용자 메시지는 일반화, 내부 ID로 상관.

---

# 9) 시나리오형 실전

## 9.1 “주문 API” — 보안 설계 카드

- **AuthN**: OIDC JWT (aud=`orders-api`), mTLS(서비스 간).  
- **AuthZ**: `/orders/:id`는 `owner_id==sub` 조건, 관리자 전용 경로 분리.  
- **Rate**: `POST /orders` 사용자별 **10 r/m**, `GET /orders` **60 r/m**.  
- **Schema**: `NewOrder` 스키마(아이템 최소1, SKU 패턴, qty 1~100).  
- **Idempotency**: `POST /orders`는 헤더 필수.  
- **Logging**: TraceID, actor, path, result, reason.  
- **Runbook**: 429/403 급증 시 알람 → 토큰 클레임·레이트리밋 히트 확인.

## 9.2 “웹훅 수신” — 보안 설계 카드

- **HMAC 서명 + 타임스탬프** (±5분).  
- **스키마 검증**: 이벤트 타입/필수 필드.  
- **재시도 정책**: 멱등키 저장, 중복 처리 금지.  
- **네트워크**: 송신자 IP 범위 화이트리스트.

---

# 10) 테스트(DevSecOps)

- **SAST**: 인젝션/경로탐색/취약 API 호출.  
- **DAST**: 인증 포함 시나리오(권한 경계 테스트).  
- **계약 테스트**: OpenAPI 대조(요청/응답 스키마).  
- **보안 린트**: Semgrep `p/owasp-top-ten` + 커스텀 룰(예: `where({id: req.params.id})` 경고).  
- **성능/리밋 테스트**: 레이트리밋 429/Retry-After 확인, 버스트/평균률.

```yaml
# GitHub Actions 발췌
- name: SAST (Semgrep)
  uses: returntocorp/semgrep-action@v1
  with: { config: p/owasp-top-ten }
- name: Contract Test
  run: npx @redocly/cli lint openapi.yaml
```

---

# 11) 운영 체크리스트

## 인증
- [ ] JWT `iss/aud/exp/nbf/alg/kid` 검증, JWKS 캐시/회전  
- [ ] 서비스 간 **mTLS**(SPIFFE 권장), SAN/SPIFFE ID 매칭  
- [ ] API 키는 **권한 최소**·회전·사용량 감시

## 인가
- [ ] 오브젝트 소유권/테넌트 ID 강제(쿼리 조건·RLS)  
- [ ] 역할/스코프 매핑(`orders:read`/`write`) 문서화  
- [ ] 중앙 정책(OPA/Rego 등) 변경 추적

## 레이트리밋
- [ ] IP·User·ClientID·경로별 다층 정책  
- [ ] 429 응답·`Retry-After`·경고 헤더  
- [ ] Redis/서비스 상태 점검, 실패 시 우회운영 범위 정의

## 스키마
- [ ] 입력/출력 JSON Schema 강제, 페이로드 한도  
- [ ] OpenAPI 린트/계약 테스트  
- [ ] 버전 전략(v1→v2) 및 감가상각 계획

## 로깅/운영
- [ ] 구조화 로그, TraceID, PII 마스킹  
- [ ] 401/403/429/5xx 이상치 알람  
- [ ] 비밀/키/토큰 수명·회전 주기

---

# 12) 연습문제(예상·해설)

1) **문**: JWT 검증에서 **반드시** 확인해야 할 5개 필드는?  
   **정답**: `iss`, `aud`, `exp`, `nbf`(선택), `alg`(허용알고리즘 목록 고정), `kid`(JWKS 키 선택).

2) **문**: `/orders/:id` IDOR 방지 서버 코드 핵심 한 줄은?  
   **정답**: `where({ id: params.id, owner_id: req.user.sub })` (또는 DB RLS).

3) **문**: 토큰 버킷에서 버킷 용량 C=30, 보충률 r=10 r/s. 현재 토큰 T=5일 때 8개 요청을 즉시 허용 가능한가?  
   **정답(수식)**: $$ T - 8 < 0 \Rightarrow \text{불가} $$ → 약 \( (8-5)/10 = 0.3 \)초 대기 후 가능.

4) **문**: 웹훅 재생 공격 방어 2가지?  
   **정답**: 타임스탬프+HMAC 서명, 멱등키 저장 및 재사용 차단.

5) **문**: OpenAPI 스키마 검증을 서비스 **응답**에도 적용하는 이유?  
   **정답**: 데이터 누출/내부 필드 출력 방지, 계약 안정성 보장.

---

## 부록 A. GraphQL 보안(요약)
- **인증**: JWT/mTLS 동일.  
- **인가**: 필드/리졸버 단 인가(디렉티브), **IDOR 주의**.  
- **리밋**: 깊이/비용/필드 수 제한, 레이트리밋.  
- **스키마**: allowlist 쿼리(특히 서버-서버), 입력 스키마 strict.

## 부록 B. gRPC 보안(요약)
- **TLS/mTLS** 필수, 서비스 계정(SAN/spiffeID) 확인.  
- **레이트리밋**: 메시/게이트웨이에서 토큰 버킷.  
- **스키마**: protobuf validation(필수·범위), backward-compat 규칙.

---

## 마무리

- 엣지에서 **JWT 검증·레이트리밋**, 메시에서 **mTLS + 정책(OPA)**, 서비스에서 **스키마 검증 + 오브젝트/테넌트 인가**, DB에서 **RLS**까지 **중첩 방어**가 핵심입니다.  
- 오늘 바로 할 일:  
  1) `/orders`와 같은 민감 엔드포인트에 **사용자·경로 기반 레이트리밋** 추가  
  2) **OpenAPI 스키마**를 계약 테스트로 강제  
  3) `where({ owner_id: sub })` 또는 **RLS**로 **IDOR** 근본 차단  
  4) 서비스 간 통신에 **mTLS** 적용(가능하면 **SPIFFE**)  