---
layout: post
title: 형식언어와 오토마타 - 문맥 인식 언어, 선형 한정 오토마타, 재귀적(결정 가능) 언어와의 관계
date: 2025-08-05 19:20:23 +0900
category: 형식언어와 오토마타
---
# 문맥 인식 언어(CSL) ↔ 선형 한정 오토마타(LBA), 그리고 **재귀적(결정 가능) 언어**와의 관계

이 글은
(1) **문맥 인식 언어(Context-Sensitive Languages; CSL)** 와 **선형 한정 오토마타(Linear Bounded Automata; LBA)** 의 **동치**를 정리하고,
(2) CSL이 **재귀적(Recursive; 결정 가능)** 언어들과 맺는 포함 관계를 **정의–구성–알고리즘–복잡도**의 관점에서 자세히 설명한다.

---

## 0. 한눈에 보기 (핵심 결론)

- $$\boxed{\ \textbf{CSL} \;=\; \textbf{NLBA 인식 언어} \;=\; \mathrm{NSPACE}(O(n))\ }$$
  여기서 **NLBA**는 **비결정적** LBA.
- 모든 CSL은 **결정 가능(Recursive)** 이다. 즉 $$\text{CSL}\subseteq\text{Recursive}.$$
- 포함은 **엄격**하다: $$\text{CSL}\subsetneq \text{Recursive}\subsetneq \text{RE}.$$
- **DLBA = NLBA ?**는 **미해결**(일명 *LBA 문제*). 다만 $$\mathrm{NSPACE}(n)\subseteq \mathrm{DSPACE}(n^2)$$ (Savitch).

---

## 1. 모델과 정의

### 1.1 LBA (Linear Bounded Automaton)

길이 \(n\)의 입력 \(w\)가 주어지면, 테이프 사용 가능 영역이 입력 길이에 비례해 **선형**으로 제한된 튜링 기계:

- 좌우 경계를 \(\vdash,\dashv\)로 표시하고, 헤드/쓰기 동작은 이 경계를 넘을 수 없음.
- 구성(상태, 헤드 위치, 테이프 내용)의 총 수는 $$|Q|\cdot (c n)\cdot |\Gamma|^{c n}=\exp(\Theta(n))$$ 로 **유한**.
- **NLBA**: 전이가 비결정적(여러 후보 가능). **DLBA**: 결정적(0/1개).

### 1.2 CSG (Context-Sensitive Grammar)

문맥 인식 문법 \(G=(V,\Sigma,R,S)\)는 **길이 비축약** 규칙을 갖는다.

- 문맥형 표기: $$\alpha A\beta \Rightarrow \alpha\,\gamma\,\beta \qquad (A\in V,\ \gamma\neq \varepsilon)$$
- 요약(비축약): $$\alpha \Rightarrow \beta \ \Rightarrow\ |\alpha|\le |\beta|.$$
- **Kuroda 정규형**으로 변환 가능:
  $$AB\to CD,\quad A\to BC,\quad A\to B,\quad A\to a \quad (A,B,C,D\in V,\ a\in\Sigma).$$

---

## 2. **동치성**: CSG ⇔ NLBA ⇔ NSPACE(n)

### 2.1 CSG ⇒ NLBA (유도 모사)

- 비축약 조건 때문에 모든 중간 문장형 길이는 **입력 길이의 선형 범위** 안에 갇힌다.
- LBA는 테이프에 현재 문장형을 저장하고, 규칙의 **국소 패턴**을 찾는 스윕으로 한 단계 유도를 모사한다.
- 시작기호 \(S\)에서 시작해 \(w\)에 도달 가능한지 검사하면 **멤버십**.

> 직관: “문맥을 보며 길이를 줄이지 않는” 유도는 “**선형 공간**에서 가능한 재작성”과 동형.

### 2.2 NLBA ⇒ CSG (전이 재작성)

- LBA의 **구성(configuration)** 을 문자열로 코딩: “… 왼쪽내용 · 상태 · 읽는기호 · 오른쪽내용 …”.
- 한 스텝 전이를 **문맥 규칙**으로 기술: 좌/우 이웃 문맥이 맞을 때만 해당 구간을 다음 구성으로 치환.
- 시작 구성 \(\Rightarrow^*\) 수용 구성의 유도 ↔ 입력 생성.

### 2.3 결론

$$
\boxed{\ \textbf{CSL} = \textbf{NLBA 인식 언어} = \mathrm{NSPACE}(n)\ }.
$$

---

## 3. 왜 **CSL ⊆ Recursive(결정 가능)** 인가?

LBA의 입력별 **구성 그래프**는 **유한**(지수 개)이며, 멤버십은 “시작 구성 → 수용 구성 **도달성**”으로 환원된다.

### 3.1 개념 알고리즘

```text
Decide_LBA(M, w):
  # 구성 그래프 G는 암시적으로 정의됨(정점: 구성, 간선: 1스텝 전이)
  return REACHABLE(start_config(M, w), any_accept_config)
```

- **REACHABLE** 은 유한 그래프에서 결정 가능.
- **Savitch 정리**: \(\mathrm{NSPACE}(n)\subseteq \mathrm{DSPACE}(n^2)\)
  ⇒ 비결정적 선형 공간의 도달성은 **결정적 제곱공간**으로 판정 가능.
  ⇒ **모든 CSL은 결정 가능(Recursive)**.

### 3.2 Savitch 방식(재귀적 중간점 탐색) 의사코드

```text
# Path(u,v,ℓ): 구성 그래프에서 길이 ≤ 2^ℓ 경로 존재?
Path(u, v, ℓ):
  if ℓ == 0: return (u == v) or (u→v in one step)
  for each mid configuration m:
    if Path(u, m, ℓ-1) and Path(m, v, ℓ-1): return True
  return False

Decide_LBA(M, w):
  let G be implicit config graph of M on w
  return ∃ accept a : Path(start, a, ⌈log2 diameter(G)⌉)
```

- 저장은 “현재 서브문제의 두 구성 + 깊이” 정도라 **\(O(n^2)\)** 공간.

---

## 4. **CSL vs Recursive**: 포함과 **엄격성**

### 4.1 포함 사슬

$$
\boxed{\ \text{REG} \subsetneq \text{CFL} \subsetneq \text{CSL} \subsetneq \text{Recursive} \subsetneq \text{RE}\ }.
$$

- **CSL ⊆ Recursive**: §3의 도달성 판정으로 즉시.
- **Recursive ⊊ RE**: 정지 문제(고전).

### 4.2 엄격성(CSL ⊊ Recursive)의 직관적 근거

- **공간 계층 정리(Space Hierarchy)**: 더 큰 공간을 허용하면 더 많은 결정 언어를 인식 가능.
- \(\mathrm{NSPACE}(n)=\text{CSL}\) 이고, \(\mathrm{DSPACE}(n^3)\) 등 **초과선형 공간**을 요구하는 **결정 언어**들이 존재.
  ⇒ 그런 언어들은 CSL 밖: **\(\text{CSL}\subsetneq\text{Recursive}\)**.

---

## 5. 폐포(닫힘)·복잡도 요약

### 5.1 닫힘 성질(대표)

- 합 \(\cup\), 교 \(\cap\), 연접, Kleene★, **역순** \(L^R\)
- **보수(Complement)** — Immerman–Szelepcsényi: $$\mathrm{NSPACE}(s)=\mathrm{coNSPACE}(s)\ (s\ge \log n)$$
  ⇒ \(\mathrm{NSPACE}(n)=\mathrm{coNSPACE}(n)\) ⇒ CSL은 **보수에 닫힘**.
- 역호모모르피즘, **λ-자유** 호모모르피즘/치환

> CFL이 보수에 닫히지 않는 것과 대비되어, CSL의 **보수 닫힘**은 중요한 특징.

### 5.2 멤버십 복잡도

- **LBA가 주어졌을 때**: 멤버십은 \(\mathbf{NSPACE}(n)\)-**완전**(구성 그래프 도달성).
- **CSG(문법)가 주어졌을 때**: 멤버십은 **PSPACE-완전**(규칙 탐색 비용 증가).

### 5.3 전역 성질

- 공백성/보편성/포함성/동치성 등은 **일반적으로 결정 불가능**(PCP/정지 문제 감소).

---

## 6. 감각을 주는 **예시와 설계**

### 6.1 \(a^n b^n c^n\) — CSL \(\setminus\) CFL

- **LBA 설계 직관**: 좌→우로 **미사용 \(a\)** 하나를 마킹(Ā). 그 뒤에서 **가장 왼쪽 미사용 \(b, c\)** 를 차례로 마킹(\(\bar b,\bar c\)).
  우→좌로 돌아가 다음 \(a\)를 찾는 **왕복 스윕** 반복. 남거나 모자라면 거절.

```text
LBA_abc(w):
  scan to ensure w ∈ a* b* c* ; else REJECT
  loop:
    mark first unmarked a as Ā; if none: goto CHECK_REMAINS
    move right to first unmarked b; if none: REJECT; mark b̄
    move right to first unmarked c; if none: REJECT; mark c̄
    move left back to leftmost unmarked a; repeat
  CHECK_REMAINS:
    if any unmarked b or c remains: REJECT else ACCEPT
```

- **공간**: 입력 위 마킹만 사용 ⇒ 선형. **시간**: \(O(n^2)\) 스윕 허용.

### 6.2 \(ww\) — 복제 언어

- 길이 홀수면 거절. 중앙 경계 \(m\)을 **비결정적으로 추측** 후 **검증**, 좌/우에서 미사용 문자끼리 1:1 비교.

```text
LBA_ww(x):
  if |x| odd: REJECT
  guess boundary m; verify left/right length = m; else REJECT
  repeat m times:
    mark leftmost unmarked bit σ; mark rightmost unmarked bit τ
    if σ ≠ τ: REJECT
  ACCEPT
```

---

## 7. **알고리즘**: 멤버십 판정 구현 스케치

### 7.1 LBA 멤버십 = 구성 그래프 도달성

```text
# 비결정적 선형 공간 탐색(개념적)
Accepts_NLBA(M, w):
  conf := start_config(M, w)
  nondeterministically:
    while True:
      if conf ∈ Accepting: return ACCEPT
      conf := choose any successor of conf    # one-step move
```

- 결정기로 바꾸려면 Savitch(§3.2)로 **DSPACE(n^2)**에 압축.

### 7.2 CSG 멤버십 = 비축약 유도 탐색(PSPACE)

- 유도 길이가 줄지 않으므로 중간 문장형 길이 \(\le c\cdot |w|\).
- 각 단계에서 적용 가능한 규칙과 위치를 **도베일링**으로 순회 ⇒ **다항 공간**.

```text
CSG_Member(G, w):
  MaxLen := c·|w|
  for depth = 0 .. poly(|w|):
    if ExistsDerivationLengthAtMost(G, S, w, depth, MaxLen): return ACCEPT
  return REJECT   # 결정판정은 PSPACE 절차로 구현
```

---

## 8. **CSL ⊂ Recursive**를 더 단단히 이해하기

- \(\mathrm{NSPACE}(n)\) 는 \(\mathrm{DSPACE}(n^2)\)에 포함되고, 이는 다시 \(\mathrm{DSPACE}(n^3), \mathrm{DSPACE}(n^4),\dots\)에 포함.
- **공간 계층 정리**에 따르면 \(\mathrm{DSPACE}(n^2)\subsetneq \mathrm{DSPACE}(n^3)\subsetneq\cdots\) 이므로,
  **결정 가능하지만 CSL이 아닌 언어**가 무수히 존재(예: 특정 구성 그래프 성질을 따지는 인위적 구성 등).

> 결론: CSL은 **결정 가능한 언어의 한 부분 계층**(선형 공간 기반)일 뿐, 결정 가능의 전부가 아니다.

---

## 9. DLBA vs NLBA (열린 문제)

- **물음**: $$\mathrm{DSPACE}(n) \stackrel{?}{=} \mathrm{NSPACE}(n) \quad\Longleftrightarrow\quad \text{DLBA} \stackrel{?}{=} \text{NLBA}.$$
- **현황**: 미해결.
- **알려진 것**: $$\mathrm{NSPACE}(n)\subseteq \mathrm{DSPACE}(n^2)$$ (Savitch). 즉, **결정적 제곱공간**으로는 항상 모사 가능.

---

## 10. 미니 실습: CSG↔LBA 전개 감각 익히기

### 10.1 CSG ⇒ LBA (규칙 매칭 스캐너)

```text
SimulateCSG_ByLBA(G=(V,Σ,R,S), w):
  tape := S
  repeat:
    if tape == w: ACCEPT
    nondeterministically choose (ℓ→r) ∈ R and a position i
    if ℓ occurs at i in tape and |tape with ℓ@i→r| ≤ c·|w|:
      tape := replace ℓ by r at i
    else:
      REJECT this branch
```

- “비축약” 때문에 길이 상한만 지키면 선형 공간 내 동작.

### 10.2 NLBA ⇒ CSG (전이 재작성 규칙 스케치)

- 구성 인코딩: `… a q b …` (상태 \(q\)가 \(b\)를 읽음).
- 전이 \((q,b)\to(q',c,\mathrm{R})\)를 아래와 같은 **국소 치환** 패턴으로 분해(Kuroda NF로 더 세분화):

```text
# 오른쪽 이동
a q b   ⇒   a c q'     # 길이 보존/증가로 마킹·패딩 비단말을 더 둬 Kuroda형으로 분해
# 경계 처리, 왼쪽 이동도 유사
```

---

## 11. 체크리스트 (정리/암기)

- [ ] $$\boxed{\text{CSL}=\text{NLBA}=\mathrm{NSPACE}(n)}$$
- [ ] CSL은 **보수에 닫힘**(Immerman–Szelepcsényi).
- [ ] 모든 CSL은 **결정 가능** → $$\text{CSL}\subseteq\text{Recursive}.$$
- [ ] 엄격 포함: $$\text{CSL}\subsetneq\text{Recursive}$$ (공간 계층 정리).
- [ ] CSG 멤버십 = **PSPACE-완**, LBA 멤버십 = **NSPACE(n)-완**.
- [ ] **DLBA = NLBA?** 미해결.

---

## 12. 빠른 Q&A

- **Q. 왜 CSL이 결정 가능하죠?**
  **A.** LBA의 입력별 구성 그래프가 **유한**이고, 멤버십이 **도달성**으로 환원되며, Savitch로 **결정적 제곱공간**에서 판정 가능.

- **Q. CSL이 보수에 닫히는 이유는?**
  **A.** \(\mathrm{NSPACE}(n)=\mathrm{coNSPACE}(n)\) (Immerman–Szelepcsényi) 덕분.

- **Q. 결정 가능하지만 CSL은 아닌 예가 있나요?**
  **A.** 예. \(\mathrm{DSPACE}(n^3)\) 이상을 본질적으로 요구하는 언어들(공간 계층 정리) — 구체 구성은 대개 기계 인코딩 기반으로 제시.

---

## 13. 한 페이지 요약

- **정의**: LBA=선형 공간 TM. CSG=비축약/문맥형 규칙(=Kuroda 정규형으로 정리 가능).
- **동치**: $$\text{CSL}=\text{NLBA}=\mathrm{NSPACE}(n).$$
- **결정성**: 모든 CSL은 **Recursive**. (Savitch로 \(O(n^2)\) 공간 결정)
- **포함**: $$\text{REG}⊊\text{CFL}⊊\text{CSL}⊊\text{Recursive}⊊\text{RE}.$$
- **닫힘**: 합·교·연접·★·역순·역호모(λ-자유)·**보수**.
- **복잡도**: LBA 멤버십 NSPACE(n)-완, CSG 멤버십 PSPACE-완.
- **열린 문제**: **DLBA = NLBA ?**

---

### 부록: 간단 예제 — \(a^n b^n c^n\)용 LBA를 상태 구조로

```text
States: q_checkForm, q_markA, q_seekB, q_seekC, q_back, q_verifyNone, q_acc, q_rej
Tape symbols: {a,b,c, Ā, b̄, c̄, ␣, ⊢, ⊣}

q_checkForm:
  scan left→right once; if not a* b* c* then q_rej; else go to leftmost cell; → q_markA

q_markA:
  if first unmarked a exists: write Ā; move right; → q_seekB
  else → q_verifyNone

q_seekB:
  move right until first unmarked b; if none: q_rej; mark b̄; move right → q_seekC

q_seekC:
  move right until first unmarked c; if none: q_rej; mark c̄; move left to ⊢ → q_markA

q_verifyNone:
  scan to ensure no unmarked b/c remains; if ok → q_acc else q_rej
```

- **공간**: 입력 위 마킹만으로 충분(선형).
- **정확성**: 각 Ā는 정확히 한 b̄, 한 c̄와 짝지어짐 ⇒ \(|a|=|b|=|c|\)일 때만 수용.
