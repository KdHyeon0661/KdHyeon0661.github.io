---
layout: post
title: 정보통신기사 - 무선LAN · CSMA/CA · 보안
date: 2025-08-22 14:25:23 +0900
category: 정보통신기사
---
# IP 주소 · 서브넷/CIDR · VLSM 총정리 (tx-ip-subnet-cidr-vlsm)

> **목표**: 정보통신기사 필기·실무에서 자주 나오는 **IPv4/IPv6 주소**, **서브넷/마스크**, **CIDR**(Classless), **VLSM**(가변 길이 서브넷팅)을  
> (1) 원리 → (2) 공식/암기표 → (3) 예제/풀이 → (4) 설계 절차 → (5) Python 미니 도구 → (6) 연습문제 순으로 **생략 없이** 정리합니다.  
> 수식은 **MathJax**, 표/코드는 **코드블록**으로 제공합니다.

---

## 0) 큰 그림 한 장

- **IPv4 주소 = 32비트**, **IPv6 주소 = 128비트**.  
- **서브넷 마스크/Subnet Prefix**로 **네트워크/호스트** 경계를 구분(AND 연산).  
- **CIDR**: 클래스 개념(ABC)을 버리고 **임의 길이 프리픽스**(/n) 사용 → **주소 효율·라우팅 집계**.  
- **VLSM**: 같은 상위 대역을 **필요 크기별로 가변 분할**(낭비↓) — “**큰 거부터**”가 핵심 규칙.  
- **라우팅**은 **Longest Prefix Match**(가장 긴/구체적 경로가 우선).

---

## 1) IPv4 주소 기초

### 1.1 표기와 범위
- **점-십진 표기**: `a.b.c.d` 각 옥텟 0~255 (8비트 × 4 = 32비트)
- **네트워크/호스트 구분**: **마스크**(예: 255.255.255.0) 또는 **슬래시 표기**(/24)
- **네트워크 주소**: 호스트 비트 **0**  
- **브로드캐스트 주소**: 호스트 비트 **1**  
- **유효 호스트 수**:
  \[
  H = \begin{cases}
  2^{h}-2,& h\ge 2\\
  2,& /31\ \text{(특수 P2P)}\\
  1,& /32\ \text{(호스트 경로)}
  \end{cases}
  \]
  - \(h\): 호스트 비트 개수(= \(32-n\), n은 프리픽스 길이)

### 1.2 (역사) 클래스풀 주소
- Class A: 0.0.0.0/8~127.255.255.255 (오늘날 **CIDR**로 대체, 시험에서 개념만)  
- Class B: /16, Class C: /24 — 이 구분을 **CIDR**가 대체했음을 기억.

### 1.3 사설/예약 주소 (암기)
- **사설(Private)**:  
  - 10.0.0.0/8  
  - 172.16.0.0/12 (172.16.0.0~172.31.255.255)  
  - 192.168.0.0/16
- **Loopback**: 127.0.0.0/8 (보통 127.0.0.1)  
- **APIPA/Link-Local**: 169.254.0.0/16  
- **멀티캐스트**: 224.0.0.0/4  
- **RFC 1918/5735/6890** 참조(시험은 범위 암기 위주)

---

## 2) 서브넷 마스크 · 프리픽스 · AND 연산

### 2.1 마스크/프리픽스 상호 변환
- **마스크 → /n**: 1이 연속된 비트 개수 = n
- **/n → 마스크**: 상위 n비트를 1, 하위(32−n)비트를 0

| /n | Subnet Mask | Hosts(≈) | Increment(증분) |
|---:|---|---:|---:|
| /8  | 255.0.0.0       | 16M−2 | 1.0.0.0 |
| /16 | 255.255.0.0     | 65,534| 0.1.0.0 |
| /24 | 255.255.255.0   | 254   | 0.0.1.0 |
| /25 | 255.255.255.128 | 126   | 128     |
| /26 | 255.255.255.192 | 62    | 64      |
| /27 | 255.255.255.224 | 30    | 32      |
| /28 | 255.255.255.240 | 14    | 16      |
| /29 | 255.255.255.248 | 6     | 8       |
| /30 | 255.255.255.252 | 2     | 4       |
| /31 | 255.255.255.254 | P2P   | 2       |
| /32 | 255.255.255.255 | host  | 1       |

> **Increment(증분)**: 변하는 옥텟의 **서브넷 간 간격**. 예: /26이면 마지막 옥텟이 0,64,128,192 시작.

### 2.2 네트워크/브로드캐스트 구하기 (AND)
- **네트워크 주소** = (IP) **AND** (마스크)  
- **브로드캐스트** = **네트워크** OR (마스크의 **보수**)

**예)** `192.168.10.77/26`  
- 마스크 255.255.255.192 → 증분 64 → 서브넷 시작: 0,64,128,192  
- `77`은 **64~127** 범위 → **네트워크** `192.168.10.64`  
- **브로드캐스트** `192.168.10.127`  
- **호스트 범위** `192.168.10.65 ~ 192.168.10.126`

### 2.3 와일드카드 마스크(ACL용)
- **Wildcard** = 마스크의 **비트 반전**  
- 예: /24 → 0.0.0.255, /26 → 0.0.0.63

---

## 3) CIDR와 집계(Summarization/Supernetting)

### 3.1 CIDR 개념
- **Classless Inter-Domain Routing**: 클래스 무시하고 **/n 프리픽스**로 라우팅  
- **집계**: 여러 연속 프리픽스를 **상위 프리픽스 하나**로 묶어 라우팅 테이블 축소

### 3.2 요령 (경계 맞추기)
- **바이너리 공통 접두어**를 찾기 → 그 길이가 집계 프리픽스  
- 개수는 **2의 거듭제곱**으로 증가

**예1)** `192.168.0.0/24` ~ `192.168.3.0/24`  
- 0~3 = 4개 = \(2^2\) → **192.168.0.0/22** 로 집계

**예2)** `10.10.32.0/24` + `10.10.33.0/24` 는 /23로 합쳐짐(`10.10.32.0/23`)

### 3.3 불연속 대역은 집계 불가
- **붙지 않는 블록**은 하나의 CIDR로 합칠 수 없음 → 복수 경로 유지

---

## 4) VLSM(Variable Length Subnet Mask) — 절차와 예제

### 4.1 핵심 원칙
1. **요구 호스트 수를 내림차순 정렬**  
2. 각 요구를 **충족하는 최소 /프리픽스** 선택  
3. **남는 블록은 다시 분할**(상위에서 하위로)  
4. **경계 정렬(2^h 개수)**을 지키며 배치

### 4.2 빠른 변환표 (필수 암기)
- **필요 호스트 H → 호스트 비트 h**: \(2^{h} - 2 \ge H\) ⇒ 최소 h  
- **프리픽스**: \(n = 32 - h\)

| 필요 호스트 H | 최소 h | 프리픽스(/n) | 유효 호스트 |
|---:|---:|---:|---:|
| ≥ 2     | 2 | /30 | 2 |
| ≤ 6     | 3 | /29 | 6 |
| ≤ 14    | 4 | /28 | 14 |
| ≤ 30    | 5 | /27 | 30 |
| ≤ 62    | 6 | /26 | 62 |
| ≤ 126   | 7 | /25 | 126 |
| ≤ 254   | 8 | /24 | 254 |
| ≤ 510   | 9 | /23 | 510 |
| ≤ 1022  | 10| /22 | 1022 |

> /31은 P2P 특수(유효 2 주소), 일반 호스트 서브넷은 위 표 사용.

### 4.3 풀 예제 — **`192.168.10.0/24`** 에 다음 서브넷을 설계
- 요구:  
  - **A**: 60 hosts  
  - **B**: 28 hosts  
  - **C**: 12 hosts  
  - **D**: 2 hosts (P2P 링크)

**Step 1. 내림차순 정렬:** A(60), B(28), C(12), D(2)

**Step 2. 각 요구에 맞는 최소 /n**  
- A(60) → /26(=62 호스트)  
- B(28) → /27(=30)  
- C(12) → /28(=14)  
- D(2) → /30(=2)

**Step 3. 상위 블록에서 배정**  
- 상위: `192.168.10.0/24`  
  - **A**: /26 → **192.168.10.0/26** (호스트: .1~.62, 브로드캐스트 .63)  
  - 남음: **192.168.10.64/26**
    - **B**: /27 → **192.168.10.64/27** ( .65~.94, BCast .95 )  
    - 남음: **192.168.10.96/27**
      - **C**: /28 → **192.168.10.96/28** ( .97~.110, BCast .111 )  
      - 남음: **192.168.10.112/28** … **192.168.10.127/28** (여러 개)
        - **D**: /30 → **192.168.10.112/30** ( .113~.114, BCast .115 )  
        - 남음: **192.168.10.116/30**, … 계속

**결과 요약**

| Subnet | Prefix | Network | First Host | Last Host | Broadcast |
|---|---:|---|---|---|---|
| A | /26 | 192.168.10.0 | 192.168.10.1 | 192.168.10.62 | 192.168.10.63 |
| B | /27 | 192.168.10.64 | 192.168.10.65 | 192.168.10.94 | 192.168.10.95 |
| C | /28 | 192.168.10.96 | 192.168.10.97 | 192.168.10.110 | 192.168.10.111 |
| D | /30 | 192.168.10.112 | 192.168.10.113 | 192.168.10.114 | 192.168.10.115 |

> **팁**: “**증분(increment)**” 감각이 중요합니다. /26=64간격, /27=32, /28=16, /30=4.

---

## 5) 자주 나오는 계산형 예제

### 예제 1) `172.16.35.77/20`의 네트워크/브로드캐스트/호스트 범위
- /20 → 마스크 255.255.240.0 → 증분 **16** (세 번째 옥텟)  
- 세 번째 옥텟 35는 **32~47** 범위 → 네트워크 `172.16.32.0`  
- 브로드캐스트 `172.16.47.255`  
- 호스트 범위 `172.16.32.1 ~ 172.16.47.254`

### 예제 2) `/26`의 3번째 서브넷 네트워크는? (기준 `/24`)
- /26 증분 = 64 → 서브넷 시작: 0,64,128,192  
- **3번째**(0부터 세면 0:0, 1:64, 2:128, 3:192) → 네트워크 **x.x.x.128**

### 예제 3) VLSM 요구: 200, 50, 20, 10 호스트 (상위 `10.10.0.0/24`는 충분한가?)
- 최대 필요: 200 → /24(=254) 이상 필요  
- 상위가 /24면 **200 하나만**으로 거의 소진 → 나머지 불가  
- 결론: `10.10.0.0/24`는 **부족**. 상위를 더 큰 블록(/23 이상)으로 받아야 함

### 예제 4) 두 /24를 합쳐 하나로 집계
- `192.168.4.0/24` + `192.168.5.0/24` → 인접 2개 = \(2^1\) → **`192.168.4.0/23`**

### 예제 5) /31 링크
- `203.0.113.10/31` ↔ `203.0.113.11/31` (P2P, RFC 3021)  
- **브로드캐스트 없음**, **양끝 호스트 2개 모두 사용** → 주소 절약

---

## 6) IPv6 기초와 서브넷팅

### 6.1 주소 유형
- **유니캐스트**:  
  - **GUA**(글로벌): 2000::/3  
  - **ULA**(사설): fc00::/7 (일반적으로 **fd**로 시작)  
  - **Link-Local**: **fe80::/10** (라우터 홉 넘지 않음)
- **멀티캐스트**: ff00::/8  
- **루프백**: ::1/128  
- **브로드캐스트 없음**(멀티캐스트 사용)

### 6.2 인터페이스 식별자 & SLAAC
- 일반적으로 **/64 서브넷**: 상위 64비트=네트워크, 하위 64비트=인터페이스 ID  
- **SLAAC**: 라우터 광고(RA)로 프리픽스 수신, **EUI-64**나 무작위로 인터페이스 ID 생성

### 6.3 표기와 요약
- **0 생략**: 선행 0 생략, `::`로 **한 번만** 연속 0 압축  
- **CIDR 동일**: `/n` 프리픽스  
- **집계**: 바이너리 공통 접두어 기준 동일

**예)** `2001:db8:1000::/36`에서 /48 서브넷들  
- /36 → /48로 **12비트 더** 서브넷팅 → **2^12 = 4096**개의 /48 생성  
- 첫 /48: `2001:db8:1000::/48`, 다음은 `2001:db8:1001::/48` …

### 6.4 IPv6 서브넷 설계 팁
- **/64 고정**을 기본 단위로 사용(Neighbor Discovery, SLAAC 호환)  
- 사이트에 **/48** 또는 **/56**을 받아 **/64**로 나눠 쓰기  
- **VLSM** 개념은 IPv6에도 있지만, 보통 **/64 균등 분배**가 권장

---

## 7) NAT 개념(간단 연결)

- **Private ↔ Public 변환**: 주소 절약, 경계 보안(기본 차단)  
- **PAT(NAPT)**: 포트까지 다중 매핑(가장 일반)  
- **CIDR/VLSM**과 직접적 관계는 없지만, **사설대역 설계**에서 함께 고려

---

## 8) 설계 체크리스트(현장/시험)

- [ ] 요구 **호스트 수(현재/성장)** 파악 → **내림차순 정렬**  
- [ ] 각 요구에 맞는 **최소 /프리픽스 선택** (표 활용)  
- [ ] **증분**과 **경계 정렬**을 지키며 할당  
- [ ] **예약/확장용 여유 블록** 남기기  
- [ ] **요약(CIDR 집계)** 가능한 경계로 배치(라우팅 단순화)  
- [ ] **문서화**: 네트워크/브로드캐스트/게이트웨이/할당 정책  
- [ ] IPv6: **/64 기본**, 사이트는 /48 또는 /56 받기

---

## 9) 실습형 — 손으로 빨리 푸는 요령

1) **증분**만 기억해도 80% 해결:  
   - /25=128, /26=64, /27=32, /28=16, /29=8, /30=4  
2) 찾는 IP의 **해당 옥텟**을 증분으로 나눈 뒤 **내림(quotient)** × 증분 = **네트워크 시작**  
3) 브로드캐스트는 **시작 + (증분−1)**  
4) 호스트 범위는 **+1 ~ −1**

**예)** `10.2.5.167/27`  
- /27 → 증분 32 → 167/32=5.x → 5×32=160 → 네트워크 **10.2.5.160**  
- 브로드캐스트 **10.2.5.191**  
- 호스트 **161~190**

---

## 10) Python 미니 도구 (교육용)

```python
# IPv4 계산 유틸 (교육용, ipaddress 표준모듈 없이 구현 개념)
def ip_to_int(ip):
    a,b,c,d = map(int, ip.split('.'))
    return (a<<24)|(b<<16)|(c<<8)|d

def int_to_ip(x):
    return '.'.join(str((x>>i)&0xff) for i in (24,16,8,0))

def prefix_to_mask(n):
    return ((1<<32)-1) ^ ((1<<(32-n))-1)

def network_broadcast(ip, n):
    ipi = ip_to_int(ip)
    mask = prefix_to_mask(n)
    net = ipi & mask
    brd = net | (~mask & 0xffffffff)
    return int_to_ip(net), int_to_ip(brd)

def host_range(ip, n):
    net, brd = network_broadcast(ip, n)
    if n == 31:
        return (net, brd)  # p2p
    if n == 32:
        return (net, net)
    return (int_to_ip(ip_to_int(net)+1), int_to_ip(ip_to_int(brd)-1))

def wildcard_from_prefix(n):
    mask = prefix_to_mask(n)
    wc = (~mask) & 0xffffffff
    return int_to_ip(wc)

# VLSM allocator: base network/prefix, list of required hosts (descending not required)
def vlsm_allocate(base_net_ip, base_n, host_reqs):
    base_net, _ = network_broadcast(base_net_ip, base_n)
    start = ip_to_int(base_net)
    size = 1 << (32 - base_n)
    end = start + size
    # sort desc
    reqs = sorted(host_reqs, reverse=True)
    allocs = []
    cursor = start
    for H in reqs:
        if H == 2:
            n = 30  # common
        else:
            h = 2
            while (1<<h) - 2 < H:
                h += 1
            n = 32 - h
        block_size = 1 << (32 - n)
        # align cursor to block boundary
        if cursor % block_size != 0:
            cursor = ((cursor // block_size) + 1) * block_size
        if cursor + block_size > end:
            raise ValueError("no space for H="+str(H))
        net = cursor
        brd = net + block_size - 1
        allocs.append({
            "hosts": H, "prefix": n, "network": int_to_ip(net),
            "first": int_to_ip(net+1 if n<=30 else net),
            "last": int_to_ip(brd-1 if n<=30 else brd),
            "broadcast": int_to_ip(brd) if n<=30 else "-"
        })
        cursor = brd + 1
    return allocs

# Demo
print("Network/Broadcast of 172.16.35.77/20:", network_broadcast("172.16.35.77",20))
print("Host range:", host_range("172.16.35.77",20))
print("Wildcard /26:", wildcard_from_prefix(26))
print("VLSM allocate 192.168.10.0/24 for [60,28,12,2]:")
for a in vlsm_allocate("192.168.10.0",24,[60,28,12,2]):
    print(a)
```

---

## 11) 빠른 암기표 (시험 직전 15줄)

1) **호스트 수** \(H = 2^{h}-2\) (단 /31, /32 특수)  
2) **프리픽스 ↔ 호스트 비트**: \(n=32-h\)  
3) **증분**: /25=128, /26=64, /27=32, /28=16, /29=8, /30=4  
4) **네트워크=IP AND Mask**, **브로드=Net OR ~Mask**  
5) **Private**: 10/8, 172.16/12, 192.168/16  
6) **APIPA**: 169.254/16, **Loopback**: 127/8  
7) **멀티캐스트**: 224/4, **브로드캐스트**: (서브넷 내 최댓값)  
8) **CIDR 집계**: 2^k 개 연속 대역 → 상위 프리픽스 하나  
9) **VLSM**: **큰 요구부터** 배치 → 남은 블록 재분할  
10) **/31** P2P 허용, **/32** 호스트 경로  
11) **와일드카드** = ~마스크  
12) **Longest Prefix Match**가 라우팅 우선  
13) IPv6: **/64 기본**, GUA 2000::/3, ULA fc00::/7, Link-Local fe80::/10  
14) IPv6엔 브로드캐스트 없음(멀티캐스트 사용)  
15) 설계는 **여유 블록 + 문서화**가 생명

---

## 12) 연습문제 (풀이 포함)

**Q1.** `192.168.1.130/26`의 네트워크/브로드캐스트/호스트 범위?  
**A.** /26 증분 64 → 128~191 범위. 네트워크 **192.168.1.128**, 브로드 **192.168.1.191**, 호스트 **.129~.190**.

**Q2.** 최소 50호스트 수용 서브넷의 /프리픽스와 유효 호스트 수는?  
**A.** 50 ≤ 62 → **/26**, 유효 **62**.

**Q3.** `10.0.0.0/23`의 유효 호스트 수는?  
**A.** h=9 → \(2^9-2=510\).

**Q4.** `192.168.8.0/24`에서 /28 서브넷 **3번째**의 네트워크/브로드캐스트는?  
**A.** /28 증분 16 → 0,16,32,… **3번째=32** → **192.168.8.32/28**, 브로드 **192.168.8.47**.

**Q5.** `203.0.113.0/24`와 `203.0.114.0/24`는 하나로 요약 가능한가?  
**A.** 연속 2개 /24는 /23로 합치려면 **경계가 짝수**여야 함. 113은 홀수 시작 → **불가**.  
가능한 집계는 `203.0.112.0/23` 또는 `203.0.114.0/23` 등 경계 맞는 페어.

**Q6.** IPv6 `2001:db8:abcd:1234::/64`에서 다음 서브넷 `/68`은 몇 개? 첫 번째와 두 번째는?  
**A.** /64→/68 **4개**. 첫: `...:1234:0::/68`, 둘째: `...:1234:1::/68` (16진 0x0, 0x1 증가).

**Q7.** `172.20.10.0/24`에서 VLSM으로 (A=100, B=50, C=20, D=10) 할당하라.  
**A.** A=/25(126): `172.20.10.0/25`  
B=/26(62): `172.20.10.128/26`  
C=/27(30): `172.20.10.192/27`  
D=/28(14): `172.20.10.224/28` (잔여 `/28` 2블록: .240/28 등)

---

## 13) 트러블슈팅 포인트

- **서브넷 경계 불일치**: 게이트웨이/마스크 혼선 → **서브넷 외부**로 ARP 브로드캐스트 반복, 통신 실패  
- **요약 경계 실수**: 광고한 요약이 실제 포함하지 않는 네트워크를 가리키면 **블랙홀**  
- **ACL 와일드카드 오용**: 마스크와 반대로 써 **허용/차단** 반전  
- **/31 미지원 장비**: 레거시 라우터/장비 호환성 확인  
- **IPv6 브로드캐스트 착각**: 존재하지 않음 → 멀티캐스트 FF02::1/::2 활용

---

## 14) 마무리

- **CIDR/VLSM의 요체**는 **비트를 빌려 경계를 정하고**, **증분**으로 빠르게 감 잡는 것입니다.  
- 손연산 요령(**증분/경계**) + 체계적 절차(**큰 요구부터, 경계 맞추기, 문서화**)만 익히면  
  대부분의 서브넷/요약 설계 문제를 **몇 분 내**에 정확히 풀 수 있습니다.
