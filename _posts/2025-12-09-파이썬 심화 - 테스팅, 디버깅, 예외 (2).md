---
layout: post
title: 파이썬 심화 - 테스팅, 디버깅, 예외 (2)
date: 2025-12-09 14:30:23 +0900
category: 파이썬 심화
---
# 테스팅, 디버깅, 예외 (2)

예외 처리는 단순한 오류 메시지 출력을 넘어 애플리케이션의 견고성과 유지보수성을 결정하는 핵심 기술입니다. 파이썬의 다양한 예외 처리 기법을 심층적으로 살펴보고, 실제 프로덕션 환경에서 적용 가능한 고급 패턴들을 구현해 보겠습니다.

## 테스트 실패 예측과 조건부 테스트 건너뛰기

### 동적 테스트 조건 평가와 스킵 메커니즘

```python
import unittest
import sys
import os
import platform
import pytest
from typing import Optional, Callable, Any
from contextlib import contextmanager
from dataclasses import dataclass
from enum import Enum
import warnings
import inspect

class TestCondition(Enum):
    """테스트 조건 타입"""
    PLATFORM = "platform"
    PYTHON_VERSION = "python_version"
    EXTERNAL_DEPENDENCY = "external_dependency"
    ENVIRONMENT_VARIABLE = "environment_variable"
    NETWORK_AVAILABILITY = "network_availability"
    RESOURCE_AVAILABILITY = "resource_availability"

@dataclass
class SkipCondition:
    """테스트 스킵 조건"""
    condition_type: TestCondition
    condition_value: Any
    skip_reason: str
    required: bool = True
    
class AdvancedTestSkipper:
    """고급 테스트 스킵 관리자"""
    
    def __init__(self):
        self.conditions: list[SkipCondition] = []
        self.custom_checkers: dict[str, Callable[[], bool]] = {}
        
    def add_condition(self, condition: SkipCondition):
        """스킵 조건 추가"""
        self.conditions.append(condition)
        
    def register_custom_checker(self, name: str, checker: Callable[[], bool]):
        """커스텀 조건 체커 등록"""
        self.custom_checkers[name] = checker
        
    def should_skip(self, condition_type: TestCondition, 
                   condition_value: Any = None) -> Optional[str]:
        """테스트 스킵 여부 결정"""
        for condition in self.conditions:
            if condition.condition_type == condition_type:
                if condition_value is None or condition.condition_value == condition_value:
                    if self._evaluate_condition(condition):
                        return condition.skip_reason
        return None
        
    def _evaluate_condition(self, condition: SkipCondition) -> bool:
        """조건 평가"""
        if condition.condition_type == TestCondition.PLATFORM:
            return self._check_platform(condition.condition_value)
        elif condition.condition_type == TestCondition.PYTHON_VERSION:
            return self._check_python_version(condition.condition_value)
        elif condition.condition_type == TestCondition.EXTERNAL_DEPENDENCY:
            return self._check_external_dependency(condition.condition_value)
        elif condition.condition_type == TestCondition.ENVIRONMENT_VARIABLE:
            return self._check_environment_variable(condition.condition_value)
        elif condition.condition_type == TestCondition.NETWORK_AVAILABILITY:
            return self._check_network_availability()
        elif condition.condition_type == TestCondition.RESOURCE_AVAILABILITY:
            return self._check_resource_availability(condition.condition_value)
        return False
        
    def _check_platform(self, required_platform: str) -> bool:
        """플랫폼 체크"""
        current = sys.platform
        required = required_platform.lower()
        
        platform_mapping = {
            'windows': ['win32', 'cygwin'],
            'linux': ['linux'],
            'darwin': ['darwin']
        }
        
        if required in platform_mapping:
            return current not in platform_mapping[required]
        return current != required
        
    def _check_python_version(self, required_version: str) -> bool:
        """파이썬 버전 체크"""
        from packaging import version
        
        try:
            current = version.parse(platform.python_version())
            required = version.parse(required_version)
            
            if '>' in required_version:
                return current <= required
            elif '<' in required_version:
                return current >= required
            else:
                return current != required
        except ImportError:
            # packaging 모듈이 없을 경우 간단한 체크
            major_minor = f"{sys.version_info.major}.{sys.version_info.minor}"
            return major_minor != str(required_version)
            
    def _check_external_dependency(self, dependency: str) -> bool:
        """외부 의존성 체크"""
        try:
            __import__(dependency)
            return False  # import 성공 = 스킵하지 않음
        except ImportError:
            return True  # import 실패 = 스킵
            
    def _check_environment_variable(self, env_var: str) -> bool:
        """환경 변수 체크"""
        value = os.environ.get(env_var)
        if isinstance(env_var, tuple):
            var_name, expected_value = env_var
            return os.environ.get(var_name) != expected_value
        return value is None
        
    def _check_network_availability(self) -> bool:
        """네트워크 가용성 체크"""
        try:
            import socket
            socket.create_connection(("8.8.8.8", 53), timeout=1)
            return False
        except OSError:
            return True
            
    def _check_resource_availability(self, resource: str) -> bool:
        """리소스 가용성 체크"""
        if resource == "gpu":
            try:
                import torch
                return not torch.cuda.is_available()
            except ImportError:
                return True
        elif resource == "memory":
            import psutil
            available_memory = psutil.virtual_memory().available
            return available_memory < (2 * 1024 * 1024 * 1024)  # 2GB 미만
        return False
        
    @contextmanager
    def conditional_test(self, test_name: str = None):
        """조건부 테스트 컨텍스트 매니저"""
        skip_reason = None
        
        # 모든 조건 체크
        for condition in self.conditions:
            reason = self.should_skip(condition.condition_type, condition.condition_value)
            if reason:
                skip_reason = reason
                break
                
        if skip_reason:
            # 테스트 스킵
            if test_name:
                print(f"⏭️ 테스트 '{test_name}' 스킵됨: {skip_reason}")
            raise unittest.SkipTest(skip_reason)
        else:
            # 테스트 실행
            yield
            
def demonstrate_test_skipping():
    """테스트 스킵 데모"""
    print("=== 테스트 실패 예측과 조건부 건너뛰기 ===")
    
    # 고급 테스트 스킵 관리자 생성
    skipper = AdvancedTestSkipper()
    
    # 다양한 스킵 조건 추가
    skipper.add_condition(SkipCondition(
        condition_type=TestCondition.PLATFORM,
        condition_value="linux",
        skip_reason="리눅스에서만 실행 가능한 테스트"
    ))
    
    skipper.add_condition(SkipCondition(
        condition_type=TestCondition.PYTHON_VERSION,
        condition_value="3.8",
        skip_reason="파이썬 3.8 이상 필요"
    ))
    
    skipper.add_condition(SkipCondition(
        condition_type=TestCondition.EXTERNAL_DEPENDENCY,
        condition_value="requests",
        skip_reason="requests 패키지 필요"
    ))
    
    skipper.add_condition(SkipCondition(
        condition_type=TestCondition.ENVIRONMENT_VARIABLE,
        condition_value=("TEST_ENV", "production"),
        skip_reason="프로덕션 환경에서만 실행"
    ))
    
    # 커스텀 조건 체커 등록
    def check_database_availability():
        try:
            import sqlite3
            return False
        except ImportError:
            return True
            
    skipper.register_custom_checker("database", check_database_availability)
    
    # unittest 스타일 데모
    class TestAdvancedFeatures(unittest.TestCase):
        """고급 기능 테스트 클래스"""
        
        def setUp(self):
            self.skipper = AdvancedTestSkipper()
            # 공통 조건 설정
            self.skipper.add_condition(SkipCondition(
                condition_type=TestCondition.EXTERNAL_DEPENDENCY,
                condition_value="numpy",
                skip_reason="NumPy가 설치되지 않음"
            ))
            
        def test_linux_specific_feature(self):
            """리눅스 전용 기능 테스트"""
            # 조건부 테스트 실행
            with self.skipper.conditional_test("test_linux_specific_feature"):
                # 실제 테스트 로직
                result = os.uname() if hasattr(os, 'uname') else "Not Linux"
                self.assertIsNotNone(result)
                
        def test_gpu_acceleration(self):
            """GPU 가속 테스트"""
            # GPU 가용성 체크
            self.skipper.add_condition(SkipCondition(
                condition_type=TestCondition.RESOURCE_AVAILABILITY,
                condition_value="gpu",
                skip_reason="GPU를 사용할 수 없음"
            ))
            
            with self.skipper.conditional_test("test_gpu_acceleration"):
                # GPU 연산 테스트 로직
                self.assertTrue(True, "GPU 테스트 통과")
                
        def test_network_operation(self):
            """네트워크 연산 테스트"""
            self.skipper.add_condition(SkipCondition(
                condition_type=TestCondition.NETWORK_AVAILABILITY,
                condition_value=True,
                skip_reason="네트워크 연결 필요"
            ))
            
            with self.skipper.conditional_test("test_network_operation"):
                import urllib.request
                response = urllib.request.urlopen("http://httpbin.org/get", timeout=3)
                self.assertEqual(response.status, 200)
                
    # pytest 스타일 데코레이터
    def pytest_skip_if(condition_func, reason):
        """pytest 스킵 데코레이터"""
        def decorator(test_func):
            def wrapper(*args, **kwargs):
                if condition_func():
                    pytest.skip(reason)
                return test_func(*args, **kwargs)
            return wrapper
        return decorator
        
    # 조건부 실행 함수 예시
    def requires_windows():
        return sys.platform != "win32"
        
    @pytest_skip_if(requires_windows, "윈도우즈에서만 실행 가능")
    def test_windows_specific():
        """윈도우즈 전용 테스트"""
        assert True
        
    # 데모 실행
    print("\n테스트 조건 평가:")
    test_cases = [
        ("리눅스 테스트", TestCondition.PLATFORM, "linux"),
        ("파이썬 3.8 테스트", TestCondition.PYTHON_VERSION, "3.8"),
        ("requests 테스트", TestCondition.EXTERNAL_DEPENDENCY, "requests"),
    ]
    
    for test_name, condition_type, condition_value in test_cases:
        reason = skipper.should_skip(condition_type, condition_value)
        status = "스킵" if reason else "실행"
        print(f"{test_name}: {status} ({reason or '조건 만족'})")
        
    # 동적 테스트 생성 예시
    print("\n동적 테스트 생성 및 조건부 실행:")
    
    def create_dynamic_tests():
        """동적 테스트 생성"""
        test_scenarios = [
            ("데이터베이스 테스트", TestCondition.EXTERNAL_DEPENDENCY, "sqlite3"),
            ("메모리 집약적 테스트", TestCondition.RESOURCE_AVAILABILITY, "memory"),
            ("네트워크 의존성 테스트", TestCondition.NETWORK_AVAILABILITY, True),
        ]
        
        for test_name, condition_type, condition_value in test_scenarios:
            def make_test(name, c_type, c_value):
                def test_function():
                    temp_skipper = AdvancedTestSkipper()
                    temp_skipper.add_condition(SkipCondition(
                        condition_type=c_type,
                        condition_value=c_value,
                        skip_reason=f"{c_value} 필요"
                    ))
                    
                    with temp_skipper.conditional_test(name):
                        # 실제 테스트 로직
                        assert True, f"{name} 통과"
                        
                test_function.__name__ = f"test_{name.replace(' ', '_').lower()}"
                return test_function
                
            # 동적 테스트 함수 생성
            test_func = make_test(test_name, condition_type, condition_value)
            
            # 실행 시도
            try:
                test_func()
                print(f"✓ {test_name}: 실행됨")
            except unittest.SkipTest as e:
                print(f"⏭️ {test_name}: 스킵됨 ({e})")
            except AssertionError as e:
                print(f"✗ {test_name}: 실패 ({e})")
                
    create_dynamic_tests()

demonstrate_test_skipping()
```

## 다중 예외 처리와 고급 예외 관리

### 체계적인 예외 계층 구조와 상황별 처리

```python
from typing import Dict, List, Optional, Type, Any, Union
from dataclasses import dataclass, field
from enum import Enum
import traceback
import sys

class ErrorSeverity(Enum):
    """에러 심각도 레벨"""
    DEBUG = "debug"
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

class ErrorCategory(Enum):
    """에러 카테고리"""
    VALIDATION = "validation"
    NETWORK = "network"
    DATABASE = "database"
    FILE_SYSTEM = "file_system"
    SECURITY = "security"
    BUSINESS_LOGIC = "business_logic"
    INTEGRATION = "integration"
    CONFIGURATION = "configuration"

@dataclass
class ErrorContext:
    """에러 컨텍스트 정보"""
    category: ErrorCategory
    severity: ErrorSeverity = ErrorSeverity.ERROR
    user_message: Optional[str] = None
    technical_details: Dict[str, Any] = field(default_factory=dict)
    timestamp: float = field(default_factory=lambda: time.time())
    
class BaseApplicationError(Exception):
    """애플리케이션 에러 베이스 클래스"""
    
    def __init__(self, message: str, 
                 context: Optional[ErrorContext] = None,
                 cause: Optional[Exception] = None):
        super().__init__(message)
        self.message = message
        self.context = context or ErrorContext(category=ErrorCategory.BUSINESS_LOGIC)
        self.cause = cause
        self.traceback = traceback.format_exc()
        
    def to_dict(self) -> Dict[str, Any]:
        """에러 정보를 딕셔너리로 변환"""
        return {
            "type": self.__class__.__name__,
            "message": self.message,
            "category": self.context.category.value,
            "severity": self.context.severity.value,
            "timestamp": self.context.timestamp,
            "details": self.context.technical_details,
            "cause": str(self.cause) if self.cause else None
        }

class ValidationError(BaseApplicationError):
    """검증 에러"""
    def __init__(self, message: str, field: Optional[str] = None, **kwargs):
        context = ErrorContext(
            category=ErrorCategory.VALIDATION,
            technical_details={"field": field} if field else {}
        )
        super().__init__(message, context, **kwargs)

class NetworkError(BaseApplicationError):
    """네트워크 에러"""
    def __init__(self, message: str, url: Optional[str] = None, status_code: Optional[int] = None, **kwargs):
        details = {}
        if url:
            details["url"] = url
        if status_code:
            details["status_code"] = status_code
            
        context = ErrorContext(
            category=ErrorCategory.NETWORK,
            severity=ErrorSeverity.ERROR,
            technical_details=details
        )
        super().__init__(message, context, **kwargs)

class DatabaseError(BaseApplicationError):
    """데이터베이스 에러"""
    def __init__(self, message: str, query: Optional[str] = None, 
                 database: Optional[str] = None, **kwargs):
        details = {}
        if query:
            details["query"] = query
        if database:
            details["database"] = database
            
        context = ErrorContext(
            category=ErrorCategory.DATABASE,
            technical_details=details
        )
        super().__init__(message, context, **kwargs)

class RetryableError(BaseApplicationError):
    """재시도 가능 에러"""
    def __init__(self, message: str, max_retries: int = 3, **kwargs):
        context = ErrorContext(
            category=ErrorCategory.INTEGRATION,
            technical_details={"max_retries": max_retries}
        )
        super().__init__(message, context, **kwargs)
        
class CompositeError(BaseApplicationError):
    """복합 에러 (여러 에러를 그룹화)"""
    def __init__(self, message: str, errors: List[BaseApplicationError], **kwargs):
        context = ErrorContext(
            category=ErrorCategory.INTEGRATION,
            severity=ErrorSeverity.CRITICAL,
            technical_details={"error_count": len(errors)}
        )
        super().__init__(message, context, **kwargs)
        self.errors = errors
        
    def to_dict(self) -> Dict[str, Any]:
        result = super().to_dict()
        result["errors"] = [err.to_dict() for err in self.errors]
        return result

class ExceptionHandler:
    """고급 예외 핸들러"""
    
    def __init__(self):
        self.handlers: Dict[Type[Exception], List[Callable]] = {}
        self.fallback_handler: Optional[Callable] = None
        self.exception_log: List[Dict[str, Any]] = []
        
    def register_handler(self, exception_type: Type[Exception], 
                        handler: Callable[[Exception], Any]):
        """예외 핸들러 등록"""
        if exception_type not in self.handlers:
            self.handlers[exception_type] = []
        self.handlers[exception_type].append(handler)
        
    def set_fallback_handler(self, handler: Callable[[Exception], Any]):
        """폴백 핸들러 설정"""
        self.fallback_handler = handler
        
    def handle(self, exception: Exception) -> Any:
        """예외 처리"""
        # 예외 로깅
        self._log_exception(exception)
        
        # 등록된 핸들러 찾기
        handler_chain = self._find_handler_chain(exception)
        
        if handler_chain:
            # 체인 핸들러 실행
            return self._execute_handler_chain(exception, handler_chain)
        elif self.fallback_handler:
            # 폴백 핸들러 실행
            return self.fallback_handler(exception)
        else:
            # 기본 처리: 재발생
            raise
            
    def _find_handler_chain(self, exception: Exception) -> List[Callable]:
        """예외 타입에 맞는 핸들러 체인 찾기"""
        handler_chain = []
        
        # 정확한 타입 매칭
        exception_type = type(exception)
        if exception_type in self.handlers:
            handler_chain.extend(self.handlers[exception_type])
            
        # 부모 클래스 체인 확인
        for exc_class in exception_type.__mro__:
            if exc_class in self.handlers and exc_class != exception_type:
                handler_chain.extend(self.handlers[exc_class])
                
        return handler_chain
        
    def _execute_handler_chain(self, exception: Exception, 
                              handler_chain: List[Callable]) -> Any:
        """핸들러 체인 실행"""
        result = None
        
        for handler in handler_chain:
            try:
                result = handler(exception)
                # 핸들러가 예외를 처리했음을 표시
                if result is not None:
                    break
            except Exception as handler_error:
                # 핸들러 자체 에러 로깅
                self._log_exception(handler_error, note="Handler error")
                continue
                
        return result
        
    def _log_exception(self, exception: Exception, note: str = None):
        """예외 로깅"""
        log_entry = {
            "timestamp": time.time(),
            "type": type(exception).__name__,
            "message": str(exception),
            "traceback": traceback.format_exc(),
            "note": note
        }
        
        # BaseApplicationError인 경우 추가 정보
        if isinstance(exception, BaseApplicationError):
            log_entry.update(exception.to_dict())
            
        self.exception_log.append(log_entry)
        
    @contextmanager
    def catch_all(self, reraise: bool = False, 
                  log_level: ErrorSeverity = ErrorSeverity.ERROR):
        """모든 예외 캐치 컨텍스트 매니저"""
        try:
            yield
        except Exception as e:
            # 로깅
            self._log_exception(e)
            
            # 처리 시도
            result = self.handle(e)
            
            # 재발생 여부
            if reraise:
                raise
                
            return result
            
    def get_exception_statistics(self) -> Dict[str, Any]:
        """예외 통계 조회"""
        if not self.exception_log:
            return {}
            
        stats = {
            "total_errors": len(self.exception_log),
            "by_type": {},
            "by_severity": {},
            "recent_errors": self.exception_log[-10:]  # 최근 10개
        }
        
        for entry in self.exception_log:
            # 타입별 통계
            error_type = entry["type"]
            stats["by_type"][error_type] = stats["by_type"].get(error_type, 0) + 1
            
            # 심각도별 통계
            severity = entry.get("severity", "unknown")
            stats["by_severity"][severity] = stats["by_severity"].get(severity, 0) + 1
            
        return stats

def demonstrate_exception_handling():
    """예외 처리 데모"""
    print("\n=== 다중 예외 처리와 고급 예외 관리 ===")
    
    handler = ExceptionHandler()
    
    # 1. 다양한 예외 핸들러 등록
    print("\n1. 예외 핸들러 등록 및 처리:")
    
    def handle_validation_error(error: ValidationError):
        print(f"검증 에러 처리: {error.message}")
        if error.context.technical_details.get("field"):
            print(f"문제 필드: {error.context.technical_details['field']}")
        return "VALIDATION_ERROR_HANDLED"
        
    def handle_network_error(error: NetworkError):
        print(f"네트워크 에러 처리: {error.message}")
        details = error.context.technical_details
        if "url" in details:
            print(f"요청 URL: {details['url']}")
        if "status_code" in details:
            print(f"상태 코드: {details['status_code']}")
            
        # 재시도 로직 (시뮬레이션)
        return "NETWORK_ERROR_HANDLED"
        
    def handle_database_error(error: DatabaseError):
        print(f"데이터베이스 에러 처리: {error.message}")
        # 연결 재시도 또는 대체 쿼리 실행
        return "DATABASE_ERROR_HANDLED"
        
    def handle_retryable_error(error: RetryableError):
        print(f"재시도 가능 에러 처리: {error.message}")
        max_retries = error.context.technical_details.get("max_retries", 3)
        print(f"최대 재시도 횟수: {max_retries}")
        return "RETRYABLE_ERROR_HANDLED"
        
    # 폴백 핸들러
    def fallback_handler(error: Exception):
        print(f"폴백 핸들러: 처리되지 않은 에러 - {type(error).__name__}: {error}")
        return "FALLBACK_HANDLED"
        
    # 핸들러 등록
    handler.register_handler(ValidationError, handle_validation_error)
    handler.register_handler(NetworkError, handle_network_error)
    handler.register_handler(DatabaseError, handle_database_error)
    handler.register_handler(RetryableError, handle_retryable_error)
    handler.set_fallback_handler(fallback_handler)
    
    # 2. 다양한 예외 처리 테스트
    print("\n2. 예외 처리 테스트:")
    
    test_exceptions = [
        ValidationError("잘못된 이메일 형식", field="email"),
        NetworkError("서버 연결 실패", url="https://api.example.com", status_code=500),
        DatabaseError("쿼리 실행 실패", query="SELECT * FROM users", database="main_db"),
        RetryableError("임시 네트워크 문제", max_retries=5),
        ValueError("일반 값 에러"),  # 폴백 핸들러로 처리됨
    ]
    
    for exc in test_exceptions:
        print(f"\n처리 중: {type(exc).__name__}")
        result = handler.handle(exc)
        print(f"처리 결과: {result}")
        
    # 3. catch_all 컨텍스트 매니저 데모
    print("\n3. catch_all 컨텍스트 매니저:")
    
    def risky_operation():
        """위험한 연산 (에러 발생 가능)"""
        import random
        operations = [
            lambda: 1 / 0,  # ZeroDivisionError
            lambda: int("not_a_number"),  # ValueError
            lambda: [][0],  # IndexError
            lambda: {}['missing'],  # KeyError
            lambda: open("nonexistent.txt"),  # FileNotFoundError
            lambda: None.attribute,  # AttributeError
        ]
        
        op = random.choice(operations)
        return op()
        
    # 여러 번 실행하여 다양한 예외 포착
    for i in range(5):
        print(f"\n실행 {i+1}:")
        with handler.catch_all(reraise=False) as result:
            risky_operation()
            print("성공 (실행되지 않음)")
            
    # 4. 에러 통계 조회
    print("\n4. 에러 통계:")
    stats = handler.get_exception_statistics()
    
    print(f"총 에러 수: {stats.get('total_errors', 0)}")
    
    print("타입별 에러 분포:")
    for error_type, count in stats.get('by_type', {}).items():
        print(f"  {error_type}: {count}")
        
    # 5. 계층적 예외 처리 데모
    print("\n5. 계층적 예외 처리:")
    
    class PaymentProcessor:
        def __init__(self):
            self.handler = ExceptionHandler()
            self.setup_handlers()
            
        def setup_handlers(self):
            """결제 관련 예외 핸들러 설정"""
            
            def handle_payment_validation_error(error):
                print(f"결제 검증 실패: {error.message}")
                # 결제 재시도 또는 사용자 알림
                return {"action": "retry", "delay": 5}
                
            def handle_payment_network_error(error):
                print(f"결제 게이트웨이 오류: {error.message}")
                # 대체 결제 수단 시도
                return {"action": "fallback_method"}
                
            def handle_insufficient_funds_error(error):
                print(f"잔액 부족: {error.message}")
                # 충전 안내 또는 거절
                return {"action": "reject", "reason": "insufficient_funds"}
                
            # 커스텀 결제 에러 클래스
            class PaymentValidationError(ValidationError):
                pass
                
            class PaymentNetworkError(NetworkError):
                pass
                
            class InsufficientFundsError(BaseApplicationError):
                pass
                
            # 핸들러 등록
            self.handler.register_handler(PaymentValidationError, handle_payment_validation_error)
            self.handler.register_handler(PaymentNetworkError, handle_payment_network_error)
            self.handler.register_handler(InsufficientFundsError, handle_insufficient_funds_error)
            
        def process_payment(self, amount: float):
            """결제 처리 (에러 처리 포함)"""
            with self.handler.catch_all(reraise=True) as result:
                # 결제 로직 (시뮬레이션)
                if amount > 1000:
                    raise ValidationError("한도 초과", field="amount")
                elif amount < 0:
                    raise ValidationError("유효하지 않은 금액", field="amount")
                    
                # 네트워크 에러 시뮬레이션
                import random
                if random.random() < 0.3:
                    raise NetworkError("결제 게이트웨이 타임아웃")
                    
                print(f"결제 성공: ${amount:.2f}")
                return True
                
    # 결제 프로세서 테스트
    processor = PaymentProcessor()
    
    test_amounts = [500, 1500, -100, 750]
    
    for amount in test_amounts:
        print(f"\n결제 처리: ${amount}")
        try:
            result = processor.process_payment(amount)
            print(f"결과: {result}")
        except Exception as e:
            print(f"처리되지 않은 예외: {type(e).__name__}: {e}")

demonstrate_exception_handling()
```

## 모든 예외 캐치와 포괄적인 에러 관리

### 안전한 예외 포착과 시스템 안정성 보장

```python
import logging
from types import TracebackType
from typing import Type, Optional

class ComprehensiveErrorCatcher:
    """포괄적인 에러 캐쳐"""
    
    def __init__(self, 
                 log_errors: bool = True,
                 suppress_all: bool = False,
                 callback: Optional[Callable] = None):
        self.log_errors = log_errors
        self.suppress_all = suppress_all
        self.callback = callback
        self.logger = logging.getLogger(__name__)
        
    def __enter__(self):
        return self
        
    def __exit__(self, 
                 exc_type: Optional[Type[BaseException]],
                 exc_value: Optional[BaseException],
                 exc_traceback: Optional[TracebackType]) -> bool:
        
        if exc_type is not None:
            # 예외 발생 시 처리
            return self._handle_exception(exc_type, exc_value, exc_traceback)
            
        return True  # 예외 없음
        
    def _handle_exception(self, 
                         exc_type: Type[BaseException],
                         exc_value: BaseException,
                         exc_traceback: TracebackType) -> bool:
        """예외 처리"""
        
        # 로깅
        if self.log_errors:
            self._log_exception(exc_type, exc_value, exc_traceback)
            
        # 콜백 실행
        if self.callback:
            try:
                self.callback(exc_type, exc_value, exc_traceback)
            except Exception as callback_error:
                self.logger.error(f"에러 콜백 실행 중 오류: {callback_error}")
                
        # 예외 억제 여부
        return self.suppress_all
        
    def _log_exception(self, 
                      exc_type: Type[BaseException],
                      exc_value: BaseException,
                      exc_traceback: TracebackType):
        """예외 로깅"""
        error_info = {
            "type": exc_type.__name__,
            "message": str(exc_value),
            "traceback": self._format_traceback(exc_traceback)
        }
        
        # 심각도에 따른 로깅 레벨 결정
        if exc_type in (KeyboardInterrupt, SystemExit):
            self.logger.info(f"시스템 신호: {error_info['type']}")
        elif exc_type in (MemoryError,):
            self.logger.critical(f"치명적 에러: {error_info}")
        else:
            self.logger.error(f"에러 발생: {error_info}")
            
    def _format_traceback(self, traceback: TracebackType) -> str:
        """트레이스백 포맷팅"""
        import traceback as tb
        return "".join(tb.format_tb(traceback))
        
    @staticmethod
    def catch_all_decorator(log_errors: bool = True, 
                           suppress: bool = False,
                           default_return = None):
        """모든 예외를 캐치하는 데코레이터"""
        def decorator(func):
            def wrapper(*args, **kwargs):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if log_errors:
                        logging.error(f"함수 {func.__name__} 실행 중 에러: {e}")
                        
                    if suppress:
                        return default_return
                    else:
                        raise
            return wrapper
        return decorator
        
class SystemGuard:
    """시스템 가드: 치명적 에러로부터 보호"""
    
    CRITICAL_EXCEPTIONS = (MemoryError, KeyboardInterrupt, SystemExit)
    
    def __init__(self, max_critical_errors: int = 3):
        self.max_critical_errors = max_critical_errors
        self.critical_error_count = 0
        self.error_history = []
        
    def __enter__(self):
        self.original_excepthook = sys.excepthook
        sys.excepthook = self._custom_excepthook
        return self
        
    def __exit__(self, *args):
        sys.excepthook = self.original_excepthook
        
    def _custom_excepthook(self, exc_type, exc_value, exc_traceback):
        """커스텀 예외 훅"""
        
        # 치명적 에러 체크
        if exc_type in self.CRITICAL_EXCEPTIONS:
            self.critical_error_count += 1
            
            if self.critical_error_count >= self.max_critical_errors:
                print("⚰️ 치명적 에러 한계 초과. 시스템 종료 중...")
                sys.exit(1)
                
        # 에러 기록
        self.error_history.append({
            "type": exc_type.__name__,
            "message": str(exc_value),
            "timestamp": time.time()
        })
        
        # 원래 excepthook 실행 (표준 에러 출력)
        self.original_excepthook(exc_type, exc_value, exc_traceback)

def demonstrate_comprehensive_catching():
    """포괄적인 예외 캐치 데모"""
    print("\n=== 모든 예외 캐치와 시스템 보호 ===")
    
    # 1. 컨텍스트 매니저를 사용한 예외 캐치
    print("\n1. 컨텍스트 매니저로 모든 예외 캐치:")
    
    def error_callback(exc_type, exc_value, exc_tb):
        print(f"콜백: {exc_type.__name__} 발생 - {exc_value}")
        
    catcher = ComprehensiveErrorCatcher(
        log_errors=True,
        suppress_all=False,
        callback=error_callback
    )
    
    # 다양한 예외 테스트
    test_cases = [
        ("ZeroDivisionError", lambda: 1 / 0),
        ("ValueError", lambda: int("invalid")),
        ("TypeError", lambda: "string" + 123),
        ("FileNotFoundError", lambda: open("nonexistent.txt")),
    ]
    
    for name, operation in test_cases:
        print(f"\n테스트: {name}")
        try:
            with catcher:
                operation()
        except Exception as e:
            print(f"캐치된 예외: {type(e).__name__}: {e}")
            
    # 2. 데코레이터를 사용한 함수 단위 예외 캐치
    print("\n2. 데코레이터로 함수 예외 캐치:")
    
    @ComprehensiveErrorCatcher.catch_all_decorator(
        log_errors=True,
        suppress=True,
        default_return="DEFAULT_RETURN"
    )
    def risky_function(should_fail: bool):
        if should_fail:
            raise RuntimeError("의도된 실패")
        return "성공"
        
    print(f"정상 실행: {risky_function(False)}")
    print(f"실패 시도: {risky_function(True)}")
    
    # 3. 시스템 가드 데모
    print("\n3. 시스템 가드 (치명적 에러 보호):")
    
    def simulate_critical_errors():
        """치명적 에러 시뮬레이션"""
        with SystemGuard(max_critical_errors=2) as guard:
            print("시스템 가드 활성화됨")
            
            # 치명적 에러 시뮬레이션 (실제로는 실행되지 않음)
            print("에러 시뮬레이션 중...")
            
            # MemoryError 시뮬레이션 (실제로 발생시키지 않음)
            print("치명적 에러 1 발생 (시뮬레이션)")
            # 실제로는 raise MemoryError()를 사용하지만 데모용으로 출력만
            
            print("치명적 에러 2 발생 (시뮬레이션)")
            # 두 번째 치명적 에러 - 여기서 시스템 종료됨
            
        print("시스템 가드 비활성화됨")
        
    # 시스템 가드 테스트 (실제 에러는 발생시키지 않음)
    simulate_critical_errors()
    
    # 4. 실전 예제: 데이터 처리 파이프라인
    print("\n4. 실전 예제: 데이터 처리 파이프라인")
    
    class DataPipeline:
        """에러에 강건한 데이터 처리 파이프라인"""
        
        def __init__(self):
            self.error_handler = ComprehensiveErrorCatcher(
                log_errors=True,
                suppress_all=False
            )
            self.pipeline_stages = []
            
        def add_stage(self, stage_name: str, processor: Callable):
            """처리 단계 추가"""
            # 에러 처리가 포함된 래퍼 함수 생성
            @ComprehensiveErrorCatcher.catch_all_decorator(
                log_errors=True,
                suppress=False,
                default_return={"error": "processing_failed"}
            )
            def wrapped_processor(data):
                return processor(data)
                
            self.pipeline_stages.append((stage_name, wrapped_processor))
            
        def process(self, data):
            """데이터 처리"""
            current_data = data
            
            for stage_name, processor in self.pipeline_stages:
                print(f"\n단계 실행: {stage_name}")
                
                with self.error_handler:
                    result = processor(current_data)
                    
                    if isinstance(result, dict) and "error" in result:
                        print(f"단계 실패: {stage_name} - {result['error']}")
                        # 실패 처리 로직
                        current_data = self._handle_stage_failure(
                            stage_name, current_data, result
                        )
                    else:
                        print(f"단계 성공: {stage_name}")
                        current_data = result
                        
            return current_data
            
        def _handle_stage_failure(self, stage_name, data, error_result):
            """단계 실패 처리"""
            # 기본 실패 처리: 데이터 유지
            return data
            
    # 데이터 파이프라인 테스트
    pipeline = DataPipeline()
    
    # 처리 단계 정의 (일부는 실패하도록)
    pipeline.add_stage("validation", lambda x: x if x else ValueError("빈 데이터"))
    pipeline.add_stage("transformation", lambda x: x * 2 if isinstance(x, (int, float)) else TypeError("숫자 아님"))
    pipeline.add_stage("enrichment", lambda x: f"결과: {x}")
    
    # 테스트 데이터
    test_data = [10, None, "text", 3.14]
    
    for data in test_data:
        print(f"\n{'='*40}")
        print(f"데이터 처리: {data}")
        try:
            result = pipeline.process(data)
            print(f"최종 결과: {result}")
        except Exception as e:
            print(f"파이프라인 실패: {type(e).__name__}: {e}")

demonstrate_comprehensive_catching()
```

## 커스텀 예외 생성과 계층적 에러 시스템

### 도메인 특화 예외 클래스 설계

```python
from abc import ABC
from typing import Optional, Dict, Any, List

class DomainError(BaseApplicationError, ABC):
    """도메인 에러 베이스 클래스"""
    pass

class ECommerceError(DomainError):
    """전자상거래 도메인 에러"""
    DOMAIN = "ecommerce"
    
    def __init__(self, message: str, user_id: Optional[str] = None,
                 order_id: Optional[str] = None, **kwargs):
        details = {}
        if user_id:
            details["user_id"] = user_id
        if order_id:
            details["order_id"] = order_id
            
        context = ErrorContext(
            category=ErrorCategory.BUSINESS_LOGIC,
            technical_details=details
        )
        super().__init__(message, context, **kwargs)

class PaymentError(ECommerceError):
    """결제 에러"""
    SUBDOMAIN = "payment"
    
    def __init__(self, message: str, amount: Optional[float] = None,
                 payment_method: Optional[str] = None, **kwargs):
        details = kwargs.get("context", ErrorContext()).technical_details
        if amount is not None:
            details["amount"] = amount
        if payment_method:
            details["payment_method"] = payment_method
            
        context = ErrorContext(
            category=ErrorCategory.BUSINESS_LOGIC,
            user_message="결제 처리 중 문제가 발생했습니다",
            technical_details=details
        )
        super().__init__(message, **{**kwargs, "context": context})

class InsufficientFundsError(PaymentError):
    """잔액 부족 에러"""
    ERROR_CODE = "PAYMENT_001"
    
    def __init__(self, current_balance: float, required_amount: float, **kwargs):
        message = f"잔액 부족: 현재 {current_balance}, 필요 {required_amount}"
        details = {
            "current_balance": current_balance,
            "required_amount": required_amount,
            "shortage": required_amount - current_balance
        }
        
        context = ErrorContext(
            category=ErrorCategory.BUSINESS_LOGIC,
            severity=ErrorSeverity.WARNING,
            user_message="계좌 잔액이 부족합니다",
            technical_details=details
        )
        super().__init__(message, context=context, **kwargs)

class PaymentGatewayError(PaymentError):
    """결제 게이트웨이 에러"""
    ERROR_CODE = "PAYMENT_002"
    
    def __init__(self, gateway: str, status_code: int, response: Dict, **kwargs):
        message = f"결제 게이트웨이({gateway}) 오류: {status_code}"
        details = {
            "gateway": gateway,
            "status_code": status_code,
            "response": response
        }
        
        context = ErrorContext(
            category=ErrorCategory.INTEGRATION,
            user_message="결제 시스템에 일시적인 문제가 발생했습니다",
            technical_details=details
        )
        super().__init__(message, context=context, **kwargs)

class InventoryError(ECommerceError):
    """재고 관련 에러"""
    SUBDOMAIN = "inventory"
    
    def __init__(self, message: str, product_id: str, 
                 requested_quantity: int, available_quantity: int, **kwargs):
        details = {
            "product_id": product_id,
            "requested_quantity": requested_quantity,
            "available_quantity": available_quantity
        }
        
        context = ErrorContext(
            category=ErrorCategory.BUSINESS_LOGIC,
            user_message="상품 재고가 부족합니다",
            technical_details=details
        )
        super().__init__(message, context=context, **kwargs)

class ErrorFactory:
    """에러 팩토리: 에러 생성 및 관리"""
    
    _error_registry: Dict[str, Type[DomainError]] = {}
    
    @classmethod
    def register_error(cls, error_code: str, error_class: Type[DomainError]):
        """에러 클래스 등록"""
        cls._error_registry[error_code] = error_class
        
    @classmethod
    def create_error(cls, error_code: str, **kwargs) -> DomainError:
        """에러 생성"""
        if error_code not in cls._error_registry:
            raise ValueError(f"등록되지 않은 에러 코드: {error_code}")
            
        error_class = cls._error_registry[error_code]
        
        # 에러 코드에서 메시지 추출 (있을 경우)
        if hasattr(error_class, 'ERROR_CODE'):
            kwargs.setdefault('error_code', error_class.ERROR_CODE)
            
        return error_class(**kwargs)
        
    @classmethod
    def create_from_exception(cls, exception: Exception, 
                             error_code: str = "GENERIC_ERROR") -> DomainError:
        """기존 예외로부터 도메인 에러 생성"""
        error_class = cls._error_registry.get(error_code, ECommerceError)
        
        # 원본 예외 정보 포함
        context = ErrorContext(
            category=ErrorCategory.INTEGRATION,
            technical_details={
                "original_exception": type(exception).__name__,
                "original_message": str(exception)
            }
        )
        
        return error_class(
            message=f"변환된 에러: {exception}",
            context=context,
            cause=exception
        )

def demonstrate_custom_exceptions():
    """커스텀 예외 데모"""
    print("\n=== 커스텀 예외 생성과 계층적 에러 시스템 ===")
    
    # 에러 팩토리 초기화
    ErrorFactory.register_error("INSUFFICIENT_FUNDS", InsufficientFundsError)
    ErrorFactory.register_error("PAYMENT_GATEWAY_ERROR", PaymentGatewayError)
    
    # 1. 계층적 예외 생성
    print("\n1. 계층적 예외 생성:")
    
    # 다양한 수준의 예외 생성
    base_error = ECommerceError(
        "일반 상거래 에러",
        user_id="user123",
        order_id="order456"
    )
    
    payment_error = PaymentError(
        "결제 처리 실패",
        amount=100.50,
        payment_method="credit_card",
        user_id="user123"
    )
    
    funds_error = InsufficientFundsError(
        current_balance=50.0,
        required_amount=100.0,
        user_id="user123"
    )
    
    gateway_error = PaymentGatewayError(
        gateway="Stripe",
        status_code=500,
        response={"error": "internal_server_error"},
        order_id="order789"
    )
    
    # 에러 정보 출력
    errors = [base_error, payment_error, funds_error, gateway_error]
    
    for error in errors:
        print(f"\n{error.__class__.__name__}:")
        print(f"  메시지: {error.message}")
        print(f"  심각도: {error.context.severity.value}")
        if isinstance(error, PaymentError):
            print(f"  금액: {error.context.technical_details.get('amount')}")
        if isinstance(error, InsufficientFundsError):
            print(f"  부족액: {error.context.technical_details.get('shortage')}")
            
    # 2. 에러 팩토리 사용
    print("\n2. 에러 팩토리 사용:")
    
    # 등록된 에러 코드로 생성
    try:
        funds_error = ErrorFactory.create_error(
            "INSUFFICIENT_FUNDS",
            current_balance=75.0,
            required_amount=150.0,
            user_id="user456"
        )
        print(f"팩토리 생성 에러: {funds_error.message}")
        
    except ValueError as e:
        print(f"에러 생성 실패: {e}")
        
    # 3. 예외 변환
    print("\n3. 예외 변환 (다른 예외를 도메인 에러로):")
    
    def process_payment(amount: float):
        """결제 처리 (예외 발생 가능)"""
        # 다양한 예외 상황 시뮬레이션
        import random
        scenarios = [
            lambda: (_ for _ in ()).throw(ValueError("잘못된 금액 형식")),
            lambda: (_ for _ in ()).throw(ConnectionError("네트워크 연결 실패")),
            lambda: (_ for _ in ()).throw(Exception("알 수 없는 오류")),
        ]
        
        scenario = random.choice(scenarios)
        scenario()
        
    try:
        process_payment(100.0)
    except Exception as e:
        # 일반 예외를 도메인 에러로 변환
        domain_error = ErrorFactory.create_from_exception(
            e,
            error_code="PAYMENT_GATEWAY_ERROR"
        )
        
        print(f"원본 예외: {type(e).__name__}: {e}")
        print(f"변환된 에러: {domain_error.__class__.__name__}")
        print(f"에러 메시지: {domain_error.message}")
        
    # 4. 실전 예제: 주문 처리 시스템
    print("\n4. 실전 예제: 주문 처리 시스템")
    
    class OrderProcessor:
        """주문 처리 시스템"""
        
        def __init__(self):
            self.error_handler = ExceptionHandler()
            self.setup_error_handlers()
            
        def setup_error_handlers(self):
            """에러 핸들러 설정"""
            
            def handle_insufficient_funds(error: InsufficientFundsError):
                print(f"잔액 부족 처리: 사용자에게 알림")
                details = error.context.technical_details
                shortage = details.get('shortage', 0)
                return {
                    "action": "notify_user",
                    "message": f"잔액이 {shortage}원 부족합니다",
                    "retryable": False
                }
                
            def handle_payment_gateway_error(error: PaymentGatewayError):
                print(f"결제 게이트웨이 오류 처리: 재시도")
                details = error.context.technical_details
                status_code = details.get('status_code', 0)
                
                # 5xx 에러는 재시도, 4xx 에러는 재시도 안함
                if 500 <= status_code < 600:
                    return {
                        "action": "retry",
                        "delay": 5,
                        "max_retries": 3
                    }
                else:
                    return {
                        "action": "fail",
                        "reason": "client_error"
                    }
                    
            self.error_handler.register_handler(
                InsufficientFundsError,
                handle_insufficient_funds
            )
            self.error_handler.register_handler(
                PaymentGatewayError,
                handle_payment_gateway_error
            )
            
        def process_order(self, order_data: Dict[str, Any]):
            """주문 처리"""
            try:
                # 결제 처리 시뮬레이션
                self._process_payment(order_data)
                
                # 재고 확인 시뮬레이션
                self._check_inventory(order_data)
                
                print("주문 처리 완료")
                return {"status": "success"}
                
            except Exception as e:
                # 에러 처리
                result = self.error_handler.handle(e)
                
                if result:
                    print(f"에러 처리 결과: {result}")
                    return {"status": "handled", "details": result}
                else:
                    # 처리되지 않은 에러
                    raise
                    
        def _process_payment(self, order_data: Dict[str, Any]):
            """결제 처리 (에러 발생 가능)"""
            amount = order_data.get('amount', 0)
            balance = order_data.get('balance', 0)
            
            # 잔액 부족 체크
            if amount > balance:
                raise InsufficientFundsError(
                    current_balance=balance,
                    required_amount=amount,
                    user_id=order_data.get('user_id')
                )
                
            # 결제 게이트웨이 에러 시뮬레이션
            import random
            if random.random() < 0.3:
                raise PaymentGatewayError(
                    gateway="TestGateway",
                    status_code=503,
                    response={"error": "service_unavailable"},
                    order_id=order_data.get('order_id')
                )
                
        def _check_inventory(self, order_data: Dict[str, Any]):
            """재고 확인"""
            # 재고 부족 에러 시뮬레이션
            import random
            if random.random() < 0.2:
                raise InventoryError(
                    message="재고 부족",
                    product_id=order_data.get('product_id', 'unknown'),
                    requested_quantity=order_data.get('quantity', 1),
                    available_quantity=0
                )
                
    # 주문 처리 테스트
    processor = OrderProcessor()
    
    test_orders = [
        {"order_id": "001", "amount": 100, "balance": 50, "user_id": "user1", "product_id": "prod1", "quantity": 2},
        {"order_id": "002", "amount": 200, "balance": 300, "user_id": "user2", "product_id": "prod2", "quantity": 1},
        {"order_id": "003", "amount": 150, "balance": 200, "user_id": "user3", "product_id": "prod3", "quantity": 3},
    ]
    
    for order in test_orders:
        print(f"\n{'='*40}")
        print(f"주문 처리: {order['order_id']}")
        
        try:
            result = processor.process_order(order)
            print(f"처리 결과: {result['status']}")
        except Exception as e:
            print(f"처리 실패: {type(e).__name__}: {e}")

demonstrate_custom_exceptions()
```

## 다른 예외에 대한 응답으로 예외 발생과 마지막 예외 다시 발생

### 체인 예외 처리와 재발생 패턴

```python
import traceback
from typing import Optional, List, Dict

class ExceptionChainer:
    """예외 체이닝 관리자"""
    
    def __init__(self):
        self.exception_chain: List[Exception] = []
        
    def chain_exception(self, new_exception: Exception, 
                       cause: Optional[Exception] = None) -> Exception:
        """예외 체이닝"""
        if cause is None and self.exception_chain:
            cause = self.exception_chain[-1]
            
        # 예외에 원인 설정 (Python 3.0+ __cause__ 사용)
        if cause:
            new_exception.__cause__ = cause
            
        self.exception_chain.append(new_exception)
        return new_exception
        
    def raise_chained(self, exception: Exception, 
                     cause: Optional[Exception] = None):
        """체인된 예외 발생"""
        chained = self.chain_exception(exception, cause)
        raise chained
        
    def get_full_traceback(self) -> str:
        """전체 트레이스백 가져오기"""
        if not self.exception_chain:
            return ""
            
        full_traceback = []
        
        for i, exc in enumerate(self.exception_chain):
            full_traceback.append(f"\n{'='*60}")
            full_traceback.append(f"예외 {i+1}: {type(exc).__name__}")
            full_traceback.append(f"메시지: {exc}")
            
            if exc.__cause__:
                full_traceback.append(f"원인: {type(exc.__cause__).__name__}: {exc.__cause__}")
                
            full_traceback.append(f"\n트레이스백:")
            full_traceback.append(''.join(traceback.format_tb(exc.__traceback__)))
            
        return '\n'.join(full_traceback)

class ExceptionTransformer:
    """예외 변환기: 다른 예외에 대한 응답으로 예외 발생"""
    
    @staticmethod
    def transform_exception(original_exception: Exception,
                          new_exception_type: Type[Exception],
                          message: Optional[str] = None,
                          preserve_context: bool = True) -> Exception:
        """예외 변환"""
        
        # 새 예외 메시지 생성
        if message is None:
            message = f"변환됨: {original_exception}"
            
        # 새 예외 생성
        new_exception = new_exception_type(message)
        
        # 컨텍스트 보존
        if preserve_context:
            # __cause__ 설정 (원인 관계)
            new_exception.__cause__ = original_exception
            
            # __context__ 설정 (컨텍스트 관계)
            new_exception.__context__ = original_exception
            
            # 원본 예외 정보 보존
            setattr(new_exception, '_original_exception', original_exception)
            setattr(new_exception, '_original_traceback', 
                   traceback.extract_tb(original_exception.__traceback__))
            
        return new_exception
        
    @staticmethod
    def reraise_with_context(exception: Exception,
                           additional_message: str = "",
                           new_exception_type: Optional[Type[Exception]] = None):
        """컨텍스트와 함께 예외 재발생"""
        
        # 새 메시지 생성
        new_message = f"{additional_message}: {exception}" if additional_message else str(exception)
        
        # 새 예외 타입 결정
        if new_exception_type is None:
            new_exception_type = type(exception)
            
        # 새 예외 생성
        new_exception = new_exception_type(new_message)
        
        # 모든 컨텍스트 보존
        new_exception.__cause__ = exception.__cause__ if hasattr(exception, '__cause__') else None
        new_exception.__context__ = exception.__context__ if hasattr(exception, '__context__') else None
        new_exception.__traceback__ = exception.__traceback__
        
        # 추가 정보 복사
        if hasattr(exception, '_original_exception'):
            setattr(new_exception, '_original_exception', exception._original_exception)
            
        raise new_exception

class RetryManager:
    """재시도 관리자"""
    
    def __init__(self, max_retries: int = 3, 
                 backoff_factor: float = 1.0,
                 retry_exceptions: Optional[List[Type[Exception]]] = None):
        self.max_retries = max_retries
        self.backoff_factor = backoff_factor
        self.retry_exceptions = retry_exceptions or [Exception]
        self.attempts = 0
        
    @contextmanager
    def retry_context(self):
        """재시도 컨텍스트"""
        last_exception = None
        
        for attempt in range(self.max_retries + 1):
            self.attempts = attempt
            
            try:
                yield attempt
                return  # 성공
                
            except Exception as e:
                last_exception = e
                
                # 재시도 가능한 예외인지 확인
                if not self._is_retryable(e) or attempt == self.max_retries:
                    break
                    
                # 재시도 대기
                wait_time = self.backoff_factor * (2 ** attempt)
                print(f"재시도 {attempt + 1}/{self.max_retries}: {wait_time:.1f}초 후 재시도")
                time.sleep(wait_time)
                
        # 모든 재시도 실패
        if last_exception:
            self._reraise_with_retry_info(last_exception)
            
    def _is_retryable(self, exception: Exception) -> bool:
        """재시도 가능 여부 확인"""
        return any(isinstance(exception, exc_type) 
                  for exc_type in self.retry_exceptions)
                  
    def _reraise_with_retry_info(self, exception: Exception):
        """재시도 정보와 함께 예외 재발생"""
        retry_info = {
            "max_retries": self.max_retries,
            "attempts_made": self.attempts,
            "backoff_factor": self.backoff_factor
        }
        
        # 새 예외 메시지
        new_message = (f"{exception} (재시도 {self.attempts}/{self.max_retries} 실패, "
                      f"backoff={self.backoff_factor})")
        
        # 예외 변환
        transformed = ExceptionTransformer.transform_exception(
            exception,
            type(exception),
            new_message,
            preserve_context=True
        )
        
        # 재시도 정보 추가
        setattr(transformed, '_retry_info', retry_info)
        
        raise transformed

def demonstrate_exception_chaining_and_reraising():
    """예외 체이닝과 재발생 데모"""
    print("\n=== 다른 예외에 대한 응답으로 예외 발생과 재발생 ===")
    
    # 1. 예외 체이닝
    print("\n1. 예외 체이닝:")
    
    chainer = ExceptionChainer()
    
    try:
        try:
            # 첫 번째 예외
            raise ValueError("잘못된 값")
        except ValueError as e1:
            # 두 번째 예외 (첫 번째를 원인으로)
            chainer.raise_chained(
                TypeError("타입 에러"),
                cause=e1
            )
    except TypeError as e2:
        print(f"캐치된 예외: {type(e2).__name__}: {e2}")
        if e2.__cause__:
            print(f"원인 예외: {type(e2.__cause__).__name__}: {e2.__cause__}")
            
    # 2. 체인된 예외 트레이스백
    print("\n2. 체인된 예외 트레이스백:")
    
    def level1():
        raise ConnectionError("레벨1: 연결 실패")
        
    def level2():
        try:
            level1()
        except ConnectionError as e1:
            # 변환하여 재발생
            new_exception = ExceptionTransformer.transform_exception(
                e1,
                RuntimeError,
                "레벨2: 런타임 에러로 변환"
            )
            raise new_exception
            
    def level3():
        try:
            level2()
        except RuntimeError as e2:
            # 다시 변환하여 재발생
            new_exception = ExceptionTransformer.transform_exception(
                e2,
                SystemError,
                "레벨3: 시스템 에러로 변환"
            )
            raise new_exception
            
    try:
        level3()
    except SystemError as e3:
        print(f"최종 예외: {type(e3).__name__}: {e3}")
        
        # 트레이스백 출력
        print("\n체인된 트레이스백:")
        tb = chainer.get_full_traceback()
        print(tb if tb else "트레이스백 없음")
        
    # 3. 재시도 매니저를 사용한 예외 처리
    print("\n3. 재시도 매니저를 사용한 예외 처리:")
    
    retry_manager = RetryManager(
        max_retries=3,
        backoff_factor=0.5,
        retry_exceptions=[ConnectionError, TimeoutError]
    )
    
    def unreliable_network_operation(attempt: int):
        """신뢰할 수 없는 네트워크 연산"""
        import random
        
        # 의도적으로 실패 확률 조정
        if random.random() < 0.7:  # 70% 실패율
            raise ConnectionError(f"네트워크 연결 실패 (시도: {attempt})")
            
        return "연산 성공"
        
    with retry_manager.retry_context() as attempt:
        result = unreliable_network_operation(attempt)
        print(f"결과: {result}")
        
    # 4. 예외 변환과 재발생 패턴
    print("\n4. 예외 변환과 재발생 패턴:")
    
    class DatabaseService:
        """데이터베이스 서비스 (예외 변환 예제)"""
        
        def __init__(self):
            self.exception_transformer = ExceptionTransformer
            
        def execute_query(self, query: str):
            """쿼리 실행"""
            try:
                # 데이터베이스 연산 시뮬레이션
                if "DROP" in query.upper():
                    raise ValueError("잘못된 쿼리: DROP 문은 허용되지 않음")
                    
                if "SELECT" not in query.upper():
                    raise SyntaxError("잘못된 SQL 문법")
                    
                return [{"id": 1, "name": "테스트 데이터"}]
                
            except (ValueError, SyntaxError) as e:
                # 저수준 예외를 고수준 예외로 변환
                transformed = self.exception_transformer.transform_exception(
                    e,
                    DatabaseError,
                    "데이터베이스 연산 실패",
                    preserve_context=True
                )
                raise transformed
                
    class APIWrapper:
        """API 래퍼 (재발생 패턴 예제)"""
        
        def __init__(self, database: DatabaseService):
            self.database = database
            
        def get_user_data(self, user_id: str):
            """사용자 데이터 조회"""
            try:
                query = f"SELECT * FROM users WHERE id = {user_id}"
                return self.database.execute_query(query)
                
            except DatabaseError as e:
                # 데이터베이스 에러를 API 에러로 변환
                self._handle_database_error(e)
                
        def _handle_database_error(self, error: DatabaseError):
            """데이터베이스 에러 처리"""
            print(f"데이터베이스 에러 처리 중...")
            
            # 원본 예외 정보 확인
            if hasattr(error, '_original_exception'):
                original = error._original_exception
                print(f"원본 예외: {type(original).__name__}: {original}")
                
            # API 클라이언트를 위한 에러로 변환
            api_error = ExceptionTransformer.transform_exception(
                error,
                NetworkError,
                "서버 내부 오류",
                preserve_context=True
            )
            
            # 재발생
            raise api_error
            
    # 통합 테스트
    database = DatabaseService()
    api = APIWrapper(database)
    
    test_queries = [
        "SELECT * FROM users",  # 정상
        "DROP TABLE users",     # ValueError 발생
        "INVALID SQL",          # SyntaxError 발생
    ]
    
    for query in test_queries:
        print(f"\n쿼리 실행: {query}")
        try:
            result = database.execute_query(query)
            print(f"결과: {result}")
        except DatabaseError as e:
            print(f"데이터베이스 에러: {type(e).__name__}: {e}")
            if e.__cause__:
                print(f"원인: {type(e.__cause__).__name__}: {e.__cause__}")
                
    # 5. 마지막 예외 다시 발생 패턴
    print("\n5. 마지막 예외 다시 발생 패턴:")
    
    class TransactionManager:
        """트랜잭션 관리자"""
        
        def __init__(self):
            self.last_exception = None
            
        @contextmanager
        def transaction(self):
            """트랜잭션 컨텍스트"""
            print("트랜잭션 시작")
            
            try:
                yield
                print("트랜잭션 커밋")
                
            except Exception as e:
                print("트랜잭션 롤백")
                self.last_exception = e
                
                # 트랜잭션 에러 정보 추가
                transaction_error = ExceptionTransformer.transform_exception(
                    e,
                    type(e),
                    f"트랜잭션 실패: {e}",
                    preserve_context=True
                )
                
                # 트랜잭션 컨텍스트 정보 추가
                setattr(transaction_error, '_transaction_context', {
                    'action': 'rollback',
                    'timestamp': time.time()
                })
                
                # 마지막 예외로 저장
                self.last_exception = transaction_error
                
                # 다시 발생
                raise transaction_error
                
        def get_last_exception(self) -> Optional[Exception]:
            """마지막 예외 가져오기"""
            return self.last_exception
            
        def reraise_last_exception(self, additional_info: str = ""):
            """마지막 예외 다시 발생"""
            if not self.last_exception:
                raise RuntimeError("재발생할 예외가 없습니다")
                
            ExceptionTransformer.reraise_with_context(
                self.last_exception,
                additional_info,
                type(self.last_exception)
            )
    
    # 트랜잭션 매니저 테스트
    transaction_mgr = TransactionManager()
    
    try:
        with transaction_mgr.transaction():
            # 트랜잭션 내부 작업
            print("작업 실행 중...")
            raise ValueError("의도된 트랜잭션 실패")
            
    except Exception as e:
        print(f"트랜잭션 에러 캐치: {type(e).__name__}: {e}")
        
        # 마지막 예외 확인
        last_exc = transaction_mgr.get_last_exception()
        if last_exc:
            print(f"저장된 마지막 예외: {type(last_exc).__name__}")
            
        # 다시 발생 시도
        try:
            transaction_mgr.reraise_last_exception("추가 정보 포함")
        except ValueError as reraisd:
            print(f"재발생된 예외: {type(reraisd).__name__}: {reraisd}")

demonstrate_exception_chaining_and_reraising()
```

## 결론

파이썬의 예외 처리 시스템은 단순한 오류 메시지 출력을 넘어 애플리케이션의 견고성, 유지보수성, 사용자 경험을 결정하는 핵심 요소입니다. 효과적인 예외 처리를 위한 핵심 원칙은 다음과 같습니다:

1. **도메인 특화 예외 계층 구조**: 비즈니스 로직에 맞는 커스텀 예외 클래스를 설계하여 의미 있는 에러 정보를 제공해야 합니다.

2. **체계적인 예외 변환**: 저수준 예외를 고수준 도메인 예외로 변환하여 추상화 수준을 일관되게 유지해야 합니다.

3. **상황 인식 예외 처리**: 예외의 심각도, 카테고리, 컨텍스트에 따라 적절한 처리를 제공해야 합니다.

4. **예외 체이닝과 원인 보존**: `__cause__`와 `__context__`를 활용하여 예외의 근본 원인을 추적할 수 있어야 합니다.

5. **안전한 예외 재발생**: 필요한 정보를 보존하면서 예외를 다시 발생시켜 상위 레벨에서 적절히 처리할 수 있도록 해야 합니다.

6. **조건부 테스트 스킵**: 테스트 환경의 제약 조건을 사전에 평가하여 불필요한 실패를 방지해야 합니다.

실제 프로덕션 환경에서는 다음과 같은 추가 고려사항이 필요합니다:
- **에러 모니터링과 알림**: 예외 발생 시 실시간 모니터링 시스템에 보고
- **회복 전략**: 재시도, 폴백, 회로 차단기 패턴 구현
- **사용자 친화적 에러 메시지**: 기술적 세부사항과 사용자용 메시지 분리
- **에러 통계와 분석**: 에러 패턴 분석을 통한 시스템 개선
- **테스트 커버리지**: 예외 처리 로직에 대한 철저한 테스트 작성

이러한 원칙과 패턴들을 적용하면 예외 상황에서도 안정적으로 동작하며, 문제 발생 시 빠른 디버깅과 복구가 가능한 견고한 애플리케이션을 구축할 수 있습니다. 예외 처리를 전략적으로 설계하면 시스템의 신뢰성을 크게 향상시키고 유지보수 비용을 절감할 수 있습니다.