---
layout: post
title: C++ - STL (6)
date: 2024-09-17 19:20:23 +0900
category: Cpp
---
# STL 6 â€” ì‹¤ì „ í™œìš© íŒê³¼ í”í•œ ì‹¤ìˆ˜ ë°©ì§€

## ì‹¤ì „ ìƒí™©ë³„ íŒ¨í„´ ê°€ì´ë“œ

STLì„ íš¨ê³¼ì ìœ¼ë¡œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” íŠ¹ì • ìƒí™©ì— ë§ëŠ” íŒ¨í„´ì„ ì•Œê³  ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ë‹¤ìŒì€ ìì£¼ ë§ˆì£¼ì¹˜ëŠ” ìƒí™©ë“¤ì— ëŒ€í•œ ê¶Œì¥ í•´ê²°ì±…ì…ë‹ˆë‹¤:

| ìƒí™© | ê¶Œì¥ íŒ¨í„´ | ì„¤ëª… |
|------|-----------|------|
| **ìˆœíšŒ ì¤‘ ìš”ì†Œ ì‚­ì œ** | `it = container.erase(it)` | ì‹œí€€ìŠ¤ ì»¨í…Œì´ë„ˆì—ì„œ ì•ˆì „í•˜ê²Œ ì‚­ì œí•˜ë©´ì„œ ìˆœíšŒ |
| **ì¡°ê±´ë¶€ ì‚­ì œ** | `erase(remove_if(...), end())` | ë²¡í„°, ë¬¸ìì—´ ë“± ì‹œí€€ìŠ¤ ì»¨í…Œì´ë„ˆì—ì„œ ë‹¤ìˆ˜ ì‚­ì œ |
| **ë§µì—ì„œ ì—†ì„ ë•Œë§Œ ìƒì„±** | `map.try_emplace(key, ìƒì„±ì_ì¸ì...)` | í‚¤ê°€ ì—†ì„ ë•Œë§Œ ê°’ ìƒì„±, ë³µì‚¬ ë°©ì§€ |
| **ë§µì˜ í‚¤ ì¡´ì¬ í™•ì¸** | `map.contains(key)` (C++20) ë˜ëŠ” `find() != end()` | `operator[]` ëŒ€ì‹  ëª…ì‹œì  í™•ì¸ |
| **ë¹ ë¥¸ ì‚½ì…** | `emplace_back()`, `emplace()`, `try_emplace()` | ì´ë™ ì—†ì´ ì œìë¦¬ì—ì„œ ìƒì„± |
| **ë³µí•© ì •ë ¬ ê¸°ì¤€** | `std::tie(field1, field2) < std::tie(other1, other2)` | ë‹¤ì¤‘ í•„ë“œ ì •ë ¬ ê°„í¸ êµ¬í˜„ |
| **í•´ì‹œ ì»¨í…Œì´ë„ˆ ì„±ëŠ¥ ì¡°ì •** | `reserve(n)` + `max_load_factor(Î±)` | ë¦¬í•´ì‹œ(rehash) ìµœì†Œí™” |
| **ì •ë ¬ëœ ì»¨í…Œì´ë„ˆ ë²”ìœ„ ê²€ìƒ‰** | `lower_bound()`, `upper_bound()`, `equal_range()` | íš¨ìœ¨ì ì¸ ë²”ìœ„ ê¸°ë°˜ ê²€ìƒ‰ |
| **ë°˜ë³µì ì•ˆì •ì„±ì´ ì¤‘ìš”í•œ ê²½ìš°** | `list`, `set`, `map` ì‚¬ìš© | ë…¸ë“œ ê¸°ë°˜ ì»¨í…Œì´ë„ˆëŠ” ëŒ€ë¶€ë¶„ ì•ˆì •ì  |
| **ëŒ€ëŸ‰ ë°ì´í„° ì‚½ì… ì „** | `vector.reserve(N)` | ì¬í• ë‹¹(reallocation) ìµœì†Œí™” |
| **ë³µì‚¬ ëŒ€ì‹  ì´ë™ ê°€ëŠ¥í•  ë•Œ** | `std::make_move_iterator()` | ë¶ˆí•„ìš”í•œ ë³µì‚¬ ì œê±° |

---

## ë°˜ë³µ ì¤‘ ì‚­ì œ: ì•ˆì „í•˜ê²Œ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•

ìˆœíšŒí•˜ë©´ì„œ ìš”ì†Œë¥¼ ì‚­ì œí•˜ëŠ” ê²ƒì€ STLì—ì„œ ê°€ì¥ í”í•œ ì‹¤ìˆ˜ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ì˜¬ë°”ë¥¸ ì ‘ê·¼ë²•ì„ ì•Œì•„ë´…ì‹œë‹¤.

### âŒ ìœ„í—˜í•œ ë°©ë²•: ì¸ë±ìŠ¤ ê¸°ë°˜ ì‚­ì œ
```cpp
std::vector<int> v = {1, 2, 3, 2, 4};

// ìœ„í—˜í•œ ì½”ë“œ - ìš”ì†Œê°€ ì‚­ì œë˜ë©´ ì¸ë±ìŠ¤ê°€ ë³€ê²½ë©ë‹ˆë‹¤
for (size_t i = 0; i < v.size(); ++i) {
    if (v[i] == 2) {
        v.erase(v.begin() + i);
        // iëŠ” ê·¸ëŒ€ë¡œì´ì§€ë§Œ, ë’¤ì˜ ìš”ì†Œë“¤ì´ ì•ìœ¼ë¡œ ë‹¹ê²¨ì§‘ë‹ˆë‹¤
        // ë‹¤ìŒ 2ë¥¼ ê±´ë„ˆë›°ê±°ë‚˜ ë²¡í„° ë²”ìœ„ë¥¼ ë²—ì–´ë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤
    }
}
```

### ğŸ”§ í•´ê²°ì±… 1: ì—­ìˆœ ìˆœíšŒ (ê°„ë‹¨í•˜ì§€ë§Œ ë¹„íš¨ìœ¨ì )
```cpp
// ì—­ìˆœìœ¼ë¡œ ì‚­ì œí•˜ë©´ ì•ˆì „í•˜ì§€ë§Œ O(nÂ²)ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤
for (int i = v.size() - 1; i >= 0; --i) {
    if (v[i] == 2) {
        v.erase(v.begin() + i);
    }
}
```

### ğŸ”§ í•´ê²°ì±… 2: ë°˜ë³µì ì‚¬ìš© (ì˜¬ë°”ë¥¸ ë°©ë²•)
```cpp
// ë°˜ë³µìë¥¼ ì‚¬ìš©í•œ ì•ˆì „í•œ ì‚­ì œ
for (auto it = v.begin(); it != v.end(); ) {
    if (*it == 2) {
        it = v.erase(it);  // eraseëŠ” ì‚­ì œëœ ìš”ì†Œ ë‹¤ìŒì˜ ë°˜ë³µìë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤
    } else {
        ++it;  // ì‚­ì œí•˜ì§€ ì•Šì•˜ë‹¤ë©´ ë‹¤ìŒìœ¼ë¡œ ì´ë™
    }
}
```

### ğŸ”§ í•´ê²°ì±… 3: erase-remove ê´€ìš©êµ¬ (ê°€ì¥ íš¨ìœ¨ì )
```cpp
#include <algorithm>

// ë²¡í„°, ë¬¸ìì—´ ë“± ì‹œí€€ìŠ¤ ì»¨í…Œì´ë„ˆì— ìµœì í™”ëœ ë°©ë²•
v.erase(std::remove(v.begin(), v.end(), 2), v.end());
```

### ğŸ”§ í•´ê²°ì±… 4: C++20 erase/erase_if (ê°€ì¥ ê°„ê²°)
```cpp
// C++20ë¶€í„° ì‚¬ìš© ê°€ëŠ¥í•œ ê°€ì¥ ê¹”ë”í•œ ë°©ë²•
std::erase(v, 2);  // ëª¨ë“  2 ì‚­ì œ

// ë˜ëŠ” ì¡°ê±´ë¶€ ì‚­ì œ
std::erase_if(v, [](int x) { return x % 2 == 0; });  // ëª¨ë“  ì§ìˆ˜ ì‚­ì œ
```

### ğŸ”§ í•´ê²°ì±… 5: set/mapì—ì„œì˜ ì•ˆì „í•œ ì‚­ì œ
```cpp
#include <set>

std::set<int> s = {1, 2, 3, 4, 5};

// set, map ë“±ì—ì„œë„ ë¹„ìŠ·í•œ íŒ¨í„´
for (auto it = s.begin(); it != s.end(); ) {
    if (*it % 2 == 0) {
        it = s.erase(it);  // C++11ë¶€í„° eraseê°€ ë‹¤ìŒ ë°˜ë³µìë¥¼ ë°˜í™˜
    } else {
        ++it;
    }
}

// âŒ ì ˆëŒ€ ì´ë ‡ê²Œ í•˜ì§€ ë§ˆì„¸ìš”!
// for (auto it = s.begin(); it != s.end(); ++it) {
//     if (*it % 2 == 0) {
//         s.erase(it);  // itì€ ë¬´íš¨í™”ë¨, ë‹¤ìŒ ++itì—ì„œ ë¬¸ì œ ë°œìƒ
//     }
// }
```

---

## ë°˜ë³µì ë¬´íš¨í™”: ë©”ëª¨ë¦¬ ì•ˆì „ì„±ì˜ í•µì‹¬

ë°˜ë³µì ë¬´íš¨í™”ëŠ” STL ì‚¬ìš© ì¤‘ ê°€ì¥ ì£¼ì˜í•´ì•¼ í•  ê°œë…ì…ë‹ˆë‹¤. ë¬´íš¨í™”ëœ ë°˜ë³µìë¥¼ ì‚¬ìš©í•˜ë©´ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘(Undefined Behavior)ì´ ë°œìƒí•©ë‹ˆë‹¤.

### ì»¨í…Œì´ë„ˆë³„ ë¬´íš¨í™” ê·œì¹™ ìš”ì•½

#### 1. **vectorì™€ string (ì—°ì† ë©”ëª¨ë¦¬)**
- **ì¬í• ë‹¹ ë°œìƒ ì‹œ**: **ëª¨ë“ ** ë°˜ë³µì, ì°¸ì¡°, í¬ì¸í„°ê°€ ë¬´íš¨í™”
- **ì¤‘ê°„ ì‚½ì… ì‹œ**: ì‚½ì…ì  **ì´í›„ì˜** ëª¨ë“  ë°˜ë³µìê°€ ë¬´íš¨í™”
- **ì¤‘ê°„ ì‚­ì œ ì‹œ**: ì‚­ì œì  **ì´í›„ì˜** ëª¨ë“  ë°˜ë³µìê°€ ë¬´íš¨í™”
- **ì•ˆì „ ëŒ€ì±…**: `reserve()`ë¡œ ì¬í• ë‹¹ ë°©ì§€

#### 2. **deque (ë¶„í•  ë°°ì—´)**
- **ì‚½ì…/ì‚­ì œ ì‹œ**: ì˜í–¥ ë°›ëŠ” ë¸”ë¡ì˜ ë°˜ë³µìê°€ ë¬´íš¨í™”
- **ì•ˆì „ ëŒ€ì±…**: deque ì—°ì‚° í›„ì—ëŠ” ë°˜ë³µì ì¬íšë“ì´ ì•ˆì „

#### 3. **listì™€ forward_list (ì—°ê²° ë¦¬ìŠ¤íŠ¸)**
- **ì‚½ì… ì‹œ**: **ë‹¤ë¥¸ ëª¨ë“  ë°˜ë³µìëŠ” ì•ˆì „**
- **ì‚­ì œ ì‹œ**: **ì‚­ì œëœ ë…¸ë“œì˜ ë°˜ë³µìë§Œ** ë¬´íš¨í™”
- **íŠ¹ì§•**: ê°€ì¥ ì•ˆì •ì ì¸ ë°˜ë³µì ë³´ì¥

#### 4. **map, set, multimap, multiset (ê· í˜• ì´ì§„ íŠ¸ë¦¬)**
- **ì‚½ì…/ì‚­ì œ ì‹œ**: **ì‚­ì œëœ ë…¸ë“œì˜ ë°˜ë³µìë§Œ** ë¬´íš¨í™”
- **íŠ¹ì§•**: ë…¸ë“œ ê¸°ë°˜ì´ë¼ ëŒ€ë¶€ë¶„ ì•ˆì •ì 

#### 5. **unordered ì»¨í…Œì´ë„ˆ (í•´ì‹œ í…Œì´ë¸”)**
- **ë¦¬í•´ì‹œ(rehash) ë°œìƒ ì‹œ**: **ëª¨ë“ ** ë°˜ë³µìê°€ ë¬´íš¨í™”
- **ì‚­ì œ ì‹œ**: ì‚­ì œëœ ë²„í‚·ì˜ ë°˜ë³µìë§Œ ë¬´íš¨í™”
- **ì•ˆì „ ëŒ€ì±…**: `reserve()`ë¡œ ë¦¬í•´ì‹œ ë°©ì§€

### ì‹¤ì „ ì˜ˆì œ: vectorì˜ ì¬í• ë‹¹ ë¬¸ì œ
```cpp
#include <vector>

std::vector<int> vec = {1, 2, 3};
auto it = vec.begin() + 1;  // 2ë¥¼ ê°€ë¦¬í‚´

vec.push_back(4);  // ìš©ëŸ‰ì´ ì¶©ë¶„í•˜ë©´ itì€ ìœ íš¨
vec.push_back(5);  // ìš©ëŸ‰ì´ ë¶€ì¡±í•˜ë©´ ì¬í• ë‹¹ ë°œìƒ ê°€ëŠ¥
vec.push_back(6);
vec.push_back(7);

// âŒ ì¬í• ë‹¹ì´ ë°œìƒí–ˆë‹¤ë©´ itì€ ë¬´íš¨í™”ë¨!
// *it ì ‘ê·¼ì€ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘

// âœ… ì•ˆì „í•œ ì ‘ê·¼: í•­ìƒ ì¬í™•ì¸
it = vec.begin() + 1;  // ìƒˆ ë°˜ë³µì ì–»ê¸°
```

---

## ì‚½ì…ì˜ ê¸°ìˆ : insert, emplace, try_emplace

### ì‹œí€€ìŠ¤ ì»¨í…Œì´ë„ˆ: push_back vs emplace_back
```cpp
#include <vector>
#include <string>

struct Person {
    Person(std::string name, int age) : name(std::move(name)), age(age) {}
    std::string name;
    int age;
};

std::vector<Person> people;

// ë°©ë²• 1: ì„ì‹œ ê°ì²´ ìƒì„± í›„ ë³µì‚¬/ì´ë™
people.push_back(Person("Alice", 30));  // ì„ì‹œ ê°ì²´ ìƒì„± â†’ ì´ë™ (ë¹„íš¨ìœ¨ì )

// ë°©ë²• 2: emplace_backìœ¼ë¡œ ì œìë¦¬ ìƒì„±
people.emplace_back("Bob", 25);  // ìƒì„±ì ì¸ìë§Œ ì „ë‹¬ â†’ ì§ì ‘ ìƒì„± (íš¨ìœ¨ì )

// ë°©ë²• 3: ëª…ì‹œì  ì´ë™
Person charlie("Charlie", 35);
people.push_back(std::move(charlie));  // ì´ë™ ìƒì„±ì í˜¸ì¶œ
```

### ë§µ(Map)ì—ì„œì˜ ì‚½ì…: operator[], insert, emplace, try_emplace
```cpp
#include <map>
#include <string>

std::map<std::string, std::string> dictionary;

// ë°©ë²• 1: operator[] (ì£¼ì˜ í•„ìš”)
dictionary["apple"] = "ì‚¬ê³¼";  // í‚¤ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ìƒì„± í›„ í• ë‹¹

// ë¬¸ì œ: ê°’ì˜ ê¸°ë³¸ ìƒì„±ì´ ë¹„ì‹¸ê±°ë‚˜ ë¶ˆê°€ëŠ¥í•  ìˆ˜ ìˆìŒ
dictionary["complex"];  // ë¹ˆ ë¬¸ìì—´ì´ ê¸°ë³¸ ìƒì„±ë¨ (ë¶ˆí•„ìš”í•œ ì‘ì—…)

// ë°©ë²• 2: insert (C++11 ì´ì „ ë°©ì‹)
auto result = dictionary.insert({"banana", "ë°”ë‚˜ë‚˜"});
// resultëŠ” pair<iterator, bool> ë°˜í™˜ (ì‚½ì… ì—¬ë¶€ í‘œì‹œ)

// ë°©ë²• 3: emplace (C++11)
dictionary.emplace("cherry", "ì²´ë¦¬");

// ë°©ë²• 4: try_emplace (C++17 - ê¶Œì¥)
// í‚¤ê°€ ì—†ì„ ë•Œë§Œ ìƒì„±, í‚¤ê°€ ìˆìœ¼ë©´ ë¬´ì‹œ (ìµœì ì˜ ì„±ëŠ¥)
dictionary.try_emplace("date", "ëŒ€ì¶”ì•¼ì");

// ë¹„ì‹¼ ê°ì²´ì˜ íš¨ìœ¨ì  ì‚½ì…
std::map<int, std::string> data;
std::string largeString(1000, 'x');

// âŒ ë¹„íš¨ìœ¨ì : ì„ì‹œ ê°ì²´ ìƒì„± í›„ ë³µì‚¬
data[1] = largeString;

// âœ… íš¨ìœ¨ì : ì´ë™ ë˜ëŠ” ì œìë¦¬ ìƒì„±
data.emplace(2, std::move(largeString));  // ì´ë™
data.try_emplace(3, 1000, 'y');  // ìƒì„±ì í˜¸ì¶œ: std::string(1000, 'y')
```

---

## ê²€ìƒ‰ì˜ ê¸°ìˆ : find, count, lower_bound, equal_range

### ê¸°ë³¸ ê²€ìƒ‰
```cpp
#include <set>
#include <vector>
#include <algorithm>

std::set<int> numbers = {1, 3, 5, 7, 9};

// find: ìš”ì†Œ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (ë°˜ë³µì ë°˜í™˜)
auto it = numbers.find(5);
if (it != numbers.end()) {
    std::cout << "ì°¾ì•˜ìŠµë‹ˆë‹¤: " << *it << "\n";
}

// count: ìš”ì†Œ ê°œìˆ˜ í™•ì¸ (set/mapì€ 0 ë˜ëŠ” 1)
size_t count = numbers.count(3);  // 1
count = numbers.count(10);        // 0

// contains: C++20ë¶€í„°ì˜ ê°„ê²°í•œ ë°©ë²•
if (numbers.contains(7)) {
    std::cout << "7ì´ ì¡´ì¬í•©ë‹ˆë‹¤\n";
}
```

### ë²”ìœ„ ê²€ìƒ‰ (ì •ë ¬ëœ ì»¨í…Œì´ë„ˆ)
```cpp
std::set<int> sorted = {10, 20, 30, 40, 50, 60, 70};

// lower_bound: ì£¼ì–´ì§„ ê°’ ì´ìƒì¸ ì²« ë²ˆì§¸ ìš”ì†Œ
auto low = sorted.lower_bound(35);  // 40ì„ ê°€ë¦¬í‚´

// upper_bound: ì£¼ì–´ì§„ ê°’ ì´ˆê³¼ì¸ ì²« ë²ˆì§¸ ìš”ì†Œ
auto high = sorted.upper_bound(55);  // 60ì„ ê°€ë¦¬í‚´

// equal_range: lower_boundì™€ upper_boundì˜ ìŒ
auto range = sorted.equal_range(40);
// range.firstëŠ” 40 (lower_bound)
// range.secondëŠ” 50 (upper_bound)

// ë²”ìœ„ ë‚´ ìš”ì†Œ ìˆœíšŒ
for (auto it = range.first; it != range.second; ++it) {
    std::cout << *it << " ";  // 40
}

// ë²¡í„°ì—ì„œë„ ì •ë ¬ë˜ì–´ ìˆë‹¤ë©´ ì‚¬ìš© ê°€ëŠ¥
std::vector<int> vec = {10, 20, 30, 40, 50};
std::sort(vec.begin(), vec.end());  // ì •ë ¬ í•„ìˆ˜
auto vec_range = std::equal_range(vec.begin(), vec.end(), 30);
```

---

## ì»¤ìŠ¤í…€ ì •ë ¬ê³¼ ë¹„êµì

### ì˜¬ë°”ë¥¸ ë¹„êµì ì‘ì„±
```cpp
#include <set>
#include <vector>
#include <algorithm>
#include <tuple>  // std::tie ì‚¬ìš©

struct Student {
    std::string name;
    int score;
    int id;
};

// ë°©ë²• 1: í•¨ìˆ˜ ê°ì²´
struct CompareStudent {
    bool operator()(const Student& a, const Student& b) const {
        // ì ìˆ˜ ë‚´ë¦¼ì°¨ìˆœ, ê°™ì€ ì ìˆ˜ë©´ ì´ë¦„ ì˜¤ë¦„ì°¨ìˆœ, ê°™ì€ ì´ë¦„ì´ë©´ ID
        if (a.score != b.score) return a.score > b.score;
        if (a.name != b.name) return a.name < b.name;
        return a.id < b.id;
    }
};

std::set<Student, CompareStudent> studentSet;

// ë°©ë²• 2: ëŒë‹¤ í‘œí˜„ì‹ (ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ê³¼ í•¨ê»˜ ì‚¬ìš©)
std::vector<Student> students;
std::sort(students.begin(), students.end(),
    [](const Student& a, const Student& b) {
        // std::tieë¡œ ê°„ê²°í•˜ê²Œ ë‹¤ì¤‘ í•„ë“œ ë¹„êµ
        return std::tie(b.score, a.name, a.id) < std::tie(a.score, b.name, b.id);
    });
```

### íˆ¬ëª… ë¹„êµì (C++14 ì´ìƒ)
```cpp
#include <map>
#include <string>
#include <string_view>

struct StringCompare {
    // íˆ¬ëª… ë¹„êµì ì„ ì–¸
    using is_transparent = void;
    
    bool operator()(std::string_view a, std::string_view b) const {
        return a < b;
    }
};

std::map<std::string, int, StringCompare> wordCount;

// ë‹¤ì–‘í•œ ë¬¸ìì—´ íƒ€ì…ìœ¼ë¡œ ê²€ìƒ‰ ê°€ëŠ¥ (ë¶ˆí•„ìš”í•œ ë³€í™˜ ì œê±°)
wordCount.emplace("hello", 1);
wordCount.emplace("world", 2);

// C ìŠ¤íƒ€ì¼ ë¬¸ìì—´ë¡œ ê²€ìƒ‰
auto it1 = wordCount.find("hello");

// string_viewë¡œ ê²€ìƒ‰
std::string_view sv = "world";
auto it2 = wordCount.find(sv);

// std::stringìœ¼ë¡œ ê²€ìƒ‰
std::string str = "test";
auto it3 = wordCount.find(str);
```

---

## ì„±ëŠ¥ ìµœì í™” íŒ

### 1. ì‚¬ì „ í• ë‹¹ìœ¼ë¡œ ì¬í• ë‹¹ ë°©ì§€
```cpp
#include <vector>

// ë‚˜ìœ ì˜ˆ: ì—¬ëŸ¬ ë²ˆ ì¬í• ë‹¹ ë°œìƒ
std::vector<int> bad;
for (int i = 0; i < 1000000; ++i) {
    bad.push_back(i);  // ì¬í• ë‹¹ ë°œìƒ ê°€ëŠ¥
}

// ì¢‹ì€ ì˜ˆ: í•œ ë²ˆì— ë©”ëª¨ë¦¬ í• ë‹¹
std::vector<int> good;
good.reserve(1000000);  // í•„ìš”í•œ ë§Œí¼ ë¯¸ë¦¬ í• ë‹¹
for (int i = 0; i < 1000000; ++i) {
    good.push_back(i);  // ì¬í• ë‹¹ ì—†ìŒ
}
```

### 2. í•´ì‹œ ì»¨í…Œì´ë„ˆ ì„±ëŠ¥ ì¡°ì •
```cpp
#include <unordered_map>

std::unordered_map<std::string, int> hashMap;

// 1. ë¡œë“œ íŒ©í„° ì¡°ì • (ê¸°ë³¸ê°’ì€ 1.0)
hashMap.max_load_factor(0.75);  // ë²„í‚·ì´ 75% ì°¨ë©´ ë¦¬í•´ì‹œ

// 2. ë¯¸ë¦¬ ë²„í‚· ìˆ˜ ì˜ˆì•½ (ë¦¬í•´ì‹œ ë°©ì§€)
hashMap.reserve(10000);  // ì•½ 10000ê°œ ìš”ì†Œë¥¼ ìœ„í•œ ê³µê°„ ì˜ˆì•½

// 3. ì§ì ‘ ë²„í‚· ìˆ˜ ì„¤ì •
hashMap.rehash(5000);  // ìµœì†Œ 5000ê°œ ë²„í‚· ë³´ì¥
```

### 3. ì´ë™ ì˜ë¯¸ë¡  í™œìš©
```cpp
#include <vector>
#include <string>
#include <algorithm>

std::vector<std::string> source = {"apple", "banana", "cherry"};
std::vector<std::string> destination;

// ë‚˜ìœ ì˜ˆ: ëª¨ë“  ë¬¸ìì—´ ë³µì‚¬
destination.reserve(source.size());
for (const auto& str : source) {
    destination.push_back(str);  // ë³µì‚¬ ë°œìƒ
}

// ì¢‹ì€ ì˜ˆ: ì´ë™ ì˜ë¯¸ë¡  í™œìš©
destination.reserve(source.size());
for (auto& str : source) {
    destination.push_back(std::move(str));  // ì´ë™ ë°œìƒ
}

// ìµœì ì˜ ì˜ˆ: ì´ë™ ë°˜ë³µì ì‚¬ìš©
destination.clear();
std::move(source.begin(), source.end(),
          std::back_inserter(destination));
```

---

## í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ì±…

### ì‹¤ìˆ˜ 1: range-forì—ì„œ ì»¨í…Œì´ë„ˆ ìˆ˜ì •
```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// âŒ ìœ„í—˜: range-forëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ë°˜ë³µìë¥¼ ì‚¬ìš©
for (int value : vec) {
    if (value == 3) {
        // vec.erase(...);  // ë°˜ë³µì ë¬´íš¨í™”!
    }
}

// âœ… ì•ˆì „í•œ ëŒ€ì•ˆë“¤
// ë°©ë²• 1: ëª…ì‹œì  ë°˜ë³µì ì‚¬ìš©
for (auto it = vec.begin(); it != vec.end(); ) {
    if (*it == 3) {
        it = vec.erase(it);
    } else {
        ++it;
    }
}

// ë°©ë²• 2: erase-remove ê´€ìš©êµ¬
vec.erase(std::remove(vec.begin(), vec.end(), 3), vec.end());

// ë°©ë²• 3: C++20 erase/erase_if
std::erase(vec, 3);
```

### ì‹¤ìˆ˜ 2: ë§µì˜ operator[] ë‚¨ìš©
```cpp
#include <map>
#include <string>

std::map<std::string, ExpensiveObject> cache;

// âŒ ë¹„íš¨ìœ¨ì : ë¶ˆí•„ìš”í•œ ê¸°ë³¸ ìƒì„±
if (cache["key"].isValid()) {  // "key"ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ìƒì„±ë¨
    // ...
}

// âœ… íš¨ìœ¨ì : find ë˜ëŠ” contains ì‚¬ìš©
auto it = cache.find("key");
if (it != cache.end() && it->second.isValid()) {
    // ...
}

// C++20ì—ì„œëŠ” ë” ê°„ê²°
if (cache.contains("key") && cache["key"].isValid()) {
    // containsë¡œ ë¨¼ì € í™•ì¸
}
```

### ì‹¤ìˆ˜ 3: ì»¤ìŠ¤í…€ í•´ì‹œì™€ ë¹„êµìì˜ ë¶ˆì¼ì¹˜
```cpp
struct Person {
    std::string name;
    int age;
    
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
};

// í•´ì‹œ í•¨ìˆ˜
struct PersonHash {
    std::size_t operator()(const Person& p) const {
        // nameê³¼ ageë¥¼ ëª¨ë‘ ê³ ë ¤í•´ì•¼ í•¨
        return std::hash<std::string>{}(p.name) ^ 
               (std::hash<int>{}(p.age) << 1);
    }
};

// âŒ ë¬¸ì œ: operator==ì´ nameê³¼ ageë¥¼ ëª¨ë‘ ë¹„êµí•˜ëŠ”ë°
// í•´ì‹œ í•¨ìˆ˜ê°€ ageë§Œ ê³ ë ¤í•˜ë©´ ê°™ì€ í•´ì‹œ ê°’ì„ ê°€ì§„ ë‹¤ë¥¸ ê°ì²´ê°€
// ê°™ì€ ë²„í‚·ì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆì–´ ì„±ëŠ¥ ì €í•˜

std::unordered_map<Person, std::string, PersonHash> people;

// ì˜¬ë°”ë¥¸ í•´ì‹œ í•¨ìˆ˜ëŠ” operator==ì™€ ì¼ì¹˜í•´ì•¼ í•¨
```

### ì‹¤ìˆ˜ 4: listì— ì•Œê³ ë¦¬ì¦˜ ì˜ëª» ì ìš©
```cpp
#include <list>
#include <algorithm>

std::list<int> numbers = {1, 2, 2, 3, 4, 2, 5};

// âŒ ë¹„íš¨ìœ¨ì : listì— std::remove ì‚¬ìš©
numbers.erase(std::remove(numbers.begin(), numbers.end(), 2),
              numbers.end());

// âœ… íš¨ìœ¨ì : listì˜ ë©¤ë²„ í•¨ìˆ˜ ì‚¬ìš©
numbers.remove(2);  // O(n), ì—°ê²°ë§Œ ë³€ê²½

// ì¡°ê±´ë¶€ ì‚­ì œë„ ë§ˆì°¬ê°€ì§€
numbers.remove_if([](int x) { return x % 2 == 0; });
```

---

## ì‹¤ì „ íŒ¨í„´: ë°ì´í„° ê·¸ë£¹í™”ì™€ ì§‘ê³„

### ê·¸ë£¹ë³„ ë°ì´í„° ìˆ˜ì§‘
```cpp
#include <vector>
#include <unordered_map>
#include <string>
#include <iostream>

struct LogEntry {
    std::string level;
    int code;
    std::string message;
};

int main() {
    std::vector<LogEntry> logs = {
        {"ERROR", 1001, "Database connection failed"},
        {"WARN", 2001, "High memory usage"},
        {"ERROR", 1002, "File not found"},
        {"INFO", 3001, "User login"},
        {"ERROR", 1003, "Timeout occurred"}
    };
    
    // ë ˆë²¨ë³„ ë¡œê·¸ ìˆ˜ ì§‘ê³„
    std::unordered_map<std::string, int> levelCounts;
    for (const auto& log : logs) {
        levelCounts[log.level]++;
    }
    
    // ë ˆë²¨ë³„ ìƒì„¸ ë¡œê·¸ ì €ì¥
    std::unordered_map<std::string, std::vector<LogEntry>> logsByLevel;
    for (const auto& log : logs) {
        logsByLevel[log.level].push_back(log);
    }
    
    // ê²°ê³¼ ì¶œë ¥
    for (const auto& [level, count] : levelCounts) {
        std::cout << level << ": " << count << " entries\n";
        
        // í•´ë‹¹ ë ˆë²¨ì˜ ìƒì„¸ ë¡œê·¸ ì¶œë ¥
        const auto& levelLogs = logsByLevel[level];
        for (const auto& log : levelLogs) {
            std::cout << "  [" << log.code << "] " << log.message << "\n";
        }
    }
}
```

### ì¤‘ë³µ ì œê±°ì™€ ì •ë ¬
```cpp
#include <vector>
#include <algorithm>
#include <iostream>

int main() {
    std::vector<int> numbers = {5, 2, 8, 2, 5, 1, 8, 9, 3, 2};
    
    // 1. ì •ë ¬
    std::sort(numbers.begin(), numbers.end());
    
    // 2. ì¤‘ë³µ ì œê±° (ì •ë ¬ í›„ì—ë§Œ íš¨ê³¼ì )
    numbers.erase(std::unique(numbers.begin(), numbers.end()),
                  numbers.end());
    
    // ê²°ê³¼: 1 2 3 5 8 9
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    // ì»¤ìŠ¤í…€ ê°ì²´ì˜ ì¤‘ë³µ ì œê±° ì˜ˆì œ
    struct Point { int x, y; };
    std::vector<Point> points = {{1,2}, {3,4}, {1,2}, {5,6}, {3,4}};
    
    // ì •ë ¬ (x ê¸°ì¤€, ê°™ìœ¼ë©´ y ê¸°ì¤€)
    std::sort(points.begin(), points.end(),
              [](const Point& a, const Point& b) {
                  return std::tie(a.x, a.y) < std::tie(b.x, b.y);
              });
    
    // ì¤‘ë³µ ì œê±°
    points.erase(std::unique(points.begin(), points.end(),
                             [](const Point& a, const Point& b) {
                                 return a.x == b.x && a.y == b.y;
                             }),
                 points.end());
}
```

---

## ê²°ë¡ : STLì„ ì•ˆì „í•˜ê³  íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•˜ê¸°

STLì€ ê°•ë ¥í•œ ë„êµ¬ì´ì§€ë§Œ, ì˜¬ë°”ë¥´ê²Œ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ ì„±ëŠ¥ ë¬¸ì œë‚˜ ë²„ê·¸ë¥¼ ì´ˆë˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì›ì¹™ë“¤ì„ ê¸°ì–µí•˜ì„¸ìš”:

1. **ë°˜ë³µì ì•ˆì „ì„±ì— í•­ìƒ ì£¼ì˜í•˜ì„¸ìš”**: ë¬´íš¨í™”ëœ ë°˜ë³µìëŠ” ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì„ ì¼ìœ¼í‚µë‹ˆë‹¤. ì»¨í…Œì´ë„ˆ êµ¬ì¡° ë³€ê²½ ì‹œì—ëŠ” ë°˜ë³µìë¥¼ ì¬íšë“í•˜ëŠ” ê²ƒì´ ì•ˆì „í•©ë‹ˆë‹¤.

2. **ì•Œê³ ë¦¬ì¦˜ë³´ë‹¤ ì»¨í…Œì´ë„ˆë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”**: ë°ì´í„° ì ‘ê·¼ íŒ¨í„´ì— ë§ëŠ” ì»¨í…Œì´ë„ˆë¥¼ ì„ íƒí•˜ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ìµœì ì˜ ì•Œê³ ë¦¬ì¦˜ì´ ë”°ë¼ì˜µë‹ˆë‹¤.

3. **ì„±ëŠ¥ì€ ì¸¡ì •ìœ¼ë¡œ í™•ì¸í•˜ì„¸ìš”**: ì´ë¡ ì  ë³µì¡ë„ëŠ” ì°¸ê³ ìš©ì¼ ë¿ì…ë‹ˆë‹¤. ì‹¤ì œ ë°ì´í„°ì™€ í™˜ê²½ì—ì„œ ì„±ëŠ¥ì„ ì¸¡ì •í•˜ê³  ìµœì í™”í•˜ì„¸ìš”.

4. **í˜„ëŒ€ì ì¸ C++ ê¸°ëŠ¥ì„ í™œìš©í•˜ì„¸ìš”**: `emplace`, `try_emplace`, `contains`, Ranges ë“±ì˜ ìµœì‹  ê¸°ëŠ¥ì€ ì½”ë“œë¥¼ ë” ì•ˆì „í•˜ê³  íš¨ìœ¨ì ìœ¼ë¡œ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.

5. **íŒ¨í„´ì„ ìµíˆê³  ì¬ì‚¬ìš©í•˜ì„¸ìš”**: erase-remove ê´€ìš©êµ¬, íˆ¬ëª… ë¹„êµì, ì´ë™ ì˜ë¯¸ë¡  í™œìš© ë“± ê²€ì¦ëœ íŒ¨í„´ì„ ìµí˜€ë‘ë©´ ì‹¤ìˆ˜ë¥¼ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

STLì€ ë³µì¡í•´ ë³´ì¼ ìˆ˜ ìˆì§€ë§Œ, ê¸°ë³¸ ì›ë¦¬ì™€ íŒ¨í„´ì„ ì´í•´í•˜ë©´ ê°•ë ¥í•œ ë„êµ¬ê°€ ë©ë‹ˆë‹¤. ì•ˆì „ì„±ê³¼ ì„±ëŠ¥ì„ ê³ ë ¤í•œ ì½”ë“œë¥¼ ì‘ì„±í•˜ê³ , ë¶ˆí™•ì‹¤í•  ë•ŒëŠ” ë¬¸ì„œë¥¼ ì°¸ì¡°í•˜ê±°ë‚˜ ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ í”„ë¡œê·¸ë¨ìœ¼ë¡œ ë™ì‘ì„ í™•ì¸í•˜ëŠ” ìŠµê´€ì„ ê¸°ë¥´ì„¸ìš”.