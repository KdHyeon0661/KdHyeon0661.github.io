---
layout: post
title: C++ - STL (6)
date: 2024-09-17 19:20:23 +0900
category: Cpp
---
# STL 6 — STL 활용 팁 & 실수 방지

## 0. 한눈에 표 — “이 상황에서 이 패턴”

| 상황 | 안전/권장 패턴 |
|---|---|
| 순회 중 안전하게 삭제 (시퀀스 컨테이너) | `it = v.erase(it)` / `v.erase(remove_if(...), v.end())` / `std::erase_if(v, pred)`(C++20) |
| 키-값 컨테이너에서 “만약 없으면만 생성” | `m.try_emplace(key, ctor_args...)` |
| 존재 여부만 확인 (map/unordered_map) | `contains(key)`(C++20) 또는 `find(key) != end()` |
| 성능 좋은 삽입 | `emplace_back` / `emplace` / `try_emplace` (in-place 생성) |
| 정렬 기준 다중 키 | `std::tie(a,b,...) < std::tie(x,y,...)` |
| 해시 컨테이너 리해시 제어 | `reserve(n)` 또는 `rehash(buckets)` + `max_load_factor(α)` |
| 연관 컨테이너 구간 검색 | `lower_bound`, `upper_bound`, `equal_range` |
| 이터레이터 무효화를 피해야 할 때 | `list`(node-stable), `map/set`(node-stable) 사용 |
| 큰 벡터 다량 push 전에 | `v.reserve(N)` (재할당 감소) |
| copy보단 move가 좋을 때 | `std::move_iterator` / `std::make_move_iterator` |

---

## 1. “반복 중 삭제” — 제대로 아는 4가지

### 1.1 인덱스 기반 삭제 — **위험한 기본형**

```cpp
#include <vector>
using namespace std;

vector<int> v = {1,2,3,2,4};
// ❌ 인덱스가 앞으로 당겨져 건너뛰기/범위 오류 위험
for (size_t i=0; i<v.size(); ++i) {
    if (v[i] == 2) v.erase(v.begin()+i);
}
```

- `erase`가 요소를 당겨서 **다음 i가 밀려버림** → 일부 2는 삭제 안 되거나 UB 위험.

### 1.2 역순 인덱스 — **가능하지만 번거롭다**

```cpp
for (int i = (int)v.size()-1; i >= 0; --i)
    if (v[i] == 2) v.erase(v.begin()+i);
```

- 역순은 안전하지만 **O(n) * 삭제횟수**로 비쌀 수 있음.

### 1.3 반복자로 지우면서 전진 — **정석**

```cpp
for (auto it = v.begin(); it != v.end(); ) {
    if (*it == 2) it = v.erase(it);  // 다음 요소 반복자 반환
    else ++it;
}
```

### 1.4 `erase-remove` 관용구 — **가장 권장 (벡터/문자열)**

```cpp
#include <algorithm>
v.erase(remove(v.begin(), v.end(), 2), v.end());
```

- `remove`는 “살릴 것들을 앞으로 모아놓고” 마지막 유효 끝을 반환.
- **실제 컨테이너 크기 축소는 `erase`가 한다.**

### 1.5 C++20 `std::erase` / `std::erase_if`

{% raw %}
```cpp
#include <vector>
#include <string>
#include <map>
using namespace std;

vector<int> v = {1,2,3,2,4};
std::erase(v, 2);                    // 모든 2 삭제

string s = "abacad";
std::erase(s, 'a');                  // 'a' 제거 → "bcd"

map<int,string> m = {{1,"a"},{2,"bb"},{3,"ccc"}};
std::erase_if(m, [](auto& kv){ return kv.second.size() >= 2; }); // value 길이 기준 삭제
```
{% endraw %}

> `std::erase(_if)`는 **vector/string/map/unordered_map 등** 다수 컨테이너에 제공.

---

## 2. 반복자 무효화 — 컨테이너별 규칙 (암기표)

> 무효화: “그 반복자/참조를 더 쓰면 UB”.

| 컨테이너 | 삽입 시 | 삭제 시 |
|---|---|---|
| `vector` / `string` | 재할당(reallocation) 발생 시 **모든** 반복자/참조 무효. 재할당 없더라도 삽입점 이후 반복자 **무효** | 삭제점 이후 반복자 **무효** |
| `deque` | 일부 연산에서 폭넓게 무효화 (양끝 블록 분할 구조) — 보수적으로 **대부분 무효화**로 생각 | 삭제점 관련 구간 무효 |
| `list` / `forward_list` | **안정**(stable). 삽입해도 다른 반복자 **유효** | 지운 그 노드 반복자만 무효 |
| `map/set` / `unordered_*` | **안정**(노드 기반). 삽입해도 기존 반복자 **유효** (unordered는 rehash 시 전부 무효) | 지운 노드의 반복자만 무효. (unordered는 rehash 제외) |

**핵심**
- “**배열 기반**(vector/string)은 재할당이 치명적.” → `reserve`로 방지.
- “**노드 기반**(list/map/set)은 삽입에 강하다.”
- “**unordered**는 `rehash`에 주의.” → `reserve(n)` + `max_load_factor(α)`로 제어.

---

## 3. set/map에서 삭제 루프 — 바로 쓰는 패턴

```cpp
#include <set>
using namespace std;

set<int> s = {1,2,3,4,5};
for (auto it = s.begin(); it != s.end(); ) {
    if (*it % 2 == 0) it = s.erase(it); // ✅ 삭제된 다음 반복자 반환 (C++11~)
    else ++it;
}
```

- C++11부터 associative 컨테이너 `erase(it)`는 **다음 반복자 반환**.
- **절대** `++it; s.erase(it);`를 같이 하지 말 것.

---

## 4. `insert` vs `emplace` vs **`try_emplace` / `emplace_hint`**

### 4.1 시퀀스 컨테이너

```cpp
vector<pair<int,int>> v;
v.push_back(make_pair(1,2));  // 잠재적 복사/이동
v.emplace_back(1,2);          // ⭕ 그 자리에서 생성 (in-place)
```

### 4.2 연관 컨테이너 (map/unordered_map)

```cpp
#include <map>
#include <string>
using namespace std;

map<string, string> m;

// 값이 비싸게 만들 때 insert는 "먼저 만들고" 옮김
m.insert({"a", string(1000, 'x')});

// try_emplace: 키가 **없을 때만** 생성자 인자로 **그 자리에서** 생성
m.try_emplace("b", 1000, 'y'); // value=string(1000,'y'), 없으면만 생성

// emplace_hint: 힌트 반복자 제공(정렬 위치 힌트). 올바른 힌트면 로그 인자 감소
auto it = m.end();
m.emplace_hint(it, "c", string("cheap"));

// operator[] 주의: 없으면 **디폴트-생성** 후 참조 반환
m["d"] = "value"; // 없으면 value() default 생성 → 일부 타입에서 비용/제약
// 값이 무겁거나 non-default-constructible이면 operator[] 피하고 try_emplace 사용
```

---

## 5. 탐색: `find` / `count` / `lower_bound` / `equal_range` (정렬/정확 차이)

```cpp
#include <set>
#include <vector>
#include <algorithm>
using namespace std;

set<int> s = {1,3,5,7};

auto it1 = s.find(3);           // 키 == 3 여부 (O(log n))
size_t c = s.count(5);          // set/map은 0 또는 1
auto it2 = s.lower_bound(4);    // 정렬 기준 “>= 4” 첫 원소
auto it3 = s.upper_bound(7);    // “> 7” 첫 원소 → end()
auto [lo, hi] = s.equal_range(5); // [lo, hi) 범위
```

- **정렬 컨테이너**(map/set)는 **키 비교자** 기준.
- **시퀀스 컨테이너**는 `lower_bound`가 **정렬되어 있어야** 의미 있음.

---

## 6. 커스텀 정렬/비교 — “엄격 약한 순서(strict weak ordering)” 지키기

```cpp
#include <set>
#include <utility>
using namespace std;

struct Comp {
    bool operator()(const pair<int,int>& a, const pair<int,int>& b) const {
        if (a.second != b.second) return a.second < b.second;  // value 오름차순
        return a.first < b.first;                               // tie-breaker
    }
};

set<pair<int,int>, Comp> s; // ✅ 반사/추이/반대칭 성질 지키는 비교자
```

> 비교자가 일관되지 않으면 **UB**(컨테이너 내부 구조 파괴/무한루프) 위험.

### 6.1 투명 비교자 — **heterogeneous lookup** (C++14~)

```cpp
#include <map>
#include <string>
#include <string_view>
using namespace std;

struct TransLess {
    using is_transparent = void; // 투명 태그
    bool operator()(string_view a, string_view b) const { return a < b; }
};

map<string, int, TransLess> m = { {"alpha",1},{"beta",2} };

int v1 = m.at("alpha");                 // C-string로 찾기 (변환 없이)
auto it = m.find(string_view("beta"));  // string_view로도 find 가능
```

- “키를 **굳이 `Key`로 변환**하지 않아도” 찾을 수 있어 **할당 줄고 속도↑**.

---

## 7. 컨테이너 조합 패턴 — Group-by / Index / Multi-Map

```cpp
#include <unordered_map>
#include <vector>
#include <string>
using namespace std;

// 7.1 한 키에 다수 값: map<string, vector<int>>
unordered_map<string, vector<int>> groups;
groups["error"].push_back(17);
groups["error"].push_back(42);

// 7.2 반대로 값→키들 역인덱스
unordered_map<int, vector<string>> rev;
for (auto& [k, vs] : groups)
    for (int v : vs) rev[v].push_back(k);

// 7.3 중복 키 자체를 허용 — multimap
multimap<string,int> mm;
mm.emplace("error", 17);
mm.emplace("error", 42);
```

---

## 8. 해시 컨테이너 운영술 — `reserve`, 로드팩터, `rehash`

```cpp
#include <unordered_map>
#include <string>
using namespace std;

unordered_map<string,int> um;
um.max_load_factor(0.75f); // 기본은 대략 1.0인 구현 多
um.reserve(10'000);        // 적절히 버킷 수 키워 미리 rehash 방지
```

- **리해시(rehash)** 발생 시: **모든 반복자/포인터 무효**.
- **패턴**: 대량 삽입 전 **`reserve`**; 충돌 줄이려면 **해시 커스터마이즈** 고려.

---

## 9. 성능 팁

### 9.1 `reserve`, `shrink_to_fit`

```cpp
vector<int> v;
v.reserve(100000);    // 재할당 줄여 push_back O(1) 최적화
// ... 사용 후 메모리를 과감히 돌려주고 싶다면 (강제는 아님)
vector<int>(v).swap(v);    // 강제 수축 트릭 (C++ 표준적)
```

> `shrink_to_fit()`은 **non-binding**(강제 아님). swap 트릭이 더 확실.

### 9.2 `back_inserter` + 알고리즘

```cpp
#include <algorithm>
#include <vector>
#include <iterator>
using namespace std;

vector<int> src = {1,2,3,4};
vector<int> dst;
dst.reserve(src.size());
transform(src.begin(), src.end(), back_inserter(dst), [](int x){ return x*x; });
```

### 9.3 `move`로 싸게 옮기기

```cpp
#include <algorithm>
#include <vector>
using namespace std;

vector<string> a = {"A","B","C"};
vector<string> b;
b.reserve(a.size());
move(make_move_iterator(a.begin()), make_move_iterator(a.end()), back_inserter(b));
```

---

## 10. 알고리즘 선택 — `sort/stable_sort`, `partial_sort`, `nth_element`

```cpp
#include <algorithm>
#include <vector>
using namespace std;

vector<int> v = {7,1,5,3,9};

// 전체 정렬: 불안정/빠름
sort(v.begin(), v.end());             // 평균 O(n log n)

// 안정 정렬: 같은 키의 상대 순서 보장
stable_sort(v.begin(), v.end());

// 상위 K개만 정렬된 상태로 (나머지는 순서 불특정)
partial_sort(v.begin(), v.begin()+3, v.end());

// k번째 원소 기준 파티션 (퀵셀렉션 유사)
nth_element(v.begin(), v.begin()+2, v.end()); // v[2]는 정렬 시 위치의 값
```

> 큰 데이터에서 **상위 K**만 필요하면 `partial_sort`/`nth_element`가 훨씬 싸다.

---

## 11. Ranges (C++20) — 가독성/안전성 ↑

```cpp
#include <vector>
#include <ranges>
#include <algorithm>
#include <iostream>
using namespace std;

int main() {
    vector<int> v = {1,2,3,4,5,6};

    // 필터 → 변환 → 복사
    vector<int> out;
    ranges::copy(
        v | ranges::views::filter([](int x){ return x%2==0; })
          | ranges::views::transform([](int x){ return x*x; }),
        back_inserter(out)
    );

    for (int x : out) cout << x << ' '; // 4 16 36
}
```

---

## 12. 우선순위 큐 비교자 실수 — “작을수록 높은가? 큰가?”

```cpp
#include <queue>
#include <vector>
using namespace std;

// 기본: max-heap (큰 게 top)
priority_queue<int> pq1;

// min-heap
priority_queue<int, vector<int>, greater<int>> pq2;
```

- 헷갈리면 기억: **기본은 max-heap**. “작은 게 먼저”라면 `greater<>`.

---

## 13. 작은/큰 객체 전달 — 값? 참조? (비용 모델)

- **작은 Trivially Copyable**(예: `int`, `pair<int,int>`)은 **값** 전달이 깔끔/빠름.
- **큰/복잡**(예: `string`, `vector`, 구조체) — `const&` 전달, 결과는 **값 반환**(NRVO/move로 비용↓).
- 람다 캡처도 동일: 값/참조 선택을 명확히.

---

## 14. 자주 하는 실수 & 교정 (추가)

1) **range-for**에서 지우기:

```cpp
vector<int> v = {1,2,3};
// ❌ range-for에서 바로 erase는 반복자 무효화/UB 위험
for (int x : v) if (x==2) /*erase?*/;

// ✅ 인덱스/반복자/erase-remove/erase_if로
v.erase(remove(v.begin(), v.end(), 2), v.end());
```

2) `map::operator[]` 남용: 값이 **비싸게 디폴트 생성**됨. → `find`/`contains`/`try_emplace`로 제어.

3) `unordered_*`에서 커스텀 타입 키 쓰며 `==`/`hash` 불일치: 둘은 **합의**해야 한다. 같다면 같은 해시를 생성하도록.

4) 정렬/연관 컨테이너 비교자에서 **엄격 약한 순서** 위배 (동일 키 다른 판단) → 반드시 tie-breaker 포함.

5) `list`에 `remove` 알고리즘 호출:

```cpp
list<int> L = {1,2,2,3};
// ❌ std::remove는 iterator 기반. list 자체의 멤버 remove가 더 낫다.
L.remove(2); // ✅ O(n), 연결만 바꿈. std::remove+erase보다 깔끔
```

6) `string_view`로 임시/소유자 수명 넘어 참조 유지 → **dangling** 주의. 입력의 소유/수명 설계 명확히.

---

## 15. “무엇을 언제 선택하나?” (컨테이너 선택 가이드)

- **읽기 많은 랜덤접근 & 메모리 밀집** → `vector` (+ `reserve`)
- **중간 삽입/삭제 많고 반복자 안정 중요** → `list`
- **정렬된 키-값** / 범위 질의 (`lower_bound`) → `map`/`set`
- **최고 속 검색, 정렬 불필요** → `unordered_map`/`unordered_set`
- **양끝 삽/삭 빈번** → `deque`
- **상위 K만 유지** → `priority_queue` or `nth_element`

---

## 16. 예제 모음 — 실무형 스니펫

### 16.1 로그 집계: 그룹핑 + 정렬 출력

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    vector<pair<string,int>> logs = {
        {"ERROR",17},{"WARN",3},{"INFO",1},{"ERROR",42},{"INFO",5}
    };

    unordered_map<string, vector<int>> bucket;
    for (auto& [lev, code] : logs) bucket[lev].push_back(code);

    vector<pair<string,int>> count;
    count.reserve(bucket.size());
    for (auto& [lev, v] : bucket) count.emplace_back(lev, (int)v.size());

    // level 이름 오름차, 개수 내림차
    sort(count.begin(), count.end(), [](auto& a, auto& b){
        return tie(a.first, -a.second) < tie(b.first, -b.second);
    });

    for (auto& [lev, c] : count) cout << lev << " x " << c << "\n";
}
```

### 16.2 안전한 삭제 (C++20)

```cpp
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

int main(){
    vector<int> v = {1,2,3,2,4,2,5};
    std::erase_if(v, [](int x){ return x==2 || x>4; });
    for (int x : v) cout << x << ' '; // 1 3 4
}
```

### 16.3 투명 비교자 + heterogeneous lookup

{% raw %}
```cpp
#include <map>
#include <string>
#include <string_view>
#include <iostream>
using namespace std;

struct ByView {
    using is_transparent = void;
    bool operator()(string_view a, string_view b) const { return a < b; }
};

int main(){
    map<string,int,ByView> m = {{"apple",1},{"banana",2}};
    cout << m.contains("apple") << "\n"; // 1
    auto it = m.find(string_view("banana"));
    if (it != m.end()) cout << it->second << "\n";
}
```
{% endraw %}

### 16.4 `unordered_map` 성능 제어

```cpp
#include <unordered_map>
#include <string>
using namespace std;

int main(){
    unordered_map<string,int> um;
    um.max_load_factor(0.7f);
    um.reserve(50000);  // 대량 삽입 전
    for (int i=0; i<50000; ++i) um.emplace("k"+to_string(i), i);
}
```

### 16.5 `try_emplace` / `insert` 결과 처리

```cpp
#include <map>
#include <string>
#include <iostream>
using namespace std;

int main(){
    map<string,string> m;

    // insert 결과 pair<iterator,bool>
    if (auto [it, ok] = m.insert({"a", "1"}); ok) {
        cout << "inserted: " << it->first << "\n";
    }

    // try_emplace: 없을 때만 생성자 호출
    m.try_emplace("b", 3, 'x'); // value = string(3,'x')

    // contains (C++20)
    if (!m.contains("c")) m.emplace("c", "3");
}
```

---

## 17. 시간복잡도 요약 (대표)

- `vector::push_back` 평균 $$O(1)$$ (재할당 시 분기 비용)
- `vector::insert/erase` 중간 위치는 $$O(n)$$
- `list` 삽입/삭제는 위치가 있으면 $$O(1)$$ (탐색은 $$O(n)$$)
- `map/set` 삽입/탐색/삭제 $$O(\log n)$$
- `unordered_map/set` 평균 $$O(1)$$ (최악 $$O(n)$$, 해시/로드팩터 영향)

---

## 18. 디버깅/품질 팁

- **디버그 STL**(MSVC) / **_GLIBCXX_DEBUG**(GCC) 켜고 경계/무효화 잡기.
- 비교자/해시/동치(`==`) 일관성에 **static_assert** + **테스트** 추가.
- **클래스 설계**: 무거운 값은 이동/스왑 최적화, 불필요한 복사 줄이기.

---

## 19. 요약

- **삭제는 관용구**로: `it = erase(it)`, `erase-remove`, `std::erase(_if)`
- **무효화 규칙**을 반드시 기억 — `vector`는 재할당이 적.
- **삽입은 emplace/try_emplace**로 in-place, 디폴트 생성 회피.
- **탐색은 상황별**: `contains/find/lower_bound/equal_range`.
- **성능은 reserve/로드팩터**로 사전 제어.
- **비교자/해시 일관성**이 무너지면 **UB**.
