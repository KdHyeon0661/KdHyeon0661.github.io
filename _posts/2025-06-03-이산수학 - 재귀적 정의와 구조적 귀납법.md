---
layout: post
title: 이산수학 - 재귀적 정의와 구조적 귀납법
date: 2025-06-03 20:20:23 +0900
category: 이산수학
---
# 재귀적 정의와 구조적 귀납법 (Recursive Definitions & Structural Induction)

## 0) 한눈 요약

- **재귀적 정의**: 대상을 **기초 사례**와 **생성 규칙**으로 만들며, 정의 자체가 **자기참조**를 포함.  
- **구조적 귀납법**: 그렇게 정의된 **구조의 모양(생성자)**에 맞춰 **기초·귀납 단계**로 성질을 증명.  
- 핵심 아이디어: **생성자별로 증명하면 전체가 따라온다.**

---

## 1) 재귀적 정의(Recursive Definition) — 형식과 예

### 1.1 일반 형식
어떤 데이터 타입(집합) $$T$$ 를 **생성자(constructors)** 집합 $$\mathcal{C}$$ 로 정의:

1) **기초(Base)**: $$c(\text{기초 인자들})\in T$$  
2) **귀납(Step)**: $$x_1,\dots,x_k\in T \Rightarrow c(x_1,\dots,x_k)\in T$$  
3) **최소성(Minimality)**: 위 두 규칙으로 **유도 가능한 것만** $$T$$ 에 포함.

> 이렇게 만들어진 $$T$$ 를 **자유 대수(Free Algebra)**, $$\mathcal{C}$$ 를 **서명(signature)** 라고도 부릅니다.

---

### 1.2 예 A — 자연수(피아노)
- 기초: $$0\in\mathbb{N}$$  
- 생성자: $$S:\mathbb{N}\to \mathbb{N},\ \ n\mapsto S(n)=n+1$$  
- 최소성: $$\mathbb{N}$$ 은 0과 후자함수로만 닫힌 최소 집합.

**재귀 함수 예** (덧셈):
$$
\begin{aligned}
n+0 &= n,\\
n+S(m) &= S(n+m).
\end{aligned}
$$

---

### 1.3 예 B — 리스트(List, 원소 집합 $$A$$)
- 기초: $$[] \in \mathrm{List}(A)$$  
- 생성자: **cons**: $$A\times \mathrm{List}(A)\to \mathrm{List}(A),\ (x,\ell)\mapsto x::\ell$$

**재귀 함수 예** (길이, 이어붙이기, 뒤집기):
$$
\begin{aligned}
\mathrm{len}([])&=0,\quad &\mathrm{len}(x::xs)&=1+\mathrm{len}(xs),\\
xs\mathbin{++}[]&=xs,\quad &(x::xs)\mathbin{++}ys&=x::(xs\mathbin{++}ys),\\
\mathrm{rev}([])&=[],\quad &\mathrm{rev}(x::xs)&=\mathrm{rev}(xs)\mathbin{++}[x].
\end{aligned}
$$

---

### 1.4 예 C — 이진 트리(Binary Tree)

(단순형) **리프만 값**:
- 기초: $$\mathrm{Leaf}(v)\in \mathrm{BTree}$$
- 생성: $$\mathrm{Node}(L,R)\in \mathrm{BTree}$$ (왼·오른 서브트리)

(함수 예)
$$
\begin{aligned}
\mathrm{size}(\mathrm{Leaf})&=1, & \mathrm{size}(\mathrm{Node}(L,R))&=1+\mathrm{size}(L)+\mathrm{size}(R),\\
\mathrm{leaves}(\mathrm{Leaf})&=1, & \mathrm{leaves}(\mathrm{Node}(L,R))&=\mathrm{leaves}(L)+\mathrm{leaves}(R),\\
\mathrm{height}(\mathrm{Leaf})&=1, & \mathrm{height}(\mathrm{Node}(L,R))&=1+\max(\mathrm{height}(L),\mathrm{height}(R)).
\end{aligned}
$$

---

### 1.5 예 D — 산술식(문법) AST
$$
E ::= n \ \mid\ (E+E)\ \mid\ (E\times E)
$$
(평가 함수)
$$
\begin{aligned}
\llbracket n\rrbracket &= n,\\
\llbracket e_1+e_2\rrbracket &= \llbracket e_1\rrbracket+\llbracket e_2\rrbracket,\\
\llbracket e_1\times e_2\rrbracket &= \llbracket e_1\rrbracket\times \llbracket e_2\rrbracket.
\end{aligned}
$$

---

### 1.6 예 E — 정규식과 의미(언어)
알파벳 $$\Sigma$$, 정규식 $$r$$ 의 언어 의미 $$\mathcal{L}(r)\subseteq \Sigma^\*$$:
$$
\begin{aligned}
\mathcal{L}(\varnothing)&=\varnothing,\quad \mathcal{L}(\varepsilon)=\{\varepsilon\},\quad \mathcal{L}(a)=\{a\},\\
\mathcal{L}(r_1|r_2)&=\mathcal{L}(r_1)\cup \mathcal{L}(r_2),\\
\mathcal{L}(r_1\cdot r_2)&=\{xy\mid x\in\mathcal{L}(r_1),y\in\mathcal{L}(r_2)\},\\
\mathcal{L}(r^\*) &= \bigcup_{k\ge 0} \mathcal{L}(r)^k.
\end{aligned}
$$

---

## 2) 구조적 귀납법(Structural Induction) — 원리와 스키마

### 2.1 원리(비공식)
재귀적으로 **생성자**로만 만들어지는 $$T$$ 에 대해, 성질 $$P(x)$$ 를 보이려면:

1) **기초**: 각 기초 생성자 인스턴스에 대해 $$P$$ 참.  
2) **귀납**: 생성자별로, **작은 구조에서 $$P$$ 참**이라면 **그 생성자의 결과에도 $$P$$ 참**.

그러면 모든 $$x\in T$$ 에 대해 $$P(x)$$ 가 성립.

> 자연수의 수학적 귀납법이 **후자 생성자**에 대한 특수 케이스라는 점을 기억.

---

### 2.2 리스트 귀납법 스키마
- 기초: $$P([])$$ 를 증명.  
- 귀납: $$P(xs)\Rightarrow P(x::xs)$$ 를 보이면 **모든 리스트**에 대해 $$P$$ 참.

### 2.3 트리 귀납법 스키마
- 기초: $$P(\mathrm{Leaf}(v))$$  
- 귀납: $$P(L)\land P(R)\Rightarrow P(\mathrm{Node}(L,R))$$

---

## 3) 대표 정리와 구조적 증명 (핵심 6선)

### 3.1 리스트 결합 길이 정리
**정리**: 모든 리스트 $$A,B$$ 에 대해
$$
\mathrm{len}(A\mathbin{++}B)=\mathrm{len}(A)+\mathrm{len}(B).
$$

**증명(리스트 귀납)**  
- 기초: $$A=[]$$ 일 때
$$
\mathrm{len}([]\mathbin{++}B)=\mathrm{len}(B)=0+\mathrm{len}(B).
$$
- 귀납: $$A=x::xs$$ 가정, 귀납가정(GH) $$\mathrm{len}(xs\mathbin{++}B)=\mathrm{len}(xs)+\mathrm{len}(B)$$.
$$
\begin{aligned}
\mathrm{len}((x::xs)\mathbin{++}B)
&= \mathrm{len}(x::(xs\mathbin{++}B))\\
&= 1+\mathrm{len}(xs\mathbin{++}B)\\
&= 1+\mathrm{len}(xs)+\mathrm{len}(B) \quad(\text{GH})\\
&= \mathrm{len}(x::xs)+\mathrm{len}(B).
\end{aligned}
$$
■

---

### 3.2 뒤집기 두 번은 항등
**정리**: 모든 리스트 $$xs$$ 에 대해 $$\mathrm{rev}(\mathrm{rev}(xs))=xs.$$

**보조정리(융합)**: $$\mathrm{rev}(xs\mathbin{++}ys)=\mathrm{rev}(ys)\mathbin{++}\mathrm{rev}(xs).$$

*보조정리 증명(귀납 on $$xs$$)*  
- 기초: $$xs=[]$$ 은 자명.  
- 귀납: $$xs=x::xs'$$,
$$
\begin{aligned}
\mathrm{rev}((x::xs')\mathbin{++}ys)
&=\mathrm{rev}(x::(xs'\mathbin{++}ys))
= \mathrm{rev}(xs'\mathbin{++}ys)\mathbin{++}[x]\\
&=(\mathrm{rev}(ys)\mathbin{++}\mathrm{rev}(xs'))\mathbin{++}[x]\\
&=\mathrm{rev}(ys)\mathbin{++}(\mathrm{rev}(xs')\mathbin{++}[x])
= \mathrm{rev}(ys)\mathbin{++}\mathrm{rev}(x::xs').
\end{aligned}
$$

*본정리 증명(귀납 on $$xs$$)*  
- 기초: $$[]$$ 자명.  
- 귀납: $$x::xs$$,
$$
\mathrm{rev}(\mathrm{rev}(x::xs))
= \mathrm{rev}(\mathrm{rev}(xs)\mathbin{++}[x])
= \mathrm{rev}([x])\mathbin{++}\mathrm{rev}(\mathrm{rev}(xs))
= [x]\mathbin{++}xs = x::xs.
$$
■

---

### 3.3 map 합성 법칙
**정리**: 임의 함수 $$f,g$$ 와 리스트 $$xs$$ 에 대해
$$
\mathrm{map}\ f(\mathrm{map}\ g\ xs)=\mathrm{map}\ (f\circ g)\ xs.
$$

*증명(리스트 귀납)* — 기초는 자명, 귀납은 정의대로 전개하면 성립. ■

---

### 3.4 (트리) **완전 이진 트리**에서 리프 = 내부노드 + 1
**정의**: 완전 이진 트리(full) = 모든 내부노드가 **정확히 두 자식**.  
**정리**: 완전 이진 트리 $$T$$ 에 대하여
$$
\mathrm{leaves}(T)=\mathrm{internal}(T)+1.
$$

*증명(트리 귀납)*  
- 기초: 리프 하나인 트리: $$1=0+1$$.  
- 귀납: $$T=\mathrm{Node}(L,R)$$ 이고 $$L,R$$ 각각 정리 성립 가정.
$$
\begin{aligned}
\mathrm{leaves}(T)&=\mathrm{leaves}(L)+\mathrm{leaves}(R)\\
&=(\mathrm{internal}(L)+1)+(\mathrm{internal}(R)+1)\\
&=\mathrm{internal}(L)+\mathrm{internal}(R)+2\\
&=(\mathrm{internal}(L)+\mathrm{internal}(R)+1)+1\\
&=\mathrm{internal}(T)+1.
\end{aligned}
$$
■

---

### 3.5 (식 AST) 노드 수와 리프 수의 관계
식 문법 $$E ::= n \mid (E+E) \mid (E\times E)$$ 에서  
**정리**: 비리프(연산자) 노드 수를 $$\mathrm{ops}(e)$$, 리프(상수) 수를 $$\mathrm{cons}(e)$$ 라 하면
$$
\mathrm{ops}(e)=\mathrm{cons}(e)-1.
$$

*증명(구조적 귀납)*  
- 기초: $$e=n$$ 일 때 $$\mathrm{ops}=0,\ \mathrm{cons}=1$$ ⟹ 성립.  
- 귀납: $$e=e_1\circ e_2\ (\circ\in\{+,\times\})$$,
$$
\mathrm{ops}(e)=1+\mathrm{ops}(e_1)+\mathrm{ops}(e_2)
=1+(\mathrm{cons}(e_1)-1)+(\mathrm{cons}(e_2)-1)
=\mathrm{cons}(e_1)+\mathrm{cons}(e_2)-1=\mathrm{cons}(e)-1.
$$
■

---

### 3.6 (정규식) Kleene-스타의 $$\varepsilon$$ 포함
**정리**: 모든 정규식 $$r$$ 에 대해 $$\varepsilon\in \mathcal{L}(r^\*)$$.

*증명* $$\mathcal{L}(r^\*)=\bigcup_{k\ge 0}\mathcal{L}(r)^k$$ 에서 $$k=0$$ 이면 $$\{\varepsilon\}$$. ■

---

## 4) 코드로 보는 재귀 정의 & 구조적 귀납법

### 4.1 Python — 리스트 성질 검증 (단위/속성 테스트)
```python
def concat(xs, ys):
    return xs + ys

def rev(xs):
    return list(reversed(xs))

def length(xs):
    return len(xs)

# 정리 3.1: len(xs++ys) = len(xs)+len(ys)
def prop_len_concat(xs, ys):
    return length(concat(xs, ys)) == length(xs) + length(ys)

# 정리 3.2: rev(rev(xs)) = xs
def prop_rev_involutive(xs):
    return rev(rev(xs)) == xs

# 정리 3.3: map 합성
def my_map(f, xs): return [f(x) for x in xs]
def prop_map_fusion(f, g, xs):
    return my_map(f, my_map(g, xs)) == my_map(lambda x: f(g(x)), xs)

# 간단 체크
assert prop_len_concat([1,2],[3,4,5])
assert prop_rev_involutive([1,2,3,4])
assert prop_map_fusion(lambda x:x+1, lambda y:y*2, [0,1,2])
```

> 실제 “증명”은 위 **속성(prop)** 그대로를 **리스트 귀납법**으로 서술하면 됩니다.

---

### 4.2 Python — 트리 정의와 속성 검증
```python
from dataclasses import dataclass
from typing import Optional, Any

@dataclass(frozen=True)
class Leaf:
    val: Any

@dataclass(frozen=True)
class Node:
    left: Any
    right: Any

def is_leaf(t): return isinstance(t, Leaf)

def leaves(t):
    if is_leaf(t): return 1
    return leaves(t.left) + leaves(t.right)

def internals(t):
    if is_leaf(t): return 0
    return 1 + internals(t.left) + internals(t.right)

# 완전 이진 트리 테스트 샘플
T = Node(Node(Leaf(1), Leaf(2)), Leaf(3))  # 내부노드 2, 리프 3 (여기는 "완전" 아님 주의)
assert leaves(T) == 3
assert internals(T) == 2
# 완전 이진 트리에서는 leaves = internals + 1 성립.
```

---

### 4.3 Python — 식 AST와 평가
```python
from dataclasses import dataclass
@dataclass(frozen=True)
class Num:
    n:int

@dataclass(frozen=True)
class Plus:
    l:any; r:any

@dataclass(frozen=True)
class Times:
    l:any; r:any

def evalE(e):
    if isinstance(e, Num): return e.n
    if isinstance(e, Plus): return evalE(e.l) + evalE(e.r)
    if isinstance(e, Times): return evalE(e.l) * evalE(e.r)
    raise TypeError

def ops(e):
    if isinstance(e, Num): return 0
    if isinstance(e, (Plus, Times)): return 1 + ops(e.l) + ops(e.r)

def cons(e):
    if isinstance(e, Num): return 1
    if isinstance(e, (Plus, Times)): return cons(e.l) + cons(e.r)

e = Plus(Num(2), Times(Num(3), Num(4)))
assert ops(e) == cons(e) - 1
assert evalE(e) == 2 + 3*4
```

---

## 5) 설계 원칙 — 종료성과 구조적 재귀

- **종료성 보장**: “재귀 인자”가 **구조적으로 작아진다**(서브구조).  
  이는 **자연수로의 측도 $$\mu$$** 가 매 호출마다 감소한다는 뜻이며,  
  자연수의 **순서화 원리(Well-Ordering)** 로 종료가 보장됩니다.

- **좋은 재귀 설계** = “**생성자 케이스**로 나누기 → **서브구조 호출** → **결합**”.

---

## 6) 구조적 귀납법 스니펫 (증명 템플릿)

### 6.1 리스트
- **P([])**: … 계산/정의로 참.  
- **P(x::xs)**: 귀납가정 **P(xs)** 를 이용해 정의 전개로 참.

### 6.2 트리
- **P(Leaf)**: … 참.  
- **P(Node(L,R))**: 귀납가정 **P(L), P(R)** 로 결론 성립.

### 6.3 식(AST)
- **P(Num n)**: … 참.  
- **P(Plus e1 e2), P(Times e1 e2)**: 귀납가정 **P(e1), P(e2)** 를 결합.

> **Tip**: 구조적 귀납은 “**생성자 수만큼**” 귀납 단계가 있습니다.

---

## 7) 더 깊게 — 폴드(fold)와 구조적 귀납

- **fold**(접기, catamorphism)는 “**재귀적 정의를 해소**”하는 표준 도식.  
  예: 리스트의 `foldr`:
  $$
  \mathrm{foldr}\ c\ n\ []=n,\quad
  \mathrm{foldr}\ c\ n\ (x::xs)=c(x,\ \mathrm{foldr}\ c\ n\ xs).
  $$
- 많은 재귀 함수(길이, 합, 모든/존재)는 사실 **fold의 특별한 경우**.
- **구조적 귀납**은 fold로 정의된 함수를 **성질**에 대해 증명할 때 **가장 자연스러운 도구**.

---

## 8) 실전 문제 풀이 예(설계→증명)

### 8.1 리스트 `filter`와 `length`의 관계
**정리**: 모든 리스트 $$xs$$, 술어 $$p$$ 에 대해
$$
0\le \mathrm{len}(\mathrm{filter}\ p\ xs)\le \mathrm{len}(xs).
$$

*증명(귀납 on $$xs$$)* — 기초 자명. 귀납에서 첫 원소가 조건을 **만족/불만족** 케이스 분기 후  
정의 전개 + 귀납가정으로 결론.

---

### 8.2 트리 순회와 노드 수
**정리**: 임의 트리 $$T$$ 에서 중위/전위/후위 순회로 얻은 리스트의 길이는 항상 $$\mathrm{size}(T)$$ 와 같다.

*증명(트리 귀납)* — 각 순회 정의를 따라 합 리스트 길이를 교차 귀납으로 셈.

---

### 8.3 식 평가의 결정성
**정리**: 위 산술식 평가 $$\llbracket\cdot\rrbracket$$ 은 **결정적**(deterministic)이다.  
즉 같은 식은 항상 같은 값.

*증명(구조적 귀납)* — 생성자별로 평가 규칙이 유일하게 정해짐.

---

## 9) 흔한 함정(실패 패턴)과 디버깅

1) **기초 사례 누락**: 빈 리스트/리프를 빼먹으면 *정의도 증명도* 깨짐.  
2) **서브구조가 아닌 인자**로 재귀: 종료성 상실 가능.  
3) **보조정리 없이 정면돌파**: `rev(rev xs)=xs` 는 **융합 보조정리**가 관건.  
4) **중복 케이스**: 생성자 분기가 겹치면 귀납 단계 모순.  
5) **치역/공역 불일치**: 재귀 함수의 반환 타입을 생성자와 일치시켜야 fold/귀납과 맞물림.

---

## 10) 치트시트

- **정의**: 기초 + 생성자(서브구조) + 최소성.  
- **증명**: 생성자별 기초/귀납. 필요한 곳엔 **보조정리** 먼저.  
- **종료성**: “작아짐(측도 감소)” 보장.  
- **패턴**: 리스트 귀납, 트리 귀납, 식 귀납, 정규식 귀납.  
- **코드**: 재귀는 생성자 분기 → 서브호출 → 결합.  
- **검증**: 속성 테스트는 증명의 **직관**을 확보하는 도구.

---

## 부록 A) 수식·정의 모음 (참고)

- 리스트 귀납 원리:
$$
P([])\land \big(\forall x, xs.\ P(xs)\Rightarrow P(x::xs)\big)
\ \Rightarrow\ \forall xs.\ P(xs).
$$

- 트리 귀납 원리:
$$
\big(\forall v.\ P(\mathrm{Leaf}(v))\big)\land
\big(\forall L,R.\ P(L)\land P(R)\Rightarrow P(\mathrm{Node}(L,R))\big)
\ \Rightarrow\ \forall T.\ P(T).
$$

- fold의 유니버설 성질(스케치): 재귀 방정식을 만족하는 해는 **유일**.

---

## 부록 B) 추가 예제 코드 스니펫

### B.1 foldr로 다시 쓰는 리스트 함수
```python
from functools import reduce
def foldr(c, n, xs):
    # 오른쪽 접기: Python reduce는 왼쪽부터이므로 재현
    def go(xs):
        return n if not xs else c(xs[0], go(xs[1:]))
    return go(xs)

def length(xs): return foldr(lambda _x, acc: 1+acc, 0, xs)
def rev(xs):    return foldr(lambda x, acc: acc+[x], [], xs)
def concat(xs, ys): return foldr(lambda x, acc: [x]+acc, ys, xs)
```

### B.2 정규식 의미(간이 구현 아이디어)
```python
def L_empty(): return {()}        # ε
def L_void():  return set()       # ∅
def L_char(a): return {(a,)}      # 단일 문자(튜플로 표현)

def union(S, T): return S | T
def concat(S, T):
    return { s+t for s in S for t in T }
def star(S):
    R = {()}  # ε
    frontier = {()}
    # 유한 근사(길이<=k)로 실험적 계산; 이론은 정의로 귀납
    for _ in range(3):
        frontier = concat(frontier, S)
        R |= frontier
    return R
```

> 이 코드는 **아이디어용**. 이론에서의 **귀납/공리**가 실제 구현으로 **가이드라인**이 됩니다.

---

## 마무리

- **재귀적 정의**는 “데이터를 만드는 법”, **구조적 귀납법**은 “그 데이터에 대해 증명하는 법”.  
- 리스트/트리/식/정규식 등 **모든 재귀적 데이터**에 **동일한 프레임**으로 접근할 수 있습니다.  
- 실전에서는:  
  1) **생성자 기반**으로 정의·코드·증명을 나란히 세우고,  
  2) **보조정리(융합·분배 등)** 를 먼저 확보하며,  
  3) **종료성(서브구조로의 감소)** 을 체크하십시오.

이 두 도구를 손에 넣으면, **정확성 증명**, **알고리즘 설계**, **문법/언어 의미론**까지 견고하게 다룰 수 있습니다.