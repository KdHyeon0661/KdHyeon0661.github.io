---
layout: post
title: 이산수학 - 재귀적 정의와 구조적 귀납법
date: 2025-06-03 20:20:23 +0900
category: 이산수학
---
# 🔁 재귀적 정의와 구조적 귀납법

## 📌 개요

**재귀적 정의**와 **구조적 귀납법**은 서로 깊이 연결된 개념으로,  
복잡한 대상(수열, 문자열, 트리 등)을 **단순한 구성 요소로부터 정의하고**,  
그 성질을 **귀납적으로 증명**하는 데 사용됩니다.

> 즉, "정의는 재귀적으로", "증명은 구조적으로"

---

## 🧩 1. 재귀적 정의 (Recursive Definition)

재귀적 정의는 어떤 객체를 **기본 사례(base case)**와  
**규칙(case step)**을 통해 **자기 자신을 참조하면서 정의**하는 방식입니다.

### ✅ 예시 1: 자연수의 재귀적 정의

\[
\begin{cases}
0 \in \mathbb{N} & \text{(기초 단계)} \\
\text{if } n \in \mathbb{N},\ \text{then } n+1 \in \mathbb{N} & \text{(귀납 단계)}
\end{cases}
\]

→ 즉, **0에서 시작해서 하나씩 더하는 방식**으로 자연수를 정의

---

### ✅ 예시 2: 팩토리얼

\[
\begin{cases}
0! = 1 & \text{(기초 단계)} \\
n! = n \cdot (n-1)! & \text{(재귀 단계, } n \geq 1)
\end{cases}
\]

---

### ✅ 예시 3: 피보나치 수열

\[
\begin{cases}
F_0 = 0,\ F_1 = 1 & \text{(기초 단계)} \\
F_n = F_{n-1} + F_{n-2} & \text{(재귀 단계, } n \geq 2)
\end{cases}
\]

---

### ✅ 예시 4: 리스트(List)의 재귀 정의 (프로그래밍 관점)

- 리스트는 `[]` (빈 리스트) 또는 `[head] + tail` 형식으로 정의됨

```python
def length(lst):
    if lst == []:
        return 0
    return 1 + length(lst[1:])
```

---

## 🧠 2. 구조적 귀납법 (Structural Induction)

**구조적 귀납법**은 **재귀적으로 정의된 자료구조의 모든 원소에 대해 어떤 명제가 참임을 증명**하는 방법입니다.

> 수학적 귀납법이 자연수에 대한 것이라면, 구조적 귀납법은 **구조에 기반한 데이터(트리, 수식, 문자열 등)**에 적용

---

### ✅ 증명 절차

1. **기초 단계**  
   - 가장 단순한 형태(빈 리스트, 0, 리프 노드 등)에서 명제가 참인지 증명
2. **귀납 단계**  
   - 복잡한 구조(노드, 리스트 확장, 연산 등)가 참이라고 가정했을 때  
     그보다 더 복잡한 구조에서도 명제가 참인지 증명

---

## 🧪 예제: 이진 트리의 노드 수 = 리프 수 + 내부 노드 수

### 🎯 명제

> 모든 이진 트리에 대해,  
> 노드 수 = 리프 노드 수 + 내부 노드 수

### 📌 트리의 재귀 정의

- **Leaf**: 값을 가진 단말 노드  
- **Node(left, right)**: 두 서브트리를 가지는 비단말 노드

### 🔎 구조적 귀납법 증명

#### 1. **기초 단계 (Leaf 트리)**

- 리프 수 = 1, 내부 노드 수 = 0 → 노드 수 = 1  
✅ 성립

#### 2. **귀납 단계 (Node 트리)**

- 왼쪽, 오른쪽 서브트리 각각에 대해 명제가 성립한다고 가정
- 노드 수 = 왼쪽 노드 수 + 오른쪽 노드 수 + 1  
- 리프 수 = 왼쪽 리프 수 + 오른쪽 리프 수  
- 내부 노드 수 = 왼쪽 내부 + 오른쪽 내부 + 1  
→ 명제 성립

---

## 🧪 예제: 리스트 길이와 concat 연산

### 🎯 명제

> 리스트 A, B에 대해  
> `length(A ++ B) = length(A) + length(B)`

### 📌 리스트의 재귀 정의

- `[]`는 리스트이다.  
- `x :: xs` (x를 머리로, xs를 꼬리로 하는 리스트)도 리스트이다.

### 🔎 구조적 귀납법

#### 1. 기초: A = []

```haskell
length([] ++ B) = length(B) = 0 + length(B)
```
✅ 성립

#### 2. 귀납: A = x :: xs

```haskell
length((x :: xs) ++ B)
= 1 + length(xs ++ B)
= 1 + (length(xs) + length(B))   (귀납 가정)
= (1 + length(xs)) + length(B)
= length(x :: xs) + length(B)
```
✅ 성립

---

## 🔁 재귀 정의 & 구조적 귀납법: 요약 대응표

| 재귀적 정의                     | 구조적 귀납법 증명                        |
|-------------------------------|------------------------------------------|
| 기본 사례 정의 (`0`, `[]`)     | 기초 단계: 가장 단순한 구조부터 시작    |
| 복잡한 케이스 정의 (`n+1`, `x::xs`) | 귀납 단계: 작은 구조의 참을 가정해 증명 |
| 트리 구조, 리스트, 수식 표현    | 구조 전체에 걸쳐 귀납 증명 가능          |

---

## ✅ 마무리 요약

- 재귀 정의는 **자료를 구성하는 방식**  
- 구조적 귀납법은 **그 구조에 대해 성질을 증명하는 도구**
- 일반적인 수학적 귀납법의 확장 개념
- **트리, 리스트, 수식, 정규 표현식, 문법 등**에 자주 사용됨