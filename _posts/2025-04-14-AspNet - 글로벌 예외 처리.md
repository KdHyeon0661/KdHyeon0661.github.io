---
layout: post
title: AspNet - 글로벌 예외 처리
date: 2025-04-10 22:20:23 +0900
category: AspNet
---
# ASP.NET Core 글로벌 예외 처리

## 왜 글로벌 예외 처리인가?

- 컨트롤러/핸들러마다 `try-catch`를 반복하면 중복/누락 발생.
- 예외를 **한 곳**에서 받아 **일관된 응답 형식**(HTML 또는 JSON)과 **로깅**을 보장.
- **환경별 보안 정책**(개발: 상세 오류, 운영: 요약/추적 ID) 적용이 용이.
- **가시성/관찰성**(Correlation/Trace ID) 부여 및 경계 로깅에 유리.

---

## 파이프라인의 기본 형태(환경 분기)

```csharp
var builder = WebApplication.CreateBuilder(args);

// 로깅/서비스 등록 생략...
var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    // 개발: 상세 예외 페이지
    app.UseDeveloperExceptionPage();
}
else
{
    // 운영: 글로벌 예외 핸들러 + HSTS
    app.UseExceptionHandler("/Error");     // MVC/Razor용 re-execute
    // 또는 app.UseExceptionHandler(ConfigureGlobalHandler(app));
    app.UseHsts();
}

// 공통 파이프라인
app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();

// 상태 코드 기본 페이지(선택)
app.UseStatusCodePages(); // 또는 커스텀(아래 참고)

app.MapControllers();
app.MapRazorPages();
app.Run();
```

> 핵심: **`UseExceptionHandler`는 가능한 상단**(정적 파일 뒤, 라우팅 앞/뒤 선택은 전략에 따라)에서 배치해, 하위 미들웨어에서 던진 예외를 포착.

---

## 운영 환경에서의 전략 비교: Redirect vs Re-Execute vs Inline 처리

### Razor/MVC 중심(HTML UI) — 경로 재실행(Re-Execute)

```csharp
app.UseExceptionHandler("/Error"); // /Error 액션/페이지로 파이프라인 재실행
```

- 장점: 공통 레이아웃을 가진 사용자 친화 오류 페이지 제공.
- 단점: API와는 맞지 않음(JSON 필요).

`Pages/Error.cshtml` 또는 `Controllers/ErrorController`에서 사용자용 페이지 제공:

```csharp
// Pages/Error.cshtml.cs
public sealed class ErrorModel : PageModel
{
    private readonly ILogger<ErrorModel> _logger;
    public string? RequestId { get; private set; }
    public ErrorModel(ILogger<ErrorModel> logger) => _logger = logger;

    public void OnGet()
    {
        RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier;
        _logger.LogError("Unhandled error. TraceId={TraceId}", RequestId);
    }
}
```

### API 중심(JSON) — Inline 미들웨어 구성

`UseExceptionHandler` 오버로드로 미들웨어를 직접 구성해 **`ProblemDetails` JSON** 반환:

```csharp
app.UseExceptionHandler(appErr =>
{
    appErr.Run(async context =>
    {
        var feature = context.Features.Get<IExceptionHandlerPathFeature>();
        var ex = feature?.Error;

        // 항상 500으로 시작하고, 예외 타입에 따라 상태 코드 재지정
        var status = ex switch
        {
            NotFoundException     => StatusCodes.Status404NotFound,
            ValidationException   => StatusCodes.Status400BadRequest,
            ConflictException     => StatusCodes.Status409Conflict,
            UnauthorizedAccessException => StatusCodes.Status401Unauthorized,
            _ => StatusCodes.Status500InternalServerError
        };

        var traceId = Activity.Current?.Id ?? context.TraceIdentifier;

        context.Response.StatusCode = status;
        context.Response.ContentType = "application/problem+json";

        var problem = new ProblemDetails
        {
            Type = $"https://httpstatuses.com/{status}",
            Title = status switch
            {
                400 => "유효성 검사 실패",
                401 => "인증 실패",
                404 => "리소스를 찾을 수 없습니다",
                409 => "요청 충돌",
                _   => "서버 내부 오류"
            },
            Status = status,
            Detail = app.Environment.IsDevelopment() ? ex?.ToString() : "서버에서 오류가 발생했습니다.",
            Instance = feature?.Path
        };

        // 관찰성: traceId 제공
        problem.Extensions["traceId"] = traceId;

        // 유효성 예외라면 오류 목록 포함(예: FluentValidation)
        if (ex is ValidationException vex)
            problem.Extensions["errors"] = vex.Errors.Select(e => new { e.PropertyName, e.ErrorMessage });

        await context.Response.WriteAsJsonAsync(problem);
    });
});
```

> **운영**에서는 `Detail`에 스택 트레이스 노출 금지. 대신 `traceId`를 제공해 로그/분석 시스템에서 조회 가능하게 한다.

---

## `UseDeveloperExceptionPage()` — 개발용 상세 페이지

```csharp
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage(); // 스택, 라우팅/쿼리/쿠키 등 풍부한 진단
}
```

- 반드시 **개발 환경**에서만.
- 운영 노출은 보안상 위험(내부 구조/경로/헤더 노출).

---

## 상태 코드 페이지(404/403 등) — StatusCodePages

### 기본 텍스트

```csharp
app.UseStatusCodePages(); // 404, 403 등 간단한 텍스트 응답
```

### 경로 리다이렉트/재실행

```csharp
// /StatusCode/404 등으로 리다이렉트
app.UseStatusCodePagesWithRedirects("/StatusCode/{0}");

// 현재 파이프라인에서 /StatusCode/{code}로 재실행
app.UseStatusCodePagesWithReExecute("/StatusCode/{0}");
```

컨트롤러/페이지에서 상태별 예쁘게 렌더링 가능.

> API 프로젝트에서는 StatusCodePages 대신 **일관된 JSON 오류 응답**을 권장(필요하다면 `ProblemDetails`를 상태 코드용으로도 통일).

---

## 사용자 지정 예외와 표준 응답 매핑

실무에서는 도메인/애플리케이션 예외를 선언하고 **표준 상태 코드/문제 타입**으로 매핑한다.

```csharp
public sealed class NotFoundException : Exception
{
    public NotFoundException(string resource, object key)
        : base($"{resource}({key}) not found.") { }
}
public sealed class ConflictException : Exception
{
    public ConflictException(string message) : base(message) { }
}

public sealed class ValidationException : Exception
{
    public IEnumerable<ValidationError> Errors { get; }
    public ValidationException(IEnumerable<ValidationError> errors)
        : base("Validation failed.") => Errors = errors;
}

public sealed record ValidationError(string PropertyName, string ErrorMessage);
```

- 서비스 계층에서 위 예외를 던지면, 글로벌 핸들러에서 상태 코드(404/409/400 등)로 변환.
- 컨트롤러/핸들러는 예외를 **던지기만** 하도록 단순화.

---

## `ProblemDetails`를 API 표준으로

- RFC 7807 표준(`application/problem+json`).
- 클라이언트에서 **일관된 오류 파싱** 가능.
- 커스텀 정보를 `Extensions`에 담아 확장(예: `traceId`, `errors`).

예: 검증 오류 응답 형태

```json
{
  "type": "https://httpstatuses.com/400",
  "title": "유효성 검사 실패",
  "status": 400,
  "detail": "입력값이 유효하지 않습니다.",
  "instance": "/api/users",
  "traceId": "00-3ea...-00",
  "errors": [
    { "propertyName": "Email", "errorMessage": "올바른 이메일이 아닙니다." }
  ]
}
```

---

## 예외 처리 미들웨어와 필터의 역할 구분

| 기술 | 적용 범위 | 장점 | 한계/유의 |
|---|---|---|---|
| `UseExceptionHandler` | 파이프라인 전역 | MVC/Minimal API/StaticFiles 이후 발생 예외까지 포착 | 이미 응답이 시작된 경우 개입 어려움 |
| Controller/Action `ExceptionFilter` | MVC 액션 내부 | MVC에 최적화, 액션/컨트롤러별 세밀 제어 | 미들웨어보다 범위 좁음, Minimal API 비포함 |
| Page/Filter/Attribute | Razor Pages/MVC | 뷰 렌더링 시 특정 처리 | API 표준 JSON에는 부적합 |

> **API 우선**: `UseExceptionHandler`에서 JSON 표준화.
> **MVC/Razor 우선**: `UseExceptionHandler("/Error")`로 재실행 + 필요 시 `ExceptionFilter` 보조.

### 간단한 `ExceptionFilter` 예시

```csharp
public sealed class ApiExceptionFilter : IExceptionFilter
{
    private readonly IWebHostEnvironment _env;
    private readonly ILogger<ApiExceptionFilter> _logger;

    public ApiExceptionFilter(IWebHostEnvironment env, ILogger<ApiExceptionFilter> logger)
        => (_env, _logger) = (env, logger);

    public void OnException(ExceptionContext context)
    {
        var ex = context.Exception;
        var status = ex switch
        {
            NotFoundException => StatusCodes.Status404NotFound,
            ValidationException => StatusCodes.Status400BadRequest,
            _ => StatusCodes.Status500InternalServerError
        };

        _logger.LogError(ex, "Unhandled exception in MVC.");

        var problem = new ProblemDetails
        {
            Title = "요청 처리 중 오류가 발생했습니다.",
            Status = status,
            Detail = _env.IsDevelopment() ? ex.ToString() : null,
            Type = $"https://httpstatuses.com/{status}",
            Instance = context.HttpContext.Request.Path
        };

        context.Result = new ObjectResult(problem)
        {
            StatusCode = status,
            DeclaredType = typeof(ProblemDetails)
        };

        context.ExceptionHandled = true;
    }
}
```

등록:

```csharp
builder.Services.AddControllers(options =>
{
    options.Filters.Add<ApiExceptionFilter>();
});
```

---

## Minimal API에서의 간결한 매핑(.NET 7/8)

Minimal API의 예외를 포착해 표준 응답으로 변환:

```csharp
app.UseExceptionHandler(appErr =>
{
    appErr.Run(async ctx =>
    {
        var ex = ctx.Features.Get<IExceptionHandlerFeature>()?.Error;
        var status = ex is NotFoundException ? 404 :
                     ex is ValidationException ? 400 : 500;

        ctx.Response.StatusCode = status;
        ctx.Response.ContentType = "application/problem+json";

        await ctx.Response.WriteAsJsonAsync(new ProblemDetails
        {
            Status = status,
            Title = status == 404 ? "Not Found" :
                    status == 400 ? "Bad Request" : "Internal Server Error",
            Detail = app.Environment.IsDevelopment() ? ex?.ToString() : null,
            Instance = ctx.Request.Path
        });
    });
});
```

---

## 이미 응답이 시작된 경우

- 헤더/상태 코드가 **이미 전송된 후** 예외가 발생하면, `UseExceptionHandler`가 새 응답을 구성할 수 없다.
- 해결책:
  - 본문을 쓰기 전 오류 가능성이 있는 작업을 우선 수행.
  - 스트리밍/대용량 응답에서는 부분 실패 처리 전략(범위 응답, 취소 토큰, 타임아웃) 고려.
  - 프록시/클라이언트에 **idempotent 재시도/취소** 정책 안내.

---

## 로깅 전략(ILogger/Serilog)

### `ILogger` 기본

- `LogError(ex, "...")`로 스택 추적 포함.
- 로깅 스코프에 `TraceIdentifier`/Correlation ID를 포함해 검색 가능성 강화.

```csharp
using (_logger.BeginScope(new Dictionary<string, object?>
{
    ["TraceId"] = HttpContext.TraceIdentifier
}))
{
    _logger.LogError(ex, "Unhandled exception");
}
```

### Serilog 통합(예시)

```csharp
// Program.cs 빌드 이전
Log.Logger = new LoggerConfiguration()
    .Enrich.FromLogContext()
    .Enrich.WithMachineName()
    .Enrich.WithThreadId()
    .WriteTo.Console()
    .WriteTo.File("logs/app-.log", rollingInterval: RollingInterval.Day)
    .CreateLogger();

builder.Host.UseSerilog();
```

- `UseSerilogRequestLogging()`을 추가해 요청 시작/종료 이벤트 구조화.
- `traceId`를 ProblemDetails와 로그 모두에 담아 상호 참조 가능하게.

---

## 유효성 검증 예외와 표준 상태 코드

- `FluentValidation` 또는 DataAnnotations 검증 실패를 `ValidationException`으로 변환.
- 글로벌 핸들러에서 `400 Bad Request + ProblemDetails`로 표준화.
- MVC ModelState를 사용한다면 **자동 400**을 `ApiBehaviorOptions`로 제어/커스터마이즈 가능.

```csharp
builder.Services.Configure<ApiBehaviorOptions>(o =>
{
    o.InvalidModelStateResponseFactory = context =>
    {
        var errors = context.ModelState
            .Where(x => x.Value?.Errors.Count > 0)
            .Select(x => new { Field = x.Key, Errors = x.Value!.Errors.Select(e => e.ErrorMessage) });

        var problem = new ValidationProblemDetails(context.ModelState)
        {
            Status = StatusCodes.Status400BadRequest,
            Title = "유효성 검사 실패",
            Detail = "입력값을 확인하세요."
        };
        problem.Extensions["traceId"] = context.HttpContext.TraceIdentifier;
        problem.Extensions["errorsSimple"] = errors;

        return new BadRequestObjectResult(problem)
        {
            ContentTypes = { "application/problem+json" }
        };
    };
});
```

---

## 커스텀 미들웨어로 전역 예외 처리(대안)

필요 시 직접 미들웨어를 작성해도 된다. 단, `UseExceptionHandler`는 프레임워크 표준 처리/재실행과 호환이 좋아 우선 고려.

```csharp
public sealed class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;
    private readonly IWebHostEnvironment _env;

    public GlobalExceptionMiddleware(RequestDelegate next, ILogger<GlobalExceptionMiddleware> logger, IWebHostEnvironment env)
        => (_next, _logger, _env) = (next, logger, env);

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex) when (LogAndFilter(ex, context))
        {
            // 빈 catch: LogAndFilter가 응답까지 책임짐
        }
    }

    private bool LogAndFilter(Exception ex, HttpContext ctx)
    {
        var status = ex switch
        {
            NotFoundException => 404,
            ValidationException => 400,
            _ => 500
        };

        _logger.LogError(ex, "Unhandled exception at {Path}", ctx.Request.Path);

        if (!ctx.Response.HasStarted)
        {
            ctx.Response.StatusCode = status;
            ctx.Response.ContentType = "application/problem+json";
            var problem = new ProblemDetails
            {
                Status = status,
                Title = status == 404 ? "Not Found" :
                        status == 400 ? "Bad Request" : "Internal Server Error",
                Detail = _env.IsDevelopment() ? ex.ToString() : null,
                Instance = ctx.Request.Path
            };
            problem.Extensions["traceId"] = ctx.TraceIdentifier;
            ctx.Response.WriteAsJsonAsync(problem).GetAwaiter().GetResult();
        }
        return true;
    }
}
```

등록:

```csharp
app.UseMiddleware<GlobalExceptionMiddleware>();
```

> `UseExceptionHandler`와 **중복 배치**는 피하자. 둘 중 하나의 패턴으로 일관되게.

---

## 보안 고려사항

- 운영에서는 **스택 트레이스/내부 메시지**를 절대 노출하지 않는다.
- 대신 `traceId`만 제공, 내부 로깅/APM에서 연계 조회.
- 민감한 예외(연결 문자열, 자격 증명, 파일 경로 등)가 메시지에 포함되지 않도록 주의.
- 4xx와 5xx를 구분해 **알람/모니터링**의 신호-노이즈를 줄인다.

---

## 테스트 전략(통합/단위)

- 통합 테스트에서 고의로 예외를 발생시키는 엔드포인트를 만들고,
  `ProblemDetails` 스키마(`type/title/status/traceId`)를 검증.
- 상태 코드별(400/401/403/404/409/500) 표준 응답과 로깅 여부(에러 레벨)를 검증.
- 이미 응답이 시작된 경우의 동작은 e2e로 시뮬레이션(스트리밍/파일 응답 등) 필요.

---

## 상태 코드/예외 매핑 추천 테이블

| 예외/상황 | 상태 코드 | 메모 |
|---|---|---|
| `ValidationException`, ModelState Invalid | 400 | 필드별 오류 배열 포함 |
| 인증 실패 | 401 | 인증 토큰/쿠키 없음/만료 |
| 권한 부족 | 403 | 인증됨/권한 없음 |
| 리소스 없음 | 404 | 키/경로 누락 |
| 낙관적 동시성 실패/중복 | 409 | 낙관적 잠금, 유니크 충돌 |
| 서비스 제한/레이트 제한 | 429 | Retry-After 헤더 포함 |
| 서버 내부 | 500 | 운영에서는 스택 미노출 |

---

## 최종 예시(혼합: MVC + API)

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllersWithViews();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
    app.UseSwagger();
    app.UseSwaggerUI();
}
else
{
    // Razor 페이지/뷰 기반 에러 페이지
    app.UseExceptionHandler("/Error");

    // 또는 API 전용 JSON 핸들러를 원하면 아래 블록으로 교체
    /*
    app.UseExceptionHandler(err =>
    {
        err.Run(async ctx =>
        {
            var ex = ctx.Features.Get<IExceptionHandlerFeature>()?.Error;
            var status = ex is NotFoundException ? 404 :
                         ex is ValidationException ? 400 : 500;

            ctx.Response.StatusCode = status;
            ctx.Response.ContentType = "application/problem+json";

            var pb = new ProblemDetails
            {
                Status = status,
                Title = status == 404 ? "Not Found" :
                        status == 400 ? "Bad Request" : "Internal Server Error",
                Detail = app.Environment.IsDevelopment() ? ex?.ToString() : null,
                Instance = ctx.Request.Path
            };
            pb.Extensions["traceId"] = ctx.TraceIdentifier;
            await ctx.Response.WriteAsJsonAsync(pb);
        });
    });
    */

    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();

app.UseAuthorization();

app.UseStatusCodePagesWithReExecute("/StatusCode/{0}");

app.MapControllers();
app.MapRazorPages();

app.Run();
```

---

## 요약

- **개발**: `UseDeveloperExceptionPage`로 신속한 디버깅.
- **운영**: `UseExceptionHandler`로 글로벌 예외 표준화.
  - HTML UI → `/Error` 재실행
  - API → Inline 핸들러에서 **`ProblemDetails`** 반환
- **사용자 정의 예외**를 **표준 상태 코드**로 변환(404/400/409/401/403/500).
- **로깅/관찰성**: `traceId`를 응답과 로그에 함께 기록.
- **StatusCodePages**로 404/403 사용자 경험 개선(또는 API의 경우 JSON 표준화).
- 이미 응답이 시작된 후의 예외는 사전 설계/테스트로 방지.
- 보안: 운영에서는 내부 정보 미노출, 표준 메시지 + 추적 ID만 반환.
