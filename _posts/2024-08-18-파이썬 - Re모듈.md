---
layout: post
title: 파이썬 - Re 모듈
date: 2024-08-18 19:20:23 +0900
category: Python
---
# 파이썬 `re` 모듈

## 왜 정규표현식인가?

- 복잡한 문자열 패턴(로그, 경로, 이메일, 날짜, 수치, 토큰 등)을 **짧은 식**으로 검증·추출·치환.
- 간단한 전처리는 `str` 메서드로도 충분하지만, **다양한 변형/조건**이 있거나 **문법화된 문자열**은 `re`가 압도적.

---

## `re`의 주요 함수 — 한눈 요약

| 함수 | 핵심 용도 | 반환 | 비고 |
|---|---|---|---|
| `re.search(p, s)` | **전체 문자열**에서 **첫** 매치 | `Match` 또는 `None` | 가장 흔한 기본기 |
| `re.match(p, s)` | **문자열 시작**에서만 매치 | `Match` 또는 `None` | 시작 고정이 필요할 때만 |
| `re.fullmatch(p, s)` | 문자열 **전체**가 패턴과 정확히 일치 | `Match` 또는 `None` | **검증**에 최적 |
| `re.findall(p, s)` | **모든** 매치의 **텍스트** | `list[str]` or `list[tuple]` | 그룹이 있으면 **튜플** 리스트 |
| `re.finditer(p, s)` | **모든** 매치의 이터레이터 | `Iterator[Match]` | 큰 입력에 효율적 |
| `re.split(p, s, maxsplit=0)` | 패턴 기준 **분할** | `list[str]` | 캡처 그룹 있으면 **구분자도 포함** |
| `re.sub(p, repl, s, count=0)` | 패턴 **치환** | `str` | `repl`은 **문자열** 또는 **함수** |
| `re.subn(p, repl, s, count=0)` | 치환 + **치환 횟수** | `(result_str, n_subs)` | 통계 필요 시 |
| `re.compile(p, flags=...)` | 패턴 **사전 컴파일** | `Pattern` | 반복 사용 시 **성능** 이점 |
| `re.escape(s)` | 리터럴 안전 이스케이프 | `str` | 사용자 입력을 **패턴에 삽입**할 때 |

> **TIP**: 검증은 `fullmatch`, 존재 여부 확인은 `search`, 반복 추출은 `finditer`.

---

## `search` vs `match` vs `fullmatch`

```python
import re
text = "ID=abc123; Token=XYZ"

print(bool(re.search(r"[A-Za-z]\w{2,}", text)))   # True (어디든 첫 매치)
print(bool(re.match(r"[A-Za-z]\w{2,}", text)))    # True? → 텍스트가 알파벳으로 시작해야만
print(bool(re.fullmatch(r".+=.+", text)))         # False (전체가 '키=값' 하나여야 함)
```

- **검색**: `search`
- **시작 고정**: `match` (대부분은 `^` 앵커가 있는 `search`로 대체 가능)
- **완전 검증**: `fullmatch`

---

## 치환 `re.sub` — 문자열 vs 콜러블

### 간단 치환

```python
import re
text = "apple, banana, apple"
print(re.sub(r"apple", "orange", text))  # "orange, banana, orange"
```

### 그룹 참조 치환 (역참조)

```python
text = "2025-06-30"
# YYYY-MM-DD → DD/MM/YYYY

print(re.sub(r"(\d{4})-(\d{2})-(\d{2})", r"\3/\2/\1", text))  # "30/06/2025"
```

### **함수** 치환 (조건·계산·포맷)

```python
import re

def upcase_if_short(m):
    w = m.group(0)
    return w.upper() if len(w) <= 3 else w

s = "go big or go home"
print(re.sub(r"[A-Za-z]+", upcase_if_short, s))  # "GO big OR GO home"
```

> 콜러블 치환은 **정교한 로직**(숫자 변환, 포맷팅, 맵핑)에 매우 유용.

---

## 패턴 기초 문법 — 최소한 이것만

| 토큰 | 의미 | 예 |
|---|---|---|
| `.` | 임의의 한 문자(개행 제외) | `a.b` → `acb` |
| `^` / `$` | 행/문자열 시작·끝 | `^Hello$` |
| `*` / `+` / `?` | 0+ / 1+ / 0~1 | `ab*`, `ab+`, `ab?` |
| `{n}`, `{n,}`, `{n,m}` | 반복 횟수 | `\d{4}`, `\d{2,}`, `\d{2,4}` |
| `[...]` | 문자 집합 | `[A-Fa-f0-9]` |
| `|` | OR | `cat|dog` |
| `(...)` | **그룹** | 캡처·참조·우선순위 |
| `(?:...)` | **비캡처** 그룹 | 구조만 묶고 캡처 X |

### **탐욕(greedy)** vs **비탐욕(non-greedy)**

- 기본은 **탐욕**: 가능한 **많이** 먹음.
- `*?`, `+?`, `??`, `{m,n}?` 는 **비탐욕**: 가능한 **적게**.

```python
s = "<b>bold</b><i>it</i>"
re.findall(r"<.*>", s)    # ['<b>bold</b><i>it</i>'] (탐욕)
re.findall(r"<.*?>", s)   # ['<b>', '</b>', '<i>', '</i>'] (비탐욕)
```

---

## 그룹과 캡처 — 위치·의미·이름

### 캡처 & 역참조

```python
m = re.match(r"(\d{4})-(\d{2})-(\d{2})", "2025-06-30")
if m:
    y, mo, d = m.groups()
    print(y, mo, d)  # 2025 06 30
```

### **이름 있는 그룹**

```python
m = re.match(r"(?P<y>\d{4})-(?P<m>\d{2})-(?P<d>\d{2})", "2025-11-10")
print(m.group("y"), m.group("m"), m.group("d"))  # 2025 11 10
print(m.groupdict())  # {'y': '2025', 'm': '11', 'd': '10'}
```

### 비캡처 그룹 `(?:...)`

- 그룹화(우선순위, 반복)만 하고 **결과에는 포함 X**
  성능·가독성·`findall` 반환형 제어에 유용.

---

## 경계와 앵커 — 단어 경계/문자열 경계

| 토큰 | 의미 | 비고 |
|---|---|---|
| `\b` | **단어 경계** | 영숫자 ↔ 비영숫자 경계 |
| `\B` | 비-단어 경계 | |
| `\A` / `\Z` | 절대 시작 / 절대 끝 | `^`, `$`는 **멀티라인** 영향 |
| `^` / `$` | 행의 시작/끝 (기본은 전체 시작/끝) | `re.MULTILINE` 플래그 시 행 기준 |

```python
re.findall(r"\bcat\b", "cat scatter bobcat")  # ['cat'] (정확히 'cat'만)
```

---

## 전방·후방 탐색 (lookaround)

- **소비하지 않는(0폭)** 조건식: 매치 **전후 맥락**을 확인만.

| 패턴 | 의미 |
|---|---|
| `(?=...)` | 긍정 **전방**: 뒤에 ...가 와야 함 |
| `(?!...)` | 부정 **전방**: 뒤에 ...가 오면 안 됨 |
| `(?<=...)` | 긍정 **후방**: 앞에 ...가 있어야 함 |
| `(?<!...)` | 부정 **후방**: 앞에 ...가 있으면 안 됨 |

```python
s = "Price: $10, $20, and $3"
# 달러 기호 뒤 숫자만 (기호 제외 추출)

print(re.findall(r"(?<=\$)\d+", s))  # ['10', '20', '3']

# 'cat' 다음이 공백/문자열 끝일 때만

print(bool(re.search(r"cat(?!\w)", "my cat ")))   # True
print(bool(re.search(r"cat(?!\w)", "my category")))  # False
```

> **후방 탐색은 고정 폭** 제약(패턴 길이가 정해져야 함)이 있습니다.

---

## 플래그 — `re.IGNORECASE` 등

| 플래그 | 의미 | 단축 |
|---|---|---|
| `re.IGNORECASE` | 대소문자 무시 | `re.I` |
| `re.MULTILINE` | `^/$`가 **행 단위**로 동작 | `re.M` |
| `re.DOTALL` | `.`이 개행도 매치 | `re.S` |
| `re.VERBOSE` | **가독성** 있는 패턴 (주석/공백 허용) | `re.X` |
| `re.ASCII` | `\w`, `\b` 등을 ASCII로 제한 | `re.A` |

### 멀티라인 & 도트올

```python
s = "first\nsecond"
print(re.findall(r"^.+$", s, flags=re.M))    # ['first', 'second'] (행 기준)
print(re.findall(r".+", s, flags=re.S))      # ['first\nsecond'] (개행 포함)
```

### VERBOSE — 주석/공백으로 설명형 패턴

```python
pat = re.compile(r"""
    (?P<user>[A-Za-z0-9._%+-]+)   # 사용자
    @
    (?P<host>[A-Za-z0-9.-]+)      # 호스트
    \.
    (?P<tld>[A-Za-z]{2,})         # 최상위 도메인
""", re.X)

print(pat.fullmatch("test@example.com").groupdict())
```

---

## `findall` / `finditer` 차이와 사용감

- `findall`: 결과를 **리스트**로 모두 메모리에. 그룹이 있으면 **튜플**의 리스트.
- `finditer`: **이터레이터**. 큰 텍스트 처리/인덱스 확인에 유리.

```python
s = "foo=1; bar=23; baz=456"
pat = re.compile(r"([a-z]+)=(\d+)")

for m in pat.finditer(s):
    print(m.group(1), int(m.group(2)), m.span())
# ('foo', 1, (0, 5)) ...

```

---

## `split` — 캡처 그룹 있으면 **구분자 보존**

```python
s = "path/to///file"
print(re.split(r"/+", s))                 # ['path', 'to', 'file']
print(re.split(r"(/+)", s))               # ['path', '/', 'to', '///', 'file']
```

---

## `Pattern`과 `Match` 객체 — 속성·메서드

```python
p = re.compile(r"(?P<key>\w+)=(?P<val>\d+)")
m = p.search("x=42; y=7")

print(m.group(0))              # 'x=42' (전체 매치)
print(m.group("key"), m["val"])# 'x', '42'
print(m.groups())              # ('x', '42')
print(m.groupdict())           # {'key': 'x', 'val': '42'}
print(m.start(), m.end())      # 0 4
print(m.span("val"))           # (2, 4) (캡처 위치)
```

---

## `compile`을 쓰는 타이밍 — 성능·가독성

- 반복 호출(루프·핫패스)에서 **패턴을 재사용** → `re.compile`.
- 플래그도 함께 묶고, **VERBOSE**로 문서화까지.

```python
TOKEN = re.compile(r"[A-Za-z_]\w*")
def tokenize(buf: str):
    return TOKEN.findall(buf)
```

---

## 안전한 이메일/URL/숫자 — “적당히 실용적”한 예

> RFC 완전 대응은 **지나치게 복잡**합니다. 실무에선 “적당한 보수성”의 패턴이 현실적.

```python
EMAIL = re.compile(r"""
    [A-Za-z0-9._%+-]+           # user
    @
    (?:[A-Za-z0-9-]+\.)+        # host labels.
    [A-Za-z]{2,63}              # TLD (rough)
""", re.X)

URL = re.compile(r"""
    https?://
    [^\s/$.?#].[^\s]*           # 간단 버전
""", re.X)

NUMBER = re.compile(r"""
    [+-]?
    (?:
      (?:\d{1,3}(?:,\d{3})+)    # 천단위 콤마
      |\d+                      # 또는 순수 숫자
    )
    (?:\.\d+)?                  # 선택적 소수
""", re.X)
```

---

## 실전 치환 시나리오

### 천단위 콤마 → 정수

```python
def to_int(m): return str(int(m.group(0).replace(",", "")))
s = "Price: 12,345 won; Fee: 1,000 won"
print(re.sub(r"\d{1,3}(?:,\d{3})+", to_int, s))
# "Price: 12345 won; Fee: 1000 won"

```

### 변수 치환 (템플릿)

```python
env = {"USER": "kim", "HOME": "/home/kim"}
T = re.compile(r"\$\{(?P<key>[A-Z_][A-Z0-9_]*)\}")

def replace_var(m):
    key = m["key"]
    return env.get(key, m.group(0))  # 없으면 원문 유지

print(T.sub(replace_var, "User=${USER}, Home=${HOME}, X=${X}"))
```

---

## **카타스트로픽 백트래킹** 방지 (성능·보안)

- 중첩된 **탐욕적** 반복과 **모호한 분기**가 만나면 최악의 경우 **지수 시간**.
- 증상: 특정 입력에서 CPU 100%, 응답 지연/타임아웃.

### 위험한 예

```python
# 악성 입력에 매우 느려질 수 있음

VULN = re.compile(r"(a+)+$")
print(bool(VULN.match("a" * 3000 + "X")))  # 오래 걸릴 수 있음
```

### 대책

- 가능한 **구체적**으로 작성(경계/분리자 명시).
- **비탐욕** 사용, 불필요한 캡처 제거.
- 입력 길이 제한, **타임아웃**(Python 기본 `re`는 내장 타임아웃 없음 → 호출 측에서 제한).
- 더 고급 기능이 필요하면 **서드파티 `regex` 패키지**(시간 제한, 일부 추가 문법) 고려.

---

## 국제화(Unicode) 주의

- `\w`, `\b`는 기본적으로 **유니코드** 인식. 언어별 단어 경계가 기대와 다를 수 있음.
- ASCII만 허용하려면 `re.ASCII` 또는 패턴을 명시적으로 제한.

```python
print(re.findall(r"\w+", "한글 abc 123"))          # ['한글', 'abc', '123']
print(re.findall(r"\w+", "한글 abc 123", re.A))     # ['abc', '123']
```

---

## 데이터 검증: `fullmatch`로 확실히

```python
DATE = re.compile(r"""
    (?:19|20)\d{2}      # 1900~2099
    -
    (?:0[1-9]|1[0-2])   # 01~12
    -
    (?:0[1-9]|[12]\d|3[01])
""", re.X)

def is_date(s: str) -> bool:
    return DATE.fullmatch(s) is not None

print(is_date("2025-11-10"))  # True
print(is_date("2025-13-01"))  # False
```

---

## 로그 파싱 미니 사례

```python
LINE = re.compile(r"""
    (?P<ts>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})
    \s+
    (?P<lvl>INFO|WARN|ERROR)
    \s+
    $$(?P<mod>[^$$]+)\]
    \s+
    (?P<msg>.*)
""", re.X)

def parse_log(buf: str):
    for m in LINE.finditer(buf):
        yield m.groupdict()

sample = """\
2025-11-10T15:42:00 INFO [core] started
2025-11-10T15:42:01 ERROR [db] connection failed
"""
for row in parse_log(sample):
    print(row)
```

---

## 테스트 팁 (pytest)

```python
import re, pytest
EMAIL = re.compile(r"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$")

@pytest.mark.parametrize("ok", ["a@b.co", "x.y+z@host.name"])
def test_email_ok(ok):
    assert EMAIL.fullmatch(ok)

@pytest.mark.parametrize("bad", ["@x", "a@", "a@x", "a@x.", "a@x.c"])
def test_email_bad(bad):
    assert not EMAIL.fullmatch(bad)
```

---

## 디버깅·가독성·유지보수

- 긴 패턴은 **`re.VERBOSE`**로 작성하고, **단위 테스트**로 고정.
- 캡처가 필요 없으면 `(?:...)`로 **비캡처**.
- 사용자 입력을 패턴에 끼울 때는 **`re.escape`** 사용.
  ```python
  needle = re.escape(user_text)
  pat = re.compile(fr"\b{needle}\b", re.I)
  ```

---

## 사전 컴파일 + 함수 바인딩 (실전 템플릿)

```python
import re

_PATTERNS = {
    "email": re.compile(r"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$"),
    "date":  re.compile(r"^\d{4}-\d{2}-\d{2}$"),
}

def is_email(s: str) -> bool:
    return _PATTERNS["email"].fullmatch(s) is not None

def extract_dates(buf: str):
    for m in _PATTERNS["date"].finditer(buf):
        yield m.group(0)
```

---

## 자주 쓰는 미니 레시피 모음

- **단어 토큰**: `r"[A-Za-z_]\w*"`
- **16진**: `r"\b[0-9A-Fa-f]+\b"`
- **IPv4**(느슨): `r"\b(?:\d{1,3}\.){3}\d{1,3}\b"`
- **한국 휴대전화(단순)**: `r"01[016789]-?\d{3,4}-?\d{4}"`
- **괄호 쌍 캡처**: `r"\(([^()]*)\)"` (중첩은 정규식으로 어려움 → 파서 필요)
- **HTML 태그 제거(단순)**: `re.sub(r"<[^>]+>", "", html)` (완전 파싱은 HTML 파서 권장)

---

## 성능 체크 포인트

- 반복 호출 구간은 **`compile` 재사용**.
- `findall` vs `finditer`: 많은 매치 → `finditer`가 메모리 우수.
- 가능하면 **구체화**: 경계(`\b`), 앵커(`^$`), 명시적 클래스, 비캡처.
- 입력 길이 제한·전처리(슬라이스)로 탐색 범위 축소.

---

## 마무리 체크리스트

- [ ] 검증은 `fullmatch` 사용
- [ ] 긴 패턴은 `VERBOSE` + 주석
- [ ] 치환은 **함수형 `repl`** 적극 활용
- [ ] 캡처는 정말 필요할 때만 (비캡처 `?:`)
- [ ] 국제화/ASCII 동작 차이 인지 (`re.A`)
- [ ] 카타스트로픽 백트래킹 위험 패턴 피하기
- [ ] 테스트로 정상/경계/오류 케이스 고정

---

## 부록 A) 정규식 치트시트 (요약)

| 분류 | 토큰 | 의미 |
|---|---|---|
| 문자 | `.` | 임의 문자(개행 제외) |
| 클래스 | `\d \w \s` | 숫자/워드/공백 |
| 경계 | `\b \B` | 단어 경계/비경계 |
| 앵커 | `^ $ \A \Z` | 시작/끝/절대 시작/끝 |
| 반복 | `* + ? {n} {n,} {n,m}` | 0+ / 1+ / 0~1 / 정량 |
| 게으름 | `*? +? ?? {n,m}?` | 비탐욕 |
| 그룹 | `(...) (?:...) (?P<name>...)` | 캡처/비캡처/이름 |
| 룩어라운드 | `(?= ) (?! ) (?<= ) (?<! )` | 전/후방(긍/부정) |
| 플래그 | `re.I M S X A` | 대소무시/멀티라인/도트올/가독성/ASCII |

---

## 부록 B) 이메일 간단 추출 예 (당신 초안 보강)

```python
import re
text = "문의: test@example.com, admin@site.net"
emails = re.findall(
    r"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}",
    text
)
print(emails)  # ['test@example.com', 'admin@site.net']
```

- 다국어 도메인/복잡 TLD를 완벽히 다루려면 추가 고려가 필요합니다(현실적 타협 패턴 권장).
