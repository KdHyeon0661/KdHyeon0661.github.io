---
layout: post
title: 파이썬 - re 모듈
date: 2024-08-18 19:20:23 +0900
category: Python
---
# 파이썬 re 모듈: 정규표현식의 완벽 가이드

정규표현식은 문자열 패턴을 표현하는 강력한 언어로, 복잡한 텍스트 처리 작업을 간결하게 해결할 수 있습니다. 파이썬의 `re` 모듈은 이러한 정규표현식 기능을 완벽하게 구현하여, 로그 분석, 데이터 추출, 텍스트 검증 등 다양한 작업에서 필수적인 도구가 됩니다.

정규표현식을 배우기에는 다소 어려울 수 있지만, 한번 익히면 평생 사용할 수 있는 가장 강력한 문자열 처리 기술 중 하나입니다. 이 가이드에서는 기초부터 고급 활용까지, 실무에서 바로 적용할 수 있는 정규표현식 사용법을 상세히 설명합니다.

## 왜 정규표현식인가?

간단한 문자열 처리에는 파이썬의 기본 문자열 메서드(`str.split()`, `str.replace()`, `str.find()` 등)로 충분합니다. 하지만 다음과 같은 복잡한 경우에는 정규표현식이 더 효과적입니다:

1. **복잡한 패턴 매칭**: 이메일 주소, 전화번호, URL 등 구조화된 텍스트
2. **유연한 검색**: 다양한 형식의 날짜, 통화 표기, 숫자 형식
3. **고급 텍스트 처리**: HTML 태그 제거, 템플릿 변수 치환, 로그 파싱
4. **데이터 검증**: 사용자 입력의 형식 검사

## 정규표현식의 기본 요소 이해하기

정규표현식은 특별한 의미를 가진 메타문자들을 조합하여 패턴을 만듭니다. 먼저 가장 기본적인 메타문자들을 이해해 보겠습니다.

### 기본 메타문자

```python
import re

# 점(.) - 임의의 한 문자 (개행 문자 제외)
pattern = r"b.t"  # bat, bet, bit, but 등 매치
print(re.findall(pattern, "bat bet bit but boot"))  # ['bat', 'bet', 'bit', 'but']

# 캐럿(^) - 문자열의 시작
pattern = r"^Hello"
print(bool(re.search(pattern, "Hello World")))  # True
print(bool(re.search(pattern, "Say Hello")))    # False

# 달러($) - 문자열의 끝
pattern = r"World$"
print(bool(re.search(pattern, "Hello World")))  # True
print(bool(re.search(pattern, "World Hello")))  # False

# 별표(*) - 0회 이상 반복
pattern = r"ab*c"  # ac, abc, abbc, abbbc 등
print(re.findall(pattern, "ac abc abbc abbbc"))  # ['ac', 'abc', 'abbc', 'abbbc']

# 더하기(+) - 1회 이상 반복
pattern = r"ab+c"  # abc, abbc, abbbc 등 (ac는 매치되지 않음)
print(re.findall(pattern, "ac abc abbc abbbc"))  # ['abc', 'abbc', 'abbbc']

# 물음표(?) - 0회 또는 1회
pattern = r"colou?r"  # color와 colour 모두 매치
print(re.findall(pattern, "color colour"))  # ['color', 'colour']
```

### 문자 클래스와 집합

```python
import re

# 대괄호([]) - 문자 집합 (하나의 문자와 매치)
pattern = r"[aeiou]"  # 모음 하나
print(re.findall(pattern, "Hello World"))  # ['e', 'o', 'o']

# 하이픈(-) - 범위 지정
pattern = r"[A-Za-z]"  # 모든 알파벳
print(re.findall(pattern, "Hello 123"))  # ['H', 'e', 'l', 'l', 'o']

# 캐럿(^) - 부정 (대괄호 안에서 사용 시)
pattern = r"[^0-9]"  # 숫자가 아닌 문자
print(re.findall(pattern, "Hello123"))  # ['H', 'e', 'l', 'l', 'o']

# 특수 문자 클래스
# \d - 숫자 (0-9)
# \w - 단어 문자 (알파벳, 숫자, 밑줄)
# \s - 공백 문자 (스페이스, 탭, 개행 등)
pattern = r"\d+"  # 하나 이상의 숫자
print(re.findall(pattern, "12 apples, 34 oranges"))  # ['12', '34']
```

## re 모듈의 주요 함수

`re` 모듈은 다양한 작업을 위한 여러 함수를 제공합니다. 각 함수의 용도와 차이점을 이해하는 것이 중요합니다.

### 1. `re.search()`: 패턴 검색

문자열 전체에서 패턴을 검색하고, 첫 번째로 매치되는 부분을 찾습니다.

```python
import re

text = "The quick brown fox jumps over the lazy dog"
result = re.search(r"brown", text)

if result:
    print(f"찾은 문자열: {result.group()}")  # brown
    print(f"시작 위치: {result.start()}")    # 10
    print(f"끝 위치: {result.end()}")        # 15
    print(f"위치 범위: {result.span()}")     # (10, 15)
else:
    print("패턴을 찾을 수 없습니다.")
```

### 2. `re.match()`: 문자열 시작에서 매치

문자열의 시작에서만 패턴을 검색합니다. 문자열 중간에 패턴이 있어도 시작 부분에 없으면 매치되지 않습니다.

```python
import re

# 문자열 시작에서 매치
text = "hello world"
result1 = re.match(r"hello", text)
print(f"match 결과: {bool(result1)}")  # True

# 문자열 중간에 패턴이 있는 경우
result2 = re.match(r"world", text)
print(f"match 결과: {bool(result2)}")  # False

# search는 문자열 어디에서나 검색
result3 = re.search(r"world", text)
print(f"search 결과: {bool(result3)}")  # True
```

### 3. `re.fullmatch()`: 전체 문자열 매치

전체 문자열이 패턴과 정확히 일치하는지 확인합니다. 데이터 검증에 특히 유용합니다.

```python
import re

# 이메일 형식 검증
def is_valid_email(email):
    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    return bool(re.fullmatch(pattern, email))

# 테스트
emails = [
    "user@example.com",      # 유효
    "user.name@domain.co.kr", # 유효
    "user@domain",           # 무효 (. 이후 도메인 부분 없음)
    "@example.com",          # 무효 (사용자명 없음)
    "user@.com",             # 무효 (도메인 없음)
]

for email in emails:
    print(f"{email}: {'유효' if is_valid_email(email) else '무효'}")
```

### 4. `re.findall()`: 모든 매치 찾기

문자열에서 패턴과 매치되는 모든 부분을 찾아 리스트로 반환합니다.

```python
import re

text = "내 전화번호는 010-1234-5678이고, 사무실은 02-987-6543입니다."
pattern = r"\d{2,3}-\d{3,4}-\d{4}"

phone_numbers = re.findall(pattern, text)
print(f"찾은 전화번호: {phone_numbers}")  # ['010-1234-5678', '02-987-6543']
```

### 5. `re.finditer()`: 매치 객체 이터레이터

`findall()`과 비슷하지만, 매치 객체의 이터레이터를 반환합니다. 대용량 텍스트 처리나 매치 위치 정보가 필요할 때 유용합니다.

```python
import re

text = "Python 3.10, Python 3.11, Python 3.12"
pattern = r"Python (\d+\.\d+)"

for match in re.finditer(pattern, text):
    version = match.group(1)  # 그룹 1 (버전 번호)
    start, end = match.span()  # 매치 위치
    print(f"버전: {version}, 위치: {start}-{end}")
```

### 6. `re.sub()`: 문자열 치환

패턴과 매치되는 부분을 다른 문자열로 치환합니다.

```python
import re

# 기본 치환
text = "나는 Python을 좋아합니다. Python은 강력합니다."
result = re.sub(r"Python", "파이썬", text)
print(result)  # "나는 파이썬을 좋아합니다. 파이썬은 강력합니다."

# 치환 횟수 제한
result = re.sub(r"Python", "파이썬", text, count=1)
print(result)  # "나는 파이썬을 좋아합니다. Python은 강력합니다."

# 함수를 사용한 동적 치환
def replace_numbers(match):
    number = int(match.group())
    return str(number * 2)  # 숫자를 2배로

text = "1개의 사과, 3개의 바나나, 5개의 오렌지"
result = re.sub(r"\d+", replace_numbers, text)
print(result)  # "2개의 사과, 6개의 바나나, 10개의 오렌지"
```

### 7. `re.split()`: 패턴으로 문자열 분할

패턴을 기준으로 문자열을 분할합니다.

```python
import re

# 쉼표 또는 세미콜론으로 분할
text = "사과,바나나;오렌지,키위"
result = re.split(r"[,;]", text)
print(result)  # ['사과', '바나나', '오렌지', '키위']

# 분할 횟수 제한
result = re.split(r"[,;]", text, maxsplit=2)
print(result)  # ['사과', '바나나', '오렌지,키위']

# 패턴을 캡처하면 구분자도 결과에 포함
result = re.split(r"([,;])", text)
print(result)  # ['사과', ',', '바나나', ';', '오렌지', ',', '키위']
```

### 8. `re.compile()`: 패턴 컴파일

자주 사용하는 패턴을 컴파일하여 재사용하면 성능이 향상됩니다.

```python
import re
import time

# 컴파일하지 않은 경우
start = time.time()
for i in range(10000):
    re.search(r"\d+", f"문자열 {i} 테스트")
end = time.time()
print(f"컴파일 안 함: {end - start:.4f}초")

# 컴파일한 경우
pattern = re.compile(r"\d+")
start = time.time()
for i in range(10000):
    pattern.search(f"문자열 {i} 테스트")
end = time.time()
print(f"컴파일 함: {end - start:.4f}초")
```

## 그룹 캡처: 패턴의 일부분 추출하기

그룹 캡처는 정규표현식의 강력한 기능으로, 패턴의 특정 부분을 별도로 추출할 수 있습니다.

### 기본 그룹 캡처

```python
import re

# 날짜에서 연, 월, 일 추출
text = "2024-08-18"
pattern = r"(\d{4})-(\d{2})-(\d{2})"

match = re.search(pattern, text)
if match:
    year = match.group(1)   # 2024
    month = match.group(2)  # 08
    day = match.group(3)    # 18
    print(f"년: {year}, 월: {month}, 일: {day}")
    
    # groups() 메서드로 모든 그룹 가져오기
    print(f"모든 그룹: {match.groups()}")  # ('2024', '08', '18')
```

### 이름 있는 그룹

그룹에 이름을 지정하면 코드의 가독성이 향상됩니다.

```python
import re

# 이름 있는 그룹 사용
pattern = r"(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})"
text = "생일: 1990-05-15, 결혼기념일: 2015-10-20"

for match in re.finditer(pattern, text):
    print(f"년: {match.group('year')}, "
          f"월: {match.group('month')}, "
          f"일: {match.group('day')}")
    
    # groupdict()로 딕셔너리 형태로 가져오기
    print(f"딕셔너리: {match.groupdict()}")
```

### 비캡처 그룹

그룹화는 필요하지만 결과에는 포함하지 않으려면 비캡처 그룹을 사용합니다.

```python
import re

# 비캡처 그룹 (?:...)
text = "abc123 xyz456"
pattern1 = r"(?:[a-z]+)(\d+)"  # 알파벳 그룹은 캡처하지 않음
pattern2 = r"([a-z]+)(\d+)"     # 모든 그룹 캡처

matches1 = re.findall(pattern1, text)
matches2 = re.findall(pattern2, text)

print(f"비캡처 그룹: {matches1}")  # ['123', '456'] (숫자만)
print(f"일반 그룹: {matches2}")    # [('abc', '123'), ('xyz', '456')]
```

## 탐욕적(Greedy) vs 비탐욕적(Non-greedy) 매칭

정규표현식에서 반복 메타문자(`*`, `+`, `?`, `{}`)는 기본적으로 탐욕적으로 동작합니다. 즉, 가능한 한 많은 문자와 매치하려 합니다. 비탐욕적으로 동작하게 하려면 `?`를 추가합니다.

```python
import re

text = "<b>굵은 글씨</b>와 <i>기울임 글씨</i>"

# 탐욕적 매칭 (기본)
greedy_pattern = r"<.*>"  # 가능한 한 많이 매치
greedy_result = re.findall(greedy_pattern, text)
print(f"탐욕적: {greedy_result}")  
# ['<b>굵은 글씨</b>와 <i>기울임 글씨</i>']

# 비탐욕적 매칭
non_greedy_pattern = r"<.*?>"  # 가능한 한 적게 매치
non_greedy_result = re.findall(non_greedy_pattern, text)
print(f"비탐욕적: {non_greedy_result}")  
# ['<b>', '</b>', '<i>', '</i>']
```

## 전방 탐색(Lookahead)과 후방 탐색(Lookbehind)

전방/후방 탐색은 패턴을 소비하지 않고 조건만 확인하는 특별한 그룹입니다.

### 전방 탐색 (Lookahead)

```python
import re

# 긍정 전방 탐색 (?=...): 뒤에 특정 패턴이 있어야 함
text = "apple banana cherry date"
# 'a'로 끝나고 뒤에 공백이 있는 단어
pattern = r"\w+a(?=\s|$)"
result = re.findall(pattern, text)
print(f"'a'로 끝나는 단어: {result}")  # ['banana', 'date']

# 부정 전방 탐색 (?!...): 뒤에 특정 패턴이 없어야 함
# 'e'로 끝나지만 뒤에 'r'이 오지 않는 경우
pattern = r"\w+e(?!r)"
result = re.findall(pattern, text)
print(f"'e'로 끝나고 뒤에 'r'이 없는 단어: {result}")  # ['apple']
```

### 후방 탐색 (Lookbehind)

```python
import re

# 긍정 후방 탐색 (?<=...): 앞에 특정 패턴이 있어야 함
text = "가격: $100, €200, ¥300"
# 달러 기호 뒤의 숫자
pattern = r"(?<=\$)\d+"
result = re.findall(pattern, text)
print(f"달러 가격: {result}")  # ['100']

# 부정 후방 탐색 (?<!...): 앞에 특정 패턴이 없어야 함
# 콤마 앞에 오지 않는 숫자
pattern = r"(?<!,)\b\d+\b"
text = "100, 200, 300 and 400"
result = re.findall(pattern, text)
print(f"콤마 앞에 오지 않는 숫자: {result}")  # ['100', '400']
```

## 플래그(Flags): 정규표현식 동작 제어

`re` 모듈은 정규표현식의 동작을 제어하는 다양한 플래그를 제공합니다.

### 주요 플래그

```python
import re

text = """Hello World
hello world
HELLO WORLD"""

# re.IGNORECASE (re.I): 대소문자 무시
pattern = r"hello"
result_i = re.findall(pattern, text, re.IGNORECASE)
print(f"대소문자 무시: {result_i}")  # ['Hello', 'hello', 'HELLO']

# re.MULTILINE (re.M): 멀티라인 모드 (^와 $가 각 줄의 시작/끝에 적용)
pattern = r"^hello"
result_m = re.findall(pattern, text, re.IGNORECASE | re.MULTILINE)
print(f"멀티라인: {result_m}")  # ['Hello', 'hello', 'HELLO']

# re.DOTALL (re.S): 점(.)이 개행 문자도 포함
text = "첫 줄\n두 번째 줄"
pattern = r".+"
result_s = re.findall(pattern, text, re.DOTALL)
print(f"DOTALL: {result_s}")  # ['첫 줄\n두 번째 줄']

# re.VERBOSE (re.X): 가독성 좋은 정규표현식 작성
pattern = re.compile(r"""
    ^                   # 문자열 시작
    (\d{3})             # 지역번호 (3자리)
    -                   # 하이픈
    (\d{3,4})           # 국번 (3-4자리)
    -                   # 하이픈
    (\d{4})             # 번호 (4자리)
    $                   # 문자열 끝
""", re.VERBOSE)

phone = "010-1234-5678"
match = pattern.match(phone)
if match:
    print(f"전화번호 분석: {match.groups()}")  # ('010', '1234', '5678')
```

## 실전 예제: 다양한 텍스트 처리 작업

### 1. 로그 파일 분석

```python
import re
from datetime import datetime

def parse_log_file(log_text):
    """로그 파일 파싱 함수"""
    log_pattern = re.compile(r"""
        (?P<timestamp>\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2},\d{3})
        \s+
        (?P<level>INFO|WARN|ERROR|DEBUG)
        \s+
        \[(?P<module>[^\]]+)\]
        \s+
        (?P<message>.*)
    """, re.VERBOSE)
    
    logs = []
    for match in log_pattern.finditer(log_text):
        log_entry = match.groupdict()
        logs.append(log_entry)
    
    return logs

# 샘플 로그 데이터
sample_log = """2024-08-18 10:30:15,123 INFO [web.server] 서버가 시작되었습니다.
2024-08-18 10:31:20,456 WARN [db.connection] 연결 시간이 길어지고 있습니다.
2024-08-18 10:32:05,789 ERROR [auth.service] 인증 실패: 잘못된 비밀번호
2024-08-18 10:33:10,012 DEBUG [cache.manager] 캐시 적중률: 85%"""

# 로그 분석
parsed_logs = parse_log_file(sample_log)
for log in parsed_logs:
    print(f"[{log['level']}] {log['module']}: {log['message']}")
```

### 2. 데이터 추출 및 정제

```python
import re

def extract_and_clean_data(text):
    """텍스트에서 데이터 추출 및 정제"""
    
    # 이메일 주소 추출
    email_pattern = r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
    emails = re.findall(email_pattern, text)
    
    # 전화번호 추출 (다양한 형식 지원)
    phone_pattern = r"""
        (?:                  # 비캡처 그룹 시작
          \+\d{1,3}[-.\s]?   # 국가번호 (선택적)
        )?                   # 국가번호는 선택적
        \(?\d{2,4}\)?[-.\s]? # 지역번호
        \d{3,4}[-.\s]?       # 국번
        \d{4}                # 번호
    """
    phones = re.findall(phone_pattern, text, re.VERBOSE)
    
    # URL 추출
    url_pattern = r"https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+[/\w\.-]*"
    urls = re.findall(url_pattern, text)
    
    # 해시태그 추출
    hashtag_pattern = r"#([a-zA-Z0-9_]+)"
    hashtags = re.findall(hashtag_pattern, text)
    
    return {
        'emails': emails,
        'phones': [phone.strip() for phone in phones],
        'urls': urls,
        'hashtags': hashtags
    }

# 테스트 데이터
test_text = """
연락처 정보:
이메일: john.doe@company.com, sales@example.co.kr
전화: 010-1234-5678, 02-987-6543, +82-10-5555-6666
웹사이트: https://www.example.com, http://blog.example.org
소셜: #python #programming #데이터분석
"""

result = extract_and_clean_data(test_text)
for key, value in result.items():
    print(f"{key}: {value}")
```

### 3. 템플릿 엔진 구현

```python
import re

class SimpleTemplateEngine:
    """간단한 템플릿 엔진 구현"""
    
    def __init__(self):
        self.pattern = re.compile(r"\$\{([^}]+)\}")
    
    def render(self, template: str, context: dict) -> str:
        """템플릿 렌더링"""
        
        def replace(match):
            key = match.group(1).strip()
            # 점 표기법 지원 (user.name → context['user']['name'])
            parts = key.split('.')
            value = context
            for part in parts:
                if isinstance(value, dict) and part in value:
                    value = value[part]
                else:
                    # 키가 없으면 원본 텍스트 유지
                    return match.group(0)
            return str(value)
        
        return self.pattern.sub(replace, template)

# 사용 예시
template_engine = SimpleTemplateEngine()

# 템플릿
template = """
안녕하세요, ${user.name}님!

주문 정보:
- 주문번호: ${order.id}
- 상품: ${order.product}
- 가격: ${order.price}원
- 배송지: ${user.address}

감사합니다.
${company.name}
"""

# 컨텍스트 데이터
context = {
    'user': {
        'name': '김철수',
        'address': '서울시 강남구'
    },
    'order': {
        'id': 'ORD-20240818-001',
        'product': '노트북',
        'price': '1,200,000'
    },
    'company': {
        'name': 'ABC 쇼핑몰'
    }
}

# 템플릿 렌더링
result = template_engine.render(template, context)
print(result)
```

### 4. 고급 데이터 검증

```python
import re

class DataValidator:
    """데이터 검증 클래스"""
    
    # 컴파일된 패턴들
    PATTERNS = {
        'korean_phone': re.compile(r'^01[016789]-?\d{3,4}-?\d{4}$'),
        'email': re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'),
        'url': re.compile(r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+[/\w\.-]*/?$'),
        'date_iso': re.compile(r'^\d{4}-\d{2}-\d{2}$'),
        'time_24h': re.compile(r'^([01]\d|2[0-3]):([0-5]\d)(:([0-5]\d))?$'),
        'korean_registration_number': re.compile(r'^\d{6}-?[1-4]\d{6}$'),
        'credit_card': re.compile(r'^\d{4}-?\d{4}-?\d{4}-?\d{4}$'),
        'ipv4': re.compile(r'^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'),
        'password': re.compile(r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$'),
    }
    
    @classmethod
    def validate(cls, data_type: str, value: str) -> bool:
        """데이터 검증"""
        pattern = cls.PATTERNS.get(data_type)
        if not pattern:
            raise ValueError(f"지원하지 않는 데이터 타입: {data_type}")
        
        return bool(pattern.fullmatch(value))
    
    @classmethod
    def extract_and_validate(cls, text: str, pattern_name: str):
        """텍스트에서 데이터 추출 및 검증"""
        pattern = cls.PATTERNS.get(pattern_name)
        if not pattern:
            raise ValueError(f"지원하지 않는 패턴: {pattern_name}")
        
        valid_items = []
        invalid_items = []
        
        for match in pattern.finditer(text):
            item = match.group()
            if pattern.fullmatch(item):
                valid_items.append(item)
            else:
                invalid_items.append(item)
        
        return {
            'valid': valid_items,
            'invalid': invalid_items,
            'total_found': len(valid_items) + len(invalid_items)
        }

# 검증 테스트
test_cases = [
    ("korean_phone", "010-1234-5678", True),
    ("korean_phone", "011-123-4567", True),
    ("korean_phone", "01012345678", True),
    ("korean_phone", "02-1234-5678", False),
    ("email", "user@example.com", True),
    ("email", "user.name+tag@sub.domain.co.kr", True),
    ("email", "user@.com", False),
    ("date_iso", "2024-08-18", True),
    ("date_iso", "2024/08/18", False),
    ("password", "Password123!", True),
    ("password", "weakpass", False),
]

print("데이터 검증 테스트:")
for data_type, value, expected in test_cases:
    try:
        result = DataValidator.validate(data_type, value)
        status = "✓" if result == expected else "✗"
        print(f"{status} {data_type:20} {value:30} -> {result} (기대: {expected})")
    except Exception as e:
        print(f"✗ {data_type:20} {value:30} -> 오류: {e}")
```

## 성능 최적화와 모범 사례

### 1. 패턴 컴파일 재사용

```python
import re
import time

# 성능 비교: 컴파일 vs 비컴파일
def test_performance():
    text = "a" * 1000 + "123" + "b" * 1000
    
    # 컴파일하지 않고 반복 사용
    start = time.time()
    for _ in range(1000):
        re.search(r"\d+", text)
    non_compiled_time = time.time() - start
    
    # 컴파일하고 반복 사용
    pattern = re.compile(r"\d+")
    start = time.time()
    for _ in range(1000):
        pattern.search(text)
    compiled_time = time.time() - start
    
    print(f"컴파일 없이: {non_compiled_time:.4f}초")
    print(f"컴파일하여: {compiled_time:.4f}초")
    print(f"성능 향상: {non_compiled_time/compiled_time:.1f}배")

test_performance()
```

### 2. 효율적인 패턴 작성

```python
import re

def optimize_patterns():
    """패턴 최적화 예제"""
    
    text = "abc123def456ghi789"
    
    # 비효율적인 패턴 (불필요한 그룹 캡처)
    inefficient = re.findall(r"([a-z]+)(\d+)", text)
    print(f"비효율적: {inefficient}")  # [('abc', '123'), ('def', '456'), ('ghi', '789')]
    
    # 효율적인 패턴 (필요한 부분만 캡처)
    efficient = re.findall(r"[a-z]+(\d+)", text)
    print(f"효율적: {efficient}")  # ['123', '456', '789']
    
    # 경계(anchor) 사용으로 검색 범위 제한
    text2 = "123abc456def"
    without_anchor = re.search(r"\d+", text2)  # 전체 검색
    with_anchor = re.search(r"^\d+", text2)    # 시작 부분만 검색
    
    print(f"경계 없이: {without_anchor.group() if without_anchor else None}")
    print(f"경계 사용: {with_anchor.group() if with_anchor else None}")

optimize_patterns()
```

### 3. 백트래킹 문제 방지

정규표현식의 백트래킹(backtracking)은 성능 문제를 일으킬 수 있습니다. 특히 중첩된 반복 패턴에서 문제가 발생합니다.

```python
import re
import time

def avoid_catastrophic_backtracking():
    """카타스트로픽 백트래킹 방지"""
    
    # 위험한 패턴 (지수 시간 복잡도)
    dangerous_pattern = r"(a+)+b"
    
    # 안전한 패턴 (선형 시간 복잡도)
    safe_pattern = r"a+b"
    
    # 테스트 문자열
    test_string = "a" * 100 + "b"
    
    # 위험한 패턴 테스트
    start = time.time()
    try:
        match = re.match(dangerous_pattern, test_string)
        dangerous_time = time.time() - start
        print(f"위험한 패턴: {dangerous_time:.6f}초")
    except Exception as e:
        print(f"위험한 패턴 오류: {e}")
    
    # 안전한 패턴 테스트
    start = time.time()
    match = re.match(safe_pattern, test_string)
    safe_time = time.time() - start
    print(f"안전한 패턴: {safe_time:.6f}초")

avoid_catastrophic_backtracking()
```

## 디버깅과 문제 해결

### 1. 정규표현식 디버깅

```python
import re

def debug_regex(pattern, text):
    """정규표현식 디버깅 도우미"""
    print(f"패턴: {pattern}")
    print(f"텍스트: {text}")
    print("-" * 50)
    
    try:
        # match 시도
        match_result = re.match(pattern, text)
        print(f"match() 결과: {match_result.group() if match_result else 'None'}")
        
        # search 시도
        search_result = re.search(pattern, text)
        print(f"search() 결과: {search_result.group() if search_result else 'None'}")
        
        # findall 시도
        findall_result = re.findall(pattern, text)
        print(f"findall() 결과: {findall_result}")
        
        # finditer로 상세 정보
        print("\nfinditer() 상세:")
        for i, match in enumerate(re.finditer(pattern, text), 1):
            print(f"  매치 {i}: '{match.group()}' (위치: {match.start()}-{match.end()})")
            if match.groups():
                print(f"    그룹: {match.groups()}")
    
    except re.error as e:
        print(f"정규표현식 오류: {e}")
    except Exception as e:
        print(f"기타 오류: {e}")

# 디버깅 예제
debug_regex(r"\d{3}-\d{4}", "전화: 010-1234, 02-5678")
```

### 2. 일반적인 실수와 해결 방법

```python
import re

def common_mistakes_and_solutions():
    """일반적인 실수와 해결 방법"""
    
    print("1. 특수문자 이스케이프 실수")
    text = "a.b.c"
    
    # 실수: 점(.)을 일반 문자로 취급
    wrong = re.findall(r"a.b", text)
    print(f"  잘못된 방법: {wrong}")  # ['a.b']
    
    # 해결: 특수문자 이스케이프
    correct = re.findall(r"a\.b", text)
    print(f"  올바른 방법: {correct}")  # ['a.b']
    
    print("\n2. 그룹 캡처와 findall")
    text = "abc123 xyz456"
    
    # 실수: 그룹이 있을 때 findall의 동작
    with_groups = re.findall(r"([a-z]+)(\d+)", text)
    print(f"  그룹 있을 때: {with_groups}")  # [('abc', '123'), ('xyz', '456')]
    
    # 해결: 비캡처 그룹 사용
    without_groups = re.findall(r"(?:[a-z]+)\d+", text)
    print(f"  비캡처 그룹: {without_groups}")  # ['abc123', 'xyz456']
    
    print("\n3. 앵커(anchor)의 중요성")
    text = "123abc456"
    
    # 실수: 앵커 없이 검증
    no_anchor = re.fullmatch(r"\d+", text)
    print(f"  앵커 없이 검증: {bool(no_anchor)}")  # False (전체가 숫자가 아님)
    
    # 실수: 잘못된 앵커 사용
    wrong_anchor = re.search(r"^\d+$", text)
    print(f"  잘못된 앵커: {bool(wrong_anchor)}")  # False
    
    # 해결: 부분 매치 검색
    partial_match = re.search(r"\d+", text)
    print(f"  부분 매치: {partial_match.group() if partial_match else None}")  # '123'

common_mistakes_and_solutions()
```

## 결론

파이썬의 `re` 모듈은 강력한 정규표현식 기능을 제공하여 복잡한 텍스트 처리 작업을 효율적으로 해결할 수 있게 해줍니다. 이 가이드에서 다룬 주요 개념을 요약하면 다음과 같습니다:

1. **기본 함수 이해**: `search()`, `match()`, `findall()`, `sub()` 등 각 함수의 용도와 차이점을 이해해야 합니다.
2. **패턴 작성 능력**: 메타문자, 문자 클래스, 그룹 캡처 등을 활용해 효과적인 패턴을 작성할 수 있어야 합니다.
3. **고급 기능 활용**: 전방/후방 탐색, 비탐욕적 매칭, 플래그 사용 등 고급 기능을 적절히 활용할 줄 알아야 합니다.
4. **성능 고려**: 패턴 컴파일 재사용, 효율적인 패턴 작성, 백트래킹 문제 방지 등 성능을 고려해야 합니다.
5. **실무 적용**: 로그 분석, 데이터 추출, 템플릿 처리, 데이터 검증 등 실제 문제에 적용하는 방법을 익혀야 합니다.

정규표현식은 처음에는 어렵게 느껴질 수 있지만, 계속 연습하고 실제 문제에 적용하다 보면 점점 익숙해질 것입니다. 가장 좋은 학습 방법은 실제 프로젝트에서 정규표현식을 사용해 보는 것입니다. 작은 작업부터 시작해 점점 더 복잡한 패턴을 다루다 보면, 정규표현식이 얼마나 강력한 도구인지 깨닫게 될 것입니다.

마지막으로, 정규표현식은 강력하지만 모든 문제의 해결책은 아닙니다. 너무 복잡한 패턴은 유지보수가 어렵고 성능 문제를 일으킬 수 있습니다. 적절한 수준에서 사용하고, 너무 복잡해지면 다른 접근방법(파서 라이브러리, 전문 텍스트 처리 도구 등)을 고려하는 것이 좋습니다.