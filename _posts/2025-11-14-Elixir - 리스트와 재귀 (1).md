---
layout: post
title: Elixir - 리스트와 재귀 (1)
date: 2025-11-14 23:25:23 +0900
category: Elixir
---
# 7장 — 리스트의 머리/꼬리, 재귀 처리, 리스트 생성 완전 정리

## 리스트의 머리와 꼬리

엘릭서 리스트는 **단방향 연결 리스트**(singly linked list)다.
각 노드는:

- **머리(head)**: 현재 요소 값
- **꼬리(tail)**: 나머지 리스트(또 다른 리스트, 또는 빈 리스트 `[]`)

로 구성된다.

```elixir
iex> [1, 2, 3] = [1 | [2 | [3 | []]]]
[1, 2, 3]

iex> [h | t] = [10, 20, 30]
[10, 20, 30]
iex> h
10
iex> t
[20, 30]
```

내부적으로는 다음과 같이 생각할 수 있다(개념 그림):

```text
[1, 2, 3]

   [1 |  ]  -->  [2 |  ]  -->  [3 | []]
      head        head         head
      tail  ------^            tail = []
```

- `head` 는 그 노드의 값
- `tail` 은 “나머지 리스트”에 대한 포인터(참조)

이 구조 때문에:

- **앞에 요소를 붙이는 것**은 포인터 하나만 바꾸면 돼서 \(O(1)\)
- **뒤에 요소를 붙이는 것**은 끝까지 찾아가야 해서 \(O(n)\)

라는 차이가 난다. 이게 리스트 코드를 짤 때 **가장 중요한 직관**이다.

---

### 빈 리스트와 단일/다중 요소 패턴

머리/꼬리 패턴의 기본부터 보면:

```elixir
iex> [] = []
[]
iex> [x] = [42]
[42]
iex> [x, y | rest] = [:a, :b, :c, :d]
[:a, :b, :c, :d]
iex> {x, y, rest}
{:a, :b, [:c, :d]}
```

- `[]` : **빈 리스트**에 매칭
- `[x]` : **원소 하나짜리 리스트**에 매칭
- `[x, y | rest]` : 최소 두 원소 이상인 리스트,
  앞의 두 원소는 `x`, `y`, 나머지 꼬리는 `rest`

핵심:

- 패턴에서 `|` 는 **cons** 연산자를 의미한다.
- `[h | t]` 패턴은 “리스트의 첫 요소를 `h`, 나머지를 `t`로 받겠다”는 선언.

실전에서 자주 쓰는 패턴들:

```elixir
[h | t]      # 최소 1개 이상일 때
[h, h2 | t]  # 최소 2개 이상일 때
[]           # 아무것도 없는 경우
[x]          # 정확히 1개
[x | []]     # 1개, 하지만 “머리/꼬리” 관점에서 강조할 때
```

---

### 부적절 리스트(improper list) 경고

연결 리스트 관점에서, **꼬리는 항상 리스트**여야 “정상(proper) 리스트”다.

```elixir
iex> [1 | 2]        # 꼬리가 리스트가 아님 → 부적절 리스트
[1 | 2]
```

- `[1 | 2]` 는 “머리=1, 꼬리=2”인 구조이지만,
  `2`는 리스트가 아니므로 **부적절 리스트(improper list)** 라고 부른다.
- 대부분의 엘릭서/표준 라이브러리는 **정상 리스트**(꼬리가 리스트)만 가정한다.
- 부적절 리스트는 **디버깅/특정 인터롭(얼랭 low-level 코드)** 을 제외하면 사용하지 않는 것이 안전하다.

왜 위험한가?

```elixir
iex> Enum.map([1 | 2], &(&1 * 2))
** (FunctionClauseError) no function clause matching in :lists.map/2
```

- 내부 구현이 “정상 리스트”라고 믿고 재귀를 돌다가,
  마지막 단계에서 꼬리가 더 이상 리스트가 아니라 **예외**가 난다.

---

### 리스트와 차리스트(charlist)

```elixir
iex> 'abc'      # 싱글 쿼트 = charlist = 정수 리스트
'abc'
iex> is_list('abc') and is_list([97,98,99])
true
iex> to_string('abc')
"abc"
```

- `"abc"` : **바이너리 문자열(binary)**
- `'abc'` : **차리스트(charlist)**, 내부적으로 `[97, 98, 99]` (코드 포인트 리스트)

특징:

- 엘릭서에서는 **문자열 작업**은 거의 항상 `"binary"` 로 처리한다.
- 얼랭 일부 API와 I/O 함수는 **차리스트**를 기대한다.

예:

```elixir
iex> :io.format("Num=~p~n", [123])          # 포맷 문자열은 charlist로 취급
:ok
iex> :io.format(~c"Str=~s~n", [~c"hello"])  # ~c 시그릴로 charlist 리터럴
:ok
```

정리하면:

- “사람이 읽는 문자열” → 기본적으로 `"binary"` 를 사용
- 얼랭 I/O, 파일 경로, 일부 네트워크 API → 필요하면 `to_charlist/1` 로 변환

---

### 기본 연산의 비용 모델

단방향 연결 리스트의 연산 비용은 전통적인 교과서에서 다음과 같이 설명된다.

- **앞에 붙이기(prepend)**: `[x | xs]`
  - 포인터 1개만 새로 만들면 된다 →
    $$T_{\text{prepend}} = O(1)$$
- **뒤에 붙이기(append)**: `xs ++ [x]`
  - `xs`를 한 번 끝까지 복사해야 한다 →
    $$T_{\text{append}} = O(n)$$
- **인덱스 접근**: `Enum.at(xs, i)`
  - 머리부터 i번째까지 따라가야 한다 →
    $$T_{\text{index}} = O(n)$$
- **길이 구하기**: `length(xs)`
  - 매번 전체를 순회해야 한다 →
    $$T_{\text{length}} = O(n)$$

복잡도 표로 정리하면:

| 연산                  | 예시 코드            | 시간 복잡도 |
|----------------------|----------------------|------------|
| 앞에 붙이기          | `[x | xs]`           | \(O(1)\)   |
| 뒤에 붙이기          | `xs ++ [x]`          | \(O(n)\)   |
| 인덱스 접근          | `Enum.at(xs, i)`     | \(O(n)\)   |
| 길이 계산            | `length(xs)`         | \(O(n)\)   |
| 맵/필터/폴드         | `Enum.map/2` 등     | \(O(n)\)   |

따라서 리스트 처리의 철칙은:

> **“많이 붙인다 → 앞에 붙여서 누적 → 마지막에 뒤집는다(reverse)”**

라는 **reverse-append 패턴**이다.
뒤에 붙이는 `++` 을 루프 안에서 남용하면 쉽게 \(O(n^2)\) 로 악화된다.

---

### 실전: 머리/꼬리 패턴으로 분해 디버깅

머리/꼬리 패턴은 단순히 알고리즘 구현뿐 아니라, **디버깅**에도 유용하다.

```elixir
defmodule DebugList do
  def log_each([h | t]) do
    IO.puts("head=#{inspect(h)}, tail=#{inspect(t)}")
    log_each(t)
  end

  def log_each([]), do: :ok
end

DebugList.log_each([:a, :b, :c])
# head=:a, tail=[:b, :c]
# head=:b, tail=[:c]
# head=:c, tail=[]

```

- 각 단계에서 리스트가 어떻게 줄어드는지,
  어떤 형태로 들어오는지 바로 볼 수 있다.
- 패턴을 **두 절(진행/종료)** 로 나누는 습관은
  이후 7.2에서 재귀 함수들을 구현할 때 그대로 활용된다.

---

## 머리와 꼬리를 사용해 리스트 처리하기

핵심 아이디어는:

1. **머리/꼬리 패턴매칭**으로 리스트를 `[h | t]` 와 `[]` 로 나눈다.
2. **재귀**로 진행(머리를 처리하고 꼬리로 재귀)과 종료(빈 리스트)를 정의한다.
3. 누적기가 필요하면 **매개변수로 들고 다니며** 꼬리재귀로 만든다.

---

### 합계/최댓값: 재귀의 기본형

```elixir
defmodule L do
  # 합계: 누적기 없는 단순 재귀
  def sum([h | t]), do: h + sum(t)
  def sum([]), do: 0

  # 합계(권장): 누적기 + 꼬리재귀
  def sum_tr(xs), do: do_sum(xs, 0)
  defp do_sum([h | t], acc), do: do_sum(t, acc + h)
  defp do_sum([], acc), do: acc

  # 최댓값
  def max([h | t]), do: do_max(t, h)
  defp do_max([h | t], best) when h > best, do: do_max(t, h)
  defp do_max([_ | t], best), do: do_max(t, best)
  defp do_max([], best), do: best
end
```

- `sum/1` : 이해하기 쉽지만, 스택 프레임이 **n층** 쌓인다.
- `sum_tr/1` : 누적기 `acc` 를 들고 다니며 마지막 줄에서 바로 재귀 →
  BEAM이 **꼬리호출 최적화**를 적용할 수 있다.
- `max/1` : “진행 절(머리 비교)”과 “종료 절(더 이상 없음)”으로 딱 둘로 나눠져 있다.

꼬리재귀/일반재귀의 스택 사용 차이는 다음과 같이 생각할 수 있다.

$$
\text{일반 재귀} : O(n)\ \text{스택}, \qquad
\text{꼬리 재귀} : O(1)\ \text{스택}
$$

---

### map / filter / reduce 직접 구현

`Enum` 모듈이 어떻게 동작하는지 감을 잡기 위해, 직접 최소 버전을 구현해 보자.

```elixir
defmodule L2 do
  def map([h | t], f), do: [f.(h) | map(t, f)]
  def map([], _f), do: []

  def filter([h | t], p) do
    if p.(h), do: [h | filter(t, p)], else: filter(t, p)
  end
  def filter([], _p), do: []

  # 좌축약(foldl): 누적기가 앞에
  def reduce(xs, acc, f), do: do_reduce(xs, acc, f)
  defp do_reduce([h | t], acc, f), do: do_reduce(t, f.(acc, h), f)
  defp do_reduce([], acc, _f), do: acc
end

iex> L2.map([1,2,3], &(&1*2))
[2, 4, 6]
iex> L2.filter([1,2,3,4], &(rem(&1,2)==0))
[2, 4]
iex> L2.reduce([1,2,3], 0, &+/2)
6
```

설명:

- `map/2` : `[h | t]` 의 머리에 `f.(h)` 를 적용하고,
  나머지는 재귀 결과를 꼬리에 붙인다.
- `filter/2` : `p.(h)` 가 참이면 `[h | ...]`, 아니면 건너뛰고 꼬리만 재귀.
- `reduce/3` : 누적기 `acc` 를 들고 다니며,
  각 단계에서 `f.(acc, h)` 로 새로운 acc 를 만든다.

이 패턴을 이해하면 **대부분의 리스트 집계/변환**은 reduce로 수렴한다는 걸 체감하게 된다.

---

### take / drop / take_while / split

부분 리스트를 다루는 기본 함수들도 머리/꼬리 패턴으로 쉽게 구현할 수 있다.

```elixir
defmodule L3 do
  def take([h | t], n) when n > 0, do: [h | take(t, n - 1)]
  def take(_, 0), do: []
  def take([], _), do: []

  def drop([_ | t], n) when n > 0, do: drop(t, n - 1)
  def drop(xs, _), do: xs

  def take_while([h | t], p) do
    if p.(h), do: [h | take_while(t, p)], else: []
  end
  def take_while([], _), do: []

  def split(xs, n), do: {take(xs, n), drop(xs, n)}
end
```

- `take/2` : 앞에서 n개를 가져와 새 리스트 생성
- `drop/2` : 앞에서 n개를 버리고 나머지 반환
- `take_while/2` : 조건이 참인 동안만 가져오기
- `split/2` : `take`와 `drop` 결과를 한 번에 튜플로 반환

---

### zip / unzip / intersperse

두 리스트를 **쌍으로 묶거나**, 쌍의 리스트를 다시 두 리스트로 분리하는 것도 쉽게 표현된다.

```elixir
defmodule L4 do
  def zip([a | as], [b | bs]), do: [{a, b} | zip(as, bs)]
  def zip(_, _), do: []

  def unzip([{a, b} | t]) do
    {as, bs} = unzip(t)
    {[a | as], [b | bs]}
  end
  def unzip([]), do: {[], []}

  def intersperse([h | t], sep), do: [h | do_intersperse(t, sep)]
  def intersperse([], _), do: []

  defp do_intersperse([h | t], sep), do: [sep, h | do_intersperse(t, sep)]
  defp do_intersperse([], _), do: []
end
```

- `zip/2` : 같은 인덱스끼리 `{a, b}` 튜플로 묶는다.
- `unzip/1` : `{a, b}` 튜플 리스트를 두 리스트로 다시 나눈다.
- `intersperse/2` : 리스트 사이사이에 구분자(sep)를 끼워 넣는다.

자주 쓰는 실전 예:

```elixir
# 헤더 리스트를 "k=v" 쌍으로 만들고, "&" 로 조인하기

headers = [{"a", "1"}, {"b", "2"}]

headers
|> Enum.map(fn {k, v} -> [k, "=", v] end)
|> Enum.intersperse("&")
|> :erlang.iolist_to_binary()
# "a=1&b=2"

```

---

### any / all / find / count

검색/조건 체크 계열 함수도 전부 머리/꼬리 재귀 패턴으로 정리된다.

```elixir
defmodule L5 do
  def any?([h | t], p), do: p.(h) or any?(t, p)
  def any?([], _), do: false

  def all?([h | t], p), do: p.(h) and all?(t, p)
  def all?([], _), do: true

  def find([h | t], p), do: if(p.(h), do: {:ok, h}, else: find(t, p))
  def find([], _), do: :error

  def count(xs, p), do: do_count(xs, p, 0)
  defp do_count([h | t], p, acc), do: do_count(t, p, if(p.(h), do: acc + 1, else: acc))
  defp do_count([], _p, acc), do: acc
end
```

- `any?/2` : 하나라도 조건을 만족하면 곧바로 `true`
- `all?/2` : 하나라도 실패하면 곧바로 `false`
- `find/2` : 첫 번째 매칭 원소를 찾으면 즉시 반환
- `count/2` : 조건을 만족하는 원소 개수 세기

단축 평가(short-circuit) 패턴:

- `or` : 왼쪽이 참이면 오른쪽은 평가하지 않는다.
- `and` : 왼쪽이 거짓이면 오른쪽은 평가하지 않는다.

이 때문에 `any?/2`, `all?/2` 모두 “필요 최소한의 원소”만 검사하고 끝난다.

---

### 정렬 스케치: 삽입 정렬(교육용)

실무에서는 내장 `Enum.sort/2` 또는 `:lists.sort/1` 을 쓰지만,
리스트 재귀 패턴을 익히기에 삽입 정렬은 좋은 예제다.

```elixir
defmodule L6 do
  def isort(xs), do: do_isort(xs, [])
  defp do_isort([h | t], acc), do: do_isort(t, insert(h, acc))
  defp do_isort([], acc), do: acc

  defp insert(x, [h | t]) when x > h, do: [h | insert(x, t)]
  defp insert(x, xs), do: [x | xs]
end

iex> L6.isort([3,1,4,2])
[1,2,3,4]
```

- `acc` 는 “이미 정렬된 리스트”
- 새로운 원소 `x` 를 정렬된 리스트에 삽입하는 `insert/2`
  → 삽입 위치 전까지는 그대로 유지, 그 위치에 `x` 삽입

복잡도는 \(O(n^2)\) 이지만, **재귀/패턴**을 맛보기에는 좋은 예시다.

---

### Enum/Stream과의 연결

지금까지 구현한 `sum/map/filter/reduce` 등을 보면,
모두 “리스트 한 번 순회”라는 공통 구조를 가진다.

내장 `Enum` 모듈은:

- 리스트, 맵, 범위, 파일 스트림 등 **열거 가능한 것**을 추상화하여,
- `map`, `filter`, `reduce`, `sort`, `group_by` 등 고급 연산을 제공한다.

실제 구현도 크게 다르지 않다.

```elixir
Enum.map([1,2,3], &(&1 * 2))
Enum.filter(1..10, &(rem(&1, 2) == 0))
Enum.reduce(1..100, 0, &+/2)
```

`Stream` 모듈은:

- 같은 패턴을 **지연 평가(lazy)** 로 구현해 메모리 사용을 줄인다.
- 리스트 크기가 아주 크거나, 무한 스트림(예: 파일, 네트워크)을 다룰 때 유용하다.

---

### 테스트/디버깅

리스트 재귀 함수는 “한 단계씩 내려가며 상태가 어떻게 바뀌는지” 보는 게 중요하다.

```elixir
defmodule DebugSum do
  def sum(xs), do: do_sum(xs, 0)

  defp do_sum([h | t], acc) do
    IO.inspect({h, acc}, label: "step")
    do_sum(t, acc + h)
  end

  defp do_sum([], acc), do: acc
end

DebugSum.sum([1,2,3])
# step: {1, 0}
# step: {2, 1}
# step: {3, 3}
# => 6

```

간단한 ExUnit 테스트:

```elixir
defmodule LTest do
  use ExUnit.Case, async: true

  test "sum_tr equals Enum.sum" do
    xs = Enum.to_list(1..10_000)
    assert L.sum_tr(xs) == Enum.sum(xs)
  end

  test "my map behaves like Enum.map" do
    xs = [1,2,3,4]
    assert L2.map(xs, &(&1 * 3)) == Enum.map(xs, &(&1 * 3))
  end
end
```

---

## 머리와 꼬리를 사용해 리스트 만들기

이번에는 “리스트를 **만드는 쪽**”에 초점을 맞춘다.

- 단순한 경우: **범위, 컴프리헨션**
- 많은 원소: **prepend + reverse**
- 문자열/바이너리: **iodata**
- 자료구조: **두 리스트로 큐 만들기**
- 집계/그루핑: **맵 생성**

---

### 단순 생성: 범위·컴프리헨션

```elixir
iex> for i <- 1..5, do: i * 2
[2, 4, 6, 8, 10]

iex> for {k, v} <- [a: 1, b: 2], do: {k, v * v}
[a: 1, b: 4]
```

- 범위 `1..5` : 내부적으로는 “start..end” 형태의 Range 구조체지만,
  `for` 에서 순회되면서 리스트를 만든다.
- 리스트 컴프리헨션은 **수학의 집합 내포 표기**와 비슷하게
  “생성기 + 조건 + 변환”으로 리스트를 만든다.

조금 더 복잡한 예:

```elixir
# 1~10 사이에서 짝수이고 제곱이 20보다 작은 것만

iex> for x <- 1..10, rem(x, 2) == 0, x * x < 20, do: {x, x*x}
[{2,4},{4,16}]
```

패턴:

```elixir
for pattern <- enumerable, guard1, guard2, do: expression
```

- `pattern` : 각각의 요소를 어떻게 바인딩할지
- `guard` : 필터 조건
- `expression` : 최종 리스트의 원소가 될 값

---

### prepend → reverse 패턴

많은 원소를 만들 때는 **앞에 붙인 뒤(reverse)** 마지막에 한 번만 뒤집는다.

```elixir
defmodule Build do
  def upto(n) when n >= 1, do: do_upto(n, []) |> :lists.reverse()

  defp do_upto(1, acc), do: [1 | acc]
  defp do_upto(k, acc), do: do_upto(k - 1, [k | acc])
end

iex> Build.upto(5)
[1, 2, 3, 4, 5]
```

- `do_upto/2` 는 `[n, n-1, ..., 1]` 순서로 **앞에 붙이며** 만든다.
- 마지막에 `:lists.reverse/1` 로 뒤집어서 `[1,2,...,n]` 을 만든다.

반대로 하면 어떻게 되나?

```elixir
def bad_upto(n) do
  Enum.reduce(1..n, [], fn i, acc -> acc ++ [i] end)
end
```

- 매 단계마다 `acc ++ [i]` 는 왼쪽 리스트 `acc` 를 복사한다.
- 전체 비용은 대략:

$$
T(n) \approx 1 + 2 + \dots + n = O(n^2)
$$

- n 이 커질수록 급격히 느려진다.

---

### 문자열/바이너리 생성은 iodata로

문자열은 기본적으로 **바이너리**이기 때문에, 반복해서 `<>` 로 이어 붙이면 매번 새 바이너리가 생성된다.

더 나은 패턴: **iodata (중첩 리스트 + 바이너리)** 로 모아두고 마지막에만 선형화.

```elixir
defmodule HTML do
  def list(items) do
    [
      "<ul>\n",
      Enum.map(items, fn it -> ["  <li>", it, "</li>\n"] end),
      "</ul>\n"
    ]
    |> :erlang.iolist_to_binary()
  end
end

iex> HTML.list(["A", "B"])
"<ul>\n  <li>A</li>\n  <li>B</li>\n</ul>\n"
```

장점:

- 리스트를 연결하는 것은 포인터만 조정하면 되므로 비용이 싸다.
- 마지막에 `iolist_to_binary/1` 가 전체 구조를 **한 번만** 순회하면서 바이너리를 만든다.
- 이 패턴은 미국/유럽권 고성능 서버 코드에서도 일반적으로 쓰이는 패턴과 같다
  (웹 서버, 프록시, 로그 포맷터, 템플릿 엔진 등).

---

### 큐(queue) 만들기: 두 리스트 기법

단방향 리스트에서 **큐**를 직접 만들면 문제가 생긴다.

```elixir
defmodule BadQueue do
  def new, do: []

  def enqueue(q, x), do: q ++ [x]    # O(n)

  def dequeue([h | t]), do: {:ok, h, t}
  def dequeue([]), do: :empty
end
```

- `enqueue/2` 가 `q ++ [x]` 를 사용 → 매번 `q` 복사 → 평균 \(O(n)\)
- 원소를 많이 넣으면 심각하게 느려진다.

해결책: **두 리스트 큐(two-list queue)**.

```elixir
defmodule Queue do
  defstruct in: [], out: []

  def new, do: %__MODULE__{}

  # enqueue: in 리스트 앞에 붙이기 (O(1))
  def enqueue(%__MODULE__{in: i} = q, x), do: %__MODULE__{q | in: [x | i]}

  # dequeue: out에 있으면 out에서 빼기
  def dequeue(%__MODULE__{out: [h | t]} = q),
    do: {:ok, h, %__MODULE__{q | out: t}}

  # out이 비어 있으면 in을 뒤집어서 out으로
  def dequeue(%__MODULE__{in: i, out: []} = q) do
    case :lists.reverse(i) do
      [h | t] -> {:ok, h, %__MODULE__{in: [], out: t}}
      [] -> :empty
    end
  end
end

q =
  Queue.new()
  |> Queue.enqueue(1)
  |> Queue.enqueue(2)
  |> Queue.enqueue(3)

{:ok, x, q2} = Queue.dequeue(q)   # x == 1
```

- 대부분의 `enqueue` 는 O(1)
- `dequeue` 중 일부에서만 `reverse` 비용이 발생
- 전체적으로 **평균 \(O(1)\)** 연산

이 기법은 함수형 언어에서 큐를 구현할 때 **전형적인 패턴**이다.

---

### 집계/그루핑 만들기: frequencies/1 수제 구현

리스트 → 맵(집계 결과) 변환도 머리/꼬리 기반 재귀로 쉽게 구현된다.

```elixir
defmodule BuildMap do
  def freq(xs), do: do_freq(xs, %{})

  defp do_freq([h | t], acc),
    do: do_freq(t, Map.update(acc, h, 1, &(&1 + 1)))

  defp do_freq([], acc), do: acc
end

iex> BuildMap.freq(~w(a a b c c c))
%{"a" => 2, "b" => 1, "c" => 3}
```

- `Map.update/4` 를 이용해 “없으면 1, 있으면 +1” 패턴을 구현
- 내장 `Enum.frequencies/1` 도 비슷한 패턴을 따른다.

그루핑(group_by)도 비슷하게 만들 수 있다.

```elixir
defmodule Group do
  def by(xs, f), do: do_by(xs, f, %{})

  defp do_by([h | t], f, acc) do
    key = f.(h)
    acc = Map.update(acc, key, [h], &[h | &1])
    do_by(t, f, acc)
  end

  defp do_by([], _f, acc) do
    # 각 그룹의 리스트를 reverse 해서 원래 순서로 맞춘다
    acc
    |> Enum.map(fn {k, vs} -> {k, :lists.reverse(vs)} end)
    |> Map.new()
  end
end

iex> Group.by(["apple", "avocado", "banana"], &String.first/1)
%{"a" => ["apple", "avocado"], "b" => ["banana"]}
```

- 각 키별로 리스트를 **머리에 붙이기**로 누적한 후,
  마지막에 `reverse` 해서 순서를 복원.

---

### 리스트 컴프리헨션: 여러 생성기/조건

리스트 컴프리헨션은 여러 생성기와 조건을 사용해 복잡한 리스트를 간결하게 만든다.

```elixir
# 데카르트 곱 + 조건

iex> for x <- 1..5, y <- 1..5, x * y <= 8, do: {x, y}
[{1,1},{1,2},{1,3},{1,4},{1,5},{2,1},{2,2},{2,3},{3,1},{3,2},{4,1}]
```

이 코드는 다음과 같은 중첩 루프와 동치다:

```elixir
result =
  1..5
  |> Enum.flat_map(fn x ->
    1..5
    |> Enum.filter(fn y -> x * y <= 8 end)
    |> Enum.map(fn y -> {x, y} end)
  end)
```

컴프리헨션을 이해할 때도 머리/꼬리 관점이 유용하다.

- 내부 구현은 결국 “입력 열거 가능 객체를 하나씩 꺼내서 → 조건 검사 → 출력 리스트에 붙임”
- 즉, `map + filter` 의 한 줄 표기법이다.

---

### 재귀 생성기: 피보나치/슬라이딩 윈도우

#### 피보나치 리스트 생성

```elixir
defmodule Gen do
  def fib(n) when n >= 2, do: do_fib(n, 0, 1, []) |> :lists.reverse()

  defp do_fib(0, _a, _b, acc), do: acc
  defp do_fib(k, a, b, acc), do: do_fib(k - 1, b, a + b, [a | acc])
end

iex> Gen.fib(6)
[0,1,1,2,3,5]
```

- `a`, `b` 가 각각 “현재 항”과 “다음 항”
- 리스트는 `[a_n, ..., a_0]` 순으로 앞에 붙여지고, 마지막에 reverse

#### 슬라이딩 윈도우

```elixir
defmodule Window do
  def windows([a,b | t], 2), do: [[a, b] | windows([b | t], 2)]
  def windows([_], 2), do: []
  def windows([], 2), do: []
end

iex> Window.windows([1,2,3,4], 2)
[[1,2],[2,3],[3,4]]
```

- 크기가 2인 윈도우 예시
- 더 일반적인 `k`에 대한 구현도 마찬가지로 머리/꼬리 재귀로 확장할 수 있다.

---

### 실전 미니 프로젝트: 텍스트 파이프라인

요구: 문자열을 토큰 리스트로 만들고, 길이 기준으로 필터링, 빈도 순으로 나열.

```elixir
defmodule Text do
  def run(str, min_len \\ 2) do
    str
    |> normalize()
    |> tokenize()
    |> Enum.filter(&(byte_size(&1) >= min_len))
    |> Enum.frequencies()
    |> Enum.sort_by(fn {_k, v} -> -v end)
    |> Enum.map(fn {k, v} -> [k, ":", Integer.to_string(v), "\n"] end)
    |> :erlang.iolist_to_binary()
  end

  defp normalize(s) when is_binary(s),
    do: s |> String.downcase() |> String.replace(~r/[^a-z0-9\s]/, "")

  defp normalize(_), do: ""

  defp tokenize(s), do: String.split(s, ~r/\s+/, trim: true)
end

Text.run("Hello hello HELLO world!")
# hello:3
# world:1

```

내부 단계 대부분이 **리스트 변환**이다:

1. `normalize/1` : 문자열 → 정제된 문자열
2. `tokenize/1` : 문자열 → 단어 리스트
3. `filter` : 기준 길이 이상 단어만
4. `frequencies` : 단어 → 등장 횟수 맵
5. `sort_by` : 등장 횟수 기준 정렬
6. `map` + `iolist_to_binary` : 결과를 텍스트 리포트로 직렬화

이 예시는 7장에서 다룬 거의 모든 기법(머리/꼬리, 리스트 변환, iodata)을 한 번에 사용한다.

---

### 리스트 조작 비용 모델(정리)

리스트 기반 변환 파이프라인의 총 비용을,
각 단계의 선형 비용 합으로 근사하면 다음과 같다.

$$
T_{\text{pipeline}} \approx \sum_{i=1}^{k} c_i \cdot n_i
$$

- \(n_i\) : i번째 단계에서 처리하는 리스트 길이
- \(c_i\) : 각 단계의 상수 계수(한 원소를 처리하는 비용)

필터링/그루핑으로 길이가 줄어들면 이후 단계 비용이 감소한다.

반면, 특히 조심해야 할 `++` 남용은:

$$
\begin{aligned}
T(n)
&= \sum_{i=1}^{n} O(i) \\
&= O(1 + 2 + \dots + n) \\
&= O(n^2)
\end{aligned}
$$

이므로, 많은 원소를 생성/변환할 때는 항상:

- **prepend + reverse**
- 문자열은 **iodata + iolist_to_binary**

패턴을 우선적으로 고려해야 한다.

---

## 연습 문제

1. **`flat_map/2` 구현**

   - 입력: 리스트 `xs` 와 함수 \(f: a \to [b]\)
   - 출력: `xs` 의 각 요소에 `f`를 적용한 후, 결과 리스트들을 평탄화한 리스트
   - 예: `flat_map([1,2,3], &([&1, &1*10]))` → `[1,10,2,20,3,30]`

2. **`chunk_every/2` 구현**

   - 입력: 리스트 `xs`, 정수 `k`
   - 출력: 크기 `k` 인 청크들로 나눈 리스트의 리스트
     예: `chunk_every([1,2,3,4,5], 2)` → `[[1,2],[3,4],[5]]`

3. **`dedup/1` 구현**

   - 인접한 동일 원소를 한 개로 축약
     예: `[a,a,b,b,b,c] → [a,b,c]`

4. **두 리스트 큐에 `peek/1` 추가**

   - 비어 있으면 `:empty`, 아니면 `{:ok, front}` 반환

5. **`merge_sorted/2` 구현**

   - 정렬된 두 리스트 `xs`, `ys` 를 받아
     합쳐도 정렬된 리스트를 반환
     (병합 정렬의 merge 단계)

---

## 7장 요약

- **7.1 머리/꼬리**
  - 엘릭서 리스트는 단방향 연결 리스트다.
  - `[h | t]` 패턴으로 머리와 꼬리를 분해하고,
    빈 리스트 `[]`를 기반 케이스로 삼는다.
  - 앞에 붙이기는 \(O(1)\), 뒤에 붙이기는 \(O(n)\) 이라는 비용 모델을 항상 의식해야 한다.

- **7.2 리스트 처리**
  - 재귀 함수는 “진행 절”과 “종료 절”을 분리해 작성한다.
  - `sum/max/map/filter/reduce/take/drop/zip/any/all/find` 등
    대부분의 리스트 알고리즘은 머리/꼬리 + 재귀 + 누적기로 구현할 수 있다.
  - 꼬리재귀로 만들면 공간 복잡도를 \(O(1)\) 수준으로 유지할 수 있다.

- **7.3 리스트 생성**
  - 많은 원소를 생성할 때는 **prepend + reverse** 패턴을 사용한다.
  - 문자열/바이너리는 **iodata** 로 모아두고 마지막에 `iolist_to_binary/1` 로 직렬화한다.
  - 두 리스트 큐, 집계/그루핑, 슬라이딩 윈도우 등 실용적인 자료구조/알고리즘도
    전부 머리/꼬리에서 출발한다.

이 장을 충분히 연습하면, `Enum` 과 `Stream` 이 제공하는 거의 모든 함수의 **내부 동작**을 상상할 수 있게 된다.
그 상태에서 코드를 작성하면 “이 연산이 실제로는 리스트를 몇 번 순회하는지”,
“어디에서 메모리 비용이 터질지”를 자연스럽게 생각하게 되고,
조금 더 큰 규모의 데이터/서비스에서 성능과 가독성 사이의 균형을 잡기 쉬워진다.
