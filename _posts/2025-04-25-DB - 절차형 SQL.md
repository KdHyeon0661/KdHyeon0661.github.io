---
layout: post
title: DB - 절차형 SQL
date: 2025-04-25 20:20:23 +0900
category: DB
---
# 절차형 SQL (Procedural SQL: PL/SQL, T-SQL, PL/pgSQL, MySQL)

## 절차형 SQL 사용 여부 결정 가이드

절차형 SQL을 사용할지 여부를 결정하기 전에 다음 질문들을 스스로에게 던져보세요:

| 고려사항 | 예/아니오 | 권장 방향 |
|---|---|---|
| 비즈니스 로직이 데이터베이스와 "매우 가까이" 있어야 하는가? (감사 추적, 데이터 무결성, 권한 관리, 데이터 마스킹 등) | 예 | **데이터베이스 내부(프로시저/트리거/UDF)** 고려 |
| 대용량 벌크 처리나 야간 배치 작업에서 **네트워크 왕복 횟수**를 최소화해야 하는가? | 예 | 서버 측 **배치 프로시저** 권장 |
| 비즈니스 규칙 변경이 빈번하고 애플리케이션 배포 주기와 **독립적**으로 관리되어야 하는가? | 예 | 프로시저나 패키지로 캡슐화하고 **버전 관리** 적용 |
| 해당 로직이 단일 집합 연산 SQL 문으로 구현 가능한가? | 예 | **절차형 SQL 지양**, 단일 SQL 문으로 해결 |
| 행 단위 루프나 커서를 피할 수 있는가? | 예 | **집합 지향 접근법**으로 재작성 우선 |

**핵심 원칙**: 가능하다면 항상 **집합 지향(set-based)** 접근법을 먼저 고려하세요. 절차형 SQL은 **데이터와 밀접한 로직**과 **네트워크 왕복 최소화**가 필요한 경우에 사용하세요.

---

## 주요 데이터베이스별 절차형 SQL 문법 비교

### 블록 구조와 기본 요소

#### Oracle PL/SQL 예시
```sql
DECLARE
  employee_count NUMBER := 0;
  highest_salary_employee VARCHAR2(100);
BEGIN
  -- 데이터 조회 및 변수에 할당
  SELECT COUNT(*), MAX(employee_name) INTO employee_count, highest_salary_employee
  FROM employees WHERE department_id = 10;

  -- 조건문 처리
  IF employee_count > 10 THEN
    DBMS_OUTPUT.PUT_LINE('부서 10에는 직원이 너무 많습니다: ' || employee_count);
  ELSE
    DBMS_OUTPUT.PUT_LINE('부서 10 직원 수: ' || employee_count);
  END IF;
EXCEPTION
  -- 예외 처리
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('데이터를 찾을 수 없습니다.');
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('오류 발생: ' || SQLERRM);
END;
/
```

#### SQL Server T-SQL 예시
```sql
DECLARE @employee_count INT = 0;
DECLARE @highest_salary_employee NVARCHAR(100);

-- 데이터 조회 및 변수 할당
SELECT @employee_count = COUNT(*), @highest_salary_employee = MAX(employee_name)
FROM dbo.employees WHERE department_id = 10;

-- 조건문 처리
IF @employee_count > 10
  PRINT CONCAT('부서 10에는 직원이 너무 많습니다: ', @employee_count);
ELSE
  PRINT CONCAT('부서 10 직원 수: ', @employee_count);
```

#### PostgreSQL PL/pgSQL 예시
```sql
DO $$
DECLARE
  employee_count INT := 0;
  highest_salary_employee TEXT;
BEGIN
  -- 데이터 조회 및 변수에 할당
  SELECT COUNT(*), MAX(employee_name) INTO employee_count, highest_salary_employee
  FROM employees WHERE department_id = 10;

  -- 조건문 처리
  IF employee_count > 10 THEN
    RAISE NOTICE '부서 10에는 직원이 너무 많습니다: %', employee_count;
  ELSE
    RAISE NOTICE '부서 10 직원 수: %', employee_count;
  END IF;
END $$;
```

#### MySQL 저장 프로시저 예시
```sql
DELIMITER //
CREATE PROCEDURE department_employee_summary()
BEGIN
  DECLARE employee_count INT DEFAULT 0;
  DECLARE highest_salary_employee VARCHAR(100);

  -- 데이터 조회 및 변수 할당
  SELECT COUNT(*), MAX(employee_name) INTO employee_count, highest_salary_employee
  FROM employees WHERE department_id = 10;

  -- 조건문 처리
  IF employee_count > 10 THEN
    SELECT CONCAT('부서 10에는 직원이 너무 많습니다: ', employee_count) AS message;
  ELSE
    SELECT CONCAT('부서 10 직원 수: ', employee_count) AS message;
  END IF;
END;
//
DELIMITER ;
```

---

## 조건문, 반복문, 예외처리 패턴

### 조건문 처리

모든 주요 데이터베이스는 `IF...ELSIF...ELSE`와 `CASE` 구문을 지원합니다.

#### PL/SQL CASE 구문 예시
```sql
DECLARE
  employee_count NUMBER := 15;
  department_status VARCHAR2(20);
BEGIN
  CASE
    WHEN employee_count = 0  THEN department_status := '비어있음';
    WHEN employee_count < 10 THEN department_status := '소규모';
    ELSE department_status := '대규모';
  END CASE;
  
  DBMS_OUTPUT.PUT_LINE('부서 상태: ' || department_status);
END;
/
```

### 반복문과 커서 사용

**중요 원칙**: 가능하면 **커서와 루프 대신 집합 연산**(MERGE, UPDATE...FROM, INSERT...SELECT)을 사용하세요. 커서는 외부 서비스 호출이나 복잡한 비즈니스 규칙 처리 등 특수한 경우에만 사용하세요.

#### PL/SQL 커서 사용 예시 (가능하면 피하세요)
```sql
DECLARE
  CURSOR employee_cursor IS 
    SELECT employee_id, current_salary 
    FROM employees 
    WHERE department_id = 10;
  employee_record employee_cursor%ROWTYPE;
BEGIN
  OPEN employee_cursor;
  LOOP
    FETCH employee_cursor INTO employee_record;
    EXIT WHEN employee_cursor%NOTFOUND;

    -- 행 단위 처리 (비효율적)
    UPDATE employees 
    SET current_salary = employee_record.current_salary * 1.05 
    WHERE employee_id = employee_record.employee_id;
  END LOOP;
  CLOSE employee_cursor;
END;
/
```

#### 권장하는 집합 지향 대안
```sql
-- 단일 SQL 문으로 모든 직원 급여 인상
UPDATE employees
SET current_salary = current_salary * 1.05
WHERE department_id = 10;
```

### 예외처리 패턴

#### PL/SQL 예외처리
```sql
BEGIN
  -- 위험한 작업 수행
  SELECT salary INTO v_salary FROM employees WHERE employee_id = 999;
  
  -- 정상 처리
  DBMS_OUTPUT.PUT_LINE('급여: ' || v_salary);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    -- 데이터 없음 처리
    DBMS_OUTPUT.PUT_LINE('직원 정보를 찾을 수 없습니다.');
  WHEN TOO_MANY_ROWS THEN
    -- 키 무결성 문제
    DBMS_OUTPUT.PUT_LINE('중복된 직원 ID가 있습니다.');
  WHEN OTHERS THEN
    -- 기타 모든 예외
    DBMS_OUTPUT.PUT_LINE('시스템 오류: ' || SQLERRM);
    RAISE; -- 호출자에게 예외 전파
END;
/
```

#### SQL Server 예외처리
```sql
BEGIN TRY
  -- 위험한 작업 수행
  SELECT @salary = salary FROM dbo.employees WHERE employee_id = 999;
  
  -- 정상 처리
  PRINT CONCAT('급여: ', @salary);
END TRY
BEGIN CATCH
  DECLARE @error_message NVARCHAR(4000) = ERROR_MESSAGE();
  
  -- 오류 로깅
  INSERT INTO dbo.error_log(error_message, error_time) 
  VALUES (@error_message, SYSDATETIME());
  
  -- 호출자에게 예외 전파
  THROW;
END CATCH;
```

---

## 트랜잭션 관리와 저장점(Savepoint)

### 기본 원칙
- **하나의 논리적 작업 단위**는 하나의 트랜잭션으로 묶으세요.
- 부분 실패에 대비해 **저장점(SAVEPOINT)**을 활용한 부분 롤백을 설계하세요.

#### Oracle 트랜잭션 관리 예시
```sql
BEGIN
  -- 첫 번째 저장점
  SAVEPOINT before_main_update;
  
  -- 주요 업데이트 작업
  UPDATE employees SET salary = salary * 1.05 WHERE department_id = 10;
  
  -- 두 번째 저장점
  SAVEPOINT before_bonus_update;
  
  -- 추가 업데이트 작업
  UPDATE bonuses SET amount = amount * 1.10 WHERE department_id = 10;
  
  -- 조건부 롤백
  IF some_condition THEN
    ROLLBACK TO before_bonus_update; -- 보너스 업데이트만 취소
  END IF;
  
  -- 최종 커밋
  COMMIT;
END;
/
```

#### 자율 트랜잭션(감사 로깅용)
```sql
CREATE OR REPLACE PROCEDURE log_audit_event(p_message IN VARCHAR2) IS
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  -- 로깅 작업은 메인 트랜잭션과 독립적
  INSERT INTO audit_log(message, timestamp) 
  VALUES (p_message, SYSTIMESTAMP);
  
  COMMIT; -- 자율 트랜잭션 내에서 커밋
END log_audit_event;
/
```

---

## 대용량 데이터 처리 성능 패턴

### 집합 지향 접근법 우선 (MERGE/INSERT...SELECT/UPDATE...JOIN)

#### Oracle MERGE 예시
```sql
MERGE INTO target_table t
USING (SELECT id, value FROM source_table) s
ON (t.id = s.id)
WHEN MATCHED THEN 
  UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN 
  INSERT (id, value) VALUES (s.id, s.value);
```

#### PostgreSQL UPSERT 예시
```sql
INSERT INTO target_table(id, value)
SELECT id, value FROM source_table
ON CONFLICT (id) 
DO UPDATE SET value = EXCLUDED.value;
```

#### MySQL UPSERT 예시
```sql
INSERT INTO target_table(id, value)
SELECT id, value FROM source_table
ON DUPLICATE KEY UPDATE value = VALUES(value);
```

### PL/SQL 대용량 처리 (BULK 연산)
```sql
DECLARE
  -- 컬렉션 타입 정의
  TYPE employee_id_table IS TABLE OF employees.employee_id%TYPE;
  
  -- 컬렉션 변수 선언
  employee_ids employee_id_table;
BEGIN
  -- 대량 데이터 조회
  SELECT employee_id BULK COLLECT INTO employee_ids
  FROM employees 
  WHERE department_id = 10;
  
  -- 대량 업데이트 (단일 왕복)
  FORALL i IN 1..employee_ids.COUNT
    UPDATE employees 
    SET salary = salary * 1.05 
    WHERE employee_id = employee_ids(i);
    
  COMMIT;
END;
/
```

### SQL Server 테이블 값 매개변수(TVP) 사용
```sql
-- 사용자 정의 테이블 타입 생성
CREATE TYPE dbo.EmployeeIDList AS TABLE (
    employee_id INT PRIMARY KEY
);
GO

-- TVP를 사용하는 저장 프로시저
CREATE PROCEDURE dbo.update_employee_salaries
    @employee_ids dbo.EmployeeIDList READONLY
AS
BEGIN
    UPDATE e 
    SET e.salary = e.salary * 1.05
    FROM dbo.employees e
    INNER JOIN @employee_ids ids ON e.employee_id = ids.employee_id;
END;
GO
```

---

## 동적 SQL과 보안 고려사항

### 동적 SQL 사용 (SQL 인젝션 방지)

#### PL/SQL 바인드 변수 사용 예시
```sql
DECLARE
  dynamic_sql VARCHAR2(4000);
  salary_increase NUMBER := 1000;
  department_id NUMBER := 10;
BEGIN
  -- 바인드 변수를 사용한 안전한 동적 SQL
  dynamic_sql := 'UPDATE employees SET salary = salary + :1 WHERE department_id = :2';
  
  EXECUTE IMMEDIATE dynamic_sql USING salary_increase, department_id;
END;
/
```

#### SQL Server 안전한 동적 SQL
```sql
DECLARE @dynamic_sql NVARCHAR(MAX) = 
    N'UPDATE dbo.employees SET salary = salary + @increase WHERE department_id = @dept';
    
EXEC sp_executesql @dynamic_sql, 
    N'@increase INT, @dept INT', 
    @increase = 1000, 
    @dept = 10;
```

### 보안 설계 원칙

1. **최소 권한 원칙**: 각 프로시저에 필요한 최소한의 권한만 부여
2. **역할 기반 접근 제어**: 사용자별 권한 대신 역할에 권한 부여
3. **데이터 마스킹**: 민감 데이터는 뷰나 정책으로 보호
4. **권한 상승 주의**: `SECURITY DEFINER`나 `EXECUTE AS` 사용 시 감사 로깅 필수

#### PostgreSQL 보안 함수 예시
```sql
CREATE OR REPLACE FUNCTION secure_data_update()
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER  -- 함수 소유자의 권한으로 실행
SET search_path = public  -- 검색 경로 고정
AS $$
BEGIN
  -- 권한이 필요한 작업 수행
  UPDATE sensitive_data SET value = 'MASKED';
  
  -- 반드시 감사 로깅
  INSERT INTO audit_log(operation, user_name, timestamp)
  VALUES ('data_masking', current_user, now());
END $$;
```

---

## 트리거의 현명한 사용

트리거는 주로 감사 로깅, 데이터 표준화, 역정합 방지에 사용하고, 비즈니스 규칙 구현에는 지양하세요.

### Oracle 감사 트리거 예시
```sql
CREATE TABLE employee_audit (
    audit_id NUMBER GENERATED ALWAYS AS IDENTITY,
    employee_id NUMBER,
    action_performed VARCHAR2(10),
    performed_by VARCHAR2(30),
    performed_at TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE OR REPLACE TRIGGER trg_employee_audit
AFTER INSERT OR UPDATE OR DELETE ON employees
FOR EACH ROW
BEGIN
  INSERT INTO employee_audit(employee_id, action_performed, performed_by)
  VALUES (
    COALESCE(:NEW.employee_id, :OLD.employee_id),
    CASE 
      WHEN INSERTING THEN 'INSERT'
      WHEN UPDATING THEN 'UPDATE'
      WHEN DELETING THEN 'DELETE'
    END,
    USER
  );
END;
/
```

---

## 사용자 정의 함수(UDF) 설계 패턴

- **스칼라 UDF**: 행 단위 호출로 인한 성능 문제 가능성 → 가능하면 인라인으로 대체
- **테이블 반환 함수**: 조인 가능한 결과 집합 반환 → 성능 우수

### SQL Server 테이블 반환 함수 예시
```sql
CREATE FUNCTION dbo.get_active_orders(@customer_id INT)
RETURNS TABLE
AS
RETURN (
    SELECT order_id, order_date, total_amount
    FROM dbo.orders
    WHERE customer_id = @customer_id 
      AND order_status = 'ACTIVE'
);
GO

-- 사용 예시
SELECT * FROM dbo.get_active_orders(1001);
```

---

## 로깅, 감사, 오류 처리 표준화

### 표준 오류 로깅 테이블
```sql
CREATE TABLE application_errors (
    error_id INT IDENTITY PRIMARY KEY,
    error_time DATETIME DEFAULT GETDATE(),
    user_name VARCHAR(100),
    procedure_name VARCHAR(200),
    error_message NVARCHAR(MAX),
    error_severity INT,
    additional_data NVARCHAR(MAX)
);
```

### 표준화된 오류 처리 프로시저
```sql
CREATE PROCEDURE dbo.log_and_handle_error
    @procedure_name VARCHAR(200),
    @error_message NVARCHAR(MAX),
    @severity INT = 0,
    @additional_data NVARCHAR(MAX) = NULL
AS
BEGIN
    -- 오류 로깅
    INSERT INTO application_errors(
        user_name, 
        procedure_name, 
        error_message, 
        error_severity, 
        additional_data
    )
    VALUES (
        SUSER_SNAME(),
        @procedure_name,
        @error_message,
        @severity,
        @additional_data
    );
    
    -- 심각한 오류인 경우 상위로 전파
    IF @severity >= 10
        THROW 50000, @error_message, 1;
END;
GO
```

---

## 배치 작업 스케줄링

#### Oracle DBMS_SCHEDULER 예시
```sql
BEGIN
  DBMS_SCHEDULER.CREATE_JOB(
    job_name        => 'NIGHTLY_REPORT_GENERATION',
    job_type        => 'STORED_PROCEDURE',
    job_action      => 'reporting.generate_nightly_reports',
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY;BYHOUR=2;BYMINUTE=0',
    enabled         => TRUE,
    comments        => '매일 새벽 2시에 리포트 생성'
  );
END;
/
```

---

## 성능 최적화와 안티패턴 방지

| 안티패턴 | 위험 | 개선 방안 |
|---|---|---|
| 행 단위 커서로 대량 업데이트 | 대량 데이터에서 성능 급락 | 집합 연산(UPDATE, MERGE) 사용 |
| 스칼라 함수 과도 사용 | 행마다 호출 오버헤드 | 인라인 테이블 함수나 조인으로 대체 |
| 트리거 연쇄 의존성 | 디버깅 및 추적 어려움 | 핵심 로직만 트리거에, 규칙은 프로시저로 |
| 문자열 결합 동적 SQL | SQL 인젝션 위험 | 바인드 변수 사용 |
| 과도한 트랜잭션 범위 | 잠금 경합 증가 | 최소 범위 트랜잭션, 저장점 활용 |
| 예외 무시 또는 은폐 | 문제 진단 어려움 | 로깅 후 재전파, 표준 오류 코드 |

**성능 비교**: 
- 행 단위 루프: `T_loop ≈ n × (t_call + t_lookup)`
- 집합 연산: `T_set ≈ t_scan + t_join + t_write`
- 대체로 `T_set ≪ T_loop` (특히 데이터 양이 많을수록)

---

## 실전 예제: 월말 정산 시스템

### 요구사항
- 매월 말 고객별 결제 집계 및 할인 규칙 적용
- 1천만 건 규모 데이터, 야간 작업(02:00), 30분 내 완료 목표
- 감사 로깅 및 실패 시 재시도 메커니즘

### Oracle 구현 (요약)
```sql
CREATE OR REPLACE PACKAGE monthly_billing AS
  -- 로깅 프로시저 (자율 트랜잭션)
  PROCEDURE log_step(p_step VARCHAR2, p_message VARCHAR2);
  
  -- 주요 정산 프로시저
  PROCEDURE process_monthly_billing(p_month CHAR);
END monthly_billing;
/

CREATE OR REPLACE PACKAGE BODY monthly_billing AS
  PROCEDURE log_step(p_step VARCHAR2, p_message VARCHAR2) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO billing_audit_log(
        step_name, 
        message, 
        log_time, 
        user_name
    )
    VALUES (p_step, p_message, SYSTIMESTAMP, USER);
    COMMIT;
  END log_step;

  PROCEDURE process_monthly_billing(p_month CHAR) IS
    v_start_time TIMESTAMP := SYSTIMESTAMP;
  BEGIN
    -- 시작 로깅
    log_step('START', '월별 정산 시작: ' || p_month);
    
    -- 1단계: 중간 테이블에 데이터 적재
    INSERT /*+ APPEND */ INTO billing_staging(
        customer_id, 
        billing_month, 
        total_amount
    )
    SELECT 
        customer_id, 
        p_month, 
        SUM(transaction_amount)
    FROM customer_transactions
    WHERE TO_CHAR(transaction_date, 'YYYYMM') = p_month
    GROUP BY customer_id;
    
    -- 2단계: 할인 규칙 적용
    MERGE INTO billing_staging s
    USING customer_discounts d
    ON (s.customer_id = d.customer_id AND s.billing_month = p_month)
    WHEN MATCHED THEN 
      UPDATE SET s.total_amount = s.total_amount * (1 - d.discount_rate);
    
    -- 3단계: 최종 테이블에 반영
    MERGE INTO billing_final f
    USING (
        SELECT * FROM billing_staging 
        WHERE billing_month = p_month
    ) s
    ON (f.customer_id = s.customer_id AND f.billing_month = s.billing_month)
    WHEN MATCHED THEN 
      UPDATE SET f.total_amount = s.total_amount
    WHEN NOT MATCHED THEN 
      INSERT (customer_id, billing_month, total_amount)
      VALUES (s.customer_id, s.billing_month, s.total_amount);
    
    -- 완료 로깅
    log_step('COMPLETE', 
        '월별 정산 완료: ' || p_month || 
        ', 소요시간: ' || 
        ROUND((SYSTIMESTAMP - v_start_time) * 24 * 60, 2) || '분');
        
    COMMIT;
    
  EXCEPTION
    WHEN OTHERS THEN
      log_step('ERROR', '정산 오류: ' || SQLERRM);
      ROLLBACK;
      RAISE;
  END process_monthly_billing;
END monthly_billing;
/
```

---

## 테스트, 품질 관리, 배포 전략

### 단위 테스트 접근법
- 각 프로시저와 함수에 대한 입력-출력 검증 테스트 작성
- 경계값, 오류 조건, 정상 조건 모두 테스트
- 데이터베이스별 테스트 프레임워크 활용:
  - Oracle: utPLSQL
  - SQL Server: tSQLt
  - PostgreSQL: pgTap

### 마이그레이션 및 버전 관리
- 모든 데이터베이스 변경을 버전 관리
- 업그레이드/롤백 스크립트 준비
- Liquibase, Flyway 등의 마이그레이션 도구 활용

### 성능 모니터링
- 대표 데이터셋으로 성능 기준치 설정
- 실행 계획 분석 및 성능 회귀 테스트
- I/O, CPU, 메모리 사용량 모니터링

---

## 결론: 절차형 SQL의 현명한 활용

절차형 SQL은 현대 데이터베이스 시스템에서 여전히 중요한 역할을 합니다. 효과적으로 활용하기 위한 핵심 원칙은 다음과 같습니다:

1. **적절한 사용 판단**: 데이터와 밀접한 로직, 대량 처리, 감사 추적 등에 집중하고, 가능하면 집합 지향 SQL을 우선적으로 고려하세요.

2. **성능 최적화**: 행 단위 처리 대신 집합 연산을 사용하고, 대용량 처리는 벌크 연산이나 테이블 값 매개변수로 최적화하세요.

3. **보안과 안정성**: SQL 인젝션 방지를 위한 바인드 변수 사용, 최소 권한 원칙 적용, 철저한 예외 처리와 로깅을 구현하세요.

4. **유지보수성**: 명확한 네이밍 규칙, 주석, 표준화된 오류 처리, 버전 관리를 통해 코드의 장기적 유지보수성을 보장하세요.

5. **테스트와 모니터링**: 단위 테스트, 통합 테스트, 성능 테스트를 체계적으로 수행하고, 프로덕션 환경에서 지속적으로 모니터링하세요.

6. **데이터베이스 특성 이해**: 각 데이터베이스 시스템의 강점과 제약사항을 이해하고, 이식성이 필요한 경우 적절한 추상화 레이어를 설계하세요.

절차형 SQL은 단순히 "코드를 데이터베이스에 옮기는" 것이 아니라, 데이터 처리 패턴의 본질을 이해하고 최적의 아키텍처를 선택하는 것입니다. 올바르게 사용할 때, 절차형 SQL은 시스템의 성능, 보안, 유지보수성을 크게 향상시킬 수 있는 강력한 도구가 됩니다.

최종적으로, 기술적 결정은 항상 비즈니스 요구사항, 팀의 전문성, 시스템의 진화 경로를 종합적으로 고려하여 내려야 합니다. 절차형 SQL은 도구상자의 하나의 도구일 뿐이며, 가장 적합한 도구를 상황에 맞게 선택하는 것이 전문가의 역할입니다.