---
layout: post
title: DB - 절차형 SQL
date: 2025-04-25 20:20:23 +0900
category: DB
---
# 절차형 SQL (Procedural SQL: PL/SQL · T-SQL · PL/pgSQL · MySQL)

## 0. 절차형 SQL을 쓸지 말지, 빠른 판단 체크리스트

| 질문 | 예/아니오 | 지침 |
|---|---|---|
| 로직이 데이터에 “아주 가깝게” 있어야 하나? (감사/무결성/권한·마스킹) | 예 | **DB 내부(프로시저/트리거/UDF)** 후보 |
| 초대용량 벌크/정산/야간배치로 **네트워크 왕복**을 줄여야 하나? | 예 | 서버사이드 **배치 프로시저** 권장 |
| 규칙 변경이 잦고 어플리케이션 배포 주기와 **독립적**이어야 하나? | 예 | 프로시저/패키지로 캡슐화, **버전 태깅** |
| 로직이 표현형 SQL로 **순수 집합연산**으로 가능하나? | 예 | **절차형 지양**, SQL 한 문으로 해결 |
| 행 단위 루프/커서를 피할 수 있나? | 예 | **집합 지향**으로 재작성(우선) |

> 원칙: **집합 지향**(set-based)이 가능한지 먼저 본다. 절차형은 **데이터 근접 로직**과 **왕복 최소화**에 사용한다.

---

## 1. 공통 문법 패턴(엔진별 대조)

### 1.1 블록 구조 & 기본 요소

#### Oracle PL/SQL
```sql
DECLARE
  v_count NUMBER := 0;
  v_name  VARCHAR2(100);
BEGIN
  SELECT COUNT(*), MAX(ename) INTO v_count, v_name
  FROM emp WHERE deptno = 10;

  IF v_count > 10 THEN
    DBMS_OUTPUT.PUT_LINE('Too many rows: ' || v_count);
  ELSE
    DBMS_OUTPUT.PUT_LINE('OK: ' || v_count);
  END IF;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('No rows');
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Err: ' || SQLERRM);
END;
/
```

#### SQL Server T-SQL
```sql
DECLARE @count INT = 0, @name NVARCHAR(100);

SELECT @count = COUNT(*), @name = MAX(ename)
FROM dbo.emp WHERE deptno = 10;

IF @count > 10
  PRINT CONCAT('Too many rows: ', @count);
ELSE
  PRINT CONCAT('OK: ', @count);
```

#### PostgreSQL PL/pgSQL
```sql
DO $$
DECLARE
  v_count INT := 0;
  v_name  TEXT;
BEGIN
  SELECT COUNT(*), MAX(ename) INTO v_count, v_name
  FROM emp WHERE deptno = 10;

  IF v_count > 10 THEN
    RAISE NOTICE 'Too many rows: %', v_count;
  ELSE
    RAISE NOTICE 'OK: %', v_count;
  END IF;
END $$;
```

#### MySQL (Stored Program)
```sql
DELIMITER //
CREATE PROCEDURE demo_proc()
BEGIN
  DECLARE v_count INT DEFAULT 0;
  DECLARE v_name  VARCHAR(100);

  SELECT COUNT(*), MAX(ename) INTO v_count, v_name
  FROM emp WHERE deptno = 10;

  IF v_count > 10 THEN
    SELECT CONCAT('Too many rows: ', v_count) AS msg;
  ELSE
    SELECT CONCAT('OK: ', v_count) AS msg;
  END IF;
END;
//
DELIMITER ;
```

---

## 2. 제어구조(조건/반복) · 커서 · 예외처리

### 2.1 조건문(공통)
- `IF...ELSIF...ELSE` / `CASE` 구문은 네 엔진 모두 지원.

#### PL/SQL CASE
```sql
CASE
  WHEN v_count = 0  THEN v_flag := 'EMPTY';
  WHEN v_count < 10 THEN v_flag := 'FEW';
  ELSE v_flag := 'MANY';
END CASE;
```

#### T-SQL CASE (표현식)
```sql
SELECT CASE 
         WHEN @count = 0 THEN 'EMPTY'
         WHEN @count < 10 THEN 'FEW'
         ELSE 'MANY'
       END AS flag;
```

### 2.2 반복문 & 커서

> **원칙**: 가능하면 **커서 루프 대신 집합 연산**(MERGE, UPDATE...FROM, INSERT...SELECT)을 쓴다.  
> 예외: 외부 서비스 호출/복잡한 규칙 엔진/상호작용이 필요한 경우만 루프.

#### PL/SQL 명시/암시 커서
```sql
DECLARE
  CURSOR c_emp IS SELECT empno, sal FROM emp WHERE deptno = 10;
  r c_emp%ROWTYPE;
BEGIN
  OPEN c_emp;
  LOOP
    FETCH c_emp INTO r;
    EXIT WHEN c_emp%NOTFOUND;

    UPDATE emp SET sal = r.sal * 1.05 WHERE empno = r.empno;
  END LOOP;
  CLOSE c_emp;
END;
/
```

**대안(집합 지향)**:
```sql
UPDATE emp
SET sal = sal * 1.05
WHERE deptno = 10;
```

#### T-SQL 커서(피할 수 있으면 피하자)
```sql
DECLARE c CURSOR LOCAL FAST_FORWARD FOR
  SELECT empno, sal FROM dbo.emp WHERE deptno = 10;

DECLARE @empno INT, @sal DECIMAL(10,2);
OPEN c;
FETCH NEXT FROM c INTO @empno, @sal;
WHILE @@FETCH_STATUS = 0
BEGIN
  UPDATE dbo.emp SET sal = @sal * 1.05 WHERE empno = @empno;
  FETCH NEXT FROM c INTO @empno, @sal;
END
CLOSE c; DEALLOCATE c;
```

**대안**:
```sql
UPDATE e
SET sal = e.sal * 1.05
FROM dbo.emp AS e
WHERE e.deptno = 10;
```

### 2.3 예외처리

#### PL/SQL
```sql
BEGIN
  SELECT ... INTO v FROM t WHERE id = :id;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    -- 복구/대체값/로깅
  WHEN TOO_MANY_ROWS THEN
    -- 키 무결성 검사
  WHEN OTHERS THEN
    -- 로깅 후 RAISE
    RAISE;
END;
```

#### T-SQL
```sql
BEGIN TRY
  -- 위험 SQL
END TRY
BEGIN CATCH
  DECLARE @err NVARCHAR(4000) = ERROR_MESSAGE();
  -- 로깅 테이블에 기록
  INSERT dbo.err_log(msg, at) VALUES (@err, SYSDATETIME());
  THROW; -- 또는 RAISERROR
END CATCH;
```

#### PL/pgSQL
```sql
BEGIN
  PERFORM risky_op();
EXCEPTION
  WHEN unique_violation THEN
    RAISE NOTICE 'dup';
  WHEN OTHERS THEN
    RAISE USING MESSAGE = SQLERRM;
END;
```

#### MySQL
```sql
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
  -- 롤백/로깅
END;
```

---

## 3. 트랜잭션 & 저장점 & 자동/독립 트랜잭션

### 3.1 기본 규칙
- **하나의 논리 단위**는 하나의 트랜잭션으로 묶는다.
- 중간 실패에 대비하여 **SAVEPOINT**(부분 롤백)를 설계한다.

#### Oracle
```sql
BEGIN
  SAVEPOINT s1;
  UPDATE a ...;
  SAVEPOINT s2;
  INSERT b ...;

  IF something_bad THEN
    ROLLBACK TO s2; -- b만 취소
  END IF;

  COMMIT;
END;
/
```

**자율 트랜잭션(autonomous transaction)** — 로깅용(주의 깊게 사용)
```sql
CREATE OR REPLACE PROCEDURE log_event(p_msg IN VARCHAR2) IS
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  INSERT INTO app_log(msg, ts) VALUES (p_msg, SYSTIMESTAMP);
  COMMIT;
END;
/
```

#### T-SQL
```sql
BEGIN TRAN;
SAVE TRAN s1;

UPDATE a ...;
IF @@ERROR <> 0 BEGIN ROLLBACK TRAN; RETURN; END;

SAVE TRAN s2;
INSERT b ...;
IF @@ERROR <> 0 BEGIN ROLLBACK TRAN s2; END;

COMMIT TRAN;
```

#### PostgreSQL
- 함수 내 전체가 한 트랜잭션(서브트랜잭션은 `EXCEPTION` 블록 단위)
```sql
BEGIN;
SAVEPOINT s1;
-- ...
ROLLBACK TO SAVEPOINT s1;
COMMIT;
```

#### MySQL
```sql
START TRANSACTION;
SAVEPOINT s1;
-- ...
ROLLBACK TO SAVEPOINT s1;
COMMIT;
```

---

## 4. 대량처리 성능 패턴

### 4.1 집합 지향 우선 (MERGE/INSERT…SELECT/UPDATE…JOIN)

#### Oracle MERGE
```sql
MERGE INTO tgt t
USING (SELECT id, val FROM src) s
ON (t.id = s.id)
WHEN MATCHED THEN UPDATE SET t.val = s.val
WHEN NOT MATCHED THEN INSERT (id, val) VALUES (s.id, s.val);
```

#### SQL Server MERGE (주의: 오래된 버전 버그 이슈, 최신 누적 패치 권장)
```sql
MERGE dbo.tgt AS t
USING dbo.src AS s
ON (t.id = s.id)
WHEN MATCHED THEN UPDATE SET t.val = s.val
WHEN NOT MATCHED BY TARGET THEN INSERT (id, val) VALUES (s.id, s.val);
```

#### PostgreSQL `INSERT ... ON CONFLICT`
```sql
INSERT INTO tgt(id, val)
SELECT id, val FROM src
ON CONFLICT (id) DO UPDATE SET val = EXCLUDED.val;
```

#### MySQL `INSERT ... ON DUPLICATE KEY UPDATE`
```sql
INSERT INTO tgt(id, val)
SELECT id, val FROM src
ON DUPLICATE KEY UPDATE val = VALUES(val);
```

### 4.2 PL/SQL Bulk (대량 Fetch/Write)

```sql
DECLARE
  TYPE t_ids IS TABLE OF emp.empno%TYPE;
  l_ids t_ids;
BEGIN
  SELECT empno BULK COLLECT INTO l_ids
  FROM emp WHERE deptno = 10;

  FORALL i IN 1..l_ids.COUNT
    UPDATE emp SET sal = sal * 1.05 WHERE empno = l_ids(i);

  COMMIT;
END;
/
```

### 4.3 T-SQL TVP & 배치
- **Table-Valued Parameter**로 대량 파라미터 입력
```sql
-- 1) 타입
CREATE TYPE dbo.ID_LIST AS TABLE (id INT PRIMARY KEY);
GO
-- 2) 프로시저
CREATE PROCEDURE dbo.raise_salary
  @ids dbo.ID_LIST READONLY
AS
UPDATE e SET e.sal = e.sal * 1.05
FROM dbo.emp e JOIN @ids i ON e.empno = i.id;
GO
```

### 4.4 PostgreSQL COPY / MySQL LOAD DATA
- 대량 로드 시 **네이티브 로더**를 사용해 왕복 최소화
```sql
-- PostgreSQL
COPY emp FROM '/path/emp.csv' CSV HEADER;

-- MySQL
LOAD DATA INFILE '/path/emp.csv'
INTO TABLE emp
FIELDS TERMINATED BY ',' ENCLOSED BY '"'
IGNORE 1 LINES;
```

---

## 5. 동적 SQL · 보안(권한/마스킹) · RBAC

### 5.1 동적 SQL
- **필드/테이블 조건적 선택** 등에서 필요
- **바인드 변수**로 SQL 인젝션 방지

#### PL/SQL
```sql
DECLARE
  v_sql VARCHAR2(4000);
BEGIN
  v_sql := 'UPDATE emp SET sal = :1 WHERE deptno = :2';
  EXECUTE IMMEDIATE v_sql USING 1000, 10;
END;
/
```

#### T-SQL (sp_executesql)
```sql
DECLARE @sql NVARCHAR(MAX) = N'UPDATE dbo.emp SET sal = @inc WHERE deptno = @d';
EXEC sp_executesql @sql, N'@inc INT, @d INT', @inc=1000, @d=10;
```

#### PL/pgSQL
```sql
EXECUTE format('UPDATE emp SET sal = %L WHERE deptno = %s', 1000, 10);
```

### 5.2 보안 설계
- **역할(Role) 기반 부여**: DCL + 최소권한 원칙
- **마스킹/칼럼 가드**: 뷰/정책(Oracle VPD/FGAC, SQL Server Dynamic Data Masking, PG RLS)
- **권한 위임 주의**: `WITH GRANT OPTION`/`EXECUTE AS`/`SECURITY DEFINER`는 제한적으로

#### PostgreSQL SECURITY DEFINER (주의: 검사·로깅 동반)
```sql
CREATE OR REPLACE FUNCTION fn_secure(...)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- 권한 상승 작업
END $$;
```

---

## 6. 트리거 실무: 어디까지 쓸 것인가

| 트리거 유형 | 타이밍 | 예 |
|---|---|---|
| 행/문장 단위 | BEFORE/AFTER | 감사 로그, 표준화(대소문자/트림), 역정합 방지 |

> 지침: **비즈니스 규칙**을 트리거에 과도하게 넣지 말 것. **감사/무결성 최소화**에 사용.

### 예: 변경 이력(간단 감사)
#### Oracle
```sql
CREATE TABLE emp_audit(id NUMBER, who VARCHAR2(30), what VARCHAR2(30), at TIMESTAMP);

CREATE OR REPLACE TRIGGER trg_emp_audit
AFTER UPDATE OR INSERT OR DELETE ON emp
FOR EACH ROW
BEGIN
  INSERT INTO emp_audit(id, who, what, at)
  VALUES (NVL(:NEW.empno, :OLD.empno), USER,
          CASE WHEN INSERTING THEN 'I' WHEN UPDATING THEN 'U' ELSE 'D' END,
          SYSTIMESTAMP);
END;
/
```

#### SQL Server
```sql
CREATE TRIGGER dbo.trg_emp_audit ON dbo.emp
AFTER INSERT, UPDATE, DELETE
AS
INSERT dbo.emp_audit(id, who, what, at)
SELECT COALESCE(i.empno, d.empno), SUSER_SNAME(),
       CASE WHEN i.empno IS NOT NULL AND d.empno IS NULL THEN 'I'
            WHEN i.empno IS NOT NULL AND d.empno IS NOT NULL THEN 'U'
            ELSE 'D' END,
       SYSDATETIME()
FROM inserted i
FULL JOIN deleted d ON i.empno = d.empno;
```

---

## 7. 사용자 정의 함수(UDF): 스칼라 vs 테이블

- **스칼라 UDF**는 **행마다 호출** → 주의(병목). 가능하면 **인라인 TVF**(T-SQL) 또는 **SQL식/JOIN**으로 대체.
- **불변 함수**는 **계산된 컬럼/인덱스**로 재사용 검토.

### T-SQL 인라인 TVF(매우 효율적)
```sql
CREATE FUNCTION dbo.fn_active_orders(@cust INT)
RETURNS TABLE
AS RETURN
(
  SELECT o.*
  FROM dbo.orders o
  WHERE o.customer_id = @cust AND o.status = 'ACTIVE'
);
GO

-- 사용
SELECT * FROM dbo.fn_active_orders(1001);
```

### PostgreSQL set-returning function
```sql
CREATE OR REPLACE FUNCTION fn_active_orders(p_cust INT)
RETURNS TABLE (order_id INT, amount NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT id, amount FROM orders WHERE customer_id = p_cust AND status='ACTIVE';
END $$ LANGUAGE plpgsql;
```

---

## 8. 로깅/감사/에러표준

- **표준 오류 테이블**: `app_error(id, at, who, proc, msg, payload)`
- **일관된 RAISE/THROW** 정책: 사용자 오류/시스템 오류 구분, **메시지 코드** 부여
- 로그는 **비동기/경량**: Oracle 자율 트랜잭션, SQL Server Service Broker/외부 로거, PG NOTIFY 등 고려

#### T-SQL 에러 규약 예
```sql
BEGIN TRY
  -- ...
END TRY
BEGIN CATCH
  INSERT dbo.app_error(at, who, proc, msg)
  VALUES (SYSDATETIME(), SUSER_SNAME(), OBJECT_NAME(@@PROCID), ERROR_MESSAGE());
  THROW; -- 상위로 전파
END CATCH;
```

---

## 9. 스케줄링 & 배치

- **Oracle**: DBMS_SCHEDULER  
- **SQL Server**: SQL Server Agent(잡/스텝/스케줄)  
- **PostgreSQL**: `pg_cron` 확장 또는 외부 스케줄러  
- **MySQL**: Event Scheduler(간단 주기)

#### Oracle 예
```sql
BEGIN
  DBMS_SCHEDULER.CREATE_JOB(
    job_name => 'NIGHTLY_BILLING',
    job_type => 'STORED_PROCEDURE',
    job_action => 'billing.run_daily',
    start_date => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY;BYHOUR=2;BYMINUTE=0;BYSECOND=0',
    enabled => TRUE);
END;
/
```

---

## 10. 성능·안정성: 반(反)패턴과 리팩터링

| 반패턴 | 위험 | 리팩터링 |
|---|---|---|
| 행루프 커서로 대량 업데이트 | 수십만 행에서 급격히 느림 | 집합 UPDATE, MERGE, FORALL/TMP/TVP |
| 스칼라 UDF 남발 | 호출당 오버헤드 | 인라인 TVF/공통 테이블식/윈도우함수 |
| 트리거 다층 의존 | 추적 어려움/순환 | 핵심만(감사/무결성), 규칙은 뷰/프로시저로 |
| 동적 SQL에 문자열 결합 | 인젝션 | 바인딩/`sp_executesql`/format() |
| 트랜잭션 과대범위 | 잠금 경합/스필 | 최소 범위/저수준 저장점/분리 |
| 예외 삼키기 | 장애 은폐 | 로깅 후 재전파/표준 에러코드 |

**복잡도 감각**(루프 비용 대략치)  
반복 루프가 \(n\)행을 단건 호출로 처리하면 **왕복 + 인터프리트 비용**이 누적되어  
$$
T_{\text{loop}} \approx n \cdot (t_{\text{call}} + t_{\text{lookup}})
$$
반면 집합 연산은
$$
T_{\text{set}} \approx t_{\text{scan}} + t_{\text{join}} + t_{\text{write}}
$$
대체로 \(T_{\text{set}} \ll T_{\text{loop}}\) (특히 n이 클수록).

---

## 11. 이식성(Portability) 전략

- **도메인 레이어 분리**: 공통 SQL은 뷰/표준 SQL, 엔진 특화는 어댑터(패키지/스키마)로 캡슐화
- **조건부 컴파일**: Oracle(플래그), T-SQL(IF DBPROPERTY), PG(확장 유무), MySQL(버전 체크)로 분기
- **테스트 매트릭스**: 핵심 프로시저에 대해 엔진별 결과 동일성 테스트

---

## 12. 실전 미니 프로젝트 — “월말 정산 + 감사 + 재시도”

### 요구
- 매월 말 고객별 결제 집계, 할인 규칙, 실패 건 재시도, **감사 로그** 필수
- 1000만 건 규모 / 야간 02:00 / 30분 내 완료 목표

### 공통 설계
1) **집합 집계**로 고객/주문 월 합산 → 중간테이블 `billing_stage`  
2) **규칙 적용**: 할인 정책 테이블과 조인, 등급별 퍼센트  
3) **최종 반영**: `MERGE`/`UPSERT`  
4) **감사**: 시작/종료/성공수/실패수/실패 샘플 캡처  
5) **재시도**: 실패 PK 목록 저장 후 재실행 스텝

#### Oracle 패키지(요약)
```sql
CREATE OR REPLACE PACKAGE billing AS
  PROCEDURE run_month(p_ym IN CHAR);
END;
/
CREATE OR REPLACE PACKAGE BODY billing AS
  PROCEDURE log_msg(p_step VARCHAR2, p_msg VARCHAR2) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO billing_log(step, msg, ts) VALUES (p_step, p_msg, SYSTIMESTAMP);
    COMMIT;
  END;

  PROCEDURE run_month(p_ym IN CHAR) IS
  BEGIN
    log_msg('START', p_ym);

    -- 1) 스테이지 적재
    INSERT /*+ APPEND */ INTO billing_stage(cust_id, ym, amt)
    SELECT cust_id, p_ym, SUM(amount)
    FROM orders
    WHERE TO_CHAR(order_date,'YYYYMM') = p_ym
    GROUP BY cust_id;

    -- 2) 규칙 적용
    MERGE INTO billing_stage s
    USING discounts d
    ON (s.cust_id = d.cust_id AND s.ym = p_ym)
    WHEN MATCHED THEN UPDATE SET s.amt = s.amt * (1 - d.rate);

    -- 3) 최종 반영
    MERGE INTO billing_final f
    USING (SELECT * FROM billing_stage WHERE ym = p_ym) s
    ON (f.cust_id = s.cust_id AND f.ym = s.ym)
    WHEN MATCHED THEN UPDATE SET f.amt = s.amt
    WHEN NOT MATCHED THEN INSERT (cust_id, ym, amt) VALUES (s.cust_id, s.ym, s.amt);

    COMMIT;
    log_msg('END', p_ym);
  EXCEPTION
    WHEN OTHERS THEN
      log_msg('ERROR', SQLERRM);
      ROLLBACK;
      RAISE;
  END;
END;
/
```

#### SQL Server(요약)
```sql
CREATE OR ALTER PROCEDURE dbo.run_month @ym CHAR(6)
AS
BEGIN
  SET NOCOUNT ON;
  BEGIN TRY
    INSERT INTO dbo.billing_log(step, msg, ts) VALUES ('START', @ym, SYSDATETIME());

    -- 1) Stage
    INSERT INTO dbo.billing_stage(cust_id, ym, amt)
    SELECT cust_id, @ym, SUM(amount)
    FROM dbo.orders
    WHERE CONVERT(CHAR(6), order_date, 112) = @ym
    GROUP BY cust_id;

    -- 2) Discount
    UPDATE s
      SET s.amt = s.amt * (1 - d.rate)
    FROM dbo.billing_stage s
    JOIN dbo.discounts d ON d.cust_id = s.cust_id AND s.ym = @ym;

    -- 3) Upsert
    MERGE dbo.billing_final AS f
    USING (SELECT * FROM dbo.billing_stage WHERE ym = @ym) AS s
      ON f.cust_id = s.cust_id AND f.ym = s.ym
    WHEN MATCHED THEN UPDATE SET f.amt = s.amt
    WHEN NOT MATCHED THEN INSERT (cust_id, ym, amt) VALUES (s.cust_id, s.ym, s.amt);

    INSERT INTO dbo.billing_log(step, msg, ts) VALUES ('END', @ym, SYSDATETIME());
  END TRY
  BEGIN CATCH
    INSERT INTO dbo.billing_log(step, msg, ts)
    VALUES ('ERROR', ERROR_MESSAGE(), SYSDATETIME());
    THROW;
  END CATCH
END;
GO
```

#### PostgreSQL(요약)
```sql
CREATE OR REPLACE PROCEDURE run_month(p_ym CHAR(6))
LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO billing_log(step, msg, ts) VALUES ('START', p_ym, now());

  INSERT INTO billing_stage(cust_id, ym, amt)
  SELECT cust_id, p_ym, SUM(amount)
  FROM orders
  WHERE to_char(order_date,'YYYYMM') = p_ym
  GROUP BY cust_id;

  UPDATE billing_stage s
  SET amt = s.amt * (1 - d.rate)
  FROM discounts d
  WHERE d.cust_id = s.cust_id AND s.ym = p_ym;

  INSERT INTO billing_final(cust_id, ym, amt)
  SELECT cust_id, ym, amt
  FROM billing_stage
  WHERE ym = p_ym
  ON CONFLICT (cust_id, ym) DO UPDATE SET amt = EXCLUDED.amt;

  INSERT INTO billing_log(step, msg, ts) VALUES ('END', p_ym, now());
EXCEPTION WHEN OTHERS THEN
  INSERT INTO billing_log(step, msg, ts) VALUES ('ERROR', SQLERRM, now());
  RAISE;
END $$;
```

#### MySQL(요약)
```sql
DELIMITER //
CREATE PROCEDURE run_month(p_ym CHAR(6))
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    INSERT INTO billing_log(step, msg, ts) VALUES ('ERROR', 'SQLEXCEPTION', NOW());
    ROLLBACK;
  END;

  START TRANSACTION;
  INSERT INTO billing_log(step, msg, ts) VALUES ('START', p_ym, NOW());

  INSERT INTO billing_stage(cust_id, ym, amt)
  SELECT cust_id, p_ym, SUM(amount)
  FROM orders
  WHERE DATE_FORMAT(order_date, '%Y%m') = p_ym
  GROUP BY cust_id;

  UPDATE billing_stage s
  JOIN discounts d ON d.cust_id = s.cust_id AND s.ym = p_ym
  SET s.amt = s.amt * (1 - d.rate);

  INSERT INTO billing_final(cust_id, ym, amt)
  SELECT cust_id, ym, amt FROM billing_stage WHERE ym = p_ym
  ON DUPLICATE KEY UPDATE amt = VALUES(amt);

  INSERT INTO billing_log(step, msg, ts) VALUES ('END', p_ym, NOW());
  COMMIT;
END;
//
DELIMITER ;
```

---

## 13. 테스트·품질·배포(CI/CD)

- **단위 테스트**: 각 프로시저/UDF에 대해 입력→출력 검증(샘플/경계/오류 케이스)
  - Oracle: utPLSQL, SQLcl 스크립트
  - SQL Server: tSQLt 프레임워크
  - PostgreSQL: pgTap
- **계약 테스트**: 프로시저의 **서명(파라미터/리턴)**과 **에러코드** 고정
- **마이그레이션**: 버전 태깅 스크립트(UP/DOWN), Liquibase/Flyway
- **성능 리그레션**: 대표 데이터셋으로 실행시간/IO/플랜 스냅샷 비교

---

## 14. 요약

- 절차형 SQL은 **데이터 근접 로직**, **왕복 최소화 대량처리**, **감사/무결성**에 강력하다.  
- 그러나 기본은 **집합 지향**이며, 커서/행루프는 최후의 수단.  
- 트랜잭션·예외·로깅을 **표준화**하고, 엔진별 장점을 활용하되 이식성 레이어를 둔다.  
- 테스트/마이그레이션/플랜 관리까지 품질체계를 구성하면, **성능과 신뢰성**을 동시에 얻는다.

---

## 부록 A) 빠른 레시피(사전)

### A.1 행루프 지양 → 집합 지향 패턴
```sql
-- 나쁨
FOR r IN (SELECT ...) LOOP
  UPDATE t SET ... WHERE pk = r.pk;
END LOOP;

-- 좋음
UPDATE t SET ... WHERE pk IN (SELECT pk FROM ...);
```

### A.2 조건부 UPSERT
- Oracle: MERGE
- SQL Server: MERGE(주의) 또는 UPDATE…; IF @@ROWCOUNT=0 INSERT…
- PostgreSQL: INSERT … ON CONFLICT
- MySQL: INSERT … ON DUPLICATE KEY UPDATE

### A.3 에러 표준
- **업무 오류**: 사용자 메시지 + 코드, 롤백 없음(선택)
- **시스템 오류**: 로깅 후 RAISE/THROW, 트랜잭션 롤백

### A.4 권한
- 최소 권한(READ/WRITE/EXECUTE 분리), **롤(ROLE)** 기반, DDL/DML/DCL 구분
- SECURITY DEFINER/EXECUTE AS 사용 시 **감사 로깅** 필수