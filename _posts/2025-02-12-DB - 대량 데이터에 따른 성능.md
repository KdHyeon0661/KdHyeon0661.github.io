---
layout: post
title: DB - 대량 데이터에 따른 성능
date: 2025-02-12 19:20:23 +0900
category: DB
---
# 📦 대량 데이터에 따른 성능 이슈와 대응 전략

## 1. 대량 데이터의 정의

- **절대적 기준**은 없지만, 일반적으로 수백만 건 이상의 **행(row)** 또는 수십~수백 GB 이상 용량의 **테이블 단위**를 의미.
- 수십 테라바이트(TB) 또는 페타바이트(PB) 이상을 다루는 경우는 **초대규모(빅데이터) 시스템**으로 구분.

---

## 2. 대량 데이터로 인한 성능 저하 원인

| 이슈 유형 | 설명 |
|-----------|------|
| 🔄 **Full Scan 빈도 증가** | 인덱스를 사용하지 못하거나 WHERE 조건이 비효율적일 때 전체 테이블을 스캔함 |
| 📉 **인덱스 성능 저하** | 지나치게 많은 인덱스는 쓰기 성능을 저하시킴 (INSERT/UPDATE/DELETE 시 인덱스 갱신 부하) |
| 📄 **I/O 병목 현상** | 디스크 접근 횟수 증가로 인해 CPU보다 디스크 I/O 병목이 성능의 병목점이 됨 |
| 🔢 **정렬/그룹/조인 비용 급증** | ORDER BY, GROUP BY, JOIN 연산 시 정렬 공간(Temp Space) 사용이 늘고 처리 시간도 급증 |
| 🧮 **통계 정보 부정확** | Optimizer가 부정확한 실행 계획을 선택하여 성능 저하 초래 |

---

## 3. 주요 성능 대응 전략

### ✅ 3.1 파티셔닝 (Partitioning)

- **수직 파티셔닝**: 컬럼 단위로 분리하여 자주 사용하는 컬럼만 별도 테이블로 관리
- **수평 파티셔닝**: 날짜, 지역, 범위 등에 따라 행 단위 분할
- 파티션 **Pruning**과 **Elimination**으로 쿼리 성능 대폭 향상

> 예: 월별 데이터 분리 → `SELECT * FROM logs WHERE log_month = '2024-06'` 시 해당 파티션만 조회

---

### ✅ 3.2 인덱스 최적화

- **복합 인덱스(Composite Index)** 활용: 자주 함께 조회되는 컬럼 조합
- **Covering Index**: 쿼리가 요구하는 모든 컬럼을 포함해 테이블 접근을 피함
- 과도한 인덱스는 오히려 DML(삽입/수정/삭제) 성능 저하 유발 → **선택성과 활용빈도 기준**으로 설계

---

### ✅ 3.3 통계 정보 관리 (Statistics)

- RDBMS 옵티마이저는 통계 정보를 기반으로 쿼리 실행 계획 수립
- 대량 데이터 환경에서는 주기적으로 `ANALYZE`, `UPDATE STATISTICS`, `DBMS_STATS` 등을 통해 **최신 통계 유지** 필수

---

### ✅ 3.4 아카이빙 및 이력 테이블 분리

- 사용 빈도가 낮고 오래된 데이터를 **이력 테이블**로 분리하여 운영 테이블 경량화
- 필요 시 Only Archive 조회 → 운영 부하 최소화

---

### ✅ 3.5 분산 처리 및 병렬 처리 (Parallelism)

- RDBMS의 병렬 쿼리 처리 기능(PQ, Parallel Hint)
- 분산 DBMS나 BigQuery, Snowflake, Hive 등 **MPP(Massively Parallel Processing)** 플랫폼 고려

---

### ✅ 3.6 메모리 기반 설계 및 캐싱

| 기술 | 설명 |
|------|------|
| Redis, Memcached | 읽기 속도 요구 시 캐시 레이어 구축 |
| Materialized View | 정적 결과를 미리 계산해 보관, 집계/조회 속도 개선 |
| In-Memory Table | 전체 테이블을 메모리에 적재, 응답 지연 최소화 (예: SAP HANA) |

---

## 4. 대량 데이터 환경에서 주의할 점

| 항목 | 설명 |
|------|------|
| 🔄 트랜잭션 크기 제한 | 너무 큰 트랜잭션은 Lock 경합, Undo/Redo 부하 유발 |
| 🕸️ 대용량 조인 피하기 | 꼭 필요한 조인만 수행하고, Join 대상 테이블은 사전에 필터링 |
| 🛑 실시간 조회와 대량 일괄처리 분리 | 실시간 조회용 DB와 Batch/Analytics용 DB 분리 (OLTP vs OLAP) |
| ⛓️ 자동화된 아카이빙 정책 | 주기적 삭제/이동 정책 없이 운영 데이터만 누적되면 급속한 성능 저하 발생 |

---

## 5. 대량 데이터 + 성능 튜닝 우선 순위

1️⃣ WHERE절 최적화 →  
2️⃣ 인덱스 설계 →  
3️⃣ 통계 정보 관리 →  
4️⃣ 파티셔닝 적용 →  
5️⃣ 필요 시 반정규화/아카이빙 →  
6️⃣ 병렬 처리 및 분산 시스템 검토

---

## 💬 결론

> 대량 데이터 환경에서는 **모델링, 쿼리, 인프라 설계가 모두 조화를 이뤄야** 진정한 성능을 확보할 수 있습니다.

- 데이터 용량은 시간이 지날수록 증가하므로 **장기적인 운영 전략(보존주기, 이력관리, 파티션 설계)**이 중요합니다.
- "대량 데이터 = 성능 저하"가 아닌, **체계적 설계 + 실시간 모니터링**이 핵심입니다.