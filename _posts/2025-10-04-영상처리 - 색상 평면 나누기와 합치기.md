---
layout: post
title: 영상처리 - 색상 평면 나누기와 합치기
date: 2025-10-04 15:25:23 +0900
category: 영상처리
---
# 색상 평면 나누기와 합치기

## 목표와 설계

### 왜 “색상 평면 나누기/합치기”인가?

- **분리(Split)**: 채널 단위 작업(예: Y’만 평활화, S만 감소, R만 히스토그램 균등화)이 쉬워집니다.
- **합치기(Merge)**: 보정된 채널들을 다시 하나의 **트루컬러** 영상으로 복원합니다.

### 지원 색 모델과 표기

- **RGB**: R, G, B (0..255)
- **HSI**: H(0..360°, 표시용 0..255 스케일), S(0..1→0..255), I(0..1→0..255)
- **YCbCr(Full Range)**: Y, Cb, Cr (0..255, Cb/Cr 중심 128)

> 표시는 **그레이스케일**(채널을 0..255로) 또는 **의사색(pseudocolor)**(특히 H)에 대응합니다.

---

## 코어: 채널 분리와 합치기 함수

### 도우미(스케일링·히스토그램 스트레칭·의사색)

```cpp
// SplitMergeCore.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <cmath>
#include <algorithm>
#include <string>
#include "IppDib.h"
#include "IppImage.h"
#include "RGB24.h"
#include "DibImageConvert.hpp"
#include "RGB_HSI.hpp"
#include "RGB_YCbCr.hpp"

inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }

// 그레이 8비트 -> BGRA32 DIB
inline IppDib GrayToDib(const IppImage<uint8_t>& g){
    IppDib d; d.create(g.width(), g.height(), 32);
    for(int y=0;y<g.height();++y){
        const uint8_t* s=g.row(y);
        uint8_t* dd=(uint8_t*)d.bits()+(size_t)y*d.stride();
        for(int x=0;x<g.width();++x){
            uint8_t v=s[x];
            dd[x*4+0]=dd[x*4+1]=dd[x*4+2]=v; dd[x*4+3]=255;
        }
    }
    return d;
}

// 간단 히스토그램 스트레칭(0..255 → 0..255)
inline void StretchContrast(IppImage<uint8_t>& g){
    int lo=255, hi=0;
    for(int y=0;y<g.height();++y){
        const uint8_t* p=g.row(y);
        for(int x=0;x<g.width();++x){ lo=std::min(lo,(int)p[x]); hi=std::max(hi,(int)p[x]); }
    }
    if (hi<=lo) return;
    const float k = 255.f/float(hi-lo);
    for(int y=0;y<g.height();++y){
        uint8_t* p=g.row(y);
        for(int x=0;x<g.width();++x){
            int v = int((p[x]-lo)*k + 0.5f);
            p[x] = clamp_u8(v);
        }
    }
}

// H(0..360deg)를 표시용 0..255로 매핑
inline uint8_t HueToByte(float Hdeg){
    while(Hdeg<0) Hdeg+=360.f; while(Hdeg>=360.f) Hdeg-=360.f;
    return (uint8_t)std::lround(Hdeg*(255.f/360.f));
}

// 간단 의사색: H(0..360°)를 BGR로 변환(밝기는 1, 채도 1 가정)
inline void PseudoColorHue(const IppImage<HSI32f>& hsi, IppDib& out){
    out.create(hsi.width(), hsi.height(), 32);
    for(int y=0;y<hsi.height();++y){
        const HSI32f* s=hsi.row(y);
        uint8_t* d=(uint8_t*)out.bits()+(size_t)y*out.stride();
        for(int x=0;x<hsi.width();++x){
            // S=1,I=0.8로 가정해 hue만 강조(튜닝 가능)
            HSI32f t{s[x].h, 1.f, 0.8f};
            IppImage<HSI32f> one(1,1); one.at(0,0)=t;
            IppImage<RGB24>   rr; HSI_to_RGB24(one, rr);
            d[x*4+0]=rr.at(0,0).b; d[x*4+1]=rr.at(0,0).g; d[x*4+2]=rr.at(0,0).r; d[x*4+3]=255;
        }
    }
}
```

### **색상 평면 나누기**(Split)

```cpp
enum class SplitModel { RGB, HSI, YCbCr };

struct SplitOptions{
    SplitModel model = SplitModel::RGB;
    bool stretch = false;        // 그레이 채널 표시용 히스토그램 스트레칭
    bool pseudoHue = false;      // HSI일 때 H 채널 의사색 표시
};

struct SplitResult {
    // 시각화를 위해 DIB 3장을 생성(R/G/B or H/S/I or Y/Cb/Cr)
    IppDib ch1, ch2, ch3;
    std::wstring name1, name2, name3; // 창 제목 등
};

inline SplitResult SplitPlanes(const IppDib& dib, const SplitOptions& opt){
    SplitResult r;
    IppImage<RGB24> rgb; DibToImageRGB24(dib, rgb);

    if (opt.model == SplitModel::RGB){
        IppImage<uint8_t> R(rgb.width(), rgb.height());
        IppImage<uint8_t> G(rgb.width(), rgb.height());
        IppImage<uint8_t> B(rgb.width(), rgb.height());
        for(int y=0;y<rgb.height();++y){
            const RGB24* s=rgb.row(y);
            uint8_t* pr=R.row(y), *pg=G.row(y), *pb=B.row(y);
            for(int x=0;x<rgb.width();++x){
                pr[x]=s[x].r; pg[x]=s[x].g; pb[x]=s[x].b;
            }
        }
        if (opt.stretch){ StretchContrast(R); StretchContrast(G); StretchContrast(B); }
        r.ch1=GrayToDib(R); r.ch2=GrayToDib(G); r.ch3=GrayToDib(B);
        r.name1=L"R plane"; r.name2=L"G plane"; r.name3=L"B plane";
    }
    else if (opt.model == SplitModel::HSI){
        IppImage<HSI32f> hsi; RGB24_to_HSI(rgb, hsi);
        IppImage<uint8_t> H8(hsi.width(),hsi.height()), S8(hsi.width(),hsi.height()), I8(hsi.width(),hsi.height());
        for(int y=0;y<hsi.height();++y){
            const HSI32f* s=hsi.row(y);
            uint8_t* h=H8.row(y), *ss=S8.row(y), *ii=I8.row(y);
            for(int x=0;x<hsi.width();++x){
                h[x]=HueToByte(s[x].h);
                ss[x]=(uint8_t)std::lround(std::clamp(s[x].s,0.f,1.f)*255.f);
                ii[x]=(uint8_t)std::lround(std::clamp(s[x].i,0.f,1.f)*255.f);
            }
        }
        if (opt.stretch){ StretchContrast(S8); StretchContrast(I8); /*H는 각도라 보통 스트레칭 안함*/ }
        // 출력
        if (opt.pseudoHue){
            // H를 의사색으로
            IppImage<HSI32f> onlyH(hsi.width(),hsi.height());
            for(int y=0;y<hsi.height();++y){
                const HSI32f* s=hsi.row(y); HSI32f* d=onlyH.row(y);
                for(int x=0;x<hsi.width();++x) d[x] = { s[x].h, 1.f, 0.8f };
            }
            PseudoColorHue(onlyH, r.ch1);
        } else {
            r.ch1=GrayToDib(H8);
        }
        r.ch2=GrayToDib(S8); r.ch3=GrayToDib(I8);
        r.name1=L"H plane"; r.name2=L"S plane"; r.name3=L"I plane";
    }
    else{ // YCbCr
        IppImage<YCbCr8> yuv; RGB24_to_YCbCr(rgb, yuv);
        IppImage<uint8_t> Y(yuv.width(),yuv.height()), Cb(yuv.width(),yuv.height()), Cr(yuv.width(),yuv.height());
        for(int y=0;y<yuv.height();++y){
            const YCbCr8* s=yuv.row(y);
            uint8_t* py=Y.row(y), *pcb=Cb.row(y), *pcr=Cr.row(y);
            for(int x=0;x<yuv.width();++x){
                py[x]=s[x].y; pcb[x]=s[x].cb; pcr[x]=s[x].cr;
            }
        }
        if (opt.stretch){ StretchContrast(Y); /*Cb/Cr는 중심 128이라 스트레칭은 시각 왜곡 유발 가능*/ }
        r.ch1=GrayToDib(Y); r.ch2=GrayToDib(Cb); r.ch3=GrayToDib(Cr);
        r.name1=L"Y plane"; r.name2=L"Cb plane"; r.name3=L"Cr plane";
    }
    return r;
}
```

### **색상 평면 합치기**(Merge)

```cpp
enum class MergeModel { RGB, HSI, YCbCr };

struct MergeInputs {
    // 채널별 입력 그레이(0..255). 모두 같은 크기여야 함.
    IppImage<uint8_t> ch1, ch2, ch3;
    MergeModel model = MergeModel::RGB;
    // HSI일 때: ch1=H(0..255→0..360°), ch2=S(0..255→0..1), ch3=I(0..255→0..1)
    // YCbCr일 때: ch1=Y, ch2=Cb, ch3=Cr (full range)
};

inline bool MergePlanes(const MergeInputs& mi, IppDib& out){
    if (mi.ch1.width()!=mi.ch2.width() || mi.ch1.width()!=mi.ch3.width()) return false;
    if (mi.ch1.height()!=mi.ch2.height() || mi.ch1.height()!=mi.ch3.height()) return false;
    const int W=mi.ch1.width(), H=mi.ch1.height();

    if (mi.model==MergeModel::RGB){
        IppImage<RGB24> rgb(W,H);
        for(int y=0;y<H;++y){
            const uint8_t* pr=mi.ch1.row(y), *pg=mi.ch2.row(y), *pb=mi.ch3.row(y);
            RGB24* d=rgb.row(y);
            for(int x=0;x<W;++x) d[x]=RGB24(pr[x], pg[x], pb[x]);
        }
        ImageRGB24ToDib(rgb, out); return true;
    }
    else if (mi.model==MergeModel::HSI){
        IppImage<HSI32f> hsi(W,H);
        for(int y=0;y<H;++y){
            const uint8_t* h=mi.ch1.row(y), *s=mi.ch2.row(y), *ii=mi.ch3.row(y);
            HSI32f* d=hsi.row(y);
            for(int x=0;x<W;++x){
                float Hdeg = (h[x]/255.f)*360.f;
                float S    = std::clamp(s[x]/255.f, 0.f, 1.f);
                float I    = std::clamp(ii[x]/255.f,0.f, 1.f);
                d[x]={Hdeg,S,I};
            }
        }
        IppImage<RGB24> rgb; HSI_to_RGB24(hsi, rgb);
        ImageRGB24ToDib(rgb, out); return true;
    }
    else{ // YCbCr
        IppImage<YCbCr8> yuv(W,H);
        for(int y=0;y<H;++y){
            const uint8_t* py=mi.ch1.row(y), *pcb=mi.ch2.row(y), *pcr=mi.ch3.row(y);
            YCbCr8* d=yuv.row(y);
            for(int x=0;x<W;++x) d[x]={py[x], pcb[x], pcr[x]};
        }
        IppImage<RGB24> rgb; YCbCr_to_RGB24(yuv, rgb);
        ImageRGB24ToDib(rgb, out); return true;
    }
}
```

---

## UI — **색상 평면 나누기** 대화 상자 & 메뉴

### 리소스 ID

```cpp
// resource.h (추가)
#define ID_MENU_SPLIT_PLANES            82010
#define ID_MENU_MERGE_PLANES            82011

#define IDD_SPLIT_PLANES_DLG            3900
#define IDC_RAD_SPLIT_RGB               3901
#define IDC_RAD_SPLIT_HSI               3902
#define IDC_RAD_SPLIT_YUV               3903
#define IDC_CHK_SPLIT_STRETCH           3904
#define IDC_CHK_SPLIT_PSEUDOH           3905

```

### RC(대화 상자/메뉴)

```rc
// ImageTool.rc (추가)
IDD_SPLIT_PLANES_DLG DIALOGEX 0,0, 220, 128
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Split Color Planes"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Model", -1, 12, 10, 196, 40
    AUTORADIOBUTTON "RGB",   IDC_RAD_SPLIT_RGB, 22, 24, 40, 10, WS_TABSTOP
    AUTORADIOBUTTON "HSI",   IDC_RAD_SPLIT_HSI, 72, 24, 40, 10
    AUTORADIOBUTTON "YCbCr", IDC_RAD_SPLIT_YUV, 122, 24, 60, 10
    AUTOCHECKBOX "Stretch (grays)", IDC_CHK_SPLIT_STRETCH, 22, 58, 90, 12
    AUTOCHECKBOX "Hue pseudocolor", IDC_CHK_SPLIT_PSEUDOH, 22, 74, 100, 12
    DEFPUSHBUTTON "OK", IDOK,  96, 96, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 146, 96, 44, 16
END

POPUP "&Color"
BEGIN
    MENUITEM "Split Color Planes...\tCtrl+Shift+S", ID_MENU_SPLIT_PLANES
    MENUITEM "Merge Color Planes...\tCtrl+Shift+M", ID_MENU_MERGE_PLANES
END

IDR_ACCEL ACCELERATORS
BEGIN
    "S", ID_MENU_SPLIT_PLANES,  VIRTKEY, CONTROL, SHIFT
    "M", ID_MENU_MERGE_PLANES,  VIRTKEY, CONTROL, SHIFT
END
```

### 대화 상자 코드

```cpp
// SplitPlanesDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "SplitMergeCore.hpp"

// 앱의 창/도큐먼트 도우미(간단 인터페이스 예시)
struct DocRef { HWND hwnd; IppDib* dib; std::wstring title; };
std::vector<DocRef> GetOpenDocs();                 // 구현은 앱 쪽에서 제공
HWND CreateDocWindowFromDib(const IppDib& dib, const std::wstring& title); // 새 창 생성

class SplitPlanesDlg {
public:
    SplitPlanesDlg(HWND owner, IppDib& src): owner_(owner), src_(src) {}
    INT_PTR DoModal();
private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM);
    HWND owner_{};
    IppDib& src_;
};
```

```cpp
// SplitPlanesDlg.cpp
#include "SplitPlanesDlg.h"

INT_PTR SplitPlanesDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_SPLIT_PLANES_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK SplitPlanesDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        return ((SplitPlanesDlg*)l)->OnInit(h); }
    auto* self=(SplitPlanesDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w);
    return FALSE;
}
INT_PTR SplitPlanesDlg::OnInit(HWND h){
    CheckRadioButton(h, IDC_RAD_SPLIT_RGB, IDC_RAD_SPLIT_YUV, IDC_RAD_SPLIT_RGB);
    CheckDlgButton(h, IDC_CHK_SPLIT_STRETCH, BST_UNCHECKED);
    CheckDlgButton(h, IDC_CHK_SPLIT_PSEUDOH, BST_UNCHECKED);
    return TRUE;
}
INT_PTR SplitPlanesDlg::OnCommand(HWND h, WPARAM w){
    switch(LOWORD(w)){
    case IDOK: {
        SplitOptions opt;
        if (IsDlgButtonChecked(h, IDC_RAD_SPLIT_HSI)==BST_CHECKED) opt.model=SplitModel::HSI;
        else if (IsDlgButtonChecked(h, IDC_RAD_SPLIT_YUV)==BST_CHECKED) opt.model=SplitModel::YCbCr;
        else opt.model=SplitModel::RGB;
        opt.stretch   = (IsDlgButtonChecked(h, IDC_CHK_SPLIT_STRETCH)==BST_CHECKED);
        opt.pseudoHue = (IsDlgButtonChecked(h, IDC_CHK_SPLIT_PSEUDOH)==BST_CHECKED);

        auto res = SplitPlanes(src_, opt);
        CreateDocWindowFromDib(res.ch1, res.name1);
        CreateDocWindowFromDib(res.ch2, res.name2);
        CreateDocWindowFromDib(res.ch3, res.name3);

        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL: EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

---

## UI — **색상 평면 합치기** 대화 상자 & 메뉴

### 리소스 ID

```cpp
// resource.h (추가)
#define IDD_MERGE_PLANES_DLG           3950
#define IDC_RAD_MERGE_RGB              3951
#define IDC_RAD_MERGE_HSI              3952
#define IDC_RAD_MERGE_YUV              3953
#define IDC_CMB_CH1                    3954
#define IDC_CMB_CH2                    3955
#define IDC_CMB_CH3                    3956
#define IDC_TXT_CH1                    3957
#define IDC_TXT_CH2                    3958
#define IDC_TXT_CH3                    3959

```

### RC

```rc
// ImageTool.rc (추가)
IDD_MERGE_PLANES_DLG DIALOGEX 0,0, 280, 168
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Merge Color Planes"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Model", -1, 12, 10, 256, 40
    AUTORADIOBUTTON "RGB",   IDC_RAD_MERGE_RGB,  22, 24, 40, 10, WS_TABSTOP
    AUTORADIOBUTTON "HSI",   IDC_RAD_MERGE_HSI,  76, 24, 40, 10
    AUTORADIOBUTTON "YCbCr", IDC_RAD_MERGE_YUV, 130, 24, 60, 10

    LTEXT "R / H / Y:", IDC_TXT_CH1, 22, 60, 50, 10
    COMBOBOX IDC_CMB_CH1, 76, 58, 180, 100, CBS_DROPDOWNLIST | WS_VSCROLL

    LTEXT "G / S / Cb:", IDC_TXT_CH2, 22, 80, 50, 10
    COMBOBOX IDC_CMB_CH2, 76, 78, 180, 100, CBS_DROPDOWNLIST | WS_VSCROLL

    LTEXT "B / I / Cr:", IDC_TXT_CH3, 22, 100, 50, 10
    COMBOBOX IDC_CMB_CH3, 76, 98, 180, 100, CBS_DROPDOWNLIST | WS_VSCROLL

    DEFPUSHBUTTON "OK", IDOK,    160, 132, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 210, 132, 44, 16
END
```

### 도큐먼트 목록/콤보 유틸

```cpp
// DocListUtil.hpp (예시 구현: 앱 사양에 맞게 수정)
#pragma once
#include <vector>
#include <string>
#include <windows.h>
#include "IppDib.h"

// 앱 전역에서 열려 있는 창/도큐먼트를 수집
extern std::vector<DocRef> g_docs; // {HWND, IppDib*, title}

inline std::vector<DocRef> GetOpenDocs(){ return g_docs; }

inline void FillComboWithDocs(HWND hDlg, int comboID, const std::vector<DocRef>& docs){
    HWND hCmb = GetDlgItem(hDlg, comboID);
    SendMessageW(hCmb, CB_RESETCONTENT, 0, 0);
    for(size_t i=0;i<docs.size();++i){
        SendMessageW(hCmb, CB_ADDSTRING, 0, (LPARAM)docs[i].title.c_str());
    }
    if (!docs.empty()) SendMessageW(hCmb, CB_SETCURSEL, 0, 0);
}

inline int ComboSelIndex(HWND hDlg, int comboID){
    return (int)SendMessageW(GetDlgItem(hDlg, comboID), CB_GETCURSEL, 0, 0);
}
```

### 대화 상자 코드

```cpp
// MergePlanesDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "SplitMergeCore.hpp"
#include "DocListUtil.hpp"

class MergePlanesDlg {
public:
    MergePlanesDlg(HWND owner): owner_(owner) {}
    INT_PTR DoModal();
private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM);

    void UpdateLabels(HWND h); // RGB/HSI/YCbCr에 따라 라벨 변경

    HWND owner_{};
};
```

```cpp
// MergePlanesDlg.cpp
#include "MergePlanesDlg.h"

extern HWND CreateDocWindowFromDib(const IppDib& dib, const std::wstring& title);

INT_PTR MergePlanesDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_MERGE_PLANES_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK MergePlanesDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        return ((MergePlanesDlg*)l)->OnInit(h); }
    auto* self=(MergePlanesDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w);
    return FALSE;
}
void MergePlanesDlg::UpdateLabels(HWND h){
    bool isHSI = (IsDlgButtonChecked(h, IDC_RAD_MERGE_HSI)==BST_CHECKED);
    bool isYUV = (IsDlgButtonChecked(h, IDC_RAD_MERGE_YUV)==BST_CHECKED);
    SetDlgItemTextW(h, IDC_TXT_CH1, isHSI?L"H:" : (isYUV?L"Y:" : L"R:"));
    SetDlgItemTextW(h, IDC_TXT_CH2, isHSI?L"S:" : (isYUV?L"Cb:" : L"G:"));
    SetDlgItemTextW(h, IDC_TXT_CH3, isHSI?L"I:" : (isYUV?L"Cr:" : L"B:"));
}

INT_PTR MergePlanesDlg::OnInit(HWND h){
    CheckRadioButton(h, IDC_RAD_MERGE_RGB, IDC_RAD_MERGE_YUV, IDC_RAD_MERGE_RGB);
    UpdateLabels(h);
    auto docs = GetOpenDocs();
    FillComboWithDocs(h, IDC_CMB_CH1, docs);
    FillComboWithDocs(h, IDC_CMB_CH2, docs);
    FillComboWithDocs(h, IDC_CMB_CH3, docs);
    return TRUE;
}

INT_PTR MergePlanesDlg::OnCommand(HWND h, WPARAM w){
    switch(LOWORD(w)){
    case IDC_RAD_MERGE_RGB:
    case IDC_RAD_MERGE_HSI:
    case IDC_RAD_MERGE_YUV:
        UpdateLabels(h); return TRUE;

    case IDOK: {
        auto docs = GetOpenDocs();
        int i1=ComboSelIndex(h, IDC_CMB_CH1);
        int i2=ComboSelIndex(h, IDC_CMB_CH2);
        int i3=ComboSelIndex(h, IDC_CMB_CH3);
        if (i1<0||i2<0||i3<0 || i1>=(int)docs.size() || i2>=(int)docs.size() || i3>=(int)docs.size()){
            MessageBoxW(h, L"채널로 사용할 도큐먼트를 선택하세요.", L"Merge", MB_ICONWARNING);
            return TRUE;
        }
        // 각 도큐먼트의 DIB → 그레이 8비트로 확보(BGRA에서 B=G=R 가정)
        auto toGray8=[&](IppDib* dib)->IppImage<uint8_t>{
            IppImage<uint8_t> g(dib->width(), dib->height());
            for(int y=0;y<dib->height();++y){
                const uint8_t* s=(const uint8_t*)dib->bits()+(size_t)y*dib->stride();
                uint8_t* d=g.row(y);
                for(int x=0;x<dib->width();++x){
                    // 표시용 그레이 또는 채널 영상이라고 가정: 세 채널 동일이면 아무거나
                    d[x]=s[x*4+2]; // R(=G= B)중 하나
                }
            }
            return g;
        };
        IppImage<uint8_t> ch1 = toGray8(docs[i1].dib);
        IppImage<uint8_t> ch2 = toGray8(docs[i2].dib);
        IppImage<uint8_t> ch3 = toGray8(docs[i3].dib);

        if (ch1.width()!=ch2.width() || ch1.width()!=ch3.width() ||
            ch1.height()!=ch2.height() || ch1.height()!=ch3.height()){
            MessageBoxW(h, L"세 영상의 크기가 일치하지 않습니다.", L"Merge", MB_ICONERROR);
            return TRUE;
        }

        MergeInputs mi; mi.ch1=ch1; mi.ch2=ch2; mi.ch3=ch3;
        if (IsDlgButtonChecked(h, IDC_RAD_MERGE_HSI)==BST_CHECKED) mi.model=MergeModel::HSI;
        else if (IsDlgButtonChecked(h, IDC_RAD_MERGE_YUV)==BST_CHECKED) mi.model=MergeModel::YCbCr;
        else mi.model=MergeModel::RGB;

        IppDib out;
        if (!MergePlanes(mi, out)){
            MessageBoxW(h, L"병합 실패(입력 확인).", L"Merge", MB_ICONERROR);
            return TRUE;
        }
        CreateDocWindowFromDib(out, L"Merged Color");
        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL: EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

### 메뉴 핸들러

```cpp
// main_multiwin.cpp (발췌)
#include "SplitPlanesDlg.h"
#include "MergePlanesDlg.h"

// ...
case ID_MENU_SPLIT_PLANES:
    if (st && st->dib){
        SplitPlanesDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            // 새 창들이 이미 만들어짐
        }
    }
    return 0;

case ID_MENU_MERGE_PLANES: {
    MergePlanesDlg dlg(hWnd);
    dlg.DoModal();
    return 0;
}
```

---

## 예제 시나리오

### **Y’만 부드럽게 → 재결합**

- **상황**: 색감은 유지하고 노이즈만 줄이고 싶다.
- **절차**:
  1) `Color → Split Color Planes…` 에서 **YCbCr** 선택, **Stretch** 체크(보기 편의).
  2) 생성된 **Y plane** 창을 선택 → 8.2절의 **가우시안/평균필터** 등으로 **블러**.
  3) `Color → Merge Color Planes…` 에서 Model=YCbCr,
     - `Y:Cmb=Y plane`, `Cb:Cmb=C b plane`, `Cr:Cmb=Cr plane` 선택 → **OK**.
- **결과**: 색상(크로마)은 보존되며 **밝기 노이즈만 저감**.

### **HSI: 채도 S 감소, 밝기 I 증가**

- **상황**: 과포화 회화풍 이미지를 **자연스럽게**.
- **절차**:
  1) HSI로 Split(필요 시 Hue 의사색 체크).
  2) **S plane**을 `명암비 ×0.8`(6.2절) / **I plane**을 `밝기 +10`
  3) Merge(Model=HSI).
- **결과**: 색조(H)는 유지, 채도 감소로 **자연스럽고 부드러운 톤**.

### **RGB: R만 히스토그램 균등화**

- **상황**: 해질녘 사진에서 붉은 채널만 눌려 있음.
- **절차**: RGB Split → **R plane**에 6.5절의 **히스토그램 균등화** 적용 → RGB Merge.
- **결과**: 붉은 영역의 디테일 회복, **색상 캐스트** 최소화.

### **피부톤 보호: Hue 마스크 편집 후 Merge**

- **상황**: 전체 S를 올렸지만 피부톤이 과포화.
- **절차**: HSI Split → **H plane**에서 피부 범위(10~40°) 마스크 생성 → **S plane**에만 범위 내 감쇠 → HSI Merge.
- **결과**: 배경은 선명, **피부는 자연스러움**.

---

## 정확성·안정성 체크리스트

- [ ] Split/ Merge 시 **영상 크기** 일치 확인(미스매치 시 오류 안내).
- [ ] HSI: H 스케일(0..255↔0..360°), S/I(0..1↔0..255) 변환 정확.
- [ ] YCbCr: **Full Range** 가정(필요시 Limited Range 옵션 추가 가능).
- [ ] 표시용 스트레칭은 **시각화 전용**이며, Merge 입력으로 쓸 때 의도적으로 적용/미적용을 결정.
- [ ] 새 창 생성 시 **제목**(R/G/B, H/S/I, Y/Cb/Cr)을 명확히.

---

## 테스트: 왕복 정확성

```cpp
// test_split_merge.cpp
#include <cassert>
#include "SplitMergeCore.hpp"

int main(){
    // 32x16 단순 패턴 DIB 생성
    IppDib src; src.create(32,16,32);
    for(int y=0;y<src.height();++y){
        uint8_t* d=(uint8_t*)src.bits()+y*src.stride();
        for(int x=0;x<src.width();++x){
            d[x*4+0] = (uint8_t)((x*8) & 255);       // B
            d[x*4+1] = (uint8_t)((y*16) & 255);      // G
            d[x*4+2] = (uint8_t)(((x+y)*4) & 255);   // R
            d[x*4+3] = 255;
        }
    }

    // 1) RGB Split → Merge
    SplitOptions so; so.model=SplitModel::RGB;
    auto sr = SplitPlanes(src, so);
    // DIB→Gray 3장으로부터 MergeInputs 구성(테스트용 변환)
    auto dibToGray=[&](const IppDib& dib){
        IppImage<uint8_t> g(dib.width(), dib.height());
        for(int y=0;y<dib.height();++y){
            const uint8_t* s=(const uint8_t*)dib.bits()+y*dib.stride();
            uint8_t* d=g.row(y);
            for(int x=0;x<dib.width();++x) d[x]=s[x*4+2];
        }
        return g;
    };
    MergeInputs mi; mi.model=MergeModel::RGB;
    mi.ch1=dibToGray(sr.ch1); mi.ch2=dibToGray(sr.ch2); mi.ch3=dibToGray(sr.ch3);
    IppDib merged; bool ok=MergePlanes(mi, merged); assert(ok);
    // 동일성 대략 확인(정확히 동일해야 함)
    assert(merged.width()==src.width() && merged.height()==src.height());

    // 2) YCbCr/HSI도 단순 왕복이 작동하는지 확인
    so.model=SplitModel::YCbCr; auto sy = SplitPlanes(src, so);
    mi.model=MergeModel::YCbCr; mi.ch1=dibToGray(sy.ch1); mi.ch2=dibToGray(sy.ch2); mi.ch3=dibToGray(sy.ch3);
    ok=MergePlanes(mi, merged); assert(ok);

    so.model=SplitModel::HSI; auto sh = SplitPlanes(src, so);
    mi.model=MergeModel::HSI; mi.ch1=dibToGray(sh.ch1); mi.ch2=dibToGray(sh.ch2); mi.ch3=dibToGray(sh.ch3);
    ok=MergePlanes(mi, merged); assert(ok);

    return 0;
}
```

---

## 성능·확장 팁

- **대용량 영상**: 채널 분리는 메모리 대역폭 지배 → 행 단위 **멀티스레딩**으로 손쉽게 2~4배 가속.
- **SIMD**: RGB↔Gray, YCbCr 변환은 SSE2/AVX2 적합.
- **의사색 LUT**: H→BGR 매핑을 256 엔트리 LUT로 만들어 빠르게 색칠.
- **HSI 안정성**: \(\cos(60^\circ-H)\) 분모 보호(ε) 및 H wrap-around 주의.
- **YCbCr 범위**: 코덱 인터페이스와 연결 시 **Limited Range** 옵션을 추가(매핑식 필요).
- **크기 불일치 처리**: 현재는 **오류**로 처리. 필요하면 자동 **리샘플링**(9.2절 보간법) 옵션을 제공.

---

## 요약

- **Split**: RGB/HSI/YCbCr을 3개의 단일 채널 평면으로 시각화(Stretch/의사색 지원).
- **편집**: 각 평면에 원하는 필터·연산 적용(예: Y에 블러, S 감소, R 균등화).
- **Merge**: 모델에 맞게 역변환하여 **트루컬러**로 복원.
- **UI**: 두 개의 대화 상자로 손쉽게 작업(모델 선택, 도큐먼트 매칭).
