---
layout: post
title: 형식언어와 오토마타 - NP-완전성과 미해결 문제
date: 2025-08-15 15:20:23 +0900
category: 형식언어와 오토마타
---
# NP-완전성과 미해결 문제

## 기본 정의: NP, NP-어려움, NP-완전

- **NP**: “예(Yes) 인스턴스는 **길이 다항**의 증명서로 **다항시간 검증** 가능”인 결정 문제 집합.
- **NP-어려움(NP-hard)**: NP의 **모든 문제**가 다항시간 감소로 줄어드는 문제.
- **NP-완전(NP-complete)**: (i) NP에 속하고, (ii) NP-어려운 문제.

### 다항식 시간 many-one 감소(카프 감소)

언어 \(A,B\subseteq\Sigma^\*\)에 대해
$$
A \le_m^p B \iff \exists f \in \mathbf{FP}\ \text{s.t.}\ \forall x:\ x\in A \Leftrightarrow f(x)\in B.
$$

- 전이성, 반사성을 만족.
- \(A\le_m^p B\)이고 \(B\in\mathbf{P}\)라면 \(A\in\mathbf{P}\).

---

## Cook–Levin 정리와 “출발점”들

- **Cook–Levin 정리**: **SAT**가 NP-완전. 임의의 NP 계산을 부울 공식 만족성으로 부호화한다.
- **3-SAT**도 NP-완전(절마다 리터럴 3개로 제한해도 난이도 보존).
- 카프(Karp)의 21문제 등 표준 NP-완전 군:
  - 그래프: CLIQUE, INDEPENDENT SET, VERTEX COVER, HAMILTONIAN CYCLE, 3-COLORING
  - 수치/조합: SUBSET-SUM, PARTITION, 0/1-KNAPSACK(dec)
  - 라우팅/일정: TSP(dec), JOB-SHOP

> 실전 요령: 새로운 문제의 난이도를 판단할 때 **SAT/3-SAT**이나 **표준 NP-완전 문제**들로부터의 감소를 가장 먼저 시도한다.

---

## NP-완전성 **증명 템플릿**(감소 설계)

1) **NP 포함**: “예” 증명서 구조(대입, 부분집합, 경로 등)를 보이고 다항시간 검증 가능성을 증명.
2) **감소 설계**: 이미 NP-완전인 \(A\)에서 목표 \(B\)로 \(A\le_m^p B\).
   - **가젯(gadget)**: 변수·절·충돌 금지 같은 지역 제약을 목표 인스턴스의 구조로 번역.
   - **양방향 정확성**:
     - \(x\in A \Rightarrow f(x)\in B\) (정방향)
     - \(f(x)\in B \Rightarrow x\in A\) (역방향)

### 미니 예: 3-SAT → CLIQUE (스케치)

```text
입력: 3-CNF ϕ = ∧_{j=1..m} (ℓ_{j1} ∨ ℓ_{j2} ∨ ℓ_{j3})
그래프 G 구성:
  - 각 절 C_j의 리터럴을 정점으로 (총 3m개)
  - 같은 절의 정점들끼리는 간선 없음
  - 모순 쌍( x vs ¬x ) 사이에도 간선 없음
  - 그 외 모든 쌍에는 간선 추가
목표: k := m
정확성: ϕ가 만족 ⇔ G에 크기 m의 clique 존재
```

### 3-SAT → VERTEX COVER (클리크 보수)

- 그래프 보수를 이용해 **CLIQUE ↔ VERTEX COVER**로 전환.
- \(G\)에 크기 \(k\) 클리크가 있으면, 보수 그래프 \(\overline{G}\)엔 크기 \(n-k\) 정점덮개가 존재.

---

## 결정 ↔ 탐색 ↔ 최적화: 본질은 같다(자기감소)

- **결정판**을 풀 수 있으면 **탐색판**(실제 해 구하기)도 다항번의 결정 질의로 복원 가능(**self-reduction**).
- **최적화판**: 결정 오라클을 이분탐색/증분으로 호출해 최적 값을 찾아낸다.

```text
# SAT: 결정 → 탐색 (자기감소 예시)

for 변수 x_i:
  if SAT(φ with x_i := 0) then assign x_i=0 else assign x_i=1
return assignment
```

---

## 근사(Approximation)와 PCP: “얼마나 가깝게?”의 경계

### 근사 클래스와 알고리즘

- **PTAS/FPTAS**: (Fully) Polynomial-Time Approximation Scheme.
- **APX**: 상수비 근사 가능 문제군.
- 전형적 예:
  - **SET COVER**: Greedy가 \(1+\ln n\)-근사. \((1-\varepsilon)\ln n\) 이내 근사는 PCP 기반 하에서 **불가능**.
  - **METRIC-TSP**: Christofides 1.5-근사. **1.5보다 좋은 일반 상수**는 미해결.
  - **VERTEX COVER**: 2-근사(단순한 매칭 라운딩).
  - **MAX-CUT**: Goemans–Williamson SDP \(≈0.878\)-근사(UGC 하에서 최적일 가능성).

### PCP 정리 핵심 표어

$$
\mathbf{NP} = \mathbf{PCP}(\log n, O(1)).
$$
- NP 증명은 **상수 개수 쿼리**만으로 **확률적** 검증 가능 → 다수 NP-완전 최적화 문제의 **근사 불가능성**으로 연결.

### UGC(Unique Games Conjecture)

- 여러 문제의 **근사 임계값**을 한 번에 설명하는 강력한 가정. 여전히 **미해결**.
- MAX-CUT \(0.878...\)의 최적성, LABEL-COVER 계열 임계값 등이 UGC로 깔끔히 정리된다.

---

## 파라미터화(FPT)와 구조적 제약

- **FPT**: \(f(k)\cdot n^{O(1)}\) 시간. 작은 파라미터에서 실용적.
  - 예: **VERTEX COVER**는 \(O(2^k + kn)\) 알고리즘, **TREEWIDTH**가 작으면 많은 문제 DP로 P-시간 처리.
- **구조 제약**: 평면 그래프, 유한 트리폭, 이분 그래프, 금지 소소(minor), 메트릭 제약 등에서 P-시간/좋은 근사 가능.

---

## 미세 복잡도(Fine-grained)와 가정

- **ETH**: 3-SAT는 \(2^{o(n)}\) 시간에 풀 수 없다.
- **SETH**: \(k\)-SAT에 대해 \(2^{(1-\varepsilon)n}\) 알고리즘은 존재하지 않음(모든 \(k\)에 대해).
- **결론**: P 안의 많은 문제들(예: Edit Distance, LCS, APSP 등)에서 **차수 수준의 시간 하한**이 유도된다.
- 평균-사례/가우시안 가정, **Planted Clique**, **SSE Hypothesis** 등도 폭넓게 쓰이는 가정군.

---

## 왜 증명이 어려운가 — **증명 장벽**

- **Relativization(상대화)**: 오라클을 붙여도 명제가 유지되는 기법으로는 \( \mathbf{P}\stackrel{?}{=}\mathbf{NP} \)를 해결 못 함(긍·부 오라클 모두 존재).
- **Natural Proofs**: “자연스러운” 회로 하한 증명은 **의사난수** 존재와 충돌 → 강한 회로 하한 증명에 장벽.
- **Algebrization**: 상대화 장벽을 넘는 기법도 **대수화**까지 고려하면 다시 막힘.

> 함의: **새로운 메타 기법**이 필요하다는 공감대.

---

## 실무 로드맵 — NP-완전 문제를 만났을 때

1) **구조 활용**: 평면/트리폭/메트릭 등 구조 파악 → 특화 알고리즘/DP.
2) **근사**: 보장비를 가진 단순·빠른 알고리즘(SET COVER Greedy, VC 2-근사, Christofides).
3) **FPT/커널화**: 해 크기 \(k\), 편차, 컷 크기 등 파라미터로 분기/커널 축소.
4) **무작위화/로컬서치/메타휴리스틱**: 큰 인스턴스의 준최적 해 탐색.
5) **감소 활용**: **SAT/ILP/SMT**로 옮겨 산업용 솔버 사용(자기감소로 해 복원).
6) **하드 제약 vs 소프트 제약**: 페널티·라그랑주 이완·컬럼 생성·컷팅플레인.

---

## 예제·코드 — 감소, 근사, 솔버 감수

### 3-SAT → CLIQUE **생성기/검증기**(파이썬)

```python
# 3-CNF ϕ를 (절마다 3리터럴)로 받고, 그래프 G=(V,E)와 목표 k=m을 생성한다.
# 리터럴은 (var_index, is_neg)로, 절은 [lit1, lit2, lit3] 리스트로 표현한다고 가정.

from itertools import combinations

def three_sat_to_clique(clauses, num_vars):
    # V: 절 j의 리터럴 i를 노드로: (j, i)
    V = [(j, i) for j in range(len(clauses)) for i in range(3)]
    E = set()
    def conflict(l1, l2):
        # (v,neg)와 (v,not neg)이면 충돌
        return l1[0]==l2[0] and l1[1] != l2[1]

    for (j1,i1),(j2,i2) in combinations(V, 2):
        if j1 == j2:
            continue  # 같은 절은 연결 금지
        l1, l2 = clauses[j1][i1], clauses[j2][i2]
        if not conflict(l1,l2):
            E.add(((j1,i1),(j2,i2)))
            E.add(((j2,i2),(j1,i1)))
    k = len(clauses)
    return V, E, k

def is_k_clique(V,E,k,subset):
    # subset은 V의 부분집합. 완전그래프인지 검사
    if len(subset) != k: return False
    for u,v in combinations(subset,2):
        if (u,v) not in E: return False
    return True

def clique_to_assignment(subset, clauses, num_vars):
    # 선택된 각 절의 리터럴로부터 일관 대입을 만든다.
    assign = [None]*(num_vars+1)
    for (j,i) in subset:
        var, neg = clauses[j][i]
        val = (not neg)
        if assign[var] is None:
            assign[var] = val
        elif assign[var] != val:
            return None  # 모순
    # 미지정 변수는 임의로 채운다
    for v in range(1, num_vars+1):
        if assign[v] is None: assign[v] = False
    return assign
```

- 사용법: `three_sat_to_clique`로 그래프 구성 → 클리크 탐색(작은 경우 브루트포스/백트래킹) → `clique_to_assignment`로 해 복원.

### **SET COVER Greedy**( \(1+\ln n\)-근사 )

```python
def greedy_set_cover(U, sets):
    # U: 우주집합(원소의 집합), sets: 리스트 [S1, S2, ...] (각각은 집합)
    covered, chosen = set(), []
    remain = list(sets)
    while covered != U:
        best = max(remain, key=lambda S: len(S - covered))
        if not (best - covered):
            # 더 이상 전진 불가 → 실패(커버 불가) 혹은 U가 이상
            break
        chosen.append(best)
        covered |= best
    return chosen
```

- 표준 분석으로 \((1+\ln |U|)\)-근사 비율 보장.

### **VERTEX COVER 2-근사**(최대 매칭 라운딩)

```python
def vc_two_approx(n, edges):
    # n: 정점 수(0..n-1), edges: (u,v) 리스트
    used = [False]*n
    cover = set()
    for u,v in edges:
        if not used[u] and not used[v]:
            # 매칭에 추가
            used[u]=used[v]=True
            cover.add(u); cover.add(v)
    return cover  # |C| ≤ 2·OPT
```

### **자기감소**(결정 오라클로 해 찾기, SAT 예시 골격)

```python
def find_sat_assignment_with_oracle(phi, oracle_sat_decision):
    # oracle_sat_decision(φ_sub) -> True/False
    assign = {}
    vars_ = sorted(list(phi.variables()))
    cur = phi
    for x in vars_:
        if oracle_sat_decision(cur.fix(x, 0)):
            assign[x]=0; cur = cur.fix(x, 0)
        else:
            assign[x]=1; cur = cur.fix(x, 1)
    return assign
```

---

## 학습·연구에서 자주 만나는 **가정**과 그 함의

| 가정 | 핵심 내용 | 대표 함의 |
|---|---|---|
| **ETH/SETH** | SAT의 \(2^{o(n)}\)/\(2^{(1-\varepsilon)n}\) 불가능 | 정렬·거리·그래프 거리류의 **차수 하한** |
| **UGC** | Unique Games의 근사 난이도 가설 | Max-Cut, VC 등 **임계값** 예측 |
| **SSE** | Small-Set Expansion 가설 | 그래프 분할류 근사 임계 |
| **평균-사례 가정** | Planted Clique 등 | 탐지/추정 경계, 암호 연결 |

> 실전: 논문·보고서에서 “ETH 가정하 \(n^{2-\varepsilon}\) 불가” 같은 문장을 보면 **개선 불가 근거**로 이해하면 된다.

---

## 미니 실험 과제(스스로 손을 움직여 보기)

1) 3-SAT 인스턴스를 직접 만들어 §10.1의 **CLIQUE 감소**를 돌려 보라. 작은 인스턴스에 대해 **브루트포스**로 \(k\)-클리크를 찾고 대입을 복원하라.
2) 임의 생성 SET COVER에 Greedy를 돌리고, 최적해(작은 규모는 MILP/브루트포스)와 **근사비 비교 그래프**를 그려보라.
3) **VERTEX COVER 2-근사**를 만들고, 작은 그래프에서 최적과의 차이를 실험하라.
4) 트리폭이 작은 그래프(예: 그리드 소규모)에 대해 **동적계획**으로 VC/IS/TSP(dec)를 풀어보고, 일반 그래프 대비 성능 차이를 기록하라.

---

## 열린 문제 집중

- **P ?= NP**: 컴퓨팅 이론의 최중요 미해결. 암호·최적화·AI탐색 전반에 격변적 영향.
- **NP vs coNP**: TAUT 등과 얽혀 여전히 미결.
- **NP-중간 문제**: \( \mathbf{P}\ne\mathbf{NP} \)라면 존재(Ladner). **GI**(준다항), **인수분해**(NP∩coNP) 등 경계 사례의 정확한 지위.
- **근사 임계값**: Metric-TSP 1.5 개선 가능 여부, Coloring/Max-Clique의 강한 하한과 알고리즘 간 간극.
- **평균-사례 난이도**: 무작위 3-SAT 임계(클러스터 구조/에너지 경관)와 알고리즘 한계의 정밀 이론화.
- **Fine-grained**: SETH가 옳다면, Edit Distance \(O(n^{2-\varepsilon})\)는 불가인지 등 “**정확 차수**”의 경계.

---

## 한 페이지 정리

- **정의**: NP-완전 = NP에 속하고 NP-어려운 문제. many-one 다항 감소가 표준.
- **증명법**: “NP 포함 + 감소(가젯)” 두 축. 3-SAT가 **출발 허브**.
- **결정·탐색·최적화**는 자기감소로 본질적 동등.
- **근사/PCP/UGC**: 무엇이 **얼마나 가깝게** 가능한지/불가능한지의 하늘선을 제공.
- **가정(ETH/SETH/UGC 등)**: P 내부·외부의 **정밀 하한**을 뒷받침.
- **장벽(Relativization/Natural Proofs/Algebrization)**: 고전적 기법만으론 큰 벽.
- **실무**: 구조 활용, 근사·FPT, 무작위화, 솔버 감수로 해법을 설계하라.

---

## 개요

### Christofides for Metric-TSP (스케치)

1) 최소 신장 트리(MST) \(T\).
2) 홀수 차수 정점 집합 \(O\)에 대해 최소 가중 완전매칭 \(M\).
3) \(T\cup M\)은 모든 정점 짝수 차수 → 오일러 순회 → 단축(shortcut)으로 해밀토니언 순회.
보장: 비용 ≤ 1.5·OPT.

### Goemans–Williamson(Max-Cut)

1) 정수 프로그램 → SDP 이완.
2) SDP 해의 벡터를 무작위 초평면으로 절단.
보장: 기대해 ≥ \(0.878\cdot\)OPT.

---

## 마무리 코멘트

NP-완전성은 “**불가능**”의 딱지가 아니라 “**문제 설계와 해법 전략을 올바르게 고르는 나침반**”이다.
감소로 **경계**를 파악하고, PCP/UGC/ETH로 **한계**를 이해하며, 구조·파라미터·근사·무작위화·솔버 결합으로 **실용적 최적점**을 찾는 것이 핵심이다.
