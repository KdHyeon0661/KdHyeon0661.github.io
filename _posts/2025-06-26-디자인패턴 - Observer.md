---
layout: post
title: 디자인패턴 - Observer
date: 2025-06-26 19:20:23 +0900
category: 디자인패턴
---
# Observer (옵서버 패턴)

## 정의

**옵서버 패턴(Observer Pattern)**은 **Subject(관찰 대상)**의 상태 변화가 발생할 때, 이를 구독 중인 **Observer(관찰자)**에게 **자동으로 통지**하는 행위 패턴이다.
핵심 목표는 **느슨한 결합**과 **동적 구독/해지**를 통한 **반응형 협력**이다.

> “한 객체의 상태 변화가 다수의 객체에 영향을 미칠 때, 직접 결합 없이 변화 통지 메커니즘으로 연결한다.”

---

## 의도와 효과

- **의도**: Subject의 상태 변경을, 그 사실에 관심 있는 다수의 Observer에게 **자동·일관**되게 알린다.
- **효과**
  - **결합도 감소**: Subject은 Observer의 구체 타입을 알 필요가 없다.
  - **동적 확장**: 런타임에 **attach/detach** 가능.
  - **반응형 흐름**: 이벤트 기반 UI, 실시간 데이터, 모델-뷰 동기화에 적합.

---

## 구조(Structure)

### UML(ASCII)

```
┌────────────────┐           attach/detach           ┌────────────────┐
│    Subject     │◄──────────────────────────────────│    Observer    │
│  - observers   │──────────────notify(state)───────▶│ + update(..)   │
│  + attach(o)   │                                     └────────────────┘
│  + detach(o)   │
│  + notify()    │
└────────────────┘
```

- **Subject**: 상태 보유, 옵서버 목록 관리, 변경 시 `notify()`.
- **Observer**: `update(...)`를 통해 통지 수신. Push/Pull 전략에 따라 파라미터 유연.

### Push vs Pull 모델

| 모델 | 설명 | 장점 | 단점 | 예시 |
|---|---|---|---|---|
| Push | `update(new_state)`처럼 **데이터를 밀어넣음** | Observer가 즉시 사용 | 불필요 데이터 전송 | 로그 스트림, 알림 payload 포함 |
| Pull | `update()`만 호출하고 **Observer가 Subject에서 가져감** | 최소 통지, 유연 | 추가 조회 비용 | 모델-뷰에서 필요한 필드만 조회 |

---

## 최소 구현(동기, Push 모델)

```python
class Subject:
    def __init__(self):
        self._observers = []
        self._state = None

    def attach(self, ob):
        if ob not in self._observers:
            self._observers.append(ob)

    def detach(self, ob):
        if ob in self._observers:
            self._observers.remove(ob)

    def set_state(self, value):
        self._state = value
        self.notify(value)  # Push

    def notify(self, value):
        # 안전한 스냅샷을 떠서, 통지 중 detach되어도 문제없게 함
        for ob in list(self._observers):
            ob.update(value)

class Observer:
    def __init__(self, name): self.name = name
    def update(self, new_state):
        print(f"{self.name} <= {new_state}")

s = Subject()
a, b = Observer("A"), Observer("B")
s.attach(a); s.attach(b)
s.set_state("ON")
s.set_state("OFF")
```

---

## Pull 모델(Subject 참조 전달)

```python
class PullSubject:
    def __init__(self):
        self._obs = []
        self.state = None
    def attach(self, ob): self._obs.append(ob)
    def notify(self):
        for ob in list(self._obs):
            ob.update(self)  # self만 전달 (pull)
    def set_state(self, v):
        self.state = v
        self.notify()

class PullObserver:
    def update(self, subject: PullSubject):
        # 필요한 값만 가져간다
        print("state:", subject.state)
```

---

## 메모리 누수 방지: WeakRef 기반 옵서버

파이썬 등 GC 언어에서도 **Subject가 Observer를 강한 참조**로 잡고 있으면 해지 누락 시 누수가 된다. **weakref**를 사용하면 Observer가 GC될 때 자동 제거된다.

```python
import weakref

class WeakSubject:
    def __init__(self):
        self._obs = weakref.WeakSet()
        self.state = None
    def attach(self, ob): self._obs.add(ob)
    def detach(self, ob):
        # WeakSet은 자동 관리되지만 명시적 해지도 허용
        try: self._obs.remove(ob)
        except KeyError: pass
    def set_state(self, v):
        self.state = v
        for ob in list(self._obs):
            ob.update(self)  # pull 예시
```

---

## 버전

- 공용 컬렉션(옵서버 목록) 접근과 **notify 중 변경**을 보호.
- 통지 순환을 막기 위해 **변경 버전(version)** 혹은 **reemtrant guard**를 둘 수 있다.

```python
import threading

class ThreadSafeSubject:
    def __init__(self):
        self._lock = threading.RLock()
        self._obs = []
        self._state = None

    def attach(self, ob):
        with self._lock:
            if ob not in self._obs:
                self._obs.append(ob)

    def detach(self, ob):
        with self._lock:
            if ob in self._obs:
                self._obs.remove(ob)

    def set_state(self, v):
        with self._lock:
            self._state = v
            snapshot = list(self._obs)
        # 락을 쥔 채로 콜백을 호출하지 않는다(교착 회피)
        for ob in snapshot:
            ob.update(v)

    def get_state(self):
        with self._lock:
            return self._state
```

운영 팁
- **락 보유 중 콜백 호출 금지**: 콜백이 역호출로 attach/detach하거나 다른 락을 잡아 **교착** 가능.
- **스냅샷 후 호출**: 목록을 복사한 뒤 락 해제, 콜백 호출.

---

## 비동기 옵서버(asyncio)

UI·네트워킹·I/O 바인딩 시스템에서는 비동기 통지가 자연스럽다.

```python
import asyncio
from typing import Awaitable, Callable, List, Union

AsyncObserver = Union[Callable[[str], Awaitable[None]],
                      Callable[[str], None]]

class AsyncSubject:
    def __init__(self):
        self._obs: List[AsyncObserver] = []
    def attach(self, ob: AsyncObserver): self._obs.append(ob)
    async def notify(self, value: str):
        tasks = []
        for ob in list(self._obs):
            ret = ob(value)
            if asyncio.iscoroutine(ret):
                tasks.append(ret)
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)
    async def set_state(self, v: str):
        await self.notify(v)

async def aobs(x):
    await asyncio.sleep(0.01)
    print("A:", x)

def bobs(x):
    print("B:", x)

async def main():
    s = AsyncSubject()
    s.attach(aobs); s.attach(bobs)
    await s.set_state("READY")

asyncio.run(main())
```

비동기 설계 포인트
- **예외 처리**: 한 옵서버의 예외가 전체 통지를 막지 않게 `return_exceptions=True`로 모아 처리.
- **순서 보장**: 필요 시 await 순차 실행, 그렇지 않으면 동시 수신으로 처리량 향상.

---

## 이벤트 폭주 완화: 디바운스·스로틀·배치

대량 통지 상황(스크롤, 센서, 로그)에서 **CPU/렌더링 폭주**를 방지하려면 Subject 측에서 **디바운스**, **스로틀**, **배치**를 적용한다.

### 디바운스(마지막 값만 특정 지연 후 전파)

```python
import threading, time

class DebouncedSubject:
    def __init__(self, delay=0.05):
        self._obs = []
        self._t = None
        self._last = None
        self.delay = delay
        self._lock = threading.Lock()

    def attach(self, ob): self._obs.append(ob)

    def set_state(self, v):
        with self._lock:
            self._last = v
            if self._t and self._t.is_alive():
                return  # 타이머 이미 동작 중
            self._t = threading.Timer(self.delay, self._flush)
            self._t.start()

    def _flush(self):
        with self._lock:
            val = self._last
            snapshot = list(self._obs)
        for ob in snapshot:
            ob.update(val)
```

### 스로틀(주기당 최대 1회)

```python
class ThrottledSubject:
    def __init__(self, period=0.1):
        self._obs = []; self.period = period
        self._last_ts = 0

    def attach(self, ob): self._obs.append(ob)

    def set_state(self, v):
        now = time.time()
        if now - self._last_ts >= self.period:
            self._last_ts = now
            for ob in list(self._obs): ob.update(v)
```

### 배치(정해진 건수/시간마다 묶어 전파)

```python
class BatchingSubject:
    def __init__(self, size=10):
        self._obs = []; self._buf = []; self.size = size
    def attach(self, ob): self._obs.append(ob)
    def push(self, item):
        self._buf.append(item)
        if len(self._buf) >= self.size:
            batch = self._buf; self._buf = []
            for ob in list(self._obs): ob.update(batch)
```

---

## 백프레셔와 복잡도

- 한 번의 통지에 M개의 옵서버가 있다면 **시간 복잡도는 대체로 O(M)**.
- 통지 도착률을 \(\lambda\), 각 옵서버 평균 처리율을 \(\mu\)라고 할 때, 단순 대기열 근사로 **혼잡도 \(\rho=\lambda/\mu\)** 가 1에 근접하면 지연이 급증한다.
- 다수 옵서버가 느릴 경우:
  - **버퍼 제한** + 드롭 정책(최신 우선, 샘플링)
  - **워커 풀**(병렬 처리) + 옵서버 수준의 타임아웃
  - **우선순위 통지**(핵심 옵서버 우선)

---

## 형식화된 이벤트: 타입 세이프 이벤트 버스

이벤트를 **형식화(dataclass)**하면 payload 일관성과 문서화가 좋아진다.

```python
from dataclasses import dataclass
from typing import Dict, List, Callable, Type, Any

@dataclass(frozen=True)
class PriceChanged: symbol: str; price: float
@dataclass(frozen=True)
class Connected:    node: str

class EventBus:
    def __init__(self):
        self._map: Dict[Type[Any], List[Callable[[Any], None]]] = {}
    def subscribe(self, etype: Type[Any], handler: Callable[[Any], None]):
        self._map.setdefault(etype, []).append(handler)
    def publish(self, evt: Any):
        for h in list(self._map.get(type(evt), [])):
            h(evt)

bus = EventBus()
bus.subscribe(PriceChanged, lambda e: print("tick:", e.symbol, e.price))
bus.publish(PriceChanged("AAPL", 199.3))
```

장점
- 이벤트 스키마가 **코드로 가시화**.
- 린타·IDE 지원으로 **오류 조기 발견**.

---

## MVC/MVVM와의 통합

- **MVC**: Model이 Subject, View/Controller가 Observer. 모델 변경 시 뷰 갱신.
- **MVVM**: ViewModel이 Subject, View가 Observer. 파이썬에서는 속성 setter에서 `notify()` 호출.

```python
class VM:
    def __init__(self): self._obs = []; self._value = 0
    def attach(self, ob): self._obs.append(ob)
    @property
    def value(self): return self._value
    @value.setter
    def value(self, v):
        if v != self._value:
            self._value = v
            for ob in list(self._obs): ob.update(v)
```

---

## 순환 통지/루프 방지

- **버전/리비전 토큰**: 변경마다 `rev += 1`, Observer는 마지막 본 rev를 기록해 **반복 통지** 회피.
- **재진입 가드**: `notifying` 플래그로 통지 중 발생한 재귀 통지 차단.
- **그래프 토폴로지**: 가능한 한 **DAG형 의존** 유지, 강결합 피하기.

```python
class GuardedSubject:
    def __init__(self): self._obs = []; self._notifying = False
    def attach(self, ob): self._obs.append(ob)
    def notify(self, v):
        if self._notifying: return
        self._notifying = True
        try:
            for ob in list(self._obs): ob.update(v)
        finally:
            self._notifying = False
```

---

## 오류 처리 전략

- 한 옵서버의 예외가 전체 통지 실패를 만들지 않도록 **개별 try/except**.
- 오류는 **수집·로깅** 후 계속 진행, 혹은 정책에 따라 **Fail-fast**.
- 비동기에서는 예외를 **이벤트**로 다시 발행하거나, **콜백**으로 전달.

```python
def safe_notify(obs, val, logger=print):
    for ob in list(obs):
        try: ob.update(val)
        except Exception as e:
            logger(f"observer {ob} error: {e}")
```

---

## 테스트·운영 체크리스트

- **구독/해지 테스트**: attach/detach가 즉시 반영되는가.
- **누수 점검**: WeakRef 사용 여부, 해지 누락 경고 로깅.
- **동시성**: 스냅샷 후 통지, 락 범위 최소화, 교착 유무.
- **성능**: N 옵서버·초당 K 이벤트에서 지연/CPU/메모리 측정.
- **에러 격리**: 한 옵서버 실패가 전체를 중단시키지 않는가.
- **폭주 제어**: 디바운스/스로틀/배치/드롭 정책 검증.
- **백프레셔**: 큐 길이 모니터링, 알림 임계치 경고.

---

## Observer vs Mediator vs Event Bus

| 패턴 | 목적 | 관계 | 장점 | 약점 |
|---|---|---|---|---|
| Observer | 상태 변경 통지 | 1 → N | 단순, 가벼움 | 대형 시스템에서 흐름 추적 난해 |
| Mediator | 상호작용 중재 | M ↔ M → 중앙 1 | 의존성 감소 | 중재자 비대화 위험 |
| Event Bus | 이벤트 라우팅 | Pub → Bus → Sub | 모듈 경계 명확 | 디버깅 복잡, 전역 의존화 우려 |

---

## 자주 쓰는 변형

- **PropertyChange**: 필드별 구독, 변경 전(old)/후(new) 값 제공.
- **Once** 구독: 1회 통지 후 자동 해지.
- **Filtered** 구독: 조건(predicate)에 맞는 이벤트만 수신.
- **Buffered** 구독: 일정 기간/개수 버퍼링 후 일괄 전달.

```python
class OnceObserver:
    def __init__(self, subject, fn):
        self.subject = subject; self.fn = fn
        subject.attach(self)
    def update(self, v):
        try: self.fn(v)
        finally: self.subject.detach(self)
```

---

## 간단 예제: 주가 알림(필터·형식화)

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class PriceTick: symbol: str; price: float

class Ticker:
    def __init__(self): self._obs = []
    def attach(self, ob): self._obs.append(ob)
    def tick(self, evt: PriceTick):
        for ob in list(self._obs):
            ob.update(evt)

class PriceAbove:
    def __init__(self, sym, threshold):
        self.sym, self.th = sym, threshold
    def update(self, evt: PriceTick):
        if evt.symbol == self.sym and evt.price > self.th:
            print("ALERT:", evt)

t = Ticker()
t.attach(PriceAbove("AAPL", 200.0))
t.tick(PriceTick("AAPL", 199.9))
t.tick(PriceTick("AAPL", 200.1))  # 조건 만족
```

---

## 수학적 메모: 통지 비용과 기대 알림 수

- 옵서버가 \(N\)명이고, 각 통지에 대해 실제로 반응할 확률이 \(p\)라면, **기대 반응 수**는
  \[
  \mathbb{E}[\text{react}] = N \cdot p.
  \]
- 통지 1건의 비용이 \(c\), 옵서버 순회 비용이 \(aN\)이라면, 1회 통지 총비용 근사는
  \[
  T \approx aN + c \cdot Np.
  \]
  필터·배치·디바운스를 통해 \(N\) 또는 \(p\)를 효과적으로 낮추면 총비용이 줄어든다.

---

## 안티패턴과 주의점

- **강참조 누수**: detach 누락으로 Observer가 영구 잔존 → **WeakRef** 또는 **컨텍스트 관리자** 사용.
- **락 보유 중 콜백**: 교착/장기 지연 → **스냅샷 후 호출**.
- **무한 루프**: 통지 → 상태 변경 → 재통지 반복 → **가드/버전**으로 차단.
- **과도한 전파**: 초당 수천 통지 → **디바운스/스로틀/배치/드롭**.
- **전역 이벤트 남용**: 흐름 추적 불가 → **도메인별 버스 분리**, **관찰 그래프 문서화**.

---

## 정리

- 옵서버 패턴은 **상태 변화의 자동 통지**를 통해 **느슨한 결합**을 실현한다.
- **Push/Pull**, **동기/비동기**, **스레드 안전**, **WeakRef**, **디바운스/스로틀/배치** 등 실무 요소를 더하면 대규모 시스템에서도 견고하게 동작한다.
- 핵심 운영 포인트는 **누수 방지**, **교착 회피**, **폭주 제어**, **오류 격리**, **가시화(로그·트레이스)**다.

위의 구성과 예제들을 기반으로, UI 바인딩, 실시간 데이터 피드, 로그 파이프라인, 모델-뷰 동기화 등 다양한 상황에 **바로 적용 가능한 옵서버 설계**를 구축할 수 있다.
~~~markdown
