---
layout: post
title: 디자인패턴 - Observer
date: 2025-06-26 19:20:23 +0900
category: 디자인패턴
---
# Observer (옵서버 패턴)

## ✅ 정의

**옵서버 패턴(Observer Pattern)**은 **객체의 상태 변화**를 감지하고, 그 변화를 **의존하고 있는 객체들(옵서버)**에게 **자동으로 알림을 보내는 행위 패턴**입니다.  
주로 **이벤트 기반 시스템**이나 **UI**, **실시간 데이터 반응**이 필요한 경우에 사용됩니다.

> “한 객체의 상태 변화가 여러 객체에 영향을 미칠 때, 상태 변경을 자동으로 통지”

---

## 🎯 의도 (Intent)

- **Subject(관찰 대상)**의 상태가 바뀌면, 해당 변화를 **Observer(관찰자)**들에게 자동으로 알림
- Subject와 Observer 간의 **결합도를 낮추고**, **동적 관계 형성**을 가능하게 함

---

## 📦 구조 (UML)

```
┌────────────┐
│  Subject   │◄────────────┐
└────┬───────┘             │
     │                     │
     ▼     attach/detach   │
┌────────────┐     update  │
│  Observer  │─────────────┘
└────────────┘
```

- `Subject`: 상태를 가지고 있으며, Observer 목록을 관리
- `Observer`: Subject의 상태 변화에 반응하는 객체

---

## 🧑‍💻 구현 예시 (Python)

```python
# Subject (관찰 대상)
class Subject:
    def __init__(self):
        self._observers = []
        self._state = None

    def attach(self, observer):
        self._observers.append(observer)

    def detach(self, observer):
        self._observers.remove(observer)

    def notify(self):
        for observer in self._observers:
            observer.update(self._state)

    def set_state(self, value):
        self._state = value
        print(f"[Subject] 상태가 '{value}'로 변경됨")
        self.notify()

# Observer (관찰자)
class Observer:
    def __init__(self, name):
        self.name = name

    def update(self, new_state):
        print(f"  └─ {self.name}가 상태 변경을 감지: {new_state}")

# 사용 예시
subject = Subject()
obs1 = Observer("Observer A")
obs2 = Observer("Observer B")

subject.attach(obs1)
subject.attach(obs2)

subject.set_state("ON")
subject.set_state("OFF")
```

**출력 예시:**
```
[Subject] 상태가 'ON'로 변경됨
  └─ Observer A가 상태 변경을 감지: ON
  └─ Observer B가 상태 변경을 감지: ON
[Subject] 상태가 'OFF'로 변경됨
  └─ Observer A가 상태 변경을 감지: OFF
  └─ Observer B가 상태 변경을 감지: OFF
```

---

## ✅ 장점

- **Subject와 Observer 간 결합도 낮음 (느슨한 연결)**
- **다수 객체 동기화**가 용이
- 동적으로 **옵서버를 추가/제거** 가능
- UI/실시간 처리에 적합

---

## ⚠️ 단점

- 옵서버 수가 많으면 **알림 비용이 증가**함
- **순환 참조**나 **무한 루프** 발생 가능성 있음 (주의 필요)
- 상태 변경 시 원인을 추적하기 어려울 수 있음 (디버깅 어려움)

---

## 📌 사용 사례

| 분야 | 예시 |
|------|------|
| **UI 프레임워크** | 버튼 클릭, 텍스트 변경, React 상태 변경 등 |
| **이벤트 처리기** | 마우스, 키보드, 센서 이벤트 |
| **데이터 스트림** | RxJS, LiveData, Flow 등 |
| **모델-뷰 연결** | MVC, MVVM에서 View는 Model을 옵서버로 구독 |
| **Pub/Sub 시스템** | Redis, Kafka, MQTT 기반 메시징 |
| **알림 시스템** | 주가 변동 알림, 채팅 알림 등

---

## 🧠 Observer vs Mediator vs Event Bus

| 패턴       | 목적 | 구조 | 단방향/양방향 |
|------------|------|------|----------------|
| **Observer** | 상태 변화 알림 | 1:N 관계 | 단방향 |
| **Mediator** | 통신 중재 | M:M → 1:M:M | 양방향 |
| **Event Bus** | 이벤트 전달 | Publisher → Bus → Subscriber | 단방향 (중앙 집중)

---

## 🧠 마무리

**옵서버 패턴은 객체 간의 동적인 종속 관계를 구현할 수 있도록 도와주는 강력한 패턴입니다.**  
상태 변화가 여러 객체에 영향을 미쳐야 할 때, 직접적인 참조 없이 유연하게 연결할 수 있습니다.

다만, 옵서버 간 **루프, 중복 알림, 상태 동기화 문제** 등은 설계 시 반드시 주의해야 합니다.