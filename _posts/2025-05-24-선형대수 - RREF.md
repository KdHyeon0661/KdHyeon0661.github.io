---
layout: post
title: 선형대수 - RREF
date: 2025-05-24 20:20:23 +0900
category: 선형대수
---
# RREF (기약 행 사다리꼴) 완전 정복

**핵심 요약**  
- **RREF**(Reduced Row Echelon Form)는 연립 1차 방정식과 벡터공간의 구조를 가장 간단히 드러내는 표준형이다.  
- **가우스-조르당 소거**로 항상 RREF에 도달할 수 있고, **RREF는 유일**하다.  
- **피벗 열 ↔ 기저변수**, **비피벗 열 ↔ 자유변수**. 랭크, 해의 개수, 기저, 영공간 등 핵심 정보가 한눈에 보인다.  
- 실전에서는 부동소수점 오차를 고려해 **부분 피벗팅**과 **허용오차(tolerance)** 가 필수다.

---

## 1. 정의와 성질

### 1.1 REF와 RREF의 차이
- **REF**(Row Echelon Form, 행 사다리꼴):  
  1) 0이 아닌 행은 위쪽에, 2) 각 행의 선도 원소(피벗)는 그 윗행 피벗보다 오른쪽, 3) 피벗 아래는 0.
- **RREF**(기약 행 사다리꼴):  
  REF 조건에 더해  
  4) 모든 피벗은 **정확히 1**, 5) **피벗이 위치한 열의 다른 원소는 모두 0**.

**중요**: 임의의 행렬은 가우스-조르당 소거로 **항상 RREF**에 도달하며, 그 RREF는 **유일**하다.

### 1.2 기하학적 직관
- **피벗 개수 = 랭크**: 행(또는 열) 공간의 차원.  
- **자유변수 개수 = 열의 수 − 랭크**: 영공간의 차원(널리티).  
- RREF는 선형사상에서 좌표축을 정리해 “문제의 자유도와 제약”을 분해한 결과라고 볼 수 있다.

---

## 2. 해석 도구로서의 RREF

### 2.1 해의 분류와 RREF
연립방정식 $$A x = b$$ 의 확대행렬 $$[A \mid b]$$ 를 RREF로 만들면:

- **모순 행**(왼쪽이 전부 0, 오른쪽이 0이 아님) $$\Rightarrow$$ **해 없음**.  
- **피벗 열의 개수 = 변수 수** $$\Rightarrow$$ **유일해**.  
- **피벗 열의 개수 < 변수 수**, 모순 없음 $$\Rightarrow$$ **무수히 많은 해**(자유변수 존재).

### 2.2 공간의 기저
- **행공간(Row space)**: RREF의 **0이 아닌 행들**이 기저를 이룬다.  
- **열공간(Column space)**: **원래 행렬의 피벗 열**들이 기저를 이룬다.  
- **영공간(Null space)**: RREF에서 **자유변수**를 매개로 해를 파라미터화하면 얻게 되는 **특수해들의 집합**.  
- **왼쪽 영공간(Null space of $$A^\top$$)**: $$A^\top$$ 의 RREF로 같은 방식으로 구한다.

### 2.3 랭크-널리티 정리
열의 수를 $$n$$, 랭크를 $$r$$, 널리티(영공간 차원)를 $$\nu$$ 라 하면  
$$
r + \nu = n.
$$

---

## 3. 가우스-조르당 소거(부분 피벗팅 포함) 절차

1) 가장 왼쪽 열부터 오른쪽으로 진행하며, 현재 열에서 **절댓값이 가장 큰 피벗 후보**를 찾고 **행 교환**(부분 피벗팅).  
2) 피벗을 **1**로 만든다(행 전체를 나눔).  
3) 그 열의 **다른 모든 행 원소를 0**으로 만든다(행 조합).  
4) 다음 피벗을 오른쪽 아래 방향으로 진행.  
5) 모든 열을 처리하면 RREF.

**계산복잡도**: 일반적으로 $$m \times n$$ 행렬에 대해 약 $$O(m n \min(m,n))$$, 정방 $$n\times n$$ 은 $$O(n^3)$$.

---

## 4. 손으로 풀어보는 예시

### 4.1 유일해
행렬
$$
A=\begin{bmatrix}
1&2&-1\\
0&1&3\\
0&0&2
\end{bmatrix},\quad
b=\begin{bmatrix}
4\\
5\\
-2
\end{bmatrix}.
$$

확대행렬을 RREF로 만들면 **모순 없음**, 피벗 열 3개(변수 3개와 동일) $$\Rightarrow$$ **유일해**.  
후방 대입 또는 RREF에서 바로 읽어 해를 얻는다.

### 4.2 무수히 많은 해(자유변수 존재)
$$
A=\begin{bmatrix}
1&2&-1\\
2&4&-2\\
0&0&1
\end{bmatrix},\quad
b=\begin{bmatrix}
1\\
2\\
3
\end{bmatrix}.
$$
두 번째 행은 첫 번째의 배수. RREF로 가면 피벗 열 2개, 변수 3개 $$\Rightarrow$$ 자유변수 1개.  
자유변수를 $$t$$ 로 두고 해를 파라미터화.

### 4.3 해 없음(모순)
$$
A=\begin{bmatrix}
1&1\\
2&2
\end{bmatrix},\quad
b=\begin{bmatrix}
1\\
3
\end{bmatrix}.
$$
RREF에서 $$[0\ 0 \mid 1]$$ 형태의 **모순 행**이 나타난다 $$\Rightarrow$$ **해 없음**.

---

## 5. PyTorch로 RREF 구현 및 실전 유틸(피벗/기저/해 분류)

아래 코드는 모두 **PyTorch** 기반이다(부동소수점 오차를 고려하여 `dtype=torch.float64`, 허용오차 사용).

```python
import torch

DT = torch.float64

def rref_torch(A: torch.Tensor, tol: float = 1e-12):
    """
    RREF 계산 (부분 피벗팅 포함)
    반환: R, pivot_cols
      - R: RREF 형태
      - pivot_cols: 피벗이 선 행의 열 인덱스 리스트
    """
    A = A.clone().to(DT)
    m, n = A.shape
    R = A.clone()
    pivot_cols = []
    row = 0
    for col in range(n):
        if row >= m:
            break
        # 부분 피벗팅: |R[row:, col]| 최대인 곳을 피벗 후보로
        col_slice = torch.abs(R[row:, col])
        max_val, max_idx_rel = torch.max(col_slice, dim=0)
        if max_val <= tol:
            continue
        max_idx = row + int(max_idx_rel.item())
        if max_idx != row:
            R[[row, max_idx]] = R[[max_idx, row]]
        # 피벗을 1로 정규화
        pivot = R[row, col]
        R[row, :] = R[row, :] / pivot
        # 피벗 열의 다른 행을 0으로
        for r in range(m):
            if r != row:
                factor = R[r, col]
                if abs(factor) > tol:
                    R[r, :] -= factor * R[row, :]
        pivot_cols.append(col)
        row += 1
    # 작은 수를 0으로 정리(보기 좋게)
    R[torch.abs(R) < tol] = 0.0
    return R, pivot_cols

def augmented_rref(A: torch.Tensor, b: torch.Tensor, tol: float = 1e-12):
    """
    확대행렬 [A | b] 를 RREF로 변환하여 (R_aug, pivot_cols) 반환
    """
    A = A.to(DT); b = b.to(DT).reshape(-1, 1)
    Ab = torch.cat([A, b], dim=1)
    R_aug, piv = rref_torch(Ab, tol=tol)
    return R_aug, piv

def classify_and_solve(A: torch.Tensor, b: torch.Tensor, tol: float = 1e-12):
    """
    RREF로 해의 상태를 분류하고(유일/무수히 많음/없음),
    - unique: x 반환
    - infinite: particular x_p 와 nullspace basis 반환
    - none: None
    """
    m, n = A.shape
    R_aug, pivot_cols = augmented_rref(A, b, tol=tol)
    R = R_aug[:, :n]
    rhs = R_aug[:, n:]
    # 모순 검사: [0 ... 0 | c], c != 0
    for i in range(m):
        if torch.all(torch.abs(R[i, :]) <= tol) and torch.abs(rhs[i, 0]) > tol:
            return {"type": "inconsistent", "x": None}

    piv_set = set(pivot_cols)
    free_cols = [j for j in range(n) if j not in piv_set]

    if len(pivot_cols) == n:
        # 유일해: 자유변수 없음. 각 피벗행에서 바로 읽기
        x = torch.zeros(n, dtype=DT)
        pivot_row = 0
        for col in range(n):
            if col in piv_set:
                x[col] = rhs[pivot_row, 0]
                pivot_row += 1
        return {"type": "unique", "x": x}

    # 무수히 많은 해: 자유변수 존재
    # 특정해 x_p: 자유변수=0으로 두고 피벗에서 읽기
    x_p = torch.zeros(n, dtype=DT)
    # pivot_row와 pivot_col의 개수는 동일
    for r, c in enumerate(pivot_cols):
        x_p[c] = rhs[r, 0]

    # nullspace basis 구성
    null_basis = []
    for j in free_cols:
        v = torch.zeros(n, dtype=DT)
        v[j] = 1.0
        # 각 피벗변수는 v[c] = -R[r, j]
        for r, c in enumerate(pivot_cols):
            v[c] = -R[r, j]
        null_basis.append(v)

    return {"type": "infinite", "x_particular": x_p, "nullspace_basis": null_basis, "free_cols": free_cols}

def row_space_basis(A: torch.Tensor, tol: float = 1e-12):
    R, _ = rref_torch(A, tol=tol)
    rows = []
    for i in range(R.shape[0]):
        if torch.any(torch.abs(R[i, :]) > tol):
            rows.append(R[i, :])
    return rows  # RREF의 0이 아닌 행들

def col_space_basis(A: torch.Tensor, tol: float = 1e-12):
    R, piv = rref_torch(A, tol=tol)
    # 열공간 기저는 '원래 행렬 A'의 피벗 열들
    return [A[:, j] for j in piv]

def null_space_basis(A: torch.Tensor, tol: float = 1e-12):
    m, n = A.shape
    R, pivot_cols = rref_torch(A, tol=tol)
    piv_set = set(pivot_cols)
    free_cols = [j for j in range(n) if j not in piv_set]

    basis = []
    for j in free_cols:
        v = torch.zeros(n, dtype=DT)
        v[j] = 1.0
        for r, c in enumerate(pivot_cols):
            v[c] = -R[r, j]
        basis.append(v)
    return basis

def left_null_space_basis(A: torch.Tensor, tol: float = 1e-12):
    return null_space_basis(A.T, tol=tol)
```

---

## 6. 예제: 해 분류, 기저, 랭크-널리티 확인

### 6.1 유일해
```python
A = torch.tensor([[1., 2., -1.],
                  [0., 1.,  3.],
                  [0., 0.,  2.]], dtype=DT)
b = torch.tensor([4., 5., -2.], dtype=DT)

info = classify_and_solve(A, b)
print(info["type"])  # "unique"
print("x =", info["x"])  # 유일해
```

### 6.2 무수히 많은 해(자유변수)
```python
A = torch.tensor([[1., 2., -1.],
                  [2., 4., -2.],
                  [0., 0.,  1.]], dtype=DT)
b = torch.tensor([1., 2., 3.], dtype=DT)

info = classify_and_solve(A, b)
print(info["type"])                     # "infinite"
print("x_particular =", info["x_particular"])
print("free_cols    =", info["free_cols"])
print("nullspace basis vectors (columns):")
for v in info["nullspace_basis"]:
    print(v)
```

**해석**  
- 자유변수를 $$t$$ 로 두면 해는 $$x = x_p + t \, v_1$$ 꼴.  
- **영공간 차원 = 자유변수 수**.

### 6.3 해 없음
```python
A = torch.tensor([[1., 1.],
                  [2., 2.]], dtype=DT)
b = torch.tensor([1., 3.], dtype=DT)

info = classify_and_solve(A, b)
print(info["type"])  # "inconsistent"
```

### 6.4 행공간/열공간/영공간/왼쪽영공간 기저
```python
A = torch.tensor([[1., 2., -1.],
                  [2., 4.,  3.],
                  [3., 6.,  2.]], dtype=DT)

rows = row_space_basis(A)
cols = col_space_basis(A)
nulls = null_space_basis(A)
lnulls = left_null_space_basis(A)

print("row space basis:")
for r in rows: print(r)

print("column space basis (original A's pivot columns):")
for c in cols: print(c)

print("null space basis:")
for v in nulls: print(v)

print("left null space basis:")
for v in lnulls: print(v)

# 랭크-널리티 검증
rank = len(rows)
n = A.shape[1]
nullity = len(nulls)
print("rank + nullity =", rank + nullity, " (should be n =", n, ")")
```

---

## 7. RREF로 역행렬 계산(증강행렬)

정방 가역행렬 $$A$$ 에 대해 $$[A \mid I]$$ 를 RREF로 만들면 $$[I \mid A^{-1}]$$ 를 얻는다. 아래는 교육용 데모(실전에서는 `torch.linalg.solve(A, I)` 권장).

```python
def inverse_via_rref(A: torch.Tensor, tol: float = 1e-12):
    n = A.shape[0]
    I = torch.eye(n, dtype=DT)
    Aug = torch.cat([A.to(DT), I], dim=1)          # [A | I]
    R, _ = rref_torch(Aug, tol=tol)                # [I | A^{-1}]가 되어야 함
    left = R[:, :n]; right = R[:, n:]
    if not torch.allclose(left, torch.eye(n, dtype=DT), atol=1e-8):
        raise RuntimeError("A가 특이이거나 수치적으로 불안정하여 역행렬을 얻지 못했습니다.")
    return right

# 예제
A = torch.tensor([[2., 3.],
                  [1., 4.]], dtype=DT)
Ainv = inverse_via_rref(A)
print("A^{-1} via RREF:\n", Ainv)
print("check A @ A^{-1}:\n", A @ Ainv)
```

---

## 8. 수치적 주의사항과 실전 팁

1) **부분 피벗팅 필수**: 작은 피벗은 오차를 크게 증폭한다. 위 구현은 열마다 절댓값 최대를 피벗으로 선택한다.  
2) **허용오차 설정**: 데이터 스케일에 따라 `tol` 을 조정하라. 너무 작으면 잡음에 민감, 너무 크면 유효한 피벗을 놓칠 수 있다.  
3) **스케일링/정규화**: 열 스케일 불균형이 심하면 사전에 정규화하면 안정성이 좋아진다.  
4) **정방·가역이 아니면 역행렬 없음**: 이 경우엔 RREF로 해의 구조를 분석하거나, 필요하면 SVD 기반 의사역행렬을 사용한다.  
5) **속도**: 대규모 문제에서는 직접 RREF보다 `torch.linalg.solve`(혹은 특수구조에 맞는 분해: 대칭양정이면 Cholesky)가 더 빠르고 안정적이다.

---

## 9. 연습문제(스스로 확인)

1) 임의의 $$3\times 4$$ 행렬을 생성해 RREF로 변환하고, 랭크-널리티 정리를 수치로 확인하라.  
2) 임의의 정방행렬 $$A$$ 에 대해 $$[A \mid I]$$ 를 RREF로 변환해 $$A^{-1}$$ 을 얻고, `torch.linalg.solve(A, I)` 결과와 비교하라.  
3) 데이터 행렬 $$X$$ 에서 RREF로 **열공간 기저**를 뽑아 **피처 선택**을 수행해보라(피벗 열들만 선택).  
4) 임의의 $$A, b$$ 에 대해 `classify_and_solve` 로 해의 유형을 분류하고, 무수히 많은 해일 때 **특정해 + 영공간 기저** 형태로 해를 구성하라.

---

## 10. 핵심 정리

- RREF는 **해의 구조(유일/무한/없음)**, **랭크와 자유도**, **기저 벡터**를 즉시 드러낸다.  
- **피벗 열 = 기저변수**, **비피벗 열 = 자유변수**, **피벗 개수 = 랭크**.  
- 실전에서는 **안정성(피벗팅, tol)** 과 **적합한 분해법 선택**(solve/Cholesky/QR/SVD)을 병행하라.