---
layout: post
title: 알고리즘 - 스택 관련 문제
date: 2025-01-01 19:20:23 +0900
category: 알고리즘
---
# 스택을 활용한 알고리즘 문제들

## 스택 기본기 리마인드

- **정의**: 후입선출(LIFO). `push`, `pop`, `top/peek`, `empty`.
- **시간복잡도**: 표준 배열/리스트 기반 구현에서 각 연산은 $$O(1)$$ 평균.
- **전형적 용도**
  1) **파싱/검사**: 괄호 짝, 수식 파싱, HTML/XML 구조 검사
  2) **탐색/시뮬**: DFS 반복화, undo/redo, 브라우저 앞/뒤
  3) **모노토닉 스택**: 최근/가까운 더 큰(작은) 값, 영역 확장(히스토그램)
  4) **트리/그래프**: 비재귀 순회, Tarjan(SCC) 내부 스택
  5) **자료구조 변형**: MinStack, 두 스택으로 큐/큐로 스택

---

## — 재귀를 스택으로 바꾸기

### 핵심 아이디어(원고 요점 보강)

- 재귀 DFS의 **호출 스택**을 **명시적 스택**으로 옮긴다.
- 인접 정점 방문 순서를 통제하려면 **스택에 넣는 순서**를 조정한다.

### 스택 기반 DFS 코드 (정점 오름차순 방문)

```python
def dfs_stack(graph, start):
    visited = set()
    stack = [start]
    while stack:
        u = stack.pop()
        if u in visited:
            continue
        visited.add(u)
        print(u, end=' ')
        # 오름차순 방문 → 스택에 역순 삽입
        for v in sorted(graph[u], reverse=True):
            if v not in visited:
                stack.append(v)
```

### 검증: 루프 불변식

- 매 반복 진입 시 `visited`는 **이미 출력 완료된 정점 집합**이고, `stack`에는 **아직 탐색할 정점**만 있다.
- 각 간선은 최대 2회 확인 → 시간복잡도 $$O(V+E)$$.

### 실전 팁

- 그래프가 **희소**면 인접 리스트, **조밀**이면 인접 행렬 고려.
- **연결 요소** 전체를 방문하려면 모든 미방문 정점을 시작점으로 반복.

---

## + 후위 평가

### 중위 → 후위 (Shunting Yard 요지)

- **연산자 스택**으로 우선순위/괄호 처리.
- 동일 우선순위는 **좌결합**이면 pop 후 push.

```python
def infix_to_postfix(expr):
    prec = {'+':1, '-':1, '*':2, '/':2}
    stack = []
    out = []
    for ch in expr:
        if ch.isalpha() or ch.isdigit():
            out.append(ch)
        elif ch == '(':
            stack.append(ch)
        elif ch == ')':
            while stack and stack[-1] != '(':
                out.append(stack.pop())
            stack.pop()  # '(' 제거
        else:  # operator
            while stack and stack[-1] != '(' and prec[ch] <= prec.get(stack[-1], 0):
                out.append(stack.pop())
            stack.append(ch)
    while stack:
        out.append(stack.pop())
    return ''.join(out)
```

### 후위 표기식 평가

```python
def eval_postfix(tokens):
    st = []
    for t in tokens:
        if t.isdigit():
            st.append(int(t))
        else:
            b = st.pop(); a = st.pop()
            if t == '+': st.append(a+b)
            elif t == '-': st.append(a-b)
            elif t == '*': st.append(a*b)
            elif t == '/': st.append(int(a/b))  # 정수 나눗셈 규칙에 주의
    return st.pop()
```

### 확장: 단항, 공백, 다자리 수, 음수

- 토크나이저로 공백/다자리수를 처리.
- `-`가 **단항 음수**인지 **이항 빼기**인지 **문맥**으로 구분.

---

## 히스토그램에서 가장 큰 직사각형 — 모노토닉 증가 스택

### 핵심(원고 보강)

- 스택에 **높이가 증가하는 인덱스**를 유지.
- 더 낮은 막대를 만나면 **이전 고점**들을 pop하며 면적 계산.

```python
def largest_rectangle(hist):
    st = []
    max_area = 0
    hist.append(0)  # 센티넬
    for i, h in enumerate(hist):
        while st and hist[st[-1]] > h:
            height = hist[st.pop()]
            width = i if not st else i - st[-1] - 1
            max_area = max(max_area, height * width)
        st.append(i)
    hist.pop()
    return max_area
```

- 시간복잡도: 각 인덱스가 **1회 push + 1회 pop** → $$O(n)$$.

### 확장: **이진 행렬** 최대 직사각형

- 각 행을 **연속 1의 높이 히스토그램**으로 간주 후 위 알고리즘 반복.

```python
def maximal_rectangle(matrix):
    if not matrix: return 0
    n = len(matrix[0])
    heights = [0]*n
    ans = 0
    for row in matrix:
        for j, ch in enumerate(row):
            heights[j] = heights[j]+1 if ch=='1' else 0
        ans = max(ans, largest_rectangle(heights[:]))
    return ans
```

---

## 트리 순회 — 후위 순회 비재귀 (원고 보강)

### 한 스택 + 역출력 트릭

- 전위(루트-좌-우)와 **스택 push 순서**를 바꿔 **루트-우-좌**를 출력한 뒤, **역순**으로 뒤집으면 후위가 된다.

```python
def postorder_stack(tree, root):
    if root == '.':
        return
    st = [root]
    out = []
    while st:
        u = st.pop()
        out.append(u)
        l, r = tree[u]
        if l != '.': st.append(l)
        if r != '.': st.append(r)
    print(''.join(out[::-1]))
```

### 두 스택 정석형

```python
def postorder_two_stacks(tree, root):
    if root == '.': return
    s1, s2 = [root], []
    while s1:
        u = s1.pop()
        s2.append(u)
        l, r = tree[u]
        if l != '.': s1.append(l)
        if r != '.': s1.append(r)
    print(''.join(reversed(s2)))
```

---

## 판별

### 단일 괄호 `()` (원고 코드 유지)

```python
def is_valid_parentheses(s):
    st = []
    for ch in s:
        if ch == '(':
            st.append(ch)
        elif ch == ')':
            if not st:
                return False
            st.pop()
    return not st
```

### 확장: 다종 괄호 `()[]{}` 와 순서 규칙

```python
def valid_brackets(s):
    pair = {')':'(', ']':'[', '}':'{'}
    st = []
    for ch in s:
        if ch in '([{':
            st.append(ch)
        elif ch in ')]}':
            if not st or st[-1] != pair[ch]:
                return False
            st.pop()
    return not st
```

- 모든 검사는 $$O(n)$$. 유니코드/문자열 섞임 주의.

---

## — 모노토닉 감소 스택

### 기본형 (원고 코드 유지)

```python
def next_greater(arr):
    n = len(arr)
    ans = [-1]*n
    st = []  # 인덱스 스택
    for i in range(n):
        while st and arr[st[-1]] < arr[i]:
            ans[st.pop()] = arr[i]
        st.append(i)
    return ans
```

### 변형

- **오른쪽이 아닌 왼쪽**의 더 큰/작은 값 → 스캔 방향과 비교 부등식만 바꾸면 된다.
- **원형 배열**: 인덱스를 `2n`까지 확장해 `i % n`로 접근.

```python
def next_greater_circular(nums):
    n = len(nums)
    ans = [-1]*n
    st = []
    for i in range(2*n):
        while st and nums[st[-1]] < nums[i % n]:
            ans[st.pop()] = nums[i % n]
        if i < n:
            st.append(i)
    return ans
```

---

## 모노토닉 스택 응용 확장 세트

### Daily Temperatures

```python
def daily_temperatures(T):
    n = len(T)
    ans = [0]*n
    st = []  # 내림차순 스택(인덱스)
    for i, t in enumerate(T):
        while st and T[st[-1]] < t:
            j = st.pop()
            ans[j] = i - j
        st.append(i)
    return ans
```

### Stock Span

```python
def stock_span(prices):
    st = []  # (가격, 연속일수)
    ans = []
    for p in prices:
        span = 1
        while st and st[-1][0] <= p:
            span += st.pop()[1]
        st.append((p, span))
        ans.append(span)
    return ans
```

### Trapping Rain Water (스택 풀이)

```python
def trap(height):
    st = []
    water = 0
    for i, h in enumerate(height):
        while st and height[st[-1]] < h:
            mid = st.pop()
            if not st: break
            left = st[-1]
            bounded = min(height[left], h) - height[mid]
            width = i - left - 1
            if bounded > 0:
                water += bounded * width
        st.append(i)
    return water
```

---

## 계산기 확장 — 단항/우선순위/스페이스/다자리수

### 토크나이저 + Shunting Yard + 후위 평가 통합

```python
def tokenize(expr):
    tokens = []
    i = 0; n = len(expr)
    while i < n:
        c = expr[i]
        if c.isspace():
            i += 1; continue
        if c.isdigit():
            j = i
            while j < n and expr[j].isdigit():
                j += 1
            tokens.append(expr[i:j])
            i = j
        elif c in '+-*/()':
            tokens.append(c); i += 1
        else:
            raise ValueError("invalid char")
    return tokens

def to_postfix(tokens):
    prec = {'+':1, '-':1, '*':2, '/':2}
    out, st = [], []
    prev = None
    for t in tokens:
        if t.isdigit():
            out.append(t)
        elif t == '(':
            st.append(t)
        elif t == ')':
            while st and st[-1] != '(':
                out.append(st.pop())
            st.pop()
        else:
            # 단항 - 처리: 이전 토큰이 없거나, ( 연산자 뒤라면 0을 앞에 둔다.
            if t == '-' and (prev is None or prev in '+-*/('):
                out.append('0')
            while st and st[-1] != '(' and prec[t] <= prec.get(st[-1], 0):
                out.append(st.pop())
            st.append(t)
        prev = t
    while st:
        out.append(st.pop())
    return out

def eval_postfix_tokens(post):
    st = []
    for t in post:
        if t.isdigit():
            st.append(int(t))
        else:
            b = st.pop(); a = st.pop()
            if t == '+': st.append(a+b)
            elif t == '-': st.append(a-b)
            elif t == '*': st.append(a*b)
            elif t == '/': st.append(int(a/b))
    return st.pop()

def calc(expr):
    toks = tokenize(expr)
    post = to_postfix(toks)
    return eval_postfix_tokens(post)
```

---

## 스택 변형 자료구조

### Min Stack — $$O(1)$$ 최솟값

- 방법1: 값과 현재 최소값을 **쌍으로** 저장
- 방법2: **차이값/인코딩**(언더플로우 주의)
여기서는 쌍 방식:

```python
class MinStack:
    def __init__(self):
        self.st = []
    def push(self, x):
        cur_min = x if not self.st else min(x, self.st[-1][1])
        self.st.append((x, cur_min))
    def pop(self):
        self.st.pop()
    def top(self):
        return self.st[-1][0]
    def getMin(self):
        return self.st[-1][1]
```

### 두 스택으로 큐

```python
class MyQueue:
    def __init__(self):
        self.in_st, self.out_st = [], []
    def push(self, x):
        self.in_st.append(x)
    def _move(self):
        if not self.out_st:
            while self.in_st:
                self.out_st.append(self.in_st.pop())
    def pop(self):
        self._move()
        return self.out_st.pop()
    def peek(self):
        self._move()
        return self.out_st[-1]
    def empty(self):
        return not self.in_st and not self.out_st
```

---

## 문자열/스택 파싱 전형

### Decode String: `3[a2[c]]` → `accaccacc`

```python
def decode_string(s):
    st = []  # (반복수, 이전 문자열)
    num = 0
    cur = []
    for ch in s:
        if ch.isdigit():
            num = num*10 + int(ch)
        elif ch == '[':
            st.append((num, ''.join(cur)))
            num = 0; cur = []
        elif ch == ']':
            k, prev = st.pop()
            cur = [prev + ''.join(cur)*k]
        else:
            cur.append(ch)
    return ''.join(cur)
```

### Remove K Digits: 가장 작은 수 만들기(모노토닉 증가)

```python
def remove_k_digits(num, k):
    st = []
    for ch in num:
        while k and st and st[-1] > ch:
            st.pop(); k -= 1
        st.append(ch)
    while k:
        st.pop(); k -= 1
    s = ''.join(st).lstrip('0')
    return s if s else '0'
```

---

## 그래프/트리 고급: Tarjan의 SCC (스택 핵심)

- DFS 중 **스택에 경로상 정점**을 유지, `low-link`로 **강연결요소** 검출.

```python
def scc_tarjan(adj):
    n = len(adj)
    ids = [-1]*n; low = [0]*n
    on = [False]*n; st = []
    idx = 0; comps = []
    def dfs(u):
        nonlocal idx
        ids[u] = low[u] = idx; idx += 1
        st.append(u); on[u] = True
        for v in adj[u]:
            if ids[v] == -1:
                dfs(v); low[u] = min(low[u], low[v])
            elif on[v]:
                low[u] = min(low[u], ids[v])
        if low[u] == ids[u]:
            comp = []
            while True:
                w = st.pop(); on[w] = False
                comp.append(w)
                if w == u: break
            comps.append(comp)
    for i in range(n):
        if ids[i] == -1:
            dfs(i)
    return comps
```

---

## 시뮬레이션: 브라우저 히스토리(앞/뒤), Undo/Redo

```python
class Browser:
    def __init__(self, home):
        self.back_st = [home]
        self.forward_st = []
    def visit(self, url):
        self.back_st.append(url)
        self.forward_st.clear()
    def back(self):
        if len(self.back_st) > 1:
            self.forward_st.append(self.back_st.pop())
        return self.back_st[-1]
    def forward(self):
        if self.forward_st:
            self.back_st.append(self.forward_st.pop())
        return self.back_st[-1]
```

---

## 복잡도·증명 스케치(필수 정리)

- **모노토닉 스택** 계열(오큰수, 히스토그램, Daily T.):
  각 인덱스는 **정확히 1회 push + 1회 pop** → 총 연산수는 $$O(n)$$.
- **스택 기반 DFS**: 각 간선 확인이 상수 시간 → $$O(V+E)$$.
- **VPS/Bracket**: 각 문자를 최대 1회 스택에 올렸다 내림 → $$O(n)$$.

---

## 경계·테스트 체크리스트

1) 빈 입력, 한 글자, 전부 동일 값
2) 히스토그램: 내림차순/오름차순/중복/끝처리(센티넬)
3) 수식: 공백/음수/나눗셈 방향/0으로 나누기
4) 괄호: 길이 홀수/닫는 괄호가 먼저/여러 괄호 혼합
5) 원형 오큰수: 모두 같은 값/단조 감소 전열
6) 성능: $$n=10^5\sim 10^6$$ 규모에서도 통과해야 할 구현(파이썬이면 pypy 고려)

---

## 백준 맥락 연결(입출력 템플릿)

### 오큰수(17298)

```python
import sys
input = sys.stdin.readline

n = int(input().strip())
arr = list(map(int, input().split()))
ans = [-1]*n
st = []
for i in range(n):
    while st and arr[st[-1]] < arr[i]:
        ans[st.pop()] = arr[i]
    st.append(i)
print(*ans)
```

### — 다중 테스트 처리

```python
import sys
input = sys.stdin.readline

def largest_rectangle(hist):
    st = []
    ans = 0
    hist.append(0)
    for i, h in enumerate(hist):
        while st and hist[st[-1]] > h:
            height = hist[st.pop()]
            width = i if not st else i - st[-1] - 1
            if height * width > ans:
                ans = height * width
        st.append(i)
    hist.pop()
    return ans

while True:
    data = list(map(int, input().split()))
    if data[0] == 0:
        break
    n = data[0]
    hist = data[1:]
    print(largest_rectangle(hist))
```

---

## “왜 스택인가?” — 문제 유형별 선택 판단표

| 문제유형 | 핵심 패턴 | 이유 |
|---|---|---|
| 괄호/마크업 검사 | 단조 push-pop | 최근 미해결 요소를 즉시 해소 |
| 오큰수/일일온도/주가스팬 | 모노토닉 스택 | 이전 원소들의 **불필요한 후보**를 빠르게 제거 |
| 히스토그램/최대 직사각형 | 증가 스택 | “확장 가능한 구간”을 암시적으로 유지 |
| DFS, 트리 순회 | 명시적 스택 | 재귀 깊은 입력에서도 안전, 순서 제어 용이 |
| 수식 파싱/계산 | 연산자/피연산자 스택 | 우선순위·괄호를 지역적으로 해결 |

---

## 종합 예제: “가장 가까운 더 큰 건물” + “비가 오는 날의 수집량”

### 인근 더 높은 건물

```python
def nearest_greater_to_left(heights):
    st = []  # 모노토닉 감소(인덱스)
    ans = [-1]*len(heights)
    for i, h in enumerate(heights):
        while st and heights[st[-1]] <= h:
            st.pop()
        ans[i] = st[-1] if st else -1
        st.append(i)
    return ans
```

### 강우량 수집(트래핑 워터, 양끝에서 동시에)

- 스택 풀이 외에 **투 포인터**도 비교(면접 대비).

```python
def trap_two_pointers(height):
    l, r = 0, len(height)-1
    left_max = right_max = 0
    water = 0
    while l < r:
        if height[l] < height[r]:
            if height[l] >= left_max:
                left_max = height[l]
            else:
                water += left_max - height[l]
            l += 1
        else:
            if height[r] >= right_max:
                right_max = height[r]
            else:
                water += right_max - height[r]
            r -= 1
    return water
```

---

## 성능/메모리 팁

- **센티넬 추가**: 히스토그램 끝 처리 간편화.
- **인덱스만 스택에 저장**: 값 대신 인덱스를 두면 **폭 계산**이 쉬움.
- 파이썬: **로컬 변수 바인딩** 최적화, I/O는 `sys.stdin.readline`.

---

## 수학적 요약 (복잡도)

- 모노토닉 스택 패턴(오큰수, 히스토그램, Daily T., 스팬)의 **총 연산수**:
  $$
  \sum_{i=1}^{n} (\text{push}_i + \text{pop}_i) \le 2n \Rightarrow O(n).
  $$
- DFS, 트리 순회(비재귀)도 각 간선/정점 **유한 번** 처리 → $$O(V+E)$$.

---

## 마무리 — 학습 루트 제안

1) **기본기 재현**: 괄호, 오큰수, 히스토그램
2) **변형 익히기**: 원형/왼쪽 NGE, daily temp, stock span
3) **파싱**: 중위→후위, 단항·공백·다자리수 계산기
4) **그래프/트리 응용**: DFS 비재귀, Tarjan
5) **실전 조립**: 이진 행렬 최대 직사각형, 물 수집, 브라우저 시뮬

---

# 부록 A. 예제 입출력 모음(간단)

```text
입력(오큰수):
4
3 5 2 7
출력:
5 7 7 -1
```

```text
입력(히스토그램):
7
2 1 4 5 1 3 3
출력:
8
```

---

# 부록 B. 디버깅 체크리스트

- 히스토그램: **동일 높이** 처리 시 `>` vs `>=` 비교 주의
- 오큰수: 답 배열 초기값 `-1` 설정
- 계산기: 단항 `-` 문맥 판별, 나눗셈 규칙(언어별 차이)
- 괄호: 중간에 스택이 비었는지, 종료 후 스택이 비었는지
