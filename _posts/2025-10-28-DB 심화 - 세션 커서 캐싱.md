---
layout: post
title: DB 심화 - 세션 커서 캐싱
date: 2025-10-28 21:25:23 +0900
category: DB 심화
---
# 세션 커서 캐싱(Session Cursor Caching)

> **한 줄 요약**  
> `SESSION_CACHED_CURSORS`는 **세션 단위**의 “작은 커서 캐시”다.  
> **같은 SQL을 같은 세션에서 반복 파싱**할 때, **라이브러리 캐시 탐색 + 소프트 파싱 비용**을 크게 줄여준다.  
> **바인드 변수**와 함께 쓰면 **파싱 CPU↓, 뮤텍스 경합↓, 응답시간↓** 효과가 크다.

---

## 1) 개념과 배경

### 1.1 커서(cursor)란?
- 파싱된 SQL/PLSQL의 **실행 가능한 객체**(파스 트리, 실행계획, 런타임 메타데이터 포함).
- **라이브러리 캐시**(Shared Pool)에는 **Parent/Child 커서** 구조로 상주.

### 1.2 세션 커서 캐싱이 필요한 이유
- **소프트 파싱**도 공짜가 아니다:
  - 라이브러리 캐시 해시버킷 탐색, Child 선택, 권한/환경 재검증, 뮤텍스 획득 등 오버헤드.
- **웹/마이크로서비스** 패턴에서는 동일한 SQL이 **짧은 시간에 매우 자주 재호출**된다.
- 이때 **세션 로컬 캐시**에 최근 사용 커서를 보관해두면 **재파싱 없이 재사용**이 쉽다.

### 1.3 핵심 파라미터와 지표
- 파라미터 **`SESSION_CACHED_CURSORS`**  
  - 세션당 보관 가능한 **닫힌 커서**의 최대 개수(기본값 0 또는 낮은 값인 환경 多).
- 지표
  - `V$SYSSTAT` / `V$SESSTAT`의 **`session cursor cache hits`**
  - `parse count (total)`, `parse count (hard)`, `parse time elapsed`

> **히트율 직관식**  
> $$ \text{Hit Ratio} \approx \frac{\text{session cursor cache hits}}{\text{parse count (total)}} $$
> (절대적인 진리 값은 아니지만, 경향을 파악하는 데 유용)

---

## 2) 동작 원리 — 서버-측 “세션 로컬” 커서 LRU

1) **세션**이 SQL을 **파싱**(하드/소프트)하여 **오픈**한다.  
2) 커서를 **클로즈**하면, 해당 커서는 **세션 커서 캐시** 후보가 된다.  
3) **같은 세션**에서 **같은 텍스트**(Parent 기준)로 **다시 파싱을 요청**하면,
   - 먼저 **세션 커서 캐시**에서 **직접 재사용**을 시도한다(있으면 **즉시 히트**).
   - 세션 캐시에 없으면 **라이브러리 캐시** 탐색(소프트 파싱 경로).
4) 세션 커서 캐시는 **LRU**로 관리되며, 개수 상한은 `SESSION_CACHED_CURSORS`.

> **중요 메모**  
> - **세션 캐시**는 **닫힌 커서**를 보관한다. 즉, 앱에서 커서를 **Close** 해도 다음 호출에 **빠르게 재사용** 가능.  
> - 어떤 SQL이 **한 세션에서 최소 3회 이상 파싱**되면(버전에 따라 다소 차이), 그때부터 **세션 캐시에 적재**되는 **경향**이 있다(문헌상의 일반적 규칙).

---

## 3) 라이브러리 캐시 vs 세션 커서 캐시 vs 클라이언트(드라이버) 캐시

| 구분 | 위치 | 범위 | 목적 | 한계 |
|---|---|---|---|---|
| **라이브러리 캐시** | 서버 Shared Pool | 인스턴스 전체 | Parent/Child 커서 공유 | 소프트 파싱 오버헤드 존재(뮤텍스/락) |
| **세션 커서 캐시** | 서버 **세션 로컬(UGA/SGA)** | **세션** | 동일 SQL 재사용 시 “즉시 반환” | 세션 끝나면 소멸, 용량 작음 |
| **클라이언트 Statement Cache** (ODP.NET/JDBC OCI 등) | **클라이언트/미들** | 연결(세션) | 클로즈된 PreparedStatement 재사용 | 드라이버별 정책 상이, 서버 인지 어려움 |

> **베스트 프랙티스**:  
> - **바인드 변수** + **세션 커서 캐시** + (가능 시) **클라이언트 Statement Cache** → 3단 캐시로 파싱 비용 극소화.

---

## 4) 실습: `SESSION_CACHED_CURSORS` 효과 증명

### 4.1 준비
```sql
-- 테스트 테이블
DROP TABLE t_cc PURGE;
CREATE TABLE t_cc AS
SELECT level AS id,
       CASE MOD(level,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END AS rgn,
       ROUND(DBMS_RANDOM.VALUE(10,1000),2) amt
FROM dual CONNECT BY level <= 100000;

CREATE INDEX ix_t_cc_rgn ON t_cc(rgn);
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'T_CC',cascade=>TRUE,method_opt=>'FOR COLUMNS SIZE 75 rgn');
END;
/
```

### 4.2 현재 세션 파라미터와 지표 확인
```sql
-- 현재 세션의 SESSION_CACHED_CURSORS
SHOW PARAMETER session_cached_cursors

-- 세션 지표(나의 세션)
SELECT sn.name, ss.value
FROM   v$sesstat ss JOIN v$statname sn ON sn.statistic#=ss.statistic#
WHERE  ss.sid = SYS_CONTEXT('USERENV','SID')
AND    sn.name IN ('parse count (total)','parse count (hard)','session cursor cache hits');

-- 시스템 지표(참고)
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('parse count (total)','parse count (hard)','parse time elapsed','session cursor cache hits');
```

### 4.3 반복 파싱 부하 생성(바인드 활용)
```plsql
-- 동일 SQL을 바인드만 바꿔가며 "반복 파싱" → 세션 캐시 이득 확인
DECLARE
  v_cnt NUMBER;
  v_rgn VARCHAR2(10);
BEGIN
  FOR i IN 1..5000 LOOP
    v_rgn := CASE MOD(i,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END;
    EXECUTE IMMEDIATE 'SELECT /* demo-cc */ COUNT(*) FROM t_cc WHERE rgn=:b1'
      INTO v_cnt USING v_rgn;
  END LOOP;
END;
/
```

### 4.4 전/후 지표 비교
```sql
SELECT sn.name, ss.value
FROM   v$sesstat ss JOIN v$statname sn ON sn.statistic#=ss.statistic#
WHERE  ss.sid = SYS_CONTEXT('USERENV','SID')
AND    sn.name IN ('parse count (total)','parse count (hard)','session cursor cache hits');
```

- **`session cursor cache hits` 값 증가** 여부 확인.  
- `parse count (total)` 증가 대비 **Cache Hits**가 **충분히 올라왔다면** 효과가 나타난 것.

> **팁**: `SESSION_CACHED_CURSORS`가 0 또는 너무 낮으면 **히트가 발생하지 않음**. 적정값으로 올리고 동일 실험을 반복해 **차이를 수치화**하자.

---

## 5) 톺아보기 — 성능상 이득이 생기는 지점

1) **같은 세션**에서 **같은 Parent SQL**을 **여러 번** 파싱하는 **패턴**일 때.  
2) 커서를 **닫았다가** 곧 **다시 사용**할 때(웹 요청/응답 사이클에 흔함).  
3) **바인드 변수**를 사용하여 **텍스트 동일성**을 확보했을 때.

> 반대로,
> - 각 호출마다 **텍스트가 미묘하게 다르거나**(주석·공백·힌트),  
> - 앱에서 커서를 **아예 열어둔 채** 반복 사용하면(오픈/클로즈가 적음)  
>   → **세션 커서 캐시 이득이 적다**.

---

## 6) 적정 사이즈 산정 가이드

### 6.1 단계별 접근
1) 현황 파악: `session cursor cache hits`, `parse count (total)` / 사용자별 세션  
2) 값 점증: `SESSION_CACHED_CURSORS`를 **점진적으로**(예: 50 → 100 → 200) 인상  
3) 효과 검증: 히트 증가 ↔ 추가 메모리(세션당 수 KB~수십 KB) 균형  
4) 상한: 애플리케이션이 **한 세션에서 반복 사용하는 서로 다른 SQL 수**보다 약간 넉넉하게

### 6.2 경험치(일반적 참고)
- **OLTP/웹**: 100~500 사이에서 많이 수렴  
- **배치/리포트 전용**: 반복 재호출이 적으면 낮은 값도 OK

> **주의**: 너무 크게 잡으면 **세션 수 × 캐시 엔트리** 만큼 누적되어 **UGA/SGA 사용량**이 커질 수 있다.

---

## 7) `OPEN_CURSORS` vs `SESSION_CACHED_CURSORS`

- `OPEN_CURSORS`: **동시에 열어둘 수 있는** 커서의 상한(세션 단).  
- `SESSION_CACHED_CURSORS`: **닫힌 커서**를 **세션 로컬 캐시에 보관**하는 개수.

> 둘 다 **세션당** 한도이지만, 목적이 다르다.  
> - `OPEN_CURSORS` 부족 → ORA-01000(too many open cursors)  
> - `SESSION_CACHED_CURSORS` 낮음 → **파싱 히트(재사용) 저조**, 불필요한 소프트 파싱 증가

---

## 8) 케이스 스터디 — 실무 패턴별 처방

### 8.1 웹 API(짧은 연결/연결 풀)
- 각 요청에서 **같은 템플릿 SQL**이 반복 호출됨(바인드 값만 다름).  
- **권장**: `SESSION_CACHED_CURSORS` **상향** + **바인드 변수** + **Statement Cache(드라이버)**

### 8.2 배치 쿼리(대형 보고/집계)
- 파싱 횟수 자체가 많지 않거나 한 번 오픈 후 오래 사용.  
- **권장**: “바인드·플랜 안정화(SPM)”가 더 중요. 세션 캐시는 **부차적**.

### 8.3 ORM/동적 SQL 생성기 사용
- 미묘한 텍스트 차이(공백/주석/힌트/컬럼 순서 변경)로 Parent 난립 위험.  
- **권장**: SQL 템플릿 **고정**, 값만 바인드로 바꾸게 설계 → **세션 캐시·라이브러리 캐시 재사용** 극대화

---

## 9) 진단 스크립트 모음

### 9.1 사용자(내 세션) 지표
```sql
SELECT sn.name, ss.value
FROM   v$sesstat ss JOIN v$statname sn ON sn.statistic#=ss.statistic#
WHERE  ss.sid = SYS_CONTEXT('USERENV','SID')
AND    sn.name IN ('parse count (total)','parse count (hard)','session cursor cache hits');
```

### 9.2 시스템 Top 세션(세션 커서 캐시 히트 많은 세션)
```sql
WITH m AS (
  SELECT sid, statistic#, value
  FROM   v$sesstat
  WHERE  statistic# IN (SELECT statistic# FROM v$statname WHERE name='session cursor cache hits')
)
SELECT m.sid, m.value AS cache_hits
FROM   m
ORDER  BY m.value DESC FETCH FIRST 20 ROWS ONLY;
```

### 9.3 라이브러리 캐시 경합 동반 확인(15분)
```sql
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '15' MINUTE; EXEC :t2 := SYSTIMESTAMP;
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event IN ('library cache: mutex X','library cache: mutex S','cursor: pin S wait on X')
GROUP  BY event ORDER BY samples DESC;
```

> **튜닝 순서**  
> 1) **바인드 변수** 정착 → 2) **세션 캐시 사이즈** 상향 → 3) 필요 시 **드라이버 Statement Cache**  
> 4) 남은 경합은 **아키텍처(핫커서 분산, 배치 시간 분리)** 로 완화

---

## 10) 예제: PL/SQL 로드 테스트(세션 캐시 효과 관찰)

```plsql
SET SERVEROUTPUT ON
DECLARE
  v_before_parse NUMBER;
  v_before_hard  NUMBER;
  v_before_hit   NUMBER;

  v_after_parse  NUMBER;
  v_after_hard   NUMBER;
  v_after_hit    NUMBER;

  v_dummy NUMBER;

  PROCEDURE snap(p_parse OUT NUMBER, p_hard OUT NUMBER, p_hit OUT NUMBER) IS
  BEGIN
    SELECT SUM(CASE WHEN name='parse count (total)'         THEN value END),
           SUM(CASE WHEN name='parse count (hard)'          THEN value END),
           SUM(CASE WHEN name='session cursor cache hits'   THEN value END)
    INTO   p_parse, p_hard, p_hit
    FROM (
      SELECT sn.name, ss.value
      FROM   v$sesstat ss JOIN v$statname sn ON sn.statistic#=ss.statistic#
      WHERE  ss.sid = SYS_CONTEXT('USERENV','SID')
      AND    sn.name IN ('parse count (total)','parse count (hard)','session cursor cache hits')
    );
  END;
BEGIN
  snap(v_before_parse, v_before_hard, v_before_hit);

  FOR i IN 1..5000 LOOP
    EXECUTE IMMEDIATE 'SELECT /* cc-load */ COUNT(*) FROM t_cc WHERE rgn=:b1'
      INTO v_dummy
      USING CASE MOD(i,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END;
  END LOOP;

  snap(v_after_parse, v_after_hard, v_after_hit);

  DBMS_OUTPUT.PUT_LINE('parse total  diff='||(v_after_parse - v_before_parse));
  DBMS_OUTPUT.PUT_LINE('parse hard   diff='||(v_after_hard  - v_before_hard));
  DBMS_OUTPUT.PUT_LINE('sess cc hits diff='||(v_after_hit   - v_before_hit));
END;
/
```

- `SESSION_CACHED_CURSORS` 값을 **0 → 100**으로 바꿔가며 실행 → **diff 값의 변화**로 효과 확인.

---

## 11) 흔한 오해·주의점

1) **“세션 캐시가 있으면 바인드가 필요 없다?” → NO.**  
   - 세션 캐시는 **텍스트 동일성**이 기본. 값이 바뀌어도 **바인드**로 텍스트를 유지해야 **효과 극대화**.

2) **“세션 캐시만 키우면 된다?” → NO.**  
   - **리터럴 남발/텍스트 변형**이 있으면 **Parent 난립**으로 효과 제한.  
   - **드라이버 Statement Cache**와 **서버 세션 캐시**는 **상호 보완**.

3) **“너무 크게 잡아도 상관 없다?” → NO.**  
   - **세션 수 × 엔트리당 메모리**가 누적된다. 점진 인상 + 관측이 원칙.

4) **“이미 오픈해 둔 커서에도 효과가 있나?” → 간접적.**  
   - 세션 캐시는 **닫힌 커서 재사용** 시 효과. 오픈 유지 패턴에선 이득이 적다.

5) **Invalidation 영향**  
   - DDL/통계 변경으로 커서가 **무효화**되면 세션 캐시 엔트리도 **재파싱 필요**. 배포/통계 타이밍 관리가 중요.

---

## 12) 클라이언트(ODP.NET/JDBC) Statement Cache와 함께 쓰기

### 12.1 ODP.NET 예
```csharp
// 연결 문자열 또는 코드에서 Statement Cache 크기 지정
// "Statement Cache Size=50;" or
conn.StatementCacheSize = 50;

using (var cmd = conn.CreateCommand()) {
  cmd.CommandText = "SELECT /* sc-demo */ COUNT(*) FROM t_cc WHERE rgn=:r";
  cmd.BindByName = true;
  cmd.Parameters.Add("r", OracleDbType.Varchar2);
  for (int i=0; i<5000; i++) {
    cmd.Parameters["r"].Value = (i%3==0) ? "APAC" : (i%3==1) ? "EMEA" : "AMER";
    var n = Convert.ToInt32(cmd.ExecuteScalar());
  }
}
```

### 12.2 JDBC(OCI) 예
```java
OracleConnection conn = (OracleConnection) ds.getConnection();
conn.setImplicitCachingEnabled(true);
conn.setStatementCacheSize(50);

PreparedStatement ps = conn.prepareStatement(
  "SELECT /* sc-demo */ COUNT(*) FROM t_cc WHERE rgn = ?");
for (int i=0; i<5000; i++) {
  ps.setString(1, i%3==0 ? "APAC" : i%3==1 ? "EMEA" : "AMER");
  try (ResultSet rs = ps.executeQuery()) { if (rs.next()) rs.getInt(1); }
}
ps.close();
```

> **콤보 전략**:  
> **Statement Cache(클라이언트)** 가 **닫힌 PreparedStatement**를 재사용 → 서버 **세션 커서 캐시**가 **해당 커서 재파싱을 우회**.  
> 결과적으로 **양쪽 캐시 히트**가 일어나면 **파싱 CPU/경합**이 대폭 줄어든다.

---

## 13) 체크리스트(운영 지침)

- [ ] **바인드 변수** 일괄 적용(ORM/DAO 레벨 포함)  
- [ ] **SQL 텍스트 템플릿 고정**(주석/공백/힌트 랜덤화 금지)  
- [ ] `SESSION_CACHED_CURSORS` **점진 상향**(100 → 200 …)  
- [ ] **지표 모니터링**: `session cursor cache hits`, `parse count (total/hard)`  
- [ ] **라이브러리 캐시 경합** 동반 감시(뮤텍스/핀 대기)  
- [ ] 클라이언트 **Statement Cache** 활성화(가능 시)  
- [ ] **배포/통계** 윈도우링(Invalidation 스파이크 방지)  
- [ ] **OPEN_CURSORS** 적정(ORA-01000 방지)

---

## 14) 결론

- `SESSION_CACHED_CURSORS`는 **작지만 강력한 레버**다.  
- **바인드 변수**와 **일관된 텍스트**가 전제될 때, **소프트 파싱 오버헤드**를 회피하며  
  **라이브러리 캐시 경합**까지 줄인다.  
- 값은 **점진적으로 늘리고** **지표로 검증**하라.  
- 드라이버 **Statement Cache**와의 **2중 캐시 전략**으로 파싱 문제를 **종식**시킬 수 있다.

> **요약**:  
> 바인드 → 텍스트 일관화 → 세션 커서 캐시 히트 ↑ → 파싱 CPU↓/뮤텍스↓/RT↓ → 시스템이 **매끈하게** 돈다.