---
layout: post
title: C# - 비동기 프로그래밍
date: 2024-10-13 20:20:23 +0900
category: Csharp
---
# async/await, Task, 스레드, 그리고 ConfigureAwait(false)

## 들어가며

현대 애플리케이션은 I/O 바운드 작업(파일 읽기/쓰기, 네트워크 요청, 데이터베이스 쿼리)이 빈번하게 발생합니다. 이러한 작업을 동기적으로 처리하면 스레드가 작업 완료까지 대기하며 블로킹되어, 애플리케이션의 확장성과 응답성이 떨어집니다. C#의 비동기 프로그래밍 모델은 이러한 문제를 해결하면서도 마치 동기 코드처럼 읽기 쉬운 코드를 작성할 수 있게 해줍니다.

이 글에서는 C# 비동기 프로그래밍의 핵심 개념인 `async`/`await`, `Task`, `Thread`와의 차이점, 그리고 성능과 안정성을 높이는 `ConfigureAwait(false)`에 대해 깊이 있게 살펴보겠습니다.

---

## 1. async / await: 비동기 코드를 동기처럼

### 기본 개념

`async`와 `await`는 C# 5.0에서 도입된 키워드로, 비동기 프로그래밍을 혁신적으로 단순화했습니다. 이 키워드들은 컴파일러가 복잡한 상태 머신을 생성하여 비동기 작업의 일시 중단과 재개를 자동으로 처리해줍니다.

```csharp
public async Task<string> DownloadDataAsync(string url)
{
    using var client = new HttpClient();
    string content = await client.GetStringAsync(url);
    return content;
}
```

위 코드에서 `await`를 만나면 메서드는 즉시 호출자에게 제어를 반환합니다. `GetStringAsync`가 완료되면 메서드가 중단된 지점부터 실행을 재개합니다. 이 모든 과정이 개발자 개입 없이 자동으로 이루어집니다.

### async 키워드의 의미

- 메서드에 `async`를 붙이면 메서드 내부에서 `await`를 사용할 수 있습니다.
- `async` 메서드는 반드시 `Task`, `Task<T>`, `ValueTask<T>` 또는 `void`를 반환해야 합니다.
- `async void`는 이벤트 핸들러 외에는 사용하지 않는 것이 원칙입니다(예외 처리 곤란, 호출자가 완료를 알 수 없음).

### await의 동작 원리

`await`는 `awaitable` 패턴을 구현하는 객체를 기다립니다. 일반적으로 `Task`나 `Task<T>`가 사용됩니다. 컴파일러는 `await`를 만나면 다음과 같은 작업을 수행합니다:

1. **awaitable 객체가 이미 완료되었는지 확인** – 완료되었다면 동기적으로 계속 실행
2. **미완료 시** – 현재 메서드의 상태를 저장하고 호출자에게 미완료 Task 반환
3. **awaitable 완료 시** – 저장된 컨텍스트에서 나머지 코드 실행

이러한 메커니즘은 **비동기 작업 중에도 스레드를 차단하지 않고** 시스템 자원을 효율적으로 사용할 수 있게 합니다.

---

## 2. Task: 비동기 작업의 단위

`Task`는 .NET에서 비동기 작업을 나타내는 핵심 타입입니다. 이는 미래에 완료될 작업을 약속(Promise)하는 객체로, 작업의 상태, 결과, 예외 등을 캡슐화합니다.

### Task의 주요 속성과 메서드

```csharp
Task task = SomeAsyncMethod();
task.Status;           // TaskStatus (WaitingToRun, Running, RanToCompletion 등)
task.IsCompleted;      // 완료 여부 (성공/실패/취소 포함)
task.IsFaulted;        // 예외 발생 여부
task.IsCanceled;       // 취소 여부
task.Exception;        // 발생한 예외 (AggregateException)

task.Wait();           // 동기적 대기 (스레드 차단) - 일반적으로 피해야 함
task.Result;           // 동기적 결과 가져오기 (차단) - 데드락 위험
await task;            // 비동기적 대기 (권장)
```

### Task의 생명주기

```
Created → WaitingForActivation → WaitingToRun → Running → 
    (RanToCompletion / Faulted / Canceled)
```

- **Created**: Task 생성됨
- **WaitingForActivation**: 실행 대기 중 (예: Task.Run 호출 전)
- **WaitingToRun**: 스레드 풀에 스케줄링됨
- **Running**: 실행 중
- **RanToCompletion**: 성공적 완료
- **Faulted**: 예외 발생
- **Canceled**: 취소됨

### Task의 다양한 생성 방법

```csharp
// 1. Task.Run: 스레드 풀에서 실행
Task t1 = Task.Run(() => DoWork());

// 2. Task.Factory.StartNew: 세부 제어 가능
Task t2 = Task.Factory.StartNew(() => DoWork(), 
    CancellationToken.None, 
    TaskCreationOptions.LongRunning, // 오래 실행 작업에 힌트
    TaskScheduler.Default);

// 3. TaskCompletionSource: 수동으로 완료 제어
var tcs = new TaskCompletionSource<int>();
// 나중에 tcs.SetResult(42); 로 완료
Task<int> t3 = tcs.Task;

// 4. Task.FromResult: 이미 완료된 Task 생성
Task<int> t4 = Task.FromResult(42);
```

---

## 3. Task vs Thread: 무엇이 다른가?

많은 개발자가 비동기 프로그래밍을 배울 때 "Task는 스레드인가?"라는 의문을 가집니다. 이 둘은 근본적으로 다른 개념입니다.

### Thread: 운영체제 수준의 실행 단위

- 스레드는 OS가 CPU 코어에 스케줄링하는 **실행 흐름**입니다.
- 각 스레드는 자체 스택, 레지스터 상태를 가집니다.
- 스레드 생성은 비용이 큽니다(메모리 약 1MB, 컨텍스트 스위칭 오버헤드).
- 수천 개의 스레드를 동시에 운영하기 어렵습니다.

### Task: 작업의 추상화

- Task는 **수행해야 할 작업 단위**를 나타냅니다.
- Task 자체는 스레드가 아닙니다. 실행되려면 스레드가 필요하지만, Task가 스레드를 직접 생성하지는 않습니다.
- 기본적으로 Task는 **스레드 풀**(ThreadPool)에서 가져온 스레드에서 실행됩니다.
- I/O 바운드 작업(Task는 실제로 스레드를 사용하지 않고 I/O 완료 포트에서 신호를 기다립니다)인 경우 스레드가 블로킹되지 않고 반환되어 다른 작업에 재사용됩니다.

### 비교 예제

```csharp
// 스레드 직접 생성
Thread thread = new Thread(() => 
{
    Thread.Sleep(1000);
    Console.WriteLine("Thread completed");
});
thread.Start();

// Task 사용
Task task = Task.Run(() => 
{
    Thread.Sleep(1000);
    Console.WriteLine("Task completed");
});
```

표면적으로는 비슷해 보이지만, 내부 동작이 다릅니다.

- **Thread**: 즉시 새 스레드를 생성하여 실행합니다. (CPU 바운드 작업에 적합)
- **Task**: 스레드 풀에서 사용 가능한 스레드가 있으면 그 스레드에서 실행하고, 없으면 대기열에 넣습니다. I/O 바운드 작업의 경우 스레드를 점유하지 않습니다.

### 스레드와 Task의 선택 기준

| 상황 | Thread | Task |
|------|--------|------|
| CPU 바운드 장기 실행 작업 | 직접 스레드 생성 (또는 LongRunning Task) | 일반 Task는 스레드 풀 사용, 장기 실행은 풀 고갈 위험 |
| I/O 바운드 작업 | ❌ 블로킹 스레드는 낭비 | ✅ async/await와 함께 이상적 |
| 수천 개의 동시 작업 | ❌ 컨텍스트 스위칭 오버헤드 큼 | ✅ 스레드 풀 효율적 재사용 |
| 세밀한 제어 필요 (우선순위, Affinity) | ✅ 직접 제어 가능 | ❌ 추상화되어 있어 제한적 |
| 작업 간 조합 (병렬, 순차, whenAll) | ❌ 직접 구현 복잡 | ✅ Task.WhenAll, ContinueWith 등 풍부한 API |

### CPU 바운드 vs I/O 바운드

- **CPU 바운드**: 계산 위주 작업. 스레드가 계속 CPU를 점유합니다. 이런 작업은 병렬 처리를 위해 여러 스레드를 활용해야 합니다. `Parallel.For`나 `Task.Run`을 사용합니다.
- **I/O 바운드**: 파일 읽기/쓰기, 네트워크 요청 등. 실제 CPU 작업보다 대기 시간이 깁니다. 이때는 `async`/`await`를 사용하여 스레드를 차단하지 않고 반환하는 것이 효율적입니다.

```csharp
// CPU 바운드: 여러 스레드 활용
int result = await Task.Run(() => LongCpuIntensiveWork());

// I/O 바운드: async/await로 스레드 절약
string data = await httpClient.GetStringAsync(url);
```

---

## 4. ConfigureAwait(false): 컨텍스트 캡처 제어

`ConfigureAwait(false)`는 비동기 프로그래밍에서 성능과 데드락 방지를 위해 중요한 메서드입니다. 이를 이해하려면 먼저 **SynchronizationContext** 개념을 알아야 합니다.

### SynchronizationContext

`SynchronizationContext`는 코드가 실행될 환경(컨텍스트)을 추상화한 것입니다. 주요 구현체로는:

- **WindowsFormsSynchronizationContext**: UI 스레드에 작업을 게시 (WinForms)
- **DispatcherSynchronizationContext**: WPF UI 스레드
- **AspNetSynchronizationContext**: ASP.NET (Framework) 요청 컨텍스트
- **ThreadPoolSynchronizationContext**: 기본 스레드 풀

기본적으로 `await`는 현재 `SynchronizationContext`를 캡처하고, 작업 완료 후 그 컨텍스트에서 나머지 코드를 실행하려고 시도합니다.

### 왜 ConfigureAwait(false)가 필요한가?

`ConfigureAwait(false)`는 **컨텍스트 캡처를 건너뛰도록** 지시합니다. 즉, `await` 이후의 코드가 원래 컨텍스트로 돌아가지 않고, 아무 스레드 풀 스레드에서나 계속 실행됩니다.

#### 1. 성능 향상

컨텍스트를 캡처하고 복원하는 작업은 약간의 오버헤드를 발생시킵니다. 특히 라이브러리 코드에서 매 `await`마다 불필요한 컨텍스트 전환을 하면 성능이 저하될 수 있습니다.

```csharp
// 라이브러리 내부 코드: 컨텍스트 복원이 필요 없음
public async Task<string> ReadFileAsync(string path)
{
    using var stream = File.OpenRead(path);
    byte[] buffer = new byte[stream.Length];
    
    // 이후 코드가 UI 스레드로 돌아갈 필요가 없다면 false 사용
    await stream.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false);
    
    return Encoding.UTF8.GetString(buffer);
}
```

#### 2. 데드락 방지

특정 환경(특히 ASP.NET Framework, WinForms, WPF)에서 `await` 후 컨텍스트 복원을 기다리며 데드락이 발생할 수 있습니다. 대표적인 패턴:

```csharp
// ASP.NET Framework 컨트롤러 메서드
public ActionResult GetData()
{
    // 동기적으로 비동기 메서드 호출 → 위험!
    var data = GetDataAsync().Result; 
    return View(data);
}

private async Task<string> GetDataAsync()
{
    // ConfigureAwait(false)가 없으면, 여기서 await 후 
    // 원래 컨텍스트(ASP.NET 요청 컨텍스트)로 돌아가려고 시도
    var result = await httpClient.GetStringAsync(url); 
    return result;
}
```

위 상황에서 `GetData()`가 동기적으로 `GetDataAsync().Result`를 호출하면 ASP.NET 요청 컨텍스트가 점유된 상태에서 `GetDataAsync` 내부의 `await`가 완료될 때까지 기다리게 됩니다. 그런데 `await`가 완료된 후 원래 컨텍스트로 돌아가려면 해당 컨텍스트가 필요하지만, 이미 동기 호출 때문에 컨텍스트가 점유되어 있어 서로를 기다리는 데드락이 발생합니다.

`ConfigureAwait(false)`를 사용하면 컨텍스트 복원을 시도하지 않으므로 데드락을 피할 수 있습니다.

### 언제 ConfigureAwait(false)를 사용해야 할까?

- **라이브러리 코드**: 재사용 가능한 라이브러리에서는 항상 `ConfigureAwait(false)`를 사용하는 것이 좋습니다. 라이브러리는 특정 애플리케이션 컨텍스트(UI, ASP.NET 등)를 가정하지 않기 때문입니다.
- **애플리케이션 최상위 레이어**: UI 이벤트 핸들러, ASP.NET 컨트롤러 액션 등에서는 `ConfigureAwait(false)`를 사용하면 안 됩니다. 왜냐하면 `await` 이후 UI 업데이트나 HTTP 응답을 보내야 하는데, 컨텍스트가 없으면 예외가 발생하거나 올바른 스레드에서 실행되지 않을 수 있습니다.

```csharp
// UI 이벤트 핸들러: ConfigureAwait(false) 사용 금지
private async void Button_Click(object sender, EventArgs e)
{
    var data = await LoadDataAsync(); // UI 컨텍스트 유지 필요
    textBox.Text = data; // UI 스레드에서 실행되어야 함
}

private async Task<string> LoadDataAsync()
{
    // 라이브러리 호출 시에는 ConfigureAwait(false) 사용 가능
    var result = await httpClient.GetStringAsync(url).ConfigureAwait(false);
    return result;
}
```

### ConfigureAwait(true)는?

`ConfigureAwait(true)`는 기본 동작(컨텍스트 캡처)과 동일하므로 굳이 명시할 필요가 없습니다. 보통 `ConfigureAwait(false)`만 사용됩니다.

---

## 추가 고급 개념

### ValueTask<T> : Task<T>의 가벼운 버전

`Task<T>`는 힙 할당이 발생합니다. 동기적으로 완료되는 경우가 많은 메서드에서는 불필요한 할당을 피하기 위해 `ValueTask<T>`를 사용할 수 있습니다.

```csharp
public ValueTask<int> CachedValueAsync()
{
    if (_cachedValue.HasValue)
        return new ValueTask<int>(_cachedValue.Value); // 동기 완료
    
    return new ValueTask<int>(LoadValueAsync()); // 비동기
}
```

### 비동기 스트림 (IAsyncEnumerable<T>)

C# 8.0에서는 `IAsyncEnumerable<T>`를 통해 여러 비동기 결과를 스트리밍할 수 있습니다.

```csharp
public async IAsyncEnumerable<int> GetNumbersAsync()
{
    for (int i = 0; i < 10; i++)
    {
        await Task.Delay(100);
        yield return i;
    }
}

await foreach (var num in GetNumbersAsync())
{
    Console.WriteLine(num);
}
```

### 취소 토큰 (CancellationToken)

비동기 작업 취소는 `CancellationToken`을 통해 구현합니다.

```csharp
public async Task DoWorkAsync(CancellationToken cancellationToken = default)
{
    for (int i = 0; i < 10; i++)
    {
        cancellationToken.ThrowIfCancellationRequested();
        await Task.Delay(1000, cancellationToken);
    }
}

// 사용
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));
try
{
    await DoWorkAsync(cts.Token);
}
catch (OperationCanceledException)
{
    Console.WriteLine("작업 취소됨");
}
```

---

## 실전 예제: 비동기 API 설계

다음은 위 개념들을 종합한 간단한 파일 다운로더 서비스입니다.

```csharp
public interface IDownloadService
{
    Task<string> DownloadContentAsync(string url, CancellationToken cancellationToken = default);
}

public class DownloadService : IDownloadService
{
    private readonly HttpClient _httpClient;
    
    public DownloadService(HttpClient httpClient)
    {
        _httpClient = httpClient;
    }
    
    public async Task<string> DownloadContentAsync(string url, CancellationToken cancellationToken = default)
    {
        try
        {
            // ConfigureAwait(false): 라이브러리 코드이므로 불필요한 컨텍스트 복원 방지
            var response = await _httpClient.GetAsync(url, cancellationToken)
                .ConfigureAwait(false);
                
            response.EnsureSuccessStatusCode();
            
            return await response.Content.ReadAsStringAsync()
                .ConfigureAwait(false);
        }
        catch (OperationCanceledException)
        {
            // 취소는 상위로 전파 (호출자가 처리)
            throw;
        }
        catch (Exception ex)
        {
            // 예외를 래핑하여 비즈니스 의미 전달
            throw new DownloadException($"Failed to download from {url}", ex);
        }
    }
}

// 사용 예 (ASP.NET Core 컨트롤러)
[ApiController]
[Route("api/[controller]")]
public class DataController : ControllerBase
{
    private readonly IDownloadService _downloadService;
    
    public DataController(IDownloadService downloadService)
    {
        _downloadService = downloadService;
    }
    
    [HttpGet]
    public async Task<ActionResult<string>> GetData(string url, CancellationToken cancellationToken)
    {
        try
        {
            // 여기서는 ConfigureAwait(false)를 사용하지 않음
            // ASP.NET Core는 SynchronizationContext가 없지만, 그래도 명시할 필요 없음
            var content = await _downloadService.DownloadContentAsync(url, cancellationToken);
            return Ok(content);
        }
        catch (DownloadException ex)
        {
            return BadRequest(ex.Message);
        }
    }
}
```

---

## 성능 고려사항 및 모범 사례

1. **비동기 메서드는 끝까지 비동기로**  
   동기 메서드를 비동기로 감싸지 말고, 진정한 비동기 구현을 사용하세요. `Task.Run`을 사용한 감싸기는 스레드 풀 스레드를 점유하므로 I/O 작업에는 적합하지 않습니다.

2. **ConfigureAwait(false)는 라이브러리에서 습관화**  
   재사용 가능한 라이브러리 코드에서는 모든 `await` 뒤에 `ConfigureAwait(false)`를 붙이는 것이 안전합니다.

3. **async void 사용 자제**  
   이벤트 핸들러 외에는 `async void`를 사용하지 마세요. 예외가 Catch되지 않고 프로세스를 종료시킬 수 있습니다.

4. **취소 토큰 항상 전달**  
   취소 가능한 작업에는 항상 `CancellationToken`을 매개변수로 받고, 내부 비동기 호출에 전달하세요.

5. **Task.Wait() / Task.Result 사용 금지**  
   데드락 위험과 스레드 풀 효율성을 저하시킵니다. 가능하면 `await`를 사용하세요.

6. **CPU 바운드와 I/O 바운드 구분**  
   CPU 바운드 작업은 `Task.Run`으로 스레드 풀에 위임하고, I/O 바운드는 `async`/`await`로 처리하세요.

---

## 결론

C#의 비동기 프로그래밍 모델은 `async`/`await`와 `Task`를 중심으로 간결하면서도 강력한 추상화를 제공합니다. 이를 올바르게 이해하고 사용하면 확장성 높은 애플리케이션을 구축할 수 있습니다.

- **`async`/`await`**: 비동기 코드를 동기 코드처럼 작성하게 해줍니다.
- **`Task`**: 비동기 작업의 단위로, 작업 상태를 관리하고 조합할 수 있는 풍부한 API를 제공합니다.
- **Task vs Thread**: Task는 작업의 추상화이며, 스레드는 실제 실행 단위입니다. Task는 스레드 풀을 효율적으로 사용하며, I/O 작업 시 스레드를 차단하지 않습니다.
- **`ConfigureAwait(false)`**: 컨텍스트 캡처를 방지하여 성능을 향상시키고 데드락을 예방합니다. 특히 라이브러리 코드에서 중요합니다.

이러한 개념들을 실무에 올바르게 적용하면, 응답성이 뛰어나고 확장 가능한 현대적인 애플리케이션을 개발할 수 있을 것입니다.