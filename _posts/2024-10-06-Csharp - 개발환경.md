---
layout: post
title: C# - 개발환경
date: 2024-10-06 19:20:23 +0900
category: Csharp
---
# C# 개발 환경 설정 (VS Code 기준)

## 개요 — 무엇을 설치하고 어떻게 쓸 것인가

**필수 항목**은 .NET SDK, VS Code, 그리고 C# 확장입니다.  
**선택 사항**으로는 C# Dev Kit(향상된 프로젝트 관리 및 테스트 도구), Docker(컨테이너 개발), Dev Containers, WSL(Windows에서 Linux 개발 환경) 등을 고려할 수 있습니다.

**권장 설정 흐름**은 다음과 같습니다:

1. .NET SDK 설치
2. VS Code와 C# 확장 설치
3. `dotnet new` 명령어로 첫 프로젝트 생성
4. `launch.json`과 `tasks.json`을 설정하여 디버깅 및 빌드 자동화
5. NuGet을 통해 외부 패키지 관리
6. 테스트 및 코드 포맷팅 도구 도입
7. 필요에 따라 컨테이너, WSL, CI/CD 파이프라인으로 개발 환경 확장

---

## .NET SDK 설치

### 공식 다운로드

[.NET 다운로드 페이지](https://dotnet.microsoft.com/ko-kr/download)에서 사용 중인 운영체제(OS)에 맞는 **.NET SDK**(런타임이 아닌 SDK)를 내려받아 설치합니다.

### 설치 확인

터미널에서 다음 명령어를 실행하여 설치를 확인하세요.

```bash
dotnet --info
dotnet --version
```

`dotnet --version`을 실행했을 때 (예: `9.0.100`) 같은 버전 문자열이 출력되면 정상적으로 설치된 것입니다. `dotnet --info`는 설치된 SDK와 런타임의 상세 목록, 런타임 식별자(RID), 경로 등을 보여줍니다.

### 흔히 발생하는 문제와 해결법

*   **'dotnet' 명령을 찾을 수 없음**: 시스템 PATH 환경 변수에 SDK 경로가 제대로 추가되지 않았을 수 있습니다.
    *   Windows: `C:\Program Files\dotnet\` 경로가 PATH에 포함되어 있는지 확인하세요.
    *   macOS: `/usr/local/share/dotnet/` 경로를 확인하거나, `~/.zprofile`, `~/.zshrc` 파일에 PATH를 추가하세요.
    *   Linux: 배포판의 패키지 관리자로 설치했다면 `/usr/share/dotnet` 같은 기본 경로를 확인하세요.
*   **여러 버전의 SDK가 공존하는 경우**: 프로젝트마다 사용할 SDK 버전을 고정하려면 프로젝트 루트에 `global.json` 파일을 생성하세요.

```json
{
  "sdk": {
    "version": "9.0.100",
    "rollForward": "latestFeature"
  }
}
```

---

## Visual Studio Code 설치

### 다운로드 및 설치

[Visual Studio Code 공식 사이트](https://code.visualstudio.com/)에서 설치 파일을 다운로드합니다. 설치 후 터미널에서 `code` 명령을 사용하려면 다음 설정이 필요할 수 있습니다.
*   macOS: VS Code 실행 → Command Palette(⇧⌘P) → “Shell Command: Install 'code' command in PATH” 실행
*   Windows: 기본 설치 옵션을 선택하면 대부분 자동으로 PATH에 등록됩니다.
*   Linux: 배포판 스토어 또는 직접 `.deb`/`.rpm` 패키지를 설치합니다.

### 필수 및 권장 확장 프로그램

1.  **C# (Microsoft)**: IntelliSense(코드 완성), 디버깅, 리팩토링 등 핵심 언어 지원을 제공하는 필수 확장입니다.
2.  **C# Dev Kit (Microsoft, 선택)**: 솔루션/프로젝트 탐색기, 통합 테스트 러너, 향상된 코드 탐색 기능을 제공하여 대규모 프로젝트 관리 편의성을 높여줍니다.
3.  **.NET Test Explorer (선택)**: 또는 C# Dev Kit에 내장된 테스트 뷰를 사용하여 테스트 케이스를 관리하고 실행할 수 있습니다.
4.  **EditorConfig for VS Code**: 프로젝트 간 일관된 코딩 스타일을 유지하는 데 도움을 줍니다.
5.  **GitLens**: Git 저장소의 변경 이력, 코드 작성자 확인(Blame), 코드 리뷰 기능을 강화해줍니다.
6.  **Docker**: 컨테이너 기반 개발을 할 경우 유용한 도구입니다.

> 확장 프로그램은 VS Code 좌측 활동 모음의 Extensions(확장) 탭에서 검색하여 설치할 수 있습니다.

---

## 첫 C# 프로젝트 생성하기

### 콘솔 애플리케이션 템플릿 사용

터미널에서 다음 명령어를 차례로 실행합니다.

```bash
mkdir HelloCSharp && cd HelloCSharp
dotnet new console
code .
```

이 명령어들은 `HelloCSharp` 디렉터리를 만들고, 콘솔 애플리케이션 템플릿을 기반으로 프로젝트를 생성한 후, VS Code로 해당 폴더를 엽니다. `Program.cs`와 `HelloCSharp.csproj` 파일이 생성됩니다.

### 생성된 Program.cs 파일

```csharp
using System;

class Program
{
    static void Main()
    {
        Console.WriteLine("Hello from VS Code!");
    }
}
```

### 프로젝트 실행

VS Code 내장 터미널(`Ctrl + ~`) 또는 외부 터미널에서 프로젝트 루트 디렉터리로 이동한 후 아래 명령어를 실행하세요.

```bash
dotnet run
```

정상적으로 실행된다면 `Hello from VS Code!` 문구가 출력됩니다.

---

## 디버깅 설정 — launch.json 이해와 활용

VS Code에서 C# 프로젝트를 효율적으로 디버그하려면 설정이 필요합니다. 상단 메뉴에서 **Run > Add Configuration**을 선택하면 `.vscode/launch.json` 파일이 자동으로 생성됩니다. 일반적인 .NET 콘솔 앱을 위한 설정 예시는 다음과 같습니다.

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": ".NET Launch (console)",
      "type": "coreclr",
      "request": "launch",
      "program": "${workspaceFolder}/bin/Debug/net9.0/HelloCSharp.dll",
      "args": [],
      "cwd": "${workspaceFolder}",
      "console": "integratedTerminal",
      "stopAtEntry": false,
      "justMyCode": true,
      "env": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  ]
}
```

*   **중단점(Breakpoint) 설정**: 코드 편집기 왼쪽 여백을 클릭하면 빨간 점이 표시됩니다.
*   **변수 확인**: 디버깅이 시작되면 하단의 디버그 패널에서 Watch, Locals, Call Stack 등을 확인할 수 있습니다.
*   **조건부 중단점**: 중단점 위에서 마우스 오른쪽 버튼을 클릭하여 조건(예: `i == 100`)을 추가할 수 있습니다.
*   **환경 제어**: `env`와 `cwd` 필드를 통해 애플리케이션의 환경 변수와 작업 디렉터리를 제어할 수 있습니다.

---

## 빌드·테스트 자동화 — tasks.json 활용

VS Code의 Tasks 기능을 사용하면 빌드, 테스트 등의 반복 작업을 키보드 단축키나 명령 팔레트에서 쉽게 실행할 수 있습니다.

```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "dotnet build",
      "command": "dotnet",
      "type": "process",
      "args": [ "build", "${workspaceFolder}" ],
      "problemMatcher": "$msCompile",
      "group": "build"
    },
    {
      "label": "dotnet test",
      "command": "dotnet",
      "type": "process",
      "args": [ "test", "${workspaceFolder}" ],
      "problemMatcher": "$msCompile",
      "group": "test"
    }
  ]
}
```

*   **빌드 실행**: `Ctrl+Shift+B`를 누르거나 명령 팔레트(Ctrl+Shift+P)에서 "Run Task"를 선택한 후 "dotnet build"를 고르면 빌드가 실행됩니다.
*   **테스트 자동화**: `dotnet test` 작업도 동일한 방식으로 실행하거나, 자주 사용한다면 별도의 키 바인딩을 설정할 수 있습니다.

---

## 프로젝트 구조 확장 — 솔루션, 라이브러리, 테스트 프로젝트

### 솔루션과 다중 프로젝트 구성

실제 애플리케이션은 여러 프로젝트(라이브러리, 실행 파일, 테스트)로 구성되는 경우가 많습니다. 다음 명령어로 솔루션을 생성하고 프로젝트를 추가해 보세요.

```bash
# 솔루션 및 프로젝트 생성
mkdir VscodeCsharpDemo && cd VscodeCsharpDemo
dotnet new sln -n VscodeCsharpDemo

dotnet new classlib -n Demo.Core
dotnet new console -n Demo.Cli
dotnet new xunit -n Demo.Tests

# 솔루션에 프로젝트 추가 및 참조 설정
dotnet sln add Demo.Core/Demo.Core.csproj Demo.Cli/Demo.Cli.csproj Demo.Tests/Demo.Tests.csproj
dotnet add Demo.Cli/Demo.Cli.csproj reference Demo.Core/Demo.Core.csproj
dotnet add Demo.Tests/Demo.Tests.csproj reference Demo.Core/Demo.Core.csproj

code .
```

### Core 라이브러리 예제

```csharp
// Demo.Core/StringTools.cs
namespace Demo.Core;

public static class StringTools
{
    public static string Reverse(string s)
        => new string(s.Reverse().ToArray());
}
```

### CLI 애플리케이션에서 라이브러리 사용

```csharp
// Demo.Cli/Program.cs
using Demo.Core;

Console.WriteLine(StringTools.Reverse("Hello VS Code"));
```

### xUnit을 이용한 단위 테스트 작성

```csharp
// Demo.Tests/StringToolsTests.cs
using Demo.Core;
using Xunit;

public class StringToolsTests
{
    [Fact]
    public void Reverse_Works()
    {
        var r = StringTools.Reverse("abc");
        Assert.Equal("cba", r);
    }
}
```

터미널에서 솔루션 루트로 이동한 후 `dotnet test` 명령어를 실행하면 모든 테스트를 실행할 수 있습니다.

---

## NuGet 패키지 관리 — Newtonsoft.Json 예시

외부 라이브러리는 NuGet 패키지 관리자를 통해 추가합니다. 예를 들어 JSON 직렬화에 널리 쓰이는 Newtonsoft.Json 패키지를 추가해 보겠습니다.

```bash
dotnet add Demo.Cli/Demo.Cli.csproj package Newtonsoft.Json
```

그리고 다음과 같이 코드에서 사용할 수 있습니다.

```csharp
// Demo.Cli/Program.cs
using Newtonsoft.Json;
using Demo.Core;

var obj = new { Msg = "Hello", Time = DateTimeOffset.UtcNow };
string json = JsonConvert.SerializeObject(obj);
Console.WriteLine(json);
Console.WriteLine(StringTools.Reverse("Package"));
```

*   **특정 버전 설치**: `dotnet add package Newtonsoft.Json --version 13.*`
*   **사설 패키지 저장소**: `NuGet.Config` 파일을 통해 사용자 정의 패키지 소스를 등록할 수 있습니다.

---

## 코드 품질 관리 — .editorconfig, 정적 분석, 포맷팅

### .editorconfig를 통한 코딩 규칙 정의

프로젝트 루트에 `.editorconfig` 파일을 생성하여 팀 전체의 코드 스타일을 통일할 수 있습니다.

```ini
root = true

[*.cs]
charset = utf-8-bom
indent_style = space
indent_size = 4
end_of_line = lf

# C# 코딩 규칙 예시
dotnet_diagnostic.IDE0055.severity = warning  # 서식 규칙 위반 시 경고
dotnet_diagnostic.CA1062.severity = warning   # Null 체크 경고
dotnet_style_qualification_for_field = false:suggestion
csharp_prefer_braces = when_multiline:suggestion
csharp_style_namespace_declarations = file_scoped:suggestion
```

### 코드 포맷팅 및 정적 분석

`dotnet format` 도구를 사용하면 프로젝트의 코드 서식을 일괄적으로 정리할 수 있습니다.

```bash
# 포맷터 전역 설치
dotnet tool install --global dotnet-format
# 프로젝트 포맷팅 실행
dotnet format
```

빌드 시 발생하는 모든 경고를 에러로 처리하려면 프로젝트 파일(.csproj)에 다음 설정을 추가하세요.

```xml
<PropertyGroup>
  <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
</PropertyGroup>
```

---

## 환경별 설정 관리 — appsettings, 환경 변수, User Secrets

### ASP.NET Core Minimal API와 설정 바인딩

웹 애플리케이션에서는 환경에 따라 다른 설정(연결 문자열, API 키 등)을 사용해야 합니다.

```csharp
// Demo.Cli/Program.cs (웹 애플리케이션 템플릿 기준)
var builder = WebApplication.CreateBuilder(args);

builder.Services.Configure<MyOptions>(builder.Configuration.GetSection("MyOptions"));
var app = builder.Build();

app.MapGet("/opts", (IOptions<MyOptions> opts) => Results.Json(opts.Value));

app.Run();

public record MyOptions(string ApiKey, string Endpoint);
```

```json
// appsettings.json (기본 설정)
{
  "MyOptions": {
    "ApiKey": "local-dev-key",
    "Endpoint": "https://dev.example.com"
  }
}
```

*   **환경별 설정 파일**: `appsettings.Development.json`, `appsettings.Production.json` 파일을 생성하여 환경별 값을 오버라이드할 수 있습니다.
*   **환경 변수**: `ASPNETCORE_ENVIRONMENT` 환경 변수를 `Development`, `Production` 등으로 설정하면 해당 환경의 설정 파일이 자동으로 로드됩니다.

### 민감 정보 보호를 위한 User Secrets

개발 중 사용하는 API 키나 비밀번호 같은 민감 정보는 소스 코드에 직접 포함시키지 말고 User Secrets를 활용하세요.

```bash
cd Demo.Cli
dotnet user-secrets init
dotnet user-secrets set "MyOptions:ApiKey" "super-secret"
```

이렇게 설정한 값은 개발 환경에서 `appsettings.Development.json`의 값을 오버라이드하며, 소스 코드 저장소에는 노출되지 않습니다.

---

## 통합 터미널 사용 팁

VS Code 내장 터미널(`Ctrl + ~`)은 프로젝트 루트에서 바로 `dotnet run`, `dotnet build`, `dotnet test` 등의 명령을 실행할 수 있어 매우 편리합니다. 멀티 루트 워크스페이스를 사용할 경우 각 폴더별로 독립된 터미널을 열어 작업할 수도 있습니다.

---

## WSL(Windows Subsystem for Linux)과 연동

Windows 사용자는 WSL을 설치하여 리눅스 환경에서 .NET 개발을 진행할 수 있습니다. **Remote - WSL** 확장을 설치하면 WSL 배포판 내부의 파일 시스템을 VS Code에서 직접 열고, 빌드하고, 디버깅할 수 있어 Windows와 Linux 사이의 환경 차이에서 자유로울 수 있습니다.

### 간단한 설정 흐름

1.  Microsoft Store에서 Ubuntu 같은 Linux 배포판을 설치합니다.
2.  Ubuntu 터미널에서 `.NET SDK`를 설치합니다.
3.  VS Code에서 "Open Folder in WSL" 옵션을 선택합니다.
4.  이후의 작업 흐름(`dotnet new`, `dotnet run`, 디버깅)은 로컬 Windows 환경과 동일합니다.

---

## Dev Containers — 재현 가능한 개발 환경 구축

팀 전체가 동일한 개발 환경을 유지하려면 Dev Containers를 사용하는 것이 좋습니다. 프로젝트에 `.devcontainer/devcontainer.json` 파일을 정의하면, 컨테이너 기반의 완전히 일관된 환경에서 코딩할 수 있습니다.

```json
// .devcontainer/devcontainer.json
{
  "name": "C# Dev",
  "image": "mcr.microsoft.com/dotnet/sdk:9.0",
  "postCreateCommand": "dotnet --info",
  "customizations": {
    "vscode": {
      "extensions": [
        "ms-dotnettools.csdevkit",
        "ms-dotnettools.csharp",
        "ms-azuretools.vscode-docker",
        "editorconfig.editorconfig"
      ]
    }
  }
}
```

VS Code에서 "Reopen in Container" 명령을 실행하면, 정의된 Docker 이미지 기반의 컨테이너가 생성되고 그 안에서 모든 개발 작업이 이루어집니다. 이는 새 팀원의 온보딩 시간을 크게 줄이고, CI/CD 환경과의 일치성을 보장합니다.

---

## 고급 디버깅 — 다중 프로필, 인자 전달, 환경 구성

실제 개발에서는 다양한 조건으로 애플리케이션을 디버깅해야 할 필요가 있습니다. `launch.json`에 여러 구성을 정의하여 상황에 맞게 선택할 수 있습니다.

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": ".NET Debug (Default)",
      "type": "coreclr",
      "request": "launch",
      "program": "${workspaceFolder}/Demo.Cli/bin/Debug/net9.0/Demo.Cli.dll",
      "args": [],
      "cwd": "${workspaceFolder}/Demo.Cli",
      "console": "integratedTerminal"
    },
    {
      "name": ".NET Debug (WithArgs)",
      "type": "coreclr",
      "request": "launch",
      "program": "${workspaceFolder}/Demo.Cli/bin/Debug/net9.0/Demo.Cli.dll",
      "args": ["--seed", "42", "--verbose"],
      "env": {
        "LOG_LEVEL": "Debug"
      },
      "cwd": "${workspaceFolder}/Demo.Cli"
    }
  ]
}
```

ASP.NET Core 애플리케이션을 디버깅할 때는 `launchSettings.json`에 정의된 프로필을 참고하거나, `program` 필드에 `"${workspaceFolder}/bin/Debug/net9.0/YourWebApp.dll"`을, `args` 필드에 `["--urls", "https://localhost:5001"]`과 같은 Kestrel 실행 인자를 명시적으로 설정할 수 있습니다. HTTPS 개발 인증서 문제가 발생하면 `dotnet dev-certs https --trust` 명령어로 인증서를 신뢰할 수 있습니다.

---

## 성능 측정 — BenchmarkDotNet 활용

알고리즘 또는 특정 코드 조각의 성능을 정확히 측정하고 싶을 때는 BenchmarkDotNet 라이브러리를 사용하세요.

```bash
# 벤치마크 전용 콘솔 프로젝트 생성
dotnet new console -n BenchDemo
dotnet add BenchDemo/BenchDemo.csproj package BenchmarkDotNet
```

```csharp
// BenchDemo/Program.cs
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

[MemoryDiagnoser]
public class Bench
{
    [Benchmark] public int SumLinq() => Enumerable.Range(0, 1000).Sum();
    [Benchmark] public int SumLoop() { int s=0; for(int i=0;i<1000;i++) s+=i; return s; }
}

BenchmarkRunner.Run<Bench>();
```

```bash
# 릴리스 모드로 벤치마크 실행 (디버그 모드에서는 정확한 측정이 어려움)
dotnet run -c Release
```

실행 결과는 메모리 할당량과 실행 시간을 포함한 상세한 보고서로 제공되어 성능 비교에 매우 유용합니다.

---

## 예외 처리 및 로깅 — 견고한 애플리케이션을 위한 필수 요소

### 예외 필터를 활용한 정교한 오류 처리

C# 6.0부터 도입된 예외 필터(Exception Filter)를 사용하면 특정 조건에서만 예외를 잡을 수 있습니다.

```csharp
try
{
    DangerousOperation();
}
catch (Exception ex) when (ex.Message.Contains("retryable"))
{
    // "retryable" 문자열이 포함된 예외만 여기서 처리하여 재시도 로직 수행
    RetryLogic();
}
```

### 구조화된 로깅

`Microsoft.Extensions.Logging`을 사용하면 콘솔, 파일, 외부 서비스 등 다양한 대상으로 구조화된 로그를 출력할 수 있습니다.

```csharp
using Microsoft.Extensions.Logging;

using var loggerFactory = LoggerFactory.Create(builder => builder.AddSimpleConsole());
var logger = loggerFactory.CreateLogger<Program>();

logger.LogInformation("애플리케이션이 {StartTime}에 시작되었습니다.", DateTimeOffset.UtcNow);
```

---

## 자주 만나는 문제와 해결 방법

| 증상 | 가능한 원인 | 해결 방안 |
| :--- | :--- | :--- |
| `The framework 'Microsoft.NETCore.App', version 'x.x.x' was not found.` | 해당 버전의 .NET 런타임이 설치되지 않았거나 프로젝트 대상 버전과 불일치 | 올바른 버전의 SDK/런타임 설치, 프로젝트의 `TargetFramework` 또는 솔루션의 `global.json` 확인 |
| `The SDK 'Microsoft.NET.Sdk' specified could not be found.` | SDK가 설치되지 않았거나 PATH에 없음, VS Code가 올바른 SDK 버전을 인식하지 못함 | .NET SDK 재설치, 시스템 PATH 확인, VS Code 재시작 |
| `Required assets to build and debug are missing.` | `.vscode` 폴더 내 디버깅 구성 파일이 없음 | VS Code가 제안하는 **"Yes"** 버튼 클릭 (자동 생성) 또는 `launch.json`, `tasks.json` 수동 생성 |
| HTTPS 개발 인증서 오류 (주로 macOS/Linux) | 로컬 개발 인증서가 신뢰되지 않음 | 터미널에서 `dotnet dev-certs https --trust` 실행 |
| NuGet 패키지 복원 실패 | 네트워크 문제, 패키지 소스 설정 오류, 프록시 문제 | `dotnet restore -s <feed-url>` 명령어 시도, 프록시 설정 확인, `NuGet.Config` 파일 점검 |

---

## 문서화와 품질 관리 — XML 주석 및 코드 분석

### XML 문서 주석 생성

public API에 대한 설명을 자동으로 생성하고, IntelliSense에 표시하려면 XML 문서 주석을 활성화하세요.

```xml
<!-- .csproj 파일 내 -->
<PropertyGroup>
  <GenerateDocumentationFile>true</GenerateDocumentationFile>
  <!-- 문서 주석이 없는 public API에 대해 CS1591 경고를 표시하지 않도록 설정 -->
  <NoWarn>$(NoWarn);1591</NoWarn>
</PropertyGroup>
```

### 코드 분석 규칙 강화

최신 코드 분석 규칙을 적용하고, 특정 경고를 에러로 승격시켜 코드 품질을 엄격히 관리할 수 있습니다.

```xml
<PropertyGroup>
  <AnalysisLevel>latest</AnalysisLevel>
  <!-- CS8602(널 참조 가능성 역참조), CS8618(널 불가 필드 미초기화)를 에러로 처리 -->
  <WarningsAsErrors>CS8602;CS8618</WarningsAsErrors>
</PropertyGroup>
```

---

## 배포 준비 — Self-contained, Single-file, ReadyToRun

애플리케이션을 배포할 때는 대상 시스템에 .NET 런타임이 설치되어 있지 않을 수 있습니다. Self-contained 배포를 통해 런타임을 포함시키고, Single-file로 패키징하여 배포를 단순화할 수 있습니다.

```bash
dotnet publish -c Release \
               -r linux-x64 \
               --self-contained true \
               -p:PublishSingleFile=true \
               -p:PublishReadyToRun=true
```

*   **Self-contained**: 애플리케이션과 함께 .NET 런타임을 포함시켜 별도 설치 없이 실행 가능합니다.
*   **Single-file**: 모든 의존성을 단일 실행 파일로 패키징합니다.
*   **ReadyToRun(R2R)**: 일부 코드를 미리 네이티브 코드로 컴파일하여 시작 속도를 향상시킵니다. (파일 크기 증가와 리플렉션 사용 제한을 고려해야 함)

---

## 학습 로드맵 — 단계별 실습 추천

체계적으로 C#과 .NET 생태계를 익히려면 다음 순서로 실습 프로젝트를 진행해 보는 것을 권장합니다.

1.  **콘솔 유틸리티 개발**: 파일 입출력, HTTP 클라이언트, JSON 파싱 등 기본 라이브러리 활용법 익히기.
2.  **웹 API 구축**: Minimal API로 간단한 REST API 만들기, Swagger 연동, 통합 테스트 작성하기.
3.  **데이터 액세스**: Entity Framework Core를 사용해 SQLite나 SQL Server에 데이터 저장 및 조회하기.
4.  **백그라운드 작업**: `BackgroundService`를 상속받아 큐 처리나 주기적 배치 작업 구현하기.
5.  **컨테이너화**: Dockerfile 작성 및 Dev Containers로 개발 환경 구성하기.
6.  **클라우드 배포**: GitHub Actions를 구성하여 Azure App Service나 AWS에 애플리케이션 자동 배포하기.

---

## 종합 실습: "메모 API" 프로젝트 (VS Code에서 완전 정복)

위에서 배운 개념들을 총동원하여 간단한 메모장 API를 만들어 보겠습니다.

### 프로젝트 생성 및 기본 구조

```bash
mkdir MemoApi && cd MemoApi
dotnet new web -n MemoApi
code .
```

### Minimal API로 핵심 기능 구현

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

app.UseSwagger();
app.UseSwaggerUI();

var store = new Dictionary<int, string>();
var nextId = 1;

app.MapGet("/memos", () => store.OrderBy(kv => kv.Key));
app.MapPost("/memos", (string text) =>
{
    var id = nextId++;
    store[id] = text;
    return Results.Created($"/memos/{id}", new { id, text });
});
app.MapGet("/memos/{id:int}", (int id) =>
    store.TryGetValue(id, out var text) ? Results.Ok(new { id, text }) : Results.NotFound());
app.MapPut("/memos/{id:int}", (int id, string text) =>
{
    if (!store.ContainsKey(id)) return Results.NotFound();
    store[id] = text;
    return Results.NoContent();
});
app.MapDelete("/memos/{id:int}", (int id) =>
{
    if (!store.Remove(id)) return Results.NotFound();
    return Results.NoContent();
});

app.Run();
```

### 디버깅 및 실행

`F5` 키를 눌러 디버깅을 시작하거나 `Ctrl+F5`로 실행합니다. 브라우저를 열어 `https://localhost:포트번호/swagger`에 접속하면 자동 생성된 Swagger UI에서 API를 테스트해 볼 수 있습니다.

### 통합 테스트 작성 (xUnit)

```bash
# 테스트 프로젝트 생성 및 참조 추가
dotnet new xunit -n MemoApi.Tests
dotnet add MemoApi.Tests/MemoApi.Tests.csproj package Microsoft.AspNetCore.Mvc.Testing
dotnet add MemoApi.Tests/MemoApi.Tests.csproj reference MemoApi/MemoApi.csproj
```

```csharp
// MemoApi.Tests/IntegrationTests.cs
using System.Net.Http.Json;
using Microsoft.AspNetCore.Mvc.Testing;
using Xunit;

public class IntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public IntegrationTests(WebApplicationFactory<Program> factory) => _client = factory.CreateClient();

    [Fact]
    public async Task CreateMemo_And_GetItBack()
    {
        // Create
        var response = await _client.PostAsJsonAsync("/memos?text=hello", new { });
        response.EnsureSuccessStatusCode();
        var created = await response.Content.ReadFromJsonAsync<dynamic>();
        int id = (int)created.id;

        // Read
        var getResponse = await _client.GetAsync($"/memos/{id}");
        getResponse.EnsureSuccessStatusCode();
        var fetched = await getResponse.Content.ReadFromJsonAsync<dynamic>();
        Assert.Equal("hello", (string)fetched.text);
    }
}
```

`dotnet test` 명령어로 통합 테스트를 실행하여 API 엔드포인트들이 예상대로 동작하는지 확인할 수 있습니다.

---

## 핵심 요약 표

| 항목 | 설명 |
| :--- | :--- |
| **필수 설치** | .NET SDK, Visual Studio Code, C# 확장 프로그램 |
| **프로젝트 시작** | `dotnet new console/web` → `code .` |
| **실행과 디버깅** | `dotnet run`, `launch.json` 설정, 중단점 활용 |
| **코드 품질** | xUnit 테스트, .editorconfig, Roslyn Analyzers, `dotnet format` |
| **패키지 관리** | `dotnet add package <패키지명>` |
| **환경 구성** | `appsettings.*.json`, 환경 변수, User Secrets |
| **환경 확장** | WSL, Docker & Dev Containers, CI/CD 파이프라인 |

---

## 부록 — 자주 사용하는 .NET CLI 명령어

```bash
# 프로젝트 템플릿 관련
dotnet new list                     # 사용 가능한 템플릿 목록 보기
dotnet new console -n MyApp         # 콘솔 애플리케이션 생성
dotnet new webapi -n MyApi          # Web API 프로젝트 생성
dotnet new classlib -n MyLibrary    # 클래스 라이브러리 프로젝트 생성
dotnet new xunit -n MyTests         # xUnit 테스트 프로젝트 생성

# 프로젝트 간 참조 및 패키지 관리
dotnet add reference ../Lib/Lib.csproj      # 프로젝트 참조 추가
dotnet add package Newtonsoft.Json          # NuGet 패키지 추가
dotnet add package Serilog.AspNetCore --version 8.*

# 빌드, 실행, 테스트
dotnet build                         # 프로젝트 빌드
dotnet run --project Api/Api.csproj  # 특정 프로젝트 실행
dotnet test                          # 모든 테스트 실행

# 배포 (퍼블리시)
dotnet publish -c Release -r linux-x64 --self-contained true -p:PublishSingleFile=true
```

---

## 마무리: VS Code와 C#의 궁합

VS Code는 가볍고 빠른 시작을 가능하게 하면서도, C# Dev Kit, 풍부한 확장 프로그램, 통합 터미널, 강력한 디버거를 통해 대규모 .NET 프로젝트 개발에도 필요한 생산성을 충분히 제공합니다. 이 가이드에서 소개한 도구와 워크플로를 차근차습 익혀나가면, 어느 IDE보다도 유연하고 효율적인 C# 개발 환경을 손에 넣을 수 있을 것입니다. 이제 여러분의 에디터에서 `dotnet new` 명령어를 입력하고, 첫 번째 프로젝트를 시작해 보세요.