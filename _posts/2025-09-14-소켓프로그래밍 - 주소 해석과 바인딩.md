---
layout: post
title: 소켓프로그래밍 - 주소 해석과 바인딩
date: 2025-09-14 16:25:23 +0900
category: 소켓프로그래밍
---
## 주소 해석과 바인딩의 모든 것

> 목표: **`getaddrinfo()` / `getnameinfo()`**를 정확히 이해하고, **IPv4/IPv6 겸용** 서버/클라이언트를 **C++23**으로 안전하게 작성한다.
> 핵심: “이름(혹은 리터럴) + 서비스(혹은 포트)” → **주소 후보 리스트** → **반복 시도(바인드/커넥트)** → **성공한 것만 사용**. 실패는 **명시적 에러**로 남긴다.

---

### 이름 해석(Host/Service)과 `getaddrinfo()`의 진짜 역할

#### 무엇을 해주나?

- **입력**:
  - `host`: **호스트명**(예: `example.com`), **IP 리터럴**(예: `127.0.0.1`, `::1`), 또는 **`nullptr`**
  - `service`: **서비스명**(예: `"http"`, `"ssh"`) 또는 **포트 문자열**(예: `"80"`, `"443"`)
- **힌트**(`addrinfo hints`)로 **의도**를 전달:
  - `ai_family`: `AF_UNSPEC`(둘 다), `AF_INET`, `AF_INET6`
  - `ai_socktype`: `SOCK_STREAM`(TCP) / `SOCK_DGRAM`(UDP)
  - `ai_flags`: `AI_PASSIVE`, `AI_ADDRCONFIG`, `AI_NUMERICHOST`, `AI_NUMERICSERV`, `AI_V4MAPPED`, `AI_ALL`, `AI_CANONNAME` …
- **출력**: (IPv6/IPv4 후보들을 **우선순위 순**으로) **연결/바인드 가능한 `sockaddr` 목록**.
  응용은 **상위부터 순서대로 시도**하다 **성공한 첫 후보**로 고정한다.

> 실무 규칙: “**`getaddrinfo()`는 단일 주소를 돌려주지 않는다**. **여러 후보**를 돌려준다 → **모두 시도**하라.”

#### 서버/클라이언트에서 `host`/`service` 관례

- **서버(바인드)**: `host = nullptr`, `AI_PASSIVE` → **와일드카드 주소**(IPv6 `::`, IPv4 `0.0.0.0`) 바인드 후보 생성
- **클라이언트(커넥트)**: `host = "example.com"` 같은 **이름/리터럴**, `AI_PASSIVE` **없이** 후보 생성
- **서비스명 vs 숫자 포트**: `"http"` → 80, `"https"` → 443. 모르는 서비스명이면 실패. *확실히 하려면* 숫자 문자열 사용.

---

### `getaddrinfo()` 완전 정복

#### 기본 형태(에러까지 포함한 패턴)

```cpp
#include <netdb.h>
#include <system_error>
#include <string>
#include <print>

struct addr_list {
    addrinfo* head{};
    addr_list() = default;
    addr_list(const addr_list&) = delete;
    addr_list& operator=(const addr_list&) = delete;
    ~addr_list() { if (head) ::freeaddrinfo(head); }
};

addr_list resolve_or_throw(const char* host, const char* service,
                           int family, int socktype, int flags) {
    addrinfo hints{};
    hints.ai_family   = family;     // AF_UNSPEC, AF_INET, AF_INET6
    hints.ai_socktype = socktype;   // SOCK_STREAM or SOCK_DGRAM
    hints.ai_protocol = 0;          // auto
    hints.ai_flags    = flags;      // AI_PASSIVE, AI_ADDRCONFIG, ...

    addrinfo* res = nullptr;
    int rc = ::getaddrinfo(host, service, &hints, &res);
    if (rc != 0) {
        // getaddrinfo는 errno가 아니라 자체 에러코드(EAI_*)를 반환한다
        std::string msg = ::gai_strerror(rc);
        throw std::runtime_error("getaddrinfo: " + msg);
    }
    addr_list L;
    L.head = res;
    return L; // RAII 래퍼 반환(성공)
}
```

#### 자주 쓰는 플래그

- **`AI_PASSIVE`**: 서버 바인딩용 와일드카드 주소 생성. `host == nullptr`과 함께 사용.
- **`AI_ADDRCONFIG`**: **현재 호스트에 구성된 주소 패밀리만** 결과로 준다(예: IPv6 주소가 하나도 없으면 v6 후보 제거).
- **`AI_NUMERICHOST`/`AI_NUMERICSERV`**: 호스트/서비스를 **무조건 숫자**로 간주(DNS 조회/서비스명 검색 방지).
- **`AI_V4MAPPED`/`AI_ALL`**: IPv6 우선 환경에서 IPv4 주소를 **V4-mapped(::ffff:a.b.c.d)** 로 반환할지 제어.

> 실무 팁: **서버**에서는 `AI_PASSIVE | AI_ADDRCONFIG` 조합이 기본. **클라이언트**는 `AI_ADDRCONFIG`만으로 충분한 경우가 많다.

---

### IPv4/IPv6 겸용 코드 패턴(이식성 핵심)

#### “둘 다 시도”의 골격

- `AF_UNSPEC` + `AI_ADDRCONFIG` 로 후보 생성 → **반복**: `socket()` → `bind()`/`connect()` → 실패 시 **다음 후보**로 넘어감.

```cpp
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cstring>
#include <print>

// 서버: dual-stack 후보 중 성공하는 것만 리슨
int listen_on(const char* bind_host, const char* port, int backlog = 128) {
    int flags = AI_PASSIVE | AI_ADDRCONFIG;
    auto L = resolve_or_throw(bind_host, port, AF_UNSPEC, SOCK_STREAM, flags);

    for (auto* ai = L.head; ai; ai = ai->ai_next) {
        int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;

        int yes = 1;
        ::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

        if (::bind(s, ai->ai_addr, ai->ai_addrlen) == 0 &&
            ::listen(s, backlog) == 0) {
            return s; // 첫 성공을 반환
        }
        ::close(s);
    }
    throw std::runtime_error("listen_on: no address worked");
}

// 클라이언트: dual-stack 후보 중 성공하는 것에 connect
int connect_to(const char* host, const char* port) {
    int flags = AI_ADDRCONFIG;
    auto L = resolve_or_throw(host, port, AF_UNSPEC, SOCK_STREAM, flags);

    for (auto* ai = L.head; ai; ai = ai->ai_next) {
        int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;
        if (::connect(s, ai->ai_addr, ai->ai_addrlen) == 0) {
            return s; // 성공
        }
        ::close(s);
    }
    throw std::runtime_error("connect_to: no address worked");
}
```

#### `IPV6_V6ONLY`와 v4-mapped

- **질문**: `::`(IPv6 any)에 바인드하면 **IPv4도** 같은 소켓으로 받을 수 있나?
  - **OS마다 다름**:
    - Linux 기본: `IPV6_V6ONLY = 0`(꺼짐) → **v4-mapped**로 IPv4 연결 수용
    - 일부 BSD/macOS 기본: `IPV6_V6ONLY = 1`(켜짐) → **별도 IPv4 소켓** 필요
- **정답**: **명시적으로** 설정하라.
```cpp
int s = ::socket(AF_INET6, SOCK_STREAM, 0);
if (s >= 0) {
    int v6only = 0; // 0이면 v4-mapped 허용
    ::setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
    // 그 다음 bind("::", port) → 리슨
}
```
- **정책**: 운영 환경이 섞이면 **v6 리스너 + v4 리스너를 각각** 띄우는 쪽이 명확하다(`SO_REUSEPORT`로 나눠도 좋음).

#### 링크-로컬 IPv6와 스코프 ID

- `fe80::1234%eth0` 처럼 **인터페이스(scope)** 가 필요한 주소가 있다.
  - `getaddrinfo()`는 `%eth0` 표기도 파싱해준다.
  - 수동 조립 시엔 `sockaddr_in6::sin6_scope_id`를 **직접 설정**해야 한다.
```cpp
sockaddr_in6 sa6{};
sa6.sin6_family = AF_INET6;
sa6.sin6_port   = htons(9000);
::inet_pton(AF_INET6, "fe80::1234", &sa6.sin6_addr);
sa6.sin6_scope_id = if_nametoindex("eth0"); // 중요!
::bind(s, (sockaddr*)&sa6, sizeof(sa6));
```

---

### 서버: 바인딩 패턴 총정리(와일드카드, 특정 IP, 다중 NIC)

#### 와일드카드 바인드(권장 시작점)

```cpp
// host=nullptr + AI_PASSIVE → 0.0.0.0 / :: 후보 생성
int s = listen_on(nullptr, "9000"); // dual-stack 후보 반복, 첫 성공
```
- **장점**: 시스템이 알아서 **적절한 NIC**를 선택해 수신.
- **주의**: v6-only 기본 OS에선 IPv4 별도 리스너 필요.

#### 특정 인터페이스/주소로 바인드

- **보안/정책**상 외부 NIC만 노출하거나 내부 전용 바인드가 필요할 때:
```cpp
int s = listen_on("10.0.0.5", "9000");      // IPv4 특정 IP
int s6 = listen_on("2001:db8::5", "9000");  // IPv6 특정 IP
```
- 같은 포트를 **여러 주소**로 바인드하려면 리스너를 **여러 개** 띄우면 된다(각각 `bind`/`listen`).

#### 백로그/큐/재기동

- `listen(fd, backlog)`는 **완료 큐(accept queue)** 크기 힌트.
- **재기동 편의**: `SO_REUSEADDR`(리눅스에서는 **TIME_WAIT 충돌 완화**에 도움).
- 멀티 프로세스/코어 분산: `SO_REUSEPORT`로 **동일 포트 다중 리스너**.

---

### 클라이언트: Happy Eyeballs(간단형), 연결 시도 순서

#### 반복

- RFC 6555 “Happy Eyeballs”는 **v6/v4 병행 시도**로 지연 최소화.
- 간단형(복잡한 동시 시도 없이 **짧은 지연**을 두고 순차 시도) 예:
{% raw %}
```cpp
#include <chrono>
#include <thread>

int connect_happy(const char* host, const char* port) {
    auto L = resolve_or_throw(host, port, AF_UNSPEC, SOCK_STREAM, AI_ADDRCONFIG);
    // 1) IPv6 후보 모으기 → 2) IPv4 후보 모으기
    std::vector<addrinfo*> v6, v4;
    for (auto* ai=L.head; ai; ai=ai->ai_next) {
        if (ai->ai_family == AF_INET6) v6.push_back(ai);
        else if (ai->ai_family == AF_INET) v4.push_back(ai);
    }
    auto try_list = [&](auto& list)->int{
        for (auto* ai: list) {
            int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
            if (s<0) continue;
            if (::connect(s, ai->ai_addr, ai->ai_addrlen)==0) return s;
            ::close(s);
        }
        return -1;
    };
    // v6 먼저 200ms 시도, 실패면 바로 v4
    int s = try_list(v6);
    if (s >= 0) return s;
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    s = try_list(v4);
    if (s >= 0) return s;
    throw std::runtime_error("connect_happy: no address worked");
}
```
{% endraw %}

- **실무**에선 비동기/타이머로 **동시 시도**를 더 정교하게 구현.

---

### 안전 출력

#### 왜 필요한가?

- 로깅/메트릭 시 **사람이 읽을 수 있는 문자열(IP:PORT)** 이 필요하다.
- `getnameinfo()`는 `sockaddr` → `"host:service"` 문자열을 만든다.

#### 숫자 전용 플래그(중요)

- **`NI_NUMERICHOST`**: 역방향 DNS를 **하지 않는다**(블로킹/지연 회피).
- **`NI_NUMERICSERV`**: `"http"` 대신 **"80"** 같이 숫자 포트.

```cpp
#include <netdb.h>
#include <string>

std::string to_string(const sockaddr* sa, socklen_t salen) {
    char host[NI_MAXHOST]{}, serv[NI_MAXSERV]{};
    int rc = ::getnameinfo(sa, salen, host, sizeof(host), serv, sizeof(serv),
                           NI_NUMERICHOST | NI_NUMERICSERV);
    if (rc == 0) return std::string(host) + ":" + serv;
    return "(unknown)";
}
```

#### 사용 예: accept 직후/연결 직후 로깅

```cpp
sockaddr_storage cli{}; socklen_t len = sizeof(cli);
int cfd = ::accept(lfd, (sockaddr*)&cli, &len);
if (cfd >= 0) {
    std::print("[accept] peer={}\n", to_string((sockaddr*)&cli, len));
}
```

---

### 서비스명/포트와 `AI_NUMERICSERV`

#### 서비스명 해석 실패 방지

- 시스템에 `"myservice"` 등록이 없으면 **실패**.
- **정해진 포트**를 사용할 땐 `"9000"` 같이 **숫자 문자열**이 안전.

```cpp
auto L = resolve_or_throw(nullptr, "9000", AF_UNSPEC, SOCK_STREAM,
                          AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV);
```

---

### 숫자 리터럴만 빠르게: `AI_NUMERICHOST`

- **실험/내부 툴**에서 DNS를 전혀 쓰지 않고, **IP 리터럴만** 다루고 싶을 때:
```cpp
auto L = resolve_or_throw("127.0.0.1", "9000", AF_UNSPEC, SOCK_STREAM,
                          AI_ADDRCONFIG | AI_NUMERICHOST | AI_NUMERICSERV);
```
- 호스트가 리터럴이 아니면 **즉시 에러** → 문제를 빨리 드러내 유용.

---

### `addrinfo` 순회와 ‘첫 성공’ 정책 — 모든 실패는 로그로 남기자

- 후보가 `AF_INET6 → AF_INET → ...` 순으로 온다고 **가정하지 말자**(플랫폼/정책에 따라 다름).
- **반드시 루프**로 `socket()`/`bind()` 혹은 `connect()`를 **모두** 시도.
- 실패할 때마다 **에러 코드**와 **주소 문자열**을 **로그**로 남기면 현장 트러블슈팅이 쉬워진다.

```cpp
for (auto* ai = L.head; ai; ai = ai->ai_next) {
    int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
    if (s < 0) { std::print(stderr, "socket({}): {}\n", ai->ai_family, strerror(errno)); continue; }
    if (::connect(s, ai->ai_addr, ai->ai_addrlen) == 0) return s;
    std::print(stderr, "connect({}): {} to {}\n",
               ai->ai_family, strerror(errno),
               to_string(ai->ai_addr, ai->ai_addrlen));
    ::close(s);
}
```

---

### `gai_strerror()`와 EAI_* 에러 군

- `getaddrinfo()` 실패 코드는 **`EAI_*`**(예: `EAI_AGAIN` DNS 일시 실패, `EAI_NONAME` 이름 없음).
- 숫자→문자열 변환은 **`gai_strerror(int)`** 로 수행.
- **주의**: `errno` 와 별개다. `errno`를 보지 말고 **반환값**을 확인하라.

---

### 안전한 `sockaddr_storage` 사용과 캐스팅

- 가장 큰 주소형(`sockaddr_in6`)까지 담을 수 있는 **`sockaddr_storage`** 를 쓰고, 필요 시 **다운캐스팅**:
```cpp
sockaddr_storage ss{}; socklen_t slen = sizeof(ss);
int cfd = ::accept(lfd, (sockaddr*)&ss, &slen);

if (ss.ss_family == AF_INET) {
    auto* v4 = (sockaddr_in*)&ss;
    // v4->sin_addr, v4->sin_port
} else if (ss.ss_family == AF_INET6) {
    auto* v6 = (sockaddr_in6*)&ss;
    // v6->sin6_addr, v6->sin6_port, v6->sin6_scope_id
}
```

---

### `inet_pton/ntop`를 쓸 때의 주의(직접 파싱 경로)

- 리터럴을 직접 다룰 땐 **`inet_pton()`** / **`inet_ntop()`**:
  - 스코프가 있는 IPv6(`fe80::1%eth0`)은 `inet_pton()`이 **%zone**을 처리하지 못함 → **`sin6_scope_id`** 를 따로 설정하거나 `getaddrinfo()` 사용.
  - 포트는 별개다. `inet_pton()`은 **주소만** 파싱.

---

### 서버/클라이언트 “완성도 높은” 예제(요지)

#### 서버: dual-stack + v6only 명시 + 로깅

```cpp
int create_listen_dual(const char* port, int backlog = 256) {
    // 1) IPv6 리스너 (v4-mapped 허용 여부를 정책적으로 결정)
    addr_list L6 = resolve_or_throw(nullptr, port, AF_INET6, SOCK_STREAM, AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV);

    for (auto* ai=L6.head; ai; ai=ai->ai_next) {
        int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;

        int yes = 1; ::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        int v6only = 0; ::setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));

        if (::bind(s, ai->ai_addr, ai->ai_addrlen)==0 && ::listen(s, backlog)==0) {
            std::print("[listen] {}\n", to_string(ai->ai_addr, ai->ai_addrlen));
            return s;
        }
        std::print(stderr, "[listen-fail] {}\n", strerror(errno));
        ::close(s);
    }
    // 2) IPv4 리스너(보수적 백업)
    addr_list L4 = resolve_or_throw(nullptr, port, AF_INET, SOCK_STREAM, AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV);
    for (auto* ai=L4.head; ai; ai=ai->ai_next) {
        int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;
        int yes = 1; ::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        if (::bind(s, ai->ai_addr, ai->ai_addrlen)==0 && ::listen(s, backlog)==0) {
            std::print("[listen] {}\n", to_string(ai->ai_addr, ai->ai_addrlen));
            return s;
        }
        std::print(stderr, "[listen-fail] {}\n", strerror(errno));
        ::close(s);
    }
    throw std::runtime_error("no listen socket");
}
```

#### 클라이언트: 후보 반복 + 숫자 로깅

```cpp
int create_connect(const char* host, const char* port) {
    auto L = resolve_or_throw(host, port, AF_UNSPEC, SOCK_STREAM, AI_ADDRCONFIG|AI_NUMERICSERV);
    for (auto* ai=L.head; ai; ai=ai->ai_next) {
        int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;
        std::print("[dial] {}\n", to_string(ai->ai_addr, ai->ai_addrlen));
        if (::connect(s, ai->ai_addr, ai->ai_addrlen)==0) {
            std::print("[connected] {}\n", to_string(ai->ai_addr, ai->ai_addrlen));
            return s;
        }
        std::print(stderr, "[connect-fail] {} to {}\n",
                   strerror(errno), to_string(ai->ai_addr, ai->ai_addrlen));
        ::close(s);
    }
    throw std::runtime_error("connect failed");
}
```

---

### 테스트 시나리오(실전 감각 익히기)

1) **IPv6-only 머신**에서 서버 시작 → IPv4 클라이언트 접근이 되는지 확인(`IPV6_V6ONLY` 설정 차이에 주목).
2) **링크-로컬(v6)** 바인드 + 같은 링크의 클라이언트로 접속 → **스코프 ID** 미설정 시 실패 재현.
3) **DNS 일시 실패**(네임서버 차단 등) → `EAI_AGAIN` 관찰, 재시도 정책 설계.
4) **서비스명 사용**(예: `"daytime"`) vs **숫자 포트** 비교 → 플랫폼별 서비스 데이터베이스 차이 확인.
5) `AI_NUMERICHOST`/`AI_NUMERICSERV` 강제 → 잘못된 입력 조기 실패로 **버그 조기 발견**.

---

### 체크리스트(요약)

- [ ] `getaddrinfo()`는 **여러 후보**를 준다 → **모두 시도**해서 **첫 성공**을 선택.
- [ ] **서버**: `AI_PASSIVE | AI_ADDRCONFIG` 기본, **v6-only 정책** 명시(`IPV6_V6ONLY`).
- [ ] **클라이언트**: `AI_ADDRCONFIG` 기본, 필요하면 **Happy Eyeballs**(v6/v4 순차 혹은 동시 시도).
- [ ] **로깅**: `getnameinfo(..., NI_NUMERICHOST|NI_NUMERICSERV)` 로 **숫자 IP:PORT**.
- [ ] **링크-로컬(IPv6)** 은 **스코프 ID** 필수.
- [ ] 서비스명 대신 **숫자 포트**로 **불확실성 제거**(또는 `AI_NUMERICSERV`).
- [ ] `freeaddrinfo()` 까먹지 않기(RAII 래퍼 권장).
