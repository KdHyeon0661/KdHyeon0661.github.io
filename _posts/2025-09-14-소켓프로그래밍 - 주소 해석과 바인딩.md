---
layout: post
title: 소켓프로그래밍 - 주소 해석과 바인딩
date: 2025-09-14 16:25:23 +0900
category: 소켓프로그래밍
---
# 주소 해석과 바인딩의 모든 것 — `getaddrinfo()` / `getnameinfo()`와 IPv4/IPv6

## 1. 문제 정의와 전체 그림

### 1.1 왜 `getaddrinfo()`인가?

예전에는

- `gethostbyname()` (호스트명 → IPv4 주소 1개),
- `getservbyname()` (서비스명 → 포트 번호),

같은 함수들을 따로 호출하고, IPv4 전용 `sockaddr_in`에 직접 채워 넣는 식으로 코드를 짰다. 이 방식은

- IPv6를 지원하기 어렵고,
- 스레드 세이프하지 않은 구현이 많고,
- 다양한 주소 패밀리(AF_INET, AF_INET6, AF_UNIX, AF_NETLINK …)에 대해 일관된 인터페이스를 제공하지 못한다.

그래서 POSIX와 주요 OS들은 **주소/서비스 해석의 새로운 기본 API**로 **`getaddrinfo()`**를 채택했다.

핵심 역할:

- **입력**
  - `host`: 호스트 이름 / 도메인 이름 (`"example.com"`), IP 리터럴 (`"127.0.0.1"`, `"::1"`), 또는 `nullptr`
  - `service`: 서비스 이름 (`"http"`, `"ssh"`) 또는 문자형 포트 (`"80"`, `"443"`)
  - `hints`: 원하는 **주소 패밀리(AF_*)**, **소켓 타입(SOCK_*)**, **플래그(AI_*)** 로 의도를 전달
- **출력**
  - `addrinfo` 구조체의 **연결 리스트** (IPv6 / IPv4 후보들 포함)
  - 각 원소는 `ai_family`, `ai_socktype`, `ai_protocol`, `sockaddr*`(구체적 주소) 정보를 가진다.
- 응용은 이 리스트를 **위에서부터 차례로**:
  - `socket()` → `bind()` 또는 `connect()`를 시도
  - **성공한 첫 번째 후보**를 채택하고 나머지는 버린다.

> 실무 규칙: **“`getaddrinfo()`는 항상 ‘여러 후보’를 준다”** 라고 생각하자.  
> 단일 주소라고 믿고 첫 원소만 쓰면, IPv6/IPv4, 멀티홈, DNS 구성에 따라 미묘한 버그가 생긴다.

### 1.2 서버 vs 클라이언트에서의 해석 차이

- **서버 쪽(바인딩)**:
  - 보통 `host = nullptr`, `service = "9000"` + `AI_PASSIVE` 플래그를 사용.
  - 그러면 커널이 알아서 **와일드카드(any) 주소** (`::`, `0.0.0.0`)에 바인드 가능한 후보들을 만들어 준다.
- **클라이언트 쪽(연결)**:
  - `host = "example.com"` 또는 `"203.0.113.10"` 같은 구체적 이름/주소.
  - `AI_PASSIVE` 없이, `AF_UNSPEC` + `AI_ADDRCONFIG` 정도만 주는 것이 일반적이다.

---

## 2. 이름/서비스 해석과 `getaddrinfo()`의 역할 상세

### 2.1 입력 파라미터: host / service / hints

#### `host` 인자

- `nullptr` 또는 빈 문자열 (`""`)
  - **서버 바인딩** 용으로 사용. `AI_PASSIVE`와 함께 사용하면 **와일드카드(any)** 주소 후보를 만들어 준다.
- 도메인 이름 (예: `"example.com"`)
  - DNS, `/etc/hosts` 등 시스템 설정에 따라 IP들을 조회.
  - IPv6 AAAA 레코드 + IPv4 A 레코드를 모두 찾아 후보 리스트를 만든다.
- IP 리터럴
  - `"127.0.0.1"`, `"::1"`, `"2001:db8::1"` 등.
  - 이 경우 DNS lookup 없이 바로 파싱하여 주소를 만든다.

#### `service` 인자

- 서비스명 (예: `"http"`, `"https"`, `"ssh"`)
  - 시스템의 서비스 데이터베이스(예: `/etc/services`)를 조회해 포트 번호를 얻는다.
  - 예: `"http"` → 80, `"https"` → 443.
- 숫자 문자열 (예: `"80"`, `"9000"`)
  - 바로 정수 포트로 변환.
  - **실무에선 숫자 문자열을 쓰는 편이 더 예측 가능**하다.

#### `addrinfo hints`

```cpp
struct addrinfo {
    int              ai_flags;
    int              ai_family;
    int              ai_socktype;
    int              ai_protocol;
    socklen_t        ai_addrlen;
    struct sockaddr *ai_addr;
    char            *ai_canonname;
    struct addrinfo *ai_next;
};
```

여기서 우리가 주로 세팅하는 건:

- `ai_family`
  - `AF_UNSPEC`  : IPv4/IPv6 모두 후보로 받기
  - `AF_INET`    : IPv4만
  - `AF_INET6`   : IPv6만
- `ai_socktype`
  - `SOCK_STREAM`: TCP
  - `SOCK_DGRAM` : UDP
- `ai_protocol`
  - 대부분의 경우 `0` (자동 선택).
- `ai_flags`
  - `AI_PASSIVE`, `AI_ADDRCONFIG`, `AI_NUMERICHOST`, `AI_NUMERICSERV`, `AI_V4MAPPED`, `AI_ALL`, `AI_CANONNAME` 등.

### 2.2 자주 쓰는 플래그 정리

| 플래그            | 의미 | 서버/클라 | 비고 |
|-------------------|------|-----------|------|
| `AI_PASSIVE`      | `host == nullptr` 와 함께 쓰면 와일드카드 주소 후보 생성 | 주로 서버 | `bind()`용 |
| `AI_ADDRCONFIG`   | **현재 호스트에 구성된 주소 패밀리**만 결과에 포함 | 둘 다 | IPv6 미구성 상황에서 IPv6 후보를 제거 |
| `AI_NUMERICHOST`  | host를 **무조건 숫자**로 간주 (DNS lookup 안 함) | 둘 다 | IP 리터럴만 허용하고 싶을 때 |
| `AI_NUMERICSERV`  | service를 **무조건 숫자**로 간주 | 둘 다 | 서비스명(`"http"`)을 사용하지 않을 때 |
| `AI_V4MAPPED`     | IPv6-only 요청인 경우 IPv4 주소를 v4-mapped로 돌려줄 수 있게 함 | 주로 클라 | 환경에 따라 조정 |
| `AI_ALL`          | v4-mapped와 native IPv6 모두 포함 | 주로 클라 | `AI_V4MAPPED`와 조합 가능 |
| `AI_CANONNAME`    | ai_canonname에 정규화된 호스트 이름 반환 | 주로 클라 | reverse DNS 비용에 주의 |

- **실무 기본값**
  - 서버: `AI_PASSIVE | AI_ADDRCONFIG` (+ 필요 시 `AI_NUMERICSERV`)
  - 클라이언트: `AI_ADDRCONFIG` (+ 필요 시 `AI_NUMERICSERV`)

---

## 3. `getaddrinfo()`를 C++23 스타일로 감싸기

### 3.1 RAII 래퍼와 예외 기반 헬퍼

원래 정리해 둔 패턴을 C++23 스타일로 조금 다듬어 보자.

```cpp
#include <netdb.h>
#include <string>
#include <stdexcept>
#include <print>

// RAII: freeaddrinfo 자동 호출 래퍼
struct addr_list {
    addrinfo* head{};

    addr_list() = default;
    explicit addr_list(addrinfo* p) : head(p) {}

    addr_list(const addr_list&)            = delete;
    addr_list& operator=(const addr_list&) = delete;

    addr_list(addr_list&& other) noexcept : head(other.head) {
        other.head = nullptr;
    }
    addr_list& operator=(addr_list&& other) noexcept {
        if (this != &other) {
            if (head) ::freeaddrinfo(head);
            head = other.head;
            other.head = nullptr;
        }
        return *this;
    }

    ~addr_list() {
        if (head) ::freeaddrinfo(head);
    }
};

// 예외 기반 헬퍼
addr_list resolve_or_throw(const char* host,
                           const char* service,
                           int family,
                           int socktype,
                           int flags)
{
    addrinfo hints{};
    hints.ai_family   = family;
    hints.ai_socktype = socktype;
    hints.ai_protocol = 0;
    hints.ai_flags    = flags;

    addrinfo* res = nullptr;
    int rc = ::getaddrinfo(host, service, &hints, &res);
    if (rc != 0) {
        std::string msg = ::gai_strerror(rc);
        throw std::runtime_error("getaddrinfo: " + msg);
    }
    return addr_list{res};
}
```

- 예외 기반이 싫다면, `std::expected<addr_list, std::error_code>` 같은 형태로 바꿔도 된다.
- 핵심은 `addrinfo*` 를 그냥 리턴하고 여기저기서 `freeaddrinfo()`를 잊어버리는 패턴을 없애는 것.

### 3.2 IPv4/IPv6 겸용 서버: `listen_on()`

앞에서 만든 `resolve_or_throw()`를 이용해 **dual-stack 서버 리스너**를 만들어보자.

```cpp
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cstring>

int listen_on(const char* bind_host,
              const char* port,
              int backlog = 128)
{
    int flags = AI_PASSIVE | AI_ADDRCONFIG;
    auto L = resolve_or_throw(bind_host, port,
                              AF_UNSPEC, SOCK_STREAM, flags);

    for (auto* ai = L.head; ai; ai = ai->ai_next) {
        int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) {
            continue;
        }

        int yes = 1;
        ::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

        if (::bind(s, ai->ai_addr, ai->ai_addrlen) == 0 &&
            ::listen(s, backlog) == 0) {
            return s; // 첫 성공 리스너 반환
        }

        ::close(s); // 실패 → 다음 후보로
    }
    throw std::runtime_error("listen_on: no address worked");
}
```

- `bind_host = nullptr` 이면 OS가 **와일드카드(any)** 주소 후보를 만들어 준다.
- `bind_host = "203.0.113.10"` 처럼 특정 주소를 주면, 그 주소에만 바인드.

---

## 4. IPv4/IPv6 겸용 클라이언트: `connect_to()`

### 4.1 단순 패턴: 후보 리스트를 순서대로 connect

```cpp
int connect_to(const char* host, const char* port) {
    int flags = AI_ADDRCONFIG; // 필요 시 AI_NUMERICSERV 추가
    auto L = resolve_or_throw(host, port,
                              AF_UNSPEC, SOCK_STREAM, flags);

    for (auto* ai = L.head; ai; ai = ai->ai_next) {
        int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) {
            continue;
        }
        if (::connect(s, ai->ai_addr, ai->ai_addrlen) == 0) {
            return s; // 성공
        }
        ::close(s);
    }
    throw std::runtime_error("connect_to: no address worked");
}
```

- 이 패턴만 제대로 구현해도, **IPv4/IPv6 겸용 클라이언트의 80%** 는 해결된다.
- 단, IPv6과 IPv4를 **어떤 순서로 시도할지**는 OS 정책과 DNS 응답 순서에 따라 달라질 수 있다.

### 4.2 간단한 Happy Eyeballs 스타일

RFC 6555에서 제안하는 “Happy Eyeballs” 알고리즘은 **IPv6과 IPv4를 동시에 혹은 짧은 지연을 두고 시도**해 어떤 환경에서도 연결 지연을 최소화하는 것이 목표다.

여기서는 간단하게 “IPv6 → (짧은 대기) → IPv4” 순차 시도로 구현해보자.

```cpp
#include <vector>
#include <chrono>
#include <thread>

// IPv6 먼저, 200ms 후 IPv4
int connect_happy(const char* host, const char* port,
                  std::chrono::milliseconds v4_delay = std::chrono::milliseconds(200))
{
    auto L = resolve_or_throw(host, port,
                              AF_UNSPEC, SOCK_STREAM, AI_ADDRCONFIG);

    std::vector<addrinfo*> v6_list;
    std::vector<addrinfo*> v4_list;

    for (auto* ai = L.head; ai; ai = ai->ai_next) {
        if (ai->ai_family == AF_INET6) v6_list.push_back(ai);
        else if (ai->ai_family == AF_INET) v4_list.push_back(ai);
    }

    auto try_connect_list = [](const auto& list) -> int {
        for (auto* ai : list) {
            int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
            if (s < 0) continue;
            if (::connect(s, ai->ai_addr, ai->ai_addrlen) == 0) {
                return s;
            }
            ::close(s);
        }
        return -1;
    };

    int s = try_connect_list(v6_list);
    if (s >= 0) return s;

    std::this_thread::sleep_for(v4_delay);

    s = try_connect_list(v4_list);
    if (s >= 0) return s;

    throw std::runtime_error("connect_happy: no address worked");
}
```

실무에서는 비동기 I/O와 타이머를 사용해서 **IPv6/IPv4를 거의 동시에 시도**하는 방식으로 확장할 수 있다.

---

## 5. IPv6 세부 사항: v4-mapped, `IPV6_V6ONLY`, 스코프 ID

### 5.1 v4-mapped 주소와 `IPV6_V6ONLY`

IPv6 소켓에 IPv4를 같이 수용하는 방법으로 **v4-mapped 주소**가 있다.

- 예: `::ffff:192.0.2.1`  
- IPv6 주소 공간의 마지막 부분에 IPv4 주소를 매핑한 형태.

`::`(IPv6 any)에 바인드해 놓고

- 커널이 v4-mapped를 허용하면,
  - IPv4 연결도 같은 소켓으로 받아들일 수 있다.
- 허용하지 않으면(v6-only),
  - IPv4에 대해 **별도의 IPv4 리스너**가 필요하다.

이를 제어하는 옵션이 `IPV6_V6ONLY`다.

```cpp
int s = ::socket(AF_INET6, SOCK_STREAM, 0);
if (s >= 0) {
    int v6only = 0; // 0: v4-mapped 허용, 1: IPv6 전용
    ::setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
    // 그 다음 bind("::", port), listen(...)
}
```

운영체제에 따라 기본값이 다르다.

- 리눅스: 기본적으로 `0`인 경우가 많다.
- 일부 BSD / macOS: 기본적으로 `1` (IPv6 전용).

**정책**은 다음 둘 중 하나로 명확하게 잡는 것이 좋다.

1. **v6-only 리스너 + 별도 IPv4 리스너**
   - 각각 `AF_INET6`, `AF_INET`으로 `socket()`/`bind()`/`listen()`.
2. **IPv6 리스너에서 v4-mapped 허용**
   - `IPV6_V6ONLY = 0`을 명시.
   - v4/v6를 모두 단일 소켓에서 처리.

### 5.2 링크-로컬 IPv6와 스코프 ID

링크-로컬 주소(예: `fe80::1234:abcd:...`)는 **인터페이스 범위(scope)** 를 가진다.

- 주소 문자열: `fe80::1234%eth0`
- 여기서 `%eth0` 부분이 **스코프 ID**.

`getaddrinfo()`는 이 `%eth0` 표기를 이해하고, `sockaddr_in6::sin6_scope_id`를 채워준다.

직접 `inet_pton()`을 사용하는 경우에는 **스코프 ID를 직접 설정**해야 한다.

```cpp
#include <net/if.h>

int s = ::socket(AF_INET6, SOCK_STREAM, 0);

sockaddr_in6 sa6{};
sa6.sin6_family = AF_INET6;
sa6.sin6_port   = htons(9000);

// 주소 파싱
::inet_pton(AF_INET6, "fe80::1234", &sa6.sin6_addr);

// 반드시 인터페이스 인덱스를 세팅해야 한다.
sa6.sin6_scope_id = if_nametoindex("eth0");

if (::bind(s, (sockaddr*)&sa6, sizeof(sa6)) < 0) {
    // 에러 처리
}
```

스코프 ID를 설정하지 않으면, **라우팅 불가** 또는 이상한 인터페이스로 나가는 문제들이 생긴다.

---

## 6. `getnameinfo()`로 주소를 문자열로 안전하게 변환하기

### 6.1 왜 `getnameinfo()`인가?

소켓 프로그래밍에서 **로깅/메트릭/디버깅**을 위해

- `sockaddr` → `"IP:PORT"` 문자열로 변환하는 경우가 많다.

이때:

- IPv4/IPv6를 모두 커버하고,
- reverse DNS lookup으로 인한 지연을 피하려면,

**`getnameinfo()`**를 사용하고 적절한 플래그를 줘야 한다.

### 6.2 숫자 전용 플래그: `NI_NUMERICHOST`, `NI_NUMERICSERV`

- `NI_NUMERICHOST`
  - reverse DNS lookup을 하지 않고, **무조건 숫자 주소**로 반환.
- `NI_NUMERICSERV`
  - 서비스명(`"http"`) 대신 **숫자 포트**로 반환.

로그/메트릭용 함수 예:

```cpp
#include <netdb.h>
#include <string>

std::string to_string(const sockaddr* sa, socklen_t salen) {
    char host[NI_MAXHOST]{};
    char serv[NI_MAXSERV]{};

    int rc = ::getnameinfo(sa, salen,
                           host, sizeof(host),
                           serv, sizeof(serv),
                           NI_NUMERICHOST | NI_NUMERICSERV);
    if (rc == 0) {
        return std::string(host) + ":" + std::string(serv);
    }
    return "(unknown)";
}
```

사용 예:

```cpp
sockaddr_storage cli{};
socklen_t clen = sizeof(cli);
int cfd = ::accept(lfd, (sockaddr*)&cli, &clen);
if (cfd >= 0) {
    std::print("[accept] peer={}\n",
               to_string((sockaddr*)&cli, clen));
}
```

이렇게 하면

- IPv4: `"203.0.113.10:52341"`
- IPv6: `"[2001:db8::1]:52341"` 같은 형태를 (조금 더 가공해서) 손쉽게 얻을 수 있다.

(대괄호 포맷은 직접 구현할 수 있다. 예를 들어 IPv6인 경우 `"[" + host + "]:" + serv`.)

---

## 7. 서비스명/포트와 `AI_NUMERICSERV`

### 7.1 서비스명 vs 숫자 포트

`getaddrinfo()`는 `service` 인자로 **서비스명** 또는 **포트 문자열**을 받는다.

- `"http"` → 80
- `"https"` → 443
- `"ssh"` → 22

하지만, 해당 서비스명이 시스템에 등록되어 있지 않으면 실패한다.

실무에서는

- **명확한 포트 번호**를 사용할 때는 `"9000"` 같이 숫자 문자열을 쓰는 것이 가장 안전하다.
- 혹은 `AI_NUMERICSERV` 를 플래그에 넣어 “포트만 허용”하게 만들 수도 있다.

### 7.2 `AI_NUMERICSERV` 사용 예

```cpp
auto L = resolve_or_throw(nullptr, "9000",
                          AF_UNSPEC, SOCK_STREAM,
                          AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV);
```

- 여기서 `"9000"`은 포트 번호로 직접 해석되고, `"http"` 같은 문자열을 쓰면 **실패**한다.
- 즉, 서비스명을 잘못 쓰는 실수를 **초기에 드러나게** 할 수 있다.

---

## 8. 숫자 리터럴만 허용하고 싶을 때: `AI_NUMERICHOST`

내부 도구나 실험 코드에서는 **DNS를 전혀 사용하지 않고**, IP 리터럴만 받게 하고 싶은 경우가 많다.

이 때 `AI_NUMERICHOST`를 쓰면 된다.

```cpp
auto L = resolve_or_throw("127.0.0.1", "9000",
                          AF_UNSPEC, SOCK_STREAM,
                          AI_ADDRCONFIG | AI_NUMERICHOST | AI_NUMERICSERV);
```

- `host`가 IP 리터럴이 아니면 (`"example.com"` 같은 DNS 이름) 즉시 에러가 난다.
- 테스트 환경에서 잘못된 입력을 조기에 잡는 데 유용하다.

---

## 9. `addrinfo` 리스트 순회와 에러 로깅 패턴

### 9.1 “모든 후보 시도” 패턴

`getaddrinfo()`가 돌려준 리스트는 대략 이런 구조다.

```text
[head] → [ai #0] → [ai #1] → [ai #2] → ... → nullptr
```

각 `ai`는

- 보통 서로 다른 `ai_family`(IPv4/IPv6) 또는 다른 주소/포트 조합.

반드시:

1. 루프를 돌면서 `socket()`/`bind()` 또는 `socket()`/`connect()` 시도
2. **성공하면 즉시 사용**, 실패하면 **로그와 함께 다음 후보로**

해야 한다.

### 9.2 에러 로깅 예제

```cpp
#include <cerrno>
#include <cstring>

int connect_with_log(const char* host, const char* port) {
    auto L = resolve_or_throw(host, port,
                              AF_UNSPEC, SOCK_STREAM,
                              AI_ADDRCONFIG | AI_NUMERICSERV);

    for (auto* ai = L.head; ai; ai = ai->ai_next) {
        int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) {
            std::print(stderr, "[socket-fail] family={} err={}\n",
                       ai->ai_family, std::strerror(errno));
            continue;
        }

        std::string addr_str = to_string(ai->ai_addr, ai->ai_addrlen);
        if (::connect(s, ai->ai_addr, ai->ai_addrlen) == 0) {
            std::print("[connect-ok] {}\n", addr_str);
            return s;
        }
        std::print(stderr, "[connect-fail] {} err={}\n",
                   addr_str, std::strerror(errno));
        ::close(s);
    }

    throw std::runtime_error("connect_with_log: all candidates failed");
}
```

이 패턴을 써두면, 현장에서

- 어느 주소 후보가 실패했는지,
- 실패 사유가 무엇인지(errno),
- 결국 어떤 주소로 연결됐는지,

를 로그만으로 추적할 수 있다.

---

## 10. `gai_strerror()`와 `EAI_*` 에러 코드

`getaddrinfo()`는 `errno` 대신 **자신만의 에러 코드 집합(EAI_*)**을 반환한다.

대표적인 코드:

- `EAI_AGAIN`
  - DNS 쿼리 일시 실패 (재시도 가능).
- `EAI_NONAME`
  - 이름을 찾을 수 없음 (호스트 없음, 서비스 없음).
- `EAI_FAMILY`
  - 요청한 주소 패밀리 지원 안 함.
- `EAI_SOCKTYPE`
  - 요청한 소켓 타입 지원 안 함.
- `EAI_SERVICE`
  - 서비스 사용 불가.
- `EAI_FAIL`
  - 비복구 에러.

숫자 코드를 문자열로 바꾸는 함수가 `gai_strerror(int)`.

```cpp
int rc = ::getaddrinfo(host, service, &hints, &res);
if (rc != 0) {
    std::string msg = ::gai_strerror(rc);
    throw std::runtime_error("getaddrinfo: " + msg);
}
```

`errno`를 읽어봐야 소용 없다. 이 경우에는 **반드시 반환값(rc)** 를 확인해야 한다.

---

## 11. `sockaddr_storage`와 안전한 캐스팅

### 11.1 왜 `sockaddr_storage`인가?

- `sockaddr_in`(IPv4)와 `sockaddr_in6`(IPv6)는 크기가 다르다.
- `accept()`, `recvfrom()` 등은 “가장 큰 주소를 담을 수 있는 버퍼”를 요구한다.

이를 위해 나온 것이 **`sockaddr_storage`** 이다.

```cpp
sockaddr_storage ss{};
socklen_t slen = sizeof(ss);

int cfd = ::accept(lfd, (sockaddr*)&ss, &slen);
if (cfd < 0) { /* 에러 처리 */ }

// 실제 타입 확인
if (ss.ss_family == AF_INET) {
    auto* v4 = (sockaddr_in*)&ss;
    // v4->sin_addr, v4->sin_port 사용
} else if (ss.ss_family == AF_INET6) {
    auto* v6 = (sockaddr_in6*)&ss;
    // v6->sin6_addr, v6->sin6_port, v6->sin6_scope_id 사용
}
```

- `ss.ss_family`를 확인한 후, 적절한 타입으로 캐스팅해야 한다.
- 포인터를 그대로 `sockaddr_in*` 으로 가정하고 접근하면 잘못된 메모리를 읽게 된다.

---

## 12. `inet_pton/inet_ntop`와 `getaddrinfo/getnameinfo`의 관계

### 12.1 IP 리터럴 전용 vs 다양한 환경 대응

- `inet_pton()` / `inet_ntop()`는 **숫자 리터럴 ↔ `in_addr`/`in6_addr`** 변환에 특화되어 있다.
- `getaddrinfo()` / `getnameinfo()`는
  - DNS, `/etc/hosts`, 서비스 데이터베이스 등 **시스템 전체 이름 해석 규칙**을 따르고,
  - IPv4/IPv6 모두를 포괄하며,
  - **하나의 API로 서버/클라이언트 양쪽을 처리**할 수 있게 해준다.

직접 `inet_pton()`을 사용하는 경우는 주로

- IP 리터럴을 받은 것을 **곧바로 주소 구조체에 넣어야 할 때**,
- 매우 성능 민감한 경로에서 **DNS를 일절 쓰지 않고** 리터럴만 처리할 때.

그 외 대부분 케이스에서는 `getaddrinfo()`를 쓰는 것이 더 자연스럽다.

---

## 13. UDP 서버/클라이언트에서의 `getaddrinfo()`

지금까지는 TCP 위주로 봤지만, UDP에서도 패턴은 거의 동일하다.

### 13.1 UDP 서버 바인딩

```cpp
int udp_bind(const char* bind_host, const char* port) {
    int flags = AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV;
    auto L = resolve_or_throw(bind_host, port,
                              AF_UNSPEC, SOCK_DGRAM, flags);

    for (auto* ai = L.head; ai; ai = ai->ai_next) {
        int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;

        int yes = 1;
        ::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

        if (::bind(s, ai->ai_addr, ai->ai_addrlen) == 0) {
            return s;
        }
        ::close(s);
    }
    throw std::runtime_error("udp_bind: no address worked");
}
```

### 13.2 UDP 클라이언트 대상 주소

UDP에서는 `connect()`를 쓰지 않고 매번 `sendto()`에 주소를 넘겨도 된다. 이때도 `getaddrinfo()`로 한 번 해석해 둔다.

```cpp
struct udp_target {
    int          family;
    socklen_t    addrlen;
    sockaddr_storage addr;
};

udp_target resolve_udp_target(const char* host, const char* port) {
    auto L = resolve_or_throw(host, port,
                              AF_UNSPEC, SOCK_DGRAM,
                              AI_ADDRCONFIG | AI_NUMERICSERV);

    for (auto* ai = L.head; ai; ai = ai->ai_next) {
        udp_target t{};
        t.family = ai->ai_family;
        t.addrlen = ai->ai_addrlen;
        std::memcpy(&t.addr, ai->ai_addr, ai->ai_addrlen);
        return t; // 첫 후보 사용
    }
    throw std::runtime_error("resolve_udp_target: no address");
}
```

이렇게 얻은 `udp_target`을 `sendto()` 호출에 재사용하면 된다.

---

## 14. 테스트 시나리오 설계 (현장에서 직접 검증)

### 14.1 IPv6-only vs Dual-stack 환경

1. **IPv6 only** 인터페이스 설정
   - 호스트에 IPv6 주소만 할당하고, IPv4 주소는 제거.
2. 서버에서 `create_listen_dual("9000")` 같은 함수를 실행.
3. 클라이언트에서 IPv4/IPv6 각각으로 접속 시도.
   - OS마다 `IPV6_V6ONLY` 기본값 차이 확인.
4. 로그를 통해 실제 어떤 주소로 리스닝/접속했는지 확인.

### 14.2 링크-로컬 IPv6 + 스코프 ID

1. 동일 링크 상의 두 호스트에 링크-로컬 주소 할당 (`fe80::...`).
2. `getaddrinfo("fe80::1234%eth0", "9000", ...)` 으로 주소 해석.
3. 스코프 ID를 설정하지 않고 수동 `inet_pton()`만 사용한 코드와 비교.
   - 실패/오동작이 어떻게 드러나는지 확인.

### 14.3 DNS 일시 장애

1. 테스트 환경에서 DNS 서버 응답을 의도적으로 늦추거나 실패시키고,
2. `getaddrinfo("example.com", ...)` 호출을 반복.
3. `EAI_AGAIN`, `EAI_NONAME` 등의 에러를 관찰하고,
4. 재시도 정책(backoff)을 어떻게 설계할지 고민해볼 수 있다.

---

## 15. 종합 예제: “완성도 있는” 서버/클라이언트 스켈레톤

### 15.1 서버: dual-stack 리스너 + 로깅

```cpp
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <print>
#include <system_error>
#include <cstring>

// 앞에서 정의한 addr_list, resolve_or_throw, to_string 재사용

int create_listen_dual(const char* port, int backlog = 256) {
    // 1) IPv6 리스너 (v4-mapped 허용 여부를 정책적으로 결정)
    {
        auto L6 = resolve_or_throw(nullptr, port,
                                   AF_INET6, SOCK_STREAM,
                                   AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV);
        for (auto* ai = L6.head; ai; ai = ai->ai_next) {
            int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
            if (s < 0) continue;

            int yes = 1;
            ::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

            int v6only = 0; // 0이면 v4-mapped 허용
            ::setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));

            if (::bind(s, ai->ai_addr, ai->ai_addrlen) == 0 &&
                ::listen(s, backlog) == 0) {
                std::print("[listen] {}\n",
                           to_string(ai->ai_addr, ai->ai_addrlen));
                return s;
            }

            std::print(stderr, "[listen-fail] {} err={}\n",
                       to_string(ai->ai_addr, ai->ai_addrlen),
                       std::strerror(errno));
            ::close(s);
        }
    }

    // 2) IPv4 리스너 (보수적 백업)
    {
        auto L4 = resolve_or_throw(nullptr, port,
                                   AF_INET, SOCK_STREAM,
                                   AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV);
        for (auto* ai = L4.head; ai; ai = ai->ai_next) {
            int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
            if (s < 0) continue;

            int yes = 1;
            ::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

            if (::bind(s, ai->ai_addr, ai->ai_addrlen) == 0 &&
                ::listen(s, backlog) == 0) {
                std::print("[listen] {}\n",
                           to_string(ai->ai_addr, ai->ai_addrlen));
                return s;
            }

            std::print(stderr, "[listen-fail] {} err={}\n",
                       to_string(ai->ai_addr, ai->ai_addrlen),
                       std::strerror(errno));
            ::close(s);
        }
    }

    throw std::runtime_error("create_listen_dual: no listen socket");
}

int main() {
    int lfd = create_listen_dual("9000", 256);

    for (;;) {
        sockaddr_storage ss{};
        socklen_t slen = sizeof(ss);
        int cfd = ::accept(lfd, (sockaddr*)&ss, &slen);
        if (cfd < 0) {
            if (errno == EINTR) continue;
            std::print(stderr, "[accept-fail] err={}\n", std::strerror(errno));
            continue;
        }
        std::string peer = to_string((sockaddr*)&ss, slen);
        std::print("[accept] peer={}\n", peer);

        // 간단 에코
        char buf[4096];
        for (;;) {
            ssize_t n = ::recv(cfd, buf, sizeof(buf), 0);
            if (n > 0) {
                ::send(cfd, buf, n, 0);
            } else if (n == 0) {
                break;
            } else if (errno == EINTR) {
                continue;
            } else {
                std::print(stderr, "[recv-fail] peer={} err={}\n",
                           peer, std::strerror(errno));
                break;
            }
        }
        ::close(cfd);
    }
}
```

### 15.2 클라이언트: 후보 반복 + 숫자 로깅

```cpp
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <print>
#include <string>
#include <cstring>

// addr_list, resolve_or_throw, to_string 사용

int create_connect(const char* host, const char* port) {
    auto L = resolve_or_throw(host, port,
                              AF_UNSPEC, SOCK_STREAM,
                              AI_ADDRCONFIG | AI_NUMERICSERV);

    for (auto* ai = L.head; ai; ai = ai->ai_next) {
        int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) {
            std::print(stderr, "[socket-fail] family={} err={}\n",
                       ai->ai_family, std::strerror(errno));
            continue;
        }

        std::string target = to_string(ai->ai_addr, ai->ai_addrlen);
        std::print("[dial] {}\n", target);

        if (::connect(s, ai->ai_addr, ai->ai_addrlen) == 0) {
            std::print("[connected] {}\n", target);
            return s;
        }

        std::print(stderr, "[connect-fail] {} err={}\n",
                   target, std::strerror(errno));
        ::close(s);
    }
    throw std::runtime_error("create_connect: no address worked");
}

int main(int argc, char** argv) {
    if (argc < 3) {
        std::print(stderr, "usage: {} <host> <port>\n", argv[0]);
        return 1;
    }

    const char* host = argv[1];
    const char* port = argv[2];

    int s = create_connect(host, port);

    const char msg[] = "hello\n";
    ::send(s, msg, sizeof(msg)-1, 0);

    char buf[4096];
    ssize_t n = ::recv(s, buf, sizeof(buf)-1, 0);
    if (n > 0) {
        buf[n] = '\0';
        std::print("[recv] {}\n", buf);
    }

    ::close(s);
    return 0;
}
```

이 두 프로그램을 동시에 써보면,

- `getaddrinfo()` / `getnameinfo()` 기반의 주소 해석/바인딩/로깅 패턴이 실제로 어떤 식으로 동작하는지,
- IPv4/IPv6 환경에서 어떤 주소로 리스닝/접속하는지,

를 쉽게 눈으로 확인할 수 있다.

---

## 16. 정리: 주소 해석·바인딩 설계 체크리스트

마지막으로, 지금까지 내용을 압축한 **실전 체크리스트**를 정리해 보자.

1. **이름 해석**
   - [ ] 오래된 `gethostbyname()` 대신 **`getaddrinfo()`**를 기본으로 쓴다.
   - [ ] `AF_UNSPEC` + `AI_ADDRCONFIG` 로 IPv4/IPv6 후보를 동시에 받는다.
   - [ ] `AI_NUMERICHOST` / `AI_NUMERICSERV`는 “숫자만 허용” 정책이 필요할 때 사용.

2. **서버 바인딩**
   - [ ] `host = nullptr` + `AI_PASSIVE` 로 와일드카드 바인딩 후보 생성.
   - [ ] dual-stack 정책을 **명시적으로** 정한다: `IPV6_V6ONLY` 를 직접 설정하거나, IPv4/IPv6 리스너를 분리.
   - [ ] `SO_REUSEADDR` (필요 시 `SO_REUSEPORT`) 설정으로 재기동 편의 확보.

3. **클라이언트 연결**
   - [ ] 후보 리스트 전체를 순회하며 `socket()`/`connect()` → **첫 성공을 사용**.
   - [ ] IPv6/IPv4 중 어느 쪽을 먼저 시도할지, Happy Eyeballs 전략을 포함해 정책적으로 결정.
   - [ ] 실패한 후보는 **주소 문자열 + errno** 를 함께 로그로 남긴다.

4. **주소 문자열화**
   - [ ] 로그/메트릭용으로 **`getnameinfo()` + `NI_NUMERICHOST | NI_NUMERICSERV`** 를 사용.
   - [ ] IPv6 주소 문자열은 대괄호 포맷(`"[addr]:port"`)을 고려한다.

5. **IPv6 특이점**
   - [ ] 링크-로컬 주소(`fe80::/10`)에는 **스코프 ID** (`sin6_scope_id`)를 반드시 설정.
   - [ ] IPv4-mapped(`::ffff:a.b.c.d`) 정책을 명확히 하고, `IPV6_V6ONLY`를 직접 세팅.

6. **에러 처리**
   - [ ] `getaddrinfo()`의 반환값(EAI_*)은 **`gai_strerror()`**로 문자열을 만들고, 예외/로그에 포함.
   - [ ] `errno` 대신 반환값을 항상 먼저 본다.
   - [ ] `freeaddrinfo()`를 까먹지 않도록 RAII 래퍼(`addr_list`)를 사용.

7. **테스트**
   - [ ] IPv4-only / IPv6-only / dual-stack 환경에서 동일 코드가 올바르게 동작하는지 확인.
   - [ ] DNS 장애 / 링크-로컬 / 스코프 ID 누락 / 포트 충돌 등 **에러 케이스를 일부러 만들어 보는** 테스트를 준비.

이 체크리스트를 따라가면서 코드와 실험을 반복하면,  
“주소 해석과 바인딩”이라는 테마가 단순 API 암기가 아니라, **일관된 설계 패턴**으로 머릿속에 자리 잡게 된다.
