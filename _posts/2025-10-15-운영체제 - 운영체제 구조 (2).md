---
layout: post
title: 운영체제 - 운영체제 구조 (2)
date: 2025-10-15 18:25:23 +0900
category: 운영체제
---
# System Services • Linkers & Loaders • OS-Specific Apps • OS Design & Implementation

본 장은 **애플리케이션이 실제로 의존하는 시스템 서비스들**, **링커/로더의 내부 동작**, **왜 앱이 운영체제별로 달라지는지**, 그리고 **운영체제의 설계/구현 원칙**을 다룬다. 각 절마다 **직접 실행 가능한 예제 코드/명령**을 포함해, 개념→관측→해석의 흐름으로 설명한다.

---

## 2.4 System Services

운영체제는 커널의 시스템콜만 제공하지 않는다. **데몬/서비스**(유닉스: `daemon`, 윈도우: *Service*)가 사용자/앱과 커널 사이에 서서 **고수준 기능**을 제공한다.

**대표 서비스 계층**
- **프로세스/작업 제어**: `systemd`, `launchd`, Windows Service Control Manager(SCM)
- **이름/설정**: `systemd-resolved`, `nscd`, Windows Registry
- **시간/동기화**: `systemd-timesyncd`, `chronyd`, Windows Time Service
- **로깅/옵저버빌리티**: `journald`, `syslog`, ETW(Windows), eBPF/BPFTRACE
- **스토리지/볼륨**: `udevd`, `LVMd`, `zfsd`
- **네트워크**: `NetworkManager`, `wpa_supplicant`, `firewalld`
- **보안**: `sshd`, `polkit`, `winlogon`, LSM/SELinux/AppArmor 정책 로더

### 2.4.1 서비스의 생애주기(systemd 기준)

1) **설치**: 바이너리/유닛 파일 배치  
2) **의존성 해석**: `After=`, `Requires=`  
3) **활성화/소켓 활성화**: 필요 시 소켓이 먼저 listen, 최초 연결 시 프로세스 기동  
4) **모니터링/재시작**: `Restart=on-failure`, watchdog, cgroup 자원 계측

#### [예제] systemd 유닛 + 소켓 활성화로 “echo 서비스” 띄우기

```ini
# /etc/systemd/system/echo.socket
[Unit]
Description=Echo socket (activation)

[Socket]
ListenStream=9999

[Install]
WantedBy=sockets.target
```

```ini
# /etc/systemd/system/echo@.service  (인스턴스 서비스)
[Unit]
Description=Echo service (instance)

[Service]
ExecStart=/usr/local/bin/echo_srv
StandardInput=socket
NonBlocking=true
```

```c
// /usr/local/bin/echo_srv  — systemd socket-activation 에코 (stdin=accepted socket)
#include <unistd.h>
#include <string.h>
int main(){
    char buf[4096];
    for(;;){
        ssize_t r = read(0, buf, sizeof(buf));
        if(r<=0) break;
        write(1, buf, r);
    }
    return 0;
}
```

```bash
sudo systemctl enable --now echo.socket
# 연결이 들어오면 systemd가 echo@.service를 자동 기동
printf "hi\n" | nc 127.0.0.1 9999
sudo systemctl status echo@*
```

**관찰 포인트**: 프로세스는 연결 시에만 기동되어 **유휴 자원 절감**. 실패 시 자동 재시작.

### 2.4.2 윈도우 서비스의 핵심 흐름(요약)

- SCM이 **ServiceMain**을 호출 → **상태 보고**(`SetServiceStatus`) → **제어 핸들러**(start/stop/pause)  
- 세션/데스크톱과 분리(특권, 로그온 계정, 종속성, 복구 옵션)

> 실습은 관리자/Visual Studio 설정이 필요하므로 여기서는 구조 개요만 제시.

### 2.4.3 구성/비밀/권한 서비스

- **리눅스**: `polkit`(권한 상승 대화), `sudo` 정책, `dbus` IPC  
- **윈도우**: UAC, LSA/SSPI, Credential Manager, DPAPI  
- **비밀 저장소**: GNOME Keyring, KWallet, Windows Vault

---

## 2.5 Linkers and Loaders

**링커(Linker)**는 여러 오브젝트/라이브러리를 결합해 실행파일/공유라이브러리를 만든다.  
**로더(Loader)**는 실행 시 **메모리 적재, 재배치(Relocation), 심볼 결합(Symbol resolution)**, 초기화 루틴 호출을 담당한다.

### 2.5.1 정적 링크 vs 동적 링크

- **정적 링크**: 모든 필요한 코드가 실행파일에 포함(크기↑, 배포 단순, 공유 불가)
- **동적 링크**: 실행 시 **공유 라이브러리(.so/.dll)** 연결(메모리 공유, 보안패치 용이, 시작 오버헤드)

#### [예제] ELF 오브젝트를 단계별 관찰

```c
// hello.c
#include <stdio.h>
extern int add(int,int);
int main(){ printf("sum=%d\n", add(2,3)); return 0; }
```

```c
// add.c
int add(int a,int b){ return a+b; }
```

```bash
# 1) 오브젝트 생성
gcc -c -fPIC hello.c -o hello.o
gcc -c -fPIC add.c   -o add.o

# 2) 공유 라이브러리 만들기
gcc -shared add.o -o libmadd.so

# 3) 동적 링크 실행파일 (런타임에 libmadd.so 필요)
gcc hello.o -L. -lmadd -o hello_dyn
LD_LIBRARY_PATH=. ./hello_dyn

# 4) 정적 링크(실습 환경에 정적 libc 필요할 수 있음)
ar rcs libmadd.a add.o
gcc hello.o ./libmadd.a -static -o hello_static  # 실패할 수 있음(정적 libc 미설치 시)
```

**관찰 포인트**: `ldd ./hello_dyn`으로 **런타임 의존성** 확인, `readelf -hSWs ./hello_dyn`으로 **ELF 헤더/섹션/심볼** 확인.

### 2.5.2 재배치(Relocations), GOT/PLT, PIE

- **GOT(Global Offset Table)**: 런타임에 결정되는 주소를 테이블로 간접 참조  
- **PLT(Procedure Linkage Table)**: 지연 결합(Lazy binding) 시 첫 호출에 해석기 진입  
- **PIE(Position-Independent Executable)**: 주소 무작위화(ASLR)를 위해 실행파일도 **위치 독립**으로 빌드

#### [예제] PLT/GOT 흔적 보기

```bash
objdump -d ./hello_dyn | sed -n '1,200p' | grep -A3 "<add@plt>"
readelf -r ./hello_dyn | grep -E "JUMP_SLOT|GLOB_DAT"
```

### 2.5.3 동적 로딩(dlopen)과 플러그인

```c
// dyn_open.c — 런타임에 심볼 로드
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
int main(){
    void* h = dlopen("./libmadd.so", RTLD_NOW);
    int (*add)(int,int) = dlsym(h, "add");
    printf("2+7=%d\n", add(2,7));
    dlclose(h);
}
```

```bash
gcc dyn_open.c -ldl -o dyn_open && LD_LIBRARY_PATH=. ./dyn_open
```

### 2.5.4 윈도우의 DLL/임포트 테이블(요약)

- **IAT(Import Address Table)**: 프로세스 시작 시 로더가 **DLL**의 실제 주소로 패치  
- **Delay-Load**: 최초 호출 시 로드  
- **Side-by-Side** 어셈블리/매니페스트로 **DLL Hell** 완화

---

## 2.6 Why Applications Are Operating-System Specific

앱이 OS별로 달라지는 이유는 **ABI(Application Binary Interface)**와 **환경 서비스**가 다르기 때문이다.

**원인 요약**
- **시스템콜 ABI**: 호출 규약, 번호, 의미(리눅스 vs BSD vs 윈도우 NT)
- **바이너리 포맷**: ELF vs PE/COFF, Mach-O  
- **링커/로더/로딩 규칙**: GOT/PLT vs IAT, rpath/LD_LIBRARY_PATH vs PATH/SxS  
- **디바이스/드라이버 모델**: `/dev/*` vs WDM/WDF  
- **GUI/입력/윈도우 시스템**: X11/Wayland vs Win32/GDI/DirectX vs Cocoa  
- **보안 모델**: LSM/SELinux/AppArmor vs Integrity Levels/UAC/Token  
- **패키징**: `deb/rpm` vs MSI/Winget vs DMG/Homebrew

### 2.6.1 포팅 전략

- **표준 API 사용**: POSIX subset, C/C++ 표준 라이브러리  
- **추상화 레이어**: 파일/소켓/스레드/타이머 공용 인터페이스  
- **빌드 시스템**: CMake/meson로 플랫폼 분기  
- **런타임 로딩**: `dlopen`/`LoadLibrary`로 선택 기능 로딩  
- **컨테이너/WSL**: 리눅스 유틸을 윈도우에서 실행(단, 커널/드라이버 기능은 제한)

#### [예제] 간단한 플랫폼 추상화 레이어

```c
// os_time.h
#pragma once
#ifdef _WIN32
#include <windows.h>
static inline long os_millis(){
    return GetTickCount64() % 0x7fffffff;
}
#else
#include <time.h>
static inline long os_millis(){
    struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
    return (long)(t.tv_sec*1000 + t.tv_nsec/1000000);
}
#endif
```

---

## 2.7 Operating-System Design and Implementation

운영체제는 **목표(Goals) → 메커니즘/정책 분리 → 구현(구조/언어/도구)** 의 과정으로 발전한다.

### 2.7.1 Design Goals

1) **정확성 & 안정성**: 크래시/데이터 손상 방지, 복구 용이성  
2) **보안 & 격리**: 최소 권한, 정책 집행, 감사  
3) **성능 & 효율**: 지연/처리량/CPU·메모리 사용량 최적화  
4) **확장성 & 균형**: SMP/NUMA/멀티큐, 낮은 락 경합  
5) **관측 가능성**: 트레이싱, 카운터, 로그  
6) **휴대성**: 아키텍처/HW 다양성, 드라이버 모델  
7) **유지보수성**: 모듈성, 테스트/검증 가능성, 업그레이드 용이

#### 성능-정확성 트레이드오프 직관

성능 목표를 $$P$$, 정확성/안전 목표를 $$S$$, 가중치 $$\alpha,\beta$$라 두면, 설계의 단순 모델:
$$
\text{Utility} = \alpha \cdot P - \beta \cdot \text{Risk}
$$
여기서 `Risk`는 **복잡도/코드량/공유상태/락경합**에 비례. **단순성**은 곧 보안/안정성.

### 2.7.2 Mechanisms and Policies

- **메커니즘**: “무엇을 할 수 있게 하는가?” — 예: **스케줄링 훅**, 페이지 교체 훅, I/O 우선순위 필드
- **정책**: “어떻게 결정하는가?” — 예: CFS vs RT, LRU vs CLOCK vs 2Q, I/O 스케줄러 선택

**좋은 설계**는 **정책을 런타임에서 교체** 가능하게 한다.

#### [예제] 동일 메커니즘 + 다른 정책 (유저 공간 스케줄러 모형)

```python
# sched_policy.py — 라운드로빈 vs 우선순위 정책 (시뮬)
from collections import deque
tasks = [{"name":"A","cost":5,"prio":1},
         {"name":"B","cost":4,"prio":5},
         {"name":"C","cost":6,"prio":3}]

def rr(ts, q=1):
    q = deque((t["name"], t["cost"]) for t in ts)
    t=0; order=[]
    while q:
        n,c = q.popleft()
        run = min(1,c)  # 타임슬라이스=1
        c -= run; t += run; order += [n]
        if c>0: q.append((n,c))
    return order,t

def by_prio(ts):
    # 높은 prio 먼저
    ts = sorted(ts, key=lambda x:-x["prio"])
    t=0; order=[]
    for tsk in ts:
        order += [tsk["name"]]*tsk["cost"]; t += tsk["cost"]
    return order,t

print("RR:", rr(tasks)[0][:20])
print("PRIO:", by_prio(tasks)[0][:20])
```

**관찰**: 같은 “실행·중지” 메커니즘으로도 **정책**(라운드로빈/우선순위)에 따라 응답성/완료순서가 크게 달라진다.

### 2.7.3 Implementation

#### 2.7.3.1 구조(아키텍처)

- **모놀리식 커널**: 성능/일관성↑. 단점: 커널 크기/신뢰 경계 확대  
- **마이크로커널**: IPC 기반으로 서버(파일시스템/드라이버) 분리. 격리/신뢰경계↑, IPC 오버헤드  
- **하이브리드**: NT, XNU(마하+BSD+IOKit) 등  
- **레이어드/모듈러**: 서브시스템 분리, 동적 모듈 로딩

#### 2.7.3.2 포터빌리티/HAL

- **아키텍처 추상화 계층**: 인터럽트/페이지 테이블/캐시/TLB 조작을 아키텍처별로 캡슐화  
- **장치 드라이버 프레임워크**: 버스(PCI/USB), 전원관리(PM), DMA-API, IOMMU

#### 2.7.3.3 언어/도구/검증

- **언어**: C(대부분), 일부 Rust(드라이버/메모리 안전성), 어셈블러(부트/문맥 전환)  
- **정적 분석/포맷**: sparse, clang-tidy, smatch  
- **테스트**: KUnit, syzkaller(퍼저), kselftest  
- **관측**: ftrace/perf/eBPF/BTF

#### 2.7.3.4 드라이버 미니 스켈레톤(가상 문자장치, 개념)

> 실제 커널 모듈 코드는 환경/버전 의존이 크다. 여기서는 **바깥에서 바라본 인터페이스**를 이해하는 수준의 유저 공간 의사 예시를 든다.

```c
// pseudo_char.c — 유저 공간에서 장치 파일처럼 동작하는 파이프 기반 모형
// (mkfifo로 /tmp/char0 생성 후 open/read/write로 테스트)
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(){
    const char* dev="/tmp/char0";
    mkfifo(dev, 0666);
    int rd = open(dev, O_RDONLY | O_NONBLOCK);
    int wr = open(dev, O_WRONLY);
    write(wr, "hello", 5);
    char buf[16]={0};
    read(rd, buf, 16);
    printf("driver-like read: %s\n", buf);
    return 0;
}
```

#### 2.7.3.5 파일시스템 저널링 전략(개념)

- **메타데이터 저널링**: 빠른 복구, 쓰기 앰플리피케이션  
- **순차 로그 구조**: 쓰기 집중 워크로드 유리, GC 필요  
- **카피-온-라이트(ZFS/Btrfs)**: 스냅샷/체크섬/자기치유, 메모리/메타데이터 오버헤드

#### 2.7.3.6 메모리 관리 구현 포인트

- **페이지 할당기**: buddy allocator + 슬랩/슬럽  
- **NUMA 인식**: first-touch, 정책 바인딩, migrate  
- **압축/스왑**: zswap/zram, IO 압력 완화

---

## 실전 묶음: “서비스 + 로더 + 정책”을 한 번에 경험하기

**목표**: (1) 소켓 활성화 echo 서비스, (2) 런타임 플러그인 로딩, (3) 정책 전환.

1) **서비스**: 앞의 `echo_srv`를 systemd로 구동  
2) **플러그인**: `libmadd.so`/`dyn_open.c` 예제를 서비스 내부에서 사용하도록 확장  
3) **정책**: 환경 변수로 “처리 정책”(예: 길이 제한, 우선순위)을 바꾸며 응답 지연/처리량 비교

**간단 지표 모델**  
요청 처리시간 $$T_s$$가 정책에 따라 $$T_s(\theta)$$ 로 변한다고 하자. 동시성 $$k$$, 네트워크 왕복 $$T_r$$, 큐잉지연 $$W(k,\theta)$$이면:
$$
\text{Throughput}(\theta) \approx \frac{k}{T_s(\theta) + T_r + W(k,\theta)}.
$$
정책 파라미터 $$\theta$$(예: 슬라이스/버퍼 크기/배치 크기)를 조정해 **처리량/지연 곡선**을 관측한다.

---

## 체크리스트 요약

- **System Services**: init/SCM, 소켓 활성화, 로깅/네트워킹/보안 데몬
- **Linker/Loader**: 정적/동적, ELF/PE, GOT/PLT, PIE/ASLR, `dlopen`
- **OS Specific**: ABI/바이너리 포맷/드라이버/보안/GUI/패키징 차이 → 포팅 레이어
- **Design Goals**: 안정/보안/성능/확장/관측/휴대성/유지보수
- **Mechanism vs Policy**: 런타임 교체 가능 설계(스케줄러/교체/IO)
- **Implementation**: 커널 구조, HAL/드라이버, 테스트/퍼징, 관측성

---

## 더 해보기(실습 과제)

1) `LD_PRELOAD`로 `write`를 후킹해 특정 문자열을 다른 파일로 미러링하라(보안/호환성 주의).  
2) 동일 앱을 리눅스/WSL/WSA/Windows 네이티브에서 빌드/실행하여 **로더/경로/권한 차이**를 정리하라.  
3) `bpftrace` 또는 `perf`로 `echo_srv` 요청 경로의 시스템콜 비용을 측정하고, **정책 파라미터**(버퍼 크기 등) 변화가 미치는 영향을 그래프로 비교하라.  
4) `meson`/`CMake`로 “포팅 레이어 + dlopen 플러그인 + 서비스”를 하나의 프로젝트로 구성해보라.

---

## 결론

운영체제의 **서비스 계층**은 커널 시스템콜을 **현대적 운영/보안/옵저버빌리티** 요구에 맞게 포장한다.  
**링커/로더**는 코드와 데이터를 실행시점에 연결하여 **메모리/성능/보안** 트레이드오프를 관리한다.  
앱이 **OS별**로 달라지는 핵심은 **ABI/환경 서비스**이며, 이를 넘는 길은 **추상화/동적 로딩/컨테이너**다.  
마지막으로 **설계 목표–메커니즘–정책–구현**의 구분을 명확히 하고, **관측 가능한 설계**를 하라 — 그게 운영체제의 길고 안정적인 진화를 가능케 한다.