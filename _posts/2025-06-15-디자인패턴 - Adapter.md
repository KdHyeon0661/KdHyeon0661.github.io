---
layout: post
title: 디자인패턴 - Adapter
date: 2025-06-15 23:20:23 +0900
category: 디자인패턴
---
# Adapter (어댑터 패턴)

## ✅ 정의

**어댑터 패턴(Adapter Pattern)**은 **호환되지 않는 인터페이스**를 가진 두 객체를 **연결**해주는 디자인 패턴입니다.  
즉, 기존 코드(클라이언트)가 **원하는 인터페이스 형식으로 기존 클래스를 감싸는 중간 계층**을 만들어, 마치 기존 클래스가 클라이언트가 기대한 인터페이스인 것처럼 동작하게 합니다.

> 전기 어댑터가 콘센트와 기기의 규격을 맞춰주는 것처럼, 객체 간의 인터페이스를 맞춰주는 역할을 합니다.

---

## 🎯 의도 (Intent)

- **호환되지 않는 인터페이스를 연결**하여 기존 코드를 수정하지 않고 재사용 가능하게 한다.
- 기존 시스템(클라이언트)이 기대하는 인터페이스를 제공하되, 실제 구현은 다른 객체가 수행한다.

---

## 📦 구조 (UML)

```
┌─────────────────────┐        ┌──────────────────────┐
│    Client           │◄──────►│ Target (인터페이스)   │
└─────────────────────┘        └──────────────────────┘
                                       ▲
                                       │
                             ┌────────────────────┐
                             │ Adapter            │
                             └────────────────────┘
                                       │
                                       ▼
                          ┌────────────────────────────┐
                          │ Adaptee (기존 클래스)       │
                          └────────────────────────────┘
```

- **Target**: 클라이언트가 기대하는 인터페이스
- **Adaptee**: 기존에 구현되어 있는 클래스 (인터페이스가 다름)
- **Adapter**: `Target` 인터페이스를 구현하고, 내부적으로 `Adaptee`를 사용함

---

## 🧑‍💻 구현 예시 (Python)

```python
# 기존 클래스 (Adaptee)
class OldPrinter:
    def print_text(self, text):
        print(f"[OLD] {text}")

# 클라이언트가 원하는 인터페이스 (Target)
class Printer:
    def print(self, text):
        pass

# 어댑터 클래스
class PrinterAdapter(Printer):
    def __init__(self, old_printer: OldPrinter):
        self.old_printer = old_printer

    def print(self, text):
        # 내부적으로 old_printer 방식으로 변환
        self.old_printer.print_text(text)

# 사용 예
client_printer = PrinterAdapter(OldPrinter())
client_printer.print("Hello, Adapter!")
# 출력: [OLD] Hello, Adapter!
```

---

## ✅ 장점

- **기존 클래스의 재사용**이 가능해짐 (인터페이스가 달라도 사용 가능)
- 클라이언트 코드를 **수정하지 않고 확장 가능**
- 코드 간 결합도를 낮추며 **유연한 아키텍처** 구현 가능

---

## ⚠️ 단점

- 클래스 수가 증가하여 구조가 복잡해질 수 있음
- 너무 많이 사용하면 **오히려 코드의 흐름이 불분명**해질 수 있음
- 어댑터가 너무 많아지면 유지보수 어려움

---

## 📌 사용 사례

| 사례 | 설명 |
|------|------|
| **레거시 시스템 통합** | 기존 시스템과 새 시스템의 인터페이스를 연결 |
| **외부 라이브러리 래핑** | 외부 API의 복잡한 인터페이스를 간단히 변환 |
| **UI 프레임워크 마이그레이션** | 새로운 컴포넌트와 기존 API의 연결 |
| **파일 포맷 변환기** | JSON ↔ XML, CSV ↔ JSON 등의 변환 로직 어댑팅 |

---

## 🧠 클래스 vs 객체 어댑터

| 구분         | 클래스 어댑터 | 객체 어댑터 |
|--------------|----------------|----------------|
| 구현 방식    | 다중 상속 사용 | 내부에 객체를 포함 (위임) |
| 유연성       | 낮음           | 높음 (동적으로 교체 가능) |
| 사용 언어 제한 | 상속 기반 언어 (Java 등) | 대부분 언어에서 사용 가능 |
| 대표 언어    | Java, C++      | Python, JavaScript 등 |

> 💡 Python에서는 객체 어댑터 방식이 일반적입니다. (`구성 → 위임`)

---

## 🧠 마무리

**어댑터 패턴**은 기존 코드와 새로운 코드를 **무리 없이 연결**해주는 훌륭한 방법입니다.  
특히 **레거시 코드 활용, 외부 API 통합, 포맷 변환기 개발**에서 매우 유용하게 쓰입니다.

하지만 남용하면 시스템의 구조가 복잡해질 수 있으므로, **인터페이스 불일치가 실제로 존재할 때에만 적용**하는 것이 바람직합니다.
