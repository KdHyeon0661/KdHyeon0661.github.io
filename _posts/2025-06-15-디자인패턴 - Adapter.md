---
layout: post
title: 디자인패턴 - Adapter
date: 2025-06-15 23:20:23 +0900
category: 디자인패턴
---
# Adapter(어댑터 패턴)

## 1. 정의(Definition)

**어댑터 패턴(Adapter Pattern)**은 **호환되지 않는 인터페이스**를 가진 두 객체를 **연결**해주는 패턴이다.  
클라이언트가 기대하는 인터페이스(**Target**)를 구현하는 **Adapter**가 내부적으로 기존 클래스(**Adaptee**)를 호출해, 마치 Adaptee가 Target처럼 동작하게 만든다. 전기 어댑터와 동일한 비유로 이해하면 쉽다.

---

## 2. 의도(Intent)

- 기존 시스템을 건드리지 않고, **인터페이스 불일치**를 해소하여 **재사용**한다.
- 클라이언트는 **Target 계약**만 의존하고, 실제 구현은 Adapter가 **위임**한다.
- 레거시/서드파티/플랫폼 API를 **우리 도메인 언어로 표준화**한다.

---

## 3. 구조(Structure) — 제공한 UML 그림 보존

```
┌─────────────────────┐        ┌──────────────────────┐
│    Client           │◄──────►│ Target (인터페이스)   │
└─────────────────────┘        └──────────────────────┘
                                       ▲
                                       │
                             ┌────────────────────┐
                             │ Adapter            │
                             └────────────────────┘
                                       │
                                       ▼
                          ┌────────────────────────────┐
                          │ Adaptee (기존 클래스)       │
                          └────────────────────────────┘
```

- **Target**: 클라이언트가 기대하는 인터페이스  
- **Adaptee**: 기존 클래스(인터페이스가 다름)  
- **Adapter**: Target을 구현하며 내부적으로 Adaptee를 호출

---

## 4. 객체 어댑터 vs 클래스 어댑터

| 구분 | 객체 어댑터(Object Adapter) | 클래스 어댑터(Class Adapter) |
|---|---|---|
| 구현 | **구성/위임**(Adapter가 Adaptee **인스턴스** 보유) | **상속**(Adapter가 Adaptee를 **상속** + Target 구현) |
| 유연성 | 높음(런타임 교체/다수 Adaptee 조합 가능) | 낮음(상속 고정, 다중 상속 필요) |
| 언어 제약 | 대부분 언어에서 가능 | 클래스 다중 상속을 요구(C#/Java는 클래스 다중 상속 불가; Java는 “Adaptee 상속 + Target 구현”은 가능) |
| 캡슐화 | 좋음 | 상대적으로 약함(Adaptee의 protected 노출) |
| 권장 | 일반적으로 **객체 어댑터 권장** | Adaptee 확장/오버라이드가 핵심일 때만 |

보통 Python/C#/Java에서는 **객체 어댑터**가 표준적인 선택이다.

---

## 5. 최소 예제(객체 어댑터) — Python

```python
# Adaptee: 레거시 프린터
class OldPrinter:
    def print_text(self, text: str) -> None:
        print(f"[OLD] {text}")

# Target: 클라이언트 기대 인터페이스
class Printer:
    def print(self, text: str) -> None:
        raise NotImplementedError

# Adapter: Target을 구현하고 Adaptee에게 위임
class PrinterAdapter(Printer):
    def __init__(self, old_printer: OldPrinter):
        self._old = old_printer

    def print(self, text: str) -> None:
        # 필요 시 포맷/인코딩/검증/로깅/예외 매핑 수행
        self._old.print_text(text)

client_printer = PrinterAdapter(OldPrinter())
client_printer.print("Hello, Adapter!")  # [OLD] Hello, Adapter!
```

핵심은 **Target 계약의 안정성**과 **Adaptee 호출 세부를 캡슐화**하는 것이다.

---

## 6. 실전 예제 1 — 결제 게이트웨이 어댑터(C#)

서로 다른 결제 벤더(API/예외/단위)가 있는 상황에서, 우리 앱은 **표준 인터페이스**만 의존한다.

```csharp
public interface IPayment {
    Task<PaymentResult> PayAsync(PaymentRequest req, CancellationToken ct = default);
}

public record PaymentRequest(decimal AmountKRW, string Method, string OrderId);
public record PaymentResult(bool Success, string TransactionId, string? Error);

#region 레거시/서드파티
public class PayFastClient {
    public Task<string> Charge(int amountWon, string method, string orderId) 
        => Task.FromResult("TX123"); // 단순화
}
#endregion

// Adapter: IPayment ←(Adapter)→ PayFastClient(Adaptee)
public sealed class PayFastAdapter : IPayment
{
    private readonly PayFastClient _client;
    public PayFastAdapter(PayFastClient client) => _client = client;

    public async Task<PaymentResult> PayAsync(PaymentRequest req, CancellationToken ct = default)
    {
        try {
            // 단위/포맷 매핑
            int amountWon = checked((int)decimal.Round(req.AmountKRW, 0, MidpointRounding.AwayFromZero));
            string tx = await _client.Charge(amountWon, req.Method, req.OrderId);
            return new PaymentResult(true, tx, null);
        } catch (Exception ex) {
            // 예외 → 도메인 오류로 매핑
            return new PaymentResult(false, "", ex.Message);
        }
    }
}
```

장점
- 클라이언트는 **IPayment**만 의존 → 다른 벤더로 교체가 쉬움.  
- **에러/단위/포맷**을 어댑터 내부에서 통일.

---

## 7. 실전 예제 2 — 비동기/콜백 API 어댑트(Python)

레거시 콜백 기반 API를 `async`/`await` Target으로 감싼다.

```python
import asyncio
from typing import Callable, Optional

# Adaptee: 콜백 기반 네트워크 클라이언트
class LegacyClient:
    def request(self, payload: bytes, cb: Callable[[Optional[Exception], bytes], None]) -> None:
        # 네트워크 비동기 작업 후 cb(err, data) 호출 (여기선 모의)
        try:
            cb(None, b"OK:" + payload)
        except Exception as e:
            cb(e, b"")

# Target: asyncio 기반의 표준 인터페이스
class AsyncClient:
    async def request(self, payload: bytes) -> bytes:
        raise NotImplementedError

# Adapter: 콜백 → awaitable로 브리지
class AsyncClientAdapter(AsyncClient):
    def __init__(self, legacy: LegacyClient):
        self._legacy = legacy

    async def request(self, payload: bytes) -> bytes:
        loop = asyncio.get_running_loop()
        fut: asyncio.Future[bytes] = loop.create_future()

        def cb(err: Optional[Exception], data: bytes):
            if err:
                fut.set_exception(err)
            else:
                fut.set_result(data)

        # 콜백 실행을 이벤트 루프 안전하게 래핑할 수도 있다
        self._legacy.request(payload, cb)
        return await fut

# 사용
# data = await AsyncClientAdapter(LegacyClient()).request(b"ping")
```

포인트
- **파라미터 변환/스케줄링 정책**을 Adapter가 담당.
- 동시성 모델이 다른 라이브러리 간 **경계 완화**.

---

## 8. 실전 예제 3 — 포맷 변환 어댑터(JSON ↔ XML)

```python
import json
import xml.etree.ElementTree as ET
from abc import ABC, abstractmethod
from typing import Any, Dict

# Target: 우리 시스템은 Dict <-> bytes(JSON)만 다룸
class JsonCodec(ABC):
    @abstractmethod
    def encode(self, obj: Dict[str, Any]) -> bytes: ...
    @abstractmethod
    def decode(self, data: bytes) -> Dict[str, Any]: ...

class DefaultJson(JsonCodec):
    def encode(self, obj: Dict[str, Any]) -> bytes: return json.dumps(obj, ensure_ascii=False).encode("utf-8")
    def decode(self, data: bytes) -> Dict[str, Any]: return json.loads(data.decode("utf-8"))

# Adaptee: 외부 라이브러리는 XML만
class XmlLib:
    def dump(self, obj: Dict[str, Any]) -> bytes:
        root = ET.Element("root")
        for k, v in obj.items():
            e = ET.SubElement(root, k); e.text = str(v)
        return ET.tostring(root, encoding="utf-8")
    def load(self, data: bytes) -> Dict[str, Any]:
        root = ET.fromstring(data)
        return {child.tag: child.text for child in root}

# Adapter: JsonCodec ←→ XmlLib
class XmlAsJsonAdapter(JsonCodec):
    def __init__(self, xml: XmlLib): self._xml = xml
    def encode(self, obj: Dict[str, Any]) -> bytes:
        return self._xml.dump(obj)
    def decode(self, data: bytes) -> Dict[str, Any]:
        return self._xml.load(data)

codec: JsonCodec = XmlAsJsonAdapter(XmlLib())
b = codec.encode({"id": 1, "name": "kim"})
obj = codec.decode(b)
```

효과
- 내부는 **JSON 계약**으로 통일, 외부는 XML만 지원해도 Adapter로 연결 가능.
- 스키마 차이/타입 캐스팅/날짜 포맷 등을 **Adapter에서 통일**.

---

## 9. 클래스 어댑터 — Java(상속 기반)

Java는 클래스 다중 상속이 불가하나, **Adaptee를 상속**하고 **Target 인터페이스를 구현**하는 형태로 “클래스 어댑터”를 만들 수 있다.

```java
// Target
interface Printer { void print(String text); }

// Adaptee
class OldPrinter {
    public void print_text(String text) { System.out.println("[OLD] " + text); }
}

// Class Adapter: OldPrinter를 확장 + Printer 구현
class PrinterClassAdapter extends OldPrinter implements Printer {
    @Override public void print(String text) { super.print_text(text); }
}

// 사용
Printer p = new PrinterClassAdapter();
p.print("hello");
```

장점: Adaptee의 보호된 기능을 오버라이드/재사용하기 쉬움  
단점: 상속 고정(유연성 낮음), **합성(객체 어댑터)**이 보통 더 낫다.

---

## 10. 성능/동시성/에러 매핑

- **오버헤드 모델**  
  Adapter 호출 1회 비용은
  $$ T_{\text{adapter}} = T_{\text{call}} + T_{\text{map}} + T_{\text{I/O}} $$
  여기서 \(T_{\text{map}}\)은 포맷/파라미터 변환, \(T_{\text{I/O}}\)는 네트워크/디스크 지연이다.  
  대부분의 실무에서 \(T_{\text{I/O}}\)가 지배적이므로 어댑터 오버헤드는 미미하지만, **고빈도 로컬 호출**에서는 매핑 비용을 최소화한다.
- **동시성**  
  어댑터는 가능하면 **무상태**로 설계. 공유 캐시/버퍼가 필요하면 락 범위를 최소화하고 **불변 데이터 + 원자적 스왑** 사용.
- **에러 매핑**  
  벤더별 예외/상태코드를 **도메인 오류**로 일관 매핑(예: `Timeout`, `InvalidInput`, `Unauthorized` 등).  
  로그에는 **원본 코드/메시지**를 보존하고, 상위에는 표준화된 오류를 던진다.

---

## 11. 테스트 전략(계약/골든/페일패스)

- **계약 테스트**: Target 인터페이스에 대한 **공통 테스트 스위트**를 정의하고, 모든 Adapter가 이를 통과하도록 한다.
- **골든 테스트**: 포맷 변환(예: JSON↔XML)에서 **샘플 입출력**을 고정해 회귀 방지.
- **페일 패스**: 네트워크오류/타임아웃/유효성 실패를 **명시적 시나리오**로 검증.
- **스파이/프록시**: Adaptee 호출 횟수/파라미터를 기록, 매핑 정확성 검증.

예시(PyTest)

```python
import pytest

class TargetSuite:
    def assert_printer_contract(self, p):
        p.print("x")  # 예외 없이 동작해야 함

def test_printer_adapter_contract():
    suite = TargetSuite()
    suite.assert_printer_contract(PrinterAdapter(OldPrinter()))
```

---

## 12. 리팩토링 절차 — “직접 사용” → “어댑터”

냄새
- 클라이언트 곳곳에 레거시 호출/파라미터 변환/에러 분기 산재.
- 외부 교체(새 벤더/API v2)가 어려움.

절차
1) **Target 인터페이스**를 먼저 정의(도메인 친화 이름/타입).  
2) 기존 호출을 수집해 **Adaptee** API 표면을 명확히 한다.  
3) **Adapter**를 작성하여 변환/예외 매핑을 캡슐화.  
4) 클라이언트는 Target만 의존하도록 변경(DIP).  
5) 테스트: 계약 테스트와 페일 패스로 경계 품질 검증.  
6) 구성/DI로 Adapter 선택 가능하게 한다.

---

## 13. 다른 패턴과의 관계(비교 표)

| 패턴 | 목적 | 어댑터와 차이 |
|---|---|---|
| **Bridge** | 추상과 구현을 **독립적으로 변화** | 인터페이스 불일치를 해결하진 않음(설계 시점의 분리) |
| **Decorator** | 기능을 **동적으로 추가** | 인터페이스는 **그대로 유지**, 변환 없음 |
| **Facade** | 복잡 서브시스템에 **단순 진입점** 제공 | 인터페이스 변환보다는 **단순화**가 목적 |
| **Proxy** | 접근 제어/원격/지연 로딩 | 동일 인터페이스 유지, 변환 없음 |
| **Adapter** | **인터페이스 변환** | 위 네 패턴과 **동시에** 사용할 수 있음(예: 로깅 데코레이터가 감싼 어댑터) |

---

## 14. 수학적 비용 분석 — 연결 수 감소

클라이언트 \(M\)개가, 제공자 \(N\)개와 직접 통신하려면 **연결 수**는  
$$ E_{\text{직접}} = M \times N $$
어댑터로 **Target 표준화**을 하면 클라이언트→Target은 \(M\)개, Target→제공자 어댑터는 \(N\)개만 필요하므로  
$$ E_{\text{어댑터}} = M + N $$
따라서 큰 시스템일수록 **의존성 그래프의 간선 수가 급감**한다.

---

## 15. 확장 패턴

- **양방향(Bi-directional) 어댑터**: 두 표준 사이를 상호 변환(주의: 상태/의미 손실 포인트 명시).  
- **체인형 어댑터**: A→B→C로 연쇄 변환(성능/가독성 저하 위험, 필요 시 **통합 어댑터**로 재작성).  
- **정책 주입형**: 재시도/백오프/서킷브레이커(Decorator)와 조합.

---

## 16. 체크리스트(최종)

- 인터페이스 **불일치**가 실제로 존재하는가? 단순 래핑이 아닌 **유의미한 변환**인가?  
- Target 계약이 **작고 명확**한가(과도한 범용화 금지)?  
- **에러/단위/포맷** 매핑 정책이 문서화되었는가?  
- 어댑터는 **무상태/재사용 가능**하게 설계되었는가?  
- 테스트(계약/골든/페일 패스)로 **경계 품질**을 보장하는가?  
- DI/구성으로 **어댑터 교체**가 쉬운가?

---

## 17. 장점/단점 요약

**장점**
- 레거시·외부 라이브러리를 **도메인 표면에 부드럽게 통합**  
- 클라이언트 코드 수정 최소화(의존성 역전)  
- 교체/버전 업 시 영향 범위 제한

**단점**
- 클래스/파일 증가, 디버깅 경로 길어짐  
- 남용 시 흐름 파악 어려움, **가짜 표준** 양산 위험  
- 성능 민감 코드에서 매핑 비용 고려 필요

---

## 18. 마무리

어댑터는 **인터페이스 경계에서의 마찰을 제거**하는 가장 실용적인 패턴이다.  
하지만 “무조건 래핑”이 능사는 아니다. 진짜로 **불일치가 존재**하고, **도메인 표준 계약(Target)**을 통해 시스템을 더 **안정적이고 교체 가능한 구조**로 만들 때 적용하라. 성능/에러/동시성/테스트를 겸비한 어댑터는 장기 유지보수성의 핵심 자산이 된다.
~~~markdown