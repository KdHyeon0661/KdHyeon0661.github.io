---
layout: post
title: 정보보안기사 - 데이터베이스 보안 위협과 통제, DBMS 보안 통제
date: 2025-11-13 18:25:23 +0900
category: 정보보안기사
---
# SECTION 11 데이터베이스 보안 — 01. 데이터베이스 보안 위협과 통제 · 02. DBMS 보안 통제

## 개요와 학습 목표

본 문서는 실무/실기 관점에서 **데이터베이스(DB) 보안의 위협 모델 → 통제 설계 → DBMS별 구현 예제(PostgreSQL/MySQL/MariaDB/SQL Server/Oracle)**를 한 번에 정리한다.
핵심은 **계층 방어**(네트워크/호스트/인증/인가/암호화/감사/백업/운영)와 **최소권한·기본거부(Default Deny)**, **가시성(감사·로그·경보)**, **회복력(백업·복구·DR)**이다.

---

## 위협 모델(Threat Landscape) — 어디로, 무엇이, 어떻게 침해되는가
### 공격 표면 요약

| 계층 | 대표 위협 | 발생 맥락 | 영향 |
|---|---|---|---|
| 네트워크 | 노출 포트 스캔, 무단 접속, TLS 다운그레이드 | 방화벽 미흡, 외부 공개 | 데이터 탈취, RCE |
| 인증/세션 | 약한 암호, 재사용, 브루트포스, 무TLS | 계정 정책 부재 | 계정 탈취, 내부자 가장 |
| 인가 | **초과권한** 서비스 계정, PUBLIC 권한 남발 | 편의성 우선 | 대량 조회/삭제/권한상승 |
| 쿼리/프로시저 | **SQL Injection**, 동적 SQL, 위험한 DEFINER | 입력검증 부재 | 임의 DDL/DML, OS 접근 |
| 데이터 보호 | 미암호화(전송/저장), 키 관리 부실 | 운영 편의 | 평문 유출, 규제 위반 |
| 감사/로깅 | 미수집/미전송/미보존, 무시되는 경보 | SIEM 미연계 | 탐지 지연, 사후 분석 불가 |
| 백업/DR | 백업 평문, 탈취/랜섬, 복구 미검증 | 보관/절차 부실 | 영구 손실, 지연 |
| 변경/패치 | 미패치, 취약 옵션, 잘못된 파라미터 | 무검증 변경 | RCE/권한상승/DoS |

### 정량/정성 위험 평가(간단)

$$
\text{Risk} = \text{Likelihood} \times \text{Impact}
$$
- Likelihood: 노출/공격난이도/통제성숙도로 추정
- Impact: 기밀성·무결성·가용성·법적영향(벌금/평판)

---

## 보안 통제 아키텍처(Defense-in-Depth)

```
[사용자/앱]
   │  (입력검증·ORM·준비문)
[API/APP 계층]
   │  (프록시·WAF·세션보호·비밀관리)
[네트워크]
   │  (FW/SG·세그멘테이션·mTLS)
[DB Listener/인증]
   │  (TLS·Kerberos/LDAP·비대칭)
[권한/RBAC/정책]
   │  (스키마 분리·RLS/VPD·데이터 마스킹)
[암호화]
   │  (TDE·열단 암호화·키관리/HSM)
[감사/모니터링]
   │  (Audit/Log/SIEM/UEBA)
[백업/DR/무결성]
   └─(암호화 백업·불변 저장·주기적 복구훈련)
```

---

## 네트워크/호스트 통제
### 방화벽·세그멘테이션 규칙(예: 리스너만 앱 서브넷에서 접근)

- **Inbound**: DB 포트(5432/3306/1433/1521)는 **APP 서브넷만 허용**
- **Outbound**: 외부 인터넷 차단(필수 업데이트/라이선스만 예외)
- Bastion/Jumphost에서만 관리자 접근(SSH/RDP → DB)

**예: Linux `nftables` 최소 규칙**
```bash
table inet db {
  chain input {
    type filter hook input priority 0;
    iif != "eth0" drop
    ct state established,related accept
    ip saddr 10.20.0.0/16 tcp dport {5432,3306,1433,1521} accept
    tcp dport {22} ip saddr 10.10.0.0/16 accept
    counter drop
  }
}
```

### 리스너 바인딩/포트 고정

- `listen_addresses`(PG), `bind-address`(MySQL), `TCP/IP enabled`(MSSQL), `LOCAL_LISTENER`(Oracle) 등 **내부 IP로 제한**.

---

## 인증(Authentication)
### 원칙

- **강력한 인증**: TLS 필수, MFA(운영자), 중앙 인증(Kerberos/AD/LDAP)
- **앱-DB 비밀**: **시크릿 관리자**(vault/KMS)에서 주기적 **회전**

### PostgreSQL — `pg_hba.conf` 예

```conf
# 내부 APP 서브넷만 TLS+SCRAM

hostssl myappdb  app_user  10.20.0.0/16  scram-sha-256 clientcert=1
# 운영자: Kerberos

hostssl all      +dba      10.10.0.0/16  gss include_realm=1 krb_realm=EXAMPLE.COM
```

### MySQL — SSL/TLS 강제 & 계정

```sql
-- SSL 필수 계정
CREATE USER 'app_user'@'10.20.%' IDENTIFIED BY '***' REQUIRE SSL PASSWORD EXPIRE INTERVAL 90 DAY;
ALTER USER 'app_user'@'10.20.%' IDENTIFIED WITH caching_sha2_password;
```

### SQL Server — AD 통합(개요)

- **Windows 인증** 우선, 관리자는 AD 그룹(`SQL_DBA`) 매핑
- 애플리케이션은 **Contained Database User + 전용 Login**으로 분리

### Oracle — 비밀번호 프로파일/잠금

```sql
CREATE PROFILE APP_PROFILE LIMIT
  FAILED_LOGIN_ATTEMPTS 5
  PASSWORD_LIFE_TIME 90
  PASSWORD_GRACE_TIME 7
  PASSWORD_LOCK_TIME 1/24; -- 1시간
ALTER USER APP_USER PROFILE APP_PROFILE;
```

---

## 인가(Authorization) — 최소권한·기본거부
### 스키마 분리 & 역할 기반

- **app_schema**(실행 객체), **data_schema**(테이블) 분리
- **ROLE**: `app_read`, `app_write`, `report_read` …와 같이 **작은 단위**로 설계
- **기본거부**: PUBLIC 권한 제거, 새 객체 기본권한 제한

**PostgreSQL 예**
```sql
REVOKE ALL ON SCHEMA public FROM PUBLIC;
CREATE SCHEMA app AUTHORIZATION app_owner;
CREATE ROLE app_read NOINHERIT;
CREATE ROLE app_write NOINHERIT;
GRANT USAGE ON SCHEMA app TO app_read, app_write;
GRANT SELECT ON ALL TABLES IN SCHEMA app TO app_read;
GRANT INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA app TO app_write;
ALTER DEFAULT PRIVILEGES IN SCHEMA app
  GRANT SELECT ON TABLES TO app_read;
```

### 행·열 단위 통제(RLS/마스킹)

- **PostgreSQL RLS**
```sql
ALTER TABLE app.orders ENABLE ROW LEVEL SECURITY;
CREATE POLICY p_tenant_isolation ON app.orders
  USING (tenant_id = current_setting('app.tenant_id')::int);
```
- **SQL Server RLS**
```sql
CREATE FUNCTION dbo.fn_tenant_predicate(@tenant_id int)
RETURNS TABLE WITH SCHEMABINDING AS
  RETURN SELECT 1 AS fn_result WHERE @tenant_id = SESSION_CONTEXT(N'tenant_id');
GO
CREATE SECURITY POLICY TenantFilter
ADD FILTER PREDICATE dbo.fn_tenant_predicate(tenant_id) ON dbo.Orders;
```
- **Oracle VPD(DBMS_RLS)**, **MySQL에는 RLS 부재 → VIEW/스토어드 루틴+조건**으로 대체.

---

## 안전한 쿼리/프로시저
### SQL Injection 방지 — **준비문(Prepared Statement)** 강제

```python
# psycopg2 예

cur.execute("INSERT INTO app.users(name,email) VALUES (%s,%s)", (name, email))
```
- 동적 SQL이 필요하면 **화이트리스트**(컬럼/정렬키) + 바인딩.

### 위험한 DEFINER 루틴 금지

- MySQL/MariaDB의 `SQL SECURITY DEFINER`는 **최소권한 계정**으로만, **필요 최소 DML**만 수행.

---

## 암호화 — 전송·저장·키 관리
### 전송(TLS)

- 서버/클라이언트 양쪽에서 **최신 TLS** 강제, **mTLS**(서버↔앱) 권장
- **PostgreSQL**: `ssl=on`, `ssl_min_protocol_version='TLSv1.2'`
- **MySQL**: `--require_secure_transport=ON`
- **SQL Server**: Force Encryption(서버), 클라이언트 TrustServerCertificate=false
- **Oracle**: `SQLNET.ENCRYPTION_SERVER=REQUIRED`, `SQLNET.AUTHENTICATION_SERVICES=(TCPS,BEQ)`

**PostgreSQL 서버 예**
```conf
# postgresql.conf

ssl = on
ssl_min_protocol_version = 'TLSv1.2'
ssl_ciphers = 'HIGH:!aNULL:!MD5'
```

### 저장(At-Rest)

- **TDE(Transparent Data Encryption)**: SQL Server/Oracle/MySQL Enterprise, MariaDB(엔진별)
- **열단 암호화**: **pgcrypto**(PG), **Always Encrypted**(MSSQL)
- 키는 **KMS/HSM**에, **분리 의무**(DBA≠키관리자).

**SQL Server TDE**
```sql
CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'Strong_P@ss!';
CREATE CERTIFICATE MyServerCert WITH SUBJECT='TDE';
CREATE DATABASE ENCRYPTION KEY
  WITH ALGORITHM = AES_256 ENCRYPTION BY SERVER CERTIFICATE MyServerCert;
ALTER DATABASE Sales SET ENCRYPTION ON;
```

**Oracle TDE(요지)**
```sql
ADMINISTER KEY MANAGEMENT SET KEYSTORE OPEN IDENTIFIED BY "KeystorePass";
ADMINISTER KEY MANAGEMENT SET KEY IDENTIFIED BY "KeystorePass" WITH BACKUP;
ALTER SYSTEM SET ENCRYPTION KEY IDENTIFIED BY "KeystorePass";
```

**PostgreSQL 열단 암호화(pgcrypto)**
```sql
SELECT pgp_sym_encrypt('4111-1111-1111-1111','k'),
       pgp_sym_decrypt(column, 'k');
```

---

## 감사/로깅/모니터링
### 수집 원칙

- **누가/언제/어디서/무엇을**: 로그인 성공/실패, 권한 변경, DDL, 고위험 DML(PII 테이블 SELECT/UPDATE/DELETE)
- **중앙집중**: 원격 syslog/agent로 **SIEM** 전송, **불변 저장**(WORM)

### PostgreSQL

- **pgaudit** 확장: 역할 사용, DDL/DML/SELECT 감사
```sql
CREATE EXTENSION pgaudit;
ALTER SYSTEM SET pgaudit.log = 'read, write, ddl';
ALTER SYSTEM SET log_line_prefix = '%m [%p] %u %d %h ';
SELECT pg_reload_conf();
```

### MySQL/MariaDB

- **Enterprise Audit** 또는 **MariaDB Audit Plugin**
```sql
INSTALL PLUGIN server_audit SONAME 'server_audit';
SET GLOBAL server_audit_logging=ON;
SET GLOBAL server_audit_events='CONNECT,QUERY_DDL,QUERY_DML';
```

### SQL Server

```sql
CREATE SERVER AUDIT AuditToFile
TO FILE (FILEPATH='D:\Audit\');
ALTER SERVER AUDIT AuditToFile WITH (STATE=ON);
CREATE DATABASE AUDIT SPECIFICATION AuditDDL
FOR SERVER AUDIT AuditToFile
ADD (SCHEMA_OBJECT_CHANGE_GROUP);
ALTER DATABASE AUDIT SPECIFICATION AuditDDL WITH (STATE=ON);
```

### Oracle Unified Auditing(요지)

```sql
CREATE AUDIT POLICY audit_privs ACTIONS GRANT, REVOKE, CREATE USER, DROP USER;
AUDIT POLICY audit_privs;
AUDIT SELECT ON HR.EMPLOYEES BY USERS app_read, app_write;
```

---

## 백업/복구/DR — **보안성 & 복원력**

- **암호화 백업**(서버 측/스토리지 측), **오프사이트 보관**, **불변(Immutable) 저장**
- **주기적 복구 연습**: RTO/RPO 검증, 체크섬 무결성

**PostgreSQL**
```bash
# Base backup + WAL 아카이브

psql -c "SELECT pg_start_backup('base')"
rsync -a /var/lib/postgresql/14/main /backup/base_$(date +%F)
psql -c "SELECT pg_stop_backup()"
```

**MySQL**
```bash
mysqldump --single-transaction --routines --triggers mydb | \
  openssl enc -aes-256-cbc -salt -out /backup/mydb.sql.enc
```

**SQL Server**
```sql
BACKUP DATABASE Sales TO DISK='\\backup\sales.bak' WITH COMPRESSION, CHECKSUM, ENCRYPTION(ALGORITHM = AES_256, SERVER CERTIFICATE = MyServerCert);
```

---

## 변경관리/패치/구성 기준

- **CIS Benchmarks**(DBMS별) 기반 점검
- **Parameter as Code**(ansible/terraform)로 재현성
- 테스트 → 승인 → 배포 → 검증 **릴리즈 절차**

---

## DBMS별 “보안 베이스라인” 빠른 레시피

### PostgreSQL

1) **네트워크**: 전용 VPC/서브넷, `pg_hba.conf` 최소화, `listen_addresses` 내부
2) **TLS**: 서버/클라 인증서, `ssl_min_protocol_version='TLSv1.2+'`
3) **인증**: SCRAM/Kerberos, 운영자 GSS, 앱 유저는 SCRAM + mTLS
4) **권한**: PUBLIC 권한 제거, RLS 정책, `search_path` 고정
5) **로그/감사**: `log_statement='ddl'`, pgaudit, 원격 전송
6) **백업**: basebackup + WAL, 암호화 저장
7) **옵션**: `track_activities=on`, `log_connections=on`, `log_disconnections=on`

**샘플: `pg_hba.conf`**
```conf
hostssl mydb app_user 10.20.0.0/16 scram-sha-256 clientcert=1
hostssl all  +dba     10.10.0.0/16 gss include_realm=1
```

### MySQL/MariaDB

1) `bind-address` 내부, `--require_secure_transport=ON`
2) `caching_sha2_password`(MySQL 8), 암호 만료/재사용 제한
3) **Role 기반 GRANT**, DEFINER 최소권한
4) **Audit Plugin** 활성, general/slow log는 운영 정책에 맞게
5) **백업**: xtrabackup/Enterprise backup + 암호화

**GRANT 예**
```sql
CREATE ROLE app_read, app_write;
GRANT SELECT ON mydb.* TO app_read;
GRANT SELECT,INSERT,UPDATE,DELETE ON mydb.* TO app_write;
GRANT app_read TO 'app_user'@'10.20.%';
```

### SQL Server

1) Force Encryption, 최신 프로토콜
2) AD 그룹 기반 로그인, 최소권한 서버/DB 역할
3) **TDE + RLS + Dynamic Data Masking/Always Encrypted(민감 열)**
4) SQL Server Audit + XE(Extended Events)
5) 백업 암호화 + 체크섬 + 오프사이트

**RLS/마스킹 예**
```sql
ALTER TABLE dbo.Customer WITH (SYSTEM_VERSIONING = OFF); -- 필요 시
ALTER TABLE dbo.Customer ALTER COLUMN Email ADD MASKED WITH (FUNCTION='email()');
```

### Oracle

1) `sqlnet.ora`로 암호군/TLS, `REMOTE_LOGIN_PASSWORDFILE=EXCLUSIVE`
2) PROFILE로 암호 정책, **DBA/APP 권한 분리**, **Database Vault**(가능 시)
3) **TDE Wallet/OKV** + **Data Redaction**(조회 시 마스킹)
4) Unified Auditing + Fine-Grained Auditing(FGA)
5) RMAN 암호화 백업, FRA/오프사이트

**FGA 예**
```sql
BEGIN
  DBMS_FGA.add_policy(
    object_schema => 'HR',
    object_name   => 'EMPLOYEES',
    policy_name   => 'FGA_SEL_SSN',
    audit_column  => 'SSN',
    statement_types => 'SELECT');
END;
/
```

---

## 실습 시나리오(핵심 과제)

1) **PostgreSQL 다중 테넌트 RLS**: 테넌트별 격리 + pgaudit로 SELECT 로깅 → SIEM 전송
2) **MySQL 앱 최소권한**: 스키마 분리 + ROLE/GRANT, DEFINER 루틴 제거, SSL 필수
3) **SQL Server**: TDE 활성 → RLS 정책 → Audit → 백업 암호화 복구 테스트
4) **Oracle**: PROFILE/잠금/암호정책 → TDE Wallet → Unified Auditing/FGA → RMAN 복구

---

## 운영 “금기사항”(Anti-Patterns)

- 앱 계정에 `DB_OWNER`/`SUPERUSER`/`DBA` 부여
- PUBLIC에 DML/EXECUTE 남발, 새 객체 기본권한 미관리
- 평문 백업/S3 공개 버킷, 키/비밀을 코드에 하드코딩
- 무TLS 접속 허용, 감사 미수집·미분석, 복구 미훈련

---

## 점검 체크리스트(요약)

- [ ] **네트워크**: 내부 바인딩, FW/SG 최소, Bastion 경유
- [ ] **TLS**: 전송암호화 강제, mTLS(앱↔DB)
- [ ] **인증**: 중앙 인증/강암호/회전, 운영자 MFA
- [ ] **인가**: 스키마 분리, ROLE 설계, 기본거부, RLS/VPD
- [ ] **쿼리**: 준비문, 동적SQL 화이트리스트, DEFINER 최소화
- [ ] **암호화**: TDE/열단, KMS/HSM, 키 롤오버 절차
- [ ] **감사**: 로그인/DDL/고위험 DML, SIEM 연계, 불변 보존
- [ ] **백업/DR**: 암호화 백업, 불변 저장, 정기 복구 연습
- [ ] **패치/구성**: 정기 패치, CIS 기준 준수, IaC 기록
- [ ] **권한검토**: 정기적 접근 재검토·만료(Joiner-Mover-Leaver)

---

## (선택) 데이터 민감도 분류의 수식적 메모

$$
\text{SensitivityScore} = w_c C + w_i I + w_a A + w_l L
$$
- \(C,I,A\): 기밀/무결/가용 영향 점수, \(L\): 법/규제 영향, \(w_*\): 가중치
→ **고민감 데이터**는 **열단 암호화·쿼리 감사 강화·액세스 재검토 주기 단축**.

---

## 부록 A) 구성 파일 스니펫 모음

### A.1 PostgreSQL TLS/로그

```conf
# postgresql.conf

ssl=on
ssl_min_protocol_version='TLSv1.2'
log_line_prefix='%m [%p] %u %d %h '
log_connections=on
log_disconnections=on
log_statement='ddl'
```

### A.2 MySQL 보안 my.cnf

```ini
[mysqld]
bind-address=10.20.5.12
require_secure_transport=ON
tls_version=TLSv1.2,TLSv1.3
validate_password.policy=STRONG
local_infile=OFF
```

### A.3 SQL Server — Force Encryption(개요)

- SQL Server Configuration Manager → Protocols for MSSQLSERVER → **Force Encryption=Yes**
- 서버 인증서 바인딩, 클라이언트는 TrustServerCertificate=False

### A.4 Oracle sqlnet.ora(요지)

```ini
SQLNET.ENCRYPTION_SERVER = REQUIRED
SQLNET.ENCRYPTION_TYPES_SERVER = (AES256,AES192)
SQLNET.AUTHENTICATION_SERVICES = (TCPS,BEQ)
```

---

## 결론

- **위협 모델**을 먼저 명확히 하고, **네트워크→인증→인가→암호화→감사→백업**의 **계층 방어**를 일관되게 구현한다.
- **DBMS별 구체 예제**(pg_hba/GRANT/RLS/TDE/Audit 등)를 **표준 템플릿**으로 남기고 IaC로 재현 가능하게 관리한다.
- 보안은 **설정**이 아니라 **운영**이다. 로그를 보고, 경보를 다듬고, 백업을 복구해 보라 — **그것이 최종 통제의 증거**다.
