---
layout: post
title: 논리회로설계 - 카노맵
date: 2025-08-28 21:25:23 +0900
category: 논리회로설계
---
# 카노맵(Karnaugh Map) — **스위칭 함수의 최소 형식**, **2·3·4변수 K-map**, **필수 주항(EPI)으로 최소식 결정**

> 표기 관례: \(+\)=OR, \(\cdot\) 또는 생략=AND, \(\overline{A}\)=NOT \(A\).  
> 변수 순서(관례): \(A\)(MSB) → \(B\) → \(C\) → \(D\).  
> K-map 행/열 라벨은 **그레이 코드(00, 01, 11, 10)** 를 사용합니다.

---

## 1. 스위칭 함수의 **최소 형식(minimal form)**

### 1.1 목표와 용어
- **목표**: 곱항/합항 수, 리터럴 수, 게이트 깊이를 최소화한 **최소식**을 구한다.
- **정규형**
  - **SOP(곱의 합)**: \(F=\sum m(I)\) — **1**이 되는 미니텀(minterm)의 합.
  - **POS(합의 곱)**: \(F=\prod M(J)\) — **0**이 되는 맥스텀(maxterm)의 곱.
- **주항(implicant)**: 1 셀(들)을 덮는 곱항.
- **소수 주항(PI, prime implicant)**: 더 이상 확장 불가한 주항(카노맵에서 **최대 크기 묶음**).
- **필수 주항(EPI, essential PI)**: 적어도 하나의 1 셀을 **오직 자신만** 덮는 PI.

> **Don’t care**(\(X\))는 필요할 때만 1로 간주하여 **묶음을 키우는** 데 사용한다.

### 1.2 K-map 최소화 원칙
- **인접 1들을 \(1,2,4,8,\dots\)** 크기(2의 거듭제곱)로 묶는다.
- **가로/세로 인접 + 테두리 래핑**(좌↔우, 상↔하 연속) 허용. **대각선은 인접 아님**.
- 같은 셀을 **여러 묶음에 중복** 포함해도 된다(더 큰 묶음 확보용).
- 가능한 한 **큰 묶음**을 우선적으로 만든다(리터럴 수 감소).

---

## 2. **2변수 K-map** (2×2)

### 2.1 배치(그레이 코드)
|      | C=0 | C=1 |
|------|-----|-----|
| **A=0** | m0  | m1  |
| **A=1** | m2  | m3  |

> 여기서는 간단히 \(A, C\) 두 변수라 가정(라벨 순서는 **00, 01, 11, 10** 규칙을 2열에 축약).

### 2.2 예시
- \(F=\sum m(1,3)\) → **열 \(C=1\)** 을 2셀로 묶음 ⇒ \(\boxed{F=C}\).
- \(F=\sum m(2,3)\) → **행 \(A=1\)** 묶음 ⇒ \(\boxed{F=A}\).
- \(F=\sum m(0,1,2,3)\) → 전체 묶음(4셀) ⇒ \(\boxed{F=1}\).

---

## 3. **3변수 K-map** (2×4) — 행 \(A\), 열 \(BC\) (그레이 코드)

### 3.1 배치
|      | **BC=00** | **01** | **11** | **10** |
|------|-----------|--------|--------|--------|
| **A=0** | m0        | m1     | m3     | m2     |
| **A=1** | m4        | m5     | m7     | m6     |

### 3.2 최소화 예 — \(\displaystyle F=\sum m(1,2,3,5,7)\)
K-map(1만 표기):

```
      BC
      00  01  11  10
A=0   0   1   1   1
A=1   0   1   1   0
```

- **그룹1(4셀)**: 열 **01, 11** 두 열을 위·아래로 묶음 → \(C=1\) 고정 → \(\boxed{C}\).
- **그룹2(2셀)**: \(m2(010)\)–\(m3(011)\) 가로 묶음 → \(A=0, B=1\) → \(\boxed{\overline{A}B}\).

\[
\boxed{F=C+\overline{A}B}
\]

검증: \(C=1\)이면 \(1,3,5,7\)을 덮고, 남는 \(2\)는 \(\overline{A}B\)가 덮는다.

---

## 4. **4변수 K-map** (4×4) — 행 \(AB\), 열 \(CD\) (둘 다 그레이 코드)

### 4.1 배치
| **AB \ CD** | **00** | **01** | **11** | **10** |
|-------------|--------|--------|--------|--------|
| **00**      | m0     | m1     | m3     | m2     |
| **01**      | m4     | m5     | m7     | m6     |
| **11**      | m12    | m13    | m15    | m14    |
| **10**      | m8     | m9     | m11    | m10    |

### 4.2 예 ① — \(\displaystyle F=\sum m(0,2,5,7,8,10,13,15)\)
K-map(1만 표기):

```
AB\CD  00  01  11  10
00     1   .   1   1
01     .   1   1   .
11     .   1   1   .
10     1   .   1   1
```

- **그룹A(4셀)**: \(B=0,\ D=0\) → \(\boxed{\overline{B}\,\overline{D}}\)
- **그룹B(4셀)**: \(B=1,\ D=1\) → \(\boxed{BD}\)

\[
\boxed{F=\overline{B}\,\overline{D}+BD = B\odot D}\quad\text{(XNOR)}
\]

> **래핑(가장자리 연결)** 덕분에 4셀 묶음 둘이 가능 → 리터럴 수 크게 감소.

### 4.3 예 ② — **EPI를 이용한 최소식 결정**  
\(\displaystyle F=\sum m(0,2,3,8,10,11,14,15)\)

K-map(1만 표기):

```
AB\CD  00  01  11  10
00     1   .   1   1      (m0, m3, m2)
01     .   .   .   .
11     .   .   1   1      (m15, m14)
10     1   .   1   1      (m8,  m11, m10)
```

- 눈으로 보이는 큰 묶음과 PI(소수 주항) 세트(한 가지 해석):
  - \(P_1=\overline{B}\,\overline{D}\)  (셀 \(0,2,8,10\))
  - \(P_2=\ \ \ C\overline{B}\)        (셀 \(2,3,10,11\))
  - \(P_3=\ \ \ AC\)                   (셀 \(10,11,14,15\))

**커버링 차트** (●: 해당 미니텀을 PI가 덮음)

| minterm | 0 | 2 | 3 | 8 | 10 | 11 | 14 | 15 |
|:------:|:-:|:-:|:-:|:-:|:--:|:--:|:--:|:--:|
| \(P_1=\overline{B}\,\overline{D}\) | ● | ● |   | ● |  ● |    |    |    |
| \(P_2=C\overline{B}\)              |   | ● | ● |   |  ● |  ● |    |    |
| \(P_3=AC\)                         |   |   |   |   |  ● |  ● |  ● |  ● |

- **EPI 판정**
  - \(m0, m8\)은 \(P_1\)만 덮음 ⇒ \(P_1\)은 **EPI**.
  - \(m3\)은 \(P_2\)만 덮음 ⇒ \(P_2\)는 **EPI**.
  - \(m14, m15\)는 \(P_3\)만 덮음 ⇒ \(P_3\)는 **EPI**.

따라서 모든 미니텀을 **EPI 3개**로 덮는다:

\[
\boxed{F = \overline{B}\,\overline{D} + C\overline{B} + AC}
\]

SOP 최소식(검증용 대수):
\[
F = \overline{B}\,\overline{D} \;+\; C\overline{B} \;+\; AC
\]
POS도 구해 보면(§7 코드 참고):
\[
F = (A+\overline{B}) (C+\overline{B}) (C+\overline{D})
\]

---

## 5. **EPI 기반 최소식 결정 절차**(요약)

1. **PI(소수 주항)** 모두 찾기 — K-map에서 만들 수 있는 **최대 크기 묶음**을 전부 열거.
2. **커버링 차트** 작성 — 각 미니텀을 어떤 PI들이 덮는지 표로 표시.
3. **EPI 선택** — 특정 미니텀을 **오직 하나의 PI만** 덮으면 그 PI는 **필수(EPI)**.
4. 남은 미니텀은 **최소 개수**의 PI로 덮는 **집합 커버**를 고른다(보통 **많이 덮는 PI**, **큰 묶음** 우선 휴리스틱).

> 6변수 이상이면 K-map보다 **퀘인–맥클러스키** + **Petrick’s method**(집합 커버)를 많이 사용.

---

## 6. **POS 최소화(0 묶기)** — 보완 관점

- SOP는 **1을 묶어 곱항**을 만든다.
- POS는 **0을 묶어 합항**을 만든다(규칙·그레이 배치는 동일).
- 4변수에서 \(F=0\)인 셀들을 8·4·2·1 묶음으로 커버 → 각 묶음이 \((\text{합항})\) 이 되고, 최종식은 이 합항의 **AND**.

보수/정규형 대응:
\[
\overline{F}=\sum m(\text{0인 인덱스}) \quad\Rightarrow\quad F=\prod M(\text{0인 인덱스})
\]

---

## 7. **프로그램화된 예제** (Python; **진리표/최소화/검증**)

> **이 코드는 설명용**입니다. `sympy`가 설치되어 있으면 실제로 최소식을 확인할 수 있습니다.

### 7.1 그레이 코드 K-map 배치 및 렌더링
```python
# Karnaugh Map helper (4 vars) with Gray labeling
from itertools import product

gray = ['00','01','11','10']  # Gray order
def idx_to_bits(i, n=4):
    return f"{i:0{n}b}"

def grid_positions():
    # rows: AB in Gray; cols: CD in Gray
    pos = {}
    for r,ab in enumerate(gray):
        for c,cd in enumerate(gray):
            bits = ab + cd  # A B C D
            idx = int(bits, 2)
            pos[idx] = (r, c)
    return pos  # {minterm: (row, col)}

def render_kmap(ones, xs=()):
    pos = grid_positions()
    M = [['.' for _ in range(4)] for __ in range(4)]
    for i in ones:
        r,c = pos[i]
        M[r][c] = '1'
    for i in xs:
        r,c = pos[i]
        M[r][c] = 'X'
    # header
    print("AB\\CD  00  01  11  10")
    for r,ab in enumerate(gray):
        row = "  ".join(M[r])
        print(f"{ab}    {row}")

# Example (matches §4.3)
render_kmap([0,2,3,8,10,11,14,15])
```

### 7.2 `sympy`로 **SOP/POS 최소화** & 동치 검증
```python
# pip install sympy
from sympy import symbols
from sympy.logic.boolalg import SOPform, POSform, simplify_logic, Equivalent

A,B,C,D = symbols('A B C D')

# Example: F = Σm(0,2,3,8,10,11,14,15)
mins = [0,2,3,8,10,11,14,15]
F_sop = SOPform([A,B,C,D], mins)              # 정규형 SOP
F_dnf = simplify_logic(F_sop, form='dnf')     # 최소 DNF(SOP)
F_cnf = simplify_logic(F_sop, form='cnf')     # 최소 CNF(POS)

print("SOP (DNF):", F_dnf)    # (~B & ~D) | (C & ~B) | (A & C)
print("POS (CNF):", F_cnf)    # (A | ~B) & (C | ~B) & (C | ~D)

# 동치 검증(예: (A+B)(A+C) == A+BC)
from sympy import Or, And, Not
G1 = And(Or(A,B), Or(A,C))
G2 = Or(A, And(B,C))
print("Equivalent?", Equivalent(G1, G2))
```

### 7.3 **EPI 체크**(간단 차트 검사; PI를 수동 지정해 검증)
```python
# Given a product term as dict like {'A':1,'B':0,'C':1}, check coverage
def covers(term, a,b,c,d):
    for var,val in term.items():
        if var=='A' and a!=val: return False
        if var=='B' and b!=val: return False
        if var=='C' and c!=val: return False
        if var=='D' and d!=val: return False
    return True

# Example PIs for §4.3
PIs = [
    {'name':'~B~D', 'term':{'B':0,'D':0}},
    {'name':'C~B',  'term':{'C':1,'B':0}},
    {'name':'AC',   'term':{'A':1,'C':1}},
]
mins = [0,2,3,8,10,11,14,15]

def epi_detection(PIs, mins):
    epi = set()
    for m in mins:
        a,b,c,d = [(m>>k)&1 for k in (3,2,1,0)]
        covered_by = []
        for pi in PIs:
            if covers(pi['term'], a,b,c,d):
                covered_by.append(pi['name'])
        # EPI: covered by exactly one PI
        if len(covered_by)==1:
            epi.add(covered_by[0])
    return epi

print("EPIs:", epi_detection(PIs, mins))  # {'~B~D', 'C~B', 'AC'}
```

---

## 8. 실무 팁 & 체크리스트

- [ ] **그레이 코드 라벨**(00,01,11,10)인지 확인(01↔10 바꾸면 인접성이 깨짐).
- [ ] **가장 큰 묶음**부터 만들고, **중복 포함**을 허용하라.
- [ ] **X(don’t care)** 는 묶음을 키울 때만 포함.
- [ ] **EPI 먼저 고정**, 잔여 셀은 최소 개수의 PI로 커버.
- [ ] SOP·POS **양쪽 표현**을 함께 적어 교차 검증.
- [ ] 비동기/CDC 경로 등 타이밍 민감 회로에서는 **합의항**(consensus) 추가로 글리치 완화.

---

## 9. 연습문제

> 정답/해설이 필요하면 이어서 요청하세요(카노맵 스케치 포함해 드립니다).

1) **2변수**: \(F=\sum m(1,3)\).  
   - (a) K-map으로 SOP 최소식을 구하고,  
   - (b) POS 최소식도 구하라.

2) **3변수**: \(F=\sum m(0,2,6,7)\).  
   - (a) 4셀 묶음/2셀 묶음을 제시하고,  
   - (b) 최소식을 구하라.

3) **4변수**: \(F=\sum m(0,2,3,8,10,11,14,15)\).  
   - (a) 모든 PI를 표시하고,  
   - (b) 커버링 차트로 EPI를 찾은 뒤,  
   - (c) SOP/POS 최소식을 제시하라.

4) **DC 포함**: \(F=\sum m(1,3,5) + d(7,9)\).  
   - DC를 활용해 SOP 최소식을 구하라(K-map 묶음과 함께 설명).

5) **POS 연습**: 4변수에서 \(F=0\) 인 인덱스가 \(\{1,2,4,5\}\).  
   - K-map으로 POS 최소식을 구하고, \(\overline{F}=\sum m(\cdot)\) 를 통해 교차 검증하라.

---

## 10. 핵심 요약

- **K-map**은 **인접 1(또는 0)을 2의 거듭제곱 크기**로 최대한 크게 묶어 **리터럴 수**를 줄이는 도구.  
- **EPI**는 “나만 덮는” 1 셀이 있는 PI — **무조건 포함**.  
- 남은 셀은 **최소 개수 PI**로 커버(집합 커버).  
- **SOP/POS**를 모두 적어두면, 드모르간/보수 관계로 **검증**이 수월하다.