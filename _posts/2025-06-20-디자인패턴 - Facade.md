---
layout: post
title: 디자인패턴 - Facade
date: 2025-06-20 22:20:23 +0900
category: 디자인패턴
---
# Facade(퍼사드 패턴)

## 정의

**퍼사드 패턴(Facade Pattern)**은 복잡한 서브시스템들의 집합에 대해 **단순한 인터페이스**를 제공하여, 외부 클라이언트가 내부 구현을 몰라도 **쉽고 일관된 사용 경험**을 얻도록 만드는 **구조 패턴**이다.

> “복잡한 시스템에 대한 간단한 출입구(Facade)를 만들어준다.”

---

## 의도 (Intent)

- 여러 서브시스템(객체/모듈/서비스)을 **일관된 흐름**으로 묶어 **간단한 API**를 제공한다.
- **초기화/종료/에러 처리/리소스 관리** 같은 반복·상용구를 퍼사드가 **표준화**한다.
- 외부에서는 **결합도를 낮추고**, 내부 구조는 **캡슐화**한다.

---

## 구조 (UML)

```
┌─────────────┐
│   Client    │
└─────┬───────┘
      │  간단한 메서드 호출(오케스트레이션 요청)
      ▼
┌─────────────┐         ┌────────────┐
│   Facade    │◄───────▶│ SubSystemA │
└─────────────┘         └────────────┘
      │                 ┌────────────┐
      └────────────────▶│ SubSystemB │
                        └────────────┘
                          ...
```

- **Client**: 퍼사드를 사용하는 외부(애플리케이션/상위 계층/컨트롤러)
- **Facade**: 단순한 작업 단위 메서드 제공(흐름/예외/로그/트랜잭션 일원화)
- **SubSystems**: 실제 기능을 가진 내부 구성(서비스/모듈/드라이버)

---

## 퍼사드가 해결하는 대표 문제

- 내부 API가 **과도하게 세분화**되어 외부 사용이 어렵다.
- **초기화 순서/정리 순서**가 복잡하다(예: 장치, 네트워크, 캐시, 인증).
- **에러/재시도/타임아웃** 정책이 서브시스템마다 달라 **불균질**하다.
- 외부에 **최소 필요 API**만 노출하고 내부를 숨겨야 한다(캡슐화/보안).

---

## 구현 예시 1 — Python: 부팅 시퀀스(초안을 보강)

> 제공 예시를 유지하되, **에러 처리/타임아웃/로그**를 퍼사드에서 표준화한다.

```python
import time
from contextlib import contextmanager

# 복잡한 서브시스템

class CPU:
    def freeze(self):
        print("CPU: 동작 멈춤")
    def jump(self, position: int):
        print(f"CPU: {position} 위치로 점프")
    def execute(self):
        print("CPU: 명령어 실행")

class Memory:
    def load(self, position: int, data: str):
        print(f"Memory: {position} 위치에 {data} 로드")

class HardDrive:
    def read(self, sector: int) -> str:
        print(f"HardDrive: {sector} 섹터 읽기")
        # 실제로는 IO 오류/지연 가능
        return "OS 부트로더"

# 관측(로깅/타임) 유틸

@contextmanager
def step(name: str):
    start = time.time()
    print(f"[STEP] {name} 시작")
    try:
        yield
        print(f"[STEP] {name} 성공 ({(time.time()-start):.3f}s)")
    except Exception as e:
        print(f"[STEP] {name} 실패: {e}")
        raise

# 퍼사드

class Computer:
    def __init__(self, cpu: CPU, mem: Memory, disk: HardDrive, boot_sector=100):
        self.cpu, self.mem, self.disk = cpu, mem, disk
        self.boot_sector = boot_sector

    def start(self):
        print("[컴퓨터 부팅 시작]")
        with step("freeze"):
            self.cpu.freeze()
        with step("read boot"):
            boot_data = self.disk.read(self.boot_sector)
            if not boot_data:
                raise RuntimeError("부트로더 없음")
        with step("load boot"):
            self.mem.load(0, boot_data)
        with step("jump+execute"):
            self.cpu.jump(0)
            self.cpu.execute()
        print("[컴퓨터 부팅 완료]")

# 클라이언트

Computer(CPU(), Memory(), HardDrive()).start()
```

핵심
- **흐름/예외/로깅/시간 측정**을 퍼사드에서 **표준화**.
- 클라이언트는 `start()`만 호출하면 된다(간단한 출입구).

---

## 구현 예시 2 — Python: 결제 퍼사드(오케스트레이션)

> 장바구니 확인 → 재고 예약 → 결제 승인 → 영수증 발행 → 알림 발송

```python
class CartService:
    def validate(self, user_id, cart_id) -> dict:
        return {"total": 52000, "items": [{"sku":"A","qty":1}]}

class InventoryService:
    def reserve(self, items) -> str:  # 예약 토큰
        return "res-123"
    def release(self, token: str): ...

class PaymentGateway:
    def authorize(self, amount, card_token) -> str:  # 승인ID
        return "auth-xyz"
    def capture(self, auth_id): ...

class ReceiptService:
    def issue(self, order_id, amount): return f"R-{order_id}"

class Notifier:
    def send(self, user_id, msg): print(f"notify {user_id}: {msg}")

# 퍼사드: 결제의 복잡한 단계/롤백을 표준화

class CheckoutFacade:
    def __init__(self, cart, inv, pay, rcpt, ntf):
        self.cart, self.inv, self.pay, self.rcpt, self.ntf = cart, inv, pay, rcpt, ntf

    def checkout(self, user_id: str, cart_id: str, card_token: str) -> dict:
        order_id = f"O-{int(time.time())}"
        reservation = None
        auth_id = None
        try:
            info = self.cart.validate(user_id, cart_id)
            reservation = self.inv.reserve(info["items"])
            auth_id = self.pay.authorize(info["total"], card_token)
            self.pay.capture(auth_id)
            receipt = self.rcpt.issue(order_id, info["total"])
            self.ntf.send(user_id, f"주문 {order_id} 완료, 영수증 {receipt}")
            return {"order_id": order_id, "receipt": receipt}
        except Exception as e:
            # 표준 롤백
            if auth_id:    # 승인 취소가 있다면 호출
                pass
            if reservation:
                self.inv.release(reservation)
            self.ntf.send(user_id, f"주문 실패: {e}")
            raise
```

핵심
- **에러 시 롤백 시나리오**까지 퍼사드가 책임.
- 퍼사드는 **오케스트레이션 규칙**과 **경계 정책**을 한 곳에서 일관화.

---

## 구현 예시 3 — C#: 모듈 퍼사드(도메인 서비스 묶음)

```csharp
public interface IAuth { Task<string> EnsureUserAsync(string token); }
public interface IProfile { Task UpdateAsync(string userId, string name); }
public interface IAudit { Task RecordAsync(string userId, string action); }

public sealed class UserFacade {
    private readonly IAuth _auth;
    private readonly IProfile _profile;
    private readonly IAudit _audit;
    public UserFacade(IAuth auth, IProfile profile, IAudit audit)
    { _auth = auth; _profile = profile; _audit = audit; }

    public async Task UpdateDisplayNameAsync(string token, string newName) {
        var userId = await _auth.EnsureUserAsync(token);
        await _profile.UpdateAsync(userId, newName);
        await _audit.RecordAsync(userId, $"UpdateName:{newName}");
    }
}
```

핵심
- 상위 계층(Controller/UseCase)은 `UserFacade.UpdateDisplayNameAsync()`만 알면 된다.
- 내부 서비스 계약/흐름은 **퍼사드에 캡슐화**.

---

## 다층 퍼사드: Subsystem Facade ↔ API Facade ↔ App Facade

복잡한 시스템에서는 퍼사드가 **한 층**에만 존재하지 않는다.

- **Subsystem Facade**: 내부 모듈 경계마다(예: 인증 모듈, 렌더링 모듈) 제공.
- **API Facade**: 여러 Subsystem Facade를 아우르는 상위 퍼사드(애플리케이션 유스케이스 API).
- **App Facade**: 외부 채널(웹/모바일/API 게이트웨이)에 노출되는 최상위 계약.

```
[Client/Controller]
        │
   [API Facade]  ← 유스케이스 단위(검증/권한/트랜잭션)
   ┌─────┴─────┐
[SubsystemF1] [SubsystemF2] ...  ← 모듈 내부 복잡성 은닉
   └─ Service/Repo/Driver ...
```

장점
- **관심사 분리**: 유스케이스 정책은 위, 상세 구현은 아래.
- **교체 용이**: 서브시스템 교체도 퍼사드 계약 유지로 외부 영향 최소화.

---

## 마이크로서비스와 퍼사드

- **API Gateway**: 여러 서비스의 엔드포인트를 통합·보안·관찰. “퍼사드와 유사한 역할”이지만 **네트워크 경계**에 위치.
- **BFF(Backends For Frontends)**: 채널별(웹/모바일) 요구를 맞춘 **퍼사드형 API**.
- **앱 퍼사드**: 내부 서비스 호출 오케스트레이션(어그리게이션), 캐시/서킷브레이커/리트라이/트레이싱 표준화.

> 퍼사드는 코드 레벨(모듈 내부)에서도, 아키텍처 레벨(게이트웨이/BFF)에서도 같은 철학으로 적용된다: **“복잡성 은닉 + 간단한 진입점”**.

---

## 성능·복잡도 분석

퍼사드 호출의 평균 지연:
\[
T_{\text{facade}} = T_{\text{orchestration}} + \sum_{i=1}^{k} T_{\text{subsystem},i}
\]
- 퍼사드 자체의 오버헤드는 **오케스트레이션/검증/로깅** 정도로 작다.
- 네트워크/IO 호출이 주가 되므로 **타임아웃/리트라이/서킷브레이커** 정책이 성능을 좌우.

복잡도
- 퍼사드가 제공하는 **유스케이스 수**를 \(U\), 각 유스케이스가 호출하는 **서브시스템 수**를 평균 \(k\)라 할 때,
  문서화/테스트 비용은 대략 \(\mathcal{O}(U \cdot k)\).
- **다층 퍼사드**로 분해하면 변경 영향 범위를 축소(\(\downarrow\))할 수 있다.

---

## 테스트 전략

1) **단위 테스트(퍼사드 단위)**
   - 서브시스템을 **Mock**으로 대체 → 흐름/파라미터/예외/롤백 시퀀스 검증.
2) **계약 테스트(Contract)**
   - 퍼사드가 외부에 제공하는 **API 계약** 고정; 스키마/상태 코드/에러 메시지 규칙 검증.
3) **통합 테스트**
   - 실제 서브시스템과 연동하여 **행복 경로/에러 경로/경계값** 점검.
4) **관측 테스트(Observability)**
   - 로깅/트레이싱/메트릭이 퍼사드에서 **일관**되게 나오도록 검사.

간단 PyTest 스케치:

```python
class MockInv(InventoryService):
    def __init__(self): self.reserved=False
    def reserve(self, items): self.reserved=True; return "tok"
    def release(self, token): self.reserved=False

def test_checkout_rolls_back_on_payment_failure(monkeypatch):
    cart = CartService()
    inv = MockInv()
    pay = PaymentGateway()
    rcpt = ReceiptService()
    ntf = Notifier()

    facade = CheckoutFacade(cart, inv, pay, rcpt, ntf)

    def fail_authorize(amount, card_token): raise RuntimeError("카드 오류")
    monkeypatch.setattr(pay, "authorize", fail_authorize)

    try:
        facade.checkout("u1","c1","card")
        assert False, "예외가 발생해야 함"
    except RuntimeError:
        assert inv.reserved is False   # 롤백 검증
```

---

## 안티패턴 & 주의점

- **거대 퍼사드(God Facade)**: 모든 걸 한 클래스/모듈에 몰아넣음 → **SRP 위반**.
  - 해결: 유스케이스별/모듈별 **여러 퍼사드로 분할**하고 상위 퍼사드에서 **작게 조립**.
- **중복 퍼사드**: 팀별로 유사 퍼사드를 중복 구현 → **계약 표준화**와 공용 라이브러리화.
- **세밀 제어 상실**: 퍼사드가 너무 추상화하여 필요한 옵션이 사라짐.
  - 해결: **“간단 API + 고급 API(확장 포인트)”** 이중 노출.
- **비즈니스 로직 누수**: 퍼사드가 도메인 로직을 **과도**하게 품을 때 → 응용 서비스/도메인 레이어로 재배치.

---

## 리팩토링: 복잡한 호출 그래프 → 퍼사드

증상
- 컨트롤러/애플리케이션 서비스가 **여러 서비스/드라이버를 직접 호출**하며 **중복 흐름**이 널뛰기.
- 예외/재시도/타임아웃/로깅 정책이 **일관되지 않음**.

절차
1) 공통 시나리오(유스케이스)를 **흐름도**로 도출.
2) 해당 흐름의 **입력/출력/오류/롤백 규칙**을 명세(계약).
3) 퍼사드 클래스를 신설하고 로직 이동(서브시스템은 주입).
4) 상위 레이어는 퍼사드만 호출하도록 단순화.
5) 계약/통합 테스트 추가, 기존 중복 코드를 제거.

---

## 다른 패턴과의 조합

- **Facade + Builder**: 복잡한 생성·초기화 시나리오를 Builder로 구성하고, Builder 내부에서 Facade로 **오케스트레이션**.
- **Facade + Adapter**: 외부/레거시 API를 Adapter로 맞추고, Facade가 여러 Adapter를 조합.
- **Facade + Decorator**: 퍼사드 앞뒤로 로깅/서킷브레이커/캐시를 데코레이터 체인으로 부착(특히 마이크로서비스/BFF).
- **Facade + Mediator**: 모듈 내부 **복잡한 객체 상호작용**은 Mediator로 정리하고, 모듈 경계 바깥에는 Facade.
- **Facade + Proxy**: 원격 호출/지연 로딩/접근 제어는 Proxy로 감싸고, Facade는 **유스케이스 조립**에 집중.

---

## 사용 사례(보강)

| 사례                         | 설명 |
|------------------------------|------|
| Spring `JdbcTemplate`        | 연결/문장/예외/자원 반납을 감싸 단순한 JDBC API 제공 |
| 미디어 플레이어              | 디코더, 버퍼, 렌더러를 퍼사드로 묶어 `play(file)`만 노출 |
| 빌드/배포 도구               | 다수 플러그인/작업을 `build()`, `deploy()`로 통합 |
| 게임 엔진                     | 리소스 로더/씬 그래프/사운드 관리 초기화를 `engine.init()`로 |
| 데이터 파이프라인            | 소스→변환→싱크 단계의 조합을 `run_pipeline(cfg)`로 |
| 마이크로서비스 BFF/API GW    | 다수 서비스 호출을 채널 맞춤 응답으로 집계·정규화 |

---

## Facade vs Mediator vs Adapter (표 유지·확장)

| 패턴       | 목적                          | 관계 중심        | 위치/노출                    | 언제 쓰나 |
|------------|-------------------------------|------------------|------------------------------|----------|
| **Facade**   | 단순화(오케스트레이션 표준화) | 외부 → 내부      | 모듈/도메인 경계(API 제공)   | 복잡 흐름을 간단 API로 |
| **Mediator** | 상호작용 중재(동료 간 조정)  | 객체 ↔ 객체      | 모듈 내부(객체들의 허브)     | 객체 간 의존 얽힘 해소 |
| **Adapter**  | 인터페이스 변환(호환성)     | 외부 ↔ 외부      | 경계 사이(포맷/계약 변환)    | 레거시/써드파티 연결 |

---

## 설계 체크리스트

- 퍼사드가 **어떤 유스케이스**를 제공하는가? 입력/출력/예외 계약은 명확한가?
- 내부 서브시스템 교체 시 **퍼사드 계약**만 유지하면 외부 영향이 0인가?
- **표준 정책**(타임아웃/재시도/트랜잭션/로그/트레이싱)을 퍼사드에서 일괄 적용하는가?
- **다층 퍼사드** 필요 여부(Subsystem ↔ API ↔ App).
- **간단 API**와 **고급 API(옵션/확장 포인트)**를 구분하여 과도 추상화를 예방했는가?
- 테스트: 단위/계약/통합/관측 라인이 준비되어 있는가?

---

## 마무리

**퍼사드 패턴**은 “복잡성 은닉 + 간단한 진입점”으로 **개발자 경험과 유지보수성**을 크게 높인다.
초기화/오케스트레이션/에러 처리/정책 표준화가 필요한 곳에서 특히 빛나며, **다층 퍼사드**로 스케일할수록 변경 영향이 줄어든다.
단, 퍼사드에 모든 것을 몰아넣는 **거대 퍼사드**를 피하고, **SRP/계약/테스트/관측**을 갖춘 얇은 퍼사드들을 **의미 있는 경계**에 배치하라.
그럴 때 퍼사드는 작은 진입점으로 거대한 시스템을 **안정적으로** 움직이는 가장 효율적인 설계 축이 된다.
