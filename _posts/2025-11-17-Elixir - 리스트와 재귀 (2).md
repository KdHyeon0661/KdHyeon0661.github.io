---
layout: post
title: Elixir - 리스트와 재귀 (2)
date: 2025-11-17 14:25:23 +0900
category: Elixir
---
# 리스트 고급 패턴: map/reduce부터 실전 Enum/Stream까지

## 7.4 맵 함수 만들기 (map/2 from scratch)

### 7.4.1 가장 단순한 형태 — 비(非) 꼬리재귀 map

엑기스 버전부터 다시 보고 확장하자.

```elixir
defmodule MyMap do
  # 비-꼬리재귀(교육용)
  def map([h | t], f), do: [f.(h) | map(t, f)]
  def map([], _f),     do: []
end

iex> MyMap.map([1, 2, 3], &(&1 * 2))
[2, 4, 6]
```

핵심 원리:

1. 리스트를 `[h | t]` 로 분해한다.  
   - `h` : 현재 원소  
   - `t` : 나머지 리스트
2. `h`를 변환하여 `f.(h)`를 얻는다.
3. 나머지 `t`에 대해 **재귀 호출**로 map을 수행한다.
4. `[f.(h) | map(t, f)]` 로 새 리스트를 쌓는다.
5. 빈 리스트 `[]` 에 도달하면 재귀가 멈추고 **되돌아가며** 리스트를 다시 만든다.

실제 호출 스택을 텍스트 그림으로 보면:

```text
map([1,2,3], f)
=> [f.(1) | map([2,3], f)]
             |
             v
             [f.(2) | map([3], f)]
                          |
                          v
                          [f.(3) | map([], f)]
                                       |
                                       v
                                       []
```

재귀가 끝나고 올라올 때:

```text
map([], f)         => []
map([3], f)        => [f.(3) | []]
map([2,3], f)      => [f.(2) | [f.(3)]]
map([1,2,3], f)    => [f.(1) | [f.(2), f.(3)]]
```

이 구현은:

- 구조적으로 가장 단순하고 **읽기 쉬운** map이다.
- 다만, 입력 크기 n에 대해 **대략 n번의 스택 프레임**을 쌓는다.  
  일반적인 “앱 수준 리스트”에서는 문제가 없지만,
  - 수십만 이상의 원소,
  - 혹은 매우 깊은 재귀
  같은 상황에서는 **꼬리재귀**로 바꾸는 것이 안정적이다.

---

### 7.4.2 꼬리재귀 map — 대량 데이터 / 스트림 처리 대비

꼬리재귀 버전은 “계산을 하고 나서 **마지막에 자기 자신을 호출**”하는 형태로 작성한다.

```elixir
defmodule MyMapTR do
  def map(xs, f), do: do_map(xs, f, []) |> :lists.reverse()

  defp do_map([h | t], f, acc), do: do_map(t, f, [f.(h) | acc])
  defp do_map([], _f, acc),     do: acc
end
```

동작을 단계별로 보면:

1. `acc` 는 “지금까지의 결과 리스트”다.
2. `[h | t]` 에서 `h`를 꺼내 `f.(h)` 를 만들고, **앞에 붙인다**.
3. 다음 꼬리 `t` 와 업데이트된 `acc` 로 다시 `do_map/3` 호출.
4. `[]` 에 도달하면 `acc` 를 반환한다.
5. 마지막에 `:lists.reverse/1` 로 한 번 뒤집어 순서를 복원한다.

간단 예:

```elixir
MyMapTR.map([1, 2, 3], &(&1 * 10))

# 내부 흐름
# do_map([1,2,3], f, [])      -> do_map([2,3], f, [10])
# do_map([2,3],   f, [10])    -> do_map([3],   f, [20,10])
# do_map([3],     f, [20,10]) -> do_map([],   f, [30,20,10])
# do_map([],      f, [30,20,10]) -> [30,20,10]
# reverse -> [10,20,30]
```

시간 복잡도:

- 한 번의 순회에서 원소마다 `f.(h)` 와 cons(`[... | acc]`)  
  → **선형 시간** \(O(n)\)  
- 마지막에 한 번의 `reverse` 도 **선형** \(O(n)\)

결론:

$$
T_{\text{map\_tr}} = O(n) + O(n) = O(n)
$$

공간 측면에서:

- 각 재귀 호출에서 **새로운 스택 프레임이 필요 없을 정도로** BEAM이 꼬리호출을 최적화할 수 있다.
- 따라서 “스택 오버플로우 위험” 없이 큰 리스트도 안정적으로 처리할 수 있다.

실전에서는:

- (1) **간단**하게 쓰고 싶으면 비꼬리재귀 버전,
- (2) **대량 데이터/긴 리스트**를 자주 다루면 꼬리재귀 버전

을 상황에 맞게 선택하면 된다.  
내장 `Enum.map/2`는 내부적으로 **효율적인 구현**을 사용하므로 직접 구현보다 `Enum`을 먼저 고려하는 것이 실무 패턴이다.

---

### 7.4.3 map 합성의 융합 법칙(fusion law)

map은 “원소 독립 변환”이라는 특성 때문에, **합성(fusion)** 이 아주 잘 된다.

수학적으로:

- 함수 \(g : A \to B\), \(f : B \to C\) 가 있을 때
- 리스트 \(xs : [A]\) 에 대해,

$$
\text{map}\ f\ (\text{map}\ g\ xs) = \text{map}\ (f \circ g)\ xs
$$

여기서 \((f \circ g)(x) = f(g(x))\) 이다.

엘릭서 코드로 비교해 보면:

```elixir
xs
|> Enum.map(&g/1)
|> Enum.map(&f/1)
```

대신:

```elixir
xs
|> Enum.map(fn x -> x |> g() |> f() end)
# 또는
|> Enum.map(&(f(g(&1))))
```

로 합칠 수 있다.

**왜 중요한가?**

- 첫 번째 형태는 리스트를 **두 번 순회**한다.
- 두 번째는 **한 번만 순회**하면서 두 변환을 동시에 적용한다.

이론적으로 map의 합성은 **항상** fusion이 가능하다.  
실무에서, 긴 파이프라인에서 `Enum.map` 이 연달아 있다면:

1. 각 map이 서로 의존하지 않는 “순수 변환”인지 보고,
2. 가능하면 하나로 합쳐서 **불필요한 순회**를 줄이는 것이 좋다.

지연 평가(Stream)의 관점:

```elixir
xs
|> Stream.map(&g/1)
|> Stream.map(&f/1)
|> Enum.to_list()
```

- 여기서는 중간에 **실제 리스트가 만들어지지 않지만**,  
  최종적으로 소비될 때는 각 원소에 대해 `g` → `f` 순서로 연속 호출된다.
- 눈에 보이는 리스트는 한 번 만들어지지만,  
  내부적으로는 “한 번에 두 변환” 처리가 이뤄진다.

결론:

- Enum 기반 코드에서는 **map 두 개**를 보면 “융합 후보”로 본다.
- Stream에서는 굳이 합치지 않아도 지연 평가 덕분에 대부분 효율적이다.  
  다만 가독성 관점에서 합치는 편이 더 나을 때도 있다.

---

### 7.4.4 실전 1: 결과와 로그를 함께 만들기 (map + side log)

실무에서는 종종 “결과 리스트”와 “로그/메타데이터 리스트”를 **함께** 만들고 싶다.  
예: 변환 파이프라인에서 입력/출력을 나란히 기록하는 경우.

```elixir
defmodule MapWithLog do
  # 결과 리스트와 로그 리스트를 함께 축적
  def map_log(xs, f) do
    xs
    |> do_map(f, [], [])
    |> then(fn {ys, logs} ->
      {:ok, :lists.reverse(ys), :lists.reverse(logs)}
    end)
  end

  defp do_map([h | t], f, ys, logs) do
    y = f.(h)
    do_map(t, f, [y | ys], ["#{inspect(h)} -> #{inspect(y)}" | logs])
  end

  defp do_map([], _f, ys, logs), do: {ys, logs}
end

{:ok, ys, logs} = MapWithLog.map_log([1, 2, 3], &(&1 * &1))
# ys   = [1, 4, 9]
# logs = ["1 -> 1","2 -> 4","3 -> 9"]
```

포인트:

- `ys` 와 `logs` 두 누적기를 사용한다.
- 두 리스트 모두 **prepend + reverse** 패턴을 사용한다.
- `then/2`는 값 전체를 한 번에 후처리할 때 유용한 도우미 함수다.

이 패턴은 **배치 처리, ETL, 로그/모니터링 파이프라인**에서 그대로 활용할 수 있다.

---

### 7.4.5 실전 2: 에러 태그와 map 결합 (map + tagged tuple)

입력 중 일부에서 에러가 날 수도 있는 상황에서, map을 단순히 성공값만 모으지 말고 **성공/실패를 구분**하고 싶을 때가 많다.

```elixir
defmodule MapResult do
  def map_ok(xs, f), do: do_map(xs, f, []) |> :lists.reverse()

  defp do_map([h | t], f, acc) do
    case f.(h) do
      {:ok, y} -> do_map(t, f, [{:ok, y} | acc])
      {:error, reason} -> do_map(t, f, [{:error, {h, reason}} | acc])
    end
  end

  defp do_map([], _f, acc), do: acc
end
```

사용 예:

```elixir
defmodule Parser do
  def int(str) do
    case Integer.parse(str) do
      {n, ""} -> {:ok, n}
      _       -> {:error, :bad_int}
    end
  end
end

MapResult.map_ok(~w(10 20 x 30), &Parser.int/1)
# [
#   {:ok, 10},
#   {:ok, 20},
#   {:error, {"x", :bad_int}},
#   {:ok, 30}
# ]
```

이런 식으로 **에러 컨텍스트**(원래 입력 값)를 함께 저장해 두면,  
나중에 에러를 한꺼번에 처리/로깅할 때 유용하다.

---

## 7.5 리스트를 줄여 하나의 값으로 만들기 (reduce/fold)

### 7.5.1 reduce의 핵심 아이디어

`reduce(xs, acc0, f)` 는 **누적기 `acc`** 에 각 원소를 차례로 “접어 넣는(fold)” 함수다.

```elixir
defmodule MyReduce do
  def reduce([h | t], acc, f), do: reduce(t, f.(acc, h), f)
  def reduce([], acc, _f),     do: acc
end

iex> MyReduce.reduce([1, 2, 3], 0, &+/2)
6
```

수식으로 쓰면:

$$
\text{reduce}([x_1,x_2,\dots,x_n], a_0, f)
= f(\dots f(f(a_0, x_1), x_2)\dots, x_n)
$$

여기서:

- \(a_0\) : 시작값(initial accumulator)  
- \(f\) : 누적기와 원소를 받아 새 누적기를 만드는 이항 함수

이 패턴으로:

- 합계(sum)
- 곱(product)
- 원소 개수(count)
- 최대/최소
- 문자열 결합
- 맵/필터 구현
- 집계/통계

등 대부분의 리스트 집계 로직을 표현할 수 있다.

---

### 7.5.2 표준 파생: sum, product, count, any?/all?, join

이전 reduce 정의를 재사용해 다양한 함수를 만들어 보자.

```elixir
defmodule Folds do
  import MyReduce, only: [reduce: 3]

  def sum(xs),     do: reduce(xs, 0, &+/2)
  def product(xs), do: reduce(xs, 1, &*/2)

  def count(xs), do:
    reduce(xs, 0, fn acc, _ -> acc + 1 end)

  def any?(xs, p), do:
    reduce(xs, false, fn acc, x -> acc or p.(x) end)

  def all?(xs, p), do:
    reduce(xs, true,  fn acc, x -> acc and p.(x) end)

  def join(xs, sep \\ "") do
    case xs do
      [] ->
        ""

      [h | t] ->
        reduce(t, to_string(h), fn acc, x ->
          [acc, sep, to_string(x)]
        end)
        |> :erlang.iolist_to_binary()
    end
  end
end
```

특징:

- `sum` / `product` : 가장 직관적인 reduce 파생 예
- `count` : 원소의 값은 무시하고 누적기만 증가
- `any?` / `all?` : 논리 연산(`or` / `and`)으로 표현
- `join` : 중간 문자열을 iodata로 모아 출력(복사 최소화)

예:

```elixir
iex> Folds.sum([1,2,3,4])
10

iex> Folds.product([2,3,4])
24

iex> Folds.count(~w(a b c d e))
5

iex> Folds.any?([1,3,5,6], &(rem(&1,2)==0))
true

iex> Folds.all?([2,4,6], &(rem(&1,2)==0))
true

iex> Folds.join([1,2,3], ",")
"1,2,3"
```

---

### 7.5.3 map / filter를 reduce로 구현하기

reduce가 얼마나 일반적인지 확인하기 위해,  
`map`과 `filter`를 reduce 하나로 구현해보자.

```elixir
defmodule Derived do
  import MyReduce, only: [reduce: 3]

  def map(xs, f) do
    xs
    |> reduce([], fn x, acc -> [f.(x) | acc] end)
    |> :lists.reverse()
  end

  def filter(xs, p) do
    xs
    |> reduce([], fn x, acc ->
      if p.(x), do: [x | acc], else: acc
    end)
    |> :lists.reverse()
  end
end
```

여기서 주의할 점:

- `reduce(xs, acc, f)` 의 인자 순서를 `fn x, acc` 로 쓸지 `fn acc, x` 로 쓸지  
  통일하는 것이 좋다. 위 예제는 의도적으로 순서를 바꿔봤지만,  
  실제 코드에서는 한 스타일로 고정하는 편이 읽기 쉽다.

**요지**:

- `map`, `filter` 는 사실 더 특별한 함수가 아니라,  
  적절한 `f` 를 가진 `reduce` 의 한 특수한 경우다.
- 이런 관점은 **추상화 수준**을 올리면서도 구현을 단순하게 유지하는 데 도움이 된다.

---

### 7.5.4 foldl vs foldr (개념적 비교)

전통적인 함수형 프로그래밍에서는:

- **foldl** : 왼쪽에서부터 접는 reduce
- **foldr** : 오른쪽에서부터 접는 reduce

로 구분한다.

엘릭서의 `Enum.reduce/3` 는 기본적으로 **foldl** (좌축약)에 해당한다.

수식으로:

$$
\begin{aligned}
\text{foldl}\ f\ a_0\ [x_1,\dots,x_n]
&= f(\dots f(f(a_0, x_1), x_2), \dots, x_n) \\
\text{foldr}\ f\ a_0\ [x_1,\dots,x_n]
&= f(x_1, f(x_2, \dots f(x_n, a_0)\dots))
\end{aligned}
$$

차이점:

- **foldl** 은 “앞에서부터” 쌓아가는 느낌이고, 꼬리재귀로 구현하기 쉽다.
- **foldr** 은 “뒤에서부터” 접기 때문에, 지연 평가가 있는 언어에서는
  - 무한 리스트 처리,
  - 단락 평가,
  등에 유리하다.

엘릭서에서는:

- 지연 평가가 있는 `Stream` 을 쓰면 foldr와 비슷한 패턴 일부를 흉내낼 수 있지만,  
  일반적으로는 **foldl 스타일 reduce** 만으로도 충분히 실용적이다.

---

### 7.5.5 결합법칙과 시작값(모노이드 관점)

reduce를 안정적이고 예측 가능하게 사용하려면 **결합법칙**과 **항등원**을 의식하는 것이 좋다.

연산 \(\star\) 가 있을 때, 결합법칙은:

$$
(a \star b) \star c = a \star (b \star c)
$$

항등원 \(e\) 는:

$$
e \star a = a \star e = a
$$

예:

- 숫자 덧셈:  
  - \(\star = +\), \(e = 0\)  
  - 결합적, 항등원 존재 → 문제 없음.
- 리스트 연결:  
  - \(\star = ++\), \(e = []\)  
  - 결합적, 항등원 존재.

이런 연산은 reduce에 넣어도:

- 순회 순서가 바뀌어도 결과가 같고,
- 빈 리스트에 대해서도 **직관적인 의미**가 있다.

반대로, 비결합적 연산(예: 실수에서 부동소수점 덧셈의 정밀도 문제, 뺄셈 등)은:

- reduce 순서에 따라 결과가 달라질 수 있다.
- 병렬 처리/분할 정복에서 위험해질 수 있다.

실무 요령:

- `reduce` 로 집계를 설계할 때, 가능하면 **결합적 연산 + 항등원** 조합으로 만들려고 노력한다.
- 그렇지 않은 경우에는 “순서 의존”임을 코드/주석에서 분명히 드러내야 한다.

---

### 7.5.6 scan(부분합/중간결과 노출)

`scan` 은 reduce와 비슷하지만, **각 단계의 누적값을 모두 리스트로 돌려주는 함수**다.

```elixir
defmodule MyScan do
  def scan(xs, acc0, f),
    do: do_scan(xs, acc0, f, []) |> :lists.reverse()

  defp do_scan([h | t], acc, f, out) do
    acc2 = f.(acc, h)
    do_scan(t, acc2, f, [acc2 | out])
  end

  defp do_scan([], _acc, _f, out),
    do: out
end

iex> MyScan.scan([1,2,3,4], 0, &+/2)
[1, 3, 6, 10]
```

용도:

- 누적 합/누적 평균/누적 최대값 등 **시계열 대시보드**에서 중간 값을 모두 보고 싶을 때.
- 스트리밍 상황에서 “지금까지의 상태”를 한 단계씩 출력할 때.

예: 단순 누적 평균

```elixir
defmodule RunningAvg do
  def avg(xs) do
    xs
    |> Enum.reduce({0, 0, []}, fn x, {sum, cnt, out} ->
      sum2 = sum + x
      cnt2 = cnt + 1
      avg  = sum2 / cnt2
      {sum2, cnt2, [avg | out]}
    end)
    |> elem(2)
    |> :lists.reverse()
  end
end

RunningAvg.avg([1,2,3,4])
# [1.0, 1.5, 2.0, 2.5]
```

이 예제도 사실상 “수동 scan”의 한 형태다.

---

## 7.6 더 복잡한 리스트 패턴

앞에서는 머리/꼬리와 단순 재귀 위주의 패턴을 봤다.  
이제 **다중 요소, 가드, 그룹핑, 키워드, 중첩 리스트** 등 좀 더 복잡한 리스트 패턴들을 정리한다.

---

### 7.6.1 다중 요소·가드 결합

함수 헤드에서 **여러 원소와 가드**를 같이 쓰면,  
분기 로직을 **본문이 아니라 “계약층”에서 처리**할 수 있다.

```elixir
defmodule Pattern do
  # 앞의 두 원소를 보고 분기
  def classify([0, 0 | _]), do: :double_zero
  def classify([0 | _]),    do: :leading_zero

  def classify([a, b | _]) when a < b, do: :asc_head
  def classify(_), do: :other
end
```

사용 예:

```elixir
Pattern.classify([0,0,1,2]) # :double_zero
Pattern.classify([0,1])     # :leading_zero
Pattern.classify([1,2,3])   # :asc_head
Pattern.classify([3,1])     # :other
```

장점:

- 복잡한 분기를 `case` 안에 여러 줄로 쓰는 대신,  
  **함수 헤드에 조건을 모두 올려서** 코드가 짧고 읽기 쉬워진다.
- “이 함수는 어떤 리스트 패턴을 받는가?”가 함수 정의만 봐도 명확하다.

---

### 7.6.2 슬라이딩 윈도우(고정 길이 2, 일반 k)

앞에서 간단히 2개짜리 윈도우를 봤다. 다시 정리하면:

```elixir
defmodule Window2 do
  def pairs([a, b | t]), do: [[a, b] | pairs([b | t])]
  def pairs(_),          do: []
end

iex> Window2.pairs([1,2,3,4])
[[1,2],[2,3],[3,4]]
```

일반적인 길이 `k`에 대해서는 로직이 조금 더 복잡해지지만,  
아이디어는 같다: “앞에서 `k`개를 떼고, 한 칸 이동한 리스트에 대해 재귀”.

---

### 7.6.3 그룹핑: 런-길이 인코딩(RLE)

인접한 동일 원소를 `(값, 반복 횟수)`로 묶는 RLE 예제를 다시 자세히 보자.

```elixir
defmodule RLE do
  def encode(xs),
    do: do_encode(xs, nil, 0, []) |> :lists.reverse()

  # 현재 원소 h가 이전(prev)와 같으면 count 증가
  defp do_encode([h | t], h, n, acc),
    do: do_encode(t, h, n + 1, acc)

  # h != prev 이고, 이전 그룹이 있다면 이전 그룹을 acc에 추가 후 새 그룹 시작
  defp do_encode([h | t], prev, n, acc) when n > 0,
    do: do_encode(t, h, 1, [{prev, n} | acc])

  # 처음 시작 (prev = nil, n = 0)
  defp do_encode([h | t], nil, 0, acc),
    do: do_encode(t, h, 1, acc)

  # 입력이 끝났고, 현재 그룹이 있으면 acc에 추가
  defp do_encode([], prev, n, acc) when n > 0,
    do: [{prev, n} | acc]

  # 완전히 빈 입력([]) 처리
  defp do_encode([], _prev, 0, acc),
    do: acc
end

iex> RLE.encode(~w(a a a b b c c c c))
[{"a", 3}, {"b", 2}, {"c", 4}]
```

포인트:

- “현재 보고 있는 그룹”을 `(prev, n)` 으로 표현한다.
- 새로운 원소 `h`가 들어왔을 때 상황:
  - `h == prev` → `n + 1`
  - `h != prev` → 이전 그룹을 acc에 넣고 새 그룹 시작
- 끝에 도달했을 때, 마지막 그룹을 acc에 넣는 것을 잊지 않는다.

이런 패턴은 로그 압축, 통계 사전 구축 등에서 자주 쓰인다.

---

### 7.6.4 키워드 리스트와 패턴

키워드 리스트는 **튜플의 리스트**이자 **특별 취급되는 리스트**다.

```elixir
iex> opts = [timeout: 3000, pool: :default]
[timeout: 3000, pool: :default]
iex> is_list(opts)
true
iex> hd(opts)
{:timeout, 3000}
```

가장 앞에 특정 옵션이 있는지 **패턴**으로 빠르게 검사할 수 있다.

```elixir
defmodule Kw do
  def timeout(opts) do
    case opts do
      [timeout: t | _] when is_integer(t) -> t
      _ -> 1000
    end
  end
end

Kw.timeout(timeout: 3000, pool: :x) # 3000
Kw.timeout(pool: :x)                # 1000
```

내장 `Keyword.get/3` 를 쓰면 조금 더 단순하게 쓸 수 있지만,  
패턴을 사용하면 “앞에서 우선하는” 키워드 리스트의 특성(첫 키 우선)을 더 명시적으로 드러낼 수 있다.

---

### 7.6.5 부적절 리스트를 안전하게 감지

부적절 리스트 문제는 앞에서 설명했다.  
이를 **자동으로 탐지**하려면, `:lists.reverse/1` 를 이용한 간단한 방법이 있다.

```elixir
defmodule Safe do
  def proper?(list) when is_list(list) do
    try do
      _ = :lists.reverse(list)
      true
    catch
      :error, _ -> false
    end
  end

  def proper?(_), do: false
end
```

다만, 예외를 쓰지 않고 간단하게 검사하고 싶다면,  
리스트를 순회하면서 “tail이 리스트인지”를 계속 확인하는 함수도 만들 수 있다.

```elixir
defmodule Safe2 do
  def proper?(list) when is_list(list), do: do_proper?(list)
  def proper?(_), do: false

  defp do_proper?([_h | t]) when is_list(t), do: do_proper?(t)
  defp do_proper?([]), do: true
  defp do_proper?(_),  do: false
end
```

---

### 7.6.6 중첩 리스트 평탄화(flatten)

교육용 flatten 구현:

```elixir
defmodule Flat do
  def flatten([h | t]), do: flatten(h) ++ flatten(t)
  def flatten([]),      do: []
  def flatten(x),       do: [x]
end

iex> Flat.flatten([1, [2, [3]], 4])
[1, 2, 3, 4]
```

이 구현은 간단하지만, `++`를 다량 사용하기 때문에 **성능상 그리 좋지 않다**.  
실무에서는 최적화된 `List.flatten/1` 을 쓰는 것이 좋다.

그래도 이 코드가 유용한 이유:

- “리스트/원소”를 재귀적으로 구분하는 패턴을 체득하기에 좋다.
- 중첩 구조를 어떻게 걷어낼 수 있는지 감각을 길러준다.

---

## 7.7 리스트 모듈 실전 (List / Enum / Stream)

이제 표준 라이브러리 차원에서 **List / Enum / Stream** 이 어떤 역할을 하는지 정리한다.

---

### 7.7.1 List vs Enum vs Stream — 역할 비교

| 모듈  | 대상                      | 특징                                            |
|-------|---------------------------|-------------------------------------------------|
| List  | “진짜 리스트”             | 연결 리스트 특성에 의존하는 연산들             |
| Enum  | 모든 열거 가능(enumerable) | 리스트, 맵, 범위, 스트림 등 → 공통 연산 제공   |
| Stream| 지연(lazy) 열거           | 변환 파이프라인 정의, 최종 소비 시 한 번에 평가 |

- `List` 모듈은 **연결 리스트 구조를 알고 있는 함수**들이 모여 있다.  
  예: `List.first/1`, `List.last/1`, `List.keyfind/4`, `List.foldl/3` 등.
- `Enum` 모듈은 **프로토콜 기반**으로, `Enumerable` 구현체들을 대상로 한다.  
  즉, 리스트뿐 아니라 **맵, 범위, 파일 스트림, 커스텀 컬렉션**도 모두 `Enum.map/2` 등을 쓸 수 있다.
- `Stream` 은 “**계산을 나중으로 미루는** 변환자”다.  
 최종적으로 `Enum.to_list/1`, `Enum.sum/1` 같은 함수를 호출할 때 실제로 평가된다.

---

### 7.7.2 List 주요 함수와 주의점

몇 가지 대표 함수를 예제로 살펴보자.

```elixir
# ++ / -- : 연결과 차집합(첫 일치만 제거)
[1, 2, 3] ++ [4]         # [1, 2, 3, 4]
[1, 2, 3, 2] -- [2]      # [1, 3, 2] (첫 번째 2만 제거)

# keyfind / keydelete : 튜플 리스트에서 키 기반 접근
List.keyfind([{:a, 1}, {:b, 2}], :b, 0)     # {:b, 2}
List.keydelete([{:a, 1}, {:b, 2}], :a, 0)   # [{:b, 2}]

# first / last
List.first([1, 2, 3])     # 1
List.last([1, 2, 3])      # 3

# foldl : 왼쪽에서부터 접기
List.foldl([1, 2, 3], 0, &+/2)  # 6
```

중요한 주의점:

- `++` 는 왼쪽 리스트를 **복제**한다.  
  반복해서 사용하면 \(O(n^2)\) 비용이 발생할 수 있다.
- `--` 는 “차집합”이 아니라, **왼쪽 리스트에서 오른쪽 리스트의 원소를 순서대로 제거**하는 연산이다.  
  특히, 동일한 값을 여러 번 제거할 때 “몇 개가 지워지는지”를 정확히 알고 사용해야 한다.

---

### 7.7.3 Enum 대표 함수들 (리스트 외 전체 컬렉션)

```elixir
Enum.map(1..5, &(&1 * 2))
Enum.filter(1..10, &(rem(&1,2)==0))
Enum.reduce(1..5, 0, &+/2)

Enum.frequencies(~w(a a b c c c))
# %{"a" => 2, "b" => 1, "c" => 3}

Enum.sort_by([{:a,2},{:a,1}], fn {_,v} -> v end)
# [a: 1, a: 2]

Enum.group_by(["kim","lee","kang"], &String.first/1)
# %{"k" => ["kim","kang"], "l" => ["lee"]}

Enum.chunk_every(1..10, 3, 3, :discard)
# [[1,2,3],[4,5,6],[7,8,9]]
```

요약:

- `Enum.frequencies/1` : 리스트를 “값 → 빈도” 맵으로 만들어주는 집계기
- `Enum.group_by/2` : “키 함수(f)”에 따라 원소들을 그룹별로 묶는다.
- `Enum.chunk_every/4` : 리스트를 고정 크기 배치로 나누고, 남는 부분 처리 방법 선택 가능.

이 함수들은 **로그 분석**, **배치 처리**, **간단 통계**를 구현할 때 매우 유용하다.

---

### 7.7.4 Stream으로 메모리 효율화

`Enum` 은 매 단계마다 실제 리스트를 만들지만, `Stream` 은 **계산을 미루고** “레시피만 만든다”.

```elixir
Stream.iterate(0, &(&1 + 1))
|> Stream.map(&(&1 * 2))
|> Enum.take(5)
# [0, 2, 4, 6, 8]
```

여기서:

- `Stream.iterate/2` : 무한 시퀀스를 정의한다.
- `Stream.map/2` : “변환해야 한다”는 사실만 기억한다.
- `Enum.take/2` : 실제로 앞에서부터 5개만 가져오면서 전체를 평가한다.

장점:

- 큰 데이터를 처리할 때 **중간 리스트를 만들지 않는다**.
- 파일이나 네트워크 스트림처럼 끝을 모르는 입력에도 잘 맞는다.

실전 예: 파일 줄 단위 처리

```elixir
File.stream!("large.log")
|> Stream.map(&String.trim/1)
|> Stream.reject(&(&1 == ""))
|> Stream.map(&Log.parse_line/1)
|> Enum.frequencies_by(fn {level, _} -> level end)
```

- `File.stream!/1` 은 파일을 한 줄씩 lazily 읽는다.
- 중간 변환은 전부 `Stream` 으로 연결.
- 마지막 `Enum.frequencies_by/2` 에서 전체를 한 번만 순회하며 동작.

---

### 7.7.5 iodata와 리스트: 출력 효율 최적화

앞에서 HTML 리스트 예제로 iodata를 봤다. 한 번 더 정리하자.

```elixir
defmodule Html do
  def ul(items) do
    [
      "<ul>\n",
      for it <- items do
        ["  <li>", it, "</li>\n"]
      end,
      "</ul>\n"
    ]
    |> :erlang.iolist_to_binary()
  end
end

Html.ul(["A", "B"])
# "<ul>\n  <li>A</li>\n  <li>B</li>\n</ul>\n"
```

포인트:

- `iolist` 는 “바이너리 또는 바이너리/리스트의 중첩 리스트”이다.
- `iolist_to_binary/1` 는 이 구조를 **한 번에 평탄화**해 하나의 바이너리를 만든다.
- 반복적인 문자열 결합 대신, **리스트 구조를 조작**하는 것이 훨씬 효율적이다.

서버 측 템플릿 엔진, 로그 포맷터, 바이너리 프로토콜 인코더 등에서  
이 패턴을 사용하는 것은 매우 일반적이며, 고성능 코드에서 중요한 요소다.

---

### 7.7.6 실전 스니펫: 로그 파서(라인→구조→집계)

리스트/Enum/Stream의 조합 예로 간단한 로그 파서를 보자.

```elixir
defmodule Log do
  @spec parse_line(String.t()) :: {String.t(), String.t()} | {:unknown, String.t()}
  def parse_line("[" <> rest) do
    # 포맷: [LEVEL] message
    case String.split(rest, "] ", parts: 2) do
      [level, msg] ->
        {String.trim_leading(level), msg}

      _ ->
        {:unknown, rest}
    end
  end

  def parse_line(line), do: {:unknown, line}

  @spec stats([String.t()]) :: map()
  def stats(lines) do
    lines
    |> Enum.map(&parse_line/1)
    |> Enum.reject(&match?({:unknown, _}, &1))
    |> Enum.frequencies_by(fn {lvl, _} -> lvl end)
  end
end

iex> Log.stats(["[INFO] ok","[ERROR] bad","oops"])
%{"ERROR" => 1, "INFO" => 1}
```

이 예제는 다음과 같은 패턴을 모두 사용한다:

- 리스트/범위/파일 → `Enum` 변환 파이프라인
- 패턴매칭으로 행 파싱
- `Enum.frequencies_by/2` 로 그룹별 개수 집계

---

## 7.8 리스트와 친해지기 (Idioms, Pitfalls, Exercises)

마지막으로, 리스트를 다룰 때 자주 등장하는 **관용구(idiom)** 와 **함정**,  
그리고 연습 문제들을 정리한다.

---

### 7.8.1 필살기 요약

1. **prepend + reverse**

   - 리스트 생성/변환 시 표준 패턴:
     - 각 단계에서 `[x | acc]` 로 **앞에 붙인다**.
     - 마지막에 한 번만 `:lists.reverse(acc)` 로 순서를 맞춘다.

2. **누적기(acc)**

   - 재귀에서 “지금까지의 상태”를 들고 다니는 최소 단위.
   - 숫자, 맵, 리스트, 튜플 등 무엇이든 될 수 있다.
   - 여러 누적기(예: `sum`, `count`, `logs`)를 튜플로 묶어 들고 다니는 것도 일반적이다.

3. **패턴 헤드 계약**

   - 복잡한 분기/제약 조건은 가능하면 함수 헤드에서 처리한다.
   - `def f([0,0|_]), def f([0|_]), def f([a,b|_]) when a < b` 식의  
     “모양 + 가드” 조합으로 계약을 명시한다.

4. **iodata**

   - 문자열/바이너리 결합 시 **반드시 고려해야 하는 패턴**.
   - 많은 조각을 반복해서 `<>` 로 이어 붙이지 말고,  
     리스트 구조에 넣고 마지막에 `iolist_to_binary/1` 로 변환.

5. **Enum vs Stream**

   - 데이터가 크지 않고 단순하면 `Enum`으로 충분.
   - 매우 큰 컬렉션/파일/네트워크 스트림을 다루거나,  
     무한 시퀀스를 모델링할 때는 `Stream`을 사용.

6. **++ / -- 남용 금지**

   - `acc ++ [x]` 를 루프 안에서 사용하면 \(O(n^2)\)로 망가지기 쉽다.
   - `--` 는 “모든 x 제거”가 아니라, 오른쪽 리스트의 각 원소를  
     **왼쪽 리스트에서 첫 일치만 제거**하는 연산이다.

---

### 7.8.2 흔한 함정 → 교정 예제

1) 루프 내 `acc ++ [x]`

```elixir
def bad(n) do
  Enum.reduce(1..n, [], fn i, acc -> acc ++ [i] end)
end

def good(n) do
  1..n
  |> Enum.reduce([], fn i, acc -> [i | acc] end)
  |> :lists.reverse()
end
```

- `bad/1` : 각 단계마다 `acc` 전체를 복사 → \(O(n^2)\)
- `good/1` : 각 단계는 \(O(1)\), 마지막에 \(O(n)\) → 전체 \(O(n)\)

2) 빈 리스트 미처리

```elixir
# 위험한 코드
def head_plus_one(xs), do: hd(xs) + 1

# 안전한 코드
def safe_head_plus_one([]), do: :error
def safe_head_plus_one([h | _]), do: {:ok, h + 1}
```

- `hd/1` 는 빈 리스트에서 예외를 던진다.
- 대부분의 공용 함수에서는 빈 리스트에 대해 **명시적으로 절**을 추가해야 한다.

3) 부적절 리스트 생성

```elixir
# 위험: 꼬리가 리스트가 아님
[1 | 2]

# 안전: 항상 꼬리가 리스트
[1 | [2 | []]]   # == [1,2]
```

부적절 리스트는 대부분의 라이브러리 함수가 가정하는 구조가 아니므로,  
의도적으로 사용하는 경우가 아니라면 피하는 것이 좋다.

4) 불필요한 중간 리스트

```elixir
# 불필요한 중간 리스트 생성
data
|> Enum.map(&f/1)
|> Enum.map(&g/1)

# 융합
data
|> Enum.map(&(g(f(&1))))
```

또는 Stream으로:

```elixir
data
|> Stream.map(&f/1)
|> Stream.map(&g/1)
|> Enum.to_list()
```

---

### 7.8.3 성능 메모(간단 수식)

연결 리스트에서 “뒤에 붙이기” 반복은 누적 복제로 인해 평균 비용이 커진다.

루프마다 `acc ++ [x]` 를 하면:

$$
T(n) \approx 1 + 2 + \dots + n = \frac{n(n+1)}{2} = O(n^2)
$$

반면 `prepend + reverse` 패턴은:

- 각 단계: \(O(1)\)
- 마지막 reverse: \(O(n)\)

따라서 전체 비용:

$$
T_{\text{prepend\_reverse}}(n) = O(n)
$$

---

### 7.8.4 연습 문제 (해설 스케치 포함)

연습을 통해 7.4~7.7 내용을 고정해보자.

#### (1) `flat_map/2` 직접 구현

정의:

- 입력: 리스트 `xs`, 함수 \(f : a \to [b]\)
- 출력: 각 원소에 `f`를 적용하고, 결과 리스트들을 **평탄화**한 리스트

```elixir
defmodule X do
  def flat_map(xs, f),
    do: do_flat_map(xs, f, []) |> :lists.reverse()

  defp do_flat_map([h | t], f, acc) do
    ys = f.(h)
    # ys를 acc 앞에 붙인다 (역순으로)
    acc2 =
      Enum.reduce(ys, acc, fn y, a ->
        [y | a]
      end)

    do_flat_map(t, f, acc2)
  end

  defp do_flat_map([], _f, acc), do: acc
end

X.flat_map([1, 2, 3], fn x -> [x, x] end)
# [1, 1, 2, 2, 3, 3]
```

#### (2) `chunk_every/2` (마지막 조각 포함)

```elixir
defmodule Chunk do
  def every(xs, k), do: do_every(xs, k, [], []) |> :lists.reverse()

  defp do_every([h | t], k, cur, acc) when length(cur) + 1 == k do
    chunk = [h | cur] |> :lists.reverse()
    do_every(t, k, [], [chunk | acc])
  end

  defp do_every([h | t], k, cur, acc) do
    do_every(t, k, [h | cur], acc)
  end

  defp do_every([], _k, [], acc), do: acc

  defp do_every([], _k, cur, acc),
    do: [:lists.reverse(cur) | acc]
end
```

#### (3) 인접 중복 축약 `dedup/1`

```elixir
defmodule Dedup do
  def run([]), do: []

  def run([h | t]),
    do: do_run(t, h, [h]) |> :lists.reverse()

  defp do_run([h | t], last, acc) when h == last,
    do: do_run(t, last, acc)

  defp do_run([h | t], _last, acc),
    do: do_run(t, h, [h | acc])

  defp do_run([], _last, acc),
    do: acc
end

Dedup.run([:a,:a,:b,:b,:b,:c])
# [:a,:b,:c]
```

#### (4) 병합 정렬의 병합 단계 `merge_sorted/2`

```elixir
defmodule Merge do
  def merge([a | as], [b | bs]) when a <= b,
    do: [a | merge(as, [b | bs])]

  def merge([a | as], [b | bs]),
    do: [b | merge([a | as], bs)]

  def merge([], bs), do: bs
  def merge(as, []), do: as
end

Merge.merge([1,3,5], [2,4,6])
# [1,2,3,4,5,6]
```

#### (5) `zip_with/3` — 두 리스트를 합성 함수로 결합

```elixir
defmodule Zip do
  def with([a | as], [b | bs], f),
    do: [f.(a, b) | with(as, bs, f)]

  def with(_, _, _), do: []
end

Zip.with([1,2,3], [10,20,30], &+/2)
# [11,22,33]
```