---
layout: post
title: Spring - 외부 연동 & 통신
date: 2025-10-21 14:25:23 +0900
category: Spring
---
# 18. 외부 연동 & 통신 — RestClient/WebClient, Resilience4j, gRPC, 파일·웹훅 콜백 패턴

> 목표: 스프링에서 **HTTP/비동기 외부 통신**을 안정적으로 다루는 규범을 한 번에 정리한다.  
> 범위: **RestClient/WebClient 베스트 프랙티스**, **Resilience4j(서킷 브레이커/리트라이/레이트리밋/벌크헤드/타임리밋)**, **gRPC 요약(프로토콜/보안/스트리밍)**, **파일 업/다운·웹훅 콜백 패턴**.  
> 전제: Spring Boot 3.3+, Java 21.

---

## A. HTTP 클라이언트 — RestClient & WebClient

### A-1. 선택 기준
- **RestClient (Spring 6)**: 동기식, RestTemplate의 현대화(플루언트 API/테스트 편의). **JDBC 중심 MVC** 백엔드에서 단순 외부 호출에 적합.
- **WebClient**: 논블로킹, **WebFlux**/고성능 팬아웃에 적합. I/O-bound 대량 동시성에 강함.
- 공통: **타임아웃/재시도/표준 헤더/관측(메트릭/로그/traceId)**를 **빌더 한 곳**에서 강제.

---

### A-2. RestClient 베스트 프랙티스

#### 의존성 / 설정
```kotlin
dependencies {
  implementation("org.springframework.boot:spring-boot-starter-web") // RestClient 포함
  implementation("io.micrometer:micrometer-observation")
}
```

#### 공통 빌더
```java
@Configuration
class RestClients {

  @Bean
  RestClient externalRestClient(RestClient.Builder b) {
    return b
      .baseUrl("https://api.example.com")
      .defaultHeaders(h -> {
        h.setAccept(List.of(MediaType.APPLICATION_JSON));
        h.set(HttpHeaders.USER_AGENT, "acme-api/1.0");
      })
      .requestInterceptor((req, body, ex) -> {
        // traceId 전파
        Optional.ofNullable(MDC.get("traceId")).ifPresent(id -> req.getHeaders().add("X-Trace-Id", id));
      })
      .connectTimeout(Duration.ofSeconds(2))
      .readTimeout(Duration.ofSeconds(3))
      .build();
  }
}
```

#### 사용 + 오류 매핑 + 제네릭
```java
@Service
@RequiredArgsConstructor
class CatalogClient {
  private final RestClient rest;

  public Product getProduct(String id) {
    return rest.get().uri("/v1/products/{id}", id)
      .accept(MediaType.APPLICATION_JSON)
      .retrieve()
      .onStatus(HttpStatusCode::is4xxClientError, (req, res) -> {
        if (res.getStatusCode() == HttpStatus.NOT_FOUND) return new NotFoundException("product "+id);
        return new BadRequestException("client error");
      })
      .onStatus(HttpStatusCode::is5xxServerError, (req, res) -> new UpstreamException("upstream 5xx"))
      .body(Product.class);
  }

  public PageResult<Product> search(String q, int page, int size) {
    ParameterizedTypeReference<PageResult<Product>> type = new ParameterizedTypeReference<>(){};
    return rest.get().uri(uri -> uri.path("/v1/products")
        .queryParam("q", q).queryParam("page", page).queryParam("size", size).build())
      .retrieve().body(type);
  }
}
```

#### 파일 다운로드(스트리밍)
```java
public Path download(String url) {
  Path temp = Files.createTempFile("dl-", ".bin");
  rest.get().uri(url).retrieve()
    .toEntity(InputStream.class)
    .ifPresent(resp -> {
      try (var in = resp.getBody(); var out = Files.newOutputStream(temp)) {
        in.transferTo(out);
      } catch (IOException e) { throw new UncheckedIOException(e); }
    });
  return temp;
}
```

> 규범
> - 타임아웃은 **연결/읽기** 분리.
> - **에러 모델 통일**: Upstream 예외 → 로컬 `UpstreamException(code, bodySnippet)` 매핑.
> - 요청·응답 본문 로깅은 **금지**(샘플링·마스킹·사이즈 제한).

---

### A-3. WebClient 베스트 프랙티스

#### 의존성 / 커넥터
```kotlin
dependencies { implementation("org.springframework.boot:spring-boot-starter-webflux") }
```

```java
@Configuration
class WebClients {

  @Bean
  WebClient webClient() {
    HttpClient http = HttpClient.create()
      .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 2000)
      .responseTimeout(Duration.ofSeconds(3))
      .resolver(DefaultAddressResolverGroup.INSTANCE); // DNS 튜닝(선택)

    return WebClient.builder()
      .baseUrl("https://api.example.com")
      .clientConnector(new ReactorClientHttpConnector(http))
      .defaultHeaders(h -> {
        h.setAccept(List.of(MediaType.APPLICATION_JSON));
        h.set(HttpHeaders.USER_AGENT, "acme-api/1.0");
      })
      .filter((req, next) -> {
        // traceId
        var b = ClientRequest.from(req);
        Optional.ofNullable(MDC.get("traceId")).ifPresent(id -> b.header("X-Trace-Id", id));
        return next.exchange(b.build());
      })
      .build();
  }
}
```

#### 사용 + 재시도 + 타임아웃 + 페일패스트
```java
@Service @RequiredArgsConstructor
class RxCatalogClient {
  private final WebClient wc;

  public Mono<Product> getProduct(String id) {
    return wc.get().uri("/v1/products/{id}", id).retrieve()
      .onStatus(s -> s.value()==404, resp -> Mono.error(new NotFoundException("product "+id)))
      .bodyToMono(Product.class)
      .timeout(Duration.ofSeconds(4))
      .retryWhen(Retry.backoff(2, Duration.ofMillis(200)).jitter(0.2)
        .filter(ex -> ex instanceof IOException || ex instanceof TimeoutException));
  }

  public Flux<Product> searchMany(List<String> ids) {
    return Flux.fromIterable(ids)
      .flatMap(this::getProduct, /*concurrency*/ 16) // 팬아웃
      .onErrorContinue((ex, v) -> log.warn("skip {} due to {}", v, ex.toString()));
  }
}
```

> 규범
> - **`retrieve()` + `onStatus`**로 상태코드 별 처리.
> - 재시도는 **idempotent** 요청에만, **지터** 필수.
> - **boundedElastic**는 블로킹 우회 시에만.

---

## B. Resilience4j — CircuitBreaker, Retry, RateLimiter, Bulkhead, TimeLimiter

### B-1. 의존성 & 자동설정
```kotlin
dependencies {
  implementation("io.github.resilience4j:resilience4j-spring-boot3")
  implementation("io.github.resilience4j:resilience4j-micrometer")
}
```

### B-2. YAML 구성(샘플)
```yaml
resilience4j:
  circuitbreaker:
    configs:
      default:
        sliding-window-type: COUNT_BASED
        sliding-window-size: 50
        failure-rate-threshold: 50
        slow-call-rate-threshold: 50
        slow-call-duration-threshold: 1s
        permitted-number-of-calls-in-half-open-state: 5
        wait-duration-in-open-state: 10s
        record-exceptions:
          - java.io.IOException
          - java.util.concurrent.TimeoutException
    instances:
      catalog:
        base-config: default
  retry:
    instances:
      catalog:
        max-attempts: 3
        wait-duration: 200ms
        retry-exceptions:
          - java.io.IOException
          - java.util.concurrent.TimeoutException
  ratelimiter:
    instances:
      catalog:
        limit-for-period: 50
        limit-refresh-period: 1s
        timeout-duration: 0
  bulkhead:
    instances:
      catalog:
        max-concurrent-calls: 50
        max-wait-duration: 0
  timelimiter:
    instances:
      catalog:
        timeout-duration: 2s
```

### B-3. 애너테이션 조합(싱크)
```java
@Service
@RequiredArgsConstructor
class SafeCatalogClient {

  private final RestClient rest;

  @TimeLimiter(name="catalog")     // Future/CompletionStage 대상
  @CircuitBreaker(name="catalog", fallbackMethod="fallback")
  @Retry(name="catalog")
  @RateLimiter(name="catalog")
  @Bulkhead(name="catalog", type = Bulkhead.Type.SEMAPHORE)
  public CompletableFuture<Product> get(String id) {
    return CompletableFuture.supplyAsync(() ->
      rest.get().uri("/v1/products/{id}", id)
          .retrieve().body(Product.class));
  }

  private CompletableFuture<Product> fallback(String id, Throwable ex) {
    log.warn("catalog fallback for {}: {}", id, ex.toString());
    return CompletableFuture.completedFuture(Product.placeholder(id));
  }
}
```

### B-4. WebClient와 프로그래매틱 조합(리액티브)
```java
@Service @RequiredArgsConstructor
class RxSafeCatalogClient {
  private final WebClient wc;
  private final CircuitBreaker cb = CircuitBreaker.ofDefaults("catalog");
  private final Retry retry = Retry.ofDefaults("catalog");

  public Mono<Product> get(String id) {
    return wc.get().uri("/v1/products/{id}", id).retrieve().bodyToMono(Product.class)
      .transformDeferred(CircuitBreakerOperator.of(cb))
      .transformDeferred(RetryOperator.of(retry));
  }
}
```

### B-5. 운영 팁
- **에러 분류**: HTTP 4xx는 보통 **실패**로 기록하지 않거나 리트라이 제외. 5xx/네트워크/타임아웃만 리트라이.
- **메트릭**: `resilience4j_circuitbreaker_state`, 실패율, 슬라이딩 윈도우 내 호출수. 알람 트리거.
- **벌크헤드**: 호출 폭주 차단(다운스트림 보호). 상위에 **큐/콜랩스**가 더 경제적일 때도.

---

## C. gRPC 요약 — 언제, 어떻게

### C-1. 왜 gRPC?
- **바이너리(ProtoBuf)** + HTTP/2: **낮은 오버헤드**·**양방향 스트리밍**·**헤더 압축**.
- 내부 마이크로서비스 간 **고성능** RPC가 필요할 때 적합. 외부 공개 API는 여전히 **HTTP+JSON**이 호환성↑.

### C-2. 기본 구성(자바/스프링)
#### Gradle
```kotlin
plugins {
  id("com.google.protobuf") version "0.9.4"
  id("java")
}
dependencies {
  implementation("io.grpc:grpc-netty-shaded:1.66.0")
  implementation("io.grpc:grpc-protobuf:1.66.0")
  implementation("io.grpc:grpc-stub:1.66.0")
  implementation("org.slf4j:slf4j-api:2.0.13")
}
protobuf {
  protoc { artifact = "com.google.protobuf:protoc:3.25.3" }
  plugins {
    id("grpc") { artifact = "io.grpc:protoc-gen-grpc-java:1.66.0" }
  }
  generateProtoTasks {
    all().forEach { task -> task.plugins { id("grpc") } }
  }
}
```

#### .proto
```proto
syntax = "proto3";
package catalog.v1;

service Catalog {
  rpc Get (GetRequest) returns (Product);
  rpc StreamPrices (PriceRequest) returns (stream PriceTick);
}

message GetRequest { string id = 1; }
message Product { string id = 1; string name = 2; int64 price = 3; }
message PriceRequest { repeated string ids = 1; }
message PriceTick { string id = 1; int64 price = 2; int64 ts = 3; }
```

#### 서버 구현
```java
public class CatalogService extends CatalogGrpc.CatalogImplBase {
  @Override
  public void get(GetRequest req, StreamObserver<Product> obs) {
    Product p = Product.newBuilder().setId(req.getId()).setName("Item").setPrice(100).build();
    obs.onNext(p); obs.onCompleted();
  }

  @Override
  public void streamPrices(PriceRequest req, StreamObserver<PriceTick> obs) {
    req.getIdsList().forEach(id -> {
      obs.onNext(PriceTick.newBuilder().setId(id).setPrice(100).setTs(System.currentTimeMillis()).build());
    });
    obs.onCompleted();
  }
}
```

#### 부트에서 서버 띄우기
```java
@Configuration
class GrpcServerConfig {
  @Bean(initMethod = "start", destroyMethod = "shutdown")
  Server grpcServer(CatalogService service) {
    return ServerBuilder.forPort(6565).addService(service).build();
  }
}
```

#### 클라이언트
```java
@Service
class GrpcCatalogClient implements AutoCloseable {
  private final ManagedChannel ch = ManagedChannelBuilder.forAddress("catalog", 6565)
    .usePlaintext() // 운영에선 TLS
    .build();
  private final CatalogGrpc.CatalogBlockingStub stub = CatalogGrpc.newBlockingStub(ch);

  public Product get(String id) {
    return stub.withDeadlineAfter(2, TimeUnit.SECONDS).get(GetRequest.newBuilder().setId(id).build());
  }

  @Override public void close() { ch.shutdown(); }
}
```

### C-3. 보안/운영
- **TLS**(서버/양방향), **mTLS**로 서비스 신뢰.
- **Deadline**(타임아웃) 필수, **Interceptor**로 메타데이터 헤더(tenant/traceId) 주입.
- 게이트웨이(Envoy/Cloud LB)로 L7 라우팅·observability.
- 파일 전송은 **스트리밍 RPC** 사용; 매우 큰 파일은 **서명 URL + HTTP**가 현실적일 때가 많음.

### C-4. 언제 gRPC?
- 내부 트래픽, **낮은 레이턴시/양방향 스트림** 필요.
- 외부·브라우저·서드파티 통합은 **HTTP+JSON**과 **웹훅**이 일반적으로 더 쉬움.

---

## D. 파일 업로드/다운로드 통신 패턴(외부 API 연계)

### D-1. 클라이언트→우리 서버(이미 15장에서 다룸) 요약
- **멀티파트 업로드**: 크기 제한, MIME 스니핑, 해시/무결성, 바이러스 스캔, 임시 저장 → 비동기 파이프라인(썸네일/전환).
- 대용량은 **청크 업로드** 또는 **S3/GCS Presigned URL**로 **클라이언트→스토리지 직행**.

### D-2. 우리 서버→타사(업로드 프록시)
```java
public URI uploadToPartner(Path file, String filename, String token) {
  var entity = MultipartBodyBuilderSupport.multipart("file", file, filename, "image/jpeg");
  return rest.post().uri("https://partner.example.com/upload")
    .headers(h -> h.setBearerAuth(token))
    .contentType(MediaType.MULTIPART_FORM_DATA)
    .body(entity)
    .retrieve()
    .body(UploadResult.class).location();
}
```
> 타사 한도(레이트리밋) 준수: **Resilience4j RateLimiter**, 상태코드 429/503 처리.

### D-3. 스트리밍 다운로드(우리→타사→클라이언트 프록시)
- **바이트 파이프**(InputStream ↔ OutputStream)로 **메모리 고정 상한** 유지.
- `Content-Length`, `ETag`, `Content-Disposition`을 타사 응답에서 **패스스루**.

---

## E. 웹훅(Webhook) 콜백 패턴 — 발신 / 수신

### E-1. 왜 웹훅?
- 비동기 이벤트를 **상대 서버**로 푸시. 결제 완료/배달 상태/파일 처리 완료 등.
- 핵심: **서명 검증**, **Idempotency**, **재시도**.

### E-2. 발신자(우리 → 고객 시스템)
#### 메시지 모델(서명용)
```json
{
  "id": "evt_20251022_001",
  "type": "file.processed",
  "ts": 173, 
  "data": {
    "fileId": "f_abc123",
    "status": "COMPLETED"
  }
}
```

#### 서명(HMAC-SHA256) 생성
```java
class WebhookSigner {
  static String sign(String secret, String payload) {
    try {
      Mac mac = Mac.getInstance("HmacSHA256");
      mac.init(new SecretKeySpec(secret.getBytes(UTF_8), "HmacSHA256"));
      return Base64.getEncoder().encodeToString(mac.doFinal(payload.getBytes(UTF_8)));
    } catch (Exception e) { throw new IllegalStateException(e); }
  }
}
```

#### 발신 + 재시도(백오프)
```java
@Service
@RequiredArgsConstructor
class WebhookDispatcher {
  private final RestClient http;

  public void send(URI endpoint, String secret, WebhookEvent evt) {
    String payload = toJson(evt);
    String sig = WebhookSigner.sign(secret, payload);
    int attempt = 0;
    while (attempt < 5) {
      try {
        http.post().uri(endpoint)
          .header("X-Webhook-Id", evt.id())
          .header("X-Webhook-Signature", sig)
          .header("X-Webhook-Timestamp", String.valueOf(evt.ts()))
          .contentType(MediaType.APPLICATION_JSON)
          .body(payload)
          .retrieve().toBodilessEntity();
        return;
      } catch (HttpClientErrorException e) {
        if (e.getStatusCode().is4xxClientError()) break; // 영구 실패
      } catch (Exception ignore) {}
      sleepWithJitter(attempt++); // 0.2s → 0.4s → 0.8s …
    }
    // DLT(보류 큐) 저장 + 운영 알림
  }
}
```

### E-3. 수신자(상대 → 우리)
#### 서명 검증 + 리플레이 방지(타임스탬프 허용범위)
```java
@RestController
@RequestMapping("/webhooks/partner")
class PartnerWebhookController {

  @PostMapping
  ResponseEntity<Void> receive(@RequestHeader("X-Webhook-Id") String id,
                               @RequestHeader("X-Webhook-Signature") String sig,
                               @RequestHeader("X-Webhook-Timestamp") long ts,
                               @RequestBody String body) {
    // 1) 타임스탬프 확인(±5분)
    if (Math.abs(System.currentTimeMillis() - ts) > 300_000) return ResponseEntity.status(408).build();

    // 2) 서명 검증
    String expected = WebhookSigner.sign(loadSecret(), body);
    if (!MessageDigest.isEqual(sig.getBytes(UTF_8), expected.getBytes(UTF_8))) return ResponseEntity.status(401).build();

    // 3) 멱등성 (중복 콜백 무시)
    if (!idempotencyRegister.tryLock(id)) return ResponseEntity.ok().build();
    try {
      // 4) 비즈니스 처리 → 비동기 큐로 넘기고, 웹훅에는 빠르게 2xx 응답
      processAsync(body);
      return ResponseEntity.ok().build();
    } finally { idempotencyRegister.unlock(id); }
  }
}
```

> 규범
> - **2xx**를 빠르게 회신(다운스트림 실패는 **내부 큐**로 처리/재시도).
> - **서명 검증 + 시간창**으로 **재전송/리플레이 공격** 방지.
> - 본문 파싱 전 **서명 먼저**.

---

## F. 관측성 — 로그/메트릭/트레이싱

- **HTTP 클라이언트 공통 태그**: `client_name`, `outcome(2xx/4xx/5xx)`, `status`, `exception`.
- Resilience4j 지표: **서킷 상태**, 성공/실패/느린 호출 비율, 리트라이 횟수, 제한/거부 수.
- WebClient/RestClient: Micrometer 자동 계측 사용 → **Prometheus**에 스크랩.
- **분산 추적**: traceparent(B3/W3C) 전파, **웹훅에도 헤더로 삽입**.

---

## G. 테스트 — 통합/회귀

### G-1. WireMock/MockWebServer
```kotlin
testImplementation("com.github.tomakehurst:wiremock-jre8:3.6.0")
```
```java
@AutoConfigureWireMock(port = 0)
@SpringBootTest
class CatalogClientTest {
  @Test
  void ok() {
    stubFor(get(urlEqualTo("/v1/products/1"))
      .willReturn(aResponse().withStatus(200)
        .withHeader("Content-Type","application/json")
        .withBody("""{"id":"1","name":"A","price":100}""")));

    var p = client.getProduct("1");
    assertThat(p.name()).isEqualTo("A");
  }
}
```

### G-2. 실패/리트라이/서킷
- WireMock으로 500/타임아웃 → **리트라이 카운트**와 **서킷 오픈** 상태를 검증.
- 컨슈머 계약 테스트(예: Spring Cloud Contract)로 파편화 방지.

---

## H. 보안 체크리스트

- **TLS** 강제, **서버 인증서 검증**(Trust Store 관리).
- **OAuth2 Client Credentials**로 토큰 취득, 갱신(5분 전 리프레시).
- **비밀/키**는 Vault/Secret Manager에서 주입.
- **헤더/쿼리 로그 마스킹**(Authorization, Cookie, X-Api-Key).
- **다운로드 프록시**시 `Content-Disposition: attachment`, `X-Content-Type-Options: nosniff`.

---

## I. 운영 체크리스트(요약)

- [ ] RestClient/WebClient 공통 빌더: **타임아웃/헤더/traceId/메트릭** 강제  
- [ ] **Resilience4j**: 회로/리트라이/레이트리밋/벌크헤드/타임리밋 설정 + 메트릭 알람  
- [ ] **Idempotency**: 요청/웹훅에 고유 ID, 중복 보호  
- [ ] **웹훅**: 서명 검증 + 타임스탬프 + 빠른 2xx + 내부 큐 재시도  
- [ ] **파일**: 스트리밍/청크/Presigned URL, Range/ETag 패스스루  
- [ ] **gRPC**: 내부용, TLS/Deadline/Interceptor/메트릭  
- [ ] 테스트: WireMock 계약/장애 주입, 회로 상태 전이 검증

---

## J. 한 페이지 요약
- **RestClient/WebClient**는 “한 곳에서” **타임아웃/헤더/관측**을 표준화하고, 호출부는 **간결**하게.  
- **Resilience4j**로 예측 가능한 실패를 만들고(서킷), **지터 있는 리트라이**와 **레이트/벌크 헤드**로 다운스트림을 보호.  
- **gRPC**는 내부 고성능/스트리밍에 적합, 외부는 HTTP+JSON·웹훅이 보편.  
- **웹훅**은 서명/타임스탬프/멱등성/재시도가 전부다.  
- 파일 전송은 **스트리밍 + Presigned URL**을 우선, **Range/ETag**로 비용을 줄인다.  
- 전 구간에 **traceId/메트릭/로그 마스킹**을 심어 장애가 나도 **원인과 영향**을 즉시 찾을 수 있게 하라.