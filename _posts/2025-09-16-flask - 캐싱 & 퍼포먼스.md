---
layout: post
title: flask - 캐싱 & 퍼포먼스
date: 2025-09-16 22:25:23 +0900
category: flask
---
# 캐싱 & 퍼포먼스

## 캐싱의 큰 그림

효율적인 캐싱 전략은 **계층적 접근**을 기반으로 설계해야 합니다. 각 계층은 서로 다른 목적과 특성을 가지며, 전체 시스템의 성능과 확장성을 결정합니다.

1) **CPU 캐시/인터프리터 레벨**: 파이썬 내장 `lru_cache` 데코레이터 등(인스턴스 내부 최적화)
2) **애플리케이션 캐시**: Flask-Caching(메모리, Redis), 뷰 단위/함수 결과/저수준 캐시 작업
3) **HTTP 캐시**: `ETag`, `Last-Modified`, `Cache-Control` 헤더, CDN 캐싱
4) **데이터베이스/쿼리 캐시**: 쿼리 결과 캐싱 또는 구체화된 뷰(materialized view) 활용
5) **CDN/프록시 캐시**: Nginx, CloudFront, Varnish와 같은 외부 캐싱 계층

> 핵심 원칙: **캐시 적중률 향상 + 명확한 무효화 전략 + 일관성 요구사항 분석**입니다. "정확성"과 "신선도" 사이의 트레이드오프를 명확히 이해하고 문서화해야 합니다.

---

## Flask-Caching 도입 (메모리/Redis)

### 설치와 초기화

```bash
pip install Flask-Caching redis
```

```python
# app/extensions.py

from flask_caching import Cache

cache = Cache()

def init_cache(app):
    app.config.setdefault("CACHE_TYPE", "RedisCache")  # "SimpleCache" (메모리)도 가능
    app.config.setdefault("CACHE_REDIS_URL", "redis://localhost:6379/3")
    app.config.setdefault("CACHE_KEY_PREFIX", "myapp:")
    app.config.setdefault("CACHE_DEFAULT_TIMEOUT", 300)  # 5분
    # Flask-Caching(>=2.0)은 init_app 필요
    cache.init_app(app)
```

```python
# app/__init__.py

from .extensions import init_cache
def create_app(...):
    app = Flask(__name__)
    ...
    init_cache(app)
    return app
```

### 뷰 캐싱(@cache.cached)

```python
# app/blueprints/site/views.py

from flask import Blueprint, render_template, request
from app.extensions import cache

site_bp = Blueprint("site", __name__)

def _index_cache_key():
    # 쿼리스트링, 언어, 로그인 상태에 따라 키 구분
    lang = request.args.get("lang", "ko")
    return f"index:{lang}"

@site_bp.get("/")
@cache.cached(timeout=60, key_prefix=_index_cache_key)
def home():
    # 데이터베이스 조회나 외부 API 호출 같은 고비용 작업…
    return render_template("home.html", items=_load_top_items())
```

### 함수 결과 캐싱(@cache.memoize)

```python
# app/services/catalog.py

from app.extensions import cache

@cache.memoize(timeout=600)  # 동일한 인자에 대해 결과 캐싱
def get_product_detail(product_id: int, currency: str = "KRW"):
    # 복잡한 계산이나 여러 API 호출이 필요한 작업…
    return {"id": product_id, "price": _fx_convert(_db_price(product_id), currency)}
```

**키 조정 옵션**

```python
@cache.memoize(600, unless=lambda *a, **k: k.get("bypass"))  # 런타임 조건에 따른 캐시 제어
def recommend(user_id, *, bypass=False): ...
```

### 저수준 API(set/get/add/delete)

```python
from app.extensions import cache

def get_homepage_json():
    key = "homepage:v1"  # 버전 접두사로 스키마 변화 대응
    data = cache.get(key)
    if data is None:
        data = _build_homepage_data()
        cache.set(key, data, timeout=120)
    return data
```

**add 메서드**를 사용한 **캐시 스탬피드(동시 미스 폭주)** 완화:

```python
if not cache.add(key, {"status":"building"}, timeout=30):
    # 다른 워커가 이미 생성 중 — 짧게 대기 후 재확인
    time.sleep(0.1)
    return cache.get(key)
# 우리가 빌드 담당

data = _build()
cache.set(key, data, timeout=300)
return data
```

### 캐시 무효화 전략과 실전 팁

- **버전 접두사**: `homepage:v2:...` 처럼 스키마 변경 시 **버전만 변경하여 전체 무효화**
- **delete_memoized**: memoize된 함수의 특정 인자 조합 무효화
  ```python
  cache.delete_memoized(get_product_detail, 42, "KRW")  # 특정 조합만 무효화
  cache.delete_memoized(get_product_detail)  # 모든 인자 조합 무효화
  ```
- **키 명명 규칙**: `namespace:entity:id` 형식. 예) `product:42`, `user:1:feed`
- **쓰기 후 무효화**: 데이터베이스 업데이트 직후 관련 캐시 키들을 제거
- **TTL 계층화**: 핵심 데이터(짧은 TTL), 통계/랭킹(긴 TTL) 구분
- **사전 예열**: 배포 직후 통계나 랭킹 데이터를 미리 생성

---

## ETag와 조건부 요청

### `ETag` + `If-None-Match` 활용

```python
# app/http/cache.py

from flask import Response, request
import hashlib, json

def json_with_etag(obj, max_age=60):
    body = json.dumps(obj, ensure_ascii=False).encode("utf-8")
    etag = hashlib.md5(body).hexdigest()  # 강한 ETag (작은 페이로드에 적합)
    if request.headers.get("If-None-Match") == etag:
        resp = Response(status=304)
    else:
        resp = Response(body, status=200, mimetype="application/json")
        resp.set_etag(etag)
    resp.cache_control.public = True
    resp.cache_control.max_age = max_age
    return resp
```

**사용 예시**

```python
@api_v1_bp.get("/stats")
def stats():
    data = get_cached_stats()
    return json_with_etag(data, max_age=120)
```

### `Last-Modified` + `If-Modified-Since` 활용

```python
from datetime import datetime, timezone
from flask import Response, request

def send_if_modified(body: bytes, last_modified: datetime):
    ims = request.if_modified_since  # werkzeug가 파싱한 값
    if ims and last_modified.replace(microsecond=0) <= ims.replace(microsecond=0):
        return Response(status=304)
    resp = Response(body, mimetype="text/plain")
    resp.last_modified = last_modified
    resp.cache_control.public = True
    resp.cache_control.max_age = 300
    return resp
```

### 정적 파일 캐시 버스팅 전략

- 파일명에 **해시값 포함** → 무기한 캐시 가능
- Flask는 `send_file`/`static`에 대해 `SEND_FILE_MAX_AGE_DEFAULT` 설정 활용
- 빌드 파이프라인에서 `app.css?v=<hash>` 대신 **파일명 자체에 해시 포함**(`app.<hash>.css`)을 권장

---

## 캐시 스탬피드와 동시성 이슈 대처

**Dogpile 방지 전략**(짧은 유예 기간 활용):

- 만료 직전/직후 **하나의 워커만** 캐시 재생성
- 다른 워커는 **구 캐시(stale)** 를 잠시 사용 후 합류

**간단한 구현 예시**

```python
def cached_compute(key, ttl=300, grace=30):
    item = cache.get(key)
    if item and item.get("exp", 0) > time.time():
        return item["val"]  # 정상 캐시 사용
    # 유예 구간: stale 허용 + 리프레시 락 시도
    if item and item.get("exp", 0) + grace > time.time():
        if cache.add(key + ":lock", 1, timeout=grace):
            val = _recompute()
            cache.set(key, {"val": val, "exp": time.time() + ttl}, ttl + grace)
        return item["val"]  # stale 데이터 제공
    # 완전 만료: 우리가 직접 갱신
    val = _recompute()
    cache.set(key, {"val": val, "exp": time.time() + ttl}, ttl + grace)
    return val
```

---

## 응답 압축과 Keep-Alive

### 압축 전략: 어디서 적용할 것인가?

- **권장 접근법**: **프록시/웹서버(Nginx)** 또는 **CDN**에서 압축 처리
- Flask에서 `Flask-Compress`를 사용한 간단한 적용도 가능하나, CPU 부하를 고려하면 프록시로 오프로드하는 것이 좋습니다.

#### Nginx gzip 설정

```
gzip on;
gzip_comp_level 5;
gzip_min_length 1024;
gzip_types text/plain text/css application/json application/javascript text/xml application/xml;
gzip_vary on;
```

#### Nginx + Brotli 설정

```
brotli on;
brotli_comp_level 5;
brotli_static on;  # 사전 압축된 .br 파일 제공
brotli_types text/plain text/css application/json application/javascript text/xml application/xml;
```

#### Flask-Compress 빠른 적용

```bash
pip install flask-compress brotli
```

```python
from flask_compress import Compress

def init_compress(app):
    app.config["COMPRESS_ALGORITHM"] = "br,gzip"
    app.config["COMPRESS_MIN_SIZE"] = 1024
    Compress(app)
```

> **주의사항**: 이미지/동영상 파일은 이미 압축되어 있어 재압축이 비효율적입니다. MIME 타입 필터링이 필수적입니다.

### HTTP Keep-Alive 최적화

- 프록시/클라이언트와의 **연결 재사용**으로 **핸드셰이크 비용** 절감
- Nginx 설정 예시:
  ```
  keepalive_timeout 65;
  keepalive_requests 1000;
  ```
- Gunicorn 설정(리버스 프록시 환경):
  - `--keep-alive 5` (프록시와 백엔드 사이), 워커 수와 스레드 수 적절히 조율

---

## 커넥션 풀링(데이터베이스/HTTP)

### SQLAlchemy 커넥션 풀 설정

```python
app.config.update(
    SQLALCHEMY_ENGINE_OPTIONS={
        "pool_pre_ping": True,
        "pool_size": 5,          # 워커/스레드/데이터베이스 제한 고려
        "max_overflow": 10,
        "pool_recycle": 1800,    # MySQL wait_timeout 이슈 대응
    }
)
```

### 외부 HTTP 호출 — `requests.Session` 풀 설정

```python
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

session = requests.Session()
adapter = HTTPAdapter(
    pool_connections=20, pool_maxsize=50,
    max_retries=Retry(total=3, backoff_factor=0.2, status_forcelist=[429, 500, 502, 503, 504])
)
session.mount("http://", adapter)
session.mount("https://", adapter)

def get_json(url, timeout=3):
    r = session.get(url, timeout=timeout)
    r.raise_for_status()
    return r.json()
```

### `httpx` 활용 (비동기 지원, 타임아웃/풀 정교화)

```python
import httpx

client = httpx.Client(
    timeout=httpx.Timeout(5.0, connect=2.0, read=3.0),
    limits=httpx.Limits(max_connections=100, max_keepalive_connections=20)
)
```

> **타임아웃, 재시도, 서킷 브레이커**를 표준화하여(데코레이터/유틸리티) 외부 API 병목을 줄여야 합니다.

---

## 프로파일링: CPU 사용량, 벽시계 시간, 쿼리 성능 분석

### werkzeug 프로파일러 미들웨어 활용

```python
# wsgi_prof.py

from werkzeug.middleware.profiler import ProfilerMiddleware
from app import create_app

app = create_app()
app.wsgi_app = ProfilerMiddleware(app.wsgi_app, profile_dir="./profiles", sort_by=("tottime",))
```

실행 후 `./profiles/` 디렉토리에 **pstats 파일** 생성 → `snakeviz`, `gprof2dot` 등으로 시각화:

```bash
pip install snakeviz
snakeviz profiles/.....prof
```

### cProfile을 활용한 수동 측정

```python
import cProfile, pstats, io

def profile_fn(fn, *a, **k):
    pr = cProfile.Profile()
    pr.enable(); r = fn(*a, **k); pr.disable()
    s = io.StringIO(); pstats.Stats(pr, stream=s).sort_stats("tottime").print_stats(30)
    print(s.getvalue()); return r
```

### SQLAlchemy 쿼리 로깅과 슬로우 쿼리 감지

```python
app.config["SQLALCHEMY_ECHO"] = False

import logging
logging.getLogger("sqlalchemy.engine").setLevel(logging.INFO)   # 개발 환경용
# 운영 환경에서는 이벤트 리스너로 200ms 이상의 슬로우 쿼리만 로깅하는 핸들러를 권장
```

---

## 분산 추적(OpenTelemetry): Flask, 데이터베이스, HTTP 호출 통합

### 기본 설정

```bash
pip install opentelemetry-api opentelemetry-sdk \
            opentelemetry-exporter-otlp \
            opentelemetry-instrumentation-flask \
            opentelemetry-instrumentation-requests \
            opentelemetry-instrumentation-sqlalchemy
```

Collector(OTLP)로 전송한다고 가정한 설정:

```python
# app/observability/otel.py

from opentelemetry.sdk.resources import SERVICE_NAME, Resource
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter

def setup_tracing(app):
    provider = TracerProvider(resource=Resource.create({SERVICE_NAME: "flask-app"}))
    processor = BatchSpanProcessor(OTLPSpanExporter(endpoint="http://otel-collector:4318/v1/traces"))
    provider.add_span_processor(processor)

    from opentelemetry import trace
    trace.set_tracer_provider(provider)

    from opentelemetry.instrumentation.flask import FlaskInstrumentor
    FlaskInstrumentor().instrument_app(app)

    from opentelemetry.instrumentation.requests import RequestsInstrumentor
    RequestsInstrumentor().instrument()

    # SQLAlchemy 계측
    from opentelemetry.instrumentation.sqlalchemy import SQLAlchemyInstrumentor
    from app.extensions import db
    SQLAlchemyInstrumentor().instrument(engine=db.engine)
```

**스팬에 커스텀 태깅 추가**

```python
from opentelemetry import trace
tracer = trace.get_tracer(__name__)

@api_v1_bp.get("/expensive")
def expensive():
    with tracer.start_as_current_span("business_rule") as span:
        span.set_attribute("feature", "recommendation")
        data = _compute()
        return {"len": len(data)}
```

> **수집 및 백엔드**: Jaeger, Tempo, Zipkin, Datadog 등. **샘플링 비율과 규칙**을 환경별로 적절히 조정해야 합니다.

---

## 대용량 파일 스트리밍과 청크 응답

### `send_file` 기본 활용 (Zero-copy 경로)

```python
from flask import send_file

@assets_bp.get("/download/<path:name>")
def download(name):
    # 권한 검증 후
    path = f"/var/app/uploads/{name}"
    # conditional=True → If-Modified-Since / Range 요청 일부 지원
    return send_file(path, as_attachment=True, conditional=True, max_age=3600)
```

일부 WSGI 서버와 운영체제는 `wsgi.file_wrapper`를 통해 커널 **sendfile** 경로를 사용합니다 → CPU 사용량 감소.

### 커스텀 제너레이터를 통한 청크 스트리밍

```python
from flask import Response

def iter_file(path, chunk_size=1024*256):
    with open(path, "rb") as f:
        while True:
            chunk = f.read(chunk_size)
            if not chunk: break
            yield chunk

@assets_bp.get("/stream/<path:name>")
def stream(name):
    path = f"/var/app/big/{name}"
    resp = Response(iter_file(path), mimetype="application/octet-stream")
    resp.headers["Content-Disposition"] = f'attachment; filename="{name}"'
    resp.headers["Cache-Control"] = "private, max-age=0"
    return resp
```

### Range 요청 처리(부분 콘텐츠, 206 상태 코드)

Flask의 `send_file(..., conditional=True)`는 간단한 Range 요청을 지원합니다.
직접 구현하려면 Range 헤더 파싱이 필요하며 복잡합니다. 가능하면 **Nginx/CloudFront**에 **X-Accel-Redirect**나 **서명된 URL**을 위임하는 것이 좋습니다:

```python
# 권한 검증 후 내부 경로 위임

from flask import make_response

@assets_bp.get("/fast/<path:name>")
def fast(name):
    resp = make_response("", 200)
    resp.headers["X-Accel-Redirect"] = f"/protected/{name}"
    resp.headers["Content-Type"] = "application/octet-stream"
    resp.headers["Content-Disposition"] = f'attachment; filename="{name}"'
    return resp
```

**Nginx 설정**

```
location /protected/ {
  internal;
  alias /var/app/big/;
}
```

### S3 등 외부 스토리지 프록시 스트리밍

- **권장 방식**: 사전 서명된 URL을 **클라이언트에 직접 제공**(서버는 권한 검증만 담당)
- 서버 프록시 스트리밍이 필요한 경우:

```python
import boto3
from flask import Response

s3 = boto3.client("s3")

@assets_bp.get("/s3/<path:key>")
def s3_stream(key):
    r = s3.get_object(Bucket="my-bucket", Key=key)
    body = r["Body"]  # botocore.response.StreamingBody (iterable)
    return Response(body.iter_chunks(chunk_size=1024*256), mimetype=r["ContentType"])
```

> **주의사항**: 프록시 스트리밍은 **서버 송신 비용과 대역폭** 부담을 증가시킵니다. 대규모 배포에서는 **CDN이나 서명된 URL** 방식을 선호해야 합니다.

---

## Gunicorn/WSGI 워커와 스레드 튜닝 간단 가이드

- **sync 워커**: I/O 대기 시간이 많은 경우 비효율적
- **gevent/eventlet**: 코루틴 기반, 외부 I/O 작업이 많은 애플리케이션에 적합
- **gthread**: 스레드 병렬성 증가, GIL 영향 받음
- 손쉬운 시작 설정:
  ```bash
  gunicorn "wsgi:app" -k gthread --threads 8 -w 2 --bind :8000 --keep-alive 5 --max-requests 5000 --max-requests-jitter 500
  ```
- **max-requests**(재시작)로 **메모리 누수** 방지, **preload_app** 사용 시 주의(데이터베이스 커넥션 복사 문제)

---

## 실전 레퍼런스 가이드

### 캐시 초기화 템플릿

```python
from flask_caching import Cache
cache = Cache(config={
    "CACHE_TYPE": "RedisCache",
    "CACHE_REDIS_URL": "redis://127.0.0.1:6379/3",
    "CACHE_KEY_PREFIX": "myapp:",
    "CACHE_DEFAULT_TIMEOUT": 300,
})
cache.init_app(app)
```

### 뷰 캐시 적용

```python
@cache.cached(timeout=60, key_prefix=lambda: f"view:{request.full_path}")
def view(): ...
```

### memoize 캐시 무효화

```python
cache.delete_memoized(func)                 # 전체 함수 캐시 무효화
cache.delete_memoized(func, arg1, arg2)     # 특정 인자 조합만 무효화
```

### Flask-Compress 적용

```python
from flask_compress import Compress
Compress(app)
```

### requests 세션 풀과 재시도 설정

```python
adapter = HTTPAdapter(pool_connections=20, pool_maxsize=50, max_retries=Retry(total=3))
session.mount("https://", adapter)
```

### werkzeug 프로파일러 적용

```python
app.wsgi_app = ProfilerMiddleware(app.wsgi_app, profile_dir="./profiles")
```

### OpenTelemetry 초기화

```python
from app.observability.otel import setup_tracing
setup_tracing(app)
```

### 스트리밍 응답 생성

```python
return Response(iter(lambda: f.read(262144), b""), mimetype="application/octet-stream")
```

---

## 결론

이번 장에서는 Flask 애플리케이션의 성능 최적화를 위한 종합적인 전략을 살펴보았습니다. 캐싱 계층 설계부터 시작하여 애플리케이션 수준의 캐싱 구현, HTTP 수준의 캐싱 전략, 그리고 분산 환경에서의 성능 모니터링까지 실제 운영 환경에서 검증된 접근 방식을 다루었습니다.

성능 최적화는 단일 기술이나 기법에 의존하기보다는 계층적이고 통합적인 접근이 필요합니다. 애플리케이션 캐시, HTTP 캐시, 데이터베이스 최적화, 네트워크 최적화가 조화를 이루어야 진정한 성능 향상을 달성할 수 있습니다. 또한 프로파일링과 모니터링 도구를 활용하여 실제 병목 지점을 데이터 기반으로 파악하는 것이 중요합니다.

마지막으로, 성능 최적화는 지속적인 과정이라는 점을 인식해야 합니다. 애플리케이션의 사용 패턴이 변화하고, 데이터 규모가 성장함에 따라 최적화 전략도 진화해야 합니다. 잘 설계된 캐싱 전략과 성능 모니터링 체계는 단순히 응답 시간을 단축하는 것을 넘어, 사용자 경험 향상과 인프라 비용 절감이라는 실질적인 비즈니스 가치를 제공할 수 있습니다.