---
layout: post
title: flask - 캐싱 & 퍼포먼스
date: 2025-09-16 22:25:23 +0900
category: flask
---
# 10. 캐싱 & 퍼포먼스

> 이 장은 **Flask-Caching(메모리/Redis)와 캐시 무효화 전략**, **압축(Gzip/Brotli)·Keep-Alive·커넥션 풀(DB/HTTP)**, **프로파일링/트레이싱(werkzeug profiler, OpenTelemetry)**, **대용량 파일 스트리밍/청크 응답**을 **운영 실전** 기준으로 정리한다.

---

## 10.1 캐싱의 큰 그림

캐시는 **“계층적으로”** 설계한다.

1) **CPU 캐시/인터프리터 레벨**: 파이썬 함수 `lru_cache` 등(인스턴스 내부)  
2) **앱 캐시**: Flask-Caching(메모리, Redis), per-view / memoize / low-level set/get  
3) **HTTP 캐시**: `ETag`, `Last-Modified`, `Cache-Control`, CDN  
4) **DB/쿼리 캐시**: 결과 캐시 or materialized view (애플리케이션 수준)  
5) **CDN/프록시 캐시**: Nginx/CloudFront/Varnish

> 원칙: **적중률↑ + 무효화 전략 명확화 + 일관성 요구 판단**. “정확성”과 “신선도”의 트레이드오프를 문서화.

---

## 10.2 Flask-Caching 도입 (메모리/Redis)

### 10.2.1 설치 & 초기화

```bash
pip install Flask-Caching redis
```

```python
# app/extensions.py
from flask_caching import Cache

cache = Cache()

def init_cache(app):
    app.config.setdefault("CACHE_TYPE", "RedisCache")  # "SimpleCache" (메모리) 도 가능
    app.config.setdefault("CACHE_REDIS_URL", "redis://localhost:6379/3")
    app.config.setdefault("CACHE_KEY_PREFIX", "myapp:")
    app.config.setdefault("CACHE_DEFAULT_TIMEOUT", 300)  # 5분
    # Flask-Caching(>=2.0)은 init_app 필요
    cache.init_app(app)
```

```python
# app/__init__.py
from .extensions import init_cache
def create_app(...):
    app = Flask(__name__)
    ...
    init_cache(app)
    return app
```

### 10.2.2 뷰 캐싱(@cache.cached)

```python
# app/blueprints/site/views.py
from flask import Blueprint, render_template, request
from app.extensions import cache

site_bp = Blueprint("site", __name__)

def _index_cache_key():
    # 쿼리스트링/언어/로그인 여부에 따라 키 차별화
    lang = request.args.get("lang", "ko")
    return f"index:{lang}"

@site_bp.get("/")
@cache.cached(timeout=60, key_prefix=_index_cache_key)
def home():
    # DB/외부API 등 비용 큰 작업…
    return render_template("home.html", items=_load_top_items())
```

### 10.2.3 함수 결과 캐싱(@cache.memoize)

```python
# app/services/catalog.py
from app.extensions import cache

@cache.memoize(timeout=600)  # 동일 인자에 대해 캐시
def get_product_detail(product_id: int, currency: str = "KRW"):
    # 복잡한 계산/멀티 API 호출…
    return {"id": product_id, "price": _fx_convert(_db_price(product_id), currency)}
```

키 조정:

```python
@cache.memoize(600, unless=lambda *a, **k: k.get("bypass"))  # 런타임 조건
def recommend(user_id, *, bypass=False): ...
```

### 10.2.4 저수준 API(set/get/add/delete)

```python
from app.extensions import cache

def get_homepage_json():
    key = "homepage:v1"  # 버전 프리픽스로 스키마 변화 대응
    data = cache.get(key)
    if data is None:
        data = _build_homepage_data()
        cache.set(key, data, timeout=120)
    return data
```

**add**(존재하지 않을 때만)로 **캐시 스탬피드(동시 미스 폭주)** 완화:

```python
if not cache.add(key, {"status":"building"}, timeout=30):
    # 다른 워커가 이미 생성 중 — 짧게 sleep 후 재확인
    time.sleep(0.1)
    return cache.get(key)
# 우리가 빌드 담당
data = _build()
cache.set(key, data, timeout=300)
return data
```

### 10.2.5 캐시 무효화(정책/실전 팁)

- **버전 프리픽스**: `homepage:v2:...` 처럼 스키마 변경 시 **버전만 바꿔 전체 무효화**  
- **delete_memoized**: memoize된 함수/특정 인자를 무효화
  ```python
  cache.delete_memoized(get_product_detail, 42, "KRW")
  cache.delete_memoized(get_product_detail)  # 모든 인자 조합 무효화
  ```
- **키 컨벤션**: `namespace:entity:id` 형태. 예) `product:42`, `user:1:feed`  
- **쓰기 후 무효화(write-through/invalidate)**: DB 업데이트 직후 관련 키들을 제거  
- **TTL 층위**: 핵심 데이터(짧은 TTL), 통계/랭킹(긴 TTL)  
- **사전 예열(warm-up)**: 배포 직후 스탯/랭킹 미리 생성

---

## 10.3 HTTP 캐시(브라우저/CDN) — ETag/조건부 요청

### 10.3.1 `ETag` + `If-None-Match`

```python
# app/http/cache.py
from flask import Response, request
import hashlib, json

def json_with_etag(obj, max_age=60):
    body = json.dumps(obj, ensure_ascii=False).encode("utf-8")
    etag = hashlib.md5(body).hexdigest()  # 강한 ETag (작은 페이로드만)
    if request.headers.get("If-None-Match") == etag:
        resp = Response(status=304)
    else:
        resp = Response(body, status=200, mimetype="application/json")
        resp.set_etag(etag)
    resp.cache_control.public = True
    resp.cache_control.max_age = max_age
    return resp
```

사용:

```python
@api_v1_bp.get("/stats")
def stats():
    data = get_cached_stats()
    return json_with_etag(data, max_age=120)
```

### 10.3.2 `Last-Modified` + `If-Modified-Since`

```python
from datetime import datetime, timezone
from flask import Response, request

def send_if_modified(body: bytes, last_modified: datetime):
    ims = request.if_modified_since  # werkzeug parses
    if ims and last_modified.replace(microsecond=0) <= ims.replace(microsecond=0):
        return Response(status=304)
    resp = Response(body, mimetype="text/plain")
    resp.last_modified = last_modified
    resp.cache_control.public = True
    resp.cache_control.max_age = 300
    return resp
```

### 10.3.3 정적 파일 캐시 버스팅

- 파일명에 **해시** 포함 → 무기한 캐시 가능
- Flask는 `send_file`/`static`에 대해 `SEND_FILE_MAX_AGE_DEFAULT` 활용  
- 빌드 파이프라인에서 `app.css?v=<hash>` 대신 **파일명 자체에 hash** 권장(`app.<hash>.css`)

---

## 10.4 캐시 스탬피드/동시성 이슈 대처

**Dogpile** 전략(“짧은 유예 기간”):

- 만료 직전/직후 **하나의 워커만** 재생성  
- 다른 워커는 **stale 캐시** 잠깐 사용 후 합류

간단 구현 예:

```python
def cached_compute(key, ttl=300, grace=30):
    item = cache.get(key)
    if item and item.get("exp", 0) > time.time():
        return item["val"]  # 정상 캐시
    # 유예 구간: stale 허용 + 리프레시 락 시도
    if item and item.get("exp", 0) + grace > time.time():
        if cache.add(key + ":lock", 1, timeout=grace):
            val = _recompute()
            cache.set(key, {"val": val, "exp": time.time() + ttl}, ttl + grace)
        return item["val"]  # stale serve
    # 완전 만료: 우리가 갱신
    val = _recompute()
    cache.set(key, {"val": val, "exp": time.time() + ttl}, ttl + grace)
    return val
```

---

## 10.5 압축(Gzip/Brotli) & Keep-Alive

### 10.5.1 어디서 압축할까?

- **권장**: **프록시/웹서버(Nginx)** 또는 **CDN**에서 압축  
- 앱에서 `Flask-Compress` 로 간단 적용 가능하나, CPU 부하는 프록시로 오프로드가 좋다.

#### (A) Nginx 설정 (gzip)

```
gzip on;
gzip_comp_level 5;
gzip_min_length 1024;
gzip_types text/plain text/css application/json application/javascript text/xml application/xml;
gzip_vary on;
```

#### (B) Nginx + Brotli

```
brotli on;
brotli_comp_level 5;
brotli_static on;  # 사전 압축된 .br 제공시
brotli_types text/plain text/css application/json application/javascript text/xml application/xml;
```

#### (C) Flask-Compress 빠른 적용

```bash
pip install flask-compress brotli
```

```python
from flask_compress import Compress

def init_compress(app):
    app.config["COMPRESS_ALGORITHM"] = "br,gzip"
    app.config["COMPRESS_MIN_SIZE"] = 1024
    Compress(app)
```

> **주의**: 이미지/동영상은 이미 압축되어 있어 재압축 비효율. `mime` 필터링 필수.

### 10.5.2 HTTP Keep-Alive

- 프록시/클라이언트와 **연결 재사용**으로 **핸드셰이크 비용** 감축  
- Nginx:
  ```
  keepalive_timeout 65;
  keepalive_requests 1000;
  ```
- Gunicorn(리버스 프록시 뒤에서):  
  - `--keep-alive 5` (프록시와 백엔드 사이), 워커 수/스레드 수 조율

---

## 10.6 커넥션 풀(DB/HTTP)

### 10.6.1 SQLAlchemy(Flask-SQLAlchemy) 풀

```python
app.config.update(
    SQLALCHEMY_ENGINE_OPTIONS={
        "pool_pre_ping": True,
        "pool_size": 5,          # 워커/스레드/DB 제한 고려
        "max_overflow": 10,
        "pool_recycle": 1800,    # MySQL wait_timeout 이슈
    }
)
```

### 10.6.2 외부 HTTP 호출 — `requests.Session` 풀

```python
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

session = requests.Session()
adapter = HTTPAdapter(
    pool_connections=20, pool_maxsize=50,
    max_retries=Retry(total=3, backoff_factor=0.2, status_forcelist=[429, 500, 502, 503, 504])
)
session.mount("http://", adapter)
session.mount("https://", adapter)

def get_json(url, timeout=3):
    r = session.get(url, timeout=timeout)
    r.raise_for_status()
    return r.json()
```

### 10.6.3 `httpx` (async 지원, 타임아웃/풀 정교)

```python
import httpx

client = httpx.Client(
    timeout=httpx.Timeout(5.0, connect=2.0, read=3.0),
    limits=httpx.Limits(max_connections=100, max_keepalive_connections=20)
)
```

> **타임아웃/재시도/서킷브레이커**를 표준화(데코레이터/유틸)하여 외부 API 병목을 줄여라.

---

## 10.7 프로파일링: CPU/벽시계/쿼리

### 10.7.1 werkzeug 프로파일러 미들웨어

```python
# wsgi_prof.py
from werkzeug.middleware.profiler import ProfilerMiddleware
from app import create_app

app = create_app()
app.wsgi_app = ProfilerMiddleware(app.wsgi_app, profile_dir="./profiles", sort_by=("tottime",))
```

실행 후 `./profiles/` 에 **pstats** 파일 생성 → `snakeviz`, `gprof2dot` 등으로 시각화:

```bash
pip install snakeviz
snakeviz profiles/.....prof
```

### 10.7.2 cProfile 수동 측정

```python
import cProfile, pstats, io

def profile_fn(fn, *a, **k):
    pr = cProfile.Profile()
    pr.enable(); r = fn(*a, **k); pr.disable()
    s = io.StringIO(); pstats.Stats(pr, stream=s).sort_stats("tottime").print_stats(30)
    print(s.getvalue()); return r
```

### 10.7.3 SQLAlchemy 쿼리 로깅/슬로우 쿼리

```python
app.config["SQLALCHEMY_ECHO"] = False

import logging
logging.getLogger("sqlalchemy.engine").setLevel(logging.INFO)   # 개발용
# 운영에서는 이벤트 리스너로 200ms+ 슬로우쿼리만 로깅하는 핸들러를 권장
```

---

## 10.8 분산 트레이싱(OpenTelemetry) — Flask/DB/HTTP

### 10.8.1 기본 세팅

```bash
pip install opentelemetry-api opentelemetry-sdk \
            opentelemetry-exporter-otlp \
            opentelemetry-instrumentation-flask \
            opentelemetry-instrumentation-requests \
            opentelemetry-instrumentation-sqlalchemy
```

Collector(OTLP)로 보낸다고 가정:

```python
# app/observability/otel.py
from opentelemetry.sdk.resources import SERVICE_NAME, Resource
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter

def setup_tracing(app):
    provider = TracerProvider(resource=Resource.create({SERVICE_NAME: "flask-app"}))
    processor = BatchSpanProcessor(OTLPSpanExporter(endpoint="http://otel-collector:4318/v1/traces"))
    provider.add_span_processor(processor)

    from opentelemetry import trace; trace.set_tracer_provider(provider)

    from opentelemetry.instrumentation.flask import FlaskInstrumentor
    FlaskInstrumentor().instrument_app(app)

    from opentelemetry.instrumentation.requests import RequestsInstrumentor
    RequestsInstrumentor().instrument()

    # SQLAlchemy
    from opentelemetry.instrumentation.sqlalchemy import SQLAlchemyInstrumentor
    from app.extensions import db
    SQLAlchemyInstrumentor().instrument(engine=db.engine)
```

스팬 커스텀 태깅:

```python
from opentelemetry import trace
tracer = trace.get_tracer(__name__)

@api_v1_bp.get("/expensive")
def expensive():
    with tracer.start_as_current_span("business_rule") as span:
        span.set_attribute("feature", "recommendation")
        data = _compute()
        return {"len": len(data)}
```

> **수집/백엔드**: Jaeger/Tempo/Zipkin/Datadog 등. **샘플링** 비율/룰을 환경별로 조절.

---

## 10.9 대용량 파일 스트리밍/청크 응답

### 10.9.1 `send_file`의 기본 (Zero-copy 경로)

```python
from flask import send_file

@assets_bp.get("/download/<path:name>")
def download(name):
    # 권한 검증 후
    path = f"/var/app/uploads/{name}"
    # conditional=True → If-Modified-Since / Range 일부 지원
    return send_file(path, as_attachment=True, conditional=True, max_age=3600)
```

일부 WSGI 서버/OS는 `wsgi.file_wrapper` 를 통해 커널 **sendfile** 경로를 사용 → CPU 사용량↓.

### 10.9.2 커스텀 제너레이터로 청크 스트리밍

```python
from flask import Response

def iter_file(path, chunk_size=1024*256):
    with open(path, "rb") as f:
        while True:
            chunk = f.read(chunk_size)
            if not chunk: break
            yield chunk

@assets_bp.get("/stream/<path:name>")
def stream(name):
    path = f"/var/app/big/{name}"
    resp = Response(iter_file(path), mimetype="application/octet-stream")
    resp.headers["Content-Disposition"] = f'attachment; filename="{name}"'
    resp.headers["Cache-Control"] = "private, max-age=0"
    return resp
```

### 10.9.3 Range 요청(부분 콘텐츠, 206)

Flask의 `send_file(..., conditional=True)` 는 간단한 Range 지원을 제공한다.  
직접 구현 시 Range 파싱 필요(복잡). 가능하면 **Nginx/CloudFront**에 **X-Accel-Redirect**/**signed URL**을 위임:

```python
# 권한 체크 후 내부 경로 위임
from flask import make_response

@assets_bp.get("/fast/<path:name>")
def fast(name):
    resp = make_response("", 200)
    resp.headers["X-Accel-Redirect"] = f"/protected/{name}"
    resp.headers["Content-Type"] = "application/octet-stream"
    resp.headers["Content-Disposition"] = f'attachment; filename="{name}"'
    return resp
```

Nginx:

```
location /protected/ {
  internal;
  alias /var/app/big/;
}
```

### 10.9.4 S3 등 외부 스토리지 프록시 스트리밍

- **권장**: 프리사인드 URL을 **클라이언트에 직접 제공**(서버는 권한만 판단)  
- 필요 시 서버 프록시 스트리밍:

```python
import boto3
from flask import Response

s3 = boto3.client("s3")

@assets_bp.get("/s3/<path:key>")
def s3_stream(key):
    r = s3.get_object(Bucket="my-bucket", Key=key)
    body = r["Body"]  # botocore.response.StreamingBody (iterable)
    return Response(body.iter_chunks(chunk_size=1024*256), mimetype=r["ContentType"])
```

> **주의**: 프록시 스트리밍은 **서버 egress 비용/대역폭** 부담. 대규모 배포에서는 **CDN/Signed URL** 선호.

---

## 10.10 Gunicorn/WSGI 워커/스레드 튜닝 간단 가이드

- **sync** 워커: I/O 대기 많은 경우 비효율  
- **gevent/eventlet**: 코루틴 기반, 외부 I/O 많은 앱에 적합  
- **gthread**: 스레드 병렬 ↑, GIL 영향  
- 손쉬운 스타트:
  ```bash
  gunicorn "wsgi:app" -k gthread --threads 8 -w 2 --bind :8000 --keep-alive 5 --max-requests 5000 --max-requests-jitter 500
  ```
- **max-requests**(재시작)로 **메모리 누수** 방지, **preload_app** 주의(DB 커넥션 복사 방지)

---

## 10.11 성능 체크리스트(운영)

- [ ] **핫 경로** 프로파일링으로 파악(Top N 핫 함수/쿼리)  
- [ ] **캐시 계층**: 앱 캐시(Flask-Caching) + HTTP 캐시(ETag/Last-Modified) + CDN  
- [ ] **키/무효화 전략** 문서화: 버전 프리픽스, write-through, delete_memoized  
- [ ] **스탬피드 방지**: add/락, grace 기간(dogpile)  
- [ ] **압축**: Nginx/CDN에서 Brotli/Gzip, MIME 필터  
- [ ] **Keep-Alive/풀링**: DB/HTTP 타임아웃/재시도/풀 크기 조정  
- [ ] **쿼리/인덱스**: 슬로우쿼리 로깅, N+1 방지(selectinload), 적절한 인덱스  
- [ ] **트레이싱/메트릭**: OpenTelemetry, 레이턴시/오류율/써킷 상태  
- [ ] **대용량 전송**: send_file(conditional) / X-Accel-Redirect / Signed URL  
- [ ] **스케일/리소스**: 워커/스레드/코루틴 적정치, CPU/메모리/FD 모니터링

---

## 10.12 흔한 안티패턴

- **캐시 키에 버전 미포함** → 스키마 변경 시 쓰레기 데이터 반환  
- **무분별한 장기 TTL** → 핫픽스 반영 지연, “유령 버그”  
- **앱에서 이미지/비디오 재압축** → CPU 낭비, 프록시/CDN으로 이관할 것  
- **HTTP 풀/타임아웃 없음** → 외부 API 지연이 전체를 막음  
- **프로파일링 없이 미리 최적화** → 엉뚱한 곳에 시간 투입  
- **대용량 파일을 메모리에 모두 올려 전송** → OOM 위험  
- **ETag를 DB 쿼리 결과 해시로 매 요청 계산** → 오히려 느려짐(사전 저장/버전 필드 사용)

---

## 10.13 미니 레퍼런스(붙여넣기)

### 10.13.1 캐시 초기화

```python
from flask_caching import Cache
cache = Cache(config={
    "CACHE_TYPE": "RedisCache",
    "CACHE_REDIS_URL": "redis://127.0.0.1:6379/3",
    "CACHE_KEY_PREFIX": "myapp:",
    "CACHE_DEFAULT_TIMEOUT": 300,
})
cache.init_app(app)
```

### 10.13.2 뷰 캐시

```python
@cache.cached(timeout=60, key_prefix=lambda: f"view:{request.full_path}")
def view(): ...
```

### 10.13.3 memoize 무효화

```python
cache.delete_memoized(func)                 # 전체
cache.delete_memoized(func, arg1, arg2)     # 특정 인자
```

### 10.13.4 Flask-Compress

```python
from flask_compress import Compress
Compress(app)
```

### 10.13.5 requests 풀/재시도

```python
adapter = HTTPAdapter(pool_connections=20, pool_maxsize=50, max_retries=Retry(total=3))
session.mount("https://", adapter)
```

### 10.13.6 werkzeug profiler

```python
app.wsgi_app = ProfilerMiddleware(app.wsgi_app, profile_dir="./profiles")
```

### 10.13.7 OpenTelemetry 부트스트랩

```python
from app.observability.otel import setup_tracing
setup_tracing(app)
```

### 10.13.8 스트리밍 응답

```python
return Response(iter(lambda: f.read(262144), b""), mimetype="application/octet-stream")
```

---

## 10.14 마무리

이 장에서는 **앱 캐시(Flask-Caching)** 의 실전 사용법과 **무효화/스탬피드 방지**를 다루고, **HTTP 캐시(ETag/조건부 요청)** 로 브라우저·CDN까지 레이어링하는 방법을 보았다. 또한 **압축(Gzip/Brotli)**·**Keep-Alive**·**커넥션 풀(DB/HTTP)** 로 전송/외부 I/O 비용을 줄이고, **werkzeug profiler/cProfile** 과 **OpenTelemetry** 로 **어디가 느린지 “보이게”** 만드는 접근을 정리했다. 마지막으로 **대용량 파일 스트리밍/Range/프록시 오프로딩**까지 실무 팁을 포함했다.
