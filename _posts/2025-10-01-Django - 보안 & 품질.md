---
layout: post
title: Django - 보안 & 품질
date: 2025-10-01 22:25:23 +0900
category: Django
---
# 6. 보안 & 품질

## A. Django 보안 베스트 — CSRF / XSS / Clickjacking, Host / SSL / HSTS, Secret 관리

### A-1. CSRF(Cross-Site Request Forgery)

- **Django 기본 제공**: `CsrfViewMiddleware` + 템플릿 {% raw %}`{% csrf_token %}`{% endraw %}.
- **서버 렌더링 폼**: {% raw %}`<form method="post">{% csrf_token %}…</form>`{% endraw %}.
- **AJAX/HTMX/SPA**:
  - **쿠키에서 토큰 읽기 → 헤더 전송** (`X-CSRFToken`).
  - SameSite, CORS 정책과 함께 설계.

{% raw %}
```html
<!-- 템플릿 폼 -->
<form method="post">
  {% csrf_token %}
  <!-- fields ... -->
</form>
```
{% endraw %}

```javascript
// fetch 예시 (쿠키 기반 세션)
function getCookie(name) {
  return document.cookie.split('; ').find(r => r.startsWith(name+'='))?.split('=')[1];
}
fetch('/api/endpoint/', {
  method: 'POST',
  headers: { 'X-CSRFToken': getCookie('csrftoken') },
  credentials: 'include',
  body: JSON.stringify({a: 1})
});
```

```python
# settings/prod.py (권장)
CSRF_COOKIE_SECURE = True
CSRF_COOKIE_SAMESITE = "Lax"  # 크로스 사이트 POST가 필요하면 'None' + Secure
```

> **주의**: 세션 인증 + CORS + SPA 조합에서는 **쿠키 SameSite=None + Secure** 와 **CSRF 토큰 전송**을 함께 고려.

---

### A-2. XSS(Cross-Site Scripting)

- Django 템플릿은 기본 **자동 이스케이프**. `|safe` 남용 금지.
- **사용자 입력을 HTML로 렌더**해야 할 때: **화이트리스트 기반 Sanitizer**(Bleach 등).
- API/JSON 응답은 문자열로 직렬화되어 비교적 안전하지만, **DOM 조작 시 innerHTML 대입 금지**.

```python
# HTML Sanitizing (예: Bleach)
pip install bleach
```

```python
# apps/common/sanitize.py
import bleach

ALLOWED_TAGS = ["b", "i", "strong", "em", "p", "ul", "ol", "li", "a", "br"]
ALLOWED_ATTRS = {"a": ["href", "title", "rel"]}
def clean_html(html: str) -> str:
    return bleach.clean(html, tags=ALLOWED_TAGS, attributes=ALLOWED_ATTRS, strip=True)
```

---

### A-3. Clickjacking

```python
# settings.py
MIDDLEWARE += ["django.middleware.clickjacking.XFrameOptionsMiddleware"]
X_FRAME_OPTIONS = "DENY"  # 또는 'SAMEORIGIN'
```

별도 페이지에만 iframe 허용하려면 **응답 헤더를 부분적으로 변경**.

```python
from django.views.decorators.clickjacking import xframe_options_exempt

@xframe_options_exempt
def preview(request):
    ...
```

---

### A-4. Host 검증 / SSL / HSTS / 보안 헤더

```python
# settings/prod.py
ALLOWED_HOSTS = ["example.com", "www.example.com"]

SECURE_SSL_REDIRECT = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True

SECURE_HSTS_SECONDS = 60*60*24*30
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

SECURE_REFERRER_POLICY = "strict-origin-when-cross-origin"
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_BROWSER_XSS_FILTER = True  # 일부 브라우저 의존, 추가 방어
```

**Nginx** 에서 `Strict-Transport-Security`/`X-Content-Type-Options`/`Referrer-Policy` 등도 세팅해 **이중화** 가능.

---

### A-5. Content Security Policy(CSP) (권장)

- XSS 위험을 줄이는 **가장 강력한 헤더**.
- 점진 도입: **Report-Only** → 로그/튜닝 → **Enforce**.

```python
# 간단한 미들웨어
class CSPMiddleware:
    def __init__(self, get_response): self.get_response = get_response
    def __call__(self, request):
        res = self.get_response(request)
        res["Content-Security-Policy"] = (
            "default-src 'self'; img-src 'self' data:; script-src 'self'; style-src 'self' 'unsafe-inline'"
        )
        return res
```

> 외부 리소스(CDN/Analytics)가 많을수록 정책이 복잡해지므로 **Nonce 기반** 도입 고려.

---

### A-6. Secret 관리 (환경변수/Key Vault)

- `.env`/환경변수 + **런타임 주입**(12-factor).
- 운영 비밀은 **클라우드 시크릿 매니저**(AWS Secrets Manager, GCP Secret Manager) 사용 권장.
- **키 회전** 가능하도록 코드를 작성.

```python
# settings/base.py
import os
SECRET_KEY = os.environ["DJANGO_SECRET_KEY"]
DATABASES["default"]["PASSWORD"] = os.environ["DB_PASSWORD"]
```

> 레포지토리에 Secret 포함 금지. **git-secrets/commit hooks**로 유출 방지.

---

## B. 입력 검증 & 파일 업로드 보안 — MIME / 확장자 / 바이러스 스캔 전략

### B-1. 일반 입력 검증

- **서버에서 재검증**: 클라이언트 유효성 검사를 신뢰하지 말 것.
- 폼/Serializer에서 `clean_/validate_` 로 **문자열 길이/형식** 검증.
- **정규식** 사용 시 **ReDoS** 방지(비효율 패턴 회피, 타임아웃).

```python
# 이메일/전화 등 정규식 검사 예 (Serializer)
from rest_framework import serializers
import re

PHONE_RE = re.compile(r"^\+?[0-9\- ]{7,20}$")
class ProfileSerializer(serializers.Serializer):
    phone = serializers.CharField()
    def validate_phone(self, v):
        if not PHONE_RE.match(v):
            raise serializers.ValidationError("전화번호 형식이 올바르지 않습니다.")
        return v
```

---

### B-2. 파일 업로드 위협 모델

- **과대 파일/Zip bomb** → 자원 고갈.
- **악성 코드**(예: 매크로, PE, 스크립트) → 서버/사용자 공격.
- **콘텐츠 스니핑**: 브라우저가 MIME을 재해석 → XSS/다운로드 실행.
- **경로 조작**: 파일명에 경로 포함(`../`) → 임의 위치 저장.

#### 방어 전략(요약):

1) **크기 제한**: 폼/서버/리버스 프록시 레벨에서 최대 바이트 제한.  
2) **확장자 + MIME + 실제 포맷 3중 검증**.  
3) **안전한 저장 경로/파일명 정규화**, 사용자 제공 파일명은 메타로만 보존.  
4) **바이러스 스캔**(ClamAV 등) + **격리/승인 후 공개**.  
5) **서명 URL(프라이빗)** + **다운로드 시 Content-Disposition** 로 인라인 실행 차단.  
6) 이미지 처리 시 **Pillow 폭탄 방지**(픽셀 제한).

---

### B-3. 구현 스니펫 — Django ModelForm + 튜닝

```python
# apps/assets/models.py
from django.db import models
def upload_to(instance, filename):
    return f"uploads/{instance.pk or 'new'}/{filename}"

class Document(models.Model):
    file = models.FileField(upload_to=upload_to)
    uploaded_at = models.DateTimeField(auto_now_add=True)
    size = models.PositiveBigIntegerField(default=0)
    content_type = models.CharField(max_length=80, blank=True)
```

```python
# apps/assets/forms.py
from django import forms
from .models import Document
from django.core.exceptions import ValidationError

ALLOWED_EXT = {".pdf", ".png", ".jpg", ".jpeg"}
MAX_MB = 10

class DocumentForm(forms.ModelForm):
    class Meta:
        model = Document
        fields = ["file"]

    def clean_file(self):
        f = self.cleaned_data["file"]
        # 1) 크기 제한
        if f.size > MAX_MB * 1024 * 1024:
            raise ValidationError(f"{MAX_MB}MB 이하만 업로드 가능합니다.")
        # 2) 확장자
        import os
        ext = os.path.splitext(f.name)[1].lower()
        if ext not in ALLOWED_EXT:
            raise ValidationError("허용되지 않는 확장자입니다.")
        # 3) 콘텐츠 타입
        ct = getattr(f, "content_type", "") or ""
        if not ct:
            raise ValidationError("Content-Type 확인 불가")
        if ext in {".png", ".jpg", ".jpeg"} and not ct.startswith("image/"):
            raise ValidationError("이미지 MIME이 아닙니다.")
        return f
```

---

### B-4. 실제 포맷 판독 + 이미지 폭탄 방지

```python
# apps/assets/validators.py
from django.core.exceptions import ValidationError
from PIL import Image, UnidentifiedImageError

def validate_image_safely(django_file):
    # 파일 포인터 보존
    pos = django_file.tell() if hasattr(django_file, "tell") else 0
    try:
        img = Image.open(django_file)
        img.verify()  # 파일 완전성 검사
        # 폭탄 방지: 픽셀 수 제한
        width, height = img.size
        if width * height > 50_000_000:  # 5천만 픽셀
            raise ValidationError("이미지 픽셀이 너무 큽니다.")
    except UnidentifiedImageError:
        raise ValidationError("유효한 이미지가 아닙니다.")
    finally:
        try: django_file.seek(pos)
        except Exception: pass
```

```python
# forms.py에서 사용
class ImageUploadForm(forms.ModelForm):
    def clean_file(self):
        f = self.cleaned_data["file"]
        validate_image_safely(f)
        return f
```

---

### B-5. 바이러스 스캔(ClamAV) + 격리

```python
# apps/assets/antivirus.py
import socket, struct

def clamav_scan(file_bytes: bytes, host="clamav", port=3310) -> bool:
    # 간단한 INSTREAM 프로토콜 (예: 클램AV 데몬)
    s = socket.socket()
    s.connect((host, port))
    s.sendall(b"zINSTREAM\0")
    chunk = 8192
    for i in range(0, len(file_bytes), chunk):
        part = file_bytes[i:i+chunk]
        s.sendall(struct.pack(">I", len(part)) + part)
    s.sendall(struct.pack(">I", 0))
    resp = s.recv(4096)
    s.close()
    return b"OK" in resp

# 사용 예 (업로드 직후, 저장 전/후 스캔)
def scan_in_memory(django_file) -> bool:
    pos = django_file.tell()
    data = django_file.read()
    safe = clamav_scan(data)
    try: django_file.seek(pos)
    except Exception: pass
    return safe
```

> 대형 파일은 **비동기 스캔**(큐에 넣고 “승인 후 공개”)으로 전환하고, 사용자에게 **“처리 중”** 상태를 안내.

---

### B-6. 안전한 다운로드 (Content-Disposition)

```python
from django.http import FileResponse, Http404
from django.utils.encoding import smart_str
from .models import Document

def download(request, pk):
    doc = Document.objects.get(pk=pk)
    if not request.user.is_authenticated:
        raise Http404()
    resp = FileResponse(doc.file.open("rb"), as_attachment=True, filename=smart_str(doc.file.name.split("/")[-1]))
    resp["Content-Type"] = doc.content_type or "application/octet-stream"
    resp["X-Content-Type-Options"] = "nosniff"
    return resp
```

---

## C. 테스트 — Unit / Integration, pytest-django 세팅, 팩토리/픽스처, 커버리지

### C-1. pytest-django 세팅

```bash
pip install pytest pytest-django pytest-cov factory_boy model_bakery
```

```
project/
  pytest.ini
  conftest.py
```

```ini
# pytest.ini
[pytest]
DJANGO_SETTINGS_MODULE = config.settings.test
python_files = tests.py test_*.py *_tests.py
addopts = -q --disable-warnings
```

```python
# config/settings/test.py
from .base import *
DEBUG = False
PASSWORD_HASHERS = ["django.contrib.auth.hashers.MD5PasswordHasher"]
EMAIL_BACKEND = "django.core.mail.backends.locmem.EmailBackend"
CELERY_TASK_ALWAYS_EAGER = True
CELERY_TASK_EAGER_PROPAGATES = True
```

---

### C-2. 팩토리(Factory Boy) / 모델 베이커(model_bakery)

```python
# apps/blog/factories.py
import factory
from django.contrib.auth import get_user_model
from .models import Post

User = get_user_model()

class UserFactory(factory.django.DjangoModelFactory):
    class Meta: model = User
    username = factory.Sequence(lambda n: f"user{n}")

class PostFactory(factory.django.DjangoModelFactory):
    class Meta: model = Post
    author = factory.SubFactory(UserFactory)
    title = factory.Faker("sentence")
    body = factory.Faker("text")
    is_public = True
```

```python
# tests/test_post.py
import pytest
from apps.blog.factories import PostFactory

pytestmark = pytest.mark.django_db

def test_post_str():
    p = PostFactory(title="Hi")
    assert "Hi" in str(p)
```

**model_bakery** 는 필드를 **자동 채우기**:

```python
from model_bakery import baker

def test_quick():
    post = baker.make("blog.Post", is_public=True)
    assert post.pk is not None
```

---

### C-3. 요청/응답 통합 테스트 (Client)

```python
# tests/test_views.py
import pytest
from django.urls import reverse
from apps.blog.factories import PostFactory, UserFactory

pytestmark = pytest.mark.django_db

def test_create_post_requires_login(client):
    res = client.post(reverse("blog:post_new"), {"title": "A", "body": "B"})
    assert res.status_code in (302, 403)

def test_list_page(client):
    PostFactory.create_batch(3)
    res = client.get(reverse("blog:list"))
    assert res.status_code == 200
    assert "게시글" in res.content.decode()
```

---

### C-4. DRF API 테스트 (APIClient)

```python
# tests/test_api.py
import pytest
from rest_framework.test import APIClient
from django.urls import reverse
from apps.api.models import Post
from apps.blog.factories import UserFactory

pytestmark = pytest.mark.django_db

def test_post_api_create():
    user = UserFactory()
    client = APIClient()
    client.force_authenticate(user=user)
    res = client.post(reverse("post-list"), {"title": "t", "body": "b", "is_public": True}, format="json")
    assert res.status_code == 201
    assert Post.objects.filter(title="t").exists()
```

---

### C-5. 픽스처(공통 자원) & 트랜잭션

```python
# conftest.py
import pytest
from apps.blog.factories import UserFactory

@pytest.fixture
def user(db):
    return UserFactory()
```

- `db`/`transactional_db` 마커로 DB 접근 보장.
- 파일/외부 서비스는 **Fake/Stub** 또는 **responses**(HTTP mocking) 활용.

```bash
pip install responses
```

```python
# 예: 외부 HTTP Mock
import responses, json

@responses.activate
def test_external_call():
    responses.add(
        responses.GET, "https://api.example.com/x",
        json={"ok": True}, status=200
    )
    # call function ...
```

---

### C-6. 커버리지(coverage)

```bash
pytest --cov=apps --cov-report=term-missing
```

`pyproject.toml` 또는 `setup.cfg`로 제외 패턴/목표치 설정:

```ini
# setup.cfg
[coverage:run]
branch = True
source = apps

[coverage:report]
fail_under = 80
show_missing = True
omit =
    */migrations/*
    */tests/*
```

---

### C-7. 성능 테스트(선택) & 회귀 테스트

- **Django Debug Toolbar** / **pytest-benchmark** 로 성능 회귀 추적.
- N+1 감지를 위한 **assertNumQueries**:

```python
from django.test.utils import CaptureQueriesContext
from django.db import connection

def test_queries(client, django_user_model):
    with CaptureQueriesContext(connection) as ctx:
        client.get("/expensive/")
    assert len(ctx.captured_queries) <= 10
```

---

## D. 로깅/모니터링 — Django 로거, 구조화 로그, Sentry/APM 연동

### D-1. Django 로깅 기본

```python
# settings/base.py
import os

LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")

LOGGING = {
  "version": 1,
  "disable_existing_loggers": False,
  "formatters": {
    "simple": {"format": "%(levelname)s %(name)s %(message)s"},
    "verbose": {"format": "%(asctime)s %(levelname)s %(name)s %(process)d %(thread)d %(message)s"},
    "json": {
      "format": '{"ts":"%(asctime)s","level":"%(levelname)s","logger":"%(name)s","msg":"%(message)s","request_id":"%(request_id)s"}'
    },
  },
  "filters": {
    "request_id": {"()": "apps.common.logging.RequestIDFilter"},
  },
  "handlers": {
    "console": {"class": "logging.StreamHandler", "formatter": "json", "filters": ["request_id"]},
  },
  "root": {"handlers": ["console"], "level": LOG_LEVEL},
}
```

```python
# apps/common/logging.py
import logging
from contextvars import ContextVar
request_id_var = ContextVar("request_id", default="-")

class RequestIDFilter(logging.Filter):
    def filter(self, record):
        record.request_id = request_id_var.get()
        return True
```

```python
# 미들웨어에서 Request-ID 주입 (요약)
class RequestIDMiddleware:
    def __init__(self, get_response): self.get_response = get_response
    def __call__(self, request):
        import uuid
        token = request_id_var.set(request.headers.get("X-Request-ID") or uuid.uuid4().hex)
        try:
            res = self.get_response(request)
            res["X-Request-ID"] = request_id_var.get()
            return res
        finally:
            request_id_var.reset(token)
```

---

### D-2. 구조화 로그(Structlog 선택지)

```bash
pip install structlog
```

```python
# settings/base.py
import structlog

structlog.configure(
  processors=[
    structlog.processors.TimeStamper(fmt="iso"),
    structlog.processors.add_log_level,
    structlog.processors.JSONRenderer(),
  ],
  context_class=dict,
  wrapper_class=structlog.make_filtering_bound_logger(LOG_LEVEL),
)

# 사용
import structlog
log = structlog.get_logger(__name__)

def do_something(user_id):
    log.info("biz_event", user_id=user_id, action="purchase")
```

> 구조화 로그는 **ELK/Cloud Logging** 등과 찰떡. **request_id, user_id, path, status** 등 **상관 키**를 지속 바인딩.

---

### D-3. Sentry(에러 수집)

```bash
pip install sentry-sdk
```

```python
# settings/prod.py
import sentry_sdk
from sentry_sdk.integrations.django import DjangoIntegration

sentry_sdk.init(
  dsn=os.environ.get("SENTRY_DSN"),
  integrations=[DjangoIntegration()],
  send_default_pii=False,  # PII 전송 여부 (규정 준수 고려)
  traces_sample_rate=0.1,  # APM 샘플 비율
)
```

- **환경/릴리즈** 태깅: `sentry_sdk.set_tag("service", "web")`, `sentry_sdk.set_release("1.2.3")`.
- **사용자 정보**는 개인정보 규정 준수 하에 최소화.
- **내부 예외 마스킹**: 4xx는 info 수준 로그, 5xx만 에러 보고 등 **샘플링/필터링**.

---

### D-4. APM/추적 — OpenTelemetry + OTLP(선택)

```bash
pip install opentelemetry-sdk opentelemetry-exporter-otlp opentelemetry-instrumentation-django
```

```bash
export OTEL_EXPORTER_OTLP_ENDPOINT="http://otel-collector:4317"
export OTEL_SERVICE_NAME="django-app"
python -m opentelemetry.instrumentation.django runserver
```

- HTTP 요청/DB 쿼리/외부 호출 트레이스 자동 수집.
- **Request-ID ↔ Trace-ID** 연동해 로그/트레이스를 상호 점프 가능하도록.

---

### D-5. 헬스체크/프로브 & 가동성

- `/healthz` 엔드포인트: **DB 핑/Redis 핑**.
- K8s/LB에 **readiness/liveness** 프로브 제공.

```python
# apps/core/health.py
from django.http import JsonResponse
from django.db import connection
from django.core.cache import cache

def healthz(request):
    try:
        with connection.cursor() as cur:
            cur.execute("SELECT 1")
        cache.set("health", "ok", 5)
        result = cache.get("health") == "ok"
    except Exception as e:
        return JsonResponse({"ok": False, "err": str(e)}, status=500)
    return JsonResponse({"ok": True})
```

---

## E. 운영 체크리스트 (요약)

**플랫폼/네트워크**
- [ ] **HTTPS 강제**, HSTS, 최신 TLS 설정  
- [ ] **ALLOWED_HOSTS** 및 프록시 헤더 정합(`SECURE_PROXY_SSL_HEADER`)  
- [ ] **WAF/CDN** 활용(레이어7 방어, Bot 차단)

**애플리케이션 보안**
- [ ] CSRF 토큰, SameSite/쿠키 보안, CORS 최소화  
- [ ] 템플릿 자동 이스케이프, Sanitizer 도입, **CSP** 단계적 적용  
- [ ] 파일 업로드 3중 검증(확장자/MIME/실제 포맷) + AV 스캔 + 프라이빗 저장  
- [ ] 관리자(Admin) 접근 보호(별도 서브도메인/IP 제한/2FA)

**비밀/권한**
- [ ] Secret은 **환경변수/Key Vault**, 키 회전 지원  
- [ ] 최소 권한 원칙(DB/S3/Redis), 보관 암호화

**품질/테스트**
- [ ] pytest-django, 팩토리/픽스처, 커버리지 기준(≥80%)  
- [ ] 통합/회귀 테스트(쿼리 수, 성능 측정)  
- [ ] Mock으로 외부 의존 분리, 계약 테스트 작성

**로깅/관측성**
- [ ] 구조화 로그 + Request-ID/Trace-ID  
- [ ] Sentry 에러 & APM 샘플링/필터  
- [ ] 헬스체크/알림/대시보드(SLO) 운영

---

## F. 부록: 보안/품질 스니펫 모음

### F-1. 관리자 페이지 보호 (IP/Basic Auth)

```python
# middleware 예시: /admin 에 대해 Basic Auth
import base64
from django.http import HttpResponse

class AdminBasicAuth:
    def __init__(self, get_response): self.get_response = get_response
    def __call__(self, request):
        if request.path.startswith("/admin"):
            auth = request.headers.get("Authorization", "")
            if not auth.startswith("Basic "):
                return self._challenge()
            user, pwd = base64.b64decode(auth.split()[1]).decode().split(":")
            if not (user == "admin" and pwd == "s3cret"):
                return self._challenge()
        return self.get_response(request)
    def _challenge(self):
        resp = HttpResponse(status=401)
        resp["WWW-Authenticate"] = 'Basic realm="Admin"'
        return resp
```

> 운영에서는 **IDP(SSO)** 와 연동하거나 **VPN**/IP Allowlist를 권장.

---

### F-2. 설정 값 검증 (django-environ + pydantic)

```python
pip install django-environ pydantic
```

```python
# config/settings/env.py
import environ
from pydantic import BaseModel, AnyUrl

env = environ.Env()
env.read_env()

class Settings(BaseModel):
    DEBUG: bool = False
    DJANGO_SECRET_KEY: str
    DATABASE_URL: AnyUrl
    REDIS_URL: AnyUrl

settings_model = Settings(
    DEBUG=env.bool("DEBUG", False),
    DJANGO_SECRET_KEY=env("DJANGO_SECRET_KEY"),
    DATABASE_URL=env("DATABASE_URL"),
    REDIS_URL=env("REDIS_URL"),
)
```

---

### F-3. 강제 HTTPS 리다이렉트(Nginx)

```nginx
server {
  listen 80;
  server_name example.com www.example.com;
  return 301 https://$host$request_uri;
}
```

---

### F-4. 비즈니스 오류 → 사용자 친화 메시지 맵핑(DRF 예외 핸들러)

```python
# apps/api/exceptions.py
from rest_framework.views import exception_handler

def unified_handler(exc, context):
    resp = exception_handler(exc, context)
    if not resp:
        return resp
    code = resp.status_code
    data = {"code": code, "message": "요청을 처리할 수 없습니다."}
    if "detail" in resp.data:
        data["message"] = resp.data["detail"]
    data["errors"] = resp.data
    resp.data = data
    return resp

# settings.py
REST_FRAMEWORK["EXCEPTION_HANDLER"] = "apps.api.exceptions.unified_handler"
```

---

## 마무리

- **보안 기본기(CSRF/XSS/CSP/HSTS/Secret 관리)** 를 **설정+코드+프록시** 레벨에서 중첩 방어로 적용하세요.  
- **입력/업로드** 는 3중 검증과 **바이러스 스캔/격리/서명 URL** 로 안전하게, **다운로드 nosniff/attachment** 로 마무리하세요.  
- **pytest-django + 팩토리 + 커버리지** 로 **회귀 없는 배포**를 습관화하세요.  
- **구조화 로그 + Sentry + APM** 으로 **가시성/추적성**을 확보해 장애를 빠르게 잡아내고, **SLO** 를 지키는 운영을 완성합니다.
