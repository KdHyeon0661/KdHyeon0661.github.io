---
layout: post
title: 네트워크보안 - 제로 트러스트 네트워킹
date: 2025-10-31 16:25:23 +0900
category: 네트워크보안
---
# 21. 제로 트러스트 네트워킹 (Zero Trust Networking)

> 목표  
> - **아이덴티티·디바이스·앱·데이터** 4축 정책을 **“네트워크 신뢰=0”** 전제에서 재설계한다.  
> - **ZTNA/SDP**로 기존 **사이트-to-사이트/VPN**의 과도한 평면 신뢰(Flat Trust)와 과권한을 제거하고,  
> - **지속 검증(Continuous Verification)**과 **위험 점수(Risk Score)**로 **세션 중**에도 권한을 자동 조정(업/다운/차단)한다.  
> - 실습은 **기존 VPN → ZTNA** 전환 로드맵을 **정책/구성/검증/마이그레이션** 순으로 제시한다.  
> ⚠️ 모든 예제는 **승인된 테스트 환경**에서 사용하자. 운영 반영 전 **Dry-run/카나리**와 **롤백 계획**이 필수다.

---

## 21.1 아이덴티티·디바이스·앱·데이터 정책

### 21.1.1 원칙 (3A + D)
1) **AuthN (누구인가?)**: IdP(SSO) + 강 MFA(피싱 저항형: FIDO2/Passkey).  
2) **AuthZ (무엇을 할 수 있는가?)**: **속성 기반(ABAC)** + **컨텍스트(시간·위치·디바이스 상태·위험)**.  
3) **Accounting (어떻게 썼는가?)**: 모든 **정책 결정·근거·세션 메타**를 로그로 보존(감사·재현).  
4) **Data (무엇을 보호하는가?)**: **분류/라벨**(Public/Confidential/Restricted), **목적 기반** 최소 권한.

### 21.1.2 정책 모델 (ABAC/PBAC) — OPA/Rego 예시
> “사내 CRM 읽기 권한”은 **역할**이 아니라 **속성+컨텍스트**로 허용한다.

**입력 컨텍스트(JSON; PEP→PDP)**
```json
{
  "user": {"id":"a@corp","dept":"sales","role":"rep","mfa":"fido2"},
  "device": {"managed":true,"os":"Windows","osver":"11.2","posture":{"edr":"ok","disk_encrypted":true,"firewall":"on"}},
  "request": {"app":"crm","action":"read","resource":"customer:1234"},
  "context": {"geo":"KR","network":"untrusted","time":"2025-11-01T12:01:03Z","risk":35}
}
```

**Rego 정책 (간소화)**
```rego
package zt.policy

default allow = false
default reason = "deny_by_default"

trusted_device {
  input.device.managed == true
  input.device.posture.edr == "ok"
  input.device.posture.disk_encrypted
  input.device.posture.firewall == "on"
}

strong_mfa { input.user.mfa == "fido2" }

low_risk { input.context.risk < 60 }

# CRM 읽기 허용 규칙 (부서 제한 + 강 MFA + 신뢰 디바이스 + 저위험)
allow {
  input.request.app == "crm"
  input.request.action == "read"
  input.user.dept == "sales"
  strong_mfa
  trusted_device
  low_risk
}

# 민감 데이터(PII) 접근은 사내망만 (예시)
deny_reason["requires_private_network"] {
  input.request.app == "crm"
  startswith(input.request.resource, "customer:")
  input.context.network != "private"
}
```

**Envoy ext_authz (PEP) 연동 스니펫**
```yaml
http_filters:
- name: envoy.filters.http.ext_authz
  typed_config:
    "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
    transport_api_version: V3
    with_request_body:
      max_request_bytes: 8192
      allow_partial_message: true
    grpc_service:
      envoy_grpc: { cluster_name: opa-authz }
    failure_mode_allow: false  # 실패 시 차단
```
> PEP(프록시/에이전트)가 **요청마다** OPA(PDP)에 질의 → 허용/거부와 **근거**(explain)를 로그에 남긴다.

### 21.1.3 디바이스 정책 (Posture)
- **등록/관리(MDM/EMM)**: 시리얼/UDID 바인딩, 분실/탈옥/루팅 차단.  
- **상태**: EDR/AV 최신, OS 패치, 디스크 암호화, 방화벽 온, 보안 부트.  
- **검증 주기**: 접속 직전 + 세션 중 **N분마다 재평가**. 불만족 시 **권한 다운** 또는 **차단**.  
- **증명**: mTLS(클라이언트 인증서), TPM 바인딩, Device-Bound Passkey.

**mTLS (Nginx) – 클라이언트 인증**
```nginx
server {
  listen 443 ssl;
  ssl_certificate      /etc/ssl/svc.crt;
  ssl_certificate_key  /etc/ssl/svc.key;
  ssl_client_certificate /etc/ssl/ca_bundle.pem;
  ssl_verify_client optional;  # 필요 경로만 require 로 강화

  location /crm/ {
    if ($ssl_client_verify != SUCCESS) { return 403; }
    proxy_pass http://crm_backend;
  }
}
```

### 21.1.4 앱 정책 (선별 노출)
- **애플리케이션 단위로 노출**: 네트워크 레벨이 아니라 **앱 프론트**에 PEP 배치.  
- **허용목록(Default-Deny)**: SSO/OIDC로 **발견된 앱만** 노출(Portal/Launcher).  
- **동적 세그먼테이션**: 사용자·디바이스·위험에 따라 **백엔드 서비스 접근 범위** 자동 축소.

**Kubernetes NetworkPolicy (L3/L4)**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata: { name: allow-crm-from-ztna, namespace: prod }
spec:
  podSelector: { matchLabels: { app: crm } }
  ingress:
  - from:
    - namespaceSelector: { matchLabels: { ztna: "edge" } }
    ports:
    - { protocol: TCP, port: 8080 }
  policyTypes: ["Ingress"]
```

**Cilium L7 (HTTP) 정책 예**
```yaml
apiVersion: "cilium.io/v2"
kind: CiliumNetworkPolicy
metadata: { name: crm-l7 }
spec:
  endpointSelector: { matchLabels: { app: crm } }
  ingress:
  - fromEndpoints:
    - matchLabels: { ztna: "edge" }
    toPorts:
    - ports: [{ port: "8080", protocol: TCP }]
      rules:
        http:
        - method: GET
          path: '^/api/customers/[0-9]+$'
```

### 21.1.5 데이터 정책 (분류/라벨/마스킹)
- **라벨링**: `data.classification: public/confidential/restricted` 메타.  
- **목적 제한**: API에 **목적 스코프**(e.g., `scope:crm:view`).  
- **마스킹/토큰화**: Role/Context에 따라 PII 일부 마스킹.

**예: 응답 필드 마스킹(게이트웨이 Lua)**
```lua
function mask_pii(body, role)
  if role ~= "analyst" then
    body["ssn"] = string.gsub(body["ssn"], "%d", "X")
  end
  return body
end
```

---

## 21.2 ZTNA/SDP·세그먼테이션

### 21.2.1 용어 정리
- **ZTNA (Zero Trust Network Access)**: 사용자/디바이스 중심으로 **앱 단위** 접근을 승인.  
- **SDP (Software-Defined Perimeter)**: 서비스 “앞에 보이지 않는 경계”를 만들고, 인증된 주체만 **동적 터널**로 연결.  
- **차이**: 둘 다 유사한 목표. 용어는 벤더/문맥에 따라 혼용되나 **핵심은 앱 단위 접근 + 지속 검증**.

### 21.2.2 참조 아키텍처
```
[User/Device] --(IdP SSO + ZT Client/mTLS)--> [ZT Edge/PEP] --(mTLS)--> [App Connectors] --> [Apps]
                               |                                         |
                          (OPA/Rego PDP)                           (Egress-only)
```
- **Edge/PEP**: 정책 집행, 세션 제어, 로깅.  
- **Connector**: 내부에서 **아웃바운드**로 Edge에 연결(인바운드 포트 개방 불필요).  
- **IdP**: OIDC/SAML, 그룹/속성 공급.  
- **PDP(OPA)**: 중앙 정책 결정(ABAC/PBAC).

### 21.2.3 마이크로세그멘테이션 (L3→L7)
- **동일 VLAN/서브넷 내부도 차단이 기본**(Pod/Workload 간)  
- **L3/L4**: NetPolicy/SG/NACL 최소 허용.  
- **L7**: 서비스 메시(Envoy/Istio) 또는 eBPF 데이터패스(Cilium)로 **메서드/경로**까지 제어.  
- **내부 mTLS**: 워크로드 간 **상호 TLS**로 스푸핑 제거.

**Istio AuthorizationPolicy (mTLS + 경로 제한)**
```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata: { name: crm-allow }
spec:
  selector: { matchLabels: { app: crm } }
  rules:
  - from:
    - source:
        principals: ["spiffe://corp.local/ns/edge/sa/ztna-proxy"]
    to:
    - operation: { methods: ["GET"], paths: ["/api/customers/*"] }
```

---

## 21.3 지속 검증·위험 점수

### 21.3.1 지속 검증(Continuous Verification)
- **세션 중 리-AuthZ**: 토큰 TTL 짧게(5–15분) + 백채널 평가(OPA 캐시 60–120초).  
- **컨텍스트 변화** (IP/ASN/Geo/시간/디바이스 상태/위험 신호) 감지 시 **즉시 재평가**.  
- **부정 시나리오**: 위험 점수 임계 초과 → **권한 하향(읽기만)** 또는 **세션 킬**.

**OPA 캐시 친화 결정(결정+근거 로깅)**
```rego
# 결정을 포함해 reason 필드로 근거 반환
allow_resp := {"allow": allow, "reason": reason}
```

### 21.3.2 위험 점수 모델 (예시)
- **신호**  
  - 로그인 위치/ASN 이례: +15  
  - 디바이스 EDR 장애: +30  
  - DoH/프록시 우회 탐지: +20  
  - JA3/UA 희귀: +10  
  - 관리자 리소스 접근 시도 실패 반복: +15  
- **임계치**  
  - `<40` 정상, `40–69` 제한(읽기 전용/다운스코프), `≥70` 차단+재인증.

**간단 파이썬 점수 함수**
```python
def risk_score(signals):
    s=0
    s += 15 if signals.get("geo_anom") else 0
    s += 30 if signals.get("edr_off") else 0
    s += 20 if signals.get("bypass_doh") else 0
    s += 10 if signals.get("rare_ja3") else 0
    s += min(30, 5*signals.get("admin_denies",0))
    return s
```

**정책 결합(PEP)**
```python
score = risk_score(signals)
if score >= 70: decision="deny"
elif score >= 40: decision="allow_readonly"
else: decision="allow"
```

### 21.3.3 토큰/세션 다운스코프
- **OAuth/OIDC Scopes**를 **세션 중** 재발급(Down-scoping)하여 쓰기 권한 제거.  
- **mTLS 재협상** 또는 **PEP 내부 상태**로 라우트/메서드 제한을 즉시 반영.

**Envoy RBAC 예 (다운스코프: GET만 허용)**
```yaml
- name: envoy.filters.http.rbac
  typed_config:
    "@type": type.googleapis.com/envoy.extensions.filters.http.rbac.v3.RBAC
    rules:
      action: ALLOW
      policies:
        readonly:
          permissions: [{ any: true }]
          principals:
            - metadata:
                filter: envoy.filters.http.jwt_authn
                path: [{ key: "claims" }, { key: "scope" }]
                value:
                  string_match: { exact: "crm.read" }
```

---

## 21.4 실습: VPN → ZTNA 전환 로드맵

> **목표**: 기존 **풀 터널 VPN** 접근을 **앱 단위 ZTNA**로 단계적 치환.  
> **출력물**: 정책(OPA), PEP(L7 프록시/게이트웨이), 커넥터, IdP 통합, 검증/측정 지표, 배포 플레이북.

### 21.4.1 단계 0 — 인벤토리 & 우선순위
- **애플리케이션 카탈로그**: URL/FQDN, 포트, 민감도, 소유자, 인증 방식.  
- **사용자 세그먼트**: 부서/역할/사용 패턴.  
- **기술 지도**: 어디에 PEP를 둘 것인가? (SaaS, 내부 Web, TCP 앱, RDP/SSH, DB).  
- **1차 대상**: 웹 기반 내부 앱(SSO 쉬움) → **CRM/위키/이슈트래커**.

### 21.4.2 단계 1 — 최소 기능 ZTNA (PoC/파일럿)
- **IdP(OIDC)**: 그룹/속성 발행, MFA.  
- **PEP(리버스 프록시)**: OIDC 로그인, 세션 관리, mTLS 옵션.  
- **PDP(OPA)**: ABAC 첫 규칙(부서=서비스, EDR=OK, 위험<60).  
- **Connector**: 방화벽 인바운드 미개방, 내부에서 **아웃바운드**로만 연결.

**Nginx OIDC (lua-resty-openidc 예시)**
```nginx
location / {
  access_by_lua_block {
    local opts = {
      redirect_uri_path = "/redirect_uri",
      discovery = "https://idp/.well-known/openid-configuration",
      client_id = "zt-edge", client_secret = "s3cr3t",
      scope = "openid email profile",
      renew_access_token_on_expiry = true
    }
    local res, err = require("resty.openidc").authenticate(opts)
    if err then ngx.exit(ngx.HTTP_UNAUTHORIZED) end
    ngx.req.set_header("X-User", res.id_token.email)
  }
  proxy_pass http://crm_backend;
}
```

**OPA 데모 서버 (Envoy-ExtAuthz gRPC) Docker Compose**
```yaml
services:
  opa:
    image: openpolicyagent/opa:latest-envoy
    command: ["run","--server","--addr=0.0.0.0:8181","--set=decision_logs.console=true","/policy"]
    volumes: ["./policy:/policy"]
  envoy:
    image: envoyproxy/envoy:v1.30-latest
    volumes: ["./envoy.yaml:/etc/envoy/envoy.yaml"]
    ports: ["8443:8443"]
```

### 21.4.3 단계 2 — 라우팅/세그먼테이션 수축
- **VPN 라우팅 축소(스플릿 터널)**: ZTNA로 이행된 앱은 VPN 경로에서 제거.  
- **내부 NetPolicy**: ZT Edge/Connector만 백엔드에 접속 허용.  
- **mTLS 내부화**: Edge ↔ Service 간 상호 TLS.

### 21.4.4 단계 3 — 지속 검증 & 다운스코프
- **디바이스 포스처 피드**(MDM/EDR API)를 PDP에 통합.  
- **위험 점수** 도입 → 읽기 전용 다운스코프/차단.  
- **세션 재평가**: 5–10분 주기 + 이벤트 기반(위험 급등).

**위험 이벤트 → OPA 데이터 입력 (Data API)**
```bash
curl -X PUT http://opa:8181/v1/data/context/risk/a@corp -d '{"score":72,"signals":["edr_off","geo_anom"]}'
```

### 21.4.5 단계 4 — 레거시/서버-대-서버 처리
- **중계형 ZTNA**: SSH/RDP/DB는 **게이트웨이/브로커**로 프록싱(기록/키 관리).  
- **서비스 계정/머신 아이덴티티**: SPIFFE/SVID, mTLS, 워크로드 ID.  
- **예외**: 레거시 장비는 **세분화된 세그먼트**에 격리 + Jump-host 방식.

### 21.4.6 단계 5 — 측정/운영/자동화
- **지표**:  
  - ZTNA 통과율(성공/거부), 거부 사유(정책/포스처/위험),  
  - 재평가 이벤트/다운스코프 비율,  
  - VPN 트래픽 감소율, 원복/장애율.  
- **플레이북**: 정책 배포 GitOps, 카나리(일부 그룹만), 자동 롤백(Health 실패 시).

**Kibana KQL 예 (거부 상위 사유)**
```kql
index:ztna-logs-* and decision:"deny"
| stats count() by reason, user, device.os
| sort by count desc
```

### 21.4.7 단계 6 — 사용자 경험(UX) & 변경관리
- **SSO 포털**: 승인된 앱만 타일로 노출, 즐겨찾기.  
- **자가 복구 경로**: 포스처 실패 시 **원인·해결 가이드** 즉시 제시(EDR 재시작, OS 업데이트 등).  
- **커뮤니케이션**: 마이그레이션 타임라인, FAQ, 비상 연락 채널.

---

## 부록 A. 정책 체크리스트 (운영 관점)
- [ ] **Default-Deny**: 앱/경로/메서드 단위 허용목록  
- [ ] **강 MFA**: 위험 시 Step-Up, 피싱 저항형(FIDO2)  
- [ ] **디바이스 포스처**: EDR/암호화/방화벽/OS 패치 연동  
- [ ] **mTLS**: Edge↔Service, SPIFFE/SVID 고려  
- [ ] **지속 검증**: 세션 중 재평가(주기+이벤트), 다운스코프  
- [ ] **감사/가시성**: 결정·근거 로그, 탐지 대시보드  
- [ ] **데이터 정책**: 라벨/마스킹/목적 스코프  
- [ ] **레거시 예외**: 격리 세그먼트, 게이트웨이 프록시  
- [ ] **장애 대비**: IdP/PEP 이중화, 실패 모드(폐쇄/개방) 정의  
- [ ] **DevSecOps**: 정책을 코드로(OPA/IaC), CI 회귀 테스트

---

## 부록 B. “VPN → ZTNA” 현실적 난관 & 팁
- **앱 발견 누락**: 프록시/DNS/Flow 기반 **실사용 Top-N**부터 이행.  
- **레거시 인증**: 헤더 기반/클라이언트 인증 프록시로 래핑.  
- **성능/지연**: Edge 지역 분산(Anycast/POP), TCP↔HTTP 변환 비용 관찰.  
- **오탐 차단**: “모니터링 모드(permit+log)” → “차단” 단계적 전환.  
- **운영조직 변화**: 네트워크팀+IDP팀+엔드포인트팀 **공동 운영 모델**로 재편.

---

## 요약
- **네트워크 신뢰를 제거**하고 **아이덴티티·디바이스·앱·데이터** 축으로 **세분화·맥락화**된 접근을 부여하라.  
- **ZTNA/SDP**는 **앱 단위 노출 + mTLS + 정책-as-code(OPA)**로 구현하고,  
- **지속 검증/위험 점수**로 **세션 중** 권한을 자동 조정한다.  
- 전환 로드맵은 **인벤토리→파일럿→세그먼트 수축→지속 검증→레거시 처리→지표/자동화** 순으로 밟고,  
- 모든 결정은 **근거 로그**와 **GitOps 정책 저장소**로 **재현 가능**해야 한다.