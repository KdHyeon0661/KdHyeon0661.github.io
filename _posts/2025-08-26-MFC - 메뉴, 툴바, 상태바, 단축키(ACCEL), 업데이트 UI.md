---
layout: post
title: MFC - 메뉴, 툴바, 상태바, 단축키(ACCEL), 업데이트 UI
date: 2025-08-26 14:25:23 +0900
category: MFC
---
# 메뉴 / 툴바 / 상태바: 단축키(ACCEL), 업데이트 UI(`ON_UPDATE_COMMAND_UI`) 기초 총정리

본 글은 **MFC 고전 UI 3종(메뉴·툴바·상태바)**와 **단축키(Accelerator)·UI 업데이트 메커니즘**을 **끝부분까지 빠짐없이** 설명합니다. SDI/MDI(문서/뷰)와 대화상자 기반 앱 모두에 적용되는 내용을 포함합니다. (설명 편의상 함수·매크로 이름은 `고정폭`으로 표기합니다.)

---

## 0) 큰 그림: “명령 ID” 하나로 4가지 입력 통합
MFC에서는 **하나의 명령 ID**(예: `ID_FILE_OPEN`)가 아래 **4개의 입력 경로**를 동시에 대표합니다.

1) **메뉴 항목** → `WM_COMMAND`  
2) **툴바 버튼** → `WM_COMMAND`  
3) **단축키(Accelerator)** → `WM_COMMAND`  
4) **상태바 힌트** → **문자열 리소스**의 “상태바 설명” 부분 사용

즉, “메뉴를 누르든/툴바를 클릭하든/단축키를 치든” **같은 ID**가 전달되어 **동일한 핸들러**가 실행됩니다. 이것이 MFC 명령 라우팅의 핵심 철학입니다.

---

## 1) 메뉴(Menu)

### 1-1. 리소스 에디터에서 만드는 법
- **리소스 뷰 → Menu → 새 메뉴** 생성.
- 항목마다 **Command ID**(예: `ID_FILE_OPEN`)를 부여.  
- **문자열 리소스**에 동일 ID의 문자열을 등록하면,  
  - **앞부분**: 메뉴 캡션(예: `&Open...`)  
  - **개행(`\n`) 이후**: **상태바 도움말 텍스트** (예: `Open a document`)  
  → 메뉴에 마우스를 올리면 상태바에 자동 표시됩니다(`OnSetMessageString` 메커니즘).

### 1-2. 액세스 키/구분선/서브메뉴
- `&` 문자로 **Alt + 문자** 액세스 키 설정(예: `&File` → Alt+F).  
- 구분선은 **Separator** 항목 사용.  
- 항목에 **Submenu**를 연결하면 드롭다운 구조 생성.

### 1-3. 명령 라우팅 순서
문서/뷰 기반 앱에서 **명령/업데이트**는 아래 순서로 핸들러를 찾습니다.

`활성 CView → CFrameWnd(프레임) → CDocument → CWinApp`

> 같은 ID의 핸들러가 여러 곳에 있으면 **먼저 찾은 쪽이 우선**합니다.  
> 데이터 조작은 `CDocument`, 화면 편집/도구는 `CView`, 전역 기능은 `CWinApp`가 자연스럽습니다.

### 1-4. 동적 메뉴/컨텍스트 메뉴
- **동적 메뉴**: `OnInitMenuPopup` 시점에 항목 삽입/제거 가능(단, 매 프레임 조작은 금물).  
- **컨텍스트 메뉴(우클릭)**: `TrackPopupMenu`로 화면 좌표에 표시. 컨텍스트 전용 ID도 **동일 라우팅**을 따릅니다.

### 1-5. 흔한 실수/체크포인트
- **ID 중복**: 의도하지 않은 핸들러 호출. ID 네이밍 규칙을 지키고 범위를 관리하세요.  
- **문자열 리소스 미등록**: 상태바 힌트가 비거나 이전 텍스트가 남습니다.  
- **대화상자 기반 앱**: 메뉴 업데이트가 자동으로 빈번하지 않으므로, 필요 시 **명시적 UI 업데이트**(아래 §5-4 참조)가 필요합니다.

---

## 2) 툴바(Toolbar)

### 2-1. 고전 `CToolBar` vs Feature Pack `CMFCToolBar`
- **`CToolBar`(클래식)**: 가볍고 전통적인 툴바. 이미지 스트립(비트맵) 기반.  
- **`CMFCToolBar`(Feature Pack)**: 테마/커스터마이즈/드롭다운/명령 관리가 강화된 현대식 툴바.  
  → **둘 중 하나**를 선택해 사용하는 것이 유지보수에 유리합니다(혼용 지양).

### 2-2. 생성·이미지·아이디 연결
- **리소스 에디터**에서 툴바 리소스 추가(버튼 순서/ID 지정).  
- 이미지 크기(전통적으로 16×16 또는 24×24)와 **DPI 스케일링**을 고려해 준비.  
- 버튼 ID는 **메뉴와 동일한 명령 ID**를 사용하면 **핸들러 공유**가 자동입니다.

### 2-3. 확장 스타일/툴팁/상태
- 확장 스타일(클래식): **플랫 모양**, **더블버퍼링** 등(Feature Pack은 각종 옵션 제공).  
- 툴팁은 **문자열 리소스**의 캡션/둘째 줄을 활용하거나 별도의 툴팁 텍스트를 할당.  
- 버튼 활성/비활성/체크 상태는 `ON_UPDATE_COMMAND_UI`에서 **CCmdUI**를 통해 제어(아래 §5).

### 2-4. DPI/테마/비활성 아이콘
- **고해상도**에서 흐릿함을 피하려면 **여러 스케일**(예: 100/150/200%) 이미지 준비 또는 벡터 아이콘 사용 가능한 툴킷 사용.  
- **비활성(Disabled) 상태** 아이콘을 별도로 준비하면 가독성↑(자동 디밍은 대비가 낮을 수 있음).  
- Feature Pack 사용 시 **Visual Manager**로 다크/현대 테마를 적용할 수 있습니다.

### 2-5. 드롭다운/스플릿 버튼(Feature Pack)
- `CMFCToolBarButton`의 **드롭다운**을 활용하면 메뉴와 툴바의 복합 UX를 제공.  
- 기본 버튼 클릭과 드롭다운 화살표 클릭을 **서로 다른 동작**으로 매핑 가능.

---

## 3) 상태바(Status Bar)

### 3-1. 구조와 “인디케이터” 개념
- 상태바는 보통 **여러 개의 “Pane(인디케이터)”**로 분할됩니다.  
  - `ID_SEPARATOR` : 가변 폭(주 메시지 영역)  
  - `ID_INDICATOR_CAPS/NUM/SCRL` : 키보드 상태 표시  
  - **사용자 정의 Pane**: 네트워크/진행률/모드 등

### 3-2. 텍스트 갱신
- **메뉴 항목 위에 마우스를 올리면** 해당 ID의 문자열 리소스 **둘째 줄**이 자동 표시(`OnSetMessageString`).  
- 그 외 상황에서는 `SetPaneText`로 특정 Pane의 텍스트를 갱신합니다.  
- 장시간 표시가 필요 없는 **일시 메시지**는 타이머로 **초 뒤 초기화**하는 패턴이 깔끔합니다.

### 3-3. 사용자 경험(UX) 팁
- **오버플로** 방지: 긴 텍스트는 줄임표 처리하고 핵심 정보만 남기기.  
- **접근성**: 색/아이콘만으로 상태 전달을 피하고 **텍스트** 또는 **툴팁**을 병행.  
- **진행 상태**는 상태바보다는 **모달·모델리스 진행 대화상자**나 **리본/툴바 진행 UI**가 더 눈에 띕니다.

---

## 4) 단축키(Accelerator, ACCEL)

### 4-1. 작동 원리(메시지 루프)
- 메시지 루프에서 `TranslateAccelerator`가 **키 입력을 명령(=ID)**로 변환합니다.  
- 변환된 명령은 **메뉴/툴바 클릭과 동일**하게 라우팅됩니다.

### 4-2. 리소스 에디터에서 추가하기
- **Accelerator 리소스**를 추가하고 각 항목에  
  - 키 조합(예: `Ctrl+O`)  
  - **명령 ID**(예: `ID_FILE_OPEN`)  
  - 플래그(Alt/Ctrl/Shift, VirtKey 등)를 지정.  
- **이미 존재하는 메뉴/툴바의 ID**를 그대로 재사용하면 핸들러를 공유합니다.

### 4-3. 우선순위/충돌
- **액셀러레이터가 먼저** 명령으로 변환되며, **텍스트 입력 컨트롤 포커스**일 때는 일부 키가 컨트롤에 소비될 수 있습니다(예: `Ctrl+C` 복사).  
- **중복 키**를 지정하면 예기치 않은 명령이 실행될 수 있으니, **앱 전반에서 일관성**을 확인하세요.

### 4-4. 지역화/키보드 레이아웃
- 비영문 키보드(한글/IME) 환경에서 **문자 키 가속기**는 혼선을 줄 수 있습니다.  
- **기능 키/조합 키 중심**의 가속기 구성이 안전합니다.

---

## 5) 업데이트 UI: `ON_UPDATE_COMMAND_UI`의 모든 것

### 5-1. 무엇을 하는가
- 메뉴/툴바/리본 항목의 **활성화(Enable)**, **체크/라디오(상태)**, **캡션(Text)** 등을 **실시간**으로 갱신합니다.  
- 핸들러의 시그니처는 `void OnUpdateX(CCmdUI* pCmdUI)` 형태이며, 내부에서  
  - `pCmdUI->Enable(BOOL)`  
  - `pCmdUI->SetCheck(int)` 또는 `SetRadio(BOOL)`  
  - `pCmdUI->SetText(LPCTSTR)`  
  를 호출합니다.

### 5-2. 언제 호출되는가
- 프레임 기반 앱(SDI/MDI)에서는 **Idle 시점**(메시지가 없을 때) 자동 호출됩니다.  
- 메뉴가 펼쳐질 때에도 해당 항목의 `OnUpdate…`가 호출되어 **열기 직전 상태**를 반영합니다.

### 5-3. 어디에 두는가(라우팅 순서 동일)
- 명령 라우팅과 동일한 순서(활성 `CView` → `CFrameWnd` → `CDocument` → `CWinApp`).  
- **상태 판단 주체**에 따라 **핸들러 위치**를 결정하세요.  
  - 예: 편집 가능 여부는 `CView`, 문서 변경 여부는 `CDocument` 등.

### 5-4. 대화상자 기반 앱의 특수성
- 대화상자 앱은 **Idle 기반 자동 업데이트가 약함**.  
- 일반적으로 **이벤트 변화 시점**에 `UpdateDialogControls(this, FALSE)`를 **직접 호출**하여 버튼/메뉴 상태를 재평가합니다.  
- 너무 자주 호출하면 성능 저하 → **상태 변화가 발생했을 때만** 호출하는 것이 좋습니다.

### 5-5. 패턴별 모범 사례
- **Enable/Disable**: 기능 사용 가능 상태를 **명확한 조건식**으로 빠르게 평가.  
- **Toggle/Check**: 현재 모드/옵션을 **체크**로 표현(저장 아이콘 대신 **상태 표시**가 더 직관적일 때).  
- **Radio 그룹**: 동일 그룹의 여러 항목에 대해 **하나만 `SetRadio(TRUE)`**, 나머지는 `FALSE`.  
- **Text 변경**: 빈번하면 가독성↓ → **상태바**나 **툴팁**으로 옮기는 것을 고려.

### 5-6. 성능/안정성 주의
- `ON_UPDATE_COMMAND_UI`는 **빈번히 호출**됩니다(특히 프레임 앱).  
- **I/O, DB, 복잡한 계산 금지**: 캐시된 상태 변수를 읽는 **O(1) 로직**만 수행하세요.  
- 예외 발생 시 UI가 멎은 듯 보일 수 있으므로, 내부에서 **예외/에러 처리**는 철저하게.

---

## 6) 통합 작동 시나리오(현업 관점)

1) 사용자가 **문서를 열어 편집** → 앱 내부 상태 `isDirty = true`.  
2) Idle 타임에 `ON_UPDATE_COMMAND_UI`가 호출됨 →  
   - `ID_FILE_SAVE`에 대해 `pCmdUI->Enable(isDirty)` → **저장 버튼 활성화**  
   - `ID_VIEW_STATUSBAR`에 대해 `pCmdUI->SetCheck(isStatusBarVisible)` → **메뉴 체크 표시**  
3) 사용자가 **Ctrl+S**(가속기) 또는 **툴바 저장 버튼** 또는 **메뉴 저장** 클릭 →  
   - 모두 `ID_FILE_SAVE`로 라우팅 → **동일 핸들러** 실행  
4) 성공적으로 저장하면 `isDirty = false` → 다음 Idle에 **저장 버튼 비활성화**  
5) 메뉴에 마우스 오버 시, 문자열 리소스의 둘째 줄이 **상태바에 힌트**로 표시

---

## 7) 디버깅/트러블슈팅

- **업데이트가 안 된다**  
  - 프레임 앱: `ON_UPDATE_COMMAND_UI`가 정의된 **클래스와 라우팅 경로**가 맞는지 확인.  
  - 대화상자 앱: **이벤트 후 `UpdateDialogControls` 호출** 누락 여부 확인.
- **툴바 버튼만 비활성**  
  - 동일 ID의 `ON_UPDATE_COMMAND_UI`가 **툴바/메뉴 모두**에 적용되지만, 일부 프레임/Feature Pack 구성에서는 **메뉴 펼침 시점**에만 평가될 수 있습니다. **Idle 호출**이 동작하는지 점검.
- **단축키가 먹지 않는다**  
  - **Accelerator 테이블**이 프레임에 올바르게 연결되어 있는지, 포커스가 **에디트 컨트롤**에 있지 않은지 확인.  
  - 이미 **다른 가속기**가 선점했는지(중복) 체크.
- **상태바 힌트가 안 보임**  
  - 문자열 리소스의 **개행(`\n`)** 이후 설명 문구가 비어있지 않은지 확인.  
  - 커스텀 상태바 사용 시 `OnSetMessageString` 메시지 흐름을 가로막지 않았는지 점검.

---

## 8) 품질 체크리스트

- 명령 ID/문자열 리소스/가속기 테이블 간 **ID 일관성 유지**  
- `ON_UPDATE_COMMAND_UI`는 **빠르고 결정적**인 로직만 수행  
- 대화상자 앱은 **명시적 UI 업데이트 트리거**를 도입  
- 툴바/아이콘은 **DPI 대비**(여러 스케일 or 벡터)  
- 상태바 텍스트는 **핵심 정보 우선**, 과도한 길이 금지  
- 단축키는 **표준 관례**(Ctrl+N/O/S, Ctrl+Z/Y/C/V 등)를 가능한 준수  
- 지역화 시 **액세스 키(`&`) 충돌** 점검(메뉴 전반 일관성)

---

## 9) 요약

- **메뉴·툴바·단축키**는 **하나의 명령 ID**로 수렴하며,  
- **상태바**는 그 명령의 **설명 텍스트**를 사용자에게 피드백합니다.  
- **`ON_UPDATE_COMMAND_UI`**는 “지금 이 순간, 이 명령을 보여주고/활성화할지/체크할지”를 결정하는 핵심 후크입니다.  
- 프레임 앱은 **Idle 자동 업데이트**, 대화상자 앱은 **명시적 트리거**가 실전 포인트입니다.