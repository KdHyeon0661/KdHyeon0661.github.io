---
layout: post
title: 파이썬 심화 - 메타프로그래밍 (5)
date: 2025-12-03 15:30:23 +0900
category: 파이썬 심화
---
# 메타프로그래밍 (5)

## 클래스 설계의 원칙

파이썬에서 견고한 클래스를 설계할 때는 몇 가지 핵심 원칙을 준수해야 합니다. 이러한 원칙들은 코드의 가독성, 유지보수성, 확장성을 보장하며, 협업 환경에서 특히 중요합니다.

### 1. 클래스의 명시적 정의와 강제

클래스는 항상 명시적으로 정의되어야 하며, 특정 인터페이스나 동작을 강제해야 할 경우 추상 베이스 클래스(ABC)를 활용하는 것이 좋습니다.

```python
from abc import ABC, abstractmethod
from typing import Protocol

# 추상 베이스 클래스를 통한 인터페이스 강제
class Renderable(ABC):
    @abstractmethod
    def render(self) -> str:
        """객체를 문자열로 렌더링"""
        pass

# 프로토콜을 통한 구조적 서브타이핑
class Serializable(Protocol):
    def to_dict(self) -> dict:
        ...
    
    @classmethod
    def from_dict(cls, data: dict) -> 'Serializable':
        ...

class Shape(Renderable, Serializable):
    def __init__(self, color: str):
        self.color = color
    
    def render(self) -> str:
        return f"Shape with color {self.color}"
    
    def to_dict(self) -> dict:
        return {"color": self.color}
    
    @classmethod
    def from_dict(cls, data: dict) -> 'Shape':
        return cls(data["color"])
```

### 2. 클래스 멤버의 적절한 초기화

클래스 멤버는 생성자(`__init__`)에서 명시적으로 초기화해야 합니다. 타입 힌트를 사용하여 의도를 명확히 하고, 필수 매개변수와 선택적 매개변수를 구분하는 것이 중요합니다.

```python
from dataclasses import dataclass
from typing import Optional, List

# 데이터 클래스를 활용한 간결한 초기화
@dataclass
class UserProfile:
    username: str
    email: str
    age: Optional[int] = None
    preferences: List[str] = None
    
    def __post_init__(self):
        if self.preferences is None:
            self.preferences = []
    
    def add_preference(self, preference: str) -> None:
        self.preferences.append(preference)

# 전통적인 클래스에서의 명시적 초기화
class BankAccount:
    def __init__(
        self, 
        account_number: str, 
        owner: str,
        initial_balance: float = 0.0
    ):
        self.account_number = account_number
        self.owner = owner
        self._balance = initial_balance  # private 멤버
        self.transaction_history = []
    
    @property
    def balance(self) -> float:
        """잔액 조회 (읽기 전용 프로퍼티)"""
        return self._balance
```

### 3. 함수 주석을 활용한 다중 디스패치 구현

파이썬은 단일 디스패치를 기본으로 지원하지만, `functools.singledispatch`나 `multipledispatch` 라이브러리를 활용하여 다중 디스패치 패턴을 구현할 수 있습니다.

```python
from functools import singledispatch
from typing import Union

# 단일 디스패치를 활용한 함수 오버로딩
@singledispatch
def process_data(data):
    """기본 처리 함수"""
    raise NotImplementedError(f"지원되지 않는 타입: {type(data)}")

@process_data.register(str)
def _(data: str) -> str:
    """문자열 처리"""
    return f"문자열 처리: {data.upper()}"

@process_data.register(list)
def _(data: list) -> list:
    """리스트 처리"""
    return [str(item) for item in data]

@process_data.register(dict)
def _(data: dict) -> dict:
    """딕셔너리 처리"""
    return {k: str(v) for k, v in data.items()}

# 타입 힌트를 활용한 다중 인자 디스패치
def calculate_area(shape: Union['Circle', 'Rectangle'], scale: float = 1.0) -> float:
    """다양한 도형의 면적 계산"""
    if isinstance(shape, Circle):
        return shape.radius ** 2 * 3.14159 * scale
    elif isinstance(shape, Rectangle):
        return shape.width * shape.height * scale
    else:
        raise TypeError(f"지원되지 않는 도형 타입: {type(shape)}")
```

### 4. 프로퍼티 메서드 중복 방지

프로퍼티 메서드를 설계할 때는 DRY(Don't Repeat Yourself) 원칙을 준수해야 합니다. 데코레이터를 활용하여 중복을 제거하고, 캐싱을 통해 성능을 최적화할 수 있습니다.

```python
class TemperatureSensor:
    def __init__(self):
        self._raw_data = []
        self._celsius = None
        self._fahrenheit = None
    
    def update_sensor(self, raw_value: float) -> None:
        """센서 데이터 업데이트"""
        self._raw_data.append(raw_value)
        # 캐시 초기화
        self._celsius = None
        self._fahrenheit = None
    
    @property
    def celsius(self) -> float:
        """섭씨 온도 (캐싱 적용)"""
        if self._celsius is None:
            # 실제 계산 로직 (복잡한 변환이 있다고 가정)
            self._celsius = sum(self._raw_data[-10:]) / min(len(self._raw_data), 10)
        return self._celsius
    
    @property
    def fahrenheit(self) -> float:
        """화씨 온도 (다른 프로퍼티 재사용)"""
        if self._fahrenheit is None:
            self._fahrenheit = self.celsius * 9/5 + 32
        return self._fahrenheit
    
    def reset_cache(self) -> None:
        """캐시 초기화 메서드"""
        self._celsius = None
        self._fahrenheit = None
```

## 고급 클래스 설계 패턴

### 믹스인(Mixin) 클래스를 활용한 기능 조합

```python
class JSONSerializableMixin:
    def to_json(self) -> str:
        import json
        return json.dumps(self.to_dict())
    
    def to_dict(self) -> dict:
        """하위 클래스에서 구현해야 함"""
        raise NotImplementedError

class LoggableMixin:
    def log(self, message: str) -> None:
        import logging
        logging.info(f"[{self.__class__.__name__}] {message}")

class Product(JSONSerializableMixin, LoggableMixin):
    def __init__(self, name: str, price: float):
        self.name = name
        self.price = price
    
    def to_dict(self) -> dict:
        return {
            "name": self.name,
            "price": self.price,
            "class": self.__class__.__name__
        }
```

### 디스크립터(Descriptor)를 활용한 속성 제어

```python
class ValidatedAttribute:
    """데이터 검증을 위한 디스크립터"""
    def __init__(self, validator=None, default=None):
        self.validator = validator
        self.default = default
        self.data = {}
    
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        return self.data.get(id(obj), self.default)
    
    def __set__(self, obj, value):
        if self.validator and not self.validator(value):
            raise ValueError(f"유효하지 않은 값: {value}")
        self.data[id(obj)] = value

class Person:
    age = ValidatedAttribute(lambda x: 0 <= x <= 150)
    email = ValidatedAttribute(lambda x: '@' in x if x else True)
    
    def __init__(self, name: str, age: int, email: str = None):
        self.name = name
        self.age = age  # ValidatedAttribute.__set__ 호출
        self.email = email  # ValidatedAttribute.__set__ 호출
```

## 결론

효율적인 파이썬 클래스 설계는 다음과 같은 요소에 주의해야 합니다:

1. **명확한 인터페이스 정의**: 추상 베이스 클래스나 프로토콜을 활용하여 클래스의 의도를 명확히 전달하세요.
2. **타입 안전성**: 타입 힌트를 적극 활용하여 코드의 의도를 문서화하고 정적 분석 도구의 지원을 받으세요.
3. **초기화의 명확성**: 모든 멤버 변수를 `__init__`에서 명시적으로 초기화하고, 데이터 클래스나 디스크립터를 활용하여 보일러플레이트 코드를 줄이세요.
4. **다형성의 적절한 활용**: 단일/다중 디스패치 패턴을 이해하고 상황에 맞게 적용하세요.
5. **프로퍼티의 적절한 사용**: 계산 비용이 큰 연산이나 자주 접근하는 데이터에 대해 프로퍼티와 캐싱을 활용하세요.
6. **상속보다는 조합**: 믹스인 패턴을 활용하여 기능을 모듈화하고 다중 상속의 복잡성을 관리하세요.

이러한 원칙들을 준수하면 더욱 견고하고 유지보수하기 쉬운 객체지향 코드를 작성할 수 있으며, 대규모 프로젝트에서도 안정적으로 동작하는 클래스 구조를 구축할 수 있습니다.