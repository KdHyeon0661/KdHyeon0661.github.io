---
layout: post
title: MFC - RAII, 스마트 포인터로 리소스 안전성 확보
date: 2025-09-11 18:25:23 +0900
category: MFC
---
# RAII / 스마트 포인터로 리소스 안전성 확보

**대상**: Win32/MFC/콘솔/서버 모든 C++ 프로젝트
**목표**:
- 예외/조기 반환/에러에도 **자동 정리**되도록 리소스 수명 설계
- `std::unique_ptr / std::shared_ptr / std::weak_ptr`와 **커스텀 삭제자**로 C API(Win32/GDI/COM 등) 안전 래핑
- **소유권(ownership) 모델**을 코드로 명시하고, **성능/메모리/스레드** 측면 트레이드오프 이해
- **Rule of Zero / Move-only / PImpl / Scope Guard / unique_resource**까지 실전 패턴 총망라

> TL;DR
> 1) **단일 소유 = `unique_ptr`**(기본값), 2) **공유 소유가 정말 필요할 때만 `shared_ptr`**, 3) 순환은 **`weak_ptr`**로 끊기, 4) C 핸들은 **커스텀 Deleter**로 감싸기, 5) 실패 가능 작업은 **임시 빌드 → 교체** 로 강한 예외 보장.

---

## 0. 왜 RAII 인가? (문제 정의 → 해법)

### 0-1. 수동 정리의 고질적 문제
```cpp
void raw() {
    HANDLE h = ::CreateEventW(nullptr, FALSE, FALSE, nullptr);
    if (!h) return;            // 누수 위험 ① (조기 반환)
    do_something();
    if (failed()) return;      // 누수 위험 ②
    ::CloseHandle(h);          // 정상 경로에서만 정리
}
```
- 예외/return 분기에 따라 **정리 경로가 누락**되기 쉽습니다.
- 여러 리소스를 쌓아가며 처리하면 **goto/중첩 if**가 난무하고, 유지보수가 지옥.

### 0-2. RAII의 해법
- **생성자에서 획득(acquire)** → **소멸자에서 해제(release)**.
- 스코프(수명)가 끝나는 순간 **컴파일러가 자동 호출** → 예외/return과 무관하게 **정리 보장**.

```cpp
struct Handle {
    HANDLE h{};
    explicit Handle(HANDLE hh) : h(hh) {}
    ~Handle(){ if (h && h!=INVALID_HANDLE_VALUE) ::CloseHandle(h); }
    Handle(const Handle&) = delete;
    Handle& operator=(const Handle&) = delete;
    Handle(Handle&& o) noexcept : h(std::exchange(o.h, nullptr)) {}
    Handle& operator=(Handle&& o) noexcept {
        if (this != &o) { if (h && h!=INVALID_HANDLE_VALUE) ::CloseHandle(h); h = std::exchange(o.h, nullptr); }
        return *this;
    }
};
```
- 리소스 **소유권을 정확히 표현**하고, move-only로 **이중 해제/복사 누수**를 원천 차단.

---

## 1. `std::unique_ptr<T, Deleter>` — “단일 소유”의 표준

### 1-1. 기본 사용
```cpp
auto p = std::make_unique<int>(42);
*p = 100;
// 스코프 종료 → 자동 delete
```

### 1-2. 커스텀 삭제자(Win32/GDI/COM)
```cpp
// ① HANDLE (CloseHandle)
struct HandleCloser { void operator()(HANDLE h) const noexcept { if (h && h!=INVALID_HANDLE_VALUE) ::CloseHandle(h); } };
using unique_handle = std::unique_ptr<std::remove_pointer_t<HANDLE>, HandleCloser>;

unique_handle open_event() {
    return unique_handle(::CreateEventW(nullptr, FALSE, FALSE, nullptr));
}

// ② GDI 객체 (DeleteObject)
struct GdiDeleter { void operator()(HGDIOBJ o) const noexcept { if (o) ::DeleteObject(o); } };
using unique_pen   = std::unique_ptr<std::remove_pointer_t<HPEN>,   GdiDeleter>;
using unique_bmp   = std::unique_ptr<std::remove_pointer_t<HBITMAP>, GdiDeleter>;

// ③ HDC (DeleteDC) vs GetDC(ReleaseDC) — 다른 해제자
struct DeleteDCDeleter { void operator()(HDC dc) const noexcept { if (dc) ::DeleteDC(dc); } };
using unique_hdc = std::unique_ptr<std::remove_pointer_t<HDC>, DeleteDCDeleter>;

struct ReleaseDCDeleter {
    HWND wnd{};
    void operator()(HDC dc) const noexcept { if (dc) ::ReleaseDC(wnd, dc); }
};
// 사용: std::unique_ptr<std::remove_pointer_t<HDC>, ReleaseDCDeleter> dc(::GetDC(hWnd), ReleaseDCDeleter{hWnd});
```

> **포인트**: “생성자와 해제 함수” 쌍을 정확히 매칭. (예: `Create*` ↔ `DeleteObject/CloseHandle`, `LoadIcon` ↔ `DestroyIcon`)

### 1-3. move-only로 설계 (복사 금지)
- `unique_ptr`는 **복사 불가**(=소유권 중복 금지), `std::move`로만 이전.
```cpp
std::unique_ptr<FILE, decltype(&fclose)> f(fopen("a.txt","rb"), &fclose);
auto g = std::move(f);  // f는 비어짐(nullptr)
```

### 1-4. 컨테이너와 궁합
```cpp
std::vector<std::unique_ptr<Node>> nodes;
nodes.push_back(std::make_unique<Node>(...));  // 이동만 발생 → 안전/빠름
```

### 1-5. 다형성(가상 소멸자)
```cpp
struct Base { virtual ~Base() = default; };
struct Derived : Base { ~Derived() override { /* ... */ } };

std::unique_ptr<Base> p = std::make_unique<Derived>();
```

---

## 2. `std::shared_ptr / std::weak_ptr` — 공유 소유와 순환 차단

### 2-1. 언제 쓸까?
- 여러 오브젝트가 “**동일 수명**으로 공유하는 리소스”를 가질 때.
- 예: 이미지 캐시, 관찰자 패턴(리스너들이 공유).

> **주의**: 남용하면 **제어 블록 할당 + 원자적 refcnt 갱신**으로 **오버헤드**가 큼. “정말 공유”일 때만.

### 2-2. 기본 사용
```cpp
auto sp = std::make_shared<Image>(path);
auto sp2 = sp;          // refcount +1
sp.reset();             // sp만 해제, 실제 리소스는 sp2가 남아 있어 유지
```

### 2-3. 순환 참조 문제 & `weak_ptr`로 해결
```cpp
struct Node : std::enable_shared_from_this<Node> {
    std::string name;
    std::vector<std::shared_ptr<Node>> children;
    std::weak_ptr<Node> parent; // 부모는 weak_ptr로 소유권 끊기
};

auto root = std::make_shared<Node>();
auto c = std::make_shared<Node>();
c->parent = root;             // 순환 X
root->children.push_back(c);  // OK
```

### 2-4. `enable_shared_from_this` 주의점
```cpp
struct Foo : std::enable_shared_from_this<Foo> {
    std::shared_ptr<Foo> self() { return shared_from_this(); } // 반드시 shared_ptr로 관리되는 인스턴스에서만
};

auto p = std::make_shared<Foo>();
auto s = p->self(); // OK
Foo stack; stack.self(); // UB! (절대 금지)
```

### 2-5. `allocate_shared` & 캐시/풀
- `make_shared`는 **객체 + 제어블록을 한 번에 할당**(메모리/캐시 효율 ↑).
- 커스텀 allocator 필요 시 `allocate_shared` 사용.

### 2-6. `weak_ptr` 캐시 패턴
```cpp
std::unordered_map<std::string, std::weak_ptr<Image>> cache;

std::shared_ptr<Image> GetImage(const std::string& key) {
    if (auto it = cache.find(key); it != cache.end()) {
        if (auto sp = it->second.lock()) return sp; // 아직 살아있음
    }
    auto sp = std::make_shared<Image>(key);
    cache[key] = sp;
    return sp;
}
```

---

## 3. **예외 안전**: 강한 보장(Strong), 기본 보장(Basic)

### 3-1. “임시 구성 → 교체” (Commit/Swap)
```cpp
void ReplaceConfig(Config& dst) {
    Config next;               // 임시
    next.loadFrom("config.json"); // 실패하면 예외, dst는 안전
    dst.swap(next);            // 성공 시 교체
}
```

### 3-2. `noexcept` 이동
```cpp
struct Blob {
    std::vector<std::byte> buf;
    Blob(Blob&&) noexcept = default;
    Blob& operator=(Blob&&) noexcept = default;
    Blob(const Blob&) = delete;
    Blob& operator=(const Blob&) = delete;
};
```
- 컨테이너가 **이동 시 예외 없음**을 알면 **재할당 최적화**가 더 적극적으로 수행.

---

## 4. Scope Guard — 부분 자원 정리(코드 짧게)

### 4-1. 간단 가드(대체: C++23 `std::scope_exit`)
```cpp
template<class F>
struct ScopeExit {
    F f; bool active=true;
    explicit ScopeExit(F&& fn): f(std::forward<F>(fn)) {}
    ~ScopeExit(){ if(active) f(); }
    void release(){ active=false; }
};
#define SCOPE_EXIT(code) auto _scope_##__LINE__ = ScopeExit([&](){ code; })

void CopyFileAtomic(const std::wstring& src, const std::wstring& dst) {
    std::wstring tmp = dst + L".tmp";
    {
        std::ofstream o(tmp, std::ios::binary);
        if (!o) throw std::runtime_error("open tmp failed");
        SCOPE_EXIT( /* 예외/return에도 */ if (std::error_code ec; std::filesystem::remove(tmp, ec), false) {} );
        // write...
    }
    std::filesystem::rename(tmp, dst); // 거의 원자적
}
```

---

## 5. Win32/GDI/COM 리소스 래핑 레시피

### 5-1. `HANDLE` 계열
```cpp
struct HandleCloser { void operator()(HANDLE h) const noexcept { if (h && h!=INVALID_HANDLE_VALUE) ::CloseHandle(h); } };
using unique_handle = std::unique_ptr<std::remove_pointer_t<HANDLE>, HandleCloser>;

unique_handle OpenRead(const std::wstring& p) {
    return unique_handle(::CreateFileW(p.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr));
}
```

### 5-2. GDI 객체
```cpp
struct GdiDelete { void operator()(HGDIOBJ o) const noexcept { if (o) ::DeleteObject(o); } };
using unique_font = std::unique_ptr<std::remove_pointer_t<HFONT>, GdiDelete>;

unique_font MakeFontPt(double pt, UINT dpi) {
    LOGFONTW lf{}; lf.lfHeight = -::MulDiv((int)std::lround(pt), dpi, 72);
    return unique_font(::CreateFontIndirectW(&lf));
}
```

### 5-3. COM CoTaskMem
```cpp
struct CoFree { void operator()(void* p) const noexcept { ::CoTaskMemFree(p); } };
using unique_com = std::unique_ptr<void, CoFree>;

LPWSTR raw=nullptr; SHGetKnownFolderPath(FOLDERID_RoamingAppData, 0, nullptr, &raw);
unique_com p(raw); // 자동 해제
```

### 5-4. `FindFirstFile`/`FindClose`
```cpp
struct FindCloser { void operator()(HANDLE h) const noexcept { if (h && h!=INVALID_HANDLE_VALUE) ::FindClose(h); } };
using unique_find = std::unique_ptr<std::remove_pointer_t<HANDLE>, FindCloser>;

void EnumFiles(const std::wstring& dir) {
    WIN32_FIND_DATAW fd;
    unique_find f(::FindFirstFileW((dir+L"\\*").c_str(), &fd));
    if (!f) return;
    do { /* fd.cFileName */ } while (::FindNextFileW(f.get(), &fd));
}
```

---

## 6. 소유권 모델 설계: “누가 언제까지 책임지나?”

### 6-1. 표준 모델
- **단일 소유**: `unique_ptr` (99% 기본)
- **공유 소유**: `shared_ptr` (정말 공유일 때만)
- **관찰/약참조**: `weak_ptr`
- **비소유 참조**: `T&`, `T*`, `std::span`, `std::string_view` (수명 보장 필수)

### 6-2. GUI와의 조화 (MFC)
- **윈도우 컨트롤**은 **OS가 수명 관리** → `CEdit/CListCtrl`은 **멤버 객체**로 보유 (스마트 포인터로 delete X).
- 모델/리소스는 `unique_ptr`로 앱/문서가 **명시적으로 소유**.

---

## 7. 컨테이너 + 스마트 포인터

### 7-1. `std::vector<std::unique_ptr<T>>`
```cpp
struct Item { /* ... */ };
std::vector<std::unique_ptr<Item>> items;

items.push_back(std::make_unique<Item>());
items.erase(std::remove_if(items.begin(), items.end(),
    [](auto& p){ return p->expired(); }), items.end()); // 소유가 함께 제거
```

### 7-2. 매핑
```cpp
std::unordered_map<std::string, std::unique_ptr<Node>> map;
map.emplace("root", std::make_unique<Node>());
```

### 7-3. 다형 컨테이너
```cpp
std::vector<std::unique_ptr<Base>> polys;
polys.push_back(std::make_unique<DerivedA>());
polys.push_back(std::make_unique<DerivedB>());
```

---

## 8. 팩토리/빌더 & PImpl

### 8-1. 팩토리는 소유권을 돌려준다
```cpp
std::unique_ptr<Connection> MakeConn(const Config& cfg);
auto conn = MakeConn(cfg); // 누가 소유하는지 명확
```

### 8-2. PImpl (헤더 안정/컴파일 시간 단축)
```cpp
class Widget {
public:
    Widget();
    ~Widget();                         // cpp에서만 pimpl delete
    Widget(Widget&&) noexcept;
    Widget& operator=(Widget&&) noexcept;
    void set_text(std::string);
private:
    struct Impl;
    std::unique_ptr<Impl> p_;          // 소유권 = Widget
};
```

---

## 9. 성능/메모리/스레드 고려

### 9-1. `shared_ptr` 비용
- 제어 블록(별도/합쳐진 할당), **원자적** refcnt → 멀티스레드에서 **비용 큼**.
- 가능한 `unique_ptr` + **명시적 소유자 전달**로 모델링.

### 9-2. `make_shared` vs `shared_ptr(new T)`
- `make_shared`는 **한 번 할당**(제어블록+객체) → 빠르고 캐시 친화.
- But **별도 커스텀 deleter/allocator** 필요 시 `shared_ptr<T>(new T, Deleter)` or `allocate_shared`.

### 9-3. lock-free atomic ops
```cpp
std::shared_ptr<T> g; // 원자 교체
void publish(std::shared_ptr<T> p) { std::atomic_store(&g, std::move(p)); }
std::shared_ptr<T> read() { return std::atomic_load(&g); }
```

---

## 10. “언제 smart pointer를 쓰지 않는가?”

- **비소유 관찰자**(UI 컨트롤, 외부가 수명 소유): 생포인터/레퍼런스, `std::observer_ptr`(C++23) 고려
- **짧은 임시 객체** 반환: 값으로 반환(move elision)
- **성능 민감 루프에서 shared_ptr**: 가능하면 **ID/핸들**로 참조하고, 소유자는 따로

---

## 11. C API와 상호 운용: “받고 바로 감싸라”

```cpp
// EX: sqlite3* (sqlite3_close)
struct sqlite_close { void operator()(sqlite3* db) const noexcept { if (db) sqlite3_close(db); } };
using unique_sqlite = std::unique_ptr<sqlite3, sqlite_close>;

unique_sqlite open_db(const char* path) {
    sqlite3* raw{};
    if (sqlite3_open(path, &raw) != SQLITE_OK) throw std::runtime_error("open failed");
    return unique_sqlite(raw);
}
```

> **원칙**: “받는 즉시” 스마트 포인터에 담아 예외 안전 확보.

---

## 12. 고급: `unique_resource`(범용 RAII)와 `scope_exit`

### 12-1. 최소 구현
```cpp
template<class R, class D>
class unique_resource {
    R r{}; D d{}; bool own = true;
public:
    unique_resource(R rr, D dd) noexcept : r(rr), d(dd) {}
    ~unique_resource(){ if (own) d(r); }
    unique_resource(const unique_resource&) = delete;
    unique_resource& operator=(const unique_resource&) = delete;
    unique_resource(unique_resource&& o) noexcept : r(o.r), d(std::move(o.d)), own(std::exchange(o.own,false)) {}
    unique_resource& operator=(unique_resource&& o) noexcept {
        if (this!=&o) { if(own) d(r); r=o.r; d=std::move(o.d); own=std::exchange(o.own,false); }
        return *this;
    }
    R get() const noexcept { return r; }
    void release() noexcept { own=false; }
};
```

### 12-2. 사용
```cpp
auto file = unique_resource{ ::CreateFileW(L"a.bin",GENERIC_WRITE,0,nullptr,CREATE_ALWAYS,0,nullptr),
                             [](HANDLE h){ if(h && h!=INVALID_HANDLE_VALUE) ::CloseHandle(h); } };
// file.release()로 소유권 해제 가능
```

---

## 13. 문자열/버퍼/뷰: `string_view`/`span`/`optional`

```cpp
void parse(std::string_view s);           // 비소유, 수명 주의
void write(std::span<const std::byte> b); // 연속 메모리 뷰

std::optional<Color> try_parse_color(std::string_view s);
```

- **뷰 타입은 소유하지 않음** → **원본 수명**을 항상 명확히.

---

## 14. 예제 묶음 — 실제 작업 흐름

### 14-1. 안전한 이미지 로드/캐시
```cpp
struct Image { /* 디코더/비트맵 래핑 */ };

class ImageCache {
    std::mutex mx_;
    std::unordered_map<std::wstring, std::weak_ptr<Image>> map_;
public:
    std::shared_ptr<Image> get(const std::wstring& path) {
        if (auto it = map_.find(path); it != map_.end()) {
            if (auto sp = it->second.lock()) return sp;
        }
        auto sp = std::make_shared<Image>(/*load*/);
        { std::scoped_lock lk(mx_); map_[path] = sp; }
        return sp;
    }
};
```

### 14-2. 문서/페이지 소유 — `unique_ptr` + 강한 보장
```cpp
struct Page { /* ... */ };
struct Document {
    std::vector<std::unique_ptr<Page>> pages;
    void add(std::unique_ptr<Page> p){ pages.push_back(std::move(p)); }
};

bool save_atomic(const fs::path& file, const Document& doc);
std::optional<Document> load_safe(const fs::path& file);

void replace_document(Document& dst, const fs::path& file) {
    auto d = load_safe(file);
    if (!d) throw std::runtime_error("load failed");
    dst = std::move(*d); // move로 빠르게 교체
}
```

---

## 15. 가장 흔한 실수 & 체크리스트

### 15-1. 흔한 실수
- `shared_ptr` 남용 → 성능 저하/불명확한 소유
- `enable_shared_from_this` 객체를 **생포인터/스택**에서 생성 → **UB**
- `string_view`로 받은 버퍼가 이미 해제됨 → 댕글링
- `unique_ptr`에 잘못된 deleter 매칭 → 리소스 누수/크래시
- 컨테이너에서 `erase` 시 **소유객체 정리 순서** 고려 누락

### 15-2. 체크리스트
- [ ] 소유권 필요? → **unique_ptr**부터
- [ ] 여러 소유자? 진짜? → 그래야만 **shared_ptr**
- [ ] 순환? → **weak_ptr**로 끊기
- [ ] C API 받자마자 **감싸기**
- [ ] 실패 가능 작업은 **임시 → 교체**
- [ ] move-only, `noexcept` 이동 제공
- [ ] deleter/해제 함수 **정확 매칭**
- [ ] 컨테이너/알고리즘 **표준 사용**으로 예외 안전 확보

---

## 16. 부록: 실전 Deleter 사전 (복붙용)

```cpp
// Win32
struct CloseHandleDel   { void operator()(HANDLE h) const noexcept { if(h && h!=INVALID_HANDLE_VALUE) ::CloseHandle(h); } };
struct FindCloseDel     { void operator()(HANDLE h) const noexcept { if(h && h!=INVALID_HANDLE_VALUE) ::FindClose(h); } };
struct RegCloseKeyDel   { void operator()(HKEY k)   const noexcept { if(k) ::RegCloseKey(k); } };

// GDI
struct DeleteObjectDel  { void operator()(HGDIOBJ o) const noexcept { if(o) ::DeleteObject(o); } };
struct DeleteDCDel      { void operator()(HDC dc)    const noexcept { if(dc) ::DeleteDC(dc); } };
struct DestroyIconDel   { void operator()(HICON ic)  const noexcept { if(ic) ::DestroyIcon(ic); } };
struct DestroyCursorDel { void operator()(HCURSOR c) const noexcept { if(c) ::DestroyCursor(c); } };

// COM
struct CoTaskMemFreeDel { void operator()(void* p)   const noexcept { ::CoTaskMemFree(p); } };
struct SysFreeStringDel { void operator()(BSTR b)    const noexcept { if(b) ::SysFreeString(b); } };

// FILE*
struct FcloseDel        { void operator()(FILE* f)   const noexcept { if(f) ::fclose(f); } };

// 타입 별칭
template<class T, class D>
using uptr = std::unique_ptr<T, D>;

using unique_handle  = uptr<std::remove_pointer_t<HANDLE>, CloseHandleDel>;
using unique_find    = uptr<std::remove_pointer_t<HANDLE>, FindCloseDel>;
using unique_hkey    = uptr<std::remove_pointer_t<HKEY>,   RegCloseKeyDel>;
using unique_hbmp    = uptr<std::remove_pointer_t<HBITMAP>, DeleteObjectDel>;
using unique_hfont   = uptr<std::remove_pointer_t<HFONT>,   DeleteObjectDel>;
using unique_hdc     = uptr<std::remove_pointer_t<HDC>,     DeleteDCDel>;
using unique_icon    = uptr<std::remove_pointer_t<HICON>,   DestroyIconDel>;
using unique_cursor  = uptr<std::remove_pointer_t<HCURSOR>, DestroyCursorDel>;
using unique_com     = uptr<void, CoTaskMemFreeDel>;
using unique_bstr    = uptr<std::remove_pointer_t<BSTR>, SysFreeStringDel>;
using unique_file    = uptr<FILE, FcloseDel>;
```

---

## 17. 마무리

RAII/스마트 포인터는 **코드가 수명을 말하도록** 만드는 설계 도구입니다.
- “**누가 소유하고 언제 해제하는가**”를 타입 체계에 새기면,
- 누수/이중해제/댕글링/예외 경로 누락 같은 **하위 레벨 버그가 사라집니다**.
