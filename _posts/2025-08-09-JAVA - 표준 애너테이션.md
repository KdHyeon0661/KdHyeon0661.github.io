---
layout: post
title: Java - 표준 애너테이션
date: 2025-08-09 15:20:23 +0900
category: Java
---
# 표준 애너테이션 완전 정리

## @Override — “이 메서드는 진짜 오버라이드입니다”

### 핵심 개념

- 상위 타입(클래스 **또는 인터페이스**)의 메서드를 **정확히 재정의**하고 있음을 **컴파일러에게 선언**한다.
- 오탈자/시그니처 미스매치로 실제로는 **새 메서드를 선언해버리는 실수**를 **컴파일 타임에 차단**한다.
- Java 6+부터 **인터페이스 메서드 구현에도 @Override를 붙이는 것을 권장**(Java 5는 달랐음).

### 올바른/잘못된 예제

```java
class Parent {
    Number value() { return 42; }
}

class Child extends Parent {
    @Override
    Integer value() {            // ✔ 공변 반환(covariant return)도 허용
        return 42;
    }

    // @Override
    // void vlaue() { }          // ✘ 오탈자: 컴파일 오류로 즉시 탐지
}
```

### 디폴트 메서드/인터페이스 구현

```java
interface Greeter {
    default String hi() { return "hi"; }
}

class Service implements Greeter {
    @Override
    public String hi() { return "HI"; } // 인터페이스 디폴트 메서드도 명시적으로 오버라이드
}
```

### 레코드/Sealed와의 맥락

- **record**는 `equals/hashCode/toString`을 자동 생성한다. 직접 재정의할 때 **반드시 @Override**를 붙여 의도를 명확히 하자.
- **sealed** 계층에서도 동일하게 @Override 권장(계약 명시).

```java
public record Point(int x, int y) {
    @Override public String toString() { return x + "," + y; }
}
```

### 모범 사례

- **상속/구현 메서드는 전부 @Override**를 습관화(리뷰/리팩토링 시 안전).
- **접근 제한자/throws 변경**으로 시그니처가 바뀌지 않았는지 컴파일러가 보장.

---

## @Deprecated — “사용 중단, 대체 API로 이동하세요”

### 핵심 개념

- **사용 지양(Deprecated)** 상태를 선언. 호출 시 **컴파일 경고**가 발생.
- **Java 9+**: `@Deprecated(since="9", forRemoval=true)` 속성 도입
  - `since`: 언제부터 폐기로 표시했는지
  - `forRemoval`: **향후 릴리스에서 제거 예정**임을 의미(도구가 더 강하게 경고)

```java
/**
 * @deprecated Use {@link #newApi()} instead.
 */
@Deprecated(since = "11", forRemoval = true)
public void oldApi() { /* ... */ }

public void newApi() { /* ... */ }
```

> **Javadoc의 `@deprecated` 태그**와 **애너테이션**을 **둘 다** 쓰자.
> 문서/IDE 툴체인이 **대체 경로**를 사용자에게 명확히 안내한다.

### 패키지/모듈 단위의 폐기 표식

- **패키지**: `package-info.java`에 부착
- **모듈(Java 9+)**: `module-info.java`에도 붙일 수 있다(사용 중단 모듈의 명시적 경고)

```java
// package-info.java
@Deprecated(since="21", forRemoval=true)
package com.example.legacy;
```

```java
// module-info.java
@Deprecated(since="21", forRemoval=true)
module com.example.legacy { exports com.example.legacy; }
```

> 조직 차원에서 **모듈/패키지 수준 폐기 공지**를 병행하면 **대규모 코드베이스 마이그레이션**에 유리하다.

### 대체 API 전환 가이드 포함 예

```java
/**
 * @deprecated since 17; migrate to {@link Files#readString(java.nio.file.Path)}.
 */
@Deprecated(since="17")
String read(File f) { /* ... */ return ""; }
```

### 테스트 & 정적 분석

- CI에서 **`-Xlint:deprecation`** 또는 IDE 검사를 활성화하여 **남은 사용지점**을 추적한다.
- `forRemoval=true` 표식은 **“빨리 없애라”**는 시그널. 릴리스 노트/마이그레이션 가이드를 함께 유지.

---

## @SuppressWarnings — “의도된 경고만 억제, 최소 범위 적용”

### 핵심 개념

- 특정 **컴파일 경고 카테고리**를 억제한다.
- 억제 키는 **컴파일러/버전에 따라 달라질 수 있음**(javac vs. IDE). **최소 범위**(로컬 변수/블록/메서드) 적용 권장.

### 자주 쓰는 키 (javac 기준, 대표)

| 키 | 의미/용도(대표) |
|---|---|
| `"unchecked"` | 제네릭 형안전 경고(원시타입→제네릭 캐스팅 등) |
| `"rawtypes"`  | Raw type 사용 경고 |
| `"deprecation"` | 사용 중단 API 사용 경고 |
| `"serial"`    | `Serializable`의 `serialVersionUID` 경고 |
| `"finally"`   | finally 블록 문제 |
| `"fallthrough"` | switch fall-through 경고 |
| `"cast"`, `"divzero"`, `"overrides"`, `"try"`, `"preview"` 등 | 상황별 세부 경고 |

> 실무에선 `-Xlint:all`로 경고를 모두 열어보고, 억제가 **불가피한 지점에만** 국소적으로 적용한다.

### 최소 범위 적용 예

```java
List raw = new ArrayList();     // raw type (경고)
raw.add("A");

// ❶ 국소 변수에만 억제
@SuppressWarnings({"rawtypes","unchecked"})
List<String> s = raw;           // 억제 범위: 이 줄만

// ❷ 블록 스코프 억제
@SuppressWarnings("deprecation")
void useOld() {
    OldApi api = new OldApi();
    api.old();                  // 대체 불가 상황에서 국소 억제
}
```

### 제네릭/가변인자와의 상호작용

```java
// 컴파일러가 경고를 표시하는 전형적 케이스
@SafeVarargs             // 가변인자+제네릭 안전성 보장(생성자/final/static에만 허용)
static <T> List<T> listOf(T... ts) {
    return Arrays.asList(ts);
}
```

---

## 세 애너테이션의 **정확한 Target/Retention**과 사용 위치

| 애너테이션 | 주 Target(대표) | Retention | 주요 적용 위치 |
|---|---|---|---|
| `@Override` | `METHOD` | `SOURCE` | 오버라이드 메서드(클래스/인터페이스 구현 포함) |
| `@Deprecated` | `TYPE`, `METHOD`, `FIELD`, `CONSTRUCTOR`, `PACKAGE`, *(Java 9+ `MODULE` 지원)* | `RUNTIME` | API 폐기 표식(문서/IDE/도구에 노출) |
| `@SuppressWarnings` | `TYPE`, `METHOD`, `FIELD`, `PARAMETER`, `CONSTRUCTOR`, `LOCAL_VARIABLE`, *(Java 9+ `MODULE` 가능)* | `SOURCE` | 경고 억제(컴파일러 해석용) |

> `@Override`/`@SuppressWarnings`는 **소스 단계 지시**가 본질이고, `@Deprecated`는 **런타임까지 남아** 문서화/리플렉션에도 보인다.

---

## 실전 패턴과 리팩토링 가이드

### “Deprecated → 대체로 점진 이행” 체크리스트

1. `@Deprecated(since, forRemoval)` + **Javadoc에 대체 경로** 표시
2. 릴리스 노트/마이그레이션 가이드에 사례 추가
3. `-Xlint:deprecation`로 사용지점 추적, **자동 리팩토링 스크립트**(IDE/AST) 준비
4. `forRemoval=true`는 **제거 시점** 명시(로드맵)

### “SuppressWarnings 남용 금지” 체크리스트

- 억제는 **최소 범위**로(라인/로컬 변수/메서드)
- 사유를 **주석으로 문서화**(코드리뷰에 도움)
- 근본 원인(제네릭/타입 설계) 해결을 우선 검토

### @Override 100% 적용

- 팀 규칙: **오버라이드 메서드는 모두 @Override 필요**
- 디폴트 메서드/equals/hashCode/toString 재정의 포함
- CI에서 **미사용/미표시 메서드 검출**(정적 분석 룰)도 가능

---

## 종합 예제 — 3종 애너테이션이 한 파일에서 만나는 경우

```java
package demo;

import java.util.*;

class LegacyLib {
    /** @deprecated since 21; use {@link #modern()} instead. */
    @Deprecated(since="21", forRemoval=true)
    void legacy() { System.out.println("legacy"); }

    void modern() { System.out.println("modern"); }
}

interface Greeter { String hi(); }

class Impl implements Greeter {
    @Override
    public String hi() { return "Hi"; }

    @SuppressWarnings({"unchecked","rawtypes"})
    List<String> castRaw(List raw) {   // 최소 범위: 메서드 단위
        return raw;                    // 의도된 unchecked
    }

    void migrate(LegacyLib lib) {
        // 필요하면 라인 단위로 더 줄일 수도 있음
        @SuppressWarnings("deprecation")
        var _ = (Runnable) () -> lib.legacy();
        _.run();

        lib.modern(); // 신규 API로 전환
    }
}
```

---

## 테스트, 빌드, 도구 설정

### 컴파일러 옵션(javac)

```bash
# deprecation 경고 보고

javac -Xlint:deprecation -d out $(find src -name "*.java")

# 모든 경고(가능한 한)

javac -Xlint:all -Werror -d out $(find src -name "*.java")
```
- `-Werror`: 경고를 에러로 승격(빌드 품질 강제)

### Maven (예)

```xml
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
  <version>3.11.0</version>
  <configuration>
    <release>21</release>
    <compilerArgs>
      <arg>-Xlint:all</arg>
      <arg>-Werror</arg>
    </compilerArgs>
  </configuration>
</plugin>
```

### Gradle (Kotlin DSL 예)

```kotlin
tasks.withType<JavaCompile>().configureEach {
    options.release.set(21)
    options.compilerArgs.addAll(listOf("-Xlint:all", "-Werror"))
}
```

---

## 자주 겪는 오류와 해결법 (트러블슈팅)

| 문제 | 원인 | 해결 |
|---|---|---|
| @Override 붙였는데 “method does not override” | 오탈자/시그니처 오판(파라미터/throws/제네릭 경계) | 상위 선언과 **정확히 일치** 확인, IDE 도움 받기 |
| Deprecated 경고가 안 보임 | 빌드/IDE가 deprecation 경고 비활성 | `-Xlint:deprecation` 활성, IDE 인스펙션 켜기 |
| @SuppressWarnings가 과도하게 넓게 적용 | 클래스/패키지 레벨에 붙임 | **라인/블록/메서드 단위**로 범위 축소 |
| forRemoval를 썼는데 팀에 혼란 | 제거 시점/대체 미명시 | 릴리스 계획+마이그레이션 문서 동시 제공 |
| 인터페이스 메서드 구현에 @Override가 경고 | 古 JDK 도구 설정/레벨 문제 | JDK 6+에서 허용. 빌드 JDK 정렬/도구 설정 확인 |

---

## 학습용 미니 실습

### 오버라이드 실패를 컴파일이 잡아내는지 확인

```java
class A { void go(int x) {} }
class B extends A {
    // 아래 주석을 풀고 컴파일해 보자 — 파라미터 타입 불일치!
    // @Override void go(Integer x) {}
}
```

### Deprecated 교체 훈련

```java
class Api {
    /** @deprecated use v2() */
    @Deprecated(since="20")
    static String v1(){ return "v1"; }
    static String v2(){ return "v2"; }
}

class Use {
    static void run() {
        // IDE가 v1() 사용 지점을 알려주는지 체크
        System.out.println(Api.v2());
    }
}
```

### SuppressWarnings 최소 범위 적용

```java
class SuppDemo {
    void f() {
        List raw = new ArrayList(); raw.add("x");
        @SuppressWarnings({"unchecked","rawtypes"})
        List<String> ok = raw; // 이 한 줄만 억제
        System.out.println(ok.get(0));
    }
}
```

---

## 확장: 표준 3종과 잘 어울리는 보조 애너테이션

| 애너테이션 | 언제 함께 쓰나 | 메모 |
|---|---|---|
| `@SafeVarargs` | 제네릭 가변인자 메서드/생성자 | `final`/`static`/생성자에서만 |
| `@FunctionalInterface` | 람다 타깃 인터페이스 | 추상 메서드 1개 보장 |
| `@Generated` (JDK 9+) | 생성 코드 표식 | 소스 생성 파이프라인 디버깅 |

---

## 요약 표

| 항목 | @Override | @Deprecated | @SuppressWarnings |
|---|---|---|---|
| 목적 | **오버라이드 보장** | **사용 중단 표식** | **경고 억제(선별)** |
| 주요 대상 | 메서드 | 타입/메서드/필드/생성자/패키지/(모듈) | 타입/멤버/지역/파라미터/(모듈) |
| Retention | SOURCE | RUNTIME | SOURCE |
| 도입 팁 | 구현/재정의 **전부** 사용 | `since/forRemoval` + Javadoc `@deprecated` | 키는 **컴파일러 의존**, **최소 범위** 적용 |
| CI 권장 | - | `-Xlint:deprecation` | `-Xlint:all -Werror`와 병행 |

---

## 결론

- **@Override**는 **안전망**이자 **가독성 신호** — “의도된 재정의”를 강하게 보장한다.
- **@Deprecated**는 **문서+정책 도구** — `since/forRemoval`과 **대체 경로**를 함께 제공해야 가치가 있다.
- **@SuppressWarnings**는 **필요 최소 억제** — 경고를 **숨기기보다 해결**하는 것이 원칙이며, 어쩔 수 없을 때 **국소 적용**한다.
이 세 가지를 팀 규칙/CI와 **일관되게 운영**하면 **API 수명주기 관리**와 **코드 품질**이 비약적으로 올라간
