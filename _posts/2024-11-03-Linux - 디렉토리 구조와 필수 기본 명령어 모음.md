---
layout: post
title: Linux - 디렉토리 구조와 필수 기본 명령어 모음
date: 2024-11-03 19:20:23 +0900
category: Linux
---
# 리눅스 명령어 기초와 디렉토리 구조 + 실전 명령어 예제

## 리눅스 명령어의 기본 구조

```bash
명령어 [옵션] [대상...]
```
**예시**
```bash
ls -l /etc
```
- **명령어**: `ls`
- **옵션**: `-l` (긴 형식)
- **대상**: `/etc` 디렉토리

**추가 패턴**
```bash
# 옵션 합치기 (GNU 유틸 대부분)

ls -lah      # -l -a -h를 결합

# 긴 옵션

ls --all --human-readable --long

# 여러 대상

cp a.txt b.txt /tmp/

# -- 로 옵션 종료(파일명이 -로 시작할 때 안전)

grep -n -- "-pattern" file.txt
```

**인용(quoting) 규칙 요약**
```bash
echo "HOME is $HOME"      # 변수 확장 O
echo 'HOME is $HOME'      # 변수 확장 X (문자 그대로)
echo HOME\ is\ "$HOME"    # 공백 이스케이프 + 이중따옴표 혼합
```

**글로빙(globbing)과 브레이스 확장**
```bash
ls *.log                 # 와일드카드
cp app.{yml,yaml} /etc/  # 브레이스 확장
echo {1..5}              # 1 2 3 4 5
```

---

## 리눅스 디렉토리 구조 (FHS 핵심)

리눅스는 **루트 디렉토리 `/`**를 기준으로 계층 구조를 가진다.

| 디렉토리 | 요약 | 비고 |
|---|---|---|
| `/` | 최상위 루트 | 모든 경로의 시작점 |
| `/bin` | 기본 사용자 명령 | `ls`, `cp`, `mv` 등 |
| `/sbin` | 시스템 관리자 명령 | `reboot`, `fsck` 등 |
| `/etc` | 설정 파일 | 서비스/시스템 설정 |
| `/home` | 일반 사용자 홈 | `/home/user` |
| `/root` | 루트 홈 | 관리자 계정 홈 |
| `/usr` | 사용자 애플리케이션 | 대다수 실행파일/라이브러리 |
| `/var` | 가변 데이터 | 로그, 큐, 스풀, 캐시 |
| `/tmp` | 임시 파일 | 재부팅 시 소거될 수 있음 |
| `/lib`, `/lib64` | 라이브러리 | 아키텍처별 분리 |
| `/dev` | 디바이스 파일 | 디스크/터미널/랜카드 |
| `/proc`, `/sys` | 가상 FS | 커널/프로세스 정보 |
| `/run` | 런타임 데이터 | PID/소켓 등 |
| `/mnt`, `/media` | 마운트 포인트 | 외부 장치/임시 마운트 |

**실전 확인**
```bash
ls -l /
ls -l /proc/self
cat /proc/cpuinfo
lsblk -f
mount | column -t
```

---

## 파일·디렉토리 조작 (기본 + 실전)

**목록/정렬/필터링**
```bash
ls
ls -l
ls -a
ls -lh /var/log
ls -lt                 # 최근 수정 순
ls -lt | head -n 10    # 최근 10개
```

**이동**
```bash
cd /home/user        # 절대경로
cd ./user            # 상대경로
cd ..                # 상위
cd ~                 # 홈
cd -                 # 직전 경로
pwd
```

**생성/삭제**
```bash
mkdir test
mkdir -p a/b/c
rmdir empty-dir                # 빈 디렉토리만
rm -r non-empty-dir/          # 하위 포함 삭제
rm -rf /                      # 절대 금지!
```

**복사/이동/이름변경**
```bash
touch file.txt
cp a.txt b.txt
cp -r dir1 dir2
mv old.txt new.txt
mv file.txt /tmp/
```

**링크(하드/심볼릭)**
```bash
ln original.bin hardlink.bin      # 하드 링크 (같은 inode)
ln -s /opt/app/bin/app /usr/local/bin/app  # 심볼릭 링크
ls -li                            # inode 확인
```

**압축/아카이브**
```bash
tar -czf logs.tgz /var/log
tar -xzf logs.tgz -C /tmp/
zip -r data.zip data/
unzip data.zip -d /data
```

---

## 내용 보기·스트리밍·팔로우

**빠른 조회**
```bash
cat file.txt
nl -ba file.txt            # 줄 번호
less bigfile.log           # q로 종료, /검색, n 다음 결과
```

**부분 조회**
```bash
head -n 10 file.txt
tail -n 10 file.txt
tail -f /var/log/syslog    # 실시간 로그 팔로우
```

**대용량 안전 파이프라인(메모리 절약)**
```bash
zcat huge.log.gz | grep -i error | tee errors.txt | wc -l
```

---

## 검색(find/grep)과 정규표현식

**find**
```bash
find . -name "*.log"
find /etc -type f -size +10M
find /var/www -type f -mtime -7 -name "*.php"
find . -type f -exec chmod 640 {} \;     # 일괄 권한
find . -type f -print0 | xargs -0 wc -l  # 공백 안전
```

**grep(기본/재귀/번호/대소문자/정규표현식)**
```bash
grep "error" file.txt
grep -r "main" ./src/
grep -ni "fail(ed)?" app.log
grep -E "(WARN|ERROR)" app.log
```

**정규표현식 미니 규칙**
- `.`: 임의의 한 문자
- `*`: 0회 이상 반복
- `+`: 1회 이상 반복 (`grep -E`)
- `?`: 0~1회 (`grep -E`)
- `[]`: 문자 집합
- `()`/`|`: 그룹/OR (`grep -E`)

---

## 리다이렉션·파이프·tee/xargs

**리다이렉션**
```bash
# 표준출력 덮어쓰기/추가

ls -l > list.txt
ls -l >> list.txt

# 표준에러 리다이렉션

make 2> error.log

# 표준출력+표준에러 통합

cmd > all.log 2>&1
```

**파이프라인**
```bash
ps aux | grep nginx | grep -v grep | awk '{print $2}' | xargs -r sudo kill
```

**tee (중간 저장)**
```bash
dmesg | tee dmesg.txt | grep -i usb
```

**xargs (배치 실행)**
```bash
# 개행으로 구분된 입력을 인수로 변환

cat files.txt | xargs -I{} cp {} /backup/
# NUL 구분(공백 안전)

find . -type f -print0 | xargs -0 -I{} sha256sum "{}" >> checksums.txt
```

---

## 권한·소유권·특수비트·umask

**권한 계산(8진수)**
파일 권한은 **소유자(u)/그룹(g)/기타(o)**에 대해 **r=4, w=2, x=1**의 합으로 결정된다.
$$
\text{perm} = 4\cdot I(r) + 2\cdot I(w) + 1\cdot I(x)
$$
예: `rwxr-x---` → `u=7, g=5, o=0` → `chmod 750 file`

**기본 명령**
```bash
chmod 755 script.sh
chmod +x myapp
chown user:group file.txt
stat file.txt
```

**기호 방식(chmod)**
```bash
chmod u+x,g-w,o= file.sh   # 소유자 실행 추가, 그룹 쓰기 제거, 기타 없음
```

**특수 비트**
```bash
# setuid(4), setgid(2), sticky(1)

chmod 4755 /usr/local/bin/tool   # setuid + 755
chmod 2755 shared-dir            # setgid 디렉토리(그룹 상속)
chmod 1777 /tmp                  # sticky: 소유자만 삭제 가능
```

**umask(기본 권한 마스크)**
```bash
umask           # 현재 값 확인(예: 0022)
umask 0027      # 새 파일 기본 권한이 더 보수적으로
```

---

## 텍스트 처리(Unix 철학의 핵심 도구)

**cut, paste, tr**
```bash
cut -d, -f1,3 data.csv          # 1,3번째 컬럼
tr -d '\r' < win.txt > unix.txt # CR 제거
paste file1 file2               # 열 결합
```

**sort, uniq**
```bash
sort access.log | uniq -c | sort -nr | head  # 빈도 상위
sort -t, -k3,3n data.csv                     # 3열 숫자 기준 정렬
```

**awk (열 기반 스크립팅)**
```bash
# CSV의 3열 합

awk -F, '{sum+=$3} END{print sum}' data.csv

# 조건/형식화 출력

ps aux | awk '$3>20 {printf "%-8s %6s %5s%% %s\n",$1,$2,$3,$11}'
```

**sed (스트림 편집기)**
```bash
sed -n '1,100p' file.txt               # 1~100행 출력
sed 's/error/ERROR/g' app.log > out.log  # 치환
sed -E '/^\s*#/d;/^\s*$/d' conf        # 주석/공백 제거
```

**join/comm (집합 연산)**
```bash
sort a.txt > a.sorted
sort b.txt > b.sorted
comm -12 a.sorted b.sorted      # 교집합
```

---

## 시스템·프로세스·서비스 관리

**시스템 정보**
```bash
uname -a
cat /etc/os-release
lscpu
free -h
df -hT
du -sh * | sort -h
```

**프로세스/리소스**
```bash
ps aux | head
top
htop                      # 설치 필요
pidof nginx
pmap <pid>
```

**프로세스 제어**
```bash
kill -TERM <pid>         # 정상 종료 시도
kill -KILL <pid>         # 강제
pkill -f "python app.py"
```

**우선순위(nice/renice)**
```bash
nice -n 10 long_task.sh
sudo renice -n -5 -p <pid>
```

**잡 제어(백그라운드, nohup)**
```bash
long_task.sh &
jobs
fg %1
bg %1
nohup long_task.sh > run.log 2>&1 &
disown
```

**systemd 서비스**
```bash
sudo systemctl status nginx
sudo systemctl enable --now nginx
sudo systemctl restart nginx
sudo journalctl -u nginx --since "1 hour ago"
```

---

## 네트워킹 기초

**주소/라우팅/포트**
```bash
ip a
ip r
ss -tulpn
```

**테스트/진단**
```bash
ping -c 4 8.8.8.8
curl -I https://example.com
dig example.com +short     # 패키지: dnsutils/bind-tools
```

**간이 서버**
```bash
# Python HTTP 서버

python3 -m http.server 8080

# nc(netcat) 간이 TCP 서버/클라이언트

nc -l 9000
nc 127.0.0.1 9000
```

---

## 패키지 관리(요약)

| 동작 | Debian/Ubuntu | Fedora/RHEL | Arch | openSUSE |
|---|---|---|---|---|
| 업데이트 | `sudo apt update && sudo apt upgrade` | `sudo dnf upgrade` | `sudo pacman -Syu` | `sudo zypper dup` |
| 설치 | `sudo apt install` | `sudo dnf install` | `sudo pacman -S` | `sudo zypper install` |
| 제거 | `sudo apt remove` | `sudo dnf remove` | `sudo pacman -R` | `sudo zypper remove` |
| 검색 | `apt search` | `dnf search` | `pacman -Ss` | `zypper search` |

**추가 포맷(Snap/Flatpak)**
```bash
snap list
flatpak list
```

---

## 디스크·마운트·fstab

**장치/파티션**
```bash
lsblk -f
blkid
sudo fdisk -l
```

**마운트/언마운트**
```bash
sudo mount /dev/sdb1 /mnt/data
sudo umount /mnt/data
```

**부팅 시 자동 마운트(/etc/fstab)**
```bash
# 예시: UUID 기반, ext4

UUID=xxxx-xxxx  /data  ext4  defaults,noatime  0  2
```

**스마트 상태**
```bash
sudo smartctl -a /dev/sda
```

---

## 로그·진단·보안 기초

**로그**
```bash
sudo journalctl -b                     # 부팅 이후
sudo journalctl -u ssh --since "today"
sudo tail -f /var/log/syslog           # Debian/Ubuntu
sudo tail -f /var/log/messages         # RHEL계열
```

**방화벽(UFW)**
```bash
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow OpenSSH
sudo ufw allow 80,443/tcp
sudo ufw enable
sudo ufw status verbose
```

**SSH 보안**
```bash
ssh-keygen -t ed25519 -C "me@example.com"
ssh-copy-id user@server
sudoedit /etc/ssh/sshd_config  # PasswordAuthentication no, PermitRootLogin prohibit-password
sudo systemctl restart ssh
```

---

## 스케줄러: cron/at

**crontab**
```bash
crontab -e
# 매일 03:00 백업

0 3 * * * /usr/local/bin/backup.sh
crontab -l
```

**at (일회성)**
```bash
echo "bash /home/user/run_once.sh" | at 23:00
atq
atrm <job>
```

---

## 실전 시나리오 모음

**시나리오 1: 로그에서 에러 라인 추출 → 요약**
```bash
zcat app-2025-11-*.log.gz \
| grep -Ei "(ERROR|FATAL)" \
| sed -E 's/[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9:.-]+Z//' \
| awk '{k[$1]++} END{for (i in k) printf "%-50s %6d\n", i, k[i]}' \
| sort -k2,2nr | head -n 20
```

**시나리오 2: 디스크 꽉 참 → 대용량 파일 탐지/정리**
```bash
df -hT
du -sh /* 2>/dev/null | sort -h | tail
du -sh /var/log/* | sort -h | tail
sudo journalctl --vacuum-time=7d
sudo find /var/log -type f -name "*.log" -size +200M -print
```

**시나리오 3: 서비스 죽음 → 프로세스/포트/로그 확인**
```bash
sudo systemctl status myapp
sudo journalctl -u myapp --since "30 min ago"
ss -tulpn | grep :8080
sudo lsof -i :8080
```

**시나리오 4: 대량 파일 일괄 변환(인코딩/개행)**
```bash
# CRLF → LF

find . -type f -name "*.txt" -print0 | xargs -0 -I{} sed -i 's/\r$//' "{}"
# EUC-KR → UTF-8 (iconv 필요)

find . -type f -name "*.csv" -print0 \
 | xargs -0 -I{} sh -c 'iconv -f euc-kr -t utf-8 "{}" > "{}.utf8"'
```

**시나리오 5: 백업/무결성 체크**
```bash
# rsync 미러링 + 삭제 동기화

rsync -a --delete /srv/data/ backup@host:/backup/data/
# 체크섬 생성/검증

find /srv/data -type f -print0 | xargs -0 sha256sum > data.sha256
sha256sum -c data.sha256
```

---

## 부족했던 부분 보강(기존 초안 확장 포인트)

- **링크/inode 개념**(하드/심볼릭 차이, inode 번호 확인)
- **특수권한**(setuid/setgid/sticky)과 **umask**
- **파이프라인/xargs/tee**를 통한 **스트리밍 처리** 패턴
- **텍스트 처리 3대장**(grep/sed/awk)과 조합 예제
- **프로세스/서비스/로그** 트러블슈팅 순서
- **디스크/마운트/fstab** 베이직 + 실전 점검 루틴

---

## 정리된 명령어 리스트(확장판)

| 범주 | 대표 명령어 |
|---|---|
| 디렉토리 | `ls`, `cd`, `pwd`, `mkdir`, `rmdir`, `tree` |
| 파일 조작 | `touch`, `cp`, `mv`, `rm`, `ln`, `tar`, `zip`, `unzip` |
| 내용 확인 | `cat`, `nl`, `less`, `head`, `tail` |
| 검색 | `find`, `grep`, `egrep`, `fgrep` |
| 텍스트 처리 | `cut`, `tr`, `paste`, `sort`, `uniq`, `sed`, `awk`, `join`, `comm` |
| 권한 | `chmod`, `chown`, `chgrp`, `stat`, `umask` |
| 사용자 | `whoami`, `id`, `adduser`, `usermod`, `passwd` |
| 시스템 | `uname`, `lscpu`, `free`, `df`, `du`, `lsblk`, `mount`, `blkid` |
| 프로세스 | `ps`, `top`, `htop`, `kill`, `pkill`, `nice`, `renice` |
| 서비스/로그 | `systemctl`, `journalctl` |
| 네트워크 | `ip`, `ss`, `ping`, `curl`, `dig`, `nc` |
| 스케줄 | `crontab`, `at`, `atq`, `atrm` |
| 보안 | `ufw`, `ssh`, `ssh-keygen`, `ssh-copy-id` |
| 기타 | `history`, `clear`, `echo`, `date`, `cal`, `which`, `whereis` |

---

## 마무리

- 리눅스는 **텍스트/파이프라인 중심의 조합**이 힘이다. 본문 예제들을 그대로 입력해 보며 **작은 단위 명령을 연결**하는 감각을 익히자.
- 다음 단계로는 **셸 스크립팅**, **환경 변수/프로필 관리**, **컨테이너(Docker/Podman)**까지 확장하면 실무 생산성이 급상승한다.
- 궁금한 명령은 항상 `man <명령>`과 `--help`로 확인하고, 문제 상황에서는 **로그→프로세스→네트워크→디스크** 순서로 점검 루틴을 습관화하자.
