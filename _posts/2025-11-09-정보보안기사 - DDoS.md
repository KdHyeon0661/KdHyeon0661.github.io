---
layout: post
title: 정보보안기사 - DDoS
date: 2025-11-09 21:25:23 +0900
category: 정보보안기사
---
# SECTION 04 네트워크 기본 학습 — 13. 분산 서비스 거부(DDoS: Distributed Denial of Service) 공격

## 1. 개요 — DDoS란 무엇인가

- **정의**: 수천~수백만 단말(봇넷) 또는 제3자 **반사/증폭(Reflection/Amplification)** 장비를 동원해 표적의 **대역폭/상태/애플리케이션 자원**을 고갈시켜 정상 서비스를 방해하는 공격.
- **DoS와 차이**: 단일 발신지(DoS)와 달리 **소스 다변화**로 차단·추적·속도제어가 어려움. 다중 벡터를 **동시에** 사용(예: UDP 대역폭 + SYN 상태 고갈 + HTTP L7 Flood).
- **왜 어렵나**  
  1) **규모**: bps·pps·cps 모두 폭증(네트워크·커널·앱 전층 압박).  
  2) **분산성**: IP/ASN/지역/프로토콜 다양 → 정적 ACL 한계.  
  3) **적응성**: 방어가 보이면 **벡터 전환**, 우회 재시도.  
  4) **연계효과**: L3/4 혼잡이 L7 모니터링·오토스케일링에도 영향.

```
[수천 개의 봇/리플렉터]  ==>  [업스트림/엣지]  ==>  [경계/WAF/LB]  ==>  [오리진/DB/내부]
      다중 벡터                   차단·스크러빙           속도제한/프록시        비즈니스 로직
```

---

## 2. 공격 분류 — 세 계층, 다섯 대표 벡터

### 2.1 Volumetric(대역폭 포화) — 반사/증폭 포함

| 벡터 | 개념 | 대표 표적 | 징후(네트워크) | 즉시 대응 |
|---|---|---|---|---|
| **UDP Flood** | 고PPS·고bps로 링크 포화 | 엣지 회선, 라우터 | bps/pps 급증, 드롭↑ | 업스트림 **스크러빙**, RTBH |
| **Reflection** | 소스 스푸핑 → 제3자 응답이 표적에 | DNS/NTP/SSDP/CLDAP/Memcached 등 | 한 방향 대용량 응답 | **BCP38/uRPF**, 오픈 리졸버 제거 |
| **Amplification** | 요청≪응답 (계수↑) | 일부 UDP 서비스 | 응답/요청 바이트 비율↑ | 서비스 하드닝·ACL |

- **증폭 계수**  
  $$ \text{Amplification Factor} = \frac{\text{응답 바이트}}{\text{요청 바이트}} \;(\gg 1 \text{이면 위험}). $$

### 2.2 Protocol/State Exhaustion(L3/4)

| 벡터 | 개념 | 커널/장비 징후 | 즉시 대응 |
|---|---|---|---|
| **SYN Flood** | 대량 SYN로 **SYN-RECV** 백로그 고갈 | `SYN-RECV`↑, 재전송↑ | **SYN Cookies/Proxy**, 백로그↑ |
| **ACK/RST/ICMP Flood** | 플래그/유형 편향으로 처리 부하 | 특정 플래그 급증 | 레이트/ACL, DPI |
| **Fragmentation 악용** | 재조립 비용 증가 | 재조립 큐↑ | 비표준 조각 드롭, 한계 조정 |
| **Conntrack 고갈** | 상태추적 테이블 포화 | `nf_conntrack_count`≈`max` | 추적 해제/Bypass·용량↑ |

### 2.3 Application Layer(L7)

| 벡터 | 개념 | 앱 징후 | 즉시 대응 |
|---|---|---|---|
| **HTTP Request Flood** | 합법 형태 요청 대량 | RPS↑, 2xx/5xx/대기열 | **CDN/WAF/챌린지/Rate** |
| **Slow Client/Slowloris** | 느린 헤더/바디로 워커 점유 | 연결시간↑ | 최소 전송률, 타임아웃 |
| **Handshakes 남용** | TLS/HTTP/2 초기 비용 남용 | 재협상/스트림 이벤트↑ | 프로토콜 옵션 제한, 리밋 |
| **비싼 엔드포인트 집중** | 검색/리포트/쿼리 | DB/캐시 Miss↑ | 캐시·큐·읽기복제·써킷브레이커 |

- **특기(사례형)**: “카펫 봄빙(Carpet Bombing)” — 단일 호스트가 아닌 **프리픽스 전체**에 분산 저강도 트래픽 → 호스트 기준 임계로는 탐지·차단 어려움 → **프리픽스 기반의 임계·탐지** 필요.

---

## 3. 용량·시간 감각(간단 모델)

- 스크러빙/엣지 처리 전 표적 링크 용량을 \(C\) (bps), 공격 도착률을 \(A\), 정상 트래픽을 \(N\)라 할 때, 링크 포화 조건은
$$
A + N > C.
$$
- 토큰 버킷 레이트 리밋(버킷 \(B\), 보충률 \(r\))의 **허용량 상한**:
$$
\text{허용}(t) \le r \cdot t + B.
$$
- SYN 백로그(용량 \(L\))에 평균 도착률 \(\lambda\), 평균 해소률 \(\mu\)라면, 과도 구간에서 **대기·드롭**은 \(\lambda > \mu\) 시 급증(큐잉 이론의 기본 직관).

---

## 4. 공격 생애주기(관점 정리)

1) **장비 확보**: 봇 감염/IoT 디폴트 패스워드, 리플렉터(오픈 서비스) 악용.  
2) **리허설/측정**: 표적 경로, 용량, 방어 체계 사전 파악.  
3) **실행**: 다중 벡터·다중 지역에서 동시에 발사.  
4) **적응**: 방어 감지 시 다른 프로토콜/포트/계층으로 전환.  
5) **중단/흔적**: 짧은 윈도우 반복, 장기 지속, 랜섬형 등 다양.

> 본 문서에서는 2)~4)에 **방어자 관점**의 대응·운영 절차를 제시한다.

---

## 5. 관측·탐지 — 패킷·플로우·애플리케이션의 다층 융합

### 5.1 패킷 기반 IDS/IPS 룰(개념 예; 실전은 공식 룰셋 권장)

```bash
# Suricata — 초당 SYN 급증 탐지(개념)
alert tcp any any -> $HOME_NET any (msg:"DDoS SYN spike"; flags:S; threshold:type both, track by_dst, count 10000, seconds 1; sid:300001;)

# UDP 리플렉션 표적 포트(예: 53/123/1900/389/11211 등) 급증
alert udp any any -> $HOME_NET [53,123,1900,389,11211] (msg:"Potential reflection flood"; detection_filter:track by_dst, count 20000, seconds 1; sid:300002;)

# ICMP 타입/코드 비정상 급증
alert icmp any any -> $HOME_NET any (msg:"ICMP abnormal rate"; detection_filter:track by_dst, count 20000, seconds 1; sid:300003;)
```

### 5.2 플로우 기반(대규모 DDoS 탐지의 핵심)

- **지표**: pps/bps/cps, 유니크 소스/ASN 카디널리티, **요청/응답 바이트 비율**, 포트/프로토콜 분포, 프리픽스 단위 합산.
- **예시 쿼리(개념)**

```bash
# nfdump: 분당 상위 pps 소스 Top-N
nfdump -r flows.nfd -s srcip/pps -n 20

# 프리픽스 집계(출처 ASN/국가 분포 확인은 외부 메타 연계 필요)
nfdump -r flows.nfd -s dstport -n 20
```

### 5.3 애플리케이션/프록시 계층

- **Nginx/HAProxy**: RPS, 동시 연결, 대기열 길이, 4xx/5xx 패턴, 특정 URI 집중.  
- **로그 기반 히스테리시스**: “초당 요청↑ + 4xx/5xx↑ + 특정 User-Agent 편향” 등의 **복합 조건**으로 경보.

```python
# nginx_access_watch.py — 교육용: 최근 10초 IP별 요청/429 비율 감시
import time, collections, sys
WINDOW=10
hist=collections.defaultdict(list)
for line in sys.stdin:  # tail -F access.log | python3 ...
    # 가정: '$remote_addr $status'
    try:
        ip, status = line.split()[0], int(line.split()[1])
    except:
        continue
    now=time.time()
    hist[ip].append((now,status))
    # 윈도우 정리
    hist[ip]=[(t,s) for t,s in hist[ip] if t>now-WINDOW]
    req=len(hist[ip])
    r429=sum(1 for _,s in hist[ip] if s==429)
    if req>200 and r429/req>0.3:  # 예시 임계
        print(f"[ALERT] {ip} req={req} 429ratio={r429/req:.2f}")
```

---

## 6. 네트워크 계층 완화 — 업스트림부터 오리진까지

### 6.1 업스트림/라우팅

- **BCP38/uRPF**: 소스 스푸핑 차단(공급자·업스트림 협력 필수).  
- **RTBH(Remote Triggered Blackhole)**: 표적 프리픽스 임시 무정차 흡수(서비스 포기·급한 불 끄기).  
- **BGP Flowspec**: 5튜플/플래그 기준으로 정밀 차단(운영사 협업 필요).  
- **Anycast + 스크러빙 센터**: 전 세계로 분산 → 스크러빙 후 정상 트래픽만 원점으로.

### 6.2 경계 장비/정책

```bash
# nftables 예(개념): SYN Rate, UDP 특정 포트 제어
nft add table inet filter
nft add chain inet filter input { type filter hook input priority 0; policy drop; }
nft add rule inet filter input ct state established,related accept
nft add rule inet filter input iif "lo" accept

# 필요한 ICMP만 허용(PTB/TTL Exceeded 등)
nft add rule inet filter input icmp type { destination-unreachable, time-exceeded, echo-request, echo-reply } limit rate 200/second accept

# SYN rate limit + 버스트
nft add rule inet filter input tcp flags syn / syn,rst limit rate 2000/second burst 2000 packets accept
nft add rule inet filter input tcp flags syn drop

# UDP 증폭원 대표 포트 제한(환경 맞춤)
nft add rule inet filter input udp dport {53,123,1900,389,11211} limit rate 1000/second burst 5000 packets accept
nft add rule inet filter input udp dport {53,123,1900,389,11211} drop
```

### 6.3 커널/커넥션 튜닝

```bash
# /etc/sysctl.d/50-ddos.conf
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_syn_backlog = 16384
net.core.somaxconn = 16384
net.ipv4.tcp_synack_retries = 3
net.ipv4.tcp_fin_timeout = 30
net.netfilter.nf_conntrack_max = 2097152
net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 30
```

---

## 7. 애플리케이션 계층 완화 — 리밋·챌린지·캐시·설계

### 7.1 웹 프런트(Nginx/HAProxy)

```nginx
# Nginx — 토큰 버킷 기반 속도/연결 제한 + 타임아웃
limit_req_zone $binary_remote_addr zone=reqip:10m rate=20r/s;
limit_conn_zone $binary_remote_addr zone=connip:10m;

http {
  keepalive_timeout  15;
  client_header_timeout 10;
  client_body_timeout 15;
  reset_timedout_connection on;

  server {
    listen 443 ssl http2;

    limit_req zone=reqip burst=40 nodelay;  # 엔드포인트에 따라 조정
    limit_conn connip 100;

    # CPU-비싼 엔드포인트 개별 리밋 강화
    location /search {
      limit_req zone=reqip burst=10;
      proxy_pass http://app;
    }
  }
}
```

```haproxy
# HAProxy — stick-table로 IP별 요청/연결 제어
frontend fe_https
  bind :443 ssl crt /etc/ssl/haproxy.pem alpn h2,http/1.1
  mode http
  stick-table type ip size 1m expire 10m store http_req_rate(10s),conn_cur
  http-request track-sc0 src
  acl abuse sc0_http_req_rate gt 200
  acl many_conn sc0_conn_cur gt 200
  http-request deny if abuse or many_conn
  default_backend be_app
```

### 7.2 캐시·오리진 셰일드·써킷 브레이커

- **CDN 캐시**로 정적·캐시 가능한 응답을 엣지에서 종결.  
- **Origin Shield**(중간 캐시 계층)로 원점 동시 도달 급증 억제.  
- **서킷 브레이커**: 백엔드 오류/지연 시 **즉시 실패**·**폴백**으로 자원 보호.  
- **Queue & 백압(Backpressure)**: 요청 큐 길이 상한, 초과 시 **정중한 실패**.

### 7.3 프로토콜 옵션(개념)

- **TLS**: 불필요한 재협상 비활성, 세션 재활용(세션 티켓/캐시), 강한 암호군.  
- **HTTP/2**: 스트림·헤더 크기·동시 스트림 수 제한, RST 남용 방지 설정.  
- **HTTP/3**: 초기 윈도우·동시 요청 제한, 퀵 패스 제한.

---

## 8. 클라우드·글로벌 아키텍처 패턴

- **Anycast + 글로벌 CDN + 스크러빙**: 분산 흡수 → 정제 → 오리진.  
- **멀티 리전 액티브/액티브**: 지리적 분산 + 리전 장애 격리.  
- **DNS 레벨 제어**: 헬스 체크·가중치·지연 기반 라우팅·드레인(peak-offload).  
- **인증 기반 접근**: 공개 엔드포인트 축소(관리·API는 ZTNA/SASE·프록시 뒤로).

---

## 9. 안전한 실습(공격 재현 없이 “방어·관찰”만)

> 목표: **병목을 인위적으로 만들고**, 리밋/타임아웃/큐·지표가 **의도대로 작동**하는지 검증한다. 공격 트래픽 생성·봇넷·증폭 실험은 **금지**.

### 9.1 토폴로지(네임스페이스)

```
[client(ns:c)] --HTTP--> [Nginx(ns:edge) Rate/Conn Limit] --HTTP--> [Flask(ns:app)]
                                                  |
                                           [모니터(ns:mon)]
```

### 9.2 구성 포인트

```bash
# app 인터페이스에 인위적 병목(예: 10Mbps) 부여
tc qdisc replace dev veth_app root tbf rate 10mbit burst 32kbit latency 400ms

# Nginx 설정은 §7.1 예시 적용
# client에서는 wrk/ab 등 합법적 저강도 부하로 2xx/429/대기열 동작 확인
```

### 9.3 앱 레벨 간단 리밋(교육용)

```python
# flask_token_bucket.py — 초당 20r/s IP별 제한(실전은 프록시/WAF 병행)
from flask import Flask, request, abort
import time, collections
app = Flask(__name__)
WINDOW, LIMIT = 1.0, 20
buckets = collections.defaultdict(list)

def allow(ip):
    now=time.time()
    q=buckets[ip]
    while q and q[0]<=now-WINDOW: q.pop(0)
    if len(q)<LIMIT: q.append(now); return True
    return False

@app.before_request
def guard():
    ip = request.headers.get('X-Forwarded-For', request.remote_addr)
    if not allow(ip): abort(429)

@app.route("/health")
def health(): return "ok"
```

---

## 10. 런북 — “감지 → 분류 → 완화 → 복구 → 사후”

1) **감지**: bps/pps/cps 급증, `SYN-RECV`↑, L7 RPS·에러율↑, conntrack 사용률↑.  
2) **분류**: Volumetric/Protocol/L7? 단일/다중 벡터? 단일 호스트/카펫 봄빙?  
3) **즉시 완화**:  
   - 업스트림 **스크러빙/RTBH/Flowspec** 요청,  
   - 경계 **Rate/ACL** 조정,  
   - WAF/프록시 **리밋/챌린지** 강화,  
   - 비즈니스 중요 엔드포인트만 **허용 목록** 운영.  
4) **근절**: 오픈 리졸버·증폭원 제거(내 자산), 커널/큐/백로그 튜닝, 캐시·오리진 셰일딩 확충.  
5) **복구**: 캐시 워밍, 큐·DB 풀 정상화, 사용자 커뮤니케이션.  
6) **사후**: 특성(ASN/국가/벡터/시간대) 문서화, 임계·룰 조정, **훈련 주기화**.

---

## 11. 표 — 벡터별 징후·대응 요약

| 레이어 | 벡터 | 주요 징후 | 1차 대응 | 2차 대응 |
|---|---|---|---|---|
| Volumetric | UDP/Reflection | bps/pps 한 방향 급증 | 스크러빙/RTBH | Anycast/용량 확장 |
| L3/4 | SYN Flood | SYN-RECV↑, 재전송↑ | SYN Cookies/Proxy, 백로그↑ | conntrack 튜닝·Bypass |
| L3/4 | ACK/RST/ICMP | 특정 플래그 편향 | Rate/ACL | DPI·정교 룰 |
| L7 | HTTP Flood | RPS/동시 연결↑ | CDN/WAF/리밋 | 앱 타임아웃·큐/캐시 |
| L7 | Slow Client | 연결시간↑ | 최소 전송률·타임아웃 | 이벤트 루프형 서버 |

---

## 12. 현장 명령 모음(즉시 진단)

```bash
# 네트워크/세션 개황
sar -n DEV 1 5
sar -n TCP,ETCP 1 5
ss -s
ss -ant state syn-recv | wc -l
conntrack -S 2>/dev/null || true

# 커널 큐/백로그/conntrack 상한
cat /proc/sys/net/ipv4/tcp_max_syn_backlog
cat /proc/sys/net/core/somaxconn
sysctl net.netfilter.nf_conntrack_max

# nftables 카운터 확인
nft list ruleset | grep -A2 -E 'limit|counter'
```

---

## 13. 운영 체크리스트

### 사전(Prevention)
- [ ] **BCP38/uRPF** 적용, **오픈 리졸버/증폭원** 제거  
- [ ] **CDN/WAF/스크러빙** 계약·런북 준비  
- [ ] **SYN Cookies/Proxy**, 커널/conntrack/큐 튜닝  
- [ ] **Rate/Conn Limit**, 프로토콜 옵션 제한(HTTP/2/3, TLS)  
- [ ] **캐시/Origin Shield/읽기 복제**로 L7 내성 확보  
- [ ] **모니터링/경보**(초 단위), **분기별 훈련**

### 실시간(Response)
- [ ] 지표 스냅샷(bps/pps/cps/RPS/큐/백로그)  
- [ ] 업스트림 **RTBH/Flowspec/스크러빙** 호출  
- [ ] 경계 **Rate/ACL**·WAF 리밋 강화, 중요 엔드포인트만 허용  
- [ ] 로그/플로우 샘플 지속 수집

### 사후(Post)
- [ ] 벡터·ASN·포트·URI·시간대 정리, **타임라인** 작성  
- [ ] 임계·룰·용량 재조정, **런북 교정**  
- [ ] 근본원인(노출 서비스/구성) 제거, 내부 교육

---

## 14. 부록 — 방어 스니펫(선별 사용)

### 14.1 iptables(레거시 환경)

```bash
# SYN rate 제한(개념)
iptables -A INPUT -p tcp --syn -m hashlimit --hashlimit 2000/second --hashlimit-burst 2000 \
         --hashlimit-mode srcip --hashlimit-name synlimit -j ACCEPT
iptables -A INPUT -p tcp --syn -j DROP

# ICMP 필수 유형 허용
iptables -A INPUT -p icmp --icmp-type fragmentation-needed -j ACCEPT
iptables -A INPUT -p icmp --icmp-type time-exceeded -j ACCEPT
```

### 14.2 Prometheus 경보(개념)

```yaml
groups:
- name: ddos.alerts
  rules:
  - alert: SYN_Backlog_Stress
    expr: node_netstat_Tcp_CurrEstab > 20000 or (node_netstat_Tcp_ActiveOpens - node_netstat_Tcp_PassiveOpens) > 50000
    for: 1m
    labels: {severity: critical}
    annotations:
      summary: "TCP stress on {{ $labels.instance }}"
```

---

## 15. 예상문제(실무/필답)

1) **Reflection/Amplification** 공격이 성립하려면 서비스 측 어떤 전제조건이 필요한가? **오픈 리졸버 제거**가 왜 핵심인가?  
2) **Carpet Bombing**이 호스트 기준 임계·탐지로 어려운 이유와 **프리픽스 기반** 집계의 필요성을 서술하라.  
3) **SYN Flood** 대응에서 **SYN Cookies/Proxy/Backlog/conntrack**의 역할을 각각 설명하라.  
4) L7 방어에서 **Rate Limit/챌린지/캐시/써킷 브레이커**의 상호 보완 관계를 설명하라.  
5) 업스트림 **RTBH/Flowspec**과 **Anycast+스크러빙**의 차이와 장단점을 비교하라.

---

## 16. 결론

- DDoS는 **규모·분산·적응성**으로 인해 **단일 기술**로는 막기 어렵다.  
- **업스트림(스크러빙/라우팅)** → **경계(L3/4 제어)** → **프런트(WAF/프록시)** → **오리진(캐시/설계)**의 **다층 방어**가 정석이다.  
- “측정 가능한 지표, 자동화된 런북, 주기적 훈련”이 **피해 최소화**의 핵심이다.