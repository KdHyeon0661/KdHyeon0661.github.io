---
layout: post
title: 영상처리 - 외곽선 기반의 푸리에 기술자
date: 2025-10-04 22:25:23 +0900
category: 영상처리
---
# 외곽선 기반의 푸리에 기술자 (Fourier Descriptors)

## 개념

### 윤곽선을 복소수 시퀀스로

외곽선 점열 \(\{(x_n,y_n)\}_{n=0}^{N-1}\) 를
\[
z_n = x_n + i y_n \quad (i^2=-1)
\]
로 두고, **등간격(호길이 기준)** 으로 샘플링합니다(§2.1).

### DFT와 기술자

\[
Z_k = \sum_{n=0}^{N-1} z_n \, e^{-i 2\pi kn/N}, \quad k=0,\dots,N-1
\]
- \(\{Z_k\}\) 가 **푸리에 기술자**입니다.
- 역변환으로 근사 윤곽 복원이 가능:
\[
\tilde{z}_n = \frac{1}{N}\sum_{k=0}^{N-1} \hat{Z}_k\, e^{+i 2\pi kn/N}
\]
여기서 \(\hat{Z}_k\) 는 **고주파 차단**(필요 계수만 남김) 및 **정규화**를 거친 계수입니다.

### 불변성(정규화)

- **이동 불변**: \(k=0\) 성분은 평균 위치 → \(Z_0=0\) 으로(중심화).
- **스케일 불변**: \(Z_1\) 의 크기(혹은 \(\sum|Z_k|^2\))로 정규화 → \(\hat{Z}_k = Z_k / |Z_1|\).
- **회전 불변**: \(Z_1\) 의 위상을 제거 → \(\hat{Z}_k = Z_k e^{-i\arg(Z_1)}\).
- **시작점 불변**: 시작점이 \(s\) 만큼 이동하면 \(Z_k \mapsto Z_k e^{i 2\pi ks/N}\).
  이를 제거하려면
  \[
  \hat{Z}_k = Z_k \, e^{-i k \psi}, \quad \psi = \arg\!\left(\frac{Z_1}{|Z_1|}\right)
  \]
  (회전 정규화 후 남는 시작점 위상 \(\psi\) 를 k배만큼 제거)

> 실무 팁: 비교용 **특징 벡터**는 \(\{|\hat{Z}_k|\}_{k\in\mathcal{K}}\) (크기만)이나, \(\{\Re,\Im\}\) 를 결합해도 됩니다.
> 재구성(시각화)에는 **복소계수 그대로**를 쓰되 고주파를 0으로 둡니다.

---

## 구현 상세

### 윤곽선 **등간격 재표본화**

래스터 픽셀 간격은 불균등합니다. **호길이 누적**을 구해 목표 샘플 수 \(N\) 에 대해 등간격 \(\ell_j = j\,L/(N-1)\) (총 길이 \(L\)) 위치를 보간하여 \(\{z_j\}\) 를 만듭니다. 보간은 **선형 보간**으로 충분합니다.

### DFT/IDFT

- 샘플 수 \(N\) 은 128, 256, 512 등을 권장.
- 본 장은 범용 **\( \mathcal{O}(N^2)\) DFT** 구현과, 선택적으로 빠른 **Cooley–Tukey FFT**(N=2^m) 구현을 제공합니다.

### 정규화 옵션(불변성)

- `normalize_translation` (Z0=0)
- `normalize_scale` (나눗수: \(|Z_1|\), 대체: L2 norm)
- `normalize_rotation` (위상 제거: 곱 \(e^{-i\arg Z_1}\))
- `normalize_start` (시작점 위상 제거: 곱 \(e^{-ik\psi}\))

### 재구성(시각화)

- **저주파 K개**만 남겨 역변환 → 부드러운 근사 윤곽선.
- 원본 위 **오버레이**로 결과를 확인합니다(색상/닫힌 곡선).

---

## 코드 — **FourierDescriptors.hpp** (재표본화·DFT·정규화·복원·오버레이)

```cpp
// FourierDescriptors.hpp
#pragma once
#include <vector>
#include <complex>
#include <cmath>
#include <algorithm>
#include <string>
#include <limits>
#include "IppDib.h"
#include "ContourTracing.hpp" // 13.3절: ContourSet, DrawPolylineOnDib 등

using c64 = std::complex<double>;
constexpr double PI = 3.1415926535897932384626433832795;

// ===== 유틸 =====
inline double hypot2(int dx,int dy){ return std::sqrt(double(dx*dx + dy*dy)); }

// DIB → 이진 → 윤곽선(가장 긴 것 하나 선택 또는 전체 반환)
inline ContourSet ExtractContoursFromDib(const IppDib& dib, bool onlyLongest=true, int minLen=20){
    TraceOptions opt; opt.conn=Connectivity::C8; opt.minLen=minLen; opt.overlay=false;
    ContourSet cs; IppDib ov;
    RunContourTracing(dib, ov, cs, opt);
    if (!onlyLongest) return cs;
    ContourSet out;
    if (cs.contours.empty()) return out;
    auto it = std::max_element(cs.contours.begin(), cs.contours.end(),
        [](const Contour& a, const Contour& b){ return a.points.size()<b.points.size(); });
    out.contours.push_back(*it);
    return out;
}

// 등간격(호길이) 재표본화 (출력 N개, 폐곡선 가정)
inline std::vector<POINT> ResampleContour(const std::vector<POINT>& P, int N){
    std::vector<POINT> out; out.reserve(N);
    if (P.size()<2){ out = P; return out; }

    // 길이 누적(폐곡선: 마지막-처음 연결 포함)
    const int M=(int)P.size();
    std::vector<double> acc(M+1, 0.0);
    for (int i=1;i<M;++i)
        acc[i]=acc[i-1]+hypot2(P[i].x-P[i-1].x, P[i].y-P[i-1].y);
    // 폐곡선 연결
    double Lclose = hypot2(P[0].x-P[M-1].x, P[0].y-P[M-1].y);
    acc[M] = acc[M-1] + Lclose;
    double L = acc[M];
    if (L<=0){ out = P; return out; }

    // 목표 간격
    for (int j=0;j<N;++j){
        double t = (L*j)/N; // [0, L)
        // acc 에서 위치 찾기
        auto it = std::upper_bound(acc.begin(), acc.end(), t);
        int idx = int(it-acc.begin()) - 1;
        if (idx<0) idx=0; if (idx>=M) idx=M-1;
        double t0=acc[idx], t1=acc[idx+1];
        int i0=idx, i1=(idx+1)%M;
        double s = (t1>t0)? ( (t-t0)/(t1-t0) ) : 0.0;
        double x = (1.0-s)*P[i0].x + s*P[i1].x;
        double y = (1.0-s)*P[i0].y + s*P[i1].y;
        out.push_back(POINT{ (LONG)std::lround(x),(LONG)std::lround(y) });
    }
    return out;
}

// 실수 좌표 → 복소 벡터
inline std::vector<c64> PointsToComplex(const std::vector<POINT>& P){
    std::vector<c64> z; z.reserve(P.size());
    for (auto& p: P) z.emplace_back(double(p.x), double(p.y));
    return z;
}
inline std::vector<POINT> ComplexToPoints(const std::vector<c64>& z){
    std::vector<POINT> P; P.reserve(z.size());
    for (auto& v: z) P.push_back(POINT{ (LONG)std::lround(v.real()), (LONG)std::lround(v.imag()) });
    return P;
}

// DFT (O(N^2)) — N~128–512면 충분히 빠름
inline std::vector<c64> DFT(const std::vector<c64>& z){
    const int N=(int)z.size();
    std::vector<c64> Z(N, c64(0,0));
    const double w = -2.0*PI/N;
    for (int k=0;k<N;++k){
        c64 s(0,0);
        for (int n=0;n<N;++n){
            double a = w*k*n;
            s += z[n] * c64(std::cos(a), std::sin(a));
        }
        Z[k]=s;
    }
    return Z;
}
inline std::vector<c64> IDFT(const std::vector<c64>& Z){
    const int N=(int)Z.size();
    std::vector<c64> z(N, c64(0,0));
    const double w = +2.0*PI/N;
    for (int n=0;n<N;++n){
        c64 s(0,0);
        for (int k=0;k<N;++k){
            double a = w*k*n;
            s += Z[k] * c64(std::cos(a), std::sin(a));
        }
        z[n]=s / double(N);
    }
    return z;
}

// ===== 정규화 옵션 =====
struct FDOptions {
    int sampleN = 256;           // 등간격 재표본화 개수
    int keepK   = 32;            // 0..N-1 중 저주파만 남길 개수(대역 제한용, 재구성 시 사용)
    bool normalize_translation = true; // Z0=0
    bool normalize_scale       = true; // divide by |Z1|
    bool normalize_rotation    = true; // multiply by e^{-i arg(Z1)}
    bool normalize_start       = true; // multiply by e^{-i k psi}, psi = arg(Z1 after rotation)
    bool overlay_recon         = true; // 복원 외곽선 오버레이
    uint8_t R=64,G=200,B=255;          // 오버레이 색
};

// k 인덱스가 저주파인지 검사 (0..keepK, 그리고 N-keepK..N-1 유지)
inline bool LowPassMask(int k, int N, int keepK){
    if (keepK<=0) return (k==0); // DC만
    if (k<=keepK) return true;
    if (k>=N-keepK) return true;
    return false;
}

// 정규화된 FD 계산 + (선택) 저역만 남겨 복원
struct FDResult {
    int N=0;
    std::vector<c64> Z;          // 정규화된 전체 계수
    std::vector<c64> Z_band;     // 저역만 남긴 계수(복원/시각화)
    std::vector<POINT> recon;    // 복원 윤곽선 점열(화면 오버레이용)
    double scaleUsed=1.0;        // 사용된 scale (|Z1|)
    double rotPhase=0.0;         // 제거한 회전 위상
    double startPhase=0.0;       // 제거한 시작점 위상(회전 제거 이후)
};

inline FDResult ComputeFourierDescriptors(const std::vector<POINT>& contour, const FDOptions& opt){
    FDResult res;
    if ((int)contour.size()<4){ return res; }

    // 1) 재표본화
    auto Pn = ResampleContour(contour, opt.sampleN);
    auto zn = PointsToComplex(Pn);

    // 2) DFT
    auto Z = DFT(zn);
    const int N = (int)Z.size();
    res.N = N;

    // 3) 정규화
    // 이동: Z0=0
    if (opt.normalize_translation) Z[0] = c64(0,0);

    // 회전 정규화: e^{-i arg(Z1)}
    double rot = 0.0;
    if (opt.normalize_rotation){
        if (std::abs(Z[1])>1e-12){
            rot = std::arg(Z[1]);
            c64 ph = std::exp(c64(0,-rot));
            for (int k=0;k<N;++k) Z[k]*=ph;
        }
    }
    res.rotPhase = rot;

    // 시작점 정규화: e^{-i k psi}, psi = arg(Z1)
    double psi = 0.0;
    if (opt.normalize_start){
        if (std::abs(Z[1])>1e-12){
            psi = std::arg(Z[1]); // 회전 제거 이후 → 시작점 위상만 남음
            for (int k=0;k<N;++k){
                double a = -psi * k;
                Z[k] *= std::exp(c64(0,a));
            }
        }
    }
    res.startPhase = psi;

    // 스케일 정규화: / |Z1|
    double scl = 1.0;
    if (opt.normalize_scale){
        double s = std::abs(Z[1]);
        if (s<1e-12){
            // fallback: 다음 비영 계수 탐색
            for (int k=2;k<N;++k){ if (std::abs(Z[k])>1e-12){ s=std::abs(Z[k]); break; } }
        }
        if (s>1e-12){
            scl = s;
            for (int k=0;k<N;++k) Z[k]/=scl;
        }
    }
    res.scaleUsed = scl;

    res.Z = Z;

    // 4) 저역만 남기기 (대역 제한)
    auto Zb = Z;
    for (int k=0;k<N;++k) if (!LowPassMask(k,N,opt.keepK)) Zb[k]=c64(0,0);
    res.Z_band = Zb;

    // 5) 복원
    auto zrec = IDFT(Zb);
    res.recon = ComplexToPoints(zrec);
    return res;
}

// 오버레이: 복원 외곽선을 색으로 덧그리기
inline IppDib OverlayFDReconstruction(const IppDib& src, const FDResult& fd, uint8_t R,uint8_t G,uint8_t B){
    IppDib out = src;
    DrawPolylineOnDib(out, fd.recon, R,G,B, /*closed=*/true);
    return out;
}
```

---

## UI — **Fourier Descriptors** 대화 상자 & 메뉴

### 리소스 ID

```cpp
// resource.h (추가)
#define ID_MENU_FOURIER_DESC               89010

#define IDD_FOURIER_DESC_DLG               4600
#define IDC_EDIT_FD_SAMPLES                4601
#define IDC_EDIT_FD_KEEPK                  4602
#define IDC_CHK_FD_TRANS                   4603
#define IDC_CHK_FD_SCALE                   4604
#define IDC_CHK_FD_ROT                     4605
#define IDC_CHK_FD_START                   4606
#define IDC_CHK_FD_OVERLAY                 4607
#define IDC_EDIT_FD_R                      4608
#define IDC_EDIT_FD_G                      4609
#define IDC_EDIT_FD_B                      4610
#define IDC_CMB_FD_CONTOUR                 4611
#define IDC_STC_FD_SUMMARY                 4612

```

### RC (메뉴 & 대화 상자)

```rc
// ImageTool.rc (추가)
POPUP "&Analyze"
BEGIN
    MENUITEM "Fourier Descriptors...\tCtrl+F", ID_MENU_FOURIER_DESC
END

IDD_FOURIER_DESC_DLG DIALOGEX 0,0, 320, 206
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Fourier Descriptors (Contour-based)"
FONT 9, "Segoe UI"
BEGIN
    LTEXT "Contour:", -1, 12, 14, 44, 10
    COMBOBOX IDC_CMB_FD_CONTOUR, 62, 12, 246, 80, CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP

    LTEXT "Samples (N):", -1, 12, 40, 60, 10
    EDITTEXT IDC_EDIT_FD_SAMPLES, 78, 38, 36, 14, ES_NUMBER
    LTEXT "Keep K:", -1, 128, 40, 40, 10
    EDITTEXT IDC_EDIT_FD_KEEPK, 172, 38, 36, 14, ES_NUMBER

    GROUPBOX "Normalization", -1, 12, 60, 140, 72
    AUTOCHECKBOX "Translation", IDC_CHK_FD_TRANS,  22, 74, 90, 12
    AUTOCHECKBOX "Scale",       IDC_CHK_FD_SCALE,  22, 88, 90, 12
    AUTOCHECKBOX "Rotation",    IDC_CHK_FD_ROT,    22,102, 90, 12
    AUTOCHECKBOX "Start index", IDC_CHK_FD_START,  22,116, 90, 12

    AUTOCHECKBOX "Overlay reconstruction", IDC_CHK_FD_OVERLAY, 164, 74, 140, 12
    LTEXT "Color (R,G,B):", -1, 164, 98, 70, 10
    EDITTEXT IDC_EDIT_FD_R,  238, 96, 24, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_FD_G,  266, 96, 24, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_FD_B,  294, 96, 24, 14, ES_NUMBER

    LTEXT "Summary:", -1, 12, 138, 50, 10
    LTEXT "", IDC_STC_FD_SUMMARY, 62, 136, 246, 34

    DEFPUSHBUTTON "Run", IDOK,  196, 176, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 246, 176, 44, 16
END
```

### 대화 상자 코드

```cpp
// FourierDescDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "FourierDescriptors.hpp"

// 앱 공용 헬퍼(앞 장들과 동일 스타일)
struct DocRef { HWND hwnd; IppDib* dib; std::wstring title; };
std::vector<DocRef> GetOpenDocs();
HWND CreateDocWindowFromDib(const IppDib& dib, const std::wstring& title);

class FourierDescDlg {
public:
    FourierDescDlg(HWND owner, IppDib& target) : owner_(owner), target_(target) {}
    INT_PTR DoModal();
private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM);
    void Run(HWND h);

private:
    HWND owner_{};
    IppDib& target_;
    ContourSet contours_;
};
```

```cpp
// FourierDescDlg.cpp
#include "FourierDescDlg.h"

INT_PTR FourierDescDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_FOURIER_DESC_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK FourierDescDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        return ((FourierDescDlg*)l)->OnInit(h); }
    auto* self=(FourierDescDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w);
    return FALSE;
}
INT_PTR FourierDescDlg::OnInit(HWND h){
    // 현재 이미지에서 윤곽선 목록 가져오기(최소 길이 30)
    contours_ = ExtractContoursFromDib(target_, /*onlyLongest=*/false, /*minLen=*/30);
    HWND cmb = GetDlgItem(h, IDC_CMB_FD_CONTOUR);
    int sel=0, idx=0;
    if (contours_.contours.empty()){
        SendMessageW(cmb, CB_ADDSTRING, 0, (LPARAM)L"(no contour found)");
        SendMessageW(cmb, CB_SETCURSEL, 0, 0);
    }else{
        int maxL=0;
        for (auto& c: contours_.contours){
            wchar_t buf[64];
            wsprintfW(buf, L"#%d len=%d", ++idx, (int)c.points.size());
            SendMessageW(cmb, CB_ADDSTRING, 0, (LPARAM)buf);
            if ((int)c.points.size()>maxL){ maxL=(int)c.points.size(); sel=idx-1; }
        }
        SendMessageW(cmb, CB_SETCURSEL, sel, 0); // 가장 긴 것 기본 선택
    }

    SetDlgItemInt(h, IDC_EDIT_FD_SAMPLES, 256, FALSE);
    SetDlgItemInt(h, IDC_EDIT_FD_KEEPK,   32,  FALSE);
    CheckDlgButton(h, IDC_CHK_FD_TRANS, BST_CHECKED);
    CheckDlgButton(h, IDC_CHK_FD_SCALE, BST_CHECKED);
    CheckDlgButton(h, IDC_CHK_FD_ROT,   BST_CHECKED);
    CheckDlgButton(h, IDC_CHK_FD_START, BST_CHECKED);
    CheckDlgButton(h, IDC_CHK_FD_OVERLAY, BST_CHECKED);
    SetDlgItemInt(h, IDC_EDIT_FD_R,  64, FALSE);
    SetDlgItemInt(h, IDC_EDIT_FD_G, 200, FALSE);
    SetDlgItemInt(h, IDC_EDIT_FD_B, 255, FALSE);
    SetDlgItemTextW(h, IDC_STC_FD_SUMMARY, L"(ready)");
    return TRUE;
}
INT_PTR FourierDescDlg::OnCommand(HWND h, WPARAM w){
    switch(LOWORD(w)){
    case IDOK:    Run(h); EndDialog(h, IDOK); return TRUE;
    case IDCANCEL: EndDialog(h, IDCANCEL);    return TRUE;
    }
    return FALSE;
}
void FourierDescDlg::Run(HWND h){
    if (contours_.contours.empty()){
        MessageBoxW(h, L"윤곽선을 찾지 못했습니다. (이진화/외곽선 추적을 확인하세요.)",
                    L"Fourier Descriptors", MB_ICONWARNING);
        return;
    }
    BOOL ok=FALSE;
    int N  = GetDlgItemInt(h, IDC_EDIT_FD_SAMPLES, &ok, FALSE); if (!ok||N<16) N=256;
    int K  = GetDlgItemInt(h, IDC_EDIT_FD_KEEPK,   &ok, FALSE); if (!ok||K<0)  K=32;
    bool t = (IsDlgButtonChecked(h, IDC_CHK_FD_TRANS)==BST_CHECKED);
    bool s = (IsDlgButtonChecked(h, IDC_CHK_FD_SCALE)==BST_CHECKED);
    bool r = (IsDlgButtonChecked(h, IDC_CHK_FD_ROT)==BST_CHECKED);
    bool b = (IsDlgButtonChecked(h, IDC_CHK_FD_START)==BST_CHECKED);
    bool ov = (IsDlgButtonChecked(h, IDC_CHK_FD_OVERLAY)==BST_CHECKED);
    int R = GetDlgItemInt(h, IDC_EDIT_FD_R, &ok, FALSE); if (!ok) R=64;
    int G = GetDlgItemInt(h, IDC_EDIT_FD_G, &ok, FALSE); if (!ok) G=200;
    int B = GetDlgItemInt(h, IDC_EDIT_FD_B, &ok, FALSE); if (!ok) B=255;

    int sel = (int)SendDlgItemMessageW(h, IDC_CMB_FD_CONTOUR, CB_GETCURSEL, 0, 0);
    if (sel<0 || sel>=(int)contours_.contours.size()) sel=0;

    FDOptions opt; opt.sampleN=N; opt.keepK=K;
    opt.normalize_translation=t; opt.normalize_scale=s;
    opt.normalize_rotation=r;    opt.normalize_start=b;
    opt.overlay_recon=ov; opt.R=(uint8_t)R; opt.G=(uint8_t)G; opt.B=(uint8_t)B;

    auto fd = ComputeFourierDescriptors(contours_.contours[sel].points, opt);

    wchar_t sum[196];
    wsprintfW(sum, L"N=%d, keepK=%d, |Z1|=%.3f, rot=%.2f°, start=%.2f°",
              fd.N, K, fd.scaleUsed, fd.rotPhase*180.0/PI, fd.startPhase*180.0/PI);
    SetDlgItemTextW(h, IDC_STC_FD_SUMMARY, sum);

    if (ov && !fd.recon.empty()){
        IppDib out = OverlayFDReconstruction(target_, fd, (uint8_t)R,(uint8_t)G,(uint8_t)B);
        CreateDocWindowFromDib(out, L"Fourier Descriptors (recon)");
        // 상위 몇 개 계수의 크기를 팝업으로 보여주기
        std::wstring msg=L"Top magnitudes:\n";
        struct Pair{int k; double v;};
        std::vector<Pair> mags;
        for (int k=1;k<=std::min(fd.N/2,256);++k){
            mags.push_back(Pair{k, std::abs(fd.Z[k])});
        }
        std::sort(mags.begin(), mags.end(), [](auto&a,auto&b){ return a.v>b.v; });
        int cnt=0;
        for (auto& p: mags){
            wchar_t line[96]; wsprintfW(line, L" k=%d: |Zk|=%.4f\n", p.k, p.v);
            msg+=line; if (++cnt>=10) break;
        }
        MessageBoxW(owner_, msg.c_str(), L"Fourier Descriptors", MB_OK|MB_ICONINFORMATION);
    }
}
```

```cpp
// main_multiwin.cpp (발췌)
#include "FourierDescDlg.h"

// ...
case ID_MENU_FOURIER_DESC:
    if (st && st->dib){
        FourierDescDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            UpdateStatusBasic(hWnd, st); // 상태바에 N/K 등 간략 표시 가능
        }
    }
    return 0;
```

---

## 수학적 보충

### 불변성 정리

- **이동**: \(z_n\mapsto z_n + c\) 이면 \(Z_0\mapsto Z_0+Nc\), \(k\ge1\) 불변. → \(Z_0=0\) 으로 무력화.
- **스케일**: \(z_n\mapsto \alpha z_n\) 이면 \(Z_k\mapsto \alpha Z_k\). → \(|Z_1|\) 로 나누어 무력화.
- **회전**: \(z_n\mapsto z_n e^{i\theta}\) 이면 \(Z_k\mapsto Z_k e^{i\theta}\). → \(e^{-i\arg Z_1}\) 곱으로 제거.
- **시작점**: \(z_n\mapsto z_{n+s}\) 이면 \(Z_k\mapsto Z_k e^{i2\pi ks/N}\).
  \(\psi=\arg(Z_1/|Z_1|)\) 을 구한 뒤 \(\hat{Z}_k = Z_k e^{-ik\psi}\) 로 제거.

> 위 네 가지를 모두 적용하면, (원형/유사 변환) 하에서 동일 형태는 **같은 기술자**(또는 크기열)로 맵핑됩니다.

### 대역 제한(저주파 K개)

외곽선의 전반적인 형태는 **저주파**에 담깁니다.
고주파를 0으로 두면 **매끄러운 근사**가 되며 잡음에 강인해집니다.

---

## 예제 시나리오

### **동전 vs 육각 너트 구분 (회전·스케일 불변)**

- **상황**: 동전(원형)과 육각 너트(육각형) 이미지. 외곽선은 13.3절로 추출.
- **설정**: `N=256, K=12`, **Translation/Scale/Rotation/Start = ON**.
- **관찰**:
  - 원형은 \(|\hat{Z}_k|\) 가 \(k=1\) 제외 대부분 매우 작음.
  - 육각형은 \(k=6\) 부근 계수 크기가 상대적으로 큼.
- **활용**: \(\{|\hat{Z}_k|\}_{k=2..K}\) 를 특징 벡터로 최근접(코사인/유클리드) 분류.

### **윤곽 복원 품질(K에 따른 변화)**

- **상황**: 임의 객체 외곽.
- **절차**: `K=4, 8, 16, 32` 로 바꿔가며 Run → 새 창에 **파란색 복원 윤곽** 오버레이.
- **결과**: K가 커질수록 복원이 정밀해지나, 잡음 영향도 증가. 감쇠 필터(예: \(k>K\) 에서 0)로 스무딩.

### **시작점 불변성의 효과**

- **상황**: 동일 물체가 서로 다른 픽셀에서 외곽선 추출 시작.
- **설정**: Start OFF → 특징 벡터가 달라짐, Start ON → 동일해짐.
- **요점**: 실제 응용(분류/검색)에서는 시작점 불변을 켜는 것이 안전.

---

## 정확성·성능·확장 팁

- **재표본화**는 결과에 매우 중요. **등간격(호길이)** 을 반드시 사용하세요.
- \(N\) 은 128~512 권장. K는 8~64 사이에서 문제 난이도에 맞춰 선택.
- **FFT 최적화**: 대규모 배치 처리라면 10.3절 FFT를 연결해 \(\mathcal{O}(N\log N)\) 로 가속.
- **특징 벡터**: 분류는 보통 \(|\hat{Z}_k|\) (크기)만으로 충분. 위상까지 쓰면 정합력↑(단, 시작점 관리 필요).
- **개방 곡선**(열린 윤곽)은 wrap을 끄고 재표본화·DFT 정의를 살짝 바꿔야 합니다(본 장은 폐곡선 기준).

---

## 빠른 자가 테스트

```cpp
// test_fourier_desc.cpp
#include <cassert>
#include "IppDib.h"
#include "FourierDescriptors.hpp"

int main(){
    // 인공 원: 중심(100,80), 반지름 40, 샘플 128
    std::vector<POINT> circle;
    for(int n=0;n<128;++n){
        double a = 2*PI*n/128.0;
        circle.push_back(POINT{ (LONG)std::lround(100 + 40*std::cos(a)),
                                (LONG)std::lround( 80 + 40*std::sin(a)) });
    }

    FDOptions opt; opt.sampleN=256; opt.keepK=12;
    opt.normalize_translation=opt.normalize_scale=opt.normalize_rotation=opt.normalize_start=true;
    auto fd = ComputeFourierDescriptors(circle, opt);

    // 원의 경우, 정규화 후 고차 계수 크기가 매우 작아야 함
    double energy=0; for (int k=2;k<fd.N/2;++k) energy += std::norm(fd.Z[k]);
    assert(energy < 1e-6); // 이상적 모델에서는 ~0 (수치 오차 포함)
    return 0;
}
```

---

## 요약

- 외곽선을 복소 시퀀스로 보고 **DFT 계수**를 특징으로 쓰는 것이 **푸리에 기술자**입니다.
- 이동/스케일/회전/시작점 정규화로 **형태 불변** 특징을 만들고, 저주파만 남겨도 **충분한 식별력**과 **노이즈 강인성**을 얻습니다.
- 본 장의 구현은 재표본화 → DFT → 정규화 → 저역 복원(오버레이)까지 한 번에 제공하며,
  “**Fourier Descriptors…**” 대화 상자에서 N/K/정규화 옵션을 조절해 즉시 실전에 적용할 수 있습니다.
