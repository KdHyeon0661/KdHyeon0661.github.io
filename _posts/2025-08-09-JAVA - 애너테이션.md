---
layout: post
title: Java - 애너테이션
date: 2025-08-09 14:20:23 +0900
category: Java
---
# 애너테이션(Annotation) 정의·메타·사용·프로세싱

애너테이션(Annotation)은 **코드에 의미(메타데이터)를 부여**하여 **컴파일러, 빌드 도구, 프레임워크, 런타임**이 **자동화된 동작**을 수행하도록 하는 장치다.

## 애너테이션의 핵심 개념

- **메타데이터**: 클래스, 메서드, 필드, 파라미터, 타입 사용 위치 등에 **부가정보**를 부착.
- **자체 로직 없음**: 의미 해석은 **컴파일러/도구/프레임워크/런타임 코드**가 수행.
- **주요 목적**
  - **컴파일러 지시**: `@Override`, `@SuppressWarnings`, 소스 생성/검증(AP)
  - **런타임 제어**: DI/AOP/직렬화/검증(리플렉션)
  - **문서화**: `@Documented`, API 스펙 표식

---

## 표준 애너테이션(대표)

| 애너테이션 | 역할 | 비고 |
|---|---|---|
| `@Override` | 메서드가 상위/인터페이스 메서드를 재정의함을 표시 | 오타/시그니처 불일치 시 컴파일 오류 |
| `@Deprecated` | 사용 지양 표시 | Javadoc/IDE 경고, `since`, `forRemoval` 속성 활용 |
| `@SuppressWarnings` | 컴파일 경고 억제 | `"unchecked"`, `"deprecation"`, `"rawtypes"` 등 |
| `@FunctionalInterface` | 추상 메서드 1개 보장 | 람다/메서드 참조 타겟 |
| `@SafeVarargs` | 가변인자 제네릭 안전 선언 | `final`/`static`/생성자에서만 |
| `@Native` | 네이티브 코드에서 참조 상수 표시 | 상수 필드에 부착 |
| `@Generated` | 생성 코드 표식 | JDK 9+는 `javax.annotation.processing.Generated` (과거 `javax.annotation.Generated`와 구분) |

> 최신 JDK에서도 위 개념은 유지되며, JDK 9부터는 `@Generated` 위치가 **annotation.processing 패키지**로 이동했다.

---

## 메타 애너테이션 — 정의 시에 반드시 쓰는 5종

| 메타 | 의미 | 값/설정 | 메모 |
|---|---|---|---|
| `@Target` | **부착 위치 제한** | `TYPE`, `METHOD`, `FIELD`, `PARAMETER`, `CONSTRUCTOR`, `LOCAL_VARIABLE`, `PACKAGE`, **`TYPE_USE`**, **`TYPE_PARAMETER`**, **`MODULE`**, **`RECORD_COMPONENT`** | **필요 최소**로 좁혀 오용 차단 |
| `@Retention` | **유지 기간** | `SOURCE` / `CLASS`(기본) / **`RUNTIME`** | 런타임 리플렉션이면 **RUNTIME** |
| `@Documented` | Javadoc 포함 | - | 공개 API 표식에 권장 |
| `@Inherited` | 클래스 상속 전파 | - | **클래스 타입에만** 유효(멤버/인터페이스 X) |
| `@Repeatable` | 반복 적용 | 컨테이너 애너테이션 지정 | 컨테이너의 Target/Retention은 원본과 동일 |

---

## 사용자 정의 애너테이션 — 정의 규칙/제약

### 허용되는 요소(Element) 타입

- 원시 타입, `String`, `Class`(또는 `? extends`), `enum`, **다른 애너테이션**, 그리고 **이들의 배열**
- **기본값(default)**은 **컴파일 타임 상수**만 가능(메서드 호출 결과 불가)
- `null` 기본값 개념 없음(필수면 기본값 생략)

### `value()` 단축 규칙

- 요소가 `value()` 하나뿐이거나 나머지가 전부 기본값이면 `@Ann("x")`로 축약 가능
- 다른 요소를 함께 지정하면 풀 표기 필요: `@Ann(value="x", count=2)`

### 예시: 정의/사용

```java
import java.lang.annotation.*;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnnotation {
    String value();           // 필수
    int count() default 1;    // 선택
}

// 사용
class Svc {
    @MyAnnotation("hello")
    public void work() {}
}
```

---

## 적용 위치 확장 — TYPE_USE/TYPE_PARAMETER, MODULE, RECORD_COMPONENT

```java
import java.lang.annotation.*;

@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@interface NonNull {}

// 제네릭 파라미터와 타입 사용 위치
class Box<@NonNull T> {
    @NonNull String join(@NonNull String a, @NonNull String b) { return a + b; }
}
```

- `MODULE`(Java 9+): `module-info.java`에 부착 가능한 애너테이션
- `RECORD_COMPONENT`(Java 14+): 레코드 컴포넌트 수준

---

## 반복/상속/문서화 메타 기능

### `@Repeatable`

```java
import java.lang.annotation.*;

@Repeatable(Tags.class)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface Tag { String value(); }

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface Tags { Tag[] value(); }

@Tag("java") @Tag("annotation")
class Article {}
```
- 리플렉션: `getAnnotationsByType(Tag.class)`로 평탄화된 배열을 얻는다.

### `@Inherited` (클래스 상속에만)

```java
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface Audited {}

@Audited class Parent {}
class Child extends Parent {} // Child.class.isAnnotationPresent(Audited.class) == true
```

### `@Documented` — 공개 API 문서화

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
@interface PublicApi {}
```

---

## 리플렉션(Reflection)으로 읽기/적용

### 기본 읽기

```java
import java.lang.reflect.*;

class Reader {
    static void printMethodAnnos(Class<?> c) {
        for (Method m : c.getDeclaredMethods()) {
            MyAnnotation a = m.getAnnotation(MyAnnotation.class);
            if (a != null) {
                System.out.printf("%s: value=%s, count=%d%n", m.getName(), a.value(), a.count());
            }
        }
    }
}
```

### TYPE_USE 조회(파라미터 타입 애너테이션)

```java
import java.lang.reflect.AnnotatedType;

class Introspect {
    static void checkParams(Class<?> c, String name, Class<?>... params) throws Exception {
        var m = c.getDeclaredMethod(name, params);
        AnnotatedType[] ats = m.getAnnotatedParameterTypes();
        for (int i = 0; i < ats.length; i++) {
            boolean nonNull = ats[i].isAnnotationPresent(NonNull.class);
            System.out.printf("param #%d NonNull? %s%n", i, nonNull);
        }
    }
}
```

### 성능 팁

- `Method/Field/Constructor` 조회 결과는 **캐시**(Map)하여 재사용
- JPMS에서 비공개 패키지 접근은 `opens` 또는 실행옵션 `--add-opens` 필요(§10)

---

## 실전 미니 패턴 — 검증/로깅/재시도

### 필드 검증기

```java
import java.lang.annotation.*;
import java.lang.reflect.Field;

@Documented
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@interface Range { int min(); int max(); }

class User {
    @Range(min=1, max=99) int age;
    User(int a){ age=a; }
}

class Validator {
    static void validate(Object o) throws Exception {
        for (Field f : o.getClass().getDeclaredFields()) {
            Range r = f.getAnnotation(Range.class);
            if (r == null) continue;
            f.setAccessible(true);
            int v = (int) f.get(o);
            if (v < r.min() || v > r.max()) {
                throw new IllegalArgumentException(f.getName() + " out of range: " + v);
            }
        }
    }
}
```

### 실행 시간 로깅

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface LogTime {}

class Timed {
    @LogTime void job(){ /* ... */ }
}

class Runner {
    static Object invoke(Object t, String name) throws Exception {
        var m = t.getClass().getDeclaredMethod(name);
        m.setAccessible(true);
        long t0 = System.nanoTime();
        try { return m.invoke(t); }
        finally {
            if (m.isAnnotationPresent(LogTime.class)) {
                System.out.printf("%s took %d μs%n", name, (System.nanoTime()-t0)/1000);
            }
        }
    }
}
```

### 재시도(예외별)

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface Retry {
    int times() default 3;
    long backoffMs() default 100;
    Class<? extends Throwable> on() default Exception.class;
}
```

---

## 컴파일 타임 애너테이션 프로세싱(AP) — 소스 생성/검증

**목표**: `@Retention(SOURCE)` 애너테이션을 컴파일 단계에서 읽어 **코드 생성, 규칙 검증**.

### 애너테이션

```java
import java.lang.annotation.*;
@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.TYPE)
public @interface AutoBuilder { String value() default ""; }
```

### 프로세서 스켈레톤

```java
import javax.annotation.processing.*;
import javax.lang.model.element.*;
import javax.lang.model.SourceVersion;
import java.util.Set;

@SupportedAnnotationTypes("com.example.AutoBuilder")
@SupportedSourceVersion(SourceVersion.RELEASE_21) // JDK에 맞춰 조정
public class AutoBuilderProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annos, RoundEnvironment env) {
        for (Element e : env.getElementsAnnotatedWith(
                processingEnv.getElementUtils().getTypeElement("com.example.AutoBuilder"))) {
            // e의 필드/생성자 분석 → 소스 생성
            // processingEnv.getFiler().createSourceFile("...") 사용
        }
        return true; // 우리가 처리
    }
}
```

### 빌드 연동(요지)

- **Maven**: `maven-compiler-plugin`의 `annotationProcessorPaths` 사용
- **Gradle**: `annotationProcessor("group:artifact:version")`

> 런타임 리플렉션이 느리거나 위험할 때 **AP로 코드를 생성**해 성능/안정성을 확보하는 전략이 유효하다(Lombok/MapStruct/Dagger 등).

---

## JPMS(모듈) 시대의 애너테이션/리플렉션

- 모듈 경계에서는 **비공개 패키지를 리플렉션으로 접근 불가** → 패키지를 열어야 한다.
- `module-info.java`에서 `opens` 또는 실행 옵션 사용.

```java
module com.example.app {
    requires com.fasterxml.jackson.databind;
    // 리플렉션 기반 라이브러리(Jackson/Hibernate)가 접근할 패키지 공개
    opens com.example.app.model to com.fasterxml.jackson.databind;
}
```

실행 시 임시로 열기:
```bash
java --add-opens com.example.app/com.example.app.model=ALL-UNNAMED ...
```

> 애너테이션 **자체**는 모듈 경계를 바꾸지 않지만, **애너테이션을 읽기 위한 리플렉션**이 필요하면 `opens` 설계가 요구된다.

---

## 고급 설계 — enum/클래스 요소, 중첩/배열, 기본값 상수화

```java
enum Level { INFO, WARN, ERROR }

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface Log {
    Level level() default Level.INFO;
    Class<? extends RuntimeException> onException() default RuntimeException.class;
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface Owner { String name(); }

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface Service {
    Owner owner();               // 중첩 애너테이션
    String[] tags() default {};  // 배열 요소
}

@interface A {
    int CONST = 10;              // 컴파일 상수
    int x() default CONST;       // OK
    // int y() default foo();    // 불가(상수 아님)
}
```

---

## 패키지/모듈/레코드에 부착하는 실전 예

### `package-info.java`

```java
@PublicApi
package com.example.api;

import com.example.PublicApi;
```

### `module-info.java`에 부착

```java
@StableApi
module com.example.lib {
    exports com.example.lib.api;
}
```

### 레코드 컴포넌트

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.RECORD_COMPONENT)
@interface Col { String name(); }

record Person(@Col(name="full_name") String name, int age) {}
```

---

## 프레임워크 연계 아이디어

- **Spring**: `@Component` 계열 스캐닝, `@Transactional` 경계, `@Qualifier` 주입 선택
- **JUnit 5**: `@Test`, `@BeforeEach/@AfterEach`, `@Tag` 필터링
- **JPA/Jakarta**: `@Entity/@Table/@Column`, `@OneToMany` 등 ORM 매핑
- **직렬화/매핑**: 자체 `@JsonField`, `@Masking` 정의 → 컨버터/필터에서 리플렉션 처리

> 실무에선 **메타 애너테이션 조합**(예: `@Transactional @Audited @Role("Admin")`)과 **전략적 스캐닝 범위** 설정이 관건.

---

## 트러블슈팅 & 베스트 프랙티스

| 증상/문제 | 원인 | 해결 |
|---|---|---|
| 런타임에서 애너테이션이 안 보임 | 기본 Retention은 `CLASS` | `@Retention(RetentionPolicy.RUNTIME)` 지정 |
| `@Repeatable`인데 개별 요소 조회 불가 | 컨테이너 Target/Retention 불일치 | 컨테이너를 원본과 **완전히 동일** 설정 |
| 상속된 클래스에서 애너테이션 누락 | `@Inherited` 없음/멤버 애너테이션 | 클래스 타입에 `@Inherited` 사용(멤버는 상속 X) |
| JPMS에서 `InaccessibleObjectException` | 모듈 캡슐화 | `opens` 또는 `--add-opens` |
| TYPE_USE가 인식되지 않음 | 조회 API 사용 오류 | `getAnnotated*Type*` 계열 사용 |
| 리플렉션 성능 저하 | 반복 조회 | 멤버 메타데이터 **캐시**/바인딩 |

**설계 원칙**
- `@Target`은 **최소 권한**(오용 방지)
- **Retention 의도와 일치**: 런타임 처리면 `RUNTIME`, 스타일/도구용이면 `SOURCE`
- **리플렉션 최소화/캐시** + 보안 고려(외부 입력으로 클래스/메서드명 다루지 않기)
- JPMS 환경 고려한 `opens`/실행 옵션 설계

---

## 빌드/도구 스니펫

### `javac`/`java`

```bash
# 컴파일

javac -d out $(find src -name "*.java")

# 실행

java -cp out com.example.Main
```

### Maven (요지)

```xml
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
  <version>3.11.0</version>
  <configuration>
    <release>21</release>
    <annotationProcessorPaths>
      <path>
        <groupId>com.example</groupId>
        <artifactId>autobuilder-processor</artifactId>
        <version>1.0.0</version>
      </path>
    </annotationProcessorPaths>
  </configuration>
</plugin>
```

### Gradle (Kotlin DSL 요지)

```kotlin
plugins { java }
java { toolchain { languageVersion.set(JavaLanguageVersion.of(21)) } }
dependencies {
    annotationProcessor("com.example:autobuilder-processor:1.0.0")
    testImplementation("org.junit.jupiter:junit-jupiter:5.11.0")
}
tasks.test { useJUnitPlatform() }
```

---

## 요약 체크리스트

- [ ] 표준/메타 애너테이션 의미 숙지 (`@Target/@Retention/@Repeatable/...`)
- [ ] 요소 타입 제약(원시/String/Class/enum/annotation/배열) 준수, 기본값은 **컴파일 상수**
- [ ] `value()` 축약 규칙 이해
- [ ] 런타임 처리면 **`RUNTIME`**, 스타일/소스 생성은 **`SOURCE`**
- [ ] 반복 적용은 `@Repeatable` + 컨테이너(Target/Retention 동일)
- [ ] 상속 전파는 클래스 타입 + `@Inherited`
- [ ] TYPE_USE/TYPE_PARAMETER로 정밀 제약 가능
- [ ] 리플렉션은 **캐시/최소화**, JPMS는 `opens`/`--add-opens` 고려
- [ ] 필요 시 **애너테이션 프로세싱**으로 컴파일 타임 생성/검증 도입

---

## 결론

애너테이션은 **의도를 표준화**하고 **자동화된 처리(컴파일·런타임)** 를 가능케 하는 **현대 Java 설계의 핵심 축**이다.
이 글의 규칙과 패턴을 토대로 팀 표준 애너테이션을 정의하고, 상황에 맞춰 **리플렉션/프로세싱/JPMS 설계**를 조합하면 유지보수성과 성능, 보안을 고루 확보할 수 있다.
