---
layout: post
title: Java - 애너테이션
date: 2025-08-09 14:20:23 +0900
category: Java
---
# 애너테이션(Annotation) 정의 및 사용

애너테이션(Annotation)은 **메타데이터(Metadata)**의 한 형태로, 코드에 부가적인 정보를 제공하는 방법이다.  
컴파일러나 런타임에서 **특정 동작을 지시하거나 문서화를 돕고, 코드 분석 도구나 프레임워크에서 활용**된다.

---

## 1. 애너테이션의 기본 개념

- **메타데이터**: 데이터에 대한 데이터. 애너테이션은 클래스, 메서드, 변수, 매개변수, 패키지 등에 추가 정보 제공.
- **실행 로직 없음**: 애너테이션 자체는 프로그램의 동작을 직접 변경하지 않으며, 해석은 컴파일러나 런타임 로직에서 수행.
- **사용 목적**
  - 컴파일러 지시
  - 런타임 로직 제어
  - 코드 문서화

---

## 2. 애너테이션의 종류

### 2.1 표준 애너테이션 (Java에서 기본 제공)
| 애너테이션         | 설명 |
|-------------------|------|
| `@Override`       | 메서드가 상위 클래스 메서드를 재정의함을 표시. 오타나 시그니처 불일치 시 컴파일 에러 발생. |
| `@Deprecated`     | 해당 요소가 더 이상 사용되지 않음을 표시. IDE 경고 출력. |
| `@SuppressWarnings` | 컴파일 경고를 억제. 예: `@SuppressWarnings("unchecked")` |
| `@FunctionalInterface` | 하나의 추상 메서드만 가지는 인터페이스임을 명시. |

---

### 2.2 메타 애너테이션 (Annotation을 정의할 때 사용)
| 애너테이션             | 설명 |
|-----------------------|------|
| `@Target`             | 애너테이션을 적용할 수 있는 위치 지정 (예: TYPE, METHOD, FIELD 등). |
| `@Retention`          | 애너테이션의 유지 정책 지정 (SOURCE, CLASS, RUNTIME). |
| `@Documented`         | Javadoc 문서에 애너테이션 정보 포함. |
| `@Inherited`          | 하위 클래스가 상위 클래스의 애너테이션을 상속받도록 지정. |
| `@Repeatable`         | 동일한 애너테이션을 여러 번 적용 가능하도록 지정. |

---

## 3. 애너테이션 유지 정책 (`@Retention`)

- **`RetentionPolicy.SOURCE`**  
  컴파일 시 사라짐. 컴파일러 지시용.
- **`RetentionPolicy.CLASS`**  
  클래스 파일에 포함되지만 런타임에는 사용 불가 (기본값).
- **`RetentionPolicy.RUNTIME`**  
  런타임 시 리플렉션(Reflection)으로 읽을 수 있음.

---

## 4. 애너테이션 적용 위치 (`@Target`)

| 값               | 설명 |
|------------------|------|
| `ElementType.TYPE`       | 클래스, 인터페이스, enum |
| `ElementType.METHOD`     | 메서드 |
| `ElementType.FIELD`      | 멤버 변수 |
| `ElementType.PARAMETER`  | 매개변수 |
| `ElementType.CONSTRUCTOR`| 생성자 |
| `ElementType.ANNOTATION_TYPE` | 다른 애너테이션 정의 시 |
| `ElementType.PACKAGE`    | 패키지 |

---

## 5. 사용자 정의 애너테이션

### 예제: 간단한 애너테이션 정의
```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnnotation {
    String value();
    int count() default 1;
}
```

- `@Retention(RetentionPolicy.RUNTIME)`: 런타임에도 유지.
- `@Target(ElementType.METHOD)`: 메서드에만 적용 가능.
- `String value();`: 필수 요소.
- `int count() default 1;`: 기본값 지정.

---

### 애너테이션 사용 예시
```java
public class TestClass {
    @MyAnnotation(value = "Hello", count = 3)
    public void myMethod() {
        System.out.println("메서드 실행");
    }
}
```

---

## 6. 리플렉션을 통한 애너테이션 읽기
```java
import java.lang.reflect.Method;

public class AnnotationReader {
    public static void main(String[] args) throws Exception {
        Method method = TestClass.class.getMethod("myMethod");
        MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);

        if (annotation != null) {
            System.out.println("value: " + annotation.value());
            System.out.println("count: " + annotation.count());
        }
    }
}
```
**출력**
```
value: Hello
count: 3
```

---

## 7. 애너테이션의 활용 예

- **Spring Framework**: `@Autowired`, `@Controller`, `@Service` 등으로 의존성 주입과 Bean 관리.
- **JUnit**: `@Test`, `@Before`, `@After` 등으로 테스트 코드 작성.
- **Jakarta EE / JPA**: `@Entity`, `@Table`, `@Column` 등 ORM 매핑.
- **Lombok**: `@Getter`, `@Setter`, `@Builder` 등 보일러플레이트 코드 제거.

---

## 8. 주의 사항

- 남용 시 코드 가독성과 유지보수성이 떨어질 수 있음.
- 런타임 유지 애너테이션은 Reflection 호출 비용이 발생.
- 메타 애너테이션의 Retention과 Target을 적절히 설정해야 함.

---

## 9. 결론

- 애너테이션은 Java에서 **프레임워크 설계와 코드 메타데이터 관리**에 핵심적인 역할을 한다.
- 표준 애너테이션은 컴파일 안정성을 높이고, 사용자 정의 애너테이션은 코드 구조를 유연하게 만든다.
- 리플렉션과 함께 사용하면 런타임 제어가 가능하다.