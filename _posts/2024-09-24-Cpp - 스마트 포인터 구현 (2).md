---
layout: post
title: C++ - 스마트 포인터 구현 (2)
date: 2024-09-24 19:20:23 +0900
category: Cpp
---
# C++ shared_ptr 직접 구현하기: 공유 소유권과 참조 카운팅의 이해

이전 편에서 단독 소유권을 다루는 `unique_ptr`을 구현했다면, 이번에는 여러 소유자가 하나의 객체를 공유할 수 있는 `shared_ptr`을 직접 구현해보겠습니다. 공유 소유권 모델은 현대 C++에서 복잡한 객체 수명 관리 문제를 우아하게 해결하는 핵심 도구입니다.

## 공유 소유권의 핵심 개념

`shared_ptr`의 기본 아이디어는 직관적이지만 강력합니다: 여러 스마트 포인터가 동일한 객체를 참조할 수 있으며, 객체는 마지막 참조가 사라질 때만 파괴됩니다. 이는 참조 카운팅(reference counting)이라는 메커니즘으로 구현됩니다.

핵심 요구사항은 다음과 같습니다:
- **공유 소유권**: 여러 포인터가 하나의 객체 수명을 공유
- **참조 카운팅**: 객체 참조 수를 추적하는 메커니즘
- **컨트롤 블록**: 카운트와 삭제 정책을 관리하는 중앙 저장소
- **성능 최적화**: `make_shared`를 통한 단일 할당
- **유연성**: 커스텀 삭제자와 aliasing 생성자 지원

## 컨트롤 블록: 참조 카운팅의 핵심 인프라

참조 카운팅의 마법은 모두 **컨트롤 블록**이라는 데이터 구조에서 일어납니다. 이 블록은 객체 자체와는 별도로 존재하며, 다음과 같은 정보를 관리합니다:

```cpp
struct ControlBlockBase {
    std::atomic<long> shared_count{1};  // 공유 참조 카운트
    std::atomic<long> weak_count{0};    // 약한 참조 카운트(3편에서 설명)
    
    virtual void destroy_object() noexcept = 0;  // 객체 파괴
    virtual void delete_this() noexcept = 0;     // 컨트롤 블록 자체 파괴
    virtual ~ControlBlockBase() = default;
};
```

컨트롤 블록은 두 가지 주요 변형을 가집니다:

1. **포인터 저장형**: 외부에서 할당된 객체를 관리
2. **인플레이스형**: 객체를 컨트롤 블록 내부에 직접 저장

```cpp
// 외부 포인터를 관리하는 컨트롤 블록
template <class T, class Deleter>
struct ControlBlockPtr : ControlBlockBase {
    T* ptr;
    Deleter del;
    
    void destroy_object() noexcept override {
        if (ptr) { del(ptr); ptr = nullptr; }
    }
};

// 객체를 내부에 저장하는 컨트롤 블록 (make_shared 최적화용)
template <class T>
struct ControlBlockInplace : ControlBlockBase {
    typename std::aligned_storage<sizeof(T), alignof(T)>::type storage;
    
    template <class... Args>
    ControlBlockInplace(Args&&... args) {
        ::new (&storage) T(std::forward<Args>(args)...);
    }
    
    void destroy_object() noexcept override {
        reinterpret_cast<T*>(&storage)->~T();
    }
};
```

## MySharedPtr의 기본 구조

`MySharedPtr`은 두 개의 주요 구성 요소를 관리합니다:

```cpp
template <class T>
class MySharedPtr {
private:
    T* ptr_ = nullptr;                 // 실제 관찰 포인터
    ControlBlockBase* ctrl_ = nullptr; // 참조 카운팅 인프라
    
public:
    // 기본 생성자
    explicit MySharedPtr(T* p) {
        if (p) {
            ctrl_ = new ControlBlockPtr<T, std::default_delete<T>>(
                p, std::default_delete<T>{});
            ptr_ = p;
        }
    }
    
    // 참조 카운트 관리
    void inc_shared() noexcept {
        if (ctrl_) ctrl_->shared_count.fetch_add(1);
    }
    
    void release_shared() noexcept {
        if (!ctrl_) return;
        
        // 참조 카운트 감소
        if (ctrl_->shared_count.fetch_sub(1) == 1) {
            // 마지막 공유 참조: 객체 파괴
            ctrl_->destroy_object();
            
            // 약한 참조도 없다면 컨트롤 블록 파괴
            if (ctrl_->weak_count.load() == 0) {
                ctrl_->delete_this();
            }
        }
        
        ptr_ = nullptr;
        ctrl_ = nullptr;
    }
};
```

참조 카운팅의 핵심은 `release_shared()` 메서드에 있습니다. 이 메서드가 호출될 때마다 참조 카운트가 감소하고, 카운트가 0이 되면 객체를 안전하게 파괴합니다.

## make_shared 최적화: 단일 할당의 힘

표준 `make_shared`의 가장 큰 장점 중 하나는 객체와 컨트롤 블록을 단일 메모리 할당으로 결합하는 것입니다. 이는 두 가지 중요한 이점을 제공합니다:

1. **성능 향상**: 두 번의 할당 대신 한 번의 할당
2. **캐시 지역성**: 객체와 컨트롤 블록이 물리적으로 인접

```cpp
template <class T, class... Args>
MySharedPtr<T> my_make_shared(Args&&... args) {
    // 단일 할당으로 컨트롤 블록과 객체 생성
    auto* ctrl = new ControlBlockInplace<T>(std::forward<Args>(args)...);
    
    // 내부 생성자를 통해 MySharedPtr 생성
    return MySharedPtr<T>(ctrl, 
        static_cast<T*>(ctrl->get_object_ptr()));
}
```

## Aliasing 생성자: 하나의 수명, 여러 관점

때로는 객체의 일부분만을 참조하면서도 전체 객체의 수명을 공유하고 싶을 때가 있습니다. Aliasing 생성자는 이런 요구를 우아하게 해결합니다:

```cpp
template <class U>
MySharedPtr(const MySharedPtr<U>& owner, T* alias_ptr) noexcept
    : ptr_(alias_ptr), ctrl_(owner.ctrl_) {
    inc_shared();
}
```

이 생성자를 사용하면 다음과 같은 패턴이 가능해집니다:

```cpp
struct Image {
    int width, height;
    unsigned char* pixels;
};

auto image = my_make_shared<Image>(800, 600);
// 픽셀 데이터만 별도로 참조하지만, Image 객체와 수명을 공유
auto pixels = MySharedPtr<unsigned char>(image, image->pixels);
```

여기서 `pixels`는 `Image` 객체의 수명에 묶여 있으므로, `image`가 파괴되지 않는 한 안전하게 사용할 수 있습니다.

## 커스텀 삭제자와 C 리소스 관리

`shared_ptr`의 또 다른 강력한 기능은 다양한 자원 유형을 일관된 인터페이스로 관리할 수 있다는 것입니다:

```cpp
// 파일 핸들 관리
struct FileCloser {
    void operator()(FILE* f) const noexcept {
        if (f) std::fclose(f);
    }
};

auto file = MySharedPtr<FILE>(
    std::fopen("data.bin", "rb"), 
    FileCloser{}
);

// 사용 후 자동으로 fclose 호출
```

이 패턴은 파일, 소켓, 데이터베이스 연결, GUI 리소스 등 모든 종류의 자원에 적용할 수 있습니다.

## 스레드 안전성 고려사항

멀티스레드 환경에서 참조 카운팅은 특별한 주의가 필요합니다. 우리 구현에서는 `std::atomic`을 사용하여 기본적인 스레드 안전성을 보장합니다:

```cpp
// 원자적 카운트 증가
void inc_shared() noexcept {
    if (ctrl_) ctrl_->shared_count.fetch_add(1, std::memory_order_relaxed);
}

// 원자적 카운트 감소 및 객체 파괴
void release_shared() noexcept {
    if (!ctrl_) return;
    
    // 메모리 장벽으로 이전 쓰기가 모두 가시화되도록 보장
    if (ctrl_->shared_count.fetch_sub(1, std::memory_order_acq_rel) == 1) {
        ctrl_->destroy_object();
        // ...
    }
}
```

메모리 순서(`memory_order`) 설정은 성능과 정확성 사이의 균형을 조정합니다. 우리는 보수적인 접근으로 `acq_rel`을 사용하여 안전성을 우선시했습니다.

## 결론

`shared_ptr` 구현을 통해 참조 카운팅의 기본 원리와 공유 소유권 모델의 장단점을 깊이 이해할 수 있었습니다. 컨트롤 블록이라는 추상화를 통해 객체 수명 관리와 삭제 정책을 분리하고, 타입 소거(type erasure) 기법을 통해 유연성을 확보한 점이 특히 인상적입니다.

`make_shared`의 단일 할당 최적화, aliasing 생성자를 통한 부분 객체 참조, 커스텀 삭제자를 통한 다양한 자원 관리 등은 `shared_ptr`을 단순한 스마트 포인터를 넘어 강력한 자원 관리 도구로 만듭니다.

그러나 참조 카운팅은 만능 해결책이 아닙니다. 순환 참조 문제(다음 편에서 `weak_ptr`로 해결), 원자적 연산의 오버헤드, 컨트롤 블록의 추가 메모리 사용 등 고려해야 할 트레이드오프가 존재합니다. 이러한 이해를 바탕으로 상황에 맞는 적절한 스마트 포인터를 선택할 수 있는 판단력을 기를 수 있습니다.

다음 편에서는 `weak_ptr`과 `enable_shared_from_this`를 구현하며, 순환 참조 문제 해결과 자기 참조 안전성 패턴을 탐구해보겠습니다.