---
layout: post
title: C++ - 스마트 포인터 구현 (2)
date: 2024-09-24 19:20:23 +0900
category: Cpp
---
# C++ 스마트 포인터 구현 2/6 — `MySharedPtr`(공유 소유) 설계와 구현

> 목표: 표준 `shared_ptr`의 핵심 동작(참조 카운팅, 컨트롤 블록, 커스텀 deleter, `make_shared` 1회 할당, aliasing 생성자)을 **직접 구현**한다.  
> 1편의 `MyUniquePtr`(단독 소유) 위에, 이번 편에서는 **공유 소유(Reference Counting)** 를 안전하게 다루는 인프라를 완성한다.  
> ※ `MyWeakPtr`(약참조)와 `enable_shared_from_this` 호환은 **3편**에서 상세 확장한다.

---

## 0) 요구사항 정리

- **공유 소유(Shared Ownership)**  
  여러 스마트 포인터가 **하나의 객체 수명**을 공유한다.
- **컨트롤 블록(Control Block)**  
  공유/약참조 카운트, 삭제 정책(Deleter), 필요 시 인-플레이스(in-place) 객체 저장을 관리한다.
- **예외 안전성 & 성능**  
  - `make_shared` 형태로 **1회 할당**(객체+컨트롤블록) → 캐시 친화 & 예외 안전  
  - 외부 포인터 채택 시(예: `new T`)에도 안전히 관리
- **커스텀 Deleter**  
  C 핸들(파일/소켓/메모리 등)도 RAII로 정리 가능.
- **Aliasing 생성자**  
  동일 컨트롤 블록을 공유하면서 **다른 지점**(subobject)을 가리키는 포인터 생성.
- **불완전형(incomplete type) 허용**  
  소멸 시점까지 **타입이 완전해지면** 된다(3편에서 약참조 도입 시 더 중요해짐).

---

## 1) 컨트롤 블록 설계(핵심 인터페이스)

### 1.1 카운트 불변식

공유 소유는 다음 불변식을 만족한다.

$$
\text{shared\_count} \ge 0,\quad \text{weak\_count} \ge 0
$$

- 객체 파괴 시점: $$\text{shared\_count} = 0$$ 이 되는 **순간** 객체 파괴(destroy)
- 컨트롤 블록 파괴 시점: 객체가 이미 파괴된 상태에서 $$\text{weak\_count} = 0$$ 이 되면 블록 자체도 파괴(delete)

> 2편에서는 `MyWeakPtr`를 아직 노출하지 않지만, 컨트롤 블록은 **미래 확장**(3편)을 위해 `weak_count`를 준비한다.

### 1.2 타입 소거 기반의 컨트롤 블록

- 공통 인터페이스: 파괴(destroy), 블록 삭제(delete_this), 카운트 접근
- 파생형:
  1) **포인터 소유형**: 외부에서 넘긴 `T*` 와 `Deleter` 를 저장  
  2) **인플레이스형**(`make_shared`): 블록 내부에 `T`를 **직접 배치**하고 생성자 인자를 전달

```cpp
// Control block 공통 인터페이스
struct ControlBlockBase {
    std::atomic<long> shared_count{1}; // 최초 shared_ptr 1개
    std::atomic<long> weak_count{0};   // 3편에서 본격 사용
    virtual void destroy_object() noexcept = 0;   // T 파괴
    virtual void delete_this() noexcept = 0;      // 컨트롤 블록 해제
    virtual void* get_object_ptr() noexcept = 0;  // (선택) T* 접근
    virtual ~ControlBlockBase() = default;
};

// 1) 외부 포인터 + Deleter 저장형
template <class T, class Deleter>
struct ControlBlockPtr final : ControlBlockBase {
    T* ptr;
    Deleter del;
    ControlBlockPtr(T* p, Deleter d) : ptr(p), del(std::move(d)) {}
    void destroy_object() noexcept override {
        if (ptr) { del(ptr); ptr = nullptr; }
    }
    void delete_this() noexcept override { delete this; }
    void* get_object_ptr() noexcept override { return ptr; }
};

// 2) 인플레이스 저장형(make_shared)
template <class T>
struct ControlBlockInplace final : ControlBlockBase {
    // T 정확한 정렬/수명 관리를 위해 aligned_storage 사용
    typename std::aligned_storage<sizeof(T), alignof(T)>::type storage;

    template <class... Args>
    explicit ControlBlockInplace(Args&&... args) {
        ::new (&storage) T(std::forward<Args>(args)...);
    }

    T* get() noexcept { return reinterpret_cast<T*>(&storage); }

    void destroy_object() noexcept override {
        get()->~T();
    }
    void delete_this() noexcept override { delete this; }
    void* get_object_ptr() noexcept override { return get(); }
};
```

---

## 2) `MySharedPtr` 최소 설계

- **보유 포인터 `ptr_`**: 사용자가 간접 접근하는 “표면 포인터”  
  (Aliasing 생성자에서 **원 객체와 다른 지점**을 가리킬 수도 있으므로 별도로 둔다)
- **컨트롤 블록 `ctrl_`**: 참조 카운트/파괴 정책/인-플레이스 여부

```cpp
#include <atomic>
#include <utility>
#include <type_traits>
#include <cstddef>

template <class T> class MySharedPtr; // 전방 선언(3편에서 MyWeakPtr 예정)

template <class T>
class MySharedPtr {
public:
    using element_type = T;

private:
    T* ptr_ = nullptr;                 // 관찰 포인터(aliased 가능)
    ControlBlockBase* ctrl_ = nullptr; // 수명/정책 관리

    template <class U> friend class MySharedPtr; // 변환 복사 지원
    // 3편에서 MyWeakPtr 도 friend 로 추가

public:
    // 2.1 생성자군
    constexpr MySharedPtr() noexcept = default;

    // T* + 기본 delete
    explicit MySharedPtr(T* p)
        : ptr_(p), ctrl_(nullptr) {
        if (p) ctrl_ = new ControlBlockPtr<T, std::default_delete<T>>(p, std::default_delete<T>{});
    }

    // T* + 커스텀 Deleter
    template <class D,
              class = std::enable_if_t<!std::is_reference<D>::value>>
    MySharedPtr(T* p, D d)
        : ptr_(p), ctrl_(nullptr) {
        if (p) ctrl_ = new ControlBlockPtr<T, D>(p, std::move(d));
    }

    // Aliasing 생성자: 같은 ctrl_ 공유, 다른 ptr_ 관찰
    template <class U>
    MySharedPtr(const MySharedPtr<U>& owner, T* alias_ptr) noexcept
        : ptr_(alias_ptr), ctrl_(owner.ctrl_) {
        inc_shared();
    }

    // 2.2 복사/이동
    MySharedPtr(const MySharedPtr& other) noexcept
        : ptr_(other.ptr_), ctrl_(other.ctrl_) { inc_shared(); }

    template <class U,
              class = std::enable_if_t<std::is_convertible<U*,T*>::value>>
    MySharedPtr(const MySharedPtr<U>& other) noexcept
        : ptr_(other.ptr_), ctrl_(other.ctrl_) { inc_shared(); }

    MySharedPtr(MySharedPtr&& other) noexcept
        : ptr_(other.ptr_), ctrl_(other.ctrl_) {
        other.ptr_ = nullptr; other.ctrl_ = nullptr;
    }

    template <class U,
              class = std::enable_if_t<std::is_convertible<U*,T*>::value>>
    MySharedPtr(MySharedPtr<U>&& other) noexcept
        : ptr_(other.ptr_), ctrl_(other.ctrl_) {
        other.ptr_ = nullptr; other.ctrl_ = nullptr;
    }

    // 2.3 대입
    MySharedPtr& operator=(const MySharedPtr& other) noexcept {
        if (this != &other) {
            release_shared(); // 내 것을 먼저 정리
            ptr_ = other.ptr_; ctrl_ = other.ctrl_;
            inc_shared();
        }
        return *this;
    }

    MySharedPtr& operator=(MySharedPtr&& other) noexcept {
        if (this != &other) {
            release_shared();
            ptr_ = other.ptr_; ctrl_ = other.ctrl_;
            other.ptr_ = nullptr; other.ctrl_ = nullptr;
        }
        return *this;
    }

    // 2.4 소멸자
    ~MySharedPtr() { release_shared(); }

    // 2.5 관찰자
    T* get() const noexcept { return ptr_; }
    T& operator*() const noexcept { return *ptr_; }
    T* operator->() const noexcept { return ptr_; }
    explicit operator bool() const noexcept { return ptr_ != nullptr; }
    long use_count() const noexcept { return ctrl_ ? ctrl_->shared_count.load() : 0; }

    // 2.6 수정자
    void reset() noexcept { MySharedPtr().swap(*this); }
    void reset(T* p) { MySharedPtr(p).swap(*this); }

    template <class D>
    void reset(T* p, D d) { MySharedPtr(p, std::move(d)).swap(*this); }

    void swap(MySharedPtr& other) noexcept {
        using std::swap;
        swap(ptr_, other.ptr_);
        swap(ctrl_, other.ctrl_);
    }

private:
    void inc_shared() noexcept {
        if (ctrl_) ctrl_->shared_count.fetch_add(1, std::memory_order_relaxed);
    }

    void release_shared() noexcept {
        if (!ctrl_) return;
        // shared 감소
        if (ctrl_->shared_count.fetch_sub(1, std::memory_order_acq_rel) == 1) {
            // 마지막 공유자 → 객체 파괴
            ctrl_->destroy_object();
            // 약참조가 없다면 블록도 삭제
            if (ctrl_->weak_count.load(std::memory_order_acquire) == 0) {
                ctrl_->delete_this();
            }
        }
        // 보유 포인터/블록 비우기
        ptr_ = nullptr; ctrl_ = nullptr;
    }
};
```

> **핵심 포인트**
> - 컨트롤 블록은 **타입 소거**로 파괴 정책을 캡슐화  
> - `MySharedPtr`의 `ptr_`는 **aliased** 가능(원 객체의 서브오브젝트/배열 요소 등)  
> - 카운팅은 `std::atomic<long>`로 **스레드 안전** 기초를 갖춘다(상세 메모리 질서 제어는 상황별 튜닝 가능)

---

## 3) `my_make_shared<T>(args...)` — 1회 할당 최적화

```cpp
template <class T, class... Args>
MySharedPtr<T> my_make_shared(Args&&... args) {
    // 컨트롤 블록 + T를 한 번에 할당
    auto* ctrl = new ControlBlockInplace<T>(std::forward<Args>(args)...);
    MySharedPtr<T> sp;
    // 내부 필드 세팅(비공개 생성자를 쓰지 않고도 안전히 구성)
    sp.swap(*reinterpret_cast<MySharedPtr<T>*>(
        new (&sp) MySharedPtr<T>()) ); // (생략 가능한 트릭: 여기서는 단순 대입으로 충분)
    sp = MySharedPtr<T>(); // 안전성 위해 초기화 후 직접 필드 설정
    // 편의상 직접 필드 접근 대신, 전용 헬퍼를 두는 편이 더 깔끔하지만
    // 튜토리얼 용도로 간단 구현:
    sp = MySharedPtr<T>(); // 재초기화
    // 내부 접근을 위해 MySharedPtr에 private 헬퍼를 두는 것이 정석.
    // 튜토리얼 간소화: 별도 내부 생성자 추가
    struct Accessor : MySharedPtr<T> {
        using MySharedPtr<T>::ptr_;
        using MySharedPtr<T>::ctrl_;
    };
    auto& a = reinterpret_cast<Accessor&>(sp);
    a.ptr_ = static_cast<T*>(ctrl->get_object_ptr());
    a.ctrl_ = ctrl;
    return sp;
}
```

> 실무에서는 **전용 private 생성자**(예: `MySharedPtr(ControlBlockBase*, T*)`)를 선언해 `my_make_shared`가 그 생성자를 사용하도록 **friend** 로 연결한다. 위 코드는 강의용으로 표현을 단순화했다. 아래 “정돈된 버전”에서 교정해 보여준다.

### 3.1 정돈된 버전(권장)

```cpp
template <class T>
class MySharedPtr {
    // ... (앞선 구현 동일)
private:
    // 내부 전용 생성자: 컨트롤 블록 + 관찰 포인터 직접 주입
    MySharedPtr(ControlBlockBase* c, T* p) noexcept
        : ptr_(p), ctrl_(c) {}
    template <class U, class... Args>
    friend MySharedPtr<U> my_make_shared(Args&&...);
    template <class U, class D>
    friend MySharedPtr<U> make_from_ptr(U* p, D d); // 외부 포인터 채택 헬퍼(선택)

    // ... 나머지 동일
};

// 권장 버전의 make_shared
template <class T, class... Args>
MySharedPtr<T> my_make_shared(Args&&... args) {
    auto* ctrl = new ControlBlockInplace<T>(std::forward<Args>(args)...);
    return MySharedPtr<T>(ctrl, static_cast<T*>(ctrl->get_object_ptr()));
}
```

---

## 4) Aliasing 생성자 — 하나의 수명, 여러 관찰 지점

**문제**: 컨테이너/라이브러리에서 하나의 소유자에 붙어 **서브오브젝트**를 관찰하고 싶다.

```cpp
struct Image { int w, h; unsigned char* pixels; };

MySharedPtr<Image> owner = my_make_shared<Image>(/*...*/);
// pixels 버퍼는 Image 수명에 종속. pixels만 별도로 관찰하고 싶다:
auto pixels_view = MySharedPtr<unsigned char>(owner, owner->pixels);
// → owner와 수명은 묶이고, 관찰 포인터는 pixels를 가리킨다.
```

우리가 구현한 **Aliasing 생성자**는 바로 이 용도를 지원한다:

```cpp
template <class U>
MySharedPtr(const MySharedPtr<U>& owner, T* alias_ptr) noexcept
    : ptr_(alias_ptr), ctrl_(owner.ctrl_) {
    inc_shared();
}
```

- 핵심: **컨트롤 블록은 동일**, `ptr_`만 다른 지점을 가리킨다.
- 객체 파괴는 **owner의 수명**을 따라간다.

---

## 5) 커스텀 Deleter — C 리소스 RAII

파일/소켓/메모리 같은 **C API 자원**도 안전하게 관리:

```cpp
#include <cstdio>

struct FClose {
    void operator()(FILE* f) const noexcept { if (f) std::fclose(f); }
};

int main() {
    // 외부 포인터 + 커스텀 deleter
    MySharedPtr<FILE> f(std::fopen("out.txt","w"), FClose{});
    if (f) std::fputs("hello\n", f.get());
} // 마지막 소유자가 소멸 → fclose 자동 호출
```

**Deleter가 상태를 가질 수도** 있으며, 컨트롤 블록이 그 복사본을 **타입 안전하게** 보관하고 호출한다.

---

## 6) 스레드 안전성(기초)

- 본 구현은 카운팅에 `std::atomic<long>`를 사용.  
- 읽기/증가/감소 시 **완화된 순서(relaxed)** 를 사용하고, 파괴 직전 경계에서 `acq_rel` 등을 사용해 **파괴 시점 동기화**(happens-before)를 확보.
- 고성능/고난도 시나리오에서는 **더 정교한 메모리 순서**가 필요할 수 있다(락 프리 자료구조와 통합 시 등).  
  이 강좌에서는 **직관적이고 안전한 기본 설정**을 채택했다.

---

## 7) 불완전형(incomplete type) 안전

- `MySharedPtr<T>`는 컨트롤 블록이 **파괴 정책**을 캡슐화하므로, T가 헤더 시점에 **불완전형**이어도 선언·복사가 가능.  
- 실제 파괴(`destroy_object`)는 T가 **완전형**인 번역 단위에서 일어난다(인-플레이스/포인터형 모두).

---

## 8) 예제: 단일 객체, 커스텀 deleter, aliasing

```cpp
#include <cassert>
#include <cstring>
#include <vector>
#include <iostream>

// 2/6편에서 만든 인터페이스를 그대로 사용한다고 가정

struct Buffer {
    size_t n;
    unsigned char* data;
    Buffer(size_t n) : n(n), data(new unsigned char[n]) { std::memset(data, 0, n); }
    ~Buffer() { delete[] data; }
};

int main() {
    // 1) 단일 객체: make_shared 1회 할당
    auto buf = my_make_shared<Buffer>(1024);
    assert(buf.use_count() == 1);
    buf->data[0] = 0x42;

    // 2) aliasing: 같은 수명, 다른 관찰 지점
    auto view = MySharedPtr<unsigned char>(buf, buf->data); // alias
    assert(buf.use_count() == 2);
    view.get()[0] = 0x33;
    assert(buf->data[0] == 0x33);

    // 3) 외부 포인터 + 커스텀 deleter
    struct FreeFn {
        void operator()(int* p) const noexcept { std::free(p); }
    };
    int* raw = static_cast<int*>(std::malloc(sizeof(int)*4));
    raw[0] = 7;
    MySharedPtr<int> heap(raw, FreeFn{});
    assert(heap.use_count() == 1);

    // 4) 컨테이너에 담기(복사/이동 안전)
    std::vector<MySharedPtr<Buffer>> v;
    v.push_back(buf);         // 복사 → shared_count++
    v.emplace_back(std::move(buf)); // 이동 → buf 비워지고, 벡터가 소유
    std::cout << "count: " << v.front().use_count() << "\n";
}
```

출력(환경에 따라 다르지만 count는 2 이상):

```
count: 2
```

---

## 9) 품질 체크리스트(2편 달성)

- [x] **컨트롤 블록** 인터페이스 & 구현(포인터형 / 인플레이스형)  
- [x] **참조 카운팅**(shared/weak 슬롯 준비, weak은 3편에서 본격 사용)  
- [x] **스레드 안전 카운트**(atomic)  
- [x] **커스텀 deleter** 타입 안전 저장/호출  
- [x] **`my_make_shared`**: 1회 할당 최적화  
- [x] **Aliasing 생성자**: 동일 수명, 다른 관찰 지점  
- [x] **컨테이너 호환** & 예외 안전(reset/swap)

---

## 10) 부록: 깔끔한 인터페이스(선택 구현)

현업에서는 다음 보완을 권장한다.

- 전용 **private 생성자**(컨트롤 블록 + 포인터) + `friend` 로 `my_make_shared`만 허용  
- `get_deleter<D>()` 제공: `dynamic_cast` 로 `ControlBlockPtr<T,D>` 의 deleter 참조 획득(오버헤드 감안)  
- `owner_before`(순서 약속) / 비교 연산자(같은 컨트롤 블록 비교) 추가  
- 배열 저장은 `MySharedPtr<T[]>` 별도 설계(다음 편 또는 4편에서 다룸)
