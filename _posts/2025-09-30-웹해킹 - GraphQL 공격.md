---
layout: post
title: 웹해킹 - GraphQL 공격
date: 2025-09-30 22:25:23 +0900
category: 웹해킹
---
# 🧬 6. GraphQL 공격

## 0) 한눈에 보기(Executive Summary)

- **문제**  
  - **과부하(DoS형)**: 인트로스펙션, **Alias/Batching**, 깊은 중첩, 대량 리스트 조합으로 **서버·DB를 폭주**.  
  - **권한 없는 필드 접근(BOLA/IDOR)**: `user(id:"다른사람")` 같이 **객체 단위 권한 검증 부재**로 **타인 리소스 열람/수정**.  
- **근본 원인**  
  - 단일 엔드포인트 특성상 **요청당 작업량이 예측 불가**(쿼리 그래프가 임의 복잡).  
  - **리졸버 단 권한 재검증 누락**으로 **경로별 접근제어**가 깨짐.
- **핵심 방어**  
  1) **권한은 리졸버 단에서 재검증**: 소유자/역할/테넌트 Scope 체크(=BOLA 차단).  
  2) **쿼리 깊이/복잡도 제한**: AST 기반 **Depth/Complexity** 계산 → **Budget 초과 시 거절**.  
  3) **Persisted Query(APQ/Registry)**: **사전 등록된 쿼리**만 실행(문자열 임의 제출 차단).  
  4) **레이팅/쿼터**: 사용자/토큰/오퍼레이션 별 **요율 제한 + 비용(Complexity) 기반**.  
  5) **설계·운영 수칙**: 페이지 상한, N+1 방지(DataLoader), 인트로스펙션/플레이그라운드 **운영 차단** 등.

---

# 1) 공격 표면과 징후

## 1.1 인트로스펙션(스키마 열람)
- **문제**: 스키마·필드 목록 노출 → **공격 표면 매핑**. 운영에서는 **권한 있는 사용자/환경만 허용**.  
- **징후**: `__schema`, `__type` 필드 접근. 운영 로그에서 해당 필드 요청 빈도↑.

## 1.2 Alias/Batching 남용
- **문제**: 같은 필드를 alias로 수백 번 호출하거나, 인자로 ID 배열을 던지는 **대량 페치**로 **CPU/DB 폭주**.  
- **징후**: 단일 요청 처리 시간↑, 리졸버 호출 횟수↑, 동일 쿼리에서 **반복된 필드 인스턴스** 다수.

## 1.3 깊이/복잡도 폭발
- **문제**: `user -> posts -> comments -> author -> ...` 깊게 중첩 + 리스트 곱 연산 → **카르테시안 폭발**.  
- **징후**: 응답 사이즈 급증, DB 다중 조인/배치 쿼리 폭증, 타임아웃.

## 1.4 BOLA(Broken Object Level Authorization)
- **문제**: `user(id: "...")`/`order(id: "...")` 같은 **객체 fetcher**에서 **소유 검증 누락**.  
- **징후**: 타 계정 리소스에 대한 200 응답, 감사 로그에서 **교차 테넌트 접근** 패턴.

---

# 2) 방어 전략 로드맵(설계 → 코드 → 운영)

1. **스키마/리졸버 설계**  
   - 민감 객체는 **항상 소유 검증**(컨텍스트 userId·tenantId로 필터링).  
   - **viewer/me 패턴**(id 인자 제거)로 **자기 리소스**만 보게 단순화.  
   - 리스트는 **페이지네이션 + 상한**(limit 최대치).  
2. **실행 전 검증(Validation)**  
   - **Depth/Complexity** 계산 → Budget 초과 시 **즉시 400/429**.  
   - **변수·쿼리 문자열 길이**/alias 개수 제한.  
   - 운영에서는 **Persisted Query 필수**.  
3. **실행 중 제어(Resolver)**  
   - **권한 재검증**(소유자/역할/RLS) + **필드 레벨 마스킹**.  
   - **DataLoader**로 N+1 제거(성능·안정성).  
4. **API 게이트웨이/프록시**  
   - 레이트 제한(토큰/사용자/IP/오퍼레이션 별), **POST만 허용**, **JSON 크기 상한**.  
5. **관측/탐지**  
   - operationName/complexity/depth/aliasCount/실행시간/에러율 **구조 로그**.  
   - 인트로스펙션 필드 접근/과도한 페이지 사이즈/비정상 반복 호출 경보.

---

# 3) Node.js(Apollo/GraphQL Yoga) — 방어 구현 풀세트

## 3.1 스키마(예시) + @auth 지시어

```graphql
# schema.graphql
directive @auth(role: Role = USER) on FIELD_DEFINITION | OBJECT
enum Role { USER ADMIN }

type User @auth(role: USER) {
  id: ID!
  email: String!         # 본인/ADMIN만
  name: String!
  posts(limit: Int = 20, after: ID): [Post!]!
}

type Post {
  id: ID!
  title: String!
  body: String!          # 예시로 본문 길이 상한을 리졸버에서 강제
  author: User!
  comments(limit: Int = 20, after: ID): [Comment!]!
}

type Comment {
  id: ID!
  text: String!
  author: User!
}

type Query {
  me: User!                                  # ← id 인자 없음(BOLA 예방)
  user(id: ID!): User @auth(role: ADMIN)     # 관리자가 아닌 이상 노출 금지
  post(id: ID!): Post                        # 객체 fetcher → 내부에서 소유/권한 검사
  searchUsers(prefix: String!, limit: Int = 20): [User!]! @auth(role: ADMIN)
}
```

### @auth 지시어 구현(권한 Gate)
```ts
// authDirective.ts
import { defaultFieldResolver, GraphQLField } from "graphql";

export function authDirective(getUserRole: (ctx:any)=>"USER"|"ADMIN") {
  return {
    auth: (next: Function, src: any, args: any, ctx: any, info: any) => {
      const need = info.parentType.getFields?.()[info.fieldName]?.astNode?.directives
        ?.find((d:any)=>d.name.value==="auth")
        ?.arguments?.find((a:any)=>a.name.value==="role")?.value?.value || "USER";
      const have = getUserRole(ctx);
      if (need === "ADMIN" && have !== "ADMIN") { throw new Error("forbidden"); }
      return next();
    }
  };
}
```

> 실무에서는 `graphql-tools`의 스키마 변환 또는 `@graphql-authz` 같은 라이브러리 사용을 권장.

## 3.2 컨텍스트와 소유 검증(리졸버 레벨 BOLA 방지)

```ts
// context.ts
import type { Request } from "express";
export function buildContext(req: Request) {
  // ex) JWT에서 userId/role/tenantId 추출
  const user = verifyJwt(req.headers.authorization);
  return { user }; // { id, role, tenantId }
}

// resolvers.ts (핵심: 항상 owner/tenant 재검증)
export const resolvers = {
  Query: {
    me: async (_:any, __:any, ctx:any) => {
      const me = await db.user.findById(ctx.user.id);
      if (!me) throw new Error("not found");
      return me;
    },
    user: async (_:any, {id}:{id:string}, ctx:any) => {
      // ADMIN만 허용(@auth로도 막지만, 이중 체크 습관)
      if (ctx.user.role !== "ADMIN") throw new Error("forbidden");
      return db.user.findById(id);
    },
    post: async (_:any, {id}:{id:string}, ctx:any) => {
      const p = await db.post.findById(id);
      // 예: 비공개 글이면 소유자/공개 여부 확인
      if (!canReadPost(ctx.user, p)) throw new Error("forbidden");
      return p;
    },
    searchUsers: async (_:any, {prefix, limit}:{prefix:string,limit:number}, ctx:any)=>{
      if (ctx.user.role !== "ADMIN") throw new Error("forbidden");
      const l = Math.min(Math.max(1, limit), 50);        // 상한
      return db.user.findPrefix(prefix.toLowerCase(), l); // 인덱스 전제
    }
  },
  User: {
    email: (u:any, _args:any, ctx:any) => {
      // 본인이거나 ADMIN만
      if (ctx.user.id !== u.id && ctx.user.role !== "ADMIN") return null;
      return u.email;
    },
    posts: (u:any, {limit=20, after}:{limit:number,after?:string}) => {
      const l = Math.min(limit, 50);
      return db.post.listByAuthor(u.id, { limit: l, after });
    }
  }
}
```

> **핵심**: **요청 인자의 id를 그대로 믿지 말고** `ctx.user` 기반으로 필터링/검증.

## 3.3 N+1 방지(DataLoader) + Alias 남용 억제

```ts
import DataLoader from "dataloader";

export function buildLoaders() {
  const userById = new DataLoader(async (ids:string[]) => db.user.findAllByIds(ids));
  const postByAuthor = new DataLoader(async (authorIds:string[]) => {
    // authorId별 posts를 한 번에 로드하여 매핑
    const rows = await db.post.findByAuthors(authorIds);
    const map = new Map(authorIds.map(id=>[id,[] as any[]]));
    for (const r of rows) map.get(r.authorId)!.push(r);
    return authorIds.map(id => map.get(id)!);
  });
  return { userById, postByAuthor };
}
```

> Alias/Batching은 **DataLoader가 있으면 DB 커넥션 폭주를 크게 완화**.  
> **그러나** 과도한 alias는 **Complexity Budget**으로 최종 제어해야 합니다.

## 3.4 깊이/복잡도 제한(Apollo Server 예시)

```ts
// security/complexity.ts
import { createComplexityRule, simpleEstimator, fieldExtensionsEstimator } from "graphql-query-complexity";
import depthLimit from "graphql-depth-limit";

// 1) 깊이 제한 rule
export const depthRule = depthLimit(8);  // 최대 깊이 8 (업무에 맞게 조정)

// 2) 복잡도 제한 rule: 필드 cost 합계가 budget 초과 시 거절
export function complexityRule(schema:any) {
  return createComplexityRule({
    schema,
    estimators: [
      fieldExtensionsEstimator(),          // 스키마에 complexity 확장 달 수 있음
      simpleEstimator({ defaultComplexity: 1 }) // 기본 cost
    ],
    maximumComplexity: 300,                // 예: 전체 예산 300
    variables: {},
    onComplete: (complexity: number) => {
      // 로깅/알림
      console.log("Complexity:", complexity);
    }
  });
}
```

```ts
// server.ts (Apollo v4 기준 개념)
import { ApolloServer } from "@apollo/server";
import { expressMiddleware } from "@apollo/server/express4";
import { makeExecutableSchema } from "@graphql-tools/schema";
import { depthRule, complexityRule } from "./security/complexity";
import { buildContext } from "./context";
import { authDirective } from "./authDirective";

const typeDefs = readFileSync("schema.graphql","utf8");
let schema = makeExecutableSchema({ typeDefs, resolvers });
// (선택) 스키마 확장으로 필드별 복잡도(cost) 부여 가능

const server = new ApolloServer({
  schema,
  introspection: process.env.NODE_ENV !== "production", // 운영에서는 false 권장(운영 툴 제외)
  // 플레이그라운드/landingPage 비활성 고려
});

await server.start();
app.use("/graphql", express.json({ limit: "100kb" }), expressMiddleware(server, {
  context: async ({ req }) => buildContext(req),
  validationRules: [
    depthRule,
    // complexityRule은 schema 필요 → 플러그인/format에 넣거나 start 후 주입
  ]
}));
```

> `graphql-query-complexity`는 **alias 개수/리스트 곱**에 비례해 cost가 증가 → **대량 alias/깊은 중첩 자동 차단**.

## 3.5 Persisted Query(사전 등록 쿼리) 강제

- **원리**: 클라이언트는 쿼리 텍스트 대신 **SHA-256 해시**(혹은 ID)만 보냄 → 서버는 **레지스트리**에 등록된 해시만 실행.  
- **장점**: 임의 쿼리/인트로스펙션/고비용 쿼리 **제출 자체를 차단**. CDN 캐시 최적화.

```ts
// security/persisted.ts — 초간단 레지스트리 (실무는 Redis/DB)
const registry = new Map<string, string>(); // sha256 -> queryText
export function registerPersistedQuery(sha: string, query: string) {
  registry.set(sha, query);
}
export function resolvePersistedQuery(sha: string) {
  return registry.get(sha);
}
```

```ts
// 미들웨어: Persisted Query만 허용(운영)
app.use("/graphql", async (req, res, next) => {
  if (process.env.ENFORCE_PERSISTED !== "true") return next();

  // Apollo APQ 형식: { extensions: { persistedQuery: { version:1, sha256Hash } } }
  const ext = req.body?.extensions?.persistedQuery;
  const op  = req.body?.operationName;
  const sha = ext?.sha256Hash;
  if (!sha || ext?.version !== 1) return res.status(400).json({ error: "persisted required" });

  const q = resolvePersistedQuery(sha);
  if (!q) return res.status(400).json({ error: "unknown query" });

  // 서버가 실제 query 텍스트 주입
  req.body.query = q;
  // (선택) 클라이언트가 query 텍스트를 보냈다면 비교/불일치 시 거절
  return next();
});
```

> 배포 파이프라인에서 **빌드 시 쿼리 수집 → 해시 생성 → 서버 레지스트리에 등록**(또는 원격 레지스트리)하도록 자동화하세요.

## 3.6 레이트 제한(비용 기반)

```ts
// security/ratelimit.ts — 토큰 버킷(간단)
const buckets = new Map<string, {tokens:number,last:number}>();
function take(key:string, cost:number, refillPerSec=50, burst=200) {
  const now = Date.now()/1000;
  const b = buckets.get(key) ?? { tokens: burst, last: now };
  b.tokens = Math.min(burst, b.tokens + (now - b.last) * refillPerSec);
  b.last = now;
  if (b.tokens < cost) return false;
  b.tokens -= cost; buckets.set(key, b); return true;
}

// 실행 전 complexity 계산 결과를 cost로 활용
app.use("/graphql", (req,res,next)=>{
  const userKey = (req.user?.id ?? req.ip) + ":" + (req.body?.operationName ?? "anon");
  const estCost = estimateCostFast(req.body?.query) ?? 10; // 빠른 근사치(최종은 rule에서)
  if (!take(userKey, estCost)) return res.status(429).json({ error:"rate" });
  next();
});
```

> **운영 팁**: 레이트는 **사용자/토큰/오퍼레이션** 기준으로 나누고, **cost(복잡도)** 를 함께 반영하면 공정성이 좋아집니다.

## 3.7 인트로스펙션/플레이그라운드 제어

```ts
const server = new ApolloServer({
  schema,
  introspection: process.env.ALLOW_INTROSPECTION === "true", // 기본 false
  // landingPage: false (v4는 기본 비활성)
});

// 쿼리 AST에서 __schema/__type 감지하여 운영에서 거절(화이트리스트 사용자 제외)
import { visit } from "graphql";
function rejectIntrospectionInProd(query: string) {
  const ast = parse(query);
  let introspect = false;
  visit(ast, {
    Field(node) {
      if (node.name.value === "__schema" || node.name.value === "__type") introspect = true;
    }
  });
  if (introspect && process.env.NODE_ENV === "production") throw new Error("introspection disabled");
}
```

## 3.8 입력/응답 크기·쿼리 길이 제한

```ts
app.use("/graphql",
  express.json({ limit: "100kb" }), // variables 포함
  (req,res,next)=>{
    const q = req.body?.query ?? "";
    if (q.length > 50_000) return res.status(400).json({ error:"query too long" });
    next();
  }
);
```

---

# 4) Spring GraphQL(Java) — Depth/Complexity 인스트루먼트 & 권한

```java
// GraphQLConfig.java
@Bean
public GraphQlSource graphQlSource(RuntimeWiringConfigurer wiring) {
  return GraphQlSource.builder()
    .schemaResources(new ClassPathResource("schema.graphqls"))
    .configureRuntimeWiring(wiring)
    .build();
}

@Bean
public RuntimeWiringConfigurer wiringConfigurer(UserService users, Authz authz) {
  return builder -> builder
    .type("Query", typeWiring -> typeWiring
      .dataFetcher("me", env -> users.findById(authz.userId(env)))
      .dataFetcher("user", env -> {
        authz.requireAdmin(env);
        return users.findById(env.getArgument("id"));
      })
    )
    .type("User", typeWiring -> typeWiring
      .dataFetcher("email", env -> {
        var viewer = authz.user(env);
        var target = env.getSource(User.class);
        return (viewer.isAdmin() || viewer.id().equals(target.id())) ? target.email() : null;
      })
    );
}
```

### 깊이/복잡도 제한(graphql-java)
```java
@Bean
public GraphQlHttpHandler handler(GraphQlSource source) {
  // Max depth/complexity instrumentation
  var instr = new ChainedInstrumentation(List.of(
      new MaxQueryDepthInstrumentation(8),
      new MaxQueryComplexityInstrumentation(300)
  ));
  return GraphQlHttpHandler.builder(source).instrumentation(instr).build();
}
```

> Spring GraphQL 1.x/2.x 환경에 따라 설정 위치가 조금씩 다릅니다. 핵심은 **Instrumentation**으로 **실행 전 제한**.

---

# 5) 게이트웨이/프록시(공통)

- **HTTP 메서드/헤더**: **POST만 허용**, `Content-Type: application/json` 강제.  
- **본문 크기 제한**: 100KB 등.  
- **캐시 금지**: `Cache-Control: no-store`(민감).  
- **WAF 룰**: `__schema`/`__type` 빈도 탐지, **쿼리 길이/alias 수** 임계 관리.  
- **레이트 제한**: 사용자/토큰/IP/오퍼레이션별.

**Nginx 스니펫**
```nginx
location /graphql {
  limit_req zone=perip burst=20 nodelay;   # IP 기준(보조)
  client_max_body_size 100k;
  if ($request_method != POST) { return 405; }
  if ($http_content_type !~* "application/json") { return 415; }
  proxy_pass http://app:4000/graphql;
}
```

---

# 6) 안전한 재현/스모크(스테이징) — “막혀야 정상”

> **목표**: 아래 시도들이 **거절**되거나 **예산 초과/권한 부족**으로 **실패**해야 정상입니다.

1) **인트로스펙션 필드 접근** → 운영에서 **거절**  
   - 예: `__schema { types { name } }` 를 포함한 쿼리 제출 시 400/403.  
2) **깊이 초과**  
   - `user -> posts -> comments -> author -> ...` 깊이 9 요청 → **Depth limit**로 400.  
3) **복잡도 초과**  
   - 같은 필드를 alias로 200회 호출 → **Complexity 300 초과**로 거절.  
4) **BOLA**  
   - 로그인한 A가 B의 `user(id:"B")/post(id:"B의 글")` 조회 → **forbidden**.  
5) **Persisted Query 강제**  
   - 등록되지 않은 SHA 해시로 호출 → **unknown query** 400.  
6) **페이지 상한**  
   - `limit: 10000` 요청 → **상한 50**으로 강제/거절.

---

# 7) 로깅/모니터링(관측 설계)

- **구조 로그 필드**:  
  - `ts`, `user_id`, `opName`, `depth`, `complexity`, `aliasCount`, `duration_ms`, `errors`, `bytes_out`  
- **지표/알림**:  
  - Depth/Complexity **상위 10** 쿼리, **시간 초과** 비율, **인트로스펙션 감지** 빈도.  
  - **오퍼레이션별** 성공률/지연, **사용자/테넌트별** 에러율.  
- **샘플링**: 응답 길이/시간이 임계 넘을 때 쿼리 텍스트 샘플링(민감 변수는 마스킹).

---

# 8) 설계 베스트 프랙티스(요약)

- **BOLA 예방**  
  - `me/viewer` 패턴으로 **id 인자 제거**.  
  - 객체 fetcher(`node(id)`/`user(id)`)에는 **소유/권한 검증** 필수.  
  - **테넌트 스코프**는 컨텍스트에서 주입, 인자로 받지 않음.  
  - DB 레벨 **Row-Level Security(RLS)**/WHERE 절로 **2차 차단**.
- **쿼리 비용 관리**  
  - **Depth ≤ N**, **Complexity ≤ M** (업무에 맞춰 실험).  
  - 리스트는 **cursor 기반 페이지네이션 + 상한**.  
  - **서버 캐시**(per-user scope)로 반복 쿼리 비용 절감(개인화 주의).  
- **실행 제어**  
  - Persisted Query(레지스트리) 강제.  
  - 운영에서 **인트로스펙션/플레이그라운드 비활성**(내부 도구만).  
  - **POST+JSON만** 허용, 본문/쿼리 길이 제한.  
  - **DataLoader**로 N+1 제거하되 최종 제어는 **Complexity budget**.  
- **테스트/CI**  
  - E2E에 **깊이/복잡도 초과 케이스** 포함(거절 확인).  
  - 권한 테스트: 소유/역할/테넌트별 **허용/거절 매트릭스** 자동화.  
  - 빌드 시 **쿼리 수집→해시→레지스트리 등록** 파이프라인.

---

# 9) 체크리스트

- [ ] 리졸버 단 **소유/역할/테넌트 재검증**(BOLA 차단)  
- [ ] **Depth/Complexity 제한** 도입(예: 8 / 300)  
- [ ] **Persisted Query** 강제(미등록 해시 거절)  
- [ ] **POST+JSON** 강제, **본문/쿼리 길이**/변수 크기 상한  
- [ ] **페이지 상한**(limit ≤ 50 등) + cursor 기반  
- [ ] **DataLoader** 도입, 그러나 **Budget**으로 최종 제어  
- [ ] 운영에서 **인트로스펙션/플레이그라운드 차단**(내부 도구만 허용)  
- [ ] **레이팅/쿼터**(사용자·오퍼레이션·복잡도 기반)  
- [ ] **구조 로그/지표**(opName, depth, complexity, aliasCount, duration)  
- [ ] CI에 **권한 매트릭스/E2E 공격 패턴 거절** 테스트 포함

---

## 맺음말

GraphQL은 **유연함=공격 면적**이기도 합니다.  
**리졸버 단 권한 검증**과 **Depth/Complexity Budget**, **Persisted Query**를 결합하면  
과부하/탐색/무단 접근을 **구조적으로** 막을 수 있습니다.