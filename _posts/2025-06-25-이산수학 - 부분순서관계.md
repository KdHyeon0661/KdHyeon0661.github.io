---
layout: post
title: 이산수학 - 부분순서관계
date: 2025-06-25 22:20:23 +0900
category: 이산수학
---
# 부분순서관계 (Partial Order)

## 0. 직관

- **전순서**: 모든 원소가 서로 비교 가능(숫자, 사전식 문자열).  
- **부분순서**: “비교 가능한 쌍만” 정해진다(집합의 포함, 작업 선후).  
  → “**같이 못 놓는**(incomparable) 원소”가 존재할 수 있음.

---

## 1. 정의와 기호

집합 \(A\) 위의 관계 \(R\subseteq A\times A\)가 **부분순서**(poset)라 함은:

1. **반사성**  
   $$\forall a\in A,\ (a,a)\in R$$
2. **반대칭성**  
   $$\forall a,b\in A,\ (a,b)\in R \ \text{and}\ (b,a)\in R \Rightarrow a=b$$
3. **추이성**  
   $$\forall a,b,c\in A,\ (a,b)\in R \ \text{and}\ (b,c)\in R \Rightarrow (a,c)\in R$$

표기: \( (A, \le) \) 또는 \( (A, \preceq) \).  
서로 비교 불가능이면 \(a\parallel b\) 라고도 씀.

---

## 2. 대표 예시

### 2.1 멱집합의 포함 관계
\(A=\{1,2\}\), \(\mathcal P(A)=\{\varnothing,\{1\},\{2\},\{1,2\}\}\).  
\((\mathcal P(A), \subseteq)\)는 반사/반대칭/추이 모두 성립 → **poset**.

### 2.2 자연수의 나눗셈 \((\Bbb N,\mid)\)
- 반사: \(a\mid a\)  
- 반대칭: \(a\mid b\) & \(b\mid a\Rightarrow a=b\)  
- 추이: \(a\mid b, b\mid c\Rightarrow a\mid c\)

### 2.3 벡터의 우세(성분별 비교, product order)
$$
\mathbf x\preceq \mathbf y \iff \forall i,\ x_i\le y_i
$$
(파레토 지배/우세관계 — 다목적 최적화에서 빈번)

### 2.4 작업 선후관계(DAG)
간선 \(u\to v\) = “u가 v보다 먼저” → 도달 가능성으로 부분순서.

---

## 3. 하세 다이어그램(Hasse Diagram)

추이/반사 간선은 **생략**하고 “바로 위/아래”만 그린다. 위로 갈수록 “큼”.

예) \((\mathcal P(\{1,2\}),\subseteq)\)
```
    {1,2}
     /  \
   {1}  {2}
     \  /
      ∅
```
- \(\{1\}\subset \{1,2\}\)는 그림의 **직접 간선**(cover).  
- \(\varnothing \subset \{1,2\}\)는 추이적이므로 **생략**.

---

## 4. 경계·상하한·최솟값/최댓값

- \(x\)가 **극소(minimal)**: 그보다 작은 원소 없음  
- \(x\)가 **극대(maximal)**: 그보다 큰 원소 없음  
- **최솟값(least)** \( \bot \): 모든 원소 위에 위치 \( \bot \le a \)  
- **최댓값(greatest)** \( \top \): 모든 원소 아래에 위치 \( a \le \top \)

**상한/하한**
- \(U\)의 **상한** \(b\): \(\forall u\in U,\ u\le b\)  
- **최소상한**(join, \(\bigvee U\) 또는 \(x\vee y\))  
- **최대하한**(meet, \(\bigwedge U\) 또는 \(x\wedge y\))

> 모든 쌍에 대해 meet와 join이 존재하면 **격자(lattice)**.

---

## 5. 격자(Lattice): 예와 속성

- \((\mathcal P(S),\subseteq)\)는 **불 대수(Boolean lattice)**:  
  $$X\wedge Y=X\cap Y,\quad X\vee Y=X\cup Y$$
- \((\text{Div}(n),\mid)\) (n의 **약수 집합**)은 격자:  
  $$a\wedge b=\gcd(a,b),\quad a\vee b=\operatorname{lcm}(a,b)$$

**분배격자**(distributive):  
$$
x\wedge (y\vee z)=(x\wedge y)\vee(x\wedge z) \quad\text{(쌍대식도)}
$$
불 대수는 분배격자. (분배 아님의 전형적 반례: 다이아몬드 \(M_3\), 오각 \(N_5\))

---

## 6. 체인/앤티체인, 높이/너비, Dilworth

- **체인(chain)**: 모두 쌍별 비교 가능(전순서 부분집합)  
- **앤티체인(antichain)**: 서로 **비교 불가**한 집합  
- **높이(height)**: 가장 긴 체인의 길이  
- **너비(width)**: 가장 큰 앤티체인의 크기

**딜워스 정리(Dilworth)**  
유한 poset의 **너비** = poset을 덮는 **최소 체인 분해**의 개수.

응용: 리소스 스케줄링(레벨 수), 병렬화 한계, 교시 배치 등.

---

## 7. 위상 정렬(Topological Sort)

DAG에서 선후관계를 **일렬**로.  
- Kahn(진입차수 0 큐), 또는 DFS 후역순.

```python
from collections import deque, defaultdict

def topo_sort(n, edges):
    """
    정점: 0..n-1, edges: (u->v) 리스트
    반환: 위상정렬 리스트 (없으면 빈 리스트: 사이클)
    """
    g = defaultdict(list)
    indeg = [0]*n
    for u,v in edges:
        g[u].append(v); indeg[v]+=1
    q=deque([i for i in range(n) if indeg[i]==0])
    order=[]
    while q:
        u=q.popleft(); order.append(u)
        for w in g[u]:
            indeg[w]-=1
            if indeg[w]==0: q.append(w)
    return order if len(order)==n else []
```

---

## 8. 부분순서 성질 검사 / 추이폐쇄 / 하세(추이환원)

```python
def is_reflexive(A, R):
    S=set(R)
    return all((a,a) in S for a in A)

def is_antisymmetric(R):
    S=set(R)
    for a,b in S:
        if a!=b and (b,a) in S:
            return False
    return True

def is_transitive(A, R):
    S=set(R)
    by = {}
    for a,b in S:
        by.setdefault(a,set()).add(b)
    for a in by:
        for b in by[a]:
            for c in by.get(b,()):
                if (a,c) not in S:
                    return False
    return True

def is_poset(A, R):
    return is_reflexive(A,R) and is_antisymmetric(R) and is_transitive(A,R)
```

**추이폐쇄(Warshall)** — 경로가 있으면 관계 추가:
```python
def transitive_closure(A, R):
    idx={a:i for i,a in enumerate(A)}; n=len(A)
    M=[[False]*n for _ in range(n)]
    for a,b in R: M[idx[a]][idx[b]]=True
    for k in range(n):
        for i in range(n):
            if M[i][k]:
                rowk = M[k]
                Mi = M[i]
                for j in range(n):
                    Mi[j] = Mi[j] or rowk[j]
    # 대각 반사성 보정
    for i in range(n): M[i][i]=True
    rev={i:a for a,i in idx.items()}
    out=[]
    for i in range(n):
        for j in range(n):
            if M[i][j]:
                out.append((rev[i],rev[j]))
    return out
```

**하세 다이어그램(추이환원)** — 직접 간선만 남기기:
```python
def hasse_edges(A, R):
    # 전제: R는 반사/추이 포함(폐쇄) 상태라고 가정
    S=set(R)
    # 반사 간선 제거
    S={e for e in S if e[0]!=e[1]}
    # 추이 간선 제거(커버만 남김)
    cover=set(S)
    # (a,c)가 추이로 유도되면 제거
    by={}
    for a,b in S:
        by.setdefault(a,set()).add(b)
    for a,b in list(S):
        for c in by.get(b,()):
            if (a,c) in cover:
                cover.discard((a,c))
    return sorted(cover)
```

**예시 실행**
```python
A = [frozenset(), frozenset([1]), frozenset([2]), frozenset([1,2])]
R = []
for x in A:
    for y in A:
        if x.issubset(y): R.append((x,y))
print(is_poset(A,R))                # True
Tc = transitive_closure(A,R)        # 이미 폐쇄
H  = hasse_edges(A,Tc)              # 커버 간선
print(H)  # ∅->{1}, ∅->{2}, {1}->{1,2}, {2}->{1,2}
```

---

## 9. 극대/극소, 최댓값/최솟값, 상/하한 계산

```python
def minimal_elements(A, R):
    S=set(R); less_from={}
    for a,b in S:
        if a!=b:
            less_from.setdefault(b,set()).add(a)
    return [a for a in A if a not in less_from]

def maximal_elements(A, R):
    S=set(R); less_to={}
    for a,b in S:
        if a!=b:
            less_to.setdefault(a,set()).add(b)
    return [a for a in A if a not in less_to]

def is_leq(Rset, a,b):   # a <= b ?
    return (a,b) in Rset

def lub(A, R, X):  # 최소상한 (존재 안 하면 None)
    S=set(R)
    # 상한 후보: u s.t. x<=u for all x in X
    cands=[u for u in A if all((x,u) in S for x in X)]
    # 그중 최소(다른 상한 v에 대해 u<=v)
    mins=[u for u in cands if all((u==v) or ((u,v) in S) for v in cands)]
    return mins[0] if len(mins)==1 else None

def glb(A, R, X):  # 최대하한
    S=set(R)
    cands=[u for u in A if all((u,x) in S for x in X)]
    maxs=[u for u in cands if all((u==v) or ((v,u) in S) for v in cands)]
    return maxs[0] if len(maxs)==1 else None
```

---

## 10. 너비(최대 앤티체인)와 체인 분해 — Dilworth 구현 스케치

유한 poset \((V,\le)\)에 대해 bipartite \( (L=V, R=V) \)를 만들고  
엣지 \(u\in L \to v\in R\) 를 \(u<v\) 일 때 두면,  
**최대 매칭 수** = \(|V| - \text{최소 체인 분해 수}\).

아래는 간단한 **Hopcroft–Karp** 구현(일반적 최대 매칭).  
(입력은 poset의 **엄격관계** \(<\) 엣지 집합으로 사용)

```python
from collections import deque, defaultdict

def hopcroft_karp(L, R, E):
    """
    L,R: 정점 리스트 (서로 disjoint 이름공간)
    E  : dict u->list of v (u in L, v in R) edges
    반환: 매칭 dict (L->R), 크기
    """
    INF=10**9
    adj=defaultdict(list, E)
    pairU={u:None for u in L}
    pairV={v:None for v in R}
    dist ={}

    def bfs():
        dq=deque()
        for u in L:
            if pairU[u] is None:
                dist[u]=0; dq.append(u)
            else:
                dist[u]=INF
        d=INF
        while dq:
            u=dq.popleft()
            if dist[u]<d:
                for v in adj[u]:
                    pu=pairV[v]
                    if pu is None:
                        d=dist[u]+1
                    elif dist[pu]==INF:
                        dist[pu]=dist[u]+1
                        dq.append(pu)
        return d!=INF

    def dfs(u):
        for v in adj[u]:
            pu=pairV[v]
            if pu is None or (dist[pu]==dist[u]+1 and dfs(pu)):
                pairU[u]=v; pairV[v]=u
                return True
        dist[u]=10**9
        return False

    matching=0
    while bfs():
        for u in L:
            if pairU[u] is None and dfs(u):
                matching+=1
    return pairU, matching

def width_and_min_chain_cover(V, le_edges):
    """
    V: 정점 리스트
    le_edges: (u,v) with u < v (엄격관계)
    반환: (너비 추정값 via Dilworth, 최소 체인 수)
    """
    L=list(V); R=list(V)
    # bipartite edges: u in L -> v in R if u<v
    E=defaultdict(list)
    for u,v in le_edges:
        E[u].append(v)
    pairU, m = hopcroft_karp(L,R,E)
    min_chain = len(V) - m
    width_est = min_chain  # Dilworth: width = min chain cover
    return width_est, min_chain
```

> 주의: 실전에서는 poset의 엄격관계 \(<\)만을 엣지로 쓰는 게 핵심(동일 원소 스킵).  
> 대규모에서는 라이브러리/최적화 권장.

---

## 11. 선형 확장(Linear Extension) 개수 세기 (소형용 DP)

Poset을 전순서로 나열하는 **가능한 위상정렬 수**.  
작을 때(정점 ≤ 20) 비트마스크 DP:

```python
def count_linear_extensions(n, edges):
    """
    정점 0..n-1, edges: (u->v) (u<v) 꼭지점
    반환: 가능한 위상정렬 수
    """
    from functools import lru_cache
    preds=[0]*n
    for u,v in edges:
        preds[v] |= (1<<u)

    @lru_cache(maxsize=None)
    def dp(mask):
        if mask==(1<<n)-1: return 1
        ways=0
        # 아직 선택 안 된 정점 후보 중, 모든 선행자가 mask에 있는 것
        for v in range(n):
            if not (mask>>v)&1:
                if preds[v] & ~mask == 0:
                    ways += dp(mask | (1<<v))
        return ways

    return dp(0)
```

---

## 12. 사례연구

### 12.1 약수 격자(60)

\(A=\text{Div}(60)=\{1,2,3,4,5,6,10,12,15,20,30,60\}\), \(\mid\) 로 정렬.

- \(\bot=1\), \(\top=60\)  
- \(a\wedge b=\gcd(a,b)\), \(a\vee b=\operatorname{lcm}(a,b)\)  
- 하세 간선은 “곱하면 바로 위/아래”인 쌍(추이 생략)

**질의 예**  
- \(4\)와 \(5\)의 **최소상한**: \(\operatorname{lcm}(4,5)=20\)  
- \(12\)와 \(20\)의 **최대하한**: \(\gcd(12,20)=4\)

### 12.2 강의 선수과목 → 학기 배치
- poset: 과목 = 정점, 선수관계 = 간선  
- **높이** = 최소 학기 수(레벨 배치)  
- **너비** = 한 학기 최대 병렬 수업 수의 하한

### 12.3 빌드 그래프
- 소스/타깃 간 선후(DAG) → 위상정렬이 빌드 순서  
- 변경 전파, 캐시 무효화도 poset 관점으로 깔끔히 모델링.

---

## 13. 전순서와의 비교 요약

| 항목 | 전순서 | 부분순서 |
|---|---|---|
| 비교 가능성 | 모든 쌍 | 일부 쌍만 |
| 예 | 실수의 \(\le\), 사전식 | \(\subseteq\), \(\mid\), 선후관계 |
| 시각화 | 선형 배치 | 하세 다이어그램 |
| 정렬 | 항상 1가지(중복 시 다양한 동치) | **선형 확장** 여러 개 |

---

## 14. 자주 하는 실수·주의

- **반대칭 vs 비대칭** 혼동 금지:  
  - 반대칭: \(a\le b\) and \(b\le a \Rightarrow a=b\)  
  - 비대칭: \(a<b\Rightarrow \neg(b<a)\) (반사성 없음)
- 하세 간선은 **커버**만: 추이 간선 넣으면 안 됨.
- 격자 여부: 모든 쌍에 meet/join이 **항상** 존재하는지 확인.

---

## 15. 미니 실습 세트

### 15.1 멱집합 poset 실습
```python
S = [frozenset(), frozenset([1]), frozenset([2]), frozenset([1,2])]
R = [(x,y) for x in S for y in S if x.issubset(y)]
print("poset?", is_poset(S,R))
Tc = transitive_closure(S,R)
H  = hasse_edges(S,Tc)
print("Hasse:", H)
print("minimals:", minimal_elements(S,R))
print("maximals:", maximal_elements(S,R))
```

### 15.2 DAG 위상정렬 & 선형확장 수
```python
# A->B->D, A->C, C->D
n=4; edges=[(0,1),(1,3),(0,2),(2,3)]
print("topo:", topo_sort(n,edges))
print("linear extensions:", count_linear_extensions(n, edges))  # 2 (A,B,C,D) or (A,C,B,D)
```

### 15.3 너비와 체인분해(간단)
```python
V=[0,1,2,3]
# 0<2, 1<3 (서로 독립 체인 2개)
le=[(0,2),(1,3)]
w, c = width_and_min_chain_cover(V, le)
print("width≈", w, "min chain cover=", c)  # 2, 2
```

---

## 16. 체크리스트

- [ ] 반사/반대칭/추이 모두 확인  
- [ ] 하세: 반사/추이 간선 제거(커버만 남기기)  
- [ ] 극대/극소 vs 최댓값/최솟값 구분  
- [ ] 상/하한·meet/join 존재성 점검(격자 여부)  
- [ ] DAG라면 위상정렬/선형확장 카운트  
- [ ] 너비·체인분해가 필요한지(Dilworth)

---

## 17. 한 화면 요약

| 키워드 | 한 줄 요약 |
|---|---|
| 부분순서 | 반사·반대칭·추이 |
| Hasse | 커버 간선만 |
| 극대/극소 | 경계 원소들(유일필요X) |
| 최댓/최솟 | 전체의 탑/봇 (있을 수도 없을 수도) |
| 상/하한 | 집합의 공통 상·하한 (최소/최대가 join/meet) |
| 격자 | 모든 쌍에 meet/join 존재 |
| 너비/높이 | 최대 앤티체인/최장 체인 |
| Dilworth | 너비 = 최소 체인 커버 수 |
| 위상정렬 | DAG 선형화(빌드/커리큘럼) |
