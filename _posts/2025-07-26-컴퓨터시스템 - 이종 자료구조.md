---
layout: post
title: 컴퓨터시스템 - 이종 자료구조
date: 2025-07-26 16:20:23 +0900
category: 컴퓨터시스템
---
# 이종 자료구조 (Heterogeneous Data Structures)

## 1. 개요

이종 자료구조는 서로 다른 타입의 데이터를 하나로 묶는 구조다. C에서는 **struct**로 모델링하며, 필요한 경우 **union**(공용체)·**bit-field**(비트필드)·**flexible array member**(가변 배열 멤버)로 표현력을 확장한다. 이 글은 다음을 다룬다.

- 구조체 메모리 레이아웃(정렬·패딩·끝 패딩)
- `sizeof`, `_Alignof`/`alignof`, `alignas`로 정렬 제어
- 구조체 배열(AoS) vs 배열의 구조체(SoA)의 캐시·벡터화 관점
- 비트필드의 이식성 제약과 대안(수동 비트 연산)
- 공용체의 타입 퍼닝, 태그드 유니언(variant) 패턴
- 직렬화/역직렬화, 엔디안, 패킹 pragma의 위험과 대안
- 가변 배열 멤버로 안전한 가변 길이 레코드 설계
- `offsetof`, `container_of`, strict aliasing, `volatile`/MMIO 등

---

## 2. 플랫폼(ABI) 전제와 기본 도구

플랫폼별 정렬·크기는 ABI에 종속된다. 대표적으로:

| 모델 | `sizeof(int)` | `sizeof(long)` | `sizeof(void*)` | 예 |
|------|---------------:|---------------:|----------------:|----|
| LP64 | 4 | 8 | 8 | 리눅스 x86-64, macOS |
| LLP64 | 4 | 4 | 8 | Windows x64 |

C11 이후 도구:

- `_Alignof(T)` / `alignof(T)` : 타입 T의 요구 정렬
- `alignas(N)` : 객체 정렬 강제
- `_Static_assert(cond, msg)` : 컴파일 타임 검증
- `offsetof(T, field)` : 필드 오프셋

---

## 3. 구조체 레이아웃: 정렬과 패딩의 공식

각 멤버는 자신의 **정렬 요구치**(alignment)인 $$A_i = \_Alignof(T_i)$$ 의 배수 주소에서 시작해야 한다. 이전 멤버까지의 끝 주소를 $$E_{i-1}$$라 하면, 멤버 \(i\)의 시작 오프셋은:

$$
\text{offset}(f_i) \;=\; \left\lceil \frac{E_{i-1}}{A_i} \right\rceil \cdot A_i
\quad\text{where}\quad
E_{i-1} = \text{offset}(f_{i-1}) + \text{sizeof}(T_{i-1})
$$

구조체 전체 크기 또한 **가장 큰 정렬 요구치** \(A_{\max}\)의 배수로 반올림된다(끝 패딩 포함):

$$
\text{sizeof(struct)} \;=\; \left\lceil \frac{E_n}{A_{\max}} \right\rceil \cdot A_{\max}
$$

---

## 4. 정렬·패딩 예제와 시각화

### 4.1 간단 예제

```c
struct Example {
    char a;   // 1
    int  b;   // 4
    char c;   // 1
};
```

가정: LP64, `alignof(int)=4`.

| Offset | 바이트 범위 | 필드/패딩 | 설명 |
|-------:|-------------|-----------|------|
| 0      | 0           | a         | 1바이트 |
| 1–3    | 1–3         | padding   | b를 4바이트 정렬(오프셋 4)로 맞춤 |
| 4–7    | 4–7         | b         | 4바이트 |
| 8      | 8           | c         | 1바이트 |
| 9–11   | 9–11        | padding   | 구조체 정렬(4) 배수인 12로 반올림 |

`sizeof(struct Example) == 12`

### 4.2 오프셋 출력 유틸

```c
#include <stddef.h>
#include <stdio.h>

#define SHOW(T, F) printf("%-20s : offset=%2zu, sizeof=%2zu, alignof=%2zu\n", \
                          #F, offsetof(T, F), sizeof(((T*)0)->F), _Alignof(((T*)0)->F))

struct Data { char a; double b; int c; };

int main(void){
    printf("sizeof(Data)=%zu, alignof(Data)=%zu\n", sizeof(struct Data), _Alignof(struct Data));
    SHOW(struct Data, a);
    SHOW(struct Data, b);
    SHOW(struct Data, c);
}
```

예상(리눅스 x86-64): `sizeof=24`, `a:0`, `b:8`, `c:16`.

---

## 5. 정렬 최적화와 정렬 제어

### 5.1 멤버 순서 최적화

```c
struct Bad  { char a; double b; int c; };   // 24B
struct Good { double b; int c; char a; };   // 16B (패딩 감소)
```

### 5.2 강제 정렬

```c
#include <stdalign.h>

struct alignas(16) Vec3f {
    float x, y, z;
    float pad; // 16B 맞춤(패딩 필드로 의도적 채움)
};
_Static_assert(alignof(struct Vec3f) == 16, "align");
```

### 5.3 패킹(주의)

- GCC/Clang: `__attribute__((packed))`
- MSVC: `#pragma pack(push, 1)` / `#pragma pack(pop)`

```c
#pragma pack(push, 1)
struct Packed {
    char a; int b; char c; // 6B, 패딩 없음
};
#pragma pack(pop)
```

**주의**: 미정렬 접근은 일부 CPU에서 느리거나 트랩 발생. 구조체 직렬화 용도라면 **memcpy 기반 수동 인코딩**을 권장.

---

## 6. 구조체 배열과 접근, AoS vs SoA

### 6.1 배열 오프셋

```c
struct Person { char name[10]; int age; };
struct Person people[3];
/* &people[i] == (char*)people + i * sizeof(struct Person) */
```

### 6.2 AoS vs SoA

- **AoS (Array of Structs)**: `struct { float x,y,z; } pts[N];`
  인접한 필드 간 접근시 캐시 효율이 좋음(한 점의 x,y,z 연속).
- **SoA (Struct of Arrays)**: `struct { float *x, *y, *z; };`
  동일 필드만 연속 저장 → 벡터화/스트리밍에 유리.

#### 예: 한 축만 합산

```c
// AoS
float sum_x_aos(const struct { float x,y,z; } *p, size_t n){
    float s=0; for(size_t i=0;i<n;i++) s += p[i].x; return s;
}
// SoA
float sum_x_soa(const float *x, size_t n){
    float s=0; for(size_t i=0;i<n;i++) s += x[i]; return s;
}
```

SoA는 `x`가 연속 → 프리페치/벡터화(자동/수동) 유리.

---

## 7. 포인터와 멤버 접근

```c
struct Person p = {"Alice", 30};
struct Person *ptr = &p;
printf("%s %d\n", ptr->name, (*ptr).age);
```

- `->`는 `(*ptr).field`의 축약.
- 포인터 산술은 **포인터 타입 크기 단위**로 동작. 구조체의 포인터 산술은 UB(정의되지 않음). 바이트 단위 계산은 `char*`로 캐스팅 후 수행.

---

## 8. 비트필드: 이식성·의미론

```c
struct Flags {
    unsigned a : 1;
    unsigned b : 2;
    unsigned c : 5;
};
```

제약:

- 저장 단위 내 **비트 배치 순서**(LSB/MSB)는 구현 정의.
- endianness+컴파일러+ABI에 따라 **배치가 달라질 수 있음**.
- 정해진 포맷과 직렬화/네트워크/파일 **인터페이스에는 부적합**.

### 권장 대안: 수동 비트 연산

```c
#include <stdint.h>

static inline uint8_t pack_flags(unsigned a, unsigned b, unsigned c){
    // a:1, b:2, c:5, 모두 범위 체크 필요
    return (uint8_t)((a & 0x1) | ((b & 0x3) << 1) | ((c & 0x1F) << 3));
}
static inline void unpack_flags(uint8_t v, unsigned *a, unsigned *b, unsigned *c){
    *a = v & 0x1;
    *b = (v >> 1) & 0x3;
    *c = (v >> 3) & 0x1F;
}
```

---

## 9. 공용체(union)와 태그드 유니언 패턴

### 9.1 공용체 기본

```c
union Data {
    int   i;
    float f;
    char  str[20];
}; // sizeof는 가장 큰 멤버 크기(여기선 20)
```

- 모든 멤버가 **같은 메모리**를 공유.
- **마지막으로 저장한 멤버**만 유효하게 읽을 것(엄밀).

### 9.2 태그드 유니언(variant)

```c
#include <stdio.h>

enum Kind { K_INT, K_FLOAT, K_STR };

struct Value {
    enum Kind tag;
    union {
        int   i;
        float f;
        struct { const char *p; size_t len; } s;
    } u;
};

void print_value(const struct Value *v){
    switch(v->tag){
    case K_INT:  printf("INT=%d\n", v->u.i); break;
    case K_FLOAT:printf("FLOAT=%f\n", v->u.f); break;
    case K_STR:  printf("STR=%.*s\n", (int)v->u.s.len, v->u.s.p); break;
    default:     printf("UNKNOWN\n");
    }
}
```

- 외부에 의미를 노출할 때는 **태그 필드**로 현재 멤버를 명시.

### 9.3 타입 퍼닝과 strict aliasing

- C에서는 **공용체를 통한 타입 퍼닝**에 관해 구현 정의 요소가 있으며, C99 이후 대부분 구현에서 관용적으로 허용되지만, **이식성과 최적화 안전성**을 위해 **`memcpy`를 통한 퍼닝**을 권장.

```c
float i2f(int x){ float y; memcpy(&y, &x, sizeof y); return y; }
```

---

## 10. 문자열·포인터 멤버, 동적 메모리

```c
struct Student {
    char *name; // 포인터(64비트 시스템에서 8바이트)
    int age;
};

struct Student s;
s.name = malloc(32);
strcpy(s.name, "David");
```

- 포인터 멤버는 **주소만** 저장. 실제 데이터는 힙 등 별도 영역.
- 구조체를 복사하면 포인터 값만 복사되어 **얕은 복사**가 됨(소유/수명 정책 주의).
- 복사语의 안전성 위해 **딥 카피 함수**를 별도로 제공.

---

## 11. 직렬화/역직렬화(엔디안·정렬) — 안전한 방식

이식 가능한 포맷을 원할 때:

- 정수는 **고정 폭 타입** 사용: `uint8_t/16/32/64_t`.
- 엔디안 변환 루틴 사용: `htobe32`, `be32toh`(POSIX), 혹은 수동 시프트.
- 구조체 전체를 `fwrite(&obj, sizeof obj, 1, fp)`로 덤프하는 방식은 **정렬·패딩·엔디안** 차이로 **비이식적**.

예: 32비트 big-endian 직렬화

```c
#include <stdint.h>
#include <stdio.h>

struct Rec { uint32_t id; uint16_t year; uint8_t flags; };

void write_rec_be(FILE *fp, const struct Rec *r){
    uint8_t buf[7];
    buf[0]=(r->id>>24)&0xFF; buf[1]=(r->id>>16)&0xFF;
    buf[2]=(r->id>> 8)&0xFF; buf[3]=(r->id>> 0)&0xFF;
    buf[4]=(r->year>>8)&0xFF; buf[5]=(r->year>>0)&0xFF;
    buf[6]=r->flags;
    fwrite(buf,1,sizeof buf,fp);
}

int read_rec_be(FILE *fp, struct Rec *r){
    uint8_t b[7]; if(fread(b,1,7,fp)!=7) return 0;
    r->id=(uint32_t)b[0]<<24| (uint32_t)b[1]<<16 | (uint32_t)b[2]<<8 | b[3];
    r->year=(uint16_t)b[4]<<8 | b[5];
    r->flags=b[6]; return 1;
}
```

---

## 12. 가변 길이 구조: Flexible Array Member(FAM)

```c
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

struct Packet {
    uint32_t len;
    uint8_t  data[]; // C99 flexible array member
};

struct Packet *packet_new(const uint8_t *src, uint32_t n){
    struct Packet *p = malloc(sizeof *p + n);
    if(!p) return NULL;
    p->len = n;
    memcpy(p->data, src, n);
    return p;
}
```

주의:

- 마지막 멤버만 `[]` 허용. 크기는 `sizeof(struct Packet)+len`.
- 오버런 방지 위해 항상 길이 검증.
- C89의 `arr[0]` 트릭은 확장에 의존 → 가급적 표준 FAM 사용.

---

## 13. `offsetof`와 `container_of` (고급)

특정 필드 포인터로부터 **바깥 구조체 주소**를 얻는 패턴(커널 등):

```c
#include <stddef.h>

#define container_of(ptr, type, member) \
    ((type*)((char*)(ptr) - offsetof(type, member)))

struct Node {
    int value;
    struct Node *next;
};

struct List {
    int size;
    struct Node head;
};

void example(struct Node *node_in_list){
    struct List *owner = container_of(node_in_list, struct List, head);
    // owner는 node_in_list를 포함하는 List를 가리킴
}
```

- 바이트 단위 포인터 산술을 위해 `(char*)` 변환 사용.
- 설계상 안전하지만, 잘못된 필드 조합 시 치명적 버그 → **불변식/테스트**로 보호.

---

## 14. 엄밀한 메모리 모델: strict aliasing, `restrict`, `volatile`

- **strict aliasing**: 서로 다른 타입 포인터는 동일 객체 별칭으로 간주되지 않을 수 있음. 최적화와 충돌 위험 → 타입 퍼닝은 `memcpy` 권장. `char*`는 예외적으로 모든 객체를 별칭 가능.
- **restrict**: 포인터가 **겹치지 않음**을 컴파일러에 알려 최적화를 돕는다.

```c
void saxpy(size_t n, float a, float * restrict x, float * restrict y){
    for(size_t i=0;i<n;i++) y[i] = a*x[i] + y[i];
}
```

- **volatile**: 메모리 매핑 IO/MMIO/레지스터 등 **컴파일러가 제거·재배치하면 안 되는 접근**에 사용. 일반 데이터에 남용 금지.

---

## 15. 하드웨어 레지스터 매핑과 비트필드의 함정

메모리 맵 레지스터에 비트필드 구조를 곧장 매핑하면 다음 문제가 있다.

- 비트 순서/패킹/엔디안 구현 정의 → 이식성 낮음.
- 컴파일러가 불필요한 read-modify-write 생성 가능.

권장: **명시적 마스크/시프트**와 `volatile` 포인터 사용.

```c
#define REG_BASE ((volatile uint32_t*)0x40000000u)
#define REG_CTRL 0x00

void set_ctrl_bits(uint32_t mask){
    volatile uint32_t *reg = REG_BASE + REG_CTRL/4;
    uint32_t v = *reg;
    v |= mask;
    *reg = v;
}
```

---

## 16. 구조체 리터럴, 복사·대입·수명

```c
struct Point { int x,y; };
struct Point p = { .x=3, .y=5 };

void foo(struct Point q);       // 값 복사(비효율 가능)
void bar(const struct Point *q);// 포인터 전달(권장)
```

- 큰 구조체는 포인터/참조 전달 권장.
- 구조체 대입은 **멤버별 복사**가 아닌 **메모리 블록 복사**로 취급.

---

## 17. 문자열과 배열, 포인터 구분

```c
char str1[6] = "hello"; // 배열(로컬, 6바이트 포함 '\0')
char *str2   = "hello"; // 읽기 전용 메모리 구역을 가리키는 포인터
```

- `str2[0]='H'`는 UB(보통 크래시). 리터럴은 통상 read-only.

---

## 18. 안전한 패킹 대 unsafe 패킹

- 파일/네트워크에 특정 바이트 포맷을 써야 할 때 `#pragma pack(1)` 구조체를 바로 덤프하지 말고, **수동 직렬화**(섹션 11)를 사용.
- 다른 컴파일러/플랫폼 간 호환성을 확보하고, 정렬 트랩/성능 저하를 피함.

---

## 19. 표준 기반 검증: 정렬·크기 체크

```c
#include <stdalign.h>
#include <assert.h>

struct Good { double b; int c; char a; };

_Static_assert(sizeof(struct Good) % alignof(struct Good) == 0, "tail padding rule");
_Static_assert(alignof(struct Good) >= alignof(double), "max align rule");
```

---

## 20. 실전 예제: 이미지 픽셀과 행렬, 직렬화

### 20.1 RGB 픽셀 AoS

```c
struct RGB { unsigned char r,g,b; };

void brighten(struct RGB *img, size_t n, unsigned char inc){
    for(size_t i=0;i<n;i++){
        unsigned v;
        v = img[i].r + inc; img[i].r = (unsigned char)(v>255?255:v);
        v = img[i].g + inc; img[i].g = (unsigned char)(v>255?255:v);
        v = img[i].b + inc; img[i].b = (unsigned char)(v>255?255:v);
    }
}
```

### 20.2 헤더 + 가변 데이터 직렬화

```c
struct Image {
    uint32_t w, h;
    uint8_t  data[]; // w*h*3 바이트
};

struct Image *image_new(uint32_t w, uint32_t h){
    uint64_t bytes = (uint64_t)w*h*3;
    if(bytes > SIZE_MAX - sizeof(struct Image)) return NULL;
    struct Image *im = malloc(sizeof *im + (size_t)bytes);
    if(!im) return NULL;
    im->w=w; im->h=h;
    return im;
}
```

- 파일 포맷은 별도 마법값/버전/엔디안 명시 필요.

---

## 21. 다형성 흉내: 함수 포인터 내장

```c
struct ShapeVTable {
    double (*area)(const void*);
    void   (*move)(void*, double dx, double dy);
};

struct Circle {
    const struct ShapeVTable *vtbl;
    double x,y,r;
};

double circle_area(const void *self){
    const struct Circle *c = self;
    return 3.141592653589793 * c->r * c->r;
}
void circle_move(void *self, double dx, double dy){
    struct Circle *c = self; c->x+=dx; c->y+=dy;
}

static const struct ShapeVTable CircleV = { circle_area, circle_move };

struct Circle circle_new(double x,double y,double r){
    struct Circle c = { &CircleV, x,y,r };
    return c;
}
```

- 이종 구조체를 **공통 인터페이스(vtable)**로 다루는 전형적인 C 패턴.

---

## 22. 구조체와 C++/다른 언어 FFI 상호운용

- 정렬/패킹이 서로 다른 언어 런타임과 어긋날 수 있다.
- FFI용 구조체는
  - 고정 폭 정수만 사용
  - 패딩이 생기지 않도록 멤버 순서 조정
  - 필요한 경우 양측 모두 같은 `#pragma pack(push, 1)` 사용(성능/안전 주의)
  - 경계에서 **테스트에 의한 합의** 필수

---

## 23. 통합 예제: 네트워크 헤더 파서(안전 버전)

비트필드 대신 명시적 파킹:

```c
#include <stdint.h>

struct Ip4 {
    uint8_t v_ihl;     // version(4) | ihl(4)
    uint8_t tos;
    uint16_t total_len; // big-endian
    // ... 생략
};

static inline uint8_t ip4_version(uint8_t vihl){ return (uint8_t)(vihl >> 4); }
static inline uint8_t ip4_ihl    (uint8_t vihl){ return (uint8_t)(vihl & 0x0F); }

static inline uint16_t be16(const uint8_t *p){ return (uint16_t)p[0]<<8 | p[1]; }

int parse_ip4(const uint8_t *buf, size_t len, struct Ip4 *out){
    if(len < 20) return 0;
    out->v_ihl    = buf[0];
    out->tos      = buf[1];
    out->total_len= be16(buf+2);
    // ...
    return 1;
}
```

---

## 24. 성능 체크리스트

- 멤버 순서로 **패딩 최소화** → 구조체 크기 감소 → 캐시 히트 향상
- 핫 루프는 SoA 고려, `restrict`로 별칭 제거
- 정렬 민감 데이터는 `alignas(N)`로 정렬 보장(SIMD, DMA 등)
- 직렬화는 memcpy/비트 연산, 패킹 구조체 직접 덤프 금지
- 포인터 소유권·수명 정책 문서화(얕은/깊은 복사 구분)

---

## 25. 디버깅·검증 팁

- `offsetof`/`sizeof`/`alignof`를 프린트하여 **ABI 실제 값** 확인
- `-Wpadded`(Clang/GCC)로 의도치 않은 패딩 경고 확인
- `-fno-strict-aliasing`는 임시 회피책(원인 분석이 먼저)
- 구조체 바이너리 레이아웃을 파일로 덤프 → hex-dump로 검증

---

## 26. 종합 예제: 전 분야 요소를 한 번에

```c
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdalign.h>

enum Kind { REC_USER, REC_PIXEL };

struct __attribute__((packed)) UserPacked {
    uint32_t id_be;     // big-endian 저장
    uint8_t  name_len;  // 이름 길이
    // name bytes 뒤따름
};

struct Pixel { uint8_t r,g,b; };

struct Record {
    enum Kind tag;
    union {
        struct { uint32_t id; char *name; } user;    // heap 보유
        struct { uint32_t w,h; struct Pixel *data; } img; // heap 보유
    } u;
};

static inline uint32_t be32(const uint8_t *p){ return (uint32_t)p[0]<<24|(uint32_t)p[1]<<16|(uint32_t)p[2]<<8|p[3]; }
static inline void wr_be32(uint8_t *p, uint32_t v){ p[0]=v>>24; p[1]=v>>16; p[2]=v>>8; p[3]=v; }

int write_user(FILE *fp, uint32_t id, const char *name){
    size_t n = strlen(name);
    if(n>255) return 0;
    uint8_t hdr[sizeof(struct UserPacked)] = {0};
    wr_be32(hdr, id);
    hdr[4] = (uint8_t)n;
    if(fwrite(hdr,1,sizeof hdr,fp)!=sizeof hdr) return 0;
    if(fwrite(name,1,n,fp)!=n) return 0;
    return 1;
}

struct Record read_user(FILE *fp){
    struct Record r = { .tag=REC_USER, .u.user={0,NULL} };
    uint8_t hdr[5];
    if(fread(hdr,1,5,fp)!=5) return r;
    uint32_t id = be32(hdr);
    uint8_t n = hdr[4];
    char *name = malloc(n+1);
    if(!name) return r;
    if(fread(name,1,n,fp)!=n){ free(name); return r; }
    name[n]=0;
    r.u.user.id=id; r.u.user.name=name;
    return r;
}
```

- 직렬화용 **packed header** + 가변 길이 데이터 이름.
- 내부 표현은 이식성 있는 정렬/엔디안 정수로 변환 후 보관.
- 해제 함수에서 `tag`에 따라 자원 회수.

---

## 27. 요약 표

| 개념 | 핵심 요점 |
|------|-----------|
| 정렬/패딩 | 정렬 요구치를 만족하도록 멤버/끝 패딩 삽입. 멤버 순서로 크기 최적화 |
| 정렬 제어 | `alignas`로 정렬 보장, 패킹은 위험(직렬화 제외) |
| 비트필드 | 구현 의존 배치. 외부 포맷엔 비권장. 비트 마스크/시프트 대안 |
| 공용체 | 메모리 공유. 태그드 유니언으로 안전 관리, 퍼닝은 `memcpy` 권장 |
| FAM | 마지막 멤버 `[]`로 가변 길이 레코드. 크기 계산·검증 필수 |
| 직렬화 | 고정 폭 정수 + 명시적 엔디안 변환 + `memcpy`/시프트로 안전하게 |
| 성능 | AoS/SoA 선택, `restrict`, 정렬 보장, 패딩 최소화 |
| 안전 | 소유권/수명 명시, aliasing 주의, MMIO는 `volatile`과 마스크 사용 |

---

## 28. 마무리

이종 자료구조의 **메모리 표현을 정확히 이해**하면, 성능(캐시·벡터화), 이식성(엔디안·정렬), 안정성(UB 회피·안전 직렬화)을 모두 잡을 수 있다. 설계 단계에서 **멤버 순서·정렬·패딩**을 의식하고, 대외 포맷은 **수동 직렬화**로 명시적으로 정의하라. 내부 표현과 외부 표현을 분리하면, ABI 차이나 컴파일러 최적화에도 흔들리지 않는 견고한 코드를 얻게 된다.
