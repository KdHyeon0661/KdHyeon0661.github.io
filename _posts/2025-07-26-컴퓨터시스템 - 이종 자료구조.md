---
layout: post
title: 컴퓨터시스템 - 이종 자료구조
date: 2025-07-26 16:20:23 +0900
category: 컴퓨터시스템
---
# 🧱 이종 자료구조 (Heterogeneous Data Structures)

## 1. 개요

이종 자료구조란 **서로 다른 타입의 데이터 요소들**을 하나의 논리적 단위로 묶은 구조를 의미합니다.  
C 언어에서는 **`struct`(구조체)** 를 이용하여 이러한 이종 자료구조를 정의합니다.

```c
struct Point {
    int x;
    int y;
};

struct Person {
    char name[20];
    int age;
    float height;
};
```

이 구조체는 `int`, `char[]`, `float` 등의 서로 다른 타입을 포함합니다.

---

## 2. 메모리에서의 표현

구조체는 **각 멤버 변수들이 순서대로 메모리에 배치**되며, 컴파일러는 각 멤버의 **정렬 요구사항(Alignment Requirement)** 에 따라 **패딩(Padding)** 을 삽입합니다.

### 📌 예제: 구조체 메모리 레이아웃

```c
struct Example {
    char a;    // 1 byte
    int b;     // 4 bytes
    char c;    // 1 byte
};
```

이 구조체의 메모리 구조는 다음과 같이 표현됩니다:

| Offset | 내용      | 설명                          |
|--------|-----------|-------------------------------|
| 0      | a         | 1 byte                        |
| 1~3    | padding   | b가 4바이트 정렬이므로 3바이트 |
| 4~7    | b         | 4 byte 정렬 만족               |
| 8      | c         | 1 byte                        |
| 9~11   | padding   | 구조체 전체 정렬 위해 패딩     |

- **총 크기**: 12바이트
- **정렬 단위**: 가장 큰 멤버(`int`의 4바이트)

---

## 3. 정렬(Alignment)과 패딩(Padding)

### ▶ 정렬 요구(Alignment Requirement)

- 각 타입은 자신의 크기 또는 시스템 정의된 정렬 기준에 맞게 **특정 주소 경계**에서 시작해야 함
- 예: `int`는 일반적으로 **4의 배수 주소**에서 시작해야 함

### ▶ 패딩(Padding)

- **정렬 요건을 만족하기 위해 삽입되는 더미 바이트**
- 메모리 낭비처럼 보이지만, **CPU의 빠른 메모리 접근**을 위해 필수

---

## 4. `sizeof`와 구조체 정렬

```c
#include <stdio.h>

struct Data {
    char a;
    double b;
    int c;
};

int main() {
    printf("Size: %lu\n", sizeof(struct Data));
    return 0;
}
```

- `char` → 1 byte  
- `double` → 8 byte (정렬 요구)  
- `int` → 4 byte  

**메모리 레이아웃 예시**:

| Offset | Field | 설명                           |
|--------|-------|--------------------------------|
| 0      | a     | 1 byte                         |
| 1~7    | padding | double의 8바이트 정렬 충족 위해 |
| 8~15   | b     | 8 byte                         |
| 16~19  | c     | 4 byte                         |
| 20~23  | padding | 구조체 정렬을 위한 끝 패딩     |

**총 크기: 24바이트**

---

## 5. 구조체 내부 포인터

구조체 안에 포인터가 포함되면, **해당 포인터는 주소만 저장**하며, 실제 대상은 다른 메모리 영역에 있음.

```c
struct Node {
    int data;
    struct Node* next;
};
```

- 이 구조체는 연결 리스트의 기본 단위
- `next`는 다음 노드를 가리키는 **주소값** (메모리 위치)

---

## 6. 구조체 배열 접근

구조체 배열은 **일정한 간격으로 배치된 연속적인 메모리 블록**입니다.  
패딩을 고려하여 접근해야 정확한 위치에 도달할 수 있습니다.

```c
struct Person {
    char name[10];
    int age;
};

struct Person people[3];
```

- 각 `Person`은 크기 `sizeof(struct Person)`만큼 차지
- 배열 접근은:  
  `&people[i] = base + i * sizeof(struct Person)`

---

## 7. 포인터를 통한 멤버 접근

```c
struct Person p = {"Alice", 30};
struct Person* ptr = &p;

printf("%s\n", ptr->name);  // 구조체 포인터에서 -> 사용
printf("%d\n", (*ptr).age); // 괄호 필요
```

---

## 8. 비트 필드(Bit-fields)

C에서는 구조체의 멤버에 **비트 단위 크기**를 지정할 수 있음.

```c
struct Flags {
    unsigned int a : 1;
    unsigned int b : 2;
    unsigned int c : 5;
};
```

- 총 8비트 사용
- 실제로는 `int` 크기 단위(예: 4바이트)로 저장될 수 있음

---

## 9. 공용체 (Union)

공용체는 **모든 멤버가 동일한 메모리 공간을 공유**하는 특수한 이종 자료구조

```c
union Data {
    int i;
    float f;
    char str[20];
};
```

- 가장 큰 멤버의 크기만큼만 메모리 할당됨
- 하나의 멤버만 유효하게 사용 가능

---

## 10. 포인터와 이종 자료구조의 결합

```c
struct Student {
    char* name;
    int age;
};

struct Student s1;
s1.name = malloc(20);
strcpy(s1.name, "David");
```

- `char* name`은 동적 할당된 문자열을 가리킴
- 구조체 자체는 stack에 있지만, 내부 데이터는 heap에 있을 수 있음

---

## 11. 메모리 정렬을 최적화하는 팁

### ▶ 멤버 정렬 순서를 최적화

아래 구조체는 비효율적입니다:

```c
struct Bad {
    char a;
    double b;
    int c;
}; // 총 24바이트
```

아래처럼 멤버를 정렬하면 패딩 감소:

```c
struct Good {
    double b;
    int c;
    char a;
}; // 총 16바이트
```

### ▶ `__attribute__((packed))` (GCC 전용)

패딩 없이 구조체를 정의 가능:

```c
struct __attribute__((packed)) PackedStruct {
    char a;
    int b;
    char c;
}; // 패딩 없음 → 6바이트
```

주의: 정렬이 깨지므로 **성능 저하**나 **오류** 위험

---

## 12. 구조체를 함수 인자로 전달할 때

- 기본적으로 **복사 전달(pass by value)** 방식
- 구조체 크기가 크면 **포인터를 넘기는 것이 효율적**

```c
void printPerson(struct Person p);       // 비효율
void printPersonPtr(struct Person* p);   // 권장
```

---

## 13. 구조체 리터럴

C99부터 구조체 리터럴을 직접 사용할 수 있습니다:

```c
struct Point p = { .x = 3, .y = 5 };
```

함수 인자에도 즉시 전달 가능:

```c
printPoint((struct Point){.x = 1, .y = 2});
```

---

## 14. 실전 예제: RGB 픽셀

```c
struct RGB {
    unsigned char r, g, b;
};
```

- 1픽셀당 3바이트
- 이미지 처리에서 RGB 배열은 `struct RGB* image`로 표현

---

## 15. 구조체 포인터 배열

```c
struct Student* class[30]; // 학생 30명의 포인터

class[0] = malloc(sizeof(struct Student));
class[0]->age = 20;
```

---

## ✅ 정리

| 개념          | 설명 |
|---------------|------|
| 구조체        | 이종 자료의 집합 |
| 패딩          | 정렬 요건 만족을 위한 공백 |
| 정렬 요구     | 타입마다 요구하는 주소 정렬 |
| 포인터 멤버   | 주소만 저장, 별도 메모리 필요 |
| 구조체 배열   | 연속된 메모리 블록 |
| 비트 필드     | 비트 단위로 멤버 선언 가능 |
| 공용체        | 모든 멤버가 같은 공간 공유 |
| 리터럴 초기화 | C99부터 멤버 이름으로 초기화 가능 |