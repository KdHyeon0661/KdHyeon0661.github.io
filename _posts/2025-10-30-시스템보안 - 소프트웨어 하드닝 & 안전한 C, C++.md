---
layout: post
title: 시스템보안 - 소프트웨어 하드닝 & 안전한 C/C++
date: 2025-10-30 14:30:23 +0900
category: 시스템보안
---
# 소프트웨어 하드닝 & 안전한 C/C++

## 언어 레벨: UB, 정수/포인터 산술, 메모리 모델

### **UB(Undefined Behavior)** 핵심 맥락

- **정의**: 표준이 결과를 규정하지 않는 동작. 컴파일러는 **UB가 없다고 가정**하고 최적화하므로, UB가 섞이면 “빌드 옵션이나 입력에 따라” 전혀 다른 실행이 나옴.
- **대표 예시**
  - 정수 오버플로우(부호 있는 정수)
  - 널/댕글링/미정렬 포인터 역참조
  - 경합(data race) / 잘못된 원자성
  - 범위 밖 배열 접근, 0으로 나누기, 시퀀스 포인트 전후 이중 평가 등

**안티패턴 — 부호 있는 정수 오버플로우**
```cpp
int mul(int a, int b) {
    // a,b가 INT_MAX 근처면 오버플로우 → UB
    return a * b;
}
```

**대안 (체크 + 안전한 승격/검증)**
```cpp
#include <limits>
#include <optional>

std::optional<int> safe_mul(int a, int b) {
    long long r = 1LL * a * b; // 넓은 타입으로 승격 후
    if (r < std::numeric_limits<int>::min() || r > std::numeric_limits<int>::max())
        return std::nullopt;
    return static_cast<int>(r);
}
```

> 팁: **산itizer(UBSan)**로 UB 가능 지점을 사전에 검출하고, 중요한 경계에는 **계약(계약 검사/어설션)**을 두세요.

---

### **정수 산술**: 부호·승격·시프트·나눗셈

- **부호 승격**: `char/short` → `int`로 승격. 서명 유지에 주의.
- **시프트**: 음수 시프트, 범위 밖 시프트는 UB.
- **나눗셈**: 0 나눗셈, `INT_MIN / -1` 오버플로우.

**안티패턴**
```cpp
int div_floor(int x, int y) {
    return x / y; // y==0 / x==INT_MIN, y==-1 시 UB/오버플로우 위험
}
```

**대안**
```cpp
#include <optional>

std::optional<int> div_floor_safe(int x, int y) {
    if (y == 0) return std::nullopt;
    if (x == std::numeric_limits<int>::min() && y == -1) return std::nullopt;
    return x / y;
}
```

---

### **포인터 산술/수명/정렬**

- **수명(lifetime)** 밖 객체 접근, **미정렬 접근**(SSE/NEON 등) → UB.
- **strict aliasing**: 다른 타입 포인터로 같은 메모리를 접근하면 UB(일부 예외: `char`, 표준 레이아웃 등).

**안티패턴 (strict aliasing 위반)**
```cpp
float f = 1.0f;
int* ip = reinterpret_cast<int*>(&f); // UB 가능
*ip = 0;
```

**대안 — `memcpy` 또는 `std::bit_cast`(C++20)**
```cpp
#include <bit>

float f = 1.0f;
int i = std::bit_cast<int>(f); // 안전한 재해석
```

---

### **메모리 모델**: 원자성/주문/경합

- **data race**는 UB. 두 스레드가 같은 메모리를 동시 갱신(적어도 하나는 write)하면서 동기화가 없으면 **결과 불명**.
- **std::atomic**과 **메모리 오더**(seq_cst, acquire/release 등)로 공개·관찰 순서를 정의.

**안티패턴 — 락 없이 공유 변수 갱신**
```cpp
int g_counter = 0;
void worker() { // 경합 → UB
  for (int i=0;i<100000;i++) g_counter++;
}
```

**대안 — 원자/뮤텍스**
```cpp
#include <atomic>

std::atomic<int> g_counter{0};
void worker() {
  for (int i=0;i<100000;i++) g_counter.fetch_add(1, std::memory_order_relaxed);
}
```

---

### **자원 관리**: 소유권/누수/이중해제

- **RAII**로 수명=스코프 정렬: `std::unique_ptr`, `std::shared_ptr`, `std::vector`, `std::string`.
- **gsl::not_null**, **span** 등 뷰/약참조 도구로 **계약**을 명시.

**안티패턴 — 수동 new/delete**
```cpp
int* arr = new int[n]; // 예외 발생 시 누수 가능, 범위 보호 없음
// ...
delete[] arr;
```

**대안 — 컨테이너/스마트포인터**
```cpp
#include <vector>

std::vector<int> arr(n); // 범위·예외 안전
```

---

### **계약(Contract)·사전조건/사후조건·어설션**

- **개발**: `assert(cond)`로 불변식 점검(릴리즈에서 제거 가능).
- **런타임 품질**: 실패 시 **정확한 메시지 + 입력 로깅**.

```cpp
#include <cassert>
#include <string_view>

int at(std::string_view s, size_t i) {
    assert(i < s.size() && "index out of bounds");
    return static_cast<unsigned char>(s[i]);
}
```

---

## 빌드 하드닝: Stack Protector, FORTIFY, Control-Flow 보호

> 목적: **버그가 있어도** 악용 난이도를 올리고 **조기 탐지**되도록 **툴체인·링커·OS 기능**을 적극 사용.

### **리눅스/유닉스 계열** 컴파일·링크 플래그(Clang/GCC)

- **스택 보호**: `-fstack-protector-strong` (또는 `-fstack-protector-all`)
- **포티파이**: `-D_FORTIFY_SOURCE=3 -O2` (glibc 2.34+ — 환경에 맞춰 단계 선택)
- **PIE/ASLR 연동**: `-fPIE -pie`
- **RELRO/즉시 바인딩**: `-Wl,-z,relro -Wl,-z,now`
- **NX/No-Exec-Stack**: `-Wl,-z,noexecstack`
- **CF 보호(x86 CET)**: `-fcf-protection=full` (하드웨어·툴체인 지원 시)
- **CFI(Clang)**: `-fsanitize=cfi -fvisibility=hidden -flto`(클래스 계층·가상호출 보호)
- **스택 클러시 보호**: `-fstack-clash-protection`
- **문자열 함정 금지**: `-Wstringop-overflow -Wformat -Wformat-security -fno-strict-overflow`
- **정적 분석**: `-fanalyzer`(GCC), `clang-tidy`, `scan-build`

**예: 하든드 빌드 커맨드(Clang)**
```bash
clang++ -O2 -g                                  \
  -fstack-protector-strong -fstack-clash-protection \
  -D_FORTIFY_SOURCE=3                           \
  -fPIE -pie                                    \
  -Wl,-z,relro -Wl,-z,now -Wl,-z,noexecstack    \
  -fcf-protection=full                          \
  -Wall -Wextra -Wformat -Wformat-security      \
  -o app src/*.cc
```

**링커/런타임 커널 설정(예)**
```bash
# 배포 OS에서 확인 (예: Linux)

sysctl kernel.randomize_va_space=2  # ASLR Full
# PaX/SELinux/AppArmor 등 MAC 정책 병행

```

---

### **Windows/MSVC** 하드닝

- **CFG(Control Flow Guard)**: `/guard:cf`
- **CET(Shadow Stack)**: `/CETCOMPAT` (하드웨어·OS 지원 필요)
- **주소 랜덤화/DEP**: `/DYNAMICBASE /NXCOMPAT`
- **/sdl**: 추가 보안 진단(안전 함수/경계 검증 강화)
- **/GS**: 스택 커키(기본)
- **/guard:ehcont**: EH 컨티뉴에이션 보호(최신 도구체인)
- **/HIGHENTROPYVA**: 64bit 고엔트로피 ASLR

**예: MSVC 릴리즈 프로파일**
```bat
cl /O2 /GL /GS /sdl                           ^
   /guard:cf /CETCOMPAT /DYNAMICBASE /NXCOMPAT ^
   /EHsc /Zi /MD                               ^
   /link /LTCG /HIGHENTROPYVA
```

---

### **FORTIFY** 계열

- **개념**: `memcpy/strcpy/sprintf` 등 위험 API를 **컴파일 타임/런타임**에서 **경계 체크**로 대체.
- **주의**: 최적화 레벨(`-O2` 이상)과 함께 사용할 때 효과적.
- **대체 API**: `snprintf`, `strlcpy`(플랫폼), `memcpy_s`(C11 Annex K/MS 확장), C++에서는 `std::string`, `std::array`, `std::vector`.

---

### **CFI/IFC/Return Address 보호**

- **Clang CFI**: 가상 호출/함수 포인터 타깃 검증. LTO 필요.
- **Shadow Call Stack(CET/ARM64e PAC)**: 리턴 주소 보호(하드웨어 보조).
- **Windows CFG**: 간접 호출 타깃 검증.

---

### **CMake** 하드닝 프리셋 예시

```cmake
# cmake -S . -B build -DCMAKE_BUILD_TYPE=RelWithDebInfo -DHARDEN=ON

cmake_minimum_required(VERSION 3.20)
project(hardened LANGUAGES C CXX)

option(HARDEN "Enable hardening" ON)

if (MSVC)
  add_compile_options(/W4 /permissive- /EHsc /utf-8)
  if (HARDEN)
    add_compile_options(/sdl /GS /guard:cf /CETCOMPAT)
    add_link_options(/DYNAMICBASE /NXCOMPAT /guard:cf /CETCOMPAT /HIGHENTROPYVA)
  endif()
else()
  add_compile_options(-Wall -Wextra -Wpedantic -Wformat -Wformat-security)
  if (HARDEN)
    add_compile_options(-O2 -fstack-protector-strong -fstack-clash-protection
                        -D_FORTIFY_SOURCE=3 -fcf-protection=full)
    add_link_options(-Wl,-z,relro -Wl,-z,now -Wl,-z,noexecstack -fPIE -pie)
  endif()
endif()

add_executable(app src/main.cpp)
```

---

### **라이브러리 선택**: 안전 기본값

- **fmt**(`fmt::format`)로 `printf` 포맷 취약 축소.
- **GSL**(Guidelines Support Library): `gsl::span`, `not_null`, `narrow`.
- **abseil**: `absl::StatusOr`, `flat_hash_map` 등 견고한 유틸.
- **{fmt}+spdlog**: 안전 포맷+로깅 (입력 제한/마스킹 정책 병행).

---

## 파이프라인

> **전략**: “**버그를 빨리, 싸게** 잡는다.”
> 개발 브랜치에서는 **Sanitizer on**, 릴리즈에서는 **하드닝 on**.
> Fuzz는 **핵심 파서/경계 기능**을 중심으로 **상시(OSS-Fuzz 유사)** 돌린다.

### Sanitizer 개요

- **ASan(AddressSanitizer)**: OOB/Use-After-Free/이중해제 감지.
- **UBSan(UndefinedBehaviorSanitizer)**: 오버플로우/잘못된 캐스트/정렬/나눗셈 0 등.
- **MSan(MemorySanitizer)**: 초기화되지 않은 읽기 감지(Clang, Linux).
- **TSan(ThreadSanitizer)**: 데이터 경합 감지.
- **LSan(LeakSanitizer)**: 누수 감지(ASan 포함/일부 플랫폼 별도).

**Clang 예시(디버그 빌드)**
```bash
# ASan + UBSan: 가장 추천되는 조합

clang++ -g -O1 -fsanitize=address,undefined -fno-omit-frame-pointer \
        -fno-optimize-sibling-calls -o app_asan src/*.cc

# MSan (Linux, libc++ 권장), TSan은 각각 별도 빌드로

clang++ -g -O1 -fsanitize=memory -fno-omit-frame-pointer -o app_msan src/*.cc
clang++ -g -O1 -fsanitize=thread -fno-omit-frame-pointer -o app_tsan src/*.cc
```

**MSVC(Windows)**
- **ASan 지원**(x64/ARM64, /fsanitize=address).
- UBSan/TSan은 제한적(대개 Clang-cl 선호).

```bat
cl /Zi /Od /fsanitize=address src\*.cpp /link /debug
```

> 주의: Sanitizer 빌드와 **하드닝 플래그 일부는 충돌**할 수 있습니다(특히 CFI/LTO 조합). **CI Job을 분리**하세요.
> 예) `job: sanitize_debug`, `job: release_hardened`.

---

### 실패 예시 → ASan 재현

**버그 코드 (OOB)**
```cpp
#include <cstdio>

int main() {
    int a[3] = {1,2,3};
    for (int i=0;i<=3;i++) // <= 3 → OOB
        std::printf("%d\n", a[i]);
}
```

**ASan 빌드/실행**
```bash
clang++ -g -O1 -fsanitize=address -fno-omit-frame-pointer oob.cpp -o oob_asan
./oob_asan
# => AddressSanitizer: heap-buffer-overflow / stack-buffer-overflow 보고 + 스택트레이스

```

**수정**
```cpp
for (int i=0;i<3;i++)
    std::printf("%d\n", a[i]);
```

---

### **Fuzzing**: libFuzzer (in-process, coverage-guided)

#### 대상 선택

- 파일/네트워크 **파서**, 포맷 변환, 압축/암호 해제, 이미지/JSON/ASN.1/프로토콜 등.

#### 최소 하네스

```cpp
// fuzz_parse.cpp
#include <cstdint>
#include <cstddef>
#include "parser.hpp" // 우리가 검증할 함수

extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
    parse_message(data, size); // 예: 크래시/UB 없이 실패를 반환해야 함
    return 0;
}
```

**빌드 (Clang)**
```bash
clang++ -g -O1 -fsanitize=address,undefined,fuzzer -fno-omit-frame-pointer \
        fuzz_parse.cpp parser.cpp -o fuzz_parse
# -fsanitize=fuzzer 가 커버리지 + mutator 포함(Clang)

```

**실행**
```bash
mkdir -p corpus seeds
cp samples/* seeds/
./fuzz_parse -seed=1337 -max_total_time=60 -jobs=4 -workers=4 -artifact_prefix=crashes/
```

**크래시 triage**
```bash
# 재현

./fuzz_parse crashes/id:000003,sig:11,*
# stack 트레이스 확인(ASan/UBSan 메시지로 원인 파악)

```

#### “안전 파서” 원칙

- **최대 길이·중첩 한도** 상수화(DoS 방지).
- **정수 오버플로 검증**: size 계산 시 `checked_add/checked_mul`.
- **에러 우선 반환**: 예외 대신 명시적 `StatusOr`/에러코드.
- **할당 상한**: 입력 길이 기반 상한/쿼터.

**안티패턴 → 안전한 파서 스케치**
```cpp
// 나쁜 예
uint32_t len = *(uint32_t*)data; // 엔디안·범위 체크 없음
std::string s((const char*)data+4, len); // len 신뢰 → 크래시/메모리고갈

// 안전 예
#include <optional>

std::optional<std::string> read_blob(const uint8_t* p, size_t n) {
    if (n < 4) return std::nullopt;
    uint32_t len;
    std::memcpy(&len, p, 4);
    // 엔디안 변환 필요시 적용
    if (len > 1<<20) return std::nullopt; // 1MB 상한
    if (n < 4 + len) return std::nullopt;
    return std::string((const char*)p+4, (const char*)p+4+len);
}
```

---

### **AFL++/honggfuzz** (fork-server 계열)

- 대상 바이너리와 **입력 파일 인터페이스**가 있을 때 유리.
- **ASan/UBSan**과 함께 빌드하여 충돌을 더 빨리 노출.

**AFL++ 간단 예**
```bash
# 계측 빌드

CC=afl-cc CXX=afl-c++ CFLAGS="-O1 -g -fsanitize=address,undefined" \
CXXFLAGS="-O1 -g -fsanitize=address,undefined" \
make target_binary

# 퍼징

afl-fuzz -i seeds -o findings -- ./target_binary @@
```

---

### **커버리지/회귀**: crash 최소화 & CI 연동

- **minimize**: `llvm-profdata`, `llvm-cov`로 커버리지 확인, **최소 재현 입력** 유지.
- **회귀 방지**: `crashes/` 재현 입력을 **유닛테스트로 편입**.

**CMake + libFuzzer 테스트(개략)**
```cmake
add_executable(fuzz_parse fuzz_parse.cpp parser.cpp)
target_compile_options(fuzz_parse PRIVATE -fsanitize=address,undefined,fuzzer -O1 -g -fno-omit-frame-pointer)
add_test(NAME fuzz_smoke COMMAND fuzz_parse -runs=1000 ${CMAKE_CURRENT_SOURCE_DIR}/seeds)
```

---

### **현실적 파이프라인**: Dev/PR/Release 단계

**Dev 브랜치**
- `-fsanitize=address,undefined` 기본, `clang-tidy`, `cppcheck`, `include-what-you-use`.
- PR마다 **libFuzzer smoke-run**(수초~수분).

**Nightly**
- 장시간 퍼징 잡(수십 분~수시간), **코퍼스 자동 병합·최소화**.
- Sanitizer·TSan 빌드 병렬.

**Release**
- Sanitizer OFF, **하드닝 ON**(12.2).
- LTO/CFI(가능 시), RELRO/NOW, PIE, FORTIFY.
- 사인(Windows 코드서명/패키지 서명), SBOM 생성, 재현 빌드 설정.

---

## 부록 A. **실패 패턴 대조표** (요약)

| 위험 | 안티패턴 | 안전 대안 |
|---|---|---|
| 부호 정수 오버플로 | `int x=a*b;` | 확장 승격 + 범위검사 or 내장 체크 루틴 |
| 배열 경계 | 수동 인덱싱 | `span`/`vector::at()`(디버그)/계약 |
| 문자열 복사 | `strcpy/sprintf` | `snprintf`, `{fmt}`, `std::string` |
| 타입 재해석 | `*(int*)&f` | `std::bit_cast` / `memcpy` |
| 동시성 | 락 없음 공유 | `std::atomic`/뮤텍스/TSan 테스트 |
| 수명 | raw new/delete | RAII(컨테이너/스마트포인터) |
| 포맷 취약 | `printf(user)` | 안전 포맷(`fmt::format`, 명시적 포맷 문자열) |

---

## 부록 B. **샘플 프로젝트 뼈대** (하드닝·산itizer 프리셋)

```
/proj
 ├─ CMakeLists.txt     # 12.2.5 참고
 ├─ src/
 │   ├─ main.cpp
 │   └─ parser.cpp / parser.hpp
 ├─ fuzz/
 │   └─ fuzz_parse.cpp
 ├─ seeds/
 │   └─ sample1.bin ...
 ├─ .clang-tidy        # modernize/readability/performance checks
 └─ ci/
     ├─ sanitize.yml   # ASan/UBSan 빌드 + smoke fuzz
     └─ release.yml    # Hardened build + SBOM + signing
```

**main.cpp (견고한 입력 경계)**
```cpp
#include <iostream>
#include "parser.hpp"

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    std::string buf((std::istreambuf_iterator<char>(std::cin)),
                     std::istreambuf_iterator<char>());

    auto res = parse_message(reinterpret_cast<const uint8_t*>(buf.data()), buf.size());
    if (!res.ok()) {
        std::cerr << "parse error: " << res.error() << "\n";
        return 1;
    }
    std::cout << res->to_json() << "\n";
}
```

---

# 체크리스트 (운영 관점)

**코딩 규율**
- [ ] RAII 100%, 소유권 명시(`unique_ptr`/`string`/`vector`)
- [ ] `bit_cast/memcpy`로만 재해석, strict-aliasing 위반 금지
- [ ] 경계·상한·중첩 제한 상수화(DoS 방지)

**빌드 하드닝**
- [ ] Linux: SSP/PIE/RELRO/NOW/NOEXECSTACK/FORTIFY/CET/CFI(가능 시)
- [ ] Windows: /GS /sdl /guard:cf /CETCOMPAT /NXCOMPAT /DYNAMICBASE /HIGHENTROPYVA
- [ ] LTO/서명/SBOM/재현 빌드

**Sanitizer & Fuzz**
- [ ] ASan+UBSan 디폴트 PR
- [ ] 핵심 파서 libFuzzer 상시(나이틀리 장시간)
- [ ] 크래시 재현 입력을 회귀 테스트로 편입

**배포**
- [ ] 릴리즈 바이너리는 Sanitizer OFF, 하드닝 ON
- [ ] 런타임 보안 기능(OS·컨테이너) 병행: seccomp/AppArmor/ASLR 확인
- [ ] Crash 보고(심볼/stacktrace) 파이프라인

---

# 결론

- **언어 레벨**에서 UB·정수/포인터·메모리 모델을 이해하고 **사전 방지**가 1차 방어선입니다.
- **툴체인 하드닝**은 “버그가 있더라도” 악용 난이도를 올립니다.
- **Sanitizer×Fuzz** 파이프라인은 **개발 초기에** 치명 버그를 값싸게 제거합니다.
- 이 세 축(안전 코딩·하드닝·테스트 자동화)을 **CI로 고정**하면, 보안/안정성/성능의 균형을 장기적으로 유지할 수 있습니다.
