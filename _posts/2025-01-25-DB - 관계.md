---
layout: post
title: DB - 관계
date: 2025-01-25 22:20:23 +0900
category: DB
---
# 관계(Relationship)

## 리마인드: 핵심 요약

- **관계**는 엔터티 간의 **업무적 연관성**을 의미하며, **관계명, 카디널리티(최소/최대 참여 수), 옵셔널리티, 외래키**로 정의되고 구현됩니다.
- **1:1, 1:N, N:M** 관계가 있으며, N:M 관계는 반드시 **조인 테이블**을 통해 분해(1:N + 1:N)해야 합니다.
- **식별자 관계**: 부모의 기본키가 자식의 기본키에 포함되는 강한 결합입니다.
  **비식별자 관계**: 자식의 기본키는 독립적이며, 부모의 기본키는 자식의 일반 외래키로 연결되는 약한 결합입니다.
- **FK 제약 ON DELETE/UPDATE**: CASCADE, SET NULL, RESTRICT(NO ACTION) 등으로 참조 무결성을 보장합니다.
- **ER 표기**: Crow’s Foot, IE Notation 등으로 최소/최대 참여 수를 표현합니다.
- **주의사항**: 외래키는 항상 **다(N)쪽**에 위치하며, **공유 속성**이 있다면 조인 테이블이 실질적인 엔터티가 될 수 있습니다. **‘카디널리티’**라는 용어는 맥락에 따라 다른 의미로 사용되므로 구분이 필요합니다.

이러한 기초를 바탕으로 실무에서 마주할 수 있는 함정, 설계 패턴, 상세 예제, 그리고 테스트 방법까지 확장해 살펴보겠습니다.

---

## 카디널리티와 옵셔널리티의 정밀한 이해

### 최소·최대 참여수의 업무적 의미

- **최소 참여수(0 또는 1)**: 한 엔터티의 레코드가 생성되고 유지되기 위해 **반드시** 다른 엔터티에 연결되어야 하는지를 정의합니다.
  예를 들어, “주문은 고객 없이 존재할 수 있는가?”라는 질문에 대부분 ‘아니오’라면 최소 참여수는 1입니다.
- **최대 참여수(1 또는 N)**: 한 엔터티의 한 인스턴스가 상대측 엔터티의 몇 개 인스턴스와 연결될 수 있는지를 정의합니다.
  예를 들어, “한 고객은 여러 주문을 가질 수 있는가?”라는 질문에 ‘예’라면 최대 참여수는 N입니다.

### 데이터베이스 제약으로의 구현

- 최소 참여수가 1인 필수 관계를 **데이터베이스 수준에서 강제**하려면 외래키 컬럼을 **NOT NULL**로 선언하고, 참조 무결성 동작을 **RESTRICT** 또는 **NO ACTION**으로 설정해야 합니다.
- 최소 참여수가 0인 선택적 관계는 외래키 컬럼을 **NULL 허용**으로 설정하며, 비즈니스 규칙(예: 1:1 관계에서의 유일성)에 주의하여 설계합니다.

```sql
-- 고객(1) : 주문(N) 관계. 주문은 반드시 한 고객에 속해야 함(최소 참여수=1).
CREATE TABLE Customer (
  CustomerID BIGINT PRIMARY KEY,
  Name       TEXT NOT NULL
);

CREATE TABLE "Order" (
  OrderID     BIGINT PRIMARY KEY,
  CustomerID  BIGINT NOT NULL, -- NOT NULL로 필수 관계 표현
  OrderDate   TIMESTAMP NOT NULL,
  FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID)
    ON DELETE RESTRICT  -- 고객 삭제 방지로 관계 유지 강제
    ON UPDATE CASCADE   -- 고객 ID 변경 시 함께 변경
);
```

---

## 1:1 관계의 설계 패턴과 선택

### 1:1 관계가 필요한 경우

주로 하나의 논리적 엔터티를 **물리적으로 분리**해야 할 때 사용합니다. 예를 들어 보안 등급이 높은 민감정보와 자주 조회되는 기본 정보의 분리, 갱신 빈도가 서로 다른 속성의 분리, 성능 최적화 등을 위한 목적이 있습니다.

### 구현 패턴 A: 강제적 1:1 (식별자 관계)

상세 테이블의 기본키가 부모 테이블 기본키를 그대로 외래키로 사용하는 방식입니다. 자식 레코드는 부모 없이 독립적으로 존재할 수 없습니다.

```sql
CREATE TABLE UserAccount (
  UserID BIGINT PRIMARY KEY,
  Email  TEXT NOT NULL UNIQUE
);

-- UserProfile의 PK는 UserID이면서, UserAccount를 참조하는 FK입니다.
CREATE TABLE UserProfile (
  UserID BIGINT PRIMARY KEY, -- PK = FK
  Phone  TEXT,
  Birth  DATE,
  FOREIGN KEY (UserID) REFERENCES UserAccount(UserID)
    ON DELETE CASCADE -- 사용자 계정 삭제 시 프로필도 함께 삭제
);
```

**장점**: 데이터베이스가 구조적으로 1:1 관계를 강력하게 보장합니다.
**단점**: 자식 테이블의 독립적인 확장성이 제한될 수 있습니다.

### 구현 패턴 B: 선택적 1:1 (비식별자 관계 + UNIQUE FK)

상세 테이블은 독자적인 기본키를 가지며, 부모 테이블을 참조하는 외래키에 **UNIQUE 제약**을 추가하여 1:1 관계를 구현합니다.

```sql
CREATE TABLE UserProfile2 (
  ProfileID BIGSERIAL PRIMARY KEY, -- 독립적인 PK
  UserID    BIGINT UNIQUE,  -- 한 사용자당 최대 하나의 프로필만 허용
  Phone     TEXT,
  FOREIGN KEY (UserID) REFERENCES UserAccount(UserID)
    ON DELETE SET NULL      -- 사용자 삭제 시 프로필의 FK만 NULL 설정
);
```

**장점**: 자식 레코드(프로필)가 존재하지 않을 수도 있는 선택적 관계를 모델링하기에 유연합니다.
**단점**: UNIQUE 제약만으로는 부모 레코드당 정확히 하나의 자식 레코드 존재를 완벽히 강제할 수 없습니다(부모 측에서 제어 필요).

**선택 가이드**:
- **항상 함께 존재해야 하는 강한 결합**에는 PK=FK 방식을 고려합니다.
- **생성 시점이 다르거나 선택적일 수 있는 관계**에는 UNIQUE FK 방식을 고려합니다.

---

## 1:N 관계의 고급 설계 고려사항

### 비즈니스 규칙에 따른 외래키 전략

- **삭제 규칙**: 고객이 탈퇴할 때 그 고객의 주문 기록을 어떻게 처리할지 결정해야 합니다.
  - **RESTRICT / NO ACTION**: 안전한 선택입니다. 모든 자식 레코드를 정리하기 전에는 부모 삭제를 차단하여 데이터 무결성을 보호합니다.
  - **CASCADE**: 편리하지만 데이터의 영구적인 소멸을 의미합니다. 감사나 회계 목적의 데이터에는 부적합할 수 있습니다.
  - **SET NULL**: 주문 같은 트랜잭션 기록은 보존하되, 고객과의 연결만 끊고 싶을 때 사용합니다. 외래키 컬럼이 NOT NULL이면 사용할 수 없습니다.

### 데이터 보존을 위한 소프트 삭제 패턴

실제 삭제 대신 삭제 표시 플래그를 두는 방식으로, 관계와 역사를 모두 보존할 수 있습니다.

```sql
-- 고객 테이블에 소프트 삭제 플래그 추가
ALTER TABLE Customer ADD COLUMN IsDeleted BOOLEAN NOT NULL DEFAULT FALSE;

-- 삭제 요청 시, 실제 DELETE 대신 UPDATE 실행
UPDATE Customer SET IsDeleted = TRUE WHERE CustomerID = 101;

-- 주문을 조회할 때는 삭제되지 않은 고객의 주문만 표시
SELECT o.*
FROM "Order" o
JOIN Customer c ON o.CustomerID = c.CustomerID
WHERE c.IsDeleted = FALSE;
```

### 성능을 위한 인덱싱

1:N 관계에서 부모(`1`쪽)에서 자식(`N`쪽)을 자주 조회하거나, 자식 테이블을 통한 필터링이 빈번한 경우, **자식 테이블의 외래키 컬럼에 인덱스를 생성하는 것은 필수**입니다.

```sql
-- 주문 테이블의 고객ID에 인덱스 생성
CREATE INDEX idx_order_customer ON "Order"(CustomerID);
```

---

## N:M 관계와 조인 테이블의 실체화

### 단순 연결을 넘어 업무 엔터티로 발전하는 경우

학생과 과목의 관계를 ‘수강’이라는 조인 테이블로 표현할 때, 단순히 연결만 기록하는 것이 아니라 ‘수강일자’, ‘성적’, ‘수강상태’와 같은 **고유한 속성과 비즈니스 로직**을 가지게 된다면, 이 조인 테이블은 명확한 엔터티가 됩니다.

```sql
CREATE TABLE StudentCourse (
  StudentID  BIGINT NOT NULL,
  CourseID   BIGINT NOT NULL,
  EnrollDate DATE   NOT NULL, -- 수강 신청일
  Grade      TEXT,            -- 성적
  Status     TEXT NOT NULL CHECK (Status IN ('ENROLLED','DROPPED','COMPLETED')), -- 상태
  PRIMARY KEY (StudentID, CourseID),
  FOREIGN KEY (StudentID) REFERENCES Student(StudentID) ON DELETE CASCADE,
  FOREIGN KEY (CourseID)  REFERENCES Course(CourseID) ON DELETE RESTRICT
);
```

### 복잡한 비즈니스 제약의 적용

- **중복 관계 방지**: 동일한 학생이 동일한 과목을 중복 수강하지 못하도록 기본키(`PRIMARY KEY`) 또는 유니크 제약(`UNIQUE`)으로 강제합니다.
- **재수강 허용**: 중복을 허용해야 하는 경우(예: 재수강), 회차를 나타내는 컬럼을 기본키에 포함시켜 유일성을 재정의합니다.

```sql
-- 재수강을 허용하는 구조 (회차를 구분)
CREATE TABLE StudentCourse2 (
  StudentID  BIGINT NOT NULL,
  CourseID   BIGINT NOT NULL,
  AttemptNo  INT    NOT NULL DEFAULT 1, -- 수강 시도 회차
  EnrollDate DATE   NOT NULL,
  PRIMARY KEY (StudentID, CourseID, AttemptNo) -- 회차까지 포함한 복합키
);
```

---

## 식별자 관계 vs 비식별자 관계: 실무 선택 기준

| 기준 | 식별자 관계 | 비식별자 관계 |
| :--- | :--- | :--- |
| **키 구조** | 부모 PK가 자식 PK의 일부가 됨 (복합키) | 자식 PK는 독립적. 부모 PK는 자식의 일반 FK로 연결 |
| **의존성** | 강함. 부모 없이 자식은 존재 불가 | 약함. 자식이 독립적으로 존재 가능한 구조 |
| **장점** | 관계가 매우 강하게 표현됨. 약엔터티 모델링에 적합 | 확장성과 유연성이 높음. 마이그레이션 용이 |
| **단점** | 복합키가 하위 테이블로 전파되면 조인과 인덱스 관리가 복잡해질 수 있음 | 순수한 1:1 관계를 표현하려면 추가 UNIQUE 제약 필요 |
| **적합한 경우** | 주문(Order)과 주문항목(OrderItem)처럼 진정한 전체-부분 관계 | 대부분의 일반적인 관계(고객-주문, 게시글-댓글 등) |

**실무적 조언**:
과도한 식별자 관계 사용은 복잡한 복합키를 양산하여 ORM 매핑, 쿼리 작성, 인덱스 전략을 어렵게 만들 수 있습니다. **대리키(Surrogate Key, 예: `BIGSERIAL`)**를 기본키로 사용하고, 업무적 유일성은 별도의 `UNIQUE` 제약으로 관리하는 비식별자 관계 방식이 장기적인 유지보수성에서 우위를 가질 때가 많습니다.

---

## 특수 관계 패턴: 재귀, 상속, 시간적 관계

### 재귀 관계 (자기 참조 관계)

조직도, 카테고리 계층 구조 등을 표현할 때 사용합니다.

```sql
CREATE TABLE Category (
  CategoryID   BIGINT PRIMARY KEY,
  Name         TEXT NOT NULL,
  ParentID     BIGINT NULL, -- 부모 카테고리를 참조
  FOREIGN KEY (ParentID) REFERENCES Category(CategoryID)
    ON DELETE SET NULL -- 부모 삭제 시 자식은 최상위로
);

-- 특정 카테고리의 모든 하위 카테고리를 조회 (재귀 CTE)
WITH RECURSIVE SubCategories AS (
  SELECT CategoryID, Name, ParentID
  FROM Category
  WHERE CategoryID = 1 -- 시작점
  UNION ALL
  SELECT c.CategoryID, c.Name, c.ParentID
  FROM Category c
  INNER JOIN SubCategories sc ON c.ParentID = sc.CategoryID
)
SELECT * FROM SubCategories;
```

### 슈퍼타입/서브타입 관계 (상속)

결제 수단(카드결제, 계좌이체)과 같은 일반화/특수화 관계를 모델링할 때 사용합니다. 주로 세 가지 방식을 고려합니다.

```sql
-- 방법: 공통 테이블 + 구체 테이블 (Class Table Inheritance)
CREATE TABLE Payment (
  PaymentID  BIGINT PRIMARY KEY,
  OrderID    BIGINT NOT NULL UNIQUE,
  Amount     NUMERIC(12,2) NOT NULL,
  PaidAt     TIMESTAMP NOT NULL
);

CREATE TABLE CardPayment (
  PaymentID  BIGINT PRIMARY KEY,
  CardNoHash TEXT NOT NULL,
  FOREIGN KEY (PaymentID) REFERENCES Payment(PaymentID) ON DELETE CASCADE
);

CREATE TABLE BankTransfer (
  PaymentID  BIGINT PRIMARY KEY,
  BankCode   TEXT NOT NULL,
  AccountNo  TEXT NOT NULL,
  FOREIGN KEY (PaymentID) REFERENCES Payment(PaymentID) ON DELETE CASCADE
);
```

### 시간적 관계

관계가 특정 기간 동안만 유효한 경우(예: 부서 배치 이력) 시작일과 종료일을 관계의 속성으로 포함시킵니다.

```sql
CREATE TABLE EmployeeDepartment (
  EmpID     BIGINT NOT NULL,
  DeptID    BIGINT NOT NULL,
  StartDate DATE   NOT NULL,
  EndDate   DATE   NULL, -- NULL은 '현재'를 의미
  PRIMARY KEY (EmpID, DeptID, StartDate),
  CHECK (EndDate IS NULL OR EndDate > StartDate),
  FOREIGN KEY (EmpID) REFERENCES Employee(EmpID),
  FOREIGN KEY (DeptID) REFERENCES Department(DeptID)
);
-- 기간이 겹치지 않도록 하는 강력한 제약은 DBMS별 특수 기능(예: PostgreSQL의 Exclusion Constraint)으로 구현 가능합니다.
```

---

## 삼항 이상의 관계와 설계 고려사항

### 삼항 관계의 필요성

의사, 환자, 진료일 이 세 엔터티가 조합되어 비로소 한 번의 ‘진료’ 의미를 완성하는 경우와 같이, **세 개 이상의 엔터티가 동시에 결합되어 하나의 사실을 정의**할 때 필요합니다.

```sql
-- 의사, 환자, 날짜가 결합되어 유일한 진료 기록을 정의
CREATE TABLE MedicalAppointment (
  DoctorID  BIGINT NOT NULL,
  PatientID BIGINT NOT NULL,
  Date      DATE   NOT NULL,
  Diagnosis TEXT,
  PRIMARY KEY (DoctorID, PatientID, Date), -- 삼항 복합키
  FOREIGN KEY (DoctorID)  REFERENCES Doctor(DoctorID),
  FOREIGN KEY (PatientID) REFERENCES Patient(PatientID)
);
```

**설계 시 고려사항**: 삼항 관계를 무조건 2개의 이항 관계로 분해하면, 원치 않는 조합(예: 동일한 의사와 환자이지만 다른 날짜의 예약이 여러 개 생기는 것)이 발생할 수 있습니다. 업무 규칙이 정확히 세 요소의 결합에 의존한다면 삼항 관계를 유지하는 것이 더 정확하고 안전합니다.

---

## 외래키 제약조건의 고급 활용

### ON DELETE 동작의 선택

- **CASCADE**: 주문 삭제 시 주문항목도 자동 삭제. 관리적 편의성은 높지만, 데이터 복구가 어려워 중요한 이력 데이터에는 위험할 수 있습니다.
- **SET NULL**: 부서 삭제 시 해당 부서 사원의 `DeptID`를 NULL로 설정. 데이터는 보존되지만 관계가 끊어집니다.
- **RESTRICT / NO ACTION**: 기본적인 안전장치입니다. 자식 데이터가 있는 부모는 삭제할 수 없어, 삭제 전 명시적인 정리 작업을 요구합니다.

### ON UPDATE 동작

기본키 변경은 드문 작업이므로, 대부분 `CASCADE`를 설정하거나 기본값(`NO ACTION`)을 유지합니다. 자연키를 기본키로 사용하는 경우 변경 가능성을 고려해야 하지만, 서로게이트 키 사용을 권장합니다.

---

## 기본키 전략: 자연키 vs 서로게이트 키

| 비교 항목 | 자연키 (업무 키) | 서로게이트 키 (대리 키) |
| :--- | :--- | :--- |
| **의미** | 주민등록번호, 이메일 등 업무적 의미 있음 | 순차번호, UUID 등 업무적 의미 없음 |
| **변경 가능성** | 업무 변화로 인해 변경 필요성 발생 가능 | 일반적으로 불변 |
| **장점** | 별도 인덱스 없이도 중복 방지가 직관적 | 변경에 안전하며, 조인과 마이그레이션이 단순 |
| **단점** | 개인정보 보호 이슈, 변경 시 파급효과 큼 | 반드시 별도의 업무 유일성(`UNIQUE`) 제약 필요 |

**실무 권장 사항**: 기본키는 **서로게이트 키**(예: `BIGSERIAL`, `UUID`)를 사용하고, 업무적으로 유일해야 하는 필드는 별도의 `UNIQUE` 제약을 두어 관리하는 패턴이 유연성과 안정성을 모두 확보합니다.

```sql
CREATE TABLE Product (
  ProductID BIGSERIAL PRIMARY KEY,   -- 서로게이트 키 (대리 키)
  Sku       TEXT NOT NULL UNIQUE,    -- 업무적으로 유일한 키 (자연 키)
  Name      TEXT NOT NULL
);
```

---

## 성능, 확장성, 운영을 고려한 관계 설계

### 인덱스 전략

- **외래키 컬럼 인덱스는 필수**: 외래키 제약 조건의 검사, 부모 테이블 삭제/수정 시의 성능, 그리고 역방향 조인 성능에 모두 영향을 미칩니다. 모든 외래키 컬럼에 인덱스를 생성하는 것을 원칙으로 합니다.
- **조인 테이블의 인덱스**: N:M 관계의 조인 테이블은 양쪽 외래키 조합으로 기본키를 구성하는 경우가 많지만, 반대 방향 조인을 위해 추가 인덱스를 고려할 수 있습니다.

```sql
-- 주문항목 테이블: (OrderID, ProductID)가 PK라면, ProductID 단독 조회를 위한 인덱스
CREATE INDEX idx_orderitem_product ON OrderItem(ProductID);
```

### 반정규화를 통한 성능 최적화

빈번한 조인으로 인한 성능 이슈가 있을 때, 자주 조회되는 부모 테이블의 컬럼을 자식 테이블에 복제하는 반정규화를 고려합니다.

```sql
-- 주문 테이블에 고객 이름을 반정규화하여 복제
ALTER TABLE "Order" ADD COLUMN CustomerName TEXT;

-- 고객 이름 변경 시, 관련된 모든 주문의 복제본을 갱신해야 함 (트리거, 애플리케이션 로직 등으로 관리)
```

**주의**: 반정규화는 데이터 중복과 동기화 오버헤드를 초래하므로, 명확한 성능 목표 하에 신중하게 적용해야 합니다.

---

## ORM에서의 관계 매핑과 주의점

### 매핑 기본

- **1:1**: `@OneToOne`
- **1:N / N:1**: `@OneToMany`, `@ManyToOne`
- **N:M**: `@ManyToMany` (가급적 추가 속성이 있는 조인 엔터티를 별도로 매핑하는 `@OneToMany`, `@ManyToOne` 방식 권장)

### 성능 문제: N+1 쿼리

즉시 로딩(`EAGER`)이나 지연 로딩(`LAZY`) 상태에서 컬렉션을 순회할 때 발생하는 문제입니다. **페치 조인**을 사용하여 사전에 필요한 데이터를 한 번의 쿼리로 가져오는 것이 해결책입니다.

```sql
-- 페치 조인 예시 (JPA JPQL)
SELECT o FROM Order o JOIN FETCH o.orderItems WHERE o.id = :id
```

### 다형성 관계

한 외래키가 여러 타입의 부모 테이블을 가리키는 패턴은 데이터베이스 차원에서 참조 무결성을 보장하기 어렵습니다. 가능하면 구체적인 외래키를 사용하거나, 조인 테이블을 도입하여 명확한 관계를 설계하는 것이 좋습니다.

---

## 관계 설계 품질 검증을 위한 테스트 시나리오

1. **무결성 테스트**: 존재하지 않는 부모 키를 가진 자식 데이터를 삽입하려 할 때 제약이 동작하는지 확인합니다.
2. **삭제 규칙 테스트**: `ON DELETE CASCADE`, `SET NULL`, `RESTRICT` 등이 의도대로 동작하는지 검증합니다.
3. **유일성 제약 테스트**: 1:1 관계나 N:M 관계에서 중복 연결이 불가능한지 확인합니다.
4. **옵셔널리티 테스트**: `NOT NULL` 제약이 있는 외래키에 `NULL`을 삽입할 수 없는지 확인합니다.
5. **성능 테스트**: 주요 조인 경로에 인덱스가 존재하는지, N+1 문제가 발생하지 않는지 점검합니다.
6. **시간적 관계 테스트**: 기간이 겹치는 데이터 삽입이 제약에 따라 적절히 거부되는지 확인합니다.

---

## 스키마 진화: 관계 변경 시의 안전한 마이그레이션

기존 관계를 변경해야 할 때(예: 1:N → N:M) 다음 단계를 따르는 것이 안전합니다.

1. **새 구조 병행 생성**: 새로운 테이블(조인 테이블)과 외래키를 생성합니다. 기존 외래키는 유지합니다.
2. **데이터 이관**: 기존 데이터를 새 구조로 이관하는 스크립트를 실행하고, 데이터 무결성을 검증합니다.
3. **애플리케이션 전환**:
   a. 읽기 로직을 새 구조로 먼저 전환합니다.
   b. 쓰기 로직을 새 구조로 전환합니다. (이중 쓰기 과정을 거칠 수 있음)
4. **구 구조 정리**: 모든 트래픽이 새 구조로 전환된 후, 예전 외래키 컬럼과 불필요한 제약을 제거합니다.

```sql
-- 1:N(개발자-프로젝트)에서 N:M으로 변경하는 마이그레이션 예시
-- 1단계: 새 조인 테이블 생성
CREATE TABLE DeveloperProject (
  DevID BIGINT NOT NULL,
  ProjID BIGINT NOT NULL,
  Role  TEXT,
  PRIMARY KEY (DevID, ProjID),
  FOREIGN KEY (DevID)  REFERENCES Developer(DevID),
  FOREIGN KEY (ProjID) REFERENCES Project(ProjID)
);

-- 2단계: 기존 Developer.ProjID 데이터를 새 테이블로 이관
INSERT INTO DeveloperProject (DevID, ProjID, Role)
SELECT DevID, ProjID, 'Lead' FROM Developer WHERE ProjID IS NOT NULL;

-- 3단계: 애플리케이션 코드 전환 후, 기존 컬럼 제거 (필요시)
-- ALTER TABLE Developer DROP COLUMN ProjID;
```

---

## 종합 예제: 전자상거래 시스템 관계 모델

다음은 고객, 주문, 상품, 결제 등 다양한 관계를 포함한 전자상거래 시스템의 핵심 스키마 예시입니다.

```sql
-- 고객
CREATE TABLE Customer (
  CustomerID  BIGSERIAL PRIMARY KEY,
  Email       TEXT NOT NULL UNIQUE,
  Name        TEXT NOT NULL,
  CreatedAt   TIMESTAMP NOT NULL DEFAULT NOW()
);

-- 주문 (1:N, Customer에 속함)
CREATE TABLE "Order" (
  OrderID     BIGSERIAL PRIMARY KEY,
  CustomerID  BIGINT NOT NULL,
  OrderedAt   TIMESTAMP NOT NULL DEFAULT NOW(),
  Status      TEXT NOT NULL CHECK (Status IN ('PENDING','PAID','CANCELLED')),
  FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID) ON DELETE RESTRICT
);
CREATE INDEX idx_order_customer ON "Order"(CustomerID);

-- 상품
CREATE TABLE Product (
  ProductID   BIGSERIAL PRIMARY KEY,
  Sku         TEXT NOT NULL UNIQUE,
  Name        TEXT NOT NULL,
  Price       NUMERIC(12,2) NOT NULL
);

-- 주문항목 (N:M between Order and Product, with attributes)
CREATE TABLE OrderItem (
  OrderID    BIGINT NOT NULL,
  ProductID  BIGINT NOT NULL,
  Qty        INT    NOT NULL CHECK (Qty > 0),
  PriceAt    NUMERIC(12,2) NOT NULL, -- 주문 당시 단가
  PRIMARY KEY (OrderID, ProductID),
  FOREIGN KEY (OrderID)   REFERENCES "Order"(OrderID)   ON DELETE CASCADE,
  FOREIGN KEY (ProductID) REFERENCES Product(ProductID) ON DELETE RESTRICT
);

-- 카테고리 계층 (재귀 관계)
CREATE TABLE Category (
  CategoryID BIGSERIAL PRIMARY KEY,
  Name       TEXT NOT NULL,
  ParentID   BIGINT,
  FOREIGN KEY (ParentID) REFERENCES Category(CategoryID) ON DELETE SET NULL
);

-- 상품-카테고리 다대다 관계
CREATE TABLE ProductCategory (
  ProductID  BIGINT NOT NULL,
  CategoryID BIGINT NOT NULL,
  PRIMARY KEY (ProductID, CategoryID),
  FOREIGN KEY (ProductID)  REFERENCES Product(ProductID)  ON DELETE CASCADE,
  FOREIGN KEY (CategoryID) REFERENCES Category(CategoryID) ON DELETE RESTRICT
);

-- 결제 (슈퍼타입/서브타입 관계)
CREATE TABLE Payment (
  PaymentID  BIGSERIAL PRIMARY KEY,
  OrderID    BIGINT NOT NULL UNIQUE,
  Amount     NUMERIC(12,2) NOT NULL,
  PaidAt     TIMESTAMP NOT NULL,
  Method     TEXT NOT NULL CHECK (Method IN ('CARD','BANK')),
  FOREIGN KEY (OrderID) REFERENCES "Order"(OrderID) ON DELETE CASCADE
);
CREATE TABLE CardPayment (
  PaymentID  BIGINT PRIMARY KEY REFERENCES Payment(PaymentID) ON DELETE CASCADE,
  CardNoHash TEXT NOT NULL
);
CREATE TABLE BankPayment (
  PaymentID  BIGINT PRIMARY KEY REFERENCES Payment(PaymentID) ON DELETE CASCADE,
  BankCode   TEXT NOT NULL,
  AccountNo  TEXT NOT NULL
);
```

### 대표적인 분석 질의

```sql
-- 1) 특정 고객의 최근 주문과 총액 조회
SELECT o.OrderID, o.OrderedAt, SUM(oi.Qty * oi.PriceAt) AS TotalAmount
FROM "Order" o
JOIN OrderItem oi ON oi.OrderID = o.OrderID
WHERE o.CustomerID = 501
GROUP BY o.OrderID, o.OrderedAt
ORDER BY o.OrderedAt DESC
LIMIT 10;

-- 2) 특정 카테고리 및 그 모든 하위 카테고리의 상품 조회 (재귀 CTE)
WITH RECURSIVE SubCategories AS (
  SELECT CategoryID FROM Category WHERE CategoryID = 10 -- '전자제품' 카테고리
  UNION ALL
  SELECT c.CategoryID
  FROM Category c
  INNER JOIN SubCategories s ON c.ParentID = s.CategoryID
)
SELECT p.ProductID, p.Name, p.Price
FROM Product p
JOIN ProductCategory pc ON p.ProductID = pc.ProductID
WHERE pc.CategoryID IN (SELECT CategoryID FROM SubCategories);

-- 3) 가장 인기 있는 상품 태그 조회 (N:M 관계 분석)
SELECT t.Name, COUNT(*) AS PurchaseCount
FROM OrderItem oi
JOIN ProductTag pt ON oi.ProductID = pt.ProductID
JOIN Tag t ON pt.TagID = t.TagID
GROUP BY t.TagID, t.Name
ORDER BY PurchaseCount DESC
LIMIT 5;
```

---

## 결론: 견고한 관계 설계를 위한 원칙

데이터베이스 관계 설계는 단순한 기술적 구현을 넘어, **비즈니스의 본질을 정확히 포착하고 미래의 변화에 유연하게 대응할 수 있는 구조**를 만드는 작업입니다.

1.  **업무 규칙을 우선하라**: 관계의 카디널리티와 옵셔널리티는 비즈니스 요구사항에서 비롯되어야 하며, 이를 `NOT NULL`, `UNIQUE`, 외래키 제약 등으로 정확히 구현해야 합니다.
2.  **복잡성과 유연성의 균형을 찾아라**: 식별자 관계의 강력함과 비식별자 관계의 유연함 사이에서, 서로게이트 키의 편리함과 자연키의 직관성 사이에서 상황에 맞는 최선의 선택을 해야 합니다.
3.  **성능과 무결성을 함께 설계하라**: 모든 외래키에 인덱스를 생성하는 것처럼 기본적인 성능 원칙을 지키고, `ON DELETE` 정책을 데이터의 수명 주기와 비즈니스 중요도에 따라 신중하게 선택해야 합니다.
4.  **특수 관계 패턴을 이해하라**: 재귀, 상속, 시간적 관계 등은 일반적인 1:N, N:M 관계보다 더 주의 깊은 모델링을 요구합니다. 패턴을 알고 적절히 적용하면 복잡한 현실 세계를 더 잘 표현할 수 있습니다.
5.  **변화를 예상하라**: 관계는 비즈니스와 함께 진화합니다. 조인 테이블의 도입, 반정규화, 안전한 마이그레이션 경로 등은 변화에 대비한 설계의 일부입니다.

궁극적으로 훌륭한 관계 설계는 데이터의 정확성, 시스템의 성능, 그리고 개발과 운영의 편의성을 동시에 지탱하는 토대가 됩니다. 이 문서에서 논의된 개념과 패턴은 그러한 토대를 마련하는 데 실질적인 도움이 될 것입니다.