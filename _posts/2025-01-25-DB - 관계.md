---
layout: post
title: DB - 관계
date: 2025-01-25 22:20:23 +0900
category: DB
---
# 🔗 관계(Relationship) – 엔터티 간의 연결

## 📌 1. 관계란?

**관계(Relationship)**는 두 개 이상의 엔터티(Entity) 사이에 존재하는 **업무적 연관성**을 의미합니다.  
현실 세계에서 "고객은 주문을 한다", "학생은 수강한다"처럼 **엔터티 간 동사형 연결**이 데이터 모델링 상에서는 관계로 표현됩니다.

---

## 🧱 2. 관계의 구성 요소

| 구성 요소 | 설명 |
|-----------|------|
| **관계명** | 현실 세계의 동사로 표현, ‘~한다’ 식으로 명확히 |
| **카디널리티(Cardinality)** | 한 엔터티가 다른 엔터티와 맺을 수 있는 관계의 수(최소/최대 참여수) |
| **옵셔널리티(Optionality)** | 관계가 **필수(Mandatory)**인지, **선택(Optional)**인지 |
| **외래키(Foreign Key)** | 관계를 물리적으로 구현하기 위한 수단 (항상 ‘N쪽’에 위치) |

---

## 🔢 3. 관계의 종류

### 3-1. 참여 수(카디널리티)에 따른 분류

| 종류 | 설명 | 예시 |
|------|------|------|
| **1:1 (일대일)** | 하나의 인스턴스가 다른 하나와만 연결 | 주민 ↔ 주민등록증 |
| **1:N (일대다)** | 하나의 인스턴스가 여러 개와 연결 | 고객 ↔ 주문 |
| **N:M (다대다)** | 서로 여러 인스턴스와 연결 가능 → 반드시 별도 테이블로 분해 | 학생 ↔ 강의 |

> 💡 N:M 관계는 반드시 **중간 조인 테이블**로 분해되어 1:N + 1:N 관계로 설계되어야 합니다.

### 3-2. 존재성과 행위성에 따른 분류

| 분류 | 설명 | 예시 |
|------|------|------|
| **존재 관계** | 존재 자체에 의존하는 관계 | 직원은 부서에 소속된다 |
| **행위 관계** | 어떤 행위를 통해 형성된 관계 | 학생은 수강한다, 고객은 주문한다 |

---

## 🔍 4. 관계의 디그리 (Degree)

| 차수 | 설명 | 예시 |
|------|------|------|
| **Binary** | 2개의 엔터티 간 관계 | 고객 ↔ 주문 |
| **Ternary** | 3개 엔터티가 동시에 관여 | 의사 ↔ 환자 ↔ 진료일 |
| **n-ary** | 3개 이상 엔터티 간 복합 관계 | 프로젝트 ↔ 직원 ↔ 역할 ↔ 기간 |

> 💡 실무에선 대부분 Binary로 분해하여 구현함. Ternary는 개념 설계 단계에서만 등장.

---

## 🧾 5. 관계의 구현 방식

### (1) 식별자 관계 (Identifying Relationship)

- 부모 엔터티의 기본키(PK)가 자식 엔터티의 기본키에 포함됨 → **복합키 형성**
- 자식은 부모의 존재 없이는 존재할 수 없음 (**강한 결합**)

```sql
CREATE TABLE CourseDetail (
  CourseID INT,
  StudentID INT,
  PRIMARY KEY (CourseID, StudentID),
  FOREIGN KEY (CourseID) REFERENCES Course(CourseID)
);
```

> 📌 약 엔터티(Weak Entity) 구성 시 식별자 관계가 주로 사용됨.

---

### (2) 비식별자 관계 (Non-Identifying Relationship)

- 부모 엔터티의 PK는 자식 엔터티의 일반 속성(FK)으로만 존재
- 자식이 독립된 기본키를 가짐 → **약한 결합**

```sql
CREATE TABLE Order (
  OrderID INT PRIMARY KEY,
  CustomerID INT,
  FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID)
);
```

---

### (3) 다대다(N:M) 관계 해소 예시

- `학생(Student)`과 `과목(Course)` 사이의 관계는 다대다
- 이를 `수강(StudentCourse)` 엔터티로 해소하고 공유 속성(예: 수강일자, 성적 등)을 포함

```sql
CREATE TABLE StudentCourse (
  StudentID INT,
  CourseID INT,
  EnrollDate DATE,
  Score INT,
  PRIMARY KEY (StudentID, CourseID),
  FOREIGN KEY (StudentID) REFERENCES Student(StudentID),
  FOREIGN KEY (CourseID) REFERENCES Course(CourseID)
);
```

---

## 📌 6. ERD에서의 관계 표기법

### Crow's Foot Notation

| 기호 | 의미 |
|------|------|
| ○ | 0 (선택 가능) |
| | | 1 (필수) |
| |< | 다수 (Many) |

- `○——<` : 0 이상 N (옵셔널 다수)
- `|——<` : 1 이상 N (필수 다수)

### IE Notation (Information Engineering)

- (0,1), (1,1), (0,N), (1,N)으로 표기
- 첫 번째 숫자는 최소 참여 수, 두 번째 숫자는 최대 참여 수

---

## 🔐 7. 외래키 제약 조건 (ON DELETE / ON UPDATE)

| 옵션 | 설명 | 예시 |
|------|------|------|
| **CASCADE** | 부모 삭제 시 자식도 같이 삭제 | 고객 삭제 시 주문도 삭제 |
| **SET NULL** | 부모 삭제 시 자식의 FK를 NULL로 설정 | 주문만 남김 |
| **RESTRICT / NO ACTION** | 부모 삭제 시 자식이 있으면 거부 | 참조 무결성 위반 방지 |

```sql
FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID)
  ON DELETE CASCADE
  ON UPDATE CASCADE;
```

---

## 🧭 8. 관계 설계 시 주의사항

| 항목 | 내용 |
|------|------|
| FK는 항상 다(N)쪽에 위치해야 함 |
| 다대다 관계는 반드시 중간 엔터티로 분해해야 함 |
| 공유 속성이 있는 관계는 **조인 테이블이 실질적 엔터티**가 됨 |
| 관계명은 **명확한 동사형** 또는 업무 용어로 표현 |
| **관계의 방향성, 필수성, 최대성** 모두 고려해서 설계 |
| 관계명은 중립적이지 않도록 (예: '연결됨' ❌, '담당한다' ✅) |
| 관계는 물리적으로는 외래키(FK)로 구현되지만, 논리적으로는 비즈니스 규칙을 기반으로 설계해야 함 |

---

## ⚠️ 혼동 주의: "카디널리티"의 두 가지 의미

1. 관계형 모델에서의 **카디널리티**: 엔터티 간 관계 수 (1:1, 1:N, N:M)
2. DBMS에서의 **속성 카디널리티**: 컬럼 내 서로 다른 값의 개수 (예: 유니크 정도)

> 문맥에 따라 의미가 다르므로 항상 용어 사용에 주의할 것

---

## ✅ 정리

- 관계는 **업무적으로 의미 있는 엔터티 간 연결**
- 참여 수, 필수성, 방향성, FK 구조를 명확히 고려하여 설계
- N:M 관계는 반드시 조인 테이블로 분리
- 관계명, 카디널리티, 관계 유형, FK 제약 등 실무적 디테일까지 반드시 고려
- ERD 표기법(Crow’s Foot, IE) 차이도 알아두면 협업 시 유리

> 관계 설계는 단순히 연결하는 것이 아니라, **데이터 무결성과 처리 효율성, 의미론적 정확성**까지 반영해야 하는 **핵심 논리 구조**입니다.