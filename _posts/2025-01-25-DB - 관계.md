---
layout: post
title: DB - 관계
date: 2025-01-25 22:20:23 +0900
category: DB
---
# 관계(Relationship)

## 0. 리마인드: 핵심 요약(기존 내용에서 뽑은 핵심)

- **관계**는 엔터티 간 **업무적 연관성**이며, **관계명·카디널리티(최소/최대 참여)·옵셔널리티·외래키**로 정의/구현된다.
- **1:1 / 1:N / N:M**: N:M은 반드시 **조인 테이블**로 분해(1:N + 1:N).
- **식별자 관계**: 부모 PK가 자식 PK에 포함(복합키), 강한 결합.  
  **비식별자 관계**: 자식 PK는 독립, 부모 PK는 자식의 일반 FK(약 결합).
- **FK 제약 ON DELETE/UPDATE**: CASCADE/SET NULL/RESTRICT(NO ACTION) 등으로 참조 무결성 보장.
- **ER 표기**: Crow’s Foot, IE Notation 등(최소/최대 참여 수 표현).
- **주의**: FK는 항상 **다(N)쪽**에, **공유 속성**이 있으면 조인 테이블이 실질 엔터티가 됨, **용어 ‘카디널리티’**는 맥락 구분.

이제 이를 바탕으로, 실무적 함정·패턴·예제·테스트까지 촘촘하게 확장한다.

---

## 1. 카디널리티·옵셔널리티 정밀화

### 1.1 최소·최대 참여수의 의미(업무 규칙과 동기화)
- **최소 참여수(0 또는 1)**: 레코드가 생성·유지되기 위해 **반드시** 다른 엔터티에 연결되어야 하는가?  
  예) “주문은 고객 없이 존재할 수 있는가?” → 대부분 **아니오(1)**.
- **최대 참여수(1 또는 N)**: 한쪽의 인스턴스가 상대측 몇 개와 연결 가능한가?  
  예) “한 고객은 여러 주문을 가질 수 있는가?” → **예(N)**.

### 1.2 DB 제약으로 옮기기
- 최소 참여수 1을 **DB로 강제**하려면 FK 컬럼 **NOT NULL** + **RESTRICT/NO ACTION**가 필요.
- 최소 참여수 0은 FK가 **NULL 가능**이어야 하며, 비즈니스 규칙에 따라 **유일성 제약**(예: 1:1의 반대편)에 주의한다.

```sql
-- 고객(1) : 주문(N) = 1:N, 주문은 고객이 반드시 존재(최소=1)
CREATE TABLE Customer (
  CustomerID BIGINT PRIMARY KEY,
  Name       TEXT NOT NULL
);

CREATE TABLE "Order" (
  OrderID     BIGINT PRIMARY KEY,
  CustomerID  BIGINT NOT NULL,
  OrderDate   TIMESTAMP NOT NULL,
  FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID)
    ON DELETE RESTRICT
    ON UPDATE CASCADE
);
```

---

## 2. 1:1 관계 설계 패턴

### 2.1 언제 1:1이 필요한가
- 엔터티를 **물리적 분리**(민감정보/접근권한/변경주기/성능)하고 싶을 때.
- “사용자”와 “사용자상세프로필”처럼 갱신 빈도/보안 등급이 다른 경우.

### 2.2 구현 패턴 A: 강제적 1:1(식별자 관계)
- 상세 테이블의 PK=FK(부모 PK를 재사용).  
- **장점**: 1:1을 DB가 강하게 보장.  
- **단점**: 확장 유연성이 떨어질 수 있음.

```sql
CREATE TABLE UserAccount (
  UserID BIGINT PRIMARY KEY,
  Email  TEXT NOT NULL UNIQUE
);

-- UserProfile의 PK가 UserID이자 FK
CREATE TABLE UserProfile (
  UserID BIGINT PRIMARY KEY,
  Phone  TEXT,
  Birth  DATE,
  FOREIGN KEY (UserID) REFERENCES UserAccount(UserID)
    ON DELETE CASCADE -- 사용자 삭제 시 프로필도 삭제
);
```

### 2.3 구현 패턴 B: 선택적 1:1(비식별자 + 유니크 FK)
- 상세 테이블의 PK는 독립, FK는 **UNIQUE**로 1:1에 준하는 제약을 부여.
- 상세 레코드가 **없을 수도** 있는 경우(옵셔널) 유리.

```sql
CREATE TABLE UserProfile2 (
  ProfileID BIGSERIAL PRIMARY KEY,
  UserID    BIGINT UNIQUE,  -- 한 사용자당 최대 1개의 프로필
  Phone     TEXT,
  FOREIGN KEY (UserID) REFERENCES UserAccount(UserID)
    ON DELETE SET NULL      -- 프로필만 남기고 사용자 FK NULL
);
```

**비교 포인트**  
- **PK=FK** 방식은 “항상 존재해야 하는 1:1”에 강력.  
- **UNIQUE FK** 방식은 선택적 1:1과 지연 생성에 유연.

---

## 3. 1:N 관계 고급 설계

### 3.1 비즈니스 규칙별 FK 전략
- **삭제 규칙**: 고객 삭제 시 주문은?  
  - **RESTRICT**: 안전(실수 방지), 단 “삭제 전 이관/정리”가 필요.  
  - **CASCADE**: 일괄 정리 편리하지만 **감사/회계 이슈** 주의.  
  - **SET NULL**: 주문 잔존 허용(익명화/보관), 다만 **NOT NULL** 규칙과 충돌하지 않게 설계.

### 3.2 예시: 이력 보존을 위한 소프트 삭제 + FK 유지
```sql
ALTER TABLE Customer ADD COLUMN IsDeleted BOOLEAN NOT NULL DEFAULT FALSE;

-- 실제 삭제 대신 업데이트
UPDATE Customer SET IsDeleted = TRUE WHERE CustomerID = 101;

-- 주문은 그대로 유지. 조회 시 항상 IsDeleted = FALSE 필터링.
```

### 3.3 인덱스·성능
- 1:N 조인은 “N쪽 FK 컬럼 인덱스”가 필수.
- 반대 방향(부모→자식 집계)도 FK 인덱스가 유리.

```sql
CREATE INDEX idx_order_customer ON "Order"(CustomerID);
```

---

## 4. N:M(다대다) 해소 고급: 조인 테이블의 “엔터티화”

### 4.1 “행위”와 “상태”를 담는 조인 테이블
- 학생–과목의 **수강** 관계: “수강일자/성적/상태/시작·종료일” 등의 **업무 속성** 포함 → 단순 연결을 넘어 **명확한 엔터티**.

```sql
CREATE TABLE Student (
  StudentID BIGINT PRIMARY KEY,
  Name      TEXT NOT NULL
);

CREATE TABLE Course (
  CourseID BIGINT PRIMARY KEY,
  Title    TEXT NOT NULL
);

CREATE TABLE StudentCourse (
  StudentID  BIGINT NOT NULL,
  CourseID   BIGINT NOT NULL,
  EnrollDate DATE   NOT NULL,
  Grade      TEXT,
  Status     TEXT CHECK (Status IN ('ENROLLED','DROPPED','COMPLETED')),
  PRIMARY KEY (StudentID, CourseID),
  FOREIGN KEY (StudentID) REFERENCES Student(StudentID)
    ON DELETE CASCADE,
  FOREIGN KEY (CourseID)  REFERENCES Course(CourseID)
    ON DELETE RESTRICT
);

CREATE INDEX idx_sc_course ON StudentCourse(CourseID);
CREATE INDEX idx_sc_status ON StudentCourse(Status);
```

### 4.2 N:M에 유일성·비즈니스 제약 넣기
- 동일 학생이 동일 과목을 **중복 수강 금지**: `(StudentID, CourseID)` **PK/UNIQUE**로 강제.
- 재수강을 허용한다면, **시점/회차 컬럼**을 키에 포함해 유니크 제약을 조정.

```sql
-- 재수강 허용(회차 포함 키)
CREATE TABLE StudentCourse2 (
  StudentID  BIGINT NOT NULL,
  CourseID   BIGINT NOT NULL,
  AttemptNo  INT    NOT NULL,
  EnrollDate DATE   NOT NULL,
  PRIMARY KEY (StudentID, CourseID, AttemptNo)
);
```

---

## 5. 식별자 관계 vs 비식별자 관계: 선택 기준

| 구분 | 식별자 관계 | 비식별자 관계 |
|---|---|---|
| 키 구조 | 부모 PK가 자식 PK에 포함(복합키) | 자식 PK 독립, 부모 PK는 FK |
| 결합 정도 | 강함(부모 없이는 자식 불가) | 약함(자식 독립성 가능) |
| 장점 | 1:1/약 엔터티 모델링에 강력 | 유연한 확장, 마이그레이션 용이 |
| 단점 | 복합키 전파로 하위 조인이 무거워질 수 있음 | 1:1 강제는 별도 UNIQUE 등 추가 필요 |
| 권장 | 진짜로 부모 없이는 존재 불가한 약 엔터티 | 대부분의 일반 관계(1:N, N:M) |

**실무 팁**:  
- 지나친 복합키 전파는 ORM/쿼리/인덱스 관리 비용을 키운다.  
- **서로게이트 키(PK)** + **FK로 연결**하고, 업무 유일성은 **UNIQUE** 제약으로 관리하는 방식이 유지보수에 유리한 경우가 많다.

---

## 6. 재귀(자기) 관계, 슈퍼타입/서브타입, 템포럴 관계

### 6.1 재귀 관계(조직도·카테고리 트리)
```sql
CREATE TABLE Category (
  CategoryID   BIGINT PRIMARY KEY,
  Name         TEXT NOT NULL,
  ParentID     BIGINT NULL,
  FOREIGN KEY (ParentID) REFERENCES Category(CategoryID)
    ON DELETE SET NULL
);

-- 경로 쿼리(CTE)
WITH RECURSIVE path AS (
  SELECT CategoryID, Name, ParentID, 1 AS depth
  FROM Category WHERE CategoryID = 100
  UNION ALL
  SELECT c.CategoryID, c.Name, c.ParentID, p.depth + 1
  FROM Category c
  JOIN path p ON c.ParentID = p.CategoryID
)
SELECT * FROM path;
```

### 6.2 슈퍼타입/서브타입(상속)
- 설계 옵션  
  1) **단일 테이블(Discriminator)**  
  2) **클래스별 테이블**(공통키 공유)  
  3) **구체 클래스별 독립 테이블**
- 관계 설계 시, FK의 목표 테이블이 **다형성**을 띨 수 있음(ORM의 “Polymorphic Association” 주의).

```sql
-- 클래스별 테이블 예시
CREATE TABLE Payment (
  PaymentID  BIGINT PRIMARY KEY,
  Amount     NUMERIC(12,2) NOT NULL,
  PaidAt     TIMESTAMP NOT NULL
);

CREATE TABLE CardPayment (
  PaymentID  BIGINT PRIMARY KEY REFERENCES Payment(PaymentID) ON DELETE CASCADE,
  CardNoHash TEXT NOT NULL
);

CREATE TABLE BankTransfer (
  PaymentID  BIGINT PRIMARY KEY REFERENCES Payment(PaymentID) ON DELETE CASCADE,
  BankCode   TEXT NOT NULL,
  AccountNo  TEXT NOT NULL
);
```

### 6.3 템포럴(유효기간) 관계
- “특정 기간에만 속함”을 관계 속성으로 관리: **시작일·종료일** 포함, **기간 겹침 금지** 제약.

```sql
CREATE TABLE EmployeeDepartment (
  EmpID     BIGINT NOT NULL,
  DeptID    BIGINT NOT NULL,
  StartDate DATE   NOT NULL,
  EndDate   DATE   NULL,
  PRIMARY KEY (EmpID, DeptID, StartDate),
  CHECK (EndDate IS NULL OR EndDate > StartDate),
  FOREIGN KEY (EmpID) REFERENCES Employee(EmpID),
  FOREIGN KEY (DeptID) REFERENCES Department(DeptID)
);

/* 기간 겹침 금지(서로 배타) 보장은 DB마다 Exclusion Constraint 등 기능 필요(PostgreSQL):
   EXCLUDE USING GIST (EmpID WITH =, daterange(StartDate, COALESCE(EndDate, 'infinity')) WITH &&)
*/
```

---

## 7. 삼항(Ternary)·n-항 관계 다루기

### 7.1 언제 필요한가
- “의사–환자–진료일” 같이 **세 개 이상 엔터티가 동시에** 의미를 갖는 경우.
- 대부분은 **Binary**로 분해 가능하지만, **업무 규칙이 세 항의 결합에 의존**하면 삼항 유지가 더 명확.

```sql
-- 의사-환자-날짜가 함께 유일
CREATE TABLE Visit (
  DoctorID BIGINT NOT NULL,
  PatientID BIGINT NOT NULL,
  VisitDate DATE NOT NULL,
  PRIMARY KEY (DoctorID, PatientID, VisitDate),
  FOREIGN KEY (DoctorID) REFERENCES Doctor(DoctorID),
  FOREIGN KEY (PatientID) REFERENCES Patient(PatientID)
);
```

**주의**: Binary로 과도 분해하면 **허용되지 않아야 할 조합**이 생길 수 있다. 업무 제약이 **세 항 결합**에 달려 있으면 삼항을 유지하고 **복합 키/유일성**으로 보장한다.

---

## 8. 옵셔널리티·필수성의 DB 구현 포인트

| 요구 | 구현 |
|---|---|
| 필수 관계(최소=1) | FK 컬럼 NOT NULL + 부모 삭제 RESTRICT/NO ACTION |
| 선택 관계(최소=0) | FK 컬럼 NULL 허용 + 업무 규칙에 맞는 삭제 동작(SET NULL/RESTRICT) |
| 1:1 엄격 보장 | PK=FK 또는 UNIQUE FK |
| 1:1 선택 허용 | UNIQUE FK + FK NULL 허용 |

---

## 9. FK 제약의 고급 사용(ON DELETE/UPDATE)

### 9.1 ON DELETE
- **CASCADE**: 부모 삭제 시 자식 자동 삭제.  
  백오피스/테스트엔 편리하지만, **감사·법적 보관**이 필요한 도메인에서는 위험.
- **SET NULL**: FK만 비움(레코드는 유지). **NOT NULL** 규칙과 충돌하지 않도록 설계.
- **RESTRICT/NO ACTION**: 안전하지만, 삭제 작업 전 **정리 프로세스** 필요.

### 9.2 ON UPDATE
- PK 변경이 잦지 않다면 **CASCADE 필요성 낮음**.  
  자연키를 PK로 쓸 경우에는 유의(대부분 **서로게이트 키** 추천).

---

## 10. 키 전략: 자연키 vs 서로게이트 키

| 항목 | 자연키(업무키) | 서로게이트 키(대리키) |
|---|---|---|
| 의미 | 업무상 의미를 가진 키(예: 주민번호) | 무의미 숫자/UUID |
| 변경 가능성 | 업무 변화에 따라 변경 가능 | 일반적으로 불변 |
| 장점 | 중복 방지에 직관적 | 조인 단순, 변경 안전, 마이그레이션 쉬움 |
| 단점 | 변경/마스킹/민감 정보 이슈 | 추가 유니크 제약 필요 |

**실무 권장**: PK는 대리키, 업무 유일성은 **UNIQUE**로 별도 보장.

```sql
CREATE TABLE Product (
  ProductID BIGSERIAL PRIMARY KEY,   -- 대리키
  Sku       TEXT NOT NULL UNIQUE,    -- 업무 유일성
  Name      TEXT NOT NULL
);
```

---

## 11. 인덱스·조인·락과 관계

### 11.1 인덱스
- FK 컬럼에 인덱스가 없으면 **삭제/업데이트 시 참조 스캔**으로 느려짐.
- 조인 빈도 높은 FK 컬럼은 **필수적으로 인덱스**.

```sql
CREATE INDEX idx_order_customer ON "Order"(CustomerID);
```

### 11.2 조인 전략
- 1:N에서 N쪽을 먼저 필터링(선택도 높이면 유리).
- N:M에서는 조인 테이블을 **드라이빙**(선필터)하고 양쪽을 붙이는 패턴이 흔함.

### 11.3 락과 외래키
- 부모 삭제 시 자식 존재 검사 → FK 인덱스 없으면 **락 확장 + 테이블 스캔**.  
- **배치 삭제/정리**는 작은 청크 단위로, FK 인덱스와 함께 처리.

---

## 12. 반정규화와 관계

### 12.1 반정규화의 동기
- 조인 비용 절감(핫 경로), 캐시 친화 구조, 보고서용 집계 안정화.
- **중복/동기화 비용**과 교환.

### 12.2 패턴
- 자주 조회하는 **부모의 일부 속성**을 자식에 복제(예: Customer.Name → Order.CustomerNameCopy).
- **검증 규칙**: 원본 변경 시 동기화 트리거/잡/이벤트로 보장.

```sql
ALTER TABLE "Order" ADD COLUMN CustomerNameCopy TEXT;

-- 예시: 트리거(데이터베이스별 문법 상이)
-- 원본(Customer.Name) 변경시 Order.CustomerNameCopy 업데이트
```

---

## 13. ORM 관점의 관계

### 13.1 매핑 기본
- 1:1 → `OneToOne`  
- 1:N → `OneToMany/ManyToOne`  
- N:M → `ManyToMany`(조인 엔터티 권장: 추가 속성 담기 쉬움)

### 13.2 지연로딩/즉시로딩
- 즉시로딩(EAGER)은 N+1 폭발의 원인.  
- 기본은 지연( LAZY ) + **페치 조인**/전용 조회 API로 컨트롤.

```sql
-- 페치 조인 예(ORM이 생성하는 SQL과 유사)
SELECT o.*, c.*
FROM "Order" o
JOIN Customer c ON c.CustomerID = o.CustomerID
WHERE o.OrderID = 10001;
```

### 13.3 다형성 관계(폴리모픽)
- 하나의 FK가 여러 타입을 가리키는 패턴은 **DB 차원**에서 제약이 느슨해짐.  
- 가능한 한 **명확한 FK**를 유지하거나, **조인 테이블**로 정규화.

---

## 14. 테스트 시나리오(관계의 품질 보증)

1) **FK 무결성**: 부모 없는 자식 삽입 금지, 삭제 규칙 검증.  
2) **옵셔널리티**: NULL 허용/불허 제약 준수.  
3) **유일성/키 제약**: 중복 연결 금지(예: 학생-과목 중복 수강).  
4) **성능**: FK 인덱스 유무로 삭제/조인 속도 비교.  
5) **경합/락**: 대량 삭제/갱신 시 락 대기/타임아웃 발생 여부.  
6) **템포럴**: 기간 겹침 방지 제약 검증(회귀 테스트).  
7) **ORM**: N+1 발생 여부, 페치 전략 슬라이싱.

---

## 15. 마이그레이션 전략(관계 변경)

### 15.1 순서
1) **새 스키마 병행 도입**(FK/인덱스/제약 포함)  
2) **데이터 이관**(검증 쿼리로 카운트/합 일치 확인)  
3) **서비스 코드 스위치**(읽기→쓰기 순)  
4) **구 스키마 제거**

### 15.2 예: 1:N → N:M로 변경(요구 사양 변경)
- 기존: “개발자–프로젝트”가 1:N이었는데, 다중 소속 허용으로 N:M 필요.
- 조인 테이블 신설, 기존 FK는 **NULL 허용**으로 전환 후 점진 이관.

```sql
CREATE TABLE DeveloperProject (
  DevID BIGINT NOT NULL,
  ProjID BIGINT NOT NULL,
  Role  TEXT,
  PRIMARY KEY (DevID, ProjID),
  FOREIGN KEY (DevID)  REFERENCES Developer(DevID),
  FOREIGN KEY (ProjID) REFERENCES Project(ProjID)
);

-- 기존 Developer(ProjID) 컬럼은 Deprecated -> 이관 후 제거
```

---

## 16. 사례 기반 종합 예제

### 16.1 도메인
- 고객(Customer), 주문(Order), 상품(Product), 주문항목(OrderItem), 카테고리(Category, 재귀), 태그(Tag, N:M), 지불(Payment, 서브타입), 쿠폰(Coupon, 템포럴), 사용자–권한(User–Role, N:M)

### 16.2 스키마(요약)
```sql
CREATE TABLE Customer (
  CustomerID  BIGSERIAL PRIMARY KEY,
  Email       TEXT NOT NULL UNIQUE,
  Name        TEXT NOT NULL,
  CreatedAt   TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE "Order" (
  OrderID     BIGSERIAL PRIMARY KEY,
  CustomerID  BIGINT NOT NULL,
  OrderedAt   TIMESTAMP NOT NULL DEFAULT NOW(),
  Status      TEXT NOT NULL CHECK (Status IN ('PENDING','PAID','CANCELLED')),
  FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID) ON DELETE RESTRICT
);

CREATE INDEX idx_order_customer ON "Order"(CustomerID);

CREATE TABLE Product (
  ProductID   BIGSERIAL PRIMARY KEY,
  Sku         TEXT NOT NULL UNIQUE,
  Name        TEXT NOT NULL,
  Price       NUMERIC(12,2) NOT NULL
);

CREATE TABLE OrderItem (
  OrderID    BIGINT NOT NULL,
  ProductID  BIGINT NOT NULL,
  Qty        INT    NOT NULL CHECK (Qty > 0),
  PriceAt    NUMERIC(12,2) NOT NULL,
  PRIMARY KEY (OrderID, ProductID),
  FOREIGN KEY (OrderID)   REFERENCES "Order"(OrderID)   ON DELETE CASCADE,
  FOREIGN KEY (ProductID) REFERENCES Product(ProductID) ON DELETE RESTRICT
);

-- 카테고리(재귀)
CREATE TABLE Category (
  CategoryID BIGSERIAL PRIMARY KEY,
  Name       TEXT NOT NULL,
  ParentID   BIGINT,
  FOREIGN KEY (ParentID) REFERENCES Category(CategoryID) ON DELETE SET NULL
);

-- 상품-카테고리(N:M -> 조인 엔터티)
CREATE TABLE ProductCategory (
  ProductID  BIGINT NOT NULL,
  CategoryID BIGINT NOT NULL,
  PRIMARY KEY (ProductID, CategoryID),
  FOREIGN KEY (ProductID)  REFERENCES Product(ProductID)  ON DELETE CASCADE,
  FOREIGN KEY (CategoryID) REFERENCES Category(CategoryID) ON DELETE RESTRICT
);

-- 태그(N:M)
CREATE TABLE Tag (
  TagID  BIGSERIAL PRIMARY KEY,
  Name   TEXT NOT NULL UNIQUE
);
CREATE TABLE ProductTag (
  ProductID BIGINT NOT NULL,
  TagID     BIGINT NOT NULL,
  PRIMARY KEY (ProductID, TagID),
  FOREIGN KEY (ProductID) REFERENCES Product(ProductID) ON DELETE CASCADE,
  FOREIGN KEY (TagID)     REFERENCES Tag(TagID)         ON DELETE CASCADE
);

-- 결제(슈퍼/서브타입)
CREATE TABLE Payment (
  PaymentID  BIGSERIAL PRIMARY KEY,
  OrderID    BIGINT NOT NULL UNIQUE,
  Amount     NUMERIC(12,2) NOT NULL,
  PaidAt     TIMESTAMP NOT NULL,
  Method     TEXT NOT NULL CHECK (Method IN ('CARD','BANK')),
  FOREIGN KEY (OrderID) REFERENCES "Order"(OrderID) ON DELETE CASCADE
);

CREATE TABLE CardPayment (
  PaymentID  BIGINT PRIMARY KEY REFERENCES Payment(PaymentID) ON DELETE CASCADE,
  CardNoHash TEXT NOT NULL
);

CREATE TABLE BankPayment (
  PaymentID  BIGINT PRIMARY KEY REFERENCES Payment(PaymentID) ON DELETE CASCADE,
  BankCode   TEXT NOT NULL,
  AccountNo  TEXT NOT NULL
);

-- 쿠폰(템포럴)
CREATE TABLE Coupon (
  CouponID   BIGSERIAL PRIMARY KEY,
  Code       TEXT NOT NULL UNIQUE,
  Discount   NUMERIC(12,2) NOT NULL,
  StartAt    TIMESTAMP NOT NULL,
  EndAt      TIMESTAMP NOT NULL CHECK (EndAt > StartAt)
);

CREATE TABLE CustomerCoupon (
  CustomerID BIGINT NOT NULL,
  CouponID   BIGINT NOT NULL,
  AssignedAt TIMESTAMP NOT NULL DEFAULT NOW(),
  UsedAt     TIMESTAMP,
  PRIMARY KEY (CustomerID, CouponID),
  FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID) ON DELETE CASCADE,
  FOREIGN KEY (CouponID)   REFERENCES Coupon(CouponID)     ON DELETE RESTRICT
);

-- 사용자-권한(N:M)
CREATE TABLE "Role" (
  RoleID BIGSERIAL PRIMARY KEY,
  Name   TEXT NOT NULL UNIQUE
);

CREATE TABLE UserRole (
  CustomerID BIGINT NOT NULL,
  RoleID     BIGINT NOT NULL,
  PRIMARY KEY (CustomerID, RoleID),
  FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID) ON DELETE CASCADE,
  FOREIGN KEY (RoleID)     REFERENCES "Role"(RoleID)       ON DELETE CASCADE
);
```

### 16.3 대표 질의
```sql
-- 1) 고객의 최근 주문 10건과 총액
SELECT o.OrderID, o.OrderedAt, SUM(oi.Qty * oi.PriceAt) AS Total
FROM "Order" o
JOIN OrderItem oi ON oi.OrderID = o.OrderID
WHERE o.CustomerID = 501
GROUP BY o.OrderID, o.OrderedAt
ORDER BY o.OrderedAt DESC
LIMIT 10;

-- 2) 특정 카테고리 하위 전체 상품 나열(재귀)
WITH RECURSIVE sub AS (
  SELECT CategoryID FROM Category WHERE CategoryID = 10
  UNION ALL
  SELECT c.CategoryID
  FROM Category c JOIN sub s ON c.ParentID = s.CategoryID
)
SELECT p.ProductID, p.Name
FROM Product p
JOIN ProductCategory pc ON pc.ProductID = p.ProductID
WHERE pc.CategoryID IN (SELECT CategoryID FROM sub);

-- 3) 활성 쿠폰을 가진 고객 수
SELECT COUNT(DISTINCT cc.CustomerID) AS ActiveCouponUsers
FROM CustomerCoupon cc
JOIN Coupon c ON c.CouponID = cc.CouponID
WHERE NOW() BETWEEN c.StartAt AND c.EndAt
  AND cc.UsedAt IS NULL;

-- 4) 태그 기반 추천: 'history' 태그 상품을 산 고객이 자주 같이 산 다른 태그 Top 5
SELECT t2.Name, COUNT(*) AS cnt
FROM "Order" o
JOIN OrderItem oi ON oi.OrderID = o.OrderID
JOIN ProductTag pt1 ON pt1.ProductID = oi.ProductID
JOIN Tag t1 ON t1.TagID = pt1.TagID AND t1.Name = 'history'
JOIN OrderItem oi2 ON oi2.OrderID = o.OrderID AND oi2.ProductID <> oi.ProductID
JOIN ProductTag pt2 ON pt2.ProductID = oi2.ProductID
JOIN Tag t2 ON t2.TagID = pt2.TagID
GROUP BY t2.Name
ORDER BY cnt DESC
LIMIT 5;
```

---

## 17. 성능·확장·운영 체크리스트

- **FK 인덱스**: 모든 FK에 인덱스 부여(삭제/조인/검사 성능 향상).
- **설계 시나리오별 카디널리티 검증**: 쿼리로 **고아 레코드**, **중복 관계** 탐지.
- **배치 삭제/정리**: 작은 청크 + 트랜잭션 경량화 + 큐/이벤트로 비동기 보조.
- **캐시**: 1:N 조회 핫 경로는 키-값 캐시 도입(무효화 전략 명시).
- **감사/보존**: CASCADE 남발 금지. **소프트 삭제**/아카이빙 테이블 병행.
- **마이그레이션 안전성**: 새 스키마 병행 → 데이터 이관 → 읽기 전환 → 쓰기 전환 → 구 스키마 제거.

---

## 18. 혼동 방지: “카디널리티” 이중 의미 재정리

1) **관계 카디널리티**(1:1, 1:N, N:M): **엔터티 간 연결의 참여수**.  
2) **속성 카디널리티**(컬럼의 서로 다른 값 개수): **인덱스 선택도**와 직결.

둘은 완전히 다른 개념이므로, 문맥마다 의미를 명시한다.

---

## 19. 수학적 기호로 본 관계 제약(개념적 표현)

- 엔터티 집합 \( A, B \)와 관계 \( R \subseteq A \times B \)일 때,  
  **1:N**는 임의의 \( a \in A \)에 대해 \( |\{ b \in B \mid (a,b) \in R \}| \le N \)이며, 일반적으로 \( N \)은 제한 없이 크다.  
- **옵셔널리티**(최소 참여수)는 \( a \in A \)에 대해 \( \exists b \in B: (a,b)\in R \)의 필요 여부로 정의.  
- **유일성 제약**은 \( (a,b_1),(a,b_2)\in R \Rightarrow b_1=b_2 \)와 같은 형태로 서술 가능.

$$
R \subseteq A \times B,\quad
\forall a \in A:\ \text{min\_participation}(a) \in \{0,1\},\
\text{max\_participation}(a) \in \{1,N\}.
$$

---

## 20. 회귀 테스트용 진단 SQL 스니펫

```sql
-- 1) 고아 주문(부모 없는 자식)
SELECT o.OrderID
FROM "Order" o
LEFT JOIN Customer c ON c.CustomerID = o.CustomerID
WHERE c.CustomerID IS NULL;

-- 2) 학생-과목 중복(유니크 위반 후보) 탐지
SELECT StudentID, CourseID, COUNT(*) AS cnt
FROM StudentCourse
GROUP BY StudentID, CourseID
HAVING COUNT(*) > 1;

-- 3) 템포럴 기간 겹침 후보(단순 검출)
SELECT a.EmpID, a.DeptID, a.StartDate, a.EndDate, b.StartDate, b.EndDate
FROM EmployeeDepartment a
JOIN EmployeeDepartment b
  ON a.EmpID  = b.EmpID
 AND a.DeptID = b.DeptID
 AND a.StartDate < COALESCE(b.EndDate, '9999-12-31')
 AND b.StartDate < COALESCE(a.EndDate, '9999-12-31')
 AND (a.EmpID, a.DeptID, a.StartDate) <> (b.EmpID, b.DeptID, b.StartDate);
```

---

## 21. 마무리

- **관계 설계**는 **업무 의미(최소/최대 참여, 행위/존재)**를 **물리 제약(FK/UNIQUE/NOT NULL/체크/인덱스)**으로 정교하게 옮기는 작업이다.
- **식별/비식별, 1:1/1:N/N:M, 재귀/슈퍼-서브, 템포럴, 삼항**까지 **업무 규칙**에 맞는 모델을 선택하고,  
  **성능(FK 인덱스·조인 전략)·운영(삭제 정책·아카이빙)·보안(접근·감사)**을 함께 설계한다.
- 구현 후에는 **진단 SQL/테스트/ORM 페치 전략**으로 관계의 품질을 지속적으로 검증한다.

---

# 부록 A. 실습 시나리오 요약

1) 동일 도메인을 **1:1 두 방식**(PK=FK vs UNIQUE FK), **1:N**, **N:M 조인 엔터티**로 모델링해 보고 쿼리/성능을 비교한다.  
2) **템포럴 관계**를 추가하고 기간 겹침 방지 제약(가능하면 Exclusion)까지 검증한다.  
3) 재귀 관계(카테고리 트리)에서 **CTE 경로 쿼리**와 **경로 캐싱(반정규화)**의 성능을 비교한다.  
4) ORM으로 N+1을 재현하고 **페치 조인/전용 조회 API**로 해결한다.