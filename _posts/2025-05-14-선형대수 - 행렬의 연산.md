---
layout: post
title: 선형대수 - 행렬의 연산
date: 2025-05-14 20:20:23 +0900
category: 선형대수
---
# 행렬의 연산 (덧셈, 곱셈, 전치 등)

## 표기와 전제

- 행렬: $$\mathbf{A}\in\mathbb{R}^{m\times n},\ \mathbf{B}\in\mathbb{R}^{n\times p}$$
- 전치: $$\mathbf{A}^\top$$, 영행렬: $$\mathbf{0}$$, 단위행렬: $$\mathbf{I}$$
- 원소 표기: $$\mathbf{A}=[a_{ij}]$$

---

## 행렬의 덧셈과 뺄셈

### 정의

크기가 같은 두 행렬 $$\mathbf{A},\mathbf{B}\in\mathbb{R}^{m\times n}$$ 에 대해
$$
\mathbf{A}+\mathbf{B}=[a_{ij}+b_{ij}],\qquad
\mathbf{A}-\mathbf{B}=[a_{ij}-b_{ij}].
$$

### 성질

- 교환법칙: $$\mathbf{A}+\mathbf{B}=\mathbf{B}+\mathbf{A}$$
- 결합법칙: $$(\mathbf{A}+\mathbf{B})+\mathbf{C}=\mathbf{A}+(\mathbf{B}+\mathbf{C})$$
- 항등원: $$\mathbf{A}+\mathbf{0}=\mathbf{A}$$
- 역원: $$\mathbf{A}+(-\mathbf{A})=\mathbf{0}$$

### 조건

- 반드시 **크기가 동일**해야 함: $$\mathbf{A},\mathbf{B}\in\mathbb{R}^{m\times n}$$

---

## 스칼라 곱(Scalar Multiplication)

### 정의

스칼라 $$c\in\mathbb{R}$$ 에 대해
$$
c\mathbf{A}=[c\,a_{ij}].
$$

### 성질

- 결합법칙: $$a(b\mathbf{A})=(ab)\mathbf{A}$$
- 분배법칙: $$a(\mathbf{A}+\mathbf{B})=a\mathbf{A}+a\mathbf{B}$$, $$(a+b)\mathbf{A}=a\mathbf{A}+b\mathbf{A}$$
- $$(-1)\mathbf{A}=-\mathbf{A}$$

---

## 행렬 곱셈(Matrix Multiplication)

### 정의

$$
\mathbf{A}\in\mathbb{R}^{m\times n},\ \mathbf{B}\in\mathbb{R}^{n\times p}\ \Rightarrow\
\mathbf{C}=\mathbf{A}\mathbf{B}\in\mathbb{R}^{m\times p},\quad
\mathbf{C}_{ij}=\sum_{k=1}^{n} a_{ik}b_{kj}.
$$
즉, **A의 i번째 행**과 **B의 j번째 열**의 내적입니다.

### 성질

- 결합법칙: $$\mathbf{A}(\mathbf{B}\mathbf{C})=(\mathbf{A}\mathbf{B})\mathbf{C}$$
- 분배법칙: $$\mathbf{A}(\mathbf{B}+\mathbf{C})=\mathbf{A}\mathbf{B}+\mathbf{A}\mathbf{C}$$, $$(\mathbf{A}+\mathbf{B})\mathbf{C}=\mathbf{A}\mathbf{C}+\mathbf{B}\mathbf{C}$$
- 항등원: $$\mathbf{A}\mathbf{I}=\mathbf{I}\mathbf{A}=\mathbf{A}$$ (크기 일치 필요)
- 일반적으로 **교환법칙 불성립**: $$\mathbf{A}\mathbf{B}\ne \mathbf{B}\mathbf{A}$$

### 차원 조건과 해석

- 정의 조건: **앞 행렬의 열 수 = 뒤 행렬의 행 수**
- 선형사상 합성: $$\mathbf{x}\mapsto \mathbf{B}\mathbf{x}\mapsto \mathbf{A}(\mathbf{B}\mathbf{x})=(\mathbf{A}\mathbf{B})\mathbf{x}$$
  곱의 순서는 **적용 순서의 역순**으로 반영됨.

### 주의점

- 영이 아닌 두 행렬의 곱이 영행렬일 수 있음: $$\mathbf{A}\ne\mathbf{0},\mathbf{B}\ne\mathbf{0},\ \mathbf{A}\mathbf{B}=\mathbf{0}$$
- 계산 비용: 일반적으로 $$O(n^3)$$. 괄호 위치로 중간 형상을 줄여 비용을 크게 절감할 수 있음(행렬 연쇄 곱 최적화).

---

## 전치(Transpose)

### 정의

$$
(\mathbf{A}^\top)_{ij}=a_{ji}.
$$

### 성질

- $$ (\mathbf{A}^\top)^\top=\mathbf{A} $$
- $$ (\mathbf{A}+\mathbf{B})^\top=\mathbf{A}^\top+\mathbf{B}^\top $$
- $$ (\mathbf{A}\mathbf{B})^\top=\mathbf{B}^\top\mathbf{A}^\top $$
- 대칭행렬: $$\mathbf{A}=\mathbf{A}^\top$$, 반대칭: $$\mathbf{A}^\top=-\mathbf{A}$$

---

## 원소곱(Hadamard)과 행렬곱 구분

- Hadamard(원소곱): $$ (\mathbf{A}\circ\mathbf{B})_{ij}=a_{ij}b_{ij} $$ (크기 같아야 함)
- 행렬곱: 행·열 내적 기반, 차원 조건 다름
- 구현에서 연산자 혼동 주의: 프레임워크별로 원소곱과 행렬곱 연산자가 다름

---

## 블록 연산(요약)

블록 분할 $$\mathbf{A}=\begin{bmatrix}\mathbf{A}_{11}&\mathbf{A}_{12}\\\mathbf{A}_{21}&\mathbf{A}_{22}\end{bmatrix}$$,
$$\mathbf{B}=\begin{bmatrix}\mathbf{B}_{11}&\mathbf{B}_{12}\\\mathbf{B}_{21}&\mathbf{B}_{22}\end{bmatrix}$$ 이면
$$
\mathbf{A}\mathbf{B}=
\begin{bmatrix}
\mathbf{A}_{11}\mathbf{B}_{11}+\mathbf{A}_{12}\mathbf{B}_{21} &
\mathbf{A}_{11}\mathbf{B}_{12}+\mathbf{A}_{12}\mathbf{B}_{22}\\[3pt]
\mathbf{A}_{21}\mathbf{B}_{11}+\mathbf{A}_{22}\mathbf{B}_{21} &
\mathbf{A}_{21}\mathbf{B}_{12}+\mathbf{A}_{22}\mathbf{B}_{22}
\end{bmatrix}.
$$
대규모 연산에서 캐시 효율과 병렬화를 위해 유용합니다.

---

## 구현 팁(PyTorch 관점)

- 행렬곱: `@`, `torch.matmul`, 2D 전용 `torch.mm`
- 배치 행렬곱: `torch.bmm` (3D 텐서) 또는 `torch.matmul`의 배치 브로드캐스트
- 원소곱: `*` (브로드캐스트 적용됨)
- 전치: `A.T` 또는 `A.transpose(-1,-2)` (배치 마지막 두 축 전치)
- 형상 검사: `assert A.size(1) == B.size(0)`
- 수치 안정: 필요 시 `dtype=torch.float64`, 정규화/스케일링
- 성능: 괄호로 중간 크기 최소화, `einsum` 으로 명시적 계약

---

## PyTorch 예제(핵심 시나리오 포함)

```python
import torch
torch.set_printoptions(precision=6, sci_mode=False)
dtype = torch.float64

# 덧셈·뺄셈

A = torch.tensor([[1., 2.],
                  [3., 4.]], dtype=dtype)
B = torch.tensor([[5., 6.],
                  [7., 8.]], dtype=dtype)
print("A+B=\n", A + B)
print("A-B=\n", A - B)

# 스칼라 곱

c = 3.0
print("3*A=\n", c * A)

# 행렬곱(정의와 차원)

A = torch.tensor([[1., 2.],
                  [3., 4.]], dtype=dtype)
B = torch.tensor([[2., 0.],
                  [1., 2.]], dtype=dtype)
print("A@B=\n", A @ B)  # (2x2)@(2x2)

# 전치 성질 (AB)^T = B^T A^T

left  = (A @ B).T
right = B.T @ A.T
print("(AB)^T == B^T A^T ? ", torch.allclose(left, right, atol=1e-12))

# 교환법칙 불성립 예시

print("AB=\n", A @ B)
print("BA=\n", B @ A)  # 일반적으로 다름

# 영곱 예시(둘 다 영이 아닌데 AB=0)

X = torch.tensor([[ 1., -1.],
                  [ 1., -1.]], dtype=dtype)
Y = torch.tensor([[1., 1.],
                  [1., 1.]], dtype=dtype)
print("X!=0, Y!=0, X@Y=\n", X @ Y)  # 0행렬

# Hadamard(원소곱) vs 행렬곱 구분

M = torch.tensor([[1., 2.],
                  [3., 4.]], dtype=dtype)
N = torch.tensor([[10., 20.],
                  [30., 40.]], dtype=dtype)
print("원소곱 M*N=\n", M * N)  # Hadamard
print("행렬곱 M@N=\n", M @ N)  # Matrix product

# 배치 행렬곱

B1 = torch.randn(4, 3, 2, dtype=dtype)  # batch=4, (3x2)
B2 = torch.randn(4, 2, 5, dtype=dtype)  # batch=4, (2x5)
Bprod = torch.bmm(B1, B2)               # (4, 3, 5)
print("배치 곱 shape =", Bprod.shape)

# 괄호에 따른 중간 형상/비용 차이(형상만 비교)

A = torch.randn(10, 100, dtype=dtype)
B = torch.randn(100, 5,  dtype=dtype)
C = torch.randn(5, 50,   dtype=dtype)
left  = (A @ B) @ C     # (10x5)->(10x50)
right = A @ (B @ C)     # (100x50)->(10x50)
print("동일 결과? ", torch.allclose(left, right, atol=1e-10))
print("중간 형상 (AB)->", (A @ B).shape, "  (BC)->", (B @ C).shape)

# 형상 오류 시나리오(예외 처리)

P = torch.randn(3, 4, dtype=dtype)
Q = torch.randn(5, 6, dtype=dtype)
try:
    PQ = P @ Q  # 열/행 불일치
except RuntimeError as e:
    print("형상 불일치 오류:", str(e).splitlines()[0])
```

---

## 체크리스트

1) 덧셈·뺄셈은 **크기 동일** 확인.
2) 행렬곱은 **차원 조건**(앞의 열 = 뒤의 행) 확인.
3) 원소곱과 행렬곱 연산자 구분.
4) 전치의 곱 공식은 **순서 반전**.
5) 괄호로 중간 형상 최소화(성능·메모리 절약).
6) 수치 감도 있는 문제는 `float64` 사용과 정규화/스케일링 고려.

---

## 연습문제(해설 방향만 제시)

1) 크기 $$m\times n$$ 행렬 두 개의 덧셈이 벡터공간 공리를 만족함을 보이라.
2) $$\mathbf{A}\in\mathbb{R}^{m\times n},\ \mathbf{B}\in\mathbb{R}^{n\times p}$$ 에 대해 $$\operatorname{Col}(\mathbf{A}\mathbf{B})\subseteq \operatorname{Col}(\mathbf{A})$$ 를 증명하라.
3) $$\mathbf{A},\mathbf{B}$$ 가 정방일 때 $$\operatorname{tr}(\mathbf{A}\mathbf{B})=\operatorname{tr}(\mathbf{B}\mathbf{A})$$ 를 지수 표기로 보이라.
4) 원소곱과 행렬곱을 혼동했을 때 발생 가능한 버그를 2가지 코드 예로 재현하라.
5) 괄호 최적화: $$\mathbf{A}\in\mathbb{R}^{40\times 10},\ \mathbf{B}\in\mathbb{R}^{10\times 30},\ \mathbf{C}\in\mathbb{R}^{30\times 5}$$ 에 대해
   $$(\mathbf{A}\mathbf{B})\mathbf{C}$$ 와 $$\mathbf{A}(\mathbf{B}\mathbf{C})$$ 의 곱셈 수를 계산하고 더 저렴한 쪽을 고르라.

---

## 결론

- 덧셈·뺄셈·스칼라 곱은 원소 단위의 간단한 규칙이지만, **행렬곱은 차원·괄호·순서**에 특히 주의해야 합니다.
- 전치는 합·곱과의 결합 관계를 명확히 이해해야 구현 오류가 줄어듭니다.
- 실전에서는 **형상 검사 → 연산자 선택(@/bmm) → 괄호 최적화 → dtype/정규화** 순으로 접근하는 것이 안전합니다.
