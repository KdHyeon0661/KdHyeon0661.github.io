---
layout: post
title: WPF - WPF란 무엇인가
date: 2025-08-27 14:25:23 +0900
category: WPF
---

# WPF란 무엇인가? / WinForms와 비교 / XAML 기반 UI 정의 방식

## 1) WPF(Windows Presentation Foundation)란 무엇인가?

**WPF**는 Windows 데스크톱 애플리케이션을 만들기 위한 UI 프레임워크로, .NET 위에서 동작합니다. 주요 특징은 다음과 같습니다.

- **Retained-Mode 벡터 렌더링**: GDI가 아닌 **DirectX** 기반 렌더링 파이프라인을 사용합니다. 따라서 **하드웨어 가속**, **벡터 그래픽(무한 확대/축소 시에도 선명)**, **고DPI 스케일링**이 자연스럽습니다.
- **선언형 UI(XAML) + 로직(C#)**: UI는 **XAML**로 선언하고, 동작은 C# 등의 코드비하인드나 **MVVM** 패턴의 ViewModel로 분리합니다.
- **강력한 바인딩 시스템**: `INotifyPropertyChanged`, `ObservableCollection<T>`를 바탕으로 **데이터 바인딩**이 일급 시민입니다.
- **스타일/템플릿/리소스**: **ControlTemplate**, **DataTemplate**, **Style**, **ResourceDictionary**로 UI 스킨과 구조를 데이터와 **완전히 분리**할 수 있습니다.
- **의존 속성(DependencyProperty)**: 레이아웃, 스타일, 바인딩, 애니메이션, 리소스 조회 등과 깊게 통합된 특수 속성 모델을 제공합니다.
- **라우티드 이벤트(RoutedEvent)**: 이벤트가 **버블링/터널링**하며 트리 상위/하위로 전파되어 복잡한 UI 조합에서도 처리 지점을 유연하게 선택할 수 있습니다.
- **애니메이션/효과(Storyboard)**: 시간 기반 애니메이션, 트리거(Triggers), 시각 효과를 쉽게 적용할 수 있습니다.

요약하면, **WPF = 선언형 XAML + 강력한 바인딩/템플릿 + DirectX 기반 렌더링**으로, 모던 데스크톱 앱에 필요한 **UI/UX 커스터마이징**과 **테마/스킨 교체**를 매우 강력하게 지원합니다.

---

## 2) WinForms와 비교

| 항목 | WPF | WinForms |
|---|---|---|
| 렌더링 | **DirectX(벡터)**, Retained-mode | **GDI/GDI+ (래스터)**, Immediate-mode |
| DPI 스케일링 | 고DPI 친화적, 선명한 스케일링 | 고DPI에서 흐릿/깨짐 이슈 발생 가능 |
| UI 기술 | **XAML**(선언형), MVVM 자연스러움 | 디자이너-드리븐, 코드 중심 이벤트 처리 |
| 스타일/템플릿 | **ControlTemplate/DataTemplate**로 구조/스킨 완전 교체 | 제한적(Owner Draw/Custom Paint 위주) |
| 데이터 바인딩 | 1급 기능(검증, 변환, 업데이트 트리거 등) | 단순/기본 바인딩 중심 |
| 애니메이션 | **Storyboard**, 트리거, 비헤이비어 | 제한적, 수작업 드로잉 |
| 커스터마이징 | 테마/스킨 전면 교체 용이 | 상대적으로 어려움 |
| 러닝 커브 | 비교적 높음(개념이 많음) | 낮음(직관적 드래그&드롭) |
| 상호 운용 | WinForms 호스팅/역호스팅 지원 | WPF 컨트롤 호스팅 가능 |

**실무 관점**  
- **빠르게 단순한 도구**를 만들고 싶고 고급 그래픽이 필요 없다면 **WinForms**도 여전히 유효합니다.  
- **테마/스킨, 복잡한 데이터 주도 UI, 고DPI, 애니메이션**이 중요하면 **WPF**가 확실히 유리합니다.  
- 혼용도 가능합니다. `WindowsFormsHost`, `ElementHost`를 통해 상호 호스팅이 지원됩니다.

**같은 UI를 구성하는 접근 차이(개요)**  
- *WinForms*: 코드에서 컨트롤을 생성/배치하고 이벤트 핸들러를 연결  
- *WPF*: XAML에서 UI 구조를 선언하고, 데이터와 명령을 **바인딩**하여 로직 분리

WinForms식(개념 예시):
```csharp
var form = new Form();
var button = new Button { Text = "Click", Dock = DockStyle.Top };
button.Click += (s, e) => MessageBox.Show("Hello");
form.Controls.Add(button);
Application.Run(form);
```

WPF식(개념 예시):
```xml
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Hello" Height="200" Width="300">
  <Grid>
    <Button Content="Click" Command="{Binding SayHelloCommand}" />
  </Grid>
</Window>
```

---

## 3) XAML 기반 UI 정의 방식

### (1) XAML이란?
- **XAML(eXtensible Application Markup Language)**은 .NET 객체 트리를 **XML 문법**으로 선언하는 언어입니다.  
- 마크업의 각 요소는 .NET 클래스에 매핑되고, 속성은 **속성 설정/첨부 속성(Attached Property)**, **마크업 확장(Markup Extension)** 등으로 바인딩/리소스 참조 등을 표현합니다.

핵심 문법 요소
- **네임스페이스**: `xmlns`로 WPF 기본, `xmlns:x`로 XAML 핵심(`x:Name`, `x:Key`) 기능 사용  
- **마크업 확장**: `{Binding ...}`, `{StaticResource ...}`, `{DynamicResource ...}`, `{x:Static ...}`  
- **Attached Property**: `Grid.Row`, `DockPanel.Dock`처럼 **부모 레이아웃 컨테이너가 자식에게 붙이는 속성**

### (2) XAML + 코드비하인드 + MVVM
- XAML은 **뷰 구조**와 **바인딩 선언**에 집중하고, 로직은 **코드비하인드(Partial Class)** 또는 **ViewModel**로 분리합니다.
- **MVVM**에서는 View의 `DataContext`에 ViewModel 인스턴스를 주입하고, `Binding`/`Command`로 상호작용합니다.

간단한 예제(뷰 + 뷰모델 + 커맨드)

**MainWindow.xaml**
```xml
<Window x:Class="Sample.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Counter" Height="220" Width="360">
  <Window.DataContext>
    <local:MainViewModel xmlns:local="clr-namespace:Sample"/>
  </Window.DataContext>

  <Grid Margin="16" RowDefinitions="Auto,Auto,Auto" RowSpacing="8">
    <TextBlock Text="카운터" FontSize="20" />
    <TextBlock Text="{Binding Count}" FontSize="32" FontWeight="Bold"/>
    <StackPanel Orientation="Horizontal" HorizontalAlignment="Left" >
      <Button Content="+1" Margin="0,8,8,0" Command="{Binding IncrementCommand}"/>
      <Button Content="Reset" Margin="0,8,8,0" Command="{Binding ResetCommand}"/>
    </StackPanel>
  </Grid>
</Window>
```

**MainViewModel.cs**
```csharp
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows.Input;

public class MainViewModel : INotifyPropertyChanged
{
    private int _count;
    public int Count
    {
        get => _count;
        set { _count = value; OnPropertyChanged(); }
    }

    public ICommand IncrementCommand { get; }
    public ICommand ResetCommand { get; }

    public MainViewModel()
    {
        IncrementCommand = new RelayCommand(_ => Count++);
        ResetCommand     = new RelayCommand(_ => Count = 0);
    }

    public event PropertyChangedEventHandler PropertyChanged;
    protected void OnPropertyChanged([CallerMemberName] string name = null)
        => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
}

public class RelayCommand : ICommand
{
    private readonly System.Action<object?> _execute;
    private readonly System.Predicate<object?>? _canExecute;

    public RelayCommand(System.Action<object?> execute, System.Predicate<object?>? canExecute = null)
    {
        _execute = execute; _canExecute = canExecute;
    }

    public bool CanExecute(object? parameter) => _canExecute?.Invoke(parameter) ?? true;
    public void Execute(object? parameter) => _execute(parameter);
    public event System.EventHandler? CanExecuteChanged
    {
        add    => CommandManager.RequerySuggested += value;
        remove => CommandManager.RequerySuggested -= value;
    }
}
```

### (3) 리소스, 스타일, 템플릿

- **리소스**: 브러시, 스타일, 템플릿, 데이터 등을 `ResourceDictionary`에 담아 재사용  
- **Style**: 컨트롤의 **공통 속성**/트리거 정의  
- **ControlTemplate**: 컨트롤의 **시각적 구조 자체**를 교체  
- **DataTemplate**: **데이터 타입 → 표시 UI**를 정의

예: 공통 스타일과 리소스
```xml
<Window.Resources>
  <SolidColorBrush x:Key="PrimaryBrush" Color="#4F46E5"/>
  <Style TargetType="Button">
    <Setter Property="Padding" Value="8,4"/>
    <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
    <Setter Property="Foreground" Value="White"/>
  </Style>
</Window.Resources>
```

예: DataTemplate로 리스트 표시
```xml
<ListBox ItemsSource="{Binding Users}">
  <ListBox.ItemTemplate>
    <DataTemplate DataType="{x:Type local:User}">
      <StackPanel Orientation="Horizontal" Spacing="8">
        <TextBlock Text="{Binding Name}" FontWeight="Bold"/>
        <TextBlock Text="{Binding Email}" Opacity="0.7"/>
      </StackPanel>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
```

예: ControlTemplate로 버튼 모양 교체
```xml
<Window.Resources>
  <ControlTemplate x:Key="RoundedButtonTemplate" TargetType="Button">
    <Border CornerRadius="16" Background="{TemplateBinding Background}" Padding="{TemplateBinding Padding}">
      <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
    </Border>
  </ControlTemplate>

  <Style TargetType="Button" BasedOn="{StaticResource {x:Type Button}}">
    <Setter Property="Template" Value="{StaticResource RoundedButtonTemplate}"/>
  </Style>
</Window.Resources>
```

### (4) Markup Extension과 Dynamic/StaticResource
- `{StaticResource Key}`: **로드 시점**에 리소스 고정
- `{DynamicResource Key}`: **런타임**에 리소스 변경 반영(테마 전환 등)
- `{Binding Path=...}`: DataContext에 있는 속성과 **양방향/일방향** 바인딩
- `{x:Static}`: 상수/정적 멤버 참조

### (5) 레이아웃과 첨부 속성(Attached Property)
- 레이아웃 패널: `Grid`, `StackPanel`, `DockPanel`, `UniformGrid`, `Canvas`
- 예: `Grid.Row`, `Grid.Column`은 **Grid가 자식에게 부여하는 첨부 속성**

```xml
<Grid ColumnDefinitions="Auto,*" RowDefinitions="Auto,*" >
  <TextBlock Grid.Row="0" Grid.Column="0" Text="이름"/>
  <TextBox   Grid.Row="0" Grid.Column="1" Text="{Binding Name, UpdateSourceTrigger=PropertyChanged}"/>
</Grid>
```

---

## 정리 & 실무 팁

- **WPF의 강점**은 “**XAML 선언형 UI** + **강력한 바인딩/템플릿** + **DirectX 렌더링**”의 결합입니다. 특히 **MVVM**과의 궁합이 뛰어나 **유지보수성/테스트 가능성**이 높습니다.
- **WinForms → WPF 이전** 시에는 **고DPI**, **테마/스킨 요구**, **복잡한 데이터 UI**가 결정 포인트가 됩니다.
- 초반 진입장벽은 있지만, **Resource/Style/Template/DataBinding**을 체득하면 **UI 재사용성과 품질**이 급격히 올라갑니다.
- **성능**은 가상화(ItemsControl 가상화), Freezable, `VirtualizingStackPanel`, 바인딩 트레이스/메모리 누수 관리 등 **기본 베스트 프랙티스**를 따르면 충분히 우수합니다.

이상으로 **WPF란? / WinForms와의 비교 / XAML 기반 UI** 핵심을 정리했습니다. 다음 단계로는 **MVVM 패턴**과 **바인딩 심화**, **스타일/템플릿 실전**을 다루면 학습 곡선이 빠르게 안정됩니다.