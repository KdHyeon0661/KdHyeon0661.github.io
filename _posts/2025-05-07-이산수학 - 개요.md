---
layout: post
title: 이산수학 - 개요
date: 2025-05-07 18:20:23 +0900
category: 이산수학
---
# 이산수학이란 무엇인가?

## 0. 학습 목표와 읽기 가이드

- 이산수학의 대상과 방법을 해석학과 비교해 구분할 수 있다.
- 표준 표기(논리, 수량자, 집합)를 정확히 읽고 쓸 수 있다.
- 핵심 증명 기법(직접증명, 대우, 모순, 수학적 귀납법, 불변량)을 간단 예제로 익힌다.
- 실전 응용(알고리즘 검증, 그래프 탐색, 암호 합동식)에서 개념을 연결한다.

---

## 1. 이산수학(Discrete Mathematics)의 정의

이산수학은 연속적인 변화량이 아니라 **분리된 개체**를 다루는 수학입니다.  
대표적인 대상은 다음과 같습니다.

- 정수와 모듈러 산술
- 명제 논리와 술어 논리
- 집합, 관계, 함수
- 조합론(계수, 포함배제, 점화식)
- 그래프와 트리
- 부분순서, 격자, 부울대수
- 형식 언어와 오토마타

연속 모형이 필요한 경우는 해석학을 사용합니다. 반면 **컴퓨터 시스템**처럼 모든 정보가 유한 비트열로 표현되는 맥락에서는 이산 모형이 자연스럽습니다.

가산과 비가산의 구분:
- 가산: 자연수 집합처럼 원소를 1, 2, 3, ... 로 셀 수 있는 경우.
- 비가산: 실수 집합처럼 셀 수 없는 경우.

---

## 2. 왜 이산수학이 중요한가

- 소프트웨어 정확성: 전제에서 결론이 타당한지, 조건문이 논리적으로 일관적인지 검증합니다.
- 알고리즘 분석: 정확성 증명(루프 불변식), 시간과 공간 복잡도 도출(점화식, 조합 계산).
- 그래프 모델링: 네트워크 최단경로, 의존 그래프, 추천 시스템.
- 보안과 암호: 모듈러 산술과 정수론(합동, 역원, 소수성)이 근간.
- 데이터 구조 이론: 트리, 해시, 순열과 조합의 평균적 성질.
- 자동화된 추론: 오토마타, 정규식, 컴파일러 전처리 단계.

---

## 3. 이산수학 vs 해석학

| 항목 | 이산수학 | 해석학 |
|---|---|---|
| 대상 | 정수, 그래프, 유한 집합, 가산 무한 | 실수, 연속 함수, 미분/적분 |
| 방법 | 귀납법, 조합, 논리, 그래프 | 극한, 연속, 도함수, 적분 |
| 전형 문제 | 최단경로, 경우의 수, 합동식 | 속도, 면적, 연속 변화율 |
| 응용 | 컴퓨터과학, 암호, 네트워크, 데이터 | 물리, 공학, 신호처리 |

---

## 4. 표준 표기 모음

논리 기호:
- 합성: $$p \land q$$
- 분리: $$p \lor q$$
- 부정: $$\lnot p$$
- 함의: $$p \to q$$
- 동치: $$p \leftrightarrow q$$
- 전칭 수량자: $$\forall x\ P(x)$$
- 존재 수량자: $$\exists x\ P(x)$$

집합 표기:
- 원소관계: $$x \in A$$
- 부분집합: $$A \subseteq B$$, 진부분집합: $$A \subset B$$
- 연산: $$A \cup B,\ A \cap B,\ A \setminus B,\ A^\complement$$
- 표기 예: $$\{ x \in \mathbb{N} \mid x \text{ is even} \}$$

관계와 함수:
- 관계: $$R \subseteq A \times B$$
- 함수: $$f: A \to B$$, 단사, 전사, 전단사

주의:
- 텍스트에서는 and, or, not, -> 를 쓸 수 있지만, 수식에서는 \land, \lor, \lnot, \to 를 사용합니다.
- 특수그림문자는 쓰지 않으며, 필요 기호는 모두 LaTeX로 표현합니다.

---

## 5. 핵심 증명 기법 요약

1) 직접증명  
전제에서 규칙에 따라 결론을 유도합니다.

2) 대우에 의한 증명  
$$P \to Q \equiv \lnot Q \to \lnot P$$ 를 이용합니다.

3) 모순법  
결론의 부정을 가정하고 모순을 도출합니다.

4) 수학적 귀납법  
- 기본 단계 확인 후, $$n \to n+1$$ 을 보이면 전체 성립.
- 강한 귀납은 $$\le n$$ 모두를 가정합니다.

5) 불변량과 단조량  
루프나 연산 과정에서 변하지 않거나 한 방향으로만 변하는 양을 잡아 종료성과 정확성을 보증합니다.

---

## 6. 대표 예제 1: 진리표와 함의

명제: $$(p \land q) \to p$$ 는 항상 참입니다. 진리표:

```
| p | q | p and q | (p and q) -> p |
|---|---|---------|-----------------|
| T | T |    T    |        T        |
| T | F |    F    |        T        |
| F | T |    F    |        T        |
| F | F |    F    |        T        |
```

파이썬으로 자동 검증:

```python
from itertools import product

def implies(a, b):
    return (not a) or b

rows = []
for p, q in product([False, True], repeat=2):
    lhs = p and q
    val = implies(lhs, p)
    rows.append((p, q, lhs, val))

for r in rows:
    print(r)
```

---

## 7. 대표 예제 2: 집합 연산과 드모르간

드모르간 법칙:
$$(A \cup B)^\complement = A^\complement \cap B^\complement$$

무작위 유한 집합에 대해 실험 검증:

```python
import random

U = set(range(20))
for _ in range(10):
    A = {x for x in U if random.random() < 0.4}
    B = {x for x in U if random.random() < 0.4}
    left  = U - (A | B)
    right = (U - A) & (U - B)
    assert left == right
print("De Morgan law holds on random tests")
```

---

## 8. 대표 예제 3: 관계, 등가관계, 분할

정의: 관계 $$\sim$$ 이 반사적, 대칭적, 추이적이면 등가관계입니다. 등가관계는 집합을 동치류들의 분할로 만듭니다.

예: 정수에서 $$a \sim b \iff a \equiv b \pmod{3}$$  
세 동치류 $$[0], [1], [2]$$ 로 분할됩니다.

파이썬으로 분할 보기:

```python
def eq_class_mod3(n):
    return n % 3

data = list(range(-5, 10))
classes = {}
for x in data:
    k = eq_class_mod3(x)
    classes.setdefault(k, []).append(x)

print(classes)
```

---

## 9. 대표 예제 4: 귀납법 - 홀수의 합

명제:
$$1 + 3 + 5 + \cdots + (2n - 1) = n^2$$

- 기본: $$n=1$$ 에서 좌변과 우변이 모두 $$1$$.
- 가정: $$n$$ 에서 성립.
- 귀납: $$n+1$$ 에서
$$1 + 3 + \cdots + (2n - 1) + (2n + 1) = n^2 + (2n + 1) = (n + 1)^2$$

검증 코드:

```python
def sum_of_odds(n):
    return sum(2*i-1 for i in range(1, n+1))

for n in range(1, 20):
    assert sum_of_odds(n) == n*n
print("Induction identity holds on 1..19")
```

---

## 10. 대표 예제 5: 조합론과 이항정리

이항정리:
$$(x + y)^n = \sum_{k=0}^{n} \binom{n}{k} x^{n-k} y^k$$

파이썬으로 계수 검증:

```python
from math import comb

def expand_xy(n, x=1, y=1):
    return sum(comb(n, k) * (x**(n-k)) * (y**k) for k in range(n+1))

for n in range(1, 8):
    assert expand_xy(n, 2, 3) == (2+3)**n
print("Binomial theorem checked for n<=7 at x=2, y=3")
```

---

## 11. 대표 예제 6: 점화식과 빠른 계산

피보나치:
$$F_0 = 0,\ F_1 = 1,\ F_n = F_{n-1} + F_{n-2}$$

반복문으로 간단 계산:

```python
def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a+b
    return a

for n in [0, 1, 2, 5, 10, 20]:
    print(n, fib(n))
```

행렬 거듭제곱을 사용하면 $$O(\log n)$$ 으로 계산 가능하지만 여기서는 생략합니다.

---

## 12. 대표 예제 7: 그래프와 BFS - 최단경로

그래프 $$G = (V, E)$$, 무가중치 최단경로는 BFS로 구합니다.

```python
from collections import deque

G = {
    "A": ["B", "C"],
    "B": ["A", "D"],
    "C": ["A", "D", "E"],
    "D": ["B", "C", "F"],
    "E": ["C"],
    "F": ["D"]
}

def bfs_path(src, dst):
    q = deque([src])
    prev = {src: None}
    while q:
        v = q.popleft()
        if v == dst:
            break
        for w in G.get(v, []):
            if w not in prev:
                prev[w] = v
                q.append(w)
    if dst not in prev:
        return None
    path = []
    cur = dst
    while cur is not None:
        path.append(cur)
        cur = prev[cur]
    return list(reversed(path))

print(bfs_path("A", "F"))
```

BFS 정확성의 핵심: 레벨별로 확장하며, 최초 도달 경로의 길이가 최단이라는 불변량을 유지합니다.

---

## 13. 대표 예제 8: 모듈러 산술과 역원

정의:
- $$a \equiv b \pmod{m} \iff m \mid (a - b)$$
- $$\gcd(a, m) = 1$$ 이면 $$a$$ 는 모듈러 $$m$$ 에서 곱셈 역원을 가집니다.

확장 유클리드 알고리즘:

```python
def egcd(a, b):
    if b == 0:
        return (1, 0, a)
    x, y, g = egcd(b, a % b)
    return (y, x - (a // b) * y, g)

def inv_mod(a, m):
    x, y, g = egcd(a, m)
    if g != 1:
        return None
    return x % m

m = 17
for a in range(1, m):
    inv = inv_mod(a, m)
    if inv is not None:
        assert (a * inv) % m == 1
print("All invertible elements mod 17 verified")
```

---

## 14. 실제 적용 미니 시나리오

1) 로직 검증  
사양: 입력 $$x$$ 가 짝수면 A, 홀수면 B를 수행한다.  
명제 $$\text{even}(x) \lor \text{odd}(x)$$ 은 항상 참, $$\text{even}(x) \land \text{odd}(x)$$ 은 항상 거짓이므로 분기 누락과 중복을 점검할 수 있습니다.

2) 해시 버킷 크기  
버킷 수 $$m$$ 을 소수로 두면 나쁜 패턴의 키에서 충돌이 줄어드는 경향이 있습니다. 모듈러 산술의 성질과 관련됩니다.

3) 최단경로 선택  
무가중치는 BFS, 양의 가중치는 Dijkstra, 음수 가중치가 있으면 Bellman-Ford를 사용합니다.

4) 권한 모델과 부분순서  
권한 집합의 포함관계는 부분순서입니다. 최소 상한과 최대 하한이 존재하면 격자 구조로 추론 규칙을 단순화할 수 있습니다.

---

## 15. 자주 헷갈리는 포인트

- 함의의 진리표: 앞이 거짓이면 전체가 참입니다. $$p \to q \equiv \lnot p \lor q$$
- 공집합과 공집합을 원소로 갖는 집합: $$\emptyset \neq \{\emptyset\}$$
- $$A \subseteq B$$ 와 $$A \subset B$$ 의 구분.
- 전사, 단사, 전단사의 구체적 정의역, 공역, 치역 구분.
- 수량자 순서: $$\forall x\ \exists y\ P(x,y)$$ 와 $$\exists y\ \forall x\ P(x,y)$$ 는 다릅니다.

---

## 16. 주제 지도 요약

- 집합론: 모든 대상의 공통 언어.
- 논리: 정확성의 문법.
- 관계와 함수: 데이터베이스와 타입의 기초.
- 조합론: 경우의 수, 점화식, 생성함수의 관문.
- 그래프와 트리: 구조적 데이터의 표준 모델.
- 정수론: 합동과 소수성이 암호의 엔진.
- 부울대수와 격자: 회로 설계와 형식 추론.
- 오토마타: 언어 인식과 컴파일러 이론의 입구.

---

## 17. 연습문제와 힌트

1) 논리식 단순화  
식 $$\lnot(p \lor q) \lor (p \land r)$$ 를 드모르간과 분배법칙으로 간단히 하라.  
힌트: $$\lnot(p \lor q) \equiv \lnot p \land \lnot q$$

2) 집합 항등식  
모든 집합 $$A,B,C$$ 에 대해 $$A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$$ 를 원소기반 증명으로 보여라.

3) 수량자 변환  
$$\lnot(\forall x\ \exists y\ P(x,y))$$ 와 동치인 전형식을 쓰라.  
정답: $$\exists x\ \forall y\ \lnot P(x,y)$$

4) 귀납법  
$$\sum_{k=1}^{n} k = \frac{n(n+1)}{2}$$ 를 귀납으로 증명하라.

5) 합동식  
모든 정수 $$n$$ 에 대해 $$n^3 - n \equiv 0 \pmod{6}$$ 임을 보여라.  
힌트: 2와 3에 대해 각각 합동을 보이면 충분합니다.

6) 등가관계  
관계 $$a \sim b \iff a-b \text{ 가 짝수}$$ 가 등가관계임을 보이고 동치류를 기술하라.

7) 그래프  
연결 그래프에서 임의 두 노드 간 단순 경로가 존재함을 BFS 관점으로 설명하라.

8) 조합  
길이 $$n$$ 인 이진 문자열 중 1이 $$k$$ 개인 문자열의 수는 얼마인가.  
정답: $$\binom{n}{k}$$

9) 점화식  
$$T(n) = 2T(n/2) + n,\ T(1)=1$$ 의 해를 마스터 정리로 구하라.  
정답: $$T(n) = \Theta(n \log n)$$

10) 불변량  
삽입정렬이 종료하고 정확함을 보이는 루프 불변식을 제시하라.

---

## 18. 실습 스니펫

1) 진리표 생성기

```python
from itertools import product

def truth_table(expr):
    print("| p | q | value |")
    print("|---|---|-------|")
    for p, q in product([False, True], repeat=2):
        val = expr(p, q)
        print(f"| {str(p)[0]} | {str(q)[0]} | {str(val)[0]} |")

truth_table(lambda p, q: (not (p or q)) or (p and True))
```

2) 집합 분배법칙 퍼저 테스트

```python
import random
U = set(range(100))

def rset():
    return {x for x in U if random.random() < 0.25}

for _ in range(200):
    A, B, C = rset(), rset(), rset()
    left  = A & (B | C)
    right = (A & B) | (A & C)
    assert left == right
print("Distributive law holds on random trials")
```

3) 등가관계 분할 도우미

```python
def partition_by(key, items):
    out = {}
    for x in items:
        out.setdefault(key(x), []).append(x)
    return out

print(partition_by(lambda x: x % 3, range(12)))
```

4) 중국인의 나머지 정리(두 모듈러)

```python
def egcd(a, b):
    if b == 0:
        return (1, 0, a)
    x, y, g = egcd(b, a % b)
    return (y, x - (a // b) * y, g)

def inv_mod(a, m):
    x, y, g = egcd(a, m)
    if g != 1:
        return None
    return x % m

def crt_pair(a1, m1, a2, m2):
    # m1, m2 서로소
    x1 = inv_mod(m2, m1)
    x2 = inv_mod(m1, m2)
    return (a1*m2*x1 + a2*m1*x2) % (m1*m2)

print(crt_pair(2, 3, 3, 5))  # 8
```

5) 그래프 연결요소 수 세기

```python
from collections import deque

def count_components(G):
    seen = set()
    comp = 0
    for v in G:
        if v in seen:
            continue
        comp += 1
        q = deque([v]); seen.add(v)
        while q:
            x = q.popleft()
            for y in G.get(x, []):
                if y not in seen:
                    seen.add(y); q.append(y)
    return comp
```

---

## 19. 공부 루틴 제안

- 정의를 먼저 정확히 쓰고, 즉시 한 줄 예제를 만든다. 예: 전사 함수의 반례를 직접 구성한다.
- 항등식은 원소기반 증명과 벤 다이어그램 관점 둘 다로 점검한다.
- 증명은 기법을 먼저 정하고 전개한다. 함의는 대우, 동치는 양방향.
- 작은 입력에 대한 실험 코드를 작성해 패턴을 관찰하고, 귀납적 통찰로 일반화한다.
- 루프 불변식과 종료성 조건을 코드 주석으로 명시한다.

---

## 20. 요약

- 이산수학은 컴퓨터과학의 문법과 어휘다.
- 논리, 집합, 조합, 그래프, 정수론이 핵심 축이다.
- 증명 기법과 간단한 실험 코드를 병행하면 이해가 빨라진다.
- 실전 문제에 모델을 입히고 적절한 도구(BFS, 모듈러 역원)를 선택하는 연습이 중요하다.

---

## 부록 A. 자주 쓰는 논리 등식

$$
\begin{aligned}
&\lnot(p \lor q) \equiv (\lnot p) \land (\lnot q), \quad
\lnot(p \land q) \equiv (\lnot p) \lor (\lnot q) \\
&p \lor (p \land q) \equiv p, \quad
p \land (p \lor q) \equiv p \\
&p \land (q \lor r) \equiv (p \land q) \lor (p \land r) \\
&\lnot\lnot p \equiv p, \quad
p \to q \equiv \lnot p \lor q
\end{aligned}
$$

---

## 부록 B. 집합 항등식

$$
\begin{aligned}
&A \cup (B \cap C) = (A \cup B) \cap (A \cup C) \\
&A \cap (B \cup C) = (A \cap B) \cup (A \cap C) \\
&(A \cup B)^\complement = A^\complement \cap B^\complement \\
&(A \cap B)^\complement = A^\complement \cup B^\complement \\
&A \setminus (B \cup C) = (A \setminus B) \cap (A \setminus C)
\end{aligned}
$$

---

## 부록 C. 소규모 프로젝트 아이디어

- 부울식 진리표 자동 생성기: 임의의 Python lambda를 받아 테이블로 출력.
- 그래프 연결 요소 계산기: 입력 파일의 엣지 리스트를 읽어 연결 요소 개수를 출력.
- 모듈러 역원 테이블러: 고정된 $$m$$ 에 대해 역원이 존재하는 모든 $$a$$ 를 나열하고 곱셈군 구조 관찰.