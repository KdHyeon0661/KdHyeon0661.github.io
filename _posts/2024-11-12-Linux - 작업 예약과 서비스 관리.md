---
layout: post
title: Linux - 작업 예약과 서비스 관리
date: 2024-11-12 19:20:23 +0900
category: Linux
---
# 작업 예약과 서비스 관리

## 작업 예약이 왜 중요한가

리눅스 시스템 운영에서 작업 예약과 서비스 관리는 중요한 요소입니다. 이는 크게 네 가지 운영 과제를 해결합니다:

1) **정기 작업 관리**: 백업, 로그 회전, 지표 수집, 인증서 갱신 등을 주기적으로 실행하는 작업(cron/timer)
2) **1회성 작업 처리**: 야간 재부팅, 패치 적용, 마이그레이션 등 일회성으로 실행해야 하는 작업(at)
3) **서비스 관리**: 데몬의 시작/중지/재시작/상태 확인 등 서비스 수명주기 관리(systemctl/service)
4) **장애 복구**: 실패 시 재시도, 알림 전송, 롤백 실행 등의 자동화된 복구 메커니즘(systemd `Restart=`/타이머+헬스체크)

---

## crontab — 주기적 작업 예약(기초→고급)

### 사용자별 crontab과 시스템 crontab

리눅스에서 cron 작업은 크게 두 가지 방식으로 관리됩니다:
- **개인용**: `crontab -e` 명령어로 편집하며, `/var/spool/cron/crontabs/<user>`(Debian/Ubuntu) 또는 `/var/spool/cron/<user>`(RHEL 계열)에 저장
- **시스템용**: `/etc/crontab`, `/etc/cron.d/*`, `/etc/cron.{hourly,daily,weekly,monthly}` 디렉터리를 통해 관리

```bash
crontab -e         # 현재 사용자 crontab 편집
crontab -l         # 목록 보기
crontab -r         # 삭제
sudo crontab -e -u www-data   # 특정 사용자 crontab 편집
```

### 시간 포맷(별표/쉼표/슬래시 활용)

```
분  시  일  월  요일  명령
0-59 0-23 1-31 1-12 0-7(일=0 또는 7)
```
- 범위: `1-5`, 목록: `1,10,20`, 간격: `*/5` (매 5분)
- **`/etc/crontab`와 `/etc/cron.d/*`**에서는 **사용자 필드**가 추가됩니다:
```
분 시 일 월 요일  사용자  명령
```

### 자주 사용하는 별칭

```crontab
@reboot   /usr/local/bin/on_boot.sh
@yearly   /usr/local/bin/job.sh
@monthly  /usr/local/bin/job.sh
@weekly   /usr/local/bin/job.sh
@daily    /usr/local/bin/job.sh
@hourly   /usr/local/bin/job.sh
```

### 기본 예시

```crontab
# 매일 07:00 실행
0 7 * * * /home/user/backup.sh

# 매주 일요일 23:00 실행
0 23 * * 0 /home/user/cleanup.sh

# 5분마다 실행
*/5 * * * * /usr/local/bin/status_log.sh
```

### 환경 변수/경로/로케일 — cron에서 가장 흔한 함정

cron은 매우 제한된 환경으로 실행되므로 주의가 필요합니다. `$PATH`가 짧고, 쉘 초기화 파일을 읽지 않습니다. 안전한 호출을 위해 **절대경로 사용**과 스크립트 내에서 `PATH`와 `WORKDIR`를 **명시적으로 설정**하는 것이 좋습니다.

```crontab
# 사용자 crontab 최상단에 환경 설정 (일부 구현에서 허용)
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
LANG=ko_KR.UTF-8
MAILTO=""
```

```bash
# /usr/local/bin/status_log.sh (예시)
#!/bin/bash

set -euo pipefail
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
cd /var/log/myapp
/usr/bin/env >> env.dump 2>&1
```

### 로그 관리 — 표준 출력/에러 리다이렉션

```crontab
# 표준출력과 에러를 파일로 저장
*/5 * * * * /usr/local/bin/status_log.sh >> /var/log/status.log 2>&1

# 날짜 스탬프 추가(rotate 고려)
0 2 * * * /usr/local/bin/backup.sh >> /var/log/backup/$(date +\%F).log 2>&1
```
- `logrotate`와 연계하거나, **journal**에 남기고 싶다면 cron 대신 **systemd timer + service**를 고려하세요.

### 동시 실행 방지(잠금) — `flock` 패턴(매우 중요)

동일 작업이 겹치면 데이터/장치 충돌이 발생하기 쉽습니다. `flock`으로 **뮤텍스**를 활용하여 이를 방지할 수 있습니다.

```crontab
*/5 * * * * /usr/bin/flock -n /var/lock/status.lock /usr/local/bin/status_log.sh >> /var/log/status.log 2>&1
```
- `-n` 옵션은 잠금 실패 시 즉시 종료하여 누적 실행을 방지합니다.

### 런너 패턴(run-parts) — 디렉터리 단위 실행

```crontab
# 시스템 crontab의 전형적인 패턴
01 * * * * root run-parts --report /etc/cron.hourly
```
- `/etc/cron.daily/` 등에 스크립트를 배치하면 유지보수가 용이해집니다.

### 권한 제어 — 허용/차단 리스트

- `/etc/cron.allow`, `/etc/cron.deny` 파일을 통해 사용자별 cron 사용 가능 여부를 관리할 수 있습니다(배포판마다 차이가 있음).

### anacron — 주기가 지나도 "다음에 보상 실행"

랩탑이나 비상주 서버처럼 자정에 꺼져 있으면 **cron이 작업을 놓칠 수 있습니다**. anacron은 다음 부팅 시 **보상 실행**을 제공합니다.

```ini
# /etc/anacrontab
# period  delay  job-id        command

1         10     cron.daily    run-parts /etc/cron.daily
7         25     cron.weekly   run-parts /etc/cron.weekly
30        45     cron.monthly  run-parts /etc/cron.monthly
```

---

## at — **1회성** 작업 예약(야간 단발 커맨드)

```bash
# 03:00에 재부팅
echo "reboot" | at 03:00

# 90분 후 애플리케이션 재시작
echo "systemctl restart myapp" | at now + 90 minutes

# 자주 쓰는 시간 표현
at 14:30
at midnight
at now + 1 hour
```

관련 명령어:
```bash
atq            # 대기 중인 작업 목록
at -c <jobid>  # 작업 내용 보기
atrm <jobid>   # 작업 취소
```

**주의**: `atd` 서비스가 실행 중인지 확인하세요.
```bash
sudo systemctl status atd
sudo systemctl enable --now atd
```

---

## systemctl — 현대 리눅스의 서비스 관리(핵심)

### 기본 명령어

```bash
sudo systemctl start|stop|restart nginx
sudo systemctl status nginx
sudo systemctl enable nginx
sudo systemctl disable nginx
sudo systemctl is-enabled nginx
```

### 서비스 목록/검색

```bash
systemctl list-units --type=service --state=running
systemctl list-unit-files --type=service
```

### 로그/최근 이벤트와 연계

```bash
journalctl -u nginx -b -n 200
journalctl -fu nginx
```

### 서비스 유닛 구조(핵심 옵션)

```ini
# /etc/systemd/system/myapp.service

[Unit]
Description=My App
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
EnvironmentFile=/etc/myapp/env
ExecStart=/usr/local/bin/myapp --config /etc/myapp/conf.yml
Restart=on-failure
RestartSec=5s
User=myapp
Group=myapp

# 리소스 보호(보안 하드닝)
ProtectSystem=full
ProtectHome=true
NoNewPrivileges=true
PrivateTmp=true

# 제한(예: 파일디스크립터)
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
```

- **재시작 정책**: `Restart=on-failure|always|no` (+ `RestartSec=`)
- **순서 제어**: `After=`, `Requires=`, `Wants=`
- **보안**: `ProtectSystem`, `ProtectHome`, `PrivateTmp`, `CapabilityBoundingSet`, `AmbientCapabilities`, `NoNewPrivileges`
- **환경 변수**: `Environment=` 또는 `EnvironmentFile=`

### 유닛 파일 커스터마이즈(Override)

```bash
sudo systemctl edit myapp.service
# 편집 화면에서 [Service] 섹션에 필요한 키만 덧씌우기
```
- `/etc/systemd/system/myapp.service.d/override.conf` 생성됨
- 수정 후:
```bash
sudo systemctl daemon-reload
sudo systemctl restart myapp
```

### 서비스 헬스체크(Watchdog)

- `Type=notify` + `WatchdogSec=` 조합 시, 프로세스가 주기적으로 **sd_notify**로 살아있음을 알리지 않으면 systemd가 재시작합니다.

---

## systemd **timer** — "cron의 현대적 대안"

cron 대신 **.service + .timer** 조합으로 주기 실행을 관리할 수 있습니다. 이 방식의 장점은 다음과 같습니다:

- **journal**로 로그 표준화
- **의존성/순서/보안**을 서비스 유닛 그대로 상속
- **랜덤 지연(RandomizedDelaySec)**으로 스파이크 방지
- **퍼시스턴스(Persistent=true)**로 놓친 실행 보상

### .service 예시(업무 로직)

```ini
# /etc/systemd/system/myjob.service

[Unit]
Description=Nightly backup

[Service]
Type=oneshot
ExecStart=/usr/local/bin/backup.sh
User=backup
Group=backup
Nice=10
IOSchedulingClass=best-effort
IOSchedulingPriority=7
```

### .timer 예시(스케줄링)

```ini
# /etc/systemd/system/myjob.timer

[Unit]
Description=Nightly backup (timer)

[Timer]
OnCalendar=02:00
Persistent=true
RandomizedDelaySec=5m        # 02:00~02:05 사이 랜덤 시작
AccuracySec=1min
Unit=myjob.service

[Install]
WantedBy=timers.target
```

활성화/상태/다음 실행:
```bash
sudo systemctl enable --now myjob.timer
systemctl list-timers
systemctl status myjob.timer
journalctl -u myjob.service --since today
```

### OnCalendar 문법(자주 쓰는 패턴)

```ini
OnCalendar=daily
OnCalendar=Mon..Fri 09:00
OnCalendar=*-*-01 00:15        # 매월 1일 00:15
OnCalendar=*-*-* 03:00:00      # 매일 03:00
OnCalendar=Sat,Sun 01:30
```

### cron vs systemd timer 비교(현업 관점)

| 항목 | cron | systemd timer |
|---|---|---|
| 로그 | 파일 리다이렉션 필요 | journalctl로 표준화 |
| 보안/격리 | 제한적 | 다양한 sandbox 옵션 |
| 의존성 | 없음 | `After=`/`Wants=` 등 풍부 |
| 놓친 실행 보상 | anacron 필요 | `Persistent=true` 내장 |
| 랜덤 분산 | 직접 스크립팅 | `RandomizedDelaySec=` |
| 단일 실패 재시도 | 직접 구현 | `Restart=`(서비스) 활용 가능 |

---

## service — 전통 SysV 호환 래퍼

```bash
sudo service ssh restart
sudo service nginx status
```
- systemd 환경에서는 내부적으로 `systemctl`을 호출하는 래퍼인 경우가 많습니다. 새로운 작업은 **systemctl**을 기본으로 사용하는 것이 좋습니다.

---

## 실전 시나리오와 모범 패턴

### 백업 작업: 동시 실행 방지 + 로그 + 알림

```bash
# /usr/local/bin/backup.sh
#!/bin/bash

set -euo pipefail
LOG=/var/log/backup/backup_$(date +%F).log
{
  echo "== $(date) backup start =="
  /usr/bin/rsync -a --delete /data/ /backup/data/
  echo "== $(date) backup done =="
} >> "$LOG" 2>&1
```

**cron (flock 적용)**:
```crontab
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
0 2 * * * /usr/bin/flock -n /var/lock/backup.lock /usr/local/bin/backup.sh
```

**systemd timer 대안**: 위의 `.service`/`.timer` 조합 사용(추천)

### 로그 정리: logrotate 호출 vs journal vacuum

```crontab
# 매일 자정, logrotate 실행
0 0 * * * /usr/sbin/logrotate /etc/logrotate.conf
```

**journald 용량 제한(참고)**:
```bash
sudo journalctl --vacuum-time=30d
```
→ 운영 정책에 따라 cron/timer로 주기 관리 가능

### 패치 후 서비스 롤링 재시작: 의존성·재시작 전략

```ini
# /etc/systemd/system/reload-nginx.service

[Unit]
Description=Reload NGINX gracefully
After=network-online.target

[Service]
Type=oneshot
ExecStart=/bin/sh -c '/usr/sbin/nginx -t && systemctl reload nginx'
```

```ini
# /etc/systemd/system/reload-nginx.timer

[Unit]
Description=Nightly nginx reload

[Timer]
OnCalendar=03:15
RandomizedDelaySec=3m
Unit=reload-nginx.service

[Install]
WantedBy=timers.target
```

### 헬스체크 + 자동자기치유: Restart Policy

```ini
# /etc/systemd/system/myapp.service

[Service]
Type=simple
ExecStart=/usr/local/bin/myapp
Restart=on-failure
RestartSec=5s
```
- 앱 내부에 `/healthz` 엔드포인트 제공 → 외부에서 `curl -f`로 타이머/별도 서비스로 체크 후 `systemctl restart myapp` 트리거 가능

### 1회성 야간 재부팅 예약 (승인 받았음)

```bash
echo "systemctl reboot" | at 02:30
atq
```
- 변경 필요 시 `atrm <jobid>`로 취소

---

## 문제 해결 팁(트러블슈팅 플레이북)

### cron이 "작동 안 하는 것처럼" 보일 때

1) **PATH/환경** 문제 가능성 → 절대경로/환경 설정 확인
2) `set -x`로 디버깅 로그 남기기
3) 권한/실행비트/해당 사용자 권한 확인
4) SELinux/AppArmor 정책 확인
5) `run-parts` 네이밍 규칙(숫자·알파벳·하이픈 등만)을 어겼는지 확인

### systemd timer가 실행되지 않는 경우

```bash
systemctl list-timers | grep myjob
systemctl status myjob.timer
journalctl -u myjob.service -b -n 200
```
- `WantedBy=timers.target`로 enable했는지, `daemon-reload`를 실행했는지 체크

### 서비스가 재시작 루프에 빠질 때

- `RestartSec` 시간을 늘리기, `StartLimitInterval`/`StartLimitBurst` 조정
- 로그 분석 후 실패 원인 제거. 필요하면 **백오프** 스크립트 추가

---

## 명령어 요약(치트시트)

| 범주 | 명령/파일 | 설명 |
|---|---|---|
| cron(사용자) | `crontab -e|-l|-r` | 사용자별 주기 예약 |
| cron(시스템) | `/etc/crontab`, `/etc/cron.d/*` | 시스템 전역 예약 |
| anacron | `/etc/anacrontab` | 놓친 작업 보상 실행 |
| at | `at`, `atq`, `at -c`, `atrm` | 1회성 예약 |
| flock | `/usr/bin/flock` | 동시 실행 방지 잠금 |
| systemctl | `start|stop|restart|status` | 서비스 제어 |
| enable/disable | `systemctl enable|disable` | 부팅시 자동 시작 |
| journalctl | `-u`, `-f`, `-b` | 서비스 로그 조회 |
| timer | `.service` + `.timer` | systemd 스케줄러 |
| list-timers | `systemctl list-timers` | 타이머 스케줄 확인 |

---

## 부록 A: 예제 — cron에서 systemd timer로 마이그레이션

### 기존 cron

```crontab
# 매일 01:10, 데이터 동기화
10 1 * * * /usr/bin/flock -n /var/lock/sync.lock /usr/local/bin/sync.sh >> /var/log/sync.log 2>&1
```

### 변환된 systemd

```ini
# /etc/systemd/system/sync.service

[Unit]
Description=Nightly data sync

[Service]
Type=oneshot
ExecStart=/usr/local/bin/sync.sh
User=syncuser
Group=syncuser
ProtectSystem=full
NoNewPrivileges=true
PrivateTmp=true
```

```ini
# /etc/systemd/system/sync.timer

[Unit]
Description=Nightly data sync (timer)

[Timer]
OnCalendar=*-*-* 01:10:00
RandomizedDelaySec=2m
Persistent=true
Unit=sync.service

[Install]
WantedBy=timers.target
```

활성화:
```bash
sudo systemctl daemon-reload
sudo systemctl enable --now sync.timer
systemctl list-timers | grep sync
```

---

## 부록 B: 예제 — 특정 사용자로만 도는 cron + sudoers 최소 권한

```crontab
# 매일 06:00 보고서 생성
0 6 * * * /usr/local/bin/generate_report.sh | mail -s "report" ops@example.com
```
```text
# /etc/sudoers.d/report
report ALL=(www-data) NOPASSWD: /usr/local/bin/publish_report.sh
```
- `generate_report.sh` 스크립트 내에서 `sudo -u www-data /usr/local/bin/publish_report.sh` 호출

---

## 결론

리눅스에서 작업 예약과 서비스 관리는 시스템 운영의 핵심 요소입니다. 효과적인 관리를 위해 다음과 같은 원칙을 기억하세요:

**도구 선택의 원칙**:
- 반복적 정기 작업은 cron 또는 systemd timer로 관리
- 1회성 작업은 `at` 명령어 활용
- 서비스 수명주기는 `systemctl`로 통제

**운영의 핵심 요소**:
1. **표준화**: 가능하면 systemd timer+service 조합으로 일원화하여 journal 기반 로깅과 통일된 관측성 확보
2. **로깅**: 모든 작업의 출력을 적절히 기록하고 모니터링 체계와 연동
3. **보안**: 최소 권한 원칙 적용, 전용 사용자/그룹으로 실행, 보안 옵션 적극 활용
4. **동시성 제어**: `flock` 등을 활용한 동시 실행 방지로 데이터 무결성 보장
5. **에러 처리**: 재시도 메커니즘, 실패 알림, 자동 복구 로직 구현

**실무 적용 팁**:
- 절대경로 사용과 환경 변수 명시적 설정으로 cron 작업의 신뢰성 향상
- 설정 파일을 Git 등 버전 관리 시스템에 Infrastructure as Code로 관리
- 팀별 운영 플레이북을 문서화하고 표준화된 패턴 적용

이러한 원칙과 패턴들을 체계적으로 적용하면 시스템의 안정성, 신뢰성, 유지보수성을 크게 향상시킬 수 있습니다. 문서의 예제들을 시작점으로 삼아 팀의 특정 요구사항에 맞게 조정하고 표준 운영 절차로 정착시키는 것이 중요합니다.