---
layout: post
title: Linux - 작업 예약과 서비스 관리
date: 2024-11-12 19:20:23 +0900
category: Linux
---
# 작업 예약과 서비스 관리

## 작업 예약이 왜 중요한가 — 운영에서의 4가지 과제
1) **정기 작업**: 백업, 로그 회전, 지표 수집, 인증서 갱신(cron/timer).  
2) **1회성 작업**: 야간 재부팅/패치/마이그레이션(at).  
3) **서비스 관리**: 데몬 시작/중지/재시작/상태(systemctl/service).  
4) **장애 복구**: 실패 시 재시도/알림/롤백(systemd `Restart=`/타이머+헬스체크).

---

## crontab — 주기적 작업 예약(기초→고급)

### 사용자별 crontab과 시스템 crontab
- **개인용**: `crontab -e` → `/var/spool/cron/crontabs/<user>`(Debian/Ubuntu) 또는 `/var/spool/cron/<user>`(RHEL 계열).  
- **시스템용**: `/etc/crontab`, `/etc/cron.d/*`, `/etc/cron.{hourly,daily,weekly,monthly}`

```bash
crontab -e         # 현재 사용자 crontab 편집
crontab -l         # 목록 보기
crontab -r         # 삭제
sudo crontab -e -u www-data   # 특정 사용자 crontab
```

### 시간 포맷(리캡 + 별표/쉼표/슬래시)
```
분  시  일  월  요일  명령
0-59 0-23 1-31 1-12 0-7(일=0 또는 7)
```
- 범위: `1-5`, 목록: `1,10,20`, 간격: `*/5` (매 5분)
- **`/etc/crontab`와 `/etc/cron.d/*`**에서는 **사용자 필드**가 추가된다:
```
분 시 일 월 요일  사용자  명령
```

### 자주 쓰는 별칭(지원되는 배포판에서만)
```crontab
@reboot   /usr/local/bin/on_boot.sh
@yearly   /usr/local/bin/job.sh
@monthly  /usr/local/bin/job.sh
@weekly   /usr/local/bin/job.sh
@daily    /usr/local/bin/job.sh
@hourly   /usr/local/bin/job.sh
```

### 기본 예시(리캡)
```crontab
# 매일 07:00
0 7 * * * /home/user/backup.sh

# 매주 일요일 23:00
0 23 * * 0 /home/user/cleanup.sh

# 5분마다
*/5 * * * * /usr/local/bin/status_log.sh
```

### **환경 변수/경로/로케일** — cron에서 가장 흔한 함정
- cron은 **매우 제한된 환경**으로 실행된다. `$PATH`가 짧고, 쉘 초기화 파일을 읽지 않는다.
- 안전한 호출: **절대경로 사용** + 스크립트에서 `PATH`와 `WORKDIR`를 **명시**.

```crontab
# 사용자 crontab 최상단에 환경 설정 (일부 구현에서 허용)
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
LANG=ko_KR.UTF-8
MAILTO=""
```

```bash
# /usr/local/bin/status_log.sh (예시)
#!/bin/bash
set -euo pipefail
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
cd /var/log/myapp
/usr/bin/env >> env.dump 2>&1
```

### **로그 관리** — 표준 출력/에러 리다이렉션
```crontab
# 표준출력과 에러를 파일로
*/5 * * * * /usr/local/bin/status_log.sh >> /var/log/status.log 2>&1

# 날짜 스탬프(rotate 고려)
0 2 * * * /usr/local/bin/backup.sh >> /var/log/backup/$(date +\%F).log 2>&1
```
- `logrotate`와 연계하거나, **journal**에 남기고 싶다면 cron 대신 **systemd timer + service**를 고려.

### **동시 실행 방지(잠금)** — `flock` 패턴(매우 중요)
동일 작업이 겹치면 데이터/장치 충돌이 나기 쉽다. `flock`으로 **뮤텍스**를 잡는다.
```crontab
*/5 * * * * /usr/bin/flock -n /var/lock/status.lock /usr/local/bin/status_log.sh >> /var/log/status.log 2>&1
```
- `-n`은 잠금 실패 시 즉시 종료. 누적 실행 방지.

### **런너 패턴(run-parts)** — 디렉터리 단위 실행
```crontab
# 시스템 crontab의 전형
01 * * * * root run-parts --report /etc/cron.hourly
```
- `/etc/cron.daily/` 등에 스크립트를 배치하면 유지보수 용이.

### **권한 제어** — 허용/차단 리스트
- `/etc/cron.allow`, `/etc/cron.deny`로 사용자별 사용 가능 여부 관리(배포판 차이 있음).

### **anacron** — 주기가 지나도 “다음에 보상 실행”
- 랩탑/비상주 서버처럼 자정에 꺼져 있으면 **cron이 놓친다** → anacron이 다음 부팅 시 **보상 실행**.
- 설정: `/etc/anacrontab`

```ini
# period  delay  job-id        command
1         10     cron.daily    run-parts /etc/cron.daily
7         25     cron.weekly   run-parts /etc/cron.weekly
30        45     cron.monthly  run-parts /etc/cron.monthly
```

---

## at — **1회성** 작업 예약(야간 단발 커맨드)
```bash
# 03:00에 재부팅
echo "reboot" | at 03:00

# 90분 후 애플리케이션 재시작
echo "systemctl restart myapp" | at now + 90 minutes

# 자주 쓰는 시간 표현
at 14:30
at midnight
at now + 1 hour
```

관련 명령:
```bash
atq            # 대기 중인 작업
at -c <jobid>  # 작업 내용 보기
atrm <jobid>   # 작업 취소
```

**주의**: `atd`가 실행 중인지 확인.
```bash
sudo systemctl status atd
sudo systemctl enable --now atd
```

---

## systemctl — 현대 리눅스의 서비스 관리(핵심)

### 기본 명령(리캡)
```bash
sudo systemctl start|stop|restart nginx
sudo systemctl status nginx
sudo systemctl enable nginx
sudo systemctl disable nginx
sudo systemctl is-enabled nginx
```

### 서비스 목록/검색
```bash
systemctl list-units --type=service --state=running
systemctl list-unit-files --type=service
```

### **로그/최근 이벤트와 연계**
```bash
journalctl -u nginx -b -n 200
journalctl -fu nginx
```

### 서비스 유닛 구조(핵심 옵션)
```ini
# /etc/systemd/system/myapp.service
[Unit]
Description=My App
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
EnvironmentFile=/etc/myapp/env
ExecStart=/usr/local/bin/myapp --config /etc/myapp/conf.yml
Restart=on-failure
RestartSec=5s
User=myapp
Group=myapp
# 리소스 보호(보안 하드닝)
ProtectSystem=full
ProtectHome=true
NoNewPrivileges=true
PrivateTmp=true
# 제한(예: 파일디스크립터)
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
```

- **재시작 정책**: `Restart=on-failure|always|no` (+ `RestartSec=`)  
- **순서 제어**: `After=`, `Requires=`, `Wants=`  
- **보안**: `ProtectSystem`, `ProtectHome`, `PrivateTmp`, `CapabilityBoundingSet`, `AmbientCapabilities`, `NoNewPrivileges`  
- **환경 변수**: `Environment=` 또는 `EnvironmentFile=`

### 유닛 파일 커스터마이즈(Override)
```bash
sudo systemctl edit myapp.service
# 편집 화면에서 [Service] 섹션에 필요한 키만 덧씌우기
```
- `/etc/systemd/system/myapp.service.d/override.conf` 생성됨  
- 수정 후:
```bash
sudo systemctl daemon-reload
sudo systemctl restart myapp
```

### 서비스 헬스체크(Watchdog)
- `Type=notify` + `WatchdogSec=` 조합 시, 프로세스가 주기적으로 **sd_notify**로 살아있음을 알리지 않으면 systemd가 재시작.

---

## systemd **timer** — “cron의 현대적 대안”
cron 대신 **.service + .timer** 조합으로 주기 실행을 관리한다. 장점:
- **journal**로 로그 표준화
- **의존성/순서/보안**을 서비스 유닛 그대로 상속
- **랜덤 지연(RandomizedDelaySec)**으로 스파이크 방지
- **퍼시스턴스(Persistent=true)**로 놓친 실행 보상

### .service 예시(업무 로직)
```ini
# /etc/systemd/system/myjob.service
[Unit]
Description=Nightly backup

[Service]
Type=oneshot
ExecStart=/usr/local/bin/backup.sh
User=backup
Group=backup
Nice=10
IOSchedulingClass=best-effort
IOSchedulingPriority=7
```

### .timer 예시(스케줄링)
```ini
# /etc/systemd/system/myjob.timer
[Unit]
Description=Nightly backup (timer)

[Timer]
OnCalendar=02:00
Persistent=true
RandomizedDelaySec=5m        # 02:00~02:05 사이 랜덤 시작
AccuracySec=1min
Unit=myjob.service

[Install]
WantedBy=timers.target
```

활성화/상태/다음 실행:
```bash
sudo systemctl enable --now myjob.timer
systemctl list-timers
systemctl status myjob.timer
journalctl -u myjob.service --since today
```

### OnCalendar 문법(자주 쓰는 패턴)
```ini
OnCalendar=daily
OnCalendar=Mon..Fri 09:00
OnCalendar=*-*-01 00:15        # 매월 1일 00:15
OnCalendar=*-*-* 03:00:00      # 매일 03:00
OnCalendar=Sat,Sun 01:30
```

### cron vs systemd timer 비교(현업 관점)
| 항목 | cron | systemd timer |
|---|---|---|
| 로그 | 파일 리다이렉션 필요 | journalctl로 표준화 |
| 보안/격리 | 제한적 | 다양한 sandbox 옵션 |
| 의존성 | 없음 | `After=`/`Wants=` 등 풍부 |
| 놓친 실행 보상 | anacron 필요 | `Persistent=true` 내장 |
| 랜덤 분산 | 직접 스크립팅 | `RandomizedDelaySec=` |
| 단일 실패 재시도 | 직접 구현 | `Restart=`(서비스) 활용 가능 |

---

## service — 전통 SysV 호환 래퍼
```bash
sudo service ssh restart
sudo service nginx status
```
- systemd 환경에서는 내부적으로 `systemctl`을 호출하는 래퍼인 경우가 많다. 새 작업은 **systemctl**을 기본으로.

---

## 실전 시나리오와 모범 패턴

### 1) **백업 작업**: 동시 실행 방지 + 로그 + 알림
```bash
# /usr/local/bin/backup.sh
#!/bin/bash
set -euo pipefail
LOG=/var/log/backup/backup_$(date +%F).log
{
  echo "== $(date) backup start =="
  /usr/bin/rsync -a --delete /data/ /backup/data/
  echo "== $(date) backup done =="
} >> "$LOG" 2>&1
```

**cron (flock 적용)**:
```crontab
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
0 2 * * * /usr/bin/flock -n /var/lock/backup.lock /usr/local/bin/backup.sh
```

**systemd timer 대안**: 위의 `.service`/`.timer` 조합 사용(추천).

---

### 2) **로그 정리**: logrotate 호출 vs journal vacuum
```crontab
# 매일 자정, logrotate 실행
0 0 * * * /usr/sbin/logrotate /etc/logrotate.conf
```

**journald 용량 제한(참고)**:
```bash
sudo journalctl --vacuum-time=30d
```
→ 운영 정책에 따라 cron/timer로 주기 관리 가능.

---

### 3) **패치 후 서비스 롤링 재시작**: 의존성·재시작 전략
```ini
# /etc/systemd/system/reload-nginx.service
[Unit]
Description=Reload NGINX gracefully
After=network-online.target

[Service]
Type=oneshot
ExecStart=/bin/sh -c '/usr/sbin/nginx -t && systemctl reload nginx'
```

```ini
# /etc/systemd/system/reload-nginx.timer
[Unit]
Description=Nightly nginx reload

[Timer]
OnCalendar=03:15
RandomizedDelaySec=3m
Unit=reload-nginx.service

[Install]
WantedBy=timers.target
```

---

### 4) **헬스체크 + 자동자기치유**: Restart Policy
```ini
# /etc/systemd/system/myapp.service
[Service]
Type=simple
ExecStart=/usr/local/bin/myapp
Restart=on-failure
RestartSec=5s
```
- 앱 내부에 `/healthz` 제공 → 외부에서 `curl -f`로 타이머/별도 서비스로 체크 후 `systemctl restart myapp` 트리거 가능.

---

### 5) **1회성 야간 재부팅 예약** (승인 받았음)
```bash
echo "systemctl reboot" | at 02:30
atq
```
- 변경 필요 시 `atrm <jobid>`로 취소.

---

## 문제 해결 팁(트러블슈팅 플레이북)

### cron이 “작동 안 하는 것처럼” 보일 때
1) **PATH/환경** 문제 가능성 → 절대경로/환경 설정.  
2) `set -x`로 디버깅 로그 남기기.  
3) 권한/실행비트/해당 사용자 권한 확인.  
4) SELinux/AppArmor 정책.  
5) `run-parts` 네이밍 규칙(숫자·알파벳·하이픈 등만)을 어겼는지 확인.

### systemd timer가 안 뛰는 경우
```bash
systemctl list-timers | grep myjob
systemctl status myjob.timer
journalctl -u myjob.service -b -n 200
```
- `WantedBy=timers.target`로 enable했는지, `daemon-reload`를 했는지 체크.

### 서비스가 재시작 루프에 빠질 때
- `RestartSec` 늘리기, `StartLimitInterval`/`StartLimitBurst` 조정.  
- 로그 분석 후 실패 원인 제거. 필요하면 **백오프** 스크립트 추가.

---

## 보안/운영 베스트 프랙티스 정리
- **원격 명령**은 최대한 **서비스 유닛**으로 표준화하고, 타이머를 사용해 스케줄링.
- **로그 표준화**: systemd timer + journal → 중앙 수집(예: Loki/ELK) 연동.
- **동시 실행 방지**: `flock` 습관화.
- **리소스 보호**: 서비스 유닛의 `ProtectSystem`, `NoNewPrivileges`, `PrivateTmp` 등 적극 활용.
- **권한 최소화**: 전용 사용자/그룹으로 실행, `sudo` 필요 시 `sudoers`에 명령 단위 부여.
- **설정 외부화**: `EnvironmentFile`로 비밀/경로를 분리, 권한 0600 유지.
- **백업**: crontab/유닛 파일을 Git에 IaC로 관리(버전/리뷰/롤백 용이).

---

## 명령어 요약(치트시트)

| 범주 | 명령/파일 | 설명 |
|---|---|---|
| cron(사용자) | `crontab -e|-l|-r` | 사용자별 주기 예약 |
| cron(시스템) | `/etc/crontab`, `/etc/cron.d/*` | 시스템 전역 예약 |
| anacron | `/etc/anacrontab` | 놓친 작업 보상 실행 |
| at | `at`, `atq`, `at -c`, `atrm` | 1회성 예약 |
| flock | `/usr/bin/flock` | 동시 실행 방지 잠금 |
| systemctl | `start|stop|restart|status` | 서비스 제어 |
| enable/disable | `systemctl enable|disable` | 부팅시 자동 시작 |
| journalctl | `-u`, `-f`, `-b` | 서비스 로그 조회 |
| timer | `.service` + `.timer` | systemd 스케줄러 |
| list-timers | `systemctl list-timers` | 타이머 스케줄 확인 |

---

## 부록 A: 예제 — cron에서 systemd timer로 마이그레이션

### 기존 cron
```crontab
# 매일 01:10, 데이터 동기화
10 1 * * * /usr/bin/flock -n /var/lock/sync.lock /usr/local/bin/sync.sh >> /var/log/sync.log 2>&1
```

### 변환된 systemd
```ini
# /etc/systemd/system/sync.service
[Unit]
Description=Nightly data sync

[Service]
Type=oneshot
ExecStart=/usr/local/bin/sync.sh
User=syncuser
Group=syncuser
ProtectSystem=full
NoNewPrivileges=true
PrivateTmp=true
```

```ini
# /etc/systemd/system/sync.timer
[Unit]
Description=Nightly data sync (timer)

[Timer]
OnCalendar=*-*-* 01:10:00
RandomizedDelaySec=2m
Persistent=true
Unit=sync.service

[Install]
WantedBy=timers.target
```

활성화:
```bash
sudo systemctl daemon-reload
sudo systemctl enable --now sync.timer
systemctl list-timers | grep sync
```

---

## 부록 B: 예제 — 특정 사용자로만 도는 cron + sudoers 최소 권한
```crontab
# (user: report) 매일 06:00 보고서 생성
0 6 * * * /usr/local/bin/generate_report.sh | mail -s "report" ops@example.com
```
```text
# /etc/sudoers.d/report
report ALL=(www-data) NOPASSWD: /usr/local/bin/publish_report.sh
```
- `generate_report.sh` 안에서 `sudo -u www-data /usr/local/bin/publish_report.sh` 호출.

---

## 마무리
- **반복 작업**은 cron 또는 **systemd timer**로, **1회성 작업**은 `at`으로, **서비스 수명주기**는 `systemctl`로 관리한다.  
- 운영의 핵심은 **표준화·로그·보안·동시성 제어**다. 절대경로/환경/잠금/정책을 습관화하고, 가능하면 **timer+service**로 일원화하여 관측성(journal)과 재현성(IaC)을 확보하자.  
- 위의 예제들을 그대로 붙여 넣어 시작하고, 팀 환경(계정/경로/저장소/알림)을 채워 **운영 플레이북**으로 굳히면, 장애 대응 속도와 품질이 반드시 향상된다.