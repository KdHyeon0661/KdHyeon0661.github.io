---
layout: post
title: Django - 비동기 & 실시간
date: 2025-10-01 21:25:23 +0900
category: Django
---
# 5. 비동기 & 실시간

## A. ASGI 이해 — WSGI와의 차이, Django async view

### A-1. WSGI vs ASGI 요약

| 항목 | WSGI | ASGI |
|---|---|---|
| 프로토콜 | 동기 HTTP 1.x | **비동기** HTTP/2, WebSocket, 장기 연결 |
| 실행 모델 | 스레드/프로세스 풀 | 이벤트 루프(코루틴) + 백프레셔 |
| 장점 | 단순/성숙 | **실시간/스트리밍/양방향** 가능, 고동시성 |
| 서버 | gunicorn+gthread/uwsgi | **uvicorn**, **daphne**, hypercorn |

핵심: **Django 3.1+** 는 **ASGI 애플리케이션**을 네이티브로 제공. 동기 뷰와 비동기 뷰가 **혼재** 가능하며, Django가 필요한 경계에서 자동으로 thread offloading(bridge)을 처리합니다.

### A-2. Django async view

```python
# apps/core/views.py
from django.http import JsonResponse
import asyncio

async def ping(request):
    await asyncio.sleep(0.01)  # I/O 시뮬레이션
    return JsonResponse({"ok": True})
```

- **규칙**  
  - DB ORM 호출은 **동기**이므로, **async 뷰에서 직접 ORM**을 호출하지 말고 필요한 경우 `sync_to_async` 로 감쌉니다.  
  - CPU 바운드 작업은 이벤트 루프를 막음 → **작업 큐**(Celery)나 **프로세스 풀**로 오프로딩.

```python
# ORM 호출 offloading
from asgiref.sync import sync_to_async
from django.contrib.auth.models import User

async def me(request):
    user = await sync_to_async(User.objects.get)(pk=request.user.pk)
    return JsonResponse({"username": user.username})
```

### A-3. 배포 스케치(ASGI 서버)

```bash
pip install uvicorn[standard]
# 개발/테스트
uvicorn config.asgi:application --reload --port 8000
```

Gunicorn + Uvicorn workers:
```bash
pip install "uvicorn[standard]" gunicorn
gunicorn config.asgi:application -k uvicorn.workers.UvicornWorker -w 4 -b 0.0.0.0:8000
```

> 운영 팁  
> - **CPU 코어 수**와 **I/O 특성**에 맞게 워커/Concurrency 조정  
> - **graceful shutdown** 시 WebSocket/stream 정리, **health check** 엔드포인트 제공

---

## B. Channels — WebSocket, Channel layers(Redis), 실시간 알림/채팅

### B-1. 설치 & 기본 세팅

```bash
pip install channels channels-redis
```

```python
# config/settings/base.py
INSTALLED_APPS += ["channels"]
ASGI_APPLICATION = "config.asgi.application"

# Channel Layer(브로커) - Redis 권장
CHANNEL_LAYERS = {
  "default": {
    "BACKEND": "channels_redis.core.RedisChannelLayer",
    "CONFIG": {"hosts": [("redis", 6379)]}
  }
}
```

`config/asgi.py`:
```python
import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
from django.urls import path
from apps.realtime import consumers as rt

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings.base")

django_app = get_asgi_application()

application = ProtocolTypeRouter({
    "http": django_app,
    "websocket": AuthMiddlewareStack(
        URLRouter([
            path("ws/ping/", rt.PingConsumer.as_asgi()),
            path("ws/chat/<str:room>/", rt.ChatConsumer.as_asgi()),
            path("ws/notify/", rt.NotifyConsumer.as_asgi()),
        ])
    ),
})
```

### B-2. Consumer 기초(AsyncJsonWebsocketConsumer)

```python
# apps/realtime/consumers.py
from channels.generic.websocket import AsyncJsonWebsocketConsumer

class PingConsumer(AsyncJsonWebsocketConsumer):
    async def connect(self):
        await self.accept()  # 핸드셰이크 허용
        await self.send_json({"hello": "world"})

    async def receive_json(self, content, **kwargs):
        if content.get("ping"):
            await self.send_json({"pong": content["ping"]})

    async def disconnect(self, code):
        # 정리 작업 (리소스/그룹 탈퇴)
        pass
```

### B-3. 그룹 통신과 알림

- **Channel Layer** 로 **그룹 브로드캐스트** 가능(예: user:{id}, room:{slug}).

```python
# apps/realtime/consumers.py
from channels.generic.websocket import AsyncJsonWebsocketConsumer
from channels.layers import get_channel_layer

class NotifyConsumer(AsyncJsonWebsocketConsumer):
    async def connect(self):
        if self.scope["user"].is_anonymous:
            await self.close()
            return
        self.group = f"user:{self.scope['user'].pk}"
        await self.channel_layer.group_add(self.group, self.channel_name)
        await self.accept()

    async def disconnect(self, code):
        await self.channel_layer.group_discard(self.group, self.channel_name)

    async def notify(self, event):
        # group_send 로 전달된 이벤트를 받아 클라이언트에 전송
        await self.send_json(event["data"])
```

서버 측 트리거(HTTP 뷰나 Celery 태스크에서):
```python
# apps/realtime/push.py
import asyncio
from channels.layers import get_channel_layer

async def push_to_user(user_id, payload: dict):
    layer = get_channel_layer()
    await layer.group_send(f"user:{user_id}", {"type": "notify", "data": payload})

# 동기 코드에서 호출 시
from asgiref.sync import async_to_sync
def push_to_user_sync(user_id, payload):
    async_to_sync(push_to_user)(user_id, payload)
```

### B-4. 채팅 예제(방 입장/퇴장/메시지)

```python
# apps/realtime/consumers.py
class ChatConsumer(AsyncJsonWebsocketConsumer):
    async def connect(self):
        self.room = self.scope["url_route"]["kwargs"]["room"]
        self.group = f"room:{self.room}"
        await self.channel_layer.group_add(self.group, self.channel_name)
        await self.accept()
        await self.channel_layer.group_send(self.group, {
            "type": "chat.event", "data": {"system": f"{self.channel_name} joined"}
        })

    async def disconnect(self, code):
        await self.channel_layer.group_discard(self.group, self.channel_name)
        await self.channel_layer.group_send(self.group, {
            "type": "chat.event", "data": {"system": f"{self.channel_name} left"}
        })

    async def receive_json(self, content, **kwargs):
        msg = content.get("message", "")
        await self.channel_layer.group_send(self.group, {
            "type": "chat.event", "data": {"message": msg}
        })

    async def chat.event(self, event):
        await self.send_json(event["data"])
```

**프런트엔드 스니펫(브라우저 WebSocket):**
```html
<script>
  const sock = new WebSocket(`wss://${location.host}/ws/chat/general/`);
  sock.onmessage = (e) => {
    const data = JSON.parse(e.data);
    console.log("recv", data);
  };
  function send() {
    sock.send(JSON.stringify({message: document.querySelector("#msg").value}));
  }
</script>
<input id="msg"><button onclick="send()">send</button>
```

### B-5. 인증/권한, 토큰 바인딩

- `AuthMiddlewareStack` 는 **세션 인증**을 WebSocket에 투영.  
- SPA/JWT 기반이면 **커스텀 미들웨어**로 **헤더/쿼리 토큰** 검증 후 `scope["user"]` 설정.

```python
# apps/realtime/middleware.py
from channels.middleware import BaseMiddleware
from django.contrib.auth.models import AnonymousUser
from rest_framework_simplejwt.authentication import JWTAuthentication

class JWTAuthMiddleware(BaseMiddleware):
    async def __call__(self, scope, receive, send):
        headers = dict(scope.get("headers", []))
        token = headers.get(b"authorization", b"").decode()
        user = AnonymousUser()
        if token.startswith("Bearer "):
            try:
                user, _ = JWTAuthentication().authenticate_credentials(
                    token.split(" ", 1)[1].encode()
                )
            except Exception:
                pass
        scope["user"] = user
        return await super().__call__(scope, receive, send)
```

`asgi.py` 에서 `AuthMiddlewareStack` 대신 체인:

```python
from channels.routing import ProtocolTypeRouter, URLRouter
from apps.realtime.middleware import JWTAuthMiddleware

application = ProtocolTypeRouter({
  "http": django_app,
  "websocket": JWTAuthMiddleware(URLRouter([...]))
})
```

### B-6. Presence(온라인 여부), 타임아웃, 백프레셔

- 접속 시 **group_add**, 종료 시 **group_discard**, 주기적인 **heartbeat** 를 받아 **레디스 Set** 로 사용자 온라인 목록 관리.  
- 느린 소비자에게는 **send queue** 길이 제한 → 초과 시 **강제 종료** 또는 **샘플링**.  
- 대량 브로드캐스트는 **Fan-out** 구조(생산자 1 → Redis Pub/Sub → 여러 컨슈머)로 분리.

### B-7. 스케일링 & 배포

- **Channels worker** 는 ASGI 서버(uvicorn/daphne) 프로세스와 동일. **여러 인스턴스**가 Redis 채널 레이어를 공유.  
- **Sticky session 불필요**(메시지는 Redis 그룹 브로드캐스트).  
- **헬스체크**: `/healthz` 를 HTTP로, WebSocket은 **ping/pong** 구현.

---

## C. 작업 큐 — Celery/Redis, 스케줄러(Beat), 재시도/아이들포인트 설계

### C-1. 설치 & 최소 설정

```bash
pip install celery[redis] django-redis
```

디렉터리:
```
config/
  __init__.py
  celery.py
apps/
  tasks.py
```

`config/celery.py`:
```python
import os
from celery import Celery

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings.base")
app = Celery("myproj")
app.config_from_object("django.conf:settings", namespace="CELERY")
app.autodiscover_tasks()
```

`config/__init__.py`:
```python
from .celery import app as celery_app
__all__ = ("celery_app",)
```

`settings.py`:
```python
CELERY_BROKER_URL = "redis://redis:6379/2"
CELERY_RESULT_BACKEND = "redis://redis:6379/3"  # 선택
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TIMEZONE = "Asia/Seoul"
CELERY_TASK_TIME_LIMIT = 60           # hard limit
CELERY_TASK_SOFT_TIME_LIMIT = 50      # soft limit
CELERY_WORKER_MAX_TASKS_PER_CHILD = 1000
CELERYD_PREFETCH_MULTIPLIER = 4
```

실행:
```bash
celery -A config worker -l info
```

### C-2. 태스크 작성/호출

```python
# apps/notifications/tasks.py
from celery import shared_task
from django.core.mail import send_mail

@shared_task(bind=True, autoretry_for=(Exception,), retry_backoff=True, max_retries=5)
def send_welcome_mail(self, to, name):
    send_mail("환영합니다", f"{name}님 반갑습니다.", None, [to])
```

호출:
```python
from apps.notifications.tasks import send_welcome_mail
send_welcome_mail.delay("user@example.com", "홍길동")  # 비동기
# 카운트다운/ETA
send_welcome_mail.apply_async(("u@example.com", "홍"), countdown=30)
```

### C-3. 체이닝/그룹/체인-콜백

```python
from celery import chain, group
from apps.reports.tasks import build_dataset, render_pdf, upload_storage

workflow = chain(
    build_dataset.s(params={"range": "yesterday"}),
    render_pdf.s(template="daily.html"),
    upload_storage.s(path="daily/2025-10-20.pdf")
)
workflow.delay()

# 병렬 그룹 후 집계
daily = group(build_dataset.s({"day": d}) for d in ["mon","tue","wed"])
(daily | render_pdf.s("weekly.html") | upload_storage.s("weekly/..")).delay()
```

### C-4. 재시도/멱등성/아이들포인트

- 태스크는 **외부 연동(네트워크)** 로 실패 가능 → `autoretry_for`, **지수 백오프**.  
- **멱등성 키**: 같은 입력에 대해 **한 번만** 처리되도록 키를 설계(예: 주문ID).  
- **아이들포인트(중간저장)**: 대용량 처리 시 **체크포인트**를 저장해 중간부터 재개.

```python
@shared_task(bind=True, max_retries=3, autoretry_for=(TimeoutError,))
def charge(self, order_id):
    # 이미 처리했는지 검사
    from apps.orders.models import PaymentRequest
    if PaymentRequest.objects.filter(order_id=order_id, status="DONE").exists():
        return "ok"
    # 외부 결제 호출 ...
```

### C-5. Beat(스케줄러)

```bash
celery -A config beat -l info
```

정적 스케줄(설정):
```python
# settings.py
from celery.schedules import crontab
CELERY_BEAT_SCHEDULE = {
  "cleanup-temp-hourly": {
    "task": "apps.housekeeping.tasks.cleanup_temp",
    "schedule": crontab(minute=0),  # 매시 정각
  },
  "send-digest-morning": {
    "task": "apps.notifications.tasks.send_digest",
    "schedule": crontab(minute=0, hour=9),
  },
}
```

### C-6. 성능/운영 파라미터

- **prefetch_multiplier**: 큐에서 한 번에 가져오는 작업 수(높을수록 처리량↑, 공정성↓)  
- **acks_late**: 작업 완료 후 ACK → 워커 크래시 시 **재배달** 가능(멱등성 필수)  
- **concurrency**: 워커 동시성(프로세스/스레드/이벤트루프)  
- **autoscale**: 피크 대비 자동 확장 `--autoscale=20,4`

```bash
celery -A config worker -l info --concurrency=8 --prefetch-multiplier=4 --max-tasks-per-child=500
```

### C-7. Django/ASGI와 Celery의 역할 분담

- **ASGI**: 실시간/양방향, 빠른 응답, 짧은 I/O  
- **Celery**: 무거운 I/O/CPU, 장기 작업, 재시도/스케줄  
- **Channels → Celery**: WebSocket에서 받은 요청을 Celery로 오프로딩하고, 처리 완료 시 **Channel Layer** 로 알림 푸시.

```python
# apps/realtime/bridge.py
from asgiref.sync import async_to_sync
from channels.layers import get_channel_layer

def notify_user(user_id, payload):
    async_to_sync(get_channel_layer().group_send)(
        f"user:{user_id}", {"type": "notify", "data": payload}
    )
```

```python
# apps/reports/tasks.py
from celery import shared_task
from apps.realtime.bridge import notify_user

@shared_task
def build_report_and_notify(user_id):
    # ... 무거운 처리
    notify_user(user_id, {"type": "report_ready"})
```

---

## D. 종합 실전 예제 — “실시간 알림 + 채팅 + 대용량 PDF 생성 오프로딩”

### D-1. WebSocket 알림 흐름

1) 클라이언트가 `/ws/notify/` 연결 → 서버가 `user:{id}` 그룹에 가입  
2) 사용자가 “PDF 생성” 클릭 → HTTP POST `/api/reports/`  
3) DRF 뷰가 **Celery 태스크 큐**에 작업 enqueue → 즉시 202 Accepted 반환  
4) 태스크가 완료되면 `notify_user(id, {"event":"pdf_ready", "url": ...})`  
5) 클라이언트 WebSocket 수신 → **다운로드 버튼** 활성화

**뷰 스케치:**
```python
# apps/reports/api.py
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from .tasks import build_report_and_notify

@api_view(["POST"])
@permission_classes([IsAuthenticated])
def create_report(request):
    build_report_and_notify.delay(request.user.id)
    return Response(status=202)
```

**프런트:**
```javascript
const ws = new WebSocket(`wss://${location.host}/ws/notify/`);
ws.onmessage = (e) => {
  const data = JSON.parse(e.data);
  if (data.event === "pdf_ready") {
    document.querySelector("#download").href = data.url;
    document.querySelector("#download").disabled = false;
  }
};
```

### D-2. 채팅 방 + 권한

- 방 접근 권한: URL의 `room` 을 **프로젝트/조직 ID**로 매핑, 권한 검사 후 입장 허용  
- 메시지 저장: `receive_json` 에서 DB 저장은 **sync_to_async** 로 오프로딩하거나 Celery로 처리  
- 욕설 필터/스팸 방지: **스로틀링/쿨다운**, **실시간 모더레이션 태스크**(비동기) 적용

```python
from asgiref.sync import sync_to_async
from apps.chat.models import Message

class ChatConsumer(AsyncJsonWebsocketConsumer):
    async def receive_json(self, content, **kwargs):
        msg = content.get("message","")
        await sync_to_async(Message.objects.create)(
            room=self.room, user=self.scope["user"], body=msg
        )
        await self.channel_layer.group_send(self.group, {"type":"chat.event","data":{"message":msg}})
```

---

## E. 보안/안정성/성능 체크리스트

**ASGI/Channels**
- [ ] WebSocket **인증/권한**: 세션 또는 JWT 미들웨어  
- [ ] **스루틀/레이트리밋**: 연결/초당 메시지/메시지 크기 제한  
- [ ] **백프레셔**: send 큐 길이, 타임아웃 → 과부하 시 연결 종료  
- [ ] **메시지 스키마 검증**(pydantic 등)  
- [ ] **Channel Layer** 장애 시 폴백(일시적으로 HTTP 폴링) 또는 사용자 알림

**Celery**
- [ ] **멱등성**: 외부 연동/결제/이메일 중복 방지  
- [ ] **재시도 정책**: 네트워크 예외만, 비즈니스 오류는 재시도 금지  
- [ ] **Time limit** & **메모리 누수** 대비 `max_tasks_per_child`  
- [ ] **모니터링**: Flower/Prometheus, 실패 큐(DLQ) 및 재처리 도구  
- [ ] **스케줄**: Beat HA(리더 선출) 또는 외부 스케줄러(Argo/Cloud Scheduler)

**공통**
- [ ] **구성 가능성**: 환경변수 기반(브로커 URL, Redis, Throttle)  
- [ ] **로깅/트레이싱**: Request-ID, Correlation-ID를 Channels/Celery에 전파  
- [ ] **테스트**: Channels `WebsocketCommunicator`, Celery `CELERY_TASK_ALWAYS_EAGER=True` 모드

---

## F. 테스트 스니펫

### F-1. Channels 테스트

```python
# tests/test_chat.py
import pytest
from channels.testing import WebsocketCommunicator
from config.asgi import application

@pytest.mark.asyncio
async def test_ping():
    comm = WebsocketCommunicator(application, "/ws/ping/")
    connected, _ = await comm.connect()
    assert connected
    await comm.send_json_to({"ping": "hi"})
    resp = await comm.receive_json_from()
    assert resp["pong"] == "hi"
    await comm.disconnect()
```

### F-2. Celery eager 테스트

```python
# conftest.py
import pytest
from django.conf import settings

@pytest.fixture(autouse=True)
def celery_eager(settings):
    settings.CELERY_TASK_ALWAYS_EAGER = True
    settings.CELERY_TASK_EAGER_PROPAGATES = True
    yield
```

---

## G. 운영 레퍼런스 설정 모음

### G-1. Nginx 리버스 프록시 (WebSocket 업그레이드)

```nginx
map $http_upgrade $connection_upgrade {
  default upgrade;
  ''      close;
}

server {
  location / {
    proxy_pass http://app:8000;
    proxy_set_header Host $host;
  }
  location /ws/ {
    proxy_pass http://app:8000;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;
    proxy_set_header Host $host;
  }
}
```

### G-2. 프로세스 구성 예

- **ASGI 서버**(uvicorn) × N개  
- **Celery 워커** × M개 (큐 타입별 분리: `high`, `default`, `low`)  
- **Celery Beat** × 1(HA 시 외부 스케줄러 고려)  
- **Redis** × 1+ (Channel Layer/브로커/백엔드 분리 권장)  
- **PostgreSQL** × 1+ (리드 레플리카)  
- **S3/오브젝트 스토리지** (파일/리포트/웹훅 로그)

---

## H. 추가 스니펫

### H-1. 메시지 검증(pydantic)

```python
from pydantic import BaseModel, ValidationError

class ChatMsg(BaseModel):
    message: str
    room: str

class ValidatingChatConsumer(AsyncJsonWebsocketConsumer):
    async def receive_json(self, content, **kwargs):
        try:
            data = ChatMsg(**content)
        except ValidationError as e:
            await self.send_json({"error": e.errors()}, close=True)
            return
        # ...
```

### H-2. 장기 스트리밍 응답(서버 센트 이벤트, SSE)

> SSE는 Channels 없이도 ASGI 뷰로 구현 가능. 양방향이 필요하면 WebSocket.

```python
from django.http import StreamingHttpResponse
import asyncio

async def sse(request):
    async def event_stream():
        yield "retry: 1000\n\n"
        for i in range(5):
            await asyncio.sleep(1)
            yield f"data: tick {i}\n\n"
    return StreamingHttpResponse(event_stream(), content_type="text/event-stream")
```

### H-3. Celery 라우팅(큐 분리)

```python
# settings.py
CELERY_TASK_ROUTES = {
  "apps.reports.tasks.*": {"queue": "reports"},
  "apps.notifications.tasks.*": {"queue": "noti"},
}
# 각각 워커 분리 실행
# celery -A config worker -Q reports -n reports@%h
# celery -A config worker -Q noti -n noti@%h
```

---

## 마무리

- **ASGI** 로 Django는 **실시간/양방향** 시대의 기본기를 갖췄습니다. **async view 규칙(ORM 오프로딩)** 을 지키고, 배포는 **uvicorn/daphne** 기준으로 구성하세요.  
- **Channels** 로 **WebSocket + Redis Channel Layer** 를 얹어 **알림/채팅/프레즌스** 를 안정적으로 운영하세요. **그룹 브로드캐스트/권한/백프레셔** 를 시스템적으로 설계하세요.  
- **Celery** 로 **장기·무거운 작업**을 오프로딩하고, **재시도/멱등성/스케줄**을 습관화하세요. **ASGI ↔ Celery** 브리지를 통해 **완료 알림**까지 자동화하면, 사용자 경험은 가볍고 즉시적이며, 서버는 건강해집니다.
