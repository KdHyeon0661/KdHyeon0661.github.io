---
layout: post
title: 형식언어와 오토마타 - 무제한 문법
date: 2025-08-05 17:20:23 +0900
category: 형식언어와 오토마타
---
# 무제한 문법(Unrestricted / Type-0 / Phrase-Structure Grammar)

**무제한 문법(Type-0)** 은 재작성 규칙의 형태에 사실상 제약이 없는 최상위 문법 모델로, **튜링 기계(TM)** 가 인식하는 바로 그 언어 계층(**RE: 재귀적 열거 가능**)과 **표현력이 정확히 일치**한다.

---

## 1. 형식적 정의

무제한 문법 \(G\) 는 4-튜플
$$
G=(V,\ \Sigma,\ R,\ S)
$$
- \(V\): **비단말(Nonterminals)** 의 유한 집합  
- \(\Sigma\): **터미널(알파벳)** 의 유한 집합, \(V\cap\Sigma=\varnothing\)  
- \(S\in V\): **시작기호**  
- \(R\subseteq (V\cup\Sigma)^+ \times (V\cup\Sigma)^*\): 재작성 규칙 \(\alpha\to\beta\)

**관례/요건**
- 좌변 \(\alpha\) 는 길이 \(\ge 1\) 이며 **적어도 하나의 비단말**을 포함(순수 단말 좌변 방지).  
- \(\varepsilon\) 생성이 필요하면 보통 **\(S\to\varepsilon\)** 만 허용하고 \(S\) 를 다른 규칙 우변에 올리지 않는다(표준 정리 편의).

**언어**
$$
L(G)=\{\, w\in\Sigma^* \mid S \Rightarrow^* w \,\},
$$
여기서 \(\Rightarrow\) 는 한 번의 규칙 적용(어디서나 치환), \(\Rightarrow^*\) 는 그 수반 폐포.

> 포인트: Type-0는 **문맥/길이 제약이 전혀 없음**. 따라서 Type-1(문맥 인식), Type-2(문맥 자유), Type-3(정규)보다 **상위**.

---

## 2. 표현력: **Type-0 = RE (튜링 인식 가능)**

$$
\boxed{\ \textbf{Type-0 언어}\ =\ \textbf{RE} \ }
$$

즉, **어떤 TM이 수용하는 모든 언어**를 Type-0 문법이 생성하고, 반대로 **Type-0 문법이 생성하는 모든 언어**를 어떤 TM이 수용한다.

### 2.1 \(G \Rightarrow\) TM (문법 → 인식기/열거기)

- **인식기(Recognizer)**: 입력 \(w\) 가 주어지면 TM이 **비결정적으로** 유도 \(S\Rightarrow^* w\) 를 시도한다. 한 단계 유도는 규칙 \(\alpha\to\beta\) 의 **국소 패턴 매칭 후 치환**. 어떤 경로라도 유도가 성공하면 **수용**.  
  ⇒ \(L(G)\) 는 **RE**.

- **열거기(Enumerator)**: 모든 파생 \(S\Rightarrow^* w\) 를 **도베일링**으로 폭넓게 펼쳐 **사전식**으로 출력(중복 제거 가능).  
  ⇒ 모든 \(w\in L(G)\) 가 **언젠가 출력**됨 → RE의 “열거 가능” 의미와 합치.

### 2.2 TM \(\Rightarrow\) \(G\) (기계 → 문법)

#### (i) **ID(instantaneous description)** 재작성으로 TM 전이 모사
구성(ID)을 문자열로 부호화:
- 양방향 테이프라면 경계 마커 ⊢, ⊣ 를 쓰고,
- **상태 심볼을 읽는 기호 바로 왼쪽/오른쪽에 삽입**하여 헤드 위치를 표현.

예) “상태 \(q\) 가 기호 \(b\) 를 읽음”을
```
... a  q  b  c ...
```
로 코딩(여기선 q가 b 위를 가리킨다고 약속). 전이 \((q,b)\mapsto(q',c,R)\) 는 **국소 치환**으로
```
a q b  ->  a c q'
```
처럼 만든다(왼쪽 이동은 주변 기호와 함께 처리). 시작은 **초기 구성**으로 시작하게 하고, 수용 상태 진입 후엔 **보조 마커/상태기호 제거 규칙**으로 순수 출력만 남긴다.  
⇒ 이렇게 하면 TM이 **수용하는 바로 그 집합**을 문법이 생성한다.

#### (ii) **Post/Thue 시스템 경유**
- **(semi-)Thue 시스템**: 임의 재작성 \(\alpha\to\beta\) 로 정의되는 문자열 시스템.  
- **Post 정규/정식 시스템**: **RE 집합**을 정확히 기술.  
Type-0 문법 ↔ Thue/Post ↔ TM 은 서로 **상호 변환 가능한 동치 모델**이다.

---

## 3. 정규화(참고)

Type-0에 Type-2의 CNF처럼 보편 정규형은 없으나, **TM-스타일 국소화**를 위해 다음과 같은 정형화가 쓰인다.

- 좌변에 **반드시 비단말 포함**(단말 좌변 제거).
- 상태/헤드/경계 **마커 기호**를 도입해 모든 전이를 **짧은 국소 규칙**의 묶음으로 표현.
- 연구 정규형 예: **Geffert normal form**(거칠게 말해 “거의 CF + 제한적 소거 규칙” 구성), **Penttonen/weak Greibach-like** 등.  
  목적은 **증명/환원 편의**이지, 실무 파싱을 위한 게 아니다.

---

## 4. 폐포(Closure) 성질

**RE(Type-0)** 는 다음에 **닫힘**:

- 합집합 \(\cup\), **교집합** \(\cap\)  
- 연접(\(\cdot\)), **Kleene★**  
- **호모모르피즘/역호모모르피즘**  
- **정규/결정 가능 언어**와의 교집합, **정규와의 좌/우 몫**(존재적 조건으로 RE 보존)

닫혀 있지 않은 대표 연산:

- **보수(Complement)** — 일반적으로 **No**  
- **차집합** — 일반적으로 **No**

> 스케치: RE의 \(\cup,\cap\) 는 두 **인식기**를 도베일링하면서 “**혹은/그리고**” 논리로 **수용** 시점을 정의하면 된다. 보수/차집합은 “거절 증거 부재”가 본질이라 깨진다.

---

## 5. 결정(Decidability) 성질

TM과 동치이므로, **정지 문제**·**Rice 정리**류 한계가 그대로 적용된다.

| 문제 | 결과 | 한 줄 이유 |
|---|---|---|
| **멤버십** \(w\in L(G)?\) | **RE-완전**(반결정) | “예”는 유도 찾으면 되나 “아니오”는 일반에선 무한 탐색 |
| **공백성** \(L(G)=\varnothing?\) | **결정 불가능** | 정지 문제로 환원 |
| **보편성** \(L(G)=\Sigma^*?\) | **결정 불가능** | Rice 류 속성 |
| **포함/동치** \(L(G_1)\subseteq L(G_2)?\) | **결정 불가능** | RE 전역 의미 속성 |
| **유한성/정규성/문맥자유성 여부** | 대부분 **결정 불가능** | 고전 환원 다수 |

---

## 6. 설계 패턴 — **TM을 문법으로**(현업 감각)

### 6.1 “계산 이력(history)” 생성 패턴
TM \(M\) 의 수용 계산을 다음 **행렬 문자열**로 코딩:
$$
\#\,C_0\,\#\,C_1\,\#\,\cdots\,\#\,C_t\,\#
$$
- 규칙군은 **이웃 구성 \(C_i \to C_{i+1}\)** 가 TM 전이에 의해 합법적일 때만 **국소 매칭**으로 이어지게 설계.  
- 마지막에 마커/상태를 제거하는 **정리 규칙**(또는 동형사상: 호모모르피즘)으로 **순수 출력만 남김**.

### 6.2 **헤드 이동** 국소화 스니펫(개념)

아래 표기에서 상태가 **읽는 기호 바로 왼쪽**에 놓인다고 가정:
- 구성 조각: `x q b y`  (q가 b를 읽음)

**오른쪽 이동** \((q,b)\mapsto(q',c,R)\):
```
x q b y  ->  x c q' y
```
**왼쪽 이동** \((q,b)\mapsto(q',c,L)\) 은 왼쪽 기호까지 포함:
```
a x q b y  ->  x q' a c y
```
(경계 ⊢, 공백 ␣, 테이프 확장 등은 보조 규칙으로 별도 처리)

> 실전 구현에선 다중 트랙/표식(예: ⊢, ⊣, ˄, ˃)으로 **한두 칸 주변만** 바꾸는 짧은 규칙 묶음을 만든다.

---

## 7. 사례 ①: **UNARY PLUS** 언어를 생성하는 Type-0(=Type-1도 가능) 구상

목표 언어:
$$
L_{\text{add}}=\{\, a^m\ \#\ a^n\ \#\ a^{m+n}\ \mid\ m,n\ge 0 \,\}.
$$

**아이디어**  
왼쪽 구간의 `a` 들을 하나씩 **오른쪽 구간 끝으로 이동**(계산 이력 방식). 규칙군(개념적):

```
S            ->  ⊢  a*  #  a*  #  ␣  ⊣      # 초기 포맷(정규식 기법은 실제 구현에선 확장)
# 이동 마커 주입
x a # y # z  ->  x # y # A z                 # 왼쪽 블록에서 a 하나를 '집기'(A는 "들고 있다" 마커)
A a          ->  a A                         # 집은 상태 유지하며 오른쪽으로 통과
A #          ->  # A
A a ␣        ->  a A ␣
A ␣ ⊣        ->  ␣ a ⊣                       # 맨 끝에 a 붙이기(= +1)
# 더 이상 왼쪽에 a 없으면 종료
# 마커/경계/여분 공백 삭제 규칙 ...
```

- 위는 **설계 감각**을 보여주는 축약 표기다. 실제 Type-0/1 문법에선 각 경우를 유한 다수 **국소 규칙**으로 풀어 쓴다.
- 이 전략은 **곱셈/거듭제곱** 등도 비슷하게 확장(마커 여러 개, 중첩 이동).

> 포인트: **“마커를 이동시켜 효과를 흉내”** 내는 게 재작성 기반 설계의 핵심 습관.

---

## 8. 사례 ②: **단순 TM**을 문법으로 직접 모사(초미니)

단일 테이프 TM \(M\) (입력 끝에서 **1을 덧셈**하는 기계)을 생각:
- 전이: “맨 오른쪽 공백에서 왼쪽으로 가며 첫 0→1 로 바꾸고 종료; 모두 1이면 맨 앞에 1 추가”

**ID 포맷**: `⊢ x q y ⊣` (q가 y의 첫 기호를 읽는다)

핵심 규칙(개념):
```
# 오른쪽 끝으로 달리기
q0 0  ->  0 q0
q0 1  ->  1 q0
q0 ␣  ->  1 q_acc             # ␣를 1로(맨 끝에 +1)

# '...10*␣' 패턴의 +1 전파
q0 1 ␣  ->  0 qL               # carry 생성, 왼쪽으로 이동
a qL 0  ->  q_acc 1            # 0->1로 올리고 종료
a qL 1  ->  qL 0               # 1->0로 바꾸고 계속 왼쪽
⊢ qL ⊢ -> 1 q_acc ⊢            # 모두 1이었으면 맨 앞에 1 추가
```
마지막으로 `q_acc, ⊢, ⊣` 등 보조 기호를 **삭제**하는 규칙을 더해 터미널만 남긴다.  
⇒ 이 전이들을 **문법 규칙**으로 옮기면 Type-0 문법 \(G_M\) 이 완성된다.

---

## 9. Post/Thue 시스템과의 관계

- **semi-Thue 시스템**은 **정확히 Type-0** 와 동치(알파벳/규칙의 재작성).  
- **Post 정식 시스템**은 RE를 정확히 기술하는 또 다른 고전 모델.  
- 실전 감소(예: **PCP** → TM/문법 불가능성)에서 문자열 재작성 관점이 **가젯 구성**에 아주 유리하다.

---

## 10. 실무·학습 팁(요약)

1) **국소화(Locality)**: 헤드/상태/경계 마커로 **최소 반경**의 규칙만 쓰는 습관.  
2) **정리(Cleanup)**: 계산 후 **마커 제거**(호모모르피즘)로 터미널만 남긴다.  
3) **도베일링**: 열거/인식기는 **무한 루프 회피** 대신 **레벨별 확장**으로 공정성을 확보.  
4) **폐포 활용**: 합/연접/호모모르피즘/정규교집합으로 **복합 언어 구성**을 단순화.  
5) **불가능성 인식**: 공백성·포함성 등은 **일반적으로 불가능** — 제약(길이 증가, 비축약 등)을 두어 하위 계층에서 풀자.

---

## 11. 미니 실험 — **열거기/반결정기** 의사코드

### 11.1 **열거기**(모든 파생을 사전식으로 출력)

```text
enumerate_Type0(G=(V,Σ,R,S)):
  Q := queue()
  Q.push(S)
  Seen := ∅
  while Q not empty:
    α := Q.pop()
    if α ∈ Σ* and α not in Seen:
      print(α)              # 언어 원소 출력
      Seen := Seen ∪ {α}
    # 한 단계 재작성(모든 위치/규칙 시험)
    for each position i in α:
      for each rule (ℓ -> r) in R:
        if α has substring ℓ at i:
          β := α with ℓ@i replaced by r
          if length(β) ≤ L_max(i):    # 선택적 폭발 방지 휴리스틱
             Q.push(β)
```

- **도베일링**으로 길이별/규칙별 균형 있게 전개하면, \(w\in L(G)\) 는 **언젠가** 출력된다.

### 11.2 **반결정 멤버십 검사**(“있으면 언젠가 찾는다”)

```text
semi_decide_member(G, w):
  frontier := {S}
  for steps = 0,1,2,...:
    next := ∅
    for α in frontier:
      if α == w: return ACCEPT
      for each (ℓ->r) and position i:
        if α has ℓ at i:
          next := next ∪ { α with ℓ@i replaced by r }
    frontier := frontier ∪ next           # BFS 스타일 도베일링
  # 해가 없으면 종료하지 않음 (RE 의미)
```

> **주의**: 일반 Type-0에서 “불포함”은 무한 대기. **결정기**가 되려면 문법/전개에 **강한 제약**(예: 길이 증가/단조성)이 필요하다.

---

## 12. FAQ

- **Q. 왜 보수에 닫히지 않나?**  
  **A.** RE가 보수에 닫히면 RE=coRE. 도베일링으로 양쪽 다 반결정이면 곧 **결정 가능**이 되어 **정지 문제**와 모순.

- **Q. CSL(문맥 인식)과의 경계는?**  
  **A.** CSL은 **비축약(길이 비감소)** 제약 및 LBA(선형 한정 오토마타)로 특징지어지며, RE보다 **엄격히 작다**. Type-0는 **소거/역이동** 등까지 허용해 TM 전체를 덮는다.

- **Q. 실제 언어 설계에 쓰나?**  
  **A.** Type-0는 **정적 분석 불가** 속성이 많아 실무 언어 정의엔 부적합. 대신 **상한선/불가능성** 논증에 핵심 도구다.

---

## 13. 연습 문제

1) **ID 코딩**: 단일테이프 TM의 왼쪽 이동 \((q,b)\to(q',c,L)\) 을 **완전 국소 재작성**으로 처리하는 규칙 세트를 설계하라(경계 ⊢ 포함).  
2) **Cleanup 설계**: 계산 종료 후 상태/경계/여유 공백을 제거해 터미널만 남기는 **마무리 규칙군**을 만들어라.  
3) **폐포 응용**: 두 Type-0 언어 \(L_1,L_2\) 에 대해 \(L=\{\,xy\mid x\in L_1,\ y\in h^{-1}(L_2)\,\}\) 가 Type-0임을 보이는 **구성**을 설계하라(호모/역호모/연접 조합).  
4) **반결정/불결정**: **공백성**이 왜 불가능한지, 정지 문제에서의 **many-one 감소 스케치**를 작성하라.

---

## 14. 한 페이지 요약

- **정의**: \(\alpha\to\beta\) (좌변에 비단말 포함) 임의 재작성 허용.  
- **표현력**: \(\boxed{\text{Type-0}=\text{RE}}\) — **튜링 기계와 정확히 동치**.  
- **구성**: TM의 **구성(ID)** 을 문자열로 코딩, 전이를 **국소 규칙**으로 모사, 마지막에 **마커 제거**.  
- **폐포**: \(\cup,\cap,\cdot,★\), 호모/역호모, 정규교집합/정규몫 **Yes**; 보수/차집합 **No**.  
- **결정 성질**: 멤버십 RE-완(반결정), 공백/보편/포함/동치 등 **Undecidable** 다수.  
- **설계 습관**: **마커 이동**, **국소화**, **도베일링**, **클린업**.

---

## 15. 보너스: 미니 “마커 이동” 규칙 예(개념)

> 아래는 왼쪽 블록의 `a` 를 하나 집어 오른쪽 끝으로 옮기는 **핵심 동작**을 Type-0 감각으로 보여주는 축약 규칙군이다(§7 아이디어의 국소화 버전).

```
# 포맷:  ⊢  a*  #  a*  #  ␣*  ⊣
# 1. 집기: 왼쪽 블록에서 a 하나를 들어 'A' 마커로 전환
X a  # Y # Z  ->  X # Y # A Z

# 2. 통과: A가 중간 장애물을 통과해 맨 끝으로 이동
A a  ->  a A
A #  ->  # A
A ␣  ->  ␣ A

# 3. 놓기: 끝(⊣ 앞 ␣)에서 a 하나 추가
A ␣ ⊣ ->  a ␣ ⊣

# 4. 종료 감지 & 정리: 더 이상 왼쪽에 a 없으면 마커 제거/정리
# (⊢, ⊣, 여유 ␣ 삭제 규칙 포함)
```

실제 문법에선 위 각 패턴을 **비단말/보조기호**를 활용해 **유한 개의 규칙**으로 환원한다.