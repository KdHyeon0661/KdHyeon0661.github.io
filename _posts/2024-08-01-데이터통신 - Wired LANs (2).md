---
layout: post
title: 데이터 통신 - Wired LANs (2)
date: 2024-08-01 18:20:23 +0900
category: DataCommunication
---
# Chapter 13. 고속 유선 LAN: Fast / Gigabit / 10 Gigabit Ethernet

---

## Fast Ethernet (100 Mbps)

Fast Ethernet은 **“기존 10 Mbps 이더넷의 MAC을 그대로 유지하면서 속도만 10배로 올린 것”** 이라는 설계 철학을 가진다.
즉,

- 프레임 포맷, MAC 주소 체계, 최소/최대 프레임 길이 등은 **10 Mbps와 동일**하고,
- **PHY(물리 계층)** 과 **케이블 규격**만 바꾸어 100 Mbps를 달성한다.

대표 표준:

- IEEE 802.3u (1995) – **Fast Ethernet** 표준 (100BASE-TX/FX 등)
- 가장 널리 쓰인 물리 계층은 **100BASE-TX (UTP Cat 5, 2쌍, 100 m)** 이다.

---

### Access Method (접근 방식)

#### MAC 레벨: 여전히 CSMA/CD, 그러나 현실은 Full-duplex

Fast Ethernet의 MAC 서브레이어는 **10 Mbps Ethernet과 사실상 동일**하다:

- **프레임 포맷:** 동일 (64~1518 bytes, FCS-32)
- **MAC 주소:** 48-bit MAC
- **최소 프레임 길이:** 64 bytes
- **CSMA/CD** 프로토콜 유지 (half-duplex 모드에서만 필요)

그러나 실제 구현/운영에서는:

- **스위치 + full-duplex** 구성이 빠르게 보급되었고,
- full-duplex에서는 **충돌 자체가 발생하지 않으므로 CSMA/CD가 필요 없다.**

즉, 이론적으로는 CSMA/CD를 지원하지만
오늘날 Fast Ethernet은 **사실상 “스위치 기반 point-to-point full-duplex 링크”** 로 쓰인다고 보면 된다.

#### 슬롯 시간과 네트워크 직경

10 Mbps Ethernet에서 **slotTime**(충돌 감지에 필요한 최소 시간)은:

- 512 bit-times = 51.2 µs

Fast Ethernet(100 Mbps)에서도 **slotTime은 여전히 512 bit-times** 로 정의된다. 다만:

- 비트율이 10배 ↑ → bit-time은 1/10
- 따라서 slotTime은 **5.12 µs** 로 줄어든다.

수식으로 쓰면:

- 10 Mbps에서:

  $$
  T_{\text{slot}} = \frac{512\ \text{bits}}{10\ \text{Mbit/s}} = 51.2\ \mu s
  $$

- 100 Mbps에서:

  $$
  T_{\text{slot}} = \frac{512\ \text{bits}}{100\ \text{Mbit/s}} = 5.12\ \mu s
  $$

충돌 감지 조건:

$$
T_{\text{slot}} \ge 2 T_p
$$

- $$T_p$$: 한쪽 끝에서 다른 끝까지의 **전파 지연** (one-way propagation delay)

따라서, 속도가 10배 늘어났으니 **허용 가능한 네트워크 직경(케이블 + 리피터 길이)은 약 1/10** 수준으로 줄어들게 된다.

실제로 100BASE-TX에서 **리피터 기반 공유 세그먼트**를 구성하면,
케이블/리피터 규칙은 굉장히 빡빡해지고,
결국 현실에서는 “스위치 기반 full-duplex” 만 남게 된다.

#### Half-duplex vs Full-duplex 예시

**상황 1 – 1990년대 중반 허브 기반 LAN**

- 100BASE-TX 허브에 PC 10대가 연결되어 있다고 가정.
- 허브는 전기적으로 내부 버스를 공유하는 장치이므로:
  - **논리적으로는 하나의 충돌 도메인**,
  - 모든 포트가 half-duplex.
- A와 B가 동시에 전송하면 **충돌** 발생 → CSMA/CD 동작.

**상황 2 – 스위치 기반 LAN**

- 같은 100BASE-TX 포트이지만, 장비가 “스위치”인 경우:
  - 각 포트마다 **독립적인 충돌 도메인**.
  - 각 링크는 보통 **full-duplex** 로 동작.
- A–스위치, B–스위치 간 링크는 point-to-point이고 동시에 상호 전송 가능.
- **충돌 자체가 존재하지 않으므로 CSMA/CD는 사실상 비활성.**

결론: 오늘날 우리가 말하는 “Fast Ethernet”은
**MAC은 CSMA/CD를 지원하지만, 운영은 full-duplex switch 기반** 이라는 점이 핵심이다.

---

### Physical Layer (Fast Ethernet PHY)

Fast Ethernet의 물리 계층(100 Mbps)을 정의하는 대표 규격은 다음과 같다:

| 표기 | 매체 | 코딩 | 최대 거리 (전형) |
|------|------|------|------------------|
| 100BASE-TX | UTP Cat 5 (2쌍) | 4B/5B + MLT-3 | 100 m |
| 100BASE-FX | 멀티모드 파이버 (MMF) | 4B/5B + NRZ(OOK) | 2 km (전형) |
| 100BASE-T4 (역사적) | UTP Cat 3 (4쌍) | 8B/6T | 100 m |
| 100BASE-BX10 | 단일섬유(SMF, WDM) | 4B/5B + NRZ | ~10 km |

(실제 최대 거리는 케이블 품질, 링크 버짓에 따라 달라질 수 있다.)

#### 100BASE-TX (가장 많이 쓰인 Fast Ethernet)

100BASE-TX는 오늘날에도 레거시 장비에서 자주 보이는 Fast Ethernet PHY이다.

특징:

- 매체: UTP Cat 5 (보통 Cat 5e 이상도 사용 가능)
- 페어: 2쌍 (송신 1쌍, 수신 1쌍)
- 거리: 100 m
- 인코딩:
  - MAC 계층에서 오는 4-bit nibbles → **4B/5B 인코딩** (PCS)
  - 5-bit 코드 그룹 → scrambling → NRZ → MLT-3 파형으로 변환 (PMA/PMD)
- 심볼율:

  $$
  R_{\text{symbol}} = \frac{100\ \text{Mbit/s}}{4/5} = 125\ \text{MBd}
  $$

- MLT-3는 3레벨(−1, 0, +1) 신호를 사용하여
  주파수 대역을 줄이고 전자파 방사를 감소시키는 역할을 한다.

4B/5B 인코딩은:

- 4비트를 5비트로 매핑하여,
- 각 코드 그룹 안에 **충분한 전이(edge)** 를 보장해서
  클록 회복(clock recovery)을 쉽게 해준다.

#### 100BASE-FX (파이버 Fast Ethernet)

100BASE-FX는 멀티모드 파이버를 사용하는 Fast Ethernet PHY이다.

- 매체: MMF (1300 nm 파장 사용)
- 인코딩: 4B/5B + NRZ(OOK)
- 거리: 전형적으로 2 km, SMF 활용 시 10 km까지 확장한 100BASE-BX10도 존재.

4B/5B 인코딩을 그대로 사용하지만,
아날로그 파형은 MLT-3 대신 **온-오프키잉(OOK) NRZ** 를 사용한다.

#### Fast Ethernet 인코딩 오버헤드 예제

4B/5B는 4비트 정보를 5비트 코드로 전송하므로,
**코딩 오버헤드**는:

$$
\text{Overhead} = \frac{5 - 4}{4} = 25\%
$$

즉, **라인 비트율은 125 Mbit/s** 이지만
실제 유효 정보 비트율은 100 Mbit/s 이다.

간단한 파이썬 예제로 비교해 보자.

```python
def effective_rate(line_rate_mbps, coding_ratio):
    """
    line_rate_mbps: 라인 속도 (Mbit/s)
    coding_ratio: (정보비트 / 전송비트) 예: 4/5 = 0.8
    """
    return line_rate_mbps * coding_ratio

if __name__ == "__main__":
    # 4B/5B: 정보비트/전송비트 = 4/5 = 0.8
    coding_ratio = 4 / 5
    line_rate = 125  # Mbit/s
    user_rate = effective_rate(line_rate, coding_ratio)
    print("라인 비트율:", line_rate, "Mbit/s")
    print("유효 정보 비트율:", user_rate, "Mbit/s")
```

이 코드를 실행하면 유효 정보 비트율이 **100 Mbit/s** 인 것을 확인할 수 있다.

#### Auto-Negotiation과 10/100 혼합 환경

Fast Ethernet 시대부터, 링크 파트너 간 속도/듀플렉스 모드를 협상하는
**Auto-Negotiation(802.3u)** 메커니즘이 도입되었다.

- 링크가 올라갈 때, 양 끝 장비는 **자신이 지원하는 모드** (10/100, half/full)를 광고.
- 공통으로 지원하는 것 중 **우선순위가 가장 높은 모드**를 선택.
- 이렇게 하면 “10 Mbps만 되는 장비 + 10/100 장비”를 같은 스위치에 꽂아도 자동으로 적절한 모드가 맞춰진다.

---

## Gigabit Ethernet (1 Gbps)

Gigabit Ethernet은 **기존 Ethernet MAC을 그대로 유지하면서 1 Gbps까지 확장**한 기술이다.

- 표준: IEEE 802.3z (파이버/직렬 동축, 1000BASE-X), 802.3ab (UTP, 1000BASE-T)
- MAC 프레임 구조, 주소, 상위 프로토콜은 그대로.
- **물리 계층(인코딩, 매체)** 만 변경.

---

### MAC Sublayer

#### 기본 MAC: 여전히 802.3, 하지만 Half-duplex는 사실상 사라짐

Gigabit Ethernet의 MAC 서브레이어는 여전히 **클래식 802.3 MAC** 이다:

- 프레임: 64~1518 bytes (VLAN 시 1522 bytes 등)
- 주소: 48-bit MAC
- FCS: CRC-32
- 흐름제어: IEEE 802.3x PAUSE 프레임 지원 (full-duplex에서)

초기 표준에서는 **Half-duplex CSMA/CD 모드도 정의**했지만:

- 1 Gbps에서 CSMA/CD를 유지하려면 slotTime을 512 bit-times로 둘 경우
  허용되는 케이블 길이가 **몇 십 m 수준**으로 지나치게 짧아진다.
- 이를 보완하기 위해
  - **Carrier Extension**
  - **Frame Bursting**
  같은 트릭이 도입되었다.

그러나 실제 제품/네트워크에서는 **거의 전부 Full-duplex 스위치 기반**으로 동작하며,
half-duplex Gigabit Ethernet은 **현실적으로 사용되지 않는다**고 봐도 무방하다.

#### Carrier Extension

문제:
1 Gbps에서 slotTime을 512 bit-times로 유지하면,

- 비트 시간: $$T_b = 1 / 10^9\ \text{s} = 1\ \text{ns}$$
- slotTime:

  $$
  T_{\text{slot}} = 512\ \text{ns} = 0.512\ \mu s
  $$

만약 케이블 길이가 길고 리피터가 있다면 왕복 지연이 이보다 길어질 수 있고,
CSMA/CD 충돌 감지 조건을 만족하기 힘들다.

해결책(이론적):

- 짧은 프레임(예: 64 bytes)을 전송할 때
- **MAC이 “carrier extension bits”를 인위적으로 덧붙여서**
  실제 전송 시간(프레임 길이)을 slotTime 이상이 되도록 늘린다.
- 이 확장 비트는 상위 계층에는 보이지 않고 MAC/PHY 내부에서만 사용.

즉, 실제 line 상에 흐르는 “전송 단위”는 **확장된 512 bytes** 이상이 되도록 만든다.

#### Frame Bursting

Carrier extension만 사용하면,
짧은 프레임이 많을 경우 확장 비트로 인한 **효율 저하**가 심하다.

그래서 도입된 것이 **Frame Bursting**:

- 한 홉이 연속해서 여러 개의 프레임을 전송할 때,
- 첫 프레임에는 carrier extension을 적용,
- 나머지 프레임들은 **늘리지 않고** 연속 전송해
  전체적으로 효율을 개선.

하지만 이 모든 기능은 **half-duplex Gigabit** 을 위한 것이라
full-duplex 스위치 기반 환경에서는 사실상 사용되지 않는다.

#### 802.3x Flow Control (PAUSE Frames)

Gigabit Ethernet에서는 full-duplex 환경에서의 **흐름 제어**가 중요해졌다.

- IEEE 802.3x는 **MAC Control PAUSE 프레임**을 정의한다.
- 수신 측이 버퍼가 꽉 차가면, 송신 측에게:

  - “지금부터 N slotTime 동안 전송을 멈춰 달라”는 메시지 전송.

- 송신 측은 그 시간 동안 해당 링크로의 전송을 중단.

이 메커니즘은:

- 입력 버퍼 overflow를 줄이고,
- 스위치 간 링크 혼잡을 완화하는 데 도움을 준다.

예시 상황:

- 서버 A – 스위치 – 서버 B
- A→B 방향 대량 전송 중, B의 NIC가 CPU 처리 한계로 버퍼가 찬다면:
  - B → A로 PAUSE 프레임 송신.
  - A는 **일시적으로 전송 중단** 후 다시 재개.

---

### Physical Layer (Gigabit PHY)

Gigabit Ethernet PHY는 크게 두 계열로 나뉜다:

1. **1000BASE-X 계열 (802.3z)** – 파이버/직렬 동축
2. **1000BASE-T (802.3ab)** – UTP 4쌍

#### 1000BASE-X (1000BASE-SX/LX/CX 등)

대표적인 1000BASE-X 타입:

| 표기 | 매체 | 파장 | 인코딩 | 거리(전형) |
|------|------|------|--------|------------|
| 1000BASE-SX | MMF | 850 nm | 8B/10B | 220–550 m(OM2/OM3) |
| 1000BASE-LX | MMF/SMF | 1310 nm | 8B/10B | SMF 5 km 이상 |
| 1000BASE-CX | twinax 동축 | 전기 | 8B/10B | 수 m(랙 내) |

특징:

- **8B/10B 인코딩**:
  - 8비트를 10비트 코드 그룹으로 매핑.
  - DC 밸런스와 충분한 전이 제공 → 클록 회복 용이.
  - 코드 오버헤드: 25% (4B/5B와 동일 비율).

- 라인 심볼율:

  $$
  R_{\text{symbol}} = \frac{1\ \text{Gbit/s}}{8/10} = 1.25\ \text{GBd}
  $$

#### 1000BASE-T (UTP 기반 Gigabit, 802.3ab)

1000BASE-T는 **Cat 5/5e/6 UTP 4쌍**을 사용하여 1 Gbps를 제공하는 PHY이다.

특징:

- 모든 4쌍을 동시에 사용 (각 쌍 양방향 전송 – echo cancellation 필요).
- 심볼율: 각 쌍당 125 MBd.
- 변조: **PAM-5 (Pulse Amplitude Modulation, 5레벨)**.
- 코딩 효율을 높이기 위해 **트렐리스 코딩 등** 사용.

직관적 설명:

- 4쌍 × 125 Msymbol/s × log₂(5) ≈ 4 × 125 × 2.32 ≈ 1.16 Gbit/s
  정도의 raw capacity에서, 코딩/오버헤드를 고려하면
  유효 데이터율이 1 Gbit/s 수준이 되도록 설계된다.

1000BASE-T의 설계 목표:

- **기존 Cat 5 UTP 인프라를 활용**하여 100 m까지 1 Gbps 제공.

#### Gigabit PHY 비교 표

| 타입 | 표준 | 매체 | 인코딩 | 거리 |
|------|------|------|--------|------|
| 1000BASE-SX | 802.3z | MMF | 8B/10B | 수백 m |
| 1000BASE-LX | 802.3z | SMF/MMF | 8B/10B | 수 km |
| 1000BASE-CX | 802.3z | twinax | 8B/10B | 수 m |
| 1000BASE-T | 802.3ab | UTP Cat 5e | PAM-5, 4쌍 | 100 m |

#### 간단한 인코딩 효율 비교 코드

```python
import math

def coding_efficiency_8b10b():
    return 8 / 10

def coding_efficiency_pam5_pairs():
    # 단순 근사: 4쌍, 각 125 MBd, 신호 레벨 5, 데이터율 1 Gbit/s 가 될 때의 효율
    raw_capacity = 4 * 125e6 * math.log2(5)  # bit/s
    return 1e9 / raw_capacity

if __name__ == "__main__":
    eff_8b10b = coding_efficiency_8b10b()
    eff_pam5 = coding_efficiency_pam5_pairs()
    print("8B/10B 코딩 효율:", eff_8b10b)      # 0.8
    print("1000BASE-T 대략적 효율:", eff_pam5) # 약 0.86 정도로 나올 것
```

계산 결과를 보면:

- 8B/10B는 **0.8 (80%)**,
- 1000BASE-T의 PAM-5 기반 설계는 **좀 더 높은 효율**을 갖도록 설계되었음을 알 수 있다 (정확 값은 표준에서 더 복잡하게 정의).

---

## 10 Gigabit Ethernet (10 Gbps)

10 Gigabit Ethernet(10GbE)은 **기존 Ethernet MAC을 10 Gbps 속도로 확장**한 기술이다.

중요한 설계 변화:

- **오직 full-duplex only** – 더 이상 CSMA/CD나 half-duplex를 지원하지 않는다.
- **shared medium 개념 없음** – 항상 point-to-point 링크.
- 주된 용도: 데이터센터, 캠퍼스/백본, MAN/WAN, SAN 등 고속 백본.

대표 표준:

- IEEE 802.3ae (2002) – 10GbE 첫 표준 (10GBASE-SR/LR/ER/LX4 등)
- 이후 10GBASE-T(802.3an), 10GBASE-KR(백플레인), 10G PON(802.3av) 등 계속 확장.

---

### Implementation (구현과 설계 관점)

#### CSMA/CD 완전 제거

10GbE는 **처음부터 full-duplex point-to-point 링크만** 염두에 두고 설계되었다.

이 말은 곧:

- CSMA/CD, slotTime, 충돌 도메인, 최소 프레임 길이 제약 등
  **모든 CSMA/CD 관련 설계 요소가 필요 없어진다.**
- 거리 제한은 **충돌 감지**가 아니라
  - 채널 손실/분산,
  - 광 세기, 수신 감도, 오류율(BER) 등 **물리/광학적 링크 버짓**으로 결정된다.

이 덕분에:

- 10GBASE-SR/LR/ER 등은
  - 300~400 m (OM3/OM4 MMF),
  - 10 km, 40 km (SMF)
  같은 장거리 링크도 지원할 수 있다.

#### 64B/66B 인코딩

10GbE의 핵심 기술 중 하나는 **64B/66B 인코딩**이다.

- 8B/10B는 20% 오버헤드 → 10 Gbps 구간에서 비효율.
- 64B/66B는
  - 64비트 정보를 66비트로 인코딩,
  - 오버헤드는:

    $$
    \text{Overhead} = \frac{66 - 64}{64} = \frac{2}{64} = 3.125\%
    $$

- 각 66비트 블록의 앞 2비트를 **헤더**로 사용해:
  - 동기화 패턴,
  - 제어/데이터 구분
  등을 담는다.

라인율(line rate):

- 10 Gbps MAC 데이터율을 유지하면서,
- 64B/66B 인코딩으로 인한 오버헤드를 고려하면:

  $$
  R_{\text{line}} = 10\ \text{Gbit/s} \times \frac{66}{64} = 10.3125\ \text{Gbit/s}
  $$

실제 표준에서도 10GBASE-R 계열은 10.3125 GBd 라인율을 사용한다.

간단 코드로 계산해 보면:

```python
def line_rate_64b66b(mac_rate_gbps=10.0):
    return mac_rate_gbps * 66 / 64

if __name__ == "__main__":
    lr = line_rate_64b66b()
    print("MAC 데이터율 10 Gbps, 64B/66B 사용 시 라인율:", lr, "Gbps")
```

출력은 **10.3125 Gbps** 가 된다.

#### 주요 10GbE PHY 타입

10GbE의 대표적인 PHY 타입 (대표만):

| 타입 | 매체 | 파장/전기 | 거리 (전형) | 인코딩 |
|------|------|-----------|-------------|--------|
| 10GBASE-SR | MMF | 850 nm | 최대 300~400 m (OM3/OM4) | 64B/66B |
| 10GBASE-LR | SMF | 1310 nm | 10 km | 64B/66B |
| 10GBASE-ER | SMF | 1550 nm | 40 km | 64B/66B |
| 10GBASE-LRM | MMF | 1310 nm | 220 m | 64B/66B + EDC |
| 10GBASE-CX4 | 동축/튜인액스 | 전기 | 수 m | 8B/10B (4 lane) |
| 10GBASE-T | UTP Cat 6a 등 | 전기 | 55~100 m | 고차 PAM + FEC |



- **10GBASE-SR**:
  - “Short Range” – 데이터센터 내부 랙 간 연결에 많이 사용.
- **10GBASE-LR/ER**:
  - “Long/Extended Range” – 캠퍼스/메트로 백본에 사용.
- **10GBASE-T**:
  - UTP 케이블을 이용한 10G – Cat 6a 이상을 사용하여 100 m 지원.
    (고차 PAM, echo cancellation, FEC 등 매우 복잡한 DSP 필요)

#### 모듈 폼팩터와 실제 구현

10GbE는 다양한 **플러그형 광/전기 모듈 폼팩터**를 통해 구현된다:

- XENPAK, X2, XFP (초기 세대)
- SFP+ (현재 가장 널리 쓰이는 폼팩터)
- DAC(Direct Attach Copper), AOC(Active Optical Cable) 등

예시 구성:

- 서버 – ToR(Top-of-Rack) 스위치:
  - SFP+ 포트에 **10GBASE-SR** 트랜시버 + OM3 패치 코어 3~30 m.
- ToR – Spine 스위치:
  - 10GBASE-SR 또는 40/100G 업링크의 일부로 10G를 논리적으로 묶어서 사용.

#### 구현 예제: 10G vs 1G 포트 용량 계산

예를 들어, 데이터센터에서:

- 1G 포트 48개를 가진 ToR 스위치가 있고,
- Spine 방향으로 10G 업링크 4개를 가진다고 하자.

총 downlink capacity:

$$
C_{\text{down}} = 48 \times 1\ \text{Gbps} = 48\ \text{Gbps}
$$

총 uplink capacity:

$$
C_{\text{up}} = 4 \times 10\ \text{Gbps} = 40\ \text{Gbps}
$$

**오버서브스크립션(over-subscription) 비율**:

$$
\text{Over-subscription} = \frac{C_{\text{down}}}{C_{\text{up}}} = \frac{48}{40} = 1.2
$$

즉, 이 ToR 스위치는 “1.2:1 오버서브스크립션” 구조라 할 수 있다.

간단한 파이썬 코드로 일반화하면:

```python
def oversubscription(num_access_ports, access_rate_gbps,
                     num_uplinks, uplink_rate_gbps):
    c_down = num_access_ports * access_rate_gbps
    c_up = num_uplinks * uplink_rate_gbps
    return c_down / c_up

if __name__ == "__main__":
    ratio = oversubscription(48, 1, 4, 10)
    print("Over-subscription ratio:", ratio)
```

실제 설계에서는 3:1, 4:1 등 더 높은 오버서브스크립션을 허용하기도 하며,
워크로드 특성(서버간 동서 트래픽 vs 북남 트래픽)에 따라 적정 비율을 조정한다.

#### 10GbE 구현의 핵심 포인트

정리하면, 10GbE 구현의 특징은 다음과 같다:

1. **MAC 상위는 거의 그대로**
   - 프레임 포맷, 주소, VLAN, QoS, IP/TCP/UDP 등은 10/100/1G와 동일.

2. **전적으로 full-duplex, switch 기반**
   - CSMA/CD, 충돌, 최소 프레임 길이 제약이 없다.

3. **64B/66B 인코딩과 고급 DSP**
   - 광: 64B/66B + 고속 직렬 링크.
   - 구리: 고차 PAM, FEC, 에코캔슬레이션 등 고난이도 신호처리.

4. **모듈화된 PHY (SFP+ 등)**
   - 네트워크 장비 설계의 유연성을 제공,
   - 케이블 종류/거리/비용에 따라 적절한 모듈 선택.

---

## 전체 요약

- **13.3 Fast Ethernet (100 Mbps)**
  - MAC: 10 Mbps Ethernet과 동일, CSMA/CD 지원.
  - 현실: 스위치 기반 full-duplex가 대부분, CSMA/CD는 사실상 역사적 유산.
  - PHY: 100BASE-TX(UTP, 4B/5B+MLT-3), 100BASE-FX(파이버), 100BASE-T4 등.
  - 4B/5B 인코딩으로 25% 오버헤드, 라인율 125 Mb/s → 유효 100 Mb/s.

- **13.4 Gigabit Ethernet (1 Gbps)**
  - MAC: 802.3 MAC 유지, half-duplex 지원(이론상) + carrier extension/frame bursting,
    실제는 full-duplex 스위치 기반.
  - PHY: 1000BASE-X(8B/10B, 파이버/동축), 1000BASE-T(PAM-5, 4쌍 UTP).
  - 8B/10B 인코딩(20% 오버헤드), Cat 5e UTP에서도 100 m에서 1 Gbps 달성.

- **13.5 10 Gigabit Ethernet (10 Gbps)**
  - MAC: 완전 full-duplex, point-to-point only, CSMA/CD 제거.
  - 인코딩: 64B/66B (3.125% 오버헤드), 라인율 10.3125 Gb/s.
  - PHY: 10GBASE-SR/LR/ER/LRM(광), 10GBASE-CX4/T(동축/UTP) 등.
  - 주 용도: 데이터센터, 백본, MAN/WAN, 고성능 컴퓨팅 등.

이 흐름을 잡아두면, 이후 40G, 100G, 400G, 800G Ethernet까지도
“**MAC은 거의 그대로, PHY와 인코딩, lane 수만 복잡해진 버전**” 으로 이해할 수 있다.
