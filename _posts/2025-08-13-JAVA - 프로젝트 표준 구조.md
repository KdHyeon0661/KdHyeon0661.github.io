---
layout: post
title: Java - 프로젝트 표준 구조
date: 2025-08-13 14:20:23 +0900
category: Java
---
# 프로젝트 표준 구조 — `src/main/java`, `src/test/java` (Maven/Gradle 공통, 2025 최신)

**표준 디렉터리 레이아웃**은 Java/JVM 프로젝트의 기본 질서다. Maven의 *Standard Directory Layout*을 Gradle도 그대로 인식하므로 이 구조를 따르면 **IDE 자동 인식, 플러그인 호환성, CI/CD 재현성**이 자연스럽게 확보된다. 본 문서는 **단일/멀티모듈, 리소스, 테스트 소스셋, JPMS(자바 모듈), 웹/WAR, 통합 테스트 분리, 커스터마이징**까지 실무 예제로 총정리한다. (JDK 17+ 기준, 예시 버전은 2025년 현재 LTS/안정 라인을 반영)

---

## 1. 한눈에 보는 기본 레이아웃

```
project/
├─ src/
│  ├─ main/
│  │  ├─ java/            ← 프로덕션 소스 (.java, module-info.java)
│  │  ├─ resources/       ← 리소스(설정, 템플릿, 정적 파일 등)
│  │  └─ webapp/          ← (옵션, WAR 패키징) JSP/WEB-INF/정적 리소스
│  └─ test/
│     ├─ java/            ← 테스트 소스 (.java)
│     └─ resources/       ← 테스트 리소스
├─ build/ or target/      ← 빌드 산출물(Gradle=build, Maven=target)
├─ pom.xml or build.gradle(.kts)
└─ settings.gradle(.kts) / .mvn/ / gradlew 등
```

> Gradle은 산출물을 `build/`에, Maven은 `target/`에 생성한다.  
> 표준 레이아웃을 사용하면 IntelliJ IDEA/Eclipse/VS Code가 **추가 설정 없이** 소스셋과 클래스패스를 올바르게 인식한다.

---

## 2. `src/main/java` — 프로덕션 코드의 집

- **역할**: 애플리케이션의 도메인/서비스/컨트롤러/구성요소 + (JPMS 사용 시) `module-info.java`.
- **패키지 네이밍**: 역도메인 규칙(예: `com.example.app`). 그룹ID/아티팩트ID와 일치시키면 저장소/코드정책이 단순해진다.
- **가시성/캡슐화**: 외부 공개 API와 내부 구현을 **패키지 레벨로 분리**(예: `com.example.app.api` vs `com.example.app.internal`).

### 2.1 리소스 접근(클래스패스 사용 필수)

```java
// src/main/resources/application.properties 를 읽는 예
try (var in = getClass().getClassLoader().getResourceAsStream("application.properties")) {
    if (in == null) throw new IllegalStateException("resource not found");
    var props = new java.util.Properties();
    props.load(in);
    String mode = props.getProperty("app.mode", "prod");
}
```

> 파일 시스템 경로(예: `new File("...")`) 대신 **클래스패스**를 사용해야 JAR 패키징/운영 환경에서 깨지지 않는다.

### 2.2 ServiceLoader 메타데이터

`src/main/resources/META-INF/services/fully.qualified.Interface` 파일에 구현체 FQCN을 등록하면, 런타임에 DI 없이 구현을 동적으로 로드할 수 있다.

---

## 3. `src/test/java` — 테스트 전용 공간

- **클래스패스 규칙**: 테스트 실행 시 `main` 산출물 + `test` 산출물이 **함께** 클래스패스에 포함된다. 즉, 테스트에서 프로덕션 클래스를 바로 참조 가능.
- **이름 관례**: `*Test`, `*Tests`(단위), `*IT`(통합; Failsafe/별도 소스셋과 매칭).
- **테스트 리소스**: `src/test/resources`는 **테스트에서만** 클래스패스에 올라간다. 동일 경로/이름이 `main/resources`와 충돌하면 보통 테스트 리소스가 우선한다.

예시:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class GreetingServiceTest {
    @Test
    void hello() {
        assertEquals("Hello", new GreetingService().hello());
    }
}
```

---

## 4. `src/main/resources` & `src/test/resources` — 리소스 처리

- 텍스트/바이너리 리소스(프로퍼티, YAML, 템플릿, 정적 파일)는 **`resources/`**에 둔다.
- Maven/Gradle은 빌드 시 **리소스를 그대로 클래스패스**로 복사한다.  
- Maven의 **리소스 필터링**으로 `${...}` 치환 가능(Gradle도 동등 기능 존재).

**Maven 필터링 예:**
```xml
<build>
  <resources>
    <resource>
      <directory>src/main/resources</directory>
      <filtering>true</filtering>
    </resource>
  </resources>
</build>
```

> **주의**: 운영/로컬에서 동일 리소스 파일을 **파일 경로로 직접 읽지 말라**. 반드시 `ClassLoader#getResource*`로 접근.

---

## 5. 웹/WAR(옵션) — `src/main/webapp`

- 전통적인 서블릿 컨테이너 배포(WAR)에서 JSP, `WEB-INF/`, 정적 리소스를 `webapp/`에 둔다.
- **Spring Boot**는 기본적으로 **실행형 JAR**를 권장하므로 정적/템플릿은 `src/main/resources/static/`, `templates/`에 배치하는 편이 단순하다.

---

## 6. 멀티 언어/플랫폼 소스셋

동일 프로젝트에서 Java/Kotlin/Groovy/Scala를 함께 사용할 수 있다. 표준 경로는 아래와 같다.

```
src/main/java,  src/test/java
src/main/kotlin, src/test/kotlin
src/main/groovy, src/test/groovy
src/main/scala,  src/test/scala
```

> 여러 언어 디렉터리를 동시에 둬도 된다. Gradle은 `sourceSets`가 이를 자동으로 합산한다.

---

## 7. 통합 테스트 분리(권장)

### 7.1 Maven — Failsafe 플러그인

`*IT` 같은 패턴을 **verify 단계**에 실행시켜 단위 테스트와 분리한다.

```xml
<build>
  <plugins>
    <!-- 단위 테스트: Surefire(기본) -->
    <plugin>
      <artifactId>maven-surefire-plugin</artifactId>
      <version>3.2.5</version>
    </plugin>
    <!-- 통합 테스트: Failsafe -->
    <plugin>
      <artifactId>maven-failsafe-plugin</artifactId>
      <version>3.2.5</version>
      <executions>
        <execution>
          <goals>
            <goal>integration-test</goal>
            <goal>verify</goal>
          </goals>
          <configuration>
            <includes>
              <include>**/*IT.java</include>
            </includes>
          </configuration>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>
```

### 7.2 Gradle — 별도 소스셋/작업

```kotlin
// build.gradle.kts
sourceSets {
    val integrationTest by creating {
        java.srcDir("src/integrationTest/java")
        resources.srcDir("src/integrationTest/resources")
        compileClasspath += sourceSets.main.get().output + configurations.testRuntimeClasspath.get()
        runtimeClasspath += output + compileClasspath
    }
}

configurations {
    val integrationTestImplementation by creating { extendsFrom(configurations.testImplementation.get()) }
    val integrationTestRuntimeOnly   by creating { extendsFrom(configurations.testRuntimeOnly.get()) }
}

tasks.register<Test>("integrationTest") {
    description = "Runs integration tests."
    group = "verification"
    testClassesDirs = sourceSets["integrationTest"].output.classesDirs
    classpath = sourceSets["integrationTest"].runtimeClasspath
    useJUnitPlatform()
    shouldRunAfter("test")
}
```

> **효과**: 단위 테스트는 초단위로 **빠르게**, 통합 테스트는 후단에서 **분리** 실행 → CI 안정성↑, 피드백 루프↑.

---

## 8. Gradle Test Fixtures — 테스트 공용 코드 공유

테스트 간에 재사용할 헬퍼·빌더를 `testFixtures` 소스셋으로 분리하면 **다른 모듈의 테스트**에서 가져다 쓸 수 있다.

```
src/testFixtures/java
src/testFixtures/resources
```

```kotlin
plugins { `java-test-fixtures` }

dependencies {
    testFixturesImplementation("org.assertj:assertj-core:3.26.0")
}

// 다른 모듈의 테스트에서 의존:
dependencies {
    testImplementation(testFixtures(project(":core")))
}
```

---

## 9. JPMS(자바 모듈)과 테스트

### 9.1 `module-info.java` (main)

```java
// src/main/java/module-info.java
module com.example.app {
    requires java.sql;
    exports com.example.app.api;
    // 내부 구현 패키지는 export하지 않음
}
```

### 9.2 테스트에서 리플렉션이 필요할 때

JUnit/Mockito 등은 리플렉션을 사용한다. 모듈 경계를 적용하면 테스트에서 접근이 막힐 수 있다. 해결책:

- **열기(열린 패키지)**: 테스트에서 접근해야 하는 패키지를 `opens`로 허용.
- **테스트 전용 module-info**: `src/test/java/module-info.java` 작성(고급 패턴).
- 또는 **빌드 플러그인으로 add-opens**(운영 모듈은 폐쇄, 테스트에서만 열기).

예: main 쪽에서 필요한 패키지에 한해 테스트 프레임워크로 `opens`:

```java
module com.example.app {
    requires java.sql;
    exports com.example.app.api;
    opens com.example.app.internal to org.junit.platform.commons; // JUnit 리플렉션 허용
}
```

> 팀에서 JPMS를 엄격히 쓰지 않는다면, 테스트는 **클래스패스** 모드로 두고 main만 모듈 경계를 쓰는 절충도 가능하다.

---

## 10. 멀티모듈(모노리포) 표준 구조

```
company-platform/
├─ pom.xml (packaging: pom)          ← Maven Aggregator/Parent
├─ settings.gradle(.kts)             ← Gradle 멀티 프로젝트
├─ modules/
│  ├─ core/
│  │  ├─ src/main/java/...
│  │  └─ src/test/java/...
│  ├─ api/
│  ├─ web/
│  └─ infra/
└─ buildSrc/ or gradle/libs.versions.toml (Gradle 버전 카탈로그)
```

### 10.1 Maven Parent/Aggregator

- 루트 `pom.xml`을 **Parent + Aggregator**로 설정, 하위 모듈 버전/플러그인/BOM을 일괄 관리.
- 하위 모듈의 `pom.xml`은 `<parent>`로 루트를 참조.

### 10.2 Gradle

- `settings.gradle.kts`에서 `include(":core", ":api", ":web", ":infra")`.
- 루트 `gradle/libs.versions.toml`(버전 카탈로그)로 **버전 중앙 관리**.
- 공통 스크립트는 `buildSrc/` 또는 `convention plugins`로 캡슐화.

---

## 11. 커스터마이징(필요할 때만)

표준이 최선이나, 도메인 요건으로 경로를 바꿔야 한다면 **명시적으로** 설정한다.

### 11.1 Maven

```xml
<build>
  <sourceDirectory>src/java</sourceDirectory>
  <testSourceDirectory>test/java</testSourceDirectory>
  <resources>
    <resource><directory>conf</directory></resource>
  </resources>
</build>
```

### 11.2 Gradle

```kotlin
sourceSets {
    main {
        java.setSrcDirs(listOf("src/java"))
        resources.setSrcDirs(listOf("conf"))
    }
    test {
        java.setSrcDirs(listOf("test/java"))
    }
}
```

> **경고**: IDE/플러그인 생태계가 가정하는 표준을 벗어나면 새 동료·CI에서 **학습 비용과 사고**가 늘어난다. **정말 필요할 때만** 커스터마이징하라.

---

## 12. 빌드 산출물·클래스패스·실행

- `src/main/java` → `target/classes`(Maven) / `build/classes/java/main`(Gradle)  
- `src/test/java` → `target/test-classes` / `build/classes/java/test`
- 패키징:
  - **JAR**: 기본. `main` 클래스/리소스만 포함.
  - **WAR**: `src/main/webapp` 포함(서블릿 컨테이너 배포).
- 실행:
  - 클래스패스: `java -cp target/classes:target/dependency/* com.example.Main`
  - 실행형 JAR: `java -jar build/libs/app.jar`

---

## 13. 도메인별 추가 소스셋(플러그인 관례)

다수 생태계 플러그인이 표준 하위 디렉터리를 기본값으로 사용한다.

| 도메인 | 관례 디렉터리 | 비고 |
|---|---|---|
| **Protobuf** | `src/main/proto` | protobuf-gradle-plugin / maven-protoc |
| **OpenAPI** | `src/main/openapi` | openapi-generator |
| **Avro/Thrift** | `src/main/avro`, `src/main/thrift` | 데이터 스키마 |
| **Native/JNI** | `src/main/native` | JNI/FFI 빌드 |
| **SQL/DDL** | `src/main/sql` | Flyway/Liquibase는 자체 위치 권장 |

> 플러그인 기본 경로를 따르되, 팀 표준 문서에 명시해 혼선을 방지하라.

---

## 14. 리소스 충돌/우선순위와 테스트 전략

- 경로와 파일명이 같은 리소스가 `main`과 `test`에 동시에 존재하면 **테스트 리소스가 우선**할 수 있다.
- **전략**: 공통 리소스는 `main`에 두고, 테스트에서만 덮어써야 하는 항목만 `test`에 둔다(예: `application-test.yml`).

---

## 15. CI/CD 예시(Wrapper, 캐시, 멀티-JDK)

### 15.1 Maven (GitHub Actions 예시)

```yaml
name: ci
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        java: [17, 21, 25]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ matrix.java }}
          cache: maven
      - run: ./mvnw -B -V -ntp verify
```

### 15.2 Gradle

```yaml
name: ci
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        java: [17, 21, 25]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ matrix.java }}
          cache: gradle
      - run: ./gradlew -v
      - run: ./gradlew clean build --scan
```

> **Wrapper 필수**: `mvnw`, `gradlew`로 도구 버전을 고정하면 **재현성**이 올라간다.

---

## 16. Spring Boot 프로젝트 레이아웃 팁

- 실행형 JAR 권장 → `src/main/resources/application.yml`, 정적은 `static/`, 템플릿은 `templates/`.
- **테스트 분리**: `@SpringBootTest`(느림)는 통합 테스트 태그로, 단위는 **슬라이스 테스트**(`@WebMvcTest`, `@DataJpaTest`)로 빠르게.
- 멀티모듈: 공통 DTO/유틸은 `core`, 웹/REST는 `web`, 인프라(DB/메시지)는 `infra` 등 기능별로 나눠 **경계 명확화**.

---

## 17. 흔한 함정과 대처

1. **리소스를 파일 경로로 읽음** → JAR에서 실패. **클래스패스** 사용.  
2. **비표준 디렉터리** → IDE/플러그인 충돌. 표준 유지가 장기 비용을 최소화.  
3. **테스트/통합 혼재** → 피드백 느려지고 불안정. **Failsafe/별도 소스셋**으로 분리.  
4. **중복 리소스 충돌** → 의도치 않은 오버라이드. 테스트 리소스의 우선순위를 **의식**하고 이름 구분(`-test`)로 안전장치.  
5. **모듈(보안) vs 테스트(리플렉션)** 충돌 → `opens`/`add-opens`로 테스트 범위 내에서만 열기.

---

## 18. 실무 예제 묶음

### 18.1 단일 모듈 — 간단한 Maven POM

```xml
<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId>
  <artifactId>demo</artifactId>
  <version>1.0.0</version>
  <properties>
    <maven.compiler.release>17</maven.compiler.release>
  </properties>
  <dependencies>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter</artifactId>
      <version>5.10.2</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
  <build>
    <plugins>
      <plugin>
        <artifactId>maven-surefire-plugin</artifactId>
        <version>3.2.5</version>
        <configuration>
          <useModulePath>false</useModulePath> <!-- JPMS 비활성(테스트 단순화) -->
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```

### 18.2 단일 모듈 — Gradle Kotlin DSL

```kotlin
plugins { java }

java { toolchain { languageVersion.set(JavaLanguageVersion.of(17)) } }

repositories { mavenCentral() }

dependencies {
    testImplementation(platform("org.junit:junit-bom:5.10.2"))
    testImplementation("org.junit.jupiter:junit-jupiter")
}

tasks.test { useJUnitPlatform() }
```

### 18.3 멀티모듈 — Gradle 레이아웃

```
root/
├─ settings.gradle.kts       ← include(":core", ":web")
├─ build.gradle.kts          ← 공통 설정
├─ core/
│  └─ build.gradle.kts
└─ web/
   └─ build.gradle.kts
```

`settings.gradle.kts`:
```kotlin
rootProject.name = "platform"
include(":core", ":web")
```

루트 `build.gradle.kts`(공통):
```kotlin
plugins { java }
subprojects {
    repositories { mavenCentral() }
    tasks.withType<Test> { useJUnitPlatform() }
}
```

---

## 19. 출력물 구조 확인과 로컬 실행 디버깅

- **Gradle**: `./gradlew classes testClasses` 후 `build/classes/java/{main,test}` 확인  
- **Maven**: `./mvnw -DskipTests package` 후 `target/classes`, `target/test-classes` 확인  
- IDEA에서 **Run/Debug 설정**에서 *Classpath of module*이 `main` 산출물과 일치하는지 점검.

---

## 20. 베스트 프랙티스 체크리스트

- [ ] **표준 레이아웃 유지** (`src/main/java`, `src/test/java/resources`)  
- [ ] **패키지 네임스페이스 정리**(역도메인, `api`/`internal` 구분)  
- [ ] **리소스는 클래스패스**로 접근(파일 경로 X)  
- [ ] **단위 vs 통합 테스트 분리**(Failsafe/별도 소스셋)  
- [ ] **중복 리소스 우선순위** 의식(테스트가 main을 덮는지)  
- [ ] **Wrapper 커밋**(`mvnw`, `gradlew`)로 재현성 확보  
- [ ] JPMS를 쓴다면 **테스트 리플렉션 허용**(`opens`/`add-opens`) 정책 수립  
- [ ] 멀티모듈에선 **Parent/BOM(또는 Version Catalog)** 으로 버전/플러그인 중앙 관리

---

## 21. 결론

표준 디렉터리 레이아웃은 **팀 온보딩 비용 감소, 빌드·IDE 호환성 극대화, CI/CD 재현성**을 보장하는 **가장 강력한 베이스라인**이다.  
여기에 **통합 테스트 분리, testFixtures, JPMS/테스트 호환, 멀티모듈 버전 중앙 관리**까지 갖추면, 프로젝트는 규모가 커져도 **질서와 속도**를 동시에 유지한다.