---
layout: post
title: ì•”í˜¸í•™ - ê³µê°œí‚¤ ì‹¤ìŠµ
date: 2025-10-17 19:30:23 +0900
category: ì•”í˜¸í•™
---
# ê³µê°œí‚¤ ì‹¤ìŠµ: RSA íŒŒë¼ë¯¸í„° ì·¨ì•½ ì„¸íŒ… ê¹¨ë³´ê¸° Â· ECDSA nonce ì¬ì‚¬ìš© ë³µêµ¬ (ğŸš€ ì‹¤ìŠµ ë©)

> ì´ ë©ì€ **ê³µê²©ì„ â€œêµ¬í˜„í•´ì„œ ì²´ê°â€**í•˜ëŠ” ëª©ì ì˜ êµìœ¡ìš©ì…ë‹ˆë‹¤.
> ì‹¤ì„œë¹„ìŠ¤Â·ìš´ì˜í™˜ê²½ì—ëŠ” **í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬(18ì¥)** ì™€ **ì•ˆì „ íŒŒë¼ë¯¸í„°**(í‚¤ ê¸¸ì´/ë‚œìˆ˜/íŒ¨ë”©/ì„œëª… ê·œê²©)ë¥¼ **ë°˜ë“œì‹œ** ì‚¬ìš©í•˜ì„¸ìš”.
> ëª¨ë“  ì˜ˆì œëŠ” **ë¡œì»¬ ìƒŒë“œë°•ìŠ¤ì—ì„œ ìŠ¤ìŠ¤ë¡œ ë§Œë“  í‚¤ë§Œ** ëŒ€ìƒìœ¼ë¡œ í•˜ë©°, ì œ3ì ì‹œìŠ¤í…œì— ëŒ€í•œ ë¬´ë‹¨ ê³µê²©ì€ ê¸ˆì§€ë©ë‹ˆë‹¤.

---

## ğŸ“¦ ì¤€ë¹„ë¬¼

- Python 3.10+ (ì™¸ë¶€ íŒ¨í‚¤ì§€ í•„ìš” ì—†ìŒ)
- ì‹¤í–‰ ì‹œê°„ì€ CPU ê¸°ì¤€ ìˆ˜ì´ˆ~ìˆ˜ì‹­ì´ˆ(í‚¤ í¬ê¸°Â·ë°˜ë³µ íšŸìˆ˜ì— ë”°ë¼ ë‹¬ë¼ì§)

---

## RSA ì·¨ì•½ íŒŒë¼ë¯¸í„° ê¹¨ë³´ê¸°

ë‹¤ì–‘í•œ **ì•½í•œ RSA ì„¤ì •**ì„ ê³ ì˜ë¡œ ë§Œë“¤ê³ , í‘œì¤€ì ì¸ **ê³µê²© ë ˆì‹œí”¼**ë¡œ ê¹¨ë´…ë‹ˆë‹¤.

### ê³µí†µ ìœ í‹¸

```python
# ====== ê³µí†µ ìœ í‹¸ ======

import os, math, random
from dataclasses import dataclass
from typing import Tuple, Optional

def egcd(a,b):
    if b==0: return (a,1,0)
    g,x1,y1 = egcd(b,a%b)
    return (g,y1,x1 - (a//b)*y1)

def invmod(a, m):
    g,x,y = egcd(a,m)
    if g!=1: raise ValueError("no inverse")
    return x % m

def iroot(k, n):  # âŒŠkâˆšnâŒ‹, ì •ìˆ˜ k-ì œê³±ê·¼
    # Newton
    if n==0: return 0
    x = int(n**(1.0/k))
    while pow(x,k) > n: x -= 1
    while pow(x+1,k) <= n: x += 1
    return x

def is_probable_prime(n, rounds=16):
    if n<2: return False
    small_primes = [2,3,5,7,11,13,17,19,23,29]
    for p in small_primes:
        if n%p==0: return n==p
    # Miller-Rabin
    d=n-1; s=0
    while d%2==0: d//=2; s+=1
    for _ in range(rounds):
        a=random.randrange(2,n-2)
        x=pow(a,d,n)
        if x==1 or x==n-1: continue
        good=False
        for __ in range(s-1):
            x=pow(x,2,n)
            if x==n-1: good=True; break
        if not good: return False
    return True

def gen_prime(bits):
    while True:
        n = (1 << (bits-1)) | random.getrandbits(bits-1) | 1
        if is_probable_prime(n): return n

@dataclass
class RSAKey:
    n:int; e:int; d:int; p:int; q:int
```

---

### [Textbook ê³µê²©] **eê°€ ì‘ê³  íŒ¨ë”©ì´ ì—†ëŠ”** ê²½ìš° (m^e < n)

- ì¡°ê±´: í‰ë¬¸ `m`ì´ ì‘ê±°ë‚˜, ì—¬ëŸ¬ ìˆ˜ì‹ ìì—ê²Œ **ë™ì¼ í‰ë¬¸**ì„ **ì‘ì€ e**(ì˜ˆ: e=3)ì— ì•”í˜¸í™”, ê·¸ë¦¬ê³  **íŒ¨ë”© ì—†ìŒ**.
- ì•„ì´ë””ì–´: `c = m^e (mod n)`ì¸ë° **m^e < n**ì´ë©´ `c = m^e` ê·¸ëŒ€ë¡œë¼ì„œ **ì •ìˆ˜ e-ì œê³±ê·¼**ìœ¼ë¡œ í‰ë¬¸ì„ ë³µêµ¬.

```python
def rsa_gen_small_e_no_padding(bits=512, e=3):
    p = gen_prime(bits//2); q = gen_prime(bits//2)
    n = p*q; phi=(p-1)*(q-1)
    if math.gcd(e, phi)!=1: return rsa_gen_small_e_no_padding(bits, e)
    d = invmod(e, phi)
    return RSAKey(n,e,d,p,q)

def rsa_encrypt_raw(m:int, key:RSAKey) -> int:
    return pow(m, key.e, key.n)

def rsa_decrypt_raw(c:int, key:RSAKey) -> int:
    return pow(c, key.d, key.n)

def textbook_attack_recover_m_from_c_when_me_lt_n(c:int, e:int):
    m = iroot(e, c)
    if pow(m, e) == c:
        return m
    return None

# demo

key = rsa_gen_small_e_no_padding(bits=512, e=3)
m = 12345678901234567890  # ì‘ê²Œ ì„¤ì •
c = rsa_encrypt_raw(m, key)
rec = textbook_attack_recover_m_from_c_when_me_lt_n(c, key.e)
print("[textbook] recovered:", rec == m)
```

> **êµí›ˆ**: ì‹¤ë¬´ì—ì„œëŠ” **í•­ìƒ OAEP**(RSAES-OAEP) ê°™ì€ **ì•ˆì „í•œ íŒ¨ë”©**ì„ ì‚¬ìš©í•˜ê³ , `e=65537` ê³ ì •ì´ í‘œì¤€.

---

### [Fermat] **p,qê°€ ë„ˆë¬´ ê°€ê¹Œìš¸ ë•Œ** (|pâˆ’q| ì‘ìŒ)

- ì¡°ê±´: í‚¤ ìƒì„± ì‹œ p,qê°€ **ê±°ì˜ ê°™ì€ í¬ê¸°**ì— ë”í•´ **ì„œë¡œ ë§¤ìš° ê·¼ì ‘**í•˜ê²Œ ë½‘íŒ ê²½ìš°.
- ì•„ì´ë””ì–´: n = pÂ·q ì— ëŒ€í•´, **nì„ ë‘˜ëŸ¬ì‹¼ ë‘ ì •ìˆ˜ì˜ í‰ê·  a â‰ˆ âˆšn**ì—ì„œ ì‹œì‘í•´ `a^2 - n = b^2`ë¥¼ ì°¾ìœ¼ë©´
  `p = a-b`, `q = a+b` (Fermat factorization).

```python
def fermat_factor(n:int) -> Optional[Tuple[int,int]]:
    a = iroot(2, n)
    if a*a < n: a += 1
    while True:
        b2 = a*a - n
        b = iroot(2, b2)
        if b*b == b2:
            p = a-b; q = a+b
            if p*q==n: return (min(p,q), max(p,q))
        a += 1
        if a - iroot(2,n) > 1_000_000:  # ë°ëª¨ìš© ì•ˆì „ì¥ì¹˜
            return None

# demo - ì¼ë¶€ëŸ¬ p, që¥¼ ê°€ê¹ê²Œ ìƒì„±

def rsa_gen_close_primes(bits=512, gap=2**64):
    p = gen_prime(bits//2)
    # që¥¼ p ê·¼ì²˜ì—ì„œ ì°¾ê¸°
    cand = p + random.randrange(1, gap, 2)
    while not is_probable_prime(cand): cand += 2
    q = cand
    n = p*q; phi=(p-1)*(q-1); e=65537
    if math.gcd(e,phi)!=1: return rsa_gen_close_primes(bits, gap)
    d=invmod(e,phi)
    return RSAKey(n,e,d,p,q)

key2 = rsa_gen_close_primes(bits=512, gap=2**18)
pf = fermat_factor(key2.n)
print("[fermat] success:", pf is not None, "p==", pf[0]==key2.p if pf else None)
```

> **êµí›ˆ**: êµ¬í˜„ì€ p,që¥¼ **ì¶©ë¶„íˆ ëœë¤Â·ë…ë¦½ì ìœ¼ë¡œ** ë½‘ê³ , **â€˜ì°¨ì´â€™ì— ëŒ€í•œ ì œì•½ ì—†ì´** í° ê³µê°„ì—ì„œ ì„ íƒí•´ì•¼ í•œë‹¤.

---

### [ê³µí†µ ì†Œì¸ìˆ˜ ê³µê²©] **ì„œë¡œ ë‹¤ë¥¸ RSA ëª¨ë“ˆëŸ¬ìŠ¤ê°€ ì†Œì¸ìˆ˜ë¥¼ ê³µìœ **í•  ë•Œ

- ì¡°ê±´: ë‘ ë‹¤ë¥¸ ê³µê°œí‚¤ `N1 = pÂ·q1`, `N2 = pÂ·q2`ê°€ **ìš°ì—°íˆ ê°™ì€ ì†Œìˆ˜ p**ë¥¼ ê³µìœ .
- ì•„ì´ë””ì–´: `g = gcd(N1, N2) = p` â†’ ê°ìì˜ ë¹„ë°€í‚¤ ë³µêµ¬.

```python
def shared_prime_demo(bits=512):
    p = gen_prime(bits//2)
    q1 = gen_prime(bits//2); q2 = gen_prime(bits//2)
    n1, n2 = p*q1, p*q2
    g = math.gcd(n1, n2)
    return (g==p, p, n1, n2)

ok, p, n1, n2 = shared_prime_demo(512)
print("[shared prime] gcd success:", ok, "gcd:", math.gcd(n1,n2)==p)
```

> **êµí›ˆ**: ëŒ€ê·œëª¨ì˜ ì‹¤ì œ í‚¤ ì§‘í•©ì—ì„œ **ì „ìˆ˜ gcd ìŠ¤ìº”**ë§Œìœ¼ë¡œë„, ë¶€ì‹¤ ë‚œìˆ˜ë¡œ ìƒì„±ëœ í‚¤ë¥¼ ì‰½ê²Œ ê³¨ë¼ë‚¼ ìˆ˜ ìˆë‹¤.
> (ì‹¤ì„¸ìƒ ê´€ì¸¡: ì„ë² ë””ë“œ/IoTì—ì„œ RNG ê²°í•¨ìœ¼ë¡œ ê³µìœ  ì†Œì¸ìˆ˜ê°€ ë‹¤ìˆ˜ ë°œê²¬ëœ ì‚¬ê±´ë“¤ì´ ìˆì—ˆìŠµë‹ˆë‹¤.)

---

### [Wiener] **ê°œì¸í‚¤ dê°€ ì§€ë‚˜ì¹˜ê²Œ ì‘ì„ ë•Œ (d < N^{0.25}/3)**

- ì¡°ê±´: `d`ê°€ ë§¤ìš° ì‘ì€ ê°’ì´ ë˜ë„ë¡ í‚¤ê°€ ìƒì„±ë˜ë©´, **ê³„ì†ë¶„ìˆ˜(continued fraction)** ê¸°ë°˜ì˜ Wiener ê³µê²©ìœ¼ë¡œ ë³µêµ¬ ê°€ëŠ¥.
- ì•„ì´ë””ì–´(ìš”ì§€): `e/n`ì˜ **ê³„ì†ë¶„ìˆ˜ ìˆ˜ë ´ê°’**(k/dÌ‚)ë“¤ì„ ì‹œí—˜í•˜ë©° `edÌ‚ â‰¡ 1 (mod Ï†(n))` ê´€ê³„ë¥¼ ë§Œì¡±í•˜ëŠ” í›„ë³´ë¥¼ ì°¾ìŒ.

```python
# Wiener ê³µê²© êµ¬í˜„(ë°ëª¨ìš©)

def cont_frac(n, d):
    while d:
        a = n//d
        yield a
        n, d = d, n - a*d

def convergents(cf):
    num1, num2 = 1, 0
    den1, den2 = 0, 1
    for a in cf:
        num = a*num1 + num2
        den = a*den1 + den2
        yield num, den
        num2, num1 = num1, num
        den2, den1 = den1, den

def wiener_attack(e, n) -> Optional[int]:
    for k, d in convergents(cont_frac(e, n)):
        if k == 0:
            continue
        # dëŠ” í›„ë³´ ê°œì¸í‚¤. í™•ì¸ì‹: (ed - 1) % k == 0 â†’ Ï†(n) í›„ë³´
        if (e*d - 1) % k != 0:
            continue
        phi = (e*d - 1)//k
        # x^2 - (n - phi + 1) x + n = 0 â†’ ê·¼ì´ p, q
        s = n - phi + 1
        D = s*s - 4*n
        if D >= 0:
            r = iroot(2, D)
            if r*r == D:
                p = (s + r)//2
                q = (s - r)//2
                if p*q == n:
                    return d
    return None

def rsa_gen_small_d(bits=512):
    # 1) ì„ì˜ p,q; 2) phi; 3) ì‘ì€ dë¥¼ ê³ ë¥´ê³  e = d^{-1} mod phi
    p = gen_prime(bits//2); q = gen_prime(bits//2)
    n = p*q; phi=(p-1)*(q-1)
    # ì‘ì€ d ì„ íƒ: 16ë¹„íŠ¸~20ë¹„íŠ¸ ìˆ˜ì¤€(ë°ëª¨)
    for _ in range(10000):
        d = random.randrange(2, 1<<20)
        if math.gcd(d, phi) == 1:
            e = invmod(d, phi)
            if e < n:  # ì¼ë°˜ ì¡°ê±´
                return RSAKey(n,e,d,p,q)
    raise RuntimeError("small-d generation failed")

key3 = rsa_gen_small_d(512)
d_guess = wiener_attack(key3.e, key3.n)
print("[wiener] success:", d_guess == key3.d)
```

> **êµí›ˆ**: ê°œì¸í‚¤ `d`ëŠ” ìš°ë°œì ìœ¼ë¡œ **ì‘ì•„ì§€ì§€ ì•Šë„ë¡** í•´ì•¼ í•˜ë©°, ì¼ë°˜ì ì¸ í‚¤ ìƒì„±(`e=65537`, ë¬´ì‘ìœ„ p,q)ì—ì„œëŠ” ì•ˆì „í•©ë‹ˆë‹¤.

---

### [ê³µí†µ ëª¨ë“ˆëŸ¬ìŠ¤ ê³µê²©] ë™ì¼í•œ Nìœ¼ë¡œ ì„œë¡œ ë‹¤ë¥¸ e1,e2ë¡œ **ê°™ì€ í‰ë¬¸ì„ ì•”í˜¸í™”**í–ˆì„ ë•Œ

- ì¡°ê±´: ê°™ì€ ìˆ˜ì‹ ìì˜ ì‹¤ìˆ˜ë¡œ ë™ì¼í•œ Nì„ ê³µìœ í•˜ëŠ” ì„œë¡œ ë‹¤ë¥¸ ê³µê°œí‚¤(eê°€ ë‹¤ë¦„)ë¡œ **ê°™ì€ í‰ë¬¸**ì„ ì•”í˜¸í™”í–ˆì„ ë•Œ.
- ì•„ì´ë””ì–´: `gcd(e1,e2)=1`ì´ë©´ **ë² ì£¼ í•­ë“±ì‹**ìœ¼ë¡œ `aÂ·e1 + bÂ·e2 = 1` â†’
  `m â‰¡ c1^a * c2^b (mod n)` (b<0ì´ë©´ ì—­ì›ì„ ì´ìš©)

```python
def common_modulus_recover(c1:int, c2:int, e1:int, e2:int, n:int) -> int:
    g, a, b = egcd(e1, e2)
    assert g==1
    if a<0: c1 = invmod(c1, n); a = -a
    if b<0: c2 = invmod(c2, n); b = -b
    return (pow(c1, a, n) * pow(c2, b, n)) % n

# demo

def demo_common_modulus(bits=512):
    p=gen_prime(bits//2); q=gen_prime(bits//2)
    n=p*q; phi=(p-1)*(q-1)
    e1=65537
    # e2ëŠ” e1ê³¼ ì„œë¡œì†Œ
    for e2 in [3,5,17,257,65539]:
        if math.gcd(e2, phi)==1 and math.gcd(e1, e2)==1:
            break
    m = 12345678901234567890
    c1 = pow(m, e1, n); c2 = pow(m, e2, n)
    rec = common_modulus_recover(c1, c2, e1, e2, n)
    return rec == m

print("[common modulus] success:", demo_common_modulus())
```

> **êµí›ˆ**: **ê°™ì€ N ì¬ì‚¬ìš© ê¸ˆì§€**. ê³µê°œí‚¤ êµì²´ ì‹œì—ëŠ” **ìƒˆë¡œ í‚¤ìŒ**(p,që¶€í„°) ìƒì„±í•´ì•¼ í•©ë‹ˆë‹¤.

---

## ECDSA nonce ì¬ì‚¬ìš© ë³µêµ¬ (k ì¬ì‚¬ìš© â†’ ê°œì¸í‚¤ ë…¸ì¶œ)

- ì¡°ê±´: ê°™ì€ í‚¤ë¡œ ë‘ ì„œëª…ì—ì„œ **ê°™ì€ nonce `k`**ê°€ ì“°ì´ë©´, `r` ê°’ì´ **ê°™ì•„**ì§€ê³  ì•„ë˜ ì‹ìœ¼ë¡œ **ê°œì¸í‚¤ d**ê°€ ë³µì›ë©ë‹ˆë‹¤.
- ì„œëª… ì‹(í‘œì¤€):
  - `r = (kÂ·G).x mod n`
  - `s = k^{-1}(z + rÂ·d) mod n`
  - ë‘ ì„œëª… `(r, s1), (r, s2)`ê°€ ê°™ì€ `r`ì´ë©´,
    - `k = (z1 - z2) * (s1 - s2)^{-1} mod n`
    - `d = (s1Â·k - z1) * r^{-1} mod n`

> ì‹¤ë¬´: **RFC 6979(Deterministic k)** ë˜ëŠ” **ì•ˆì „ CSPRNG**ë¡œ `k`ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. (ë¼ì´ë¸ŒëŸ¬ë¦¬ ê¸°ë³¸ ì‚¬ìš©)

### secp256k1 ìµœì†Œ ì—°ì‚°ê¸°(ìˆœìˆ˜ íŒŒì´ì¬)

```python
# ====== secp256k1 íŒŒë¼ë¯¸í„° ======

p  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
a  = 0
b  = 7
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
n  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
O  = None  # ë¬´í•œì›ì†Œ

def inv_mod(k, p):
    return pow(k, p-2, p)  # pëŠ” ì†Œìˆ˜ë¼ì„œ í˜ë¥´ë§ˆ ì—­ì›

def ec_add(P, Q):
    if P is O: return Q
    if Q is O: return P
    (x1,y1) = P; (x2,y2) = Q
    if x1==x2 and (y1 + y2) % p == 0: return O
    if P==Q:
        lam = (3*x1*x1 + a) * inv_mod(2*y1 % p, p) % p
    else:
        lam = (y2 - y1) * inv_mod((x2 - x1) % p, p) % p
    x3 = (lam*lam - x1 - x2) % p
    y3 = (lam*(x1 - x3) - y1) % p
    return (x3, y3)

def ec_mul(k, P):
    R = O
    Q = P
    while k>0:
        if k & 1: R = ec_add(R, Q)
        Q = ec_add(Q, Q)
        k >>= 1
    return R

G = (Gx, Gy)
```

### ECDSA ì„œëª…/ê²€ì¦(í•™ìŠµìš©)

```python
import hashlib, os

def H256(m: bytes) -> int:
    return int.from_bytes(hashlib.sha256(m).digest(), 'big')

def ecdsa_keygen():
    d = (int.from_bytes(os.urandom(32), 'big') % n) or 1
    Q = ec_mul(d, G)
    return d, Q

def ecdsa_sign(m: bytes, d: int, k: Optional[int]=None):
    z = H256(m) % n
    if k is None:
        k = (int.from_bytes(os.urandom(32), 'big') % n) or 1
    R = ec_mul(k, G); r = R[0] % n
    if r == 0: raise RuntimeError("bad r")
    s = (inv_mod(k, n) * (z + r*d)) % n
    if s == 0: raise RuntimeError("bad s")
    return (r, s, k)  # êµìœ¡ìš©ìœ¼ë¡œ kë„ ë°˜í™˜

def ecdsa_verify(m: bytes, sig: Tuple[int,int], Q):
    r, s = sig
    if not (1 <= r < n and 1 <= s < n): return False
    z = H256(m) % n
    w = inv_mod(s, n)
    u1 = (z*w) % n; u2 = (r*w) % n
    X = ec_mul(u1, G); Y = ec_mul(u2, Q)
    P3 = ec_add(X, Y)
    if P3 is O: return False
    return (P3[0] % n) == r
```

### **nonce ì¬ì‚¬ìš© ì‚¬ê³ ** ì‹œ ë³µêµ¬(ë‘ ë©”ì‹œì§€ì— ê°™ì€ k ì‚¬ìš©)

```python
def recover_k_from_reused_nonce(r, s1, s2, z1, z2):
    k = ((z1 - z2) * inv_mod((s1 - s2) % n, n)) % n
    return k

def recover_d_from_one_sig(r, s, z, k):
    d = ((s*k - z) * inv_mod(r, n)) % n
    return d

# demo

d, Q = ecdsa_keygen()
# ê°™ì€ kë¥¼ ê°•ì œë¡œ ì‚¬ìš©

k_forced = (int.from_bytes(os.urandom(32), 'big') % n) or 1

m1 = b"order:pay=100,to=bob"
m2 = b"order:pay=200,to=bob"
r1, s1, k1 = ecdsa_sign(m1, d, k_forced)
r2, s2, k2 = ecdsa_sign(m2, d, k_forced)
assert r1 == r2  # ê°™ì€ k â†’ ê°™ì€ r

z1 = H256(m1) % n; z2 = H256(m2) % n
k_rec = recover_k_from_reused_nonce(r1, s1, s2, z1, z2)
d_rec = recover_d_from_one_sig(r1, s1, z1, k_rec)

print("[ECDSA reuse] k recovered:", k_rec == k_forced, "d recovered:", d_rec == d)
```

> **ìš´ì˜ êµí›ˆ**
> - `r`ê°€ **ì¤‘ë³µ**ë˜ëŠ” ì„œëª…ì´ íƒì§€ë˜ë©´ **ì¦‰ì‹œ í‚¤ íê¸°/íšŒì „**.
> - ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” **RFC 6979**(ë©”ì‹œì§€Â·ë¹„ë°€í‚¤ë¡œ ê²°ì •ì  `k`) ë˜ëŠ” **ê°•ë ¥ CSPRNG**ë¥¼ ì‚¬ìš©í•œë‹¤.
> - ì„œëª… ì¥ì¹˜(ì¹´ë“œ/HSM)ê°€ **ì „ì›/ì—”íŠ¸ë¡œí”¼ ë¶€ì¡±** ìƒíƒœì—ì„œ `k=0`Â·ì¤‘ë³µ ìƒì„±ë˜ëŠ” í˜„ìƒì„ ëª¨ë‹ˆí„°ë§.

### [ë³´ë„ˆìŠ¤] **ë°”ì´ì–´ìŠ¤ëœ k**(ìƒìœ„/í•˜ìœ„ ë¹„íŠ¸ ëˆ„ì„¤) â†’ **ê²©ì ê¸°ë°˜ ë³µêµ¬**(ê°œë…)

- ì—¬ëŸ¬ ì„œëª…ì—ì„œ `k = k_true + Î´` í˜•íƒœë¡œ ì‘ì€ ì˜¤ì°¨(ì˜ˆ: í•˜ìœ„ të¹„íŠ¸ê°€ 0, ìƒìœ„ ë¹„íŠ¸ê°€ ì§§ê²Œ ìƒì„±)ë©´
  **Lattice (Bleichenbacher/Howgrave-Graham)** ê¸°ë²•ìœ¼ë¡œ `d`ë¥¼ ë³µì›í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ë³¸ ë©ì—ëŠ” êµ¬í˜„ì„ í¬í•¨í•˜ì§€ ì•Šì§€ë§Œ, ìš”ì ì€ **â€œkì˜ ë¬´ì‘ìœ„ì„±Â·ê· ì¼ì„±â€**ì„ ë³´ì¥í•´ì•¼ í•œë‹¤ëŠ” ê²ƒ.

---

## ì¢…í•© ë¯¸ë‹ˆ CTF ê³¼ì œ

### CHAL-RSA-1: Fermatë¡œ ê¹¨ë¼

- ì„œë²„ê°€ `(n, e=65537)`ë¥¼ ì£¼ê³ , `p,q`ê°€ **ê°€ê¹ë‹¤**ëŠ” íŒíŠ¸ë¥¼ ì¤ë‹ˆë‹¤.
- **ëª©í‘œ**: `p,q`ë¥¼ ì°¾ì•„ ì„ì˜ ë©”ì‹œì§€ ë³µí˜¸ or ì„œëª… ìœ„ì¡°(êµìˆ˜í˜• ê³¼ì œë¼ë©´ ë³µí˜¸ë¡œ ì œí•œ).

í’€ì´ í¬ì¸íŠ¸: ìœ„ `fermat_factor`ë¥¼ ê·¸ëŒ€ë¡œ ì ìš© â†’ `p,q` â†’ `phi` â†’ `d`.

---

### CHAL-RSA-2: ê³µí†µ ëª¨ë“ˆëŸ¬ìŠ¤

- `(n, e1, c1), (n, e2, c2)` ì œê³µ, ë‘ ì•”í˜¸ë¬¸ì€ **ê°™ì€ í‰ë¬¸**.
- **ëª©í‘œ**: í‰ë¬¸ ë³µêµ¬.
í’€ì´ í¬ì¸íŠ¸: `common_modulus_recover`.

---

### CHAL-RSA-3: Wiener

- `(n, e)` ì œê³µ. íŒíŠ¸: â€œê°œì¸í‚¤ê°€ **ì‘ë‹¤**â€.
- **ëª©í‘œ**: `d` ë³µêµ¬.
í’€ì´ í¬ì¸íŠ¸: `wiener_attack`.

---

### CHAL-ECDSA-1: nonce ì¬ì‚¬ìš©

- ë‘ ì„œëª… `(r, s1)`, `(r, s2)` ë° ë©”ì‹œì§€ í•´ì‹œ `z1, z2` ì œê³µ.
- **ëª©í‘œ**: `k`ì™€ `d` ë³µêµ¬.
í’€ì´ í¬ì¸íŠ¸: `recover_k_from_reused_nonce` â†’ `recover_d_from_one_sig`.

---

## ì‹¤ë¬´ ì²´í¬ë¦¬ìŠ¤íŠ¸ (ë°”ë¡œ ì ìš©)

### RSA

- [ ] **í‚¤ ê¸¸ì´ â‰¥ 2048ë¹„íŠ¸**, ìš´ì˜ ì‹ ê·œëŠ” 3072/4096 ê²€í† .
- [ ] `e = 65537` ê³ ì •, **OAEP**(ì•”í˜¸í™”) / **PSS**(ì„œëª…).
- [ ] **p,q ë¬´ì‘ìœ„ ë…ë¦½**(ê°•í•œ CSPRNG), **ê°€ê¹Œìš´ ì†Œìˆ˜ íšŒí”¼**.
- [ ] ëŒ€ê·œëª¨ í‚¤ì…‹ì—ëŠ” **gcd ìŠ¤ìº”**ì„ ì •ê¸° ìˆ˜í–‰(ê³µìœ  ì†Œì¸ìˆ˜ íƒì§€).
- [ ] ë™ì¼ N ì¬ì‚¬ìš© ê¸ˆì§€(í‚¤ êµì²´ëŠ” **ìƒˆ í‚¤ìŒ** ìƒì„±).
- [ ] ê°€ëŠ¥í•˜ë©´ **ECDH/EdDSA** ë“± í˜„ëŒ€ ê³¡ì„ ìœ¼ë¡œ ì „í™˜ ê²€í† .

### ECDSA

- [ ] **RFC 6979** ë˜ëŠ” ì•ˆì „ CSPRNGë¡œ **ìœ ì¼í•œ k** ìƒì„±.
- [ ] `r` **ì¤‘ë³µ ëª¨ë‹ˆí„°ë§**(ë¡œê·¸/ì§€í‘œ), ë°œê²¬ ì‹œ ì¦‰ì‹œ íê¸°/íšŒì „.
- [ ] ì„œëª… ì¥ì¹˜ì˜ **ì—”íŠ¸ë¡œí”¼/ì „ì› í’ˆì§ˆ** ëª¨ë‹ˆí„°ë§(ë¶€íŠ¸Â·ë¶€í•˜ ì‹œ k ì¬ì‚¬ìš© ìœ„í—˜).
- [ ] ê°€ëŠ¥í•˜ë©´ **Ed25519/Ed448**(ë‚´ì¬ì ìœ¼ë¡œ ì•ˆì „í•œ nonce ì²˜ë¦¬) ì‚¬ìš©.

---

## ë¶€ë¡: ë‹¨ì¼ íŒŒì¼ ë© ìŠ¤í¬ë¦½íŠ¸

> ìœ„ ì½”ë“œ ë¸”ë¡ë“¤ì„ í•œ íŒŒì¼ë¡œ ë¶™ì´ë©´ ë°”ë¡œ ì‹¤í–‰ ê°€ëŠ¥í•œ **ìê¸‰ìì¡± ë©**ì´ ë©ë‹ˆë‹¤.
> ì¶”ì²œ ì‹¤í–‰ ìˆœì„œ: `1.1 â†’ 1.2 â†’ 1.3 â†’ 1.4 â†’ 1.5 â†’ 2.2`.

---

## ë¦¬ë·° ì§ˆë¬¸ (Self-check)

1) RSA textbook ê³µê²©ì´ í†µí•˜ëŠ” **ì •í™•í•œ ì „ì œ**ëŠ” ë¬´ì—‡ì¸ê°€? OAEPê°€ ì™œ ë°©ì–´ê°€ ë˜ëŠ”ê°€?
2) Fermat ë¶„í•´ì˜ **ë³µì¡ë„**ëŠ” p,q ê°„ê²© `|pâˆ’q|`ì— ì–´ë–»ê²Œ ì˜ì¡´í•˜ëŠ”ê°€?
3) Wiener ê³µê²©ì˜ **ì„±ë¦½ ì¡°ê±´**(`d < N^{1/4}/3`)ì€ ì‹¤ë¬´ì—ì„œ ì™œ ì˜ ë§Œì¡±ë˜ì§€ ì•ŠëŠ”ê°€?
4) ê³µí†µ ëª¨ë“ˆëŸ¬ìŠ¤ ê³µê²©ì´ ë°œìƒí•˜ëŠ” **ì¡°ì§ì  ì‹¤ìˆ˜**ëŠ” ë¬´ì—‡ì´ë©°, ì–´ë–»ê²Œ ë°©ì§€í•˜ëŠ”ê°€?
5) ECDSAì—ì„œ `r`ì´ ë™ì¼í•œ ì„œëª…ì´ ë‹¤ìˆ˜ ë°œê²¬ë˜ë©´ **ì¦‰ê°** í•´ì•¼ í•˜ëŠ” ì¡°ì¹˜ëŠ”?
6) RFC 6979 ê²°ì •ì  nonceê°€ â€œë§¤ë²ˆ ë™ì¼í•œ k ì•„ë‹Œê°€?â€ë¼ëŠ” ìš°ë ¤ì— ì–´ë–»ê²Œ ë‹µí•˜ê² ëŠ”ê°€?

---

### ë§ˆë¬´ë¦¬

ì´ ë©ì„ í†µí•´ **ì·¨ì•½ íŒŒë¼ë¯¸í„°/ì˜¤ìš©**ì´ ì‹¤ì œë¡œ ì–¼ë§ˆë‚˜ ì‰½ê²Œ ë¬´ë„ˆì§€ëŠ”ì§€ ì§ì ‘ í™•ì¸í–ˆìŠµë‹ˆë‹¤.
