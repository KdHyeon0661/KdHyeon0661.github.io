---
layout: post
title: DB 심화 - 테이블 파티셔닝
date: 2025-11-24 17:25:23 +0900
category: DB 심화
---
# 오라클 **테이블 파티셔닝**

> 모든 SQL은 **Oracle 기준**이며, 실행 후에는 반드시 실측 플랜을 확인한다.
>
> ```sql
> SELECT *
> FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
>          NULL, NULL,
>         'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS +PARTITION'
> ));
> ```

---

## 0) 파티셔닝을 “진짜로” 쓰는 이유 — 옵티마이저/운영/하드웨어 3축

### 성능(옵티마이저 관점)

파티셔닝은 단순히 “테이블을 쪼갠다”가 아니라, **옵티마이저의 탐색 공간을 줄이고 비용 모델을 현실화**한다.

- **Partition Pruning(파티션 프루닝)**
  WHERE 조건에 의해 **불필요 파티션을 스캔 대상에서 제외**해 **I/O 자체를 줄임**.
  (프루닝은 정적/동적/서브쿼리/조인 기반으로 다양하게 동작한다. )

- **Partition-Wise Join(파티션-와이즈 조인)**
  양쪽 테이블이 같은 키/경계/개수로 파티셔닝 돼 있으면
  **파티션끼리 1:1로 조인**해 **재분배·전역 해시빌드 없이 병렬 조인**이 가능해진다.

- **관리/통계 분할 효과**
  파티션별 통계를 가지므로 **카디널리티 추정이 더 안정**되며,
  증분 통계(Incremental)로 **새 파티션만 재수집**할 수 있다.

### 동시성/확장성(물리/병렬 관점)

- 파티션은 사실상 “미니 테이블 세그먼트”라서
  **파티션 단위 DML/DDL**이 가능하고, 병렬 스캔/조인 시 **파티션이 자연스러운 분할 단위**가 된다.
- 특히 **RANGE-HASH 결합 패턴**은 “기간관리 + 내부 균등분산”이라는 실전 최빈도 조합.

### 운영(수명주기/보관/압축 관점)

운영에서 파티셔닝의 진가는 “**슬라이딩 윈도우 + 메타데이터 작업**”이다.

- **EXCHANGE PARTITION**으로 대량 적재를 **메타데이터 교체 수준**으로 끝낸다.
- 오래된 파티션만 `MOVE/COMPRESS/READ ONLY`로 **저비용 스토리지/압축 단계로 자동 티어링**할 수 있다.
- Heat Map/ADO(Automatic Data Optimization)는 **파티션 단위로 자동 압축/이관 정책**을 실행한다.

---

## 1) 파티션 테이블의 내부 구조 — “메타 1개, 세그먼트 N개”

### 기본 모델

- 테이블 정의는 1개지만, **세그먼트는 파티션 수만큼** 생긴다.
- 딕셔너리 레벨에서는 **파티션별 통계/저장 옵션/TS**를 따로 관리한다.

```sql
SELECT table_name, partitioned
FROM   user_tables
WHERE  table_name = 'SALES';
```

### 파티션 키(Partition Key)

- 파티션 키는 “가장 자주 쓰는 필터 + 수명 정책 + 조인키 정합성”의 교집합이어야 한다.
- 연속 데이터(시간/시퀀스)면 RANGE, 분산/핫스팟 회피면 HASH, 범주형이면 LIST.

### 인덱스: LOCAL vs GLOBAL vs GLOBAL PARTITIONED

- **LOCAL INDEX**
  파티션과 1:1로 같이 쪼개진다.
  파티션 `SPLIT/MERGE/TRUNCATE/EXCHANGE` 시 **로컬 인덱스는 자동 정합 유지**.

- **GLOBAL INDEX**
  테이블 전체를 단일 세그먼트로 보는 인덱스.
  파티션 작업 후 **INVALID/UNUSABLE**이 되기 쉽다.
  전역 인덱스를 유지해야 할 때만 사용한다.

- **GLOBAL PARTITIONED INDEX**
  **인덱스도 파티셔닝한 전역 인덱스**.
  테이블 프루닝이 안 돼도 **인덱스 레벨 프루닝**을 할 수 있다.

---

## 2) Partition Pruning 심화 — 프루닝의 “종류와 조건”

프루닝은 “WHERE 조건이 파티션 키에 어떻게 표현돼 있느냐”에 따라 여러 방식이 있다.
아래 유형들은 옵티마이저가 실제로 구분해서 사용한다.

### Static Pruning(정적 프루닝)

파싱 시점에 파티션 범위가 확정된다.

```sql
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   sales
WHERE  sales_dt >= DATE '2025-10-01'
AND    sales_dt <  DATE '2025-11-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
```

- `PSTART/PSTOP`가 특정 파티션 번호로 고정되면 정적 프루닝.

### Dynamic Pruning(동적 프루닝)

바인드 변수 때문에 파싱 시점엔 범위를 몰라서, 실행 시점에 프루닝한다.

```sql
VAR b1 DATE; VAR b2 DATE;
EXEC :b1 := DATE '2025-10-01';
EXEC :b2 := DATE '2025-11-01';

EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   sales
WHERE  sales_dt >= :b1
AND    sales_dt <  :b2;
```

- 플랜에 “dynamic partition pruning” 관련 노트가 보일 수 있다.
- 바인드 값 분포가 넓으면 ACS/바인드 피킹이 함께 얽힌다.

### Subquery Pruning(서브쿼리 프루닝)

서브쿼리 결과를 이용해 파티션 범위를 줄인다.

```sql
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   sales
WHERE  sales_dt IN (
  SELECT MAX(sales_dt) FROM sales
);
```

### Join Pruning(조인 프루닝)

조인 상대의 조건으로 파티션을 제거한다.

```sql
-- DIM_US_EU 가 sales_dt 조건을 가진다고 가정
EXPLAIN PLAN FOR
SELECT /*+ USE_HASH(s d) */ SUM(s.amount)
FROM   sales s
JOIN   dim_us_eu d
  ON   s.sales_dt = d.sales_dt
WHERE  d.sales_dt >= DATE '2025-10-01'
AND    d.sales_dt <  DATE '2025-11-01';
```

### 프루닝 방해 요인(실무 최다)

- **파티션 키에 함수 적용**
- **묵시적 형변환**
- **비 SARGable 조건**

```sql
-- BAD: 함수가 파티션 키에 붙어 프루닝 불가 가능
WHERE TO_CHAR(sales_dt,'YYYYMM') = '202510'

-- GOOD: 범위 조건
WHERE sales_dt >= DATE '2025-10-01'
AND   sales_dt <  DATE '2025-11-01'
```

**해결 패턴**
1) 범위로 rewrite
2) 가상 컬럼 + 파티션
3) FBI(함수기반 인덱스) + 가상 컬럼 병행

---

## 3) RANGE 파티셔닝 — 시간/연속 구간의 정석

### 개념

- 연속 구간의 상한값(LESS THAN)으로 분할.
- **기간 슬라이딩 윈도우 운영**에 최적.

### 월별 RANGE 파티션 예제(US/EU 리테일 매출)

```sql
DROP TABLE sales PURGE;

CREATE TABLE sales (
  sales_id   NUMBER        NOT NULL,
  sales_dt   DATE          NOT NULL,
  cust_id    NUMBER        NOT NULL,
  region_cd  VARCHAR2(6)   NOT NULL, -- 'US','DE','FR','UK','ES','IT','NL' 등
  amount     NUMBER(12,2)  NOT NULL,
  CONSTRAINT pk_sales PRIMARY KEY (sales_id, sales_dt)
)
PARTITION BY RANGE (sales_dt) (
  PARTITION p2025m09 VALUES LESS THAN (DATE '2025-10-01'),
  PARTITION p2025m10 VALUES LESS THAN (DATE '2025-11-01'),
  PARTITION p2025m11 VALUES LESS THAN (DATE '2025-12-01'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

CREATE INDEX sales_cust_lix ON sales(cust_id) LOCAL;
```

**UNIQUE LOCAL 규칙**
- “UNIQUE LOCAL 인덱스는 반드시 파티션 키를 포함”해야 한다.

### 데이터 로딩(샘플)

```sql
BEGIN
  FOR i IN 1..200000 LOOP
    INSERT INTO sales VALUES(
      i,
      DATE '2025-09-01' + MOD(i, 90),
      MOD(i, 50000)+1,
      CASE MOD(i,7)
        WHEN 0 THEN 'US'
        WHEN 1 THEN 'DE'
        WHEN 2 THEN 'FR'
        WHEN 3 THEN 'UK'
        WHEN 4 THEN 'ES'
        WHEN 5 THEN 'IT'
        ELSE 'NL'
      END,
      ROUND(DBMS_RANDOM.VALUE(5,500),2)
    );
  END LOOP;
  COMMIT;
END;
/
```

### 프루닝 관측

```sql
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   sales
WHERE  sales_dt >= DATE '2025-10-01'
AND    sales_dt <  DATE '2025-11-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
```

### 유지보수 패턴(운영 필수)

```sql
-- 다음 달 추가
ALTER TABLE sales ADD PARTITION p2025m12
VALUES LESS THAN (DATE '2026-01-01');

-- 오래된 파티션 빠른 삭제
ALTER TABLE sales TRUNCATE PARTITION p2025m09 UPDATE GLOBAL INDEXES;

-- 경계 조정
ALTER TABLE sales SPLIT PARTITION p2025m10
AT (DATE '2025-10-15')
INTO (PARTITION p2025m10a, PARTITION p2025m10b)
UPDATE GLOBAL INDEXES;

-- 병합
ALTER TABLE sales MERGE PARTITIONS p2025m10a, p2025m10b
INTO PARTITION p2025m10
UPDATE GLOBAL INDEXES;
```

---

## 4) INTERVAL RANGE — 파티션 자동 생성

### 개념

- RANGE의 “운영 자동화 버전”.
- 새 구간 데이터가 들어오면 Oracle이 **새 파티션을 자동 생성**.

```sql
DROP TABLE sales_int PURGE;

CREATE TABLE sales_int (
  sales_id NUMBER PRIMARY KEY,
  sales_dt DATE NOT NULL,
  amount   NUMBER(12,2)
)
PARTITION BY RANGE (sales_dt)
INTERVAL (NUMTOYMINTERVAL(1,'MONTH'))
(
  PARTITION p0 VALUES LESS THAN (DATE '2025-01-01')
);

INSERT INTO sales_int VALUES(1, DATE '2025-11-12', 100);
COMMIT;
-- p2025m11 자동 생성
```

### 주의

- 자동 생성 파티션의 TS/압축/서브파티션을 제어하려면
  **서브파티션 템플릿/DEFAULT 속성**을 미리 정의한다.

---

## 5) HASH 파티셔닝 — 균등 분산/핫스팟 완화

### 개념

- 키를 해시로 분산.
- “**등치 조건(=, IN)**에서 프루닝 가능”.
- 시간 슬라이딩에는 부적합, **스큐 완화/병렬 분할**이 핵심.

### 예제: 고객ID 16-way HASH

```sql
DROP TABLE cust_tx PURGE;

CREATE TABLE cust_tx (
  tx_id    NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL,
  tx_dt    DATE   NOT NULL,
  amount   NUMBER(12,2)
)
PARTITION BY HASH (cust_id)
PARTITIONS 16;
```

### 프루닝 확인

```sql
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   cust_tx
WHERE  cust_id IN (101,202);

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
```

### 운영 포인트

- 파티션 개수 변경은 “재정의/재로딩” 급의 작업.
  **처음부터 넉넉히(예: 32/64/128)** 잡고 가는 게 정석.

---

## 6) LIST 파티셔닝 — 범주형 관리/프루닝 최강

### 개념

- 명시한 값 집합으로 분할.
- 특정 그룹 단위 삭제/압축/이관이 쉽다.

### 예제: US/EU 지역 코드 LIST

```sql
DROP TABLE region_acc PURGE;

CREATE TABLE region_acc (
  acc_id     NUMBER PRIMARY KEY,
  region_cd  VARCHAR2(6) NOT NULL,
  acc_dt     DATE NOT NULL,
  amount     NUMBER(12,2)
)
PARTITION BY LIST (region_cd) (
  PARTITION p_us VALUES ('US'),
  PARTITION p_eu VALUES ('DE','FR','UK','ES','IT','NL'),
  PARTITION p_etc VALUES (DEFAULT)
);
```

### 값 추가/분리

```sql
-- 'CA'를 p_etc에서 분리
ALTER TABLE region_acc SPLIT PARTITION p_etc VALUES ('CA')
INTO (PARTITION p_ca, PARTITION p_etc)
UPDATE GLOBAL INDEXES;
```

---

## 7) COMPOSITE(결합) 파티셔닝 — 현실은 항상 2단계다

### 왜 결합이 필요한가

- “시간(운영)”과 “균등분산(성능)”을 동시에 원한다.
- 따라서 **RANGE(상위) + HASH(하위)**가 실전 1위.

### RANGE–HASH(월 × 고객해시)

```sql
DROP TABLE sales_rh PURGE;

CREATE TABLE sales_rh (
  sales_id NUMBER NOT NULL,
  sales_dt DATE   NOT NULL,
  cust_id  NUMBER NOT NULL,
  amount   NUMBER(12,2),
  CONSTRAINT pk_sales_rh PRIMARY KEY(sales_id, sales_dt)
)
PARTITION BY RANGE (sales_dt)
SUBPARTITION BY HASH (cust_id)
SUBPARTITIONS 8
(
  PARTITION p2025m10 VALUES LESS THAN (DATE '2025-11-01'),
  PARTITION p2025m11 VALUES LESS THAN (DATE '2025-12-01'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

CREATE INDEX sales_rh_cust_lix ON sales_rh(cust_id) LOCAL;
```

**프루닝**
- 상위(날짜 RANGE) 프루닝
- 하위(cust_id HASH) 프루닝
이 “2단”으로 동시에 일어난다.

```sql
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   sales_rh
WHERE  sales_dt >= DATE '2025-11-01'
AND    sales_dt <  DATE '2025-12-01'
AND    cust_id IN (101,202);

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
```

### RANGE–LIST(월 × 지역)

```sql
DROP TABLE sales_rl PURGE;

CREATE TABLE sales_rl (
  sales_id  NUMBER PRIMARY KEY,
  sales_dt  DATE NOT NULL,
  region_cd VARCHAR2(6) NOT NULL,
  amount    NUMBER(12,2)
)
PARTITION BY RANGE (sales_dt)
SUBPARTITION BY LIST (region_cd)
SUBPARTITION TEMPLATE (
  SUBPARTITION sp_us VALUES ('US'),
  SUBPARTITION sp_eu VALUES ('DE','FR','UK','ES','IT','NL'),
  SUBPARTITION sp_etc VALUES (DEFAULT)
)
(
  PARTITION p2025m11 VALUES LESS THAN (DATE '2025-12-01'),
  PARTITION p2025m12 VALUES LESS THAN (DATE '2026-01-01')
);
```

- 템플릿으로 **새 월 파티션에도 동일한 서브파티션 구조 자동 적용**.

---

## 8) REFERENCE 파티셔닝 — 부모를 기준으로 자식 자동 분할

### 개념

- 부모 테이블의 파티션 키/경계와 **동일하게 자식 테이블을 자동 파티셔닝**한다.
- 스타 스키마/팩트-디멘전에서 관리/조인 최적화에 매우 유리.

### 예제: 주문(부모 RANGE) ↔ 주문상세(자식 REFERENCE)

```sql
DROP TABLE orders PURGE;
DROP TABLE order_items PURGE;

CREATE TABLE orders (
  order_id NUMBER PRIMARY KEY,
  order_dt DATE NOT NULL,
  cust_id  NUMBER NOT NULL,
  amount   NUMBER(12,2)
)
PARTITION BY RANGE (order_dt) (
  PARTITION p2025m11 VALUES LESS THAN (DATE '2025-12-01'),
  PARTITION p2025m12 VALUES LESS THAN (DATE '2026-01-01'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

CREATE TABLE order_items (
  order_id NUMBER NOT NULL,
  item_no  NUMBER NOT NULL,
  prod_id  NUMBER NOT NULL,
  qty      NUMBER NOT NULL,
  amount   NUMBER(12,2),
  CONSTRAINT pk_oi PRIMARY KEY(order_id, item_no),
  CONSTRAINT fk_oi_orders FOREIGN KEY(order_id)
    REFERENCES orders(order_id)
)
PARTITION BY REFERENCE (fk_oi_orders);
```

- 자식 파티션을 따로 설계하지 않아도 **부모와 1:1 구조가 보장**된다.

---

## 9) PARTITION-WISE JOIN — 파티셔닝의 “궁극의 보상”

### Full vs Partial

- **Full P-Wise Join**
  두 테이블이 **동일한 파티션 방식/키/경계/개수**이고 조인키가 파티션키면
  **파티션끼리 1:1 조인**한다.

- **Partial P-Wise Join**
  한쪽만 파티셔닝되었거나 경계가 일부만 맞을 때 **부분 혜택**.

### 예제: 월×cust_hash 동일 구조의 2테이블 조인

```sql
-- customer_dim도 동일한 HASH(8-way) 구조라고 가정
-- (핵심은 "같은 subpartition 수/해시 기준" 일치)

SELECT /*+ USE_HASH(s c) FULL(s) FULL(c) */
       SUM(s.amount)
FROM   sales_rh s
JOIN   customer_dim c
  ON   s.cust_id = c.cust_id
WHERE  s.sales_dt >= DATE '2025-11-01'
AND    s.sales_dt <  DATE '2025-12-01';
```

**관측 포인트**
- 플랜에 `PARTITION HASH ALL` / `PARTITION RANGE SINGLE` 같은 라인이 보이며
- 조인 단계가 **각 파티션 단위로 분리**된다.

---

## 10) 인덱스 설계 실전 — “LOCAL이 기본, GLOBAL은 예외”

### Local Index가 기본인 이유

- 유지보수 자동화
- DML 부담 분산
- 프루닝과 정렬 최적화가 자연스럽게 묶임

```sql
CREATE INDEX sales_amt_lix ON sales(amount) LOCAL;
```

### Global(또는 Global Partitioned) Index가 필요한 상황

- **파티션 키와 무관한 전역 유일성**이 반드시 필요할 때
- “시간 범위 밖의 단건 조회”가 핵심 워크로드일 때

```sql
CREATE UNIQUE INDEX sales_uid_gix ON sales(sales_id) GLOBAL;
```

### 파티션 작업과 전역 인덱스

- `TRUNCATE/SPLIT/MERGE/EXCHANGE` 시
  전역 인덱스는 UNUSABLE이 될 수 있어
  `UPDATE GLOBAL INDEXES` 또는 리빌드가 필요하다.

---

## 11) 통계(Partition Stats) — 파티션을 쪼개도 통계는 더 잘 쪼개야 한다

### 파티션/글로벌 통계 수집

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'SALES',
    granularity=> 'AUTO',
    cascade    => TRUE,
    method_opt => 'FOR ALL COLUMNS SIZE SKEWONLY'
  );
END;
/
```

### Incremental Global Stats(대용량 필수)

```sql
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'SALES','INCREMENTAL','TRUE');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES', cascade=>TRUE);
END;
/
```

- 새 파티션만 수집하고 글로벌은 시놉시스로 합성.

---

## 12) 운영 패턴 Cookbook

### EXCHANGE PARTITION(대량 적재)

```sql
CREATE TABLE sales_stage AS SELECT * FROM sales WHERE 1=0;

-- stage에 bulk load 후
ALTER TABLE sales
EXCHANGE PARTITION p2025m11
WITH TABLE sales_stage
INCLUDING INDEXES WITHOUT VALIDATION;
```

### 슬라이딩 윈도우(월별)

```sql
-- 다음 달 추가
ALTER TABLE sales ADD PARTITION p2026m01
VALUES LESS THAN (DATE '2026-02-01');

-- 3개월 지난 파티션 제거
ALTER TABLE sales TRUNCATE PARTITION p2025m09 UPDATE GLOBAL INDEXES;
```

### Heat Map/ADO 기반 자동 압축·이관

Heat Map은 파티션/세그먼트의 사용 패턴을 기록하고,
ADO는 이를 기반으로 **파티션 단위 자동 압축/스토리지 티어링 정책**을 실행한다.

```sql
-- 예: 30일 이상 미조회 파티션을 OLTP 압축으로 자동 전환(개념 예시)
ALTER TABLE sales ILM ADD POLICY
  COMPRESS FOR OLTP
  AFTER 30 DAYS OF NO ACCESS;
```

---

## 13) 트러블슈팅 — “프루닝이 안 된다/느리다/플랜이 흔들린다”

### 프루닝이 안 될 때

1) 파티션 키에 함수/형변환 여부
2) 조건이 SARGable인지
3) 바인드 때문에 dynamic pruning이 실패하는지
4) 통계가 stale인지

**해결**
- 조건 rewrite
- 가상 컬럼 파티션
- 히스토그램/ACS
- 증분 통계

### 핫 파티션/스큐

- RANGE 최신 파티션에 DML 집중 → 핫스팟
- 해결: **RANGE-HASH 서브파티션**, 또는 최신 분할을 더 촘촘히

### 글로벌 인덱스 UNUSABLE

- 파티션 작업 후 `user_indexes.status` 확인
- 필요 시 온라인 리빌드

---

## 14) End-to-End 실전 설계 예시 — US/EU 웹 로그 1억/일

### 요구

- 하루 1억 건 클릭스트림
- **최근 7일 핫(압축X)**, 이후 90일 콜드(압축+READ ONLY), 90일 초과 삭제
- 분석은 최근 30일 + 특정 고객 집중(=, IN)

### 설계

- **RANGE(일) + HASH(cust_id 8-way)**

```sql
CREATE TABLE web_log (
  log_id   NUMBER NOT NULL,
  log_dt   DATE   NOT NULL,
  cust_id  NUMBER NOT NULL,
  region_cd VARCHAR2(6) NOT NULL, -- 'US','DE','FR','UK',...
  uri      VARCHAR2(2000),
  status   NUMBER(3),
  bytes    NUMBER
)
PARTITION BY RANGE (log_dt)
SUBPARTITION BY HASH (cust_id) SUBPARTITIONS 8
(
  PARTITION p2025d11 VALUES LESS THAN (DATE '2025-11-12'),
  PARTITION p2025d12 VALUES LESS THAN (DATE '2025-11-13'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

CREATE INDEX web_log_status_lix ON web_log(status) LOCAL;
```

### 일일 운영 배치(요지)

```sql
BEGIN
  -- (1) 내일 파티션 추가
  EXECUTE IMMEDIATE q'[
    ALTER TABLE web_log ADD PARTITION p2025d13
    VALUES LESS THAN (DATE '2025-11-14')
  ]';

  -- (2) 7일 지난 파티션 압축 + RO
  EXECUTE IMMEDIATE q'[
    ALTER TABLE web_log MOVE PARTITION p2025d05 COMPRESS FOR OLTP
  ]';
  EXECUTE IMMEDIATE q'[
    ALTER TABLE web_log MODIFY PARTITION p2025d05 READ ONLY
  ]';

  -- (3) 90일 지난 파티션 삭제(롤링 계산 필요)
  EXECUTE IMMEDIATE q'[
    ALTER TABLE web_log TRUNCATE PARTITION p2025dxx UPDATE GLOBAL INDEXES
  ]';
END;
/
```

### 분석 쿼리

```sql
-- 최근 7일 상태별 트래픽(날짜 프루닝 + 서브파티션 분산)
SELECT status, SUM(bytes)
FROM   web_log
WHERE  log_dt >= SYSDATE - 7
GROUP  BY status;

-- 특정 고객 Top URI(해시 프루닝)
SELECT uri, COUNT(*) cnt
FROM   web_log
WHERE  cust_id = :b1
AND    log_dt >= SYSDATE - 30
GROUP  BY uri
ORDER  BY cnt DESC
FETCH FIRST 20 ROWS ONLY;
```

---

## 15) 설계 체크리스트(현업용)

1. **파티션 키는 “필터+수명+조인”의 교집합인가?**
2. RANGE가 기본, 핫스팟/분산이 필요하면 HASH 서브파티션.
3. **Local Index 우선**, 전역 유일성이 필요한 경우에만 Global.
4. 새 파티션 생성/교체 흐름을 **EXCHANGE + 슬라이딩 윈도우**로 자동화했는가?
5. 프루닝/Partition-wise Join이 **실제 플랜에서 보이는가?**
6. 증분 통계로 운영 비용을 줄였는가?
7. 압축/티어링은 Heat Map/ADO 정책으로 장기 자동화가 가능한가?

---

## 마무리

- 파티셔닝은 “큰 테이블을 나누는 기술”이 아니라
  **옵티마이저가 데이터 수명과 접근 패턴을 이해하도록 ‘구조적 힌트’를 주는 행위**다.
- **Pruning**으로 I/O를 제거하고,
  **Partition-wise Join**으로 조인 비용을 분할하며,
  **슬라이딩 윈도우/EXCHANGE/ILM**로 운영비를 최소화하는 것이 실전의 핵심이다.
- 마지막으로, 어떤 파티셔닝도 **실측 플랜/통계가 확인해주지 않으면 가설**일 뿐이다.
  항상 `DBMS_XPLAN ... +PARTITION +IOSTATS +MEMSTATS`로 눈으로 검증하라.
