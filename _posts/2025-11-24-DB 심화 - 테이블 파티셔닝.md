---
layout: post
title: DB 심화 - 테이블 파티셔닝
date: 2025-11-24 17:25:23 +0900
category: DB 심화
---
# 오라클 **테이블 파티셔닝** 완전 가이드

**주제**: 파티션 기본 구조 → RANGE 파티셔닝 → HASH 파티셔닝 → LIST 파티셔닝 → **결합(Composite) 파티셔닝**
**목표**: “왜/언제/어떻게”를 코드와 실행 시나리오로 **끝까지** 이해하기

---

## 0) 큰 그림: 파티셔닝을 쓰는 이유

- **성능**: 스캔 범위를 **파티션 단위로 잘라내기(Partition Pruning)** → 읽는 블록 수↓, I/O↓
- **동시성**: 작업을 파티션 단위로 병렬화 → 각 파티션이 사실상 **미니-테이블**
- **운영 편의**: **파티션 교체/분할/병합/이관/압축/읽기전용** 같은 **일괄 관리**
- **데이터 수명**: 오래된 파티션 **TRUNCATE/MOVE** 로 빠른 보관/삭제

> 핵심 용어
> - **Partition Key**: 파티션을 나누는 기준 컬럼
> - **Local Index**: 파티션과 **1:1**로 나뉘는 인덱스(유지보수 쉽고 DML 부담 낮음)
> - **Global Index**: 테이블 전체를 통합한 인덱스(파티션 작업 시 재빌드 고려)
> - **Partition Pruning**: WHERE 조건으로 **불필요 파티션을 배제**
> - **Partition-Wise Join**: 양쪽 테이블을 같은 키/방식으로 나누면 **파티션끼리** 조인

---

## 1) 파티션 기본 구조

### 파티션과 인덱스의 기본

- 파티션 테이블은 **메타는 1개**, **세그먼트는 파티션 개수만큼** 생김.
- 인덱스는 **LOCAL** 추천(유지보수 쉬움). **UNIQUE LOCAL**은 **파티션 키가 반드시 인덱스 키에 포함**돼야 함.
- **GLOBAL** 인덱스는 단일 세그먼트 → 파티션 `SPLIT/MERGE/TRUNCATE/EXCHANGE` 시 **불일치** 발생 가능 → **REBUILD/UPDATE INDEX** 필요.

### 운영 기본 옵션

- **ROW MOVEMENT**: `UPDATE`로 파티션 키가 변할 수 있으면 **필수**.
- **TABLESPACE 분리**: 파티션별/기간별 다른 TS로 보관, 읽기 전용(READ ONLY) 등 관리.
- **압축/ILM**: 오래된 파티션만 **압축/압축 단계 변경**(Advanced Compression/Hybrid Columnar Compression 등).

```sql
-- 공용 사용자/환경 가정
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';

-- 파티션 키 변경 허용
ALTER TABLE sales ENABLE ROW MOVEMENT;
```

---

## 2) RANGE 파티셔닝 (가장 보편적)

### 개념

- **연속 구간**(날짜/숫자)의 **상한 값**으로 파티션을 나눔.
- WHERE 절이 `BETWEEN`, `>=`, `<` 형태일 때 **Pruning 효과**가 매우 큼.

> 기대 분포(대략): 파티션 수를 \( N \)이라 하면 날짜가 균등하면 **한 파티션당**
> $$ \text{기대 행수} \approx \frac{\text{총 행수}}{N} $$
> (실데이터는 특정 구간에 몰릴 수 있으니 **경계/기간 설계**가 중요)

### 예제: **월별 RANGE 파티션**

```sql
DROP TABLE sales PURGE;

CREATE TABLE sales (
  sales_id    NUMBER        PRIMARY KEY,
  sales_dt    DATE          NOT NULL,
  cust_id     NUMBER        NOT NULL,
  region_cd   VARCHAR2(6)   NOT NULL,
  amount      NUMBER(12,2)  NOT NULL
)
PARTITION BY RANGE (sales_dt) (
  PARTITION p2024m12 VALUES LESS THAN (DATE '2025-01-01') TABLESPACE ts_2024,
  PARTITION p2025m01 VALUES LESS THAN (DATE '2025-02-01') TABLESPACE ts_2025,
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01') TABLESPACE ts_2025,
  PARTITION pmax    VALUES LESS THAN (MAXVALUE)            TABLESPACE ts_new
);

-- 로컬 인덱스(권장)
CREATE INDEX sales_cust_lix ON sales(cust_id) LOCAL;

-- 글로벌 인덱스(주의)
CREATE INDEX sales_cust_gix ON sales(cust_id) GLOBAL;
```

### Pruning 확인

```sql
EXPLAIN PLAN FOR
SELECT /* 월 범위 스캔: p2025m02만 읽어야 함 */
       SUM(amount)
FROM   sales
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
```
- 실행계획의 `PSTART/PSTOP`이 **동일 파티션 번호**로 표시되면 **완전 프루닝** 성공.

### 유지보수(운영 필수 패턴)

```sql
-- (1) 다음달 파티션 "추가"
ALTER TABLE sales ADD PARTITION p2025m03
  VALUES LESS THAN (DATE '2025-04-01') TABLESPACE ts_2025;

-- (2) 오래된 월 "TRUNCATE"로 빠른 삭제
ALTER TABLE sales TRUNCATE PARTITION p2024m12 UPDATE GLOBAL INDEXES;

-- (3) 경계 잘못 잡았을 때 "SPLIT"
ALTER TABLE sales SPLIT PARTITION p2025m02 AT (DATE '2025-02-15')
  INTO (PARTITION p2025m02a, PARTITION p2025m02b)
  UPDATE GLOBAL INDEXES;

-- (4) 두 파티션 "MERGE"
ALTER TABLE sales MERGE PARTITIONS p2025m01, p2025m02 INTO PARTITION p2025q1
  UPDATE GLOBAL INDEXES;
```

### Interval Range (자동 월단위 생성)

```sql
DROP TABLE sales2 PURGE;

CREATE TABLE sales2 (
  sales_id  NUMBER PRIMARY KEY,
  sales_dt  DATE   NOT NULL,
  amount    NUMBER
)
PARTITION BY RANGE (sales_dt) INTERVAL (NUMTOYMINTERVAL(1,'MONTH')) (
  PARTITION p0 VALUES LESS THAN (DATE '2025-01-01')
);

-- 2025-05 데이터가 들어오면 p2025m05가 "자동 생성"
INSERT INTO sales2 VALUES (1, DATE '2025-05-10', 100);
COMMIT;
```

---

## 3) HASH 파티셔닝 (균등분산/치우침 완화)

### 개념

- 키 값을 **해시 함수**로 분산 → **파티션 수가 고정**이고 **균등화에 강함**.
- WHERE 절이 **등치 조건(=, IN)** 일 때 **프루닝**이 적용된다.
- 날짜 범위 같은 **연속성**엔 부적합, **스큐(치우침)** 완화가 목적.

### 예제: **cust_id 해시 8-way**

```sql
DROP TABLE cust_tx PURGE;

CREATE TABLE cust_tx (
  tx_id    NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL,
  tx_dt    DATE   NOT NULL,
  amount   NUMBER(12,2)
)
PARTITION BY HASH (cust_id)
PARTITIONS 8
STORE IN (ts_h1, ts_h2, ts_h3, ts_h4, ts_h5, ts_h6, ts_h7, ts_h8);

-- 해시 프루닝(=, IN)
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   cust_tx
WHERE  cust_id = :b1;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
```

### 유지보수

- **파티션 수 변경**은 **쉬운 작업이 아님**(재생성 or EXCHANGE를 활용한 롤링 재배치).
- 일반적으로 **처음에 충분한 개수**(예: 32, 64…)를 잡고 시작.

---

## 4) LIST 파티셔닝 (명시적 값 그룹)

### 개념

- **명시한 값 집합**으로 나눔. 국가/지역코드/상태값 등 **불연속/범주형 데이터**에 적합.
- WHERE 절이 `=`, `IN`이면 **정확 프루닝** → 특정 지역만 즉시 스캔.

### 예제: **지역 코드 LIST**

```sql
DROP TABLE region_acc PURGE;

CREATE TABLE region_acc (
  acc_id     NUMBER PRIMARY KEY,
  region_cd  VARCHAR2(6) NOT NULL,
  acc_dt     DATE NOT NULL,
  amount     NUMBER
)
PARTITION BY LIST (region_cd) (
  PARTITION p_kr  VALUES ('KR'),
  PARTITION p_us  VALUES ('US'),
  PARTITION p_eu  VALUES ('DE','FR','ES','IT','NL'),
  PARTITION p_etc VALUES (DEFAULT)   -- 나머지(기본) 파티션
);

-- LIST 프루닝
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   region_acc
WHERE  region_cd IN ('KR','US');

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
```

### 유지보수

```sql
-- 값 추가: 'JP'를 p_etc에서 별도 파티션으로 분리
ALTER TABLE region_acc SPLIT PARTITION p_etc VALUES ('JP')
  INTO (PARTITION p_jp, PARTITION p_etc) UPDATE GLOBAL INDEXES;

-- 특정 국가만 빠르게 삭제
ALTER TABLE region_acc TRUNCATE PARTITION p_us UPDATE GLOBAL INDEXES;
```

---

## 5) 결합(Composite) 파티셔닝

> **2단계 파티션**: **상위(Partition)** + **하위(Subpartition)**
> 대표 조합
> - **RANGE-HASH**: 날짜(상위) × 고객ID(하위) → **기간별+균등분산**
> - **RANGE-LIST**: 날짜 × 지역 → **기간별+지역별 관리**
> - **LIST-HASH**, **LIST-RANGE** 등 상황에 맞게

### RANGE-HASH (월별 × 고객 해시)

- 장점: 월별 관리가 쉽고, 월 내부에서는 해시로 균등 분산 → **파티션-와이즈 조인**에 유리

```sql
DROP TABLE sales_rh PURGE;

CREATE TABLE sales_rh (
  sales_id  NUMBER PRIMARY KEY,
  sales_dt  DATE   NOT NULL,
  cust_id   NUMBER NOT NULL,
  amount    NUMBER
)
PARTITION BY RANGE (sales_dt)
SUBPARTITION BY HASH (cust_id)
SUBPARTITIONS 8
(
  PARTITION p2025m01 VALUES LESS THAN (DATE '2025-02-01')
    (SUBPARTITION p2025m01_h1, SUBPARTITION p2025m01_h2, SUBPARTITION p2025m01_h3,
     SUBPARTITION p2025m01_h4, SUBPARTITION p2025m01_h5, SUBPARTITION p2025m01_h6,
     SUBPARTITION p2025m01_h7, SUBPARTITION p2025m01_h8),
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01')
    (SUBPARTITION p2025m02_h1, SUBPARTITION p2025m02_h2, SUBPARTITION p2025m02_h3,
     SUBPARTITION p2025m02_h4, SUBPARTITION p2025m02_h5, SUBPARTITION p2025m02_h6,
     SUBPARTITION p2025m02_h7, SUBPARTITION p2025m02_h8),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
    (SUBPARTITION pmax_h1, pmax_h2, pmax_h3, pmax_h4, pmax_h5, pmax_h6, pmax_h7, pmax_h8)
);

-- 로컬 인덱스: 파티션/서브파티션과 함께 분할
CREATE INDEX sales_rh_amt_lix ON sales_rh(amount) LOCAL;

-- 프루닝: 날짜로 상위 파티션 → cust_id로 하위 서브파티션까지 프루닝 가능(=, IN)
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   sales_rh
WHERE  sales_dt >= DATE '2025-02-01' AND sales_dt < DATE '2025-03-01'
AND    cust_id IN (101, 202);

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
```

### RANGE-LIST (월별 × 지역코드)

- 장점: 월 단위 운영 + 지역별 관리/알아보기 쉬움

```sql
DROP TABLE sales_rl PURGE;

CREATE TABLE sales_rl (
  sales_id   NUMBER PRIMARY KEY,
  sales_dt   DATE NOT NULL,
  region_cd  VARCHAR2(6) NOT NULL,
  amount     NUMBER
)
PARTITION BY RANGE (sales_dt)
SUBPARTITION BY LIST (region_cd)
(
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01') (
    SUBPARTITION p2025m02_kr VALUES ('KR'),
    SUBPARTITION p2025m02_us VALUES ('US'),
    SUBPARTITION p2025m02_eu VALUES ('DE','FR','ES','IT','NL'),
    SUBPARTITION p2025m02_etc VALUES (DEFAULT)
  ),
  PARTITION p2025m03 VALUES LESS THAN (DATE '2025-04-01') (
    SUBPARTITION p2025m03_kr VALUES ('KR'),
    SUBPARTITION p2025m03_us VALUES ('US'),
    SUBPARTITION p2025m03_eu VALUES ('DE','FR','ES','IT','NL'),
    SUBPARTITION p2025m03_etc VALUES (DEFAULT)
  )
);

-- 월+국가로 강력한 프루닝
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   sales_rl
WHERE  sales_dt >= DATE '2025-03-01' AND sales_dt < DATE '2025-04-01'
AND    region_cd IN ('KR','US');

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
```

### 결합 설계 팁

- **RANGE(시간) + HASH(ID)**: **가장 자주 쓰이는** 범용 패턴
- **RANGE + LIST**: 기간별 **지역/상태** 묶음 관리가 필요할 때
- **LIST + HASH**: 국가/고객 같은 고정 범주 + 균등분산
- 서브파티션 개수는 **두 테이블을 동일하게** 맞추면 **Full Partition-Wise Join** 가능:
  - 두 테이블이 같은 파티션 키/경계/개수로 나뉘고, 조인 조건이 그 키일 때
  - 옵티마이저는 **파티션쌍끼리 병렬 조인**을 계획할 수 있음

---

## 6) 기본 운영 시나리오 (현업 필수)

### 대량 적재: **EXCHANGE PARTITION**

- 스테이징 테이블에 로드 → **메타데이터 교체 수준**으로 빠르게 반영
- 데이터 검증/인덱스 유지 옵션 주의

```sql
-- 스테이징 테이블(비파티션) 준비: 구조/NOT NULL 동일, 인덱스 불필요
CREATE TABLE sales_stage AS SELECT * FROM sales WHERE 1=0;

-- 외부에서 로딩(BULK INSERT 등) 후
ALTER TABLE sales EXCHANGE PARTITION p2025m02 WITH TABLE sales_stage
  INCLUDING INDEXES WITHOUT VALIDATION;  -- 데이터 경계가 확실할 때만 WITHOUT VALIDATION

-- 만약 글로벌 인덱스가 있으면 상태 확인/REBUILD 필요할 수 있음
```

### 오래된 데이터: **MOVE/COMPRESS/READ ONLY**

```sql
-- 오래된 파티션을 압축/저렴 TS로 이관
ALTER TABLE sales MOVE PARTITION p2025m01 TABLESPACE ts_archive COMPRESS FOR OLTP;

-- 더 이상 변경 없음 → 읽기 전용
ALTER TABLE sales MODIFY PARTITION p2025m01 READ ONLY;
```

### 빠른 삭제: **TRUNCATE PARTITION**

```sql
ALTER TABLE sales TRUNCATE PARTITION p2025m01 UPDATE GLOBAL INDEXES;
```

### 메타 점검 뷰

```sql
SELECT partition_name, high_value, tablespace_name
FROM   user_tab_partitions
WHERE  table_name = 'SALES';

SELECT subpartition_name, high_value, tablespace_name
FROM   user_tab_subpartitions
WHERE  table_name = 'SALES_RH';

SELECT * FROM user_part_key_columns WHERE name='SALES';
SELECT * FROM user_subpart_key_columns WHERE name='SALES_RH';
```

---

## 7) 인덱스 전략 (Local vs Global)

### Local Index (추천)

- 파티션과 **같이 쪼개짐** → 파티션 작업 시 자동 **로컬 인덱스도 함께 조정**
- **UNIQUE LOCAL** 은 파티션 키를 반드시 포함해야 함:
```sql
-- 올바른 예: (sales_id, sales_dt) UNIQUE LOCAL
CREATE UNIQUE INDEX sales_u1 ON sales(sales_id, sales_dt) LOCAL;
```

### Global Index (주의)

- 전체를 1세그먼트로 유지 → 파티션 작업 후 **불일치** 상태 발생 → `UPDATE GLOBAL INDEXES` 또는 **REBUILD** 필요.
```sql
-- 글로벌 UNIQUE를 유지해야 할 때만
CREATE UNIQUE INDEX sales_uid_gix ON sales(sales_id) GLOBAL;

-- 파티션 조작 후 상태 확인
SELECT index_name, status FROM user_indexes WHERE table_name='SALES';
ALTER INDEX sales_uid_gix REBUILD ONLINE; -- 필요 시
```

---

## 8) 성능: Partition Pruning / Partition-Wise Join

### Pruning 패턴

- RANGE: `WHERE sales_dt BETWEEN :a AND :b` → **구간 파티션만**
- LIST:  `WHERE region_cd IN ('KR','US')` → **해당 LIST 파티션만**
- HASH:  `WHERE cust_id IN (101,202)` → **해당 해시 파티션만**
- **함수 가공/묵시적 형변환**은 프루닝을 막을 수 있음 → **FBI/가상컬럼** 고려

### Partition-Wise Join

- **Full P-Wise**: 두 테이블이 **동일 파티션 방식/경계/개수** + 조인키가 동일 → 파티션별 조인
- **Partial P-Wise**: 한쪽만 파티셔닝돼도 조인 순서/방식에 따라 **부분적** 혜택

```sql
-- 예: sales_rh(월×cust_id해시) 와 customer_dim(같은 cust_id해시 8-way)
-- → cust_id로 Full Partition-Wise Join 가능 (경계/개수 동일 조건 충족 가정)
SELECT /*+ USE_HASH(s c) FULL(s) FULL(c) */ SUM(s.amount)
FROM   sales_rh s
JOIN   customer_dim c
ON     s.cust_id = c.cust_id
WHERE  s.sales_dt >= DATE '2025-02-01' AND s.sales_dt < DATE '2025-03-01';
```

---

## 9) 모델링/설계 체크리스트

1. **파티션 키 선정**
   - 가장 자주 쓰는 **필터 조건**과 **데이터 수명 정책**에 맞춰(대부분 날짜)
   - 조인키와 **정합**되면 P-Wise Join의 이점
2. **파티션 개수/경계**
   - 너무 적으면 관리/성능 이점 미미, 너무 많으면 딕셔너리/플랜 비용↑
   - 월/주 등 **운영 주기**에 맞게
3. **Local Index 우선**
   - 유지보수 단순화. 글로벌 인덱스는 예외적
4. **DML 패턴/스큐**
   - 특정 파티션만 **핫스팟**이 되는지 확인(예: 최근 월) → **서브파티션(HASH)** 고려
5. **교체/적재 전략**
   - EXCHANGE PARTITION 로드, READ ONLY/COMPRESS, TRUNCATE 주기
6. **통계/옵티마이저**
   - `DBMS_STATS` 파티션/서브파티션 통계 + 글로벌 통계 **균형 수집**
   - 새 파티션 생성 시 **자동 통계** 또는 배치 수집 플로우

---

## 10) 실전 미션: 로그 데이터 운영 예시(End-to-End)

### 요구

- 하루 1억 건 로그, **일별 RANGE**. 최근 7일은 **DML 많음(압축X)**, 그 외 90일은 **압축+READ ONLY**, 90일 초과는 삭제.
- 분석은 주로 **최근 30일** 범위 + 일부 고객 해시 병렬.

### 설계

- **RANGE-HASH**: `log_dt`(일) × `cust_id`(8-way)
- 인덱스는 **LOCAL** 중심, 글로벌 최소화

```sql
CREATE TABLE web_log (
  log_id   NUMBER       NOT NULL,
  log_dt   DATE         NOT NULL,
  cust_id  NUMBER       NOT NULL,
  uri      VARCHAR2(2000),
  status   NUMBER(3),
  bytes    NUMBER
)
PARTITION BY RANGE (log_dt)
SUBPARTITION BY HASH (cust_id) SUBPARTITIONS 8
(
  PARTITION p2025d10 VALUES LESS THAN (DATE '2025-11-11') TABLESPACE ts_hot,
  PARTITION p2025d11 VALUES LESS THAN (DATE '2025-11-12') TABLESPACE ts_hot,
  PARTITION p2025d12 VALUES LESS THAN (DATE '2025-11-13') TABLESPACE ts_hot,
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)            TABLESPACE ts_cold
);

CREATE INDEX web_log_status_lix ON web_log(status) LOCAL;

-- 일일 배치(요지)
BEGIN
  -- 1) 내일 파티션 추가
  EXECUTE IMMEDIATE q'[ALTER TABLE web_log ADD PARTITION p2025d13 VALUES LESS THAN (DATE '2025-11-14') TABLESPACE ts_hot]';

  -- 2) 7일 지난 파티션을 압축+읽기전용 이동
  EXECUTE IMMEDIATE q'[ALTER TABLE web_log MOVE PARTITION p2025d10 TABLESPACE ts_cold COMPRESS FOR OLTP]';
  EXECUTE IMMEDIATE q'[ALTER TABLE web_log MODIFY PARTITION p2025d10 READ ONLY]';

  -- 3) 90일 지난 파티션 삭제
  EXECUTE IMMEDIATE q'[ALTER TABLE web_log TRUNCATE PARTITION p2025d10 UPDATE GLOBAL INDEXES]'; -- 예시: 실제는 롤링 기준
END;
/
```

쿼리 예:
```sql
-- 최근 7일 상태별 트래픽 (날짜 프루닝+서브파티션 분산)
SELECT status, SUM(bytes)
FROM   web_log
WHERE  log_dt >= SYSDATE - 7
GROUP  BY status;

-- 특정 고객 Top-URI (해시 프루닝)
SELECT uri, COUNT(*) cnt
FROM   web_log
WHERE  cust_id = :b1
AND    log_dt >= SYSDATE - 30
GROUP  BY uri
ORDER  BY cnt DESC
FETCH FIRST 20 ROWS ONLY;
```

---

## 11) 문제해결(트러블슈팅) 포인트

- **프루닝이 안 된다**
  - 함수 가공/형변환 여부 확인 → **가상컬럼/FBI**로 프루닝 유도
  - `EXPLAIN PLAN +PARTITION` 으로 PSTART/PSTOP 확인
- **글로벌 인덱스 INVALID**
  - 파티션 작업 후 `UPDATE GLOBAL INDEXES` 옵션 또는 **REBUILD**
- **스큐/핫 파티션**
  - **서브파티션 HASH** 추가, 또는 파티션 설계 조정
- **통계 불균형**
  - 파티션 통계 + 테이블 글로벌 통계를 **함께** 관리(스케줄로 고정)
- **DML/DDL 경합**
  - 파티션 단위 작업은 **락 범위가 작아** 경합 완화, 그래도 **핫 파티션**엔 주의

---

## 12) 요약

- **RANGE**: 시간/숫자 **연속** → 기간 관리+Pruning 최강
- **HASH**: **균등 분산**이 핵심, 등치 조건 프루닝
- **LIST**: **범주형** 값에 직관적, 특정 그룹 관리/삭제 쉬움
- **결합(Composite)**: 현실은 복합적 → RANGE-HASH / RANGE-LIST가 실전 최다
- **Local Index 우선**, 운영은 **EXCHANGE/TRUNCATE/MOVE/COMPRESS/READ ONLY**로 설계
- **Pruning/Partition-Wise Join**을 플랜에서 확인하며, 통계/경계/개수를 지속 보정

---

### 추가 점검 SQL 모음

```sql
-- 1) 파티션 메타 살펴보기
SELECT partition_name, high_value, compression, tablespace_name, interval
FROM   user_tab_partitions
WHERE  table_name='SALES';

SELECT subpartition_name, high_value, tablespace_name
FROM   user_tab_subpartitions
WHERE  table_name='SALES_RH';

-- 2) 인덱스 상태
SELECT index_name, status, partitioned, locality
FROM   user_indexes
WHERE  table_name IN ('SALES','SALES_RH');

-- 3) 파티션별 행수/블록수(대략)
SELECT partition_name, num_rows, blocks
FROM   user_tab_statistics
WHERE  table_name='SALES';

-- 4) 실제 실행계획에 파티션 프루닝이 적용되는지
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'BASIC +OUTLINE +ALIAS +PARTITION'));
```

> 이 문서의 코드를 **그대로** 따라 하면, 각 파티셔닝 방식의 **프루닝/관리/조인 효과**를 **눈으로** 확인할 수 있습니다. “데이터가 크면 클수록” 파티셔닝의 가치가 커지고, **Local Index + 결합 파티션**은 실전에서 **안정성과 성능**을 동시에 확보하는 정석 조합입니다.
