---
layout: post
title: DB 심화 - 테이블 파티셔닝
date: 2025-11-24 17:25:23 +0900
category: DB 심화
---
# 오라클 테이블 파티셔닝: 성능과 운영의 핵심 기술

파티셔닝은 대용량 데이터베이스 환경에서 성능, 가용성, 유지보수성을 동시에 향상시키는 핵심 기술입니다. 이 문서에서는 오라클 데이터베이스의 테이블 파티셔닝에 대한 심층적인 이해와 실전 적용 방법을 다룹니다.

## 파티셔닝의 핵심 가치

파티셔닝을 도입하는 주요 이유는 성능 최적화, 운영 효율성, 시스템 확장성이라는 세 가지 축에서 설명할 수 있습니다.

### 성능 최적화 관점

파티셔닝은 옵티마이저의 탐색 공간을 줄이고 비용 모델을 현실화합니다:

- **파티션 프루닝**: WHERE 조건에 의해 불필요한 파티션을 스캔 대상에서 제외하여 I/O를 줄입니다.
- **파티션-와이즈 조인**: 동일한 파티션 키를 가진 테이블 간의 조인 성능을 극대화합니다.
- **통계 관리**: 파티션별 통계를 통해 카디널리티 추정의 정확성을 높입니다.

### 운영 효율성 관점

파티셔닝은 데이터 라이프사이클 관리와 유지보수 작업을 단순화합니다:

- **데이터 라이프사이클 관리**: 파티션 단위로 데이터 보관 정책을 쉽게 적용할 수 있습니다.
- **파티션 단위 작업**: 인덱스 재구성, 통계 수집, 압축 등을 파티션 단위로 수행할 수 있습니다.
- **대용량 작업 최적화**: EXCHANGE PARTITION을 통해 대량 적재를 메타데이터 수준에서 처리할 수 있습니다.

### 시스템 확장성 관점

파티셔닝은 시스템의 확장성과 가용성을 향상시킵니다:

- **IO 분산**: 서로 다른 파티션을 다른 디스크에 저장하여 IO 병목을 완화합니다.
- **동시성 향상**: 다른 파티션에 대한 작업은 서로 블로킹되지 않습니다.
- **병렬 처리**: 파티션을 자연스러운 병렬 처리 단위로 활용할 수 있습니다.

## 파티셔닝의 기본 구조

### 파티션 테이블의 내부 구조

파티션 테이블은 논리적으로 하나의 테이블이지만, 물리적으로는 각 파티션마다 별도의 세그먼트를 가집니다:

```sql
-- 파티션 테이블 여부 확인
SELECT table_name, partitioned
FROM user_tables
WHERE table_name = 'SALES';
```

### 파티션 키 선택 원칙

효과적인 파티셔닝을 위해서는 적절한 파티션 키를 선택하는 것이 중요합니다:

1. **가장 빈번하게 사용되는 필터 조건**에 포함되는 컬럼
2. **데이터 수명주기 관리**에 적합한 컬럼 (예: 날짜)
3. **조인 최적화**를 위한 컬럼
4. **데이터 분포**가 균등한 컬럼

## 파티션 프루닝의 심층 분석

파티션 프루닝은 파티셔닝의 가장 중요한 성능 이점 중 하나입니다. WHERE 조건에 따라 불필요한 파티션을 접근하지 않도록 합니다.

### 정적 프루닝

파싱 시점에 파티션 범위가 확정되는 경우입니다:

```sql
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM sales
WHERE sales_dt >= DATE '2025-10-01'
  AND sales_dt < DATE '2025-11-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, NULL, 'BASIC +PARTITION'));
```

### 동적 프루닝

바인드 변수를 사용하여 실행 시점에 파티션 범위가 결정되는 경우입니다:

```sql
VAR b1 DATE;
VAR b2 DATE;
EXEC :b1 := DATE '2025-10-01';
EXEC :b2 := DATE '2025-11-01';

EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM sales
WHERE sales_dt >= :b1
  AND sales_dt < :b2;
```

### 프루닝 방해 요인과 해결책

다음과 같은 패턴은 파티션 프루닝을 방해할 수 있습니다:

```sql
-- BAD: 함수가 파티션 키에 적용됨 (프루닝 불가)
WHERE TO_CHAR(sales_dt, 'YYYYMM') = '202510'

-- GOOD: 범위 조건으로 재작성 (프루닝 가능)
WHERE sales_dt >= DATE '2025-10-01'
  AND sales_dt < DATE '2025-11-01'
```

프루닝을 최대화하기 위한 전략:
1. 파티션 키 컬럼에 함수 적용을 피합니다.
2. 암시적 형변환을 방지합니다.
3. SARGable(Search ARGument ABLE) 조건을 사용합니다.

## 주요 파티셔닝 유형

### RANGE 파티셔닝

연속적인 값 범위를 기준으로 데이터를 분할합니다. 시간 기반 데이터에 가장 적합합니다:

```sql
-- 월별 RANGE 파티셔닝 예제
CREATE TABLE sales (
    sales_id   NUMBER        NOT NULL,
    sales_dt   DATE          NOT NULL,
    cust_id    NUMBER        NOT NULL,
    region_cd  VARCHAR2(6)   NOT NULL,
    amount     NUMBER(12,2)  NOT NULL,
    CONSTRAINT pk_sales PRIMARY KEY (sales_id, sales_dt)
)
PARTITION BY RANGE (sales_dt) (
    PARTITION p2025m09 VALUES LESS THAN (DATE '2025-10-01'),
    PARTITION p2025m10 VALUES LESS THAN (DATE '2025-11-01'),
    PARTITION p2025m11 VALUES LESS THAN (DATE '2025-12-01'),
    PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

-- 로컬 인덱스 생성
CREATE INDEX sales_cust_lix ON sales(cust_id) LOCAL;
```

### INTERVAL 파티셔닝

RANGE 파티셔닝의 자동화 버전으로, 새 데이터가 삽입될 때 파티션을 자동으로 생성합니다:

```sql
CREATE TABLE sales_int (
    sales_id NUMBER PRIMARY KEY,
    sales_dt DATE NOT NULL,
    amount   NUMBER(12,2)
)
PARTITION BY RANGE (sales_dt)
INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
(
    PARTITION p0 VALUES LESS THAN (DATE '2025-01-01')
);

-- 새 데이터 삽입 시 자동으로 파티션 생성
INSERT INTO sales_int VALUES(1, DATE '2025-11-12', 100);
COMMIT;
```

### HASH 파티셔닝

해시 함수를 적용하여 데이터를 균등하게 분산시킵니다. 핫스팟 완화와 병렬 처리에 유리합니다:

```sql
CREATE TABLE cust_tx (
    tx_id    NUMBER PRIMARY KEY,
    cust_id  NUMBER NOT NULL,
    tx_dt    DATE   NOT NULL,
    amount   NUMBER(12,2)
)
PARTITION BY HASH (cust_id)
PARTITIONS 16;
```

### LIST 파티셔닝

명시적인 값 목록을 기준으로 데이터를 분할합니다. 범주형 데이터 관리에 적합합니다:

```sql
CREATE TABLE region_acc (
    acc_id     NUMBER PRIMARY KEY,
    region_cd  VARCHAR2(6) NOT NULL,
    acc_dt     DATE NOT NULL,
    amount     NUMBER(12,2)
)
PARTITION BY LIST (region_cd) (
    PARTITION p_us VALUES ('US'),
    PARTITION p_eu VALUES ('DE', 'FR', 'UK', 'ES', 'IT', 'NL'),
    PARTITION p_etc VALUES (DEFAULT)
);
```

## 복합 파티셔닝

실제 환경에서는 단일 파티셔닝 방식으로는 충분하지 않은 경우가 많습니다. 복합 파티셔닝은 두 가지 이상의 파티셔닝 방식을 조합합니다.

### RANGE-HASH 복합 파티셔닝

가장 일반적인 복합 파티셔닝 패턴으로, 시간 기반 관리와 균등 분산을 동시에 달성합니다:

```sql
CREATE TABLE sales_rh (
    sales_id NUMBER NOT NULL,
    sales_dt DATE   NOT NULL,
    cust_id  NUMBER NOT NULL,
    amount   NUMBER(12,2),
    CONSTRAINT pk_sales_rh PRIMARY KEY(sales_id, sales_dt)
)
PARTITION BY RANGE (sales_dt)
SUBPARTITION BY HASH (cust_id)
SUBPARTITIONS 8
(
    PARTITION p2025m10 VALUES LESS THAN (DATE '2025-11-01'),
    PARTITION p2025m11 VALUES LESS THAN (DATE '2025-12-01'),
    PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

CREATE INDEX sales_rh_cust_lix ON sales_rh(cust_id) LOCAL;
```

### RANGE-LIST 복합 파티셔닝

시간 기반 관리와 범주형 분류를 함께 적용합니다:

```sql
CREATE TABLE sales_rl (
    sales_id  NUMBER PRIMARY KEY,
    sales_dt  DATE NOT NULL,
    region_cd VARCHAR2(6) NOT NULL,
    amount    NUMBER(12,2)
)
PARTITION BY RANGE (sales_dt)
SUBPARTITION BY LIST (region_cd)
SUBPARTITION TEMPLATE (
    SUBPARTITION sp_us VALUES ('US'),
    SUBPARTITION sp_eu VALUES ('DE', 'FR', 'UK', 'ES', 'IT', 'NL'),
    SUBPARTITION sp_etc VALUES (DEFAULT)
)
(
    PARTITION p2025m11 VALUES LESS THAN (DATE '2025-12-01'),
    PARTITION p2025m12 VALUES LESS THAN (DATE '2026-01-01')
);
```

## REFERENCE 파티셔닝

부모 테이블의 파티션 구성을 자식 테이블이 자동으로 상속받도록 합니다. 데이터 모델의 정규화를 유지하면서 파티셔닝 이점을 얻을 수 있습니다:

```sql
-- 부모 테이블 (월별 파티셔닝)
CREATE TABLE orders (
    order_id NUMBER PRIMARY KEY,
    order_dt DATE NOT NULL,
    cust_id  NUMBER NOT NULL,
    amount   NUMBER(12,2)
)
PARTITION BY RANGE (order_dt) (
    PARTITION p2025m11 VALUES LESS THAN (DATE '2025-12-01'),
    PARTITION p2025m12 VALUES LESS THAN (DATE '2026-01-01'),
    PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

-- 자식 테이블 (REFERENCE 파티셔닝)
CREATE TABLE order_items (
    order_id NUMBER NOT NULL,
    item_no  NUMBER NOT NULL,
    prod_id  NUMBER NOT NULL,
    qty      NUMBER NOT NULL,
    amount   NUMBER(12,2),
    CONSTRAINT pk_oi PRIMARY KEY(order_id, item_no),
    CONSTRAINT fk_oi_orders FOREIGN KEY(order_id)
        REFERENCES orders(order_id)
)
PARTITION BY REFERENCE (fk_oi_orders);
```

## 파티션-와이즈 조인

파티션-와이즈 조인은 파티셔닝의 가장 강력한 성능 이점 중 하나입니다. 동일한 파티션 키를 가진 테이블 간의 조인 성능을 극대화합니다.

### 완전 파티션-와이즈 조인

두 테이블이 동일한 파티션 방식, 키, 경계, 개수를 가질 때 발생합니다:

```sql
-- 동일한 파티션 구조를 가진 테이블 간 조인
SELECT /*+ USE_HASH(s c) FULL(s) FULL(c) */
       SUM(s.amount)
FROM sales_rh s
JOIN customer_dim c
  ON s.cust_id = c.cust_id
WHERE s.sales_dt >= DATE '2025-11-01'
  AND s.sales_dt < DATE '2025-12-01';
```

### 부분 파티션-와이즈 조인

한쪽 테이블만 파티셔닝되었거나 파티션 경계가 부분적으로 일치할 때 발생합니다.

## 파티션 인덱스 설계

### 로컬 인덱스 vs 글로벌 인덱스

로컬 인덱스는 각 파티션과 1:1로 매핑되며, 파티션 관리 작업 시 자동으로 유지됩니다. 일반적으로 로컬 인덱스를 우선적으로 고려해야 합니다:

```sql
-- 로컬 인덱스 생성
CREATE INDEX sales_amt_lix ON sales(amount) LOCAL;
```

글로벌 인덱스는 테이블 전체를 대상으로 하며, 파티션 관리 작업 후 재구성이 필요할 수 있습니다:

```sql
-- 글로벌 인덱스 생성 (필요한 경우에만)
CREATE UNIQUE INDEX sales_uid_gix ON sales(sales_id) GLOBAL;
```

### 인덱스 선택 기준

1. **로컬 인덱스 우선**: 파티션 관리 작업의 자동화와 성능을 위해 로컬 인덱스를 기본으로 사용합니다.
2. **글로벌 인덱스 제한적 사용**: 파티션 키와 무관한 전역 유일성이 필요하거나, 시간 범위 밖의 단건 조회가 빈번한 경우에만 사용합니다.

## 파티션 통계 관리

파티션 테이블의 통계 관리는 전체 테이블 통계와 파티션별 통계를 효율적으로 유지해야 합니다.

### 증분 통계 수집

대용량 파티션 테이블에서는 증분 통계 수집이 필수적입니다:

```sql
-- 증분 통계 활성화
BEGIN
    DBMS_STATS.SET_TABLE_PREFS(
        USER, 
        'SALES', 
        'INCREMENTAL', 
        'TRUE'
    );
    
    -- 통계 수집
    DBMS_STATS.GATHER_TABLE_STATS(
        ownname    => USER,
        tabname    => 'SALES',
        granularity=> 'AUTO',
        cascade    => TRUE,
        method_opt => 'FOR ALL COLUMNS SIZE SKEWONLY'
    );
END;
/
```

증분 통계를 사용하면 새 파티션만 통계를 수집하고, 전체 테이블 통계는 시놉시스(synopsis)를 통해 효율적으로 유지됩니다.

## 파티션 운영 패턴

### EXCHANGE PARTITION을 이용한 대량 적재

EXCHANGE PARTITION은 대량 데이터 적재 시 가장 효율적인 방법입니다:

```sql
-- 스테이징 테이블 생성
CREATE TABLE sales_stage AS 
SELECT * FROM sales WHERE 1=0;

-- 스테이징 테이블에 대량 적재 후
ALTER TABLE sales
EXCHANGE PARTITION p2025m11
WITH TABLE sales_stage
INCLUDING INDEXES WITHOUT VALIDATION;
```

### 슬라이딩 윈도우 운영

시간 기반 파티셔닝에서 가장 일반적인 운영 패턴입니다:

```sql
-- 다음 달 파티션 추가
ALTER TABLE sales ADD PARTITION p2026m01
VALUES LESS THAN (DATE '2026-02-01');

-- 오래된 파티션 정리
ALTER TABLE sales TRUNCATE PARTITION p2025m09 
UPDATE GLOBAL INDEXES;
```

### Heat Map과 ADO를 활용한 자동 데이터 최적화

Heat Map은 데이터 접근 패턴을 추적하고, ADO(Automatic Data Optimization)는 이를 기반으로 자동 정책을 실행합니다:

```sql
-- 30일 동안 접근되지 않은 파티션을 OLTP 압축으로 전환
ALTER TABLE sales ILM ADD POLICY
    COMPRESS FOR OLTP
    AFTER 30 DAYS OF NO ACCESS;
```

## 실전 설계 예제: 대용량 웹 로그 시스템

### 요구사항
- 일일 1억 건의 클릭스트림 데이터 처리
- 최근 7일 데이터는 핫 데이터(압축 없음)
- 7일 이후 90일 데이터는 콜드 데이터(압축 + 읽기 전용)
- 90일 초과 데이터는 삭제
- 최근 30일 데이터와 특정 고객 데이터에 대한 분석 쿼리 최적화

### 설계안

```sql
-- RANGE(일별) + HASH(고객ID) 복합 파티셔닝
CREATE TABLE web_log (
    log_id    NUMBER NOT NULL,
    log_dt    DATE   NOT NULL,
    cust_id   NUMBER NOT NULL,
    region_cd VARCHAR2(6) NOT NULL,
    uri       VARCHAR2(2000),
    status    NUMBER(3),
    bytes     NUMBER
)
PARTITION BY RANGE (log_dt)
SUBPARTITION BY HASH (cust_id) SUBPARTITIONS 8
(
    PARTITION p2025d11 VALUES LESS THAN (DATE '2025-11-12'),
    PARTITION p2025d12 VALUES LESS THAN (DATE '2025-11-13'),
    PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

-- 로컬 인덱스 생성
CREATE INDEX web_log_status_lix ON web_log(status) LOCAL;
```

### 일일 운영 배치

```sql
BEGIN
    -- 내일 파티션 추가
    EXECUTE IMMEDIATE q'[
        ALTER TABLE web_log ADD PARTITION p2025d13
        VALUES LESS THAN (DATE '2025-11-14')
    ]';
    
    -- 7일 지난 파티션 압축 및 읽기 전용 전환
    EXECUTE IMMEDIATE q'[
        ALTER TABLE web_log MOVE PARTITION p2025d05 
        COMPRESS FOR OLTP
    ]';
    
    EXECUTE IMMEDIATE q'[
        ALTER TABLE web_log MODIFY PARTITION p2025d05 READ ONLY
    ]';
    
    -- 90일 지난 파티션 삭제
    EXECUTE IMMEDIATE q'[
        ALTER TABLE web_log TRUNCATE PARTITION p2025dxx 
        UPDATE GLOBAL INDEXES
    ]';
END;
/
```

### 분석 쿼리 예제

```sql
-- 최근 7일 상태별 트래픽 분석
SELECT status, SUM(bytes) as total_bytes
FROM web_log
WHERE log_dt >= SYSDATE - 7
GROUP BY status;

-- 특정 고객의 최근 30일 Top 20 URI
SELECT uri, COUNT(*) as access_count
FROM web_log
WHERE cust_id = :customer_id
  AND log_dt >= SYSDATE - 30
GROUP BY uri
ORDER BY access_count DESC
FETCH FIRST 20 ROWS ONLY;
```

## 문제 해결과 최적화

### 파티션 프루닝 실패 문제

프루닝이 실패하는 일반적인 원인과 해결책:

1. **파티션 키에 함수 적용**: 조건을 재작성하여 함수 적용을 피합니다.
2. **암시적 형변환**: 명시적 형변환을 사용합니다.
3. **통계 부실**: 정기적인 통계 수집을 수행합니다.
4. **바인드 변수 문제**: 동적 샘플링을 활용합니다.

### 핫 파티션 문제

특정 파티션에 작업이 집중되는 문제를 해결하기 위한 전략:

1. **서브파티셔닝 적용**: RANGE-HASH 복합 파티셔닝으로 부하 분산
2. **파티션 분할**: 핫 파티션을 더 작은 단위로 분할
3. **IO 분산**: 파티션을 다른 테이블스페이스에 분산 저장

### 글로벌 인덱스 관리

글로벌 인덱스의 유지보수 문제를 해결하기 위한 접근법:

1. **온라인 리빌드**: 사용자 영향을 최소화하면서 인덱스 재구성
2. **파티션 작업 시 업데이트**: `UPDATE GLOBAL INDEXES` 옵션 사용
3. **로컬 인덱스 우선**: 가능한 경우 로컬 인덱스 사용

## 결론

오라클 테이블 파티셔닝은 대용량 데이터베이스 환경에서 성능, 운영 효율성, 시스템 확장성을 동시에 달성하기 위한 핵심 기술입니다. 효과적인 파티셔닝 구현을 위해서는 다음과 같은 원칙을 준수해야 합니다:

### 설계 원칙

1. **비즈니스 요구사항 기반 설계**: 데이터 접근 패턴, 보관 정책, 성능 요구사항을 고려하여 파티셔닝 전략을 수립합니다.
2. **파티션 키의 신중한 선택**: 가장 빈번한 필터 조건, 데이터 수명주기 관리, 조인 최적화에 적합한 컬럼을 선택합니다.
3. **복합 파티셔닝의 적극적 활용**: RANGE-HASH와 같은 복합 파티셔닝으로 시간 기반 관리와 부하 분산을 동시에 달성합니다.

### 운영 원칙

1. **자동화 운영**: INTERVAL 파티셔닝과 슬라이딩 윈도우 패턴으로 운영 부담을 최소화합니다.
2. **통계 관리 최적화**: 증분 통계를 활용하여 대용량 파티션 테이블의 통계 관리 비용을 줄입니다.
3. **모니터링과 최적화**: 파티션 프루닝 효율성, 파티션-와이즈 조인 활용도, 파티션 단위 통계 품질을 정기적으로 점검합니다.

### 성능 원칙

1. **로컬 인덱스 우선**: 파티션 관리 작업의 자동화와 성능을 위해 로컬 인덱스를 기본으로 사용합니다.
2. **프루닝 최적화**: 파티션 키 컬럼에 함수 적용을 피하고 SARGable 조건을 사용하여 프루닝 효율성을 극대화합니다.
3. **파티션-와이즈 조인 활용**: 동일한 파티션 구조를 가진 테이블 간의 조인 성능을 최적화합니다.

파티셔닝은 단순한 기술 도입이 아니라 데이터 아키텍처의 근본적인 변화입니다. 성공적인 파티셔닝 구현을 위해서는 기술적 이해뿐만 아니라 비즈니스 요구사항과 운영 프로세스에 대한 종합적인 고려가 필요합니다. 본 문서에서 제시한 원리와 패턴을 바탕으로 조직의 데이터 특성에 맞는 최적의 파티셔닝 전략을 수립하고 구현하시기 바랍니다.