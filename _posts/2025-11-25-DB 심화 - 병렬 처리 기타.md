---
layout: post
title: DB 심화 - 병렬 처리 기타
date: 2025-11-25 16:25:23 +0900
category: DB 심화
---
# Oracle 병렬 처리

## 0. 병렬 실행(PQ)의 “그림 한 장” 리마인드

병렬 실행은 한 SQL을 여러 PX 서버(슬레이브)가 **나눠 읽고(Scan)**, **나눠 처리하고(Join/Agg/Sort)**, **QC가 합쳐 반환**하는 구조입니다. Oracle은 이 과정을 **DFO(Data Flow Operation)** 와 **TQ(Table Queue)** 라는 내부 파이프라인으로 모델링합니다. :contentReference[oaicite:0]{index=0}

### 0.1 QC–PX–TQ 흐름

```
          QC( Query Coordinator )
                 |
         -----------------
         |               |
     PX Set 1         PX Set 2
  (Producer)        (Consumer)
   Scan/Agg           Join/DML
         |               |
     [ TQ1 ]  ---->   [ TQ2 ]
    (HASH/BROADCAST/ROUND)
```

- **Producer**: 데이터를 읽어서(TS/Index Scan) TQ로 밀어 넣음  
- **Consumer**: TQ에서 데이터를 받아 Join/Agg/DML 수행  
- **TQ 분배 방식**(실행계획 PX SEND 라인에서 확인):
  - `HASH` : 조인 키 해시로 재분배  
  - `BROADCAST` : 작은 쪽을 모든 슬레이브로 복제  
  - `PARTITION` : 파티션 단위로 나눠 전달(Partition-wise)  
  - `ROUND-ROBIN` : 순환 분배

**분배가 곧 비용**입니다. 조인이 병렬에서 빨라지려면  
“**스캔 비용** + **분배 비용** + **최종 머지 비용(QC)**” 의 합이 직렬보다 작아야 합니다.

### 0.2 병렬이 “이득”이 되는 전형적 조건

Oracle은 다음 중 하나가 있어야 병렬을 고려합니다. :contentReference[oaicite:1]{index=1}

- 쿼리에 `PARALLEL` 또는 `PARALLEL_INDEX` 힌트  
- 객체가 `PARALLEL` 속성  
- Auto DOP 활성  
- `FORCE PARALLEL QUERY`

그리고 실제 플랜에는 적어도 아래가 포함돼야 합니다.

- `TABLE ACCESS FULL`  
- **파티션을 넓게 타는 INDEX RANGE**  
- `INDEX FAST FULL SCAN`  
- 병렬 테이블 함수

즉 **“병렬이 될 만한 스캔/연산이 있는가”**가 출발점입니다.

---

## 1. `direct path read` — 버퍼 캐시 우회 대용량 읽기

### 1.1 Direct Path Read의 본질

`direct path read`는 **블록을 SGA 버퍼 캐시에 올리지 않고**  
**바로 PGA로 읽어오는** 읽기 방식입니다. 이때 세션은 `direct path read` 대기 이벤트를 보게 됩니다. :contentReference[oaicite:2]{index=2}

- **Buffered read**: 디스크 → SGA Buffer Cache → PGA  
- **Direct read**: 디스크 → PGA (캐시 우회)

Oracle 공식 튜닝 가이드는 direct read를  
“SGA를 거치지 않는 단일/멀티블록 직접 읽기”로 분류하고 있습니다. :contentReference[oaicite:3]{index=3}

### 1.2 언제 발생하나

Direct Path Read는 다음 상황에서 흔하게 관찰됩니다.

1. **병렬 Full Table Scan / 병렬 Index Fast Full Scan**  
   - PX 서버는 대용량 스트리밍 I/O를 선호하므로 direct read가 기본 패턴이 됩니다. :contentReference[oaicite:4]{index=4}  
2. **큰 테이블의 직렬 FTS(Adaptive Direct Path Read)**  
   - 11g 이후, 캐시에 넣을 가치가 없다고 판단되면 직렬 FTS도 direct read로 바뀔 수 있습니다. :contentReference[oaicite:5]{index=5}  
3. **대용량 Sort/Hash가 TEMP로 스필될 때**  
   - TEMP에서의 direct read/write는 `direct path read temp`, `direct path write temp`. :contentReference[oaicite:6]{index=6}  
4. **Exadata 등에서 Smart Scan 오프로딩이 실패한 direct read**  
   - Exadata 문서에서도 direct path read는 병렬 direct read에서 핵심 이벤트로 분류됩니다. :contentReference[oaicite:7]{index=7}  

### 1.3 왜 빠른가 / 왜 느릴 수 있는가

**빠른 이유**

- 버퍼 캐시 LRU와 래치를 건드리지 않아 **캐시 오염을 막고** CPU/래치 비용을 줄입니다. :contentReference[oaicite:8]{index=8}  
- 병렬/대용량 스캔은 OS의 비동기 I/O, 대형 I/O를 타기 좋아 **순차 대역폭을 최대로 씁니다.** :contentReference[oaicite:9]{index=9}  

**느려질 수 있는 이유**

- 같은 세그먼트에 dirty 버퍼가 많으면, direct scan 직전에  
  “디스크에 내려야 하는” 동기화가 생겨 추가 대기가 끼어들 수 있습니다(대규모 업데이트 직후 FTS 등). :contentReference[oaicite:10]{index=10}  
- 반복 참조되는 **소테이블**까지 direct read로 우회하면  
  캐시 히트 이점을 잃고 오히려 응답이 악화될 수 있습니다. :contentReference[oaicite:11]{index=11}  

### 1.4 대용량 실습 데이터 생성(권장)

현 스키마는 소량이므로, DPR/병렬 효과를 보려면 데이터가 커야 합니다.

```sql
-- 1) sales를 1천만 로우 정도로 확장
INSERT /*+ APPEND PARALLEL(s 8) */ INTO sales s
SELECT level + 10000000      AS sales_id,
       MOD(level, 500000)    AS cust_id,
       DATE '2024-01-01' + MOD(level, 365) AS sales_dt,
       CASE MOD(level,5)
         WHEN 0 THEN 'US' WHEN 1 THEN 'EU' WHEN 2 THEN 'KR'
         WHEN 3 THEN 'APAC' ELSE 'LATAM' END AS region_cd,
       DBMS_RANDOM.VALUE(1,1000) AS amount
FROM dual
CONNECT BY level <= 10000000;

COMMIT;
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES', method_opt=>'for all columns size skewonly');
END;
/
```

- `APPEND` + `PARALLEL`로 **Direct-Path 로드**를 먼저 체감하고,  
- 이후 FTS에서 `direct path read`가 선명하게 관찰됩니다.

### 1.5 DPR 유도 실험

```sql
EXPLAIN PLAN FOR
SELECT /*+ FULL(s) PARALLEL(s 8) MONITOR */
       COUNT(*)
FROM   sales s
WHERE  sales_dt >= DATE '2025-01-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +ALIAS +NOTE'));
```

**플랜 기대 포인트**

- `PX COORDINATOR`
- `PX SEND QC (RANDOM)` 또는 `PX SEND QC (ORDER)`
- `PX BLOCK ITERATOR`
- `TABLE ACCESS FULL SALES`

**대기 이벤트 기대 포인트**

- `direct path read`의 비중이 가장 큼. :contentReference[oaicite:12]{index=12}  
- TEMP 스필 시 `direct path read temp`/`write temp`.

### 1.6 진단 루틴

```sql
-- direct read 규모(세션 통계)
SELECT n.name, s.value
FROM   v$mystat s JOIN v$statname n ON s.statistic# = n.statistic#
WHERE  n.name IN ('physical reads direct', 'physical reads');

-- 이벤트
SELECT event, total_waits, time_waited
FROM   v$session_event
WHERE  sid = SYS_CONTEXT('USERENV','SID')
AND    event LIKE 'direct path%';
```

- `physical reads direct`가 쿼리의 물리 읽기 대부분을 차지하면  
  DPR이 확실합니다. :contentReference[oaicite:13]{index=13}  

### 1.7 튜닝 체크리스트

1. **DOP 과대 금지**  
   - 스토리지 대역폭/CPU 대비 DOP를 올리면  
     슬레이브끼리 **디스크를 경쟁**해서 `direct path read` 대기만 늘고 느려집니다. :contentReference[oaicite:14]{index=14}  
2. **MBRC(멀티블록 읽기 크기)/스토리지 스트라이핑**  
   - DPR은 “큰 덩어리 연속 읽기”가 전제입니다. MBRC/스트라이프가 작으면 효과가 줄어듭니다. :contentReference[oaicite:15]{index=15}  
3. **캐시에 남겨야 하는 테이블인지 판단**  
   - 반복 참조 소테이블은 DPR 강제보다 캐시 경로가 낫습니다. :contentReference[oaicite:16]{index=16}  
4. **PGA/TEMP 밸런스**  
   - 병렬 정렬/해시가 TEMP로 흘러가면 direct path read temp가 늘면서 I/O 병목. :contentReference[oaicite:17]{index=17}  

---

## 2. 병렬 DML(Parallel DML, PDML)

### 2.1 PDML의 구조

PDML은 내부적으로 **Producer(SELECT) → Consumer(DML)** 의  
**2-단계 파이프라인**입니다.

```
PX Producer: 소스 집합 병렬 스캔/변환
     |
   [TQ]
     |
PX Consumer: 타깃 세그먼트에 병렬 INSERT/UPDATE/DELETE/MERGE
```

Oracle 병렬 실행 가이드에서도 DML이 병렬 서버에 의해 분할되어 수행됨을 명시합니다. :contentReference[oaicite:18]{index=18}  

### 2.2 PDML을 켜는 “3가지 조건”

1. 세션:  
```sql
ALTER SESSION ENABLE PARALLEL DML;
```

2. 타깃 오브젝트가 `PARALLEL` 속성이거나 힌트로 DOP를 줌  
3. 실행계획 NOTE에 “Parallel DML”이 실제로 활성화되어야 함  
   - 트리거/제약/인덱스 구조에 따라 **Serial 강등**될 수 있습니다. :contentReference[oaicite:19]{index=19}  

### 2.3 PDML INSERT = Direct-Path Insert

병렬 INSERT는 사실상 **direct-path load**로 동작합니다.  
Ask TOM과 Oracle 문서 모두  
`APPEND` 또는 `PARALLEL`을 사용한 INSERT AS SELECT가 direct-path임을 확인합니다. :contentReference[oaicite:20]{index=20}  

```sql
EXPLAIN PLAN FOR
INSERT /*+ APPEND PARALLEL(s 8) MONITOR */
INTO sales s
SELECT /*+ PARALLEL(o 8) */
       o.order_id + 20000000,
       o.cust_id,
       o.order_dt,
       'US',
       o.amt
FROM   orders o
WHERE  o.order_dt >= DATE '2025-02-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +NOTE'));
```

**Direct-Path Insert의 특징**

- HWM 위 **새 익스텐트에 블록을 직접 생성**하며 적재  
- 세그먼트에 **배타적 성격의 로드 락**이 필요  
- 대량 적재에서 스트리밍 I/O가 가능해짐 :contentReference[oaicite:21]{index=21}  

### 2.4 ORA-12838 (PDML/Direct-Path 후 동일 트랜잭션 접근 금지)

Oracle 공식 문서는 direct-path INSERT 직후  
**같은 트랜잭션에서 그 테이블을 읽거나 수정할 수 없고, COMMIT이 필요**하다고 명시합니다. :contentReference[oaicite:22]{index=22}  

```sql
INSERT /*+ APPEND PARALLEL(s 8) */ INTO sales
SELECT /*+ PARALLEL(o 8) */ ... FROM orders o;

-- 아래를 같은 트랜잭션에서 하면 ORA-12838 가능
SELECT COUNT(*) FROM sales;

COMMIT;  -- 해결
```

- 이 제약은 23c에서도 기본적으로 유지되며, direct-path 로드의 일관성 보장을 위한 설계입니다. :contentReference[oaicite:23]{index=23}  

### 2.5 PDML UPDATE/DELETE/MERGE의 실전 포인트

```sql
-- PDML UPDATE
EXPLAIN PLAN FOR
UPDATE /*+ PARALLEL(s 8) MONITOR */
  sales s
SET s.amount = s.amount * 1.05
WHERE EXISTS (
  SELECT /*+ PARALLEL(o 8) */ 1
  FROM   orders o
  WHERE  o.cust_id = s.cust_id
);

-- PDML DELETE
EXPLAIN PLAN FOR
DELETE /*+ PARALLEL(s 8) MONITOR */
FROM   sales s
WHERE  s.sales_dt < ADD_MONTHS(TRUNC(SYSDATE,'MM'), -24);
```

**핵심 이슈**

1. **인덱스 유지 비용**  
   - UPDATE/DELETE는 **모든 관련 인덱스**를 병렬로 유지해야 해  
     인덱스가 많으면 PDML 이점이 급감합니다.  
2. **로킹/경합(특히 Direct-Path Insert)**  
   - direct-path는 구조상 **배타적 로드를 요구**하므로  
     동시 적재 세션들이 경합할 수 있습니다. :contentReference[oaicite:24]{index=24}  
3. **UNDO/REDO/아카이브 압박**  
   - 대량 변경은 로그량이 병렬로 폭증할 수 있으니  
     로그 파일/아카이브 처리량을 포함해 DOP를 정해야 합니다.  
4. **RAC**  
   - 여러 노드에서 같은 세그먼트를 PDML하면 블록 경합이 커집니다.  
     파티션 단위로 작업 범위를 나눠 노드 Affinity를 주는 것이 일반적인 해법입니다.

### 2.6 PDML 체크리스트

- 세션에서 `ENABLE PARALLEL DML` 했는가  
- 타깃이 힙/ASSM/자동할당 TS 등 **direct-path가 허용되는 구조**인가  
- 실행계획 NOTE에 **“Parallel DML”로 표시**되는가  
- 적재 직후 같은 트랜잭션 접근을 피했는가(ORA-12838) :contentReference[oaicite:25]{index=25}  
- 인덱스/트리거/제약으로 Serial 강등되지 않는가 :contentReference[oaicite:26]{index=26}  

---

## 3. 병렬 인덱스 스캔

### 3.1 병렬 친화도: IFFS > Full Scan > Range Scan

Oracle은 병렬 인덱스 경로로 **Index Fast Full Scan(IFFS)** 를 가장 선호합니다.  
공식 Parallelism 규칙에도 IFFS가 **병렬화 가능한 스캔 타입**으로 들어 있습니다. :contentReference[oaicite:27]{index=27}  

- **Index Fast Full Scan**  
  - 인덱스를 “**얇은 테이블**”처럼 전체 멀티블록으로 읽음  
  - **정렬 순서 보장 없음**  
  - DPR과 궁합이 매우 좋고 병렬화가 쉽습니다. :contentReference[oaicite:28]{index=28}  

- **Index Full Scan**  
  - 루트→리프 순서를 유지하므로 전역 순서가 필요한 경우  
  - 순서 보존 때문에 병렬성은 상대적으로 제한적  

- **Index Range Scan**  
  - 범위가 **파티션/그라뉼 단위로 쪼개질 수 있을 때만** 병렬 효과  
  - 보통 **로컬 파티션 인덱스**에서 가장 자연스럽게 병렬화됩니다.

### 3.2 IFFS 병렬 실습

```sql
EXPLAIN PLAN FOR
SELECT /*+ INDEX_FFS(s ix_sales_cust)
           PARALLEL_INDEX(s 8)
           MONITOR */
       COUNT(*)
FROM   sales s
WHERE  cust_id BETWEEN 1 AND 999999999;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +ALIAS +NOTE'));
```

**기대 플랜**

- `PX BLOCK ITERATOR`
- `INDEX FAST FULL SCAN IX_SALES_CUST`
- `PX SEND QC`

**기대 대기**

- `direct path read`가 주 대기(인덱스도 direct read가 가능). :contentReference[oaicite:29]{index=29}  

### 3.3 “힌트가 먹히는데 왜 FTS로 가지?”의 이유

Jonathan Lewis는 `PARALLEL_INDEX` 힌트가  
**테이블 측 parallel 비용 스케일링과 결합되지 않으면**  
IFFS의 병렬 비용을 제대로 낮추지 못해  
CBO가 FTS를 택하는 사례를 설명합니다. :contentReference[oaicite:30]{index=30}  

즉, **인덱스만 병렬 힌트**를 주면:

- IFFS **병렬 비용이 할인되지 않음**  
- 결과적으로 “직렬 FTS가 더 싸다”로 계산될 수 있음

그래서 실전에서는 **테이블과 인덱스에 같은 DOP를 함께 힌트**하는 게 안전합니다.

```sql
SELECT /*+ PARALLEL(s 8)
           PARALLEL_INDEX(s ix_sales_cust 8)
           INDEX_FFS(s ix_sales_cust) */
       COUNT(*)
FROM   sales s
WHERE  cust_id >= 0;
```

### 3.4 Range Scan 병렬이 잘 되는 조건

1. **로컬 파티션 인덱스**  
   - 파티션 단위로 PX가 나뉨 → Partition-wise Index Range Scan  
2. **범위가 블록 그라뉼로 분할될 만큼 넓고 균등**  
3. 인덱스 후 `TABLE ACCESS BY ROWID`가 **폭발하지 않을 것**  
   - ROWID 랜덤 I/O가 크면 병렬 이점보다 손해입니다.

### 3.5 병렬 인덱스 체크리스트

- 정렬이 필요 없는가 → IFFS 후보  
- 인덱스로 커버링되는가(테이블 랜덤 접근 제거)  
- 테이블/인덱스 parallel 비용 스케일링이 일치하는가 :contentReference[oaicite:31]{index=31}  
- IFFS 후 Rowid 랜덤 I/O가 과다하면 해시 조인/FTS 쪽이 낫다  

---

## 4. 병렬 Nested Loops 조인(PX NLJ)

### 4.1 병렬 NLJ의 내부 동작

PX NLJ는

1. **Outer(드라이빙) 집합을 PX에 분배**  
2. 각 PX가 **Inner를 인덱스로 반복 탐색**

구조입니다.

```
Outer rows  --PX DISTRIBUTE-->  PX slaves
                     each slave:
                       for outer_row:
                         index range scan on inner
                         table by rowid
```

즉 **“드라이빙 로우 수 × 인덱스 탐색 비용”**이 그대로 병렬로 복제됩니다.

### 4.2 언제 최고 성능이 나오나

Ask TOM은 “대규모 NL은 확장성이 떨어지고 비용이 폭발한다”는 점을 반복적으로 강조합니다. :contentReference[oaicite:32]{index=32}  

따라서 NLJ 병렬이 잘 맞는 패턴은 아래뿐입니다.

- Outer가 **극소수**(고선택성)  
- Inner에 **매우 잘 맞는 인덱스**  
- Outer를 `BROADCAST`해서 **재분배 통신을 없앰**

Pythian도 작은 쪽을 `BROADCAST NONE`으로 분배해  
각 PX가 독립적으로 큰 테이블을 탐색하는 패턴을 권장합니다. :contentReference[oaicite:33]{index=33}  

```sql
EXPLAIN PLAN FOR
SELECT /*+ LEADING(d) USE_NL(s)
           PARALLEL(d 8) PARALLEL(s 8)
           PQ_DISTRIBUTE(d BROADCAST NONE)
           MONITOR */
       s.sales_id, s.amount
FROM   dim_customer d
JOIN   sales       s ON s.cust_id = d.cust_id
WHERE  d.grade = 'GOLD';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +ALIAS +NOTE'));
```

**기대 대기**

- Outer가 작으므로 TQ 통신은 작고  
- Inner 탐색은 **`db file sequential read`** 중심(인덱스 단건 I/O).  
  `db file sequential read`는 전형적인 인덱스/ROWID 단일블록 읽기 이벤트입니다. :contentReference[oaicite:34]{index=34}  

### 4.3 언제 바로 망하나

Outer가 커지면

- PX 서버 수만큼 NL 탐색이 동시 폭증  
- Inner 인덱스/ROWID 랜덤 I/O가 **코어/디스크 모두를 막음**  
- `db file sequential read`가 과도해짐

```sql
-- 드라이빙(orders)이 큰 상황을 가정
EXPLAIN PLAN FOR
SELECT /*+ LEADING(o) USE_NL(s)
           PARALLEL(o 16) PARALLEL(s 16)
           MONITOR */
       o.order_id, s.sales_id
FROM   orders o
JOIN   sales  s ON s.cust_id = o.cust_id
WHERE  o.order_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12);
```

Ask TOM이 말하는 “**대규모 NL의 LIO 폭발**” 전형입니다. :contentReference[oaicite:35]{index=35}  

### 4.4 대안: 병렬 해시 조인 + HASH/HASH 분배

```sql
EXPLAIN PLAN FOR
SELECT /*+ LEADING(o) USE_HASH(s)
           PARALLEL(o 16) PARALLEL(s 16)
           PQ_DISTRIBUTE(o HASH HASH)
           PQ_DISTRIBUTE(s HASH HASH)
           MONITOR */
       o.order_id, s.sales_id
FROM   orders o
JOIN   sales  s ON s.cust_id = o.cust_id
WHERE  o.order_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12);
```

- 두 테이블이 큰 경우엔 HASH/HASH가 통상 가장 안정적입니다. :contentReference[oaicite:36]{index=36}  
- Bloom Filter/Partial Hash Join이 붙으면 더 좋아질 수 있습니다(플랜 NOTE 참고).

### 4.5 PX NLJ 체크리스트

- Outer가 정말 작나(카디널리티/실제 A-Rows)  
- Inner 인덱스 탐색이 **단건으로 끝나는가**  
- `db file sequential read`가 폭증하는가 :contentReference[oaicite:37]{index=37}  
- Outer를 브로드캐스트하면 통신이 줄어드는가 :contentReference[oaicite:38]{index=38}  
- 크면 해시 조인/Partition-wise Join으로 바꿀 수 있는가

---

## 5. 운영 관점: 실행계획/대기/스큐 관찰 루틴

### 5.1 실제 커서 플랜(통계 포함)

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
         'BASIC +PARALLEL +ALIAS +PREDICATE +NOTE'));
```

- `NOTE` 항목에서  
  - PDML 활성 여부  
  - 힌트가 무시되었는지(19c Hint Report)  
  - PX 분배 방식  
  을 바로 확인합니다.   

### 5.2 TQ 스큐(쏠림) 확인

```sql
SELECT dfo_number, tq_id, server_type, inst_id, process,
       num_rows, bytes
FROM   v$pq_tqstat
ORDER  BY dfo_number, tq_id, server_type, inst_id, process;
```

- 슬레이브별 `NUM_ROWS` 편차가 크면 스큐입니다.  
- 스큐가 심하면 **분배 큐 막힘(`PX Deq Credit: send blkd`)**가 늘어납니다.

### 5.3 이벤트로 원인 분류

| 이벤트 | 의미 | 흔한 원인 |
|---|---|---|
| `direct path read` | DPR / 병렬 FTS/IFFS | 대용량 스캔, 스토리지 병목 :contentReference[oaicite:40]{index=40} |
| `direct path read temp` | TEMP direct read | 해시/소트 스필, PGA 부족 :contentReference[oaicite:41]{index=41} |
| `db file sequential read` | 단일블록 인덱스/ROWID | NLJ, 랜덤 I/O 폭증 :contentReference[oaicite:42]{index=42} |
| `PX Deq Credit: send blkd` | TQ 전송 막힘 | 분배 스큐/인터커넥트 병목 |
| `gc %` | RAC 블록 전송 | 노드간 충돌/재분배 |

---

## 6. 상황별 튜닝 체크리스트(통합)

### 6.1 `direct path read`

- DPR은 **대용량 DSS/병렬 스캔에서 정상 신호** :contentReference[oaicite:43]{index=43}  
- I/O가 느리면 DOP를 줄여 **경쟁을 낮추기**  
- 반복 소테이블에는 DPR 강제 금지 :contentReference[oaicite:44]{index=44}  
- TEMP direct read가 많으면 PGA를 늘리거나 DOP를 조정

### 6.2 PDML

- `ENABLE PARALLEL DML` 없으면 PDML 안 됨  
- 병렬 INSERT는 direct-path이므로 **COMMIT 전 접근 금지(ORA-12838)** :contentReference[oaicite:45]{index=45}  
- 실행계획 NOTE에서 Serial 강등 여부 확인 :contentReference[oaicite:46]{index=46}  
- 다수 인덱스/트리거/RI로 비용이 커질 수 있음  
- 적재 경쟁이 있으면 direct-path 락 경합 고려 :contentReference[oaicite:47]{index=47}  

### 6.3 병렬 인덱스

- IFFS가 가능하면 IFFS가 1순위 :contentReference[oaicite:48]{index=48}  
- 인덱스 병렬 비용 스케일링은 **테이블 parallel 힌트와 연동**  
  → 둘을 함께 힌트하라 :contentReference[oaicite:49]{index=49}  
- 커버링 실패로 Rowid 랜덤 I/O가 늘면 해시/FTS 고려

### 6.4 병렬 NLJ

- Outer가 작을 때만(수천~수만 수준) 사용 :contentReference[oaicite:50]{index=50}  
- 작은 Outer는 `BROADCAST NONE`으로 복제해 통신 제거 :contentReference[oaicite:51]{index=51}  
- Outer가 커지면 `db file sequential read` 폭발 = 즉시 해시 조인 전환 :contentReference[oaicite:52]{index=52}  

---

## 7. 미니 시나리오(바로 복붙)

### 7.1 DPR 체감

```sql
SELECT /*+ FULL(s) PARALLEL(s 8) MONITOR */ COUNT(*) FROM sales s;
-- direct path read 비중이 커지고 physical reads direct도 증가
```

### 7.2 PDML 적재 + ORA-12838 회피

```sql
ALTER SESSION ENABLE PARALLEL DML;

INSERT /*+ APPEND PARALLEL(s 8) */ INTO sales
SELECT /*+ PARALLEL(o 8) */ o.order_id + 30000000, o.cust_id, o.order_dt, 'EU', o.amt
FROM orders o;

COMMIT;  -- 반드시
```

### 7.3 병렬 IFFS

```sql
SELECT /*+ PARALLEL(s 8)
           PARALLEL_INDEX(s ix_sales_cust 8)
           INDEX_FFS(s ix_sales_cust) MONITOR */
       COUNT(*)
FROM sales s
WHERE cust_id >= 0;
```

### 7.4 NLJ가 맞는 경우 vs 해시가 맞는 경우

```sql
-- NLJ: Outer(차원)가 매우 작다고 가정
SELECT /*+ LEADING(d) USE_NL(s)
           PQ_DISTRIBUTE(d BROADCAST NONE)
           PARALLEL(8) MONITOR */
       s.sales_id, s.amount
FROM dim_customer d JOIN sales s ON s.cust_id = d.cust_id
WHERE d.grade='GOLD';

-- Outer가 커지면 해시 조인으로
SELECT /*+ LEADING(o) USE_HASH(s)
           PQ_DISTRIBUTE(o HASH HASH)
           PQ_DISTRIBUTE(s HASH HASH)
           PARALLEL(16) MONITOR */
       COUNT(*)
FROM orders o JOIN sales s ON s.cust_id=o.cust_id
WHERE o.order_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'),-12);
```

---

## 8. 한 줄 요약

- **Direct Path Read**는 병렬/대용량 스캔의 기본 읽기이며, `direct path read` 이벤트가 정상 신호다.  
- **PDML**은 “SELECT→DML 두 단계 파이프라인”이고 병렬 INSERT는 direct-path라 **COMMIT 전 접근 금지(ORA-12838)**가 핵심이다.  
- **병렬 인덱스**는 **IFFS가 가장 잘 먹히며**, 테이블/인덱스 DOP 힌트를 **함께** 줘야 비용 스케일링이 제대로 된다.  
- **PX NLJ**는 드라이빙이 극소수일 때만, 그 외는 **병렬 해시 조인 + HASH/HASH 분배**가 안전하다.
