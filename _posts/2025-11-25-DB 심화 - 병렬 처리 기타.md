---
layout: post
title: DB 심화 - 병렬 처리 기타
date: 2025-11-25 16:25:23 +0900
category: DB 심화
---
# Oracle 병렬 처리 — 기타 상식 총정리

**주제**: `direct path read`, **병렬 DML(PDML)**, **병렬 인덱스 스캔**, **병렬 Nested Loops 조인**
**목표**: “언제, 왜, 어떻게” 병렬·Direct Path가 동작하는지 **실행계획/대기 이벤트/힌트** 중심으로 이해하고,
실습 가능한 **SQL 예제**와 **튜닝 체크리스트**까지 한 번에 정리합니다. (기준: 11g 이상)

---

## 0) 공통 랩 환경 만들기(한 번만 실행)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;          -- DBMS_XPLAN 실제 통계
ALTER SESSION SET parallel_degree_policy = MANUAL; -- 필요 시 AUTO로 전환
ALTER SESSION SET workarea_size_policy = AUTO;     -- 소트/해시 워크에어리어 자동
-- PDML 실습용
ALTER SESSION ENABLE PARALLEL DML;

-- [데이터셋] 사실 테이블(파티션 X), 인덱스/차원/주문 테이블
DROP TABLE sales PURGE;
CREATE TABLE sales (
  sales_id   NUMBER       PRIMARY KEY,
  cust_id    NUMBER       NOT NULL,
  sales_dt   DATE         NOT NULL,
  region_cd  VARCHAR2(6)  NOT NULL,
  amount     NUMBER(12,2) NOT NULL
);

DROP TABLE orders PURGE;
CREATE TABLE orders (
  order_id NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL,
  order_dt DATE   NOT NULL,
  amt      NUMBER(12,2)
);

DROP TABLE dim_customer PURGE;
CREATE TABLE dim_customer (
  cust_id      NUMBER PRIMARY KEY,
  region_group VARCHAR2(10),
  grade        VARCHAR2(10),
  active_yn    CHAR(1)
);

-- 인덱스
CREATE INDEX ix_sales_cust ON sales(cust_id);
CREATE INDEX ix_orders_cust ON orders(cust_id);

-- 샘플(축약. 실제 테스트는 대량 적재 권장)
INSERT INTO dim_customer VALUES (101,'APAC','GOLD','Y');
INSERT INTO dim_customer VALUES (202,'AMER','SILVER','Y');
INSERT INTO dim_customer VALUES (303,'EMEA','BRONZE','N');

INSERT INTO sales  VALUES (1,101, DATE '2025-02-10','KR',100);
INSERT INTO sales  VALUES (2,202, DATE '2025-02-11','US',170);
INSERT INTO sales  VALUES (3,202, DATE '2025-03-01','US',250);

INSERT INTO orders VALUES (10,101, DATE '2025-02-10', 300);
INSERT INTO orders VALUES (20,202, DATE '2025-02-11', 500);
INSERT INTO orders VALUES (30,202, DATE '2025-03-01', 700);

COMMIT;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES',  method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS', method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_CUSTOMER');
END;
/
```

> 팁: 대량 적재는 `INSERT /*+ APPEND PARALLEL */ SELECT …` 로 하고, Temp/PGA/UNDO/REDO 용량을 충분히 준비하세요.

---

# 1) `direct path read` — **버퍼 캐시 우회** 대용량 읽기

## 개념 & 언제 발생하나

- **Direct Path Read(DPR)**는 읽은 블록을 **버퍼 캐시(Shared Pool/Buffer Cache)** 를 거치지 않고 **세션 PGA**에 **직접** 올립니다.
- 주로 아래 연산에서 관찰:
  - **Full Table Scan / Full Index Scan**(특히 **Index Fast Full Scan**)
  - **병렬 쿼리(PQ)** 스캔
  - 대용량 소트/해시 중간 단계의 Temp 접근은 `direct path read/write temp` 이벤트로 관찰
- 장점: **캐시 오염 방지**, **대용량 순차 I/O 최적화**, OS/스토리지의 **대형 I/O**·비동기 I/O 활용
- 단점: 자주 재사용할 블록이라면 버퍼 캐시 활용이 유리(작은 OLTP 반복 액세스)

> 11g 이후엔 **시리얼 FTS**도 상황(테이블 크기, 캐시 압력 등)에 따라 DPR을 선택할 수 있습니다.

## 실습: 대용량 스캔에서 DPR 유도

```sql
-- 병렬+전체 스캔 → DPR 기대
EXPLAIN PLAN FOR
SELECT /*+ full(s) parallel(s 8) monitor */
       COUNT(*)
FROM   sales s
WHERE  sales_dt >= DATE '2025-02-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +ALIAS +NOTE'));

-- 실행 중 ASH/이벤트 확인(개념 예시)
-- select event, count(*) from v$active_session_history
-- where sample_time > sysdate - 1/288 and session_type='FOREGROUND'
-- group by event order by 2 desc;
```

### 기대 포인트

- 플랜: `PX BLOCK ITERATOR` / `TABLE ACCESS FULL`(혹은 PX) + `IN-OUT: P->S`(QC 반환)
- 대기: `direct path read`(또는 병렬이면 슬레이브에서 동일 이벤트), I/O 대기시간이 지배

## 튜닝 포인트

- **PQ 적정 DOP**, **스토리지 Stripe/MBRC**가 DPR 효과를 좌우
- 자주 쓰는 소테이블까지 DPR을 강제하면 **응답 악화** 가능 → **카디널리티/통계**로 옵티마이저가 올바른 경로 선택하도록
- 병렬 정렬/집계 동반 시 **PGA_AGGREGATE_TARGET** 확보(Temp 스필↓)

---

# 2) 병렬 DML(Parallel DML, PDML)

## 구조 & 동작

- PDML은 **Producer(SELECT)** 와 **Consumer(DML)** **두 단계 파이프라인**으로 동작:
  1) **PX Producer**: 소스 집합을 병렬 스캔/변환
  2) **PX Consumer**: 타깃 세그먼트에 병렬로 **INSERT/UPDATE/DELETE/MERGE**
- **요건**
  - 세션에서 **`ALTER SESSION ENABLE PARALLEL DML;`**
  - 타깃 오브젝트(테이블/인덱스)에 **PARALLEL 속성**(또는 힌트)
  - 제약/트리거/인덱스 상황에 따라 **PDML이 비활성(Serial로 강등)** 될 수 있음(실행계획 NOTE 확인)

## PDML INSERT (Direct-Path Insert)

```sql
-- 타깃을 새 익스텐트로 바로 적재 → REDO/UNDO 부담 상대적 감소, I/O 스트리밍
EXPLAIN PLAN FOR
INSERT /*+ APPEND PARALLEL(s 8) MONITOR */
INTO sales s
SELECT /*+ PARALLEL(o 8) */
       o.order_id, o.cust_id, o.order_dt, 'KR', o.amt
FROM   orders o
WHERE  o.order_dt >= DATE '2025-02-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +NOTE'));
```
- **APPEND**: **Direct-Path Insert** 강제(새 익스텐트에 바로 적재).
- **주의**: 같은 세션에서 **PDML 후 곧바로 읽기** 시 `ORA-12838`(PDML 후 읽기/수정 불가) → **COMMIT 필요**.

## PDML UPDATE/DELETE

```sql
-- UPDATE: 조인 기반 갱신 (Consumer가 타깃 블록에 병렬로 적용)
EXPLAIN PLAN FOR
UPDATE /*+ PARALLEL(s 8) MONITOR */
  sales s
SET s.amount = s.amount * 1.05
WHERE EXISTS (
  SELECT /*+ PARALLEL(o 8) */ 1
  FROM   orders o
  WHERE  o.cust_id = s.cust_id
    AND  o.order_dt >= DATE '2025-02-01'
);

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +NOTE'));

-- DELETE: 파티션/범위 프루닝 시 효과적
EXPLAIN PLAN FOR
DELETE /*+ PARALLEL(s 8) MONITOR */
FROM   sales s
WHERE  s.sales_dt < ADD_MONTHS(TRUNC(SYSDATE,'MM'), -24);
```

### PDML 실무 주의사항

- **인덱스 유지 비용**: UPDATE/DELETE는 **모든 관련 인덱스**를 병렬 유지 → 과도한 인덱스는 PDML 성능을 갉아먹음
- **트리거/제약**: 일부 상황에서 PDML을 **Serial로 강등** 가능 → 플랜 NOTE/`v$sql_plan` 주석 확인
- **UNDO/REDO**: 대량 변경이면 **REDO/UNDO** 압박(로그/아카이브/복구 시간 고려)
- **ORA-12838**: PDML 이후 같은 세션에서 **해당 오브젝트 읽기/수정 금지** → **커밋**
- **RAC**: PDML은 노드간 블록 충돌 가능 → **파티션 단위**로 **서비스/노드 Affinity** 설계 시 안정화

---

# 3) 병렬 인덱스 스캔

## 어떤 스캔이 병렬화되나?

- **Index Fast Full Scan(IFFS)**: 순서를 무시하고 **리프/브랜치 블록 전체**를 읽음 → **DPR**과 매우 궁합이 좋고, **병렬화 쉬움**
- **Index Full Scan**: 루트→리프 순서 유지. **순서 유지**가 필요해 병렬성 제한
- **Index Range Scan**: “범위”가 나뉘어야 병렬 효과(파티션 인덱스/스킵 스캔/프리페치 등과 조합)

## IFFS 병렬 예제

```sql
-- 인덱스만으로 COUNT/AGG 등 해결(커버링) 시 IFFS 선호
EXPLAIN PLAN FOR
SELECT /*+ index_ffs(s ix_sales_cust) parallel_index(s 8) monitor */
       COUNT(*)
FROM   sales s
WHERE  cust_id BETWEEN 1 AND 9999999;  -- 조건이 매우 광범위 → IFFS 후보

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +ALIAS +NOTE'));
```
- 기대: `INDEX FAST FULL SCAN` + `PX BLOCK ITERATOR`, **대기**는 `direct path read` 비중 ↑
- 커버링이 아니면 IFFS 이후 **TABLE ACCESS BY ROWID**가 뒤따라 Random I/O를 유발

## RANGE 스캔 병렬화(가능 조건)

- **파티션 인덱스(로컬)**: 각 파티션을 **서로 다른 PX**가 담당 → **Partition-wise Index Range Scan**
- **스킵 스캔/범위 분할**: 옵티마이저가 **BLOCK RANGE granule**로 Range를 나눌 수 있는 케이스 제한적
- 힌트:
```sql
-- 로컬 파티션 인덱스 스캔을 병렬로(파티션 설계가 선결)
-- PARALLEL_INDEX(table_alias [index_name] degree)
SELECT /*+ leading(s) use_nl(o)
           parallel(s 8) parallel(o 8)
           parallel_index(s 8) monitor */
       /* ... */
FROM   sales s JOIN orders o ON o.cust_id = s.cust_id
WHERE  s.cust_id BETWEEN 1 AND 100000;
```

## 체크리스트

- **IFFS**가 가능한지(정렬 필요 X, 커버링 여부)
- **로컬 파티션 인덱스**면 Range도 병렬화 용이
- DPR/MBRC/스토리지 스루풋 확인(대용량 I/O 최적화)
- 인덱스 병렬 스캔 후 **테이블 랜덤 액세스**가 대량이면 **NL 대신 해시 조인**이 나을 수 있음

---

# 4) 병렬 Nested Loops 조인(PX NLJ)

## 기본 아이디어

- **Outer(드라이빙) 집합**을 **PX 서버들**에 분배 → 각 서버가 **인덱스 Range Scan + Rowid 접근** 으로 **Inner**를 탐색
- 장점: **선택도가 아주 높아**(드라이빙 로우가 매우 적고, 인덱스가 정교)일 때 **최고**의 응답
- 단점: 드라이빙 로우가 많거나 Inner에 **랜덤 I/O 폭증** → 병렬 NLJ는 금방 **I/O 병목**

## 실습: 선택도 높은 드라이빙 + NL 강제

```sql
-- GOLD 고객만 매우 소수라고 가정
EXPLAIN PLAN FOR
SELECT /*+ leading(d) use_nl(s)
           parallel(d 8) parallel(s 8)
           pq_distribute(d BROADCAST NONE)   -- 작은 쪽을 복제해 드라이빙
           monitor */
       s.sales_id, s.amount
FROM   dim_customer d
JOIN   sales       s
  ON   s.cust_id = d.cust_id
WHERE  d.grade = 'GOLD';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +ALIAS +NOTE'));
```
- 전략: **작은 차원**을 **브로드캐스트** → 각 PX가 **자기 지역**에서 인덱스 Range Scan으로 빠르게 찾음
- 기대 대기: 테이블 랜덤 I/O 위주(`db file sequential read`), 병렬 큐 대기 적음

## 반례: 드라이빙이 크면 NLJ 병렬은 비추

```sql
-- 드라이빙(orders)이 큼 → NLJ는 Random I/O 폭증
EXPLAIN PLAN FOR
SELECT /*+ leading(o) use_nl(s)
           parallel(o 16) parallel(s 16) monitor */
       /* ... */
FROM   orders o
JOIN   sales  s
  ON   s.cust_id = o.cust_id
WHERE  o.order_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12);

-- 대안: 해시 조인으로 전환 + 분배 전략
EXPLAIN PLAN FOR
SELECT /*+ leading(o) use_hash(s)
           parallel(o 16) parallel(s 16)
           pq_distribute(o HASH HASH) pq_distribute(s HASH HASH) monitor */
       /* ... 동일 칼럼 ... */
FROM   orders o
JOIN   sales  s
  ON   s.cust_id = o.cust_id
WHERE  o.order_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12);
```

## NLJ 병렬화가 잘 맞는 패턴

- 드라이빙 로우가 **매우 작다**(탐색 건수 자체가 적음)
- Inner가 **고선택성 인덱스**로 금방 찾힌다
- **브로드캐스트**로 작은 집합을 펴서 **교차 통신 최소화**
- RAC에선 **파티션/서비스 affinity**로 **GC 대기** 줄이기

---

# 5) 운영 관점: 실행계획/대기/스큐 관찰 루틴

```sql
-- 실제 실행된 커서 플랜(통계 포함)
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'BASIC +PARALLEL +ALIAS +PREDICATE +NOTE'));

-- 병렬 TQ(테이블 큐) 분배/스큐
SELECT dfo_number, tq_id, server_type, inst_id, process, num_rows, bytes
FROM   v$pq_tqstat
ORDER  BY dfo_number, tq_id, server_type, inst_id, process;

-- 병렬·Direct Path 관련 대기 이벤트(최근 5분)
-- (개념 예시: ASH이용)
-- SELECT event, COUNT(*) samples
-- FROM   v$active_session_history
-- WHERE  sample_time > SYSDATE - 1/288
--   AND  session_type = 'FOREGROUND'
--   AND (event LIKE 'PX Deq%' OR event LIKE 'direct path%' OR event LIKE 'gc %'
--        OR event LIKE 'db file sequential read' OR event LIKE 'db file scattered read')
-- GROUP  BY event
-- ORDER  BY samples DESC;
```

- **`direct path read`/`write temp`**: 소트/해시/FTS/IFFS
- **`PX Deq Credit: send blkd`**: 재분배 병목/스큐
- **`db file sequential read`**: 인덱스+Rowid 랜덤 I/O(특히 NLJ)
- **`gc %`**: RAC 블록 전송 대기(애피니티·PWJ 고려)

---

# 6) 상황별 튜닝 체크리스트(요약)

### A. `direct path read`

- 대용량 스캔/정렬/집계라면 **DQ(Direct Path)**가 정상 신호
- 스토리지/MBRC/비동기 I/O 설정 확인, **DOP**를 스토리지 밸런스에 맞추기
- 반복 참조 소테이블엔 불리 → 통계/카디널리티 정확히

### B. 병렬 DML

- **`ENABLE PARALLEL DML`** 필수, APPEND(직접경로)로 적재 스트리밍
- PDML 후 **COMMIT 전** 읽기/수정 금지(ORA-12838)
- 인덱스/트리거/제약으로 **PDML이 강등**될 수 있음(플랜 NOTE 확인)
- RAC: 파티션/서비스 **affinity**로 충돌↓, 프루닝 유도

### C. 병렬 인덱스 스캔

- **IFFS + DPR**가 가장 병렬 친화적
- Range 병렬은 **로컬 파티션 인덱스**일 때 유리
- 인덱스만으로 커버되면 테이블 랜덤 I/O 제거(매우 큼)

### D. 병렬 NL 조인

- 드라이빙이 **아주 작을 때만** 진가 발휘
- 그 외엔 **해시 조인 + PQ_DISTRIBUTE(HASH/HASH or BROADCAST)** 가 안전
- 브로드캐스트로 작은 쪽을 퍼뜨려 **랜덤 I/O 분산 → 응답 안정화**

---

## 7) 손에 잡히는 미니 시나리오

### DPR 체감

```sql
SELECT /*+ full(s) parallel(s 8) monitor */ COUNT(*) FROM sales s;
-- DBMS_XPLAN에서 PX FTS 확인, ASH에 direct path read 비중↑
```

### PDML 적재 & ORA-12838

```sql
ALTER SESSION ENABLE PARALLEL DML;

INSERT /*+ APPEND PARALLEL(s 8) */ INTO sales
SELECT /*+ PARALLEL(o 8) */ o.order_id, o.cust_id, o.order_dt, 'US', o.amt FROM orders o;

-- 바로 아래처럼 같은 세션에서 sales 조회/수정하면 ORA-12838 가능 → COMMIT 먼저
COMMIT;
```

### IFFS 병렬

```sql
SELECT /*+ index_ffs(s ix_sales_cust) parallel_index(s 8) monitor */ COUNT(*)
FROM sales s
WHERE cust_id >= 0;
```

### NLJ vs 해시 비교

```sql
-- NLJ: GOLD만(선택도 높음) → 좋다
SELECT /*+ leading(d) use_nl(s) pq_distribute(d BROADCAST NONE) parallel(8) monitor */
       s.sales_id, s.amount
FROM   dim_customer d JOIN sales s ON s.cust_id = d.cust_id
WHERE  d.grade = 'GOLD';

-- 드라이빙 큼 → 해시 조인이 유리
SELECT /*+ leading(o) use_hash(s)
           pq_distribute(o HASH HASH) pq_distribute(s HASH HASH) parallel(16) monitor */
       COUNT(*)
FROM   orders o JOIN sales s ON s.cust_id = o.cust_id
WHERE  o.order_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12);
```

---

## 마무리 한 줄

- **Direct Path = 대용량 스트리밍 읽기**,
- **PDML = 두 단계 파이프라인(SELECT→DML)**,
- **병렬 인덱스 = IFFS가 왕**,
- **병렬 NLJ = “드라이빙이 극소수”일 때만**.
실행계획의 **PX SEND/RECEIVE**와 대기 이벤트만 정확히 읽어도 실전 병렬 튜닝의 8할은 해결됩니다.
