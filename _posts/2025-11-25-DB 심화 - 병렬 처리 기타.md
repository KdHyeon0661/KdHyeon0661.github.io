---
layout: post
title: DB 심화 - 병렬 처리 기타
date: 2025-11-25 16:25:23 +0900
category: DB 심화
---
# Oracle 병렬 처리 심화: Direct Path Read, PDML, 인덱스 스캔, NL 조인

병렬 처리는 대용량 데이터베이스 환경에서 성능을 획기적으로 개선할 수 있는 핵심 기술입니다. 그러나 단순히 병렬도를 높이는 것만으로는 충분하지 않습니다. 효과적인 병렬 처리를 위해서는 데이터의 분배 방식, I/O 패턴, 조인 전략 등 다양한 요소를 깊이 이해해야 합니다. 이 글에서는 Oracle 병렬 처리의 핵심 개념과 실전 적용 방법을 체계적으로 살펴보겠습니다.

---

## 병렬 처리 기본 아키텍처 이해

### 병렬 실행 구조

Oracle의 병렬 처리는 Query Coordinator(QC)가 작업을 조율하고, 다수의 Parallel Execution Servers(PX 슬레이브)가 실제 작업을 분담하는 구조로 이루어집니다.

**핵심 구성 요소**:
- **QC(Query Coordinator)**: SQL 실행 시작, 결과 수집, 최종 반환
- **PX 슬레이브**: 실제 병렬 작업 수행자
- **DFO(Data Flow Operation)**: 병렬 실행 단위
- **TQ(Table Queue)**: PX 슬레이브 간 데이터 교환 채널

**데이터 분배 방식**:
- `PX SEND HASH`: 해시값 기반 분배
- `PX SEND BROADCAST`: 모든 슬레이브로 복제
- `PX SEND PARTITION`: 파티션 단위 분배
- `PX SEND ROUND-ROBIN`: 라운드 로빈 방식 분배

### 병렬 처리의 경제성

병렬 처리가 성능 향상으로 이어지려면 다음 조건을 충족해야 합니다:

```
직렬 처리 비용 > (스캔 비용 + 분배 비용 + 병합 비용)
```

분배 비용(네트워크 통신, 데이터 이동)과 병합 비용(QC에서의 결과 통합)이 지나치게 크면 병렬 처리의 이점이 사라집니다.

---

## Direct Path Read: 대용량 스캔의 핵심 기술

### Direct Path Read의 작동 원리

Direct Path Read(DPR)는 데이터 블록을 SGA 버퍼 캐시를 거치지 않고 직접 PGA로 읽어오는 고성능 I/O 방식입니다. 이는 대용량 풀 테이블 스캔이나 인덱스 패스트 풀 스캔에서 자주 사용됩니다.

**전통적 읽기 vs Direct Path Read**:
- **버퍼드 읽기**: 디스크 → SGA 버퍼 캐시 → PGA
- **Direct Path Read**: 디스크 → PGA (캐시 우회)

### Direct Path Read 발생 조건

1. **병렬 풀 테이블 스캔**
2. **병렬 인덱스 패스트 풀 스캔**
3. **대용량 직렬 스캔**(Adaptive Direct Path Read)
4. **TEMP 세그먼트 접근**(direct path read/write temp)

### Direct Path Read의 장단점

**장점**:
- 버퍼 캐시 LRU 체인과 래치 경합 회피
- 대규모 순차 I/O로 스토리지 대역폭 최대 활용
- PGA 메모리 직접 사용으로 CPU 효율 향상

**단점**:
- 반복 접근되는 소형 테이블에서는 캐시 히트 이점 상실
- Dirty 버퍼가 많은 경우 추가 동기화 오버헤드
- 특정 상황에서 I/O 병목 발생 가능

### Direct Path Read 성능 측정

```sql
-- Direct Path Read 통계 확인
SELECT 
    n.name AS statistic_name,
    s.value AS value,
    CASE n.name 
        WHEN 'physical reads direct' THEN 'Direct Path Read'
        WHEN 'physical reads' THEN 'Total Physical Read'
        ELSE 'Other'
    END AS category
FROM v$mystat s
JOIN v$statname n ON s.statistic# = n.statistic#
WHERE n.name IN ('physical reads direct', 'physical reads');

-- Direct Path Read 관련 대기 이벤트
SELECT 
    event,
    total_waits,
    time_waited,
    average_wait
FROM v$session_event
WHERE sid = SYS_CONTEXT('USERENV', 'SID')
AND event LIKE 'direct path%';
```

### Direct Path Read 최적화 전략

1. **적절한 DOP 설정**: 스토리지 대역폭과 CPU 자원 고려
2. **멀티블록 읽기 크기 최적화**: `db_file_multiblock_read_count` 파라미터 튜닝
3. **데이터 접근 패턴 분석**: 반복 접근 테이블은 캐시 경로 유지
4. **스토리지 구성 최적화**: 스트라이핑, RAID 레벨, 캐시 설정 검토

---

## 병렬 DML(PDML): 대용량 데이터 변경

### PDML 아키텍처

PDML은 두 단계 파이프라인으로 구성됩니다:

1. **Producer 단계**: 소스 데이터 병렬 스캔 및 변환
2. **Consumer 단계**: 타겟 세그먼트에 병렬 INSERT/UPDATE/DELETE/MERGE

### PDML 활성화 조건

```sql
-- 필수: 세션에서 PDML 활성화
ALTER SESSION ENABLE PARALLEL DML;

-- 옵션: 테이블 레벨 병렬 설정
ALTER TABLE sales PARALLEL 8;

-- 또는 힌트로 병렬도 지정
INSERT /*+ PARALLEL(sales, 8) */ INTO sales ...
```

### 병렬 INSERT: Direct-Path Insert

병렬 INSERT는 기본적으로 Direct-Path Insert 방식으로 동작합니다:

```sql
-- Direct-Path Insert 예제
EXPLAIN PLAN FOR
INSERT /*+ APPEND PARALLEL(sales 8) */
INTO sales (sales_id, cust_id, sales_dt, region_cd, amount)
SELECT /*+ PARALLEL(orders 8) */
    order_id + 1000000,
    cust_id,
    order_dt,
    'US',
    amount
FROM orders
WHERE order_dt >= DATE '2025-01-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, NULL, 'BASIC +PARALLEL +NOTE'));
```

**Direct-Path Insert 특징**:
- HWM(High Water Mark) 위 신규 익스텐트 사용
- 배타적 세그먼트 락 필요
- UNDO 생성 최소화
- 인덱스 유지 비용 별도 발생

### ORA-12838: Direct-Path Insert 제약

Direct-Path Insert 후 동일 트랜잭션에서 해당 테이블 접근 시 발생하는 오류:

```sql
-- 잘못된 예
INSERT /*+ APPEND */ INTO sales SELECT ...;  -- Direct-Path Insert
SELECT COUNT(*) FROM sales;  -- ORA-12838 발생

-- 올바른 예
INSERT /*+ APPEND */ INTO sales SELECT ...;
COMMIT;  -- 트랜잭션 종료
SELECT COUNT(*) FROM sales;  -- 정상 실행
```

### PDML UPDATE/DELETE/MERGE 고려사항

```sql
-- 병렬 UPDATE 예제
UPDATE /*+ PARALLEL(sales 8) */
    sales
SET amount = amount * 1.1
WHERE sales_dt >= DATE '2025-01-01';

-- 병렬 DELETE 예제
DELETE /*+ PARALLEL(sales 8) */
FROM sales
WHERE sales_dt < DATE '2024-01-01';
```

**PDML 주의사항**:
1. **인덱스 유지 비용**: 각 인덱스마다 병렬 유지 작업 필요
2. **트리거 실행**: 문장 레벨 트리거만 지원
3. **제약 조건**: 외래 키, CHECK 제약 등 제한 사항 확인
4. **RAC 환경**: 인스턴스 간 블록 경합 가능성

### PDML 성능 모니터링

```sql
-- PDML 실행계획 확인
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, NULL,
    'BASIC +PARALLEL +ALIAS +NOTE'
));

-- PDML 세션 통계
SELECT 
    n.name AS statistic_name,
    s.value AS value
FROM v$mystat s
JOIN v$statname n ON s.statistic# = n.statistic#
WHERE n.name LIKE '%parallel%'
   OR n.name LIKE '%dml%'
ORDER BY n.name;
```

---

## 병렬 인덱스 스캔

### 병렬 인덱스 스캔 유형

1. **Index Fast Full Scan(IFFS)**: 가장 병렬 친화적
2. **Index Full Scan**: 전역 정렬 필요 시
3. **Index Range Scan**: 파티션 인덱스에서 효과적

### Index Fast Full Scan(IFFS) 병렬 처리

```sql
-- IFFS 병렬 스캔 예제
EXPLAIN PLAN FOR
SELECT /*+ 
    PARALLEL(sales 8)
    PARALLEL_INDEX(sales idx_sales_cust 8)
    INDEX_FFS(sales idx_sales_cust)
*/
    COUNT(*)
FROM sales
WHERE cust_id BETWEEN 1 AND 1000000;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, NULL, 'BASIC +PARALLEL +ALIAS +NOTE'));
```

**IFFS 특징**:
- 인덱스 전체 멀티블록 읽기
- 정렬 순서 비보장
- Direct Path Read와 최적 조합

### 병렬 인덱스 비용 계산 문제

옵티마이저가 병렬 인덱스 스캔 비용을 과소평가하는 문제:

```sql
-- 올바른 힌트 사용법
SELECT /*+ 
    PARALLEL(table_alias degree)           -- 테이블 병렬 힌트
    PARALLEL_INDEX(table_alias index_name degree)  -- 인덱스 병렬 힌트
    INDEX_FFS(table_alias index_name)      -- IFFS 힌트
*/
FROM ...
```

### 파티션 인덱스 병렬 스캔

로컬 파티션 인덱스는 자연스럽게 병렬 처리가 가능합니다:

```sql
-- 파티션 인덱스 병렬 범위 스캔
SELECT /*+ 
    PARALLEL(sales 8)
    INDEX(sales idx_sales_partitioned)
*/
    sales_id, amount
FROM sales
WHERE sales_dt >= DATE '2025-01-01'
  AND sales_dt < DATE '2025-02-01';
```

**파티션 병렬화 장점**:
- 파티션 단위 작업 분할
- 파티션 프루닝과 자연스러운 조합
- RAC 환경에서 인스턴스 친화성

---

## 병렬 Nested Loops 조인

### 병렬 NL 조인 아키텍처

병렬 NL 조인은 드라이빙 테이블(Outer)을 PX 슬레이브에 분배하고, 각 슬레이브가 내부 테이블(Inner)을 인덱스로 반복 탐색하는 구조입니다.

### 최적의 병렬 NL 조인 시나리오

```sql
-- 소형 Outer + 브로드캐스트 분배
EXPLAIN PLAN FOR
SELECT /*+ 
    LEADING(customers) USE_NL(sales)
    PARALLEL(customers 4) PARALLEL(sales 8)
    PQ_DISTRIBUTE(customers BROADCAST NONE)
*/
    sales.sales_id,
    sales.amount
FROM dim_customer customers
JOIN sales ON sales.cust_id = customers.cust_id
WHERE customers.grade = 'GOLD';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, NULL, 'BASIC +PARALLEL +ALIAS +NOTE'));
```

**적합 조건**:
- Outer 테이블이 매우 작음(수천 행 이하)
- Inner 테이블에 효율적인 인덱스 존재
- 브로드캐스트 분배로 통신 오버헤드 최소화

### 병렬 NL 조인의 위험성

Outer 테이블이 큰 경우 심각한 성능 문제 발생:

```sql
-- 문제가 되는 대규모 NL 조인
SELECT /*+ 
    LEADING(orders) USE_NL(sales)
    PARALLEL(orders 16) PARALLEL(sales 16)
*/
    orders.order_id,
    sales.sales_id
FROM orders
JOIN sales ON sales.cust_id = orders.cust_id
WHERE orders.order_dt >= DATE '2024-01-01';
```

**문제점**:
- `db file sequential read` 이벤트 폭증
- 인덱스 블록 경합 심화
- PX 슬레이브 간 작업 불균형

### 대안: 병렬 해시 조인

대규모 테이블 조인 시 해시 조인이 일반적으로 더 안정적입니다:

```sql
-- 병렬 해시 조인 예제
EXPLAIN PLAN FOR
SELECT /*+ 
    LEADING(orders) USE_HASH(sales)
    PARALLEL(orders 16) PARALLEL(sales 16)
    PQ_DISTRIBUTE(orders HASH HASH)
    PQ_DISTRIBUTE(sales HASH HASH)
*/
    orders.order_id,
    sales.sales_id
FROM orders
JOIN sales ON sales.cust_id = orders.cust_id
WHERE orders.order_dt >= DATE '2024-01-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, NULL, 'BASIC +PARALLEL +ALIAS +NOTE'));
```

---

## 실전 성능 모니터링과 튜닝

### 실행계획 분석

```sql
-- 상세 병렬 실행계획
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, NULL,
    'BASIC +PARALLEL +ALIAS +PREDICATE +NOTE'
));
```

**분석 포인트**:
- `PX SEND` 타입 확인
- `IN-OUT` 컬럼 데이터 흐름 분석
- `NOTE` 섹션 힌트 적용 여부 확인
- `BUFFERED` 표시 여부 확인

### PX 분배 통계 분석

```sql
-- PX 테이블 큐 통계
SELECT 
    dfo_number,
    tq_id,
    server_type,
    inst_id,
    process,
    num_rows,
    bytes,
    ROUND(bytes / 1024 / 1024, 2) AS mb_size,
    ROUND(100 * num_rows / SUM(num_rows) OVER (PARTITION BY dfo_number, tq_id), 2) AS pct_rows
FROM v$pq_tqstat
ORDER BY dfo_number, tq_id, server_type, inst_id, process;
```

**스큐 감지**: PX 슬레이브 간 `num_rows` 편차가 20% 이상이면 스큐 의심

### 성능 문제 진단

```sql
-- 병렬 관련 대기 이벤트 분석
SELECT 
    event,
    COUNT(*) AS wait_count,
    SUM(time_waited) / 1000 AS total_wait_sec,
    ROUND(AVG(time_waited), 2) AS avg_wait_ms
FROM v$active_session_history
WHERE session_id = SYS_CONTEXT('USERENV', 'SID')
  AND sample_time > SYSDATE - INTERVAL '5' MINUTE
  AND event IS NOT NULL
GROUP BY event
ORDER BY total_wait_sec DESC;
```

**주요 대기 이벤트 해석**:
- `direct path read`: 대용량 스캔 중
- `direct path read temp`: TEMP I/O 발생
- `db file sequential read`: 인덱스/ROWID 접근
- `PX Deq Credit: send blkd`: 분배 큐 블로킹
- `gc cr/current request`: RAC 인터커넥트 병목

---

## 상황별 최적화 전략

### Direct Path Read 최적화

**문제**: Direct Path Read가 과도하게 발생하며 I/O 대기 증가

**해결책**:
1. DOP 조정: `ALTER SESSION SET PARALLEL_DEGREE_POLICY = AUTO`
2. PGA 메모리 확보: `pga_aggregate_target` 증가
3. 반복 접근 테이블은 캐시 유지: `ALTER TABLE table_name CACHE`

### PDML 성능 개선

**문제**: 병렬 DML 실행 시간이 예상보다 김

**해결책**:
1. 인덱스 일시적 비활성화: `ALTER INDEX index_name UNUSABLE`
2. Direct-Path Insert 활용: `APPEND` 힌트 사용
3. 파티션 단위 작업: 파티션별로 COMMIT 수행

### 병렬 인덱스 스캔 튜닝

**문제**: 옵티마이저가 FTS 선택, 인덱스 사용 안 함

**해결책**:
```sql
-- 테이블과 인덱스 모두에 병렬 힌트 적용
SELECT /*+ 
    PARALLEL(table_alias degree)
    PARALLEL_INDEX(table_alias index_name degree)
    INDEX_FFS(table_alias index_name)
*/
...
```

### 병렬 NL 조인 최적화

**문제**: `db file sequential read` 이벤트 폭증

**해결책**:
1. Outer 테이블 크기 검증: 작을 때만 NL 조인 사용
2. 브로드캐스트 분배 적용: `PQ_DISTRIBUTE(outer BROADCAST NONE)`
3. 해시 조인으로 전환: 대규모 테이블 조인 시

---

## 결론: 병렬 처리의 전략적 접근

병렬 처리는 단순한 성능 향상 도구를 넘어 대용량 데이터베이스 시스템의 근본적인 설계 원칙을 반영합니다. 효과적인 병렬 처리 구현을 위한 핵심 원칙을 정리해보겠습니다.

### 원칙 1: 적절한 도구 선택

각 상황에 맞는 최적의 병렬 처리 방식을 선택하세요:

- **Direct Path Read**: 대용량 순차 스캔, 일회성 분석 작업
- **PDML**: 대규모 데이터 적재, 일괄 변경 작업
- **병렬 인덱스 스캔**: 커버링 인덱스 쿼리, 파티션 데이터 접근
- **병렬 NL 조인**: 소형 차원 테이블 조인, 고선택성 조건
- **병렬 해시 조인**: 대규모 테이블 조인, 균등 데이터 분포

### 원칙 2: 데이터 특성 이해

데이터의 크기, 분포, 접근 패턴을 깊이 이해하세요:

1. **데이터 크기**: PGA 메모리, TEMP 공간, 네트워크 대역폭 고려
2. **분포 특성**: 데이터 스큐, 핫스팟, 파티션 구조 분석
3. **접근 패턴**: 반복 접근 vs 일회성 분석, 읽기 vs 쓰기 비율

### 원칙 3: 체계적 접근법

과학적 방법론으로 접근하세요:

1. **측정**: 실행계획, 성능 통계, 리소스 사용량 수집
2. **분석**: 병목 지점, 비효율 원인, 개선 가능성 파악
3. **실험**: 제어된 환경에서 변경사항 적용 및 효과 측정
4. **검증**: 프로덕션 환경에서의 안정성과 예측성 확인

### 원칙 4: 운영 관점 통합

기술적 최적화를 운영 요구사항과 통합하세요:

- **모니터링**: 지속적 성능 관찰과 이상 감지
- **자동화**: 반복적 튜닝 작업 자동화
- **문서화**: 결정 사유와 효과 체계적 기록
- **지식 공유**: 팀 내 모범 사례 공유와 표준화

### 마지막 조언

병렬 처리는 "더 많은 리소스 사용 = 더 빠른 성능"이라는 단순한 공식이 아닙니다. 오히려 "적절한 리소스 + 올바른 분배 + 효율적 통신 = 최적 성능"이라는 복잡한 방정식입니다. 성공적인 병렬 처리는 기술적 이해를 넘어 시스템 전체의 아키텍처, 데이터 특성, 비즈니스 요구를 종합적으로 고려하는 전략적 사고를 요구합니다.

체계적인 접근, 과학적 검증, 지속적 개선을 통해 병렬 처리의 진정한 가치를 실현하세요. 이는 단순한 성능 개선을 넘어 데이터 처리 능력의 근본적인 확장으로 이어질 것입니다.