---
layout: post
title: 영상처리 - EXIF 회전 적용 + 메타 유지 저장
date: 2025-10-18 19:25:23 +0900
category: 영상처리
---
# EXIF 회전 적용 + 메타 유지 저장 (APP1/APP2 보존)

> **목표**
> 1) JPEG을 열 때 **EXIF Orientation**을 읽어 **실제 픽셀을 회전/반전 보정**한다.  
> 2) 저장 시 **원본 메타데이터(APP1: EXIF/XMP, APP2: ICC)** 를 **가능한 그대로 유지**한다.  
> 3) 특히 **ICC 프로파일(색관리)** 과 **EXIF**를 재부착하고, **Orientation은 1(정상)** 로 **리셋/패치**한다(중복 회전 방지).

아래는 **libjpeg(-turbo)** 기반의 **재인코드 방식** 예제다. (무손실이 필요하면 맨 끝의 **jpegtran 경로** 참고)

---

## 1) 처리 순서 한눈에 보기

1. `jpeg_save_markers` 로 **APP1/APP2**(+선택: APP13) **수집**  
2. 헤더 파싱 → **Orientation(0x0112)** 추출  
3. 디코드 → **RGB 버퍼** 획득  
4. **Orientation → 픽셀 회전/반전** 적용  
5. **EXIF 패치**: Orientation 값을 **1**로 덮거나(권장) 해당 태그를 제거  
6. **재인코드**:  
   - `jpeg_write_marker` 로 **EXIF(APP1)**, **ICC(APP2)** 등 **원본 메타 재부착**  
   - 스캔라인 쓰기

---

## 2) Orientation 해석 표 (1~8)

| 값 | 의미 | 실제 픽셀 보정(좌표 기준) |
|---|---|---|
| 1 | 정상 | 없음 |
| 2 | 좌우반전 | Horizontal flip |
| 3 | 180° 회전 | Rotate 180 |
| 4 | 상하반전 | Vertical flip |
| 5 | 상하반전 + 90° CW | V flip → Rotate 90 CW |
| 6 | 90° CW | Rotate 90 CW |
| 7 | 좌우반전 + 90° CW | H flip → Rotate 90 CW |
| 8 | 90° CCW | Rotate 90 CCW |

> **주의:** 픽셀에 보정이 끝났다면 저장하는 EXIF의 Orientation은 **반드시 1** 로 만들어야 한다.

---

## 3) 실전 C++: **열기 → Orientation 보정 → 메타 유지 저장**

> 의존: `jpeglib.h` (libjpeg-turbo), C++17  
> 선택 의존(더 안전한 EXIF 파싱 원하면): TinyEXIF/tinyexif, Exiv2 등

```cpp
// ------------------------------------------------------------
// JPEG: EXIF 회전 적용 + 메타 유지 저장 (APP1/APP2 복사)
//   - 입력: std::string inPath
//   - 출력: std::string outPath
//   - 기능: EXIF Orientation 반영(픽셀 회전/반전), EXIF/ICC 재부착
// ------------------------------------------------------------
#include <jpeglib.h>
#include <cstdio>
#include <vector>
#include <string>
#include <cstdint>
#include <cstring>
#include <stdexcept>
#include <algorithm>

// ------------------------ 유틸: 파일 열기 ------------------------
struct FileCloser { void operator()(FILE* f) const { if (f) fclose(f); } };
using FilePtr = std::unique_ptr<FILE, FileCloser>;

// ------------------------ 유틸: APP 마커 보관 ------------------------
struct AppMarker {
    int marker;                  // JPEG_APP0 + n
    std::vector<uint8_t> data;   // marker payload (길이 포함하지 않음)
};
using AppMarkers = std::vector<AppMarker>;

// ------------------------ EXIF Orientation 파싱 ------------------------
// 간단 파서: APP1 (Exif\0\0 + TIFF) 에서 0x0112(Orientation) SHORT 읽기
// 참고: 안전성 위해 길이 체크를 빡빡하게 한다.
static uint16_t ReadU16BE(const uint8_t* p) { return (uint16_t)((p[0]<<8)|p[1]); }
static uint32_t ReadU32BE(const uint8_t* p) { return (uint32_t)((p[0]<<24)|(p[1]<<16)|(p[2]<<8)|p[3]); }
static uint16_t ReadU16LE(const uint8_t* p) { return (uint16_t)(p[0]|(p[1]<<8)); }
static uint32_t ReadU32LE(const uint8_t* p) { return (uint32_t)(p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24)); }

struct TiffCtx {
    bool le = true;            // little endian?
    const uint8_t* base = nullptr; // TIFF 시작(바이트 0)
    size_t size = 0;
    auto R16(const uint8_t* p) const -> uint16_t { return le ? ReadU16LE(p) : ReadU16BE(p); }
    auto R32(const uint8_t* p) const -> uint32_t { return le ? ReadU32LE(p) : ReadU32BE(p); }
    bool InRange(size_t off, size_t need=1) const { return off < size && need <= size - off; }
};

static int ParseExifOrientation(const std::vector<uint8_t>& app1, size_t* outTagOff = nullptr, bool* outLittleEndian=nullptr)
{
    // APP1 헤더: "Exif\0\0" + TIFF
    const char exifHdr[] = "Exif\0\0";
    if (app1.size() < 6 || std::memcmp(app1.data(), exifHdr, 6) != 0) return 0;

    TiffCtx ctx; ctx.base = app1.data() + 6; ctx.size = app1.size() - 6;
    if (!ctx.InRange(8)) return 0; // 최소 TIFF 헤더

    // TIFF 헤더: ByteOrder(II/MM), 42, IFD0 Offset
    if (!ctx.InRange(0, 8)) return 0;
    const uint8_t* tiff = ctx.base;
    if (tiff[0]=='I' && tiff[1]=='I') ctx.le = true;
    else if (tiff[0]=='M' && tiff[1]=='M') ctx.le = false;
    else return 0;

    uint16_t fortyTwo = ctx.R16(tiff+2);
    if (fortyTwo != 42) return 0;

    uint32_t ifd0Off = ctx.R32(tiff+4);
    if (!ctx.InRange(ifd0Off, 2)) return 0;

    // IFD0
    const uint8_t* ifd0 = ctx.base + ifd0Off;
    uint16_t cnt = ctx.R16(ifd0);
    size_t entBase = ifd0Off + 2;
    for (uint16_t i=0; i<cnt; ++i) {
        size_t entOff = entBase + i*12;
        if (!ctx.InRange(entOff, 12)) return 0;
        const uint8_t* e = ctx.base + entOff;
        uint16_t tag  = ctx.R16(e+0);
        uint16_t type = ctx.R16(e+2);
        uint32_t num  = ctx.R32(e+4);
        // Orientation: tag 0x0112, type=SHORT, num=1
        if (tag == 0x0112 && type == 3 && num >= 1) {
            // 값은 e+8(4바이트 영역)에 들어있거나, offset 참조일 수도 있다.
            uint32_t valOrOff = ctx.R32(e+8);
            uint16_t ori = 0;
            if (num==1) {
                // SHORT 1개면 보통 e+8에 값 저장 (엔디안 고려)
                if (ctx.le) ori = (uint16_t)(valOrOff & 0xFFFF);
                else        ori = (uint16_t)((valOrOff>>16) & 0xFFFF);
            } else {
                // 배열이면 offset을 따라가야 하지만 실무에서 거의 1
                size_t off = valOrOff;
                if (ctx.InRange(off, 2)) ori = ctx.R16(ctx.base+off);
            }
            if (outTagOff) *outTagOff = entOff;        // EXIF 내 태그 엔트리 위치(패치용)
            if (outLittleEndian) *outLittleEndian = ctx.le;
            return (int)ori;
        }
    }
    return 0;
}

// EXIF Orientation을 "1"로 패치 (가능하면 원본 EXIF 유지)
static bool PatchExifOrientationTo1(std::vector<uint8_t>& app1)
{
    size_t tagOff=0; bool le=true;
    int ori = ParseExifOrientation(app1, &tagOff, &le);
    if (ori <= 0) return false; // Orientation 없음

    // IFD 엔트리 e[8..11]의 4바이트 영역에 SHORT 값(1)을 기록 (num=1 케이스 가정)
    if (tagOff + 12 > app1.size()) return false;
    uint8_t* e = app1.data() + 6 + tagOff; // +6: "Exif\0\0"
    // e+2(type)=3(SHORT) & e+4(num)=1 인지 간단 확인(엄격 검사 생략 가능)
    // 값 기록:
    if (le) {
        e[8] = 1; e[9] = 0; e[10] = 0; e[11] = 0;
    } else {
        e[8] = 0; e[9] = 1; e[10] = 0; e[11] = 0;
    }
    return true;
}

// ------------------------ 픽셀 회전/반전 ------------------------
// RGB 24bpp 버퍼(행보폭 strideBytes) 기준. (BGR도 동일 패턴으로 가능)
struct ImageRGB {
    int w=0, h=0, stride=0;
    std::vector<uint8_t> data; // size >= h*stride
};

// H flip
static ImageRGB FlipH(const ImageRGB& src) {
    ImageRGB dst{src.w, src.h, src.w*3, std::vector<uint8_t>((size_t)src.h*src.w*3)};
    for (int y=0; y<src.h; ++y) {
        const uint8_t* s = src.data.data() + (size_t)src.stride*y;
        uint8_t* d = dst.data.data() + (size_t)dst.stride*y;
        for (int x=0; x<src.w; ++x) {
            const uint8_t* sp = s + x*3;
            uint8_t* dp = d + (dst.w-1-x)*3;
            dp[0]=sp[0]; dp[1]=sp[1]; dp[2]=sp[2];
        }
    }
    return dst;
}
// V flip
static ImageRGB FlipV(const ImageRGB& src) {
    ImageRGB dst{src.w, src.h, src.w*3, std::vector<uint8_t>((size_t)src.h*src.w*3)};
    for (int y=0; y<src.h; ++y) {
        const uint8_t* s = src.data.data() + (size_t)src.stride*y;
        uint8_t* d = dst.data.data() + (size_t)dst.stride*(dst.h-1-y);
        std::memcpy(d, s, (size_t)src.w*3);
    }
    return dst;
}
// 90 CW
static ImageRGB Rot90CW(const ImageRGB& src) {
    ImageRGB dst{src.h, src.w, src.h*3, std::vector<uint8_t>((size_t)src.w*src.h*3)};
    for (int y=0; y<src.h; ++y) {
        for (int x=0; x<src.w; ++x) {
            const uint8_t* sp = src.data.data() + (size_t)src.stride*y + x*3;
            // (x,y) -> (y, newH-1-x)
            int nx = y, ny = dst.h - 1 - x;
            uint8_t* dp = dst.data.data() + (size_t)dst.stride*ny + nx*3;
            dp[0]=sp[0]; dp[1]=sp[1]; dp[2]=sp[2];
        }
    }
    return dst;
}
// 90 CCW
static ImageRGB Rot90CCW(const ImageRGB& src) {
    ImageRGB dst{src.h, src.w, src.h*3, std::vector<uint8_t>((size_t)src.w*src.h*3)};
    for (int y=0; y<src.h; ++y) {
        for (int x=0; x<src.w; ++x) {
            const uint8_t* sp = src.data.data() + (size_t)src.stride*y + x*3;
            // (x,y) -> (newW-1-y, x)
            int nx = dst.w - 1 - y, ny = x;
            uint8_t* dp = dst.data.data() + (size_t)dst.stride*ny + nx*3;
            dp[0]=sp[0]; dp[1]=sp[1]; dp[2]=sp[2];
        }
    }
    return dst;
}
// 180
static ImageRGB Rot180(const ImageRGB& src) {
    ImageRGB dst{src.w, src.h, src.w*3, std::vector<uint8_t>((size_t)src.w*src.h*3)};
    for (int y=0; y<src.h; ++y) {
        for (int x=0; x<src.w; ++x) {
            const uint8_t* sp = src.data.data() + (size_t)src.stride*y + x*3;
            uint8_t* dp = dst.data.data() + (size_t)dst.stride*(dst.h-1-y) + (dst.w-1-x)*3;
            dp[0]=sp[0]; dp[1]=sp[1]; dp[2]=sp[2];
        }
    }
    return dst;
}

// Orientation(1..8) → 픽셀 보정
static ImageRGB ApplyOrientation(const ImageRGB& src, int ori)
{
    switch(ori) {
        default: return src;
        case 1:  return src;
        case 2:  return FlipH(src);
        case 3:  return Rot180(src);
        case 4:  return FlipV(src);
        case 5:  return Rot90CW(FlipV(src));   // 상하반전 후 90CW
        case 6:  return Rot90CW(src);
        case 7:  return Rot90CW(FlipH(src));   // 좌우반전 후 90CW
        case 8:  return Rot90CCW(src);
    }
}

// ------------------------ 디코드(마커 수집) ------------------------
static void CollectMarkers(j_decompress_ptr dinfo, AppMarkers& out)
{
    // jpeg_save_markers 호출로 수집된 마커는 dinfo->marker_list로 연결되어 있다.
    for (jpeg_saved_marker_ptr m = dinfo->marker_list; m; m = m->next) {
        // 관심 마커만 (APP1, APP2). 필요시 APP13도 추가
        if (m->marker == (JPEG_APP0 + 1) || m->marker == (JPEG_APP0 + 2)) {
            AppMarker a; a.marker = m->marker;
            a.data.assign(m->data, m->data + m->data_length);
            out.emplace_back(std::move(a));
        }
    }
}

// ------------------------ 메인 함수 ------------------------
bool Jpeg_ApplyExifAndCopyMeta(const std::string& inPath, const std::string& outPath, int quality = 90, bool optimize = true)
{
    // 1) 열기 + 마커 저장
    FilePtr in(fopen(inPath.c_str(), "rb"));
    if (!in) throw std::runtime_error("open input failed");

    jpeg_decompress_struct dinfo{};
    jpeg_error_mgr jerr;
    dinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&dinfo);
    jpeg_stdio_src(&dinfo, in.get());

    // 관심 마커 저장: APP1(EXIF/XMP), APP2(ICC). 최대 길이 0xFFFF
    jpeg_save_markers(&dinfo, JPEG_APP0 + 1, 0xFFFF);
    jpeg_save_markers(&dinfo, JPEG_APP0 + 2, 0xFFFF);
    // (선택) IPTC: jpeg_save_markers(&dinfo, JPEG_APP0 + 13, 0xFFFF);

    if (jpeg_read_header(&dinfo, TRUE) != JPEG_HEADER_OK) {
        jpeg_destroy_decompress(&dinfo);
        throw std::runtime_error("bad jpeg header");
    }

    // 2) APP1/APP2 수집 + Orientation 파악
    AppMarkers markers;
    // 아직 marker_list는 read_header 이후 채워짐. 바로 수집해도 되고,
    // start_decompress 전에 수집해도 됨.
    CollectMarkers(&dinfo, markers);

    int orientation = 0;
    // EXIF APP1만 찾아 Orientation 추출
    for (auto& a : markers) {
        if (a.marker == (JPEG_APP0 + 1)) {
            int ori = ParseExifOrientation(a.data);
            if (ori >= 1 && ori <= 8) { orientation = ori; break; }
        }
    }

    // 3) 디코드 → RGB 버퍼
    dinfo.out_color_space = JCS_RGB; // (libjpeg-turbo라면 JCS_EXT_BGRX 등도 가능)
    jpeg_start_decompress(&dinfo);
    ImageRGB img; img.w = dinfo.output_width; img.h = dinfo.output_height; img.stride = img.w*3;
    img.data.resize((size_t)img.h * img.stride);

    while (dinfo.output_scanline < dinfo.output_height) {
        JSAMPROW rowptr = (JSAMPROW)(img.data.data() + (size_t)img.stride * dinfo.output_scanline);
        jpeg_read_scanlines(&dinfo, &rowptr, 1);
    }
    jpeg_finish_decompress(&dinfo);
    jpeg_destroy_decompress(&dinfo);
    in.reset();

    // 4) Orientation 보정 (픽셀 변환)
    ImageRGB fixed = (orientation >= 2 && orientation <= 8) ? ApplyOrientation(img, orientation) : img;

    // 5) EXIF Orientation을 1로 패치
    for (auto& a : markers) {
        if (a.marker == (JPEG_APP0 + 1)) {
            // "Exif\0\0" 블록이면 패치 시도 (XMP APP1은 건드리지 않음)
            PatchExifOrientationTo1(a.data); // 실패해도 무시(없으면 그대로)
        }
    }

    // 6) 재인코드 + 메타 재부착
    FilePtr out(fopen(outPath.c_str(), "wb"));
    if (!out) throw std::runtime_error("open output failed");

    jpeg_compress_struct cinfo{};
    jpeg_error_mgr jerr2;
    cinfo.err = jpeg_std_error(&jerr2);
    jpeg_create_compress(&cinfo);
    jpeg_stdio_dest(&cinfo, out.get());

    cinfo.image_width = fixed.w;
    cinfo.image_height = fixed.h;
    cinfo.input_components = 3;
    cinfo.in_color_space = JCS_RGB;

    jpeg_set_defaults(&cinfo);
    if (optimize) cinfo.optimize_coding = TRUE;
    jpeg_set_quality(&cinfo, quality, TRUE); // TRUE: limit to baseline
    // 필요시 샘플링/진행형 등 세팅 추가

    jpeg_start_compress(&cinfo, TRUE);

    // (핵심) 원본 메타 재부착 (EXIF/ICC/XMP 등)
    for (const auto& a : markers) {
        // Orientation 패치가 끝난 EXIF(APP1) 포함
        jpeg_write_marker(&cinfo, (JOCTET)a.marker, (const JOCTET*)a.data.data(), (unsigned int)a.data.size());
    }

    // 스캔라인 쓰기
    while (cinfo.next_scanline < cinfo.image_height) {
        JSAMPROW rowptr = (JSAMPROW)(fixed.data.data() + (size_t)fixed.stride*cinfo.next_scanline);
        jpeg_write_scanlines(&cinfo, &rowptr, 1);
    }

    jpeg_finish_compress(&cinfo);
    jpeg_destroy_compress(&cinfo);
    out.reset();

    return true;
}
```

**설명 포인트**

- `jpeg_save_markers(&dinfo, JPEG_APP0+1, 0xFFFF)` / `+2` 로 **EXIF/XMP(APP1)**, **ICC(APP2)** 를 **원본 그대로** 수집한다.  
- **Orientation** 적용 후 **픽셀 자체를 회전/반전**했으므로, **저장 EXIF의 Orientation은 1**(정상)로 **수정**해야 한다.  
  - 위 예제의 `PatchExifOrientationTo1()` 는 가장 단순한 **태그 값 덮어쓰기**(num=1 전제) 구현이다.  
  - 보다 안전/일반적인 패치를 하려면 **TinyEXIF/Exiv2** 같은 라이브러리 사용을 권장.  
- ICC(APP2)는 **세그먼트 분할 저장** 케이스가 있으나 우리는 **원본 마커들 전체를 그대로 재부착**하므로 안전하다.

> ✅ 이 방식은 **“픽셀 재인코드”** 이므로 **손실 재압축**이 발생한다.  
> 손실 0을 원하면 아래 **jpegtran(무손실)** 경로를 고려.

---

## 4) 사용 예 (상황 및 테스트)

```cpp
int main() {
    try {
        // 90° 돌아간 스마트폰 사진 (EXIF Orientation=6 가 흔함)
        Jpeg_ApplyExifAndCopyMeta("input_rotated.jpg", "output_fixed.jpg", 90, true);
        // 결과: 픽셀이 실제로 90° 보정되었고, EXIF Orientation=1로 패치됨.
        // ICC/EXIF/XMP는 그대로 보존(Orientation만 수정).
    } catch (const std::exception& e) {
        fprintf(stderr, "ERR: %s\n", e.what());
    }
}
```

**테스트 팁**

- **EXIF 확인**: `exiftool -Orientation -icc_profile -a -G output_fixed.jpg`  
- **색관리**: 모니터/뷰어에서 색이 바뀌지 않는지(ICC 유지 여부) 확인  
- **회전 재적용 방지**: 일부 뷰어(모바일/브라우저)는 Orientation을 또 적용하므로, 값이 **1** 인지 꼭 확인

---

## 5) (옵션) **무손실 경로** — jpegtran / transupp.h

> “픽셀 재인코드 없이 EXIF 회전만 반영하고 싶다” → **MCU 경계 기반 Lossless Transform**

- **아이디어**: 원본 JPEG의 DCT 블록을 **회전/반전/크롭**으로 **재배열** → 재압축 없음  
- **툴**: IJG의 `jpegtran` 또는 소스의 `transupp.h` 유틸  
- **제약**: MCU 경계 정렬 필요(4:2:0에서 16×16 등). 그렇지 않으면 **트리밍**이 발생할 수 있음

**절차 요약**

1) `jpeg_read_header` 로 입력 파악  
2) `jtransform_request_workspace()` 호출로 변환 워크스페이스 요청  
3) `jpeg_read_coefficients()` 로 DCT 계수 획득  
4) `jpeg_copy_critical_parameters()` 로 출력 준비  
5) `jtransform_execute_transformation()` 로 변환 실행  
6) `jpeg_write_coefficients()` 로 출력 저장  
7) 변환 완료 후 **EXIF Orientation = 1** 로 **패치**해서 `jpeg_write_marker()` 로 부착

> **장점**: 화질 손실 0, 속도 빠름  
> **단점**: 코드가 조금 복잡, MCU 트리밍 주의

---

## 6) 예외/엣지 케이스 다루기

- **APP1이 2개 이상**: EXIF(APP1, `"Exif\0\0"`) 와 **XMP(APP1)** 가 함께 있을 수 있다.  
  - 위 코드는 **둘 다 보존**한다.  
  - Orientation 패치는 **EXIF APP1만** 대상으로 한다.
- **Orientation 없음/비정상 값**: 보정 없이 통과(Orientation=0 또는 범위 외)  
- **EXIF 파싱 실패**: EXIF를 건드리지 않고 그대로 부착(보수적)  
- **큰 메타**: `jpeg_write_marker` 는 64KB 제한. ICC는 여러 APP2 세그먼트로 나뉘어 있음 → **원본 그대로 복사**하면 안전
- **색공간**: 입력이 YCbCr/CMYK 등일 수 있으나, 디코더가 `JCS_RGB` 로 뽑고 인코더가 다시 JPEG로 쓴다(손실 경로).  
  - CMYK JPEG은 **RGB로 재인코드** 시 색이 달라질 수 있다. CMYK 유지 필요 시 다른 경로 필요.

---

## 7) 품질·성능 팁

- **재인코드 품질**: `jpeg_set_quality(…, baselineLimit=TRUE)` 대신 `FALSE` 를 주면 프로그레시브/최신 디코더 품질에 유리  
- **허프만 최적화**: `cinfo.optimize_coding = TRUE` → 용량 다이어트  
- **멀티스레드**: libjpeg 자체는 스캔라인 단일 쓰레드. 파일 단위 병렬이 일반적  
- **색/감마**: 전처리(회전/합성 등)를 **선형광**에서 해야 하지만, 본 예제는 단순 회전/반전(밝기 불변)이라 sRGB 코드공간 연산으로 충분

---

## 8) 체크리스트

- [x] Orientation 보정 후 EXIF Orientation=**1**로 패치  
- [x] ICC/EXIF/XMP **보존** (민감 정보 제거 옵션을 별도 정책으로)  
- [x] (무손실 필요 시) jpegtran 경로 적용  
- [x] 폭탄 방지: 최대 해상도/마커 길이 상한, 예외 복구

---

## 9) 요약

- JPEG을 열 때 **`jpeg_save_markers(APP1/APP2)`** 로 **메타**를 꼭 잡고,  
- **EXIF Orientation** 을 읽어 **픽셀을 실제로 보정**한 뒤,  
- 저장 시 **EXIF/ICC를 재부착**하되 **Orientation은 1로 리셋**하면,  
- **어떤 뷰어/플랫폼에서도 올바른 방향**으로 보이며 **색관리 메타**도 유지된다.  
- 무손실이 업무 요건이면 **jpegtran(무손실 변환)** 을 우선 검토하자.
