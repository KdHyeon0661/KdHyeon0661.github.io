---
layout: post
title: DB 심화 - 페이지 처리의 중요성
date: 2025-11-01 21:25:23 +0900
category: DB 심화
---
# 페이지 처리의 중요성

> **한 줄 요약**
> 페이지 처리(pagination)는 **사용자 경험**의 문제이자 동시에 **성능·일관성**의 문제다.
> 잘못 설계하면 **매 페이지마다 테이블 대부분을 스캔**하고, **중복/누락**이 발생하며, **왕복(Fetch call)** 이 폭증한다.
> 올바른 해법은 **부분범위처리(Stopkey)** + **Keyset(커서 기반) 페이지네이션** + **적절한 Array Fetch** + **일관성 확보**다.

---

## 예제 데이터 & 인덱스 (공통)

```sql
DROP TABLE orders PURGE;
CREATE TABLE orders (
  order_id     NUMBER PRIMARY KEY,
  customer_id  NUMBER NOT NULL,
  created_at   DATE   NOT NULL,
  status       VARCHAR2(10) NOT NULL,
  amount       NUMBER(12,2) NOT NULL
);

-- 200만 건 샘플
INSERT /*+ APPEND */ INTO orders
SELECT level,
       MOD(level, 500000)+1,
       (TRUNC(SYSDATE) - MOD(level, 365)) + (MOD(level, 86400)/86400),
       CASE WHEN MOD(level, 9)=0 THEN 'CANCEL' ELSE 'OK' END,
       ROUND(DBMS_RANDOM.VALUE(10, 1000), 2)
FROM dual CONNECT BY level <= 2000000;
COMMIT;

-- 고객·시간순 목록용 인덱스(정렬 포함)
CREATE INDEX ix_orders_cust_time ON orders(customer_id, created_at DESC, order_id DESC);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'ORDERS', cascade=>TRUE);
END;
/
```

---

## 왜 “페이지 처리”가 중요한가?

### 성능 모델

페이지 **1장**을 얻는 비용을 단순화하면:

$$
\text{RT(page)} \approx \underbrace{\text{RTT} \times N_{\text{fetch calls}}}_{\text{왕복 비용}}
+ \underbrace{\text{CPU} + \text{I/O} + \text{Wait}}_{\text{한 페이지를 만들기 위해 DB가 하는 일}}
$$

- **OFFSET 기반**은 `OFFSET k`가 커질수록 **앞선 k행을 읽고 버림** → 매 페이지 **I/O 누적** 급증.
- **Keyset 기반**은 “**마지막으로 본 키 이후**”만 읽음 → **항상 상위 N만** 읽음(부분범위처리).
- **ArraySize(배열 페치)** 를 키우면 `N_fetch calls = ceil(rows / arraysize)`가 줄어 왕복 비용 감소.

### 사용자 경험 & 일관성

- **중복/누락 문제**: 페이지 이동 중 **새로운 데이터가 들어오면** OFFSET 방식은 앞쪽 오프셋이 밀려 **중복/누락**이 생긴다.
- **일관성(consistent read)**: 같은 시점의 스냅샷으로 페이지를 내보내야 결과가 안정적이다(특히 리포트/감사 화면).

---

## 페이지 기법 3가지 — 원리/장단점/용도

| 기법 | SQL 패턴 | 장점 | 단점 | 권장 용도 |
|---|---|---|---|---|
| **OFFSET-FETCH** | `ORDER BY ... OFFSET :skip ROWS FETCH NEXT :take ROWS ONLY` | 단순 | skip 커질수록 **앞부분 버려** 성능 저하, 동시성에 중복/누락 | 레코드 수 적고 정적 목록 |
| **Keyset(커서 기반)** | `WHERE (sort_key) < :last_key ORDER BY ... FETCH FIRST :take` | **항상 상위 N만** 읽음(Stopkey), 동시성 안정 | 첫 페이지 외엔 **마지막 키** 필요, 정렬 키 설계 필요 | **OLTP/무한스크롤/대규모 목록** |
| **RowID 기반 커서** | `WHERE ROWID > :last_rowid ORDER BY ROWID` (특정 상황) | 단순, 빠름 | 정렬/비즈니스 기준에 부적합 | 내부 도구, 보정 작업 |

> **핵심**: 트래픽이 많고 데이터가 큰 **OLTP**에선 **Keyset**이 기본값이어야 한다.

---

## OFFSET의 문제를 수식으로 보기

OFFSET `k` 페이지의 읽기량(개략):

$$
\text{I/O}(k) \approx \text{I/O to read first } (k + \text{take}) \text{ rows}
$$

- k가 커질수록 **거의 전체를 읽어야** 할 수 있고, **정렬(SORT)** 까지 겹치면 폭발한다.
- 반면 Keyset은 항상 **상위 take**만 읽으므로:

$$
\text{I/O}_{\text{keyset}} \approx \text{I/O to read top } \text{take rows}
$$

---

## Keyset(커서 기반) 페이지 처리 — 설계 원칙

1) **정렬 키가 단조 감소/증가**(시간·ID 등)하고 **유일성 보장**(tie-breaker)
2) **복합 인덱스**로 **필터 + 정렬**을 동시에 해결 (예: `(customer_id, created_at DESC, order_id DESC)`)
3) 다음 페이지는 **“마지막으로 본 키”**를 전달: `(last_created_at, last_order_id)`
4) **부분범위처리(Stopkey)** 가 자동 적용: `FETCH FIRST :take` or `ROWNUM <= :take`

### 첫 페이지 (최신순 20건)

```sql
SELECT /*+ index(o ix_orders_cust_time) */
       o.order_id, o.created_at, o.amount, o.status
FROM   orders o
WHERE  o.customer_id = :cust
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 20 ROWS ONLY;   -- STOPKEY
```

### 다음 페이지 (마지막 본 키 이후 20건)

```sql
SELECT /*+ index(o ix_orders_cust_time) */
       o.order_id, o.created_at, o.amount, o.status
FROM   orders o
WHERE  o.customer_id = :cust
  AND (o.created_at, o.order_id) < (:last_created_at, :last_order_id)
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 20 ROWS ONLY;   -- STOPKEY
```

- 인덱스가 잘 맞으면 실행계획은 **`INDEX RANGE SCAN` + `STOPKEY`** 형태가 된다.
- 필요한 컬럼이 인덱스에 모두 있으면(커버링) **테이블 BY ROWID 접근도 제거** 가능.

---

## “일관된 페이지”를 위한 스냅샷 전략

### 단일 요청 내 일관성: Oracle의 **Consistent Read**

SELECT는 기본적으로 **문장 단위 읽기 일관성**을 제공한다.
하지만 **여러 페이지 호출**을 서로 다른 시점에 하면, 사이에 데이터가 삽입/삭제되어 **중복/누락**이 생길 수 있다.

### 트랜잭션 단위 스냅샷

- **방법 A(간단)**: 같은 DB 세션에서 **트랜잭션을 열고** 모든 페이지 SELECT를 수행 → 같은 SCN
- **방법 B(명시)**: 첫 SELECT의 `ORA_ROWSCN` 또는 `CURRENT_SCN`을 저장, 이후 페이지를
  **Flashback Query**로 그 시점에 맞춰 읽기:

```sql
VAR scn NUMBER;
SELECT CURRENT_SCN INTO :scn FROM v$database;

-- 첫 페이지
SELECT /*+ index(o ix_orders_cust_time) */
       o.order_id, o.created_at, o.amount
FROM   orders AS OF SCN :scn
WHERE  customer_id=:cust
ORDER  BY created_at DESC, order_id DESC
FETCH FIRST 20 ROWS ONLY;

-- 다음 페이지도 동일 SCN 고정
SELECT /* 다음 페이지 */
       o.order_id, o.created_at, o.amount
FROM   orders AS OF SCN :scn
WHERE  customer_id=:cust
  AND (created_at, order_id) < (:last_created_at, :last_order_id)
ORDER  BY created_at DESC, order_id DESC
FETCH FIRST 20 ROWS ONLY;
```

> **주의**: Flashback AS OF는 **UNDO 보존**에 의존한다. 리포팅/감사 페이지처럼 **강한 일관성**이 필요한 화면에만 적용.

---

## 부분범위처리(Stopkey)와 인덱스 설계

### 무엇이 Stopkey를 가능하게 하나?

- **WHERE + ORDER BY** 를 **하나의 복합 인덱스**로 처리
- 정렬 방향(DESC/ASC)과 인덱스 방향이 **일치**
- **커버링 인덱스**면 더 좋음

### 설계 레시피

- 고객별 최신순: `(customer_id, created_at DESC, order_id DESC)`
- 테넌트별 최신 이벤트: `(tenant_id, created_at DESC, id DESC)`
- 카테고리 + 가격순: `(category_id, price ASC, id ASC)`
- **tie-breaker**(동점 해소)로 **PK(id)** 를 항상 마지막에 넣어 **완전한 순서를 보장**.

---

## OFFSET → Keyset 전환 전/후 비교 (절차)

1) **기존 쿼리**와 **개선 쿼리**를 동일 조건으로 실행
2) TKPROF/Trace로 다음 비교
   - `call` 표의 **Fetch count**(개선후 급감)
   - **Elapsed**(특히 Execute/Fetch)
   - `consistent gets`/`physical reads`(PRP가 있으면 감소)
   - 하단 **대기 이벤트**(정렬/디스크 I/O/SQL*Net) 변화

---

## 클라이언트 코드 — 페치 왕복 최소화(배열 페치)

> Keyset으로 **읽을 양을 줄이고**, Array Fetch로 **왕복을 줄여라** — 두 축이 함께여야 완성.

### JDBC (Oracle JDBC Thin)

```java
String firstPageSql = """
SELECT order_id, created_at, amount, status
FROM   orders
WHERE  customer_id = ?
ORDER  BY created_at DESC, order_id DESC
FETCH FIRST ? ROWS ONLY
""";

try (PreparedStatement ps = conn.prepareStatement(firstPageSql)) {
  ps.setInt(1, custId);
  ps.setInt(2, pageSize);
  ps.setFetchSize(Math.max(pageSize, 1000));  // 일반 조회: 500~2000 권장
  try (ResultSet rs = ps.executeQuery()) {
    long lastId = 0; Timestamp lastTs = null;
    while (rs.next()) { /* consume */ lastId = rs.getLong(1); lastTs = rs.getTimestamp(2); }
    // lastTs/lastId를 다음 페이지 파라미터로 사용
  }
}
```

**다음 페이지**
```java
String nextPageSql = """
SELECT order_id, created_at, amount, status
FROM   orders
WHERE  customer_id = ?
AND   (created_at, order_id) < (?, ?)
ORDER  BY created_at DESC, order_id DESC
FETCH FIRST ? ROWS ONLY
""";
```

- **Statement Cache** 활성 + **바인드 변수** 사용 → Parse 비용 최소화.

### ODP.NET (C#)

```csharp
using var cmd = new OracleCommand(@"
  SELECT order_id, created_at, amount, status
  FROM orders
  WHERE customer_id = :cust
  ORDER BY created_at DESC, order_id DESC
  FETCH FIRST :take ROWS ONLY", conn);
cmd.Parameters.Add(":cust", OracleDbType.Int32).Value = custId;
cmd.Parameters.Add(":take", OracleDbType.Int32).Value = pageSize;
cmd.FetchSize = 8 * 1024 * 1024; // 바이트 기준(행당 크기 감안 4~16MB)
using var rdr = cmd.ExecuteReader();
while (rdr.Read()) { /* ... */ }
```

### Python (python-oracledb)

```python
cur.arraysize = max(page_size, 1000)
cur.execute("""
  SELECT order_id, created_at, amount, status
  FROM   orders
  WHERE  customer_id = :cust
  ORDER  BY created_at DESC, order_id DESC
  FETCH FIRST :take ROWS ONLY
""", cust=cust_id, take=page_size)
rows = cur.fetchall()
last_id = rows[-1][0]; last_ts = rows[-1][1]
```

### Node.js (node-oracledb)

```js
const result = await connection.execute(
  `
  SELECT order_id, created_at, amount, status
  FROM orders
  WHERE customer_id = :cust
  ORDER BY created_at DESC, order_id DESC
  FETCH FIRST :take ROWS ONLY
  `,
  { cust: 12345, take: 50 },
  { prefetchRows: 500, fetchArraySize: 2000 }
);
```

---

## “총 개수”를 어떻게 보여줄까? (Count 전략)

- **정확 카운트**: `SELECT COUNT(*) ...` 는 큰 테이블에서 비용이 큼.
- **근사치/비동기**:
  - 첫 페이지엔 “**5000+**”처럼 근사치(통계/샘플) 표시
  - 정확한 카운트는 **백그라운드로 계산**해 결과에 반영(다음 요청 때 갱신)
- **파티션/필터**: 카운트가 필수면 **파티션 프루닝/요약 테이블**을 활용.

---

## 동시성·중복/누락 문제 해결

1) **Keyset**은 기본적으로 중복/누락에 강함. 단, **tie-breaker**(id) 필수.
2) **일관성 고정**이 필요한 화면은 **AS OF SCN**으로 스냅샷 묶기(UNDO 보존 고려).
3) 동일 조건·정렬을 **항상 동일하게**(세션 NLS/Collation/NULLS FIRST|LAST 주의).
4) **페이지 크기와 캐시**: 프론트에서 **앞/뒤 1~2페이지 캐시**해 작은 뒤로가기/앞으로가기에 DB 왕복을 줄임.

---

## 안티 패턴 → 교정

| 안티 패턴 | 증상 | 교정 |
|---|---|---|
| `OFFSET :skip FETCH :take` 대규모 데이터 | 페이지 높아질수록 **기하급수적 지연** | **Keyset** 전환 + 인덱스 설계 |
| 정렬 컬럼 인덱스 미포함 | **SORT + FULL SCAN** → Stopkey 무효 | **필터+정렬 복합 인덱스** |
| tie-breaker 없음 | 동점에서 **순서 불안정** → 중복/누락 | 정렬의 마지막에 **PK 추가** |
| ArraySize 기본값(작음) | **Fetch call 과다**(왕복 폭증) | `setFetchSize/arraysize` 상향 |
| 전 컬럼 SELECT | I/O·네트워크·GC 과다 | **보여줄 컬럼만** 선택(커버링 검토) |

---

## 실전 튜닝 시나리오 (OLTP API)

**문제**
- 고객 주문 목록 API `/customers/{id}/orders?page=N&size=50`
- 기존: `OFFSET (N*50) FETCH 50` + 정렬 인덱스 없음 + fetchSize=50
- p95=1.6s, p99=4.8s

**개선**
1) 인덱스 `(customer_id, created_at DESC, order_id DESC)`
2) **Keyset**으로 변경
3) JDBC `setFetchSize(1000)`
4) 노출 컬럼 최소화(커버링 후보 검토)

**검증(TKPROF 요지)**
- Fetch count: **22 → 1~2**
- Execute Elapsed: 정렬/스캔 감소로 **대폭 하락**
- 전체 응답: **~1.6s → ~110ms**

---

## 페이지 처리의 보조 기술

- **부분범위처리(Stopkey)**: `FETCH FIRST N ROWS ONLY` 또는 `ROWNUM <= N`
- **Keyset 튜플 비교**: `(created_at, order_id) < (:last_ts, :last_id)`
- **세션 커서 캐시/Statement Cache**: 페이지 호출이 빈번하니 파싱 최소화
- **Prefetch/FetchSize**: 드라이버별 옵션 적극 활용
- **Keyset + 필터 변경**: 필터 바뀌면 **첫 페이지**부터 다시 (last_key 무효화)

---

## 체크리스트 (운영 투입 전)

- [ ] OFFSET 대신 **Keyset** 사용(가능하면 무조건)
- [ ] **필터 + 정렬**을 만족하는 **복합 인덱스** 설계(마지막에 PK tie-breaker)
- [ ] **부분범위처리**가 실제 계획에 적용되는지 확인(`STOPKEY`)
- [ ] **Array Fetch** 크기 조정(JDBC fetchSize, ODP.NET FetchSize, Python arraysize, Node prefetch/fetchArraySize)
- [ ] 필요 컬럼만 SELECT(가능하면 **커버링**)
- [ ] 일관성 요구 시 **AS OF SCN** 또는 **트랜잭션 스냅샷**
- [ ] TKPROF/Trace로 **Fetch count/Elapsed** 전후 비교

---

## 결론

- 페이지 처리는 **UX**를 넘어 **DB 성능과 안정성**의 핵심이다.
- **Keyset(커서 기반)** 으로 **항상 상위 N만** 읽고, **부분범위처리(Stopkey)** 로 **I/O 자체를 줄이며**,
  **Array Fetch** 로 **왕복 횟수**를 줄이면, 대규모 OLTP에서도 **빠르고 안정적인** 페이지를 제공할 수 있다.
- 정렬·필터와 인덱스가 맞물려야 성능이 나온다. 올바른 설계 + 측정(TKPROF/AWR) = **페이지 처리의 정석**.
