---
layout: post
title: 컴퓨터시스템 - 주소의 번역
date: 2025-08-24 14:20:23 +0900
category: 컴퓨터시스템
---
# 주소의 번역(Address Translation) — 가상 주소에서 물리 주소까지, 한 줄 한 줄 뜯어보기

> 목표: **프로세스가 사용하는 가상 주소(VA)**가 **DRAM의 물리 주소(PA)**로 바뀌는 과정을  
> 하드웨어(MMU·TLB)와 운영체제(페이지 테이블·예외 처리) 관점에서 **정확하고 실전적으로** 이해하기.

---

## 1) 한눈에 보는 큰 그림

프로그램은 **가상 주소(virtual address)** 로 메모리에 접근합니다.  
CPU의 **MMU**가 **페이지 테이블**을 참조해 VA→PA로 변환하고, 결과를 **TLB**에 캐싱합니다.

```
Load/Store (VA) ──► TLB 히트? ──► O: PA 사용
                    │
                    └─► X: Page Walk (페이지 테이블 탐색)
                            │
                            ├─ 합법 매핑: 변환 결과 TLB에 적재 후 접근 재시도
                            └─ 불법/미매핑: 페이지 폴트(커널로 트랩 → 처리 or SIGSEGV)
```

---

## 2) 페이징(paging) 기본: 주소 비트 분해

가상 주소는 다음처럼 나뉩니다(페이지 크기 4KB 가정).

\[
\text{VA} = \underbrace{\text{VPN}}_{\text{상위 비트}} \,\|\, \underbrace{\text{Offset}}_{\text{하위 12비트}}
\quad\Rightarrow\quad
\text{PA} = \underbrace{\text{PFN}}_{\text{프레임 번호}} \,\|\, \text{Offset}
\]

- **Offset**: 페이지 내부 바이트 위치(4KB ⇒ 12비트)
- **VPN → PFN**: 페이지 테이블이 결정
- **보호 비트**: PTE에 R/W/X, U/S, A/D 등 권한·상태가 함께 기록

---

## 3) x86-64의 4단(또는 5단) 페이지 테이블

### 3.1 비트 배치(4KB 페이지, 48비트 canonical VA)
```
VA[47:39] = PML4 인덱스 (9b)
VA[38:30] = PDPT 인덱스 (9b)
VA[29:21] = PD   인덱스 (9b)
VA[20:12] = PT   인덱스 (9b)
VA[11: 0] = 오프셋 (12b)
```

- 상위 비트(>47)는 **sign-extension** 규칙으로 48비트 주소공간을 형성(최신 확장에선 57비트까지도 가능).
- **Huge Page**:
  - 2MB: PT 없이 PD 엔트리에서 종결
  - 1GB: PDPT 엔트리에서 종결

### 3.2 단계별 탐색(페이지 워크)
1. CR3가 가리키는 **루트(PML4)** 의 베이스 물리주소 획득  
2. PML4[VA[47:39]] → 엔트리 검사(Present/권한 비트)  
3. PDPT[VA[38:30]] → 검사(1GB 페이지면 여기서 종료)  
4. PD  [VA[29:21]] → 검사(2MB 페이지면 여기서 종료)  
5. PT  [VA[20:12]] → PTE에서 **PFN** 획득  
6. 최종 PA = PFN‖Offset

### 3.3 PTE의 대표 비트(x86-64)
| 비트 | 의미 |
|-----|------|
| P   | Present (존재 여부) |
| RW  | Read/Write |
| US  | User/Supervisor (사용자 접근 허용 여부) |
| PWT/PCD | 캐시 정책 |
| A/D | Accessed/Dirty (접근/수정 추적) |
| G   | Global (컨텍스트 전환 시 flush 생략 힌트) |
| NX  | eXecute Disable (실행 금지) |

---

## 4) 예제로 보는 비트 인덱싱(4KB 페이지)

**VA = `0x0000_7f12_3456_789a`** 일 때:

- Offset = **0x89a**
- PT index = **0x167** (359)
- PD index = **0x1a2** (418)
- PDPT index = **0x48** (72)
- PML4 index = **0xfe** (254)

이 인덱스들로 각 레벨 엔트리를 차례로 따라가며 **PFN**을 찾아,  
**PA = PFN‖0x89a** 로 최종 번역합니다.

> 실무 팁: 리눅스에서는 `/proc/<pid>/pagemap` 으로 VA→PFN(물리 프레임 번호)을 확인할 수 있습니다(최신 배포판은 root 한정).

---

## 5) TLB(Translation Lookaside Buffer): 번역 결과의 캐시

- **I-TLB**(명령), **D-TLB**(데이터), 그리고 공유/2차 TLB 등 다단 구조
- **TLB 미스** 시 하드웨어 **페이지 워크** 발생 → 수십~수백 사이클 오버헤드
- 성능 핵심:
  - **지역성** 높은 접근 패턴 유지
  - **Huge Page(2MB/1GB)** 로 TLB 커버리지 확대
  - 컨텍스트 전환 시 **TLB shootdown/flush** 비용 최소화(PCID/ASID 활용)

### 5.1 PCID/ASID로 컨텍스트 전환 최적화
- **x86 PCID**: CR3 하위 태그로 TLB 엔트리 구분 → 완전 flush 없이 주소공간 전환
- **ARM ASID**: TLB 엔트리에 주소공간 ID를 부여해 유사 효과

---

## 6) 보호와 예외: 페이지 폴트의 의미론

번역 중 다음 조건이면 **페이지 폴트**:
- 매핑 없음(미할당/스왑아웃) → **수요 페이징**으로 채워넣을 수 있음
- 권한 위반(R/W/X) → **보호 오류** (보통 `SIGSEGV`)
- **COW**(Copy-On-Write) 페이지에 쓰기 시도 → **프레임 복사** 후 쓰기 허용

OS는 폴트 원인·주소·권한을 판별해:
1) 합법적이면(예: demand paging, COW) PTE를 갱신하고 재시도  
2) 불법이라면 프로세스에 시그널(`SIGSEGV` 등) 전달

---

## 7) 캐시와 번역의 상호작용(VIPT·동기화)

- L1 D-Cache는 **VIPT(Virtually Indexed, Physically Tagged)** 가 일반적  
- **에일리어스(alias)**: 같은 물리 페이지가 서로 다른 VA로 매핑될 때 캐시 라인 중복 가능  
  → OS가 **색상(coloring)**, **동기화**로 문제 방지  
- L2/L3는 보통 **PIPT**(Physically Indexed, Physically Tagged)로 안전

---

## 8) ARM64(AArch64) 개요

- 페이지 크기 4/16/64KB, 4~5레벨 테이블
- **TTBR0/TTBR1**: 사용자/커널 주소공간 베이스
- 권한 비트: **AP**(접근권한), **PXN/UXN**(Privileged/User eXecute-Never)
- **대형 페이지**: 2MB/1GB 유사 개념(컨피그에 따라 다름)

---

## 9) 가상화까지 가면? (2단계 번역: EPT/NPT)

하이퍼바이저 환경에서는 번역이 **두 단계**입니다:

```
Guest VA --(게스트 페이지 테이블)--> Guest PA
         --(EPT/NPT: 호스트가 관리)--> Host PA(실제 DRAM)
```

- 두 번의 변환으로 TLB 압박 ↑ → **Nested/combined TLB**, **Huge EPT** 로 완화
- 보안/격리 측면에서 장치 접근은 **IOMMU**(장치용 MMU)로 별도 번역 수행

---

## 10) 캐시 정책과 메모리 유형(PAT/PCD/PWT)

- x86 PTE의 **PWT/PCD**와 **PAT**(Page Attribute Table)로 메모리 유형을 결정  
  (Write-back/Write-through/Uncacheable 등)
- **MMIO**(장치 레지스터 맵)는 보통 **비캐시(UC)** 로 매핑해야 함
- 잘못된 캐시 속성은 데이터 손상·성능 저하 유발 → 드라이버 영역의 핵심 포인트

---

## 11) 번역이 바뀔 때 해야 할 일: TLB shootdown

- `mmap/mprotect/munmap` 등으로 PTE가 바뀌면 **해당 VA 범위의 TLB 무효화** 필요
- SMP에선 모든 코어에 **IPI(Inter-Processor Interrupt)** 로 shootdown 브로드캐스트
- 잦은 shootdown은 고비용 → **배치(batch)**·**지연(defer)**·**대역 단위** 최적화

---

## 12) 사용자 공간에서 번역 관찰(리눅스)

### 12.1 현재 프로세스의 매핑
```bash
cat /proc/$$/maps | head
cat /proc/$$/smaps | less
```

### 12.2 VA→PFN 대략 보기(루트 필요 가능)
```c
// /proc/self/pagemap 를 읽어 PFN/플래그 확인(요약 예시)
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>

int main() {
    size_t ps = sysconf(_SC_PAGESIZE);
    char *p = mmap(NULL, ps, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    p[0] = 1; // 실제 할당 유도(demand paging)
    int fd = open("/proc/self/pagemap", O_RDONLY);
    uint64_t entry;
    off_t off = ((uintptr_t)p / ps) * 8; // 페이지당 8바이트 엔트리
    pread(fd, &entry, 8, off);
    printf("present=%lld, pfn=%llx\n",
           (long long)((entry >> 63) & 1),
           (long long)(entry & ((1ULL<<55)-1)));
    munmap(p, ps);
    close(fd);
}
```

---

## 13) 성능 팁(요약)

- **TLB 미스 줄이기**: 순차/군집 접근, **데이터 구조 군집화**, **Huge Page**
- **COW의 비용 관리**: 초기에는 이득, 이후 쓰기 폭주 시 프레임 복사 비용↑
- **NUMA**: **first-touch** 정책으로 로컬 노드에 프레임 할당, `numactl`로 바인딩

---

## 14) 보안과 번역

- **NX/UXN/PXN**: 데이터 실행 금지 → 코드 인젝션 방어
- **SMEP/SMAP**(x86): 커널이 사용자 공간 코드 실행/접근 제한
- **KASLR/ASLR**: 주소 배치 무작위화로 ROP·info leak 난이도 상승
- **W^X**: 같은 페이지에 Write와 eXecute를 동시에 주지 않기

---

## 15) 체크리스트(개발·디버깅 관점)

- [ ] 성능이상? ⇒ **TLB 미스/페이지 폴트 통계**부터 확인(perf, `vmstat`, `perf stat -e dTLB-load-misses` 등)  
- [ ] 권한 오류? ⇒ `mprotect` 상태/권한 비트 확인(실행 금지/NX 포함)  
- [ ] 잦은 매핑 변경? ⇒ TLB shootdown 비용 고려, 변경을 **배치**  
- [ ] MMIO 매핑? ⇒ **캐시 속성** 재확인(PAT/PCD/PWT)  
- [ ] 가상화/장치? ⇒ **EPT/IOMMU** 경로까지 시야 확장

---

## 16) 한 줄 결론

**주소 번역**은 “**TLB(빠른 길)** ↔ **페이지 워크(느린 길)**” 사이를 오가며,  
**페이지 테이블의 권한 비트**가 보안·안정성을, **TLB/huge page/PCID**가 성능을 좌우합니다.  
이 흐름을 이해하면, 메모리 버그 디버깅부터 성능 튜닝·보안 강화까지 **메모리 관련 문제를 체계적으로 다룰 수 있습니다**.