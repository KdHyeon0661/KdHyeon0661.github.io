---
layout: post
title: 컴퓨터시스템 - 주소의 번역
date: 2025-08-24 14:20:23 +0900
category: 컴퓨터시스템
---
# 주소의 번역(Address Translation)

## 0. 큰 그림 한 장

프로그램은 **가상 주소(VA)** 로 로드/스토어를 수행하고, CPU의 **MMU**가 **페이지 테이블**을 참조하여 **물리 주소(PA)** 로 변환한다. 변환 결과는 **TLB**에 캐시되어 반복 비용을 줄인다.

```
Load/Store( VA ) ──► TLB hit? ──► O: 즉시 PA 사용
                     │
                     └─► X: Hardware Page Walk (페이지 테이블 단계 탐색)
                               │
                               ├─ 합법 매핑: 변환 결과를 TLB에 적재 → 접근 재시도
                               └─ 불법/미매핑: Page Fault → 커널 트랩(수요페이징/권한검사/신호 전달)
```

---

## 1. 페이징 기초: 비트 분해(4KB 페이지의 정석)

$$
\text{VA} = \underbrace{\text{VPN}}_{\text{상위 비트}} \parallel \underbrace{\text{Offset}}_{\text{하위 } \log_2{\text{PageSize}}}
\quad\Rightarrow\quad
\text{PA} = \underbrace{\text{PFN}}_{\text{프레임 번호}} \parallel \text{Offset}
$$

- 4 KB 페이지라면 **Offset = 12b**.
- **VPN → PFN** 매핑은 **페이지 테이블**(PTE)에 들어 있고, **권한(R/W/X, U/S)**, **상태(A/D)** 등이 함께 기록된다.

---

## 2. x86-64: 4단/5단(4KB 페이지) **정밀 비트 배치**

### 2.1 4단(48-bit canonical VA, 일반적)
```
VA[47:39] = PML4 index (9b)
VA[38:30] = PDPT index (9b)
VA[29:21] = PD   index (9b)
VA[20:12] = PT   index (9b)
VA[11: 0] = Offset (12b)
```

- 상위 비트는 **sign-extension** 규칙(48b 주소 공간).
- **Huge Page**
  - 1 GB: PDPT 엔트리(PDPTE)의 PS 비트로 종결 (PT/PD 미사용)
  - 2 MB: PD 엔트리(PDE)의 PS 비트로 종결 (PT 미사용)

### 2.2 5단(LA57, 57-bit VA 지원 시)
```
VA[56:48] = PML5 index (9b)
그 아래는 동일(… PML4, PDPT, PD, PT, Offset)
```
커널이 5단을 사용하면 사용자/커널 공간 배치가 넓어진다(플랫폼/커널 설정 의존).

### 2.3 x86-64 PTE 대표 비트
| 비트 | 의미 | 메모 |
|---|---|---|
| P   | Present | 0이면 미매핑/스왑/예약(폴트) |
| RW  | Read/Write | 0이면 read-only |
| US  | User/Supervisor | 0이면 U모드 접근 금지 |
| PWT/PCD | Page Write-Through / Cache Disable | 캐시 정책(PAT와 조합) |
| A/D | Accessed / Dirty | HW가 접근/수정 시 설정 |
| G   | Global | CR3 변경시 flush 생략(PCID와 함께 효과↑) |
| NX  | eXecute Disable | 코드 실행 금지(W^X 정책 기반) |

---

## 3. “한 줄 한 줄” 예제: **실제 VA를 비트로 쪼개보기**

가정: 4KB 페이지, 4단 테이블, VA = `0x0000_7f12_3456_789a`

- **Offset** = 하위 12b = `0x89a`
- **PT index** = VA[20:12] = `0x167` (10진 359)
- **PD index** = VA[29:21] = `0x1a2` (418)
- **PDPT index** = VA[38:30] = `0x048` (72)
- **PML4 index** = VA[47:39] = `0x0fe` (254)

이제 하드웨어는 다음 **페이지 워크**를 수행한다:

1. **CR3** 레지스터에서 PML4 테이블의 **물리 베이스**를 얻음
2. 물리주소(PML4_base + 8×254)에서 **PML4E** 로드 → Present? 권한 OK?
3. PML4E가 가리키는 PDPT_base + 8×72 → **PDPTE** 검사(1 GB 페이지면 여기서 PFN 확정)
4. PDPTE가 가리키는 PD_base + 8×418 → **PDE** 검사(2 MB 페이지면 여기서 PFN 확정)
5. PDE가 가리키는 PT_base + 8×359 → **PTE**에서 **PFN** 획득
6. **PA = PFN ‖ 0x89a**

그 결과는 **TLB**에 캐시되어 이후 동일 페이지 접근은 빠르게 처리된다.

> **관찰 팁**: 리눅스에서 `/proc/<pid>/pagemap`을 읽어 **현재 VA의 PFN**을 확인할 수 있다(최근 배포판 다수에서 root 권한 필요). 아래 예제 제공.

---

## 4. C 코드: `/proc/self/pagemap`으로 **VA→PFN** 대략 보기

```c
// pagemap_demo.c : VA 하나를 매핑하고 PFN/Present 비트 확인
#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>

int main() {
    size_t ps = (size_t)sysconf(_SC_PAGESIZE);
    char *p = mmap(NULL, ps, PROT_READ|PROT_WRITE,
                   MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    p[0] = 42; // demand paging 유도(메이저/마이너 상황은 시스템 상태에 의존)
    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd < 0) { perror("open pagemap"); return 1; }

    uint64_t entry;
    off_t off = ((uintptr_t)p / ps) * 8; // 페이지당 8바이트 엔트리
    if (pread(fd, &entry, 8, off) != 8) { perror("pread"); return 1; }

    int present = (entry >> 63) & 1;
    uint64_t pfn = entry & ((1ULL<<55) - 1);
    printf("VA=%p present=%d PFN=0x%llx\n", p, present, (unsigned long long)pfn);

    munmap(p, ps);
    close(fd);
    return 0;
}
```

```bash
gcc -O2 pagemap_demo.c -o pagemap_demo
sudo ./pagemap_demo
```

---

## 5. TLB(Translation Lookaside Buffer): **번역의 캐시**

- **I-TLB/D-TLB/STLB**(2차) 등 다단. **미스** 시 하드웨어 **페이지 워크** 비용이 수십~수백 사이클.
- **성능 핵심**
  1) **지역성** 좋은 접근(순차/블록)
  2) **Huge Page(2MB/1GB)** 로 TLB 커버리지(Reach) 키우기
  3) **컨텍스트 전환 비용** 최소화: **PCID(x86)** / **ASID(ARM)**

### 5.1 PCID/ASID 한 줄 정리
- **PCID(x86)**: CR3 하위 태그로 주소공간 식별 → **TLB flush 없이 전환** 가능(보안 설정과 함께 동작).
- **ASID(ARM)**: TLB 엔트리에 주소공간 ID 포함 → 유사 효과.

---

## 6. 보호와 예외: **페이지 폴트**의 해석

다음 상황에서 폴트가 난다:

- PTE **Present=0**(미매핑/스왑아웃) → **수요 페이징**으로 프레임 준비 가능
- **권한 위반**(User/Supervisor, RW, NX 등) → **보호 오류** → 보통 `SIGSEGV`
- **COW** 페이지에 **쓰기** → 프레임 복사 후 쓰기 허용

리눅스 커널은 원인/주소/권한을 보고:
(1) 합법(수요 페이징/COW)이면 PTE 갱신 후 명령 재시도
(2) 불법이면 **시그널** 전달

### 6.1 **권한 위반 실험**: `mprotect`로 강제 SIGSEGV
```c
// segv_demo.c : RW 페이지를 R-Only로 바꾼 후 쓰기 → SIGSEGV
#define _GNU_SOURCE
#include <stdio.h>
#include <signal.h>
#include <ucontext.h>
#include <sys/mman.h>
#include <unistd.h>

static void on_segv(int sig, siginfo_t* si, void* ctx){
    (void)ctx;
    printf("SIGSEGV @ %p (si_code=%d)\n", si->si_addr, si->si_code);
    _exit(0);
}

int main(){
    size_t ps = (size_t)sysconf(_SC_PAGESIZE);
    char* p = mmap(NULL, ps, PROT_READ|PROT_WRITE,
                   MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    struct sigaction sa = {.sa_sigaction=on_segv, .sa_flags=SA_SIGINFO};
    sigaction(SIGSEGV, &sa, NULL);

    mprotect(p, ps, PROT_READ); // 쓰기 금지
    p[0] = 1;                   // 여기서 SIGSEGV
    return 0;
}
```

---

## 7. 리눅스 용어의 매핑: PGD/P4D/PUD/PMD/PTE

- 커널은 내부적으로 5단을 일반화: **PGD → P4D → PUD → PMD → PTE** 이름 체계.
- 4단일 경우 일부 단계가 **folded(접힘)** 되어 동일 주소를 가리킨다.
- Huge Page:
  - **PMD 엔트리**(=x86의 PDE)에서 2MB,
  - **PUD 엔트리**(=x86의 PDPTE)에서 1GB.

---

## 8. Huge Page 시의 비트 분해(2MB/1GB)

### 8.1 2MB 페이지(PS=1 in PDE)
```
VA[47:39]=PML4, [38:30]=PDPT, [29:21]=PD, [20:0]=Offset(2MB 내)
```
- PT 수준은 생략. **Offset 폭 = 21b**.

### 8.2 1GB 페이지(PS=1 in PDPTE)
```
VA[47:39]=PML4, [38:30]=PDPT, [29:0]=Offset(1GB 내)
```
- PD/PT 생략. **Offset 폭 = 30b**.

**효과**: 동일 TLB 엔트리 하나가 커버하는 바이트가 **크게 증가** → TLB 미스 급감(워크로드에 따라 체감 큼).

---

## 9. 캐시와 번역의 맞물림: VIPT·Synonym 문제

- L1 D-Cache는 보통 **VIPT**(virtually indexed, physically tagged).
- **Synonym(동의어)**: 동일 **PA**가 서로 다른 **VA**로 맵핑되면, 인덱스가 달라 **라인 중복** 가능 → 캐시 일관성/성능 문제.
- OS는 **페이지 컬러링**/매핑 제약/동기화로 이를 방지한다(사용자 레벨에선 일반적으로 신경 쓸 일 적음).

---

## 10. ARM64(AArch64) 속성 한 장 요약

- 페이지 크기: **4/16/64KB**(플랫폼 설정).
- **TTBR0/TTBR1**: 사용자/커널 주소공간 베이스.
- 권한: **AP(Access Permission)**, **PXN/UXN**(Privileged/User eXecute-Never).
- ASID 기반 TLB 분리, 대형 페이지(예: 2MB/1GB 유사 컨셉) 지원.

---

## 11. 가상화: **2단계 번역**(EPT/NPT)

```
Guest VA --(게스트 PT)--> Guest PA
         --(호스트 EPT/NPT)--> Host PA(실제 DRAM)
```

- TLB 압박↑ → **Nested/Combined TLB**, **Huge EPT** 등으로 완화.
- **IOMMU**는 **디바이스 DMA**를 위한 번역 계층(보안 격리) 제공.

---

## 12. TLB Shootdown: PTE가 바뀔 때의 **전파 비용**

- `mmap/mprotect/munmap` 등으로 **PTE 변경** 시 해당 VA 범위 **TLB 무효화** 필요.
- **SMP**에선 다른 코어에 **IPI**로 shootdown 브로드캐스트.
- 비용 ↓ 전략: **배치(batch)**, **지연(defer)**, **큰단위 인벌리드**, **PCID/ASID** 활용.

---

## 13. 관찰/계측 무기고(리눅스)

### 13.1 퍼포먼스 카운터
```bash
# TLB, 캐시, 폴트 측정(예시):
perf stat -e cycles,instructions,cache-references,cache-misses \
           -e dTLB-loads,dTLB-load-misses \
           -e iTLB-loads,iTLB-load-misses \
           -e page-faults,major-faults \
           ./your_app
```

### 13.2 매핑/상주/NUMA/THP
```bash
cat /proc/$$/maps | head
cat /proc/$$/smaps | less          # Private_Dirty/AnonHugePages 등
numastat -p <pid>
cat /sys/kernel/mm/transparent_hugepage/enabled
```

### 13.3 bpftrace 예시
```bash
# 유저 페이지 폴트 상위 커맨드
bpftrace -e 'tracepoint:exceptions:page_fault_user { @[comm] = count(); }'
```

---

## 14. 실습: **TLB 미스 유발 vs Huge Page 완화**(마이크로벤치)

```c
// stride_tlb.c : 워킹셋/스트라이드를 조절해 dTLB-load-misses 변화를 본다
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <x86intrin.h>
#include <sched.h>
#include <string.h>
#include <unistd.h>

static inline uint64_t rdtsc(){ unsigned a,d; asm volatile("rdtsc":"=a"(a),"=d"(d)); return ((uint64_t)d<<32)|a; }
static void pin(int c){ cpu_set_t s; CPU_ZERO(&s); CPU_SET(c,&s); sched_setaffinity(0,sizeof(s),&s); }

int main(int argc,char**argv){
  size_t bytes  = (argc>1)? strtoull(argv[1],0,0) : (size_t)256<<20; // 256MB
  size_t stride = (argc>2)? strtoull(argv[2],0,0) : 4096;            // 4KB
  int core      = (argc>3)? atoi(argv[3]) : 0;
  pin(core);
  uint64_t *a; posix_memalign((void**)&a, 4096, bytes);
  size_t n = bytes/sizeof(uint64_t), step = stride/sizeof(uint64_t);
  for(size_t i=0;i<n;i++) a[i]=i;

  volatile uint64_t s=0;
  uint64_t t0=rdtsc();
  for(int r=0;r<8;r++) for(size_t i=0;i<n;i+=step) s += a[i];
  uint64_t t1=rdtsc();
  printf("bytes=%zu stride=%zu cycles/op=%.2f sum=%llu\n",
         bytes,stride,(double)(t1-t0)/(8.0*(n/step)),(unsigned long long)s);
  free((void*)a);
}
```

```bash
gcc -O2 stride_tlb.c -o stride_tlb
perf stat -e dTLB-load-misses ./stride_tlb $((256<<20)) 4096
# 이후 THP를 활성화(또는 hugepage로 재할당)하고 다시 측정해 비교
```

---

## 15. 수학/공식 몇 줄

### 15.1 **TLB Reach**
$$
\text{Reach} \approx N_{4K}\cdot 4\text{KB} + N_{2M}\cdot 2\text{MB} + N_{1G}\cdot 1\text{GB}
$$
- 워킹셋 크기가 Reach 이하라면 페이지워크 빈도가 크게 줄어든다.

### 15.2 평균 접근 시간(개략)
$$
T_{\text{access}} \approx h_{\text{TLB}} t_{\text{TLB}} + (1-h_{\text{TLB}}) t_{\text{walk}}
+ \Big(h_1 t_1 + (1-h_1)(h_2 t_2 + (1-h_2)(h_3 t_3 + (1-h_3)t_{\text{mem}}))\Big)
$$

---

## 16. 케이스 스터디: **COW와 쓰기 폭주**

- 서버에서 **fork + exec** 대신 **fork 후 일부만 쓰기**하는 패턴은 **COW 페이지 복사**가 대량 발생 가능 → 지연 스파이크.
- 해결: **빠른 exec** 경로, **프리포크 풀**, **초기화/쓰기 시점 재조정**, **대페이지 정책** 재검토.

---

## 17. 보안과 번역의 교차점

- **NX/UXN/PXN**: 데이터 페이지 실행 금지(코드 인젝션 방어).
- **SMEP/SMAP(x86)**: 커널이 사용자 공간 코드 실행/접근 제한.
- **ASLR/KASLR**: 주소 배치 무작위화 → ROP/정보유출 난이도 상승.
- **W^X**: 같은 페이지에 Write·Execute 동시 금지(정책 위배 시 위험).

---

## 18. 체크리스트(성능·디버깅)

- [ ] **TLB 미스/페이지 폴트**를 먼저 확인(perf, vmstat, major-faults)
- [ ] **Huge Page(2MB/1GB)** 사용 전략 수립(THP `always/advise/never` 조정)
- [ ] **NUMA**: first-touch 보장, 스레드/메모리 바인딩(`numactl`, affinity)
- [ ] **TLB shootdown** 빈도 제어(매핑 변경을 **배치**)
- [ ] **권한 문제**: NX/RW/US 비트와 `mprotect` 상태 확인
- [ ] **가상화/디바이스**: EPT/IOMMU 경로 포함해 원인 추적

---

## 19. 부록 A — 비트 마스크로 **인덱스 추출**(x86-64, 4단)

```c
// index_bits.c : 임의의 VA에 대해 PML4..PT 인덱스/오프셋 출력
#include <stdio.h>
#include <stdint.h>

int main(){
    uint64_t va = 0x00007f123456789aULL;
    unsigned pml4 = (va >> 39) & 0x1ff;
    unsigned pdpt = (va >> 30) & 0x1ff;
    unsigned pd   = (va >> 21) & 0x1ff;
    unsigned pt   = (va >> 12) & 0x1ff;
    unsigned off  =  va        & 0xfff;
    printf("VA=0x%llx PML4=%u PDPT=%u PD=%u PT=%u OFF=0x%x\n",
           (unsigned long long)va, pml4, pdpt, pd, pt, off);
}
```

---

## 20. 부록 B — PAT/캐시 속성, MMIO 주의

- x86 PTE의 **PWT/PCD**와 **PAT**로 **WB/WT/UC** 등 캐시 속성을 결정.
- **MMIO**는 **Uncacheable(UC)** 로 매핑해야 안전.
- 잘못된 속성은 데이터 손상/성능 저하 → 드라이버 코드에서 필수 점검.

---

## 21. 한 줄 결론

**주소 번역**은 **TLB(빠른 길)** 과 **페이지 워크(느린 길)** 사이에서 이루어지며,
**페이지 테이블의 권한 비트**가 **안전성·보안**을, **Huge Page/PCID/ASID**가 **성능**을 좌우한다.
이 흐름을 몸에 익히면, **메모리 버그 디버깅**, **성능 튜닝**, **보안 강화** 모두에서 **정확한 원인-대책**을 세울 수 있다.
