---
layout: post
title: 정보보안기사 - 불충분한 세션 관리 취약점, 정보누출 취약점
date: 2025-11-13 11:25:23 +0900
category: 정보보안기사
---
# SECTION 08 웹 애플리케이션 취약점 — 11. 불충분한 세션 관리 취약점 · 12. 정보누출 취약점 (정의→시나리오→안전 설계→코드 템플릿→운영 가이드→체크리스트·실기 예상문제)

## 불충분한 세션 관리 취약점

### 개요 — “인증 뒤를 지키는 진짜 보안은 세션”

세션은 **인증(Authentication)** 이후 사용자의 상태를 유지하고 **인가(Authorization)** 결정을 연결하는 핵심 메커니즘이다. 다음과 같은 설계/운영 미스는 실전에서 가장 자주 악용된다.

- **세션 고정(Session Fixation)**: 로그인 전 발급된 세션 ID를 **로그인 후에도 재사용**
- **예측/탈취 가능한 세션 ID**: 약한 랜덤성, 노출된 전송, 쿠키 보안 플래그 미설정
- **쿠키 속성 부실**: `HttpOnly`/`Secure`/`SameSite` 미설정, **URL에 세션 ID** 노출
- **세션 수명 과도**: 만료 없음, 슬라이딩/절대 타임아웃 부재, 로그아웃/비번 변경 시 미무효화
- **CSRF 방어 부재**: 세션은 유효하지만 **요청 출처 검증**이 없음
- **JWT 운영 실수**: 장수(長壽) 액세스 토큰, 갱신·폐기(Revocation) 체계 부재, `aud/iss/nbf` 미검증
- **동시 세션 통제 부재**: 동일 계정 여러 환경에서 무제한 세션 허용, 이상징후 미탐지

ASCII로 본 세션 라이프사이클(권장):
```
[익명] --로그인--> [세션ID 재발급(Rotate)] --활동-->
   --민감행위--> [재인증/OTP/Step-up] --로그아웃/비번변경-->
                 [서버 저장소에서 무효화 + 토큰 패밀리 폐기]
```

---

### 전형적 취약 시나리오와 방어

#### 세션 고정(Session Fixation)

**취약 예 (개념)**
1) 공격자가 `/login` 전에 피해자에게 **세션이 심긴 링크**(혹은 응답 헤더 조작)를 열게 함
2) 피해자가 그 세션으로 로그인
3) 서버가 **세션 ID를 회전(rotate)하지 않음** → 공격자도 같은 세션을 사용 가능

**Node/Express 취약 코드**
```js
// 로그인 성공 후에도 세션ID 재발급이 없음 → 고정 위험
app.post('/login', async (req, res) => {
  const ok = await auth.verify(req.body.username, req.body.password);
  if (!ok) return res.sendStatus(401);
  req.session.userId = ok.id;        // ❌ 기존 SID 계속 사용
  res.json({ ok: true });
});
```

**안전 코드 — 로그인/권한 상승 시 세션 재발급**
```js
app.post('/login', async (req, res) => {
  const user = await auth.verify(req.body.username, req.body.password);
  if (!user) return res.sendStatus(401);
  req.session.regenerate(err => {          // ✅ 새 SID
    if (err) return res.sendStatus(500);
    req.session.userId = user.id;
    req.session.roles = user.roles;
    res.json({ ok: true });
  });
});
```

#### 쿠키 속성 부실(HttpOnly/Secure/SameSite)

**권장 설정 요약**
- `HttpOnly`: JS에서 접근 불가(XSS 시 탈취 난이도 상승)
- `Secure`: HTTPS에서만 전송(평문 탈취 방지)
- `SameSite`: `Lax` 또는 `Strict`로 **CSRF 위험 감소**(특수 케이스 Cross-Origin POST는 토큰 병행)

**Express 예**
```js
import session from 'express-session';
app.use(session({
  name: 'sid',
  secret: process.env.SESSION_SECRET,
  resave: false, saveUninitialized: false,
  cookie: {
    httpOnly: true,        // ✅
    secure: true,          // ✅ HTTPS 필수 (프록시 뒤면 trust proxy 설정)
    sameSite: 'lax',       // ✅ (민감 트랜잭션은 토큰 병행)
    maxAge: 1000 * 60 * 30 // 30분 idle timeout
  }
}));
app.set('trust proxy', 1); // 프록시 뒤 Secure 쿠키 처리용
```

#### 세션 수명·무효화 정책

- **Idle Timeout(슬라이딩)**: 마지막 활동 후 N분 경과 시 만료
- **Absolute Timeout**: 로그인 시각 기준으로 최대 수명 제한
- **로그아웃/비밀번호 변경/2FA 설정 변경 시**: **서버 저장소에서 즉시 무효화**
- **동시 세션 제한**: 장치별/브라우저별 1~N개 제한, 새 로그인 시 구세션 폐기 옵션

**.NET (분리된 Absolute/Sliding)**
```csharp
services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
.AddCookie(options =>
{
    options.ExpireTimeSpan = TimeSpan.FromMinutes(30); // Sliding
    options.SlidingExpiration = true;
    options.Cookie.HttpOnly = true;
    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
    options.Cookie.SameSite = SameSiteMode.Lax;
});
```

#### JWT 운영 이슈와 안전 패턴

**문제점**
- 로컬스토리지 저장 → XSS에 취약
- 만료 길고 **서버 폐기(Revocation) 불가**
- Refresh 토큰 **회전/가족 추적(슬라이딩)** 부재 → 도난 시 재사용

**권장**
- **액세스 토큰 단수명(5~15분)**, **리프레시 토큰 회전**(+가족 jti)
- 서버에 **리프레시 jti 블랙리스트/화이트리스트** 유지(Redis 등)
- 토큰은 **HttpOnly+Secure 쿠키**에 저장, `aud/iss/exp/nbf` 엄격 검증
- **민감 행위**는 토큰만으로 불가, **재인증/2FA**(Step-up)

**Node(JWT 회전 예)**
```js
// 발급시 jti(고유ID) 포함
function issueRefresh(userId) {
  const jti = crypto.randomUUID();
  const token = jwt.sign({ sub: userId, jti, typ:'refresh' }, REFRESH_SECRET, { expiresIn: '30d', issuer:'ex', audience:'ex-web' });
  // 서버 저장 (family 관리, 유효/폐기 상태)
  store.allow(jti, { userId, family: 'xyz' });
  return token;
}

app.post('/auth/refresh', async (req, res) => {
  try {
    const { jti, sub } = jwt.verify(req.cookies.rft, REFRESH_SECRET);
    if (!store.isAllowed(jti)) return res.sendStatus(401); // 재사용 차단
    store.revoke(jti);                        // 회전: 기존 폐기
    const newRefresh = issueRefresh(sub);     // 새 jti
    const access = jwt.sign({ sub }, ACCESS_SECRET, { expiresIn:'10m', issuer:'ex', audience:'ex-web' });
    res.cookie('rft', newRefresh, { httpOnly:true, secure:true, sameSite:'lax', maxAge:30*24*3600*1000 });
    res.json({ access });
  } catch { res.sendStatus(401); }
});
```

#### CSRF 방어(세션과 함께)

- **쿠키 기반 세션**은 **CSRF 토큰** 또는 **SameSite=Lax/Strict**와 **Origin/Referer 검사** 병행
- **SPA + API**: `SameSite=Lax` + **Double Submit Token**(헤더), 또는 **CSRF-by-Design 제거**(쿠키가 아닌 Bearer, 단 민감행위는 re-auth)

**Express (csurf)**
```js
import csurf from 'csurf';
app.use(csurf({ cookie: { httpOnly:true, secure:true, sameSite:'lax' }}));
app.get('/form', (req, res) => res.render('form', { csrfToken: req.csrfToken() }));
app.post('/pay', (req, res) => res.send('ok'));
```

---

### 운영/탐지/모니터링

- **동일 세션ID의 짧은 시간대 다지역 사용** → 경보
- **동시 세션 급증**(단일 계정) → 차단/재인증
- **비밀번호 변경/2FA 활성화 시** **전 세션 폐기**가 로그에 반영되어야 함
- **쿠키 속성·정책 변경 시** A/B 트래픽에서 누락 탐지

**SIEM 예(개념)**
- where event="login" group by userId having count(distinct geo) > K within 5m
- where cookie_name="sid" and count_distinct(ip) > 2 within 1m

---

### 체크리스트(세션)

- [ ] 로그인/권한변경/비번변경 시 **세션ID 회전**
- [ ] `HttpOnly` `Secure` `SameSite` 설정, **URL에 세션ID 금지**
- [ ] **Idle/Absolute 타임아웃** 적용, 로그아웃/비번변경 시 **서버 무효화**
- [ ] **동시 세션 제한** 또는 기기별 관리, 이상탐지
- [ ] JWT는 **단수명 액세스 + 회전형 리프레시 + 서버 폐기 저장소**
- [ ] **CSRF 토큰/Origin 검증** 병행
- [ ] **민감행위 재인증/OTP**(주소/비번/송금 등)
- [ ] **보안 헤더**(HSTS/CSP/Referrer-Policy)로 주변 리스크 저감

---

### 실기 예상문제(서술/수정형)

**문제 A**: 다음 코드의 문제점을 지적하고 수정하라.
```js
app.post('/login', async (req,res)=>{
  const ok = await auth.verify(req.body.u, req.body.p);
  if (!ok) return res.sendStatus(401);
  req.session.userId = ok.id;     // 문제 지점?
  res.json({ok:true});
});
```
**요지**: 세션 고정. **`req.session.regenerate()`**로 SID 회전.

**문제 B**: JWT를 브라우저 `localStorage`에 보관시 어떤 위험? 대안은?
**요지**: XSS 탈취. **HttpOnly+Secure 쿠키 보관 + 단수명 + 리프레시 회전**.

**문제 C**: CSRF 토큰이 있어도 왜 `SameSite`가 여전히 유용한가?
**요지**: **이중 장벽** 제공. 토큰 유출/오용·오리진 미검증 상황에서 위험 완화.

---

## 정보누출 취약점

### 개요 — “의도치 않은 정보가 공격 그래프를 완성한다”

정보누출은 **오류/로그/설정/정적자산/스토리지/헤더/캐시** 등을 통해 **환경·버전·키/토큰·개인정보·비즈니스 규칙**이 외부로 드러나는 문제다. 단독으론 저위험처럼 보이지만, **권한 상승·RCE 체인의 트리거**가 된다.

**주요 범주**
- **에러/스택 트레이스/디버그 모드** 노출
- **버전/프레임워크** 식별 헤더/배너 (`Server`, `X-Powered-By`)
- **정적 산출물**: 소스맵(`.map`), 빌드 아티팩트, `.env`, `.git`
- **오브젝트 스토리지**: S3/GCS 공개 ACL, 무제한 리스트/다운로드
- **로그/분석**: PII, 토큰, 카드정보 평문 로그
- **URL/Referer**: 쿼리에 비밀 포함 → 외부 도메인으로 전파
- **디렉터리 인덱싱/백업 파일**: `index of /`, `*.bak`, `~` 파일
- **CORS 오구성**: `Access-Control-Allow-Origin: *` + `Credentials: true`
- **Actuator/관리 엔드포인트**: `/actuator`, `/metrics`, `/env`
- **GraphQL 인트로스펙션**: 프로덕션에서 활성화
- **클라우드 메타데이터 SSRF**: `http://169.254.169.254/` 크리덴셜

---

### 전형적 시나리오와 방어

#### 에러/디버그 노출

**취약 예 (Express 기본 에러 노출)**
```js
app.get('/boom', (req,res)=> { throw new Error("debug detail: sql=..."); });
```

**안전 에러 핸들러(프로덕션: 일반 메시지, 내부: 상세 로그)**
```js
app.use((err, req, res, next) => {
  const id = crypto.randomUUID();
  console.error(`[${id}]`, err);             // 내부 상세
  res.status(500).json({ message: 'Server error', id });  // 외부 일반화
});
```

**Spring Boot**
```yaml
server:
  error:
    include-stacktrace: never     # ✅
    include-message: never
management:
  endpoints:
    web:
      exposure:
        include: health,info      # ✅ 최소 노출
```
에러 페이지(Whitelabel) 커스터마이즈, `/actuator` 보호(인증/내부망 제한).

#### 보안 헤더/배너 최소화

**Nginx**
```nginx
server {
  add_header X-Content-Type-Options "nosniff" always;
  add_header X-Frame-Options "DENY" always;
  add_header Referrer-Policy "strict-origin-when-cross-origin" always;
  add_header Permissions-Policy "geolocation=()" always;
  proxy_hide_header X-Powered-By;           # ✅ 프레임워크 헤더 숨김
  more_clear_headers Server;                # ngx_headers_more 모듈 활용
}
```

#### 정적 산출물/소스맵/비밀 파일

**웹팩/빌드: 프로덕션에서 소스맵 비공개**
```js
// webpack.prod.js
module.exports = { /* ... */ devtool: false }; // ✅ 소스맵 비공개
```
운영 필요시 **인증된 사내 툴**에만 배포.
**배포 제외**: `.env`, `.git`, `*.bak`, `*.swp`는 웹루트 밖에.

**Apache 디렉터리 인덱싱 비활성**
```apache
Options -Indexes
```

#### 노출 방지

**S3 버킷 정책 예(퍼블릭 차단 + OAC/Origin 제한)**
```json
{
  "Version":"2012-10-17",
  "Statement":[
    {
      "Sid":"DenyPublic",
      "Effect":"Deny",
      "Principal":"*",
      "Action":"s3:*",
      "Resource":["arn:aws:s3:::my-bucket","arn:aws:s3:::my-bucket/*"],
      "Condition":{"Bool":{"aws:SecureTransport":"false"}}
    }
  ]
}
```
- **Public Access Block** 활성화
- **서명 URL(만료)** 로만 접근, **리스트 금지**(ListObjects Deny)
- CDN(CloudFront) 사용 시 **Origin Access**로 직접 접근 차단

**서명 URL 발급(Node)**
```js
import { S3Client, GetObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
const s3 = new S3Client({ region: "ap-northeast-2" });
const url = await getSignedUrl(s3, new GetObjectCommand({ Bucket:"my", Key:"p/1.pdf" }), { expiresIn: 300 });
```

#### URL/Referer 통한 비밀 누출

- **토큰/세션/이메일/전화 등**을 URL 쿼리로 전달 금지
- 외부 링크로 이동 시 **`Referrer-Policy`** 엄격: `strict-origin-when-cross-origin`
- OAuth/OIDC 리다이렉트에 **state/PKCE** 사용, 민감 값은 **쿠키/서버 세션** 보관

**HTML 메타**
```html
<meta name="referrer" content="strict-origin-when-cross-origin">
```

#### CORS 오구성

**취약**
```
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
```
두 줄 조합은 **금지**. 크리덴셜이 필요하면 **정확한 허용 오리진 화이트리스트**만.

**Express CORS 안전 설정**
```js
import cors from 'cors';
const allowlist = new Set(['https://app.example.com','https://admin.example.com']);
app.use(cors({
  origin(origin, cb) {
    if (!origin) return cb(null, true); // 모바일 앱 등
    cb(null, allowlist.has(origin));
  },
  credentials: true,
  methods: ['GET','POST','PUT','DELETE'],
  allowedHeaders: ['Content-Type','X-CSRF-Token','Authorization']
}));
```

#### 로그·모니터링에서의 누출

- **민감 항목 마스킹**: 카드/주민번호/토큰/비번은 **해시/별표**
- **샘플링**: 과도 상세 로그 금지, **PII 최소화**
- **전송/저장 암호화**(TLS/at-rest), **보존기간** 준수

**logback(패턴 마스킹 예)**
```xml
<configuration>
  <turboFilter class="ch.qos.logback.classic.turbo.ReconfigureOnChangeFilter"/>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%d %-5level %logger{36} - %replace(%msg){'(?i)(password|authorization: Bearer [^ ]+)','***'}%n</pattern>
    </encoder>
  </appender>
  <root level="INFO"><appender-ref ref="STDOUT"/></root>
</configuration>
```

#### 관리/디버그 엔드포인트

- Spring `/actuator/**`는 **내부망/인증** 제한, `env/beans/mappings` 등 **민감 비활성**
- GraphQL 인트로스펙션/Playground는 **프로덕션 비활성**
- 관리자 API는 **별도 도메인** + **강화 인증(2FA, IP 제한)**

**Spring Actuator 최소화**
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info
  endpoint:
    health:
      show-details: never
```

---

### 캐시/프록시/브라우저 누출 방지

- **민감 응답**: `Cache-Control: no-store`, `Pragma: no-cache`
- **프라이빗 데이터**: `Cache-Control: private, no-store`
- CDN 캐시 키에 **사용자/권한 컨텍스트**를 반영하거나 **원천 비캐시**

**Express**
```js
app.get('/me', (req,res)=>{
  res.set('Cache-Control','no-store');
  res.json({ id:req.user.id, email:req.user.email });
});
```

---

### 보안 헤더 셋(정보노출·사이드채널 완화)

- **CSP(Content-Security-Policy)**: XSS로 인한 **토큰/데이터 유출** 경로 차단
- **X-Content-Type-Options: nosniff**: MIME 스니핑 방지
- **X-Frame-Options/Frame-Ancestors**: 클릭재킹 방지
- **Referrer-Policy**: URL 기반 비밀 전파 제한
- **HSTS**: 강제 HTTPS

**Helmet(Express)**
```js
import helmet from 'helmet';
app.use(helmet({
  contentSecurityPolicy: {
    useDefaults: true,
    directives:{ 'default-src': ["'self'"] }
  },
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' }
}));
```

---

### 테스트·탐지·자동화

**DAST/크롤러 체크리스트**
- `/.git/`, `/backup/`, `/.env`, `/config/*`, `/index of/` 패턴
- JS에서 `//# sourceMappingURL=` 주석 탐지 → `.map` 접근
- 에러 페이지에 **스택/쿼리/경로** 노출 여부
- 헤더/배너에 프레임워크·버전 식별자
- 공개 버킷/스토리지 인덱싱 접근 시도

**CI 비밀 스캔**
- `gitleaks`, `trufflehog`, 클라우드 공급자 시크릿 스캐닝 활성화
- IaC 정책으로 **퍼블릭 ACL 차단**, CORS/보안 헤더 검사

---

### 체크리스트(정보누출)

- [ ] 프로덕션 **디버그/스택 트레이스 비공개**, 표준 에러 응답
- [ ] `Server/X-Powered-By` 등 **배너 제거/마스킹**
- [ ] **소스맵/백업/숨김 파일 비배포**, 디렉터리 인덱싱 OFF
- [ ] S3/GCS **퍼블릭 차단**, **서명 URL(만료)**, 목록 금지
- [ ] **CORS 화이트리스트**(와일드카드+크리덴셜 금지)
- [ ] **Referrer-Policy**·민감 값 URL 금지
- [ ] 로그에서 **민감정보 마스킹**, 보존·암호화 정책
- [ ] `/actuator`·관리 엔드포인트 **내부망/인증**
- [ ] 민감 응답 **no-store**, CDN 캐시 키에 권한 컨텍스트
- [ ] CSP/NoSniff/HSTS/Frame 방어 헤더 설정

---

### 실기 예상문제(서술/수정형)

**문제 1**
다음 헤더 구성이 위험한 이유와 수정안을 쓰라.
```
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
```
**요지**: 크리덴셜과 `*`는 함께 설정 불가(브라우저 정책/보안). **정확한 오리진 화이트리스트**로 수정.

**문제 2**
프로덕션에서 소스맵을 공개할 때의 위험과 대안을 서술하라.
**요지**: 원본 소스/주석/비밀 로직 노출. **비공개 배포** 또는 **인증된 내부 툴**에서만 접근.

**문제 3**
Spring Boot에서 스택 트레이스를 외부로 노출하지 않으려면?
**요지**: `server.error.include-stacktrace=never` 등 에러 설정, 커스텀 ErrorController, 로깅은 내부.

**문제 4**
S3 객체를 외부 제공해야 한다. 공개 ACL 없이 제공하는 안전한 방식은?
**요지**: **서명 URL(짧은 만료)**, 또는 CDN **Origin Access** 구성을 사용.

**문제 5**
`Referrer-Policy`가 정보누출과 어떻게 연관되는지 설명하라.
**요지**: 외부 이동 시 **쿼리/경로**가 Referer로 전파되는 것을 제한 → 비밀 파라미터 보호.

---

## 부록: 수식으로 본 민감정보 최소화 원리

민감정보 노출 기대값 \(E[L]\)은 대략적으로
$$
E[L] \approx \sum_{c \in \mathcal{C}} P(\text{Channel } c \text{ leaks}) \cdot I(\text{Impact}_c)
$$
여기서 채널 \(\mathcal{C}\)는 **에러/로그/정적자산/스토리지/헤더/캐시/리다이렉트/Referer** 등.
각 채널에 대해 **발생 확률 \(P\)** 를 낮추는 제어(비공개/마스킹/정책)와, **영향 \(I\)** 를 줄이는 제어(데이터 최소화, 암호화, TTL/만료, 범위제한)를 병행한다.

---

## 결론

- **세션 관리**는 인증 이후 보안의 실질적 토대다. **SID 회전·쿠키 속성·수명·무효화·CSRF·JWT 운영**까지 한 세트로 가져가야 한다.
- **정보누출**은 공격자가 **권한 상승/침투 체인을 완성**하는 재료다. **디버그/배너/정적자산/스토리지/CORS/로그/캐시/관리 엔드포인트**를 체계적으로 닫아야 한다.
- 본 문서의 **코드 템플릿·체크리스트**를 프로젝트 표준에 흡수하고, **CI(시크릿 스캔) + DAST + 운영 모니터링**으로 지속 검증하면, 시험과 실무 모두에서 높은 방어력을 확보할 수 있다.
