---
layout: post
title: 운영체제 - 데드락 (1)
date: 2025-10-20 22:25:23 +0900
category: 운영체제
---
# Chapter 8 — Deadlocks

## 8.1 System Model

### 8.1.1 자원(Resource)과 프로세스/스레드 모델
- **자원 타입**: CPU 코어, 메모리 프레임, 파일 핸들, 소켓, 디바이스, **락(뮤텍스/세마포어/RW락)** 등.  
- **인스턴스**: 각 자원 타입은 여러 개 인스턴스를 가질 수 있음(예: 파일 디스크립터 100개).  
- **프로세스/스레드(편의상 ‘작업’이라 부름)**는 자원을 **요청(request)→할당(allocate)→방출(release)**.

작업의 상태는 보통 다음 3단계의 반복으로 기술된다.

1) **요청**: 어떤 자원 타입 \(R_j\) 의 인스턴스 \(k\)개를 요구  
2) **사용**: 자원을 획득했다면 임계구역/작업 수행  
3) **방출**: 사용이 끝나면 반환

### 8.1.2 시스템 상태 기술(행렬 표기)
- 자원 타입 수 \(m\), 작업 수 \(n\).  
- **Available**: 길이 \(m\) 벡터, 현재 가용 인스턴스 수  
- **Allocation**: \(n\times m\) 행렬, 각 작업에 현재 할당된 수  
- **Request**(또는 Need): \(n\times m\), 각 작업이 **추가로** 필요한 수

> Banker's Algorithm은 8.4에서 다루지만, 여기서도 표기법은 사용한다.

### 8.1.3 데드락(Deadlock) 정의
서로가 보유한 자원을 기다리는 **순환 대기**로 인해 **무한 대기**에 빠지는 상태.  
형식화하면, 집합 \(T\) 의 모든 작업에 대해 다음이 성립:

- \( \forall P_i \in T: \) \(P_i\)는 어떤 자원을 **기다리고** 있고, 그 자원은 \(T\) 내 다른 \(P_k\)가 **보유** 중
- 이로 인해 **진행(progress)** 이 불가능

### 8.1.4 Coffman의 4조건 (데드락의 필요조건)
1) **Mutual Exclusion**: 자원은 한 번에 한 작업만 보유  
2) **Hold and Wait**: 최소 하나의 자원을 보유한 채 다른 자원을 요청하며 대기  
3) **No Preemption**: 중간 강제 회수가 불가  
4) **Circular Wait**: 작업 집합 내 자원 획득 대기에 **사이클** 존재

> 4개가 **모두** 성립해야 데드락 가능. 하나라도 깨면 **예방**할 수 있다.

---

## 8.2 Deadlock in Multithreaded Applications

스레드 기반 애플리케이션에서 데드락은 **락의 순환 대기**로 가장 흔히 발생한다.

### 8.2.1 대표 증상
- 요청이 적은데도 **응답이 무한 대기**  
- 스레드 덤프/스택 추적에서 **상호 대기 중인 락** 확인  
- CPU 사용률 낮고(혹은 0), 시스템은 살아 있으나 기능 정지

### 8.2.2 최소 재현(두 뮤텍스 교차 대기)

#### C++ (pthreads/`std::mutex`)
```cpp
// deadlock_two_mutex.cpp
#include <mutex>
#include <thread>
#include <chrono>
#include <iostream>

std::mutex A, B;

void t1(){
    std::lock_guard<std::mutex> g1(A);
    std::this_thread::sleep_for(std::chrono::milliseconds(10)); // interleave 유도
    std::lock_guard<std::mutex> g2(B); // 여기서 B 대기
}
void t2(){
    std::lock_guard<std::mutex> g1(B);
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::lock_guard<std::mutex> g2(A); // 여기서 A 대기 — 순환
}
int main(){
    std::thread x(t1), y(t2);
    x.join(); y.join(); // 종료되지 않음(데드락)
}
```

#### Java (내장 모니터)
```java
// DeadlockTwoLocks.java
public class DeadlockTwoLocks {
  static final Object A = new Object(), B = new Object();
  public static void main(String[] a){
    Thread t1 = new Thread(() -> {
      synchronized (A) {
        sleep(10);
        synchronized (B) { }
      }
    });
    Thread t2 = new Thread(() -> {
      synchronized (B) {
        sleep(10);
        synchronized (A) { }
      }
    });
    t1.start(); t2.start();
  }
  static void sleep(long ms){ try { Thread.sleep(ms); } catch(Exception ignored){} }
}
```

> **원인**: `t1`은 `A→B`, `t2`는 `B→A` 순서로 락을 취득해 **순환대기**.

### 8.2.3 N-락 일반화: Wait-For Graph (스레드 ↔ 락)
- **노드**: 스레드  
- **간선**: \(T_i \rightarrow T_j\), 스레드 \(i\)가 스레드 \(j\)가 가진 락을 기다리는 의존성  
- **사이클**이 존재하면 데드락 가능

간단 검출기(파이썬 의사코드):
```python
# wait-for cycle detection (directed graph) — DFS
def has_cycle(adj):
    N=len(adj); color=[0]*N # 0:unseen,1:visiting,2:done
    def dfs(u):
        color[u]=1
        for v in adj[u]:
            if color[v]==1: return True
            if color[v]==0 and dfs(v): return True
        color[u]=2; return False
    return any(dfs(i) for i in range(N) if color[i]==0)
```

### 8.2.4 실무에서 생기는 패턴들

1) **락 순서 불일치**: 모듈 간 사전 규약이 없음 → 예: DB락 + 캐시락 역순  
2) **락 중 예외/시간초과**: 롤백 누락 → **Hold and Wait** 영속화  
3) **다중 자원 혼합**: 파일락 + 뮤텍스 + DB 트랜잭션락  
4) **콜백 중 재진입**: 콜백이 상위 락을 다시 획득  
5) **GUI/메시지 루프 교착**: UI 쓰레드가 락 소유 상태로 동기 호출 → 상대가 UI 응답을 기다림

### 8.2.5 회피/예방 기법

#### (A) **글로벌 락 순서 규약**
- 모든 공유 오브젝트에 **순서 키** 부여(예: 주소/ID 정렬)
- 복수 락이 필요하면 **항상 작은 키→큰 키 순서**로 취득

```cpp
// ordered_lock.cpp — 주소 순서로 락 취득
void lock_two(std::mutex& a, std::mutex& b){
    std::mutex *first=&a, *second=&b;
    if (first > second) std::swap(first, second);
    std::lock(*first, *second); // deadlock-free locking for two
}
```

> C++17의 `std::scoped_lock(a,b,...)` 는 내부적으로 **데드락-프리** 알고리즘으로 동시 취득.

#### (B) **try-lock + 백오프/롤백**
- 모든 락을 얻지 못하면 **반드시 모든 획득 락을 해제** 후 재시도(무작위 슬립)

```cpp
bool lock_all(std::mutex& a, std::mutex& b){
    using namespace std::chrono_literals;
    while(true){
        if(a.try_lock()){
            if(b.try_lock()){ return true; }
            a.unlock();
        }
        std::this_thread::sleep_for(1ms); // backoff
    }
}
```

#### (C) **자원 사전할당(All-or-Nothing)**
- **Hold-and-Wait** 조건 파기: **필요한 모든 자원을 한꺼번에** 확보하지 못하면 아무 것도 잡지 않음

#### (D) **Preemption 허용 설계**
- 락 대신 **트랜잭션(낙관적)**, **메시지 큐(Actor/CSP)**, **락프리** 자료구조 고려

### 8.2.6 교착 추적/분석 도구
- **POSIX/C++**: `gdb` 스레드 스택, `pstack`, `perf lock`, TSan(데드락은 제한적), custom WFG 로깅  
- **Java**: `jstack`/JFR/VisualVM/Java Mission Control → **"Found one Java-level deadlock"** 보고  
- **Windows**: WPA/ETW, `!locks`(WinDbg)

---

## 8.3 Deadlock Characterization

데드락을 **그래프**와 **수학적 조건**으로 특성화한다.

### 8.3.1 Resource-Allocation Graph (RAG)
- **노드**: 작업 노드 \(P_i\), 자원 타입 노드 \(R_j\)  
- **간선**  
  - 요청: \(P_i \rightarrow R_j\)  
  - 할당: \(R_j \rightarrow P_i\)  
- **자원 인스턴스가 1개**인 모든 타입에서, **사이클이 존재하면 곧 데드락**.  
- **여러 인스턴스**가 있는 타입이 포함되면, 사이클은 **필요조건**일 뿐 **충분조건은 아님**.

#### 예시(단일 인스턴스)
- \(P_1 \rightarrow R_A \rightarrow P_2 \rightarrow R_B \rightarrow P_1\)  
  → 사이클 하나로 데드락 확정.

#### 예시(다중 인스턴스)
- \(R_X\) 가 2개 인스턴스, \(P_1,P_2,P_3\) 가 엮여 **사이클 존재**하더라도 여유 인스턴스로 해소 가능 → **사이클 ⇒ 가능성**.

### 8.3.2 Wait-For Graph (WFG)
- RAG에서 자원 노드를 제거한 **순수 작업 그래프**  
- **간선 \(P_i \rightarrow P_j\)**: \(P_i\)가 \(P_j\)가 보유한 자원을 기다림  
- 단일 인스턴스 가정 하에서 **사이클 ⇔ 데드락**  
- 실제 스레드/락 분석에 실용적

#### 파이썬: 간단 WFG 구축 & 검출 예
```python
# wfg_demo.py — 락 소유/대기 목록으로부터 사이클 검출
locks = {
  "L1": {"owner": "T1", "waiters": ["T3"]},
  "L2": {"owner": "T2", "waiters": ["T1"]},
  "L3": {"owner": "T3", "waiters": ["T2"]},
}
# WFG: T1→T2 (T1은 L2의 owner T2를 기다림), T2→T3, T3→T1
adj = {"T1":["T2"], "T2":["T3"], "T3":["T1"]}
print("cycle?", has_cycle(adj:=adj))
# True → 데드락
```

### 8.3.3 Coffman 4조건과의 연결(수학적 관점)
- **Mutual Exclusion**: 각 자원 인스턴스는 배타적 → **자원 노드 out-degree ≤ 1**  
- **Hold and Wait**: \(P_i\)가 **할당 간선**과 **요청 간선**을 동시에 가질 수 있음  
- **No Preemption**: 할당 간선이 **강제 역방향**으로 제거될 수 없음  
- **Circular Wait**: RAG/WFG 내 **사이클** 존재

> **결론**: RAG/WFG에 **사이클이 없도록** 설계하면(예: **락 순서 토폴로지** 유지) 자동으로 4조건 중 **Circular Wait**을 깨뜨림.

### 8.3.4 Safe/Unsafe 상태(직관)
- **안전 상태(Safe state)**: 어느 순서로든 **모든 작업을 완료**할 수 있는 **완료 순서**(safe sequence)가 존재  
- **불안전 상태(Unsafe)**: 당장 데드락은 아니지만, 특정 요청 순서에서 **데드락 가능**  
- 직관적 근거: **가용 자원으로 만족 가능한 작업 하나를 찾아 완료** → 자원을 회수하고 다음 작업으로 진행하는 **재귀적 순서** 존재 여부

> 안전성 판정은 8.4(회피)에서 구체화되지만, 여기서는 **개념**만 확인.

### 8.3.5 특징별 사례 정리

| 시나리오 | 그래프 특징 | 결론 |
|---|---|---|
| 두 락 교차 획득 | WFG 2노드 사이클 | 즉시 데드락 |
| 다중 인스턴스 + 사이클 | RAG 사이클 | **가능성** (충분조건 아님) |
| 엄격한 락 순서 | DAG | 데드락 불가 |
| try-lock + 백오프 | 순환 만들기 어려움 | 확률적 방지(아직도 라이브락 가능) |
| Actor/메시지 패턴 | 공유락 없음 | 구조적으로 예방 |

---

## 부록 — 실전 점검 체크리스트(앱/서비스 관점)

1) **락 순서 규약**을 문서화하고 린터/유닛테스트에서 강제  
2) 모든 복수 락 획득 지점에서 **`std::scoped_lock`/Java `ReentrantLock` 다중 `lock()`** 사용  
3) **try-lock + 타임아웃/백오프** 를 기본값으로 고려(특히 진단용 코드 경로)  
4) 블로킹 I/O와 락의 **중첩** 금지(특히 UI/메인/이벤트 루프 스레드)  
5) 장애 시 스레드 덤프/락 히스토리 수집(자바 `jstack`, C++ 커스텀 WFG 로그)  
6) DB 트랜잭션 락과 애플리케이션 락의 **교차 의존** 제거(항상 **DB→앱락** 같이 **하나의 방향**으로만)  
7) 장시간 락 보유 금지(긴 연산은 데이터 사본으로 수행 후 빠르게 교체)

---

## 코드 모음 — 안전한 대안 패턴

### (1) C++: `std::scoped_lock`로 2개 이상 락 데드락-프리 취득
```cpp
std::mutex a, b, c;

void safe(){
    std::scoped_lock g(a, b, c); // 교착 방지 알고리즘 적용
    // a,b,c 보호 구역
}
```

### (2) C++: **계층형 락(Hierarchical Mutex)** — 규약 위반을 런타임 감지
```cpp
// hierarchical_mutex.hpp (요지)
class hierarchical_mutex {
    std::mutex m; unsigned long const level; static thread_local unsigned long cur;
public:
    explicit hierarchical_mutex(unsigned long lvl): level(lvl){}
    void lock(){
        if(cur <= level) throw std::logic_error("lock order violation");
        m.lock(); auto prev = cur; cur = level;
    }
    void unlock(){ cur = ULONG_MAX; m.unlock(); }
};
```
> 낮은 번호 → 더 높은 우선순위. 항상 **큰 레벨 → 작은 레벨** 순서로만 락 허용.

### (3) Java: `ReentrantLock` + `tryLock` 타임아웃
```java
Lock a = new ReentrantLock(), b = new ReentrantLock();
void safe() throws InterruptedException {
  while(true){
    if(a.tryLock(10, TimeUnit.MILLISECONDS)){
      try{
        if(b.tryLock(10, TimeUnit.MILLISECONDS)){
          try{
            // work
            return;
          } finally { b.unlock(); }
        }
      } finally { a.unlock(); }
    }
    Thread.sleep(1); // backoff
  }
}
```

---

## 핵심 요약

- **8.1 시스템 모델**: 요청-할당-방출, Available/Allocation/Request 표기법, 데드락은 순환 대기로 정의.  
- **8.2 스레드 데드락**: 가장 흔한 원인은 **락 순서 불일치**. `scoped_lock`, 글로벌 순서, try-lock+백오프, All-or-Nothing으로 예방.  
- **8.3 특성화**: **RAG/WFG** 그래프에서 **사이클**이 본질. 단일 인스턴스 자원 시스템은 **사이클 ⇔ 데드락**. 여러 인스턴스면 **사이클 ⇒ 가능성**. **락 순서 DAG**를 유지하면 구조적으로 안전.