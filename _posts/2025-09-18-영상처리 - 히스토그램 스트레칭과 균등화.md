---
layout: post
title: 영상처리 - 히스토그램 분석
date: 2025-09-18 23:25:23 +0900
category: 영상처리
---
# 히스토그램 스트레칭과 균등화

## 1) 개념 정리

### 1.1 히스토그램 **스트레칭(Stretching)**
어두운/밝은 쪽의 일부 비율을 **클리핑**하고, 남은 구간을 **0~255로 선형 확장**합니다.  
- 누적분포 \(H[k]=\sum_{i=0}^k h[i]\) 가 전체 \(N\) 대비 **하위 \(p_\text{low}\)%** 에 해당하는 \(t_\text{low}\),  
  **상위 \(p_\text{high}\)%** 에 해당하는 \(t_\text{high}\) 를 찾습니다.
- 매핑:
  \[
  v'=\begin{cases}
    0 & (v \le t_\text{low})\\
    \displaystyle \left\lfloor \frac{v-t_\text{low}}{t_\text{high}-t_\text{low}}\cdot 255 + 0.5 \right\rfloor & (t_\text{low} < v < t_\text{high})\\
    255 & (v \ge t_\text{high})
  \end{cases}
  \]

> 보통 \(p_\text{low}=p_\text{high}=1\%\) 같은 **소량 클리핑**으로 노이즈/극단값을 눌러주고 대비를 올립니다.

### 1.2 히스토그램 **균등화(Equalization)**
누적분포(CDF)를 **선형(0~255)** 로 피복되게 매핑합니다.
\[
v'=\left\lfloor \frac{H[v]-H_\text{min}}{N-H_\text{min}}\cdot 255 + 0.5 \right\rfloor
\]
- \(H_\text{min}\) 은 \(H[v]>0\) 인 최초 bin의 CDF(0으로 나눔 방지).

### 1.3 **RGB vs Luma(휘도)**
- **RGB 채널별**: R/G/B 각각의 히스토그램으로 LUT를 만들어 **각 채널에 독립 적용**  
  → 간단/빠름, 하지만 **색조 변동** 가능(채널별 스케일이 달라져 색이 약간 바뀔 수 있음).
- **Luma 기반**: \(Y\approx0.299R+0.587G+0.114B\) 의 히스토그램으로 **Y만 스트레칭/균등화**하고,  
  각 픽셀에서 **스케일 \(s=Y'/\max(Y,\varepsilon)\)** 를 구해 **R,G,B를 동일 비율로 스케일**  
  → 색조 보존에 유리(채도 변동 최소화).

---

## 2) 핵심 구현 — **LUT** 생성 & 적용

아래 새 파일 **`HistOps.h`** 를 추가합니다. (전 장의 `Histogram.h/HistogramCompute.h` 필요)

```cpp
// HistOps.h
#pragma once
#include <cstdint>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cmath>
#include "IppDib.h"
#include "Histogram.h"
#include "HistogramCompute.h"

// ---- 공용 유틸 ----
inline uint8_t clamp_u8_int(int v){ return (uint8_t)std::min(255, std::max(0, v)); }
inline int clamp255(int v){ return v<0?0:(v>255?255:v); }

// ---- 1) 스트레칭 LUT 생성 (단일 히스토그램 대상) ----
// clipLow, clipHigh: 0~100 (퍼센트)
inline void BuildStretchLUT_FromHist(const Hist256& h, int clipLow, int clipHigh, uint8_t lut[256]) {
    // 누적분포
    uint64_t cdf[256]; uint64_t acc=0; for (int i=0;i<256;++i){ acc+=h.bin[i]; cdf[i]=acc; }
    const uint64_t N = cdf[255];
    if (N==0) { for (int i=0;i<256;++i) lut[i]=i; return; }

    const uint64_t lowT  = (uint64_t)std::llround(N * (clipLow  / 100.0));
    const uint64_t highT = (uint64_t)std::llround(N * (1.0 - (clipHigh / 100.0)));

    // t_low: cdf >= lowT 최초 인덱스, t_high: cdf >= highT 최초 인덱스
    int t_low = 0;  while (t_low<256  && cdf[t_low]  < lowT)  ++t_low;
    int t_high= 0;  while (t_high<256 && cdf[t_high] < highT) ++t_high;

    if (t_high <= t_low) { for (int i=0;i<256;++i) lut[i]= (i <= t_low)?0:255; return; }

    const double denom = (double)(t_high - t_low);
    for (int v=0; v<256; ++v) {
        if (v <= t_low) lut[v]=0;
        else if (v >= t_high) lut[v]=255;
        else {
            double t = (v - t_low) / denom; // 0..1
            lut[v] = (uint8_t)std::lround(t * 255.0);
        }
    }
}

// ---- 2) 균등화 LUT 생성 (단일 히스토그램 대상) ----
inline void BuildEqualizeLUT_FromHist(const Hist256& h, uint8_t lut[256]) {
    uint64_t cdf[256]; uint64_t acc=0; for (int i=0;i<256;++i){ acc+=h.bin[i]; cdf[i]=acc; }
    const uint64_t N = cdf[255];
    if (N==0) { for (int i=0;i<256;++i) lut[i]=i; return; }

    // cdf_min: 0이 아닌 최초 빈의 누적
    uint64_t cdf_min = 0;
    for (int i=0;i<256;++i){ if (h.bin[i]) { cdf_min = cdf[i]; break; } }

    for (int v=0; v<256; ++v) {
        if (cdf[v] <= cdf_min) { lut[v]=0; continue; }
        double t = (double)(cdf[v] - cdf_min) / (double)(N - cdf_min);
        if (t<0) t=0; if (t>1) t=1;
        lut[v] = (uint8_t)std::lround(t * 255.0);
    }
}

// ---- 3) LUT 적용 도우미 (BGRA32) ----
inline void ApplyLUT_RGB_ToDIB(IppDib& dib, const uint8_t lutB[256],
                               const uint8_t lutG[256], const uint8_t lutR[256]) {
    if (!dib) return;
    for (int y=0; y<dib.height(); ++y) {
        uint8_t* row = (uint8_t*)dib.bits() + (size_t)y * dib.stride();
        for (int x=0; x<dib.width(); ++x) {
            uint8_t* p = &row[x*4];
            p[0] = lutB[p[0]];
            p[1] = lutG[p[1]];
            p[2] = lutR[p[2]];
            // p[3] alpha 보존
        }
    }
}

// ---- 4) Luma 스케일 적용 (Y LUT을 이용해 RGB를 스케일) ----
// Y = 0.299R + 0.587G + 0.114B (정수 근사 사용)
// s = Y'/max(Y,1e-6) ;  r'=clamp(r*s), g', b'
inline void ApplyLumaLUT_ScaleRGB(IppDib& dib, const uint8_t lutY[256]) {
    if (!dib) return;
    for (int y=0; y<dib.height(); ++y) {
        uint8_t* row = (uint8_t*)dib.bits() + (size_t)y * dib.stride();
        for (int x=0; x<dib.width(); ++x) {
            uint8_t* p=&row[x*4];
            int B=p[0], G=p[1], R=p[2];
            int Y = clamp255((int)std::lround(0.299*R + 0.587*G + 0.114*B));
            int Yp= lutY[Y];
            if (Y<=0) {
                // 원본이 완전 0이면 결과는 Y' 비율이 의미 없음 → 동일 분배(단색 가정)
                p[0]=p[1]=p[2]=(uint8_t)Yp;
            } else {
                double s = (double)Yp / (double)Y;
                p[2] = clamp_u8_int((int)std::lround(R * s));
                p[1] = clamp_u8_int((int)std::lround(G * s));
                p[0] = clamp_u8_int((int)std::lround(B * s));
            }
        }
    }
}

// ---- 5) 고수준 API: Auto Stretch / Equalize ----
// (A) RGB 채널별 스트레칭
inline void AutoStretch_RGB(IppDib& dib, int clipLowPct=1, int clipHighPct=1) {
    if (!dib) return;
    HistogramData hd; ComputeHistogramFromDIB(dib, hd, 1);
    uint8_t lB[256], lG[256], lR[256];
    BuildStretchLUT_FromHist(hd.b, clipLowPct, clipHighPct, lB);
    BuildStretchLUT_FromHist(hd.g, clipLowPct, clipHighPct, lG);
    BuildStretchLUT_FromHist(hd.r, clipLowPct, clipHighPct, lR);
    ApplyLUT_RGB_ToDIB(dib, lB,lG,lR);
}

// (B) Luma 기반 스트레칭(색조 보존)
inline void AutoStretch_Luma(IppDib& dib, int clipLowPct=1, int clipHighPct=1) {
    if (!dib) return;
    HistogramData hd; ComputeHistogramFromDIB(dib, hd, 1);
    uint8_t lY[256]; BuildStretchLUT_FromHist(hd.y, clipLowPct, clipHighPct, lY);
    ApplyLumaLUT_ScaleRGB(dib, lY);
}

// (C) RGB 채널별 균등화
inline void Equalize_RGB(IppDib& dib) {
    if (!dib) return;
    HistogramData hd; ComputeHistogramFromDIB(dib, hd, 1);
    uint8_t lB[256], lG[256], lR[256];
    BuildEqualizeLUT_FromHist(hd.b, lB);
    BuildEqualizeLUT_FromHist(hd.g, lG);
    BuildEqualizeLUT_FromHist(hd.r, lR);
    ApplyLUT_RGB_ToDIB(dib, lB,lG,lR);
}

// (D) Luma 기반 균등화(색조 보존)
inline void Equalize_Luma(IppDib& dib) {
    if (!dib) return;
    HistogramData hd; ComputeHistogramFromDIB(dib, hd, 1);
    uint8_t lY[256]; BuildEqualizeLUT_FromHist(hd.y, lY);
    ApplyLumaLUT_ScaleRGB(dib, lY);
}
```

> **설계 요점**  
> - **RGB 방식**: 채널별 LUT → `ApplyLUT_RGB_ToDIB`  
> - **Luma 방식**: **Y LUT**로 목표 \(Y'\) 계산, **스케일 \(s=Y'/Y\)** 을 각 채널에 동일 적용 → **색조 보존**  
> - 알파는 **그대로 유지**합니다.

---

## 3) 메뉴 추가 (리소스)

### 3.1 `res/resource.h` (ID 추가)

```cpp
// Histogram Stretch / Equalize menu commands
#define ID_IMAGE_AUTOSTRETCH_RGB       40500
#define ID_IMAGE_AUTOSTRETCH_LUMA      40501
#define ID_IMAGE_EQUALIZE_RGB          40502
#define ID_IMAGE_EQUALIZE_LUMA         40503
```

### 3.2 `res/ImageTool.rc` (메뉴 텍스트/가속기)

```rc
#include "resource.h"

// ... 기존 MENU 정의 중 &Image 섹션에 추가 ...
POPUP "&Image"
BEGIN
    MENUITEM "Brightness / Contrast...\tCtrl+B",  40200
    MENUITEM "Gamma Correction...\tCtrl+G",       40300
    MENUITEM SEPARATOR
    MENUITEM "Auto Stretch (RGB, 1%)",            ID_IMAGE_AUTOSTRETCH_RGB
    MENUITEM "Auto Stretch (Luma, 1%)",           ID_IMAGE_AUTOSTRETCH_LUMA
    MENUITEM "Equalize Histogram (RGB)",          ID_IMAGE_EQUALIZE_RGB
    MENUITEM "Equalize Histogram (Luma)",         ID_IMAGE_EQUALIZE_LUMA
END

// (선택) 가속기: Ctrl+Shift+S => Auto Stretch(RGB), Ctrl+Shift+E => Equalize(Luma)
IDR_ACCEL ACCELERATORS
BEGIN
    "^S", ID_IMAGE_AUTOSTRETCH_RGB, VIRTKEY, SHIFT, CONTROL
    "^E", ID_IMAGE_EQUALIZE_LUMA,   VIRTKEY, SHIFT, CONTROL
END
```

> **권장 UX**  
> - 빠른 기본값: **Auto Stretch (RGB, 1%)** 는 대부분 사진에서 자연스러운 대비 향상  
> - 색조 보존이 필요한 과제(스캔/문서)는 **Luma** 옵션 사용을 권장

---

## 4) 메인 윈도우 연결 (핸들러)

`main_multiwin.cpp` 의 `WM_COMMAND` 스위치에 항목을 추가합니다.

```cpp
// main_multiwin.cpp (발췌)
#include "HistOps.h"  // 새로 추가한 헤더

// ...
case ID_IMAGE_AUTOSTRETCH_RGB:
    if (st && st->dib) {
        AutoStretch_RGB(st->dib, /*low*/1, /*high*/1);
        OutputBasicInfo(st);
        UpdateStatusBasic(hWnd, st);
        InvalidateRect(hWnd, nullptr, FALSE);
    }
    return 0;

case ID_IMAGE_AUTOSTRETCH_LUMA:
    if (st && st->dib) {
        AutoStretch_Luma(st->dib, 1, 1);
        OutputBasicInfo(st);
        UpdateStatusBasic(hWnd, st);
        InvalidateRect(hWnd, nullptr, FALSE);
    }
    return 0;

case ID_IMAGE_EQUALIZE_RGB:
    if (st && st->dib) {
        Equalize_RGB(st->dib);
        OutputBasicInfo(st);
        UpdateStatusBasic(hWnd, st);
        InvalidateRect(hWnd, nullptr, FALSE);
    }
    return 0;

case ID_IMAGE_EQUALIZE_LUMA:
    if (st && st->dib) {
        Equalize_Luma(st->dib);
        OutputBasicInfo(st);
        UpdateStatusBasic(hWnd, st);
        InvalidateRect(hWnd, nullptr, FALSE);
    }
    return 0;
// ...
```

---

## 5) 정확성/수치적 주의

- **스트레칭**: \(t_\text{high} \le t_\text{low}\) (평탄하거나 단색)인 극단 상황 → 0/255로 수렴 처리  
- **균등화**: \(H_\text{min}\) 보정으로 **완전 검정**에 대한 0 나눗셈 회피  
- **Luma 스케일**: \(Y=0\) 인 경우는 \(R=G=B=0\) 으로 간주 → **\(Y'\) 를 동일 분배**  
- **채널 클램프**: 모든 결과는 **0~255** 로 클램프

---

## 6) 성능 팁

- LUT는 **256 원소** 연산에 불과 — 실시간 처리도 충분  
- 초대형 이미지에서 Luma 스케일 경로가 조금 더 비쌉니다.  
  - 필요 시 `#pragma omp parallel for` (행 병렬)  
  - 또는 `ComputeHistogramFromDIB` 에 **샘플링 step**(예: 2) 적용으로 LUT 추정 → 빠르게

---

## 7) 실습/검증 체크리스트

1) **저대비** 사진 → `Auto Stretch (RGB, 1%)` 적용 시 콘트라스트 개선  
2) **컬러 캐스트** 사진 → RGB/ Luma 결과 비교(색조/채도 변화 관찰)  
3) **안개/박무** 이미지 → Luma 스트레칭이 자연스러운 경우 다수  
4) **균등화**: 실내/역광 사진에서 **텍스처 디테일**이 살아나는지 확인  
5) 극단 예: 단색/이진 영상 → 방어코드가 정상 동작(깨지지 않음)

---

## 8) (선택) 고급 옵션 아이디어

- **사용자 지정 스트레칭 대화상자**: Low/High 퍼센트(0~5%) 슬라이더, RGB/Luma 모드, 미리보기  
- **CLAHE(적응형 균등화)**: 타일 기반 + clip limit (의학/자연 영상에서 효과적)  
- **히스토그램 뷰와 연동**: 대화상자 안에서 스트레칭 범위를 **마우스로 드래그**하여 t_low/t_high 선택

---

## 9) 요약

- 스트레칭: **퍼센타일 클리핑** 후 **선형** 매핑으로 대비 향상  
- 균등화: **CDF 기반** 매핑으로 전체 톤을 균일하게 펴기  
- 구현은 모두 **LUT** 기반으로 빠르고 안전  
- **RGB(채널별)** 과 **Luma(색조 보존)** 두 경로를 지원  
- 메뉴 항목으로 **원클릭 자동 보정**까지 완성