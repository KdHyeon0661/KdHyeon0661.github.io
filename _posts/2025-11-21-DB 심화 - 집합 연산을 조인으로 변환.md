---
layout: post
title: DB 심화 - 집합 연산을 조인으로 변환
date: 2025-11-21 17:25:23 +0900
category: DB 심화
---
# 집합 연산을 조인으로 변환: 성능 최적화의 핵심 기술

## 집합 연산과 조인 변환의 본질적 이해

SQL의 집합 연산(INTERSECT, MINUS/EXCEPT, UNION)은 직관적인 논리적 표현을 제공하지만, 대규모 데이터 처리에서는 성능 문제를 야기할 수 있습니다. 이러한 집합 연산을 조인으로 변환하는 기술은 데이터베이스 성능 최적화의 중요한 패턴 중 하나입니다. 이 변환의 핵심은 집합 연산의 논리적 의미를 보존하면서도 데이터베이스 옵티마이저가 더 효율적으로 실행 계획을 수립할 수 있도록 하는 데 있습니다.

## 실습 환경 설정

```sql
-- 제품 정보 테이블
CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

-- 고객 정보 테이블
CREATE TABLE d_customer (
  cust_id   NUMBER PRIMARY KEY,
  region    VARCHAR2(8)  NOT NULL,
  tier      VARCHAR2(8)  NOT NULL
);

-- 판매 거래 테이블
CREATE TABLE f_sales (
  sales_id  NUMBER PRIMARY KEY,
  cust_id   NUMBER NOT NULL REFERENCES d_customer(cust_id),
  prod_id   NUMBER NOT NULL REFERENCES d_product(prod_id),
  sales_dt  DATE   NOT NULL,
  qty       NUMBER NOT NULL,
  amount    NUMBER(12,2) NOT NULL
);

-- 인덱스 생성
CREATE INDEX ix_fs_cust ON f_sales(cust_id);
CREATE INDEX ix_fs_prod ON f_sales(prod_id);

-- 샘플 데이터 삽입
INSERT INTO d_product VALUES (10,'ELEC','B0');
INSERT INTO d_product VALUES (20,'HOME','B1');
INSERT INTO d_customer VALUES (1,'KOR','VIP');
INSERT INTO d_customer VALUES (2,'USA','STD');

INSERT INTO f_sales VALUES (1001,1,10,DATE '2025-02-03',1,10000);
INSERT INTO f_sales VALUES (1002,1,20,DATE '2025-02-05',2,15000);
INSERT INTO f_sales VALUES (1003,2,10,DATE '2025-02-10',1, 9000);
COMMIT;
```

## INTERSECT를 조인으로 변환: 교집합의 효율적 처리

### 기본 개념과 문제 인식

INTERSECT 연산은 두 개의 결과 집합에서 공통된 행을 찾는 작업입니다. 일반적인 INTERSECT 구현은 두 집합을 모두 정렬하고 중복을 제거한 후 비교하는 방식으로 동작하므로, 대규모 데이터에서는 상당한 정렬 비용이 발생할 수 있습니다.

```sql
-- 전통적인 INTERSECT 사용
SELECT DISTINCT s.cust_id
FROM   f_sales s 
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'ELEC'

INTERSECT

SELECT DISTINCT s.cust_id
FROM   f_sales s 
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'HOME';
```

### 세미 조인(SEMI JOIN)을 통한 최적화

INTERSECT를 EXISTS를 사용한 세미 조인으로 변환하면 성능을 크게 향상시킬 수 있습니다.

```sql
-- EXISTS를 사용한 세미 조인 변환
SELECT DISTINCT s1.cust_id
FROM   f_sales s1
JOIN   d_product p1 ON p1.prod_id = s1.prod_id
WHERE  p1.category = 'ELEC'
AND    EXISTS (
    SELECT 1
    FROM   f_sales s2
    JOIN   d_product p2 ON p2.prod_id = s2.prod_id
    WHERE  p2.category = 'HOME'
    AND    s2.cust_id = s1.cust_id
);
```

**변환의 이점:**
1. **조기 종료**: EXISTS는 첫 번째 매칭을 발견하면 즉시 종료합니다.
2. **인덱스 활용**: 적절한 인덱스가 있다면 매우 효율적으로 실행됩니다.
3. **정렬 최소화**: 대규모 정렬 작업을 피할 수 있습니다.

### INNER JOIN과 DISTINCT 조합

다른 접근 방식으로 INNER JOIN과 DISTINCT를 조합할 수도 있습니다.

```sql
-- INNER JOIN과 DISTINCT 조합
SELECT DISTINCT e.cust_id
FROM (
    SELECT DISTINCT s.cust_id
    FROM f_sales s 
    JOIN d_product p ON p.prod_id = s.prod_id
    WHERE p.category = 'ELEC'
) e
JOIN (
    SELECT DISTINCT s.cust_id
    FROM f_sales s 
    JOIN d_product p ON p.prod_id = s.prod_id
    WHERE p.category = 'HOME'
) h ON e.cust_id = h.cust_id;
```

## MINUS/EXCEPT를 조인으로 변환: 차집합의 효율적 처리

### 기본 MINUS 연산의 한계

```sql
-- 기본 MINUS 사용
SELECT DISTINCT s.cust_id
FROM   f_sales s 
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'ELEC'

MINUS

SELECT DISTINCT s.cust_id
FROM   f_sales s 
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'HOME';
```

### NOT EXISTS를 사용한 안티 조인 변환

```sql
-- NOT EXISTS를 사용한 안티 조인
SELECT DISTINCT s1.cust_id
FROM   f_sales s1
JOIN   d_product p1 ON p1.prod_id = s1.prod_id
WHERE  p1.category = 'ELEC'
AND    NOT EXISTS (
    SELECT 1
    FROM   f_sales s2
    JOIN   d_product p2 ON p2.prod_id = s2.prod_id
    WHERE  p2.category = 'HOME'
    AND    s2.cust_id = s1.cust_id
);
```

### LEFT JOIN과 IS NULL 패턴

```sql
-- LEFT JOIN과 IS NULL 패턴
SELECT DISTINCT e.cust_id
FROM (
    SELECT s.cust_id
    FROM f_sales s 
    JOIN d_product p ON p.prod_id = s.prod_id
    WHERE p.category = 'ELEC'
) e
LEFT JOIN (
    SELECT s.cust_id
    FROM f_sales s 
    JOIN d_product p ON p.prod_id = s.prod_id
    WHERE p.category = 'HOME'
) h ON e.cust_id = h.cust_id
WHERE h.cust_id IS NULL;
```

**주의사항: NOT IN의 함정**
```sql
-- 위험한 패턴: NOT IN 사용
SELECT DISTINCT s.cust_id
FROM f_sales s 
JOIN d_product p ON p.prod_id = s.prod_id
WHERE p.category = 'ELEC'
AND s.cust_id NOT IN (
    SELECT s2.cust_id
    FROM f_sales s2 
    JOIN d_product p2 ON p2.prod_id = s2.prod_id
    WHERE p2.category = 'HOME'
);
-- 서브쿼리 결과에 NULL이 포함되면 전체 결과가 공집합이 됩니다!
```

## UNION 최적화: 집합 합병의 효율적 처리

### UNION의 성능 특성 이해

```sql
-- 기본 UNION 사용
SELECT DISTINCT s.cust_id
FROM f_sales s 
JOIN d_product p ON p.prod_id = s.prod_id
WHERE p.category = 'ELEC'
UNION
SELECT DISTINCT s.cust_id
FROM f_sales s 
JOIN d_product p ON p.prod_id = s.prod_id
WHERE p.category = 'HOME';
```

### UNION ALL 최적화: 상수 테이블 조인 패턴

UNION ALL을 사용하는 쿼리가 동일 테이블을 여러 번 스캔하는 경우, 상수 테이블 조인 패턴으로 최적화할 수 있습니다.

```sql
-- 비효율적인 UNION ALL 패턴 (테이블 두 번 스캔)
SELECT 'ELEC' AS category, s.cust_id, s.amount
FROM f_sales s 
JOIN d_product p ON p.prod_id = s.prod_id
WHERE p.category = 'ELEC'
UNION ALL
SELECT 'HOME' AS category, s.cust_id, s.amount
FROM f_sales s 
JOIN d_product p ON p.prod_id = s.prod_id
WHERE p.category = 'HOME';

-- 최적화된 상수 테이블 조인 패턴 (테이블 한 번 스캔)
WITH category_list AS (
    SELECT 'ELEC' AS category FROM dual
    UNION ALL
    SELECT 'HOME' AS category FROM dual
)
SELECT cl.category, s.cust_id, s.amount
FROM category_list cl
JOIN d_product p ON p.category = cl.category
JOIN f_sales s ON s.prod_id = p.prod_id;
```

**이 패턴의 장점:**
1. **단일 테이블 스캔**: 기본 테이블을 한 번만 읽습니다.
2. **인덱스 최적화**: 옵티마이저가 각 카테고리별로 최적의 인덱스를 선택할 수 있습니다.
3. **확장성**: 카테고리가 많을수록 효과가 큽니다.

## NULL 처리의 중요성: 집합 연산과 조인의 근본적 차이

집합 연산과 조인 사이의 가장 중요한 차이점 중 하나는 NULL 값을 처리하는 방식입니다.

### NULL 동치 문제 이해

```sql
-- 집합 연산: NULL을 값으로 취급
SELECT NULL FROM dual
INTERSECT
SELECT NULL FROM dual;  -- 결과: NULL (1행)

-- 조인: NULL = NULL은 FALSE
SELECT 1
FROM (SELECT NULL AS col1 FROM dual) a
JOIN (SELECT NULL AS col2 FROM dual) b 
ON a.col1 = b.col2;  -- 결과: 공집합 (0행)
```

### 안전한 NULL 동치 조건

NULL을 포함하는 컬럼으로 집합 연산을 조인으로 변환할 때는 특별한 주의가 필요합니다.

```sql
-- 안전한 NULL 동치 조건
SELECT DISTINCT a.cust_id, a.prod_id
FROM table_a a
JOIN table_b b ON (
    (a.cust_id = b.cust_id OR (a.cust_id IS NULL AND b.cust_id IS NULL))
    AND
    (a.prod_id = b.prod_id OR (a.prod_id IS NULL AND b.prod_id IS NULL))
);

-- 실무 권장사항: 가능하면 집합 연산 키 컬럼을 NOT NULL로 정의
ALTER TABLE your_table MODIFY (key_column NOT NULL);
```

## 고급 패턴: 멀티셋 연산 에뮬레이션

Oracle의 전통적인 집합 연산은 중복을 제거하지만, 때로는 중복 개수까지 고려한 연산이 필요할 수 있습니다.

### INTERSECT ALL 에뮬레이션

```sql
-- INTERSECT ALL 에뮬레이션 (중복 개수까지 보존)
WITH numbered_a AS (
    SELECT 
        key_column,
        ROW_NUMBER() OVER (PARTITION BY key_column ORDER BY ROWID) as rn
    FROM table_a
),
numbered_b AS (
    SELECT 
        key_column,
        ROW_NUMBER() OVER (PARTITION BY key_column ORDER BY ROWID) as rn
    FROM table_b
)
SELECT a.key_column
FROM numbered_a a
JOIN numbered_b b ON a.key_column = b.key_column AND a.rn = b.rn;
```

### EXCEPT ALL 에뮬레이션

```sql
-- EXCEPT ALL 에뮬레이션
WITH numbered_a AS (
    SELECT 
        key_column,
        ROW_NUMBER() OVER (PARTITION BY key_column ORDER BY ROWID) as rn
    FROM table_a
),
numbered_b AS (
    SELECT 
        key_column,
        ROW_NUMBER() OVER (PARTITION BY key_column ORDER BY ROWID) as rn
    FROM table_b
)
SELECT a.key_column, a.rn
FROM numbered_a a
LEFT JOIN numbered_b b ON a.key_column = b.key_column AND a.rn = b.rn
WHERE b.key_column IS NULL;
```

## 실전 시나리오 분석

### 복잡한 비즈니스 요구사항 해결

**시나리오**: "ELEC과 HOME 제품을 모두 구매한 고객 중, 최근 한 달 동안의 구매 내역 분석"

```sql
-- 원본 접근 방식 (집합 연산 사용)
SELECT 
    s.cust_id,
    MAX(s.sales_dt) as last_purchase_date,
    SUM(s.amount) as total_amount
FROM f_sales s
WHERE s.cust_id IN (
    SELECT DISTINCT s1.cust_id
    FROM f_sales s1 
    JOIN d_product p1 ON p1.prod_id = s1.prod_id
    WHERE p1.category = 'ELEC'
    INTERSECT
    SELECT DISTINCT s2.cust_id
    FROM f_sales s2 
    JOIN d_product p2 ON p2.prod_id = s2.prod_id
    WHERE p2.category = 'HOME'
)
AND s.sales_dt >= ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -1)
GROUP BY s.cust_id;

-- 최적화된 접근 방식 (조인 변환)
WITH customer_categories AS (
    SELECT 
        s.cust_id,
        MAX(CASE WHEN p.category = 'ELEC' THEN 1 ELSE 0 END) as has_elec,
        MAX(CASE WHEN p.category = 'HOME' THEN 1 ELSE 0 END) as has_home
    FROM f_sales s
    JOIN d_product p ON p.prod_id = s.prod_id
    GROUP BY s.cust_id
    HAVING MAX(CASE WHEN p.category = 'ELEC' THEN 1 ELSE 0 END) = 1
       AND MAX(CASE WHEN p.category = 'HOME' THEN 1 ELSE 0 END) = 1
)
SELECT 
    s.cust_id,
    MAX(s.sales_dt) as last_purchase_date,
    SUM(s.amount) as total_amount
FROM f_sales s
JOIN customer_categories cc ON cc.cust_id = s.cust_id
WHERE s.sales_dt >= ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -1)
GROUP BY s.cust_id;
```

## 성능 측정과 검증 방법론

### 실행 계획 분석

```sql
-- 상세 실행 계획 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, 
    NULL, 
    'ALLSTATS LAST +PREDICATE +NOTE +ALIAS'
));

-- TEMP 사용량 확인이 포함된 실행 계획
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, 
    NULL, 
    'ALLSTATS LAST +MEMSTATS'
));
```

### 성능 통계 비교

```sql
-- 성능 통계 캡처를 위한 함수
CREATE OR REPLACE PROCEDURE compare_performance(
    p_query1 IN VARCHAR2,
    p_query2 IN VARCHAR2
) IS
    TYPE stat_rec IS RECORD (
        name VARCHAR2(64),
        value1 NUMBER,
        value2 NUMBER
    );
    
    TYPE stat_table IS TABLE OF stat_rec;
    
    v_stats stat_table;
    v_start_time TIMESTAMP;
    v_end_time TIMESTAMP;
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== 성능 비교 시작 ===');
    
    -- 첫 번째 쿼리 실행
    v_start_time := SYSTIMESTAMP;
    EXECUTE IMMEDIATE p_query1;
    v_end_time := SYSTIMESTAMP;
    DBMS_OUTPUT.PUT_LINE('쿼리 1 실행 시간: ' || 
        EXTRACT(SECOND FROM (v_end_time - v_start_time)) || '초');
    
    -- 두 번째 쿼리 실행
    v_start_time := SYSTIMESTAMP;
    EXECUTE IMMEDIATE p_query2;
    v_end_time := SYSTIMESTAMP;
    DBMS_OUTPUT.PUT_LINE('쿼리 2 실행 시간: ' || 
        EXTRACT(SECOND FROM (v_end_time - v_start_time)) || '초');
    
    DBMS_OUTPUT.PUT_LINE('=== 성능 비교 완료 ===');
END;
/

-- 쿼리 결과 정확성 검증
CREATE OR REPLACE FUNCTION verify_equivalence(
    p_query1 IN VARCHAR2,
    p_query2 IN VARCHAR2
) RETURN BOOLEAN IS
    v_count1 NUMBER;
    v_count2 NUMBER;
    v_diff_count NUMBER;
BEGIN
    -- 각 쿼리의 행 수 확인
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM (' || p_query1 || ')' INTO v_count1;
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM (' || p_query2 || ')' INTO v_count2;
    
    IF v_count1 != v_count2 THEN
        DBMS_OUTPUT.PUT_LINE('행 수 불일치: ' || v_count1 || ' vs ' || v_count2);
        RETURN FALSE;
    END IF;
    
    -- 대칭 차집합 확인
    EXECUTE IMMEDIATE 
        'SELECT COUNT(*) FROM ((' || p_query1 || ' MINUS ' || p_query2 || 
        ') UNION ALL (' || p_query2 || ' MINUS ' || p_query1 || '))' 
        INTO v_diff_count;
    
    IF v_diff_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('내용 불일치: ' || v_diff_count || '행 차이');
        RETURN FALSE;
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('쿼리 결과가 동일합니다.');
    RETURN TRUE;
END;
/
```

## 최적화 지침과 모범 사례

### 상황별 최적 전략 선택 가이드

| 상황 | 권장 전략 | 이유 |
|------|-----------|------|
| **교집합(INTERSECT)** | EXISTS 세미 조인 | 조기 종료 가능, 인덱스 활용 최적 |
| **차집합(MINUS)** | NOT EXISTS 안티 조인 | NULL 안전성, 조인 순서 유연성 |
| **합집합 중복 제거(UNION)** | 원본 UNION 유지 | 간결성, 옵티마이저 최적화 신뢰 |
| **합집합 중복 허용(UNION ALL)** | 상수 테이블 조인 | 단일 테이블 스캔, 확장성 우수 |
| **NULL 포함 키** | NOT NULL 제약 추가 또는 특수 동치 조건 | 복잡성 감소, 버그 예방 |

### 인덱스 설계 권장사항

```sql
-- 집합 연산 최적화를 위한 인덱스 설계
-- 1. EXISTS/NOT EXISTS 최적화를 위한 인덱스
CREATE INDEX ix_sales_cust_prod ON f_sales(cust_id, prod_id);

-- 2. 카테고리 기반 필터링을 위한 인덱스
CREATE INDEX ix_product_category ON d_product(category, prod_id);

-- 3. 복합 조건 최적화를 위한 함수 기반 인덱스
CREATE INDEX ix_sales_cust_category ON f_sales(
    cust_id,
    (SELECT p.category FROM d_product p WHERE p.prod_id = f_sales.prod_id)
);
```

### 힌트 사용 지침

```sql
-- 세미 조인 힌트
SELECT /*+ SEMIJOIN */ ...
FROM table1 t1
WHERE EXISTS (SELECT 1 FROM table2 t2 WHERE ...);

-- 안티 조인 힌트  
SELECT /*+ ANTIJOIN */ ...
FROM table1 t1
WHERE NOT EXISTS (SELECT 1 FROM table2 t2 WHERE ...);

-- 조인 순서 힌트
SELECT /*+ LEADING(small_table large_table) USE_HASH(large_table) */ ...
FROM small_table, large_table
WHERE ...;

-- 뷰 병합 제어
WITH base_data AS (
    SELECT /*+ MATERIALIZE */ ...  -- 임시 테이블로 구체화
)
SELECT ... FROM base_data;
```

## 종합적 접근법과 마무리

집합 연산을 조인으로 변환하는 기술은 단순한 성능 최적화를 넘어, 데이터 처리 패턴에 대한 깊은 이해를 요구합니다. 효과적인 변환을 위해서는 다음 원칙들을 준수해야 합니다:

### 핵심 원칙 요약

1. **목적에 맞는 변환 선택**: 모든 집합 연산을 무조건 조인으로 변환하는 것이 최선은 아닙니다. 상황에 맞는 최적의 패턴을 선택하세요.

2. **NULL 처리의 중요성 인식**: 집합 연산과 조인 사이의 가장 큰 차이점은 NULL 처리 방식입니다. 이를 간과하면 정확하지 않은 결과를 얻게 됩니다.

3. **성능 측정 기반 접근**: 변환의 효과는 데이터 특성, 인덱스 구성, 시스템 자원에 따라 달라집니다. 항상 실제 성능 측정을 통해 검증하세요.

4. **인덱스 설계와의 연계**: 집합 연산 최적화는 적절한 인덱스 설계와 함께 고려되어야 합니다. EXISTS/NOT EXISTS 패턴은 특히 인덱스 활용에 민감합니다.

5. **비즈니스 요구사항 이해**: 기술적 최적화는 항상 비즈니스 요구사항을 충족해야 합니다. 과도한 최적화로 인해 유지보수성을 해치지 마세요.

### 실전 적용을 위한 체크리스트

- [ ] 변환 전후 결과의 논리적 동등성 검증 완료
- [ ] NULL 값이 있는 컬럼의 특별 처리 적용
- [ ] 실행 계획 분석을 통한 성능 개선 효과 확인
- [ ] 적절한 인덱스 존재 여부 확인 및 필요시 생성
- [ ] 대용량 데이터셋에서의 성능 테스트 수행
- [ ] 애플리케이션 코드와의 호환성 검증

### 최종 조언: 균형 잡힌 접근

집합 연산을 조인으로 변환하는 것은 강력한 최적화 도구이지만, 이것이 만능 해결책은 아닙니다. 때로는 원본 집합 연산이 더 간결하고 이해하기 쉽습니다. 또한 최신 Oracle 버전의 옵티마이저는 집합 연산에 대한 최적화를 지속적으로 개선하고 있습니다.

가장 중요한 것은 "왜 이 변환이 필요한가?"를 이해하는 것입니다. 성능 문제가 명확히 관찰되고, 변환이 측정 가능한 개선을 가져올 때만 적용하세요. 모든 최적화 결정은 데이터의 특성, 비즈니스 요구사항, 시스템 환경을 종합적으로 고려하여 이루어져야 합니다.

이 가이드가 제시한 패턴들과 원칙들을 바탕으로, 실제 문제에 창의적으로 적용하며 데이터베이스 성능 최적화의 전문가로 성장하시기 바랍니다. 기억하세요, 진정한 전문가는 기술적 솔루션을 적용하는 능력뿐만 아니라, 언제 적용하지 말아야 할지 판단하는 지혜도 갖추고 있습니다.