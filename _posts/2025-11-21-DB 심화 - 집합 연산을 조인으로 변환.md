---
layout: post
title: DB 심화 - 집합 연산을 조인으로 변환
date: 2025-11-21 17:25:23 +0900
category: DB 심화
---
# 집합 연산을 조인으로 변환

> **핵심 요약**
> - **INTERSECT** ⇢ **세미 조인( EXISTS )** 또는 **INNER JOIN + DISTINCT**
> - **MINUS/EXCEPT** ⇢ **안티 조인( NOT EXISTS / LEFT JOIN … IS NULL )**
> - **UNION** ⇢ **FULL OUTER JOIN + COALESCE** (동치 집합을 만들 수 있으나 일반적으론 `UNION`이 더 간단)
> - **UNION ALL** ⇢ 일반적으로 조인으로 “동치 변환”은 안 됨. 하지만 **상수 테이블 조인**으로 *두 번 스캔 → 한 번 스캔* 최적화가 가능한 패턴이 많음.
>
> **주의(정확성):** 집합 연산은 **NULL을 값처럼 취급**(NULL = NULL)해 **중복 제거/비교**를 수행하는 반면, 조인은 **NULL = NULL이 FALSE**다.
> 조인 변환 시에는 `a.col = b.col OR (a.col IS NULL AND b.col IS NULL)` 같은 **NULL-동치** 조건이 필요할 수 있다.

---

## 준비 스키마

```sql
-- 차원
CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

CREATE TABLE d_customer (
  cust_id   NUMBER PRIMARY KEY,
  region    VARCHAR2(8)  NOT NULL,
  tier      VARCHAR2(8)  NOT NULL
);

-- 사실
CREATE TABLE f_sales (
  sales_id  NUMBER PRIMARY KEY,
  cust_id   NUMBER NOT NULL REFERENCES d_customer(cust_id),
  prod_id   NUMBER NOT NULL REFERENCES d_product(prod_id),
  sales_dt  DATE   NOT NULL,
  qty       NUMBER NOT NULL,
  amount    NUMBER(12,2) NOT NULL
);

CREATE INDEX ix_fs_cust ON f_sales(cust_id);
CREATE INDEX ix_fs_prod ON f_sales(prod_id);

-- 샘플
INSERT INTO d_product VALUES (10,'ELEC','B0');
INSERT INTO d_product VALUES (20,'HOME','B1');
INSERT INTO d_customer VALUES (1,'KOR','VIP');
INSERT INTO d_customer VALUES (2,'USA','STD');

INSERT INTO f_sales VALUES (1001,1,10,DATE '2025-02-03',1,10000);
INSERT INTO f_sales VALUES (1002,1,20,DATE '2025-02-05',2,15000);
INSERT INTO f_sales VALUES (1003,2,10,DATE '2025-02-10',1, 9000);
COMMIT;
```

---

## INTERSECT  →  조인/세미조인

### “두 집합의 교집합”: 같은 고객이 **ELEC도 사고 HOME도 샀다**

**집합 연산 버전**
```sql
-- (A) ELEC 구매 고객
SELECT DISTINCT s.cust_id
FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'ELEC'

INTERSECT

-- (B) HOME 구매 고객
SELECT DISTINCT s.cust_id
FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'HOME';
```

**세미 조인( EXISTS ) 동치**
```sql
-- INTERSECT ⇢ "둘 다 존재" 조건
SELECT /*+ SEMIJOIN */ DISTINCT s1.cust_id
FROM   f_sales s1
JOIN   d_product p1 ON p1.prod_id = s1.prod_id
WHERE  p1.category = 'ELEC'
AND    EXISTS (
         SELECT 1
         FROM   f_sales s2
         JOIN   d_product p2 ON p2.prod_id = s2.prod_id
         WHERE  p2.category = 'HOME'
         AND    s2.cust_id  = s1.cust_id
       );
```
**장점**
- 옵티마이저가 **SEMI JOIN**(해시/네스티드 루프)으로 만들어 **두 번째 집합을 일찍 프루닝**.
- `INTERSECT`는 내부적으로 **SORT/UNIQUE** 또는 **HASH**를 요구할 수 있는데, `EXISTS`는 **인덱스**를 탄 **점검**으로 끝나기도 한다.

**INNER JOIN + DISTINCT 동치**
```sql
SELECT /*+ USE_HASH(e h) */ DISTINCT e.cust_id
FROM (
  SELECT DISTINCT s.cust_id
  FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
  WHERE  p.category = 'ELEC'
) e
JOIN (
  SELECT DISTINCT s.cust_id
  FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
  WHERE  p.category = 'HOME'
) h
ON e.cust_id = h.cust_id;
```

### 다중 컬럼 교집합 + NULL 동치 주의

**문제 상황**: `INTERSECT`는 `(cust_id, prod_id)` 두 컬럼 기준 **NULL도 동일 값처럼** 취급한다.
**조인 변환 시** 다음처럼 해야 정확성이 맞다:

```sql
-- INTERSECT (cust_id, prod_id) 동치 조인
SELECT DISTINCT e.cust_id, e.prod_id
FROM   A e
JOIN   B h
ON ( (e.cust_id = h.cust_id OR (e.cust_id IS NULL AND h.cust_id IS NULL))
 AND  (e.prod_id = h.prod_id OR (e.prod_id IS NULL AND h.prod_id IS NULL)) );
```

> **팁**: 실제 업무에서는 교집합 키 컬럼들을 **NOT NULL** 로 설계하는 편이 많아 위의 복잡한 동치 조건이 필요 없는 경우가 대부분.

---

## MINUS/EXCEPT  →  안티 조인

### “ELEC 구매 고객 **중에서** HOME은 **안 산** 고객”

**집합 연산 버전**
```sql
SELECT DISTINCT s.cust_id
FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'ELEC'

MINUS

SELECT DISTINCT s.cust_id
FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'HOME';
```

**안티 조인( NOT EXISTS ) 동치**
```sql
SELECT /*+ ANTIJOIN */ DISTINCT s1.cust_id
FROM   f_sales s1
JOIN   d_product p1 ON p1.prod_id = s1.prod_id
WHERE  p1.category = 'ELEC'
AND    NOT EXISTS (
         SELECT 1
         FROM   f_sales s2
         JOIN   d_product p2 ON p2.prod_id = s2.prod_id
         WHERE  p2.category = 'HOME'
         AND    s2.cust_id  = s1.cust_id
       );
```

**LEFT JOIN … IS NULL 동치**
```sql
SELECT DISTINCT e.cust_id
FROM (
  SELECT s.cust_id
  FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
  WHERE  p.category = 'ELEC'
) e
LEFT JOIN (
  SELECT s.cust_id
  FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
  WHERE  p.category = 'HOME'
) h
ON e.cust_id = h.cust_id
WHERE h.cust_id IS NULL;
```

> **주의( NOT IN 함정 )**
> `WHERE e.cust_id NOT IN (SELECT cust_id FROM …)` 패턴에서 서브쿼리가 **NULL**을 포함하면 결과가 **공집합**이 된다.
> **항상 `NOT EXISTS`** 또는 **LEFT JOIN … IS NULL**을 사용하자.

### 다중 컬럼 차집합 + NULL 동치

```sql
-- A(cust_id, prod_id) - B(cust_id, prod_id)
SELECT DISTINCT a.cust_id, a.prod_id
FROM   A a
LEFT   JOIN B b
  ON ( (a.cust_id = b.cust_id OR (a.cust_id IS NULL AND b.cust_id IS NULL))
   AND (a.prod_id = b.prod_id OR (a.prod_id IS NULL AND b.prod_id IS NULL)) )
WHERE  b.cust_id IS NULL;  -- 매칭이 전혀 없을 때만 남김
```

---

## UNION  →  FULL OUTER JOIN(+ COALESCE) / 한 번 스캔 최적화

### “ELEC 고객” **∪** “HOME 고객” (중복 제거)

**집합 연산 버전**
```sql
SELECT DISTINCT s.cust_id
FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'ELEC'
UNION
SELECT DISTINCT s.cust_id
FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'HOME';
```

**FULL OUTER JOIN 동치**
```sql
WITH e AS (
  SELECT DISTINCT s.cust_id FROM f_sales s JOIN d_product p ON p.prod_id = s.prod_id
  WHERE p.category = 'ELEC'
),
h AS (
  SELECT DISTINCT s.cust_id FROM f_sales s JOIN d_product p ON p.prod_id = s.prod_id
  WHERE p.category = 'HOME'
)
SELECT COALESCE(e.cust_id, h.cust_id) AS cust_id
FROM   e
FULL   OUTER JOIN h
  ON   e.cust_id = h.cust_id;
```
- `UNION`은 중복 제거가 필요해 **SORT/UNIQUE** 또는 **HASH**가 들어간다.
- FULL OUTER JOIN도 내부적으로 해시/정렬을 사용할 수 있으므로 **항상** 빠르다고 할 수는 없다.
- 실무에선 `UNION`이 간단·안전한 기본값이며, FOJ 동치는 **키/카디널리티 특성**에 따라 선택.

### “두 번 스캔 → 한 번 스캔” (상수 테이블 조인으로 `UNION ALL` 대체)

**문제**: 아래 `UNION ALL`은 `f_sales`를 **두 번** 스캔한다.
```sql
SELECT 'ELEC' AS cat, s.cust_id
FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'ELEC'
UNION ALL
SELECT 'HOME' AS cat, s.cust_id
FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'HOME';
```

**개선(상수 테이블 조인)**: *한 번 스캔* + **OR → 조인조건**
```sql
WITH cats AS (
  SELECT 'ELEC' AS category FROM dual
  UNION ALL
  SELECT 'HOME'           FROM dual
)
SELECT c.category, s.cust_id
FROM   cats c
JOIN   d_product p ON p.category = c.category
JOIN   f_sales s   ON s.prod_id  = p.prod_id;
```
- `cats`는 2행. `f_sales`/`d_product`는 **한 번**만 접근.
- 옵티마이저는 `cats`를 **드라이빙**하여 각 카테고리별로 **인덱스 범위 스캔**을 유도할 수 있다.
- 이 패턴은 “조건 값 리스트별로 `UNION ALL` 분기”를 **상수-차원 조인**으로 바꾸는 **실전 최적화**다.

---

## 성능 관점: 언제 조인이 유리한가?

1) **INTERSECT ⇢ EXISTS**
   - 두 번째 집합을 **존재 여부만 검사**하므로, **인덱스** + **세미조인**으로 매우 효율적.
   - 특히 중복 제거가 큰 비용일 때 유리.

2) **MINUS ⇢ NOT EXISTS / LEFT … IS NULL**
   - **안티조인**은 조기 프루닝에 강함.
   - `NOT IN`의 NULL 함정 회피.

3) **UNION ALL ⇢ 상수 테이블 조인**
   - 동일 테이블을 여러 번 스캔하는 패턴을 **한 번 스캔**으로 바꾸는 고전 팁.

4) **UNION ⇢ FOJ**
   - 상황에 따라 이득이 있을 수 있으나, 대부분 **그냥 UNION**이 단순·안전.
   - FOJ로 바꾸면 **NULL 동치/투영**을 섬세히 맞춰야 해서 복잡도↑

**플랜/통계 비교 루틴**
```sql
-- 실행 후
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +NOTE'));

-- 세션 통계
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN ('session logical reads','physical reads','sorts (memory)','sorts (disk)');
```

---

## “정확성” 디테일: 집합 vs 조인, **NULL 동치** 차이

집합 연산의 **동등성**은 수학적 집합 동치로, **NULL도 값으로 취급**하여 **중복 판단**/교집합·차집합을 계산한다.
반면 SQL 비교(`=`)는 **NULL = NULL이 FALSE** 이므로, 조인에서 **그냥 `=`만 쓰면 결과가 달라질 수 있다.**

**안전한 동치 조건 템플릿(두 컬럼 예)**

```sql
-- 동치(= 또는 둘 다 NULL)
( a.c1 = b.c1 OR (a.c1 IS NULL AND b.c1 IS NULL) )
AND
( a.c2 = b.c2 OR (a.c2 IS NULL AND b.c2 IS NULL) )
```

> **현업 팁**: 교집합/차집합 키 컬럼을 **NOT NULL** 로 강제하는 모델링을 선호하는 이유 중 하나가
> 이런 **NULL 동치** 처리 복잡성을 줄이기 위해서다.

---

## 고급: 중복(멀티셋)까지 보전( INTERSECT ALL / EXCEPT ALL 유사 )

Oracle(전통)에는 `INTERSECT ALL`, `EXCEPT ALL`이 없었지만, “중복의 개수”까지 반영하려면 **번호 매기기 + 조인**으로 에뮬레이트 가능하다.

### INTERSECT ALL 에뮬레이션

```sql
WITH a AS (
  SELECT x.*, ROW_NUMBER() OVER (PARTITION BY key1, key2 ORDER BY ROWID) AS rn
  FROM   A x
),
b AS (
  SELECT y.*, ROW_NUMBER() OVER (PARTITION BY key1, key2 ORDER BY ROWID) AS rn
  FROM   B y
)
SELECT a.key1, a.key2
FROM   a JOIN b
  ON   a.key1 = b.key1
 AND   a.key2 = b.key2
 AND   a.rn   = b.rn;   -- 각 중복의 "순번"을 맞춰 교집합 개수를 정확히 보전
```

### ALL 에뮬레이션

```sql
WITH a AS (
  SELECT x.*, ROW_NUMBER() OVER (PARTITION BY key1, key2 ORDER BY ROWID) AS rn
  FROM   A x
),
b AS (
  SELECT y.*, ROW_NUMBER() OVER (PARTITION BY key1, key2 ORDER BY ROWID) AS rn
  FROM   B y
)
SELECT a.key1, a.key2
FROM   a
LEFT   JOIN b
  ON   a.key1 = b.key1
 AND   a.key2 = b.key2
 AND   a.rn   = b.rn
WHERE  b.rn IS NULL;  -- A의 중복 개수에서 B의 중복 개수를 뺀 결과
```

> 위 에뮬은 **멀티셋 의미**가 꼭 필요할 때만 사용. 대부분의 DW/리포트는 **DISTINCT 집합**이면 충분하다.

---

## 실전 시나리오

### “지난달에 ELEC과 HOME 둘 다 산 고객의 최신 구매일”

- **원래(집합)**

```sql
SELECT cust_id, MAX(sales_dt) AS last_dt
FROM   f_sales
WHERE  cust_id IN (
         SELECT DISTINCT s.cust_id
         FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
         WHERE  p.category = 'ELEC'
         INTERSECT
         SELECT DISTINCT s.cust_id
         FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
         WHERE  p.category = 'HOME'
       )
AND    sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -1)
GROUP  BY cust_id;
```

- **조인(세미조인) 변환**

```sql
WITH both AS (
  SELECT /* 고객이 두 카테고리를 모두 가졌는지 플래그화 */
         s.cust_id,
         MAX(CASE WHEN p.category='ELEC' THEN 1 END) AS has_elec,
         MAX(CASE WHEN p.category='HOME' THEN 1 END) AS has_home
  FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id
  GROUP  BY s.cust_id
)
SELECT s.cust_id, MAX(s.sales_dt) AS last_dt
FROM   f_sales s
JOIN   both b ON b.cust_id = s.cust_id
WHERE  b.has_elec = 1 AND b.has_home = 1
AND    s.sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -1)
GROUP  BY s.cust_id;
```

- 또는 **EXISTS 두 번**:

```sql
SELECT s.cust_id, MAX(s.sales_dt) AS last_dt
FROM   f_sales s
WHERE  EXISTS (SELECT 1
               FROM f_sales s1 JOIN d_product p1 ON p1.prod_id=s1.prod_id
               WHERE p1.category='ELEC' AND s1.cust_id=s.cust_id)
AND    EXISTS (SELECT 1
               FROM f_sales s2 JOIN d_product p2 ON p2.prod_id=s2.prod_id
               WHERE p2.category='HOME' AND s2.cust_id=s.cust_id)
AND    s.sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -1)
GROUP  BY s.cust_id;
```

**포인트**: 교집합을 세미조인으로 바꾸면 **조인 순서/인덱스 사용** 최적화가 쉬워지고,
큰 정렬/해시로 인한 **TEMP I/O**를 피하기 좋다.

### “ELEC 산 고객에서 HOME 산 고객을 빼고, 그 고객의 월 매출”

- **집합(MINUS)**
```sql
WITH elec AS (
  SELECT DISTINCT s.cust_id
  FROM f_sales s JOIN d_product p ON p.prod_id=s.prod_id
  WHERE p.category='ELEC'
),
home AS (
  SELECT DISTINCT s.cust_id
  FROM f_sales s JOIN d_product p ON p.prod_id=s.prod_id
  WHERE p.category='HOME'
)
SELECT d.yyyymm, SUM(s.amount)
FROM   f_sales s JOIN d_date d ON d.dt = s.sales_dt
WHERE  s.cust_id IN (SELECT cust_id FROM elec MINUS SELECT cust_id FROM home)
GROUP  BY d.yyyymm;
```

- **안티조인 변환**
```sql
WITH home AS (
  SELECT /*+ MATERIALIZE */ DISTINCT s.cust_id
  FROM   f_sales s JOIN d_product p ON p.prod_id=s.prod_id
  WHERE  p.category='HOME'
)
SELECT d.yyyymm, SUM(s.amount)
FROM   f_sales s
JOIN   d_date d ON d.dt = s.sales_dt
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  p.category='ELEC'
AND    NOT EXISTS (SELECT 1 FROM home h WHERE h.cust_id = s.cust_id)
GROUP  BY d.yyyymm;
```
- `home`을 **머터리얼라이즈** 해두면, `f_sales` 스캔 중 **고객 단위로 빠른 배제**가 가능.

### “카테고리 두 개를 레이블까지 붙여 UNION ALL” → **상수 조인 최적화**

```sql
-- Before: UNION ALL 두 번 스캔
SELECT 'ELEC' AS cat, s.cust_id, SUM(s.amount)
FROM   f_sales s JOIN d_product p ON p.prod_id=s.prod_id
WHERE  p.category='ELEC'
GROUP  BY s.cust_id
UNION ALL
SELECT 'HOME', s.cust_id, SUM(s.amount)
FROM   f_sales s JOIN d_product p ON p.prod_id=s.prod_id
WHERE  p.category='HOME'
GROUP  BY s.cust_id;

-- After: cats(2행) 드라이빙 → 한 번 스캔
WITH cats AS (
  SELECT 'ELEC' category FROM dual
  UNION ALL
  SELECT 'HOME'          FROM dual
)
SELECT c.category, s.cust_id, SUM(s.amount)
FROM   cats c
JOIN   d_product p ON p.category=c.category
JOIN   f_sales s   ON s.prod_id = p.prod_id
GROUP  BY c.category, s.cust_id;
```

---

## 힌트/옵션과 변환 시 주의

- **세미/안티 조인 힌트**: `/*+ SEMIJOIN */`, `/*+ ANTIJOIN */` (버전에 따라 다름. 보통은 `EXISTS`/`NOT EXISTS`가 자연스럽게 변환됨)
- **조인 순서**: 필요 시 `LEADING`, `USE_NL`, `USE_HASH` 적극 활용.
- **뷰/CTE 머징**: `/*+ MATERIALIZE */`, `/*+ INLINE */` 로 적절히 제어 (리스트 집합/상수 테이블은 머터리얼라이즈가 유리한 경우 多).
- **NULL 동치**: 집합 ↔ 조인 변환 시 **NULL 처리** 누락이 가장 흔한 버그. (NOT IN 금지!)
- **통계/카디널리티**: `INTERSECT/MINUS`는 종종 큰 **정렬/해시**를 유발 → 조인 변환이 **메모리 압박/TEMP I/O**를 줄일 수 있다.

---

## 검증 체크리스트

- [ ] **행 개수/내용 동일성 테스트**: 변환 전/후 결과 `MINUS`로 상호 검증
```sql
-- A: 원문 결과, B: 변환 결과라고 할 때
( A MINUS B ) UNION ALL ( B MINUS A );  -- 0행이면 동치
```
- [ ] **NULL 처리 확인**: 키 컬럼에 NULL이 가능한지? 가능하면 **동치 조건** 반영했는지?
- [ ] **플랜 비교**: `DBMS_XPLAN.DISPLAY_CURSOR('ALLSTATS LAST')`로 읽기량/정렬 감소 확인
- [ ] **세션 통계 비교**: `session logical reads`, `physical reads`, `sorts(*)` 감소 여부
- [ ] **경계 데이터**: 중복 다량/없음·전부/공집합 케이스로 테스트

---

## 요약 표

| 집합 연산 | 조인/패턴 | 핵심 포인트 |
|---|---|---|
| `INTERSECT` | `EXISTS`(세미 조인) 또는 `INNER JOIN + DISTINCT` | 정렬/해시 비용 대신 조기 프루닝. NULL 동치 고려 |
| `MINUS/EXCEPT` | `NOT EXISTS`(안티 조인) 또는 `LEFT JOIN … IS NULL` | `NOT IN`(NULL 함정) 금지. 안티조인 인덱스 설계 중요 |
| `UNION` | `FULL OUTER JOIN + COALESCE` | 동치 가능하나 일반적으론 `UNION`이 단순. 필요시만 |
| `UNION ALL` | (동치 없음) but **상수 테이블 조인**으로 “두 번 스캔→한 번 스캔” | 분기 수↑일수록 효과↑. 작은 드라이빙 테이블 추천 |

---

### 맺음말

- **교집합/차집합**은 실무에서 **세미/안티 조인** 변환으로 **체감 성능**을 크게 올리는 대표 사례다.
- **UNION ALL 분기 최적화**(상수 테이블 조인)는 대시보드·리포트에서 강력한 패턴.
- 변환 시에는 **NULL 동치·중복 의미**를 반드시 점검하고, **플랜/통계**로 개선 효과를 확인하자.
