---
layout: post
title: TCPIP - 현대 웹 트래픽의 흐름
date: 2025-09-04 15:25:23 +0900
category: TCPIP
---
# 11. 현대 웹 트래픽의 흐름
**(🔰 HTTP/1.1 vs HTTP/2: 멀티플렉싱·헤더 압축, ⚙️ HTTP/3 & QUIC(UDP 기반) 큰 그림, ⚙️ CDN/Anycast·캐싱·연결 재사용/풀링, 🚀 0-RTT·세션 재개·성능·보안 트레이드오프)**

> 이 글은 **브라우저 ↔ 엣지 ↔ 오리진**을 지나가는 현대 웹 트래픽을 **프로토콜·경로·성능·보안** 관점에서 풀어냅니다.  
> HTTP/1.1→HTTP/2→HTTP/3(QUIC)의 변화를 **핵심 설계 목표: 지연 감소·혼잡 친화·대역폭 효율**로 엮고, **CDN/Anycast·캐싱·연결 풀**과 **0-RTT/세션 재개**의 **성능↔보안** 절충까지 예제와 체크리스트로 정리합니다.  
> 코드·헤더·명령은 ```로, 수식은 MathJax로 표기합니다.

---

## 11.1 웹 요청 한 건이 지나가는 기본 여정

```
브라우저
  ├─ DNS 해석(재귀 캐시 → 권한)
  ├─ (필요 시) TLS/전송 연결 성립
  ├─ 요청 전송(헤더+바디) / 응답 수신
  ├─ 추가 리소스(HTML 파싱→CSS/JS/이미지) 동시/병렬 처리
  └─ 캐시/프리로드/프리커넥트 등 최적화
        │
        ▼
   (Anycast) CDN 엣지 ←→ 오리진(또는 또 다른 캐시 계층)
```

**TTFB(Time-to-First-Byte)** 직관:
\[
\text{TTFB} \approx T_{\text{DNS}} + T_{\text{connect}} + T_{\text{handshake}} + \text{RTT}_{\text{req}}
\]
- HTTP/1.1(TLS1.3): `connect=TCP 1 RTT`, `handshake=TLS 1 RTT` → **2 RTT + DNS + 요청RTT**  
- HTTP/3(QUIC): QUIC+TLS 통합 → **1 RTT + DNS + 요청RTT** (재개/0-RTT면 더 짧음)

---

## 11.2 HTTP/1.1 vs HTTP/2 (🔰)

### 11.2.1 HTTP/1.1의 한계와 개선
- **지속 연결(keep-alive)**: 하나의 TCP 연결에서 여러 요청·응답을 순차 처리.
- **파이프라이닝**(이론상 병렬) → **헤드-오브-라인(HoL) 블로킹**과 중간 장비 호환성 문제로 사실상 비권장.
- **커넥션 폭증**: 브라우저는 오리진당 여러 TCP(과거 6개 내외)를 열어 병렬성 확보 → **핸드셰이크·혼잡창 분산·큐잉 비효율**.

### 11.2.2 HTTP/2 핵심
- **한 커넥션 다중 스트림 멀티플렉싱**: 하나의 TLS/TCP 위에서 **Stream ID**별로 **동시에** 요청/응답 흐름.
- **HPACK 헤더 압축**: 정적/동적 테이블 + 허프만으로 **중복 헤더** 최소화.
- **흐름제어/우선순위**: 스트림·커넥션 레벨 윈도우, 리소스 중요도 힌트.

**효과**
- 커넥션 수 급감(보통 1~2개) → 핸드셰이크/혼잡창 공유로 **지연↓/공정성↑**.
- 그러나 **TCP 레벨 HoL 블로킹**은 여전: **패킷 손실 시** 해당 TCP 연결의 **모든 스트림**이 재전송 완료까지 막힘.

### 11.2.3 HPACK 한눈
- **정적 테이블**(자주 쓰는 헤더 이름/값) + **동적 테이블**(세션 내 학습).  
- “:method”, “:scheme”, “:authority” 같은 **의미 헤더**를 바이너리 인덱싱.

### 11.2.4 HTTP/2 요청/응답 예(개념)
```
(하나의 TLS 커넥션)
Stream 1: GET /index.html  ──────────────►
          ◄────────────── 200 + HTML
Stream 3: GET /main.css    ──────────────►
          ◄────────────── 200 + CSS
Stream 5: GET /app.js      ──────────────►
          ◄────────────── 200 + JS
```

> **실무 메모**: HTTP/2의 “서버 푸시”는 브라우저에서 제한/축소되어 **점차 비권장** 경향. 대신 **Early Hints(103)**, **preload**를 쓰는 흐름이 보편.

---

## 11.3 HTTP/3 & QUIC 큰 그림 (⚙️)

### 11.3.1 왜 QUIC인가
- **TCP HoL 블로킹 제거**: **스트림이 전송 계층에 내재**(QUIC 스트림)되어 **한 스트림 손실이 다른 스트림을 막지 않음**.
- **핸드셰이크 단축**: QUIC은 **TLS 1.3을 자체에 내장** → **1-RTT** 성립(재개/0-RTT 지원).
- **연결 이식성**: **Connection ID**로 네트워크 변경(Wi-Fi↔LTE)·NAT 리바인딩에도 **연결 유지**.
- **유저 공간 구현**: 커널 패치 없이 **배포/진화 빠름**.

### 11.3.2 QUIC 구조 빠르게
- **UDP 기반**(포트는 다양, 흔히 443/UDP).  
- **패킷 번호 공간**: Initial/Handshake/1-RTT로 분리.  
- **스트림**: **바이트 스트림**(uni/bi-directional).  
- **암호화**: TLS 1.3 키를 **패킷 보호**에 바로 사용(AEAD).  
- **손실 복구**: **RACK-유사** 시간 기반, **PTO(Probe Timeout)** 등.

### 11.3.3 QPACK(HTTP/3 헤더 압축)
- HPACK의 “헤더 블로킹” 문제를 완화: **비동기 참조**로 요청 지연 최소화.  
- **Encoder/Decoder 스트림** 별도 운영 → 동기화 지연 완화.

### 11.3.4 H3 타임라인 vs H2
```
# H2(TLS1.3 over TCP):  TCP 1-RTT + TLS 1-RTT + Req/Resp
# H3(QUIC):            QUIC(TLS내장) 1-RTT + Req/Resp
# H3 0-RTT 재개:       (가능하면) 즉시 Req/Resp
```

### 11.3.5 UDP/MTU 주의
- 인터넷/모바일 경로는 **큰 UDP**에 취약. **초기 QUIC 패킷 ≈ 1200B** 안전선.  
- **ICMP Too Big** 차단 시 PMTUD 실패 → 손실/지연 급증 가능.

---

## 11.4 CDN, Anycast, 캐싱, 연결 재사용/풀링 (⚙️)

### 11.4.1 Anycast 엣지
- 전 세계 여러 엣지가 **같은 IP**를 **BGP**로 광고 → 사용자는 **네트워크 정책상 가까운** 엣지로 라우팅.  
- 장점: **지연↓·가용성↑·DDoS 분산**. 주의: “가까움”이 항상 **지리**와 일치하진 않음(정책/피어링 영향).

### 11.4.2 캐싱 계층(Edge ↔ Mid ↔ Origin)
- **Tiered/Origin-Shield**: 엣지 미스는 **상위 캐시** 거쳐 오리진 보호.  
- **Revalidation**: `If-None-Match`(ETag) / `If-Modified-Since`(Last-Modified).  
- **Stale-While-Revalidate / Stale-If-Error**: **오래된 캐시로 즉시 응답** 후 백그라운드 새로고침 / 오리진 오류시 **stale 허용**.

**Cache-Control 치트시트**
```
Cache-Control: public, max-age=600, s-maxage=3600, stale-while-revalidate=30
ETag: "ab12cd"
Vary: Accept-Encoding, Accept-Language
```
- `s-maxage`: **공유 캐시(CDN)**에만 적용.  
- `Vary`: 압축/언어/UA 등 **변형 기준** 명시(과도하면 적중률↓).

### 11.4.3 연결 재사용/풀링
- **HTTP/1.1**: 오리진당 **여러 TCP**(브라우저 제한) + keep-alive.  
- **HTTP/2**: 오리진당 **1~2 TLS/TCP**로 멀티플렉싱.  
- **HTTP/3**: 오리진당 **1~2 QUIC**로 멀티플렉싱 + **연결 이식성**.

**오리진 코얼레싱(HTTP/2/3)**  
- 같은 인증서(SAN)에 **여러 호스트명**이 있고, 정책/보안 요건 만족 시 **하나의 커넥션 공유** 가능 → **핸드셰이크 절감**.

### 11.4.4 리소스 힌트/프리로드
```html
<link rel="preconnect" href="https://cdn.example.com">
<link rel="dns-prefetch" href="//img.example.com">
<link rel="preload" as="style" href="/assets/main.css">
<link rel="prefetch" href="/next/page" as="document">
```
- `preconnect`: **TCP/TLS(QUIC)** 미리 성립 → 첫 요청 **RTT 절약**.  
- `preload`: **크리티컬 리소스**를 **빨리** 가져오게 힌트.  
- `prefetch`: **탐색적**(사용자 행동 예측) 캐싱.

---

## 11.5 0-RTT, 세션 재개, 성능·보안 트레이드오프 (🚀)

### 11.5.1 TLS 세션 재개
- **TLS 1.2**: 세션 ID/티켓로 재개, 핸드셰이크 절감.  
- **TLS 1.3**: **PSK + 0-RTT 옵션**. 첫 연결에서 받은 티켓/키로 다음 접속을 **즉시** 시작.

### 11.5.2 0-RTT(재생 위험과 가이드)
- 장점: **왕복 1회 절감**(특히 H3에서 체감 큼).  
- **위험: 재생(replay)**. 네트워크 중간자가 0-RTT 데이터를 **다시 제출** 가능.  
- **원칙**: 0-RTT에서는 **멱등(idempotent)·안전한** 요청만 허용(예: `GET` 캐시 가능 리소스). 계정 상태변경/결제는 **금지**.

**서버 사이드 가드**
- **토큰/스택**으로 **재생 윈도우** 관리, **시간·CID·Client IP/정보** 포함.  
- 0-RTT로는 **권한 상승 없는** 경량 엔드포인트만 허용(예: 정적 CDN 파일).

### 11.5.3 세션 티켓 운영
- **로테이션/암호화** 키 주기 문서화.  
- 멀티 리전/엣지에서는 **키 동기화**가 필요(티켓 범용성).  
- **수명** 너무 길면 보안 리스크, 너무 짧으면 성능 이득 감소.

---

## 11.6 성능·지연 모델과 설계 포인트

### 11.6.1 BDP/초기혼잡창(ICW) 감각
\[
\text{BDP} = \text{Bandwidth} \times \text{RTT}
\]
- **고RTT(모바일/원거리)**에서는 **초기 전송량**이 병목. H2/H3는 **커넥션 수 절약**으로 ICW를 **중앙집중 활용**.

### 11.6.2 요청 병렬화 전략
- H1: **도메인 셰이딩(domain sharding)**(다중 호스트로 커넥션 수↑)은 과거 해법이지만, H2/H3에서는 **비권장**(혼잡·TLS 오버헤드 증가).  
- H2/H3: **한 도메인 합치기** + **코얼레싱** + **preload/early hints**.

### 11.6.3 압축·전송·이미지
- **Brotli(br)**: 텍스트 자산(HTML/CSS/JS)에 우수. `Vary: Accept-Encoding`.  
- **이미지**: **WebP/AVIF** + **적응형 사이즈**(Client-Hints: `DPR`, `Width`, `Viewport-Width`).  
- **HTTP 캐시 가능성** 상향: 콘텐츠 해시 파일명(`app.f0c9e.js`) + **immutable** 정책.
```
Cache-Control: public, max-age=31536000, immutable
```

### 11.6.4 HTTP/2 우선순위(현대)
- 과거 복잡한 트리 기반 → **간단한 가중치/긴급성 신호**(RFC 9218)로 정리되는 추세.  
- **HTML(최상)** → **CSS/폰트** → **크리티컬 JS/이미지** 순서 힌트.

---

## 11.7 보안·관측 포인트

### 11.7.1 HSTS/ECH/ALPN
- **HSTS**: HTTPS 강제(섹션 10 참조).  
- **ECH(Encrypted ClientHello)**: SNI 프라이버시 보호 방향(보급 확대 중).  
- **ALPN**: `h2`/`h3` 협상 실패 시 **폴백** 로직 점검.

### 11.7.2 QUIC의 보안·운영 특성
- **초기 앰플리피케이션 제한**(서버는 주소 검증 전 **확대 응답 제한**)과 **Retry/토큰**으로 반사/증폭 완화.  
- **관측성**: 패킷/스트림이 전부 암호화 → **수동 DPI 가시성↓**. **qlog**, 서버 메트릭, 엣지 로깅으로 시야 확보.  
- **방화벽/NAT**: 443/UDP **허용** 필요, 미허용이면 자동 **H2 폴백**.

---

## 11.8 구현 스니펫(개념)

### 11.8.1 Nginx(개념) — HTTP/2 + H3 Alt-Svc
```nginx
server {
  listen 443 ssl http2;              # H2
  listen 443 quic reuseport;         # H3(빌드/모듈 필요, 배포판 지침 확인)
  server_name www.example.com;

  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_ciphers   TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384;
  ssl_prefer_server_ciphers on;

  add_header Alt-Svc 'h3=":443"; ma=86400' always;     # 클라에게 H3 엔드포인트 힌트
  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

  # 정적 캐시 정책(예)
  location /assets/ {
    add_header Cache-Control "public,max-age=31536000,immutable";
  }

  # 오리진/백엔드 프록시 설정 …
}
```
> 실제 H3 지원은 **빌드/버전/모듈**에 좌우됩니다. 운영 배포판 가이드를 따르세요.

### 11.8.2 `curl`로 프로토콜 확인
```bash
# HTTP 버전/TTFB 대략 확인
curl -I -w 'proto=%{http_version} ttfb=%{time_starttransfer}\n' https://www.example.com
curl --http2 -I https://www.example.com
curl --http3 -I https://www.example.com  # curl 빌드에 h3 지원 필요
```

---

## 11.9 장애 시나리오 & 진단

### 11.9.1 “일부 지역만 느리다”
```text
가설: Anycast 라우팅/피어링 경로 문제, 지역 엣지 과부하, 캐시 미스 급증
관찰: 엣지별 TTFB·대역폭·오류율, 캐시 적중률, 라우트 변화
조치: 트래픽 재분배, 티어드 캐시, 프리페치/워밍, 피어링 협의
```

### 11.9.2 “HTTP/3 실패, H2는 된다”
```text
가설: 443/UDP 차단/NAT 불안정, MTU/ICMP 차단, QUIC 토큰 검증 실패
관찰: H3 연결 시도 로그(qlog), fallback 비율, ICMP/PTB 수신 여부
조치: 443/UDP 개방, 초기 패킷 크기 1200B 준수, Retry/토큰 정책 점검
```

### 11.9.3 “캐시가 있는데도 오리진 부하 급증”
```text
가설: Cache-Control/Vary 부적절, s-maxage=0, 쿠키 의존, 쿼리스트링 난립
관찰: 히트/미스/패스 비율, 키(Host+Path+Query+Vary) 폭발
조치: 정적 자산 해시/immutable, 쿠키 분리, Vary 최소화, 프록시 캐시 키 표준화
```

### 11.9.4 “0-RTT 켰더니 보안 경보”
```text
가설: 재생 공격 탐지/정책 미흡, 비멱등 엔드포인트 허용
조치: 0-RTT 허용 경로 화이트리스트(정적 GET만), 재생 윈도우/토큰 검증 강화, 로깅 분리
```

---

## 11.10 체크리스트(요약 카드)

**프로토콜**
- [ ] HTTP/2/H3 모두 서빙(Alt-Svc), 안전한 폴백(H2→H1.1).
- [ ] TLS 1.3 우선, 0-RTT는 **멱등 요청만** 허용.

**캐시**
- [ ] `Cache-Control`/`ETag`/`Vary` 표준화, `stale-*` 전략 적용.
- [ ] 정적 자산 **해시+immutable**, HTML은 짧은 TTL + revalidate.

**연결**
- [ ] `preconnect`/`preload` 힌트, 도메인 셰이딩 제거.
- [ ] H2/3 코얼레싱 가능 도메인 설계(인증서 SAN·정책 정합).

**네트워크**
- [ ] 443/UDP 허용(H3), ICMP PTB 허용, MTU/오버레이 고려.
- [ ] Anycast 엣지 헬스·오토 리라우팅, 티어드 캐시.

**보안·관측**
- [ ] HSTS 단계 도입, OCSP Stapling, mTLS(필요 시).
- [ ] qlog/서버 메트릭/엣지 로그로 H3 가시성 확보.

---

## 11.11 한 장 요약(포스터)
- **HTTP/1.1 → 2**: 멀티플렉싱·헤더압축으로 **커넥션 수↓, 지연↓**(단, TCP HoL 남음).  
- **HTTP/3(QUIC)**: UDP 기반 스트림·1-RTT 핸드셰이크·연결 이식성으로 **대화형 지연·손실 내성** 크게 개선.  
- **CDN/Anycast·캐싱**: 전 세계 근접 엣지·계층 캐시·재검증으로 **오리진 보호**.  
- **연결 재사용/코얼레싱** + **preconnect/preload**로 **RTT 절약**.  
- **0-RTT/재개**: 성능↑ vs **재생 위험**(멱등 요청만).  
- **운영 핵심**: MTU/ICMP/UDP 경로, 캐시 키/TTL, 보안 헤더, 관측(qlog)·폴백 설계.

---

### 부록 A — 헤더/캐시 예시 모음

**정적 자산**
```
Cache-Control: public, max-age=31536000, immutable
ETag: "f0c9e-1a2b3c"
Vary: Accept-Encoding
```

**HTML**
```
Cache-Control: no-cache, must-revalidate
# 또는
Cache-Control: public, max-age=60, stale-while-revalidate=30
```

**Early Hints(103) + Preload(개념)**
```http
HTTP/1.1 103 Early Hints
Link: </assets/main.css>; rel=preload; as=style
Link: </assets/app.js>; rel=preload; as=script
```

### 부록 B — 성능 지표 대시보드 필드
```text
DNS(ms), TCP/QUIC connect(ms), TLS/handshake(ms), TTFB(ms), 
protocol(h1/h2/h3), RTT(ms), PLR(%), ECN/CE(%), 
edge_hit_ratio(%), origin_load(qps), 0-RTT_rate(%), fallback_rate(%)
```

### 부록 C — 운영 템플릿
```text
[도메인·인증서] SAN/만료/HSTS/Alt-Svc
[프로토콜] h1/h2/h3 지원·우선순위, 0-RTT 정책
[캐시] 키 구성(host+path+query+vary), TTL, stale-while-revalidate/if-error
[네트워크] 443/UDP·ICMP PTB 허용, MTU 문서화
[관측] qlog·엣지/오리진 로그·RUM(LCP/TTFB/INP)
[릴리즈] canary(지역/AS별), 폴백 자동화, 롤백 플레이북
```