---
layout: post
title: 영상처리 - 메타데이터 보존 & 썸네일 유지
date: 2025-10-09 22:25:23 +0900
category: 영상처리
---
# 메타데이터 보존(EXIF/IPTC/XMP) & 썸네일 유지 — **원본 마커 그대로 잡아두고, 재인코드 시 재주입하기(민감정보 선택 제거 포함)**

## 0. 왜 “마커 보존 & 재주입”인가?

JPEG 메타데이터는 대부분 **APPn(0xFFE0~FFEF)** 세그먼트에 저장됩니다.  
대표 예시:

- **APP0 JFIF**: JFIF 헤더(밀도·aspect)  
- **APP0 JFXX**: **임베디드 썸네일**(JPEG/팔레트/BMP 형식)  
- **APP1 Exif**: 카메라·렌즈·노출·**Orientation**·**IFD1 썸네일** 등  
- **APP1 XMP**: RDF/XML 기반 메타(제목·설명·**GPS** 등)  
- **APP13 IPTC**: Photoshop IRB(여기에 IPTC-NAA 데이터가 들어있음)  
- **APP2 ICC**: ICC 프로파일(색관리)  
- **APP14 Adobe**: transform(0/1/2)·CMYK/YCCK 힌트

대부분의 워크플로우에서 **이것들을 잃어버리면**:  
- 라이트룸/포토메카닉 등의 **카탈로그링**이 무너짐,  
- 미리보기(썸네일)가 없어져 **브라우저·OS 썸네일**이 재생성되는 비용·지연 발생,  
- **GPS/시간/저작권** 정보 유실.

**해법**: 디코드 시점에 **원본 마커를 raw 로 모조리 수집** → 저장 시점에 **그대로 재주입**.  
민감정보 제거가 필요하면 **정책 기반 필터**로 일부만 제외.

---

## 1. 설계 개요

1. **Read(열기)**  
   - `jpeg_save_markers()` 로 **관심 APPn**(APP0~APP15, COM)을 저장하도록 설정  
   - `jpeg_read_header()` 후 `marker_list` 를 **원래 순서를 잃지 않도록** 벡터에 백업  
   - (옵션) EXIF Orientation/ICC/CMYK 등은 별도 파서로 **표시용 처리**(이전 장 참고)  
2. **Write(저장)**  
   - `jpeg_start_compress()` 직후, **스캔라인 쓰기 전에** `jpeg_write_marker()` 로 **마커 재주입**  
   - **주의**: libjpeg는 기본적으로 **JFIF/Adobe 마커를 자동으로 붙일 수 있음** →  
     `cinfo.write_JFIF_header = FALSE;` / `cinfo.write_Adobe_marker = FALSE;` 로 **중복 방지**  
   - 정책에 따라 **필터링**(GPS/전체 EXIF/XMP 제거 등)  
   - 필요 시 Orientation=1 패치(이미 픽셀에 적용했다면) / ICC 교체 등은 이전 장 로직과 결합

---

## 2. 시그니처로 빠르게 구분하기

- **JFIF** (APP0): `"JFIF\0"`  
- **JFXX** (APP0): `"JFXX\0"` (썸네일 포함 가능)  
- **Exif** (APP1): `"Exif\0\0"` (TIFF 구조, IFD0/ExifIFD/GPSIFD/IFD1(썸네일))  
- **XMP** (APP1): `"http://ns.adobe.com/xap/1.0/\0"` (plain XML)  
  - **Extended XMP**(나뉘어 저장) 시: `"http://ns.adobe.com/xmp/extension/\0"` + GUID/total/offset  
- **IPTC/Photoshop IRB** (APP13): `"Photoshop 3.0\0"` + `"8BIM"` 리소스 블록  
- **ICC** (APP2): `"ICC_PROFILE\0"` + seq/count (앞서 구현)  
- **Adobe** (APP14): `"Adobe"` + version/flags/transform

---

## 3. 코드 — 마커 수집/분류/필터/재주입

### 3.1 헤더(정책 & 유틸 선언)

```cpp
// JpegMetadata.hpp
#pragma once
#include <vector>
#include <string>
#include <cstdint>
#include <jpeglib.h>

// 원본 순서 보존을 위해 수집 시 index 부여
struct SavedMarkerEx {
    int marker = 0;                  // JPEG_APP0 + n or JPEG_COM
    std::vector<uint8_t> data;       // raw payload
    size_t order = 0;                // 파일에서 등장한 순서
};

// 관심 마커 저장 활성화
void EnableSaveCommonMetadata(j_decompress_ptr cinfo);

// 수집
std::vector<SavedMarkerEx> CollectMarkersWithOrder(j_decompress_ptr cinfo);

// 시그니처 판별
bool IsAPP0_JFIF(const SavedMarkerEx& m);
bool IsAPP0_JFXX(const SavedMarkerEx& m);
bool IsAPP1_EXIF(const SavedMarkerEx& m);
bool IsAPP1_XMP(const SavedMarkerEx& m);
bool IsAPP1_XMP_Ext(const SavedMarkerEx& m);
bool IsAPP13_PhotoshopIRB(const SavedMarkerEx& m);
bool IsAPP2_ICC(const SavedMarkerEx& m);
bool IsAPP14_Adobe(const SavedMarkerEx& m);

// 정책
struct MarkerPolicy {
    bool keepJFIF   = true;    // JFIF APP0
    bool keepJFXX   = true;    // JFXX (썸네일)
    bool keepEXIF   = true;
    bool keepXMP    = true;
    bool keepXMPExt = true;    // Extended XMP
    bool keepIPTC   = true;    // APP13 Photoshop IRB
    bool keepICC    = true;    // APP2 ICC
    bool keepAdobe  = true;    // APP14 Adobe
    bool keepCOM    = true;    // 코멘트

    bool keepUnknownAPP = true;// 기타 APPn
    // 프라이버시 옵션
    bool stripGPS    = false;  // GPS 제거 (간단 경로: EXIF/XMP 자체 제거)
    bool stripXMPPII = false;  // XMP 전체 제거(민감 메타 가능성 시)
};

// 필터링
std::vector<SavedMarkerEx> FilterMarkers(const std::vector<SavedMarkerEx>& in, const MarkerPolicy& pol);

// 재주입(저장 시작 후, 스캔라인 전)
void ReinjectMarkers(j_compress_ptr cinfo, const std::vector<SavedMarkerEx>& markers,
                     bool disableLibjpegAutogenJFIFAdobe=true);
```

### 3.2 구현

```cpp
// JpegMetadata.cpp
#include "JpegMetadata.hpp"
#include <algorithm>
#include <cstring>

void EnableSaveCommonMetadata(j_decompress_ptr cinfo){
    // 넉넉히 저장: APP0~APP15 + COM
    for (int i=0;i<=15;++i){
        jpeg_save_markers(cinfo, JPEG_APP0 + i, 0xFFFF);
    }
    jpeg_save_markers(cinfo, JPEG_COM, 0xFFFF);
}

std::vector<SavedMarkerEx> CollectMarkersWithOrder(j_decompress_ptr cinfo){
    std::vector<SavedMarkerEx> out;
    size_t k=0;
    for (jpeg_saved_marker_ptr m=cinfo->marker_list; m; m=m->next){
        SavedMarkerEx sm;
        sm.marker = m->marker;
        sm.data.assign(m->data, m->data + m->data_length);
        sm.order = k++;
        out.push_back(std::move(sm));
    }
    // marker_list 가 역순일 수 있음 → order로 재정렬
    std::sort(out.begin(), out.end(), [](auto& a, auto& b){ return a.order < b.order; });
    return out;
}

// ---- signature helpers
static bool starts(const SavedMarkerEx& m, const char* s){
    size_t n = std::strlen(s);
    return m.data.size()>=n && std::memcmp(m.data.data(), s, n)==0;
}
bool IsAPP0_JFIF(const SavedMarkerEx& m){ return m.marker==(JPEG_APP0+0) && starts(m,"JFIF\0"); }
bool IsAPP0_JFXX(const SavedMarkerEx& m){ return m.marker==(JPEG_APP0+0) && starts(m,"JFXX\0"); }
bool IsAPP1_EXIF(const SavedMarkerEx& m){ return m.marker==(JPEG_APP0+1) && starts(m,"Exif\0\0"); }
bool IsAPP1_XMP(const SavedMarkerEx& m){ return m.marker==(JPEG_APP0+1) && starts(m,"http://ns.adobe.com/xap/1.0/\0"); }
bool IsAPP1_XMP_Ext(const SavedMarkerEx& m){ return m.marker==(JPEG_APP0+1) && starts(m,"http://ns.adobe.com/xmp/extension/\0"); }
bool IsAPP13_PhotoshopIRB(const SavedMarkerEx& m){ return m.marker==(JPEG_APP0+13) && starts(m,"Photoshop 3.0\0"); }
bool IsAPP2_ICC(const SavedMarkerEx& m){ return m.marker==(JPEG_APP0+2) && starts(m,"ICC_PROFILE\0"); }
bool IsAPP14_Adobe(const SavedMarkerEx& m){ return m.marker==(JPEG_APP0+14) && starts(m,"Adobe"); }

std::vector<SavedMarkerEx> FilterMarkers(const std::vector<SavedMarkerEx>& in, const MarkerPolicy& pol){
    std::vector<SavedMarkerEx> out; out.reserve(in.size());
    for (auto& m : in){
        bool keep = false;
        if (IsAPP0_JFIF(m))             keep = pol.keepJFIF;
        else if (IsAPP0_JFXX(m))        keep = pol.keepJFXX;      // 썸네일
        else if (IsAPP1_EXIF(m))        keep = pol.keepEXIF && !pol.stripGPS; // 간단 경로: stripGPS면 EXIF 자체 제거
        else if (IsAPP1_XMP_Ext(m))     keep = pol.keepXMPExt && !pol.stripXMPPII;
        else if (IsAPP1_XMP(m))         keep = pol.keepXMP && !pol.stripXMPPII;
        else if (IsAPP13_PhotoshopIRB(m)) keep = pol.keepIPTC;
        else if (IsAPP2_ICC(m))         keep = pol.keepICC;
        else if (IsAPP14_Adobe(m))      keep = pol.keepAdobe;
        else if (m.marker == JPEG_COM)  keep = pol.keepCOM;
        else if (m.marker >= JPEG_APP0 && m.marker <= JPEG_APP0+15) keep = pol.keepUnknownAPP;
        else keep = false;

        if (keep) out.push_back(m);
    }
    // 원래 순서 유지
    std::sort(out.begin(), out.end(), [](auto& a, auto& b){ return a.order < b.order; });
    return out;
}

void ReinjectMarkers(j_compress_ptr cinfo, const std::vector<SavedMarkerEx>& markers,
                     bool disableLibjpegAutogenJFIFAdobe)
{
    if (disableLibjpegAutogenJFIFAdobe){
        // libjpeg가 자동으로 붙이는 JFIF/Adobe 마커를 끔 (중복 방지)
        cinfo->write_JFIF_header  = FALSE;
        cinfo->write_Adobe_marker = FALSE;
    }
    for (auto& m : markers){
        // 주의: 너무 큰 payload는 분할 필요(ICC/XMP-Ext는 이미 분할 구조)
        jpeg_write_marker(cinfo, m.marker,
                          m.data.data(),
                          (unsigned int) m.data.size());
    }
}
```

> **주의**  
> - **GPS 제거를 “정밀하게” 하려면** EXIF TIFF를 파싱해 **GPS IFD(0x8825) 제거** 또는 XMP에서 GPS 속성만 제거해야 합니다.  
>   이 예제는 **간단 경로**로서 `stripGPS=true` 시 **EXIF/XMP 자체를 제외**합니다(가장 안전하고 확실).  
>   정밀 편집은 `exiv2` 같은 라이브러리 사용을 권장합니다.

---

## 4. 저장 파이프라인에 연결하기

앞서 만든 저장 코드(예: `JpegEncode_WithICC` 또는 단순 저장)에 **재주입 단계**를 추가합니다.

```cpp
// SaveWithMetadata.cpp — 예시 저장 함수
#include "JpegMetadata.hpp"
#include <jpeglib.h>
#include <cstdio>

bool SaveJpeg_WithReinjectedMetadata(const std::wstring& path,
                                     const IppDib& bgra,
                                     int quality,
                                     const std::vector<SavedMarkerEx>& originalMarkers,
                                     const MarkerPolicy& policy)
{
    if (!bgra) return false;

    // 1) 정책 필터
    auto filtered = FilterMarkers(originalMarkers, policy);

    // 2) libjpeg 압축 시작
    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"wb"); if (!fp) return false;
    jpeg_compress_struct cinfo{}; jpeg_error_mgr jerr{};
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_compress(&cinfo);
    jpeg_stdio_dest(&cinfo, fp);

    cinfo.image_width  = bgra.width();
    cinfo.image_height = bgra.height();
    cinfo.input_components = 3;
    cinfo.in_color_space = JCS_RGB;

    jpeg_set_defaults(&cinfo);
    jpeg_set_quality(&cinfo, std::clamp(quality,1,100), TRUE);
    jpeg_set_colorspace(&cinfo, JCS_YCbCr);

    // 3) 시작
    jpeg_start_compress(&cinfo, TRUE);

    // 4) 마커 재주입 (SOI 뒤, 스캔라인 전)
    ReinjectMarkers(&cinfo, filtered, /*disable auto JFIF/Adobe*/true);

    // 5) 스캔라인 쓰기(BGRA→RGB)
    std::vector<uint8_t> row(bgra.width()*3);
    while (cinfo.next_scanline < cinfo.image_height){
        const uint8_t* s = (const uint8_t*)bgra.bits() + (size_t)cinfo.next_scanline*bgra.stride();
        for (int x=0;x<bgra.width();++x){
            row[x*3+0]=s[x*4+2];
            row[x*3+1]=s[x*4+1];
            row[x*3+2]=s[x*4+0];
        }
        JSAMPROW rp=row.data();
        jpeg_write_scanlines(&cinfo, &rp, 1);
    }

    // 6) 종료
    jpeg_finish_compress(&cinfo);
    jpeg_destroy_compress(&cinfo);
    fclose(fp);
    return true;
}
```

---

## 5. **썸네일 유지**가 왜 자동으로 되는가?

- **JFXX 썸네일**: JFXX(APP0) 블록을 **raw로 재주입**하면 **그대로 보존**됩니다.  
  일부 뷰어나 OS 썸네일러는 이 블록을 써서 **빠르게 미리보기**를 만듭니다.
- **EXIF IFD1 썸네일**: EXIF(APP1) 전체를 **원형 보존**하면, IFD1에 들어있는 **JPEG 압축 썸네일**도 그대로 남습니다.  
  → OS/뷰어가 EXIF 썸네일을 **즉시** 활용 가능.
- 즉, **마커를 건드리지 않고 순서대로 재삽입**하면, **썸네일 손실 없이 유지**됩니다.  
  (EXIF 편집·재작성 시 IFD1를 잃어버리는 도구가 있으니 주의)

---

## 6. 실전 시나리오

### 시나리오 A — **그대로 보존 저장**

> 요구: 색 보정/회전/리사이즈만 수행하고, 메타데이터(EXIF/IPTC/XMP/ICC/썸네일)를 **원형 보존**해서 저장

1) 열기  
   - `EnableSaveCommonMetadata()` → `jpeg_read_header()` → `CollectMarkersWithOrder()`  
   - Orientation/ICC/CMYK 등은 **표시용으로만 처리**  
2) 편집  
   - 픽셀 변환(밝기·리사이즈 등)  
3) 저장  
   - `MarkerPolicy` 기본값(모두 keep)으로 `SaveJpeg_WithReinjectedMetadata()` 호출

```cpp
MarkerPolicy pol; // 기본값: 대부분 keep
SaveJpeg_WithReinjectedMetadata(L"out.jpg", edited, 92, originalMarkers, pol);
```

### 시나리오 B — **프라이버시 모드: GPS/PII 제거**

> 요구: 사진을 공유하기 전에 **GPS/개인정보**를 빼고 저장  
> 간단 경로: EXIF·XMP 자체를 제거(가장 확실)

```cpp
MarkerPolicy pol;
pol.keepEXIF = false;      // EXIF 제거(Orientation 이미 픽셀에 적용했을 것)
pol.keepXMP  = false;      // XMP 제거
pol.keepXMPExt = false;    // Extended XMP 제거
// IPTC는 회사 워크플로에 따라 유지/제거 판단
pol.keepIPTC = false;      // 필요 시 제거

SaveJpeg_WithReinjectedMetadata(L"public.jpg", edited, 90, originalMarkers, pol);
```

> 팁: Orientation은 **픽셀에 적용**한 뒤 EXIF를 버리는 것이 안전(이중회전 X).

### 시나리오 C — **EXIF는 유지, GPS만 제거하고 싶다(정밀)**

- EXIF **TIFF 구조 편집**이 필요(0x8825 GPS IFD 제거/무효화 + XMP의 GPS 속성 정리).  
- 직접 구현은 오프셋·IFD 재작성 등 **복잡** → **exiv2** 같은 라이브러리 추천.  
- 간단한 대안: **EXIF 전체 제거** + Orientation만 새 EXIF로 **간단 재생성**(필요하면).  
  (Orientation 재생성은 앞서 만든 `PatchExifOrientationInPlace` + 미니 EXIF 빌더로 가능)

---

## 7. 순서(ORDER)와 중복(JFIF/Adobe) 주의사항

- JPEG의 APPn은 **SOI(FFD8)** 다음부터 **SOS(FFDA)** 사이에 여러 개가 옵니다.  
- 많은 메타 파서/카탈로그는 **원래 순서**에 기대는 경우가 있어 **순서 보존**이 안전합니다.  
- libjpeg는 기본적으로 `jpeg_set_defaults()` 후  
  - **JFIF 마커**(APP0)와  
  - **Adobe 마커**(APP14)를 **자동으로 쓸 수 있음**  
  → 이미 우리가 **원본 마커 재주입**을 할 예정이라면,  
  `cinfo.write_JFIF_header = FALSE;` / `cinfo.write_Adobe_marker = FALSE;` 로 **중복 방지**.

---

## 8. 대용량/확장 XMP & ICC 같이 큰 메타

- **ICC**: 이미 **분할 저장** 구조(앞 장 구현 참고). 우리는 **원본 raw**를 **그대로 재주입**하므로 **자동 보존**.  
- **Extended XMP**: APP1 `"xmp/extension"` 체인으로 **GUID/offset/total**이 포함되어 **여러 조각**으로 나뉩니다.  
  - 우리 접근(원형 raw 재주입)은 **그대로 보존** 가능.  
  - 만약 XMP를 **편집**하려면, **재조립 → 수정 → 다시 분할** 과정을 구현해야 함(복잡). 보통은 **보존만** 권장.

---

## 9. 테스트 케이스 체크리스트

- [ ] **스마트폰 사진**(EXIF Orientation + EXIF 썸네일): 보존 후 OS 썸네일이 즉시 보이는지  
- [ ] **포토샵 저장 JPEG**(XMP + IPTC + Adobe APP14): 순서/중복 문제 없는지  
- [ ] **카메라 RAW → JPEG**(ICC 포함): ICC 유지 확인(뷰어에서 색 동일)  
- [ ] **스캐너 사진**(JFXX 썸네일): 썸네일 유지 여부  
- [ ] **프라이버시 모드**: EXIF/XMP 제거 후, 메타 뷰어에서 비어있는지 확인  
- [ ] **Extended XMP** 샘플: 원본과 동일한 개수/크기의 APP1 블록이 있는지

---

## 10. 성능·안정성 팁

- **성능**: 마커는 수~수십 KB 규모(ICC/XMP 제외). 재주입 비용은 미미.  
- **안정성**:  
  - 저장 시 `jpeg_write_marker()` 의 payload는 **< 64KB** 여야 함(분할 구조의 경우 원형 유지)  
  - 손상된 마커(짧은 길이)는 수집 단계에서 **그냥 보존**(수정하지 않음).  
  - EXIF/XMP를 **부분 편집**하려면 반드시 **안전 파서** 사용(오프셋 관리).

---

## 11. 간단 통합 예제: **열기 → 편집 → 메타 보존 저장**

```cpp
#include "JpegMetadata.hpp"
#include "JpegIO.hpp"        // 앞서 만든 디코드(ICC/EXIF 처리) 모듈
#include "IppDib.h"

struct Loaded {
    IppDib image;
    std::vector<SavedMarkerEx> markers;
};

// 1) 열기
bool OpenKeepAll(const std::wstring& path, Loaded& L){
    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"rb"); if (!fp) return false;

    jpeg_decompress_struct c{}; jpeg_error_mgr jerr{};
    c.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&c);
    jpeg_stdio_src(&c, fp);

    EnableSaveCommonMetadata(&c);

    if (jpeg_read_header(&c, TRUE) != JPEG_HEADER_OK){ jpeg_destroy_decompress(&c); fclose(fp); return false; }

    // 수집
    L.markers = CollectMarkersWithOrder(&c);

    // 디코드 (RGB로)
    c.out_color_space = JCS_RGB;
    jpeg_start_decompress(&c);
    L.image.create(c.output_width, c.output_height, 32);

    std::vector<uint8_t> row(L.image.width()*3);
    while (c.output_scanline < c.output_height){
        JSAMPROW rp=row.data();
        jpeg_read_scanlines(&c, &rp, 1);
        uint8_t* d=(uint8_t*)L.image.bits() + (size_t)(c.output_scanline-1)*L.image.stride();
        for (int x=0;x<L.image.width();++x){
            d[x*4+0]=row[x*3+2];
            d[x*4+1]=row[x*3+1];
            d[x*4+2]=row[x*3+0];
            d[x*4+3]=255;
        }
    }
    jpeg_finish_decompress(&c);
    jpeg_destroy_decompress(&c);
    fclose(fp);
    return true;
}

// 2) 편집(예: 아무 처리 안함)

// 3) 저장 (보존 모드 / 프라이버시 모드)
void SaveAll(const Loaded& L, const std::wstring& outPath){
    MarkerPolicy pol; // 모두 keep
    SaveJpeg_WithReinjectedMetadata(outPath, L.image, 92, L.markers, pol);
}
void SavePrivacy(const Loaded& L, const std::wstring& outPath){
    MarkerPolicy pol;
    pol.keepEXIF=false;      // EXIF 제거 (Orientation은 편집 단계에서 픽셀에 반영했다 가정)
    pol.keepXMP=false;
    pol.keepXMPExt=false;
    pol.keepIPTC=false;
    SaveJpeg_WithReinjectedMetadata(outPath, L.image, 92, L.markers, pol);
}
```

---

## 12. 마무리

- **핵심**: “**수집→필터→원래 순서로 재주입**”만 지켜도, **촬영정보/썸네일/카탈로그 메타**가 **깨지지 않습니다**.  
- **프라이버시**: 손쉬운 차단은 **EXIF/XMP 제거**. (정밀 편집은 exiv2 권장)  
- **중복 주의**: libjpeg의 **자동 JFIF/Adobe**는 **끄고**, **원본을 재주입**.  
- **확장 메타(ICC/XMP-Ext)** 도 **raw 재주입**으로 안전 보존.
