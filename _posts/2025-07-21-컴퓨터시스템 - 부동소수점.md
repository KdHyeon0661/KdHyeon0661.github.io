---
layout: post
title: 컴퓨터시스템 - 부동소수점
date: 2025-07-21 17:20:23 +0900
category: 컴퓨터시스템
---
# 부동소수점(Floating Point): 실수의 저장과 연산

컴퓨터는 이진수만을 다루기 때문에 **소수점이 있는 실수(예: 3.14, -0.125)**를 그대로 저장할 수 없다.  
이를 해결하기 위해 IEEE에서 정의한 **부동소수점 표준(IEEE 754)**을 이용해 실수를 표현하고 연산한다.

---

## 1. 부동소수점의 개념

"부동"이란 "소수점의 위치가 고정되지 않는다"는 뜻이다.  
이는 실수를 다음과 같이 표현하는 방식이다:

\[
\text{실수} = (-1)^s \times M \times 2^E
\]

- \( s \): 부호비트 (0은 양수, 1은 음수)
- \( M \): 가수(Mantissa, 또는 significand)
- \( E \): 지수(Exponent)

---

## 2. IEEE 754 표준 형식

### 📌 단정도 (float, 32비트)

| 비트수 | 의미 |
|--------|------|
| 1비트  | 부호 \( s \) |
| 8비트  | 지수 \( E \) (편향: 127) |
| 23비트 | 가수 \( M \) (숨은 1 포함) |

\[
\text{실수} = (-1)^s \times (1 + f) \times 2^{e - 127}
\]

### 📌 배정도 (double, 64비트)

| 비트수 | 의미 |
|--------|------|
| 1비트  | 부호 |
| 11비트 | 지수 (편향: 1023) |
| 52비트 | 가수 |

---

## 3. float 값의 실제 저장 예시

### 예: 실수 `1.0`

- 이진 표현: `1.0 = 1.0 × 2^0`
- 부호 비트 \( s = 0 \)
- 지수 \( E = 127 \) → `01111111`
- 가수 \( f = 0 \)

32비트 저장:  
```
0 01111111 00000000000000000000000  
== 0x3F800000
```

### C 코드 확인
```c
#include <stdio.h>
#include <stdint.h>

int main() {
    float f = 1.0f;
    uint32_t* p = (uint32_t*)&f;
    printf("float 1.0의 비트 표현: 0x%08X\n", *p);
    return 0;
}
```

출력:
```
float 1.0의 비트 표현: 0x3F800000
```

---

## 4. 특수 값들

IEEE 754은 몇 가지 **특수한 값들**도 정의한다:

| 이름 | 지수 | 가수 | 의미 |
|------|------|------|------|
| 0    | 0    | 0    | +0 또는 -0 |
| 무한대 | 255 | 0    | +∞ 또는 -∞ |
| NaN (Not a Number) | 255 | ≠0 | 연산 불능 (0/0, sqrt(-1) 등) |
| 서브노멀 | 0    | ≠0 | 매우 작은 수 (정밀도 감소) |

---

## 5. 부동소수점 연산의 특징

### 📌 근사값
대부분의 실수는 **유한 비트로 정확하게 표현할 수 없기 때문에**, **반올림 오차**가 생긴다.

### 예: 0.1
- 0.1은 이진수로 **무한 소수**
- float로 정확히 표현할 수 없음

```c
#include <stdio.h>

int main() {
    float a = 0.1f;
    if (a == 0.1f) {
        printf("같다\n");
    } else {
        printf("다르다\n");  // 출력
    }
    return 0;
}
```

출력: `다르다`  
→ 이 때문에 float 비교는 `==` 대신 **오차 범위**로 비교해야 함

```c
#include <math.h>
if (fabsf(a - 0.1f) < 1e-6) { /* 거의 같다 */ }
```

---

## 6. 정수 ↔ 부동소수점 변환

### 정수를 부동소수점으로 변환
```c
int i = 10;
float f = (float)i;  // 10.0
```

- **정확히 변환됨**: 2의 거듭제곱 기반이기 때문

### 부동소수점 → 정수
```c
float f = 3.9f;
int i = (int)f;  // i = 3
```

- **소수점 이하 버림(truncation)**  
- 오버플로우 주의 (ex. 1e10 → int 불가능)

---

## 7. C로 살펴보는 부동소수점 연산

```c
#include <stdio.h>

int main() {
    float a = 1.0f / 3.0f;
    float b = a * 3.0f;

    printf("1/3: %.10f\n", a);  // 근사값
    printf("1/3 * 3: %.10f\n", b);  // 1.0 아님
    printf("정확히 1인가? %s\n", (b == 1.0f) ? "예" : "아니오");

    return 0;
}
```

출력:
```
1/3: 0.3333333433
1/3 * 3: 1.0000000000
정확히 1인가? 예
```

→ 이 경우 `float` 정밀도 안에서 우연히 `1.0`으로 맞아 떨어질 수 있음  
하지만 **항상 그런 건 아님**

---

## 8. 부동소수점과 정수 연산의 차이점 요약

| 항목 | 정수 | 부동소수점 |
|------|------|-------------|
| 표현 방식 | 2의 보수 | IEEE 754 |
| 소수 표현 | 불가 | 가능 |
| 정확도 | 정확함 | 근사값 |
| 오버플로우 | wrap-around | 무한대 또는 NaN |
| 속도 | 빠름 | 상대적으로 느림 (FPU 사용) |
| 비교 연산 | 정확히 비교 가능 | 오차 범위 고려 필요 |

---

## 9. 정밀도 문제에 대한 실전 조언

- **비교는 오차 범위로**
- **정수로 계산할 수 있으면 정수로**
- **float보다는 double 권장 (정밀도 ↑)**
- **소수 누적 오차에 주의 (예: 금융, 과학 계산)**

---

## 마무리

부동소수점은 **정수처럼 보이지만 전혀 다른 규칙**으로 동작한다.  
정확한 계산을 기대하기보다 **근사적인 계산 체계**라는 사실을 이해하고,  
**정밀도, 표현 한계, 비교 방식** 등을 고려해 안전하게 사용하는 것이 중요하다.

수학에서의 실수와 컴퓨터에서의 실수는 **다르다.**  
이를 이해하면 수많은 버그와 예기치 않은 결과를 피할 수 있다.




----------------------




## IEEE 754: 단정도(float, 32비트) 표현 방식 상세

부동소수점 실수는 **다음과 같은 3개 필드**로 구성된다:

| 필드 이름 | 비트수 | 의미 |
|-----------|--------|------|
| 부호비트 (sign bit) | 1비트 | 음수/양수 결정. 0이면 양수, 1이면 음수 |
| 지수부 (exp) | 8비트 | 지수 부분. **편향(bias)된 지수** 저장 |
| 가수부 (frac) | 23비트 | 소수점 이하 값. **정규화일 경우 1이 숨겨짐(implicit)** |

즉, 32비트 부동소수점은 다음과 같은 구조를 가진다:

```
| S |     exp (8)     |        frac (23)         |
|---|------------------|--------------------------|
| 1 | 10000000         | 01000000000000000000000  |
```

---

## 정규화된 값 (Normalized values)

IEEE 754에서 가장 일반적인 부동소수점 값이다.

### 조건
- `exp ≠ 0` 이고 `exp ≠ 255`  
- 숨겨진 1이 가수 앞에 붙음: 즉 \( M = 1 + f \)

### 실제 값 계산식

\[
\text{값} = (-1)^s \times (1 + f) \times 2^{e - 127}
\]

- \( s \): 부호비트 (0: 양수, 1: 음수)
- \( f \): frac 부분 (소수점 아래 23비트 → 0 ≤ f < 1)
- \( e \): 지수값 (`exp`를 부호 없이 읽은 뒤, 편향 127을 뺀 값)

---

## 예: float 1.0의 저장 구조

### 1. 수학적 표현
\[
1.0 = (-1)^0 \times (1.0) \times 2^0
\]

### 2. 각 필드 채우기
- 부호비트: `s = 0` (양수)
- 가수 `f = 0` (1.0은 1 + 0)
- 지수 `e = 0` → 저장 시에는 \( 0 + 127 = 127 \)
- 지수 필드 `exp = 127 = 01111111_2`

### 3. 최종 32비트 비트열

```
S    = 0
exp  = 01111111
frac = 00000000000000000000000
```

### 4. 16진수 표현
- 이진수: `0 01111111 00000000000000000000000`
- 16진수: `0x3F800000`

---

## 비정규화된 값 (Denormalized values)

**정규화된 수보다 작은 매우 작은 값**을 표현하기 위해 사용됨.

### 조건
- `exp == 0`
- **숨겨진 1 없음** → \( M = 0 + f = f \)

### 계산식

\[
\text{값} = (-1)^s \times f \times 2^{-126}
\]

- 이때 지수는 고정된 \( -126 \)을 사용  
- 유효 자릿수 정밀도가 감소함

### 예: 가장 작은 양수 (`frac = 000...001`)
- `exp = 0`, `frac = 0x000001`
- \( f = \frac{1}{2^{23}} \)
- 값 ≈ \( 2^{-126} \times 2^{-23} = 2^{-149} \approx 1.4 \times 10^{-45} \)

---

## 특수 값 (Special values)

`exp == 255`일 경우, 가수(`frac`)의 값에 따라 특수한 의미를 가진다.

### 1. 무한대 (Infinity)
- `exp = 255`, `frac = 0`
- 부호 비트에 따라:
  - `+∞` → `s = 0`
  - `-∞` → `s = 1`

### 2. NaN (Not a Number)
- `exp = 255`, `frac ≠ 0`
- 의미 없는 값 (예: 0/0, sqrt(-1), inf - inf)

```c
#include <stdio.h>
#include <math.h>

int main() {
    float a = 0.0 / 0.0;
    if (isnan(a)) {
        printf("a는 NaN입니다.\n");
    }
}
```

---

## 전체 값 분류 정리 (IEEE 754 단정도 기준)

| exp (8비트) | frac 상태     | 해석 |
|-------------|----------------|------|
| 0           | 0              | 0 (±0) |
| 0           | ≠0             | 비정규화 수 |
| 1 ~ 254     | (any)          | 정규화 수 |
| 255         | 0              | ±무한대 |
| 255         | ≠0             | NaN |

---

## 정규화/비정규화의 시각적 예시

| 표현       | 이진수 구조 | 설명 |
|------------|-------------|------|
| `1.0`      | `0 01111111 00000000000000000000000` | 정규화된 수 |
| `0.0`      | `0 00000000 00000000000000000000000` | +0 |
| `-0.0`     | `1 00000000 00000000000000000000000` | -0 |
| 가장 작은 양의 정규 수 | `0 00000001 00000000000000000000000` | \( 2^{-126} \) |
| 가장 작은 양의 비정규 수 | `0 00000000 00000000000000000000001` | \( 2^{-149} \) |
| 양의 무한대 | `0 11111111 00000000000000000000000` | +∞ |
| NaN        | `0 11111111 10000000000000000000000` | NaN |

---

## 시각적 요약

```
exp == 0     : 비정규화 또는 0
1 <= exp <255: 정규화
exp == 255   : 무한대 또는 NaN
```

---

## C 예제: float의 내부 비트 보기

```c
#include <stdio.h>
#include <stdint.h>

void print_float_bits(float f) {
    uint32_t* p = (uint32_t*)&f;
    printf("float 값: %.8f\n", f);
    printf("비트 표현: 0x%08X\n", *p);
}

int main() {
    float a = 1.0f;
    float b = 0.0f;
    float c = 1.0f / 0.0f;
    float d = 0.0f / 0.0f;

    print_float_bits(a); // 1.0
    print_float_bits(b); // 0.0
    print_float_bits(c); // inf
    print_float_bits(d); // NaN

    return 0;
}
```

---

## 마무리

IEEE 754 단정도 실수는 **1비트 부호, 8비트 지수, 23비트 가수**로 구성되어 있으며,  
**정규화, 비정규화, 특수값**으로 나뉘어 다양한 실수 범위를 표현한다.

이 구조를 이해함으로써 다음과 같은 문제들을 정확히 분석하고 대응할 수 있다:

- 실수 연산의 오차 발생 이유  
- NaN, 무한대의 처리 방법  
- underflow와 overflow 상황  
- float ↔ int 캐스팅에서 발생하는 문제  

이는 시스템 수준 디버깅, 수치 해석, 성능 최적화 등에서 핵심적인 기반 지식이다.