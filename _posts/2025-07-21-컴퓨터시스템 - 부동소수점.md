---
layout: post
title: 컴퓨터시스템 - 부동소수점
date: 2025-07-21 17:20:23 +0900
category: 컴퓨터시스템
---
# 부동소수점(Floating Point)

## 0. 프롤로그 — “부동”의 의미와 표준의 역할

**부동**(floating)이란 소수점의 위치가 **지수 \(E\)** 에 의해 “떠다닌다”는 뜻이다. IEEE 754 표준은 하드웨어·언어가 공유하는 **저장 형식**과 **반올림/예외 규칙**을 정의한다.

$$
\boxed{x = (-1)^s \times M \times 2^{E}}
$$

- \(s\): 부호 비트, \(M\): 가수(significand, \(1.f\) 또는 \(0.f\)), \(E\): 지수(바이어스 제거 후)
- 이 표준 덕분에 서로 다른 CPU/컴파일러에서 **대략 같은 결과**를 기대할 수 있다(단, 옵션·FPU 차이에 따른 차이는 존재).

---

## 1. IEEE 754 저장 형식 — binary32/binary64

### 1.1 필드 배치

| 형식 | 총 비트 | s | E(바이어스) | f(가수 비트수) |
|---|---:|---:|---:|---:|
| binary32 (float) | 32 | 1 | 8 (127) | 23 |
| binary64 (double) | 64 | 1 | 11 (1023) | 52 |

정규화 수(normalized)는

$$
x = (-1)^s \cdot (1.f)_2 \cdot 2^{(E-\text{bias})}
$$

비정규화(서브노멀, subnormal)는

$$
x = (-1)^s \cdot (0.f)_2 \cdot 2^{(1-\text{bias})}
$$

> 서브노멀은 0 근처에서 **정밀도는 줄이되 값의 연속성**을 보장하는 완충층(gradual underflow)이다.

### 1.2 1.0의 비트 예시

- \(s=0\), \(E=127\) (float), \(f=0\) → `0 01111111 000...0` = **0x3F800000**

```c
#include <stdio.h>
#include <stdint.h>
#include <string.h>

int main(void){
    float f = 1.0f;
    uint32_t u;
    memcpy(&u, &f, sizeof u);     // strict aliasing 준수
    printf("1.0f = 0x%08X\n", u); // 보통 0x3F800000
}
```

---

## 2. 값의 분류 — 0/서브노멀/정규/무한대/NaN

| exp(부호 없는) | frac | 해석 (float 기준) |
|---|---|---|
| 0 | 0 | \(+0\) 또는 \(-0\) |
| 0 | ≠0 | **서브노멀**: \(x = (-1)^s \cdot f \cdot 2^{-126}\) |
| 1..254 | * | **정규화 수** |
| 255 | 0 | **±무한대** |
| 255 | ≠0 | **NaN** (qNaN/sNaN) |

- **±0.0**: 부호만 다름. \(\frac{1}{+0}=+\infty, \frac{1}{-0}=-\infty\)
- **NaN 비교**: 어떤 값과도 같지 않음(`NaN == NaN`은 거짓), 전파 규칙 존재.

```c
#include <math.h>
#include <stdio.h>
int main(){
    double pz = 0.0, nz = -0.0;
    printf("1/+0=%+f, 1/-0=%+f\n", 1.0/pz, 1.0/nz);
    double nan = 0.0/0.0;
    printf("nan==nan? %s\n", (nan==nan)?"true":"false");
}
```

---

## 3. 반올림과 “연산은 비결합적이다”

### 3.1 반올림 모드

- **최근접, 짝수 우선**(Round to nearest, ties to even) — 기본
- 0쪽 절단, +∞/−∞ 쪽 반올림도 표준에 존재(`fesetround`)

반올림 때문에

$$
(a+b)+c \ne a+(b+c),\quad a\times(b\times c) \ne (a\times b)\times c
$$

```c
#include <stdio.h>
int main(){
    float a = 1e20f, b = -1e20f, c = 3.0f;
    float s1 = (a+b)+c; // (1e20 - 1e20) + 3 = 0 + 3 = 3
    float s2 = a+(b+c); // 1e20 + (-1e20+3) ≈ 1e20 + (-1e20) = 0 (3 손실)
    printf("%.1f vs %.1f\n", s1, s2);
}
```

### 3.2 머신 엡실론과 ULP

- **머신 엡실론**(ε): \(1.0 + \epsilon \neq 1.0\)인 최소 양수
  - float: \(2^{-23} \approx 1.1920929\times 10^{-7}\)
  - double: \(2^{-52} \approx 2.220446049250313\times 10^{-16}\)
- **ULP(Unit in Last Place)**: 인접 표현 가능 수 간 간격.  
  수의 크기(지수)에 따라 ULP가 달라진다.

```c
#include <float.h>
#include <math.h>
#include <stdio.h>
int main(){
    printf("eps(float)=%.9g, eps(double)=%.17g\n", FLT_EPSILON, DBL_EPSILON);
    double x=1.0, y=nextafter(1.0, 2.0); // 1.0 다음 representable
    printf("ULP at 1.0 = %.17g\n", y-x);
}
```

---

## 4. “0.1이 정확하지 않은” 이유와 이진 분수

**0.1(10진)**은 이진으로 **무한소수**:

$$
0.1_{10} = 0.0001100110011\overline{0011}_{2}
$$

유한 비트로는 **잘라서 반올림**해야 하므로 근사오차가 발생한다.  
C의 **16진 부동 리터럴**(C99)로 정확한 저장값 표시가 가능:

```c
double d = 0x1.999999999999ap-4; // 0.1의 double 근사
float  f = 0x1.99999ap-4f;       // 0.1의 float 근사
```

정확히 표현 가능한 예: 분모가 \(2^k\)인 유리수.  
예) \(0.15625 = 5/32 = 0.00101_2\) → float/double에 **정확히 저장**.

---

## 5. 연산 예외와 상태 플래그

IEEE 754는 **5가지 예외**와 **sticky 플래그**를 둔다.

| 예외 | 의미 |
|---|---|
| invalid | 정의 불가(0/0, \(\sqrt{-1}\), \(\infty - \infty\)) |
| divide-by-zero | 유한/0 |
| overflow | 표현 범위 초과(무한대로 포화) |
| underflow | 반올림이 서브노멀에서 발생 |
| inexact | 반올림이 발생한 모든 연산 |

C의 `fenv.h`로 제어/확인 가능:

```c
#include <fenv.h>
#include <math.h>
#include <stdio.h>
#pragma STDC FENV_ACCESS ON
int main(){
    feclearexcept(FE_ALL_EXCEPT);
    volatile double x = 1.0/0.0; (void)x;
    if (fetestexcept(FE_DIVBYZERO)) puts("divide-by-zero set");
}
```

---

## 6. 서브노멀(denormal)과 성능

- 장점: 0 근처에서 값의 연속성 유지(수치적 안정성)  
- 단점: 일부 CPU에서 **대폭 느려질 수 있음**  
  - x86 SSE: **FTZ(Flush-To-Zero)**, **DAZ(Denormals-Are-Zero)** 모드로 성능↑(정확도↓)

수치 민감 코드(필터, 최적화)에서 **서브노멀 유도**를 피하거나, 의도적으로 FTZ/DAZ 사용 여부를 결정한다.

---

## 7. 비교·합계·다항식 — 안전하고 정확하게 계산하기

### 7.1 비교: 절대/상대 허용오차

두 수 \(a,b\)의 “거의 같음”:

$$
|a-b| \le \max(\text{abs\_tol}, \text{rel\_tol}\cdot\max(|a|,|b|))
$$

```c
#include <math.h>
static int nearly_equal(double a, double b, double rel, double abs){
    double diff=fabs(a-b);
    if(diff<=abs) return 1;
    return diff<=rel*fmax(fabs(a),fabs(b));
}
```

- \(+0.0\) vs \(-0.0\)는 **부호비트**를 확인(`signbit`, `copysign`).

### 7.2 합계: 카한(Kahan)·노이마이어(Neumaier) 보정 합산

순차 합은 **작은 항이 사라지는 소실**(catastrophic cancellation) 발생. 보정 합산을 쓰면 오차가 크게 감소.

```c
double kahan_sum(const double* a, int n){
    double s=0.0, c=0.0;
    for(int i=0;i<n;i++){
        double y=a[i]-c;
        double t=s+y;
        c=(t-s)-y;  // 잃어버린 하위 비트 누적
        s=t;
    }
    return s;
}
```

- 대규모 합: **pairwise(분할 정복) 합산** 또는 **long double 누적**도 효과적.

### 7.3 다항식 계산: 호너(Horner) + FMA

다항식 \(p(x)=a_0 + a_1 x + \dots + a_n x^n\)은 호너로:

$$
p(x)=a_0 + x(a_1 + x(a_2 + \cdots + x a_n))
$$

FMA(묶음곱셈-덧셈, fused multiply-add)는 한 번의 반올림으로

$$
\text{fma}(x,y,z) \approx x\cdot y + z
$$

```c
#include <math.h>
double poly(double x, const double* a, int n){ // a[0..n]
    double r=a[n];
    for(int i=n-1;i>=0;i--) r = fma(r, x, a[i]); // 정확도↑
    return r;
}
```

---

## 8. 정수 ↔ 부동소수점 변환

### 8.1 정수 → 부동

- \(|i| \le 2^{24}\) (float), \(|i| \le 2^{53}\) (double)이면 **정확히 표현 가능**  
- 그 이상은 **간격(ULP)** 때문에 모든 정수가 정확하지 않다.

### 8.2 부동 → 정수

- C 캐스팅은 **0쪽 절단**. 오버플로 시 **UB** 또는 구현정의 → **범위 검사** 필수.

```c
#include <limits.h>
#include <math.h>
int dbl_to_int_checked(double x, int* out){
    if (isnan(x) || isinf(x) || x>INT_MAX || x<INT_MIN) return 0;
    *out = (int)x; return 1;
}
```

---

## 9. 직렬화·재해석 — 안전한 비트 관찰

### 9.1 엄격 별칭을 피하는 안전 패턴

```c
#include <stdint.h>
#include <string.h>
uint32_t float_bits(float f){
    uint32_t u; memcpy(&u, &f, sizeof u); return u;
}
float bits_float(uint32_t u){
    float f; memcpy(&f, &u, sizeof f); return f;
}
```

### 9.2 엔디안 주의

메모리 덤프 시 바이트 순서는 **엔디안 의존**. 파일/네트워크 포맷에는 **고정 바이트순서**를 문서화하고, 변환 함수를 사용한다.

---

## 10. 출력·입력 형식 — 10진 변환의 함정과 해법

- “사람에게 보이는” 10진 출력은 **반올림·자리수** 정책에 따라 다르게 보인다.  
- **정확한 round-trip**(문자열→부동→문자열 일치)을 위해 C++17 `std::to_chars`(shortest), C23 `printf("%g")` 개선, 또는 **Ryu/Grisu** 알고리즘 기반 라이브러리 사용.

---

## 11. 플랫폼 차이와 재현성

- x87(80비트 확장 정밀) vs SSE2(64비트) → **중간 정밀 차이**  
- 컴파일러 플래그: `-ffast-math` 계열은 **표준 보장 약화**(NaN/Inf 무시, 연산 재배열)  
- 병렬 합산 순서가 바뀌면 결과가 달라짐 → **결정적 합산 순서 고정** 필요

---

## 12. 종합 표/도해

### 12.1 float 근처 ULP·ε

| x | 인접수 간 간격(ULP) |
|---|---|
| 1.0 | \(2^{-23}\) ≈ \(1.19\times 10^{-7}\) |
| 0.5 | \(2^{-24}\) |
| 2.0 | \(2^{-22}\) |

머신 엡실론(이론상):  
- float: \(2^{-23}\)  
- double: \(2^{-52}\)

### 12.2 클래스 요약

```
exp==0     : 0 또는 서브노멀(숨은 1 없음)
1..max-1   : 정규(숨은 1)
exp==max   : ±∞(frac=0), NaN(frac≠0)
```

---

## 13. 실습: 같은 비트, 다른 해석

```python
import struct, math

raw = bytes.fromhex("3F800000")   # float 1.0 big-endian
print("as float :", struct.unpack(">f", raw)[0])  # 1.0
print("as uint32:", struct.unpack(">I", raw)[0])  # 1060110336

# ULP at 1.0 (double)
one = struct.unpack(">d", bytes.fromhex("3FF0000000000000"))[0]
next_up = math.nextafter(one, math.inf)
print("ULP(1.0) =", next_up - one)
```

---

## 14. 자주 하는 실수와 처방 10가지

1. **`==`로 부동 비교** → 허용오차(절대+상대)로 비교.  
2. **순차 합산만 사용** → 카한/노이마이어/페어와이즈 합.  
3. **서브노멀 성능 무시** → FTZ/DAZ 또는 값 스케일링.  
4. **0.1 누적** → 정수 카운트 기반로 **스케일 후 정수 계산**(고정소수점/센트 단위).  
5. **정수 캐스팅 오버플로 무시** → 범위 체크.  
6. **엔디안 무시한 직렬화** → 바이트순서 명시·테스트.  
7. **별칭 규칙 위반** → `memcpy` 사용.  
8. **반올림 모드 가정** → `fenv.h`로 명시/복원.  
9. **FMA 무시** → 다항식/내적에 `fma`로 오차↓.  
10. **재현성 미고려** → 합산 순서 고정·플래그 통제·테스트 케이스 고정.

---

## 15. 연습 문제

1) float에서 \(2^{-149}\)은 무엇을 의미하는가? 그 값은 어떻게 계산되는가?  
2) double에서 \(1.0\)의 다음 representable 값과의 간격을 수식으로 설명하라.  
3) \(0.1+0.2-0.3\)가 0이 아닌 이유를 16진 부동 리터럴로 설명하라.  
4) 서브노멀의 장단점을 한 줄씩 서술하라.  
5) 카한 합산과 페어와이즈 합산의 차이를 예로 들어라.  
6) `-0.0`을 판정하는 방법을 **코드**로 제시하라.

---

## 16. 부록 A — 반올림 모드 제어/예외 확인

```c
#include <fenv.h>
#include <stdio.h>
#pragma STDC FENV_ACCESS ON
int main(){
    fesetround(FE_TONEAREST);
    // ... 연산 ...
    feclearexcept(FE_ALL_EXCEPT);
    volatile double x = 1.0/0.0;
    if (fetestexcept(FE_DIVBYZERO)) puts("divide-by-zero");
}
```

---

## 17. 부록 B — 안전한 “비트 관찰” 도구

```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>

static void print_bits_u32(uint32_t u){
    for(int i=31;i>=0;i--) putchar((u>>i)&1?'1':'0');
}

int main(){
    float f = 0.1f;
    uint32_t u; memcpy(&u, &f, sizeof u);
    printf("0.1f bits: 0x%08X\n", u);
    print_bits_u32(u); puts("");
}
```

---

## 18. 결론 — “실수는 근사와 계약의 산물”

부동소수점은 **정확한 실수의 세계**가 아니라, **근사와 규약의 세계**다.  
형식(정규/서브노멀/특수), 반올림, 예외, ULP/ε, 비교/합계/다항식의 기법, 직렬화와 별칭 규칙까지 이해하면,  
**예측 가능한 수치 해석**, **재현 가능한 성능**, **신뢰할 수 있는 결과**에 도달할 수 있다.

> “정확성은 설계로 얻고, 일관성은 습관으로 지킨다.”  
> 부동소수점의 규약을 **문서와 코드**로 명시하고, 테스트로 검증하라.