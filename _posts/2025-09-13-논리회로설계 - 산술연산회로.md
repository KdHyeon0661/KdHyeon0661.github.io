---
layout: post
title: 논리회로설계 - 산술연산회로
date: 2025-09-13 16:25:23 +0900
category: 논리회로설계
---
# 산술연산회로 — **어큐뮬레이터(누산기) 직렬덧셈기**, **2진 곱셈기 설계**, **2진 나눗셈기 설계**

> 표기: `clk`(클럭), `rst`(동기 리셋 unless noted), `CE`(Clock Enable), \(\oplus\) XOR, \(\overline{X}\) NOT.  
> 합성 기준: `ieee.std_logic_1164`, `ieee.numeric_std` 권장(`unsigned/signed` 사용).

---

## 1) 어큐뮬레이터를 가진 **직렬 덧셈기** (Serial Adder with Accumulator)

### 1.1 개념과 동작
- **목표**: 한 클럭마다 **1비트**씩 두 피연산자 \(A,B\)를 더해 누산 레지스터에 결과를 축적.  
- **구성**:  
  - 두 입력 **시프트레지스터**: `Areg`, `Breg` (LSB-first 또는 MSB-first 선택)  
  - **전가산기(FA)**: \(s_i = a_i \oplus b_i \oplus c\), \(c^+ = a_ib_i + (a_i\oplus b_i)c\)  
  - **캐리 FF**: `C` (직전 자리올림 저장)  
  - **어큐뮬레이터**: 결과를 순차적으로 저장하는 `Acc`(시프트 또는 병렬 쓰기)
- **지연**: n비트 덧셈 → **n클럭**. 하드웨어는 매우 작음.

### 1.2 마이크로연산(LSB-first 예)
```
for i = 0..n-1:
  {si, C} <- FA(Areg(0), Breg(0), C)
  Areg   <- Areg >> 1
  Breg   <- Breg >> 1
  Acc    <- write_bit(si)     -- (LSB부터 채우거나 왼/오른쪽 shift)
end
Acc(n) <- C                    -- 마지막 캐리(옵션)
```

### 1.3 하드웨어 블록(ASCII)
```
Areg --┐
       ├─> a_i ┐
Breg --┘       ├─[Full Adder]─> s_i → Acc
C  <-----------┘            └-> C^+ (carry FF)
```

### 1.4 VHDL (n비트, LSB-first, 누산 결과 병렬)
```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;

entity serial_adder_acc is
  generic (N: positive := 16);
  port (clk, rst, ce : in  std_logic;
        start        : in  std_logic;
        a_in, b_in   : in  std_logic_vector(N-1 downto 0);
        busy         : out std_logic;
        sum_out      : out std_logic_vector(N downto 0); -- N+1비트(캐리 포함)
        done         : out std_logic);
end;

architecture rtl of serial_adder_acc is
  signal Areg, Breg  : std_logic_vector(N-1 downto 0);
  signal Acc         : std_logic_vector(N downto 0); -- [i 비트까지 누적]
  signal C           : std_logic := '0';
  signal cnt         : unsigned(15 downto 0) := (others=>'0');
  signal running     : std_logic := '0';
begin
  busy <= running;

  process(clk)
    variable s : std_logic;
    variable a0,b0 : std_logic;
  begin
    if rising_edge(clk) then
      if rst='1' then
        running <= '0'; cnt <= (others=>'0'); C <= '0';
        Areg <= (others=>'0'); Breg <= (others=>'0');
        Acc  <= (others=>'0'); done <= '0';
      elsif ce='1' then
        done <= '0';
        if start='1' and running='0' then
          Areg <= a_in; Breg <= b_in;
          Acc  <= (others=>'0');
          C    <= '0';
          cnt  <= (others=>'0');
          running <= '1';
        elsif running='1' then
          a0 := Areg(0); b0 := Breg(0);
          -- Full Adder
          s  := a0 xor b0 xor C;
          C  <= (a0 and b0) or ((a0 xor b0) and C);

          -- 누산기: LSB부터 채움
          Acc(to_integer(cnt)) <= s;

          -- 쉬프트
          Areg <= '0' & Areg(N-1 downto 1);
          Breg <= '0' & Breg(N-1 downto 1);

          -- 카운트/종료
          if cnt = to_unsigned(N-1, cnt'length) then
            Acc(N) <= C;            -- 최종 캐리 저장
            running <= '0'; done <= '1';
          else
            cnt <= cnt + 1;
          end if;
        end if;
      end if;
    end if;
  end process;

  sum_out <= Acc;
end;
```

**팁**  
- MSB-first면 시프트 방향·인덱스만 바꾸면 됨.  
- 입력이 **스트리밍(직렬)** 이면 `a_in/b_in` 대신 `si_a/si_b`와 SIPO를 사용.  
- 고속화: 두 비트씩 처리하는 **2비트 시리얼-병렬 하이브리드** 가능.

---

## 2) **2진 곱셈기** 설계

### 2.1 기본 원리
- 비서명(Unsigned) 곱셈: 부분곱의 **시프트-가산**  
  \[
  P = \sum_{i=0}^{n-1} b_i \cdot (A \ll i)
  \]
- 서명(Signed, 2의 보수): **Booth** 재부호화로 연속된 1을 압축 → 가산 횟수 감소.

---

### 2.2 **시프트-가산(Serial/Iterative) 곱셈기** (Unsigned)

#### 2.2.1 마이크로아키텍처
- 레지스터: `Areg`(피승수), `Breg`(승수), `Preg`(누산기, 2N비트), `cnt`.  
- 루프(LSB-first):
```
for i=0..N-1:
  if Breg(0)=1 then P <- P + (Areg << i)  -- 실제 구현은 A 좌시프트 후 가산
  Areg <- Areg << 1
  Breg <- Breg >> 1
end
```
- 가산기는 **가변 시프트된 A** 대신 **P에 A를 더하고 P를 시프트**하도록 재배열해면 배선이 단순.

#### 2.2.2 VHDL (Iterative, 1클럭/비트)
```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;

entity mul_shift_add is
  generic (N: positive := 16);
  port (clk,rst,ce,start: in std_logic;
        A, B: in  std_logic_vector(N-1 downto 0);
        busy: out std_logic;
        P:   out std_logic_vector(2*N-1 downto 0);
        done: out std_logic);
end;

architecture rtl of mul_shift_add is
  signal Areg   : unsigned(N-1 downto 0);
  signal Breg   : unsigned(N-1 downto 0);
  signal Preg   : unsigned(2*N-1 downto 0);
  signal cnt    : unsigned(15 downto 0) := (others=>'0');
  signal run    : std_logic := '0';
begin
  busy <= run;
  P    <= std_logic_vector(Preg);

  process(clk)
  begin
    if rising_edge(clk) then
      if rst='1' then
        run <= '0'; done<='0'; Preg<=(others=>'0');
      elsif ce='1' then
        done <= '0';
        if start='1' and run='0' then
          Areg <= unsigned(A);
          Breg <= unsigned(B);
          Preg <= (others=>'0');
          cnt  <= (others=>'0');
          run  <= '1';
        elsif run='1' then
          -- if LSB of B is 1, add A to lower half of P
          if Breg(0)='1' then
            Preg(N-1 downto 0) <= Preg(N-1 downto 0) + Areg;
          end if;
          -- shift P and B (right), keep accumulation
          Breg <= '0' & Breg(N-1 downto 1);
          Preg <= '0' & Preg(2*N-1 downto 1); -- 오른쪽 시프트(곱셈 위치 보정)

          if cnt = to_unsigned(N-1, cnt'length) then
            run  <= '0'; done<='1';
          else
            cnt  <= cnt + 1;
          end if;
        end if;
      end if;
    end if;
  end process;
end;
```

**노트**  
- 위 구조는 하드웨어 배선이 단순하고, `Preg` 시프트로 자리 정렬.  
- 가산 경로가 **N비트**로 고정되어 타이밍 예측이 쉽다.  
- 처리량이 낮다면 이 구조가 CPLD/소형 FPGA에 최적.

---

### 2.3 **Booth 곱셈기** (Signed, 2’s complement)

#### 2.3.1 Radix-2 Booth 재코딩
- 승수 \(B\)와 가상 비트 \(b_{-1}=0\)를 사용, 인접 두 비트 \(b_i, b_{i-1}\)로 **가산/감산/무시** 결정:
  
| \(b_i b_{i-1}\) | 동작 |
|:--:|:--|
| 00 | 0 (무시) |
| 01 | +A (더함) |
| 10 | −A (뺌) |
| 11 | 0 (무시) |

- 매 스텝마다 **산술 시프트**(부호 연장). 부호수 처리에 유리.

#### 2.3.2 Radix-4 Booth (가속)
- 3비트 윈도우 \([b_{i+1} b_i b_{i-1}]\) → \(\{0,\pm1,\pm2\}A\) 선택. 가산 횟수 절반 근사.

#### 2.3.3 VHDL (Radix-2, 1클럭/비트)
```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;

entity mul_booth_radix2 is
  generic (N: positive := 16);
  port (clk,rst,ce,start: in std_logic;
        A, B: in  std_logic_vector(N-1 downto 0); -- 2's complement
        busy: out std_logic;
        P:   out std_logic_vector(2*N-1 downto 0);
        done: out std_logic);
end;

architecture rtl of mul_booth_radix2 is
  signal Areg   : signed(N-1 downto 0);
  signal Breg   : signed(N-1 downto 0);
  signal Prod   : signed(2*N downto 0); -- 여유비트(부호 확장)
  signal b_prev : std_logic := '0';
  signal cnt    : unsigned(15 downto 0) := (others=>'0');
  signal run    : std_logic := '0';
begin
  P    <= std_logic_vector(Prod(2*N-1 downto 0));
  busy <= run;

  process(clk)
  begin
    if rising_edge(clk) then
      if rst='1' then
        run<='0'; done<='0'; Prod<=(others=>'0'); b_prev<='0';
      elsif ce='1' then
        done <= '0';
        if start='1' and run='0' then
          Areg <= signed(A);
          Breg <= signed(B);
          Prod <= (others=>'0');
          b_prev <= '0';
          cnt  <= (others=>'0');
          run  <= '1';
        elsif run='1' then
          -- Booth recode on (Breg(0), b_prev)
          if (Breg(0)='1' and b_prev='0') then
            Prod(2*N-1 downto N) <= Prod(2*N-1 downto N) + Areg;  -- +A
          elsif (Breg(0)='0' and b_prev='1') then
            Prod(2*N-1 downto N) <= Prod(2*N-1 downto N) - Areg;  -- -A
          end if;
          -- 산술 시프트 오른쪽 (Prod, Breg, b_prev를 묶어 1비트 산술 시프트)
          b_prev <= Breg(0);
          Breg   <= Breg sra 1;  -- 산술 시프트
          -- Prod도 산술 시프트: 최상위 비트 부호 유지
          Prod   <= Prod sra 1;

          if cnt = to_unsigned(N-1, cnt'length) then
            run<='0'; done<='1';
          else
            cnt <= cnt + 1;
          end if;
        end if;
      end if;
    end if;
  end process;
end;
```

**장점/단점**  
- 장점: 서명수 처리 자연스럽고, 연속 1 압축으로 가산 횟수↓.  
- 단점: 제어가 약간 복잡, 파이프라인 병렬화는 별도 설계 필요.

---

### 2.4 **병렬 곱셈기** (Array / Wallace / Dadda)
- **부분곱 행렬**을 한 번에 생성하여 **Carry-Save Adder(CSA)** 트리로 줄이고 마지막에 **Carry-Propagate Adder**로 합산.
- **Wallace/Dadda**: 리덕션 레벨 최소화 → 지연↓, 배선 복잡↑.  
- **FPGA**: 내장 **DSP 블록**(예: 18×25, 27×27)을 활용해 타이밍/면적 최적화.  
- **ASIC**: 부스 + CSA 트리 + CPA가 일반적.

---

### 2.5 고급 주제(간단 요약)
- **고정소수점**: 스케일 팩터 \(2^{-f}\) 추적, 오버플로우/반올림.  
- **포화(saturation)** vs **모듈러 wrap** 선택.  
- **파이프라인**: 스테이지를 나눠 Fmax ↑.  
- **검증**: 무작위 테스트와 레퍼런스 모델(소프트웨어) 비교.

---

## 3) **2진 나눗셈기** 설계

### 3.1 기본 정의(Unsigned)
- 배수 \(D\), 피제수 \(N\), 몫 \(Q\), 나머지 \(R\):
  \[
  N = Q\cdot D + R,\quad 0 \le R < D
  \]

### 3.2 **복원(Restoring) 나눗셈**
- 상위 비트부터 내려오며 **뺄셈 시도 → 음수면 복원**.
- **마이크로연산(1비트당 1클럭)**:
```
R <- 0
for i = n-1 downto 0:
  R <- (R << 1) + N[i]
  if R >= D then R <- R - D; Q[i] <- 1
  else               Q[i] <- 0
end
```
- 장점: 제어 단순, 단점: 실패 시 **복원(덧셈)** 필요 → 약간 비효율.

#### 3.2.1 VHDL (Unsigned Restoring)
```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;

entity div_restoring is
  generic (N: positive := 16);
  port (clk,rst,ce,start: in std_logic;
        Numer, Denom : in  std_logic_vector(N-1 downto 0);
        busy: out std_logic;
        Quot: out std_logic_vector(N-1 downto 0);
        Rem : out std_logic_vector(N-1 downto 0);
        div0, done: out std_logic);
end;

architecture rtl of div_restoring is
  signal A  : unsigned(N-1 downto 0); -- Numer
  signal B  : unsigned(N-1 downto 0); -- Denom
  signal R  : unsigned(N downto 0);   -- N+1 비트: 임시 나머지
  signal Q  : unsigned(N-1 downto 0);
  signal i  : integer range 0 to N := 0;
  signal run: std_logic := '0';
begin
  busy <= run; Quot <= std_logic_vector(Q); Rem <= std_logic_vector(R(N-1 downto 0));

  process(clk)
    variable R_try: unsigned(N downto 0);
  begin
    if rising_edge(clk) then
      if rst='1' then
        run<='0'; done<='0'; div0<='0'; Q<=(others=>'0'); R<=(others=>'0');
      elsif ce='1' then
        done<='0';
        if start='1' and run='0' then
          if Denom = (others=>'0') then
            div0 <= '1'; done<='1'; run<='0';
          else
            div0 <= '0';
            A <= unsigned(Numer); B <= unsigned(Denom);
            Q <= (others=>'0'); R <= (others=>'0');
            i <= N-1; run<='1';
          end if;
        elsif run='1' then
          -- 시프트-인
          R <= (R(N-1 downto 0) & A(i));
          -- 시도 뺄셈
          R_try := R - ('0' & B); -- 같은 폭(N+1)
          if R_try(N)='0' then     -- 음수 아님(언더플로우 없음)
            R <= R_try;
            Q(i) <= '1';
          else
            Q(i) <= '0'; -- R 복원(그대로 유지)
          end if;

          if i=0 then
            run<='0'; done<='1';
          else
            i <= i - 1;
          end if;
        end if;
      end if;
    end if;
  end process;
end;
```

---

### 3.3 **비복원(Non-Restoring) 나눗셈**
- R의 부호를 기억하여 **연속적으로 더했다 뺐다** 함. 복원 단계 제거 → 평균적으로 빠름.
- 알고리즘(상위→하위):
```
R <- 0
for i = n-1 downto 0:
  R <- (R << 1) + N[i]
  if R >= 0 then R <- R - D; Q[i] <- 1
  else            R <- R + D; Q[i] <- 0
end
-- 종료 후 R<0이면 R <- R + D (보정)
```

#### 3.3.1 VHDL (Unsigned Non-Restoring)
```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;

entity div_nonrestoring is
  generic (N: positive := 16);
  port (clk,rst,ce,start: in std_logic;
        Numer, Denom : in  std_logic_vector(N-1 downto 0);
        busy: out std_logic;
        Quot: out std_logic_vector(N-1 downto 0);
        Rem : out std_logic_vector(N-1 downto 0);
        div0, done: out std_logic);
end;

architecture rtl of div_nonrestoring is
  signal A      : unsigned(N-1 downto 0);
  signal B      : unsigned(N-1 downto 0);
  signal R      : signed(N downto 0);  -- 부호 포함
  signal Q      : unsigned(N-1 downto 0);
  signal i      : integer range 0 to N := 0;
  signal run    : std_logic := '0';
  signal finalize: std_logic := '0';
begin
  busy <= run;

  process(clk)
  begin
    if rising_edge(clk) then
      if rst='1' then
        run<='0'; done<='0'; div0<='0'; finalize<='0';
        Q<=(others=>'0'); R<=(others=>'0'); 
      elsif ce='1' then
        done<='0';
        if start='1' and run='0' then
          if Denom=(others=>'0') then div0<='1'; done<='1';
          else
            div0<='0';
            A <= unsigned(Numer); B <= unsigned(Denom);
            Q <= (others=>'0'); R <= (others=>'0'); i<=N-1; run<='1'; finalize<='0';
          end if;
        elsif run='1' then
          if finalize='0' then
            -- bring next bit
            R <= shift_left(R,1) + to_signed(integer(A(i)), R'length);
            -- decide add/sub
            if R >= 0 then
              R <= R - to_signed(integer(B), R'length); Q(i) <= '1';
            else
              R <= R + to_signed(integer(B), R'length); Q(i) <= '0';
            end if;
            if i=0 then
              finalize <= '1'; -- 보정 단계
            else
              i <= i - 1;
            end if;
          else
            -- 보정: R<0이면 +B
            if R < 0 then R <= R + to_signed(integer(B), R'length); end if;
            run<='0'; done<='1';
          end if;
        end if;
      end if;
    end if;
  end process;

  Quot <= std_logic_vector(Q);
  Rem  <= std_logic_vector(unsigned(R(N-1 downto 0)));
end;
```

---

### 3.4 **서명(2의 보수) 나눗셈**
- 입력 부호: \(s_N=\text{sign}(N)\), \(s_D=\text{sign}(D)\).  
- 절대값으로 나눗셈 수행 후,
  \[
  Q = \text{sgn}(N)\oplus\text{sgn}(D) \; ?\; -|Q|\;:\; |Q|,\quad
  R = \text{sgn}(N)\; ?\; -|R|\;:\; |R|
  \]
- 몫의 부호는 **XOR**, 나머지의 부호는 **피제수(N)** 를 따른다.  
- **에지 케이스**: `Denom=0`(예외), `N=MIN_INT, D=-1`(오버플로우) 처리.

---

### 3.5 SRT(고성능) 간단 개요
- **Sweeney–Robertson–Tocher**: 몫 디지트를 \(\{-2,-1,0,+1,+2\}\) 등에서 **테이블 기반 선택**.  
- 부분나머지를 기반으로 **가중치 있는 감산**을 병렬로 수행 → 고속(파이프라인 병렬화 용이).  
- 설계 복잡도↑, 고속 FPU/CPU에서 사용.

---

## 4) 예제 시나리오(수작업 추적)

### 4.1 직렬 덧셈기: \(A=10110101_2(=181)\), \(B=00101110_2(=46)\)
- i=0: \(1+0+C(0)\Rightarrow s=1, C=0\) → Acc[0]=1  
- i=1: \(0+1+C0\Rightarrow s=1,C=0\) → Acc[1]=1  
- …  
- 최종 \(Acc=11100011_2 (=227)\), 캐리=0 → \(181+46=227\) OK.

### 4.2 복원 나눗셈: \(N=19(10011_2), D=5(00101_2)\)
- 초기 R=00000  
- i=4..0 진행, 각 단계에서 시프트-인 및 \(R-D\) 시도  
- 결과 \(Q=00011_2(=3), R=000100_2(=4)\) → \(19=3\cdot5+4\) OK.

---

## 5) 검증/시뮬/타이밍 포인트

### 5.1 테스트벤치 공통 골격
```vhdl
-- 공통 TB 스켈레톤
entity tb is end;
architecture sim of tb is
  signal clk: std_logic:='0'; signal rst: std_logic:='1'; signal ce: std_logic:='1';
  -- DUT 신호들 선언...
begin
  clk <= not clk after 5 ns; -- 100MHz

  process begin
    wait for 50 ns; rst<='0';
    -- 시작 신호/입력 주기, done/busy 관찰
    wait;
  end process;
end;
```
- **랜덤 테스트**: 소프트웨어 모델과 결과 비교(곱/몫/나머지).  
- **경계조건**: 0, 최대값, 부호 경계, `Denom=0`.  
- **커버리지**: 덧셈 캐리/차용 경계, Booth의 `+A/-A/무시` 모든 케이스.

### 5.2 타이밍/합성
- 직렬/반복형: 경로 길이 짧아 **Fmax 높음**, 지연은 클럭 수에 비례.  
- 병렬/트리형: 경로 길이 길고 **파이프라인** 필요.  
- FPGA: DSP/BRAM/SRL 적극 사용. ASIC: AOI/CSA 트리 최적화.

---

## 6) 설계 선택 가이드 (요약표)

| 기능 | 면적 | 지연(클럭) | Fmax | 비고 |
|---|---:|---:|---:|---|
| 직렬 덧셈기(누산) | 최소 | n | 높음 | 스트리밍용 단순 |
| 시프트-가산 곱셈 | 매우 작음 | n | 높음 | 마이크로컨트롤러/임베디드 |
| Booth 곱셈 | 작음 | n(또는 n/2) | 중~높음 | 서명수 최적 |
| Wallace/Dadda | 큼 | 1~수 | 중 | 파이프라인 필요 |
| 복원 나눗셈 | 작음 | n+α | 높음 | 제어 단순 |
| 비복원 나눗셈 | 작음 | n+보정 | 높음 | 평균 빠름 |
| SRT | 큼 | 파이프라인 | 매우 높음 | FPU/고속 |

---

## 7) 실무 팁 모음
- **고정소수점**: 연산 후 비트폭/스케일 관리, 라운딩(Nearest/Trunc), 포화 선택.  
- **오버플로우 플래그**: 가산기 최상위 캐리/XOR로 산출, 디버그에 유용.  
- **부호입력 동기화**: signed/unsigned 캐스팅 일관성 유지(`numeric_std`).  
- **리셋**: 분할기/곱셈기 상태머신은 **동기 리셋**으로 안전하게 초기화.  
- **멀티스레드(멀티 인스턴스)**: 반복형을 여러 개 병렬로 두어 처리량↑(면적과 트레이드오프).  
- **부스/나눗셈 파이프라인**: 단계별 레지스터 삽입으로 타이밍 수렴.

---

### 마무리
- **어큐뮬레이터 직렬덧셈기**는 극단적으로 단순한 하드웨어로 긴 워드도 다룰 수 있는 기본 빌딩블록입니다.  
- **2진 곱셈기**는 **시프트-가산(간단)** → **Booth(서명 최적)** → **Wallace/Dadda(고속)** 로 확장하며, 타깃(ASIC/FPGA) 자원과 목표 주파수에 맞춰 고릅니다.  
- **2진 나눗셈기**는 **복원/비복원**이 교육·실무 모두에서 표준이며, 더욱 빠른 **SRT**는 고성능 영역에서 쓰입니다.  
- 모든 설계는 **명세→마이크로연산→FSM/데이터패스→VHDL→검증→타이밍**의 흐름으로 일관되게 접근하면 안정적으로 완성됩니다.
