---
layout: post
title: 정보보안기사 - FTP
date: 2025-11-12 17:25:23 +0900
category: 정보보안기사
---
# 완전 정리 (프로토콜 구조, Active/Passive, 명령/응답, NAT/방화벽, FTPS/SFTP, 보안 위협·완화, 서버 하드닝 vsftpd/ProFTPD/Pure-FTPd/IIS, 클라이언트 실습 curl/lftp/Python/PowerShell, 로깅·감사, 운영 체크리스트)

## 개요 — “파일 하나를 위해 두 개의 연결”

FTP는 **제어 연결(control)** 과 **데이터 연결(data)** 을 **분리**하는 고전적 파일 전송 프로토콜이다.
핵심 특징은 다음과 같다.

- **제어 채널**: TCP 21(기본). 명령/응답 교환(ASCII).
- **데이터 채널**: 파일/리스트 전송용. **Active**(서버가 연결 역방향 생성) 또는 **Passive**(클라이언트가 연결 생성).
- **명령/응답 모델**: `USER/PASS/RETR/STOR/LIST/...` ↔ `1xx~5xx` 코드.
- **표준과 확장**: RFC 959(기본), RFC 2389(확장 `FEAT`), RFC 2428(IPv6/EPRT/EPSV), MLSD/MLST(머신가독 리스트), MODE Z(압축), MDTM/SIZE(메타).
- **보안 계층**: (1) **FTPS**(FTP + TLS: Explicit/Implicit), (2) **SFTP**(SSH 파일 전송, **FTP와 다름**).
- **리스크**: 평문 인증, NAT/방화벽과의 **상성 문제**, **FTP Bounce/FXP**, 디렉터리 탈출, 브루트포싱.
- **현대적 권고**: 가능하면 **SFTP/HTTPS** 대체. **불가피**하면 **FTPS(Explicit, PROT P 강제)** + **좁은 PASV 포트 범위** + **하드닝**.

---

## 연결 모델: Active vs Passive

### 제어/데이터 채널 도식

```
(클라이언트)                           (서버)
TCP 21 ── 제어 채널(명령/응답) ──────────▶
        ◀────────────────────────────────

TCP ?  ── 데이터 채널(파일/목록) ─────────▶/◀────────
```

### Active(포트 방식, `PORT`/`EPRT`)

- **흐름**: 클라이언트가 제어 채널에서 `PORT`(IPv4) 또는 `EPRT`(IPv4/IPv6)로 **자신의 대기 포트**를 알려줌 → **서버가 TCP 20(전통) 또는 임의 포트로 클라이언트에 접속**해 데이터 채널을 생성.
- **문제**: 클라이언트가 **NAT/방화벽 뒤**에 있으면 서버의 역방향 접속이 차단되어 실패하는 경우가 많다.

### Passive(수동 방식, `PASV`/`EPSV`)

- **흐름**: 클라이언트가 `PASV`(IPv4) 또는 `EPSV`(IPv4/IPv6) 요청 → **서버가 자신의 대기 포트**를 알려줌 → **클라이언트가 서버에 접속**해 데이터 채널 생성.
- **장점**: 클라이언트 측 NAT/방화벽에 유리(**클라이언트 발신**). 현대 환경의 **기본 선택**.
- **운영 포인트**: 서버 측 **Passive 포트 범위**를 좁혀 방화벽 허용 규칙을 단순화.

> IPv6 환경에서는 **EPRT/EPSV** 사용을 우선 고려(주소 포맷 간단, NAT 없이도 일관적).

---

## 핵심 명령/응답 코드

### 대표 명령 (일부)

| 카테고리 | 명령 | 설명 |
|---|---|---|
| 인증 | `USER`, `PASS`, `ACCT` | 사용자/비번/계정 |
| 탐색 | `PWD`, `CWD`, `CDUP` | 현재/이동/상위 |
| 데이터 채널 | `PORT`/`EPRT`, `PASV`/`EPSV`, `TYPE`(A/I), `MODE`, `STRU` | 능동/수동, 전송 타입(ASCII/이미지) |
| 전송 | `RETR`, `STOR`, `APPE`, `REST`, `LIST`, `NLST`, `MLSD/MLST` | 다운로드/업로드/이어받기/목록 |
| 파일 조작 | `DELE`, `RNFR`→`RNTO`, `MKD`, `RMD` | 삭제/이름 변경/디렉터리 |
| 세션 | `SYST`, `FEAT`, `NOOP`, `QUIT` | 시스템/확장/연결유지/종료 |
| FTPS 확장 | `AUTH TLS`, `PBSZ`, `PROT` | TLS 시작/버퍼 사이즈/데이터 보호수준(P/C) |

### 응답 코드 범주

| 범주 | 뜻 | 예 |
|---|---|---|
| 1xx | 처리 시작(데이터 채널 곧 열림) | `150 Opening data connection` |
| 2xx | 성공 | `200 OK`, `226 Transfer complete`, `230 Logged in` |
| 3xx | 추가 정보 필요 | `331 User name okay, need password` |
| 4xx | 일시적 실패 | `425 Can't open data connection` |
| 5xx | 영구적 실패 | `530 Not logged in`, `550 Permission denied` |

**수동 모드 예(IPv4)**:
```
PASV
227 Entering Passive Mode (203,0,113,53,195,44)
# 포트 = 195*256 + 44 = 49964

```

**수동 모드 예(IPv6)**:
```
EPSV
229 Entering Extended Passive Mode (|||49964|)
```

---

## NAT/방화벽과 FTP

### 왜 어려운가?

- **제어 채널**에서 협상되는 데이터 채널 **IP/포트 정보**가 **동적**이며, Active 모드에선 **서버→클라 역방향 연결** 필요.
- NAT 장비가 FTP **제어 메시지 내용을 파싱**해 임시 룰을 열어주는 **Application Layer Gateway(ALG) / conntrack helper**가 필요할 수 있음.

### 권고

- **Passive 모드** 기본, 서버에서 **PASV 포트 범위**를 좁혀 고정.
- **방화벽**: TCP 21 + **PASV 범위** 허용(서버 인바운드).
- 필요 시 **nf_conntrack_ftp / nf_nat_ftp** 모듈 활용.

### Linux 방화벽 예시(iptables)

```bash
# 제어 채널

iptables -A INPUT -p tcp --dport 21 -j ACCEPT
# 데이터 포트 범위 (예: 50000-50100)

iptables -A INPUT -p tcp --dport 50000:50100 -j ACCEPT

# 커널 모듈(부팅 시 로드)

modprobe nf_conntrack_ftp
modprobe nf_nat_ftp
```

### nftables (신규)

```bash
table inet filter {
  chain input {
    type filter hook input priority 0;
    tcp dport 21 accept
    tcp dport {50000-50100} accept
  }
}
```

---

## 데이터 전송 타입/구조/모드

- `TYPE A`: **ASCII** 텍스트(개행 변환).
- `TYPE I`: **Binary(이미지)** — **항상 권장**(바이너리 안전).
- `STRU F`: File 구조(일반).
- `MODE S`: Stream(일반), `MODE Z`: 압축(서버/클라 지원 시).

> 텍스트/바이너리 혼동은 파일 손상을 유발. 현대에는 **항상 `TYPE I`로 고정**하는 것이 안전.

---

## 확장 명령과 유용 기능

- `FEAT`: 서버 지원 기능 나열(예: `AUTH TLS`, `PBSZ`, `PROT`, `MLSD` 등).
- `MDTM`: 파일 최종 수정 시각 가져오기.
- `SIZE`: 파일 크기 조회(단위 바이트).
- `REST <offset>`: **이어받기(Resume)**.
- `MLSD/MLST`: **머신 가독 목록**(정형화된 key=value 속성).

---

## 보안: FTPS vs SFTP vs SCP

| 항목 | FTP | **FTPS(Explicit/Implicit)** | **SFTP** | SCP |
|---|---|---|---|---|
| 운반 | TCP 21 + 데이터 채널 | **Explicit**: 21에서 `AUTH TLS` / **Implicit**: 990로 즉시 TLS | **SSH**(TCP 22) | SSH(22) |
| 암호화 | 없음(평문) | **TLS**(제어/데이터) | **SSH 채널** | SSH 채널 |
| 포트/방화벽 | 복잡(추가 데이터포트) | 복잡(같음, +TLS) | **단일 포트(22)** | 단일 포트(22) |
| 프로토콜 | 고전 FTP | FTP 확장 | **FTP와 무관**(완전 별개) | 별개 |
| 권고 | 레거시 | 반드시 **PROT P** 강제 | **현대 기본 권장** | 간단복사 용도 |

### 흐름(요약)

```
C: FEAT
S: 211-Features: AUTH TLS, PBSZ, PROT, ...
C: AUTH TLS             # TLS 업그레이드(제어 채널 암호화 시작)
... TLS handshake ...
C: PBSZ 0               # 반드시 0
S: 200 PBSZ=0
C: PROT P               # 데이터 채널 보호(암호화) 'P' / 평문 'C'
S: 200 Protection level set to P
```

> **반드시 `PROT P`** 를 **필수**로 설정(데이터 채널 암호화). 일부 환경에서 TLS 세션 재사용 이슈가 있으므로 **서버/클라 최신** 권장.

### SFTP 개요

- SSH의 **subsystem**으로 파일 전송/관리. 패킷 기반 **단일 채널**, 방화벽/NAT 우호적.
- FTP 명령/응답과 **전혀 다르다**. 흔히 FTP 대체로 채택.

---

## 서버 하드닝 — vsftpd / ProFTPD / Pure-FTPd / IIS

### vsftpd (리눅스: 경량·보안 중심)

**기본 설정 예(`/etc/vsftpd.conf`)**
```conf
listen=YES
listen_ipv6=YES
anonymous_enable=NO
local_enable=YES
write_enable=YES
dirmessage_enable=YES
use_localtime=YES
xferlog_enable=YES
connect_from_port_20=YES

# Chroot 격리

chroot_local_user=YES
# 홈디렉터리 쓰기 가능 시 필요한 보호 완화(주의)

allow_writeable_chroot=YES

# Passive 범위 고정

pasv_min_port=50000
pasv_max_port=50100

# FTPS (Explicit TLS)

ssl_enable=YES
allow_anon_ssl=NO
force_local_data_ssl=YES
force_local_logins_ssl=YES
ssl_tlsv1=YES
ssl_tlsv1_1=NO
ssl_tlsv1_2=YES
require_ssl_reuse=NO     # NAT/프록시 호환성 이슈 회피(필요 시)
rsa_cert_file=/etc/ssl/certs/ftp.pem
rsa_private_key_file=/etc/ssl/private/ftp.key

# 배너

ftpd_banner=Welcome to Secure FTP service.
```

**서비스/방화벽**
```bash
systemctl enable --now vsftpd
# 방화벽(예: firewalld)

firewall-cmd --permanent --add-service=ftp
firewall-cmd --permanent --add-port=50000-50100/tcp
firewall-cmd --reload
```

**fail2ban(브루트포스 방어)**
```ini
# /etc/fail2ban/jail.d/vsftpd.local

[vsftpd]
enabled = true
port    = ftp,ftp-data,ftps,50000:50100
filter  = vsftpd
logpath = /var/log/vsftpd.log
maxretry = 5
bantime  = 1h
```

### ProFTPD (모듈 유연, Apache 스타일)

```conf
ServerName          "ProFTPD"
DefaultRoot         ~
RequireValidShell   off
AuthOrder           mod_auth_file.c
User                ftp
Group               ftp

# Passive range

PassivePorts        50000 50100

# FTPS

TLSEngine           on
TLSProtocol         TLSv1.2
TLSRSACertificateFile /etc/ssl/certs/ftp.pem
TLSRSACertificateKeyFile /etc/ssl/private/ftp.key
TLSVerifyClient     off
TLSOptions          NoSessionReuseRequired
TLSRequired         control,data   # 제어/데이터 모두 TLS 강제

# FXP/Bounce 방지

AllowForeignAddress off
```

### Pure-FTPd (옵션 기반, TLS 손쉬움)

```bash
# 익명 비활성, TLS 강제, Passive 범위, chroot

pure-ftpd -A -E -j -Y 2 --tls=2 --passiveportrange 50000:50100 --chrooteveryone
```

### Windows IIS FTP (FTPS)

- **IIS Manager** → FTP Site 추가 → **FTP SSL Settings**에서 **Require SSL** + 인증서 바인딩.
- **FTP Firewall Support**에서 **Data Channel Port Range**(예: 50000-50100) 설정 후 Windows 방화벽 허용.

---

## 권한/격리/가상 사용자

- **chroot** 또는 가상 루트로 사용자 디렉터리 **격리**.
- **UMASK**(예: 022)로 업로드 기본 권한 제한.
- **가상 사용자**(PAM/DB/파일)로 시스템 계정과 분리.

vsftpd 예(가상 사용자 via PAM/db):
```conf
pam_service_name=vsftpd
guest_enable=YES
guest_username=ftpuser
user_sub_token=$USER
local_root=/srv/ftp/$USER
```

---

## 클라이언트 실습

### curl(FTP/FTPS)

```bash
# 리스트

curl -v ftp://user:pass@ftp.example.com/
# 다운로드

curl -O ftp://user:pass@ftp.example.com/pub/file.bin
# 업로드

curl -T local.bin ftp://user:pass@ftp.example.com/incoming/

# 수동 모드/PASV 제어

curl --ftp-pasv -O ftp://user:pass@host/file
curl --ftp-port -O ftp://user:pass@host/file   # Active 모드 (NAT 시 실패 가능)

# 강제

curl --ssl-reqd -O ftp://user:pass@host/file
# 데이터 채널 보호 확인(일반적으로 curl은 PROT P 사용)

```

### lftp(풍부한 명령, 동기화)

```bash
lftp -u user,pass ftp.example.com
lftp> set ftp:passive-mode on
lftp> set ftp:ssl-force true
lftp> set ftp:ssl-protect-data true
lftp> mirror -R ./local_dir /remote_dir      # 업로드 동기화
lftp> pget -n 4 big.iso                      # 분할 병렬 다운로드
```

### Python(ftplib / FTP_TLS)

```python
from ftplib import FTP, FTP_TLS

# 기본 FTP

ftp = FTP('ftp.example.com')
ftp.login('user', 'pass')
ftp.set_pasv(True)
ftp.cwd('/incoming')
with open('upload.bin', 'rb') as f:
    ftp.storbinary('STOR upload.bin', f)
with open('download.bin', 'wb') as f:
    ftp.retrbinary('RETR server.bin', f.write)
ftp.quit()

# FTPS (Explicit)

ftps = FTP_TLS('ftp.example.com')
ftps.login('user', 'pass')
ftps.prot_p()          # 데이터 채널 암호화
ftps.cwd('/secure')
print(ftps.nlst())
ftps.quit()
```

### PowerShell(.NET WebRequest)

```powershell
# 다운로드

$client = New-Object System.Net.WebClient
$client.Credentials = New-Object System.Net.NetworkCredential("user","pass")
$client.DownloadFile("ftp://ftp.example.com/pub/file.bin", "file.bin")

# 업로드

$uri = "ftp://ftp.example.com/incoming/upload.bin"
$ftp = [System.Net.FtpWebRequest]::Create($uri)
$ftp.Method = [System.Net.WebRequestMethods+Ftp]::UploadFile
$ftp.Credentials = New-Object System.Net.NetworkCredential("user","pass")
[byte[]]$bytes = [System.IO.File]::ReadAllBytes("upload.bin")
$stream = $ftp.GetRequestStream()
$stream.Write($bytes, 0, $bytes.Length)
$stream.Close()
$resp = $ftp.GetResponse()
$resp.StatusDescription
```

---

## 진단/디버깅/패킷 캡처

### openssl로 FTPS 테스트

```bash
# Explicit FTPS

openssl s_client -starttls ftp -connect ftp.example.com:21 -alpn ftp
# Implicit FTPS

openssl s_client -connect ftp.example.com:990
```

### Wireshark 필터

```
ftp || ftp-data          # 평문 FTP
ssl && tcp.port==21      # FTPS(제어)
tcp.port>=50000 && ssl   # FTPS(데이터, 범위 가정)
```

### 서버 상태 확인

- vsftpd: `/var/log/vsftpd.log`, `/var/log/xferlog`
- ProFTPD: `/var/log/proftpd/proftpd.log`, `xferlog`
- IIS: `%SystemDrive%\inetpub\logs\LogFiles`

---

## 로깅/감사와 분석

### xferlog 예(표준)

```
Mon Nov 11 01:02:03 2025 1 user 12345 /incoming/a.bin b _ o r user@host ftp 0 * c
```
- 전송 시각/소요/사용자/바이트/경로/전송유형/방향/액세스/호스트/프로토콜/암호화 등 서버마다 필드 차이.

### 간단 집계 스크립트(awk)

```bash
# 일자별 총 전송 바이트

awk '{bytes[$1" "$2" "$3]+= $5} END {for(d in bytes) print d, bytes[d]}' /var/log/xferlog | sort
```

---

## 보안 위협과 대응

### 평문 인증/데이터

- 위험: 도청·크리덴셜 탈취.
- 대응: **FTPS Explicit + PROT P 강제** 또는 **SFTP**로 전환. **HSTS 유사 메커니즘 없음** → 서버 측에서 **TLS 필수** 설정.

### FTP Bounce (PORT 악용)

- 개념: 클라이언트가 `PORT`로 **제3자 IP/포트**를 지정, 서버가 그곳에 데이터 채널을 열어 **스캔/리플렉션** 가능.
- 대응: **외부 주소 금지**, `AllowForeignAddress off`(ProFTPD), vsftpd는 기본 방지.

### FXP(서버↔서버 직접 전송)

- 위험: 정책 우회/데이터 유출 경로.
- 대응: **FXP 비활성**(`AllowForeignAddress off`, `no_anon_password=YES`, 등 서버별 옵션).

### 디렉터리 트래버설/심볼릭 링크

- 위험: `..`/심링크로 **격리 탈출**.
- 대응: **chroot 격리**, 심링크 제한, 업로드 디렉터리 **실행 비권한**, 안전한 **umask**.

### 브루트포스/사전 공격

- 대응: **fail2ban**, 계정 잠금/지연, **강력한 비밀번호 정책**, **MFA(가능 시 SFTP)**.

### 인증서/암호스위트 취약성

- 대응: **TLS 1.2+**, 취약 스위트 제거, 재협상 제한, **OCSP 스테이플링**(프록시 앞단), **갱신 자동화**.

---

## 파일 무결성·재시도·재개

- 무결성 검증: 서버/클라의 `MDTM`, `SIZE`, **(확장)** `HASH`/`XSHA1`/`XMD5` 지원 여부 확인.
- 이어받기: `REST <offset>` → `RETR`.
- 재전송 전략: 클라에서 **지수 백오프**, 최대 시도 제한, **멀티 파트 병렬**(lftp 등) 고려.

---

## IPv6, EPRT/EPSV, MLSD

- **IPv6**: `EPRT`/`EPSV`로 단순화. 방화벽 규칙 동일(포트 기준).
- **MLSD/MLST**: 기계가 읽기 쉬운 리스트(권장). `LIST`의 **파싱 어려움** 해소.

예:
```
MLSD
150 Opening data connection.
type=file;size=1234;modify=20251101010203; unique=801U1; a.bin
type=dir;modify=20251101000000; subdir
226 Transfer complete.
```

---

## 운영 시나리오

### 시나리오 A — “사내 수집 서버(FTPS, 외부 파트너 업로드)”

1. DMZ에 **vsftpd+Explicit TLS(PROT P)** 설치, **익명 금지/가상 사용자**.
2. **PASV 50000–50100** 범위, 방화벽 인바운드 허용.
3. 업로드는 `/incoming`만 허용(실행 비권한), **chroot** 격리.
4. **xferlog + SIEM** 연계, **fail2ban**.
5. 인증서 **자동 갱신**(예: acme hook → vsftpd reload).

### 시나리오 B — “레거시 교환 대체(SFTP로 마이그레이션)”

1. SSH 포트 22, **SFTP 서브시스템** 활성, **ChrootDirectory**로 격리.
2. 기존 FTP 클라엔트엔 **WinSCP/lftp** 전환 가이드 제공.
3. **키 기반 인증 + MFA**(가능 시), 비밀번호 인증 순차 폐지.

### 시나리오 C — “클라우드 경유(부득이 FTP 유지)”

1. L4/TCP 로드밸런서로 **21 + PASV 범위**를 고정 매핑(스케일 아웃 시 각 백엔드 동일 범위).
2. **ALB/프록시**는 FTP 인지하지 못하므로 피함(혼합 모드는 복잡).
3. 가능하면 **SFTP(AWS Transfer Family 등)** 으로 전환.

---

## 운영 체크리스트

- [ ] **익명 로그인 비활성**, 필요 시 업/다운 분리 권한.
- [ ] **chroot 격리**, 업로드 디렉터리 **실행/리스트릭트 권한**.
- [ ] **FTPS(Explicit) + PROT P 필수**, TLS 1.2+.
- [ ] **Passive 포트 범위 고정** 및 방화벽/보안그룹 허용.
- [ ] **FXP/Bounce 금지**, 외부 주소 PORT 차단.
- [ ] **로그/감사 활성**(xferlog, 인증 실패), **SIEM 연계**.
- [ ] **fail2ban/레이트 리밋**으로 브루트포스 억제.
- [ ] **UMASK/권한/소유자 정책**, 업로드 후 **소유자 전환**(필요 시).
- [ ] **정기 취약점 점검**(서버/라이브러리), **업데이트**.
- [ ] **대체 경로 제시**: 가능 시 **SFTP/HTTPS**로 전환 로드맵.

---

## 미니 랩 — 패킷 한 눈에 보기

### 순서 (Passive, Binary 전송)

```
C: USER user
S: 331 Password required
C: PASS ****
S: 230 Logged in
C: TYPE I
S: 200 Type set to I
C: EPSV
S: 229 Entering Extended Passive Mode (|||50012|)
C: RETR a.bin
S: 150 Opening data connection
... (TCP 50012 데이터 흐름) ...
S: 226 Transfer complete
```

Wireshark 필터:
```
(ip.addr==203.0.113.53 && tcp.port==21) || (tcp.port==50012)
```

---

## 간단 수식 — 대역폭·지연 직관

FTP는 파일 전송의 **TCP 효율**에 지배된다. 한 연결의 최대 스루풋은 **대략**:

\[
\text{Throughput} \approx \frac{\text{CWND}}{\text{RTT}}
\]

또는 병목 대역폭 \(B\) 와 RTT \(T\) 에 대해 **BDP**:

\[
\text{BDP} = B \times T
\]

- 대용량/고지연(LFN) 환경에서는 **윈도우 확장**(OS 레벨)과 **병렬 스트림**(lftp `pget`)이 체감을 개선.

---

## 자주 묻는 질문(FAQ)

**Q1.** “왜 Passive 모드가 기본인가요?”
**A.** NAT/방화벽 환경에서 **클라이언트 발신**만 허용되는 경우가 많아 **역방향 접속이 필요한 Active**가 실패하기 쉬움.

**Q2.** “FTPS Explicit와 Implicit 차이?”
**A.** Explicit는 **21번**에서 `AUTH TLS`로 업그레이드(표준), Implicit은 **990번**에서 **처음부터 TLS**(역사적). 오늘날 **Explicit** 권장.

**Q3.** “SFTP가 FTP의 일종인가요?”
**A.** **아님**. **SSH** 기반의 별도 프로토콜. 포트 22 단일, 방화벽 친화적.

**Q4.** “서버가 LIST로 한글/스페이스 처리 엉망입니다.”
**A.** `MLSD/MLST` 지원을 사용. 클라이언트도 MLSD 우선 옵션 사용 권장.

**Q5.** “TLS 세션 재사용 오류로 전송 실패?”
**A.** 일부 FTPS 구현에서 데이터 채널에 TLS **세션 재사용 요구**로 문제. 서버/클라 최신화, `NoSessionReuseRequired`(ProFTPD), `require_ssl_reuse=NO`(vsftpd) 등 조정.

---

## 실습 과제(실기 스타일)

1. **vsftpd로 FTPS Explicit 서버 구축**
   - `ssl_enable=YES`, `force_local_*_ssl=YES`, `pasv_min/max_port` 지정, 방화벽 열기.
   - 클라이언트 `curl --ssl-reqd` 로 `RETR/STOR` 검증.

2. **Wireshark로 Active vs Passive 비교 캡처**
   - Active에서 서버가 **클라이언트로 연결**하는 패킷(20/tcp 시작)을 식별.
   - Passive에서 클라이언트→서버 데이터 접속 포트를 확인.

3. **lftp로 이어받기/병렬 다운로드**
   - `pget -n 4` 로 대용량 파일, 중도 중단 후 재시도.

4. **fail2ban으로 5회 실패시 1시간 차단**
   - 공격 시나리오(사전 공격) 후 `iptables` 규칙 변화/로그 확인.

5. **FXP 차단 검증**
   - `AllowForeignAddress off` 설정 전/후, 서버 간 전송 시도.

---

## 요약

- FTP는 **제어/데이터 분리**라는 역사적 설계로 인해 **NAT/방화벽**과의 상성이 까다롭다. **Passive + 고정 포트 범위**가 현대 기본.
- **보안상 평문 금지**: 가급적 **SFTP**로, 불가피하면 **FTPS(Explicit)** + **PROT P** 강제.
- 서버 하드닝: **익명 금지, chroot, UMASK, FXP/Bounce 차단, 로그/감사 + fail2ban**, **TLS 1.2+**.
- 운영 효율: **MLSD/MLST**, `REST` 재개, **자동화 클라**(lftp, Python).
- 본 문서의 설정/스크립트/캡처 절차를 그대로 따라하면 **안정적이고 보안적인 파일 교환 인프라**를 구축할 수 있다.
