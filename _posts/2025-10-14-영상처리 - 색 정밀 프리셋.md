---
layout: post
title: 영상처리 - 색 정밀 프리셋
date: 2025-10-14 18:25:23 +0900
category: 영상처리
---
# 1) **색 정밀 프리셋**: 사진(4:2:0, Q=90) / UI·문서(4:4:4, Q=92) 구분

> 목표  
> - **사진(Photographic)**과 **UI·문서(텍스트/선/도형)**를 **자동/수동으로 구분**해, 각자 **최적 프리셋**으로 JPEG 인코딩.  
> - 사진에는 **4:2:0 + Q=90**(용량 효율↗, 시각 품질 유지),  
> - UI·문서에는 **4:4:4 + Q=92**(텍스트 가장자리 컬러번짐 방지, 픽셀 레벨 정합 유지).  
> - TurboJPEG(`tjCompress2`) 중심으로 설명하고, 필요 시 jpeglib 경로 설정도 함께 제시합니다.  
> - 코드 블록은 모두 **한 번만** ``` 로 감쌉니다. 수학은 MathJax를 사용합니다.

---

## 0) 왜 프리셋을 나누나?

**색차 서브샘플링(Chroma Subsampling)** 은 사람 눈이 밝기(Y) 변화엔 민감하고 색(Cb/Cr) 변화에는 둔감하다는 성질을 활용합니다.  
- **사진**: 색 경계가 부드러워 **4:2:0**으로도 **품질 저하가 거의 느껴지지 않으면서 용량이 크게 감소**합니다.  
- **UI·문서**(텍스트/아이콘/선): 색 경계가 날카롭고 픽셀을 정밀하게 쓰므로 **4:4:4**가 **색 번짐/울림**을 막습니다.

> 시각적 차이의 직관  
> - 텍스트 스크린샷을 4:2:0으로 인코딩하면 경계에 **컬러 프린지**가 생기기 쉽습니다(특히 ClearType 등 서브픽셀 렌더링).  
> - 사진을 4:4:4로 저장하면 용량이 **불필요하게 증가**하는 경향이 큽니다(대부분의 장면에서 체감 품질 이득은 작음).

---

## 1) 색차 서브샘플링 요약

- **4:4:4**: Y, Cb, Cr 모두 **원본 해상도**. 색선명도 최상, 용량↑.  
- **4:2:2**: 수평으로 Cb/Cr 반감.  
- **4:2:0**: 수평·수직 모두 Cb/Cr 반감(픽셀 4개가 하나의 크로마 샘플 공유). **용량 효율 최고**.

픽셀 수를 \( W \times H \) 라 할 때, 대략적 비트/픽셀(BPP) 관점에서,
\[
\text{BPP}_{444} > \text{BPP}_{422} > \text{BPP}_{420}
\]
(정확한 값은 Q테이블/씬 복잡도에 의존)

---

## 2) 품질 Q(1~100)의 역할

JPEG의 Q는 양자화 정도를 제어합니다. **클수록** 양자화가 약해져 **상세 보존**(용량↑), 작을수록 용량↓(상세↓).  
권장 베이스라인(현대 디스플레이·일반 사용 기준):
- **사진**: 4:2:0에 **Q=90**이면 **품질/용량 균형**이 매우 좋음.  
- **UI·문서**: 4:4:4에 **Q=92**로 경계를 깔끔히 유지(특히 작은 텍스트/얇은 라인).  

> 팁  
> - 문서/도형은 **TJFLAG_ACCURATEDCT**를 선택하면 미세한 모서리가 더 안정적입니다(속도는 조금 손해).  
> - 사진은 **TJFLAG_FASTDCT**도 무난합니다.

---

## 3) 프리셋 정의

- **PresetPhoto**: `TJSAMP_420`, `quality=90`, `FASTDCT`, `OPTIMIZE`, (선택) `PROGRESSIVE`  
- **PresetUI**:    `TJSAMP_444`, `quality=92`, `ACCURATEDCT`, `OPTIMIZE`, (선택) `PROGRESSIVE`

덕분에 **코드에서 “한 줄”로 의도 전달**이 명확해집니다.

---

## 4) TurboJPEG 예제 — 프리셋 적용 인코더

```cpp
#include <turbojpeg.h>
#include <vector>
#include <string>
#include "IppDib.h"

enum class Preset {
    Photo420_Q90,
    UIDoc444_Q92
};

struct TJParams {
    int subsamp;   // TJSAMP_420 or TJSAMP_444
    int quality;   // 1..100
    int flags;     // TJFLAG_*
};

static TJParams MakeParams(Preset p, bool progressive=true, bool optimize=true){
    TJParams t{};
    if (p == Preset::Photo420_Q90){
        t.subsamp = TJSAMP_420;
        t.quality = 90;
        t.flags   = TJFLAG_FASTDCT;              // 사진엔 빠른 DCT도 무난
    } else {
        t.subsamp = TJSAMP_444;
        t.quality = 92;
        t.flags   = TJFLAG_ACCURATEDCT;          // UI/문서는 경계 보존 우선
    }
    if (progressive) t.flags |= TJFLAG_PROGRESSIVE;
    if (optimize)    t.flags |= TJFLAG_OPTIMIZE_CODING;
    return t;
}

static bool TJEncodePreset(const IppDib& bgra, Preset preset, std::vector<unsigned char>& outJpeg, std::string& err){
    outJpeg.clear(); err.clear();
    if (!bgra){ err="invalid image"; return false; }

    TJParams P = MakeParams(preset, /*progressive*/true, /*optimize*/true);

    tjhandle h = tjInitCompress();
    if (!h){ err = tjGetErrorStr2(h); return false; }

    unsigned char* buf=nullptr;
    unsigned long  size=0;
    int rc = tjCompress2(
        h,
        (unsigned char*)bgra.bits(), bgra.width(), bgra.stride(), bgra.height(),
        TJPF_BGRA, &buf, &size,
        P.subsamp, P.quality, P.flags
    );

    if (rc != 0){
        err = tjGetErrorStr2(h); tjDestroy(h);
        return false;
    }

    outJpeg.assign(buf, buf+size);
    tjFree(buf);
    tjDestroy(h);
    return true;
}
```

**사용 예**
```cpp
IppDib img = LoadBGRA(...); // 기존 파이프라인 참고
std::vector<unsigned char> jpg;
std::string err;

// 사진으로 저장
TJEncodePreset(img, Preset::Photo420_Q90, jpg, err);
SaveBytes(L"photo420_q90.jpg", jpg);

// UI·문서로 저장
TJEncodePreset(img, Preset::UIDoc444_Q92, jpg, err);
SaveBytes(L"ui444_q92.jpg", jpg);
```

---

## 5) (선택) jpeglib 경로에서의 동일 프리셋

이미 구성한 `JpegEncodeOptions`가 있다면 **서브샘플링·품질·DCT**만 아래처럼 맞추면 동일합니다.

```cpp
// Photo 4:2:0 Q=90
opt.chroma = JpegChroma::CS420;
jpeg_set_quality(&c, 90, TRUE);
c.dct_method = JDCT_IFAST; // 사진: 빠른 DCT

// UI 4:4:4 Q=92
opt.chroma = JpegChroma::CS444;
jpeg_set_quality(&c, 92, TRUE);
c.dct_method = JDCT_ISLOW; // or JDCT_FLOAT (정확)
c.optimize_coding = TRUE;
jpeg_simple_progression(&c); // 원하면 프로그래시브
```

---

## 6) 자동 분류(사진 vs UI·문서) — **경량 히ュー리스틱**

> 수동 토글도 제공하되, 기본 폴백으로 **가볍고 안전한 자동 감지**를 둡니다.

### 6.1 아이디어
- **에지 밀도**: 텍스트/선 도형은 고주파(에지)가 많은 경향.  
- **채색 분할(팔레트성)**: UI는 **유니크 색상 수**가 상대적으로 적고 **고채도 평면**이 많음.  
- **채도/밝기 상관**: 사진은 **연속 음영**·색 변화가 부드럽다.

### 6.2 아주 단순한 구현(빠름, 의사코드 수준)
```cpp
struct ClassifyFeature { double edgeDensity; double uniqueColorRatio; double satMean; };

static ClassifyFeature ExtractFeatures_BGRA_Downscaled(const IppDib& src){
    // 1) 1/4 다운스케일로 계산량 축소(자체 보간 or IDCT 스케일 디코드 사용)
    IppDib s = DownscaleQuarter(src); // 구현은 기존 함수 재사용

    const int W=s.width(), H=s.height();
    // 2) Sobel로 edge magnitude 대략 추정
    auto L = [&](int x,int y)->int{ // 간단한 Y 추정
        const uint8_t* p=(const uint8_t*)s.bits()+y*s.stride()+x*4;
        int B=p[0],G=p[1],R=p[2]; return (int)(0.299*R+0.587*G+0.114*B);
    };
    double edgeCnt=0, total=W*H;
    for(int y=1;y<H-1;++y){
        for(int x=1;x<W-1;++x){
            int gx = -L(x-1,y-1)-2*L(x-1,y)+-L(x-1,y+1) + L(x+1,y-1)+2*L(x+1,y)+L(x+1,y+1);
            int gy = -L(x-1,y-1)-2*L(x,y-1)-L(x+1,y-1) + L(x-1,y+1)+2*L(x,y+1)+L(x+1,y+1);
            int mag = std::abs(gx)+std::abs(gy);
            if (mag > 200) edgeCnt++; // 임계
        }
    }
    double edgeDensity = edgeCnt / total;

    // 3) unique color ratio(거칠게): 5-5-5 bit로 양자화해 세기
    std::vector<uint8_t> hist(32*32*32,0);
    int uniq=0;
    for(int y=0;y<H;y++){
        const uint8_t* row=(const uint8_t*)s.bits()+y*s.stride();
        for(int x=0;x<W;x++){
            int B=row[x*4+0]>>3, G=row[x*4+1]>>3, R=row[x*4+2]>>3;
            int idx=(R<<10)|(G<<5)|B;
            if (!hist[idx]){ hist[idx]=1; uniq++; }
        }
    }
    double uniqueColorRatio = (double)uniq / (W*H);

    // 4) 평균 채도(HSV 단순 버전)
    auto SAT=[&](int r,int g,int b)->double{
        int mx=std::max({r,g,b}), mn=std::min({r,g,b}); if (mx==0) return 0.0;
        return (double)(mx - mn) / mx; // 0..1
    };
    double ssum=0;
    for(int y=0;y<H;y++){
        const uint8_t* row=(const uint8_t*)s.bits()+y*s.stride();
        for(int x=0;x<W;x++){
            int B=row[x*4+0], G=row[x*4+1], R=row[x*4+2];
            ssum += SAT(R,G,B);
        }
    }
    double satMean = ssum / (W*H);

    return {edgeDensity, uniqueColorRatio, satMean};
}

static Preset AutoPickPreset(const IppDib& bgra){
    auto f = ExtractFeatures_BGRA_Downscaled(bgra);
    // 간단 기준(프로젝트별로 튜닝):
    // 에지 많고, 유니크컬러 적고, 채도 낮으면 → UI
    if (f.edgeDensity > 0.12 && f.uniqueColorRatio < 0.05 && f.satMean < 0.35)
        return Preset::UIDoc444_Q92;
    return Preset::Photo420_Q90;
}
```

> **실전 팁**  
> - 작은 아이콘/텍스트가 포함된 사진(예: 캡처)에선 UI로 오검출 가능 → **수동 오버라이드** 옵션 제공.  
> - 반대로 사진 촬영물인데 포스터/간판이 가득하면 UI로 오검출 될 수 있음 → **히스토그램 평활 후 재판단** 같은 보완 가능.

---

## 7) UI 설계(예시)

- **“색 정밀 프리셋”** 드롭다운:  
  - 자동(권장), 사진(420,Q=90), UI·문서(444,Q=92)  
- **상세 옵션(고급)**:  
  - 품질 슬라이더, 서브샘플링 선택(420/422/444), Progressive, Optimize, Accurate DCT  
- **결과 미리보기**:  
  - 원본/결과 **탭**으로 전환, **차이 확대**(2×, 4×), 작은 텍스트 랜더링 품질 확인  
- **배치 처리**:  
  - 폴더 선택 → 자동 분류 + 프리셋 적용 → 결과 용량·시간 통계

---

## 8) PSNR/SSIM으로 프리셋 검증(개념)

품질 평가는 **주관적 시각 테스트**가 최종이지만, **PSNR/SSIM**으로 보조합니다.

- **PSNR**:
\[
\text{PSNR} = 10 \log_{10}\left( \frac{MAX^2}{\text{MSE}} \right),\quad
\text{MSE} = \frac{1}{WH}\sum_{x,y} (I(x,y)-\hat I(x,y))^2
\]
- **SSIM**(요약):
\[
\text{SSIM}(x,y)=\frac{(2\mu_x\mu_y + C_1)(2\sigma_{xy}+C_2)}{(\mu_x^2+\mu_y^2+C_1)(\sigma_x^2+\sigma_y^2+C_2)}
\]
UI·문서는 **경계 보존**이 핵심이므로, **국소 대비/에지 유지**를 별도 지표(예: 에지 PSNR)로 함께 봅니다.

---

## 9) 경계 사례와 팁

- **크기 매우 작은 텍스트/아이콘**: 4:2:0이면 번짐이 확연 → 4:4:4 고정.  
- **대부분 사진 + 일부 UI**: 자동 감지 후 **혼합 영역**만 별도 레이어로 4:4:4? → JPEG은 프레임 전체 서브샘플링이 동일해야 하므로 **2패스**(UI 영역만 크롭 저장) 또는 **품질/사이즈 요구에 맞춰 전체 444**를 고려.  
- **ClearType(서브픽셀 렌더링)**: RGB 서브픽셀을 이용하므로 **4:4:4**에서 이점이 큽니다.  
- **ICC/EXIF/XMP**: 메타 보존은 **jpeglib 경로**에서 재주입(앞 장 참고). 색 정확도가 중요한 UI 캡처라면 **sRGB ICC 부착** 고려.

---

## 10) 통합 시나리오

### 10.1 “자동→수동 오버라이드” 플로우
1) 디코드(BGRA) 후 `AutoPickPreset()`  
2) 프리셋으로 1차 인코드(미리보기)  
3) 사용자 확인: 사진/문서 스위치(라디오)  
4) 선택 반영해 최종 저장(배치 가능)

### 10.2 배치 변환(폴더)
- 자동 분류 후, 파일명 규칙으로 `_photo.jpg`, `_ui.jpg` 식 접미사.  
- 로그에 원본 크기/결과 크기/소요 ms/자동 분류 피처 기록 → 사후 튜닝에 활용.

---

## 11) (보너스) 타깃 사이즈와의 조합

“300KB 이하” 같은 요구가 있으면, **해상도 유지 우선** 모드에서  
- 사진: 4:2:0, Q 이진 탐색(§7의 타깃 사이즈 제어)  
- UI: 4:4:4, Q 이진 탐색 + 필요 시 **Q 하한**(예 85) 아래로는 **다운스케일**로 타협(경계 보존 우선)

---

## 12) 성능 메모

- TurboJPEG는 BGRA 입력을 직접 받아 SIMD로 빠르게 처리.  
- **사진 프리셋**은 4:2:0이므로 같은 Q에서도 **속도↑, 용량↓** 경향.  
- UI 프리셋은 4:4:4라 **용량↑**지만, 텍스트 선명도 이득이 커서 문서 보관/전달에 적합.

---

## 13) 작은 실험 가이드

- 테스트 세트:  
  - (A) 풍경/인물/저조도 사진 20장  
  - (B) UI 스크린샷 20장(다크/라이트, 작은 폰트 포함)  
- 각 이미지에 두 프리셋 적용 → **용량, 주관평가(경계 선명도), 확대(400%) 비교**  
- 결과 정리: 사진은 4:2:0이 **평균 -35% 용량**에서 차이 거의 없음, UI는 4:4:4가 **작은 폰트 선명도**에서 확실한 우위.

---

## 14) 결론

- **프리셋 분리**(사진=**4:2:0/Q90**, UI·문서=**4:4:4/Q92**)만으로 **품질 일관성과 용량 효율**을 동시에 잡을 수 있습니다.  
- TurboJPEG 경로는 **코드가 간단**하고 **고속**이며, 메타/색관리는 jpeglib 경로와 **병행**하세요.  
- 자동 감지 + 수동 오버라이드 UX로 실무 신뢰성을 높이세요.