---
layout: post
title: C++ - 입출력
date: 2024-09-30 19:20:23 +0900
category: Cpp
---
# 입출력 완전 정리: `cin`, `cout`, `fstream`, `iomanip`, `cerr`, `stringstream`

## 0) 핵심 한 줄 요약

- 콘솔: `<iostream>`의 `cin/cout/cerr/clog`  
- 파일: `<fstream>`의 `ifstream/ofstream/fstream` + **열기 모드**  
- 서식: `<iomanip>`의 `setw/setprecision/fixed/scientific/...`  
- 문자열 I/O: `<sstream>`의 `istringstream/ostringstream/stringstream`  
- 성능: `ios::sync_with_stdio(false); cin.tie(nullptr);` + `'\n'`  
- 견고성: **에러 상태(fail/eof/bad) 처리**, **예외 활성화**, **newline 처리(>> + getline 혼용 주의)**

---

## 1) 콘솔 I/O — `<iostream>`

### 1.1 표준 스트림과 기본 예제

| 스트림     | 용도                                  | 버퍼링      |
|------------|---------------------------------------|-------------|
| `std::cin` | 표준 입력(키보드)                     | 라인/완전   |
| `std::cout`| 표준 출력(화면)                       | 완전        |
| `std::cerr`| **에러 출력**                         | **즉시(flush)** |
| `std::clog`| 일반 **로그 출력**                    | 완전(지연)  |

```cpp
#include <iostream>
int main() {
    int a{};
    std::cout << "정수를 입력하세요: ";
    std::cin >> a;
    std::cout << "입력한 값: " << a << "\n";
}
```

### 1.2 개행과 버퍼 비우기

```cpp
std::cout << "Hello" << std::endl; // 개행 + flush(느림)
std::cout << "World\n";            // 개행만(권장, 성능 유리)
std::cout << std::flush;            // flush만
```

**팁**: 로그 전용 스트림에는 `std::unitbuf`/`std::nounitbuf`로 “항상 flush” 모드를 토글할 수 있습니다.
```cpp
std::cout << std::unitbuf;  // 모든 출력 후 자동 flush
std::cout << "항상 즉시 출력\n";
std::cout << std::nounitbuf;
```

### 1.3 빠른 I/O 설정(경쟁/대용량)

```cpp
#include <bits/stdc++.h> // (경쟁코드에서만) 또는 <iostream>
int main() {
    std::ios::sync_with_stdio(false); // C stdio와 동기 해제
    std::cin.tie(nullptr);            // cin과 cout의 묶음 해제
    // ... 대량 I/O 작업 ...
}
```
- `endl` 대신 `'\n'` 사용.
- `sync_with_stdio(false)`일 때 **scanf/printf와 혼용 금지**.

### 1.4 에러 상태와 견고한 입력 루프

스트림 상태 비트:
- `eofbit`: EOF에 도달  
- `failbit`: 변환/형식 실패  
- `badbit`: 물리적 오류

```cpp
#include <iostream>
#include <limits>
int main() {
    int x{};
    while (true) {
        std::cout << "정수 입력(끝: Ctrl+D/Ctrl+Z): ";
        if (std::cin >> x) {
            std::cout << "ok: " << x << "\n";
        } else {
            if (std::cin.eof()) break;               // 정상 종료
            std::cin.clear();                         // failbit 해제
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // 쓰레기 라인 폐기
            std::cerr << "정수가 아닙니다. 다시 시도.\n";
        }
    }
}
```

### 1.5 `>>`와 `getline` 혼용 시 개행 처리

```cpp
int n{};
std::cin >> n;            // 숫자만 읽고 '\n'은 남김
std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // 남은 개행 폐기
std::string line;
std::getline(std::cin, line); // 이제 정상 동작
```

또는 공백 스킵만 하고 싶다면:
```cpp
std::getline(std::cin >> std::ws, line); // 선행 공백 제거 후 라인 읽기
```

---

## 2) 파일 I/O — `<fstream>`

### 2.1 기본 열기/닫기와 RAII

```cpp
#include <fstream>
int main() {
    std::ofstream out("log.txt");              // 쓰기
    if (!out) { std::cerr << "열기 실패\n"; return 1; }
    out << "라인1\n";
} // out 소멸자에서 자동 close()
```

### 2.2 열기 모드 정리

| 플래그              | 의미                                |
|---------------------|-------------------------------------|
| `std::ios::in`      | 읽기                                |
| `std::ios::out`     | 쓰기                                |
| `std::ios::app`     | **항상 끝에 덧붙이기**(append)      |
| `std::ios::trunc`   | 열 때 길이 0으로 절단               |
| `std::ios::binary`  | **바이너리**(텍스트 변환 금지)      |
| `std::ios::ate`     | 열자마자 파일 끝으로 이동           |

예:
```cpp
std::ofstream out("a.txt", std::ios::out | std::ios::app); // 텍스트 append
std::ifstream bin("img.bin", std::ios::in | std::ios::binary);
```

### 2.3 전체 파일 읽기(텍스트)

```cpp
#include <fstream>
#include <sstream>
#include <string>

std::string read_all(const std::string& path) {
    std::ifstream fin(path);
    if (!fin) throw std::runtime_error("open fail");
    std::ostringstream ss;
    ss << fin.rdbuf();  // 버퍼를 통째로 복사
    return ss.str();
}
```

### 2.4 바이너리 읽기/쓰기

```cpp
#include <cstdint>
#include <fstream>
#include <vector>

struct Pixel { std::uint8_t r,g,b; };

int main() {
    std::vector<Pixel> buf(800*600);

    // 쓰기
    std::ofstream out("raw.rgb", std::ios::binary);
    out.write(reinterpret_cast<const char*>(buf.data()),
              static_cast<std::streamsize>(buf.size()*sizeof(Pixel)));

    // 읽기
    std::ifstream in("raw.rgb", std::ios::binary);
    in.read(reinterpret_cast<char*>(buf.data()),
            static_cast<std::streamsize>(buf.size()*sizeof(Pixel)));
}
```
> **주의**: 구조체를 그대로 파일에 쓰면 **엔디안/패딩** 차이로 **포터블하지 않음**.  
> 고정폭 타입과 명시적 직렬화 포맷(예: CSV/JSON/CBOR 등)을 고려.

### 2.5 예외 기반 오류 처리

```cpp
std::ifstream fin;
fin.exceptions(std::ifstream::failbit | std::ifstream::badbit);
try {
    fin.open("data.txt");
    int x; fin >> x;   // 실패 시 예외
} catch (const std::ios_base::failure& e) {
    std::cerr << "I/O 실패: " << e.what() << "\n";
}
```

---

## 3) 출력 서식 — `<iomanip>`

### 3.1 숫자/기수/부호/대문자
```cpp
#include <iomanip>
int n = 255;
std::cout << std::showbase << std::hex << n << "\n"; // 0xff
std::cout << std::dec << std::showpos << 42 << "\n"; // +42
std::cout << std::uppercase << std::hex << n << "\n"; // 0XFF
std::cout << std::nouppercase << std::noshowpos << std::dec;
```

### 3.2 고정/지수/정밀
```cpp
double pi = 3.1415926535;
std::cout << std::fixed    << std::setprecision(2) << pi << "\n"; // 3.14
std::cout << std::scientific << std::setprecision(3) << pi << "\n"; // 3.142e+00
std::cout << std::defaultfloat; // 기본 모드로 되돌리기
```

### 3.3 필드 폭/정렬/채우기
```cpp
std::cout << std::setw(8) << 42 << "\n";                 // (기본: 오른쪽 정렬)
std::cout << std::left  << std::setw(8) << 42 << "\n";   // 왼쪽 정렬
std::cout << std::right << std::setw(8) << 42 << "\n";   // 오른쪽 정렬
std::cout << std::internal << std::setw(8) << -42 << "\n"; // 부호/값 분리 정렬
std::cout << std::setfill('-') << std::setw(8) << 42 << "\n"; // ------42
std::cout << std::setfill(' ');                           // 원복
```
- `setw`는 **1회용**(다음 출력엔 초기화).
- `setfill`/정렬/기수/정밀 등은 **상태 유지**.

### 3.4 불/포인트/공백처리
```cpp
std::cout << std::boolalpha << true << " " << false << "\n"; // true false
std::cout << std::noboolalpha << true << " " << false << "\n"; // 1 0
std::cout << std::showpoint << 3.0 << "\n"; // 3.00000 (fixed와 함께 의미)
std::cout << std::noshowpoint;
```

### 3.5 시간 포맷: `put_time`
```cpp
#include <ctime>
#include <iomanip>
std::time_t t = std::time(nullptr);
std::tm tm = *std::localtime(&t);
std::cout << std::put_time(&tm, "%Y-%m-%d %H:%M:%S") << "\n";
```

---

## 4) 문자열 스트림 — `<sstream>`

### 4.1 `istringstream` — 문자열 파싱
```cpp
#include <sstream>
#include <string>
#include <iostream>

int main() {
    std::string s = "100 3.14 Hello";
    std::istringstream iss(s);
    int i{}; double d{}; std::string word;
    if (iss >> i >> d >> word) {
        std::cout << i << "," << d << "," << word << "\n";
    }
}
```

### 4.2 `ostringstream` — 문자열로 포맷 출력
```cpp
#include <sstream>
#include <iomanip>
std::ostringstream oss;
oss << std::fixed << std::setprecision(2) << 3.14159;
std::string out = oss.str(); // "3.14"
```

### 4.3 `stringstream` — 양방향 + 재사용

```cpp
#include <sstream>
#include <limits>

std::stringstream ss;
ss << "1,2,3";
int a,b,c; char comma;
ss >> a >> comma >> b >> comma >> c; // CSV 간단 파싱

// 재사용 시: 상태/버퍼 초기화
ss.clear();         // 에러 비트 초기화
ss.str(std::string{}); // 내용 비우기
```

### 4.4 CSV 안전 파싱(빈 칸/빈 필드 처리)
```cpp
#include <sstream>
#include <string>
#include <vector>

std::vector<std::string> split_csv_line(const std::string& line) {
    std::vector<std::string> cols;
    std::string cur;
    bool in_quote = false;
    for (size_t i = 0; i < line.size(); ++i) {
        char ch = line[i];
        if (ch == '"') {
            if (in_quote && i+1 < line.size() && line[i+1] == '"') { cur.push_back('"'); ++i; }
            else in_quote = !in_quote;
        } else if (ch == ',' && !in_quote) {
            cols.push_back(cur); cur.clear();
        } else {
            cur.push_back(ch);
        }
    }
    cols.push_back(cur);
    return cols;
}
```

---

## 5) 에러/로그 스트림 — `cerr` vs `clog`

```cpp
std::cerr << "즉시 에러: 파일 열기 실패\n";   // 항상 flush됨(단위 버퍼)
std::clog << "배치 로그: 처리 중 ...\n";     // 지연 flush(성능 유리)
```

### 5.1 타임스탬프 로그 패턴
```cpp
#include <iostream>
#include <iomanip>
#include <ctime>

void log_info(const std::string& msg) {
    std::time_t t = std::time(nullptr);
    std::tm tm = *std::localtime(&t);
    std::clog << std::put_time(&tm, "%F %T") << " [INFO] " << msg << '\n';
}
```

### 5.2 `cout`을 파일로 임시 리다이렉트
```cpp
#include <fstream>
#include <iostream>

int main() {
    std::ofstream file("out.txt");
    auto* oldbuf = std::cout.rdbuf(file.rdbuf()); // cout → 파일
    std::cout << "이건 파일로 갑니다\n";
    std::cout.rdbuf(oldbuf);                       // 복원
    std::cout << "다시 콘솔\n";
}
```

---

## 6) 실전 이슈 & 함정 모음

### 6.1 `>>` vs `getline` 혼용
- `>>`는 공백에서 끊고, `getline`은 줄 전체를 읽습니다.  
- 섞어쓰면 **남은 개행** 때문에 첫 `getline`이 빈 문자열을 얻습니다 → `ignore`로 버퍼 정리.

### 6.2 C I/O와 혼용
- `std::ios::sync_with_stdio(false)` 상태에서 `printf/scanf`와 섞으면 **순서 뒤바뀜/데드락** 위험.  
- 섞지 않거나, 동기화 유지.

### 6.3 포맷 상태 지속/일회성 규칙
- `setw`는 one-shot, `setfill`/`fixed`/`precision`은 지속.  
- 라이브러리 함수 내에서 상태를 변경했다면 **원복**까지 책임지는 게 매너.
  ```cpp
  std::streamsize oldp = std::cout.precision();
  std::cout << std::fixed << std::setprecision(2) << 3.0 << "\n";
  std::cout.precision(oldp); // 복원
  ```

### 6.4 로케일/유니코드
- `wcin/wcout`, `wifstream/wofstream`(wide) + `imbue(std::locale(""))`로 로케일 적용.  
- Windows 콘솔 UTF-8은 별도 설정(환경/콘솔 코드페이지)이 필요할 수 있습니다.  
- 크로스플랫폼 UTF-8은 **파일은 UTF-8**, 콘솔은 환경 의존으로 분리 설계가 현실적.

### 6.5 바이너리/텍스트 차이(윈도우)
- 텍스트 모드에서 `\n` ↔ `\r\n` 변환. 바이너리 데이터는 반드시 `std::ios::binary`로.

---

## 7) 치트시트 — 서식 조작자 한눈에

| 카테고리     | 조작자 예시 |
|--------------|-------------|
| 기수         | `std::dec / std::hex / std::oct / std::showbase / std::uppercase` |
| 부호/대소문자| `std::showpos / std::noshowpos / std::uppercase / std::nouppercase` |
| 부동소수점   | `std::fixed / std::scientific / std::defaultfloat / std::setprecision(n) / std::showpoint` |
| 폭/정렬/채움 | `std::setw(n) / std::left / std::right / std::internal / std::setfill(ch)` |
| 불리언       | `std::boolalpha / std::noboolalpha` |
| 공백/개행    | `std::ws / std::endl / '\n' / std::flush` |
| 시간         | `std::put_time(&tm, "%F %T")` |

---

## 8) 미니 프로젝트: **CSV 요약 리포트** (파일→파싱→서식 출력)

> `data.csv` (헤더 포함, `name,score`)를 읽어 평균/최고/최저를 계산해 깔끔하게 포맷팅.

```cpp
```cpp
#include <bits/stdc++.h> // 또는 <iostream> <fstream> <sstream> <vector> <iomanip> <limits>
struct Row { std::string name; double score; };

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    std::ifstream fin("data.csv");
    if (!fin) { std::cerr << "data.csv 열기 실패\n"; return 1; }

    std::string line;
    std::vector<Row> rows;

    // 헤더 스킵
    if (!std::getline(fin, line)) { std::cerr << "빈 파일\n"; return 1; }

    while (std::getline(fin, line)) {
        if (line.empty()) continue;
        // 견고한 CSV: 큰따옴표 간단 처리(정식 파서는 별도 구현/라이브러리 권장)
        auto cols = [&]{
            std::vector<std::string> v; std::string cur; bool q=false;
            for (size_t i=0;i<line.size();++i){
                char c=line[i];
                if (c=='"'){ if(q && i+1<line.size()&&line[i+1]=='"'){cur.push_back('"');++i;} else q=!q; }
                else if(c==',' && !q){ v.push_back(cur); cur.clear(); }
                else cur.push_back(c);
            }
            v.push_back(cur); return v;
        }();

        if (cols.size() < 2) continue;
        Row r;
        r.name = cols[0];
        try {
            r.score = std::stod(cols[1]);
        } catch (...) {
            std::cerr << "숫자 변환 실패: " << cols[1] << "\n";
            continue;
        }
        rows.push_back(std::move(r));
    }

    if (rows.empty()) { std::cerr << "데이터 없음\n"; return 1; }

    double sum = 0.0, mn = std::numeric_limits<double>::infinity();
    double mx = -std::numeric_limits<double>::infinity();
    for (auto const& r : rows) { sum += r.score; mn = std::min(mn, r.score); mx = std::max(mx, r.score); }
    double avg = sum / rows.size();

    // 리포트 출력(정렬/폭/정밀)
    std::cout << std::left << std::setw(20) << "Name"
              << std::right << std::setw(10) << "Score" << "\n";
    std::cout << std::setfill('-') << std::setw(30) << "" << "\n";
    std::cout << std::setfill(' ');

    std::cout << std::fixed << std::setprecision(2);
    for (auto const& r : rows) {
        std::cout << std::left << std::setw(20) << r.name
                  << std::right << std::setw(10) << r.score << "\n";
    }

    std::cout << std::setfill('-') << std::setw(30) << "" << "\n";
    std::cout << std::setfill(' ');
    std::cout << std::left << std::setw(20) << "AVG" << std::right << std::setw(10) << avg << "\n";
    std::cout << std::left << std::setw(20) << "MIN" << std::right << std::setw(10) << mn  << "\n";
    std::cout << std::left << std::setw(20) << "MAX" << std::right << std::setw(10) << mx  << "\n";
}
```
```

---

## 9) 마무리 체크리스트

- [ ] 대용량이라면 `sync_with_stdio(false); cin.tie(nullptr);` 적용했는가?  
- [ ] `endl` 남용 대신 `'\n'`을 사용했는가?  
- [ ] `>>` 뒤 `getline`을 쓰기 전, 남은 개행을 처리했는가?  
- [ ] 파일은 적절한 **열기 모드**(특히 `binary`)로 열었는가?  
- [ ] 서식 상태를 바꿨다면 필요 시 **원복**했는가?  
- [ ] 예외/상태비트로 **실패를 감지**하고 처리했는가?  
- [ ] 문자열 파싱은 **견고한 방식**(따옴표/빈 필드)으로 구현했는가?