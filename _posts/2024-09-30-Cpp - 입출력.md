---
layout: post
title: C++ - 입출력
date: 2024-09-30 19:20:23 +0900
category: Cpp
---
# C++ 입출력 완벽 가이드: 콘솔, 파일, 문자열 처리의 모든 것

## 서론: 왜 C++ 입출력을 깊이 이해해야 하는가?

C++의 입출력 시스템은 단순히 데이터를 읽고 쓰는 것을 넘어서, 타입 안전성, 확장성, 성능 최적화의 중요한 기반을 제공합니다. C 스타일의 `printf`/`scanf`와 달리, C++ 스트림은 타입 안전성을 보장하며, 사용자 정의 타입에 대한 입출력 연산을 쉽게 확장할 수 있습니다. 그러나 그만큼 복잡한 특성과 미묘한 함정들이 존재합니다.

이 가이드는 단순한 사용법을 넘어, 실전에서 마주치는 문제들을 해결하고 성능을 최적화하는 방법을 다룹니다.

---

## 제1장: 콘솔 입출력 - `cin`과 `cout`의 세계

### 기본 사용법부터 시작하기

```cpp
#include <iostream>

int main() {
    int age;
    std::string name;
    
    std::cout << "이름을 입력하세요: ";
    std::cin >> name;
    
    std::cout << "나이를 입력하세요: ";
    std::cin >> age;
    
    std::cout << "안녕하세요, " << name << "님! " 
              << age << "살이시군요.\n";
}
```

### 성능 최적화: 대용량 데이터 처리를 위한

경쟁 프로그래밍이나 대용량 데이터 처리에서 입출력 성능은 결정적입니다:

```cpp
#include <iostream>

int main() {
    // 두 가지 마법 주문
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    int n;
    std::cin >> n;
    
    long long sum = 0;
    for (int i = 0; i < n; ++i) {
        int value;
        std::cin >> value;
        sum += value;
    }
    
    std::cout << sum << '\n';  // endl 대신 '\n' 사용
}
```

**왜 이렇게 설정해야 할까요?**
- `sync_with_stdio(false)`: C의 `stdio`와 동기화를 끕니다. C++ 스트림은 자체 버퍼를 사용하게 되어 속도가 빨라집니다.
- `cin.tie(nullptr)`: `cin`이 `cout`을 자동으로 flush하지 않게 합니다.
- `endl` 대신 `'\n'`: `endl`은 개행 후 flush를 수행하므로 느립니다.

### 견고한 입력 처리: 사용자 실수 대비하기

실제 프로그램에서는 사용자가 항상 올바른 입력을 제공하지 않습니다:

```cpp
#include <iostream>
#include <limits>

int get_age() {
    int age;
    
    while (true) {
        std::cout << "나이를 입력하세요 (0-150): ";
        
        if (std::cin >> age) {
            // 입력 성공
            if (age >= 0 && age <= 150) {
                return age;
            } else {
                std::cout << "나이는 0에서 150 사이여야 합니다.\n";
            }
        } else {
            // 입력 실패 - 잘못된 형식
            std::cout << "숫자를 입력해주세요.\n";
            std::cin.clear();  // 에러 상태 초기화
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            // 버퍼 비우기
        }
    }
}
```

### `getline`과 `>>`의 조화로운 사용

두 방식의 특성을 이해하면 효율적으로 조합할 수 있습니다:

```cpp
#include <iostream>
#include <string>
#include <limits>

struct Person {
    std::string name;
    int age;
    std::string city;
};

Person read_person() {
    Person p;
    
    std::cout << "이름: ";
    std::getline(std::cin, p.name);
    
    std::cout << "나이: ";
    while (!(std::cin >> p.age)) {
        std::cout << "나이는 숫자로 입력해주세요: ";
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    }
    std::cin.ignore();  // 개행 문자 처리
    
    std::cout << "도시: ";
    std::getline(std::cin, p.city);
    
    return p;
}
```

---

## 제2장: 파일 입출력 - 데이터의 영속성

### 기본 파일 작업

```cpp
#include <fstream>
#include <iostream>
#include <string>

void basic_file_operations() {
    // 파일 쓰기
    std::ofstream out_file("example.txt");
    if (!out_file) {
        std::cerr << "파일을 열 수 없습니다.\n";
        return;
    }
    
    out_file << "첫 번째 줄\n";
    out_file << "두 번째 줄\n";
    out_file << 42 << " " << 3.14 << "\n";
    // 파일은 자동으로 닫힙니다 (RAII)
    
    // 파일 읽기
    std::ifstream in_file("example.txt");
    if (!in_file) {
        std::cerr << "파일을 읽을 수 없습니다.\n";
        return;
    }
    
    std::string line;
    while (std::getline(in_file, line)) {
        std::cout << "읽은 줄: " << line << '\n';
    }
}
```

### 다양한 파일 모드 이해하기

```cpp
#include <fstream>

void file_modes() {
    // 덧붙이기 모드 - 기존 내용 유지하며 추가
    std::ofstream log_file("app.log", std::ios::app);
    log_file << "새 로그 항목\n";
    
    // 이진 모드 - 텍스트 변환 없음
    std::ofstream binary_file("data.bin", std::ios::binary);
    int numbers[] = {1, 2, 3, 4, 5};
    binary_file.write(reinterpret_cast<const char*>(numbers), 
                      sizeof(numbers));
    
    // 읽기/쓰기 모두 가능
    std::fstream data_file("data.dat", 
                          std::ios::in | std::ios::out | std::ios::binary);
    if (data_file) {
        // 파일 작업...
    }
}
```

### 전체 파일을 한 번에 읽기

```cpp
#include <fstream>
#include <sstream>
#include <string>
#include <stdexcept>

std::string read_entire_file(const std::string& filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file) {
        throw std::runtime_error("파일을 열 수 없습니다: " + filename);
    }
    
    // 파일 크기 확인
    file.seekg(0, std::ios::end);
    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);
    
    // 메모리 할당 및 읽기
    std::string content(size, '\0');
    if (!file.read(&content[0], size)) {
        throw std::runtime_error("파일 읽기 실패: " + filename);
    }
    
    return content;
}

// 또는 더 간단한 방법 (C++17 이상)
std::string read_file_simple(const std::string& filename) {
    std::ifstream file(filename);
    std::stringstream buffer;
    buffer << file.rdbuf();
    return buffer.str();
}
```

---

## 제3장: 서식 지정 - 데이터를 아름답게 표현하기

### 숫자 서식 지정

```cpp
#include <iostream>
#include <iomanip>

void number_formatting() {
    double pi = 3.141592653589793;
    
    // 기본 출력
    std::cout << "기본: " << pi << "\n";
    
    // 고정 소수점
    std::cout << std::fixed;
    std::cout << "고정 (기본 정밀도): " << pi << "\n";
    std::cout << std::setprecision(2);
    std::cout << "고정 (소수점 2자리): " << pi << "\n";
    
    // 과학적 표기법
    std::cout << std::scientific;
    std::cout << "과학적 표기법: " << pi << "\n";
    
    // 기본 모드로 복귀
    std::cout << std::defaultfloat;
    
    // 너비와 채우기
    std::cout << std::setw(10) << std::setfill('*') << 42 << "\n";
    std::cout << std::setfill(' ');  // 원래대로
    
    // 진법
    int value = 255;
    std::cout << "10진수: " << value << "\n";
    std::cout << std::hex << "16진수: " << value << "\n";
    std::cout << std::oct << "8진수: " << value << "\n";
    std::cout << std::dec;  // 10진수로 복귀
    
    // 진법 표시
    std::cout << std::showbase << std::hex << value << "\n";
    std::cout << std::noshowbase << std::dec;
}
```

### 표 형태로 데이터 출력하기

```cpp
#include <iostream>
#include <iomanip>
#include <vector>
#include <string>

struct Product {
    std::string name;
    double price;
    int quantity;
};

void print_product_table(const std::vector<Product>& products) {
    // 헤더 출력
    std::cout << std::left 
              << std::setw(20) << "상품명"
              << std::right
              << std::setw(10) << "가격"
              << std::setw(10) << "수량"
              << std::setw(15) << "합계" << "\n";
    
    std::cout << std::setfill('-') << std::setw(55) << "" << "\n";
    std::cout << std::setfill(' ');
    
    // 데이터 출력
    double total_value = 0.0;
    std::cout << std::fixed << std::setprecision(2);
    
    for (const auto& product : products) {
        double item_total = product.price * product.quantity;
        total_value += item_total;
        
        std::cout << std::left << std::setw(20) << product.name
                  << std::right
                  << std::setw(10) << product.price
                  << std::setw(10) << product.quantity
                  << std::setw(15) << item_total << "\n";
    }
    
    // 푸터
    std::cout << std::setfill('-') << std::setw(55) << "" << "\n";
    std::cout << std::setfill(' ');
    std::cout << std::left << std::setw(40) << "총합계:"
              << std::right << std::setw(15) << total_value << "\n";
}
```

---

## 제4장: 문자열 스트림 - 메모리 내 데이터 처리

### 문자열 파싱과 조합

```cpp
#include <sstream>
#include <string>
#include <vector>
#include <iostream>

void string_stream_examples() {
    // 문자열을 다른 타입으로 파싱
    std::string data = "John 25 175.5";
    std::istringstream iss(data);
    
    std::string name;
    int age;
    double height;
    
    if (iss >> name >> age >> height) {
        std::cout << "이름: " << name << "\n";
        std::cout << "나이: " << age << "\n";
        std::cout << "키: " << height << "\n";
    }
    
    // 여러 값을 문자열로 조합
    std::ostringstream oss;
    oss << "결과: " << 42 << " " << 3.14 << " " << std::boolalpha << true;
    std::string result = oss.str();
    std::cout << result << "\n";
    
    // CSV 파싱 (간단한 버전)
    std::string csv_line = "apple,1.99,100";
    std::stringstream ss(csv_line);
    std::vector<std::string> tokens;
    std::string token;
    
    while (std::getline(ss, token, ',')) {
        tokens.push_back(token);
    }
    
    std::cout << "CSV 토큰들:\n";
    for (const auto& t : tokens) {
        std::cout << "- " << t << "\n";
    }
}
```

### 유연한 타입 변환 도구

```cpp
#include <sstream>
#include <string>
#include <type_traits>

template<typename T>
std::string to_string(const T& value) {
    std::ostringstream oss;
    oss << value;
    return oss.str();
}

template<typename T>
T from_string(const std::string& str) {
    T value;
    std::istringstream iss(str);
    iss >> value;
    if (!iss) {
        throw std::runtime_error("변환 실패: " + str);
    }
    return value;
}

// 사용 예시
void type_conversion() {
    std::string str_num = "123";
    int num = from_string<int>(str_num);
    
    double dbl = 3.14159;
    std::string str_dbl = to_string(dbl);
    
    std::cout << "문자열에서 정수로: " << num << "\n";
    std::cout << "실수에서 문자열로: " << str_dbl << "\n";
}
```

---

## 제5장: 에러 처리와 로깅

### 체계적인 에러 처리

```cpp
#include <iostream>
#include <fstream>
#include <system_error>
#include <cerrno>

class FileHandler {
    std::fstream file_;
    
public:
    FileHandler(const std::string& filename, std::ios::openmode mode) {
        file_.open(filename, mode);
        if (!file_) {
            // 시스템 에러 코드와 함께 상세한 에러 메시지
            throw std::system_error(errno, std::system_category(),
                                   "파일 열기 실패: " + filename);
        }
    }
    
    void write_data(const std::string& data) {
        file_ << data;
        if (file_.fail()) {
            throw std::runtime_error("파일 쓰기 실패");
        }
    }
    
    ~FileHandler() {
        if (file_.is_open()) {
            file_.close();
        }
    }
};
```

### 로그 레벨별 출력

```cpp
#include <iostream>
#include <string>
#include <chrono>
#include <iomanip>

enum class LogLevel {
    DEBUG,
    INFO,
    WARNING,
    ERROR,
    CRITICAL
};

class Logger {
    static std::ostream& get_stream(LogLevel level) {
        switch (level) {
            case LogLevel::ERROR:
            case LogLevel::CRITICAL:
                return std::cerr;  // 에러는 stderr로
            default:
                return std::cout;  // 일반 로그는 stdout으로
        }
    }
    
public:
    static void log(LogLevel level, const std::string& message) {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        
        auto& stream = get_stream(level);
        
        stream << std::put_time(std::localtime(&time), "%F %T") << " [";
        
        switch (level) {
            case LogLevel::DEBUG:    stream << "DEBUG"; break;
            case LogLevel::INFO:     stream << "INFO"; break;
            case LogLevel::WARNING:  stream << "WARN"; break;
            case LogLevel::ERROR:    stream << "ERROR"; break;
            case LogLevel::CRITICAL: stream << "CRITICAL"; break;
        }
        
        stream << "] " << message << std::endl;
    }
};

// 사용 예시
void process_data() {
    Logger::log(LogLevel::INFO, "데이터 처리 시작");
    
    try {
        // 작업 수행...
        Logger::log(LogLevel::DEBUG, "중간 단계 완료");
    } catch (const std::exception& e) {
        Logger::log(LogLevel::ERROR, 
                   std::string("처리 실패: ") + e.what());
        throw;
    }
    
    Logger::log(LogLevel::INFO, "데이터 처리 완료");
}
```

---

## 제6장: 실전 프로젝트 - 주소록 관리 시스템

입출력의 모든 개념을 통합한 실제 프로젝트 예제입니다:

```cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <iomanip>
#include <algorithm>
#include <limits>

struct Contact {
    std::string name;
    std::string phone;
    std::string email;
    std::string address;
    
    void display() const {
        std::cout << std::left
                  << std::setw(20) << "이름: " << name << "\n"
                  << std::setw(20) << "전화번호: " << phone << "\n"
                  << std::setw(20) << "이메일: " << email << "\n"
                  << std::setw(20) << "주소: " << address << "\n"
                  << std::setfill('-') << std::setw(50) << "" << "\n"
                  << std::setfill(' ');
    }
};

class AddressBook {
    std::vector<Contact> contacts_;
    const std::string filename_ = "address_book.csv";
    
    Contact read_contact_from_user() {
        Contact c;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        
        std::cout << "이름: ";
        std::getline(std::cin, c.name);
        
        std::cout << "전화번호: ";
        std::getline(std::cin, c.phone);
        
        std::cout << "이메일: ";
        std::getline(std::cin, c.email);
        
        std::cout << "주소: ";
        std::getline(std::cin, c.address);
        
        return c;
    }
    
public:
    void add_contact() {
        std::cout << "\n--- 새 연락처 추가 ---\n";
        contacts_.push_back(read_contact_from_user());
        std::cout << "연락처가 추가되었습니다.\n";
    }
    
    void list_contacts() const {
        if (contacts_.empty()) {
            std::cout << "연락처가 없습니다.\n";
            return;
        }
        
        std::cout << "\n--- 연락처 목록 (" << contacts_.size() << "개) ---\n";
        for (size_t i = 0; i < contacts_.size(); ++i) {
            std::cout << "[" << i + 1 << "] ";
            contacts_[i].display();
        }
    }
    
    void save_to_file() const {
        std::ofstream file(filename_);
        if (!file) {
            std::cerr << "파일 저장 실패\n";
            return;
        }
        
        // CSV 헤더
        file << "name,phone,email,address\n";
        
        // 데이터
        for (const auto& contact : contacts_) {
            file << contact.name << ","
                 << contact.phone << ","
                 << contact.email << ","
                 << contact.address << "\n";
        }
        
        std::cout << contacts_.size() << "개의 연락처를 저장했습니다.\n";
    }
    
    void load_from_file() {
        std::ifstream file(filename_);
        if (!file) {
            std::cout << "저장된 파일이 없습니다.\n";
            return;
        }
        
        contacts_.clear();
        std::string line;
        
        // 헤더 스킵
        std::getline(file, line);
        
        while (std::getline(file, line)) {
            if (line.empty()) continue;
            
            std::stringstream ss(line);
            Contact c;
            
            std::getline(ss, c.name, ',');
            std::getline(ss, c.phone, ',');
            std::getline(ss, c.email, ',');
            std::getline(ss, c.address, ',');
            
            contacts_.push_back(c);
        }
        
        std::cout << contacts_.size() << "개의 연락처를 불러왔습니다.\n";
    }
    
    void search_contact() const {
        std::string keyword;
        std::cin.ignore();
        std::cout << "검색할 이름 또는 전화번호: ";
        std::getline(std::cin, keyword);
        
        std::transform(keyword.begin(), keyword.end(), keyword.begin(),
                      ::tolower);
        
        bool found = false;
        for (const auto& contact : contacts_) {
            std::string name_lower = contact.name;
            std::transform(name_lower.begin(), name_lower.end(),
                          name_lower.begin(), ::tolower);
            
            std::string phone_lower = contact.phone;
            std::transform(phone_lower.begin(), phone_lower.end(),
                          phone_lower.begin(), ::tolower);
            
            if (name_lower.find(keyword) != std::string::npos ||
                phone_lower.find(keyword) != std::string::npos) {
                contact.display();
                found = true;
            }
        }
        
        if (!found) {
            std::cout << "검색 결과가 없습니다.\n";
        }
    }
};

void display_menu() {
    std::cout << "\n=== 주소록 관리 시스템 ===\n"
              << "1. 연락처 추가\n"
              << "2. 연락처 목록\n"
              << "3. 연락처 검색\n"
              << "4. 파일 저장\n"
              << "5. 파일 불러오기\n"
              << "6. 종료\n"
              << "선택: ";
}

int main() {
    AddressBook book;
    
    // 시작 시 자동으로 파일 불러오기
    book.load_from_file();
    
    while (true) {
        display_menu();
        
        int choice;
        if (!(std::cin >> choice)) {
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            std::cout << "잘못된 입력입니다.\n";
            continue;
        }
        
        switch (choice) {
            case 1: book.add_contact(); break;
            case 2: book.list_contacts(); break;
            case 3: book.search_contact(); break;
            case 4: book.save_to_file(); break;
            case 5: book.load_from_file(); break;
            case 6: 
                std::cout << "프로그램을 종료합니다.\n";
                return 0;
            default:
                std::cout << "잘못된 선택입니다.\n";
        }
    }
}
```

---

## 결론: 현명한 입출력 프로그래밍을 위한 원칙

### 1. **적절한 도구 선택의 지혜**
   - 작은 데이터, 대화형 프로그램: `cin`/`cout`
   - 대용량 데이터, 성능 중요: 빠른 입출력 설정 + `'\n'`
   - 파일 작업: `fstream` + 적절한 열기 모드
   - 문자열 처리: `sstringstream`

### 2. **견고성의 중요성**
   - 모든 입력은 검증하세요
   - 파일 작업은 항상 성공 여부를 확인하세요
   - 메모리 부족 상황을 고려하세요
   - 예외 처리를 통해 정상적인 실패 처리를 구현하세요

### 3. **성능 최적화의 균형**
   - `sync_with_stdio(false)`와 `cin.tie(nullptr)`을 적절히 사용하세요
   - `endl` 대신 `'\n'`을 사용하세요
   - 불필요한 형식 변환을 피하세요
   - 적절한 버퍼링 전략을 선택하세요

### 4. **가독성과 유지보수성**
   - 서식 지정으로 출력을 정리하세요
   - 일관된 에러 메시지 형식을 사용하세요
   - 로깅 레벨을 구분하세요
   - 사용자에게 명확한 피드백을 제공하세요

### 5. **보안 고려사항**
   - 사용자 입력을 신뢰하지 마세요
   - 버퍼 오버플로우를 방지하세요
   - 파일 경로 주입을 조심하세요
   - 민감한 데이터는 적절히 보호하세요

### 6. **플랫폼 호환성**
   - 줄바꿈 문자(`\n` vs `\r\n`)에 주의하세요
   - 파일 인코딩(UTF-8 등)을 고려하세요
   - 경로 구분자(`/` vs `\`)를 처리하세요
   - 로케일 설정을 확인하세요

C++ 입출력 시스템은 처음에는 복잡해 보일 수 있지만, 그 원리와 패턴을 이해하면 강력한 도구가 됩니다. 이 가이드가 여러분의 C++ 입출력 프로그래밍 여정에 도움이 되길 바랍니다. 기억하세요: 좋은 입출력 코드는 사용자 경험을 결정하고, 프로그램의 안정성을 보장하며, 성능을 최적화합니다.