---
layout: post
title: MFC - 스토리지 코너 케이스
date: 2025-09-22 19:25:23 +0900
category: MFC
---
# 스토리지 코너 케이스 완전 가이드

**Long Path(\\?\), Reparse Point/Junction, UNC/SMB 지연, 파일 ID·USN 저수준 팁 (Win32/C++ 중심)**

> “로컬에서 잘 되는데, 고객 PC의 네트워크 드라이브나 Junction이 섞인 경로에서만 터진다”…
> 이 문서는 그런 **구석 케이스를 선제적으로 막는** 실전 레시피를 모았습니다.
> 코드 스니펫은 모두 **Wide(UTF-16)**, **Win32 API** 기준입니다.

---

## 한눈에 개요

- **Long Path (\\?\)**
  - `MAX_PATH(260)` 제한 회피, **확장 경로(extended-length path)** 규칙, UNC(`\\?\UNC\server\share`)
  - **Manifest longPathAware**와의 관계, 문자열 정규화/후행 점/공백
- **Reparse Point / Junction / Symlink**
  - `FILE_ATTRIBUTE_REPARSE_POINT`, `FILE_FLAG_OPEN_REPARSE_POINT`, `FSCTL_GET_REPARSE_POINT`
  - **루프 방지**, 트리 순회 시 **해결할지/건너뛸지** 정책
- **UNC/SMB 지연**
  - SMB **Oplock/Lease** 및 **브레이크 지연**, **WAN/지터** 대응, **타임아웃/재시도/취소**
  - **I/O 우선순위 힌트**, **비동기 OVERLAPPED**, **메타데이터 최소화**
- **파일 ID / USN 저수준**
  - `GetFileInformationByHandleEx(FileIdInfo)`, `FILE_ID_INFO` vs `BY_HANDLE_FILE_INFORMATION`
  - **USN 저널**(NTFS): `FSCTL_READ_USN_JOURNAL`, `USN_RECORD_V3` → **폴더 감시 대체/보완**
  - **볼륨/서버 간 이동**시 ID/USN 변동성·제약

---

## — 260을 넘겼을 때의 생존법

### 왜 여전히 터질까?

- 많은 Win32 API가 여전히 **기본 경로 규칙**(MAX_PATH, `.`/`..`/NUL/탭 등)을 적용합니다.
- **확장 경로 prefix** `\\?\` 를 쓰면 대부분의 **경로 파서 우회**가 가능:
  - **로컬 드라이브**: `\\?\C:\very\long\path\...`
  - **UNC**: `\\?\UNC\server\share\very\long\path\...` (`\\server\share` 부분을 `UNC\server\share`로 대체)
- 단, **일부 UI/쉘 API**는 여전히 MAX_PATH 가정. → **하위 레이어(핸들 기반)**로 우회.

### 안전한 확장 경로 빌더

```cpp
#include <string>
#include <pathcch.h>
#pragma comment(lib, "Pathcch.lib")

// path: 일반 Win32 경로(\\server\share 또는 C:\...)
// UNC이면 \\?\UNC\server\share\..., 로컬이면 \\?\C:\... 으로 확장
std::wstring MakeExtendedPath(const std::wstring& path) {
    if (path.rfind(L"\\\\?\\", 0) == 0) return path; // 이미 확장
    if (path.rfind(L"\\\\", 0) == 0) {
        // UNC
        return L"\\\\?\\UNC" + path.substr(1); // "\\?\UNC\server\share\..."
    }
    if (path.size() >= 2 && path[1] == L':') {
        return L"\\\\?\\" + path;               // "\\?\C:\..."
    }
    // 상대 경로는 먼저 절대화
    wchar_t buf[MAX_PATH];
    GetFullPathNameW(path.c_str(), MAX_PATH, buf, nullptr);
    return MakeExtendedPath(buf);
}
```

> **팁**
> - **상대 경로**는 먼저 **절대화 → 확장**.
> - **후행 점/공백**(e.g. `foo. `, `bar.`)은 표준 파서에서 **잘리는** 경우가 있음. `\\?\`면 그대로 존재 → 정규화/검증 필수.
> - **Manifest**에 `<longPathAware>true</longPathAware>`를 넣으면 일부 API가 **확장 없이도** 260을 넘긴 경로 허용. 하지만 **UNC/레거시 API** 대비를 위해 **직접 `\\?\`` 사용 습관**이 안전.

### CreateFileW 샘플 (롱패스 + 권한 + 성능 플래그)

```cpp
HANDLE OpenForReadLong(const std::wstring& anyPath) {
    std::wstring p = MakeExtendedPath(anyPath);
    HANDLE h = CreateFileW(
        p.c_str(),
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        nullptr,
        OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS |        // 디렉터리 핸들 허용
        FILE_FLAG_SEQUENTIAL_SCAN |         // 순차 힌트
        FILE_ATTRIBUTE_NORMAL,
        nullptr);
    return (h == INVALID_HANDLE_VALUE) ? nullptr : h;
}
```

### 디렉터리 열기(메타만)

```cpp
HANDLE OpenDirHandle(const std::wstring& dir) {
    std::wstring p = MakeExtendedPath(dir);
    return CreateFileW(p.c_str(),
        FILE_LIST_DIRECTORY,
        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
        nullptr,
        OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, // 리파스 자체 열기 가능
        nullptr);
}
```

---

## Reparse Point / Junction / Symlink — “길을 바꾸는 문” 다루기

### 탐지와 기본 정책

- `GetFileAttributesW`→ `FILE_ATTRIBUTE_REPARSE_POINT` 비트로 **존재** 확인
- 트리 순회 시 **정책을 먼저 정하라**:
  1) **항상 해석**(실경로로 들어감)
  2) **항상 건너뜀**(무한 루프/보안 이슈 회피)
  3) **타입별**(Junction은 해석, Symlink는 건너뜀 등)
- 루프 방지: **(VolumeSerialNumber + FileIndex)** 또는 **파일 ID 128**을 **방문 집합**으로 기록

### 리파스 데이터 읽기 (`FSCTL_GET_REPARSE_POINT`)

```cpp
#include <winioctl.h>

struct REPARSE_BUFFER {
    DWORD  ReparseTag;
    WORD   ReparseDataLength;
    WORD   Reserved;
    union {
        // SYMLINK, MOUNT_POINT 등 구조체 생략(공식 헤더 참고)
        REPARSE_DATA_BUFFER Data;
    };
};

bool ReadReparsePoint(HANDLE h, std::vector<BYTE>& out) {
    out.resize(MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    DWORD ret = 0;
    BOOL ok = DeviceIoControl(h, FSCTL_GET_REPARSE_POINT,
        nullptr, 0, out.data(), (DWORD)out.size(), &ret, nullptr);
    if (!ok) return false;
    out.resize(ret);
    return true;
}

// 사용 예: 리파스 자체 열기
void InspectReparse(const std::wstring& path) {
    HANDLE h = CreateFileW(MakeExtendedPath(path).c_str(),
        0,
        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
        nullptr, OPEN_EXISTING,
        FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS, nullptr);
    if (h == INVALID_HANDLE_VALUE) return;

    std::vector<BYTE> buf;
    if (ReadReparsePoint(h, buf)) {
        auto rb = (REPARSE_DATA_BUFFER*)buf.data();
        switch (rb->ReparseTag) {
        case IO_REPARSE_TAG_SYMLINK:     /* ... */ break;
        case IO_REPARSE_TAG_MOUNT_POINT: /* ... */ break; // Junction
        case IO_REPARSE_TAG_APPEXECLINK: /* 앱 실행 링크 */ break;
        default: /* 사용자 정의, 클라우드 프로바이더 등 */ break;
        }
    }
    CloseHandle(h);
}
```

### 예제

```cpp
#include <unordered_set>

// (VolumeSerial, FileIndexHigh, FileIndexLow) -> 64/128비트 키
struct FileKey { ULONGLONG vol; ULONGLONG idx; };
struct KeyHash { size_t operator()(const FileKey& k) const noexcept {
    return std::hash<ULONGLONG>()(k.vol ^ (k.idx*11400714819323198485ull));
}};
struct KeyEq { bool operator()(const FileKey& a, const FileKey& b) const noexcept {
    return a.vol==b.vol && a.idx==b.idx;
}};
using KeySet = std::unordered_set<FileKey,KeyHash,KeyEq>;

bool GetFileKey(HANDLE h, FileKey& out) {
    BY_HANDLE_FILE_INFORMATION inf{};
    if (!GetFileInformationByHandle(h, &inf)) return false;
    out.vol = inf.dwVolumeSerialNumber;
    out.idx = (ULONGLONG)inf.nFileIndexLow | ((ULONGLONG)inf.nFileIndexHigh << 32);
    return true;
}

void Walk(const std::wstring& root, KeySet& visited, bool followReparse) {
    WIN32_FIND_DATAW fd{};
    std::wstring pat = MakeExtendedPath(root) + L"\\*";
    HANDLE ff = FindFirstFileW(pat.c_str(), &fd);
    if (ff == INVALID_HANDLE_VALUE) return;
    do {
        if (wcscmp(fd.cFileName, L".")==0 || wcscmp(fd.cFileName, L"..")==0) continue;
        std::wstring child = root + L"\\" + fd.cFileName;

        DWORD attr = fd.dwFileAttributes;
        bool isDir = (attr & FILE_ATTRIBUTE_DIRECTORY) != 0;
        bool isReparse = (attr & FILE_ATTRIBUTE_REPARSE_POINT) != 0;

        if (isDir) {
            if (isReparse && !followReparse) {
                // 정책: 리파스 디렉터리는 건너뜀
                continue;
            }
            // 핸들 열고 루프 체크
            HANDLE h = CreateFileW(MakeExtendedPath(child).c_str(), 0,
                FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, nullptr,
                OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS |
                               (isReparse?FILE_FLAG_OPEN_REPARSE_POINT:0), nullptr);
            if (h == INVALID_HANDLE_VALUE) continue;
            FileKey k{};
            if (GetFileKey(h, k)) {
                if (visited.find(k) != visited.end()) { CloseHandle(h); continue; }
                visited.insert(k);
            }
            CloseHandle(h);
            // 재귀
            Walk(child, visited, followReparse);
        } else {
            // 파일 처리 …
        }
    } while (FindNextFileW(ff, &fd));
    FindClose(ff);
}
```

> **포인트**
> - `FILE_FLAG_OPEN_REPARSE_POINT` 없이 열면 **리파스를 따라가며** 대상 핸들을 엽니다. “리파스 자체”를 열어 메타를 읽고 싶으면 **반드시 설정**.
> - Junction/심볼릭 링크 **루프**는 실수 한 번으로 무한 루프. **FileIndex + Volume**으로 방문 추적.

### 대표 Reparse Tag 요약

| Tag | 의미 | 비고 |
|---|---|---|
| `IO_REPARSE_TAG_MOUNT_POINT` | **Junction** | 디렉터리용, 타 드라이브/경로 마운트 |
| `IO_REPARSE_TAG_SYMLINK` | **심볼릭 링크** | 파일/디렉터리, 상대/절대 |
| `IO_REPARSE_TAG_APPEXECLINK` | UWP/AppX 실행 링크 | 시작 메뉴 등 |
| `IO_REPARSE_TAG_CLOUD` 계열 | 클라우드 **플레이스홀더** | 오프라인 상태·지연 로드 |
| 사용자 정의 | 백업/AV/가상화 | **해석하지 말고** 속성만 참고 권장 |

---

## UNC/SMB 지연 — 네트워크 파일의 현실적인 설계

### 느린 이유는 다양하다

- **WAN/지터/패킷 손실** → RTT 커짐
- **SMB Oplock/Lease** 브레이크 → 공유자 변경 시 **브레이크 알림 왕복** 지연
- 서버 **리소스 경쟁**(백업/AV 스캔/스냅샷)
- **DFS, Reparse 기반 네임스페이스** → 추가 hop

### 열기·읽기 플래그

```cpp
HANDLE OpenForNetworkRead(const std::wstring& p) {
    return CreateFileW(MakeExtendedPath(p).c_str(),
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, // 공유 충분히
        nullptr, OPEN_EXISTING,
        FILE_FLAG_SEQUENTIAL_SCAN | FILE_ATTRIBUTE_NORMAL |
        FILE_FLAG_OVERLAPPED, // 비동기
        nullptr);
}
```

- **공유 플래그**를 **보수적으로** 열면 다른 프로세스가 파일 메타를 만질 때 **오플락 브레이크** 빈도 ↓
- 읽기 전용이면 `GENERIC_READ`만. **쓰기 핸들**은 가능하면 짧게 유지.

### 비동기 + 타임아웃 + 취소

```cpp
struct AsyncFile {
    HANDLE h{};
    HANDLE iocp{};
    AsyncFile(HANDLE hFile) : h(hFile) {
        iocp = CreateIoCompletionPort(h, NULL, 0, 1);
    }
    bool Read(void* buf, DWORD len, LONGLONG off, DWORD timeoutMs) {
        OVERLAPPED ov{}; ov.Offset = (DWORD)off; ov.OffsetHigh=(DWORD)(off>>32);
        if (!ReadFile(h, buf, len, nullptr, &ov)) {
            if (GetLastError()!=ERROR_IO_PENDING) return false;
        }
        DWORD n=0; ULONG_PTR key; LPOVERLAPPED pov;
        if (!GetQueuedCompletionStatus(iocp, &n, &key, &pov, timeoutMs)) {
            if (GetLastError()==WAIT_TIMEOUT) {
                CancelIoEx(h, &ov); // **중요**: 네트워크 대기 취소
                return false;
            }
        }
        return true;
    }
};
```

- 네트워크 I/O는 **무기한 대기**하면 UX 파괴 → **시간 제한 + 취소** 필수
- 앱 종료·탭 닫기·사용자 취소에 맞춰 **CancelIoEx** 호출

### I/O 우선순위 힌트 (SMB 서버 호응)

```cpp
BOOL SetLowIoPriority(HANDLE h) {
    FILE_IO_PRIORITY_HINT_INFO info{};
    info.PriorityHint = IoPriorityHintVeryLow;
    return SetFileInformationByHandle(h, FileIoPriorityHintInfo, &info, sizeof(info));
}
```

- 백그라운드 동기화·프리페치 등엔 **낮은 우선순위**로 네트워크에 예의

### 메타데이터 최소화

- **네트워크 왕복**을 아끼려면:
  - **열면 한 번에** `GetFileInformationByHandleEx`로 필요한 메타를 한 패스로 수집
  - 디렉터리 열거는 **`FindFirstFileExW(..., FindExInfoBasic)`** 사용(여분 정보 생략)
  - **캐시**: `FileId -> 최근 크기/시간` 맵, **짧은 TTL**

### 재시도/백오프

- SMB는 간헐적으로 `ERROR_NETWORK_BUSY/ERROR_BAD_NET_RESP` 등을 낸다.
- **지수 백오프(100→200→400ms, jitter)** + **최대 3~5회**
- **Idempotent** 작업만 자동 재시도. **쓰기/삭제**는 주의.

---

## 파일 ID — “경로 대신 핸들/ID로”

### 가져오기

```cpp
#include <winbase.h>

bool GetFileId(HANDLE h, FILE_ID_INFO& id) {
    return GetFileInformationByHandleEx(h, FileIdInfo, &id, sizeof(id));
}

bool GetVolumeId(HANDLE h, DWORD& volSer) {
    BY_HANDLE_FILE_INFORMATION inf{};
    if (!GetFileInformationByHandle(h, &inf)) return false;
    volSer = inf.dwVolumeSerialNumber;
    return true;
}
```

- `FILE_ID_INFO.FileId`는 **128bit**(NTFS/ReFS). **볼륨 내**에서 **지속적**(재부팅 후에도)
- 단, **일부 파일시스템/SMB**는 **지원 안 함**(함수 실패 가능) → **경로 fallback** 필요

### 경고: 안정성의 경계

- **동일 볼륨 내 rename/move**는 보통 **ID 유지**
- **다른 볼륨으로 move/copy**면 **ID 변경**
- SMB 서버에 따라 **ID 안정성/의미**가 다를 수 있음(특히 오래된 NAS)

### 핸들 재열기(“경로가 바뀌어도”)

- NT 경로의 `\\?\GLOBALROOT\Device\HarddiskVolumeX\...` + **ID 기반** 열기(고급: `NtCreateFile` + `FILE_OPEN_BY_FILE_ID`)는 공개 Win32로는 제한적.
- 실용적으로는 **처음 연 핸들을 오래 유지**하거나, **USN + 빠른 재검색** 전략이 더 맞음.

---

## USN 저널 — 대형 트리의 “변경 감시” 핵심

> NTFS 전용. 관리자 권한/특정 권한 필요.

### 핵심 이점

- **폴더 감시(ReadDirectoryChangesW)**는 **한 지점**만, 대량 변경 시 **분실 가능**
- USN 저널은 **볼륨 전체 변경 기록**(파일 생성/삭제/이름 변경/쓰기 등)
- **스캔→스냅샷** 후, 다음엔 **저널 차분**만 읽으면 **빠름**

### 열기

```cpp
HANDLE OpenVolume(const wchar_t* volRoot) {
    // volRoot 예: L"\\\\?\\C:"
    std::wstring path = std::wstring(L"\\\\?\\") + volRoot[4] + L":";
    return CreateFileW(path.c_str(), GENERIC_READ|GENERIC_WRITE,
        FILE_SHARE_READ|FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
}
```

### 현재 저널 정보

```cpp
USN_JOURNAL_DATA_V1 data{};
DWORD br=0;
DeviceIoControl(hVol, FSCTL_QUERY_USN_JOURNAL, nullptr,0, &data, sizeof(data), &br, nullptr);
// data.NextUsn, data.FirstUsn, data.UsnJournalID 확보
```

### 변화 읽기 (연속)

```cpp
READ_USN_JOURNAL_DATA_V1 read{};
read.StartUsn = lastUsn; // 이전에 본 위치
read.ReasonMask = 0xFFFFFFFF;
read.UsnJournalID = data.UsnJournalID;
read.ReturnOnlyOnClose = FALSE;

std::vector<BYTE> buf(1024*1024);
DWORD out=0;
if (DeviceIoControl(hVol, FSCTL_READ_USN_JOURNAL, &read, sizeof(read),
                    buf.data(), (DWORD)buf.size(), &out, nullptr)) {
    BYTE* p = buf.data() + sizeof(USN);
    while (p < buf.data() + out) {
        auto r = (USN_RECORD_V3*)p; // 또는 V2/V4 볼륨에 따라
        // r->FileReferenceNumber, r->ParentFileReferenceNumber, r->Reason, 파일명 등
        p += r->RecordLength;
        lastUsn = *(USN*)buf.data(); // 마지막 USN 갱신
    }
}
```

### 이름/경로 복원

- `FileReferenceNumber`만으로는 **완전 경로**를 바로 얻을 수 없음 →
  - **캐시**: (FRN → {Name, ParentFRN}) 맵
  - 부모를 **역으로 타고 올라가** 최종 경로 재구성
- 최초 스냅샷: `FSCTL_ENUM_USN_DATA`로 전체 **FRN → 메타** 테이블 빌드

### 오류/예외

- `ERROR_JOURNAL_DELETE_IN_PROGRESS` / `ERROR_JOURNAL_NOT_ACTIVE` → 저널 재생성된 상황: **풀 스캔** 필요
- 네트워크/SMB 드라이브는 **USN 미지원**(로컬 NTFS 전용)

---

## 경로 정규화/유니코드·로캘·금지 문자

- **UTF-16** 사용(Win32 Wide API)
- 파일/디렉터리 이름에 **U+202A** 등 방향 제어 문자는 문자열 비교/정렬에 영향을 줄 수 있음 → UI 표시 시 **정규화**/가시화
- **예약 이름**: `CON`, `PRN`, `AUX`, `NUL`, `COM1`… (확장 경로라도 파일 시스템/레거시에 따라 문제)
- **금지 문자**: `<>:"/\|?*` (NTFS 기준), 하지만 **Alternate Data Stream**(`file:stream`) 등 특수 구문 주의
- **PathCchCanonicalizeEx** 로 `.`/`..` 정규화(확장 경로는 바꾸지 않음), **후행 공백/점**은 애초에 거부/정리

---

## 이동/교체의 원자성 & SMB 주의사항

- **MoveFileEx(MOVEFILE_REPLACE_EXISTING)**: **같은 볼륨** 내에서는 거의 **원자 교체**처럼 작동
- **ReplaceFileW**: 백업/저널과 결합된 **신뢰성 높은 교체**(ACL/속성 보존)
- **다른 볼륨/서버**로의 이동은 **Copy→Delete** 시맨틱에 가까움(원자성 X)
- **SMB 공유** 간 이동은 서버 구현/DFS에 영향 → **교체 보장** 안 됨 → **임시 파일 + rename** 패턴을 **서버 동일 경로**에서 수행하도록 설계

---

## 속성/시간/캐시 — 원격과 로컬의 차이

- `GetFileAttributesExW` vs `FindFirstFileExW(FindExInfoBasic)`
  - 원격에서 **왕복 감소** 위해 **Basic** 정보 요청
- 시간 스탬프(UTC vs 로컬), 네트워크에서 **정밀도/캐시** 차이
- **파일 사이즈**는 캐시될 수 있음 → **쓰기 직후 재조회**는 **Flush/Close 후** 확인

---

## 대규모 열거 성능 팁

- `FindFirstFileExW(dir, FindExInfoBasic, …, FindExSearchNameMatch, NULL, 0)`
- **배치 처리**: 일괄 수집 후 **정렬/필터**는 메모리에서
- **Reparse 스킵** 옵션으로 **클라우드 플레이스홀더** 대량 폴더에서 **불필요한 네트워크 트래픽** 감소

---

## 실전 레시피 모음

### “긴 경로 + Junction 포함 대량 스캔” 견고 템플릿

- 경로 입력 → **절대화 + 확장**
- **Reparse 정책** 선택(기본: 디렉터리 리파스 건너뜀)
- **방문 집합**(Volume+FileIndex) 구축으로 **루프 차단**
- `FindFirstFileExW(Basic)`로 **메타 왕복 최소화**
- 원격 드라이브 감지 시: **동기 I/O 금지**, **타임아웃/취소** 반드시

### “네트워크 파일 스트리밍”

- `FILE_FLAG_OVERLAPPED` + IOCP
- **작은 읽기 묶기**(64~256KB) + **리드 어헤드**
- **낮은 I/O 우선순위**(백그라운드)
- 오류 재시도(지수 백오프, 최대 5회)
- UI와 분리: **작업 스레드** + **취소 토큰**(CancelIoEx)

### “경로가 바뀌는 파일 추적”

- 파일 열 때 **FILE_ID_INFO** 가져와 **캐시 키**
- 경로 변경 감지: **USN 저널**로 rename 이벤트 수신 → **ID 매칭으로 빠른 갱신**
- 다른 볼륨으로 이동 시 **ID 변경** → **신규로 취급**

---

## 디버깅/진단 팁

- **실제 열리는 물리 경로**: `GetFinalPathNameByHandleW(h, …, FILE_NAME_NORMALIZED)`
- **재현이 어려운 UNC 지연**: **WPR/WPA**로 **File I/O(Wait vs Service)**, **SMB 클라이언트 이벤트** 분석
- **리파스 루프**: 방문 집합 로그 출력 + 경고
- **오류 코드**는 반드시 **`FormatMessageW`**로 기록(사용자 보고서 가독성)

---

## 전체 샘플: “튼튼한 파일 복사”(롱패스/리파스/UNC/취소)

```cpp
struct CopyOptions {
    bool followReparse = false;     // 디렉터리 리파스 따라갈지
    DWORD readSize = 256*1024;      // I/O 사이즈
    DWORD timeoutMs = 5000;         // 각 I/O 타임아웃
};

bool CopyFileRobust(const std::wstring& src, const std::wstring& dst, const CopyOptions& opt, std::atomic_bool& cancel) {
    // 1) 소스 열기
    HANDLE hs = CreateFileW(MakeExtendedPath(src).c_str(),
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        nullptr, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED,
        nullptr);
    if (hs==INVALID_HANDLE_VALUE) return false;
    SetLowIoPriority(hs);

    // 리파스 처리 정책(파일이면 굳이 OPEN_REPARSE_POINT 안씀)
    DWORD attr = GetFileAttributesW(MakeExtendedPath(src).c_str());
    if ((attr!=INVALID_FILE_ATTRIBUTES) &&
        (attr & FILE_ATTRIBUTE_REPARSE_POINT) && !opt.followReparse) {
        CloseHandle(hs);
        SetLastError(ERROR_NOT_SUPPORTED);
        return false;
    }

    // 2) 목적지 임시 파일
    std::wstring dstTmp = dst + L".tmp";
    HANDLE hd = CreateFileW(MakeExtendedPath(dstTmp).c_str(),
        GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_WRITE_THROUGH,
        nullptr);
    if (hd==INVALID_HANDLE_VALUE) { CloseHandle(hs); return false; }
    SetLowIoPriority(hd);

    // 3) 비동기 복사 루프
    AsyncFile r(hs), w(hd);
    std::vector<BYTE> buf(opt.readSize);
    LONGLONG off = 0;
    for (;;) {
        if (cancel.load()) { CancelIoEx(hs, nullptr); CancelIoEx(hd, nullptr); SetLastError(ERROR_CANCELLED); break; }
        if (!r.Read(buf.data(), (DWORD)buf.size(), off, opt.timeoutMs)) break;
        // 실제 읽힌 바이트 수는 GetQueuedCompletionStatus의 n으로 반환되었다고 가정
        DWORD n = 0; ULONG_PTR key; LPOVERLAPPED pov;
        GetQueuedCompletionStatus(r.iocp, &n, &key, &pov, 0);
        if (n==0) { /* EOF */ break; }

        OVERLAPPED ov{}; ov.Offset=(DWORD)off; ov.OffsetHigh=(DWORD)(off>>32);
        if (!WriteFile(hd, buf.data(), n, nullptr, &ov) && GetLastError()!=ERROR_IO_PENDING) { break; }
        DWORD wn=0; GetQueuedCompletionStatus(w.iocp, &wn, &key, &pov, opt.timeoutMs);
        if (wn != n) { SetLastError(ERROR_WRITE_FAULT); break; }
        off += n;
    }

    DWORD err = GetLastError();
    CloseHandle(hs);
    if (err==ERROR_SUCCESS || err==ERROR_HANDLE_EOF) {
        CloseHandle(hd);
        // 4) 원자 교체(같은 볼륨일 때)
        if (MoveFileExW(MakeExtendedPath(dstTmp).c_str(), MakeExtendedPath(dst).c_str(),
                        MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED)) {
            return true;
        } else {
            // 교체 실패 시 임시파일 남김
            return false;
        }
    } else {
        CancelIoEx(hd, nullptr); CloseHandle(hd);
        // 실패 시 임시 삭제 시도
        DeleteFileW(MakeExtendedPath(dstTmp).c_str());
        SetLastError(err);
        return false;
    }
}
```

---

## 체크리스트 (프로덕션 품질)

- [ ] 모든 외부 경로 입력은 **절대화 + 확장(\\?\)**
- [ ] **Reparse 정책** 명시(해석/스킵/타입별) + **루프 방지** 구현
- [ ] UNC/SMB는 **OVERLAPPED + 타임아웃 + 취소**
- [ ] **I/O 우선순위 힌트**(백그라운드) 사용
- [ ] 메타 왕복 최소화(FindExInfoBasic, batched queries)
- [ ] 파일 ID/USN 사용 시 **불가/재생성 케이스** 대비
- [ ] 교체/저장 시 **임시 파일 + 원자 교체** 패턴
- [ ] 로깅은 **경로/오류코드/리파스태그/서버/쉐어**까지

---

## 흔한 함정과 해결

| 증상 | 원인 | 해결 |
|---|---|---|
| 길이 260 조금 넘으면 실패 | 확장 경로 미사용 | **`\\?\`** 접두, 또는 **longPathAware** + 여전히 확장 권장 |
| Junction 루프 무한 재귀 | 리파스 해석 + 방문 체크 없음 | **`FILE_ATTRIBUTE_REPARSE_POINT` 검사 + 방문 집합** |
| UNC에서 랜덤 멈춤 | 동기 I/O + 오플락 브레이크/네트워크 지연 | **OVERLAPPED + CancelIoEx + 타임아웃** |
| 경로가 바뀌면 더 이상 추적 불가 | 경로 기반 캐시 | **파일 ID** 캐시, **USN rename**로 갱신 |
| “권한 없음/경로 없음” 혼선 | 리파스 대상 접근 실패/권한 | **리파스 자체 열기** 후 태그 분석/에러 메시지 구분 |
| Replace 실패/손상 | 다른 볼륨/SMB 원자성 부재 | **같은 디렉터리 임시 + MoveFileEx(REPLACE_EXISTING)** |

---

## 결론

- **확장 경로(\\?\)**, **리파스 안전성**, **네트워크 타임아웃/취소**, **파일 ID/USN**을 갖추면
  **로컬/UNC/가상/클라우드가 섞인 최악의 경로**에서도 **예측 가능한 동작**을 보장할 수 있습니다.
- “평균이 아닌 **최악**을 위한 설계”가 스토리지의 기본기입니다.
- 이 가이드를 템플릿으로 삼아 **트리 스캐너/동기화/백업/에디터** 등 모든 파일 중심 앱의 **내구성**을 끌어올리세요.
