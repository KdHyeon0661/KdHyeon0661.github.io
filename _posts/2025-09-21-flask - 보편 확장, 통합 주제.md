---
layout: post
title: flask - 보편 확장, 통합 주제
date: 2025-09-21 19:25:23 +0900
category: flask
---
# 17. 보편 확장/통합 주제

## 17.1 OAuth 로그인 (소셜/OIDC)

### 17.1.1 개념 요약

- **OAuth 2.0**: 권한 위임(로그인이라기보단 “리소스 접근 권한” 부여).  
- **OpenID Connect (OIDC)**: OAuth 2.0 위에서 **ID 토큰**(JWT) 규격을 더해 **인증** 용도로 사용 가능.  
- **소셜 로그인**: Google/GitHub/Kakao 등 공급자(Provider)를 인증 브로커로 사용.  
- **플로우**: Authorization Code (PKCE 권장) → 토큰 교환 → 사용자 정보 조회 → **앱의 세션/계정 연동**.

> 원칙: **외부 로그인은 “우리 서비스 계정”을 만들어 연결한다.** “소셜 계정=우리 계정”을 동일시하지 말고, **연결/해제** 상태로 다룬다.

### 17.1.2 의존성(권장 라이브러리)

- **Authlib**: OAuth/OIDC에 강력하며 Flask 통합 훌륭.
- (대안) **Flask-Dance**: 핸들러/세션 편리 (프로덕션에선 Authlib 선호하는 팀이 많음).

```bash
pip install Authlib
```

### 17.1.3 데이터 모델

```python
# app/models/account.py
from app.extensions import db
from datetime import datetime, timezone

class User(db.Model):
    __tablename__ = "users"
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(255), unique=True, index=True)
    name = db.Column(db.String(120))
    avatar_url = db.Column(db.String(512))
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))

class OAuthAccount(db.Model):
    __tablename__ = "oauth_accounts"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"), index=True)
    provider = db.Column(db.String(50), index=True)   # 'google', 'github', 'kakao'
    subject = db.Column(db.String(255), index=True)   # provider 내부의 사용자 고유 ID (sub)
    access_token = db.Column(db.Text)
    refresh_token = db.Column(db.Text)
    expires_at = db.Column(db.DateTime(timezone=True))
    user = db.relationship("User", backref="oauth_accounts")
    __table_args__ = (db.UniqueConstraint("provider","subject", name="uq_oauth_provider_subject"),)
```

### 17.1.4 Authlib 설정(공통)

```python
# app/auth/oauth.py
from authlib.integrations.flask_client import OAuth
from flask import current_app

oauth = OAuth()

def init_oauth(app):
    oauth.init_app(app)
    # Google (OIDC)
    oauth.register(
        name="google",
        server_metadata_url="https://accounts.google.com/.well-known/openid-configuration",
        client_id=app.config["GOOGLE_CLIENT_ID"],
        client_secret=app.config["GOOGLE_CLIENT_SECRET"],
        client_kwargs={"scope": "openid email profile"},
    )
    # GitHub (OAuth2)
    oauth.register(
        name="github",
        api_base_url="https://api.github.com/",
        access_token_url="https://github.com/login/oauth/access_token",
        authorize_url="https://github.com/login/oauth/authorize",
        client_id=app.config["GITHUB_CLIENT_ID"],
        client_secret=app.config["GITHUB_CLIENT_SECRET"],
        client_kwargs={"scope": "read:user user:email"},
    )
    # Kakao (OAuth2)
    oauth.register(
        name="kakao",
        api_base_url="https://kapi.kakao.com",
        access_token_url="https://kauth.kakao.com/oauth/token",
        authorize_url="https://kauth.kakao.com/oauth/authorize",
        client_id=app.config["KAKAO_REST_API_KEY"],    # 카카오에서는 "REST API 키"
        client_kwargs={"scope": "profile_nickname account_email"},
    )
```

### 17.1.5 로그인 라우트(공통 콜백)

```python
# app/blueprints/auth/social.py
from flask import Blueprint, redirect, url_for, request, session
from flask import current_app, flash
from flask_login import login_user
from app.auth.oauth import oauth
from app.extensions import db
from app.models.account import User, OAuthAccount
from datetime import datetime, timezone, timedelta

bp = Blueprint("social_auth", __name__, url_prefix="/auth")

@bp.get("/login/<provider>")
def login(provider):
    client = oauth.create_client(provider)
    if client is None:
        flash("Unsupported provider", "danger")
        return redirect(url_for("site.home"))
    redirect_uri = url_for("social_auth.auth_callback", provider=provider, _external=True)
    # PKCE는 Authlib가 자동 처리(요청 시 코드챌린지 생성)
    return client.authorize_redirect(redirect_uri)

@bp.get("/callback/<provider>")
def auth_callback(provider):
    client = oauth.create_client(provider)
    token = client.authorize_access_token()  # 토큰 교환
    # OIDC (google)인 경우 userinfo 엔드포인트 존재
    if provider == "google":
        userinfo = client.parse_id_token(token)  # ID 토큰 파싱
        sub = userinfo["sub"]
        email = userinfo.get("email")
        name = userinfo.get("name")
        picture = userinfo.get("picture")
    elif provider == "github":
        me = client.get("user").json()
        emails = client.get("user/emails").json()
        sub = str(me["id"])
        primary_email = next((e["email"] for e in emails if e.get("primary")), None)
        email = primary_email or me.get("email")
        name = me.get("name") or me.get("login")
        picture = me.get("avatar_url")
    elif provider == "kakao":
        me = client.get("/v2/user/me").json()
        sub = str(me.get("id"))
        kakao_account = me.get("kakao_account", {})
        profile = kakao_account.get("profile", {})
        email = kakao_account.get("email")
        name = profile.get("nickname")
        picture = profile.get("profile_image_url")
    else:
        flash("Unsupported provider", "danger")
        return redirect(url_for("site.home"))

    # 계정 연결 / 생성
    oauth_acct = OAuthAccount.query.filter_by(provider=provider, subject=sub).one_or_none()
    if oauth_acct:
        user = oauth_acct.user
        # 토큰 갱신 저장(선택)
        oauth_acct.access_token = token.get("access_token")
        oauth_acct.refresh_token = token.get("refresh_token")
        if "expires_in" in token:
            oauth_acct.expires_at = datetime.now(timezone.utc) + timedelta(seconds=int(token["expires_in"]))
    else:
        # 신규 유저 생성 or 기존 이메일 매칭 후 링크
        user = User.query.filter_by(email=email).one_or_none()
        if not user:
            user = User(email=email, name=name, avatar_url=picture)
            db.session.add(user); db.session.flush()
        oauth_acct = OAuthAccount(
            user_id=user.id, provider=provider, subject=sub,
            access_token=token.get("access_token"),
            refresh_token=token.get("refresh_token"),
            expires_at=(datetime.now(timezone.utc) + timedelta(seconds=int(token["expires_in"]))) if token.get("expires_in") else None,
        )
        db.session.add(oauth_acct)
    db.session.commit()

    login_user(user, remember=True)
    flash(f"Logged in via {provider}", "success")
    return redirect(url_for("site.home"))
```

> **보안 팁**
> - **state/nonce** 검증은 Authlib가 처리.  
> - **리다이렉션 대상 제한**(open redirect 방지) – `next` 파라미터 화이트리스트.  
> - 토큰/리프레시토큰은 **암호화 저장**(예: Fernet/KMS) 고려.  
> - **탈퇴/연결해제** 기능 제공(해당 `OAuthAccount` 삭제).

---

## 17.2 GraphQL 도입 판단 기준 (Ariadne/Strawberry)

### 17.2.1 REST vs GraphQL — 언제 쓸까?

- **GraphQL 장점**
  - 클라이언트가 **필요한 데이터만** 질의(Over/Under-fetch 문제 개선)
  - **스키마 중심** 계약과 강력한 타입 시스템, 유연한 확장
  - **단일 엔드포인트**로 복잡한 관계 조회/조합에 유리
- **주의/비용**
  - 캐싱/모니터링/권한/복잡도 관리가 어렵다
  - 쿼리 비용 관리(복잡도 제한/깊이 제한/타임아웃/RateLimit) 필수
- **결론**: **다양한 클라이언트가 풍부한 읽기 질의를 수행**하고 **관계형 조합**이 많다면 고려.  
  간단 CRUD 위주/정형 API는 REST가 더 단순/효율적.

### 17.2.2 Ariadne vs Strawberry

| 항목 | Ariadne | Strawberry |
|---|---|---|
| 철학 | **스키마 우선(schema-first)**: SDL(스키마 정의 언어) 작성 → 리졸버 연결 | **파이썬 타입 우선**: dataclass/타입힌트로 GraphQL 스키마 생성 |
| 장점 | GraphQL에 익숙한 팀에 자연스러움, 스키마와 구현 분리 | Pythonic, IDE 타입 지원/리팩토링 유리, 작은 프로젝트에 생산성↑ |
| 생태계 | Starlette/FastAPI/Flask 통합, 확장 플러그인 풍부 | FastAPI/Flask 통합, Federation 등 지원 확대 중 |
| 추천 | 대규모/팀 협업, SDL 선호 | 소규모/빠른 개발, 타입힌트 중시 |

> 두 라이브러리 모두 Flask와 쉽게 연동 가능. **권한/로깅/서킷/데이터로더** 는 동일한 운영 이슈.

---

## 17.3 Ariadne 예제(Flask 통합)

### 17.3.1 설치

```bash
pip install ariadne ariadne[flask] graphql-core==3.*
```

### 17.3.2 SDL + 리졸버

```python
# app/graphql/schema.graphql
type User { id: ID!, email: String!, name: String, avatarUrl: String }
type Query {
  me: User
  users(limit: Int = 20): [User!]!
}
type Mutation {
  updateName(name: String!): User!
}
```

```python
# app/graphql/schema.py
from ariadne import QueryType, MutationType, make_executable_schema, load_schema_from_path
from flask_login import current_user
from app.models.account import User

type_defs = load_schema_from_path("app/graphql/schema.graphql")
query = QueryType()
mutation = MutationType()

@query.field("me")
def resolve_me(*_):
    return current_user if getattr(current_user, "is_authenticated", False) else None

@query.field("users")
def resolve_users(*_, limit=20):
    return User.query.order_by(User.id.desc()).limit(limit).all()

@mutation.field("updateName")
def resolve_update_name(*_, name):
    if not getattr(current_user, "is_authenticated", False):
        raise Exception("Unauthorized")
    current_user.name = name
    from app.extensions import db
    db.session.commit()
    return current_user

schema = make_executable_schema(type_defs, [query, mutation])
```

### 17.3.3 Flask 뷰 연결 (GraphQL Playground 포함)

```python
# app/blueprints/graphql.py
from flask import Blueprint, request, jsonify
from ariadne import graphql_sync
from ariadne.explorer import ExplorerGraphiQL
from .auth import require_login  # 선택

from app.graphql.schema import schema

bp = Blueprint("graphql", __name__, url_prefix="/graphql")
explorer_html = ExplorerGraphiQL().html(None)

@bp.get("")
def explorer():
    return explorer_html

@bp.post("")
def graphql_server():
    data = request.get_json()
    success, result = graphql_sync(
        schema,
        data,
        context_value={"request": request},   # 권한/로깅/세션에 활용
        debug=False
    )
    status = 200 if success else 400
    return jsonify(result), status
```

### 17.3.4 DataLoader(쿼리 N+1 방지)

```python
# app/graphql/dataloaders.py
from promise import Promise
from promise.dataloader import DataLoader
from app.models.account import User

class UserByIdLoader(DataLoader):
    def batch_load_fn(self, ids):
        rows = User.query.filter(User.id.in_(ids)).all()
        by_id = {r.id: r for r in rows}
        return Promise.resolve([by_id.get(i) for i in ids])
```

컨텍스트에 주입:

```python
# in graphql_server()
from app.graphql.dataloaders import UserByIdLoader
ctx = {"request": request, "loaders": {"userById": UserByIdLoader()}}
success, result = graphql_sync(schema, data, context_value=ctx)
```

리졸버에서 사용:

```python
def resolve_post_author(obj, info):
    return info.context["loaders"]["userById"].load(obj.author_id)
```

### 17.3.5 보안/리소스 제어

- **쿼리 깊이/복잡도 제한**: 악성 쿼리 방지  
- **타임아웃**: 장시간 실행 방지  
- **권한 체크**: 리졸버 단위/스키마 지시어 기반  
- **로깅/메트릭**: 요청/리졸버 시간, 오류율 관측

간단 복잡도 제한 예(컨셉):

```python
MAX_DEPTH = 8
def validate_depth(document_ast):
    # AST 순회로 depth 계산(라이브러리 사용 가능)
    ...

# 실행 전 검사
# if depth > MAX_DEPTH: raise Exception("Query too deep")
```

---

## 17.4 Strawberry 예제(Flask 통합)

### 17.4.1 설치

```bash
pip install strawberry-graphql
```

### 17.4.2 타입 기반 스키마

```python
# app/graphql/strawberry_schema.py
import strawberry
from typing import Optional, List
from flask_login import current_user
from app.models.account import User as UserModel
from app.extensions import db

@strawberry.type
class User:
    id: strawberry.ID
    email: str
    name: Optional[str]
    avatar_url: Optional[str]

    @staticmethod
    def from_model(m: UserModel) -> "User":
        return User(id=str(m.id), email=m.email, name=m.name, avatar_url=m.avatar_url)

@strawberry.type
class Query:
    @strawberry.field
    def me(self) -> Optional[User]:
        if getattr(current_user, "is_authenticated", False):
            return User.from_model(current_user)
        return None

    @strawberry.field
    def users(self, limit: int = 20) -> List[User]:
        rows = UserModel.query.order_by(UserModel.id.desc()).limit(limit).all()
        return [User.from_model(r) for r in rows]

@strawberry.type
class Mutation:
    @strawberry.mutation
    def update_name(self, name: str) -> User:
        if not getattr(current_user, "is_authenticated", False):
            raise Exception("Unauthorized")
        current_user.name = name
        db.session.commit()
        return User.from_model(current_user)

schema = strawberry.Schema(query=Query, mutation=Mutation)
```

### 17.4.3 Flask 뷰

```python
# app/blueprints/graphql_strawberry.py
from flask import Blueprint
from strawberry.flask.views import GraphQLView
from app.graphql.strawberry_schema import schema

bp = Blueprint("graphql_strawberry", __name__, url_prefix="/gql")

bp.add_url_rule("", view_func=GraphQLView.as_view("graphql_view", schema=schema))
```

> Strawberry는 **Python 타입**과 **리졸버**가 일체화되어 IDE/타입체커 친화적.  
> 대신 **스키마(계약)**를 외부/프론트팀과 분리 관리하고 싶다면 Ariadne의 **SDL**이 명확할 수 있다.

---

## 17.5 서드파티 API 연동 — 회로 차단기/재시도/백오프

### 17.5.1 왜 필요한가?

- 외부 API는 **일시적 실패/속도 저하**가 빈번 → **재시도** + **지수 백오프**로 안정성↑  
- 장기 장애/슬로우 상태에서 무한 재시도는 **폭주** → **회로 차단기(circuit breaker)** 로 빠른 실패/격리  
- 실패/성공률/지연을 **메트릭**으로 관측/알람

### 17.5.2 httpx + tenacity + 간단 회로차단기

```bash
pip install httpx tenacity
```

```python
# app/integrations/client.py
import time, threading
import httpx
from tenacity import retry, stop_after_attempt, wait_exponential_jitter, retry_if_exception_type

class CircuitBreaker:
    def __init__(self, failure_threshold=5, reset_timeout=30):
        self.failure_threshold = failure_threshold
        self.reset_timeout = reset_timeout
        self.failures = 0
        self.state = "CLOSED"   # CLOSED -> OPEN -> HALF_OPEN
        self.opened_at = 0.0
        self.lock = threading.Lock()

    def allow(self) -> bool:
        with self.lock:
            if self.state == "OPEN":
                if time.time() - self.opened_at > self.reset_timeout:
                    self.state = "HALF_OPEN"
                    return True
                return False
            return True

    def on_success(self):
        with self.lock:
            self.failures = 0
            self.state = "CLOSED"

    def on_failure(self):
        with self.lock:
            self.failures += 1
            if self.failures >= self.failure_threshold:
                self.state = "OPEN"
                self.opened_at = time.time()

client = httpx.Client(timeout=httpx.Timeout(5.0, connect=2.0, read=3.0))
breaker = CircuitBreaker(failure_threshold=5, reset_timeout=20)

class UpstreamTemporaryError(Exception): ...
class CircuitOpenError(Exception): ...

@retry(
    reraise=True,
    stop=stop_after_attempt(3),
    wait=wait_exponential_jitter(initial=0.2, max=2.0),
    retry=retry_if_exception_type((httpx.HTTPError, UpstreamTemporaryError))
)
def get_json(url, headers=None):
    if not breaker.allow():
        raise CircuitOpenError("circuit open")

    try:
        r = client.get(url, headers=headers)
        if r.status_code >= 500:
            raise UpstreamTemporaryError(f"5xx from upstream: {r.status_code}")
        r.raise_for_status()
        breaker.on_success()
        return r.json()
    except (httpx.HTTPError, UpstreamTemporaryError) as e:
        breaker.on_failure()
        raise
```

> **지표**: `circuit_state{service="foo"}`, `retries_total`, `latency` 를 Prometheus에 발행(11장 참조).  
> **레이트리미트**(429) → `Retry-After` 존중 + **큐/버퍼** 전략 고려.

### 17.5.3 요청 서명/보안/감사

- 일부 API는 **HMAC 서명**/API 키 필요 → **서명 유효성** 체크, 키 로테이션 대비  
- **PII**/토큰은 로그에서 마스킹(11장)  
- **Idempotency-Key**를 헤더로 보내 **중복 버튼 클릭**/재시도 중 **중복 처리 방지**

예: Stripe 스타일 아이들포턴시 헤더

```python
import uuid
headers = {
    "Authorization": f"Bearer {API_KEY}",
    "Idempotency-Key": uuid.uuid4().hex,
}
r = client.post(url, json=payload, headers=headers)
```

서버 측(우리가 제공자라면) 처리:

```python
# app/idempotency/store.py
from app.extensions import cache  # Redis 등
def idempo_check_and_set(key: str, response: dict, ttl=3600):
    existing = cache.get(f"idempo:{key}")
    if existing:
        return existing  # 이전 응답 그대로 반환
    cache.set(f"idempo:{key}", response, ttl)
    return None
```

---

## 17.6 웹훅(Webhook) 설계

### 17.6.1 원칙

- **수신 서버는 매우 빨리 2xx** 응답(수 초 이상 작업은 **백그라운드 큐**에 맡김)  
- **서명 검증**(HMAC 등) + **타임스탬프/리플레이 방지**  
- **리트라이**: 제공자가 **재시도** 가능하므로 **멱등 처리** 필수(아이들포턴시 키 또는 이벤트 ID 저장)  
- **가시성**: 수신 기록/상태/재처리 UI 제공(운영툴 14장)

### 17.6.2 HMAC 서명 검증 (Stripe 유사)

```python
# app/webhooks/verify.py
import hmac, hashlib, time

class InvalidSignature(Exception): ...
class ReplayAttack(Exception): ...

def verify_signature(raw_body: bytes, header: str, secret: str, tolerance=300):
    # header 형식 예: "t=1700000000,v1=<hexsig>"
    try:
        parts = dict(kv.split("=",1) for kv in header.split(","))
        ts = int(parts["t"]); sig = parts["v1"]
    except Exception:
        raise InvalidSignature("bad header")

    if abs(int(time.time()) - ts) > tolerance:
        raise ReplayAttack("timestamp too old")

    payload = f"{ts}.{raw_body.decode('utf-8')}".encode("utf-8")
    expected = hmac.new(secret.encode("utf-8"), payload, hashlib.sha256).hexdigest()
    if not hmac.compare_digest(expected, sig):
        raise InvalidSignature("mismatch")
```

### 17.6.3 Flask 엔드포인트

```python
# app/blueprints/webhooks.py
from flask import Blueprint, request, jsonify
from app.webhooks.verify import verify_signature, InvalidSignature, ReplayAttack
from app.extensions import db
from app.tasks.webhook_tasks import handle_event_async
from app.models.webhook import WebhookEvent

bp = Blueprint("webhooks", __name__, url_prefix="/webhooks")

@bp.post("/provider-x")
def provider_x():
    raw = request.get_data()
    signature = request.headers.get("X-Signature")
    try:
        verify_signature(raw, signature, secret=current_app.config["PROVIDER_X_SECRET"])
    except (InvalidSignature, ReplayAttack) as e:
        return {"error": str(e)}, 400

    payload = request.get_json()
    event_id = payload.get("id")
    # 멱등 처리: 이미 처리한 이벤트는 스킵 (또는 이전 결과 반환)
    if WebhookEvent.query.filter_by(provider="x", event_id=event_id).first():
        return jsonify({"status": "duplicate"}), 200

    # 저장 후 비동기로 처리
    evt = WebhookEvent(provider="x", event_id=event_id, payload=payload, status="queued")
    db.session.add(evt); db.session.commit()

    handle_event_async.delay(evt.id)
    return jsonify({"status": "ok"}), 202
```

모델:

```python
# app/models/webhook.py
from app.extensions import db
from datetime import datetime, timezone

class WebhookEvent(db.Model):
    __tablename__="webhook_events"
    id = db.Column(db.Integer, primary_key=True)
    provider = db.Column(db.String(50), index=True)
    event_id = db.Column(db.String(200), index=True)   # 제공자의 고유 이벤트 ID
    payload = db.Column(db.JSON)
    status = db.Column(db.String(20), default="queued")  # queued|processing|done|error
    error = db.Column(db.Text)
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    __table_args__ = (db.UniqueConstraint("provider","event_id", name="uq_webhook_provider_event"),)
```

비동기 처리:

```python
# app/tasks/webhook_tasks.py
from celery import shared_task
from app.extensions import db
from app.models.webhook import WebhookEvent

@shared_task(bind=True, autoretry_for=(Exception,), retry_backoff=2, max_retries=5)
def handle_event_async(self, event_pk: int):
    evt = WebhookEvent.query.get(event_pk)
    evt.status = "processing"; db.session.commit()
    try:
        # 이벤트 타입별 분기
        typ = evt.payload.get("type")
        if typ == "payment.succeeded":
            _handle_payment(evt.payload)
        elif typ == "subscription.canceled":
            _handle_cancel(evt.payload)
        else:
            pass
        evt.status = "done"; evt.error = None
    except Exception as e:
        evt.status = "error"; evt.error = str(e)
        raise
    finally:
        db.session.commit()
```

> **운영 팁**
> - **Dead-letter 큐**/재처리 버튼 제공.  
> - **시간역순/필터/검색** 가능한 이벤트 인덱스.  
> - **2xx만 성공으로 간주**(3xx/4xx/5xx는 제공자 재시도 유발).

### 17.6.4 제공자(우리) 입장에서 웹훅 발신

- **서명**: `t=timestamp, v1=HMAC_SHA256(<t>.<body>, secret)` 헤더에 포함  
- **리트라이**: 2xx 외에는 **지수 백오프**로 재시도, 최대 횟수 제한  
- **아이들포턴시 키**: `event_id` 를 본문/헤더에 넣어 수신 측 멱등 처리 가능하게  
- **관측**: 성공률/지연/재시도 횟수/상대 서버 오류율

---

## 17.7 통합 시 공통 보안/품질 가이드

1) **타임아웃/재시도/백오프/회로 차단기**는 표준 유틸로 통일  
2) **Idempotency**: 외부 호출/웹훅/내부 큐 **모두** 중복 방지 키 사용  
3) **민감정보 마스킹**: 토큰/Authorization/PII 로그 금지(11장)  
4) **관측**: 로그(JSON) + 메트릭(성공률/지연/오류율) + 트레이스(10~11장)  
5) **키 로테이션/비밀 관리**: Secret Manager/KMS로 관리, 롤링 시 Downtime 없이 갱신  
6) **레이트 리미팅**: 외부 API 한도 준수, 우리의 API도 **429** + `Retry-After` 표준화  
7) **유닛/통합/계약 테스트**: 모킹/계약 검증(Pact)로 변경 감지(15장)

---

## 17.8 붙여넣기 스타터

### 17.8.1 OAuth 환경변수(예)

```bash
export GOOGLE_CLIENT_ID=...
export GOOGLE_CLIENT_SECRET=...
export GITHUB_CLIENT_ID=...
export GITHUB_CLIENT_SECRET=...
export KAKAO_REST_API_KEY=...
```

`config.py`:

```python
GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")
GITHUB_CLIENT_ID = os.getenv("GITHUB_CLIENT_ID")
GITHUB_CLIENT_SECRET = os.getenv("GITHUB_CLIENT_SECRET")
KAKAO_REST_API_KEY = os.getenv("KAKAO_REST_API_KEY")
```

### 17.8.2 Ariadne/Strawberry 라우트 병행

```python
# app/__init__.py (일부)
from .blueprints.graphql import bp as gql_ariadne
from .blueprints.graphql_strawberry import bp as gql_strawberry
app.register_blueprint(gql_ariadne)
app.register_blueprint(gql_strawberry)
```

### 17.8.3 httpx 클라이언트 표준 유틸

```python
# app/integrations/http.py
import httpx
from tenacity import retry, stop_after_attempt, wait_exponential_jitter, retry_if_exception_type

client = httpx.Client(timeout=httpx.Timeout(5.0, connect=2.0, read=3.0))

@retry(
    reraise=True,
    stop=stop_after_attempt(3),
    wait=wait_exponential_jitter(0.2, 2.0),
    retry=retry_if_exception_type(httpx.HTTPError)
)
def post_json(url, json, headers=None):
    r = client.post(url, json=json, headers=headers)
    r.raise_for_status()
    return r.json()
```

---

## 17.9 테스트 전략(요약)

- **OAuth 콜백**: 공급자 더블(로컬 서버/`responses` 로 토큰/유저 API 응답)  
- **GraphQL**: 스냅샷으로 쿼리 결과 회귀 검사(중요 필드만) + 복잡도 제한 테스트  
- **서드파티**: 회로 차단기 상태 전이/재시도 호출 횟수 단언  
- **웹훅**: 서명 검증 성공/실패/재시도/멱등성 단언, 큐 태스크 호출 확인

예) 웹훅 서명 테스트:

```python
def test_webhook_signature(client, app):
    secret = app.config["PROVIDER_X_SECRET"]
    ts = 1700000000
    body = b'{"id":"evt_1","type":"payment.succeeded"}'
    import hmac, hashlib
    sig = hmac.new(secret.encode(), f"{ts}.{body.decode()}".encode(), hashlib.sha256).hexdigest()
    hdr = f"t={ts},v1={sig}"
    r = client.post("/webhooks/provider-x", data=body, headers={"X-Signature": hdr, "Content-Type":"application/json"})
    assert r.status_code in (200, 202)
```

---

## 17.10 흔한 안티패턴

- **소셜 계정 = 우리 계정** 동일시 → 공급자 연결 해제 시 로그인 불가/복구 불가  
- **OAuth 토큰 평문 저장** & 로테이션 미흡 → 유출 위험  
- **GraphQL 복잡도/깊이 제한 없음** → DoS 유발  
- **재시도만 무한히**(백오프/회로차단기 없음) → 다운스트림/우리 시스템 모두 피해  
- **웹훅에서 오래 처리** → 타임아웃/중복 재시도 폭주  
- **웹훅 서명 미검증**/타임스탬프 무시 → 위조/리플레이 공격  
- **Idempotency 미적용** → 중복 결제/중복 주문 처리 사고

---

## 17.11 체크리스트

- [ ] Authlib로 OAuth/OIDC 프로바이더 등록(google/github/kakao)  
- [ ] 콜백에서 **계정 연결/생성** 로직 + **토큰 보관/암호화**  
- [ ] GraphQL 도입 기준 합의(쿼리 패턴/관계 복잡도/캐싱 전략)  
- [ ] Ariadne(스키마 우선) 또는 Strawberry(타입 우선) 선택/혼합 금지  
- [ ] DataLoader로 N+1 제거, **복잡도/깊이 제한**/타임아웃  
- [ ] httpx + tenacity로 **재시도/백오프** + 회로차단기 표준 적용  
- [ ] 웹훅: **서명 검증 + 타임스탬프 + 멱등 처리 + 비동기**  
- [ ] 로깅/메트릭/트레이싱 연동(11장), 실패/재시도 가시화  
- [ ] 계약/통합 테스트(15장), 공급자 샌드박스 환경 분리  
- [ ] 비밀/키 로테이션 정책, 권한 최소화(IAM)
