---
layout: post
title: Django - 웹 기본기 묶음 (1)
date: 2025-10-01 17:25:23 +0900
category: Django
---
# 2. 웹 기본기 묶음 (1) — 정적/미디어 파일, 인증/권한, 세션/쿠키 (Django 5.x 기준)

## A. 정적(Static) & 미디어(Media) 파일 — STATICFILES, MEDIA, 스토리지 백엔드(S3 등)

### A-0. 큰 그림

- **정적 파일**: 앱 코드와 함께 배포되는 **불변 자산**(CSS/JS/이미지/폰트 등).  
  개발 중에는 `runserver` 가 서빙(개발 편의), 운영에서는 **웹 서버/스토리지/CDN**이 서빙.
- **미디어 파일**: **사용자 업로드** 파일. 반드시 별도 루트(MEDIA_ROOT)와 URL(MEDIA_URL)을 분리.  
  운영에서는 **애플리케이션에서 직접 서빙하지 않고** 웹 서버/스토리지/CDN를 이용.

### A-1. 개발용 기본 설정

```python
# config/settings/base.py (공통)
from pathlib import Path
BASE_DIR = Path(__file__).resolve().parent.parent.parent

STATIC_URL = "static/"
STATICFILES_DIRS = [BASE_DIR / "static"]            # 개발 중 사용할 경로(선택)
STATIC_ROOT = BASE_DIR / "staticfiles"              # collectstatic 대상(운영 배포용)

MEDIA_URL = "media/"
MEDIA_ROOT = BASE_DIR / "media"                     # 업로드 저장 위치(개발)
```

디렉터리 레이아웃 예:
```
myproject/
├─ static/                  # 개발 중 참조 (예: css/site.css)
├─ staticfiles/             # collectstatic 결과 (운영 배포 산출물)
└─ media/                   # 업로드 파일 저장소(개발)
```

템플릿에서:
```html
{% load static %}
<link rel="stylesheet" href="{% static 'css/site.css' %}">
<img src="{{ user.profile_image.url }}" alt="">
```

### A-2. 운영 배포 패턴

1) **collectstatic**으로 모든 정적 파일을 한 곳(STATIC_ROOT)으로 모은 뒤  
2) **Nginx/Apache** 또는 **CDN**이 `/static/`을 서빙  
3) 미디어 파일은 `/media/`를 웹 서버 or 스토리지에서 서빙

명령:
```bash
python manage.py collectstatic
```

#### Nginx 예시 (운영)
```nginx
# 정적
location /static/ {
    alias /srv/app/staticfiles/;      # STATIC_ROOT
    add_header Cache-Control "public, max-age=31536000, immutable";
}

# 미디어
location /media/ {
    alias /srv/app/media/;            # MEDIA_ROOT (업로드)
    add_header Cache-Control "public, max-age=3600";
}
```

> **팁**: 정적 파일은 **해시 기반 파일명**(ManifestStaticFilesStorage)을 사용하면 캐싱/배포가 쉬워집니다.

### A-3. 해시 기반 정적 파일(캐시 무효화)

```python
# config/settings/prod.py
STATICFILES_STORAGE = "django.contrib.staticfiles.storage.ManifestStaticFilesStorage"
```

- CSS/JS 파일명에 콘텐츠 해시를 포함해 브라우저 캐시 무효화가 자동화됩니다.
- `collectstatic` 시점에 해시가 계산되며 `{% static %}` 가 자동으로 해시된 경로를 생성.

### A-4. WhiteNoise(간편 서빙, 소규모/단일 컨테이너)

Nginx 없이 **애플리케이션 프로세스에서 정적 서빙**이 필요할 때(간단 배포) 사용.

```bash
pip install whitenoise
```

```python
# config/settings/prod.py
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",  # SecurityMiddleware 다음
    ...
]
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"
```

> CDN이나 Nginx를 쓰면 더 효율적이지만, 초기 배포/소규모에 WhiteNoise가 간단합니다.

### A-5. S3 등 외부 스토리지(django-storages)

```bash
pip install django-storages boto3
```

```python
# config/settings/prod.py
INSTALLED_APPS += ["storages"]

# 정적 파일을 S3로
AWS_STORAGE_BUCKET_NAME = "myapp-static-bucket"
AWS_S3_REGION_NAME = "ap-northeast-2"
AWS_S3_SIGNATURE_VERSION = "s3v4"

# 정적
STATICFILES_STORAGE = "storages.backends.s3boto3.S3Boto3Storage"
STATIC_URL = f"https://{AWS_STORAGE_BUCKET_NAME}.s3.amazonaws.com/"

# 미디어(업로드)도 S3로 (별도 백엔드 클래스를 둬 분리 권장)
DEFAULT_FILE_STORAGE = "myproject.storage_backends.MediaStorage"
MEDIA_URL = f"https://{AWS_STORAGE_BUCKET_NAME}.s3.amazonaws.com/media/"
```

`storage_backends.py`:
```python
# myproject/storage_backends.py
from storages.backends.s3boto3 import S3Boto3Storage

class MediaStorage(S3Boto3Storage):
    location = "media"
    default_acl = "private"       # 업로드는 기본 비공개 권장
    file_overwrite = False
```

- **정적은 public read**, **미디어는 private + 서명 URL** 패턴을 권장.
- 이미지 썸네일/리사이즈/바이러스 스캔은 **비동기(Celery)** 로 오프로딩.

### A-6. 보안/규모 팁

- **미디어 파일은 앱 서버에서 직접 보내지 않기** → CDN/웹 서버/스토리지에서 서빙  
- 업로드 검증: **확장자 + MIME + 실제 포맷 확인(Pillow 등)**  
- 대용량: **S3 pre-signed URL**(클라이언트에서 직접 업로드), 백그라운드 후처리  
- **디렉터리 인덱싱 금지**, 직접 경로 노출 최소화

---

## B. 인증/권한 — 기본 Auth, 커스텀 User, Permission/Group, 로그인 흐름

### B-0. 큰 그림

- Django는 **배터리 포함** 인증 스택: User 모델, 비밀번호 해시, 로그인/로그아웃, 권한/그룹, 세션, 데코레이터/믹스인, Admin 통합.
- **초기 설계 단계에서 “커스텀 User” 채택 여부**를 반드시 결정(변경 난이도가 높음).

### B-1. 기본 설정과 미들웨어

```python
# config/settings/base.py
INSTALLED_APPS += [
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
]

MIDDLEWARE += [
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
]

AUTHENTICATION_BACKENDS = [
    "django.contrib.auth.backends.ModelBackend",  # 기본 권한 체계(perm) 백엔드
]
LOGIN_URL = "accounts:login"
LOGIN_REDIRECT_URL = "core:home"
LOGOUT_REDIRECT_URL = "core:home"
```

### B-2. 로그인/로그아웃/회원가입(기본 Form 이용)

URL:
```python
# apps/accounts/urls.py
from django.urls import path
from . import views

app_name = "accounts"
urlpatterns = [
    path("login/",  views.login_view,  name="login"),
    path("logout/", views.logout_view, name="logout"),
    path("signup/", views.signup,      name="signup"),
]
```

뷰:
```python
# apps/accounts/views.py
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.forms import AuthenticationForm, UserCreationForm
from django.shortcuts import render, redirect
from django.contrib import messages

def login_view(request):
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()  # 내부에서 authenticate 수행
            login(request, user)
            messages.success(request, "로그인되었습니다.")
            next_url = request.GET.get("next") or "core:home"
            return redirect(next_url)
    else:
        form = AuthenticationForm(request)
    return render(request, "accounts/login.html", {"form": form})

def logout_view(request):
    logout(request)
    messages.info(request, "로그아웃되었습니다.")
    return redirect("core:home")

def signup(request):
    if request.method == "POST":
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            messages.success(request, "가입이 완료되었습니다. 로그인해 주세요.")
            return redirect("accounts:login")
    else:
        form = UserCreationForm()
    return render(request, "accounts/signup.html", {"form": form})
```

템플릿(요약):
```html
<!-- templates/accounts/login.html -->
<form method="post">
  {% csrf_token %}
  {{ form.non_field_errors }}
  {{ form.username.label_tag }} {{ form.username }} {{ form.username.errors }}
  {{ form.password.label_tag }} {{ form.password }} {{ form.password.errors }}
  <button type="submit">로그인</button>
</form>
```

### B-3. 보호(데코레이터/믹스인)

함수형 뷰:
```python
from django.contrib.auth.decorators import login_required, permission_required

@login_required
def dashboard(request):
    ...

@permission_required("shop.view_order", raise_exception=True)
def order_admin(request):
    ...
```

클래스형 뷰:
```python
from django.contrib.auth.mixins import LoginRequiredMixin, PermissionRequiredMixin
from django.views.generic import TemplateView

class DashboardView(LoginRequiredMixin, TemplateView):
    template_name = "core/dashboard.html"

class OrderAdminView(PermissionRequiredMixin, TemplateView):
    template_name = "shop/order_admin.html"
    permission_required = "shop.view_order"
    raise_exception = True
```

### B-4. 권한(Permission) & 그룹(Group)

- Django는 **모델별 자동 권한**(add/change/delete/view)을 생성.
- **그룹**에 권한을 부여 → 사용자에게 그룹을 할당 → 권한 상속.

관리자(Admin)에서 그룹 구성 후 사용자에게 부여하거나, 코드로 부여:
```python
from django.contrib.auth.models import Group, Permission
group, _ = Group.objects.get_or_create(name="Staff")
perm = Permission.objects.get(codename="view_order")
group.permissions.add(perm)
user.groups.add(group)
```

특정 도메인 권한 규칙이 복잡하다면 **Object-Level Permission**(예: django-guardian) 같은 패키지 고려.

### B-5. 커스텀 User — `AbstractUser` vs `AbstractBaseUser`

**왜?**  
- 기본 `username` 대신 `email` 을 로그인 식별자로 사용,  
- 프로필 필드(전화, 실명, 조직, role 등) 확장,  
- 외부 인증(IdP)과의 정합.

**권장**: 초기 설계부터 `AbstractUser` 상속을 채택(마이그레이션 이후 변경 비용이 큼).

```python
# apps/accounts/models.py
from django.contrib.auth.models import AbstractUser
from django.db import models

class User(AbstractUser):
    # username, email, first_name, last_name 등 기본 필드 유지
    phone = models.CharField(max_length=20, blank=True)
    is_marketing_agreed = models.BooleanField(default=False)
```

설정:
```python
# config/settings/base.py
AUTH_USER_MODEL = "accounts.User"
```

#### 이메일 로그인을 위한 `AbstractBaseUser` (고급)

```python
# apps/accounts/models.py (간소화 예시)
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, BaseUserManager
from django.db import models

class UserManager(BaseUserManager):
    def create_user(self, email, password=None, **extra):
        if not email:
            raise ValueError("Email is required")
        email = self.normalize_email(email)
        user = self.model(email=email, **extra)
        user.set_password(password)
        user.save(using=self._db)
        return user
    def create_superuser(self, email, password=None, **extra):
        extra.setdefault("is_staff", True)
        extra.setdefault("is_superuser", True)
        return self.create_user(email, password, **extra)

class User(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(unique=True)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = []             # createsuperuser 시 추가 질의 필드
    objects = UserManager()
```

- 관리자(Admin) 등록 및 `ModelAdmin` 커스터마이징 필요.
- 장점: 로그인 식별/필드 구성을 완전 제어. 단점: 구현/메인터넌스 난이도 ↑.

### B-6. 비밀번호 해시/정책/재설정

- Django는 **PBKDF2(기본)** 등 안전한 해시를 사용.  
- 설정에서 **검증기** 추가:
```python
AUTH_PASSWORD_VALIDATORS = [
  {"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"},
  {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator", "OPTIONS": {"min_length": 10}},
  {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
  {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]
```

- 비밀번호 재설정(Password Reset) 기본 뷰/템플릿을 제공(이메일 백엔드 필요) — 실제 배포에서는 **SMTP/트랜잭셔널 이메일** 서비스 연동.

### B-7. 소셜 로그인/이메일 인증

- **django-allauth** 추천: 소셜(OAuth), 이메일 인증, 로그인/가입 플로우 통합.  
- 기업 SSO(OIDC/SAML)는 전용 백엔드/미들웨어 또는 리버스 프록시(IdP)와 연동.

---

## C. 세션/쿠키 — 백엔드 엔진 비교, 보안 옵션, remember-me

### C-0. 큰 그림

- **세션**: 사용자별 상태를 서버에(또는 쿠키에) 저장·조회하는 메커니즘. Django는 미들웨어로 세션을 관리.
- **쿠키**: 브라우저가 서버 도메인에 대해 유지하는 **작은 키-값 저장소**. 보안 속성(Secure/HttpOnly/SameSite) 중요.
- **remember-me**: 로그인 세션 만료를 **긴 기간**으로 연장하는 UX 패턴(체크박스로 흔히 제공).

### C-1. 세션 백엔드 엔진 비교

| 엔진 | 설정 값 | 특징 | 장단점 |
|---|---|---|---|
| DB 세션 | `django.contrib.sessions.backends.db` | 기본값. 세션을 DB 테이블에 저장 | 설치 간단/트랜잭션, 대량 트래픽 시 DB 부담 |
| 캐시 세션 | `django.contrib.sessions.backends.cache` | 캐시에 저장 | 매우 빠름/휘발성, 캐시 클러스터 필요 |
| 캐시+DB | `django.contrib.sessions.backends.cached_db` | 캐시 미스 시 DB 조회 | 성능/내구성 균형 |
| 서명 쿠키 | `django.contrib.sessions.backends.signed_cookies` | 서버 저장소 없이 쿠키 자체에 저장(서명) | 서버 메모리 無/쿠키 크기 제한/조작 방지 서명 |

설정:
```python
# config/settings/base.py
SESSION_ENGINE = "django.contrib.sessions.backends.cached_db"
SESSION_COOKIE_NAME = "sessionid"
SESSION_COOKIE_AGE = 60 * 60 * 24 * 14   # 2주 (초 단위)
SESSION_SAVE_EVERY_REQUEST = False       # 요청마다 만료 연장 여부
```

> **서명 쿠키 세션**은 **대용량 상태** 저장에 부적합(쿠키 크기 제한).  
> 대개 `cached_db` 또는 `cache`(Redis) 사용을 권장.

### C-2. 쿠키 보안 옵션

```python
# config/settings/prod.py
CSRF_COOKIE_SECURE = True        # HTTPS 에서만
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_HTTPONLY = False     # CSRF 쿠키는 JS 접근 X가 아님 (토큰을 폼에 렌더)
SESSION_COOKIE_HTTPONLY = True   # JS 접근 금지(권장)
CSRF_COOKIE_SAMESITE = "Lax"     # "Strict"|"Lax"|"None"
SESSION_COOKIE_SAMESITE = "Lax"
SECURE_HSTS_SECONDS = 60 * 60 * 24 * 30
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
```

- **Secure**: HTTPS에서만 전송  
- **HttpOnly**: JS에서 접근 금지(XSS 보호)  
- **SameSite**: 크로스 사이트 요청에 대한 쿠키 전송 제한(CSRF 위험 감소)

### C-3. 세션 사용법(뷰 코드)

```python
def set_color(request):
    request.session["theme"] = request.POST.get("theme", "light")
    return redirect("core:home")

def get_color(request):
    theme = request.session.get("theme", "light")
    return render(request, "core/home.html", {"theme": theme})
```

- Django는 세션 dict를 변경하면 **자동으로 저장 마킹**(수정 감지).
- 파일 업로드/장바구니/위시리스트 등 경량 상태 저장에 적합(민감 정보 저장 금지).

### C-4. remember-me(세션 만료 제어)

**UX**: 로그인 폼에서 “로그인 상태 유지(remember me)” 체크 → 세션 만료를 **길게** 설정.

```python
# apps/accounts/views.py (예시)
from django.conf import settings
from django.contrib.auth import login
from django.contrib.auth.forms import AuthenticationForm
from django.shortcuts import render, redirect

def login_view(request):
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        remember = request.POST.get("remember") == "on"
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            if remember:
                # 브라우저 종료 후에도 유지: COOKIE_AGE 사용
                request.session.set_expiry(settings.SESSION_COOKIE_AGE)   # 예: 2주
            else:
                # 브라우저 종료 시 만료
                request.session.set_expiry(0)
            return redirect(request.GET.get("next") or "core:home")
    else:
        form = AuthenticationForm(request)
    return render(request, "accounts/login.html", {"form": form})
```

템플릿:
```html
<!-- templates/accounts/login.html -->
<form method="post">
  {% csrf_token %}
  {{ form.non_field_errors }}
  {{ form.username.label_tag }} {{ form.username }} {{ form.username.errors }}
  {{ form.password.label_tag }} {{ form.password }} {{ form.password.errors }}
  <label><input type="checkbox" name="remember"> 로그인 상태 유지</label>
  <button type="submit">로그인</button>
</form>
```

> **주의**: remember-me 기간이 충분히 길다면 **2FA(OTP/WebAuthn)** 등으로 보완을 고려. 공용 PC에서는 기본 해제.

### C-5. CSRF와 세션

- Django는 **CSRF 보호**를 기본 제공(템플릿 `csrf_token`, 미들웨어).  
- API/SPA 환경에서는 **쿠키 SameSite, CSRF 토큰 전송 방식**(헤더/폼)을 명확히 설계.  
- 세션 인증 + CSRF는 **서버 렌더링/HTMX** 패턴과 잘 맞습니다.

### C-6. 세션 스토리지(캐시/Redis) 구성

`django-redis` 예시:
```bash
pip install django-redis
```

```python
# config/settings/prod.py
CACHES = {
  "default": {
    "BACKEND": "django_redis.cache.RedisCache",
    "LOCATION": "redis://redis:6379/1",
    "OPTIONS": {
      "CLIENT_CLASS": "django_redis.client.DefaultClient",
    }
  }
}
SESSION_ENGINE = "django.contrib.sessions.backends.cache"
SESSION_CACHE_ALIAS = "default"
```

- Redis 다운타임 시 로그인 상태 손실 가능 → 높은 가용성 구성 필요(Replica/Cluster).
- 대규모 서비스는 세션/캐시 계층을 **애플리케이션과 분리**하여 스케일 아웃.

---

## D. 종합 예제 — “프로필 이미지 업로드 + 접근 권한 + remember-me 로그인”

### D-1. 모델

```python
# apps/accounts/models.py
from django.contrib.auth.models import AbstractUser
from django.db import models

def user_avatar_path(instance, filename):
    return f"avatars/{instance.pk}/{filename}"

class User(AbstractUser):
    avatar = models.ImageField(upload_to=user_avatar_path, blank=True, null=True)
    bio = models.CharField(max_length=160, blank=True)
```

### D-2. 폼

```python
# apps/accounts/forms.py
from django import forms
from .models import User

class ProfileForm(forms.ModelForm):
    class Meta:
        model = User
        fields = ["avatar", "bio"]

    def clean_avatar(self):
        f = self.cleaned_data.get("avatar")
        if not f:
            return f
        if f.size > 2 * 1024 * 1024:
            raise forms.ValidationError("아바타는 2MB 이하만 업로드 가능합니다.")
        if not str(f.content_type).startswith("image/"):
            raise forms.ValidationError("이미지 파일만 업로드하세요.")
        return f
```

### D-3. 뷰(로그인/프로필 수정/권한)

```python
# apps/accounts/views.py
from django.contrib.auth.decorators import login_required, permission_required
from django.shortcuts import render, redirect
from django.contrib import messages
from .forms import ProfileForm

@login_required
def profile(request):
    if request.method == "POST":
        form = ProfileForm(request.POST, request.FILES, instance=request.user)
        if form.is_valid():
            form.save()
            messages.success(request, "프로필을 업데이트했습니다.")
            return redirect("accounts:profile")
    else:
        form = ProfileForm(instance=request.user)
    return render(request, "accounts/profile.html", {"form": form})

@permission_required("shop.view_order", raise_exception=True)
def staff_orders(request):
    # 권한 있는 사용자만 접근
    ...
```

### D-4. 템플릿

```html
<!-- templates/accounts/profile.html -->
{% extends "base.html" %}
{% block content %}
<h1>내 프로필</h1>
<form method="post" enctype="multipart/form-data">
  {% csrf_token %}
  <div>
    {{ form.avatar.label_tag }} {{ form.avatar }} {{ form.avatar.errors }}
    {% if request.user.avatar %}
      <div><img src="{{ request.user.avatar.url }}" alt="" width="120"></div>
    {% endif %}
  </div>
  <div>
    {{ form.bio.label_tag }} {{ form.bio }} {{ form.bio.errors }}
  </div>
  <button type="submit">저장</button>
</form>
{% endblock %}
```

### D-5. 설정(보안/정적/미디어)

```python
# config/settings/prod.py
CSRF_COOKIE_SECURE = True
SESSION_COOKIE_SECURE = True
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = "Lax"

STATICFILES_STORAGE = "django.contrib.staticfiles.storage.ManifestStaticFilesStorage"

MEDIA_URL = "media/"
MEDIA_ROOT = BASE_DIR / "media"  # 또는 S3 (DEFAULT_FILE_STORAGE 설정)
```

> 운영에서 미디어는 S3(private) + 서명 URL을 강력 권장.

### D-6. 로그인(remember-me) 템플릿 확장

```html
<!-- templates/accounts/login.html -->
<form method="post">
  {% csrf_token %}
  {{ form.non_field_errors }}
  <div>{{ form.username.label_tag }} {{ form.username }} {{ form.username.errors }}</div>
  <div>{{ form.password.label_tag }} {{ form.password }} {{ form.password.errors }}</div>
  <label><input type="checkbox" name="remember"> 로그인 상태 유지</label>
  <button type="submit">로그인</button>
</form>
```

---

## E. 운영 체크리스트 (요약)

**정적/미디어**
- [ ] `collectstatic` 파이프라인/CI에 포함
- [ ] 해시 기반 정적 파일(Manifest)로 캐싱 최적화
- [ ] 미디어는 스토리지(S3 등) + CDN 서빙, 접근 제어(서명 URL/ACL)
- [ ] 업로드 검증(확장자/MIME/실제 포맷), 바이러스 스캔/썸네일 비동기 처리

**인증/권한**
- [ ] 초기 설계에 `AUTH_USER_MODEL` 결정(가능하면 `AbstractUser` 상속)
- [ ] 비밀번호 정책/재설정/락아웃/2FA 고려
- [ ] 권한/그룹 모델링(관리자 작업 자동화 스크립트)
- [ ] 관리자(Admin) 접근 보호(IP allowlist/별도 도메인/2FA)

**세션/쿠키**
- [ ] 세션 엔진: 트래픽/내구성 기준으로 `cached_db` 또는 `cache`(Redis) 선정
- [ ] 보안 쿠키 옵션: Secure/HttpOnly/SameSite
- [ ] remember-me: 만료 정책 + 위험 완화(2FA/이상행동 탐지)
- [ ] CSRF 보호 플로우: 서버 렌더링/HTMX/API 별로 명확히 문서화

---

## F. 자주 묻는 질문(FAQ)

1) **정적 파일이 운영에서 404가 납니다.**  
→ `collectstatic` 실행 여부, Nginx의 `/static/` alias가 **STATIC_ROOT** 를 가리키는지 확인. Manifest 사용 시 `STATIC_URL` 경로 오타, 파일 권한/소유권도 점검.

2) **업로드 이미지가 너무 큽니다.**  
→ 폼 `clean_*` 에서 크기 제한, 업로드 직후 비동기로 리사이즈/썸네일 생성. 프론트엔드에서 클라이언트 리사이즈 적용 가능.

3) **이메일을 아이디로 쓰고 싶습니다.**  
→ 초기 설계에 `AbstractUser` 상속 + `USERNAME_FIELD="email"` 을 고려하거나, 완전한 `AbstractBaseUser` 커스터마이징. 마이그레이션 이후 변경은 난이도↑.

4) **권한이 복잡합니다(문서별 소유자/공유자).**  
→ 모델 단위 권한 외에 **Object-Level Permission** 패키지(django-guardian), 또는 명시적 ACL 테이블/도메인 서비스 설계를 고려.

5) **세션이 자주 끊깁니다.**  
→ 세션 엔진/만료 정책/로드밸런서 스티키 세션 여부 확인. 캐시 세션 사용 시 Redis 가용성/타임아웃 설정 점검.

---

## G. 추가 스니펫

### G-1. 로그인 시 마지막 로그인 시간/아이피 기록(신고/보안용)
```python
# apps/accounts/signals.py
from django.contrib.auth.signals import user_logged_in
from django.dispatch import receiver

@receiver(user_logged_in)
def on_login(sender, user, request, **kwargs):
    user.last_login_ip = request.META.get("REMOTE_ADDR")
    user.save(update_fields=["last_login_ip"])
```

모델:
```python
class User(AbstractUser):
    last_login_ip = models.GenericIPAddressField(blank=True, null=True)
```

### G-2. 파일 응답을 서명 URL로 리다이렉트(S3 프라이빗)
```python
# apps/assets/views.py
import datetime
import boto3
from django.conf import settings
from django.shortcuts import redirect

def private_download(request, key):
    s3 = boto3.client("s3", region_name=settings.AWS_S3_REGION_NAME)
    url = s3.generate_presigned_url(
        ClientMethod="get_object",
        Params={"Bucket": settings.AWS_STORAGE_BUCKET_NAME, "Key": f"media/{key}"},
        ExpiresIn=60  # 1분
    )
    return redirect(url)
```

### G-3. 강제 로그아웃(보안 이벤트 후 토큰 무효화)
```python
from django.contrib.sessions.models import Session

def logout_all_sessions(user):
    for s in Session.objects.all():
        data = s.get_decoded()
        if data.get("_auth_user_id") == str(user.pk):
            s.delete()
```

---

## 마무리

이 장에서는 **정적/미디어 파일 파이프라인(collectstatic, 해시/캐시, WhiteNoise, S3/서명 URL)**, **인증/권한(기본 로그인, 커스텀 사용자, 권한/그룹, 믹스인/데코레이터, 비밀번호 정책)**, **세션/쿠키(엔진별 특성, 보안 옵션, remember-me 구현)** 를 **운영 관점까지** 상세히 다뤘습니다.  
