---
layout: post
title: 운영체제 - 보안 (2)
date: 2025-10-29 23:25:23 +0900
category: 운영체제
---
# Chapter 16 — Security (2)

## 16.5 User Authentication

### 16.5.1 용어와 큰 그림
- **Identity(정체성)**: “누구인가”에 대한 주체(사람/서비스/디바이스).  
- **Credential(자격증명)**: 정체성을 **입증**하기 위한 데이터/토큰/비밀.  
- **Authentication(인증)**: “정말 그 사람 맞는가?”  
- **Authorization(인가)**: “무엇을 해도 되는가?”  
- **Accounting(감사)**: “무엇을 했는가?” 로그와 증적.

**요소(factors)**  
1) **지식**(Something you know): 패스워드/핀/보안질문(비권장).  
2) **소유**(Something you have): TOTP/HOTP 토큰·FIDO2 키·mTLS 클라이언트 인증서.  
3) **본인**(Something you are): 지문/FaceID/Windows Hello 등 생체.  
4) (+) **환경/맥락**: 기기 신뢰도·위치·네트워크·행동 패턴.  
**MFA**는 서로 다른 **두 요소 이상**을 조합.

---

### 16.5.2 패스워드: 생성·저장·검증의 원칙
- **길이 우선**(문자종류 강요는 효과 낮음): 최소 8~12자, 가능한 긴 구문 권장.  
- **사전·유출 목록**과 **금칙어** 체크(유출 패스워드 금지).  
- **주기적 강제 변경은 지양**: 유출/의심 이벤트 시 변경.  
- **저장**: 절대 평문/단순 해시 금지 → **Salted Slow Hash**(Argon2id 권장, 대안: scrypt/BCrypt/PBKDF2-HMAC-SHA256).  
- **Pepper**: 별도 저장(예: HSM/KMS)된 서버측 비밀을 추가해 대량 해시 테이블 공격을 추가로 어렵게.

#### 예: PBKDF2 기반 패스워드 저장/검증
```python
# password_store_pbkdf2.py — 표준 라이브러리만으로 안전 저장/검증
import os, hashlib, hmac, base64, secrets

def hash_password(pw: bytes, iters=200_000, dklen=32):
    salt = os.urandom(16)
    dk   = hashlib.pbkdf2_hmac('sha256', pw, salt, iters, dklen=dklen)
    return f"pbkdf2$sha256${iters}${base64.b64encode(salt).decode()}${base64.b64encode(dk).decode()}"

def verify_password(pw: bytes, rec: str) -> bool:
    _,_,iters,salt_b64,dk_b64 = rec.split('$')
    salt = base64.b64decode(salt_b64); dk=base64.b64decode(dk_b64)
    test = hashlib.pbkdf2_hmac('sha256', pw, salt, int(iters), dklen=len(dk))
    return hmac.compare_digest(test, dk)

rec = hash_password(b"S3cure phrase goes here!")
assert verify_password(b"S3cure phrase goes here!", rec)
```

---

### 16.5.3 2단계 인증: OTP, 푸시, FIDO2/WebAuthn
- **TOTP/HOTP**: 공유 비밀 + 시간/카운터를 기반으로 **일회성 코드** 생성.  
- **푸시 승인**: 등록 기기로 승인(피싱에 취약할 수 있음→번호 일치/확인 코드 병행).  
- **FIDO2/WebAuthn**: 공개키 기반, **피싱 저항**. 원격 서버는 **사이트 바운딩**된 공개키만 저장, 프라이빗키는 보안 요소(보안키/TPM/SE)에 보관.

#### 예: 순수 파이썬 TOTP 생성/검증
```python
# totp_demo.py — RFC 6238 (SHA-1/30s/6digits) 학습용 구현
import hmac, hashlib, time, struct, base64

def hotp(secret: bytes, counter: int, digits=6):
    h = hmac.new(secret, struct.pack(">Q", counter), hashlib.sha1).digest()
    off = h[-1] & 0x0f
    code = (struct.unpack(">I", h[off:off+4])[0] & 0x7fffffff) % (10**digits)
    return str(code).zfill(digits)

def totp(base32_secret: str, period=30):
    secret = base64.b32decode(base32_secret, casefold=True)
    return hotp(secret, int(time.time()) // period)

# 검증: 시간 드리프트 허용(±1 스텝)
def verify_totp(base32_secret: str, code: str, period=30):
    for w in (-1,0,1):
        if totp(base32_secret, period=period) == code or \
           hotp(base64.b32decode(base32_secret, casefold=True), int(time.time())//period + w) == code:
            return True
    return False
```

#### WebAuthn 흐름(요약)
1) **등록**: 서버가 챌린지 발급 → 클라이언트(브라우저)가 보안키로 **origin 바운드** 공개키 생성/서명 → 서버가 공개키 저장.  
2) **인증**: 새 챌린지 → 보안키가 사용자 존재(터치/생체)를 확인하고 서명 → 서버가 서명·카운터 검증.

---

### 16.5.4 세션/토큰: Cookie, JWT, Opaque
- **쿠키 기반 세션**(서버 저장): 단순·철회 쉬움.  
- **JWT**(서명된 클레임): 스테이트리스하지만 **철회/만료/권한 축소** 설계가 필요(짧은 TTL + **refresh 토큰**).  
- **보안 플래그**: `Secure`, `HttpOnly`, `SameSite=Strict/Lax`. CSRF 토큰 병행.

```python
# flask_cookie_flags.py — 안전 쿠키 설정
from flask import Flask, make_response
app = Flask(__name__)
@app.route("/login")
def login():
    resp = make_response("ok")
    resp.set_cookie("sid","opaque-id",secure=True,httponly=True,samesite="Strict")
    return resp
```

---

### 16.5.5 연동/연합: OAuth 2.1 + OIDC (PKCE)
- **OAuth 2.1** + **PKCE**(code verifier/challenge)로 **비밀 없는 퍼블릭 클라이언트** 보호.  
- **OIDC**: 사용자 정보(ID Token) 표준화(서명 검증 필수, `nonce` 체크).

```text
브라우저 → /authorize?client_id=...&code_challenge=...&nonce=... → 동의/로그인
        ← redirect_uri?code=...
백엔드 → /token (code + code_verifier) → id_token(서명), access_token 수신
```

---

### 16.5.6 계정 복구·락·리스크 기반 인증
- 복구: **메일 링크 + 디바이스/2FA 확인**. *보안질문 금지*.  
- 잠금: **폭력적 시도**에 대한 **지연/락/레이트 리밋**.  
- 리스크 스코어: 기기/ASN/위치/행동/시간대.  
  $$\text{score}=\sigma\!\left(\sum_i w_i x_i + b\right),\;\; \sigma(z)=\frac{1}{1+e^{-z}}$$  
  스코어가 임계 초과시 **step-up MFA** 요구.

---

## 16.6 Implementing Security Defenses

### 16.6.1 Defense in Depth(다층 방어)
1) **애플리케이션**: 입력 검증·권한 분리·비밀 관리·로깅.  
2) **OS/컨테이너**: 샌드박스(seccomp/AppArmor/SELinux), 최소 권한, 자동 업데이트.  
3) **네트워크**: 세그먼트·FW·TLS·WAF·DDoS 보호.  
4) **클라우드/서버리스**: IAM 최소화, 퍼블릭 노출 점검, KMS·암호화.  
5) **지속 관측**: 지표/로그/추적, 이상 탐지, IR 런북/훈련.

---

### 16.6.2 샌드박싱/격리

#### 리눅스: seccomp-BPF(허용 목록)
```bash
# Docker 예: 최소 syscalls만 허용(개념). 실제는 seccomp 프로파일 JSON 사용.
docker run --security-opt seccomp=/path/seccomp.json --pids-limit=128 --read-only -m 256m image
```

#### 리눅스: AppArmor/SELinux 프로필
```bash
# AppArmor 예(개념): /usr/bin/myapp 프로필 생성, 파일/네트워크 제한
#include <tunables/global>
/usr/bin/myapp {
  #include <abstractions/base>
  deny network raw,
  /var/myapp/** rw,
  /etc/** r,
  capability chown,
}
```

#### 윈도우: AppContainer(스토어 앱), WDAC/AppLocker
- **AppContainer**: 폴더/레지스트리/네트워크 능력 제한.  
- **WDAC**: **서명/정책 기반** 실행 허용 목록.  
- **AppLocker**: 경로/해시/퍼블리셔 규칙.

---

### 16.6.3 메모리 안전·컴파일러 완화
- GCC/Clang: `-fstack-protector-strong -D_FORTIFY_SOURCE=2 -fPIE -pie -Wl,-z,relro,-z,now`  
- MSVC: `/guard:cf`(CFI), `/Qspectre`, `/DYNAMICBASE`, `/NXCOMPAT`, `/HIGHENTROPYVA`

```bash
# 예: 린터/빌드 옵션(메모리 오버런 방지 강화)
CFLAGS="-O2 -fstack-protector-strong -D_FORTIFY_SOURCE=2 -fPIE"
LDFLAGS="-Wl,-z,relro,-z,now -pie"
```

---

### 16.6.4 비밀 관리·암호화
- **KMS/HSM** 사용(키는 코드/환경변수에 하드코딩 금지).  
- **Envelope 암호화**: DEK로 데이터 암호화 → DEK는 **KMS에 래핑**.  
- **회전**: KID 포함 → 새 키로 암호화, 구 키는 **복호만** 허용하는 과도기 운영.

```python
# envelope_demo.py — 데이터 키(DEK)와 마스터 키(MK) 분리(모의)
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os
def envelope_encrypt(mk_wrap, plaintext):
    dek = os.urandom(32)
    aes = AESGCM(dek); nonce=os.urandom(12)
    ct  = aes.encrypt(nonce, plaintext, b"aad")
    # mk_wrap 는 KMS API를 통해 DEK를 wrap한다고 가정
    wrapped_dek = mk_wrap(dek)
    return {"nonce":nonce,"ct":ct,"wdek":wrapped_dek}
```

---

### 16.6.5 로깅/모니터링/감사
- **표준 스키마**(request_id, user_id, action, subject, result, reason).  
- **PII/비밀 마스킹**.  
- **중앙 집계**(SIEM/ELK/OpenSearch), **무결성 보호**(서명/HMAC).  
- **Windows**: Event ID 4624/4625(로그온/실패), 4688(프로세스 생성), 4672(권한 할당), Sysmon(네트워크/이미지 로드).

```powershell
# Windows 감사 정책 확장(예)
auditpol /set /subcategory:"Logon" /success:enable /failure:enable
auditpol /set /subcategory:"Process Creation" /success:enable
```

---

### 16.6.6 네트워크 하드닝
- **방화벽**: 기본 거부, 필요한 포트만 열기.  
- **TLS 1.2/1.3** 강제, HSTS, 안전한 암호군.  
- **레이트 리미트**: 인증/쓰기 API에 적용.

```nginx
# TLS & 보안 헤더 예시
ssl_protocols TLSv1.2 TLSv1.3;
add_header Strict-Transport-Security "max-age=31536000" always;
add_header X-Content-Type-Options nosniff;
add_header Content-Security-Policy "default-src 'self'";
```

---

### 16.6.7 CI/CD & 공급망
- **코드 서명**(키 분리, 하드웨어 보호).  
- **SBOM** 생성(예: syft), **취약 스캔**(grype/Trivy).  
- **정적분석(SAST)**: Semgrep/CodeQL, **PR 게이트**.  
- **의존성 고정/서명 검증**(Sigstore/Cosign).  
- **재현 가능한 빌드**.

---

### 16.6.8 사고 대응(IR)·백업/복구
- **런북**: 감지→분류→격리→근본원인→교정→사후검토.  
- **백업**: 3-2-1 원칙, **복구 연습**(DR 드릴).  
- **법적/규제 보고** 라인 정리.

---

## 16.7 An Example: Windows 10

> Windows 10(및 동세대 Windows) 보안 아키텍처를 **로그온→토큰→격리→정책**의 흐름으로 살펴보고, 운영에서 근간이 되는 **Hello, Credential Guard, WDAC/AppLocker, Defender** 등을 실전 명령과 함께 다룬다.

### 16.7.1 인증·로그온 모델
- **Winlogon** + **Credential Providers**: 사용자 자격(패스워드/PIN/생체/스마트카드)을 수집.  
- **LSASS/LSA**: 인증 패키지(SSP/AP: **Kerberos**, **NTLM**, Negotiate) 호출, **토큰** 발급.  
- **SAM/AD**: 로컬 계정은 SAM, 도메인 계정은 AD/KDC와 교섭.  
- **토큰**: SID(사용자/그룹), 권한(privileges), 무결성 수준(IL), UAC 정보 포함.

#### 이벤트 관찰 포인트
- 4624(로그온 성공), 4625(실패), 4648(명시적 자격 사용), 4672(Special privileges).

---

### 16.7.2 Windows Hello & Hello for Business
- **PIN/생체는 디바이스 바운드**(TPM 보호) → 서버에 **공개키** 등록(AD/Azure AD).  
- **원격 피싱 저항**: 키는 장치 외부로 유출되지 않음, 인증은 **증명된 디바이스** 컨텍스트에서 수행.

---

### 16.7.3 Credential Guard & LSA Protection
- **VBS(가상화 기반 보안)**: Hyper-V로 격리된 **LSA ISO** 프로세스에 크리덴셜 보호.  
- **LSASS 보호(PPL)**: LSASS를 **Protected Process Light**로 실행, 메모리 주입/덤프 난이도↑.

```powershell
# Credential Guard/Device Guard 상태 확인
Get-CimInstance -ClassName Win32_DeviceGuard | Select-Object -ExpandProperty SecurityServicesConfigured
```

---

### 16.7.4 WDAC(Windows Defender Application Control) & AppLocker
- **WDAC**: 커널 모드까지 포함한 **실행 허용 목록**(서명/정책 기반), 드라이버 공격 표면 축소.  
- **AppLocker**: 사용자 공간 실행 제어(경로/해시/퍼블리셔).  
- **Stage**: Audit → Enforce 전환 권장.

```powershell
# AppLocker 감사 모드 활성(도메인 GPO 권장, 로컬 예시)
New-Item -Path HKLM:\SOFTWARE\Policies\Microsoft\Windows\SrpV2 -Force | Out-Null
# (정책 XML 작성 후) Import-AppLockerPolicy -Path .\Policy.xml -XML -Merge
Set-AppLockerPolicy -PolicyObject (Get-AppLockerPolicy -Local) -EnforcementMode AuditOnly
```

---

### 16.7.5 Defender, Exploit Guard, ASR, Controlled Folder Access
- **Microsoft Defender Antivirus**: 실시간 보호/클라우드 제공 보호.  
- **Exploit Guard(ASR Rules)**: 공격 표면 축소 규칙(Office 매크로·LOLBin 차단).  
- **Controlled Folder Access(CFA)**: 지정 폴더의 **비인가 변경** 차단(랜섬웨어 대응).

```powershell
# ASR 규칙 켜기(예: 자주 쓰는 규칙 일부)
$rules = @(
 "D4F940AB-401B-4EFC-AADC-AD5F3C50688A", # Office 앱의 자식 프로세스 생성 차단
 "BE9BA2D9-53EA-4CDC-84E5-9B1EEEE46550", # 실행 파일/스크립트/동적 콘텐츠형 이메일 첨부 파일 차단
 "75668C1F-73B5-4CF0-BB93-3ECF5CB7CC84"  # PsExec/WMIC 차단
)
foreach($r in $rules){ Add-MpPreference -AttackSurfaceReductionRules_Ids $r -AttackSurfaceReductionRules_Actions Enabled }

# Controlled Folder Access
Set-MpPreference -EnableControlledFolderAccess Enabled
Add-MpPreference -ControlledFolderAccessProtectedFolders "C:\Users\Public\Documents"
```

---

### 16.7.6 BitLocker & Secure Boot
- **TPM 연동**: 부트 체인 무결성 측정 → **자동 잠금 해제**.  
- **Secure Boot**: 서명된 부트로더만 실행.  
- **장치 분실·도난 위험** 완화.

```powershell
# BitLocker 상태
Get-BitLockerVolume | Format-Table MountPoint, VolumeStatus, ProtectionStatus, EncryptionMethod
```

---

### 16.7.7 접근 제어: ACL/SDDL/UAC/무결성 수준
- **ACL(ACE의 목록)**: 주체(SID)에 대한 허용/거부 항목.  
- **SDDL**: 보안 설명자를 문자열로 표현(감사/자동화에 유용).  
- **UAC**: 관리자 그룹 사용자의 **표준 토큰** 기본 사용 → 상승 시 동의.  
- **무결성 수준(IL)**: Low/Medium/High/System. IE/Edge 샌드박스는 **Low IL**.

```powershell
# SDDL 보기/변경(예시)
(Get-Acl "C:\Sensitive").Sddl
# 특정 사용자에게 읽기 권한 부여
$acl = Get-Acl "C:\Sensitive"
$rule = New-Object System.Security.AccessControl.FileSystemAccessRule("MYDOM\Alice","Read","Allow")
$acl.AddAccessRule($rule); Set-Acl "C:\Sensitive" $acl
```

---

### 16.7.8 DPAPI(데이터 보호) — 앱 비밀의 로컬 보호
- **ProtectedData.Protect**(C#) 또는 CryptProtectData(Win32)로 **사용자/머신 키** 기반 보호.

```csharp
// dpapi_demo.cs — .NET DPAPI (사용자 범위)로 비밀 보호
using System;
using System.Security.Cryptography;
using System.Text;

class P {
  static void Main() {
    var plain = Encoding.UTF8.GetBytes("top secret");
    var scope = DataProtectionScope.CurrentUser;
    var cipher = ProtectedData.Protect(plain, optionalEntropy:null, scope);
    var back  = ProtectedData.Unprotect(cipher, null, scope);
    Console.WriteLine(Encoding.UTF8.GetString(back));
  }
}
```

---

### 16.7.9 Windows 방화벽·IPsec·WFP
- **Windows Defender Firewall**: 프로필(Domain/Private/Public) 별 정책.  
- **IPsec**: 인증/암호화 정책.  
- **WFP(Windows Filtering Platform)**: 드라이버/필터 체인 기반 통제.

```powershell
# Inbound 규칙 추가(예: 포트 8443 허용, 도메인 프로필에서만)
New-NetFirewallRule -DisplayName "App 8443" -Direction Inbound -LocalPort 8443 -Protocol TCP -Action Allow -Profile Domain
```

---

### 16.7.10 실전 시나리오: “보안 워크스테이션” 최소 기준
1) **Windows Hello + TPM + BitLocker**(핀/생체 + 암호화).  
2) **Credential Guard + LSA 보호 + VBS/HVCI** 활성.  
3) **WDAC(AppLocker 대안)**: Publisher 기반 허용목록(감사→강제).  
4) **Defender + ASR + CFA** 활성, 클라우드 보호 On.  
5) **최소 권한**: 로컬 관리자 제거, LAPS(로컬 관리자 암호 관리) 도입.  
6) **패치 자동화**: Windows Update for Business/WSUS.  
7) **로깅/EDR**: Audit 확대, Sysmon 배포, Defender for Endpoint.  
8) **브라우저 하드닝**: SmartScreen, 다운로드 제어, 확장 프로그램 제한.  
9) **네트워크**: 방화벽 기본 거부, 프록시/SSL 검사 정책(필요시), VPN 항상 켜기.  
10) **USB**: 정책으로 저장장치 제한/감사.

---

### 16.7.11 Windows 이벤트/탐지 팁(요약)
- **자격 증명 도난 징후**: LSASS 접근 시도(처리: PPL/CG 활성), 4624 Type 10(원격), 4648 패턴, Sysmon ID 10(ProcessAccess).  
- **권한 상승**: 4672(특권), 4697(서비스 설치), 7045(서비스 생성).  
- **실행 통제 우회**: WDAC/AppLocker 차단 로그(Event Viewer → Applications and Services Logs → Microsoft → Windows).

---

## 부록: 인증·방어 종합 체크리스트

### (A) 인증 파이프라인
- [ ] 유출 패스워드 차단(사전/블랙리스트).  
- [ ] Argon2id/BCrypt/PBKDF2 + salt + **pepper(KMS)**.  
- [ ] TOTP/FIDO2(WebAuthn) 지원, 복구 코드는 **단 1회용**·암호화 저장.  
- [ ] 리스크 기반 step-up MFA(새 기기/위치/AS).  
- [ ] 세션 쿠키: Secure/HttpOnly/SameSite, CSRF 토큰.  
- [ ] OIDC(OAuth2.1+PKCE) 연동, 짧은 Access Token, Refresh는 바인딩/회전.

### (B) 애플리케이션·플랫폼 방어
- [ ] 안전 저장 패턴: **임시→fsync→rename→부모 fsync**.  
- [ ] 입력 검증·출력 인코딩, 템플릿 자동 이스케이프, ORM 파라미터 바인딩.  
- [ ] 비밀은 KMS/볼트, 키 회전/권한 최소화.  
- [ ] 샌드박스(seccomp/SELinux/AppArmor, AppContainer), 컨테이너 루트리스.  
- [ ] CI/CD: 코드서명, SBOM, 취약 스캔, PR 게이트(SAST/Secrets).  
- [ ] 로깅/감사/경보: 실패 로그인/권한 상승/실행 차단/네트워크 이상.

### (C) Windows 10
- [ ] Hello, BitLocker, Credential Guard, LSASS PPL, VBS/HVCI.  
- [ ] WDAC/AppLocker, Defender(ASR/CFA), SmartScreen.  
- [ ] 방화벽 기본 거부, 필요 포트만 허용.  
- [ ] Audit 정책 확대, Sysmon, EDR.  
- [ ] LAPS, 로컬 관리자 제거, 관리자 작업은 Just-In-Time/JEA.

---

## 한 줄 요약
- **16.5**: 인증은 **강한 저장(Argon2/PBKDF2)** + **피싱저항 MFA(FIDO2)** + **리스크 기반**으로 설계하라.  
- **16.6**: 방어는 **다층**으로. 샌드박스/메모리 완화/비밀관리/네트워크/공급망/로깅을 전 주기에 녹여라.  
- **16.7**: Windows 10은 **VBS/CG/WDAC/Defender**로 현대적 방어를 제공한다. **감사/정책/업데이트**가 실무 품질을 가른다.