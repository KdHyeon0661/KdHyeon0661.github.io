---
layout: post
title: C++ - 스마트 포인터 구현 (5)
date: 2024-09-27 19:20:23 +0900
category: Cpp
---
# C++ 스마트 포인터 구현 5/6 — **실전 적용, 벤치마크, 디버깅 & 검증 가이드**

> 목표: 1~4편에서 만든 `MyUniquePtr / MySharedPtr / MyWeakPtr / enable_shared_from_this` + 배열/커스텀 deleter/다형성 캐스팅을 **실전 코드에 투입**할 수 있도록,
> - (A) **적용 패턴**(이미지·네트워크·캐시·플러그인)
> - (B) **마이크로 벤치마크 하니스**
> - (C) **Sanitizer/디버거/리포터**로 검증
> - (D) **동시성 스트레스 테스트**
> - (E) **튜닝 & 마이그레이션 체크리스트**
> 를 끝까지 “동작 코드”로 정리한다.

---

## 0) 전제 & 빠른 리마인드

- 1편: `MyUniquePtr`(이동 전용, RAII)
- 2편: `MySharedPtr`(컨트롤 블록/카운팅/`my_make_shared`/**aliasing 생성자**)
- 3편: `MyWeakPtr` + `enable_shared_from_this`(자기참조 안전)
- 4편: **배열**(`T[]`), **커스텀 deleter**, **pointer_cast**, **불완전형**, **메모리 모델**

> 아래 코드는 같은 프로젝트/헤더로 누적 사용을 가정한다. 네임스페이스/경로만 맞추면 그대로 붙여넣어 동작한다.

---

## A) **실전 적용 패턴** — 바로 가져다 쓰는 스니펫

### A-1. 이미지 파이프라인: 공유 버퍼 + 배열 `T[]`

```cpp
// image_pipeline.hpp
#include <cstddef>
#include <algorithm>
#include <cstring>
#include "my_shared_array.hpp"   // 4편 구현: MySharedPtr<T[]>, my_make_shared_array

struct Image {
    int w, h, c; // width/height/channels
    MySharedPtr<unsigned char[]> pixels; // w*h*c
    std::size_t bytes() const { return std::size_t(w)*h*c; }

    static Image zeros(int w,int h,int c){
        Image im{w,h,c, my_make_shared_array<unsigned char>(std::size_t(w)*h*c)};
        std::memset(im.pixels.get(), 0, im.bytes());
        return im;
    }
};

// 포맷-A → 포맷-B 변환(예: 평균값)
inline Image to_gray(const Image& src) {
    Image dst = Image::zeros(src.w, src.h, 1);
    auto n = std::size_t(src.w)*src.h;
    for (std::size_t i=0;i<n;++i){
        const unsigned char* p = &src.pixels[i*src.c];
        unsigned v=0; for (int k=0;k<src.c;++k) v+=p[k];
        dst.pixels[i] = static_cast<unsigned char>(v/std::max(1,src.c));
    }
    return dst; // 복사 아님. 내부 버퍼는 공유/스택 이동
}
```

핵심:
- 대용량 버퍼는 `MySharedPtr<T[]>`로 **공유**하여 **복사 방지**.
- 스테이지 간 **소유권** 걱정 없이 파이프라인을 구성.

---

### A-2. 네트워크 세션: `enable_shared_from_this` + 콜백 람다 캡처

```cpp
// session.hpp
#include <functional>
#include <string>
#include "my_enable_shared_from_this.hpp"

// 가짜 비동기 API
inline void fake_async_read(std::function<void(std::string)> cb) {
    cb("PING"); // 실제 네트워크라면 이벤트 루프에서 호출됨
}

class Session : public MyEnableSharedFromThis<Session> {
public:
    void start() {
        auto self = this->shared_from_this(); // 안전한 자기참조
        fake_async_read([self](std::string s){
            self->on_read(std::move(s));
        });
    }
    void on_read(std::string s) {
        // 파싱/처리
        (void)s;
    }
};

// 사용
// auto s = my_make_shared<Session>();
// s->start(); // 콜백 동안 수명 보장
```

패턴:
- 콜백 람다에 `self`(shared_ptr)를 **캡처** → 콜백 완료 전 파괴 방지.
- 주기/타임아웃 관리가 필요하면, **타이머 콜백에도 동일 패턴**.

---

### A-3. 작업 큐/스레드풀: **누수 방지 캡처** — `weak_ptr` 우선

```cpp
// task_pool.hpp
#include <queue>
#include <mutex>
#include <thread>
#include <condition_variable>
#include "my_smart_ptr.hpp"

class TaskPool {
    std::mutex m_;
    std::condition_variable cv_;
    std::queue<std::function<void()>> q_;
    bool stop_=false; std::thread th_;
public:
    TaskPool() { th_=std::thread([this]{ loop(); }); }
    ~TaskPool(){ {std::lock_guard<std::mutex> lk(m_); stop_=true;} cv_.notify_all(); th_.join(); }

    void post(std::function<void()> f) {
        std::lock_guard<std::mutex> lk(m_); q_.push(std::move(f)); cv_.notify_one();
    }
private:
    void loop(){
        for(;;){
            std::function<void()> f;
            { std::unique_lock<std::mutex> lk(m_);
              cv_.wait(lk,[&]{return stop_||!q_.empty();});
              if (stop_ && q_.empty()) return;
              f=std::move(q_.front()); q_.pop();
            }
            f();
        }
    }
};

// 사용 측: weak_ptr로 캡처하여 종료/취소 시 자동 무시
struct Worker : MyEnableSharedFromThis<Worker> {
    void start(TaskPool& pool){
        MyWeakPtr<Worker> wk = this->weak_from_this();
        pool.post([wk]{
            if (auto sp = wk.lock()) {
                sp->tick();
            } // else: 이미 파괴 → 아무 것도 안 함
        });
    }
    void tick(){ /* do work */ }
};
```

포인트:
- **주기 작업/지연 작업**은 `weak_ptr`을 캡처 → 객체가 이미 파괴되면 **no-op**.
- **메시지 큐/스케줄러**에서 **오래 사는 람다**는 반드시 `weak_ptr` 추천.

---

### A-4. 캐시/레지스트리: **`map<Key, weak_ptr<Value>>`**

```cpp
#include <unordered_map>
#include <string>

template<class T>
class Cache {
    std::unordered_map<std::string, MyWeakPtr<T>> map_;
public:
    void put(std::string k, const MySharedPtr<T>& v){ map_[std::move(k)]=v; }
    MySharedPtr<T> get(const std::string& k) {
        auto it = map_.find(k);
        if (it==map_.end()) return {};
        return it->second.lock(); // 없으면 빈 포인터
    }
    void sweep_dead(){
        for (auto it=map_.begin(); it!=map_.end(); ){
            if (it->second.expired()) it = map_.erase(it);
            else ++it;
        }
    }
};
```

원칙:
- 캐시는 **소유하지 않는다**(강한 참조 X) → `weak_ptr`.
- 사용 시 `lock()`으로 **임시 소유**.

---

### A-5. 플러그인/서브오브젝트 공유: **aliasing 생성자**로 하위 컴포넌트만 노출

```cpp
// plugin.hpp
struct Plugin {
    struct API { int version=1; /*...*/ } api;
    // 내부 자원/상태...
};

// 전체 Plugin을 소유하는 shared_ptr
MySharedPtr<Plugin> plug = my_make_shared<Plugin>();

// 외부에는 API 서브오브젝트만 공유하되, 수명은 plug가 관리:
MySharedPtr<Plugin::API> api(plug, &plug->api); // aliasing 생성자

// 외부 사용자는 api만 받은 채로 plug의 수명을 함께 공유
```

이점:
- 외부에 **표면적 인터페이스만 노출**하면서,
- **원 소유(plug) 파괴 방지**.

---

## B) **마이크로 벤치마크 하니스**

> 목적: `MySharedPtr`/`MyUniquePtr`의 **생성·복사·파괴·배열** 비용을 파악하고,
> **`std::shared_ptr/unique_ptr` 대비 오버헤드** 감 잡기.

### B-1. 공용 유틸

```cpp
// bench_util.hpp
#include <chrono>
#include <cstdint>
#include <functional>
#include <iostream>

inline uint64_t ns() {
    using namespace std::chrono;
    return duration_cast<nanoseconds>(high_resolution_clock::now().time_since_epoch()).count();
}

inline void run_bench(const char* name, int rounds, const std::function<void()>& f){
    uint64_t t0=ns();
    for(int i=0;i<rounds;++i) f();
    uint64_t t1=ns();
    std::cout<<name<<": "<< (t1-t0)/double(rounds) <<" ns/op\n";
}
```

### B-2. 생성/파괴, 복사/리셋

```cpp
// bench_shared.cpp
#include "bench_util.hpp"
#include "my_smart_ptr.hpp"
#include <memory> // std::shared_ptr 대조

struct Obj { int x; };

int main(){
    constexpr int R=200000;

    run_bench("MyShared make/dtor", R, []{
        auto sp = my_make_shared<Obj>();
        (void)sp;
    });
    run_bench("STD shared make/dtor", R, []{
        auto sp = std::make_shared<Obj>();
        (void)sp;
    });

    auto baseM = my_make_shared<Obj>();
    run_bench("MyShared copy/reset", R, [baseM] mutable {
        auto c = baseM; // copy
        c.reset();
    });

    auto baseS = std::make_shared<Obj>();
    run_bench("STD shared copy/reset", R, [baseS] mutable {
        auto c = baseS; c.reset();
    });

    return 0;
}
```

### B-3. 배열/메모리 대역폭

```cpp
// bench_array.cpp
#include "bench_util.hpp"
#include "my_shared_array.hpp"
#include <vector>
#include <cstring>

int main(){
    constexpr std::size_t N=1<<20; // 1 MiB
    constexpr int R=512;

    run_bench("MyShared<T[]> alloc/free", R, []{
        auto buf = my_make_shared_array<unsigned char>(N);
    });

    run_bench("MyShared<T[]> memset", R, []{
        auto buf = my_make_shared_array<unsigned char>(N);
        std::memset(buf.get(), 0xAA, N);
    });

    return 0;
}
```

### B-4. 빌드 & 실행

```bash
# Clang/GCC (Linux/macOS)
clang++ -O3 -DNDEBUG bench_shared.cpp -o bench_shared
./bench_shared

clang++ -O3 -DNDEBUG bench_array.cpp -o bench_array
./bench_array

# MSVC (Developer Prompt)
cl /O2 /DNDEBUG bench_shared.cpp
bench_shared.exe
```

> **주의**  
> - 작은 ns/op 차이는 환경 변동/인라이닝/최적화에 크게 흔들린다.  
> - 성능 해석은 **상대적 경향**을 보되, 실제 워크로드(실서비스)로 **통합 벤치**를 만든 후 판단하라.

---

## C) **Sanitizer / 디버깅 / 리포터**

### C-1. Address/Leak/UB/Thread Sanitizer

```bash
# Clang/GCC
clang++ -g -fsanitize=address,undefined bench_shared.cpp -o aasan
./aasan

clang++ -g -fsanitize=thread stress.cpp -o tsan
./tsan

# MSVC (최근 버전)
cl /fsanitize=address /Zi bench_shared.cpp
```

- **ASan**: OOB, Use-After-Free 등
- **LSan**: 누수
- **UBSan**: 미정의 동작
- **TSan**: 데이터 레이스

> 우리의 컨트롤 블록/카운팅은 4편 메모리 모델을 준수한다.  
> TSan이 경고하면, **테스트 코드에서 공유 데이터 보호**를 점검하라(특히 전역 컨테이너).

---

### C-2. **디버그 트레이싱**: 컨트롤 블록 ID/타입/생존수

아래 매크로를 켜면 **생성/파괴 카운터**, **유출 목록**을 종료 시 덤프한다.

```cpp
// my_sp_debug.hpp
#pragma once
#include <atomic>
#include <mutex>
#include <unordered_map>
#include <iostream>
#include <typeinfo>
#include <cxxabi.h> // GCC/Clang: demangle. MSVC면 생략하거나 대체.

#define MYSP_DEBUG 1

namespace mysp_debug {
    struct Stat {
        std::atomic<long> live{0};
    };
    inline Stat& stat(){ static Stat s; return s; }

    struct Rec {
        const char* type;
        long id;
    };

    inline std::mutex& m(){ static std::mutex mm; return mm; }
    inline std::unordered_map<const void*, Rec>& tbl(){ static std::unordered_map<const void*,Rec> t; return t; }

    inline const char* demangle(const char* n){
    #if defined(__GNUG__)
        int st=0; return abi::__cxa_demangle(n,0,0,&st);
    #else
        return n;
    #endif
    }

    inline void on_create(const void* ctrl, const std::type_info& ti, long id){
        std::lock_guard<std::mutex> lk(m());
        tbl()[ctrl] = Rec{ demangle(ti.name()), id };
        stat().live.fetch_add(1);
    }
    inline void on_destroy(const void* ctrl){
        std::lock_guard<std::mutex> lk(m());
        tbl().erase(ctrl);
        stat().live.fetch_sub(1);
    }

    inline void report(){
        auto live = stat().live.load();
        if (live==0) { std::cerr<<"[MySP] No leaks.\n"; return; }
        std::cerr<<"[MySP] Leaks: "<<live<<"\n";
        for (auto& [k,v] : tbl()){
            std::cerr<<"  - id="<<v.id<<" type="<<(v.type?v.type:"?")<<"\n";
        }
    }
}
```

컨트롤 블록에 **ID 부여 & 훅 호출**:

```cpp
// control_block.hpp (발췌)
struct ControlBlockBase {
    std::atomic<long> shared_count{1};
    std::atomic<long> weak_count{0};
#if MYSP_DEBUG
    long id = 0;
    virtual const std::type_info& ti() const = 0;
#else
    virtual ~ControlBlockBase() = default;
#endif
    virtual void destroy_object() noexcept = 0;
    virtual void delete_this() noexcept { delete this; }
};

template<class T, class Deleter>
struct ControlBlockPtr : ControlBlockBase {
    T* p;
    Deleter d;
    ControlBlockPtr(T* pp, Deleter dd) : p(pp), d(std::move(dd)) {
    #if MYSP_DEBUG
        static std::atomic<long> seq{0};
        id = ++seq;
        mysp_debug::on_create(this, typeid(T), id);
    #endif
    }
    ~ControlBlockPtr(){
    #if MYSP_DEBUG
        mysp_debug::on_destroy(this);
    #endif
    }
#if MYSP_DEBUG
    const std::type_info& ti() const override { return typeid(T); }
#endif
    void destroy_object() noexcept override { if (p){ d(p); p=nullptr; } }
};
```

프로그램 종료 시 리포트:

```cpp
// main.cpp (테스트 실행 진입점에서)
#include "my_sp_debug.hpp"
#include <cstdlib>
int main(){
    std::atexit([]{ mysp_debug::report(); }); // 유출 리포트
    // ... 테스트/앱 실행 ...
}
```

---

## D) **동시성 스트레스 테스트**(부하/경합/무결성)

```cpp
// stress.cpp
#include <vector>
#include <thread>
#include <atomic>
#include <cassert>
#include "my_smart_ptr.hpp"

struct Blob { int v=0; };

int main(){
    constexpr int NTHREAD=8;
    constexpr int R=100000;

    auto root = my_make_shared<Blob>();
    std::atomic<int> ok{0};
    std::vector<std::thread> th;

    // 복사/리셋 경쟁
    for(int t=0;t<NTHREAD;++t){
        th.emplace_back([&]{
            for (int i=0;i<R;++i){
                MySharedPtr<Blob> c = root; // copy
                if (c) ++ok;
                if (i%7==0) c.reset();
            }
        });
    }
    for (auto& x:th) x.join();

    // 여전히 root는 살아 있어야 함
    assert(root.use_count()>=1);
    return 0;
}
```

**TSan**으로 돌려 데이터 레이스를 확인하라. 경합은 정상이나, **레이스 경고가 없어야** 바람직하다.

---

## E) **튜닝 & 마이그레이션 체크리스트**

### E-1. 선택 기준 정리

| 시나리오 | 권장 도구 |
|---|---|
| “한 소유자, 명확한 생명주기” | `MyUniquePtr<T>` |
| “여러 소유자, 공유 생존” | `MySharedPtr<T>` |
| “캐시/레지스트리, 소유하지 않음” | `MyWeakPtr<T>` |
| “대용량 버퍼/프레임” | `MySharedPtr<T[]>` |
| “파일/소켓/HANDLE/free” | `MySharedPtr<T>(커스텀 deleter)` |

### E-2. API 사용 규약

- **항상 `my_make_*`** 사용 (예외 안전/할당 1회 정책 적용 가능)
- **콜백/비동기 람다**:  
  - “반드시 살아야 함” → `shared_from_this()` 캡처  
  - “있으면 처리, 없어도 됨” → `weak_ptr` 캡처 + `lock()`
- **순환 참조**: **항상 한쪽을 `weak_ptr`로 끊는다.**
- **aliasing 생성자**: 서브오브젝트만 노출하면서 **원 소유 수명 공유**.
- **불완전형**: 팩토리는 **정의가 있는 TU**에서 `my_make_shared<T>()` 호출.

### E-3. 성능 팁

- **작은 객체의 폭주 생성/소멸** → 오브젝트 풀/전용 할당자(`std::pmr`) 고려
- `my_make_shared`가 컨트롤 블록/객체 **이중 할당**이라면 (우리 설계)  
  “단일 할당” 컨트롤 블록으로 고급 최적화 가능(6편 옵션)
- **배열 초기화 비용**: `new T[n]{}` vs `new T[n]` 차이를 워크로드에 맞춰 선택

### E-4. 마이그레이션

- `new/delete` 남아 있는 곳: **RAII로 포장** 후 교체
- `std::shared_ptr` ↔ `MySharedPtr` 혼용? 가능하지만, **명시적 변환기**가 없으므로 **경계 모듈에서만** 변환 래퍼를 쓰자(또는 일괄 치환).
- 테스트 우선: 6편의 테스트 스위트로 **회귀 체크** 후 일괄 변경

---

## F) **FAQ & 함정**

- Q: “`MySharedPtr<T>`로 `delete[]` 해도 되나요?”  
  A: **아니오**. 배열은 `MySharedPtr<T[]>` *혹은* 커스텀 deleter에서 `delete[]`를 지정해야 한다.

- Q: “왜 콜백에 `shared_ptr` 캡처가 누수를 부릅니까?”  
  A: 콜백 체인이 서로 `shared_ptr`로 **서로를 잡으면** 수명이 끊기지 않는다 → 한쪽을 `weak_ptr`.

- Q: “Sanitizer가 경고한다면?”  
  A: 대부분 **테스트 코드 레이스**나 **잘못된 소유 패턴**이다. 3~4편의 불변식을 대조하라.

---

## G) **작은 수식으로 보는 참조 카운팅 불변식**

- 공유 수: $$ S = \text{shared\_count} $$
- 약한 수: $$ W = \text{weak\_count} $$

파괴 규칙:
$$
S \to 0 \Rightarrow \text{객체 파괴} \\
S = 0 \land W = 0 \Rightarrow \text{컨트롤 블록 파괴}
$$

`weak.lock()` 성공 조건:
$$
S > 0 \ \text{일 때만} \ S \gets S+1
$$

CAS 루프:
$$
\text{while } S>0: \ \text{CAS}(S, S+1) \ \text{성공 시 획득}
$$

---

## H) **요약**

- **적용 패턴**: 이미지/네트워크/작업큐/캐시/플러그인 — “정해진 자리에 정해진 도구”.
- **벤치 하니스**: ns/op 감지로 **경향** 파악, 실제 워크로드로 **재확인**.
- **Sanitizer & 리포터**: 개발 단계에서 **즉시** 켜고, 종료 누수 리포트로 **맞고 가기**.
- **스트레스 테스트**: TSan에도 깔끔해야 “실전용”.
- **체크리스트**로 마이그레이션/튜닝을 마지막 점검.
