---
layout: post
title: 논리회로설계 - 부울 대수의 교환·결합·분배 · 드모르간 · 간략화 정리 · 곱셈 전개 및 인수화 · 부울식 보수화
date: 2025-08-28 16:25:23 +0900
category: 논리회로설계
---
# 부울 대수 — 교환·결합·분배 · 드모르간 · 간략화 정리 · 곱셈 전개/인수화 · 부울식 보수화 (개정판 2025)

## 0. 준비(용어·표기·목표)
- **리터럴(literal)**: \(A\) 또는 \(\overline{A}\)
- **항(term)**: 리터럴들의 AND 곱(예: \(A\overline{B}C\))
- **합(sum)**: 항들의 OR 합(예: \(A\overline{B}C+\overline{A}B\))
- **표기 약속**: \(+\) = OR, \(\cdot\) 또는 생략 = AND, \(\overline{A}\) 또는 \(A'\) = NOT \(A\), \(\oplus\) = XOR
- **진리값 집합**: \(\{0,1\}\)

> 목표: **법칙을 정의→직관→증명 스케치→실전 예제**로 정리하고,  
> **SOP(곱의 합)·POS(합의 곱)** 간 전환, **보수화**, **전개/인수화**를 한 번에 익힌다.  
> 연습과 자동검증을 위해 **Python 스니펫**을 제공한다.

---

## 1. 교환 법칙 (Commutative)
$$
A+B = B+A,\qquad AB = BA
$$

**직관**: OR/AND는 피연산자 순서에 무관.  
**예제**: \(F = XY + ZX = ZX + XY\) (동일 결과)  
> 참고: XOR도 교환적이다. \(A\oplus B = B\oplus A\).

---

## 2. 결합 법칙 (Associative)
$$
(A+B)+C = A+(B+C),\qquad (AB)C = A(BC)
$$

**직관**: 묶는 위치(괄호) 변경이 결과에 무관.  
**예제**: \(F=(A+B)+C=A+(B+C)\), \(G=(AB)C=A(BC)\)  
> 주의: **NOT**는 단항 연산이므로 결합법칙의 대상이 아니다.

---

## 3. 분배 법칙 (Distributive, 두 형태 모두 중요)
$$
A(B+C) = AB + AC \quad\text{(AND가 OR에 분배)}
$$
$$
A + BC = (A+B)(A+C) \quad\text{(OR가 AND에 분배)}
$$

### 3.1 증명 스케치(진리표로 확인)
| \(A\) | \(B\) | \(C\) | \(A(B+C)\) | \(AB+AC\) |
|---:|---:|---:|---:|---:|
|0|0|0|0|0|
|0|0|1|0|0|
|0|1|0|0|0|
|0|1|1|0|0|
|1|0|0|0|0|
|1|0|1|1|1|
|1|1|0|1|1|
|1|1|1|1|1|

동일하므로 등식 성립. 두 번째 형태도 같은 방식으로 검증 가능.

### 3.2 실전 사용
- **전개(expansion)**: \(A(B+C)\Rightarrow AB+AC\) (SOP로 펼치기)
- **인수화(factoring)**: \(A+BC\Rightarrow(A+B)(A+C)\) (POS로 묶기)

**예제(전개 후 흡수로 단순화)**
$$
(A+B)(A+\overline{B}) \xRightarrow{\text{전개}} A + B\overline{B} = A
$$

---

## 4. 드모르간 법칙 (De Morgan)
$$
\overline{A+B} = \overline{A}\ \overline{B},\qquad
\overline{AB} = \overline{A}+\overline{B}
$$

### 4.1 확장형(여러 변수)
$$
\overline{\;A_1 + A_2 + \cdots + A_n\;} = \overline{A_1}\ \overline{A_2}\ \cdots\ \overline{A_n}
$$
$$
\overline{\;A_1A_2\cdots A_n\;} = \overline{A_1}+\overline{A_2}+\cdots+\overline{A_n}
$$

### 4.2 예제(괄호 전체 반전이 핵심)
$$
\overline{A + BC} = \overline{A}\ \overline{BC} = \overline{A}\ (\overline{B}+\overline{C})
$$

---

## 5. 간략화 정리 (Simplification Theorems, 핵심 모음)

### 5.1 항등·지배·멱등·보수·이중부정
$$
A+0=A,\quad A\cdot1=A,\qquad A+1=1,\quad A\cdot0=0
$$
$$
A+A=A,\quad AA=A,\qquad A+\overline{A}=1,\quad A\overline{A}=0,\qquad \overline{\overline{A}}=A
$$

### 5.2 흡수(Absorption)
$$
A+AB=A,\qquad A(A+B)=A
$$
**예제**: \(A + A\overline{B} = A\)

### 5.3 인접성 소거(변수 제거)
$$
XY + \overline{X}Y = Y,\qquad XY + X\overline{Y} = X
$$
**증명**: \(XY + \overline{X}Y = (X+\overline{X})Y = 1\cdot Y = Y\).

### 5.4 합의(컨센서스) 정리
$$
AB + \overline{A}C + BC = AB + \overline{A}C
$$
- \(BC\)는 **합의(consensus) 항**으로 **제거 가능**.  
**예제**: \(F=AB + \overline{A}C + BC \Rightarrow F=AB + \overline{A}C\)

### 5.5 샤논 전개(Shannon Expansion)
$$
F = x\cdot F|_{x=1} + \overline{x}\cdot F|_{x=0}
$$
- 변수 \(x\) 기준으로 식을 재귀 분해(정규형 도출·검증에 편리).

---

## 6. 곱셈 전개와 인수화 (SOP/POS 오가며 정리)

### 6.1 전개(AND를 OR 위로 분배)
$$
A(B+C+D) = AB + AC + AD
$$
**예제**
$$
(A+B)(C+D) = AC + AD + BC + BD
$$

### 6.2 인수화(OR를 AND 위로 분배)
$$
A + BC = (A+B)(A+C)
$$
**예제**
$$
AB + AC + AD = A(B+C+D)
$$
$$
AB + \overline{A}C = (A+C)(\overline{A}+B)\quad\text{(대칭 인수화 연습)}
$$

### 6.3 1의 삽입으로 정규형 만들기
$$
X = X(Y+\overline{Y}) = XY + X\overline{Y}\quad(\text{SOP 확장})
$$
$$
X = X\cdot (Y+\overline{Y}) = (X+Y)(X+\overline{Y})\quad(\text{POS 변환})
$$

### 6.4 단계별 실전 예제
**예제 A — 인수화로 간단화**
$$
\begin{aligned}
F &= AB + AC + \overline{A}C \\
  &= A(B+C) + \overline{A}C \\
  &= AB + AC + \overline{A}C \\
  &= AB + C(A+\overline{A}) \\
  &= AB + C
\end{aligned}
$$

**예제 B — \((A+B)(A+C)\) 전개→흡수**
$$
(A+B)(A+C) = A + BC \quad(\text{전개 후 } A+AB=A,\ A+AC=A)
$$

**예제 C — 합의 정리 적용**
$$
F = AB + \overline{A}C + BC \;\Rightarrow\; F = AB + \overline{A}C
$$

---

## 7. 부울식 보수화 (Complementation)

### 7.1 드모르간으로 직접 보수 구하기
- **규칙**: **연산자 교환** \(+\leftrightarrow\cdot\), **리터럴 보수화**, **상수 교환** \(0\leftrightarrow 1\).

**예제 1**
$$
\begin{aligned}
F &= AB + \overline{C}\\
\overline{F} &= \overline{AB + \overline{C}}
= \overline{AB}\cdot \overline{\overline{C}}
= (\overline{A}+\overline{B})\cdot C
\end{aligned}
$$

**예제 2(괄호 주의)**
$$
F = A + BC \quad\Rightarrow\quad \overline{F} = \overline{A}\cdot(\overline{B}+\overline{C})
$$

### 7.2 정규형 관점(미터姆/맥스텀)
- \(F=\sum m(\mathcal{I})\) 이면 \(\overline{F}=\prod M(\mathcal{U}\setminus\mathcal{I})\)  
  (\(\mathcal{U}\): 모든 인덱스 집합)
- **예제**
$$
F(A,B,C)=\sum m(1,3,4,6)\Rightarrow
\overline{F}=\prod M(0,2,5,7)
$$

### 7.3 보수화 체크리스트
- [ ] 괄호 단위로 반전(부분만 반전 금지)  
- [ ] \(+\leftrightarrow\cdot\) 교환  
- [ ] 모든 리터럴에 보수 적용  
- [ ] 이중부정 \(\overline{\overline{A}}=A\) 정리

---

## 8. 종합 예제(혼합 적용)

**문제**
$$
F = (A+B)\overline{(A+\overline{C})} + A\overline{B}C
$$

**풀이**
1) 드모르간:
\[
\overline{(A+\overline{C})} = \overline{A}\cdot C
\]
2) 대입·인수화:
\[
F = (A+B)(\overline{A}C) + A\overline{B}C
  = C\big((A+B)\overline{A} + A\overline{B}\big)
\]
3) 전개:
\[
= C(A\overline{A} + B\overline{A} + A\overline{B})
= C(0 + B\overline{A} + A\overline{B})
\]
4) 보완쌍 관찰(대칭):
\[
B\overline{A} + A\overline{B} = A\oplus B
\]
**결론**:
\[
F = C(A\oplus B)
\]

> **회로 관점 팁**: 위 식을 게이트로 구현할 때, 입력 전이 시 정적 해저드가 우려되면 **합의항**으로 커버를 잇는 방법을 검토한다.

---

## 9. 실수 예방 포인트
- \(A + BC = (A+B)(A+C)\) **는 참**.  
  유사 패턴 \(AB + C = (A+C)(B+C)\) **도 성립**(대칭적 분배). 방향 혼동 주의.
- \(A + \overline{A}B = A + B\) **는 참**.  
  안전 경로: \((A+\overline{A})(A+B) = 1\cdot(A+B)=A+B\).
- 드모르간은 **괄호 전체** 보수: \(\overline{A+BC}\neq \overline{A}+ \overline{B}C\).
- 우선순위 기억: NOT ＞ AND ＞ OR. \(A + BC = A + (BC)\).

---

## 10. 연습 문제 (정답은 숨김)
1) \(F=(A+B)(\overline{A}+C)\) 를 가장 간단히 하라.  
2) \(F=AB+\overline{A}C+BC\) 에서 합의 정리로 불필요 항 제거하라.  
3) \(F=A+BC\) 의 보수 \(\overline{F}\) 를 드모르간으로 구하라.  
4) \(F=XY+\overline{X}Y+\overline{Y}Z\) 를 간략화하라.  
5) \(F=(X+Y)(X+\overline{Z}) + X\overline{Y}Z\) 를 단계별 전개/인수화로 최소화하라.

---

## 11. 자동 검증 스니펫 — 진리표·등가성·SOP/POS (Python)

> 소규모 변수(≤6)라면 **전수검사**로 등가성 검증이 빠르고 확실하다.

```python
from itertools import product

def eq(vars_, f, g):
    """f, g: bits(tuple)->{0,1}"""
    for bits in product([0,1], repeat=len(vars_)):
        if f(bits) != g(bits):
            return False, dict(zip(vars_, bits))
    return True, None

# 1. 분배: A + BC == (A+B)(A+C)
def lhs(bits):
    A,B,C = bits
    return int(A or (B and C))
def rhs(bits):
    A,B,C = bits
    return int((A or B) and (A or C))

ok, cex = eq(['A','B','C'], lhs, rhs)
print("A + BC == (A+B)(A+C)?", ok, "counterexample:", cex)

# 2. 합의 정리: AB + A' C + BC == AB + A' C
def F(bits):
    A,B,C = bits
    return int((A and B) or ((1-A) and C) or (B and C))
def G(bits):
    A,B,C = bits
    return int((A and B) or ((1-A) and C))

ok, cex = eq(['A','B','C'], F, G)
print("Consensus holds?", ok, "counterexample:", cex)

# 3. 보수화 예: F = A + BC, F' = A' (B' + C')
def F_(bits):
    A,B,C = bits
    return int(A or (B and C))
def Fc(bits):
    A,B,C = bits
    return int((1-A) and ((1-B) or (1-C)))

ok, cex = eq(['A','B','C'], lambda t: 1-F_(t), Fc)
print("Complement via De Morgan ok?", ok, "counterexample:", cex)
```

### 11.1 보너스: 진리표→SOP/POS 생성기

{% raw %}
```python
def truth_table(vars_, f):
    rows = []
    for bits in product([0,1], repeat=len(vars_)):
        rows.append((*bits, f(bits)))
    return rows

def minterm(vars_, bits):
    # LaTeX-친화 표기
    out = []
    for v,b in zip(vars_, bits):
        out.append(v if b==1 else f'\\overline{{{v}}}')
    return ''.join(out)

def maxterm(vars_, bits):
    # (A + B + C) 형태
    out = []
    for v,b in zip(vars_, bits):
        out.append(v if b==0 else f'\\overline{{{v}}}')
    return '(' + ' + '.join(out) + ')'

def sop_pos(vars_, f):
    tt = truth_table(vars_, f)
    sop_terms, pos_terms = [], []
    for bits in product([0,1], repeat=len(vars_)):
        val = f(bits)
        if val==1: sop_terms.append(minterm(vars_, bits))
        else:      pos_terms.append(maxterm(vars_, bits))
    return ' + '.join(sop_terms), ' '.join(pos_terms)

# 사용 예: F = A'B + A C'
def F(bits):
    A,B,C = bits
    return int(((1-A) and B) or (A and (1-C)))

sop, pos = sop_pos(['A','B','C'], F)
print("SOP:", sop)
print("POS:", pos)
```
{% endraw %}

---

## 12. 마무리 — 실전 요약 카드
- **교환·결합·분배**: 전개/인수화의 뼈대. 두 가지 **분배 형태** 모두 암기.
- **드모르간**: 보수화·NAND/NOR 변환의 핵심(괄호 단위 전역 반전!).
- **간략화 핵심**: 항등/지배/멱등/보수/흡수/인접성 소거/합의/샤논 전개.
- **정규형 전환**: \(X = X(Y+\overline{Y})\) (SOP), \(X = X\cdot(Y+\overline{Y})\) (POS).
- **보수화 3원칙**: \(+\leftrightarrow\cdot\), 리터럴 보수, \(0\leftrightarrow1\).
- **검증 습관**: 작은 식은 **전수 진리표**, 큰 식은 **K-맵/알고리즘(Q–M, BDD/SAT)**.