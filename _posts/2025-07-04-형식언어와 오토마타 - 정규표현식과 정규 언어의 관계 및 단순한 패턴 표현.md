---
layout: post
title: 형식언어와 오토마타 - 정규표현식과 정규 언어의 관계 및 단순한 패턴 표현
date: 2025-07-04 20:20:23 +0900
category: 형식언어와 오토마타
---
# 정규표현식과 정규 언어의 관계 및 단순한 패턴 표현

## 큰 그림 요약

- **정규표현식**은 유한 알파벳 \(\Sigma\) 위 문자열 집합(언어)을 기술하는 **형식**이다.
- **정규 언어**는 “**어떤 정규표현식으로** 표현될 수 있는 모든 언어”의 집합이다.
- 고전 정리(**Kleene의 정리**):
  \[
  \text{정규표현식} \;\Longleftrightarrow\; \varepsilon\text{-NFA} \;\Longleftrightarrow\; \text{NFA} \;\Longleftrightarrow\; \text{DFA}
  \]
  네 표현은 **표현력이 동등**(같은 언어류를 정확히 표현).

---

## 정규표현식이 정의하는 정규 언어

### 형식적 생성 규칙

알파벳 \(\Sigma\)에 대해 정규표현식 \(R\)은 다음으로 귀납 정의한다.

- **원자(Atoms)**
  - \(\emptyset\): 공집합(아무 문자열도 없음)
  - \(\varepsilon\): 빈 문자열만 포함하는 언어 \(\{\varepsilon\}\)
  - \(a \in \Sigma\): 단일 기호 언어 \(\{a\}\)
- **연산자(Operators)**
  - **합**: \(R_1 + R_2\) 또는 \(R_1 \mid R_2\)
    \(\;\Rightarrow\; L(R_1 \mid R_2) = L(R_1) \cup L(R_2)\)
  - **연접**: \(R_1R_2\)
    \(\;\Rightarrow\; L(R_1R_2)=\{xy \mid x\in L(R_1),\,y\in L(R_2)\}\)
  - **Kleene-별**: \(R^\*\)
    \(\;\Rightarrow\; L(R^\*)=\bigcup_{k\ge 0}L(R)^k\) (여기서 \(L(R)^0=\{\varepsilon\}\))

> 파생 기호(정규 의미 보존): \(R^+ = RR^\*\) (1회 이상), \(R?=R\mid\varepsilon\) (선택)

### 간단 예

| 정규표현식 \(R\) | \(L(R)\) (언어) |
|---|---|
| \(a\) | \(\{a\}\) |
| \(a^\*\) | \(\{\varepsilon,a,aa,aaa,\ldots\}\) |
| \((a+b)^\*\) | \(\Sigma=\{a,b\}\) 위 **모든 문자열** |
| \(a^\*b\) | 0개 이상의 \(a\) 뒤에 \(b\) |
| \((ab)^\*\) | “ab” 반복(\(\varepsilon,ab,abab,\ldots\)) |

> 결론: **모든 정규표현식은 정규 언어를 정의**하며, 해당 언어는 **항상 DFA로 인식 가능**하다.

---

## 정규 언어를 표현하는 정규표현식 (역방향)

### 정의

> **정규 언어**는 **어떤 정규표현식으로 표현될 수 있는 언어**이다.

다음 네 가지는 **동치**(Kleene 정리).

1) 정규표현식으로 표현 가능
2) DFA로 인식 가능
3) NFA/ε-NFA로 인식 가능
4) 정규 문법(Type-3, 우선형/좌선형)으로 생성 가능

\[
\text{RE} \iff \varepsilon\text{-NFA} \iff \text{NFA} \iff \text{DFA} \iff \text{정규 문법}
\]

### 예/비예

- **예(정규)**
  - “짝수 개의 0을 가지는 이진 문자열”
    \[
    (1^\*01^\*01^\*)^\*
    \]
  - “ab로 시작하는 모든 문자열”
    \[
    ab(a+b)^\*
    \]
- **비정규(정규표현식 불가)**
  - \(\{a^nb^n\mid n\ge 0\}\): 균형 필요(스택 필요 → PDA)
  - \(\{ww\mid w\in\Sigma^\*\}\): 복제 구조(유한 상태로 불가)

> 비정규성 증명: **펌핑 렘마**, **Myhill–Nerode** 등 사용.

---

## 단순 패턴 표현 레시피 (정규식 ↔ 오토마타 관점)

### 접두사/접미사/부분 문자열

| 설명 | 정규표현식 | DFA 관점 핵심 |
|---|---|---|
| \(“ab”\)로 시작 | \(ab(a+b)^\*\) | “ab” 소비 후 **모든 상태로 흘러가는 sink** |
| \(“ab”\)로 끝 | \((a+b)^\*ab\) | “마지막 두 글자 추적” 3상태 DFA |
| \(“ab”\) 포함 | \((a+b)^\*ab(a+b)^\*\) | 실패오토마타(kmp 유사) 3상태 |

### 길이/개수 제약

| 설명 | 정규표현식 | DFA 아이디어 |
|---|---|---|
| 길이 정확히 3(\(\Sigma=\{a,b\}\)) | \((a+b)(a+b)(a+b)\) | 4상태(길이 mod 추적) |
| 정확히 2개의 \(a\) | \(b^\*ab^\*ab^\*\) | “본 \(a\) 개수” 3상태 + sink |
| \(b\) 짝수 개 | \((a^\*ba^\*b)^\*a^\*\) | 2상태 패리티(짝/홀) |

### “시작/끝/중간” 혼합

| 설명 | 정규표현식(예) |
|---|---|
| “a로 시작, b로 끝” | \(a(a+b)^\*b\) |
| “a와 b만, 연속 ‘aaa’ 금지” | \((b|ab|aab)^\*(\varepsilon|a|aa)\) |
| “연속된 ‘11’ 미포함(이진)” | \((0|10)^\*(\varepsilon|1)\) |

> 위 레시피들은 **작은 DFA**로도 자연스럽게 설계 가능(상태 = “최근 본 패턴의 맥락”).

---

## 현실 세계 엔진 vs 이론(정규 언어) — 주의점

- PCRE/Python/Java 정규식은 **백레퍼런스** `\1`, **룩어라운드** 등 **비정규** 기능 포함 → 이론의 “정규 언어”를 넘어설 수 있음.
- 백트래킹 엔진은 `^(a+)+$` + `a^n b` 같은 입력에서 **지수적 시간**(Catastrophic Backtracking) 발생 가능.
- 본 글의 이론/코드는 **순수 정규 언어** 영역만 다룬다(ε-NFA/DFA 기반).

---

## 코드: 정규식 → ε-NFA → DFA → 수용 검사

> 교육용 **순수 정규 언어** 파이프라인(지원: `|` 합, **암묵적 연접**, `*` 별, `+` 플러스, `?` 옵션, 괄호).
> - ① 정규식 **파싱(Shunting-yard)** → ② **Thompson**로 ε-NFA 구성 → ③ ε-closure+부분집합으로 DFA 변환 → ④ **수용 여부 검사**.
> - 예제 패턴을 바로 테스트.

```python
from collections import defaultdict, deque
from dataclasses import dataclass
from typing import Dict, Set, Tuple, List, Optional, Union

Sym = str

# ---------- 1) 정규식 AST ----------

@dataclass(frozen=True)
class Epsilon: pass

@dataclass(frozen=True)
class Empty: pass

@dataclass(frozen=True)
class Symb:
    a: Sym

@dataclass(frozen=True)
class Alt:     # R1 | R2
    left: 'Regex'
    right: 'Regex'

@dataclass(frozen=True)
class Concat:  # R1 R2
    left: 'Regex'
    right: 'Regex'

@dataclass(frozen=True)
class Star:    # R*
    inner: 'Regex'

@dataclass(frozen=True)
class Plus:    # R+
    inner: 'Regex'

@dataclass(frozen=True)
class Opt:     # R?
    inner: 'Regex'

Regex = Union[Epsilon, Empty, Symb, Alt, Concat, Star, Plus, Opt]

# ---------- 2) 토큰화 & Shunting-yard ----------

def tokenize(pattern: str) -> List[str]:
    toks, i = [], 0
    while i < len(pattern):
        c = pattern[i]
        if c in {'|','(',')','*','+','?'}:
            toks.append(c); i += 1
        elif c == 'ε':
            toks.append('ε'); i += 1
        elif c == '∅':
            toks.append('∅'); i += 1
        elif c.isspace():
            i += 1
        else:
            toks.append(c); i += 1  # 단일 심볼 가정(데모)
    return toks

def insert_concat_tokens(tokens: List[str]) -> List[str]:
    out = []
    def is_atom(t): return t not in {'|',')','*','+','?'}
    for i, t in enumerate(tokens):
        out.append(t)
        if i+1 < len(tokens):
            t1, t2 = tokens[i], tokens[i+1]
            if ((t1 == ')' or is_atom(t1) or t1 in {'*','+','?'})
                and (t2 == '(' or is_atom(t2))):
                out.append('·')  # 명시적 연접 삽입
    return out

def parse(pattern: str) -> Regex:
    prec = {'*':3, '+':3, '?':3, '·':2, '|':1}
    toks = insert_concat_tokens(tokenize(pattern))
    output: List[Regex] = []
    ops: List[str] = []

    def apply(op):
        if op == '|':
            r = output.pop(); l = output.pop()
            output.append(Alt(l, r))
        elif op == '·':
            r = output.pop(); l = output.pop()
            output.append(Concat(l, r))
        elif op == '*':
            output.append(Star(output.pop()))
        elif op == '+':
            output.append(Plus(output.pop()))
        elif op == '?':
            output.append(Opt(output.pop()))

    for t in toks:
        if t == '(':
            ops.append(t)
        elif t == ')':
            while ops and ops[-1] != '(':
                apply(ops.pop())
            ops.pop()
        elif t in prec:
            while ops and ops[-1] in prec and prec[ops[-1]] >= prec[t]:
                apply(ops.pop())
            ops.append(t)
        else:
            if t == 'ε': output.append(Epsilon())
            elif t == '∅': output.append(Empty())
            else: output.append(Symb(t))
    while ops: apply(ops.pop())
    assert len(output) == 1
    return output[0]

# ---------- 3) Thompson: Regex -> ε-NFA ----------

class ENFA:
    def __init__(self, start: int, finals: Set[int], trans: Dict[Tuple[int, Sym], Set[int]]):
        self.start = start
        self.finals = set(finals)
        self.trans = defaultdict(set)
        for k, vs in trans.items(): self.trans[k] |= vs
        self.eps = 'ε'

    def eclosure(self, S: Set[int]) -> Set[int]:
        st, seen = list(S), set(S)
        while st:
            q = st.pop()
            for r in self.trans.get((q, self.eps), set()):
                if r not in seen:
                    seen.add(r); st.append(r)
        return seen

    def step(self, S: Set[int], a: Sym) -> Set[int]:
        out = set()
        for q in S:
            out |= self.trans.get((q, a), set())
        return out

class Thompson:
    def __init__(self):
        self._id = 0; self.eps = 'ε'
    def new(self) -> int: self._id += 1; return self._id

    def build(self, R: Regex) -> ENFA:
        s, F, T = self._build(R)
        return ENFA(s, F, T)

    def _build(self, R: Regex):
        if isinstance(R, Epsilon):
            s, f = self.new(), self.new()
            T = defaultdict(set); T[(s, self.eps)].add(f)
            return s, {f}, T
        if isinstance(R, Empty):
            s, f = self.new(), self.new()
            return s, set(), defaultdict(set)
        if isinstance(R, Symb):
            s, f = self.new(), self.new()
            T = defaultdict(set); T[(s, R.a)].add(f)
            return s, {f}, T
        if isinstance(R, Alt):
            s1,F1,T1 = self._build(R.left)
            s2,F2,T2 = self._build(R.right)
            s,f = self.new(), self.new()
            T = defaultdict(set, T1)
            for k,v in T2.items(): T[k] |= v
            T[(s, self.eps)].update({s1, s2})
            for x in F1: T[(x, self.eps)].add(f)
            for x in F2: T[(x, self.eps)].add(f)
            return s, {f}, T
        if isinstance(R, Concat):
            s1,F1,T1 = self._build(R.left)
            s2,F2,T2 = self._build(R.right)
            T = defaultdict(set, T1)
            for k,v in T2.items(): T[k] |= v
            for x in F1: T[(x, self.eps)].add(s2)
            return s1, F2, T
        if isinstance(R, Star):
            s1,F1,T1 = self._build(R.inner)
            s,f = self.new(), self.new()
            T = defaultdict(set, T1)
            T[(s, self.eps)].update({s1, f})
            for x in F1: T[(x, self.eps)].update({s1, f})
            return s, {f}, T
        if isinstance(R, Plus):
            # R+ = R R*
            return self._build(Concat(R.inner, Star(R.inner)))
        if isinstance(R, Opt):
            # R? = R | ε
            return self._build(Alt(R.inner, Epsilon()))
        raise ValueError("unknown node")

# ---------- 4) ε-NFA -> DFA ----------

class DFA:
    def __init__(self, start: int, finals: Set[int], trans: Dict[Tuple[int, Sym], int], sigma: Set[Sym]):
        self.start = start; self.finals = set(finals)
        self.trans = dict(trans); self.sigma = set(sigma)

    def accepts(self, w: str) -> bool:
        q = self.start
        for ch in w:
            if (q, ch) not in self.trans: return False
            q = self.trans[(q, ch)]
        return q in self.finals

def enfa_to_dfa(A: ENFA, sigma: Set[Sym]) -> DFA:
    S0 = frozenset(A.eclosure({A.start}))
    idx = {S0:0}; rev = [S0]
    finals = set()
    if any(s in A.finals for s in S0): finals.add(0)
    trans = {}
    Q = deque([S0])

    while Q:
        S = Q.popleft(); sid = idx[S]
        for a in sigma:
            nxt = set()
            for q in S:
                nxt |= A.trans.get((q, a), set())
            nxt = frozenset(A.eclosure(nxt))
            if not nxt: continue
            if nxt not in idx:
                idx[nxt] = len(rev); rev.append(nxt); Q.append(nxt)
                if any(x in A.finals for x in nxt): finals.add(idx[nxt])
            trans[(sid, a)] = idx[nxt]
    return DFA(0, finals, trans, sigma)

# ---------- 5) 데모 ----------

def demo():
    tests = [
        # (정규식, 알파벳 추정, 단어들, 기대)
        ("(a|b)*ab(a|b)*", {'a','b'}, ["", "ab", "baba", "aab", "ba"], [False, True, True, True, False]),
        ("(1*01*01*)*", {'0','1'}, ["", "0", "00", "010", "1010", "111"], [True, False, True, True, True, True]),
        ("(ab|ac)(a|b|c)*", {'a','b','c'}, ["ab", "ac", "aa", "ba", "acab"], [True, True, False, False, True]),
        ("(ab)*", {'a','b'}, ["", "ab", "aba", "abab"], [True, True, False, True]),
        ("a?b+", {'a','b'}, ["b", "ab", "a", "bb"], [True, True, False, True]),
    ]
    for pat, sigma, words, expect in tests:
        R = parse(pat)
        A = Thompson().build(R)
        D = enfa_to_dfa(A, sigma)
        got = [D.accepts(w) for w in words]
        print(f"[{pat}] ->", dict(zip(words, got)), "/ expected:", dict(zip(words, expect)))

if __name__ == "__main__":
    demo()
```

### 실행/해석 포인트

- **정규식 파서**는 `|`(합), `·`(암묵적 연접 자동 삽입), `* + ?`, `()`를 지원.
- **Thompson**은 각 연산자별 표준 ε-NFA 조립(결합성이 좋아 디버그가 수월).
- **ε-closure + subset**으로 **결정적 DFA** 생성 → `accepts`로 수용 여부 \(O(|w|)\) 판정.
- `tests`에는 본문 레시피 예시가 포함되어 **즉시 검증** 가능.

> 성능/생산용 고려: 상태 **최소화(Hopcroft)**, 큰 알파벳/복잡 패턴 최적화, 에러 처리/에스케이프 등 확장 필요.

---

## 추가 패턴 모음(실용/연습)

> 아래 6.1은 **이론적 정규식 표기**(\(+\)를 합, \(^*\)를 별로)이고, 6.2는 **현대 엔진 표기**(문자 클래스, 경계 등)를 함께 제시.

### 이론 표기(알파벳 \(\{a,b\}\))

| 설명 | 정규표현식 |
|---|---|
| `a`로 시작하고 `b`로 끝 | \(a(a+b)^\*b\) |
| `aa` 부분문자열 금지 | \((b|ab)^\*(\varepsilon|a)\) |
| `ab` 또는 `ba`만 반복 | \((ab+ba)^\*\) |
| `a` 개수가 3의 배수 | \(((b^\*ab^\*)(b^\*ab^\*)(b^\*ab^\*))^\*b^\*\) (또는 DFA 3상태로 설계 후 상태제거) |

### 현대 엔진(PCRE류) 표기 예

> 주의: 아래는 **정규 언어 범위를 넘어서는 기능**도 포함될 수 있지만, 보편적 실무 예시로 함께 제시.

| 설명 | 정규식(엔진) |
|---|---|
| 숫자만(1+ 자리) | `^[0-9]+$` |
| 영문자만 | `^[A-Za-z]+$` |
| 소문자/숫자/밑줄 시작, 3~16자 | `^[a-z][a-z0-9_]{2,15}$` |
| (단순한) 이메일 | `^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$` |
| “ab” 포함 | `^(?:[ab])*ab(?:[ab])*$` |

> 이메일 등은 **RFC 완전 정합**이 훨씬 복잡하며, 보통 **파서/라이브러리**를 권장.

---

## 왜/어떻게 “정규식 ↔ 오토마타”를 왕복할까?

- **설계 관점**: 정규식으로 대략적인 규칙을 잡고, 오토마타로 **오동작/코너케이스** 점검(특히 금지 패턴).
- **성능 관점**: 백트래킹형 엔진의 성능 리스크를 피해 **DFA 실행**(항상 선형 시간).
- **검증 관점**: 두 패턴 동치성 비교 → **DFA 최소화 후 동형성** 비교가 체계적.

---

## 비정규 패턴 주의 & 증명 스케치

- \(\{a^nb^n\}\), \(\{ww\}\) 등은 **정규식 불가**.
- **펌핑 렘마(regular)**: 충분히 긴 단어는 \(xyz\)로 분해되어 \(xy^iz\)가 항상 언어 안에 남아야 한다는 조건. 해당 조건을 위배시키는 증거 단어를 잡아 **모순**으로 비정규성을 보인다.
- **Myhill–Nerode**: 서로 구별 가능한 접미사가 무한히 많으면 **상태 수가 무한히 필요** → 정규 아님.

---

## 실전 체크리스트

- [ ] 패턴이 **정규 언어 내**인지(백레퍼런스/고급 룩어라운드 남용 지양)
- [ ] 긴 입력에서 **백트래킹 폭발** 가능성 없는지
- [ ] 필요한 경우 **오토마타화**(DFA)로 안전한 선형 시간 보장
- [ ] **테스트 케이스**: 수용/비수용 경계, 빈 문자열, 가장 짧은/긴 사례, 반복/중첩 등

---

## 마무리 정리

| 항목 | 핵심 한 줄 |
|---|---|
| 정규표현식 → 언어 | 모든 정규표현식은 **정규 언어**를 정의 |
| 언어 → 정규표현식 | 모든 정규 언어는 **어떤 정규표현식**으로 표현 가능 |
| 동치성 | RE ↔ (ε-)NFA ↔ DFA ↔ 정규 문법 (Kleene 정리) |
| 패턴 레시피 | 시작/끝/부분문자열/길이/개수/모듈러 제약 등은 **작은 DFA**로도 깔끔 |
| 주의 | 비정규 기능/백트래킹 폭발 → 오토마타 관점 검증 권장 |

> **핵심 메시지**: 정규표현식과 정규 언어는 **동전의 양면**이다.
> 이론(오토마타) 관점으로 설계/검증하면 **정확성·성능·가독성**이 모두 좋아진다.

---

## 추가 연습

1) \(\Sigma=\{0,1\}\): **연속 `11` 금지** 정규식/ε-NFA/DFA를 각각 구성하고, 본문 코드를 이용해 수용 검사.
2) \(\Sigma=\{a,b\}\): **`a` 수가 3의 배수** DFA 설계 → 상태 제거로 정규식 도출.
3) **`aba` 미포함** DFA 설계(3~4상태 실패오토마타), 임의 문자열에 대한 수용 여부를 코드로 검증.
