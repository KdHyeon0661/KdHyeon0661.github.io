---
layout: post
title: DB 심화 - 수동 PGA 메모리 관리 전환
date: 2025-11-24 16:25:23 +0900
category: DB 심화
---
# Oracle PGA Workarea 할당/해제 원리

## 0) 문제의 중심: Workarea는 “쿼리 성능의 심장”이다

Oracle에서 **Workarea(작업영역)** 는 다음 오퍼레이터가 쓰는 **PGA 기반 메모리 버퍼**입니다.

- **Sort Workarea**
  - `ORDER BY`, `GROUP BY`, `DISTINCT`
  - `WINDOW SORT`(분석 함수)
  - `SORT JOIN`(Merge Join 전 정렬)
- **Hash Workarea**
  - `HASH JOIN`(빌드/프로브)
  - `HASH GROUP BY`, `DISTINCT`의 해시 버전

Workarea의 크기와 라이프사이클이 바뀌면, 같은 SQL이라도

- **메모리 내(Optimal)** 로 끝나느냐
- **Temp 1회 스필(One-Pass)** 로 끝나느냐
- **Temp 다중 스필(Multi-Pass)** 로 폭주하느냐

가 갈리면서 실행 시간이 **수 배~수십 배** 달라집니다. 자동 모드에서는 이 Workarea 크기를 Oracle이 **전역 예산(PGA_AGGREGATE_TARGET)과 동시성**을 보고 매 순간 조정합니다.

---

## 1) AUTO vs MANUAL: “무엇이 바뀌는가”를 먼저 확실히 하자

### AUTO(Automatic PGA Memory Management)의 정의

- `WORKAREA_SIZE_POLICY=AUTO`일 때
- Oracle은 **PGA_AGGREGATE_TARGET 안에서 전역 상한(Global Memory Bound, GMB)** 을 계산하고,
  각 Sort/Hash Workarea에 **Grant**를 부여합니다.
- 이때 **SORT_AREA_SIZE, HASH_AREA_SIZE는 무시**됩니다.

즉, AUTO는 `PGA_AGGREGATE_TARGET`을 **전체 Workarea 예산**으로 두고,
그 순간의 **활성 세션/활성 Workarea/병렬도**를 반영해 크기를 **동적으로 배분**합니다.

### MANUAL의 정의

- `WORKAREA_SIZE_POLICY=MANUAL`로 바꾸면 자동 분배가 **절대 수행되지 않습니다.**
- Workarea 크기는 **SORT_AREA_SIZE(정렬), HASH_AREA_SIZE(해시)** 로 고정됩니다.
- 전환의 내부 조건은 “**PGA_AGGREGATE_TARGET=0**”과 동일한 효과입니다.

즉, MANUAL은 “**쿼리마다 Oracle이 계산하던 Workarea Grant를 끄고, 우리가 숫자를 박아버리는 모드**”입니다.

---

## 2) MANUAL 전환 시 “왜 위험한가” — 실제로 터지는 원인 구조

### 동시성 변화에 적응하지 못한다

AUTO는 GMB가 동시성에 따라 줄고 늘지만, MANUAL은 **상한이 못 줄어듭니다**.

- **피크(동시세션↑)** 에는
  $$\text{총 PGA 사용} \approx \sum \text{(세션별 Workarea 상한)}$$
  이 되며, 예산 초과 시 **ORA-4030/4036** 혹은 OS 스왑 → 전체 성능 붕괴로 이어집니다.
- **비피크(동시세션↓)** 에는
  상한이 과하게 크면 불필요한 PGA 점유가 지속됩니다.

### 병렬(PQ)에서는 “곱셈 폭주”가 일어난다

병렬 실행 슬레이브가 DOP=N일 때, Workarea도 N개가 **동시에** 생깁니다.

- Sort 2개(예: SMJ 전 양쪽 정렬) + DOP 8 + SORT_AREA_SIZE 256MB이면
  $$\text{정렬만} \approx 2 \times 8 \times 256\text{MB} = 4\text{GB}$$
  이게 **한 SQL 한 개**의 하한 추정치입니다(오버헤드 제외).

AUTO는 “전역 bound”에서 이를 스로틀하지만, MANUAL은 못 합니다.

### “큰 값이면 항상 좋은가?” — 아니다

MANUAL에서 SORT/HASH 영역을 크게 잡으면,
**개별 SQL은 빨라질 수 있지만**, 운영 전체는 훨씬 불안정해집니다.

- 어떤 시간대에 특정 배치가 5개 겹치면?
  → **PGA 폭주**가 한 번에 터집니다.
- RAC/멀티 인스턴스에서 인스턴스별 동시성 분포가 바뀌면?
  → 특정 인스턴스가 먼저 한계에 닿습니다.

### 그래서 Oracle이 AUTO를 기본값으로 강하게 권장한다

AUTO는 다음을 목표로 동작합니다.

1) **각 Workarea가 Optimal로 끝날 만큼 주되**
2) **동시성 피크에서 전체가 죽지 않게 상한을 자동으로 줄이는 것**

이 “전역 상한 기반 자동 조절”이 AUTO의 정수입니다.

---

## 3) PGA_AGGREGATE_TARGET “합리적 산정법” — 경험칙 + 관측 기반 보정

Oracle은 PGA 타깃을 **강제 할당치가 아니라 예산 목표**로 쓰고,
그 안에서 GMB를 계산합니다.

### 출발점(경험칙)

- **OLTP**
  - Workarea가 작고 짧으며 동시성이 높다
  - RAM의 **10~20%**에서 시작
- **DW/ETL/PQ 중심**
  - 대형 Sort/Hash가 많고 세션 수는 상대적으로 낮다
  - RAM의 **20~40%**에서 시작

여기서 중요한 전제:

- **SGA와 OS 여유의 균형**
  PGA를 키우면 OS 캐시/백그라운드/스왑 여유가 줄어 **전체 시스템 안정성이 깨집니다**.

### 관측 기반 보정 절차(정석)

Oracle이 공식적으로 제공하는 조언 뷰는
`V$PGA_TARGET_ADVICE`와 `V$PGA_TARGET_ADVICE_HISTOGRAM`입니다.

#### (1) 현재 상태 진단

```sql
-- PGA 전체 상태
SELECT name, value
FROM   v$pgastat
WHERE  name IN (
  'total PGA allocated',
  'total PGA inuse',
  'over allocation count',
  'global memory bound',
  'pga aggregate target',
  'aggregate PGA auto target'
);

-- Workarea 품질(현재 세션 기준)
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat# = ms.stat#
WHERE  sn.name IN (
  'workarea executions - optimal',
  'workarea executions - onepass',
  'workarea executions - multipass',
  'sorts (memory)',
  'sorts (disk)'
);

-- 타깃 조언
SELECT * FROM v$pga_target_advice ORDER BY pga_target_for_estimate;

SELECT *
FROM   v$pga_target_advice_histogram
ORDER  BY pga_target_for_estimate, category;
```

**해석 포인트**

- `workarea executions - onepass/multipass` 비율이 높다
  → Workarea가 GMB에 눌려 스필이 잦다는 뜻
  → PGA 타깃 상향 후보
- `over allocation count`가 자주 증가한다
  → 동시 Workarea가 예산을 빼앗아 급격한 축소/스필이 발생했다는 신호
  → 타깃 상향 또는 동시성/PQ 조절 후보
- `global memory bound`가 지나치게 낮다
  → “지금 이 순간 Workarea 경쟁이 심하다”는 뜻
  → 동시성/쿼리 구조/대상 Workarea 줄이기가 먼저일 수도 있음.

#### (2) +20~30% 증분 상향 A/B 테스트

```sql
ALTER SYSTEM SET pga_aggregate_target = 12G SCOPE=BOTH;
-- 동일 워크로드 재실행
```

- Advice 뷰는 “**최근 워크로드**를 기반으로 재계산”되고,
  인스턴스 재기동이나 타깃 변경 시 히스토그램이 리셋될 수 있습니다.
  → 반드시 **같은 조건**에서 반복 측정.

#### (3) 하드 캡(PGA_AGGREGATE_LIMIT) 설정

`PGA_AGGREGATE_LIMIT`는 전체 PGA의 **하드 상한**으로,
타깃을 넘는 폭주(스필 능력 초과, 비정상 메모리 누수)를 OS 레벨 전에 차단합니다.

```sql
ALTER SYSTEM SET pga_aggregate_target = 12G SCOPE=BOTH;
ALTER SYSTEM SET pga_aggregate_limit  = 24G SCOPE=BOTH;  -- 예: 타깃의 2배 근처
```

- 타깃은 “평균적 최적치”
- 리밋은 “최악 피크에서 DB를 살리는 안전장치”
라는 역할 분리가 핵심입니다.

---

## 4) Workarea 할당·증설·해제 라이프사이클 — AUTO vs MANUAL을 “실행 단계”로 분해

### 공통 라이프사이클 “뼈대”

1) **오퍼레이터 시작**
   - Optimizer가 예상한 `expected_optimal_size` / `expected_onepass_size`를 기준으로
     Workarea Grant(메모리 부여) 계산
2) **실행 중**
   - 메모리가 충분하면 **In-memory(Optimal)**
   - 부족하면 **Temp 스필(Onepass/Multipass)**
3) **오퍼레이터 종료**
   - Workarea 해제(반납)
4) **커서 종료/GC**
   - 커서/세션이 닫히며 남아있던 PGA 구조 완전 반납

### AUTO의 동작 핵심: “GMB 기반 Grant”

AUTO에서는 Oracle이 계산한 **Global Memory Bound(GMB)** 가
각 Workarea의 상한으로 작동합니다.

- Grant 산정 개념:
  $$\text{Grant} = \min(\text{ExpectedOptimalSize},\ \text{GMB})$$
- 동시성↑ → GMB↓ → Workarea가 줄어 **Onepass/Multi** 로 전환
- 동시성↓ → GMB↑ → 같은 SQL이라도 더 큰 Grant를 받아 Optimal 비율이 늘어남

즉, AUTO는 “**전체를 살리기 위한 자동 스로틀**”을 내장한 모드입니다.

### MANUAL의 동작 핵심: “고정 상한 + 디스크 스필”

MANUAL에서는

- Sort Workarea 상한 = SORT_AREA_SIZE
- Hash Workarea 상한 = HASH_AREA_SIZE
- 전역 상한/자동 축소가 없습니다.

따라서

- 상한이 작으면 **즉시 Onepass/Multi로 스필**
- 상한이 크면 **동시성 피크에서 총합 폭주**

라는 두 극단이 생깁니다.

---

## 5) Onepass/Multipass가 왜 무서운가 — 내부 메커니즘 관점

### Sort Workarea

- **Optimal**
  - 입력 전체를 Workarea에 담아 **한 번에 정렬**
  - Temp I/O 거의 없음
- **One-pass**
  - 메모리에서 정렬 Run을 만들고 Temp에 한 번 기록 → **1회 병합**
- **Multi-pass**
  - Run이 너무 많아져 병합을 여러 번 반복
  - Temp read/write가 **기하급수적으로 증가**

### Hash Workarea

- **Optimal**
  - Hash table이 메모리에 완전히 들어감
- **One-pass**
  - Hash partition을 Temp로 한 번 spill → 한 번 재읽기
- **Multi-pass**
  - partition도 메모리에 못 들어가 더 잘개 쪼개며 spill 반복
  - `direct path write temp` / `direct path read temp` 급증

AUTO에서 One/Multi가 늘어나는 이유는
활성 Workarea가 많아져 GMB가 줄었기 때문일 수 있습니다.
따라서 “PGA만 늘리자”보다 **동시성을 줄이거나 Workarea 개수 자체를 줄이는 SQL 구조 개선**이 더 효과적인 경우가 많습니다.

---

## 6) 실습: MANUAL vs AUTO를 “지표로 체감”하기

### 데이터 준비(대형 Sort 유발)

```sql
CREATE TABLE t_sort NOLOGGING AS
SELECT /*+ materialize */
       rownum AS id,
       TRUNC(DBMS_RANDOM.VALUE(1, 500000)) AS k,
       RPAD('x', 200, 'x') AS pad
FROM   dual CONNECT BY LEVEL <= 2000000;

EXEC DBMS_STATS.GATHER_TABLE_STATS(USER, 'T_SORT');

VAR lo NUMBER; VAR hi NUMBER;
EXEC :lo := 1000; EXEC :hi := 200000;

-- baseline snapshot
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN (
  'sorts (memory)',
  'sorts (disk)',
  'workarea executions - optimal',
  'workarea executions - onepass',
  'workarea executions - multipass'
);
```

### 케이스 A: MANUAL, 작은 SORT_AREA_SIZE

```sql
ALTER SYSTEM SET workarea_size_policy = MANUAL;
ALTER SESSION SET sort_area_size = 32M;

SELECT /*+ MONITOR */
       k, COUNT(*)
FROM   t_sort
WHERE  k BETWEEN :lo AND :hi
GROUP  BY k
ORDER  BY k;

-- after snapshot
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN (
  'sorts (memory)',
  'sorts (disk)',
  'workarea executions - optimal',
  'workarea executions - onepass',
  'workarea executions - multipass'
);
```

**관찰 기대**

- `sorts (disk)` 증가
- `onepass/multipass` 증가
  → “수동 상한이 부족해 Temp 스필이 생겼다”는 뜻

### 케이스 B: MANUAL, 큰 SORT_AREA_SIZE

```sql
ALTER SESSION SET sort_area_size = 512M;  -- 테스트 서버에서만

SELECT /*+ MONITOR */
       k, COUNT(*)
FROM   t_sort
WHERE  k BETWEEN :lo AND :hi
GROUP  BY k
ORDER  BY k;

SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN (
  'sorts (memory)',
  'sorts (disk)',
  'workarea executions - optimal',
  'workarea executions - onepass',
  'workarea executions - multipass'
);
```

**관찰 기대**

- `disk sort` 감소
  → 하지만 이 수치를 “운영에 그대로 적용”하면
    동시성 피크에서 위험해질 수 있다는 점이 핵심 교훈입니다.

### 케이스 C: AUTO, PGA 타깃 상향

```sql
ALTER SYSTEM SET workarea_size_policy = AUTO;
ALTER SYSTEM SET pga_aggregate_target = 8G;

SELECT /*+ MONITOR */
       k, COUNT(*)
FROM   t_sort
WHERE  k BETWEEN :lo AND :hi
GROUP  BY k
ORDER  BY k;

-- GMB와 품질 확인
SELECT name, value
FROM   v$pgastat
WHERE  name IN (
  'global memory bound',
  'pga aggregate target',
  'total PGA allocated'
);

SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN (
  'workarea executions - optimal',
  'workarea executions - onepass',
  'workarea executions - multipass',
  'sorts (memory)',
  'sorts (disk)'
);
```

**관찰 기대**

- `global memory bound` 상승
- Optimal 비율 증가
  → “PGA 예산이 늘어 Workarea Grant가 충분해졌다”는 뜻

---

## 7) 실전 관측: “지금 이 순간 어떤 Workarea가 얼마나 받는가”

### 실행 중 Workarea(Active)

```sql
SELECT sid,
       operation_type,
       policy,
       expected_optimal_size/1024/1024 AS exp_opt_mb,
       expected_onepass_size /1024/1024 AS exp_one_mb,
       last_memory_used       /1024/1024 AS last_mb,
       active_time/100 AS active_sec
FROM   v$sql_workarea_active
ORDER  BY active_time DESC;
```

- `policy`가 AUTO인지 MANUAL인지 즉시 확인
- `last_memory_used`가 기대치보다 작고 `exp_one_mb`가 크면
  → GMB에 눌려 스필이 곧 생길 가능성

### 누적 히스토리(Completed)

```sql
SELECT operation_type,
       optimal_executions,
       onepass_executions,
       multipasses
FROM   v$sql_workarea
ORDER  BY (optimal_executions + onepass_executions + multipasses) DESC;
```

- 특정 `operation_type`에서 multipass가 크면
  → **그 유형 오퍼레이터가 자주 메모리 부족에 빠진다**

---

## 8) MANUAL을 정말 써야 한다면 — 최소한의 가드레일

### 시스템 전역이 아니라 “세션/잡 단위”부터

```sql
ALTER SYSTEM SET workarea_size_policy = MANUAL SCOPE=MEMORY; -- 테스트
ALTER SESSION SET sort_area_size = 128M;
ALTER SESSION SET hash_area_size = 256M;
```

- 배치 잡 시작 시 세션에서만 키고, 끝나면 원복
- 전역 변경은 **가장 마지막 선택**

### 하드 캡 + Resource Manager 병행

- `PGA_AGGREGATE_LIMIT` 하드 상한 설정
- Consumer Group별 PGA/병렬도 제한
  (12cR2+는 **프로세스 PGA 상한**도 설정 가능)

### “최악 시나리오 총합”을 계산해 둔다

- 동시 배치 수
- 각 배치의 최대 DOP
- 동시에 켜지는 Workarea 개수
- SORT/HASH 상한

을 곱해 **OS 여유 메모리 안에 들어오는지** 확인하지 않으면
MANUAL은 항상 **시한폭탄**입니다.

---

## 9) AUTO에서도 성능이 나쁘다면, 진짜 해법은 “쿼리 구조 개선”에 있다

PGA를 늘리는 것만으로 해결되지 않는 대표 패턴:

1) **정렬 자체를 줄이기**
   - Top-N 쿼리는 `FETCH FIRST n ROWS ONLY` / `ROWNUM`으로 **STOPKEY** 유도
   - 인덱스 순서가 정렬키와 맞으면 Sort Workarea 자체가 사라짐
2) **해시빌드 폭을 줄이기**
   - 선행 필터/조인 순서/카디널리티 정합
3) **행폭 축소**
   - Sort/Hash 직전에는 **정렬키+PK만 투영** → 정렬 후 상세 조인
4) **동시 Workarea 개수 줄이기**
   - 불필요한 `GROUP BY` 중첩 제거
   - `DISTINCT`를 조인 전으로 끌어올 수 있는지 검토
5) **PQ DOP 조정**
   - **DOP를 2배 올려도 Workarea 경쟁이 4배가 되는 케이스**가 있다
     (Workarea 수 증가 + GMB 하락의 복합 효과)

AUTO는 “예산 안에서 최선”을 할 뿐,
예산을 뚫고 성능을 보장하지 않습니다.
따라서 성능 튜닝의 우선순위는

1) **쿼리 구조/플랜 개선**
2) **동시성/병렬도 정책**
3) **PGA 타깃 보정**

순서로 가는 게 정석입니다.

---

## 10) 결론 — 운영 원칙을 한 문장으로

- **기본값은 AUTO + 합리적인 PGA_AGGREGATE_TARGET**
  AUTO는 GMB를 통해 Workarea 크기를 동시성에 맞춰 자동 조절합니다.
- **MANUAL은 “특수 배치/튜닝 실험”에서만, 세션 단위로 제한적으로**
  자동 분배를 끄면 SORT/HASH 상한이 고정되며, 동시성·PQ에서 곱셈 폭주가 생깁니다.
- PGA 타깃은 **Advice 뷰와 One/Multipass 비율을 근거로 증분 조정**하고,
  하드 캡은 `PGA_AGGREGATE_LIMIT`로 잡아 폭주를 막습니다.
- 결국 성능은 “메모리 숫자”보다 **Workarea가 생기는 구조 자체를 줄이는 SQL/플랜 설계**에서 더 크게 좋아집니다.

---

## 부록) 원복 스크립트

```sql
ALTER SYSTEM RESET sort_area_size       SCOPE=BOTH;
ALTER SYSTEM RESET hash_area_size       SCOPE=BOTH;
ALTER SYSTEM SET   workarea_size_policy = AUTO SCOPE=BOTH;

-- 환경에 맞게 재설정
ALTER SYSTEM SET pga_aggregate_target = 8G  SCOPE=BOTH;
ALTER SYSTEM SET pga_aggregate_limit  = 16G SCOPE=BOTH;
```
