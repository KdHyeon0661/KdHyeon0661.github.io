---
layout: post
title: DB 심화 - 수동 PGA 메모리 관리 전환
date: 2025-11-24 16:25:23 +0900
category: DB 심화
---
# 할당/해제 원리

> 목표
> - **WORKAREA_SIZE_POLICY=MANUAL** 전환 시 **주의사항과 가드레일**을 정리
> - **PGA_AGGREGATE_TARGET**의 **합리적인 크기 산정법**(OLTP/DW, 동시성, PQ 고려)
> - **Sort/Hash 작업영역(Workarea)**의 **할당·증설·해제** 라이프사이클을 **수동/자동 모드** 관점에서 비교
> - 실습용 SQL로 **전/후 지표**(Optimal/Onepass/Multipass, sorts/disk 등) 관측

---

## 한눈 요약

- **수동 모드(MANUAL)**에서는 정렬·해시 등 **Workarea 크기**를 세션/시스템 파라미터(**SORT_AREA_SIZE, HASH_AREA_SIZE**)로 **고정**한다.
  → **동시성 변화나 부하 피크**에 **자동 적응하지 못하므로** 메모리 폭주(ORA-4030/4036) 또는 과도한 디스크 스필을 유발할 수 있다.
- **자동 모드(AUTO)**에서는 **PGA_AGGREGATE_TARGET**(또는 AMM 하의 MEMORY_TARGET) 안에서 **전역 상한(Global Memory Bound)**을 계산해 **Workarea별 적절한 크기**를 동적으로 부여한다.
  → 일반적으로 **AUTO 권장**.
- **PGA_AGGREGATE_TARGET 적정치**는 **워크로드·동시성**을 바탕으로 **관측값**(V$PGASTAT, V$PGA_TARGET_ADVICE, One/Multi 비율)으로 **결정**한다.
  대략 **OLTP: 서버 메모리의 10~20%**, **DW/ETL: 20~40%**에서 출발해 **증감 테스트**로 보정.
- **할당/해제 라이프사이클**:
  - **수동**: 실행계획의 각 Workarea가 **요청 즉시 고정 크기**까지 할당(필요 시 증설), **커서 종료/페치 완료** 시 해제.
  - **자동**: **전역 상한**을 고려해 **Grant**(부여) → 실행 중 동적 조정(피크 시 축소/Onepass 전환) → **오퍼레이터 종료 시 해제**.

---

# 수동 PGA 메모리 관리 전환 시 주의사항

### 전환 요건과 비권장 사유

- **전환 요건(예외적 상황)**
  - 특정 미션크리티컬 배치가 **예측 가능한 데이터량**으로 고정되어 있고,
    **최대한 디스크 스필 없이** 끝내려는 **튜닝 실험** 단계.
  - AUTO 알고리즘의 **전역 상한 조절**이 과하게 보수적이어서 **일시적으로** 수동치가 유리한 케이스.
- **비권장 사유(일반)**
  - **동시성 변동**에 적응 불가 → 피크 시간에 **총 PGA 초과** 위험.
  - **병렬(PQ)** 시 슬레이브 **각각이 동일한 Workarea**를 가져 **곱 절대값**으로 메모리 사용.
  - **운영 관리 복잡성**: 세션별/작업별 상이한 요구를 파라미터로 일일이 커버하기 어려움.

### 파라미터 상호작용과 우선순위

- `WORKAREA_SIZE_POLICY=MANUAL`로 전환 시, **Workarea 크기**는 주로 **SORT_AREA_SIZE**, **HASH_AREA_SIZE**가 결정.
- `PGA_AGGREGATE_TARGET`은 **자동 분배의 기준**이 되지 않지만, **전체 PGA 상한(PGA_AGGREGATE_LIMIT)**에 여전히 영향.
- **AMM**(`MEMORY_TARGET`) 사용 중에는 SGA/PGA를 동적으로 바꾸므로, **수동 Workarea라도** 전체 메모리 압박의 영향을 받음.

설정/확인 예:
```sql
-- 현재 설정 확인
SHOW PARAMETER workarea_size_policy;
SHOW PARAMETER pga_aggregate_target;
SHOW PARAMETER pga_aggregate_limit;
SHOW PARAMETER memory_target;
SHOW PARAMETER sga_target;

-- (테스트 환경에서만) 수동 전환
ALTER SYSTEM SET workarea_size_policy = MANUAL SCOPE=BOTH;

-- 세션/시스템 단위로 정렬/해시 작업영역 고정
ALTER SYSTEM  SET sort_area_size = 256M SCOPE=BOTH;   -- 예: 대형 정렬 배치용
ALTER SYSTEM  SET hash_area_size = 512M SCOPE=BOTH;
-- 또는 세션별 상이값 부여
ALTER SESSION SET sort_area_size = 64M;
ALTER SESSION SET hash_area_size = 128M;
```

> 가드레일
> - **테스트 → 배포** 순서, **롤백 플랜** 준비(파라미터 원복 스크립트).
> - **자원 관리자(DBMS_RESOURCE_MANAGER)**로 **PGA 사용량 제한** 정책(Consumer Group별) 고려.
> - **PDB 환경**(CDB): PDB 단위 파라미터와 CDB 전역 상한의 **중첩 제약** 확인.

### 폭증 리스크

- Degree of Parallelism = DOP가 **8**이고, 쿼리에 **정렬 2개**가 동시에 존재하면
  대략 **SORT_AREA_SIZE × 2 × 8** 만큼이 **추정치**(오버헤드 제외)로 필요할 수 있음.
- PQ 슬레이브 * N개 × Workarea 다중개(해시 조인·집계·윈도우·SMJ 정렬 등) = 총 PGA 폭증.
- **대응**: PQ **적정 DOP**(Adaptive DOP 비활성/제한), Consumer Group별 **PGA 한도**, 배치 **윈도우 분리**.

### 오류/장애 시나리오

- **ORA-4030**: PGA 메모리 부족(프로세스 메모리 할당 실패).
- **ORA-4036**: `PGA_AGGREGATE_LIMIT` 초과 시 발생(버전에 따라 메시지 상이).
- **스왑 스래싱**: OS 레벨에서 스왑이 급증하며 시스템 전체 성능 저하.
  → **총합 추정**(세션수×Workarea)으로 **최악 시나리오**도 감당 가능한지 **사전 계산**.

---

# PGA_AGGREGATE_TARGET 적정 크기 산정

> 비록 **수동 모드**를 사용할 수 있어도, 운영 환경 전체의 안정성과 평균 성능을 위해
> **AUTO 모드 + 합리적인 PGA 타깃**이 기본값이다. 아래 산정법은 **AUTO 전제** 기준(권장)이며,
> 수동을 쓰는 동안에도 **전체 PGA 예산/상한**을 합리적으로 잡기 위한 가이드로 유효하다.

### 출발점(경험칙)

- **OLTP**: 서버 RAM의 **10~20%**에서 시작
- **DW/ETL**(대형 정렬/해시가 흔함): **20~40%**에서 시작
- **단일 서버**에 **SGA**가 크다면, PGA는 지나치게 키우지 말고 **OS 잉여 메모리**를 반드시 남겨라.

### 관측 기반 보정(권장 절차)

1) **현재 상태 진단**
```sql
-- PGA 전체 통계
SELECT name, value
FROM   v$pgastat
WHERE  name IN ('total PGA allocated','total PGA inuse',
                'over allocation count','global memory bound',
                'pga aggregate target','pga aggregate limit');

-- Workarea 실행 품질
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN ('workarea executions - optimal',
                   'workarea executions - onepass',
                   'workarea executions - multipass',
                   'sorts (memory)','sorts (disk)');

-- 타깃 조언(히스토그램)
SELECT * FROM v$pga_target_advice ORDER BY pga_target_for_estimate;

SELECT * FROM v$pga_target_advice_histogram
ORDER BY pga_target_for_estimate, category;
```
- **Onepass/Multipass 비율**이 높으면 타깃 상향 후보.
- `over allocation count`>0 자주 관측 → 타깃 상향 또는 동시성/쿼리 패턴 조정.
- `global memory bound`가 지나치게 낮으면, 많은 세션이 쟁탈전 중인 신호.

2) **증분 상향**(+20~30%) → **동일 워크로드** 재실행 → 지표 비교
3) **한계점**: `PGA_AGGREGATE_LIMIT`은 **타깃의 1.5~2×** 수준으로 설정(환경에 따라 다름).

설정 예:
```sql
ALTER SYSTEM SET workarea_size_policy = AUTO;
ALTER SYSTEM SET pga_aggregate_target = 12G SCOPE=BOTH;
ALTER SYSTEM SET pga_aggregate_limit  = 24G SCOPE=BOTH;
```

> 주의
> - **AMM(MEMORY_TARGET)** 사용 시 PGA 타깃은 **강제치가 아닌 조언치**로 해석될 수 있다.
> - **NUMA/OS HugePage** 구성, **SGA_TARGET**과의 균형도 함께 본다.

---

# Sort Area(Workarea) **할당·증설·해제** 라이프사이클

### 공통 개념

- **Workarea**: SORT(ORDER BY, GROUP BY, DISTINCT, WINDOW SORT), HASH JOIN/GROUP BY 등 **메모리 작업영역**.
- **동시 Workarea**: 하나의 실행계획에서 **여러 Workarea가 동시에** 활성화될 수 있다(예: SMJ는 양쪽 정렬).
- **수명**: **오퍼레이터 시작** 시 할당 → **오퍼레이터 종료/커서 닫힘/페치 완료** 시 해제.

### 수동 모드(MANUAL)

- **초기 할당**: 오퍼레이터가 시작되면 **SORT_AREA_SIZE/HASH_AREA_SIZE**를 기준으로 **필요량만큼 즉시 확보**
  (OS로부터 단계적으로 가져오며, 내부적으로는 **Run 형성**과정에서 실사용이 증가).
- **증설/축소**: 수동에서는 **상한이 고정**되므로 AUTO처럼 **전역 상한에 따른 축소**는 없다.
  부족하면 **디스크 스필**(one/multi-pass).
- **해제**: 일반적으로 **해당 오퍼레이터(정렬/해시)가 끝나고 커서가 수거**되면 해제.
  오래 열린 커서/지연 페치 루프는 메모리 점유 시간을 **늘린다**.

### 자동 모드(AUTO)

- **Grant 산정**: `min(ExpectedOptimalSize, Global Memory Bound)`
- **실행 중 동적 조정**: Global Memory Bound 하락 시 **축소**, 반대면 **증액** 가능(버전·오퍼레이터별 제약).
- **해제**: 오퍼레이터 종료 시 반납.

### 관측 쿼리

```sql
-- 활성 Workarea
SELECT sid, operation_type, policy,
       expected_optimal_size/1024/1024 exp_opt_mb,
       expected_onepass_size /1024/1024 exp_one_mb,
       last_memory_used       /1024/1024 last_mb,
       active_time/100 active_sec
FROM   v$sql_workarea_active
ORDER  BY active_time DESC;

-- 완료된 Workarea (히스토리)
SELECT operation_type,
       optimal_executions, onepass_executions, multipasses
FROM   v$sql_workarea
ORDER  BY (optimal_executions + onepass_executions + multipasses) DESC;

-- 프로세스별 PGA 분해
SELECT pid, program, category, allocated/1024/1024 alloc_mb, used/1024/1024 used_mb
FROM   v$process_memory
ORDER  BY allocated DESC;
```

---

# 실습: 수동 vs 자동, Sort Area 영향 비교

## 데이터 준비(대형 정렬 유발 표본)

```sql
CREATE TABLE t_sort AS
SELECT rownum AS id,
       TRUNC(DBMS_RANDOM.VALUE(1, 500000)) AS k,
       RPAD('x', 200, 'x') AS pad
FROM   dual CONNECT BY LEVEL <= 2000000;

EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'T_SORT');

-- 정렬 유도 쿼리(메모리/디스크 소트 관측용)
VAR lo NUMBER; VAR hi NUMBER;
EXEC :lo := 1000;  EXEC :hi := 200000;

-- 관측 지표 초기 스냅샷
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN ('sorts (memory)','sorts (disk)',
                   'workarea executions - optimal',
                   'workarea executions - onepass',
                   'workarea executions - multipass');
```

## 케이스 A: **수동**(SORT_AREA_SIZE 작게 → 디스크 스필 유발)

```sql
ALTER SYSTEM SET workarea_size_policy = MANUAL;
ALTER SESSION SET sort_area_size = 32M;   -- 작게

SELECT /*+ MONITOR */
       k, COUNT(*)
FROM   t_sort
WHERE  k BETWEEN :lo AND :hi
GROUP  BY k
ORDER  BY k;

-- 결과 관측
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN ('sorts (memory)','sorts (disk)',
                   'workarea executions - optimal',
                   'workarea executions - onepass',
                   'workarea executions - multipass');
```
**기대**: `sorts (disk)` 및 `workarea executions - onepass/multipass` 증가.

## 케이스 B: **수동**(SORT_AREA_SIZE 크게 → 메모리 내 정렬)

```sql
ALTER SESSION SET sort_area_size = 512M;  -- 크게 (테스트 서버에서만!)

SELECT /*+ MONITOR */
       k, COUNT(*)
FROM   t_sort
WHERE  k BETWEEN :lo AND :hi
GROUP  BY k
ORDER  BY k;

-- 관측(디스크 스필 감소/Zero 기대)
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN ('sorts (memory)','sorts (disk)',
                   'workarea executions - optimal',
                   'workarea executions - onepass',
                   'workarea executions - multipass');
```
**주의**: 동시 세션×쿼리 수를 고려하지 않은 **과도한 SORT_AREA_SIZE**는 운영에서 **매우 위험**.

## 케이스 C: **자동**(PGA 타깃 상향 → 전역 상한 상승)

```sql
ALTER SYSTEM SET workarea_size_policy = AUTO;
ALTER SYSTEM SET pga_aggregate_target = 8G;   -- 기존 대비 상향

SELECT /*+ MONITOR */
       k, COUNT(*)
FROM   t_sort
WHERE  k BETWEEN :lo AND :hi
GROUP  BY k
ORDER  BY k;

-- 전역 상한 및 실행 품질 확인
SELECT name, value
FROM   v$pgastat
WHERE  name IN ('global memory bound','pga aggregate target','total PGA allocated');

SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN ('workarea executions - optimal',
                   'workarea executions - onepass',
                   'workarea executions - multipass',
                   'sorts (memory)','sorts (disk)');
```
**기대**: `global memory bound` 상승 → **Optimal 비율 증가**.

---

# 운영 가이드 — 수동 모드 안전장치 & 패턴

### 가드레일(필수)

- **PGA 상한**: `PGA_AGGREGATE_LIMIT`를 **현실적인 수준**으로(타깃의 1.5~2×).
- **Resource Manager**: Consumer Group별 **PGA 한도/병렬도 제한**.
- **PQ 관리**: DOP 상한, **쿼리 등급**별 PQ 금지/허용 정책.

### 쿼리·플랜 레벨의 메모리 절약

- **정렬 회피**: 인덱스로 `ORDER BY`/`GROUP BY` 대체, **Top-N STOPKEY**, **정렬 후 가공** 패턴.
- **해시 스필 완화**: 카디널리티 정확화(통계/히스토그램), 조인 순서/방식 조정.
- **윈도우 함수**: 입력을 PARTITION/ORDER 순서에 가깝게 공급(필요시 FBI/가상컬럼).
- **행폭 축소**: 정렬 전 **정렬키+식별자만 투영** → 정렬 후 상세 조인.

### 점검 체크리스트

- [ ] **최악 동시성 × Workarea 개수 × SORT/HASH 사이즈** 총합이 **OS 여유 메모리** 안에 드는가?
- [ ] **PQ 쿼리**가 많은가? DOP 상한/쿼리 등급 정책을 적용했는가?
- [ ] **Onepass/Multi** 비율이 높은 SQL은 **쿼리 구조 개편**이 먼저인가, **메모리 증설**이 먼저인가?
- [ ] **장시간 열린 커서/지연 페치**로 Workarea 점유가 길어지지 않는가?
- [ ] **롤백 플랜**(AUTO 복귀)과 **스모크 테스트** 절차가 준비되어 있는가?

---

# “정렬 영역 할당/해제”를 체감하는 소형 예제

## 작은 데이터에서의 라이프사이클

```sql
ALTER SYSTEM SET workarea_size_policy = MANUAL;
ALTER SESSION SET sort_area_size = 8M;

-- 1) 첫 실행(메모리 정렬 기대)
SELECT * FROM (
  SELECT /*+ NO_MERGE */ k, COUNT(*) c
  FROM   t_sort
  WHERE  k BETWEEN 100 AND 10000
  GROUP  BY k
) x
ORDER BY x.c DESC;

-- 실행 중 V$SQL_WORKAREA_ACTIVE로 last_memory_used 확인
SELECT operation_type,
       expected_optimal_size/1024/1024 exp_opt_mb,
       last_memory_used/1024/1024        last_mb
FROM   v$sql_workarea_active;

-- 커서/페치 종료 후 동일 쿼리 재수행 → 다시 할당되는지 V$PROCESS_MEMORY로 비교
```

## 큰 데이터 + 지연 페치(해제 지연 사례)

```sql
-- 일부 클라이언트/프레임워크는 페치를 매우 느리게(페이지네이션 방식) 진행
-- 수동 모드에선 정렬 Workarea가 오래 유지될 수 있음 → 동시성에 악영향
ALTER SESSION SET sort_area_size = 256M;

-- 페치 루프(의사 코드)
-- while (fetch 100 rows) sleep(500ms) ...  → 정렬 Workarea 오래 점유
-- 해결: Top-N 후 사후 가공, 또는 AUTO로 전환해 전역 상한 자동 축소 기대
```

---

# FAQ

**Q1. MANUAL에서 `SORT_AREA_RETAINED_SIZE`를 함께 써야 하나요?**
A1. 현대 버전에서는 기본적으로 권장하지 않습니다(모드/버전에 따라 무시되거나 비직관적).
    일반적으로 **SORT_AREA_SIZE**만 관리하고, **장시간 커서** 패턴 자체를 개선하세요.

**Q2. MANUAL일 때 `PGA_AGGREGATE_TARGET`은 완전히 무시되나요?**
A2. **Workarea 자동 분배**에는 **영향하지 않지만**, **PGA 전체 상한/오버할로케이션 보호**(특히 `PGA_AGGREGATE_LIMIT`) 맥락에선 여전히 **중요 지표**입니다.

**Q3. 특정 세션만 크게 주고 싶다면?**
A3. 세션 단위 `ALTER SESSION SET sort_area_size=...`/`hash_area_size=...` 가능.
    단, **총합이 OS 메모리 한계**를 넘지 않도록 **세션 수 제한/스케줄링**이 필수.

**Q4. AUTO로는 안 되고 MANUAL로는 되는 사례가 있나요?**
A4. 일부 배치에서 **GMB(전역 상한)**이 과도하게 낮아지는 피크 구간에 **일시적으로 MANUAL이 유리**할 수 있습니다.
    그러나 **근본 해결**은 대개 **동시성 제어, PQ DOP 조정, 쿼리 재작성**입니다.

---

# 운영 런북(요약)

1. **기본값은 AUTO**. MANUAL은 **테스트/특수 배치**에 한정.
2. **MANUAL 전환 시**:
   - 세션/잡 단위 적용부터 시작(시스템 전역 X).
   - **최악 합계 메모리**를 산정(세션수×PQ×Workarea×사이즈).
   - `PGA_AGGREGATE_LIMIT`/Resource Manager로 **하드 가드레일**.
3. **PGA 타깃 산정**:
   - OLTP 10~20%, DW 20~40%로 시작 → **관측 기반 보정**.
   - `V$PGA_TARGET_ADVICE`, `workarea executions - *` 지표로 **효과 확인**.
4. **Sort Area 라이프사이클**:
   - **오퍼레이터 시작 시 할당 → 종료/커서 닫힘 시 해제**.
   - 수동은 **고정 상한**, 자동은 **전역 상한 기반 동적 조정**.
5. **쿼리/플랜 개선이 우선**: 정렬 회피(인덱스/Top-N), 해시 스필 최소화(정확한 카디널리티, 조인 순서).

---

## 부록: 설정 원복 스크립트

```sql
-- AUTO 복귀(권장 기본)
ALTER SYSTEM RESET sort_area_size       SCOPE=BOTH;
ALTER SYSTEM RESET hash_area_size       SCOPE=BOTH;
ALTER SYSTEM SET   workarea_size_policy = AUTO SCOPE=BOTH;

-- 예산/상한 재정의(환경별 값)
ALTER SYSTEM SET pga_aggregate_target = 8G  SCOPE=BOTH;
ALTER SYSTEM SET pga_aggregate_limit  = 16G SCOPE=BOTH;
```

> 결론
> **수동 PGA 관리**는 **날 선 도구**다. **성능 실험/특수 배치**에는 유용할 수 있지만,
> **일반 운영**에서는 **AUTO + 합리적 PGA 타깃**과 **쿼리/플랜 구조적 개선**이
> **성능·안정성·운영 편의성**을 모두 충족하는 **정석 해법**이다.
