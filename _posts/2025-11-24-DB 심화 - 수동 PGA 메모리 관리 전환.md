---
layout: post
title: DB 심화 - 수동 PGA 메모리 관리 전환
date: 2025-11-24 16:25:23 +0900
category: DB 심화
---
# Oracle PGA Workarea 할당/해제 원리와 운영 전략

## 서론: PGA Workarea의 중요성

Oracle 데이터베이스에서 PGA(Program Global Area) Workarea(작업 영역)는 정렬(Sort) 및 해시(Hash) 연산을 위한 핵심 메모리 영역입니다. 이 영역의 효율적인 운영은 전체 시스템 성능을 결정하는 중요한 요소로, Workarea의 크기와 라이프사이클 관리가 쿼리 실행 시간을 수 배에서 수십 배까지 좌우할 수 있습니다.

Workarea는 다음 주요 연산에 사용됩니다:
- **정렬 작업**: `ORDER BY`, `GROUP BY`, `DISTINCT`, 윈도우 함수 정렬(`WINDOW SORT`), 병합 조인 전 정렬(`SORT JOIN`)
- **해시 작업**: `HASH JOIN`(빌드/프로브 테이블), `HASH GROUP BY`

---

## Workarea 관리 모드: AUTO vs MANUAL

### 자동 PGA 메모리 관리(AUTO) 모드

`WORKAREA_SIZE_POLICY=AUTO`로 설정하면 Oracle은 전역 메모리 예산(`PGA_AGGREGATE_TARGET`)을 기반으로 동적으로 Workarea 크기를 조정합니다.

**AUTO 모드의 핵심 메커니즘:**
1. Oracle은 시스템 전체의 PGA 사용량과 동시성을 모니터링합니다.
2. **Global Memory Bound(GMB)** 를 실시간으로 계산하여 각 Workarea에 적절한 메모리를 할당합니다.
3. 동시 세션이 증가하면 GMB가 자동으로 감소하여 전체 시스템의 안정성을 유지합니다.
4. `SORT_AREA_SIZE` 및 `HASH_AREA_SIZE` 파라미터는 무시됩니다.

**장점:**
- 동적 조정으로 시스템 부하 변화에 유연하게 대응
- 과도한 메모리 사용으로 인한 시스템 장애 위험 감소
- 전역 최적화를 통한 효율적인 자원 분배

### 수동 관리(MANUAL) 모드

`WORKAREA_SIZE_POLICY=MANUAL`로 설정하면 Workarea 크기가 `SORT_AREA_SIZE`와 `HASH_AREA_SIZE` 파라미터 값으로 고정됩니다.

**MANUAL 모드의 주요 위험 요소:**

1. **동시성 변화 적응 불가**
   - 피크 시간대: 각 세션이 고정된 큰 메모리를 요구하여 총 PGA 사용량이 급증, ORA-4030/4036 오류 또는 시스템 장애 발생 가능
   - 비피크 시간대: 필요 이상의 메모리를 점유하여 자원 낭비

2. **병렬 실행 시 메모리 폭주**
   - 병렬도(DOP)가 N일 때 Workarea도 N배로 증가
   - 예: 정렬 2개 + DOP 8 + SORT_AREA_SIZE 256MB = 단일 쿼리만으로 약 4GB PGA 요구

3. **시스템 불안정성 증가**
   - 여러 대형 배치 작업이 동시 실행 시 PGA 폭주 위험
   - RAC 환경에서 특정 인스턴스에 부하 집중 가능

---

## PGA_AGGREGATE_TARGET의 합리적 설정 방법

### 초기 설정 가이드라인

| 시스템 유형 | 권장 PGA 크기 | 특징 |
|------------|--------------|------|
| **OLTP** | 전체 RAM의 10-20% | 작은 정렬/해시 작업, 높은 동시성 |
| **DW/배치** | 전체 RAM의 20-40% | 대형 정렬/해시 작업, 상대적 낮은 동시성 |

**중요 고려사항:**
- SGA와 PGA 간의 균형 유지
- 운영체제 및 다른 애플리케이션을 위한 메모리 여유 확보
- `PGA_AGGREGATE_LIMIT`를 통한 하드 제한 설정

### 성능 모니터링 및 튜닝 절차

#### 1. 현재 상태 진단

```sql
-- PGA 전체 상태 확인
SELECT name, 
       ROUND(value/1024/1024, 2) AS value_mb,
       CASE name 
         WHEN 'total PGA allocated' THEN '현재 할당된 총 PGA'
         WHEN 'total PGA inuse' THEN '실제 사용 중인 PGA'
         WHEN 'over allocation count' THEN '예산 초과 횟수'
         WHEN 'global memory bound' THEN '현재 GMB(자동 모드)'
         WHEN 'pga aggregate target' THEN 'PGA 목표치'
         WHEN 'aggregate PGA auto target' THEN '자동 관리 가능 영역'
       END AS description
FROM   v$pgastat
WHERE  name IN (
  'total PGA allocated',
  'total PGA inuse', 
  'over allocation count',
  'global memory bound',
  'pga aggregate target',
  'aggregate PGA auto target'
);

-- Workarea 실행 품질 분석
SELECT sn.name AS statistic_name,
       ms.value AS count_value,
       CASE sn.name
         WHEN 'workarea executions - optimal' THEN '메모리 내 완료 비율'
         WHEN 'workarea executions - onepass' THEN '1회 디스크 스필 비율'
         WHEN 'workarea executions - multipass' THEN '다중 디스크 스필 비율'
       END AS meaning
FROM   v$mystat ms 
JOIN   v$statname sn ON sn.stat# = ms.stat#
WHERE  sn.name IN (
  'workarea executions - optimal',
  'workarea executions - onepass', 
  'workarea executions - multipass'
);
```

#### 2. PGA 타깃 조언 뷰 분석

```sql
-- PGA 타깃 변경 시 예상 효과 분석
SELECT ROUND(pga_target_for_estimate/1024/1024) AS target_mb,
       ROUND(estd_pga_cache_hit_percentage) AS estd_cache_hit_pct,
       estd_overalloc_count,
       ROUND(estd_extra_bytes_rw/1024/1024) AS estd_extra_io_mb,
       CASE 
         WHEN pga_target_factor = 1 THEN '<< CURRENT'
         ELSE ' '
       END AS current_mark
FROM   v$pga_target_advice
ORDER BY pga_target_for_estimate;

-- 작업 유형별 히스토그램 분석
SELECT operation_type,
       total_executions,
       optimal_executions,
       onepass_executions,
       multipasses_executions,
       ROUND(optimal_executions/total_executions*100, 1) AS optimal_pct
FROM   v$sql_workarea
WHERE  total_executions > 0
ORDER BY total_executions DESC;
```

#### 3. 증분 조정 및 효과 검증

```sql
-- PGA 타깃을 20% 증가 (예시)
ALTER SYSTEM SET pga_aggregate_target = 12G SCOPE=BOTH;

-- 하드 제한 설정 (일반적으로 타깃의 1.5-2배)
ALTER SYSTEM SET pga_aggregate_limit = 24G SCOPE=BOTH;
```

**성능 지표 해석 가이드:**

| 지표 | 이상적 수준 | 문제 징후 | 해결 방안 |
|------|------------|----------|-----------|
| `optimal_executions` 비율 | 95% 이상 | 80% 미만 | PGA 타깃 증가 또는 쿼리 튜닝 |
| `onepass_executions` 비율 | 5% 이하 | 15% 초과 | 메모리 증설 또는 동시성 조절 |
| `multipasses_executions` | 0에 가깝게 | 빈번 발생 | 긴급한 튜닝 필요 |
| `over allocation count` | 증가 없음 | 지속 증가 | 동시성 제한 또는 PGA 증설 |

---

## Workarea 실행 모드 이해: Optimal vs Onepass vs Multipass

### 정렬 작업의 실행 모드

```
입력 데이터
    │
    ├── Optimal 모드 ────▶ 전체 데이터가 메모리 내 정렬 ────▶ 결과 출력
    │   (가장 효율적)
    │
    ├── Onepass 모드 ────▶ 메모리에 부분 정렬 ────▶ Temp 디스크 기록
    │                       │                      │
    │                       │                      │
    │                       ◀─── 1회 병합 ─────────┘
    │
    └── Multipass 모드 ───▶ 다중 Run 생성 ────▶ Temp 다중 기록
            (가장 비효율)       │                      │
                               │                      │
                               ◀─── 다중 병합 반복 ────┘
```

### 해시 작업의 실행 모드

```
해시 테이블 빌드
    │
    ├── Optimal 모드 ────▶ 전체 해시 테이블 메모리 수용 ────▶ 즉시 조인
    │
    ├── Onepass 모드 ────▶ 해시 파티션 생성 ────▶ Temp 스필
    │                       │                      │
    │                       │                      │
    │                       ◀─── 1회 재읽기 ────────┘
    │
    └── Multipass 모드 ───▶ 파티션 재분할 ────▶ 다중 Temp I/O
                               │                      │
                               │                      │
                               ◀─── 다중 재처리 ───────┘
```

**성능 영향:**
- Optimal → Onepass: 일반적으로 2-5배 성능 저하
- Optimal → Multipass: 10배 이상 성능 저하 가능
- Temp I/O 대기 이벤트(`direct path read/write temp`) 증가

---

## 실전 모니터링: 실행 중인 Workarea 분석

### 활성 Workarea 실시간 모니터링

```sql
SELECT swa.sid,
       s.username,
       swa.operation_type,
       swa.policy,
       ROUND(swa.expected_optimal_size/1024/1024, 1) AS exp_opt_mb,
       ROUND(swa.expected_onepass_size/1024/1024, 1) AS exp_one_mb,
       ROUND(swa.last_memory_used/1024/1024, 1) AS last_used_mb,
       ROUND(swa.active_time/100, 1) AS active_seconds,
       sq.sql_text,
       CASE 
         WHEN swa.last_memory_used < swa.expected_onepass_size 
           THEN '스필 위험'
         WHEN swa.last_memory_used >= swa.expected_optimal_size 
           THEN '최적 상태'
         ELSE '정상'
       END AS status
FROM   v$sql_workarea_active swa
JOIN   v$session s ON s.sid = swa.sid
LEFT JOIN v$sql sq ON sq.sql_id = s.sql_id
ORDER BY swa.active_time DESC;
```

### 세션별 PGA 사용 현황

```sql
SELECT s.sid,
       s.username,
       ROUND(p.pga_used_mem/1024/1024, 2) AS pga_used_mb,
       ROUND(p.pga_alloc_mem/1024/1024, 2) AS pga_alloc_mb,
       ROUND(p.pga_max_mem/1024/1024, 2) AS pga_max_mb,
       s.program,
       s.module,
       s.action
FROM   v$session s
JOIN   v$process p ON p.addr = s.paddr
WHERE  s.status = 'ACTIVE'
   AND s.type = 'USER'
ORDER BY p.pga_used_mem DESC;
```

---

## MANUAL 모드의 위험성 실증 실습

### 테스트 환경 설정

```sql
-- 대용량 정렬 테스트 테이블 생성
CREATE TABLE t_large_sort_test NOLOGGING AS
SELECT /*+ materialize */
       rownum AS id,
       TRUNC(DBMS_RANDOM.VALUE(1, 1000000)) AS sort_key,
       RPAD('DATA_', 500, 'X') AS large_payload,
       SYSDATE - DBMS_RANDOM.VALUE(0, 365) AS create_date
FROM   dual 
CONNECT BY LEVEL <= 1000000;  -- 100만 행

EXEC DBMS_STATS.GATHER_TABLE_STATS(USER, 'T_LARGE_SORT_TEST');

-- 성능 측정 기준값 저장
CREATE GLOBAL TEMPORARY TABLE perf_baseline AS
SELECT sn.name, ms.value
FROM   v$mystat ms 
JOIN   v$statname sn ON sn.stat# = ms.stat#
WHERE  sn.name IN (
  'sorts (memory)',
  'sorts (disk)',
  'workarea executions - optimal',
  'workarea executions - onepass',
  'workarea executions - multipass',
  'physical writes direct temporary tablespace',
  'physical reads direct temporary tablespace'
);
```

### 시나리오 1: 부적절한 MANUAL 설정

```sql
-- 위험한 MANUAL 설정 (너무 작은 SORT_AREA_SIZE)
ALTER SYSTEM SET workarea_size_policy = MANUAL SCOPE=MEMORY;
ALTER SESSION SET sort_area_size = 1M;  -- 의도적으로 작게 설정

-- 대형 정렬 쿼리 실행
SELECT /*+ MONITOR GATHER_PLAN_STATISTICS */ 
       sort_key, COUNT(*), AVG(LENGTH(large_payload))
FROM   t_large_sort_test
WHERE  create_date > SYSDATE - 30
GROUP BY sort_key
ORDER BY sort_key
FETCH FIRST 1000 ROWS ONLY;

-- 성능 통계 비교
SELECT a.name,
       b.value - a.value AS delta_value,
       CASE 
         WHEN a.name LIKE '%disk%' OR a.name LIKE '%multipass%' 
           THEN '위험 지표'
         WHEN a.name LIKE '%optimal%' 
           THEN '긍정 지표'
         ELSE '일반 지표'
       END AS category
FROM   perf_baseline a
JOIN   v$mystat b ON b.stat# = a.stat#
JOIN   v$statname sn ON sn.stat# = a.stat#
WHERE  sn.name IN (
  'sorts (memory)',
  'sorts (disk)',
  'workarea executions - optimal',
  'workarea executions - onepass',
  'workarea executions - multipass'
);
```

### 시나리오 2: 적절한 AUTO 모드

```sql
-- AUTO 모드로 전환 및 적절한 PGA 설정
ALTER SYSTEM SET workarea_size_policy = AUTO SCOPE=MEMORY;
ALTER SYSTEM SET pga_aggregate_target = 4G SCOPE=MEMORY;

-- 동일 쿼리 재실행 및 성능 비교
SELECT /*+ MONITOR GATHER_PLAN_STATISTICS */ 
       sort_key, COUNT(*), AVG(LENGTH(large_payload))
FROM   t_large_sort_test
WHERE  create_date > SYSDATE - 30
GROUP BY sort_key
ORDER BY sort_key
FETCH FIRST 1000 ROWS ONLY;
```

---

## Workarea 최적화를 위한 SQL 레벨 개선 전략

PGA 메모리 증설만으로는 근본적인 해결이 되지 않는 경우, SQL 자체를 개선해야 합니다.

### 1. 정렬 부하 최소화 기법

```sql
-- 비효율적 패턴: 전체 정렬 후 필터링
SELECT *
FROM   large_table
ORDER BY sort_column DESC
FETCH FIRST 100 ROWS ONLY;

-- 개선 패턴: 인덱스 활용 및 Stopkey 최적화
SELECT /*+ INDEX_DESC(large_table idx_sort_desc) */
       *
FROM   large_table
WHERE  ROWNUM <= 100;
```

### 2. 해시 조인 최적화

```sql
-- 비효율적 패턴: 대형 테이블을 해시 빌드로 사용
SELECT /*+ USE_HASH(large) */ *
FROM   large_table large
JOIN   small_table small ON small.key = large.key;

-- 개선 패턴: 작은 테이블을 해시 빌드로 사용
SELECT /*+ USE_HASH(small) LEADING(small) */ *
FROM   small_table small
JOIN   large_table large ON large.key = small.key;
```

### 3. 불필요한 Workarea 생성 회피

```sql
-- 비효율적 패턴: 중첩된 정렬/그룹화
SELECT deptno, AVG(sal)
FROM   (
  SELECT deptno, sal
  FROM   emp
  ORDER BY ename  -- 내부 정렬 (불필요)
)
GROUP BY deptno;

-- 개선 패턴: 불필요한 정렬 제거
SELECT deptno, AVG(sal)
FROM   emp
GROUP BY deptno;
```

---

## 운영 환경 적용 가이드라인

### 신규 시스템 설정 체크리스트

1. **기본값 유지**: `WORKAREA_SIZE_POLICY = AUTO`
2. **PGA 타깃 설정**: 시스템 유형에 따라 RAM의 10-40% 범위 내 적절한 값 설정
3. **하드 제한 설정**: `PGA_AGGREGATE_LIMIT = PGA_AGGREGATE_TARGET × 1.5 ~ 2`
4. **모니터링 구성**: 정기적인 PGA 사용 현황 및 Workarea 품질 모니터링
5. **알람 설정**: `over allocation count` 증가, `multipass` 실행 등 위험 지표에 대한 사전 알람

### 기존 시스템 점검 항목

```sql
-- 위험 지표 진단 쿼리
SELECT 
  -- 1. Workarea 품질 진단
  (SELECT ROUND(SUM(onepass_executions + multipasses_executions) * 100.0 / 
                SUM(total_executions), 1)
   FROM v$sql_workarea 
   WHERE total_executions > 0) AS suboptimal_workarea_pct,
  
  -- 2. PGA 과할당 현황
  (SELECT value FROM v$pgastat WHERE name = 'over allocation count') AS overalloc_count,
  
  -- 3. 디스크 정렬 비율
  (SELECT ROUND(sorts_disk * 100.0 / NULLIF(sorts_memory + sorts_disk, 0), 1)
   FROM (SELECT SUM(CASE name WHEN 'sorts (memory)' THEN value END) AS sorts_memory,
                SUM(CASE name WHEN 'sorts (disk)' THEN value END) AS sorts_disk
         FROM v$sysstat WHERE name LIKE 'sorts%')) AS disk_sort_pct,
  
  -- 4. Temp I/O 부하
  (SELECT ROUND(SUM(bytes)/1024/1024/1024, 2)
   FROM v$tempseg_usage) AS temp_usage_gb
FROM dual;
```

### 응급 상황 대응 절차

1. **긴급 완화**: 문제 세션 식별 및 제한적 종료
2. **원인 분석**: `V$SQL_WORKAREA_ACTIVE` 및 `V$SQL`을 통한 문제 쿼리 식별
3. **임시 조치**: `PGA_AGGREGATE_LIMIT` 상향 또는 문제 쿼리 실행 제한
4. **근본 해결**: 쿼리 튜닝 또는 애플리케이션 로직 수정

---

## 결론: PGA Workarea 운영의 핵심 원칙

1. **AUTO 모드를 기본으로 유지하라**
   - Oracle의 자동 메모리 관리 메커니즘은 동시성 변화와 시스템 부하에 유연하게 대응할 수 있도록 설계되었습니다.
   - MANUAL 모드는 특수한 튜닝 상황이나 제한된 환경에서만 세션 수준으로 제한적으로 적용해야 합니다.

2. **모니터링 기반의 점진적 튜닝을 실시하라**
   - `V$PGA_TARGET_ADVICE` 및 Workarea 품질 지표를 기반으로 PGA 크기를 증분 조정합니다.
   - 일회성 튜닝이 아닌 지속적인 모니터링과 조정이 필요합니다.

3. **메모리 증설보다 SQL 개선을 우선시하라**
   - PGA 메모리를 증가시키는 것은 임시 해결책일 뿐입니다.
   - 정렬 최소화, 인덱스 활용, 불필요한 Workarea 회피 등 SQL 레벨의 개선이 근본적인 해결책입니다.

4. **시스템 안정성을 위한 보호 장치를 마련하라**
   - `PGA_AGGREGATE_LIMIT`를 통한 하드 제한 설정
   - Resource Manager를 활용한 세션별 자원 제한
   - 조기 경보 시스템 구축을 통한 사전 대응

5. **용량 계획을 수립하라**
   - 최대 동시 실행 쿼리 수, 평균/최대 Workarea 크기, 병렬도 등을 고려한 용량 계획
   - 성장 추세를 반영한 주기적인 용량 검토 및 확장

PGA Workarea의 효율적 관리는 단순한 파라미터 튜닝을 넘어 시스템 아키텍처, 애플리케이션 설계, 운영 프로세스가 통합적으로 고려되어야 하는 영역입니다. 자동화된 모니터링과 프로액티브한 관리를 통해 시스템의 안정성과 성능을 동시에 확보할 수 있습니다.