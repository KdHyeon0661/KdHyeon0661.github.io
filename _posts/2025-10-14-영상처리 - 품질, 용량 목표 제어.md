---
layout: post
title: 영상처리 - 품질/용량 목표 제어
date: 2025-10-14 15:25:23 +0900
category: 영상처리
---
# 7. **품질/용량 목표 제어(타깃 사이즈)** — `jpeg_mem_dest` + **이진 탐색**으로 “이 JPEG을 300KB 이하로”

> 목표
> - **“이 이미지를 300KB 이하로 저장해줘”** 같은 요구를 **재압축 반복 없이 자동**으로 맞추기
> - `jpeg_mem_dest` 로 **메모리로 인코딩** → 결과 바이트 수를 보고 **품질(quality)** 을 **이진 탐색**
> - 필요 시 **샘플링(4:4:4→4:2:0)**, **프로그레시브**, **리사이즈**까지 단계적 폴백으로 높은 성공률 확보
> - 예제는 C++ / libjpeg(-turbo) / `IppDib(BGRA32)` 기준이며, 코드 블록은 한 번만 ``` 로 감쌉니다.

---

## 0. 왜 이진 탐색인가?

JPEG 용량은 **Quality(1~100)**, **샘플링(4:4:4/4:2:2/4:2:0)**, **최적화(허프만 코드)**, 이미지 내용 등에 따라 **단조 감소에 가까운 경향**을 보입니다.
즉, *대체로* `Quality` 를 낮추면 **용량이 감소**하므로, **이진 탐색**으로 **빠르게** 목표에 수렴할 수 있습니다.

보정 포인트:
- 완전한 단조는 아니므로 **±여유 바이트(오차 허용)** 를 둡니다. (예: ±4KB)
- **Quality=1**로도 목표 미달(=너무 큼)이라면, **샘플링/리사이즈** 폴백이 필요합니다.

---

## 1. 품질/용량에 영향 주는 요소 (요약)

- **Quality(정수 1~100)**: 낮을수록 용량↓, 화질↓
- **서브샘플링(Chroma subsampling)**: 4:4:4 > 4:2:2 > **4:2:0** (용량 4:2:0가 가장 유리)
- **optimize_coding(TRUE)**: 허프만 테이블 최적화(대체로 몇 % 용량↓)
- **프로그레시브(Progressive)**: 동일 품질에서 용량↓ 경향(파일/이미지마다 다름)
- **해상도(픽셀 수)**: 리사이즈가 용량에 **가장 큰 영향**

---

## 2. 옵션 구조체 & 서브샘플링 설정

- libjpeg은 인코딩 전 `jpeg_set_defaults()` 후 `jpeg_set_colorspace(&cinfo, JCS_YCbCr)`를 호출하고,
  `cinfo.comp_info`의 **H/V 샘플링 팩터**로 4:4:4/4:2:2/4:2:0를 지정합니다.

```cpp
// JpegSizeTarget.hpp
#pragma once
#include <vector>
#include <string>
#include <cstdint>
#include <jpeglib.h>
#include "IppDib.h"

enum class JpegChroma {
    CS444, CS422, CS420
};
struct JpegEncodeOptions {
    JpegChroma chroma = JpegChroma::CS420; // 기본 4:2:0 (용량 유리)
    bool progressive = false;              // true면 jpeg_simple_progression 사용
    bool optimize_coding = true;           // 허프만 최적화
    bool use_ext_bgra = true;              // turbo 확장 색공간 입력(BGRA) 사용
};

struct MarkerBlob { int marker; std::vector<uint8_t> data; }; // 재주입용(선택)

struct TargetResult {
    std::vector<uint8_t> jpeg; // 최종 JPEG 메모리 버퍼
    int used_quality = 0;
    JpegChroma used_chroma = JpegChroma::CS420;
    int out_w=0, out_h=0;
};
```

```cpp
// JpegSizeTarget.cpp (일부)
static void SetChromaSampling(jpeg_compress_struct& cinfo, JpegChroma cs){
    // YCbCr로 맞춘 뒤, comp_info[0]=Y, [1]=Cb, [2]=Cr
    jpeg_set_colorspace(&cinfo, JCS_YCbCr);
    if (cs == JpegChroma::CS444){
        cinfo.comp_info[0].h_samp_factor = 1; cinfo.comp_info[0].v_samp_factor = 1;
        cinfo.comp_info[1].h_samp_factor = 1; cinfo.comp_info[1].v_samp_factor = 1;
        cinfo.comp_info[2].h_samp_factor = 1; cinfo.comp_info[2].v_samp_factor = 1;
    } else if (cs == JpegChroma::CS422){
        cinfo.comp_info[0].h_samp_factor = 2; cinfo.comp_info[0].v_samp_factor = 1;
        cinfo.comp_info[1].h_samp_factor = 1; cinfo.comp_info[1].v_samp_factor = 1;
        cinfo.comp_info[2].h_samp_factor = 1; cinfo.comp_info[2].v_samp_factor = 1;
    } else { // CS420
        cinfo.comp_info[0].h_samp_factor = 2; cinfo.comp_info[0].v_samp_factor = 2;
        cinfo.comp_info[1].h_samp_factor = 1; cinfo.comp_info[1].v_samp_factor = 1;
        cinfo.comp_info[2].h_samp_factor = 1; cinfo.comp_info[2].v_samp_factor = 1;
    }
}
```

---

## 3. **품질 고정 인코딩** — `jpeg_mem_dest`로 한 번 압축해 바이트 얻기

- libjpeg이 **malloc()** 로 할당해주는 메모리(`unsigned char* outbuf; unsigned long outsize;`)를 돌려줍니다.
  사용 후 `free(outbuf)` 해야 합니다. (new/delete 금지)

```cpp
// 품질 q, 옵션 opt로 BGRA32 IppDib을 메모리 JPEG로 인코드하고 바이트 배열 반환
static bool EncodeJpegMem(const IppDib& bgra, int q, const JpegEncodeOptions& opt,
                          const std::vector<MarkerBlob>* reinjectMarkers,
                          std::vector<uint8_t>& out)
{
    if (!bgra) return false;

    jpeg_compress_struct c{}; jpeg_error_mgr jerr{};
    c.err = jpeg_std_error(&jerr);
    jpeg_create_compress(&c);

    unsigned char* mem = nullptr;
    unsigned long   memSize = 0;
#if JPEG_LIB_VERSION >= 62
    jpeg_mem_dest(&c, &mem, &memSize); // libjpeg(-turbo) 표준
#else
    return false; // 구버전 대응은 별도 구현
#endif

    c.image_width  = bgra.width();
    c.image_height = bgra.height();

#ifdef JCS_EXTENSIONS
    if (opt.use_ext_bgra){
        c.input_components = 4;
        c.in_color_space = JCS_EXT_BGRA; // turbo 확장: BGRA → 내부에서 YCbCr
    } else
#endif
    {
        c.input_components = 3;
        c.in_color_space = JCS_RGB; // 수동 변환 경로 사용
    }

    jpeg_set_defaults(&c);
    // 색공간/샘플링 지정
    SetChromaSampling(c, opt.chroma);

    // 품질/코딩 옵션
    jpeg_set_quality(&c, std::max(1, std::min(q, 100)), TRUE);
    c.optimize_coding = opt.optimize_coding ? TRUE : FALSE;
    if (opt.progressive) jpeg_simple_progression(&c);

    // 시작
    jpeg_start_compress(&c, TRUE);

    // (선택) 메타데이터 재주입 — SOI 다음, 스캔라인 전
    if (reinjectMarkers){
        for (auto& m : *reinjectMarkers){
            jpeg_write_marker(&c, m.marker,
                              const_cast<unsigned char*>(m.data.data()),
                              (unsigned int)m.data.size());
        }
    }

    // 행 쓰기
    std::vector<uint8_t> rowRGB; rowRGB.resize(bgra.width()*3);
    while (c.next_scanline < c.image_height){
        const uint8_t* s = (const uint8_t*)bgra.bits() + (size_t)c.next_scanline*bgra.stride();
#ifdef JCS_EXTENSIONS
        if (opt.use_ext_bgra){
            // BGRA 그대로 전달
            JSAMPROW rp = (JSAMPROW)s;
            jpeg_write_scanlines(&c, &rp, 1);
        } else
#endif
        {
            // BGRA → RGB 변환 후 전달(표준 경로)
            for (int x=0;x<bgra.width();++x){
                rowRGB[x*3+0]=s[x*4+2];
                rowRGB[x*3+1]=s[x*4+1];
                rowRGB[x*3+2]=s[x*4+0];
            }
            JSAMPROW rp = rowRGB.data();
            jpeg_write_scanlines(&c, &rp, 1);
        }
    }

    jpeg_finish_compress(&c);
    // 결과 복사
    out.assign(mem, mem + memSize);
    jpeg_destroy_compress(&c);
    free(mem);
    return true;
}
```

> **TIP**
> - `optimize_coding=TRUE` 는 거의 항상 이득입니다(속도↓ 약간, 용량↓).
> - `progressive=TRUE` 는 장면에 따라 용량이 1~10% 더 줄어드는 경우가 있습니다.

---

## 4. **이진 탐색**으로 타깃 바이트에 수렴

- `q_lo=1`, `q_hi=100` 으로 시작 → `q_mid=(q_lo+q_hi)/2` 로 인코딩 → 결과 바이트 비교
- `bytes <= target+tol` 이면 **성공**, 아니면 구간 갱신
- 반복 횟수는 보통 **7~8회**면 충분(2^8=256)

```cpp
// target_bytes 이하(±tolerance 허용)로 맞추기
static bool EncodeToTargetBytes(const IppDib& img,
                                size_t target_bytes,
                                size_t tolerance_bytes,
                                const JpegEncodeOptions& opt,
                                const std::vector<MarkerBlob>* reinjectMarkers,
                                TargetResult& result)
{
    int lo=1, hi=100, bestq=-1;
    std::vector<uint8_t> bestBuf;

    for (int iter=0; iter<12 && lo<=hi; ++iter){
        int mid = (lo+hi)/2;
        std::vector<uint8_t> buf;
        if (!EncodeJpegMem(img, mid, opt, reinjectMarkers, buf)) return false;

        const size_t sz = buf.size();
        // 목표 달성?
        if (sz <= target_bytes + tolerance_bytes){
            // 충분히 작음 → 더 키울 여지가 있는지(화질↑)
            bestq = mid; bestBuf.swap(buf);
            lo = mid + 1;
        }else{
            // 너무 큼 → 화질 낮추기
            hi = mid - 1;
        }
    }

    // bestq 가 없으면(=quality 1로도 큼) 실패 반환
    if (bestq < 0) return false;

    result.jpeg.swap(bestBuf);
    result.used_quality = bestq;
    result.used_chroma  = opt.chroma;
    // (출력 해상도는 입력과 동일, 필요 시 img.width/height 복사)
    result.out_w = img.width();
    result.out_h = img.height();
    return true;
}
```

---

## 5. **폴백 전략** — 그래도 크면?

1) **샘플링 전환**:
   - 4:4:4 → 4:2:0 로 바꾸면 **색차 해상도**를 줄여 **용량 큰 폭 감소**
   - 미세한 색 경계/텍스트가 많은 이미지에선 주의(색 번짐 가능)

2) **프로그레시브 켜기**:
   - 동일 품질 대비 용량↓ 경향(장면 의존)

3) **다운스케일**(리사이즈):
   - 최후의 수단이지만, 용량 제어가 가장 확실
   - **비율 s ≈ sqrt(target/now)** 로 추정해서 크기 줄이기

### 5.1 간단 **양선형** 다운스케일러(그레이/컬러 공용)

```cpp
// 아주 단순한 양선형 리사이즈(BGRA32 → BGRA32), 외부 고품질 리사이저로 교체 가능
static IppDib DownscaleBilinear(const IppDib& src, int newW, int newH){
    IppDib dst; dst.create(newW, newH, 32);
    const int sw=src.width(), sh=src.height();
    const double sx = (double)sw / newW;
    const double sy = (double)sh / newH;

    for (int y=0;y<newH;++y){
        double fy = (y+0.5)*sy - 0.5;
        int y0 = (int)floor(fy), y1 = std::min(sh-1, y0+1);
        double wy = fy - y0; if (y0<0){ y0=0; wy=0; }
        for (int x=0;x<newW;++x){
            double fx=(x+0.5)*sx - 0.5;
            int x0=(int)floor(fx), x1=std::min(sw-1,x0+1);
            double wx = fx - x0; if (x0<0){ x0=0; wx=0; }

            auto S = [&](int xx,int yy)->const uint8_t*{
                return (const uint8_t*)src.bits() + (size_t)yy*src.stride() + xx*4;
            };
            const uint8_t* p00=S(x0,y0); const uint8_t* p10=S(x1,y0);
            const uint8_t* p01=S(x0,y1); const uint8_t* p11=S(x1,y1);

            double w00=(1-wx)*(1-wy), w10=wx*(1-wy), w01=(1-wx)*wy, w11=wx*wy;
            uint8_t* d=(uint8_t*)dst.bits() + (size_t)y*dst.stride() + x*4;
            for (int c=0;c<4;++c){
                double v = p00[c]*w00 + p10[c]*w10 + p01[c]*w01 + p11[c]*w11;
                d[c] = (uint8_t)std::clamp((int)std::round(v), 0, 255);
            }
        }
    }
    return dst;
}
```

### 5.2 “**타깃 바이트**” 전체 파이프라인

```cpp
// target_bytes 이하를 1) 현재 옵션, 2) 4:2:0/프로그레시브 전환, 3) 다운스케일 순서로 시도
bool EncodeJpeg_ToSize(const IppDib& src,
                       size_t target_bytes, size_t tolerance_bytes,
                       const std::vector<MarkerBlob>* reinjectMarkers,
                       TargetResult& out)
{
    JpegEncodeOptions opt;

    // (A) 기본: 4:2:0 + optimize + (progressive off)
    opt.chroma = JpegChroma::CS420;
    opt.optimize_coding = true;
    opt.progressive = false;
    if (EncodeToTargetBytes(src, target_bytes, tolerance_bytes, opt, reinjectMarkers, out))
        return true;

    // (B) 4:2:0 + progressive
    opt.progressive = true;
    if (EncodeToTargetBytes(src, target_bytes, tolerance_bytes, opt, reinjectMarkers, out))
        return true;

    // (C) 4:2:2 (간혹 4:2:0와 다른 테이블로 유리할 때가 있음)
    opt.chroma = JpegChroma::CS422;
    if (EncodeToTargetBytes(src, target_bytes, tolerance_bytes, opt, reinjectMarkers, out))
        return true;

    // (D) 최후: 다운스케일 추정 → 재시도(최대 2~3회)
    IppDib cur = src;
    for (int attempt=0; attempt<3; ++attempt){
        // 대략 절감 비율 추정: 현재 “Quality=1 + 4:2:0 + progressive”로 한 번 용량 측정
        std::vector<uint8_t> buf;
        JpegEncodeOptions probe = opt;
        probe.chroma = JpegChroma::CS420;
        probe.progressive = true;
        if (!EncodeJpegMem(cur, 1, probe, reinjectMarkers, buf)) break;

        if (buf.size() <= target_bytes + tolerance_bytes){
            // Q=1로 이미 작으면, 이 해상도에서 이진 탐색으로 품질을 올려보자
            if (EncodeToTargetBytes(cur, target_bytes, tolerance_bytes, opt, reinjectMarkers, out)){
                out.out_w = cur.width(); out.out_h = cur.height();
                return true;
            }
        }

        // 스케일 추정: s ≈ sqrt(target / current)
        double s = std::sqrt((double)target_bytes / (double)buf.size());
        s *= 0.97; // 약간 보수적으로 더 줄이기
        if (s >= 1.0) s = 0.9;        // 그래도 줄이자
        if (s < 0.3) s = 0.3;         // 과도 축소 방지(하한)
        int nw = std::max(8, (int)std::floor(cur.width()  * s));
        int nh = std::max(8, (int)std::floor(cur.height() * s));
        if (nw==cur.width() && nh==cur.height()) { nw = cur.width()-1; nh = cur.height()-1; }
        cur = DownscaleBilinear(cur, nw, nh);

        // 축소 후 최적 옵션으로 최종 시도
        if (EncodeToTargetBytes(cur, target_bytes, tolerance_bytes, opt, reinjectMarkers, out)){
            out.out_w = cur.width(); out.out_h = cur.height();
            return true;
        }
    }
    return false; // 타협 실패
}
```

---

## 6. 사용 예 — **300KB 이하로 저장**

### 6.1 메타데이터 포함(재주입)해서 맞추기
- 메타(Exif/XMP/ICC)는 **파일 크기를 늘립니다** → **반드시** 인코딩 반복마다 **같이 재주입** 후 길이를 측정해야 합니다.

```cpp
IppDib img = LoadSomeBGRA(); // 기존 파이프라인 참고
std::vector<MarkerBlob> markers = /* 원본에서 수집(보존할 APPn) */;
TargetResult res;

size_t target = 300 * 1024; // 300KB
size_t tol    = 4   * 1024; // ±4KB 허용

if (EncodeJpeg_ToSize(img, target, tol, &markers, res)){
    // res.jpeg 가 최종 바이트
    // res.used_quality, res.used_chroma, res.out_w/h 참고
    SaveBytesToFile(L"out_300kb.jpg", res.jpeg);
} else {
    // 실패: 극단적으로 디테일이 많거나, 메타가 매우 큰 경우 등
}
```

### 6.2 **프로그레시브** 선호, 4:4:4 유지(텍스트/GUI 캡처)
- 텍스트 스크린샷처럼 **색 경계가 예민**하면 4:4:4 유지가 좋습니다.
  용량이 클 수 있으므로 **다운스케일**로 타협하는 것이 안전합니다.

```cpp
JpegEncodeOptions opt;
opt.chroma = JpegChroma::CS444;
opt.progressive = true;
opt.optimize_coding = true;
// EncodeToTargetBytes를 직접 호출해도 되고,
// EncodeJpeg_ToSize 내부를 변형하여 (A)단계부터 CS444를 쓰도록 커스터마이즈 가능
```

---

## 7. UI/UX 제안 (MFC 도구에 녹이기)

- “**타깃 용량**(KB)” 입력 + “**허용 오차**(KB)” + “**최대 가로/세로**” + “**샘플링 우선순위**” 옵션
- 라디오: **품질 우선**(해상도 유지) / **용량 우선**(해상도도 조절)
- 체크: **프로그레시브**, **허프만 최적화**, **메타데이터 유지(선택/필터)**
- 진행 상태에 **현재 품질, 크기, 추정 스케일** 표시 → 재시도 과정을 가시화
- **배치**: 폴더 단위 일괄 변환 + 실패/성공 로그

---

## 8. 주의/팁

- **mozjpeg** 계열은 추가 최적화(트렐리스 등)로 **같은 품질에서 더 작은 용량**을 내기도 합니다.
  (libjpeg-turbo만으로도 위 파이프라인은 충분히 유효)
- **최저 품질**에서도 **복잡한 자연 사진 + 큰 메타**면 300KB 이하가 **불가능**할 수 있습니다 → 리사이즈 필요.
- **색공간/ICC**: sRGB로 통일하면 **표시 일관성**에 유리(ICC 보존/변환 파트 참조).
- **EXIF Orientation**: 이미 픽셀에 반영했다면 **Orientation=1**로 패치하여 **이중 회전** 방지.
- **스레딩**: 같은 이미지를 반복 인코드하므로 **스레드 풀**에서 병렬 처리하면 체감 빠름.

---

## 9. 검증 체크리스트

- [ ] **Quality 이진 탐색**이 **단계적으로** 수렴하는지(로그로 `q`, `bytes`)
- [ ] **메타 재주입 포함** 측정을 하는지(메타 크기에 따라 결과가 달라짐)
- [ ] 4:4:4 / 4:2:0 **샘플링 전환**이 용량에 미치는 영향 확인
- [ ] **프로그레시브 on/off** 비교
- [ ] **다운스케일 루프**가 과도 축소 없이 목표 도달하는지
- [ ] “용량 우선” 모드에서 **가로/세로 상한**을 존중하는지

---

## 10. 결론

- `jpeg_mem_dest` + **이진 탐색**은 “**정해진 바이트 이하**” 조건을 만족시키는 가장 단순·강력한 방식입니다.
- **샘플링/프로그레시브/허프만 최적화**를 적절히 조합하고, **리사이즈**를 최후의 수단으로 쓰면 **성공률 100%에 가깝게** 운용할 수 있습니다.
- 상단 예제들을 그대로 **ImageTool**에 붙이면, “**한 번에 300KB**” 같은 실무 요구를 꽤 우아하게 해결할 수 있습니다.
