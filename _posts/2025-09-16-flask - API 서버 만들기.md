---
layout: post
title: flask - API 서버 만들기
date: 2025-09-16 16:25:23 +0900
category: flask
---
# 4. API 서버 만들기

> 이 장은 **JSON API 베스트프랙티스(상태코드/에러 규약) → 스키마 직렬화·검증(Marshmallow/Pydantic) → OpenAPI/Swagger 문서화(flask-smorest, flask-restx)** 를 실전 기준으로 정리한다.  
> 모든 코드는 ``` 로 감싸고, 수식이 필요하다면 $$...$$로 감싼다(이 장은 수식이 거의 없다).

---

## 4.1 JSON API 베스트프랙티스

### 4.1.1 응답 형태(일관성)

- **성공(리소스 반환)**:
  - `200 OK` (조회/수정 후 결과), `201 Created` (생성), `204 No Content` (삭제/바디 없음)
- **실패(에러 규약)**:
  - `400 Bad Request` (형식 오류), `401 Unauthorized`, `403 Forbidden`, `404 Not Found`
  - `409 Conflict` (중복/버전 충돌), `422 Unprocessable Entity` (검증 실패)
  - `429 Too Many Requests` (레이트 리밋), `500/502/503` (서버/의존성 장애)

권장 **에러 JSON 스키마(예시)**:

```json
{
  "error": {
    "code": "validation_failed",
    "message": "입력값이 유효하지 않습니다.",
    "details": {
      "name": ["최대 100자 이하이어야 합니다."],
      "price": ["0 이상이어야 합니다."]
    },
    "request_id": "a1b2c3d4"
  }
}
```

- `code`: 머신이 읽을 내부 에러코드(고정된 토큰)  
- `message`: 사용자 메시지(다국어 고려)  
- `details`: 필드별 오류(검증 실패 시 필수)  
- `request_id`: 관측/추적을 위한 상관ID

### 4.1.2 컬렉션/단건/서브리소스 URL

- 컬렉션: `/api/v1/items` (GET 목록, POST 생성)  
- 단건: `/api/v1/items/{id}` (GET/PUT/PATCH/DELETE)  
- 서브리소스: `/api/v1/items/{id}/reviews`  

**쿼리 매개변수**: `page`, `size`, `sort`, `filter[...]`, `fields`, `include` 등

### 4.1.3 페이징/정렬/필터링

- **커서(Keyset) 페이징** 권장(대규모에서 안정적). 간단 예시는 Offset.
- 응답에 **링크 헤더** 또는 `meta/links` 포함.

```json
{
  "items": [{ "id": 101, "name": "A" }],
  "meta": {
    "page": 2, "size": 20, "total": 1234, "has_next": true
  },
  "links": {
    "self": "https://api.example.com/items?page=2&size=20",
    "next": "https://api.example.com/items?page=3&size=20",
    "prev": "https://api.example.com/items?page=1&size=20"
  }
}
```

### 4.1.4 캐시/조건부 요청

- **GET** 응답에 `ETag`/`Last-Modified` + `Cache-Control`  
- 클라이언트는 `If-None-Match`/`If-Modified-Since` 로 재검증 → **304** 응답

### 4.1.5 멱등성/안전성

- GET/HEAD: 안전·멱등  
- PUT/DELETE: 멱등  
- POST: 보통 멱등 아님 → **Idempotency-Key** 로 멱등 처리 가능(아래 4.1.8)

### 4.1.6 컨텐츠 타입/인코딩

- 요청: `Content-Type: application/json`  
- 응답: `application/json; charset=utf-8`  
- 압축: Gzip/Brotli (프록시 레벨 권장)

### 4.1.7 보안 헤더/권한

- `Authorization: Bearer <token>` 또는 세션 쿠키(+CSRF 대책)  
- CORS는 최소 허용 원칙: Origin/Methods/Headers 화이트리스트  
- 응답 헤더: `X-Content-Type-Options: nosniff`, `Content-Security-Policy`(프런트 분리 시)

### 4.1.8 Idempotency-Key (결제/주문 등 중복 방지)

- 클라이언트가 **POST** 헤더 `Idempotency-Key: <uuid>` 첨부  
- 서버는 키별 **요청 바디 해시**와 **결과**를 저장, 동일 키 재요청 시 **같은 결과** 반환(409/422 방지)

```python
# 스케치: 키 저장소는 Redis/DB (키 TTL 설정)
from flask import request, jsonify
import hashlib, json, time

IDEMPOTENCY_STORE = {}  # 예제용 (운영: Redis)

def body_hash(payload: dict) -> str:
    return hashlib.sha256(json.dumps(payload, sort_keys=True).encode()).hexdigest()

@api_v1.post("/payments")
def create_payment():
    key = request.headers.get("Idempotency-Key")
    payload = request.get_json(silent=False) or {}
    h = body_hash(payload)

    if key:
        saved = IDEMPOTENCY_STORE.get(key)
        if saved:
            # 바디 해시 다르면 충돌(409)
            if saved["hash"] != h:
                return {"error": {"code":"idempotency_conflict","message":"Different payload"}}, 409
            # 동일이면 결과 재사용
            return saved["response"], 200

    # 실제 결제 처리 ...
    resp = jsonify(id="pay_123", status="authorized", amount=payload.get("amount"))
    if key:
        IDEMPOTENCY_STORE[key] = {"hash": h, "response": resp.get_json(), "ts": time.time()}
    return resp, 201
```

---

## 4.2 Marshmallow 기반 직렬화/검증

### 4.2.1 설치

```bash
pip install marshmallow marshmallow-sqlalchemy
```

### 4.2.2 스키마 정의

```python
# app/schemas/item_ma.py
from marshmallow import Schema, fields, validate, validates, ValidationError

class ItemOut(Schema):
    id = fields.Int(required=True)
    name = fields.Str(required=True)
    price = fields.Float(required=True)
    currency = fields.Str(required=True, validate=validate.OneOf(["KRW","USD","JPY"]))
    created_at = fields.DateTime(required=True)

class ItemIn(Schema):
    name = fields.Str(required=True, validate=validate.Length(max=100))
    price = fields.Float(required=True)
    currency = fields.Str(load_default="KRW")

    @validates("price")
    def validate_price(self, v):
        if v < 0:
            raise ValidationError("0 이상이어야 합니다.")
```

### 4.2.3 뷰에서 사용

```python
from flask import request, jsonify
from app.schemas.item_ma import ItemIn, ItemOut
from datetime import datetime, timezone

@api_v1.post("/items")
def create_item():
    data = request.get_json(silent=False)
    errors = ItemIn().validate(data)
    if errors:
        return {"error":{"code":"validation_failed","message":"입력 오류","details":errors}}, 422

    # DB insert 가정
    item = {"id": 123, **data, "created_at": datetime.now(timezone.utc)}
    return ItemOut().dump(item), 201

@api_v1.get("/items/<int:item_id>")
def get_item(item_id: int):
    # DB fetch 가정
    item = {"id": item_id, "name": "Book", "price": 20.5, "currency":"KRW",
            "created_at": datetime.now(timezone.utc)}
    return ItemOut().dump(item), 200
```

### 4.2.4 리스트/페이지 응답 직렬화

```python
class PageMeta(Schema):
    page = fields.Int(required=True)
    size = fields.Int(required=True)
    total = fields.Int(required=True)
    has_next = fields.Bool(required=True)

class ItemList(Schema):
    items = fields.List(fields.Nested(ItemOut), required=True)
    meta = fields.Nested(PageMeta, required=True)
```

---

## 4.3 Pydantic 기반 직렬화/검증 (v2)

### 4.3.1 설치

```bash
pip install pydantic==2.* pydantic-core
```

### 4.3.2 모델 정의

```python
# app/schemas/item_pd.py
from pydantic import BaseModel, Field, field_validator
from datetime import datetime
from typing import Literal

class ItemInPD(BaseModel):
    name: str = Field(..., max_length=100)
    price: float
    currency: Literal["KRW","USD","JPY"] = "KRW"

    @field_validator("price")
    @classmethod
    def non_negative(cls, v):
        if v < 0:
            raise ValueError("0 이상이어야 합니다.")
        return v

class ItemOutPD(BaseModel):
    id: int
    name: str
    price: float
    currency: Literal["KRW","USD","JPY"]
    created_at: datetime
```

### 4.3.3 사용

```python
from flask import request
from app.schemas.item_pd import ItemInPD, ItemOutPD
from datetime import datetime, timezone

@api_v1.post("/items-pd")
def create_item_pd():
    data = request.get_json(silent=False)
    try:
        dto = ItemInPD.model_validate(data)
    except Exception as e:
        # Pydantic 오류 → 422 변환
        return {"error":{"code":"validation_failed","message":str(e)}}, 422

    item = ItemOutPD(
        id=456, name=dto.name, price=dto.price, currency=dto.currency,
        created_at=datetime.now(timezone.utc)
    )
    return item.model_dump(mode="json"), 201
```

**선택 기준**  
- Marshmallow: Flask/대부분의 파이프라인과 친화, 직렬화/역직렬화 역할 분리  
- Pydantic: 타입힌트 기반, 속도/개발자 경험 우수, FastAPI 친화  
- 혼용 금지 아님. 팀 표준을 정하고, **서비스 계층 DTO**로 일관화하면 좋다.

---

## 4.4 에러 핸들링/예외 → 규약 응답으로 매핑

### 4.4.1 공통 핸들러

```python
# app/errors.py
from flask import Blueprint, jsonify, g
from werkzeug.exceptions import BadRequest, NotFound, Unauthorized, Forbidden

errors_bp = Blueprint("errors", __name__)

def error_payload(code: str, message: str, details=None, status=400):
    return jsonify({
        "error": {
            "code": code, "message": message, "details": details or {},
            "request_id": getattr(g, "request_id", None)
        }
    }), status

@errors_bp.app_errorhandler(BadRequest)
def _bad_request(e):  # 400
    return error_payload("bad_request", str(e), status=400)

@errors_bp.app_errorhandler(NotFound)
def _nf(e):          # 404
    return error_payload("not_found", "리소스를 찾을 수 없습니다.", status=404)

@errors_bp.app_errorhandler(Unauthorized)
def _unauth(e):      # 401
    return error_payload("unauthorized", "인증이 필요합니다.", status=401)

@errors_bp.app_errorhandler(Forbidden)
def _forb(e):        # 403
    return error_payload("forbidden", "접근 권한이 없습니다.", status=403)

@errors_bp.app_errorhandler(Exception)
def _ise(e):         # 500
    # 내부에서는 로깅/알림, 외부에는 상세 숨김
    return error_payload("internal_error", "서버 오류가 발생했습니다." , status=500)
```

### 4.4.2 검증 실패(422) 통일

```python
def validation_error(details):
    return error_payload("validation_failed", "입력값이 유효하지 않습니다.", details, status=422)
```

---

## 4.5 OpenAPI/Swagger 문서화 — flask-smorest

### 4.5.1 설치

```bash
pip install flask-smorest marshmallow
```

### 4.5.2 설정/앱 통합

```python
# app/__init__.py
from flask import Flask
from flask_smorest import Api

def create_app(config=None):
    app = Flask(__name__)
    app.config.update(
        API_TITLE="Shop API",
        API_VERSION="1.0.0",
        OPENAPI_VERSION="3.0.3",
        OPENAPI_URL_PREFIX="/",
        OPENAPI_JSON_PATH="openapi.json",
        OPENAPI_REDOC_PATH="/redoc",
        OPENAPI_REDOC_URL="https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js",
        OPENAPI_SWAGGER_UI_PATH="/docs",
        OPENAPI_SWAGGER_UI_URL="https://cdn.jsdelivr.net/npm/swagger-ui-dist/"
    )
    api = Api(app)
    # 블루프린트 등록
    from app.apis.items_smorest import blp as items_blp
    api.register_blueprint(items_blp, url_prefix="/api/v1")
    return app
```

### 4.5.3 리소스 정의(마시멜로 스키마 연계)

```python
# app/apis/items_smorest.py
from flask_smorest import Blueprint
from flask import request
from marshmallow import Schema, fields, validate
from datetime import datetime, timezone

blp = Blueprint("items", "items", description="Items API")

class ItemIn(Schema):
    name = fields.String(required=True, validate=validate.Length(max=100))
    price = fields.Float(required=True)
    currency = fields.String(load_default="KRW", validate=validate.OneOf(["KRW","USD","JPY"]))

class ItemOut(Schema):
    id = fields.Int(required=True)
    name = fields.String(required=True)
    price = fields.Float(required=True)
    currency = fields.String(required=True)
    created_at = fields.DateTime(required=True)

@blp.route("/items")
class ItemsResource:
    @blp.arguments(ItemIn)           # 자동 검증/로드
    @blp.response(201, ItemOut)     # 자동 직렬화/문서화
    def post(payload):
        item = {
            "id": 101,
            "name": payload["name"],
            "price": payload["price"],
            "currency": payload["currency"],
            "created_at": datetime.now(timezone.utc)
        }
        return item

    @blp.response(200, ItemOut(many=True))
    def get():
        return [
          {"id":1,"name":"A","price":10.0,"currency":"KRW","created_at":datetime.now(timezone.utc)},
          {"id":2,"name":"B","price":20.0,"currency":"KRW","created_at":datetime.now(timezone.utc)}
        ]

@blp.route("/items/<int:item_id>")
class ItemResource:
    @blp.response(200, ItemOut)
    def get(item_id: int):
        return {"id":item_id,"name":"Book","price":9.99,"currency":"KRW","created_at":datetime.now(timezone.utc)}
```

- `/docs` → Swagger UI, `/openapi.json` → 스키마 추출  
- `@blp.arguments` 가 검증 실패 시 적절한 4xx를 자동 반환(커스터마이즈 가능)

### 4.5.4 에러 스키마 문서화(옵션)

```python
class ErrorDetail(Schema):
    code = fields.String(required=True)
    message = fields.String(required=True)
    details = fields.Dict(keys=fields.String(), values=fields.List(fields.String()))

class ErrorResponse(Schema):
    error = fields.Nested(ErrorDetail, required=True)
```

엔드포인트에 `@blp.alt_response(422, ErrorResponse)` 등으로 실패 응답도 문서화.

---

## 4.6 OpenAPI/Swagger — flask-restx 대안

### 4.6.1 설치

```bash
pip install flask-restx
```

### 4.6.2 설정/네임스페이스

```python
# app/apis/items_restx.py
from flask_restx import Api, Namespace, Resource, fields
from flask import Flask, request
from datetime import datetime, timezone

app = Flask(__name__)
api = Api(app, version="1.0", title="Shop API", doc="/docs")  # /docs에 UI
ns = Namespace("items", description="Items API")
api.add_namespace(ns, path="/api/v1")

ItemIn = api.model("ItemIn", {
    "name": fields.String(required=True, max_length=100),
    "price": fields.Float(required=True),
    "currency": fields.String(required=False, default="KRW", enum=["KRW","USD","JPY"])
})
ItemOut = api.model("ItemOut", {
    "id": fields.Integer(required=True),
    "name": fields.String(required=True),
    "price": fields.Float(required=True),
    "currency": fields.String(required=True),
    "created_at": fields.DateTime(required=True)
})

@ns.route("/items")
class Items(Resource):
    @ns.marshal_list_with(ItemOut, code=200)
    def get(self):
        return [
          {"id":1,"name":"A","price":10,"currency":"KRW","created_at":datetime.now(timezone.utc)}
        ]

    @ns.expect(ItemIn, validate=True)
    @ns.marshal_with(ItemOut, code=201)
    def post(self):
        payload = request.get_json()
        return {"id":101, **payload, "created_at":datetime.now(timezone.utc)}, 201
```

- `@ns.expect` 가 요청 검증(간단)  
- `@ns.marshal_with` 가 응답 직렬화 & 문서화  
- 장점: 문서화가 빠르지만, 복잡 검증/스키마 재사용은 **marshmallow + smorest** 조합이 더 유연

---

## 4.7 버전 전략/네임스페이스/디프리케이션

- **URL 버전**: `/api/v1` → `/api/v2` (권장: 명시적이고 캐시/게이트웨이에 유리)  
- **헤더 버전**: `Accept: application/vnd.example.v1+json` (게이트웨이/클라이언트 협의 필요)  
- **디프리케이션**: 응답 헤더 `Deprecation: true`, `Sunset: <date>`, 문서/Changelog에 명시

---

## 4.8 보안/레이트리미팅/감사

- **AuthZ**: 역할/권한(스코프) 기반 결정 → 403 반환  
- **Rate limit**: 로그인/업로드/주요 API에 IP/사용자별 제한 (예: Flask-Limiter)  
- **감사 로그**: 주요 상태 변경(Create/Update/Delete), 요청자/시간/전/후 상태

```python
# 레이트 리미팅 예시 (스케치)
# pip install flask-limiter
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(get_remote_address, default_limits=["200/minute"])

def create_app(...):
    app = Flask(__name__)
    limiter.init_app(app)
    return app

@api_v1.post("/login")
@limiter.limit("10/minute")
def login():
    ...
```

---

## 4.9 cURL/HTTPie 예시(개발 확인)

```bash
# 생성
curl -i -X POST http://127.0.0.1:5000/api/v1/items \
  -H "Content-Type: application/json" \
  -d '{"name":"Pen","price":1200,"currency":"KRW"}'

# 조회
curl -i http://127.0.0.1:5000/api/v1/items/101

# 문서
curl -s http://127.0.0.1:5000/openapi.json | jq .
```

---

## 4.10 pytest로 API 테스트

```python
# tests/test_items.py
def test_create_item(client):
    r = client.post("/api/v1/items", json={"name":"Book","price":12.5,"currency":"KRW"})
    assert r.status_code == 201
    data = r.get_json()
    assert data["name"] == "Book"
    assert "created_at" in data

def test_validation_422(client):
    r = client.post("/api/v1/items", json={"name":"X","price":-1})
    assert r.status_code == 422
    err = r.get_json()["error"]
    assert err["code"] == "validation_failed"
    assert "price" in err["details"]
```

---

## 4.11 운영 체크리스트

- [ ] **상태코드/메시지/에러 스키마** 일관성  
- [ ] **검증 계층**: Marshmallow/Pydantic 중 하나(또는 둘) 표준화  
- [ ] **OpenAPI** 자동화(flask-smorest 권장) & CI에서 **스키마 유효성 검사**  
- [ ] **페이징/정렬/필터링** 규칙 문서화  
- [ ] **Idempotency-Key**: 결제/주문 등 재시도 가능한 POST에 적용  
- [ ] **ETag/Cache-Control**: 읽기 최적화  
- [ ] **보안**: 인증/인가/레이트리밋/CORS/CSP/로깅 마스킹  
- [ ] **관측가능성**: request_id, 구조화 로깅, APM/트레이스, 에러율/지연 측정  
- [ ] **버전/폐기** 공지 흐름(Deprecation/Sunset)  
- [ ] **문서 품질**: 예시/오류응답/스키마 정의, SDK 생성 가능성 고려

---

## 4.12 흔한 안티패턴

- **모든 실패를 400으로**: 의미 손실 → `401/403/404/409/422/429` 구분  
- **요청/응답 스키마 무문서**: 클라이언트-서버 엇박자 → OpenAPI로 싱글 소스  
- **검증 누락**: DB 제약 에러를 그대로 500으로 노출  
- **하드코딩 URL**: 게이트웨이/프록시 환경에서 실패  
- **Idempotency 미적용**: 리트라이에서 중복 과금/주문  
- **캐시 무시**: 과도한 읽기 비용/지연

---

## 4.13 미니 프로젝트 골격(통합 스캐폴딩)

```python
# app/__init__.py
from flask import Flask
from flask_smorest import Api
from app.errors import errors_bp

def create_app():
    app = Flask(__name__)
    app.config.update(
        API_TITLE="Shop API",
        API_VERSION="1.0.0",
        OPENAPI_VERSION="3.0.3",
        OPENAPI_URL_PREFIX="/",
        OPENAPI_JSON_PATH="openapi.json",
        OPENAPI_SWAGGER_UI_PATH="/docs",
        OPENAPI_SWAGGER_UI_URL="https://cdn.jsdelivr.net/npm/swagger-ui-dist/"
    )
    api = Api(app)
    from app.apis.items_smorest import blp as items_blp
    api.register_blueprint(items_blp, url_prefix="/api/v1")
    app.register_blueprint(errors_bp)
    return app
```

```python
# wsgi.py
from app import create_app
app = create_app()
```

---

## 4.14 마무리

이 장에서는 **JSON API 설계 원칙(상태코드/에러 규약/페이징/캐시/멱등)** 과 함께, **Marshmallow/Pydantic** 으로 **입출력 스키마를 엄격히 정의**하고, **flask-smorest** 와 **flask-restx** 로 **OpenAPI 문서**를 자동화하는 방법을 실제 코드와 함께 다뤘다.