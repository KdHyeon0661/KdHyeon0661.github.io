---
layout: post
title: MFC - GDI 기초
date: 2025-09-01 15:25:23 +0900
category: MFC
---
# GDI 기초: DC, 펜/브러시/비트맵, 더블 버퍼링, 깜빡임 방지 (MFC/Win32 실전 총정리)

이 글은 **MFC/Win32 GDI**의 핵심을 **처음부터 탄탄히** 다집니다.  
**DC(Device Context)**, **펜/브러시/비트맵**, **텍스트/클리핑**, **더블 버퍼링(오프스크린 렌더링)**, **깜빡임(플리커) 방지**까지 **실전 코드**를 곁들여 **빠짐없이** 설명합니다.

> 대상: MFC SDI/MDI/대화상자 앱, Windows 10/11, Unicode/x64 권장  
> 표기: MFC 클래스(`CPaintDC`, `CDC`, `CBitmap`, …)와 Win32 API(`CreatePen`, `BitBlt`, …)를 혼용 설명

---

## 0) 한눈에 보기 — “GDI 실무 흐름”

1) **DC 확보**  
   - 화면 그리기: `CPaintDC`(WM_PAINT 내부), `CClientDC`(즉시 그리기)  
   - 메모리 DC(오프스크린): `CDC::CreateCompatibleDC` + `CBitmap` 선택  
2) **그리기 상태(객체) 준비**  
   - **펜**(`CPen`): 선 색/두께/스타일  
   - **브러시**(`CBrush`): 면 색/해치/패턴  
   - **폰트**(`CFont`): 텍스트  
   - **비트맵**(`CBitmap`, `CreateDIBSection`): 이미지/백버퍼  
3) **선택/복원**  
   - `SelectObject`로 DC에 선택 → 그리기 → **원래 객체로 복원**  
4) **렌더**  
   - 선/면: `MoveToEx`/`LineTo`, `Rectangle`, `Ellipse`, `Polygon`  
   - 이미지: `BitBlt`, `StretchBlt`, `AlphaBlend`  
   - 텍스트: `TextOut`, `DrawText`, `SetBkMode(TRANSPARENT)`  
5) **플리커 방지**  
   - **더블 버퍼링**: 메모리 DC에 모두 그린 뒤 화면 DC로 **한 번에 BitBlt**  
   - `WM_ERASEBKGND` 최소화, 배경은 **오프스크린에서 채우기**  
6) **리소스 관리**  
   - `DeleteObject/ReleaseDC` vs MFC의 **RAII**(`CBitmap::DeleteObject`, `CPen::DeleteObject`)  
   - **선택한 객체는 다시 원래 것으로 되돌린 다음 삭제**

---

# 1) DC(Device Context) — 무엇이며 어떻게 쓰나

### 1-1. DC의 종류 (화면/메모리/프린터)

| 종류 | 사용 클래스/함수 | 용도 | 비고 |
|---|---|---|---|
| 페인트 DC | `CPaintDC dc(this);` | **WM_PAINT 처리 중** 그리기 | `BeginPaint/EndPaint` 래핑 |
| 클라이언트 DC | `CClientDC dc(this);` | WM_PAINT 외 즉시 그리기 | 잦은 사용은 지양(깨짐) |
| 윈도우 DC | `GetWindowDC()` | Non-client 영역(캡션/테두리) 그리기 | 드묾 |
| 메모리 DC | `CDC mem; mem.CreateCompatibleDC(&dc)` | **오프스크린** 렌더링 | 더블 버퍼 핵심 |
| 호환 DC | `CreateCompatibleDC(hdc)` | 해당 DC와 **픽셀 포맷 일치** | 화면/프린터와 호환 |
| 프린터 DC | 인쇄 DC | 인쇄/프리뷰 | DPI/맵핑모드 주의 |

**권장**: 화면 갱신은 **반드시** `WM_PAINT`에서 `CPaintDC`를 사용.  
즉시 그리기(`CClientDC`)는 간단 표시 외에는 **추천하지 않음**(다음 WM_PAINT에 의해 덮임).

---

### 1-2. 최소 골격 (WM_PAINT)

```cpp
void CMyView::OnPaint() {
    CPaintDC dc(this);                     // 1) 그릴 DC
    CRect rc; GetClientRect(&rc);

    // 2) GDI 객체 준비(펜/브러시/폰트 등)
    CPen pen(PS_SOLID, 1, RGB(30,144,255));
    CBrush brush(RGB(245,250,255));
    auto pOldPen   = dc.SelectObject(&pen);
    auto pOldBrush = dc.SelectObject(&brush);

    // 3) 그리기
    dc.Rectangle(rc);

    // 4) 복원
    dc.SelectObject(pOldPen);
    dc.SelectObject(pOldBrush);
}
```

> **복원 규칙**: DC에 `SelectObject`로 새 객체를 넣으면, **작업 끝**에 **원래 객체로 되돌린 뒤** 새 객체를 삭제하세요.

---

# 2) 펜/브러시/폰트 — 선·면·텍스트의 기본

### 2-1. 펜(CPen/HPEN)

- 생성: `CPen pen(PS_SOLID, 2, RGB(0,120,215));`
- 스타일: `PS_SOLID`, `PS_DASH`, `PS_DOT`, `PS_DASHDOT`, `PS_NULL`(선 없음)
- 고급: `ExtCreatePen`(원형/사각 캡, 조인 스타일, 사용자 패턴)

```cpp
CPen pen(PS_DASH, 2, RGB(200,0,0));
auto old = dc.SelectObject(&pen);
dc.MoveTo(10, 10); dc.LineTo(200, 10);
dc.SelectObject(old);
```

**ExtCreatePen 예(원형 캡/라운드 조인)**

```cpp
LOGBRUSH lb{ BS_SOLID, RGB(0,160,0), 0 };
HPEN hWide = ExtCreatePen(PS_GEOMETRIC | PS_ENDCAP_ROUND | PS_JOIN_ROUND,
                          8, &lb, 0, nullptr);
HPEN hOld = (HPEN)SelectObject(dc, hWide);
MoveToEx(dc, 20, 50, nullptr); LineTo(dc, 220, 120);
SelectObject(dc, hOld); DeleteObject(hWide);
```

> **GEOMETRIC 펜**은 두께가 논리 단위(월드 좌표)에 의존하며, **엔드캡/조인** 제어 가능.

---

### 2-2. 브러시(CBrush/HBRUSH)

- 단색: `CBrush b(RGB(240,240,240));`
- 해치: `CreateHatchBrush(HS_DIAGCROSS, RGB(0,0,255))`
- 패턴: 비트맵 브러시(작은 타일을 반복)

```cpp
CBrush solid(RGB(255, 250, 230));
auto oldB = dc.SelectObject(&solid);
dc.Rectangle(10, 10, 200, 100);
dc.SelectObject(oldB);
```

**해치 브러시**

```cpp
CBrush hatch; hatch.CreateHatchBrush(HS_BDIAGONAL, RGB(0, 80, 200));
auto old = dc.SelectObject(&hatch);
dc.Ellipse(30, 30, 180, 140);
dc.SelectObject(old);
```

---

### 2-3. 폰트(CFont/HFONT) & 텍스트

- 생성: `CFont f; f.CreatePointFont(100, L"Segoe UI");` (10pt)
- 텍스트: `TextOut`, `DrawText`
- 배경: `SetBkMode(TRANSPARENT)`, `SetTextColor`

```cpp
CFont f; f.CreatePointFont(110, L"Segoe UI");
auto pf = dc.SelectObject(&f);
int oldBk = dc.SetBkMode(TRANSPARENT);
COLORREF oldTx = dc.SetTextColor(RGB(30,30,30));

dc.TextOut(20, 20, L"Hello, GDI!");
CRect rc(20, 50, 260, 120);
dc.DrawText(L"멀티라인 텍스트\n왼쪽 정렬", &rc, DT_LEFT | DT_WORDBREAK);

dc.SetTextColor(oldTx);
dc.SetBkMode(oldBk);
dc.SelectObject(pf);
```

> **가독성**: 항상 `TRANSPARENT` + 배경은 직접 칠하기(더블 버퍼링과 궁합).

---

# 3) 비트맵: DDB vs DIB, 로딩/그리기/스케일

### 3-1. DDB(장치 종속) vs DIB(장치 독립)

| 유형 | 특징 | 생성 | 언제 |
|---|---|---|---|
| DDB | 장치에 최적화, 포맷 불명확 | `CreateCompatibleBitmap` | 단순 백버퍼/빠른 BitBlt |
| DIB | 명시적 포맷(BITMAPINFO), 픽셀 접근 쉬움 | `CreateDIBSection` | 이미지 처리/알파/저장·로드 |

**DDB 백버퍼 예(간단/빠름)**  
→ 더블 버퍼링 섹션에서 실습

**DIB 섹션 생성 예(32bpp ARGB)**

```cpp
BITMAPINFO bi{}; bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
bi.bmiHeader.biWidth = width;
bi.bmiHeader.biHeight = -height;          // top-down
bi.bmiHeader.biPlanes = 1;
bi.bmiHeader.biBitCount = 32;
bi.bmiHeader.biCompression = BI_RGB;

void* pBits = nullptr;
CBitmap dib;
dib.CreateDIBSection(nullptr, &bi, DIB_RGB_COLORS, &pBits, nullptr, 0);
// pBits를 RGBA로 직접 채우기 가능
```

---

### 3-2. Blt/Stretch/Alpha

- **BitBlt**: 1:1 복사  
- **StretchBlt**: 크기 변환(보간은 GDI 품질 한계)  
- **AlphaBlend**(msimg32.lib): 알파 합성(소스 상수/프레멀티플 옵션)

```cpp
// srcDC → dstDC로 복사
dc.BitBlt(x, y, w, h, &src, sx, sy, SRCCOPY);

// 스트레치
dc.StretchBlt(x, y, W, H, &src, sx, sy, w, h, SRCCOPY);

// 알파
BLENDFUNCTION bf{ AC_SRC_OVER, 0, 180 /*0..255*/, 0 /*AC_SRC_ALPHA=1*/ };
AlphaBlend(dc, x,y,w,h, src, sx,sy,w,h, bf);
```

> **AlphaBlend**의 `AC_SRC_ALPHA`를 쓰려면 **소스 비트맵이 프레멀티플 알파**여야 합니다(직접 생성 시 유의).

---

# 4) 클리핑/무효화/배경지우기

### 4-1. Invalidate/Update/WM_ERASEBKGND

- 변경 영역만 갱신: `InvalidateRect(&rc, FALSE)`, `UpdateWindow()`  
- 배경지우기 억제: **오프스크린에서 전체 배경을 칠한다면** `WM_ERASEBKGND`에서 **TRUE 반환** 또는 **아무것도 하지 않기**(MFC는 기본 처리에서 배경 지움 → 플리커 발생)

```cpp
BOOL CMyView::OnEraseBkgnd(CDC* pDC) {
    // 더블 버퍼링으로 전체를 그릴 것이므로 별도 지우지 않음
    return TRUE; // 배경 지우기 완료로 간주 → 깜빡임 감소
}
```

---

### 4-2. 클리핑(Region/Rect) — 부분만 그리기

```cpp
CRgn rgn; rgn.CreateRectRgn(50, 50, 200, 150);
dc.SelectClipRgn(&rgn);
dc.Rectangle(0, 0, 300, 200);  // 클립 밖은 그려지지 않음
dc.SelectClipRgn(nullptr);     // 클립 해제
```

> **InvalidateRgn**과 조합하면 큰 화면에서 **부분 갱신**으로 성능 ↑

---

# 5) 더블 버퍼링(오프스크린 렌더링) — 플리커 방지의 핵심

더블 버퍼링은 **메모리 DC**에 모든 그림을 그리고, 마지막에 **한 번의 BitBlt**로 화면에 복사하는 기법입니다.

### 5-1. 1회성 백버퍼(매 WM_PAINT)

```cpp
void CMyView::OnPaint() {
    CPaintDC dc(this);
    CRect rc; GetClientRect(&rc);

    // 1) 메모리 DC + 백버퍼 비트맵
    CDC mem; mem.CreateCompatibleDC(&dc);
    CBitmap buf; buf.CreateCompatibleBitmap(&dc, rc.Width(), rc.Height());
    auto oldBmp = mem.SelectObject(&buf);

    // 2) 배경 칠하기(여기서!)
    mem.FillSolidRect(rc, RGB(255,255,255));

    // 3) 오프스크린에 모든 그리기 수행
    CPen pen(PS_SOLID, 2, RGB(0,120,215));
    auto oldPen = mem.SelectObject(&pen);
    mem.Rectangle(20, 20, 200, 120);
    mem.SelectObject(oldPen);

    // 4) 화면으로 복사(한 방에)
    dc.BitBlt(0, 0, rc.Width(), rc.Height(), &mem, 0, 0, SRCCOPY);

    // 5) 복원/정리
    mem.SelectObject(oldBmp);
}
```

> 장점: 구현 간단/가장 확실한 플리커 제거  
> 단점: **매 페인트 때** 백버퍼 생성/해제 → 큰 창에서 비용 ↑

---

### 5-2. **캐시형 백버퍼**(창 크기 바뀔 때만 다시 만든다)

```cpp
class CMyView : public CView {
    CDC     m_memDC;
    CBitmap m_backBmp;
    CSize   m_bufSize{0,0};

    void EnsureBackBuffer(CDC* pScreen, CSize need) {
        if (need.cx == m_bufSize.cx && need.cy == m_bufSize.cy && m_memDC.m_hDC) return;
        // 재생성
        m_memDC.DeleteDC(); m_backBmp.DeleteObject();
        m_memDC.CreateCompatibleDC(pScreen);
        m_backBmp.CreateCompatibleBitmap(pScreen, need.cx, need.cy);
        m_memDC.SelectObject(&m_backBmp);
        m_bufSize = need;
    }

    void RedrawOffscreen() {
        CRect rc(0,0,m_bufSize.cx, m_bufSize.cy);
        m_memDC.FillSolidRect(rc, RGB(255,255,255));
        // ... heavy drawing ...
    }

    afx_msg void OnSize(UINT, int cx, int cy) {
        CClientDC screen(this);
        EnsureBackBuffer(&screen, {cx, cy});
        RedrawOffscreen();
        Invalidate(FALSE);
    }

    void OnPaint() override {
        CPaintDC dc(this);
        if (!m_memDC.m_hDC) { CClientDC screen(this); EnsureBackBuffer(&screen, GetClientRectSize()); RedrawOffscreen(); }
        CRect rc; GetClientRect(&rc);
        dc.BitBlt(0,0,rc.Width(),rc.Height(), &m_memDC, 0,0, SRCCOPY);
    }
};
```

> 장점: 큰 캔버스에서 **반복 생성 비용 절감**, 복잡한 씬에 적합  
> 주의: 내용 변경 시 **`RedrawOffscreen()`** 호출로 캐시 무효화

---

### 5-3. **Buffered Paint API**(DWM 도움, Vista+)

Windows는 `BufferedPaint`(UxTheme) API를 제공합니다. GDI+와 혼용 시 품질/성능이 좋은 편.

```cpp
#include <uxtheme.h>
#pragma comment(lib, "uxtheme.lib")

void CMyView::OnPaint() {
    CPaintDC dc(this); CRect rc; GetClientRect(&rc);
    HDC hdcPaint = nullptr;
    HPAINTBUFFER hbuf = BeginBufferedPaint(dc, &rc, BPBF_COMPATIBLEBITMAP, nullptr, &hdcPaint);
    if (hbuf) {
        // hdcPaint에 그리기(오프스크린)
        RECT r{rc.left, rc.top, rc.right, rc.bottom};
        HBRUSH bg = CreateSolidBrush(RGB(255,255,255));
        FillRect(hdcPaint, &r, bg); DeleteObject(bg);
        // ... 기타 GDI 호출 ...
        EndBufferedPaint(hbuf, TRUE); // TRUE=커밋
    }
}
```

> 장점: 코드 간결, 시스템 최적화  
> 단점: 의존성 및 세밀 제어는 직접 더블버퍼가 낫기도

---

# 6) 깜빡임(플리커) 원인 & 방지 체크리스트

**원인**
- 배경을 먼저 지우고(흰 플래시) 그 위에 다시 그리는 **두 단계**가 보일 때  
- 많은 컨트롤이 **개별로 WM_ERASEBKGND**를 수행할 때  
- 즉시 그리기(`CClientDC`)와 `WM_PAINT`가 엇갈려 갱신 순서가 꼬일 때

**방지**
1. **더블 버퍼링**(오프스크린에서 전부 그린 후 한 번에 복사)  
2. `OnEraseBkgnd`에서 **TRUE 반환**하고, 배경 채우기는 **오프스크린**에서  
3. **컨트롤 깜빡임** 감소: 부모가 `WS_CLIPCHILDREN`, 자식이 `WS_CLIPSIBLINGS`(상황 따라)  
4. 텍스트는 `SetBkMode(TRANSPARENT)` + 배경은 오프스크린에서 칠하기  
5. 스크롤/리사이즈 시 **부분 무효화**(`ScrollWindowEx`, `InvalidateRect` 최소화)  
6. **WS_EX_COMPOSITED**는 트레이드오프 큼(성능/입력 지연) → 일반적으로 **비권장**  
7. 고빈도 타이머 드로잉은 **프레임 제한**(예: 60Hz) 또는 더티 영역만 갱신

---

# 7) 고급: 좌표/맵핑/펜 조인, 라스터 연산(ROP), 텍스트 품질

### 7-1. 맵핑 모드 & 좌표

- 기본: `MM_TEXT`(픽셀 1:1)  
- 인쇄/강력한 좌표계: `MM_ANISOTROPIC`으로 `SetWindowExt/SetViewportExt`  
- 오리진: `SetViewportOrg`로 이동(좌상단 여백 등)

```cpp
dc.SetMapMode(MM_ANISOTROPIC);
dc.SetWindowExt(1000, 1000);                 // 논리 1000x1000
dc.SetViewportExt(rc.Width(), rc.Height());  // 디바이스 크기에 맞춤
dc.SetViewportOrg(0,0);
```

---

### 7-2. 라스터 연산(ROP)

- `BitBlt`/`PatBlt` ROP로 특수 효과  
- 대표: `SRCCOPY`(일반), `SRCINVERT`, `SRCAND`, `SRCPAINT`, `BLACKNESS`, `WHITENESS`

```cpp
dc.PatBlt(0,0, rc.Width(), rc.Height(), BLACKNESS); // 검정 채우기
```

> 복잡한 합성은 GDI+ 또는 Direct2D 권장. GDI ROP는 한계가 분명.

---

### 7-3. 텍스트 품질 & ClearType

- `SetBkMode(TRANSPARENT)` 필수  
- `SetTextColor`로 선명한 대비  
- 폰트 힌팅/안티앨리어싱은 시스템 설정 영향  
- GDI 텍스트 품질은 `SetBkMode`, 폰트 선택, 해상도에 좌우 → **UI 폰트**(`Segoe UI`) 권장

---

# 8) 리소스/수명/RAII — 누수 없는 코드

### 8-1. 선택/복원 패턴

```cpp
CPen pen(PS_SOLID, 1, RGB(0,0,0));
auto oldPen = dc.SelectObject(&pen);
// ... draw ...
dc.SelectObject(oldPen); // 반드시!
```

### 8-2. MFC 객체와 DeleteObject

- MFC 객체(`CPen`, `CBrush`, `CBitmap`)는 소멸자에서 자동 삭제 X → **`DeleteObject()`** 호출하거나, 스택 수명으로 자동 정리되게 쓰기  
- `CDC`는 `DeleteDC()`, `CFont`는 `DeleteObject()`  
- `CClientDC`/`CPaintDC`는 소멸 시 자동 Release

---

# 9) 종합 실습 — “줌 가능한 그래픽 뷰” (더블 버퍼/부분 갱신)

**기능**
- 마우스 휠로 확대/축소  
- 화면은 **캐시 백버퍼**에 렌더 → `BitBlt`  
- 배경/격자/도형/텍스트를 오프스크린에서 모두 그리기(플리커 제로)

```cpp
class CZoomView : public CWnd {
    DECLARE_DYNAMIC(CZoomView)
public:
    BOOL Create(CWnd* parent) {
        return CWnd::Create(nullptr, L"ZoomView", WS_CHILD|WS_VISIBLE, CRect(0,0,100,100), parent, 0);
    }

protected:
    CDC     m_memDC;
    CBitmap m_bmp;
    CSize   m_sz{0,0};
    double  m_zoom = 1.0;

    void EnsureBuffer(int cx, int cy) {
        if (cx == m_sz.cx && cy == m_sz.cy && m_memDC.m_hDC) return;
        CClientDC screen(this);
        m_memDC.DeleteDC(); m_bmp.DeleteObject();
        m_memDC.CreateCompatibleDC(&screen);
        m_bmp.CreateCompatibleBitmap(&screen, cx, cy);
        m_memDC.SelectObject(&m_bmp);
        m_sz = {cx, cy};
    }

    void DrawOffscreen() {
        CRect rc(0,0,m_sz.cx, m_sz.cy);
        m_memDC.FillSolidRect(rc, RGB(255,255,255));

        // 격자(줌 반영)
        CPen grid(PS_DOT, 1, RGB(220,220,220));
        auto oldPen = m_memDC.SelectObject(&grid);
        int step = int(20 * m_zoom); step = max(8, step);
        for (int x=0; x<rc.right; x+=step) { m_memDC.MoveTo(x,0); m_memDC.LineTo(x,rc.bottom); }
        for (int y=0; y<rc.bottom; y+=step){ m_memDC.MoveTo(0,y); m_memDC.LineTo(rc.right,y); }
        m_memDC.SelectObject(oldPen);

        // 도형
        CPen pen(PS_SOLID, max(1, (int)(2*m_zoom)), RGB(0,120,215));
        CBrush br(RGB(245,250,255));
        auto op = m_memDC.SelectObject(&pen);
        auto ob = m_memDC.SelectObject(&br);
        CRect r(50,50, 250,150);
        r.left   = int(r.left   * m_zoom);
        r.top    = int(r.top    * m_zoom);
        r.right  = int(r.right  * m_zoom);
        r.bottom = int(r.bottom * m_zoom);
        m_memDC.RoundRect(r, CPoint(12*m_zoom, 12*m_zoom));
        m_memDC.SelectObject(ob);
        m_memDC.SelectObject(op);

        // 텍스트
        CFont f; f.CreatePointFont((int)(100*m_zoom), L"Segoe UI");
        auto pf = m_memDC.SelectObject(&f);
        int oldBk = m_memDC.SetBkMode(TRANSPARENT);
        m_memDC.SetTextColor(RGB(30,30,30));
        m_memDC.TextOut(10, int(10*m_zoom), L"Zoomed View");
        m_memDC.SetBkMode(oldBk);
        m_memDC.SelectObject(pf);
    }

    afx_msg void OnPaint() {
        CPaintDC dc(this);
        CRect rc; GetClientRect(&rc);
        EnsureBuffer(rc.Width(), rc.Height());
        DrawOffscreen();
        dc.BitBlt(0,0,rc.Width(), rc.Height(), &m_memDC, 0,0, SRCCOPY);
    }

    afx_msg BOOL OnEraseBkgnd(CDC*) { return TRUE; }
    afx_msg void OnSize(UINT, int cx, int cy) {
        EnsureBuffer(cx, cy);
        Invalidate(FALSE);
    }
    afx_msg BOOL OnMouseWheel(UINT, short zDelta, CPoint) {
        double s = (zDelta > 0) ? 1.1 : 0.9;
        m_zoom = std::clamp(m_zoom*s, 0.25, 8.0);
        Invalidate(FALSE);
        return TRUE;
    }

    DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CZoomView, CWnd)
    ON_WM_PAINT()
    ON_WM_ERASEBKGND()
    ON_WM_SIZE()
    ON_WM_MOUSEWHEEL()
END_MESSAGE_MAP()
```

---

# 10) 성능/안정성/테스트 체크리스트

1. **더블 버퍼 기본값**: 모든 커스텀 그리기는 **오프스크린**에 먼저  
2. **WM_ERASEBKGND**: **TRUE 반환**(배경은 오프스크린에서 채우기)  
3. **큰 창/고DPI**: **캐시형 백버퍼**(리사이즈 때만 재생성)  
4. **부분 무효화**: 더티 영역만 `InvalidateRect`  
5. **SelectObject 복원**: GDI 객체 누수/비정상 드로잉 예방  
6. **DIBSection**: 픽셀 액세스/알파 필요 시 32bpp top-down  
7. **AlphaBlend**: 프레멀티플 알파 유지  
8. **폰트**: `Segoe UI`/`TRANSPARENT`/명확한 대비  
9. **컨트롤 깜빡임**: 필요 시 **오너 드로우/커스텀 드로우** + 더블 버퍼  
10. **스레드**: GDI는 스레드 안전 X → **UI 스레드에서만 그리기**  
11. **도구**: `GDIView`, `Process Explorer`로 GDI 객체 수 모니터링  
12. **테스트**: 100~300% DPI, 고Hz 디스플레이에서 플리커/성능 체크

---

## 부록 A) 자주 쓰는 코드 조각

**픽셀 알파 채우기(DIB 32bpp)**

```cpp
struct RGBA { BYTE b,g,r,a; };
auto* px = (RGBA*)pBits;
for (int y=0; y<height; ++y) {
    for (int x=0; x<width; ++x) {
        px[x] = { 200, 100, 50, 180 }; // B,G,R,A (프레멀티플이면 r,g,b *= a/255)
    }
    px += width;
}
```

**안전한 선택/복원 헬퍼(RAII)**

```cpp
template<typename TDC, typename TOBJ>
struct ScopedSelect {
    TDC& dc; HGDIOBJ old{};
    ScopedSelect(TDC& d, TOBJ* o) : dc(d), old(dc.SelectObject(o)) {}
    ~ScopedSelect(){ if (old) dc.SelectObject(old); }
};

// 사용
CPen p(PS_SOLID,1,RGB(0,0,0));
ScopedSelect guard(dc, &p);
dc.LineTo(100,100);
```

**고정 FPS 타이머(애니메이션)**

```cpp
SetTimer(1, 16, nullptr); // 약 60Hz
void OnTimer(UINT_PTR id) {
    if (id==1) { UpdateScene(); Invalidate(FALSE); }
}
```

---

## 부록 B) 자주 겪는 문제와 해결

| 증상 | 원인 | 해결 |
|---|---|---|
| 그릴 때마다 화면이 번쩍거린다 | 배경 지우기 + 전면 그리기 순서가 보임 | **더블 버퍼** + `OnEraseBkgnd=TRUE` |
| 선 두께가 DPI/확대에서 이상 | 기하 펜/맵핑 모드 처리 부족 | `ExtCreatePen(PS_GEOMETRIC…)` + `MM_ANISOTROPIC` |
| 텍스트 배경 박스가 보인다 | `OPAQUE` 배경 | `SetBkMode(TRANSPARENT)` |
| 비트맵이 거칠게 스케일 | GDI Stretch 품질 한계 | 원본 해상도 고려/`StretchBlt` 대신 미리 스케일 |
| AlphaBlend가 흐릿/색 번짐 | 프레멀티플 알파 아님 | 소스 RGBA **프레멀티플**로 공급 |
| GDI 객체 누수 | SelectObject 복원 누락/삭제 누락 | 선택 복원 후 `DeleteObject` 철저 |
| 컨트롤 깜빡임 | 각 컨트롤의 배경 지우기 | 부모에서 오프스크린, 필요 시 오너드로우 |

---

## 결론

- **DC의 수명/종류**를 이해하고, **펜/브러시/폰트/비트맵**을 **선택→복원** 패턴으로 다루면 **안정성**이 확보됩니다.  
- **더블 버퍼링**은 **플리커 방지의 정석**입니다. **오프스크린에서 배경까지 모두 그린 뒤** 화면에 **한 번에 복사**하세요.  
- 고DPI/대화면 시대에 **캐시형 백버퍼 + 부분 무효화**로 **성능**을 챙기고, 텍스트/색 대비/알파를 다듬어 **품질**을 끌어올리세요.

필요하시면 **당신의 프로젝트 구조**(뷰/대화상자/컨트롤)로 맞춘 **더블 버퍼링 템플릿**을 곧장 만들어 드릴게요. 🙂
