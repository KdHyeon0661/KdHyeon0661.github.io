---
layout: post
title: DB 심화 - Redo
date: 2025-10-15 20:25:23 +0900
category: DB 심화
---
# Oracle Redo 완전 정복(Oracle Database 19c 기준)

> 목표
> - Redo가 정확히 **무엇을 기록하는지**, 언제/어떻게 기록되는지, 커밋과 어떤 관계인지, 복구에서 어떤 역할을 하는지 끝까지 설명
- Redo Log Buffer → LGWR → Online Redo Log → Archived Redo Log → Media Recovery → Data Guard까지 흐름을 실제로 따라가며 본다
- 성능/튜닝 관점(LGWR 대기, 로그 스위치, 체크포인트, I/O 모델)과 실습 SQL 포함
- Undo와의 차이도 명확히 구분
- “redo size가 많다 = 나쁜가?”, “로그 스위치가 잦다 = 왜 문제?” 같은 실무 질문에 답을 줄 수 있게 만든다

---

## Redo란 무엇인가?

**Redo는 데이터베이스 블록에 발생한 모든 변경 사항을 재현 가능한 형태로 순차적으로 기록한 저널(Journal)입니다.** 더 구체적으로 말하면, 버퍼 캐시에서 특정 블록이 어떻게 바뀌었는지를 캡쳐한 물리적 로그 레코드의 집합체입니다.

이 기록의 핵심 가치는 **디스크에 아직 반영되지 않은 변경(Dirty Buffer)도 이미 Redo에 안전하게 저장되어 있다는 점**입니다. 데이터 파일보다 Redo가 더 빨리 '진실'을 알고 있는 셈입니다. 이러한 설계는 다음과 같은 오라클의 핵심 철학을 구현합니다:

1.  모든 변경은 먼저 SGA의 버퍼 캐시에서 발생합니다.
2.  변경 내용은 즉시 **Redo Log Buffer**에 레코드로 기록됩니다.
3.  **LGWR(Log Writer)** 프로세스가 이 Redo를 **Online Redo Log 파일**에 동기적으로 플러시합니다.
4.  커밋은 해당 트랜잭션의 Redo가 디스크에 안전하게 기록되었는지(LGWR 플러시 완료) 확인하는 것으로 완료됩니다.
5.  **DBWn(Database Writer)** 프로세스는 나중에 Dirty Buffer를 데이터 파일에 비동기적으로 기록합니다. 이는 커밋과 직접적인 연관이 없습니다.
6.  인스턴스 장애가 발생하더라도, 온라인 및 아카이브된 리두 로그를 재생(Apply)하면 데이터베이스를 장애 발생 직전의 일관된 상태로 복원할 수 있습니다.

> **핵심 정리: Redo는 커밋의 내구성(Durability)을 보장하는 메커니즘입니다. 데이터 파일에 쓰이지 않았더라도 Redo만 있으면 모든 커밋된 변경 사항을 복구할 수 있습니다.**

---

## Redo와 Undo를 명확히 구분하기

이 두 개념은 종종 혼동되지만 목적과 역할이 근본적으로 다릅니다.

### Redo (재실행 로그)

-   **방향성**: 변경 "행위" 자체를 기록하여, 미래에 **앞으로 재적용(Re-DO)** 할 수 있게 합니다.
-   **주요 목적**: 인스턴스 복구(Crash Recovery), 미디어 복구(Media Recovery), Data Guard를 통한 복제.
-   **저장 위치**: Redo Log Buffer → Online Redo Log 파일 → (선택적) Archived Redo Log 파일.
-   **주체**: **LGWR(Log Writer)** 프로세스가 기록을 담당합니다.

### Undo (되돌리기 로그)

-   **방향성**: 변경되기 "전"의 데이터 값(Before Image)을 저장하여, **과거 상태로 되돌리기(Un-DO)** 할 수 있게 합니다.
-   **주요 목적**: 트랜잭션 롤백, 읽기 일관성(Consistent Read) 제공, Flashback 기능 지원.
-   **저장 위치**: **Undo Tablespace** 내의 UNDO 세그먼트.
-   **주체**: DML을 수행하는 서버 프로세스가 Undo 레코드를 생성하고 관리합니다.

**비유하자면:**
-   **Redo**는 "요리사가 요리를 만드는 **과정(레시피)** 을 적은 기록"입니다.
-   **Undo**는 "요리하기 **전의 재료 상태**를 찍어둔 사진"입니다.

이 두 메커니즘이 함께 작동하여 ACID 트랜잭션의 **원자성(Atomicity: Undo를 통한 롤백)**, **일관성(Consistency: Undo를 통한 일관된 읽기)**, **내구성(Durability: Redo를 통한 커밋 보장)** 을 실현합니다.

---

## Redo의 생성부터 기록까지: DML 한 줄의 여정

`INSERT INTO t VALUES (1); COMMIT;` 이라는 간단한 명령어가 내부적으로 Redo를 통해 어떻게 처리되는지 단계별로 따라가 보겠습니다.

1.  **DML 실행 단계**
    -   서버 프로세스가 필요한 테이블/인덱스 블록을 버퍼 캐시로 읽어옵니다(미스시 물리적 I/O 발생).
    -   블록을 수정하기 시작하면:
        -   변경 **전**의 값은 **Undo 세그먼트**에 기록됩니다. (Undo 생성)
        -   변경 **내용**은 **Redo 레코드**로 변환되어 **Redo Log Buffer**에 적재됩니다. (Redo 생성)

2.  **커밋 전 상태**
    -   트랜잭션은 아직 커밋되지 않았습니다.
    -   버퍼 캐시의 블록은 'Dirty' 상태이지만, DBWn은 이를 즉시 디스크에 쓸 의무가 없습니다.
    -   Redo Log Buffer의 내용도 아직 온라인 리두 로그 파일에 플러시되지 않았을 수 있습니다.

3.  **커밋 실행 단계 (가장 중요!)**
    -   오라클은 커밋 요청을 받는 순간, 해당 트랜잭션의 모든 Redo 레코드(및 커밋 레코드 자체)가 **Online Redo Log 파일에 동기적으로 기록되었는지**를 보장해야 합니다.
    -   LGWR 프로세스가 Redo Log Buffer의 해당 내용을 디스크로 플러시(`fsync`)하고, 그 완료를 확인하는 순간 커밋이 '완료'되었다고 클라이언트에 응답합니다.
    -   **즉, 커밋의 속도와 지연은 LGWR의 I/O 성능에 직접적으로 좌우됩니다.**

4.  **커밋 이후**
    -   트랜잭션은 논리적으로 종료되었습니다.
    -   데이터 파일에는 변경 내용이 아직 반영되지 않았을 수 있습니다(DBWn의 비동기 쓰기).
    -   하지만 **Redo는 이미 디스크에 안전하게 저장**되어 있습니다. 이 시점에 인스턴스 장애가 발생해도, 재시작 시 SMON 프로세스가 Redo를 재생하여 커밋된 내용을 데이터 파일에 복원할 수 있습니다.

**요약: Redo는 즉시적, 순차적, 동기적으로 기록되어 커밋을 보장하는 반면, 데이터 파일의 쓰기는 지연적, 배치적, 비동기적으로 처리됩니다.**

---

## Redo 저장소의 계층적 구조

Redo 데이터는 다음과 같은 여러 계층의 저장소를 거치며 이동합니다.

1.  **Redo Log Buffer (SGA 내부)**
    -   Redo 레코드가 처음으로 쌓이는 작고 빠른 메모리 버퍼입니다.
    -   `log_buffer` 파라미터로 크기를 제어합니다.
    -   LGWR는 커밋 발생 시, 버퍼가 1/3 찼을 때, 혹은 약 1초(내부 타이머)마다 등 특정 트리거에 의해 이 버퍼를 플러시합니다.

2.  **Online Redo Log Files (디스크)**
    -   디스크 상의 순차적 로그 파일 세트입니다.
    -   여러 **로그 그룹(Group)** 으로 구성되며, 가용성을 위해 각 그룹 내에 **복수 멤버(Member)** 를 둘 수 있습니다(미러링).
    -   LGWR는 항상 **현재 그룹(Current Group)** 에만 순차적으로 데이터를 추가(Append) 기록합니다.
    -   현재 그룹이 가득 차면 **로그 스위치(Log Switch)** 가 발생하여 다음 그룹으로 활성 그룹이 전환됩니다.

3.  **Archived Redo Log Files (디스크, ARCHIVELOG 모드 한정)**
    -   로그 스위치로 인해 더 이상 현재 그룹이 아닌(Active/Inactive 상태의) 온라인 리두 로그 파일을 **ARCn(Archiver)** 백그라운드 프로세스가 별도의 위치(디스크, FRA 등)로 복사한 파일입니다.
    -   미디어 복구, 특정 시점 복구(PITR), Data Guard 전송 등에 사용되는 장기 보관용 로그입니다.

이 흐름을 파이프라인으로 표현하면 다음과 같습니다:

```text
[버퍼 캐시에서 DML 발생 → Redo 레코드 생성]
                     ↓
             Redo Log Buffer (SGA 메모리)
                     ↓ (LGWR 동기 플러시)
         Online Redo Log File (디스크, 현재 그룹)
                     ↓ (로그 스위치 시)
      Archived Redo Log File (디스크, 장기 보관)
```

---

## Redo가 왜 '데이터베이스의 생명줄'인가?

Redo는 다음 세 가지 측면에서 오라클 데이터베이스의 핵심이며, 없어서는 안 될 존재입니다.

### 1. 인스턴스 복구 (Crash Recovery)
인스턴스가 비정상 종료되면, 버퍼 캐시에 있던 많은 Dirty 블록들이 데이터 파일에 기록되지 않은 채 사라집니다. 재시작 시 **SMON 프로세스**는 온라인 리두 로그 파일을 읽어 두 단계로 복구를 수행합니다:
-   **Roll Forward (재실행)**: 커밋된/커밋되지 않은 모든 변경을 Redo 로그를 통해 데이터 파일에 재적용하여, 장애 발생 직전의 물리적 상태로 복원합니다.
-   **Roll Back (되돌리기)**: Roll Forward 단계에서 복원된 내용 중, 커밋되지 않은 트랜잭션의 변경사항은 Undo 정보를 이용해 롤백하여 데이터베이스의 논리적 일관성을 확보합니다.

### 2. 미디어 복구 (Media Recovery / PITR)
디스크 손상 등으로 데이터 파일이 유실되거나 오염된 경우, 과거의 백업(예: RMAN 전체 백업)을 복원한 후, 그 백업 시점부터 현재(또는 특정 시점)까지 생성된 **아카이브 리두 로그와 온라인 리두 로그를 재생**함으로써 데이터베이스를 최신 상태로 복구할 수 있습니다. 이를 통해 정해진 시간 내의 어느 시점으로도 복구(Point-In-Time Recovery)가 가능해집니다.

### 3. Data Guard / 스탠바이 데이터베이스
프라이머리 데이터베이스에서 생성된 Redo는 네트워크를 통해 스탠바이 데이터베이스로 전송됩니다. 스탠바이는 이 Redo 스트림을 지속적으로 적용(Redo Apply)함으로써 프라이머리와 실시간에 가깝게 동기화된 상태를 유지합니다. 이는 고가용성(HA)과 재해 복구(DR)의 근간이 됩니다.

**결론적으로, Redo는 커밋된 데이터를 영원히 잃지 않게 하는 복구의 근본이자, 고가용성 아키텍처의 핵심 동기화 수단입니다.**

---

## Online Redo Log 파일 상세: 그룹, 멤버, 로그 스위치

### 구조와 확인 방법
온라인 리두 로그는 **그룹(Group)** 단위로 관리됩니다. 각 그룹은 하나 이상의 동일한 **멤버(Member, 파일)** 로 구성되어 미러링됩니다. LGWR는 한 그룹의 모든 멤버에 동시에 기록합니다.

```sql
-- 로그 그룹 정보 확인 (크기, 상태, 멤버 수)
SELECT group#, bytes/1024/1024 AS size_mb, members, archived, status
FROM   v$log
ORDER  BY group#;

-- 각 그룹의 멤버 파일 경로 확인
SELECT group#, member
FROM   v$logfile
ORDER  BY group#, member;
```
-   `STATUS` 칼럼:
    -   **CURRENT**: LGWR가 현재 기록 중인 그룹.
    -   **ACTIVE**: 인스턴스 복구에 아직 필요합니다. 아직 체크포인트가 완료되지 않았거나, 아카이브가 안 끝난 상태일 수 있습니다.
    -   **INACTIVE**: 인스턴스 복구에 더 이상 필요 없습니다. 재사용(덮어쓰기) 가능한 상태.

### 로그 스위치(Log Switch)와 그 영향
현재 그룹이 가득 차면 LGWR는 **로그 스위치**를 트리거하여 다음 그룹으로 전환합니다. 이때 발생하는 주요 작업은:
1.  CKPT 프로세스가 체크포인트를 발생시켜, DBWn에게 많은 Dirty 버퍼를 데이터 파일에 쓰도록 유도합니다.
2.  ARCHIVELOG 모드라면, ARCn 프로세스가 방금 닫힌 그룹의 리두 로그 파일을 아카이브 로그로 복사하기 시작합니다.

**너무 잦은 로그 스위치의 문제점:**
-   **빈번한 체크포인트**: DBWn이 과도하게 I/O 작업을 수행하게 되어 시스템 전반의 I/O 부하를 증가시킵니다.
-   **아카이브 부하 증가**: ARCn 프로세스가 쉴 새 없이 동작해야 합니다.
-   **성능 저하**: 로그 스위치 자체와 연관된 내부 작업(메타데이터 업데이트 등)이 자주 발생합니다.

**운영 가이드라인:**
일반적인 OLTP 시스템에서는 로그 스위치가 **20~30분에 한 번** 정도 발생하도록 리두 로그 그룹의 크기를 조정하는 것이 권장됩니다. 너무 짧은 간격(예: 수 분 이내)으로 스위치가 발생한다면 리두 로그 크기를 늘리는 것을 고려해야 합니다.

```sql
-- 강제 로그 스위치 (테스트용, DBA 권한 필요)
ALTER SYSTEM SWITCH LOGFILE;
```

---

## ARCHIVELOG 모드: 운영 DB의 필수 조건

### NOARCHIVELOG vs ARCHIVELOG
-   **NOARCHIVELOG 모드**: 온라인 리두 로그 파일이 순환하며 이전 내용을 덮어씁니다. 따라서 가장 최근의 전체 백업 시점까지만 복구가 가능하며, 그 이후의 데이터는 영구 손실될 수 있습니다. 주로 개발/테스트 환경에서 사용됩니다.
-   **ARCHIVELOG 모드**: 로그 스위치로 인해 닫힌 온라인 리두 로그 파일이 아카이브 로그 파일로 보관됩니다. 전체 백업과 이 아카이브 로그들을 결합하면 **어느 시점으로도 복구(PITR)** 가 가능해집니다. 모든 운영(Production) 데이터베이스의 표준 설정입니다.

```sql
-- 현재 아카이브 모드 및 상태 확인
ARCHIVE LOG LIST;
```

### 아카이브 로그와 Data Guard
아카이브 로그는 Data Guard 구성의 핵심입니다. 프라이머리 DB의 아카이브 로그(또는 실시간 Redo 스트림)가 스탠바이 DB로 전송되어 적용됨으로써, 스탠바이는 프라이머리와 논리적/물리적으로 동일한 상태를 유지할 수 있습니다. 이는 재해 발생 시 신속한 역할 전환(Failover)의 기반이 됩니다.

---

## 성능의 핵심: LGWR와 관련 대기 이벤트

Redo 경로에서 발생하는 주요 성능 병목 현상은 다음과 같은 대기 이벤트로 관찰됩니다.

### `log file sync`
-   **의미**: 세션이 `COMMIT`(또는 `ROLLBACK`) 명령을 실행한 후, LGWR가 해당 트랜잭션의 Redo를 온라인 리두 로그 파일에 동기 플러시하기를 기다리는 대기입니다.
-   **원인과 영향**: 이 대기 시간이 길다는 것은 **커밋이 느리다**는 것을 의미하며, 사용자가 느끼는 응답 시간 저하로 직결됩니다. 원인은 주로 느린 스토리지 I/O, 너무 잦은 커밋, 또는 리두 로그 파일 구성 문제입니다.

### `log file parallel write`
-   **의미**: LGWR 프로세스 자신이 리두 로그 파일(멤버들)에 실제 I/O를 수행하는 동안의 대기입니다.
-   **해석**: 이 이벤트의 대기 시간은 LGWR의 I/O 쓰기 지연 시간을 직접적으로 나타냅니다. `log file sync` 대기의 근본 원인 중 하나입니다.

### `log buffer space`
-   **의미**: 서버 프로세스가 Redo Log Buffer에 새로운 Redo 레코드를 기록하려 했지만, 버퍼에 공간이 부족하고 LGWR가 버퍼를 플러시하여 공간을 만들어주길 기다리는 상태입니다.
-   **발생 조건**: 비교적 드물지만, `log_buffer` 크기가 극단적으로 작거나 LGWR의 I/O 속도가 Redo 생성 속도를 따라가지 못할 때 발생할 수 있습니다.

**성능 관측 예시:**

```sql
-- 시스템 레벨의 주요 Redo 대기 이벤트 확인
SELECT event, total_waits, time_waited_micro/1e6 AS sec_waited
FROM   v$system_event
WHERE  event IN ('log file sync', 'log file parallel write', 'log buffer space')
ORDER  BY time_waited_micro DESC;

-- 현재 `log file sync`를 대기 중인 세션 확인
SELECT sid, serial#, username, event, state, seconds_in_wait, sql_id
FROM   v$session
WHERE  event = 'log file sync'
AND    state = 'WAITING';
```

**튜닝 방향성:**
-   **스토리지 최적화**: 온라인 리두 로그 파일은 **가장 빠른 저지연 스토리지(예: 로컬 SSD)** 에 위치시켜야 합니다.
-   **리두 로그 크기 조정**: 너무 잦은 로그 스위치를 방지하여 체크포인트 및 아카이브 부하를 줄입니다.
-   **애플리케이션 설계 검토**: 가능하다면, 자잘한 트랜잭션을 반복적으로 커밋하는 패턴을 배치 커밋으로 변경하는 것을 고려합니다. (단, 비즈니스 요구사항과 트레이드오프 필요)

---

## Redo 생성량과 운영 현황 파악하기

시스템의 Redo 활동을 모니터링하는 것은 쓰기 부하와 잠재적 문제를 파악하는 데 필수적입니다.

```sql
-- 시스템 시작 이후 누적 Redo 관련 통계
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('redo size', 'redo writes', 'user commits', 'redo synch time')
ORDER  BY name;

-- 실시간 Redo 생성률 추정 (간단한 예시)
-- 1. 현재 redo size 값 기록
-- 2. 60초 대기
-- 3. 다시 redo size 값 기록 후 차이 계산
-- (MB/초) = (차이값 / 1024 / 1024) / 60
```

**지표 해석:**
-   **`redo size`**: 생성된 Redo의 총 바이트 수. 시스템의 총 쓰기 부하를 나타내는 핵심 지표입니다.
-   **`user commits`**: 수행된 커밋의 총 횟수.
-   **분석**: `redo size`는 크지만 `user commits`가 상대적으로 적다면, 대용량 배치 작업이 주로 수행되고 있음을 의미할 수 있습니다. 반대로 `user commits`가 매우 많다면, OLTP 성격의 자잘한 트랜�잭션이 빈번히 발생하고 있어 `log file sync` 대기에 주의해야 함을 시사합니다.

---

## Redo와 Checkpoint: 복구 시간 단축의 협력 관계

**체크포인트(Checkpoint)** 는 리두 로그의 재생 시작 지점을 앞당겨 인스턴스 복구 시간을 단축하는 메커니즘입니다.

-   **CKPT(Checkpoint Process)**: 체크포인트 발생 시, 데이터 파일 헤더와 컨트롤 파일에 **체크포인트 SCN**을 기록합니다. 이 SCN은 "이 시점까지의 변경은 이미 데이터 파일에 반영되었다"는 복구의 기준선입니다.
-   **동작 방식**: 로그 스위치나 일정 시간 간격 등으로 체크포인트가 발생하면, CKPT는 DBWn에게 더 많은 Dirty 버퍼를 데이터 파일에 쓰도록 요청합니다. DBWn의 쓰기가 진행되면서 체크포인트 SCN도 점진적으로 증가합니다.
-   **효과**: 장애 복구 시, SMON은 **마지막 체크포인트 SCN 이후**의 리두 로그만 재생하면 되므로, 복구에 필요한 시간이 크게 줄어듭니다.

```sql
-- 인스턴스 복구 관련 정보 확인 (예상 복구 시간 등)
SELECT * FROM v$instance_recovery;
```

---

## Redo를 줄여야 할까? (NOLOGGING과 Direct-Path 작업)

"Redo를 생성하지 않으면 성능이 좋아질 것"이라는 생각은 부분적으로만 맞습니다. 일반적인 DML/DDL 작업에서 Redo 생성을 완전히 끄는 것은 복구 기능을 포기하는 것이므로 허용되지 않습니다.

하지만, **대량 데이터 적재** 같은 특정 시나리오에서는 Redo 생성을 최소화하여 성능을 극대화할 수 있는 옵션이 있습니다.

### NOLOGGING 모드와 Direct-Path Insert
-   **NOLOGGING**: 테이블 또는 인덱스를 생성하거나 재구성할 때 `NOLOGGING` 옵션을 지정하면, 해당 오브젝트에 대한 특정 작업(예: Direct-Path Insert)에서 최소한의 Redo만 생성합니다.
-   **Direct-Path Insert**: `INSERT /*+ APPEND */` 힌트를 사용하거나 `CREATE TABLE ... AS SELECT` 구문을 사용하면, 데이터가 버퍼 캐시를 거치지 않고 테이블 세그먼트의 고수위 마크(HWM) 위로 직접 기록됩니다. 이 방식은 로깅을 크게 줄입니다.

**중요한 주의사항:**
NOLOGGING 모드로 수행된 작업은 **리두 로그로 보호되지 않습니다**. 따라서 해당 세그먼트에 대해 NOLOGGING 작업이 수행된 후, 미디어 장애가 발생하면 그 세그먼트는 복구 과정에서 **오류가 발생하거나 오래된 상태로 남을 수 있습니다**. 이를 방지하기 위한 운영 절차는 다음과 같습니다:
1.  NOLOGGING 작업 수행.
2.  작업 직후 해당 테이블스페이스 또는 데이터베이스 **즉시 백업** 수행. (예: `RMAN BACKUP ...`)

**결론:** Redo 최소화는 성능 향상의 강력한 도구이지만, 이는 **복구 가능성과의 트레이드오프 관계**에 있음을 반드시 인지하고, 신중한 운영 절차와 함께 사용해야 합니다.

---

## 결론: Redo, 데이터베이스 신뢰성의 초석

Redo는 단순한 로그 파일을 넘어, 오라클 데이터베이스의 **신뢰성(Reliability), 가용성(Availability), 내구성(Durability)** 을 지탱하는 초석입니다.

-   **본질**: Redo는 모든 변경의 '행위 기록'이며, 이 기록이 디스크에 안전하게 저장되는 순간이 바로 커밋의 완료입니다. Undo와의 명확한 분리를 이해하는 것이 첫걸음입니다.
-   **흐름**: Redo Log Buffer에서 시작해 LGWR에 의해 Online Redo Log로, 최종적으로는 Archived Redo Log로 이동하며, 각 단계는 복구와 고가용성을 위한 필수 인프라를 형성합니다.
-   **성능**: `log file sync` 대기 이벤트는 커밋 지연의 바로미터입니다. 이 성능은 결국 LGWR의 I/O 속도, 그리고 그 기반이 되는 **빠른 스토리지와 적절한 리두 로그 구성**에 달려 있습니다.
-   **운영**: **ARCHIVELOG 모드**는 운영 데이터베이스의 생존 조건입니다. 적절한 로그 스위치 간격 유지, 아카이브 로그 관리, 그리고 NOLOGGING 작업 시의 신중한 백업 계획은 DBA의 핵심 운영 과제입니다.
-   **전략적 도구**: 대량 작업의 성능을 위해 Redo 생성을 최소화하는 기법(NOLOGGING, Direct-Path)은 존재하지만, 이는 반드시 **복구 전략과 결합**되어야 하는 양날의 검입니다.

**한 마디로, Redo는 오라클이 "내가 한 일을 절대 잊지 않고, 잃지 않겠다"고 약속하는 방식이며, LGWR가 그 약속장을 디스크에 봉인하는 순간이 바로 여러분의 커밋이 완료되는 순간입니다.** 이 복잡하면서도 정교한 메커니즘을 이해하는 것은 데이터베이스의 건강을 진단하고, 고성능·고가용성 시스템을 설계하는 데 있어 가장 중요한 기초 지식이 됩니다.