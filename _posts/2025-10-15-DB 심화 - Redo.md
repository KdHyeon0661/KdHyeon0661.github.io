---
layout: post
title: DB 심화 - Redo
date: 2025-10-15 20:25:23 +0900
category: DB 심화
---
# Oracle Redo 완전 정복
(Oracle Database 19c 기준, 내부 동작 · 복구 · 성능 · 운영까지)

> 목표
> - Redo가 정확히 **무엇을 기록하는지**, 언제/어떻게 기록되는지, 커밋과 어떤 관계인지, 복구에서 어떤 역할을 하는지 끝까지 설명
> - Redo Log Buffer → LGWR → Online Redo Log → Archived Redo Log → Media Recovery → Data Guard까지 흐름을 실제로 따라가며 본다
> - 성능/튜닝 관점(LGWR 대기, 로그 스위치, 체크포인트, I/O 모델)과 실습 SQL 포함
> - Undo와의 차이도 명확히 구분
> - “redo size가 많다 = 나쁜가?”, “로그 스위치가 잦다 = 왜 문제?” 같은 실무 질문에 답을 줄 수 있게 만든다

---

## 0. Redo란 뭔가?

**Redo = “데이터베이스 블록에 어떤 변경이 있었는지에 대한 재생 가능 기록”**
(= 변경의 “행위”를 순차적으로 기록한 저널)

좀 더 구체적으로 말하면:

- Redo는 **데이터베이스 변경(INSERT/UPDATE/DELETE, DDL 등)** 을 **물리적으로 재현할 수 있는 최소 단위로 캡쳐**한 로그입니다.
- Redo 레코드는 **버퍼 캐시에서 특정 블록이 어떻게 바뀌었는지**를 담고 있고, 이건 빠르게 순차적으로 기록됩니다.
- Redo는 디스크에 있는 실제 데이터파일보다 **진실을 더 빨리 알고 있는 존재**입니다.
  - Dirty Buffer(아직 디스크로 안 나간 변경)는 이미 Redo에 기록돼 있고, 이 덕분에 장애가 나도 복구할 수 있습니다.

즉, Oracle은 다음의 철학을 가집니다:

1. **변경은 SGA(Buffer Cache)에서 먼저 일어난다.**
2. 그 변경 내용은 **Redo Log Buffer**에 기록된다.
3. **LGWR(Log Writer)** 가 이 Redo를 **Online Redo Log 파일(리두 로그 파일)** 로 동기적으로 플러시한다.
4. 커밋은 “해당 트랜잭션 Redo가 안전하게(디스크까지) 써졌는가?”만 확인하면 끝난다.
5. 나중에 DBWn(Database Writer)이 Dirty Buffer를 데이터 파일에 적는다. 커밋과는 느슨하게 연결된다.
6. 만약 인스턴스가 죽어도, 온라인/아카이브 리두 로그를 재생하면 DB 상태를 복원할 수 있다.

> 핵심: **Redo는 커밋의 내구성(“Durability”)이다.**
> 데이터파일이 아직 안 써졌어도 Redo만 있으면 다시 만들 수 있다.

---

## 1. Redo와 Undo를 구분하자

많이 혼동하는 두 개:

### 1.1 Redo
- 방향: “**앞으로 다시 적용(re-DO)** 가능하게” 변경 내용을 순차 기록한다.
- 목적: **장애/복구(크래시 리커버리, 미디어 리커버리)**, Data Guard 전송
- 쓰는 곳: **Redo Log Buffer → Online Redo Log → (Archive Redo Log)**
- 주체: **LGWR** 가 기록

### 1.2 Undo
- 방향: “**과거 상태로 되돌릴 수 있게**” 변경 전(before image) 정보를 저장한다.
- 목적:
  - 트랜잭션 롤백
  - 읽기 일관성(Consistent Read; SELECT가 과거 SCN 기준으로 읽을 때)
  - Flashback Query/Flashback Table 등
- 쓰는 곳: **Undo Tablespace** (UNDO 세그먼트)
- 주체: DML 수행 세션이 Undo 레코드를 생성하고 참조

비유:
- **Redo**: “어떤 UPDATE를 했는지 절차서”
- **Undo**: “그 UPDATE 하기 전에 값은 뭐였는지 기록해둔 스냅샷”

이 두 개가 함께 ACID 중 **원자성(Atomicity)**, **내구성(Durability)**, **일관성(Consistency)** 를 채운다:
- Undo는 롤백과 CR(일관 읽기)을 통해 **일관성/원자성** 지원
- Redo는 커밋의 영속성(디스크에 안전히 쓰임)을 통해 **내구성** 지원

---

## 2. Redo 작성 흐름: DML 한 줄이 Redo까지 가는 여정

다음 시나리오를 보자.

```sql
CREATE TABLE t_redo (
    id      NUMBER PRIMARY KEY,
    payload VARCHAR2(100),
    updated_at DATE
);

INSERT INTO t_redo (id, payload, updated_at)
VALUES (1, 'hello', SYSDATE);

UPDATE t_redo
   SET payload = 'hello world',
       updated_at = SYSDATE
 WHERE id = 1;

COMMIT;
```

이 짧은 트랜잭션 안에서 실제로 일어나는 단계들을 시간 순으로 뜯으면:

1. **INSERT/UPDATE 실행 시점**
   - 서버 프로세스가 해당 블록(테이블/인덱스 블록)을 **Buffer Cache** 에 가져온다.(없으면 물리 I/O 발생)
   - 블록을 수정한다. 이때:
     - 변경 전 값은 Undo 세그먼트에 기록 (Undo)
     - 변경한 내용은 Redo 레코드로 만든다 (Redo)

2. **Redo Log Buffer에 적재**
   - 방금의 변경 내용은 **SGA의 Redo Log Buffer**에 들어간다.
   - 아직 디스크는 아님. 메모리 안에 있는 임시 버퍼다.

3. **아직 COMMIT 전**
   - 현재 이 트랜잭션은 커밋되지 않았음
   - Buffer Cache에 있는 블록은 Dirty 상태일 수 있지만, 아직 **DBWn**은 그걸 디스크에 쓸 의무가 없다.
   - Redo는 아직 “진짜 디스크”(Online Redo Log 파일)에 안 나갔을 수도 있다.

4. **COMMIT 실행**
   - Oracle은 COMMIT 시점에 **LGWR가 Redo Log Buffer에 있는 이 트랜잭션의 Redo 레코드(및 COMMIT 레코드)** 를 **온라인 리두 로그 파일로 동기 flush** 했음을 보장한다.
   - 즉, LGWR가 **fsync/동기 I/O** 까지 끝났음을 보장해야 COMMIT이 클라이언트에게 “완료”라고 돌아간다.
   - 그래서 COMMIT은 보통 **Redo 쓰기 경로**에 의해 지연된다. (I/O 속도, 로그파일 경합이 중요)

5. **COMMIT 이후**
   - 트랜잭션은 논리적으로 끝났다.
   - 데이터파일은 아직 안 쓸 수도 있다. (DBWn이 “나중에” Dirty 블록을 쓰겠지)
   - 하지만 **Redo는 이미 디스크에 있음**.
   - 만약 지금 인스턴스가 죽어도, 재시작 시 SMON이 방금 커밋한 Redo를 재생(roll forward)해서 디스크를 최신 상태로 복원할 수 있다.

요약하면:
**Red o → 즉시/순차/작게/동기 기록(커밋 보장)**
**Datafile → 나중에/배치성/비동기 기록(DBWn)**

---

## 3. Redo의 구성 요소

Redo는 여러 단계의 저장소를 거칩니다:

1. **Redo Log Buffer (SGA 안)**
   - Redo 레코드가 먼저 쌓이는 임시 버퍼
   - 파라미터: `log_buffer`
   - LGWR가 주기적으로, 또는 특정 이벤트(커밋, 1/3 찼다, 1초 경과 등)마다 플러시

2. **Online Redo Log Files**
   - 디스크 상의 “순차 로그 파일”
   - 여러 개의 **로그 그룹(group)** 으로 구성, 각 그룹에 **복수 멤버(member)** 로 다중화 가능
   - LGWR는 항상 “현재 그룹(current log group)”에 순차적으로 Append
   - 꽉 차면 **로그 스위치(log switch)** → 다음 그룹으로 회전

3. **Archived Redo Logs (ARCHIVELOG 모드일 때)**
   - 이전에 쓰던 Online Redo Log 그룹이 회전되면,
   - ARCn(archiver) 백그라운드가 그 내용을 아카이브 대상 위치(디스크/FRA 등)로 복사
   - “아카이브 로그”는 **미디어 복구, PITR, Data Guard 전송** 등에 쓰인다.

이 구조는 아래와 같은 파이프라인으로 볼 수 있다:

```text
[Buffer Cache에서 DML 발생]
   ↓
Redo Record 생성
   ↓
Redo Log Buffer (SGA)
   ↓ LGWR flush (동기)
Online Redo Log (디스크)
   ↓ (Log Switch 시)
Archived Redo Log (장기 보관)
```

---

## 4. Redo를 왜 이렇게까지 중요하게 다루는가?

Redo는 3가지 의미에서 “생명줄”이다.

### 4.1 인스턴스 복구 (Crash Recovery)
- 인스턴스가 비정상 종료(전원 off 등) → Buffer Cache 안에 있던 Dirty 블록 중 일부는 아직 디스크에 안 갔음 → 데이터파일은 “옛날 상태”
- 하지만 Online Redo Log에는 그 변경의 일련 번호가 남아 있음
- 재기동 시 SMON이:
  - **Roll Forward:** 온라인 리두 로그(필요시 + 일부 아카이브)를 읽어 블록 변경을 재적용해서 디스크를 커밋된 시점까지 끌어올림
  - **Roll Back(Uncommitted):** 미완료 트랜잭션은 Undo를 이용해 되돌림

즉, **Redo 덕분에 커밋이 잃어버리지 않는다.**

### 4.2 미디어 복구 (Media Recovery / PITR)
- 데이터파일이 손상되었거나 백업본을 복원한 상황
- 그 백업(예: 전날 RMAN 백업) 이후의 변경을 아카이브 리두 로그/온라인 리두 로그 재생으로 앞으로 “되감기”할 수 있음 → 시점 복구(Point-In-Time Recovery) 가능

### 4.3 Data Guard / Standby
- Primary DB에서 LGWR/ARCn이 Redo를 전송하면 Standby DB가 이를 적용하여 **거의 실시간 복제** 가능 (물리/논리 스탠바이)
- 이것도 결국 “Redo를 재생해서 동일 상태를 맞춘다”라는 원리

---

## 5. COMMIT = LGWR의 fsync

자주 묻는 질문:
“COMMIT은 왜 느리기도 하고 빠르기도 해?”

답: **COMMIT 시간은 크게 LGWR의 I/O 성능에 좌우**된다.

- COMMIT 시 Oracle은 해당 트랜잭션의 Redo(플러스 COMMIT 레코드)가 **Online Redo Log 파일에 안전하게 기록되었다**는 걸 확인해야 한다.
- 이 동기 I/O 과정에서 지연이 발생하면 COMMIT이 느려진다.
  - 디스크 IOPS/latency
  - 로그 파일 위치가 느린 스토리지인지
  - 같은 redo log group에 너무 많은 세션이 동시 커밋 중인지

관찰 방법(요약):

```sql
-- 전체 시스템에서 얼마나 Redo가 생성되고 있는지
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('redo size', 'redo writes', 'user commits')
ORDER  BY name;

-- 세션별 커밋 횟수/redo 사용량도 ASH/AWR에서 추적 가능
```

해석 예:
- `redo size`는 지금까지 생성된 리두 바이트 수 누적 (부하 지표)
- `user commits`는 커밋 횟수 (OLTP 패턴 감지)
- 커밋 횟수 대비 redo size가 매우 크다면 대량 DML 위주
- redo size 대비 commit이 엄청 많으면 “자잘한 커밋(자주 commit)”이 많은 트랜잭션 패턴 → LGWR 커밋 동기 flush가 잦아짐

---

## 6. Redo Log Buffer와 `log_buffer`

### 6.1 Redo Log Buffer는 어디에?
- **SGA의 일부**
- DML 실행 시 생성된 Redo 레코드가 먼저 여기에 적재됨
- 너무 작으면 LGWR 호출이 자주 일어나고 경합 가능
- 너무 커도 “엔드투엔드 성능 폭발적 향상”은 아닐 수 있음 (커밋 시엔 어차피 flush 해야 하니까)

```sql
SHOW PARAMETER log_buffer;
SELECT name, value
FROM   v$parameter
WHERE  name = 'log_buffer';
```

### 6.2 LGWR 플러시 트리거
LGWR는 Redo Log Buffer → Online Redo Log로 쓰는 시점을 다음 상황에서 결정:
- 트랜잭션 COMMIT
- Redo Log Buffer가 일정 비율 이상 찼다
- 3초(또는 1초 등 버전 및 내부 정책 기준) 정도 지났다
- 체크포인트 등 특정 이벤트

즉, 여러분이 COMMIT을 안 해도 LGWR는 주기적으로 Redo를 흘려보낸다.
하지만 COMMIT은 반드시 **자신의 커밋 레코드까지** 쓰였음을 확인하고 돌아간다.

---

## 7. Online Redo Log Files — 그룹과 멤버

### 7.1 구조
- Oracle은 보통 여러 개의 **로그 그룹(group)** 을 둔다. 예: GROUP#1, GROUP#2, GROUP#3 …
- 각 그룹에는 동일한 내용을 쓰는 여러 **멤버(member)** (중복된 파일 경로)로 **미러링/다중화** 가능
- LGWR는 현재 활성 그룹(current group)에 순차적으로 기록하다가, 다 차면 **로그 스위치(log switch)** 를 일으켜 다음 그룹으로 넘어간다.

```sql
-- 현재 redo log 그룹/멤버 확인
SELECT group#, bytes/1024/1024 AS size_mb, members, archived, status
FROM   v$log
ORDER  BY group#;

SELECT group#, member
FROM   v$logfile
ORDER  BY group#, member;
```

칼럼 의미:
- `group#`: 그룹 번호
- `status`: CURRENT(현재 쓰는 중), ACTIVE(복구에 아직 필요), INACTIVE(이미 백업/아카이브 완료되어 덮어써도 됨)
- `archived`: 아카이브되었는지 여부
- `bytes`: 그룹 크기

### 7.2 로그 스위치(Log Switch)
- 현재 그룹이 꽉 찼을 때 다음 그룹으로 넘어가는 순간
- ARCHIVELOG 모드라면, 스위치된 그룹은 ARCn이 아카이브 대상으로 복사
- 스위치가 너무 자주 일어나면?
  - **체크포인트가 매우 자주** 발생 → DBWn과 CKPT에 부담
  - 아카이브 I/O가 과하게 빈번해짐
  - 결국 시스템 전체에 오버헤드

운영 팁:
OLTP 시스템에서 **로그 스위치가 수십 초/수분 단위로 너무 잦을 경우** redo log size를 키워 로그 스위치 주기를 늘리는 게 일반적인 권장안입니다. (자주 20~30분 정도 간격이 가이드라인으로 언급되곤 함. 업무 패턴에 따라 다름)

```sql
-- 강제로 로그 스위치 유발 (DBA 테스트용)
ALTER SYSTEM SWITCH LOGFILE;

-- 최근 아카이브 로그 확인
SELECT sequence#, first_time, next_time, blocks, archived, status
FROM   v$archived_log
ORDER  BY sequence# DESC FETCH FIRST 10 ROWS ONLY;
```

---

## 8. Archived Redo Log — 장기 보관과 복구 / Data Guard

### 8.1 ARCHIVELOG vs NOARCHIVELOG
- **NOARCHIVELOG 모드**
  - Online Redo Log 그룹이 순환하면서 예전 로그를 덮어쓴다
  - 장애 시 “가장 최근 백업”까지만 복구 가능 (그 이후는 소실 가능)
  - 보통 개발/테스트 DB에서 사용
- **ARCHIVELOG 모드**
  - Online Redo Log가 스위치될 때마다 그 내용이 **아카이브 로그 파일**로 복제(보관)
  - RMAN 백업 + 아카이브 로그를 사용하면, 특정 시점(Point-in-Time)까지 복구 가능
  - 운영(프로덕션) DB의 표준

아카이브 모드 여부 확인:

```sql
ARCHIVE LOG LIST;
```

이 명령은 아카이브 상태, 현재 로그 시퀀스, 아카이브 경로 등을 보여준다.

### 8.2 Data Guard / Standby
- Primary DB에서 나오는 Redo는 LGWR/ARCn 에 의해 Standby DB로 전송된다.
- Standby는 그 Redo를 적용(“Redo Apply”)함으로써 Primary와 거의 동기화된 복제 상태를 유지.
- 장애 발생 시 Standby를 승격(Failover / Switchover).

핵심:
**Redo는 단순한 로컬 복구 재료일 뿐 아니라, 고가용성/DR(Disaster Recovery)의 핵심 동기화 스트림이다.**

---

## 9. Redo와 Checkpoint / DBWn / CKPT의 관계

여기서 중요한 세 친구를 살짝 복습하자.

- **LGWR(Log Writer)**
  - Redo Log Buffer → Online Redo Log
  - 커밋의 핵심
- **DBWn(Database Writer)**
  - Buffer Cache의 Dirty 버퍼 → 데이터파일
  - 백그라운드로 비동기, 여러 DBWn 존재 가능
- **CKPT(Checkpoint Process)**
  - 체크포인트 발생 시점에 **데이터파일 헤더와 컨트롤파일에 SCN을 기록**
  - “이 시점까지만 복구하면 된다”는 기준선(Recovery Boundary)을 짧게 유지해, 인스턴스 복구 시간을 줄인다.

Redo는 이 셋과 어떻게 연결될까?

1. 시스템은 지속적으로 Redo를 생성하고 LGWR가 기록한다.
2. Redo가 너무 쌓이면(혹은 로그 스위치 등 이벤트) 체크포인트를 유발해
   - DBWn이 Dirty 블록을 가능한 한 데이터파일에 기록
   - CKPT가 그 SCN을 데이터파일 헤더/컨트롤 파일에 반영
3. 이러면 충돌 없이 인스턴스 복구 시 재생해야 하는 Redo 구간이 짧아짐.
   즉, 체크포인트는 **Redo 재생 부담을 줄이는 장치**다.

관찰:

```sql
-- 최근 체크포인트와 인스턴스 복구 관련 정보
SELECT * FROM v$instance_recovery;
SELECT checkpoint_change# FROM v$database;
```

---

## 10. Redo 크기를 줄이면 좋은가? (OLTP vs Batch 관점)

많은 사람들이 “Redo를 줄이면 성능이 올라가겠지?”라고 가정하지만, 이건 절반만 맞습니다.

### 10.1 Redo는 거의 항상 기록된다
- Oracle은 기본적으로 **모든 변경(데이터+인덱스+데이터 사전 DDL 등)** 을 Redo로 남긴다.
- Redo를 완전히 “끄는” 건 일반적인 DML/DDL에서 불가능하다. (왜냐면 복구가 안 되면 DBMS로서의 신뢰를 잃으니까)

### 10.2 예외적/부분적 최적화: Direct-Path Insert / NOLOGGING
- 대량 데이터 적재(예: 데이터 웨어하우스 배치 로드)에서
  - **APPEND 힌트(Direct-Path Insert)** 나
  - **NOLOGGING 모드 세그먼트/인덱스 생성**
  는 Redo 생성을 “대폭 줄이거나(혹은 최소화)” 할 수 있다.
- 하지만 이건 **크래시나 미디어 손상 시 해당 세그먼트는 복구 못 할 수도 있음** 을 의미한다.
  즉, 고급 사용/특정 요건 하에서만 쓴다.

예:

```sql
-- 대량 적재 성능 목적으로 (주의: 복구 리스크)
CREATE TABLE t_big NOLOGGING AS
SELECT * FROM source_table;

-- Direct-path insert (APPEND)
INSERT /*+ APPEND */ INTO t_big
SELECT * FROM staging_table;
COMMIT;
```

- 이런 작업은 Redo 부하를 줄여 대용량 적재 속도를 올린다.
- 그러나 재해 상황에서 해당 세그먼트/인덱스가 복구 불가일 수 있으므로
  - 보통은 “적재 후 바로 백업(RMAN)” 절차를 묶어서 운영한다.
- 즉 **Redo 최소화 = 성능 향상**은 맞을 수 있지만
  **Redo 최소화 = 복구 리스크 증가**가 항상 따라온다.

> 운영 DB(온라인 트랜잭션 시스템)에서 무턱대고 NOLOGGING을 남발하는 건 위험하다.

---

## 11. Redo와 성능 병목: LGWR, I/O 대기, log file sync

Redo 경로에서 자주 보는 성능 지표/대기 이벤트를 짚어보자.

### 11.1 `log file sync`
- 세션이 COMMIT할 때, LGWR가 해당 트랜잭션의 Redo를 디스크로 flush 완료할 때까지 기다리는 대기
- 이 값이 크면 “커밋이 느리다”
  - LGWR I/O 느림 (저성능 스토리지, 파일 시스템/네트워크 스토리지 지연)
  - 너무 잦은 커밋(= 아주 작은 트랜잭션을 초고빈도로 COMMIT)
  - Redo 로그 파일이 너무 작고 너무 자주 스위치가 일어나면서 LGWR가 자주 전환/메타 작업을 함

### 11.2 `log buffer space`
- Redo Log Buffer가 꽉 차서 세션이 Redo를 밀어넣을 수 없고, LGWR가 빨리 써주길 기다리는 상황
- 드묾. 만약 발생하면 `log_buffer` 확인, LGWR I/O 경로 체크

### 11.3 `log file parallel write`
- LGWR 자체가 redo를 디스크에 쓰고 있는 동안의 대기(백그라운드 관점)
- DB 관리자가 직접 해석할 땐 LGWR I/O 레이턴시 지표로 본다.

### 11.4 “LGWR가 느리면 OLTP 전체가 느려진다”
- OLTP는 짧은 트랜잭션+자주 COMMIT(예: 결제건, 주문건, 로그성 트랜잭션)
- COMMIT마다 Redo flush = 디스크 sync
- 그래서 LGWR I/O가 병목이면 전체 응답 시간이 들쭉날쭉해진다.

관찰 예:

```sql
-- AWR/ASH 기반으로도 보지만, v$session_wait_class, v$system_event 등으로 러프하게 본다.
SELECT event, total_waits, time_waited_micro/1e6 AS sec
FROM   v$system_event
WHERE  event IN ('log file sync', 'log file parallel write', 'log buffer space')
ORDER  BY sec DESC;

-- 세션 단위 현재 대기
SELECT sid, serial#, username, event, wait_class, state, seconds_in_wait
FROM   v$session
WHERE  event IN ('log file sync','log buffer space','log file parallel write')
AND    state <> 'WAITED SHORT TIME';
```

튜닝 방향:
- LGWR가 쓰는 온라인 리두 로그 파일은 **빠른 디스크/스토리지** 위에 두라 (저지연 SSD 등)
- 자잘한 COMMIT을 너무 자주 하지 않도록 비즈니스 로직(배치 커밋) 조정 가능 여부 검토
  (단, 이것은 비즈니스 요구사항과 일관성 보장 정책과 맞물리는 민감한 부분)
- 로그 파일 크기/그룹 수 적절하게 확보 → 너무 잦은 로그 스위치 방지 → LGWR/CKPT/ARCn 부담↓
- RAC/Data Guard 환경에서는 네트워크 전송 지연도 LGWR 경로에 개입할 수 있다(동기/최소손실 모드 등)

---

## 12. Redo 관측용 실습: redo size와 커밋 비용

아주 단순한 실험 플로우:

```sql
-- 0) 베이스라인 측정
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('redo size','user commits');

-- 1) 대량 INSERT (벌크 트랜잭션)
DECLARE
  i NUMBER;
BEGIN
  FOR i IN 1..50000 LOOP
    INSERT INTO t_redo (id, payload, updated_at)
    VALUES (100000 + i,
            RPAD('payload', 50, 'x'),
            SYSDATE);

    -- 커밋을 자주 안 함
    IF MOD(i,10000)=0 THEN COMMIT; END IF;
  END LOOP;
  COMMIT;
END;
/

-- 2) 다시 측정
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('redo size','user commits');

-- 관찰 포인트:
-- - redo size가 얼마나 늘었나?
-- - user commits는 몇 번이나 늘었나?
```

해석:
- 만약 `redo size` 는 크게 늘었는데 `user commits` 는 적게 늘었다면 → “큰 트랜잭션 몇 번”
- 반대로 `user commits` 엄청 늘고 `redo size` 는 각 커밋마다 작다면 → “자잘한 트랜잭션 엄청 많음”
  - 이런 패턴은 LGWR에게 “짧은 트랜잭션 수천 번 COMMIT = log file sync 대기 폭증”을 줄 수 있다.

---

## 13. 수학적 감각 — Redo 생성률과 I/O

Redo 생성률은 시스템의 “쓰기 강도(write intensity)”라고 볼 수 있다.

예를 들어, 어떤 관찰 구간(예: 1초, 1분) 동안:

$$
\text{redo\_rate (MB/s)} \approx
\frac{\text{redo size (bytes) 증가량}}{\text{측정 구간(초)}} \div 1024 \div 1024
$$

- redo_rate가 높다는 건:
  - OLTP에서 엄청난 DML 폭주
  - 배치 로드/ETL/집계 결과 적재
  - 대규모 인덱스 재구성/DDL 등 구조적 변경
- redo_rate 급증 시 확인할 것:
  - `log file sync` 지연 상승 여부
  - ARCn(archiver)이 아카이브를 제때 처리 중인가? (안 그러면 아카이브 대상 경로 FULL → 시스템 멈춤 위험)
  - FRA(Flash Recovery Area) 용량 부족 경고 여부

---

## 14. 운영 체크리스트 (Redo 관점으로 DB 건강 확인하기)

1. **ARCHIVELOG 모드**인가?
   - 운영 DB라면 거의 항상 YES
   - `ARCHIVE LOG LIST` 로 확인
2. **Online Redo Log 크기/개수**는 적절한가?
   - 로그 스위치 간격이 너무 짧지 않은지(수십 초~수분마다 스위치라면 너무 작을 수 있음)
3. **Redo 로그 파일이 있는 스토리지**는 충분히 빠른가?
   - `log file sync` 평균 대기 시간이 수 ms 단위인지, 수십~수백 ms인지 확인
   - 느리면 커밋 지연으로 사용자 응답이 느려진다
4. **Redo rate(초당 MB)** 가 갑자기 치솟는 순간은 언제인가?
   - 그 시간대에 어떤 배치/작업이 돌았는지 매핑
5. **ARCn이 지연 없이 아카이브를 뽑고 있는가?**
   - 아카이브 디렉터리 꽉 찌 않았나?
   - `v$archived_log` 로 최근 생성 속도와 크기 확인
6. **Data Guard** 구성 시 Redo 전송 지연은?
   - 스탠바이 적용/전송 지연이 미션 크리티컬한지(거의 실시간 복제가 필요한 금융/결제 시스템 등)
7. **NOLOGGING / Direct-Path Insert** 등을 사용한 테이블/인덱스가 있다면, 그 직후 제대로 RMAN 백업했는가?
   - 그렇지 않으면 DR 상황에서 해당 세그먼트 복구가 불가능할 수 있다.
8. **Checkpoint 빈도 / CKPT 동작**
   - 체크포인트가 너무 잦아도 전체 I/O 부하
   - 너무 드물어도 crash recovery 시 redo 재생 시간이 길어진다
9. **log_buffer** 가 병목을 일으킬 정도로 너무 작은가? (`log buffer space`)
   - 드물지만 확인
10. **batch 커밋 정책**
   - 작은 트랜잭션을 매 레코드마다 커밋하는 패턴은 `log file sync` 폭증을 부르고 LGWR를 학대한다.
   - 가능한 경우 비즈니스적으로 “N개마다 묶어 커밋”을 고려.

---

## 15. 요약

- **Redo는 오라클의 심장박동**이다.
  - 모든 변경은 Redo로 캡쳐되고, 이 Redo가 Online Redo Log로 안전하게 기록된 시점이 곧 “COMMIT의 내구성 보장”이다.
- **Redo와 Undo는 다르다**
  - Redo: “앞으로 재적용 가능하게” 해서 복구/재생 용
  - Undo: “과거 버전 재구성/롤백” 용
  - 함께 ACID를 완성한다
- **Redo 흐름**
  - Buffer Cache에서 블록 변경
  - → Redo Log Buffer
  - → LGWR가 Online Redo Log에 동기 flush (커밋 보장)
  - → (Log Switch) Archived Redo Log
  - → 복구 / PITR / Data Guard 복제
- **성능 포인트**
  - `log file sync`는 커밋 지연 그 자체
  - 로그 스위치 빈도는 redo log 크기로 조정
  - Redo rate 급증은 시스템 쓰기 부하의 축적 신호
- **운영 포인트**
  - ARCHIVELOG 모드, FRA 용량, ARCn 정상동작은 생존 문제
  - LGWR의 I/O 경로(redo 로그 디스크)는 OLTP 레이턴시에 직결
  - NOLOGGING/Direct-Path Insert는 복구 리스크를 동반하므로 전략적으로만 사용

> 한 줄로 정리하면:
> **Redo는 “내가 방금 한 변경을 잊지 않겠다”는 오라클의 서약서이며,
> LGWR가 그 서약서를 디스크에 박아 넣는 순간이 바로 COMMIT이다.**
