---
layout: post
title: 운영체제 - IO 시스템 (1)
date: 2025-10-25 22:30:23 +0900
category: 운영체제
---
# Chapter 12 — I/O Systems

## Overview

### I/O 스택 한눈에 보기

```
[App/User] ── 표준 라이브러리(fread/fwrite, recv/send, ReadFile, …)
    │
    ├─► [OS 커널: VFS/Socket/Block/Char 계층]
    │       ├ 파일시스템(ext4, NTFS, APFS, XFS…)
    │       ├ 네트워크 스택(TCP/UDP/QUIC 소켓)
    │       ├ 블록 계층(스케줄러, 요청 병합)
    │       └ 문자 디바이스(터미널, 센서, TTY)
    │
    ├─► [드라이버: 버스(PCIe/USB), 장치별 프로토콜]
    │
    └─► [컨트롤러/디바이스: NVMe, NIC, GPU, USB]
```

- **경로(Core path)**: 앱 호출 → 커널 진입 → 드라이버 → 장치 → 완료 인터럽트 → 커널 완료 → 앱 반환.
- **데이터 경로**: *Programmed I/O(유저/커널 CPU 복사)*, *DMA(장치가 메모리에 직접 전송)*, *zero-copy(매핑 공유)*.

### I/O 성능 지표

- **지연(latency)**: 요청 1건의 E2E 시간.
- **처리량(throughput / IOPS)**: 단위 시간당 바이트/연산 수.
- **큐잉 이론 직관**
  - 평균 도착률 \(\lambda\), 평균 체류시간 \(W\)일 때 **Little의 법칙**:
    $$L = \lambda \cdot W$$
  - 단순 M/M/1에서 서비스율 \(\mu\), 이용률 \(\rho=\lambda/\mu < 1\)이면 평균 대기시간
    $$W_q = \frac{\rho}{\mu - \lambda} = \frac{\lambda}{\mu(\mu-\lambda)}$$
  - **교훈**: 이용률이 1에 근접하면 **p99 지연 급증**.

### I/O 방법론

- **Blocking vs Non-blocking**: 블로킹은 호출이 완료될 때까지 대기, 논블로킹은 즉시 반환(다음 준비 이벤트를 감시).
- **동기 vs 비동기**: 비동기는 제출 후 **완료 알림**(인터럽트/큐)으로 결과 수신.
- **Buffering**: **커널/라이브러리 버퍼**를 통해 모아쓰기, 병합, 재정렬.
- **Caching**: 페이지 캐시(file read hit), 소켓 버퍼, 디바이스 내부 캐시.
- **Spooling**: 프린트·배치 작업을 **중간 큐**에 적재해 순차 처리.

### 데이터 이동 패턴

- **Memcpy 경유**: `read()` → 유저 버퍼 복사.
- **DMA**: NIC/NVMe가 메모리로 직접 전송(드라이버가 버퍼를 맵핑).
- **Zero-copy**: `sendfile()`, `splice()`, `mmap()`을 통해 **복사 없이** 커널/장치 간 파이프라인 공유.

### 신뢰/내구 보장

- **Read/Write ordering**: 배리어(FUA/flush), fsync/commit.
- **무결성**: CRC/체크섬, ECC, 재시도, 타임아웃/리셋.

---

## I/O Hardware

### 장치, 컨트롤러, 버스

- **디바이스(Device)**: 실제 매체/인터페이스(HDD, SSD, NIC, USB 카메라).
- **컨트롤러(Controller)**: 장치 제어 로직(NVMe 컨트롤러, NIC MAC/PHY).
- **버스(Bus)**: CPU/메모리/장치 연결(PCIe, USB, SATA, I2C, SPI).
- **레지스터**: 제어/상태/데이터 레지스터(명령, 큐 포인터, 인터럽트 마스크 등).

### I/O 접근: MMIO vs PIO

- **MMIO**: 장치 레지스터가 **메모리 주소 공간**에 매핑. `*(volatile uint32_t*)addr = value;`
- **PIO(Port I/O)**: x86의 `in`/`out` 포트 공간(현대엔 MMIO가 주류).
- **캐시 속성**: MMIO는 **비캐시/강순서**로 매핑해야 함(PAT/MAIR).

### 인터럽트 vs 폴링

- **Interrupt**: 완료 시 장치가 CPU에 신호 → ISR(상위/하위 반) 실행.
  - **MSI/MSI-X**: 메시지 기반 인터럽트. 코어/큐 별 분산.
  - **Coalescing**: 너무 잦은 인터럽트를 **묶어서** 알림(p99/CPU 균형).
- **Polling**: CPU가 주기적으로 상태 레지스터 확인. 고속 NIC/저지연에 사용(바쁜 대기).

### DMA(Direct Memory Access)

- **원리**: 장치가 **시스템 메모리**로 직접 읽기/쓰기. CPU는 제어만.
- **IOMMU**: 장치용 가상 주소→물리 주소 변환, **격리/보안** 및 연속성 요구 완화.
- **Scatter/Gather**: 불연속 메모리 조각을 **한 작업으로** 전송(리스트로 기술).

#### 간단 DMA 링 버퍼 개념 코드(C)

```c
// dma_ring.h — 컨셉용 (실드라이버 아님)
#include <stdint.h>
#define RING_SZ 1024

struct dma_desc {
    uint64_t addr;   // DMA 가능 물리/IOVA 주소
    uint32_t len;
    uint32_t flags;  // OWNED_BY_DEV, EOP 등
};
struct dma_ring {
    struct dma_desc desc[RING_SZ];
    uint32_t head; // 드라이버가 소비하는 위치
    uint32_t tail; // 드라이버가 장치로 enqueue 한 마지막+1
};
static inline uint32_t ring_next(uint32_t x){ return (x+1) % RING_SZ; }
```

### 장치 드라이버의 상/하위 반(Top/Bottom halves)

- **Top half(ISR)**: 인터럽트 즉시 처리 — 최소 작업(큐 인덱스 갱신, 타임스탬프).
- **Bottom half**: 소프트IRQ/Tasklet/Workqueue에서 무거운 처리(패킷 스택 상향 등).

### 메모리 맵 I/O 예제(C, Linux)

```c
// mmio_demo.c — MMIO 레지스터 맵 접근(컨셉)
// 컴파일: gcc -O2 mmio_demo.c -o mmio_demo
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char** argv){
    if(argc < 3){
        fprintf(stderr, "usage: %s <resource_file> <offset>\n", argv[0]);
        return 1;
    }
    int fd = open(argv[1], O_RDWR | O_SYNC);
    off_t off = strtoull(argv[2], NULL, 0);
    size_t sz = 0x1000; // 4KiB
    uint8_t* reg = mmap(NULL, sz, PROT_READ|PROT_WRITE, MAP_SHARED, fd, off);
    volatile uint32_t* REG_STATUS = (volatile uint32_t*)(reg + 0x00);
    volatile uint32_t* REG_CTRL   = (volatile uint32_t*)(reg + 0x04);

    uint32_t status = *REG_STATUS;
    printf("STATUS=0x%08x\n", status);
    *REG_CTRL = 0x1; // 예: 시작 비트 set
    munmap((void*)reg, sz); close(fd);
    return 0;
}
```

> 주의: 실제 하드웨어 주소/권한/바리어 필요. *실장치*에선 메모리 배리어(`__sync_synchronize()`/`atomic_thread_fence`)와 **비순서 완화 규칙**을 준수.

### NIC 고성능 경로 개념(DPDK/AF_XDP)

- **유저 공간**에서 **polling + hugepage + zero-copy**로 커널 우회.
- **장점**: p99↓, CPU 사용↑. 서비스 클래스/큐 분리로 QoS 확보.

---

## Application I/O Interface

### 파일 I/O(바이트 스트림)

#### POSIX 기본

- `open`/`read`/`write`/`close`, `lseek`(오프셋), `fsync`/`fdatasync`(내구).
- 플래그: `O_RDONLY`, `O_RDWR`, `O_NONBLOCK`, `O_DIRECT`(페이지 캐시 우회), `O_SYNC`.

```c
// posix_io_basic.c — 파일 크기만큼 읽어 SHA-256 출력(라이브러리 의존 없는 더미 해시)
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char** argv){
    if(argc<2){ fprintf(stderr,"usage: %s file\n", argv[0]); return 1; }
    int fd = open(argv[1], O_RDONLY);
    if(fd<0){ perror("open"); return 1; }
    uint64_t sum=0; char buf[1<<16];
    for(;;){
        ssize_t n = read(fd, buf, sizeof(buf));
        if(n==0) break;
        if(n<0){ perror("read"); return 1; }
        for(ssize_t i=0;i<n;i++) sum = (sum*131) + (unsigned char)buf[i];
    }
    close(fd);
    printf("digest(weak)=%016llx\n", (unsigned long long)sum);
    return 0;
}
```

#### Vectored I/O(Scatter/Gather)

- 여러 버퍼를 한 번에 읽고/쓴다: `readv`/`writev`, `sendmsg`/`recvmsg`.
- 장점: 시스템콜 오버헤드↓, 패킷 헤더+바디를 **한 번에** 송신.

{% raw %}
```c
// writev_demo.c — 헤더+바디를 하나의 TCP send로 전송
#include <sys/uio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>

int main(){
    int s = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in dst={.sin_family=AF_INET,.sin_port=htons(8080)};
    inet_pton(AF_INET,"127.0.0.1",&dst.sin_addr);
    connect(s,(struct sockaddr*)&dst,sizeof(dst));

    const char* h="GET / HTTP/1.1\r\nHost: localhost\r\n\r\n";
    const char* b=""; // 본문 없음
    struct iovec iov[2]={{.iov_base=(void*)h,.iov_len=strlen(h)},
                         {.iov_base=(void*)b,.iov_len=strlen(b)}};
    ssize_t n = writev(s, iov, 2);
    printf("sent=%zd\n", n);
    char buf[4096]; read(s, buf, sizeof(buf));
    close(s);
    return 0;
}
```
{% endraw %}

#### Direct I/O (`O_DIRECT`)

- 페이지 캐시 우회(파일시스템 구현/정렬 제약). **대형 순차 I/O**에서 유리. DMA 정렬에 맞춰 버퍼/오프셋 정렬 필요.

```c
// odirect_read.c — 4KiB 정렬 버퍼로 O_DIRECT 읽기
#define _GNU_SOURCE
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

int main(int argc, char** argv){
    if(argc<2){ fprintf(stderr,"usage: %s file\n", argv[0]); return 1; }
    int fd = open(argv[1], O_RDONLY | O_DIRECT);
    if(fd<0){ perror("open"); return 1; }
    size_t sz = 4096 * 16;
    void* buf;
    if(posix_memalign(&buf, 4096, sz)){ perror("memalign"); return 1; }
    off_t off = 0;
    ssize_t n = pread(fd, buf, sz, off); // 오프셋도 4KiB 정렬
    if(n<0) perror("pread");
    else printf("read=%zd bytes\n", n);
    free(buf); close(fd);
    return 0;
}
```

#### Memory-mapped I/O (`mmap`)

- 파일을 **프로세스 주소 공간**에 매핑, **페이지 폴트 기반 on-demand** 접근, COW/공유 가능.
- 장점: **복사 제거**, 랜덤 접근 시 간결한 코드, OS 리드어헤드/페이지 캐시 활용.

```c
// mmap_scan.c — 파일 매핑 후 특정 바이트 카운트
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc,char**argv){
    if(argc<3){ fprintf(stderr,"usage: %s file byte\n", argv[0]); return 1; }
    int fd=open(argv[1],O_RDONLY);
    struct stat st; fstat(fd,&st);
    unsigned char* p = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    unsigned char target=(unsigned char)argv[2][0];
    size_t cnt=0; for(off_t i=0;i<st.st_size;i++) if(p[i]==target) cnt++;
    printf("count=%zu\n", cnt);
    munmap(p, st.st_size); close(fd);
    return 0;
}
```

### 비동기 파일 I/O

- **POSIX AIO**(`aio_read`/`aio_write`) — 신호/스레드 기반 완료 통지(구현 차이로 일관성 부족).
- **io_uring**(Linux) — **Submission/Completion** 큐를 유저 공간에서 공유. 낮은 오버헤드/풍부한 연산.

```c
// uring_cat.c — io_uring으로 파일 비동기 읽기(간단 버전)
#define _GNU_SOURCE
#include <liburing.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char** argv){
    if(argc<2){ fprintf(stderr,"usage: %s file\n", argv[0]); return 1; }
    int fd = open(argv[1], O_RDONLY);
    struct io_uring ring; io_uring_queue_init(64, &ring, 0);

    const size_t BS=1<<16;
    off_t off=0; ssize_t n;
    void* buf = aligned_alloc(4096, BS);
    for(;;){
        struct io_uring_sqe* sqe = io_uring_get_sqe(&ring);
        io_uring_prep_read(sqe, fd, buf, BS, off);
        io_uring_submit(&ring);
        struct io_uring_cqe* cqe; io_uring_wait_cqe(&ring, &cqe);
        n = cqe->res; io_uring_cqe_seen(&ring, cqe);
        if(n<=0) break;
        write(STDOUT_FILENO, buf, n);
        off += n;
    }
    free(buf); io_uring_queue_exit(&ring); close(fd);
    return 0;
}
```

### 네트워크 I/O (소켓)

#### 블로킹 vs 논블로킹 + 멀티플렉싱

- **select/poll**: 호환성↑, 대규모 FD에서 오버헤드↑.
- **epoll**(Linux), **kqueue**(BSD/macOS), **IOCP**(Windows) — 대규모 동접에 최적.

```c
// epoll_echo.c — 단일 스레드 epoll 에코 서버
#define _GNU_SOURCE
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

static int make_nonblock(int fd){
    int fl = fcntl(fd, F_GETFL, 0);
    return fcntl(fd, F_SETFL, fl | O_NONBLOCK);
}
int main(){
    int s = socket(AF_INET, SOCK_STREAM, 0);
    int one=1; setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
    struct sockaddr_in addr={.sin_family=AF_INET,.sin_port=htons(9000),.sin_addr={.s_addr=INADDR_ANY}};
    bind(s,(struct sockaddr*)&addr,sizeof(addr));
    listen(s, 512);
    make_nonblock(s);

    int ep=epoll_create1(0);
    struct epoll_event ev={.events=EPOLLIN,.data.fd=s};
    epoll_ctl(ep, EPOLL_CTL_ADD, s, &ev);

    struct epoll_event events[1024];
    char buf[4096];
    for(;;){
        int n=epoll_wait(ep, events, 1024, -1);
        for(int i=0;i<n;i++){
            int fd=events[i].data.fd;
            if(fd==s){
                for(;;){
                    int c = accept(s, NULL, NULL);
                    if(c<0){ if(errno==EAGAIN) break; perror("accept"); break;}
                    make_nonblock(c);
                    struct epoll_event evc={.events=EPOLLIN|EPOLLET,.data.fd=c};
                    epoll_ctl(ep, EPOLL_CTL_ADD, c, &evc);
                }
            }else{
                for(;;){
                    ssize_t m = read(fd, buf, sizeof(buf));
                    if(m==0){ close(fd); break; }
                    if(m<0){ if(errno==EAGAIN) break; perror("read"); close(fd); break; }
                    ssize_t off=0;
                    while(off<m){
                        ssize_t w = write(fd, buf+off, m-off);
                        if(w<0){ if(errno==EAGAIN) break; perror("write"); close(fd); break; }
                        off += w;
                    }
                }
            }
        }
    }
}
```

#### UDP + Scatter/Gather

{% raw %}
```c
// udp_sg.c — sendmsg로 헤더/바디 결합 전송
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/uio.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>

int main(){
    int s=socket(AF_INET,SOCK_DGRAM,0);
    struct sockaddr_in to={.sin_family=AF_INET,.sin_port=htons(7000)};
    inet_pton(AF_INET,"127.0.0.1",&to.sin_addr);
    char h[]="H:", b[]="payload";
    struct iovec iov[2]={{h,sizeof(h)-1},{b,sizeof(b)-1}};
    struct msghdr msg={.msg_name=&to,.msg_namelen=sizeof(to),.msg_iov=iov,.msg_iovlen=2};
    sendmsg(s,&msg,0);
    close(s); return 0;
}
```
{% endraw %}

### 파이프/이벤트/신호/Completion

- **파이프/UNIX 도메인 소켓**: 프로세스 간 데이터 스트림/파일 디스크립터 전달.
- **이벤트FD/Signalfd**: 이벤트 기반 설계에 적합, epoll과 결합.
- **Completion 포트(IOCP)**: Windows 비동기 모델, 스레드 풀에 완료 큐.

### 내구성/정합(스토리지 인터페이스)

- **`fsync()`**: 해당 파일의 데이터+메타데이터 내구화.
- **`fdatasync()`**: 데이터 중심 내구화(메타 일부 제외).
- **FUA/Flush**: 장치 배리어. WAL/DB는 **그룹 커밋**으로 비용 제어.
- **`O_TRUNC`**, **`rename()`**를 통한 **원자적 교체** 패턴.

### 고급 주제: Zero-copy 송수신

- **`sendfile(out, in, …)`**: 파일 → 소켓 전송 중간 복사 제거.
- **`splice/tee`**: 파이프로 커널 내 데이터 경로 연결.
- **`mmap + write`** vs **`read + write`**: 복사/페이지 폴트/캐시 압력 트레이드오프.

```c
// sendfile_http.c — 간단한 정적 파일 송신기 (개념)
#include <sys/sendfile.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int send_file(int sock, const char* path){
    int fd=open(path,O_RDONLY); if(fd<0) return -1;
    struct stat st; fstat(fd,&st);
    dprintf(sock,"HTTP/1.1 200 OK\r\nContent-Length: %ld\r\n\r\n", (long)st.st_size);
    off_t off=0; while(off<st.st_size){
        ssize_t n = sendfile(sock, fd, &off, st.st_size-off);
        if(n<=0){ close(fd); return -1; }
    }
    close(fd); return 0;
}
```

### Windows 대비표(간단 맵핑)

| 기능 | POSIX/Linux | Windows |
|---|---|---|
| 블로킹 파일 I/O | `read/write` | `ReadFile/WriteFile` |
| 비동기 파일 I/O | `io_uring`/`aio_*` | `OVERLAPPED` + `IOCP` |
| 메모리 매핑 | `mmap/munmap` | `CreateFileMapping/MapViewOfFile` |
| 이벤트 대기 | `epoll/poll/select` | `WSAEventSelect`, `IOCP` |
| Direct I/O | `O_DIRECT` | `FILE_FLAG_NO_BUFFERING` |

### 설계 체크리스트

1) **프로파일**: 읽기/쓰기 비율, 요청 크기, 동시성, 내구 요구.
2) **API 선택**: 소규모/간단 → 블로킹; 대규모 동접 → `epoll`/kqueue/IOCP; 대용량 파일 → `mmap`/`sendfile`/`O_DIRECT`.
3) **버퍼 전략**: 대형 버퍼(128KiB~1MiB)로 배치; `readv/writev`로 헤더/바디 결합.
4) **내구**: WAL/그룹 커밋; `fsync` 빈도와 배리어 영향 관측(p99).
5) **NUMA/CPU 핀**: 큐/IRQ/스레드의 **노드 로컬** 정렬.

---

## 종합 실습

### 실습 A — 같은 파일을 `read` vs `mmap` vs `O_DIRECT`

1) 4KiB 랜덤 vs 1MiB 순차 패턴으로 **IPC(ms)/CPU%/page-faults** 비교.
2) `perf stat -e page-faults,cache-misses`와 `strace -c`로 오버헤드 가시화.

### 실습 B — epoll 서버의 p99 관측

1) `epoll_echo.c`와 클라이언트 5,000개(짐발 생성기)로 RTT 분포.
2) 인터럽트 coalescing, NAPI polling 레벨을 바꾸어 p99 변화를 기록.

### 실습 C — io_uring로 파이프라인

1) `uring_cat.c`를 확장하여 파일→소켓을 **링크드 SQE(send+splice)** 로 zero-copy 구성.
2) QD(동시 outstanding), SQPOLL 모드, IORING_SETUP_COOP_TASKRUN 옵션 실험.

---

## 핵심 요약

- **12.1**: I/O는 **지연/처리량/큐잉**의 균형 게임. 버퍼링·캐싱·비동기화로 **시스템콜/컨텍스트 전환**을 줄이고 **배치/병합**을 늘리면 좋다.
- **12.2**: 하드웨어는 **MMIO/인터럽트/DMA**가 핵심. MSI-X, IOMMU, Scatter/Gather로 저오버헤드·고병렬 경로를 만든다.
- **12.3**: 앱 인터페이스 선택이 성능 80%를 결정. **`epoll/kqueue/IOCP`**, **`mmap/sendfile/O_DIRECT`**, **`io_uring`** 등 워크로드에 맞는 조합을 택하고, **내구성(fsync/flush)** 과 **zero-copy**를 적절히 사용하자.
