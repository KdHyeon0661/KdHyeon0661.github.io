---
layout: post
title: Java - 직렬화
date: 2025-07-29 18:20:23 +0900
category: Java
---
# 직렬화(Serializable)

## 개념과 흐름

**직렬화(Serialization)**: **객체 그래프**를 **바이트 스트림**으로 변환해 디스크/네트워크에 저장·전송하는 과정.
**역직렬화(Deserialization)**: 바이트 스트림 → 객체 그래프 복원.

- Java 기본 직렬화: `java.io.Serializable` **마커 인터페이스**. 구현 메서드 없음.
- **객체 그래프 보존**: 동일 객체 참조(아이덴티티), 순환 참조, 중복 참조를 스트림이 표현/복원.
- **비직렬화 상위 클래스**: `Serializable`이 **아닌** 상위 클래스는 **no-arg 생성자**로 복원 중 초기화.

**간단 다이어그램**

```
[객체 그래프] --ObjectOutputStream--> [바이트 스트림]
[바이트 스트림] --ObjectInputStream--> [객체 그래프(복원)]
```

---

## 빠른 시작: 기본 사용

### 직렬화/역직렬화 예제 (기본)

```java
import java.io.*;
import java.util.List;

class Person implements Serializable {
    @Serial private static final long serialVersionUID = 1L; // Java 14+의 @Serial 권장
    String name;
    int age;
    List<String> tags;

    Person(String name, int age, List<String> tags) {
        this.name = name; this.age = age; this.tags = tags;
    }
}

public class BasicSerialization {
    public static void main(String[] args) throws Exception {
        Person p = new Person("홍길동", 30, List.of("dev", "java"));

        // 직렬화
        try (ObjectOutputStream oos =
                 new ObjectOutputStream(new FileOutputStream("person.ser"))) {
            oos.writeObject(p);
        }

        // 역직렬화
        try (ObjectInputStream ois =
                 new ObjectInputStream(new FileInputStream("person.ser"))) {
            Person q = (Person) ois.readObject();
            System.out.println(q.name + " / " + q.age + " / " + q.tags);
        }
    }
}
```

> **중요**: 포함된 필드 타입들도 `Serializable` 이어야 합니다(컬렉션/내부 객체 포함). 불가능하면 `transient` 처리 혹은 커스텀 직렬화로 우회.

---

## serialVersionUID — 클래스 버전 관리

- **역직렬화 시 클래스 호환성 식별자**. 불일치하면 `InvalidClassException`.
- **명시적 선언 권장**(자동 생성은 컴파일러/환경 따라 달라져 **취약**).

```java
class Person implements Serializable {
    @Serial private static final long serialVersionUID = 2L; // 변경 시 주의
}
```

### 클래스 진화(필드 추가/삭제/타입 변경)와 호환성

| 변경 | 호환성(기본) | 비고 |
|---|---|---|
| **필드 추가** | 보통 **호환** | 새 필드는 기본값(null/0/false)로 복원됨. 커스텀 초기화 필요하면 `readObject`에서 보정 |
| **필드 삭제** | 보통 **호환** | 스트림에 남은 데이터는 무시(단, `serialPersistentFields` 활용 가능) |
| **필드 타입 변경** | **비호환** | `InvalidClassException` 위험. `readObject`로 수동 변환하거나 `Externalizable` 고려 |
| **상속 구조 변경** | **주의** | 상위 직렬화/비직렬화 여부와 생성자 요건 검토 |
| **serialVersionUID 변경** | **비호환** | 명시적 변경은 기존 데이터와 단절 의미 |

> 실무 팁: **의도된 호환성**을 유지하려면 `serialVersionUID`를 고정하고, 변경 시 `readObject`로 **하위 호환**을 수동 처리.

---

## transient — 민감정보/비직렬화 필드 제외

```java
class User implements Serializable {
    @Serial private static final long serialVersionUID = 1L;
    String username;
    transient String password;     // 디스크/와이어에 남기지 않음
}
```

- `static` 필드는 **직렬화 대상 아님**(클래스 레벨).
- 참조형 필드는 **전체 그래프**가 따라 직렬화되므로, 노출되면 안 되는 객체는 `transient` 또는 **별도 마스킹** 필요.

---

## 커스텀 직렬화 — writeObject / readObject / serialPersistentFields

### 패턴과 시그니처 (정확히 일치해야 함)

```java
private void writeObject(ObjectOutputStream out) throws IOException { ... }
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { ... }
```
> Java 14+에서는 `@Serial` 애너테이션으로 시그니처 실수를 방지.

### 예제: 민감정보 마스킹/해시하고 복원

```java
class Account implements Serializable {
    @Serial private static final long serialVersionUID = 1L;
    String id;
    transient String plainPassword; // 원문 제외
    byte[] passwordHash;            // 대신 저장

    @Serial private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject(); // non-transient 필드 처리
        // 추가 데이터 없음(이미 hash만 보관). 필요시 salt 등 별도 write 가능.
    }

    @Serial private void readObject(ObjectInputStream in)
            throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        // 복원 후 불변식 보정: plainPassword는 null 유지
    }
}
```

### serialPersistentFields — 스트림 필드 집합 제어

```java
class V2 implements Serializable {
    @Serial private static final long serialVersionUID = 2L;
    private int w, h; // 내부 표기는 바뀌었지만 스트림 호환 유지
    @Serial private static final ObjectStreamField[] serialPersistentFields = {
        new ObjectStreamField("width",  int.class),
        new ObjectStreamField("height", int.class)
    };

    @Serial private void writeObject(ObjectOutputStream out) throws IOException {
        ObjectOutputStream.PutField f = out.putFields();
        f.put("width",  w);
        f.put("height", h);
        out.writeFields();
    }

    @Serial private void readObject(ObjectInputStream in)
            throws IOException, ClassNotFoundException {
        ObjectInputStream.GetField f = in.readFields();
        w = f.get("width", 0);
        h = f.get("height", 0);
    }
}
```

> **효과**: 내부 필드명이 바뀌어도 **스트림 포맷(필드명/순서)을 유지**하여 **하위 호환**.

---

## 객체 정체성/순환 참조/중복 참조 — 자동 처리

- Java 스트림은 **핸들 테이블**로 같은 객체를 **한 번만 기록**하고 **참조 공유**를 복원.
- **순환 참조**(A→B→A)도 안전히 처리.

```java
class Node implements Serializable {
    String name;
    Node next;
    Node(String name) { this.name = name; }
}
// A.next = B; B.next = A; 직렬화/역직렬화 OK (아이덴티티 보존)
```

---

## `readResolve` / `writeReplace` — 싱글턴/프록시/불변 보존

- `writeReplace`: 직렬화 직전 **다른 객체로 교체**.
- `readResolve`: 역직렬화 직후 **대체 객체로 치환**.

### 싱글턴 보존

```java
final class Singleton implements Serializable {
    @Serial private static final long serialVersionUID = 1L;
    private static final Singleton INSTANCE = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() { return INSTANCE; }

    @Serial private Object readResolve() throws ObjectStreamException {
        return INSTANCE; // 역직렬화 시 항상 동일 인스턴스 보장
    }
}
```

### 직렬화 프록시 패턴 (권장)

```java
final class Period implements Serializable {
    @Serial private static final long serialVersionUID = 1L;
    private final java.time.LocalDate start, end;

    Period(LocalDate start, LocalDate end) {
        if (end.isBefore(start)) throw new IllegalArgumentException();
        this.start = start; this.end = end;
    }

    // 진짜 대신 Proxy를 내보냄
    @Serial private Object writeReplace() { return new SerializationProxy(this); }
    @Serial private void readObject(ObjectInputStream in) throws InvalidObjectException {
        throw new InvalidObjectException("Proxy required");
    }

    private static class SerializationProxy implements Serializable {
        @Serial private static final long serialVersionUID = 1L;
        private final LocalDate start, end;
        SerializationProxy(Period p) { this.start = p.start; this.end = p.end; }
        @Serial private Object readResolve() { return new Period(start, end); }
    }
}
```

> **효과**: 역직렬화 시 **불변식**을 항상 재검증. 안전하고 깔끔.

---

## Externalizable — 완전 수동 직렬화

- `Externalizable` 구현 시 `writeExternal`/`readExternal`을 **직접** 구현.
- **공개 no-arg 생성자 필수**. 스트림 형식을 **완전히 통제**(버전 필드 포함).
- 강력하지만 **취약**(필드 추가/삭제 시 직접 처리).

```java
class UserV2 implements Externalizable {
    public String name;
    public int age;

    public UserV2() {} // 반드시 public no-arg

    @Override public void writeExternal(ObjectOutput out) throws IOException {
        out.writeUTF(name);
        out.writeInt(age);
    }
    @Override public void readExternal(ObjectInput in) throws IOException {
        this.name = in.readUTF();
        this.age = in.readInt();
    }
}
```

---

## enum / record 특수 처리

### enum

- **이름(name)** 기준으로 직렬화. **사용자 `writeObject/readObject` 금지(무시/예외)**.
- 필드가 있더라도 **이름만으로 복원**되므로, 역직렬화 후 불변식이 자동 보장.

### record (Java 16+)

- 레코드도 `Serializable` 구현 가능(명시 필요).
- 컴포넌트 필드가 모두 직렬화 가능해야 하며, 역직렬화 시 **canonical constructor 규칙** 유지가 핵심.
- 불변 보장은 강하지만, 커스텀 검증은 `readResolve`를 통해 재적용할 수 있음.

```java
record Point(int x, int y) implements Serializable {
    @Serial private static final long serialVersionUID = 1L;
}
```

---

## 보안 — 절대 **신뢰할 수 없는 입력**을 역직렬화하지 말 것

- **가젯 체인**을 이용한 임의 코드 실행 위험.
- 반드시 **허용 목록(allowlist) 기반 필터** 적용: **Java 9+ `ObjectInputFilter`** (8u121+ 일부 백포트).

### 글로벌/스트림 단위 필터

```java
import java.io.*;
import java.util.*;
import java.io.ObjectInputFilter.*;

public class SafeDeserialize {
    public static void main(String[] args) throws Exception {
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("in.bin"))) {
            // 패턴: 클래스 이름/패키지 제한, 배열/깊이/총 바이트 제한
            ObjectInputFilter filter = ObjectInputFilter.Config.createFilter(
                "maxdepth=20;maxbytes=1048576;java.base/*;com.myapp.*;!*"
            );
            ois.setObjectInputFilter(filter);
            Object obj = ois.readObject(); // 허용 외는 REJECTED
        }
    }
}
```

### 안전 수칙

- **네트워크로부터 직렬화 데이터 수신 금지**(대신 JSON/CBOR/Protobuf 등 안전 파서 사용).
- 클래스 로더/패키지 범위 제한, **화이트리스트 필터** 적용.
- 민감정보는 `transient` + 별도 암호화/서명.
- **커스텀 readObject**에서 **검증**(범위/포맷/불변식).

---

## 성능/포맷/대안

| 선택지 | 장점 | 단점 | 적합 용도 |
|---|---|---|---|
| Java 기본 직렬화 | 쉬움, 객체 그래프/아이덴티티 보존 | 포맷 불투명, 느릴 수 있음, 보안 이슈 | 내부 캐시/스냅샷, 신뢰 경계 안 |
| JSON(Jackson/Gson) | 텍스트/가독성, 광범위 | 크기 큼, 속도 중간, 그래프/ID 별도 처리 필요 | 외부 API, 로그/설정 |
| Protobuf/Avro/FlatBuffers | 작고 빠름, 스키마/진화 지원 | 도구/스키마 필요 | 고성능 RPC/메시징 |
| Kryo | 빠른 바이너리, 자동 등록 | 클래스 진화 관리 주의 | JVM 내부 고성능 캐시 |

**실무 팁**: 네트워크 경계/외부 시스템에는 **스키마 기반 포맷(Protobuf/Avro)** 권장.

---

## 스트림 유틸 — 메모리/암호화/압축

### 메모리 직렬화

```java
byte[] toBytes(Serializable obj) throws IOException {
    try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(bos)) {
        oos.writeObject(obj);
        return bos.toByteArray();
    }
}
```

### 압축 결합

```java
try (ObjectOutputStream oos = new ObjectOutputStream(
         new java.util.zip.GZIPOutputStream(new FileOutputStream("data.ser.gz")))) {
    oos.writeObject(obj);
}
```

### (참고) 암호화 결합

- `CipherOutputStream`/`CipherInputStream`으로 **암호화된 직렬화** 가능(키 관리 필수).

---

## 예외/자주 보는 에러와 대처

| 예외 | 원인 | 해결 |
|---|---|---|
| `NotSerializableException` | 필드/내부 객체가 `Serializable` 아님 | `transient`, 대체 직렬화, 타입 교체 |
| `InvalidClassException` | `serialVersionUID` 불일치/클래스 진화 비호환 | UID 유지/`readObject`로 변환, `serialPersistentFields` |
| `OptionalDataException` | 예상과 다른 원시/오브젝트 순서 | I/O 순서 일치, 버전 필드로 분기 |
| `StreamCorruptedException` | 깨진 헤더/프로토콜 불일치 | 같은 계층에서 같은 흐름으로 read/write, 중간 조작 금지 |

---

## 테스트/호환성 전략

- **골든 파일**: 특정 버전에서 직렬화한 바이트를 테스트 리소스로 보관 → 새 버전에서 역직렬화 테스트.
- **스키마 버전 필드**: 커스텀 직렬화 시 첫 바이트로 `version`을 기록 → `readObject`에서 분기.
- **대량 테스트**: 다양한 그래프(순환/중복/깊은 컬렉션) 케이스로 회귀.

---

## 고급: 클래스 로딩/패키지 이동 호환

- 패키지/클래스명 변경 시 `ObjectInputStream.resolveClass`를 오버라이드하여 **리맵** 가능.
```java
ObjectInputStream ois = new ObjectInputStream(in) {
    @Override protected Class<?> resolveClass(ObjectStreamClass desc)
            throws IOException, ClassNotFoundException {
        String name = desc.getName();
        if (name.equals("old.pkg.Person")) return newpkg.Person.class;
        return super.resolveClass(desc);
    }
};
```

---

## 스레드/락/리소스 — 직렬화 대상 아님

- `Thread`, `Lock`, `Socket`, `InputStream` 등 **프로세스/OS 자원**은 직렬화 불가.
- 필요한 경우 **핸들/설정 값만** 저장하고, 역직렬화 시 **재연결/재초기화**.

---

## 람다/익명 클래스

- 람다는 **캡처된 타깃 타입**이 `Serializable`일 때만 직렬화 가능(권장 X).
- 구조/컴파일러 의존. 장기 저장 포맷으로 **비권장**.

---

## 체크리스트 (실무 요약)

- [ ] **신뢰 경계 밖**에서 들어오는 바이트는 **역직렬화 금지**(필요시 `ObjectInputFilter` + allowlist).
- [ ] `serialVersionUID` **명시**. 클래스 진화 계획 수립.
- [ ] 민감정보는 `transient` + 필요 시 **해시/암호화**.
- [ ] 불변식 보존은 **직렬화 프록시 패턴** 또는 `readResolve`.
- [ ] 외부 통신/장기 저장은 **스키마 포맷(Protobuf/Avro)** 고려.
- [ ] 골든 파일 테스트로 **버전 호환** 보장.
- [ ] 커스텀 직렬화 시 `@Serial`, `serialPersistentFields` 적극 활용.
- [ ] 대용량/빈번 I/O는 **압축/버퍼링** 및 대안 포맷 성능 측정.

---

## 예제 모음

### 하위 호환: 필드 추가 후 디폴트값 보정

```java
class Profile implements Serializable {
    @Serial private static final long serialVersionUID = 2L;
    String name;
    Integer age; // v2에서 추가

    @Serial private void readObject(ObjectInputStream in)
            throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        if (age == null) age = -1; // v1 데이터 호환
    }
}
```

### 버전 필드로 포맷 제어(Externalizable 스타일)

```java
class Msg implements Serializable {
    @Serial private static final long serialVersionUID = 1L;
    int version = 2;
    String text; long ts; String lang; // v2에서 lang 추가

    @Serial private void writeObject(ObjectOutputStream out) throws IOException {
        out.writeInt(version);
        out.writeUTF(text);
        out.writeLong(ts);
        out.writeBoolean(lang != null);
        if (lang != null) out.writeUTF(lang);
    }
    @Serial private void readObject(ObjectInputStream in)
            throws IOException, ClassNotFoundException {
        int v = in.readInt();
        text = in.readUTF();
        ts = in.readLong();
        if (v >= 2 && in.readBoolean()) lang = in.readUTF();
    }
}
```

### 컬렉션 대량/순환 참조 확인

```java
class Node implements Serializable {
    String name; List<Node> children = new java.util.ArrayList<>();
    Node(String n) { name = n; }
}

Node a = new Node("A"), b = new Node("B");
a.children.add(b); b.children.add(a); // 서로 참조
// 기본 직렬화로 안전히 처리됨
```

---

## (선택) 직관적 오버헤드 추정 — 단순 근사

> 실제 포맷은 복잡하지만, 작은 객체가 많을수록 **헤더/클래스 설명자** 오버헤드 비중이 커진다.

대략:
$$
\text{Total} \approx \text{StreamHeader} + \sum_i (\text{ClassDesc}_i + \text{ObjectHeader}_i + \text{Fields}_i)
$$

- StreamHeader(2바이트 마커 + 버전 등) + 클래스당 설명자(ClassDesc) + 객체별 마커/핸들.
- **작은 레코드 다량** → Protobuf/Avro가 유리한 이유.

---

## 마무리

- Java 직렬화는 **간단·강력**하지만, **보안/호환성**과 **장기 유지** 관점의 난점이 존재.
- 내부 신뢰 경계/캐시·스냅샷에 **제한적으로 사용**하고, 외부 통신·장기 스토리지는 **스키마 기반 포맷**을 권장.
- 필요한 경우 `serialVersionUID` + `readObject`/`serialPersistentFields`/`readResolve`로 **안전한 진화**를 설계하라.
- 무엇보다 **역직렬화 입력 검증(ObjectInputFilter)** 을 습관화할 것.

---
```java
// 간단한 직렬화 라운드트립 유틸 (테스트/벤치마크에 유용)
public static <T extends Serializable> T roundTrip(T obj) throws Exception {
    byte[] data;
    try (var bos = new java.io.ByteArrayOutputStream();
         var oos = new java.io.ObjectOutputStream(bos)) {
        oos.writeObject(obj);
        data = bos.toByteArray();
    }
    try (var bis = new java.io.ByteArrayInputStream(data);
         var ois = new java.io.ObjectInputStream(bis)) {
        return (T) ois.readObject();
    }
}
```
