---
layout: post
title: 파이썬 - 클래스 (3)
date: 2024-08-13 19:20:23 +0900
category: Python
---
# 파이썬 클래스 3 – 데이터 클래스, 추상 클래스, 캡슐화, MRO

이번 글에서는 파이썬 클래스의 고급 기능들을 살펴보겠습니다. 데이터 중심 클래스를 간편하게 만드는 `dataclass`, 인터페이스를 정의하는 추상 클래스(ABC), 정보 은닉을 위한 캡슐화 기법, 그리고 다중 상속에서 메서드 탐색 순서를 결정하는 MRO에 대해 다룹니다.

## 데이터 클래스 (`dataclass`)

파이썬 3.7부터 도입된 `dataclass` 데코레이터는 데이터를 저장하는 클래스를 간편하게 생성할 수 있게 해줍니다. `__init__`, `__repr__`, `__eq__` 등의 반복적인 메서드 구현을 자동으로 생성해주어 생산성을 크게 향상시킵니다.

### 기본 사용법

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int

# 자동 생성된 __init__ 사용
person = Person("Alice", 25)

# 자동 생성된 __repr__ 사용
print(person)  # Person(name='Alice', age=25)

# 자동 생성된 __eq__ 사용
person2 = Person("Alice", 25)
print(person == person2)  # True
```

### 데이터 클래스 옵션 상세 설명

`dataclass` 데코레이터는 다양한 옵션을 제공하여 클래스의 동작을 세밀하게 제어할 수 있습니다.

```python
from dataclasses import dataclass
from typing import List

@dataclass(
    init=True,      # __init__ 메서드 생성 (기본값)
    repr=True,      # __repr__ 메서드 생성 (기본값)
    eq=True,        # __eq__ 메서드 생성 (기본값)
    order=False,    # 비교 연산자 메서드 생성
    frozen=False,   # 불변 클래스로 생성
    slots=False,    # __slots__ 사용 (Python 3.10+)
    kw_only=False,  # 키워드 전용 인자 (Python 3.10+)
)
class Product:
    name: str
    price: float
    tags: List[str] = []  # 주의: 가변 기본값은 문제를 일으킬 수 있음
```

### 필드 제어: `field()` 함수

`field()` 함수를 사용하여 개별 필드의 동작을 세밀하게 제어할 수 있습니다.

```python
from dataclasses import dataclass, field
from typing import List, ClassVar
from uuid import uuid4

@dataclass
class InventoryItem:
    # 필드 메타데이터
    name: str = field(metadata={"description": "상품 이름"})
    
    # 기본값 지정
    category: str = "general"
    
    # 가변 객체의 기본값 (권장 방식)
    tags: List[str] = field(default_factory=list)
    
    # 비교에서 제외
    internal_id: str = field(default_factory=lambda: str(uuid4()), compare=False)
    
    # 출력에서 제외
    secret_token: str = field(default="hidden", repr=False)
    
    # 클래스 변수 (인스턴스 변수가 아님)
    next_id: ClassVar[int] = 1
    
    def __post_init__(self):
        """인스턴스 초기화 후 추가 처리"""
        if len(self.name) < 2:
            raise ValueError("상품 이름은 2자 이상이어야 합니다")

# 사용 예제
item = InventoryItem("Laptop")
print(item)  # InventoryItem(name='Laptop', category='general', tags=[])
```

### 불변 데이터 클래스

`frozen=True` 옵션을 사용하면 불변(immutable) 데이터 클래스를 생성할 수 있습니다.

```python
@dataclass(frozen=True)
class Point:
    x: int
    y: int
    
    def __post_init__(self):
        """불변 클래스에서도 검증 가능"""
        if self.x < 0 or self.y < 0:
            raise ValueError("좌표는 0 이상이어야 합니다")

p = Point(3, 4)
# p.x = 5  # FrozenInstanceError 발생
```

### 데이터 클래스 유틸리티 함수

`dataclasses` 모듈은 데이터 클래스를 다루기 위한 유용한 함수들을 제공합니다.

```python
from dataclasses import dataclass, asdict, astuple, replace, fields

@dataclass
class Student:
    name: str
    age: int
    grade: str = "A"

# 객체 생성
student = Student("Kim", 20, "B")

# 딕셔너리로 변환
print(asdict(student))  # {'name': 'Kim', 'age': 20, 'grade': 'B'}

# 튜플로 변환
print(astuple(student))  # ('Kim', 20, 'B')

# 필드 정보 확인
for field_info in fields(student):
    print(f"{field_info.name}: {field_info.type}")

# 불변 방식으로 수정 (새 객체 생성)
updated = replace(student, age=21, grade="A+")
print(updated)  # Student(name='Kim', age=21, grade='A+')
```

### 데이터 클래스 상속

데이터 클래스도 상속이 가능하며, 필드 순서에 주의해야 합니다.

```python
@dataclass
class Vehicle:
    make: str
    model: str

@dataclass
class Car(Vehicle):
    year: int
    color: str = "white"

# 부모 클래스 필드가 먼저, 자식 클래스 필드가 뒤에 옴
car = Car("Hyundai", "Sonata", 2023, "black")
print(car)  # Car(make='Hyundai', model='Sonata', year=2023, color='black')
```

### 실전 예제: 주문 시스템

```python
from dataclasses import dataclass, field
from datetime import datetime
from typing import List
from decimal import Decimal

@dataclass
class OrderItem:
    product_id: str
    product_name: str
    quantity: int
    unit_price: Decimal
    
    @property
    def total_price(self) -> Decimal:
        return self.unit_price * self.quantity

@dataclass
class Order:
    order_id: str
    customer_id: str
    items: List[OrderItem] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    status: str = "pending"
    
    def add_item(self, product_id: str, product_name: str, 
                 quantity: int, unit_price: Decimal) -> None:
        self.items.append(OrderItem(product_id, product_name, quantity, unit_price))
    
    @property
    def total_amount(self) -> Decimal:
        return sum(item.total_price for item in self.items)
    
    def __post_init__(self):
        if self.total_amount < Decimal('0'):
            raise ValueError("주문 금액은 0 이상이어야 합니다")

# 사용 예제
order = Order("ORD001", "CUST001")
order.add_item("P001", "노트북", 1, Decimal('1500000'))
order.add_item("P002", "마우스", 2, Decimal('25000'))

print(f"주문 총액: {order.total_amount}원")
print(f"주문 상태: {order.status}")
```

---

## 추상 클래스 (Abstract Base Class, ABC)

추상 클래스는 구현을 강제하는 인터페이스를 정의하는 데 사용됩니다. 하나 이상의 추상 메서드를 포함하며, 직접 인스턴스화할 수 없습니다.

### 기본 사용법

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    """도형 클래스의 추상 기본 클래스"""
    
    @abstractmethod
    def area(self) -> float:
        """면적을 계산하는 추상 메서드"""
        pass
    
    @abstractmethod
    def perimeter(self) -> float:
        """둘레를 계산하는 추상 메서드"""
        pass
    
    def description(self) -> str:
        """구체적 메서드도 포함 가능"""
        return "이것은 도형입니다"

# 추상 클래스는 직접 인스턴스화할 수 없음
# shape = Shape()  # TypeError 발생

class Circle(Shape):
    """원 클래스 - 추상 메서드 구현 필요"""
    
    def __init__(self, radius: float):
        self.radius = radius
    
    def area(self) -> float:
        return 3.14159 * self.radius ** 2
    
    def perimeter(self) -> float:
        return 2 * 3.14159 * self.radius

class Rectangle(Shape):
    """사각형 클래스 - 추상 메서드 구현 필요"""
    
    def __init__(self, width: float, height: float):
        self.width = width
        self.height = height
    
    def area(self) -> float:
        return self.width * self.height
    
    def perimeter(self) -> float:
        return 2 * (self.width + self.height)

# 사용 예제
circle = Circle(5)
print(f"원 면적: {circle.area():.2f}")      # 78.54
print(f"원 둘레: {circle.perimeter():.2f}")  # 31.42

rectangle = Rectangle(4, 6)
print(f"사각형 면적: {rectangle.area()}")      # 24
print(f"사각형 둘레: {rectangle.perimeter()}")  # 20
```

### 다양한 추상 멤버 타입

```python
from abc import ABC, abstractmethod, abstractclassmethod, abstractstaticmethod, abstractproperty

class DatabaseConnector(ABC):
    """데이터베이스 연결자 추상 클래스"""
    
    # 추상 클래스 메서드
    @abstractclassmethod
    def create_connection(cls, connection_string: str) -> 'DatabaseConnector':
        pass
    
    # 추상 인스턴스 메서드
    @abstractmethod
    def connect(self) -> bool:
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        pass
    
    # 추상 프로퍼티 (옛날 방식)
    @abstractproperty
    def is_connected(self) -> bool:
        pass
    
    # 추상 정적 메서드
    @abstractstaticmethod
    def validate_connection_string(conn_str: str) -> bool:
        pass
    
    # 구체적 메서드
    def get_connection_info(self) -> str:
        return "데이터베이스 연결 정보"

class MySQLConnector(DatabaseConnector):
    
    @classmethod
    def create_connection(cls, connection_string: str) -> 'MySQLConnector':
        print(f"MySQL 연결 생성: {connection_string}")
        return cls()
    
    def connect(self) -> bool:
        print("MySQL에 연결 중...")
        self._connected = True
        return True
    
    def disconnect(self) -> bool:
        print("MySQL 연결 종료 중...")
        self._connected = False
        return True
    
    @property
    def is_connected(self) -> bool:
        return getattr(self, '_connected', False)
    
    @staticmethod
    def validate_connection_string(conn_str: str) -> bool:
        return conn_str.startswith("mysql://")
```

### 추상 클래스와 믹스인(Mixin) 패턴

```python
from abc import ABC, abstractmethod
from typing import List

# 추상 기본 클래스
class Serializable(ABC):
    @abstractmethod
    def serialize(self) -> dict:
        pass
    
    @classmethod
    @abstractmethod
    def deserialize(cls, data: dict) -> 'Serializable':
        pass

# 믹스인 클래스
class TimestampMixin:
    def __init__(self):
        from datetime import datetime
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def update_timestamp(self):
        from datetime import datetime
        self.updated_at = datetime.now()

# 구체적 클래스
class User(Serializable, TimestampMixin):
    def __init__(self, username: str, email: str):
        super().__init__()  # 믹스인 초기화
        self.username = username
        self.email = email
        self._id = None
    
    def serialize(self) -> dict:
        return {
            'id': self._id,
            'username': self.username,
            'email': self.email,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }
    
    @classmethod
    def deserialize(cls, data: dict) -> 'User':
        user = cls(data['username'], data['email'])
        user._id = data['id']
        return user

# 사용 예제
user = User("john_doe", "john@example.com")
print(user.serialize())
```

### ABC와 Protocol 비교

파이썬에는 인터페이스를 정의하는 두 가지 방식이 있습니다:

```python
# 1. ABC (상속 기반, 런타임 검사)
from abc import ABC, abstractmethod

class Drawable(ABC):
    @abstractmethod
    def draw(self) -> None:
        pass

class Circle(Drawable):
    def draw(self) -> None:
        print("원 그리기")

# 2. Protocol (구조적 타이핑, 정적 타입 검사)
from typing import Protocol

class DrawableProtocol(Protocol):
    def draw(self) -> None: ...

def render(drawable: DrawableProtocol) -> None:
    drawable.draw()

class Square:
    def draw(self) -> None:
        print("사각형 그리기")

# 둘 다 사용 가능
circle = Circle()
square = Square()

circle.draw()  # OK
render(square)  # OK (Protocol은 구조적 타이핑)
```

---

## 캡슐화 (Encapsulation)

캡슐화는 객체의 내부 상태와 구현 세부사항을 외부로부터 숨기고, 공개된 인터페이스를 통해서만 상호작용하도록 하는 객체지향 프로그래밍의 기본 원칙입니다.

### 접근 제어 관례

파이썬은 엄격한 접근 제어 메커니즘을 제공하지 않지만, 명명 규칙을 통해 의도를 전달합니다.

```python
class BankAccount:
    def __init__(self, account_number: str, initial_balance: float = 0):
        # 공개 속성 (외부에서 자유롭게 접근)
        self.account_number = account_number
        
        # 보호된 속성 (하위 클래스에서 접근 가능, 외부에서는 접근하지 말 것)
        self._balance = initial_balance
        
        # 비공개 속성 (네임 맹글링 적용, 클래스 내부에서만 접근)
        self.__transaction_history = []
    
    def deposit(self, amount: float) -> None:
        """입금 메서드"""
        if amount <= 0:
            raise ValueError("입금액은 0보다 커야 합니다")
        self._balance += amount
        self.__add_transaction(f"입금: +{amount}")
    
    def withdraw(self, amount: float) -> bool:
        """출금 메서드"""
        if amount <= 0:
            raise ValueError("출금액은 0보다 커야 합니다")
        if self._balance >= amount:
            self._balance -= amount
            self.__add_transaction(f"출금: -{amount}")
            return True
        return False
    
    def get_balance(self) -> float:
        """잔액 조회 메서드"""
        return self._balance
    
    def __add_transaction(self, description: str) -> None:
        """비공개 메서드: 거래 내역 추가"""
        from datetime import datetime
        self.__transaction_history.append({
            "timestamp": datetime.now(),
            "description": description,
            "balance": self._balance
        })
    
    def get_recent_transactions(self, count: int = 5) -> list:
        """최근 거래 내역 조회"""
        return self.__transaction_history[-count:] if self.__transaction_history else []

# 사용 예제
account = BankAccount("123-456-789", 1000)
account.deposit(500)
account.withdraw(200)

print(f"계좌번호: {account.account_number}")  # 공개 속성
print(f"잔액: {account.get_balance()}")        # 게터 메서드 사용

# 보호된 속성에 접근 (가능하지만 권장하지 않음)
print(f"내부 잔액: {account._balance}")

# 비공개 속성에 직접 접근 시도
# print(account.__transaction_history)  # AttributeError

# 네임 맹글링 우회 접근 (절대 권장하지 않음)
print(f"맹글링된 이름: {account._BankAccount__transaction_history}")
```

### 프로퍼티(Property)를 활용한 캡슐화

`@property` 데코레이터를 사용하면 메서드를 속성처럼 접근할 수 있게 하면서도 내부 로직을 캡슐화할 수 있습니다.

```python
class Temperature:
    def __init__(self, celsius: float = 0):
        self._celsius = celsius
    
    @property
    def celsius(self) -> float:
        """섭씨 온도 프로퍼티"""
        return self._celsius
    
    @celsius.setter
    def celsius(self, value: float) -> None:
        """섭씨 온도 설정자 (검증 포함)"""
        if value < -273.15:  # 절대영도
            raise ValueError("온도는 -273.15°C 이상이어야 합니다")
        self._celsius = value
    
    @property
    def fahrenheit(self) -> float:
        """화씨 온도 프로퍼티 (읽기 전용)"""
        return (self._celsius * 9/5) + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value: float) -> None:
        """화씨 온도 설정자"""
        self.celsius = (value - 32) * 5/9
    
    @property
    def kelvin(self) -> float:
        """켈빈 온도 프로퍼티 (읽기 전용)"""
        return self._celsius + 273.15
    
    @kelvin.setter  
    def kelvin(self, value: float) -> None:
        """켈빈 온도 설정자"""
        self.celsius = value - 273.15

# 사용 예제
temp = Temperature(25)
print(f"섭씨: {temp.celsius}°C")      # 25.0
print(f"화씨: {temp.fahrenheit}°F")    # 77.0
print(f"켈빈: {temp.kelvin}K")         # 298.15

# 프로퍼티 설정
temp.celsius = 30
print(f"변경된 화씨: {temp.fahrenheit}°F")  # 86.0

# 화씨로 설정
temp.fahrenheit = 100
print(f"변경된 섭씨: {temp.celsius}°C")     # 37.777...

# 잘못된 값 검증
try:
    temp.celsius = -300
except ValueError as e:
    print(f"오류: {e}")  # 온도는 -273.15°C 이상이어야 합니다
```

### 디스크립터(Descriptor)를 활용한 고급 캡슐화

디스크립터는 재사용 가능한 속성 접근 로직을 정의할 수 있는 강력한 메커니즘입니다.

```python
class ValidatedAttribute:
    """유효성 검사 디스크립터"""
    
    def __init__(self, min_value=None, max_value=None):
        self.min_value = min_value
        self.max_value = max_value
        self.data_name = None
    
    def __set_name__(self, owner, name):
        """속성 이름 자동 저장"""
        self.data_name = name
    
    def __get__(self, obj, objtype=None):
        """값 가져오기"""
        if obj is None:
            return self
        return obj.__dict__.get(self.data_name, None)
    
    def __set__(self, obj, value):
        """값 설정하기 (유효성 검사 포함)"""
        self._validate(value)
        obj.__dict__[self.data_name] = value
    
    def _validate(self, value):
        """유효성 검사"""
        if self.min_value is not None and value < self.min_value:
            raise ValueError(f"{self.data_name}은(는) {self.min_value} 이상이어야 합니다")
        if self.max_value is not None and value > self.max_value:
            raise ValueError(f"{self.data_name}은(는) {self.max_value} 이하이어야 합니다")

class Person:
    # 디스크립터를 사용한 속성 정의
    age = ValidatedAttribute(min_value=0, max_value=150)
    height = ValidatedAttribute(min_value=0, max_value=300)  # cm
    weight = ValidatedAttribute(min_value=0, max_value=500)  # kg
    
    def __init__(self, name, age, height, weight):
        self.name = name
        self.age = age  # 디스크립터의 __set__ 호출
        self.height = height
        self.weight = weight
    
    @property
    def bmi(self) -> float:
        """BMI 계산 (읽기 전용 프로퍼티)"""
        if self.height == 0:
            return 0
        return self.weight / ((self.height / 100) ** 2)
    
    def __str__(self) -> str:
        return f"{self.name}, {self.age}세, BMI: {self.bmi:.1f}"

# 사용 예제
try:
    person = Person("김철수", 25, 175, 70)
    print(person)  # 김철수, 25세, BMI: 22.9
    
    # 유효성 검사 동작 확인
    person.age = 160  # ValueError: age은(는) 150 이하이어야 합니다
except ValueError as e:
    print(f"오류: {e}")
```

### `__slots__`을 활용한 메모리 최적화

`__slots__`을 사용하면 인스턴스의 속성 저장 방식을 최적화하여 메모리 사용을 줄일 수 있습니다.

```python
class PointWithSlots:
    __slots__ = ('x', 'y', '__weakref__')  # __weakref__는 약한 참조 지원용
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def distance(self, other):
        return ((self.x - other.x) ** 2 + (self.y - other.y) ** 2) ** 0.5

class PointWithoutSlots:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def distance(self, other):
        return ((self.x - other.x) ** 2 + (self.y - other.y) ** 2) ** 0.5

# 메모리 사용량 비교
import sys

p1 = PointWithSlots(3, 4)
p2 = PointWithoutSlots(3, 4)

print(f"__slots__ 사용: {sys.getsizeof(p1) + sys.getsizeof(p1.__dict__ if hasattr(p1, '__dict__') else 0)} bytes")
print(f"__slots__ 미사용: {sys.getsizeof(p2) + sys.getsizeof(p2.__dict__)} bytes")

# __slots__ 제약사항
# p1.z = 5  # AttributeError: 'PointWithSlots' object has no attribute 'z'
p2.z = 5  # 동적 속성 추가 가능
```

---

## MRO (Method Resolution Order)

MRO는 다중 상속에서 메서드를 찾는 순서를 결정합니다. 파이썬은 C3 선형화 알고리즘을 사용하여 일관된 메서드 탐색 순서를 보장합니다.

### 기본 개념

```python
class A:
    def show(self):
        print("A")

class B(A):
    def show(self):
        print("B")

class C(A):
    def show(self):
        print("C")

class D(B, C):
    pass

# MRO 확인
print(D.__mro__)  # (<class '__main__.D'>, <class '__main__.B'>, 
                  #  <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)

# 메서드 호출
d = D()
d.show()  # B (B → C → A 순서로 탐색)
```

### C3 선형화 알고리즘 이해

C3 알고리즘은 다음 규칙을 따릅니다:
1. 자식 클래스는 부모 클래스보다 먼저 탐색됨
2. 부모 클래스는 왼쪽에서 오른쪽 순서로 탐색됨
3. 동일한 클래스는 MRO에 한 번만 나타남

```python
class O:
    pass

class A(O):
    pass

class B(O):
    pass

class C(O):
    pass

class D(A, B):
    pass

class E(B, C):
    pass

class F(D, E):
    pass

# MRO 계산
print("F의 MRO:", [cls.__name__ for cls in F.__mro__])
# F, D, A, E, B, C, O, object

# 수동 계산:
# L(F) = F + merge(L(D), L(E), [D, E])
# L(D) = D + merge(L(A), L(B), [A, B]) = D + merge([A, O], [B, O], [A, B])
#       = [D, A] + merge([O], [B, O], [B]) = [D, A, B] + merge([O], [O])
#       = [D, A, B, O]
# L(E) = E + merge(L(B), L(C), [B, C]) = E + merge([B, O], [C, O], [B, C])
#       = [E, B] + merge([O], [C, O], [C]) = [E, B, C] + merge([O], [O])
#       = [E, B, C, O]
# L(F) = F + merge([D, A, B, O], [E, B, C, O], [D, E])
#       = [F, D] + merge([A, B, O], [E, B, C, O], [E])
#       = [F, D, A] + merge([B, O], [E, B, C, O], [E])
#       = [F, D, A, E] + merge([B, O], [B, C, O])
#       = [F, D, A, E, B] + merge([O], [C, O])
#       = [F, D, A, E, B, C] + merge([O], [O])
#       = [F, D, A, E, B, C, O]
```

### 협력적 `super()` 호출

다중 상속에서 올바른 메서드 체인을 유지하려면 협력적인 `super()` 호출이 필요합니다.

```python
class Base:
    def __init__(self):
        print("Base.__init__")
        super().__init__()  # 중요: 다음 클래스 호출을 위해

class Mixin1(Base):
    def __init__(self):
        print("Mixin1.__init__")
        super().__init__()

class Mixin2(Base):
    def __init__(self):
        print("Mixin2.__init__")
        super().__init__()

class MyClass(Mixin1, Mixin2):
    def __init__(self):
        print("MyClass.__init__")
        super().__init__()

# 인스턴스 생성
obj = MyClass()
# 출력:
# MyClass.__init__
# Mixin1.__init__
# Mixin2.__init__
# Base.__init__

# MRO 확인
print([cls.__name__ for cls in MyClass.__mro__])
# ['MyClass', 'Mixin1', 'Mixin2', 'Base', 'object']
```

### 실전 예제: 다중 상속을 활용한 플러그인 시스템

```python
class PluginBase:
    """플러그인 기본 클래스"""
    
    def __init__(self, name):
        self.name = name
        super().__init__()
    
    def execute(self):
        print(f"{self.name}: 기본 실행")

class LoggingMixin:
    """로깅 기능 믹스인"""
    
    def __init__(self):
        self.logs = []
        super().__init__()
    
    def log(self, message):
        self.logs.append(message)
        print(f"[LOG] {message}")
    
    def get_logs(self):
        return self.logs

class ValidationMixin:
    """유효성 검사 믹스인"""
    
    def validate(self, data):
        print(f"데이터 검증: {data}")
        return True
    
    def execute(self):
        if self.validate("테스트 데이터"):
            super().execute()  # 다음 클래스의 execute 호출

class EmailPlugin(PluginBase, LoggingMixin, ValidationMixin):
    """이메일 전송 플러그인"""
    
    def __init__(self):
        super().__init__("EmailPlugin")
    
    def execute(self):
        self.log("이메일 플러그인 실행 시작")
        super().execute()  # ValidationMixin.execute() 호출
        self.log("이메일 전송 완료")
        print(f"총 로그 수: {len(self.get_logs())}")

# 플러그인 사용
plugin = EmailPlugin()
plugin.execute()

# MRO 확인
print("\nEmailPlugin MRO:")
for cls in EmailPlugin.__mro__:
    print(f"  {cls.__name__}")
```

---

## 종합 예제: 온라인 쇼핑몰 시스템

이제까지 배운 개념들을 종합하여 간단한 온라인 쇼핑몰 시스템을 구현해 보겠습니다.

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import List, Dict, Optional
from datetime import datetime
from decimal import Decimal

# --- 값 객체들 ----------------------------------------------------------------

@dataclass(frozen=True)
class Money:
    """불변 금액 값 객체"""
    amount: Decimal
    currency: str = "KRW"
    
    def __post_init__(self):
        if self.amount < Decimal('0'):
            raise ValueError("금액은 0 이상이어야 합니다")
        object.__setattr__(self, 'currency', self.currency.upper())
    
    def __add__(self, other: 'Money') -> 'Money':
        if self.currency != other.currency:
            raise ValueError("통화가 일치하지 않습니다")
        return Money(self.amount + other.amount, self.currency)
    
    def __mul__(self, quantity: int) -> 'Money':
        return Money(self.amount * quantity, self.currency)
    
    def __str__(self) -> str:
        return f"{self.amount:,.0f} {self.currency}"

@dataclass(frozen=True)
class Address:
    """불변 주소 값 객체"""
    street: str
    city: str
    postal_code: str
    
    def __post_init__(self):
        if not self.postal_code.isdigit():
            raise ValueError("우편번호는 숫자만 포함해야 합니다")

# --- 추상 클래스 ---------------------------------------------------------------

class PaymentMethod(ABC):
    """결제 수단 추상 클래스"""
    
    @abstractmethod
    def process_payment(self, amount: Money) -> bool:
        """결제 처리"""
        pass
    
    @property
    @abstractmethod
    def name(self) -> str:
        """결제 수단 이름"""
        pass

class NotificationService(ABC):
    """알림 서비스 추상 클래스"""
    
    @abstractmethod
    def send(self, recipient: str, message: str) -> bool:
        """알림 전송"""
        pass

# --- 구체적 구현 클래스 --------------------------------------------------------

class CreditCardPayment(PaymentMethod):
    """신용카드 결제"""
    
    def __init__(self, card_number: str, card_holder: str):
        self._card_number = card_number
        self._card_holder = card_holder
    
    def process_payment(self, amount: Money) -> bool:
        print(f"[신용카드] {self._card_holder}님의 카드로 {amount} 결제 처리")
        # 실제 결제 처리 로직 (실제 구현에서는 API 호출 등)
        return True
    
    @property
    def name(self) -> str:
        return "신용카드"

class KakaoPayPayment(PaymentMethod):
    """카카오페이 결제"""
    
    def __init__(self, phone_number: str):
        self._phone_number = phone_number
    
    def process_payment(self, amount: Money) -> bool:
        print(f"[카카오페이] {self._phone_number}으로 {amount} 결제 요청")
        return True
    
    @property
    def name(self) -> str:
        return "카카오페이"

class EmailNotification(NotificationService):
    """이메일 알림 서비스"""
    
    def send(self, recipient: str, message: str) -> bool:
        print(f"[이메일] {recipient}에게 전송: {message}")
        return True

class SMSNotification(NotificationService):
    """SMS 알림 서비스"""
    
    def send(self, recipient: str, message: str) -> bool:
        print(f"[SMS] {recipient}에게 전송: {message}")
        return True

# --- 주문 시스템 ----------------------------------------------------------------

class Product:
    """상품 클래스"""
    
    def __init__(self, id: str, name: str, price: Money, stock: int):
        self.id = id
        self.name = name
        self._price = price  # 캡슐화
        self._stock = stock
    
    @property
    def price(self) -> Money:
        """가격 프로퍼티 (읽기 전용)"""
        return self._price
    
    @property
    def stock(self) -> int:
        """재고 프로퍼티"""
        return self._stock
    
    @stock.setter
    def stock(self, value: int):
        """재고 설정자 (검증 포함)"""
        if value < 0:
            raise ValueError("재고는 0 이상이어야 합니다")
        self._stock = value
    
    def reduce_stock(self, quantity: int) -> None:
        """재고 감소"""
        if quantity > self.stock:
            raise ValueError(f"재고 부족: 현재 {self.stock}개, 요청 {quantity}개")
        self.stock -= quantity
    
    def __str__(self) -> str:
        return f"{self.name} - {self.price} (재고: {self.stock}개)"

@dataclass
class OrderItem:
    """주문 항목 데이터 클래스"""
    product: Product
    quantity: int
    
    @property
    def subtotal(self) -> Money:
        """항목별 합계"""
        return self.product.price * self.quantity

class Order:
    """주문 클래스"""
    
    def __init__(self, order_id: str, customer_email: str, 
                 shipping_address: Address):
        self.order_id = order_id
        self.customer_email = customer_email
        self.shipping_address = shipping_address
        self._items: List[OrderItem] = []  # 캡슐화
        self._