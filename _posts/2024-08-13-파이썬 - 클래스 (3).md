---
layout: post
title: 파이썬 - 클래스 (3)
date: 2024-08-13 19:20:23 +0900
category: Python
---
# 파이썬 클래스 3 – 데이터 클래스, 추상 클래스, 캡슐화, MRO

## 1. 데이터 클래스 (`dataclass`)

파이썬 3.7+에서 제공되는 **데이터 중심 클래스** 자동 생성기입니다.
반복 구현이 지루했던 `__init__`, `__repr__`, `__eq__` 등을 자동으로 만들어 줍니다.

### 1.1 기본 사용

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int

p1 = Person("Alice", 25)
p2 = Person("Alice", 25)

print(p1)       # Person(name='Alice', age=25)
print(p1 == p2) # True
```

### 1.2 주요 옵션 총정리

| 옵션 | 기본 | 설명 | 실전 팁 |
|---|---:|---|---|
| `init` | `True` | `__init__` 자동 생성 | 커스텀 초기화는 `__post_init__`에서 |
| `repr` | `True` | `__repr__` 자동 생성 | 디버깅 용이 |
| `eq` | `True` | `__eq__` 자동 생성 | 값 기반 비교 |
| `order` | `False` | 순서 비교(`__lt__` 등) 자동 | 정렬 기준이 “필드 순서”가 되므로 주의 |
| `frozen` | `False` | 불변(재할당 금지) | 도메인 모델/해시키에 유용 |
| `slots` | `False` | `__slots__` 생성(메모리↓, 속도↑) | 3.10+ 권장 |
| `unsafe_hash` | `False` | 해시 강제 생성 | 가변 필드일 땐 비추 |
| `kw_only` | `False` | 키워드 전용 필드 | 3.10+ 안전한 API |

### 1.3 `field()`로 필드 제어

- 기본값/공장(`default_factory`)
- 비교/출력 포함 여부
- 메타데이터 보관

```python
from dataclasses import dataclass, field
from typing import List, Dict

@dataclass(slots=True, repr=True)
class Course:
    title: str
    tags: List[str] = field(default_factory=list)    # 리스트 기본값은 factory!
    scores: Dict[str, int] = field(default_factory=dict)
    secret: str = field(default="N/A", repr=False)   # __repr__에서 숨기기
```

> **주의**: 리스트·딕셔너리 같은 **가변 객체** 기본값은 `default_factory`를 써야 안전합니다.

### 1.4 `__post_init__`로 검증/정규화

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Money:
    amount: int
    currency: str = "KRW"

    def __post_init__(self):
        if self.amount < 0:
            # frozen이라도 __post_init__에서 예외로 무결성 보장
            raise ValueError("amount must be non-negative")
        object.__setattr__(self, "currency", self.currency.upper())
```

### 1.5 유틸 함수: `asdict`, `astuple`, `replace`

```python
from dataclasses import asdict, astuple, replace

p = Person("Ann", 30)
print(asdict(p))                # {'name': 'Ann', 'age': 30}
print(astuple(p))               # ('Ann', 30)
p2 = replace(p, age=31)         # 불변 스타일 업데이트
```

### 1.6 해시/불변 설계 규약

- `frozen=True`이면 해시 가능(필드도 불변이 이상적).
- 가변 필드를 해시 비교에 넣으면 **논리적 오류** 가능 → 해시 키로 쓰지 말 것.

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Key:
    a: int
    b: int

s = {Key(1,2), Key(1,2)}  # 중복 없이 1개만
```

### 1.7 상속 + 데이터클래스

- 부모/자식 모두 `@dataclass` 가능.
- 필드 순서/기본값 규칙에 주의(기본값 없는 필드가 먼저).

```python
from dataclasses import dataclass

@dataclass
class Base:
    id: int

@dataclass
class User(Base):
    name: str
    is_admin: bool = False

print(User(1, "Bob"))  # User(id=1, name='Bob', is_admin=False)
```

### 1.8 `dataclass` + 패턴 매칭 (3.10+)

```python
@dataclass
class Event:
    type: str
    payload: dict

def handle(ev: Event):
    match ev:
        case Event(type="login", payload={"user": user}):
            print("login:", user)
        case Event(type="error", payload={"code": c}):
            print("error:", c)
        case _:
            print("other", ev)
```

---

## 2. 추상 클래스 (Abstract Base Class, ABC)

**의도**: 인터페이스(계약)를 명시하고, **자식에게 구현을 강제**.

### 2.1 기본

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def sound(self) -> None:
        ...

class Dog(Animal):
    def sound(self) -> None:
        print("멍멍")

# Animal()      # TypeError: 추상 메서드 미구현
Dog().sound()    # 멍멍
```

### 2.2 추상 클래스의 다양한 추상 멤버

- `@abstractmethod` (인스턴스 메서드)
- `@abstractclassmethod`, `@abstractstaticmethod`, `@abstractproperty` 도 가능

```python
from abc import ABC, abstractmethod, abstractclassmethod

class Repo(ABC):
    @abstractclassmethod
    def from_url(cls, url: str) -> "Repo": ...

    @abstractmethod
    def get(self, key: str) -> str: ...

class MemoryRepo(Repo):
    @classmethod
    def from_url(cls, url: str) -> "MemoryRepo":
        return cls()

    def __init__(self):
        self._store = {}

    def get(self, key: str) -> str:
        return self._store.get(key, "")
```

### 2.3 ABC vs Protocol (참고)

- **ABC**: 상속 기반, **런타임 강제**.
- **Protocol**: 구조적 타이핑(덕 타이핑), **정적 타입체커**가 보장(런타임 강제 X).

> 본 문서는 ABC 중심. Protocol은 이전 심화 글에서 다뤘던 흐름과 동일.

---

## 3. 캡슐화 (Encapsulation)

**목적**: 내부 상태를 숨기고, **제어된 인터페이스**로만 접근/변경하도록 하여 **무결성/일관성**을 유지.

### 3.1 관례와 네임 맹글링

- `_name`: “내부용” **관례**(막히진 않음)
- `__name`: **네임 맹글링**(클래스명 섞여 `_Class__name`으로 내부명 변경)

```python
class Secret:
    def __init__(self):
        self._semi_private = "관례상 내부"
        self.__really_private = "맹글링 대상"

    def expose(self):
        return self.__really_private

s = Secret()
print(s._semi_private)          # 접근 가능하지만 하지 않는 걸로 약속
print(s.expose())               # OK
# print(s.__really_private)     # AttributeError
print(s._Secret__really_private)# 맹글링 우회(권장 X)
```

> **보안 기능은 아님**. “우발적 접근/이름 충돌” 방지 장치.

### 3.2 `property`로 게터/세터/검증

```python
class Account:
    def __init__(self, balance: int = 0):
        self._balance = balance

    @property
    def balance(self) -> int:
        return self._balance

    @balance.setter
    def balance(self, v: int) -> None:
        if v < 0:
            raise ValueError("balance >= 0")
        self._balance = v

a = Account()
a.balance = 10
print(a.balance)   # 10
# a.balance = -1   # ValueError
```

### 3.3 디스크립터(Descriptor)로 재사용 가능한 검증

```python
class NonNegative:
    def __set_name__(self, owner, name): self.name = name
    def __get__(self, obj, objtype=None):
        return obj.__dict__.get(self.name, 0)
    def __set__(self, obj, value):
        if value < 0: raise ValueError(f"{self.name} >= 0 required")
        obj.__dict__[self.name] = value

class Wallet:
    balance = NonNegative()
    def __init__(self, initial=0):
        self.balance = initial

w = Wallet(100)
w.balance = 20
# w.balance = -5  # ValueError
```

> **장점**: 여러 클래스에서 **동일 검증 로직**을 손쉽게 재사용.

### 3.4 “진짜” 불변을 원한다면: `frozen dataclass`

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class ImmutablePoint:
    x: int
    y: int

p = ImmutablePoint(1, 2)
# p.x = 3  # FrozenInstanceError
```

- 도메인 규칙이 강한 값 객체(Value Object)에 적합.
- 성능/메모리까지 고려하면 `slots=True`도 함께.

---

## 4. MRO (Method Resolution Order)

다중 상속에서 **메서드 탐색 순서**. 파이썬 2.3+는 **C3 선형화**를 사용합니다.

### 4.1 기본 확인

```python
class A:
    def hello(self): print("A")
class B(A):
    def hello(self): print("B")
class C(A):
    def hello(self): print("C")
class D(B, C):
    pass

d = D()
d.hello()            # B
print(D.__mro__)     # (D, B, C, A, object)
print(D.mro())       # 동일
```

- 탐색 순서: `D → B → C → A → object`

### 4.2 C3 선형화의 목표 (직관 요약)

- **로컬 우선순위**: 서브클래스의 부모 순서를 존중
- **모든 부모 포함**: 각 클래스를 **정확히 한 번** 포함
- **일관성**: 상속 그래프 전체의 순서를 모순 없이 만족

> 고전 DFS는 다이아몬드에서 부모를 **중복 방문**하거나 순서가 꼬일 수 있음. C3는 이를 방지.

### 4.3 협력적 `super()` (cooperative super)

모든 클래스가 **같은 시그니처**로 `super()`를 호출해야 다중상속 체인이 **깨지지 않고** 흐릅니다.

```python
class Base:
    def __init__(self, *a, **kw):
        print("Base")
        super().__init__(*a, **kw)

class M1(Base):
    def __init__(self, *a, **kw):
        print("M1")
        super().__init__(*a, **kw)

class M2(Base):
    def __init__(self, *a, **kw):
        print("M2")
        super().__init__(*a, **kw)

class X(M1, M2):
    def __init__(self, *a, **kw):
        print("X")
        super().__init__(*a, **kw)

X()
# X
# M1
# M2
# Base
```

> `super(Sub, self).meth()` 처럼 특정 부모를 **지정 호출**하면 **체인이 끊김** → 다중상속 설계에서 금기.

---

## 5. 종합 미니 프로젝트 — “주문 시스템” (dataclass + ABC + 캡슐화 + MRO)

### 5.1 요구사항

- 각 결제 수단은 공통 인터페이스(ABC)를 따른다.
- 불변 값 객체(`Money`)로 금액 표현.
- 캡슐화로 주문 상태를 제어(`property` / 검증).
- 믹스인과 다중상속, 협력적 `super()` 사용.

### 5.2 구현

```python
from __future__ import annotations
from dataclasses import dataclass, field, replace
from abc import ABC, abstractmethod
from typing import List

# --- 값 객체: 불변 Money -------------------------------------------------------
@dataclass(frozen=True, slots=True)
class Money:
    amount: int
    currency: str = "KRW"

    def __post_init__(self):
        if self.amount < 0:
            raise ValueError("amount >= 0")
        object.__setattr__(self, "currency", self.currency.upper())

    def __add__(self, other: "Money") -> "Money":
        if self.currency != other.currency:
            raise ValueError("currency mismatch")
        return Money(self.amount + other.amount, self.currency)

    def __mul__(self, k: int) -> "Money":
        return Money(self.amount * k, self.currency)

    def __str__(self) -> str:
        return f"{self.amount} {self.currency}"

# --- 추상 결제 수단 -------------------------------------------------------------
class Payment(ABC):
    @abstractmethod
    def pay(self, total: Money) -> None: ...

class CardPayment(Payment):
    def __init__(self, card_no: str):
        self._card_no = card_no

    def pay(self, total: Money) -> None:
        print(f"[CARD] {self._card_no[-4:]} charged {total}")

class PointPayment(Payment):
    def __init__(self, owner: str, points: int):
        self._owner = owner
        self._points = points

    def pay(self, total: Money) -> None:
        need = total.amount
        if self._points < need:
            raise ValueError("not enough points")
        self._points -= need
        print(f"[POINT] {self._owner} used {need}pt, remain={self._points}pt")

# --- 주문 항목 ------------------------------------------------------------------
@dataclass(slots=True)
class LineItem:
    sku: str
    price: Money
    qty: int

    @property
    def subtotal(self) -> Money:
        return self.price * self.qty

# --- 믹스인: 로깅 / 할인 규칙 ---------------------------------------------------
class LoggingMixin:
    def _log(self, msg: str) -> None:
        print(f"[LOG] {msg}")

class DiscountMixin:
    def _apply_discount(self, total: Money) -> Money:
        # 예시: 10000 이상 5% 할인
        if total.amount >= 10_000:
            return Money(int(total.amount * 0.95), total.currency)
        return total

# --- 주문 본체: 다중상속 + 협력적 super ---------------------------------------
class Order(LoggingMixin, DiscountMixin):
    def __init__(self, payment: Payment):
        self._items: List[LineItem] = []
        self._payment = payment
        super().__init__()  # 협력적 super (믹스인 체인 대비)

    def add(self, item: LineItem) -> None:
        self._items.append(item)
        self._log(f"add {item.sku} x{item.qty} = {item.subtotal}")

    @property
    def total(self) -> Money:
        if not self._items:
            return Money(0)
        cur = self._items[0].price.currency
        s = Money(0, cur)
        for it in self._items:
            if it.price.currency != cur:
                raise ValueError("mixed currency not allowed")
            s = s + it.subtotal
        s2 = self._apply_discount(s)
        return s2

    def pay(self) -> None:
        t = self.total
        self._log(f"pay total={t}")
        self._payment.pay(t)

# --- 사용 예 --------------------------------------------------------------------
if __name__ == "__main__":
    card = CardPayment("1234-5678-9999-0000")
    order = Order(card)
    order.add(LineItem("BOOK-1", Money(8000), 1))
    order.add(LineItem("CABLE-1", Money(3000), 1))
    print("TOTAL:", order.total)  # 11000 → 5% 할인 → 10450
    order.pay()

    points = PointPayment("alice", 20000)
    order2 = Order(points)
    order2.add(LineItem("USB", Money(15000), 1))
    order2.pay()
```

**포인트**

- `Money`는 **불변 값 객체**: 통화/금액 무결성 유지.
- `Payment`는 **ABC**: 결제 수단을 쉽게 확장.
- `Order`는 **믹스인**(로깅/할인) + 협력적 `super()` 패턴.
- `property`로 조회 전용 인터페이스, 내부 상태는 `_items`로 캡슐화.

---

## 6. 체크리스트 & 베스트 프랙티스

1. **데이터클래스**
   - 가변 기본값 → `default_factory`
   - 검증/정규화 → `__post_init__`
   - 해시/불변 → `frozen=True` + 가급적 불변 필드
   - 대량 인스턴스 → `slots=True`

2. **ABC**
   - “반드시 구현해야 함”을 명시해 **런타임 강제**
   - 클래스/정적/프로퍼티 추상 멤버도 제공 가능

3. **캡슐화**
   - 네임 맹글링은 **우발적 접근 방지**용
   - **비즈니스 규칙**은 `property`/디스크립터로 강제
   - 도메인 값은 **불변 설계**를 우선 고려

4. **MRO/다중상속**
   - **협력적 `super()`**: 동일 시그니처로 호출
   - 부모 직접 지정 호출은 체인 붕괴 위험
   - 믹스인은 **얇고 독립적**으로(상태 의존 최소화)

---

## 7. 빠른 레퍼런스

- `dataclasses.dataclass(init=True, repr=True, eq=True, order=False, frozen=False, slots=False, unsafe_hash=False, kw_only=False)`
- `dataclasses.field(default=..., default_factory=..., repr=True/False, compare=True/False, metadata={...})`
- `dataclasses.asdict/astuple/replace/is_dataclass`
- `abc.ABC / @abstractmethod / @abstractclassmethod / @abstractstaticmethod / @abstractproperty`
- 캡슐화: `_name`(관례), `__name`(맹글링), `@property`, **디스크립터**(`__get__/__set__/__delete__`)
- MRO: `.__mro__`, `.mro()`, **C3 선형화**, 협력적 `super()`

---

## 8. 마무리

- `dataclass`로 **값 중심 모델**을 간결하고 안전하게.
- ABC로 **인터페이스를 선언**하고 팀 합의를 코드로 **강제**.
- 캡슐화는 “문서상의 약속”이 아니라 **코드 레벨 제약**(property/descriptor/frozen)로.
- MRO와 협력적 `super()`를 이해하면 다중상속/믹스인을 **두려움 없이** 사용할 수 있습니다.
