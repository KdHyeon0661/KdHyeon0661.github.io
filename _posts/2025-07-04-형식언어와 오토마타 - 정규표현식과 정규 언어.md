---
layout: post
title: 형식언어와 오토마타 - 정규표현식과 정규 언어
date: 2025-07-04 19:20:23 +0900
category: 형식언어와 오토마타
---
# 정규표현식과 정규 언어

> 목표
> - **정규표현식(Regex)**의 수학적 정의와 **정규 언어**의 관계를 엄밀하게 설명
> - 정규표현식 ↔ (ε-)NFA ↔ DFA ↔ 정규표현식 **상호 변환**을 실제로 구현할 수 있는 **파이썬 예제 코드** 제공
> - 실전에서 자주 쓰는 문법(+, ?, 괄호, |, *)의 **형식적 의미**, **연산자 우선순위**, **정규식 엔진 주의점(백트래킹/비정규 확장)**까지 정리

---

## 빠른 개요

- **정규표현식(Regular Expression)**: 유한 알파벳 \(\Sigma\) 위 문자열 집합(언어)을 기술하는 **형식**.
- **정규 언어(Regular Language)**: 어떤 정규표현식으로 기술 가능한 언어들의 집합.
- **Kleene 정리**:
  $$\text{정규표현식} \;\Longleftrightarrow\; \varepsilon\text{-NFA} \;\Longleftrightarrow\; \text{NFA} \;\Longleftrightarrow\; \text{DFA}$$
  이 네 표현은 **표현력이 동등**하다.

---

## 정규표현식: 형식적 정의와 의미론

### 기본 원자(Atoms)

- $$\emptyset$$: 공집합(어떤 문자열도 포함 안 함)
- $$\varepsilon$$: 빈 문자열만 포함하는 언어(집합) \(\{\varepsilon\}\)
- $$a \in \Sigma$$: 단일 심볼 \(a\)로 이루어진 언어 \(\{a\}\)

### 연산자(Operators)

- **합(Union)**: \(R_1 \;|\; R_2\) 또는 \(R_1 + R_2\)
  $$L(R_1 | R_2) \;=\; L(R_1) \cup L(R_2)$$
- **연접(Concatenation)**: \(R_1 R_2\) (사이에 기호가 없어도 **암묵적 연접**)
  $$L(R_1 R_2) \;=\; \{ xy \mid x \in L(R_1),\; y \in L(R_2) \}$$
- **Kleene-별(Closure)**: \(R^\*\)
  $$L(R^\*) \;=\; \bigcup_{k\ge 0} L(R)^k \quad(\text{여기서 }L(R)^0=\{\varepsilon\})$$

> 편의 확장(정규적 의미를 보존)
> - **플러스**: \(R^+ = R R^\*\) (1회 이상)
> - **옵션**: \(R? = R \;|\; \varepsilon\)

### 연산자 **우선순위 & 결합성**

- 우선순위(높음→낮음): **\*** > **연접** > **\|**
- 결합성: \((R^\*)^\* = R^\*\), 연접은 좌결합으로 해석하는 파서가 일반적
- 괄호 **( … )** 로 명시적 그룹화

---

## 예로 보는 \(L(R)\)

| 정규식 \(R\) | 언어 \(L(R)\) (설명) |
|---|---|
| \(a\) | \(\{a\}\) |
| \(a \mid b\) | \(\{a,b\}\) |
| \(ab\) | \(\{ab\}\) |
| \(a^\*\) | \(\{\varepsilon, a, aa, aaa,\dots\}\) |
| \((a \mid b)^\*\) | \(\Sigma=\{a,b\}\) 위 **모든 문자열** |
| \(a^\*b\) | **0개 이상 a 뒤에 b로 끝나는** 문자열 |
| \((ab)^\*\) | “ab”가 반복되는 문자열 \(\{\varepsilon, ab, abab,\dots\}\) |
| \((1^\*01^\*01^\*)^\*\) | **0의 개수가 짝수**인 이진 문자열 전체 |

---

## 정규표현식과 오토마타: Kleene 정리

- **정리**:
  $$\forall R\; \exists A \;(\varepsilon\text{-NFA})\;:\; L(R)=L(A) \quad\land\quad \forall A\; \exists R:\; L(A)=L(R)$$
- 변환 실무 흐름
  1) **정규식 → ε-NFA**: Thompson 구성
  2) **ε-NFA → DFA**: ε-closure + subset construction
  3) **DFA → 정규식**: 상태 제거(state elimination)

---

## “현실 세계” RegEx 엔진과 이론의 차이

- **이론적 정규식**: **정규 언어**만 표현(백레퍼런스/부정형 전방탐색 등 없음)
- **실무 엔진(PCRE/Python/Java 등)**:
  - **백레퍼런스** `\1`, **복잡한 룩어라운드** 등 → **정규 언어를 넘어감(비정규)**
  - **백트래킹 기반**: **Catastrophic Backtracking** 주의 (예: `^(a+)+$`에 `a^n b` 입력)

> 본 글의 알고리즘/코드는 **순수 정규 언어 모델** 기준.

---

## 파이썬으로 구현하는 정규식 ↔ 오토마타

아래 코드는 **교육용 레퍼런스**로, 다음을 포함합니다.

1. **파서**: 중위 정규식을 AST로 (지원: `|`, 연접, `*`, `+`, `?`, 괄호)
2. **Thompson**: AST → ε-NFA
3. **ε-NFA → DFA**: ε-closure + 부분집합 구성
4. **DFA → 정규식**: 상태 제거 (기본형)
5. **테스트**: 대표 패턴들로 수용 여부 확인

> 실무 사용 시: 에러 검사/최소화(Hopcroft)/대형 입력 최적화 필요.

```python
from collections import defaultdict, deque
from dataclasses import dataclass
from typing import Dict, Set, Tuple, List, Optional, Union

Sym = str

# ---------------------------
# 정규식 AST
# ---------------------------

@dataclass(frozen=True)
class Epsilon: pass

@dataclass(frozen=True)
class Empty: pass

@dataclass(frozen=True)
class Symb:
    a: Sym  # 단일 심볼

@dataclass(frozen=True)
class Alt:  # R1 | R2
    left: 'Regex'
    right: 'Regex'

@dataclass(frozen=True)
class Concat:  # R1 R2
    left: 'Regex'
    right: 'Regex'

@dataclass(frozen=True)
class Star:  # R*
    inner: 'Regex'

@dataclass(frozen=True)
class Plus:  # R+
    inner: 'Regex'

@dataclass(frozen=True)
class Opt:   # R?
    inner: 'Regex'

Regex = Union[Epsilon, Empty, Symb, Alt, Concat, Star, Plus, Opt]

# ---------------------------
# 토큰화 & Shunting-yard 파서
#    지원: | (union), * + ? (단항), () , 암묵적 연접
#    우선순위: * + ? > concatenation > |
# ---------------------------

def tokenize(pattern: str) -> List[str]:
    # 심볼은 알파벳/숫자 하나로 가정(데모); 필요시 \-escape 처리 등 확장 가능
    tokens = []
    i = 0
    while i < len(pattern):
        c = pattern[i]
        if c in {'|', '(', ')', '*', '+', '?'}:
            tokens.append(c); i += 1
        elif c == 'ε':
            tokens.append('ε'); i += 1
        elif c == '∅':
            tokens.append('∅'); i += 1
        elif c.isspace():
            i += 1
        else:
            # 단일 심볼
            tokens.append(c); i += 1
    return tokens

def insert_concat_tokens(tokens: List[str]) -> List[str]:
    # 두 토큰 사이에 '·' (명시적 연접) 삽입
    out = []
    def is_atom(t):
        return t not in {'|', ')', '*', '+', '?'}
    for i, t in enumerate(tokens):
        out.append(t)
        if i+1 < len(tokens):
            t1, t2 = tokens[i], tokens[i+1]
            if ( (t1 == ')' or is_atom(t1) or t1 in {'*','+','?'} )
                 and (t2 == '(' or is_atom(t2)) ):
                out.append('·')  # concatenation
    return out

def parse(pattern: str) -> Regex:
    prec = {'*':3, '+':3, '?':3, '·':2, '|':1}
    right_assoc = set()   # 단항 연산은 오른결합 처리 필요 없음(스택에서 즉시 적용)
    toks = insert_concat_tokens(tokenize(pattern))
    # Shunting-yard
    output: List[Regex] = []
    ops: List[str] = []
    def apply_op(op):
        if op == '|':
            r = output.pop(); l = output.pop()
            output.append(Alt(l, r))
        elif op == '·':
            r = output.pop(); l = output.pop()
            output.append(Concat(l, r))
        elif op == '*':
            r = output.pop()
            output.append(Star(r))
        elif op == '+':
            r = output.pop()
            output.append(Plus(r))
        elif op == '?':
            r = output.pop()
            output.append(Opt(r))
        else:
            raise ValueError("Unknown op: "+op)

    for t in toks:
        if t == '(':
            ops.append(t)
        elif t == ')':
            while ops and ops[-1] != '(':
                apply_op(ops.pop())
            ops.pop()  # discard '('
        elif t in prec:
            while ops and ops[-1] in prec and (
                prec[ops[-1]] > prec[t] or
                (prec[ops[-1]] == prec[t] and t not in right_assoc)
            ):
                apply_op(ops.pop())
            ops.append(t)
        else:
            # atom: ε, ∅, symbol
            if t == 'ε':
                output.append(Epsilon())
            elif t == '∅':
                output.append(Empty())
            else:
                output.append(Symb(t))
    while ops:
        apply_op(ops.pop())
    assert len(output) == 1
    return output[0]

# ---------------------------
# Thompson: Regex -> ε-NFA
# ---------------------------

class ENFA:
    def __init__(self, start: int, finals: Set[int], trans: Dict[Tuple[int, Sym], Set[int]]):
        self.start = start
        self.finals = set(finals)
        self.trans = defaultdict(set)
        for k, vs in trans.items():
            self.trans[k] |= set(vs)
        self.eps = 'ε'

    def eclosure(self, states: Set[int]) -> Set[int]:
        stack = list(states)
        seen = set(states)
        while stack:
            q = stack.pop()
            for r in self.trans.get((q, self.eps), set()):
                if r not in seen:
                    seen.add(r); stack.append(r)
        return seen

    def step(self, S: Set[int], a: Sym) -> Set[int]:
        out = set()
        for q in S:
            out |= self.trans.get((q, a), set())
        return out

    def accepts(self, w: str) -> bool:
        S = self.eclosure({self.start})
        for ch in w:
            S = self.eclosure(self.step(S, ch))
            if not S: return False
        return len(S & self.finals) > 0

class ThompsonBuilder:
    def __init__(self):
        self._next = 0
        self.eps = 'ε'
    def _new(self) -> int:
        self._next += 1
        return self._next

    def build(self, R: Regex) -> ENFA:
        start, finals, trans = self._build(R)
        return ENFA(start, finals, trans)

    def _build(self, R: Regex):
        if isinstance(R, Epsilon):
            s = self._new(); f = self._new()
            T = defaultdict(set)
            T[(s, self.eps)].add(f)
            return s, {f}, T
        if isinstance(R, Empty):
            s = self._new(); f = self._new()
            # no path
            return s, set(), defaultdict(set)
        if isinstance(R, Symb):
            s = self._new(); f = self._new()
            T = defaultdict(set)
            T[(s, R.a)].add(f)
            return s, {f}, T
        if isinstance(R, Alt):
            s1, F1, T1 = self._build(R.left)
            s2, F2, T2 = self._build(R.right)
            s = self._new(); f = self._new()
            T = defaultdict(set, T1)
            for k,v in T2.items(): T[k] |= v
            T[(s, self.eps)].update({s1, s2})
            for x in F1: T[(x, self.eps)].add(f)
            for x in F2: T[(x, self.eps)].add(f)
            return s, {f}, T
        if isinstance(R, Concat):
            s1, F1, T1 = self._build(R.left)
            s2, F2, T2 = self._build(R.right)
            T = defaultdict(set, T1)
            for k,v in T2.items(): T[k] |= v
            for x in F1:
                T[(x, self.eps)].add(s2)
            return s1, F2, T
        if isinstance(R, Star):
            s1, F1, T1 = self._build(R.inner)
            s = self._new(); f = self._new()
            T = defaultdict(set, T1)
            # new start -> old start / new final
            T[(s, self.eps)].update({s1, f})
            # old finals -> old start / new final
            for x in F1:
                T[(x, self.eps)].update({s1, f})
            return s, {f}, T
        if isinstance(R, Plus):
            # R+ = R R*
            return self._build(Concat(R.inner, Star(R.inner)))
        if isinstance(R, Opt):
            # R? = R | ε
            return self._build(Alt(R.inner, Epsilon()))
        raise ValueError("Unknown regex node")

# ---------------------------
# ε-NFA -> DFA (subset construction)
# ---------------------------

class DFA:
    def __init__(self, start: int, finals: Set[int], trans: Dict[Tuple[int, Sym], int], sigma: Set[Sym]):
        self.start = start
        self.finals = set(finals)
        self.trans = dict(trans)
        self.sigma = set(sigma)

    def run(self, w: str) -> bool:
        q = self.start
        for ch in w:
            if (q, ch) not in self.trans:
                return False
            q = self.trans[(q, ch)]
        return q in self.finals

def enfa_to_dfa(A: ENFA, sigma: Set[Sym]) -> DFA:
    eps = A.eps
    start_set = frozenset(A.eclosure({A.start}))
    idx: Dict[frozenset, int] = {start_set: 0}
    rev: List[frozenset] = [start_set]
    finals: Set[int] = set()
    trans: Dict[Tuple[int, Sym], int] = {}
    dq = deque([start_set])

    def is_final(S: frozenset) -> bool:
        return any(s in A.finals for s in S)

    if is_final(start_set): finals.add(0)

    while dq:
        S = dq.popleft()
        sid = idx[S]
        for a in sigma:
            # move on 'a' and then ε-close
            nxt_raw = set()
            for q in S:
                nxt_raw |= A.trans.get((q, a), set())
            nxt = frozenset(A.eclosure(nxt_raw))
            if not nxt:
                continue
            if nxt not in idx:
                idx[nxt] = len(rev)
                rev.append(nxt)
                if is_final(nxt): finals.add(idx[nxt])
                dq.append(nxt)
            trans[(sid, a)] = idx[nxt]
    return DFA(0, finals, trans, set(sigma))

# ---------------------------
# DFA -> 정규표현식 (상태 제거)
#    R[i][j] = i->j 경로의 정규식 라벨
#    상태 k 제거 시: R[i][j] := R[i][j] | R[i][k](R[k][k])*R[k][j]
# ---------------------------

def re_union(r1: Optional[str], r2: Optional[str]) -> Optional[str]:
    if r1 is None: return r2
    if r2 is None: return r1
    if r1 == r2: return r1
    return f"({r1}|{r2})"

def re_concat(r1: Optional[str], r2: Optional[str]) -> Optional[str]:
    if r1 is None or r2 is None: return None
    # ε는 항등, ∅는 흡수
    if r1 == "∅" or r2 == "∅": return None
    if r1 == "ε": return r2
    if r2 == "ε": return r1
    return f"{r1}{r2}"

def re_star(r: Optional[str]) -> Optional[str]:
    if r is None: return "ε"  # 없음은 ε* = ε 로 취급
    if r == "ε": return "ε"
    return f"({r})*"

def dfa_to_regex(D: DFA) -> str:
    # 상태 재번호: 0..n-1, 0=start
    states = sorted({D.start} | {p for (p,_),_ in D.trans.items()} | {q for _,q in D.trans.items()})
    idmap = {s:i for i,s in enumerate(states)}
    n = len(states)
    start = idmap[D.start]
    finals = {idmap[f] for f in D.finals}

    # R[i][j] 초기화
    R: List[List[Optional[str]]] = [[None]*n for _ in range(n)]
    for (i,a), j in D.trans.items():
        ii, jj = idmap[i], idmap[j]
        lab = a
        R[ii][jj] = re_union(R[ii][jj], lab)
    # 자기루프 ε 없음

    # 시작/종료 집합을 다중 처리하기 위해 새 시작 s, 새 종료 f 추가
    # 간단 버전: 만약 finals 여러 개면 union으로 흡수
    # 여기서는 상태 제거를 직접 수행: 모든 k 제거(시작/종료는 남김)
    for k in range(n):
        # k 제거 규칙: i->j 보강
        loop = R[k][k]
        loop_star = re_star(loop)
        for i in range(n):
            if i == k: continue
            if R[i][k] is None: continue
            for j in range(n):
                if j == k: continue
                if R[k][j] is None: continue
                cand = re_concat(re_concat(R[i][k], loop_star), R[k][j])
                R[i][j] = re_union(R[i][j], cand)
        # k를 완전히 삭제(참조 제거)
        for i in range(n):
            R[i][k] = None
        for j in range(n):
            R[k][j] = None

    # start에서 finals로 가는 라벨 합집합
    regex: Optional[str] = None
    for f in finals:
        regex = re_union(regex, R[start][f])
    return regex or "∅"

# ---------------------------
# 데모 테스트
# ---------------------------

def demo():
    samples = [
        ("(a|b)*ab(a|b)*", ["", "ab", "baba", "aab", "ba", "bbaa"], [False, True, True, True, False, True]),
        ("(1*01*01*)*", ["", "0", "00", "010", "1010", "111"], [True, False, True, True, True, True]),  # 짝수 0
        ("(ab|ac)(a|b|c)*", ["ab", "ac", "aa", "ba", "acab"], [True, True, False, False, True]),
        ("(ab)*", ["", "ab", "aba", "abab"], [True, True, False, True]),
        ("a?b+", ["b", "ab", "a", "bb"], [True, True, False, True]),
    ]
    sigma_guess = lambda pat: set([c for c in pat if c.isalnum() and c not in {'ε'}])

    for pat, words, expect in samples:
        R = parse(pat)
        th = ThompsonBuilder().build(R)
        sigma = sigma_guess(pat)
        D = enfa_to_dfa(th, sigma)
        ok = [D.run(w) for w in words]
        print(f"[{pat}] -> DFA acceptance:", dict(zip(words, ok)), " / expected:", dict(zip(words, expect)))

    # DFA -> 정규식 역변환 샘플: 짝수 a (간단 DFA)
    # DFA: q0(start,final) --a--> q1 ; q1 --a--> q0  (Σ={a})
    start = 0
    finals = {0}
    trans = {(0,'a'):1, (1,'a'):0}
    D2 = DFA(start, finals, trans, {'a'})
    rx = dfa_to_regex(D2)
    print("DFA(even a) -> regex:", rx)

if __name__ == "__main__":
    demo()
```

### 코드 설명 요약

- `parse`: Shunting-yard로 **암묵적 연접**을 `·`로 삽입 후 AST 구성
- `ThompsonBuilder`: 각 연산(원자/합/연접/별/플러스/옵션)에 대한 **표준 NFA 조립**
- `ENFA.accepts`: ε-closure 기반 시뮬레이터
- `enfa_to_dfa`: 부분집합 구성(subset construction)
- `dfa_to_regex`: **상태 제거** 공식 \(R_{ij} \leftarrow R_{ij} \mid R_{ik} (R_{kk})^\* R_{kj}\) 반복 적용(간단 버전)

> 참고: 상태제거는 정규식이 길어질 수 있음(지수적 성장). 실무에서는 “사람이 읽기 쉬운” 정규식보다는 **DFA 그대로 사용 + 최소화**를 선호.

---

## 대표 패턴 설계 예제

### “문자열 어딘가에 `ab` 포함”

- 정규식:
  ```regex
  (a|b)*ab(a|b)*
  ```
- DFA 개념: `…a`를 기억하는 상태, 뒤가 `b`이면 수용으로

### “0의 개수가 짝수인 이진 문자열”

- 정규식(한 가지 표현):
  ```regex
  (1*01*01*)*
  ```
- DFA: 두 상태(짝/홀)로 **패리티** 관리

### “ab 또는 ac로 시작”

```regex
(ab|ac)(a|b|c)*
```

### “(ab)*”: `ab`가 0회 이상 반복

```regex
(ab)*
```

### “a?b+”: `b`가 1회 이상, 앞에 `a`는 있어도 되고 없어도 됨

```regex
a?b+
```

---

## 정규식 대수(간단 법칙) — 간소화 팁

- 항등/영: \(R \mid \emptyset = R\), \(R\emptyset=\emptyset\), \(\emptyset R=\emptyset\)
- 단위: \(R\varepsilon = R\), \(\varepsilon R = R\)
- 멱등/교환/결합: \(R|R=R\), \(R|S=S|R\), \(R|(S|T)=(R|S)|T\)
- 분배: \(R(S|T)=RS|RT\), \((S|T)R=SR|TR\)
- 별: \(R^\* = \varepsilon \mid R R^\*\), \((R^\*)^\* = R^\*\)

> 상태 제거로 얻은 정규식을 **사람이 읽기 좋게** 줄일 때 유용.

---

## 정규 언어가 **아닌** 예 (정규식으로 불가)

- $$\{ a^n b^n \mid n \ge 0 \}$$ — 균형 필요(스택 없음 → **문맥자유**)
- $$\{ ww \mid w \in \{a,b\}^\* \}$$ — “복제” 구조(유한상태로 불가)

**증명 스케치**: **펌핑 렘마** 또는 **Myhill–Nerode**로 비정규성을 보인다.

---

## 실무 엔진 사용 시 주의(요약)

- **백트래킹 폭발**: `(a|aa)*b` 같은 패턴은 긴 접두사에서 지수적 시도 →
  가능하면 **원자적 그룹/possessive quantifier/비백트래킹 엔진** 사용
- **비정규 확장**(백레퍼런스, 룩어라운드) 사용 시 **정규 언어**가 아닌 경우 존재 →
  오토마타 변환/증명과 **동일 선상 아님**

---

## 연습 문제(스스로 구현/검증)

1) 알파벳 \(\{0,1\}\)에서 **연속된 `11`을 포함하지 않는** 언어의 정규식/ε-NFA/DFA를 직접 구성하라.
2) \(\Sigma=\{a,b\}\). **`a`로 시작해서 `b`로 끝나는** 문자열 언어의 DFA를 만들고, 상태 제거로 정규식을 추출하라.
3) **부분문자열 `aba`가 등장**하지 않는 언어를 위한 DFA를 설계하라(3-상태 실패자동자 패턴).

---

## 마무리 정리

| 항목 | 핵심 |
|---|---|
| 정규표현식 | 합/연접/별로 언어를 생성하는 형식 |
| 정규 언어 | 정규표현식으로 기술 가능한 언어 |
| 동치성 | 정규식 ↔ ε-NFA ↔ NFA ↔ DFA (Kleene) |
| 변환 | Thompson, ε-closure+subset, 상태제거 |
| 한계 | 균형/복제/중첩 심층 구조는 불가(비정규) |

> **핵심 메시지**: 정규표현식은 “**유한상태**”로 모델링 가능한 모든 것을 정확히 담는다.
> 오토마타 관점으로 바라보면, **설계·검증·최적화**가 훨씬 체계적이고 안전해진다.
