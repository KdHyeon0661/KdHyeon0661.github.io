---
layout: post
title: 네트워크보안 - 예제 PCAP/랩 시나리오
date: 2025-11-03 23:25:23 +0900
category: 네트워크보안
---
# C. 예제 PCAP/랩 시나리오 10선(난이도별)

> 목표
> - “**패킷(PCAP)** ↔ **로그(Zeek/Suricata/Proxy)** ↔ **지표(SIEM)**”를 **끝까지 연결**하는 10개의 시나리오로 실습한다.
> - 각 시나리오마다 **학습 포인트**, **재현 절차**, **캡처/분석 명령**, **탐지/완화 아이디어**, **확장 과제**를 포함한다.
> - 모든 실습은 **승인된 랩/테스트망(ROE 문서화)**에서만 수행한다. 실제 환경/외부 네트워크 대상 무단 테스트는 불법이다.

---

## 공통 랩 준비(요약 템플릿)

- **호스트**: `attacker`(테스트용), `client`, `server`(웹/파일/DB 중 하나), `dns`(캐시/권한 분리 가능)
- **도커 컴포즈(예시)**: `nginx`(443/HTTP2), `minio`(파일 업로드 확인), `bind9`(dns), `zeek`, `suricata`
- **네트워크**: 단일 브리지 `labnet`(172.20.0.0/24), MTU 1500
- **권장 툴**: `tcpdump`, `tshark`, `Wireshark`, `Zeek`, `Suricata`, `jq`, `python3`(Scapy)

공통 캡처 팁:
```bash
# (1) 5분씩 순환 캡처, 헤더+일부 페이로드(128B)만
sudo tcpdump -i eth0 -s 128 -G 300 -W 12 -w 'cap-%Y%m%d-%H%M%S.pcap' 'tcp or udp'

# (2) 필요 시 풀패킷(성능 주의)
sudo tcpdump -i eth0 -s 0 -w full.pcap

# (3) 라이브 확인
sudo tcpdump -i eth0 -nn -tt 'tcp port 443 or udp port 53'
```

분석 공통:
```bash
# Zeek
zeek -r cap-*.pcap
# Suricata(오프라인)
suricata -r cap-*.pcap -l ./suri_out
jq -r 'select(.event_type=="alert")|.alert.signature' ./suri_out/eve.json | sort | uniq -c | sort -nr
```

---

# 시나리오 1 (입문): 3-Way/4-Way + 재전송/손실 파악

**학습 포인트**
- TCP **핸드셰이크/종결**(3-way/4-way) 위주의 **정상 플로우** 관찰.
- **재전송**, **윈도우 제로**, **RST 종료** 패턴을 Wireshark/TCP 분석기로 이해.

**트래픽 생성(안전한 방법)**
```bash
# client→server 간 간단 HTTP 요청 100회
for i in {1..100}; do curl -s -o /dev/null http://server:8080/healthz; done
```
(의도적 손실을 보려면, 랩 인터페이스에 **임시 qdisc**로 1~3% 손실을 걸어 관찰)
```bash
sudo tc qdisc add dev eth0 root netem loss 2% delay 20ms
# 테스트 후 원복
sudo tc qdisc del dev eth0 root
```

**캡처/필터**
```bash
sudo tcpdump -i eth0 -s 0 -w s1.pcap 'tcp and (port 8080)'
```

**Wireshark Display Filter**
- 초기 SYN: `tcp.flags.syn == 1 && tcp.flags.ack == 0`
- 재전송: `tcp.analysis.retransmission || tcp.analysis.fast_retransmission`
- RST 종료: `tcp.flags.reset == 1`

**tshark 요약**
```bash
tshark -r s1.pcap -q -z io,stat,1,"COUNT(tcp.analysis.retransmission) tcp.retx"
tshark -r s1.pcap -q -z conv,tcp
```

**Zeek 로그 확인**
```bash
zeek -r s1.pcap
zeek-cut id.orig_h id.resp_h service missed_bytes orig_ip_bytes resp_ip_bytes < conn.log | head
```

**확장 과제**
- 지연/손실이 **서버 측** vs **클라이언트 측** 어느 구간에서 발생했는지 RTT/ACK 분석으로 설명.
- `Suricata`의 `flow` 이벤트와 대조하여 문제 구간 레이블링.

---

# 시나리오 2 (입문+): DNS 정상/이상(오타·NXDOMAIN) 비교

**학습 포인트**
- DNS `A/AAAA/CNAME/TXT` 요청·응답 흐름, **NXDOMAIN**(오타, 타이포스쿼팅) 패턴.
- 재귀 DNS 캐시 히트/미스 시 **지연 차이** 관찰.

**생성**
```bash
# 정상 도메인과 오타 도메인 혼합 질의
dig +short example.com @dns
dig +short examp1e.com @dns   # 'l'→'1'
for i in {1..20}; do dig +short www.google.com @dns > /dev/null; done
```

**캡처/필터**
```bash
sudo tcpdump -i eth0 -s 0 -w s2.pcap 'udp port 53 or tcp port 53'
```

**Wireshark 필터**
- 쿼리만: `dns.flags.response == 0`
- 응답 코드: `dns.flags.rcode != 0` (NXDOMAIN 등)

**tshark 통계**
```bash
tshark -r s2.pcap -Y "dns" -T fields -e frame.time_epoch -e ip.src -e dns.qry.name -e dns.flags.rcode | head
```

**Zeek**
```bash
zeek -r s2.pcap
zeek-cut query rcode answers < dns.log | sort | uniq -c
```

**탐지 아이디어**
- **RCODE 비율**(NXDOMAIN 급증), **의심 서브도메인 길이**, **요청 폭주** 룰.
- Suricata `dns` 이벤트로 RCODE 카운팅.

---

# 시나리오 3 (초급): TLS 핸드셰이크 · SNI · JA3 요약

**학습 포인트**
- TLS 1.2/1.3 **ClientHello/ServerHello**, **SNI**, **JA3/JA3S** 개념.
- 사이트별 **SNI 상위 목록**과 **서드파티 호출** 파악.

**생성**
```bash
# 클라이언트가 HTTPS 사이트를 다양하게 조회
for h in example.com www.cloudflare.com wikipedia.org; do
  curl -s -o /dev/null https://"${h}";
done
```

**캡처**
```bash
sudo tcpdump -i eth0 -s 256 tcp port 443 -w s3.pcap
```

**tshark: SNI 추출**
```bash
tshark -r s3.pcap -Y "tls.handshake.extensions_server_name" \
  -T fields -e ip.src -e ip.dst -e ssl.handshake.extensions_server_name | sort -u
```

**Zeek**
```bash
zeek -r s3.pcap
cut -f9 ssl.log | sort | uniq -c | sort -nr   # ja3
zeek-cut server_name version cipher < ssl.log | head
```

**탐지/정책**
- 조직 정책에 **허용되지 않은 SNI 카테고리** 탐지(프록시 카테고리/Suricata tls.sni).
- TLS 1.0/1.1 잔존 여부(다운그레이드 이슈) 점검.

---

# 시나리오 4 (초중급): ARP 스푸핑 · L2 MITM 징후 & 탐지

> ⚠️ **동일 브리지 내 랩 환경**에서만, **소유 장비**를 대상으로 수행. 실제 환경 금지.

**학습 포인트**
- **ARP 포이즈닝**이 발생할 때 발생하는 **ARP Reply 폭증**, **게이트웨이 MAC 변경** 감지.
- 방어개념: **DAI/DHCP Snooping/Port Security**.

**Scapy(교육용, 소량·단시간) — 게이트웨이로 위장한 ARP Reply**
```python
# s4_arp_poison.py (랩/테스트망 전용)
from scapy.all import *
gw_ip="172.20.0.1"; client_ip="172.20.0.10"
attacker_mac=get_if_hwaddr(conf.iface)
pkt1=ARP(op=2, psrc=gw_ip, pdst=client_ip, hwdst="ff:ff:ff:ff:ff:ff", hwsrc=attacker_mac)
for _ in range(10):
    send(pkt1, inter=0.5, verbose=False)
```

**캡처**
```bash
sudo tcpdump -i eth0 -s 0 -w s4.pcap 'arp or (tcp and port 80)'
```

**Wireshark 색인**
- ARP Reply 폭증: `arp.opcode == 2`
- 동일 IP(게이트웨이)의 **상이한 MAC**: ARP 테이블 변화 관찰.

**Suricata 규칙(교육용 알림)**
```suricata
alert arp any any -> any any (msg:"ARP: Possible spoof"; arp_op: reply; threshold:type both, track by_src, count 5, seconds 10; sid:4000001; rev:1;)
```

**방어 실습(스위치가 있다면)**
- DAI/DHCP Snooping 활성화 후 동일 테스트 → 드롭/로그 확인.

---

# 시나리오 5 (초중급): 평문 HTTP 자격증명 노출 vs HTTPS 보호

**학습 포인트**
- **HTTP Basic/Form** 자격 노출 PCAP에서의 **페이로드 관찰**.
- HTTPS 사용 시 **같은 행위가 보이지 않음** 비교.

**테스트 서버**: `nginx` 로컬 폼 엔드포인트
```nginx
# location /login (테스트 전용)
location = /login {
  if ($request_method = POST) { return 200 "ok"; }
  return 200 "login page";
}
```

**평문 HTTP 요청**
```bash
curl -v -d 'username=alice&password=test123!' http://server:8080/login
```

**캡처**
```bash
sudo tcpdump -i eth0 -s 0 -A -w s5_http.pcap 'tcp port 8080'
```

**Wireshark**
- `http.request.method == "POST"` → 페이로드 확인(테스트용이므로 OK).
- **동일 요청을 HTTPS**로 보내고 차이점 비교:
```bash
curl -k -d 'username=alice&password=test123!' https://server:8443/login
```

**메시지**
- 운영에선 **HTTPS/HSTS** 강제, **쿠키 Secure/HttpOnly/SameSite** 확인.

---

# 시나리오 6 (중급): L7 느린 요청/부분 DoS(슬로우 업로드) 탐지

**학습 포인트**
- **느린 업로드/다중 연결**로 자원 소모 유도 징후(완전한 공격 아님, 소규모 재현).
- 프록시/리버스에서 **업로드 크기/속도/동시 연결** 임계 감지.

**생성(조심스럽게, 소량·짧게)**
```bash
# 10MB 파일을 1KB씩 천천히 전송(테스트 서버로)
python3 - <<'PY'
import requests, time
def gen():
  chunk=b"a"*1024
  for _ in range(10240):  # 10MB
    yield chunk; time.sleep(0.01)  # 느리게
r=requests.put("http://server:9000/upload/slow.bin", data=gen())
print(r.status_code)
PY
```

**캡처/분석**
```bash
sudo tcpdump -i eth0 -s 128 -w s6.pcap 'tcp port 9000'
tshark -r s6.pcap -q -z io,stat,5,"AVG(frame.len) Len"
```

**Nginx/Haproxy에 임계 예시**
- **요청 바디 크기 제한**, **요청 읽기 타임아웃**, **동시 연결 rate-limit**.
- Suricata `http` 트랜잭션 시간/바이트 임계 탐지(통계 기반).

---

# 시나리오 7 (중급+): DNS 기반 데이터 은닉(튜닝용 탐지)

> ⚠️ 외부망 금지. 이 시나리오는 **악성 기법을 모사**하지만, 교육 목적의 **탐지·방어 튜닝**에 집중한다.
> 대역 외부 송신 없이 **로컬 `dns` 컨테이너**만 대상으로 한다.

**학습 포인트**
- 길고 무작위처럼 보이는 **서브도메인 TXT/A 질의** 패턴, **짧은 TTL**, **요청 폭주**.
- Zeek/Suricata에서 도메인 길이/엔트로피/요청 빈도 기반 **탐지 룰** 초안 만들기.

**무해한 생성 스크립트(로컬 DNS로만)**
```python
# s7_dns_embed.py
import base64, os, time, random, string, subprocess
data = os.urandom(2000)
enc = base64.urlsafe_b64encode(data).decode().strip("=")
chunks = [enc[i:i+40] for i in range(0, len(enc), 40)]
for c in chunks:
    sub = f"{c}.data.lab"
    subprocess.run(["dig","+short",sub,"TXT","@dns"], stdout=subprocess.DEVNULL)
    time.sleep(0.05 + random.random()*0.05)
```

**캡처**
```bash
sudo tcpdump -i eth0 -s 0 -w s7.pcap 'udp port 53'
```

**Zeek**
```bash
zeek -r s7.pcap
# dns.log: query 길이, qtype=TXT 비중, 동일 2차 도메인 반복 요청
zeek-cut query qtype_name answers < dns.log | awk '{print length($1), $0}' | sort -nr | head
```

**탐지 아이디어(의사 KQL)**
```text
index:dns-* qtype:TXT
| extend qlen=len(query)
| summarize cnt=count(), avg_qlen=avg(qlen) by src_ip, suffix(extract_domain(query), 2)
| where cnt > 50 or avg_qlen > 45
```

**완화**
- 내부 **도메인 허용 목록** 외 **외부로의 DNS**는 **재귀 DNS 경유**만 허용, 직접 외부 DNS 차단.
- **Response Policy Zone(RPZ)**로 의심 도메인 씽크홀.

---

# 시나리오 8 (중급+): “분활 업로드를 통한 데이터 반출” 탐지(프록시 관점)

**학습 포인트**
- 10MB 청크 × N회 **반복 PUT** 패턴의 **5분 합계/카운트 임계** 감지.
- 프록시/NGFW 레이어에서 **tput/건수 기반** 룰 설계.

**생성**
```bash
dd if=/dev/urandom of=/tmp/10m.bin bs=1M count=10
for i in {1..20}; do
  curl -s -T /tmp/10m.bin http://server:9000/upload/chunk-$i.bin -o /dev/null
done
```

**캡처**
```bash
sudo tcpdump -i eth0 -s 128 -w s8.pcap 'tcp port 9000 and (tcp[((tcp[12] & 0xf0) >> 2):4] != 0)'
```

**tshark 추출**
```bash
tshark -r s8.pcap -Y "http.request.method==PUT" -T fields -e ip.src -e http.request.uri -e http.file_data | wc -l
```

**탐지 룰(의사 KQL)**
```text
proxy | where method=="PUT" and bytes_out>5000000
| summarize total_out=sum(bytes_out), cnt=count() by user, src_ip, bin(5m)
| where total_out>200000000 or cnt>30
```

**완화**
- **업로드 임계**, **확장자/콘텐츠 검사(ICAP)**, **승인 워크플로우**.
- 클라우드 스토리지에 **VPC 엔드포인트 정책** + **S3 Object Lock**.

---

# 시나리오 9 (상급): 주기적 HTTPS 비콘(간헐·저대역) 행위 탐지

**학습 포인트**
- 일정 간격(예: 60±5s)로 짧은 HTTPS 요청 → **행위 기반** 탐지(간격/JA3/URI 패턴).
- 도메인 평판에 의존하지 않고 **행위+메타데이터**로 식별.

**생성(무해)**
```bash
# 60초 간격으로 짧은 요청 15회
python3 - <<'PY'
import time, requests, random
for i in range(15):
    requests.get("https://server:8443/ping", verify=False, timeout=5)
    time.sleep(55 + random.random()*10)
PY
```

**캡처**
```bash
sudo tcpdump -i eth0 -s 128 -w s9.pcap 'tcp port 8443'
```

**Zeek + 간격 추정**
```bash
zeek -r s9.pcap
# conn.log에서 동일 5-튜플의 ts 간격 계산(간단 파이프)
awk 'NR>1{print $1-prev;} {prev=$1}' <(zeek-cut ts id.orig_h id.resp_h id.resp_p proto < conn.log | grep '8443') | awk '{sum+=$1; n+=1} END{print "avg:",sum/n}'
```

**탐지 아이디어**
- 같은 SNI/JA3로 **규칙적 간격**의 소량 트래픽 → 알림.
- `Suricata` tls 이벤트 + `flow` 간격 기반 커스텀 후처리.

---

# 시나리오 10 (상급): 포트 스캔 + 인벤토리 및 방화벽 히트 대조

**학습 포인트**
- 승인 대역에 대한 **Masscan(속도↓)** → **Nmap 재확인** → **방화벽 히트**와의 상관.
- 오탐/미확인을 줄이는 **2단계 확인 프로세스**.

> ⚠️ 반드시 **허가된 내부 테스트 대역**만.

**Masscan (저속)**
```bash
sudo masscan 172.20.0.0/24 -p443 --rate 500 -oJ s10_masscan.json
jq -r '.[].ip' s10_masscan.json | sort -u > s10_ips.txt
```

**Nmap 재확인**
```bash
xargs -I{} nmap -sS -sV -p443 -oX nmap_{}.xml < s10_ips.txt
```

**방화벽 로그 대조(의사 KQL)**
- 5분 윈도우 내 `src=attacker`에서 443 SYN 다발 ↔ 방화벽 Drop/Allow 히트 비교.

```text
fw | where src_ip=="172.20.0.50" and dst_port==443
| summarize drop=sum(toint(action=="deny")), allow=sum(toint(action=="allow")) by dst_ip, bin(5m)
```

**보고**
- 인벤토리(열린 443) 리스트와 **방화벽 정책 상태**(허용/차단) 테이블 작성.
- **불필요 노출**이 있으면 **정책 개선안**(WAF 뒤 배치/프라이빗 링크 전환) 제시.

---

## 제출물 템플릿(시나리오별 동일 적용)

1. **개요**: 시나리오 목적/가정/범위.
2. **타임라인**: 트래픽 발생 시각/이벤트 순서.
3. **재현 절차**: 실행한 커맨드/스크립트(버전/환경 포함).
4. **증거**: PCAP 조각(Wireshark 스크린샷 설명), Zeek/Suricata 로그, 핵심 통계.
5. **분석**: 정상 vs 이상, 원인/영향/대응.
6. **탐지 룰**: KQL/Suricata/Zeek 정책 초안과 튜닝 포인트.
7. **완화**: 프록시/FW/K8s/엔드포인트에서의 정책/구성.
8. **회고**: 오탐 가능성, 개선 아이디어, 다음 실험(확장).

---

## 채점 루브릭(워크숍 운영 시)

| 항목 | 기준 | 배점 |
|---|---|---|
| 재현 정확성 | 절차/환경/명령 재현 가능 | 25 |
| 분석 깊이 | 타임라인/원인/증거 상호 일치 | 25 |
| 탐지 품질 | 룰/임계/대시보드 설계 | 20 |
| 완화 현실성 | 운영 반영 난이도/영향 분석 | 20 |
| 문서 품질 | 간결·일관 포맷, 스크린샷/표 | 10 |

---

## 마무리

- 10개 시나리오는 **기초(핸드셰이크/HTTP/DNS)** → **중급(ARP, 업로드 임계)** → **상급(비콘, 인벤토리+정책)**으로 **난이도 계단식** 구성이다.
- 각 시나리오를 **엔드투엔드**로: *패킷*을 캡처하고 *로그*로 구조화한 뒤, *탐지 룰*과 *운영 완화*로 연결해야 실무 역량이 빠르게 올라간다.
- 원하면 위 내용을 **Docker Compose 번들(nginx/minio/bind9/zeek/suricata + 노트북)**로 패키징해 줄 수 있다.
  또한 조직 환경(프록시/NGFW/K8s/클라우드)에 맞춰 **정책·대시보드 템플릿**까지 일괄 정리해 주겠다.
