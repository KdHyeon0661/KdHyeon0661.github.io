---
layout: post
title: Linux - 데몬과 백그라운드 실행 관리  
date: 2024-11-20 19:20:23 +0900
category: Linux
---
# 데몬(daemon)과 백그라운드 실행 관리

## 0) 큰 그림: 언제 무엇을 쓰나?

| 시나리오 | 권장 도구 | 한 줄 요약 |
|---|---|---|
| 간단히 “백그라운드로 돌리기” | `nohup … &`, `disown`, `setsid`, `tmux` | 단발성/개인 테스트 |
| 서버에 “정식 데몬”으로 배포 | **`systemd` .service** | 자동 시작/복구/로깅/리소스/보안 |
| 포트가 열릴 때만 실행 | **`systemd` .socket** | 소켓 활성화(지연 실행) |
| 크론보다 정교한 일정/의존성 | **`systemd` .timer** | `@reboot` 대체, 상태/로그 일원화 |
| 구형 SysVinit 환경 | `/etc/init.d/*`, `service` | 이행기 또는 레거시 |
| 외부 툴 선호 | `supervisord` | 단일 프로세스 감시/자동 재시작 |
| 프로그램이 스스로 데몬화 | `fork/setsid` | 고전 방식(요즘은 systemd 권장) |

---

## 1) 가장 빠른 방법: `nohup`, `&`, `disown`, `setsid`

### 1.1 기본 패턴
```bash
nohup ./myapp --port 8080 > myapp.out 2>&1 &
disown
```
- `nohup`: SIGHUP 무시 → 터미널 끊겨도 종료되지 않음  
- `&`: 백그라운드  
- `disown`: 셸의 job 목록에서 분리(로그아웃 영향 제거)

### 1.2 대체: `setsid` (새 세션에서 실행)
```bash
setsid ./myapp >myapp.out 2>&1 < /dev/null &
```

### 1.3 확인/정리
```bash
ps aux | grep myapp
tail -f myapp.out
kill -TERM <PID>
```

> 장점: 간편.  
> 단점: **자동 재시작·로깅·리소스/보안 제어 없음** → 운영 서비스에는 권장 X.

---

## 2) 세션 분리 터미널: `tmux` / `screen`

### 2.1 `tmux` 빠른 사용
```bash
tmux new -s app
# 내부에서
./myapp
# 분리
Ctrl+b d
# 재접속
tmux attach -t app
```

### 2.2 세션 자동 시작 스크립트
```bash
#!/usr/bin/env bash
tmux has-session -t app 2>/dev/null || tmux new -d -s app "cd /opt/app && ./myapp"
```

> 장점: SSH 끊겨도 안 죽음, 다중 창/로그 보기 편함.  
> 단점: **서비스 관리/복구는 수동** → 결국 systemd로 가자.

---

## 3) 표준: **systemd 서비스**로 등록

### 3.1 최소 예제: `/etc/systemd/system/myapp.service`
```ini
[Unit]
Description=MyApp HTTP Service
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
WorkingDirectory=/opt/myapp
ExecStart=/opt/myapp/myapp --port=8080
Restart=on-failure
RestartSec=3
# 로깅은 journald로 일원화
# 환경
Environment=APP_ENV=prod LOG_LEVEL=info
# 또는 외부 파일
# EnvironmentFile=/etc/myapp/myapp.env

[Install]
WantedBy=multi-user.target
```

### 3.2 배포·관리
```bash
sudo systemctl daemon-reload
sudo systemctl enable --now myapp
sudo systemctl status myapp -l
journalctl -u myapp -f
```

### 3.3 재시작/제한/오류 감지
```bash
sudo systemctl restart myapp
sudo systemctl show myapp | grep -E 'Restart|State|MainPID'
```

---

## 4) 운영형 유닛: **리소스·보안·라이프사이클** 확장

### 4.1 재시작 정책/연속 실패 제한
```ini
[Service]
Restart=always            # always/on-failure/on-abnormal/on-watchdog
RestartSec=2s

StartLimitIntervalSec=30s
StartLimitBurst=10        # 30초 동안 10번 실패하면 Inactive
```

### 4.2 종료 신호/그레이스풀 셧다운
```ini
[Service]
KillSignal=SIGTERM
TimeoutStopSec=20s
KillMode=mixed            # 컨테이너형 트리까지 정리
```

### 4.3 파일/디렉토리 준비(권한/소유자 자동)
```ini
[Service]
WorkingDirectory=/opt/myapp
RuntimeDirectory=myapp
RuntimeDirectoryMode=0750
StateDirectory=myapp
StateDirectoryMode=0750
CacheDirectory=myapp
LogsDirectory=myapp
User=myapp
Group=myapp
```

### 4.4 cgroups 기반 리소스 제어
```ini
[Service]
# 파일 핸들/프로세스 제한
LimitNOFILE=65535
LimitNPROC=4096

# CPU/메모리/IO(커널별 가용)
CPUQuota=200%             # 최대 2코어 상당
CPUWeight=80              # 1~10000
MemoryMax=2G
IOReadBandwidthMax=/dev/nvme0n1 200M
IOWriteBandwidthMax=/dev/nvme0n1 100M
```

### 4.5 보안 하드닝(샌드박스)
```ini
[Service]
NoNewPrivileges=true
PrivateTmp=true                 # /tmp 분리
ProtectSystem=strict            # /usr /boot /etc read-only
ProtectHome=true                # /home /root /run/user 보호
ProtectControlGroups=true
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectKernelLogs=true
RestrictSUIDSGID=true
RestrictRealtime=true
LockPersonality=true
PrivateDevices=true
CapabilityBoundingSet=CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_BIND_SERVICE
DynamicUser=true                # 시스템 계정 자동 발급
IPAddressDeny=any               # 기본 차단
# 필요한 경우만 열기
#IPAddressAllow=127.0.0.0/8 ::1/128
#ProtectClock=true
SystemCallFilter=@system-service  # 화이트리스트 세트
ProcSubset=pid
```

> 이 블록을 사용하면 “루트 데몬” 대신 **최소 권한** + **쓰기 영역 격리**가 가능해진다.

### 4.6 준비/후처리/핫 리로드
```ini
[Service]
ExecStartPre=/usr/bin/bash -c '/usr/bin/test -f /opt/myapp/config.yml'
ExecStart=/opt/myapp/myapp
ExecReload=/bin/kill -HUP $MAINPID
ExecStopPost=/usr/bin/logger "myapp stopped"
```

---

## 5) **소켓 활성화**: 요청 올 때만 실행(.socket)

### 5.1 예시: `/etc/systemd/system/myapp.socket`
```ini
[Unit]
Description=MyApp Socket

[Socket]
ListenStream=0.0.0.0:9090
Accept=false

[Install]
WantedBy=sockets.target
```

### 5.2 서비스와 연결: `/etc/systemd/system/myapp.service`
```ini
[Unit]
Description=MyApp On-Demand
Requires=myapp.socket
After=network.target

[Service]
ExecStart=/opt/myapp/myapp --fd 3   # 소켓 FD를 인자로 받도록 구현
NonBlocking=true
```

### 5.3 동작
```bash
sudo systemctl enable --now myapp.socket
systemctl status myapp.socket
# 클라이언트 접속이 오면 systemd가 myapp.service를 자동 기동
```

> 장점: **유휴 시 리소스 0**. 경량 API/헬퍼에 적합.

---

## 6) **타이머 유닛**: 크론 대체(.timer)

### 6.1 서비스: `/etc/systemd/system/cleanup.service`
```ini
[Unit]
Description=Nightly cleanup

[Service]
Type=oneshot
ExecStart=/usr/local/bin/cleanup.sh
```

### 6.2 타이머: `/etc/systemd/system/cleanup.timer`
```ini
[Unit]
Description=Nightly cleanup timer

[Timer]
OnCalendar=*-*-* 03:00:00
Persistent=true        # 지났으면 부팅 시 보상 실행
RandomizedDelaySec=5m  # 스톰 방지(분산)

[Install]
WantedBy=timers.target
```

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now cleanup.timer
systemctl list-timers
journalctl -u cleanup.service
```

> `@reboot` 크론 대신 타이머를 쓰면 **의존성/로그/상태**가 모두 systemd로 통합된다.

---

## 7) **유저 단위 서비스**: 로그인없이 돌리기

### 7.1 사용자 서비스 디렉토리
```
~/.config/systemd/user/myapp.service
```

### 7.2 실행
```bash
systemctl --user daemon-reload
systemctl --user enable --now myapp
journalctl --user -u myapp -f
```

### 7.3 로그아웃 후에도 계속: linger
```bash
sudo loginctl enable-linger <username>
```

> CI runner, 개인 개발용 에이전트에 유용.

---

## 8) **템플릿 유닛/인스턴스**: 여러 인스턴스 쉽게

### 8.1 `/etc/systemd/system/myapp@.service`
```ini
[Unit]
Description=MyApp instance %i

[Service]
ExecStart=/opt/myapp/myapp --instance=%i --port=%I
DynamicUser=true
```

### 8.2 기동
```bash
sudo systemctl start myapp@alpha
sudo systemctl start myapp@beta
systemctl status 'myapp@*'
```

---

## 9) **sd_notify**: 준비 완료/워치독

### 9.1 서비스
```ini
[Service]
Type=notify
ExecStart=/opt/myapp/myapp
NotifyAccess=main
WatchdogSec=15s
```

### 9.2 C 예제(준비 알림)
```c
// gcc -o myapp myapp.c -lsystemd
#include <systemd/sd-daemon.h>
#include <unistd.h>
#include <stdio.h>
int main() {
    // 초기화...
    sd_notify(0, "READY=1");
    // 주기적으로 워치독 킥(설정 시)
    while (1) {
        sd_notify(0, "WATCHDOG=1");
        sleep(5);
    }
    return 0;
}
```

> `Type=notify`로 전환하면 **실제 준비 완료 시점**을 systemd에 정확히 알릴 수 있다.

---

## 10) **직접 데몬화 코드** (교육용)

### 10.1 C: 고전 데몬 스켈레톤
```c
/*
 * daemonize.c
 * gcc -o daemonize daemonize.c
 */
#include <unistd.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <syslog.h>
#include <fcntl.h>
#include <signal.h>

static volatile int running = 1;
void handle(int sig){ running = 0; }

int main(void) {
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);      // parent 종료

    if (setsid() < 0) exit(EXIT_FAILURE); // 새 세션
    signal(SIGTERM, handle);
    signal(SIGINT, handle);

    pid = fork();                         // 제어터미널 재획득 방지
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);

    umask(0);
    chdir("/");

    // 표준 FD 닫기
    close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO);
    open("/dev/null", O_RDONLY);
    open("/var/log/mydaemon.log", O_WRONLY|O_CREAT|O_APPEND, 0644);
    dup2(1, 2);

    openlog("mydaemon", LOG_PID, LOG_DAEMON);
    syslog(LOG_INFO, "started");

    while (running) {
        // 작업...
        sleep(5);
    }
    syslog(LOG_INFO, "stopped");
    closelog();
    return 0;
}
```

> 요즘은 **직접 데몬화 대신 systemd 서비스**로 관리하는 것이 표준.

### 10.2 Python: 간단 백그라운드 실행
```python
# app.py
import signal, time, sys, os

running = True
def handler(sig, frame):
    global running
    running = False

signal.signal(signal.SIGTERM, handler)
signal.signal(signal.SIGINT, handler)

# 로깅은 stdout → journald(ExecStart로 실행 시)
print("READY")
sys.stdout.flush()

while running:
    print("tick")
    sys.stdout.flush()
    time.sleep(2)

print("BYE")
```
**systemd**로 실행하면 출력은 `journalctl -u`에 남는다.

---

## 11) **supervisord** (선호 시)

### 11.1 구성: `/etc/supervisor/conf.d/myapp.conf`
```ini
[program:myapp]
directory=/opt/myapp
command=/opt/myapp/myapp --port 8080
autostart=true
autorestart=true
stdout_logfile=/var/log/myapp.out.log
stderr_logfile=/var/log/myapp.err.log
user=myapp
stopsignal=TERM
```

```bash
sudo supervisorctl reread
sudo supervisorctl update
sudo supervisorctl status
```

> systemd의 보안/리소스/의존성 기능은 부족할 수 있음.  
> 컨테이너 내부 단일 프로세스 감시에 쓰이기도 한다.

---

## 12) **우선순위/스케줄링/CPU 바인딩** (고급)

```bash
nice -n 10 ./myapp                # 낮은 CPU 우선순위
renice -n -5 -p <PID>             # 실시간 변경

ionice -c2 -n7 -p <PID>           # IO 우선순위 낮춤

taskset -c 2-3 ./myapp            # 특정 코어에 바인딩
chrt -r 10 -p <PID>               # 실시간 정책(주의)
```

> 운영환경에선 **성능/지연/안정성**을 함께 고려해 점진 적용.

---

## 13) **로깅·회전·관찰**

```bash
journalctl -u myapp --since "1 hour ago"
journalctl -u myapp -f
journalctl -xeu myapp           # 실패 원인 상세
systemctl status myapp -l
systemd-cgls                    # cgroup 트리
systemd-cgtop                   # cgroup별 사용량
```

- 별도 파일 로깅이 필요하면 `rsyslog`/`logrotate` 조합 또는 `StandardOutput=append:/var/log/myapp.log` 등을 선택(운영 정책에 맞춰).

---

## 14) **트러블슈팅 루틴**

1) 서비스가 곧 죽는다  
```bash
systemctl status myapp -l
journalctl -u myapp -b | tail -n 200
systemctl show myapp | egrep 'Result|Exit|State'
```

2) 포트/권한 문제  
- 1024 미만 포트를 root 없이 열려면  
```ini
AmbientCapabilities=CAP_NET_BIND_SERVICE
CapabilityBoundingSet=CAP_NET_BIND_SERVICE
User=myapp
```

3) 파일 핸들 고갈  
```bash
cat /proc/<PID>/limits | grep open
# 유닛에 LimitNOFILE=65535
```

4) 디렉토리 권한/경로  
- `WorkingDirectory=/opt/myapp`  
- `ReadWritePaths=/var/lib/myapp` 로 쓰기 허용 경로 최소화

5) 너무 자주 재시작(루프)  
- `Restart=on-failure`, `StartLimit*` 조정  
- crash 이유를 로그로 확보 후 수정

---

## 15) **완성형 서비스 예제** (운영 하드닝 종합)

`/etc/systemd/system/myapp.service`
```ini
[Unit]
Description=MyApp (Hardened)
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
User=myapp
Group=myapp
WorkingDirectory=/opt/myapp
ExecStart=/opt/myapp/myapp --config=/etc/myapp/config.yml
ExecReload=/bin/kill -HUP $MAINPID
Restart=on-failure
RestartSec=2s
StartLimitIntervalSec=30s
StartLimitBurst=10

# 리소스
LimitNOFILE=65535
CPUQuota=200%
MemoryMax=2G

# 런타임/상태 경로
RuntimeDirectory=myapp
StateDirectory=myapp
LogsDirectory=myapp

# 보안
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ProtectControlGroups=true
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectKernelLogs=true
RestrictSUIDSGID=true
LockPersonality=true
PrivateDevices=true
CapabilityBoundingSet=CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_BIND_SERVICE
DynamicUser=false
SystemCallFilter=@system-service
ProcSubset=pid
IPAddressDeny=any

# watchdog
WatchdogSec=15s
NotifyAccess=main

[Install]
WantedBy=multi-user.target
```

```bash
sudo useradd -r -s /usr/sbin/nologin -d /opt/myapp myapp
sudo mkdir -p /opt/myapp /etc/myapp
sudo chown -R myapp:myapp /opt/myapp /etc/myapp /var/lib/myapp /var/log/myapp
sudo systemctl daemon-reload
sudo systemctl enable --now myapp
```

---

## 16) **크론 @reboot vs systemd 타이머** (현대 권장)

- 크론 `@reboot`는 **의존성/로그/상태** 관리가 약함.  
- systemd `.timer`는 **실패 재실행, 보상 실행, 의존성, journald 로깅, 유닛 통합**으로 운영 친화적.

---

## 17) **레거시: SysVinit/`service`/`chkconfig`**

- `/etc/init.d/myapp` 스크립트 (RHEL6/CentOS6, 일부 임베디드)  
- 현대 배포판에선 `systemctl`이 래핑하므로 가능하면 마이그레이션 권장.

---

## 18) 체크리스트: 데몬 출시 전/후

- [ ] **서비스 파일**: `WorkingDirectory`, `ExecStart`, `Restart`, `LimitNOFILE`  
- [ ] **권한**: `User/Group`(root 금지), `CapabilityBoundingSet` 최소화  
- [ ] **리소스**: `CPUQuota`, `MemoryMax`  
- [ ] **보안**: `ProtectSystem`, `PrivateTmp`, `NoNewPrivileges`, `SystemCallFilter`  
- [ ] **로그**: `journalctl -u`로 확인, 필요 시 외부 집계(Elastic/CloudWatch 등)  
- [ ] **헬스체크**: `Type=notify` + `WatchdogSec` 혹은 `/healthz`  
- [ ] **배포 자동화**: `systemctl daemon-reload` 포함, 롤백 스크립트  
- [ ] **관찰**: `systemd-cgtop`, `pidstat`, `ss -tuln`  
- [ ] **백업 계획**: 설정/데이터 디렉토리 분리, `StateDirectory` 활용

---

## 19) 마무리

- 개발 단계에선 `nohup`, 운영 단계에선 **systemd**가 정답이다.  
- **소켓/타이머**로 유휴/주기 업무를 깔끔하게 통합하고,  
- **cgroups 리소스 제어**와 **보안 하드닝**으로 운영 위험을 줄이며,  
- **sd_notify/Watchdog**로 안정적인 라이프사이클을 구현하자.  
- 문제는 **journalctl**과 `systemctl show/cgls/cgtop`으로 수치화해서 해결한다.