---
layout: post
title: 운영체제 - 대용량 저장 구조 (1)
date: 2025-10-25 19:30:23 +0900
category: 운영체제
---
# Mass-Storage Structure

## Overview of Mass-Storage Structure

### 저장장치의 분류와 특성

- **HDD (Hard Disk Drive)**
  - **구성**: 플래터(자기 디스크), 스핀들(회전), 액추에이터 암(헤드 이동).
  - **지연 요소**
    - **탐색(Seek) 지연**: 헤드가 대상 트랙으로 이동하는 시간.
    - **회전(Rotational) 지연**: 원하는 섹터가 헤드 아래로 올 때까지 대기.
    - **전송(Transfer) 시간**: 섹터를 읽고/쓰는 실제 시간.
  - **성능 근사**
    $$
    T_{\text{HDD}} \approx T_{\text{seek}} + T_{\text{rot}} + T_{\text{xfer}}
    $$
- **SSD / NVM (Flash, NVMe, Optane/SCM 등)**
  - **구성**: 컨트롤러 + **FTL(Flash Translation Layer)**, 채널/웨이 병렬성, 내부 DRAM/캐시.
  - **지연 요소**
    - **큐잉/스케줄링**(호스트 & 장치), **프로그램/소거** 지연, **가비지 컬렉션(GC)**, **웨어 레벨링**, **쓰기 증폭**.
  - **성능 근사**
    $$
    T_{\text{NVM}} \approx T_{\text{queue}} + T_{\text{flash-op}} + T_{\text{GC/WA}}
    $$
  - **특징**: **랜덤/순차 성능 격차가 작음**, **지연 분산**은 GC/열화에 따라 튈 수 있음.

### 디바이스 인터페이스와 OS 스택

- **HDD**: SATA/SAS → AHCI/Host Bus Adapter → 블록 계층 → 파일시스템.
- **NVMe**: PCIe → **Submission/Completion Queues(SQ/CQ)** (다중 큐) → blk-mq → 파일시스템.
- **OS의 역할**:
  1) I/O 스케줄링(정책 결정)
  2) 요청 병합/정렬(merging, reordering)
  3) QoS/분리(BFQ/Deadline/Noop/Kyber 등)
  4) 충돌 회피와 동시성 제어(멀티큐 락 최소화)

---

## HDD Scheduling

> 회전하는 플래터와 기계식 액추에이터의 물리적 제약을 **효율적인 헤드 이동**으로 완화하는 것이 목표.

### 지연 요소 상세

- **평균 회전 지연**
  스핀들 회전수가 \(R\) RPM이면,
  $$
  T_{\text{rot,avg}} = \frac{1}{2}\cdot \frac{60}{R}\ \text{(초)}
  $$
  예: 7,200RPM → \( \frac{1}{2}\cdot\frac{60}{7200}\approx 4.17\text{ms} \)
- **탐색 지연 모델**
  실기계는 비선형이지만, 근사적으로
  $$
  T_{\text{seek}} \approx \alpha + \beta\cdot \sqrt{d}
  $$
  (\(d\): 트랙 간 거리) 혹은 데이터시트의 평균 탐색시간 사용(예: 9ms).

### 스케줄링 목표

- **총 이동 거리(트랙 간 이동)** 최소화 → 평균 지연 감소
- **평균 응답시간** 및 **분산** 감소
- **기아(starvation)** 방지(특히 단방향 편향 알고리즘에서)

### 대표 알고리즘

#### (A) FCFS (First-Come, First-Served) — 도착 순

- 장점: 공정, 구현 단순
- 단점: 헤드 이동 비효율(랜덤 순서 그대로)

#### (B) SSTF (Shortest Seek Time First) — 가장 가까운 트랙 우선

- 장점: 평균 이동거리↓
- 단점: **기아 가능**(중앙 근처 요청이 변두리를 굶김)

#### (C) SCAN (전동차/엘리베이터 스캔)

- 헤드가 한 방향으로 이동하며 해당 방향의 요청을 처리한 뒤 **끝에서 방향 반전**.
- 장점: SSTF 대비 **기아 감소**, 평균/최악 응답의 타협

#### (D) C-SCAN (Circular SCAN)

- 한 방향으로만 서비스하고 끝에 도달하면 **헤드를 처음으로 점프** 후 재개(반대 방향 서비스 없음).
- 장점: **균질한 응답시간**, 트랙의 위치에 따른 편향 감소

#### (E) LOOK / C-LOOK

- 실제 **마지막 요청**까지만 이동(물리 끝까지 가지 않음).
- SCAN/C-SCAN의 실용 최적화 버전.

### 시뮬레이션: 헤드 이동 총량/평균 응답 비교 (Python)

```python
# hdd_sched.py

from typing import List, Tuple

def fcfs(requests: List[int], head: int) -> Tuple[int, List[int]]:
    order = requests[:]
    dist = sum(abs(order[i] - (head if i==0 else order[i-1])) for i in range(len(order)))
    return dist, order

def sstf(requests: List[int], head: int) -> Tuple[int, List[int]]:
    req = requests[:]
    pos = head; order=[]; total=0
    while req:
        idx = min(range(len(req)), key=lambda i: abs(req[i]-pos))
        total += abs(req[idx]-pos)
        pos = req[idx]; order.append(pos); req.pop(idx)
    return total, order

def scan(requests: List[int], head: int, max_cyl: int, direction: int=1) -> Tuple[int, List[int]]:
    # direction=1: 증가 방향부터, -1: 감소 방향부터
    left = sorted([r for r in requests if r < head])
    right= sorted([r for r in requests if r >= head])
    order = []
    pos=head; total=0
    if direction>0:
        for r in right: total+=abs(r-pos); pos=r; order.append(r)
        total+=abs((max_cyl-1)-pos); pos=max_cyl-1
        for r in reversed(left): total+=abs(r-pos); pos=r; order.append(r)
    else:
        for r in reversed(left): total+=abs(r-pos); pos=r; order.append(r)
        total+=abs(pos-0); pos=0
        for r in right: total+=abs(r-pos); pos=r; order.append(r)
    return total, order

def cscan(requests: List[int], head: int, max_cyl: int, direction: int=1) -> Tuple[int, List[int]]:
    left = sorted([r for r in requests if r < head])
    right= sorted([r for r in requests if r >= head])
    order=[]; pos=head; total=0
    if direction>0:
        for r in right: total+=abs(r-pos); pos=r; order.append(r)
        # jump to start
        total += abs((max_cyl-1)-pos); pos=max_cyl-1
        total += abs(pos-0); pos=0
        for r in left: total+=abs(r-pos); pos=r; order.append(r)
    else:
        for r in reversed(left): total+=abs(r-pos); pos=r; order.append(r)
        total += abs(pos-0); pos=0
        total += abs((max_cyl-1)-pos); pos=max_cyl-1
        for r in reversed(right): total+=abs(r-pos); pos=r; order.append(r)
    return total, order

def look(requests: List[int], head: int, direction:int=1) -> Tuple[int, List[int]]:
    left = sorted([r for r in requests if r < head])
    right= sorted([r for r in requests if r >= head])
    order=[]; pos=head; total=0
    if direction>0:
        for r in right: total+=abs(r-pos); pos=r; order.append(r)
        for r in reversed(left): total+=abs(r-pos); pos=r; order.append(r)
    else:
        for r in reversed(left): total+=abs(r-pos); pos=r; order.append(r)
        for r in right: total+=abs(r-pos); pos=r; order.append(r)
    return total, order

def clook(requests: List[int], head: int, direction:int=1) -> Tuple[int, List[int]]:
    left = sorted([r for r in requests if r < head])
    right= sorted([r for r in requests if r >= head])
    order=[]; pos=head; total=0
    if direction>0:
        for r in right: total+=abs(r-pos); pos=r; order.append(r)
        if left:
            total += abs(pos-left[0]); pos=left[0]
        for r in left[1:]: total+=abs(r-pos); pos=r; order.append(r)
    else:
        for r in reversed(left): total+=abs(r-pos); pos=r; order.append(r)
        if right:
            total += abs(pos-right[-1]); pos=right[-1]
        for r in reversed(right[:-1]): total+=abs(r-pos); pos=r; order.append(r)
    return total, order

if __name__ == "__main__":
    req = [95, 180, 34, 119, 11, 123, 62, 64]
    head= 50; maxc=200
    for name, fn in [("FCFS",fcfs),("SSTF",sstf),
                     ("SCAN",lambda r,h:scan(r,h,maxc,1)),
                     ("C-SCAN",lambda r,h:cscan(r,h,maxc,1)),
                     ("LOOK",lambda r,h:look(r,h,1)),
                     ("C-LOOK",lambda r,h:clook(r,h,1))]:
        dist, order = fn(req, head) if "SCAN" not in name else fn(req, head)
        print(f"{name:6s} dist={dist:4d} order={order}")
```

**해설 포인트**
- **총 이동 거리**가 작을수록 평균 지연이 작아짐(탐색 시간 지배).
- **C-SCAN / C-LOOK**은 **균질 응답**을 설계 목표로 — 트랙 위치에 따른 편향을 줄임.
- 워크로드가 **한쪽에 몰리면** SSTF가 잘 작동하지만, **멀티큐/멀티스레드 스트림**에서는 **기아 방지**까지 고려해야 함.

### 응답시간/대기시간 평가 지표

- 요청 \(i\)의 **완료시간** \(C_i\), 도착시간 \(A_i\), 서비스시간 \(S_i\)일 때
  $$
  \text{Wait}_i = C_i - A_i - S_i,\quad \text{Turnaround}_i = C_i - A_i
  $$
- HDD는 **이동/회전 지연**이 서비스시간의 대부분 → 스케줄링이 곧 성능.

---

## NVM Scheduling

> **플래시/NVMe**에서는 “헤드 이동”이 없고, **병렬성/큐잉/내부 GC**가 성능을 좌우. 스케줄링은 **지연 예측 가능성**, **쓰기 증폭 최소화**, **QoS 분리**에 초점.

### Flash & FTL 기초

- **읽기/쓰기/소거 단위 불일치**: 읽기/쓰기=**페이지(예: 4–16KiB)**, 소거=**블록(수십~수백 페이지)**.
- **In-place 업데이트 불가** → **로그 구조** 쓰기 + **유효/무효 페이지** → **GC**가 **유효 페이지**를 이동/머지 후 **블록 소거**.
- **웨어 레벨링**: 블록 소거 횟수를 고르게.
- **쓰기 증폭(Write Amplification, WA)**
  $$
  WA \approx \frac{\text{NAND에 실제 기록한 바이트}}{\text{호스트가 요청한 바이트}}
  $$
  GC/병합이 많을수록 **WA↑** → 내구성과 지연 악화.

### NVMe 큐잉 모델

- **Submission/Completion Queues (SQ/CQ)**: 각 CPU가 **자신의 큐**로 I/O 제출 → **락/캐시 간섭 감소**.
- **큐 심도(Queue Depth)**: 동시 outstanding I/O 수. 깊이가 **너무 작으면** 병렬성↓, **너무 크면** tail latency↑(큐잉 지연/GC 간섭).
- **Command Priorities**: NVMe는 명령 우선순위/Namespaces로 격리 가능.

### 호스트 I/O 스케줄러(blk-mq)와 정책

- **noop**: 재배치/병합 거의 없음(플래시 전용, 장치가 스케줄링).
- **mq-deadline**: 단순 데드라인 보장 + read 우선. tail latency 제어에 강함.
- **kyber**: **서비스 클래스별 큐잉 제어**(읽기/쓰기/동기/비동기)로 **p99 지연** 목표.
- **bfq**: 시간 슬라이스 기반 **프로세스-별/컨트롤 그룹별 공정성**(데스크탑/미디어 재생에 호의적).

> 일반 가이드: **NVMe SSD → mq-deadline/kyber** 권장(서버 워크로드). HDD/혼합 장치는 **bfq**도 고려.

### Read/Write 혼합 워크로드에서의 스케줄링

- **읽기 지연 민감**: 데이터베이스/온라인 서비스 → **읽기 승격(read boosting)**, **쓰기 쓰로틀**.
- **FUA/FLUSH**: 순서/내구 보장 명령은 **멀티큐를 가로막는 배리어** 역할 → 묶음 처리/배치 필요.
- **Write coalescing**: 작고 랜덤한 쓰기를 컨트롤러/호스트 버퍼에서 **정렬/정합** → **WA↓**.

### 큐딥/혼합비율/GC를 반영한 간단 시뮬레이터 (Python)

```python
# nvme_sched_sim.py — 병렬 채널 & 큐잉/GC 개략 시뮬(학습용 근사)

import heapq, random

class Req:
    __slots__=("ts","rw","lba","size")
    def __init__(self, ts, rw, lba, size):
        self.ts=ts; self.rw=rw; self.lba=lba; self.size=size

def simulate(arrival_rate=1000, duration=0.5, qdepth=32, nch=4, p_read=0.7,
             t_read=80e-6, t_write=200e-6, gc_prob=0.02, t_gc=2e-3):
    # 이벤트 기반: 도착(ts), 채널 가용 시 처리. GC는 확률적으로 삽입.
    t=0.0; i=0
    pq=[] # (complete_time)
    inflight=0; lat=[]
    # 채널 가용 시간
    ch_free=[0.0]*nch
    while t<duration:
        # 도착
        inter = random.expovariate(arrival_rate)
        t += inter
        rw = 'R' if random.random()<p_read else 'W'
        size = 4096
        # 큐잉: qdepth 초과 시 대기(간단근사: 도착시점에 inflight<qdepth면 바로 발행, 아니면 큐잉 지연으로 보정)
        if inflight>=qdepth:
            # 큐 만석 → 가장 빠른 완료까지 대기
            soon = heapq.heappop(pq); inflight-=1
            for c in range(nch): ch_free[c]=max(ch_free[c], soon)
        # 채널 선택: 가장 빨리 비는 채널
        c = min(range(nch), key=lambda k: ch_free[k])
        start = max(t, ch_free[c])
        svc = t_read if rw=='R' else t_write
        # GC 간섭
        if random.random()<gc_prob:
            svc += t_gc
        done = start + svc
        lat.append(done - t)
        ch_free[c] = done
        heapq.heappush(pq, done); inflight+=1
    return sum(lat)/len(lat), sorted(lat)[int(0.99*len(lat))-1]

if __name__=="__main__":
    for q in (8,16,32,64):
        avg,p99 = simulate(qdepth=q)
        print(f"QD={q:2d} avg={avg*1e3:.2f}ms p99={p99*1e3:.2f}ms")
```

**관찰 포인트**
- **queue depth**를 늘리면 평균 대역폭은 좋아지지만, **p99 지연**이 악화(큐잉+GC 간섭).
- **채널 수(nch)**를 늘리면 같은 QD에서 **tail latency**가 완화.
- **read 비율↑**에서는 평균 지연이 낮아지고 분산도 줄어드는 경향(모델 파라미터에 따라 달라짐).

### FTL 관점 스케줄링/가비지 컬렉션 상호작용

- **호스트 쓰기 배치**가 좋으면(연속/LBA 정렬) → **FTL 병합 비용↓**, **WA↓**, **GC 간섭↓**.
- OS 층에서 **writeback/flush coalescing**과 **I/O 크기 정규화(예: 128KiB)** 로 **내부 병렬성** 극대화.
- **Trim/Discard**: 파일 삭제/공간 회수 시 **UNMAP**을 보내면, FTL이 **유효 페이지 수를 미리 줄여** GC 비용을 절약.
  - Linux: `fstrim`, 마운트 옵션 `discard`(실시간은 컨트롤러/워크로드에 따라 비용 상이 — 배치형 fstrim 권장).

### OS 스케줄러 선택 가이드(실전)

- **HDD**: `bfq`(데스크탑/미디어), `mq-deadline`(서버).
- **SATA SSD**: `mq-deadline` 기본, 매우 단순한 워크로드/하드웨어가 강력한 스케줄링을 할 경우 `noop`.
- **NVMe SSD**: `mq-deadline` 또는 **kyber**(p99 지연 제어가 중요할 때).
- **DB/OLTP**: 읽기 우선, flush 배치, QD 튜닝(QD 16~64 범위 실험), `latency_target` 기반 자동 조절.

### 예제: 리눅스에서 스케줄러/큐딥 설정과 측정(학습 스크립트)

```bash
# 注意: root 권한 필요, 실제 서버에서 신중히 사용!
# 장치별 스케줄러 확인/설정

cat /sys/block/nvme0n1/queue/scheduler
echo mq-deadline | sudo tee /sys/block/nvme0n1/queue/scheduler

# 큐 딥스 제어(blk-mq)

cat /sys/block/nvme0n1/queue/nr_requests
echo 128 | sudo tee /sys/block/nvme0n1/queue/nr_requests

# 읽기 우선 weight (cgroup v2 예)

echo "+io" | sudo tee /sys/fs/cgroup/cgroup.subtree_control
mkdir -p ~/cg/io
echo $$ | sudo tee ~/cg/io/cgroup.procs
# 읽기 우선 가중치

echo "default weight 500" | sudo tee /sys/fs/cgroup/io.weight
```

### WAL/DB와 동기 쓰기

- **WAL(Write-Ahead Logging)** 은 **fsync/FUA**를 동반 → I/O 경계가 **장치 내부 파이프라인을 깨뜨림**.
- 해결: **그룹 커밋**, **배치 fsync**, **문서화된 flush 간격**으로 **p99**를 안정화.

---

## 실습 패키지

### 실습 A — HDD 스케줄러 비교

1) `hdd_sched.py`에서 **여러 시퀀스**(균등/군집/편향) 생성.
2) FCFS/SSTF/SCAN/C-SCAN/LOOK/C-LOOK의 **이동거리**, **평균 대기** 비교.
3) 요청 분포가 **헤드 기준 비대칭**일 때 **기아** 발생 여부 확인.

### 실습 B — NVMe QD vs 체감 지연

1) `nvme_sched_sim.py`로 QD 1→128, `p_read` 0.3→0.9, `gc_prob` 0→0.05 스윕.
2) **avg vs p99** 지연 곡선 작성 → 서비스 SLO 목표에 맞는 **최적 QD** 선택.

### 실습 C — 쓰기 정렬의 효과

1) 섹터 크기 4KiB/쓰기 단위 128KiB로 **모아서** 제출 vs 4KiB 랜덤 쓰기 비교.
2) 모델에서 **t_write**를 크기 기반으로 선형/부분선형 증가로 바꾸고 **대역폭/p99** 관찰.

---

## 운영 체크리스트

1) **장치 타입 식별**: HDD/NVMe/혼합? → 스케줄러 선택의 출발점.
2) **큐딥/QoS**: QD 실험으로 **p99 SLO**를 만족하는 범위를 찾고, 읽기 승격/쓰기 쓰로틀 적용.
3) **파일시스템 옵션**: 배치형 `fstrim`, 저널 모드/배리어 설정, writeback 간격.
4) **멀티큐/NUMA**: CPU 코어당 큐 매핑, IRQ affinity, I/O 스레드 바인딩.
5) **데이터 배치**: **콜드 vs 핫** 분리, 로그/체크포인트/스냅샷을 **다른 네임스페이스/볼륨**으로 격리.
6) **관측**: `iostat -x`, `blktrace/btt`, `perf`, NVMe SMART/Log Page(실패 예측, 미디어 오류, GC 힌트).
7) **펌웨어/FTL 차이**: 동일 모델이라도 펌웨어에 따라 **WA/GC 정책**이 다름 → **AB 테스트** 및 **성능 드리프트** 모니터링.

---

## 핵심 요약

- **HDD Scheduling**: 기계식 제약(탐색/회전) → **헤드 이동 최적화**가 본질. SCAN/C-SCAN/LOOK 계열이 평균/분산/기아 사이의 균형.
- **NVM Scheduling**: 병렬 큐/내부 GC/WA가 지연을 좌우. **mq-deadline/kyber**와 **QD 최적화**, **읽기 승격·쓰기 배치**가 p99 안정화의 핵심.
- **현장 팁**: 분산 스토리지/DB는 **호스트-장치-네트워크** 전 스택에서 **배치/동시성/배리어**를 일관되게 설계해야 **지연의 롱테일**을 눌러 성능을 예측 가능하게 만든다.
