---
layout: post
title: DB 심화 - 인덱스 기본 원리
date: 2025-11-07 14:25:23 +0900
category: DB 심화
---
# 인덱스 기본 원리: **왜 인덱스가 안 붙고/범위 스캔이 안 되는가**

## 실습 준비

```sql
-- 클린업
DROP TABLE idx_demo PURGE;

-- 데모 테이블: 주문(고객, 날짜, 금액, 상태, 메모)
CREATE TABLE idx_demo (
  order_id    NUMBER        PRIMARY KEY,
  cust_id     NUMBER        NOT NULL,
  order_dt    DATE          NOT NULL,
  amount      NUMBER(12,2)  NOT NULL,
  status      VARCHAR2(8)   NOT NULL,
  note        VARCHAR2(100)
);

BEGIN
  FOR i IN 1..100000 LOOP
    INSERT INTO idx_demo
    VALUES (
      i,
      MOD(i, 5000) + 1,
      DATE '2025-01-01' + MOD(i, 365),
      TRUNC(DBMS_RANDOM.VALUE(10, 100000), 2),
      CASE MOD(i,5) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP'
                     WHEN 3 THEN 'DONE' ELSE 'CANC' END,
      CASE WHEN MOD(i,17)=0 THEN 'gift' ELSE NULL END
    );
  END LOOP;
  COMMIT;
END;
/

-- 인덱스
CREATE INDEX ix_idx_demo_cust_dt   ON idx_demo(cust_id, order_dt);
CREATE INDEX ix_idx_demo_status_dt ON idx_demo(status, order_dt);
CREATE INDEX ix_idx_demo_amount    ON idx_demo(amount);
CREATE INDEX ix_idx_demo_note      ON idx_demo(note);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'IDX_DEMO', cascade => TRUE, method_opt => 'for all columns size skewonly');
END;
/
```

---

## **인덱스 사용 불가/범위 스캔 불가**의 본질: SARGability

### SARGable이란?

- **S**earch **ARG**ument **able**: 인덱스 **탐색 키**(Start/Stop Key)를 만들 수 있어 **Root→Branch→Leaf**로 **점프할 수 있는** 조건.
- **핵심 원칙**: **인덱스 컬럼 “그 자체”**(또는 결정가능한 **상수/바인드**)로 **비교**해야 한다.
  → 컬럼에 **함수/연산**을 걸거나 **형변환을 컬럼 쪽에** 걸면 **탐색 키**를 만들 수 없어 **범위 스캔 불가**.

> 기억 문장: **“컬럼을 가공하지 말고, 바인드/상수를 가공하라.”**

---

## **컬럼 가공**(함수/연산) 때문에 인덱스가 안 붙는 경우

### 날짜 컬럼에 `TRUNC`(컬럼 쪽)

**나쁜 예**
```sql
-- TRUNC(order_dt) = 날짜  → 컬럼 가공으로 범위 스캔 불가(인덱스 사용 어려움)
SELECT * FROM idx_demo
WHERE TRUNC(order_dt) = DATE '2025-03-01';
```

**좋은 예 (리라이트)**
```sql
-- SARGable 범위 조건: Start/Stop Key가 명확
SELECT * FROM idx_demo
WHERE order_dt >= DATE '2025-03-01'
  AND order_dt <  DATE '2025-03-02';
```

### 문자열 컬럼에 `UPPER/LOWER/INITCAP`(컬럼 쪽)

**나쁜 예**
```sql
SELECT * FROM idx_demo
WHERE UPPER(status) = 'PAID';
```

**좋은 예**
```sql
-- 값 쪽을 가공하거나, 대소문자 일치 보장
SELECT * FROM idx_demo
WHERE status = 'PAID';
```

**불가피하게 대소문자 정규화가 필요**하다면 → **FBI** 사용
```sql
-- 대소문자 무시 검색을 가능하게 하는 Function-Based Index
CREATE INDEX ix_idx_demo_status_u ON idx_demo(UPPER(status));

SELECT /*+ index(idx_demo ix_idx_demo_status_u) */ *
FROM   idx_demo
WHERE  UPPER(status) = UPPER(:bind);
```

### 숫자/문자 컬럼에 산술/문자열 연산(컬럼 쪽)

**나쁜 예**
```sql
-- amount가 10% 오른 값 비교 (컬럼에 연산)
SELECT * FROM idx_demo
WHERE amount * 1.1 > :p;
```

**좋은 예**
```sql
-- 상수/바인드 쪽을 변환
SELECT * FROM idx_demo
WHERE amount > :p / 1.1;
```

### 패턴 검색에서 **선행 와일드카드**

**나쁜 예**
```sql
SELECT * FROM idx_demo
WHERE note LIKE '%gift%';   -- 앞에 % → 인덱스 시작점 불명확 → 범위 탐색 불가
```

**좋은 예**
```sql
-- 접두사 검색만 인덱스 사용 가능
SELECT * FROM idx_demo
WHERE note LIKE 'gift%';
```

**근본 해결(부분 문자열 검색)**
- **텍스트 인덱스**(Oracle Text),
- **N-gram 앞부분만을 위한 FBI(권장X, 제한적)**,
- **서치 엔진**(Elastic 등)로 분리.

### **함수 비결정성**/시계/세션 의존

`SYSDATE`, `SYSTIMESTAMP`, `DBMS_RANDOM`, `SYS_CONTEXT` 등은 **인덱스 표현식 자체**에는 부적합.
- WHERE 절에서는 **상수/바인드 비교**로 범위화하고, 인덱스에는 **순수 컬럼/순수함수**만.

---

## **묵시적 형변환** 때문에 인덱스가 안 붙거나 잘못된 범위가 되는 경우

> **묵시적 변환 규칙**: Oracle은 **컬럼 타입을 기준**으로 **반대편(상수/바인드)을 변환**하려고 시도. 하지만 **타입/포맷에 따라** 컬럼쪽으로 변환이 이동하거나 **함수 호출**이 끼어 **인덱스 불가**가 되기도 함.

### `DATE` 컬럼 vs 문자열 리터럴

**나쁜 예**
```sql
-- 문자열을 DATE로 묵시적 변환 → 세션 NLS_DATE_FORMAT 따라 실패/오동작
SELECT * FROM idx_demo
WHERE order_dt = '2025-03-01';  -- 위험
```

**좋은 예**
```sql
SELECT * FROM idx_demo
WHERE order_dt = DATE '2025-03-01';  -- ANSI 리터럴

-- 또는 명시적 변환 (NLS 독립)
WHERE order_dt = TO_DATE('2025-03-01','YYYY-MM-DD');
```

### `NUMBER` 컬럼 vs 문자열 바인드

**나쁜 예**
```sql
-- cust_id NUMBER vs 바인드가 VARCHAR2 → 묵시적 변환 과정에서 컬럼 가공될 여지
SELECT * FROM idx_demo
WHERE cust_id = :cust_str;  -- 드라이버가 문자열 바인드로 보내면 문제
```

**좋은 예**
```sql
-- 바인드 타입을 숫자로 맞춤
-- (JDBC/ODP.NET/cx_Oracle 등에서 파라미터 타입을 NUMBER로 고정)
WHERE cust_id = :cust_num;
```

### `TO_CHAR(컬럼)` vs 문자열 비교

**나쁜 예**
```sql
SELECT * FROM idx_demo
WHERE TO_CHAR(order_dt,'YYYY-MM') = '2025-03';
```
- **컬럼 가공**(TO_CHAR)로 인덱스 범위 스캔 불가.

**좋은 예**
```sql
-- SARGable 범위
WHERE order_dt >= DATE '2025-03-01'
  AND order_dt <  DATE '2025-04-01';
```

### 비교 연산자에서 **암시적 캐릭터셋/NLS** 영향

- `status = 'paid'` vs `status = 'PAID'`: **대소문자/Collation**에 민감.
- **NLS_COMP/NLS_SORT**를 LINGUISTIC으로 바꾸면 인덱스 경로가 바뀔 수 있다.
  → **일관된 NLS**(커넥션 풀에서 고정) + **값 표준화**(상수/바인드 쪽 변환) 권장.

---

## **인덱스 사용이 어려운 조건 유형**과 리라이트

### `NOT EQUAL (!=, <>), NOT LIKE, NOT IN`

- 범위가 **전 영역(전체 키 공간)**이라서 인덱스의 장점이 사라진다.

**나쁜 예**
```sql
SELECT * FROM idx_demo WHERE status <> 'PAID';
```

**대안**
- **긍정 조건으로 뒤집기**(가능한 범위 축소)
- 서브쿼리로 **존재성**을 재구성(세미/안티 조인)
- **집계/분할** 후 필요한 키만 읽기(케이스마다 상이)

### `IS NULL` / `IS NOT NULL`

- **B-tree**는 **널 값을 키로 저장하지 않음**(일반적으로).
- `IS NULL` 조건은 인덱스로 탐색이 어렵다(예외: 인덱스 포함 컬럼/함수 가공으로 NULL을 키로 만드는 설계).

**대안**
```sql
-- 1) NVL을 컬럼에 쓰지 말고, FBI로 'NULL을 특정 상수로 치환한' 인덱스 생성
CREATE INDEX ix_note_nvl ON idx_demo ( NVL(note, '§NULL§') );

-- 2) 질의
SELECT /*+ index(idx_demo ix_note_nvl) */ *
FROM   idx_demo
WHERE  NVL(note, '§NULL§') = '§NULL§';   -- IS NULL 등가
```

### `OR` 조건

- `OR`는 서로 다른 컬럼에 대한 조건을 **합집합**으로 만들며 **인덱스 병합**(BITMAP OR)을 유발하거나 **Full Scan**으로 기울기 쉽다.

**나쁜 예**
```sql
SELECT * FROM idx_demo
WHERE status = :s OR amount >= :a;
```

**리라이트**
- 가능하면 **UNION ALL**로 쪼갠 뒤 **중복 제거**가 필요하면 상위에서 DISTINCT.
```sql
SELECT * FROM idx_demo WHERE status = :s
UNION ALL
SELECT * FROM idx_demo WHERE amount >= :a
  AND NOT (status = :s);  -- 중복 제거 조건(상황 따라 생략/조정)
```
- 또는 **비즈니스 로직** 기준으로 **이항 분기** 처리(서버 쿼리 조건 단순화).

### `LIKE 'ABC%'` + **정렬 불일치**

- 스캔은 되지만 `ORDER BY`가 인덱스 정렬과 불일치하면 **추가 SORT 비용**.

**해결**
- **인덱스 컬럼 순서**를 정렬과 맞추거나,
- **커버링**(select-list 포함) + **Stopkey**로 **앞부분만** 읽도록 설계.

---

## **FBI(Function-Based Index)**로도 풀 수 있는가?

> 컬럼을 가공해야만 하는 요구(대소문자 무시, 공백 제거, 날짜 버킷 등)는 **FBI**로 해결 가능.
> **단**, 함수는 **결정적(Deterministic)** 이어야 하며, **외부 상태**에 의존하면 **틀린 결과**를 만든다.

### 안전 FBI 예시

```sql
-- 1) 대소문자 무시 검색
CREATE INDEX ix_status_u ON idx_demo( UPPER(status) );
SELECT * FROM idx_demo WHERE UPPER(status) = UPPER(:s);

-- 2) 날짜 버킷(일 단위)
CREATE INDEX ix_order_dt_d ON idx_demo( TRUNC(order_dt) );
SELECT * FROM idx_demo WHERE TRUNC(order_dt) = DATE '2025-03-01';
```

### 위험 FBI(금지)

```sql
-- 외부 테이블/시간/세션 상태에 의존하는 함수는 인덱스 표현식에 금지
CREATE OR REPLACE FUNCTION fx_bad(p VARCHAR2) RETURN NUMBER DETERMINISTIC IS
BEGIN
  RETURN CASE WHEN SYSDATE >= DATE '2025-03-01' THEN 1 ELSE 0 END;  -- 시간 의존
END;
/
CREATE INDEX ix_bad ON idx_demo( fx_bad(status) );  -- ❌ 잘못된 인덱스 키
```

---

## **실전 리라이트 패턴 모음** (나쁜 → 좋은)

### 날짜 = ‘문자열’

```sql
-- ❌
WHERE order_dt = '2025-03-01';

-- ✅ (ANSI/명시적 변환)
WHERE order_dt = DATE '2025-03-01';
-- 또는
WHERE order_dt >= DATE '2025-03-01' AND order_dt < DATE '2025-03-02';
```

### `TRUNC(컬럼)` vs 범위

```sql
-- ❌
WHERE TRUNC(order_dt) BETWEEN DATE '2025-03-01' AND DATE '2025-03-31';

-- ✅
WHERE order_dt >= DATE '2025-03-01'
  AND order_dt <  DATE '2025-04-01';
```

### `UPPER(컬럼)` vs 값 표준화

```sql
-- ❌
WHERE UPPER(status) = 'PAID';

-- ✅ (값을 상수화/바인드 표준화)
WHERE status = 'PAID';

-- ✅(대소문자 자유 검색이 필수면 FBI)
CREATE INDEX ix_status_u ON idx_demo(UPPER(status));
WHERE UPPER(status) = UPPER(:s);
```

### 산술식: 컬럼 vs 상수

```sql
-- ❌ 컬럼 측 연산
WHERE amount * 1.1 > :p;

-- ✅ 상수 측 재배치
WHERE amount > :p / 1.1;
```

### 부분 문자열/후방 일치

```sql
-- ❌
WHERE note LIKE '%gift%';

-- ✅ 접두사만 필요하다면
WHERE note LIKE 'gift%';

-- ✅ 진짜 부분 문자열 → Oracle Text 등 전문 인덱스 고려
```

### NULL 검사

```sql
-- ❌ 컬럼 가공 NVL(note,'X') = 'X' (인덱스 미사용/불안정)
-- ✅ FBI로 NULL을 키로 변환
CREATE INDEX ix_note_nullkey ON idx_demo(NVL(note,'§NULL§'));

SELECT /*+ index(idx_demo ix_note_nullkey) */ *
FROM   idx_demo
WHERE  NVL(note,'§NULL§') = '§NULL§';
```

### `OR` 분기

```sql
-- ❌
WHERE status='PAID' OR amount>=10000;

-- ✅
SELECT * FROM idx_demo WHERE status='PAID'
UNION ALL
SELECT * FROM idx_demo WHERE amount>=10000
  AND status <> 'PAID';
```

---

## **묵시적 형변환** 상세 사례 & 드라이버 레벨 체크

### JDBC/ODP.NET/cx_Oracle 바인드 타입 일치

- 컬럼이 `NUMBER`면 **파라미터도 NUMBER**로, `DATE`면 **DATE**로 보낼 것.
- 문자열로 보내면 **묵시적 변환**이 일어나고, **컬럼 가공**으로 인덱스를 못 쓸 수도 있다.

**JDBC 예**
```java
// ❌ 위험: 문자열 바인드
PreparedStatement ps = con.prepareStatement(
  "SELECT * FROM idx_demo WHERE cust_id = ?");
ps.setString(1, "100");  // 문자열

// ✅ 안전: 숫자 바인드
ps.setLong(1, 100L);
```

**Python (oracledb/cx_Oracle)**
```python
# ❌ 문자열 바인드

cur.execute("SELECT * FROM idx_demo WHERE order_dt = :d", d="2025-03-01")

# ✅ 날짜 타입 바인드

cur.execute("SELECT * FROM idx_demo WHERE order_dt = :d",
            d=datetime.date(2025,3,1))
```

### NLS에 따른 문자열→DATE 파싱 문제

```sql
ALTER SESSION SET NLS_DATE_FORMAT='DD/MM/YYYY';  -- 예시

-- ❌ 포맷 의존
WHERE order_dt = '01/03/2025';

-- ✅ ANSI/명시적
WHERE order_dt = DATE '2025-03-01';
```

---

## 인덱스 범위 스캔을 활성화하는 **설계 레시피**

1) **컬럼 순서**: 선행 컬럼은 **선택도 높은 필터**, 다음은 **주요 범위 컬럼**, 마지막은 **tie-breaker**(정렬 일치).
2) **정렬 일치 + Stopkey**: `ORDER BY`와 **인덱스 정렬**을 맞추고 `FETCH FIRST N`으로 **앞부분만** 읽기.
3) **커버링 인덱스**: SELECT-LIST가 인덱스로 충족되게 설계(랜덤 테이블 I/O 제거).
4) **FBI**: 불가피한 가공(대소문자/버킷/정규화)은 **FBI**로 해결(결정성 주의).
5) **클러스터링 팩터**: 테이블 물리 순서를 인덱스 순서에 가까이(CTAS 재적재 + 인덱스 재생성).
6) **SARGable 준수**: “**컬럼 가공 금지, 상수/바인드 가공**” 습관화.
7) **묵시적 변환 금지**: **바인드 타입/포맷을 컬럼과 일치**.

---

## 검증 스크립트(실행 계획/실행 통계로 확인)

```sql
ALTER SESSION SET statistics_level = ALL;

-- 1) 나쁜 vs 좋은: TRUNC(order_dt)
SELECT /* BAD */ COUNT(*)
FROM idx_demo
WHERE TRUNC(order_dt) = DATE '2025-03-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

SELECT /* GOOD */ COUNT(*)
FROM idx_demo
WHERE order_dt >= DATE '2025-03-01'
  AND order_dt <  DATE '2025-03-02';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

-- 2) LIKE 패턴
SELECT /* BAD */ COUNT(*) FROM idx_demo WHERE note LIKE '%gift%';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

SELECT /* GOOD */ COUNT(*) FROM idx_demo WHERE note LIKE 'gift%';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

- `INDEX RANGE SCAN`/`TABLE ACCESS BY INDEX ROWID` 유무, `Buffers/Reads` 비교로 **전/후**를 정량화.

---

## 자주 나오는 오해 Q&A

**Q1. `CURSOR_SHARING=FORCE`면 리터럴이 다 바인드로 바뀌니 인덱스 잘 쓰지 않나요?**
A. 파싱 공유 문제를 줄일 뿐, **SARGability**는 **쿼리 구조**의 문제. 컬럼 가공/묵시적 변환은 여전히 **인덱스 장애**.

**Q2. 함수기반 인덱스를 만들면 모든 함수가 가능?**
A. **결정성**(입력만으로 출력 결정)이 전제. 시간/세션/외부 테이블 의존 함수는 **금지**.

**Q3. `IS NULL`은 항상 인덱스 불가?**
A. 일반 B-tree는 NULL을 키로 저장하지 않지만, **FBI로 NULL을 키로 변환**하면 가능.

**Q4. Skip Scan으로 선행 컬럼 없어도 되죠?**
A. 선행 컬럼 **도메인이 작을 때만** 유효. 크면 Full Scan이 나은 경우가 많다.

---

## 요약 체크리스트

- [ ] WHERE 절에서 **컬럼에 함수/연산 금지**(TRUNC/UPPER/TO_CHAR/산술 등).
- [ ] **상수/바인드 쪽**으로 변환을 이동(SARGable).
- [ ] **날짜는 범위 표현**(Start/Stop Key), ANSI `DATE 'YYYY-MM-DD'`/명시적 `TO_DATE` 사용.
- [ ] **바인드 타입**을 **컬럼 타입과 일치**(묵시적 변환 금지).
- [ ] 부분 문자열/후방 일치는 **전문 인덱스** 고려.
- [ ] `OR`, `<>`, `NOT IN`, `IS [NOT] NULL`은 **범위 축소**/UNION/세미·안티조인/혹은 FBI로 설계.
- [ ] 필요 시 **FBI**(결정성 보장)로 인덱스화.
- [ ] 실행계획/ALLSTATS LAST로 **실제 블록 수/대기**를 확인해 전/후 검증.

> 결론: 인덱스는 “**지도**”이고 SARGability는 “**목적지 좌표**”입니다.
