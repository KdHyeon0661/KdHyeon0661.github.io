---
layout: post
title: DB 심화 - 인덱스 기본 원리
date: 2025-11-07 14:25:23 +0900
category: DB 심화
---
# 인덱스 기본 원리: 인덱스 사용 불가와 범위 스캔 실패의 원인 분석

> **핵심 요약**
> 인덱스가 효과적으로 사용되지 않는 주된 원인은 SARGability(Search Argument Able) 문제입니다. 이는 WHERE 절의 조건이 인덱스 탐색 키로 사용될 수 없는 형태로 작성되었기 때문입니다. 컬럼에 함수를 적용하거나, 묵시적 형변환이 발생하거나, 비효율적인 조건식을 사용하면 옵티마이저가 인덱스 범위 스캔을 선택하지 못하게 됩니다. 이러한 문제를 해결하기 위해서는 컬럼 자체를 가공하지 않고 상수나 바인드 변수를 가공하는 방식으로 쿼리를 재작성해야 합니다.

---

## 실습 환경 구성

```sql
-- 테스트 테이블 생성
DROP TABLE idx_demo PURGE;

CREATE TABLE idx_demo (
  order_id    NUMBER        PRIMARY KEY,
  cust_id     NUMBER        NOT NULL,
  order_dt    DATE          NOT NULL,
  amount      NUMBER(12,2)  NOT NULL,
  status      VARCHAR2(8)   NOT NULL,
  note        VARCHAR2(100)
);

-- 샘플 데이터 생성 (100,000건)
BEGIN
  FOR i IN 1..100000 LOOP
    INSERT INTO idx_demo
    VALUES (
      i,
      MOD(i, 5000) + 1,
      DATE '2025-01-01' + MOD(i, 365),
      TRUNC(DBMS_RANDOM.VALUE(10, 100000), 2),
      CASE MOD(i,5) 
        WHEN 0 THEN 'NEW' 
        WHEN 1 THEN 'PAID' 
        WHEN 2 THEN 'SHIP'
        WHEN 3 THEN 'DONE' 
        ELSE 'CANC' 
      END,
      CASE WHEN MOD(i,17)=0 THEN 'gift' ELSE NULL END
    );
    
    -- 일정 주기로 커밋
    IF MOD(i, 10000) = 0 THEN
      COMMIT;
    END IF;
  END LOOP;
  COMMIT;
END;
/

-- 다양한 인덱스 생성
CREATE INDEX ix_idx_demo_cust_dt   ON idx_demo(cust_id, order_dt);
CREATE INDEX ix_idx_demo_status_dt ON idx_demo(status, order_dt);
CREATE INDEX ix_idx_demo_amount    ON idx_demo(amount);
CREATE INDEX ix_idx_demo_note      ON idx_demo(note);

-- 통계 정보 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname => USER,
    tabname => 'IDX_DEMO',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt => 'FOR ALL COLUMNS SIZE SKEWONLY',
    cascade => TRUE
  );
END;
/

-- 상세 실행 통계 활성화
ALTER SESSION SET statistics_level = ALL;
```

---

## SARGability의 기본 개념 이해

### SARGability란 무엇인가?

SARGability(Search Argument Able)는 WHERE 절의 조건식이 인덱스 탐색 키로 사용될 수 있는지를 판단하는 개념입니다. 옵티마이저가 인덱스의 Root → Branch → Leaf 노드로 효율적으로 탐색할 수 있으려면 조건식이 특정 형태를 가져야 합니다.

**핵심 원칙:**
- 인덱스 컬럼 자체를 변경하지 않고 비교해야 합니다.
- 상수나 바인드 변수 쪽을 가공하여 비교식을 구성해야 합니다.
- 인덱스 컬럼에 함수나 연산을 적용하면 탐색 키를 생성할 수 없습니다.

### SARGable 조건의 예시

```sql
-- SARGable (인덱스 사용 가능)
SELECT * FROM idx_demo WHERE cust_id = 100;
SELECT * FROM idx_demo WHERE order_dt >= DATE '2025-03-01';
SELECT * FROM idx_demo WHERE status = 'PAID' AND order_dt >= DATE '2025-01-01';

-- Non-SARGable (인덱스 사용 어려움)
SELECT * FROM idx_demo WHERE TRUNC(order_dt) = DATE '2025-03-01';
SELECT * FROM idx_demo WHERE UPPER(status) = 'PAID';
SELECT * FROM idx_demo WHERE amount * 1.1 > 10000;
```

---

## 주요 인덱스 사용 불가 패턴과 해결책

### 패턴 1: 날짜 컬럼에 함수 적용

**문제 상황:**
```sql
-- 컬럼에 TRUNC 함수 적용 (인덱스 사용 불가)
SELECT * FROM idx_demo
WHERE TRUNC(order_dt) = DATE '2025-03-01';
```

**해결 방안:**
```sql
-- 범위 조건으로 재작성 (인덱스 사용 가능)
SELECT * FROM idx_demo
WHERE order_dt >= DATE '2025-03-01'
  AND order_dt < DATE '2025-03-02';

-- 실행 계획 비교
EXPLAIN PLAN FOR
SELECT /*+ GATHER_PLAN_STATISTICS */ *
FROM idx_demo
WHERE TRUNC(order_dt) = DATE '2025-03-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT /*+ GATHER_PLAN_STATISTICS */ *
FROM idx_demo
WHERE order_dt >= DATE '2025-03-01'
  AND order_dt < DATE '2025-03-02';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 패턴 2: 문자열 컬럼에 대소문자 변환

**문제 상황:**
```sql
-- 컬럼에 UPPER 함수 적용
SELECT * FROM idx_demo
WHERE UPPER(status) = 'PAID';
```

**해결 방안:**
```sql
-- 방법 1: 데이터 표준화 (권장)
SELECT * FROM idx_demo
WHERE status = 'PAID';  -- 저장 시 대문자로 통일

-- 방법 2: 함수 기반 인덱스 사용
CREATE INDEX ix_idx_demo_status_upper ON idx_demo(UPPER(status));

SELECT /*+ INDEX(idx_demo ix_idx_demo_status_upper) */ *
FROM idx_demo
WHERE UPPER(status) = 'PAID';

-- 방법 3: 바인드 변수 표준화
SELECT * FROM idx_demo
WHERE status = UPPER(:input_status);
```

### 패턴 3: 산술 연산을 컬럼에 적용

**문제 상황:**
```sql
-- 컬럼에 산술 연산 적용
SELECT * FROM idx_demo
WHERE amount * 1.1 > :threshold;
```

**해결 방안:**
```sql
-- 상수 쪽으로 연산 이동
SELECT * FROM idx_demo
WHERE amount > :threshold / 1.1;

-- 함수 기반 인덱스 활용 (필요 시)
CREATE INDEX ix_idx_demo_amount_tax ON idx_demo(amount * 1.1);

SELECT /*+ INDEX(idx_demo ix_idx_demo_amount_tax) */ *
FROM idx_demo
WHERE amount * 1.1 > :threshold;
```

### 패턴 4: 와일드카드 패턴 검색

**문제 상황:**
```sql
-- 선행 와일드카드 사용
SELECT * FROM idx_demo
WHERE note LIKE '%gift%';
```

**해결 방안:**
```sql
-- 접두사 검색 (인덱스 사용 가능)
SELECT * FROM idx_demo
WHERE note LIKE 'gift%';

-- 전문 검색 필요 시 Oracle Text 활용
-- 1. Oracle Text 인덱스 생성
BEGIN
  CTX_DDL.CREATE_PREFERENCE('idx_demo_lexer', 'BASIC_LEXER');
  CTX_DDL.SET_ATTRIBUTE('idx_demo_lexer', 'index_themes', 'NO');
  CTX_DDL.SET_ATTRIBUTE('idx_demo_lexer', 'index_text', 'YES');
END;
/

CREATE INDEX idx_demo_note_ctx ON idx_demo(note)
INDEXTYPE IS CTXSYS.CONTEXT
PARAMETERS ('LEXER idx_demo_lexer');

-- 2. CONTAINS 연산자 사용
SELECT * FROM idx_demo
WHERE CONTAINS(note, 'gift') > 0;
```

---

## 묵시적 형변환 문제와 해결

### 날짜 컬럼과 문자열 비교

**문제 상황:**
```sql
-- 문자열 리터럴과 날짜 비교 (묵시적 변환)
SELECT * FROM idx_demo
WHERE order_dt = '2025-03-01';  -- 세션 NLS 설정에 의존
```

**해결 방안:**
```sql
-- ANSI 날짜 리터럴 사용
SELECT * FROM idx_demo
WHERE order_dt = DATE '2025-03-01';

-- 명시적 TO_DATE 변환
SELECT * FROM idx_demo
WHERE order_dt = TO_DATE('2025-03-01', 'YYYY-MM-DD');

-- 바인드 변수 사용 시
SELECT * FROM idx_demo
WHERE order_dt = :order_date;  -- DATE 타입 바인드
```

### 숫자 컬럼과 문자열 비교

**문제 상황:**
```sql
-- 문자열 바인드와 숫자 컬럼 비교
SELECT * FROM idx_demo
WHERE cust_id = :cust_id_str;  -- 문자열 바인드
```

**해결 방안:**
```sql
-- 올바른 데이터 타입 사용
-- 애플리케이션 코드 수정 예시:

-- Java/JDBC
// ❌ 잘못된 방법
preparedStatement.setString(1, "100");

// ✅ 올바른 방법
preparedStatement.setInt(1, 100);

-- Python
# ❌ 잘못된 방법
cursor.execute("SELECT * FROM idx_demo WHERE cust_id = :id", id="100")

# ✅ 올바른 방법
cursor.execute("SELECT * FROM idx_demo WHERE cust_id = :id", id=100)
```

### NLS 설정에 따른 영향

```sql
-- NLS 설정 확인
SELECT 
    parameter,
    value
FROM nls_session_parameters
WHERE parameter IN ('NLS_DATE_FORMAT', 'NLS_TIMESTAMP_FORMAT', 
                    'NLS_NUMERIC_CHARACTERS', 'NLS_SORT');

-- 안전한 쿼리 작성 방법
-- 1. 세션 NLS 설정 표준화
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'YYYY-MM-DD HH24:MI:SS';

-- 2. 명시적 형변환 사용
SELECT * FROM idx_demo
WHERE order_dt = TO_DATE(:date_string, 'YYYY-MM-DD');

-- 3. ANSI 리터럴 사용
SELECT * FROM idx_demo
WHERE order_dt = DATE '2025-03-01';
```

---

## 특수 조건식의 인덱스 활용 문제

### NOT 조건 처리

**문제 상황:**
```sql
-- NOT 조건 (인덱스 활용 어려움)
SELECT * FROM idx_demo
WHERE status <> 'PAID';
SELECT * FROM idx_demo
WHERE NOT (amount > 10000);
```

**해결 방안:**
```sql
-- 긍정 조건으로 재작성 (가능한 경우)
SELECT * FROM idx_demo
WHERE status IN ('NEW', 'SHIP', 'DONE', 'CANC');

-- 범위를 구체화
SELECT * FROM idx_demo
WHERE amount <= 10000;

-- 필요한 경우 안티 조인 활용
SELECT d.*
FROM idx_demo d
WHERE NOT EXISTS (
    SELECT 1 FROM idx_demo d2
    WHERE d2.order_id = d.order_id
      AND d2.status = 'PAID'
);
```

### NULL 값 검색

**문제 상황:**
```sql
-- NULL 검색 (B-tree 인덱스 미사용)
SELECT * FROM idx_demo
WHERE note IS NULL;
```

**해결 방안:**
```sql
-- 방법 1: 함수 기반 인덱스 생성
CREATE INDEX ix_idx_demo_note_nvl ON idx_demo (
    CASE WHEN note IS NULL THEN 'Y' ELSE 'N' END
);

SELECT /*+ INDEX(idx_demo ix_idx_demo_note_nvl) */ *
FROM idx_demo
WHERE CASE WHEN note IS NULL THEN 'Y' ELSE 'N' END = 'Y';

-- 방법 2: 별도의 NOT NULL 플래그 컬럼 추가
ALTER TABLE idx_demo ADD (note_is_null CHAR(1) DEFAULT 'N');
UPDATE idx_demo SET note_is_null = 'Y' WHERE note IS NULL;
CREATE INDEX ix_idx_demo_note_null ON idx_demo(note_is_null);
```

### OR 조건 최적화

**문제 상황:**
```sql
-- OR 조건 (인덱스 병합 필요)
SELECT * FROM idx_demo
WHERE status = 'PAID' OR amount >= 10000;
```

**해결 방안:**
```sql
-- UNION ALL로 분리 (중복 없을 때)
SELECT * FROM idx_demo WHERE status = 'PAID'
UNION ALL
SELECT * FROM idx_demo WHERE amount >= 10000
  AND status <> 'PAID';

-- UNION ALL로 분리 (중복 가능할 때)
SELECT * FROM idx_demo WHERE status = 'PAID'
UNION ALL
SELECT * FROM idx_demo WHERE amount >= 10000;

-- IN 조건으로 변환 (동일 컬럼일 때)
SELECT * FROM idx_demo
WHERE status IN ('PAID', 'SHIP');  -- status = 'PAID' OR status = 'SHIP'
```

---

## 함수 기반 인덱스(FBI)의 적절한 활용

### FBI 생성 가이드

```sql
-- 결정적 함수를 사용한 FBI
CREATE INDEX ix_idx_demo_func1 ON idx_demo(
    UPPER(status),
    TRUNC(order_dt)
);

-- 복합 FBI
CREATE INDEX ix_idx_demo_func2 ON idx_demo(
    cust_id,
    EXTRACT(YEAR FROM order_dt),
    EXTRACT(MONTH FROM order_dt)
);

-- 계산된 컬럼 FBI
CREATE INDEX ix_idx_demo_func3 ON idx_demo(
    amount,
    CASE 
        WHEN amount < 1000 THEN 'LOW'
        WHEN amount < 10000 THEN 'MEDIUM'
        ELSE 'HIGH'
    END
);

-- FBI 사용 쿼리
SELECT /*+ INDEX(idx_demo ix_idx_demo_func1) */ 
       order_id, cust_id, order_dt, status
FROM idx_demo
WHERE UPPER(status) = 'PAID'
  AND TRUNC(order_dt) = DATE '2025-03-01';
```

### FBI 생성 시 주의사항

```sql
-- ❌ 비결정적 함수 사용 금지
CREATE OR REPLACE FUNCTION get_current_year RETURN NUMBER IS
BEGIN
    RETURN EXTRACT(YEAR FROM SYSDATE);  -- 시간에 의존적
END;
/

-- ❌ 잘못된 FBI 생성 (비결정적 함수)
CREATE INDEX ix_bad_fbi ON idx_demo(get_current_year());

-- ✅ 결정적 함수 정의
CREATE OR REPLACE FUNCTION calculate_discount(
    p_amount IN NUMBER
) RETURN NUMBER DETERMINISTIC IS
BEGIN
    RETURN CASE 
        WHEN p_amount >= 10000 THEN p_amount * 0.9
        WHEN p_amount >= 5000 THEN p_amount * 0.95
        ELSE p_amount
    END;
END;
/

-- ✅ 올바른 FBI 생성
CREATE INDEX ix_good_fbi ON idx_demo(calculate_discount(amount));
```

---

## 실전 쿼리 재작성 패턴 모음

### 날짜 관련 쿼리 최적화

```sql
-- 원본 (비효율적)
SELECT * FROM idx_demo
WHERE TO_CHAR(order_dt, 'YYYY-MM') = '2025-03';

-- 개선안 1: 범위 조건 사용
SELECT * FROM idx_demo
WHERE order_dt >= DATE '2025-03-01'
  AND order_dt < DATE '2025-04-01';

-- 개선안 2: FBI 활용
CREATE INDEX ix_idx_demo_year_month ON idx_demo(
    EXTRACT(YEAR FROM order_dt),
    EXTRACT(MONTH FROM order_dt)
);

SELECT /*+ INDEX(idx_demo ix_idx_demo_year_month) */ *
FROM idx_demo
WHERE EXTRACT(YEAR FROM order_dt) = 2025
  AND EXTRACT(MONTH FROM order_dt) = 3;
```

### 문자열 검색 최적화

```sql
-- 원본 (비효율적)
SELECT * FROM idx_demo
WHERE UPPER(status) = UPPER(:input_status)
   OR LOWER(status) = LOWER(:input_status);

-- 개선안 1: 데이터 표준화
SELECT * FROM idx_demo
WHERE status = UPPER(:input_status);  -- 저장 시 대문자 통일 가정

-- 개선안 2: FBI 활용
CREATE INDEX ix_idx_demo_status_ci ON idx_demo(UPPER(status));

SELECT /*+ INDEX(idx_demo ix_idx_demo_status_ci) */ *
FROM idx_demo
WHERE UPPER(status) = UPPER(:input_status);
```

### 복합 조건 최적화

```sql
-- 원본 (OR 조건 비효율)
SELECT * FROM idx_demo
WHERE (status = 'PAID' AND amount > 5000)
   OR (status = 'SHIP' AND amount > 10000);

-- 개선안 1: UNION ALL 분리
SELECT * FROM idx_demo WHERE status = 'PAID' AND amount > 5000
UNION ALL
SELECT * FROM idx_demo WHERE status = 'SHIP' AND amount > 10000;

-- 개선안 2: CASE 표현식 활용
SELECT * FROM idx_demo
WHERE (status, amount) IN (
    ('PAID', 5000),
    ('SHIP', 10000)
);
```

---

## 성능 측정과 검증 방법

### 실행 계획 분석 도구

```sql
-- 기본 실행 계획 확인
EXPLAIN PLAN FOR
SELECT * FROM idx_demo
WHERE TRUNC(order_dt) = DATE '2025-03-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 실제 실행 통계 포함 계획
SELECT /*+ GATHER_PLAN_STATISTICS */ *
FROM idx_demo
WHERE order_dt >= DATE '2025-03-01'
  AND order_dt < DATE '2025-03-02';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL, 'ALLSTATS LAST'));

-- 상세 실행 계획
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, NULL, 'ADVANCED ALLSTATS LAST +PEEKED_BINDS +OUTLINE'
));
```

### 성능 비교 스크립트

```sql
-- 인덱스 사용 여부 성능 비교
SET TIMING ON
SET AUTOTRACE TRACEONLY STATISTICS

-- 케이스 1: Non-SARGable 쿼리
SELECT /*+ NON_SARGABLE */ COUNT(*)
FROM idx_demo
WHERE TRUNC(order_dt) = DATE '2025-03-01';

-- 케이스 2: SARGable 쿼리
SELECT /*+ SARGABLE */ COUNT(*)
FROM idx_demo
WHERE order_dt >= DATE '2025-03-01'
  AND order_dt < DATE '2025-03-02';

SET AUTOTRACE OFF
SET TIMING OFF

-- 결과 비교를 위한 테이블
CREATE TABLE query_performance_log (
    test_id NUMBER GENERATED ALWAYS AS IDENTITY,
    query_type VARCHAR2(50),
    execution_time_ms NUMBER,
    buffer_gets NUMBER,
    physical_reads NUMBER,
    test_timestamp TIMESTAMP DEFAULT SYSTIMESTAMP
);
```

### 인덱스 사용 통계 모니터링

```sql
-- 인덱스 사용 통계 확인
SELECT 
    index_name,
    table_name,
    monitoring,
    used,
    start_monitoring,
    end_monitoring
FROM v$object_usage
WHERE table_name = 'IDX_DEMO';

-- 인덱스 모니터링 활성화
ALTER INDEX ix_idx_demo_cust_dt MONITORING USAGE;

-- 인덱스 사용 테스트 후 확인
SELECT * FROM idx_demo WHERE cust_id = 1000;

SELECT 
    index_name,
    used,
    start_monitoring
FROM v$object_usage
WHERE index_name = 'IX_IDX_DEMO_CUST_DT';
```

---

## 실무 적용을 위한 모범 사례

### 애플리케이션 개발 가이드라인

1. **쿼리 작성 원칙**
   ```sql
   -- ❌ 피해야 할 패턴
   WHERE UPPER(column) = :value
   WHERE TRUNC(date_column) = :date
   WHERE column || '' = :value
   
   -- ✅ 권장 패턴
   WHERE column = UPPER(:value)
   WHERE date_column >= :start_date AND date_column < :end_date
   WHERE column = :value
   ```

2. **바인드 변수 사용 원칙**
   ```java
   // Java/JDBC 예시
   // ❌ 잘못된 방법
   String sql = "SELECT * FROM orders WHERE order_date = '" + dateStr + "'";
   
   // ✅ 올바른 방법
   String sql = "SELECT * FROM orders WHERE order_date = ?";
   preparedStatement.setDate(1, java.sql.Date.valueOf(dateStr));
   
   // ✅ 타입 일치 중요
   preparedStatement.setInt(1, intValue);      -- NUMBER 컬럼
   preparedStatement.setDate(2, dateValue);    -- DATE 컬럼
   preparedStatement.setString(3, stringValue); -- VARCHAR2 컬럼
   ```

### 데이터베이스 설계 가이드라인

1. **인덱스 설계 원칙**
   ```sql
   -- 복합 인덱스 컬럼 순서
   CREATE INDEX ix_orders_composite ON orders (
       status,           -- 선택도 높은 컬럼
       order_date DESC,  -- 범위/정렬 컬럼
       customer_id       -- tie-breaker
   );
   
   -- 커버링 인덱스
   CREATE INDEX ix_orders_covering ON orders (
       customer_id,
       order_date,
       status
   ) INCLUDE (amount, shipping_address);
   ```

2. **데이터 타입 표준화**
   ```sql
   -- 날짜 컬럼: 항상 DATE/TIMESTAMP 사용
   CREATE TABLE orders (
       order_date DATE NOT NULL,
       -- VARCHAR2에 날짜 저장 금지
   );
   
   -- 숫자 컬럼: NUMBER 사용
   CREATE TABLE products (
       price NUMBER(10,2) NOT NULL,
       -- VARCHAR2에 숫자 저장 금지
   );
   ```

### 성능 모니터링 체계

```sql
-- 정기적 성능 분석 리포트
CREATE OR REPLACE PROCEDURE generate_index_performance_report AS
    v_report CLOB;
BEGIN
    -- 1. Non-SARGable 쿼리 탐지
    SELECT sql_text
    BULK COLLECT INTO v_report
    FROM v$sql
    WHERE UPPER(sql_text) LIKE '%TRUNC(%'
       OR UPPER(sql_text) LIKE '%UPPER(%'
       OR UPPER(sql_text) LIKE '%TO_CHAR(%'
       AND executions > 100;
    
    -- 2. 미사용 인덱스 식별
    FOR idx IN (
        SELECT index_name, table_name
        FROM v$object_usage
        WHERE used = 'NO'
          AND end_monitoring IS NULL
    ) LOOP
        -- 리포트에 추가
        NULL;
    END LOOP;
    
    -- 3. 성능 권장 사항 생성
    DBMS_OUTPUT.PUT_LINE('인덱스 성능 최적화 리포트');
END;
/

-- 정기적 실행 스케줄
BEGIN
    DBMS_SCHEDULER.CREATE_JOB(
        job_name        => 'INDEX_PERFORMANCE_REPORT_JOB',
        job_type        => 'PLSQL_BLOCK',
        job_action      => 'BEGIN generate_index_performance_report; END;',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=WEEKLY; BYDAY=MON; BYHOUR=2',
        enabled         => TRUE
    );
END;
/
```

---

## 결론: 효과적인 인덱스 활용을 위한 종합 전략

인덱스가 효과적으로 사용되지 않는 문제는 대부분 SARGability 원칙을 위반한 쿼리 작성에서 비롯됩니다. 이러한 문제를 해결하기 위해서는 근본적인 접근 방식의 변화가 필요합니다.

### 핵심 성공 전략

1. **쿼리 작성 습관 개선**
   - 컬럼 자체를 가공하지 말고, 상수나 바인드 변수를 가공하세요.
   - 날짜 검색은 범위 조건으로, 문자열 검색은 표준화된 형식으로 작성하세요.
   - 애플리케이션에서 올바른 데이터 타입을 사용하여 바인드 변수를 전달하세요.

2. **데이터베이스 설계 최적화**
   - 인덱스 설계 시 접근 패턴을 고려하세요.
   - 필요한 경우 함수 기반 인덱스를 활용하되, 결정적 함수만 사용하세요.
   - 데이터 타입을 일관되게 관리하고 표준화하세요.

3. **성능 모니터링 체계 구축**
   - 정기적으로 실행 계획을 분석하세요.
   - Non-SARGable 쿼리를 식별하고 개선하세요.
   - 미사용 인덱스를 정리하고 최적화하세요.

4. **개발 문화 정립**
   - 코드 리뷰 시 쿼리 최적화 점검을 포함하세요.
   - 성능 테스트를 개발 주기에 통합하세요.
   - 지속적인 학습과 개선을 장려하세요.

### 실무 적용을 위한 조언

인덱스 최적화는 단순한 기술적 조치를 넘어 시스템 전체의 설계 철학을 반영합니다. 가장 효과적인 최적화는 문제를 사전에 예방하는 설계에서 시작됩니다. 데이터 모델링 단계부터 성능을 고려한 접근이 장기적인 성공을 보장합니다.

기억하세요: 옵티마이저는 훌륭한 도구이지만 마법사는 아닙니다. 개발자가 작성한 쿼리의 구조에 따라 최적의 실행 계획을 선택할 수 있습니다. SARGability 원칙을 준수한 쿼리 작성이 인덱스의 진정한 힘을 발휘할 수 있는 첫걸음입니다.

정기적인 성능 모니터링, 주기적인 튜닝, 그리고 지속적인 개선 문화를 통해 시스템의 건강을 유지하시기 바랍니다. 작은 변화부터 시작하여 점진적으로 개선해 나가다 보면, 인덱스 관련 성능 문제는 크게 감소할 것입니다.