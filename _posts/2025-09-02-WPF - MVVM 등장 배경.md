---
layout: post
title: WPF - MVVM 등장 배경
date: 2025-09-02 14:25:23 +0900
category: WPF
---
# MVVM 등장 배경 및 Model·View·ViewModel 역할 분리

WPF는 **XAML, 데이터 바인딩, 의존 속성**이라는 강력한 기반을 갖추고 있습니다. 그러나 초기에는 WinForms와 유사하게 **코드비하인드(이벤트 핸들러 중심)**로 UI 로직을 작성하는 경우가 많았으며, 이 방식은 프로젝트 규모가 커질수록 유지보수가 매우 어려워졌습니다. **MVVM(Model-View-ViewModel)**은 이러한 문제를 해결하고, **WPF의 고유한 강점(바인딩, 커맨드, 템플릿)을 최대한 활용할 수 있도록** 고안된 아키텍처 패턴입니다.

---

## MVVM 등장 배경

### 코드비하인드 중심 개발의 한계

- **낮은 응집도**: `Button_Click`, `SelectionChanged`와 같은 이벤트 핸들러 안에 **비즈니스 로직**과 **UI 처리 로직**이 뒤섞여 있어 코드의 복잡성을 증가시켰습니다.
- **재사용성과 테스트성 부족**: UI 프레임워크에 강하게 결합된 이벤트 흐름은 코드를 다른 환경에서 재사용하거나 **단위 테스트를 작성하기 매우 어렵게** 만들었습니다.
- **상태 관리의 어려움**: 화면의 다양한 상태(활성화/비활성화, 표시/숨김 등)를 제어하는 코드가 여러 이벤트 핸들러에 흩어져 있어 **사이드 이펙트를 추적하고 관리하기가 힘들었습니다**.
- **협업의 비효율**: 디자이너(XAML 작업)와 개발자(C# 로직)의 작업 경계가 모호해, **시각적 디자인을 변경하거나 리소스를 교체하는 것조차 많은 조정을 필요로 했습니다**.

### WPF의 강점을 살리지 못한 초기 개발 방식

WPF는 **데이터 바인딩**, **ICommand 커맨드 패턴**, **유연한 템플릿 시스템**과 같이 선언적이고 자동화된 UI 개발을 지원하는 뛰어난 기능들을 제공합니다. 그러나 초기 접근법은 이러한 기능들을 충분히 활용하지 못한 채, WinForms 시대의 명령형 이벤트 처리 방식에 머물러 있었습니다.

### 기존 패턴의 부족함과 MVVM의 적합성

기존의 MVC나 MVP 패턴도 데스크톱 앱에 적용될 수 있으나, WPF의 **양방향 데이터 바인딩**과 **리소스 기반의 동적 UI 구성**을 가장 자연스럽고 우아하게 수용할 수 있는 패턴이 필요했습니다. MVVM은 WPF/Silverlight의 데이터 바인딩 엔진과 깊이 연관되어 태어났으며, **뷰와 로직의 분리를 극대화**하는 데 목적을 두고 있습니다.

**결론적으로, MVVM은 WPF의 핵심 철학을 구현 수단으로 삼아, 테스트 가능하고 유지보수성이 높은 UI 애플리케이션을 구조화하기 위해 등장했습니다.**

---

## Model · View · ViewModel의 역할 분리

MVVM은 애플리케이션을 세 가지 명확한 계층으로 분리합니다.

```
사용자 ↔ View (표현) ↔ 데이터 바인딩 ↔ ViewModel (프레젠테이션 로직) ↔ Model (비즈니스 로직/데이터)
```

### 1. Model (데이터와 비즈니스 규칙)

*   **역할**: 애플리케이션의 **핵심 데이터와 비즈니스 로직**을 담당합니다.
*   **특징**:
    *   주로 도메인 엔티티, DTO(Data Transfer Object), 서비스, 리포지토리 등으로 구성됩니다.
    *   **UI나 프레젠테이션 로직에 대한 어떠한 참조도 없어야 합니다**. 순수한 C# 클래스로 유지하는 것이 이상적입니다.
    *   데이터의 유효성, 계산 규칙, 영속성 관련 로직을 포함합니다.
*   **예시**: `Customer`, `Product`, `Order`, `IOrderRepository`, `TaxCalculator` 등.

### 2. View (사용자 인터페이스)

*   **역할**: 사용자에게 정보를 **표시**하고, 사용자의 **입력을 받는** 역할만 수행합니다.
*   **특징**:
    *   XAML로 정의되며, 가능한 한 **코드비하인드를 최소화**합니다. 코드비하인드는 뷰 모델과의 연결이나 순수한 UI 애니메이션 등에만 제한적으로 사용합니다.
    *   **DataContext** 속성을 통해 ViewModel을 참조하고, **바인딩(Binding)**과 **커맨드(Command)**를 통해 ViewModel과 모든 상호작용을 합니다.
    *   **스타일(Style)**, **데이터 템플릿(DataTemplate)**, **컨트롤 템플릿(ControlTemplate)**을 통해 시각적 표현을 완전히 교체할 수 있는 유연성을 가집니다.

### 3. ViewModel (프레젠테이션 로직)

*   **역할**: **View를 위한 상태와 행동을 정의**합니다. View와 Model 사이의 **중개자** 역할을 합니다.
*   **특징**:
    *   **INotifyPropertyChanged** 인터페이스를 구현하여, 속성 값이 변경될 때 View에 자동으로 알릴 수 있게 합니다.
    *   **ICommand** 인터페이스를 구현한 커맨드 객체(예: `RelayCommand`)를 노출하여, View의 버튼 클릭 등의 동작을 처리합니다.
    *   Model의 데이터를 View에 표시하기 적합한 형태로 가공하거나 변환합니다.
    *   **View에 대한 참조를 절대 가지지 않습니다**. View가 어떤 특정 컨트롤인지 알지 못합니다.

**핵심 원칙:** View는 ViewModel을 알고 바인딩을 통해 소비하지만, ViewModel은 View의 존재를 알지 못합니다. 이 **단방향 의존성**이 테스트 가능성과 유연성을 보장합니다.

---

## 데이터 흐름과 상호작용

MVVM에서의 표준적인 데이터 흐름은 다음과 같습니다.

1.  **사용자 입력**: View에서 버튼을 클릭하거나 텍스트를 입력합니다.
2.  **커맨드 실행**: 해당 동작이 ViewModel의 `ICommand`(예: `RefreshCommand`)에 바인딩되어 있다면, 그 커맨드의 `Execute` 메서드가 호출됩니다.
3.  **비즈니스 로직 처리**: ViewModel은 필요한 서비스나 리포지토리(Model 계층)를 호출하여 데이터를 가져오거나 변경을 요청합니다.
4.  **상태 갱신**: 작업 결과로 ViewModel의 속성(예: `Orders` 컬렉션, `IsBusy` 플래그)이 업데이트됩니다. 이때 `INotifyPropertyChanged`를 통해 변경이 통지됩니다.
5.  **UI 자동 갱신**: View에 설정된 데이터 바인딩이 이 변경 통지를 받아, 자동으로 화면을 새로 고칩니다.

이 흐름은 이벤트 핸들러를 통한 수동 제어를 제거하고, 선언적이고 반응형인 패러다임으로 전환시킵니다.

---

## MVVM의 장점과 실천 시 주의사항

### 주요 장점
*   **명확한 관심사 분리**: 유지보수성과 협업 효율성이 크게 향상됩니다.
*   **향상된 테스트 가능성**: UI 프레임워크에 의존하지 않는 ViewModel 로직은 단위 테스트가 쉽습니다.
*   **디자이너-개발자 워크플로우 개선**: XAML과 C# 코드가 느슨하게 결합되어 병렬 작업이 용이합니다.
*   **뷰의 유연성**: 동일한 ViewModel에 여러 View를 바인딩하거나, DataTemplate을 교체하여 동적인 UI 변경이 가능합니다.

### 흔한 실수(안티패턴)와 해결책
*   **ViewModel에서 UI API 직접 호출**: `MessageBox.Show()`나 `NavigationService`를 직접 사용하면 테스트가 불가능해집니다.
    *   **해결**: `IDialogService`, `INavigationService` 같은 추상화된 서비스 인터페이스를 주입받아 사용합니다.
*   **과도하게 큰 ViewModel**: 하나의 ViewModel이 너무 많은 책임을 지면 유지보수가 힘듭니다.
    *   **해결**: 기능별로 **UserControl**과 **Child ViewModel**을 만들어 조합합니다.
*   **불필요한 양방향 바인딩**: 모든 바인딩을 `TwoWay`로 설정하면 데이터 흐름을 추적하기 어려워집니다.
    *   **해결**: 기본값(`OneWay` 또는 `OneTime`)을 사용하고, 정말 수정이 필요한 경우에만 `TwoWay`를 명시합니다.

---

## 결론

MVVM은 단순한 디자인 패턴을 넘어, WPF/Silverlight와 같은 현대적인 XAML 플랫폼의 **정신을 구현한 아키텍처**라고 볼 수 있습니다. 데이터 바인딩과 커맨드라는 강력한 도구를 활용해 뷰와 로직을 철저히 분리함으로써, **대규모이고 장기적으로 유지보수되어야 하는 엔터프라이즈 애플리케이션 개발**에 필수적인 **테스트 용이성, 코드 안정성, 팀 협업 효율성**을 제공합니다. 초기 학습 곡선이 있다는 점을 제외하면, WPF로 견고한 애플리케이션을 구축하기 위해 선택할 수 있는 가장 적합하고 체계적인 방법론입니다.