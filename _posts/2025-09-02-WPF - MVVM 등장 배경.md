---
layout: post
title: WPF - MVVM 등장 배경
date: 2025-09-02 14:25:23 +0900
category: WPF
---
# MVVM 등장 배경 / Model·View·ViewModel 역할 분리

WPF는 **XAML + 데이터 바인딩 + 의존 속성**이라는 강력한 기반을 갖고 있습니다. 하지만 초창기에는 WinForms처럼 **코드비하인드(이벤트 핸들러 중심)**로 UI 로직을 작성하는 경우가 많았고, 이 방식은 규모가 커질수록 유지보수가 어려워졌습니다. **MVVM(Model–View–ViewModel)**은 이러한 문제를 해결하기 위해 **WPF의 언어적 특성(바인딩·커맨드·템플릿)**을 최대한 활용하도록 고안된 아키텍처 패턴입니다.

---

## MVVM 등장 배경

### 코드비하인드 중심 개발의 한계

- **응집도 저하**: `Button_Click`, `SelectionChanged` 같은 이벤트 핸들러가 **비즈니스 로직**과 **UI 처리**를 뒤섞음.
- **재사용성·테스트성 부족**: 이벤트 흐름이 UI 프레임워크에 강하게 결합되어 **단위 테스트가 어려움**.
- **상태 추적 난이도**: 화면 상태(Enable/Disable, Visible/Collapsed 등) 제어가 이벤트 곳곳에 흩어져 **사이드 이펙트** 증가.
- **확장/디자인 협업 어려움**: 디자이너(XAML)와 개발자(C#)의 **작업 경계가 모호**해 **시각적 리소스 교체**도 부담.

### WPF 고유 특성의 미활용

- **데이터 바인딩**: `INotifyPropertyChanged`, `ObservableCollection<T>` 기반의 **자동 UI 동기화**가 있음에도 수동 갱신.
- **Commands**: `ICommand`로 입력 제스처·단축키와 동작을 연결할 수 있는데 이벤트만 사용.
- **DataTemplate/ControlTemplate**: 데이터-표현 분리를 통한 **스킨 교체**가 용이한데, 로직과 뷰가 강결합이면 장점 반감.

### 기존 패턴의 한계와 MVVM의 필요

- **MVC/MVP**: 데스크톱·XAML 환경에서 **양방향 바인딩**과 **템플릿 구성**을 자연스럽게 녹이기에는 번거로움.
- **MVU(Model–View–Update)**: 선언형 렌더 사이클에 강점(예: Elm/React)이나 WPF의 **Retained-mode + 템플릿/바인딩** 생태와는 결이 다름.

> **결론:** MVVM은 WPF의 **바인딩·커맨드·템플릿** 철학을 최대화하여 **테스트 가능한 UI**와 **깨끗한 분리**를 제공하기 위해 등장했습니다.

---

## Model · View · ViewModel 역할 분리

아래는 가장 널리 쓰이는 역할 정의입니다.

```
사용자 ↔ View(XAML) ↔ Binding/Command ↔ ViewModel(C#) ↔ Service/Repository ↔ Model/Domain
```

### Model (도메인/엔티티/DTO)

- **무엇을 표현하는가(데이터·규칙)**에 집중.
- **도메인 로직**(불변식, 계산), **영속 모델(Entity)**, 또는 단순 **DTO**를 포함.
- UI 프레임워크에 **비의존**이어야 함. (가능하면 `INotifyPropertyChanged`도 배제하고 순수 객체로 유지)
- 예: `Order`, `Customer`, `Product`, `PriceCalculator`, `IOrderRepository`.

```csharp
public sealed class Order
{
    public string Id { get; }
    public DateTime PlacedAt { get; }
    public IReadOnlyList<OrderLine> Lines { get; }

    public decimal Total => Lines.Sum(l => l.UnitPrice * l.Quantity);

    public Order(string id, DateTime placedAt, IEnumerable<OrderLine> lines)
    {
        Id = id; PlacedAt = placedAt; Lines = lines.ToList().AsReadOnly();
    }
}
```

### View (XAML)

- **보여주는 역할**만 수행. **로직 최소화**(코드비하인드는 ViewModel 연결·특수 UI 상호작용 정도).
- **DataTemplate/ControlTemplate/Style/Resource**로 **표현/스킨**을 교체 가능.
- **DataContext**를 통해 ViewModel과 연결. **명령(Commands)**, **바인딩**으로 상호작용.

```xml
<Window ...>
  <Window.DataContext>
    <vm:OrdersViewModel/>
  </Window.DataContext>

  <Grid>
    <ListView ItemsSource="{Binding Orders}">
      <ListView.View>
        <GridView>
          <GridViewColumn Header="Id" DisplayMemberBinding="{Binding Id}"/>
          <GridViewColumn Header="Total" DisplayMemberBinding="{Binding Total, StringFormat={}{0:C}}"/>
        </GridView>
      </ListView.View>
    </ListView>

    <Button Content="새로고침"
            Command="{Binding RefreshCommand}"
            HorizontalAlignment="Right" VerticalAlignment="Bottom" />
  </Grid>
</Window>
```

### ViewModel (프레젠테이션 로직)

- View의 **상태/행동을 추상화**한 **프레젠테이션 모델**.
- **INotifyPropertyChanged** 구현으로 **UI 자동 갱신**.
- **ICommand**(예: RelayCommand)로 **동작**을 노출(버튼·단축키·제스처와 연결).
- **Service/Repository**에 의존해 Model을 **조회·수정**, 그 결과를 **View에 적합한 형태**로 가공.
- **UI 타입(Brush, Visibility 등) 의존 최소화**가 바람직. 필요 시 변환기는 **Converter**로 분리.

```csharp
public sealed class OrdersViewModel : INotifyPropertyChanged
{
    private readonly IOrderService _service;
    public ObservableCollection<Order> Orders { get; } = new();

    public ICommand RefreshCommand { get; }

    private bool _isBusy;
    public bool IsBusy { get => _isBusy; private set { _isBusy = value; OnChanged(); } }

    public OrdersViewModel(IOrderService service)
    {
        _service = service;
        RefreshCommand = new RelayCommand(async _ => await RefreshAsync(), _ => !IsBusy);
    }

    private async Task RefreshAsync()
    {
        try
        {
            IsBusy = true;
            var items = await _service.GetRecentOrdersAsync();
            Orders.Clear();
            foreach (var x in items) Orders.Add(x);
        }
        finally
        {
            IsBusy = false;
            (RefreshCommand as RelayCommand)?.RaiseCanExecuteChanged();
        }
    }

    public event PropertyChangedEventHandler? PropertyChanged;
    private void OnChanged([System.Runtime.CompilerServices.CallerMemberName] string? n = null)
        => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(n));
}

public sealed class RelayCommand : ICommand
{
    private readonly Func<object?, Task>? _execAsync;
    private readonly Predicate<object?>? _can;
    public RelayCommand(Func<object?, Task> execAsync, Predicate<object?>? can = null)
    { _execAsync = execAsync; _can = can; }

    public bool CanExecute(object? p) => _can?.Invoke(p) ?? true;
    public async void Execute(object? p) => await (_execAsync?.Invoke(p) ?? Task.CompletedTask);
    public event EventHandler? CanExecuteChanged;
    public void RaiseCanExecuteChanged() => CanExecuteChanged?.Invoke(this, EventArgs.Empty);
}
```

> **핵심:** ViewModel은 **뷰를 모름**(UI 타입·컨트롤 직접 접근 금지), 뷰는 **바인딩/커맨드**로만 ViewModel을 호출.

---

## 데이터 흐름과 상호작용

### 표준 흐름

1. **사용자 입력**(클릭/키 입력/제스처) → View의 **Command 바인딩** 발화
2. ViewModel의 **Command.Execute** 실행 → **Service/Repository** 호출
3. 결과로 **Model** 변경 → ViewModel의 **속성 갱신**(`INPC`)
4. **Data Binding**이 변화를 캐치 → View가 자동으로 갱신 렌더

```
User → View(XAML)
   └─ Command/Binding → ViewModel
          └─ Service/Repository → Model
                ↘ (result) ViewModel.Property set (INPC)
                       ↘ Binding → View 업데이트
```

### 상태 제어(Enable/Disable 등)

- 버튼 활성화/비활성: **CanExecute**(ICommand)로 제어 → View에서 자동 반영.
- 로딩 스피너/오버레이: ViewModel의 `IsBusy` → **DataTrigger/Converter**로 스타일 제어.

---

## 경계 설계와 안티패턴

### 경계 원칙

- **View ↔ ViewModel**: **DataContext**와 **Binding/Command**만 통신.
- **ViewModel ↔ Model/Service**: 순수 .NET 인터페이스로 의존(테스트 가능).
- **ViewModel ↔ UI 타입 분리**: `Visibility/Brush` 등은 Converter/State Mapper를 활용해 최소화.

### 자주 보는 실수(안티패턴)

- ViewModel에 `MessageBox.Show` 같은 **UI API 호출** 넣기 → **테스트 불가/플랫폼 종속**.
  - 해결: **DialogService 인터페이스**로 추상화하여 주입.
- ViewModel에서 **Dispatcher 직접 호출 남발** → 비동기/스케줄링을 **서비스·헬퍼**로 캡슐화.
- **거대한 ViewModel**(수백/수천 LOC) → 화면 기능별 **Child VM**으로 쪼개고 **DataTemplate**로 합성.
- **양방향 바인딩 남발** → 필요한 곳만 TwoWay, 나머지는 OneWay/OneTime.

---

## DI(의존성 주입)과 MVVM

WPF도 **Generic Host**로 DI/로깅/구성을 사용할 수 있습니다.

```csharp
// App.xaml.cs
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

public partial class App : Application
{
    private IHost? _host;
    protected override void OnStartup(StartupEventArgs e)
    {
        base.OnStartup(e);
        _host = Host.CreateDefaultBuilder(e.Args)
            .ConfigureServices(s =>
            {
                s.AddSingleton<IOrderService, OrderService>();
                s.AddTransient<OrdersViewModel>();
                s.AddTransient<Views.MainWindow>();
            }).Build();

        var win = _host.Services.GetRequiredService<Views.MainWindow>();
        win.DataContext = _host.Services.GetRequiredService<OrdersViewModel>();
        win.Show();
    }
}
```

> 이 방식으로 **ViewModel의 외부 의존성**을 자연스럽게 주입하고, **단위 테스트**에서 **목(mock)**으로 대체가 쉬워집니다.

---

## 테스트 용이성

ViewModel은 UI 프레임워크에 비의존이므로 **순수 단위 테스트**가 가능합니다.

```csharp
[Fact]
public async Task RefreshCommand_LoadsOrders()
{
    var fake = A.Fake<IOrderService>();
    A.CallTo(() => fake.GetRecentOrdersAsync())
        .Returns(Task.FromResult<IEnumerable<Order>>(new[] { new Order("1", DateTime.UtcNow, Array.Empty<OrderLine>()) }));

    var vm = new OrdersViewModel(fake);
    await Task.Run(() => vm.RefreshCommand.Execute(null));

    Assert.Single(vm.Orders);
}
```

---

## MVVM을 더 강력하게 만드는 도구

- **CommunityToolkit.Mvvm**: `ObservableObject`, `RelayCommand`, `[ObservableProperty]` 등 보일러플레이트 제거
- **Prism**: 모듈러 구조, Region Navigation, Dialog Service, EventAggregator
- **ReactiveUI**: 반응형 바인딩, 상태 선언적 모델링

> 프레임워크 채택 여부와 무관하게 **역할 분리 원칙**은 동일합니다.

---

## 요약: 왜 MVVM인가?

- **분리**: UI(XAML)와 로직(C#)의 명확한 분리 → 유지보수/협업 ↑
- **테스트**: ViewModel을 순수 코드로 테스트 가능 → 품질 ↑
- **재사용/테마**: DataTemplate/Style로 **표현 교체** 쉬움 → 디자인 자유도 ↑
- **WPF 친화**: 바인딩·커맨드·템플릿을 **언어 차원에서 최대 활용**

MVVM은 **WPF의 핵심 능력치**(바인딩·커맨드·템플릿)를 **아키텍처 차원**에서 끌어내어,
**대규모·장수 프로젝트**에서도 **안정적이고 테스트 가능한 UI**를 구축하도록 돕습니다.
