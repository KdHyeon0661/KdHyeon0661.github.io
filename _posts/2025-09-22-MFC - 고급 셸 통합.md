---
layout: post
title: MFC - 고급 셸 통합
date: 2025-09-22 20:25:23 +0900
category: MFC
---
# 고급 셸 통합 완전 가이드  
**IFileDialog 커스터마이즈(장치/항목 필터·커스텀 컨트롤·프리뷰 연동), 썸네일/프리뷰 제공자, 검색(인덱서) 핸들러**

> 목표: “**파일 열기/저장 대화상자를 내 워크플로에 맞게 확장**하고, **탐색기/검색**과 **자연스럽게 통합**되는 고급 확장(Thumbnail/Preview/Filter/Protocol)을 만든다.”

본 문서는 Win32/C++(COM) 기준입니다. 모든 코드는 **UNICODE(UTF-16)** 가정.  
각 섹션은 **개념 → 실무 체크리스트 → 최소 예제 코드 → 등록(레지스트리/WiX)** 순으로 구성합니다.

---

## 0) 큰 그림 맵

- **IFileDialog 계열 (Vista+)**
  - `IFileOpenDialog`/`IFileSaveDialog` + `IFileDialogCustomize`(컨트롤 추가)
  - `IFileDialogEvents::OnIncludeItem` **항목 필터**(디렉터리/장치/확장자/속성)  
  - `IShellItemFilter`(구형/특정 경로 제어에 유용)  
  - **프리뷰**: 대화상자 내부에 임의 HWND **직접 삽입은 불가** →  
    - (A) **대화상자 옆**에 *자체* 프리뷰 창을 떠서 `OnSelectionChange`로 업데이트  
    - (B) 사용자가 **탐색기 “미리 보기 창”**을 켠 상태면 **Preview Handler**가 자동 수행(확장 구현 시)  
  - `IFileDialogControlEvents` 로 컨트롤과 대화상자 간 상호작용

- **썸네일 / 프리뷰 제공자**
  - **썸네일**: `IThumbnailProvider`(+ `IInitializeWithStream/File/Item`) → 탐색기 **아이콘/썸네일**  
  - **프리뷰**: `IPreviewHandler`(+ `IInitializeWithStream/File/Item`) → 탐색기 **미리 보기 창**  
  - **등록**: 해당 확장자(`.foo`)의 `ShellEx` 키에 **GUID별 카테고리 등록**  
    - 썸네일: `{e357fccd-a995-4576-b01f-234630154e96}`  
    - 프리뷰:  `{8895b1c6-b41f-4c1c-a562-0d564250836f}`

- **검색 핸들러(Windows Search)**
  - **파일 포맷** 인덱싱: `IFilter`(텍스트/속성 추출) 또는 **Property Handler**(`IPropertyStore`)  
  - **스토어(프로토콜)** 인덱싱: `IProtocolHandler` / `IUrlAccessor` 로 **커스텀 저장소** 노출  
  - **등록**: Windows Search 레지스트리(프로토콜/필터/속성 스키마)

---

# 1. IFileDialog 커스터마이즈

## 1.1 필수 개념

- **생성**: `CoCreateInstance(CLSID_FileOpenDialog / CLSID_FileSaveDialog)`  
- **옵션**: `IFileDialog::SetOptions(FOS_...)` (예: `FOS_FORCEFILESYSTEM`, `FOS_PATHMUSTEXIST`)  
- **이벤트 연결**: `IFileDialog::Advise(IFileDialogEvents*, &cookie)`  
  - `OnFileOk`, `OnSelectionChange`, `OnFolderChanging/Change`, `OnTypeChange`, `OnIncludeItem` 등  
- **커스터마이즈 컨트롤**: `IFileDialogCustomize`  
  - 텍스트/체크박스/콤보/라디오/에디트/그룹/푸시 버튼 추가  
  - 컨트롤 이벤트: `IFileDialogControlEvents`

> **주의**: Common Item Dialog는 “*내부 레이아웃 영역*” 안에 **임의 HWND 삽입**을 지원하지 않습니다.  
> 자체 프리뷰를 원하면 **별도의 WS_POPUP/TOOLWINDOW**를 만들어 **대화상자와 나란히** 배치하고 `OnSelectionChange` 시 업데이트 하세요.

---

## 1.2 장치/항목 필터링

### 선택 1) `OnIncludeItem`로 필터링(권장)
- 대화상자가 **표시할 항목을 나에게 묻는** 콜백
- **장치**(예: 리무터블/네트워크 드라이브) 거르기, **확장자/속성** 기반 필터 가능

```cpp
class FileDlgEvents final : public IFileDialogEvents, public IFileDialogControlEvents {
    ULONG m_ref = 1;
public:
    // IUnknown
    IFACEMETHODIMP QueryInterface(REFIID riid, void** ppv) override {
        if (!ppv) return E_POINTER;
        if (riid==__uuidof(IUnknown) || riid==__uuidof(IFileDialogEvents)) {
            *ppv = static_cast<IFileDialogEvents*>(this);
        } else if (riid==__uuidof(IFileDialogControlEvents)) {
            *ppv = static_cast<IFileDialogControlEvents*>(this);
        } else { *ppv=nullptr; return E_NOINTERFACE; }
        AddRef(); return S_OK;
    }
    IFACEMETHODIMP_(ULONG) AddRef() override { return ++m_ref; }
    IFACEMETHODIMP_(ULONG) Release() override { auto r=--m_ref; if(!r) delete this; return r; }

    // ─ IFileDialogEvents ─
    IFACEMETHODIMP OnIncludeItem(IFileDialog* pfd, IShellItem* psi) override {
        // 예: 특정 드라이브 타입/확장자를 거른다
        SFGAOF attrs = 0;
        psi->GetAttributes(SFGAO_STREAM | SFGAO_FOLDER | SFGAO_FILESYSTEM, &attrs);

        // 폴더/파일 시스템만 허용
        if (!(attrs & SFGAO_FILESYSTEM)) return S_FALSE;

        // 드라이브 타입 필터(리무버블/네트워크 제외)
        wil::unique_cotaskmem_string pszPath;
        if (SUCCEEDED(psi->GetDisplayName(SIGDN_FILESYSPATH, &pszPath)) && pszPath) {
            UINT type = GetDriveTypeW((std::wstring(pszPath).substr(0,3)).c_str());
            if (type == DRIVE_REMOVABLE || type == DRIVE_REMOTE) {
                return S_FALSE; // 목록에서 제외
            }
            // 확장자 필터 (.log만)
            if ((attrs & SFGAO_STREAM)) {
                auto ext = std::filesystem::path(pszPath.get()).extension().wstring();
                if (_wcsicmp(ext.c_str(), L".log") != 0) return S_FALSE;
            }
        }
        return S_OK; // 포함
    }

    // 나머지 이벤트는 필요 시 구현
    IFACEMETHODIMP OnFileOk(IFileDialog*) override { return S_OK; }
    IFACEMETHODIMP OnSelectionChange(IFileDialog*) override { return S_OK; }
    IFACEMETHODIMP OnFolderChanging(IFileDialog*, IShellItem*) override { return S_OK; }
    IFACEMETHODIMP OnFolderChange(IFileDialog*) override { return S_OK; }
    IFACEMETHODIMP OnTypeChange(IFileDialog*) override { return S_OK; }
    IFACEMETHODIMP OnOverwrite(IFileDialog*, IShellItem*, FDE_OVERWRITE_RESPONSE*) override { return S_OK; }
    IFACEMETHODIMP OnShareViolation(IFileDialog*, IShellItem*, FDE_SHAREVIOLATION_RESPONSE*) override { return S_OK; }

    // ─ IFileDialogControlEvents ─ (컨트롤 변화 대응)
    IFACEMETHODIMP OnItemSelected(IFileDialogCustomize*, DWORD, DWORD) override { return S_OK; }
    IFACEMETHODIMP OnButtonClicked(IFileDialogCustomize*, DWORD) override { return S_OK; }
    IFACEMETHODIMP OnCheckButtonToggled(IFileDialogCustomize*, DWORD, BOOL) override { return S_OK; }
    IFACEMETHODIMP OnControlActivating(IFileDialogCustomize*, DWORD) override { return S_OK; }
};
```

### 선택 2) `IShellItemFilter` 제공(보조)
- 특정 루트에서 **하위 항목만** 제어하고 싶을 때 유용
- `IFileDialog::SetFolder` / `SetDefaultFolder` 와 함께 사용

```cpp
class DirFilter : public IShellItemFilter {
    ULONG m_ref=1;
public:
    IFACEMETHODIMP QueryInterface(REFIID riid, void** ppv) override { /*...*/ }
    IFACEMETHODIMP_(ULONG) AddRef() override { return ++m_ref; }
    IFACEMETHODIMP_(ULONG) Release() override { auto r=--m_ref; if(!r) delete this; return r; }

    // 특정 항목 허용 여부
    IFACEMETHODIMP IncludeItem(IShellItem* psi) override {
        wil::unique_cotaskmem_string path;
        if (SUCCEEDED(psi->GetDisplayName(SIGDN_FILESYSPATH, &path)) && path) {
            // 예: 숨김/시스템 제외
            DWORD attr = GetFileAttributesW(path.get());
            if (attr != INVALID_FILE_ATTRIBUTES && (attr & (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM)))
                return S_FALSE;
        }
        return S_OK;
    }
    // 하위 폴더 계속 열 수 있는지
    IFACEMETHODIMP GetEnumFlagsForItem(IShellItem*, SHCONTF* pgrfFlags) override {
        *pgrfFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
        return S_OK;
    }
};
```

> **실무 팁**  
> - 필터는 **사용자 관성**을 해치지 않는 선에서: “보이지 않게”가 UX를 깨면, “**보이되 선택만 제한**(Validate)” 도 고려하세요.  
> - 네트워크 드라이브/가상 폴더는 `SIGDN_DESKTOPABSOLUTEPARSING`으로 **파싱 이름** 확인이 더 정확.

---

## 1.3 커스텀 컨트롤(파일 대화상자 내부 UI 확장)

가능한 컨트롤:
- **텍스트**(정적), **체크박스**, **라디오 리스트**, **콤보박스**, **에디트**, **푸시 버튼**  
- **StartVisualGroup / EndVisualGroup**로 그룹핑, **MakeProminent**로 강조

```cpp
// 컨트롤 ID는 앱 정의(고유)
enum : DWORD {
    CID_GROUP      = 1000,
    CID_FMT_LABEL  = 1001,
    CID_FMT_COMBO  = 1002,
    CID_PREVIEW_CB = 1003,
    CID_APPLY_BTN  = 1004,
};

void AddCustomControls(IFileDialog* pfd) {
    wil::com_ptr<IFileDialogCustomize> ui;
    if (SUCCEEDED(pfd->QueryInterface(IID_PPV_ARGS(&ui)))) {
        ui->StartVisualGroup(CID_GROUP, L"옵션");
        ui->AddText(CID_FMT_LABEL, L"포맷:");
        ui->AddComboBox(CID_FMT_COMBO);
        ui->AddControlItem(CID_FMT_COMBO, 1, L"PNG");
        ui->AddControlItem(CID_FMT_COMBO, 2, L"JPEG");
        ui->AddCheckButton(CID_PREVIEW_CB, L"선택시 미리보기 표시", TRUE);
        ui->EndVisualGroup();
        ui->AddPushButton(CID_APPLY_BTN, L"적용(&A)");
        ui->MakeProminent(CID_APPLY_BTN);
    }
}
```

### 컨트롤 이벤트
```cpp
IFACEMETHODIMP FileDlgEvents::OnButtonClicked(IFileDialogCustomize* ui, DWORD cid) {
    if (cid == CID_APPLY_BTN) {
        // 현재 선택 항목/포맷 읽어 후처리
        DWORD selId = 0;
        ui->GetSelectedControlItem(CID_FMT_COMBO, &selId);
        // ... 설정 저장
    }
    return S_OK;
}
```

---

## 1.4 프리뷰 연동 패턴

### 방법 A) **외부 프리뷰 창**(권장·단순)
1) 대화상자 띄우기 전에 **우측에 작은 프리뷰 툴창** 생성(WS_EX_TOOLWINDOW | WS_EX_TOPMOST 선택)  
2) `OnSelectionChange` 에서 `IShellItem` → 경로/스트림 얻음 → **자체 렌더**  
3) 대화상자 이동/크기 변경 시 **동일한 좌표로 붙여 이동**

```cpp
IFACEMETHODIMP FileDlgEvents::OnSelectionChange(IFileDialog* pfd) {
    wil::com_ptr<IShellItem> psi;
    if (SUCCEEDED(pfd->GetResult(&psi)) || SUCCEEDED(pfd->GetCurrentSelection(&psi))) {
        wil::unique_cotaskmem_string path;
        if (SUCCEEDED(psi->GetDisplayName(SIGDN_FILESYSPATH, &path)) && path) {
            PostMessageW(g_hPreviewWnd, WM_APP+1, 0, (LPARAM)_wcsdup(path.get())); // 미리보기 창으로 전달
        }
    }
    return S_OK;
}
```

### 방법 B) **미리 보기 창(탐색기) 활용**
- 사용자가 **파일 대화상자의 “미리 보기 창”** 을 켜면, **해당 확장자의 Preview Handler** 가 자동 실행  
- 별도 코드 없이 **미리보기 구현체(IPreviewHandler)** 를 앱에서 제공하면 동일 경험

> **정리**: Dialog 내부 삽입은 불가 → **A/B 중 선택**.  
> A는 **앱 제어/일관 UI** 장점. B는 탐색기/파일열기에서 **재사용** 장점.

---

## 1.5 통합 예: 완전한 Open Dialog 구성

```cpp
bool ShowOpenWithFilters(HWND owner, std::wstring& outPath) {
    wil::com_ptr<IFileOpenDialog> dlg;
    RETURN_IF_FAILED(CoCreateInstance(CLSID_FileOpenDialog, nullptr, CLSCTX_INPROC_SERVER,
                                      IID_PPV_ARGS(&dlg)));

    DWORD opts = 0;
    dlg->GetOptions(&opts);
    dlg->SetOptions(opts | FOS_FORCEFILESYSTEM | FOS_FILEMUSTEXIST | FOS_PATHMUSTEXIST);

    // 파일 타입 필터 (표시용)
    COMDLG_FILTERSPEC specs[] = {
        { L"로그 파일 (*.log)", L"*.log" },
        { L"모든 파일 (*.*)",   L"*.*"   },
    };
    dlg->SetFileTypes(_countof(specs), specs);
    dlg->SetFileTypeIndex(1);

    // 커스텀 컨트롤
    AddCustomControls(dlg.get());

    // 이벤트
    auto* ev = new FileDlgEvents();
    DWORD cookie=0; dlg->Advise(ev, &cookie);

    // (선택) 기본 폴더/루트 설정
    // dlg->SetFolder( ... ); dlg->SetDefaultFolder( ... );

    HRESULT hr = dlg->Show(owner);
    dlg->Unadvise(cookie);
    ev->Release();
    if (FAILED(hr)) return false;

    wil::com_ptr<IShellItem> psi;
    RETURN_IF_FAILED(dlg->GetResult(&psi));
    wil::unique_cotaskmem_string path;
    RETURN_IF_FAILED(psi->GetDisplayName(SIGDN_FILESYSPATH, &path));
    outPath = path.get();
    return true;
}
```

---

# 2. 썸네일(Thumbnail) 제공자

## 2.1 개념
- 탐색기/열기 대화상자/공용 선택 UI에서 **아이콘+썸네일**을 그릴 때 호출
- 인터페이스: **`IThumbnailProvider`**  
- 초기화: `IInitializeWithStream`(권장) / `IInitializeWithFile` / `IInitializeWithItem`
- 반환: **`HBITMAP`**(알파 포함) 또는 `ISharedBitmap`

## 2.2 체크리스트
- **빠름**: 32/64/96/256px 등 요청 크기에 맞춰 **최소 연산**  
- **캐시**: 음수 결과(“시각화 불가”)도 캐시  
- **알파**: 32bpp BGRA, **premultiplied alpha** 권장

## 2.3 최소 구현(스트림 기반)
```cpp
class ATL_NO_VTABLE CThumbFoo :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CThumbFoo, &CLSID_ThumbFoo>,
    public IThumbnailProvider,
    public IInitializeWithStream
{
    wil::com_ptr<IStream> m_stream;

public:
    BEGIN_COM_MAP(CThumbFoo)
        COM_INTERFACE_ENTRY(IInitializeWithStream)
        COM_INTERFACE_ENTRY(IThumbnailProvider)
    END_COM_MAP()

    // IInitializeWithStream
    IFACEMETHODIMP Initialize(IStream* pStream, DWORD) override {
        m_stream = pStream; return S_OK;
    }

    // IThumbnailProvider
    IFACEMETHODIMP GetThumbnail(UINT cx, HBITMAP* phbmp, WTS_ALPHATYPE* pdwAlpha) override {
        // 1) m_stream에서 헤더/내용 읽기
        // 2) cx에 맞춰 렌더(HBITMAP 생성)
        // 예시는 GDI+로 PNG 생성 후 HBITMAP 추출
        Gdiplus::Bitmap* bmp = RenderPreviewFromStream(m_stream.get(), cx);
        if (!bmp) return E_FAIL;
        bmp->GetHBITMAP(Gdiplus::Color(0,0,0,0), phbmp);
        delete bmp;
        *pdwAlpha = WTSAT_ARGB;
        return S_OK;
    }
};
OBJECT_ENTRY_AUTO(CLSID_ThumbFoo, CThumbFoo)
```

## 2.4 등록(레지스트리)
- 키: `HKCR\.foo\ShellEx\{e357fccd-a995-4576-b01f-234630154e96}` = `CLSID_ThumbFoo`
- COM 서버(인프로크) 등록 필요

**WiX 예시**
```xml
<!-- Thumbnail Handler 등록 -->
<Component Id="cmpThumbFoo" Guid="*" >
  <RegistryValue Root="HKCR" Key=".foo\ShellEx\{e357fccd-a995-4576-b01f-234630154e96}"
                 Value="{YOUR-CLSID-HERE}" Type="string" Action="write"/>
  <ProgId Id="FooFile" Description="Foo Document"/>
  <!-- COM CLSID 등록(typelib/ThreadingModel=Both 권장) -->
</Component>
```

---

# 3. 프리뷰(Preview) 제공자

## 3.1 개념
- 탐색기/파일 대화상자의 **미리 보기 창**에서 컨텐츠 **읽기·렌더**
- 인터페이스: **`IPreviewHandler`** + `IInitializeWithStream`(권장)
- 호스트가 SetWindow로 **컨테이너 HWND**를 줌 → 여기에 **직접 그린다**

## 3.2 최소 구현
```cpp
class ATL_NO_VTABLE CPreviewFoo :
  public CComObjectRootEx<CComMultiThreadModel>,
  public CComCoClass<CPreviewFoo, &CLSID_PreviewFoo>,
  public IPreviewHandler,
  public IInitializeWithStream
{
    HWND m_hwndParent = nullptr;
    RECT m_rc{};
    wil::com_ptr<IStream> m_stream;

public:
    BEGIN_COM_MAP(CPreviewFoo)
        COM_INTERFACE_ENTRY(IInitializeWithStream)
        COM_INTERFACE_ENTRY(IPreviewHandler)
    END_COM_MAP()

    // IInitializeWithStream
    IFACEMETHODIMP Initialize(IStream* pStream, DWORD) override {
        m_stream = pStream; return S_OK;
    }

    // IPreviewHandler
    IFACEMETHODIMP SetWindow(HWND hwnd, const RECT* prc) override {
        m_hwndParent = hwnd; m_rc = *prc; return S_OK;
    }
    IFACEMETHODIMP SetRect(const RECT* prc) override { m_rc = *prc; return S_OK; }
    IFACEMETHODIMP DoPreview() override {
        // 1) m_stream 내용을 파싱
        // 2) m_hwndParent 영역(m_rc)에 GDI/GDI+/D2D로 렌더
        //    (호스트가 WM_PAINT 유발 시 다시 그려야 하므로 자식 창 생성 권장)
        return S_OK;
    }
    IFACEMETHODIMP Unload() override { m_stream.reset(); return S_OK; }
    IFACEMETHODIMP SetFocus() override { return S_OK; }
    IFACEMETHODIMP QueryFocus(HWND* phwnd) override { *phwnd = m_hwndParent; return S_OK; }
    IFACEMETHODIMP TranslateAccelerator(MSG*) override { return S_FALSE; }
};
OBJECT_ENTRY_AUTO(CLSID_PreviewFoo, CPreviewFoo)
```

## 3.3 등록
- 키: `HKCR\.foo\ShellEx\{8895b1c6-b41f-4c1c-a562-0d564250836f}` = `CLSID_PreviewFoo`
- COM 서버 등록(32/64bit 각각)

---

# 4. 검색 핸들러

Windows Search(인덱서) 통합은 크게 **세 계층**으로 나눕니다.

1) **IFilter**: 파일 **본문 텍스트/속성 추출**(PDF, DOCX 등과 유사)  
2) **Property Handler(IPropertyStore)**: **속성 시스템**에 노출(메타데이터 읽기/쓰기)  
3) **Protocol Handler**: 파일시스템이 아닌 **커스텀 저장소**(DB/클라우드/암호화 컨테이너)를 **가상 URL** 로 인덱싱

## 4.1 IFilter (콘텐츠 인덱싱)

### 개념
- 인덱서는 파일을 열고 **IFilter**를 호출하여 **텍스트 청크/속성**을 순차적으로 읽음
- 구현: `IFilter::Init` → `GetChunk`(다음 블록) → `GetText`/`GetValue` 반복

### 최소 스켈레톤
```cpp
class ATL_NO_VTABLE CFilterFoo :
  public CComObjectRootEx<CComMultiThreadModel>,
  public CComCoClass<CFilterFoo, &CLSID_FilterFoo>,
  public IFilter
{
    // 내부 파서 상태…
public:
    BEGIN_COM_MAP(CFilterFoo)
        COM_INTERFACE_ENTRY(IFilter)
    END_COM_MAP()

    IFACEMETHODIMP Init(ULONG grfFlags, ULONG cAttributes, FULLPROPSPEC const*, ULONG* pdwFlags) override {
        *pdwFlags = IFILTER_INIT_CANON_PARAGRAPHS | IFILTER_INIT_APPLY_INDEX_ATTRIBUTES;
        // 파서 준비
        return S_OK;
    }
    IFACEMETHODIMP GetChunk(STAT_CHUNK* pStat) override {
        // 다음 청크 메타(텍스트/속성/언어ID/BreakType)
        // 더 없으면 FILTER_E_END_OF_CHUNKS
        return FILTER_E_END_OF_CHUNKS;
    }
    IFACEMETHODIMP GetText(ULONG* pcwcBuffer, WCHAR* awcBuffer) override {
        // 현재 청크 텍스트 채움, 더 없으면 FILTER_E_NO_TEXT
        return FILTER_E_NO_TEXT;
    }
    IFACEMETHODIMP GetValue(PROPVARIANT** ppPropVal) override {
        return FILTER_E_NO_VALUES;
    }
    IFACEMETHODIMP BindRegion(FILTERREGION, REFIID, void**) override { return E_NOTIMPL; }
};
OBJECT_ENTRY_AUTO(CLSID_FilterFoo, CFilterFoo)
```

### 등록
- 확장자 → **PersistentHandler** 지정 → 그 핸들러 키에 **IFilter** CLSID 등록
```
HKCR
 └─ .foo
     └─ PersistentHandler = "{CLSID_PERSIST_FOO}"
HKCR
 └─ CLSID\{CLSID_PERSIST_FOO}
     └─ PersistentAddinsRegistered
         └─ {89BCB740-6119-101A-BCB7-00DD010655AF} (IFilter)
             (Default) = "{CLSID_FilterFoo}"
```

> **테스트**: `control.exe srchadmin.dll` → 고급 → 다시 인덱싱 / `powercfg /requests` 로 진행 확인,  
> `SearchIndexer.exe`의 로드/충돌은 Application 로그 참고.

---

## 4.2 Property Handler (속성 시스템)

- 인터페이스: `IPropertyStore`(+ `IInitializeWithStream/File/Item`)  
- 역할: `.foo`의 메타데이터(제목/태그/작성자 등)를 **읽기/쓰기**로 노출  
- 등록: `HKCR\.foo\ShellEx\{e357fccd-a995-4576-b01f-234630154e96}` 은 썸네일,  
  속성 핸들러는 **다른 GUID**(PropertyHandler Category) → `IPropertyStore` CLSID 등록

> 속성 정의는 **.propdesc XML** 로 커스텀 가능(정렬/표시/검색 가중치)

---

## 4.3 Protocol Handler (커스텀 저장소 인덱싱)

### 개념
- 예: `mycloud://item/1234` 같은 **가상 URL** 공간을 인덱서에 제공  
- 인덱서는 `IProtocolHandler`를 통해 **크롤링** → 각 항목별 **IUrlAccessor** 로 스트림/속성 획득

### 스켈레톤
```cpp
// Protocol Factory
class ATL_NO_VTABLE CProtoFoo :
  public CComObjectRootEx<CComMultiThreadModel>,
  public CComCoClass<CProtoFoo, &CLSID_ProtoFoo>,
  public IProtocolHandler
{
public:
    BEGIN_COM_MAP(CProtoFoo)
      COM_INTERFACE_ENTRY(IProtocolHandler)
    END_COM_MAP()

    IFACEMETHODIMP Start(LPCWSTR pcwszURL, IProtocolSink* pSink, IInternetBindInfo*, DWORD) override {
        // mycloud://item/1234 파싱, pSink->ReportData, ReportResult
        return S_OK;
    }
    IFACEMETHODIMP Stop() override { return S_OK; }
    // Windows Search는 UrlAccessor 기반을 더 자주 씀(Windows Search SDK 참조)
};
```

### 등록
```
HKLM\Software\Microsoft\Windows Search\ProtocolHandlers\mycloud
  (Default) = "{CLSID_ProtoFoo}"
```
- **보안/격리**: 인덱서는 서비스로 동작. **네트워크/자격 증명** 설계 필요  
- **대안**: 파일시스템 **가상 드라이브(Cloud Files/CF API)** 로 노출하면 **기존 필터 체인** 활용 가능

---

# 5. 테스트 & 배포

## 5.1 테스트 루틴
- **IFileDialog**
  - 필터링: 네트워크 드라이브/USB/시스템 폴더 포함 경로에서 **표시/비표시** 확인  
  - 컨트롤: 값 변경 → `OnItemSelected/OnButtonClicked` 정상 이벤트  
  - 프리뷰: 대용량/손상 파일, 예외/취소 처리(시간 제한)

- **Thumbnail/Preview**
  - 다양한 크기 요청(16~256px) → **성능/품질/알파**  
  - 파일 잠금/스트림 실패/메모리 부족 처리  
  - **DllHost.exe**(Out-of-proc 설정 시) 격리 안정성

- **Search**
  - `Indexing Options`에서 확장/프로토콜 포함 확인  
  - **IFilter**: 텍스트 일부가 검색에 걸리는지  
  - **Property**: 속성 수정 → 탐색기 상세창 반영  
  - **Protocol**: 항목 수/증분 크롤 성능

## 5.2 배포 팁
- x86/x64 **각 DLL** 제공(탐색기는 **프로세스 비트수**와 일치하는 핸들러만 로드)  
- COM 등록: MSI/WiX로 **HKCR/CLSID** 및 **ShellEx** 키 추가  
- 서명: **코드 서명**(SmartScreen/바이러스 오탐 방지)  
- 업데이트: Shell 확장은 **탐색기 캐시** 영향 → 강제 갱신(Explorer 재시작/캐시 무효화)

---

# 6. 성능 & 안정성 체크리스트

- [ ] 모든 COM 호출은 **예외/시간 제한** 처리 (특히 썸네일/프리뷰)  
- [ ] 이미지/텍스트 디코딩은 **스트림 크기 상한** + **타임아웃**  
- [ ] GDI/GDI+/WIC 리소스는 **RAII** 로 누수 방지  
- [ ] **비동기 취소**(프리뷰 중 탭 전환 등) 지원  
- [ ] IFilter/PropertyStore는 **빠른 실패** (인덱서 전체를 막지 않도록)  
- [ ] 레지스트리 등록 시 **잘못된 확장/CLSID** 중복 피하기(충돌시 무시/후순위)

---

# 7. 고급 팁 모음

- **IFileDialog → 최근 위치(Places) 고정**  
  `IFileDialog::AddPlace(IShellItem*, FDAP_BOTTOM)` 로 즐겨찾기 삽입  
- **Known Folder로 기본 폴더 설정**  
  `SHGetKnownFolderItem(FOLDERID_Pictures, ...)` → `SetFolder`  
- **파일 형식 전환 UI**  
  `OnTypeChange` 에서 선택된 필터에 따라 커스텀 컨트롤 가시성/기본 확장 변경  
- **대화상자에서 선택 미리보기(경량)**  
  `IShellItemImageFactory::GetImage` 로 썸네일만 빠르게 미리 보기 창에 그리기  
- **Preview Handler 재활용**  
  앱 내부의 상세 뷰어와 **같은 렌더링 엔진**을 공유(코어 라이브러리를 공용화)

---

# 8. 문제 해결(FAQ)

- **파일 대화상자에 내 프리뷰가 안 보인다**  
  → Common Item Dialog는 **내부 삽입 불가**. **별도 프리뷰 창** 또는 **Preview Handler** 구현 필요.

- **썸네일이 안 뜬다 / 느리다**  
  → 요청 크기 확인, 디코딩 경량화, 실패 시 **빠른 E_FAIL** 반환(기본 아이콘으로 대체)  
  → 32bpp **premultiplied alpha** 사용

- **IFilter가 검색에 반영 안 됨**  
  → PersistentHandler 연결/클래스 등록 재확인, **인덱싱 다시 시작**  
  → `SearchProtocolHost.exe` 로그/이벤트 뷰어 확인

- **Protocol Handler에서 인증 문제**  
  → **ApplicationID/Service SID 권한** 검토, 네트워크 자격 증명 토큰 전달 설계

---

## 부록 A) 간단 WiX 조각 (공용)

```xml
<!-- 64bit COM InProc Server 등록 -->
<Component Id="cmpFooShell64" Win64="yes" Guid="*">
  <File Id="filFoo64" Name="FooShell64.dll" Source="$(var.BuildDir)\x64\FooShell64.dll" KeyPath="yes" />
  <ProgId Id="Foo.File" Description="Foo Document"/>
  <Class Id="{YOUR-CLSID-PREVIEW}" Context="InprocServer32" Description="Foo Preview Handler" ThreadingModel="Both">
    <ProgId Id="Foo.Preview"/>
  </Class>
  <!-- Preview 등록 -->
  <RegistryValue Root="HKCR" Key=".foo\ShellEx\{8895b1c6-b41f-4c1c-a562-0d564250836f}"
                 Value="{YOUR-CLSID-PREVIEW}" Type="string" Action="write" />
  <!-- Thumbnail 등록 -->
  <RegistryValue Root="HKCR" Key=".foo\ShellEx\{e357fccd-a995-4576-b01f-234630154e96}"
                 Value="{YOUR-CLSID-THUMB}" Type="string" Action="write" />
  <!-- IFilter PersistentHandler 등록 -->
  <RegistryValue Root="HKCR" Key=".foo" Name="PersistentHandler" Value="{YOUR-CLSID-PERSIST}" Type="string" Action="write"/>
  <RegistryValue Root="HKCR" Key="CLSID\{YOUR-CLSID-PERSIST}\PersistentAddinsRegistered\{89BCB740-6119-101A-BCB7-00DD010655AF}"
                 Value="{YOUR-CLSID-FILTER}" Type="string" Action="write"/>
</Component>
```

---

## 부록 B) 안전한 스트림 → HBITMAP (WIC/GDI+ 예시)

```cpp
HBITMAP RenderPngToHBITMAP(IStream* s, UINT cx) {
    Gdiplus::Bitmap bmp(s); // PNG/JPEG 자동 판별
    if (bmp.GetLastStatus()!=Gdiplus::Ok) return nullptr;

    UINT w = bmp.GetWidth(), h = bmp.GetHeight();
    if (!w || !h) return nullptr;
    double scale = double(cx)/double(std::max(w,h));
    UINT dw = std::max(1u, UINT(w*scale)), dh = std::max(1u, UINT(h*scale));

    Gdiplus::Bitmap dst(dw, dh, PixelFormat32bppPARGB);
    Gdiplus::Graphics g(&dst);
    g.SetInterpolationMode(Gdiplus::InterpolationModeHighQualityBicubic);
    g.DrawImage(&bmp, Gdiplus::Rect(0,0,dw,dh));
    HBITMAP hbmp = nullptr;
    dst.GetHBITMAP(Gdiplus::Color(0,0,0,0), &hbmp);
    return hbmp;
}
```
