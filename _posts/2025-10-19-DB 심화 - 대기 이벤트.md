---
layout: post
title: DB 심화 - 대기 이벤트
date: 2025-10-19 15:25:23 +0900
category: DB 심화
---
# Oracle **대기 이벤트(Wait Events)** 완전 가이드  
— “언제 발생하고/사라지는가”, **래치(Latch)** 와 **대기 이벤트**의 개념 분리, 실습·진단·튜닝 (19c 기준)

> 목표  
> - **대기 이벤트**가 **언제** 발생하고 **어떻게 끝나는지**(수명주기) 를 정확히 설명  
> - **래치(latch)/뮤텍스(mutex)** 와 **대기 이벤트(wait event)** 를 **명확히 구분**  
> - I/O/락/로그/버퍼/네트워크/RAC 등 **대표 이벤트**의 해석법과 **튜닝 포인트** 제시  
> - **실습 시나리오(세션 A/B)**, **진단 SQL**(V$SESSION/V$SYSTEM_EVENT/V$EVENT_NAME/ASH) 포함

---

## 0. 한눈 개요

- **대기 이벤트(Wait Event)**: 세션이 **어떤 리소스를 기다린 시간**을 분류·기록한 **관측 인터페이스**.  
- 이벤트는 **세션이 즉시 진행 불가** → **수동/능동 대기** → **조건 만족/타임아웃/에러** 로 **끝날 때** 1회로 집계.  
- **CPU 사용 중**이면 **대기 중이 아니다**(ASH에 **ON CPU** 로 샘플링).  
- **래치/뮤텍스**는 **메모리 내부 직렬화 도구**(동시성 제어 기법)이지, 이벤트 그 자체가 아님. 다만 **획득 실패→잠깐 잠** 시 **대기 이벤트 이름**(예: `latch: cache buffers chains`)으로 **기록**될 수 있다.

---

## 1. 대기 이벤트 수명주기(Lifecycle)

### 1.1 언제 생기나?
세션이 **즉시 진행 불가**할 때:
- **디스크 I/O 완료 대기**: `db file sequential read`(단일 블록), `direct path read/write`(대용량 경로)
- **트랜잭션 락 대기**: `enq: TX - row lock contention`
- **Redo 플러시 대기**: `log file sync` (커밋 시 LGWR flush)
- **버퍼 경합**: `buffer busy waits`, `read by other session`
- **래치/뮤텍스 재시도 간 잠깐 쉼**: `latch: cache buffers chains`, `cursor: mutex X/S`
- **RAC 글로벌 캐시**: `gc cr request`, `gc buffer busy`
- **네트워크/Idle**: `SQL*Net message from client`(대부분 Idle)

### 1.2 대기 시작 → 종료 조건
- **조건 성립**(I/O 완료, 락 소유자 커밋 등)  
- **포스트(post)/시그널** 수신 (LGWR/DBWR/OS I/O 완료 알림)  
- **타임아웃/에러** 로 종료

**종료 순간**: `V$SESSION_EVENT`/`V$SYSTEM_EVENT` 의 **waits/시간** 누적 증가, `V$SESSION` 의 `STATE` 가 `WAITED KNOWN TIME`/`WAITED SHORT TIME` 로 바뀌었다가 다음 호출로 이동.

### 1.3 언제 사라지나?
- 이벤트는 **발생-종료** 시 **카운팅**되고, **세션이 다음 단계로 진입**하면 **그 대기는 끝**.  
- **사라진다**는 것은 “**세션이 더 이상 그 이벤트를 기다리지 않는다**”는 뜻(리소스 획득/완료/에러/타임아웃).

---

## 2. 래치/뮤텍스 vs 대기 이벤트 — 개념 분리

| 구분 | 본질 | 범위 | 블로킹 방식 | 이벤트와의 관계 |
|---|---|---|---|---|
| **래치(Latch)** | **SGA 메모리 구조 보호**용 **스핀-락** | 매우 **짧은 임계구역** | 먼저 **스핀** 후 실패 시 **잠깐 잠** | 잠으로 전환 시 **`latch: …`** 이벤트로 기록 |
| **뮤텍스(Mutex)** | 커서/라이브러리 캐시 등 **미세 직렬화** | 짧은 임계구역 | 스핀 & 슬립 | `cursor: mutex X/S` 등으로 기록 |
| **엔큐(Enqueue, TX/TM 등)** | **트랜잭션/오브젝트** 레벨 잠금 | 길 수 있음 | 대기 중심 | `enq: TX - …`, `enq: TM - …` |
| **대기 이벤트** | **관측 지표** | 전체 | (무관) | **대기 상황**이 있을 때만 기록 |

> **핵심**: 래치/뮤텍스는 **동시성 제어 기법**, 대기 이벤트는 **일어난 대기를 분류·기록**한 **로그/지표**.

---

## 3. 이벤트 클래스(Wait Class)와 해석

- Oracle은 이벤트를 **Wait Class** 로 묶어 상위 경향을 본다.
  - **User I/O**: `db file sequential read`, `direct path read/write`  
  - **System I/O**: 백그라운드 I/O (`log file parallel write` 등)  
  - **Commit**: `log file sync`  
  - **Concurrency**: 래치/뮤텍스/버퍼 경합/ITL 등  
  - **Application**: `enq: TX - row lock contention` 등 애플리케이션 동시성  
  - **Network**: SQL*Net  
  - **Cluster**: RAC GC  
  - **Configuration/Other** …  
  - **Idle**: `SQL*Net message from client`, `rdbms ipc message` 등(보통 무시)

---

## 4. 대표 이벤트—동작과 튜닝 시사점 요약

| 이벤트 | 뜻 | 주원인 | 튜닝 힌트 |
|---|---|---|---|
| `db file sequential read` | 단일 블록 읽기 | 인덱스 접근/랜덤 읽기 | 인덱스 설계, 캐시 히트율, 스토리지 레이턴시 |
| `direct path read/write` | 버퍼 캐시 우회 대량 I/O | 병렬/배치/대용량 스캔 | 적절한 병렬도, I/O 대역폭, TEMP/UNDO/LOG 밸런스 |
| `buffer busy waits` | 같은 블록 경합 | 핫 블록/ITL 부족 | 키 분산, `INITRANS`/`PCTFREE` 확장, 파티셔닝 |
| `read by other session` | 다른 세션이 같은 블록 읽는 중 | 동일 블록 동시 미스 | 인덱스/파티션 설계, 캐시 정책 |
| `enq: TX - row lock contention` | 행 락 충돌 | 동시 UPDATE/DELETE | 접근 순서 통일, 단일 소비, `FOR UPDATE` 등 |
| `enq: TX - allocate ITL entry` | ITL 부족 | 동시 갱신 집중 | `INITRANS`↑, 헤더 여유, 키 분산 |
| `log file sync` | 커밋이 LGWR flush 대기 | 잦은 커밋/느린 redo 디스크 | 커밋 배치, 빠른 redo 디스크, 로그 크기/스위치 |
| `latch: cache buffers chains` | CBC 래치 경합 | 핫 버킷/블록 | 키 분산, 핫 SQL 개선 |
| `cursor: mutex X/S` | 커서 뮤텍스 경합 | 과도한 파싱/공유커서 충돌 | 바인드/하드파싱 절감, 커서 캐시 |

---

## 5. 실습 시나리오

> 아래 예제는 **테스트 전용**에서 진행하세요.

### 5.1 행 락 대기(`enq: TX - row lock contention`)

```sql
-- 준비
DROP TABLE t_lock PURGE;
CREATE TABLE t_lock (id NUMBER PRIMARY KEY, v NUMBER);
INSERT INTO t_lock SELECT LEVEL, 0 FROM dual CONNECT BY LEVEL <= 100;
COMMIT;

-- 세션 A: 특정 행 갱신(커밋 지연)
UPDATE t_lock SET v = v + 1 WHERE id = 1;

-- 세션 B: 같은 행 갱신 시도 → 행 락 대기
UPDATE t_lock SET v = v + 10 WHERE id = 1;
-- B는 A가 COMMIT/ROLLBACK 할 때까지 'enq: TX - row lock contention'
```

진단:

```sql
-- 현재 대기
SELECT sid, event, state, seconds_in_wait
FROM   v$session
WHERE  event LIKE 'enq: TX - row lock contention';

-- 세션별 잠금(간단)
SELECT s.sid, l.type, l.id1, l.id2, l.lmode, l.request
FROM   v$lock l JOIN v$session s ON s.sid = l.sid
WHERE  l.type IN ('TX','TM');
```

튜닝: **접근 순서 통일**, **행을 좁게 잠그는 설계**, 필요시 **큐잉/단일 소비자**.

---

### 5.2 ITL 부족(`enq: TX - allocate ITL entry`)

```sql
DROP TABLE t_itl PURGE;
CREATE TABLE t_itl(
  id  NUMBER PRIMARY KEY,
  g   NUMBER NOT NULL,
  pad VARCHAR2(50)
)
INITRANS 1 PCTFREE 5;

BEGIN
  FOR i IN 1..10000 LOOP
    INSERT INTO t_itl VALUES(i, MOD(i,10), RPAD('x',50,'x'));
    IF MOD(i,500)=0 THEN COMMIT; END IF;
  END LOOP;
  COMMIT;
END;
/

-- 여러 세션이 동시에 같은 g=0 범위 UPDATE → 블록당 ITL 부족 유발
-- 관측
SELECT sid, event, state, seconds_in_wait
FROM   v$session
WHERE  event LIKE 'enq: TX - allocate ITL entry';

-- 개선
ALTER TABLE t_itl MOVE INITRANS 8 PCTFREE 20;
```

---

### 5.3 커밋 지연(`log file sync`)

```sql
DROP TABLE t_commit PURGE;
CREATE TABLE t_commit (id NUMBER, v NUMBER);

DECLARE
  i NUMBER := 0;
BEGIN
  WHILE i < 10000 LOOP
    INSERT INTO t_commit VALUES(i, 0);
    COMMIT;  -- 자잘한 커밋 → LGWR flush 폭증 → log file sync 증가
    i := i + 1;
  END LOOP;
END;
/
```

관측:

```sql
SELECT event, total_waits, time_waited_micro/1e6 AS sec
FROM   v$system_event
WHERE  event IN ('log file sync','log file parallel write','log buffer space')
ORDER  BY sec DESC;
```

튜닝: **커밋 빈도 조절(배치)**, **redo 디스크 저지연 장비**, **로그 크기/스위치 빈도 최적화**.

---

### 5.4 버퍼 경합(`buffer busy waits`, `read by other session`)

- **핫 블록**(동일 블록 반복 접근) 또는 **동시 물리 읽기 충돌** 시 관측.

진단:

```sql
-- 세그먼트 통계 상위
SELECT o.owner, o.object_name, 
       SUM(CASE WHEN s.statistic_name='buffer busy waits' THEN s.value ELSE 0 END) buf_busy
FROM   v$segment_statistics s
JOIN   dba_objects o ON o.owner=s.owner AND o.object_name=s.object_name
GROUP  BY o.owner, o.object_name
ORDER  BY buf_busy DESC FETCH FIRST 10 ROWS ONLY;
```

튜닝: **키 분산(Reverse/Hash)**, **파티셔닝**, **쿼리/인덱스 계획 개선**.

---

## 6. 진단 SQL 모음

```sql
-- 6.1 이벤트 메타
SELECT name, wait_class, parameter1, parameter2, parameter3
FROM   v$event_name
ORDER  BY wait_class, name;

-- 6.2 시스템 누적
SELECT event, total_waits, time_waited_micro/1e6 AS seconds, wait_class
FROM   v$system_event
ORDER  BY seconds DESC;

-- 6.3 세션 현재/최근 대기
SELECT sid, serial#, username, state, event, wait_class, 
       seconds_in_wait, blocking_session
FROM   v$session
WHERE  state <> 'WAITED SHORT TIME'
ORDER  BY seconds_in_wait DESC;

-- 6.4 ASH(라이선스 필요): 최근 10분 상위 이벤트
SELECT event, wait_class, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
GROUP  BY event, wait_class
ORDER  BY samples DESC;

-- 6.5 파일별 I/O 지연
SELECT file#, name FROM v$datafile ORDER BY file#;
SELECT file#, avg_read_time, avg_write_time, phyblkrd, phyblkwrt
FROM   v$filestat ORDER BY (avg_read_time + avg_write_time) DESC;
```

---

## 7. “이벤트는 언제 사라지나?” — 상태 필드로 보는 미시동작

`V$SESSION.STATE`:

- `WAITING` : 지금 **그 이벤트**를 대기 중  
- `WAITED KNOWN TIME` : 방금 전에 **측정 가능한 시간** 만큼 기다렸다가 끝남  
- `WAITED SHORT TIME` : 아주 짧게 기다렸다가 끝남(기록만 남기고 곧 진행)  

세션이 **I/O 완료/락 해제/래치 획득** 등으로 **조건 성립** 시, 해당 이벤트의 **이번 대기 인스턴스**가 **종료**되고, 세션은 **다음 단계**로 넘어간다(= “사라진다”).

---

## 8. 수식 감각(개념)

- **DB Time** = **CPU Time** + **Wait Time**  
  $$ \mathrm{DB\ Time} = \mathrm{CPU} + \sum_{e \in \text{events}} \mathrm{WaitTime}_e $$
- **Top-Down 접근**: Wait Class/Top Events → SQL/오브젝트 → OS/스토리지  
- **Idle 이벤트**는 제외하고 본다(사용자 Think Time 등).

---

## 9. 튜닝 체크리스트(문제 유형별)

1. **I/O 대기(User I/O)** ↑  
   - 인덱스/계획 최적화, 통계/카디널리티 교정, 스토리지 레이턴시 점검, 캐시 히트율 개선  
2. **Commit (`log file sync`)** ↑  
   - 커밋 배치, Redo 디스크 가속(저지연), 로그 파일 크기/스위치 주기 최적화  
3. **Concurrency(래치/뮤텍스/버퍼)** ↑  
   - 핫 블록 분산(키/파티션), ITL 확장(`INITRANS`/`PCTFREE`), 파싱 절감(바인드, 커서 재사용)  
4. **Application(행 락/엔큐)** ↑  
   - 접근 순서 통일, `SELECT FOR UPDATE`, 큐잉/단일 소비, 트랜잭션 경계 축소  
5. **RAC Cluster** ↑  
   - 서비스-파티션 로컬리티, 시퀀스 캐시/증가폭, 파티션 프루닝

---

## 10. 간단 실무 절차(Top-Down)

1) **AWR/ASH** 로 **Top Wait**/SQL/세그먼트 파악  
2) 이벤트의 **자원 의미** 해석(락인가? I/O인가? 로그인가?)  
3) 해당 자원의 **근본 원인**(계획/설계/스토리지/패턴) 확인  
4) **작은 변경**부터 시도(인덱스/SQL 힌트/INITRANS/로그 크기/커밋 정책)  
5) **재측정** → 개선 여부 확인(전/후 `v$system_event`, AWR 비교)

---

## 11. 마무리 요약

- **대기 이벤트**는 **세션이 멈춘 이유와 시간**을 분류해 보여주는 **관측 레이어**.  
- 이벤트는 **조건 불충족 → 대기 → 조건 성립/타임아웃** 으로 **발생하고 사라진다**.  
- **래치/뮤텍스**는 **SGA 내부 동시성 제어 수단**이며, **획득 실패로 잠깐 잠** 들어갈 때만 **대기 이벤트**로 찍힌다.  
- 해석은 **Wait Class → Event → SQL/오브젝트 → 시스템 리소스** 순으로 **위에서 아래로**.  
- 튜닝은 **원인 자원**(I/O·Redo·락·버퍼·파싱·RAC 로컬리티)을 **정확히 겨냥**해야 효과가 크다.

> 한 줄 정리:  
> **대기 이벤트**는 “왜 지금 못 달리는가”의 지도이고, **래치/뮤텍스**는 “부딪치지 않게 잠깐 멈춰 세우는 안전벨트”다.  
> 지도를 잘 읽고 안전벨트 충돌을 줄이면, DB는 훨씬 매끄럽게 달린다.
