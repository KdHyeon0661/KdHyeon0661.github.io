---
layout: post
title: DB 심화 - 대기 이벤트
date: 2025-10-19 15:25:23 +0900
category: DB 심화
---
# Oracle **대기 이벤트(Wait Events)** (19c 기준)

> 목표
> - **대기 이벤트**가 **언제** 발생하고 **어떻게 끝나는지**(수명주기) 를 정확히 설명
> - **래치(latch)/뮤텍스(mutex)** 와 **대기 이벤트(wait event)** 를 **명확히 구분**
> - I/O/락/로그/버퍼/네트워크/RAC 등 **대표 이벤트**의 해석법과 **튜닝 포인트** 제시
> - **실습 시나리오(세션 A/B)**, **진단 SQL**(V$SESSION/V$SYSTEM_EVENT/V$EVENT_NAME/ASH) 포함

---

## 대기 이벤트 개요와 핵심 개념

**대기 이벤트(Wait Event)** 는 데이터베이스 세션이 어떤 리소스를 기다린 시간을 분류하고 기록하는 관측 인터페이스입니다. 쉽게 말해, '세션이 무엇을 기다리느라 시간을 보냈는지'를 설명하는 라벨입니다. 세션이 CPU를 사용하며 논리적으로 작업을 수행 중일 때는 '대기 중'이 아닙니다. 그러나 즉시 진행할 수 없는 조건에 부딪히면, 해당 조건이 해결될 때까지 대기 상태에 들어가고, 그 원인이 된 리소스 유형에 맞는 특정 대기 이벤트를 발생시킵니다.

**래치(Latch)** 와 **뮤텍스(Mutex)** 는 이러한 대기 이벤트와 종종 혼동되지만, 본질적으로 다릅니다. 이들은 SGA와 같은 공유 메모리 구조에 대한 동시 접근을 제어하기 위한 **내부 동기화 메커니즘**(스핀-락 방식)입니다. 반면, 대기 이벤트는 이러한 메커니즘을 획득하려다 실패하거나, 다른 리소스(I/O 완료, 락 해제 등)를 기다릴 때 발생하는 **관측 가능한 현상**을 기록하는 것입니다. 즉, 래치/뮤텍스는 '원인'에 가깝고, `latch: cache buffers chains` 같은 이벤트는 그 결과로 관측되는 '증상'입니다.

---

## 대기 이벤트의 수명주기(Lifecycle): 시작과 종료

대기 이벤트는 세션이 진행을 멈춰야 할 때 태어나고, 대기 조건이 해결될 때 죽습니다. 이 생애 주기를 이해하는 것이 성능 문제를 정확히 진단하는 첫걸음입니다.

### 대기 이벤트가 시작되는 순간
세션이 다음 작업을 즉시 수행할 수 없을 때 대기 상태로 전환됩니다. 이는 다양한 원인에서 비롯됩니다:
- **I/O 작업 완료 대기**: `db file sequential read`(인덱스 조회 시 단일 블록 읽기), `db file scattered read`(풀 테이블 스캔 시 멀티 블록 읽기).
- **동시성 제어 대기**: `enq: TX - row lock contention`(다른 트랜잭션이 소유한 행 잠금), `buffer busy waits`(다른 세션이 동일 블록 사용 중).
- **시스템 내부 조정 대기**: `latch: cache buffers chains`(해시 체인 래치 획득 실패), `log file sync`(커밋 시 LGWR의 Redo 플러시 완료).
- **네트워크 대기**: `SQL*Net message from client`(주로 클라이언트 응답 대기로, 대부분 유휴 상태를 의미).

### 대기 이벤트가 종료되는 순간
대기 상태는 아래 조건 중 하나가 충족되면 종료되고, 세션은 다음 작업을 재개합니다.
- **조건 충족**: 기다리던 리소스가 사용 가능해짐 (예: I/O 완료, 락 소유자 커밋).
- **시스템 알림**: 백그라운드 프로세스(예: LGWR, DBWR)나 운영체제로부터 완료 신호(POST)를 받음.
- **타임아웃 또는 오류**: 정해진 시간 내에 조건이 충족되지 않거나 오류가 발생.

대기가 종료되면, 해당 이벤트의 누적 대기 횟수(`TOTAL_WAITS`)와 시간(`TIME_WAITED`)이 `V$SYSTEM_EVENT` 및 `V$SESSION_EVENT` 뷰에 업데이트됩니다. `V$SESSION` 뷰의 `STATE` 컬럼은 `WAITING`에서 `WAITED KNOWN TIME`(측정 가능한 시간 동안 대기함) 또는 `WAITED SHORT TIME`(매우 짧게 대기함)으로 변경되었다가, 세션이 다음 작업을 시작하면 다시 `WAITING`이나 다른 상태로 바뀝니다.

---

## 주요 대기 이벤트 클래스(Wait Class)와 의미

Oracle은 수백 개의 대기 이벤트를 이해하기 쉬운 상위 범주로 묶어 **Wait Class**를 정의합니다. 이는 문제의 성격을 빠르게 파악하는 데 도움이 됩니다.

- **User I/O**: 애플리케이션 요청에 따른 데이터 파일 읽기/쓰기 대기. (`db file sequential read`, `direct path read`)
- **System I/O**: 백그라운드 프로세스의 I/O 작업 대기. (`log file parallel write`, `db file parallel write`)
- **Commit**: 트랜잭션 커밋과 관련된 대기. (`log file sync`)
- **Concurrency**: 래치, 뮤텍스, 버퍼, 라이브러리 캐시 등 내부 자원 경합 대기.
- **Application**: 애플리케이션 설계로 인한 대기. (`enq: TX - row lock contention`)
- **Configuration**: 부적절한 설정으로 인한 대기 (예: 너무 작은 로그 버퍼).
- **Network**: 네트워크 통신 지연.
- **Cluster**: RAC 환경에서 인스턴스 간 캐시 동기화 대기. (`gc cr request`)
- **Idle**: 세션이 유휴 상태임을 나타내는 대기. (`SQL*Net message from client` - 분석 시 주로 제외)

---

## 핵심 대기 이벤트 심층 분석 및 튜닝 방향

각 대기 이벤트는 시스템의 특정 상태를 나타내며, 그 해석법과 해결책이 다릅니다.

### 1. I/O 관련 대기
- **`db file sequential read`**: 주로 인덱스를 통한 행 접근 시 발생하는 단일 블록 읽기 대기입니다. 인덱스 조회, ROWID로 테이블 액세스, 인덱스 범위 스캔 시 나타납니다.
    - **튜닝 포인트**: 비효율적인 인덱스 스캔 또는 높은 물리적 I/O를 유발하는 SQL을 최적화합니다. 버퍼 캐시 히트율을 높이고, 느린 스토리지 I/O 성능을 점검합니다.
- **`db file scattered read`**: 풀 테이블 스캔이나 인덱스 패스트 풀 스캔 시 멀티 블록 I/O를 기다리는 대기입니다.
    - **튜닝 포인트**: 불필요한 풀 스캔을 인덱스 스캔으로 전환하거나, 파티셔닝을 적용합니다. `DB_FILE_MULTIBLOCK_READ_COUNT` 파라미터가 적절히 설정되었는지 확인합니다.

### 2. 동시성(Concurrency) 관련 대기
- **`buffer busy waits`**: 여러 세션이 동시에 같은 데이터 블록에 접근하려고 할 때 발생합니다. 한 세션이 블록을 읽거나 변경하는 동안 다른 세션은 대기해야 합니다.
    - **튜닝 포인트**: '핫 블록(Hot Block)'을 찾아 해시 파티셔닝, Reverse Key 인덱스 등으로 접근을 분산시킵니다. `INITRANS` 값을 높여 블록 내 트랜잭션 슬롯(ITL)을 늘리는 것도 효과적입니다.
- **`enq: TX - row lock contention`**: 한 트랜잭션이 갱신 중인 행을 다른 트랜잭션이 갱신하려 할 때 발생하는 행 수준 잠금 대기입니다.
    - **튜닝 포인트**: 애플리케이션 로직을 수정해 접근 순서를 통일하거나, 트랜잭션 길이를 최소화합니다. `SELECT FOR UPDATE NOWAIT`를 활용하거나, 큐(Queue) 메커니즘을 도입합니다.

### 3. Redo 로그 관련 대기
- **`log file sync`**: 사용자 세션이 `COMMIT` 또는 `ROLLBACK`을 수행할 때, LGWR 프로세스가 해당 트랜잭션의 Redo를 디스크에 기록하기를 기다리는 대기입니다.
    - **튜닝 포인트**: 너무 잦은 커밋을 배치 처리로 변경합니다. 온라인 리두 로그 파일을 최고 성능의 스토리지(저지연 SSD)에 위치시키고, 로그 파일 크기를 적절히 조정하여 로그 스위치 빈도를 줄입니다.

### 4. 래치(Latch) 관련 대기
- **`latch: cache buffers chains`**: 버퍼 캐시 해시 체인을 보호하는 CBC 래치를 얻지 못해 대기하는 상태입니다. 특정 해시 버킷에 속한 '핫 블록'에 대한 과도한 동시 접근이 원인입니다.
    - **튜닝 포인트**: 핫 블록을 유발하는 SQL 및 인덱스를 최적화하고, 핫 블록 자체를 분산시키는 설계(파티셔닝, Reverse Key)를 적용합니다.

### 5. RAC(Cluster) 관련 대기
- **`gc cr request`**: 로컬 인스턴스에 필요한 Consistent Read(CR) 버퍼가 원격 인스턴스에 있을 때, 해당 버퍼를 전송받기 위해 대기합니다.
- **`gc buffer busy`**: 원격 인스턴스에서 현재 사용 중인 버퍼를 로컬에서 접근하려 할 때 발생합니다.
    - **튜닝 포인트**: 애플리케이션 서비스를 인스턴스별로 분리하거나, 데이터를 파티셔닝하여 인스턴스 로컬리티(Affinity)를 높입니다. 시퀀스 생성 시 `CACHE` 크기를 늘립니다.

---

## 실습 시나리오: 대기 이벤트 직접 관찰하기

> 아래 예제는 테스트 환경에서 실행하세요.

### 시나리오 1: 행 잠금 경합(`enq: TX - row lock contention`)
```sql
-- 세션 A
UPDATE employees SET salary = salary * 1.1 WHERE employee_id = 200;
-- COMMIT 실행하지 않고 대기

-- 세션 B (다른 연결에서 실행)
UPDATE employees SET salary = salary * 1.05 WHERE employee_id = 200;
-- 세션 A의 커밋을 기다리며 'enq: TX - row lock contention' 대기에 빠짐
```

**진단 SQL**:
```sql
-- 대기 중인 세션 확인
SELECT sid, serial#, username, event, state, blocking_session
FROM   v$session
WHERE  event LIKE 'enq: TX - row lock%';

-- 잠금 정보 상세 조회
SELECT s.sid, s.serial#, l.type, l.id1, l.id2, l.lmode, l.request, s.username
FROM   v$lock l
JOIN   v$session s ON l.sid = s.sid
WHERE  l.type = 'TX' AND l.block > 0;
```
**해결**: 세션 A에서 `COMMIT` 또는 `ROLLBACK`을 실행하면 세션 B의 대기가 해제됩니다.

### 시나리오 2: 로그 파일 동기화(`log file sync`)
```sql
-- 자잘한 커밋을 반복하는 프로시저 실행
BEGIN
  FOR i IN 1..5000 LOOP
    INSERT INTO test_log VALUES (i, SYSDATE);
    COMMIT; -- 매번 COMMIT -> LGWR 플러시 유발
  END LOOP;
END;
/
```
**관측 및 튜닝**:
```sql
-- log file sync 대기 확인
SELECT event, total_waits, time_waited_micro/1e6 AS seconds_waited
FROM   v$system_event
WHERE  event = 'log file sync';
```
**해결**: PL/SQL 블록 내에서 1000건마다 한 번씩 커밋하는 방식으로 변경하여 `COMMIT` 빈도를 줄입니다.

---

## 실전 진단을 위한 필수 SQL 쿼리

문제 발생 시 시스템과 세션의 대기 상태를 신속히 파악할 수 있는 쿼리 모음입니다.

```sql
-- 1. 시스템 누적 대기 이벤트 Top 10 (시작 이후)
SELECT event, wait_class, total_waits,
       ROUND(time_waited_micro / 1000000, 2) AS time_waited_secs,
       ROUND(time_waited_micro * 100 / NULLIF((SELECT SUM(time_waited_micro) FROM v$system_event WHERE wait_class != 'Idle'), 0), 2) AS pct
FROM   v$system_event
WHERE  wait_class != 'Idle'
ORDER  BY time_waited_micro DESC
FETCH FIRST 10 ROWS ONLY;

-- 2. 현재 대기 중인 세션 실시간 조회
SELECT sid, serial#, username, program,
       event, wait_class, state, seconds_in_wait,
       blocking_session, sql_id
FROM   v$session
WHERE  type = 'USER'
AND    state = 'WAITING'
AND    wait_class != 'Idle'
ORDER  BY seconds_in_wait DESC;

-- 3. 대기 이벤트별 상세 파라미터 정보 확인
SELECT name, wait_class, parameter1, parameter2, parameter3
FROM   v$event_name
WHERE  name LIKE '&이벤트_이름_패턴%'; -- 예: 'buffer%', 'enq%'

-- 4. ASH(Active Session History)를 이용한 최근 시간대 패턴 분석 (Enterprise Edition)
-- 최근 30분 동안 가장 많이 샘플링된 대기 이벤트
SELECT event, wait_class, COUNT(*) AS sample_count
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '30' MINUTE
AND    session_state = 'WAITING'
AND    wait_class != 'Idle'
GROUP  BY event, wait_class
ORDER  BY sample_count DESC;

-- 5. 특정 세션의 대기 이벤트 히스토리
SELECT event, total_waits, time_waited_micro
FROM   v$session_event
WHERE  sid = &세션_SID
ORDER  BY time_waited_micro DESC;
```

---

## 대기 이벤트를 통한 성능 튜닝 접근법

대기 이벤트 분석은 성능 튜닝의 '증상 기반 진단'의 출발점입니다. 효과적인 접근법은 다음과 같습니다.

1.  **상위 대기 식별 (Top-Down)**: AWR/ASH 리포트나 `V$SYSTEM_EVENT`를 통해 시스템 전체 또는 특정 기간의 **상위 대기 이벤트(Wait Class)** 를 먼저 파악합니다. 이는 '어디에 문제가 집중되어 있는가'를 보여줍니다.
2.  **근본 원인 추적 (Drill-Down)**: 식별된 주요 이벤트와 연관된 **특정 SQL, 세션, 오브젝트(테이블, 인덱스)** 를 찾습니다. `V$SESSION`, `V$SQL`, `V$SEGMENT_STATISTICS` 뷰가 여기에 활용됩니다.
3.  **리소스 병목 해석**: 대기 이벤트가 가리키는 **하위 시스템 리소스 병목**을 해석합니다.
    -   `db file sequential read` → **스토리지 I/O 지연** 또는 **비효율적 인덱스 사용**
    -   `log file sync` → **Redo 로그 쓰기 지연** 또는 **과도한 커밋**
    -   `buffer busy waits` → **애플리케이션 핫 스팟(블록 경합)**
    -   `enq: TX - row lock` → **애플리케이션 동시성 제어 문제**
4.  **표적 개선 수행**: 원인에 맞는 구체적인 액션을 수행합니다.
    -   **SQL/인덱스 튜닝**: 실행 계획 변경, 불필요한 풀 스캔 제거.
    -   **애플리케이션 수정**: 커밋 빈도 조정, 잠금 획득 순서 통일.
    -   **설계 변경**: 파티셔닝 도입, Reverse Key 인덱스 적용.
    -   **시스템/구성 조정**: I/O 서브시스템 성능 개선, 메모리(`SGA`) 크기 조정, 파라미터 최적화.
5.  **개선 효과 검증**: 변경 후 모니터링을 통해 대기 이벤트의 감소와 응답 시간 개선을 정량적으로 확인합니다.

---

## 결론: 대기 이벤트, 성능 진단의 언어

대기 이벤트는 오라클 데이터베이스가 스스로의 병목 지점을 우리에게 알려주는 가장 명확한 **언어**입니다. 이 언어를 이해한다는 것은, 단순한 지표 이상으로 데이터베이스 내부에서 벌어지는 미시적인 동작들—세션이 I/O를 위해 멈추는 순간, 락을 위해 줄 서는 순간, 메모리 접근을 위해 잠시 회전하는 순간—을 읽어낼 수 있게 되는 것입니다.

핵심은 **대기 이벤트(증상)**, **래치/뮤텍스/엔큐(내부 메커니즘)**, 그리고 **최종 원인(설계/코드/하드웨어)** 사이의 인과관계를 명확히 구분하고 연결하는 데 있습니다. `log file sync` 대기가 많다고 해서 항상 LGWR를 탓할 수는 없습니다. 그 뒤에 놓인 애플리케이션의 과도한 커밋 패턴이 진정한 문제일 수 있습니다.

따라서 효과적인 성능 관리자는 대기 이벤트라는 '신호'를 받아들이고, 그것이 가리키는 방향으로 파고들어, SQL 문장 한 줄, 애플리케이션 로직 한 단락, 또는 시스템 구성 한 가지를 변화시킴으로써 전체 시스템의 건강을 회복시킬 수 있어야 합니다. 대기 이벤트 분석은 결국, 데이터베이스와의 대화를 시작하는 방법을 배우는 것입니다.