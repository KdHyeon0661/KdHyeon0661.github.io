---
layout: post
title: DB - 관계형 데이터베이스 구조
date: 2025-02-15 19:20:23 +0900
category: DB
---
# 관계형 데이터베이스(Relational Database, RDB) 개요 및 구조

## 1. 관계형 데이터베이스 정의와 철학(핵심 복습)

- **정의**: 데이터를 **테이블(관계)**로 표현하고, 각 테이블은 **행(튜플)**, **열(속성)**로 구성된다.  
- **관계 설정**: **외래키(FK)**를 통해 테이블 간 참조 관계를 명시한다.  
- **질의**: 표준 **SQL**로 CRUD 및 복합 질의를 수행한다.  
- **기원**: 1970, **E. F. Codd**의 관계 모델; 집합론과 술어 논리에 근거한 엄밀한 모델.

### 1.1 수학적 배경(요약)
- **튜플 도메인**: 열의 값은 해당 도메인의 원자값이어야 한다(1NF).  
- **함수 종속**: $$X \to Y$$ 는 속성 집합 \( X \)가 주어지면 \( Y \)가 유일하게 결정됨을 의미한다.  
- **키**: 후보키 \( K \)는 최소성(minimality)과 유일성(uniqueness)을 모두 만족하는 속성 집합이다.  
- **정규화 목표**: **중복 최소화**, **갱신 이상 제거**, **논리적 일관성** 유지.

---

## 2. 핵심 구성 요소(심화)

### 2.1 테이블(Table, Relation)
- 개념적 엔티티의 물리 구현. 하나의 테이블은 **동일 스키마**를 가진 튜플들의 집합.
- 스키마 변경(ADD/MODIFY/DROP)은 DDL이며, DBMS에 따라 **온라인 DDL** 지원 정도가 상이하다.

### 2.2 행(Row, Tuple)
- 한 인스턴스의 데이터. 튜플은 **순서 개념이 없다**(ORDER BY 없이 순서는 비결정적).

### 2.3 열(Column, Attribute)
- 속성 이름, 도메인(타입/길이/제약). **널 허용 여부**와 **기본값**이 성능/무결성에 중요.

### 2.4 도메인(Domain)
- 값의 타입, 범위, 제약(CHECK), 기본값, 포맷.  
- 문서화(데이터 딕셔너리)와 **테이블 수준 CHECK**를 함께 둬서 앱/DB 이중 방어가 바람직.

### 2.5 키(Key)
- **기본키(PK)**: 유일+NOT NULL, 한 테이블 1개.  
- **후보키**: PK가 될 수 있는 모든 후보.  
- **대체키**: 후보키 중 PK가 아닌 것(보조 Unique).  
- **슈퍼키**: 유일하지만 최소성은 보장 안 함.  
- **외래키(FK)**: 참조 무결성의 핵심. ON DELETE/UPDATE 정책으로 결과를 예측 가능하게 만든다.

### 2.6 제약조건(Constraints)
- PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL, CHECK, EXCLUSION(특수; Postgres).  
- **제약은 성능 최적화가 아니라 무결성의 최후 방어선**. 잘 설계된 제약은 오히려 운영비용을 줄인다.

---

## 3. 테이블 간 관계와 매핑(구체 예시)

| 관계 | 설계 포인트 | 구현 요령 |
|---|---|---|
| 1:1 | 종종 물리 분리 후 PK=PK FK로 연결 | 통합이 성능상 이점이면 1:1 통합 고려 |
| 1:N | 가장 흔함 | FK는 **항상 N쪽**에 둔다 |
| N:M | 조인 테이블(bridge)로 분해 | 조인 테이블에 공유 속성(수강일, 역할 등) 포함 |

```sql
-- 예: 사용자-주문-주문상세
CREATE TABLE customer(
  id          BIGSERIAL PRIMARY KEY,
  email       CITEXT UNIQUE NOT NULL,  -- Postgres 확장, 대소문자 무시
  name        TEXT NOT NULL,
  created_at  TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE "order"(
  id          BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(id) ON DELETE RESTRICT,
  status      TEXT NOT NULL CHECK (status IN ('PENDING','PAID','CANCELLED','SHIPPED')),
  ordered_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE order_item(
  order_id   BIGINT NOT NULL REFERENCES "order"(id) ON DELETE CASCADE,
  product_id BIGINT NOT NULL,
  qty        INT    NOT NULL CHECK (qty > 0),
  price_cents INT   NOT NULL CHECK (price_cents >= 0),
  PRIMARY KEY(order_id, product_id)
);
```

- **주의**: FK의 ON DELETE CASCADE는 편리하지만 **실수 시 대량 삭제** 유발 가능. 테스트 필수.

---

## 4. 무결성: 엔터티·참조·도메인(실무 패턴)

### 4.1 엔터티 무결성
- PK는 NULL 불가, 유일. **자연키 vs 인조키**: 변경 가능성·민감도(PII)·리스크를 고려해 **인조키** 권장.

### 4.2 참조 무결성
- FK는 참조 대상이 존재해야 함(또는 NULL).  
- 정책 선택:
  - **ON DELETE RESTRICT/NO ACTION**: 강한 보수.  
  - **ON DELETE SET NULL**: 연성 참조.  
  - **ON DELETE CASCADE**: 부모 삭제 시 자식 자동 삭제(감사/규제 데이터에 주의).

### 4.3 도메인 무결성
- CHECK/ENUM/코드 테이블.  
- **코드성 값**은 보통 별도 코드 테이블로 관리하고 FK로 참조하여 데이터 품질을 통제.

---

## 5. 정규화와 성능(균형 잡기)

- **1NF/2NF/3NF/BCNF/4NF/5NF**는 중복/이상 제거에 유효.  
- 실무는 대개 **3NF±**까지 정규화 후, **실측 병목 지점**에서만 **반정규화**.

### 5.1 반정규화 시나리오(간단)
- 주문 테이블에 `customer_name`을 중복 저장하여 조인 제거.  
- 트리거/프로시저/단일 트랜잭션으로 **동기화**를 담보해야 한다.

```sql
-- 고객명 변경 시 주문 테이블의 캐시 컬럼 동기화(트리거 예)
CREATE OR REPLACE FUNCTION sync_order_customer_name() RETURNS trigger AS $$
BEGIN
  UPDATE "order" SET cached_customer_name = NEW.name
  WHERE customer_id = NEW.id;
  RETURN NEW;
END $$ LANGUAGE plpgsql;

CREATE TRIGGER trg_customer_name_update
AFTER UPDATE OF name ON customer
FOR EACH ROW EXECUTE FUNCTION sync_order_customer_name();
```

---

## 6. SQL DDL/DML/DCL/TCL — 통합 운영 관점

### 6.1 DDL(구조)
- **온라인 DDL**(무중단) 여부 확인: Postgres `CONCURRENTLY`, MySQL `INSTANT/INPLACE`, SQL Server `ONLINE`.
- **파티션 설계**: 날짜/범위/해시 키로 수평 분할 → **프루닝**으로 범위 조회 가속.

```sql
-- 월 단위 파티셔닝 예(Postgres)
CREATE TABLE order_monthly PARTITION OF "order"
FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
```

### 6.2 DML(조작)
- **UPSERT**: Postgres `ON CONFLICT`, MySQL `ON DUPLICATE KEY`, Oracle/MSSQL `MERGE`.
- **벌크 작업**: `COPY`/`LOAD DATA INFILE`/`BULK INSERT`로 처리; 대량 삭제는 **청크/파티션 DROP**.

```sql
-- 멱등 주문 생성(요청별 유니크키)
ALTER TABLE "order" ADD COLUMN request_id TEXT;
CREATE UNIQUE INDEX uq_order_request ON "order"(request_id);

INSERT INTO "order"(customer_id, status, request_id)
VALUES (:cid, 'PENDING', :req)
ON CONFLICT (request_id)
DO UPDATE SET status = EXCLUDED.status
RETURNING id;
```

### 6.3 DCL(권한)
- **RBAC**(Role-Based Access Control)으로 최소 권한 부여.  
- **RLS(Row-Level Security)**로 행 단위 접근 제어(고객 자신의 주문만 열람 등).

```sql
-- RLS 예: 현재 세션의 사용자 ID로 필터링
ALTER TABLE "order" ENABLE ROW LEVEL SECURITY;
CREATE POLICY order_owner ON "order"
  USING (customer_id = current_setting('app.user_id')::BIGINT);
```

### 6.4 TCL(트랜잭션)
- 격리수준 선택: READ COMMITTED/REPEATABLE READ/ SERIALIZABLE.  
- **SAVEPOINT**로 부분 롤백, **리트라이**로 직렬화 충돌 대응.

```sql
BEGIN;
  SAVEPOINT sp1;
  UPDATE accounts SET balance = balance - 100 WHERE id = 1;
  -- 실패 시
  -- ROLLBACK TO SAVEPOINT sp1;
COMMIT;
```

---

## 7. 인덱스 전략과 실행 계획(성능 핵심)

### 7.1 인덱스 유형·패턴
- **B-Tree**: 범용. 동등/범위 검색.  
- **Hash**(MySQL 내부 최적화, Postgres는 보통 B-Tree 선호).  
- **함수/표현식 기반**: `lower(email)` 같은 정규화.  
- **파셜/필터드**: 조건부 데이터만 인덱싱.  
- **커버링 인덱스**: 필요한 컬럼을 모두 포함해 테이블 접근 회피(엔진별 INCLUDE/복합키).

```sql
-- 파셜 인덱스(활성 회원만)
CREATE INDEX ix_user_active_lastlogin
  ON users (last_login DESC)
  WHERE is_active = true;

-- 함수 기반(이메일 정규화)
CREATE INDEX ix_users_email_norm ON users ((lower(email)));
```

### 7.2 실행 계획 읽기(개념)
- **Seq Scan vs Index Scan vs Index Only Scan**  
- **Nested Loop / Hash Join / Merge Join**  
- **Filter/Rows/Cost/Width** 지표 확인.  
- 통계 최신화(ANALYZE/DBMS_STATS)가 필수.

```sql
EXPLAIN ANALYZE
SELECT o.id, sum(oi.qty*oi.price_cents)
FROM "order" o
JOIN order_item oi ON oi.order_id = o.id
WHERE o.customer_id = :cid
  AND o.ordered_at >= now() - interval '30 days'
GROUP BY o.id;
```

---

## 8. 파티셔닝/아카이빙/머티리얼라이즈드 뷰

### 8.1 파티셔닝
- **프루닝**으로 범위 쿼리 최적화, **파티션 교체/드롭**으로 대량 삭제 비용 절감.  
- 키는 **자주 필터링되는 컬럼**(예: 날짜)과 일치시킨다.

### 8.2 아카이빙
- 오래된 데이터는 이력/아카이브 테이블로 이동(OLTP 경량화).  
- 뷰/유니온으로 단일 인터페이스 유지 가능.

### 8.3 머티리얼라이즈드 뷰(Materialized View)
- 집계/복잡 쿼리 결과를 저장. REFRESH 스케줄 설계(완전/증분).  
- 강한 정합성이 필요하면 **트리거 기반 캐시 테이블**로 대체하고 트랜잭션에 포함.

---

## 9. 보안·감사·운영 거버넌스

### 9.1 RBAC/RLS/마스킹
- 롤 기반 최소 권한, 컬럼 마스킹(민감정보), RLS로 세분화.  
- DCL 변경은 **티켓/코드 리뷰** 필수, 정기 권한 점검.

### 9.2 변경 관리
- **DDL 버저닝**: Flyway/Liquibase로 마이그레이션 스크립트 관리.  
- **릴리스 전략**: 컬럼 추가→이중쓰기→백필→스위치→구조 정리.

### 9.3 백업/복구(PITR)
- 정기 백업, **복구 리허설**로 RTO/RPO 검증.  
- 로그 선행기록(Write-Ahead Logging) 기반 **시점 복구** 전략.

---

## 10. RDB vs NoSQL: 조합 전략

| 항목 | RDB | NoSQL |
|---|---|---|
| 무결성/트랜잭션 | 강함(ACID) | 약~중(엔진별; BASE/이벤트추적) |
| 스키마 | 엄격 | 유연 |
| 확장 | 보통 수직(수평도 가능) | 수평 우수(샤딩/리플리카) |
| 적합 | ERP/금융/정합 중시 OLTP | 로그/세션/캐시/대용량 문서 |

- **폴리글랏**: RDB + 캐시(Redis) + 검색(Elastic) + DWH(BigQuery/Snowflake) 조합이 일반적.

---

## 11. 엔드투엔드 예시: 미니 주문 시스템(설계→구현→쿼리)

### 11.1 스키마(DDL)
```sql
CREATE TABLE product(
  id           BIGSERIAL PRIMARY KEY,
  sku          TEXT UNIQUE NOT NULL,
  name         TEXT NOT NULL,
  price_cents  INT  NOT NULL CHECK (price_cents >= 0),
  active       BOOLEAN NOT NULL DEFAULT true
);

CREATE TABLE customer(
  id          BIGSERIAL PRIMARY KEY,
  email       CITEXT UNIQUE NOT NULL,
  name        TEXT NOT NULL,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE "order"(
  id          BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(id) ON DELETE RESTRICT,
  status      TEXT NOT NULL CHECK (status IN ('PENDING','PAID','CANCELLED','SHIPPED')),
  ordered_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  request_id  TEXT UNIQUE
) PARTITION BY RANGE (ordered_at);

-- 파티션 한 개 생성(예시)
CREATE TABLE order_2025_11 PARTITION OF "order"
FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');

CREATE TABLE order_item(
  order_id    BIGINT NOT NULL REFERENCES "order"(id) ON DELETE CASCADE,
  product_id  BIGINT NOT NULL REFERENCES product(id),
  qty         INT NOT NULL CHECK (qty > 0),
  price_cents INT NOT NULL CHECK (price_cents >= 0),
  PRIMARY KEY(order_id, product_id)
);

-- 인덱스
CREATE INDEX ix_order_customer_time ON "order"(customer_id, ordered_at DESC);
CREATE INDEX ix_item_product ON order_item(product_id);
CREATE INDEX ix_product_sku_active ON product(sku) WHERE active = true;
```

### 11.2 기본 데이터(DML)
```sql
INSERT INTO product(sku, name, price_cents) VALUES
('SKU-KEYBRD-1','Mechanical Keyboard', 12000),
('SKU-MOUSE-1','Gaming Mouse', 7000),
('SKU-PAD-1','Large Mousepad', 2000);

INSERT INTO customer(email, name) VALUES
('alpha@example.com','Alpha'),
('beta@example.com','Beta');
```

### 11.3 멱등 주문 생성(UPSERT + 트랜잭션)
```sql
-- 요청별 유니크키로 멱등화
BEGIN;
  INSERT INTO "order"(customer_id, status, request_id)
  SELECT c.id, 'PENDING', 'REQ-2025-11-06-0001'
  FROM customer c WHERE c.email = 'alpha@example.com'
  ON CONFLICT (request_id) DO NOTHING;

  -- 방금 생성/기존 주문의 ID 확보
  WITH o AS (
    SELECT id FROM "order" WHERE request_id = 'REQ-2025-11-06-0001'
  )
  INSERT INTO order_item(order_id, product_id, qty, price_cents)
  SELECT o.id, p.id, 2, p.price_cents
  FROM o, product p
  WHERE p.sku = 'SKU-KEYBRD-1'
  ON CONFLICT (order_id, product_id)
  DO UPDATE SET qty = order_item.qty + EXCLUDED.qty;
COMMIT;
```

### 11.4 조회(커버링/집계/페이징)
```sql
-- 최근 30일 고객별 주문 금액 합계
SELECT c.email, sum(oi.qty * oi.price_cents) AS total_cents
FROM customer c
JOIN "order" o ON o.customer_id = c.id
JOIN order_item oi ON oi.order_id = o.id
WHERE o.ordered_at >= now() - interval '30 days'
GROUP BY c.email
ORDER BY total_cents DESC
LIMIT 10;

-- 키셋 페이징(마지막 주문 시점 이후)
SELECT id, customer_id, status, ordered_at
FROM "order"
WHERE (ordered_at, id) < (:last_ts, :last_id)
ORDER BY ordered_at DESC, id DESC
LIMIT 50;
```

### 11.5 권한(DCL)·행 보안(RLS)
```sql
-- 읽기 전용 롤
CREATE ROLE app_readonly;
GRANT CONNECT ON DATABASE appdb TO app_readonly;
GRANT USAGE ON SCHEMA public TO app_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_readonly;

-- RLS: 세션 변수에 고객 ID를 넣고 자신의 주문만 보게 함
ALTER TABLE "order" ENABLE ROW LEVEL SECURITY;
CREATE POLICY own_orders ON "order"
USING (customer_id = current_setting('app.user_id')::BIGINT);
```

### 11.6 실행 계획 점검(요지)
```sql
EXPLAIN ANALYZE
SELECT o.id, sum(oi.qty*oi.price_cents)
FROM "order" o
JOIN order_item oi ON oi.order_id = o.id
WHERE o.customer_id = :cid
  AND o.ordered_at >= date_trunc('month', now())
GROUP BY o.id;
```
- 인덱스 **ix_order_customer_time**가 사용되는지, 파티션 프루닝이 적용되는지, 조인 방식(Hash/Nested Loop)을 확인한다.

---

## 12. 자주 겪는 문제와 해결책(체크리스트)

| 문제 | 원인 | 해결 |
|---|---|---|
| WHERE 없이 UPDATE/DELETE | 전행 영향 | 키 필터 의무화, 세이프 모드, 테스트는 LIMIT/ROWCOUNT |
| 큰 OFFSET | 스캔/정렬 과비용 | **키셋 페이징**으로 전환 |
| 인덱스 과다 | DML 저하, 저장소 낭비 | 사용통계로 정리, 파셜 인덱스 |
| 대량 삭제 지연 | 언두/리두 폭증 | 파티션 DROP/스위치, 청크 배치 |
| FK 없는 설계 | 데이터 부패 | FK 도입 + 이행 데이터 정합성 검사 |
| TRUNCATE 롤백 기대 | 데이터 소실 | 백업/스냅샷, 권한 분리 |
| 컬럼 타입 오설계 | 암묵 캐스팅/오버플로 | 도메인 정의, CHECK 제약 |

---

## 13. 이식성 주의(멀티 RDBMS)

- **자동 증가**: Postgres `IDENTITY`, MySQL `AUTO_INCREMENT`, SQL Server `IDENTITY`, Oracle `IDENTITY/SEQUENCE`.  
- **UPSERT**: PG(ON CONFLICT), MySQL(ON DUPLICATE KEY), MSSQL/Oracle(MERGE).  
- **시간존**: UTC 저장 + 표시 변환. MySQL `DATETIME`(TZ 없음) 주의.  
- **Collation/Case**: 유니크 비교 규칙이 다름 → 정규화 인덱스(`lower()`)·CITEXT 등.  
- **온라인 DDL**: 가용성 요구에 맞는 엔진/버전 선택.

---

## 14. 마무리(핵심 정리)

- **관계형 데이터베이스**는 **정형 데이터/관계/트랜잭션**이 핵심인 시스템에 최적이다.  
- 설계는 **정규화**로 시작하되, 병목 지점에 **선택적 반정규화**를 적용한다.  
- **제약/키/FK**를 적극 사용하여 데이터 품질을 DB 계층에서 보장한다.  
- 성능은 **인덱스/파티션/실행계획/캐시**로, 운영은 **RBAC/RLS/마이그레이션/백업**으로 완성한다.  
- 현실적인 아키텍처는 RDB를 중심으로 **캐시/검색/DWH** 등 **폴리글랏** 구성으로 확장한다.
