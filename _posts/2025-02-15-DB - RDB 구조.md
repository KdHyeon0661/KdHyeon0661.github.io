---
layout: post
title: DB - 관계형 데이터베이스 구조
date: 2025-02-15 19:20:23 +0900
category: DB
---
# 관계형 데이터베이스의 핵심 원리와 실무적 적용

## 관계형 모델의 본질: 구조, 무결성, 언어

관계형 데이터베이스는 데이터를 **테이블(관계)**이라는 직관적인 구조로 조직화합니다. 각 테이블은 특정 엔티티(예: 고객, 주문, 상품)를 표현하며, 행(튜플)은 개별 인스턴스를, 열(속성)은 그 인스턴스의 특성을 나타냅니다. 테이블 간의 논리적 연결은 **외래키**라는 명시적 참조를 통해 구축되며, 이를 통해 데이터의 의미와 정합성을 보존합니다.

이 모델의 힘은 **선언적 질의 언어인 SQL**에서 비롯됩니다. 사용자는 *무엇을* 원하는지만 기술하고, 데이터베이스 시스템이 *어떻게* 가장 효율적으로 가져올지 결정합니다. 이러한 추상화는 생산성을 극대화하고, 1970년 에드거 F. 커드가 제안한 수학적 기반(집합론과 관계 대수) 위에 세워진 견고한 이론적 토대를 제공합니다.

핵심 수학적 개념은 데이터 설계의 지침이 됩니다:
*   **함수적 종속성**: 한 속성 집합(X)의 값이 다른 속성 집합(Y)의 값을 유일하게 결정할 때, Y는 X에 함수적으로 종속된다고 말합니다. 예를 들어, `주문번호`가 주어지면 `고객ID`와 `주문일자`가 결정됩니다.
*   **정규화**: 이러한 종속 관계를 분석하여 데이터 중복을 제거하고 갱신 이상(삽입, 삭제, 수정 시 발생하는 불일치)을 방지하는 체계적인 과정입니다.
*   **키**: 각 행을 유일하게 식별할 수 있는 최소한의 속성 집합(기본키)을 정의함으로써 데이터의 정체성을 보장합니다.

---

## 데이터 무결성: 데이터베이스의 책임

관계형 데이터베이스는 단순한 데이터 컨테이너가 아닙니다. 그것은 스스로 규칙을 부여하고 이를 강제할 수 있는 능동적 시스템입니다. 이 **무결성** 보장은 세 가지 차원에서 이루어집니다.

1.  **엔터티 무결성**: 각 테이블의 기본키는 반드시 유일하고 NULL 값을 가질 수 없습니다. 이는 모든 데이터 항목이 명확한 정체성을 가지도록 보장합니다. 실무에서는 변경되지 않는 **대리키**(자동 증가 숫자, UUID)를 PK로 사용하는 것이 변경 가능한 **자연키**(이메일, 주민번호)보다 안정성과 보안 측면에서 유리합니다.
2.  **참조 무결성**: 외래키로 지정된 값은 반드시 참조 대상 테이블에 존재하는 유효한 기본키 값이어야 합니다. 이 규칙은 고아 데이터(부모가 없는 자식 레코드)의 생성을 방지합니다. `ON DELETE CASCADE`(부모 삭제 시 자동 삭제)나 `ON DELETE SET NULL` 같은 정책을 신중하게 선택하여 비즈니스 규칙을 반영할 수 있습니다.
3.  **도메인 무결성**: 각 컬럼에 입력될 수 있는 값의 유형과 범위를 제한합니다. `CHECK` 제약(`price >= 0`), `NOT NULL`, `ENUM` 타입, 그리고 별도의 **코드 테이블**을 참조하는 방식은 잘못된 데이터가 시스템에 유입되는 것을 사전에 차단합니다.

이러한 제약 조건들은 단순한 성능 오버헤드가 아니라, 애플리케이션 로직의 결함으로 인한 데이터 오염으로부터 시스템을 보호하는 **최후의 방어선**입니다. 잘 정의된 제약은 장기적으로 오히려 디버깅과 유지보수 비용을 줄여줍니다.

---

## 관계 설계: 개념을 테이블로 매핑하기

실세계의 관계를 테이블 구조로 옮기는 것은 데이터 모델링의 핵심입니다.
*   **1:1 관계**: 하나의 사용자와 하나의 사용자 설정 프로필과 같은 관계입니다. 대부분의 경우 하나의 테이블로 통합하는 것이 성능상 유리하지만, 보안상 분리하거나 성장성을 고려해 별도 테이블로 설계할 수도 있습니다.
*   **1:N 관계**: 한 고객이 여러 주문을 하는 것과 같은 가장 일반적인 관계입니다. 외래키는 항상 '다(N)'쪽 테이블(예: `주문` 테이블의 `customer_id`)에 위치시킵니다.
*   **N:M 관계**: 학생과 강의, 상품과 태그와 같은 다대다 관계는 **조인 테이블**(또는 연결 테이블)을 통해 해소합니다. 이 조인 테이블은 각 엔터티의 기본키를 외래키로 참조하는 동시에, 관계 자체에 대한 속성(예: 수강 신청일, 태깅 일자)을 저장할 수 있는 독립적인 엔티티로 발전할 수 있습니다.

```sql
-- 전형적인 전자상거래 스키마의 핵심
CREATE TABLE customer (
  id BIGSERIAL PRIMARY KEY, -- 대리키 사용
  email TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL
);

CREATE TABLE "order" (
  id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(id) ON DELETE RESTRICT, -- 1:N 관계, 부모 보호
  status TEXT NOT NULL CHECK (status IN ('PENDING','PAID','SHIPPED')), -- 도메인 무결성
  ordered_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- N:M 관계: 주문-상품 (한 주문에 여러 상품, 한 상품이 여러 주문에)
CREATE TABLE order_item (
  order_id BIGINT NOT NULL REFERENCES "order"(id) ON DELETE CASCADE, -- 주문 삭제 시 항목도 삭제
  product_id BIGINT NOT NULL REFERENCES product(id),
  quantity INT NOT NULL CHECK (quantity > 0),
  price_at_time NUMERIC NOT NULL, -- 주문 당시의 가격 (역사적 스냅샷)
  PRIMARY KEY (order_id, product_id) -- 복합 기본키
);
```
이 예에서 `ON DELETE RESTRICT`와 `ON DELETE CASCADE`의 선택은 비즈니스 규칙("고객 기록은 보존하되, 주문 삭제는 모든 항목을 정리한다")을 반영한 것입니다.

---

## 성능과 구조의 균형: 정규화와 그 너머

정규화(1NF, 2NF, 3NF, BCNF)는 이상 현상을 제거하고 데이터 중복을 최소화하는 이상적인 설계 목표입니다. 그러나 순수한 정규화가 항상 최고의 성능을 보장하는 것은 아닙니다. **반정규화**는 의도적으로 일부 중복을 도입하여 읽기 성능을 극적으로 향상시키는 전략입니다.

**반정규화의 전형적인 사례**
주문 목록을 조회할 때마다 `주문` 테이블과 `고객` 테이블을 조인하여 고객 이름을 가져오는 대신, `주문` 테이블에 `cached_customer_name` 컬럼을 추가하여 조인 없이 바로 이름을 표시할 수 있습니다.

그러나 이 선택은 무거운 책임을 동반합니다. 원본 데이터(`customer.name`)가 변경되면 모든 관련된 중복 복사본(`order.cached_customer_name`)을 동시에 업데이트해야 합니다. 이를 보장하지 않으면 시스템 내에 불일치 데이터가 영구적으로 남게 됩니다.

```sql
-- 고객 이름 변경 시 중복 데이터를 동기화하는 트리거
CREATE OR REPLACE FUNCTION sync_customer_name_to_orders()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.name IS DISTINCT FROM OLD.name THEN
    UPDATE "order"
    SET cached_customer_name = NEW.name
    WHERE customer_id = NEW.id; -- 동기화 로직
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```
반정규화는 성능 측정과 비용 분석을 거친 후, 명확한 동기화 메커니즘과 함께 신중하게 적용되어야 하는 **의도적 절충**입니다.

---

## 현대적 성능 최적화 기술

데이터 규모가 커짐에 따라 기본 인덱스 이상의 기술이 필요합니다.

*   **고급 인덱싱**: B-Tree 외에도, 특정 조건의 행만 인덱싱하는 **부분 인덱스**(`WHERE is_active = true`), 컬럼 표현식에 기반한 **함수 기반 인덱스**(`lower(email)`), 쿼리所需 모든 데이터를 포함해 테이블 접근을 완전히 회피하는 **커버링 인덱스**를 상황에 맞게 활용할 수 있습니다.
*   **파티셔닝**: 하나의 거대한 테이블을 물리적으로는 독립적이지만 논리적으로는 하나인 작은 단위(파티션)로 분할합니다. 날짜 기반 파티셔닝은 과거 데이터의 아카이빙과 최신 데이터에 대한 빠른 조회를 동시에 가능하게 합니다. 쿼리가 파티션 키를 조건으로 사용하면, 데이터베이스는 관련된 파티션만 스캔하는 **파티션 프루닝**을 수행하여 성능을 크게 향상시킵니다.
*   **실행 계획 분석**: `EXPLAIN ANALYZE` 명령은 데이터베이스가 쿼리를 어떻게 실행할지 보여주는 지도입니다. 이 지도를 읽어 Seq Scan 대신 Index Scan이 사용되는지, 어떤 조인 알고리즘(Hash Join, Nested Loop)이 선택되었는지, 예상 비용과 실제 행 수가 일치하는지 분석함으로써 성능 병목 현상을 정확히 진단할 수 있습니다.

---

## 운영, 보안, 그리고 생태계

견고한 데이터베이스 설계는 개발 단계에서 끝나지 않습니다. 지속적인 운영과 관리가 그 가치를 유지시킵니다.

*   **안전한 변경 관리**: 테이블 스키마 변경은 서비스 중단을 초래할 수 있습니다. `ALTER TABLE ... ADD COLUMN`과 같은 **온라인 DDL** 작업이 지원되는지 확인하고, 대규모 변경은 신중한 단계(새 컬럼 추가 → 데이터 이중 쓰기 → 이관 → 구 컬럼 제거)를 거쳐 수행해야 합니다. Flyway나 Liquibase 같은 마이그레이션 도구를 사용하면 변경 이력을 버전 관리하고 지속적 배포 파이프라인에 통합할 수 있습니다.
*   **세분화된 접근 제어**: **역할 기반 접근 제어(RBAC)**를 통해 사용자에게 필요한 최소 권한만 부여합니다. 더 나아가 **행 수준 보안(RLS)** 정책을 사용하면, 같은 테이블에 대해 "사용자는 자신의 주문만 볼 수 있다"와 같은 동적 필터링을 적용할 수 있어, 애플리케이션 로직 없이도 데이터 접근을 안전하게 통제할 수 있습니다.
*   **폴리글랏 지속성**: 관계형 데이터베이스는 만능 도구가 아닙니다. 현대적인 아키텍처는 각 저장소의 강점을 활용합니다. 트랜잭션과 복잡한 조인이 필요한 핵심 비즈니스 데이터는 RDB에, 세션 정보나 캐시는 Redis에, 전체 텍스트 검색은 Elasticsearch에, 대규모 분석은 데이터 웨어하우스(BigQuery, Snowflake)에 저장하는 **폴리글랏 퍼시스턴스** 접근법이 표준이 되었습니다.

---

## 결론: 관계형 데이터베이스의 지속적 가치

관계형 데이터베이스는 반세기 동안 그 근본적인 가치를 입증해왔습니다. 그 힘은 단순함과 수학적 엄밀함에 기반한 강력한 추상화에서 비롯됩니다. 테이블, 행, 열이라는 직관적인 모델은 비즈니스 도메인을 명확하게 표현하는 틀을 제공하며, 선언적 SQL은 데이터 조작의 복잡성을 효과적으로 감춥니다.

그러나 이 추상화는 마법이 아닙니다. 그것은 설계자의 책임 위에 세워집니다. 정규화를 통한 견고한 기초 구축, 외래키와 제약 조건을 통한 무결성의 적극적 보호, 인덱스와 파티셔닝을 통한 성능의 신중한 조정, 그리고 운영과 보안에 대한 지속적인 관심—이 모든 것이 결합될 때 비로소 관계형 모델의 진정한 잠재력이 실현됩니다.

기술의 풍경은 NoSQL, NewSQL, 클라우드 서비스로 빠르게 진화하고 있지만, 데이터를 구조화하고 관계를 정의하며 무결성을 보장해야 하는 근본적인 필요성은 변하지 않습니다. 관계형 데이터베이스는 이러한 필요성에 대한 검증된 답변으로서, 여전히 정형화된 데이터와 복잡한 트랜잭션의 세계에서 중심적인 위치를 차지하고 있습니다. 현명한 설계자라면 그 원리를 깊이 이해하고, 현대적 아키텍처의 맥락에서 이를 유연하게 적용하여, 변화하는 요구사항에 맞서 견고하고 유지보수 가능한 시스템을 구축할 것입니다.