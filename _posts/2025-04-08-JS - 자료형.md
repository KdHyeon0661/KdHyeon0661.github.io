---
layout: post
title: JavaScript - 자료형
date: 2025-04-08 21:20:23 +0900
category: JavaScript
---
# 자바스크립트 자료형 정리 (Primitive vs Object)

> **핵심 요약**
> - **기본형(Primitive)**: `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint` — **값 자체**가 변수에 담김, **불변적 성질**.
> - **참조형(Object)**: `object`(일반 객체, 배열, 함수, Date, RegExp, Map/Set/WeakMap/WeakSet, Error, TypedArray 등) — 변수엔 **참조(주소)**가 담김, 보통 **가변**.
> - 비교/산술 시 내부적으로 **ToPrimitive**(추상 연산), **박싱(Wrapper)**, **타입 강제 변환**이 일어날 수 있음.
> - 복사/전달/직렬화에서의 **얕은 vs 깊은 복사**, **순환 참조**, **심볼 키**, **BigInt** 등 **실전 함정**을 꼭 이해할 것.

---

## 7가지 기본형(Primitive) — 원리까지

### `number`

자바스크립트의 `number`는 **IEEE-754 배정밀도 부동소수점(64-bit)**.

```js
let a = 42;
let b = 3.14;
let c = Infinity;
let d = NaN;            // 숫자형 "아님" 결과지만 typeof는 'number'
let e = -0;             // 음의 0도 존재
console.log(typeof a, typeof d, 1 / e); // 'number' 'number' -Infinity
```

- `NaN` 비교: `NaN !== NaN` → 항상 false. 비교는 `Number.isNaN()` 사용.
- 안전 정수 범위: `Number.MIN_SAFE_INTEGER` ~ `Number.MAX_SAFE_INTEGER`.

**부동소수점 오차 예시**

```js
console.log(0.1 + 0.2);           // 0.30000000000000004
const eq = (x, y, eps = 1e-12) => Math.abs(x - y) < eps;
console.log(eq(0.1 + 0.2, 0.3));  // true
```

수식 표기를 해야 한다면:

$$
|x - y| < \varepsilon
$$

### `string`

UTF-16 코드 유닛 기반. **불변**.

```js
let s1 = "Hello";
let s2 = 'World';
let s3 = `Hello, ${s2}`; // 템플릿 리터럴
// s1[0] = 'h' 는 불가(불변). 새 문자열을 만들어야 함.
```

### `boolean`

```js
let isAdult = true;
let isLoggedIn = false;
```

- Truthy/Falsy 규칙 이해 필요: `0, -0, 0n, "", null, undefined, NaN`는 falsy.

### `null`

의도적으로 “값 없음”.

```js
let user = null;
console.log(typeof null); // 'object' - 역사적 버그
```

### `undefined`

할당되지 않은 상태 또는 반환값 없음.

```js
let v;
console.log(v); // undefined
```

### `symbol`

**고유한 식별자** 생성. 열거 불가(기본 for..in/JSON 직렬화에서 보이지 않음).

```js
const sym1 = Symbol("id");
const sym2 = Symbol("id");
console.log(sym1 === sym2); // false
const o = { [sym1]: 1, id: 2 };
console.log(Object.getOwnPropertySymbols(o)); // [Symbol(id)]
```

### `bigint`

아주 큰 정수 표현. `number`와 **혼합 산술 금지**.

```js
const big = 10n ** 30n;
console.log(typeof big); // 'bigint'
// console.log(big + 1);        // TypeError (1은 number)
// 꼭 BigInt로 맞추기:
console.log(big + 1n);
```

---

## 참조형(Object) — 계열별 특징

**객체**는 키-값 구조로 다양한 하위 타입 포함.

```js
const user = { name: "Alice", age: 25, isAdmin: false };
const list = [1, 2, 3];           // 배열(특수한 객체)
function greet() { console.log("Hello"); } // 함수(호출 가능한 객체)
```

### 배열(Array)

- **희소 배열**(큰 인덱스 건너뛰기)은 성능 저하 가능.
- 타입 혼합보다 **일관된 요소 타입**이 엔진 최적화에 유리.

```js
const arr = [];
arr[1000000] = 1; // 희소 -> 내부 구조 변화 가능
```

### 함수(Function)

- **일급 객체**: 변수에 할당/인자/반환값 가능.
- 스코프·클로저·this 바인딩 주의.

### 날짜/정규식/오류

```js
const d = new Date();
const r = /ab+c/i;
const e = new Error("oops");
```

### Map/Set vs Object/Array

- **Map**: 임의 키(객체 포함), 순서 보존, 크기 `size`.
- **Set**: 중복 없는 집합.
- **Object**: 문자열/심볼 키 위주, 프로토타입 상속 영향.
- **배열**: 인덱스 순회·길이 관리에 최적화.

```js
const m = new Map();
m.set({ k: 1 }, "v");
console.log(m.size); // 1

const s = new Set([1, 2, 2, 3]);
console.log([...s]); // [1, 2, 3]
```

### WeakMap/WeakSet

- 약한 참조(가비지 컬렉터에 의해 키가 수거 가능).
- **키로만 객체 가능**(WeakMap), 값 보관(WeakSet은 값 자체가 객체).
- **순회 불가**, 크기 조회 불가 → **메모리 캐시** 등에 유용.

---

## typeof / instanceof / toString.call — 타입 판별 총정리

| 값/표현                       | 결과/설명                                       |
|------------------------------|--------------------------------------------------|
| `typeof 123`                 | `"number"`                                       |
| `typeof "abc"`               | `"string"`                                       |
| `typeof true`                | `"boolean"`                                      |
| `typeof undefined`           | `"undefined"`                                    |
| `typeof null`                | `"object"` ← 역사적 버그                         |
| `typeof 123n`                | `"bigint"`                                       |
| `typeof Symbol()`            | `"symbol"`                                       |
| `typeof {}`                  | `"object"`                                       |
| `typeof []`                  | `"object"` → 배열 판별은 `Array.isArray()`       |
| `typeof function() {}`       | `"function"` (함수는 특수 표기)                  |
| `({}).toString.call([])`     | `"[object Array]"`                               |
| `({}).toString.call(null)`   | `"[object Null]"`                                |
| `({}).toString.call(undefined)` | `"[object Undefined]"`                       |
| `x instanceof Ctor`          | `Ctor.prototype`가 `x`의 프로토타입 체인에 있나? |

**권장 판별법**

```js
const isArray = Array.isArray;
const isPlainObject = (v) =>
  Object.prototype.toString.call(v) === "[object Object]";
```

---

## Primitive vs Object — 저장·복사·변경

| 항목           | Primitive                                  | Object/Reference                            |
|----------------|---------------------------------------------|---------------------------------------------|
| 저장 방식      | **값 자체**                                  | **참조(주소)**                               |
| 복사 시        | 값 복사                                      | 참조 복사(얕은 복사)                         |
| 변경 가능 여부 | 불변적 성질(새 값 대입 = 새 값 생성)          | 프로퍼티 변경 가능(대부분 가변)              |

```js
let a = 10;
let b = a;
b = 20;
console.log(a); // 10

let obj1 = { x: 1 };
let obj2 = obj1;
obj2.x = 9;
console.log(obj1.x); // 9 (같은 객체를 바라봄)
```

### 함수 인자 전달 — **항상 값-복사(call by value)**

- **참조 자체도 값**으로 복사된다(참조의 값 복사).
- 함수 안에서 **프로퍼티 수정**은 외부 객체에 반영, **재할당**은 외부에 영향 없음.

```js
function mutate(o) { o.x = 999; }
function reassign(o) { o = { x: 0 }; }

const obj = { x: 1 };
mutate(obj);
console.log(obj.x);  // 999

reassign(obj);
console.log(obj.x);  // 999 (변경 없음: 매개변수에 새 참조 대입했을 뿐)
```

---

## 박싱(Wrapper)과 ToPrimitive — 연산 시 내부 동작

- 기본형이 **메서드를 호출**할 때 일시적으로 **래퍼 객체**(`Number`, `String`, `Boolean`)가 생성될 수 있음.
- 비교/연산에서 **ToPrimitive**(힌트: `"number"`, `"string"`, `"default"`)와 **타입 강제 변환**이 개입.

```js
console.log("2" * 3);    // 6  -> "2"가 number로 강제 변환
console.log("2" + 3);    // "23" -> +는 문자열 연결을 우선
console.log([1,2] + [3]); // "1,23" -> 배열 ToPrimitive -> "1,2" + "3"
```

**사용자 정의 ToPrimitive**

```js
const money = {
  amount: 1000,
  [Symbol.toPrimitive](hint) {
    return hint === "string" ? `$${this.amount}` : this.amount;
  }
};
console.log(String(money)); // "$1000"
console.log(+money + 500);  // 1500
```

---

## 얕은 복사 vs 깊은 복사 — 스프레드, 구조 분해, Object.assign

### 얕은 복사(Shallow Copy)

```js
const a = { x: 1, y: { z: 2 } };
const b = { ...a };                 // 얕은 복사
const c = Object.assign({}, a);     // 얕은 복사
b.y.z = 999;
console.log(a.y.z); // 999 (중첩 객체는 참조 공유)
```

### 깊은 복사(Deep Copy)

1) **structuredClone**(표준, 순환 참조 지원, 심볼 키 제외)

```js
const a = { x: 1, y: { z: 2 } };
a.self = a; // 순환 참조
const d = structuredClone(a);
d.y.z = 999;
console.log(a.y.z); // 2
console.log(d.self === d); // true
```

2) **JSON 방식**: 함수/심볼/`undefined`/Date/Map/Set/BigInt 등 **손실** 발생

```js
const a2 = { d: new Date(), f() {}, s: Symbol(), u: undefined, b: 1n };
const j = JSON.parse(JSON.stringify(a2));
console.log(j); // { d: "2025-...", b: undefined? -> BigInt는 예외(에러), 함수/심볼/undefined는 손실 }
```

3) **라이브러리**(예: lodash `cloneDeep`) 또는 **수동 복사** 전략

---

## 배열/객체 조작 — 스프레드·구조분해의 함정과 패턴

```js
const user = { name: "A", meta: { score: 10 } };
const user2 = { ...user, name: "B" }; // meta는 공유(얕은 복사)
user2.meta.score++;
console.log(user.meta.score); // 11
```

**불변 업데이트(중첩 안전)**

```js
const next = {
  ...user,
  meta: { ...user.meta, score: user.meta.score + 1 }
};
```

**배열 병합/삽입**

```js
const arr = [1, 2, 3];
const nextArr = [...arr.slice(0, 1), 99, ...arr.slice(1)];
```

---

## 직렬화/역직렬화 — JSON vs structuredClone vs MessagePort

- **JSON**: 텍스트 교환 표준. **함수/심볼/undefined** 손실, **BigInt 미지원**.
- **structuredClone**: 대부분의 내장 타입 지원(함수/DOM 제외), 순환 참조 OK.
- **postMessage**(Worker/Window): 구조화 복제 알고리즘 사용.

```js
// 안전한 복제·전달
const cloned = structuredClone(source);
```

---

## 비교(== vs ===), 정렬, 포함 여부

### 동등(==) vs 일치(===)

- **항상 `===` 권장**. `==`는 암묵 변환 규칙이 복잡.

```js
console.log("" == 0);        // true
console.log(false == "0");   // true
console.log([] == 0);        // true
console.log([0] == 0);       // true
console.log(null == undefined); // true (특례)
console.log(null === undefined); // false
```

### 객체 비교는 참조 비교

```js
const o1 = { a: 1 }, o2 = { a: 1 };
console.log(o1 === o2); // false (내용 같아도 참조 다르면 false)
```

### 정렬 주의(문자열 정렬이 기본)

```js
console.log([10, 2, 30].sort());        // [10, 2, 30] -> ["10","2","30"] 기준
console.log([10, 2, 30].sort((a,b)=>a-b)); // [2, 10, 30]
```

### 포함 여부

```js
console.log([1,2,NaN].includes(NaN)); // true
console.log([1,2,NaN].indexOf(NaN));  // -1 (엄밀 동일성 비교의 차이)
```

---

## 객체 불변화 — freeze/seal/preventExtensions

```js
const o = { x: 1, y: { z: 2 } };
Object.freeze(o);
o.x = 2;                  // 무시(엄격모드면 TypeError)
o.y.z = 3;                // 바뀜! (얕은 freeze)
console.log(o.y.z);       // 3

// 깊은 freeze 예시
function deepFreeze(obj) {
  if (obj && typeof obj === "object" && !Object.isFrozen(obj)) {
    Object.freeze(obj);
    for (const k of Object.getOwnPropertyNames(obj)) deepFreeze(obj[k]);
    for (const s of Object.getOwnPropertySymbols(obj)) deepFreeze(obj[s]);
  }
  return obj;
}
```

---

## 심볼/접근자/비열거 프로퍼티 — 메타데이터 안전 저장

```js
const id = Symbol("id");
const user = { name: "Kim", [id]: 123 };
Object.defineProperty(user, "hidden", {
  value: "secret",
  enumerable: false
});
console.log(Object.keys(user));           // ['name']
console.log(Object.getOwnPropertySymbols(user)); // [Symbol(id)]
```

---

## 성능과 메모리 — 엔진 친화적 패턴

- **일관된 객체 셰이프(프로퍼티 추가 순서·유형 유지)**로 JIT 최적화 유도.
- 배열은 **희소/혼합 타입** 피하기.
- **박싱/언박싱·암묵 변환**이 잦은 코드 경계 정리.
- 대량 데이터는 **TypedArray**(수치 연산)나 **ArrayBuffer** 고려.

```js
// 숫자 전용 버퍼
const buf = new ArrayBuffer(8);
const view = new Float64Array(buf);
view[0] = Math.PI;
```

---

## 보안 — 타입·직렬화와 XSS/프로토타입 오염

- JSON 파싱은 **`JSON.parse`**로만 (eval 금지).
- **프로토타입 오염** 방지: 외부 입력을 그대로 `Object.assign`으로 루트에 병합 금지, **키 검증** 필수.
- DOM 삽입 시 **`textContent`** 사용, HTML 템플릿은 **안전 이스케이프**.

```js
// 안전 이스케이프 템플릿
function escapeHtml(s) {
  return String(s)
    .replaceAll("&","&amp;").replaceAll("<","&lt;")
    .replaceAll(">","&gt;").replaceAll(`"`,`&quot;`)
    .replaceAll("'","&#39;");
}
function html(strings, ...vals) {
  return strings.reduce((a, s, i) => a + s + escapeHtml(vals[i] ?? ""), "");
}
```

---

## 실전 예제 묶음

### 타입 안전 덧셈기 — `number`/`bigint`/`string` 구분

```js
function safeAdd(a, b) {
  const ta = typeof a, tb = typeof b;
  if (ta === "number" && tb === "number") return a + b;
  if (ta === "bigint" && tb === "bigint") return a + b;
  if (ta === "string" || tb === "string") return String(a) + String(b);
  throw new TypeError(`Unsupported: ${ta} + ${tb}`);
}

console.log(safeAdd(1, 2));     // 3
console.log(safeAdd(1n, 2n));   // 3n
console.log(safeAdd("a", 2));   // "a2"
```

### 깊은 비교(구조 동일성) — 순환 참조 지원

```js
function deepEqual(a, b, visited = new WeakMap()) {
  if (Object.is(a, b)) return true;
  if (typeof a !== "object" || a === null ||
      typeof b !== "object" || b === null) return false;

  if (visited.get(a) === b) return true;
  visited.set(a, b);

  const aKeys = Reflect.ownKeys(a);
  const bKeys = Reflect.ownKeys(b);
  if (aKeys.length !== bKeys.length) return false;

  for (const k of aKeys) {
    if (!bKeys.includes(k)) return false;
    if (!deepEqual(a[k], b[k], visited)) return false;
  }
  return true;
}

const o1 = { x: 1 }; o1.self = o1;
const o2 = structuredClone(o1);
console.log(deepEqual(o1, o2)); // true
```

### 안전한 클론 + 불변 업데이트 조합

```js
function updateScore(u, delta) {
  // 깊은 복제 후 수정 — 구조적 공유가 필요하면 Immer 같은 라이브러리 고려
  const next = structuredClone(u);
  next.meta.score += delta;
  return next;
}
```

### 타입 가드 유틸(런타임)

```js
const isNonNullObject = (v) => typeof v === "object" && v !== null;
const isFunction = (v) => typeof v === "function";
const isDate = (v) => Object.prototype.toString.call(v) === "[object Date]";
```

---

## typeof 요약 표 — 확장판

| 값/식                     | typeof            | 비고 |
|--------------------------|-------------------|-----|
| `NaN`, `Infinity`, `-0` | `"number"`        | 숫자 계열 |
| `123n`                  | `"bigint"`        | BigInt는 Number와 산술 혼합 금지 |
| `Symbol()`              | `"symbol"`        | 고유 식별자, JSON 직렬화 불가 |
| `null`                  | `"object"`        | 역사적 버그. 판별은 `v === null` |
| `[]`                    | `"object"`        | `Array.isArray(v)` 권장 |
| `()=>{}`                | `"function"`      | 함수는 특별히 function 리턴 |
| `new Date()`            | `"object"`        | 판별은 `toString.call(v)` |
| `undefined`             | `"undefined"`     | 미할당/반환 없음 |

---

## 체크리스트(실전 습관)

- [ ] 비교는 **항상 `===`**. `==`는 피함(특례: `null == undefined`).
- [ ] **얕은 복사**와 **깊은 복사**의 차이를 알고 적용: `structuredClone` 적극 활용.
- [ ] 직렬화는 **JSON 한계** 인지(함수/심볼/BigInt 손실). 필요 시 다른 포맷/바이너리/프로토콜 버퍼 고려.
- [ ] 배열은 **희소/혼합 타입** 지양. 객체는 **일관 셰이프** 유지.
- [ ] 타입 판별은 상황에 맞게: `typeof` / `Array.isArray` / `toString.call`.
- [ ] DOM 삽입은 `textContent` 기본, 템플릿엔 이스케이프.
- [ ] `BigInt`와 `Number` 혼합 금지. 변환은 명시적으로.
- [ ] 함수 인자는 **값-복사**임을 기억. 재할당 효과 없음, 프로퍼티 수정은 반영.

---

## 마무리

이 글은 기존의 **기본형/참조형 개요**를 기반으로, 엔진 동작(박싱·ToPrimitive·암묵 변환), **복사/전달/비교/직렬화**의 실전 함정, **Map/Set/WeakMap**과 같은 현대 컬렉션, **성능·보안**까지 확장하였다.
이해 포인트는 세 가지다.

1) **값 vs 참조**의 관점으로 생각하라.
2) 비교/연산/직렬화 시의 **숨은 변환**을 예측하라.
3) 복사/업데이트/판별을 **일관된 도구**로 다뤄라.
