---
layout: post
title: 파이썬 심화 - 숫자, 날짜, 시간 (1)
date: 2025-11-26 21:25:23 +0900
category: 파이썬 심화
---
# 숫자, 날짜, 시간 (1)

## 숫자 반올림과 정확한 계산

### 다양한 반올림 방법
```python
# 기본 round() 함수
print(round(3.14159, 2))      # 3.14
print(round(3.145, 2))        # 3.15 (반올림)
print(round(2.5))             # 2 (은행가 반올림)
print(round(3.5))             # 4 (은행가 반올림)

# 수학 모듈을 활용한 다양한 반올림
import math

num = 3.7
print(math.floor(num))        # 3 (내림)
print(math.ceil(num))         # 4 (올림)
print(math.trunc(num))        # 3 (소수점 버림)

# 사용자 정의 반올림
def custom_round(num, decimal_places=0):
    factor = 10 ** decimal_places
    return math.floor(num * factor + 0.5) / factor

print(custom_round(2.5))      # 3 (전통적인 반올림)
print(custom_round(2.4))      # 2
```

### 정확한 10진수 계산 (Decimal 모듈)
```python
from decimal import Decimal, getcontext

# 부동소수점의 정밀도 문제
print(0.1 + 0.2)               # 0.30000000000000004
print(0.1 + 0.2 == 0.3)        # False

# Decimal을 사용한 정확한 계산
print(Decimal('0.1') + Decimal('0.2'))  # 0.3
print(Decimal('0.1') + Decimal('0.2') == Decimal('0.3'))  # True

# 정밀도 설정
getcontext().prec = 6  # 전체 자릿수 설정
result = Decimal(1) / Decimal(7)
print(result)  # 0.142857

# 금융 계산 예제
price = Decimal('19.99')
quantity = Decimal('3')
tax_rate = Decimal('0.10')

subtotal = price * quantity
tax = subtotal * tax_rate
total = subtotal + tax

print(f"소계: {subtotal}")     # 59.97
print(f"세금: {tax}")          # 5.997
print(f"총계: {total}")        # 65.967
```

## 숫자 서식화와 출력

### 다양한 숫자 포맷팅
```python
# format() 메서드 사용
num = 1234567.89123456

print(f"기본: {num}")                          # 1234567.89123456
print(f"소수점 2자리: {num:.2f}")               # 1234567.89
print(f"천단위 구분: {num:,.2f}")               # 1,234,567.89
print(f"지수 표기: {num:.2e}")                  # 1.23e+06
print(f"퍼센트: {0.256:.1%}")                   # 25.6%
print(f"퍼센트: {0.256:.2%}")                   # 25.60%

# 너비와 정렬 지정
numbers = [1234.56, 78.9, 123456.78]
for n in numbers:
    print(f"{n:>15,.2f}")  # 오른쪽 정렬, 15자리 너비
#       1,234.56
#          78.90
#     123,456.78

# 다양한 진법 표시
print(f"이진수: {42:b}")       # 101010
print(f"8진수: {42:o}")        # 52
print(f"16진수(소문자): {42:x}")  # 2a
print(f"16진수(대문자): {42:X}")  # 2A
```

## 2진수, 8진수, 16진수 작업

### 다양한 진법 변환과 연산
```python
# 리터럴 표기법
binary = 0b1010       # 10진수 10
octal = 0o12          # 10진수 10
hexadecimal = 0xA     # 10진수 10

print(binary, octal, hexadecimal)  # 10 10 10

# 진법 변환 함수
num = 255
print(bin(num))       # '0b11111111'
print(oct(num))       # '0o377'
print(hex(num))       # '0xff'

# 문자열에서 변환
print(int('1010', 2))     # 10
print(int('12', 8))       # 10
print(int('A', 16))       # 10
print(int('FF', 16))      # 255

# 비트 연산
a = 0b1100  # 12
b = 0b1010  # 10

print(f"a & b: {bin(a & b)}")    # 0b1000 (AND)
print(f"a | b: {bin(a | b)}")    # 0b1110 (OR)
print(f"a ^ b: {bin(a ^ b)}")    # 0b0110 (XOR)
print(f"~a: {bin(~a & 0b1111)}") # 0b0011 (NOT, 마스킹)
print(f"a << 2: {bin(a << 2)}")  # 0b110000 (왼쪽 시프트)
print(f"a >> 1: {bin(a >> 1)}")  # 0b0110 (오른쪽 시프트)

# 비트 플래그 예제
READ = 0b0001    # 1
WRITE = 0b0010   # 2
EXECUTE = 0b0100 # 4
DELETE = 0b1000  # 8

user_permissions = READ | WRITE  # 읽기와 쓰기 권한
print(f"권한: {bin(user_permissions)}")  # 0b11

# 권한 확인
has_read = user_permissions & READ
has_delete = user_permissions & DELETE

print(f"읽기 권한: {bool(has_read)}")    # True
print(f"삭제 권한: {bool(has_delete)}")  # False
```

## 바이트에서 큰 숫자 패킹/언패킹

### 구조체 모듈 활용
```python
import struct

# 숫자를 바이트로 패킹
num = 1234567890

# 다양한 형식으로 패킹
packed_int = struct.pack('>I', num)      # 빅 엔디안 4바이트
packed_long = struct.pack('>Q', num)     # 빅 엔디안 8바이트
packed_float = struct.pack('>f', 123.45) # 빅 엔디안 float

print(f"패킹된 int: {packed_int}")
print(f"패킹된 long: {packed_long}")
print(f"패킹된 float: {packed_float}")

# 바이트에서 숫자 언패킹
unpacked_int = struct.unpack('>I', packed_int)[0]
unpacked_long = struct.unpack('>Q', packed_long)[0]
unpacked_float = struct.unpack('>f', packed_float)[0]

print(f"언패킹된 int: {unpacked_int}")
print(f"언패킹된 long: {unpacked_long}")
print(f"언패킹된 float: {unpacked_float}")

# 여러 값 패킹/언패킹
values = (100, 3.14, b'AB')
packed = struct.pack('>Id2s', *values)  # int, double, 2바이트 문자열
print(f"복합 패킹: {packed}")

unpacked = struct.unpack('>Id2s', packed)
print(f"복합 언패킹: {unpacked}")

# 네트워크 바이트 순서 (빅 엔디안)
network_order = struct.pack('!H', 1000)  # 네트워크 바이트 순서
host_order = struct.unpack('!H', network_order)[0]
print(f"네트워크 순서: {network_order}")
print(f"호스트 순서: {host_order}")

# 실제 예제: RGB 색상 패킹
def pack_rgb(r, g, b):
    """RGB 값을 4바이트로 패킹 (알파 채널 포함)"""
    return struct.pack('BBBB', r, g, b, 255)  # 알파는 255(불투명)

def unpack_rgb(data):
    """4바이트에서 RGB 값 언패킹"""
    return struct.unpack('BBBB', data)

rgb_data = pack_rgb(255, 128, 0)
print(f"RGB 패킹: {rgb_data}")  # b'\xff\x80\x00\xff'

r, g, b, a = unpack_rgb(rgb_data)
print(f"언패킹 RGB: ({r}, {g}, {b}, {a})")  # (255, 128, 0, 255)
```

## 복소수 계산

### 복소수 기본 연산
```python
# 복소수 생성
z1 = 3 + 4j
z2 = complex(1, 2)  # 1 + 2j
z3 = 2 - 3j

print(f"z1 = {z1}")  # (3+4j)
print(f"z2 = {z2}")  # (1+2j)

# 기본 연산
print(f"덧셈: {z1 + z2}")      # (4+6j)
print(f"뺄셈: {z1 - z2}")      # (2+2j)
print(f"곱셈: {z1 * z2}")      # (-5+10j)
print(f"나눗셈: {z1 / z2}")    # (2.2-0.4j)

# 복소수 속성
print(f"실수부: {z1.real}")    # 3.0
print(f"허수부: {z1.imag}")    # 4.0
print(f"켤레복소수: {z1.conjugate()}")  # (3-4j)

# 복소수 모듈 활용
import cmath

# 크기(절대값)와 위상각
z = 1 + 1j
magnitude = abs(z)  # 또는 cmath.polar(z)[0]
phase = cmath.phase(z)

print(f"크기: {magnitude:.4f}")        # 1.4142
print(f"위상각: {phase:.4f} 라디안")    # 0.7854 라디안
print(f"위상각: {math.degrees(phase):.2f} 도")  # 45.00 도

# 극좌표 변환
polar = cmath.polar(z)  # (크기, 위상각)
print(f"극좌표: 크기={polar[0]:.4f}, 각도={polar[1]:.4f}")

# 직교좌표로 복원
rect = cmath.rect(polar[0], polar[1])
print(f"직교좌표 복원: {rect}")  # (1+1j)

# 복소수 함수
print(f"제곱근: {cmath.sqrt(z)}")       # (1.09868+0.45509j)
print(f"지수: {cmath.exp(z)}")          # (1.46869+2.28736j)
print(f"로그: {cmath.log(z)}")          # (0.34657+0.78540j)
print(f"사인: {cmath.sin(z)}")          # (1.29846+0.63496j)
print(f"코사인: {cmath.cos(z)}")         # (0.83373-0.98890j)

# 실제 응용: RLC 회로 계산
def impedance_rlc(R, L, C, frequency):
    """
    RLC 회로의 임피던스 계산
    R: 저항 (옴), L: 인덕턴스 (헨리), C: 커패시턴스 (패럿)
    frequency: 주파수 (헤르츠)
    """
    omega = 2 * math.pi * frequency  # 각주파수
    Z_R = R
    Z_L = complex(0, omega * L)      # jωL
    Z_C = complex(0, -1/(omega * C)) # 1/(jωC) = -j/(ωC)
    
    total_impedance = Z_R + Z_L + Z_C
    return total_impedance

# RLC 회로 예제
R = 100    # 100Ω
L = 0.001  # 1mH
C = 0.000001  # 1μF
freq = 1000  # 1kHz

Z = impedance_rlc(R, L, C, freq)
magnitude = abs(Z)
phase = math.degrees(cmath.phase(Z))

print(f"\nRLC 회로 임피던스:")
print(f"총 임피던스: {Z}")
print(f"크기: {magnitude:.2f} Ω")
print(f"위상각: {phase:.2f} 도")
```

## 결론

Python의 숫자 처리 기능은 단순한 산술 연산을 넘어 과학, 공학, 금융 등 다양한 분야에서 필요한 고급 기능을 제공합니다. 반올림의 경우 `round()` 함수의 동작을 정확히 이해하고, 필요에 따라 `math` 모듈의 함수들을 활용할 수 있어야 합니다. 금융 계산과 같이 정밀도가 중요한 경우 `decimal` 모듈의 `Decimal` 클래스를 사용해야 부동소수점 오차를 피할 수 있습니다.

숫자 서식화는 데이터 가독성을 높이는 중요한 요소입니다. f-string과 format 메서드를 활용하여 천단위 구분, 소수점 정밀도, 다양한 진법 표시 등을 효과적으로 처리할 수 있습니다. 특히 2진수, 8진수, 16진수 작업은 저수준 프로그래밍이나 하드웨어 제어에서 필수적이며, 비트 연산을 통해 메모리 효율적인 코드를 작성할 수 있습니다.

바이트 단위의 데이터 처리는 네트워크 프로그래밍, 파일 형식 처리, 하드웨어 통신 등에서 핵심 기술입니다. `struct` 모듈을 이용하면 다양한 데이터 타입을 바이트 스트림으로 효율적으로 패킹하고 언패킹할 수 있습니다.

복소수 계산은 전기공학, 신호 처리, 물리학 등에서 광범위하게 사용됩니다. Python의 복소수 지원과 `cmath` 모듈은 이러한 분야의 수학적 계산을 직관적이고 효율적으로 수행할 수 있게 해줍니다.

각 도구와 기법은 특정 문제 영역에 최적화되어 있으므로, 작업의 요구사항을 정확히 이해하고 상황에 맞는 적절한 방법을 선택하는 것이 중요합니다. Python의 풍부한 숫자 처리 라이브러리들을 효과적으로 활용하면 복잡한 수치 계산 문제도 체계적으로 해결할 수 있습니다.