---
layout: post
title: 컴퓨터시스템 - 최적화 컴파일러
date: 2025-08-01 14:20:23 +0900
category: 컴퓨터시스템
---
# 최적화 컴파일러의 능력과 한계

## 개요 — 목표와 제약

**목표**
컴파일러 최적화의 목표는 **프로그램의 의미(정의된 동작)를 보존**하면서 **성능(시간/메모리/전력)** 을 개선하는 것이다. 이를 위해 컴파일러는 **IR(중간표현, 주로 SSA)** 위에서 정적 분석과 변환을 수행한다: 상수 폴딩, 공통부분식 제거, 루프 변환, 인라인, 레지스터 할당, 벡터화, 코드 레이아웃 최적화 등.

**제약(한계)**
컴파일러는 런타임의 모든 사실을 알 수 없다. **입력 데이터/외부 I/O/스레드 상호작용/메모리 모델/예외적 제어 전이/언어 규격의 UB(Undefined Behaviour)** 때문에 많은 변환은 **증명 가능한 경우에만** 적용된다. 또한 마이크로아키텍처(캐시, 분기예측, 파이프라인, 포트 사용, 메모리 병렬성) 영향으로 **정적 최적화가 항상 실제 성능 상승을 보장하진 않는다.**

---

## 1. 최적화의 분류(큰 틀)

- **지역(Local)**: 기본 블록 내부 (상수 폴딩, DCE, CSE, copy-prop, peephole).
- **전역(Global, 함수 내부)**: 함수 전체(전역 CSE, LICM, 루프 변환, 레지스터 할당).
- **절차간(Interprocedural, Whole Program)**: 함수 경계 너머 분석/변환(인라인, 전역 상수 전파, devirtualization, 함수 특수화).
- **링크 타임(LTO/ThinLTO)**: 번역 단위 결합 후 전체 프로그램 대상으로 IPO 수행.
- **프로파일 기반(PGO)**: 실행 프로파일로 **핫 경로**를 공격적으로 최적화.
- **JIT/동적 최적화**: 런타임 정보(실제 타입, 분기 확률, 상수 인자)로 재컴파일/특화.

---

## 2. 대표 최적화 기법과 작동 원리(조건과 한계 포함)

### 2.1 상수 폴딩 · 상수 전파(Constant Folding/Propagation)

- **무엇**: 컴파일 타임에 계산 가능한 식을 미리 계산하거나, 상수를 데이터/제어 흐름에 전파.
- **예**
```c
int a = 2 * (3 + 4);   // → int a = 14;
```
- **한계**: 부동소수점은 반올림·예외(Inf/NaN·signed zero) 규칙이 개입. 외부 효과(volatile, I/O) 포함 식은 폴딩 금지.

### 2.2 죽은 코드/대입 제거(DCE/DSE)

- **무엇**: 결과에 영향을 주지 않는 연산/대입 제거.
```c
int f(){ int x=3; x=4; return 5; } // x 관련 코드 제거
```
- **한계**: **부수효과**가 있으면 제거 불가(volatile, I/O, inline asm, setjmp/longjmp와의 상호작용 등).

### 2.3 공통부분식 제거(GVN/CSE)

- **무엇**: 같은 식을 반복 계산하지 않고 재사용(전역 값 번호부여 GVN).
- **한계**: **별칭(aliasing)** 으로 메모리 읽기 값이 바뀔 수 있으면 보수적으로 포기.

### 2.4 강도 감소(Strength Reduction) · 인덕션 변수 간소화(IV Simplification)

- **무엇**: 곱셈→시프트, 나눗셈→곱셈, 지수→누적 덧셈 대체.
```c
for(int i=0;i<n;i++) y[i] = base + i*8;      // before
for(int i=0,v=base;i<n;i++,v+=8) y[i] = v;   // after
```
- **한계**: FP 정밀도·예외 규정, 포인터 wrap-around, 미세한 레이턴시/포트 배분 영향.

### 2.5 루프 변환: LICM / Unroll / Fusion-Fission / Interchange / Tiling / Peeling

- **LICM(불변 코드 호이스팅)**: 루프 내 불변 표현식을 밖으로 이동.
- **Unrolling**: 루프 본문 복제로 분기 오버헤드 감소·ILP 증가(코드 크기↑, 레지스터 압박↑).
- **Fusion/Fission**: 루프 결합으로 캐시 재사용↑ 또는 분할로 병렬화/레지스터 압박 완화.
- **Interchange**: 중첩 루프 순서 교체로 메모리 지역성 개선(행/열 접근).
- **Tiling/Blocking**: 캐시 크기에 맞춘 블록으로 나눠 데이터 재사용 극대화(행렬 연산의 왕도).
- **Peeling**: 정렬/경계 문제 해결을 위해 일부 반복을 분리.

### 2.6 인라인(Inlining)

- **무엇**: 함수 본문을 호출 지점에 복사 — 호출 오버헤드 제거 + 추가 최적화 기회(상수 전파, DCE).
- **한계**: **코드 팽창 → I-캐시 압박**, 인라이너 휴리스틱/PGO 의존. 가상/함수 포인터 호출은 devirtualization 없인 인라인 불가.

### 2.7 레지스터 할당(Register Allocation) · 스필/리로드

- **무엇**: SSA의 가상 레지스터를 물리 레지스터로 색칠(graph coloring/linear scan).
- **한계**: NP-완전 근사. 레지스터 압박 → **스필 발생**(메모리 접근 증가로 급격한 성능 저하).

### 2.8 명령어 스케줄링(Scheduling) · If-Conversion(분기→마스크)

- **무엇**: 의존성 없는 명령을 재배치해 파이프라인 버블 제거, VLIW/슈퍼스칼라 자원 활용.
- **If-Conversion**: 짧은 분기를 predication/마스크로 변환해 분기 미스 비용 회피.
- **한계**: 메모리 의존성 보수적 추정, predication이 오히려 불리할 수도 있음.

### 2.9 벡터화(Vectorization, SIMD)

- **무엇**: 동일 연산을 다수 데이터에 병렬 적용(AVX2/AVX-512/SVE2 등).
```c
void saxpy(int n, float *restrict x, float *restrict y, float a){
  #pragma omp simd
  for (int i=0;i<n;i++) y[i] += a*x[i];
}
```
- **조건**: 별칭 없음(`restrict`), 루프 캐리 의존 없음, 정렬/alignment, 예외/NaN 처리 규정.
- **한계**: gather/scatter 비용, 불규칙 접근, 분기 많은 루프, FP 규칙의 엄격 모드.

### 2.10 인터프로시저(IPO) · Devirtualization · 함수 특수화(Cloning)

- **무엇**: 호출 그래프 전역 분석으로 인라인, 상수 인자 특수화, 가상호출→직접호출 변환.
- **한계**: 동적 링크/의미적 인터포지션, DSO 경계, 가시성 정책이 방해. LTO/PGO 도움 필요.

### 2.11 코드 레이아웃 · 핫/콜드 분리 · 분기 재배치

- **무엇**: 핫 경로를 연속 배치, 콜드 블록은 분리(예외 경로 분리) → I-캐시/TLB 효율 개선.
- **수단**: PGO, -fprofile-use, -freorder-blocks-and-partition, hot/cold 함수 속성 등.

---

## 3. 분석 인프라(컴파일러가 ‘알게 되는’ 방식)

### 3.1 SSA(Static Single Assignment)

- 각각의 가상 레지스터가 **한 번만 대입**되는 형태 → def-use 체인·데이터 흐름 분석이 단순해진다.
- **Phi** 노드로 합류점에서의 값 선택을 표현.

### 3.2 별칭/포인터 분석(Alias/Points-to)

- **Type-based(TBAA)**, **flow-/context-sensitive** 분석으로 포인터가 서로 같은 위치를 가리키는지 판단.
- C의 **엄격 별칭 규칙(strict aliasing)** 가정 하에서 더 공격적 최적화 가능(위반 시 UB).

### 3.3 범위/부호/정렬 분석 · 루프 의존 분석(폴리헤드럴)

- 값의 범위(overflow 가능성), 정렬, 루프 의존성(데이터 의존 그래프)를 분석해 **LICM/타일링/벡터화**의 적용 여부를 판정.

---

## 4. 왜 ‘항상’ 최선이 아닌가 — 본질적 한계

### 4.1 정보 비대칭(컴파일 타임 vs 런타임)

컴파일러는 **런타임 값/타이밍/스케줄링/입출력/캐시 상태**를 정확히 모른다. 그러므로 **증명 불가**에 직면하면 보수적으로 포기한다.
```c
void foo(int *a, int *b){
  *a = 42;
  *b = *b + 1; // a==b 가능성 → 순서 교체 불가
}
```

### 4.2 계산 불가능성(Undecidability)

일반 프로그램 속성(루프 종료, 조건 불변성 등)은 튜링 장벽 때문에 **결정 불가능**. 근사/휴리스틱/프로파일에 의존.

### 4.3 외부 효과·비결정성

- 시스템 콜, 파일, 장치 I/O
- signal/setjmp/longjmp
- 스레드와 **메모리 모델(C/C++ atomics)**
→ 컴파일러는 `volatile`/`atomic`/fence/순서 규칙을 존중하며 최적화 범위가 제한된다.

---

## 5. 언어 규격과 컴파일러의 ‘특권’ — Undefined Behaviour(UB)

C/C++의 많은 동작(부호 있는 overflow, use-after-free, 미정의 시퀀스 포인트 등)이 UB다. 컴파일러는 **UB가 없다고 가정**하고 자유롭게 최적화할 수 있어, 실제로 UB가 발생하면 동작이 예측 불가해진다.

**예시**
```c
// signed overflow is UB
int foo(int x){
  if (x + 1 > x) return 1;  // 컴파일러는 항상 참으로 최적화 가능
  else return 2;
}
```
`x == INT_MAX` 환경 등에서 기대와 다르게 동작해도 규격상 문제 없다. **결론: UB는 성능 최적화의 동력인 동시에, 실무에서 가장 위험한 함정**이다.

---

## 6. 별칭(aliasing) — 최적화의 최대 걸림돌

```c
void f(int *x, int *y){
  int a = *x + *x; // 두 번 로드 vs 재사용
  *y = *x + 1;     // x==y 가능성 → a 재사용 불가
}
```
**대응**
- **C99 `restrict`** 로 겹치지 않음을 보장:
```c
void saxpy(int n, float *restrict x, float *restrict y, float a){
  for(int i=0;i<n;i++) y[i] += a*x[i]; // 벡터화·재배치 가능성↑
}
```
- API 설계에서 **읽기/쓰기 경로 분리**, 불필요한 별칭 제거.

---

## 7. 동시성과 메모리 모델

- **C/C++ atomics**: `memory_order_relaxed/acquire/release/acq_rel/seq_cst` 에 따라 허용되는 재배열/가시성 다름.
- **데이터 레이스 없는 프로그램(DRF)** 에서만 언어 보장이 힘을 발휘한다.
- 최적화는 **as-if rule**(관측 가능한 동작 보존) 안에서 허용되지만, atomics/fence/volatile는 강한 제약을 부여한다.

---

## 8. 실전: 최적화가 막히는 패턴과 해결

### 8.1 별칭으로 인한 CSE/벡터화 실패

**before**
```c
void axpy(int n, float *x, float *y, float a){
  for(int i=0;i<n;i++) y[i] = y[i] + a*x[i];
}
```
**after**
```c
void axpy(int n, float *restrict x, float *restrict y, float a){
  #pragma omp simd
  for(int i=0;i<n;i++) y[i] += a*x[i];
}
```
핵심: `restrict` + `simd` 힌트로 벡터화와 불필요 재로드 제거.

### 8.2 volatile/I/O — DSE 금지

```c
volatile int *port=(volatile int*)0x40000000;
void poke(){ *port = 1; } // 제거/재배열 금지
```

### 8.3 setjmp/longjmp, signal 핸들러

로컬 변수의 수명/값 보장이 달라져 최적화 제약. 이런 코드에서는 과감한 레이아웃/인라인이 제한될 수 있다.

### 8.4 함수 포인터/가상 호출

정적 컴파일러는 **대상 함수 불명** → 인라인/특수화 불가. LTO/PGO로 call site의 분포를 학습하거나 설계를 바꿔 **devirtualization** 기회를 만든다.

---

## 9. 벡터화 심화 — 조건, 장벽, 해결책

- **조건**: 루프 캐리 의존 X, 별칭 X, 정렬/연속 접근, 예외/NaN 가정, 확실한 경계 길이.
- **장벽**:
  - 함수 호출(특히 외부) → 인라인 필요
  - 분기 다수 → **마스킹(if-conversion)**
  - 불규칙 접근 → gather/scatter 비용, **타일링/재배열로 규칙화**
- **정렬**: `aligned_alloc`/`posix_memalign`, `__builtin_assume_aligned` 로 힌트 제공.
- **경계 처리**: peeling(앞/뒤 몇 원소 분리) + 정렬된 본루프.

---

## 10. 레이턴시 vs 대역폭 vs 메모리 병렬성(MLP)

성능은 종종 다음으로 설명된다:
$$
\text{CPU time} = \frac{\text{Instructions}\times \text{CPI}}{f}
$$
- **CPI** 를 낮추려면: 분기 미스↓, 캐시 미스↓, 포트 충돌↓, 스톨↓.
- **메모리 바운드** 판정(roofline):
$$
\text{Attainable Perf}=\min(\text{Peak FLOPs}, \ \text{AI}\times \text{Peak BW}),\quad
\text{AI}=\frac{\text{FLOPs}}{\text{Bytes moved}}
$$
- **AI↑**: 블로킹/타일링/재사용/SoA, **MLP↑**: 프리패치/동시 outstanding miss 증가(스레드/태스크).

---

## 11. 링크 타임 최적화(LTO/ThinLTO) · PGO — 강력한 현실 해법

- **LTO**: 번역 단위 경계를 허물어 **교차 TU 인라인, 전역 상수 전파, dead code 제거, 레이아웃 최적화**를 수행.
- **PGO**: 실제 실행 히트 데이터로 **인라이너/레이아웃/분기 힌트**를 조정해 **I-캐시/분기/IPC**를 동시 개선.

**권장 빌드 스텝(Clang 예)**
```bash
# 1. 프로파일 생성
clang -O3 -fprofile-generate -march=native -fvisibility=hidden -fno-semantic-interposition app.c -o app.gen
./app.gen <train_inputs>

# 2. 프로파일 사용 + ThinLTO
clang -O3 -fprofile-use=default.profdata -flto=thin -march=native \
      -fvisibility=hidden -fno-semantic-interposition *.o -o app
```
- `-fvisibility=hidden` / `-fno-semantic-interposition` 로 **인터포지션 비용 감소** 및 devirtualization 가능성↑.

---

## 12. 부동소수점 최적화의 주의점

- IEEE-754 모드에서 컴파일러는 **재배열 제한**(정확성 우선).
- `-ffast-math` 계열은 NaN/Inf/서브노멀/부호있는 0 등의 규칙을 완화해 벡터화/강도감소/합병을 공격적으로 허용한다.
- **실무 지침**: 핵심 루틴 한정, **허용 오차**·**검증**을 갖추고 사용.

---

## 13. 자동 병렬화의 현실

- 루프 병렬화는 **의존성 증명**이 필요. 포인터/함수 호출/불규칙 접근/전역 상태가 있으면 자동 병렬화는 보수적으로 포기한다.
- 실무에서는 **OpenMP/TBB** 등 명시적 병렬화를 권장.
```c
#pragma omp parallel for schedule(static)
for (int i=0;i<n;i++) y[i] = a*x[i] + y[i];
```

---

## 14. 툴과 플래그 — 최적화의 가시화/검증

### 14.1 컴파일러 리포트

- Clang/LLVM: `-Rpass=.`(성공), `-Rpass-missed=.`(실패), `-Rpass-analysis=.` (분석 근거),
  `-fsave-optimization-record`(+yaml) → 어떤 최적화가 걸렸는지 추적.
- GCC: `-fopt-info-vec-optimized`, `-fopt-info-vec-missed`, `-fdump-tree-*`.

### 14.2 어셈/성능 계측

- `objdump -d`, `llvm-objdump -d`, Compiler Explorer(godbolt)
- `perf stat -e cycles,instructions,branch-misses,L1-dcache-loads,LLC-load-misses`
- `perf record/report`, Intel VTune, `llvm-mca`(마이크로아키텍처 모델)

### 14.3 마이크로벤치 주의

- **워밍업**(캐시/브랜치 안정), **고정 클럭/고정 코어 고정**(CPU 주파수 변동/터보/스케줄러 영향 제거), **중앙값+IQR** 보고.
- **입력 다양화**(편향된 히트율 방지).

---

## 15. 안전한 최적화 사용 지침(실무 체크리스트)

- [ ] **UB 금지**: 부호 있는 overflow, OOB, UAF, 미정의 순서 등 제거.
- [ ] **별칭 축소**: `restrict`/API로 alias 관계를 끊어줌.
- [ ] **volatile/I/O 최소화**: 필요한 곳에만 사용(최적화 장벽).
- [ ] **벡터화 전제**: 정렬/연속 접근/분기 마스킹 설계.
- [ ] **PGO+LTO**: 핫 경로 집중 최적화(ROI가 가장 좋다).
- [ ] **수치 정확성**: `-ffast-math` 사용 시 허용 오차/테스트 확보.
- [ ] **메모리 모델 준수**: atomics/fence/happens-before 이해·준수.
- [ ] **코드 크기 관리**: 인라인/언롤링으로 I-캐시 압박 유발 여부 점검.
- [ ] **회귀 검증**: 최적화 전후 correctness/perf 회귀 테스트.

---

## 16. 예제 모음(구체 코드 + 전후 효과)

### 16.1 불필요 메모리 참조 제거와 레지스터 캐싱

**before**
```c
int f(int *p){
  int s = *p;      // load
  *p = s + 1;      // store
  return *p;       // load (재로드)
}
```
**after**
```c
int f_opt(int *p){
  int s = *p;
  s = s + 1;
  *p = s;
  return s;        // 레지스터 반환 → 불필요 load 제거
}
```

### 16.2 함수 경계가 벡터화/호이스팅을 막는 경우

**before**
```c
extern int g(); // 부수효과를 가질 수 있다고 가정
int h(int *a, int n){
  int s = 0;
  for(int i=0;i<n;i++) s += a[i] * g();
  return s;
}
```
**after(계약 강화/인라인/속성)**
```c
// g는 인자·메모리 읽기만: pure 속성(플랫폼 의존) 또는 inlining
static inline int g_pure(int c){ return c; }

int h2(int *a, int n, int c){
  int gc = g_pure(c); // 루프 외 단일 로드/계산
  int s = 0;
  #pragma omp simd reduction(+:s)
  for(int i=0;i<n;i++) s += a[i] * gc;
  return s;
}
```

### 16.3 인터포지션과 devirtualization

동적 링크/기호 가시성 때문에 **직접호출 가정 불가 → 인라인/상수 전파/분기 제거 불가**.
**대응**: `-fvisibility=hidden` + 내부 API에 한해 공개 기호 축소, 필요 시 `-fno-semantic-interposition`, LTO로 해소.

### 16.4 타일링/블로킹으로 AI↑

**단순 행렬 곱**
```c
for(int i=0;i<N;i++)
  for(int j=0;j<N;j++)
    for(int k=0;k<N;k++)
      C[i*N+j] += A[i*N+k]*B[k*N+j];
```
**블록 버전(개념)**
```c
for(int ii=0; ii<N; ii+=B)
  for(int jj=0; jj<N; jj+=B)
    for(int kk=0; kk<N; kk+=B)
      for(int i=ii; i<min(ii+B,N); i++)
        for(int j=jj; j<min(jj+B,N); j++){
          float acc = C[i*N+j];
          for(int k=kk; k<min(kk+B,N); k++)
            acc += A[i*N+k]*B[k*N+j];
          C[i*N+j] = acc;
        }
```
핵심: 워킹셋을 캐시에 맞춰 **데이터 재사용↑ → 메모리 대역 제약 완화**.

---

## 17. 보안/안전과 최적화의 충돌

- **스펙터 완화(retpoline, lfence 등)**: 간접 분기/스펙ulative 실행 억제로 성능 영향.
- **스택 보호/ASLR/CFI**: 코드 레이아웃/인라인/PLT 호출 형태에 영향.
- **정적 분석/UBSan/ASan/TSan**: 개발/테스트에서 켜고, 릴리스 빌드에선 해제(혹은 샘플링)하여 성능-안전을 균형.

---

## 18. 언어·툴체인 보충 참고

- **GCC/Clang**: `-O3 -march=native -fstrict-aliasing -fno-semantic-interposition -fvisibility=hidden -flto[=thin]`
- **PGO**: `-fprofile-generate / -fprofile-use`
- **보고서**: Clang `-Rpass*`, GCC `-fopt-info*`
- **MSVC**: `/O2 /GL`(LTCG) `/Gy`(function sections) `/Gw`(data) + PGO(`/GENPROFILE`/`/USEPROFILE`)
- **Rust**: `-C opt-level=3 -C target-cpu=native -C lto=fat/thin -C codegen-units=1 -Z perf`(야간 기능 주의)

---

## 19. 요약

- 컴파일러는 **IR 분석 + 휴리스틱/프로파일**로 강력한 최적화를 수행하지만, **별칭/외부 효과/동시성/UB/링크 경계** 때문에 항상 최선은 아니다.
- **현실적인 해법**:
  1) 코드·데이터 레이아웃을 **벡터화/캐시 친화**로 설계,
  2) `restrict`·속성·가시성으로 **제약을 명시**,
  3) **PGO+LTO**로 핫 경로에 인라인/레이아웃/분기 최적화 집중,
  4) 최적화 전후를 **계측**해 회귀 없이 실제 성능을 얻는다.

---

## 20. 부록 — 미니 벤치 템플릿/계측 루틴

```c
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
double now_s(){ struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
  return t.tv_sec + t.tv_nsec*1e-9; }

void work(int n, const float *restrict x, float *restrict y, float a){
  #pragma omp simd
  for(int i=0;i<n;i++) y[i] += a*x[i];
}

int main(){
  const int n=1<<26;
  float *x, *y;
  posix_memalign((void**)&x, 64, sizeof(float)*n);
  posix_memalign((void**)&y, 64, sizeof(float)*n);
  for(int i=0;i<n;i++) x[i]=1.0f, y[i]=0.0f;

  // 워밍업
  for(int r=0;r<3;r++) work(n,x,y,2.0f);

  double t0=now_s();
  work(n,x,y,2.0f);
  double t1=now_s();
  double bytes = 2.0*n*sizeof(float); // read x + read/write y의 대략
  printf("time=%.3fs, BW=%.1f GB/s\n", t1-t0, bytes/((t1-t0)*(1<<30)));

  free(x); free(y);
  return 0;
}
```
- 실행 시 `taskset`/전원관리 고정/반복 측정으로 노이즈 제거.
- `perf stat -e cycles,instructions,branch-misses,L1-dcache-loads,LLC-load-misses` 로 전후 비교.

---

## 21. 요약 체크리스트(한 장)

- [ ] UB 제거(부호 overflow, OOB, UAF, 미정의 순서).
- [ ] 별칭 제거(`restrict`/API 설계).
- [ ] 루프: LICM/강도감소/언롤/타일링 설계로 **AI↑·MLP↑**.
- [ ] 벡터화 전제: 정렬/연속접근/마스크·peeling.
- [ ] LTO/PGO 적용, 링크 경계에서 가시성/인터포지션 최소화.
- [ ] 수치 정확성 정책(IEEE vs fast-math) 명확화.
- [ ] 동시성: atomics/fence로 메모리 모델 준수.
- [ ] 측정: perf/VTune/llvm-mca + 컴파일러 최적화 리포트 확인.
- [ ] 코드 크기/캐시 압박 감시(인라인/언롤 남용 금지).
