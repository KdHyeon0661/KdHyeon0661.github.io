---
layout: post
title: 논리회로설계 - SM 차트와 상태머신 설계
date: 2025-09-13 17:25:23 +0900
category: 논리회로설계
---
# SM 차트와 상태머신 설계 — **SM(=ASM) 차트의 유도**, **SM 차트 구현(하드와이어드/마이크로프로그램/HDL)**

> 용어 정리  
> - SM 차트: **State Machine chart**. 디지털 설계 교과서에서 흔히 **ASM(Algorithmic State Machine) 차트**라고도 부름.  
> - 구성요소: **상태 박스(state box)**, **결정 박스(decision box)**, **조건 박스(conditional output box)**.  
> - 규율: **한 상태 박스 = 한 클럭 주기**. 같은 주기 안에서 결정·조건 박스의 경로가 선택되고, 그 경로 안의 **조건부 출력/마이크로연산**이 **그 클럭 동안** 실행된다. 다음 클럭에서 다음 상태 박스로 **이행**.

---

## 0) SM(ASM) 차트 표기법과 해석

### 0.1 박스와 신호의 의미
- **상태 박스** `S`:  
  - 표기: `S:` 아래에 **무조건적(unconditional)** 출력 및 **마이크로연산(레지스터 전송)** 기입  
  - 실행: 해당 클럭동안 항상 실행  
  - 끝에서 **결정 박스**로 이어짐
- **결정 박스** `? cond`:  
  - 표기: 다이아몬드/`?` 형태, `cond=1/0` 두 방향  
  - 실행: 동일 클럭 내에서 **조합 판단**
- **조건 박스** `[cond]` :  
  - 표기: 사각형, 상단에 조건, 내부에 **조건부 출력/마이크로연산**  
  - 실행: 해당 조건이 참이면 같은 클럭 동안 수행
- **이행(상태 천이)**: 차트의 한 **최종 화살표**가 가리키는 **다음 상태 박스**로 **다음 클럭**에 진입

### 0.2 시간 모델(핵심 직관)
한 클럭 주기 동안:
1) 현재 **상태 박스**의 무조건 항목 수행  
2) 이어지는 **결정 박스**들이 조합적으로 평가되어 **경로 확정**  
3) 경로에 놓인 **조건 박스**의 항목 실행  
4) 주기 말에 **상태 레지스터**가 다음 상태 코드로 갱신

> 따라서 **결정/조건 박스에 포함된 출력은 Mealy 성격(입력 의존)**, **상태 박스의 출력은 Moore 성격**으로 이해하면 쉽다.

---

## 1) SM 차트의 **유도 절차** (문제 → 상태/데이터 → 차트)

### 1.1 체크리스트
1. **문제 명세 정리**: 입력/출력, 초기상태, 종료조건, 오류/예외, 시간 제약  
2. **데이터 패스 분리(필요 시)**: 레지스터/카운터/시프터 및 **마이크로연산**(RT-level) 정의  
3. **원시 의사코드**: “if/else/while/for” 구조를 **한 클럭에 가능한 단계**로 절단  
4. **상태 후보 도출**: 반복 단위·경계 조건·버스 동작의 ‘묶음’을 **하나의 상태 박스**로  
5. **결정/조건 박스 배치**: 입력/플래그(Zero, Carry, MSB, 비트 등)에 대한 분기를 조합적으로 표현  
6. **안정성**: 리셋→IDLE 경로, **닫힌 커버(Self-start)**, 예외 처리(0으로 나눔 등)  
7. **출력의 위치**: 외부로 나가는 신호는 **Moore(상태 박스)** 또는 **조건 박스+등록**으로 글리치 방지

### 1.2 미니 예제 #1 — **시퀀스 검출기(1011, 오버랩 허용)**
**명세**: 입력 `x`, 출력 `y`. 입력열에서 `1011`이 끝날 때 `y=1` 펄스.  
**상태 의미**(부분 매칭): `S0(ε)`, `S1(1)`, `S2(10)`, `S3(101)`

**SM 차트(텍스트)**

```
[S0]: (Moore: y=0)
  ? x=1
    [x=1] -> S1
    [x=0] -> S0

[S1]: (y=0)
  ? x=0
    [x=0] -> S2
    [x=1] -> S1   -- '1' 연속

[S2]: (y=0)
  ? x=1
    [x=1] -> S3
    [x=0] -> S0

[S3]: (y=0)
  ? x=1
    [x=1] -> (y<=1) -> S1  -- '...1011' 검출 및 오버랩 '1' 유지
    [x=0] -> S2
```

> 여긴 데이터패스 없는 **순수 FSM** 예시이지만, **조건 박스 내 출력(y<=1)** 은 **같은 클럭**에 발생(일반적으로는 등록 권장).

---

## 2) SM 차트 **구현 패턴** (하드와이어드 vs 마이크로프로그램 vs HDL)

### 2.1 하드와이어드 컨트롤러(PLA/게이트)
- **흐름**: SM 차트 → **상태표**(현재상태/입력 → 다음상태/출력) → **상태 인코딩** → **부울식** → **K-맵/카노맵 최소화** → 게이트/PLA  
- **Moore 출력**은 상태비트로 직접 구동하기 쉬움(출력 비트 **상태코드에 내장** 추천)  
- **Mealy/조건 출력**은 보통 **레지스터 1단 추가**(글리치 방지)

### 2.2 마이크로프로그램(ROM) 방식
- **주소**: `[현재상태코드 | 플래그/입력 일부]`  
- **데이터(컨트롤워드)**: `[다음상태코드 | 제어선(Load/Shift/Add/Sub/Inc/Clr...) | 외부출력]`  
- **특징**: 차트의 **조건 박스 분기**를 주소 비트로 흡수하여 **컨트롤워드** 선택

### 2.3 HDL(추천, 합성 친화)
- **2-프로세스 패턴**:  
  - `process(all)`: **ns(다음상태)/조건부 제어선** 계산(조합), 기본값 필수  
  - `process(clk)`: **상태/레지스터** 업데이트(순차)  
- **3-프로세스**: Mealy 출력 **등록**을 분리  
- **상태 인코딩**: `enum_encoding`/`fsm_encoding` 속성으로 **one-hot/gray/sequential** 명시 가능

---

## 3) 예제 A — **직렬 비교기(Serial Comparator) 컨트롤러**: SM 차트 유도→구현

### 3.1 명세
- 입력: 직렬 `a`, `b` (MSB→LSB 순 입력, `tick` 1클럭/비트), `n`비트 길이  
- 출력: `GT`(A>B), `LT`(A<B), `EQ`(A=B)  
- 직전까지 동일하면 계속 비교, **처음 다른 비트**에서 결론, 나머지는 무시

### 3.2 데이터패스(플래그)
- 레지스터 없음(스트리밍 가정)  
- 플래그: `gt`, `lt` (세트 이후 유지), `eq`(기본 1, gt/lt가 1되면 0)

### 3.3 SM 차트

```
S0 (IDLE):  -- 초기화
  [uncond] gt<=0, lt<=0, eq<=1
  ? start=1
    [1] -> S1
    [0] -> S0

S1 (RUN):
  ? tick=1
    [1]
      ? a!=b
        [a=1,b=0] -> (gt<=1, eq<=0) -> S2 (HOLD_GT)
        [a=0,b=1] -> (lt<=1, eq<=0) -> S3 (HOLD_LT)
      ? a==b
        [1] -> S1  -- 계속
    [0] -> S1

S2 (HOLD_GT):  -- 결과 유지
  [uncond] GT<=1, EQ<=0
  ? done=1
    [1] -> S0
    [0] -> S2

S3 (HOLD_LT):
  [uncond] LT<=1, EQ<=0
  ? done=1
    [1] -> S0
    [0] -> S3
```

### 3.4 상태표(요지)
- `(S1, tick & a!=b)` 분기에서 조건 박스가 실행되며 플래그 세트(Mealy 성격).  
- Moore 외부출력을 원하면 `S2/S3`에서만 내보내고, `S1` 분기에서의 펄스는 내부 레지스터에만 기록.

### 3.5 VHDL (2-프로세스, 결과는 Moore로 등록)
```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity serial_cmp_ctrl is
  port (clk,rst,start,tick,a,b,done: in std_logic;
        GT,LT,EQ: out std_logic);
end;
architecture rtl of serial_cmp_ctrl is
  type S_t is (S0,S1,S2,S3);
  signal s, ns: S_t := S0;
  signal gt,lt,eq: std_logic := '0';
begin
  -- 조합: ns 및 (필요시) 내부 플래그 기본값
  process(all) begin
    ns <= s;
    case s is
      when S0 =>
        if start='1' then ns<=S1; end if;
      when S1 =>
        if tick='1' then
          if (a='1' and b='0') then ns<=S2;
          elsif (a='0' and b='1') then ns<=S3;
          else ns<=S1;
          end if;
        end if;
      when S2 =>
        if done='1' then ns<=S0; end if;
      when S3 =>
        if done='1' then ns<=S0; end if;
    end case;
  end process;

  -- 순차: 상태/플래그(조건 박스 역할)
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then s<=S0; gt<='0'; lt<='0'; eq<='1';
      else
        s <= ns;
        case s is
          when S0 => gt<='0'; lt<='0'; eq<='1';
          when S1 =>
            if tick='1' then
              if (a='1' and b='0') then gt<='1'; lt<='0'; eq<='0';
              elsif (a='0' and b='1') then lt<='1'; gt<='0'; eq<='0';
              end if;
            end if;
          when others => null;
        end case;
      end if;
    end if;
  end process;

  -- Moore 외부출력
  GT <= '1' when s=S2 else '0';
  LT <= '1' when s=S3 else '0';
  EQ <= '1' when (s=S1 and gt='0' and lt='0') or (s=S0) else '0';
end;
```

---

## 4) 예제 B — **시프트-가산 2진 곱셈기 컨트롤러**: SM 차트 유도→ROM/HDL 구현

### 4.1 명세/데이터패스
- 데이터패스(레지스터): `A`(피승수), `B`(승수), `P`(누산기, 2N), `CNT`(남은 비트)  
- 마이크로연산:
  - `if (B0) then P[lowN-1:0] ← P[low] + A`  
  - `shift_right(B)`, `shift_right(P)`  
  - `CNT ← CNT - 1`  
- 종료: `CNT=0 → DONE`

### 4.2 SM 차트(핵심 경로)

```
S0 (IDLE):
  [uncond] busy<=0, done<=0
  ? start=1
    [1] -> (P←0, CNT←N, busy←1, load A,B) -> S1
    [0] -> S0

S1 (TEST):
  ? CNT=0
    [1] -> (busy←0, done←1) -> S3(DONE)
    [0] -> S2(STEP)

S2 (STEP):
  ? B0=1
    [1] -> [P_low += A]        -- 조건 박스(같은 클럭)
    [0] -> (no add)
  [uncond] P>>=1, B>>=1, CNT←CNT-1 -> S1

S3 (DONE):
  [uncond] done<=1
  -> S0
```

> 포인트: `S2` 안에서 **추가/비추가 결정**과 **시프트/감산**이 **같은 클럭**에 실행됨(ASM 원칙). 클럭 말에 `S1`로 복귀.

### 4.3 ROM(컨트롤 메모리) 구현 스케치
- **주소 비트**: `[S1/S2/S0/S3 | (CNT=0) | B0]` (예: 상태 2비트 + 플래그 2비트)  
- **컨트롤워드**: `[NS(다음상태2b) | LD_AB | CLR_P | ADD | SH_P | SH_B | DEC_CNT | busy | done]`

**컨트롤 테이블(일부)**

| 상태 | CNT0 | B0 | NS  | LD_AB | CLR_P | ADD | SH_P | SH_B | DEC | busy | done |
|-----|-----:|---:|:---:|:-----:|:-----:|:---:|:----:|:----:|:---:|:----:|:----:|
| S0  |  X   | X  | S1  | 1     | 1     | 0   | 0    | 0    | 0   | 1    | 0    |
| S1  |  1   | X  | S3  | 0     | 0     | 0   | 0    | 0    | 0   | 0    | 1    |
| S1  |  0   | X  | S2  | 0     | 0     | 0   | 0    | 0    | 0   | 1    | 0    |
| S2  |  X   | 0  | S1  | 0     | 0     | 0   | 1    | 1    | 1   | 1    | 0    |
| S2  |  X   | 1  | S1  | 0     | 0     | 1   | 1    | 1    | 1   | 1    | 0    |
| S3  |  X   | X  | S0  | 0     | 0     | 0   | 0    | 0    | 0   | 0    | 1    |

> 구현: (상태, CNT0, B0) → ROM 주소 → 컨트롤워드 → 데이터패스 제어선 드라이브

### 4.4 HDL(하드와이어드) 구현(컨트롤러 부분)
```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity mul_ctrl is
  port (clk,rst,start: in std_logic;
        cnt_is_zero, B0: in std_logic;
        ld_ab, clr_p, add, sh_p, sh_b, dec_cnt, busy, done: out std_logic);
end;
architecture rtl of mul_ctrl is
  type S_t is (S0,S1,S2,S3);
  signal s, ns: S_t := S0;
begin
  -- 조합: 기본값
  process(all) begin
    ld_ab<='0'; clr_p<='0'; add<='0'; sh_p<='0'; sh_b<='0'; dec_cnt<='0'; busy<='0'; done<='0';
    ns <= s;
    case s is
      when S0 =>
        busy<='0';
        if start='1' then
          ld_ab<='1'; clr_p<='1'; busy<='1'; ns<=S1;
        end if;
      when S1 =>
        busy<='1';
        if cnt_is_zero='1' then done<='1'; ns<=S3;
        else ns<=S2;
        end if;
      when S2 =>
        busy<='1';
        if B0='1' then add<='1'; end if;
        sh_p<='1'; sh_b<='1'; dec_cnt<='1';
        ns<=S1;
      when S3 =>
        done<='1'; ns<=S0;
    end case;
  end process;

  -- 순차: 상태
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then s<=S0; else s<=ns; end if;
    end if;
  end process;
end;
```

> 데이터패스 모듈은 `ld_ab/ clr_p/ add/ sh_p/ sh_b/ dec_cnt` 제어선을 받아 해당 마이크로연산을 수행한다.

---

## 5) 예제 C — **복원 나눗셈기 컨트롤러**: SM 차트 유도→HDL

### 5.1 마이크로연산(Unsigned, 상위→하위)
- `R ← (R<<1) + N[i]`  
- `if R ≥ D then (R ← R - D; Q[i] ← 1) else Q[i] ← 0`  
- `i ← i - 1` 반복

### 5.2 SM 차트

```
S0(IDLE):
  [uncond] done<=0, div0<=0
  ? start=1
    [1] -> ? D=0
            [1] -> (div0<=1) -> S3(DONE)
            [0] -> (R←0, i←n-1, Q←0) -> S1
    [0] -> S0

S1(LOAD+SHIFTIN):
  [uncond] R ← (R<<1) + N[i]
  -> S2(TEST)

S2(TEST):
  ? R >= D
    [1] -> [R ← R - D; Q[i]←1] -> S4(NEXT)
    [0] -> [Q[i]←0]            -> S4(NEXT)

S4(NEXT):
  ? i=0
    [1] -> S3(DONE)
    [0] -> (i←i-1) -> S1

S3(DONE):
  [uncond] done<=1
  -> S0
```

### 5.3 컨트롤러 HDL(조합/순차 분리)
```vhdl
-- 제어선: sh_in, sub_en, q_we, q_bit, i_dec, r_clr, div0, done
-- 비교 플래그: ge = (R>=D), i_is_zero, d_is_zero
```
(상세 코드는 앞선 곱셈기 컨트롤러와 동일 패턴으로 작성 가능)

---

## 6) SM 차트 → **상태표/부울식** → **최소화/상태할당** 요령

### 6.1 상태표 구성
- 행: `(현재상태, 플래그/입력 조합)`  
- 열: `다음상태`, `출력(무조건/조건)`  
- **ISM(불완전 명세)**: 사용하지 않는 조합은 `–`(don’t care)로 두고 **닫힌 커버** 우선

### 6.2 최소화/할당
- **무어 출력 비트 내장**: 출력=상태코드 비트 → 출력 로직 0  
- **인접성 보존**: 자주 왕복 전이 = **해밍 1**(그레이)  
- **FPGA**: 원-핫 유리(조건 박스가 많아도 식 단순)  
- **CPLD/ASIC**: 이진/그레이로 FF 절약, **공통인수** 추출

### 6.3 조건 출력의 등록
- **원칙**: 조건 박스의 외부 신호는 **레지스터 1단** 거쳐 출력(글리치 방지)  
- 트리거형 신호(펄스)는 컨트롤러 내부에서 **1클럭 펄스** 생성 후 외부로

---

## 7) 디버깅/검증: SM 차트 기반 **시뮬레이션 전략**

### 7.1 커버리지 항목
- 모든 **상태 박스** 진입  
- 모든 **결정 박스**의 양 분기  
- 모든 **조건 박스** 실행/미실행 케이스  
- 예외 경로(분모=0, 카운터=0 등)

### 7.2 테스트벤치 팁
- **레지스터 전송 관찰**: 마이크로연산의 결과(레지스터값)를 **다음 클럭**에서 체크  
- **패턴 생성기**: 곱셈/나눗셈은 **무작위 입력**과 **소프트 레퍼런스**로 비교  
- **어설션**:  
  - `assert not (illegal_state)`  
  - `assert next_state_known`  
  - `assert done implies stable outputs`

---

## 8) SM 차트 작성 **가이드라인**

1. **상태 박스는 최소·자립적**: 한 박스에서 가능한 많은 마이크로연산을 **한 클럭**에 묶되, 타이밍 한계 고려  
2. **결정은 조합적으로 얕게**: 다단 if-then-else가 깊으면 **플래그 레지스터화**하여 다음 상태에서 판단  
3. **조건 박스는 “조건부 부작용”만**: 외부 신호는 레지스터로  
4. **루프는 명확하게**: `TEST → STEP → TEST` 형태(예: S1↔S2)로 **반복 구조**를 눈에 띄게  
5. **예외/복구 경로**: 어디서든 **IDLE/SAFE**로 돌아올 수 있게(닫힌 커버)  
6. **문서화**: 각 박스의 **마이크로연산·제어선**을 테이블로 함께 보관(ROM/PLA/HDL 공통 활용)

---

## 9) 보너스 예제 — **보행자 포함 교차로**(상태 출력 중심, SM 차트)

```
S0(NS_G): G_NS=1, R_EW=1
  ? T=1
    [1] -> S1(NS_Y)

S1(NS_Y): Y_NS=1, R_EW=1
  ? T=1
    [1] -> S2(EW_G)

S2(EW_G): G_EW=1, R_NS=1
  ? T=1
    [1] -> S3(EW_Y)

S3(EW_Y): Y_EW=1, R_NS=1
  ? T=1
    [1] -> S0(NS_G)

-- 보행 버튼: 각 G 시작 시점 조건 박스에서 walk_latch<=1; Y 종료 시점에서 클리어
```

> 상태 박스 출력(Moore)이므로 **글리치 없음**. 보행 로직은 **조건 박스 + 래치**로 처리.

---

## 10) 요약 카드

- **SM(ASM) 차트**는 “한 상태=한 클럭, 그 안에서 결정과 조건부 동작을 수행”하는 **시각적 설계 도구**.  
- **유도 절차**: 명세→데이터패스·마이크로연산→상태 후보→결정/조건 박스 배치→예외·Self-start 보강.  
- **구현**:  
  - **하드와이어드**(부울식/PLA): Moore 출력 내장, Mealy 출력 등록  
  - **ROM**(컨트롤워드): (상태|플래그)→컨트롤워드  
  - **HDL**: 2/3-프로세스 패턴, 상태/제어선 명확하게  
- **검증**: 상태/분기/조건 커버리지, 예외 경로, 소프트 레퍼런스 대조.  
- **실무 팁**: 타이밍을 고려해 박스 내 연산량 조절, 조건 출력은 **항상 레지스터링**, 닫힌 커버·IDLE 복귀 루프.
