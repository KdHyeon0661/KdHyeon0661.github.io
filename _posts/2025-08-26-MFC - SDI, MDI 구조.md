---
layout: post
title: MFC - SDI, MDI 구조
date: 2025-08-26 17:25:23 +0900
category: MFC
---
# SDI/MDI 구조 이해: `CDocument` / `CView` / `CFrameWnd`, DocTemplate, 명령 라우팅 완전 정리

이 글은 MFC의 **문서/뷰 구조(도큐먼트-뷰-프레임)** 를 **SDI/MDI** 관점에서 끝까지 파고듭니다.  
핵심 클래스의 역할, 생성·수명 주기, **DocTemplate의 연결 방식**, **명령/업데이트 라우팅**, **멀티 뷰**, **프린팅 파이프라인**, **MDI 전용 이슈**까지 **생략 없이** 정리했습니다. (코드 없이 개념·흐름 중심)

---

## 0) 큰 그림: 왜 Doc/View인가?

- **분리(Separation of Concerns)**  
  - **`CDocument`**: 데이터·모델(파일 로드/저장, 직렬화, 변경 여부)  
  - **`CView`**: 표시·편집(그리기, 사용자 입력 처리)  
  - **`CFrameWnd`**: 컨테이너(메뉴·툴바·상태바·레아웃, 활성 뷰 관리)
- **확장성**: **한 문서에 여러 뷰(표/그래프/속성)** 를 동시에 띄우고 동기화 가능  
- **표준 행동의 자동화**: 새 문서/열기/저장/인쇄/MRU 등 **파일 형 앱의 반복 작업**을 프레임워크가 제공

---

## 1) 핵심 클래스의 책임과 경계

### 1-1. `CDocument` (모델)
- **데이터 보유**: 문서 상태·컬렉션·도메인 객체  
- **직렬화(Serialization)**: 저장/불러오기에 필요한 읽기/쓰기 구현  
- **변경 플래그**: 수정되면 `SetModifiedFlag(TRUE)` → 종료/닫기/새로 열기 전 **저장 확인**  
- **뷰 알림 브로드캐스트**: `UpdateAllViews(pSender, lHint, pHint)` → 모든 뷰가 **동일 데이터 변경**을 반영
- **수명**: 연결된 **모든 프레임(뷰)** 이 닫힐 때 소멸

### 1-2. `CView` (뷰)
- **표시/편집**: `OnDraw`로 화면 그리기, 마우스/키보드 입력 처리  
- **문서 접근**: `GetDocument()`로 모델 상태 읽기/쓰기  
- **초기 준비**: 첫 표시 직후 **`OnInitialUpdate`** (컨트롤 크기 조정, 스크롤 범위 설정 등)  
- **문서 갱신 수신**: `OnUpdate(pSender, lHint, pHint)`에서 선택적 반응 (부분 갱신을 위해 **Hint** 사용)

### 1-3. `CFrameWnd` / `CMDIFrameWnd` / `CMDIChildWnd` (프레임)
- **UI 컨테이너**: 메뉴/툴바/상태바/도킹 창, 가속기  
- **활성 뷰 관리**: 포커스·활성화 전환, 레이아웃 재계산  
- **MDI의 경우**  
  - 메인: `CMDIFrameWnd(Ex)`  
  - 자식: `CMDIChildWnd(Ex)` (각 문서를 담는 독립 창)  
- **SDI의 경우**  
  - 메인 프레임: `CFrameWnd(Ex)` (문서 1개 + 뷰 1개가 기본)

---

## 2) DocTemplate: 문서-프레임-뷰의 “결혼식 주례”

### 2-1. 역할
- **런타임 클래스 3종 연결**:  
  - 문서(`RUNTIME_CLASS(CMyDoc)`), 프레임(`…Frame`), 뷰(`…View`)  
- **파일 형식 메타**: 확장자/필터/캡션 등 **DocString**에서 추출  
- **생성 시나리오의 허브**: **새 문서**/**열기**/**다시 열기** 시 공장처럼 객체를 만들고 **묶어** 표시

### 2-2. 유형
- **`CSingleDocTemplate`**: **SDI**(문서 1개만)  
- **`CMultiDocTemplate`**: **MDI**(문서 여러 개, 각기 Child Frame으로 표시)

### 2-3. 애플리케이션 초기화에서의 연결(개념)
- 앱 시작(`CWinApp::InitInstance`)에서 **DocTemplate 인스턴스 생성 → `AddDocTemplate` 등록**  
- 이후 **`ID_FILE_NEW`/`ID_FILE_OPEN`** 같은 표준 명령이 들어오면 **등록된 DocTemplate**이 호출되어  
  - 문서 생성 → 프레임/뷰 생성·연결 → 첫 표시 준비(`OnInitialUpdate`) → 프레임 활성

### 2-4. DocString의 의미 (파일 대화상자/타이틀/MRU에 사용)
- 리소스 문자열에는 `\n`으로 구획된 **이름/필터/확장자/문서 캡션 템플릿** 등 토큰이 들어감  
- 파일 열기/저장 대화 상자에 표시될 **필터 문자열**, 창 타이틀 포맷 등에 활용

---

## 3) 생성·수명 주기(시나리오 별 흐름)

### 3-1. 앱 시작 → SDI 기본 화면
1) 앱 초기화: 런타임 환경/리소스 준비  
2) DocTemplate 등록  
3) (SDI) `ID_FILE_NEW` 자동 트리거 → `OpenDocumentFile(NULL)`  
4) **문서 생성** → **프레임 생성**(메인 프레임) → **뷰 생성** → **프레임에 뷰 부착**  
5) `CView::OnInitialUpdate` 호출 → 스크롤·컨트롤·데이터 바인딩 초기화  
6) 프레임 활성화/표시

### 3-2. 파일 열기(`ID_FILE_OPEN`)
1) OpenDocumentFile(파일 경로)  
2) **문서 생성** 후 `CDocument::OnOpenDocument(path)` 호출 → 로딩/파싱  
3) 프레임/뷰 생성·부착 → `OnInitialUpdate` → 활성화  
4) MRU(최근 문서) 갱신

### 3-3. 저장/저장 As
- `CDocument::OnSaveDocument(path)`에서 직렬화/내보내기  
- **수정 플래그 해제**: 저장 성공 후 `SetModifiedFlag(FALSE)`  
- 실패 시 사용자 피드백(권한/디스크 상태)

### 3-4. 종료/닫기
- 문서가 **수정됨**이면 저장 확인(Yes→저장, No→폐기, Cancel→중단)  
- SDI: 창 닫기 = 문서 종료  
- MDI: Child Frame 닫기 = 해당 문서 종료(다른 Child가 없으면 문서 소멸)

---

## 4) 명령(커맨드) · 업데이트 라우팅(핵심)

### 4-1. `WM_COMMAND`/가속기/툴바/메뉴 → 동일 경로
- 메뉴·툴바·단축키(Accelerator)는 모두 **명령 ID**로 통합되어 들어옴  
- **핸들러 검색 순서**(프레임워크가 자동으로 “적절한 곳”을 찾아감)

**SDI**  
1) **활성 `CView`**  
2) **`CFrameWnd`** (메인 프레임)  
3) **`CDocument`**  
4) **`CWinApp`**

**MDI**  
1) **활성 Child의 `CView`**  
2) **그 Child의 `CMDIChildWnd`**  
3) **그 Child의 `CDocument`**  
4) **`CMDIFrameWnd`(메인 프레임)**  
5) **`CWinApp`**

> 정리: **데이터 조작**은 `CDocument`, **표시/도구**는 `CView`, **창·전역**은 `Frame/App`가 담당하도록 배치하면 자연스럽게 라우팅됩니다.

### 4-2. `ON_UPDATE_COMMAND_UI` (상태 갱신)
- 동일한 라우팅 체계로 **Enable/Disable, Check/Radio, Text** 를 결정  
- 프레임 기반(특히 SDI/MDI)에서는 **Idle 타임**에 자동 호출되어 메뉴/툴바 상태를 일관되게 갱신  
- **성능 주의**: 이 함수들은 **아주 자주 호출**되므로 I/O나 무거운 작업 금지(캐시된 플래그 읽기 정도로)

---

## 5) 여러 뷰와 동기화 (멀티 뷰/스플리터)

### 5-1. 한 문서 — 다수의 뷰
- 예: 표(View A), 그래프(View B), 속성(View C)  
- 문서 변경 시 `UpdateAllViews`로 **방송** → 각 뷰는 `OnUpdate`에서 **관심 있는 부분만** 갱신  
- **Hint 패턴**: `lHint`/`pHint`로 “무엇이 바뀌었는지” 알려 **부분 렌더링** (예: `HINT_SELECTION_CHANGED`)

### 5-2. 동적 뷰 교체 / 추가
- (고급) 런타임에 다른 타입의 뷰로 **교체**하거나 **추가 프레임** 생성  
- 수명 규칙: **프레임이 뷰의 소유자**, **문서는 프레임/뷰 모두와 느슨히 연계**  
- 잘못된 소유권(뷰를 임의 삭제 등)은 크래시 원인 → **프레임 API로** 생성/파괴

### 5-3. 스플리터(`CSplitterWnd`)
- 하나의 프레임 안에 **행·열로 여러 뷰** 배치  
- 각각 **동일 문서**를 바라보되, 다른 포커스/스크롤/표시 모드를 제공  
- 레이아웃 변경 시 **RecalcLayout**으로 프레임 재배치

---

## 6) 프린팅 파이프라인(표준 흐름)

1) 사용자가 **인쇄/미리보기**  
2) `CView::OnPreparePrinting` → 페이지 수 계산/설정  
3) `OnBeginPrinting` → GDI 리소스 준비  
4) `OnPrint`(페이지별 호출) → **문서 데이터**를 **뷰 방식으로** 렌더  
5) `OnEndPrinting` → 정리

> 포인트: **문서 데이터는 `CDocument`**, **출력 레이아웃/렌더는 `CView`**가 담당

---

## 7) MDI 전용 이슈 (SDI와 다른 지점)

- **Child Frame**: 문서마다 독립 창, **활성 Child**가 **명령/업데이트**의 기준  
- **메뉴 병합**: 활성 Child의 메뉴가 메인 메뉴와 **동적으로 병합** (특히 Ribbon이 아닌 고전 메뉴에서 체감)  
- **윈도우 메뉴**: 열려 있는 문서(Child) 목록 표시/전환  
- **타이틀/캡션**: Child 별로 문서명, 메인 프레임의 캡션 템플릿과 조합  
- **창 배치**: Cascade / Tile / ArrangeIcons 등 **MDI 전용 명령** 제공

---

## 8) 직렬화와 문서 변경 통지(데이터 흐름의 표준 패턴)

- **로드/저장**: `CDocument::Serialize(ar)`에 **읽기/쓰기 양면 구현**  
  - `ar.IsStoring()` → 저장 / `!IsStoring()` → 로드  
- **문서 변경 후**: `SetModifiedFlag(TRUE)` → 종료/닫기 시 저장 묻기  
- **뷰 갱신 방송**: `UpdateAllViews(nullptr, HINT_XXX, pHint)`  
  - 뷰에서 `OnUpdate` 구현 → 필요한 UI만 갱신  
- **초기 그리기**: `CView::OnInitialUpdate`에서 스크롤 범위/컨트롤 데이터 바인딩

---

## 9) SDI vs MDI 선택 기준

| 항목 | SDI | MDI |
|---|---|---|
| 사용 패턴 | 문서 1개 중심, 단순 · 집중 | 문서 여러 개 동시 열람/비교 |
| UI 복잡도 | 간결, 메뉴 단순 | Child 관리, 메뉴 병합 등 복잡 |
| 멀티 뷰 | 스플리터/패널로 해결 | Child 여러 개 + 각기 다른 뷰 구조도 가능 |
| 학습/유지보수 | 쉬움 | 상대적으로 어려움 |
| 예시 | 메모장형, 단일 프로젝트 편집기 | IDE, 이미지·탭 기반 에디터, 데이터 분석 툴 |

---

## 10) 자주 생기는 문제와 예방책

- **명령 핸들러가 안 불림**  
  - 라우팅 경로에 **핸들러가 없는 클래스**에 넣었을 가능성.  
  - “표시/편집은 뷰, 데이터 조작은 문서” 원칙으로 재배치.
- **업데이트 UI가 엇갈림**  
  - `ON_UPDATE_COMMAND_UI`는 **아주 자주 호출**됨. 상태 계산은 **O(1)** 로.  
  - 활성 Child 변경(MDI) 시점에 상태가 다를 수 있으니 **활성 프레임/뷰 기준**으로 계산.
- **뷰 간 동기화 지연/깜빡임**  
  - 데이터 변경 후 즉시 `UpdateAllViews` 호출.  
  - 힌트로 **부분 갱신**(스크롤/선택만) 유도.
- **문서/뷰 소멸 순서 오해**  
  - 프레임이 뷰를 소유, 마지막 프레임 소멸 시 문서 소멸. **직접 delete 금지**.  
  - 리소스는 `OnClose`/`OnDestroy` 등 **적절한 훅**에서 정리.
- **파일 대화상자 필터가 이상함**  
  - DocString 토큰(이름/확장자/필터)이 잘못 구성. 리소스 문자열 재점검.

---

## 11) 설계 베스트 프랙티스

1. **도메인 로직은 문서**에, **UI 로직은 뷰**에  
2. **힌트 기반 갱신**으로 **큰 캔버스/대량 데이터**의 성능 확보  
3. **표준 명령 ID**(열기/저장/인쇄/새로)와 **DocTemplate**를 활용해 반복 코드를 줄이기  
4. **멀티 뷰**가 필요하면 스플리터/추가 프레임을 고려하되 **소유권 규칙**을 문서화  
5. **MDI**에서는 활성 Child 개념을 전제로 **업데이트 UI/단축키**를 설계  
6. **직렬화 포맷의 버전 필드**로 **호환성/마이그레이션** 경로 마련

---

## 12) 한 장으로 보는 흐름(시퀀스 개념도)

```
[사용자] ──(ID_FILE_OPEN)──▶ [App/CWinApp]
   │                          │
   └────────────────────────▶ [DocTemplate.OpenDocumentFile]
                              │
                     [CDocument 생성]
                              │
                     [CFrameWnd/CMDIChild 생성]
                              │
                          [CView 생성]
                              │
                     [CView::OnInitialUpdate]
                              │
                       [프레임 활성/표시]
                              │
       (편집/명령) ─────────▶ [CView 핸들러]
                              │
               (데이터 변경) ─▶ [CDocument.SetModifiedFlag]
                              │
      (뷰에 방송) ◀─────────── [CDocument.UpdateAllViews]
                              │
                    (종료/닫기/새로)
                              └─▶ 저장 확인 → OnSaveDocument → 소멸
```

---

### 마무리

- **Doc/View/Frame**은 역할 분리가 명확한 **전통적이지만 강력한 구조**입니다.  
- **DocTemplate**는 파일 형식·문서·프레임·뷰를 **느슨하게 결합**하는 축이며,  
- **명령/업데이트 라우팅**은 “핸들러를 어디에 둘 것인가”의 **설계 규율**을 제공합니다.  
- 이 원칙을 지키면, SDI든 MDI든 **멀티 뷰·대용량·인쇄·확장**을 안정적으로 품을 수 있습니다.