---
layout: post
title: Linux - 부팅과 서비스 관리
date: 2024-11-14 19:20:23 +0900
category: Linux
---
# 부팅과 서비스 관리

## 부팅(boot) 흐름: 큰 그림과 각 단계의 역할

1) **펌웨어 (BIOS/UEFI)**
   - 하드웨어 초기화, 부팅 장치 선택. UEFI는 ESP(EFI System Partition)에서 부트로더(예: `\EFI\grub\grubx64.efi`) 실행.

2) **Bootloader (GRUB)**
   - 커널 이미지(`vmlinuz-*`)와 **initramfs**(`initrd.img`/`initramfs-*`)를 메모리로 적재, **커널 커맨드라인** 전달.
   - 멀티부트 메뉴, 커널 파라미터 임시 편집, 복구 모드 진입.

3) **Kernel + Initramfs**
   - 커널이 하드웨어 드라이버/메모리/프로세스·네트워크 스택 초기화.
   - **initramfs**는 루트 파일시스템을 마운트하기 위한 임시 루트(암호화/LVM/RAID 드라이버 포함).
   - 루트 FS 마운트 후 `init`(현대 시스템은 `systemd`)로 제어 이양.

4) **init (systemd)**
   - PID 1로 실행, **타겟(target)**에 따라 필요한 서비스 유닛을 병렬로 올림.
   - 의존성(Requires/Wants)과 순서(After/Before)로 **안정·신속**한 부팅을 달성.

5) **Login**
   - TTY(`agetty`), SSH(`sshd`), 또는 그래픽 디스플레이 매니저(GDM/SDDM/LightDM) 제공.

---

## 부트로더 GRUB 실무 팁 (UEFI 기준)

### GRUB 메뉴 일시 편집

- GRUB 화면에서 커널 항목 선택 후 `e` → `linux` 줄 끝에 파라미터 추가 → `Ctrl+x`로 부팅.

예시(일회성 디버깅):
```text
linux /boot/vmlinuz-... root=UUID=... ro systemd.unit=rescue.target
```

### GRUB 구성 파일 재생성

- Debian/Ubuntu:
```bash
sudo update-grub
```
- RHEL/Fedora(UEFI):
```bash
sudo grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg
```

### GRUB 보안(옵션)

```bash
# grub superuser 및 암호 설정(예: RHEL 계열)

sudo grub2-setpassword
```
> 부트로더에서 **임의 파라미터 주입**을 막아 물리 접근 보안 강화.

---

## 커널 커맨드라인(안전/복구에 유용)

- `systemd.unit=rescue.target` : 단일 사용자 수준(서비스 대부분 정지).
- `systemd.unit=emergency.target` : 최소 셸만 제공(루트 마운트 필요).
- `rd.break` : initramfs 단계에서 셸 제공(루트 패스워드 재설정 등).
- `selinux=0` : SELinux 일시 비활성(문제 원인 격리용, 상시 X).
- `rootdelay=10` : 느린 디스크 초기화 대응.

---

## initramfs 재생성

- Debian/Ubuntu:
```bash
sudo update-initramfs -u -k all
```
- RHEL/Fedora:
```bash
sudo dracut -f
```

---

## systemd 핵심: 유닛(Unit), 타겟(Target), 의존성 모델

### 유닛 타입(대표)

- `.service` : 데몬/서비스
- `.socket`  : 소켓 활성화(요청 시 서비스 기동)
- `.timer`   : 예약 실행(크론 대체 가능)
- `.path`    : 파일/디렉터리 변경 감지 → 서비스 트리거
- `.mount`, `.automount` : 마운트 관리
- `.target`  : 실행 레벨(구 runlevel)의 논리 그룹

### 서비스 유닛 예시(실무 하드닝 포함)

`/etc/systemd/system/myapp.service`
```ini
[Unit]
Description=My App (REST API)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=myapp
Group=myapp
WorkingDirectory=/opt/myapp
EnvironmentFile=-/etc/myapp/myapp.env
ExecStart=/opt/myapp/bin/myapp --config /etc/myapp/config.yaml
Restart=on-failure
RestartSec=3

# 보안/격리(가능한 한 많이 적용)

NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=full
ProtectHome=true
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true
RestrictSUIDSGID=true
ReadWritePaths=/var/lib/myapp /var/log/myapp
CapabilityBoundingSet=
AmbientCapabilities=
LockPersonality=true
MemoryDenyWriteExecute=true
RestrictRealtime=true
RestrictAddressFamilies=AF_INET AF_INET6
SystemCallFilter=@system-service  # 필요 시 화이트리스트 튜닝

[Install]
WantedBy=multi-user.target
```

> 포인트
> - **After/Before**: 실행 **순서**.
> - **Wants/Requires**: 실행 **의존성**. Requires 실패 시 해당 서비스도 실패.
> - **보안 하드닝**: `ProtectSystem`, `PrivateTmp`, `NoNewPrivileges`, `CapabilityBoundingSet` 등으로 피해 범위를 최소화.
> - 쓰기 필요한 경로만 **ReadWritePaths**로 허용.

### 유닛 파일 로딩/갱신

```bash
sudo systemctl daemon-reload      # 유닛 파일 변경 반영
sudo systemctl enable --now myapp # 부팅 등록+즉시 시작
sudo systemctl status myapp
```

### 드롭인(override)로 배포 패키지 유닛 보강

```bash
sudo systemctl edit nginx
# /etc/systemd/system/nginx.service.d/override.conf 생성 후 다음과 같이:

```
```ini
[Service]
Environment="NGINX_CONF=/etc/nginx/nginx.conf"
```
```bash
sudo systemctl daemon-reload
sudo systemctl restart nginx
```

---

## 타겟(target)과 런레벨 대응, 격리/전환

### 런레벨 매핑

| Runlevel | Target                | 설명                     |
|----------|-----------------------|--------------------------|
| 0        | poweroff.target       | 종료                     |
| 1        | rescue.target         | 단일 사용자              |
| 3        | multi-user.target     | CLI 멀티유저             |
| 5        | graphical.target      | GUI 포함                 |
| 6        | reboot.target         | 재부팅                   |

### 현재/기본 타겟 확인·설정

```bash
systemctl get-default
sudo systemctl set-default multi-user.target
```

### 특정 타겟으로 일시 전환(격리)

```bash
sudo systemctl isolate rescue.target
```

---

## 서비스(데몬) 기동과 상태 점검

### 기본 명령

```bash
sudo systemctl start|stop|restart myapp
sudo systemctl reload myapp
sudo systemctl enable|disable myapp
systemctl is-enabled myapp
systemctl list-units --type=service
```

### 로그/유닛 분석

```bash
journalctl -u myapp -b -e     # 현재 부팅 이후 myapp 로그 끝으로 이동
journalctl -u myapp -f        # tail -f
systemctl cat myapp           # 유닛 완전한 소스 확인(드롭인 포함)
systemctl show myapp | less   # 속성 덤프 (PIDFile, FragmentPath 등)
```

---

## 부팅 성능/병목 디버깅

```bash
systemd-analyze time            # 전체 부팅 소요
systemd-analyze blame           # 느린 유닛 순
systemd-analyze critical-chain  # 크리티컬 체인
```

부팅 지연 유닛 개선 팁:
- 순수 의존성은 `Wants`로 낮추고, 진짜 필수만 `Requires`.
- `After` 남발 금지(순서 의존이 진짜 필요한가 검토).
- 네트워크 필요 시 `network-online.target` 정확히 사용(네트워크 준비 이벤트와 구분).
- 서비스 하드닝 옵션 과도 설정으로 I/O 지연이 없는지 확인.

---

## 소켓/타이머/패스 유닛 — “필요할 때만”, “정해진 때만”, “변경되었을 때만”

### 소켓 활성화(예: 간이 에코 서버)

`/etc/systemd/system/echod.socket`
```ini
[Unit]
Description=Echo server socket

[Socket]
ListenStream=127.0.0.1:9999
Accept=yes

[Install]
WantedBy=sockets.target
```
`/etc/systemd/system/echod@.service` (인스턴스 서비스)
```ini
[Unit]
Description=Echo server (%i)

[Service]
ExecStart=/usr/bin/socat - "STDOUT"
StandardInput=socket
```
가동:
```bash
sudo systemctl enable --now echod.socket
nc 127.0.0.1 9999
```
> 연결 들어올 때만 인스턴스가 기동 → 자원 절약.

### 타이머(크론 대체)

`/etc/systemd/system/nightly-backup.service`
```ini
[Unit]
Description=Nightly backup

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/nightly-backup.sh
User=backup
Group=backup
```
`/etc/systemd/system/nightly-backup.timer`
```ini
[Unit]
Description=Run backup nightly

[Timer]
OnCalendar=02:30
RandomizedDelaySec=5m
Persistent=true

[Install]
WantedBy=timers.target
```
가동:
```bash
sudo systemctl enable --now nightly-backup.timer
systemctl list-timers
```

### 패스 유닛(파일 변경 트리거)

`/etc/systemd/system/reload-nginx.path`
```ini
[Unit]
Description=Watch nginx conf

[Path]
PathChanged=/etc/nginx/nginx.conf

[Install]
WantedBy=multi-user.target
```
`/etc/systemd/system/reload-nginx.service`
```ini
[Unit]
Description=Reload nginx

[Service]
Type=oneshot
ExecStart=/bin/sh -c 'nginx -t && systemctl reload nginx'
```
가동:
```bash
sudo systemctl enable --now reload-nginx.path
```

---

## 사용자 서비스(`--user`)와 linger

### 사용자 단위 서비스

```bash
systemctl --user enable --now mytool.service
journalctl --user -u mytool -f
```
로그인 없이도 유지하려면:
```bash
loginctl enable-linger <username>
```

---

## cgroups v2와 자원 제한(서비스 QoS)

서비스 유닛 내 예시:
```ini
[Service]
CPUQuota=200%           # 최대 2 vCPU
MemoryMax=2G            # 메모리 상한
IOReadBandwidthMax=/dev/sda 50M
BlockIOWeight=500
TasksMax=1024
```
> 컨테이너·자원 격리와 같은 효과를 **시스템 서비스**에도 적용 가능.

---

## SELinux/AppArmor와 서비스

- SELinux Enforcing 환경에서 서비스가 실패하면 `audit.log`/`journal` 메시지에서 **거부 AVC** 확인.
```bash
sudo ausearch -m avc -ts recent
sudo sealert -a /var/log/audit/audit.log
```
- AppArmor:
```bash
sudo aa-status
sudo aa-complain /etc/apparmor.d/usr.sbin.nginx
sudo aa-enforce  /etc/apparmor.d/usr.sbin.nginx
```
> 보안 정책과 systemd 하드닝을 **함께** 설계하면 방어심도 상승.

---

## 복구 시나리오 모음 (실전)

### 부팅 실패: rescue/emergency

GRUB에서 `e` → `linux` 줄에 추가:
```text
systemd.unit=rescue.target
# 또는

systemd.unit=emergency.target
```
rescue에서 루트 읽기/쓰기 재마운트:
```bash
mount -o remount,rw /
```

### 루트 패스워드 분실(드루이드: rd.break)

GRUB `e` 편집:
```text
rd.break
```
initramfs 쉘:
```bash
mount -o remount,rw /sysroot
chroot /sysroot
passwd
touch /.autorelabel   # SELinux 사용 시 권장
exit; exit
```

### 유닛 디버깅

```bash
systemctl status troubled.service
journalctl -u troubled.service -b -e
systemctl cat troubled.service
systemctl show troubled.service | sed -n '1,80p'
```
- `ExecStart` 경로/권한, `WorkingDirectory`, 환경파일 경로, **권한/소유자** 점검.
- 하드닝 옵션이 과해 실패할 수 있음(`ProtectSystem=full` 등).

### default.target 손상/GUI 문제

```bash
systemctl get-default
sudo systemctl set-default multi-user.target
sudo systemctl isolate multi-user.target
```
GUI 문제는 `graphical.target` 대신 CLI로 부팅 후 드라이버/DM 점검.

---

## SysVinit 호환(레거시)

### service/chkconfig

```bash
sudo service ssh restart
sudo chkconfig httpd on     # CentOS/RHEL 6 계열
```
현대 배포판에서는 내부적으로 `systemctl`로 브릿지되거나, SysV 스크립트 호환 유닛이 자동 생성된다.

### 직접 스크립트

```bash
sudo /etc/init.d/sshd restart
```
> **새 시스템은 systemd 우선**. 레거시는 마이그레이션 권장.

---

## 실전 예시

### 예시 1: SSH 서비스를 재시작하고 상태 확인

```bash
sudo systemctl restart ssh
sudo systemctl status ssh
```

### 예시 2: 특정 서비스가 부팅 시 실행되도록 설정

```bash
sudo systemctl enable nginx
```

### 예시 3: 기본 타겟을 CLI 모드로 설정

```bash
sudo systemctl set-default multi-user.target
```

### 예시 4: “느린 부팅” 원인 찾기

```bash
systemd-analyze blame
systemd-analyze critical-chain
```

### 예시 5: 소켓 활성화된 온디맨드 API

```bash
# 요청이 올 때만 프로세스가 뜨도록 socket+@service 구성(위 소켓 예시 참고)

curl http://127.0.0.1:9999
```

### 예시 6: 설정 변경 감지 시 자동 reload

```bash
sudo systemctl enable --now reload-nginx.path
# nginx.conf 저장 → 자동 문법검사 → reload

```

---

## 명령 치트시트

| 목적 | 명령 |
|---|---|
| 서비스 제어 | `systemctl start|stop|restart NAME` |
| 부팅 등록/해제 | `systemctl enable|disable NAME` |
| 상태/로그 | `systemctl status NAME`, `journalctl -u NAME -f` |
| 유닛 검색/목록 | `systemctl list-units --type=service`, `systemctl list-unit-files` |
| 타겟 | `systemctl get-default`, `systemctl set-default multi-user.target`, `systemctl isolate rescue.target` |
| 데몬 재읽기 | `systemctl daemon-reload` |
| 부팅 분석 | `systemd-analyze time|blame|critical-chain` |
| 유닛 소스/속성 | `systemctl cat NAME`, `systemctl show NAME` |
| 사용자 서비스 | `systemctl --user ...`, `loginctl enable-linger USER` |
| 레거시 | `service NAME restart`, `chkconfig NAME on` |

---

## 마무리

- 부팅은 **UEFI/GRUB → 커널/Initramfs → systemd**로 이어지는 **명확한 파이프라인**이다. 각 레이어에서 **문제 가설**을 세우고 **전용 도구**로 확인하라.
- `systemd`는 단순 시작/정지 도구를 넘어 **의존성 모델, 소켓/타이머/패스, cgroups, 보안 하드닝**까지 제공한다. **유닛 파일 설계**의 품질이 운영 안정성을 결정한다.
- 복구는 **GRUB 편집 → rescue/emergency/rd.break → 마운트/비번/SELinux 재라벨** 순으로 절차화하라.
- 새 시스템은 **systemd 중심**, 레거시는 **호환을 이해**하되 점진적 마이그레이션을 추진하라.
