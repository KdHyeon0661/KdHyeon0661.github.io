---
layout: post
title: Linux - 부팅과 서비스 관리
date: 2024-11-14 19:20:23 +0900
category: Linux
---
# 부팅과 서비스 관리

## 시스템 부팅의 전체 흐름

리눅스 시스템의 부팅 과정은 여러 단계를 거치며 각 단계마다 고유한 역할을 수행합니다. 이 과정을 이해하는 것은 시스템 문제 해결과 최적화의 기초가 됩니다.

### 1. 펌웨어 단계 (BIOS/UEFI)

시스템 전원이 켜지면 가장 먼저 펌웨어(BIOS 또는 UEFI)가 실행됩니다. 이 단계에서는 하드웨어 초기화와 부팅 장치 선택이 이루어집니다. UEFI 시스템에서는 ESP(EFI System Partition)에서 부트로더(예: `\EFI\grub\grubx64.efi`)를 찾아 실행합니다.

### 2. 부트로더 단계 (GRUB)

GRUB와 같은 부트로더는 커널 이미지(`vmlinuz-*`)와 **initramfs**(초기 RAM 파일 시스템, `initrd.img` 또는 `initramfs-*`)를 메모리로 로드합니다. 또한 커널에 전달할 **커널 커맨드라인** 파라미터를 설정합니다. GRUB는 멀티부트 메뉴 제공, 커널 파라미터 임시 편집, 복구 모드 진입 등 다양한 기능을 담당합니다.

### 3. 커널과 Initramfs 단계

커널이 메모리에 로드되면 하드웨어 드라이버 초기화, 메모리 관리, 프로세스 및 네트워크 스택 구축 등의 핵심 작업을 수행합니다. **Initramfs**는 실제 루트 파일시스템을 마운트할 수 있도록 임시 루트 환경을 제공하며, 특히 암호화, LVM, RAID 드라이버가 필요한 경우에 중요합니다. 루트 파일시스템이 성공적으로 마운트되면 제어를 `init` 프로세스(현대 시스템에서는 `systemd`)로 넘깁니다.

### 4. Init 프로세스 단계 (systemd)

PID 1로 실행되는 `systemd`는 시스템의 초기화 관리자 역할을 합니다. **타겟(target)** 단위로 서비스들을 병렬로 시작하며, 의존성(`Requires`/`Wants`)과 실행 순서(`After`/`Before`)를 고려하여 안정적이면서도 신속한 부팅을 구현합니다.

### 5. 로그인 단계

시스템이 완전히 부팅된 후에는 사용자 로그인을 위한 환경이 제공됩니다. 이는 TTY 콘솔(`agetty`), SSH 데몬(`sshd`), 또는 그래픽 디스플레이 매니저(GDM, SDDM, LightDM 등)를 통해 이루어집니다.

---

## GRUB 부트로더 실무 가이드 (UEFI 환경 기준)

### GRUB 메뉴 임시 편집

부팅 시 GRUB 화면에서 원하는 커널 항목을 선택한 후 `e` 키를 누르면 편집 모드로 진입합니다. `linux` 줄의 끝에 필요한 파라미터를 추가한 후 `Ctrl+x`를 눌러 해당 설정으로 부팅할 수 있습니다.

**디버깅을 위한 일회성 부팅 예시**:
```text
linux /boot/vmlinuz-... root=UUID=... ro systemd.unit=rescue.target
```

### GRUB 구성 파일 재생성

시스템 변경 사항(예: 새 커널 설치)이 GRUB에 반영되도록 구성 파일을 재생성해야 할 때가 있습니다.

**Debian/Ubuntu 계열**:
```bash
sudo update-grub
```

**RHEL/Fedora 계열 (UEFI)**:
```bash
sudo grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg
```

### GRUB 보안 강화 (선택 사항)

물리적 접근이 가능한 환경에서는 GRUB 부트로더에 대한 비인가 접근을 방지하는 것이 중요합니다.

```bash
# RHEL/Fedora 계열 예시: GRUB 수퍼유저 암호 설정
sudo grub2-setpassword
```
이 설정은 부트로더 메뉴에서 임의의 커널 파라미터를 주입하는 것을 방지하여 시스템 보안을 강화합니다.

---

## 유용한 커널 커맨드라인 파라미터

문제 해결이나 시스템 복구 시 다음과 같은 커널 파라미터들이 유용하게 사용됩니다.

- `systemd.unit=rescue.target`: 단일 사용자 모드(대부분의 서비스가 중지된 상태)로 부팅합니다.
- `systemd.unit=emergency.target`: 최소한의 셸만 제공하는 모드로 부팅합니다(루트 파일시스템 마운트 필요).
- `rd.break`: initramfs 단계에서 셸을 제공하여 루트 비밀번호 재설정 등의 작업을 수행할 수 있습니다.
- `selinux=0`: SELinux를 일시적으로 비활성화합니다(문제 원인 격리용, 상시 사용 금지).
- `rootdelay=10`: 느린 디스크 초기화를 대비하여 루트 장치 대기 시간을 증가시킵니다.

---

## Initramfs 재생성 방법

하드웨어 드라이버나 파일시스템 모듈을 변경한 후에는 initramfs를 재생성해야 할 수 있습니다.

**Debian/Ubuntu 계열**:
```bash
sudo update-initramfs -u -k all
```

**RHEL/Fedora 계열**:
```bash
sudo dracut -f
```

---

## Systemd 핵심 개념: 유닛, 타겟, 의존성 모델

### 유닛(Unit)의 주요 타입

Systemd는 다양한 시스템 컴포넌트를 **유닛**이라는 단위로 관리합니다.

- **`.service`**: 데몬이나 서비스를 관리합니다.
- **`.socket`**: 소켓 활성화를 통해 요청 시 서비스를 시작합니다.
- **`.timer`**: 예약 실행을 관리합니다(크론 작업 대체 가능).
- **`.path`**: 파일 또는 디렉터리 변경을 감지하여 서비스를 트리거합니다.
- **`.mount`**, **`.automount`**: 파일시스템 마운트를 관리합니다.
- **`.target`**: 실행 레벨(전통적 런레벨)을 논리적 그룹으로 표현합니다.

### 서비스 유닛 예시 (보안 강화 포함)

다음은 실제 운영 환경에서 사용할 수 있는 보안이 강화된 서비스 유닛 파일 예시입니다.

`/etc/systemd/system/myapp.service`:
```ini
[Unit]
Description=My App (REST API)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=myapp
Group=myapp
WorkingDirectory=/opt/myapp
EnvironmentFile=-/etc/myapp/myapp.env
ExecStart=/opt/myapp/bin/myapp --config /etc/myapp/config.yaml
Restart=on-failure
RestartSec=3

# 보안 및 격리 설정 (가능한 많은 옵션 적용)
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=full
ProtectHome=true
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true
RestrictSUIDSGID=true
ReadWritePaths=/var/lib/myapp /var/log/myapp
CapabilityBoundingSet=
AmbientCapabilities=
LockPersonality=true
MemoryDenyWriteExecute=true
RestrictRealtime=true
RestrictAddressFamilies=AF_INET AF_INET6
SystemCallFilter=@system-service  # 필요 시 허용 목록으로 조정

[Install]
WantedBy=multi-user.target
```

**중요 포인트**:
- **After/Before**: 서비스 실행 **순서**를 제어합니다.
- **Wants/Requires**: 실행 **의존성**을 정의합니다. `Requires`로 지정된 서비스가 실패하면 해당 서비스도 실패합니다.
- **보안 강화**: `ProtectSystem`, `PrivateTmp`, `NoNewPrivileges`, `CapabilityBoundingSet` 등의 옵션으로 서비스의 피해 가능 범위를 최소화합니다.
- **쓰기 권한 제한**: 쓰기가 필요한 경로만 `ReadWritePaths`로 명시적으로 허용합니다.

### 유닛 파일 관리

```bash
# 유닛 파일 변경 후 systemd에 인지시키기
sudo systemctl daemon-reload

# 서비스 활성화(부팅 시 자동 시작) 및 즉시 시작
sudo systemctl enable --now myapp

# 서비스 상태 확인
sudo systemctl status myapp
```

### 드롭인(Override)을 통한 유닛 확장

배포판에서 제공하는 기본 서비스 유닛을 직접 수정하는 대신 드롭인 방식을 사용하는 것이 좋습니다. 이렇게 하면 패키지 업데이트 시 변경사항이 유지됩니다.

```bash
# nginx 서비스에 대한 드롭인 파일 생성/편집
sudo systemctl edit nginx
```
이 명령은 `/etc/systemd/system/nginx.service.d/override.conf` 파일을 생성하거나 엽니다. 예시 내용:
```ini
[Service]
Environment="NGINX_CONF=/etc/nginx/nginx.conf"
```
변경 후에는 반드시 `daemon-reload`를 실행해야 합니다.
```bash
sudo systemctl daemon-reload
sudo systemctl restart nginx
```

---

## 타겟(Target)과 런레벨(Runlevel)

### 전통적 런레벨과 Systemd 타겟의 대응 관계

| 런레벨 | Systemd 타겟 | 설명 |
|--------|---------------|------|
| 0 | `poweroff.target` | 시스템 종료 |
| 1 | `rescue.target` | 단일 사용자 모드 (복구 모드) |
| 3 | `multi-user.target` | CLI 기반 다중 사용자 모드 (서버 기본) |
| 5 | `graphical.target` | GUI 포함 다중 사용자 모드 (데스크톱 기본) |
| 6 | `reboot.target` | 시스템 재부팅 |

### 타겟 관리 명령어

```bash
# 현재 기본 타겟 확인
systemctl get-default

# 기본 타겟 변경 (예: CLI 모드로 설정)
sudo systemctl set-default multi-user.target

# 특정 타겟으로 일시 전환 (격리 모드)
sudo systemctl isolate rescue.target
```

---

## 서비스 기동과 상태 관리

### 기본 서비스 관리 명령

```bash
# 서비스 시작/정지/재시작
sudo systemctl start|stop|restart myapp

# 서비스 설정만 재로드 (실행 중인 서비스에 영향 없음)
sudo systemctl reload myapp

# 부팅 시 자동 시작 활성화/비활성화
sudo systemctl enable|disable myapp

# 자동 시작 활성화 여부 확인
systemctl is-enabled myapp

# 모든 서비스 유닛 목록 확인
systemctl list-units --type=service
```

### 로그 분석과 유닛 정보 확인

```bash
# 현재 부팅 이후의 서비스 로그 확인 (끝부분부터)
journalctl -u myapp -b -e

# 서비스 로그 실시간 모니터링
journalctl -u myapp -f

# 유닛 파일 전체 내용 확인 (드롭인 포함)
systemctl cat myapp

# 유닛의 모든 속성 덤프
systemctl show myapp | less
```

---

## 부팅 성능 분석과 병목 지점 진단

Systemd는 부팅 과정의 성능 분석을 위한 강력한 도구들을 제공합니다.

```bash
# 전체 부팅 시간 분석
systemd-analyze time

# 각 유닛별 소요 시간 순위 (느린 순)
systemd-analyze blame

# 크리티컬 체인 분석 (의존성 경로 추적)
systemd-analyze critical-chain
```

**부팅 지연 개선 팁**:
- 순수 의존성은 `Wants`로 설정하고, 진정 필수적인 경우에만 `Requires`를 사용하세요.
- `After` 지시어를 남용하지 마세요. 진정한 순서 의존성이 필요한지 검토하세요.
- 네트워크가 필요한 서비스는 `network-online.target`을 정확히 사용하세요(네트워크 인터페이스 활성화와 실제 네트워크 연결 준비는 다릅니다).
- 과도한 보안 하드닝 옵션이 I/O 지연을 유발하지 않는지 확인하세요.

---

## 고급 유닛 타입: 소켓, 타이머, 패스

### 소켓 활성화: 필요할 때만 서비스 실행

소켓 활성화는 클라이언트 연결 요청이 들어왔을 때만 서비스를 시작하는 방식으로, 시스템 자원을 효율적으로 사용할 수 있습니다.

**소켓 유닛 예시** (`/etc/systemd/system/echod.socket`):
```ini
[Unit]
Description=Echo server socket

[Socket]
ListenStream=127.0.0.1:9999
Accept=yes

[Install]
WantedBy=sockets.target
```

**인스턴스 서비스 유닛** (`/etc/systemd/system/echod@.service`):
```ini
[Unit]
Description=Echo server (%i)

[Service]
ExecStart=/usr/bin/socat - "STDOUT"
StandardInput=socket
```

**활성화 및 테스트**:
```bash
sudo systemctl enable --now echod.socket
nc 127.0.0.1 9999  # 연결 테스트
```

### 타이머 유닛: 정해진 시간에만 실행

타이머 유닛은 전통적인 cron 작업을 대체할 수 있으며, 더 정교한 스케줄링과 통합된 로깅을 제공합니다.

**서비스 유닛** (`/etc/systemd/system/nightly-backup.service`):
```ini
[Unit]
Description=Nightly backup

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/nightly-backup.sh
User=backup
Group=backup
```

**타이머 유닛** (`/etc/systemd/system/nightly-backup.timer`):
```ini
[Unit]
Description=Run backup nightly

[Timer]
OnCalendar=02:30
RandomizedDelaySec=5m
Persistent=true

[Install]
WantedBy=timers.target
```

**활성화 및 관리**:
```bash
sudo systemctl enable --now nightly-backup.timer
systemctl list-timers  # 모든 활성 타이머 확인
```

### 패스 유닛: 파일 변경 시 실행

패스 유닛은 특정 파일이나 디렉터리의 변경을 감지하여 서비스를 트리거합니다.

**패스 유닛** (`/etc/systemd/system/reload-nginx.path`):
```ini
[Unit]
Description=Watch nginx configuration

[Path]
PathChanged=/etc/nginx/nginx.conf

[Install]
WantedBy=multi-user.target
```

**서비스 유닛** (`/etc/systemd/system/reload-nginx.service`):
```ini
[Unit]
Description=Reload nginx

[Service]
Type=oneshot
ExecStart=/bin/sh -c 'nginx -t && systemctl reload nginx'
```

**활성화**:
```bash
sudo systemctl enable --now reload-nginx.path
# 이제 nginx.conf 파일을 저장할 때마다 자동으로 설정 검증 후 재로드됩니다.
```

---

## 사용자 서비스와 Linger 기능

Systemd는 시스템 전체 서비스뿐만 아니라 사용자별 서비스도 관리할 수 있습니다.

### 사용자 서비스 관리

```bash
# 현재 사용자를 위한 서비스 활성화 및 시작
systemctl --user enable --now mytool.service

# 사용자 서비스 로그 확인
journalctl --user -u mytool -f
```

### Linger 기능: 로그인 없이도 사용자 서비스 유지

사용자가 로그아웃한 후에도 사용자 서비스가 계속 실행되도록 하려면 linger 기능을 활성화해야 합니다.

```bash
# 특정 사용자에 대해 linger 활성화
sudo loginctl enable-linger <username>
```

---

## Cgroups v2를 이용한 자원 제한

Systemd 서비스 유닛에서 cgroups v2 옵션을 사용하여 CPU, 메모리, I/O 자원을 제한할 수 있습니다.

**서비스 유닛 내 자원 제한 예시**:
```ini
[Service]
CPUQuota=200%           # 최대 2개의 가상 CPU 코어 사용
MemoryMax=2G            # 메모리 사용 상한 2GB
IOReadBandwidthMax=/dev/sda 50M  # 디스크 읽기 대역폭 제한
BlockIOWeight=500       # 블록 I/O 상대적 가중치
TasksMax=1024           # 최대 프로세스/스레드 수
```
이러한 설정은 컨테이너와 유사한 자원 격리 효과를 시스템 서비스에도 적용할 수 있게 해줍니다.

---

## SELinux/AppArmor와의 통합

### SELinux 환경에서의 문제 해결

SELinux가 강제(Enforcing) 모드인 환경에서 서비스가 실패한다면, 먼저 SELinux 정책 위반 여부를 확인해야 합니다.

```bash
# 최근 발생한 SELinux AVC(액세스 벡터 캐시) 거부 메시지 확인
sudo ausearch -m avc -ts recent

# SELinux 문제 분석 도구로 자세한 정보 확인
sudo sealert -a /var/log/audit/audit.log
```

### AppArmor 관리

AppArmor를 사용하는 시스템에서는 다음과 같이 프로파일을 관리할 수 있습니다.

```bash
# AppArmor 상태 확인
sudo aa-status

# 특정 프로파일을 불평(complain) 모드로 전환 (거부 대신 로깅만)
sudo aa-complain /etc/apparmor.d/usr.sbin.nginx

# 특정 프로파일을 강제(enforce) 모드로 전환
sudo aa-enforce /etc/apparmor.d/usr.sbin.nginx
```

보안 정책과 systemd의 보안 하드닝 옵션을 함께 설계하면 시스템의 방어 수준을 크게 높일 수 있습니다.

---

## 실전 복구 시나리오

### 부팅 실패: Rescue/Emergency 모드 진입

GRUB 화면에서 `e` 키를 눌러 편집 모드로 들어간 후, `linux` 줄 끝에 다음 파라미터를 추가합니다:
```text
systemd.unit=rescue.target
```
또는 더 제한적인 모드가 필요하다면:
```text
systemd.unit=emergency.target
```

Rescue 모드에서 루트 파일시스템을 읽기/쓰기 모드로 재마운트:
```bash
mount -o remount,rw /
```

### 루트 비밀번호 분실: rd.break 활용

GRUB에서 `e`를 눌러 편집 모드로 진입한 후, `linux` 줄 끝에 다음을 추가합니다:
```text
rd.break
```

Initramfs 셸에서 다음 단계를 수행합니다:
```bash
# 루트 파일시스템을 읽기/쓰기 모드로 재마운트
mount -o remount,rw /sysroot

# 루트 파일시스템으로 체인지루트
chroot /sysroot

# 루트 비밀번호 변경
passwd

# SELinux 사용 시 자동 재라벨링 트리거 (필요시)
touch /.autorelabel

# 종료
exit
exit  # 두 번 실행하여 재부팅
```

### 서비스 유닛 디버깅

서비스가 제대로 시작되지 않을 때는 체계적으로 문제를 진단해야 합니다.

```bash
# 서비스 상태 확인
systemctl status troubled.service

# 서비스 로그 확인 (현재 부팅 이후)
journalctl -u troubled.service -b -e

# 유닛 파일 전체 내용 확인
systemctl cat troubled.service

# 유닛 속성 확인 (처음 80줄)
systemctl show troubled.service | sed -n '1,80p'
```

**확인할 주요 사항**:
- `ExecStart` 경로의 정확성과 실행 권한
- `WorkingDirectory` 설정
- 환경 파일 경로와 내용
- 파일/디렉터리 소유권과 권한
- 과도한 보안 하드닝 옵션(`ProtectSystem=full` 등)으로 인한 실패 가능성

### 기본 타겟 손상 또는 GUI 문제

```bash
# 현재 기본 타겟 확인
systemctl get-default

# 기본 타겟을 CLI 모드로 변경
sudo systemctl set-default multi-user.target

# 즉시 CLI 모드로 전환
sudo systemctl isolate multi-user.target
```
GUI 관련 문제는 `graphical.target` 대신 CLI 모드로 부팅한 후 그래픽 드라이버나 디스플레이 매니저를 점검하는 것이 좋습니다.

---

## SysVinit 호환성 (레거시 시스템)

### service와 chkconfig 명령

일부 레거시 시스템이나 호환성을 위해 전통적인 명령어도 사용할 수 있습니다.

```bash
# 서비스 재시작 (내부적으로 systemctl로 브리징됨)
sudo service ssh restart

# 부팅 시 자동 시작 설정 (CentOS/RHEL 6 이전)
sudo chkconfig httpd on
```
현대 배포판에서는 이러한 명령들이 내부적으로 `systemctl`로 변환되거나, SysV init 스크립트에 대한 systemd 호환 유닛이 자동 생성됩니다.

### 직접 init 스크립트 실행

```bash
sudo /etc/init.d/sshd restart
```
**참고**: 새 시스템에서는 systemd를 우선적으로 사용하는 것이 좋으며, 레거시 시스템은 점진적으로 systemd로 마이그레이션하는 것을 권장합니다.

---

## 실전 예제 모음

### 예제 1: SSH 서비스 재시작 및 상태 확인
```bash
sudo systemctl restart ssh
sudo systemctl status ssh
```

### 예제 2: Nginx 서비스 부팅 시 자동 시작 설정
```bash
sudo systemctl enable nginx
```

### 예제 3: 기본 부팅 모드를 CLI로 설정
```bash
sudo systemctl set-default multi-user.target
```

### 예제 4: 느린 부팅의 원인 분석
```bash
systemd-analyze blame
systemd-analyze critical-chain
```

### 예제 5: 소켓 활성화를 통한 온디맨드 API 서비스
```bash
# 요청이 들어올 때만 프로세스가 시작되도록 socket+@service 구성
curl http://127.0.0.1:9999
```

### 예제 6: 설정 파일 변경 감지 시 자동 재로드
```bash
sudo systemctl enable --now reload-nginx.path
# nginx.conf 파일을 저장하면 자동으로 문법 검사 후 재로드됩니다.
```

---

## 명령어 요약

| 작업 | 명령어 |
|------|--------|
| 서비스 제어 | `systemctl start\|stop\|restart NAME` |
| 부팅 시 자동 시작 관리 | `systemctl enable\|disable NAME` |
| 서비스 상태 및 로그 | `systemctl status NAME`, `journalctl -u NAME -f` |
| 유닛 검색 및 목록 | `systemctl list-units --type=service`, `systemctl list-unit-files` |
| 타겟 관리 | `systemctl get-default`, `systemctl set-default multi-user.target`, `systemctl isolate rescue.target` |
| 유닛 파일 변경 적용 | `systemctl daemon-reload` |
| 부팅 성능 분석 | `systemd-analyze time\|blame\|critical-chain` |
| 유닛 정보 확인 | `systemctl cat NAME`, `systemctl show NAME` |
| 사용자 서비스 관리 | `systemctl --user ...`, `loginctl enable-linger USER` |
| 레거시 명령 | `service NAME restart`, `chkconfig NAME on` |

---

## 결론

리눅스 시스템의 부팅과 서비스 관리는 체계적인 이해와 적절한 도구 사용을 통해 효율적으로 관리할 수 있습니다. 시스템 부팅은 **UEFI/GRUB → 커널/Initramfs → systemd**로 이어지는 명확한 파이프라인을 따르며, 각 단계에서 발생할 수 있는 문제에 대한 가설을 세우고 적절한 도구로 확인하는 접근이 필요합니다.

Systemd는 단순한 서비스 관리자를 넘어 의존성 모델, 소켓/타이머/패스 유닛, cgroups 기반 자원 제한, 포괄적인 보안 강화 옵션까지 제공하는 통합 시스템 관리 프레임워크입니다. 서비스 유닛 파일의 설계 품질이 시스템의 운영 안정성과 보안 수준을 결정하는 중요한 요소입니다.

복구 상황에서는 **GRUB 편집 → rescue/emergency/rd.break 모드 진입 → 파일시스템 마운트/비밀번호 재설정/SELinux 재라벨링** 순으로 체계적인 절차를 따르는 것이 중요합니다.

새로운 시스템에서는 systemd를 중심으로 설계하고 관리하는 것이 좋으며, 레거시 환경에서는 호환성 메커니즘을 이해하면서도 점진적인 마이그레이션을 추진하는 전략이 효과적입니다. 이러한 원칙과 도구들을 잘 활용한다면, 복잡한 리눅스 시스템도 안정적으로 운영하고 문제를 효과적으로 해결할 수 있을 것입니다.