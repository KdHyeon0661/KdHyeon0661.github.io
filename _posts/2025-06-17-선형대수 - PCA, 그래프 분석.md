---
layout: post
title: 선형대수 - PCA, 그래프 분석
date: 2025-06-17 22:20:23 +0900
category: 선형대수
---
# 고유값의 활용: PCA, 그래프 스펙트럴, 동역학, 물리

> **핵심 한 줄** — 고유값/고유벡터는 “**어떤 선형 변환이 특정 방향을 얼마나 키우거나(또는 회전·진동시키는지)**”를 정량화한다.
> 데이터의 **주성분**, 그래프의 **연결/군집**, 동역학의 **안정성**, 물리의 **에너지 준위** 모두 고유값 이야기다.

---

## 0. 빠른 로드맵

| 분야 | 행렬 | 고유값 의미 | 고유벡터 의미 | 대표 작업/지표 |
|---|---|---|---|---|
| **PCA** | 공분산 \(C=\frac1n X^\top X\) | 방향별 분산량 | 주성분 축 | 차원축소, 설명분산비 |
| **그래프** | 라플라시안 \(L=D-A\) / 정규화 \(\mathcal L=I-D^{-1/2}AD^{-1/2}\) | 연결성·스펙트럴갭 | 군집 경계(피들러) | 스펙트럴 클러스터링 |
| **PageRank/중심성** | 확률전이 \(P\), 구글행렬 \(G\) | 정착·순위 수렴 속도 | 랭크 벡터/중심성 | 파워 이터레이션 |
| **연속시간 동역학** | 시스템 \(A\) | 성장/감쇠(실수부), 진동(허수부) | 모드 방향 | 안정성(실수부<0) |
| **이산시간 동역학** | 시스템 \(A\) | 스펙트럴 반지름 | 모드 방향 | 안정성(\(|\lambda|<1\)) |
| **마르코프/체인** | 전이 \(P\) | \(\lambda_1=1\) 정착 | 정상분포 | 믹싱율(갭) |
| **양자역학** | 해밀토니안 \(H\) | 에너지 준위 | 고유상태 | 분광, 상태해석 |
| **진동/구조** | \(M^{-1}K\) or generalized \((K,M)\) | 고유진동수^2 | 정상모드 | 공진, 모드해석 |

---

## 1. PCA: 공분산의 고유분해로 보는 주성분

### 1.1 정의와 원리

- 평균 중심화된 데이터 \(X\in\mathbb R^{n\times d}\) (행=샘플, 열=특징).
- 공분산 \(C=\frac{1}{n}X^\top X\in\mathbb R^{d\times d}\).
- 고유분해
  $$
  C\mathbf v_i=\lambda_i\mathbf v_i,\quad \lambda_1\ge\lambda_2\ge\cdots\ge 0.
  $$
  - \(\mathbf v_i\): **주성분 방향(축)**
  - \(\lambda_i\): 그 방향의 **분산량** (설명력)
- 차원 \(k\)로 줄이려면 \(V_k=[\mathbf v_1,\dots,\mathbf v_k]\) 에 투영:
  $$
  Z=X V_k \in \mathbb R^{n\times k}.
  $$

> **SVD 등가성**: \(X=U\Sigma V^\top\) 이면 \(C=V\Sigma^2 V^\top\).
> 즉, **특이값 \(\sigma_i\)^2 = 고유값 \(\lambda_i\)**.

### 1.2 실전 체크포인트
- **중심화** 필수(평균 0) \(\Rightarrow\) 미중심화는 1주성분이 평균 방향을 잡는다.
- 스케일 상이하면 **표준화**(z-score) 고려.
- 수치엔 **SVD** 권장(`eigh`는 대칭일 때 빠르고 안정적).

### 1.3 미니 예제 (NumPy, SVD 기반 PCA)

```python
import numpy as np

# (행=샘플, 열=특징) 예시 데이터
X = np.array([
    [2.5, 2.4],
    [0.5, 0.7],
    [2.2, 2.9],
    [1.9, 2.2],
    [3.1, 3.0]
], dtype=float)

# 1. 평균 중심화
Xc = X - X.mean(axis=0, keepdims=True)

# 2. SVD
U, S, Vt = np.linalg.svd(Xc, full_matrices=False)
# 고유값 = (S^2)/(n-1)  (np.cov 기본 정의 일치 위해 n-1 사용)
lam = (S**2) / (len(X) - 1)
V = Vt.T  # 주성분 축

print("주성분(열):\n", V)
print("고유값(분산):", lam)
print("설명분산비:", lam / lam.sum())

# 3. k=1로 투영
k = 1
Z = Xc @ V[:, :k]
print("1차원 투영 결과 shape:", Z.shape)
```

### 1.4 상황 예시
- **얼굴 인식(Eigenfaces)**: 얼굴 이미지(픽셀)를 고차원 벡터로 보고 PCA 축으로 투영 → 압축·노이즈 제거·유사도 계산.
- **센서 융합**: 중복 정보가 많다면 상관축을 PCA로 묶고, 정보량 적은 축 제거.

---

## 2. 그래프 스펙트럴: 라플라시안으로 보는 연결과 군집

### 2.1 기본 행렬
- 인접행렬 \(A\), 차수행렬 \(D=\mathrm{diag}(d_i)\).
- **(콤비네토리얼) 라플라시안**: \(L=D-A\) (대칭, 반정부호 반정확).
- **정규화 라플라시안**:
  $$
  \mathcal L = I - D^{-1/2} A D^{-1/2}.
  $$

### 2.2 핵심 스펙트럴 사실
- \(L\)의 고유값은 \(0=\lambda_1\le\lambda_2\le\cdots\).
  **0의 중복도 = 연결 성분 개수**.
- 두 번째로 작은 \(\lambda_2\) (**Fiedler 값**)이 작을수록 “약하게 연결”되어 분할 쉬움.
- Fiedler **고유벡터**의 부호/값으로 그래프를 2-분할 → **스펙트럴 클러스터링**.

### 2.3 알고리즘(정규화 라플라시안, 다중 군집)
1) \(\mathcal L\) 구성 → 2) 작은 고유값에 대응하는 상위 \(k\)개의 고유벡터 모아 \(U\in\mathbb R^{n\times k}\)
3) 각 행을 정규화 → 4) **k-means**로 행(노드) 클러스터링.

### 2.4 간단 예제 (작은 그래프)

```python
import numpy as np

# 두 클러스터가 희미하게 연결된 장난감 그래프
A = np.array([
    [0,1,1,0,0,0],
    [1,0,1,0,0,0],
    [1,1,0,1,0,0], # 약간의 브리지 엣지(2-3-4-5 식으로 연결)
    [0,0,1,0,1,1],
    [0,0,0,1,0,1],
    [0,0,0,1,1,0],
], dtype=float)

D = np.diag(A.sum(axis=1))
L = D - A

# 정규화 라플라시안
D_inv_sqrt = np.diag(1.0/np.sqrt(np.maximum(np.diag(D), 1e-12)))
Lnorm = np.eye(A.shape[0]) - D_inv_sqrt @ A @ D_inv_sqrt

# 작은 고유값부터
evals, evecs = np.linalg.eigh(Lnorm)
idx = np.argsort(evals)
evals, evecs = evals[idx], evecs[:, idx]

print("정규화 라플라시안 고유값:", np.round(evals, 4))

# k=2로 클러스터링 (부호로도 가능, 여기서는 단순 임계)
fiedler_vec = evecs[:, 1]
labels = (fiedler_vec > 0).astype(int)
print("2-분할 라벨:", labels)
```

> 실제 프로젝트에서는 `sklearn.cluster.KMeans`로 2단계(행 정규화 후 k-means)를 수행.

### 2.5 인접행렬의 스펙트럼 & 중심성
- **Perron–Frobenius**: 비음수 대칭 \(A\)의 최대 고유값 \(\lambda_{\max}\)와 대응 고유벡터는 양(준)값 → **eigenvector centrality**.
- **PageRank**: 구글 행렬 \(G=\alpha P +(1-\alpha)\frac{1}{n}\mathbf 1\mathbf 1^\top\) 의 **고유벡터(고유값=1)** 를 파워 이터레이션으로 구함.

---

## 3. PageRank/고유벡터 중심성: 파워 이터레이션

```python
import numpy as np

# 간단한 방향 그래프의 확률전이행렬 P (열확률 혹은 행확률 중 하나 택일)
# 여기서는 행확률로 구성 (각 행의 합이 1)
P = np.array([
    [0.0, 1.0, 0.0],
    [0.5, 0.0, 0.5],
    [1.0, 0.0, 0.0]
], dtype=float)

alpha = 0.85
n = P.shape[0]
G = alpha * P + (1-alpha) * np.ones((n, n))/n  # 구글행렬

x = np.ones(n)/n  # 초기 분포
for _ in range(100):
    x_next = G @ x
    if np.linalg.norm(x_next - x, 1) < 1e-12:
        break
    x = x_next

print("PageRank 벡터(정상 고유벡터):", x / x.sum())
```

> 고유값 1에 대응하는 고유벡터가 **순위/중요도**.
> 수렴속도는 **스펙트럴 갭** \(1-|\lambda_2|\)에 좌우된다.

---

## 4. 선형 동역학: 안정성과 모드 해석

### 4.1 연속시간 \( \dot{\mathbf x}=A\mathbf x \)
해일반형(대각화 가능 가정):
$$
\mathbf x(t)=\sum_i c_i e^{\lambda_i t}\mathbf v_i.
$$
- **안정성**: 모든 고유값 실수부 \(\Re(\lambda_i)<0\) 이면 원점 **지수 안정**.
- **복소 고유값** \(\lambda=a\pm i\omega\): **감쇠(또는 발산) + 진동**.

#### 시뮬레이션 예제

```python
import numpy as np
from scipy.linalg import expm

A = np.array([[0, 1],
              [-2, -1]], dtype=float)  # 안정(고유값 실수부<0)
x0 = np.array([1.0, 0.0])

ts = np.linspace(0, 5, 11)
traj = np.stack([expm(A*t) @ x0 for t in ts], axis=0)
print("t, x(t):")
for t, xt in zip(ts, traj):
    print(f"{t:.2f}", np.round(xt, 4))
```

### 4.2 이산시간 \( \mathbf x_{k+1}=A\mathbf x_k \)
- **안정성**: 모든 고유값 \(|\lambda_i|<1\) 이면 원점 **지수 안정**.
- 스펙트럴 반지름 \(\rho(A)=\max_i|\lambda_i|\) 가 1보다 작아야 수렴.

---

## 5. 마르코프 체인: 정상분포와 스펙트럴 갭

- 전이행렬 \(P\) (행확률) 에서 정상분포 \(\pi\) 는 \(\pi^\top=\pi^\top P\) (고유값=1).
- 두 번째 고유값의 크기 \(|\lambda_2|\) 가 작을수록 **빠른 균등화(믹싱)**.
  갭 \(1-|\lambda_2|\) 가 클수록 좋다.

```python
import numpy as np

P = np.array([
    [0.9, 0.1],
    [0.2, 0.8]
])
evals, evecs = np.linalg.eig(P.T)
i = np.argmin(np.abs(evals - 1.0))
pi = evecs[:, i].real
pi = pi / pi.sum()
print("정상분포 π:", pi)
print("스펙트럴 갭:", 1 - np.sort(np.abs(evals))[-2])
```

---

## 6. 물리 예시

### 6.1 양자: \(H\psi=E\psi\) (에너지 고유값 문제)
- 행렬 \(H\) (해밀토니안) 의 고유값 \(E\): **에너지 준위**, 고유벡터 \(\psi\): **고유상태**.
- 예: 스핀-1/2 (파울리 Z)

```python
import numpy as np

sigma_z = np.array([[1, 0],
                    [0,-1]], dtype=complex)
H = 0.5 * sigma_z
E, psi = np.linalg.eigh(H)   # 허미티안 → eigh
print("에너지 고유값:", E)
print("고유상태(열벡터):\n", psi)
```

### 6.2 구조진동: \(K\mathbf u = \omega^2 M \mathbf u\)
- \(K\): 강성, \(M\): 질량 → **일반화 고유값 문제**.
- \(\omega\): 고유진동수, \(\mathbf u\): 모드형상.

```python
import numpy as np
from scipy.linalg import eigh  # generalized eigenproblem

# 3개 질점 스프링 예시
K = np.array([[ 2,-1, 0],
              [-1, 2,-1],
              [ 0,-1, 2]], dtype=float)
M = np.eye(3)

w2, U = eigh(K, M)  # K u = w^2 M u
w = np.sqrt(np.maximum(w2, 0))
print("자연진동수:", np.round(w, 4))
print("모드형상(열):\n", np.round(U, 4))
```

---

## 7. 수치해석 실무 팁: 언제 어떤 함수?

| 상황 | 추천 함수 | 이유 |
|---|---|---|
| 대칭/허미티안(공분산, 라플라시안, 해밀토니안) | `numpy.linalg.eigh` / `scipy.linalg.eigh` | 실수 스펙트럼, 안정적·빠름 |
| 일반 비대칭 | `numpy.linalg.eig` | 일반 고유분해 |
| 큰 희소행렬 상위 몇 개 | `scipy.sparse.linalg.eigs`/`eigsh` | ARPACK 기반, 부분 스펙트럼 |
| 주성분(크고 직사각형) | `numpy.linalg.svd` | 더 안정적, 특이값^2=고유값 |
| 최대고유값/벡터 | **파워 이터레이션** | 간단·대규모 가능 |
| 수치감도(비정규 행렬) | 스케일링/정규화·`svd` | 고유벡터 민감 → SVD 기반 |

### 7.1 파워 이터레이션 스니펫
```python
def power_iteration(A, iters=1000, tol=1e-9):
    n = A.shape[0]
    x = np.random.randn(n)
    x /= np.linalg.norm(x)
    lam_old = 0.0
    for _ in range(iters):
        y = A @ x
        x = y / (np.linalg.norm(y) + 1e-15)
        lam = x @ (A @ x)  # Rayleigh quotient
        if abs(lam - lam_old) < tol:
            break
        lam_old = lam
    return lam, x
```

---

## 8. 이론적 배경(필수 포인트)

- **스펙트럴 정리**: 실대칭(허미티안) 행렬은 직교기저로 대각화 가능 → 고유벡터 **직교**, 고유값 **실수**.
  PCA/라플라시안/해밀토니안이 여기에 해당.
- **SVD와 고유값**: \(X=U\Sigma V^\top\), \(X^\top X=V\Sigma^2 V^\top\).
  PCA는 사실상 **SVD**.
- **Jordan/비정규 행렬**: 대각화 불가(결함) 시 고유분해 불안정. 실무는 SVD/슈어 분해·Arnoldi.
- **스펙트럴 갭**: \(|\lambda_1|-|\lambda_2|\) (또는 1-|\(\lambda_2\)|) — 수렴/혼합/집합 분리의 난이도 척도.

---

## 9. 실전 시나리오 요리 레시피

### 9.1 고차원 데이터 압축 & 시각화
1) 중심화(+표준화) → 2) SVD로 상위 2~3축 → 3) 산점도.
**설명분산비 누적**로 k 선택(예: 95%).

### 9.2 네트워크 군집/분할
1) \(A,D,L\) 구성 → 2) \(\mathcal L\) 고유벡터 상위 k → 3) 행 정규화·k-means → 4) 군집 품질(모듈러리티/NCut) 확인.

### 9.3 동역학 모델 안정화
- 연속시간: \(\Re(\lambda_i)<0\) 되게 게인 조정(피드백).
- 이산시간: \(|\lambda_i|<1\) 되게 폴 배치.

### 9.4 순위/중요도 산출
- PageRank: 파워 이터레이션, 덤핑팩터 \(\alpha\) 튜닝(0.85~0.95).
- Eigenvector Centrality: \(A\mathbf v=\lambda\mathbf v\) 최대 고유쌍.

---

## 10. 자주 겪는 함정

- **중심화 누락(PCA)** → 1주성분이 평균 쏠림.
- **스케일 편차** → 큰 스케일 특성이 주성분을 독점(표준화 필요).
- **희소 대규모** → 밀집 `eig` 호출 금지, **희소용** 부분 분해 사용.
- **비정규 행렬 민감도** → 고유벡터 불안정, SVD 기반 접근 고려.
- **클러스터 k 고정** → 스펙트럼 “엘보/갭”을 보고 k 추정 시도.

---

## 11. 종합 예제: PCA → 투영 → 그래프 분할 → 동역학 안정성

```python
import numpy as np

# 1. 랜덤 3D 데이터 생성(두 개의 뭉치)
np.random.seed(0)
C1 = np.random.randn(50, 3)*0.4 + np.array([2, 2, 2])
C2 = np.random.randn(50, 3)*0.5 + np.array([-2, -2, 0])
X = np.vstack([C1, C2])
Xc = X - X.mean(axis=0, keepdims=True)

# PCA via SVD
U, S, Vt = np.linalg.svd(Xc, full_matrices=False)
V = Vt.T
Z2 = Xc @ V[:, :2]  # 2D 투영

# 2. 2D 공간의 k-최근접 이웃 그래프(간단: 완전그래프 대신 거리 임계)
from scipy.spatial.distance import pdist, squareform
D = squareform(pdist(Z2))
eps = np.percentile(D, 10)  # 10% 분위 임계
A = (D < eps).astype(float)
np.fill_diagonal(A, 0)
A = np.maximum(A, A.T)  # 무방향화

# 라플라시안 클러스터링(2-분할)
deg = np.diag(A.sum(axis=1))
L = deg - A
D_inv_sqrt = np.diag(1.0/np.sqrt(np.maximum(np.diag(deg),1e-12)))
Lnorm = np.eye(A.shape[0]) - D_inv_sqrt @ A @ D_inv_sqrt
evals, evecs = np.linalg.eigh(Lnorm)
fied = evecs[:, 1]
labels = (fied > 0).astype(int)

print("스펙트럴 분할 라벨 분포:", np.bincount(labels))

# 3. 각 클러스터의 선형 동역학 안정성 예시
A_sys = np.array([[0, 1], [-2, -0.5]])  # 안정
print("연속시간 시스템 고유값:", np.linalg.eigvals(A_sys))
```

---

## 12. 핵심 공식 모음

- **PCA**: \(C=\frac{1}{n}X^\top X\), \(C\mathbf v_i=\lambda_i\mathbf v_i\), 설명분산비 \(\lambda_i/\sum_j\lambda_j\).
- **그래프 라플라시안**: \(L=D-A\), \(\mathcal L=I-D^{-1/2}AD^{-1/2}\), \(\lambda_1=0\), 0의 중복도=성분수.
- **연속시간 안정성**: \(\Re(\lambda_i(A))<0\).
  **이산시간**: \(|\lambda_i(A)|<1\).
- **PageRank**: \(G=\alpha P+(1-\alpha)\frac{1}{n}\mathbf 1\mathbf 1^\top\), \(G\mathbf x=\mathbf x\).

---

## 마무리

고유값은 **방향(고유벡터)** 과 그 방향의 **강도(고유값)** 를 통해 “복잡한 것의 본질”을 드러낸다.
데이터 압축, 그래프 군집, 시스템 안정화, 물리적 상태 해석까지—**고유값을 해석하는 눈**이 문제를 구조적으로 단순하게 만든다.
