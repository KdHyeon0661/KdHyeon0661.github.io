---
layout: post
title: 객체지향설계 - 컴포넌트 기반 설계
date: 2025-07-31 19:20:23 +0900
category: 객체지향설계
---
# 컴포넌트 기반 설계(Component-based Design)과 객체 지향 설계의 조화 — 상세 가이드

컴포넌트 기반 설계와 객체 지향 설계(OOP)는 서로 경쟁하는 개념이 아니라 **상호 보완**되는 설계 관점입니다. 이 글은 두 접근을 어떻게 조화롭게 결합해 현실적이고 테스트 가능하며 확장 가능한 시스템을 만드는지 구체적으로 다룹니다.

---

# 1. 왜 조화가 필요한가? (핵심 동기)
- **관심사의 분리**: OOP는 클래스 단위로 책임을 명확히 하고, 컴포넌트는 시스템 수준에서 책임(모듈, 배포 단위)을 나눕니다. 둘을 합치면 코드 수준 책임과 시스템 수준 책임을 동시에 관리할 수 있습니다.  
- **유연한 배포/재사용**: 작은 객체를 컴포넌트로 묶어 라이브러리, 마이크로서비스, 마이크로프론트엔드 등 다양한 배포 단위로 활용할 수 있습니다.  
- **테스트와 운영의 용이성**: OOP의 캡슐화로 단위 테스트를 쉽고, 컴포넌트 경계로 통합·계약 테스트와 운영 모니터링을 분리할 수 있습니다.

---

# 2. 핵심 개념의 정렬 (OOP ↔ Component)
- **클래스(객체)** ↔ **컴포넌트 내부 단위**  
  클래스는 내부 구현(상태+행위)을 캡슐화. 컴포넌트는 관련 클래스/모듈의 집합으로서 외부에 **명확한 계약(인터페이스)**을 노출.
- **캡슐화** ↔ **경계(Boundary)**  
  OOP의 private/protected와 컴포넌트의 외부 API(REST, gRPC, JS API)는 같은 철학: 내부 구현 은닉.
- **책임 분배(SRP, GRASP)** ↔ **컴포넌트 책임(마이크로 책임)**  
  클래스 수준의 SRP와 컴포넌트 수준의 SRP(한 컴포넌트가 하나의 비즈니스 역량 담당) 병행.
- **합성 우선(Composition)** ↔ **컴포지션으로 컴포넌트 구성**  
  내부적으로는 클래스 합성, 외부적으로는 컴포넌트 조합으로 확장성 확보.

---

# 3. 설계 원칙 & 실천 가이드

## 단일 책임과 응집도
- 컴포넌트는 높은 응집도(관련 클래스/서비스 묶음)와 낮은 결합도를 목표로 설계.
- 클래스 수준에서 SRP를 지키고, 컴포넌트 수준에서도 **"하나의 비즈니스 기능"** 으로 묶는다.

## 명확한 계약(Contract)
- 컴포넌트는 인터페이스(공식 API)를 문서화하고 버전 관리. 내부 구현은 자유롭게 변경 가능.
- 계약은 **데이터 모델, 에러 규약, 성능·SLA 정보**까지 포함.

## 경계에서 부수효과 허용
- 부수효과(DB I/O, 네트워크)는 컴포넌트 경계 내부에서만 수행하고, 외부에는 명확한 추상(포트/어댑터)을 통해 노출.

## 의존성 관리 (DIP 적용)
- 컴포넌트는 내부에서 추상(인터페이스)에 의존하도록 설계. 구체 구현은 런타임에 주입—버전 호환성과 교체 용이.

## 구성/확장: 합성 > 상속
- 내부 클래스는 합성으로 역할을 결합, 컴포넌트는 다른 컴포넌트를 조합해 더 큰 기능을 만든다.

---

# 4. 통신 패턴: 언제 동기(HTTP/RPC), 언제 비동기(Event)?
- **동기 (Request/Response)**  
  - 짧고 즉시 응답이 필요한 작업(인증, 조회)에 적합.  
  - 장점: 단순성, 트랜잭션 경계 설정 용이. 단점: 높은 결합(지연 전파).
- **비동기 (Event / Message Bus / Pub-Sub)**  
  - 느슨한 결합, 확장성, 장애 격리에 유리. 이벤트 소싱·이벤트 드리븐 아키텍처에 적합.  
  - 장점: 가용성·확장성 우수. 단점: 복잡한 일관성 관리(최종 일관성).
- **권장**: 내부 컴포넌트 간은 동기 호출로 빠르게 처리하고(성능에 민감할 때), 도메인 경계나 비즈니스 이벤트는 비동기로 처리해 결합 완화.

---

# 5. 상태 소유권 & 일관성 전략
- **로컬 상태(컴포넌트 내부)**: 소유권 명확 — 해당 컴포넌트가 단일 소스 오브 트루스(SSOT).
- **공유 상태 금지**: 직접 공유 DB 사용은 결합을 높임. 대신 API 호출 또는 이벤트로 동기화.
- **일관성 모델**:  
  - **강한 일관성**: 트랜잭션이 필요한 경우 컴포넌트 경계 내에서 처리.  
  - **최종 일관성**: 이벤트와 보상 트랜잭션(또는 SAGA)으로 처리.  
- **패턴**: Event Sourcing + CQRS를 사용하면 변경 내역을 이벤트로 관리하고 읽기 모델을 별도로 구성 가능.

---

# 6. 패키징·배포·버전 관리
- **패키징 단위 결정**: 라이브러리(같은 프로세스), 별도 서비스(다른 프로세스), 마이크로프론트엔드(프론트엔드 컴포넌트) 중 선택.  
- **버전 관리 전략**: 세멘틱 버전(semver) 준수 — 비호환 변경 시 Major bump.  
- **호환성 유지**: 후방 호환성을 우선, 변경 시 소비자 계약 테스트(consumer-driven contract)를 수행(Pact 등).  
- **배포 전략**: Canary, Blue/Green, Feature Flags로 점진 배포.

---

# 7. 테스트 전략 (컴포넌트 관점)
- **단위 테스트**: 클래스/모듈 수준에서 내부 로직 검증.  
- **컴포넌트 통합 테스트**: 컴포넌트 내부 클래스들이 함께 동작하는지 검증(인메모리 DB, 가짜 어댑터 사용).  
- **계약 테스트**: 컴포넌트 간 API 계약 보장(consumer-driven contract).  
- **E2E 테스트**: 전체 플로우 검증 — 느리지만 필수.  
- **테스트 피라미드 권장**: 단위 테스트 많게 → 통합(컴포넌트) 적당히 → E2E는 최소로.

---

# 8. 관찰성·운영(Observability & Ops)
- 각 컴포넌트는 **메트릭, 로그, 트레이스, 상태(health)** 를 노출해야 함.  
- 추적(Tracing)은 요청이 여러 컴포넌트를 통과할 때 문제 원인 추적에 필수(예: OpenTelemetry).  
- SLO/SLI 정의: 컴포넌트별 가용성·성능 목표를 설정하고 모니터링.

---

# 9. 성능·스케일링 고려사항
- **그레인(Granularity)**: 너무 작은 컴포넌트는 통신 오버헤드를 늘리고, 너무 큰 컴포넌트는 확장성이 떨어짐. 적절한 균형 필요.  
- **데이터 로컬리티**: 빈번히 함께 호출되는 기능은 같은 컴포넌트나 노드에 배치해 네트워크 비용 절감.  
- **캐싱**: 컴포넌트 경계에서 캐시 전략을 명확히 정의(무효화 정책 포함).

---

# 10. 예제: 간단한 컴포넌트 인터페이스 (TypeScript)

```typescript
// PaymentComponent가 외부에 제공하는 계약(인터페이스)
export interface PaymentAPI {
  createPayment(request: CreatePaymentRequest): Promise<CreatePaymentResponse>;
  getPaymentStatus(paymentId: string): Promise<PaymentStatus>;
}

// 내부 구현은 여러 클래스로 구성될 수 있음
class PaymentService {
  constructor(private readonly gateway: PaymentGateway, private readonly repo: PaymentRepo) {}
  async createPayment(req: CreatePaymentRequest) {
    // 검증, 도메인 로직, 저장, 외부 게이트웨이 호출 등
  }
}
```

- `PaymentAPI` 는 컴포넌트 경계의 계약(contract). 호출자는 이 인터페이스만 알면 됨.
- 내부에서는 OOP 원칙(작은 클래스, SRP)을 적용해 `PaymentService`, `PaymentRepository`, `Validator` 등을 합성.

---

# 11. 마이그레이션 / 점진적 적용 전략
1. **경계 식별**: 도메인 지식(유비쿼터스 언어)으로 바운디드 컨텍스트/컴포넌트 후보 도출.  
2. **계약 설계**: API/이벤트 계약을 먼저 정의.  
3. **안전망 테스트**: 소비자 계약/통합 테스트 만들기.  
4. **추출(Extract)**: Monolith의 기능을 하나씩 컴포넌트로 추출(Branch by Abstraction / Strangler Fig).  
5. **배포·관찰**: 독립 배포 및 모니터링을 통해 안정성 검증.  
6. **반복·조정**: 호출 패턴·성능을 모니터링하며 컴포넌트 경계 조정.

---

# 12. 흔한 안티패턴 & 피해야 할 점
- **Chatty Components**: 작은 호출이 빈번히 오가면 성능 저하. → 호출 합치기, bulk API 제공.  
- **God Component**: 모든 책임을 한 컴포넌트에 몰아넣음. → 책임 분리.  
- **Shared Database (안전하지 않은 공유 DB)**: 컴포넌트 간 결합 증가. → 각 컴포넌트는 자신의 저장소를 소유하거나 명확한 접근 규약 사용.  
- **버전 헬(Version Hell)**: 계약 미검증 상태로 여러 버전 공존. → contract tests + semver 엄수.  
- **과도한 분리(Over-fragmentation)**: 너무 많은 컴포넌트는 운영 비용·복잡도 증가. → 합리적 묶음 필요.

---

# 13. 체크리스트 (컴포넌트 설계 시 점검)
- [ ] 컴포넌트의 책임이 명확한가? (한두 문장으로 설명 가능)  
- [ ] 외부 계약(API/이벤트/데이터 포맷)이 문서화·버전 관리되고 있는가?  
- [ ] 내부는 OOP 원칙(SRP, DIP, High Cohesion)을 따르고 있는가?  
- [ ] 상태 소유권이 명확한가? (누가 쓰고 누가 변경하는가)  
- [ ] 통신 방식(동기 vs 비동기)이 적절히 선택되었는가?  
- [ ] 테스트 전략(단위·컴포넌트 통합·계약·E2E)이 갖춰져 있는가?  
- [ ] 관찰성(메트릭/로그/트레이스) 체계가 준비되어 있는가?  
- [ ] 배포·롤백·버전전략이 정해져 있는가?

---

# 14. 도구·패턴 추천(간단)
- **계약 테스트**: Pact (consumer-driven contracts)  
- **이벤트/메시징**: Kafka, RabbitMQ 등 (비동기 통신)  
- **트레이싱/관찰성**: OpenTelemetry, Prometheus + Grafana  
- **프론트엔드 컴포넌트**: React/Vue 컴포넌트 + micro-frontend 프레임워크 (single-spa 등)  
- **모듈화 런타임**: OSGi(자바), npm/monorepo 접근(프론트엔드)

---

# 15. 요약(마무리)
- **객체지향 설계**는 클래스 수준에서 책임·행위를 명확히 하고, **컴포넌트 기반 설계**는 시스템 수준의 경계·배포·운영을 관리합니다.  
- 중요한 것은 *둘을 나란히 적용*해 각 레이어의 책임을 분명히 하는 것 — 내부는 잘 설계된 OOP로, 외부 경계는 명확한 컴포넌트 계약으로.  
- 실무 팁: 먼저 계약을 설계하고(인터페이스·이벤트), 내부는 작고 응집된 클래스로 구성, 통신은 필요에 따라 동기/비동기로 선택, 모든 컴포넌트에 테스트와 관찰성을 확보하세요.