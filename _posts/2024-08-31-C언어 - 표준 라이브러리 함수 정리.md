---
layout: post
title: C - 표준 라이브러리 함수 정리
date: 2024-08-31 19:20:23 +0900
category: C
---
# 표준 라이브러리 핵심 요약

## 0. 한 화면 치트시트

```c
// 안전 파싱
char *end = NULL; errno = 0;
long v = strtol(s, &end, 10);
if (errno == ERANGE || end == s || *end != '\0') /* 오류 */

// 정렬/탐색 계약
qsort(a, n, sizeof *a, cmp);                  // cmp: 엄격한 약순서→추이/반대칭
int key = 42;
int *p = bsearch(&key, a, n, sizeof *a, cmp); // a는 "이미" cmp 기준으로 정렬

// 난수 바이어스 제거(거부 표본추출)
int bound = 100;
int r;
for (;;) { r = rand(); if (r <= RAND_MAX - (RAND_MAX+1)%bound) break; }
int x = r % bound; // 0..bound-1 균등

// 시간 포맷
time_t now = time(NULL);
struct tm tm = *localtime(&now);
char buf[64];
strftime(buf, sizeof buf, "%Y-%m-%d %H:%M:%S%z", &tm);

// 종료 처리
atexit(cleanup);  // exit() 경로에서 cleanup 보장 호출
```

---

## 1. `<stdlib.h>` — 유틸리티/메모리/정렬/프로세스

### 1.1 문자열 → 숫자 (비권장 vs 권장)

#### 비권장(편하지만 오류 감지 불가)
```c
int    atoi(const char *s);
long   atol(const char *s);
double atof(const char *s);
```
- 공백/부호/숫자 일부만 읽어도 **성공처럼 보임**.
- 오버플로우/언더플로우를 **구별할 수 없음**.

#### 권장: `strto*` 계열 (범위·잔여문자·오류 감지)
```c
long           strtol (const char *s, char **end, int base);
unsigned long  strtoul(const char *s, char **end, int base);
double         strtod (const char *s, char **end);
long long      strtoll (const char *s, char **end, int base);   // C99
unsigned long long strtoull(const char *s, char **end, int base); // C99
```

**정석 예제 — 안전한 32비트 정수 파싱**
```c
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

int parse_int32(const char *s, int *out) {
    if (!s || !*s) return -1;
    char *end = NULL;
    errno = 0;
    long v = strtol(s, &end, 10);

    if (end == s) return -2;                 // 숫자 아님
    while (isspace((unsigned char)*end)) end++; // 후행 공백 허용
    if (*end != '\0') return -3;             // 쓰레기 꼬리
    if ((errno == ERANGE) || v < INT_MIN || v > INT_MAX) return -4; // 범위 초과

    *out = (int)v;
    return 0;
}
```

> 진단 포인트
> - `end==s`: 숫자 토큰이 **전무**
> - `errno==ERANGE` 또는 범위 체크 실패
> - 토큰 뒤 **잔여문자** 존재 여부

**기본/접두어 기반 진법 파싱**
```c
// "0xFF" → 16진, "077" → 8진, "123" → 10진
long v = strtol(s, &end, 0);
```

---

### 1.2 메모리 관리

```c
void  *malloc  (size_t);
void  *calloc  (size_t n, size_t size); // 제로 초기화
void  *realloc (void *ptr, size_t new_size);
void   free    (void *ptr);
void  *aligned_alloc(size_t alignment, size_t size); // C11: size는 alignment 배수
```

**`realloc` 안전 패턴**
```c
void *tmp = realloc(p, new_sz);
if (!tmp) {
    /* 실패: p는 여전히 유효 */
    /* 필요 시 복구/로그 후 적절 처리 */
} else {
    p = tmp;  // 성공 경로
}
```

**제로 초기화 차이**
- `malloc`: 미초기화(쓰레기값)
- `calloc`: **모든 바이트 0** (포인터/부동소수의 논리적 0 보장)

---

### 1.3 정렬/탐색 — 계약과 함정

```c
void  qsort (void *base, size_t n, size_t size,
             int (*cmp)(const void*, const void*));
void *bsearch(const void *key, const void *base, size_t n, size_t size,
             int (*cmp)(const void*, const void*));
```

**비교 함수의 계약**
- 반환 \<0 / =0 / \>0
- **추이성**: a≤b, b≤c → a≤c (위배시 무한 루프/비정상 결과 위험)
- **연산 안전**: `return a - b;` 는 오버플로우 위험 → 아래처럼

```c
int cmp_int(const void *pa, const void *pb){
    int a = *(const int*)pa;
    int b = *(const int*)pb;
    return (a > b) - (a < b); // 안전하고 의도가 분명
}
```

**예제 — 정렬 + 이진탐색**
```c
#include <stdio.h>
#include <stdlib.h>

static int cmp_int(const void *pa, const void *pb){
    int a = *(const int*)pa, b = *(const int*)pb;
    return (a > b) - (a < b);
}

int main(void){
    int a[] = {50, 20, 40, 10, 30};
    size_t n = sizeof a / sizeof *a;
    qsort(a, n, sizeof *a, cmp_int);

    int key = 30;
    int *p = bsearch(&key, a, n, sizeof *a, cmp_int);
    printf("찾기: %d → %s (인덱스=%td)\n",
        key, p ? "성공" : "실패", p ? (ptrdiff_t)(p - a) : -1);
    return 0;
}
```

> **중요**: `bsearch`는 **이미 `cmp` 기준으로 정렬된 배열**에서만 동작.

---

### 1.4 난수 — 바이어스와 초기화

```c
int   rand(void);      // [0, RAND_MAX]
void  srand(unsigned); // 시드
```

**초기화**
```c
#include <time.h>
srand((unsigned)time(NULL));
```

**모듈러 바이어스 제거** (거부 표본추출)
```c
int bounded_rand(int bound){
    if (bound <= 0) return 0;
    int lim = RAND_MAX - (RAND_MAX + 1) % bound;
    int r;
    do { r = rand(); } while (r > lim);
    return r % bound;
}
```

> `rand()`는 통계 품질이 제한적입니다(표준 준수만 보장).
> **암호학/보안**에는 부적합. (※ 보안 목적이면 플랫폼 RNG 사용; 단, 이는 표준 C 바깥)

---

### 1.5 프로그램 제어/환경

```c
_Noreturn void exit(int status);
_Noreturn void abort(void);
int atexit(void (*func)(void));
char *getenv(const char *name);
int system(const char *cmd);  // 외부 쉘 실행(보안 주의)
```

**정리 함수 등록**
```c
static void cleanup(void){ /* 파일 닫기/로그 등 */ }

int main(void){
    atexit(cleanup);  // exit(…) 경로에서 호출됨
    /* ... */
    exit(0);
}
```

**환경 변수 읽기**
```c
const char *p = getenv("PATH");
if (p) puts(p);
```

> `system()`은 입력을 쉘에 넘기므로 **인자 검증/인젝션에 특히 주의**.

---

### 1.6 수학 외 정수/분할 함수(참고)

```c
int   abs (int);        // stdlib.h
long  labs(long);
long long llabs(long long);   // C99

div_t   div (int, int);       // { .quot, .rem }
ldiv_t  ldiv(long, long);
lldiv_t lldiv(long long, long long); // C99
```

---

## 2. `<math.h>` — 실수/특수값/정확성

### 2.1 대표 함수군

| 범주 | 함수 |
|---|---|
| 기본 | `sqrt`, `cbrt`, `pow`, `hypot` |
| 절댓값 | `fabs`, `fma`(정확 누적 곱셈-덧셈) |
| 삼각 | `sin`, `cos`, `tan`, `asin`, `acos`, `atan`, `atan2` |
| 지수/로그 | `exp`, `exp2`, `log`, `log10`, `log2`, `expm1`, `log1p` |
| 반올림 | `ceil`, `floor`, `trunc`, `round`, `lround`, `llround` |
| 나머지 | `fmod`, `remainder`, `remquo` |
| 분류 | `fpclassify`, `isfinite`, `isinf`, `isnan`, `signbit` |
| 상수 | `HUGE_VAL`, `INFINITY`, `NAN`(매크로) |

> 대부분 `float`/`double`/`long double` 버전 제공(접미 `_f`, `_l` 형태가 아닌 **함수 오버로드 없음**; C는 매크로/프로토타입으로 분기).

### 2.2 특수값과 분기

**분기 매크로**
```c
#include <math.h>
double x = /* ... */;
if (isnan(x))      { /* NaN 처리 */ }
else if (isinf(x)) { /* ±INF 처리 */ }
else if (!isfinite(x)) { /* NaN/INF 외 */ }
```

**`fmod` vs `remainder`**
- `fmod(x,y)`: **C표준의 나머지 정의**(부호는 x에 따름)
- `remainder(x,y)`: 가장 가까운 정수 배수와의 차(라운딩 규칙 상이)

### 2.3 수치적으로 바람직한 선택

- **두 벡터 거리**: `hypot(dx, dy)` → 오버/언더플로 방지.
- **작은 x에서 `log(1+x)`**: `log1p(x)` (정확도↑).
- **작은 x에서 `exp(x)-1`**: `expm1(x)` (정확도↑).
- **정확한 누적**: `fma(a,b,c)` → \(a \times b + c\)를 **한 번의 반올림**으로.

### 2.4 예제 — 좌표/삼각/거리/안전제곱

```c
#include <math.h>
#include <stdio.h>

int main(void){
    double x = -3.14;
    printf("ceil=%.2f floor=%.2f trunc=%.2f round=%.2f\n",
           ceil(x), floor(x), trunc(x), round(x));

    double dx=3.0, dy=4.0;
    printf("hypot(3,4)=%.1f\n", hypot(dx, dy)); // 5.0

    double a=1e308, b=1e308, c=-1e308; // fma로 정밀도 향상
    printf("fma=%.1e\n", fma(a, 1.0, c)); // (a*1 + c) = 0 기대

    double y = 0.0/0.0; // NaN
    printf("isnan?: %d\n", isnan(y));

    return 0;
}
```

> GCC/Clang에서는 **링크 시 `-lm` 필요**할 수 있습니다.

```bash
gcc main.c -lm
```

---

## 3. `<time.h>` — 벽시계/달력/포맷/차이

### 3.1 핵심 타입과 함수

```c
typedef ... time_t;             // 초 단위(구현 의존)
typedef ... clock_t;            // CPU 사용량 단위

time_t  time(time_t *t);        // 현재 "달력 시각"(epoch부터의 초)
double  difftime(time_t a, time_t b);
struct tm *localtime(const time_t *);  // 지역시간
struct tm *gmtime(const time_t *);     // UTC
time_t  mktime(struct tm *);           // tm(지역기준) → time_t
size_t  strftime(char *s, size_t, const char *fmt, const struct tm *);
clock_t clock(void);                   // 프로세스 CPU 사용량(벽시계 아님)
int     timespec_get(struct timespec *ts, int base); // C11, 나노초 해상도(구현 의존)
```

**`struct tm` 핵심**
```c
struct tm {
  int tm_sec;   // 0..60 (윤초 고려)
  int tm_min;   // 0..59
  int tm_hour;  // 0..23
  int tm_mday;  // 1..31
  int tm_mon;   // 0..11 (0=Jan)
  int tm_year;  // 1900 이후 경과연도
  int tm_wday;  // 0..6 (0=Sun)
  int tm_yday;  // 0..365
  int tm_isdst; // 서머타임: >0 적용, 0 미적용, <0 정보없음
};
```

### 3.2 현재 시각을 문자열로

```c
#include <time.h>
#include <stdio.h>

int main(void){
    time_t now = time(NULL);
    struct tm tm = *localtime(&now);

    char buf[64];
    strftime(buf, sizeof buf, "%Y-%m-%d %H:%M:%S %Z%z", &tm);
    puts(buf); // 예: 2025-11-10 21:05:00 KST+0900
}
```

- `%Z`: 타임존 약어(구현/환경 의존)
- `%z`: RFC822 오프셋(+0900 등)

### 3.3 달력 연산 — `mktime` 정규화 활용

**N일 더하기**
```c
time_t add_days(time_t t, int days){
    struct tm tm = *localtime(&t);
    tm.tm_mday += days;
    return mktime(&tm); // mktime이 "말일 넘어감" 등을 자동 정규화
}
```

**월 더하기**
```c
time_t add_months(time_t t, int months){
    struct tm tm = *localtime(&t);
    tm.tm_mon += months;
    return mktime(&tm);
}
```

> `mktime`은 지역시간 규칙(서머타임 전환 등)을 고려해 정규화합니다.

### 3.4 경과 시간 측정 (벽시계 vs CPU)

- **벽시계 경과**: 시작/끝의 `time()` 차이 또는 C11 `timespec_get`
- **CPU 사용량**: `clock()` 이용 → **I/O 대기 포함 안 됨**

```c
#include <time.h>
#include <stdio.h>

int main(void){
    clock_t c0 = clock();
    // work
    clock_t c1 = clock();
    double cpu_sec = (double)(c1 - c0) / CLOCKS_PER_SEC;
    printf("CPU sec = %.6f\n", cpu_sec);
}
```

**나노초 벽시계(C11)**
```c
#include <time.h>
#include <stdio.h>

int main(void){
    struct timespec ts;
    if (timespec_get(&ts, TIME_UTC) == TIME_UTC) {
        printf("%lld.%09ld\n", (long long)ts.tv_sec, ts.tv_nsec);
    }
}
```

> 실제 해상도는 구현/플랫폼 의존. 고해상도 타이머는 표준 C 바깥(POSIX/플랫폼 API).

---

## 4. 문자열/메모리(간단 리마인더) — `<string.h>`

| 함수 | 설명 |
|---|---|
| `memset`, `memcpy`, `memmove` | 바이트 채우기/복사/겹침 안전 복사 |
| `memcmp` | 바이트 비교 |
| `strlen`, `strcpy/strncpy`, `strcat/strncat` | 문자열 길이/복사/덧붙이기 |
| `strcmp/strncmp`, `strstr/strchr` | 비교/검색 |

> 크기 안전을 위해 **버퍼 길이 인자**가 있는 변형 사용을 권장(`strncpy`는 널-종단 미보장 케이스 주의).
> 입력에는 `fgets`와 길이 제한된 `scanf("%Ns", ...)` 사용.

---

## 5. 수학 스니펫 — 수식과 안정성

### 5.1 나머지/정수 나눗셈 정의(참고)

정수 나눗셈에서
$$
a = q \cdot b + r,\quad \text{with}\ r = a \bmod b
$$
C에서 `a/b`는 **0을 향한 절단(truncation toward 0)**, `a%b`는 이에 따른 나머지 규칙을 따릅니다(부호 주의).

### 5.2 오버/언더플로 회피

두 좌표 거리:
$$
\sqrt{x^2 + y^2} \quad\Rightarrow\quad \texttt{hypot(x,y)}
$$

작은 \(x\)에서
$$
\log(1+x) \approx \texttt{log1p(x)},\quad
e^x - 1 \approx \texttt{expm1(x)}.
$$

---

## 6. “실전 레시피” 모음

### 6.1 CSV 정수 열 파싱 → 정렬 → 찾기

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

static int cmp_int(const void *pa, const void *pb){
    int a = *(const int*)pa, b = *(const int*)pb;
    return (a > b) - (a < b);
}

int main(void){
    char line[1024];
    if (!fgets(line, sizeof line, stdin)) return 0;

    int *vec = NULL; size_t n = 0, cap = 0;
    for (char *tok = strtok(line, ","); tok; tok = strtok(NULL, ",")) {
        // trim
        while (*tok==' '||*tok=='\t') tok++;
        char *end; errno = 0;
        long v = strtol(tok, &end, 10);
        if (end == tok || (errno==ERANGE)) continue;
        while (*end==' '||*end=='\t'||*end=='\n') end++;
        if (*end) continue;

        if (n == cap) {
            size_t newcap = cap ? cap*2 : 8;
            int *tmp = realloc(vec, newcap * sizeof *vec);
            if (!tmp) { free(vec); return 1; }
            vec = tmp; cap = newcap;
        }
        vec[n++] = (int)v;
    }

    qsort(vec, n, sizeof *vec, cmp_int);

    int key = 42;
    int *p = bsearch(&key, vec, n, sizeof *vec, cmp_int);
    printf("count=%zu min=%d max=%d find(%d)=%s\n",
           n, n?vec[0]:0, n?vec[n-1]:0, key, p?"yes":"no");

    free(vec);
    return 0;
}
```

### 6.2 UTC ↔ 지역시간 변환/포맷

```c
#include <time.h>
#include <stdio.h>

int main(void){
    time_t now = time(NULL);

    struct tm utc = *gmtime(&now);
    struct tm loc = *localtime(&now);

    char a[32], b[32];
    strftime(a, sizeof a, "%Y-%m-%d %H:%M:%S UTC", &utc);
    strftime(b, sizeof b, "%Y-%m-%d %H:%M:%S %z", &loc);

    printf("UTC: %s\nLOC: %s\n", a, b);
}
```

### 6.3 정규화로 “다음 달 같은 날” 계산

```c
time_t next_month_same_day(time_t t){
    struct tm tm = *localtime(&t);
    tm.tm_mon += 1;                       // 12월이면 13→다음해 1월로 정규화
    return mktime(&tm);                   // 30/31일은 말일 보정 규칙 적용
}
```

---

## 7. 추가 팁/함정 체크리스트

- [ ] `atoi/atof` 대신 **`strto*` + `errno` + `endptr`**.
- [ ] `qsort` 비교함수는 **추이성**/반대칭 지켜라. `return a-b;` 지양.
- [ ] `bsearch`는 **정렬 후** 사용. 동일 `cmp` 사용 일관성.
- [ ] `rand()%N` 바이어스 주의 → **거부 표본추출**로 보정.
- [ ] `<math.h>`는 **-lm 링크**(플랫폼/컴파일러에 따라 필요).
- [ ] `clock()`은 **CPU 시간**(벽시계 아님). 벽시계는 `time()`/`timespec_get`.
- [ ] `mktime`는 **지역시간** 기준 정규화. DST 전환 시각 주의.
- [ ] 종료 크리티컬 섹션 있으면 `atexit`로 안전 종료 경로 확보.
- [ ] `aligned_alloc`(C11) 사용 시 **size % alignment == 0** 보장.
- [ ] 입력/출력은 항상 **버퍼 크기**를 기준으로 동작.

---

## 8. 마무리 표 — “무엇을, 언제”

| 문제 | 우선 선택 | 대안/주의 |
|---|---|---|
| 문자열→정수 | `strtol/strtoll` | `atoi` 비권장(오류 감지 불가) |
| 정렬/탐색 | `qsort`/`bsearch` | 비교함수 계약 위반 금지 |
| 난수[0..N) | 거부 표본추출 | `rand()%N` 바이어스 |
| 거리/제곱합 | `hypot`/`fma` | 단순 제곱합은 정밀도 취약 |
| 로그/지수 근접 | `log1p`/`expm1` | 작은 값에서 손실 |
| 현재 시각 포맷 | `strftime` | `asctime`/`ctime`은 고정 버퍼/개행 포함 |
| 달력 연산 | `tm` 수정→`mktime` | 직접 초 가산은 DST 문제 |
| 종료 정리 | `atexit` | `abort`는 호출 안 됨 |

---

## 9. 빌드 예시

```bash
# 수학 링크가 필요한 구현:
gcc main.c -lm -o app

# 경고 엄격 + 표준
gcc -std=c11 -Wall -Wextra -Wconversion -O2 main.c -lm
```

---

## 10. 다음 읽을거리(예고)

- `<errno.h>`와 **에러 처리 패턴**(실패 시점/복구 전략)
- `<inttypes.h>` `strtoimax/strtoumax`로 **플랫폼 독립 파싱**
- `<locale.h>`와 숫자/시간 **로케일 포맷**
- 견고한 **입력 검증** & 안전 I/O (`fgets`, 길이 제한 `scanf`)
