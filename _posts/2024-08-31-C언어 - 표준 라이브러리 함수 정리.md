---
layout: post
title: C - 표준 라이브러리 함수 정리
date: 2024-08-31 19:20:23 +0900
category: C
---
# C 표준 라이브러리 핵심 가이드

## 핵심 요약

```c
// 1) 문자열에서 숫자를 안전하게 파싱하기
char *end = NULL;
errno = 0;
long value = strtol(input_string, &end, 10);
if (errno == ERANGE || end == input_string || *end != '\0') {
    // 오류 처리
}

// 2) 정렬과 이진 탐색 사용법
qsort(array, element_count, sizeof(element_type), comparison_function);
// 비교 함수는 반드시 추이성(transitivity)을 만족해야 함

int key = 42;
int *result = bsearch(&key, array, element_count, 
                      sizeof(element_type), comparison_function);
// 배열은 반드시 먼저 같은 기준으로 정렬되어 있어야 함

// 3) 편향 없는 난수 생성
int bound = 100;  // 0부터 99까지의 난수
int random_value;
for (;;) {
    random_value = rand();
    if (random_value <= RAND_MAX - (RAND_MAX + 1) % bound) break;
}
random_value = random_value % bound;  // 이제 균등 분포

// 4) 시간 포맷팅
time_t now = time(NULL);
struct tm local_time = *localtime(&now);
char buffer[64];
strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S%z", &local_time);

// 5) 프로그램 종료 시 정리 작업
atexit(cleanup_function);  // exit() 호출 시 자동 실행
```

---

## `<stdlib.h>`: 핵심 유틸리티 함수

### 문자열을 숫자로 변환하기: 안전한 방법 vs 위험한 방법

#### 위험한 방법 (사용하지 마세요)
```c
int value = atoi("123abc");    // 123을 반환하지만, "abc" 부분은 무시됨
double d = atof("inf");        // 0.0을 반환 (예상과 다를 수 있음)
```
이 함수들은 변환 실패를 감지할 수 없고, 오버플로우도 무시합니다. 디버깅하기 어려운 버그의 원인이 될 수 있습니다.

#### 안전한 방법: `strto*` 계열 함수
```c
long strtol(const char *str, char **endptr, int base);
double strtod(const char *str, char **endptr);
unsigned long long strtoull(const char *str, char **endptr, int base);
```
이 함수들은 변환된 값, 변환되지 않은 나머지 문자열, 그리고 발생한 오류를 모두 알려줍니다.

**안전한 정수 파싱 예제:**
```c
#include <stdlib.h>
#include <errno.h>
#include <limits.h>
#include <ctype.h>

int parse_integer(const char *str, int *result) {
    if (!str || !*str) return -1;  // 빈 문자열
    
    char *end;
    errno = 0;  // 오류 플래그 초기화
    long value = strtol(str, &end, 10);
    
    // 에러 조건 체크
    if (end == str) return -2;  // 숫자가 하나도 없음
    if (errno == ERANGE) return -3;  // 범위 초과
    if (value < INT_MIN || value > INT_MAX) return -3;  // int 범위 초과
    
    // 후행 공백 허용
    while (isspace((unsigned char)*end)) end++;
    
    // 불필요한 문자가 남아있는지 확인
    if (*end != '\0') return -4;  // 숫자 뒤에 쓰레기 값
    
    *result = (int)value;
    return 0;  // 성공
}

// 사용 예
int main() {
    int num;
    const char *input = "  123  ";
    
    switch (parse_integer(input, &num)) {
        case 0: printf("성공: %d\n", num); break;
        case -1: printf("빈 문자열\n"); break;
        case -2: printf("숫자가 없음\n"); break;
        case -3: printf("범위 초과\n"); break;
        case -4: printf("잘못된 형식\n"); break;
    }
    return 0;
}
```

**다양한 진법 파싱:**
```c
long decimal = strtol("123", NULL, 10);     // 10진수: 123
long hex = strtol("0xFF", NULL, 0);         // 0 접두사: 16진수 자동 감지 → 255
long octal = strtol("077", NULL, 0);        // 0 접두사: 8진수 자동 감지 → 63
long binary = strtol("1010", NULL, 2);      // 2진수: 10
```

### 메모리 관리: `malloc`, `calloc`, `realloc`, `free`

**`realloc`의 안전한 사용 패턴:**
```c
int *array = malloc(initial_size * sizeof(int));
if (!array) { /* 메모리 부족 처리 */ }

// 배열 확장 시
int *temp = realloc(array, new_size * sizeof(int));
if (!temp) {
    // 실패: 원본 array는 여전히 유효함
    // 여기서 복구 로직이나 적절한 처리를 수행
    printf("메모리 확장 실패. 원본 데이터 보존됨.\n");
    // 필요하다면 array를 해제하거나 다른 작업 수행
} else {
    // 성공: temp가 새로운 메모리 블록
    array = temp;  // 기존 포인터 대체
}
```

**`calloc` vs `malloc`:**
```c
int *p1 = malloc(100 * sizeof(int));  // 초기화되지 않은 메모리
int *p2 = calloc(100, sizeof(int));   // 모든 비트가 0으로 초기화된 메모리

// calloc은 다음과 동일합니다:
int *p3 = malloc(100 * sizeof(int));
if (p3) memset(p3, 0, 100 * sizeof(int));
```

### 정렬과 탐색: `qsort`와 `bsearch`

**안전한 비교 함수 작성법:**
```c
// 위험한 방법 (오버플로우 가능성)
int bad_compare(const void *a, const void *b) {
    int x = *(const int*)a;
    int y = *(const int*)b;
    return x - y;  // x=INT_MAX, y=-1일 때 오버플로우!
}

// 안전한 방법
int safe_compare(const void *a, const void *b) {
    int x = *(const int*)a;
    int y = *(const int*)b;
    return (x > y) - (x < y);  // -1, 0, 1을 안전하게 반환
}

// 문자열 비교
int string_compare(const void *a, const void *b) {
    const char **str1 = (const char**)a;
    const char **str2 = (const char**)b;
    return strcmp(*str1, *str2);
}
```

**실제 사용 예제:**
```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main() {
    // 정수 배열 정렬
    int numbers[] = {42, 17, 89, 3, 56};
    int count = sizeof(numbers) / sizeof(numbers[0]);
    
    qsort(numbers, count, sizeof(int), safe_compare);
    
    // 정렬된 배열에서 검색
    int key = 42;
    int *result = bsearch(&key, numbers, count, sizeof(int), safe_compare);
    
    if (result) {
        printf("%d을(를) 찾았습니다. 인덱스: %ld\n", 
               key, result - numbers);
    } else {
        printf("%d을(를) 찾지 못했습니다.\n", key);
    }
    
    // 문자열 배열 정렬
    const char *names[] = {"Charlie", "Alice", "Bob", "David"};
    int name_count = sizeof(names) / sizeof(names[0]);
    
    qsort(names, name_count, sizeof(const char*), string_compare);
    
    for (int i = 0; i < name_count; i++) {
        printf("%s\n", names[i]);
    }
    
    return 0;
}
```

### 난수 생성: `rand()`와 `srand()`

**편향 없는 난수 생성:**
```c
#include <stdlib.h>
#include <time.h>

// 초기화
srand((unsigned int)time(NULL));  // 현재 시간을 시드로 사용

// 0부터 bound-1 사이의 균등 분포 난수
int unbiased_random(int bound) {
    if (bound <= 0) return 0;
    
    // 편향 제거: 거부 표본 추출(rejection sampling)
    int limit = RAND_MAX - (RAND_MAX + 1) % bound;
    int random_value;
    
    do {
        random_value = rand();
    } while (random_value > limit);
    
    return random_value % bound;
}

// 사용 예
int main() {
    srand((unsigned int)time(NULL));
    
    // 0~99 사이 난수
    for (int i = 0; i < 10; i++) {
        printf("%d ", unbiased_random(100));
    }
    printf("\n");
    
    return 0;
}
```

**중요 참고사항:** `rand()`는 암호학적으로 안전하지 않습니다. 보안이 중요한 응용 프로그램에서는 운영체제 제공의 암호학적 난수 생성기를 사용해야 합니다.

### 프로그램 제어와 환경

```c
#include <stdlib.h>
#include <stdio.h>

// 종료 시 실행할 정리 함수
void cleanup() {
    printf("프로그램 종료 중... 정리 작업 수행\n");
    // 파일 닫기, 메모리 해제, 로그 기록 등
}

int main() {
    // 정리 함수 등록
    atexit(cleanup);
    
    // 환경 변수 읽기
    const char *path = getenv("PATH");
    if (path) {
        printf("PATH 환경 변수: %s\n", path);
    }
    
    // 외부 명령 실행 (주의: 보안 위험 가능성)
    printf("현재 디렉토리:\n");
    system("pwd");  // 시스템 명령 실행
    
    // 정상 종료 (cleanup 자동 호출)
    exit(0);
    
    // 또는 비정상 종료
    // abort();  // cleanup 호출되지 않음
}
```

**`system()` 함수 사용 시 주의사항:** 사용자 입력을 그대로 `system()`에 전달하면 명령어 인젝션 공격에 취약할 수 있습니다. 반드시 입력값을 검증하고 제한해야 합니다.

---

## `<math.h>`: 수학 함수

### 기본 수학 함수

```c
#include <math.h>
#include <stdio.h>

int main() {
    double x = 2.0;
    double y = 3.0;
    
    // 기본 연산
    printf("제곱근: sqrt(%.1f) = %.3f\n", x, sqrt(x));
    printf("세제곱근: cbrt(%.1f) = %.3f\n", 27.0, cbrt(27.0));
    printf("거듭제곱: pow(%.1f, %.1f) = %.3f\n", x, y, pow(x, y));
    
    // 절대값
    printf("절대값: fabs(%.1f) = %.1f\n", -3.14, fabs(-3.14));
    
    // 삼각 함수
    printf("사인: sin(π/2) = %.3f\n", sin(3.14159 / 2));
    printf("코사인: cos(0) = %.1f\n", cos(0.0));
    
    // 지수와 로그
    printf("자연 지수: exp(1) = %.3f\n", exp(1.0));
    printf("자연 로그: log(10) = %.3f\n", log(10.0));
    printf("상용 로그: log10(100) = %.1f\n", log10(100.0));
    
    // 반올림 관련
    printf("올림: ceil(2.3) = %.1f\n", ceil(2.3));
    printf("내림: floor(2.7) = %.1f\n", floor(2.7));
    printf("소수점 버림: trunc(3.9) = %.1f\n", trunc(3.9));
    printf("반올림: round(2.5) = %.1f\n", round(2.5));
    
    return 0;
}
```

### 수치적 안정성을 고려한 함수 선택

수치 계산에서는 정밀도 손실을 피하기 위해 특수한 함수를 사용해야 할 때가 있습니다.

```c
#include <math.h>
#include <stdio.h>

int main() {
    // 작은 값의 로그 계산: log1p가 더 정확함
    double small = 1e-15;
    printf("log(1 + %g) 직접 계산: %.15f\n", small, log(1.0 + small));
    printf("log(1 + %g) log1p 사용: %.15f\n", small, log1p(small));
    
    // 작은 값의 지수 계산: expm1이 더 정확함
    printf("exp(%g) - 1 직접 계산: %.15f\n", small, exp(small) - 1.0);
    printf("exp(%g) - 1 expm1 사용: %.15f\n", small, expm1(small));
    
    // 두 점 사이 거리: hypot이 오버플로우 방지
    double dx = 1e100;
    double dy = 1e100;
    printf("직접 계산 sqrt(x² + y²): %g\n", sqrt(dx*dx + dy*dy));  // INF 발생 가능
    printf("hypot 사용: %g\n", hypot(dx, dy));  // 안전하게 계산
    
    // 정밀한 곱셈-덧셈: fma
    double a = 1.0000000001;
    double b = 1.0000000001;
    double c = -1.0;
    printf("직접 계산 a*b + c: %.15f\n", a * b + c);
    printf("fma 사용: %.15f\n", fma(a, b, c));  // 한 번의 반올림
    
    return 0;
}
```

### 특수 값 처리

부동소수점 계산에서는 INF(무한대)와 NaN(숫자가 아님) 값을 올바르게 처리해야 합니다.

```c
#include <math.h>
#include <stdio.h>

int main() {
    double positive_inf = 1.0 / 0.0;      // +INF
    double negative_inf = -1.0 / 0.0;     // -INF
    double nan_value = 0.0 / 0.0;         // NaN
    
    // 값 분류
    printf("+INF isinf? %d\n", isinf(positive_inf));
    printf("-INF isinf? %d\n", isinf(negative_inf));
    printf("NaN isnan? %d\n", isnan(nan_value));
    printf("10.5 isfinite? %d\n", isfinite(10.5));
    
    // 부호 확인
    printf("+INF sign: %d\n", signbit(positive_inf) ? -1 : 1);
    printf("-INF sign: %d\n", signbit(negative_inf) ? -1 : 1);
    
    // 특수 값과의 연산
    printf("INF + 10 = %f\n", positive_inf + 10);
    printf("INF * 0 = %f (NaN)\n", positive_inf * 0);
    printf("sqrt(-1) = %f (NaN)\n", sqrt(-1.0));
    
    return 0;
}
```

**컴파일 시 참고:** 수학 라이브러리를 사용할 때는 링크 옵션 `-lm`이 필요할 수 있습니다.
```bash
gcc program.c -lm -o program
```

---

## `<time.h>`: 시간과 날짜 처리

### 현재 시간 얻기와 포맷팅

```c
#include <time.h>
#include <stdio.h>

int main() {
    // 현재 시간 얻기 (에포크 이후 초 단위)
    time_t current_time = time(NULL);
    printf("에포크 이후 초: %ld\n", (long)current_time);
    
    // 지역 시간으로 변환
    struct tm *local = localtime(&current_time);
    
    // 시간 포맷팅
    char time_buffer[100];
    strftime(time_buffer, sizeof(time_buffer), 
             "%Y년 %m월 %d일 %H시 %M분 %S초", local);
    printf("현재 시간: %s\n", time_buffer);
    
    // 다양한 포맷
    strftime(time_buffer, sizeof(time_buffer), "%A, %B %d", local);
    printf("오늘은: %s\n", time_buffer);  // 예: Monday, January 01
    
    strftime(time_buffer, sizeof(time_buffer), "%Y-%m-%dT%H:%M:%S%z", local);
    printf("ISO 8601 형식: %s\n", time_buffer);
    
    // UTC 시간
    struct tm *utc = gmtime(&current_time);
    strftime(time_buffer, sizeof(time_buffer), 
             "%Y-%m-%d %H:%M:%S UTC", utc);
    printf("UTC 시간: %s\n", time_buffer);
    
    return 0;
}
```

### 시간 간격 측정

```c
#include <time.h>
#include <stdio.h>

int main() {
    // 벽시계 시간 측정
    time_t start_wall = time(NULL);
    
    // 작업 수행 (예: 대기)
    for (volatile int i = 0; i < 100000000; i++);
    
    time_t end_wall = time(NULL);
    double wall_seconds = difftime(end_wall, start_wall);
    printf("벽시계 경과 시간: %.2f초\n", wall_seconds);
    
    // CPU 시간 측정 (프로그램이 실제로 CPU를 사용한 시간)
    clock_t start_cpu = clock();
    
    // CPU 집중 작업
    double sum = 0;
    for (int i = 0; i < 1000000; i++) {
        sum += i * 0.1;
    }
    
    clock_t end_cpu = clock();
    double cpu_seconds = (double)(end_cpu - start_cpu) / CLOCKS_PER_SEC;
    printf("CPU 사용 시간: %.6f초\n", cpu_seconds);
    
    return 0;
}
```

### 날짜 계산과 조작

`mktime()` 함수는 날짜 조작과 정규화에 유용합니다.

```c
#include <time.h>
#include <stdio.h>

int main() {
    time_t now = time(NULL);
    struct tm date = *localtime(&now);
    
    // 10일 후 계산
    date.tm_mday += 10;
    time_t future = mktime(&date);  // 자동 정규화 (월 변경 등 처리)
    
    struct tm *future_tm = localtime(&future);
    char buffer[100];
    strftime(buffer, sizeof(buffer), "%Y-%m-%d", future_tm);
    printf("10일 후: %s\n", buffer);
    
    // 3개월 후 계산
    date = *localtime(&now);
    date.tm_mon += 3;
    future = mktime(&date);
    future_tm = localtime(&future);
    strftime(buffer, sizeof(buffer), "%Y-%m-%d", future_tm);
    printf("3개월 후: %s\n", buffer);
    
    // 특정 날짜 생성 (2024년 크리스마스)
    struct tm christmas = {0};
    christmas.tm_year = 2024 - 1900;  // 1900년 이후
    christmas.tm_mon = 11;            // 12월 (0-based)
    christmas.tm_mday = 25;
    christmas.tm_hour = 12;
    
    time_t christmas_time = mktime(&christmas);
    strftime(buffer, sizeof(buffer), "%A, %B %d, %Y", &christmas);
    printf("2024년 크리스마스: %s\n", buffer);
    
    // 요일 계산
    printf("2024년 크리스마스는 %d요일입니다.\n", christmas.tm_wday);
    // 0=일요일, 1=월요일, ..., 6=토요일
    
    return 0;
}
```

### 고해상도 시간 측정 (C11)

```c
#include <time.h>
#include <stdio.h>

int main() {
    struct timespec start, end;
    
    // 시간 측정 시작
    timespec_get(&start, TIME_UTC);
    
    // 작업 수행
    for (volatile int i = 0; i < 1000000; i++);
    
    // 시간 측정 종료
    timespec_get(&end, TIME_UTC);
    
    // 경과 시간 계산 (나노초 단위)
    long seconds = end.tv_sec - start.tv_sec;
    long nanoseconds = end.tv_nsec - start.tv_nsec;
    
    if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1000000000L;
    }
    
    printf("경과 시간: %ld.%09ld초\n", seconds, nanoseconds);
    
    return 0;
}
```

---

## 실전 예제: 통합 활용

### CSV 파일 파싱, 정렬, 검색

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

// 비교 함수
int compare_doubles(const void *a, const void *b) {
    double x = *(const double*)a;
    double y = *(const double*)b;
    return (x > y) - (x < y);
}

int main() {
    FILE *file = fopen("data.csv", "r");
    if (!file) {
        perror("파일 열기 실패");
        return 1;
    }
    
    // 동적 배열 초기화
    double *values = NULL;
    size_t capacity = 0;
    size_t count = 0;
    
    char line[256];
    while (fgets(line, sizeof(line), file)) {
        // 쉼표로 분리
        char *token = strtok(line, ",");
        while (token) {
            // 문자열을 double로 변환
            char *end;
            errno = 0;
            double value = strtod(token, &end);
            
            // 변환 성공 확인
            if (end != token && errno == 0) {
                // 배열 확장 필요 시
                if (count >= capacity) {
                    size_t new_capacity = capacity ? capacity * 2 : 16;
                    double *temp = realloc(values, 
                                          new_capacity * sizeof(double));
                    if (!temp) {
                        free(values);
                        fclose(file);
                        fprintf(stderr, "메모리 부족\n");
                        return 1;
                    }
                    values = temp;
                    capacity = new_capacity;
                }
                
                values[count++] = value;
            }
            
            token = strtok(NULL, ",");
        }
    }
    
    fclose(file);
    
    if (count == 0) {
        printf("데이터가 없습니다.\n");
        free(values);
        return 0;
    }
    
    // 정렬
    qsort(values, count, sizeof(double), compare_doubles);
    
    // 통계 출력
    printf("데이터 개수: %zu\n", count);
    printf("최솟값: %.2f\n", values[0]);
    printf("중간값: %.2f\n", values[count / 2]);
    printf("최댓값: %.2f\n", values[count - 1]);
    
    // 특정 값 검색
    double search_key = 42.0;
    double *found = bsearch(&search_key, values, count, 
                           sizeof(double), compare_doubles);
    
    if (found) {
        printf("%.2f을(를) 찾았습니다.\n", search_key);
    } else {
        printf("%.2f을(를) 찾지 못했습니다.\n", search_key);
    }
    
    // 메모리 해제
    free(values);
    
    return 0;
}
```

### 로그 시스템 구현

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef struct {
    FILE *file;
    char *filename;
    int level;  // 0=ERROR, 1=WARN, 2=INFO, 3=DEBUG
} Logger;

Logger* logger_create(const char *filename, int level) {
    Logger *log = malloc(sizeof(Logger));
    if (!log) return NULL;
    
    log->filename = strdup(filename);
    if (!log->filename) {
        free(log);
        return NULL;
    }
    
    log->file = fopen(filename, "a");
    if (!log->file) {
        free(log->filename);
        free(log);
        return NULL;
    }
    
    log->level = level;
    return log;
}

void logger_log(Logger *log, int level, const char *message) {
    if (!log || level > log->level) return;
    
    time_t now = time(NULL);
    struct tm *tm_info = localtime(&now);
    
    char timestamp[20];
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", tm_info);
    
    const char *level_str;
    switch(level) {
        case 0: level_str = "ERROR"; break;
        case 1: level_str = "WARN"; break;
        case 2: level_str = "INFO"; break;
        case 3: level_str = "DEBUG"; break;
        default: level_str = "UNKNOWN";
    }
    
    fprintf(log->file, "[%s] [%s] %s\n", timestamp, level_str, message);
    fflush(log->file);
}

void logger_destroy(Logger *log) {
    if (!log) return;
    
    if (log->file) fclose(log->file);
    if (log->filename) free(log->filename);
    free(log);
}

int main() {
    Logger *log = logger_create("app.log", 2);  // INFO 레벨까지 로깅
    
    if (!log) {
        fprintf(stderr, "로그 생성 실패\n");
        return 1;
    }
    
    logger_log(log, 2, "애플리케이션 시작");
    logger_log(log, 1, "경고: 설정 파일을 찾을 수 없음, 기본값 사용");
    
    // 작업 수행...
    
    logger_log(log, 0, "심각한 오류 발생!");
    logger_log(log, 2, "애플리케이션 종료");
    
    logger_destroy(log);
    
    return 0;
}
```

---

## 결론: C 표준 라이브러리 모범 사례

C 표준 라이브러리는 강력하지만, 올바르게 사용하지 않으면 미묘한 버그와 보안 취약점을 초래할 수 있습니다. 다음 원칙을 기억하세요:

1. **안전한 입력 처리**: `atoi()`, `atof()` 대신 `strtol()`, `strtod()`를 사용하여 오류를 감지하세요.

2. **메모리 관리 주의**: `realloc()`은 항상 임시 포인터에 결과를 받아 실패 시 원본 데이터를 보존하세요.

3. **수치적 안정성**: 작은 값의 계산에는 `log1p()`, `expm1()`을, 거리 계산에는 `hypot()`을 사용하세요.

4. **시간 처리**: 시간대와 서머타임을 고려하려면 `localtime()`과 `mktime()`을 이해해야 합니다.

5. **비교 함수**: `qsort()`와 `bsearch()`용 비교 함수는 추이성을 보장하고 오버플로우를 피하도록 작성하세요.

6. **난수 생성**: `rand() % N`은 편향이 있을 수 있으므로, 균등 분포가 필요하면 거부 표본 추출을 사용하세요.

7. **종료 처리**: 정리 작업이 필요하면 `atexit()`를 사용하여 프로그램 종료 시 안전하게 실행되도록 하세요.

8. **외부 명령**: `system()`은 사용자 입력을 그대로 전달하지 마세요. 명령어 인젝션 공격에 취약합니다.

9. **수학 라이브러리**: 컴파일 시 `-lm` 옵션을 잊지 마세요.

10. **디버깅**: `errno`와 함수 반환 값을 항상 확인하세요. 무시하기 쉬운 오류가 치명적인 버그로 이어질 수 있습니다.

이러한 표준 라이브러리 함수들을 올바르게 사용하면 C 프로그래밍의 생산성과 코드 안정성을 크게 향상시킬 수 있습니다. 각 함수의 특성과 한계를 이해하고, 상황에 맞는 함수를 선택하는 것이 전문 C 프로그래머의 자세입니다.