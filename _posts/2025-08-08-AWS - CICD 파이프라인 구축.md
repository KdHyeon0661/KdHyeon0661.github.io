---
layout: post
title: AWS - CI/CD 파이프라인 구축
date: 2025-08-08 17:20:23 +0900
category: AWS
---
# CI/CD 파이프라인 구축 — CodePipeline · CodeBuild · CodeDeploy

## 0. 한 장 요약

| 단계 | 서비스 | 핵심 |
|---|---|---|
| 소스 | CodeCommit/GitHub/S3 | 커밋/태그 이벤트 트리거 |
| 오케스트레이션 | **CodePipeline** | 단계(Stages)·동시/순차·승인·아티팩트 전달 |
| 빌드/테스트 | **CodeBuild** | `buildspec.yml`로 빌드·테스트·보안검사·아티팩트·리포트 |
| 배포 | **CodeDeploy** | EC2 In-place/Blue-Green, ECS Canary/Linear, Lambda Canary/Linear |
| 모니터링/롤백 | CloudWatch + Alarms + CodeDeploy Auto-rollback | 장애 시 자동 롤백/알림 |
| 보안 | KMS/SM/SSM + CodeGuru + Inspector + WAF | 비밀·키·SAST/DAST·서명 |

---

## 1. CI/CD 기본 개념과 수식 감 잡기

- **CI**: 커밋마다 **자동 빌드/테스트**로 품질을 상시 유지.  
- **CD**: 검증된 산출물을 **환경별 자동 배포**(승인/점진 전환/롤백 포함).

빌드 대기/실행 시간을 단순 추정:
$$
T_{\text{pipeline}} \approx T_{\text{queue}} + \sum_i T_{\text{build}_i} + \sum_j T_{\text{deploy}_j}
$$

아티팩트 저장 비용 근사:
$$
\text{Storage(GB)} \approx \frac{\sum \text{artifact bytes}}{10^9} \quad ; \quad \text{Egress} \propto \text{다운로드 횟수}
$$

---

## 2. 표준 아키텍처 패턴

### 2.1 단일 리전, 다중 환경(Dev → Stg → Prod, 수동 승인 포함)
```mermaid
flowchart LR
  A[Git Push/PR Merge] --> P[CodePipeline]
  P -->|Source| S[Source Artifact S3+KMS]
  P -->|Build| B1[CodeBuild: Test+Build+SBOM]
  P -->|Security| SEC[CodeBuild: SAST/Secrets]
  P -->|Staging Deploy| D1[CodeDeploy Stg]
  P -->|Manual Approval| APR[Approver]
  P -->|Prod Deploy (Blue/Green)| D2[CodeDeploy Prod]
  D2 -->|CW Alarms| RB[Auto Rollback]
```

### 2.2 멀티계정/크로스어카운트(보안 분리)
- Tooling(Shared) 계정: 파이프라인/빌드  
- Dev/Stg/Prod 계정: 배포 대상  
- **Artifact S3(KMS CMK)** + **AssumeRole**로 안전한 전달

---

## 3. 필수 IAM·S3·KMS 기반

### 3.1 파이프라인용 아티팩트 버킷(암호화 + 제한)
```json
{
  "Version":"2012-10-17",
  "Statement":[
    {"Sid":"DenyUnEncryptedUploads","Effect":"Deny","Principal":"*",
     "Action":"s3:PutObject",
     "Resource":"arn:aws:s3:::my-artifacts-bucket/*",
     "Condition":{"StringNotEquals":{"s3:x-amz-server-side-encryption":"aws:kms"}}},
    {"Sid":"AllowPipeline","Effect":"Allow",
     "Principal":{"AWS":"arn:aws:iam::123456789012:role/CodePipelineRole"},
     "Action":["s3:PutObject","s3:GetObject","s3:ListBucket"],
     "Resource":["arn:aws:s3:::my-artifacts-bucket","arn:aws:s3:::my-artifacts-bucket/*"]}
  ]
}
```

### 3.2 KMS 키 정책(파이프라인/빌드/배포 주체만 사용)
```json
{
  "Version":"2012-10-17",
  "Statement":[
    {"Sid":"Admins","Effect":"Allow","Principal":{"AWS":"arn:aws:iam::123456789012:root"},
     "Action":"kms:*","Resource":"*"},
    {"Sid":"UseKeyCP","Effect":"Allow",
     "Principal":{"AWS":[
       "arn:aws:iam::123456789012:role/CodePipelineRole",
       "arn:aws:iam::123456789012:role/CodeBuildRole",
       "arn:aws:iam::123456789012:role/CodeDeployRole"
     ]},
     "Action":["kms:Encrypt","kms:Decrypt","kms:ReEncrypt*","kms:GenerateDataKey*","kms:DescribeKey"],
     "Resource":"*",
     "Condition":{"StringEquals":{"kms:ViaService":"s3.ap-northeast-2.amazonaws.com"}}}
  ]
}
```

---

## 4. CodeBuild ― `buildspec.yml` 실전 템플릿

### 4.1 Node.js + 테스트 + 캐시 + SBOM + 리포트
```yaml
version: 0.2
env:
  variables:
    NODE_ENV: production
  secrets-manager:
    NPM_TOKEN: "my/secrets/npm:token"   # Secrets Manager 경로
phases:
  install:
    runtime-versions: { nodejs: 18 }
    commands:
      - echo "Config npm auth"
      - echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc
      - npm ci
  pre_build:
    commands:
      - npm run lint
      - npm test -- --reporter junit --reporter-options "mochaFile=reports/junit/test-results.xml"
  build:
    commands:
      - npm run build
      - npx syft packages dir:. -o json > reports/sbom.json  # SBOM 생성(anchore/syft)
  post_build:
    commands:
      - echo "Packaging artifact"
artifacts:
  files:
    - "dist/**"
    - "apps/**"
    - "package.json"
    - "reports/**"
  name: "webapp-$CODEBUILD_BUILD_NUMBER.zip"
cache:
  paths:
    - "/root/.npm/**/*"
reports:
  junit:
    files: [ "reports/junit/test-results.xml" ]
    file-format: JUNITXML
```

### 4.2 Docker-in-Docker(이미지 빌드 + 취약점 스캔 + ECR 푸시)
```yaml
version: 0.2
phases:
  install:
    commands:
      - nohup /usr/local/bin/dockerd-entrypoint.sh > /tmp/dockerd.log 2>&1 &
      - timeout 15 sh -c "until docker info; do sleep 1; done"
  build:
    commands:
      - aws ecr get-login-password | docker login --username AWS --password-stdin <ACCOUNT>.dkr.ecr.ap-northeast-2.amazonaws.com
      - docker build -t myapp:latest .
      - docker tag myapp:latest <ACCOUNT>.dkr.ecr.ap-northeast-2.amazonaws.com/myapp:${CODEBUILD_RESOLVED_SOURCE_VERSION}
      - docker push <ACCOUNT>.dkr.ecr.ap-northeast-2.amazonaws.com/myapp:${CODEBUILD_RESOLVED_SOURCE_VERSION}
      - trivy image --exit-code 0 --severity HIGH,CRITICAL --format json -o trivy.json <ACCOUNT>.dkr.ecr.ap-northeast-2.amazonaws.com/myapp:${CODEBUILD_RESOLVED_SOURCE_VERSION}
artifacts:
  files: [ "trivy.json" ]
```

---

## 5. CodeDeploy ― 대상별 배포 전략

### 5.1 EC2 In-place (appspec + 스크립트)
**폴더 구조**
```
.
├── appspec.yml
├── scripts/
│   ├── install_dependencies.sh
│   ├── start_server.sh
│   └── stop_server.sh
└── dist/
```

**`appspec.yml`**
```yaml
version: 0.0
os: linux
files:
  - source: /
    destination: /var/www/myapp
hooks:
  BeforeInstall:
    - location: scripts/stop_server.sh
      timeout: 180
  AfterInstall:
    - location: scripts/install_dependencies.sh
      timeout: 600
  ApplicationStart:
    - location: scripts/start_server.sh
      timeout: 180
  ValidateService:
    - location: scripts/healthcheck.sh
      timeout: 120
```

### 5.2 EC2 Blue/Green + CloudWatch 알람 기반 롤백
- 배포 그룹에서 **Blue/Green** 선택, 신규 Auto Scaling 그룹로 트래픽 전환  
- **Deployment configuration**: `CodeDeployDefault.AllAtOnce` / `HalfAtATime` / **Canary10Percent5Minutes**  
- **Auto Rollback**: “CloudWatch Alarm” 트리거로 활성화

**CloudWatch 경보 예 (5xx > 임계)**
```json
{
  "AlarmName": "Prod-5xx-spike",
  "MetricName": "HTTPCode_Target_5XX_Count",
  "Namespace": "AWS/ApplicationELB",
  "Statistic": "Sum",
  "Period": 60,
  "EvaluationPeriods": 3,
  "Threshold": 20,
  "ComparisonOperator": "GreaterThanOrEqualToThreshold",
  "Dimensions": [{ "Name":"LoadBalancer","Value":"app/my-alb/abc123" }]
}
```

### 5.3 ECS Blue/Green (CodeDeploy + ALB 대상 그룹 교체)
- Task Definition → CodeBuild에서 이미지 태그 업데이트  
- CodeDeploy App(ECS) + Deployment Group: **ProdListener**, **TargetGroup Blue/Green** 지정  
- 전환 전략: Canary/Linear 선택

### 5.4 Lambda Canary/Linear
- CodeDeploy App(Lambda) 구성 → **Traffic shifting** 비율/시간 설정  
- Validate hook(Lambda)로 **헬스체크/실패 시 롤백**

---

## 6. CodePipeline ― 파이프라인 정의(IaC)

### 6.1 CloudFormation(요약형, Source→Build→Stg→Approval→Prod)
```yaml
AWSTemplateFormatVersion: '2010-09-09'
Resources:
  PipelineRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement: [{ Effect: Allow, Principal: { Service: codepipeline.amazonaws.com }, Action: sts:AssumeRole }]
      Policies:
        - PolicyName: PipelineAccess
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: ["s3:*","codebuild:*","codedeploy:*","iam:PassRole","kms:*","cloudwatch:*"]
                Resource: "*"

  Pipeline:
    Type: AWS::CodePipeline::Pipeline
    Properties:
      RoleArn: !GetAtt PipelineRole.Arn
      ArtifactStore:
        Type: S3
        Location: my-artifacts-bucket
        EncryptionKey:
          Id: arn:aws:kms:ap-northeast-2:123456789012:key/xxxx
          Type: KMS
      Stages:
        - Name: Source
          Actions:
            - Name: GitHubSource
              ActionTypeId: { Category: Source, Owner: ThirdParty, Provider: GitHub, Version: "1" }
              Configuration:
                Owner: myorg
                Repo: myrepo
                Branch: main
                OAuthToken: "{{resolve:secretsmanager:github/token:SecretString:token}}"
              OutputArtifacts: [{ Name: SourceArtifact }]
        - Name: Build
          Actions:
            - Name: CodeBuild
              ActionTypeId: { Category: Build, Owner: AWS, Provider: CodeBuild, Version: "1" }
              Configuration: { ProjectName: my-build-project }
              InputArtifacts: [{ Name: SourceArtifact }]
              OutputArtifacts: [{ Name: BuildArtifact }]
        - Name: DeployStg
          Actions:
            - Name: CodeDeployStg
              ActionTypeId: { Category: Deploy, Owner: AWS, Provider: CodeDeploy, Version: "1" }
              Configuration: { ApplicationName: my-app, DeploymentGroupName: my-dg-stg }
              InputArtifacts: [{ Name: BuildArtifact }]
        - Name: Approval
          Actions:
            - Name: ManualApproval
              ActionTypeId: { Category: Approval, Owner: AWS, Provider: Manual, Version: "1" }
        - Name: DeployProd
          Actions:
            - Name: CodeDeployProd
              ActionTypeId: { Category: Deploy, Owner: AWS, Provider: CodeDeploy, Version: "1" }
              Configuration: { ApplicationName: my-app, DeploymentGroupName: my-dg-prod }
              InputArtifacts: [{ Name: BuildArtifact }]
```

### 6.2 파이프라인 변수/파라미터(브랜치/태그 기반)
- 브랜치 `main` → Stg/Prod  
- 태그 `v*` → 릴리스 파이프라인만 트리거

---

## 7. 데이터베이스 마이그레이션(릴리스 내 통합)

### 7.1 Build 단계에서 마이그레이션 패키징
- **Flyway/Liquibase** 스크립트를 아티팩트에 포함  
- Stg 배포 후 DB 마이그레이션 실행 → 검증 → Prod 승인

**Buildspec 스니펫**
```yaml
phases:
  build:
    commands:
      - ./gradlew build
      - ./gradlew flywayMigrate -i -Penv=staging
artifacts:
  files: ["build/libs/*.jar", "db/migration/**"]
```

### 7.2 Feature Flag 전략
- DB 스키마 선반영 → 코드에서 신규 필드를 **Flag**로 조건 처리 → 전환 후 플래그 제거

---

## 8. 보안/컴플라이언스 통합

### 8.1 Secrets/Parameters
- AWS **Secrets Manager** / **SSM Parameter Store**로 키/토큰 주입  
- CodeBuild `secrets-manager` 맵핑 사용(앞선 예시)

### 8.2 SAST/라이선스/SBOM/서명
- ESLint/Flake8/Gosec 등 SAST  
- OSS 라이선스 스캔(OSS Review Toolkit, FOSSA 등)  
- **SBOM(syft)** 생성 + 보관  
- 릴리스 아티팩트 **서명**(cosign, AWS Signer) 및 **프로비넌스**(SLSA 수준 향상)

**buildspec 스니펫**
```yaml
phases:
  build:
    commands:
      - oryx scan --format sarif > reports/sast.sarif || true
      - syft dir:. -o spdx-json=reports/sbom.spdx.json
artifacts:
  files: ["reports/**","dist/**"]
reports:
  security:
    files: ["reports/sast.sarif"]
    file-format: SARIF
```

### 8.3 승인/감사
- CodePipeline **Manual Approval**에 ChangeSet/릴리스 노트 링크 첨부  
- CloudTrail로 **배포 이벤트** 추적, 보존기간 관리

---

## 9. 다중 타깃 배포 패턴

### 9.1 EC2 (웹/백엔드)
- ASG 최소 2대, ALB 헬스체크, **Blue/Green + Canary10%/5m**  
- 알람 연동으로 자동 롤백

### 9.2 ECS (Fargate/EC2)
- 태스크 정의 이미지 태그 최신화 → CodeDeploy ECS **Blue/Green**  
- 두 Target Group 전환

### 9.3 Lambda
- CodeDeploy Lambda App → **Canary10Percent5Minutes**  
- Pre/Post Traffic Hook로 통합 테스트/메트릭 검증

### 9.4 EKS
- CodeBuild에서 `kubectl`/`helm` 사용  
- 배포 전략: **RollingUpdate**, **Canary**, **Blue/Green**(별도 Ingress/서비스)

**예: Helm 배포**
```yaml
phases:
  install:
    commands:
      - curl -sSL https://get.helm.sh/helm-v3.14.0-linux-amd64.tar.gz | tar xz && mv linux-amd64/helm /usr/local/bin/
      - aws eks update-kubeconfig --name my-eks --region ap-northeast-2
  build:
    commands:
      - helm upgrade --install web ./chart --set image.tag=${CODEBUILD_RESOLVED_SOURCE_VERSION}
```

---

## 10. GitHub Actions ↔ CodePipeline 연계(옵션)

- 외부 PR 빌드/테스트는 GitHub Actions로, **배포는 CodePipeline**에 위임  
- Actions에서 `aws codepipeline start-pipeline-execution` 호출

```yaml
name: PR-check
on:
  pull_request:
    branches: [ main ]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm ci && npm test
```

---

## 11. 모니터링·가시성

- CodeBuild 리포트(JUnit/SARIF) → CodeBuild 콘솔에서 시각화  
- CloudWatch 대시보드: 배포 성공률, 평균 배포시간, 실패 원인 Top N  
- 로그: Build Logs, CodeDeploy Logs(`/opt/codedeploy-agent/deployment-root`)  
- 추적: X-Ray(배포 후 성능 회귀 감지)

---

## 12. 비용 최적화

- CodeBuild: **Compute type** 최적화, 캐시 사용, 모노레포 **매트릭스 병렬** 대신 변경 감지로 최소 빌드  
- 아티팩트: S3 Lifecycle(예: 30~90일 후 Glacier)  
- 테스트: **단위/통합** 분리, 병렬화로 총 빌드 시간↓  
- 멀티계정: 필요 리전에만 파이프라인/빌드 배치

---

## 13. 통합 레퍼런스 — End-to-End 예시

### 13.1 폴더 구조
```
.
├── buildspec.yml
├── appspec.yml
├── scripts/
│   ├── install_dependencies.sh
│   ├── start_server.sh
│   ├── stop_server.sh
│   └── healthcheck.sh
├── infra/
│   └── pipeline.yaml   # CloudFormation for CodePipeline
└── src/
```

### 13.2 스크립트 예시
```bash
# scripts/install_dependencies.sh
#!/bin/bash
set -eux
cd /var/www/myapp
if [ -f package.json ]; then npm ci; fi
```
```bash
# scripts/start_server.sh
#!/bin/bash
set -eux
pm2 delete all || true
pm2 start dist/server.js --name webapp
```
```bash
# scripts/stop_server.sh
#!/bin/bash
set -eux
pm2 delete all || true
```
```bash
# scripts/healthcheck.sh
#!/bin/bash
set -eux
curl -f http://localhost:3000/health || exit 1
```

---

## 14. 검증/릴리스 체크리스트

- [ ] 파이프라인 **Artifact S3 + KMS** 암호화  
- [ ] CodeBuild **secrets-manager** 사용(평문 금지)  
- [ ] SAST/OSS 라이선스/SBOM 생성·보관  
- [ ] Stg **자동 배포 + 통합 테스트** 성공  
- [ ] **Manual Approval** 증빙(체인지로그/테스트 리포트) 첨부  
- [ ] Prod **Blue/Green + Alarms + Auto-rollback** 활성화  
- [ ] 배포 후 **A/B 메트릭**(에러율/지연/자원) 관찰  
- [ ] 장애 대응 Runbook/롤백 시나리오 숙지

---

## 15. 결론

- **CodePipeline**은 단계/승인/아티팩트 전달의 “골격”.  
- **CodeBuild**는 빌드/테스트/보안검사/SBOM의 “근육”.  
- **CodeDeploy**는 다양한 **배포전략(Blue/Green·Canary·Linear)** 과 **자동 롤백**의 “심장”.

위 템플릿과 스니펫을 **그대로 복붙**해 시작하되, 환경(EC2/ECS/Lambda/EKS)·보안(KMS/Secrets)·품질(SAST/SBOM)·운영(알람/대시보드)을 **단계적으로 성숙**시키면 된다.  
핵심은 **작게 시작해 자동화 범위를 넓히고**, **실패를 안전하게 만들며**, **지속적으로 측정/튜닝**하는 것이다.