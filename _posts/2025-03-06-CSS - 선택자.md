---
layout: post
title: CSS - 선택자
date: 2025-03-06 20:20:23 +0900
category: CSS
---
# 선택자(Selector)

## 0. 선택자란?

**선택자(Selector)**는 “어떤 요소에 스타일을 적용할지”를 지정하는 표현식입니다.  
선택자를 잘 이해하면 **정확한 타깃팅**, **낮은 특이성 유지**, **예측 가능한 스타일**, **간결한 CSS**가 가능합니다.

---

## 1. 기본 선택자

### 1.1 전체 선택자 `*`
```css
* { margin: 0; padding: 0; }
```
- 모든 요소에 적용. 초기화/디버그용으로 제한적으로 사용.  
- 성능·예측성 측면에서 광범위 사용은 지양(대개 `box-sizing: border-box` 같은 전역 규칙에 한정).

### 1.2 태그(요소) 선택자
```css
p { color: gray; }
```
- 문서 의미 구조를 따르는 공통 규칙에 적합(본문 타이포, 기본 여백 등).

### 1.3 클래스 선택자 `.class`
```css
.box { border: 1px solid #000; }
```
- **재사용 가능한 컴포넌트/유틸리티**의 핵심. 실무 기본 축.

### 1.4 아이디 선택자 `#id`
```css
#header { background: lightblue; }
```
- 문서 내 유일해야 함. **특이성이 높아** 과사용 지양(유지보수 난점).

---

## 2. 결합자(Combinator)

### 2.1 자식 `>`
```css
ul > li { list-style: none; }
```
- **직계 자식**만. 구조 의도가 명확.

### 2.2 후손(공백) `␠`
```css
div p { color: green; }
```
- **중첩 깊이 무관**. 남발하면 영향 범위가 넓어짐(선택자 의도 불분명).

### 2.3 형제 `+`, `~`
```css
h2 + p { margin-top: 0; }     /* 바로 다음 형제 */
h2 ~ p { color: red; }         /* 뒤에 오는 모든 형제 */
```

> **팁**: 길고 구체적인 후손 선택자 체인은 **성능·유지보수** 모두에 불리.  
> 컴포넌트(클래스) 중심으로 단순한 결합자를 선호하세요.

---

## 3. 속성 선택자 (Attribute Selectors)

### 3.1 기초
```css
input[type="text"] { border: 1px solid #888; }
```

### 3.2 부분 일치
```css
a[href^="https://"] { /* 시작 */ }
a[href$=".pdf"]     { /* 끝 */ }
a[href*="example"]  { /* 포함 */ }
```

### 3.3 공백/하이픈 구분
```css
/* 단어(공백) 포함: class="tag primary" → 'primary' 단어와 일치 */
[class~="primary"] { color: #2563eb; }

/* 하이픈 시작: lang="en", "en-US" 모두 매치 */
[lang|="en"] { font-variant: common-ligatures; }
```

### 3.4 대소문자 민감도 플래그 (Level 4)
```css
/* i = case-insensitive (대소문자 무시), s = case-sensitive (강제 구분) */
input[type="email" i] { /* 'EMAIL', 'Email'도 일치 */ }
```

### 3.5 ARIA/상태 속성과의 궁합 (실전)
```css
[aria-current]          { font-weight: 700; }
[aria-expanded="true"]  { outline: 2px solid #0ea5e9; }
[data-state="open"]     { display: block; }
```

---

## 4. 가상 클래스 (Pseudo-classes)

### 4.1 상태 기반
```css
a:link   { color: #2563eb; } /* 방문 전 */
a:visited{ color: #7c3aed; } /* 방문 후 (프라이버시 제약으로 일부 속성 제한) */
a:hover  { text-decoration: underline; }
a:active { opacity: .9; }
input:focus { border-color: #2563eb; }
input:focus-visible { outline: 2px solid #2563eb; } /* 키보드 포커스 접근성 향상 */
```

### 4.2 폼 상태
```css
input:required { box-shadow: 0 0 0 1px #d97706 inset; }
input:valid    { border-color: #16a34a; }
input:invalid  { border-color: #dc2626; }
/* 최근 브라우저: 사용자가 상호작용한 뒤의 검증 상태 */
input:user-valid   { border-color: #16a34a; }
input:user-invalid { border-color: #dc2626; }
:disabled { opacity: .6; cursor: not-allowed; }
:checked  + label { font-weight: 700; }
```

### 4.3 구조/위치
```css
li:first-child { font-weight: 700; }
li:last-child  { color: #b91c1c; }
li:nth-child(2){ color: green; }

/* of-타입/선택자 버전 (Level 4) */
li:nth-of-type(odd) { background: #fafafa; }
:where(article) :nth-child(2 of p, h2, ul) { margin-top: 0; }
```

### 4.4 문맥/특수
```css
:root  { color-scheme: light dark; }
:empty { min-height: 2rem; background: #f8fafc; }
:only-child     { border: 1px dashed #bbb; }
:only-of-type   { font-style: italic; }
:lang(ko)       { word-break: keep-all; }
:target         { scroll-margin-top: 6rem; outline: 2px solid #2563eb; }
```

---

## 5. 가상 요소 (Pseudo-elements)

```css
p::before { content: "※ "; }
p::after  { content: " 끝"; }

::selection { background: #fde68a; color: #111; }

::marker { color: #2563eb; }         /* 리스트 마커 스타일 */
::file-selector-button { padding: .5rem .8rem; } /* 파일 입력 버튼 */
```

- `::before`/`::after`는 보통 `content`가 있어야 렌더됨.  
- **접근성**: 아이콘 등 장식엔 `aria-hidden="true"`, 텍스트 의미가 필요하면 실제 DOM 텍스트를 권장.

---

## 6. 그룹 선택자

```css
h1, h2, h3 { font-family: Pretendard, system-ui, sans-serif; }
```
- **쉼표**로 여러 선택자를 묶어 동일 규칙 적용.  
- 컴포넌트 스코프 안에서만 그룹화해 **영향 범위**를 제어하세요.

---

## 7. 최신 선택자 도구함 (Selectors Level 4)

### 7.1 `:is()` — 선택자 리스트를 간결하게, **특이성은 인수 중 최댓값**
```css
/* 이전 */
.card h1, .card h2, .card h3 { margin-top: 1rem; }

/* 이제 */
.card :is(h1, h2, h3) { margin-top: 1rem; }
```

### 7.2 `:where()` — `:is()`와 동일하지만 **특이성 0**
```css
/* 낮은 특이성 유지를 위해 :where 사용 */
:where(.prose) :is(h1, h2, h3) { line-height: 1.25; }
```
- 라이브러리/유틸리티에서 **오버라이드가 쉬운** 규칙을 만들 때 유용.

### 7.3 `:not()` — 부정
```css
button:not(.primary) { background: #e5e7eb; color: #111; }
```
- `:not()` 자체는 특이성을 **추가하지 않지만**, 안에 들어간 선택자의 특이성은 반영.

### 7.4 `:has()` — **부모를 자식 조건으로 스타일링** (게임체인저)
```css
/* 입력이 포커스/에러일 때 래퍼 강조 */
.field:has(input:focus) { outline: 2px solid #2563eb; }
.field:has(input:user-invalid) { outline: 2px solid #dc2626; }

/* 카드에 특정 배지를 포함하면 카드 강조 */
.card:has(.badge--new) { box-shadow: 0 8px 24px rgba(0,0,0,.15); }
```
- 셀렉터 성능 고려: 너무 넓은 범위의 :has 검색은 비용↑ → **스코프를 좁히는 클래스**와 함께 사용.

### 7.5 `:nth-child(an+b of S)` — **필터 대상 지정**
```css
/* 카드 내에서 제목/부제목/요약 중 두 번째 '해당 요소'에만 규칙 */
.card :nth-child(2 of h2, h3, p.summary) { color: #334155; }
```

---

## 8. 특이성(Specificity)·우선순위·레이어

### 8.1 특이성 요약 규칙
- **ID(1,0,0)** > **클래스/속성/의사클래스(0,1,0)** > **요소/의사요소(0,0,1)**
- 인라인 `style`은 **특이성 최상**(단, `!important`는 별도 위계)
- 동등 특이성이면 **나중에 선언된 규칙**이 승

#### 예시 비교
```css
/* 타깃: <h1 id="title" class="headline"> */

h1              { color: green; }  /* 0,0,1 */
.headline       { color: blue; }   /* 0,1,0  → 승 */
#title          { color: purple; } /* 1,0,0  → 승 */

/* !important 역전 */
h1 { color: green !important; }    /* !important → 최상위로 역전 */
```

### 8.2 :is / :where / :not 특이성
- `:is(A, B, C)`의 특이성 = **A,B,C 중 최댓값**
- `:where(...)` = **항상 0**
- `:not(X)` = `X`의 특이성이 **그대로 반영**(단, :not 자체는 추가 없음)

### 8.3 `@layer` — **레이어 우선순위가 특이성보다 먼저**
```css
@layer reset, base, components, utilities;

@layer components {
  .btn { color: #111; }
}
@layer utilities {
  .text-primary { color: #2563eb !important; }
}
```
- 레이어 선언 **순서**가 먼저 비교 → 같은 레이어 내에서는 **특이성/선언순**.  
- 디자인 시스템에서 **충돌 제어**에 매우 유용.

---

## 9. 실전 선택자 설계 패턴

### 9.1 BEM 네이밍
```css
.card {}
.card__title {}
.card--featured {}
```
- 선택자는 짧고 **구조를 드러내며**, 특이성을 낮게 유지.

### 9.2 상태 클래스 / data-* 속성
```html
<details class="accordion" data-state="open">
  <summary>제목</summary>
  <div class="panel">내용</div>
</details>
```
```css
.accordion[data-state="open"] .panel { display: block; }
```

### 9.3 ARIA와 접근성 상태 훅
```html
<button aria-expanded="false" aria-controls="sect1">열기</button>
<section id="sect1" hidden>내용</section>
```
```css
button[aria-expanded="true"] { outline: 2px solid #0ea5e9; }
```

### 9.4 :has로 부모 상태 연동
```css
/* 패널이 열려 있으면 summary에 아이콘 회전 */
details:has([open]) summary svg { transform: rotate(180deg); }
/* 또는 */
details[open] summary svg { transform: rotate(180deg); }
```

### 9.5 유틸리티 선택자
```css
.mt-4 { margin-top: 1rem; }
.text-muted { color: #6b7280; }
```
- **조합성**과 **낮은 특이성**을 유지. 프레임워크와 공존 쉬움.

---

## 10. 접근성·UX를 위한 선택자 관례

- 포커스 가시화: `:focus-visible` 우선
```css
:focus-visible { outline: 3px solid #0ea5e9; outline-offset: 2px; }
```
- 상태를 **색만**으로 구분하지 않기: 아이콘/텍스트 병행  
- `::before/::after`에 의미 텍스트 넣지 않기(보조기기 인식 한계)  
- 콘텐츠가 비어 있으면 `:empty`로 레이아웃 보정 가능하지만, **실제 접근성 메시지**는 DOM에 넣기.

---

## 11. 성능 관점의 선택자

- **오른쪽(키 셀렉터)부터** 매칭: `.card .title`에서 `title` 요소가 먼저 필터됨.  
- 너무 긴 후손 체인, 넓은 범위 `:has`는 비용↑ → **스코프 클래스**로 좁혀라.
- 복잡한 속성 선택자(`[attr*="..."]`) 남발 지양, **정확한 키** 사용.

---

## 12. 디버깅: 어떤 규칙이 적용됐나?

- 브라우저 DevTools의 **Styles/Computed** 탭에서 **적용/무시 규칙**을 확인  
- 의심 요소에 일시적으로 디버그 아웃라인:
```css
* { outline: 1px solid rgba(255,0,0,.1); } /* 개발 중 전역 디버그 */
```
- **특이성 전쟁**이 시작되면 `@layer`·`:where()`로 **낮추고 재정비**.

---

## 13. 실전 시나리오

### 13.1 네비게이션: 현재 위치 강조
```html
<nav class="nav">
  <a href="/home" aria-current="page">Home</a>
  <a href="/posts">Posts</a>
  <a href="/about">About</a>
</nav>
```
```css
.nav a[aria-current] {
  font-weight: 700;
  color: #2563eb;
}
```
- **속성 선택자 + ARIA**로 프레임워크 무관, 접근성 포함.

### 13.2 폼 필드 상태와 부모 하이라이트
```html
<div class="field">
  <label for="email">Email</label>
  <input id="email" type="email" required>
  <p class="hint">회사 메일 주소를 입력하세요.</p>
</div>
```
```css
/* 입력 포커스 시 .field 강조 */
.field:has(input:focus) {
  outline: 2px solid #2563eb; border-radius: .5rem;
}

/* 제출 후 사용자 유효성 상태 */
.field:has(input:user-invalid) .hint { color: #dc2626; }
.field:has(input:user-valid)   .hint { color: #16a34a; }
```

### 13.3 카드 목록: 특정 구성요소 유무에 따른 카드 스타일
```html
<article class="card">
  <h3 class="title">포스트</h3>
  <span class="badge badge--new">NEW</span>
  <p class="excerpt">요약...</p>
</article>
```
```css
.card:has(.badge--new) {
  box-shadow: 0 8px 24px rgba(0,0,0,.12);
}
```

### 13.4 표 헤더 고정과 마커 스타일
```html
<table class="table">
  <thead><tr><th>이름</th><th>점수</th></tr></thead>
  <tbody>...</tbody>
</table>
```
```css
.table thead th { position: sticky; top: 0; background: #f8fafc; }
li::marker { color: #2563eb; }
```

### 13.5 선택자 단순화 리팩터링 (`:is`/`:where`)
```css
/* 이전 */
.article h1,
.article h2,
.article h3 { margin-top: 2rem; }

/* 이후 */
.article :is(h1, h2, h3) { margin-top: 2rem; }

/* 낮은 특이성 의도적 유지 */
:where(.article) :is(h1, h2, h3) { line-height: 1.25; }
```

---

## 14. 흔한 함정과 해결책

| 문제 | 안 좋은 예 | 해결책 |
|---|---|---|
| 특이성 폭발 | `#app .header .nav ul li a { ... }` | **클래스 2~3개**로 충분한 스코프 설계 (`.nav__link`) |
| ID 과사용 | `#header .title` | **ID 대신 클래스**. ID는 JS 훅이나 스크롤 타깃에만 |
| `!important` 남용 | `.btn { color: #111 !important; }` | `@layer`/`:where`로 **낮은 특이성 구조**를 먼저 만들기 |
| 넓은 `:has` | `.page:has(.error)` | `.page.error` **상태 클래스 도입** 또는 더 좁은 스코프 |
| ARIA 무시 | `.active`만 사용 | 접근성/내비: `[aria-current]`, 토글: `[aria-expanded="true"]` |

---

## 15. 선택자 치트시트 (요약)

- **기본**: `*`, `tag`, `.class`, `#id`
- **결합자**: `A B`(후손), `A>B`(자식), `A+B`(인접형제), `A~B`(일반형제)
- **속성**: `[attr]`, `[attr="v"]`, `^=`, `$=`, `*=` , `~=`(단어), `|=`(하이픈 접두), `i/s` 플래그
- **가상클래스**: 상태(`:hover`, `:focus-visible`, `:checked`, `:disabled`, `:valid/:invalid/:user-*`), 구조(`:first/last/only-(child|of-type)`, `:nth-*`, `:lang`, `:target`, `:empty`, `:root`)
- **가상요소**: `::before`, `::after`, `::marker`, `::selection`, `::file-selector-button`
- **레벨 4**: `:is`, `:where`, `:not`, `:has`, `:nth-child(of S)`
- **레이어**: `@layer reset, base, components, utilities;` (레이어 우선 → 특이성)

---

## 16. 종합 예제: 블로그 아티클 스코프 스타일

### HTML
```html
<article class="prose" itemscope itemtype="https://schema.org/Article">
  <header>
    <h1 itemprop="headline">선택자 완전 정복</h1>
    <p class="meta">by Do Hyun Kim</p>
  </header>

  <h2>개요</h2>
  <p>선택자는 대상 요소를 지정하는 문법입니다.</p>

  <h2>목차</h2>
  <ul class="toc">
    <li><a href="#basic">기본 선택자</a></li>
    <li><a href="#advanced">고급 선택자</a></li>
  </ul>

  <section id="basic">
    <h3>기본 선택자</h3>
    <p class="lead">가장 많이 쓰는 선택자들.</p>
  </section>

  <section id="advanced">
    <h3>고급 선택자</h3>
    <p>레벨 4 기능들.</p>
  </section>
</article>
```

### CSS
```css
@layer base, components, utilities;

@layer base {
  :root { color-scheme: light dark; }
  .prose { font-family: system-ui, sans-serif; line-height: 1.7; }
  .prose :where(h1, h2, h3) { line-height: 1.25; }
  .prose .meta { color: #64748b; }
}

@layer components {
  .prose .toc {
    list-style: none; padding: 0; display: grid; gap: .25rem;
  }
  .prose .toc a {
    display: inline-block; padding: .25rem .5rem; border-radius: .375rem;
  }
  .prose .toc a:hover { background: #f1f5f9; }
}

@layer utilities {
  /* :has로 현재 섹션 강조 (해당 앵커가 타깃일 때) */
  .prose:has(:target) .toc a[href="#basic"]:where(:target ~ *) { font-weight: 700; }
}

/* 실제로는 더 간명하게: 현재 타깃 강조 */
:target { outline: 2px solid #2563eb; scroll-margin-top: 6rem; }
```

---

## 17. 마무리

- 초안의 **핵심(기본/결합자/속성/가상클래스·요소/그룹/우선순위)**을 보존하면서,  
  **:is/:where/:has, nth-child(of S), 속성 i/s 플래그, :focus-visible, @layer** 등 **최신 스펙**을 추가했습니다.
- 실전에서는 **낮은 특이성**과 **짧은 선택자**, **상태 클래스/ARIA/data-***를 조합하여  
  **예측 가능하고 접근성 높은** 스타일을 설계하세요.
- 충돌 시에는 `@layer`와 `:where`로 **질서**를 먼저 만들고, `!important`는 **최후의 수단**으로만 사용하세요.
