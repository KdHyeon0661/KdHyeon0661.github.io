---
layout: post
title: 알고리즘 - 동적 계획법 (1)
date: 2025-04-17 21:20:23 +0900
category: 알고리즘
---
# 동적 계획법(Dynamic Programming) 기초

## 1) 동적 계획법이란?

복잡한 문제를 **서로 겹치는 하위 문제(overlapping subproblems)**로 분해하고, 각 하위 문제의 해를 **저장**하여 재사용하는 기법입니다. 또한 **최적 부분 구조(optimal substructure)**가 있어 큰 문제의 최적해가 작은 문제들의 최적해로 구성될 때 적용됩니다.

수학적으로는 다음과 같은 **점화식**(recurrence)을 세우는 과정입니다.

- 예) 피보나치
  \[
  F(n) = F(n-1) + F(n-2),\quad F(0)=0,\ F(1)=1
  \]

---

## 2) DP 표준 풀이 절차(5단계)

1. **상태 정의**: `dp[i]` 또는 `dp[i][j]`가 **무엇**을 의미하는지 자연어로 먼저 정의  
   예) `dp[i] = i를 만들기 위한 최소 동전 수`
2. **초기값 설정**: 경계/기저 사례를 명확히 기입  
   예) `dp[0] = 0`, 나머지는 `+∞`로 초기화 등
3. **점화식(전이) 설계**: 현재 상태를 이전 상태들의 함수로 표현  
   예) `dp[i] = min(dp[i - coin] + 1 for coin in coins if i>=coin)`
4. **순회 순서**: 전이가 의존하는 방향으로 반복문을 설계  
   예) 0/1 배낭은 `j`를 **내림차순**, 완전 배낭은 **오름차순**
5. **정답과 복원**: 정답 위치(`dp[n]`, `dp[n][m]` 등)를 명시, 필요 시 선택 경로 복원

---

## 3) 탑다운 vs 보텀업

| 구분 | 탑다운(메모이제이션) | 보텀업(테이블) |
|---|---|---|
| 접근 | 재귀 + 캐시 | 반복 + 배열 |
| 장점 | 직관적, 필요한 것만 계산 | 호출 스택 부담 없음, 상수계수 빠름 |
| 단점 | 재귀 한계/스택 오버플로우 | 테이블 정의/순서 고민 필요 |
| 추천 | 상태공간이 크고 실제 reachable 적을 때 | 상태가 조밀하고 전이 간단할 때 |

---

## 4) 기본 템플릿

### 4.1 탑다운(메모이제이션)

```python
import sys
sys.setrecursionlimit(1_000_000)

from functools import lru_cache

@lru_cache(maxsize=None)
def f(state):
    # 기저
    if base_condition(state):
        return base_value
    # 전이
    best = +10**18
    for nxt in transitions(state):
        best = min(best, cost(state, nxt) + f(nxt))
    return best
```

### 4.2 보텀업(테이블)

```python
INF = 10**18
dp = [INF]*(N+1)
dp[0] = 0
for i in range(1, N+1):
    for choice in CHOICES:
        if feasible(i, choice):
            dp[i] = min(dp[i], dp[i - cost(choice)] + value(choice))
# 정답: dp[N]
```

---

## 5) 기초 예제 확장

### 5.1 피보나치(비교: 순수 재귀 vs DP)

```python
# 보텀업
def fib(n):
    if n <= 1: return n
    a, b = 0, 1
    for _ in range(2, n+1):
        a, b = b, a+b
    return b
```

시간복잡도 \(O(n)\), 공간 \(O(1)\).

### 5.2 백준 1003 — 피보나치 함수(호출 횟수 DP)
이미 제시된 테이블 버전 OK. 확장: **출력 캐시**를 미리 만들어 여러 쿼리 처리.

```python
call = [[0, 0] for _ in range(41)]
call[0] = [1, 0]
call[1] = [0, 1]
for i in range(2, 41):
    call[i][0] = call[i-1][0] + call[i-2][0]
    call[i][1] = call[i-1][1] + call[i-2][1]
```

### 5.3 백준 9095 — 1, 2, 3 더하기

```python
dp = [0]*12
dp[1], dp[2], dp[3] = 1, 2, 4
for i in range(4, 12):
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
```

### 5.4 백준 2579 — 계단 오르기(연속 3칸 금지)

```python
n = int(input())
st = [0] + [int(input()) for _ in range(n)]
dp = [0]*(n+1)
if n>=1: dp[1] = st[1]
if n>=2: dp[2] = st[1]+st[2]
for i in range(3, n+1):
    dp[i] = max(dp[i-2], dp[i-3] + st[i-1]) + st[i]
print(dp[n])
```

---

## 6) 동전(DP) — 최소 개수와 경우의 수

### 6.1 최소 동전 개수(완전 배낭)

```python
def min_coins(amount, coins):
    INF = 10**9
    dp = [INF]*(amount+1)
    dp[0] = 0
    for c in coins:          # 완전 배낭: 바깥 루프가 coin, 안쪽이 오름차순
        for x in range(c, amount+1):
            dp[x] = min(dp[x], dp[x-c] + 1)
    return dp[amount] if dp[amount] < INF else -1
```

### 6.2 만들 수 있는 경우의 수(조합 수)

```python
def count_ways(amount, coins):
    dp = [0]*(amount+1)
    dp[0] = 1
    for c in coins:
        for x in range(c, amount+1):
            dp[x] += dp[x-c]
    return dp[amount]
```

> 최소 개수 vs 경우의 수: 초기값/전이 의미가 다름. 최소 개수는 `min`, 경우의 수는 `sum`.

---

## 7) 배낭 문제

### 7.1 0/1 배낭(각 아이템 0번 또는 1번)

```python
def knapsack_01(W, items):
    # items: (weight, value)
    dp = [0]*(W+1)
    for w, v in items:
        for cap in range(W, w-1, -1):  # 내림차순! (중복 사용 방지)
            dp[cap] = max(dp[cap], dp[cap-w]+v)
    return dp[W]
```

### 7.2 완전 배낭(무한개 사용 가능)

```python
def unbounded_knapsack(W, items):
    dp = [0]*(W+1)
    for w, v in items:
        for cap in range(w, W+1):  # 오름차순
            dp[cap] = max(dp[cap], dp[cap-w]+v)
    return dp[W]
```

---

## 8) 1차원 수열 DP — 최대 부분합(Kadane)

```python
def max_subarray_sum(a):
    best = cur = a[0]
    for x in a[1:]:
        cur = max(x, cur + x)
        best = max(best, cur)
    return best
```

전형적인 보텀업 전이: `dp[i] = max(a[i], dp[i-1]+a[i])`.

---

## 9) LIS(가장 긴 증가 부분수열)

### 9.1 \(O(n^2)\) DP

```python
def lis_n2(a):
    n = len(a)
    dp = [1]*n
    for i in range(n):
        for j in range(i):
            if a[j] < a[i]:
                dp[i] = max(dp[i], dp[j]+1)
    return max(dp)
```

### 9.2 \(O(n \log n)\) — 이분 탐색 활용

```python
from bisect import bisect_left
def lis_nlogn(a):
    tail = []
    for x in a:
        i = bisect_left(tail, x)
        if i == len(tail):
            tail.append(x)
        else:
            tail[i] = x
    return len(tail)
```

> `tail[k]`: 길이 `k+1` 증가 부분수열의 **가장 작은 끝값**.

---

## 10) 문자열 DP

### 10.1 LCS(최장 공통 부분수열) — \(O(nm)\)

```python
def lcs(a, b):
    n, m = len(a), len(b)
    dp = [[0]*(m+1) for _ in range(n+1)]
    for i in range(1, n+1):
        for j in range(1, m+1):
            if a[i-1] == b[j-1]:
                dp[i][j] = dp[i-1][j-1]+1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[n][m]
```

#### 경로 복원(선택한 문자를 추적)
```python
def lcs_restore(a, b):
    n, m = len(a), len(b)
    dp = [[0]*(m+1) for _ in range(n+1)]
    for i in range(1, n+1):
        for j in range(1, m+1):
            dp[i][j] = dp[i-1][j-1]+1 if a[i-1]==b[j-1] else max(dp[i-1][j], dp[i][j-1])
    i, j = n, m
    res = []
    while i>0 and j>0:
        if a[i-1]==b[j-1]:
            res.append(a[i-1]); i-=1; j-=1
        elif dp[i-1][j] >= dp[i][j-1]:
            i-=1
        else:
            j-=1
    return ''.join(reversed(res))
```

### 10.2 편집 거리(Edit Distance) — Levenshtein

```python
def edit_distance(a, b):
    n, m = len(a), len(b)
    dp = [[0]*(m+1) for _ in range(n+1)]
    for i in range(n+1): dp[i][0] = i
    for j in range(m+1): dp[0][j] = j
    for i in range(1, n+1):
        for j in range(1, m+1):
            cost = 0 if a[i-1]==b[j-1] else 1
            dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost)
    return dp[n][m]
```

---

## 11) 2차원 격자 DP

### 11.1 경로의 수 — 오른쪽/아래만 이동

```python
MOD = 10**9+7
def count_paths(grid):
    n, m = len(grid), len(grid[0])
    dp = [[0]*m for _ in range(n)]
    if grid[0][0]==1: return 0
    dp[0][0] = 1
    for i in range(n):
        for j in range(m):
            if grid[i][j]==1: 
                dp[i][j]=0; continue
            if i: dp[i][j] += dp[i-1][j]
            if j: dp[i][j] += dp[i][j-1]
            dp[i][j] %= MOD
    return dp[n-1][m-1]
```

### 11.2 최소 비용 경로

```python
def min_path_sum(cost):
    n, m = len(cost), len(cost[0])
    dp = [[0]*m for _ in range(n)]
    dp[0][0] = cost[0][0]
    for j in range(1, m): dp[0][j] = dp[0][j-1] + cost[0][j]
    for i in range(1, n): dp[i][0] = dp[i-1][0] + cost[i][0]
    for i in range(1, n):
        for j in range(1, m):
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j]
    return dp[n-1][m-1]
```

---

## 12) 비트마스크 DP — TSP 소형

상태: `dp[mask][u]` = 방문 집합 `mask`로 `u`에 도착하는 최소 비용

```python
def tsp(cost):
    n = len(cost)
    INF = 10**9
    dp = [[INF]*n for _ in range(1<<n)]
    dp[1][0] = 0  # 0에서 시작
    for mask in range(1<<n):
        for u in range(n):
            if not (mask & (1<<u)): continue
            for v in range(n):
                if mask & (1<<v): continue
                dp[mask|(1<<v)][v] = min(dp[mask|(1<<v)][v], dp[mask][u] + cost[u][v])
    ans = min(dp[(1<<n)-1][u] + cost[u][0] for u in range(n))
    return ans
```

시간 \(O(n^2 2^n)\). n이 15~20 정도에서 실전 가능.

---

## 13) 구간 DP(Interval DP) — 행렬 연쇄 곱셈

상태: `dp[i][j]` = i~j 곱 비용 최소

```python
def matrix_chain(p):
    # p: 차원 배열, 행렬 A_i는 p[i-1] x p[i]
    n = len(p)-1
    INF = 10**18
    dp = [[0]* (n+1) for _ in range(n+1)]
    for len_ in range(2, n+1):
        for i in range(1, n-len_+2):
            j = i+len_-1
            dp[i][j] = INF
            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j]+p[i-1]*p[k]*p[j])
    return dp[1][n]
```

---

## 14) 트리 DP — Independent Set(루트 없는 트리)

`dp[u][0/1]` = u를 선택하지/선택했을 때 u 서브트리에서의 최대 독립집합 크기

```python
import sys
sys.setrecursionlimit(1_000_000)

def tree_independent_set(n, graph, weight=None):
    # weight=None이면 가중치 1로 가정
    if weight is None: weight = [1]*(n+1)
    dp0 = [0]*(n+1)  # u 미선택
    dp1 = [0]*(n+1)  # u 선택

    visited = [False]*(n+1)
    def dfs(u):
        visited[u]=True
        dp1[u] = weight[u]
        for v in graph[u]:
            if visited[v]: continue
            dfs(v)
            dp0[u] += max(dp0[v], dp1[v])  # u 미선택: 자식 자유
            dp1[u] += dp0[v]               # u 선택: 자식은 미선택
    dfs(1)
    return max(dp0[1], dp1[1])
```

---

## 15) 경로 복원 일반 기법

최대/최소값 뿐 아니라 **선택 경로**를 출력하려면, 전이할 때 **부모/선택 기록**을 둡니다.

```python
def coin_change_restore(amount, coins):
    INF = 10**9
    dp = [INF]*(amount+1)
    prev = [-1]*(amount+1)   # 어떤 코인으로 왔는지
    dp[0] = 0
    for c in coins:
        for x in range(c, amount+1):
            if dp[x-c] + 1 < dp[x]:
                dp[x] = dp[x-c] + 1
                prev[x] = c
    if dp[amount] >= INF: return -1, []
    used = []
    cur = amount
    while cur>0:
        used.append(prev[cur])
        cur -= prev[cur]
    return dp[amount], used  # 사용한 동전 목록
```

---

## 16) 공간/시간 최적화

1) **롤링 배열**: 2차원 DP에서 `dp[i][*]`만 필요하면 1차원으로 압축  
2) **전이 순서**: 0/1 배낭은 역순, 완전 배낭은 정순  
3) **전이 최적화**(고급):
   - **모노토닉 큐 최적화**: 구간 길이가 고정된 전이의 슬라이딩 최소/최대
   - **Divide & Conquer Optimization**: `opt[i] ≤ opt[i+1]`가 성립할 때
   - **Convex Hull Trick**: 선형 전이의 최솟값/최댓값(라인 컨테이너)

> 대회 고난도 DP에서 시간 \(O(n\log n)\), \(O(n)\)로 줄이는 핵심 테크닉입니다.

---

## 17) DP 설계 체크리스트(실수 방지)

- 상태 정의가 **명확한가**? `dp[i]`가 무엇을 의미하는지 한 문장으로 설명 가능?
- 초기값은 올바른가? 예: 최대/최소에 맞는 **중립값**(0, +∞, -∞) 선택
- 전이에서 **경계 검사**(인덱스 범위) 빠짐 없음?
- 순회 순서가 전이 의존성과 맞는가? (0/1 vs 완전 배낭)
- 답의 위치는 어디인가? `dp[n]`, `max(dp[i])`, `dp[n][m]` 등
- 필요 시 **경로 복원**을 위한 parent/choice 기록 추가

---

## 18) 대표 문제 카탈로그(백준)

| 주제 | 번호 | 요지 |
|---|---|---|
| 동전 최소/경우의 수 | 2294, 9084 | 완전 배낭/카운팅 |
| 배낭 0/1 | 12865 | 역순 전이 |
| LIS | 11053, 12015 | \(O(n^2)\)/\(O(n\log n)\) |
| LCS | 9251 | 문자열 DP |
| 편집거리 | 15483 | 삽입/삭제/치환 |
| 최대 부분합 | 1912 | Kadane |
| 구간 DP | 11066 | 파일 합치기 |
| 비트마스크 DP | 2098 | TSP |
| 트리 DP | 2213, 2533 | 독립집합/얼리어답터 |

---

## 19) 수학적 시각(점화식의 안정성)

DP는 본질적으로 다음 형태의 재귀 관계를 **유한 상태공간**에서 **메모리**로 고정시키는 것:

\[
\mathrm{dp}[s] = \min_{a \in A(s)} \{ c(s,a) + \mathrm{dp}[T(s,a)] \}
\]

- \(s\): 상태, \(A(s)\): 선택, \(T\): 전이, \(c\): 비용  
- **최소/최대** 대신 **합/경우의 수** 등 다양한 세미링으로 일반화 가능

---

## 20) 종합 예제 묶음

### 20.1 동전 2문제(최소·경우의 수)

```python
def coin_min_and_count(amount, coins):
    INF = 10**9
    # 최소 개수
    min_dp = [INF]*(amount+1)
    min_dp[0] = 0
    for c in coins:
        for x in range(c, amount+1):
            min_dp[x] = min(min_dp[x], min_dp[x-c]+1)

    # 경우의 수
    cnt_dp = [0]*(amount+1)
    cnt_dp[0] = 1
    for c in coins:
        for x in range(c, amount+1):
            cnt_dp[x] += cnt_dp[x-c]

    return (min_dp[amount] if min_dp[amount]<INF else -1, cnt_dp[amount])
```

### 20.2 배낭 0/1 + 경로 복원(선택된 아이템)

```python
def knapsack_restore(W, items):
    n = len(items)
    dp = [[0]*(W+1) for _ in range(n+1)]
    for i,(w,v) in enumerate(items, start=1):
        for cap in range(W+1):
            dp[i][cap] = dp[i-1][cap]
            if cap>=w and dp[i-1][cap-w]+v > dp[i][cap]:
                dp[i][cap] = dp[i-1][cap-w]+v
    # 복원
    sel = []
    cap = W
    for i in range(n,0,-1):
        w, v = items[i-1]
        if dp[i][cap] != dp[i-1][cap]:
            sel.append(i-1)
            cap -= w
    sel.reverse()
    return dp[n][W], sel
```

### 20.3 파일 합치기(구간 DP) — 전이 최적화 아이디어 힌트
`dp[i][j] = min_k dp[i][k] + dp[k+1][j] + sum(i..j)`  
구간합 `S`로 `sum(i..j)`를 \(O(1)\)에 계산. 최적분할 인덱스가 단조이면 `Knuth 최적화` 고려.

---

## 21) 결론 요약

| 항목 | 요약 |
|---|---|
| 핵심 | **상태 정의 → 초기값 → 전이 → 순서 → 정답/복원** |
| 적용 조건 | Overlapping Subproblems + Optimal Substructure |
| 구현 | 탑다운(재귀+캐시) 또는 보텀업(반복+테이블) |
| 유형 | 최적화/카운팅/결정형(가능/불가능) |
| 최적화 | 롤링 배열, 전이 순서, 고급 최적화(모노토닉 큐, CHT, D&C) |
| 학습 루트 | 동전/배낭/부분수열/문자열/구간/트리/비트마스크 순으로 확장 |