---
layout: post
title: 알고리즘 - 동적 계획법 (1)
date: 2025-04-17 21:20:23 +0900
category: 알고리즘
---
# 📚 동적 계획법(Dynamic Programming) 기초 완전 정복

**동적 계획법(DP)**은 복잡한 문제를 작은 문제로 나누고,  
그 결과를 저장해서 **중복 계산을 피하는 알고리즘 설계 기법**입니다.

조합 최적화, 경로 탐색, 수열 처리 등에서 **시간 복잡도를 획기적으로 줄여주는 강력한 도구**입니다.

---

## ❓ 왜 동적 계획법을 배워야 할까?

- 완전탐색(브루트포스)은 시간 초과가 나기 쉽다
- **중복되는 연산**을 줄이고 **최적의 해**를 빠르게 구할 수 있다
- 실제 면접과 코딩 테스트에서 자주 등장 (LeetCode, 백준, 삼성 SW 역량 테스트 등)

---

## 🧠 동적 계획법의 핵심 아이디어

### 📌 **작은 문제에서 큰 문제로 나아가는 '점화식' 설계**
- 문제를 작은 문제로 나눈다
- **이전에 구한 답을 저장(memoization)**하고
- 그것을 이용해서 다음 문제를 해결한다

### 📌 예: 피보나치 수열
```text
f(n) = f(n-1) + f(n-2)
```

| n | 호출 횟수 (재귀) | 저장 (DP) |
|---|------------------|------------|
| 30 | 수천만 번 | 30번 만에 끝 |

---

## ✅ 동적 계획법을 사용할 수 있는 조건

| 조건 | 설명 |
|------|------|
| **Overlapping Subproblems** | 동일한 작은 문제가 반복됨 |
| **Optimal Substructure** | 큰 문제의 최적해가 작은 문제의 최적해로 구성됨 |

---

## 📦 DP의 분류

| 유형 | 설명 | 예시 |
|------|------|------|
| **Top-down (Memoization)** | 재귀 + 캐싱 | `f(n) = f(n-1) + f(n-2)` |
| **Bottom-up (Tabulation)** | 반복문 + 테이블 채우기 | `dp[i] = dp[i-1] + dp[i-2]` |
| **1차원 배열** | 수열, 계단, 피보나치 | |
| **2차원 배열** | 행렬 경로, 배낭 문제 | |
| **상태 DP** | `dp[i][j][k]`처럼 복잡한 상태 추적 | |

---

## ✅ 기본 문제 예제 모음

---

### 📘 [백준 1003 - 피보나치 함수](https://www.acmicpc.net/problem/1003)

```python
dp = [[0, 0] for _ in range(41)]
dp[0] = [1, 0]  # 0 호출 시
dp[1] = [0, 1]  # 1 호출 시

for i in range(2, 41):
    dp[i][0] = dp[i-1][0] + dp[i-2][0]
    dp[i][1] = dp[i-1][1] + dp[i-2][1]

for _ in range(int(input())):
    n = int(input())
    print(dp[n][0], dp[n][1])
```

📌 함수 호출 수를 DP로 누적 계산

---

### 📘 [백준 9095 - 1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)

```python
dp = [0] * 12
dp[1], dp[2], dp[3] = 1, 2, 4

for i in range(4, 12):
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

t = int(input())
for _ in range(t):
    print(dp[int(input())])
```

📌 n을 1,2,3의 합으로 표현하는 경우의 수 → 점화식 설계 연습용

---

### 📘 [백준 2579 - 계단 오르기](https://www.acmicpc.net/problem/2579)

```python
n = int(input())
stairs = [0] + [int(input()) for _ in range(n)]
dp = [0] * (n + 1)

if n >= 1: dp[1] = stairs[1]
if n >= 2: dp[2] = stairs[1] + stairs[2]

for i in range(3, n + 1):
    dp[i] = max(dp[i-2], dp[i-3] + stairs[i-1]) + stairs[i]

print(dp[n])
```

📌 한 번에 1칸 또는 2칸 올라갈 수 있고, **연속 3칸은 안됨**  
→ DP 점화식에 조건 추가

---

## 🔁 Top-Down vs Bottom-Up 비교

| 방식 | 설명 | 장단점 |
|------|------|--------|
| **Top-down** | 재귀 + 메모이제이션 | 구현 간결, 깊은 호출 주의 |
| **Bottom-up** | 반복문 + 배열 | 메모리 예측 용이, 빠름 |

---

## ⚠️ DP에서 자주 하는 실수

- 점화식을 정확히 이해하지 못하고 시작
- 초기값 설정을 빼먹음 (예: `dp[0] = 0`, `dp[1] = 1`)
- 인덱스 범위 초과
- 중복 계산이 발생 (메모이제이션 안함)

---

## 📚 동적 계획법이 쓰이는 대표 문제 유형

| 유형 | 설명 |
|------|------|
| 피보나치 수열 | 대표적인 DP 기본 구조 |
| 계단 오르기, 점프 | 이전 상태와 현재 상태 연결 |
| 동전 문제 | 최소 동전 개수, 경우의 수 |
| 배낭 문제 (Knapsack) | 물건을 고르는 최적해 |
| 수열 문제 | 가장 긴 증가 부분 수열 (LIS), 부분 합 최대 등 |
| 행렬 탐색 | 2차원 DP, 경로의 수, 최소 비용 |

---

## ✅ 마무리 요약

| 항목 | 요약 |
|------|------|
| 핵심 개념 | 중복되는 하위 문제의 결과를 저장 |
| 조건 | Overlapping + Optimal Substructure |
| 전략 | 점화식 설계 + 메모이제이션 |
| 구현 방식 | Top-down (재귀), Bottom-up (반복) |
| 주요 예제 | 피보나치, 계단 오르기, 동전 문제 등 |

> 동적 계획법은 **생각을 코드로 구현하는 힘**을 키우는 훈련이다.