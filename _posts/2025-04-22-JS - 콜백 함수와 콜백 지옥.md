---
layout: post
title: JavaScript - 콜백 함수와 콜백 지옥
date: 2025-04-22 19:20:23 +0900
category: JavaScript
---
# 콜백 함수와 콜백 지옥 (Callback & Callback Hell)

## 콜백 함수란?

### 정의와 기본 형태

- **콜백 함수(callback)**: 다른 함수에 **인자로 전달**되어 **나중에 호출**되는 함수.
- 동기(Sync)·비동기(Async) 모두 가능하나, 실전에서는 주로 **비동기 완료 통지**에 사용.

```js
function greet(name, callback) {
  console.log(`Hello, ${name}`);
  callback(); // 나중 시점 호출
}

function finish() { console.log("Greeting complete."); }

greet("Alice", finish);
// Hello, Alice
// Greeting complete.
```

### 에러 우선 콜백(Node 스타일)

- Node.js의 표준 관례: **error-first callback** `(err, result)`.
- 성공 시 `err=null` 또는 `undefined`.

```js
const fs = require("fs");

fs.readFile("data.txt", "utf8", (err, data) => {
  if (err) return console.error("읽기 실패:", err);
  console.log("내용:", data);
});
```

### 타이머·이벤트에서의 콜백

```js
setTimeout(() => console.log("3초 후 실행!"), 3000);

button.addEventListener("click", () => {
  console.log("버튼 클릭됨");
});
```

---

## 콜백과 이벤트 루프: 실행 순서 이해

### 태스크 큐와 콜백 스케줄링

- 브라우저/Node 런타임은 **이벤트 루프**가 태스크를 꺼내 **콜백을 실행**.
- `setTimeout(fn, 0)`도 **즉시**가 아니라 다음 틱에 큐에 들어감.

```js
console.log("A");
setTimeout(() => console.log("B"), 0);
console.log("C");
// 출력: A → C → B
```

### 마이크로태스크와 비교(참고)

- `Promise.then`은 **마이크로태스크**로, 일반 타이머 콜백보다 먼저 실행됨.

```js
setTimeout(() => console.log("macro"), 0);
Promise.resolve().then(() => console.log("micro"));
console.log("sync");
// sync → micro → macro
```

---

## 콜백 지옥(Callback Hell)

### 증상과 예시

- **중첩된 들여쓰기(피라미드)**, **흩어진 에러 처리**, **흐름 파악 어려움**.

```js
login("user", "pass", (err, user) => {
  if (err) return console.error(err);

  getUserProfile(user.id, (err, profile) => {
    if (err) return console.error(err);

    getUserPosts(profile.id, (err, posts) => {
      if (err) return console.error(err);

      console.log("Posts:", posts);
    });
  });
});
```

### 근본 원인

- **제어권 역전(Inversion of Control)**: 흐름을 라이브러리/환경에 위임.
- **에러/취소/타임아웃** 같은 부가 요구 사항이 얽히면 가독성 급락.

---

## 콜백 지옥 완화: 콜백만으로 구조화

### 핸들러 분리

```js
function onError(err) { if (err) console.error(err); }

function onPosts(err, posts) {
  if (err) return onError(err);
  console.log("Posts:", posts);
}

function onProfile(err, profile) {
  if (err) return onError(err);
  getUserPosts(profile.id, onPosts);
}

function onLogin(err, user) {
  if (err) return onError(err);
  getUserProfile(user.id, onProfile);
}

login("user", "pass", onLogin);
```

### 제어 흐름 유틸(직렬 실행 예시)

```js
function series(tasks, done) {
  let i = 0;
  const next = (err, res) => {
    if (err || i === tasks.length) return done(err, res);
    const task = tasks[i++];
    task(next);
  };
  next();
}

// 사용
series([
  cb => login("user","pass",(e,u)=>cb(e,u)),
  (prev, cb) => getUserProfile(prev.id, cb),
  (prev, cb) => getUserPosts(prev.id, cb),
], (err, posts) => {
  if (err) return console.error(err);
  console.log("Posts:", posts);
});
```

> 콜백만으로도 체계를 잡을 수 있지만, **표현력/가독성**은 Promise/async-await가 우수합니다.

---

## Promise로 개선하기

### 콜백 API를 Promise로 감싸기(promisify)

```js
const fs = require("fs");

function readFileP(path, enc="utf8") {
  return new Promise((resolve, reject) => {
    fs.readFile(path, enc, (err, data) => err ? reject(err) : resolve(data));
  });
}

readFileP("data.txt")
  .then(text => console.log(text))
  .catch(console.error);
```

### 체이닝으로 평탄화

```js
loginP("user","pass")
  .then(user   => getUserProfileP(user.id))
  .then(profile=> getUserPostsP(profile.id))
  .then(posts  => console.log("Posts:", posts))
  .catch(err   => console.error("에러:", err));
```

### 병렬/집합 연산

```js
Promise.all([fetchA(), fetchB(), fetchC()])
  .then(([a,b,c]) => use(a,b,c))
  .catch(console.error);

Promise.allSettled([pa, pb]).then(results => {
  for (const r of results) {
    if (r.status === "fulfilled") console.log("OK:", r.value);
    else console.warn("ERR:", r.reason);
  }
});
```

---

## async/await로 리팩터링

### 직렬 흐름을 동기처럼 표현

```js
async function fetchPosts() {
  try {
    const user    = await loginP("user", "pass");
    const profile = await getUserProfileP(user.id);
    const posts   = await getUserPostsP(profile.id);
    console.log("Posts:", posts);
  } catch (err) {
    console.error(err);
  }
}
fetchPosts();
```

### 병렬 실행 패턴

```js
async function fetchData() {
  const [a, b] = await Promise.all([fetchAP(), fetchBP()]);
  return combine(a, b);
}
```

### 타임아웃/취소(AbortController)

```js
async function fetchWithTimeout(url, { ms = 3000 } = {}) {
  const ac = new AbortController();
  const t  = setTimeout(() => ac.abort(), ms);
  try {
    const res = await fetch(url, { signal: ac.signal });
    return await res.json();
  } finally {
    clearTimeout(t);
  }
}
```

### 지수 백오프 리트라이

- 대기 시간: $$ t_k = t_0 \cdot 2^{k} $$
```js
async function retry(fn, { attempts=3, base=300 } = {}) {
  let last;
  for (let k=0; k<attempts; k++) {
    try { return await fn(); }
    catch (e) { last = e; await new Promise(r => setTimeout(r, base * (2 ** k))); }
  }
  throw last;
}
```

---

## 브라우저 콜백형 API → Promise로 포장

### XHR 예시

```js
function getJSON(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "json";
    xhr.onload = () => xhr.status >= 200 && xhr.status < 300
      ? resolve(xhr.response)
      : reject(new Error(`HTTP ${xhr.status}`));
    xhr.onerror = () => reject(new Error("Network error"));
    xhr.send();
  });
}

getJSON("/api/data")
  .then(console.log)
  .catch(console.error);
```

### 지오로케이션 예시

```js
function getCurrentPositionP(opts){
  return new Promise((res, rej) =>
    navigator.geolocation.getCurrentPosition(res, rej, opts));
}
```

---

## 에러 처리, 리소스 정리, 누수 방지

### 콜백에서의 에러 처리 원칙

- **한 곳에서 return**으로 종료.
- **이중 콜백 호출** 금지(플래그·상태로 보호).

```js
function task(cb) {
  let done = false;
  function once(err, val) {
    if (done) return; done = true; // 중복 방지
    cb(err, val);
  }
  asyncOp((err, v) => err ? once(err) : once(null, v));
}
```

### Promise/async에서의 안전망

- 체인 마지막에 `.catch()`를 두어 **누락 에러** 방지.
- 전역 핸들러:
  - 브라우저 `unhandledrejection`
  - Node `unhandledRejection`

```js
window.addEventListener("unhandledrejection", e => {
  console.warn("Unhandled:", e.reason);
});
```

### `finally`로 정리 보장

```js
let lock;
try {
  lock = await acquire();
  await critical();
} finally {
  if (lock) await lock.release();
}
```

---

## 성능·설계 고려사항

### 과도한 중첩/연쇄 IO

- **가능한 병렬**: 독립 IO는 `Promise.all`.
- **의존 관계**: 필요한 최소한만 직렬 `await`.

### 재시도 폭주(K thundering herd)

- 지수 백오프 + **지터(jitter)** 적용.
- 수식 예: $$ t_k = U(0, 1) \cdot t_0 \cdot 2^{k} $$

### 취소 가능성

- 콜백 세계: **플래그**로 취소 신호.
- 최신 API: **AbortController**/`signal`.

---

## 마이그레이션 가이드(콜백 → Promise/async)

### 단계별

1) **핫스팟** 식별(깊은 중첩/불안정 콜백 구간).
2) **promisify 래퍼** 작성·도입.
3) **then-chain**으로 평탄화.
4) **async/await**로 가독성 향상.
5) **타임아웃/취소/리트라이** 표준화 유틸 적용.
6) **전역 에러 핸들러** 배선.

### 예: 전체 변환

```js
// (1) 원본 콜백 API
function getUser(id, cb){
  setTimeout(() => cb(null, { id, name: "Alice" }), 200);
}
function getOrders(uid, cb){
  setTimeout(() => cb(null, [{ id: 1, uid }, { id: 2, uid }]), 200);
}

// (2) promisify
const getUserP   = id => new Promise((res, rej) => getUser(id, (e,v)=> e?rej(e):res(v)));
const getOrdersP = uid => new Promise((res, rej) => getOrders(uid, (e,v)=> e?rej(e):res(v)));

// (3) async/await
async function getUserOrders(uid){
  const user   = await getUserP(uid);
  const orders = await getOrdersP(user.id);
  return { user, orders };
}

getUserOrders(10).then(console.log).catch(console.error);
```

---

## 안티패턴과 개선

### 새 Promise로 불필요한 래핑

```js
// ❌ 나쁜 예
new Promise((resolve, reject) => {
  fetch(url).then(resolve, reject);
});
// ✅ 그냥 반환
fetch(url);
```

### `await` 후 `then` 혼용

```js
// ❌ 혼용은 가독성 저하
const r = await fetch(url).then(r => r.json());
// ✅ 일관성 있게
const r = await (await fetch(url)).json();
```

### 병렬 가능한데 직렬로 작성

```js
// ❌
const a = await A(); const b = await B();
// ✅
const [a, b] = await Promise.all([A(), B()]);
```

---

## 미니 퀴즈

```js
// Q1) 출력 순서는?
console.log("X");
setTimeout(() => console.log("Y"), 0);
Promise.resolve().then(() => console.log("Z"));
// ?

// Q2) 다음 콜백 API를 Promise로 바꾸고, async/await으로 posts 콘솔 출력
getUser("u", (e, user) => { /* ... */ });
getPosts("id", (e, posts) => { /* ... */ });

// Q3) 콜백 지옥을 완화하는 3가지 전략을 쓰시오.
// (힌트: 핸들러 분리, 제어 흐름 유틸, Promise/async)

// Q4) 지수 백오프 대기 시간 수식은?
// (기본: t_k = t_0 * 2^k, 지터 포함 변형도 서술)
```

**정답 힌트**
- Q1: `X → Z → Y` (sync → micro → macro)
- Q2: `promisify` 후 `await`으로 순차 처리
- Q3: 함수 분리, series/parallel 유틸, Promise/async-await
- Q4: $$t_k = t_0 \cdot 2^{k}$$, 지터: $$t_k = U(0,1)\cdot t_0 \cdot 2^{k}$$

---

## 요약

- 콜백은 **완료 통지**를 위한 기본 도구지만, 복잡해지면 **콜백 지옥**으로 이어짐.
- **Promise**와 **async/await**을 통해 **가독성·에러 처리·조합성**을 크게 개선.
- 실전에서는 **promisify → then-chain → async/await** 순으로 리팩터링하고,
  **타임아웃/취소/리트라이/전역 핸들러**까지 표준화하면 견고한 비동기 코드를 만들 수 있다.
