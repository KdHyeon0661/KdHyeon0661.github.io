---
layout: post
title: WPF - UI 가상화
date: 2025-09-07 22:25:23 +0900
category: WPF
---
# ⚡ WPF **UI 가상화(VirtualizingStackPanel)** 완전 정복
*(개념 → 조건/옵션 → 예제 → 고급 패턴(리사이클·캐시·픽셀 스크롤) → 데이터 가상화와 차이 → 트러블슈팅/체크리스트까지 “빠짐없이”)*

> 이 글은 WPF의 **UI 가상화**를 중심으로, `VirtualizingStackPanel`이 언제/어떻게 동작하는지,  
> 성능을 극적으로 끌어올리는 **필수 설정/주의점/실전 템플릿**을 모두 모았습니다.  
> .NET 4.5+ ~ .NET 8 WPF까지 통용되는 내용을 기준으로 합니다.

---

## 0. 한눈에 보기: 왜 필요한가?

- **UI 가상화(UI Virtualization)** = **보이는 아이템만** 컨테이너(예: `ListBoxItem`, `ListViewItem`)와 템플릿을 만들어 **실제로 렌더/측정**하고, 화면 밖은 **재활용/폐기**.  
- 이로 인해 **메모리/레이아웃/바인딩/템플릿 비용**이 급감 → 스크롤/탭 전환 **부드러움** 확보.  
- 주인공: `VirtualizingStackPanel` (수직/수평 스택 레이아웃의 가상화 구현체)

> **데이터 가상화(Data Virtualization)** 와는 다릅니다.  
> - UI 가상화: **컨트롤 생성/측정/렌더를 줄임**  
> - 데이터 가상화: **데이터 로딩 자체를 지연/페이징**  
> 실전에선 **둘 다** 써야 대용량에서 쾌적합니다.

---

## 1. 기본 사용법 (필수 스위치)

대부분의 `ItemsControl` 파생(예: `ListBox`, `ListView`, `TreeView`, `DataGrid`)는 기본적으로 가상화를 지원하지만,  
**아래 3가지 조건**이 맞아야 **실제 동작**합니다.

1) 스크롤은 **아이템 기반** (`ScrollViewer.CanContentScroll="True"`)  
2) **ItemsPanel** 이 `VirtualizingStackPanel`  
3) **가상화 활성화 + 리사이클 모드** 설정

### 1.1 ListBox 예제(정석)
```xml
<ListBox ItemsSource="{Binding HugeItems}"
         ScrollViewer.CanContentScroll="True"  <!-- 아이템 스크롤: 가상화 핵심 -->
         VirtualizingStackPanel.IsVirtualizing="True"
         VirtualizingStackPanel.VirtualizationMode="Recycling"  <!-- 재활용 -->
         VirtualizingPanel.CacheLengthUnit="Item"               <!-- 프리페치 단위 -->
         VirtualizingPanel.CacheLength="2,2">                   <!-- 위/아래 각 2개 -->
  <ListBox.ItemsPanel>
    <ItemsPanelTemplate>
      <VirtualizingStackPanel/>
    </ItemsPanelTemplate>
  </ListBox.ItemsPanel>

  <ListBox.ItemTemplate>
    <DataTemplate>
      <!-- 무거운 템플릿이라도 가상화+리사이클이면 버틸 수 있음 -->
      <StackPanel Orientation="Horizontal" Margin="8" SnapsToDevicePixels="True">
        <Image Source="{Binding Thumbnail}" Width="48" Height="48" Margin="0,0,8,0"/>
        <StackPanel>
          <TextBlock Text="{Binding Title}" FontWeight="SemiBold"/>
          <TextBlock Text="{Binding Description}" Foreground="#666"/>
        </StackPanel>
      </StackPanel>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
```

> **중요**: `ScrollViewer.CanContentScroll="False"` 이면 **픽셀 스크롤**로 동작 → 기본 `VirtualizingStackPanel`에서는 **가상화가 꺼집니다**  
> (픽셀 스크롤에서도 가상화가 필요한 경우는 4.2절 **픽셀 스크롤 가상화** 참고)

---

## 2. 핵심 옵션 총정리

| 속성/옵션 | 의미 | 권장 |
|---|---|---|
| `ScrollViewer.CanContentScroll` | `True`면 항목 단위 스크롤(가상화 ON) | **True** |
| `VirtualizingStackPanel.IsVirtualizing` | 가상화 켜기 | **True** |
| `VirtualizingStackPanel.VirtualizationMode` | `Standard`(버림) / `Recycling`(재활용) | **Recycling** |
| `VirtualizingPanel.CacheLengthUnit` | 캐시 단위: `Item`/`Page`/`Pixel` | 보통 **Item** |
| `VirtualizingPanel.CacheLength` | 화면 밖 **프리페치** 범위(위,아래) | 목록 성격에 따라 튜닝 |
| `VirtualizingPanel.IsVirtualizingWhenGrouping` | Grouping 시 가상화 유지 | **True**(가능하면) |
| `VirtualizingPanel.ScrollUnit` | `Item`/`Pixel` (픽셀 스크롤 가상화 시 사용) | 상황별 |
| `VirtualizingPanel.ScrollForced` | 레이아웃 특성상 스크롤 강제 | 특수 케이스 |
| `VirtualizingPanel.CleanUpVirtualizedItem` | 컨테이너 폐기 전 정리 이벤트 | 자원 해제, 상태 유지 |

> **리사이클(Recycling)**: 화면 밖으로 나간 컨테이너를 **다른 아이템에게 재할당** → 생성/GC 비용 대폭 감소.  
> 단, **상태 누수**(체크박스 상태 같은 UI 상태)가 발생하지 않도록 **바인딩만으로 상태 표현**(시각적 상태는 템플릿 트리거/VSM) 권장.

---

## 3. 컨트롤별 가이드

### 3.1 ListView (GridView와 함께)
```xml
<ListView ItemsSource="{Binding Products}"
          ScrollViewer.CanContentScroll="True"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling">
  <ListView.ItemsPanel>
    <ItemsPanelTemplate>
      <VirtualizingStackPanel/>
    </ItemsPanelTemplate>
  </ListView.ItemsPanel>
  <ListView.View>
    <GridView AllowsColumnReorder="True">
      <GridViewColumn Header="Name"  DisplayMemberBinding="{Binding Name}" />
      <GridViewColumn Header="Price" DisplayMemberBinding="{Binding Price}" />
      <GridViewColumn Header="Stock" DisplayMemberBinding="{Binding Stock}" />
    </GridView>
  </ListView.View>
</ListView>
```
- **주의**: `GridViewColumn.Width="Auto"` 컬럼이 많고 템플릿이 무거우면 측정 비용 상승 → 고정 폭/공정한 폭 계산 로직 권장.

### 3.2 DataGrid
```xml
<DataGrid ItemsSource="{Binding Records}"
          EnableRowVirtualization="True"
          EnableColumnVirtualization="True"
          VirtualizingPanel.CacheLength="1,1"
          VirtualizingPanel.CacheLengthUnit="Page"
          VirtualizingStackPanel.VirtualizationMode="Recycling"
          ScrollViewer.CanContentScroll="True"
          VirtualizingPanel.IsVirtualizingWhenGrouping="True"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingPanel.ScrollUnit="Item"
          VirtualizingPanel.ScrollForced="True"
          VirtualizingPanel.IsContainerVirtualizable="True"
          SelectionUnit="FullRow"
          ColumnWidth="*" />
```
- DataGrid는 기본적으로 가상화가 좋지만, **행 상세(RowDetails)·그룹·동적 컬럼** 등에서 성능이 쉽게 떨어집니다.  
- **RowDetailsVisibilityMode="Collapsed"** 유지, 필요한 행만 열기.

### 3.3 TreeView (계층 가상화)
```xml
<TreeView ItemsSource="{Binding Nodes}"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling"
          VirtualizingPanel.IsVirtualizingWhenGrouping="True"
          ScrollViewer.CanContentScroll="True">
  <TreeView.ItemTemplate>
    <HierarchicalDataTemplate ItemsSource="{Binding Children}">
      <StackPanel Orientation="Horizontal" Margin="2">
        <TextBlock Text="{Binding Name}" />
      </StackPanel>
    </HierarchicalDataTemplate>
  </TreeView.ItemTemplate>
</TreeView>
```
- 확장된 가지만 가상화 대상. **대량 펼침**은 비용이 큼 → **검색/필터**로 펼침 범위를 제한.

---

## 4. 고급: 스크롤 모델 & 캐시 & 픽셀 스크롤

### 4.1 캐시 길이 튜닝
- 스크롤 속도가 빠르거나 템플릿이 무거우면 **프리페치**로 체감 지연을 줄임.
```xml
VirtualizingPanel.CacheLength="2,3"    <!-- 위 2, 아래 3 -->
VirtualizingPanel.CacheLengthUnit="Item" 
```
- 많은 프리페치는 메모리를 늘림. **측정/렌더 시간을 줄이는 선**에서 절충.

### 4.2 **픽셀 스크롤**에서도 가상화 쓰기
기본적으로는 **아이템 스크롤**에서만 가상화가 켜지지만, WPF 4.5 이후  
`VirtualizingPanel.ScrollUnit="Pixel"` 을 설정해 **픽셀 스크롤 + 가상화**가 가능합니다.

```xml
<ListBox
  ScrollViewer.CanContentScroll="True"
  VirtualizingPanel.ScrollUnit="Pixel"
  VirtualizingPanel.CacheLengthUnit="Pixel"
  VirtualizingPanel.CacheLength="200,400"  <!-- 위 200px, 아래 400px -->
  VirtualizingStackPanel.IsVirtualizing="True"
  VirtualizingStackPanel.VirtualizationMode="Recycling">
  <ListBox.ItemsPanel>
    <ItemsPanelTemplate>
      <VirtualizingStackPanel/>
    </ItemsPanelTemplate>
  </ListBox.ItemsPanel>
</ListBox>
```
- 이 설정은 **가변 높이 아이템**에서 스크롤 품질을 높일 때 유용.

### 4.3 컨테이너 정리 이벤트: `CleanUpVirtualizedItem`
가상화로 컨테이너를 버리거나 재활용하기 직전, 리소스/상태를 정리할 기회를 제공.

```xml
<ListBox
  VirtualizingStackPanel.IsVirtualizing="True"
  VirtualizingStackPanel.VirtualizationMode="Recycling"
  VirtualizingPanel.CleanUpVirtualizedItem="OnCleanUp">
  ...
</ListBox>
```

```csharp
private void OnCleanUp(object sender, CleanUpVirtualizedItemEventArgs e)
{
    // e.UIElement : 버려질 컨테이너
    // e.Value     : 해당 데이터 항목
    // 특정 항목은 버리지 않게 하려면:
    if (e.Value is MyItem item && item.IsPinned)
        e.Cancel = true;
}
```
- 선택 항목/편집 중인 항목 등은 **취소**하여 화면 밖으로 나가도 **컨테이너 유지** 가능(메모리 비용 증가 주의).

---

## 5. “무거운 템플릿”에서의 리사이클 패턴

**문제**: 재활용 시 이전 아이템의 **시각 상태/이벤트 핸들러**가 새 아이템으로 넘어가는 **누수**  
**원칙**:
- **상태는 전부 바인딩**에서 계산(체크박스, 강조 색 등)  
- 이벤트 핸들러는 **ItemContainerStyle** 수준에서 공통 처리(가능하면 `Command` 바인딩)  
- 템플릿 상태는 **VSM(VisualStateManager)** 나 **Triggers**로 선언적으로

### 5.1 ItemContainerStyle 예
```xml
<ListBox
  VirtualizingStackPanel.VirtualizationMode="Recycling">
  <ListBox.ItemContainerStyle>
    <Style TargetType="ListBoxItem">
      <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
      <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
      <EventSetter Event="MouseDoubleClick" Handler="OnOpenDetail"/>
      <!-- 시각 상태는 템플릿에서 바인딩으로 -->
    </Style>
  </ListBox.ItemContainerStyle>
</ListBox>
```

---

## 6. 그룹핑(GroupStyle)과 가상화

- **Grouping** 활성 시, 패널/템플릿 구성에 따라 **가상화가 꺼질 수 있습니다**.  
- 해결책:
  - `VirtualizingPanel.IsVirtualizingWhenGrouping="True"`
  - GroupStyle.Panel 에 **VirtualizingStackPanel** 사용
  - GroupHeader 템플릿을 **가볍게** 유지

```xml
<ListCollectionView x:Key="Grouped" Source="{Binding Items}">
  <!-- 코드에서 그룹 지정 -->
</ListCollectionView>

<ListView ItemsSource="{StaticResource Grouped}"
          VirtualizingPanel.IsVirtualizingWhenGrouping="True"
          ScrollViewer.CanContentScroll="True"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling">
  <ListView.GroupStyle>
    <GroupStyle>
      <GroupStyle.Panel>
        <ItemsPanelTemplate>
          <VirtualizingStackPanel/>
        </ItemsPanelTemplate>
      </GroupStyle.Panel>
      <GroupStyle.HeaderTemplate>
        <DataTemplate>
          <Border Background="#111827" Padding="6">
            <TextBlock Foreground="White" Text="{Binding Name}" FontWeight="SemiBold"/>
          </Border>
        </DataTemplate>
      </GroupStyle.HeaderTemplate>
    </GroupStyle>
  </ListView.GroupStyle>
</ListView>
```

---

## 7. Wrap/Uniform 레이아웃의 가상화

기본 `WrapPanel`/`UniformGrid`는 **가상화 미지원**.  
대량 타일 UI는 다음 대안을 사용:

- **VirtualizingWrapPanel**(서드파티/샘플 구현)  
- **Grid + ItemsControl** 을 **페이지네이션**으로 나누고 한 페이지만 렌더  
- **픽셀 스크롤 + 가상화**를 지원하는 **커스텀 VirtualizingPanel** 구현

> Wrap형 그리드가 필요하면 라이브러리(ModernWpf, GongSolutions, 등)의 `VirtualizingWrapPanel`을 검토.

---

## 8. 데이터 가상화(서버/스토리지 페이징)와의 결합

UI 가상화만으로는 **메모리**와 **네트워크** 비용을 줄일 수 없습니다.  
**데이터 가상화**를 포함하면 대규모 컬렉션에서도 쾌적:

- 화면이 **요청하는 범위만** 데이터 소스에서 로드  
- 스크롤 위치/요청 범위를 감지 → **비동기 페이지 로딩**  
- 간단한 패턴: **무한 스크롤 + 프리페치** (아이템 끝 근처에서 다음 페이지 가져오기)

### 8.1 간단 예(무한 스크롤 트리거)
```csharp
private async void OnScrollChanged(object sender, ScrollChangedEventArgs e)
{
    var sv = (ScrollViewer)sender;
    if (sv.VerticalOffset + sv.ViewportHeight >= sv.ExtentHeight - 100)
    {
        if (!IsLoading && HasMore)
            await LoadNextPageAsync();
    }
}
```
- 이때도 **UI 가상화**는 켜 두어 템플릿 비용 감소.

---

## 9. 성능 체크리스트 (현업 필수)

- [ ] `ScrollViewer.CanContentScroll="True"`  
- [ ] `ItemsPanel=VirtualizingStackPanel`  
- [ ] `VirtualizingStackPanel.IsVirtualizing="True"`  
- [ ] `VirtualizingStackPanel.VirtualizationMode="Recycling"`  
- [ ] `VirtualizingPanel.CacheLength(,Unit)` 으로 프리페치 조절  
- [ ] **픽셀 스크롤이 꼭 필요**하면 `VirtualizingPanel.ScrollUnit="Pixel"`  
- [ ] 템플릿은 **가볍게**, 상태는 **바인딩/VSM** 로직으로  
- [ ] 그룹핑/RowDetails/동적 컬럼 시 가상화 유지 여부 확인  
- [ ] 이미지 썸네일은 **지연 로딩 + 캐시**  
- [ ] `SnapsToDevicePixels`, `UseLayoutRounding="True"`로 재측정 떨림 감소  
- [ ] 불필요한 `UpdateLayout` 호출 금지  
- [ ] 대량 변경 전 **`DeferRefresh()`** 사용(뷰 갱신 한 번에)

---

## 10. 실전 템플릿 모음

### 10.1 초대용량 이미지 목록(픽셀 스크롤 + 프리페치)
```xml
<ListBox ItemsSource="{Binding Photos}"
         ScrollViewer.CanContentScroll="True"
         VirtualizingPanel.ScrollUnit="Pixel"
         VirtualizingPanel.CacheLengthUnit="Pixel"
         VirtualizingPanel.CacheLength="400,800"
         VirtualizingStackPanel.IsVirtualizing="True"
         VirtualizingStackPanel.VirtualizationMode="Recycling">
  <ListBox.ItemsPanel>
    <ItemsPanelTemplate>
      <VirtualizingStackPanel/>
    </ItemsPanelTemplate>
  </ListBox.ItemsPanel>

  <ListBox.ItemTemplate>
    <DataTemplate>
      <Border Margin="4" Padding="4" Background="{DynamicResource Palette.Card}">
        <Image Width="420" Stretch="Uniform" Source="{Binding LazyImage}"/>
      </Border>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
```

### 10.2 선택 항목은 버리지 않기
```xml
<ListView
  VirtualizingStackPanel.IsVirtualizing="True"
  VirtualizingStackPanel.VirtualizationMode="Recycling"
  VirtualizingPanel.CleanUpVirtualizedItem="OnCleanUp" />

// code-behind
private void OnCleanUp(object sender, CleanUpVirtualizedItemEventArgs e)
{
    // 선택 항목은 컨테이너 유지(편집 상태 보존)
    if (e.UIElement is ListViewItem lvi && lvi.IsSelected)
        e.Cancel = true;
}
```

### 10.3 TreeView 대량 노드(검색+부분 펼침)
```xml
<TreeView ItemsSource="{Binding FilteredNodes}"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling"
          ScrollViewer.CanContentScroll="True"/>
```
- **Filter**로 일치하는 경로만 확장하여 실제 가상화 대상 최소화.

---

## 11. 성능 분석 도구

- **WPF Performance Suite** (Visual Studio 확장)  
- **Perforator**: 프레임률/Dirty Rect/하드웨어 가속 등  
- **VisualTreeHelper, Snoop**: 시각 트리 확인, 컨테이너 생성 유무 관찰  
- 메모리 프로파일러(Visual Studio/JetBrains dotMemory 등)로 **컨테이너 수/바인딩 오브젝트** 확인

---

## 12. 흔한 함정 & 해결

**H1. 스크롤이 부드럽지 않다**  
- 템플릿이 무거움 → 가볍게/이미지 지연 로딩/프리페치 증가  
- 픽셀 스크롤 필요 → `VirtualizingPanel.ScrollUnit="Pixel"` + 적절한 `CacheLength`  

**H2. 가상화가 안 켜진다**  
- `ScrollViewer.CanContentScroll="False"`? → True로  
- `ItemsPanel`이 `VirtualizingStackPanel`이 아님? → 교체  
- `WrapPanel`/복잡 패널 사용? → 가상화 지원 패널로 변경 or VirtualizingWrapPanel 사용  
- Grouping/RowDetails로 꺼졌나? → 관련 스위치 켜고 템플릿 경량화

**H3. 리사이클 시 상태가 섞인다**  
- UI 상태는 **모델 바인딩**으로 표현, 템플릿은 상태를 바인딩(VSM/Triggers)  
- 이벤트 핸들러는 컨테이너 스타일에서 공통화, 아이템마다 구독/해제 남발 금지

**H4. 선택이 스크롤 중 풀린다**  
- 선택 상태를 **모델 두 방향 바인딩** (`IsSelected ↔ VM`)  
- 컨테이너 폐기 방지(`CleanUpVirtualizedItem.Cancel=true`) 또는 논리적 선택 모델로 복원

**H5. 불규칙 점프/깜빡임**  
- `SnapsToDevicePixels="True"`, `UseLayoutRounding="True"`  
- 픽셀 스크롤 시 `CacheLength` 확대, 이미지 해상도/디코딩 전략 조정

---

## 13. 미세 팁

- `Binding.IsAsync="True"`는 바인딩 지연으로 스크롤 끊김을 줄일 수도 있지만 과도 사용 금지.  
- `Freezable`(Brush/Geometry) 공유/Freeze로 템플릿 렌더 비용 감소.  
- `ItemContainerGenerator.StatusChanged`를 활용해 가상화/생성 타이밍에 맞춘 로직 배치.  
- **대량 추가/삭제** 전 `CollectionView.DeferRefresh()` 로 UI 반영 한 번에.

---

## 14. 결론

- WPF의 대용량 리스트/트리 성능은 **VirtualizingStackPanel + 리사이클 + 올바른 스크롤 모델**이 **절반 이상**을 좌우합니다.  
- 나머지 절반은 **템플릿 경량화**, **데이터 가상화**, **이미지/네트워크 지연 로딩**, **정확한 프리페치 튜닝**이 담당합니다.  
- 본문 템플릿과 체크리스트만 지켜도, 수만 개 항목에서도 “스크롤이 **빠르게** 반응하는” UX를 만들 수 있습니다.
