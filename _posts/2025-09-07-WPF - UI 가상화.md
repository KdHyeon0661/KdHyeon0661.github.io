---
layout: post
title: WPF - UI 가상화
date: 2025-09-07 22:25:23 +0900
category: WPF
---
# WPF UI 가상화 (VirtualizingStackPanel) 완전 가이드

WPF의 UI 가상화는 대량의 데이터를 효율적으로 표시하는 핵심 기술입니다. 이 가이드에서는 VirtualizingStackPanel을 중심으로 가상화의 개념부터 실전 적용까지 상세히 설명합니다.

## UI 가상화의 기본 개념

UI 가상화는 화면에 보이는 항목만 실제 UI 컨테이너(예: ListBoxItem, ListViewItem)를 생성하고, 화면 밖의 항목은 가상으로 처리하는 기술입니다. 이렇게 하면 메모리 사용량을 줄이고 레이아웃 계산, 데이터 바인딩, 템플릿 적용 비용을 크게 감소시켜 대용량 데이터 목록에서도 부드러운 스크롤링이 가능해집니다.

**데이터 가상화와의 차이점**
- UI 가상화: UI 요소 생성 및 렌더링 비용을 줄입니다
- 데이터 가상화: 데이터 자체의 로딩을 지연시켜 메모리 사용을 최적화합니다
실제 대규모 애플리케이션에서는 두 기술을 함께 사용하는 것이 효과적입니다.

## UI 가상화의 필수 조건

가상화가 제대로 동작하려면 세 가지 기본 조건을 충족해야 합니다:

```xml
<ListBox ItemsSource="{Binding LargeItemCollection}"
         ScrollViewer.CanContentScroll="True"  <!-- 항목 단위 스크롤 활성화 -->
         VirtualizingStackPanel.IsVirtualizing="True"  <!-- 가상화 활성화 -->
         VirtualizingStackPanel.VirtualizationMode="Recycling">  <!-- 재활용 모드 -->
    
    <!-- VirtualizingStackPanel을 ItemsPanel로 지정 -->
    <ListBox.ItemsPanel>
        <ItemsPanelTemplate>
            <VirtualizingStackPanel/>
        </ItemsPanelTemplate>
    </ListBox.ItemsPanel>
    
    <!-- 항목 템플릿 -->
    <ListBox.ItemTemplate>
        <DataTemplate>
            <StackPanel Orientation="Horizontal" Margin="8">
                <Image Source="{Binding Thumbnail}" Width="48" Height="48" Margin="0,0,8,0"/>
                <StackPanel>
                    <TextBlock Text="{Binding Title}" FontWeight="SemiBold"/>
                    <TextBlock Text="{Binding Description}" Foreground="#666"/>
                </StackPanel>
            </StackPanel>
        </DataTemplate>
    </ListBox.ItemTemplate>
</ListBox>
```

### 중요한 설정 옵션

1. **ScrollViewer.CanContentScroll="True"**
   - 항목 단위 스크롤을 활성화합니다
   - 기본값이 True인 경우가 많지만 명시적으로 설정하는 것이 좋습니다

2. **VirtualizingStackPanel.IsVirtualizing="True"**
   - 가상화를 명시적으로 활성화합니다

3. **VirtualizingStackPanel.VirtualizationMode="Recycling"**
   - Standard 모드: 화면 밖으로 나간 컨테이너를 완전히 제거
   - Recycling 모드: 컨테이너를 재활용하여 생성/삭제 비용 절감

## 가상화 옵션 상세 설명

### 캐시 설정 (Prefetching)

화면 밖의 항목을 미리 생성하여 스크롤 시 지연을 줄일 수 있습니다:

```xml
<ListBox VirtualizingPanel.CacheLengthUnit="Item"
         VirtualizingPanel.CacheLength="2,2">
    <!-- 위/아래 각 2개 항목을 미리 생성 -->
</ListBox>
```

CacheLengthUnit 옵션:
- **Item**: 항목 단위로 캐시 (일반적으로 사용)
- **Page**: 페이지 단위로 캐시
- **Pixel**: 픽셀 단위로 캐시

### 픽셀 단위 스크롤에서의 가상화

일반적으로 항목 단위 스크롤에서만 가상화가 작동하지만, WPF 4.5 이상에서는 픽셀 단위 스크롤에서도 가상화를 사용할 수 있습니다:

```xml
<ListBox ScrollViewer.CanContentScroll="True"
         VirtualizingPanel.ScrollUnit="Pixel"
         VirtualizingPanel.CacheLengthUnit="Pixel"
         VirtualizingPanel.CacheLength="200,400">
    <!-- 위 200px, 아래 400px 범위의 항목 미리 생성 -->
</ListBox>
```

이 설정은 가변 높이 항목이 있는 목록에서 유용합니다.

## 다양한 컨트롤의 가상화 설정

### ListView (GridView 포함)

```xml
<ListView ItemsSource="{Binding ProductList}"
          ScrollViewer.CanContentScroll="True"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling">
    
    <ListView.ItemsPanel>
        <ItemsPanelTemplate>
            <VirtualizingStackPanel/>
        </ItemsPanelTemplate>
    </ListView.ItemsPanel>
    
    <ListView.View>
        <GridView>
            <GridViewColumn Header="상품명" DisplayMemberBinding="{Binding Name}" Width="200"/>
            <GridViewColumn Header="가격" DisplayMemberBinding="{Binding Price}" Width="100"/>
            <GridViewColumn Header="재고" DisplayMemberBinding="{Binding Stock}" Width="80"/>
        </GridView>
    </ListView.View>
</ListView>
```

### DataGrid

DataGrid는 기본적으로 행 가상화가 활성화되어 있지만, 추가 설정을 통해 성능을 더욱 향상시킬 수 있습니다:

```xml
<DataGrid ItemsSource="{Binding LargeDataSet}"
          EnableRowVirtualization="True"
          EnableColumnVirtualization="True"
          VirtualizingPanel.CacheLength="1,1"
          VirtualizingStackPanel.VirtualizationMode="Recycling"
          ScrollViewer.CanContentScroll="True">
    
    <!-- 컬럼 정의 -->
    <DataGrid.Columns>
        <DataGridTextColumn Header="ID" Binding="{Binding Id}" Width="80"/>
        <DataGridTextColumn Header="이름" Binding="{Binding Name}" Width="200"/>
        <DataGridTextColumn Header="설명" Binding="{Binding Description}" Width="300"/>
    </DataGrid.Columns>
</DataGrid>
```

### TreeView

TreeView의 계층적 가상화는 확장된 노드만 실제로 생성됩니다:

```xml
<TreeView ItemsSource="{Binding TreeNodes}"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling"
          ScrollViewer.CanContentScroll="True">
    
    <TreeView.ItemTemplate>
        <HierarchicalDataTemplate ItemsSource="{Binding Children}">
            <StackPanel Orientation="Horizontal" Margin="2">
                <TextBlock Text="{Binding Name}" />
            </StackPanel>
        </HierarchicalDataTemplate>
    </TreeView.ItemTemplate>
</TreeView>
```

## 재활용 모드에서의 상태 관리 문제

재활용 모드에서는 컨테이너가 재사용되기 때문에 UI 상태가 예기치 않게 전달될 수 있습니다. 이를 방지하기 위한 방법:

### 바인딩을 통한 상태 관리

```xml
<ListBox.ItemContainerStyle>
    <Style TargetType="ListBoxItem">
        <!-- 선택 상태를 양방향 바인딩으로 관리 -->
        <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
        
        <!-- 시각적 상태는 트리거로 관리 -->
        <Style.Triggers>
            <Trigger Property="IsSelected" Value="True">
                <Setter Property="Background" Value="LightBlue"/>
            </Trigger>
        </Style.Triggers>
    </Style>
</ListBox.ItemContainerStyle>
```

### CleanUpVirtualizedItem 이벤트 활용

컨테이너가 재활용되기 전에 특별한 처리가 필요한 경우:

```xml
<ListBox VirtualizingStackPanel.IsVirtualizing="True"
         VirtualizingStackPanel.VirtualizationMode="Recycling"
         VirtualizingPanel.CleanUpVirtualizedItem="OnCleanUpVirtualizedItem">
</ListBox>
```

```csharp
private void OnCleanUpVirtualizedItem(object sender, CleanUpVirtualizedItemEventArgs e)
{
    // 편집 중인 항목이나 고정된 항목은 재활용 방지
    if (e.Value is MyItem item && (item.IsBeingEdited || item.IsPinned))
    {
        e.Cancel = true;  // 재활용 취소
    }
}
```

## 그룹화와 가상화의 결합

그룹화가 활성화된 경우 가상화가 자동으로 비활성화될 수 있습니다. 이를 방지하려면:

```xml
<ListView ItemsSource="{Binding GroupedData}"
          VirtualizingPanel.IsVirtualizingWhenGrouping="True"
          ScrollViewer.CanContentScroll="True"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling">
    
    <ListView.GroupStyle>
        <GroupStyle>
            <!-- 그룹 패널에도 가상화 사용 -->
            <GroupStyle.Panel>
                <ItemsPanelTemplate>
                    <VirtualizingStackPanel/>
                </ItemsPanelTemplate>
            </GroupStyle.Panel>
            
            <GroupStyle.HeaderTemplate>
                <DataTemplate>
                    <Border Background="#111827" Padding="8">
                        <TextBlock Foreground="White" 
                                   Text="{Binding Name}" 
                                   FontWeight="SemiBold"/>
                    </Border>
                </DataTemplate>
            </GroupStyle.HeaderTemplate>
        </GroupStyle>
    </ListView.GroupStyle>
</ListView>
```

## 성능 최적화 팁

### 1. 템플릿 최적화
- 불필요한 중첩 패널 제거
- 이미지는 필요한 때만 로드 (Lazy Loading)
- 복잡한 시각적 효과 최소화

### 2. 이미지 처리
```xml
<Image>
    <Image.Source>
        <BitmapImage UriSource="{Binding ImageUrl}"
                     DecodePixelWidth="200"  <!-- 실제 표시 크기로 디코딩 -->
                     CacheOption="OnLoad"/>  <!-- 캐싱 옵션 설정 -->
    </Image.Source>
</Image>
```

### 3. 레이아웃 설정
```xml
<ListBox UseLayoutRounding="True"
         SnapsToDevicePixels="True">
    <!-- 레이아웃 재계산 최소화 -->
</ListBox>
```

### 4. 데이터 바인딩 최적화
```xml
<TextBlock Text="{Binding Description, 
                  Mode=OneWay,  <!-- 읽기 전용인 경우 OneWay 사용 -->
                  UpdateSourceTrigger=PropertyChanged}"/>
```

## 일반적인 문제와 해결 방법

### 문제 1: 가상화가 작동하지 않음
**원인**: ScrollViewer.CanContentScroll="False"로 설정됨
**해결**: True로 변경하고 VirtualizingStackPanel 사용

### 문제 2: 스크롤이 부드럽지 않음
**원인**: 너무 무거운 항목 템플릿
**해결**: 템플릿 단순화, 이미지 최적화, 캐시 크기 증가

### 문제 3: 재활용 시 상태가 유지되지 않음
**원인**: UI 상태가 컨트롤에 직접 저장됨
**해결**: 모든 상태를 ViewModel에 저장하고 바인딩으로 관리

### 문제 4: 그룹화 시 성능 저하
**원인**: 그룹화로 인해 가상화 비활성화
**해결**: VirtualizingPanel.IsVirtualizingWhenGrouping="True" 설정

## 실제 적용 예제: 대용량 이미지 갤러리

```xml
<ListBox ItemsSource="{Binding PhotoCollection}"
         ScrollViewer.CanContentScroll="True"
         VirtualizingPanel.ScrollUnit="Pixel"
         VirtualizingPanel.CacheLengthUnit="Pixel"
         VirtualizingPanel.CacheLength="300,600"
         VirtualizingStackPanel.IsVirtualizing="True"
         VirtualizingStackPanel.VirtualizationMode="Recycling"
         UseLayoutRounding="True">
    
    <ListBox.ItemsPanel>
        <ItemsPanelTemplate>
            <VirtualizingStackPanel Orientation="Horizontal"/>
        </ItemsPanelTemplate>
    </ListBox.ItemsPanel>
    
    <ListBox.ItemTemplate>
        <DataTemplate>
            <Border Margin="4" Padding="4" Background="White">
                <!-- 지연 로딩을 위한 이미지 바인딩 -->
                <Image Width="200" Height="150" Stretch="Uniform">
                    <Image.Source>
                        <BitmapImage UriSource="{Binding ImagePath}"
                                     DecodePixelWidth="200"
                                     CacheOption="OnLoad"
                                     CreateOptions="DelayCreation"/>
                    </Image.Source>
                </Image>
            </Border>
        </DataTemplate>
    </ListBox.ItemTemplate>
</ListBox>
```

## 결론

WPF의 UI 가상화는 대용량 데이터를 효율적으로 표시하는 필수 기술입니다. VirtualizingStackPanel을 올바르게 구성하고, 재활용 모드를 활성화하며, 적절한 캐시 설정을 적용하면 수천, 수만 개의 항목에서도 부드러운 사용자 경험을 제공할 수 있습니다.

성공적인 구현을 위한 핵심 원칙은 다음과 같습니다:
1. 항상 ScrollViewer.CanContentScroll="True" 설정
2. VirtualizingStackPanel을 명시적으로 ItemsPanel로 지정
3. 재활용 모드(VirtualizationMode="Recycling") 사용
4. 항목 템플릿을 가능한 한 가볍게 유지
5. 모든 UI 상태를 ViewModel에 저장하고 바인딩으로 관리
6. 필요에 따라 캐시 크기를 조정하여 스크롤 성능 최적화

이러한 원칙을 준수하면 WPF 애플리케이션에서 대규모 데이터 집합을 효율적으로 처리할 수 있으며, 사용자에게 반응성이 뛰어난 인터페이스를 제공할 수 있습니다.