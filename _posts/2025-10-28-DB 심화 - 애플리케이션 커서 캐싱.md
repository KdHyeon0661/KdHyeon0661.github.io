---
layout: post
title: DB 심화 - 애플리케이션 커서 캐싱
date: 2025-10-28 22:25:23 +0900
category: DB 심화
---
# 애플리케이션 커서 캐싱(Application-side Statement/Cursor Caching)

> **핵심 한 줄**
> 애플리케이션 커서 캐싱(Statement Cache)은 **드라이버/애플리케이션 레벨**에서 **PreparedStatement/Command**를 재사용해 **파싱 왕복·서버 커서 오픈/클로즈 비용**을 없애준다.
> 서버의 **라이브러리 캐시/세션 커서 캐시**와 **서로 보완적**이며, **바인드 변수**와 함께 사용할 때 최대 효과.

---

## 왜 “애플리케이션 커서 캐싱”인가?

### 문제 배경

- OLTP/웹 요청은 **짧고 빈번**하며 **같은 SQL 템플릿**을 **값만 바꿔 반복**한다.
- 하지만 매 요청마다 드라이버가 `prepare → bind → execute → close` 를 반복하면:
  - **(서버) 파싱/검증** 왕복,
  - **(서버) 커서 오픈/클로즈** 오버헤드,
  - **(클라이언트) 오브젝트 생성/GC** 부담이 누적된다.

### 해결 개념

- **애플리케이션 커서 캐싱** = 드라이버가 **닫힌 PreparedStatement/Command를 캐시**해 다음 호출에서 **즉시 재사용**.
- 장점:
  1) **파싱 왕복 감소**(서버에도 파싱 요청이 덜 감),
  2) **오픈/클로즈 비용 절감**,
  3) **라이브러리 캐시 뮤텍스 경합 완화**(하드·소프트 파싱 감소의 간접 효과),
  4) **RT(응답시간) 저하** 및 **CPU 절감**.

> 애플리케이션 캐시는 **서버 밖**에서 동작하고, **서버의 세션 커서 캐시/라이브러리 캐시**와 **겹치지 않음**.
> 그러므로 “**클라이언트 Statement Cache + (서버) 세션 커서 캐시 + 바인드 변수**”의 **3중 재사용**이 베스트.

---

## 용어와 레이어 구분

| 레이어 | 이름 | 위치 | 목적 | 비고 |
|---|---|---|---|---|
| **클라이언트/드라이버** | **Statement Cache** | 애플리케이션 프로세스(또는 미들티어) | **닫힌 PreparedStatement/Command 재사용** | 본 문서 주제 |
| **서버/세션** | **Session Cursor Cache** | Oracle 서버(세션 로컬) | **닫힌 커서** 재사용(소프트 파싱 회피) | `SESSION_CACHED_CURSORS` |
| **서버/인스턴스** | **Library Cache** | Oracle Shared Pool | Parent/Child 커서 공유 | 바인드·커서 공유 핵심 |

**핵심 관계**
- 드라이버 Statement Cache가 **같은 SQL 템플릿**을 **같은 연결**에서 반복 호출 →
  서버는 **세션 커서 캐시**를 통해 **즉시 히트**할 확률↑ →
  결과적으로 **parse count (total/hard)** 감소와 **뮤텍스 대기** 완화.

---

## 드라이버별 설정 & 예제

> 아래 예제는 **실전에서 바로 붙여 볼 수 있는 최소 코드**를 제공한다.
> 공통 원칙: **바인드 변수 사용**, **SQL 템플릿 고정(주석·공백 랜덤화 금지)**, **연결 풀과 함께 사용**.

### Java — **JDBC (Oracle 드라이버)**
#### 풀 & Statement Cache 활성화

```java
// HikariCP + Oracle JDBC 예시 (Implicit Caching on)
HikariConfig cfg = new HikariConfig();
cfg.setJdbcUrl("jdbc:oracle:thin:@//dbhost:1521/ORCLPDB1");
cfg.setUsername("app");
cfg.setPassword("secret");
// 드라이버 힌트: 암시적 캐시/사이즈
cfg.addDataSourceProperty("oracle.jdbc.fanEnabled", "true"); // 선택
// 연결 후 속성 설정
HikariDataSource ds = new HikariDataSource(cfg);

try (Connection raw = ds.getConnection()) {
  // OracleConnection 캐스팅(드라이버 의존)
  oracle.jdbc.OracleConnection conn = raw.unwrap(oracle.jdbc.OracleConnection.class);
  conn.setImplicitCachingEnabled(true);
  conn.setStatementCacheSize(100); // 권장: 50~200에서 시작, 관측 기반 조정
}
```

#### 사용 코드(바인드 + 재사용)

```java
String sql = "SELECT /* app-cache */ SUM(amount) " +
             "FROM t_sales WHERE region = ? AND order_dt BETWEEN ? AND ?";
try (Connection raw = ds.getConnection()) {
  oracle.jdbc.OracleConnection conn = raw.unwrap(oracle.jdbc.OracleConnection.class);
  conn.setImplicitCachingEnabled(true);
  conn.setStatementCacheSize(100);

  for (int i=0; i<1000; i++) {
    String r = (i%3==0) ? "APAC" : (i%3==1) ? "EMEA" : "AMER";
    try (PreparedStatement ps = conn.prepareStatement(sql)) {
      ps.setString(1, r);
      ps.setDate(2, java.sql.Date.valueOf("2025-10-01"));
      ps.setDate(3, java.sql.Date.valueOf("2025-10-31"));
      try (ResultSet rs = ps.executeQuery()) { if (rs.next()) rs.getBigDecimal(1); }
    } // ps.close() → 캐시에 들어감 → 다음 prepare에서 즉시 히트
  }
}
```

> **포인트**
> - `ImplicitCachingEnabled + StatementCacheSize` 로 **닫힌 PreparedStatement**가 내부 LRU에 남는다.
> - 같은 SQL 템플릿으로 `prepare()` 호출 시 **즉시 반환**(파싱 왕복 회피).

---

### .NET — **ODP.NET (Oracle.ManagedDataAccess)**

#### 연결 & Statement Cache

```csharp
// 연결 문자열에 Statement Cache 사이즈 지정 or 코드에서 설정
var cs = "User Id=app;Password=secret;Data Source=ORCLPDB1;Statement Cache Size=100;";
using var conn = new OracleConnection(cs);
conn.Open();
// 필요 시: conn.StatementCacheSize = 100; // 코드에서 설정도 가능
```

#### Command 재사용 패턴

```csharp
using var cmd = conn.CreateCommand();
cmd.BindByName = true;
cmd.CommandText = "SELECT /* app-cache */ COUNT(*) FROM t_sales WHERE region=:r AND order_dt BETWEEN :d1 AND :d2";
cmd.Parameters.Add("r", OracleDbType.Varchar2);
cmd.Parameters.Add("d1", OracleDbType.Date);
cmd.Parameters.Add("d2", OracleDbType.Date);

for (int i=0; i<2000; i++) {
  cmd.Parameters["r"].Value = (i%3==0) ? "APAC" : (i%3==1) ? "EMEA" : "AMER";
  cmd.Parameters["d1"].Value = new DateTime(2025,10,1);
  cmd.Parameters["d2"].Value = new DateTime(2025,10,31);
  var n = Convert.ToInt32(cmd.ExecuteScalar());
  // Command.Dispose()하지 않고 루프 내 재사용 시 더 빠르며,
  // Dispose 후라도 Statement Cache에 의해 다음 생성 시 빠르게 회수 가능
}
```

> **팁**
> - ODP.NET은 **Statement Cache Size**가 0이 아니면, `OracleCommand`가 닫힐 때 **캐시에 보관**.
> - `BindByName=true`로 **바인드 일관성** 유지(순서 실수 방지).

---

### Python — **oracledb(cx_Oracle)**

#### 연결/풀 & 캐시

```python
import oracledb
pool = oracledb.create_pool(user="app", password="secret",
                            dsn="dbhost/orclpdb1",
                            min=4, max=32, increment=2)
with pool.acquire() as conn:
    conn.stmtcachesize = 100  # 기본값보다 넉넉히
    with conn.cursor() as cur:
        sql = "SELECT /* app-cache */ SUM(amount) FROM t_sales WHERE region=:r AND order_dt BETWEEN :d1 AND :d2"
        for i in range(1000):
            r = ("APAC","EMEA","AMER")[i%3]
            cur.execute(sql, r=r, d1=oracledb.Date(2025,10,1), d2=oracledb.Date(2025,10,31))
            cur.fetchone()
```

> **동작**
> - `stmtcachesize` 만큼 드라이버가 **문장 핸들**을 캐시한다.
> - 같은 SQL 템플릿으로 `execute()` 시 **재준비 비용 회피**.

---

### Node.js — **node-oracledb**

```js
const oracledb = require('oracledb');

async function run() {
  const pool = await oracledb.createPool({
    user: 'app', password: 'secret', connectString: 'dbhost/orclpdb1',
    poolMin: 4, poolMax: 32, poolIncrement: 2,
    stmtCacheSize: 100 // 중요!
  });

  const conn = await pool.getConnection();
  const sql = `SELECT /* app-cache */ COUNT(*) FROM t_sales
               WHERE region=:r AND order_dt BETWEEN :d1 AND :d2`;
  for (let i=0;i<2000;i++) {
    const r = (i%3===0) ? 'APAC' : (i%3===1) ? 'EMEA' : 'AMER';
    const res = await conn.execute(sql, { r, d1: new Date('2025-10-01'), d2: new Date('2025-10-31') });
    // res.rows[0][0]
  }
  await conn.close();
  await pool.close(0);
}
run();
```

---

### Go — **godror (Go Oracle driver)**

```go
import (
  "context"
  "database/sql"
  _ "github.com/godror/godror"
)

func run() error {
  // 연결 문자열 예: "user/pass@dbhost/orclpdb1?stmt_cache_size=100"
  db, err := sql.Open("godror", "user=app password=secret connectString=dbhost/orclpdb1 stmt_cache_size=100")
  if err != nil { return err }
  defer db.Close()

  ctx := context.Background()
  stmt, err := db.PrepareContext(ctx, "SELECT /* app-cache */ SUM(amount) FROM t_sales WHERE region=:1 AND order_dt BETWEEN :2 AND :3")
  if err != nil { return err }
  defer stmt.Close()

  for i:=0; i<1000; i++ {
    r := []string{"APAC","EMEA","AMER"}[i%3]
    var sum sql.NullFloat64
    if err = stmt.QueryRowContext(ctx, r, "2025-10-01", "2025-10-31").Scan(&sum); err != nil {
      return err
    }
  }
  return nil
}
```

> **메모**: 드라이버마다 옵션 이름이 조금씩 다를 수 있으니 실제 환경의 드라이버 문서를 확인해 사이즈 파라미터를 맞춘다.

---

## 올바른 사용 패턴(핵심 체크리스트)

1) **바인드 변수**로 **텍스트 동일성**을 확보(리터럴 금지).
2) **SQL 템플릿 고정**: 주석/공백/힌트/컬럼 순서 랜덤화 금지.
3) **연결 풀** 사용 시, **같은 풀/같은 연결**에서 반복 호출될 가능성이 높아 **캐시 효율↑**.
4) 캐시 사이즈는 **50~200**에서 출발 → **지표 기반 점진 조정**.
5) **DDL/통계 변경**이 잦은 시점엔 캐시된 문장이 **무효화**될 수 있으므로 배포/통계 수집 **윈도우링**.
6) NLS/세션 파라미터가 **동일**하도록 풀/세션 초기화(세션 태깅/콜백) — Child 폭증 방지.

---

## 성능 측정 & 진단

### 서버 측 지표(참고용)

```sql
-- 세션(나)의 파싱/세션 커서 캐시 히트
SELECT sn.name, ss.value
FROM   v$sesstat ss JOIN v$statname sn ON sn.statistic#=ss.statistic#
WHERE  ss.sid = SYS_CONTEXT('USERENV','SID')
AND    sn.name IN ('parse count (total)','parse count (hard)','session cursor cache hits');

-- 시스템 지표
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('parse count (total)','parse count (hard)','parse time elapsed','session cursor cache hits');
```
> **기대**: 애플리케이션 Statement Cache 활성 후, **parse count**가 줄고, **session cursor cache hits**가 늘어나는 경향.

### 애플리케이션 측 지표

- **레이턴시**(평균/95/99), **TPS/RPS**, **GC/할당량**(JVM/.NET), **CPU 사용률**을 비교.
- **JDBC/ODP.NET** 일부 드라이버는 캐시 히트를 노출(로깅/진단 레벨) — 환경에 맞게 켠다.

### XPLAN로 간접 확인

- 동일 SQL의 **`parse calls` 가 감소**하고, 실행계획은 동일하게 유지되는지 확인.
- (캐시 히트가 높으면) **라이브러리 캐시 관련 대기**(`library cache: mutex X/S`, `cursor: pin S wait on X`) 샘플이 줄어든다.

---

## 사이즈 산정과 튜닝 절차

1) **현황 파악**:
   - 애플리케이션 레벨에서 “**세션당 반복 사용하는 서로 다른 SQL 템플릿 수**” 추정.
   - 너무 다양한 템플릿이라면 템플릿 **정규화**부터.
2) **초기값 결정**: 50~200 (OLTP/웹), 배치는 낮게 시작.
3) **점진 인상**: 50 → 100 → 150 … 단계적으로 조정.
4) **효과 검증**: 파싱 지표·응답시간·CPU/뮤텍스 대기 변화를 비교.
5) **상한 제어**: 캐시가 너무 커지면 **메모리** 사용량과 **LRU 효율** 저하 → **적정선**에서 고정.

---

## 장애/함정 패턴 & 해법

### 텍스트 변형으로 **캐시 미스 연속**

- **증상**: 같은 의미의 쿼리인데 텍스트가 미묘하게 다름. 매번 캐시 미스.
- **원인**: ORM/템플릿 엔진이 **주석/공백/컬럼 순서**를 매 호출 생성.
- **해법**: **SQL 템플릿 고정**. 값은 **바인드**로만 넣기.

### 세션 상태(NLS/ROLE/optimizer) 차이

- **증상**: 같은 텍스트인데 Child가 늘고, 때때로 재파싱.
- **원인**: 연결 풀에서 **서로 다른 세션 상태**가 섞임.
- **해법**: **세션 태깅/콜백**으로 상태를 표준화(예: NLS_DATE_FORMAT, TIME_ZONE 등).

### DDL/통계 변경 직후 지연

- **증상**: 배포/통계 수집 후 잠시 파싱/재컴파일 증가.
- **원인**: 서버 커서 **무효화** → 클라이언트 캐시에 남아 있어도 **다시 준비 필요**.
- **해법**: **저부하 시간**에 변경, 대규모는 **분산/순차** 적용.

### Statement Cache가 **과소/과대**

- **과소**: 캐시 히트 낮음, parse 여전. → **점진 인상**.
- **과대**: 메모리 증가, LRU 효율 저하, 보관만 하고 못 쓰는 엔트리↑. → **축소**.

### 바인드 타입/길이 불일치

- **증상**: Child 분기 증가, 캐시 재사용률↓.
- **해법**: **바인드 타입 고정**(예: VARCHAR2 vs NVARCHAR2 혼용 금지), **길이 일관화**.

### 커서 누수(클라이언트)

- **증상**: `Open Cursors` 증가, ORA-01000.
- **원인**: `Close()`/`Dispose()` 누락, 반복 `prepare()`만 수행.
- **해법**: `try-with-resources`/`using`/`defer Close()` 패턴 준수.
- **참고**: Statement Cache는 “**닫힌** 문장”만 캐시한다. 열어둔 커서는 누수 위험.

---

## 배치/리포트에서의 전략

- 배치 작업은 보통 **적은 수의 커서를 오래 유지**해 실행하므로, Statement Cache 이득은 상대적으로 작다.
- 대신 **바인드 + 세션 커서 캐시**가 더 중요하고, **플랜 안정화(SPM)**, **정렬/해시 워크에어리어 튜닝**이 효과적.

---

## RAC/멀티 인스턴스 고려

- Statement Cache는 **연결 단위**. 다른 인스턴스 노드로 라우팅되면 **별도 캐시**.
- **커넥션 핀/세션 어피니티**(e.g., Transaction Affinity)를 쓰면 같은 세션에 머물 확률↑ → 캐시 효율↑.

---

## 작은 실험: Statement Cache On/Off 비교(개념 데모)

### 기준 쿼리

```sql
SELECT /* app-cache-measure */ COUNT(*) FROM t_sales
WHERE region=:r AND order_dt BETWEEN :d1 AND :d2
```

### 시나리오

1) **Statement Cache Size=0** (비활성)로 1만 회 호출 → RT/CPU/parse 지표 수집
2) **Statement Cache Size=100** (활성)로 동일 호출 → 지표 비교

### 서버 측 관찰(참고)

```sql
-- 같은 세션에서 before/after 비교
SELECT sn.name, ss.value
FROM   v$sesstat ss JOIN v$statname sn ON sn.statistic#=ss.statistic#
WHERE  ss.sid = SYS_CONTEXT('USERENV','SID')
AND    sn.name IN ('parse count (total)','parse count (hard)','session cursor cache hits');
```
> **기대**: 활성화 후 `parse count` 감소 경향, `session cursor cache hits` 증가 경향, 애플리케이션 RT 단축.

---

## 운영 체크리스트(요약)

- [ ] **바인드 변수** 전면 적용 (SQL 템플릿 고정)
- [ ] **드라이버 Statement Cache** 활성 & **사이즈 50~200**에서 관측 기반 조정
- [ ] **서버 `SESSION_CACHED_CURSORS`** 도 적정(50~200)으로 병행
- [ ] **연결 풀** 사용 + **세션 상태 표준화**(태깅/콜백)
- [ ] 배포/통계 수집은 **저부하 시간 + 순차 적용**
- [ ] **파싱 지표/뮤텍스 대기/RT** 꾸준 모니터링
- [ ] 커서 누수 방지(`close/dispose/defer`) 규율화

---

## 결론

- **애플리케이션 커서 캐싱**은 **첫 번째 파싱 이후 반복 호출 비용**을 크게 없애는 **가성비 높은 최적화**다.
- **바인드 변수**와 **서버 세션 커서 캐시**를 함께 쓰면 **파싱/경합/RT**를 동시에 줄인다.
- 효과는 **지표로 검증**하되, **텍스트 동일성/세션 상태 일관성**을 확보하지 않으면 빛이 바래진다.
- **작게 시작 → 관찰 → 점진 조정**이 정석. 문제는 대부분 **텍스트 변형**과 **세션 혼재**에서 온다.

> **한 줄 요약**
> “**바인드 + 템플릿 고정 + 애플리케이션 Statement Cache + 세션 커서 캐시**”를 기본기로 삼으면,
> **파싱 지옥**은 끝나고 시스템은 **조용히 빠르게** 돌아간다.
