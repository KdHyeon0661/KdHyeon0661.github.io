---
layout: post
title: 객체지향설계 - 책임 분배
date: 2025-07-20 22:20:23 +0900
category: 객체지향설계
---
# 책임 분배 (Responsibility Assignment)

다음은 **책임 분배(Responsibility Assignment)**에 대한 상세 설명입니다.  
소프트웨어 설계 단계에서 책임 분배는 객체지향 설계의 핵심 활동 중 하나이며, 클래스와 객체가 “무엇을 해야 하는지”를 결정하는 과정입니다.  

---

## 1. 책임 분배란 무엇인가?
**책임 분배(Responsibility Assignment)**는  
시스템이 수행해야 하는 기능(기능적 요구사항)과 비기능적 요구사항을 적절한 클래스나 객체에 **역할과 책임**으로 나누어 할당하는 설계 활동입니다.  

- **책임(Responsibility)**: 객체가 수행해야 하는 행동(메서드) 또는 관리해야 하는 정보(데이터)  
- **분배(Assignment)**: 이 책임을 가장 적합한 클래스나 객체에 배정하는 행위  

> 즉, “이 기능은 누가 담당할 것인가?”라는 질문에 답하는 단계입니다.

---

## 2. 책임의 두 가지 유형
책임은 크게 **행동적 책임**과 **정보적 책임**으로 나눌 수 있습니다.

| 책임 유형 | 설명 | 예시 |
|-----------|------|------|
| 행동적 책임 (Doing Responsibility) | 객체가 직접 수행하는 행위, 다른 객체와의 협력 요청, 계산 수행 등 | 결제 요청 처리, 주문 상태 변경, 데이터 검증 |
| 정보적 책임 (Knowing Responsibility) | 객체가 보유하거나 관리하는 데이터와 그 상태를 아는 것 | 사용자 이름, 주문 내역, 계좌 잔액 |

---

## 3. 책임 분배의 목적
1. **명확한 역할 정의**  
   - 클래스와 객체가 수행해야 하는 일을 명확히 구분해 중복과 혼동을 방지  
2. **재사용성 증가**  
   - 잘 정의된 책임은 다른 프로젝트에서도 재사용 가능  
3. **유지보수성 향상**  
   - 책임이 명확히 나뉘어 있으면 변경이 필요한 부분을 빠르게 파악 가능  
4. **결합도 낮추기**  
   - 책임을 잘 분배하면 객체 간 의존성을 줄일 수 있음  
5. **응집도 높이기**  
   - 유사한 책임을 묶어 높은 응집도를 유지  

---

## 4. 책임 분배의 주요 원칙과 기법

### (1) GRASP 패턴
책임 분배를 체계적으로 하기 위해 **GRASP(General Responsibility Assignment Software Patterns)** 원칙이 사용됩니다.

| GRASP 패턴 | 설명 |
|------------|------|
| **Information Expert** | 해당 책임을 수행하는 데 필요한 정보를 가장 많이 가진 객체에 책임을 부여 |
| **Creator** | 어떤 객체를 생성해야 하는 책임을 갖는 클래스 선정 |
| **Controller** | 시스템 이벤트를 처리하는 역할의 객체를 할당 |
| **Low Coupling** | 객체 간 결합도를 최소화하는 책임 분배 |
| **High Cohesion** | 객체 내부 책임을 응집도 높게 묶음 |
| **Polymorphism** | 타입별로 다른 동작을 다형성으로 처리 |
| **Pure Fabrication** | 결합도와 응집도를 높이기 위해 인위적으로 만든 클래스 |
| **Indirection** | 두 객체 사이의 직접적인 의존성을 줄이기 위해 중간 객체 사용 |
| **Protected Variations** | 변경 가능성이 있는 부분을 인터페이스나 추상화로 감싸서 보호 |

---

### (2) 책임 분배 시 고려 사항
1. **누가 가장 잘 아는가? (정보 전문가 원칙)**  
   → 데이터와 가장 밀접한 객체에게 책임을 부여  
2. **결합도 최소화**  
   → 다른 객체에 불필요하게 의존하지 않도록  
3. **응집도 극대화**  
   → 서로 관련 있는 기능과 데이터는 같은 객체에  
4. **변경 용이성 확보**  
   → 미래의 변경을 대비하여 책임을 모듈화  
5. **역할의 명확성**  
   → 객체의 이름만 보고도 역할을 유추할 수 있어야 함  

---

## 5. 예시 시나리오

### 요구사항
> "사용자가 온라인 쇼핑몰에서 상품을 주문하고 결제할 수 있다."

### 책임 분배 예
| 클래스 | 책임 |
|--------|------|
| `User` | 사용자 정보 조회, 주문 요청 |
| `Order` | 주문 생성, 주문 상태 관리 |
| `Product` | 상품 정보 제공, 재고 확인 |
| `PaymentProcessor` | 결제 요청 처리, 결제 결과 반환 |

📌 **분석**  
- 주문 생성은 `Order` 클래스에 맡김 (주문과 관련된 데이터와 상태를 가장 잘 알고 있으므로 → 정보 전문가 원칙)  
- 결제 처리는 `PaymentProcessor`가 담당 (결제 로직은 별도의 책임으로 분리하여 응집도 향상)  

---

## 6. 책임 분배와 객체 협력
책임이 나뉜 후, 객체들은 **메시지**를 통해 협력합니다.  
예:  
```plaintext
User → Order : createOrder(productList)
Order → PaymentProcessor : processPayment(paymentInfo)
```
이렇게 책임이 명확하면 시스템 전체 흐름이 명료해지고, 유지보수가 쉬워집니다.

---

## 7. 잘못된 책임 분배의 문제점
- **한 객체가 너무 많은 책임을 가짐 (God Object)** → 응집도 저하, 결합도 증가  
- **관련 없는 책임이 섞임** → 코드 가독성과 유지보수성 저하  
- **중복 책임** → 버그 발생 가능성 증가  
- **변경에 취약** → 한 부분 수정 시 연쇄적으로 다른 부분이 깨짐  

---

## 8. 결론
책임 분배는 **객체지향 설계 품질의 절반 이상**을 좌우하는 핵심 활동입니다.  
GRASP 원칙, 결합도/응집도 고려, 정보 전문가 패턴 등을 활용해 책임을 올바르게 분배하면 **유연하고 확장 가능한 시스템**을 만들 수 있습니다.
