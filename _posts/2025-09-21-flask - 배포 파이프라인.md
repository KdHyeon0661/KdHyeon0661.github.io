---
layout: post
title: flask - 배포 파이프라인
date: 2025-09-21 18:25:23 +0900
category: flask
---
# 16. 배포 파이프라인

> 이 장은 **WSGI 서버(Gunicorn/uWSGI) + Nginx 리버스 프록시**, **Docker/Compose 멀티-스테이지 빌드/이미지 최적화**, **Kubernetes(Deployment/ConfigMap/Secret/Ingress/HPA)**, **무중단 배포(롤링·블루-그린·카나리)**, **DB 마이그레이션 자동화**를 **운영 실전** 기준으로 끝까지 풀어쓴다.  
> 모든 코드는 ``` 로 감싸며, 수식이 필요하면 $$...$$ 로 표기한다(이 장은 수식이 거의 없다).

---

## 16.1 운영 아키텍처 개요

- **앱 계층**: Flask → WSGI 서버(**Gunicorn/uWSGI**)  
- **프록시 계층**: **Nginx(또는 클라우드 LB)** — TLS 종료, 정적 캐시, 압축, WebSocket 프록시  
- **컨테이너**: **Docker** — 멀티-스테이지 빌드, 런타임 최소화, non-root  
- **오케스트레이션**: **Kubernetes** — Deployment/Service/Ingress/HPA/Config/Secret  
- **배포 전략**: 롤링, **블루-그린**, **카나리** + **DB 마이그레이션 자동화**  
- **CI/CD**: 빌드 → 테스트 → 보안 스캔 → 푸시 → 쿠버 배포(헬름/쿠스톰) → 점진적 릴리즈

---

## 16.2 WSGI 서버: Gunicorn/uWSGI

### 16.2.1 Gunicorn 기본

```bash
gunicorn "wsgi:app" \
  --bind 0.0.0.0:8000 \
  --workers 2 \
  --threads 8 \
  --keep-alive 5 \
  --max-requests 5000 --max-requests-jitter 500
```

**권장값 가이드(초기)**  
- CPU 바운드 적음(일반 웹): `-w 2 * CPU`, `--threads 4~8`  
- 외부 I/O 많음: `-k gthread` 또는 `-k gevent`(비동기), `--worker-connections 1000`(gevent)  
- 메모리 누수 방지: `--max-requests` + `--max-requests-jitter`

`gunicorn.conf.py` 예:

```python
import multiprocessing

bind = "0.0.0.0:8000"
workers = max(2, multiprocessing.cpu_count())
worker_class = "gthread"   # 또는 "gevent"
threads = 8
keepalive = 5
timeout = 60
graceful_timeout = 30
max_requests = 5000
max_requests_jitter = 500
accesslog = "-"
errorlog = "-"
loglevel = "info"
forwarded_allow_ips = "*"
proxy_allow_ips = "*"
```

### 16.2.2 uWSGI 기본

```bash
uwsgi --module wsgi:app \
      --http-socket 0.0.0.0:8000 \
      --processes 2 --threads 8 \
      --vacuum --die-on-term \
      --buffer-size 65535 \
      --harakiri 60 --harakiri-verbose
```

`uwsgi.ini`:

```ini
[uwsgi]
module = wsgi:app
http-socket = 0.0.0.0:8000
processes = 2
threads = 8
die-on-term = true
vacuum = true
buffer-size = 65535
harakiri = 60
static-map = /static=/app/static  ; (필요시)
route = ^/healthz/live break:200  ; 초경량 라이브니스
```

> **Gunicorn vs uWSGI**: Gunicorn이 단순하고 Pythonic. uWSGI는 기능 풍부(ini 많음). 선택은 팀 선호와 운영 경험에 따른다.

---

## 16.3 Nginx 리버스 프록시

### 16.3.1 기본 프록시 설정

```
# /etc/nginx/conf.d/app.conf
upstream app_upstream {
  server 127.0.0.1:8000;  # Gunicorn/uWSGI
  keepalive 64;
}

server {
  listen 80;
  server_name example.com;

  # TLS 종료는 server 블록을 :443 + ssl로 구성 (생략 가능)
  # include snippets/ssl-*.conf;

  client_max_body_size 50m;                # 업로드 제한
  proxy_read_timeout 60s;
  proxy_connect_timeout 5s;
  proxy_send_timeout 60s;

  # 정적 파일 (가능하면 CDN에)
  location /static/ {
    alias /app/static/;
    expires 7d;
    add_header Cache-Control "public, max-age=604800, immutable";
  }

  location / {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_pass http://app_upstream;
  }

  # WebSocket (Flask-SocketIO 등)
  location /socket.io/ {
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_pass http://app_upstream;
    proxy_read_timeout 600s;
  }
}
```

### 16.3.2 압축/캐시/보안 헤더

```
gzip on;
gzip_comp_level 5;
gzip_min_length 1024;
gzip_types text/plain text/css application/json application/javascript application/xml;
gzip_vary on;

add_header X-Frame-Options "SAMEORIGIN" always;
add_header X-Content-Type-Options "nosniff" always;
add_header Referrer-Policy "no-referrer-when-downgrade" always;
add_header Permissions-Policy "geolocation=()" always;
```

> **Tip**: Brotli가 가능하면 켜되, **정적 사전압축(.br)** 을 CI에서 만들어 Nginx `brotli_static on;` 사용.

---

## 16.4 Docker/Compose — 멀티-스테이지, 최적화, 보안

### 16.4.1 멀티-스테이지 Dockerfile (pip)

```dockerfile
# syntax=docker/dockerfile:1.6
FROM python:3.11-slim AS base
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1

# ---- builder: wheels ----
FROM base AS builder
RUN apt-get update && apt-get install -y --no-install-recommends build-essential gcc libpq-dev \
 && rm -rf /var/lib/apt/lists/*
WORKDIR /build
COPY pyproject.toml poetry.lock* requirements*.txt* ./
# (poetry 사용 시) RUN pip install poetry && poetry export -f requirements.txt -o req.txt
COPY . .
RUN pip wheel --no-deps --wheel-dir /wheels .

# ---- runtime ----
FROM base AS runtime
# 런타임에 필요한 OS 패키지 최소 설치
RUN apt-get update && apt-get install -y --no-install-recommends \
      libpq5 curl ca-certificates \
 && rm -rf /var/lib/apt/lists/*
WORKDIR /app
# 비루트 사용자
RUN useradd -m appuser
COPY --from=builder /wheels /wheels
RUN pip install --no-deps /wheels/* \
 && rm -rf /wheels
COPY . .
USER appuser
ENV PORT=8000 \
    GUNICORN_CMD_ARGS="--workers=2 --threads=8 --bind=0.0.0.0:8000"
EXPOSE 8000
CMD ["gunicorn", "wsgi:app"]
```

**핵심 포인트**  
- **wheels 캐시**로 빌드 재사용 ↑  
- 런타임 이미지 **슬림화**(컴파일러 제거)  
- **non-root** 사용자  
- `ENV GUNICORN_CMD_ARGS`로 **런타임 튜닝 주입**  
- `HEALTHCHECK` 를 추가하면 Compose/K8s 외 환경에서 유용

### 16.4.2 이미지 크기 최적화 팁
- `.dockerignore` 에 불필요한 파일 제외(venv, tests, .git 등)  
- Alpine은 glibc 이슈/빌드 복잡성 → **slim** 추천(대부분의 팀)  
- 멀티-스테이지로 **컴파일 타임 deps** 제거  
- **레이어 캐시**: **의존성 파일 먼저 복사** → 코드 변경 시 전체 재빌드 방지

`.dockerignore` 예:

```
.git
__pycache__/
*.pyc
venv/
.env
.mypy_cache/
tests/
docs/
```

### 16.4.3 docker-compose 로컬 스택

```yaml
# docker-compose.yml
version: "3.9"
services:
  web:
    build: .
    image: myapp:web
    ports: ["8000:8000"]
    environment:
      - APP_ENV=production
      - DATABASE_URL=postgresql://app:app@db:5432/app
      - REDIS_URL=redis://cache:6379/0
    depends_on: [db, cache]
  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=app
      - POSTGRES_USER=app
      - POSTGRES_PASSWORD=app
    volumes: [dbdata:/var/lib/postgresql/data]
  cache:
    image: redis:7-alpine
volumes:
  dbdata: {}
```

> **로컬**: compose로 “애플리케이션 + DB + 캐시”를 손쉽게 띄워 통합 테스트/데모에 사용.

---

## 16.5 Kubernetes — 핵심 리소스 설계

### 16.5.1 ConfigMap/Secret

```yaml
# k8s/config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  APP_ENV: "production"
  GUNICORN_WORKERS: "2"
  GUNICORN_THREADS: "8"
---
apiVersion: v1
kind: Secret
metadata:
  name: app-secret
type: Opaque
stringData:
  DATABASE_URL: postgresql://app:app@postgres.default.svc:5432/app
  SECRET_KEY: "please-change"
```

> **운영**: Secret은 git에 평문 보관 금지. **SealedSecrets / External Secrets** / KMS 연동을 고려.

### 16.5.2 Deployment/Service

```yaml
# k8s/deploy.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-web
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 0     # 무중단
  selector:
    matchLabels: { app: myapp, tier: web }
  template:
    metadata:
      labels: { app: myapp, tier: web }
      annotations:
        # preStop 훅 반영 시간을 위한 드레인(아래 lifecycle 참고)
        prometheus.io/scrape: "true"
        prometheus.io/port: "8000"
    spec:
      terminationGracePeriodSeconds: 30
      containers:
        - name: web
          image: myrepo/myapp:web-2025-10-20
          imagePullPolicy: IfNotPresent
          ports: [{containerPort: 8000}]
          envFrom:
            - configMapRef: {name: app-config}
            - secretRef: {name: app-secret}
          env:
            - name: PORT
              value: "8000"
          resources:
            requests: { cpu: "200m", memory: "256Mi" }
            limits:   { cpu: "500m", memory: "512Mi" }
          readinessProbe:
            httpGet: { path: /healthz/ready, port: 8000 }
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 1
            failureThreshold: 3
          livenessProbe:
            httpGet: { path: /healthz/live, port: 8000 }
            initialDelaySeconds: 10
            periodSeconds: 10
          lifecycle:
            preStop:
              exec:
                command: ["/bin/sh","-c","sleep 5"]  # Nginx/LB 연결 드레인
---
apiVersion: v1
kind: Service
metadata:
  name: myapp-web
spec:
  selector: { app: myapp, tier: web }
  ports:
    - port: 80
      targetPort: 8000
      protocol: TCP
  type: ClusterIP
```

> **무중단 핵심**: `maxUnavailable: 0` + **readinessProbe** + **preStop**(연결 드레인) + **Graceful shutdown**(Gunicorn `--graceful-timeout`).

### 16.5.3 Ingress(NGINX Ingress Controller)

```yaml
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
    nginx.ingress.kubernetes.io/enable-websocket: "true"
spec:
  tls:
    - hosts: [example.com]
      secretName: tls-cert   # cert-manager로 자동 발급 가능
  rules:
    - host: example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service: { name: myapp-web, port: { number: 80 } }
```

> **TLS**: cert-manager + ACME로 자동화. `ClusterIssuer` 구성 후 Ingress에 annotation 추가.

### 16.5.4 HPA(오토스케일)

```yaml
# k8s/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: myapp-web
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp-web
  minReplicas: 3
  maxReplicas: 20
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
```

> **고급**: Prometheus Adapter로 **요청 지연/에러율** 기반 스케일(외부 지표)을 구성할 수 있다.

---

## 16.6 무중단 배포 전략

### 16.6.1 롤링 업데이트 (기본)

- `RollingUpdate` + `maxUnavailable: 0` → **항상 가용 인스턴스 유지**  
- 새 버전 Pod 준비(ready) 후 이전 버전 Pod 제거

체크포인트:
- 앱이 **SIGTERM** 을 받고 **graceful shutdown** (요청 처리 후 종료)  
- DB 세션/큐 워커는 **안전 종료**(preStop 에서 drain)  
- **마이그레이션 순서**(아래 16.8)

### 16.6.2 블루-그린

- **Blue(현재)** 와 **Green(새 버전)** 을 **동시에 띄움**
- 서비스 라우팅(Selector/Ingress)을 **한 번에 전환**
- 빠른 롤백 용이(다시 Blue로 스위치)

구성 예(요약):
- `Deployment myapp-web-blue`, `Deployment myapp-web-green`  
- `Service myapp-web` 의 `selector` 를 blue↔green 로테이션

### 16.6.3 카나리

- `Deployment myapp-web` + `Deployment myapp-web-canary`  
- Ingress(NGINX) 또는 서비스메시(Istio/Linkerd)로 **가중치 트래픽** 분배(예: 5% → 25% → 50% → 100%)  
- 에러율/지연/KPI 모니터링으로 승격/중단 판단

Istio VirtualService 예(개념):

```yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata: { name: myapp }
spec:
  hosts: ["example.com"]
  http:
    - route:
        - destination: { host: myapp-web, subset: stable, port: { number: 80 } , weight: 95 }
        - destination: { host: myapp-web, subset: canary, port: { number: 80 } , weight: 5 }
```

---

## 16.7 앱 레벨 무중단 팁

- **SIGTERM 핸들링**: Gunicorn graceful timeout 내에 종료되도록 긴 작업은 큐로 넘기기  
- **Readiness**: DB 다운/의존성 실패 시 **ready=fail** 로 트래픽 제외  
- **Sticky 세션** 피하기(가능하면 세션을 서버 외 저장: Redis)  
- **마이그레이션과 코드 호환**: 롤링 중 **옛/새 코드가 동시에 동작**할 수 있어야 함(16.8)

---

## 16.8 마이그레이션 자동화(Alembic/Flask-Migrate)

### 16.8.1 원칙

- **마이그레이션은 배포 파이프라인의 일부**  
- 롤링 시에는 **호환 가능한 스키마**로 이동:  
  1) **Additive** 변경(컬럼 추가) → 코드 신규 컬럼 읽기/쓰기 **옵셔널**  
  2) 코드 배포  
  3) **삭제/리네임 등 파괴적 변경**은 **후속 릴리즈**에서 진행

### 16.8.2 쿠버네티스 Job로 자동 실행

```yaml
# k8s/migrate-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: myapp-migrate-20251020
spec:
  backoffLimit: 1
  template:
    spec:
      restartPolicy: Never
      containers:
        - name: migrate
          image: myrepo/myapp:web-2025-10-20
          envFrom:
            - configMapRef: { name: app-config }
            - secretRef: { name: app-secret }
          command: ["flask","db","upgrade"]   # Flask-Migrate 커맨드
```

**배포 순서**  
1) Job 실행(마이그레이션) → 성공  
2) `Deployment` 업데이트(롤링 시작)  
3) 관측(에러율/latency) → 완료

> **Helm** 사용 시 `helm.sh/hook: pre-upgrade` 로 Job을 **프리 훅**으로 지정 가능.

### 16.8.3 InitContainer / PostStart 대안

- **initContainer로 마이그레이션**: 단일 Pod에만 의미, 롤링 전체에는 적합 X  
- **postStart hook**: 실패 시 앱 시작 실패 → **가용성 저하** 위험  
- **권장**: **별도 Job** 으로 실행

---

## 16.9 CI/CD 파이프라인 설계

### 16.9.1 스테이지

1) **단위/통합 테스트** + **커버리지**  
2) **SAST/Dependency 스캔**(pip-audit, trivy)  
3) **Docker 빌드**(멀티-스테이지) + 이미지 스캔  
4) **푸시**(GHCR/ECR/GCR)  
5) **쿠버 배포**(Helm/Kustomize) — **롤링/카나리/블루-그린**  
6) **DB 마이그레이션 Job**(pre)  
7) **헬스/메트릭 검증/자동 롤백 규칙**(Argo Rollouts 등)

### 16.9.2 GitHub Actions 예

```yaml
# .github/workflows/deploy.yml
name: deploy
on:
  push:
    branches: [ main ]
jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: {python-version: "3.11"}
      - run: pip install -r requirements-dev.txt
      - run: pytest --cov=app --cov-report=xml
      - uses: aquasecurity/trivy-action@0.20.0
        with: {scan-type: "fs", severity: "CRITICAL,HIGH"}

  docker:
    needs: build-test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: docker build -t ghcr.io/org/myapp:${{ github.sha }} .
      - run: echo $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin
      - run: docker push ghcr.io/org/myapp:${{ github.sha }}

  k8s-deploy:
    needs: docker
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: azure/setup-kubectl@v4
      - name: k8s context
        run: |
          echo "${KUBE_CONFIG}" > kubeconfig
          export KUBECONFIG=$PWD/kubeconfig
          kubectl version
      - name: run migration job
        run: |
          sed -e "s|myrepo/myapp:web-2025-10-20|ghcr.io/org/myapp:${{ github.sha }}|" k8s/migrate-job.yaml | kubectl apply -f -
          kubectl wait --for=condition=complete --timeout=180s job/myapp-migrate-20251020 || (kubectl logs job/myapp-migrate-20251020 && exit 1)
      - name: rolling deployment
        run: |
          sed -e "s|myrepo/myapp:web-2025-10-20|ghcr.io/org/myapp:${{ github.sha }}|" k8s/deploy.yaml | kubectl apply -f -
          kubectl rollout status deploy/myapp-web --timeout=180s
```

---

## 16.10 정적 자산/미디어 배포

- **정적 빌드**(Webpack/Vite) → **hash 파일명** → **CDN 업로드**  
- 앱은 **/static/** 를 프록시/캐시하도록 Nginx 설정(10장 참조)  
- 사용자 업로드는 **오브젝트 스토리지(S3)** + **서명 URL** (13장)

---

## 16.11 관측 가능성(운영 필수 연계)

- **로깅**: JSON 구조화, **request_id**(11장)  
- **메트릭**: `/metrics` Prometheus, **레디니스/라이브니스**(11장)  
- **트레이싱**(OTel): 릴리즈 마다 trace_id/log 상관 (10~11장)

배포 중 체크:
- `5xx rate`, `latency p95/p99`, `HPA scale` 반응, `error budget` 소비 추세

---

## 16.12 보안/규정 준수

- **이미지 스캔**(trivy/grype) + **취약 패키지 업데이트**  
- **런타임 보안**: non-root, read-only root fs(가능 시), drop capabilities  
- **시크릿 관리**: KMS/External Secrets, 환경 변수 최소 노출  
- **네트워크**: 네임스페이스/NetworkPolicy(외부 DB에만 허용), WAF  
- **릴리즈 서명**: SBOM 생성/서명(조직 정책에 따라)

`securityContext` 예:

```yaml
securityContext:
  runAsUser: 10001
  runAsGroup: 10001
  runAsNonRoot: true
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop: ["ALL"]
```

---

## 16.13 실전 체크리스트

- [ ] WSGI 튜닝(워커/스레드/타임아웃/그레이스풀)  
- [ ] Nginx 프록시(헤더/WS/압축/캐시/업로드)  
- [ ] 컨테이너 최적화(멀티-스테이지, non-root, .dockerignore)  
- [ ] Compose 로컬 통합 스택  
- [ ] K8s: Deployment/Service/Ingress/Config/Secret/HPA/Probes  
- [ ] 무중단: `maxUnavailable=0` / readiness / preStop / SIGTERM 처리  
- [ ] 배포 전략: 롤링 → 블루-그린/카나리 확장  
- [ ] 마이그레이션: **Job 프리 훅** + **Additive-First** 방침  
- [ ] CI/CD: 테스트/스캔/빌드/푸시/배포 자동화  
- [ ] 관측: 로그/메트릭/트레이스 + 자동 롤백 기준  
- [ ] 보안: 이미지/런타임/시크릿/네트워크/권한 최소화

---

## 16.14 붙여넣기 퀵스타터

### 16.14.1 `wsgi.py`

```python
from app import create_app
app = create_app("production")

if __name__ == "__main__":
    app.run()
```

### 16.14.2 `gunicorn.conf.py` (요약)

```python
bind = "0.0.0.0:8000"
worker_class = "gthread"
workers = 2
threads = 8
timeout = 60
graceful_timeout = 30
max_requests = 5000
max_requests_jitter = 500
accesslog = "-"
errorlog = "-"
```

### 16.14.3 Dockerfile (요약)

```dockerfile
FROM python:3.11-slim AS builder
WORKDIR /build
COPY . .
RUN pip wheel --wheel-dir /wheels .

FROM python:3.11-slim
WORKDIR /app
RUN useradd -m appuser
COPY --from=builder /wheels /wheels
RUN pip install --no-deps /wheels/* && rm -rf /wheels
COPY . .
USER appuser
EXPOSE 8000
CMD ["gunicorn","wsgi:app"]
```

### 16.14.4 K8s Deployment (요약)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: myapp-web }
spec:
  replicas: 3
  selector: { matchLabels: { app: myapp } }
  template:
    metadata: { labels: { app: myapp } }
    spec:
      containers:
        - name: web
          image: myrepo/myapp:latest
          ports: [{containerPort: 8000}]
          readinessProbe:
            httpGet: { path: /healthz/ready, port: 8000 }
          livenessProbe:
            httpGet: { path: /healthz/live, port: 8000 }
```

---

## 16.15 마무리

이 장에서는 Flask 프로덕션의 **표준 배포 파이프라인**을 시작부터 끝까지 구성했다.

- **WSGI + Nginx** 로 안정적 HTTP/WS 처리,
- **Docker 멀티-스테이지** 로 이미지 슬림화와 보안,
- **Kubernetes** 로 설정/시크릿/스케일/네트워킹 표준화,
- **무중단 배포**(롤링/블루-그린/카나리)와 **DB 마이그레이션 Job** 자동화,
- **CI/CD** 로 테스트/스캔/배포를 일관되게.
