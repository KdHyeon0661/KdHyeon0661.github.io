---
layout: post
title: 정보보안기사 - SSL/TLS
date: 2025-11-12 11:25:23 +0900
category: 정보보안기사
---
# SECTION 05 네트워크 보안 프로토콜 — 02. SSL/TLS

## TLS란 무엇인가: 목적·버전·용어

TLS(Transport Layer Security)는 **기밀성·무결성·상호 인증**을 제공하는 표준 프로토콜이다. 최신 표준은 **TLS 1.3**이며, 핸드셰이크와 암호모듈을 대폭 단순화했다. **TLS 1.0/1.1은 공식 폐기(Deprecated)** 되었고, **DTLS 1.3**은 UDP 환경용이다.

- **핸드셰이크(Handshake)**: 키 교환·알고리즘 협상·서버/클라이언트 인증
- **레코드 계층(Record)**: 애플리케이션 데이터를 **AEAD**(GCM/ChaCha20-Poly1305)로 보호
- **세션 재개/0-RTT**: TLS 1.3의 PSK 기반 재개 및 선택적 **0-RTT**(재전송/재생 위험 관리 필요)
- **DTLS 1.3**: 손실·재정렬 환경(VoIP/WebRTC/QUIC 일부 구성요소)에서 TLS 1.3과 동등 수준의 보안 보장(순서 보호/비재생성만 예외)

> 정책 참고: **BCP 195bis (RFC 9325)** 는 안전한 TLS/DTLS 사용 권고의 최신판이다. 실무 지침의 최상위 근거로 참조한다.

---

## 암호 스위트·키 교환·곡선/키 길이 권고
### TLS 1.3에서의 단순화

TLS 1.3은 **고정 RSA·static DH**를 제거하고 **(EC)DHE + AEAD + SHA-2**만 허용한다. 권장 스위트:
- `TLS_AES_128_GCM_SHA256`
- `TLS_AES_256_GCM_SHA384`
- `TLS_CHACHA20_POLY1305_SHA256`
모두 **순방향 보안(PFS)** 을 제공한다.

### 키 교환 곡선

- **X25519** 또는 **P-256** 우선. 상호운용·성능·보안 균형이 좋다. (NIST 가이드/BCP 195bis도 이와 정합)

---

## 인증서·PKI·HSTS·OCSP(운영 관점)
### 공개 신뢰 인증서 운용 상식

- **유효기간**: 2025-11-11 기준 공용 TLS 서버 인증서 최대 **398일**. CA/B 포럼은 2026~2029년 단계적으로 **47일**까지 단축 예정(일정 확정). 자동화(ACME) 전제를 강화한다.
- **검증 데이터 재사용**(도메인/아이피 등): 기존 398일 → 향후 10일 등 대폭 단축 일정 포함(승인된 SC-081v3). 운영 프로세스에 반영할 것.

### HSTS(HTTP Strict Transport Security)

- 응답 헤더 `Strict-Transport-Security`로 “HTTPS만 허용”을 강제하여 SSL Stripping 방지. 프리로드 정책 고려.
```http
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
```

### SNI·OCSP 스테이플링·Must-Staple

- **SNI**: 하나의 IP에 다수 도메인 호스팅 시 서버 선택. TLS 확장(RFC 6066).
- **OCSP 스테이플링**: 서버가 최신 OCSP 응답을 **스테이플**하여 브라우저의 별도 OCSP 질의를 줄이고 프라이버시/성능 향상.
- **Must-Staple**: 인증서에 **TLS Feature(1.3.6.1.5.5.7.1.24)** 를 넣어 “항상 스테이플링”을 강제. 실패 시 연결 거절 기대. 운영 난이도 높으므로 사전 검증 필수.

> 메모: **TLS 1.0/1.1은 역사적(Historic)/Deprecated** 상태이며, 서버·클라이언트 모두 기본 비활성화 권고(Windows도 순차적 기본 비활성화 공지).

---

## & 레코드 계산
### TLS 1.3 핸드셰이크 요약

1. **ClientHello**(지원 버전/스위트/키공유/SNI/ALPN/OCSP 요청 등)
2. **ServerHello**(스위트/키공유 수락) → **(EC)DHE**로 공유 비밀 산출
3. **EncryptedExtensions** / (서버)증명서 / **CertificateVerify**
4. **Finished** 후 애플리케이션 데이터 전송(옵션: 0-RTT)


### 레코드 크기 개념(수식)

TLS 1.3 AEAD에서 레코드 페이로드(평문) 길이를 \(L\)라 하면, 전송 레코드 대략:
$$
\text{RecordSize} \approx L + \text{AEAD\_TAG}(16) + \text{ContentType}(1) + \text{Padding}(0\sim)
$$

---

## 서버 소프트웨어별 “안전한 기본값” 템플릿
### NGINX(HTTP/1.1·2·3)

```nginx
# /etc/nginx/conf.d/ssl.conf

ssl_protocols TLSv1.3;                       # TLS 1.2를 유지해야 한다면 'TLSv1.2 TLSv1.3'
ssl_prefer_server_ciphers off;               # TLS1.3은 고정 스위트
ssl_ciphers TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256;
ssl_ecdh_curve X25519:P-256;
ssl_session_timeout  10m;
ssl_session_cache    shared:SSL:50m;

# OCSP Stapling

ssl_stapling on;
ssl_stapling_verify on;
resolver 1.1.1.1 8.8.8.8 valid=300s;

# HSTS

add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

# HTTP/2 & HTTP/3(QUIC)

listen 443 ssl http2;         # HTTP/2
listen 443 http3 reuseport;   # HTTP/3(QUIC, OpenSSL/Quic 패키지 필요)
```
HTTP/3는 **QUIC 전송 + TLS 1.3**을 사용한다(애플리케이션은 HTTP/3, 전송은 QUIC, 보안은 TLS1.3).

### Apache httpd (mod_ssl)

```apache
# ssl.conf

SSLProtocol             TLSv1.3
SSLCipherSuite          TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256
SSLOpenSSLConfCmd       Curves X25519:P-256

# OCSP Stapling

SSLUseStapling          on
SSLStaplingResponderTimeout 5
SSLStaplingReturnResponderErrors off
SSLStaplingCache        shmcb:/var/run/ocsp(128000)

# HSTS

Header always set Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
```

### HAProxy(TCP/HTTP 프록시)

```haproxy
global
  ssl-default-bind-options no-sslv3 no-tlsv10 no-tlsv11
  ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
  ssl-default-bind-curves X25519:P-256

frontend fe_https
  bind :443 ssl crt /etc/haproxy/certs/example.pem alpn h2,http/1.1
  http-response set-header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
  default_backend be_app
```

---

## 클라이언트/애플리케이션 코드 보안 설정 예시
### Python (requests + mTLS)

```python
import requests

# 서버 인증(기본 verify=True). 사설 CA라면 verify="/path/to/ca_bundle.pem"

r = requests.get("https://example.com/api", timeout=5)
print(r.status_code)

# mTLS: 클라이언트 인증서/키 제공

r = requests.get(
    "https://mtls.example.com",
    cert=("/etc/ssl/client.crt", "/etc/ssl/client.key"),
    timeout=5,
)
```

### Go (http.Client TLS 1.3 강제, Root CA 고정)

```go
package main

import (
  "crypto/tls"
  "crypto/x509"
  "io/ioutil"
  "net/http"
  "time"
)

func main() {
  // 신뢰 루트 구성(사설 CA 사용 시)
  roots := x509.NewCertPool()
  ca, _ := ioutil.ReadFile("/etc/ssl/private/ca.pem")
  roots.AppendCertsFromPEM(ca)

  tr := &http.Transport{
    TLSClientConfig: &tls.Config{
      MinVersion: tls.VersionTLS13,
      RootCAs:    roots,
      // mTLS: ClientCAs/Certificates 설정 가능
    },
  }
  c := &http.Client{Transport: tr, Timeout: 5 * time.Second}
  resp, _ := c.Get("https://example.com")
  defer resp.Body.Close()
}
```

### Java (JSSE, TLS 1.3, ALPN)

```java
import javax.net.ssl.*;
import java.security.KeyStore;

SSLContext ctx = SSLContext.getInstance("TLSv1.3");
ctx.init(null, null, null);
SSLSocketFactory sf = ctx.getSocketFactory();
try (SSLSocket s = (SSLSocket) sf.createSocket("example.com", 443)) {
    s.startHandshake();
    System.out.println(s.getSession().getProtocol()); // TLSv1.3
}
```

### .NET (HttpClientHandler)

```csharp
var handler = new HttpClientHandler {
    SslProtocols = System.Security.Authentication.SslProtocols.Tls13
};
using var http = new HttpClient(handler) { Timeout = TimeSpan.FromSeconds(5) };
var resp = await http.GetAsync("https://example.com");
```

---

## 진단·검증 도구 사용법(핸즈온)
### OpenSSL s_client

```bash
# 서버 체인/스테이플링/ALPN 확인

openssl s_client -connect example.com:443 -servername example.com -tls1_3 -status -alpn h2 -showcerts
```
- 출력에서 `OCSP Response Status: successful` 확인(스테이플링).
- `Protocol  : TLSv1.3` / `Cipher    : TLS_AES_128_GCM_SHA256` 확인.

### curl

```bash
# TLS1.3 강제 및 스위트 지시(지원 구현에서만 가능)

curl -I --tlsv1.3 --ciphers TLS_AES_128_GCM_SHA256 https://example.com
```

### Wireshark 필터

```
tls.handshake.type == 1        # ClientHello
tls.handshake.type == 2        # ServerHello
tls.handshake.extensions_server_name
tls.handshake.extensions.status_request
```

---

## 구성 실수(미스컨피그)와 점검 체크리스트
### 필수 차단/권고

- **TLS 1.0/1.1 비활성화**: 서버/클라 정책에서 완전히 차단. 규제/표준 준수 측면에서도 요구됨.
- **구식 스위트 금지**: RSA key exchange, CBC, RC4, 3DES, NULL/EXPORT 스위트 금지. (BCP 195bis)
- **서버 체인 완결성**: 중간 CA 누락 방지, AIA/OCSP 접근성 테스트.

### 인증서·정책

- **만료 관리 자동화(ACME)**: 398일→47일 일정에 대비하여 자동 갱신 파이프라인이 필수이다.
- **HSTS**: `includeSubDomains; preload` 적용 전 **서브도메인 HTTPS 커버리지** 완비 여부 점검.
- **OCSP 스테이플링**: CDN/리버스프록시 앞단에서 스테이플링 활성화, 상위 장비가 응답을 유지하도록 캐시 만료/리프레시 전략 수립.
- **Must-Staple 선택적 채택**: 미흡한 인프라에서는 가용성 리스크. 사전 리허설 후 도입.

### 애플리케이션

- **세션 쿠키**: `Secure; HttpOnly; SameSite=Lax(or Strict)` 설정, HSTS와 병행.
- **0-RTT 데이터 사용 시**: 재생 방지 토큰/Idempotent 엔드포인트만 허용(로그/추적 필요).

---

## mTLS(상호 인증)·API 보안 패턴

- **mTLS**는 클라이언트가 인증서를 제시해 서버가 신원 확인. API·B2B 백엔드에서 광범위 사용.
- OAuth 2.0 환경에서는 **RFC 8705**로 액세스 토큰을 **클라이언트 인증서에 바인딩**해 탈취/재사용을 억제.

**NGINX mTLS 예시**
```nginx
server {
  listen 443 ssl;
  ssl_certificate     /etc/ssl/certs/server.crt;
  ssl_certificate_key /etc/ssl/private/server.key;

  ssl_client_certificate /etc/ssl/ca/clients_ca.pem; # 신뢰할 클라이언트 CA
  ssl_verify_client on;                               # mTLS 강제

  location / {
    proxy_pass http://app;
  }
}
```

---

## 동향(개념 소개)

- SNI는 평문 노출되므로 도메인 노출 문제. **ECH(Encrypted Client Hello)** 가 이를 해소하기 위한 작업으로 진행 중(BCP 195bis도 “작업 중 기술”로 언급). 배포는 점진적이며 인프라 호환성 고려 필요.

---

## HTTP/3와 TLS 1.3

- **HTTP/3는 QUIC 위에서 동작**하고, **QUIC은 TLS 1.3**을 사용하여 키 교환/암호화를 수행한다. 기존 TCP/TLS 스택과 다르게 전송계층 자체가 QUIC으로 대체됨.

---

## 운영 시나리오: “레거시 TLS 폐지 + 자동 발급/갱신 + 가시성”
### 목표

1) TLS1.0/1.1 완전 차단, 2) TLS1.3 우선, 3) 인증서 자동화(ACME), 4) HSTS/OCSP 스테이플링, 5) 로그/헬스체크.

### 실행 절차(예)

1. **자산 스캔**: zgrab/sslyze로 모든 443/STARTTLS 자산 목록화
2. **정책 반영**: 로드밸런서/프록시부터 TLS1.0/1.1 비활성화
3. **인증서 자동화**: Let’s Encrypt/ACME 클라이언트 배치, 만료 30일 전 롤링
4. **HSTS 및 스테이플링**: 단계적 적용 후 Canary 트래픽으로 모니터링
5. **관측성**: 핸드셰이크 오류율, OCSP 실패율, 인증서 잔여일수 대시보드
6. **감사**: 분기별 BCP 195bis/NIST 체크리스트로 재점검

---

## 취약 구성 점검 스크립트(샘플)
### 호출

```bash
pip install sslyze
python - <<'PY'
from sslyze import ServerNetworkLocationViaDirectConnection, Scanner, ServerScanRequest, ScanCommand
loc = ServerNetworkLocationViaDirectConnection(hostname="example.com", port=443)
scanner = Scanner()
req = ServerScanRequest(server_location=loc, scan_commands={
    ScanCommand.TLS_1_0_SUPPORTED, ScanCommand.TLS_1_1_SUPPORTED,
    ScanCommand.TLS_1_2_CIPHER_SUITES, ScanCommand.TLS_1_3_CIPHER_SUITES,
    ScanCommand.CERTIFICATE_INFO, ScanCommand.OCSP_STAPLING
})
for res in scanner.get_results([req]):
    print(res.scan_result)
PY
```

### OpenSSL로 Must-Staple 확인(참고)

```bash
# 확인

openssl x509 -in server.crt -noout -text | grep -A3 "TLS Feature"
```
(해당 OID는 RFC 7633 규정)

---

## 규정·표준 참조(배경 문서)

- **TLS 1.3**(RFC 8446) ― 최신 프로토콜 정의, 1.2/5077/5246 등 대체/업데이트 관계 포함.
- **DTLS 1.3**(RFC 9147) ― UDP용 보안.
- **Deprecated: TLS 1.0/1.1**(RFC 8996).
- **BCP 195bis**(RFC 9325) ― 안전한 TLS/DTLS 사용 권고 최신판.
- **TLS 확장: SNI/OCSP**(RFC 6066), **OCSP 다중 스테이플링**(RFC 6961), **Must-Staple**(RFC 7633).
- **HSTS**(RFC 6797).
- **CA/B 포럼 BRs**: 유효기간 398일 및 향후 단축 일정(SC-081v3).

---

## 실전 Q&A(예상 실기 포인트)

**Q1. “TLS 1.0/1.1 차단”을 왜 요구하나?**
A. 알려진 설계 한계(취약 스위트·모드, 다운그레이드 위험)와 **RFC 8996**의 폐기 권고에 따라 규정/업계 표준이 차단을 요구한다.

**Q2. TLS 1.3에서 권장 스위트만 남긴 이유?**
A. 과거 옵션으로 인한 취약 구성 가능성을 줄이고, **(EC)DHE + AEAD + SHA-2** 조합을 표준화하여 상호운용성·보안을 높였다.

**Q3. HSTS 프리로드 시 유의점?**
A. 프리로드는 되돌리기 어렵다. 서브도메인 전체 HTTPS 보장과 리다이렉션 루프/서브시스템 예외가 없는지 선검증.

**Q4. Must-Staple을 당장 적용해도 되나?**
A. OCSP 인프라 미성숙 시 가용성 장애를 유발할 수 있다. Canary → 점진 확대 전략 권장.

**Q5. 공용 인증서 유효기간이 왜 짧아지나?**
A. 키 롤테이션 주기 단축·위기 반응 속도 제고·자동화 촉진 목적. **2026~2029 단계적 47일** 일정 반영 필요.

---

## 최종 점검 체크리스트(운영용)

- [ ] **프로토콜**: TLS1.3 우선, TLS1.2 허용(레거시 호환), 1.0/1.1 완전 차단(서버/클라 정책)
- [ ] **스위트/곡선**: AES-GCM/ChaCha20-Poly1305 + X25519/P-256, RSA KeyExchange·CBC·RC4·3DES 제거
- [ ] **인증서**: 만료 ≤398일, 자동 갱신 파이프라인(ACME). 2026~2029 단축 일정 로드맵 수립
- [ ] **체인/신뢰**: 중간 CA 포함, AIA/CRL/OCSP 접근성 확인
- [ ] **OCSP**: 스테이플링 on, 옵저버빌리티(실패율/지연) 모니터링
- [ ] **HSTS**: `max-age ≥ 6개월`, `includeSubDomains`, 프리로드는 사전검증 후 적용
- [ ] **mTLS(API)**: 필요 시 클라이언트 CA·CRL 관리, RFC 8705(OAuth 바인딩) 고려
- [ ] **HTTP/3**: QUIC/TLS1.3 지원 LB/프록시 버전 확인, 혼용기간 이중 스택 운영
- [ ] **로깅/모니터링**: 핸드셰이크 실패 코드·스테이플링 실패·만료 임박 수치 대시보드
- [ ] **침해대응**: 키 유출 시 즉시 폐지/재발급(단축 유효기간·오토메이션이 복구시간 단축)

---

## 미니 실습: 셀프 점검 to-do

1) `openssl s_client -status`로 OCSP 스테이플링 여부 확인
2) `sslyze`로 프로토콜/스위트/체인 검사
3) 운영 프록시/웹서버에 **HSTS** 삽입, 2주 Canary 후 `max-age` 연장
4) ACME 갱신 실패 알람(웹훅/Slack) 설정
5) 분기마다 **RFC 9325 체크리스트**로 정책 갱신

---

## 결론

TLS는 “켜놓으면 안전”이 아닌 **지속 운영**의 기술이다. 최신 표준(**TLS 1.3/DTLS 1.3**), 업계 권고(**BCP 195bis**), 정책(**HSTS/OCSP**), **CA/B의 수명 단축 로드맵**을 동시 반영해야, 성능·가용성·보안을 모두 만족한다. 본 문서의 설정 템플릿과 점검 체크리스트를 베이스라인으로 삼아 환경별로 세부 조정하라.
