---
layout: post
title: Elixir - 슈퍼바이저와 워커
date: 2025-11-20 20:25:23 +0900
category: Elixir
---
# 슈퍼바이저와 워커

## 슈퍼바이저와 워커의 역할

### 슈퍼바이저가 실제로 하는 일

슈퍼바이저는 **업무 로직 자체를 수행하지 않는다**. 대신 다음 네 가지에 집중한다.

1. **자식 프로세스 시작**
   - 워커(GenServer/GenStage/Task.Supervisor 등), 혹은 **서브 슈퍼바이저**를 시작한다.
   - 시작 순서가 중요할 수 있으므로 **children 리스트의 순서**를 통해 제어한다.

2. **자식 감시(Monitoring)**
   - 자식이 종료되면 **exit 신호**를 감지한다.
   - 종료 이유가 `:normal`인지, 예외로 크래시했는지, `:shutdown`인지에 따라 **재시작 여부**를 결정한다.

3. **재시작(Restart)**
   - 재시작 전략(`:one_for_one`, `:rest_for_one`, `:one_for_all`)에 따라,
     어떤 자식들을 다시 띄울지 선택한다.
   - 재시작 강도(`max_restarts`, `max_seconds`)를 넘어서면 **자기 자신도 포기하고 종료**한다.

4. **실패 격리(Failure Isolation)**
   - 한 자식이 터져도 **다른 자식은 최대한 유지**한다.
   - 트리를 계층화하여 “**어디까지 같이 죽어야 하는지**”를 제어한다.

반대로 **워커(GenServer 등)**는 다음에 집중한다.

- **도메인 로직** (예: 주문 처리, 캐시 관리, Job 실행, 세션 관리 등)
- **상태 관리** (메모리 내 상태, ETS 핸들, 파일 핸들 등)
- **요청/응답 프로토콜** 구현 (call/cast/info 콜백)

요약하면:

- **슈퍼바이저**: “이 프로세스들이 언제 태어나고, 언제 죽고, 어떻게 다시 태어날지”를 책임지는 **수명주기 관리자**
- **워커**: “실제로 무슨 일을 할지”를 책임지는 **업무 담당자**

---

### 가장 작은 예: 카운터를 감시하는 슈퍼바이저

먼저 **아주 단순한 워커 + 슈퍼바이저**를 통해 재시작을 눈으로 확인해보자.

```elixir
defmodule Counter do
  use GenServer

  # Public API
  def start_link(opts),
    do: GenServer.start_link(__MODULE__, :ok, opts)

  def bump(pid),
    do: GenServer.call(pid, :bump)

  # Callbacks
  @impl true
  def init(:ok), do: {:ok, 0}

  @impl true
  def handle_call(:bump, _from, n) do
    # 3 이상이면 의도적으로 크래시
    if n >= 3 do
      raise "boom at #{n}"
    end

    {:reply, n + 1, n + 1}
  end
end
```

이제 이 워커를 감시하는 슈퍼바이저:

```elixir
defmodule App.Supervisor do
  use Supervisor

  def start_link(opts \\ []),
    do: Supervisor.start_link(__MODULE__, :ok, opts)

  @impl true
  def init(:ok) do
    children = [
      {Counter, name: Counter}  # 워커
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end
end
```

IEx에서:

```elixir
{:ok, _sup} = App.Supervisor.start_link(name: App.Supervisor)

Counter.bump(Counter)  # 1
Counter.bump(Counter)  # 2
Counter.bump(Counter)  # 3
Counter.bump(Counter)  # 여기서 예외 → 워커 크래시 → 슈퍼바이저가 재시작

Counter.bump(Counter)  # 다시 1부터 시작 (상태 리셋)
```

관찰 포인트:

- `Counter`는 단순히 “숫자를 올리다가, 3 이후에는 크래시하는” 로직만 가진다.
- **슈퍼바이저는 전혀 로직을 모르지만**, 누가 죽었는지만 보고 **다시 살린다**.
- 상태는 **0으로 리셋**된다.
  – 재시작은 곧 “초기 상태로 되돌리기”이기 때문이다.

이 예제만 이해해도:

- “**의도적인 크래시**를 통해 오류 상태에서 탈출하고, 초기 상태로 돌아가는 것”이
  OTP 설계의 기본 패턴이라는 점을 느낄 수 있다.

---

### 재시작 전략 비교 – 언제 무엇을 쓰는가

슈퍼바이저는 **자식 여러 개**를 동시에 감시할 수 있다. 이 때, **누가 죽었을 때 누구를 함께 재시작할지**를 정하는 것을 **전략(strategy)**라고 한다.

| 전략 | 동작 | 추천 사용 예 |
|---|---|---|
| `:one_for_one` | 실패한 **그 자식만** 재시작 | 서로 독립적인 서버(대부분의 일반 GenServer) |
| `:rest_for_one` | 실패한 자식 **이후에 시작된 자식들** 모두 재시작 | “위 → 아래” **연쇄 의존** 구조 (파이프라인 다운스트림) |
| `:one_for_all` | **모든 자식** 재시작 | **공유 리소스/계약**이 매우 강한 경우 (예: 공통 캐시/커넥션 풀 초기화 필요) |

직관적인 그림(텍스트로):

- **`:one_for_one`**

  ```
  [Sup]
    ├─ A
    ├─ B
    └─ C

  B가 죽으면 → B만 다시 시작
  ```

- **`:rest_for_one`** (A → B → C 순서로 시작)

  ```
  [Sup]
    ├─ A (공통 설정/공유 자원)
    ├─ B (A를 사용)
    └─ C (A,B를 사용)

  B가 죽으면 → B, C 재시작 (A는 유지)
  C가 죽으면 → C만 재시작
  ```

- **`:one_for_all`**

  ```
  [Sup]
    ├─ A
    ├─ B
    └─ C

  B가 죽으면 → A, B, C 전부 재시작
  ```

**실전 팁**

- 의존 방향을 **위에서 아래로** 그려보고,
  “이 노드가 죽으면 어디까지 다시 올려야 안정적 상태가 되는지”를 기준으로 전략을 선택한다.
- 예: “DB 커넥션 풀 → 캐시 서버 → API 서버” 같은 구조에서,
  DB 커넥션 풀 설정이 완전히 깨지면 그 위에 있는 캐시/서버도 모두 재시작하는 것이 안전하다면 `:one_for_all`을 고려할 수 있다.

---

### 트리 형태로 확장 – 서브 슈퍼바이저

현실 시스템에서는 **한 슈퍼바이저에 모든 워커를 몰아넣지 않는다**. 대신 다음과 같이 계층을 나눈다.

```elixir
defmodule IO.Supervisor do
  use Supervisor

  def start_link(opts),
    do: Supervisor.start_link(__MODULE__, :ok, opts)

  @impl true
  def init(:ok) do
    children = [
      {Logger.BackendSupervisor, []},  # 예시: IO 백엔드(가상의 예)
      {Cache.Server, name: Cache.Server}
    ]

    Supervisor.init(children, strategy: :one_for_all)
  end
end

defmodule Root.Supervisor do
  use Supervisor

  def start_link(opts),
    do: Supervisor.start_link(__MODULE__, :ok, opts)

  @impl true
  def init(:ok) do
    children = [
      {IO.Supervisor, name: IO.Supervisor},
      {App.Supervisor, name: App.Supervisor}
    ]

    Supervisor.init(children, strategy: :rest_for_one)
  end
end
```

이 구조의 의미:

- `Root.Supervisor` 아래에 **두 개의 서브 슈퍼바이저**가 형제로 존재:
  - `IO.Supervisor`: 로깅/캐시 등 I/O 관련 컴포넌트
  - `App.Supervisor`: 도메인 로직 서버들
- `IO.Supervisor`가 터져서 재시작되면,
  - `App.Supervisor`는 그대로 유지 (`:one_for_one`이기 때문)
  - I/O 라인은 `:one_for_all` 전략에 따라 전체가 함께 재시작

이런 식으로 트리를 나누면:

- **어떤 장애가 어느 범위까지 영향을 줄지**를 미리 설계할 수 있다.
- 나중에 운영자가 트리를 보면서
  “이 슈퍼바이저가 내려가면 어느 기능이 일시 중단되는지”를 직관적으로 이해할 수 있다.

---

## 워커 재시작 옵션과 child_spec

슈퍼바이저가 자식을 어떻게 다룰지 정의하는 핵심 단위는 **child_spec**이다.

### child_spec 필드 정리

대표적인 child_spec:

```elixir
%{
  id: MyServer,                   # 자식 식별자 (슈퍼바이저 내에서 유일해야 함)
  start: {MyServer, :start_link, [opts]},
  restart: :permanent,            # :permanent | :transient | :temporary
  shutdown: 10_000,               # 종료猶予(ms) | :infinity
  type: :worker,                  # :worker | :supervisor
  modules: [MyServer]             # 핫 코드 업그레이드용 (일반적으론 자동)
}
```

각 필드 의미:

- `id`: 슈퍼바이저가 이 자식을 구분할 때 사용하는 이름. 중복되면 안 된다.
- `start`: `{모듈, 함수, 인자목록}` 형식. 일반적으로 `start_link/1`를 사용.
- `restart`:
  - `:permanent` — **항상 재시작** (정상 종료여도)
  - `:transient` — **비정상 종료일 때만 재시작** (정상 종료는 재시작하지 않음)
  - `:temporary` — **절대 재시작하지 않음** (일회성 작업에 적합)
- `shutdown`:
  - `N` (ms) — `:shutdown` exit 신호를 보내고 N ms 동안 **정리 시간을 준 뒤**, 안 죽으면 `:kill`
  - `:infinity` — 무한정 대기 (잘못 쓰면 시스템이 내려갈 때 매우 느려질 수 있음)
- `type`:
  - `:worker` — 일반 GenServer, GenStage, Task.Supervisor 등
  - `:supervisor` — 또 다른 Supervisor (서브 트리의 루트)

실제 코딩 시에는 보통 **`Supervisor.child_spec/2`** 혹은 `{Mod, opts}` 튜플을 통해 간결하게 작성한다.

---

### `:permanent`, `:transient`, `:temporary` 실제 차이

`restart` 정책을 비교하는 실전 예제를 조금 더 구체적으로 보자.

#### `:permanent` – “언제나 살아 있어야 하는 서버”

```elixir
defmodule Worker.Perm do
  use GenServer

  def start_link(opts),
    do: GenServer.start_link(__MODULE__, :ok, opts)

  @impl true
  def init(:ok), do: {:ok, :running}

  def stop(pid),
    do: GenServer.stop(pid, :normal)  # 정상 종료 요청
end

defmodule Sup.Perm do
  use Supervisor

  def start_link,
    do: Supervisor.start_link(__MODULE__, :ok, name: __MODULE__)

  @impl true
  def init(:ok) do
    child =
      Supervisor.child_spec(
        {Worker.Perm, name: Worker.Perm},
        restart: :permanent
      )

    Supervisor.init([child], strategy: :one_for_one)
  end
end
```

IEx에서:

```elixir
{:ok, _} = Sup.Perm.start_link()
Worker.Perm.stop(Worker.Perm)  # :normal 종료
# → 하지만 restart: :permanent 이므로 슈퍼바이저가 다시 시작해서 살아난다.

```

- **항상 하나 있어야 하는** 서버 (예: 메인 캐시 서버, 중앙 라우터 등)에 적합하다.

#### `:transient` – “정상 종료는 정상, 예외엔 재시작”

```elixir
defmodule Sup.Transient do
  use Supervisor

  def start_link,
    do: Supervisor.start_link(__MODULE__, :ok, name: __MODULE__)

  @impl true
  def init(:ok) do
    child =
      Supervisor.child_spec(
        {Worker.Perm, name: Worker.Trans},
        restart: :transient
      )

    Supervisor.init([child], strategy: :one_for_one)
  end
end
```

IEx에서:

```elixir
{:ok, _} = Sup.Transient.start_link()

# 정상 종료

GenServer.stop(Worker.Trans, :normal)
# → 비정상이 아니므로 다시 시작하지 않는다.

# 비정상 종료

pid = Process.whereis(Worker.Trans)
Process.exit(pid, :kill)
# → 비정상 종료이므로 다시 시작된다.

```

**언제 쓰나?**

- “작업을 다 하면 꺼지는 워커(배치 작업)”에 적합하다.
- 작업 중 예외로 죽으면 다시 재시작해주지만,
  작업이 끝나고 정상 종료하는 것을 “오류”로 보지 않는다.

#### `:temporary` – “다시는 살리지 말 것”

- `restart: :temporary`는 어떤 경우든 **재시작하지 않는다**.
- 예: **정말 한 번만 실행해야 하는 마이그레이션 워커**나
  이미 Job 시스템에서 **재시도 로직을 따로 관리**하는 일회성 작업 등.

---

### 재시작 강도(Intensity)와 시간창(Period)

슈퍼바이저가 자식을 “너무 많이, 너무 자주” 재시작하면 어떻게 될까?

- 코드/환경이 잘못 구성되어 **계속 죽었다 살았다를 반복**할 수 있다.
- 이런 상태를 **플래핑(flapping)** 이라고 부르고, 그냥 놔두면 자원과 로그를 낭비한다.

그래서 슈퍼바이저는 다음 두 값을 갖는다.

```elixir
Supervisor.init(children,
  strategy: :one_for_one,
  max_restarts: 3,
  max_seconds: 5
)
```

의미:

- **5초** 동안 **3회**를 초과하는 재시작이 발생하면
- 슈퍼바이저 자신이 **포기하고 종료**한다.
- 상위 슈퍼바이저(또는 애플리케이션)가 다시 이 슈퍼바이저를 재시작할지 결정한다.

간단한 재시작율 직관:

$$
\text{허용 재시작율} = \frac{\text{max\_restarts}}{\text{max\_seconds}}
$$

- 예: `max_restarts: 3, max_seconds: 5` → 초당 0.6회 정도를 임계치로 보는 셈.

**실전 팁**

- 개발 환경에서 **의도적으로 crash 루프를 만들고**,
  `max_restarts`, `max_seconds`를 조절해보면서 “어느 수준에서 전파되는지” 감을 잡는 것이 좋다.
- 운영 환경에서는 Telemetry로 **실제 재시작 카운트**를 수집하면서,
  플래핑이 발생했을 때 빠르게 감지·튜닝하도록 한다.

---

### shutdown 동작과 리소스 정리

슈퍼바이저 또는 애플리케이션이 종료될 때:

1. 슈퍼바이저는 각 자식에게 `exit(child, :shutdown)`을 보낸다.
2. 자식이 GenServer라면, `terminate(reason, state)` 콜백이 **호출될 기회**를 얻는다.
3. 이때 **파일/소켓/DB 트랜잭션** 등을 정리해야 한다.
4. `shutdown: N` ms 안에 종료하지 않으면,
   슈퍼바이저는 `exit(child, :kill)`을 보내 강제 종료한다.

따라서 **리소스 정리 전략은 언제나 두 겹으로 설계해야 한다.**

1) **각 요청 처리 시** `try ... after`로 정리
2) **프로세스 종료 시** `terminate/2`에서 **남아 있을 수 있는 리소스** 정리

예:

```elixir
@impl true
def handle_call({:write, line}, _from, st) do
  try do
    IO.write(st.io, line <> "\n")
    {:reply, :ok, st}
  after
    # 여기서 io를 닫으면 안 된다! (요청마다 닫히기 때문)
    :ok
  end
end

@impl true
def terminate(reason, st) do
  IO.write(st.io, "# terminating: #{inspect(reason)}\n")
  File.close(st.io)
  :ok
end
```

- “각 요청마다 열고 닫는” 경우에는 `try...after`에서 닫고,
- “서버의 전체 수명 동안 유지하는 핸들”은 `terminate/2`에서 정리한다.

---

### DynamicSupervisor – 동적 워커 풀의 표준

이전 OTP에서 쓰이던 `:simple_one_for_one`은 **Deprecated**되었고,
오늘날에는 **DynamicSupervisor**가 표준이다.

#### 기본 구조

```elixir
defmodule Jobs.Supervisor do
  use DynamicSupervisor

  def start_link(opts),
    do: DynamicSupervisor.start_link(__MODULE__, :ok, opts)

  @impl true
  def init(:ok),
    do: DynamicSupervisor.init(strategy: :one_for_one)

  def start_job(args) do
    spec = {Job.Server, args}
    DynamicSupervisor.start_child(__MODULE__, spec)
  end

  def stop_job(pid),
    do: DynamicSupervisor.terminate_child(__MODULE__, pid)
end

defmodule Job.Server do
  use GenServer

  def start_link(args),
    do: GenServer.start_link(__MODULE__, args)

  @impl true
  def init(args),
    do: {:ok, %{args: args}}
end
```

IEx:

```elixir
{:ok, _} = Jobs.Supervisor.start_link(name: Jobs.Supervisor)

{:ok, pid1} = Jobs.Supervisor.start_job(some: :arg)
{:ok, pid2} = Jobs.Supervisor.start_job(other: :job)

Jobs.Supervisor.stop_job(pid1)
```

- `DynamicSupervisor`는 자식 목록이 **고정되어 있지 않은 경우**에 적합하다.
  - 예: 사용자 세션당 워커 1개, Job당 워커 1개, 커넥션당 워커 1개 등.
- 일반 `Supervisor`와 달리, 자식을 **동적으로 추가/제거**하는 것이 자연스럽다.

#### Registry와 결합한 “세션 프로세스”

```elixir
defmodule Session.Server do
  use GenServer

  def start_link(user_id),
    do: GenServer.start_link(__MODULE__, user_id)

  @impl true
  def init(user_id),
    do: {:ok, %{user_id: user_id, data: %{}}}
end

defmodule Session.Supervisor do
  use DynamicSupervisor

  def start_link(opts),
    do: DynamicSupervisor.start_link(__MODULE__, :ok, opts)

  @impl true
  def init(:ok),
    do: DynamicSupervisor.init(strategy: :one_for_one)

  def start_session(user_id) do
    spec = {Session.Server, user_id}
    DynamicSupervisor.start_child(__MODULE__, spec)
  end
end

defmodule Session.Registry do
  def whereis(user_id) do
    case Registry.lookup(SessionReg, {:session, user_id}) do
      [{pid, _}] -> {:ok, pid}
      [] -> :error
    end
  end

  def ensure_session(user_id) do
    with :error <- whereis(user_id),
         {:ok, pid} <- Session.Supervisor.start_session(user_id) do
      Registry.register(SessionReg, {:session, user_id}, [])
      {:ok, pid}
    else
      {:ok, pid} -> {:ok, pid}
    end
  end
end
```

- `DynamicSupervisor` + `Registry` 조합은 **“키별 단일 프로세스”** 패턴을 구현하는 데 핵심이다.
- 예: 유저 세션, 쇼핑 카트, 채팅 방, 파티션별 워커 등.

---

## 슈퍼바이저는 신뢰성의 핵심이다

### 실패를 “상태 전이”로 보는 관점

일반적인 시스템에서는 실패를 **예외적인 상황**으로 취급한다.
반면 OTP에서는 **실패가 규범**이고, 이를 “**상태 전이**”로 본다.

- 예: “정상 작동(running) → 오류 상태(error) → 크래시(crash) → 재시작(restart) → 초기 상태(running)”
- 이 전체 흐름을 **슈퍼비전 트리**가 표준화한다.

장점:

1. **팀 전체가 동일한 실패 모델을 공유**
   - “죽으면 슈퍼바이저가 다시 띄운다”는 기본 규칙.
2. **운영 가이드 단순화**
   - “이 프로세스가 죽으면 어떻게 하지?” 대신 “슈퍼바이저가 어떻게 재시작하도록 설계되어 있지?”로 사고.
3. **복구 자동화**
   - 사람이 개입하지 않아도, 대부분의 일시적 장애는 **자동으로 회복**된다.

---

### 설계 원칙 체크리스트

실전에서 슈퍼비전 트리를 설계할 때 점검해야 할 포인트:

1. **한 책임 = 한 워커**
   - 하나의 GenServer가 너무 많은 일을 하지 않게 한다.
   - 상태와 리소스를 최소화하여 **재시작 비용을 줄인다**.

2. **의존 방향을 트리에 투영**
   - “어떤 모듈이 어떤 모듈에 의존하는가?”를 정리하고,
   - 그 방향대로 슈퍼비전 트리의 **부모-자식 관계**와 **시작 순서**를 설계한다.

3. **전략 선택**
   - 독립적인 서버들 → `:one_for_one`
   - 위에서 아래로 순차 의존 → `:rest_for_one`
   - 강한 공유/계약(공통 설정이 깨지면 모두 재시작해야 하는 경우) → `:one_for_all`

4. **재시작 강도 튜닝**
   - 플래핑을 빠르게 상위로 전파할지,
     아니면 어느 정도의 튀김은 허용할지 결정.

5. **shutdown 시간**
   - 외부 I/O(네트워크/파일/DB)가 많은 경우,
     `shutdown` 시간을 **실제 정리 시간에 맞게 충분히** 잡는다.

6. **DynamicSupervisor 활용**
   - 동적 워커(세션/Job)를 **일반 Supervisor에 몰아넣지 말고**,
     DynamicSupervisor에 연결하여 표준 패턴을 따른다.

7. **관찰 가능성**
   - 재시작 카운트, 종료 이유, 메일박스 길이, 처리량 등을
     Telemetry 이벤트로 노출하여 **플래핑/병목**을 조기에 감지한다.

---

### “미니 파이프라인” 예제 – 실패 격리와 부분 재부팅

요구사항:

- 외부에서 문자열 라인 형태의 이벤트를 받는다.
- 파싱 → 검증 → 저장 순으로 처리한다.
- 검증 단계에서 예외가 나더라도, Reader/Parser는 계속 동작해야 한다.
- 잘못된 메시지는 DeadLetter 큐에 보낸다.

#### 파이프라인 워커들

```elixir
defmodule Input.Reader do
  use GenServer

  def start_link(opts),
    do: GenServer.start_link(__MODULE__, opts, name: Keyword.get(opts, :name))

  @impl true
  def init(_opts) do
    # 시작 후 주기적으로 :tick을 받아 데이터를 흘려보내는 예
    Process.send_after(self(), :tick, 50)
    {:ok, %{downstream: Input.Parser}}
  end

  @impl true
  def handle_info(:tick, st) do
    # 실제로는 소켓/파일/카프카 읽기 등이 들어갈 위치
    send(st.downstream, {:line, "a,1"})
    Process.send_after(self(), :tick, 50)
    {:noreply, st}
  end
end

defmodule Input.Parser do
  use GenServer

  def start_link(_opts),
    do: GenServer.start_link(__MODULE__, :ok, name: __MODULE__)

  @impl true
  def init(:ok),
    do: {:ok, %{downstream: Input.Validator}}

  @impl true
  def handle_info({:line, raw}, st) do
    try do
      [k, v] = String.split(raw, ",")
      event = %{k: k, v: String.to_integer(v)}
      send(st.downstream, {:event, event})
    rescue
      _ ->
        send(DeadLetter.Sink, {:bad, raw})
    end

    {:noreply, st}
  end
end

defmodule Input.Validator do
  use GenServer

  def start_link(_opts),
    do: GenServer.start_link(__MODULE__, :ok, name: __MODULE__)

  @impl true
  def init(:ok),
    do: {:ok, %{downstream: DB.Sink}}

  @impl true
  def handle_info({:event, e}, st) do
    if e.v < 0 do
      # 검증 실패 → 일부러 크래시
      raise "invalid #{inspect(e)}"
    end

    send(st.downstream, {:ok, e})
    {:noreply, st}
  end
end

defmodule DB.Sink do
  use GenServer

  def start_link(_opts),
    do: GenServer.start_link(__MODULE__, :ok, name: __MODULE__)

  @impl true
  def init(:ok),
    do: {:ok, %{buf: []}}

  @impl true
  def handle_info({:ok, e}, st) do
    # 실제로는 DB 배치 insert/insert_all 등이 들어갈 위치
    {:noreply, %{st | buf: [e | st.buf]}}
  end
end

defmodule DeadLetter.Sink do
  use GenServer

  def start_link(_opts),
    do: GenServer.start_link(__MODULE__, :ok, name: __MODULE__)

  @impl true
  def init(:ok), do: {:ok, []}

  @impl true
  def handle_info({:bad, raw}, st),
    do: {:noreply, [raw | st]}
end
```

#### 슈퍼바이저 구성

```elixir
defmodule Input.Supervisor do
  use Supervisor

  def start_link(opts),
    do: Supervisor.start_link(__MODULE__, :ok, opts)

  @impl true
  def init(:ok) do
    children = [
      {Input.Reader, name: Input.Reader},
      {Input.Parser, name: Input.Parser},
      {Input.Validator, name: Input.Validator}
    ]

    # Reader → Parser → Validator 순으로 시작
    Supervisor.init(children, strategy: :rest_for_one)
  end
end

defmodule Sink.Supervisor do
  use Supervisor

  def start_link(opts),
    do: Supervisor.start_link(__MODULE__, :ok, opts)

  @impl true
  def init(:ok) do
    children = [
      {DB.Sink, name: DB.Sink},
      {DeadLetter.Sink, name: DeadLetter.Sink}
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end
end

defmodule Root.Supervisor do
  use Supervisor

  def start_link,
    do: Supervisor.start_link(__MODULE__, :ok, name: __MODULE__)

  @impl true
  def init(:ok) do
    children = [
      {Sink.Supervisor, name: Sink.Supervisor},
      {Input.Supervisor, name: Input.Supervisor}
    ]

    Supervisor.init(children,
      strategy: :one_for_one,
      max_restarts: 3,
      max_seconds: 5
    )
  end
end
```

실행:

```elixir
{:ok, _} = Root.Supervisor.start_link()
# Reader는 init에서 이미 첫 :tick을 예약함

```

**동작 시나리오**

- `Input.Validator`가 예외로 죽으면?
  - `:rest_for_one` 전략에 의해 **Validator 이후에 시작된 자식**이 없으므로 Validator만 재시작.
  - Reader/Parser는 계속 살아 있으므로 **데이터 흐름도 빠르게 복원**된다.
- `DB.Sink`가 예외로 죽으면?
  - `Sink.Supervisor`의 `:one_for_one` 전략에 의해 **DB.Sink만 재시작**되고 DeadLetter는 계속 수집.

이런 식으로 단계별로 트리를 쪼개면:

- 검증 단계가 계속 죽더라도 Reader는 유지되어 **입력 소스와의 연결**은 살아 있게 만들 수 있다.
- 반대로 DB가 계속 터진다면, Sink 라인만 재시작하면서 DeadLetter에 쌓인 메시지로 사후 분석이 가능하다.

---

### Telemetry로 재시작 관찰하기

슈퍼바이저 재시작을 Telemetry로 기록하는 예:

```elixir
:telemetry.attach(
  "sup-restarts",
  [:supervisor, :restart],
  fn _event, measurements, metadata, _config ->
    require Logger

    Logger.warning("""
    child=#{inspect(metadata.child)}
    reason=#{inspect(metadata.reason)}
    count=#{measurements.count}
    """)
  end,
  nil
)
```

- 이 이벤트를 기반으로 **대시보드(예: Prometheus, Grafana, LiveDashboard)**에서
  “어떤 자식이 얼마나 자주 재시작되는지”를 확인할 수 있다.
- 특정 자식의 재시작이 갑자기 증가하면,
  코드 변경/환경 변경/외부 API 문제 등 **근본 원인을 추적**할 수 있다.

---

### 수학적 직관 – MTBF/MTTR과 가용도

신뢰성을 이야기할 때 자주 등장하는 개념:

- **MTBF(Mean Time Between Failures)**: 평균 고장 간격 (고장 사이 시간)
- **MTTR(Mean Time To Repair)**: 평균 복구 시간

고장률을 \(\lambda\) (단위 시간당 고장 확률),
복구 시간(재시작 포함)을 \(R\)이라고 하면,
평균 가용도(Availability) \(A\)는 다음과 같이 근사할 수 있다.

$$
A = \frac{\text{MTBF}}{\text{MTBF} + \text{MTTR}}
  = \frac{1/\lambda}{1/\lambda + R}
$$

OTP 슈퍼비전 트리는:

- 고장률 \(\lambda\) 자체를 줄이지는 못하지만,
- **재시작 자동화로 MTTR을 줄이는 역할**을 한다.

또한 `max_restarts/max_seconds` 설정은
“이 정도 속도로 고장이 나면 **상위 레벨에서 크게 리셋해야 한다**”는 **정책 임계값**으로 이해할 수 있다.

---

### 테스트 전략 – 재시작과 shutdown을 검증하라

슈퍼바이저를 테스트할 때는 다음 세 가지를 꼭 확인한다.

1. **재시작 동작**

```elixir
test "validator crash restarts only tail" do
  {:ok, _} = Root.Supervisor.start_link()

  v = Process.whereis(Input.Validator)

  Process.exit(v, :kill)
  Process.sleep(50)

  # Validator는 새 PID로 재시작
  assert v != Process.whereis(Input.Validator)

  # Reader는 살아 있어야 한다.
  assert Process.alive?(Process.whereis(Input.Reader))
end
```

2. **shutdown 정리**

- `GenServer.stop/3`를 통해 워커를 정상 종료하고,
- `terminate/2`에서 리소스 정리가 잘 되는지 확인한다.

3. **강도 초과 시 전파**

- `max_restarts`, `max_seconds`를 매우 작게 설정한 테스트용 Supervisor를 만들고,
- 연속으로 크래시를 유발해보며 “슈퍼바이저 자체가 내려갔다 다시 올라오는지” 확인한다.

---

## 운영 팁 모음

1. **슈퍼비전 트리 도면화**
   - README나 내부 문서에 트리 구조를 **텍스트/다이어그램**으로 정리해 둔다.
   - 어느 슈퍼바이저가 어떤 자식들을 갖고 있고,
     각 슈퍼바이저가 어떤 전략(`:one_for_one` 등)을 쓰는지 명시.

2. **child_spec 명시**
   - 복수 인스턴스를 띄우는 워커(샤딩/세션 등)는
     `child_spec/1`를 직접 구현하여 **id, restart 정책** 등을 명시적으로 통제한다.

3. **백오프(Backoff)**
   - 재시작 직후 동일 작업을 바로 시작하면,
     플래핑이 발생할 수 있다.
   - `handle_continue`나 별도 타이머를 사용하여 **워밍업 딜레이**를 두거나
     **지수 백오프**를 적용한다.

4. **분산 환경**
   - 노드별로 동일한 슈퍼비전 트리를 띄우되,
     **라우팅(어느 노드로 보낼지)**와 **상태 동기화**는 별도 컴포넌트로 분리한다.
   - Supervisor는 “한 노드 내에서” 수명주기만 책임진다고 보는 것이 안전하다.

---

## 자주 하는 실수와 교정 방향

1) **한 슈퍼바이저에 모든 워커를 몰아넣기**

- 문제: 어떤 것이 죽었을 때 어떤 것이 재시작되는지 **구분이 안 되고**,
  재시작 파급 범위를 세밀하게 제어하기 어렵다.
- 교정:
  - 기능/도메인/리소스 경계별로 **서브 슈퍼바이저**를 나누어
    트리를 계층화한다.

2) **`shutdown: 5_000` 기본값만 맹신**

- 문제: 외부 I/O가 많은 워커는 5초로는 정리를 다 못할 수 있다.
- 교정:
  - 실제 I/O 상황에 맞춰 `shutdown` 값을 조정하고,
  - 그래도 남을 수 있는 리소스는 **각 요청의 `try...after`**에서 정리한다.

3) **`:permanent` 남발**

- 문제: 사실은 “작업 완료 후 꺼지는 것이 정상”인 워커까지
  모두 계속 살려두려 하면서 **불필요한 재시작 소음**이 발생한다.
- 교정:
  - 배치/Job 워커에는 `:transient` 또는 `:temporary`를 적용해,
    “정상 종료 = 성공” 패턴을 명확히 한다.

4) **동적 워커를 일반 Supervisor에 넣기**

- 문제: Supervisor가 **정적 children 목록**을 전제로 작성된 코드와 섞여,
  동적 자식 추가/제거에 대한 이슈가 생길 수 있다.
- 교정:
  - **DynamicSupervisor**로 분리하여, 동적 워커 관리 패턴을 표준화한다.

5) **강도 설정을 잘못 잡기**

- 문제: 너무 느슨하면 실패 루프를 오래 허용하고,
  너무 빡세면 일시적인 스파이크에도 상위 루트가 자주 리셋된다.
- 교정:
  - 개발 환경에서 **의도적으로 크래시를 유발해보며**,
    프로젝트 특성에 맞는 `max_restarts`, `max_seconds`를 잡는다.
  - Telemetry로 실제 재시작 패턴을 관찰하며 운영 중에도 튜닝한다.

---

## 마무리

- **슈퍼바이저는 OTP 신뢰성의 핵심**이다.
- 워커는 오직 **업무 로직과 상태**를 담당하고,
  슈퍼바이저는 오직 **수명주기와 재시작 정책**을 담당한다.
- 올바른 **전략 선택**(`:one_for_one`, `:rest_for_one`, `:one_for_all`)과
  **재시작 옵션**(`:permanent`, `:transient`, `:temporary`, `max_restarts`, `shutdown`)은
  *장애의 파급을 최소화*하고 *복구를 자동화*한다.
- **DynamicSupervisor**를 사용해 동적 워커를 관리하고,
  **Telemetry**로 재시작/큐/처리량을 관찰하면,
  시스템은 **스스로 회복**하는 방향으로 진화한다.

결국 설계의 기준은 단순하다.

- **작게 나누고**
- **경계를 세우고**
- **복구를 표준화**하라.

그렇게 쌓인 슈퍼비전 트리가, 장기적으로 **복구 가능한 대규모 시스템**의 뼈대가 된다.
