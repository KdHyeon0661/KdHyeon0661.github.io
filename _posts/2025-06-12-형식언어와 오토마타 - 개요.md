---
layout: post
title: 형식언어와 오토마타 - 개요
date: 2025-06-12 19:20:23 +0900
category: 형식언어와 오토마타
---
# 형식언어와 오토마타 (Formal Languages and Automata) — 개선본

형식언어(formal language)는 **정의된 알파벳과 규칙**으로 구성된 언어이며, 이를 **인식(recognize)**하는 수학적 계산 모델이 **오토마타(automata)**입니다.

---

## 0. 표기 규칙 & 빠른 용어 정리

- **알파벳**: $$\Sigma$$ (유한 집합). 예: $$\Sigma=\{a,b\}$$
- **문자열**: $$w\in\Sigma^\*$$, 길이 $$|w|$$, 공백 문자열 $$\varepsilon$$
- **언어**: $$L\subseteq\Sigma^\*$$
- **연산**: 연결 $$xy$$, 거듭제곱 $$x^k$$, Kleene 별 $$L^\*=\bigcup_{k\ge0}L^k$$, 역(반전) $$w^R$$

예시:

```text
알파벳 Σ = {a, b}
문자열 w = abba
언어 L = {ε, a, b, aa, bb, aba, bab, abba, ...}
```

---

## 1. 오토마타 한눈에 보기 (모델 ↔ 언어 클래스 ↔ 기억장치)

| 모델 | 인식 언어 | 기억장치/핵심 |
|---|---|---|
| DFA (Deterministic Finite Automaton) | 정규 언어 (Regular) | 유한상태, 결정적 전이 |
| NFA/ε-NFA (Nondet. FA) | 정규 언어 | 유한상태, 비결정/ε-이동 |
| PDA (Pushdown Automaton) | 문맥자유 언어 (CFL) | 스택(깊이 1 차원) |
| TM (Turing Machine) | 재귀열거 언어 (RE) | 무한 테이프, 보편 계산 |

정규 ⊊ 문맥자유 ⊊ 문맥민감 ⊆ 재귀열거(RE). 결정가능(Recursive) ⊊ RE.

---

## 2. DFA (Deterministic Finite Automaton)

### 2.1 정의와 의미
DFA는 5튜플 $$M=(Q,\Sigma,\delta,q_0,F)$$.
- $$Q$$: 유한 상태 집합, $$\Sigma$$: 입력 알파벳
- $$\delta: Q\times\Sigma\to Q$$: 전이함수(결정적)
- $$q_0\in Q$$: 시작 상태, $$F\subseteq Q$$: 받아들이는(accept) 상태

**확장 전이함수** $$\hat{\delta}(q, w)$$를 재귀적으로 정의하면, $$\hat{\delta}(q_0,w)\in F$$이면 $$w\in L(M)$$.

### 2.2 예제: a의 개수가 짝수인 언어
$$L=\{w\in\{a,b\}^\*\mid \#a(w)\ \text{가 짝수}\}$$

```text
상태: Q={q0(짝수), q1(홀수)}, 시작 q0, 종료 F={q0}
전이:
  δ(q0, a)=q1, δ(q0, b)=q0
  δ(q1, a)=q0, δ(q1, b)=q1
```

**상황 예시(로그 정책)**: “경고 코드 ‘A’가 짝수 번 등장할 때 승인” 같은 규칙을 DFA로 간단히 모델링 가능.

### 2.3 (미니 코드) DFA 시뮬레이터
```python
def run_dfa(states, alphabet, delta, start, accepts, s):
    q = start
    for ch in s:
        if ch not in alphabet: return False
        q = delta[(q, ch)]
    return q in accepts

# 예제 DFA: 짝수개의 'a'
states = {'q0', 'q1'}
alphabet = {'a', 'b'}
delta = {('q0','a'):'q1', ('q0','b'):'q0', ('q1','a'):'q0', ('q1','b'):'q1'}
print(run_dfa(states, alphabet, delta, 'q0', {'q0'}, 'abba'))   # True
print(run_dfa(states, alphabet, delta, 'q0', {'q0'}, 'abbaa')) # False
```

---

## 3. NFA/ε-NFA와 DFA의 동치

- NFA는 $$\delta:Q\times\Sigma\to 2^Q$$, ε-NFA는 $$\delta:Q\times(\Sigma\cup\{\varepsilon\})\to 2^Q$$
- **정리**: DFA ≡ NFA ≡ ε-NFA (인식 언어 동치).
  - ε-이동을 ε-폐포로 흡수 → NFA
  - NFA를 **부분집합 구성(subset construction)**으로 DFA화

**부분집합 구성 스케치**: NFA 상태 집합 $$Q$$ → DFA 상태는 $$2^Q$$의 원소. 시작은 ε-폐포($$\{q_0\}$$ 포함). 각 문자마다 집합 전이를 계산.

**상황 예시(간단 필터 체인)**: 이벤트가 여러 경로로 소비될 수 있는 **OR-조건** 필터링 로직은 NFA가 직관적—배포 시 DFA로 변환해 선형 시간으로 스캔.

---

## 4. 정규표현식(Regex)과 정규 언어

- **정규표현식**: $$\varnothing,\ \varepsilon,\ a\in\Sigma$$에서 합/연결/별(＊)로 생성
- **Kleene/케이틀리 정리**: 정규식과 (DFA/NFA)가 표현하는 언어는 동치

예시 정규식:

```regex
(a|b)*abb
```

이 언어는 임의의 a,b 열 뒤에 `abb`로 끝나는 문자열 집합.

> **현실 주의**: 많은 프로그래밍 언어의 “정규식 엔진”은 **역참조/전후방 탐색** 등 **정규 언어 밖**의 기능을 제공(최악의 경우 백트래킹으로 지수 시간). 이론 정규식과 구분하자.

---

## 5. 정규 언어의 폐쇄성과 비정규성 판정

### 5.1 폐쇄성 (정규 언어)
정규 언어 클래스는 다음 연산에 대해 **폐쇄**:
- 합/교/차/여, 연결, Kleene 별, 역(반전), 동형사상(이미지/역상)

**증명 아이디어**:
- 교집합: DFA의 **곱구성(product construction)**
- 여집합: DFA에서 **종결 상태 F ↔ Q\F 교환**

### 5.2 펌핑 보조정리(Regular Pumping Lemma)
**정리**: 정규 언어 $$L$$이면 $$\exists p$$ (펌핑 길이) s.t. $$\forall s\in L,\ |s|\ge p$$ ⇒
$$\exists x,y,z:\ s=xyz,\ |xy|\le p,\ |y|\ge 1,\ \forall i\ge0:\ xy^iz\in L$$.

**활용** (비정규성 증명):
- $$L=\{a^n b^n\mid n\ge0\}$$는 정규가 아님.
  - $$s=a^p b^p$$, 펌핑 조각 $$y=a^k$$ ⇒ $$xy^2z=a^{p+k}b^p\notin L$$.

**상황 예시(데이터 검증)**: “열 ‘A’의 길이 == 열 ‘B’의 길이” 류 제약은 **정규**로 처리 불가 → **문맥자유/그 이상**이 필요.

### 5.3 Myhill–Nerode 정리
**정리**: $$L$$에 대해 우동치 $$\equiv_L$$를
$$x\equiv_L y\iff \forall z,\ xz\in L \Leftrightarrow yz\in L$$
로 정의하면, $$L$$이 정규 ⇔ 동치류가 **유한 개**이며, **최소 DFA 상태 수 = 동치류 수**.

**사용법**:
- 비정규성: 서로 구별되는 접미사로 **무한 많은 동치류**를 구성
- 최소 상태 하한: 예) $$L=\{w\mid \#a(w)\equiv 0\pmod{k}\}$$은 최소 $$k$$ 상태 필요

---

## 6. DFA 최소화 (개요)

- **파티션 정제(Partition Refinement)**: (accept vs non-accept)로 시작 → 전이 행선지 기준으로 블록 분할 반복 → 안정 시 최소 DFA
- Hopcroft 알고리즘: $$O(|\Sigma|\cdot n\log n)$$

**작은 예**: 상태가 여러 개인 DFA에서 등가 상태를 병합해 전이표를 단순화.

---

## 7. 문맥자유 언어(CFL)와 CFG

### 7.1 CFG 정의 & 파스 트리
CFG $$G=(V,\Sigma,R,S)$$, 예:
$$S\to aSb\ \mid\ \varepsilon\quad\Rightarrow\quad L=\{a^n b^n\mid n\ge 0\}$$

- **좌/우 파생, 파스 트리** 개념
- **모호성**: 하나의 문자열에 대해 여러 파스 트리 → 문법이 모호 (언어가 본질적으로 모호할 수도 있음)

### 7.2 PDA와의 동치
- PDA는 스택으로 “짝 맞추기/중첩” 구조 인식 ⇒ **CFG ≡ PDA**

### 7.3 정상형과 알고리즘
- **CNF(Chomsky Normal Form)**: $$A\to BC\ \mid\ a\ (\mid\ S\to\varepsilon)$$
- **GNF(Greibach Normal Form)**: $$A\to a\alpha$$
- **CYK 파싱**: CNF에서 $$O(n^3)$$ 동적 계획으로 멤버십 판정

### 7.4 (미니 코드) CYK 파서
```python
from collections import defaultdict

def cyk_parse(cnf_productions, s):
    """
    cnf_productions: dict like
      {'S': [('A','B'), ('B','C')], 'A':[('a',)], 'B':[('b',)], ...}
    s: input string over terminals (list or str)
    """
    if isinstance(s, str):
        s = list(s)
    n = len(s)
    P = [ [set() for _ in range(n)] for _ in range(n) ]
    # length 1
    for i, a in enumerate(s):
        for A, rhs_list in cnf_productions.items():
            for rhs in rhs_list:
                if len(rhs)==1 and rhs[0]==a:
                    P[i][i].add(A)
    # length >=2
    for l in range(2, n+1):       # substring length
        for i in range(n-l+1):
            j = i+l-1
            for k in range(i, j):
                left_set, right_set = P[i][k], P[k+1][j]
                for A, rhs_list in cnf_productions.items():
                    for rhs in rhs_list:
                        if len(rhs)==2:
                            B, C = rhs
                            if B in left_set and C in right_set:
                                P[i][j].add(A)
    return P[0][n-1] if n>0 else set()

# 예: S -> AB | BC, A-> a, B-> b, C-> c (CNF)
G = {
  'S':[('A','B'),('B','C')],
  'A':[('a',)],
  'B':[('b',)],
  'C':[('c',)]
}
print('S in?', 'S' in cyk_parse(G, 'ab'))  # True
print('S in?', 'S' in cyk_parse(G, 'bc'))  # True
print('S in?', 'S' in cyk_parse(G, 'ac'))  # False
```

**상황 예시(컴파일러 파이프라인)**: 렉서(정규) → 파서(CFG). 괄호/중첩/우선순위는 정규로 어렵고 CFG가 적합.

### 7.5 CFL의 폐쇄성/비폐쇄성
- **폐쇄**: 합/연결/Kleene 별/역(반전)/정규와의 교집합
- **비폐쇄**: 일반적으로 교집합/여집합은 폐쇄 아님
  - 트릭: 비CFL 증명에 **정규와의 교집합** 사용
  - 예: $$L_1=\{a^n b^n c^n\}$$는 CFL이 아님. 정규 $$R=\{a^\* b^\* c^\*\}$$와 교집합은 자기 자신 → 여전히 비CFL.

---

## 8. PDA 직관과 예시

**언어** $$L=\{a^n b^n\mid n\ge0\}$$ 인식 PDA 스케치:
- 입력 a마다 스택에 ‘A’ push, b마다 pop
- 중간 전환(읽기를 a→b로 바꾸는 시점)을 ε-이동으로 처리
- 종료: 스택 공백 또는 accept 상태로 수락

**상황 예시(중첩 규칙 검사)**: JSON/XML 괄호/태그 중첩 유효성 검사는 PDA 형태가 자연스럽다.

---

## 9. 결정가능성/계산가능성(튜링 기계 관점)

### 9.1 튜링 기계(TM)
구성: $$M=(Q,\Sigma,\Gamma,\delta,q_0,q_{acc},q_{rej})$$. 무한 테이프/헤드/전이.
**다중 테이프 TM, RAM, λ-계산** 등은 계산능력 동등.

### 9.2 결정가능/인정가능
- **결정가능(Decidable)**: 항상 정지하며 정답
- **인정가능(RE)**: 언어에 속하면 정지/승인, 아니면 무한루프 가능

### 9.3 정지 문제와 Rice 정리
- **정지 문제(HALT)**: $$HALT=\{\langle M,x\rangle \mid M \text{이 } x \text{에서 정지}\}$$ → **결정불가능**
- **Rice 정리**: “프로그램(머신)이 인식하는 언어의 **비자명한 성질**은 모두 결정불가능”

**상황 예시(정적 분석 한계)**: “이 함수가 모든 입력에서 안전한가?” 유형은 일반적으로 결정불가능—분석 도구는 근사/제약/타임아웃을 둔다.

---

## 10. 촘스키 위계(Chomsky Hierarchy)

| 타입 | 언어 | 전형적 예 | 인식/생성 모델 |
|---|---|---|---|
| 3 | 정규 | $$\{w\mid \#a(w)\equiv 0\pmod k\}$$ | DFA/NFA/정규식 |
| 2 | 문맥자유 | $$\{a^n b^n\}$$, 괄호 짝 | CFG/PDA |
| 1 | 문맥민감 | $$\{a^n b^n c^n\}$$ 등 | 선형제한 오토마타 |
| 0 | 재귀열거 | 임의의 계산 가능 언어 | 튜링 기계 |

---

## 11. 실전 연결(Regex 엔진, 렉서/파서, 성능 포인트)

- **정규식 엔진 vs 이론 정규식**: 엔진의 확장 기능(역참조 등)은 정규 언어 바깥 가능, **백트래킹 폭발** 주의
- **렉서(정규) → 파서(CFG)**: 언어 설계/컴파일러/규칙 검증 파이프라인의 표준
- **성능**: DFA 기반 매칭은 선형/고정 메모리, 백트래킹 NFA는 입력/패턴에 따라 **최악 지수** 가능

---

## 12. 연습문제(스케치 해설)

1) **정규 여부**: $$L=\{w\in\{0,1\}^\*\mid \#1(w)\ \text{가 짝수}\}$$
- 2상태 DFA로 수락 ⇒ 정규.

2) **비정규 증명**: $$\{a^n b^n\mid n\ge 0\}$$
- 정규 가정→펌핑 모순.

3) **CFL 확인**: $$\{ww^R\mid w\in\{a,b\}^\*\}$$
- CFG: $$S\to aSa\mid bSb\mid a\mid b\mid \varepsilon$$ 또는 PDA로 스택 매칭.

4) **최소 상태 하한**: $$L=\{w\mid \#a(w)\equiv 0\pmod{5}\}$$
- Myhill–Nerode로 5개 동치류 ⇒ 최소 DFA 5상태.

5) **CYK 멤버십**: CNF 문법으로 ‘ab’, ‘bc’는 S에 속하지만 ‘ac’는 아님(코드 참고).

---

## 13. 자주 하는 실수 & 팁

- 펌핑 보조정리를 **충분조건**처럼 사용(오해) → 필요조건임
- 정규식 엔진의 결과를 **정규 언어**로 오해
- CFL의 교집합/여집합 비폐쇄성 망각
- 환원 방향 혼동: $$A\le_m B$$면 “B가 풀리면 A도 풀린다”(B가 적어도 A만큼 어렵다)

---

## 14. 부록: 빠른 참고 표

### 14.1 정규 언어 폐쇄성 요약

| 연산 | 합 | 교 | 차 | 여 | 연결 | 별 | 역 | 동형사상 |
|---|---|---|---|---|---|---|---|---|
| 정규 | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ |

### 14.2 CFL 폐쇄성 요약

| 연산 | 합 | 연결 | 별 | 역 | 교(일반) | 여 |
|---|---|---|---|---|---|---|
| CFL | ✔ | ✔ | ✔ | ✔ | ✖(일반) | ✖(일반) |
| (CFL ∩ 정규) |  |  |  |  | ✔ |  |

---

## 결론

형식언어/오토마타는 **언어 설계·컴파일러·입력 검증·정적 분석**의 이론적 토대입니다.
DFA/NFA/정규식(정규), CFG/PDA(CFL), CYK, 그리고 결정가능성 관점(튜링, 할팅, Rice)을 함께 익히면 **현실 시스템 규칙 설계**와 **성능/한계**를 균형 있게 판단할 수 있습니다.
