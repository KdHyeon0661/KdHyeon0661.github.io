---
layout: post
title: Svelte - 고급 토픽 (2)
date: 2025-10-08 17:30:23 +0900
category: Svelte
---
# — **D3 / Three.js / MapLibre 통합 · 데스크톱/모바일 포장(Tauri / Electron / Capacitor)**

> 이 장에서는 SvelteKit을 **고성능 시각화 엔진**과 **네이티브 포장(데스크톱/모바일)**과 통합하는 방법을 “복붙 가능한 예제” 중심으로 다룬다.
> 범위:
> - **D3**: 반응형 SVG/Canvas, 스케일, 줌/팬, 가상화 팁
> - **Three.js**: SSR-안전 동적 import, OrbitControls, 후처리, 성능 튜닝
> - **MapLibre GL JS**: 타일 소스, 레이어/소스 동적 업데이트, 클릭/호버 인터랙션
> - **포장**: **Tauri**(Rust 기반 경량), **Electron**(Node + Chromium), **Capacitor**(iOS/Android)
> - 공통 고려: SSR/CSR 격리, 타입, 접근성(A11y), 성능/메모리, 배포 스크립트

---

## 준비 사항

```bash
# 프로젝트 생성 (없다면)

pnpm create svelte@latest sveltekit-advanced
cd sveltekit-advanced
pnpm i
```

- SvelteKit 기본 지식(라우팅, +page, +page.ts, SSR/CSR 모드)
- Node 18+, PNPM 9+
- 브라우저 빌트인 API(ResizeObserver, IntersectionObserver) 사용 가능

> 시각화 라이브러리는 **브라우저 전용**이므로 **SSR 안전**(dynamic import, `onMount`) 패턴을 철저히 지킨다.

---

## D3 통합

### 설치 & 기본 패턴

```bash
pnpm add d3
```

D3는 모듈 모음식 패키지다. 흔히 쓰는 유틸만 가져오기 권장(`d3-scale`, `d3-shape` 등 개별 설치도 가능하지만 `d3` 통합 패키지로도 충분).

**SSR 안전 패턴**:

```svelte
<!-- src/lib/viz/D3Line.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { scaleTime, scaleLinear, extent, axisBottom, axisLeft, line, select, zoom, zoomTransform } from 'd3';
  export let data: { x: Date; y: number }[] = [];
  export let margin = { top: 10, right: 16, bottom: 28, left: 36 };

  let container: HTMLDivElement;
  let svg: SVGSVGElement;
  let resizeObs: ResizeObserver;
  let cleanup: () => void;

  function draw() {
    const rect = container.getBoundingClientRect();
    const width = Math.max(300, rect.width);
    const height = 240;

    const innerW = width - margin.left - margin.right;
    const innerH = height - margin.top - margin.bottom;

    const x = scaleTime().domain(extent(data, d => d.x) as [Date, Date]).range([0, innerW]);
    const y = scaleLinear().domain([0, Math.max(1, ...data.map(d => d.y))]).nice().range([innerH, 0]);

    const root = select(svg).attr('width', width).attr('height', height);
    root.selectAll('*').remove(); // 간단: 전체 클리어 (성능 필요 시 update 패턴으로 전환)

    const g = root.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    g.append('g')
      .attr('transform', `translate(0, ${innerH})`)
      .call(axisBottom(x).ticks(5));
    g.append('g').call(axisLeft(y).ticks(4));

    const ln = line<{ x: Date; y: number }>()
      .x(d => x(d.x))
      .y(d => y(d.y));

    g.append('path')
      .datum(data)
      .attr('fill', 'none')
      .attr('stroke', '#2563eb')
      .attr('stroke-width', 2)
      .attr('d', ln);

    // 줌/팬 (x축만)
    const z = zoom<SVGRectElement, unknown>()
      .scaleExtent([0.5, 20])
      .translateExtent([[0, 0],[innerW, innerH]])
      .on('zoom', (ev) => {
        const t = ev.transform;
        const zx = t.rescaleX(x);
        g.select<SVGGElement>(':scope > g:nth-of-type(1)').call(axisBottom(zx).ticks(5)); // x axis 업데이트
        g.select('path').attr('d', line<{ x: Date; y: number }>().x(d=>zx(d.x)).y(d=>y(d.y))(data)!);
      });

    const rectPane = g.append('rect').attr('width', innerW).attr('height', innerH).attr('fill', 'transparent').style('cursor','grab').call(z as any);

    cleanup = () => { rectPane.on('.zoom', null); };
  }

  onMount(() => {
    resizeObs = new ResizeObserver(() => draw());
    resizeObs.observe(container);
    draw();
    return () => { resizeObs?.disconnect(); cleanup?.(); };
  });

  $: data, svg && draw(); // 데이터 변경 시 다시 그리기(간단 구현)
</script>

<div bind:this={container} class="viz"><svg bind:this={svg} /></div>

<style>
.viz { width: 100%; }
svg { display: block; }
</style>
```

사용:

```svelte
<script lang="ts">
  import D3Line from '$lib/viz/D3Line.svelte';
  const data = Array.from({length: 50}, (_, i) => ({ x: new Date(Date.now() - (50 - i)*3600e3), y: Math.round(20 + Math.random()*10) }));
</script>

<D3Line {data}/>
```

#### 팁

- **업데이트 패턴**(enter/update/exit)으로 성능 최적화 가능
- 대량 데이터(> 수만 포인트)는 **SVG 대신 Canvas** 또는 **WebGL(Three/Regl)** 권장
- 확대/축소 시 **축 레이블 겹침** → 간격/포맷 조건부 조정

---

### Canvas 렌더링(수만 포인트)

```svelte
<!-- src/lib/viz/D3ScatterCanvas.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { scaleLinear, extent } from 'd3';
  export let points: { x: number; y: number }[] = [];
  let canvas: HTMLCanvasElement;
  let container: HTMLDivElement;
  let ro: ResizeObserver;

  function draw() {
    const { width } = container.getBoundingClientRect();
    const height = 260;
    canvas.width = width * devicePixelRatio;
    canvas.height = height * devicePixelRatio;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    const ctx = canvas.getContext('2d')!;
    ctx.scale(devicePixelRatio, devicePixelRatio);
    ctx.clearRect(0,0,width,height);

    const x = scaleLinear().domain(extent(points, d=>d.x) as [number,number]).range([8,width-8]);
    const y = scaleLinear().domain(extent(points, d=>d.y) as [number,number]).range([height-8,8]);

    // 빠른 점 찍기
    ctx.fillStyle = '#0ea5e9';
    for (let i=0;i<points.length;i++){
      const p = points[i];
      ctx.fillRect(x(p.x), y(p.y), 2, 2);
    }
  }

  onMount(() => {
    ro = new ResizeObserver(draw);
    ro.observe(container);
    draw();
    return () => ro.disconnect();
  });

  $: points, canvas && draw();
</script>

<div bind:this={container}><canvas bind:this={canvas} /></div>
```

---

### 반응형 + 스크롤 가시성 렌더링(IntersectionObserver)

```svelte
<!-- src/lib/viz/VisibilityWrapper.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  export let onEnter: () => void = () => {};
  export let onExit: () => void = () => {};
  let el: HTMLDivElement;
  let io: IntersectionObserver;
  onMount(() => {
    io = new IntersectionObserver(([e]) => {
      if (e.isIntersecting) onEnter(); else onExit();
    }, { rootMargin: '200px' });
    io.observe(el);
    return () => io.disconnect();
  });
</script>

<div bind:this={el}><slot/></div>
```

---

## Three.js 통합

### 설치 & 기본 골격

```bash
pnpm add three
```

SSR-안전 패턴: `onMount`에서만 `three`를 import하고 DOM 엘리먼트에 렌더러 붙인다.

```svelte
<!-- src/lib/three/SpinningBox.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  let container: HTMLDivElement;
  let cleanup: () => void;

  export let color = 0x4f46e5;

  onMount(async () => {
    const THREE = await import('three');
    const { Scene, PerspectiveCamera, WebGLRenderer, BoxGeometry, MeshBasicMaterial, Mesh, Color, sRGBEncoding } = THREE;

    const scene = new Scene();
    const camera = new PerspectiveCamera(60, 1, 0.1, 100);
    camera.position.z = 2;

    const renderer = new WebGLRenderer({ antialias: true, alpha: true });
    renderer.outputEncoding = sRGBEncoding;
    container.appendChild(renderer.domElement);

    const cube = new Mesh(new BoxGeometry(1,1,1), new MeshBasicMaterial({ color: new Color(color) }));
    scene.add(cube);

    const ro = new ResizeObserver(() => {
      const r = container.getBoundingClientRect();
      renderer.setSize(r.width, r.height, false);
      camera.aspect = r.width / Math.max(1, r.height);
      camera.updateProjectionMatrix();
    });
    ro.observe(container);

    let raf = 0;
    const tick = () => {
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.02;
      renderer.render(scene, camera);
      raf = requestAnimationFrame(tick);
    };
    tick();

    cleanup = () => { cancelAnimationFrame(raf); ro.disconnect(); renderer.dispose(); };
  });

  onDestroy(() => cleanup?.());
</script>

<div class="stage" bind:this={container} />
<style>
.stage { width: 100%; height: 300px; border:1px solid #e5e7eb; border-radius:12px; }
canvas { display:block; width:100% !important; height:100% !important; }
</style>
```

사용:

```svelte
<SpinningBox color={0x22c55e}/>
```

---

### OrbitControls/라이팅/후처리

```svelte
<!-- src/lib/three/SceneWithControls.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  export let modelUrl: string | null = null; // glTF 등
  let div: HTMLDivElement; let cleanup: () => void;

  onMount(async () => {
    const THREE = await import('three');
    const { Scene, PerspectiveCamera, WebGLRenderer, Color, sRGBEncoding, AmbientLight, DirectionalLight, Clock } = THREE;
    const { OrbitControls } = await import('three/examples/jsm/controls/OrbitControls.js');
    const { GLTFLoader }   = await import('three/examples/jsm/loaders/GLTFLoader.js');

    const scene = new Scene();
    scene.background = new Color(0xf8fafc);
    const cam = new PerspectiveCamera(60, 1, 0.1, 100);
    cam.position.set(3,3,5);

    const renderer = new WebGLRenderer({ antialias: true });
    renderer.outputEncoding = sRGBEncoding;
    div.appendChild(renderer.domElement);

    const ctrl = new OrbitControls(cam, renderer.domElement);
    ctrl.enableDamping = true;

    scene.add(new AmbientLight(0xffffff, 0.6));
    const sun = new DirectionalLight(0xffffff, 1.0);
    sun.position.set(3,5,2);
    scene.add(sun);

    if (modelUrl) {
      const loader = new GLTFLoader();
      try {
        const gltf = await loader.loadAsync(modelUrl);
        scene.add(gltf.scene);
      } catch (e) { console.warn('GLTF load failed', e); }
    }

    const ro = new ResizeObserver(() => {
      const r = div.getBoundingClientRect();
      renderer.setSize(r.width, r.height, false);
      cam.aspect = r.width / Math.max(1, r.height);
      cam.updateProjectionMatrix();
    });
    ro.observe(div);

    const clock = new Clock();
    let raf=0;
    const tick = () => {
      const dt = clock.getDelta();
      ctrl.update();
      renderer.render(scene, cam);
      raf = requestAnimationFrame(tick);
    };
    tick();

    cleanup = () => { cancelAnimationFrame(raf); ro.disconnect(); ctrl.dispose(); renderer.dispose(); };
  });

  onDestroy(()=> cleanup?.());
</script>

<div class="stage" bind:this={div}/>
<style>.stage{ width:100%; height:360px; border:1px solid #e5e7eb; border-radius:12px; }</style>
```

#### 성능 팁

- 메시/머티리얼 **dispose**로 메모리 누수 방지
- 텍스처는 **텍스처 압축**(KTX2, Basis) 고려
- **requestAnimationFrame** 중단(가시영역 밖) → `IntersectionObserver`로 제어

---

## MapLibre GL JS 통합

### 설치 & 기본 지도

```bash
pnpm add maplibre-gl
```

```svelte
<!-- src/lib/map/MapBasic.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import type { Map } from 'maplibre-gl';

  export let style = 'https://demotiles.maplibre.org/style.json';
  export let center: [number, number] = [127.0, 37.5]; // [lng, lat]
  export let zoom = 6;

  let map: Map; let el: HTMLDivElement;

  onMount(async () => {
    const maplibregl = await import('maplibre-gl');
    map = new maplibregl.Map({
      container: el,
      style,
      center,
      zoom,
      hash: false
    });

    map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), 'top-right');

    map.on('load', () => {
      // 예시: 원형 레이어 추가
      map.addSource('cities', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [
          { type:'Feature', properties: {name:'Seoul'}, geometry:{ type:'Point', coordinates:[126.9780, 37.5665]} },
          { type:'Feature', properties: {name:'Busan'}, geometry:{ type:'Point', coordinates:[129.0756, 35.1796]} },
        ]}
      });
      map.addLayer({
        id:'city-points', type:'circle', source:'cities',
        paint: { 'circle-radius': 6, 'circle-color':'#ef4444', 'circle-stroke-width':1, 'circle-stroke-color':'#fff' }
      });
    });
  });

  onDestroy(()=> map?.remove());
</script>

<div bind:this={el} class="map"/>
<style>.map{ width:100%; height:380px; }</style>
```

---

### 동적 데이터 업데이트 & 인터랙션

```svelte
<!-- src/lib/map/MapInteractive.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  let map: any; let el: HTMLDivElement;
  export let points: { id: string; name: string; lng: number; lat: number }[] = [];

  function toGeoJSON(){
    return {
      type: 'FeatureCollection',
      features: points.map(p => ({
        type: 'Feature',
        properties: { id: p.id, name: p.name },
        geometry: { type: 'Point', coordinates: [p.lng, p.lat] }
      }))
    };
  }

  onMount(async () => {
    const maplibregl = await import('maplibre-gl');
    map = new maplibregl.Map({
      container: el,
      style: 'https://demotiles.maplibre.org/style.json',
      center: [127, 37.5], zoom: 6
    });

    map.on('load', () => {
      map.addSource('pts', { type: 'geojson', data: toGeoJSON() });
      map.addLayer({ id:'pts-layer', type:'circle', source:'pts', paint:{ 'circle-radius': 5, 'circle-color': '#0ea5e9', 'circle-stroke-color':'#fff', 'circle-stroke-width':1 } });

      map.on('mouseenter', 'pts-layer', () => map.getCanvas().style.cursor='pointer');
      map.on('mouseleave', 'pts-layer', () => map.getCanvas().style.cursor='');

      map.on('click', 'pts-layer', (e: any) => {
        const f = e.features?.[0];
        if (!f) return;
        const [lng, lat] = f.geometry.coordinates;
        new maplibregl.Popup().setLngLat([lng, lat]).setHTML(`<strong>${f.properties.name}</strong>`).addTo(map);
      });
    });
  });

  $: if (map && map.isStyleLoaded() && map.getSource('pts')) {
    map.getSource('pts').setData(toGeoJSON());
  }

  onDestroy(()=> map?.remove());
</script>

<div bind:this={el} class="map" />
<style>.map{ width:100%; height:380px; }</style>
```

**성능 팁**
- 잦은 `setData`는 비용 큼 → **diffing/클러스터링**(supercluster) 고려
- 대규모 포인트(>10만): **vector tile**로 전처리 후 레이어로 렌더링
- 지도 인스턴스는 **페이지 전환시 clean-up** 철저

---

## 세 통합 조합: MapLibre + D3 오버레이

MapLibre 위에 **SVG 오버레이**를 깔고 D3로 렌더(스크린 좌표 변환 사용).

```svelte
<!-- src/lib/map/MapWithD3Overlay.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { select } from 'd3';
  let map: any; let root: HTMLDivElement; let svg: SVGSVGElement; let g: SVGGElement;

  export let points: { lng: number; lat: number; v: number }[] = [];

  function project(lng: number, lat: number) {
    const p = map.project([lng, lat]); // {x, y}
    return [p.x, p.y];
  }

  function draw() {
    if (!map || !map.isStyleLoaded()) return;
    const sel = select(g).selectAll('circle').data(points, (d:any)=>`${d.lng},${d.lat}`);
    sel.enter().append('circle').attr('r', 4).attr('fill', '#22c55e')
      .merge(sel as any)
      .attr('cx', d => project(d.lng, d.lat)[0])
      .attr('cy', d => project(d.lng, d.lat)[1]);
    sel.exit().remove();
  }

  onMount(async () => {
    const maplibregl = await import('maplibre-gl');
    map = new maplibregl.Map({ container: root, style: 'https://demotiles.maplibre.org/style.json', center:[127,37.5], zoom: 6 });
    map.on('load', () => {
      const canvas = map.getCanvasContainer();
      // SVG 오버레이
      svg = select(canvas.parentElement).append('svg').style('position','absolute').style('top','0').style('left','0').attr('width','100%').attr('height','100%').node() as any;
      g = select(svg).append('g').node() as any;

      map.on('move', draw);
      map.on('zoom', draw);
      draw();
    });
  });

  $: points, draw();
  onDestroy(()=> map?.remove());
</script>

<div bind:this={root} class="map"/>
<style>.map{ width:100%; height:420px; position:relative; }</style>
```

---

## 데스크톱 포장

### Tauri (권장: 가볍고 빠름)

```bash
pnpm add -D @tauri-apps/cli
pnpm tauri init
```

질문에 맞춰 `dist` 폴더 경로를 SvelteKit 빌드 결과(`/build` 또는 `adapter-static` 시 `/build`)로 매핑한다. 권장 플로우:

- **개발 모드**: SvelteKit dev 서버를 Tauri가 프록시 (tauri `devPath`)
- **프로덕션**: `svelte-kit build` -> 정적/SSR 결과를 `tauri build`가 `distDir`로 패키징

`src-tauri/tauri.conf.json` 예시(핵심 발췌):

```json
{
  "build": { "beforeBuildCommand": "pnpm build", "beforeDevCommand": "pnpm dev" },
  "tauri": {
    "bundle": { "active": true, "targets": "all" },
    "allowlist": { "all": false, "shell": { "all": false, "execute": false } },
    "windows": [{ "title": "SvelteKit App", "width": 1200, "height": 800, "resizable": true }]
  }
}
```

개발:

```bash
pnpm tauri dev
```

빌드:

```bash
pnpm tauri build
```

**SvelteKit 어댑터 선택**
- 단순 SPA/정적: `adapter-static` → Tauri WebView에서 파일 제공
- 내부 API/SSR 사용: 로컬 서버를 함께 띄우거나, **셋업 단순화를 위해 SPA 빌드**를 권장

**파일시스템/API 접근**
- `src-tauri/src/main.rs` 에서 tauri 플러그인/커맨드 정의 → 프론트엔드에서 `@tauri-apps/api`로 호출

```ts
// 예: 프론트엔드 호출 (권한 있는 범위만)
import { dialog } from '@tauri-apps/api';
const path = await dialog.open({ directory: true });
```

---

### Electron

```bash
pnpm add -D electron electron-builder concurrently
```

간단한 메인 프로세스:

```ts
// electron/main.ts
import { app, BrowserWindow } from 'electron';
import path from 'node:path';
let win: BrowserWindow | null = null;

async function create() {
  win = new BrowserWindow({ width: 1200, height: 800, webPreferences: { nodeIntegration: false, contextIsolation: true } });
  if (process.env.VITE_DEV_SERVER_URL) {
    await win.loadURL(process.env.VITE_DEV_SERVER_URL);
    win.webContents.openDevTools();
  } else {
    await win.loadFile(path.join(__dirname, '../dist/index.html')); // adapter-static 기준
  }
}
app.whenReady().then(create);
app.on('window-all-closed', () => { if (process.platform !== 'darwin') app.quit(); });
```

`package.json` 스크립트:

```json
{
  "scripts": {
    "dev": "concurrently \"pnpm -C . run dev\" \"cross-env VITE_DEV_SERVER_URL=http://localhost:5173 electron .\"",
    "build:web": "svelte-kit build",
    "build:electron": "electron-builder"
  }
}
```

**보안 주의**: NodeIntegration 꺼두고 IPC로만 통신. CSP 설정.

---

## 모바일 포장 — Capacitor

```bash
pnpm add @capacitor/core
pnpm add -D @capacitor/cli
npx cap init
```

`capacitor.config.ts`:

```ts
import { CapacitorConfig } from '@capacitor/cli';
const config: CapacitorConfig = {
  appId: 'com.example.sveltekit',
  appName: 'SvelteKit App',
  webDir: 'build', // svelte-kit build 결과(정적)
  server: { androidScheme: 'https' }
};
export default config;
```

플랫폼 추가:

```bash
pnpm build         # svelte-kit build (adapter-static)
npx cap add android
npx cap add ios
npx cap sync
```

개발/실행:

```bash
npx cap open android
npx cap open ios
```

**네이티브 기능**(카메라, 파일, 기기 정보 등)은 Capacitor 플러그인을 통해 접근:

```ts
import { Device } from '@capacitor/device';
const info = await Device.getInfo();
```

> SSR/라우터: 모바일에서 **SPA 정적 배포**가 무난. 내부 API는 네이티브 HTTP/프록시 또는 별도 서버 사용.

---

## 공통 고려 사항

### SSR/CSR 격리

- 시각화/지도/웹GL은 **브라우저 API 의존** → **`onMount` + dynamic import**
- +page.ts(서버 load)에서 데이터만 준비하고, 시각화 렌더는 클라이언트에서 실행

### 타입/빌드

- `skipLibCheck: true`로 빠른 빌드 유지하되, 외부 라이브러리 타입은 명시 import
- `vite.optimizeDeps.exclude`로 `three/examples/*` 불필요 사전 번들 제외

```ts
// vite.config.ts
export default defineConfig({
  optimizeDeps: { exclude: ['three/examples/jsm/*'] }
});
```

### 접근성(A11y)

- SVG 요소에 `role="img"` + `aria-label` 제공
- 3D/지도 컨테이너는 대체 텍스트/설명 제공, 키보드 내비 방법 문서화
- 색 대비, 포커스 링, 모션 민감자(`prefers-reduced-motion`) 고려

### 성능/메모리

- **dispose**(Three 텍스처/지오메트리/머티리얼/렌더러)
- MapLibre 레이어/소스 제거 시 `removeLayer` → `removeSource` 순서
- D3 SVG 업데이트는 **선택적 diff**로 최소 변경
- `requestIdleCallback`로 비필수 작업 지연

---

## 종합 페이지 예시(+page.svelte)

```svelte
<!-- src/routes/advanced/+page.svelte -->
<script lang="ts">
  import D3Line from '$lib/viz/D3Line.svelte';
  import SceneWithControls from '$lib/three/SceneWithControls.svelte';
  import MapInteractive from '$lib/map/MapInteractive.svelte';

  const d3data = Array.from({length: 100}, (_,i)=>({ x: new Date(Date.now()- (100-i)*3600e3), y: 20 + Math.random()*15 }));

  const cities = [
    { id:'seoul', name:'Seoul', lng:126.9780, lat:37.5665 },
    { id:'busan', name:'Busan', lng:129.0756, lat:35.1796 }
  ];
</script>

<h1>고급 통합 데모</h1>

<section>
  <h2>D3 라인</h2>
  <D3Line data={d3data}/>
</section>

<section>
  <h2>Three.js 3D</h2>
  <SceneWithControls modelUrl={null}/>
</section>

<section>
  <h2>MapLibre 인터랙티브</h2>
  <MapInteractive points={cities}/>
</section>
```

---

## 배포 전략

- **웹만**: Vercel/Netlify/Cloudflare Pages (정적 + CSR)
- **데스크톱**: Tauri 권장(메모리/배포 크기 우수), Electron은 풍부한 에코시스템
- **모바일**: Capacitor로 iOS/Android 빌드. 네이티브 권한/스토어 정책 준수
- **지도 타일**: 상용/자체 호스팅 타일 서버 SLA/쿼터 체크

---

## 테스트 & 디버깅

- **시각화**: 스냅샷보단 **단위 함수(스케일, 데이터 파이프라인)** 테스트
- **Three**: 렌더 결과는 E2E 스크린샷(Playwright) + 임계 경로 로깅
- **MapLibre**: 이벤트 핸들러, setData 호출 횟수, 클러스터링 정확도 테스트
- **데스크톱/모바일**: 파일 접근 권한/경로, 윈도우 리사이즈/회전 대응

---

## 수학 코너(성능 수식, 선택)

샘플 다운샘플 비율:
$$
r = \left\lceil \frac{N}{P} \right\rceil
$$
- \(N\): 원본 포인트 수, \(P\): 픽셀 수(가로폭)
- 다운샘플은 **픽셀당 최대 한 포인트**만 유지 → SVG 오버드로잉 방지

프레임 예산:
$$
t_\mathrm{frame} = \frac{1000}{60} \approx 16.7\ \mathrm{ms}
$$
- 각 루프(계산 + 렌더)가 \(< 16.7\)ms를 넘지 않도록 프로파일링

---

## 체크리스트

- [ ] D3/Three/MapLibre는 **onMount + dynamic import**
- [ ] 리사이즈/가시성 옵저버로 **불필요한 렌더 최소화**
- [ ] 대용량 데이터: **Canvas/WebGL/Vector tile/클러스터링**
- [ ] dispose/cleanup 누락 없게
- [ ] 포장(Tauri/Electron/Capacitor) 시 **정적 빌드/라우팅** 검증
- [ ] 모바일 권한/스토어 정책/스크린 회전 UI 확인

---

## 마무리

이 장의 예제들을 토대로 **데이터 시각화 대시보드**, **3D 뷰어**, **인터랙티브 지도 앱**을 웹/데스크톱/모바일로 한 번에 전개할 수 있다.
핵심은 **SSR-안전한 초기화**, **자원 해제**, **데이터 크기 조절**이며, 포장 단계에서는 **정적 배포 전략**과 **권한 관리**까지 챙기면 프로덕션 수준의 통합이 가능하다.

---
```md
**다음 단계**
- MapLibre + Three.js **3D 타일(terrain)** 오버레이
- Three 인스턴스 공유 + 포스트프로세싱 파이프라인
- D3 데이터 파이프라인에 워커(Web Worker) 도입(파싱/집계)
- 오프라인 패키징(Tauri FS/Capacitor Filesystem) + 저장소 캐시(IndexedDB)
```
