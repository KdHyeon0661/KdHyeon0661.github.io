---
layout: post
title: Avalonia - 개요
date: 2024-12-29 19:20:23 +0900
category: Avalonia
---
# Avalonia 소개 및 VS Code에서 시작하기 — 설치·프로젝트 구조·MVVM·스타일링·배포까지 (확장판)

본 문서는 사용자가 제공한 초안(“Avalonia란?”, “설치”, “VS Code에서 시작”, “간단한 XAML 수정”)을 **핵심을 유지**하면서 **대폭 확장**한 가이드이다.
WPF 경험을 가진 .NET 개발자가 **Windows·Linux·macOS·(선택적으로 WebAssembly/모바일)**까지 아우르는 Avalonia 앱을 **VS Code만으로** 만들고, **MVVM** 구조, **데이터 바인딩**, **스타일링/리소스**, **테스팅**, **핫 리로드**, **배포**까지 한 번에 정리한다.

---

## 1. Avalonia란?

**Avalonia**는 .NET 기반의 **크로스 플랫폼 UI 프레임워크**이다.
**XAML**로 UI를 기술하고, **MVVM** 패턴을 1급 지원하며, **하드웨어 가속** 렌더링과 **모던 스타일**을 제공한다. WPF와 유사한 개발 경험을 제공하지만, WPF가 Windows 전용인 것과 달리 Avalonia는 **Windows, Linux, macOS**를 기본 타깃으로 한다. (WebAssembly/모바일은 선택적으로 설정 가능)

### 1.1 주요 특징 (핵심 재정리 + 확장)
- XAML 기반 UI: WPF 개발자가 바로 적응 가능
- MVVM 패턴: 테스트 용이성, 관심사 분리, 확장성
- 하드웨어 가속 렌더링: 고해상도/고주사율 디스플레이에서도 매끄러운 UI
- 스타일링/리소스 시스템: 전역 테마, 컨트롤별 스타일, DataTemplate, 리소스 딕셔너리
- 오픈소스/커뮤니티: 이슈/예제/컨트롤 생태계 성장 중
- 멀티 플랫폼: 하나의 코드베이스로 데스크톱 전역 (선택적으로 브라우저/WebAssembly, 모바일)

### 1.2 왜 Avalonia인가? (표 재구성 + 보강)

| 이유 | 설명 |
|------|------|
| 크로스 플랫폼 | 단일 코드베이스로 Windows·Linux·macOS (선택: WebAssembly/모바일) |
| WPF 친화성 | XAML·바인딩·리소스 등 WPF 지식 재사용 |
| MVVM 지원 | INotifyPropertyChanged, ICommand, DataTemplate 기반 구조 |
| 생태계·업데이트 | 활발한 개선과 예제 자료 축적 |
| 배포 유연성 | self-contained, single-file(선택), 각 OS 네이티브 런처 패키징 용이 |

---

## 2. 개발 환경 준비

### 2.1 .NET SDK 설치 (필수)
Avalonia는 일반적으로 .NET 6 이상에서 작동한다. (권장: 최신 LTS/STS)

- 다운로드:
  https://dotnet.microsoft.com/en-us/download

설치 확인:

```bash
dotnet --version
```

### 2.2 Avalonia 템플릿 설치
프로젝트 생성을 위한 템플릿 설치:

```bash
dotnet new install Avalonia.Templates
```

설치된 템플릿 확인:

```bash
dotnet new --list | grep Avalonia
```

> `grep`이 없는 Windows PowerShell에선 `dotnet new --list`만 실행 후 수동 확인.

### 2.3 VS Code 확장 (권장)
- C# (C# Dev Kit 또는 OmniSharp 계열 중 사용 환경에 맞게)
- Avalonia for Visual Studio Code (XAML 인텔리센스/도움)
- .NET Install Tool for Extension Authors (일부 확장에서 필요)

설치 후 VS Code 재시작 권장.

---

## 3. 첫 프로젝트 만들기와 실행

### 3.1 프로젝트 생성

```bash
dotnet new avalonia.app -o MyAvaloniaApp
cd MyAvaloniaApp
```

> `avalonia.app` 템플릿은 데스크톱 타깃을 기본으로 한다. 여기서 출발해 구조와 패턴을 다진 뒤, 필요 시 WebAssembly/모바일을 검토한다.

### 3.2 실행

```bash
dotnet run
```

기본 창이 뜨면 성공이다.

---

## 4. 솔루션 구조와 핵심 파일 이해

기본 템플릿 기준(간소화하여 예시):

```
MyAvaloniaApp/
  MyAvaloniaApp.csproj
  Program.cs
  App.axaml
  App.axaml.cs
  MainWindow.axaml
  MainWindow.axaml.cs
```

- `Program.cs`: 앱 부트스트랩 (AppBuilder)
- `App.axaml`: 전역 리소스/스타일/테마 지정
- `MainWindow.axaml`: 첫 화면 레이아웃
- `*.axaml.cs`: XAML의 코드 비하인드(이벤트, 초기화 등)

### 4.1 Program.cs (부트스트랩)

```csharp
using Avalonia;
using System;

namespace MyAvaloniaApp
{
    internal static class Program
    {
        [STAThread] // Windows에서 UI 스레드 STA 필요
        public static void Main(string[] args)
        {
            BuildAvaloniaApp()
                .StartWithClassicDesktopLifetime(args);
        }

        public static AppBuilder BuildAvaloniaApp()
            => AppBuilder.Configure<App>()
                .UsePlatformDetect()   // 현재 OS에 맞는 플랫폼 초기화
                .LogToTrace();         // 디버그 로그
    }
}
```

### 4.2 App.axaml (전역 리소스/스타일/테마)

```xml
<!-- App.axaml -->
<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyAvaloniaApp.App">
  <Application.Styles>
    <!-- Fluent 테마/스타일 포함 (템플릿에 따라 이미 포함) -->
    <FluentTheme Mode="Light"/>
    <!-- 전역 스타일/리소스 사전 추가 가능 -->
    <StyleSelector/>
  </Application.Styles>
</Application>
```

### 4.3 MainWindow.axaml (기본 화면)

```xml
<!-- MainWindow.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="MyAvaloniaApp.MainWindow"
        Width="480" Height="300"
        Title="My Avalonia App">
  <StackPanel Margin="16" Spacing="8" HorizontalAlignment="Stretch">
    <TextBlock Text="Hello Avalonia" FontSize="20" />
    <Button Content="클릭하세요!" Width="160" />
  </StackPanel>
</Window>
```

---

## 5. MVVM 구조로 확장하기 (CommunityToolkit.Mvvm 예시)

WPF와 동일하게 Avalonia에서도 MVVM이 자연스럽다.
여기서는 **Microsoft CommunityToolkit.Mvvm**을 사용해 **INotifyPropertyChanged**, **ICommand**를 간결하게 구성한다.

### 5.1 패키지 설치

```bash
dotnet add package CommunityToolkit.Mvvm
```

### 5.2 폴더 구조 권장안

```
MyAvaloniaApp/
  Models/
  ViewModels/
  Views/
```

### 5.3 Model 예시 (간단한 Todo 항목)

```csharp
// Models/TodoItem.cs
namespace MyAvaloniaApp.Models
{
    public sealed class TodoItem
    {
        public string Title { get; }
        public bool IsDone { get; private set; }

        public TodoItem(string title, bool isDone = false)
        {
            Title = title;
            IsDone = isDone;
        }

        public void Toggle() => IsDone = !IsDone;
    }
}
```

### 5.4 ViewModel 예시 (ObservableCollection + 커맨드)

```csharp
// ViewModels/MainViewModel.cs
using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using MyAvaloniaApp.Models;

namespace MyAvaloniaApp.ViewModels
{
    public partial class MainViewModel : ObservableObject
    {
        [ObservableProperty]
        private string? newTitle;

        public ObservableCollection<TodoItem> Items { get; } = new();

        public MainViewModel()
        {
            // 초기 데이터
            Items.Add(new TodoItem("첫 번째 작업"));
            Items.Add(new TodoItem("두 번째 작업"));
        }

        [RelayCommand(CanExecute = nameof(CanAdd))]
        private void Add()
        {
            if (!string.IsNullOrWhiteSpace(NewTitle))
            {
                Items.Add(new TodoItem(NewTitle));
                NewTitle = string.Empty;
            }
        }

        private bool CanAdd() => !string.IsNullOrWhiteSpace(NewTitle);
    }
}
```

> `ObservableObject`, `RelayCommand`를 통해 INotifyPropertyChanged, ICommand 구현이 간결해진다.

### 5.5 DataContext 연결 (코드비하인드 최소화)

```csharp
// MainWindow.axaml.cs
using Avalonia.Controls;
using MyAvaloniaApp.ViewModels;

namespace MyAvaloniaApp
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            DataContext = new MainViewModel();
        }
    }
}
```

### 5.6 바인딩 UI (TextBox + Button Command + ListBox)

```xml
<!-- Views/MainWindow.axaml (또는 기존 MainWindow.axaml) -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="https://github.com/avaloniaui/2016/xaml"
        xmlns:vm="using:MyAvaloniaApp.ViewModels"
        x:Class="MyAvaloniaApp.MainWindow"
        Width="560" Height="360"
        Title="Todo Sample">
  <Design.DataContext>
    <vm:MainViewModel/>
  </Design.DataContext>

  <StackPanel Margin="16" Spacing="12">
    <TextBlock Text="할 일 추가" FontSize="20" />
    <DockPanel>
      <TextBox Text="{Binding NewTitle, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
               Watermark="새 작업 입력..."
               Width="360" />
      <Button Content="추가"
              Command="{Binding AddCommand}"
              Margin="8,0,0,0" />
    </DockPanel>

    <Separator/>

    <ItemsControl Items="{Binding Items}">
      <ItemsControl.ItemTemplate>
        <DataTemplate>
          <DockPanel Margin="0,4">
            <TextBlock Text="{Binding Title}" />
            <TextBlock Text="{Binding IsDone}" DockPanel.Dock="Right" />
          </DockPanel>
        </DataTemplate>
      </ItemsControl.ItemTemplate>
    </ItemsControl>
  </StackPanel>
</Window>
```

> `Design.DataContext`는 VS Code의 XAML 디자인 타임 힌트에 도움을 준다.

---

## 6. 스타일·리소스·DataTemplate 제대로 쓰기

### 6.1 전역 리소스 딕셔너리

리소스(브러시, 두께, 마진, 문자열 등)를 중앙 집중화:

```xml
<!-- App.axaml -->
<Application ...>
  <Application.Resources>
    <ResourceDictionary>
      <SolidColorBrush x:Key="BrandBrush" Color="#3B82F6" />
      <Thickness x:Key="PagePadding">24</Thickness>

      <Style Selector="Button.confirm">
        <Setter Property="Background" Value="{StaticResource BrandBrush}" />
        <Setter Property="Foreground" Value="White" />
      </Style>
    </ResourceDictionary>
  </Application.Resources>

  <Application.Styles>
    <FluentTheme Mode="Light"/>
  </Application.Styles>
</Application>
```

사용:

```xml
<Button Classes="confirm" Content="확인" Padding="{StaticResource PagePadding}" />
```

### 6.2 컨트롤 타깃팅 스타일

특정 타입에 대한 일괄 스타일:

```xml
<Style Selector="TextBlock">
  <Setter Property="FontSize" Value="14" />
</Style>
```

### 6.3 DataTemplate: 타입→뷰 변환

```xml
<DataTemplate DataType="{x:Type vm:MainViewModel}">
  <views:MainView/>
</DataTemplate>
```

> ViewLocator 패턴과 조합하여 이름 규칙(`HomeViewModel`→`HomeView`) 기반 자동 매핑도 가능하다.

---

## 7. Converter, Validation, 트리거

### 7.1 IValueConverter

```csharp
// Converters/BoolToTextConverter.cs
using System;
using Avalonia.Data.Converters;
using System.Globalization;

namespace MyAvaloniaApp.Converters
{
    public class BoolToTextConverter : IValueConverter
    {
        public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
            => value is bool b && b ? "완료" : "진행 중";

        public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
            => (value as string) == "완료";
    }
}
```

XAML 등록/사용:

```xml
<Window xmlns:conv="using:MyAvaloniaApp.Converters">
  <Window.Resources>
    <conv:BoolToTextConverter x:Key="BoolToText"/>
  </Window.Resources>

  <TextBlock Text="{Binding IsDone, Converter={StaticResource BoolToText}}"/>
</Window>
```

### 7.2 Validation (DataAnnotations 예시)

```csharp
// ViewModels/AccountViewModel.cs
using System.ComponentModel.DataAnnotations;
using CommunityToolkit.Mvvm.ComponentModel;

public partial class AccountViewModel : ObservableValidator
{
    [ObservableProperty]
    [Required(ErrorMessage = "사용자 이름은 필수입니다.")]
    private string? userName;

    [ObservableProperty]
    [EmailAddress(ErrorMessage = "이메일 형식이 아닙니다.")]
    private string? email;

    partial void OnUserNameChanged(string? value) => ValidateAllProperties();
    partial void OnEmailChanged(string? value) => ValidateAllProperties();
}
```

XAML에서 에러 표현:

```xml
<TextBox Text="{Binding UserName, Mode=TwoWay}"/>
<TextBlock Foreground="Red" Text="{Binding (Validation.Errors)[0].ErrorContent, RelativeSource={RelativeSource AncestorType=TextBox}}" />
```

---

## 8. 리스트·그리드 UI (ItemsControl, ListBox, DataGrid)

### 8.1 ListBox + 선택 바인딩

```xml
<ListBox Items="{Binding Items}" SelectedItem="{Binding SelectedItem, Mode=TwoWay}">
  <ListBox.ItemTemplate>
    <DataTemplate>
      <StackPanel Orientation="Horizontal" Spacing="8">
        <CheckBox IsChecked="{Binding IsDone}"/>
        <TextBlock Text="{Binding Title}"/>
      </StackPanel>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
```

ViewModel에 `SelectedItem` 프로퍼티를 추가하면 상세 패널 구현이 쉬워진다.

### 8.2 DataGrid (대량 데이터/컬럼 바인딩)

```bash
dotnet add package Avalonia.Controls.DataGrid
```

```xml
<DataGrid Items="{Binding Items}" AutoGenerateColumns="False" HeadersVisibility="Column">
  <DataGrid.Columns>
    <DataGridTextColumn Header="Title" Binding="{Binding Title}" />
    <DataGridCheckBoxColumn Header="Done" Binding="{Binding IsDone}" />
  </DataGrid.Columns>
</DataGrid>
```

---

## 9. DI 구성과 멀티 윈도우/네비게이션

간단한 앱에서는 `new MainViewModel()`로 충분하지만, 규모가 커지면 **DI 컨테이너**로 ViewModel/서비스를 주입한다.

### 9.1 간단 DI (Microsoft.Extensions.DependencyInjection)

```bash
dotnet add package Microsoft.Extensions.DependencyInjection
```

```csharp
// App.axaml.cs
using Microsoft.Extensions.DependencyInjection;
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;

public partial class App : Application
{
    public static ServiceProvider Services { get; private set; } = default!;

    public override void Initialize()
    {
        AvaloniaXamlLoader.Load(this);
        var sc = new ServiceCollection();

        sc.AddSingleton<ViewModels.MainViewModel>();
        // sc.AddTransient<... 서비스들 ...>

        Services = sc.BuildServiceProvider();
    }

    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            var vm = Services.GetRequiredService<ViewModels.MainViewModel>();
            desktop.MainWindow = new MainWindow { DataContext = vm };
        }
        base.OnFrameworkInitializationCompleted();
    }
}
```

> 이 방식이면 어디서나 `App.Services.GetRequiredService<>()`로 필요한 인스턴스를 불러올 수 있어 테스트와 모듈화가 쉬워진다.

---

## 10. 핫 리로드, 로깅, 디버깅

### 10.1 dotnet watch (핫 리로드)

```bash
dotnet watch
```

XAML/코드 변경 시 앱이 자동으로 재시작되거나 UI가 갱신된다(환경에 따라 다를 수 있음).

### 10.2 로깅

`AppBuilder.LogToTrace()`는 기본 트레이스 로그를 활성화한다.
VS Code의 디버그 콘솔 또는 터미널에서 로그를 확인한다.

### 10.3 VS Code launch.json 예시

`.vscode/launch.json`:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": ".NET Launch",
      "type": "coreclr",
      "request": "launch",
      "preLaunchTask": "build",
      "program": "${workspaceFolder}/bin/Debug/net8.0/MyAvaloniaApp.dll",
      "args": [],
      "cwd": "${workspaceFolder}",
      "stopAtEntry": false
    }
  ]
}
```

`.vscode/tasks.json`:

```json
{
  "version": "2.0.0",
  "tasks": [
    { "label": "build", "command": "dotnet", "type": "process", "args": [ "build" ] }
  ]
}
```

> 실제 `netX.Y` 프레임워크 폴더는 프로젝트 설정에 맞게 수정한다.

---

## 11. 스타일링 심화: 테마·리소스 분리·컨트롤 상태

### 11.1 리소스 분리

```
Resources/
  Colors.axaml
  Spacing.axaml
  Styles.axaml
```

`App.axaml`에서 머지:

```xml
<Application.Resources>
  <ResourceDictionary>
    <ResourceDictionary.MergedDictionaries>
      <ResourceInclude Source="avares://MyAvaloniaApp/Resources/Colors.axaml"/>
      <ResourceInclude Source="avares://MyAvaloniaApp/Resources/Spacing.axaml"/>
      <ResourceInclude Source="avares://MyAvaloniaApp/Resources/Styles.axaml"/>
    </ResourceDictionary.MergedDictionaries>
  </ResourceDictionary>
</Application.Resources>
```

### 11.2 상태 기반 스타일

```xml
<Style Selector="Button:pointerover">
  <Setter Property="Opacity" Value="0.9"/>
</Style>

<Style Selector="Button:pressed">
  <Setter Property="RenderTransform">
    <Setter.Value>
      <ScaleTransform ScaleX="0.98" ScaleY="0.98"/>
    </Setter.Value>
  </Setter>
</Style>
```

---

## 12. 다국어(로컬라이제이션) 초석

간단한 자원 기반 문자열:

```xml
<!-- Strings.axaml -->
<ResourceDictionary xmlns="https://github.com/avaloniaui"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <x:String x:Key="App.Title">작업 관리자</x:String>
  <x:String x:Key="Button.Add">추가</x:String>
</ResourceDictionary>
```

사용:

```xml
<Button Content="{StaticResource Button.Add}" />
```

> 실서비스에서는 `resx` 또는 전용 로컬라이제이션 레이어를 사용하고, 문화권 변경에 따라 동적 로딩을 구현한다.

---

## 13. 테스트 전략

### 13.1 ViewModel 단위 테스트 (xUnit)

```bash
dotnet new xunit -o MyAvaloniaApp.Tests
cd MyAvaloniaApp.Tests
dotnet add reference ../MyAvaloniaApp/MyAvaloniaApp.csproj
```

테스트 예시:

```csharp
using MyAvaloniaApp.ViewModels;
using Xunit;

public class MainViewModelTests
{
    [Fact]
    public void AddCommand_ShouldAddItem_WhenNewTitleIsValid()
    {
        var vm = new MainViewModel();
        vm.NewTitle = "테스트";
        vm.AddCommand.Execute(null);

        Assert.Contains(vm.Items, it => it.Title == "테스트");
    }
}
```

> ViewModel 테스트는 Avalonia 런타임 없이 수행 가능하므로 CI에서 빠르게 돈다.

---

## 14. 배포 (self-contained, 런타임 지정, 단일 파일 선택)

### 14.1 기본 self-contained 배포

Windows x64:

```bash
dotnet publish -c Release -r win-x64 --self-contained true
```

Linux x64:

```bash
dotnet publish -c Release -r linux-x64 --self-contained true
```

macOS x64:

```bash
dotnet publish -c Release -r osx-x64 --self-contained true
```

출력물은 `bin/Release/<TFM>/<RID>/publish/`에 생성된다.

### 14.2 단일 파일(선택)

```bash
dotnet publish -c Release -r win-x64 -p:PublishSingleFile=true --self-contained true
```

> 단일 파일은 시작 속도/크기 균형을 검토. 플랫폼별 서명/권한(예: macOS Gatekeeper) 고려.

---

## 15. WebAssembly/모바일에 대한 간단한 방향

- **WebAssembly**: 별도 템플릿/프로젝트로 구성하여 브라우저에서 호스팅되는 프런트엔드로 실행한다. 데스크톱과 코드 공유를 극대화하려면 UI·ViewModel를 공용 라이브러리로 분리한다.
- **모바일(Android/iOS)**: 모바일 플랫폼 프로젝트를 별도로 추가하고 공용 로직(모델/뷰모델/서비스)을 공유한다. 네이티브 권한·입력·해상도 대응과 앱 스토어 배포 체인을 감안한다.

> 본 문서는 **데스크톱**을 실전 기준으로 상세 설명했고, WebAssembly/모바일은 프로젝트 분리 및 공용 계층 설계 원칙 중심으로 접근하자.

---

## 16. 예제: 간단한 탭 네비게이션과 다이얼로그

### 16.1 탭 기반 레이아웃

```xml
<TabControl>
  <TabItem Header="할 일">
    <views:MainView/>
  </TabItem>
  <TabItem Header="통계">
    <views:StatsView/>
  </TabItem>
</TabControl>
```

### 16.2 다이얼로그 호출 (Window.ShowDialog)

```csharp
// Views/Dialogs/InputDialog.axaml.cs
using Avalonia.Controls;
using System.Threading.Tasks;

public partial class InputDialog : Window
{
    public string? Result { get; private set; }

    public InputDialog()
    {
        InitializeComponent();
    }

    private void OnOk(object? sender, Avalonia.Interactivity.RoutedEventArgs e)
    {
        Result = this.FindControl<TextBox>("InputBox").Text;
        Close(Result);
    }

    private void OnCancel(object? sender, Avalonia.Interactivity.RoutedEventArgs e)
        => Close(null);

    public static Task<string?> ShowAsync(Window owner)
    {
        var dlg = new InputDialog();
        return dlg.ShowDialog<string?>(owner);
    }
}
```

XAML:

```xml
<!-- Views/Dialogs/InputDialog.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="MyAvaloniaApp.Views.Dialogs.InputDialog"
        Width="360" Height="160" Title="입력">
  <StackPanel Margin="16" Spacing="8">
    <TextBlock Text="값을 입력하세요."/>
    <TextBox x:Name="InputBox" />
    <StackPanel Orientation="Horizontal" HorizontalAlignment="Right" Spacing="8">
      <Button Content="확인" Click="OnOk"/>
      <Button Content="취소" Click="OnCancel"/>
    </StackPanel>
  </StackPanel>
</Window>
```

호출:

```csharp
// 아무 ViewModel에서도 Window를 직접 열지 말고, DialogService 패턴 권장.
// 간단 예시는 코드비하인드에서:
private async void OpenDialog(object? sender, RoutedEventArgs e)
{
    if (this.VisualRoot is Window owner)
    {
        var result = await Views.Dialogs.InputDialog.ShowAsync(owner);
        // result 사용
    }
}
```

---

## 17. 성능·메모리·반응성 팁

- ObservableCollection에 대량 추가 시, 가급적 배치 추가/가상화 되는 컨트롤 사용(DataGrid Virtualization 옵션 확인)
- 빈번한 PropertyChanged 발생을 줄이도록 모델링
- 이미지/대용량 리소스는 지연 로딩
- 렌더링 바운딩 비용을 낮추기 위해 과도한 중첩 레이아웃/효과를 피함
- 디버그 빌드와 릴리스 빌드는 체감 성능이 다르므로 릴리스 기준 측정

---

## 18. 예제 프로젝트 정리: To-Do + 통계 화면

### 18.1 StatsViewModel (완료율 계산)

```csharp
// ViewModels/StatsViewModel.cs
using System.Linq;
using CommunityToolkit.Mvvm.ComponentModel;
using MyAvaloniaApp.Models;
using System.Collections.ObjectModel;

public partial class StatsViewModel : ObservableObject
{
    private readonly ReadOnlyObservableCollection<TodoItem> items;

    public StatsViewModel(ObservableCollection<TodoItem> source)
    {
        items = new ReadOnlyObservableCollection<TodoItem>(source);
    }

    public int Total => items.Count;
    public int Done => items.Count(i => i.IsDone);
    public double Rate => Total == 0 ? 0 : (double)Done / Total;
}
```

### 18.2 StatsView (간단 시각화)

```xml
<!-- Views/StatsView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyAvaloniaApp.Views.StatsView">
  <StackPanel Margin="16" Spacing="8">
    <TextBlock Text="통계" FontSize="20"/>
    <TextBlock Text="{Binding Total, StringFormat=총 {0}개}" />
    <TextBlock Text="{Binding Done, StringFormat=완료 {0}개}" />
    <ProgressBar Minimum="0" Maximum="1" Value="{Binding Rate}" Height="12"/>
  </StackPanel>
</UserControl>
```

> 실서비스에서는 차트 라이브러리 연동, 히스토리 집계 등을 추가.

---

## 19. GitHub Actions로 간단 CI

`.github/workflows/build.yml`:

```yaml
name: build
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
      - name: Restore
        run: dotnet restore
      - name: Build
        run: dotnet build --configuration Release --no-restore
      - name: Test
        run: dotnet test --no-build --verbosity normal
```

---

## 20. 실무 체크리스트

- 프로젝트 계층화: `App`(부트), `Views`, `ViewModels`, `Models`, `Services`, `Resources`
- DI 도입: ViewModel/서비스 수명 관리
- 설정/비밀키: 환경별 appsettings, 사용자 데이터 폴더 저장 경로 분리
- 로깅: 문제 추적에 필수
- 예외 처리: 전역 핸들러 + 사용자 피드백(UI Freeze 방지)
- 다국어: 문자열 분리/동적 로딩 전략
- 접근성: 키보드 탐색, 색 대비, 스크린리더 고려
- 배포: OS별 패키징/서명/업데이트 전략

---

## 21. 마무리

초안에서 제시된 내용(“Avalonia란?”, “설치 절차”, “VS Code로 실행”, “XAML 수정 예”)을 **그대로 유지**하면서, **MVVM 구조화, 스타일링/리소스, DI, 리스트/그리드 UI, Converter/Validation, 다이얼로그, 핫 리로드, 테스트, CI, 배포**까지 실전 흐름을 추가했다.
이 구조로 데스크톱을 먼저 완성한 뒤, 동일한 ViewModel/모델/서비스를 공용 라이브러리로 묶어 **WebAssembly/모바일**로 확장하면 유지보수 비용을 낮출 수 있다.

---

## 부록 A. 완성형 최소 샘플 (요약본)

### A.1 Program.cs

```csharp
using Avalonia;

namespace MyAvaloniaApp
{
    internal static class Program
    {
        [STAThread]
        public static void Main(string[] args)
            => BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);

        public static AppBuilder BuildAvaloniaApp()
            => AppBuilder.Configure<App>()
                         .UsePlatformDetect()
                         .LogToTrace();
    }
}
```

### A.2 App.axaml

```xml
<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyAvaloniaApp.App">
  <Application.Resources>
    <ResourceDictionary>
      <SolidColorBrush x:Key="BrandBrush" Color="#3B82F6"/>
    </ResourceDictionary>
  </Application.Resources>
  <Application.Styles>
    <FluentTheme Mode="Light"/>
  </Application.Styles>
</Application>
```

### A.3 App.axaml.cs

```csharp
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml;
using Microsoft.Extensions.DependencyInjection;
using MyAvaloniaApp.ViewModels;

namespace MyAvaloniaApp
{
    public partial class App : Application
    {
        public static ServiceProvider Services { get; private set; } = default!;

        public override void Initialize()
        {
            AvaloniaXamlLoader.Load(this);

            var sc = new ServiceCollection();
            sc.AddSingleton<MainViewModel>();
            Services = sc.BuildServiceProvider();
        }

        public override void OnFrameworkInitializationCompleted()
        {
            if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
            {
                var vm = Services.GetRequiredService<MainViewModel>();
                desktop.MainWindow = new MainWindow { DataContext = vm };
            }
            base.OnFrameworkInitializationCompleted();
        }
    }
}
```

### A.4 MainWindow.axaml

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:MyAvaloniaApp.ViewModels"
        x:Class="MyAvaloniaApp.MainWindow"
        Width="560" Height="360"
        Title="My Avalonia App">
  <Design.DataContext>
    <vm:MainViewModel/>
  </Design.DataContext>

  <StackPanel Margin="16" Spacing="12">
    <TextBlock Text="할 일 추가" FontSize="20" />
    <DockPanel>
      <TextBox Text="{Binding NewTitle, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
               Watermark="새 작업 입력..." Width="360" />
      <Button Content="추가" Command="{Binding AddCommand}" Margin="8,0,0,0" />
    </DockPanel>

    <ItemsControl Items="{Binding Items}">
      <ItemsControl.ItemTemplate>
        <DataTemplate>
          <DockPanel Margin="0,4">
            <TextBlock Text="{Binding Title}" />
            <TextBlock Text="{Binding IsDone}" DockPanel.Dock="Right" />
          </DockPanel>
        </DataTemplate>
      </ItemsControl.ItemTemplate>
    </ItemsControl>
  </StackPanel>
</Window>
```

### A.5 ViewModels/MainViewModel.cs

```csharp
using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;

namespace MyAvaloniaApp.ViewModels
{
    public partial class MainViewModel : ObservableObject
    {
        [ObservableProperty]
        private string? newTitle;

        public ObservableCollection<Item> Items { get; } = new();

        public MainViewModel()
        {
            Items.Add(new Item("첫 번째 작업"));
            Items.Add(new Item("두 번째 작업"));
        }

        [RelayCommand(CanExecute = nameof(CanAdd))]
        private void Add()
        {
            if (!string.IsNullOrWhiteSpace(NewTitle))
            {
                Items.Add(new Item(NewTitle));
                NewTitle = string.Empty;
            }
        }

        private bool CanAdd() => !string.IsNullOrWhiteSpace(NewTitle);
    }

    public sealed class Item
    {
        public string Title { get; }
        public bool IsDone { get; set; }
        public Item(string title) => Title = title;
    }
}
```

---

## 부록 B. 자주 겪는 문제와 해결

- XAML 네임스페이스 오류: `xmlns="https://github.com/avaloniaui"` 정확히 지정
- 디자인 타임 바인딩 미작동: `Design.DataContext`를 추가하고 VM 네임스페이스 확인
- 바인딩 실패: Output/로그에서 바인딩 에러 확인, 프로퍼티 이름/INPC 여부 점검
- 단일 파일 실행 시 시작 속도: `PublishSingleFile` 사용 시 I/O 방식 변화. 필요 시 해제
- macOS 배포: 권한/서명/노타라이즈 절차 필요
- Linux 배포: 배포 대상의 libc 호환성, 필요한 런타임 라이브러리 확인

---

## 결론

초기 초안의 흐름(설치→VS Code 실행→간단 XAML) 위에 **MVVM 구조화·스타일링/리소스·리스트/그리드·DI·다이얼로그·핫 리로드·테스팅·CI·배포**까지 “실전 개발자가 바로 적용”할 수 있도록 단계별 예제와 코드를 덧붙였다.
이 문서를 따라 하면 **WPF 개발자가 곧바로 Avalonia로 전환**하여 **크로스 플랫폼 데스크톱 앱**을 구성할 수 있다. 필요 시 동일 설계를 유지한 채 **WebAssembly/모바일**로 확장하면 된다.
