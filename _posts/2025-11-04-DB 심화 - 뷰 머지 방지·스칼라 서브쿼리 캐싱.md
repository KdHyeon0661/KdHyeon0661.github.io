---
layout: post
title: DB 심화 - 함수 호출 최소화
date: 2025-11-04 14:25:23 +0900
category: DB 심화
---
# 뷰 머지(View Merge) **방지**·스칼라 서브쿼리 **캐싱**·`DETERMINISTIC`/`RESULT_CACHE` **활용**·복잡 함수 로직 **슬림화**로 **함수 호출 최소화**하기

> **핵심 요약**
> - **함수 호출 폭증**의 1차 원인은 **“많은 행에 대해 너무 이른 시점에”** 함수를 평가하기 때문.  
> - **뷰 머지 방지**로 “필터·정렬·부분범위처리(Stopkey)”가 **먼저** 실행되게 하여 **행 개수**를 줄인 뒤, **나중**에 소수 행만 함수를 평가한다.  
> - **스칼라 서브쿼리 캐싱**(Scalar Subquery Caching)은 **같은 상관 키 값**에 대해 서브쿼리 결과를 **문장 실행 중 캐시**해 **중복 조회**를 줄인다.  
> - `DETERMINISTIC` 자체는 **캐시를 만들지 않지만**, **함수기반 인덱스(FBI)**/쿼리 재작성 등 최적화에 활용되고, **`RESULT_CACHE`** 는 **엔진 레벨 결과 캐시**를 제공한다.  
> - 복잡한 함수 로직은 **JOIN/CASE/DECODE/SQL 매크로**로 바꾸거나, **룩업 테이블**·**배치 프리페치**·**전역(세션) 캐시**로 **N+1 패턴**을 제거한다.

---

## 0) 실습 테이블 & 인덱스 (공통)

```sql
-- 주문(대용량)
DROP TABLE orders PURGE;
CREATE TABLE orders (
  order_id     NUMBER PRIMARY KEY,
  customer_id  NUMBER NOT NULL,
  created_at   DATE   NOT NULL,
  status_code  NUMBER NOT NULL,
  region       VARCHAR2(16),
  amount       NUMBER(12,2)
);

INSERT /*+ APPEND */ INTO orders
SELECT level,
       MOD(level, 500000)+1,
       (TRUNC(SYSDATE)-MOD(level,365)) + (MOD(level,86400)/86400),
       MOD(level,6),
       CASE MOD(level,4) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA'
                         WHEN 2 THEN 'AMER' ELSE 'OTHER' END,
       ROUND(DBMS_RANDOM.VALUE(10,1000),2)
FROM dual CONNECT BY level <= 2000000;
COMMIT;

-- 상태 코드 룩업
DROP TABLE dim_status PURGE;
CREATE TABLE dim_status (
  status_code  NUMBER PRIMARY KEY,
  status_name  VARCHAR2(30) NOT NULL
);
INSERT INTO dim_status VALUES (0,'NEW');
INSERT INTO dim_status VALUES (1,'PAID');
INSERT INTO dim_status VALUES (2,'SHIPPED');
INSERT INTO dim_status VALUES (3,'DELIVERED');
INSERT INTO dim_status VALUES (4,'RETURN');
INSERT INTO dim_status VALUES (5,'CANCEL');
COMMIT;

-- 고객 최신순 페이지 인덱스(정렬 포함 + tie-breaker)
CREATE INDEX ix_orders_cust_time
  ON orders(customer_id, created_at DESC, order_id DESC);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_STATUS',cascade=>TRUE);
END;
/
```

---

## 1) 뷰 머지(View Merge) **방지**로 함수 호출 최소화

### 1.1 원리
- 옵티마이저는 인라인 뷰/뷰를 **상위 쿼리로 병합(merge)** 하여 **조기 푸시다운**(필터/함수/조인)을 시도한다.  
- **문제**: 함수(특히 무거운/재귀 SQL 포함)가 **필터 이전**으로 **끌려 내려가** **대량 행**에 대해 호출될 수 있다.  
- **대응**: `NO_MERGE` 힌트로 **병합을 막고**, 인라인 뷰 안에서 **부분범위처리(Stopkey)**·필터·정렬로 **행 수를 크게 줄인 뒤**, 바깥 레벨에서 **함수**를 평가한다.

### 1.2 안티패턴 → 개선

**안티패턴(함수가 일찍 평가되는 형태)**

```sql
-- 함수: 코드→라벨 변환(예: 가벼워도 호출횟수 폭증 가능)
CREATE OR REPLACE FUNCTION f_status_name(p_code NUMBER)
  RETURN VARCHAR2
IS
BEGIN
  -- (예시) 간단 CASE. 실전에서는 재귀 SQL/복잡 로직일 수도 있음
  RETURN CASE p_code
           WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIPPED'
           WHEN 3 THEN 'DELIVERED' WHEN 4 THEN 'RETURN' WHEN 5 THEN 'CANCEL'
           ELSE 'UNKNOWN'
         END;
END;
/

-- ❌ 바깥 WHERE/SELECT에서 바로 호출(뷰 병합되면 더 일찍 평가될 수 있음)
SELECT o.order_id, f_status_name(o.status_code) AS status_name
FROM   orders o
WHERE  o.customer_id = :cust
AND    f_status_name(o.status_code) <> 'CANCEL'
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

**개선(인라인 뷰 + `NO_MERGE` + Stopkey → 바깥 SELECT에서 함수 평가)**

```sql
SELECT /* 바깥에서는 소수 행만 함수 평가 */
       v.order_id,
       v.created_at,
       v.amount,
       f_status_name(v.status_code) AS status_name
FROM  (
        SELECT /*+ NO_MERGE(v) index(o ix_orders_cust_time) */
               o.order_id, o.created_at, o.amount, o.status_code
        FROM   orders o
        WHERE  o.customer_id = :cust
        ORDER  BY o.created_at DESC, o.order_id DESC
        FETCH FIRST 50 ROWS ONLY
      ) v
-- 필요하면 이 레벨에서 필터 (함수 포함) 수행
WHERE  f_status_name(v.status_code) <> 'CANCEL';
```

- **효과**:  
  - 인라인 뷰 내부에서 **정렬 + STOPKEY** 로 **50행만** 추출.  
  - 바깥에서 함수 호출 → **50번만** 호출.  
  - 뷰 머지로 인해 함수를 수십만/수백만 행에 적용하는 **최악의 경우** 방지.

> **포인트**  
> - `NO_MERGE(v)`는 **암시적 병합 방지**.  
> - 필요 시 `MATERIALIZE`(버전/옵션 의존) 또는 `WITH ...` CTE + 힌트로 **머티리얼라이즈** 유도.  
> - 실제 계획에서 `STOPKEY` 존재 여부를 **DBMS_XPLAN.DISPLAY_CURSOR** 로 확인.

---

## 2) **스칼라 서브쿼리 캐싱**으로 함수/룩업 호출 최소화

### 2.1 원리
- **스칼라 서브쿼리**(SELECT … returning single value)를 **상관 키(=입력)** 와 **결과**의 매핑으로 **문장 실행 중 캐시**한다.  
- 같은 키 값이 반복되면 **재실행 없이 캐시 히트** → **N+1 완화**.  
- 특히 **카디널리티가 낮은 코드/라벨 변환**에 매우 효과적.

### 2.2 예제: 상태 코드 → 이름(상관 서브쿼리)

**방법 A: 스칼라 서브쿼리**

```sql
SELECT o.order_id,
       o.created_at,
       o.amount,
       ( SELECT s.status_name
         FROM   dim_status s
         WHERE  s.status_code = o.status_code
       ) AS status_name
FROM   orders o
WHERE  o.customer_id = :cust
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 2000 ROWS ONLY;
```

- **동작**:  
  - `o.status_code` 값이 **반복**되면 내부 서브쿼리 결과를 **캐시**.  
  - 0~5 사이 코드면 **최대 6건**만 실제 실행 → 나머지는 **캐시 히트**.  
  - 대량 데이터에서 **조인과 유사한 비용**으로 수렴(단, 조인이 더 계획 안정적일 때가 많음).

**방법 B: 조인(비교용)**

```sql
SELECT o.order_id, o.created_at, o.amount, s.status_name
FROM   orders o
JOIN   dim_status s
  ON   s.status_code = o.status_code
WHERE  o.customer_id = :cust
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 2000 ROWS ONLY;
```

- **권장**: 조인은 항상 **예측 가능**하고 통계에 의한 **플랜 최적화**가 잘 된다.  
- **대안**: 상관 스칼라 서브쿼리는 **코드 다양성이 낮음** + **SQL 간결성**을 원할 때 유용.

### 2.3 필터에 스칼라 서브쿼리 사용 (주의)

```sql
-- 'CANCEL' 제외
SELECT o.order_id, o.created_at, o.amount
FROM   orders o
WHERE  o.customer_id = :cust
AND   ( SELECT s.status_name
        FROM   dim_status s
        WHERE  s.status_code = o.status_code
      ) <> 'CANCEL'
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 2000 ROWS ONLY;
```

- **장점**: 캐싱 효과로 재평가 최소화.  
- **주의**: 인덱스 접근성(SARG)은 보통 **조인**이 더 유리. 가능한 **조인**으로 바꾸는 것을 우선 검토.

> **요약**: 스칼라 서브쿼리는 **“같은 키가 많이 반복될 때”** 호출 수를 효과적으로 줄여 준다.  
> 하지만 **계획 안정성·조인 순서** 측면에서는 **조인**이 일반적으로 **더 안전**하다.

---

## 3) `DETERMINISTIC` vs `RESULT_CACHE` — 캐싱의 의미와 올바른 활용

### 3.1 `DETERMINISTIC`의 의미 (캐시 **아님**)
```plsql
CREATE OR REPLACE FUNCTION normalize_region(p_txt VARCHAR2)
  RETURN VARCHAR2 DETERMINISTIC
IS
BEGIN
  RETURN CASE UPPER(TRIM(p_txt))
           WHEN 'ASIA PACIFIC' THEN 'APAC'
           WHEN 'US' THEN 'AMER'
           WHEN 'NA' THEN 'AMER'
           ELSE UPPER(TRIM(p_txt))
         END;
END;
/
```
- **의미**: **같은 입력 → 같은 출력**이라는 **계약**.  
- **효과**: 함수기반 인덱스(FBI) 정의·쿼리 재작성 등의 **근거**로 활용 가능.  
- **오해 금지**: **엔진이 자동 캐시**해 주는 것은 **아님**. **성능 보장 X**.

### 3.2 `RESULT_CACHE` — 엔진 레벨 결과 캐시(11g+)

```plsql
CREATE OR REPLACE FUNCTION get_status_name_rc(p_code NUMBER)
  RETURN VARCHAR2
  RESULT_CACHE  -- 결과 캐시 사용
IS
  v VARCHAR2(30);
BEGIN
  SELECT status_name INTO v
  FROM   dim_status
  WHERE  status_code = p_code;
  RETURN v;
END;
/
```

- **특징**  
  - **SGA 공유 캐시**. 동일 인자에 대해 **세션 간** 재사용 가능.  
  - 의존 객체 변화 시 **자동 무효화**(딕셔너리 추적, 12c부터 `RELIES_ON` 비권장).  
  - **히트율이 높은**(입력 다양성 낮음) 함수에 **탁월**.  
  - **주의**: 캐시 공간 관리(만료/크기), 정합성, 적합성(자주 바뀌는 데이터에는 부적합).

**사용 예**

```sql
SELECT o.order_id, o.created_at, o.amount,
       get_status_name_rc(o.status_code) AS status_name
FROM   orders o
WHERE  o.customer_id = :cust
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 2000 ROWS ONLY;
```

- 상태코드가 0~5면 **첫 평가 6번** 이후는 거의 전부 **캐시 히트**.  
- **스칼라 서브쿼리 캐싱**과 **RESULT_CACHE**는 **서로 다른 레벨**의 최적화(둘 다 유리할 수 있음).

### 3.3 `RESULT_CACHE` vs 조인/서브쿼리 선택 가이드

| 상황 | 권장 |
|---|---|
| 코드→명칭 단순 매핑, 코드 다양성 매우 낮음, 함수 재사용 多 | `RESULT_CACHE` 또는 **JOIN**(둘 다 좋음) |
| 룩업이 자주 갱신됨, 정합성 민감 | **JOIN** 우선(캐시 무효화 비용/타이밍 회피) |
| 복잡한 문자열 정규화 등 순수 계산 | `DETERMINISTIC` + (`RESULT_CACHE`는 입력 다양성에 따라) |

---

## 4) **복잡한 함수 로직** 슬림화: N+1 제거·배치화·SQL화

### 4.1 나쁜 예(재귀 SQL·자율 트랜잭션·외부 자원)

```plsql
CREATE OR REPLACE FUNCTION heavy_fn(p_order_id NUMBER)
  RETURN NUMBER
IS
  PRAGMA AUTONOMOUS_TRANSACTION; -- ❌ SELECT 일관성 깨짐 위험
  v_score NUMBER;
BEGIN
  -- (1) 주문 연관 정보를 여러 번 SELECT (N+1)
  SELECT SUM(amount) INTO v_score FROM orders WHERE order_id = p_order_id;

  -- (2) 룩업/통계 테이블 여기저기 조회
  -- (3) 파일/네트워크 호출(UTL_HTTP 등)  ❌ SQL 안에서 절대 금지
  -- (4) 로깅 INSERT/COMMIT (자율 트랜잭션) ❌

  RETURN v_score;
END;
/
```

- **문제**: 행마다 **다중 재귀 SQL** + **자율 트랜잭션** + **외부 자원** → **성능**·**일관성** 모두 악화.

### 4.2 개선 원칙
1) **JOIN/집계 SQL 한 방**으로 바꾸기(가능하면)  
2) **필요 키 집합**을 **미리 모아** GTT/임시 테이블에 넣고 **배치 조인**  
3) 복잡 규칙은 **룩업 테이블** + **CASE/DECODE** 로 모델링  
4) **SQL 매크로**(19c+)로 안전 캡슐화(함수처럼 보이나 **SQL로 확장**)  
5) 불가피한 함수는 **투영 단계**(필터 이후)에서만 호출 + `RESULT_CACHE`/패키지 캐시

### 4.3 SQL 매크로 예(복잡 규칙 캡슐화)

```plsql
CREATE OR REPLACE FUNCTION m_order_page(p_take NUMBER)
  RETURN VARCHAR2 SQL_MACRO(SCALAR)
IS
BEGIN
  RETURN q'{
    SELECT /*+ index(o ix_orders_cust_time) */
           o.order_id, o.created_at, o.amount,
           s.status_name,
           CASE WHEN o.amount >= 500 THEN 'VIP'
                WHEN o.amount >= 200 THEN 'HIGH'
                WHEN o.amount >=  50 THEN 'MID'
                ELSE 'LOW' END AS tier
    FROM   orders o
    JOIN   dim_status s ON s.status_code = o.status_code
    WHERE  o.customer_id = :cust
    ORDER  BY o.created_at DESC, o.order_id DESC
    FETCH FIRST p_take ROWS ONLY
  }';
END;
/
```

- **장점**: 호출은 함수처럼 **간결**, 내부는 **순수 SQL** → **재귀 SQL 없음**, **SARG 유지**, **Stopkey 적용**.

---

## 5) “페이지 처리(Stopkey) + 뷰 머지 방지 + 캐싱” 결합 레시피

### 5.1 최적 조합 예시

```sql
SELECT /* 바깥 단계: 소수 행에만 함수/CASE */
       v.order_id,
       v.created_at,
       v.amount,
       get_status_name_rc(v.status_code) AS status_name
FROM  (
        SELECT /*+ NO_MERGE(v) index(o ix_orders_cust_time) */
               o.order_id, o.created_at, o.amount, o.status_code
        FROM   orders o
        WHERE  o.customer_id = :cust
        ORDER  BY o.created_at DESC, o.order_id DESC
        FETCH FIRST :take ROWS ONLY
      ) v;
```

- **행 수↓**(Stopkey) → **함수 호출 수↓**  
- `RESULT_CACHE`로 **반복 인자**에 대해 **SGA 캐시 히트**  
- 뷰 머지 방지로 **평가 순서 보장**  
- 필요 시 스칼라 서브쿼리로 룩업 대체 가능(카디널리티 낮을 때)

---

## 6) 성능 측정 절차 (전/후 비교)

```sql
ALTER SESSION SET statistics_level=ALL;
ALTER SESSION SET events '10046 trace name context forever, level 8';

-- 1) BEFORE: 뷰 머지 허용 + 함수 조기 평가/재귀 SQL/조인 없음
-- 2) AFTER : NO_MERGE + Stopkey + 조인/CASE 또는 RESULT_CACHE

ALTER SESSION SET events '10046 trace name context off';
```

- **TKPROF / SQL Monitor**에서 확인할 지표  
  - `recursive calls` (함수/서브쿼리 재평가 감소)  
  - `Fetch count` (페이지 처리+배열 페치 적용 시 1~2회 근처)  
  - `consistent gets`/`physical reads` (Stopkey로 감소)  
  - 상위 대기: `db file sequential/scattered read`, `SQL*Net ...`, `latch: ...` 변화  
  - 실행계획의 **`STOPKEY`**, 인덱스 **RANGE SCAN** 존재 여부

---

## 7) 자주 하는 실수 & 처방

| 실수 | 증상 | 처방 |
|---|---|---|
| 뷰/인라인 뷰에서 **함수 + 필터**를 쓰고 병합 허용 | **함수 조기 평가**로 호출 폭증 | `NO_MERGE`/`MATERIALIZE`로 평가 순서 고정 후 바깥에서 함수 |
| WHERE에 **함수 적용**(열에) | 인덱스 무력화, Full Scan | **함수기반 인덱스(FBI)** 또는 **식 변환**(SARG) |
| 함수 내부 **재귀 SQL** | `recursive calls` 폭증, N+1 | **JOIN/스칼라 서브쿼리 캐싱/GTT** 로 배치화 |
| `DETERMINISTIC`를 캐시로 오해 | 성능 개선 없음 | `RESULT_CACHE` 또는 스칼라 서브쿼리 캐싱 활용 |
| OFFSET 페이지 | 뒤로 갈수록 폭증 | **Keyset + Stopkey** 로 전환 |
| 입력 다양성 큰데 `RESULT_CACHE` 남발 | 캐시 미스, 메모리 낭비 | 조인/스칼라 서브쿼리로 전환, 캐시 대상 선별 |

---

## 8) 요약 코드 모음 (Before → After)

### 8.1 상태 라벨 표시 (페이지 + 뷰 머지 방지 + RESULT_CACHE)

```plsql
CREATE OR REPLACE FUNCTION get_status_name_rc(p_code NUMBER)
  RETURN VARCHAR2 RESULT_CACHE IS
  v VARCHAR2(30);
BEGIN
  SELECT status_name INTO v FROM dim_status WHERE status_code=p_code;
  RETURN v;
END;
/
```

```sql
-- BEFORE (나쁨): 조기 함수 평가 + OFFSET
SELECT f_status_name(o.status_code)
FROM   orders o
WHERE  o.customer_id=:cust
ORDER  BY created_at DESC, order_id DESC
OFFSET :skip ROWS FETCH NEXT :take ROWS ONLY;

-- AFTER (권장): NO_MERGE + Stopkey + RESULT_CACHE
SELECT get_status_name_rc(v.status_code) AS status_name
FROM (
  SELECT /*+ NO_MERGE(v) index(o ix_orders_cust_time) */
         o.status_code
  FROM   orders o
  WHERE  o.customer_id=:cust
  ORDER  BY o.created_at DESC, o.order_id DESC
  FETCH FIRST :take ROWS ONLY
) v;
```

### 8.2 스칼라 서브쿼리 캐싱 활용

```sql
SELECT o.order_id, o.created_at, o.amount,
       ( SELECT s.status_name
         FROM dim_status s
         WHERE s.status_code = o.status_code
       ) AS status_name
FROM   orders o
WHERE  o.customer_id=:cust
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 2000 ROWS ONLY;
```

> 코드 다양성(0~5) 낮아 **캐시 히트율 ≈ 100%**.  
> 하지만 **JOIN**이 더 계획 안정적이면 조인 우선.

---

## 9) 체크리스트 (배포 전)

- [ ] **부분범위처리(Stopkey)** 가 **먼저** 실행되는가? (`STOPKEY` 확인)  
- [ ] **`NO_MERGE`** 로 **평가 순서**를 보장했는가?  
- [ ] 함수는 **필터 이후/투영 단계**에서 **소수 행에만** 호출되는가?  
- [ ] **스칼라 서브쿼리 캐싱** 또는 **JOIN** 으로 N+1을 제거했는가?  
- [ ] `DETERMINISTIC`/`RESULT_CACHE` 의 **의미**와 **한계**를 이해하고 적절히 사용했는가?  
- [ ] **OFFSET 금지**, **Keyset 페이지**로 전환했는가?  
- [ ] TKPROF/SQL Monitor로 **`recursive calls`/`Fetch count`/I-O** 전후 비교했는가?

---

## 결론
- **함수 호출 최소화**의 핵심은 **“언제(순서)·얼마나(행 수)·어떻게(캐시/조인/SQL화)”** 평가하느냐다.  
- **뷰 머지 방지**로 평가 순서를 잡고, **Stopkey** 로 **행 수**를 줄여 **소수 행에만** 함수를 적용한다.  
- **스칼라 서브쿼리 캐싱**과 **`RESULT_CACHE`** 는 **중복 평가**를 없애는 강력한 무기다.  
- 복잡 함수는 **SQL화/룩업 조인/매크로**로 슬림화하라.  
- 마지막으로, **측정**(TKPROF/SQL Monitor)로 효과를 **수치화**하라 — 그래야 다음 최적화의 방향이 보인다.