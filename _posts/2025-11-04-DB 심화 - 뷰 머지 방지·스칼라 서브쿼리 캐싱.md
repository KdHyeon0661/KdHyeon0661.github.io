---
layout: post
title: DB 심화 - 함수 호출 최소화
date: 2025-11-04 14:25:23 +0900
category: DB 심화
---
# PL/SQL 함수 호출 최적화: 성능 저하 방지와 캐싱 전략

> **핵심 요약**  
> 함수 호출이 성능 저하의 주요 원인이 되는 경우는 대부분 "너무 많은 행에 대해 너무 이른 시점에 평가"하기 때문입니다. 이 문제를 해결하기 위해 뷰 머지 방지, 스칼라 서브쿼리 캐싱, DETERMINISTIC/RESULT_CACHE 활용, 복잡 함수 로직 슬림화 등 다양한 기법을 적용할 수 있습니다.

---

## 실습 환경 구성

```sql
-- 주문 테이블 생성 (대용량 데이터)
DROP TABLE orders PURGE;
CREATE TABLE orders (
  order_id     NUMBER PRIMARY KEY,
  customer_id  NUMBER NOT NULL,
  created_at   DATE   NOT NULL,
  status_code  NUMBER NOT NULL,
  region       VARCHAR2(16),
  amount       NUMBER(12,2)
);

-- 샘플 데이터 삽입 (200만 건)
INSERT /*+ APPEND */ INTO orders
SELECT level,
       MOD(level, 500000)+1,
       (TRUNC(SYSDATE)-MOD(level,365)) + (MOD(level,86400)/86400),
       MOD(level,6),
       CASE MOD(level,4) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA'
                         WHEN 2 THEN 'AMER' ELSE 'OTHER' END,
       ROUND(DBMS_RANDOM.VALUE(10,1000),2)
FROM dual CONNECT BY level <= 2000000;
COMMIT;

-- 상태 코드 매핑 테이블
DROP TABLE dim_status PURGE;
CREATE TABLE dim_status (
  status_code  NUMBER PRIMARY KEY,
  status_name  VARCHAR2(30) NOT NULL
);

INSERT INTO dim_status VALUES (0,'NEW');
INSERT INTO dim_status VALUES (1,'PAID');
INSERT INTO dim_status VALUES (2,'SHIPPED');
INSERT INTO dim_status VALUES (3,'DELIVERED');
INSERT INTO dim_status VALUES (4,'RETURN');
INSERT INTO dim_status VALUES (5,'CANCEL');
COMMIT;

-- 고객별 최신 주문 인덱스
CREATE INDEX ix_orders_cust_time
  ON orders(customer_id, created_at DESC, order_id DESC);

-- 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_STATUS',cascade=>TRUE);
END;
/
```

---

## 뷰 머지 방지로 함수 호출 최소화

### 문제점 분석
옵티마이저는 쿼리 최적화 과정에서 인라인 뷰나 뷰를 상위 쿼리와 병합(merge)하려고 시도합니다. 이는 일반적으로 성능에 도움이 되지만, 함수 호출과 관련해서는 문제를 일으킬 수 있습니다. 함수가 필터 조건보다 먼저 평가되어 대량의 행에 대해 호출될 수 있기 때문입니다.

### 비효율적인 예시
```sql
-- 간단한 상태 코드 변환 함수
CREATE OR REPLACE FUNCTION f_status_name(p_code NUMBER)
  RETURN VARCHAR2
IS
BEGIN
  RETURN CASE p_code
           WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIPPED'
           WHEN 3 THEN 'DELIVERED' WHEN 4 THEN 'RETURN' WHEN 5 THEN 'CANCEL'
           ELSE 'UNKNOWN'
         END;
END;
/

-- 함수가 조기에 평가될 수 있는 문제가 있는 쿼리
SELECT o.order_id, f_status_name(o.status_code) AS status_name
FROM   orders o
WHERE  o.customer_id = :cust
AND    f_status_name(o.status_code) <> 'CANCEL'
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

### 개선된 접근법
```sql
-- NO_MERGE 힌트를 사용하여 뷰 병합 방지
SELECT /* 바깥 레벨에서만 함수 호출 */
       v.order_id,
       v.created_at,
       v.amount,
       f_status_name(v.status_code) AS status_name
FROM  (
        SELECT /*+ NO_MERGE index(o ix_orders_cust_time) */
               o.order_id, o.created_at, o.amount, o.status_code
        FROM   orders o
        WHERE  o.customer_id = :cust
        ORDER  BY o.created_at DESC, o.order_id DESC
        FETCH FIRST 50 ROWS ONLY  -- 부분범위처리 적용
      ) v
WHERE  f_status_name(v.status_code) <> 'CANCEL';
```

### 최적화 효과
1. **인라인 뷰 내부**에서 부분범위처리(Stopkey)가 적용되어 50행만 추출됩니다.
2. **바깥 쿼리**에서 함수가 호출되므로 최대 50번만 실행됩니다.
3. 뷰 병합으로 인한 대량 행에 대한 함수 호출을 방지합니다.

### 실행 계획 확인
```sql
-- 실행 계획 분석
ALTER SESSION SET statistics_level = ALL;

-- 쿼리 실행 후 실행 계획 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

---

## 스칼라 서브쿼리 캐싱으로 중복 호출 최소화

### 캐싱 메커니즘 이해
스칼라 서브쿼리는 동일한 입력 값에 대해 결과를 캐시하여 재사용합니다. 이는 특히 카디널리티가 낮은 코드 변환 작업에 매우 효과적입니다.

### 스칼라 서브쿼리 활용 예제
```sql
SELECT o.order_id,
       o.created_at,
       o.amount,
       ( SELECT s.status_name
         FROM   dim_status s
         WHERE  s.status_code = o.status_code
       ) AS status_name
FROM   orders o
WHERE  o.customer_id = :cust
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 2000 ROWS ONLY;
```

### 캐싱 효과 분석
- 상태 코드가 0-5 사이의 값만 있다면, 실제 데이터베이스 조회는 최대 6번만 발생합니다.
- 나머지 호출은 캐시에서 결과를 반환하므로 성능이 크게 개선됩니다.
- 특히 동일한 고객의 주문 내역에서 상태 코드가 반복될 경우 효과가 두드러집니다.

### 대안: 조인 방식
```sql
-- 조인을 활용한 동일 기능 구현
SELECT o.order_id, o.created_at, o.amount, s.status_name
FROM   orders o
JOIN   dim_status s
  ON   s.status_code = o.status_code
WHERE  o.customer_id = :cust
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 2000 ROWS ONLY;
```

### 선택 가이드라인
| 상황 | 권장 방식 | 이유 |
|------|-----------|------|
| 코드 다양성이 매우 낮은 경우 | 스칼라 서브쿼리 | 캐시 히트율이 거의 100%에 가까움 |
| 예측 가능한 실행 계획 필요 | 조인 | 옵티마이저가 더 잘 최적화할 수 있음 |
| 대량 데이터 처리 | 조인 | 배치 처리에 더 적합함 |

---

## DETERMINISTIC과 RESULT_CACHE의 올바른 활용

### DETERMINISTIC 함수의 이해
```plsql
CREATE OR REPLACE FUNCTION normalize_region(p_txt VARCHAR2)
  RETURN VARCHAR2 DETERMINISTIC
IS
BEGIN
  RETURN CASE UPPER(TRIM(p_txt))
           WHEN 'ASIA PACIFIC' THEN 'APAC'
           WHEN 'US' THEN 'AMER'
           WHEN 'NA' THEN 'AMER'
           ELSE UPPER(TRIM(p_txt))
         END;
END;
/
```

**중요 포인트:**
- `DETERMINISTIC`은 "동일 입력 → 동일 출력"을 보장하는 계약입니다.
- **자동 캐싱을 제공하지 않습니다.** 성능 향상을 보장하지 않습니다.
- 함수 기반 인덱스(FBI) 생성이나 쿼리 재작성에 활용됩니다.

### RESULT_CACHE 함수의 활용
```plsql
CREATE OR REPLACE FUNCTION get_status_name_rc(p_code NUMBER)
  RETURN VARCHAR2
  RESULT_CACHE  -- 결과 캐시 사용 선언
IS
  v_status_name VARCHAR2(30);
BEGIN
  SELECT status_name INTO v_status_name
  FROM   dim_status
  WHERE  status_code = p_code;
  
  RETURN v_status_name;
END;
/
```

**RESULT_CACHE의 특징:**
1. **SGA 공유 캐시**: 결과가 SGA에 캐시되어 세션 간 공유됩니다.
2. **자동 무효화**: 의존 객체가 변경되면 자동으로 캐시가 무효화됩니다.
3. **적합한 상황**: 입력 값의 다양성이 낮고 호출 빈도가 높은 함수에 적합합니다.
4. **주의사항**: 자주 변경되는 데이터에는 부적합할 수 있습니다.

### 사용 예시
```sql
-- RESULT_CACHE 함수 활용
SELECT o.order_id, o.created_at, o.amount,
       get_status_name_rc(o.status_code) AS status_name
FROM   orders o
WHERE  o.customer_id = :cust
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 2000 ROWS ONLY;
```

### 선택 기준
| 기준 | DETERMINISTIC | RESULT_CACHE | 조인/서브쿼리 |
|------|---------------|--------------|----------------|
| 캐싱 제공 | 아니오 | 예 | 상황에 따라 다름 |
| 입력 다양성 | 제한 없음 | 낮을 때 효과적 | 제한 없음 |
| 데이터 변경 빈도 | 영향 없음 | 자주 변경 시 부적합 | 영향 없음 |
| 구현 복잡도 | 낮음 | 중간 | 상황에 따라 다름 |

---

## 복잡 함수 로직의 슬림화 전략

### 문제가 있는 복잡 함수 예시
```plsql
CREATE OR REPLACE FUNCTION heavy_function(p_order_id NUMBER)
  RETURN NUMBER
IS
  PRAGMA AUTONOMOUS_TRANSACTION;  -- 문제: 읽기 일관성 위험
  v_score NUMBER;
BEGIN
  -- N+1 문제: 행마다 별도 조회
  SELECT SUM(amount) INTO v_score FROM orders WHERE order_id = p_order_id;
  
  -- 여러 추가 조회
  -- 외부 자원 접근 (파일, 네트워크)
  -- 자율 트랜잭션 내에서 로깅
  
  RETURN v_score;
END;
/
```

### 개선 전략

#### 1. JOIN으로 변환
```sql
-- 복잡 함수 대신 JOIN 활용
SELECT o.order_id, o.created_at, o.amount,
       s.status_name,
       CASE WHEN o.amount >= 500 THEN 'VIP'
            WHEN o.amount >= 200 THEN 'HIGH'
            WHEN o.amount >= 50 THEN 'MID'
            ELSE 'LOW' END AS customer_tier
FROM   orders o
JOIN   dim_status s ON s.status_code = o.status_code
WHERE  o.customer_id = :cust
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 100 ROWS ONLY;
```

#### 2. SQL 매크로 활용 (Oracle 19c+)
```plsql
CREATE OR REPLACE FUNCTION order_summary_macro(p_take NUMBER)
  RETURN VARCHAR2 SQL_MACRO(SCALAR)
IS
BEGIN
  RETURN q'{
    SELECT /*+ index(o ix_orders_cust_time) */
           o.order_id, o.created_at, o.amount,
           s.status_name,
           CASE WHEN o.amount >= 500 THEN 'VIP'
                WHEN o.amount >= 200 THEN 'HIGH'
                WHEN o.amount >= 50 THEN 'MID'
                ELSE 'LOW' END AS tier
    FROM   orders o
    JOIN   dim_status s ON s.status_code = o.status_code
    WHERE  o.customer_id = :cust
    ORDER  BY o.created_at DESC, o.order_id DESC
    FETCH FIRST p_take ROWS ONLY
  }';
END;
/
```

#### 3. 배치 조인 활용
```sql
-- GTT(Global Temporary Table)를 활용한 배치 처리
CREATE GLOBAL TEMPORARY TABLE temp_order_ids (
  order_id NUMBER PRIMARY KEY
) ON COMMIT DELETE ROWS;

-- 필요한 ID를 일괄 삽입
INSERT INTO temp_order_ids
SELECT order_id FROM orders 
WHERE customer_id = :cust 
AND created_at >= SYSDATE - 30;

-- 배치 조인 수행
SELECT o.order_id, o.created_at, o.amount, s.status_name
FROM   temp_order_ids t
JOIN   orders o ON o.order_id = t.order_id
JOIN   dim_status s ON s.status_code = o.status_code
ORDER BY o.created_at DESC;
```

---

## 종합 최적화 예시

### 최적화 전
```sql
-- 비효율적인 원본 쿼리
SELECT o.order_id, 
       f_complex_status(o.status_code, o.region) AS status_desc,
       heavy_calculation(o.amount) AS calculated_value
FROM   orders o
WHERE  o.customer_id = :cust
AND    f_complex_status(o.status_code, o.region) <> 'CANCELED'
ORDER  BY o.created_at DESC
OFFSET 0 ROWS FETCH NEXT 50 ROWS ONLY;
```

### 최적화 후
```sql
-- 종합 최적화 적용
SELECT v.order_id,
       v.status_desc,
       v.calculated_value
FROM  (
        SELECT /*+ NO_MERGE index(o ix_orders_cust_time) */
               o.order_id,
               -- 간소화된 계산 (룩업 테이블 조인)
               (SELECT status_name FROM dim_status WHERE status_code = o.status_code) 
                 || ' - ' || o.region AS status_desc,
               -- 단순화된 계산
               CASE WHEN o.amount >= 500 THEN o.amount * 0.9
                    WHEN o.amount >= 200 THEN o.amount * 0.95
                    ELSE o.amount END AS calculated_value,
               o.created_at
        FROM   orders o
        WHERE  o.customer_id = :cust
        ORDER  BY o.created_at DESC, o.order_id DESC
        FETCH FIRST 50 ROWS ONLY  -- Keyset 페이지네이션
      ) v
WHERE  v.status_desc NOT LIKE '%CANCEL%';
```

---

## 성능 측정과 검증 방법

### 트레이스 활성화
```sql
-- 성능 측정을 위한 트레이스 활성화
ALTER SESSION SET statistics_level = ALL;
ALTER SESSION SET events '10046 trace name context forever, level 8';

-- 테스트 쿼리 실행

-- 트레이스 비활성화
ALTER SESSION SET events '10046 trace name context off';
```

### 성능 지표 분석
```sql
-- 주요 성능 지표 확인
SELECT sql_id, executions, buffer_gets, disk_reads,
       rows_processed, elapsed_time,
       ROUND(elapsed_time/NULLIF(executions,0)) avg_elapsed
FROM   v$sql
WHERE  sql_text LIKE '%orders%'
ORDER  BY elapsed_time DESC FETCH FIRST 10 ROWS ONLY;
```

### 실행 계획 비교
```sql
-- 실행 계획 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('sql_id_here', NULL, 'ALLSTATS LAST'));
```

### 재귀 호출 분석
```sql
-- 재귀 호출 통계 확인
SELECT name, value
FROM   v$sysstat
WHERE  name LIKE '%recursive%'
ORDER BY value DESC;
```

---

## 일반적인 실수와 개선 방안

### 1. WHERE 절에 함수 사용
**문제:** 
```sql
WHERE UPPER(column_name) = 'VALUE'  -- 인덱스 사용 불가
```
**해결:**
- 함수 기반 인덱스 생성
- 데이터 정규화 (대문자로 저장)
- 표현식 변환

### 2. 과도한 N+1 패턴
**문제:** 행마다 별도 쿼리 실행
**해결:** 배치 조인, 스칼라 서브쿼리 캐싱, 임시 테이블 활용

### 3. RESULT_CACHE의 오용
**문제:** 입력 다양성이 높은 함수에 RESULT_CACHE 사용
**해결:** 적절한 사용 사례 평가, 캐시 히트율 모니터링

### 4. OFFSET 페이지네이션
**문제:** 뒤로 갈수록 성능 저하
**해결:** Keyset 페이지네이션으로 전환

---

## 결론

PL/SQL 함수 호출 최적화는 데이터베이스 성능 향상의 중요한 요소입니다. 효과적인 최적화를 위해서는 다음과 같은 원칙을 준수해야 합니다:

### 핵심 원칙
1. **평가 시기 제어**: 뷰 머지 방지를 통해 함수 평가 시기를 적절히 제어하고, 부분범위처리(Stopkey)를 활용하여 함수 호출 대상을 최소화하세요.

2. **캐싱 전략 활용**: 스칼라 서브쿼리 캐싱과 RESULT_CACHE를 상황에 맞게 활용하여 중복 계산을 방지하세요. DETERMINISTIC의 실제 의미를 이해하고 적절히 활용하세요.

3. **로직 간소화**: 복잡한 함수 로직은 가능한 한 SQL로 변환하고, JOIN, CASE 표현식, 룩업 테이블 등을 활용하여 N+1 문제를 해결하세요.

4. **측정 기반 접근**: 최적화의 효과는 실제 성능 측정을 통해 검증해야 합니다. TKPROF, SQL Monitor, 실행 계획 분석 등을 활용하여 객관적인 성능 데이터를 수집하고 분석하세요.

### 실전 적용 가이드
- **시작 전**: 현재 쿼리의 성능 프로파일을 정확히 이해하세요. 가장 많은 시간을 소비하는 부분이 어디인지 파악하세요.
- **점진적 개선**: 한 번에 너무 많은 변경을 시도하지 말고, 측정 가능한 단계별로 개선을 진행하세요.
- **환경 고려**: 개발, 테스트, 운영 환경의 차이를 고려하고, 운영 환경에서의 성능을 최종적으로 검증하세요.
- **지속적인 모니터링**: 최적화는 일회성 작업이 아닙니다. 시스템 사용 패턴이 변화함에 따라 지속적인 모니터링과 튜닝이 필요합니다.

### 최종 목표
함수 호출 최적화의 궁극적인 목표는 사용자에게 더 빠른 응답 시간을 제공하면서도 시스템 리소스를 효율적으로 활용하는 것입니다. 기술적 최적화와 함께 비즈니스 요구사항과 사용자 경험을 종합적으로 고려한 균형 잡힌 접근이 필요합니다. 올바른 도구와 방법론을 활용하면 PL/SQL 함수의 성능 문제를 효과적으로 해결하고, 더 나은 데이터베이스 성능을 달성할 수 있습니다.