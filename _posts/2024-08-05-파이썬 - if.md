---
layout: post
title: 파이썬 - if 문
date: 2024-08-05 19:20:23 +0900
category: Python
---
# if 문

프로그래밍에서 조건에 따라 다른 동작을 수행하는 것은 가장 기본적이면서도 중요한 개념입니다. 파이썬의 `if` 문은 이러한 조건부 실행을 구현하는 핵심 도구로, 직관적인 문법과 다양한 활용 패턴을 제공합니다. 이 글에서는 `if` 문의 기본 구조부터 고급 활용법까지 실제 코드 예제를 통해 자세히 알아보겠습니다.

## if 문의 기본 구조

### 단순 if 문

가장 기본적인 형태의 `if` 문은 조건이 참(True)일 때만 특정 코드 블록을 실행합니다.

```python
# 기본 if 문 예제
temperature = 28

if temperature > 25:
    print("날씨가 더워요. 반팔을 입으세요.")
    print("물을 자주 마시는 게 좋아요.")

# 출력: 날씨가 더워요. 반팔을 입으세요.
#       물을 자주 마시는 게 좋아요.
```

파이썬은 들여쓰기로 코드 블록을 구분합니다. 일반적으로 4개의 공백을 사용하며, 탭과 공백을 혼용하면 `IndentationError`가 발생할 수 있으므로 주의해야 합니다.

### if-else 문

조건이 거짓(False)일 때 실행할 대안 코드를 지정하려면 `else` 절을 사용합니다.

```python
# if-else 예제
age = 16

if age >= 19:
    print("성인입니다. 주류 구매가 가능합니다.")
else:
    print("미성년자입니다. 주류 구매가 불가능합니다.")
    print("보호자의 동의가 필요합니다.")

# 출력: 미성년자입니다. 주류 구매가 불가능합니다.
#       보호자의 동의가 필요합니다.
```

### if-elif-else 문

여러 조건 중 하나를 선택해야 할 때는 `elif`(else if의 줄임말)를 사용합니다.

```python
# if-elif-else 예제
score = 85

if score >= 90:
    grade = "A"
    print("우수한 성적입니다!")
elif score >= 80:
    grade = "B"
    print("좋은 성적입니다.")
elif score >= 70:
    grade = "C"
    print("보통 성적입니다.")
elif score >= 60:
    grade = "D"
    print("조금 더 노력이 필요합니다.")
else:
    grade = "F"
    print("재수강을 고려해보세요.")

print(f"당신의 학점은 {grade}입니다.")

# 출력: 좋은 성적입니다.
#       당신의 학점은 B입니다.
```

`elif`는 순차적으로 평가되며, 처음으로 참이 되는 조건의 코드 블록만 실행됩니다. 모든 조건이 거짓일 경우 `else` 블록이 실행됩니다.

### 중첩 if 문

if 문 안에 또 다른 if 문을 작성할 수 있습니다.

```python
# 중첩 if 문 예제
membership = "gold"
purchase_amount = 120000

if membership == "gold":
    if purchase_amount >= 100000:
        discount = 0.15
        print("골드 회원 15% 할인이 적용됩니다.")
    else:
        discount = 0.10
        print("골드 회원 10% 할인이 적용됩니다.")
elif membership == "silver":
    discount = 0.05
    print("실버 회원 5% 할인이 적용됩니다.")
else:
    discount = 0
    print("할인이 적용되지 않습니다.")

final_price = purchase_amount * (1 - discount)
print(f"최종 결제 금액: {final_price:,.0f}원")
```

하지만 중첩이 깊어지면 코드의 가독성이 떨어지므로, 가능하면 평탄화하는 것이 좋습니다.

## 조건 표현식 (삼항 연산자)

간단한 조건에 따라 값을 선택할 때는 조건 표현식을 사용할 수 있습니다.

```python
# 조건 표현식 예제
x = 10

# 일반적인 if-else
if x > 0:
    sign = "양수"
else:
    sign = "음수 또는 0"

# 조건 표현식 사용
sign = "양수" if x > 0 else "음수 또는 0"

print(f"{x}은(는) {sign}입니다.")

# 더 복잡한 예제
age = 22
status = "성인" if age >= 19 else "미성년자"
discount_rate = 0.1 if age >= 65 else 0.0

print(f"상태: {status}, 할인율: {discount_rate*100}%")
```

조건 표현식은 간결하지만 복잡한 로직에는 적합하지 않습니다. 가독성을 우선시하는 것이 좋습니다.

## 비교 연산자와 논리 연산자

### 기본 비교 연산자

```python
# 비교 연산자 예제
a = 10
b = 20

print(f"a == b : {a == b}")      # 같음
print(f"a != b : {a != b}")      # 같지 않음
print(f"a < b  : {a < b}")       # 작음
print(f"a > b  : {a > b}")       # 큼
print(f"a <= b : {a <= b}")      # 작거나 같음
print(f"a >= b : {a >= b}")      # 크거나 같음

# 문자열 비교
name1 = "Alice"
name2 = "Bob"
print(f"알파벳 순서: {name1 < name2}")  # True (사전식 순서)
```

### 논리 연산자

```python
# 논리 연산자 예제
age = 25
has_license = True

if age >= 19 and has_license:
    print("운전이 가능합니다.")
else:
    print("운전이 불가능합니다.")

# 여러 조건 결합
score = 85
attendance = 0.95

if score >= 80 or attendance >= 0.9:
    print("과목 통과!")
else:
    print("재수강 필요")

# not 연산자
is_raining = False

if not is_raining:
    print("우산이 필요 없습니다.")
else:
    print("우산을 챙기세요.")
```

### 체인 비교

파이썬은 수학에서처럼 체인 비교를 지원합니다.

```python
# 체인 비교 예제
x = 15

# 일반적인 방식
if x > 10 and x < 20:
    print("x는 10보다 크고 20보다 작습니다.")

# 체인 비교 방식
if 10 < x < 20:
    print("x는 10보다 크고 20보다 작습니다.")

# 여러 개 비교
y = 5
if 0 < x < 100 and 0 < y < 50:
    print("두 값 모두 유효 범위 내에 있습니다.")
```

### 멤버십 연산자

```python
# in, not in 연산자 예제
fruits = ["사과", "바나나", "오렌지", "포도"]

if "사과" in fruits:
    print("사과가 리스트에 있습니다.")

if "딸기" not in fruits:
    print("딸기는 리스트에 없습니다.")

# 문자열 검사
text = "파이썬 프로그래밍"
if "프로그래밍" in text:
    print("텍스트에 '프로그래밍'이 포함되어 있습니다.")

# 딕셔너리 키 검사
user = {"name": "홍길동", "age": 30, "city": "서울"}
if "age" in user:
    print(f"나이: {user['age']}")
```

### 동일성 연산자

```python
# is와 ==의 차이
list1 = [1, 2, 3]
list2 = [1, 2, 3]
list3 = list1

print(f"list1 == list2 : {list1 == list2}")  # True (값 비교)
print(f"list1 is list2 : {list1 is list2}")  # False (객체 식별자 비교)
print(f"list1 is list3 : {list1 is list3}")  # True (같은 객체)

# None 비교
value = None
if value is None:  # 올바른 방법
    print("값이 None입니다.")

if value == None:  # 작동은 하지만 권장하지 않음
    print("값이 None입니다.")
```

## 진리값 평가와 단락 평가

### 진리값 평가

파이썬에서는 다양한 값이 조건문에서 자동으로 진리값으로 변환됩니다.

```python
# 다양한 값의 진리값 평가
values_to_test = [
    0,          # False
    1,          # True
    0.0,        # False
    3.14,       # True
    "",         # False (빈 문자열)
    "Hello",    # True
    [],         # False (빈 리스트)
    [1, 2, 3],  # True
    (),         # False (빈 튜플)
    (1, 2),     # True
    {},         # False (빈 딕셔너리)
    {"a": 1},   # True
    None,       # False
]

for value in values_to_test:
    print(f"{repr(value):15} -> {bool(value)}")

# 실제 활용 예제
def process_items(items):
    if items:  # items가 비어있지 않으면 True
        print(f"{len(items)}개의 항목을 처리합니다.")
        for item in items:
            print(f"- {item}")
    else:
        print("처리할 항목이 없습니다.")

process_items(["사과", "바나나", "오렌지"])
process_items([])
```

### 단락 평가

파이썬의 `and`와 `or` 연산자는 단락 평가를 수행합니다.

```python
# 단락 평가 예제
def expensive_operation():
    print("비용이 많이 드는 연산 실행 중...")
    return True

# and 연산자: 첫 번째 피연산자가 False면 두 번째는 평가하지 않음
print("테스트 1:")
result = False and expensive_operation()  # expensive_operation 호출되지 않음
print(f"결과: {result}")

print("\n테스트 2:")
result = True and expensive_operation()  # expensive_operation 호출됨
print(f"결과: {result}")

# or 연산자: 첫 번째 피연산자가 True면 두 번째는 평가하지 않음
print("\n테스트 3:")
result = True or expensive_operation()  # expensive_operation 호출되지 않음
print(f"결과: {result}")

# 실제 활용: 기본값 설정
config = {"timeout": 30}
timeout = config.get("timeout") or 60  # timeout이 None이면 60 사용
print(f"\n타임아웃: {timeout}초")

# 안전한 접근
data = {"user": {"name": "Alice"}}
name = (data.get("user") or {}).get("name") or "익명"
print(f"사용자 이름: {name}")
```

## 실전 활용 패턴

### 가드 절 패턴

중첩된 조건문 대신 가드 절을 사용하면 코드 가독성을 높일 수 있습니다.

```python
# 가드 절 패턴 예제
def process_order(order):
    # 가드 절: 잘못된 입력 검사
    if not order:
        return {"success": False, "error": "주문 정보가 없습니다."}
    
    if "items" not in order or not order["items"]:
        return {"success": False, "error": "주문 항목이 없습니다."}
    
    if "user_id" not in order:
        return {"success": False, "error": "사용자 정보가 없습니다."}
    
    # 모든 검증 통과 후 실제 처리 로직
    total = sum(item["price"] * item["quantity"] for item in order["items"])
    
    # 추가 검증
    if total <= 0:
        return {"success": False, "error": "유효하지 않은 금액입니다."}
    
    # 정상 처리
    return {
        "success": True,
        "total_amount": total,
        "order_id": generate_order_id()
    }

def generate_order_id():
    import uuid
    return str(uuid.uuid4())[:8]

# 테스트
test_order = {
    "user_id": "user123",
    "items": [
        {"name": "노트북", "price": 1500000, "quantity": 1},
        {"name": "마우스", "price": 25000, "quantity": 2}
    ]
}

result = process_order(test_order)
print(result)
```

### EAFP vs LBYL

파이썬에서는 두 가지 접근 방식이 있습니다:

```python
# LBYL (Look Before You Leap) - 실행 전 검사
def get_user_age_LBYL(user_data):
    if "user" in user_data:
        if "profile" in user_data["user"]:
            if "age" in user_data["user"]["profile"]:
                return user_data["user"]["profile"]["age"]
    return None

# EAFP (Easier to Ask Forgiveness than Permission) - 시도 후 예외 처리
def get_user_age_EAFP(user_data):
    try:
        return user_data["user"]["profile"]["age"]
    except (KeyError, TypeError):
        return None

# 데이터 테스트
data1 = {"user": {"profile": {"age": 30, "name": "Alice"}}}
data2 = {"user": {"profile": {"name": "Bob"}}}
data3 = {}

print(f"LBYL 방식: {get_user_age_LBYL(data1)}")  # 30
print(f"EAFP 방식: {get_user_age_EAFP(data1)}")  # 30

print(f"LBYL 방식: {get_user_age_LBYL(data2)}")  # None
print(f"EAFP 방식: {get_user_age_EAFP(data2)}")  # None
```

파이썬 커뮤니티에서는 일반적으로 EAFP 방식을 선호합니다. 코드가 더 간결하고 파이썬다운 스타일입니다.

### any()와 all() 함수 활용

```python
# any()와 all() 함수 예제
numbers = [2, 4, 6, 8, 10]

# any(): 하나라도 참이면 True
if any(n % 2 == 1 for n in numbers):
    print("리스트에 홀수가 있습니다.")
else:
    print("모든 수가 짝수입니다.")

# all(): 모두 참이면 True
if all(n % 2 == 0 for n in numbers):
    print("모든 수가 짝수입니다.")
else:
    print("홀수가 포함되어 있습니다.")

# 실제 활용 예제
def is_valid_password(password):
    """비밀번호 유효성 검사"""
    if len(password) < 8:
        return False
    
    conditions = [
        any(c.isupper() for c in password),  # 대문자 포함
        any(c.islower() for c in password),  # 소문자 포함
        any(c.isdigit() for c in password),  # 숫자 포함
        any(c in "!@#$%^&*" for c in password),  # 특수문자 포함
    ]
    
    return all(conditions)

passwords = ["weak", "StrongPass1", "StrongPass!", "STRONGPASS1"]
for pwd in passwords:
    print(f"'{pwd}': {'유효' if is_valid_password(pwd) else '무효'}")
```

### match 문 (Python 3.10+)

파이썬 3.10부터는 패턴 매칭을 위한 `match` 문이 도입되었습니다.

```python
# match 문 예제 (Python 3.10+)
def handle_http_status(status_code):
    match status_code:
        case 200:
            return "성공"
        case 404:
            return "찾을 수 없음"
        case 500:
            return "서버 오류"
        case 401 | 403:  # 여러 값 매칭
            return "인증 오류"
        case _ if 400 <= status_code < 500:  # 가드 조건
            return "클라이언트 오류"
        case _ if 500 <= status_code < 600:
            return "서버 오류"
        case _:
            return "알 수 없는 상태"

# 테스트
test_codes = [200, 404, 500, 401, 403, 400, 503, 999]
for code in test_codes:
    print(f"HTTP {code}: {handle_http_status(code)}")
```

## 주의사항과 모범 사례

### 부동소수점 비교

부동소수점 숫자를 비교할 때는 직접 `==` 연산자를 사용하면 안 됩니다.

```python
# 부동소수점 비교 문제
a = 0.1 + 0.2
b = 0.3

print(f"0.1 + 0.2 = {a}")  # 0.30000000000000004
print(f"0.3 = {b}")        # 0.3
print(f"a == b: {a == b}") # False

# 올바른 방법
import math

# 상대 오차 허용
if math.isclose(a, b, rel_tol=1e-9):
    print("두 값은 실질적으로 같습니다.")

# 절대 오차 허용
if math.isclose(a, b, abs_tol=1e-10):
    print("두 값은 실질적으로 같습니다.")
```

### 복잡한 조건문 단순화

복잡한 조건문은 함수나 변수로 추출하면 가독성이 높아집니다.

```python
# 복잡한 조건문 개선 예제
def can_access_resource(user, resource):
    """리소스 접근 권한 검사"""
    
    # 나쁜 예: 모든 조건을 한 줄에
    # if user.is_active and user.has_permission(resource) and not resource.is_maintenance:
    
    # 좋은 예: 의미 있는 변수와 함수 사용
    is_user_valid = user.is_active and user.is_authenticated
    has_permission = user.has_permission(resource)
    is_resource_available = not resource.is_maintenance
    
    # 더 나은 예: 의미 있는 함수로 추출
    def check_user_access(user):
        return user.is_active and user.is_authenticated
    
    def check_resource_status(resource):
        return not resource.is_maintenance
    
    return check_user_access(user) and has_permission and check_resource_status(resource)
```

### 빈 컨테이너 검사

```python
# 빈 컨테이너 검사
data_structures = [
    [],        # 빈 리스트
    [1, 2, 3], # 채워진 리스트
    "",        # 빈 문자열
    "Hello",   # 채워진 문자열
    {},        # 빈 딕셔너리
    {"a": 1},  # 채워진 딕셔너리
    set(),     # 빈 집합
    {1, 2, 3}, # 채워진 집합
]

for ds in data_structures:
    # 올바른 방법
    if ds:  # 간결하고 파이썬다운
        print(f"{repr(ds)}: 비어있지 않음")
    else:
        print(f"{repr(ds)}: 비어있음")
    
    # 덜 좋은 방법
    # if len(ds) > 0:  # 불필요하게 장황함
    #     print(f"{repr(ds)}: 비어있지 않음")
```

### 할당 표현식 활용 (Python 3.8+)

```python
# 할당 표현식 예제 (왈러스 연산자 :=)
import re

# 이전 방식
text = "이메일: user@example.com, 전화: 010-1234-5678"
match = re.search(r'\d{3}-\d{4}-\d{4}', text)
if match:
    phone = match.group()
    print(f"전화번호: {phone}")

# 할당 표현식 사용
if match := re.search(r'\d{3}-\d{4}-\d{4}', text):
    print(f"전화번호: {match.group()}")

# 파일 처리에서 유용
lines = ["첫 번째 줄", "두 번째 줄", "END", "네 번째 줄"]
while (line := lines.pop(0)) != "END":
    print(f"처리 중: {line}")
```

## 실전 통합 예제

```python
# 사용자 인증 및 권한 시스템
class User:
    def __init__(self, username, age, roles, is_active=True):
        self.username = username
        self.age = age
        self.roles = set(roles)
        self.is_active = is_active
    
    def has_role(self, role):
        return role in self.roles

class Resource:
    def __init__(self, name, min_age=0, required_roles=None, is_maintenance=False):
        self.name = name
        self.min_age = min_age
        self.required_roles = set(required_roles or [])
        self.is_maintenance = is_maintenance

def check_access(user, resource):
    """사용자의 리소스 접근 권한 검사"""
    
    # 가드 절: 기본 검증
    if not user or not resource:
        return False, "유효하지 않은 입력"
    
    if not user.is_active:
        return False, "비활성화된 사용자"
    
    if resource.is_maintenance:
        return False, "점검 중인 리소스"
    
    # 나이 제한 검사
    if user.age < resource.min_age:
        return False, f"나이 제한: {resource.min_age}세 이상 필요"
    
    # 역할 기반 접근 제어
    if resource.required_roles:
        if not any(user.has_role(role) for role in resource.required_roles):
            return False, f"필요한 역할: {', '.join(resource.required_roles)}"
    
    # 특별 규칙 (관리자는 모든 접근 허용)
    if user.has_role("admin"):
        return True, "관리자 접근 허용"
    
    # 모든 검증 통과
    return True, "접근 허용"

# 테스트
users = [
    User("admin_user", 30, ["admin", "user"], True),
    User("adult_user", 25, ["user", "premium"], True),
    User("teen_user", 16, ["user"], True),
    User("inactive_user", 28, ["user"], False),
]

resources = [
    Resource("일반 콘텐츠", min_age=0, required_roles=["user"]),
    Resource("성인 콘텐츠", min_age=19, required_roles=["user"]),
    Resource("프리미엄 콘텐츠", min_age=0, required_roles=["premium", "admin"]),
    Resource("점검 중 리소스", min_age=0, required_roles=["user"], is_maintenance=True),
]

# 접근 테스트
for user in users:
    print(f"\n사용자: {user.username} (나이: {user.age}, 역할: {user.roles})")
    for resource in resources:
        allowed, reason = check_access(user, resource)
        status = "✓" if allowed else "✗"
        print(f"  {status} {resource.name}: {reason}")
```

## 결론

파이썬의 `if` 문은 단순한 조건 검사부터 복잡한 의사 결정까지 다양한 상황에 적용할 수 있는 강력한 도구입니다. 기본적인 `if-elif-else` 구조를 이해하는 것에서 시작하여, 진리값 평가, 단락 평가, 다양한 비교 연산자 등의 개념을 숙지하면 더 효율적이고 파이썬다운 코드를 작성할 수 있습니다.

실무에서는 가드 절 패턴을 활용해 중첩을 줄이고, EAFP 접근 방식을 선호하며, 복잡한 조건은 함수나 변수로 추출하는 것이 좋습니다. 또한 `any()`, `all()` 함수나 할당 표현식과 같은 파이썬의 고급 기능을 적절히 활용하면 코드의 가독성과 효율성을 높일 수 있습니다.

조건문은 프로그래밍의 논리적 흐름을 제어하는 핵심 요소이므로, 다양한 상황에서 연습하고 실제 프로젝트에 적용해 보는 것이 가장 좋은 학습 방법입니다. 명확하고 간결한 조건문은 버그를 줄이고 유지보수성을 높이는 데 큰 도움이 됩니다.