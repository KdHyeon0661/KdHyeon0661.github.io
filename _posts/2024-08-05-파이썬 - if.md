---
layout: post
title: 파이썬 - if 문
date: 2024-08-05 19:20:23 +0900
category: Python
---
# if 문

## 1. 기본 `if`

- **구조**
```python
if 조건:
    실행할_문장들
```

- **예시**
```python
x = 10
if x > 5:
    print("x는 5보다 큽니다.")
```

> 파이썬은 **들여쓰기**로 블록을 구분합니다. 공백/탭 혼용은 `IndentationError`를 유발합니다.

---

## 2. `if-else`

조건이 거짓일 때 실행할 대체 블록을 지정합니다.

```python
x = 3
if x > 5:
    print("x는 5보다 큽니다.")
else:
    print("x는 5보다 작거나 같습니다.")
```

---

## 3. `if-elif-else`

여러 조건 중 하나만 참일 때 해당 블록을 실행합니다.

```python
x = 7
if x > 10:
    print("x는 10보다 큽니다.")
elif x > 5:
    print("x는 5보다 크고 10 이하입니다.")
else:
    print("x는 5 이하입니다.")
```

> **상단에서 하단 순으로 평가**되며, **첫 True 블록**만 실행됩니다.

---

## 4. 중첩 if

```python
x = 15
if x > 10:
    if x < 20:
        print("x는 10보다 크고 20보다 작습니다.")
    else:
        print("x는 20 이상입니다.")
```

- 중첩이 깊어지면 가독성이 떨어집니다 → **가드 절(early return)**, **elif**로 평탄화 권장.

---

## 5. 한 줄 조건(조건 표현식 · “삼항 연산”)

단순한 분기에는 **조건 표현식**을 사용합니다.

```python
x = 10
result = "x는 양수입니다." if x > 0 else "x는 음수입니다."
print(result)
```

> 복잡한 표현을 한 줄에 억지로 넣으면 **가독성 저하**. 간결할 때만 사용하세요.

---

## 6. 비교/논리 연산자 요약

| 연산자 | 의미 | 예시 | 결과 |
|---|---|---|---|
| `==` | 동등 | `5 == 5` | `True` |
| `!=` | 비동등 | `5 != 3` | `True` |
| `<, >, <=, >=` | 대소 | `3 < 5` | `True` |
| `and` | 둘 다 참 | `(x > 0) and (x < 10)` | `True` |
| `or`  | 하나라도 참 | `(x > 10) or (x == 5)` | `True` |
| `not` | 부정 | `not (x > 5)` | `False` |
| `in` / `not in` | 멤버십 | `3 in [1,2,3]` | `True` |
| `is` / `is not` | 동일성 | `x is None` | (싱글턴 비교) |

- **체인 비교**: 파이썬은 비교 연산을 체인할 수 있습니다.
```python
x = 7
print(5 < x < 10)      # True  (5 < x and x < 10)
```

---

## 7. 진리값(truthiness)과 단락 평가

### 7.1 어떤 값이 참/거짓인가?
- **False로 평가**: `0`, `0.0`, `0j`, `None`, 빈 컨테이너(`""`, `[]`, `()`, `{}`, `set()`, `range(0)`), `__bool__`이 False를, 또는 `__len__`이 0을 반환하는 객체.
- 그 외는 **True**.

```python
print(bool(0), bool(""), bool([]), bool([1]))  # False False False True
```

### 7.2 단락 평가(short-circuit)
- `and`: 좌항이 False면 우항 **평가 안 함**.
- `or` : 좌항이 True면 우항 **평가 안 함**.
- 반환값은 **피연산자 그 자체**(진리값이 아님).

```python
def ping():
    print("call")
    return "PONG"

print(False and ping())   # False         (우항 미평가)
print(True or ping())     # True          (우항 미평가)

print("" or "default")    # "default"
print([1] and "X")        # "X"
```

> 이 특성을 이용해 **기본값 지정**, **안전 접근**(존재할 때만 접근) 패턴을 만들 수 있습니다.

---

## 8. 들여쓰기와 스타일

- PEP 8 권장: **4 스페이스** 들여쓰기.
- 중첩을 줄이기 위해 **가드 절** 사용:
```python
def process(item):
    if item is None:
        return "skip"
    if not item.is_valid():
        return "invalid"
    # 유효한 경우만 아래 로직
    return item.compute()
```

---

## 9. 실전 예제 모음

### 9.1 숫자 분류
```python
num = -10
if num > 0:
    print("양수입니다.")
elif num < 0:
    print("음수입니다.")
else:
    print("0입니다.")
```

### 9.2 멤버십 검사
```python
my_list = [1, 2, 3, 4, 5]
if 3 in my_list:
    print("3이 리스트에 있습니다.")
else:
    print("3이 리스트에 없습니다.")
```

### 9.3 논리 연산자 결합
```python
age = 25
if 18 <= age < 65:
    print("성인입니다.")
else:
    print("미성년자이거나 노인입니다.")
```

### 9.4 딕셔너리 키 존재 vs 값의 진리값
```python
payload = {"count": 0}

# 값의 진리값은 False지만 키는 존재함
if "count" in payload:
    print("키 존재, 값:", payload["count"])  # 0

# 'or' 기본값 패턴은 0/""도 덮어씀에 주의
count = payload.get("count") or 10   # → 10 (0이 Falsy라 대체됨)
# 안전하게:
count = payload["count"] if "count" in payload else 10
```

### 9.5 문자열 조건 깔끔하게
```python
name = "  alice  "
if (n := name.strip()):      # walrus(=할당표현식)로 클린/검사 동시
    print(f"hello {n}")
else:
    print("빈 입력")
```

### 9.6 안전 접근(딕셔너리 중첩)
```python
cfg = {"db": {"host": "localhost"}}
host = cfg.get("db", {}).get("host", "127.0.0.1")
print(host)
```

### 9.7 날짜 범위 검사(체인 비교)
```python
import datetime as dt

start = dt.date(2025, 1, 1)
end   = dt.date(2025, 12, 31)
today = dt.date(2025, 11, 10)

if start <= today <= end:
    print("캠페인 기간")
```

### 9.8 any/all로 복합 조건 정리
```python
user = {"roles": {"reader", "editor"}}
if any(r in user["roles"] for r in ("admin", "editor")):
    print("쓰기 권한")
```

### 9.9 예외와 if의 선택(EAFP vs LBYL)
- **LBYL**(Look Before You Leap): 먼저 검사하고 실행  
- **EAFP**(Easier to Ask Forgiveness than Permission): 그냥 시도, 예외 처리

```python
# LBYL
if "user" in cfg and "name" in cfg["user"]:
    name = cfg["user"]["name"]
else:
    name = "anonymous"

# EAFP
try:
    name = cfg["user"]["name"]
except KeyError:
    name = "anonymous"
```
> 딕셔너리 중첩 접근은 **EAFP가 간결**한 경우가 많습니다.

---

## 10. 흔한 함정과 모범 사례

### 10.1 `is` vs `==`
- **값 비교**는 `==`, **싱글턴(None 등) 비교**는 `is`.
```python
x = None
if x is None:
    ...
```

### 10.2 부동소수점 비교
- 직접 `==` 비교 대신 **허용 오차** 사용.
```python
import math
x, y = 0.1 + 0.2, 0.3
if math.isclose(x, y, rel_tol=1e-9, abs_tol=0.0):
    print("동등")
```

### 10.3 NaN 비교
- NaN은 자신과도 같지 않음 → `math.isnan()` 사용.
```python
import math
x = float('nan')
print(x == x)          # False
print(math.isnan(x))   # True
```

### 10.4 빈 컨테이너 검사
- `if not seq:` 가 관용적(길이가 0이면 False).
```python
items = []
if not items:
    print("비어 있음")
```

### 10.5 길고 복잡한 조건
- **중간 변수/함수**로 의도를 드러내기.
```python
def is_eligible(u):
    return u.age >= 18 and u.country in {"KR", "US"} and u.active

if is_eligible(user):
    ...
```

### 10.6 중첩 if 줄이기(가드 절)
```python
def handle(req):
    if not req.user:
        return "401"
    if not req.user.active:
        return "403"
    # 정상 처리
    return "200"
```

---

## 11. 컴프리헨션에서의 조건

### 11.1 필터 위치
```python
evens = [x for x in range(10) if x % 2 == 0]
```

### 11.2 값 선택용 조건 표현식
```python
labels = ["even" if x % 2 == 0 else "odd" for x in range(5)]
```

> **필터(if)** 와 **값 선택(조건 표현식)** 은 **위치가 다릅니다**.

---

## 12. 수학적 보조(드모르간 법칙)

논리식 단순화/부정 변환 시 유용합니다.

$$
\neg (A \land B) \equiv (\neg A) \lor (\neg B), \quad
\neg (A \lor B) \equiv (\neg A) \land (\neg B)
$$

```python
# 예시: "둘 다 ~가 아니다" → "하나라도 ~가 아니다"
if not (0 <= x <= 100):
    ...
# 동치:
if x < 0 or x > 100:
    ...
```

---

## 13. 종합 예제: 입력 검증 → 분기 → 처리

```python
def normalize_user(input_user: dict) -> dict:
    # 가드 절
    if input_user is None:
        return {"ok": False, "err": "no input"}

    # 필수 필드 검사
    required = {"name", "age"}
    if not required.issubset(input_user):
        missing = required - set(input_user)
        return {"ok": False, "err": f"missing: {sorted(missing)}"}

    # 값 정제
    name = (input_user.get("name") or "").strip()
    age  = input_user.get("age")

    if not name:
        return {"ok": False, "err": "empty name"}

    # 숫자 여부 검사 (EAFP)
    try:
        age = int(age)
    except (TypeError, ValueError):
        return {"ok": False, "err": "age must be int"}

    # 범위 검사(체인 비교 + 드모르간)
    if not (0 <= age <= 150):
        return {"ok": False, "err": "age out of range"}

    # 최종
    return {"ok": True, "user": {"name": name, "age": age}}

print(normalize_user({"name": "  Alice ", "age": "30"}))
```

---

## 14. 체크리스트(요약)

- **기본 분기**: `if / elif / else`, 들여쓰기 엄수.
- **체인 비교**: `a < x < b` 간결/효율적.
- **truthiness**: 빈 컨테이너/0/None은 False.
- **단락 평가**: `and`/`or`는 피연산자 **자체 반환**.
- **None 비교**는 `is`, 값 비교는 `==`.
- **부동소수점/NaN**: `math.isclose`, `math.isnan`.
- **가독성**: 가드 절, 중간 변수/함수로 조건 분해.
- **컴프리헨션**: 필터 `if`와 값 선택(조건 표현식)을 구분.