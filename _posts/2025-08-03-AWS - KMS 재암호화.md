---
layout: post
title: AWS - KMS 재암호화
date: 2025-08-03 23:20:23 +0900
category: AWS
---
# KMS 재암호화(ReEncrypt)로 키 교체하는 단계별 스크립트 & 운영 가이드

## 핵심 요약

- **사용 API**: `KMS.ReEncrypt` (CLI: `aws kms re-encrypt`, SDK: `re_encrypt`).
- **최선 전략**: **엔벨로프(Envelope)** 구조라면 **데이터(파일/레코드)는 건드리지 않고** 저장된 **암호문 데이터 키(EDK)만 재암호화**.
- **S3 객체(SSE-KMS)**: **CopyObject / S3 Batch Operations**로 키 교체.
- **불가피한 경우**: 클라이언트 복호화 → 재암호화(평문 일시 노출) — 최소화·격리 필요.

---

## **언제 ReEncrypt를 쓰나?** (개념 정리)

- **대상**: KMS에서 **만든 암호문** (예: `GenerateDataKey`의 `CiphertextBlob`, `Encrypt` 결과).
- **동작**: KMS 내부에서 **복호화 → 새 키로 재암호화** → **새 암호문** 반환.
- **장점**: **평문을 호출자에게 돌려주지 않음** → 애플리케이션이 평문을 다루지 않음.
- **전형 사례**:
  - 엔벨로프 저장 구조: `ciphertext_data_key`(=EDK) + (AES-GCM으로 암호화된 데이터). **EDK만 교체**.
  - 계정/리전 분리, 키 회전 정책 변경, 조직 합병/분리 시 **키 전환**.

---

## **전략 요약 — 3 패턴**

| 패턴 | 사용 조건 | 데이터 평문 취급 | 비고 |
|---|---|---|---|
| **A. ReEncrypt(EDK만)** | 엔벨로프 구조(EDK 저장) | **아니오** | **권장**. 데이터 재암호화 불필요, 빠르고 안전 |
| **B. S3 SSE-KMS Copy** | S3 SSE-KMS 객체 | **아니오** | 단건: CopyObject, 대량: **S3 Batch Operations** |
| **C. 클라이언트 복호화 → 재암호화** | KMS 암호문이 아님 / 형식 미호환 | **예(일시)** | 최소화·격리·감사. 마지막 선택지 |

---

## **사전 준비** (권한·정책·테스트)

### 최소 권한(예: `DataMigratorRole`)

- **소스 키**: `kms:ReEncryptFrom`, `kms:DescribeKey`
- **대상 키**: `kms:ReEncryptTo`, `kms:DescribeKey`
- **S3 작업 시**: `s3:GetObject`, `s3:PutObject`, `s3:CopyObject`, `s3:ListBucket`
- **옵션**: 편의상 `kms:ReEncrypt*`로 양쪽 키에 허용(운영 전엔 분리 권장).

### 키 정책(Key policy) 스니펫

```json
{
  "Version":"2012-10-17",
  "Statement":[
    {
      "Sid":"AllowReEncryptFrom",
      "Effect":"Allow",
      "Principal":{"AWS":"arn:aws:iam::123456789012:role/DataMigratorRole"},
      "Action":[ "kms:ReEncryptFrom","kms:DescribeKey" ],
      "Resource":"*"
    }
  ]
}
```

```json
{
  "Version":"2012-10-17",
  "Statement":[
    {
      "Sid":"AllowReEncryptTo",
      "Effect":"Allow",
      "Principal":{"AWS":"arn:aws:iam::123456789012:role/DataMigratorRole"},
      "Action":[ "kms:ReEncryptTo","kms:DescribeKey" ],
      "Resource":"*"
    }
  ]
}
```

> **실무 팁**: `aws:SourceAccount`, `kms:ViaService`(S3 경유 등), `aws:PrincipalOrgID` 조건으로 **범위 최소화**.

### 테스트 & 백업

- **샘플 데이터셋(1~2%)**로 **리허설** → CloudTrail/KMS/CloudWatch 모니터링.
- S3는 **버전 관리** 활성화(롤백 쉬움).
- DB/메타스토어는 **임시 보조 컬럼**(새 EDK)로 **이중 기록 → 전환**.

---

## **방법 A — KMS ReEncrypt로 EDK만 교체 (권장)**

### CLI: 로컬 EDK 파일 교체

```bash
# old_ciphertext.bin(원본 EDK, 바이너리) → 새 키로 재암호화 → new_ciphertext.bin

aws kms re-encrypt \
  --ciphertext-blob fileb://old_ciphertext.bin \
  --destination-key-id arn:aws:kms:ap-northeast-2:123456789012:key/NEW-KEY \
  --source-encryption-context '{"purpose":"doc"}' \
  --destination-encryption-context '{"purpose":"doc","rotated":"2025-11-10"}' \
  --query CiphertextBlob --output text | base64 --decode > new_ciphertext.bin
```

> **컨텍스트**를 사용했다면 **Source**/**Destination**에 정확히 전달(AD=GCM AAD처럼 **무결성 바인딩** 역할).

### Python(boto3): S3 객체 메타데이터의 **EDK 재암호화 후 원자적 갱신**

> 가정: S3 객체에는 `Metadata.edk`(base64-encoded EDK)가 저장되어 있고, 데이터 본문은 AES-GCM 등으로 이미 암호문.

```python
import boto3, base64, json, time
from botocore.config import Config
from botocore.exceptions import ClientError

REGION = "ap-northeast-2"
BUCKET = "my-encrypted-bucket"
NEW_KEY_ARN = "arn:aws:kms:ap-northeast-2:123456789012:key/NEW-KEY"

kms = boto3.client("kms", region_name=REGION, config=Config(retries={"max_attempts": 10}))
s3  = boto3.client("s3",  region_name=REGION)

def reencrypt_object_edk(key: str):
    head = s3.head_object(Bucket=BUCKET, Key=key)
    meta = head.get("Metadata", {})
    edk_b64 = meta.get("edk")
    if not edk_b64:
        raise RuntimeError(f"EDK metadata missing: s3://{BUCKET}/{key}")

    old_blob = base64.b64decode(edk_b64)

    # ReEncrypt (평문 노출 없음)
    resp = kms.re_encrypt(
        CiphertextBlob=old_blob,
        DestinationKeyId=NEW_KEY_ARN,
        SourceEncryptionContext={"purpose": "s3-object"},
        DestinationEncryptionContext={"purpose": "s3-object", "rotated": "2025-11-10"}
    )
    new_blob = resp["CiphertextBlob"]
    new_edk_b64 = base64.b64encode(new_blob).decode("utf-8")

    # 원자적 갱신: CopyObject + MetadataDirective=REPLACE
    new_meta = meta.copy()
    new_meta["edk"] = new_edk_b64

    s3.copy_object(
        Bucket=BUCKET,
        CopySource={"Bucket": BUCKET, "Key": key},
        Key=key,
        Metadata=new_meta,
        MetadataDirective="REPLACE"
    )
    return True

if __name__ == "__main__":
    for objkey in ["logs/2025/11/10/a.enc", "logs/2025/11/10/b.enc"]:
        try:
            ok = reencrypt_object_edk(objkey)
            print("OK:", objkey, ok)
        except ClientError as e:
            print("ERR:", objkey, e)
```

**운영 포인트**
- 실패 시 **원본 메타데이터(EDK)** 유지 → **재시도** 용이.
- **버전 관리**가 켜져 있으면 변경 이력 추적/롤백 간편.
- 대량 작업은 **paginator + ThreadPoolExecutor**로 **동시성 제한**(예: 100) & **지수 백오프**.

### Node.js(AWS SDK v3): DB(예: DynamoDB)에 저장한 EDK 컬럼 교체

```js
// npm i @aws-sdk/client-kms @aws-sdk/client-dynamodb p-limit
import { KMSClient, ReEncryptCommand } from '@aws-sdk/client-kms';
import { DynamoDBClient, ScanCommand, UpdateItemCommand } from '@aws-sdk/client-dynamodb';
import pLimit from 'p-limit';

const region = 'ap-northeast-2';
const NEW_KEY_ARN = 'arn:aws:kms:ap-northeast-2:123456789012:key/NEW-KEY';

const kms = new KMSClient({ region });
const ddb = new DynamoDBClient({ region });

async function reencryptItemEDK(item) {
  const oldB64 = item.EDK.S; // base64 string
  const oldBlob = Buffer.from(oldB64, 'base64');
  const out = await kms.send(new ReEncryptCommand({
    CiphertextBlob: oldBlob,
    DestinationKeyId: NEW_KEY_ARN,
    SourceEncryptionContext: { purpose: 'ddb-row' },
    DestinationEncryptionContext: { purpose: 'ddb-row', rotated: '2025-11-10' }
  }));
  const newB64 = Buffer.from(out.CiphertextBlob).toString('base64');

  await ddb.send(new UpdateItemCommand({
    TableName: 'SecureTable',
    Key: { PK: item.PK, SK: item.SK },
    UpdateExpression: 'SET EDK = :edk, KeyRotatedAt = :ts',
    ExpressionAttributeValues: {
      ':edk': { S: newB64 },
      ':ts':  { S: new Date().toISOString() }
    },
    ConditionExpression: 'attribute_exists(PK)' // idempotency guard
  }));
}

(async () => {
  const scan = await ddb.send(new ScanCommand({ TableName: 'SecureTable' }));
  const limit = pLimit(100); // max concurrency
  await Promise.all(scan.Items.map(i => limit(() => reencryptItemEDK(i))));
  console.log('done');
})();
```

---

## **방법 B — S3 SSE-KMS 객체 키 변경 (Copy / Batch)**

### 단일/소량: `copy-object`

```bash
aws s3api copy-object \
  --bucket my-bucket \
  --copy-source my-bucket/path/to/object.parquet \
  --key path/to/object.parquet \
  --server-side-encryption aws:kms \
  --ssekms-key-id arn:aws:kms:ap-northeast-2:123456789012:key/NEW-KEY
```

- S3가 내부적으로 **읽고 새 키로 씀** → **평문 미노출**.
- **메타데이터 유지/교체**는 `MetadataDirective`로 제어.

### 대규모: **S3 Batch Operations**

1) **Inventory** 목록 생성 → 대상 오브젝트 CSV/Manifest 준비
2) **Batch 작업**: **Copy** with `sseAwsKmsKeyId=NEW-KEY`

**예시 Manifest (CSV)**

```csv
Bucket,Key,VersionId
my-bucket,logs/2025/11/10/a.parquet,
my-bucket,logs/2025/11/10/b.parquet,
```

**IAM 역할**: S3 Batch가 대상 객체 읽기/쓰기 + KMS 사용 가능해야 함.
**리포트**: 성공/실패 오브젝트 리포트 → **재시도 대상** 자동 식별.

---

## **방법 C — 클라이언트 복호화 → 재암호화** (최후의 수단)

### Python 예시 (로컬에서 AES-GCM 복호화 → 새 키로 EDK 생성)

```python
# 가정: 데이터는 AES-GCM으로 암호화되어 있고, KMS EDK 없이 로컬 키만으로 관리 중이었다고 가정
# → 복호화 후 KMS에서 데이터 키 발급(GenerateDataKey) → 데이터 재암호화 → 암호문 + EDK 저장

import os, boto3
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

kms = boto3.client("kms", region_name="ap-northeast-2")
NEW_KEY_ARN = "arn:aws:kms:ap-northeast-2:123456789012:key/NEW-KEY"

def decrypt_local(cipher_blob: bytes, local_key: bytes) -> bytes:
    aes = AESGCM(local_key)
    nonce, ct = cipher_blob[:12], cipher_blob[12:]
    return aes.decrypt(nonce, ct, None)

def reencrypt_to_kms(plaintext: bytes):
    g = kms.generate_data_key(KeyId=NEW_KEY_ARN, KeySpec="AES_256",
                              EncryptionContext={"purpose":"migrated"})
    ptk, edk = g["Plaintext"], g["CiphertextBlob"]
    aes = AESGCM(ptk)
    nonce = os.urandom(12)
    ct = nonce + aes.encrypt(nonce, plaintext, None)
    del ptk
    return ct, edk

# 사용: old_cipher.bin + local_key -> (ct_kms, edk)

```

> **주의**: 평문 **메모리 상주 시간 최소화**, 스왑/코어덤프/로그에 **흔적 금지**. 가능하면 **임시 전용 VPC·암호화 디스크·HSM 경계**에서 수행.

---

## **대규모 마이그레이션 운영 팁**

### 처리량·제한

- **KMS 스로틀** 방지: 동시성 제한(예: 50~200), **지수 백오프**.
- **분할(batch) 처리**: 접두사/기간/파티션 단위로 분리.
- **관찰 지표**: `KMS Throttles`, 오류율, 평균/백분위 지연.

### 신뢰성

- **Idempotency**: 동일 항목 재실행해도 안전(조건식/버전·타임스탬프 컬럼).
- **저장 전 검증**: 새 EDK 저장 후 **읽어 복호화 테스트(샘플링)**.
- **원자성**: S3는 **CopyObject**로 메타 전량 교체. DB는 **새 컬럼 병행** 후 스위칭.

### 모니터링/감사

- **CloudTrail**: `ReEncrypt`, `Decrypt`, `GenerateDataKey` 호출 **누가/언제/어디서**.
- **CloudWatch Logs/Metric Filters**: 오류 패턴 알람.
- **Athena 쿼리**(CloudTrail S3 로그 파서)로 **이상 호출 탐지**.

**예시: Athena로 ReEncrypt 호출 집계**

```sql
SELECT eventsource, eventname, useridentity.principalid, count(*) AS cnt
FROM cloudtrail_logs
WHERE eventname = 'ReEncrypt'
  AND from_iso8601_timestamp(eventtime) BETWEEN
      timestamp '2025-11-10 00:00:00' AND timestamp '2025-11-10 23:59:59'
GROUP BY 1,2,3
ORDER BY cnt DESC;
```

### 롤백

- **S3 버전 관리** 켜두면 **이전 버전**으로 복원.
- DB는 **원본 EDK 백업 컬럼** 보관(만료 기간 두고 제거).
- **드라이런(dry-run)** 모드로 목록·권한·속도·비용 추정.

---

## **보안·감사 체크리스트**

- [ ] **Least Privilege**: 소스=From, 대상=To 권한 분리 (`kms:ReEncryptFrom/To`).
- [ ] **키 정책 + IAM 정책** **교차 검증** (둘 다 허용 필요).
- [ ] **Encryption Context 일치** — Source/Destination 정확히 지정.
- [ ] **CloudTrail** 전체 지역 활성화 + S3/CloudTrail 버킷 암호화(KMS).
- [ ] **S3 버전 관리**, **버킷 정책: TLS/VPCe/KMS 필수**.
- [ ] **백오프/재시도/장애 재수행** 설계.
- [ ] **DR/멀티리전**: Multi-Region Key 필요성 검토.
- [ ] **비용/성능** 모니터링: 호출 수·실패율·지연.

---

## **운영 스크립트 모음** (샘플)

### Python: **대량 S3 EDK 재암호화** (병렬 + 재시도)

```python
import boto3, base64, concurrent.futures, time, sys
from botocore.config import Config
from botocore.exceptions import ClientError

REGION = "ap-northeast-2"
BUCKET = "my-encrypted-bucket"
PREFIX = "logs/2025/11/10/"
NEW_KEY_ARN = "arn:aws:kms:ap-northeast-2:123456789012:key/NEW-KEY"
MAX_WORKERS = 128

kms = boto3.client("kms", region_name=REGION, config=Config(retries={"max_attempts": 10}))
s3  = boto3.client("s3",  region_name=REGION)

def reencrypt_one(key):
    try:
        head = s3.head_object(Bucket=BUCKET, Key=key)
        meta = head.get("Metadata", {})
        edk_b64 = meta.get("edk")
        if not edk_b64:
            return (key, "SKIP_NO_EDK")
        old_blob = base64.b64decode(edk_b64)

        out = kms.re_encrypt(
            CiphertextBlob=old_blob,
            DestinationKeyId=NEW_KEY_ARN,
            SourceEncryptionContext={"purpose":"s3-object"},
            DestinationEncryptionContext={"purpose":"s3-object","rotated":"2025-11-10"}
        )
        new_edk_b64 = base64.b64encode(out["CiphertextBlob"]).decode("utf-8")
        new_meta = meta.copy()
        new_meta["edk"] = new_edk_b64

        s3.copy_object(
            Bucket=BUCKET,
            CopySource={"Bucket": BUCKET, "Key": key},
            Key=key,
            Metadata=new_meta,
            MetadataDirective="REPLACE"
        )
        return (key, "OK")
    except ClientError as e:
        return (key, f"ERR:{e.response.get('Error',{}).get('Code')}")

def list_keys(bucket, prefix):
    paginator = s3.get_paginator("list_objects_v2")
    for page in paginator.paginate(Bucket=bucket, Prefix=prefix):
        for o in page.get("Contents", []):
            yield o["Key"]

if __name__ == "__main__":
    keys = list(list_keys(BUCKET, PREFIX))
    stats = {"OK":0}
    with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as ex:
        for k, res in ex.map(reencrypt_one, keys):
            stats[res] = stats.get(res, 0) + 1
            if stats.get("OK",0) % 1000 == 0:
                print("Progress OK:", stats["OK"])
    print("Summary:", stats)
```

### Bash: **로컬 EDK 파일 일괄 재암호화**

```bash
#!/usr/bin/env bash

set -euo pipefail
NEW_KEY="arn:aws:kms:ap-northeast-2:123456789012:key/NEW-KEY"
SRC_DIR="old-edk"
DST_DIR="new-edk"
mkdir -p "$DST_DIR"

for f in "$SRC_DIR"/*.bin; do
  base=$(basename "$f")
  aws kms re-encrypt \
    --ciphertext-blob fileb://"$f" \
    --destination-key-id "$NEW_KEY" \
    --query CiphertextBlob --output text | base64 --decode > "$DST_DIR/$base"
done
echo "done."
```

### Java (v2 SDK): EDK 재암호화

```java
KmsClient kms = KmsClient.builder().region(Region.AP_NORTHEAST_2).build();
ReEncryptRequest req = ReEncryptRequest.builder()
    .ciphertextBlob(SdkBytes.fromByteArray(oldBlob))
    .destinationKeyId("arn:aws:kms:ap-northeast-2:123456789012:key/NEW-KEY")
    .sourceEncryptionContext(Map.of("purpose","row"))
    .destinationEncryptionContext(Map.of("purpose","row","rotated","2025-11-10"))
    .build();
ReEncryptResponse resp = kms.reEncrypt(req);
byte[] newBlob = resp.ciphertextBlob().asByteArray();
```

---

## **무결성/비용 메모**

- **무결성**: 엔벨로프 구조에서 **데이터 암호문은 그대로**, **EDK만 교체**.
- **비용 근사**:
  $$
  C \approx N_{op} \cdot c_{reenc} + N_{copy} \cdot c_{s3copy} + C_{\text{monitoring}}
  $$
  - \(N_{op}\): ReEncrypt 호출 수, \(c_{reenc}\): 호출당 KMS 비용
  - \(N_{copy}\): S3 copy 수, \(c_{s3copy}\): 객체 크기/리전/클래스 기반 비용

---

## **Step Functions로 안전한 일괄 오케스트레이션** (옵션)

- **Map 상태**로 키 목록을 청크 분할, **KMS Throttle** 발생 시 자동 **재시도**.
- **성공/실패 카운트** 집계 → 알림(SNS).
- **Partial 실패**는 **DLQ(SQS)**로 보내 재처리.

**ASL 스케치**

```json
{
  "StartAt": "ChunkLoop",
  "States": {
    "ChunkLoop": {
      "Type": "Map",
      "MaxConcurrency": 50,
      "Iterator": {
        "StartAt": "ReEncryptOne",
        "States": {
          "ReEncryptOne": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Retry": [{ "ErrorEquals": ["ThrottlingException"], "IntervalSeconds": 2, "MaxAttempts": 6, "BackoffRate": 2.0 }],
            "End": true
          }
        }
      },
      "End": true
    }
  }
}
```

---

## **운영 점검표 (최소 세트)**

- [ ] 샘플/드라이런 성공 (권한·속도·로그 확인)
- [ ] CloudTrail에 `ReEncrypt` 호출 이력 정상 기록
- [ ] 실패율 < 0.1% / 재시도 성공률 확인
- [ ] 롤백 경로(S3 버전/EDK 백업 컬럼) 확보
- [ ] **컨텍스트 일치성** 검증 (랜덤 샘플 복호화 테스트)
- [ ] 결과 리포트(요약/실패 목록) 보존

---

## **FAQ**

**Q1. ReEncrypt는 항상 평문을 반환 안 하나요?**
A. 네, **새 암호문만 반환**합니다. (EDK 교체 시 평문 노출 없음)

**Q2. 컨텍스트를 바꾸고 싶어요.**
A. `DestinationEncryptionContext`에 **새 컨텍스트** 지정 가능. 단, 원본이 컨텍스트로 보호됐다면 `SourceEncryptionContext`를 **정확히** 제공해야 합니다.

**Q3. S3 SSE-KMS 객체는 ReEncrypt로 못 하나요?**
A. 보통 **S3 Copy**가 표준입니다. EDK를 별도 메타로 관리하는 **엔벨로프 구조**라면 A 패턴(EDK만 교체)이 더 효율적.

**Q4. 교체 완료 검증은 어떻게?**
A. 임의 샘플에 대해 **새 EDK로 Decrypt → 데이터 복호화 성공**을 확인. S3 버전이 있다면 **버전 비교**로 무결성 추적.

---

## **CloudFormation/CDK 스니펫** (키/권한 배포)

### CloudFormation — 대상 CMK

```yaml
Resources:
  NewAppKey:
    Type: AWS::KMS::Key
    Properties:
      EnableKeyRotation: true
      Description: New CMK for rotation 2025-11
      KeyPolicy:
        Version: "2012-10-17"
        Statement:
          - Sid: Admins
            Effect: Allow
            Principal:
              AWS: arn:aws:iam::123456789012:role/KMSAdmins
            Action: "kms:*"
            Resource: "*"
          - Sid: AllowMigratorReEncryptTo
            Effect: Allow
            Principal:
              AWS: arn:aws:iam::123456789012:role/DataMigratorRole
            Action:
              - kms:ReEncryptTo
              - kms:DescribeKey
            Resource: "*"
```

### CDK(TypeScript) — S3 기본 암호화에 새 키 지정

```ts
import * as cdk from 'aws-cdk-lib';
import * as kms from 'aws-cdk-lib/aws-kms';
import * as s3  from 'aws-cdk-lib/aws-s3';

export class RotationStack extends cdk.Stack {
  constructor(scope: cdk.App, id: string, props?: cdk.StackProps){
    super(scope, id, props);

    const key = new kms.Key(this, 'NewKey', {
      enableKeyRotation: true,
      alias: 'alias/app-2025-11',
      description: 'Rotation key 2025-11'
    });

    new s3.Bucket(this, 'DataBucket', {
      encryption: s3.BucketEncryption.KMS,
      encryptionKey: key,
      enforceSSL: true,
      bucketKeyEnabled: true
    });
  }
}
```

---

## **간단 수식으로 보는 작업 한도 & 시간 추정**

- 병렬도 \(p\), 단건 평균 소요 \(t\)초, 총 개수 \(N\)일 때 **이론적 최소 시간**:
  $$
  T_{\min} \approx \frac{N \cdot t}{p}
  $$
  단, **KMS 스로틀/네트워크/IO**로 인해 실제 \(T \ge T_{\min}\).
- **안전 병렬도** \(p^*\)는 KMS 지역별 제한과 **오류율**로 조정:
  $$
  p^* = \arg\min_p \big(\text{오류율}(p) < \epsilon \land T(p) \text{ 최소}\big)
  $$

---

## **결론**

- **가장 안전하고 간단한 길**: **EDK만 ReEncrypt**(데이터 비접촉), 혹은 **S3 Copy/Batch**.
- **대규모/운영 품질**: 동시성 제어, 재시도, **감사**(CloudTrail), **롤백**(S3 버전/EDK 백업), **점진 롤아웃**이 핵심.
- **정책/컨텍스트/권한의 교집합**을 정확히 설계하면, **평문 노출 없이**도 **안전하고 반복 가능한** 키 교체가 가능하다.
