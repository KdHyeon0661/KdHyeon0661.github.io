---
layout: post
title: AWS - KMS 재암호화
date: 2025-08-03 23:20:23 +0900
category: AWS
---
# 🔁 KMS 재암호화(ReEncrypt)로 키 교체하는 **단계별** 스크립트 & 운영 가이드

이 문서는 AWS KMS의 **ReEncrypt** 기능을 사용해 "기존 데이터(또는 데이터 키에 대한 암호문)를 새 CMK(또는 다른 CMK)으로 안전하게 교체(키 전환/키 교체)"하는 **실무용 단계별 스크립트**와 운영·보안·대규모 적용 시 고려사항을 포함합니다.

## 요약(한줄)
- **목표**: 평문 노출 없이(가능한 경우) 기존 암호문을 새 키로 옮기는 것.  
- **핵심 도구**: `KMS.ReEncrypt` API (CLI: `aws kms re-encrypt` / boto3: `re_encrypt`) — KMS 내부에서 복호화 후 재암호화 수행.  
- **적용 대상**: KMS로 암호화된 "암호문(예: encrypted data key)" 또는 KMS가 암호화한 단일 바이트 블록(예: 파일의 CiphertextBlob).  
- **대체/보완**: S3의 SSE-KMS 객체는 S3 Copy(또는 S3 Batch Operations)로 키를 바꾸는 것이 일반적.

---

## 목차
1. 사전 개념 정리 — 언제 ReEncrypt를 쓰나  
2. 전략(방법) 요약 — 3가지 패턴  
3. 사전 준비 (권한·정책·테스트)  
4. 방법 A — **KMS ReEncrypt**로 암호문(데이터키 등) 직접 교체 (권장, 평문 비노출)  
   - CLI 예제  
   - boto3(파이썬) 예제  
5. 방법 B — S3 SSE-KMS 객체의 키 변경 (Copy / Batch)  
   - CLI / boto3 예제  
6. 방법 C — 클라이언트 사이드(평문 복호화 → 재암호화) (불가피한 경우)  
7. 대규모 마이그레이션 운영 팁 (배치, 모니터링, 오류·재시도, 롤백)  
8. 보안·감사 체크리스트  
9. FAQ(자주 묻는 질문)

---

## 1) 사전 개념 — 언제 ReEncrypt를 쓰나
- **ReEncrypt**는 KMS가 관리하는 암호문(예: `GenerateDataKey`에서 나온 `CiphertextBlob`, 혹은 `Encrypt`로 만든 암호문)을 **KMS 내부에서** 복호화한 뒤 *다른* CMK로 재암호화해 새 암호문을 반환합니다.
- 장점: 애플리케이션이 **평문(Plaintext)** 을 직접 다루지 않아도 됨 → **안전성 우수**.
- 주의: ReEncrypt는 **원본 암호문이 KMS에서 생성된 형태**(즉 KMS가 관리하는 암호문)여야 제대로 동작. 일반 애플리케이션이 자체 생성·관리한 암호문(예: 자체 RSA 암호화 결과)은 먼저 복호화 후 재암호화해야 함.

---

## 2) 전략(방법) 요약 — 세 가지 패턴

A. **ReEncrypt 데이터 키(권장)**  
   - 애플리케이션이 envelope encryption 패턴: `CiphertextDataKey`(KMS 암호문) + 실제 데이터(대칭키로 암호화)로 저장해 둔 경우, **CiphertextDataKey만 ReEncrypt**하면 됨. 데이터 자체는 건드릴 필요 없음. (평문 데이터 키가 노출되지 않음.)

B. **S3 SSE-KMS 객체 키 교체**  
   - S3에서 SSE-KMS로 보호된 객체는 **S3 CopyObject** (또는 S3 Batch Operations)를 통해 새 KMS 키로 재암호화(복사) 가능. 내부적으로 S3가 객체를 읽어 새 키로 쓰므로 사용자가 평문을 다루지 않아도 됨.

C. **클라이언트 사이드 암호화(직접 복호화 → 재암호화)**  
   - 대상 암호문이 KMS와 무관하거나 ReEncrypt를 사용할 수 없을 때. 이 경우 애플리케이션이 데이터를 복호화(평문 취득) 후 새 키로 재암호화함. **평문 노출 리스크**와 KMS 호출 증가에 주의.

---

## 3) 사전 준비 (권한·정책·테스트)
- **권한(최소 권한 원칙)**  
  - ReEncrypt를 수행할 주체(예: `DataMigratorRole`)에 다음 권한이 필요:
    - `kms:ReEncryptFrom` (또는 `kms:ReEncrypt*`) on **소스 키**
    - `kms:ReEncryptTo` (또는 `kms:ReEncrypt*`) on **대상 키**
    - `kms:DescribeKey` (권장)
    - (S3 객체 수정 시) `s3:GetObject`, `s3:PutObject`, `s3:CopyObject`, `s3:ListBucket` 등
  - 콘솔/문서 편의상 `kms:ReEncrypt*`로 양쪽 키에 허용하면 간단(하지만 더 세분화된 정책 권장).

- **키 정책**  
  - 소스/대상 CMK의 키 정책(Key policy)에 `ReEncryptFrom`/`ReEncryptTo` 권한을 부여해야 합니다. (KMS 문서 권장)

- **테스트 환경**  
  - 프로덕션 전 **작은 샘플 데이터셋**(S3 버킷 복제본 또는 테스트 객체)을 준비해 먼저 테스트하세요.
  - **버전관리(예: S3 버전)**, 백업을 켜두고 시도하세요.

---

## 4) 방법 A — KMS `ReEncrypt`로 **암호문(데이터키 등)** 직접 교체 (권장)

### 흐름 (envelope encryption 시)
1. 객체(또는 DB 레코드)에 저장된 `EncryptedDataKey`(=old_ciphertext_blob)와 encryption context(metadata)를 읽어온다.  
2. KMS `ReEncrypt` 호출: `CiphertextBlob=old_blob`, `DestinationKeyId=new_cmk_arn`, `SourceEncryptionContext=...` (필요 시), `DestinationEncryptionContext=...` (필요 시).  
3. KMS가 새로운 `CiphertextBlob`(new_blob)을 반환. 이걸 객체의 메타데이터(DB 컬럼)에 저장(교체).  
   - **중요**: 새 blob을 저장하기 전까지 원본을 보존(atomic 교체/버전) — 실패 대비.

### CLI 예제 (로컬 파일: old_ciphertext.bin → new_ciphertext.bin)

```bash
# 1) re-encrypt: old ciphertext file -> new ciphertext (base64 binary in JSON; we write raw bytes)
aws kms re-encrypt \
  --ciphertext-blob fileb://old_ciphertext.bin \
  --destination-key-id arn:aws:kms:ap-northeast-2:123456789012:key/NEW-KEY-ID \
  --source-encryption-context '{"purpose":"file-backup"}' \
  --destination-encryption-context '{"purpose":"file-backup","rotated":"2025-08-10"}' \
  --query CiphertextBlob --output text | base64 --decode > new_ciphertext.bin
```

> `--source-encryption-context`/`--destination-encryption-context` 는 필요하면 JSON 문자열로 전달. (CLI의 quoting 주의)

### boto3 (Python) 예제 — S3 객체의 encrypted-data-key를 재암호화하고 메타데이터 업데이트

아래 예시는 **애플리케이션이 envelope 방식**으로 S3 객체를 저장했고, 메타데이터에 `x-amz-meta-encrypted-key`(hex/base64)로 암호문을 보관해 둔 시나리오입니다.

```python
import boto3
import base64
import botocore

s3 = boto3.client('s3')
kms = boto3.client('kms', region_name='ap-northeast-2')

SRC_BUCKET = 'my-encrypted-bucket'
OBJ_KEY = 'path/to/object.enc'
NEW_KEY_ARN = 'arn:aws:kms:ap-northeast-2:123456789012:key/NEW-KEY-ID'

def reencrypt_object_data_key(bucket, key):
    # 1) Get object metadata (assume encrypted data key stored in metadata 'x-amz-meta-edk' base64)
    head = s3.head_object(Bucket=bucket, Key=key)
    meta = head.get('Metadata', {})
    edk_b64 = meta.get('edk')  # e.g., base64-encoded ciphertext blob
    if not edk_b64:
        raise Exception("No encrypted data key found in metadata")

    old_blob = base64.b64decode(edk_b64)

    # 2) ReEncrypt using KMS
    # If encryption context was used originally, provide it via SourceEncryptionContext
    resp = kms.re_encrypt(
        CiphertextBlob=old_blob,
        DestinationKeyId=NEW_KEY_ARN,
        SourceEncryptionContext={'purpose': 's3-object'},
        DestinationEncryptionContext={'purpose': 's3-object', 'rotated': '2025-08-10'}
    )

    new_blob = resp['CiphertextBlob']  # bytes

    # 3) Update object metadata atomically by copying over itself (S3 metadata replacement)
    # Note: CopyObject requires full replacement of metadata if MetadataDirective='REPLACE'
    new_metadata = meta.copy()
    new_metadata['edk'] = base64.b64encode(new_blob).decode('utf-8')

    # CopyObject: same key -> replace metadata (this will create a new object version if versioning enabled)
    s3.copy_object(
        Bucket=bucket,
        CopySource={'Bucket': bucket, 'Key': key},
        Key=key,
        Metadata=new_metadata,
        MetadataDirective='REPLACE'
    )
    print(f"Re-encrypted EDK for {key} and updated metadata")

if __name__ == '__main__':
    reencrypt_object_data_key(SRC_BUCKET, OBJ_KEY)
```

**주의사항**
- `re_encrypt` 호출은 **평문을 반환하지 않음** — 안전.
- 만약 원본 암호문이 encryption context에 의존하면 `SourceEncryptionContext`를 반드시 전달.
- S3 `copy_object`는 객체 크기에 따라 비용/요금 발생. 대량이라면 S3 Batch 사용 권장.

---

## 5) 방법 B — S3 SSE-KMS 객체의 키 변경 (Copy / Batch)

S3에서 `ServerSideEncryption=aws:kms`로 보호된 객체는 **S3 Copy**(copy-object)를 사용해 대상 `--sse aws:kms --sse-kms-key-id <newKey>`를 지정하면 S3가 객체를 내부적으로 재암호화합니다.

### 단일 객체 — AWS CLI

```bash
aws s3api copy-object \
  --bucket my-bucket \
  --copy-source my-bucket/path/to/object.txt \
  --key path/to/object.txt \
  --server-side-encryption aws:kms \
  --ssekms-key-id arn:aws:kms:ap-northeast-2:123456789012:key/NEW-KEY-ID
```

### 대량 객체 — S3 Batch Operations 권장
- 대규모(수십만~수백만) 객체라면 **S3 Inventory + S3 Batch Operations**를 이용하여 키 교체 작업(복사)을 수행합니다.
- S3 Batch의 작업 유형 `PUT` 또는 `COPY`로 `sseAwsKmsKeyId`를 지정하면 S3가 내부적으로 재암호화 수행.
- 장점: 스케줄링, 작업 상태 추적, 실패 항목 리포트 제공.

---

## 6) 방법 C — 클라이언트 사이드(평문 복호화 → 재암호화)
- 불가피하게 대상 암호문이 KMS 관련이 아니거나 ReEncrypt를 쓸 수 없는 형식이면 다음 절차:
  1. 안전한 환경(균형: VPC, 임시 인스턴스, 메모리 보호)에서 대상 데이터 복호화(평문 획득).
  2. 새 CMK로 새 데이터키 생성/암호화 또는 바로 KMS `Encrypt` 호출.
  3. 새 암호문/새 데이터키로 저장.
  4. 평문은 즉시 메모리에서 제거하고 로그에 남기지 말 것.
- 이 방법은 **데이터가 잠시라도 평문 상태가 됨** → 규제/컴플라이언스에 민감한 경우 피해야 함.

---

## 7) 대규모 마이그레이션 운영 팁

### 배치 전략
- **Inventory → 작은 청크 → 병렬 처리(제한)**:
  - S3 Inventory(또는 DB 쿼리)로 대상 리스트 생성.
  - 병렬 작업 수(스레드/프로세스)를 제한하여 KMS throttling 방지(예: 동시에 50~200개).
  - 각 작업 단위에 대해 지수적 백오프 및 재시도 로직 구현.

### 모니터링 & 로깅
- CloudWatch 메트릭: KMS `Throttles`, `Encrypt`, `ReEncrypt` 호출 지표 모니터링.
- CloudTrail: ReEncrypt 이벤트 감사(누가 언제 수행했는지).
- 작업 로그는 실패 항목의 원본(키, 에러 코드, 재시도 횟수)을 남겨 복구에 활용.

### 트랜잭션/원자성
- S3 메타데이터 교체는 **CopyObject**로 atomic하게 대체하되, 실패 가능성 고려:
  - 전략: 새 메타데이터로 복사 → 성공 시 원래 백업(버전) 유지 또는 삭제(검토 후).
- DB의 경우 새 컬럼(또는 버전 컬럼)을 먼저 채우고 확인 후 기존 컬럼을 교체하는 안전 패턴 권장.

### 테스트 → 단계적 롤아웃
1. 샘플(1% 데이터)으로 전환 테스트.  
2. 비핵심 데이터로 1차 배치.  
3. 모니터링 이상 없으면 전체 확장.

### 롤백 계획
- ReEncrypt 작업에서 원본 암호문을 별도 안전 스토어(예: 다른 S3 버전, 데이터베이스에 암호화된 형태)로 임시 보관하면 롤백 가능.
- S3 버전 활성화 시 복원 쉬움(원래 버전으로 복사/되돌림).

---

## 8) 보안·감사 체크리스트 (필수)
- [ ] **샘플 테스트** 완료  
- [ ] **KMS 키 정책**에 `ReEncryptFrom`/`ReEncryptTo` 권한 검토  
- [ ] **IAM 역할**(마이그레이터)에 최소 권한 부여 (`kms:ReEncrypt*`, `s3:GetObject`, `s3:PutObject` 등)  
- [ ] **CloudTrail** KMS 이벤트 로깅 활성화  
- [ ] **S3 버전ing** 켜기(객체 덮어쓰기 시 복구 가능)  
- [ ] **Encryption Context** 가 사용됐다면 정확히 보존·전달  
- [ ] **에러/재시도 정책**, **속도 제한**, **백업 정책** 준비

---

## 9) FAQ / 자주 묻는 질문

**Q. ReEncrypt로 모든 케이스를 평문 없이 처리할 수 있나?**  
A. 대부분은 가능(특히 KMS에서 생성된 암호문/EDK). 하지만 애플리케이션이 자체적으로 암호화한 데이터(예: 고객이 로컬에서 AES로 암호화하고 EDK 없이 저장한 경우)는 클라이언트 측에서 복호화→재암호화해야 함.

**Q. ReEncrypt 시 encryption context는 어떻게 처리하나?**  
A. 원래 암호문이 특정 encryption context로 보호되었다면 `SourceEncryptionContext`를 제공해야 하고, 새 encryption context로 바꾸려면 `DestinationEncryptionContext`를 지정하세요.

**Q. ReEncrypt API 호출 비용/제한은?**  
A. KMS API 호출 비용과 KMS 스로틀 제한이 적용됩니다. 대량 작업 시 스로틀 방지와 비용 관리 필요.

---

## 부록 — 샘플 IAM 키 정책(간단 예)

**소스 CMK(key-policy)** 에서 `DataMigratorRole`이 ReEncryptFrom 허용:

```json
{
  "Sid": "AllowReEncryptFrom",
  "Effect": "Allow",
  "Principal": {
    "AWS": "arn:aws:iam::123456789012:role/DataMigratorRole"
  },
  "Action": [
    "kms:ReEncryptFrom",
    "kms:DescribeKey"
  ],
  "Resource": "*"
}
```

**대상 CMK(key-policy)** 에서 `DataMigratorRole`이 ReEncryptTo 허용:

```json
{
  "Sid": "AllowReEncryptTo",
  "Effect": "Allow",
  "Principal": {
    "AWS": "arn:aws:iam::123456789012:role/DataMigratorRole"
  },
  "Action": [
    "kms:ReEncryptTo",
    "kms:DescribeKey"
  ],
  "Resource": "*"
}
```

> 운영 편의상 콘솔에서는 `kms:ReEncrypt*`를 사용하지만, 보안상 `ReEncryptFrom`/`ReEncryptTo`로 분리하는 것이 더 세밀함.

---

## 맺음말 — 권장 순서 (실무 체크리스트)
1. 테스트 환경에서 전체 플로우(단일 파일 → ReEncrypt → 메타데이터 교체) 검증.  
2. 키 정책/역할/권한 최소화 구성.  
3. S3 버전·백업 활성화.  
4. 작은 청크로 점진 배포(스루풋 제한·모니터링 적용).  
5. 모든 ReEncrypt 호출/결과를 CloudWatch/CloudTrail로 모니터링.  
6. 성공 확인 후 원본 안전 삭제 정책 적용(보존 기간 고려).
