---
layout: post
title: 컴퓨터시스템 - 성능 개선 기술
date: 2025-08-06 16:20:23 +0900
category: 컴퓨터시스템
---
# 실제 상황: 성능 개선 기술 — 현장에서 통하는 플레이북

> 목표: **실서비스/실프로그램**에서 성능을 올릴 때 무엇부터, 어떻게, 어디까지 할지.  
> 구성: 공통 절차 → 상황별 플레이북(지연/처리량/비용) → 범주별 기술(코드·런타임·시스템·데이터) → 케이스 스터디 → 검증/안전 → 체크리스트.

---

## 0. 한 페이지 요약 (TL;DR)

1) **문제 정의**: “무엇을 빠르게?” — p95 지연, 처리량, 비용/와트 등 **목표 지표**를 수치로 못박는다.  
2) **측정**: 프로파일(샘플링), 하드웨어 카운터, I/O·락 대기, GC/메모리.  
3) **가설 → 작은 변경 → 재측정**: 한 번에 하나씩, 회귀 방지.  
4) **우선순위**: 핫패스 20%를 먼저, **Amdahl**과 **Little**로 “상한”을 계산.  
5) **계층적 접근**: 알고리즘/데이터 구조 → 메모리 패턴/벡터화 → 동시성/락 → I/O → 네트워크/DB → OS/하드웨어.

---

## 1. 공통 절차(현장 표준)

### 1.1 목표와 SLA/SLO
- **지연(latency)**: p50/p90/p95/p99, **테일**이 비즈니스를 좌지우지한다.
- **처리량(throughput)**: RPS, GB/s, 잡/시간.
- **비용/전력**: 코어·메모리·GPU 사용, 클라우드 비용.

### 1.2 관찰(측정) 도구
- **타이머**: wall-clock(필수), 반복·워밍업·중앙값.  
- **프로파일**:  
  - 샘플링(저부하): perf/VTune/bpftrace.  
  - 이벤트: `cycles, instructions, cache-misses, branch-misses, stalled-cycles`, syscalls, page faults.  
- **대기 탐지**: 락/뮤텍스, futex, epoll, DB 대기, GC/스톱 더 월드.  
- **분포**: 히스토그램으로 p99 확인(평균은 착시).

### 1.3 상한 계산
- **Amdahl**: 최적화 가능한 비율 \(p\), 가속비 \(s\).
  \[
  \text{Speedup} = \frac{1}{(1-p)+\frac{p}{s}}
  \]
- **Little’s Law**: \(L=\lambda W\) (시스템 내 작업 수=처리율×대기시간).  
  → 큐가 차면 **대기시간 폭증**, 분기 예측·캐시와 무관.

---

## 2. 상황별 플레이북

### 2.1 “지연(p95) 떨어뜨리기” (온라인 트랜잭션/웹서비스)

증상 | 원인 후보 | 즉각 조치 | 근본 해결
---|---|---|---
p95가 비정상 스파이크 | GC/스톱, 디스크/네트워크 타임아웃, 잠금 경합 | 타임아웃·재시도 상한, 큐 길이 제한, 캐싱 | 객체/버퍼 재사용, 메모리 할당 패턴 개선, 락 분해/샤딩
짧은 핫함수 다단 호출 | 호출 오버헤드, I-cache 압박 | **인라인/배칭** | LTO/PGO, API를 배치 지향으로
DB호출 다수 | 왕복 지연 누적 | N+1 제거, 배치/벌크 | CQRS·캐시·인덱스 튜닝
외부 API | 네트워크 변동성 | 서킷 브레이커·백오프 | 비동기·파이프라인화, 콜 합치기

### 2.2 “처리량 올리기” (배치/ETL/과학계산)

증상 | 원인 후보 | 즉각 조치 | 근본 해결
---|---|---|---
CPU 100%·IPC 낮음 | 메모리 바운드 | **타일링/SoA/프리패치** | 알고리즘/데이터 레이아웃 재설계
디스크 100% | 랜덤 I/O | 순차화, 병합정렬, 압축 | 파일/파티션 레이아웃 변경
GPU 유휴 | CPU 프리·후처리 병목 | 배치 사이즈↑, 스트림 파이프라인 | 호스트↔디바이스 전송 최소화(고정버퍼)

### 2.3 “비용 줄이기(동일 성능)” (클라우드/온프레)

- **권장**: PGO·LTO로 바이너리 축소/핫패스 최적화 → 인스턴스 다운사이징.  
- **스택**: Nginx/Envoy 튜닝(keep-alive/리사이클), DB 커넥션 풀 최적, 압축 레벨 자동화(Zstd 레벨 튜닝).  
- **전력/열**: CPU governor “performance”, NUMA 바인딩으로 캐시 교차오염 감소.

---

## 3. 범주별 기술(코드→런타임→시스템)

### 3.1 알고리즘 & 데이터 구조
- **O(n log n) vs O(n²)**: 상수 최적화보다 우선.  
- **해시 vs 정렬**: 키 분포/캐시 친화성 고려.  
- **스트리밍/온더플라이**: 전체 적재 대신 **윈도우/세그먼트** 처리.

### 3.2 메모리·캐시 최적화
- **연속 접근/타일링/블로킹**: L1/L2 재사용 극대화.  
- **SoA(배열-분해)**: 벡터화와 대역 효율에 유리.  
- **스칼라 치환**: 동일 원소 로드를 한 번으로.
```c
void axpy(int n, float *restrict x, float *restrict y, float a){
  float aa=a;
  #pragma omp simd
  for(int i=0;i<n;i++){ float xi=x[i], yi=y[i]; y[i]=yi + aa*xi; }
}
```

### 3.3 벡터화/ILP/언롤
- `restrict`/정렬, **분기 없는 루프**로 자동 벡터화 유도.
- 적당한 **언롤 팩터**(레지스터 압박·I-cache 고려).

### 3.4 동시성·락
- **샤딩/분할 정복**: 전역락 → 파티션 락 또는 per-thread.  
- **락 범위 축소/핫섹션 분리**: 읽기 다수면 RW락.  
- **원자·배치 업데이트**: `local += ...;` → 최종 머지.
```c
#define P 64
_Alignas(64) long cnt[P];
void add(int tid,long v){ cnt[tid]+=v; }
long total(){ long s=0; for(int i=0;i<P;i++) s+=cnt[i]; return s; }
```

### 3.5 I/O·네트워크
- **배치 I/O**: `readv/writev`, 비동기(uring/overlapped), sendfile.  
- **소켓**: 커넥션 풀, TCP_NODELAY(소량 지연 민감), 큐 길이 제한.  
- **압축/포맷**: 대역절약 vs CPU—실측으로 최적 레벨 고정.

### 3.6 DB/스토리지
- **N+1 제거**, 필요한 컬럼만(covering index).  
- **쓰기 집약**: 배치 커밋, 로깅·체크섬 옵션 등급 조정(정합성 요구 수준에 맞춤).  
- **파티셔닝**: 시간·키 범위 분할, 핫파티션을 분산.

### 3.7 런타임/언어(메모리·GC)
- **객체 재사용**(pool), **Zero-copy**(슬라이스/뷰).  
- **GC 언어**: 장수 객체·큰 힙 단편화 주의, 주니어/주기 튜닝 전 **할당 패턴**부터 줄이기.  
- **C/C++**: `-O3 -march=native -flto` + **PGO**로 핫경로 인라이닝/레이아웃.

### 3.8 OS/하드웨어
- **NUMA**: first-touch, 스레드·메모리 바인딩.  
- **Huge Pages**: TLB 미스 감소(장수 데이터 구조).  
- **디스크**: 큐뎁스/스케줄러, 파일시스템 마운트 옵션.  
- **전원/주파수**: 성능 governor, 터보 지속.

---

## 4. 케이스 스터디(축약)

### 4.1 온라인 서비스 p95 −30%
- **증상**: p95=320ms, p50=40ms (테일 길다).  
- **측정**: 프로파일 → 요청당 DB 왕복 7회, 작은 JSON 변환 함수 다단 호출.  
- **조치**: (1) DAO 통합으로 **1회 쿼리** + 필요한 컬럼만, (2) JSON 변환 함수 **배치 API** 도입, (3) 결과 캐시 60s.  
- **결과**: p95=210ms(−34%), DB RPS −55%, CPU −18%. 회귀 없음.

### 4.2 데이터 파이프라인 처리량 +2.6×
- **증상**: CSV→파케이 변환 120MB/s 한계. CPU 60%, LLC 미스↑.  
- **조치**: SoA 파서, 타일(1MB) 버퍼, **벡터화** + `zstd` 레벨 6→3, `writev`로 배치.  
- **결과**: 310MB/s, CPU 75%(유효연산 증가), 압축률 −6% (비용/성능 균형 OK).

### 4.3 수치 루프 1.8× (C)
- **전**: AoS 벡터 거리 계산, 분기 포함.  
- **후**: SoA + `restrict` + 언롤 + 분기 없는 마스크, 레지스터 누적.
```c
typedef struct { float *x,*y,*z; } vec3;
float l2(vec3 v,int n){
  __builtin_assume_aligned(v.x,64);
  float s=0.0f;
  #pragma omp simd reduction(+:s)
  for(int i=0;i<n;i++){
    float dx=v.x[i], dy=v.y[i], dz=v.z[i];
    s += dx*dx + dy*dy + dz*dz;
  }
  return s;
}
```

---

## 5. 지연·처리량·비용을 함께 다루는 기술

### 5.1 파이프라인화
- **단계 분할**(파싱→검증→변환→저장) + 링버퍼/SPSC 큐.  
- **배압(Backpressure)**: 큐 크기 한도, 지연 급증 차단.

### 5.2 캐시 전략
- **읽기 집중**: LRU/ARC, **단기 캐시**(초단기 TTL)로 스파이크 흡수.  
- **쓰기 집중**: 로그 구조·버퍼링 → 배치 플러시.

### 5.3 탄력성(Resilience)와 성능
- **서킷 브레이커/레이트 리밋**: 과부하 시 전체 붕괴 방지 → 평균 성능 유지.  
- **디그레이드 모드**: 비핵심 기능을 임시 비활성화(테일 단축).

---

## 6. 실험 설계와 안전장치

- **A/B·카나리**: 트래픽 일부에만 적용, 리스크 제한.  
- **동일 워크로드**: 요청 믹스/데이터 분포를 고정.  
- **여러 번·여러 크기**: 작은/중간/큰 입력을 모두 측정(스케일에 따라 병목이 바뀐다).  
- **신뢰구간**: 중앙값 + 95% CI 보고.  
- **회귀 알람**: 벤치마크 CI, 임계 초과 시 자동 롤백.

---

## 7. “증상→추측→빠른 확인” 표

증상 | 빠른 추측 | 5분 테스트
---|---|---
IPC 낮음·LLC 미스↑ | 메모리 바운드 | 스트라이드 1 순회로 재작성(샘플 루틴) 후 차이 관찰
p99만 나쁨 | 큐/로크 경합·외부 콜 | 큐 길이 제한, 동시성 절반으로 줄여 p99 변화 체크
CPU 한가·지연 높음 | I/O 대기 | 비동기/배치로 교체한 작은 경로 실험
DB CPU↑ | 인덱스 부재/N+1 | EXPLAIN/쿼리 캐시(1분) 켜기
스파이크 | GC/압축 | GC 주기/압축 레벨 조정 → p95 변화

---

## 8. 안티패턴 (피해야 할 것)

- **측정 없이 큰 수술**: 팀/운영 리스크만 키운다.  
- **한 번에 여러 변경**: 어떤 것이 효과였는지 모른다.  
- **p50만 개선**: 고객이 체감하는 p95/p99 방치.  
- **무한 캐시**: 불일치/정합성 문제로 장애 유발.  
- **과도한 인라인/언롤**: I-cache 미스 증가로 역효과.

---

## 9. 체크리스트

- [ ] 목표 지표: p95/처리량/비용 **숫자**로 정의했는가?  
- [ ] 핫패스는 어디인가(상위 10% 콜스택)?  
- [ ] 메모리 패턴: **연속/타일/SoA**인가?  
- [ ] 벡터화에 장애(분기/별칭)가 없는가(`restrict`/분기 제거)?  
- [ ] 락 경합/큐 길이/외부 왕복 횟수는?  
- [ ] 배치/파이프라인/비동기 전환 여지는?  
- [ ] DB: 인덱스/쿼리 수/전송 컬럼 최소화?  
- [ ] NUMA/hugepage/고정/전원모드 점검?  
- [ ] 변경은 **작게**, 측정은 **반복**했는가?

---

## 10. 부록: 계량화 포뮬러

- **속도향상**  
  \[
  S = \frac{T_{\text{old}}}{T_{\text{new}}}
  \]
- **연산 집약도(Roofline)**  
  \[
  \text{AI} = \frac{\text{FLOPs}}{\text{Bytes}},\quad
  \text{Perf} \le \min(\text{PeakFLOPs}, \text{AI}\cdot \text{BW})
  \]
- **큐 대기** (M/M/1 근사)  
  \[
  W_q \approx \frac{\rho}{\mu(1-\rho)}\quad(\rho=\lambda/\mu)
  \]
  → 이용률 \(\rho\)가 0.8→0.9가 되면 대기가 급증.

---

### 마무리

현장의 성능 개선은 **과학적 실험**과 **엔지니어링 절제**의 결합이다.  
핵심은 “**어디가 한계인지 먼저 계산하고**(Amdahl/Little/Roofline), **작은 변경을 안전하게 반복**해 **핫패스**를 깎는 것”.  
