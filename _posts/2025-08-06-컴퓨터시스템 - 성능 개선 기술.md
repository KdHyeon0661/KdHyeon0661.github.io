---
layout: post
title: 컴퓨터시스템 - 성능 개선 기술
date: 2025-08-06 16:20:23 +0900
category: 컴퓨터시스템
---
# 실제 상황: 성능 개선 기술

## 한 페이지 요약

1) **문제 정의**: “무엇을 빠르게?” — p95 지연, 처리량, 비용/와트 등 **목표 지표**를 수치로 못박는다.
2) **측정**: 샘플링 프로파일 + 하드웨어 카운터 + I/O·락·GC/메모리 대기.
3) **가설 → 작은 변경 → 재측정**: 한 번에 하나, 회귀 방지.
4) **우선순위**: 핫패스 20%를 먼저, **Amdahl**과 **Little**로 “상한” 계산.
5) **계층 접근**: 알고리즘/데이터 → 메모리/벡터화 → 동시성/락 → I/O → 네트워크/DB → OS/하드웨어.

---

## 공통 절차(현장 표준)

### 목표와 SLA/SLO 정의

- **지연(latency)**: p50/p90/p95/p99. 테일(p95↑)이 사용자 체감과 오류율을 좌우한다.
- **처리량(throughput)**: RPS, GB/s, job/hour. **평형점**은 큐잉과 리소스 한계의 함수.
- **비용/전력**: vCPU·메모리·GPU·스토리지·네트워크·전력/열. 다운사이징 목표치를 수치화.

### 도구와 원칙

- **타이머**: wall-clock, 충분한 반복·워밍업·중앙값/신뢰구간.
- **프로파일(저오버헤드 우선)**: perf/VTune/bpftrace(샘플링), eBPF 기반 락/오프-CPU/블록 I/O.
- **카운터**: `cycles, instructions, IPC, cache-misses, branch-misses, dTLB-misses, stalled-cycles-frontend/backend`.
- **대기 분해**: futex/epoll, DB/원격 콜, GC/스톱 더 월드.
- **분포 관측**: 히스토그램/TDigest/CKMS로 p95/p99. 평균을 맹신하지 않는다.

### 상한 계산으로 “헛수고” 예방

- **Amdahl**:
  $$
  \text{Speedup}=\frac{1}{(1-p)+\frac{p}{s}}
  $$
  최적화 가능한 비중 \(p\), 해당 구간 가속비 \(s\). 핫패스가 30%면 \(s=\infty\)여도 전체 1.43× 한계.
- **Little’s Law**:
  $$
  L=\lambda W
  $$
  시스템 내 작업수 \(L\)=처리율 \(\lambda\)×대기시간 \(W\). 큐가 차면 **지연 폭증**(p99↑).
- **Roofline**(배치/HPC):
  $$
  \text{Perf}\le \min(\text{Peak FLOPs},\ \text{AI}\cdot \text{BW}),\quad
  \text{AI}=\frac{\text{FLOPs}}{\text{Bytes}}
  $$

---

## 상황별 플레이북

### p95 지연 낮추기(온라인 트랜잭션)

증상 | 원인 후보 | 즉각 조치(저비용) | 근본 해결(중·고비용)
---|---|---|---
p95 스파이크 | GC/스톱, 디스크/네트워크 타임아웃, 락 경합 | 타임아웃·재시도 상한, 큐 길이 제한, 캐싱, 서킷 브레이커 | 객체/버퍼 재사용, 할당 패턴 개선, 락 샤딩/분해, 비동기·파이프라인
짧은 함수 다단 호출 | 호출 오버헤드/I-cache 압박 | 인라인/배칭, 핫경로 LTO/PGO | API 자체를 배치 지향으로 재설계
N+1 DB 호출 | 왕복 지연 누적 | 조인/벌크, 필요한 컬럼만 | CQRS, 인덱스/실행계획 튜닝, 결과 캐시
외부 API 변동성 | 네트워크 지터 | 서킷 브레이커/백오프, 타임아웃·폴백 | 요청 합치기, 비동기 파이프라인, 로컬 힌트 캐시

**5분 드릴**
- 동시에 처리하는 **동시성 반으로** → p95 변화? (큐잉 문제면 즉시 개선)
- **단일 엔드포인트만** 대상으로 **N+1 제거** 실험 → p95 변화?
- **핫함수 인라인** 브랜치로 테스트 → p95 변화?

### 처리량 올리기(배치/ETL/과학계산)

증상 | 원인 후보 | 즉각 조치 | 근본 해결
---|---|---|---
IPC<1·LLC miss↑ | 메모리 바운드 | 타일링/SoA/스칼라 치환, 프리패치 | 알고리즘/레이아웃 재설계, AoSoA/타일 크기 탐색
디스크 100% | 랜덤 I/O | 순차화, 병합정렬, 페이지 캐시 활용 | 포맷/파티션 재설계, 압축/컬럼형
GPU 유휴 | CPU 전·후처리 병목 | 배치 사이즈↑, 중간 포맷 통일 | H2D/D2H 최소화(고정버퍼), 스트림 파이프라인

### 비용 줄이기(동일 성능 유지)

- **바이너리 최적화**: `-O3 -flto -march=native + PGO` → **핫경로 인라인**·분기 제거.
- **스택/에이전트**: Nginx/Envoy keep-alive·리사이클, 커넥션 풀·TCP 옵션, 압축 레벨(Zstd) 자동화.
- **인스턴스 다운사이징**: NUMA 바인딩/핀으로 캐시 교차오염 감소 → 코어 수↓에도 성능 유지.

---

## 범주별 기술(코드 → 런타임 → 시스템)

### 알고리즘 & 데이터 구조

- **차수 우선**: O(n²)→O(n log n). 상수 최적화 이전에 구조를 바꾼다.
- **해시 vs 정렬**: 키 분포·캐시 친화성·메모리 사용을 함께 비교.
- **스트리밍**: 전체 적재 대신 **윈도우/세그먼트** 처리로 피크 메모리 감소.

### 메모리·캐시 최적화(로컬리티 재활용)

```c
void axpy(int n, float *restrict x, float *restrict y, float a){
  float aa=a;
  #pragma omp simd
  for(int i=0;i<n;i++){
    float xi=x[i], yi=y[i];   // 스칼라 치환
    y[i]=yi + aa*xi;          // 연속 접근, 벡터화 유리
  }
}
```
- **연속 접근/타일링/블로킹**, **SoA/AoSoA**, **정렬/패딩**, **비휘발 저장**(스트리밍 결과) 적용.

### 벡터화/ILP/언롤

- 분기 없는 루프, `restrict`, 정렬된 포인터로 자동 벡터화 유도.
- 언롤은 **레지스터 압박·I-cache**와 균형.

### 동시성·락·샤딩

```c
#define P 64

_Alignas(64) long shard_cnt[P];  // 라인 패딩
void add(int tid,long v){ shard_cnt[tid]+=v; }
long total(){ long s=0; for(int i=0;i<P;i++) s+=shard_cnt[i]; return s; }
```
- **샤딩/분할 정복**, **락 범위 축소**, **원자 업데이트의 배치/머지**.

### I/O·네트워크(왕복/시스템 콜 감소)

```c
// writev 사용: N번 write → 1번
#include <sys/uio.h>

ssize_t flush_many(int fd, const struct iovec *iov, int n){ return writev(fd, iov, n); }
```
- 비동기(uring), `sendfile`, zero-copy, 커넥션 풀, 큐 길이 제한.

### DB/스토리지

- **N+1 제거**, **커버링 인덱스**, **배치 커밋**.
- 쓰기 집중 워크로드는 **로그 구조 + 버퍼 플러시**, 파티셔닝으로 핫파티션 분산.

### 런타임/언어(GC/할당)

- **객체/버퍼 재사용**(pool), **슬라이스/뷰**로 zero-copy.
- GC는 **할당 패턴**을 먼저 줄이고, 그 다음 세대/주기/영역을 조정.

### OS/하드웨어

- NUMA first-touch, 스레드/메모리 바인딩. Huge Pages(큰 워킹셋).
- 디스크 큐뎁스/스케줄러, 파일시스템 마운트 옵션.
- 전원/주파수: performance governor, 고정 클럭(가능 시).

---

## 케이스 스터디

### 온라인 API p95 −34%

- **초기**: p95=320ms, p50=40ms.
- **관찰**: 요청당 DB 왕복 7회, JSON 변환 도우미 함수가 루프 내 호출.
- **조치**: DAO 통합(1회 쿼리, 필요한 컬럼만), JSON 변환 **배치 API**로 교체, 결과 캐시 60s.
- **결과**: p95=210ms(−34%), DB RPS −55%, CPU −18%, 에러율↓.

### ETL 처리량 2.6×

- **초기**: CSV→Parquet 120MB/s, LLC miss↑.
- **조치**: SoA 파싱, 1MB 타일 버퍼, `zstd` 레벨 6→3, `writev` 배치.
- **결과**: 310MB/s(+2.6×), 압축률 −6%(비용/성능 균형 양호).

### 수치 루프 1.8× (C)

```c
typedef struct { float *x,*y,*z; } vec3;
float l2(vec3 v,int n){
  __builtin_assume_aligned(v.x,64);
  float s=0.0f;
  #pragma omp simd reduction(+:s)
  for(int i=0;i<n;i++){
    float dx=v.x[i], dy=v.y[i], dz=v.z[i];
    s += dx*dx + dy*dy + dz*dz; // SoA, 분기 없음, 레지스터 누적
  }
  return s;
}
```

---

## 지연·처리량·비용을 함께 조절하기

### 파이프라인화와 배압

- 단계 분리(파싱→검증→변환→저장) + **SPSC 링버퍼**.
- 배압: 큐 길이 한도·드롭/지연 정책으로 테일 제어.

### 캐시 전략

- 읽기 집중: LRU/ARC, **초단기 TTL 캐시**로 스파이크 흡수.
- 쓰기 집중: 로그 구조·버퍼링 → 배치 플러시.

### 탄력성과 성능의 균형

- 서킷 브레이커/레이트 리밋/폴백 모드. 장애 격리로 **평균 성능**을 지킨다.

---

## 실험 설계와 안전장치

- **A/B·카나리**: 트래픽 일부만.
- **동일 워크로드**: 요청 믹스/데이터 분포 고정.
- **다중 스케일**: 작은/중간/큰 입력 모두 측정(병목이 바뀜).
- **신뢰구간**: 중앙값 + 95% CI.
- **회귀 알람**: 벤치마크 CI 임계 초과 시 자동 롤백.

---

## “증상→추측→빠른 확인” 표

증상 | 빠른 추측 | 5분 테스트
---|---|---
IPC 낮음·LLC miss↑ | 메모리 바운드 | 스트라이드 1 순회로 재작성한 샘플 루틴 성능 비교
p99만 나쁨 | 큐/락 경합·외부 콜 지연 | 동시성 절반으로 줄여 p99 변화 관찰
CPU 한가·지연 높음 | I/O 대기 | 소규모 경로를 비동기/배치로 교체
DB CPU↑ | 인덱스 부재/N+1 | EXPLAIN + 결과 캐시 1분 켜보기
스파이크 발생 | GC/압축/압축해제 | GC 주기/압축 레벨 조정 후 p95 변화 관찰

---

## 안티패턴(피해야 할 것)

- **측정 없이 대수술**: 리스크만 커진다.
- **한 번에 여러 변경**: 효과 원인 불명.
- **p50만 개선**: 사용자는 p95/p99를 체감한다.
- **무한 캐시**: 정합성·장애의 지뢰밭.
- **과도한 인라인/언롤**: I-cache 미스↑로 역효과.

---

## 체크리스트(실전용)

- [ ] 목표 지표: p95/처리량/비용 **숫자**로?
- [ ] 핫패스 10~20%는 어디인가(콜스택/플레임그래프)?
- [ ] 메모리 패턴: **연속/타일/SoA**인가? 스칼라 치환했는가?
- [ ] 벡터화 장애(분기/별칭/정렬)는 없는가?
- [ ] 락 경합/큐 길이/외부 왕복 수는?
- [ ] 배치/파이프라인/비동기 전환 여지는?
- [ ] DB: 인덱스/전송 컬럼 최소/벌크화?
- [ ] NUMA/HugePage/고정 클럭/핀/전원모드 점검?
- [ ] 변경은 **작게**, 측정은 **반복**했는가?
- [ ] 결과를 **중앙값+신뢰구간**으로 보고했는가?

---

## 실험용 코드/셸 스니펫

### 마이크로벤치 틀(p50/p95/표준편차)

```c
// bench_p95.c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

static double now(){ struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
  return t.tv_sec + t.tv_nsec*1e-9; }

static volatile double sink;
static void workload(int n){
  double s=0;
  for(int i=0;i<n;i++) s+= (i*1315423911u)%1009;
  sink = s;
}

static int cmpd(const void* a,const void* b){
  double da=*(const double*)a, db=*(const double*)b;
  return (da<db)?-1:(da>db);
}

int main(int argc,char**argv){
  int runs = (argc>1)? atoi(argv[1]) : 31;
  int N    = (argc>2)? atoi(argv[2]) : 1000000;
  double *t = malloc(sizeof(double)*runs);
  for(int i=0;i<runs;i++){
    for(int w=0;w<3;w++) workload(10000); // 워밍업
    double t0=now(); workload(N); double t1=now();
    t[i]=t1-t0;
  }
  qsort(t, runs, sizeof(double), cmpd);
  double sum=0, sum2=0;
  for(int i=0;i<runs;i++){ sum+=t[i]; sum2+=t[i]*t[i]; }
  double mean=sum/runs, sd=sqrt((sum2/runs)-(mean*mean));
  int p50_i = (int)(0.50*(runs-1));
  int p95_i = (int)(0.95*(runs-1));
  printf("runs=%d mean=%.6f sd=%.6f p50=%.6f p95=%.6f\n",
         runs, mean, sd, t[p50_i], t[p95_i]);
  free(t);
  return 0;
}
```

### perf로 병목 단서 얻기

```sh
gcc -O3 -march=native -flto bench_p95.c -o bench && ./bench 31 1500000
perf stat -e cycles,instructions,IPC,\
L1-dcache-loads,L1-dcache-load-misses,\
LLC-loads,LLC-load-misses,\
dTLB-loads,dTLB-load-misses,branches,branch-misses \
./bench 31 1500000
```

### bpftrace로 블록 I/O 지연 관찰(루트 필요)

```sh
sudo bpftrace -e 'tracepoint:block:block_rq_complete { @lat[probe] = hist(nsecs/1000); }'
```

### writev 배치 vs 반복 write

{% raw %}
```c
// writev_demo.c
#include <sys/uio.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

int main(){
  char a[]="AAA\n", b[]="BBB\n", c[]="CCC\n";
  struct iovec v[3]={{a,4},{b,4},{c,4}};
  writev(1, v, 3); // 1회 호출로 3개 버퍼 출력
  return 0;
}
```
{% endraw %}

### NUMA 바인딩/고정 클럭

```sh
# + governor=performance

sudo cpupower frequency-set -g performance
# NUMA 바인딩(노드0)

numactl --cpunodebind=0 --membind=0 ./bench
```

---

## 수식 모음(계량화)

- **속도향상**
  $$
  S=\frac{T_{\text{old}}}{T_{\text{new}}}
  $$
- **Amdahl**
  $$
  \text{Speedup}=\frac{1}{(1-p)+\frac{p}{s}}
  $$
- **Little**
  $$
  L=\lambda W
  $$
- **Roofline**
  $$
  \text{Perf}\le \min(\text{PeakFLOPs},\ \text{AI}\cdot \text{BW}),\quad
  \text{AI}=\frac{\text{FLOPs}}{\text{Bytes}}
  $$
- **M/M/1 근사 큐 대기**
  $$
  W_q \approx \frac{\rho}{\mu(1-\rho)}\quad(\rho=\lambda/\mu)
  $$

---

## 맺음말

현장 성능 개선은 **과학적 실험**과 **엔지니어링 절제**의 결합이다.
핵심은 “**상한을 먼저 계산**(Amdahl/Little/Roofline)하고, **핫패스**를 작은 변경으로 깎아내며, **측정→수정→재측정**을 빠르게 반복하는 것”.
이 플레이북의 절차·표·코드·셸 스니펫을 그대로 적용하면, 지연·처리량·비용을 **예측 가능하게** 개선할 수 있다.
