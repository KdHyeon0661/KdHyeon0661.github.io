---
layout: post
title: 정보보안기사 - 경로 추적 취약점
date: 2025-11-13 08:25:23 +0900
category: 정보보안기사
---
# 취약점 완전 정리 (우회 벡터·OS별 특이점·언어별 취약 패턴·안전 정규화·심볼릭 링크/TOCTOU·Zip Slip·서버/클라우드 설정·체크리스트·실기 예상문제)

## 개요 — “파일 시스템 경계를 벗어나려는 모든 시도”

**경로 추적(Path Traversal)** 또는 **디렉터리 트래버설**은 사용자가 제공한 경로 조각을 조합해 **의도한 디렉터리 밖의 파일**을 읽거나(일반적으로 LFR: Local File Read), 쓰거나, 삭제하도록 만드는 취약점이다. 전형적으로 `..`, 이중 인코딩, 구분자 혼합(슬래시/역슬래시), 유니코드 변형, 심볼릭 링크, 압축 해제(Zip Slip), 웹서버 alias 오설정 등을 이용한다.

핵심 방어는 다음 3요소의 결합이다.

1) **입력 모델을 ‘경로’가 아닌 ‘ID’로**: 외부에 경로를 받지 말고 **ID → 내부경로 매핑**
2) **정규화 후 경로 제약**: `resolve/normalize/realpath` 등으로 정규화하고 **BASE 프리픽스 검사**
3) **권한/소유권 인가**: 파일마다 접근 정책 평가(소유자/조직/태그/만료 등)

리스크 직관(시험용 포뮬러):
$$
\text{Risk} \approx P(\text{NormalizationBypass}) \times I(\text{Data/Integrity Loss}) \div D(\text{Detection/Isolation})
$$

- \(P\)를 낮추기: **ID 매핑**, **정규화+prefix 검사**, **심볼릭 링크/레이스 방지**
- \(I\)를 낮추기: **민감 파일 비공개 영역 배치**, **권한/소유 검증**, **별도 오리진**
- \(D\)를 높이기: **로그/알림**, **특정 패턴 탐지**, **Fail-closed**

---

## 위협 모델 & 전형적 시나리오

```
[사용자] --(file=?../../etc/passwd)--> [웹앱] --(경로결합)--> [파일시스템]
                                   ^                  ^
                                입력검증 실패      정규화/프리픽스 검사 없음
```

- **읽기(Read)**: 민감 설정 파일, 토큰, 소스코드 유출
- **쓰기/삭제(Write/Delete)**: 로그 오염, 서비스 거부, 웹루트 오염(파일 업로드 취약점과 결합)
- **압축 해제(Zip Slip)**: 아카이브 내부 경로로 탈출하여 시스템 임의 위치에 파일 전개
- **웹서버 alias/정적 경로 오설정**: URL→디스크 매핑에서 경로 검증 불충분

---

## 흔한 우회 벡터(정규화 전/후 값 차이 악용)

| 유형 | 예시 입력 | 비고 |
|---|---|---|
| 기본 상위 디렉터리 | `../../etc/passwd` | 가장 기본 |
| URL 인코딩 | `..%2f..%2fetc%2fpasswd` | `%2f` = `/` |
| 이중 인코딩 | `%252e%252e%252fetc%252fpasswd` | 서버가 두 번 디코드 |
| 점+슬래시 변형 | `..\/..\../etc/passwd` | `\`/`/` 혼용 |
| 유니코드 동형/정규화 | `%E2%80%A2%E2%80%A2/` 등 | NFC/NFD, 혼동 문자 |
| 현재 디렉터리 혼합 | `././../../etc/passwd` | 정규화 필요 |
| Windows 장치/ADS | `C:\Windows\system32\drivers\etc\hosts` / `readme.txt:stream` | NTFS Alternate Data Streams |
| UNC/장치 경로 | `\\?\C:\Windows\...`, `\\.\pipe\...` | 경로 스킴 우회 |
| Null byte(과거) | `passwd%00.txt` | 일부 구버전만 영향 |
| 심볼릭 링크 | `uploads/safe.jpg` → symlink → `/etc/passwd` | **정규화/열기 순서** 중요 |
| 아카이브 경로 | `../../.ssh/authorized_keys` | Zip Slip |

> **포인트**: “`..` 제거”처럼 **단순 치환**은 절대 금지. **정규화 후 BASE 경로 프리픽스 검사**가 핵심.

---

## OS별 경로 특이점

### Linux/Unix

- 구분자 `/` 하나. 백슬래시는 일반 문자일 수 있음.
- **심볼릭 링크**, **하드 링크**, **마운트**, `/proc`, `/sys` 유의.
- `realpath()`/`resolve()` 후 **BASE 시작 여부** 검사.
- `openat2()`(리눅스 5.6+)의 `RESOLVE_BENEATH|NO_SYMLINKS` 활용 시 레이스/심볼릭 링크 방어에 유리.

### Windows/NTFS

- 구분자 `\` 이지만 많은 런타임이 `/`도 허용.
- **UNC/장치 경로**(`\\?\`, `\\.\`)와 **NTFS ADS**(`filename:stream`) 우회 가능.
- **예약 명칭**(`CON`, `NUL`, `PRN`, `AUX`, `COM1`…) 및 **트레일링 점/공백** 처리(Explorer와 API 차이) 주의.
- 경로 비교 시 **대소문자 비민감** 환경 많음 → 비교 시 lower-case 기준 통일.

---

## 언어/프레임워크별 취약 패턴 & 안전 패턴

### — 안전 템플릿

```python
from flask import Flask, request, abort, Response
from pathlib import Path
import mimetypes

app = Flask(__name__)
BASE = Path("/srv/app/data").resolve(strict=True)

def safe_resolve(rel: str) -> Path:
    # 외부에서 "경로" 자체를 받지 않는 것이 최선이지만, 예시상 상대경로 입력 처리
    p = (BASE / rel).resolve()
    if not str(p).startswith(str(BASE)):
        raise ValueError("Traversal")
    return p

@app.get("/view")
def view():
    # 권장: id -> 내부경로 매핑 사용(여기선 예시로 rel 허용)
    rel = request.args.get("rel", "")
    try:
        path = safe_resolve(rel)
    except Exception:
        abort(400)

    if not path.exists() or not path.is_file():
        abort(404)

    # 권한/소유권 인가 로직(예: ACL/RBAC/소유자 확인) 추가
    mime = mimetypes.guess_type(path.name)[0] or "application/octet-stream"
    # 렌더 대신 다운로드(의도에 따라)
    return Response(open(path, "rb"), headers={
        "Content-Type": "application/octet-stream",
        "X-Content-Type-Options": "nosniff",
        "Content-Disposition": f"attachment; filename*=UTF-8''{path.name}"
    })
```

### — 경로 정규화 + BASE 프리픽스 + 심볼릭 링크 주의

```js
import express from "express";
import path from "node:path";
import fs from "node:fs/promises";

const app = express();
const BASE = path.resolve("/srv/app/data");

function safeResolve(rel) {
  const norm = path.normalize(rel).replace(/^(\.\.(\/|\\|$))+/, "");
  const abs = path.resolve(BASE, norm);
  if (!abs.startsWith(BASE + path.sep)) throw new Error("Traversal");
  return abs;
}

app.get("/read", async (req, res) => {
  try {
    const rel = req.query.rel || "";
    const abs = safeResolve(rel);
    const st = await fs.stat(abs);
    if (!st.isFile()) return res.sendStatus(404);

    // 권한 검사 필요(소유자/조직/태그)
    res.setHeader("Content-Type", "application/octet-stream");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Content-Disposition", `attachment; filename*=UTF-8''${encodeURIComponent(path.basename(abs))}`);
    res.sendFile(abs); // 내부 경로 노출 안 함
  } catch {
    res.sendStatus(400);
  }
});

app.listen(3000);
```

### — `Path.normalize()` + prefix 검사

```java
@GetMapping("/file/{id}")
public ResponseEntity<Resource> get(@PathVariable String id, Principal principal) throws IOException {
    // 권장: id -> 내부경로 매핑 + 인가 검증
    FileMeta meta = fileService.find(id);
    if (meta == null) return ResponseEntity.notFound().build();
    if (!policyService.canAccess(principal, meta)) return ResponseEntity.status(403).build();

    Path base = Paths.get("/srv/app/data").toRealPath();
    Path p = base.resolve(meta.getRelativePath()).normalize().toRealPath();

    if (!p.startsWith(base) || !Files.isRegularFile(p)) return ResponseEntity.notFound().build();

    Resource r = new FileSystemResource(p);
    return ResponseEntity.ok()
        .header(HttpHeaders.CONTENT_DISPOSITION, ContentDisposition.attachment()
            .filename(meta.getDownloadName(), StandardCharsets.UTF_8).toString())
        .header("X-Content-Type-Options", "nosniff")
        .contentType(MediaType.APPLICATION_OCTET_STREAM)
        .body(r);
}
```

### PHP — **절대 경로 결합 금지**, `realpath` + prefix 검사

```php
<?php
$BASE = realpath("/srv/app/data");

function safe_path($rel) {
  global $BASE;
  // 입력은 되도록 ID만 받고 서버가 매핑해서 상대경로를 결정
  $p = realpath($BASE . DIRECTORY_SEPARATOR . $rel);
  if ($p === false || strpos($p, $BASE) !== 0) {
    http_response_code(400); exit;
  }
  return $p;
}

$rel = $_GET['rel'] ?? '';
$path = safe_path($rel);
if (!is_file($path)) { http_response_code(404); exit; }

header('Content-Type: application/octet-stream');
header('X-Content-Type-Options: nosniff');
header('Content-Disposition: attachment; filename="'.basename($path).'"');
readfile($path);
```

### Go — `filepath.Clean` + prefix 검사

```go
func safeJoin(base, rel string) (string, error) {
  clean := filepath.Clean(rel)
  abs := filepath.Join(base, clean)
  baseAbs, _ := filepath.Abs(base)
  abs, _ = filepath.Abs(abs)
  if !strings.HasPrefix(abs, baseAbs+string(os.PathSeparator)) && abs != baseAbs {
     return "", errors.New("traversal")
  }
  return abs, nil
}
```

---

## 방어

문제: **검사 시점과 사용 시점이 다르면** 심볼릭 링크를 통해 검사 이후 외부로 연결이 바뀔 수 있다.

### 안전한 오픈(리눅스 커널 5.6+)

- `openat2()`의 `RESOLVE_BENEATH | RESOLVE_NO_SYMLINKS | RESOLVE_NO_MAGICLINKS` 조합
- C 예시(교육용 스니펫):
```c
#define _GNU_SOURCE
#include <linux/openat2.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int open_safe(const char *base, const char *rel) {
  struct open_how how = {
    .flags = O_RDONLY | O_CLOEXEC,
    .resolve = RESOLVE_BENEATH | RESOLVE_NO_SYMLINKS | RESOLVE_NO_MAGICLINKS
  };
  int dfd = open(base, O_PATH | O_DIRECTORY);
  if (dfd < 0) return -1;
  int fd = syscall(SYS_openat2, dfd, rel, &how, sizeof(how));
  close(dfd);
  return fd; // fd를 통해 read
}
```
> 고수준 런타임에서는 직접 사용이 어렵지만, **검사 후 오픈까지 원자적으로** 처리하는 구현(또는 신뢰 가능한 라이브러리) 사용을 고려.

---

## — 안전 해제

### 취약 사례(개념)

- ZIP/TAR 내부 엔트리에 `../../` 포함 → 해제 시 BASE 밖에 파일 생성

### Java 안전 예시

```java
try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zip))) {
  ZipEntry e;
  Path dest = Paths.get("/srv/app/unpack").toRealPath();
  while ((e = zis.getNextEntry()) != null) {
    Path target = dest.resolve(e.getName()).normalize();
    if (!target.startsWith(dest)) throw new SecurityException("Zip Slip");
    // 파일 크기/개수/심볼릭 링크/허용 확장자 상한 등 추가 검증
    if (e.isDirectory()) Files.createDirectories(target);
    else {
      Files.createDirectories(target.getParent());
      Files.copy(zis, target, StandardCopyOption.REPLACE_EXISTING);
    }
  }
}
```

### Node.js 안전 체크(간단)

```js
function safeZipPath(destBase, entryName) {
  const target = path.resolve(destBase, entryName);
  if (!target.startsWith(destBase + path.sep)) throw new Error("Zip Slip");
  return target;
}
```

---

## 웹서버/리버스 프록시 설정 주의

### Nginx `alias` 오설정 방지

```nginx
# 취약 가능 패턴(잘못된 예)
# location ~ ^/img/(.*)$ { alias /data/img/; }  # 캡쳐그룹 재조합 시 검사 부재

# 권장: 정적 prefix + 내부 제공(X-Accel-Redirect)

location /protected/ {
    internal;
    alias /srv/app/data/;     # 반드시 trailing slash 규칙 준수
    add_header X-Content-Type-Options "nosniff";
    types { } default_type application/octet-stream;
}
```
- 정규식 `location`과 `alias` 조합은 **캡처 재조합 시 프리픽스 검증 실패**하기 쉬우므로 주의.
- 가능하면 **애플리케이션이 권한/경로 검증** 후 `X-Accel-Redirect`로 전달.

### Apache — Directory 제한

```apache
<Directory "/srv/app/data">
  Require all denied
</Directory>

# 애플리케이션만 내부적으로 읽고, 직접 URL 노출 금지

```

### IIS — 가상 디렉터리 맵핑 시 상위경로 이동 차단

- 가상 디렉터리/핸들러 맵핑에서 **상대경로/와일드카드 조합** 주의
- 필요 시 URL Rewrite에서 `..`/역슬래시 패턴 즉시 거부

---

## 프레임워크별 정적 리소스 매핑

- Spring `ResourceHttpRequestHandler` 사용 시 `addResourceLocations("file:/srv/static/")`와 같이 **절대 위치**를 제공하고, `.`/`..`가 포함된 요청은 **기본적으로 차단**되지만, 커스텀 핸들러나 `addResourceHandler`에 **경로 재작성**을 넣을 경우 프리픽스 검사를 반드시 수행.
- Express 정적 미들웨어(`express.static`)는 기본적으로 상위 경로 접근을 막지만, **사용자 입력을 그대로 `sendFile`**에 넘기면 취약.

---

## 클라우드/컨테이너 관점의 방어

- 민감 파일은 **컨테이너 이미지에 포함 금지**, 런타임 **Secret/Config**로 마운트(권한 최소화).
- 다운로더/뷰어 서비스는 **읽기 전용 마운트**(`ro`), **전용 볼륨** 분리.
- **네임스페이스/마운트**를 이용해 앱이 볼 수 있는 디렉터리를 최소화(진짜 “BASE”를 작게).
- 서버리스/오브젝트 스토리지 사용 시 **키 자체가 경로**이므로, **키 스키마 검증**과 **접근정책(정확한 조건부 정책)** 필요.

---

## 탐지/모니터링/테스트

### 로그에서 볼 수 있는 징후

- 요청 파라미터/경로에 `..`, `%2e%2e`, `%5c`, `\` 존재
- 403/404 급증, 파일 접근 실패 로그 증가
- 성공한 다운로드/뷰에서 **비정상 경로**가 HID된 정규화 결과로 나타남

### DAST/Fuzzing 기본 케이스

```
../../etc/passwd
..%2f..%2fetc%2fpasswd
..%252f..%252fetc%252fpasswd
..%c0%af..%c0%afetc/passwd
....//....//etc/passwd
..\..\Windows\System32\drivers\etc\hosts
%2e%2e/%2e%2e/etc/passwd
```

### 간단한 차단(게이트 앞단에서 빠르게 400)

- WAF/리버스 프록시에서 path/query에 `..`/`%2e`/역슬래시 포함 시 **즉시 거부**(화이트리스트 기반에서 예외 추가)
- 단, **정규화에 자신 있으면** 앞단 차단은 보조 수단으로 유지

---

## 운영 체크리스트

- [ ] **경로 입력 금지**: 외부에는 **ID/키**만 받고, 서버가 매핑하여 내부경로 결정
- [ ] 경로 조합 필요 시: `normalize/resolve/realpath` 후 **BASE prefix 검사**
- [ ] **심볼릭 링크/레이스** 방지: 검사→열기 원자화, 가능한 경우 `openat2` 계열 사용
- [ ] **정적/alias 매핑**: 정규식 location 주의, 내부 제공(`X-Accel-Redirect`) 선호
- [ ] **Zip/Tar 해제**: 엔트리마다 **BASE prefix 검사**, 링크/허용 확장자/크기/개수 제한
- [ ] Windows 특이점: UNC/장치경로/ADS/예약명/대소문자/공백/점 처리
- [ ] 권한/소유 인가: 파일 단위 정책(RBAC/ABAC), 만료/소유자 검증
- [ ] 로깅: 입력값(raw)/정규화 결과/BASE 검사 결과/권한 평가/실패 사유
- [ ] 모의해킹 시나리오: 이중 인코딩/혼합 구분자/유니코드 정규화/심볼릭 링크/Zip Slip
- [ ] 주기적 리그레션: 프레임워크/서버 업데이트 후 경로 처리 변화 회귀 테스트

---

## 안전 구현 요지

1) **서버측 페이징/정렬**만 허용, “상위 폴더” 이동 기능은 **서버가 계산**
2) 디렉터리 목록을 만들 때도 `resolve` 후 **BASE prefix**를 만족하는 항목만 노출
3) 다운로드는 **항상 첨부**로 제공 + `nosniff`
4) 삭제/이동은 **정규화→권한 검증→원자적 연산** 순서

---

## 실기 예상문제 (서술/코드 수정형)

**문제 1**
다음 코드는 경로 추적 취약점이 있다. 문제점을 3가지 이상 쓰고 수정하라.
```js
app.get('/open', (req, res) => {
  const p = __dirname + '/data/' + req.query.path; // A
  res.sendFile(p);                                  // B
});
```
**모범 요지**
- A: 문자열 결합으로 **경로탈출** 가능( `..`/인코딩/역슬래시 ).
- B: **권한 검증 없음**, 내부 경로 노출 위험.
- 수정: `normalize/resolve` + **BASE 프리픽스 검사**, **ID 매핑**, **권한 검사**, 실패 시 400/403.

---

**문제 2**
Zip 업로드 후 서버에서 자동 해제한다. 어떤 위험이 있고, 어떻게 방어해야 하는가?

**모범 요지**
- 위험: **Zip Slip**(엔트리 `../../`), 심볼릭 링크, 압축 폭탄(대용량/파일개수).
- 방어: 엔트리별 `resolve/normalize` + **BASE 프리픽스 검사**, 링크 거부, 확장자/크기/개수 상한, 타임아웃.

---

**문제 3**
Windows 환경에서 경로 비교 시 고려해야 할 3가지를 쓰시오.

**모범 요지**
- **대소문자 비민감** → 비교 전 통일.
- **UNC/장치 경로/ADS**(`\\?\`, `\\.\`, `name:stream`) 처리.
- **트레일링 점/공백**, 예약 명칭(CON/NUL/PRN 등) 및 `\`/`/` 혼용.

---

**문제 4**
다음 방어 코드에서 빠진 요소를 쓰고 보완하라.
```python
def safe_resolve(rel):
    p = (BASE / rel).resolve()
    if not str(p).startswith(str(BASE)):
        raise
    return p
```
**모범 요지**
- **권한/소유권 인가**가 없음 → 파일 소유자/정책 검사 추가.
- 로그/모니터링 부족 → 실패 사유, 호출자 기록.
- (선택) 심볼릭 링크/레이스 방지를 위한 원자적 오픈 고려.

---

**문제 5**
Nginx `alias`와 정규식 `location`을 혼합 사용할 때 발생 가능한 문제와 안전 대안을 제시하라.

**모범 요지**
- 문제: 캡처 재조합에서 **프리픽스 검증** 누락 → 경로탈출.
- 대안: 정규식 대신 **prefix location** 사용, 또는 애플리케이션에서 **권한/경로 검증 후** `X-Accel-Redirect`로 내부 제공.

---

## 부록: 간단 도식

```
입력(ID) ──┐
           │  (DB 조회)            (정규화)         (인가)          (제공)
           └─> [id→relpath] ──> BASE/rel → resolve → prefix검사 → 정책평가 → 첨부+nosniff
```

---

## 결론

경로 추적은 **입력값을 경로로 신뢰**하는 순간 시작된다. 실무 방어의 핵심은
- (1) **ID 매핑**,
- (2) **정규화 + BASE prefix 검사**,
- (3) **권한/소유권 인가**,
- (4) **심볼릭 링크/레이스/Zip Slip**까지 포함한 **전체 체인 관리**다.
서버/프레임워크/리버스 프록시/클라우드 구성을 **표준 템플릿**으로 고정하고, 정기적으로 **회귀 테스트**하면 품질과 시험 대비가 동시에 향상된다.
