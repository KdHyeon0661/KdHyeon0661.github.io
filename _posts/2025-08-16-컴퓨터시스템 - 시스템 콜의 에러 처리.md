---
layout: post
title: 컴퓨터시스템 - 시스템 콜의 에러 처리
date: 2025-08-16 15:20:23 +0900
category: 컴퓨터시스템
---
# 시스템 콜의 에러 처리 — 원리, 패턴, 함정, 실전 코드

> 리눅스/POSIX를 기준으로 **errno**, **EINTR/EAGAIN**, **부분 I/O**, **타임아웃**, **자원 누수 방지**, **신호/스레드 안전성**, **파일·네트워크·메모리 매핑**까지 다룬다.  
> 예시는 C로 제시한다.

---

## 1) 기초 원리 — `errno`와 반환값

- 대부분의 시스템 콜은 **성공 시 비음수**(대개 `0` 또는 바이트 수), **실패 시 `-1`**을 반환하고,  
  실패 원인은 **스레드 지역 변수 `errno`** 에 저장한다.
- **중요 규칙**
  - **성공 호출은 `errno`를 0으로 만들 의무가 없다.** 성공 후의 `errno` 값은 **무시**해야 한다.
  - 오류 메시지를 만들 때는 **반드시 실패 직후** `errno`를 **지역 변수에 저장**하라.  
    (다른 라이브러리 호출이 `errno`를 바꿀 수 있다.)
- 메시지 변환
  - `perror("open")`, `strerror(errno)`(스레드-안전 아님), `strerror_r`(POSIX/gnu 차이 있음).

```c
int fd = open(path, O_RDONLY);
if (fd == -1) {
    int e = errno; // 보존
    fprintf(stderr, "open(%s) failed: %s\n", path, strerror(e));
    return -1;
}
```

---

## 2) 재시도 가능한 오류 vs 치명적 오류

오류는 대체로 **일시적(Transient)** 과 **영구적(Permanent)** 으로 나뉜다.

- **일시적**: 나중에 다시 시도하면 성공할 수 있음  
  `EINTR`(신호로 중단), `EAGAIN/EWOULDBLOCK`(논블로킹), `ENOBUFS/ENOMEM`(일시적 자원 부족), `EINPROGRESS` 등
- **영구적**: 입력·권한·존재 문제가 원인  
  `ENOENT`, `EACCES/EPERM`, `EINVAL`, `ENOTDIR`, `ENOSYS` …

설계 원칙:
1) **일시적 오류는 상황에 맞게 재시도** (무한 루프 금지, **데드라인/백오프** 필요).  
2) **영구적 오류는 즉시 중단**하고 상위로 반환·로깅.

---

## 3) 신호로 인한 중단 — `EINTR` 처리

- 많은 블로킹 시스템 콜은 신호 도착 시 **`EINTR`** 로 실패할 수 있다.
- 해결책:
  - **재시도 루프**: `while (syscall(...) == -1 && errno == EINTR) continue;`
  - glibc의 `TEMP_FAILURE_RETRY(expr)` 매크로(간편)도 있다.
  - 일부 콜은 `SA_RESTART` 신호 플래그로 자동 재시작되기도 한다(보장 아님).
- **특수: `close()`**  
  POSIX는 `EINTR` 시 FD 상태가 **불특정**이라고 말한다. 실무에서는
  - **`close()`의 `EINTR`는 성공으로 간주하고 재시도하지 않는** 것이 안전하다(재시도하면 FD 재사용 레이스로 다른 FD를 닫을 수 있음).

```c
ssize_t retry_read(int fd, void *buf, size_t n) {
    for (;;) {
        ssize_t r = read(fd, buf, n);
        if (r >= 0) return r;
        if (errno == EINTR) continue;   // 신호 재시도
        return -1;
    }
}
```

---

## 4) 논블로킹 I/O — `EAGAIN/EWOULDBLOCK`

- 소켓/파이프/터미널을 `O_NONBLOCK` 으로 열면, 읽기·쓰기 불가능 시 **즉시** `-1`과 `EAGAIN` 을 반환한다.
- 처리 패턴: **준비도 확인 → I/O 시도 → `EAGAIN`이면 다시 기다림**.
  - 준비도 확인: `poll/ppoll`, `select/pselect`, `epoll`, `kqueue(비POSIX)`.
  - 타임아웃을 명시해 **영원히 대기하지 않도록** 한다.

```c
#include <poll.h>

ssize_t nb_read_once(int fd, void *buf, size_t n, int timeout_ms){
    struct pollfd p = { .fd = fd, .events = POLLIN };
    int pr = poll(&p, 1, timeout_ms);
    if (pr <= 0) { errno = (pr==0)? EAGAIN : errno; return -1; }
    return read(fd, buf, n); // 여전히 EINTR/EAGAIN 가능 → 상위에서 루프
}
```

---

## 5) **부분 I/O**(Short read/write)와 EOF

- `read()` 는 **0** 을 반환하면 **EOF**(상대가 종료). 0이 아닌 양수 < 요청 바이트일 수도 있다.
- `write()` 도 요청한 바이트를 **모두 쓰지 않을 수 있다**(특히 소켓/파이프, 큰 버퍼).  
  → **반드시 루프**로 **모두 처리**해야 한다.

```c
// 모든 바이트 쓰기
ssize_t write_all(int fd, const void *buf, size_t n){
    const unsigned char *p = buf;
    size_t left = n;
    while (left) {
        ssize_t w = write(fd, p, left);
        if (w > 0) { p += w; left -= w; continue; }
        if (w == -1 && (errno == EINTR)) continue;
        if (w == -1 && (errno == EAGAIN)) continue; // 논블로킹이면 준비 후 재시도
        return -1; // 기타 오류
    }
    return (ssize_t)n;
}
```

---

## 6) 타임아웃과 데드라인 패턴

- 재시도 루프에는 **데드라인**(절대 시각) 또는 **최대 시도 시간**을 둔다.
- `clock_gettime(CLOCK_MONOTONIC, …)` 으로 시작 시간을 얻고, 남은 시간을 계산해 `ppoll/pselect` 에 넘긴다.

```c
int wait_readable_deadline(int fd, const struct timespec *deadline){
    for (;;) {
        struct timespec now, remain;
        clock_gettime(CLOCK_MONOTONIC, &now);
        if (now.tv_sec > deadline->tv_sec ||
           (now.tv_sec==deadline->tv_sec && now.tv_nsec>=deadline->tv_nsec))
            { errno = ETIMEDOUT; return -1; }
        // remain = deadline - now
        long ns = (deadline->tv_sec - now.tv_sec)*1000000000L + (deadline->tv_nsec - now.tv_nsec);
        remain.tv_sec = ns/1000000000L; remain.tv_nsec = ns%1000000000L;

        struct pollfd p = { .fd=fd, .events=POLLIN };
        int r = ppoll(&p, 1, &remain, NULL);
        if (r == 1 && (p.revents & POLLIN)) return 0;
        if (r == -1 && errno == EINTR) continue;
        if (r == 0) { errno = ETIMEDOUT; return -1; }
        return -1;
    }
}
```

---

## 7) 시그널과 `SIGPIPE` / `EPIPE`

- 닫힌 소켓/파이프에 `write()` 하면 **`SIGPIPE`** 발생(기본 동작: **프로세스 종료**), `write`는 `-1/EPIPE`.
- 안전 패턴:
  - 프로세스 시작 시 `signal(SIGPIPE, SIG_IGN)` 로 무시하고, **`EPIPE`를 오류로 처리**.
  - 또는 소켓에 `MSG_NOSIGNAL` 플래그(전송 시), 일부 OS는 `SO_NOSIGPIPE`.

```c
signal(SIGPIPE, SIG_IGN);
if (write(fd, buf, n) == -1 && errno == EPIPE) {
    // 상대 종료 처리
}
```

---

## 8) 파일 디스크립터 수명과 누수 방지

- **`O_CLOEXEC`**: `open/openat`/`pipe2`/`accept4` 에서 **생성 시점**에 `CLOEXEC` 설정 → `exec()` 후 FD 상속 방지.
- 사후 설정은 경쟁이 생기므로 `fcntl(fd, F_SETFD, FD_CLOEXEC)` 보다는 **원샷 플래그** 사용 권장.
- FD 한도 초과: `EMFILE`(프로세스 한도), `ENFILE`(시스템 한도).  
  → 로깅 후 **백오프**, 필요 시 **예약 FD 전략**(비상용 FD를 열어두었다가 닫고 처리).

```c
int fd = open(path, O_RDONLY | O_CLOEXEC);
if (fd == -1 && errno == EMFILE) {
    // 예약 FD 닫기 → 잠시 처리 → 다시 열기 같은 전략
}
```

---

## 9) 경로/권한/경쟁 조건(TOCTTOU) 방지

- 파일 생성은 `openat()`과 **원자 플래그** 활용:
  - 안전 생성: `O_CREAT | O_EXCL` (이미 있으면 실패)  
  - 디렉터리 강제: `O_DIRECTORY`  
  - 심볼릭 링크 금지: `O_NOFOLLOW`
- 디렉터리 FD 기준 API(`*at`)로 **의도한 디렉터리 안에서만** 작업: 경로 스퀏팅/심링크 공격 완화.

```c
int dfd = open("/safe/dir", O_RDONLY | O_DIRECTORY | O_CLOEXEC);
int fd  = openat(dfd, "file", O_CREAT | O_EXCL | O_WRONLY | O_NOFOLLOW | O_CLOEXEC, 0644);
```

---

## 10) 메모리 매핑 `mmap`/`munmap`·페이지 신호

- 실패 시 **`MAP_FAILED`**(즉 `((void*)-1)`) 반환. `NULL` 아님.
- 파일이 잘못 잘려나가면 **접근 시 `SIGBUS`** 가능 → 신호 핸들러/복구 설계.
- 동기화: `msync` 결과와 `fsync`/`fdatasync` 오류(EIO, ENOSPC, EDQUOT)를 체크.

```c
void *p = mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);
if (p == MAP_FAILED) { perror("mmap"); /* handle */ }
```

---

## 11) 스레드·신호 안전성

- `errno` 는 스레드 지역임(스레드 안전).  
- **신호 핸들러** 안에서는 **비동기-시그널-안전(AS-safe)** 함수만 호출(예: `write`, `_exit`).  
  핸들러 시작/종료 시 **`int saved = errno; ... errno = saved;`** 로 `errno` 복구.

```c
void handler(int sig){
    int saved = errno;
    const char msg[] = "INT\n";
    write(STDERR_FILENO, msg, sizeof msg - 1);
    errno = saved;
}
```

---

## 12) 정리·해제 패턴 — `goto` 기반 정리

여러 자원을 잡았다면 **한 곳에서 정리**하는 패턴이 안전하다.

```c
int do_work(const char *path){
    int fd = -1; void *map = NULL; int rc = -1;

    fd = open(path, O_RDONLY | O_CLOEXEC);
    if (fd == -1) goto FAIL;

    map = mmap(NULL, 4096, PROT_READ, MAP_PRIVATE, fd, 0);
    if (map == MAP_FAILED) { map = NULL; goto FAIL; }

    // ... 작업 ...
    rc = 0;
FAIL:
    if (map) munmap(map, 4096);
    if (fd != -1) close(fd); // close의 EINTR는 무시
    return rc;
}
```

---

## 13) 파일·스토리지 특수 오류

- **공간 부족**: `ENOSPC`(디스크), `EDQUOT`(쿼터). 기록 중단·사용자 경고·롤백.
- **데이터 동기화 실패**: `fsync`/`fdatasync`의 `EIO`/`ENOSPC`는 반드시 상위로 전달.
- **원자적 갱신**: `rename()`은 같은 파일시스템 내에서 원자적. 임시 파일에 쓰고 `fsync` → `rename` → 디렉터리 `fsync` 순서로 **크래시 안전** 확보.

---

## 14) 네트워크 특수 오류

- **연결 오류**: `ECONNREFUSED/ETIMEDOUT/ENETUNREACH` → 재시도 정책, 지수 백오프, 데드라인.
- **비정상 종료**: `read=0`(EOF), `EPIPE`(위 §7), `ECONNRESET`.
- **부분 송신**: `send()` 루프 필수, `sendfile/splice` 사용 시 반환값 체크 동일.
- **논블로킹 connect**: `connect` → `EINPROGRESS` → `poll(POLLOUT)` 으로 완료 확인, `getsockopt(SO_ERROR)`로 최종 오류 확인.

```c
int ok_connect_nb(int s, const struct sockaddr *sa, socklen_t sl, int ms){
    int r = connect(s, sa, sl);
    if (r == 0) return 0;
    if (r == -1 && errno == EINPROGRESS) {
        struct pollfd p = { .fd=s, .events=POLLOUT };
        if (poll(&p,1,ms) == 1) {
            int err=0; socklen_t len=sizeof err;
            getsockopt(s, SOL_SOCKET, SO_ERROR, &err, &len);
            if (err==0) return 0;
            errno = err; return -1;
        }
        errno = (errno==EINTR)? EINTR : ETIMEDOUT;
    }
    return -1;
}
```

---

## 15) 로깅·전파·리턴 정책

- **리턴 규약을 통일**: `int`(0/-1) or `ssize_t`(>=0/-1) or **`errno` 자체 반환**(양수) 등 팀 표준을 정하라.
- **오류 메시지**에는 **엔터티와 파라미터** 포함: `"open(%s, O_RDONLY) failed: %s"`.
- 라이브러리 함수는 **`errno`를 덮어쓰지 않도록** 주의(사용자에게 오류 원인을 남겨준다).

---

## 16) 테스트/관찰

- **`strace -f -e trace=%file,%network`** 로 시스템 콜과 오류를 확인.
- 실패 주입: `ulimit -n 32`(FD 부족), 가득 찬 디스크, `tc netem`(네트워크 지연/손실).
- 타임아웃/재시도 경로도 **의도적으로** 실행해 본다.

---

## 17) 미니 체크리스트

- [ ] **모든 시스템 콜 반환값을 검사**했는가? (`assert`가 아니라 **런타임 처리**)
- [ ] **`errno`를 즉시 보존**했는가?
- [ ] **`EINTR` 루프/타임아웃/데드라인**이 있는가?
- [ ] **부분 I/O 루프**(read/write all)가 있는가?
- [ ] **`SIGPIPE` 무시** 또는 `MSG_NOSIGNAL` 을 적용했는가?
- [ ] **`O_CLOEXEC`** 를 일관되게 사용했는가?
- [ ] 경로 작업에 **`openat` + 안전 플래그**를 사용했는가?
- [ ] **자원 정리**는 한 곳에서, 오류 경로도 동일하게 처리되는가?

---

## 18) 한 줄 결론
시스템 콜 에러 처리는 **패턴화**할 수 있다.  
**EINTR/EAGAIN 루프**, **부분 I/O 보장**, **타임아웃/데드라인**, **자원 수명·경쟁 조건**을 틀로 만들고,  
`errno` 보존·로깅·정리 루틴을 표준화하면 **견고하고 디버그 가능한** 시스템 코드가 된다.