---
layout: post
title: 컴퓨터시스템 - 시스템 콜의 에러 처리
date: 2025-08-16 15:20:23 +0900
category: 컴퓨터시스템
---
# 시스템 콜의 에러 처리

## 빠른 개요

- **반드시**: 모든 시스템 콜의 **반환값 검사** → 실패 즉시 `int e = errno;`로 **보존**
- **EINTR 루프**: 블로킹 콜은 `while (r==-1 && errno==EINTR) 재시도`
- **부분 I/O**: `read`/`write`는 **루프**로 정확한 바이트 수를 보장
- **논블로킹/타임아웃**: `ppoll/pselect/epoll`로 준비도 확인 + **절대 데드라인** 설계
- **SIGPIPE**: 시작 시 `signal(SIGPIPE, SIG_IGN)` 혹은 `MSG_NOSIGNAL`
- **CLOEXEC/NOFOLLOW**: FD 상속/심링크/디렉터리 우회 방지 → `O_CLOEXEC | O_NOFOLLOW | O_DIRECTORY` 등
- **close(EINTR)**: **성공 간주**(재시도 금지)
- **mmap**: 실패는 `MAP_FAILED`(NULL 아님), 잘못된 파일 접근은 **SIGBUS** 가능
- **원자적 갱신**: tmp 작성 → `fsync(tmp)` → `rename()` → `fsync(dir)`
- **실전 유틸**: 본문 §12 “robio.h/.c” 그대로 복붙해 사용

---

## 기초 원리 — `errno`와 반환 규약

- **성공**: 대개 **비음수**(0 또는 바이트 수).
- **실패**: `-1` 반환 + **스레드 로컬** 변수 `errno`에 오류 코드 저장.
- **중요 규칙**
  1) **성공 호출은 `errno`를 0으로 만들지 않는다.** 성공 뒤의 `errno` 값은 **무시**.
  2) 오류 메시지/분기용으로 쓸 땐 **실패 직후** `errno`를 **지역 변수**에 **즉시 저장**.

```c
int fd = open(path, O_RDONLY | O_CLOEXEC);
if (fd == -1) {
    int e = errno; // 보존
    fprintf(stderr, "open(%s) failed: %s\n", path, strerror(e));
    return -1;
}
```

- 메시지: `perror("open")`, `strerror(errno)`(스레드-안전 아님), `strerror_r`(POSIX/gnu 차이).
  실전에서는 **안전 래퍼**를 만들어 쓴다(§12).

---

## 오류 분류 — 일시적 vs 영구적

| 범주 | 예시 errno | 처리 원칙 |
|---|---|---|
| **일시적(Transient)** | `EINTR`, `EAGAIN/EWOULDBLOCK`, `EINPROGRESS`, `ENOBUFS`, `ENOMEM` | **재시도**하되, **데드라인/백오프** 설계 |
| **영구적(Permanent)** | `ENOENT`, `EACCES/EPERM`, `EINVAL`, `ENOTDIR`, `EXDEV`, `ENOSYS` | **즉시 실패** 반환/로깅 |

> **백오프**: 짧은 지수 백오프(예: 1, 2, 4, 8ms…) + 최대 대기 상한.

---

## 신호로 인한 중단 — `EINTR` 패턴

- 블로킹 시스템 콜은 시그널 도착 시 **`EINTR`** 로 종료 가능.
- **표준 패턴**:

```c
#define TEMP_RETRY_ON_EINTR(expr) \

    ({ typeof(expr) __r; do { __r = (expr); } while (__r == -1 && errno == EINTR); __r; })

ssize_t r = TEMP_RETRY_ON_EINTR(read(fd, buf, n));
```

- **특수: `close()`**
  POSIX 의미론상 `close()`가 `EINTR`이면 FD가 닫혔는지 **불특정** → **실무 권장**:
  **`close()`의 `EINTR`는 성공으로 간주**하고 **재시도하지 않는다**(FD 재사용 레이스 방지).

---

## 논블로킹과 `EAGAIN` — 준비도(ready) + 시도 + 재대기

- `O_NONBLOCK` 설정 시 읽기/쓰기 불가 상황에서 **즉시** `-1/EAGAIN`.
- **이벤트 대기 → I/O 시도 → `EAGAIN`이면 다시 대기**:

```c
#include <poll.h>

static int wait_readable(int fd, int timeout_ms) {
    struct pollfd p = { .fd=fd, .events=POLLIN };
    for (;;) {
        int r = poll(&p, 1, timeout_ms);
        if (r == 1 && (p.revents & (POLLIN|POLLHUP|POLLERR))) return 0;
        if (r == 0) { errno = EAGAIN; return -1; }
        if (r == -1 && errno == EINTR) continue;
        return -1;
    }
}
```

> **ppoll/pselect** 사용 시 **시그널 마스크와 대기를 원자적으로** 처리 → 경쟁 조건 회피(§8).

---

## 부분 I/O(Short read/write) — **반드시 루프**

- `read()`는 요청보다 **적게 읽을 수** 있고, `0`이면 **EOF**.
- `write()`도 **일부만 쓰고** 돌아올 수 있음(특히 파이프/소켓/큰 버퍼).
- **보장 쓰기**:

```c
ssize_t write_all(int fd, const void *buf, size_t n) {
    const unsigned char *p = buf;
    size_t left = n;
    while (left) {
        ssize_t w = write(fd, p, left);
        if (w > 0) { p += w; left -= (size_t)w; continue; }
        if (w == -1 && (errno == EINTR || errno == EAGAIN)) continue;
        return -1;
    }
    return (ssize_t)n;
}
```

- 읽기 쪽은 “정확히 N바이트 읽기” 또는 “라인 단위/프레이밍 읽기”로 **프로토콜**을 명확히.

---

## 타임아웃과 **절대 데드라인** 패턴

- 상대 타임아웃(남은 시간)을 계속 갱신하면 드리프트/경쟁이 생긴다.
  **권장**: 시작에 **절대 데드라인**을 계산 → 매 루프에서 **남은 시간** 재계산.

```c
static int now_mono(struct timespec *ts){ return clock_gettime(CLOCK_MONOTONIC, ts); }

static int ts_compare(const struct timespec *a, const struct timespec *b) {
    if (a->tv_sec != b->tv_sec) return (a->tv_sec > b->tv_sec) - (a->tv_sec < b->tv_sec);
    if (a->tv_nsec != b->tv_nsec) return (a->tv_nsec > b->tv_nsec) - (a->tv_nsec < b->tv_nsec);
    return 0;
}

static struct timespec ts_sub(const struct timespec *end, const struct timespec *beg) {
    struct timespec r = { end->tv_sec - beg->tv_sec, end->tv_nsec - beg->tv_nsec };
    if (r.tv_nsec < 0) { r.tv_sec--; r.tv_nsec += 1000000000L; }
    return r;
}
```

- 이 남은 시간을 `ppoll/pselect`에 넘기면, **EINTR 루프**에서도 정확한 시간 보장이 된다.

---

## SIGPIPE / `EPIPE` — **종료 대신 오류 처리**

- 닫힌 파이프/소켓에 `write()` → **SIGPIPE**(기본 동작: 종료) + `-1/EPIPE`
- **전역 무시 + 코드에서 에러 처리**:

```c
signal(SIGPIPE, SIG_IGN); // 프로세스 초기화 시 1회
// 또는 send(..., MSG_NOSIGNAL) (Linux), SO_NOSIGPIPE(BSD)
```

---

## 시그널과 블로킹 I/O — `SA_RESTART`, `pselect/ppoll`

- `SA_RESTART`: 일부 블로킹 콜을 **자동 재시작**(보장 아님).
- I/O 대기와 시그널 처리의 **경쟁 조건** 제거: `pselect/ppoll`로
  **(1) 마스크 변경**과 **(2) 대기**를 **원자적으로** 수행.

```c
sigset_t mask, old;
sigemptyset(&mask);
sigaddset(&mask, SIGTERM);
pthread_sigmask(SIG_BLOCK, &mask, &old);

fd_set rfds; FD_ZERO(&rfds); FD_SET(fd, &rfds);
int r = pselect(fd+1, &rfds, NULL, NULL, NULL, &old); // 대기 중 SIGTERM 허용
```

---

## FD 수명/누수 방지 — `O_CLOEXEC`와 “예약 FD”

- **생성 시점**에 `O_CLOEXEC`(또는 `accept4/pipe2`의 `*4` 변형)로 **FD 상속 방지**.
  사후 `fcntl(F_SETFD, FD_CLOEXEC)`는 경쟁 조건 가능 → **비권장**.
- 한도 초과: `EMFILE`(프로세스), `ENFILE`(시스템).
  **예약 FD 전략**: 비상용 FD 하나를 열어두었다가 **닫고** 처리 후 다시 확보.

---

## 경로/권한/TOCTTOU 완화 — `*at`, `openat2`(Linux), 안전 플래그

- **디렉터리 FD 기준** API(`openat/fstatat/linkat/unlinkat/...`) 사용으로
  **의도한 디렉터리 트리**에 한해 작업.
- 안전 플래그:
  - 생성: `O_CREAT | O_EXCL` (원자적 존재 확인)
  - 디렉터리 강제: `O_DIRECTORY`
  - 심링크 금지: `O_NOFOLLOW`
- Linux의 **`openat2`**(5.6+): `RESOLVE_BENEATH`, `RESOLVE_NO_SYMLINKS`, `RESOLVE_IN_ROOT` 등으로
  경로 탈주 방지(샌드박싱·치명적 경로 작업에 유용).

```c
int dfd = open("/safe", O_DIRECTORY|O_RDONLY|O_CLOEXEC);
int fd  = openat(dfd, "file", O_CREAT|O_EXCL|O_WRONLY|O_NOFOLLOW|O_CLOEXEC, 0644);
```

---

## `mmap`/`msync`/`fsync` — SIGBUS와 동기화 오류

- 실패는 **`MAP_FAILED`**(NULL 아님).
- 잘못 잘린 파일(또는 I/O 오류) → **접근 시 `SIGBUS`** 가능.
  → 신호 핸들러/복구 경로 설계.
- 디스크 반영:
  - 메모리-파일: `msync`
  - 파일-디스크: `fsync`/`fdatasync` → `EIO`, `ENOSPC`, `EDQUOT`를 **상위로 전파**.

---

## 실전 유틸(바로 복붙) — `robio.h` / `robio.c`

> **기능**
> - 안전 `strerror`
> - `O_NONBLOCK`/`O_CLOEXEC` 설정
> - `write_all`/`read_full`(데드라인 지원)
> - `connect_nb_with_timeout`
> - `wait_readable`/`wait_writable` (ppoll)
> - 원자적 파일 쓰기(크래시 안전 시퀀스)

```c
/* robio.h */
#pragma once
#define _POSIX_C_SOURCE 200809L
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/poll.h>
#include <sys/epoll.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <time.h>
#include <unistd.h>
#include <errno.h>
#include <stddef.h>

#ifdef __cplusplus

extern "C" {
#endif

/* thread-safe strerror to buf */
const char* rob_strerror(int err, char *buf, size_t bufsz);

/* flags helpers */
int rob_set_cloexec(int fd);
int rob_set_nonblock(int fd);

/* time helpers */
int  rob_now(struct timespec *ts); /* CLOCK_MONOTONIC */
int  rob_remain(const struct timespec *deadline, struct timespec *remain);

/* wait readiness with ppoll (returns 0 on ready, -1 on error, errno=ETIMEDOUT/EINTR/...) */
int rob_wait_readable(int fd, const struct timespec *deadline, const sigset_t *mask);
int rob_wait_writable(int fd, const struct timespec *deadline, const sigset_t *mask);

/* io loops */
ssize_t rob_write_all(int fd, const void *buf, size_t n, const struct timespec *deadline, const sigset_t *mask);
ssize_t rob_read_full (int fd, void *buf, size_t n, const struct timespec *deadline, const sigset_t *mask);

/* nonblocking connect with timeout */
int rob_connect_nb_with_timeout(int fd, const struct sockaddr *sa, socklen_t sl, const struct timespec *deadline, const sigset_t *mask);

/* crash-safe atomic replace: write tmp -> fsync(tmp) -> rename -> fsync(dir) */
int rob_atomic_replace(int dfd, const char *tmpname, const char *final);

#ifdef __cplusplus

}
#endif

```

```c
/* robio.c */
#define _GNU_SOURCE
#include "robio.h"
#include <string.h>
#include <stdio.h>
#include <dirent.h>

const char* rob_strerror(int err, char *buf, size_t bufsz) {
#if defined(__GLIBC__) && !defined(_GNU_SOURCE)

    /* glibc old POSIX strerror_r variant */
#endif
#if defined(__GLIBC__)

    /* GNU variant returns char* */
    return strerror_r(err, buf, bufsz);
#else

    /* POSIX: returns int */
    if (strerror_r(err, buf, bufsz) == 0) return buf;
    snprintf(buf, bufsz, "errno %d", err);
    return buf;
#endif

}

int rob_set_cloexec(int fd) {
    int fl = fcntl(fd, F_GETFD);
    if (fl == -1) return -1;
    return fcntl(fd, F_SETFD, fl | FD_CLOEXEC);
}
int rob_set_nonblock(int fd) {
    int fl = fcntl(fd, F_GETFL);
    if (fl == -1) return -1;
    return fcntl(fd, F_SETFL, fl | O_NONBLOCK);
}

int rob_now(struct timespec *ts){ return clock_gettime(CLOCK_MONOTONIC, ts); }

int rob_remain(const struct timespec *deadline, struct timespec *remain){
    struct timespec now;
    if (rob_now(&now) != 0) return -1;
    long s = deadline->tv_sec - now.tv_sec;
    long ns = deadline->tv_nsec - now.tv_nsec;
    if (ns < 0) { ns += 1000000000L; s--; }
    if (s < 0) { remain->tv_sec = remain->tv_nsec = 0; errno = ETIMEDOUT; return -1; }
    remain->tv_sec = s; remain->tv_nsec = ns;
    return 0;
}

static int _ppoll_wait(int fd, short events, const struct timespec *deadline, const sigset_t *mask) {
    struct pollfd p = { .fd=fd, .events=events };
    for (;;) {
        struct timespec to, *pto = NULL;
        if (deadline) {
            if (rob_remain(deadline, &to) != 0) return -1;
            pto = &to;
        }
        int r = ppoll(&p, 1, pto, mask);
        if (r == 1) {
            if (p.revents & (POLLERR|POLLNVAL)) { errno = EIO; return -1; }
            return 0;
        }
        if (r == 0) { errno = ETIMEDOUT; return -1; }
        if (r == -1 && errno == EINTR) continue;
        return -1;
    }
}

int rob_wait_readable(int fd, const struct timespec *deadline, const sigset_t *mask) {
    return _ppoll_wait(fd, POLLIN|POLLHUP, deadline, mask);
}
int rob_wait_writable(int fd, const struct timespec *deadline, const sigset_t *mask) {
    return _ppoll_wait(fd, POLLOUT, deadline, mask);
}

ssize_t rob_write_all(int fd, const void *buf, size_t n, const struct timespec *deadline, const sigset_t *mask) {
    const unsigned char *p = buf;
    size_t left = n;
    while (left) {
        ssize_t w = write(fd, p, left);
        if (w > 0) { p += (size_t)w; left -= (size_t)w; continue; }
        if (w == -1 && (errno == EINTR)) continue;
        if (w == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
            if (rob_wait_writable(fd, deadline, mask) != 0) return -1;
            continue;
        }
        return -1;
    }
    return (ssize_t)n;
}

ssize_t rob_read_full(int fd, void *buf, size_t n, const struct timespec *deadline, const sigset_t *mask) {
    unsigned char *p = buf;
    size_t got = 0;
    while (got < n) {
        ssize_t r = read(fd, p+got, n-got);
        if (r > 0) { got += (size_t)r; continue; }
        if (r == 0) { /* EOF */ break; }
        if (r == -1 && errno == EINTR) continue;
        if (r == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
            if (rob_wait_readable(fd, deadline, mask) != 0) return -1;
            continue;
        }
        return -1;
    }
    return (ssize_t)got;
}

int rob_connect_nb_with_timeout(int fd, const struct sockaddr *sa, socklen_t sl, const struct timespec *deadline, const sigset_t *mask) {
    int r = connect(fd, sa, sl);
    if (r == 0) return 0;
    if (r == -1 && errno == EINPROGRESS) {
        if (rob_wait_writable(fd, deadline, mask) != 0) return -1;
        int err = 0; socklen_t len = sizeof err;
        if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &len) != 0) return -1;
        if (err) { errno = err; return -1; }
        return 0;
    }
    return -1;
}

static int _fsync_dirfd(int dfd){
    int rc = fsync(dfd);
    return rc;
}

int rob_atomic_replace(int dfd, const char *tmpname, const char *final) {
    /* tmpname 은 이미 같은 디렉터리 dfd 아래에 존재, 데이터 기록 끝냄 */
    int tfd = openat(dfd, tmpname, O_RDONLY | O_CLOEXEC);
    if (tfd == -1) return -1;
    if (fsync(tfd) != 0) { close(tfd); return -1; }
    close(tfd);
    if (renameat(dfd, tmpname, dfd, final) != 0) return -1;
    if (_fsync_dirfd(dfd) != 0) return -1;
    return 0;
}
```

---

## 네트워크 — `connect`/`send`/`recv` 특이점

- **connect(논블로킹)**: `EINPROGRESS` → `POLLOUT` 대기 → `SO_ERROR` 확인(0이면 성공, 아니면 errno 설정).
- **부분 송수신**: `send`/`recv` **루프** + `EAGAIN/EINTR` 처리.
- **Half-close**: `shutdown(fd, SHUT_WR)` 후 peer의 EOF(읽기 `0`) 관찰로 **정상 종료** 판단.

---

## 파일 쓰기 — 크래시 안전 순서

1) 임시 파일(`.tmp`)에 **데이터 전체 쓰기** → `fsync(tmp)`
2) **동일 파일시스템**에서 `rename(tmp, final)` (원자적 교체)
3) **부모 디렉터리** `fsync(dirfd)` 로 메타데이터 보장

> 파일시스템/마운트 옵션에 따라 세부가 달라질 수 있으나 이 시퀀스가 보편적 최선.

---

## 스레드/시그널 안전 — 최소 원칙

- `errno`는 **스레드 로컬**.
- **시그널 핸들러**에서는 **AS-safe** 함수만 사용(예: `write`), 끝나면 `errno` 복구.
- **전용 시그널 스레드** + 기타 스레드 **전부 블록** 패턴(§시그널 글 참고).

---

## 디버깅/관찰/실패 주입

- `strace -f -e trace=%file,%network ./app` — 시스템 콜/errno 추적
- `ulimit -n 32` — FD 부족 재현, 가득 찬 디스크/쿼터로 `ENOSPC/EDQUOT` 재현
- `tc qdisc add dev ... netem delay/loss` — 네트워크 지연/손실
- 타임아웃/재시도 경로를 **의도적으로** 밟게 하여 로그/메트릭 검증

---

## “견고한 종료” 미니 예제 — SIGPIPE 무시 + 타임아웃 + 부분 I/O

```c
#define _POSIX_C_SOURCE 200809L
#include "robio.h"
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdio.h>

int main(void){
    signal(SIGPIPE, SIG_IGN);

    int s = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC, 0);
    rob_set_nonblock(s);

    struct sockaddr_in sa = { .sin_family=AF_INET, .sin_port=htons(8080) };
    inet_pton(AF_INET, "127.0.0.1", &sa.sin_addr);

    struct timespec deadline; rob_now(&deadline); deadline.tv_sec += 3; // 3초 데드라인
    if (rob_connect_nb_with_timeout(s, (struct sockaddr*)&sa, sizeof sa, &deadline, NULL) != 0) {
        char b[128]; fprintf(stderr, "connect: %s\n", rob_strerror(errno,b,sizeof b)); return 1;
    }

    const char req[] = "GET / HTTP/1.0\r\n\r\n";
    if (rob_write_all(s, req, sizeof req - 1, &deadline, NULL) < 0) {
        perror("write_all"); return 1;
    }

    char buf[4096];
    ssize_t n = rob_read_full(s, buf, sizeof buf, &deadline, NULL); // 헤더 일부만 읽는 예
    if (n < 0) { perror("read_full"); return 1; }
    write(STDOUT_FILENO, buf, (size_t)n);

    /* close의 EINTR는 성공으로 간주 */
    close(s);
    return 0;
}
```

---

## 자주 겪는 함정과 처방

| 현상 | 원인 | 처방 |
|---|---|---|
| 블로킹 I/O가 간헐적으로 `-1/EINTR` | 시그널 개입 | **EINTR 루프**, 혹은 `SA_RESTART` + `pselect/ppoll` |
| 쓰기 후 프로세스가 종료 | `SIGPIPE` 기본 동작 | 전역 **무시** + `EPIPE` 처리, 또는 `MSG_NOSIGNAL` |
| 로그에 errno가 엉뚱함 | 보존 전에 다른 함수 호출 | **실패 직후 `e=errno` 보존** |
| `close` 후 FD가 여전히 열려 보임 | `close(EINTR)` 재시도 | **재시도 금지**, 성공 간주 |
| 임시 파일이 남음/손상 | 순서/동기화 미흡 | `fsync(tmp)` → `rename` → `fsync(dir)` |
| 보안 경로 탈주 | 심링크/상대경로 | `openat`/`openat2` + `O_NOFOLLOW` + `RESOLVE_*` |
| 논블로킹 connect가 성공/실패 판별 안 됨 | `SO_ERROR` 미확인 | `getsockopt(SO_ERROR)`로 최종 오류 확인 |
| EOF 처리 혼동 | `read==0` 무시 | `0`은 **EOF**, 연결 종료 판단에 사용 |

---

## 보너스: 수학적 관점에서의 데드라인 오차 누적(간단)

블로킹-재시도 루프에서 상대 타임아웃 `t`를 매번 그대로 쓰면,
**EINTR**/일시적 `EAGAIN` 루프에 의해 총 대기가
$$ T \approx t \times N + \sum_{i=1}^{N} \delta_i $$
로 **늘어날 수** 있다(`\delta_i`는 각 루프의 추가 지연).
**절대 데드라인**을 사용하면 각 루프에서 남은 시간
$$ t_i = \max(0, D - \text{now}_i) $$
로 계산되어 **총 대기 시간이 D를 넘지 않음**.

---

## 마무리 — 실전 적용 요령

- **팀 표준**을 정하라: 반환 규약(0/-1 vs errno), 로깅 포맷, 유틸 함수 세트(§12).
- **I/O는 루프**가 기본값 — 부분 I/O와 `EINTR/EAGAIN`은 정상 경로다.
- **시간은 절대 데드라인** — 타임아웃 정확도/코드 간결성 모두 향상.
- **FD/경로 보안** — `O_CLOEXEC`·`*at`·`openat2`·`NOFOLLOW` 패턴을 습관화.
- **네트워크/스토리지 특수 오류** — `EPIPE/ECONNRESET/ENOSPC/EIO`를 “운영 시나리오”로 다루기.

---

## 부록 A) 안전 로깅 스니펫

```c
#define LOGE(fmt, ...) do { \

    int __e = errno; \
    char __b[128]; \
    fprintf(stderr, "[%s:%d] " fmt " (err=%d:%s)\n", \
        __FILE__, __LINE__, ##__VA_ARGS__, __e, rob_strerror(__e, __b, sizeof __b)); \
} while(0)
```

## 부록 B) `TEMP_FAILURE_RETRY`(glibc 스타일)

```c
#ifndef TEMP_FAILURE_RETRY
#define TEMP_FAILURE_RETRY(expression) \

  ({ long int __result; \
     do __result = (long int)(expression); \
     while (__result == -1L && errno == EINTR); \
     __result; })
#endif

```

## 부록 C) 원자적 라인 읽기(부분 읽기 + EOF 안전)

```c
ssize_t read_line_nb(int fd, char *buf, size_t maxlen, const struct timespec *deadline, const sigset_t *mask){
    size_t i = 0;
    while (i+1 < maxlen) {
        char c;
        ssize_t r = read(fd, &c, 1);
        if (r == 1) { buf[i++] = c; if (c == '\n') break; continue; }
        if (r == 0) break; // EOF
        if (r == -1 && (errno == EINTR)) continue;
        if (r == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
            if (rob_wait_readable(fd, deadline, mask) != 0) return -1;
            continue;
        }
        return -1;
    }
    buf[i] = '\0';
    return (ssize_t)i;
}
```

---

## 한 줄 결론

에러 처리는 **패턴**이다.
**EINTR/EAGAIN 루프**, **부분 I/O 보장**, **절대 데드라인**, **FD/경로 보안 플래그**, **SIGPIPE 무시 + 오류 처리**를
유틸 함수로 **표준화**하면, 시스템 코드는 **견고**해지고 **디버깅 가능한 로그**를 남긴다.
본문의 `robio` 세트를 프로젝트에 넣고, 모든 시스템 콜 호출부를 **한 가지 문체로** 통일하라.
