---
layout: post
title: 객체지향설계 - 테스트 가능한 객체 지향 구조
date: 2025-07-25 19:20:23 +0900
category: 객체지향설계
---
# 테스트 가능한 객체 지향 구조 (Designing Testable OOP)

## 0. 목적과 범위

- **목적**: 테스트가 쉬운 구조를 **설계 단계**에서 만들기.
- **핵심**: SRP/DIP/ISP, 포트·어댑터, 불변/순수 함수, 경계(Seam) 설계, 테스트 더블 전략.
- **성과**: 낮은 결합도, 높은 응집도, 빠르고 결정적인(Unit/Integration) 테스트, 안정적 CI.

---

## 1. 설계 원칙(테스트 용 관점)

| 원칙 | 설계 효과 | 테스트 이점 | 적용 팁 |
|---|---|---|---|
| SRP (단일 책임) | 클래스가 한 가지 이유로만 변함 | 테스트 범위 축소 | 긴 메서드/갓 클래스 분할 |
| DIP (의존 역전) | 상위가 하위 구현을 모름 | Mock/Fake 주입 용이 | **인터페이스는 안쪽 계층**에 배치 |
| ISP (인터페이스 분리) | 작은 계약 | 과도한 목킹 방지 | 사용 메서드만 가진 포트 정의 |
| High Cohesion / Low Coupling | 내부 강, 외부 약 | 독립적 단위 테스트 | 값 객체/합성 우선 |
| 순수 함수/불변 | 결정적 실행 | 결정적(assert-only) 테스트 | `Clock`/`Random` 주입으로 순수화 |

> 테스트성은 “사후” 활동이 아니다. **설계 품질의 부산물**이어야 한다.

---

## 2. 아키텍처: 계층형 → 포트·어댑터(헥사고날) → 클린

```
[UI/Controller]
      │
[Application / UseCase]  ← 트랜잭션 경계/권한/흐름
      │
[Domain]  ← 엔터티, 값 객체, 도메인 서비스 (프레임워크 무의존)
  ▲   │
  │  (Ports: Repository, MessageBus, Clock, PaymentGateway …)
  │
[Adapters / Infra]  ← DB/JPA, HTTP, MQ, FS (Ports 구현)
```

- **의존 방향**: 바깥→안쪽. 도메인이 인프라를 모르면 단위 테스트가 **빠르고 견고**해진다.
- **테스트 전략**: 도메인·애플리케이션은 **Fake/Stub**로, 어댑터는 **통합 테스트**로.

---

## 3. 테스트 더블 정리

| 유형 | 설명 | 사용 예 |
|---|---|---|
| Dummy | 매개변수 채움용 | 로깅 인터페이스 미사용 파라미터 |
| Stub | 고정 응답 | Clock, FeatureFlag, 환율 |
| Fake | 간이 구현 | InMemoryRepository, 임시 이메일 송신함 |
| Spy | 호출 기록 관찰 | 알림 횟수/순서 검증 |
| Mock | 기대 상호작용 검증 | 외부 결제 게이트웨이 호출 보장 |

> 도메인 규칙은 **Fake/Real 중심**으로 상태 검증, 외부 통신은 **Mock/Spy**로 상호작용 검증을 분리한다.

---

## 4. 경계(Seams) 만들기 — 무엇을 추상화할까

| 경계 | 포트(인터페이스) | 어댑터(구현) | 테스트 대체 |
|---|---|---|---|
| 시간 | `Clock` | `SystemClock` | `FixedClock` |
| 랜덤 | `Randomizer` | `SecureRandomizer` | `DeterministicRandomizer` |
| DB | `Repository<T>` | JPA/JDBC/EF | InMemoryRepo / Testcontainers |
| HTTP | `PaymentGateway` | `HttpClient` 기반 | MockWebServer / WireMock |
| 파일 | `FileStorage` | S3/로컬 FS | InMemoryFS (Jimfs 등) |
| 메시지 | `MessageBus` | Kafka/Rabbit | CapturingBus(Fake) |

---

## 5. 실전 예제 1 — 은행 이체(헥사고날, Java)

### 5.1 도메인/포트

```java
// domain/Money.java
public record Money(long cents, String currency) {
  public Money add(Money o){ requireSame(o); return new Money(cents+o.cents, currency); }
  public Money sub(Money o){ requireSame(o); if(cents<o.cents) throw new IllegalStateException("insufficient");
    return new Money(cents-o.cents, currency); }
  private void requireSame(Money o){ if(!currency.equals(o.currency)) throw new IllegalArgumentException("curr"); }
}

// domain/BankAccount.java
public final class BankAccount {
  private final String id;
  private Money balance;
  public BankAccount(String id, Money initial){ this.id=id; this.balance=initial; }
  public void debit(Money amt){ balance = balance.sub(amt); }
  public void credit(Money amt){ balance = balance.add(amt); }
  public Money balance(){ return balance; }
  public String id(){ return id; }
}

// application/port/AccountRepository.java
public interface AccountRepository {
  Optional<BankAccount> findById(String id);
  void save(BankAccount account);
}
```

### 5.2 애플리케이션 서비스(트랜잭션 경계는 여기)

```java
// application/TransferService.java
public class TransferService {
  private final AccountRepository repo;
  public TransferService(AccountRepository repo){ this.repo=repo; }

  public void transfer(String fromId, String toId, Money amt){
    var from = repo.findById(fromId).orElseThrow();
    var to   = repo.findById(toId).orElseThrow();
    from.debit(amt);
    to.credit(amt);
    repo.save(from);
    repo.save(to);
  }
}
```

### 5.3 InMemory Fake + 단위 테스트

```java
// testdouble/InMemoryAccountRepository.java
public class InMemoryAccountRepository implements AccountRepository {
  private final Map<String,BankAccount> store = new ConcurrentHashMap<>();
  public Optional<BankAccount> findById(String id){ return Optional.ofNullable(store.get(id)); }
  public void save(BankAccount a){ store.put(a.id(), a); }
  public void put(BankAccount a){ save(a); } // test helper
}

// test/TransferServiceTest.java (JUnit 5)
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class TransferServiceTest {
  @Test void transfer_moves_money_and_persists() {
    var repo = new InMemoryAccountRepository();
    repo.put(new BankAccount("A", new Money(1000,"USD")));
    repo.put(new BankAccount("B", new Money(500,"USD")));
    var svc = new TransferService(repo);

    svc.transfer("A","B", new Money(300,"USD"));

    assertEquals(700, repo.findById("A").get().balance().cents());
    assertEquals(800, repo.findById("B").get().balance().cents());
  }
}
```

### 5.4 상호작용(Mock) 검증(선택)

```java
// Mockito 예
@Test void calls_save_twice_in_order() {
  var repo = Mockito.mock(AccountRepository.class);
  var a = new BankAccount("A", new Money(1000,"USD"));
  var b = new BankAccount("B", new Money(500,"USD"));
  Mockito.when(repo.findById("A")).thenReturn(Optional.of(a));
  Mockito.when(repo.findById("B")).thenReturn(Optional.of(b));

  new TransferService(repo).transfer("A","B", new Money(300,"USD"));

  Mockito.verify(repo).save(a);
  Mockito.verify(repo).save(b);
}
```

---

## 6. 실전 예제 2 — 외부 결제 게이트웨이(HTTP 경계)

### 6.1 포트와 서비스

```java
// application/port/PaymentGateway.java
public interface PaymentGateway {
  String charge(String userId, Money amount); // returns approval id
}

// application/CheckoutService.java
public class CheckoutService {
  private final PaymentGateway gateway;
  public CheckoutService(PaymentGateway gateway){ this.gateway=gateway; }
  public String checkout(String userId, Money amt){ return gateway.charge(userId, amt); }
}
```

### 6.2 Mock 서버(WireMock) 통합 테스트

```java
// test/CheckoutServiceIT.java
class CheckoutServiceIT {
  @RegisterExtension static WireMockExtension wm =
    WireMockExtension.newInstance().options(wireMockConfig().dynamicPort()).build();

  @Test void call_gateway_and_return_approval() {
    wm.stubFor(post("/charge").willReturn(okJson("{\"approvalId\":\"OK-123\"}")));

    PaymentGateway gw = (user, amt) -> { // simple HTTP client 생략
      var res = /* POST wm.getRuntimeInfo().getHttpBaseUrl()+"/charge" */;
      return "OK-123";
    };
    var svc = new CheckoutService(gw);

    assertEquals("OK-123", svc.checkout("u1", new Money(100,"USD")));
  }
}
```

> **포인트**: HTTP는 애플리케이션 바깥의 **어댑터**에서 다루고, 서비스는 포트만 안다. 단위 테스트는 Fake/Mock, 통합은 WireMock/MockWebServer로.

---

## 7. 실전 예제 3 — C# (.NET) 시간/HTTP 경계화

```csharp
// Domain boundary
public interface IClock { DateTime UtcNow { get; } }
public sealed class SystemClock : IClock { public DateTime UtcNow => DateTime.UtcNow; }

public interface IPaymentGateway { Task<string> ChargeAsync(string userId, decimal amount); }

public sealed class CheckoutService {
    private readonly IPaymentGateway _gateway; private readonly IClock _clock;
    public CheckoutService(IPaymentGateway gateway, IClock clock){ _gateway=gateway; _clock=clock; }
    public async Task<(string approval, DateTime at)> CheckoutAsync(string id, decimal amount) {
        var approval = await _gateway.ChargeAsync(id, amount);
        return (approval, _clock.UtcNow);
    }
}
```

```csharp
// Test (xUnit + Moq)
[Fact]
public async Task Checkout_UsesGateway_AndReturnsFixedTime() {
    var gateway = new Mock<IPaymentGateway>();
    gateway.Setup(g=>g.ChargeAsync("u1", 10m)).ReturnsAsync("OK-1");
    var fixedClock = Mock.Of<IClock>(c => c.UtcNow == new DateTime(2025,1,1,0,0,0, DateTimeKind.Utc));

    var svc = new CheckoutService(gateway.Object, fixedClock);
    var (approval, at) = await svc.CheckoutAsync("u1", 10m);

    Assert.Equal("OK-1", approval);
    Assert.Equal(new DateTime(2025,1,1,0,0,0, DateTimeKind.Utc), at);
}
```

---

## 8. 실전 예제 4 — Python(순수 함수·Fake Repo)

```python
# domain.py
from dataclasses import dataclass

@dataclass(frozen=True)
class Money:
    cents: int
    currency: str = "USD"

@dataclass
class BankAccount:
    id: str
    balance: Money
    def debit(self, amt: Money):
        if self.balance.currency != amt.currency or self.balance.cents < amt.cents:
            raise ValueError("insufficient/currency")
        self.balance = Money(self.balance.cents - amt.cents, self.balance.currency)
    def credit(self, amt: Money):
        if self.balance.currency != amt.currency:
            raise ValueError("currency")
        self.balance = Money(self.balance.cents + amt.cents, self.balance.currency)

# service.py
class AccountRepository:
    def find(self, id: str) -> BankAccount: ...
    def save(self, acc: BankAccount) -> None: ...

class TransferService:
    def __init__(self, repo: AccountRepository):
        self.repo = repo
    def transfer(self, a: str, b: str, amt: Money):
        from_acc = self.repo.find(a)
        to_acc = self.repo.find(b)
        from_acc.debit(amt); to_acc.credit(amt)
        self.repo.save(from_acc); self.repo.save(to_acc)

# test_service.py (pytest)
class InMemoryRepo(AccountRepository):
    def __init__(self): self.store = {}
    def find(self, id): return self.store[id]
    def save(self, acc): self.store[acc.id] = acc

def test_transfer_updates_balances():
    r = InMemoryRepo()
    r.store["A"] = BankAccount("A", Money(1000))
    r.store["B"] = BankAccount("B", Money(500))
    TransferService(r).transfer("A","B", Money(300))
    assert r.store["A"].balance.cents == 700
    assert r.store["B"].balance.cents == 800
```

---

## 9. 데이터 접근 테스트: InMemory vs Testcontainers

- **InMemory**: 빠른 피드백, 비즈니스 로직 검증에 적합.
- **Testcontainers**: 실제 DB 행동(트랜잭션/인덱스/락) 검증.

```groovy
// Gradle (Java)
testImplementation "org.testcontainers:junit-jupiter:1.20.2"
testImplementation "org.testcontainers:postgresql:1.20.2"
```

```java
class RepoIT {
  static PostgreSQLContainer<?> pg = new PostgreSQLContainer<>("postgres:16");
  @BeforeAll static void start(){ pg.start(); }
  @AfterAll static void stop(){ pg.stop(); }
  // DataSource를 pg.getJdbcUrl()로 구성 후 통합 테스트
}
```

---

## 10. 시간·랜덤·환경 경계화

### 10.1 시간

```java
public interface Clock { Instant now(); }
public final class SystemClock implements Clock { public Instant now(){ return Instant.now(); } }
public final class FixedClock implements Clock { private final Instant fixed; public FixedClock(Instant i){ fixed=i; } public Instant now(){ return fixed; } }
```

### 10.2 랜덤

```kotlin
interface Randomizer { int nextInt(int bound); }
class DeterministicRandom implements Randomizer { private int v; public int nextInt(int b){ return (v++) % b; } }
```

### 10.3 환경/설정

- `Config` 포트로 주입. 테스트는 `TestConfig`로 대체.

---

## 11. 동시성·스케줄링 경계화

- **비동기 타이머/리트라이**는 인터페이스로 분리하고, 테스트에서는 **가짜 스케줄러/가짜 클록**으로 **가상 시간** 제어.
- Rx/프로미스 기반은 **TestScheduler** 사용.

```java
// 가상 시간 스케줄러 인터페이스
public interface Scheduler { void schedule(Runnable r, Duration d); }
public final class ImmediateScheduler implements Scheduler { public void schedule(Runnable r, Duration d){ r.run(); } }
```

---

## 12. 테스트 전략: 피라미드, 프로퍼티·뮤테이션 테스트

### 12.1 테스트 피라미드(권장 비율)
- **단위(Unit)**: 많고 빠르게
- **통합(Integration)**: 중간
- **E2E**: 적고 핵심 경로만

### 12.2 프로퍼티 기반 테스트(예)

```java
// jqwik 예시 (합 보존 성질)
@Property
void add_commutes(@ForAll int a, @ForAll int b) {
  assertEquals(a+b, b+a);
}
```

### 12.3 뮤테이션 점수
$$
\text{MutationScore}(\%) = 100 \times \frac{\text{Killed Mutants}}{\text{Total Mutants}}
$$

- 낮다면, 테스트가 **조건/분기**를 제대로 단속하지 못한다는 뜻.

---

## 13. CI 파이프라인 실전

1) **단위/정적 분석**: 초단계. 실패 시 즉시 피드백.
2) **통합(Testcontainers/MockServer)**: 병렬화.
3) **E2E/계약**: 배포 전 야간/스테이지.
4) **플라키 제거**: 가짜 클록/고정 포트/재시도 금지.
5) **속도 최적화**: 테스트 격리(DB 트랜잭션 롤백, 임시 디렉토리), 캐시 활용.

---

## 14. 테스트를 어렵게 만드는 안티패턴과 처방

| 안티패턴 | 증상 | 처방 |
|---|---|---|
| 전역 싱글톤 | 테스트 간 상태 누수 | 인스턴스 주입/스코프 분리 |
| 정적 호출 남용 | 목킹 불가 | 래퍼 인터페이스/어댑터 도입 |
| 도메인↔인프라 혼합 | 단위 테스트 불가 | 포트·어댑터로 분리 |
| 거대한 서비스 | 변경 충격 큼 | 유스케이스별 서비스 분해 |
| 시간/랜덤 직접 호출 | 비결정 테스트 | Clock/Randomizer 주입 |

---

## 15. 설계·코드 리뷰용 체크리스트

- [ ] **생성자 주입**을 사용하고 있는가(필수 의존성)?
- [ ] 도메인 계층이 **프레임워크에 의존**하지 않는가?
- [ ] 외부 자원(DB/HTTP/FS/시간/랜덤)이 **포트**로 추상화되었는가?
- [ ] 단위 테스트가 **빠르고 결정적**인가(네트워크/슬립 없음)?
- [ ] Fake/Stub/Mock 전략이 **일관**적인가?
- [ ] 트랜잭션 경계가 **애플리케이션 레이어**에 있는가?
- [ ] 통합 테스트는 **실 구현(어댑터)**을 검증하는가?
- [ ] 플라키 테스트가 제거되었는가(가짜 클록/고정 포트)?
- [ ] Mutation Score/복잡도/중복 임계치를 만족하는가?
- [ ] ADR(Architecture Decision Record)로 결정과 맥락이 기록되었는가?

---

## 16. 참고 매핑표 — 냄새 → 테스트성 처방

| 냄새/문제 | 설계 처방 | 테스트 이점 |
|---|---|---|
| 긴 메서드 | Extract Method/클래스 | 작은 단위 테스트 |
| 조건문 폭발 | Strategy/State | 브랜치별 독립 테스트 |
| 데이터 클래스 | 값 객체(불변) | 동등성/검증 내재화 |
| 메시지 체인 | Hide Delegate/Facade | 내부 구조 변경 영향↓ |
| 전역 상태 | DI, 스코프 | 결정적 테스트 |
| N+1/HTTP 얽힘 | 포트·어댑터 | Fake/Mock로 빠른 테스트 |

---

## 17. 프로젝트 뼈대(예: Java)

```
src/
 ├─ main/java
 │   ├─ com.example.app.presentation (controller, dto)
 │   ├─ com.example.app.application  (usecase, service, port.in/out)
 │   ├─ com.example.app.domain       (entity, value, domain service)
 │   └─ com.example.app.infrastructure (jpa, http, fs adapters)
 └─ test/java
     ├─ unit (도메인/애플리케이션 + Fake/Stub)
     ├─ integration (어댑터 + Testcontainers/WireMock)
     └─ e2e (희소)
```

---

## 18. 마무리

테스트 가능한 OOP는 결과가 아니라 **설계 과정**이다.
도메인을 깨끗이 유지하고(포트·어댑터), 시간·랜덤·I/O를 경계 밖으로 밀어내며, 작은 책임과 불변/순수 함수를 채택하라.
그렇게 하면 테스트는 **부담**이 아니라 **설계 품질의 증거**가 된다. 오늘 한 곳의 경계를 추상화하는 것만으로도 내일의 변경 비용을 크게 줄일 수 있다.
