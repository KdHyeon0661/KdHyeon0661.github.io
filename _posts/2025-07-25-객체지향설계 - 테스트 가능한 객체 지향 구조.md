---
layout: post
title: 객체지향설계 - 테스트 가능한 객체 지향 구조
date: 2025-07-25 19:20:23 +0900
category: 객체지향설계
---
# 테스트 가능한 객체 지향 구조 (Designing Testable OOP)

테스트 가능한 객체 지향 구조는 **설계 단계에서부터 테스트 용이성(Testability)을 고려한 구조**를 말합니다.  
아래는 핵심 원칙·아키텍처·기법과 실전 예제(코드 + 테스트)·체크리스트를 한데 모은 가이드입니다. 바로 블로그에 붙여 쓰기 좋게 정리했어요.

---

## 1. 핵심 아이디어 요약
- **작은 단위로 설계**: 클래스/메서드는 단일 책임(SRP)을 지키고 작게 만들어 단위 테스트가 쉽도록 한다.  
- **의존성 추상화**: 구현이 아닌 인터페이스(추상)에 의존하여 교체 가능한 테스트 더블을 주입한다 (DIP).  
- **사이드 이펙트 분리**: I/O, DB, 네트워크 등 부작용은 도메인 로직에서 분리하고 어댑터로 캡슐화한다.  
- **순수 함수·불변성**: 가능한 한 순수 함수와 불변 객체를 사용하면 단위 테스트가 단순하고 결정적이다.  
- **경계(Seams) 만들기**: 테스트할 지점과 교체 가능한 지점을 설계상 분명히 만든다.

---

## 2. 설계 원칙 (테스트 용 관점)
- **SRP(단일 책임)**: 각 클래스는 하나의 책임. 테스트 범위를 좁힐 수 있음.  
- **DIP(의존 역전)**: 상위 모듈이 하위 모듈에 직접 의존하지 않도록 인터페이스 사용 → 목/페이크 주입 가능.  
- **ISP(인터페이스 분리)**: 필요한 메서드만 가진 작은 인터페이스로 테스트가 쉬움.  
- **High Cohesion / Low Coupling**: 응집도가 높고 결합도 낮으면 단위 테스트 독립성 증가.  
- **작은 메서드·순수 함수 권장**: 부작용이 적을수록 테스트가 단순.

---

## 3. 아키텍처 패턴 (테스트 친화적)
- **Ports & Adapters / Hexagonal**: 도메인 중심으로 포트(인터페이스)를 두고 인프라를 어댑터로 구현 → 단위 테스트는 포트에 테스트 더블을 주입.  
- **Onion / Clean Architecture**: 도메인이 중앙, 인프라는 바깥쪽 → 도메인 테스트가 외부 영향 없이 가능.  
- **Layered (계층형)**: Presentation / Application / Domain / Infrastructure로 분리, 도메인 테스트는 Infrastructure 없이 가능.

---

## 4. 테스트 더블과 용도
- **Dummy**: 매개변수 채우기용, 사용되지 않는 인자.  
- **Stub**: 특정 입력에 대해 고정 응답 제공(상태 제어).  
- **Fake**: 단순 구현체(예: InMemoryRepository) — 진짜보다 가벼운 구현.  
- **Spy**: 실제 객체를 사용하되 호출 기록을 검사.  
- **Mock**: 기대 동작과 상호작용을 검증(행위 기반 테스트).

> 일반 원칙: 도메인 로직은 **Fake** 또는 **Real**에 가까운 테스트로 검증하고, 외부 통신/상호작용은 **Mock**으로 검증해 병립한다.

---

## 5. 구현 기법 (구체적 권장 사항)

### 생성자 주입(Constructor Injection)
- 테스트에서 의존성(인터페이스)을 쉽게 주입할 수 있도록 생성자 인자로 받는다.

### 팩토리/빌더 사용
- 복잡한 객체 생성은 빌더로 캡슐화 → 테스트용 빌더(Test Data Builder)로 가독성 높임.

### 상태 분리 & 트랜잭션 경계
- 트랜잭션 경계는 애플리케이션 레이어에 두고 도메인은 순수 비즈니스 규칙만 가지게 한다.

### 외부 의존성 격리
- DB, 메시지, 파일시스템, 시간(Clock) 등은 추상화된 포트로 래핑하여 테스트에서 대체.

### 불변 객체(Value Object)
- `Money`, `Address` 등은 불변으로 구현해 동등성/테스트가 쉬움.

### 피해야 할 것들
- 정적(singleton) 전역 상태: 테스트 간 간섭과 플라키 테스트 유발.  
- 복잡한 초기화 로직을 생성자에 두는 것: 테스트에서 설정이 어려워짐.

---

## 6. 테스트 전략 (단계별)
1. **단위 테스트(Unit Tests)**: 순수 로직/메서드 수준—Mock/Stub 이용.  
2. **통합 테스트(Integration Tests)**: 여러 모듈 통합, 실제 DB 대신 인메모리 혹은 Testcontainers 사용.  
3. **계약 테스트(Contract Tests)**: 외부 서비스와의 인터페이스 보장 (Pact 등).  
4. **E2E(End-to-End)**: 전체 플로우 검증 (슬로우).  
5. **속도와 안정성 균형**: CI는 빠른 단위/통합 테스트 중심, E2E는 적당히.

---

## 7. 실전 예제 — Java로 보여주는 테스트 가능한 구조

### 1) 도메인 인터페이스와 서비스
```java
// 포트(Repository 인터페이스)
public interface AccountRepository {
    Optional<BankAccount> findById(String accountId);
    void save(BankAccount account);
}

// 도메인 엔티티 (간단)
public class BankAccount {
    private final String id;
    private long balanceCents;

    public BankAccount(String id, long initialCents) {
        this.id = id;
        this.balanceCents = initialCents;
    }

    public void withdraw(long cents) {
        if (cents <= 0) throw new IllegalArgumentException("amount>0");
        if (balanceCents < cents) throw new IllegalStateException("insufficient");
        balanceCents -= cents;
    }

    public void deposit(long cents) {
        if (cents <= 0) throw new IllegalArgumentException("amount>0");
        balanceCents += cents;
    }

    public long getBalanceCents() { return balanceCents; }
}
```

### 2) 애플리케이션 서비스 (생성자 주입)
```java
public class AccountService {
    private final AccountRepository repo;

    public AccountService(AccountRepository repo) {
        this.repo = repo;
    }

    public void transfer(String fromId, String toId, long cents) {
        BankAccount from = repo.findById(fromId).orElseThrow();
        BankAccount to   = repo.findById(toId).orElseThrow();

        from.withdraw(cents);
        to.deposit(cents);

        repo.save(from);
        repo.save(to);
    }
}
```

### 3) 테스트용 Fake Repository (단위/통합 중간)
```java
public class InMemoryAccountRepository implements AccountRepository {
    private final Map<String, BankAccount> store = new ConcurrentHashMap<>();
    public Optional<BankAccount> findById(String accountId) {
        return Optional.ofNullable(store.get(accountId));
    }
    public void save(BankAccount account) {
        store.put(account.id, account);
    }
    // 테스트 편의 메서드
    public void add(BankAccount account) { store.put(account.id, account); }
}
```

### 4) 단위 테스트 예 (JUnit 5, Mockito 대체로 Fake 사용)
```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class AccountServiceTest {
    @Test
    void transferReducesAndIncreasesBalance() {
        InMemoryAccountRepository repo = new InMemoryAccountRepository();
        repo.add(new BankAccount("A", 10_00)); // $10.00
        repo.add(new BankAccount("B", 5_00));  // $5.00

        AccountService service = new AccountService(repo);
        service.transfer("A", "B", 3_00); // transfer $3

        assertEquals(7_00, repo.findById("A").get().getBalanceCents());
        assertEquals(8_00, repo.findById("B").get().getBalanceCents());
    }
}
```

### 5) 행위 검증(Interaction) 예 — Mockito
```java
// Mockito 사용 시 예시 (의존성 주입 후 repo.save 호출 확인)
@Test
void transferCallsSaveTwice() {
    AccountRepository mockRepo = Mockito.mock(AccountRepository.class);
    BankAccount a = new BankAccount("A", 1000);
    BankAccount b = new BankAccount("B", 500);
    Mockito.when(mockRepo.findById("A")).thenReturn(Optional.of(a));
    Mockito.when(mockRepo.findById("B")).thenReturn(Optional.of(b));

    AccountService service = new AccountService(mockRepo);
    service.transfer("A", "B", 300);

    Mockito.verify(mockRepo, Mockito.times(1)).save(a);
    Mockito.verify(mockRepo, Mockito.times(1)).save(b);
}
```

---

## 8. Test Data Patterns
- **Test Data Builder**: 테스트 가독성 향상, 복잡한 객체 생성 간소화.  
- **Object Mother**: 공통 테스트 객체 팩토리(테스트 유지보수 이점/단점 있음).  
- **Fixtures**: 반복 데이터 세트, 그러나 공유로 플라키함 주의.

---

## 9. CI/테스트 품질 관리
- **빠른 단위 테스트**는 PR에서 필수. 느린 통합/인수 테스트는 별 파이프라인으로.  
- **병렬 실행** 지원: 테스트 독립성 보장 필수.  
- **테스트 격리(테스트 독립성)**: 각 테스트는 서로 상태를 공유하지 않아야 함.  
- **플라키 테스트 제거**: 비결정적인 테스트는 신뢰도와 개발 속도를 저하시킴.  
- **Code Coverage**: 목표는 100%가 아니라 중요한 부분의 적절한 커버리지.  
- **Mutation Testing**: 테스트의 효과를 더 엄밀히 검증(필요 시).

---

## 10. 흔한 안티패턴과 해결책
- **전역 상태/싱글톤** → 테스트 격리 어려움. 해결: 인스턴스 주입, 테스트 전 초기화/정리.  
- **정적 메서드(광범위 사용)** → 목킹 불가/어려움. 해결: 래핑(인터페이스로 추상화).  
- **무거운 생성자 로직** → 테스트 준비 복잡. 해결: 팩토리/빌더 또는 팩토리 주입.  
- **느슨한 경계(도메인과 인프라 혼합)** → 단위 테스트 불가. 해결: 포트/어댑터로 분리.

---

## 11. 실무 팁 요약 체크리스트
- [ ] 생성자 주입을 사용하고 있는가?  
- [ ] 외부 I/O는 인터페이스로 추상화되어 있는가?  
- [ ] 핵심 비즈니스 로직은 외부 의존성 없이 실행 가능한가?  
- [ ] 테스트 더블(Fake/Stub/Mock)을 쉽게 만들 수 있는가?  
- [ ] 정적/전역 상태가 테스트를 방해하지 않는가?  
- [ ] Test Data Builder로 테스트 코드 가독성을 확보했는가?  
- [ ] 단위 테스트는 빠르고 결정적인가? (No network/DB)  
- [ ] 통합 테스트는 별도의 파이프라인/환경에서 안정적으로 실행되는가?

---

## 12. 결론
테스트 가능한 객체 지향 구조는 단순히 “테스트를 잘 작성하는” 것을 넘어서 **설계의 질 자체를 높이는 활동**입니다.  
초기 설계에서 **의존성 추상화, 경계 분리, 작은 단위 책임**을 적용하면 테스트가 쉬워지고, 결과적으로 코드의 변경·확장도 훨씬 안전해집니다.  
작은 개선(예: 생성자 주입 하나 적용)도 테스트 난이도를 크게 낮추니 단계적으로 적용해보세요.