---
layout: post
title: MFC - 시리얼 포트 터미널
date: 2025-09-17 20:25:23 +0900
category: MFC
---
# “시리얼 포트 터미널” — 백그라운드 스레드, 안전한 I/O, 로그 롤링까지 (MFC/Win32 실전)

> 목표: **COMx 오픈/설정(baud/bit/parity/flow)** → **백그라운드 수신 스레드(Overlapped I/O)** → **UI는 PostMessage로 비동기 갱신** → **송신 큐/이력** → **로그 롤링(일자/크기)** → **안전 종료/복구**.  
> 도구: **Win32 시리얼 API(CreateFile/SetupComm/SetCommState/WaitCommEvent/ReadFile/WriteFile)**, **OVERLAPPED I/O**, **MFC Dialog/SDI**.  
> 포커스: “프레임 드롭 없이 **끊김 없는 수신**”, “**UI 프리징 0**”, “**로그 파일 손상 0**”.

---

## 0) 완성 UX

- **좌측 상단**: COM 포트 선택(COM1..), Baud(9600 ~ 921600), DataBits(7/8), Parity(N/E/O), StopBits(1/2), Flow(None/RTSCTS/XONXOFF)  
- **연결/해제** 버튼, **DTR/RTS 토글**  
- **수신 창**: 텍스트/HEX 뷰 토글, 타임스탬프 옵션  
- **송신 박스**: ASCII/HEX 입력, Enter→전송, “CR/LF” 옵션  
- **로그**: 파일 경로/롤링 조건(최대 크기 MB 또는 일자) 설정, “지금 롤링” 버튼  
- 상태바: RX/TX 카운터, CTS/DSR/DCD/RI 표기(변경 시 반짝)

---

## 1) 프로젝트 뼈대(대화상자 기반 MFC 권장)

- MFC App Wizard → **Dialog** + **유니코드** + **공유 MFC(/MD)**  
- 리소스: `IDD_TERMINAL`(콤보/에딧/리스트), `IDC_COMBO_PORT`, `IDC_COMBO_BAUD`, `IDC_BTN_CONNECT`, `IDC_EDIT_RX`, `IDC_EDIT_TX` 등  
- 문자열은 UTF-16, 실제 전송 인코딩은 “직접 바이트” 혹은 “선택(UTF-8/ANSI)” 옵션으로 처리

---

## 2) COM 장치 열기/설정 — 꼼꼼한 초기화

### 2-1. 포트 이름 주의
- COM1~COM9: `"COM1"` OK  
- COM10 이상: `"\\\\.\\COM10"` 식으로 **접두사 필요**

### 2-2. 디바이스 열기 & 버퍼
```cpp
struct SerialPort {
    HANDLE h = INVALID_HANDLE_VALUE;
    DCB dcb{};
    COMMTIMEOUTS to{};
    DWORD evtMask = EV_RXCHAR | EV_ERR; // 기본은 RX 수신/에러
};

bool OpenSerial(SerialPort& sp, const std::wstring& port) {
    std::wstring path = (port.size()>4 ? L"\\\\.\\" + port : port);
    sp.h = CreateFileW(path.c_str(), GENERIC_READ|GENERIC_WRITE, 0, nullptr,
                       OPEN_EXISTING, FILE_FLAG_OVERLAPPED, nullptr);
    if (sp.h == INVALID_HANDLE_VALUE) return false;

    SetupComm(sp.h, 1<<20, 1<<20); // 드라이버 버퍼 힌트(1MB)

    sp.dcb.DCBlength = sizeof(DCB);
    GetCommState(sp.h, &sp.dcb);
    // 기본: 115200 8N1, 하드웨어/소프트웨어 플로우 OFF
    sp.dcb.BaudRate = CBR_115200;
    sp.dcb.ByteSize = 8;
    sp.dcb.Parity   = NOPARITY;
    sp.dcb.StopBits = ONESTOPBIT;

    sp.dcb.fOutxCtsFlow = FALSE;
    sp.dcb.fRtsControl  = RTS_CONTROL_DISABLE;
    sp.dcb.fInX = sp.dcb.fOutX = FALSE;

    if (!SetCommState(sp.h, &sp.dcb)) { CloseHandle(sp.h); sp.h=INVALID_HANDLE_VALUE; return false; }

    sp.to.ReadIntervalTimeout         = 1;
    sp.to.ReadTotalTimeoutConstant    = 0;
    sp.to.ReadTotalTimeoutMultiplier  = 0;
    sp.to.WriteTotalTimeoutConstant   = 1000;
    sp.to.WriteTotalTimeoutMultiplier = 10;
    SetCommTimeouts(sp.h, &sp.to);

    // 통지 마스크
    SetCommMask(sp.h, sp.evtMask);
    PurgeComm(sp.h, PURGE_RXCLEAR|PURGE_TXCLEAR|PURGE_RXABORT|PURGE_TXABORT);
    EscapeCommFunction(sp.h, SETDTR); // 옵션: 연결 시 DTR 활성화

    return true;
}
```

### 2-3. 파라미터 바꾸기(런타임)
```cpp
bool Configure(SerialPort& sp, DWORD baud, BYTE databits, BYTE parity, BYTE stop, int flow) {
    sp.dcb.BaudRate = baud;
    sp.dcb.ByteSize = databits;
    sp.dcb.Parity   = parity;   // NOPARITY, EVENPARITY, ODDPARITY
    sp.dcb.StopBits = stop;     // ONESTOPBIT, TWOSTOPBITS

    // Flow
    if (flow==0) { // None
        sp.dcb.fOutxCtsFlow = FALSE; sp.dcb.fRtsControl = RTS_CONTROL_DISABLE;
        sp.dcb.fInX=sp.dcb.fOutX=FALSE;
    } else if (flow==1) { // RTS/CTS
        sp.dcb.fOutxCtsFlow = TRUE;  sp.dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
        sp.dcb.fInX=sp.dcb.fOutX=FALSE;
    } else { // XON/XOFF
        sp.dcb.fOutxCtsFlow = FALSE; sp.dcb.fRtsControl = RTS_CONTROL_DISABLE;
        sp.dcb.fInX=sp.dcb.fOutX=TRUE;
        sp.dcb.XonChar = 0x11; sp.dcb.XoffChar = 0x13;
        sp.dcb.XonLim = 1024; sp.dcb.XoffLim = 512;
    }

    return !!SetCommState(sp.h, &sp.dcb);
}
```

---

## 3) 백그라운드 수신 — Overlapped I/O + Worker Thread

**핵심 원칙**  
- 포트 I/O는 **UI 스레드 금지** → Worker 스레드에서 `WaitCommEvent` / `ReadFile`  
- UI 갱신은 `PostMessage(WM_APP_RX, ...)` 로 전달(데이터는 고정 버퍼/큐)  
- 종료 시 **CancelIoEx** + 스레드 조인

### 3-1. 메시지 정의
```cpp
constexpr UINT WM_APP_RX = WM_APP + 1; // 수신 도착
constexpr UINT WM_APP_EV = WM_APP + 2; // 통제선/에러 이벤트
```

### 3-2. Lock-free-ish 링버퍼(간단)
> 실제로는 **MPSC 큐**나 `std::deque + critical section`도 충분. 여기선 쉬운 CS+벡터.

```cpp
class RxBuffer {
    CRITICAL_SECTION cs{};
    std::vector<BYTE> buf;
public:
    RxBuffer(){ InitializeCriticalSection(&cs); }
    ~RxBuffer(){ DeleteCriticalSection(&cs); }
    void Push(const BYTE* p, size_t n){
        EnterCriticalSection(&cs); buf.insert(buf.end(), p, p+n); LeaveCriticalSection(&cs);
    }
    size_t PopSome(std::vector<BYTE>& out, size_t max = 65536){
        EnterCriticalSection(&cs);
        size_t n = min(max, buf.size());
        out.assign(buf.begin(), buf.begin()+n);
        buf.erase(buf.begin(), buf.begin()+n);
        LeaveCriticalSection(&cs);
        return n;
    }
    size_t Size(){ EnterCriticalSection(&cs); size_t s=buf.size(); LeaveCriticalSection(&cs); return s; }
};
```

### 3-3. 수신 스레드 루프
```cpp
struct SerialRuntime {
    SerialPort sp;
    HANDLE hStop = CreateEvent(nullptr, TRUE, FALSE, nullptr);
    HANDLE hThread = nullptr;
    RxBuffer rx;
    std::atomic<uint64_t> rxCount{0}, txCount{0};
};

DWORD WINAPI RxThreadProc(LPVOID pParam) {
    auto rt = (SerialRuntime*)pParam;
    OVERLAPPED ovWait{}; ovWait.hEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
    OVERLAPPED ovRead{}; ovRead.hEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);

    BYTE tmp[64*1024];

    while (WaitForSingleObject(rt->hStop, 0) == WAIT_TIMEOUT) {
        // 이벤트 대기(수신/에러/모뎀)
        DWORD evt=0;
        ResetEvent(ovWait.hEvent);
        if (!WaitCommEvent(rt->sp.h, &evt, &ovWait)) {
            if (GetLastError()!=ERROR_IO_PENDING) break;
            HANDLE hs[2]{ ovWait.hEvent, rt->hStop };
            DWORD w = WaitForMultipleObjects(2, hs, FALSE, INFINITE);
            if (w==WAIT_OBJECT_0+1) break; // stop
            GetOverlappedResult(rt->sp.h, &ovWait, &evt, FALSE);
        }

        if (evt & EV_RXCHAR) {
            // 있을 때까지 계속 읽기
            for(;;){
                DWORD got=0;
                ResetEvent(ovRead.hEvent);
                if (!ReadFile(rt->sp.h, tmp, sizeof(tmp), &got, &ovRead)) {
                    DWORD e = GetLastError();
                    if (e==ERROR_IO_PENDING) {
                        HANDLE hs[2]{ ovRead.hEvent, rt->hStop };
                        DWORD w = WaitForMultipleObjects(2, hs, FALSE, 200);
                        if (w==WAIT_OBJECT_0+1) break; // stop
                        if (!GetOverlappedResult(rt->sp.h, &ovRead, &got, FALSE)) break;
                    } else break;
                }
                if (got==0) break;
                rt->rx.Push(tmp, got);
                rt->rxCount += got;
                // UI 알림
                PostMessage(AfxGetMainWnd()->GetSafeHwnd(), WM_APP_RX, 0, 0);
                // 버퍼에 더 있을 수 있으니 루프 지속
                if (got < sizeof(tmp)) break;
            }
        }
        if (evt & (EV_CTS|EV_DSR|EV_RLSD|EV_RING|EV_ERR|EV_BREAK)) {
            PostMessage(AfxGetMainWnd()->GetSafeHwnd(), WM_APP_EV, evt, 0);
        }
    }

    CancelIoEx(rt->sp.h, &ovRead);
    CancelIoEx(rt->sp.h, &ovWait);
    CloseHandle(ovRead.hEvent);
    CloseHandle(ovWait.hEvent);
    return 0;
}
```

> **EV 마스크 확장**  
> `EV_CTS|EV_DSR|EV_RLSD|EV_RING|EV_ERR|EV_BREAK|EV_TXEMPTY` 등 필요 시 추가 → `SetCommMask`

### 3-4. 시작/정지
```cpp
bool StartIo(SerialRuntime& rt) {
    if (rt.hThread) return true;
    ResetEvent(rt.hStop);
    rt.hThread = CreateThread(nullptr, 0, RxThreadProc, &rt, 0, nullptr);
    return rt.hThread!=nullptr;
}
void StopIo(SerialRuntime& rt) {
    if (!rt.hThread) return;
    SetEvent(rt.hStop);
    CancelIoEx(rt.sp.h, nullptr);
    WaitForSingleObject(rt.hThread, INFINITE);
    CloseHandle(rt.hThread); rt.hThread=nullptr;
}
```

---

## 4) UI ← 수신 데이터 전달 — PostMessage & 배치 처리

**핵심**: `WM_APP_RX` 들어오면 **가능한 큰 청크**로 Pop → Text/HEX로 변환 → 에디트/리치에 Append.

```cpp
// CTerminalDlg 멤버
SerialRuntime m_rt;
CEdit m_editRx; bool m_hexView=false; bool m_ts=false;

afx_msg LRESULT OnRx(WPARAM, LPARAM) {
    std::vector<BYTE> chunk;
    size_t n = m_rt.rx.PopSome(chunk, 128*1024);
    if (!n) return 0;

    CStringW line;
    if (m_ts) {
        SYSTEMTIME st; GetLocalTime(&st);
        line.Format(L"[%02d:%02d:%02d.%03d] ",st.wHour,st.wMinute,st.wSecond,st.wMilliseconds);
        m_editRx.ReplaceSel(line);
    }

    if (!m_hexView) {
        // 가볍게 인쇄 가능한 범위만(혹은 설정에 따라)
        std::wstring s; s.reserve(n);
        for (auto b: chunk) s.push_back((b>=0x20||b==0x0A||b==0x0D)? (wchar_t)b : L'.');
        m_editRx.ReplaceSel(s.c_str());
    } else {
        // HEX: 16바이트/줄
        CStringW hex;
        for(size_t i=0;i<n;i++){
            if (i%16==0){ hex += L"\r\n"; }
            CStringW t; t.Format(L"%02X ", chunk[i]);
            hex += t;
        }
        m_editRx.ReplaceSel(hex);
    }

    // 자동 스크롤
    m_editRx.LineScroll(m_editRx.GetLineCount());
    // 로그에 쓰기(아래 5장)
    AppendLog(chunk.data(), chunk.size());
    return 0;
}
```

> 큰 RX를 **여러 번** PostMessage 받는 것보단, 하나 받을 때 **링버퍼에서 최대치**를 꺼내 **일괄 처리**가 효율적.

---

## 5) 로그 롤링 — 크기/일자 기준 + 원자적 교체

### 5-1. 설계
- 파일: `%LOCALAPPDATA%\Vendor\SerialTerm\logs\YYYYMMDD.log`  
- **크기 롤링**: N MB 넘으면 `YYYYMMDD-HHMMSS.log`로 **회전**  
- 쓰기: `WriteFile` **버퍼링**(own buffer) + **Flush 조건**(주기/라인 끝/버튼)  
- **손상 방지**: 쓰는 중 크래시 대비 `FILE_FLAG_WRITE_THROUGH` 옵션(선택) 또는 주기적 Flush

### 5-2. 구현 스니펫
```cpp
class LogWriter {
    HANDLE h = INVALID_HANDLE_VALUE;
    std::wstring dir, curName;
    uint64_t curSize = 0;
    uint64_t maxBytes = 50ull*1024*1024; // 50MB
public:
    bool OpenToday(const std::wstring& root) {
        dir = root;
        CreateDirectoryW(dir.c_str(), nullptr);
        SYSTEMTIME st; GetLocalTime(&st);
        wchar_t name[64]; swprintf_s(name, L"%04d%02d%02d.log", st.wYear, st.wMonth, st.wDay);
        curName = dir + L"\\" + name;
        h = CreateFileW(curName.c_str(), FILE_APPEND_DATA, FILE_SHARE_READ, nullptr,
                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
        if (h==INVALID_HANDLE_VALUE) return false;
        LARGE_INTEGER li; GetFileSizeEx(h,&li); curSize = (uint64_t)li.QuadPart;
        return true;
    }
    void Close(){ if(h!=INVALID_HANDLE_VALUE){ CloseHandle(h); h=INVALID_HANDLE_VALUE; } }
    ~LogWriter(){ Close(); }

    void RollNow() {
        if (h==INVALID_HANDLE_VALUE) return;
        Close();
        SYSTEMTIME st; GetLocalTime(&st);
        wchar_t name[64]; swprintf_s(name, L"%04d%02d%02d-%02d%02d%02d.log",
                                     st.wYear,st.wMonth,st.wDay,st.wHour,st.wMinute,st.wSecond);
        std::wstring newName = dir + L"\\" + name;
        MoveFileW(curName.c_str(), newName.c_str());
        OpenToday(dir);
        curSize=0;
    }

    void Append(const BYTE* p, size_t n) {
        if (h==INVALID_HANDLE_VALUE) return;
        DWORD w=0; WriteFile(h, p, (DWORD)n, &w, nullptr);
        curSize += w;
        if (curSize >= maxBytes) RollNow();
    }
};
```

```cpp
// 사용
LogWriter g_log;
bool InitLog() {
    std::wstring root = GetLocalAppDataPath() + L"\\SerialTerm\\logs";
    return g_log.OpenToday(root);
}
void AppendLog(const BYTE* p, size_t n){ g_log.Append(p,n); }
```

> **일자 롤링**은 `WM_TIMER`로 자정 인접 시 `OpenToday` 재호출 또는 날짜 변경 감지로 처리.

---

## 6) 송신 — UI 스레드에서 안전하게 Write (큐/백프레셔)

- 간단: `WriteFile`(OVERLAPPED) + `GetOverlappedResult`  
- 고속/대용량 송신 시 **TX 큐**(lock + vector) 두고 **송신 스레드**가 배출 (수신 스레드와 별개)  
- 여기서는 간단 버전만.

```cpp
bool WriteSerial(SerialRuntime& rt, const BYTE* p, size_t n) {
    OVERLAPPED ov{}; ov.hEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
    DWORD written=0;
    bool ok=true;
    if (!WriteFile(rt.sp.h, p, (DWORD)n, &written, &ov)) {
        if (GetLastError()==ERROR_IO_PENDING) {
            if (!GetOverlappedResult(rt.sp.h, &ov, &written, TRUE)) ok=false;
        } else ok=false;
    }
    CloseHandle(ov.hEvent);
    rt.txCount += written;
    return ok && (written==n);
}
```

### 6-1. ASCII/HEX 입력 처리
```cpp
void CTerminalDlg::OnSend() {
    CStringW s; m_editTx.GetWindowTextW(s);
    std::vector<BYTE> out;
    if (m_sendHex) {
        // “41 42 0D 0A” → bytes
        ParseHex(s, out);
    } else {
        // UTF-8로 전송(옵션) 또는 ANSI 코드페이지
        auto u8 = WStringToUtf8(s.GetString());
        out.assign(u8.begin(), u8.end());
        if (m_crlf) { out.push_back('\r'); out.push_back('\n'); }
        else if (m_cr) out.push_back('\r');
        else if (m_lf) out.push_back('\n');
    }
    WriteSerial(m_rt, out.data(), out.size());
}
```

---

## 7) 제어선/플로우/에러 — 상태 읽기 & 반응

### 7-1. 모뎀 상태
```cpp
DWORD ms=0; GetCommModemStatus(m_rt.sp.h, &ms);
bool CTS = (ms & MS_CTS_ON)!=0;
bool DSR = (ms & MS_DSR_ON)!=0;
bool DCD = (ms & MS_RLSD_ON)!=0; // DCD=RLSD
bool RI  = (ms & MS_RING_ON)!=0;
```
- EV 마스크에 `EV_CTS|EV_DSR|EV_RLSD|EV_RING` 추가 시 변화 알림을 **EV 이벤트**로 수신

### 7-2. 에러
```cpp
DWORD errs=0; COMSTAT st{};
ClearCommError(m_rt.sp.h, &errs, &st);
// errs: CE_FRAME/CE_OVERRUN/CE_RXPARITY/CE_BREAK 등
```
- 에러 발생 시 **로그에 기록** + **상태 아이콘**으로 표시

### 7-3. RTS/DTR 수동 제어
```cpp
void SetRTS(HANDLE h, bool on){ EscapeCommFunction(h, on? SETRTS : CLRRTS); }
void SetDTR(HANDLE h, bool on){ EscapeCommFunction(h, on? SETDTR : CLRDTR); }
```

---

## 8) 종료/에러 복구 — 안전 시퀀스

1) **해제 버튼** 클릭 → **송수신 중단**  
2) `StopIo` → `CancelIoEx` → 스레드 조인  
3) `CloseHandle` 포트  
4) UI 비활성/카운터 0 유지  
5) 로그 Close (파일 핸들은 유지해도 무방)

**예외 상황**  
- 케이블 뽑힘/장치 전원 OFF: ReadFile/WaitCommEvent **에러** → 스레드 탈출  
- UI에 “연결 끊김” 표시, 재연결 가능 상태로 전환

---

## 9) 설정 저장(레지스트리/JSON)

- **마지막 포트/baud/파라미터**와 **뷰 옵션**을 `%APPDATA%` JSON 또는 HKCU 레지스트리에 보존  
- 재실행 시 자동 복원

```cpp
struct Settings {
    std::wstring lastPort=L"COM3";
    DWORD baud=115200; int databits=8; int parity=0; int stopbits=1; int flow=0;
    bool hexView=false; bool ts=false;
    uint64_t maxLogMB=50;
};
```

---

## 10) 성능/안정성 팁

- **큰 수신 부하**: 드라이버 RX 버퍼(SetupComm) 크게, 우리 링버퍼도 크게  
- **UI 업데이트 빈도 제한**: `WM_APP_RX`마다 바로 Append 하지 말고 **타이머 30~60Hz**로 합치기(옵션).  
- **고속 전송**(>1Mbps): 텍스트 렌더링 비용 ↑ → **HEX/텍스트 뷰 버퍼에만 쌓아 두고 스냅샷 렌더**  
- **시간동기**: 타임스탬프는 UI에서 찍되, 정확도가 필요하면 스레드에서 `QueryPerformanceCounter`로 마킹 후 함께 전송

---

## 11) 테스트 시나리오

- [ ] Loopback 테스트(TX→RX 점퍼)에서 1/5/10 Mbps까지 드롭 없는지  
- [ ] 케이블 뽑기/연결 재시 → 에러 복구  
- [ ] CTS/DSR/DCD/RI 변화 감지  
- [ ] 로그 롤링: 크기/자정, 손상 없이 파일 열기 가능  
- [ ] HEX/ASCII 변환 정확성, EOL 옵션(CR/LF/CRLF)  
- [ ] 장시간(>24h) 운용, 메모리 누수 0

---

## 12) 전체 조립 예(요약)

```cpp
// CTerminalDlg::OnInitDialog
InitLog();
PopulatePorts(); PopulateBaud(); // Setup UI
// Connect
void CTerminalDlg::OnBnClickedConnect(){
    if (!m_connected){
        if (!OpenSerial(m_rt.sp, m_port)) { AfxMessageBox(L"Open 실패"); return; }
        Configure(m_rt.sp, m_baud, m_bits, m_parity, m_stop, m_flow);
        if (!StartIo(m_rt)) { AfxMessageBox(L"I/O 시작 실패"); return; }
        m_connected=true; UpdateUiConnected(true);
    } else {
        StopIo(m_rt); CloseHandle(m_rt.sp.h); m_rt.sp.h=INVALID_HANDLE_VALUE;
        m_connected=false; UpdateUiConnected(false);
    }
}
```

---

## 13) 고급: TX 스레드/속도 제어, 캡처 스크립트

- **TX 별도 스레드**: 긴 파일 전송 시 사용자 UI 반응성 유지, XON/XOFF 수신 기반 **rate control**  
- **매크로/스크립트**: 정해진 명령 시퀀스 반복, 응답 패턴 인식 → 자동화 테스트

---

## 14) 문제 해결 가이드

- **WriteFile 블로킹**: 플로우 제어/버퍼 Full → OVERLAPPED로 전환, `GetOverlappedResult` 시간 제한  
- **수신 누락**: 드라이버 버퍼 부족 / WaitCommEvent 마스크 누락 / 링버퍼 Pop 타이밍 → 버퍼 확장/마스크 점검  
- **한글 깨짐**: 실제 장치 인코딩(UTF-8? CP949?) 확인 → 송신 인코딩 옵션 제공  
- **COMx 안 보임**: 가상 COM 드라이버 문제 → 장치관리자 확인, `SetupDiEnumDeviceInfo`로 나열 구현

---

## 15) 보안/권한

- 시리얼은 일반 권한으로 충분. 단, **UAC 경계**(관리자/일반) 다른 앱과 SendInput 섞어 쓰지 않음  
- 로그에 **민감 데이터**가 포함될 수 있음 → 기본 **로컬 저장 + 삭제 메뉴** 제공

---

## 16) 확장 아이디어

- **스코프 모드**: 수신 바이트를 파형/주기/지터로 시각화  
- **프로토콜 디코더**: MODBUS/SLIP/NMEA 등 플러그인  
- **검색/하이라이트**: 수신 창에서 정규식 매칭 색상 표시  
- **CSV/PCAPNG** 내보내기: 타 툴과 연동

---

## 17) 체크리스트(요약)

- [ ] Overlapped I/O + Worker Thread, UI는 PostMessage  
- [ ] 링버퍼/큐로 **무손실 수신**  
- [ ] 로그 롤링(크기/일자) + 원자적 쓰기  
- [ ] 플로우 제어(RTS/CTS, XON/XOFF) 옵션  
- [ ] 종료 시 CancelIoEx → 스레드 조인 → 핸들 정리  
- [ ] 대용량/장시간 테스트 OK

---

### 마무리
이 설계/코드 스니펫을 그대로 조립하면 **가볍고 안정적인 시리얼 터미널**을 바로 띄울 수 있습니다.  
가장 중요한 것은 **I/O는 백그라운드**, **UI는 비동기**, **로그는 안전하고 가볍게**—이 세 가지 축입니다.  