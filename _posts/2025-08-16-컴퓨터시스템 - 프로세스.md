---
layout: post
title: 컴퓨터시스템 - 프로세스
date: 2025-08-16 14:20:23 +0900
category: 컴퓨터시스템
---
# 프로세스(Process)

> **핵심 관점**
> - 프로그램은 **정적 객체**(파일), 프로세스는 **동적 객체**(실행 중 인스턴스).
> - 커널은 프로세스에 **CPU 시간**, **주소 공간**, **핸들(FD)**, **보안 컨텍스트**, **자원 한도**, **스케줄링 정책**을 부여한다.

---

## 1. 프로세스 vs 프로그램: 무엇이 다른가

| 구분 | 프로그램(파일) | 프로세스(실행 인스턴스) |
|---|---|---|
| 본질 | 디스크의 ELF/PE 등 바이너리 | 메모리·커널 오브젝트의 집합 |
| 상태 | 불변(파일이 바뀌기 전까진) | New/Ready/Running/Blocked/Zombie/Terminated |
| 위치 | 파일시스템 | RAM + 커널 내부 자료구조(task_struct 등) |
| 복수 실행 | 파일 1개라도 다수 동시 실행 가능 | 각자 PID, 주소공간, 핸들, 스케줄 상태 |
| 수급 자원 | 없음 | CPU 시간, 가상주소공간, FD, 크레덴셜, cgroup 등 |

예) `/bin/ls`는 **프로그램**. 터미널에서 `ls`를 실행하면 커널이 메모리에 적재·스케줄하고 **프로세스**가 된다.

---

## 2. 프로세스가 가진 것(논리적 메모리 지도 + 커널 자료구조)

### 2.1 주소 공간 레이아웃(일반적 x86-64, ASLR 단순화)
```
낮은 주소
| 코드(text, r-x)     |
| 데이터(data, rw-)   |
| BSS(bss, rw-)       |
| 힙(heap, ↑)         |
| mmap 영역(공유 lib, 파일매핑, 익명매핑) |
| 스택(stack, ↓)      |
높은 주소
```
- **W^X** 정책: 동일 페이지에 쓰기·실행 동시 금지, **NX 비트**로 데이터 실행 방지.
- **ASLR**로 코드/힙/스택/라이브러리 시작점 무작위화.

### 2.2 커널 내부 핵심 구조(리눅스)
- `task_struct`: 스케줄링·상태·크레덴셜·시그널·타이머 등 **스레드/프로세스 제어 블록(PCB)** 역할.
- `mm_struct`: 주소 공간(페이지 테이블 루트, `vm_area_struct` 리스트).
- `files_struct`: 파일 디스크립터 테이블(FD→`struct file*`).
- `cred`: UID/GID, capability set(예: `CAP_NET_ADMIN`), 보안 LSM(SELinux/AppArmor) 컨텍스트.
- **스레드**는 리눅스에서 “**가벼운 프로세스**”(TID/CLONE_THREAD)로 구현됨.

---

## 3. 상태와 전이: 실행은 어떻게 흐르는가

기본 상태: **New → Ready → Running ↔ Blocked → Terminated**
특수 상태: **Zombie**(종료했지만 부모가 `wait*`로 수거하지 않음), **Stopped**(`SIGSTOP` 등으로 정지).

전이 트리거:
- **스케줄러**: 코어 배정/선점(Running ↔ Ready).
- **I/O 대기**: 시스템 콜로 **Blocked**로 들어감, 완료 시 Ready.
- **시그널**: 정지/재개/종료/핸들러 실행.
- **종료**: `exit()` 호출 또는 **fatal 시그널**(예: `SIGSEGV`).

---

## 4. 생성과 실행 이미지 교체: `fork`/`execve`/`posix_spawn`/`clone3`

### 4.1 `fork()` + `execve()`(POSIX 정석)
```c
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>

int main(){
    pid_t p = fork();
    if (p == 0) {                    // child
        execlp("ls", "ls", "-l", NULL);
        _exit(127);                  // exec 실패시만 도달
    }
    int st=0; waitpid(p, &st, 0);
    if (WIFEXITED(st)) printf("child exit=%d\n", WEXITSTATUS(st));
}
```
- `fork()`는 **주소공간을 복제**하되, 실제 페이지는 **COW(Copy-On-Write)** 로 지연 복사.
- `execve()`는 현재 프로세스의 주소공간을 **새 ELF 이미지**로 교체하고, 인자·환경을 세팅.

### 4.2 `posix_spawn()`(모바일/경량 런처에 선호)
- glibc는 상황에 따라 `vfork`+`execve` 또는 `clone`을 사용해 효율 개선.
- **셸·런처**에서 다중 설정이 필요 없고 *간단히 다른 프로그램을 실행*할 때 유용.

```c
#include <spawn.h>
#include <sys/wait.h>
extern char **environ;
int run_ls(){
    pid_t pid; char* argv[]={"ls","-l",NULL};
    posix_spawn(&pid, "/bin/ls", NULL, NULL, argv, environ);
    int st; waitpid(pid,&st,0);
    return WIFEXITED(st)? WEXITSTATUS(st) : -1;
}
```

### 4.3 `clone3()`(리눅스 최신, 5.3+)
- 스레드/네임스페이스/시그널 핸들러 공유 등 **세밀한 제어**(스레드=CLONE_THREAD).
- 컨테이너 런타임, 샌드박스에서 활발히 사용.

---

## 5. 종료와 수거: 좀비/고아, `wait*` API, 종료 코드 규약

### 5.1 종료 경로
- 정상: `exit(code)` → 모든 FD 닫힘, `atexit`/DTOR 실행, 부모에게 `SIGCHLD`.
- 비정상: 시그널로 종료(예: `SIGSEGV`) → 코어덤프(옵션).

### 5.2 부모의 수거
```c
#include <sys/wait.h>
void reap_all(){
    int st;
    while (waitpid(-1, &st, WNOHANG) > 0) {
        if (WIFSIGNALED(st)) {/*로그*/} else if (WIFEXITED(st)) {/*로그*/}
    }
}
```
- **좀비**: 종료했지만 부모가 `wait*`를 부르지 않아 **PID만 남은 엔트리**.
- **고아**: 부모 종료 → **PID 1** 또는 cgroup init가 입양하여 수거.

### 5.3 종료 코드 해석(수식)
종료 상태 `status`를 해석:
- **정상 종료**: `WIFEXITED(status)` 이고 \( \text{code} = WEXITSTATUS(status) \in [0,255] \)
- **시그널 종료**: `WIFSIGNALED(status)` 이고 \( \text{sig} = WTERMSIG(status) \)

---

## 6. 스케줄링: CFS/RT/Deadline, 우선순위, niceness, affinity

### 6.1 리눅스 스케줄러 개요
- **CFS(Completely Fair Scheduler)**: 일반 작업용, 가상 런타임 \( v_i \) 를 공정하게 맞춤.
- **RT(FIFO/RR)**: 실시간. 우선순위 1–99, CFS보다 **절대 우선**.
- **SCHED_DEADLINE**: \( \langle \text{runtime}, \text{deadline}, \text{period} \rangle \) 파라미터로 EDF 비슷한 보장.

CFS 개념식:
- 각 태스크의 **가상 런타임** \( v_i \) 는 **가중치(w_i)** 를 반영해 증가
  $$ v_i \leftarrow v_i + \frac{\Delta t}{w_i} \quad\text{(niceness→weight)} $$
  작은 \( v_i \) (덜 받은 태스크)를 우선 실행.

### 6.2 niceness/priority/affinity 실전
```bash
nice -n 10 ./job                 # 낮은 우선순위
renice -n -5 -p <pid>            # 실행 중 조정(-20..19)
taskset -c 0-3 ./job             # CPU affinity
chrt -f -p 80 <pid>              # RT FIFO 80 (주의!)
```
- **Deadline** 예(관리 도구 필요): `chrt -d runtime:deadline:period -p <pid>`

---

## 7. 프로세스 보안 컨텍스트: UID/GID, Capabilities, LSM, Namespaces

- **UID/EUID/GID**: 퍼미션 결정. setuid 바이너리는 EUID 상승.
- **Capabilities**: 루트 권한을 세분화(예: `CAP_NET_BIND_SERVICE`).
```bash
setcap cap_net_bind_service=+ep ./app
getcap ./app
```
- **LSM**: SELinux/AppArmor 컨텍스트로 **정책 기반 접근 제어**.
- **Namespaces**: PID/NET/UTS/MNT/IPC/USER/CGROUP **격리** → 컨테이너의 토대.
```bash
unshare --mount --pid --ipc --net --uts --fork --mount-proc bash
```

---

## 8. 파일 디스크립터(FD)와 실행 컨텍스트

- 프로세스마다 **FD 테이블**(0=stdin, 1=stdout, 2=stderr). `execve` 후에도 **열린 FD는 상속**(CLOEXEC 없으면).
```c
int fd = open("x", O_RDONLY | O_CLOEXEC); // exec 후 자동 닫힘
```
- 파이프/소켓/TTY/파일/이벤트FD/epollFD 등 **모두 FD**로 통일.

---

## 9. 메모리: 힙/스택, `brk` vs `mmap`, COW, THP, NUMA

- **힙**: `malloc`은 작은 블록은 `brk` 영역, 큰 블록은 `mmap`(glibc 일반 경향).
- **스택**: 가드 페이지로 오버플로 방지, NX로 실행 금지.
- **COW**: `fork()` 직후 부모/자식이 같은 페이지 공유, **쓰기 시 복사**.
- **THP(Transparent Huge Page)**: 2MB 페이지로 TLB 압박 완화(워크로드 따라 유불리).
- **NUMA**: first-touch 정책. 바인딩은 `numactl` 참고.

메모리 매핑 예(파일 I/O를 메모리처럼):
```c
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
int fd = open("data.bin", O_RDWR|O_CLOEXEC);
void* p = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
// 사용 후
msync(p,4096,MS_SYNC); munmap(p,4096); close(fd);
```

---

## 10. IPC: 파이프·소켓·공유메모리·시그널·메시지큐·futex

### 10.1 익명 파이프 + `fork` + `exec`
```c
#include <unistd.h>
#include <sys/wait.h>
int main(){
    int pfd[2]; pipe(pfd);                 // pfd[0]=read, pfd[1]=write
    pid_t c = fork();
    if(c==0){ dup2(pfd[0],0); close(pfd[1]); execlp("wc","wc","-l",NULL); _exit(127); }
    close(pfd[0]);
    write(pfd[1], "hello\nworld\n", 12);
    close(pfd[1]); waitpid(c,NULL,0);
}
```

### 10.2 POSIX 공유 메모리
```c
#include <sys/mman.h> #include <sys/stat.h> #include <fcntl.h>
int fd = shm_open("/demo", O_CREAT|O_RDWR, 0600);
ftruncate(fd, 4096);
char* m = mmap(NULL,4096,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
```

### 10.3 소켓(로컬/네트워크), 메시지큐, `futex`(사용자 공간 락 원자 대기) 등은 상황별 선택.

---

## 11. 시그널과 비동기 이벤트

- 비동기 알림: `SIGINT/SIGTERM/SIGCHLD/...`
- `sigaction`으로 **SA_RESTART/마스크** 제어, 핸들러는 **AS-safe 함수만**(`write`, `_exit`).
```c
#include <signal.h>
void h(int s){ write(2, "INT\n", 4); }
int main(){ struct sigaction sa={.sa_handler=h}; sigemptyset(&sa.sa_mask);
            sigaction(SIGINT,&sa,NULL); for(;;) pause(); }
```

---

## 12. 에러 처리와 부분 I/O·타임아웃 패턴(시스템 콜 실전)

- `errno` 즉시 보존, **EINTR/EAGAIN** 루프, **부분 I/O**는 루프 보장.
- 논블로킹: `O_NONBLOCK` + `poll/ppoll/epoll`로 준비도 확인 후 I/O.
- 타임아웃: `CLOCK_MONOTONIC` 기준의 **데드라인** 선호.

쓰기 보장 헬퍼:
```c
ssize_t write_all(int fd, const void* b, size_t n){
    const char* p=b; size_t left=n;
    while(left){
        ssize_t w=write(fd,p,left);
        if(w>0){ p+=w; left-=w; continue; }
        if(w<0 && (errno==EINTR||errno==EAGAIN)) continue;
        return -1;
    }
    return (ssize_t)n;
}
```

---

## 13. 리소스 한도와 cgroup v2(프로세스 자원 관리)

- **RLIMIT**: `nofile`, `nproc`, `stack`, `core` 등.
```bash
prlimit --pid <pid> --nofile=65535
```
- **cgroup v2**: CPU/메모리/I/O/모듈식 한도·격리, systemd 통합.
```bash
systemd-run -p CPUQuota=50% -p MemoryMax=1G --scope --pid <PID>
```
CPU 쿼터 비율:
$$ f_{\text{CPU}} = \frac{\text{quota\_us}}{\text{period\_us}} $$

---

## 14. 관찰·추적·디버깅: /proc, lsof, strace, perf, eBPF, 코어덤프

- **/proc**: `/proc/<pid>/status, smaps, fd, maps, limits`
- **lsof/ss**: 열린 파일·소켓.
- **strace**: 시스템콜/errno/지연 파악.
- **perf**: CPU 프로파일(`perf top/record/report`).
- **bpftrace/bcc**: 저오버헤드 커널 트레이싱.
- **코어덤프**: `ulimit -c unlimited`, `coredumpctl gdb`.

핫스레드·핫함수 빠른 루틴:
```bash
top -H -p <pid>
perf top -p <pid>
strace -f -p <pid>
```

---

## 15. 현대 리눅스의 최신 포인트(6.x, 실무 반영)

- **pidfd_open/pidfd_send_signal**: PID 재사용 레이스 없는 안전한 시그널.
- **clone3**: 태스크 생성 파라미터 확장.
- **PSI(Pressure Stall Information)**: `/proc/pressure/cpu|memory|io` → 과부하 구간 감지.
- **io_uring**: 커널 진입/복귀 오버헤드 감소 I/O(프로세스 관점에선 FD 기반 비동기 I/O 수단).
- **cgroup v2 전면화**: 배포판 기본. MemoryLow/High/Max, CPUWeight/Quota, I/O 제한 체계화.

---

## 16. 실습: 부모-자식 파이프라인 + 종료 코드/시그널 처리 종합

```c
#define _GNU_SOURCE
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

int main(){
    int pfd[2]; pipe2(pfd, O_CLOEXEC);
    pid_t c = fork();
    if(c==0){
        dup2(pfd[0],0); close(pfd[0]); close(pfd[1]);
        execlp("wc","wc","-l",NULL); _exit(127);
    }
    close(pfd[0]);
    const char *msg="a\nb\nc\n";
    size_t n=strlen(msg), off=0;
    while(off<n){
        ssize_t w=write(pfd[1], msg+off, n-off);
        if(w>0){ off+=w; continue; }
        if(w<0 && (errno==EINTR||errno==EAGAIN)) continue;
        break;
    }
    close(pfd[1]);

    int st; waitpid(c,&st,0);
    if (WIFEXITED(st)) printf("wc exit=%d\n", WEXITSTATUS(st));
    if (WIFSIGNALED(st)) printf("wc sig=%d\n", WTERMSIG(st));
}
```

---

## 17. 흔한 함정 체크리스트

- [ ] **좀비 방치**: `SIGCHLD` 핸들러 + `waitpid(WNOHANG)` 루틴 확보.
- [ ] **CLOEXEC 누락**: 비밀 FD가 `exec` 뒤 자식에 노출. 생성 시 `O_CLOEXEC`/`pipe2` 사용.
- [ ] **EINTR/EAGAIN 무시**: 블로킹/논블로킹 I/O 루프 표준화.
- [ ] **SIGPIPE로 종료**: `signal(SIGPIPE, SIG_IGN)` 또는 `MSG_NOSIGNAL`.
- [ ] **RT 스케줄 남용**: 시스템 전체 응답성 저하.
- [ ] **PID 경쟁**: pidfd 사용.
- [ ] **ASLR/코어덤프 비활성**: 디버깅 어려움. `ulimit -c`와 심볼 준비.
- [ ] **과도한 THP**: 일부 워크로드에서 지연 스파이크. 튜닝 필요.

---

## 18. 확장: 스레드와의 경계(간단 비교)

| 항목 | 프로세스 | 스레드 |
|---|---|---|
| 주소 공간 | 독립(기본) | 동일 프로세스 내 공유 |
| 생성 비용 | 큼(페이지 테이블 등) | 작음 |
| 격리 | 강함 | 약함(메모리 공유) |
| 리소스 테이블 | 각각 | 대부분 공유(FD, 주소공간 등) |
| 리눅스 구현 | `clone3`(공유 플래그 미사용) | `clone3` + `CLONE_THREAD` |

> **권장**: 외부 실패 격리·보안 필요 → **프로세스**. 고성능 내부 병렬화 → **스레드**.

---

## 19. 작은 수학: 스케줄링 관점의 응답성/대기시간 직관

라운드 로빈에서 타임슬라이스 \( q \), 컨텍스트 스위치 오버헤드 \( s \) 일 때,
태스크 수 \( n \) 의 평균 시간당 순수 실행 비율은 대략
$$ \eta \approx \frac{q}{q+s} $$
스위치 오버헤드 \( s \) 가 커지면 효율이 급락 → 너무 작은 \( q \) 는 비효율.

CFS는 고정 슬라이스가 아니라 **가상 런타임 균등화**로 지연을 제어한다.

---

## 20. 요약

- 프로세스는 **실행 중인 프로그램의 인스턴스**로, 커널이 **자원·보안·스케줄**을 종합 관리한다.
- 생성은 `fork/exec`(또는 `posix_spawn`), 종료는 `exit`/시그널, 수거는 `wait*`.
- **주소 공간/FD/시그널/스케줄링/보안 컨텍스트/자원 한도**가 프로세스의 실체.
- **현대 리눅스 6.x** 기준으로 pidfd/clone3/cgroup v2/PSI 등 최신 기능을 적용하면 **안전성·관찰성·관리성**이 크게 좋아진다.

---

## 부록 A) 빠른 실습 명령 모음

```bash
# 내 프로세스 맵/한도/FD
cat /proc/$$/maps | head
cat /proc/$$/limits
ls -l /proc/$$/fd

# CPU 핫스레드
ps -eLo pid,tid,psr,pcpu,stat,comm --sort=-pcpu | head

# 포트 점유자/종료
sudo lsof -i :8080
sudo fuser -k 8080/tcp

# cgroup v2로 즉시 제한
systemd-run -p MemoryMax=1G -p CPUQuota=50% --scope --pid $$
```

## 부록 B) Windows/macOS 간단 대응표

| 목적 | Linux | Windows | macOS |
|---|---|---|---|
| 프로세스 목록 | `ps`, `htop` | Task Manager, `tasklist` | Activity Monitor, `ps`, `top` |
| 종료/시그널 | `kill` | `taskkill /PID` | `kill` |
| 추적 | `strace` | Process Monitor, ETW | `dtruss`(DTrace) |
| 디버깅 | `gdb` | WinDbg | `lldb` |
