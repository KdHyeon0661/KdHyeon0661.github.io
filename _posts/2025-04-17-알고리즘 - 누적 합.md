---
layout: post
title: 알고리즘 - 누적 합
date: 2025-04-17 19:20:23 +0900
category: 알고리즘
---
# 누적 합(Prefix Sum) 완전 정복 — 1D·2D·확장(차이배열·XOR·모듈러)·백준 실전

제공해 주신 초안(정의·수식·구현·11659/2559/11660 예제·유형/팁/요약)을 **핵심 유지**하면서 다음을 **빠짐없이 확장**했습니다.

- 1차원/2차원 누적합의 **정확한 수식과 인덱싱 패턴**
- **조건 카운팅**(부분합이 K인 구간 수), **모듈러 누적합**(나머지 합), **최대 부분합 = prefix − 최소 prefix**
- **차이 배열(Imos)**: 1D/2D 구간 업데이트를 O(1)씩 누적 후 한 번에 적분
- **Prefix XOR**(구간 XOR), **가중 누적합**(가중 평균/접두 누적)
- **3차원 누적합**, **롤링 해시**까지 실전에서 자주 쓰는 파생 기법
- 백준 연계: 10986(나머지 합), 2015(수들의 합 4), 1806(부분합; 투 포인터 대조), 11658(2D 구간 업데이트/쿼리 구조 비교 안내)

수식은 $$...$$, 코드는 ``` 로 감쌉니다.

---

## 1) 정의와 기본 수식(1차원)

배열 \(A[1..n]\)에 대해 **누적합**(prefix sum) \(P\)를 다음과 같이 둡니다.

$$
P[0]=0,\quad P[i] = P[i-1] + A[i]\ \ (1 \le i \le n).
$$

그때 임의 구간 \([l, r]\)의 합은

$$
\mathrm{Sum}(l,r) = \sum_{i=l}^{r} A[i] = P[r] - P[l-1].
$$

### 구현(1-based 인덱스)
```python
n = len(arr)
P = [0] * (n + 1)
for i in range(1, n + 1):
    P[i] = P[i - 1] + arr[i - 1]  # arr는 0-based
```

질의는 한 줄:
```python
def range_sum(l, r):  # 1 <= l <= r <= n
    return P[r] - P[l - 1]
```

---

## 2) 기본 예제 복습

### 2.1 BOJ 11659 구간 합 구하기 4 — 전형
```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
arr = list(map(int, input().split()))
P = [0] * (n + 1)
for i in range(1, n + 1):
    P[i] = P[i - 1] + arr[i - 1]

for _ in range(m):
    l, r = map(int, input().split())
    print(P[r] - P[l - 1])
```

### 2.2 BOJ 2559 수열 — 길이 K의 연속 합 최대
```python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
A = list(map(int, input().split()))
P = [0] * (n + 1)
for i in range(1, n + 1):
    P[i] = P[i - 1] + A[i - 1]

ans = -10**18
for r in range(k, n + 1):
    ans = max(ans, P[r] - P[r - k])
print(ans)
```

---

## 3) 2차원 누적합(Integral Image)

크기 \(n \times n\) 행렬 \(A\)의 2D 누적합 \(S\):

$$
S[x][y] = \sum_{i=1}^{x} \sum_{j=1}^{y} A[i][j],\quad S[0][*]=S[*][0]=0.
$$

사각형 \((x_1,y_1)-(x_2,y_2)\) 합은

$$
\mathrm{RectSum} = S[x_2][y_2] - S[x_1-1][y_2] - S[x_2][y_1-1] + S[x_1-1][y_1-1].
$$

### 2D 구현(BOJ 11660)
```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
A = [[0]*(n+1)]
for _ in range(n):
    A.append([0] + list(map(int, input().split())))

S = [[0]*(n+1) for _ in range(n+1)]
for i in range(1, n+1):
    row_sum = 0
    for j in range(1, n+1):
        row_sum += A[i][j]
        S[i][j] = S[i-1][j] + row_sum

for _ in range(m):
    x1, y1, x2, y2 = map(int, input().split())
    res = S[x2][y2] - S[x1-1][y2] - S[x2][y1-1] + S[x1-1][y1-1]
    print(res)
```

---

## 4) 조건 카운팅 — “합이 K인 구간 수” (해시 + 누적합)

핵심 아이디어:

$$
P[r] - P[l-1] = K \iff P[l-1] = P[r] - K.
$$

각 \(r\)에서 \(P[r]-K\)의 **과거 빈도**를 더하면 답.

### 4.1 BOJ 2015 수들의 합 4
```python
import sys
from collections import defaultdict
input = sys.stdin.readline

n, K = map(int, input().split())
A = list(map(int, input().split()))

cnt = defaultdict(int)
cnt[0] = 1  # P[0]=0
ans = 0
S = 0
for x in A:
    S += x        # P[r]
    ans += cnt[S - K]
    cnt[S] += 1
print(ans)
```

### 4.2 BOJ 10986 나머지 합 — 모듈러 누적합
합이 M의 배수인 구간 수: \( (P[r] - P[l-1]) \bmod M = 0 \iff P[r]\bmod M = P[l-1]\bmod M\).

따라서 **같은 나머지끼리의 조합 수**를 더하면 됨:

$$
\sum_{r=0}^{M-1} \binom{f_r}{2},\ \ f_r = \text{나머지가 } r \text{인 접두합 개수}.
$$

```python
import sys
input = sys.stdin.readline

n, M = map(int, input().split())
A = list(map(int, input().split()))

freq = [0] * M
S = 0
freq[0] = 1  # P[0] % M = 0
for x in A:
    S = (S + x) % M
    freq[S] += 1

ans = 0
for c in freq:
    ans += c * (c - 1) // 2
print(ans)
```

---

## 5) 최대 부분합을 누적합으로 — “Kadane의 다른 시각”

최대 부분합은
$$
\max_{1 \le r \le n} \bigl(P[r] - \min_{0 \le i < r} P[i]\bigr).
$$

즉, \(r\)까지의 접두합에서 **과거 최소 접두합**을 빼면 현시점 최대가 된다.

```python
def max_subarray_sum(arr):
    minP = 0
    S = 0
    ans = -10**18
    for x in arr:
        S += x
        ans = max(ans, S - minP)
        minP = min(minP, S)
    return ans
```

> 모든 음수인 경우도 올바르게 처리됩니다(가장 큰 음수 1개 선택).

---

## 6) 차이 배열(이모스/Imos) — 다수 구간 업데이트를 O(1)로

### 6.1 1D 차이 배열
여러 번의 구간 가산 \([l, r]\)에 대해

- 차이배열 \(D\)에 \(D[l]+=v, D[r+1]-=v\)
- 마지막에 누적합으로 원배열 복원

```python
n, q = map(int, input().split())
D = [0]*(n+2)

for _ in range(q):
    l, r, v = map(int, input().split())
    D[l] += v
    D[r+1] -= v

A = [0]*(n+1)
for i in range(1, n+1):
    A[i] = A[i-1] + D[i]
```

### 6.2 2D 차이 배열
직사각형 \((x1,y1)-(x2,y2)\)에 \(+v\):

- \(D[x1][y1]+=v,\ D[x2+1][y1]-=v,\ D[x1][y2+1]-=v,\ D[x2+1][y2+1]+=v\)
- 최종 복원은 2D 누적합(행 누적 후 열 누적 or 반대)

```python
# D는 충분한 패딩 포함 (n+2) x (m+2)
def add_rect(D, x1, y1, x2, y2, v):
    D[x1][y1] += v
    D[x2+1][y1] -= v
    D[x1][y2+1] -= v
    D[x2+1][y2+1] += v

# 복원
for i in range(1, n+1):
    for j in range(1, m+1):
        D[i][j] += D[i-1][j] + D[i][j-1] - D[i-1][j-1]
```

> 그리드 페인팅/열도계 시뮬레이션, 이벤트 누적 등에 매우 강력합니다.

---

## 7) Prefix XOR — 구간 XOR도 O(1)

XOR에 대해서도 접두 XOR \(X\)를 두면

$$
X[0]=0,\quad X[i] = X[i-1] \oplus A[i],\quad
\mathrm{Xor}(l,r) = X[r] \oplus X[l-1].
$$

합과 달리 역원 대신 XOR의 자기역원 성질(\(u \oplus u = 0\))을 사용합니다.

### XOR이 K인 부분배열 개수
\(X[r]\oplus X[l-1]=K \iff X[l-1]=X[r]\oplus K\).  
해시맵으로 동일.

```python
from collections import defaultdict

def count_subarrays_with_xor_k(arr, K):
    freq = defaultdict(int)
    freq[0] = 1
    xr = 0
    ans = 0
    for x in arr:
        xr ^= x
        ans += freq[xr ^ K]
        freq[xr] += 1
    return ans
```

---

## 8) 3차원 누적합(확장)

3D 합 \(S[x][y][z]\)는 포함-배제의 3차원 버전입니다. 직육면체 \((x1,y1,z1)-(x2,y2,z2)\):

\[
\begin{aligned}
\mathrm{Sum} =\ & S[x_2][y_2][z_2]
- S[x_1-1][y_2][z_2] - S[x_2][y_1-1][z_2] - S[x_2][y_2][z_1-1] \\
& + S[x_1-1][y_1-1][z_2] + S[x_1-1][y_2][z_1-1] + S[x_2][y_1-1][z_1-1]
- S[x_1-1][y_1-1][z_1-1].
\end{aligned}
\]

메모리·시간 부담이 크므로 입력 크기와 질의 수를 고려해 선택하세요.

---

## 9) 가중 누적합(Weighted Prefix) — 응용

예) 길이 \(k\) 가중 이동평균, 또는 인덱스 가중 합을 빠르게:

- \(P[i] = \sum_{t=1}^{i} A[t]\)
- \(Q[i] = \sum_{t=1}^{i} t\cdot A[t]\)

그럼 \([l,r]\)의 인덱스 가중합은

$$
\sum_{t=l}^{r} t A[t] = Q[r] - Q[l-1].
$$

평균도 \( (P[r]-P[l-1])/(r-l+1)\)로 O(1).

---

## 10) 롤링 해시(문자열) — Prefix로 부분문자열 해시 O(1)

기본 해시:
$$
H[i] = (H[i-1]\cdot B + s[i])\bmod M,\quad
\mathrm{hash}(l,r) = (H[r]-H[l-1]\cdot B^{(r-l+1)}) \bmod M.
$$

충돌을 줄이려면 **이중 모듈러**(두 개의 \(M\))를 사용합니다.

```python
def rolling_hash(s, B=911382323, M=972663749):
    n = len(s)
    H = [0]*(n+1)
    P = [1]*(n+1)
    for i,ch in enumerate(s,1):
        H[i] = (H[i-1]*B + ord(ch)) % M
        P[i] = (P[i-1]*B) % M
    def get(l, r):  # 1-based inclusive
        res = (H[r] - H[l-1]*P[r-l+1]) % M
        return res if res >= 0 else res + M
    return get
```

---

## 11) 투 포인터 vs 누적합 — 언제 무엇을 쓰나

- **고정 길이** 구간 합 → 누적합 O(1) 질의가 깔끔.
- **양수 배열에서 합 ≥ K 최소 길이** → 투 포인터가 최적(BOJ 1806).
- **음수 포함에서 합 = K 개수** → 누적합 + 해시가 보편적(BOJ 2015).
- **많은 구간 업데이트 + 한 번의 결과** → 차이배열(Imos).
- **많은 업데이트와 많은 질의** → 세그먼트/펜윅 트리(별도 주제).

BOJ 1806(부분합) 참고(양수 배열 한정):
```python
def min_len_subarray_geq_k(arr, K):
    n = len(arr)
    s = 0
    l = 0
    ans = n+1
    for r in range(n):
        s += arr[r]
        while s >= K:
            ans = min(ans, r - l + 1)
            s -= arr[l]
            l += 1
    return ans if ans <= n else 0
```

---

## 12) 인덱싱/성능 주의사항 체크리스트

1) **1-based P**, **0-based arr** 혼용 시 `P[i] = P[i-1] + arr[i-1]`.  
2) 구간 질의에서 **경계**: \(l=1\)이면 \(P[l-1]=P[0]=0\) 사용.  
3) 큰 입력은 `sys.stdin.readline` 또는 `read()` 사용.  
4) 2D/3D는 **메모리와 캐시** 고려(파이썬은 특히).  
5) 모듈러 누적합에서 **음수 보정**(파이썬은 `%`가 이미 음수에 안전).  
6) 차이배열은 **마지막 적분**을 잊지 말 것.  
7) 해시 카운팅에서 **초기값**: `cnt[0]=1`(공집합 접두 포함) 중요.

---

## 13) 종합 예제 묶음

### 13.1 여러 유형을 한 번에
- K합 개수(2015), 나머지 합(10986), 최대 부분합(누적 기반)

```python
import sys
from collections import defaultdict
input = sys.stdin.readline

def count_sum_equals_k(A, K):
    cnt = defaultdict(int)
    cnt[0] = 1
    ans = 0
    S = 0
    for x in A:
        S += x
        ans += cnt[S - K]
        cnt[S] += 1
    return ans

def count_sum_mod_zero(A, M):
    freq = [0]*M
    freq[0] = 1
    S = 0
    for x in A:
        S = (S + x) % M
        freq[S] += 1
    return sum(c*(c-1)//2 for c in freq)

def max_sub_sum(A):
    S = 0
    minP = 0
    ans = -10**18
    for x in A:
        S += x
        if S - minP > ans: ans = S - minP
        if S < minP: minP = S
    return ans

if __name__ == "__main__":
    n = int(input())
    A = list(map(int, input().split()))
    K = int(input())
    M = int(input())
    print(count_sum_equals_k(A, K))
    print(count_sum_mod_zero(A, M))
    print(max_sub_sum(A))
```

### 13.2 2D 차이배열 + 적분
```python
import sys
input = sys.stdin.readline

n, m, q = map(int, input().split())
D = [[0]*(m+3) for _ in range(n+3)]
for _ in range(q):
    x1, y1, x2, y2, v = map(int, input().split())
    D[x1][y1] += v
    D[x2+1][y1] -= v
    D[x1][y2+1] -= v
    D[x2+1][y2+1] += v

# 2D prefix to reconstruct
for i in range(1, n+1):
    for j in range(1, m+1):
        D[i][j] += D[i-1][j] + D[i][j-1] - D[i-1][j-1]

for i in range(1, n+1):
    print(*D[i][1:m+1])
```

---

## 14) 연습/추천 문제(BOJ)

| 번호 | 제목 | 핵심 |
|---|---|---|
| 11659 | 구간 합 구하기 4 | 1D 누적합 기본 |
| 2559 | 수열 | 고정 길이 최대 합 |
| 11660 | 구간 합 구하기 5 | 2D 누적합 |
| 2015 | 수들의 합 4 | 누적합 + 해시 |
| 10986 | 나머지 합 | 모듈러 누적합 |
| 1806 | 부분합 | 투 포인터(양수 한정, 누적합 대조) |
| 14476 | 최대공약수 하나 빼기 | 접두/접미 GCD(누적의 변형) |
| 16139 | 인간-컴퓨터 상호작용 | 문자별 2D(문자×인덱스) 누적 카운트 |
| 1749 | 점수 따먹기 | 2D 최대 부분합(누적 + 고정 열/행 스캔) |

> GCD/빈도 누적/문자 누적 등 “합”이 아닌 누적도 동일한 패턴으로 확장됩니다.

---

## 15) 요약

| 항목 | 내용 |
|---|---|
| 본질 | 접두에 대한 누적을 미리 계산해 구간을 O(1)로 |
| 1D/2D | \(P[r]-P[l-1]\), 2D는 \(+ - - +\) 포함-배제 |
| 조건 카운팅 | \(P[r]-P[l-1]=K\) → \(P[l-1]=P[r]-K\) 빈도 합 |
| 모듈러 | 같은 나머지끼리 조합 합산 |
| 최대 부분합 | \(\max(P[r]-\min P)\) |
| 차이배열 | 다수 구간 업데이트를 적분으로 일괄 반영 |
| XOR | 합 대신 XOR도 동일한 방식으로 O(1) |
| 주의 | 인덱스·초기값·음수·입출력 최적화 |

누적합은 **단순하지만 강력한 전처리 기법**입니다.  
조건 카운팅·모듈러·차이배열·XOR·2D/3D까지 확장하면, 대다수 “구간” 문제를 정면돌파할 수 있습니다.