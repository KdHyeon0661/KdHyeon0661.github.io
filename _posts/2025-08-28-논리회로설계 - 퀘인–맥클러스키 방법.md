---
layout: post
title: 논리회로설계 - 퀘인–맥클러스키 방법
date: 2025-08-28 23:25:23 +0900
category: 논리회로설계
---
# 퀘인–맥클러스키(Quine–McCluskey) 방법 — **주항의 결정**, **주항 차트**, **패트릭(Petrick) 방법**

> 표기: \(+\)=OR, \(\cdot\) 또는 생략=AND, \(\overline{A}\)=NOT \(A\).
> 비트열은 \(A B C D\) 순서( \(A\) = MSB )의 4비트로 쓰고, **결합(통합)된 비트는 ‘–’** 로 표시합니다(해당 리터럴이 소거됨, 즉 don’t care 자리).
> 목표: 미니텀/Don’t-care에서 **소수 주항(PI)** 을 체계적으로 도출하고, **주항 차트**로 **필수 주항(EPI)** 을 골라낸 뒤, 남은 커버를 **패트릭 방법**으로 **최소 커버**(최소식)로 풀어내는 **전 과정을 재현 가능한 코드와 함께** 익힙니다.

---

## 개요 — 왜 QM인가?

- 카노맵(K-map)은 2~5변수까지 직관적이지만, 변수가 늘면 시각화가 어려워집니다.
- **퀘인–맥클러스키(QM)** 는 K-map의 “인접 결합” 원리를 **표준화/기계화**한 절차입니다.
  1) **1의 개수**로 그룹화
  2) **1비트 차이** 항끼리 결합(–로 소거)
  3) 더 이상 결합 불가 → **소수 주항(PI)**
  4) **주항 차트**로 **EPI** 우선 선택
  5) 잔여 커버를 **패트릭(Petrick)** 으로 최소화

> SOP(곱의 합) 최소화를 기본으로 설명합니다. POS는 **0-셋**을 대상으로 같은 절차를 적용 후 **드모르간**으로 이행 가능합니다.

---

## 알고리즘 흐름(요점 정리)

1. **입력 수집**: \(F=\sum m(I) + d(D)\). 여기서 \(I\)=케어(1), \(D\)=don’t care.
2. **그룹화**: 각 항(미니텀/중간 항)을 **1의 개수** \(k\)별로 \(G_k\) 에 넣음.
3. **결합**: 인접 그룹 \(G_k\) ↔ \(G_{k+1}\) 사이에서 **정확히 1비트만 다른** 두 항을 **하이픈(–)** 으로 결합. 결합된 원 항에 ✓ 표시.
4. **반복**: 새로 생성된 항들에 대해 **같은 규칙**으로 상위 단계 결합을 반복.
5. **PI 확정**: 더 이상 결합되지 않은(마지막에 ✓ 되지 않은) 항이 **소수 주항(PI)**.
6. **주항 차트**: 각 **케어 미니텀**을 **어떤 PI가 덮는지** 표로 표현.
7. **EPI 선택**: 특정 미니텀을 **오직 하나의 PI만** 덮으면 그 PI는 **필수(EPI)** → 즉시 선택, 관련 열 제거.
8. **잔여 커버**: 남은 열(미니텀)은 **패트릭 방법**으로 **최소 커버**를 구해 마무리.

---

## 주항의 결정(결합 절차) — **완전 전개 예제**

### 문제(케어/Don’t-care 명세)

\[
F(A,B,C,D)=\sum m(0,1,2,5,6,7,8,9,10,14) \;+\; d(3,13,15)
\]

각 인덱스의 2진 표현( \(ABCD\) 순 ):

| m  | ABCD | m  | ABCD | m  | ABCD |
|----|------|----|------|----|------|
| 0  | 0000 | 6  | 0110 | 10 | 1010 |
| 1  | 0001 | 7  | 0111 | 14 | 1110 |
| 2  | 0010 | 8  | 1000 | 3* | 0011 |
| 5  | 0101 | 9  | 1001 | 13*| 1101 |
|    |      |    |      | 15*| 1111 |

\(* = don’t care\)

### 1의 개수로 그룹화

- \(G_0:\{0000\}\)
- \(G_1:\{0001,0010,1000\}\)
- \(G_2:\{0011^*,0101,0110,1001,1010\}\)
- \(G_3:\{0111,1110,1101^*\}\)
- \(G_4:\{1111^*\}\)

### 1차 결합(인접 그룹끼리, **1비트 차만 허용**)

(✓ = 결합에 사용된 원 항)

- \(0000\)–\(0001\) → **000–** (0,1) ✓
- \(0000\)–\(0010\) → **00–0** (0,2) ✓
- \(0000\)–\(1000\) → **–000** (0,8) ✓
- \(0001\)–\(0011^*\) → **00–1** (1,3\*) ✓
- \(0001\)–\(0101\) → **0–01** (1,5) ✓
- \(0001\)–\(1001\) → **–001** (1,9) ✓
- \(0010\)–\(0011^*\) → **001–** (2,3\*) ✓
- \(0010\)–\(0110\) → **0–10** (2,6) ✓
- \(0010\)–\(1010\) → **–010** (2,10) ✓
- \(1000\)–\(1001\) → **100–** (8,9) ✓
- \(1000\)–\(1010\) → **10–0** (8,10) ✓
- \(0011^*\)–\(0111\) → **0–11** (3\*,7) ✓
- \(0101\)–\(0111\) → **01–1** (5,7) ✓
- \(0101\)–\(1101^*\) → **–101** (5,13\*) ✓
- \(0110\)–\(0111\) → **011–** (6,7) ✓
- \(0110\)–\(1110\) → **–110** (6,14) ✓
- \(1001\)–\(1101^*\) → **1–01** (9,13\*) ✓
- \(1010\)–\(1110\) → **1–10** (10,14) ✓
- \(0111\)–\(1111^*\) → **–111** (7,15\*) ✓
- \(1110\)–\(1111^*\) → **111–** (14,15\*) ✓
- \(1101^*\)–\(1111^*\) → **11–1** (13\*,15\*) ✓

### 2차 결합(상위 단계 결합)

하이픈 패턴이 호환되고, **남은 비트 하나만 다르면** 추가 결합:

- **000–** ↔ **001–** → **00––** ( \(A=0,B=0\) 고정 )
- **00–0** ↔ **00–1** → **00––** (동일 결과)
- **10–0** ↔ **00–0** → **–0–0** ( \(B=0,D=0\) )
- **100–** ↔ **000–** → **–00–** ( \(B=0,C=0\) )
- **0–10** ↔ **1–10** → **––10** ( \(C=1,D=0\) )
- **011–** ↔ **111–** → **–11–** ( \(B=1,C=1\) )
- **0–01** ↔ **1–01** → **––01** ( \(C=0,D=1\) )

> 더 이상 결합 불가 시 종료.

### 소수 주항(PI) 확정(✓가 **최종 단계에서** 붙지 않은 항)

- **00––**  \(\Rightarrow \overline{A}\,\overline{B}\)
- **0––1**  \(\Rightarrow \overline{A}D\)
- **–0–0**  \(\Rightarrow \overline{B}\,\overline{D}\)
- **–00–**  \(\Rightarrow \overline{B}\,\overline{C}\)
- **––10**  \(\Rightarrow C\overline{D}\)
- **–11–**  \(\Rightarrow BC\)
- **––01**  \(\Rightarrow \overline{C}D\)

> Don’t-care(3,13,15)는 **결합에는 사용**하지만, **최종 커버(차트의 열)** 에서는 **제외**합니다.

---

## 주항 차트(Prime Implicant Chart)

케어 미니텀(열)과 PI(행):

| PI \ m | 0 | 1 | 2 | 5 | 6 | 7 | 8 | 9 | 10 | 14 |
|:--|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:---:|:---:|
| \( \overline{A}\overline{B}\) (00––) | ● | ● | ● |   |   |   |   |   |    |     |
| \( \overline{A}D\) (0––1)            |   | ● |   | ● |   | ● |   |   |    |     |
| \( \overline{B}\overline{D}\) (–0–0) | ● |   | ● |   |   |   | ● |   |  ● |     |
| \( \overline{B}\overline{C}\) (–00–) | ● | ● |   |   |   |   | ● | ● |    |     |
| \( C\overline{D}\) (––10)            |   |   | ● |   | ● |   |   |   |  ● |  ●  |
| \( BC\) (–11–)                       |   |   |   |   | ● | ● |   |   |    |  ●  |
| \( \overline{C}D\) (––01)            |   | ● |   | ● |   |   |   | ● |    |     |

- 이 표에서는 **필수 주항(EPI)** 이 **없습니다**(각 열에 ●가 **한 개뿐인 행**이 없음).
- 따라서 나머지 커버는 **패트릭(Petrick) 방법**으로 풉니다.

---

## 패트릭(Petrick) 방법 — **최소 커버**

### 정의

각 케어 미니텀 \(m_j\)에 대해 “그 미니텀을 덮는 PI들의 **합**”을 \(S_j\)라 두면,

\[
\boxed{P \;=\; \prod_{j} S_j}
\]

의 전개(분배법칙)로 **가능한 모든 커버 조합**(PI들의 곱)을 얻습니다.
이후 **멱등**( \(XX=X\) ), **흡수**( \(X+XY=X\) ) 등 대수 간략화로 **최소 차수(PI 수 최소)**, 동률이면 **리터럴 수 최소** 해를 고릅니다.

### 본 예제의 \(S_j\) (축약: \(P_1\sim P_7\))

- \(P_1=00––,\ P_2=0––1,\ P_3=–0–0,\ P_4=–00–,\ P_5=––10,\ P_6=–11–,\ P_7=––01\)

\[
\begin{aligned}
m_0 &: (P_1 + P_3 + P_4)\\
m_1 &: (P_1 + P_2 + P_4 + P_7)\\
m_2 &: (P_1 + P_3 + P_5)\\
m_5 &: (P_2 + P_7)\\
m_6 &: (P_5 + P_6)\\
m_7 &: (P_2 + P_6)\\
m_8 &: (P_3 + P_4)\\
m_9 &: (P_4 + P_7)\\
m_{10} &: (P_3 + P_5)\\
m_{14} &: (P_5 + P_6)
\end{aligned}
\]

> 같은 인수(예: \(P_5+P_6\))가 반복되면 **한 번만** 남겨도 됩니다.

### 간략 전개(핵심 단계)

분배·흡수를 순차 적용하면 **낮은 차수(PI 수)** 항이 남습니다.
핵심 후보 중 하나:

\[
\boxed{P_3 P_6 P_7} \quad (\text{PI 3개})
\]

- PI 수 2개로는 커버 불가(차트 상 교집합 검토로 반증 가능)
- 다른 후보(예: \(P_2 P_4 P_5\))도 3개이나, **총 리터럴 수**에서 동률 또는 불리

### 최소식(최종)

\[
\boxed{F \;=\; \underbrace{\overline{B}\,\overline{D}}_{P_3} \;+\; \underbrace{BC}_{P_6} \;+\; \underbrace{\overline{C}D}_{P_7}}
\]

**커버 검증**
- \(P_3:\{0,2,8,10\}\), \(P_6:\{6,7,14\}\), \(P_7:\{1,5,9\}\)
- 케어 미니텀 \(\{0,1,2,5,6,7,8,9,10,14\}\) 전부 덮음(중복 없이 완전).

> 비용(예): PI 3개 × 각 2리터럴 → **총 6리터럴**(간결).

---

## 구현 — **퀘인–맥클러스키 + 패트릭 파이썬 코드**

> 아래 코드는 **표준 QM 파이프라인**(그룹화 → 결합 → PI/차트 → EPI → Petrick)을 구현합니다.
> `sympy`가 있으면 결과 **등가성 검증**도 함께 수행합니다.

### 유틸리티: 비트/패턴 도우미

```python
# Quine–McCluskey + Petrick (SOP 최소화) — 순수 파이썬 레퍼런스 구현

from itertools import combinations, product
from collections import defaultdict

def int_to_bits(n, width):
    return ''.join('1' if (n >> (width-1-i)) & 1 else '0' for i in range(width))

def ones_count(bits):  # '0','1','-' 포함
    return sum(b == '1' for b in bits)

def hamming1(a, b):
    """Return True if a,b differ in exactly one position (ignoring '-')"""
    diff = 0
    for x, y in zip(a, b):
        if x == y: continue
        if x == '-' or y == '-': return False
        diff += 1
        if diff > 1: return False
    return diff == 1

def combine(a, b):
    """Combine two patterns differing by exactly one bit (no '-' mismatch)."""
    out = []
    diff = 0
    for x, y in zip(a, b):
        if x == y:
            out.append(x)
        else:
            if x == '-' or y == '-':
                return None
            out.append('-')
            diff += 1
            if diff > 1:
                return None
    return ''.join(out) if diff == 1 else None

def covers(pattern, minterm_bits):
    """pattern (with '-') covers a specific minterm bitstring?"""
    return all(p == m or p == '-' for p, m in zip(pattern, minterm_bits))
```

### 소수 주항(PI) 생성

```python
def generate_prime_implicants(minterms, dcs, width=4):
    """Return a set of prime implicants (bit-pattern strings with '-')"""
    # 초기 항: 케어 + DC
    items = {int_to_bits(m, width) for m in (set(minterms) | set(dcs))}
    # 1의 개수 그룹화
    groups = defaultdict(set)
    for bits in items:
        groups[ones_count(bits)].add(bits)

    prime_implicants = set()
    while True:
        keys = sorted(groups.keys())
        next_groups = defaultdict(set)
        used = set()
        # 인접 그룹 간 결합
        for i in range(len(keys)-1):
            for a in groups[keys[i]]:
                for b in groups[keys[i+1]]:
                    c = combine(a, b)
                    if c is not None:
                        next_groups[ones_count(c)].add(c)
                        used.add(a); used.add(b)
        # 사용되지 않은 항은 PI로 보존
        for k in keys:
            for bits in groups[k]:
                if bits not in used:
                    prime_implicants.add(bits)
        if not next_groups:
            break
        # 중복 제거(동일 패턴 병합)
        # 더 상위 결합을 위해 새 그룹으로 교체
        groups = defaultdict(set)
        for k, vs in next_groups.items():
            groups[k] = set(vs)
    return prime_implicants
```

### 주항 차트 & EPI 선택

```python
def prime_chart(prime_implicants, minterms, width=4):
    """Return chart: dict[minterm] -> set(PI) that cover it"""
    chart = {m: set() for m in minterms}
    bits_map = {m: int_to_bits(m, width) for m in minterms}
    for pi in prime_implicants:
        for m, b in bits_map.items():
            if covers(pi, b):
                chart[m].add(pi)
    return chart

def select_epis(chart):
    """Pick EPIs; return (epis, remaining_chart)."""
    epis = set()
    remaining = {m: set(pis) for m, pis in chart.items()}
    changed = True
    while changed:
        changed = False
        for m, pis in list(remaining.items()):
            if len(pis) == 1:              # 유일 커버 → EPI
                pi = next(iter(pis))
                if pi not in epis:
                    epis.add(pi)
                    changed = True
                # pi가 덮는 모든 열 제거
                for mm in list(remaining.keys()):
                    if pi in remaining[mm]:
                        del remaining[mm]
                        # pi가 덮는 열은 모두 커버된 것으로 간주
                        # (다른 pi 후보에서 제거 필요 없음: 열 자체 제거)
                break
    return epis, remaining
```

### 패트릭(Petrick) — 최소 커버(PI 수 → 리터럴 수)

```python
def petrick_min_cover(remaining_chart):
    """
    Petrick: product of sums → expand with absorption.
    Objective: minimize (#PIs, then total literals).
    """
    # S_j: each minterm's covering PI sum
    sums = []
    for m, pis in remaining_chart.items():
        sums.append(set(pis))  # sum-of-PI (symbolic)
    if not sums:
        return [set()]  # nothing to cover

    # multiply sums progressively
    products = [set()]  # start with neutral element (empty product)
    for s in sums:
        new_products = []
        for prod in products:
            for pi in s:
                new_products.append(prod | {pi})
        # absorption on products: remove supersets
        # keep only minimal-size sets
        minimal = []
        for p in new_products:
            if any(p2 <= p for p2 in new_products if p2 is not p):
                continue
            minimal.append(p)
        products = minimal

    # tie-breaker: first by #PIs, then by total literal count
    def literal_count(pi):
        # count non '-' bits in a pattern
        return sum(ch != '-' for ch in pi)

    best = None
    best_key = None
    for prod in products:
        key = (len(prod), sum(literal_count(pi) for pi in prod))
        if best is None or key < best_key:
            best, best_key = prod, key
    return [best]
```

### **엔드 투 엔드 실행**(본 문서 예제)

```python
# 문제 정의

mins = [0,1,2,5,6,7,8,9,10,14]
dcs  = [3,13,15]
width = 4

# PI 생성

PIs = generate_prime_implicants(mins, dcs, width)
print("Prime Implicants:", sorted(PIs))

# 차트 & EPI

chart = prime_chart(PIs, mins, width)
EPIs, rem = select_epis(chart)
print("EPIs:", EPIs)
print("Remaining columns:", rem)

# Petrick

covers = petrick_min_cover(rem)
solutions = []
for cov in covers:
    sol = set(EPIs) | set(cov)
    solutions.append(sol)
    print("One minimal cover:", sol)
```

### `sympy`로 **등가성 검증**(선택)

```python
# pip install sympy

from sympy import symbols
from sympy.logic.boolalg import Or, And, Not, simplify_logic, Equivalent

A,B,C,D = symbols('A B C D')

def pattern_to_expr(p):
    # '10-1' → A & ~B & D (C는 '-')
    lits = []
    for ch, var in zip(p, [A,B,C,D]):
        if ch == '1': lits.append(var)
        elif ch == '0': lits.append(Not(var))
    if not lits:  # full '-': tautology
        return True
    e = lits[0]
    for t in lits[1:]:
        e = And(e, t)
    return e

def sop_to_expr(patterns):
    it = iter(patterns)
    try:
        first = pattern_to_expr(next(it))
    except StopIteration:
        return False
    e = first
    for p in it:
        e = Or(e, pattern_to_expr(p))
    return simplify_logic(e, form='dnf')

# 기대 최소식: ~B&~D  +  B&C  +  ~C&D

expect = Or(And(Not(B),Not(D)), And(B,C), And(Not(C),D))
got = sop_to_expr(next(iter(solutions)))

print("Equivalent to expected?", Equivalent(got, expect))
print("DNF:", simplify_logic(got, form='dnf'))
print("CNF:", simplify_logic(got, form='cnf'))
```

---

## 구현 상 디테일 & 실무 팁

1. **중복 제거**: 각 단계에서 **동일 패턴**은 집합으로 관리(중복 PI 방지).
2. **결합 제한**: `combine`은 **'-' 대 '0/1' 충돌**을 거부해 **유효하지 않은 결합**을 막습니다.
3. **PI 판정**: **마지막 라운드에서** 한 번도 더 결합되지 않은 항만 PI.
4. **EPI 선택**: 열에 **유일한 ●** 를 가진 행(PI)은 **즉시 채택**. 그 PI가 덮는 **모든 열**을 제거.
5. **Petrick**: 곱의 분배가 폭증하므로, 중간 단계마다
   - **멱등**(동일 집합 제거), **흡수**(상위집합 제거)로 축소
   - 비용함수: (1) **PI 개수** → (2) **총 리터럴 수** → (3) 구현 선호(NAND-only 등)
6. **Don’t-care**: **결합에는 포함**, **차트 열에서는 제외**(커버 강제 아님).
7. **복잡도**: QM은 최적이지만, **변수↑/미니텀↑** 에서 **폭발적**. 실무에서는
   - **6변수+**: QM + **Petrick** 대신 **ESPRESSO** 등 근사 최소화 병행
   - **다중 출력**: 공통 PI 공유(PLA) 검토
8. **POS 최소화**: 0-셋으로 동일 절차 수행 → 마지막에 **드모르간**으로 SOP↔POS 변환.

---

## 수학적 보강(필요 공식)

### 결합(1비트 차) 조건

\[
\text{combine}(X,Y) = \begin{cases}
\text{하나의 위치만 다름} \Rightarrow \text{그 위치를 '-' 로 하고 반환}\\
\text{그 외} \Rightarrow \varnothing
\end{cases}
\]

### 패트릭 다항식

\[
\boxed{
P \;=\; \prod_{m \in \text{케어}} \left(\sum_{\text{PI }p \,\text{s.t.}\, p \supset m} p\right)
}
\]
전개 후 **흡수**( \(XY + X = X\) )와 **멱등**( \(X+X=X\) )으로 최소항(곱) 선택.

---

## 추가 예제 — **POS 최소화(개관)**

- 0-셋 \(Z\) 를 모아 \(\overline{F}=\sum m(Z)\) 를 **SOP 최소화** →
  \[
  \overline{F}=\sum \text{(곱항)} \;\Rightarrow\;
  F = \prod \text{(합항)} \quad \text{(드모르간)}
  \]
- 코드 측면에서는 **케어/Don’t-care 위치를 바꿔** 동일 QM을 적용하면 됩니다.

---

## 흔한 함정 & 체크리스트

- [ ] **인덱스의 비트순서**( \(A B C D\) )와 **패턴의 자리수**가 일치하는지.
- [ ] **'-' 대 '0/1'** 충돌 결합 금지(코드에서도 엄격히).
- [ ] **EPI가 하나도 없는** 케이스는 **드문 일 아님** → Petrick 준비.
- [ ] **Don’t-care 열**은 차트에서 제외했는가?
- [ ] **동률 최소 커버**의 경우 **리터럴 수**로 2차 판정.
- [ ] 결과를 **K-map** 혹은 `sympy`로 반드시 **검증**.

---

## 연습문제

> 풀이/코드 검증이 필요하면 이어서 요청하세요(동일 포맷으로 해설 제공).

### QM + Petrick

1) \(F=\sum m(0,2,5,6,7,8,10,13,15)+d(1,3,9,14)\).
   - (a) 1의 개수 그룹화표
   - (b) 1차/2차 결합 추적표(‘–’ 패턴)
   - (c) PI 차트와 EPI
   - (d) Petrick으로 최소식(동률이면 리터럴 수 최소)

### POS 최소화

2) \(F=\sum m(1,3,7,11,15)+d(0,2,5,8)\) 에서 **POS** 최소식을 구하라.
   - (a) 0-셋 구성 후 QM 수행
   - (b) 마지막에 드모르간으로 SOP↔POS 변환

### 교차 검증

3) 본문 예제의 최소식 \(F=\overline{B}\,\overline{D}+BC+\overline{C}D\) 가
   - (a) 4변수 K-map 최소화 결과와 일치함을 보이고,
   - (b) **해저드** 관점에서 필요한 경우 **합의항**(예: \(B\overline{D}\) 또는 \(\overline{B}C\) 등) 후보를 제안하고 파형 수준의 직관을 설명하라.

---

## 결론

- QM은 **정확한 최소 SOP** 를 얻는 **체계적 절차**이며,
  **PI 도출 → 차트(EPI) → Petrick** 의 세 부분이 핵심입니다.
- 작은/중간 규모에서는 **K-map과 상호 검증**, 큰 규모에서는 **ESPRESSO 등 근사기** 병행이 실용적입니다.
- 코드로 자동화하면 **재현성**과 **검증 가능성**이 높아지고, **비용 함수**(팬인/게이트 제약 등)를 바꿔 **현실적 최적화**에 적용할 수 있습니다.
