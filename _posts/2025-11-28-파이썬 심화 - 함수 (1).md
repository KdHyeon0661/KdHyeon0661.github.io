---
layout: post
title: 파이썬 심화 - 함수 (1)
date: 2025-11-28 23:25:23 +0900
category: 파이썬 심화
---
# 함수 (1)

## 매개변수 개수에 구애받지 않는 함수 작성

파이썬에서는 `*args`와 `**kwargs`를 사용하여 가변적인 수의 인자를 받는 함수를 작성할 수 있습니다. 이는 함수의 유연성을 크게 향상시키는 강력한 기능입니다.

### 기본적인 가변 인자 사용법

```python
def demonstrate_variable_arguments():
    """가변 인자의 기본적인 사용법"""
    
    print("=== 가변 인자 함수의 기본 ===")
    
    # 1. 위치 인자 가변 처리 (*args)
    def sum_all(*args):
        """임의 개수의 숫자를 받아 합계를 반환"""
        print(f"  받은 인자: {args}, 타입: {type(args)}")
        return sum(args)
    
    # 다양한 개수의 인자로 호출
    print("1. 위치 가변 인자 (*args):")
    print(f"  sum_all(1, 2): {sum_all(1, 2)}")
    print(f"  sum_all(1, 2, 3, 4, 5): {sum_all(1, 2, 3, 4, 5)}")
    print(f"  sum_all(): {sum_all()}")  # 빈 튜플
    
    # 리스트나 튜플을 언패킹하여 전달
    numbers = [10, 20, 30, 40, 50]
    print(f"  sum_all(*numbers): {sum_all(*numbers)}")
    
    # 2. 키워드 인자 가변 처리 (**kwargs)
    def print_person_info(**kwargs):
        """임의 개수의 키워드 인자를 받아 정보 출력"""
        print(f"  받은 키워드 인자: {kwargs}")
        
        if kwargs:
            print("  개인 정보:")
            for key, value in kwargs.items():
                print(f"    {key}: {value}")
        else:
            print("  정보가 제공되지 않았습니다.")
    
    print("\n2. 키워드 가변 인자 (**kwargs):")
    print_person_info(name="김철수", age=30, city="서울")
    print_person_info(name="이영희", job="개발자")
    print_person_info()
    
    # 딕셔너리를 언패킹하여 전달
    person_data = {"name": "박지원", "age": 25, "email": "jiwon@example.com"}
    print_person_info(**person_data)
    
    # 3. 혼합 사용 (일반, *args, **kwargs)
    def create_profile(name, *skills, **details):
        """이름, 기술 목록, 추가 정보로 프로필 생성"""
        profile = {
            "name": name,
            "skills": list(skills),
            "details": details
        }
        return profile
    
    print("\n3. 혼합 사용 예제:")
    profile1 = create_profile("김개발", "Python", "JavaScript", "Django", 
                              experience=3, level="Senior")
    print(f"  프로필 1: {profile1}")
    
    profile2 = create_profile("이디자이너", "Photoshop", "Figma", "Illustrator",
                              specialization="UI/UX", tools=["Figma", "Adobe XD"])
    print(f"  프로필 2: {profile2}")

demonstrate_variable_arguments()
```

### 실전 예제: 데이터 처리 유틸리티

```python
def advanced_variable_argument_examples():
    """실전적인 가변 인자 활용 예제"""
    
    print("\n=== 실전 가변 인자 활용 ===")
    
    # 1. 데이터베이스 쿼리 빌더
    class QueryBuilder:
        """가변 인자를 활용한 유연한 쿼리 빌더"""
        
        @staticmethod
        def select(*columns, **conditions):
            """SELECT 쿼리 생성"""
            # 컬럼 처리
            if not columns:
                columns_clause = "*"
            else:
                columns_clause = ", ".join(columns)
            
            # WHERE 조건 처리
            where_clauses = []
            params = []
            
            for column, value in conditions.items():
                if isinstance(value, (list, tuple)):
                    # IN 조건
                    placeholders = ", ".join(["?"] * len(value))
                    where_clauses.append(f"{column} IN ({placeholders})")
                    params.extend(value)
                else:
                    # 등가 조건
                    where_clauses.append(f"{column} = ?")
                    params.append(value)
            
            # 쿼리 조합
            query = f"SELECT {columns_clause} FROM users"
            if where_clauses:
                query += " WHERE " + " AND ".join(where_clauses)
            
            return query, params
    
    print("1. 데이터베이스 쿼리 빌더:")
    
    # 다양한 방식으로 쿼리 생성
    query1, params1 = QueryBuilder.select("id", "name", "email", age=30, city="서울")
    print(f"  쿼리 1: {query1}")
    print(f"  파라미터: {params1}")
    
    query2, params2 = QueryBuilder.select("name", "phone", status="active", role=["admin", "manager"])
    print(f"  쿼리 2: {query2}")
    print(f"  파라미터: {params2}")
    
    # 2. 로깅 유틸리티
    class FlexibleLogger:
        """다양한 형식의 로그를 처리하는 로거"""
        
        def __init__(self, name):
            self.name = name
        
        def log(self, level, *messages, **context):
            """로그 메시지 기록"""
            timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
            message_text = " ".join(str(m) for m in messages)
            
            # 컨텍스트 정보 추가
            context_info = ""
            if context:
                context_items = [f"{k}={v}" for k, v in context.items()]
                context_info = " [" + ", ".join(context_items) + "]"
            
            log_entry = f"{timestamp} [{level}] {self.name}: {message_text}{context_info}"
            print(f"  {log_entry}")
    
    print("\n2. 유연한 로깅 시스템:")
    logger = FlexibleLogger("Database")
    
    logger.log("INFO", "데이터베이스 연결 성공")
    logger.log("WARNING", "쿼리 실행 시간이 길어짐", query_time=2.5)
    logger.log("ERROR", "연결 실패", retry_count=3, error_code="DB_CONN_001")
    
    # 3. 데이터 검증기
    def validate_data(*validators, **constraints):
        """다양한 검증기를 적용하는 데이터 검증 함수"""
        def decorator(func):
            def wrapper(data):
                print(f"\n  데이터 검증 시작: {func.__name__}")
                
                # 검증기 적용
                for validator in validators:
                    if not validator(data):
                        raise ValueError(f"검증 실패: {validator.__name__}")
                
                # 제약 조건 검증
                for field, condition in constraints.items():
                    if field in data:
                        value = data[field]
                        if not condition(value):
                            raise ValueError(f"제약 조건 위반: {field}={value}")
                
                print(f"  모든 검증 통과")
                return func(data)
            
            return wrapper
        return decorator
    
    print("\n3. 데이터 검증 데코레이터:")
    
    # 검증 함수들
    def is_dict(data):
        return isinstance(data, dict)
    
    def has_required_fields(data):
        return all(key in data for key in ['id', 'name'])
    
    def is_positive_number(value):
        return isinstance(value, (int, float)) and value > 0
    
    # 데코레이터 적용
    @validate_data(is_dict, has_required_fields, age=is_positive_number)
    def process_user_data(user):
        return f"사용자 처리 완료: {user['name']}"
    
    # 테스트
    try:
        valid_user = {"id": 1, "name": "김철수", "age": 30}
        result = process_user_data(valid_user)
        print(f"  성공: {result}")
    except ValueError as e:
        print(f"  실패: {e}")
    
    try:
        invalid_user = {"id": 2, "name": "이영희", "age": -5}
        process_user_data(invalid_user)
    except ValueError as e:
        print(f"  실패: {e}")
    
    # 4. 가변 인자를 사용한 통계 함수
    print("\n4. 통계 계산 함수들:")
    
    class Statistics:
        """가변 인자를 활용한 통계 함수 모음"""
        
        @staticmethod
        def mean(*numbers):
            """평균 계산"""
            if not numbers:
                return 0
            return sum(numbers) / len(numbers)
        
        @staticmethod
        def variance(*numbers):
            """분산 계산"""
            if len(numbers) < 2:
                return 0
            
            avg = Statistics.mean(*numbers)
            squared_diffs = [(x - avg) ** 2 for x in numbers]
            return sum(squared_diffs) / (len(numbers) - 1)
        
        @staticmethod
        def describe(*numbers, **options):
            """기술 통계량 요약"""
            import math
            
            result = {
                "count": len(numbers),
                "mean": Statistics.mean(*numbers),
                "variance": Statistics.variance(*numbers),
                "min": min(numbers) if numbers else None,
                "max": max(numbers) if numbers else None,
                "sum": sum(numbers)
            }
            
            result["std"] = math.sqrt(result["variance"]) if result["variance"] > 0 else 0
            
            # 옵션 처리
            if options.get("include_median") and numbers:
                sorted_nums = sorted(numbers)
                n = len(sorted_nums)
                if n % 2 == 1:
                    result["median"] = sorted_nums[n // 2]
                else:
                    result["median"] = (sorted_nums[n // 2 - 1] + sorted_nums[n // 2]) / 2
            
            return result
    
    # 통계 함수 사용
    data = [10, 20, 30, 40, 50]
    stats = Statistics.describe(*data, include_median=True)
    
    print("  기술 통계량:")
    for key, value in stats.items():
        print(f"    {key}: {value}")

advanced_variable_argument_examples()
```

## 키워드 매개변수만 받는 함수 작성

때로는 함수가 반드시 키워드 인자로만 호출되도록 강제하고 싶을 수 있습니다. 이는 함수의 가독성을 높이고, 매개변수의 순서에 의한 오류를 방지하는 데 도움이 됩니다.

### 키워드 전용 인자 (Keyword-only Arguments)

```python
def keyword_only_functions():
    """키워드 전용 인자를 사용한 함수 설계"""
    
    print("\n=== 키워드 전용 인자 ===")
    
    # 1. 기본적인 키워드 전용 인자
    def create_user(*, username, email, is_active=True, role="user"):
        """
        모든 인자가 키워드 인자로만 전달되어야 하는 함수
        * 뒤의 매개변수는 키워드 인자로만 전달 가능
        """
        user = {
            "username": username,
            "email": email,
            "is_active": is_active,
            "role": role,
            "created_at": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        return user
    
    print("1. 기본 키워드 전용 인자:")
    
    # 올바른 사용법
    user1 = create_user(username="john_doe", email="john@example.com")
    print(f"  올바른 호출: {user1}")
    
    # 키워드 인자로 호출 (순서 변경 가능)
    user2 = create_user(email="jane@example.com", username="jane_smith", 
                       role="admin", is_active=False)
    print(f"  순서 변경 호출: {user2}")
    
    # 잘못된 사용법 (주석 해제 시 오류 발생)
    # user3 = create_user("test_user", "test@example.com")  # TypeError
    
    # 2. 위치 인자와 키워드 전용 인자 혼합
    def configure_service(service_name, *, host="localhost", port=8080, 
                         timeout=30, retries=3):
        """
        service_name은 위치 인자, 나머지는 키워드 전용 인자
        """
        config = {
            "service": service_name,
            "host": host,
            "port": port,
            "timeout": timeout,
            "retries": retries
        }
        return config
    
    print("\n2. 위치 인자와 키워드 전용 인자 혼합:")
    
    config1 = configure_service("auth-service", host="auth.example.com", port=9000)
    print(f"  설정 1: {config1}")
    
    config2 = configure_service("payment-service", timeout=60, retries=5)
    print(f"  설정 2: {config2}")
    
    # 3. 가변 위치 인자와 키워드 전용 인자
    def generate_report(*data_sources, title="Report", format="pdf", 
                       include_summary=True, **options):
        """
        data_sources: 가변 위치 인자
        title, format, include_summary: 키워드 전용 인자
        options: 추가 키워드 인자
        """
        report = {
            "title": title,
            "format": format,
            "data_sources": data_sources,
            "include_summary": include_summary,
            "options": options,
            "generated_at": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        # 데이터 소스 처리
        total_records = 0
        for source in data_sources:
            if isinstance(source, dict) and 'record_count' in source:
                total_records += source['record_count']
        
        report["total_records"] = total_records
        return report
    
    print("\n3. 가변 위치 인자와 키워드 전용 인자:")
    
    source1 = {"name": "db_users", "record_count": 1000}
    source2 = {"name": "api_logs", "record_count": 500}
    
    report = generate_report(
        source1, source2,
        title="사용자 활동 보고서",
        format="html",
        author="시스템",
        priority="high"
    )
    
    print(f"  보고서 생성 완료:")
    for key, value in report.items():
        print(f"    {key}: {value}")
    
    # 4. 실전 예제: API 클라이언트
    print("\n4. 실전 예제: API 클라이언트 클래스")
    
    class APIClient:
        """키워드 전용 인자를 사용한 안전한 API 클라이언트"""
        
        def __init__(self, base_url, *, timeout=30, retries=3, 
                     verify_ssl=True, auth=None):
            """
            base_url: 위치 인자 (필수)
            나머지: 키워드 전용 인자 (선택적)
            """
            self.base_url = base_url
            self.timeout = timeout
            self.retries = retries
            self.verify_ssl = verify_ssl
            self.auth = auth
            self.session = self._create_session()
        
        def _create_session(self):
            """내부 세션 생성 (실제 구현은 생략)"""
            return {"base_url": self.base_url, "timeout": self.timeout}
        
        def request(self, method, endpoint, *, params=None, data=None, 
                   headers=None, **request_kwargs):
            """
            method, endpoint: 위치 인자
            params, data, headers: 키워드 전용 인자
            request_kwargs: 추가 요청 옵션
            """
            # 요청 구성
            request_info = {
                "method": method,
                "url": f"{self.base_url}/{endpoint}",
                "params": params or {},
                "data": data or {},
                "headers": headers or {},
                "session_config": self.session,
                **request_kwargs
            }
            
            # 실제 요청 로직 (시뮬레이션)
            print(f"  [API 요청] {method} {request_info['url']}")
            if params:
                print(f"    파라미터: {params}")
            if headers:
                print(f"    헤더: {headers}")
            
            # 시뮬레이션 응답
            response = {
                "status": 200,
                "data": {"message": "성공", "endpoint": endpoint},
                "request_info": request_info
            }
            
            return response
        
        def get(self, endpoint, *, params=None, headers=None, **kwargs):
            """GET 요청 헬퍼 메서드"""
            return self.request("GET", endpoint, params=params, 
                               headers=headers, **kwargs)
        
        def post(self, endpoint, *, data=None, headers=None, **kwargs):
            """POST 요청 헬퍼 메서드"""
            return self.request("POST", endpoint, data=data, 
                               headers=headers, **kwargs)
    
    # API 클라이언트 사용 예제
    print("  API 클라이언트 생성 및 사용:")
    
    client = APIClient(
        "https://api.example.com",
        timeout=60,
        auth={"type": "bearer", "token": "secret_token"},
        verify_ssl=False
    )
    
    # 올바른 사용법
    response1 = client.get(
        "users",
        params={"page": 1, "limit": 20},
        headers={"User-Agent": "MyApp/1.0"}
    )
    
    response2 = client.post(
        "auth/login",
        data={"username": "test", "password": "secret"},
        headers={"Content-Type": "application/json"}
    )
    
    print("  모든 API 호출이 키워드 인자로 안전하게 수행되었습니다")

keyword_only_functions()
```

### 디폴트 값과 타입 힌트를 활용한 키워드 인자

```python
def advanced_keyword_arguments():
    """고급 키워드 인자 패턴"""
    
    print("\n=== 고급 키워드 인자 패턴 ===")
    
    # 1. 타입 힌트와 디폴트 값 조합
    from typing import Optional, List, Dict, Any, Union
    
    def create_product(
        name: str,
        price: float,
        *,
        category: str = "uncategorized",
        tags: List[str] = None,
        metadata: Dict[str, Any] = None,
        discount: Optional[float] = None,
        in_stock: bool = True
    ) -> Dict[str, Any]:
        """
        타입 힌트와 디폴트 값을 가진 키워드 전용 인자
        """
        # 가변 기본값 처리
        tags = tags or []
        metadata = metadata or {}
        
        # 할인 가격 계산
        final_price = price
        if discount is not None:
            final_price = price * (1 - discount / 100)
        
        product = {
            "name": name,
            "price": price,
            "final_price": final_price,
            "category": category,
            "tags": tags,
            "metadata": metadata,
            "in_stock": in_stock,
            "created": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        return product
    
    print("1. 타입 힌트와 디폴트 값 조합:")
    
    product1 = create_product("노트북", 1299.99, category="전자제품")
    print(f"  제품 1: {product1}")
    
    product2 = create_product(
        name="스마트폰",
        price=899.99,
        category="모바일",
        tags=["new", "5g", "premium"],
        metadata={"brand": "삼성", "model": "Galaxy S24"},
        discount=10.0,
        in_stock=True
    )
    print(f"  제품 2: {product2['name']}, 최종가: ${product2['final_price']:.2f}")
    
    # 2. 필수 키워드 인자 (Python 3.8+)
    print("\n2. 필수 키워드 인자 (Python 3.8+):")
    
    def send_notification(
        message: str,
        *,
        recipient: str,  # 필수 키워드 인자
        sender: str = "system",
        priority: str = "normal",
        channel: str = "email"
    ) -> Dict[str, Any]:
        """
        recipient는 반드시 키워드 인자로 제공해야 함
        """
        notification = {
            "message": message,
            "recipient": recipient,
            "sender": sender,
            "priority": priority,
            "channel": channel,
            "sent_at": time.strftime("%Y-%m-%d %H:%M:%S"),
            "status": "pending"
        }
        
        print(f"  알림 생성: {notification}")
        return notification
    
    # 올바른 사용법
    notification1 = send_notification("회원가입 완료", recipient="user@example.com")
    
    # 잘못된 사용법 (주석 해제 시 오류)
    # notification2 = send_notification("테스트", "user@example.com")  # TypeError
    
    # 3. 복잡한 설정 객체 생성기
    print("\n3. 복잡한 설정 객체 생성기:")
    
    def create_server_config(
        hostname: str,
        ip_address: str,
        *,
        port: int = 80,
        ssl_enabled: bool = False,
        max_connections: int = 1000,
        timeout: float = 30.0,
        logging_config: Dict[str, Any] = None,
        middleware: List[str] = None,
        **extra_settings
    ) -> Dict[str, Any]:
        """
        서버 설정을 생성하는 함수
        """
        # 기본값 처리
        logging_config = logging_config or {
            "level": "INFO",
            "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        }
        
        middleware = middleware or []
        
        # 기본 설정
        config = {
            "hostname": hostname,
            "ip_address": ip_address,
            "port": port,
            "ssl_enabled": ssl_enabled,
            "max_connections": max_connections,
            "timeout": timeout,
            "logging": logging_config,
            "middleware": middleware,
            "created": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        # 추가 설정
        config.update(extra_settings)
        
        return config
    
    # 복잡한 설정 생성
    server_config = create_server_config(
        "web-server-01",
        "192.168.1.100",
        port=443,
        ssl_enabled=True,
        max_connections=5000,
        logging_config={
            "level": "DEBUG",
            "handlers": ["file", "console"],
            "filename": "/var/log/server.log"
        },
        middleware=["auth", "cors", "compression"],
        backup_enabled=True,
        backup_schedule="0 2 * * *"  # 매일 새벽 2시
    )
    
    print("  서버 설정 생성 완료:")
    for key, value in server_config.items():
        if isinstance(value, dict):
            print(f"    {key}:")
            for sub_key, sub_value in value.items():
                print(f"      {sub_key}: {sub_value}")
        elif isinstance(value, list):
            print(f"    {key}: {', '.join(value)}")
        else:
            print(f"    {key}: {value}")
    
    # 4. 키워드 인자 검증 데코레이터
    print("\n4. 키워드 인자 검증 데코레이터:")
    
    def validate_keyword_args(**validators):
        """
        키워드 인자 검증 데코레이터
        """
        def decorator(func):
            def wrapper(*args, **kwargs):
                # 검증 실행
                for param_name, validator in validators.items():
                    if param_name in kwargs:
                        value = kwargs[param_name]
                        if not validator(value):
                            raise ValueError(
                                f"매개변수 '{param_name}' 검증 실패: {value}"
                            )
                
                return func(*args, **kwargs)
            
            return wrapper
        return decorator
    
    # 검증 함수들
    def is_positive(value):
        return value > 0
    
    def is_valid_email(email):
        return "@" in email
    
    def is_one_of(allowed_values):
        def validator(value):
            return value in allowed_values
        return validator
    
    @validate_keyword_args(
        age=is_positive,
        email=is_valid_email,
        status=is_one_of(["active", "inactive", "pending"])
    )
    def update_user_profile(user_id, **updates):
        """사용자 프로필 업데이트"""
        print(f"  사용자 {user_id} 프로필 업데이트:")
        for key, value in updates.items():
            print(f"    {key} = {value}")
        return {"user_id": user_id, **updates, "updated": True}
    
    # 테스트
    try:
        update_user_profile(123, age=30, email="test@example.com", status="active")
        print("  검증 통과")
    except ValueError as e:
        print(f"  검증 실패: {e}")
    
    try:
        update_user_profile(456, age=-5, email="invalid", status="unknown")
    except ValueError as e:
        print(f"  검증 실패: {e}")

advanced_keyword_arguments()
```

## 함수 인자에 메타데이터 넣기

함수 인자에 메타데이터를 추가하면 문서화, 검증, 직렬화 등 다양한 용도로 활용할 수 있습니다.

### 함수 어노테이션(Function Annotations) 활용

```python
def function_annotations_metadata():
    """함수 어노테이션을 활용한 메타데이터"""
    
    print("\n=== 함수 어노테이션과 메타데이터 ===")
    
    import inspect
    from typing import get_type_hints
    
    # 1. 기본적인 타입 어노테이션
    def calculate_total(
        items: list[float], 
        tax_rate: float = 0.1, 
        discount: float = 0.0
    ) -> float:
        """
        항목들의 총액을 계산
        items: 항목 가격 목록
        tax_rate: 세율 (기본값: 0.1 = 10%)
        discount: 할인율 (기본값: 0.0 = 0%)
        반환값: 총액
        """
        subtotal = sum(items)
        discounted = subtotal * (1 - discount)
        total = discounted * (1 + tax_rate)
        return round(total, 2)
    
    print("1. 기본 타입 어노테이션:")
    print(f"  함수 서명: {inspect.signature(calculate_total)}")
    
    # 어노테이션 조회
    annotations = calculate_total.__annotations__
    print(f"  어노테이션: {annotations}")
    
    # 타입 힌트 조회 (더 정확한 정보)
    type_hints = get_type_hints(calculate_total)
    print(f"  타입 힌트: {type_hints}")
    
    # 2. 커스텀 어노테이션
    print("\n2. 커스텀 어노테이션:")
    
    # 어노테이션에 추가 메타데이터 저장
    def process_order(
        order_id: '유니크한 주문 식별자',
        items: '주문 항목 목록',
        priority: '처리 우선순위 (1-5)' = 3,
        notes: '추가 메모' = None
    ) -> '처리 결과':
        """
        주문 처리 함수
        """
        result = {
            "order_id": order_id,
            "item_count": len(items),
            "priority": priority,
            "processed": True,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        if notes:
            result["notes"] = notes
        
        return result
    
    # 어노테이션 정보 분석
    sig = inspect.signature(process_order)
    print(f"  매개변수 정보:")
    
    for param_name, param in sig.parameters.items():
        annotation = param.annotation
        default = param.default if param.default != inspect.Parameter.empty else "없음"
        
        print(f"    {param_name}:")
        print(f"      어노테이션: {annotation}")
        print(f"      기본값: {default}")
        print(f"      종류: {param.kind.name}")
    
    print(f"  반환값 어노테이션: {sig.return_annotation}")
    
    # 3. dataclass와의 통합
    print("\n3. dataclass와의 통합:")
    
    from dataclasses import dataclass, field
    from typing import ClassVar
    
    @dataclass
    class UserProfile:
        """사용자 프로필 데이터 클래스"""
        
        # 필드 어노테이션
        username: str = field(metadata={"description": "사용자 아이디", "max_length": 50})
        email: str = field(metadata={"description": "이메일 주소", "pattern": r".+@.+\..+"})
        age: int = field(default=18, metadata={"description": "나이", "min": 0, "max": 150})
        is_active: bool = field(default=True, metadata={"description": "활성 상태"})
        
        # 클래스 변수
        version: ClassVar[str] = "1.0.0"
        
        def validate(self) -> bool:
            """프로필 검증"""
            # 메타데이터를 활용한 검증
            fields_metadata = self.__dataclass_fields__
            
            for field_name, field_info in fields_metadata.items():
                metadata = field_info.metadata
                
                if "description" in metadata:
                    print(f"    {field_name}: {metadata['description']}")
                
                # 나이 검증
                if field_name == "age" and hasattr(self, field_name):
                    value = getattr(self, field_name)
                    if "min" in metadata and value < metadata["min"]:
                        return False
                    if "max" in metadata and value > metadata["max"]:
                        return False
            
            return True
    
    # dataclass 사용
    user = UserProfile(username="john_doe", email="john@example.com", age=25)
    print(f"  사용자 프로필: {user}")
    print(f"  검증 결과: {user.validate()}")
    
    # 필드 메타데이터 접근
    print(f"  필드 메타데이터:")
    for field_name, field_info in user.__dataclass_fields__.items():
        print(f"    {field_name}: {field_info.metadata}")
    
    # 4. 인자 검증 데코레이터
    print("\n4. 인자 검증 데코레이터:")
    
    def validate_arguments(validate_return=False):
        """
        인자와 반환값을 검증하는 데코레이터
        """
        def decorator(func):
            # 함수의 타입 힌트 가져오기
            type_hints = get_type_hints(func)
            sig = inspect.signature(func)
            
            def wrapper(*args, **kwargs):
                # 인자 검증
                bound_args = sig.bind(*args, **kwargs)
                bound_args.apply_defaults()
                
                print(f"  함수 호출: {func.__name__}")
                print(f"  바인딩된 인자: {bound_args.arguments}")
                
                # 타입 검증
                for param_name, expected_type in type_hints.items():
                    if param_name == "return":
                        continue
                    
                    if param_name in bound_args.arguments:
                        value = bound_args.arguments[param_name]
                        actual_type = type(value)
                        
                        # 타입 검사 (간단한 버전)
                        if hasattr(expected_type, "__origin__"):
                            # 제네릭 타입 (예: List[int])
                            origin = expected_type.__origin__
                            if not isinstance(value, origin):
                                raise TypeError(
                                    f"{param_name}: 기대 {expected_type}, 실제 {actual_type}"
                                )
                        elif not isinstance(value, expected_type):
                            raise TypeError(
                                f"{param_name}: 기대 {expected_type}, 실제 {actual_type}"
                            )
                
                # 함수 실행
                result = func(*args, **kwargs)
                
                # 반환값 검증
                if validate_return and "return" in type_hints:
                    expected_return_type = type_hints["return"]
                    if not isinstance(result, expected_return_type):
                        raise TypeError(
                            f"반환값: 기대 {expected_return_type}, 실제 {type(result)}"
                        )
                
                return result
            
            return wrapper
        return decorator
    
    # 데코레이터 적용 예제
    @validate_arguments(validate_return=True)
    def create_inventory_item(
        name: str,
        quantity: int,
        price: float,
        category: str = "general"
    ) -> dict:
        """재고 항목 생성"""
        return {
            "name": name,
            "quantity": quantity,
            "price": price,
            "category": category,
            "total_value": quantity * price
        }
    
    # 올바른 호출
    try:
        item = create_inventory_item("노트북", 10, 1299.99, "전자제품")
        print(f"  생성된 항목: {item}")
    except TypeError as e:
        print(f"  타입 오류: {e}")
    
    # 잘못된 호출 (주석 해제 시 오류)
    # create_inventory_item("노트북", "10", 1299.99)  # quantity가 문자열

function_annotations_metadata()
```

### 인자 메타데이터를 활용한 문서화와 검증

```python
def metadata_documentation_and_validation():
    """메타데이터를 활용한 문서화와 검증 시스템"""
    
    print("\n=== 메타데이터 기반 문서화와 검증 ===")
    
    import json
    from enum import Enum
    
    # 1. 열거형을 활용한 타입 정의
    class UserRole(Enum):
        """사용자 역할"""
        ADMIN = "admin"
        MANAGER = "manager"
        USER = "user"
        GUEST = "guest"
    
    class ProductCategory(Enum):
        """제품 카테고리"""
        ELECTRONICS = "electronics"
        BOOKS = "books"
        CLOTHING = "clothing"
        FOOD = "food"
    
    # 2. 메타데이터가 풍부한 함수
    def register_product(
        name: str = field(
            metadata={
                "description": "제품 이름",
                "min_length": 2,
                "max_length": 100,
                "required": True
            }
        ),
        price: float = field(
            metadata={
                "description": "제품 가격",
                "min": 0.0,
                "max": 1000000.0,
                "required": True
            }
        ),
        category: ProductCategory = field(
            metadata={
                "description": "제품 카테고리",
                "choices": [c.value for c in ProductCategory],
                "required": True
            }
        ),
        stock: int = field(
            default=0,
            metadata={
                "description": "재고 수량",
                "min": 0,
                "required": False
            }
        ),
        description: str = field(
            default="",
            metadata={
                "description": "제품 설명",
                "max_length": 1000,
                "required": False
            }
        )
    ) -> dict:
        """
        제품 등록 함수
        
        매개변수:
            name: 제품 이름
            price: 제품 가격
            category: 제품 카테고리
            stock: 재고 수량
            description: 제품 설명
            
        반환값:
            등록된 제품 정보
        """
        # 실제 구현 (시뮬레이션)
        product = {
            "id": f"prod_{int(time.time())}",
            "name": name,
            "price": price,
            "category": category.value if isinstance(category, ProductCategory) else category,
            "stock": stock,
            "description": description,
            "registered_at": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        return product
    
    # field 함수 정의 (데모용)
    def field(default=inspect.Parameter.empty, **metadata):
        """필드 메타데이터 생성 헬퍼"""
        return default if not metadata else metadata
    
    # 3. 메타데이터 기반 문서 생성기
    class FunctionDocumenter:
        """함수 메타데이터 기반 문서 생성기"""
        
        @staticmethod
        def generate_docs(func):
            """함수 문서 생성"""
            import inspect
            
            sig = inspect.signature(func)
            docs = {
                "name": func.__name__,
                "docstring": func.__doc__,
                "parameters": [],
                "returns": None
            }
            
            # 매개변수 정보 수집
            for param_name, param in sig.parameters.items():
                param_info = {
                    "name": param_name,
                    "type": str(param.annotation) if param.annotation != inspect.Parameter.empty else "any",
                    "default": param.default if param.default != inspect.Parameter.empty else None,
                    "kind": param.kind.name,
                    "metadata": {}
                }
                
                # 메타데이터 추출 (field 호출인 경우)
                if param.default != inspect.Parameter.empty and isinstance(param.default, dict):
                    if "description" in param.default:
                        param_info["metadata"] = param.default
                
                docs["parameters"].append(param_info)
            
            # 반환값 정보
            if sig.return_annotation != inspect.Signature.empty:
                docs["returns"] = {
                    "type": str(sig.return_annotation),
                    "description": "함수 반환값"
                }
            
            return docs
        
        @staticmethod
        def generate_markdown(func):
            """마크다운 형식 문서 생성"""
            docs = FunctionDocumenter.generate_docs(func)
            
            markdown = f"# {docs['name']}\n\n"
            
            if docs['docstring']:
                markdown += f"{docs['docstring']}\n\n"
            
            markdown += "## 매개변수\n\n"
            markdown += "| 이름 | 타입 | 기본값 | 필수 | 설명 |\n"
            markdown += "|------|------|--------|------|------|\n"
            
            for param in docs['parameters']:
                param_name = param['name']
                param_type = param['type']
                param_default = param['default'] if param['default'] is not None else "없음"
                
                # 필수 여부 판단
                is_required = param['default'] is None and param['kind'] != 'VAR_KEYWORD'
                
                # 메타데이터에서 설명 추출
                description = param['metadata'].get('description', '')
                
                markdown += f"| {param_name} | {param_type} | {param_default} | {'예' if is_required else '아니오'} | {description} |\n"
            
            if docs['returns']:
                markdown += f"\n## 반환값\n\n"
                markdown += f"- **타입**: {docs['returns']['type']}\n"
                markdown += f"- **설명**: {docs['returns']['description']}\n"
            
            return markdown
    
    # 4. 메타데이터 기반 검증기
    class ArgumentValidator:
        """메타데이터 기반 인자 검증기"""
        
        @staticmethod
        def validate_arguments(func, *args, **kwargs):
            """인자 검증"""
            import inspect
            
            sig = inspect.signature(func)
            bound_args = sig.bind(*args, **kwargs)
            bound_args.apply_defaults()
            
            errors = []
            
            for param_name, param in sig.parameters.items():
                if param_name in bound_args.arguments:
                    value = bound_args.arguments[param_name]
                    
                    # 메타데이터 추출
                    metadata = {}
                    if param.default != inspect.Parameter.empty and isinstance(param.default, dict):
                        metadata = param.default
                    
                    # 검증 실행
                    validation_error = ArgumentValidator._validate_value(
                        param_name, value, metadata
                    )
                    
                    if validation_error:
                        errors.append(validation_error)
            
            if errors:
                raise ValueError(f"인자 검증 실패:\n" + "\n".join(errors))
        
        @staticmethod
        def _validate_value(param_name, value, metadata):
            """개별 값 검증"""
            errors = []
            
            # 길이 검증
            if "min_length" in metadata and isinstance(value, str):
                if len(value) < metadata["min_length"]:
                    errors.append(f"{param_name}: 최소 길이 {metadata['min_length']} 이상 필요")
            
            if "max_length" in metadata and isinstance(value, str):
                if len(value) > metadata["max_length"]:
                    errors.append(f"{param_name}: 최대 길이 {metadata['max_length']} 이하 필요")
            
            # 범위 검증
            if "min" in metadata and isinstance(value, (int, float)):
                if value < metadata["min"]:
                    errors.append(f"{param_name}: 최소값 {metadata['min']} 이상 필요")
            
            if "max" in metadata and isinstance(value, (int, float)):
                if value > metadata["max"]:
                    errors.append(f"{param_name}: 최대값 {metadata['max']} 이하 필요")
            
            # 선택지 검증
            if "choices" in metadata:
                if value not in metadata["choices"]:
                    choices_str = ", ".join(str(c) for c in metadata["choices"])
                    errors.append(f"{param_name}: {choices_str} 중 하나여야 함")
            
            # 패턴 검증
            if "pattern" in metadata and isinstance(value, str):
                import re
                if not re.match(metadata["pattern"], value):
                    errors.append(f"{param_name}: 패턴 {metadata['pattern']} 불일치")
            
            return "\n".join(errors) if errors else None
    
    # 문서화 및 검증 데모
    print("1. 함수 문서 생성:")
    docs = FunctionDocumenter.generate_docs(register_product)
    print(json.dumps(docs, indent=2, ensure_ascii=False))
    
    print("\n2. 마크다운 문서:")
    markdown_docs = FunctionDocumenter.generate_markdown(register_product)
    print(markdown_docs)
    
    print("\n3. 인자 검증 테스트:")
    
    # 올바른 호출
    try:
        ArgumentValidator.validate_arguments(
            register_product,
            "스마트폰",
            999.99,
            ProductCategory.ELECTRONICS,
            stock=50,
            description="최신 스마트폰 모델"
        )
        print("  검증 통과: 올바른 인자")
    except ValueError as e:
        print(f"  검증 실패: {e}")
    
    # 잘못된 호출
    try:
        ArgumentValidator.validate_arguments(
            register_product,
            "A",  # 너무 짧은 이름
            -100.0,  # 음수 가격
            "invalid_category",  # 잘못된 카테고리
            stock=-10  # 음수 재고
        )
    except ValueError as e:
        print(f"  검증 실패 (예상): {e}")

metadata_documentation_and_validation()
```

## 함수에서 여러 값 반환하기

파이썬에서는 여러 값을 반환하는 것이 매우 자연스럽습니다. 튜플을 사용하거나 명명된 튜플, 데이터 클래스, 딕셔너리 등을 활용할 수 있습니다.

### 다양한 다중 반환 방법

```python
def multiple_return_values():
    """함수에서 여러 값을 반환하는 다양한 방법"""
    
    print("\n=== 여러 값 반환하기 ===")
    
    # 1. 기본적인 튜플 반환
    def calculate_statistics(numbers):
        """기본 통계량 계산 (튜플 반환)"""
        if not numbers:
            return 0, 0, 0, 0, 0
        
        count = len(numbers)
        total = sum(numbers)
        mean = total / count
        minimum = min(numbers)
        maximum = max(numbers)
        
        return count, total, mean, minimum, maximum
    
    print("1. 기본 튜플 반환:")
    data = [10, 20, 30, 40, 50]
    stats = calculate_statistics(data)
    
    print(f"  원시 결과: {stats}")
    print(f"  타입: {type(stats)}")
    
    # 언패킹
    count, total, mean, min_val, max_val = stats
    print(f"  언패킹: count={count}, total={total}, mean={mean:.2f}")
    
    # 2. 딕셔너리 반환 (명시적인 이름)
    def analyze_dataset(data):
        """데이터셋 분석 (딕셔너리 반환)"""
        if not data:
            return {
                "count": 0,
                "sum": 0,
                "mean": 0,
                "median": 0,
                "std": 0,
                "range": 0
            }
        
        import statistics
        
        analysis = {
            "count": len(data),
            "sum": sum(data),
            "mean": statistics.mean(data),
            "median": statistics.median(data),
            "std": statistics.stdev(data) if len(data) > 1 else 0,
            "range": max(data) - min(data),
            "min": min(data),
            "max": max(data)
        }
        
        return analysis
    
    print("\n2. 딕셔너리 반환:")
    analysis = analyze_dataset(data)
    
    print(f"  분석 결과:")
    for key, value in analysis.items():
        print(f"    {key}: {value}")
    
    # 특정 값 접근
    print(f"  평균: {analysis['mean']:.2f}")
    print(f"  범위: {analysis['range']}")
    
    # 3. 명명된 튜플 (NamedTuple)
    from typing import NamedTuple
    
    class AnalysisResult(NamedTuple):
        """분석 결과를 위한 명명된 튜플"""
        count: int
        total: float
        mean: float
        min: float
        max: float
        variance: float
    
    def analyze_with_namedtuple(numbers):
        """명명된 튜플 반환"""
        if not numbers:
            return AnalysisResult(0, 0.0, 0.0, 0.0, 0.0, 0.0)
        
        count = len(numbers)
        total = sum(numbers)
        mean = total / count
        minimum = min(numbers)
        maximum = max(numbers)
        
        # 분산 계산
        squared_diffs = [(x - mean) ** 2 for x in numbers]
        variance = sum(squared_diffs) / count
        
        return AnalysisResult(count, total, mean, minimum, maximum, variance)
    
    print("\n3. 명명된 튜플 반환:")
    named_result = analyze_with_namedtuple(data)
    
    print(f"  결과: {named_result}")
    print(f"  타입: {type(named_result)}")
    print(f"  필드: {named_result._fields}")
    
    # 이름으로 접근
    print(f"  평균: {named_result.mean:.2f}")
    print(f"  분산: {named_result.variance:.2f}")
    
    # 인덱스로도 접근 가능
    print(f"  첫 번째 값: {named_result[0]}")
    
    # 언패킹
    count, total, mean, min_val, max_val, variance = named_result
    print(f"  언패킹된 분산: {variance:.2f}")
    
    # 4. 데이터 클래스 반환
    from dataclasses import dataclass
    from typing import List, Optional
    
    @dataclass
    class ProcessResult:
        """프로세스 실행 결과"""
        success: bool
        message: str
        data: Optional[dict] = None
        errors: List[str] = None
        execution_time: float = 0.0
        
        def __post_init__(self):
            if self.errors is None:
                self.errors = []
        
        def to_dict(self):
            """딕셔너리 변환"""
            return {
                "success": self.success,
                "message": self.message,
                "data": self.data,
                "error_count": len(self.errors),
                "execution_time": self.execution_time
            }
    
    def process_data(data_input):
        """데이터 처리 함수"""
        import time
        
        start_time = time.time()
        errors = []
        
        try:
            # 시뮬레이션: 데이터 처리
            processed_data = {
                "original": data_input,
                "processed": data_input.upper() if isinstance(data_input, str) else data_input,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
            }
            
            # 시뮬레이션: 오류 발생 가능성
            if data_input == "error":
                errors.append("의도된 오류 발생")
                raise ValueError("처리 오류")
            
            execution_time = time.time() - start_time
            
            return ProcessResult(
                success=True,
                message="처리 완료",
                data=processed_data,
                errors=errors,
                execution_time=execution_time
            )
            
        except Exception as e:
            errors.append(str(e))
            execution_time = time.time() - start_time
            
            return ProcessResult(
                success=False,
                message="처리 실패",
                errors=errors,
                execution_time=execution_time
            )
    
    print("\n4. 데이터 클래스 반환:")
    
    # 성공 케이스
    result1 = process_data("test data")
    print(f"  성공 결과:")
    print(f"    성공 여부: {result1.success}")
    print(f"    메시지: {result1.message}")
    print(f"    데이터: {result1.data}")
    print(f"    실행 시간: {result1.execution_time:.4f}초")
    
    # 실패 케이스
    result2 = process_data("error")
    print(f"  실패 결과:")
    print(f"    성공 여부: {result2.success}")
    print(f"    오류 수: {len(result2.errors)}")
    print(f"    오류 목록: {result2.errors}")
    
    # 딕셔너리 변환
    print(f"  딕셔너리 표현: {result1.to_dict()}")

multiple_return_values()
```

### 실전 예제: 복잡한 작업 결과 반환

```python
def practical_multiple_return_examples():
    """실전적인 다중 반환 예제"""
    
    print("\n=== 실전 다중 반환 패턴 ===")
    
    import math
    from enum import Enum
    from dataclasses import dataclass
    from typing import Tuple, Dict, Any, Optional
    
    # 1. 파일 처리 결과 반환
    class FileOperationStatus(Enum):
        """파일 작업 상태"""
        SUCCESS = "success"
        PARTIAL = "partial"
        FAILED = "failed"
        SKIPPED = "skipped"
    
    @dataclass
    class FileOperationResult:
        """파일 작업 결과"""
        status: FileOperationStatus
        file_path: str
        bytes_processed: int = 0
        error_message: Optional[str] = None
        metadata: Dict[str, Any] = None
        
        def __post_init__(self):
            if self.metadata is None:
                self.metadata = {}
        
        def is_successful(self):
            """성공 여부 확인"""
            return self.status == FileOperationStatus.SUCCESS
        
        def summary(self):
            """요약 정보"""
            return {
                "file": self.file_path,
                "status": self.status.value,
                "size": self.bytes_processed,
                "success": self.is_successful()
            }
    
    def process_file_batch(file_paths, operation="read"):
        """파일 배치 처리"""
        results = []
        total_bytes = 0
        successful_operations = 0
        
        for file_path in file_paths:
            try:
                # 파일 처리 시뮬레이션
                if "error" in file_path:
                    raise IOError(f"{file_path} 처리 중 오류 발생")
                
                # 처리 크기 시뮬레이션
                bytes_processed = len(file_path) * 100  # 간단한 계산
                total_bytes += bytes_processed
                
                result = FileOperationResult(
                    status=FileOperationStatus.SUCCESS,
                    file_path=file_path,
                    bytes_processed=bytes_processed,
                    metadata={
                        "operation": operation,
                        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
                    }
                )
                successful_operations += 1
                
            except Exception as e:
                result = FileOperationResult(
                    status=FileOperationStatus.FAILED,
                    file_path=file_path,
                    error_message=str(e)
                )
            
            results.append(result)
        
        # 배치 전체 통계
        batch_summary = {
            "total_files": len(file_paths),
            "successful": successful_operations,
            "failed": len(file_paths) - successful_operations,
            "total_bytes": total_bytes,
            "success_rate": successful_operations / len(file_paths) if file_paths else 0
        }
        
        return results, batch_summary
    
    print("1. 파일 배치 처리 결과:")
    
    test_files = ["data1.txt", "data2.csv", "error_file.txt", "data3.json"]
    results, summary = process_file_batch(test_files)
    
    print(f"  배치 요약:")
    for key, value in summary.items():
        print(f"    {key}: {value}")
    
    print(f"  개별 결과:")
    for result in results[:2]:  # 처음 2개만 출력
        print(f"    {result.file_path}: {result.status.value}")
    
    # 2. 수학적 계산 결과 반환
    def solve_quadratic(a: float, b: float, c: float) -> Tuple[bool, Optional[Tuple[complex, complex]]]:
        """
        2차 방정식 해 구하기
        반환: (해 존재 여부, (해1, 해2) 또는 None)
        """
        if a == 0:
            # 1차 방정식
            if b == 0:
                return False, None  # 해 없음
            root = -c / b
            return True, (complex(root), complex(root))
        
        # 판별식 계산
        discriminant = b**2 - 4*a*c
        
        if discriminant >= 0:
            # 실근
            root1 = (-b + math.sqrt(discriminant)) / (2*a)
            root2 = (-b - math.sqrt(discriminant)) / (2*a)
        else:
            # 허근
            real_part = -b / (2*a)
            imag_part = math.sqrt(-discriminant) / (2*a)
            root1 = complex(real_part, imag_part)
            root2 = complex(real_part, -imag_part)
        
        return True, (root1, root2)
    
    print("\n2. 수학적 계산 결과:")
    
    test_cases = [
        (1, -3, 2),   # x^2 - 3x + 2 = 0, 실근: 1, 2
        (1, 0, 1),    # x^2 + 1 = 0, 허근: i, -i
        (0, 0, 1),    # 0 = 1, 해 없음
        (0, 2, -4)    # 2x - 4 = 0, 실근: 2
    ]
    
    for a, b, c in test_cases:
        has_solution, roots = solve_quadratic(a, b, c)
        
        if has_solution and roots:
            root1, root2 = roots
            print(f"  {a}x² + {b}x + {c} = 0:")
            print(f"    해1: {root1}")
            print(f"    해2: {root2}")
        else:
            print(f"  {a}x² + {b}x + {c} = 0: 해 없음")
    
    # 3. API 응답 처리
    @dataclass
    class APIResponse:
        """API 응답을 위한 데이터 클래스"""
        success: bool
        status_code: int
        data: Optional[Dict[str, Any]] = None
        error: Optional[str] = None
        pagination: Optional[Dict[str, Any]] = None
        metadata: Dict[str, Any] = None
        
        def __post_init__(self):
            if self.metadata is None:
                self.metadata = {}
        
        @classmethod
        def from_http_response(cls, status_code, response_data):
            """HTTP 응답으로부터 생성"""
            success = 200 <= status_code < 300
            
            if success:
                return cls(
                    success=True,
                    status_code=status_code,
                    data=response_data.get("data"),
                    pagination=response_data.get("pagination"),
                    metadata=response_data.get("metadata", {})
                )
            else:
                return cls(
                    success=False,
                    status_code=status_code,
                    error=response_data.get("error", "Unknown error"),
                    metadata=response_data.get("metadata", {})
                )
        
        def validate(self, schema=None):
            """응답 검증"""
            if not self.success:
                return False, f"API 실패: {self.error}"
            
            if schema and self.data:
                # 실제로는 schema 검증 로직 구현
                pass
            
            return True, "검증 성공"
    
    def fetch_user_data(user_id, include_posts=False):
        """사용자 데이터 조회 (시뮬레이션)"""
        import random
        
        # 시뮬레이션: API 호출
        success = random.random() > 0.2  # 80% 성공률
        
        if success:
            user_data = {
                "id": user_id,
                "name": f"사용자{user_id}",
                "email": f"user{user_id}@example.com",
                "age": random.randint(20, 50)
            }
            
            if include_posts:
                user_data["posts"] = [
                    {"id": i, "title": f"포스트 {i}", "content": f"내용 {i}"}
                    for i in range(random.randint(1, 5))
                ]
            
            response_data = {
                "data": user_data,
                "pagination": {
                    "page": 1,
                    "total_pages": 1,
                    "total_items": 1
                },
                "metadata": {
                    "request_id": f"req_{int(time.time())}",
                    "processing_time": random.uniform(0.1, 0.5)
                }
            }
            
            return APIResponse.from_http_response(200, response_data)
        
        else:
            # 실패 응답
            error_data = {
                "error": f"사용자 {user_id}를 찾을 수 없음",
                "metadata": {
                    "request_id": f"req_{int(time.time())}",
                    "error_code": "USER_NOT_FOUND"
                }
            }
            
            return APIResponse.from_http_response(404, error_data)
    
    print("\n3. API 응답 처리:")
    
    # 여러 사용자 데이터 조회
    user_ids = [1, 2, 3, 999]  # 999는 존재하지 않는 사용자
    
    for user_id in user_ids:
        response = fetch_user_data(user_id, include_posts=True)
        
        if response.success:
            user_name = response.data.get("name", "N/A")
            post_count = len(response.data.get("posts", []))
            print(f"  사용자 {user_id}({user_name}): 성공, 포스트 {post_count}개")
        else:
            print(f"  사용자 {user_id}: 실패 - {response.error}")
    
    # 4. 복합 작업의 단계별 결과 반환
    print("\n4. 복합 작업 단계별 결과:")
    
    class ProcessingStep(Enum):
        """처리 단계"""
        VALIDATION = "validation"
        TRANSFORMATION = "transformation"
        PERSISTENCE = "persistence"
        NOTIFICATION = "notification"
    
    @dataclass
    class ProcessingResult:
        """처리 결과"""
        step: ProcessingStep
        success: bool
        duration: float
        input_data: Any
        output_data: Any = None
        error: Optional[str] = None
        warnings: List[str] = None
        
        def __post_init__(self):
            if self.warnings is None:
                self.warnings = []
    
    def process_data_pipeline(input_data):
        """데이터 처리 파이프라인"""
        import time
        
        results = []
        current_data = input_data
        
        # 1. 검증 단계
        start = time.time()
        try:
            if not isinstance(current_data, dict):
                raise ValueError("데이터는 딕셔너리여야 함")
            
            duration = time.time() - start
            results.append(ProcessingResult(
                step=ProcessingStep.VALIDATION,
                success=True,
                duration=duration,
                input_data=input_data,
                output_data=current_data
            ))
            
        except Exception as e:
            duration = time.time() - start
            results.append(ProcessingResult(
                step=ProcessingStep.VALIDATION,
                success=False,
                duration=duration,
                input_data=input_data,
                error=str(e)
            ))
            return results  # 검증 실패 시 종료
        
        # 2. 변환 단계
        start = time.time()
        try:
            # 데이터 변환
            transformed = {
                "processed_" + k: v.upper() if isinstance(v, str) else v
                for k, v in current_data.items()
            }
            transformed["processed_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
            
            duration = time.time() - start
            results.append(ProcessingResult(
                step=ProcessingStep.TRANSFORMATION,
                success=True,
                duration=duration,
                input_data=current_data,
                output_data=transformed
            ))
            current_data = transformed
            
        except Exception as e:
            duration = time.time() - start
            results.append(ProcessingResult(
                step=ProcessingStep.TRANSFORMATION,
                success=False,
                duration=duration,
                input_data=current_data,
                error=str(e)
            ))
            return results
        
        # 3. 저장 단계 (시뮬레이션)
        start = time.time()
        try:
            # 저장 로직
            time.sleep(0.1)  # 저장 시간 시뮬레이션
            
            saved_id = f"record_{int(time.time())}"
            saved_data = {**current_data, "id": saved_id}
            
            duration = time.time() - start
            results.append(ProcessingResult(
                step=ProcessingStep.PERSISTENCE,
                success=True,
                duration=duration,
                input_data=current_data,
                output_data=saved_data
            ))
            current_data = saved_data
            
        except Exception as e:
            duration = time.time() - start
            results.append(ProcessingResult(
                step=ProcessingStep.PERSISTENCE,
                success=False,
                duration=duration,
                input_data=current_data,
                error=str(e)
            ))
            return results
        
        # 4. 알림 단계 (시뮬레이션)
        start = time.time()
        try:
            # 알림 전송
            notification = f"데이터 처리 완료: {current_data.get('id')}"
            
            duration = time.time() - start
            results.append(ProcessingResult(
                step=ProcessingStep.NOTIFICATION,
                success=True,
                duration=duration,
                input_data=current_data,
                output_data=notification,
                warnings=["알림은 시뮬레이션입니다."]
            ))
            
        except Exception as e:
            duration = time.time() - start
            results.append(ProcessingResult(
                step=ProcessingStep.NOTIFICATION,
                success=False,
                duration=duration,
                input_data=current_data,
                error=str(e)
            ))
        
        return results
    
    # 파이프라인 실행
    test_data = {"name": "test", "value": 123}
    pipeline_results = process_data_pipeline(test_data)
    
    print("  파이프라인 실행 결과:")
    for result in pipeline_results:
        status = "✓" if result.success else "✗"
        print(f"    {status} {result.step.value}: {result.duration:.3f}초")
        if result.error:
            print(f"      오류: {result.error}")
        if result.warnings:
            print(f"      경고: {', '.join(result.warnings)}")
    
    # 전체 성공 여부 확인
    all_successful = all(r.success for r in pipeline_results)
    print(f"  전체 성공: {'예' if all_successful else '아니오'}")

practical_multiple_return_examples()
```

## 결론

파이썬의 함수 설계 기법은 간단한 유틸리티부터 복잡한 시스템까지 다양한 요구사항을 충족시킬 수 있는 강력한 도구들을 제공합니다.

가변 인자(`*args`, `**kwargs`)를 활용하면 인자 개수와 형식에 구애받지 않는 유연한 함수를 작성할 수 있습니다. 특히 데이터 처리, 로깅, 설정 관리 등 다양한 상황에서 유용하게 활용됩니다. 키워드 전용 인자(Keyword-only arguments)는 함수의 가독성과 안정성을 크게 향상시키며, 특히 많은 옵션을 가진 함수에서 매개변수 순서 오류를 방지하는 데 효과적입니다.

함수 인자에 메타데이터를 추가하는 것은 현대적인 파이썬 프로그래밍의 핵심 기술입니다. 타입 힌트를 통해 정적 분석 도구의 지원을 받을 수 있고, 커스텀 어노테이션을 통해 문서화, 검증, 직렬화 등의 추가 기능을 구현할 수 있습니다. 특히 `dataclass`와의 조합은 강력한 타입 안전성과 메타데이터 관리를 제공합니다.

함수에서 여러 값을 반환하는 다양한 패턴은 상황에 맞게 선택해야 합니다. 단순한 값들의 집합은 튜플이 적합하고, 명시적인 이름이 필요하면 명명된 튜플이나 딕셔너리를, 복잡한 데이터 구조와 메서드가 필요하면 데이터 클래스를 사용하는 것이 좋습니다. 실전에서는 작업의 성공/실패 상태, 에러 정보, 메타데이터 등을 포함한 포괄적인 결과 객체를 반환하는 패턴이 점점 더 중요해지고 있습니다.

이러한 기법들을 적절히 조합하고 상황에 맞게 적용하면 더욱 강력하고 유지보수하기 쉬운 파이썬 코드를 작성할 수 있습니다. 각 기법의 특징을 이해하고, 프로젝트의 요구사항과 팀의 코딩 규칙에 맞춰 적절한 설계 패턴을 선택하는 것이 중요합니다.