---
layout: post
title: JavaScript - ES6 이후 주요 문법 변화 정리
date: 2025-05-04 21:20:23 +0900
category: JavaScript
---
# ES6 이후 주요 문법 변화 정리

## — 대격변의 시작

### `let`/`const` (블록 스코프, TDZ, 재선언 금지)

```js
{
  // TDZ(Temporal Dead Zone): 선언 전 접근 금지
  // console.log(a); // ReferenceError
  let a = 1;
  const b = 2;
  a = 3;        // OK
  // b = 4;     // TypeError: const 재할당 불가
}
// console.log(a); // ReferenceError: 블록 밖
```
- **TDZ**: 선언 전에 접근하면 `ReferenceError`.
- **for 루프 클로저 문제 해결**: `let`은 반복마다 새 바인딩 생성.

```js
const fns = [];
for (let i = 0; i < 3; i++) fns.push(() => i);
console.log(fns.map(fn => fn())); // [0,1,2]
```

### 화살표 함수(lexical `this`, `arguments` 없음, `new` 불가)

```js
const add = (a, b) => a + b;
const obj = {
  x: 10,
  incLater() {
    setTimeout(() => { this.x++; console.log(this.x); }, 0);
  }
};
obj.incLater(); // 11
```
- `this`가 **상위 스코프**로 고정(이벤트/타이머 콜백에 유용).
- 생성자로 **사용 불가**(`new` 금지), `prototype` 없음.

### 템플릿 리터럴(멀티라인, 인터폴레이션, 태그드 템플릿)

```js
const name = "Alice", score = 95;
console.log(`Hello, ${name}. Score=${score}.`);
```
```js
function tag(strings, ...vals) { /* 보안 템플릿/국제화 등 */ }
tag`unsafe: ${userInput}`;
```

### 구조 분해 할당(배열/객체, 기본값/별칭/나머지)

```js
const [a, , c=3] = [1,2];
const {x: x1, y=20, ...rest} = {x:10, z:30};
```
- **기본값은 `undefined`일 때만** 적용(= `null`이면 적용 안 됨).

### 기본 매개변수 / 나머지·전개(Spread/Rest)

```js
function greet(name="Guest"){ return `Hi, ${name}`; }
function sum(...nums){ return nums.reduce((a,b)=>a+b,0); }
const merged = [...[1,2], ...[3,4]];
```
- **얕은(shallow)** 복사/병합. 접근자·프로토타입은 보존되지 않음(객체 Spread는 ES9에서 명세화).

### 클래스(프로토타입 문법의 설탕, `extends`, `super`)

```js
class Person {
  constructor(name){ this.name = name; }
  hi(){ return `Hi, ${this.name}`; }
}
class Student extends Person {
  hi(){ return super.hi() + " (student)"; }
}
```
- 클래스 메서드는 **열거 불가**(enumerable: false), 내부는 **strict mode**.
- **필드 선언**은 ES13(2022) 표준—아래 8.3 참고.

### 모듈(정적 `import`/`export`, 라이브 바인딩)

```js
// math.js
export const PI = 3.14;
export default function area(r){ return PI*r*r; }

// app.js (모듈 로더 환경 필요)
import area, { PI } from "./math.js";
```
- **정적 분석 가능**: 트리 셰이킹, 정적 의존성 파악.
- **동적 import**는 ES11(2020) — 6.5 참고.

### `Promise`(비동기 제어의 기본)

```js
new Promise((resolve,reject)=>setTimeout(()=>resolve(7),100))
  .then(v => v*2)            // 14
  .catch(console.error);
```

### `Symbol`(고유 키, 내부 프로토콜)

```js
const k = Symbol("id");
const obj = { [k]: 123 };
```

### `Map`/`Set`/`WeakMap`/`WeakSet`

```js
const m = new Map([["a",1]]);
m.get("a"); // 1
```
- `Weak*`는 GC 친화(키로만 약참조) — **열거 불가**, 순회 X.

### 이터레이터/제너레이터

```js
function* gen(){ yield 1; yield 2; }
for (const v of gen()) console.log(v); // 1,2
```

### `for...of` (이터러블 순회, 배열에 적합)

```js
for (const v of [10,20]) console.log(v);
```

---

## ES7(2016)

### `Array.prototype.includes`

```js
[1,2,NaN].includes(NaN); // true
```

### 지수 연산자 `**` (오른결합)

```js
2 ** 3 ** 2; // 2 ** (3 ** 2) = 512
```

---

## ES8(2017)

### `async`/`await`

```js
async function fetchJson(url){
  const res = await fetch(url);
  return res.json();
}
```

### `Object.values` / `Object.entries` / `Object.getOwnPropertyDescriptors`

```js
const o = {a:1, get b(){return 2;}};
Object.values(o);  // [1,2]
Object.entries(o); // [["a",1],["b",2]]
Object.getOwnPropertyDescriptors(o); // 디스크립터 일괄 조회
```

### 문자열 패딩

```js
"5".padStart(3,"0"); // "005"
```

### `SharedArrayBuffer`/`Atomics` (저수준 동시성; 브라우저 보안 정책 영향)

### trailing commas(함수 매개변수/호출 위치 허용)

---

## ES9(2018)

### **객체 Rest/Spread**(정식 명세)

```js
const {a, ...rest} = {a:1,b:2,c:3}; // rest={b:2,c:3}
const merged = { ...{x:1}, ...{x:9,y:2} }; // {x:9,y:2}
```
- **own + enumerable**만 복사, **얕은** 동작, **접근자 → 값**으로 평가 복사.

### `Promise.prototype.finally`

```js
doAsync().then(ok).catch(err).finally(cleanup);
```

### 정규식 개선

- **dotAll `s`**: `.`이 개행 포함
- **명명 캡처 그룹**: `/(?<year>\d{4})/`
- **후방탐색 `(?<=...)`**, **유니코드 속성 `\p{...}`**
- **`RegExp.prototype.unicode`/`sticky` 등 활용 강화**

### **Async Iteration**: `for await...of`

```js
async function* pages(){ yield fetch('/p1'); yield fetch('/p2'); }
for await (const r of pages()) console.log(await r.text());
```

---

## ES10(2019)

### `Array.prototype.flat` / `flatMap`

```js
[1,[2,[3]]].flat(2);           // [1,2,3]
["a","b"].flatMap(x=>[x,x]);   // ["a","a","b","b"]
```

### `Object.fromEntries`

```js
Object.fromEntries([["a",1],["b",2]]); // {a:1,b:2}
```

### `trimStart`/`trimEnd`, `Symbol.prototype.description`, `JSON.stringify` 안정화,

**Optional catch binding**:
```js
try { throw new Error(); } catch { /* 변수 없이 */ }
```

---

## ES11(2020)

### **Optional Chaining `?.`**

```js
user?.address?.city ?? "N/A";
```

### **Nullish Coalescing `??`**

```js
const port = cfg.port ?? 3000; // 0/"" 는 유지, null/undefined만 대체
```

### `Promise.allSettled`

```js
const results = await Promise.allSettled([p1, p2, p3]);
```

### `globalThis` (환경 중립 전역)

```js
globalThis.setTimeout === setTimeout; // true
```

### **Dynamic `import()`**, `import.meta`

```js
const mod = await import('./heavy.js');
console.log(import.meta.url); // 모듈 URL
```

### `BigInt`

```js
const big = 10n ** 20n;
```

### `String.prototype.matchAll` (모든 매치 이터레이터)

```js
[... "a1b2".matchAll(/\d/g)].map(m=>m[0]); // ["1","2"]
```

---

## ES12(2021)

### **논리 할당 연산자**: `||=`, `&&=`, `??=`

```js
cfg.timeout ||= 5000; // falsy면 대입
cfg.token &&= cfg.token.trim(); // truthy면 대입
env.port ??= 8080;   // null/undefined면 대입
```

### **Numeric Separators** (가독성)

```js
const billion = 1_000_000_000;
```

### **`String.prototype.replaceAll`**

```js
"hello".replaceAll("l","-"); // "he--o"
```

### **`Promise.any`** + `AggregateError`

```js
try {
  const first = await Promise.any([p1, p2, p3]);
} catch (e) {
  if (e instanceof AggregateError) console.log(e.errors);
}
```

### `WeakRef` / `FinalizationRegistry` (고급 GC 제어 — 신중히 사용)

---

## ES13(2022)

### **Top-level `await`** (ESM 모듈 스코프)

```js
// main.mjs (모듈로 로드되어야 함)
const data = await fetch('/data.json').then(r=>r.json());
```
- 상단에서 비동기 준비가 가능하지만 **의존 그래프가 await에 의해 지연**될 수 있으므로 모듈 설계 유의.

### **`Object.hasOwn`** (명확한 소유 속성 검사)

```js
Object.hasOwn(obj, "key"); // hasOwnProperty 안전 대체
```

### **클래스 필드/프라이빗**(인스턴스/정적, private 필드/메서드, 정적 블록)

```js
class Counter {
  #count = 0                // private 인스턴스 필드
  static #seed = 1          // private 정적 필드
  label = "ctr"             // public 인스턴스 필드
  inc = () => this.#count++ // public 인스턴스 필드에 화살표(바인딩 고정)
  get value(){ return this.#count; }
  static {
    // 정적 초기화 블록
    this.#seed = Math.random();
  }
}
const c = new Counter();
c.inc(); c.value; // 1
// c.#count;      // SyntaxError: 외부 접근 불가
```

### **RegExp Match Indices `/d` 플래그**(매치 인덱스 제공)

```js
const m = /foo/d.exec("..foo..");
m.indices[0]; // [2,5]
```

### **`Error` 원인 옵션** (`cause`)

```js
try {
  throw new Error("DB failed", { cause: new Error("ECONNREFUSED") });
} catch (e) {
  console.log(e.cause.message); // "ECONNREFUSED"
}
```

### **`Array.prototype.at`**

```js
const arr = [10,20,30];
arr.at(-1); // 30 (음수 인덱스 지원)
```

---

## 실전 적용 팁(버전 혼용, 트랜스파일, 성능)

### 폴리필/트랜스파일

- **문법**(예: `class`, `??`, `?.`)은 **Babel**로 트랜스파일.
- **런타임 기능**(예: `Promise.any`, `Array.prototype.at`)은 **폴리필(Core-JS)** 필요.

### 옵셔널 체이닝/널 병합 안전 패턴

```js
const port = Number(process.env.PORT ?? 3000);
const city = user?.address?.city ?? "Unknown";
```

### `Promise` 병렬화 기본기

```js
// 나쁜 예: 순차
const a = await fa();
const b = await fb();

// 좋은 예: 병렬
const [a1,b1] = await Promise.all([fa(), fb()]);
```

### `class` 필드 vs 생성자 할당

```js
class X {
  // 필드 초기화는 명료, TS/IDE 친화
  cache = new Map();
  constructor(){ /* 로직만 */ }
}
```

### RegExp 최신 기능 점검

- 대용량 텍스트 처리 전 **`/u`/`/s`/`/d`** 지원 여부 확인.
- 후방탐색은 오래된 엔진에서 미지원 → 폴백 정규식 고려.

---

## 버전별 예제 모음(한 화면 요약)

### ES6 핵심 묶음

```js
const PI = 3.14;
const circle = r => `area=${PI*r*r}`;
const [h, ...t] = [1,2,3];
const {x:xx=0} = {x:10};
class A{ m(){return 1} }
class B extends A{ m(){ return super.m()+1 } }
export { PI, circle, B };
```

### ES9 객체 Rest/Spread

```js
const opt = { host:"localhost", port:5432, ssl:true };
const { ssl, ...conn } = opt;   // conn={host,port}
const def = { port:3306, ssl:false };
const final = { ...def, ...conn }; // {port:5432, host:"localhost"}
```

### ES11 옵셔널/널 병합

```js
config?.db?.retry ?? 3;
```

### ES12 논리 할당

```js
opts.retries ??= 2;
state.token &&= state.token.trim();
```

### ES13 클래스 프라이빗/정적 블록

```js
class Box {
  #v = 0; static all = 0;
  static { this.all = 100; }
  get v(){ return this.#v; }
}
```

---

## 흔한 함정/오해 체크리스트

- **객체 Spread는 깊은 복사 아님**: 중첩 객체는 참조 공유.
- **`??` vs `||`**: `??`는 `null/undefined`만 대체(0/''은 유지).
- **`forEach`에서 `await` 무의미**: `for...of`/`Promise.all` 사용.
- **Top-level `await`**: 모듈 **로딩 지연** 유발—의존 그래프 설계 유의.
- **프라이빗 필드 `#x`**는 **문자열 키가 아님**: 리플렉션 불가, 직렬화 주의.

---

## 성능 관점 요약

- **체이닝 남발**보다 **단일 패스**(`reduce`/루프) 고려(측정 필수).
- 대량 구조 분해·스프레드는 **임시 객체/배열** 비용↑—핫패스 최소화.
- 정규식 고급 플래그(`s`,`u`,`d`)는 편리하지만 **호환성/속도 측정**.

---

## — 참고용 제안/추가 표준

### **불변 배열 유틸**: `toSorted`/`toReversed`/`toSpliced`/`with`

```js
const a = [3,1,2];
a.toSorted();   // [1,2,3], 원본 불변
a.toReversed(); // [2,1,3] (예시)
a.with(0, 99);  // 새 배열(0번 교체)
```

### `findLast`/`findLastIndex`

```js
[1,3,2,5].findLast(x=>x%2===1); // 5
```

### `Symbol.dispose`/`using`(리소스 정리) — **스테이지 확인 필요**
### **JSON Import** / Import Assertions

> 실무 적용 시 **타깃 런타임 버전**과 **트랜스파일/폴리필 전략**을 함께 설계하세요.

---

## 요약 표 — ES6 이후 핵심 문법

| 버전 | 주요 문법(발췌) |
|------|-----------------|
| **ES6(2015)** | let/const, 화살표, 템플릿, 구조 분해, 기본인자/Rest·Spread, class/extends, 모듈, Promise, Symbol, Map/Set, 이터레이터/제너레이터 |
| **ES7(2016)** | `includes`, 지수 `**` |
| **ES8(2017)** | `async/await`, `Object.values/entries`, 패딩, `getOwnPropertyDescriptors`, `SharedArrayBuffer/Atomics` |
| **ES9(2018)** | 객체 Rest/Spread, `Promise.finally`, 정규식(`s`, 명명그룹, 후방탐색, `\p{}`), async iteration |
| **ES10(2019)** | `flat/flatMap`, `Object.fromEntries`, `trimStart/End`, optional catch binding |
| **ES11(2020)** | `?.`, `??`, `Promise.allSettled`, `globalThis`, `import()`, `import.meta`, `BigInt`, `matchAll` |
| **ES12(2021)** | `||=`, `&&=`, `??=`, 숫자 구분자, `replaceAll`, `Promise.any`, `WeakRef`, `FinalizationRegistry` |
| **ES13(2022)** | Top-level `await`, `Object.hasOwn`, 클래스 필드/프라이빗/정적 블록, RegExp `/d`, `Error.cause`, `Array.at` |
| **ES14+(참고)** | 불변 배열 유틸(toSorted 등), findLast 계열, JSON Import, (제안) dispose |

---

## 마무리

- **ES6~ES13**은 현대 JS의 **실전 핵심**: `async/await`, 옵셔널/널 병합, 객체/배열 Spread, 클래스(필드/프라이빗), 모듈, 새로운 배열/정규식/Promise API.
- **브라우저/Node 타깃**과 **번들러/바벨/폴리필 전략**을 함께 설계하면, 최신 문법을 **안전하게** 활용할 수 있습니다.
