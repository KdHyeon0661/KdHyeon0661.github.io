---
layout: post
title: 영상처리 - 영상의 대칭 변환
date: 2025-09-29 14:25:23 +0900
category: 영상처리
---
# 영상의 대칭 변환

## 1. 대칭(미러) 변환이란?

### 1.1 좌우(수평) 대칭 — Horizontal Flip
영상의 좌우를 뒤집습니다. 인덱스 좌표(픽셀 중심 무시)에서:
\[
x' = W - 1 - x,\quad y' = y.
\]
행렬로 쓰면, 중심을 영상 중앙 \(\left(\frac{W-1}{2},\,\frac{H-1}{2}\right)\) 기준으로:
\[
\begin{bmatrix}x'\\y'\\1\end{bmatrix}
=
\underbrace{\begin{bmatrix}-1&0&0\\0&1&0\\0&0&1\end{bmatrix}}_{\text{reflection }x\mapsto -x}
\text{ around center } \Rightarrow
\begin{bmatrix}x'\\y'\\1\end{bmatrix} =
T\;R_x\;T^{-1}\begin{bmatrix}x\\y\\1\end{bmatrix}.
\]

### 1.2 상하(수직) 대칭 — Vertical Flip
영상의 상하를 뒤집습니다(Top-Down DIB에서 \(y\)는 **아래로 증가**).
\[
x' = x,\quad y' = H - 1 - y.
\]

> 성질  
> - **좌우 + 상하**를 연속 적용 ≡ **180° 회전**.  
> - 대칭은 **길이·각도**는 보존하나 **방향성**(오른손/왼손)은 반전합니다.  
> - **텍스트/얼굴**의 좌우가 바뀌므로, 셀피 교정/좌우역상 디버깅에 자주 사용됩니다.

---

## 2. 구현 전략

- **Out-of-place**: `dst`를 새로 만들고 `src`에서 뒤집어 복사(안전, 직관).  
- **In-place**: 같은 버퍼에서 swap(메모리 절약, 더 빠름).  
- **알파 채널**: RGBA **4바이트 단위**로 처리 → A 보존.  
- **성능**: O(WH). In-place 수평 대칭은 **라인 내 4바이트 swap**, 수직 대칭은 **라인 전체 swap**으로 매우 빠릅니다.  
- **Stride**: 항상 `stride()` 사용(패딩 안전).

---

## 3. 코드: 미러 변환 (헤더)

```cpp
// Mirror.h
#pragma once
#include <cstdint>
#include <cstring>
#include <algorithm>
#include "IppDib.h"

// ---------------------------
// Out-of-place (안전 복사형)
// ---------------------------
inline void FlipHorizontal_BGRA32(const IppDib& src, IppDib& dst)
{
    if (!src) { dst = src; return; }
    const int W = src.width(), H = src.height();
    dst.create(W, H, 32);

    for (int y=0; y<H; ++y)
    {
        const uint8_t* srow = (const uint8_t*)src.bits() + (size_t)y*src.stride();
        uint8_t*       drow = (uint8_t*)dst.bits() + (size_t)y*dst.stride();

        // d(x) = s(W-1-x)
        for (int x=0; x<W; ++x)
        {
            const uint8_t* ps = &srow[(W-1-x)*4];
            uint8_t*       pd = &drow[x*4];
            // BGRA copy
            pd[0]=ps[0]; pd[1]=ps[1]; pd[2]=ps[2]; pd[3]=ps[3];
        }
    }
}

inline void FlipVertical_BGRA32(const IppDib& src, IppDib& dst)
{
    if (!src) { dst = src; return; }
    const int W = src.width(), H = src.height();
    dst.create(W, H, 32);

    for (int y=0; y<H; ++y)
    {
        const uint8_t* srow = (const uint8_t*)src.bits() + (size_t)(H-1-y)*src.stride();
        uint8_t*       drow = (uint8_t*)dst.bits() + (size_t)y*dst.stride();
        std::memcpy(drow, srow, (size_t)W*4);
    }
}

// ---------------------------
// In-place (버퍼 내 교환형)
// ---------------------------
inline void FlipHorizontalInplace_BGRA32(IppDib& img)
{
    if (!img) return;
    const int W = img.width(), H = img.height();
    for (int y=0; y<H; ++y)
    {
        uint8_t* row = (uint8_t*)img.bits() + (size_t)y*img.stride();
        uint8_t* L = row;             // x=0
        uint8_t* R = row + (size_t)(W-1)*4; // x=W-1
        for (int i=0; i<W/2; ++i)
        {
            // swap 4 bytes (BGRA)
            std::swap(L[0], R[0]);
            std::swap(L[1], R[1]);
            std::swap(L[2], R[2]);
            std::swap(L[3], R[3]);
            L += 4; R -= 4;
        }
    }
}

inline void FlipVerticalInplace_BGRA32(IppDib& img)
{
    if (!img) return;
    const int W = img.width(), H = img.height();
    std::vector<uint8_t> tmp((size_t)img.stride()); // 1 line buffer

    for (int y=0; y<H/2; ++y)
    {
        uint8_t* top = (uint8_t*)img.bits() + (size_t)y*img.stride();
        uint8_t* bot = (uint8_t*)img.bits() + (size_t)(H-1-y)*img.stride();

        std::memcpy(tmp.data(), top, (size_t)img.stride());
        std::memcpy(top,        bot, (size_t)img.stride());
        std::memcpy(bot,   tmp.data(), (size_t)img.stride());
    }
}
```

> 선택 가이드  
> - **안전/명확**: `FlipHorizontal/Vertical_BGRA32(src,dst)`  
> - **최고 속도/메모리 절약**: `FlipHorizontal/VerticalInplace_BGRA32(img)`  
> - 큰 이미지에서 in-place는 행 단위 **멀티스레드**로 쉽게 확장 가능(수평 대칭은 행 독립).

---

## 4. 메뉴/명령 연결

### 4.1 리소스 상수

```cpp
// resource.h (추가)
#define ID_TRANSFORM_FLIP_H            62040
#define ID_TRANSFORM_FLIP_V            62041
```

### 4.2 RC 메뉴/가속키

```rc
// ImageTool.rc (추가/일부)
POPUP "&Transform"
BEGIN
    MENUITEM "Flip &Horizontal\tCtrl+H", ID_TRANSFORM_FLIP_H
    MENUITEM "Flip &Vertical\tCtrl+Shift+H", ID_TRANSFORM_FLIP_V
END

IDR_ACCEL ACCELERATORS
BEGIN
    "H",       ID_TRANSFORM_FLIP_H, VIRTKEY, CONTROL
    "H",       ID_TRANSFORM_FLIP_V, VIRTKEY, CONTROL, SHIFT
END
```

> 키 배치 참고  
> - 수평(가로) → **H**, 수직 → **Shift+H**로 기억하기 쉽습니다. (원한다면 V로 바꿔도 무방)

### 4.3 메시지 처리

```cpp
// main_multiwin.cpp (발췌)
#include "Mirror.h"

// ...
case ID_TRANSFORM_FLIP_H:
    if (st && st->dib) {
        // 빠른 경로: in-place
        FlipHorizontalInplace_BGRA32(st->dib);
        InvalidateRect(hWnd, nullptr, FALSE);
        OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
    }
    return 0;

case ID_TRANSFORM_FLIP_V:
    if (st && st->dib) {
        // 빠른 경로: in-place
        FlipVerticalInplace_BGRA32(st->dib);
        InvalidateRect(hWnd, nullptr, FALSE);
        OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
    }
    return 0;
```

> 주의: in-place 수직 대칭은 **한 줄 버퍼**만 사용. 메모리 사용량이 매우 적습니다.

---

## 5. 품질·성능 메모

- **정확성**:  
  - 홀수 폭/높이일 때 중앙 열/행은 **자기 자신**과 교환되므로 그대로 유지됩니다.  
  - BGRA **4바이트**가 항상 함께 이동 → 색/알파가 틀어지지 않습니다.

- **성능**:  
  - 수평: 4바이트 swap 루프 → 완전 캐시 친화, 보틀넥은 메모리 대역폭.  
  - 수직: `memcpy` 3회/라인 → 매우 빠름.  
  - **멀티스레딩**: 행 단위(수평), 상·하 행 쌍 단위(수직)로 분할하기 쉽습니다.

- **Stride/패딩**:  
  - 한 행의 실제 유효 픽셀 바이트는 `W*4`. 그러나 교환/복사 단위는 항상 `stride()`를 고려해야 합니다(수직).

- **안전성**:  
  - `IppDib::bits()`가 `nullptr`인 경우를 방지(위 코드는 `if (!img) return;` 으로 가드).

---

## 6. 실전 예제 & 상황

### 예제 A) 셀피 좌우 교정
- **상황**: 전면 카메라 미러 모드로 찍은 셀피가 **좌우 반전**.  
- **동작**: `Transform → Flip Horizontal` (Ctrl+H).  
- **결과**: 텍스트/얼굴 방향이 정상화. SNS 업로드 전 표정 왜곡 느낌이 줄어듦.

### 예제 B) 게임 스프라이트 방향 전환
- **상황**: 캐릭터 스프라이트 시트의 좌향만 있고 우향이 없음.  
- **동작**: 스프라이트 시트를 **Flip Horizontal** → 애니메이션 프레임을 우향으로 재사용.  
- **결과**: 아트 리소스 절약. 단, **좌우 비대칭 UI/로고**가 있으면 별도 예외 처리 필요.

### 예제 C) 좌표계 변환(그래픽스 파이프라인)
- **상황**: OpenGL 캡처(좌표 원점이 하단) 이미지를 **화면 표시용**으로 바꿔야 함.  
- **동작**: `Flip Vertical` 로 상하 반전.  
- **결과**: 상하가 올바르게 보임. 스크린샷/텍스처 디버깅에 필수.

### 예제 D) 데이터 증강(Data Augmentation)
- **상황**: 딥러닝 학습용 이미지 증강.  
- **동작**: 확률 \(p=0.5\)로 **Flip Horizontal**, \(p=0.1\)로 **Flip Vertical** 적용.  
- **결과**: 좌우 불변성 학습, 과적합 감소. (본 툴로 시각 확인 후 파이프라인에 동일 로직 적용)

---

## 7. 테스트 체크리스트

- [ ] 폭/높이 **홀수/짝수** 케이스에서 중앙 열/행 유지 확인  
- [ ] 알파가 포함된 PNG/BMP에서 **가장자리 Halo**/누수 없음  
- [ ] 큰 이미지(예: 8K)에서 **프리징/메모리 폭주** 없이 즉시 동작  
- [ ] 수직 대칭 후 텍스처 좌표계와 일치(특히 렌더러/스샷 연동 시)  
- [ ] Undo/Redo 스택을 쓰는 프로젝트라면 **명령 단위**로 푸시되도록 연동

---

## 8. 확장 아이디어

- **영역 제한 대칭**: ROI(선택 영역)만 뒤집기 → 가장자리 블렌딩 옵션.  
- **대칭+오프셋**: Flip 후 \(\Delta x/\Delta y\) 만큼 이동하여 합성(스티커 반사 효과).  
- **대칭과 대칭축**: 임의의 축(선) 기준 반사(하우스홀더 변환)  
  \[
  R = I - 2\frac{vv^\top}{\|v\|^2}
  \]
  를 응용하면 경사 축 대칭 가능(고급).

---

## 9. 요약

- 좌우: \(x' = W-1-x\), 상하: \(y' = H-1-y\).  
- **Out-of-place**와 **In-place** 모두 제공하며, BGRA 4바이트 단위로 안전하게 처리.  
- 메뉴/가속키로 즉시 접근(Ctrl+H / Ctrl+Shift+H).  
- 셀피 교정·스프라이트 반전·좌표계 변환·데이터 증강 등 실전에서 자주 쓰이는 **기본 변환**입니다.