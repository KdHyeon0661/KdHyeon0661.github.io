---
layout: post
title: C++ - RAII와 동기화
date: 2024-09-21 19:20:23 +0900
category: Cpp
---
# RAII와 동기화

## 0. 한 문장 요약

**RAII + 표준 동기화 도구**를 쓰면, 예외·조기 return·타임아웃 등 모든 흐름에서도 **해제 누락 없이** 락/조건변수를 다룰 수 있다.

$$
\text{자원} = \{\text{mutex lock, cond wait, handle 등}\},\quad
\text{획득} \xrightarrow{\text{생성자}} \text{해제} \xrightarrow{\text{소멸자}}
$$

---

## 1. 왜 “수동 `lock()/unlock()`”이 위험한가?

```cpp
std::mutex m;

void critical_section() {
    m.lock();
    do_work();                  // 여기서 예외/return 발생 시?
    m.unlock();                 // ❌ 도달 못하면 데드락
}
```

- 예외·조기 반환·다중 return 경로에서 **unlock 누락** → **데드락**.
- 복수 락을 잡는다면 더 위험(순서 문제로 데드락).

**RAII로 교체**:

```cpp
void critical_section_raii() {
    std::lock_guard<std::mutex> lk(m); // 생성자에서 lock, 소멸자에서 unlock
    do_work();                         // 어떤 경로로 빠져나가도 안전하게 unlock
}
```

---

## 2. `std::lock_guard` vs `std::unique_lock` — 무엇을 언제 쓰나

### 2.1 `std::lock_guard` — 가장 간단한 RAII 락

- 생성 시 즉시 lock, 소멸 시 unlock.
- “잠금 해제 후 재잠금”·지연 잠금 같은 **유연성은 없음**.
- 오버헤드가 가장 낮고 **가장 흔한 선택**.

```cpp
#include <mutex>
std::mutex m;

void f() {
    std::lock_guard<std::mutex> lk(m);
    // 임계 영역
} // 자동 unlock
```

### 2.2 `std::unique_lock` — 유연한 RAII 락

- **지연 잠금**(`defer_lock`), **명시적 lock/unlock**, **조건변수 연계**, **이동 가능**.
- 약간의 오버헤드가 있지만 제어가 필요할 때 필수.

```cpp
#include <mutex>
std::mutex m;

void g() {
    std::unique_lock<std::mutex> lk(m, std::defer_lock); // 아직 lock 안 함
    // 사전 준비 …
    lk.lock();  // 필요 시점에 획득
    // …
    lk.unlock();    // 잠깐 손 놓았다가
    // …
    lk.lock();      // 다시 잡을 수도 있음
}
```

---

## 3. 락 태그: `defer_lock`, `adopt_lock`, `try_to_lock`

```cpp
std::mutex m1, m2;

// 3.1 defer_lock: “지금은 잠그지 마”
std::unique_lock<std::mutex> l1(m1, std::defer_lock);
std::unique_lock<std::mutex> l2(m2, std::defer_lock);
std::lock(l1, l2);                   // 데드락 없이 원자적 다중 락

// 3.2 adopt_lock: “이미 잠겨 있으니 소유만 넘겨 받아”
m1.lock();
std::lock_guard<std::mutex> g(m1, std::adopt_lock); // g는 unlock 책임만 진다

// 3.3 try_to_lock: “즉시 잠금 시도(대기 X)”
std::unique_lock<std::mutex> l3(m1, std::try_to_lock);
if (!l3.owns_lock()) {
    // 잠금 실패 시 다른 일 처리
}
```

---

## 4. **다중 락과 데드락 방지** — `std::scoped_lock` / `std::lock`

### 4.1 가장 간단한 해법: `std::scoped_lock` (C++17)

```cpp
#include <mutex>
std::mutex a, b;

void h() {
    std::scoped_lock lock(a, b); // 데드락 없이 a,b 둘 다 잠금
    // 임계 영역
} // 두 락 모두 자동 해제
```

내부적으로 안전한 순서를 계산해 **원자적으로 잠금**하므로 **권장**.

### 4.2 `std::lock` + `unique_lock(defer_lock)`

```cpp
std::mutex a, b;

void h2() {
    std::unique_lock<std::mutex> l1(a, std::defer_lock);
    std::unique_lock<std::mutex> l2(b, std::defer_lock);
    std::lock(l1, l2);          // 동시에 잠금 시도 → 데드락 회피
    // …
}
```

> “항상 동일한 락 순서로 잡기”는 전통적 규칙이지만, **다중 코드경로**가 얽히면 실수 가능. `scoped_lock`을 우선 고려.

---

## 5. 조건 변수와 RAII — 스푸리어스 웨이크업까지 안전하게

### 5.1 기본 패턴 (`wait`의 **predicate** 필수)

```cpp
#include <mutex>
#include <condition_variable>
#include <queue>

std::mutex m;
std::condition_variable cv;
std::queue<int> q;
bool done = false;

void producer() {
    for (int i = 0; i < 10; ++i) {
        {
            std::lock_guard<std::mutex> lk(m);
            q.push(i);
        }               // lock_guard 소멸 → unlock
        cv.notify_one();// 통지: lock을 쥐고 있지 않을 때가 일반적
    }
    {
        std::lock_guard<std::mutex> lk(m);
        done = true;
    }
    cv.notify_all();
}

void consumer() {
    std::unique_lock<std::mutex> lk(m);
    cv.wait(lk, []{ return !q.empty() || done; }); // predicate!
    while (!q.empty()) {
        int x = q.front(); q.pop();
        // … 처리 …
        cv.wait(lk, []{ return !q.empty() || done; }); // 반복 대기
    }
}
```

- **항상** `cv.wait(lock, predicate)` 형태로 쓰자.
  스푸리어스 웨이크업(허위 깨움)·lost wakeup 문제를 회피한다.
- `notify_one()/notify_all()`은 **락 해제 이후** 호출하는 것이 일반적으로 효율적이나, **상태 변경이 lock 보호 하에 선행**되어야 한다.

### 5.2 타임아웃 대기

```cpp
using namespace std::chrono_literals;
std::unique_lock<std::mutex> lk(m);
if (!cv.wait_for(lk, 100ms, []{ return ready; })) {
    // 타임아웃 처리
}
```

---

## 6. 타임드 락: `timed_mutex` / `recursive_timed_mutex`

```cpp
#include <mutex>
#include <chrono>

std::timed_mutex tm;

bool try_write_for() {
    using namespace std::chrono_literals;
    if (tm.try_lock_for(2s)) {       // 2초 이내만 기다림
        std::lock_guard<std::timed_mutex> g(tm, std::adopt_lock);
        // 임계 영역
        return true;                 // g 소멸 시 unlock
    }
    return false;                    // 타임아웃
}
```

> 타임드 락은 **경합이 심한 구간**에서 “대기 상한”을 두는 데 유용.
> 단, 남발하면 로직 복잡도↑(타임아웃 경로 처리 필요).

---

## 7. 읽기-쓰기 락: `std::shared_mutex` / `shared_lock`

- 읽기(공유) 다수, 쓰기(배타) 단일을 지원.
- **읽기 많은** 워크로드에서 성능 향상.

```cpp
#include <shared_mutex>
#include <string>

std::shared_mutex sm;
std::string data;

std::string read_data() {
    std::shared_lock<std::shared_mutex> r(sm); // 여러 스레드가 동시 획득 가능
    return data;
}

void write_data(std::string s) {
    std::unique_lock<std::shared_mutex> w(sm); // 배타적
    data = std::move(s);
}
```

- `shared_lock`도 RAII: 생성 시 공유 잠금, 소멸 시 해제.
- 주의: **기아(Writer starvation)** 가능. 구현/정책에 따라 다름.

---

## 8. 스레드 안전한 **초기화 1회 보장**: `std::call_once`

```cpp
#include <mutex>

std::once_flag init_flag;

void init_resource() {
    // 무거운 초기화 …
}

void use() {
    std::call_once(init_flag, init_resource); // 여러 스레드에서도 딱 1번
    // 초기화 완료 후 사용
}
```

RAII와 궁합이 좋다. 초기화 함수에서 RAII 자원을 구성해두면, 어떤 예외 경로에서도 **초기화의 유일성**과 **해제의 안전성**을 확보.

---

## 9. 원자 연산 및 스핀 “락” 대체 (`atomic_flag`)

락 자체를 피해야 할 때(초경량 구간), `atomic_flag`로 **스핀 대기**를 구현할 수 있다.

```cpp
#include <atomic>

class spinlock {
    std::atomic_flag f = ATOMIC_FLAG_INIT;
public:
    void lock() noexcept {
        while (f.test_and_set(std::memory_order_acquire)) { /* spin */ }
    }
    void unlock() noexcept {
        f.clear(std::memory_order_release);
    }
};

spinlock sl;

void work() {
    std::lock_guard<spinlock> g(sl);
    // 짧은 임계 구역
}
```

- 매우 짧은 임계 구역에서만 권장. 장시간 보유 시 CPU 낭비/스케줄러 불리.
- 선점형 OS에서는 일반 mutex를 우선 고려.

---

## 10. 예외 안전성 레벨 재정의 (임계 구역 버전)

임계 구역 내 상태 전이를 **변경 전 임시 상태**에 쌓아 두고, 조건 충족 시 **커밋**하는 패턴을 쓰면 강한 보장(rollback)을 달성할 수 있다.

$$
\text{critical}(S) =
\begin{cases}
S \leftarrow \text{apply}(S, \Delta) & \text{if } \text{validate}(S, \Delta) \\
S & \text{otherwise (rollback)}
\end{cases}
$$

RAII는 **락 해제**와 **중간 자원 정리**를 자동화하여, 위 패턴 구현의 안정성을 높인다.

---

## 11. 실전 시나리오

### 11.1 생산자-소비자(멀티) — 안전한 종료 시그널 포함

```cpp
#include <mutex>
#include <condition_variable>
#include <queue>
#include <thread>
#include <vector>
#include <optional>

class queue_mt {
    std::mutex m_;
    std::condition_variable cv_;
    std::queue<int> q_;
    bool closed_ = false;

public:
    void push(int x) {
        {
            std::lock_guard<std::mutex> lk(m_);
            if (closed_) return;           // 또는 예외
            q_.push(x);
        }
        cv_.notify_one();
    }

    // 데이터 또는 종료(nullopt) 반환
    std::optional<int> pop() {
        std::unique_lock<std::mutex> lk(m_);
        cv_.wait(lk, [this]{ return closed_ || !q_.empty(); });
        if (!q_.empty()) {
            int x = q_.front(); q_.pop();
            return x;
        }
        return std::nullopt; // closed && empty
    }

    void close() {
        {
            std::lock_guard<std::mutex> lk(m_);
            closed_ = true;
        }
        cv_.notify_all();
    }
};
```

- **RAII**는 각 스코프에서 락의 **획득/해제 책임을 자동화**.
- `close()` → 모든 대기 스레드 깨움 → 안전 종료.

### 11.2 다중 락을 잡고 공용 상태 갱신

```cpp
#include <mutex>

struct Account {
    std::mutex m;
    int balance = 0;
};

void transfer(Account& a, Account& b, int amount) {
    std::scoped_lock l(a.m, b.m);     // 데드락 없이 동시 잠금
    if (a.balance >= amount) {
        a.balance -= amount;
        b.balance += amount;
    }
}
```

### 11.3 읽기 많은 설정 캐시

```cpp
#include <shared_mutex>
#include <unordered_map>
#include <string>

class Config {
    std::unordered_map<std::string, std::string> kv_;
    std::shared_mutex m_;
public:
    std::string get(std::string key) const {
        std::shared_lock r(m_);
        if (auto it = kv_.find(key); it != kv_.end()) return it->second;
        return {};
    }
    void set(std::string key, std::string val) {
        std::unique_lock w(m_);
        kv_[std::move(key)] = std::move(val);
    }
};
```

---

## 12. 스타일/성능 체크리스트

1. [ ] **가능하면 `lock_guard`**, 필요할 때만 `unique_lock`.
2. [ ] 다중 락은 **`scoped_lock`** 또는 **`lock`+`defer_lock`** 사용.
3. [ ] `condition_variable`은 **항상 predicate**로 보호.
4. [ ] 통지는 **상태 변경 후**, 보통 **락 해제 뒤** 호출.
5. [ ] 읽기 많은 워크로드는 **`shared_mutex`** 고려.
6. [ ] 타임드 락/대기는 **명확한 타임아웃 경로**와 함께.
7. [ ] 소멸자는 **`noexcept`** — 락 해제에서 예외 금지(없어야 정상).
8. [ ] 로깅/계측 등 임계 구역 외부로 최대한 이동(경합↓).
9. [ ] 필요 없는 공유 데이터는 **스레드 지역 저장소**(TLS)로(락 제거).
10. [ ] **원자성(atomic)** 로 충분하다면 락 없이 해결(단, 메모리 질서 주의).

---

## 13. 미세 팁

- `std::unique_lock`은 **move-only**: 함수에서 잠금을 **소유권 이전**해 범위를 넘기는 트릭이 가능.
- `std::condition_variable_any`는 `unique_lock` 외 커스텀 락도 지원(성능은 일반 `cv`가 더 낫다).
- “락 범위 최소화”: RAII 객체의 **스코프**를 줄여 임계 구역을 짧게 유지.

```cpp
void minimal_scope() {
    int snapshot;
    {
        std::lock_guard<std::mutex> lk(m);
        snapshot = state;     // 락 안에서 필요한 최소 작업만
    }                         // 바로 unlock
    do_expensive(snapshot);   // 락 밖에서 무거운 일
}
```

---

## 14. 자주 하는 실수와 대처

- **실수**: `wait()`에 predicate 없이 사용 → 스푸리어스 웨이크업으로 논리 오류
  **대처**: `cv.wait(lk, []{ … })` 형태만 쓰기
- **실수**: 다중 락을 순서 보장 없이 `lock_guard`로 각각 획득
  **대처**: `scoped_lock` 또는 `lock`+`defer_lock`
- **실수**: 긴 임계 구역에서 I/O·할당·로그 수행
  **대처**: 임계 구역 최소화, 바깥으로 이동
- **실수**: 재귀적 호출 경로에서 `std::mutex` 사용
  **대처**: 설계 변경(권장), 부득이하면 `recursive_mutex`(성능 페널티 있음)

---

## 15. 성능 모델(감 잡기)

임계 구역 비율을 \( p \), 스레드 수를 \( N \)라 하면, 이상화된 지연 성능은 대략

$$
S(N) \approx \frac{1}{(1-p) + \frac{p}{\min(N, C)}}
$$

- \( C \): 병행 가능 임계 구역 수(보통 1, shared_mutex 읽기 동시엔 \(C > 1\)).
- 결론: **락 경쟁(p↑)** 이 커질수록 확장성↓ → 임계 구역을 줄이고, **읽기-쓰기 분리**, 락 분할(sharding), 락 프리 구조 모색.

---

## 16. 종합 예제: 큐 + 다중 락 + 타임드 대기 + 안전 종료

```cpp
#include <mutex>
#include <condition_variable>
#include <queue>
#include <optional>
#include <chrono>

template <class T>
class blocking_queue {
    std::mutex m_;
    std::condition_variable cv_;
    std::queue<T> q_;
    bool closed_ = false;

public:
    void push(T v) {
        {
            std::lock_guard<std::mutex> lk(m_);
            if (closed_) return;             // 또는 throw
            q_.push(std::move(v));
        }
        cv_.notify_one();
    }

    // 타임아웃 pop
    template <class Rep, class Period>
    std::optional<T> pop_for(const std::chrono::duration<Rep, Period>& d) {
        std::unique_lock<std::mutex> lk(m_);
        if (!cv_.wait_for(lk, d, [this]{ return closed_ || !q_.empty(); }))
            return std::nullopt; // timeout
        if (q_.empty()) return std::nullopt; // closed & empty
        T v = std::move(q_.front()); q_.pop();
        return v;
    }

    void close() {
        {
            std::lock_guard<std::mutex> lk(m_);
            closed_ = true;
        }
        cv_.notify_all();
    }
};
```

- 모든 경로에서 **락/대기/해제**가 **RAII**로 안전.
- 타임아웃 경로와 종료 시그널을 함께 처리.

---

## 17. 결론

- **RAII는 동기화의 필수 안전장치**다. 예외·조기 return·타임아웃에서도 **unlock 누락이 없다**.
- **기본은 `lock_guard`**, 유연함이 필요하면 `unique_lock`.
- 다중 락은 **`scoped_lock`**(또는 `lock`+`defer_lock`)로 데드락을 피하자.
- 조건변수는 **predicate와 함께**. 읽기 많은 시나리오는 **`shared_mutex`** 고려.
- 필요 시 타임드 락/대기, `call_once`, 원자 연산, 스핀락 대체 등으로 **맞춤 설계**.
