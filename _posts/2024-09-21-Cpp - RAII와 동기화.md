---
layout: post
title: C++ - RAII와 동기화
date: 2024-09-21 19:20:23 +0900
category: Cpp
---
# RAII와 동기화: C++에서의 안전한 멀티스레딩 패턴

## 서론: 왜 RAII와 동기화는 함께 가야 하는가?

멀티스레드 프로그래밍에서 가장 흔한 실수는 락을 획득한 후 해제하지 않는 것입니다. 예외가 발생하거나, 함수가 일찍 반환하거나, 복잡한 조건 분기에서 락 해제를 깜빡하면 프로그램은 교착 상태(deadlock)에 빠집니다. C++의 RAII(Resource Acquisition Is Initialization) 패러다임은 이러한 문제를 우아하게 해결합니다.

**핵심 아이디어**: 락을 객체로 생각하라. 생성자가 락을 획득하고, 소멸자가 락을 해제하면, 스택 풀림(stack unwinding)이 자원 정리를 보장합니다.

## 제1장: 기본 락 관리자들

### `std::lock_guard`: 단순함의 미학

가장 기본적이고 가벼운 RAII 락 관리자입니다. 생성 시 락을 획득하고, 소멸 시 해제합니다.

```cpp
#include <mutex>
#include <vector>

std::mutex data_mutex;
std::vector<int> shared_data;

void add_data(int value) {
    std::lock_guard<std::mutex> guard(data_mutex);  // 생성 시 락 획득
    shared_data.push_back(value);
    // 예외가 발생하더라도 락은 안전하게 해제됩니다
    // guard 소멸 시 자동으로 락 해제
}
```

**특징**:
- 오버헤드가 가장 적음
- 락 해제 후 재획득 불가
- 단일 락만 관리 가능

### `std::unique_lock`: 유연성의 힘

더 많은 제어가 필요할 때 사용합니다. 지연 잠금, 조건 변수와의 통합, 잠금 해제/재획득 등이 가능합니다.

```cpp
#include <mutex>
#include <chrono>

std::timed_mutex resource_mutex;

bool try_access_with_timeout() {
    std::unique_lock<std::timed_mutex> lock(
        resource_mutex, 
        std::defer_lock  // 생성 시 락을 획득하지 않음
    );
    
    // 2초 동안만 락 획득 시도
    if (lock.try_lock_for(std::chrono::seconds(2))) {
        // 리소스 사용
        return true;
    }
    
    // 타임아웃 발생
    return false;
}
```

**특징**:
- `lock_guard`의 모든 기능 포함
- 지연 잠금(`defer_lock`), 시간 제한 잠금 지원
- 조건 변수와 함께 사용 가능
- 약간의 오버헤드 있음

## 제2장: 고급 동기화 패턴

### 교착 상태 방지: 여러 락을 안전하게 관리하기

여러 락을 동시에 획득해야 할 때가 있습니다. 순서를 잘못 지정하면 교착 상태가 발생할 수 있습니다.

**문제가 있는 코드**:
```cpp
std::mutex mutex_a, mutex_b;

void thread1() {
    std::lock_guard<std::mutex> lock_a(mutex_a);  // A를 먼저 잠금
    std::lock_guard<std::mutex> lock_b(mutex_b);  // B를 잠그려 시도
    // 작업 수행
}

void thread2() {
    std::lock_guard<std::mutex> lock_b(mutex_b);  // B를 먼저 잠금
    std::lock_guard<std::mutex> lock_a(mutex_a);  // A를 잠그려 시도
    // 작업 수행 - 교착 상태 가능!
}
```

**해결책 1: `std::scoped_lock` (C++17 이상)**
```cpp
void safe_operation() {
    std::scoped_lock lock(mutex_a, mutex_b);  // 데드락 방지 알고리즘 사용
    // 두 락 모두 안전하게 획득됨
    // 작업 수행
}
```

**해결책 2: `std::lock` + `std::unique_lock`**
```cpp
void safe_operation_legacy() {
    std::unique_lock<std::mutex> lock_a(mutex_a, std::defer_lock);
    std::unique_lock<std::mutex> lock_b(mutex_b, std::defer_lock);
    
    // 데드락 방지 알고리즘으로 동시에 잠금
    std::lock(lock_a, lock_b);
    
    // 작업 수행
    // 두 unique_lock 소멸 시 자동으로 락 해제
}
```

### 조건 변수와의 통합: 효율적인 대기

조건 변수는 스레드가 특정 조건이 충족될 때까지 대기하게 합니다. RAII 없이는 쉽게 실수할 수 있습니다.

```cpp
#include <mutex>
#include <condition_variable>
#include <queue>
#include <iostream>

class ThreadSafeQueue {
private:
    std::mutex mutex_;
    std::condition_variable condition_;
    std::queue<int> queue_;
    bool stop_ = false;
    
public:
    void push(int value) {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            queue_.push(value);
        }
        condition_.notify_one();  // 락을 해제한 후 알림
    }
    
    std::optional<int> pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        
        // 조건 변수 대기: predicate 람다 사용 (스푸리어스 웨이크업 방지)
        condition_.wait(lock, [this]() {
            return !queue_.empty() || stop_;
        });
        
        if (stop_ && queue_.empty()) {
            return std::nullopt;  // 종료 신호
        }
        
        int value = queue_.front();
        queue_.pop();
        return value;
    }
    
    void stop() {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            stop_ = true;
        }
        condition_.notify_all();  // 모든 대기 중인 스레드 깨움
    }
};
```

**중요한 점**:
1. `condition_variable::wait()`는 항상 predicate와 함께 사용하세요.
2. `notify_one()`이나 `notify_all()`은 락을 해제한 후 호출하는 것이 효율적입니다.
3. `unique_lock`만 `condition_variable`과 함께 사용할 수 있습니다.

### 읽기-쓰기 락: 성능 최적화

읽기는 동시에 여러 스레드에서 수행할 수 있지만, 쓰기는 배타적 접근이 필요합니다. `std::shared_mutex`는 이 패턴을 지원합니다.

```cpp
#include <shared_mutex>
#include <map>
#include <string>

class Configuration {
private:
    mutable std::shared_mutex mutex_;
    std::map<std::string, std::string> settings_;
    
public:
    // 읽기 작업: 여러 스레드에서 동시 접근 가능
    std::string get(const std::string& key) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);  // 공유 잠금
        auto it = settings_.find(key);
        return it != settings_.end() ? it->second : "";
    }
    
    // 쓰기 작업: 배타적 접근 필요
    void set(const std::string& key, const std::string& value) {
        std::unique_lock<std::shared_mutex> lock(mutex_);  // 배타적 잠금
        settings_[key] = value;
    }
    
    // 여러 설정을 한 번에 업데이트
    void update_batch(const std::map<std::string, std::string>& updates) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        for (const auto& [key, value] : updates) {
            settings_[key] = value;
        }
    }
};
```

## 제3장: 실전 시나리오와 패턴

### 싱글톤 패턴의 스레드 안전한 초기화

```cpp
#include <mutex>
#include <memory>

class Singleton {
private:
    Singleton() = default;
    static std::unique_ptr<Singleton> instance_;
    static std::once_flag init_flag_;
    
public:
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
    static Singleton& get_instance() {
        std::call_once(init_flag_, []() {
            instance_ = std::make_unique<Singleton>();
        });
        return *instance_;
    }
    
    void operation() {
        // 인스턴스 메서드
    }
};

std::unique_ptr<Singleton> Singleton::instance_ = nullptr;
std::once_flag Singleton::init_flag_;
```

### 계좌 이체: 트랜잭션 스타일 락 관리

```cpp
#include <mutex>
#include <stdexcept>

class BankAccount {
private:
    mutable std::mutex mutex_;
    double balance_;
    
public:
    BankAccount(double initial_balance) : balance_(initial_balance) {}
    
    void transfer_to(BankAccount& to, double amount) {
        if (&to == this) return;  // 같은 계좌로의 이체는 무시
        
        // 두 락을 동시에 획득하여 교착 상태 방지
        std::scoped_lock lock(mutex_, to.mutex_);
        
        if (balance_ < amount) {
            throw std::runtime_error("잔액 부족");
        }
        
        balance_ -= amount;
        to.balance_ += amount;
        
        // 트랜잭션 로깅 등 추가 작업
    }
    
    double get_balance() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return balance_;
    }
};
```

### 프로듀서-컨슈머 패턴의 완전한 구현

```cpp
#include <queue>
#include <mutex>
#include <condition_variable>
#include <thread>
#include <iostream>
#include <chrono>

template<typename T>
class BlockingQueue {
private:
    std::queue<T> queue_;
    mutable std::mutex mutex_;
    std::condition_variable not_empty_;
    std::condition_variable not_full_;
    size_t capacity_;
    bool stopped_ = false;
    
public:
    explicit BlockingQueue(size_t capacity) : capacity_(capacity) {}
    
    bool push(T item, std::chrono::milliseconds timeout) {
        std::unique_lock<std::mutex> lock(mutex_);
        
        // 큐가 가득 차지 않을 때까지 대기 (타임아웃 지원)
        if (!not_full_.wait_for(lock, timeout, [this]() {
            return queue_.size() < capacity_ || stopped_;
        })) {
            return false;  // 타임아웃
        }
        
        if (stopped_) return false;
        
        queue_.push(std::move(item));
        not_empty_.notify_one();
        return true;
    }
    
    std::optional<T> pop(std::chrono::milliseconds timeout) {
        std::unique_lock<std::mutex> lock(mutex_);
        
        // 큐가 비어있지 않을 때까지 대기 (타임아웃 지원)
        if (!not_empty_.wait_for(lock, timeout, [this]() {
            return !queue_.empty() || stopped_;
        })) {
            return std::nullopt;  // 타임아웃
        }
        
        if (stopped_ && queue_.empty()) {
            return std::nullopt;
        }
        
        T item = std::move(queue_.front());
        queue_.pop();
        not_full_.notify_one();
        return item;
    }
    
    void stop() {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            stopped_ = true;
        }
        not_empty_.notify_all();
        not_full_.notify_all();
    }
    
    size_t size() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.size();
    }
};
```

## 제4장: 성능 고려사항과 최적화

### 락 범위 최소화

락을 보유하는 시간을 최소화하여 경쟁을 줄입니다.

```cpp
// 비효율적: 락을 너무 오래 보유
void process_data_bad(const std::vector<int>& data) {
    std::lock_guard<std::mutex> lock(shared_mutex);
    
    // 데이터 준비 (락이 필요없는 작업)
    std::vector<int> processed;
    for (int value : data) {
        processed.push_back(transform(value));
    }
    
    // 공유 자원 업데이트 (락이 필요한 작업)
    shared_resource.insert(
        shared_resource.end(), 
        processed.begin(), 
        processed.end()
    );
}

// 효율적: 락 범위 최소화
void process_data_good(const std::vector<int>& data) {
    // 락 밖에서 데이터 준비
    std::vector<int> processed;
    processed.reserve(data.size());
    for (int value : data) {
        processed.push_back(transform(value));
    }
    
    // 락은 필요한 최소 시간만 유지
    {
        std::lock_guard<std::mutex> lock(shared_mutex);
        shared_resource.insert(
            shared_resource.end(), 
            processed.begin(), 
            processed.end()
        );
    }
}
```

### 락 계층 구조 사용

복잡한 시스템에서 교착 상태를 방지하기 위해 락 계층을 정의합니다.

```cpp
class LockHierarchy {
private:
    static thread_local int current_level;
    
public:
    class Lock {
    private:
        std::mutex& mutex_;
        int level_;
        
    public:
        Lock(std::mutex& mutex, int level) : mutex_(mutex), level_(level) {
            if (level <= current_level) {
                throw std::logic_error("락 계층 위반");
            }
            mutex_.lock();
            current_level = level;
        }
        
        ~Lock() {
            current_level = 0;  // 간소화된 구현
            mutex_.unlock();
        }
        
        Lock(const Lock&) = delete;
        Lock& operator=(const Lock&) = delete;
    };
};

thread_local int LockHierarchy::current_level = 0;

// 사용 예
std::mutex low_level_mutex;
std::mutex high_level_mutex;

void operation() {
    LockHierarchy::Lock low_lock(low_level_mutex, 1);
    // 낮은 수준 작업 수행
    
    {
        LockHierarchy::Lock high_lock(high_level_mutex, 2);
        // 높은 수준 작업 수행
    }  // high_lock 소멸, 계층 레벨 복원
    
    // 다시 낮은 수준 작업 수행
}  // low_lock 소멸
```

## 결론: 현명한 동기화를 위한 원칙

### 1. **RAII를 기본으로 삼으세요**
   수동으로 `lock()`과 `unlock()`을 호출하지 마세요. 예외 안전성과 코드 간결성을 위해 RAII 래퍼를 항상 사용하세요.

### 2. **간단함에서 시작하세요**
   `std::lock_guard`로 시작하고, 필요할 때만 `std::unique_lock`로 업그레이드하세요. 대부분의 경우 `lock_guard`로 충분합니다.

### 3. **교착 상태를 예방하세요**
   여러 락이 필요할 때는 `std::scoped_lock`이나 `std::lock`을 사용하세요. 임의의 순서로 락을 획득하지 마세요.

### 4. **조건 변수를 현명하게 사용하세요**
   항상 predicate와 함께 사용하고, 스푸리어스 웨이크업을 처리하세요. `notify` 호출은 락을 해제한 후 수행하는 것이 일반적으로 더 효율적입니다.

### 5. **락 범위를 최소화하세요**
   락을 보유하는 시간을 최소화하여 경쟁을 줄이세요. 무거운 연산, I/O 작업, 할당 등은 가능하면 락 밖에서 수행하세요.

### 6. **적절한 도구를 선택하세요**
   - 읽기 많은 작업: `std::shared_mutex`
   - 재귀적 락 필요: `std::recursive_mutex`
   - 타임아웃 필요: `std::timed_mutex` 또는 `std::unique_lock`의 시간 제한 메서드
   - 단 한 번의 초기화: `std::call_once`

### 7. **성능을 측정하세요**
   동기화는 성능에 큰 영향을 미칩니다. 프로파일링 도구를 사용하여 병목 현상을 식별하고 최적화하세요.

### 8. **락 없는 설계를 고려하세요**
   가능하다면 락을 사용하지 않는 설계를 고려하세요. 스레드 로컬 스토리지, 원자 연산, 락 없는 자료구조 등을 활용하세요.

동기화는 멀티스레드 프로그래밍의 필수 요소이지만, 올바르게 사용하지 않으면 성능 문제와 교착 상태를 초래할 수 있습니다. RAII 패턴은 C++에서 이러한 문제를 관리하는 가장 안전하고 우아한 방법을 제공합니다. 원칙을 이해하고 적절한 도구를 선택하면, 안전하면서도 효율적인 동시성 코드를 작성할 수 있습니다.

기억하세요: 좋은 동기화 코드는 눈에 띄지 않아야 합니다. 그것은 단지 프로그램이 올바르게 동작하게 하는 기반设施일 뿐입니다.