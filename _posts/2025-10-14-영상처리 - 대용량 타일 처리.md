---
layout: post
title: 영상처리 - 대용량 타일 처리
date: 2025-10-14 22:25:23 +0900
category: 영상처리
---
# **대용량 타일 처리**: 초고해상도(>80 MP)에서 **스트리밍/타일링 로드맵**

> 목표
> - 8천만 픽셀 이상(예: 12k×7k, 16k×10k)의 초대형 이미지를 **한 번에 메모리에 전부 올리지 않고**,
>   **뷰포트(화면에 보이는 영역) 중심**으로 **타일 단위 스트리밍**·**캐시**·**비동기 디코드**를 구현한다.
> - **JPEG(단일 대용량 파일)**, **폴더 타일(DeepZoom/IIIF 스타일)**, **피라미드 TIFF** 등 **다양한 저장 스킴**을 아키텍처로 흡수한다.
> - 코드 예제는 C++(TurboJPEG/jpeglib) + (이미 보유한) `IppDib`/`IppImage` 계열을 전제하며, **코드는 한 번만** ``` 로 감싼다.

---

## 문제 정의 & 메모리 예산

- 80 MP 그레이스케일(8bpp): 약 **80 MB**
- 80 MP BGRA(32bpp): 약 **320 MB**
- 160 MP BGRA: **640 MB** + 임시 버퍼/캐시/서브샘플링/스레드 버퍼 ⇒ **1 GB+** 금방 도달
→ **전영역 디코드 금지**, **뷰포트 타일링**이 필수.

---

## 아키텍처 개요

### 핵심 컴포넌트

- **TilePyramid**: (z, x, y)로 식별되는 타일 피라미드(레벨 z=0…Z, 다운샘플 2^z).
- **TileSource**: 실제 저장 형태(JPEG 단일 파일/타일 폴더/네트워크)를 추상화.
- **RegionDecoder**: 단일 대형 JPEG에서 **ROI(사각형)**만 부분 디코드(정확한 API로 iMCU 정렬).
- **TileCache(LRU)**: 디코드된 **BGRA 타일**을 메모리/디스크에 캐시(예: 메모리 512~2048개 타일, 디스크 optional).
- **TileScheduler**: 뷰포트 변경 시 **필요 타일 목록** 계산 → **우선순위 큐**로 워커 스레드에 디코드 요청 → **프리페치**.
- **ViewportRenderer**: 이미 로드된 타일을 **StretchDIBits**로 합성/렌더, 비어있는 타일은 플레이스홀더.

### 타일 규격

- 기본 **타일 크기 256×256** 또는 **512×512** 권장
  - 256: I/O 단편화↑, 핫 패닝(빠른 이동) 반응성↑
  - 512: 디코드 효율↑, I/O 오버헤드↓ (추천: 512)
- **여백(Overlap)**: 컨볼루션/필터/샤프닝용으로 타일 경계 **+16~32 px** 여유(옵션).

---

## 좌표계와 피라미드

### 레벨별 해상도

원본 \(W_0 \times H_0\) 에서 레벨 \(z\) 의 해상도:
\[
W_z = \left\lceil \frac{W_0}{2^z} \right\rceil, \quad
H_z = \left\lceil \frac{H_0}{2^z} \right\rceil
\]

### 타일 인덱싱

타일 크기 \(T\) (예: 512) 일 때,
\[
X = \left\lfloor \frac{x}{T} \right\rfloor, \quad
Y = \left\lfloor \frac{y}{T} \right\rfloor
\]
뷰포트(픽셀 좌표) \([x_v, y_v, w_v, h_v]\) 에서 필요한 타일 범위는
\[
X_{\min} = \left\lfloor \frac{x_v}{T}\right\rfloor,\;
X_{\max} = \left\lfloor \frac{x_v + w_v - 1}{T}\right\rfloor
\]
( \(Y\) 동일 )

---

## 저장 스킴 선택

1) **폴더 타일 스킴(권장)**
   - 미리 피라미드를 만들어 `z/x_y.jpg` 로 저장(DeepZoom/IIIF와 유사).
   - 뷰어는 **파일명 조합만**으로 즉시 접근. 네트워크 캐시 CDN과 상성 탁월.

2) **단일 대형 JPEG(원본만)**
   - **jpeglib `jpeg_crop_scanline` + `jpeg_skip_scanlines`** 로 **ROI 부분 디코드**.
   - MCU(iMCU) 경계 정렬 필요(4:2:0은 16×16 등).

3) **피라미드/타일 TIFF(BigTIFF)**
   - libtiff로 레벨·타일 단위 접근. 색관리/ICC/EXIF 유지가 용이.
   - (본 장은 JPEG 경로 중심으로 다룸)

→ 대다수 앱은 **2(입력) → 1(출력)** 로 **오프라인 한 번 전처리**해 폴더 타일 & 피라미드 메타를 만든 다음, 런타임은 **폴더 타일 스트리밍**으로 단순화한다.

---

## **RegionDecoder**: 단일 JPEG에서 ROI 디코드(jpeglib)

> 포인트
> - `jpeg_crop_scanline(&cinfo, &x_off, &roi_w)` 로 **수평 크롭**(iMCU 정렬 조정값 반환).
> - `jpeg_skip_scanlines(&cinfo, y_skip)` 로 **수직 스킵**.
> - 이후 **roi_h** 만큼 스캔라인 읽기.
> - 출력 색공간: `JCS_EXT_BGRA`(가능 시) 또는 RGB 후 BGRA 변환.

```cpp
#include <jpeglib.h>
#include <vector>
#include <string>

struct Rect { JDIMENSION x, y, w, h; };
struct BGRA {
    int w=0,h=0,stride=0;
    std::vector<unsigned char> buf;
    bool create(int W,int H){ w=W; h=H; stride=((W*4+3)/4)*4; buf.assign((size_t)stride*h,0); return true; }
    unsigned char* row(int y){ return buf.data() + (size_t)stride*y; }
};

static bool DecodeJPEG_ROI_BGRA(const unsigned char* jpg, size_t jpgSize,
                                const Rect& roi, BGRA& out, std::string& err,
                                int scale_num=1, int scale_denom=1)
{
    err.clear(); out = BGRA{};

    jpeg_decompress_struct c{};
    jpeg_error_mgr jerr{};
    c.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&c);
    jpeg_mem_src(&c, (unsigned char*)jpg, (unsigned long)jpgSize);

    if (JPEG_HEADER_OK != jpeg_read_header(&c, TRUE)) { err="bad header"; goto FAIL; }

    // DCT 스케일(1/1, 1/2, 1/4, 1/8)
    c.scale_num = scale_num; c.scale_denom = scale_denom;

#ifdef JCS_EXTENSIONS

    c.out_color_space = JCS_EXT_BGRA;
#else

    c.out_color_space = JCS_RGB;
#endif

    // --- 수평 크롭(iMCU 정렬 조정) ---
    JDIMENSION x_off = roi.x, want_w = roi.w;
    jpeg_crop_scanline(&c, &x_off, &want_w); // x_off/want_w가 iMCU 정렬로 보정됨

    // --- 시작 ---
    jpeg_start_decompress(&c);

    // 수직 스킵: roi.y 만큼 스캔라인 건너뛰기(자동 iMCU 정렬)
    if (roi.y > 0) jpeg_skip_scanlines(&c, roi.y);

    const JDIMENSION outW = want_w;
    const JDIMENSION outH = std::min(roi.h, c.output_height - c.output_scanline);
    if (!out.create((int)outW, (int)outH)) { err="alloc"; goto FAIL_AFTER_START; }

    // 스캔라인 버퍼(크롭된 가로폭)
#ifdef JCS_EXTENSIONS

    // BGRA로 직접 수신
    while (c.output_scanline < roi.y + outH){
        JSAMPROW dst = (JSAMPROW)out.row((int)(c.output_scanline - roi.y));
        // 크롭이 적용된 상태라서 한 줄에 outW*4 길이
        JDIMENSION got = jpeg_read_scanlines(&c, &dst, 1);
        if (got != 1) { err="short read"; goto FAIL_AFTER_START; }
    }
#else

    std::vector<unsigned char> tmp(outW*3);
    while (c.output_scanline < roi.y + outH){
        JSAMPROW rp = tmp.data();
        if (jpeg_read_scanlines(&c, &rp, 1) != 1) { err="short read"; goto FAIL_AFTER_START; }
        // RGB → BGRA 변환
        unsigned char* d = out.row((int)(c.output_scanline - roi.y - 1));
        for (JDIMENSION x=0;x<outW;x++){
            d[x*4+0] = tmp[x*3+2]; // B
            d[x*4+1] = tmp[x*3+1]; // G
            d[x*4+2] = tmp[x*3+0]; // R
            d[x*4+3] = 255;
        }
    }
#endif

    jpeg_finish_decompress(&c);
    jpeg_destroy_decompress(&c);
    return true;

FAIL_AFTER_START:
    jpeg_finish_decompress(&c);
FAIL:
    jpeg_destroy_decompress(&c);
    return false;
}
```

> **주의**
> - 크롭/스킵은 **iMCU 경계**(샘플링에 따라 8×8, 16×8, 16×16)로 조정된다. ROI가 정확히 맞지 않아도, **더 크게** 읽은 뒤 최종 렌더에서 **클리핑**으로 좁힌다.
> - `scale_num/denom` 으로 **1/2, 1/4, 1/8** 수준의 **피라미드 coarse 레벨**을 **고속**으로 뽑을 수 있다.

---

## **타일 피라미드 생성기**(오프라인)

> 입력: 초대형 단일 JPEG
> 출력: `root/level/z/x_y.jpg` 구조(타일=512, JPG 품질=90, 420) + `pyramid.json`

전략
- 최상위(원본) 레벨은 **ROI 디코드**로 타일을 바로 만든다.
- 낮은 레벨(z+1)은 상위 레벨(z) 타일 4장을 **다운샘플(2×)** 해서 생성(**메모리 절감**).
- 가장 상위 레벨(축소) 몇 단계는 libjpeg **DCT 스케일**(1/2, 1/4, 1/8)을 활용해 비용 절감.

```cpp
#include <filesystem>
#include <cstdio>

// 간단 JPEG 저장(TurboJPEG 사용)
bool SaveJPG_BGRA(const BGRA& img, int quality, int subsamp /*420/444*/,
                  std::vector<unsigned char>& outJpg, std::string& err);

struct PyramidConf {
    int tile = 512;
    int quality = 90;
    int subsamp = 420;
};

static void WriteJsonMeta(const std::filesystem::path& root, int W, int H, int tile, int maxLevel){
    auto p = root / "pyramid.json";
    FILE* fp=nullptr; _wfopen_s(&fp, p.c_str(), L"wb");
    if (!fp) return;
    fprintf(fp, "{ \"width\": %d, \"height\": %d, \"tile\": %d, \"maxLevel\": %d }\n", W, H, tile, maxLevel);
    fclose(fp);
}

bool BuildPyramidFromLargeJPEG(const std::wstring& bigJpegPath,
                               const std::filesystem::path& outRoot,
                               const PyramidConf& conf,
                               std::string& err)
{
    // 1) 파일 로드(메모리)
    FILE* fp=nullptr; _wfopen_s(&fp, bigJpegPath.c_str(), L"rb");
    if(!fp){ err="open"; return false; }
    fseek(fp,0,SEEK_END); long sz=ftell(fp); fseek(fp,0,SEEK_SET);
    std::vector<unsigned char> bytes(sz);
    fread(bytes.data(),1,sz,fp); fclose(fp);

    // 2) 원본 해상도 확인
    jpeg_decompress_struct c{}; jpeg_error_mgr jerr{};
    c.err=jpeg_std_error(&jerr); jpeg_create_decompress(&c);
    jpeg_mem_src(&c, bytes.data(), (unsigned long)bytes.size());
    if (jpeg_read_header(&c, TRUE) != JPEG_HEADER_OK){ err="bad header"; goto JFAIL; }

    int W0 = c.image_width, H0 = c.image_height;
    jpeg_destroy_decompress(&c);

    // 3) 최대 레벨 계산(레벨 z의 최대 변이 tile 이하가 될 때까지)
    int tile = conf.tile;
    auto ceil_div = [](int a,int b){ return (a + b - 1)/b; };
    auto maxL = [&](){
        int z=0, W=W0, H=H0;
        while (W>tile || H>tile){ z++; W = ceil_div(W,2); H = ceil_div(H,2); }
        return z;
    }();
    std::filesystem::create_directories(outRoot);
    WriteJsonMeta(outRoot, W0, H0, tile, maxL);

    // 4) 레벨 0(원본) → 타일
    for (int y=0; y<H0; y+=tile){
        for (int x=0; x<W0; x+=tile){
            Rect roi{ (JDIMENSION)x, (JDIMENSION)y,
                      (JDIMENSION)std::min(tile, W0 - x),
                      (JDIMENSION)std::min(tile, H0 - y) };
            BGRA tileBGRA;
            if (!DecodeJPEG_ROI_BGRA(bytes.data(), bytes.size(), roi, tileBGRA, err, 1,1))
                return false;

            // 저장
            std::vector<unsigned char> jpg;
            if (!SaveJPG_BGRA(tileBGRA, conf.quality, conf.subsamp, jpg, err))
                return false;

            auto zdir = outRoot / L"0";
            std::filesystem::create_directories(zdir);
            wchar_t name[256];
            swprintf(name, 256, L"%d_%d.jpg", x / tile, y / tile);
            auto path = zdir / name;
            FILE* of=nullptr; _wfopen_s(&of, path.c_str(), L"wb");
            fwrite(jpg.data(),1,jpg.size(),of); fclose(of);
        }
    }

    // 5) 레벨 1..maxL 생성(상위 레벨 4타일 → 1타일 다운샘플)
    for (int z=1; z<=maxL; ++z){
        auto prev = outRoot / std::to_wstring(z-1);
        auto curr = outRoot / std::to_wstring(z);
        std::filesystem::create_directories(curr);

        int Wz = ceil_div(W0, 1<<z);
        int Hz = ceil_div(H0, 1<<z);
        int nx = ceil_div(Wz, tile);
        int ny = ceil_div(Hz, tile);

        for (int ty=0; ty<ny; ++ty){
            for (int tx=0; tx<nx; ++tx){
                // 상위 레벨(z-1)의 (2*tx, 2*ty) .. (2*tx+1, 2*ty+1) 4개의 타일을 읽어 1/2로 합성
                // 간단화를 위해: 4타일을 BGRA로 읽어 2× 다운샘플 → 타일 1장
                BGRA src00,src10,src01,src11;
                auto read_tile = [&](int px,int py, BGRA& dst){
                    wchar_t n[256]; swprintf(n,256,L"%d_%d.jpg", px, py);
                    auto p = prev / n;
                    FILE* f=nullptr; if (_wfopen_s(&f, p.c_str(), L"rb")!=0) return false;
                    fseek(f,0,SEEK_END); long s=ftell(f); fseek(f,0,SEEK_SET);
                    std::vector<unsigned char> b(s); fread(b.data(),1,s,f); fclose(f);
                    // 전체 디코드(작은 타일이므로 부담 적음)
                    // TurboJPEG로 BGRA 디코드(생략: 기존 TJ_Decode_BGRA 재사용 가능)
                    // 여기서는 DecodeJPEG_ROI_BGRA를 전체 ROI로 래핑해도 됨.
                    Rect roi{0,0,(JDIMENSION)tile,(JDIMENSION)tile};
                    std::string e; return DecodeJPEG_ROI_BGRA(b.data(), b.size(), roi, dst, e, 1,1);
                };
                read_tile(2*tx,   2*ty,   src00);
                read_tile(2*tx+1, 2*ty,   src10);
                read_tile(2*tx,   2*ty+1, src01);
                read_tile(2*tx+1, 2*ty+1, src11);

                // 2× 다운샘플 & 타일 합치기 → dst(512×512)
                BGRA dst; dst.create(tile, tile);
                for (int y=0;y<tile;y++){
                    unsigned char* d = dst.row(y);
                    for (int x=0;x<tile;x++){
                        // 상단/좌측 타일에서 2× 픽셀을 평균(간단한 Box filter)
                        auto pick = [&](const BGRA& s,int sx,int sy)->const unsigned char*{
                            return s.buf.data() + (size_t)s.stride*sy + sx*4;
                        };
                        const unsigned char* p00 = pick(src00, x*2, y*2);
                        const unsigned char* p10 = pick(src10, std::min(tile-1,x*2), y*2);
                        const unsigned char* p01 = pick(src01, x*2, std::min(tile-1,y*2));
                        const unsigned char* p11 = pick(src11, std::min(tile-1,x*2), std::min(tile-1,y*2));
                        // 평균(간단)
                        int B = (p00[0]+p10[0]+p01[0]+p11[0])>>2;
                        int G = (p00[1]+p10[1]+p01[1]+p11[1])>>2;
                        int R = (p00[2]+p10[2]+p01[2]+p11[2])>>2;
                        d[x*4+0]= (unsigned char)B;
                        d[x*4+1]= (unsigned char)G;
                        d[x*4+2]= (unsigned char)R;
                        d[x*4+3]= 255;
                    }
                }

                std::vector<unsigned char> jpg;
                if (!SaveJPG_BGRA(dst, conf.quality, conf.subsamp, jpg, err)) return false;
                wchar_t name[256]; swprintf(name,256,L"%d_%d.jpg", tx, ty);
                FILE* of=nullptr; auto path = curr / name;
                _wfopen_s(&of, path.c_str(), L"wb"); fwrite(jpg.data(),1,jpg.size(),of); fclose(of);
            }
        }
    }
    return true;
JFAIL:
    jpeg_destroy_decompress(&c);
    return false;
}
```

> 실전 팁
> - 가장 낮은 레벨(작은 축소) 몇 단계는 `scale_denom=2/4/8`을 써서 **원본에서 바로 DCT 스케일** 디코드하면 더 빠르다.
> - 경계 타일(오른쪽/아래)은 실제 크기가 `tile`보다 작을 수 있음 → 메타에 `width/height` 저장.

---

## & 스케줄러

- 키: `(level z, tileX, tileY)`
- 값: `BGRA`(디코드 결과) + 최근 사용 시간
- 용량: `maxTiles`(예: 1024) → 초과 시 **LRU 축출**
- 스케줄: 뷰포트 타일 리스트를 **Near-to-Far** 순서로 정렬, **워커 풀**에 제출(우선순위 큐).

```cpp
#include <unordered_map>
#include <list>

struct TileKey { int z,x,y; bool operator==(const TileKey& o) const { return z==o.z&&x==o.x&&y==o.y; } };
struct KeyHash { size_t operator()(const TileKey& k) const { return ((k.z*73856093)^(k.x*19349663)^(k.y*83492791)); } };

class TileCache {
public:
    explicit TileCache(size_t cap): cap_(cap) {}
    bool get(const TileKey& k, BGRA& out){
        auto it = map_.find(k); if (it==map_.end()) return false;
        // promote
        lru_.splice(lru_.begin(), lru_, it->second.it);
        out = it->second.img; return true;
    }
    void put(const TileKey& k, const BGRA& img){
        auto it = map_.find(k);
        if (it!=map_.end()){ it->second.img=img; lru_.splice(lru_.begin(), lru_, it->second.it); return; }
        if (map_.size()>=cap_){ auto last = lru_.back(); lru_.pop_back(); map_.erase(last); }
        lru_.push_front(k);
        map_[k] = Node{img, lru_.begin()};
    }
private:
    struct Node { BGRA img; std::list<TileKey>::iterator it; };
    size_t cap_; std::list<TileKey> lru_;
    std::unordered_map<TileKey, Node, KeyHash> map_;
};
```

> 메모리 예산 예시
> - 타일 512×512×BGRA(4B) ≈ **1.0 MB**/tile (stride padding 포함 시 ~1.05 MB)
> - 1024 타일 → **약 1 GB**. → **512 타일(≈512 MB)**로 시작 권장.
> - “BGRA 대신 JPEG 바이트 캐시 + 필요 시 즉시 디코드” 전략도 가능(디코드 CPU↔메모리 트레이드오프).

---

## **뷰포트 렌더러**(MFC/Win32)

- 현재 레벨 \(z\) 는 **화면 DPI/줌**에 따라 결정(타일 해상도가 화면 픽셀과 근접하도록).
- 필요한 타일을 `TileCache.get()` → 있으면 `StretchDIBits`로 그린다. 없으면 **요청 등록** 후 **플레이스홀더**(체스 패턴/회색).

```cpp
// OnPaint 내부 개략
void RenderViewport(HDC hdc, const RECT& client, const Viewport& vp, TileCache& cache, TileSource& src){
    const int T = 512;
    int z = PickLevel(vp.zoom); // 구현: 화면스케일 ↔ 레벨 맵핑
    auto need = ComputeNeededTiles(vp, z, T); // (x0..x1, y0..y1 타일 범위)

    for (int ty=need.y0; ty<=need.y1; ++ty){
        for (int tx=need.x0; tx<=need.x1; ++tx){
            TileKey k{z,tx,ty};
            BGRA tile;
            if (cache.get(k, tile)){
                RECT dst = TileToClientRect(tx, ty, z, vp, T); // 뷰포트/줌을 반영한 화면 좌표
                SetDIBitsToDevice(hdc,
                    dst.left, dst.top, dst.right-dst.left, dst.bottom-dst.top,
                    0, 0, 0, tile.h, tile.buf.data(),
                    MakeBITMAPINFO_32(tile.w, tile.h), DIB_RGB_COLORS);
            }else{
                // 플레이스홀더
                RECT dst = TileToClientRect(tx, ty, z, vp, T);
                FillRect(hdc, &dst, (HBRUSH)(COLOR_BTNFACE+1));
                // 비동기 요청
                src.RequestTileAsync(k);
            }
        }
    }
}
```

---

## **TileSource**: 폴더/단일JPEG/네트워크

- **FolderTileSource**: `root/z/x_y.jpg` 로부터 로드 → TurboJPEG 디코드
- **SingleJPEGSource**: 큰 JPEG 1개 + `DecodeJPEG_ROI_BGRA()`
  - `k=(z,x,y)` 의 타일 ROI를 **원본 좌표로 역변환** 후 크롭 디코드 → 레벨 z에 맞게 **다운샘플**(2^z).
  - coarse z에서는 DCT 스케일로 비용 절감.
- **HttpTileSource**: `GET /tiles/{z}/{x}_{y}.jpg` → 다운로드 후 TurboJPEG 디코드(네트워크 캐시).

> **프리페치**: 뷰포트 경계 바깥으로 **1~2 타일 링**을 우선순위 낮게 제출.

---

## **성능/보정 포인트**

- **Restart 마커**: 단일 JPEG ROI 디코드 시 **오류 국소화** & 하드웨어 파이프라인 동기화에 유리(오버헤드 미미).
- **허프만 최적화**: 폴더 타일 저장 시 **항상 ON**(용량 2~10%↓).
- **ICC/EXIF Orientation**: **레벨 0 생성 시** 회전/반전 **물리 반영** → 이후 피라미드 전 레벨에 일관 적용.
- **보간**: 다운샘플 시 최소 Box/양선형, 뷰포트 확대 표시엔 **양선형**(문서/UI는 444 + 정확DCT).
- **스레딩**: 프레임/타일 단위 **워커 풀**. `tjhandle/jpeglib cinfo`는 **스레드 전용** 인스턴스 재사용.

---

## **실전 시나리오**

- **현미경/의료 슬라이드(150 MP)**:
  - 오프라인 피라미드 빌드(512 타일, Q=90, 420).
  - 뷰어는 **폴더 타일 스트리밍** + **타일 LRU=1024** + **프리페치 링=2**.
  - **색 정확** 필요한 레이어는 **444+Q=92**로 별도 타일 세트.

- **위성 대형 오르소(400 MP)**:
  - 레벨 0을 **단일 JPEG**로 보관, 서비스 측에서 **ROI 서비스(IIIF/HTTP)** 제공.
  - 클라이언트는 **HttpTileSource**로 가져와 캐시.

---

## 예제 코드 모음

### → ROI → BGRA 타일

```cpp
struct TileJob { TileKey k; /* callback/ctx 등 */ };

class SingleJPEGSource {
public:
    SingleJPEGSource(std::wstring path, int W0,int H0,int tile)
        : path_(std::move(path)), W0_(W0), H0_(H0), T_(tile) {}

    // 비동기 요청(간략)
    void RequestTileAsync(const TileKey& k){
        // 워커 큐에 제출 → 워커 스레드에서 DoTile(k)
    }

    bool DoTile(const TileKey& k, BGRA& out, std::string& err){
        // 1) 레벨 z 해상도
        int Wz = (W0_ + (1<<k.z) -1) >> k.z;
        int Hz = (H0_ + (1<<k.z) -1) >> k.z;

        // 2) 타일의 z-좌표계 ROI
        int x0z = k.x * T_;
        int y0z = k.y * T_;
        int wz  = std::min(T_, Wz - x0z);
        int hz  = std::min(T_, Hz - y0z);

        // 3) 원본 좌표계 ROI(2^z 배)
        Rect roi0{
            (JDIMENSION)(x0z << k.z),
            (JDIMENSION)(y0z << k.z),
            (JDIMENSION)(wz  << k.z),
            (JDIMENSION)(hz  << k.z)
        };

        // 4) 원본에서 ROI 디코드 → 필요한 경우 2^z 다운샘플
        //    coarse z가 1/2,1/4,1/8이면 DCT 스케일 사용
        int denom = 1<<k.z;
        int scale_num=1, scale_denom=1;
        if      (denom>=8) scale_denom=8;
        else if (denom>=4) scale_denom=4;
        else if (denom>=2) scale_denom=2;

        // 파일 읽기
        FILE* fp=nullptr; _wfopen_s(&fp, path_.c_str(), L"rb");
        if(!fp){ err="open"; return false; }
        fseek(fp,0,SEEK_END); long sz=ftell(fp); fseek(fp,0,SEEK_SET);
        std::vector<unsigned char> b(sz); fread(b.data(),1,sz,fp); fclose(fp);

        BGRA tmp;
        if (!DecodeJPEG_ROI_BGRA(b.data(), b.size(), roi0, tmp, err, scale_num, scale_denom))
            return false;

        // 5) 축소 비율이 정확히 2^z가 아닐 수 있으므로(1/8까지만 DCT 스케일),
        //    남은 factor = denom/scale_denom 만큼 소프트 다운샘플
        int rest = denom / scale_denom; // 1,2,4,8 중 하나
        if (rest>1) {
            out.create(wz, hz);
            for (int y=0;y<hz;y++){
                unsigned char* d = out.row(y);
                for (int x=0;x<wz;x++){
                    // rest×rest 박스 평균(간단)
                    int sumB=0,sumG=0,sumR=0,cnt=0;
                    for(int dy=0;dy<rest;dy++){
                        const unsigned char* srow = tmp.row(y*rest+dy);
                        for(int dx=0;dx<rest;dx++){
                            const unsigned char* s = srow + (x*rest+dx)*4;
                            sumB+=s[0]; sumG+=s[1]; sumR+=s[2]; cnt++;
                        }
                    }
                    d[x*4+0]= (unsigned char)(sumB/cnt);
                    d[x*4+1]= (unsigned char)(sumG/cnt);
                    d[x*4+2]= (unsigned char)(sumR/cnt);
                    d[x*4+3]= 255;
                }
            }
        }else{
            out = std::move(tmp);
        }
        return true;
    }

private:
    std::wstring path_;
    int W0_=0,H0_=0, T_=512;
};
```

### **터보JPEG 저장**(BGRA → JPEG)

```cpp
#include <turbojpeg.h>

bool SaveJPG_BGRA(const BGRA& img, int quality, int subsamp,
                  std::vector<unsigned char>& out, std::string& err)
{
    out.clear(); err.clear();
    tjhandle h = tjInitCompress(); if(!h){ err="tjInitCompress"; return false; }
    int tjsubs = (subsamp==444)? TJSAMP_444 : TJSAMP_420;
    int flags = TJFLAG_FASTDCT | TJFLAG_OPTIMIZE_CODING | TJFLAG_PROGRESSIVE;
    unsigned char* buf=nullptr; unsigned long len=0;
    int rc = tjCompress2(h, (unsigned char*)img.buf.data(), img.w, img.stride, img.h,
                         TJPF_BGRA, &buf, &len, tjsubs, quality, flags);
    if (rc!=0){ err=tjGetErrorStr2(h); tjDestroy(h); return false; }
    out.assign(buf, buf+len); tjFree(buf); tjDestroy(h); return true;
}
```

---

## **네트워크 스트리밍**(간략 로드맵)

- 서버: `GET /tiles/{z}/{x}/{y}.jpg` → 폴더 타일 반환
- 클라이언트: **HttpTileSource**
  - 요청 폭주 방지: **동일 키 coalesce**(중복 요청 제거)
  - **우선순위 큐**(뷰포트 중심 거리)
  - 실패 재시도/지수 백오프
  - **메모리+디스크 캐시**(HTTP ETag/If-None-Match)

---

## **품질/색관리/EXIF**

- EXIF Orientation은 **빌드 타임**에 물리 회전/반전 반영 → 타일 좌표계도 회전에 맞춰 재기준.
- ICC 프로파일(sRGB 아닌 경우) → **lcms2**로 sRGB 변환 후 BGRA 저장(타일 일관).
- 문서/UI는 타일 저장에 444/Q=92(경계 보존), 사진은 420/Q=90 권장.

---

## **성능 로그 포인트**(운영)

- 타일 히트율(%), 평균 디코드 ms, 프리페치 적중률, LRU evict/second
- 스크롤/줌 시 프레임 타임(16.6ms/60fps 예산), 타일 준비 지연
- 메모리 피크(BGRA 캐시), I/O MB/s, 네트워크 RTT/스루풋

---

## 결론

- 초대형 이미지는 **피라미드+타일**로 구조화하고, 뷰포트 중심 **온디맨드 ROI 디코드**로 메모리/CPU를 통제한다.
- **폴더 타일**이 가장 단순하고 안정적인 런타임 스킴이며, **단일 JPEG** 소스에서도 `jpeg_crop_scanline/skip`으로 ROI 스트리밍이 가능하다.
- 타일 캐시/LRU/프리페치/우선순위 스케줄링/스레드 전용 디코더 조합으로 **매끄러운 패닝/줌**을 달성한다.

---

## 부록 A. MCU 정렬 상식표

| 샘플링 | iMCU 폭×높이 |
|---|---|
| 4:4:4 | 8×8 |
| 4:2:2 | 16×8 |
| 4:2:0 | 16×16 |

- `jpeg_crop_scanline` 호출 시 좌측 오프셋/폭이 **가장 가까운 iMCU 경계로 조정**된다.
- 수직 스킵 `jpeg_skip_scanlines`도 iMCU 기준으로 안전하게 이동.

---

## 부록 B. 뷰포트 → 레벨 선택 휴리스틱

- 화면 픽셀/이미지 픽셀 비율 \(\alpha\) 에서, \(2^z \approx 1/\alpha\) 에 가장 가까운 정수 z 선택.
- 확대(>100%)에서 한 단계 높은 z를 쓰면 **선명도 ↑**(타일 수 증가).
- 축소(<<100%)에서는 coarse z로 **타일 수 ↓/I/O ↓**.

---

## 부록 C. 플레이스홀더/지연 로딩 UX 팁

- 로딩 중 타일은 **회색 체크보드** + 레벨 z-1의 저해상도 프리뷰를 먼저 그려 **플리커 방지**.
- 빠른 스크롤 중 **지연 요청 취소**(latest-only)로 쓸데없는 디코드 낭비 방지.

---

위 로드맵과 예제로 **ImageTool**에 “초대형 뷰어 모드(타일 스트리밍)”를 바로 붙일 수 있다.
원하시면 **TileSource/Cache/Scheduler**를 통합한 미니 프레임워크를 프로젝트에 맞춰 더 세분화해 드릴게요.
```cpp
// (선택) 다음 단계 구현 청사진:
// class TileScheduler { SubmitViewport(vp); CancelObsolete(); … }
// class FolderTileSource : public TileSource { … }
// class HttpTileSource   : public TileSource { … }
// class TileView : CWnd { OnPaint→RenderViewport; OnMouseWheel→zoom; OnLButtonDrag→pan; … }
```
