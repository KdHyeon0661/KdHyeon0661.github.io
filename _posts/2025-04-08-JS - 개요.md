---
layout: post
title: JavaScript - 개요
date: 2025-04-08 19:20:23 +0900
category: JavaScript
---
# 자바스크립트란? 역사와 특징

> **핵심을 먼저 요약**
> - 자바스크립트는 **인터프리터 기반(현대엔 JIT 포함)**의 **동적 타입** 언어이자 **프로토타입 기반 객체지향** 언어다.
> - **이벤트 루프**와 **단일 스레드 모델** 위에서 **비동기 처리**를 수행하며, **마이크로태스크(프로미스)**와 **매크로태스크** 큐를 통해 실행 순서를 보장한다.
> - **ES6(2015)** 이후 클래스/모듈/화살표 함수 등 언어 기능이 급격히 확장되었고, **Node.js**의 등장으로 **서버·CLI·데스크탑(Electron)·모바일(React Native)** 등으로 범용화되었다.

---

## 자바스크립트란?

자바스크립트(JavaScript)는 웹 브라우저에서 동적 기능을 구현하기 위해 만들어진 **스크립트 언어**로 출발했다. 이제는 브라우저를 넘어 서버( Node.js ), 데스크탑(Electron), 모바일(React Native), 임베디드(IoT) 등 **범용 프로그래밍 언어**로 자리 잡았다.

- **동적 타입**: 실행 중 타입이 바뀔 수 있음
- **인터프리터(JIT 혼합)**: 즉시 실행/테스트 용이
- **프로토타입 기반 객체지향**: 클래스가 아닌 **프로토타입 체인**으로 상속 표현(ES6 이후 클래스 문법 제공)
- **비동기 모델**: 이벤트 루프, 콜백/Promise/async-await
- **모듈 시스템**: ES Modules(표준), CommonJS(Node.js 초기 생태계)
- **문서 조작**: 브라우저에서 DOM, CSSOM을 조작

---

## 역사 (요약 + 세부 해설)

| 연도 | 주요 사건 | 해설/영향 |
|------|-----------|-----------|
| 1995 | Brendan Eich, Netscape에서 **Mocha** 작성 → **LiveScript** → **JavaScript**로 개명 | 브라우저에서 동적으로 HTML을 조작하기 위한 경량 스크립트 탄생 |
| 1996 | Microsoft, **JScript** 발표 | IE 브라우저 호환으로 스펙 혼선 증가 |
| 1997 | ECMA 표준화(ES1) | **ECMAScript**라는 표준 스펙 등장 |
| 1999 | ES3 | try/catch, 정규식 등 핵심 기능 정착 |
| 2009 | **Node.js** | V8 위에서 JS를 서버측에서 실행 → 풀스택 시대 개막 |
| 2015 | **ES6(ES2015)** | let/const, class, module(ESM), arrow function, Promise 등 대규모 개편 |
| 이후 | ES2016+ (매년) | async/await, 옵셔널 체이닝, 논리 할당 등 지속 발전 |

> **TC39 프로세스**: 자바스크립트 표준 제정 위원회인 **TC39**가 제안(Stage 0 → 4)을 거쳐 매년 기능을 확정한다.

---

## 언어 특징 — 기본에서 심화까지

### 동적 타입(Dynamic Typing)

```js
let x = "hello";
x = 42; // 오류가 아님
```

- 장점: 빠른 프로토타이핑, 유연성
- 단점: 런타임 오류 가능성 증가 → **TypeScript**나 **JSDoc**로 보완 가능

**타입 검사 팁**

```js
function isNumber(n) {
  return typeof n === "number" && Number.isFinite(n);
}

console.log(typeof NaN);      // "number" (주의!)
console.log(Number.isNaN(NaN)); // true
```

### 인터프리터 + JIT

현대 엔진(V8, SpiderMonkey, JavaScriptCore)은 **인터프리터 → 프로파일링 → JIT 컴파일**로 성능을 끌어올린다. 코드 패턴이 바뀌면 디옵티마이즈(deopt)도 발생한다.

**성능 팁 요약**
- 숨은 클래스(shape)가 자주 변하지 않게 **객체 생성 패턴을 고정**한다.
- 배열을 **희소 배열**로 만들지 않는다(큰 인덱스 건너뛰기 금지).
- **일관된 타입**의 값으로 연산한다(혼성 타입 연산 지양).

### 객체 기반(프로토타입 체인)

```js
const base = { kind: "base" };
const child = Object.create(base);
child.name = "child";

console.log(child.kind); // "base" (프로토타입 체인 따라감)
```

**직접 구현: 간단한 프로토타입 체인 조회**

```js
function getProp(obj, key) {
  while (obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) return obj[key];
    obj = Object.getPrototypeOf(obj);
  }
  return undefined;
}
```

### 스코프·호이스팅·클로저

- `var`는 함수 스코프 + 호이스팅
- `let`/`const`는 블록 스코프 + TDZ(Temporal Dead Zone)
- **클로저**: 외부 함수의 변수에 접근하는 내부 함수

```js
function counter() {
  let c = 0;
  return function () {
    c += 1;
    return c;
  };
}
const inc = counter();
console.log(inc()); // 1
console.log(inc()); // 2
```

**실전 클로저: 디바운스/스로틀**

```js
// 디바운스: 마지막 호출 이후 wait 동안만 유지되면 실행
function debounce(fn, wait = 200) {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), wait);
  };
}

// 스로틀: 주기마다 최대 1회
function throttle(fn, wait = 200) {
  let last = 0;
  return (...args) => {
    const now = Date.now();
    if (now - last >= wait) {
      last = now;
      fn(...args);
    }
  };
}
```

### 함수가 일급 객체(First-class Function)

- 함수는 변수에 저장, 인자로 전달, 반환 가능
- **고차 함수** 패턴, **커링** 가능

```js
const curry = (fn) => (a) => (b) => fn(a, b);
const add = (x, y) => x + y;
const add5 = curry(add)(5);
console.log(add5(7)); // 12
```

### 비동기 모델: 이벤트 루프, 태스크 큐

#### 콜백 → Promise → async/await

```js
// 콜백 지옥
readFile("a.txt", (err, a) => {
  if (err) return;
  readFile("b.txt", (err, b) => {
    if (err) return;
    // ...
  });
});

// Promise
read("a.txt")
  .then((a) => read("b.txt").then((b) => [a, b]))
  .then(([a, b]) => console.log(a + b))
  .catch(console.error);

// async/await
async function main() {
  try {
    const a = await read("a.txt");
    const b = await read("b.txt");
    console.log(a + b);
  } catch (e) {
    console.error(e);
  }
}
```

#### 마이크로태스크 vs 매크로태스크

- **마이크로태스크**: `Promise.then`, `queueMicrotask`
- **매크로태스크**: `setTimeout`, `setInterval`, `setImmediate(Node)`

```js
console.log("start");

setTimeout(() => console.log("timeout"), 0);

Promise.resolve()
  .then(() => console.log("microtask 1"))
  .then(() => console.log("microtask 2"));

console.log("end");

// 실행 순서: start → end → microtask 1 → microtask 2 → timeout
```

#### 간단한 Promise 구현(교육용)

```js
class MyPromise {
  constructor(executor) {
    this.state = "pending";
    this.value = undefined;
    this.handlers = [];
    const resolve = (v) => this.update("fulfilled", v);
    const reject = (e) => this.update("rejected", e);
    try {
      executor(resolve, reject);
    } catch (e) {
      reject(e);
    }
  }
  update(state, value) {
    if (this.state !== "pending") return;
    this.state = state;
    this.value = value;
    this.handlers.forEach((h) => this.run(h));
  }
  run(h) {
    queueMicrotask(() => {
      const cb = this.state === "fulfilled" ? h.onFulfilled : h.onRejected;
      if (!cb) {
        (this.state === "fulfilled" ? h.resolve : h.reject)(this.value);
        return;
      }
      try {
        const r = cb(this.value);
        h.resolve(r);
      } catch (e) {
        h.reject(e);
      }
    });
  }
  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      this.handlers.push({ onFulfilled, onRejected, resolve, reject });
      if (this.state !== "pending") this.run(this.handlers[this.handlers.length - 1]);
    });
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  static resolve(v) {
    return new MyPromise((res) => res(v));
  }
}
```

---

## 브라우저 vs Node.js: 실행 환경 차이

| 항목 | 브라우저 | Node.js |
|------|----------|---------|
| 런타임 | DOM, BOM, fetch, Web APIs | fs, net, http, cluster, worker_threads |
| 모듈 | ES Modules(현대 표준) | CommonJS(기존) + ES Modules |
| 이벤트 루프 | HTML 표준 루프 단계 | libuv 기반 루프 |
| 보안 | SOP, CSP 등 보안 모델 | 파일/네트워크 접근 가능(권한 주의) |

**브라우저 예시: DOM 조작**

```html
<button id="btn">Click</button>
<script>
  document.getElementById("btn").addEventListener("click", () => {
    const p = document.createElement("p");
    p.textContent = "Clicked!";
    document.body.appendChild(p);
  });
</script>
```

**Node.js 예시: 파일 읽기**

```js
import { promises as fs } from "node:fs";

const data = await fs.readFile("./data.txt", "utf-8");
console.log(data);
```

---

## 모듈 시스템: ES Modules vs CommonJS

### ES Modules (브라우저/Node 최신)

```js
// math.js
export const add = (a, b) => a + b;
export default function mul(a, b) { return a * b; }

// main.js
import mul, { add } from "./math.js";
console.log(add(2, 3), mul(2, 3));
```

### CommonJS (Node 전통)

```js
// math.cjs
exports.add = (a, b) => a + b;
module.exports.mul = (a, b) => a * b;

// main.cjs
const { add, mul } = require("./math.cjs");
console.log(add(2, 3), mul(2, 3));
```

**혼용 주의**: 패키지 `type`(package.json)과 확장자(`.mjs`, `.cjs`)를 일관되게.

---

## 객체지향: 프로토타입 vs 클래스 문법

### 프로토타입 기반

```js
function Person(name) {
  this.name = name;
}
Person.prototype.greet = function () {
  return `Hi, I'm ${this.name}`;
};
const p = new Person("Lee");
console.log(p.greet());
```

### ES6 클래스 문법(문법적 설탕)

```js
class Person {
  constructor(name) { this.name = name; }
  greet() { return `Hi, I'm ${this.name}`; }
}
class Developer extends Person {
  constructor(name, stack) {
    super(name);
    this.stack = stack;
  }
  code() { return `${this.name} codes ${this.stack}`; }
}
```

> **내부적으로는 여전히 프로토타입을 사용**한다.

---

## 표준 라이브러리 & 컬렉션

- 배열, 맵(Map), 셋(Set), 약한 참조(WeakMap/WeakSet)
- 이터러블/이터레이터, 제너레이터

```js
function* idGen() {
  let i = 0;
  while (true) yield ++i;
}
const g = idGen();
console.log(g.next().value); // 1
console.log(g.next().value); // 2
```

---

## 비동기 심화: 경쟁·제한·재시도 패턴

### 동시성 제한(Concurrency Limiter)

```js
function limit(fn, n = 3) {
  const q = [];
  let running = 0;
  const runNext = () => {
    if (running >= n || q.length === 0) return;
    const { args, resolve, reject } = q.shift();
    running++;
    Promise.resolve(fn(...args))
      .then(resolve, reject)
      .finally(() => { running--; runNext(); });
  };
  return (...args) => new Promise((resolve, reject) => {
    q.push({ args, resolve, reject });
    runNext();
  });
}
// 사용 예: 동시에 3개의 fetch만
```

### 재시도 with 지수 백오프

```js
async function retry(fn, { retries = 3, base = 200 } = {}) {
  let attempt = 0;
  while (true) {
    try { return await fn(); }
    catch (e) {
      if (attempt++ >= retries) throw e;
      const wait = base * 2 ** (attempt - 1);
      await new Promise((r) => setTimeout(r, wait));
    }
  }
}
```

---

## 메모리·GC·성능 최적화

- **영역별 GC**(새생/노후 세대)와 **mark-and-sweep** 이해
- **탈최적화**(deopt)를 유발하는 패턴 회피: 혼합 타입, 프로퍼티 셰이프 변경
- **객체/배열 초기화** 시점에 최종 형태로 만들기
- **반복문**: 성능 차이는 엔진 구현에 따라 다름(사전 마이크로벤치 금지, 실제 시나리오 기반 측정)

```js
// 희소 배열 피하기
const arr = [];
arr[1000000] = 1; // 희소 배열 → 성능 저하 가능
```

---

## 보안 기초(브라우저)

- **CSP(Content-Security-Policy)**: 인라인 스크립트 차단, 출처 제한
- **XSS 방지**: DOM 조작 시 텍스트로 삽입, innerHTML 남용 금지
- **SOP/CORS**: 교차 출처 보호/허용 정책 이해
- **정적 분석**: 위험 API( `eval`, `Function` 생성자 ) 지양

```js
// 안전한 삽입
const p = document.createElement("p");
p.textContent = userInput; // 자동 이스케이프
```

---

## 테스트 전략

- 단위 테스트(Jest/Vitest)
- E2E 테스트(Playwright)
- DOM 테스트(Testing Library)

```js
// 예: 간단한 덧셈 테스트
export const add = (a, b) => a + b;
/*
test("add", () => {
  expect(add(2, 3)).toBe(5);
});
*/
```

---

## 도구 체인 개요

- 패키지 관리자: npm / pnpm / yarn
- 번들러: Vite / Webpack / esbuild / Rollup
- 트랜스파일러: Babel / TypeScript
- 포맷터·린터: Prettier / ESLint

```json
// package.json 예시
{
  "name": "js-blog-sample",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "test": "vitest"
  }
}
```

---

## 예제 모음 — 실전 시나리오

### 간단 구현

```js
function createBus() {
  const map = new Map();
  return {
    on(evt, fn) {
      const list = map.get(evt) || [];
      list.push(fn);
      map.set(evt, list);
      return () => {
        const l = map.get(evt) || [];
        const i = l.indexOf(fn);
        if (i >= 0) l.splice(i, 1);
      };
    },
    emit(evt, payload) {
      (map.get(evt) || []).forEach((fn) => fn(payload));
    },
  };
}

const bus = createBus();
const off = bus.on("tick", (x) => console.log("tick:", x));
bus.emit("tick", 1);
off();
bus.emit("tick", 2); // 리스너 제거됨
```

### 안전한 템플릿 태그(미니 XSS 방지)

```js
function escapeHtml(str) {
  return String(str)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;");
}
function html(strings, ...values) {
  return strings.reduce((acc, s, i) => acc + s + escapeHtml(values[i] ?? ""), "");
}
const user = `<img src=x onerror=alert(1)>`;
const out = html`<p>${user}</p>`;
document.body.innerHTML = out; // 안전
```

### 데이터 파이프라인: map/filter/reduce

```js
const users = [
  { name: "A", age: 31 },
  { name: "B", age: 18 },
  { name: "C", age: 25 },
];
const namesOver20 = users
  .filter((u) => u.age > 20)
  .sort((a, b) => a.age - b.age)
  .map((u) => u.name);
console.log(namesOver20); // ["C", "A"]
```

### fetch + AbortController(요청 취소)

```js
const c = new AbortController();
const t = setTimeout(() => c.abort(), 200); // 200ms 후 취소

try {
  const res = await fetch("/slow", { signal: c.signal });
  const json = await res.json();
  console.log(json);
} catch (e) {
  if (e.name === "AbortError") console.log("request aborted");
}
clearTimeout(t);
```

---

## 수치·수학 관련 팁

- 부동소수점 오차

```js
console.log(0.1 + 0.2 === 0.3); // false
const eq = (a, b, eps = 1e-10) => Math.abs(a - b) < eps;
console.log(eq(0.1 + 0.2, 0.3)); // true
```

수식을 표기해야 하는 경우(예: 오차 한계 \(\epsilon\)):

$$
|a - b| < \varepsilon
$$

---

## 자바스크립트 vs Java (심화 비교)

| 구분 | JavaScript | Java |
|------|------------|------|
| 타입 | 동적 | 정적(강타입) |
| 상속 | 프로토타입 기반 | 클래스 기반 |
| 동시성 | 이벤트 루프(비선점적) | 스레드(선점형), 동기화 도구 |
| 런타임 | 브라우저·Node 등 | JVM |
| 빌드 | 선택(번들/트랜스파일) | 필수(컴파일) |

**상호 보완**: 프론트엔드(JS) + 백엔드(Java) 조합도 흔하다.

---

## 흔한 함정과 베스트 프랙티스

- `==` 대신 **항상 `===`** 사용
- `var` 대신 **`let`/`const`**
- **에러 전파**: async 함수에서 `try/catch` 및 상위로 throw
- **모듈 경계 명확화**: 외부 공개 API 최소화
- **DOM 삽입 보안**: `textContent` 기본, 필요시 Sanitizer

```js
// 나쁜 예: 암묵적 타입 변환
console.log("" == 0); // true (주의)
console.log(false == "0"); // true (주의)

// 좋은 예
console.log("" === 0); // false
```

---

## 미니 프로젝트: “작은 TODO 앱” (브라우저 ESM)

**구조**
```
/index.html
/app.js
/todo.js
/store.js
```

**index.html**
```html
<!doctype html>
<html>
  <head><meta charset="utf-8"><title>TODO</title></head>
  <body>
    <h1>TODO</h1>
    <form id="f">
      <input id="t" placeholder="할 일" required />
      <button>추가</button>
    </form>
    <ul id="list"></ul>
    <script type="module" src="./app.js"></script>
  </body>
</html>
```

**store.js**
```js
const KEY = "todos";
export function load() {
  try { return JSON.parse(localStorage.getItem(KEY) || "[]"); }
  catch { return []; }
}
export function save(items) {
  localStorage.setItem(KEY, JSON.stringify(items));
}
```

**todo.js**
```js
export function createTodo(title) {
  return { id: crypto.randomUUID(), title, done: false, createdAt: Date.now() };
}
export function toggle(todo) { todo.done = !todo.done; return todo; }
export function remove(items, id) { return items.filter((x) => x.id !== id); }
```

**app.js**
```js
import { load, save } from "./store.js";
import { createTodo, toggle, remove } from "./todo.js";

const form = document.getElementById("f");
const input = document.getElementById("t");
const list = document.getElementById("list");

let items = load();
render();

form.addEventListener("submit", (e) => {
  e.preventDefault();
  items = [createTodo(input.value), ...items];
  input.value = "";
  save(items);
  render();
});

function render() {
  list.innerHTML = "";
  for (const it of items) {
    const li = document.createElement("li");
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = it.done;
    cb.addEventListener("change", () => {
      toggle(it);
      save(items);
      render();
    });
    const del = document.createElement("button");
    del.textContent = "삭제";
    del.addEventListener("click", () => {
      items = remove(items, it.id);
      save(items);
      render();
    });
    const span = document.createElement("span");
    span.textContent = it.title + (it.done ? " (완료)" : "");
    li.append(cb, span, del);
    list.appendChild(li);
  }
}
```

---

## 체크리스트(정리)

- [ ] `let/const` 사용, `===` 고정
- [ ] 비동기 흐름: Promise/async/await 일관
- [ ] 마이크로태스크/매크로태스크 순서 이해
- [ ] 모듈 시스템(ESM/ CJS) 혼용 주의
- [ ] 브라우저/Node API 차이 인지
- [ ] DOM 삽입 시 XSS 주의(CSP/이스케이프)
- [ ] 성능: 객체 셰이프/희소 배열 회피
- [ ] 테스트·린트·포맷터 도입

---

## 마무리

당초 “웹 페이지를 동적으로” 만들기 위해 태어난 자바스크립트는, **표준화(ECMAScript)**와 **런타임 혁신(V8 등)**, **생태계(패키지·프레임워크)**의 힘으로 **전 영역**에서 사용되는 **주력 언어**가 되었다.
이 글은 기존의 **역사·특징 요약**을 바탕으로 **실전 예제(클로저, 이벤트 루프, 모듈, 보안, 성능, 미니 프로젝트)**까지 확장하여 **바로 적용 가능한 지식**을 제공한다.
여기서 다룬 **패턴·도구·보안·테스트**를 조합하면, 브라우저/Node 어느 쪽이든 **견고한 자바스크립트 코드베이스**를 구성할 수 있다.
