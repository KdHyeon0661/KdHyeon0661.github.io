---
layout: post
title: 영상처리 - 영역 기반의 불변 모멘트
date: 2025-10-04 23:25:23 +0900
category: 영상처리
---
# 영역 기반의 불변 모멘트 (Region-Based Invariant Moments)

## 1) 불변 모멘트 (개념)

### 1.1 기초 정의 — 원시 모멘트(Spatial/Raw moments)
영상 \( f(x,y) \) (이진이면 0/1 혹은 0/255, 그레이스케일이면 밝기 값) 에 대해,  
\[
m_{pq}=\sum_{x}\sum_{y} x^p y^q\, f(x,y)
\]
- \(m_{00}\): 총 질량(이진: 면적, 그레이: 총 밝기)  
- \(m_{10}/m_{00},~m_{01}/m_{00}\): **무게중심(centroid)** \((\bar{x},\bar{y})\)

### 1.2 중심 모멘트(Central moments)
\[
\mu_{pq}=\sum_{x}\sum_{y} (x-\bar{x})^p (y-\bar{y})^q\, f(x,y)
\]
- 이동에 대해 불변(centroid 기준)

### 1.3 스케일 정규화(Scale normalization)
\[
\eta_{pq}=\frac{\mu_{pq}}{\mu_{00}^{\,1+\frac{p+q}{2}}}
\]
- 스케일 변환(확대/축소)에 대해 불변

### 1.4 **Hu 불변 모멘트**(회전까지 불변)
\[
\begin{aligned}
\phi_1 &= \eta_{20}+\eta_{02} \\
\phi_2 &= (\eta_{20}-\eta_{02})^2+4\eta_{11}^2 \\
\phi_3 &= (\eta_{30}-3\eta_{12})^2+(3\eta_{21}-\eta_{03})^2 \\
\phi_4 &= (\eta_{30}+\eta_{12})^2+(\eta_{21}+\eta_{03})^2 \\
\phi_5 &= (\eta_{30}-3\eta_{12})(\eta_{30}+\eta_{12})\big[(\eta_{30}+\eta_{12})^2-3(\eta_{21}+\eta_{03})^2\big]\\
&\quad +(3\eta_{21}-\eta_{03})(\eta_{21}+\eta_{03})\big[3(\eta_{30}+\eta_{12})^2-(\eta_{21}+\eta_{03})^2\big] \\
\phi_6 &= (\eta_{20}-\eta_{02})\big[(\eta_{30}+\eta_{12})^2-(\eta_{21}+\eta_{03})^2\big] + 4\eta_{11}(\eta_{30}+\eta_{12})(\eta_{21}+\eta_{03}) \\
\phi_7 &= (3\eta_{21}-\eta_{03})(\eta_{30}+\eta_{12})\big[(\eta_{30}+\eta_{12})^2-3(\eta_{21}+\eta_{03})^2\big]\\
&\quad - (\eta_{30}-3\eta_{12})(\eta_{21}+\eta_{03})\big[3(\eta_{30}+\eta_{12})^2-(\eta_{21}+\eta_{03})^2\big]
\end{aligned}
\]
> 수치 안정성을 위해 출력 시 \( \phi'_i = \operatorname{sgn}(\phi_i)\cdot \log(1+|\phi_i|) \) 형태가 자주 사용됩니다.

---

## 2) 구현 — **Hu 불변 모멘트 계산 모듈** (단일/다중 객체 지원)

아래 헤더는
- DIB → (그레이/이진) 변환
- **원시/중심/정규화 모멘트** 계산
- **Hu 7개 불변 모멘트** 계산(로그 스케일 포함)
- (선택) **연결 성분 레이블링**으로 객체별 불변 모멘트 산출
- (선택) **CSV로 내보내기**
까지 한 번에 제공합니다.

```cpp
// InvariantMoments.hpp
#pragma once
#include <vector>
#include <string>
#include <cmath>
#include <cstdint>
#include <algorithm>
#include <queue>
#include <fstream>
#include <iomanip>
#include "IppDib.h"
#include "IppImage.h"

inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }
inline int clampi(int v,int lo,int hi){ return v<lo?lo:(v>hi?hi:v); }

// ===== BGRA32 → Gray8 / Binary8 =====
inline void DibToGray8(const IppDib& dib, IppImage<uint8_t>& g){
    g.create(dib.width(), dib.height());
    for (int y=0;y<dib.height();++y){
        const uint8_t* s=(const uint8_t*)dib.bits() + (size_t)y*dib.stride();
        uint8_t* d=g.row(y);
        for (int x=0;x<dib.width();++x){
            uint8_t B=s[x*4+0], G=s[x*4+1], R=s[x*4+2];
            int Y=(114*B + 587*G + 299*R + 500)/1000;
            d[x]=clamp_u8(Y);
        }
    }
}
inline void DibToBinary8(const IppDib& dib, IppImage<uint8_t>& bin){
    bin.create(dib.width(), dib.height());
    for (int y=0;y<dib.height();++y){
        const uint8_t* s=(const uint8_t*)dib.bits() + (size_t)y*dib.stride();
        uint8_t* d=bin.row(y);
        for (int x=0;x<dib.width();++x){
            d[x] = (s[x*4+0] | s[x*4+1] | s[x*4+2]) ? 255 : 0;
        }
    }
}

// ===== 모멘트 구조체 =====
struct RawMoments {
    long double m00=0, m10=0, m01=0, m20=0, m02=0, m11=0, m30=0, m03=0, m12=0, m21=0;
};
struct CentralMoments {
    long double mu20=0, mu02=0, mu11=0, mu30=0, mu03=0, mu12=0, mu21=0; // mu00= m00
    double cx=0.0, cy=0.0; // centroid
    long double mu00=0;    // = m00
};
struct NormalizedMoments {
    long double e20=0, e02=0, e11=0, e30=0, e03=0, e12=0, e21=0; // = ηpq
};
struct HuMoments {
    long double phi[7]{};
    long double logphi[7]{}; // sgn*log(1+|phi|)
};

// ===== 모멘트 계산 (그레이 가중 / 이진 가중 선택) =====
enum class WeightMode { Binary01, Binary255, Grayscale };

inline RawMoments ComputeRawMoments(const IppImage<uint8_t>& img, WeightMode mode){
    RawMoments r;
    const int W=img.width(), H=img.height();
    for (int y=0;y<H;++y){
        const uint8_t* s=img.row(y);
        for (int x=0;x<W;++x){
            int w = 0;
            switch(mode){
                case WeightMode::Binary01:  w = s[x] ? 1 : 0; break;
                case WeightMode::Binary255: w = s[x] ? 255 : 0; break;
                case WeightMode::Grayscale: w = s[x]; break;
            }
            if (!w) continue;
            long double xd=x, yd=y, ww=w;
            r.m00 += ww;
            r.m10 += xd*ww; r.m01 += yd*ww;
            r.m20 += xd*xd*ww; r.m02 += yd*yd*ww; r.m11 += xd*yd*ww;
            r.m30 += xd*xd*xd*ww; r.m03 += yd*yd*yd*ww;
            r.m12 += xd*yd*yd*ww; r.m21 += xd*xd*yd*ww;
        }
    }
    return r;
}
inline CentralMoments ToCentral(const RawMoments& r){
    CentralMoments c;
    c.mu00 = r.m00;
    if (r.m00==0){ c.cx=c.cy=0; return c; }
    long double cx = r.m10 / r.m00;
    long double cy = r.m01 / r.m00;
    c.cx = (double)cx; c.cy = (double)cy;

    // 중심 모멘트 (표준 다항식)
    c.mu20 = r.m20 - r.m10*cx;
    c.mu02 = r.m02 - r.m01*cy;
    c.mu11 = r.m11 - r.m10*cy;
    c.mu30 = r.m30 - 3*cx*r.m20 + 2*cx*cx*r.m10;
    c.mu03 = r.m03 - 3*cy*r.m02 + 2*cy*cy*r.m01;
    c.mu12 = r.m12 - 2*cy*r.m11 - cx*r.m02 + 2*cy*cy*r.m10 + cx*cy*r.m01;
    c.mu21 = r.m21 - 2*cx*r.m11 - cy*r.m20 + 2*cx*cx*r.m01 + cx*cy*r.m10;
    return c;
}
inline NormalizedMoments ToNormalized(const CentralMoments& c){
    NormalizedMoments e;
    if (c.mu00==0) return e;
    long double g = std::powl(c.mu00, 1.0L + 1.0L); // mu00^(1+ (p+q)/2), p+q=2 → mu00^2
    // p+q=2
    e.e20 = c.mu20 / g;
    e.e02 = c.mu02 / g;
    e.e11 = c.mu11 / g;
    // p+q=3 → mu00^(1+1.5)=mu00^2.5
    long double g3 = std::powl(c.mu00, 1.0L + 1.5L);
    e.e30 = c.mu30 / g3;
    e.e03 = c.mu03 / g3;
    e.e12 = c.mu12 / g3;
    e.e21 = c.mu21 / g3;
    return e;
}
inline HuMoments ToHu(const NormalizedMoments& e){
    HuMoments h{};
    const long double n20=e.e20, n02=e.e02, n11=e.e11;
    const long double n30=e.e30, n03=e.e03, n12=e.e12, n21=e.e21;

    h.phi[0] = n20 + n02;
    h.phi[1] = (n20 - n02)*(n20 - n02) + 4*n11*n11;
    h.phi[2] = (n30 - 3*n12)*(n30 - 3*n12) + (3*n21 - n03)*(3*n21 - n03);
    h.phi[3] = (n30 + n12)*(n30 + n12) + (n21 + n03)*(n21 + n03);
    h.phi[4] = (n30 - 3*n12)*(n30 + n12)*((n30 + n12)*(n30 + n12) - 3*(n21 + n03)*(n21 + n03))
             + (3*n21 - n03)*(n21 + n03)*(3*(n30 + n12)*(n30 + n12) - (n21 + n03)*(n21 + n03));
    h.phi[5] = (n20 - n02)*((n30 + n12)*(n30 + n12) - (n21 + n03)*(n21 + n03))
             + 4*n11*(n30 + n12)*(n21 + n03);
    h.phi[6] = (3*n21 - n03)*(n30 + n12)*((n30 + n12)*(n30 + n12) - 3*(n21 + n03)*(n21 + n03))
             - (n30 - 3*n12)*(n21 + n03)*(3*(n30 + n12)*(n30 + n12) - (n21 + n03)*(n21 + n03));

    for (int i=0;i<7;++i){
        long double v=h.phi[i];
        long double s = (v<0)? -1.0L : 1.0L;
        h.logphi[i] = s * std::log1pl(std::fabsl(v)); // sgn * log(1+|v|)
    }
    return h;
}

// ===== 8-연결 성분 레이블링(간단 DFS) → 라벨 ID/픽셀 목록 생성 =====
struct LabelRegion { int id=0; int area=0; std::vector<POINT> pixels; };
enum class Connectivity { C4, C8 };

inline std::vector<LabelRegion> LabelBinary(const IppImage<uint8_t>& bin,
                                            Connectivity conn=Connectivity::C8, int minArea=10)
{
    const int W=bin.width(), H=bin.height();
    IppImage<int> lab(W,H); lab.fill(0);
    int dx8[8]={+1,+1,0,-1,-1,-1,0,+1};
    int dy8[8]={0,+1,+1,+1,0,-1,-1,-1};
    int dx4[4]={+1,0,-1,0};
    int dy4[4]={0,+1,0,-1};

    std::vector<LabelRegion> regs; int curId=0;
    std::vector<POINT> stack; stack.reserve(1024);

    auto push=[&](int x,int y){ stack.push_back(POINT{(LONG)x,(LONG)y}); };
    auto pop=[&](){ auto p=stack.back(); stack.pop_back(); return p; };

    for (int y=0;y<H;++y){
        const uint8_t* s=bin.row(y);
        for (int x=0;x<W;++x){
            if (!s[x] || lab.row(y)[x]) continue;
            ++curId;
            LabelRegion R; R.id=curId; R.area=0; R.pixels.clear();
            push(x,y); lab.row(y)[x]=curId;
            while(!stack.empty()){
                auto p=pop(); R.area++; R.pixels.push_back(p);
                if (conn==Connectivity::C8){
                    for(int k=0;k<8;++k){
                        int xx=p.x+dx8[k], yy=p.y+dy8[k];
                        if ((unsigned)xx<(unsigned)W && (unsigned)yy<(unsigned)H){
                            if (bin.row(yy)[xx] && lab.row(yy)[xx]==0){
                                lab.row(yy)[xx]=curId; push(xx,yy);
                            }
                        }
                    }
                }else{
                    for(int k=0;k<4;++k){
                        int xx=p.x+dx4[k], yy=p.y+dy4[k];
                        if ((unsigned)xx<(unsigned)W && (unsigned)yy<(unsigned)H){
                            if (bin.row(yy)[xx] && lab.row(yy)[xx]==0){
                                lab.row(yy)[xx]=curId; push(xx,yy);
                            }
                        }
                    }
                }
            }
            if (R.area>=minArea) regs.push_back(std::move(R));
        }
    }
    return regs;
}

// ===== 라벨별 모멘트 계산(이진 0/1 가중) =====
inline RawMoments ComputeRawMomentsForRegion(const IppImage<uint8_t>& bin, const LabelRegion& R){
    RawMoments r;
    for (auto& p : R.pixels){
        int x=p.x, y=p.y; // bin은 0/255
        if (bin.row(y)[x]){ // 안전
            long double xd=x, yd=y, ww=1.0L; // 0/1 가중
            r.m00 += ww;
            r.m10 += xd*ww; r.m01 += yd*ww;
            r.m20 += xd*xd*ww; r.m02 += yd*yd*ww; r.m11 += xd*yd*ww;
            r.m30 += xd*xd*xd*ww; r.m03 += yd*yd*yd*ww;
            r.m12 += xd*yd*yd*ww; r.m21 += xd*xd*yd*ww;
        }
    }
    return r;
}

// ===== 고수준 API =====
struct InvariantOptions {
    bool useGrayscale=false;     // false: 이진, true: 그레이스케일 가중
    bool perLabel=false;         // true면 LabelBinary로 각 성분별 계산
    Connectivity conn=Connectivity::C8;
    int minArea=25;              // perLabel일 때 최소 면적
    bool logScale=true;          // 출력 시 sgn*log(1+|phi|)
};
struct InvariantResultSingle {
    double cx=0, cy=0;
    long double area=0;
    HuMoments hu{};
};
struct InvariantResult {
    std::vector<InvariantResultSingle> items; // perLabel면 여러 개
};

// 단일(이미지 전체) 또는 라벨별로 Hu 모멘트 계산
inline bool RunInvariantMoments(const IppDib& in, InvariantResult& out, const InvariantOptions& opt){
    if (!in) return false;
    IppImage<uint8_t> g, b; DibToGray8(in,g); DibToBinary8(in,b);
    out.items.clear();

    if (!opt.perLabel){
        // 단일: 이미지 전체(비-제로가 전경) 마스크로 계산
        const IppImage<uint8_t>& src = opt.useGrayscale? g : b;
        RawMoments r = ComputeRawMoments(src, opt.useGrayscale? WeightMode::Grayscale : WeightMode::Binary01);
        CentralMoments c = ToCentral(r);
        NormalizedMoments e = ToNormalized(c);
        HuMoments h = ToHu(e);

        InvariantResultSingle s;
        s.cx=c.cx; s.cy=c.cy; s.area=(long double)r.m00; s.hu=h;
        out.items.push_back(s);
        return true;
    }else{
        // 라벨링 → 각 성분별 이진 0/1 가중 모멘트
        auto regs = LabelBinary(b, opt.conn, opt.minArea);
        for (auto& R: regs){
            RawMoments r = ComputeRawMomentsForRegion(b, R);
            if (r.m00==0) continue;
            CentralMoments c = ToCentral(r);
            NormalizedMoments e = ToNormalized(c);
            HuMoments h = ToHu(e);

            InvariantResultSingle s;
            s.cx=c.cx; s.cy=c.cy; s.area=(long double)r.m00; s.hu=h;
            out.items.push_back(std::move(s));
        }
        return true;
    }
}

// CSV 내보내기
inline bool ExportInvariantCSV(const std::wstring& path, const InvariantResult& R, bool logScale=true){
    std::ofstream ofs(std::string(path.begin(), path.end()));
    if (!ofs) return false;
    ofs<< "index,cx,cy,area,phi1,phi2,phi3,phi4,phi5,phi6,phi7\n";
    ofs.setf(std::ios::fixed); ofs<<std::setprecision(8);
    for (size_t i=0;i<R.items.size();++i){
        const auto& s=R.items[i];
        const long double* v = logScale? s.hu.logphi : s.hu.phi;
        ofs<< (i+1) << "," << s.cx << "," << s.cy << "," << (double)s.area << ","
           << (double)v[0] << "," << (double)v[1] << "," << (double)v[2] << ","
           << (double)v[3] << "," << (double)v[4] << "," << (double)v[5] << ","
           << (double)v[6] << "\n";
    }
    return true;
}
```

> 구현 포인트  
> - **가중 선택**: `Binary01`(전경=1) vs `Grayscale`(밝기 가중). 이진이면 **형태** 자체, 그레이면 **밝기 분포**까지 포함합니다.  
> - **정규화 지수**: \(\eta_{pq}=\mu_{pq}/\mu_{00}^{\,1+(p+q)/2}\). 코드에서는 \(p+q=2\)와 \(3\)을 분리해 처리했습니다.  
> - **수치 안정성**: 로그 스케일 출력(`sgn*log(1+|phi|)`)은 값의 **동적 범위**를 줄여 비교·시각화에 유리합니다.

---

## 3) UI — **Invariant Moments…** 대화 상자 & 메뉴

### 3.1 리소스 ID

```cpp
// resource.h (추가)
#define ID_MENU_INV_MOMENTS             90010

#define IDD_INV_MOMENTS_DLG             4700
#define IDC_CHK_IM_GRAY                 4701
#define IDC_CHK_IM_PERLABEL             4702
#define IDC_RAD_IM_C4                   4703
#define IDC_RAD_IM_C8                   4704
#define IDC_EDIT_IM_MINAREA             4705
#define IDC_CHK_IM_LOGSCALE             4706
#define IDC_CHK_IM_EXPORTCSV            4707
#define IDC_EDIT_IM_CSVPATH             4708
#define IDC_STC_IM_SUMMARY              4709
```

### 3.2 RC

```rc
// ImageTool.rc (추가)
POPUP "&Analyze"
BEGIN
    MENUITEM "Invariant Moments...\tCtrl+I", ID_MENU_INV_MOMENTS
END

IDD_INV_MOMENTS_DLG DIALOGEX 0,0, 360, 180
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Invariant Moments (Hu 7)"
FONT 9, "Segoe UI"
BEGIN
    AUTOCHECKBOX "Use grayscale weights", IDC_CHK_IM_GRAY, 12, 12, 140, 12
    AUTOCHECKBOX "Per connected component", IDC_CHK_IM_PERLABEL, 12, 28, 160, 12

    GROUPBOX "Labeling", -1, 12, 46, 160, 50
    AUTORADIOBUTTON "4-connected", IDC_RAD_IM_C4, 22, 60, 72, 10, WS_TABSTOP
    AUTORADIOBUTTON "8-connected", IDC_RAD_IM_C8, 22, 74, 72, 10
    LTEXT "Min area:", -1, 100, 62, 40, 10
    EDITTEXT IDC_EDIT_IM_MINAREA, 142, 60, 24, 14, ES_NUMBER

    AUTOCHECKBOX "Log-scale output (sgn*log(1+|phi|))", IDC_CHK_IM_LOGSCALE, 184, 12, 168, 12
    AUTOCHECKBOX "Export CSV", IDC_CHK_IM_EXPORTCSV, 184, 28, 70, 12
    EDITTEXT IDC_EDIT_IM_CSVPATH, 184, 44, 160, 14

    LTEXT "Summary:", -1, 12, 106, 40, 10
    LTEXT "", IDC_STC_IM_SUMMARY, 56, 106, 288, 40

    DEFPUSHBUTTON "Run", IDOK,  224, 148, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 274, 148, 44, 16
END
```

### 3.3 대화 상자 코드 & 메뉴 핸들러

```cpp
// InvariantMomentsDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "InvariantMoments.hpp"

// 앱 공용 헬퍼(앞 장과 동일 스타일)
HWND CreateDocWindowFromDib(const IppDib& dib, const std::wstring& title);

class InvariantMomentsDlg {
public:
    InvariantMomentsDlg(HWND owner, IppDib& target) : owner_(owner), target_(target) {}
    INT_PTR DoModal();
private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM);
    void Run(HWND h);

private:
    HWND owner_{};
    IppDib& target_;
};
```

```cpp
// InvariantMomentsDlg.cpp
#include "InvariantMomentsDlg.h"

INT_PTR InvariantMomentsDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_INV_MOMENTS_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK InvariantMomentsDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        return ((InvariantMomentsDlg*)l)->OnInit(h); }
    auto* self=(InvariantMomentsDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w);
    return FALSE;
}
INT_PTR InvariantMomentsDlg::OnInit(HWND h){
    CheckDlgButton(h, IDC_CHK_IM_GRAY, BST_UNCHECKED);
    CheckDlgButton(h, IDC_CHK_IM_PERLABEL, BST_UNCHECKED);
    CheckRadioButton(h, IDC_RAD_IM_C4, IDC_RAD_IM_C8, IDC_RAD_IM_C8);
    SetDlgItemInt(h, IDC_EDIT_IM_MINAREA, 25, FALSE);
    CheckDlgButton(h, IDC_CHK_IM_LOGSCALE, BST_CHECKED);
    CheckDlgButton(h, IDC_CHK_IM_EXPORTCSV, BST_UNCHECKED);
    SetDlgItemTextW(h, IDC_EDIT_IM_CSVPATH, L"moments.csv");
    SetDlgItemTextW(h, IDC_STC_IM_SUMMARY, L"(ready)");
    return TRUE;
}
INT_PTR InvariantMomentsDlg::OnCommand(HWND h, WPARAM w){
    switch(LOWORD(w)){
    case IDOK:    Run(h); EndDialog(h, IDOK); return TRUE;
    case IDCANCEL: EndDialog(h, IDCANCEL);    return TRUE;
    }
    return FALSE;
}
void InvariantMomentsDlg::Run(HWND h){
    InvariantOptions opt;
    opt.useGrayscale = (IsDlgButtonChecked(h, IDC_CHK_IM_GRAY)==BST_CHECKED);
    opt.perLabel     = (IsDlgButtonChecked(h, IDC_CHK_IM_PERLABEL)==BST_CHECKED);
    opt.conn         = (IsDlgButtonChecked(h, IDC_RAD_IM_C4)==BST_CHECKED)? Connectivity::C4 : Connectivity::C8;
    BOOL ok=FALSE;
    opt.minArea      = GetDlgItemInt(h, IDC_EDIT_IM_MINAREA, &ok, FALSE); if (!ok||opt.minArea<1) opt.minArea=1;
    opt.logScale     = (IsDlgButtonChecked(h, IDC_CHK_IM_LOGSCALE)==BST_CHECKED);

    InvariantResult R;
    if (!RunInvariantMoments(target_, R, opt)){
        MessageBoxW(h, L"실행 실패: 입력 영상을 확인하세요.", L"Invariant Moments", MB_ICONERROR);
        return;
    }

    // 요약 표시(최대 10개)
    wchar_t buf[512]; buf[0]=0;
    wsprintfW(buf, L"items=%d, %ls, %ls",
        (int)R.items.size(),
        opt.perLabel?L"per-label":L"single",
        opt.useGrayscale?L"grayscale":L"binary");
    SetDlgItemTextW(h, IDC_STC_IM_SUMMARY, buf);

    std::wstring msg=L"Hu moments (";
    msg += opt.logScale? L"log-scale" : L"raw";
    msg += L")\n";
    int cnt=0;
    for (size_t i=0;i<R.items.size();++i){
        const auto& s=R.items[i];
        const long double* v = opt.logScale? s.hu.logphi : s.hu.phi;
        wchar_t ln[320];
        wsprintfW(ln, L"#%d @ (%.1f,%.1f), area=%.0f\n"
                       L"  φ1=%.6f φ2=%.6f φ3=%.6f\n"
                       L"  φ4=%.6f φ5=%.6f φ6=%.6f φ7=%.6f\n",
                  (int)(i+1), s.cx, s.cy, (double)s.area,
                  (double)v[0],(double)v[1],(double)v[2],
                  (double)v[3],(double)v[4],(double)v[5],(double)v[6]);
        msg+=ln;
        if (++cnt>=10) break; // 너무 길면 최초 10개만
    }
    MessageBoxW(owner_, msg.c_str(), L"Invariant Moments", MB_OK|MB_ICONINFORMATION);

    if (IsDlgButtonChecked(h, IDC_CHK_IM_EXPORTCSV)==BST_CHECKED){
        wchar_t path[260]; GetDlgItemTextW(h, IDC_EDIT_IM_CSVPATH, path, 260);
        if (ExportInvariantCSV(path, R, opt.logScale)){
            MessageBoxW(h, L"CSV가 저장되었습니다.", L"Invariant Moments", MB_OK|MB_ICONINFORMATION);
        }else{
            MessageBoxW(h, L"CSV 저장 실패(경로/권한 확인).", L"Invariant Moments", MB_ICONWARNING);
        }
    }
}
```

```cpp
// main_multiwin.cpp (발췌)
#include "InvariantMomentsDlg.h"

// ...
case ID_MENU_INV_MOMENTS:
    if (st && st->dib){
        InvariantMomentsDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            UpdateStatusBasic(hWnd, st); // 상태바에 items/gray/per-label 등 표시 가능
        }
    }
    return 0;
```

---

## 4) 예제 시나리오 (실전)

### 예제 A) **기하학적 형태 분류 (원 vs 정사각형 vs 삼각형)**  
- **상황**: 단색 배경 위에 흰색 도형 하나(이진).  
- **절차**:  
  1) 필요 시 13.1의 이진화 수행 → 전경=255  
  2) `Analyze → Invariant Moments…` → _Use grayscale off_ / _Per connected component off_  
  3) **Run** → 팝업에 Hu 7개 출력(로그 스케일)  
- **관찰**:  
  - 원: \( \phi_2 \) 등 방향성 관련 항들이 작다.  
  - 삼각형/사각형: 특정 \( \phi_k \) 들이 상대적으로 크게 나타나며 서로 구별 가능.  
- **응용**: \((\phi_1,\dots,\phi_7)\) (혹은 그 하위 집합)을 **특징 벡터**로 사용하여 최근접 분류기 적용.

### 예제 B) **회전/스케일/이동 불변성 확인**  
- **상황**: 같은 도형을 위치·크기·각도를 바꿔 배치.  
- **절차**: 동일 설정으로 `Run` 후 결과 비교.  
- **결과**: 로그 스케일 Hu 값이 **대체로 일정**(수치 오차 범위) → 불변성 검증.

### 예제 C) **공장 검사(다수 객체) — 라벨별 불변 모멘트**  
- **상황**: 부품 여러 개(이진), 각 부품 클래스 판별 필요.  
- **절차**:  
  1) `Per connected component` 체크, **Min area**=100, **8-connected**  
  2) **Export CSV** 체크, 파일명을 `parts_moments.csv` 로 지정  
  3) **Run** → 각 라벨(부품)마다 행 1개로 CSV 저장  
- **활용**: CSV를 Python/R/Excel에서 로드해 **클러스터링/분류** 실행.

### 예제 D) **그레이스케일 불변 모멘트(밝기 분포 포함)**  
- **상황**: 같은 shape라도 내부 텍스처(밝기 분포)가 다른 샘플들.  
- **설정**: `Use grayscale weights` 체크 → 모멘트가 **형태+밝기** 를 함께 반영.  
- **결과**: 형태가 같아도 내부 밝기 구조가 다르면 Hu 값이 달라져 **구별력** 상승.

---

## 5) 정확성·성능·확장 팁

- **이진/그레이 선택**  
  - **형태만** 비교하면 `Binary01` 권장(본 코드에서 단일 계산 시 `Binary01` 또는 라벨별 0/1 가중).  
  - 내부 텍스처까지 반영하려면 `Grayscale` 선택.  
- **라벨링 최소 면적**: 작은 노이즈 제거에 중요. 상황에 맞게 25~200 정도 세팅.  
- **로그 스케일**: 스케일 차이가 큰 데이터에서 **정규화 후에도** 값 범위가 넓습니다. 로그 스케일은 시각화·분류 안정성에 유리.  
- **정규화 지수**: 본 구현은 \(p+q\in\{2,3\}\) 를 사용( Hu 불변량에 필요). 더 높은 차수 모멘트를 쓰는 경우 일반화하세요.  
- **수치형**: 누적은 `long double` 사용으로 오차 완화. 초대형 영상에서는 **타일링**/**64-bit 누적** 고려.  
- **추가 불변량**: Zernike, Legendre, Flusser 모멘트 등으로 확장 가능(정규직교 기저 기반).

---

## 6) 빠른 자가 테스트

```cpp
// test_invariant_moments.cpp
#include <cassert>
#include <cmath>
#include "IppDib.h"
#include "InvariantMoments.hpp"

static IppDib MakeDisc(int W,int H, int cx,int cy,int r){
    IppDib d; d.create(W,H,32);
    // 배경=0
    for(int y=0;y<H;++y){
        uint8_t* p=(uint8_t*)d.bits()+y*d.stride();
        for(int x=0;x<W;++x){ p[x*4+0]=p[x*4+1]=p[x*4+2]=0; p[x*4+3]=255; }
    }
    // 원 채우기(전경=255)
    for(int y=cy-r;y<=cy+r;++y){
        for(int x=cx-r;x<=cx+r;++x){
            int dx=x-cx, dy=y-cy; if (dx*dx+dy*dy<=r*r){
                uint8_t* p=(uint8_t*)d.bits()+y*d.stride()+x*4;
                p[0]=p[1]=p[2]=255;
            }
        }
    }
    return d;
}

int main(){
    // (1) 원형: 회전/이동/스케일 변화에 Hu가 거의 동일해야 함
    IppDib A=MakeDisc(200,160, 60,80, 20);
    IppDib B=MakeDisc(300,220, 140,160, 40); // 스케일 ↑, 이동

    InvariantOptions opt; opt.perLabel=false; opt.useGrayscale=false;
    InvariantResult RA,RB;
    bool okA=RunInvariantMoments(A,RA,opt), okB=RunInvariantMoments(B,RB,opt);
    assert(okA && okB && RA.items.size()==1 && RB.items.size()==1);

    // 로그 스케일 Hu 비교
    double diff=0.0;
    for(int i=0;i<7;++i){
        diff += std::fabs((double)RA.items[0].hu.logphi[i] - (double)RB.items[0].hu.logphi[i]);
    }
    assert(diff < 1e-2); // 대략적인 불변성 (해상도 차이/양자화에 따라 약간의 오차 허용)

    // (2) 라벨링 테스트: 두 개의 원
    IppDib C=MakeDisc(256,200, 70,100, 20);
    IppDib D=MakeDisc(256,200, 170,120, 20);
    // 합성
    for (int y=0;y<200;++y){
        uint8_t* c=(uint8_t*)C.bits()+y*C.stride();
        const uint8_t* d=(const uint8_t*)D.bits()+y*D.stride();
        for(int x=0;x<256;++x){ c[x*4+0]|=d[x*4+0]; c[x*4+1]|=d[x*4+1]; c[x*4+2]|=d[x*4+2]; }
    }
    opt.perLabel=true; opt.minArea=50;
    InvariantResult RC; okA=RunInvariantMoments(C,RC,opt);
    assert(okA && RC.items.size()==2);
    return 0;
}
```

---

## 7) 요약

- **영역 기반 모멘트**는 영상의 면적 분포를 다항식 가중으로 합산한 값이며,  
  **중심화**와 **스케일 정규화**를 통해 이동/스케일에 불변, **Hu 조합**으로 회전까지 불변한 **7개 특징**을 얻습니다.  
- 본 장의 코드는 **단일 객체**는 물론 **연결 성분별**로도 Hu를 계산하고,  
  **로그 스케일 출력**과 **CSV 내보내기**까지 지원합니다.  
- “**Invariant Moments…**” 대화 상자에서 **Grayscale/Per-label/Connectivity/Min area/CSV** 를 조절하여,  
  분류/검색/검사 워크플로우에 즉시 적용하세요.