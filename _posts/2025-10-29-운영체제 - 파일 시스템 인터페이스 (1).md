---
layout: post
title: 운영체제 - 파일 시스템 인터페이스 (1)
date: 2025-10-29 14:25:23 +0900
category: 운영체제
---
# Chapter 13 — File-System Interface

## File Concept

### 파일이란 무엇인가

- **정의**: 운영체제가 제공하는 **영속적 바이트 시퀀스**(또는 레코드 모음)에 **이름**을 붙이고 **메타데이터**(크기, 소유자, 권한, 시간 등)와 함께 관리하는 단위.
- **추상화 목표**
  1) **영속성**: 프로세스 생애를 넘어 데이터가 남는다.
  2) **공유/보호**: 여러 주체가 접근하되, 접근권은 통제된다.
  3) **장치 독립성**: HDD/SSD/NAS 여부와 무관하게 동일 인터페이스 제공.

### 파일 타입과 속성

- **타입**: 보통 커널은 **regular file, directory, character/block device, FIFO(named pipe), socket, symbolic link**를 구분한다.
- **확장자**: 운영체제 기능이 아니라 **사용자/도구 관례**(.txt, .jpg, .so, .dll). 일부 OS/FS는 **리소스 포크** 혹은 **MIME**/속성으로 타이프를 별도 기록한다.
- **필수 속성(예)**
  - 크기(bytes), 소유자(uid/gid), 권한(rwx), 접근/수정/변경 시각(atime/mtime/ctime), 링크 수, i-node/파일 ID, 플래그(읽기전용, 숨김 등), **확장 속성(xattr)**.
- **시간 의미**
  - **atime**: 읽을 때 갱신(성능을 위해 noatime 선택 가능)
  - **mtime**: 데이터 바이트를 수정할 때
  - **ctime**: 메타데이터 변경(권한/링크/소유권 등)

```c
// stat_show.c — 파일 메타데이터 조회(POSIX)
#include <sys/stat.h>
#include <stdio.h>

int main(int argc, char** argv){
  struct stat st; if(argc<2 || stat(argv[1], &st)) return 1;
  printf("size=%lld mode=%o nlink=%lu uid=%u gid=%u ino=%llu\n",
    (long long)st.st_size, st.st_mode & 0777, (unsigned long)st.st_nlink,
    st.st_uid, st.st_gid, (unsigned long long)st.st_ino);
  return 0;
}
```

### 파일 연산과 오픈 파일 표

- **API**: `create/open/read/write/lseek/truncate/close`, `fsync/fdatasync`, `rename/unlink`, `chmod/chown`, `link/symlink/readlink`.
- **오픈 파일 표(Open File Table)**
  - **시스템 전역 테이블**: “열린 객체”에 대한 상태(현재 offset, 모드, 잠금 등)를 보유.
  - **프로세스 테이블**: FD→전역 엔트리 참조. `fork()` 시 **FD 복제(공유 offset)**, `dup()`도 동일.
  - **공유 의미**: 같은 파일을 여러 FD로 열어도 **커널 객체(오프셋/플래그)** 공유 여부에 따라 동작이 달라질 수 있음.

### 바이트 스트림 vs 레코드 파일 vs 스파스 파일

- **바이트 스트림**(대다수 유닉스/리눅스): 애플리케이션이 구조를 정의.
- **레코드 파일**(전통적 메인프레임/일부 DB/OS): 고정/가변 길이 레코드로 논리 접근.
- **스파스 파일**: 파일에 **“구멍(hole)”** 영역이 존재, 실제로는 **저장공간이 할당되지 않음**.
  $$\text{논리크기} = \text{실제 저장된 크기} + \text{hole 크기}$$

```c
// sparse_make.c — 스파스 파일 만들기
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main(){
  int fd = open("sparse.bin", O_CREAT|O_WRONLY, 0644);
  write(fd, "HDR", 3);               // 3B
  lseek(fd, 1LL<<30, SEEK_SET);      // 1 GiB로 점프(할당 없음)
  write(fd, "END", 3);               // 3B
  close(fd);
  return 0;
}
```

### 파일 잠금과 공유 의미

- **Advisory lock**(권고 잠금, POSIX `fcntl(F_SETLK)`): 협력 프로세스끼리만 효력.
- **Mandatory lock**: 커널이 강제. 현대 리눅스/유닉스에선 드묾.
- **레코드 잠금**: 파일 일부 범위만 잠그는 범위 잠금.
- **공유 읽기 / 베타적 쓰기** 패턴으로 데이터 경합을 줄임.

### 파일 이름, 경로, 인코딩

- **경로 분리자**: POSIX `/`, Windows `\`(API는 `/`도 일부 허용).
- **대/소문자**: 리눅스는 **case-sensitive**, 윈도우/일부 macOS 볼륨은 **case-insensitive**(보통 preserve).
- **유니코드**: 파일 이름 정규화(NFC/NFD) 차이를 고려해야 함(동일 문자 다른 정규형).
- **보안**: NUL 포함 금지, 경로 순회(`..`) 필터링, **심볼릭 링크 레이스** 방지 필요.

---

## Access Methods

### 개관

- **Sequential**: 처음부터 끝까지 차례로 접근. 스트리밍/로그에 적합.
- **Direct(Random)**: 파일 오프셋 기반 **임의 위치** 접근. 인덱스/테이블/DB 파일에 적합.
- **Indexed/Keyed**: 별도 **색인(예: B+트리, 해시)** 로 키→오프셋 매핑 후 **직접 접근**.
- **Memory-mapped**: 주소 공간에 매핑하여 **배열처럼** 접근.
- **Record-based**: 고정/가변 길이 **레코드 단위**로 접근(전통 ISAM).

### 순차 접근(Sequential)

- **장점**: 단순, **리드어헤드** 효율↑, 대역폭 최적.
- **단점**: 임의 조회 비용↑.
- **실습**: 큰 파일을 블록 단위로 순차 읽기

```c
// seq_read.c — 순차 읽기
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

char buf[1<<20];
int main(int argc,char**argv){
  if(argc<2) return 1; int fd=open(argv[1],O_RDONLY);
  ssize_t n, tot=0; while((n=read(fd,buf,sizeof(buf)))>0) tot+=n;
  printf("read=%zd bytes\n",(ssize_t)tot); close(fd); return 0;
}
```

### 직접 접근(Direct/Random)

- **lseek/ pread/ pwrite** 로 **오프셋** 지정.
- **사용 예**: “N번째 레코드” 읽기, **인덱스 파일**이 가리키는 위치로 점프.

```c
// random_read.c — pread로 임의 위치에서 읽기
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char** argv){
  if(argc<4) return 1;
  int fd=open(argv[1],O_RDONLY); off_t off=atoll(argv[2]); size_t n=atoi(argv[3]);
  char* buf=new char[n]; ssize_t r=pread(fd, buf, n, off);
  write(1, buf, r); delete[] buf; close(fd); return 0;
}
```

### 인덱스 접근(Indexed/Keyed)

- **아이디어**: (키→오프셋) 맵을 유지해 **O(log N)** (B+트리) 또는 평균 **O(1)** (해시)로 위치 찾은 뒤 **직접 접근**.
- **CSV/로그 인덱싱 예제**: 특정 필드(예: ID)의 시작 오프셋을 인덱스로 저장.

```python
# build_index.py — 간단 CSV 인덱스(키=첫 컬럼, 값=파일 오프셋)

import sys, json
idx={}
with open(sys.argv[1],'rb') as f:
    off=0
    for line in f:
        key=line.split(b',',1)[0]
        idx[key.decode()]=off
        off+=len(line)
with open(sys.argv[2],'w',encoding='utf-8') as out:
    json.dump(idx,out,ensure_ascii=False)
```

```python
# lookup_index.py — 인덱스 사용해 한 줄 바로 읽기

import sys, json, os
idx=json.load(open(sys.argv[2]))
key=sys.argv[3]
off=idx[key]
with open(sys.argv[1],'rb') as f:
    f.seek(off); print(f.readline().decode().rstrip())
```

### 메모리 매핑 접근(Memory-Mapped)

- 장점: **복사 제거**, 랜덤 접근이 코드상 간단, OS가 **on-demand 페이지인**.
- 단점: 페이지 단위 I/O, 큰 랜덤 접근에서 **페이지 폴트 폭탄** 가능.

```c
// mmap_counter.c — 파일 매핑 후 특정 바이트 수 세기
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc,char**argv){
  if(argc<3) return 1;
  int fd=open(argv[1],O_RDONLY); struct stat st; fstat(fd,&st);
  unsigned char* p = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
  unsigned char target=(unsigned char)argv[2][0]; size_t c=0;
  for(off_t i=0;i<st.st_size;i++) if(p[i]==target) c++;
  printf("count=%zu\n",c); munmap(p,st.st_size); close(fd); return 0;
}
```

### 고정 길이 예

- **N번째 레코드**의 오프셋은
  $$ \text{offset}(N) = \text{header\_bytes} + N \times \text{record\_size} $$
- **장점**: 상수 시간 직관적 접근. **단점**: 가변 길이에 비해 공간 비효율.

```c
// fixed_record_get.c — 고정 길이 레코드 접근
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>

int main(int argc,char**argv){
  if(argc<4) return 1;
  int fd=open(argv[1],O_RDONLY);
  off_t header=atoll(argv[2]); size_t rsz=atoi(argv[3]); int nth=atoi(argv[4]);
  off_t off = header + (off_t)rsz * nth;
  char* rec=new char[rsz]; pread(fd,rec,rsz,off); write(1,rec,rsz);
  delete[] rec; close(fd); return 0;
}
```

---

## Directory Structure

### 디렉터리의 역할

- **(이름 → 파일 객체)** 매핑을 관리하는 **특수 파일**.
- 제공 기능: **lookup**, **create**, **link/unlink**, **list**, **rename**, **traverse**.
- 내부 표현(개념): `[(name, inode#), …]` 목록 또는 **B+트리/해시**.

### 경로 해석(Path Resolution)

- **절대 경로**: 루트로부터 `/a/b/c`
- **상대 경로**: 현재 작업 디렉터리 기준 `./x`, `../y`
- **순회 규칙**: 각 컴포넌트별로 디렉터리에서 name→inode를 찾는다.
- **심볼릭 링크**: 경로 치환을 동반(리다이렉트). **순환** 방지를 위한 **최대 hop** 제한 필요.

```python
# path_resolve_sim.py — 매우 단순한 경로 해석(메모리 상 트리)

class Node:  # dir or file
    def __init__(self, is_dir=True): self.is_dir=is_dir; self.ch={}
root=Node(True); root.ch["etc"]=Node(True); root.ch["etc"].ch["hosts"]=Node(False)

def resolve(path):
    cur=root
    for comp in [p for p in path.split("/") if p]:
        if comp=="." : continue
        if comp=="..": raise ValueError("no parent in this toy root")
        if comp not in cur.ch: raise FileNotFoundError(comp)
        cur = cur.ch[comp]
        if not cur.is_dir and comp!=path.split("/")[-1]:
            raise NotADirectoryError(comp)
    return cur

print(resolve("/etc/hosts").is_dir)  # False
```

### 디렉터리 구조의 유형

1) **Single-level**: 모든 파일이 한 디렉터리(충돌/확장성 부족).
2) **Two-level**: 사용자별 최상위 디렉터리(`/home/user/*`).
3) **Tree(계층)**: 현대 일반 구조. 서브트리/마운트 지점/권한 분리 수월.
4) **Acyclic Graph**: **하드 링크**로 동일 파일을 여러 디렉터리가 참조(디렉터리에는 보통 하드 링크 금지).
5) **General Graph**: **심볼릭 링크**까지 포함하면 순환 가능 → **탐색 깊이 제한** 필요.

### 하드 링크 vs 심볼릭 링크

- **하드 링크**: **같은 inode**를 가리킨다(동일 파일, 링크 수 증가). **파일 시스템 경계**를 넘지 못한다. 디렉터리에 하드 링크는 제한적/금지.
- **심볼릭 링크**: **문자열 경로를 저장**하는 별도 inode. 다른 볼륨/파일시스템도 가리킴. 대상이 없어지면 **dangling symlink**.

```bash
# 링크 예시

ln fileA hardA        # 하드 링크
ln -s /path/to/B symB # 심볼릭 링크
```

### 마운트와 네임스페이스

- **마운트 포인트**: 기존 트리의 특정 지점에 **다른 파일시스템**을 연결.
- 루트 `/` 아래에 **여러 FS(ext4, XFS, tmpfs, NFS, …)** 가 결합된 **단일 네임스페이스**를 형성.
- 컨테이너/네임스페이스: 프로세스 집합에 **격리된 mount view** 제공.

### 디렉터리 연산(실습 예제)

- **생성/열거/삭제** & **권한**을 OS 호출로 직접 조작.

```c
// dir_ops.c — 디렉터리 생성/열거/삭제(POSIX)
#define _GNU_SOURCE
#include <sys/types.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

int main(){
  mkdir("demo", 0755);
  FILE* f=fopen("demo/a.txt","w"); fputs("hello\n",f); fclose(f);
  mkdir("demo/sub",0755);
  FILE* g=fopen("demo/sub/b.txt","w"); fputs("hi\n",g); fclose(g);

  DIR* d=opendir("demo"); struct dirent* de;
  while((de=readdir(d))) printf("%s\n", de->d_name);
  closedir(d);

  unlink("demo/sub/b.txt"); rmdir("demo/sub");
  unlink("demo/a.txt"); rmdir("demo");
  return 0;
}
```

### 권한·소유권·ACL·UMASK

- **UNIX 권한**: `rwx` × (owner/group/others).
- **UMASK**: 새 파일/디렉터리 생성 시 **기본 권한에서 빼기**.
- **ACL**: 더 세밀한 규칙(사용자·그룹별 엔트리).

```bash
umask 022          # 새 파일은 644, 디렉터리는 755 근처
chmod 640 file     # rw- r-- ---
chown alice:dev file
# setfacl/getfacl (시스템에 따라)

```

### 디렉터리 내부 자료구조와 성능

- **리니어 리스트**: 단순하지만 큰 디렉터리에서 느림.
- **해시/트리**: 이름 해시로 **O(1)** 기대 또는 B+트리로 **O(log N)**.
- **엔트리 분할/머지, 슬록팅**, **디렉터리 레벨 캐시(dentry cache)** 로 경로 해석 가속.
- **경로 캐시**: 최근 경로의 컴포넌트→inode 매핑을 보관하여 반복 참조 비용 감소.

### 보안 이슈: TOCTOU, 심링크 레이스, 경로 정규화

- **TOCTOU(Time Of Check To Time Of Use)**: 체크와 사용 사이에 대상이 바뀌는 공격.
- **심링크 레이스 방지**: 디렉터리 FD를 기준으로 **상대 경로 전용 openat**, **`O_NOFOLLOW`** 사용.
- **정규화**: `..`/중복 슬래시 제거, 유니코드 정규화 차이 처리.

```c
// safe_openat.c — openat + O_NOFOLLOW로 심링크 레이스 완화
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main(){
  int dfd = open("trusted_dir", O_RDONLY|O_DIRECTORY);
  int fd  = openat(dfd, "user_file", O_RDONLY | O_NOFOLLOW);
  if(fd<0){perror("openat"); return 1;}
  // 안전하게 읽기…
  close(fd); close(dfd); return 0;
}
```

---

## 13.1–13.3 통합 시나리오: “수백만 줄 CSV 빠른 조회기”

**문제**: 200GB CSV에서 `id` 필드로 특정 레코드를 **수 ms** 내 반환하고 싶다.
**설계**
1) 원본 CSV는 **불변**으로 두고, 첫 컬럼을 키로 삼아 **(키→파일 오프셋)** 인덱스 파일(JSON/바이너리 B+tree) 생성.
2) 서버는 시작 시 인덱스를 **메모리 매핑**하여 빠른 조회 제공.
3) 요청당 `pread()`으로 한 줄만 읽는다(페이지 캐시가 리드어헤드 지원).
4) **TOCTOU 방지**: 원본/인덱스의 해시와 크기를 **동시에 검증**하고, 파일 교체는 `rename()`로 **원자적** 교체.
5) 병렬 처리: **FD per thread** 또는 `io_uring`으로 **비동기 pread** 파이프라인.

```c
// tiny_lookup.c — mmap 인덱스 + pread 본문(개념)
// (인덱스 포맷은 “키\t오프셋\n”의 정렬 텍스트라고 가정)
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <search.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct { const char* base; size_t len; } blob;

int cmp_key(const void* a, const void* b){
  // a: key string, b: line "key\tOFF\n"
  const char* ka = (const char*)a;
  const char* lb = *(const char**)b;
  const char* tab=strchr(lb,'\t'); size_t klen=tab-lb;
  int r = strncmp(ka, lb, klen);
  if(r==0 && ka[klen]!='\0') r = 1; // ensure exact
  return r;
}

int main(int argc,char**argv){
  if(argc<4){ fprintf(stderr,"usage: %s <csv> <index> <key>\n",argv[0]); return 1; }
  int ifd=open(argv[2],O_RDONLY); struct stat is; fstat(ifd,&is);
  char* imap = mmap(NULL,is.st_size,PROT_READ,MAP_PRIVATE,ifd,0);
  // 인덱스는 정렬된 라인 배열이라고 가정(안전성/현실성 고려 시 바이너리 포맷 권장)
  // 라인 포인터 배열 만들기
  size_t lines=0; for(size_t i=0;i<is.st_size;i++) if(imap[i]=='\n') lines++;
  char** ptrs = (char**)malloc(lines*sizeof(char*));
  size_t j=0; ptrs[j++]=imap; for(size_t i=0;i<is.st_size;i++) if(imap[i]=='\n' && i+1<is.st_size) ptrs[j++]=imap+i+1;

  // 이진 검색
  char** hit = bsearch(argv[3], ptrs, lines, sizeof(char*), cmp_key);
  if(!hit){ fprintf(stderr,"not found\n"); return 2; }
  // 오프셋 파싱
  char* tab=strchr(*hit,'\t'); long long off=atoll(tab+1);

  int cfd=open(argv[1],O_RDONLY);
  char buf[1<<20]; // 1MiB line upper bound 가정
  // 오프셋에서 한 줄
  off_t cur=off; ssize_t got=0; for(;;){
    ssize_t n=pread(cfd, buf+got, sizeof(buf)-got, cur);
    if(n<=0) break; got+=n;
    char* nl=memchr(buf,'\n',got);
    if(nl){ write(1, buf, nl-buf+1); break; }
    cur+=n;
  }
  close(cfd); munmap(imap,is.st_size); close(ifd); free(ptrs);
  return 0;
}
```

**운영 팁**
- 대형 디렉터리에서 인덱스 파일 수가 많다면 **디렉터리 해시/B+트리 기반** 파일시스템 선택(XFS, ext4 대형 디렉터리 최적 옵션)
- `openat`/`O_NOFOLLOW` 로 안전 열기, `rename()` 으로 원자적 교체
- 분산 환경에선 인덱스를 **NAS** 의 **read-only export** 로 제공, writer는 스테이징 후 스위치

---

## 수학적 인터메조: 캐시 히트율과 평균 접근시간

파일의 일부를 **페이지 캐시**에 두고 접근 확률이 Zipf(\(s\))라고 하면, 상위 \(K\) 페이지를 캐시할 때 히트율 근사:
$$
H(K) \approx \frac{\sum_{i=1}^{K} i^{-s}}{\sum_{i=1}^{N} i^{-s}}
$$
평균 접근시간 \(E[T]\)은
$$
E[T] \approx H(K)\cdot T_{\text{mem}} + (1-H(K))\cdot T_{\text{disk}}
$$
여기서 \(T_{\text{mem}}\ll T_{\text{disk}}\). **작업세트(workset)** 를 캐시에 담으면 체감 성능이 급격히 좋아진다.

---

## 체크리스트(실무 요약)

1) **파일 개념/메타**: 용량/권한/시간/링크/해시/확장속성(xattr) 요구를 정리하고 백업/무결성 전략(해시/CRC)을 세운다.
2) **접근 방식**: 순차/랜덤/인덱스/매핑 중 워크로드에 맞는 조합 선택.
3) **디렉터리**: 대형 디렉터리를 예상하면 해시/B+트리 기반 FS, **경로 캐시**와 `openat` 기반 안전한 이름 해석 채택.
4) **보안**: 심링크 레이스/TOCTOU 방지, 권한/UMASK/ACL 규정화.
5) **이식성**: 경로/대소문자/유니코드 정규화 차이를 고려해 **교차 플랫폼** 이름 정책을 문서화.
6) **테스트**: 스파스/대용량/긴 파일명/비ASCII/심볼릭 링크/마운트 경계 등 **엣지 케이스** 포함.

---

## 핵심 요약

- **13.1**: 파일은 **이름+바이트+메타데이터**의 추상화. 오픈 파일 표, 스파스, 잠금, 시간 의미를 정확히 이해해야 데이터 일관성/성능을 잡을 수 있다.
- **13.2**: **Sequential / Direct / Indexed / Mapped / Record** 접근은 상호 보완적 도구들이다. 인덱스와 `pread`, `mmap`을 조합하면 “거대한 파일 중 부분 조회”를 **저지연**으로 만들 수 있다.
- **13.3**: 디렉터리는 **이름→객체** 매핑의 핵심 인프라. 하드/심볼릭 링크, 마운트, 안전한 `openat`/경로 정규화, 대형 디렉터리의 자료구조(해시/B+트리)를 이해하면 **확장성과 보안**을 동시에 확보할 수 있다.
