---
layout: post
title: 알고리즘 - 집합과 맵
date: 2025-01-13 19:20:23 +0900
category: 알고리즘
---
# 집합(Set)과 맵(Map, 딕셔너리)을 활용한 알고리즘

## 기본기 리마인드: 왜 Set/Map 인가?

- **평균 \(O(1)\)** 탐색·삽입·삭제(해시 기반)
- **정렬 불필요**: 정렬 비용 없이 포함 여부·카운팅이 즉시 가능
- **자연스러운 모델링**: “존재/부재”는 `set`, “키→값 매핑/카운트”는 `dict`

> 최악 \(O(n)\)은 해시 충돌이 병적으로 발생하는 경우이지만, 파이썬의 해시 난수화로 실전에서 드뭄.

---

## Set — 핵심 연산, 복잡도, 주의점

### 핵심 연산·복잡도(평균)

| 연산 | 의미 | 복잡도 |
|---|---|---|
| `s.add(x)` | 원소 추가 | \(O(1)\) |
| `s.discard(x)` / `s.remove(x)` | 원소 제거(없어도 ok / 오류) | \(O(1)\) |
| `x in s` | 포함 여부 | \(O(1)\) |
| `s.clear()` | 비우기 | \(O(n)\) |
| `len(s)` | 크기 | \(O(1)\) |
| `s.pop()` | 임의 원소 제거(정해진 순서 아님) | \(O(1)\) 평균 |
| 집합 연산(합/교/차/대칭차) | 아래 1.2 | 대체로 \(O(n+m)\) |

### 집합 연산(알고리즘 풀이에서 자주 쓰는 패턴)

```python
A | B        # 합집합
A & B        # 교집합
A - B        # 차집합
A ^ B        # 대칭차집합 (합에서 교 제거)
A <= B       # 부분집합
A >= B       # 상위집합
```

- 예: “두 배열의 공통 원소 개수” → `len(set(a) & set(b))`
- 예: “하나에만 속한 원소” → `A ^ B`

### 자료형 주의: **키는 불변(immutable)이여야 함**

- `int`, `str`, `tuple(내부도 불변)`, `frozenset` 는 OK
- `list`, `set`, `dict` 는 **불가** (가변 → 해시 불가)

```python
ok = {(1, 2), (3, 4)}  # tuple은 키로 OK
bad = {[1, 2]}         # TypeError
```

---

## — 핵심 연산, 복잡도, 주의점

### 핵심 연산·복잡도(평균)

| 연산 | 의미 | 복잡도 |
|---|---|---|
| `d[k] = v` | 삽입/갱신 | \(O(1)\) |
| `d.get(k, default)` | 조회(없어도 기본값) | \(O(1)\) |
| `k in d` | 키 존재 | \(O(1)\) |
| `d.pop(k, default)` | 제거 | \(O(1)\) |
| `for k, v in d.items()` | 순회 | \(O(n)\) |

> 파이썬 3.7+에서 **삽입 순서 보존**이지만, 알고리즘에서는 순서 의존은 피하는 것이 안전.

### 카운팅 최강 콤보: `collections.Counter` / `defaultdict(int)`

```python
from collections import Counter, defaultdict

cnt = Counter([1,1,2,3,3,3])
cnt[3]        # 3
cnt[100]      # 0 (존재하지 않으면 0 반환)

freq = defaultdict(int)
for x in [1,2,1]:
    freq[x] += 1           # 키 초기화 없이 누적 가능
```

---

## 당신의 초안: 대표 문제 5종 — 풀이를 “완전” 보강

### — Set 탐색

- 아이디어: 상근이의 카드들을 `set`으로 만들고 질의 숫자를 `in`으로 검사.

```python
import sys
input = sys.stdin.readline

n = int(input())
have = set(map(int, input().split()))
m = int(input())
q = list(map(int, input().split()))
print(' '.join('1' if x in have else '0' for x in q))
```

- 복잡도: 구성 \(O(n)\) + 질의 \(O(m)\).

#### 확장 예시(중복 제거 전처리)

입력 배열에서 중복 제거 후 크기만 필요할 때 → `len(set(arr))`.

---

### — 중복 카운팅

- `Counter`로 카드 빈도 사전 생성 → 질의마다 조회.

```python
import sys
from collections import Counter
input = sys.stdin.readline

n = int(input())
cards = list(map(int, input().split()))
cnt = Counter(cards)
m = int(input())
q = list(map(int, input().split()))
print(' '.join(str(cnt[x]) for x in q))
```

- 복잡도: 구성 \(O(n)\), 질의 \(O(m)\), 메모리 \(O(\text{고유값})\).

#### 확장: 값 범위가 작을 때

- 값이 \([0,10^6]\) 등 **좁은 정수 범위**면 배열 카운터가 더 빠름.

---

### — Set 시뮬레이션

- `enter` → add, `leave` → discard
- 출력: 이름 내림차순

```python
import sys
input = sys.stdin.readline

n = int(input())
office = set()
for _ in range(n):
    name, cmd = input().split()
    if cmd == 'enter':
        office.add(name)
    else:
        office.discard(name)

for name in sorted(office, reverse=True):
    print(name)
```

- 주의: `remove` 대신 `discard`(없어도 에러 없음).

---

### — 양방향 매핑(dict↔dict)

- `group → [members_sorted]`
- `member → group`

```python
import sys
input = sys.stdin.readline

g, m = map(int, input().split())
group2members = {}
member2group = {}

for _ in range(g):
    group = input().strip()
    k = int(input())
    members = [input().strip() for _ in range(k)]
    group2members[group] = sorted(members)
    for name in members:
        member2group[name] = group

for _ in range(m):
    q = input().strip()
    t = int(input())  # 0: 그룹→멤버, 1: 멤버→그룹
    if t == 0:
        for name in group2members[q]:
            print(name)
    else:
        print(member2group[q])
```

- 패턴: **양방향 인덱스**는 질의가 양쪽으로 들어올 때 매우 유용.

---

### — Set + 문자열

- 모든 부분문자열을 `set`에 담아 중복 제거 후 크기 출력.

```python
import sys
s = sys.stdin.readline().strip()
subs = set()
n = len(s)
for i in range(n):
    for j in range(i+1, n+1):
        subs.add(s[i:j])
print(len(subs))
```

- 복잡도: \(O(n^2)\) 개 생성·삽입, 메모리도 \(O(n^2)\).
- **대형 입력**에서는 롤링 해시/접미사 배열/트리 등 고급기법이 필요.

---

## 실전 패턴: Set/Map으로 푸는 고전 과제들

### — Map으로 보완 검사

```python
def two_sum(arr, target):
    seen = {}
    for i, x in enumerate(arr):
        need = target - x
        if need in seen:
            return (seen[need], i)
        seen[x] = i
    return None
```
- 복잡도: \(O(n)\)

### 아나그램 그룹핑 — 정렬 키/카운트 키

```python
from collections import defaultdict, Counter

def group_anagrams(words):
    groups = defaultdict(list)
    for w in words:
        key = ''.join(sorted(w))  # 또는 tuple(Counter(w).items()) 정렬
        groups[key].append(w)
    return list(groups.values())
```

### 부분합으로 어떤 합이 되는 부분배열 개수 — Map 누적

- 누적합 \(S[i]=a_1+\cdots+a_i\).
- 구하고 싶은 것은 \(S[j]-S[i]=K \Rightarrow S[i]=S[j]-K\).
- 각 시점 `j`에서 **이전**에 등장한 `S[j]-K`의 빈도만큼 정답 추가.

```python
from collections import defaultdict

def count_subarrays_sum_k(a, K):
    ans = 0
    pref = 0
    freq = defaultdict(int)
    freq[0] = 1
    for x in a:
        pref += x
        ans += freq[pref - K]
        freq[pref] += 1
    return ans
```
- 복잡도: \(O(n)\)

### 윈도우에 포함된 서로 다른 문자 수 — Set/Map 혼용

- “서로 다른 문자 최대/최소 갱신”류는 **슬라이딩 윈도우 + 카운터**가 정석.

```python
from collections import defaultdict

def longest_k_distinct(s, K):
    freq = defaultdict(int)
    distinct = 0
    best = 0
    L = 0
    for R, ch in enumerate(s):
        if freq[ch] == 0:
            distinct += 1
        freq[ch] += 1
        while distinct > K:
            freq[s[L]] -= 1
            if freq[s[L]] == 0:
                distinct -= 1
            L += 1
        best = max(best, R - L + 1)
    return best
```

### 그래프 인접 리스트 — Map of Set/List

```python
from collections import defaultdict

adj = defaultdict(set)  # 중복 간선 배제하려면 set, 유지하려면 list
def add_edge(u, v):
    adj[u].add(v)
    adj[v].add(u)
```

---

## — Counter로 구현

- “원소가 몇 개 있는지”, “하나 제거”가 핵심.

```python
from collections import Counter

ms = Counter()
ms.update([1,1,2,3])
ms[1]        # 2
ms.subtract([1])  # 1의 개수 1 감소, 음수가 될 수 있음

# 안전한 제거(0 이하면 키 삭제)

def multiset_remove(ms, x, k=1):
    if ms[x] <= k:
        del ms[x]
    else:
        ms[x] -= k
```

- **슬라이딩 윈도우**에서 “들어오고 나가는” 원소 카운팅에 매우 유용.

---

## 키의 자료형·해싱 — 정확성과 성능을 좌우

### 불변 키만 허용

- 키로 `tuple`을 많이 사용(예: 좌표 `(r, c)`).
- 요소도 불변이어야 함(튜플 안 리스트는 안 됨).
- 집합의 집합이 필요하면 `frozenset`을 키로 사용.

```python
S = set()
S.add((2, 3))         # OK
S.add(frozenset({1})) # OK
```

### 사용자 정의 객체를 키로 — `__hash__`, `__eq__`

```python
class P:
    __slots__ = ('x', 'y')
    def __init__(self, x, y): self.x, self.y = x, y
    def __eq__(self, other): return self.x == other.x and self.y == other.y
    def __hash__(self): return (self.x * 1315423911) ^ self.y
```

- **동치이면 같은 해시**여야 함: `__eq__`가 `True`면 해시값도 같아야 일관.
- 불변처럼 취급할 것(값 바꾸면 해시 깨짐 → 셋/딕트에 넣은 뒤 변경 금지).

---

## 성능 최적화 팁(백준 스타일 대입출 포함)

1) **입출력**:
   `input = sys.stdin.readline` / `sys.stdout.write`로 대용량 가속
2) **로컬 바인딩**: 반복에서 함수·속성을 지역 변수로 바인딩
   ```python
   add = s.add
   for x in arr: add(x)
   ```
3) **리스트 컴프리헨션**: join/print 한 번에
4) **값 범위가 작을 때**: `Counter` 대신 **배열 카운터**가 더 빠름
5) **정렬이 필요할 때만** 정렬: 집합 원소 출력은 `sorted(s)`
6) **기억/시간 절약**: `defaultdict(int)` vs `Counter`(필요한 기능만)

---

## 문제 템플릿 모음 — 바로 가져다 쓰기

### — Set

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
S = {input().strip() for _ in range(n)}
ans = sum(1 for _ in range(m) if input().strip() in S)
print(ans)
```

### — 양방향 맵

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
name2id = {}
id2name = {}
for i in range(1, n+1):
    nm = input().strip()
    name2id[nm] = i
    id2name[i] = nm

for _ in range(m):
    q = input().strip()
    if q.isdigit():
        print(id2name[int(q)])
    else:
        print(name2id[q])
```

### — 카테고리별 조합 카운트(Map)

- 각 의상 종류에 대해 `(개수+1)`을 곱하고 전체에서 `-1`(하나도 안 입는 경우 제외).

$$
\text{답}=\prod_{c \in \text{category}} (\text{cnt}[c] + 1) - 1
$$

```python
import sys
from collections import Counter
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n = int(input())
    cnt = Counter()
    for _ in range(n):
        name, kind = input().split()
        cnt[kind] += 1
    ans = 1
    for k in cnt.values():
        ans *= (k + 1)
    print(ans - 1)
```

### — Set of Tuple

```python
visited = set()
def dfs(u):
    if u in visited: return
    visited.add(u)
    # ...
```

### 좌표 압축 — Map 정방향/역방향

```python
arr = [1000, 50, 50, 10]
vals = sorted(set(arr))
rank = {v:i for i, v in enumerate(vals)}
comp = [rank[x] for x in arr]
```

---

## “정렬 없는 탐색”을 더 강하게: 집합 연산으로 사고 전환

- **교집합 크기**: 공통 원소 개수 → `len(setA & setB)`
- **배열 중복 여부**: `len(arr) != len(set(arr))`
- **두 문자열 공통 문자 존재**: `bool(set(a) & set(b))`
- **누적 방문**: `seen |= new_candidates` (합집합)

---

## 경계/테스트 체크리스트

1) **키/원소가 가변인지**: list/set/dict는 키 불가
2) **순서 의존**: set/dict의 순서를 믿지 말 것(알고리즘 논리상)
3) **중복 입력**: 10816 류는 반드시 Counter/카운터 필요
4) **빈 입력/빈 집합**: `pop`, `max/min` 호출 전 예외 처리
5) **대소문자/공백**: 문자열 문제는 `strip()` 습관화
6) **I/O 병목**: 대용량 입력에서 `input()` 지양
7) **메모리**: 11478처럼 \(O(n^2)\) 부분문자열 세트는 메모리 초과 위험

---

## 수학·복잡도 한눈 요약

- 해시 기반 Set/Map 평균 연산:
  $$
  \text{평균: } O(1), \quad \text{최악: } O(n)\ (\text{충돌 시})
  $$
- 집합 연산(합/교/차/대칭차):
  $$
  O(|A|+|B|)
  $$
- 부분합 카운팅:
  $$
  O(n)
  $$

---

## 심화: OrderedDict / 삽입 순서 / 정렬된 맵이 필요할 때

- 파이썬 dict는 **삽입 순서 보존**(3.7+), 하지만 “정렬”되지 않음.
- 항상 정렬 상태를 유지하려면 `sortedcontainers` 같은 외부 라이브러리(경쟁 환경에서는 금지) 또는 **힙/이진탐색트리 자체 구현** 필요.
- 간단 정렬 출력이면 `for k in sorted(d)` 로 충분.

---

## 실전 레시피 요약표

| 요구 | 자료구조/기법 | 메모 |
|---|---|---|
| 존재 여부 빠르게 | `set` | \(O(1)\) 포함 |
| 값의 빈도 | `Counter`/`defaultdict(int)` | 멀티셋 |
| 양방향 조회 | 두 개의 `dict` | 이름↔번호, 멤버↔그룹 |
| 슬라이딩 윈도우 카운팅 | `Counter`/`defaultdict` | 진입/이탈 관리 |
| 중복 제거 | `set(arr)` | 크기 비교로 중복 확인 |
| 공통 원소/차집합 | `&`, `-` | 한 줄 풀이 |
| 좌표/상태 방문 | `set` of 튜플/불변 자료형 | 방문 체크 |
| 두 수의 합 | `dict`/`set` | 보완 검사 |
| 부분합 K개수 | `dict` | 누적합 빈도 |

---

## 종합 예제: “서로 다른 문자 K개 이하의 최장 부분문자열” + 출력 복원

```python
from collections import defaultdict

def longest_substring_k_distinct(s, K):
    freq = defaultdict(int)
    distinct = 0
    best = (0, 0)   # (길이, 시작)
    L = 0
    for R, ch in enumerate(s):
        if freq[ch] == 0:
            distinct += 1
        freq[ch] += 1
        while distinct > K:
            freq[s[L]] -= 1
            if freq[s[L]] == 0:
                distinct -= 1
            L += 1
        if R - L + 1 > best[0]:
            best = (R - L + 1, L)
    length, start = best
    return s[start:start+length]

print(longest_substring_k_distinct("eceba", 2))  # "ece"
```

- 핵심: 윈도우 내 **카운트 Map**으로 “조건(서로 다른 문자 수)” 유지.

---

# 결론

초안의 핵심(정의·평균 \(O(1)\) 탐색·대표 문제들)을 바탕으로, **Set/Map의 연산·복잡도·자료형 제약**을 명확히 하고, **고빈도 패턴(카운팅·보완 검사·부분합·윈도우·양방향 매핑·그래프)**을 템플릿과 함께 확장했다.
이제 문제를 보면 “**존재/중복/빈도/매핑/공통/차집합**”으로 재구성해 **정렬 없이 \(O(1)\)** 사고가 가능한지 먼저 떠올리고, 필요한 경우에만 정렬·힙·트리로 넘어가라. 이게 코딩테스트에서 시간을 가장 많이 아껴준다.
~~~markdown
