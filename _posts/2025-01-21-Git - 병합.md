---
layout: post
title: Git - merge
date: 2025-01-21 20:20:23 +0900
category: Git
---
# Git 브랜치 병합(Merge)

## 0. 병합의 목적(정리)

- **기능 브랜치(feature)**에서 작업 완료 → **메인 라인(main/develop)**으로 결과를 통합
- 팀 협업의 종착점: 코드 리뷰(PR) → 병합 정책에 맞는 방식으로 merge/squash/rebase-merge 선택
- 히스토리에 미치는 영향, 충돌 처리 비용, 릴리스 태그, 후속 디버깅 난이도까지 고려해야 함

---

## 1. 기본 병합 흐름(복습)

```bash
# 1. 기준 브랜치로 이동
git checkout main

# 2. 대상 브랜치 병합
git merge feature/login
```

- 기준(받을 쪽): `main`
- 대상(줄 쪽): `feature/login`

---

## 2. Fast-forward vs Non-Fast-forward (확장 설명)

### 2.1 Fast-forward
- 기준 브랜치가 대상 브랜치의 **직접 선조(ancestor)**이면 단순히 포인터만 앞으로 이동(병합 커밋 없음).
- 이력 선형, 깔끔. 다만 “브랜치가 있었는지” 흔적이 희미해질 수 있음.

```text
A---B---C (main)
         \
          D---E (feature)

# FF merge 결과
A---B---C---D---E (main)
```

실무 팁:
```bash
# FF만 허용(병합 커밋 방지)
git merge --ff-only feature/login
```

### 2.2 Non-Fast-forward(병합 커밋 생성)
- 두 브랜치가 **각자** 진화한 경우 Git이 **병합 커밋**을 생성
- 변경 맥락 보존, 다중 기능 통합 시 이력 이해가 쉬움

```text
A---B---C-----F (main)
     \     /
      D---E (feature)   # F: merge commit
```

옵션 예:
```bash
# 병합 커밋을 반드시 만들고 싶다면(특히 PR 리뷰 흔적 보존 목적)
git merge --no-ff feature/login
```

---

## 3. 병합 전략 옵션과 사용 시점

Git은 상황에 따라 다른 병합 전략/옵션을 제공합니다. (아래는 대표적인 것들)

```bash
# 기본 병합(자동 선택, 최신 git은 'ort' 전략이 기본)
git merge feature/x

# 병합 커밋 강제 생성(FF라도)
git merge --no-ff feature/x

# FF만 허용(병합 커밋 방지)
git merge --ff-only feature/x

# 병합 커밋 생성 직전까지(자동 커밋 X) → 결과 검토 후 수동 커밋
git merge --no-commit feature/x

# 전략 강제(특수 케이스에서)
git merge -s ours   feature/x   # 충돌 시 '우리 쪽'(현재 브랜치) 내용 유지
git merge -s subtree feature/x  # 서브트리 레이아웃 병합에 유용
```

> `-s ours`는 대상 브랜치 변경을 버리고 **현재 브랜치 내용을 채택**합니다(히스토리만 연결하고 내용은 유지).
> 잘못 사용하면 변경 손실이 발생하므로 릴리스 분기 종결 등 **특수 상황**에서만 신중히 사용하세요.

---

## 4. 스쿼시 병합(squash merge)

**여러 커밋을 하나로 압축**하여 메인 라인에 넣는 방식. 이력은 간결해지지만, 원 브랜치의 개별 커밋 히스토리/병합 관계는 사라집니다.

CLI:
```bash
git checkout main
git merge --squash feature/payment
git commit -m "feat(payment): introduce payment module (squashed)"
```

GitHub(PR)에서도 **Squash and merge** 버튼으로 동일한 효과.
사용 시점:
- 잦은 WIP 커밋이 많아서 메인 이력을 **요약**하고 싶을 때
- PR 리뷰 단위로 “한 기능 = 한 커밋” 원칙을 지킬 때

주의:
- 나중에 `git blame` 등에서 세부 커밋/라인 히스토리를 추적하기 어렵습니다.
- 기능 브랜치를 계속 활용하려면 스쿼시 이후 **브랜치 재동기화**에 유의하세요.

---

## 5. 충돌(Conflict) — 유형별 정리와 해결

### 5.1 대표 충돌 유형
- **내용(content) 충돌**: 동일 파일의 동일 영역이 다르게 수정
- **이름(rename) 충돌**: 서로 다른 경로/이름으로 변경
- **추가/추가(add/add)**: 같은 경로에 서로 다른 파일을 동시에 추가
- **삭제/수정(delete/modify)**: 한쪽은 삭제, 한쪽은 수정
- **디렉터리/파일(directory/file)**: 한쪽은 디렉터리, 다른 쪽은 파일로 존재
- **바이너리(binary) 충돌**: 자동 병합 불가 → 수동 선택 필요
- **서브모듈(submodule) 충돌**: 서로 다른 커밋 포인터를 가리킬 때

### 5.2 기본 해결 흐름
```bash
# 병합 시도
git merge feature/banner

# 충돌 발생
#   CONFLICT (content): Merge conflict in src/ui/Header.tsx

# 1. 충돌 파일 열어 수동 편집(마커 표기)
# <<<<<<< HEAD
# ours...
# =======
# theirs...
# >>>>>>> feature/banner

# 2. 수정 후 스테이징
git add src/ui/Header.tsx

# 3. 병합 완료 커밋(자동 생성되었거나 수동 커밋)
git commit -m "resolve: banner/header conflict"
```

### 5.3 시각적 도구 사용
```bash
git mergetool                         # OS/도구 설정에 따라 kdiff3, meld 등 실행
git config --global merge.tool meld   # 선호 도구 지정
```

### 5.4 재시도/중단
```bash
git merge --abort   # 병합 시작 전 상태로 되돌리기
```

### 5.5 리네임 충돌 힌트
- 충돌 메시지와 `git status`, `git diff --name-status --diff-filter=R` 참고
- 필요 시 한쪽 이름 채택 후 다른 쪽 변경을 수동 적용

---

## 6. 병합 전 사전 점검(충돌 예방)

```bash
# 1. 기준 브랜치 최신화
git checkout main
git pull --rebase origin main

# 2. 작업 브랜치를 최신 main 위로 리베이스(개인 브랜치일 때만 권장)
git checkout feature/x
git rebase main

# 3. 다시 main으로 병합
git checkout main
git merge feature/x
```

- 팀 규칙: **공유 브랜치에 rebase는 지양**(이력 재작성). 개인 브랜치에서만 rebase로 충돌 규모를 줄이는 것이 일반적.

---

## 7. 되돌리기(Undo): merge 커밋 revert vs reset

### 7.1 merge 커밋 되돌리기(revert)
병합이 이미 원격에 올라갔고 이력을 보존해야 할 때:
```bash
# -m 1 : 부모 중 '첫 번째 부모(main)'를 기준으로 되돌림
git revert -m 1 <merge-commit-sha>
```
- 충돌 가능 → 해결 후 커밋
- 안전하며, 이력을 **보존**합니다.

### 7.2 강제 되돌리기(reset)
공유 전(private)이고 이력 보존이 덜 중요할 때:
```bash
git reset --hard <되돌릴-커밋-SHA>
git push --force-with-lease
```
- 강력하지만 위험. 팀 합의/보호 규칙에 맞춰 신중히 사용.

---

## 8. 바이너리·대용량·서브모듈 병합 팁

### 8.1 바이너리 파일
- 자동 병합 불가 → **한쪽 선택** 또는 외부 도구 의존
- `.gitattributes`로 diff/merge 드라이버 제어:
```
*.png binary
*.psd -diff -merge
```

### 8.2 LFS(대용량 파일)
- 포인터/락(lock) 사용 여부 확인
- CI/개발 환경에서 `git lfs install` 누락 시 포인터만 남는 문제 발생

### 8.3 서브모듈
- 서로 다른 커밋 포인터 충돌 → 원하는 커밋으로 체크아웃 후 상위 리포에서 **해당 포인터를 커밋**
```bash
git submodule update --init --recursive
# 충돌 시 서브모듈 디렉터리 내려가서 원하는 커밋 checkout
git add path/to/submodule
git commit -m "fix(submodule): point to <sha>"
```

---

## 9. 히스토리 보기·검증 도구(강화)

```bash
git log --oneline --graph --decorate --all
git show <commit>
git diff main...feature/login         # 3점 리비전: 공통 조상부터 차이
git range-diff main...feature/login   # rebase 전후 비교(리뷰 편의)
git blame <file>                      # 변경 라인 추적(스쿼시하면 세부 히스토리 손실)
```

---

## 10. GitHub/호스팅의 병합 옵션과 팀 정책

- **Merge commit**: 기본. 리뷰 히스토리·브랜치 맥락 보존
- **Squash and merge**: “PR = 1 커밋” 원칙, 메인 이력 간결
- **Rebase and merge**: 선형 이력 유지(주의: 강한 정책/권장 도구 필요)

팀 보호 규칙:
- `main` 보호(Force push 금지, 필수 상태 체크, 최소 리뷰어 수)
- FF만 허용 또는 항상 merge commit 강제(정책에 따라)
- 릴리스 브랜치의 병합 전략을 운영 정책에 문서화

---

## 11. 실전 시나리오 6선

### 11.1 “브랜치 흔적을 남기고 싶다(항상 병합 커밋)”
```bash
git checkout main
git pull --rebase
git merge --no-ff feature/search
# 리뷰 흔적/브랜치 존재가 메인 히스토리에 남음
```

### 11.2 “선형 이력을 유지해야 한다(정책 상)”
```bash
# 개인 브랜치에서만 rebase
git checkout feature/search
git fetch origin
git rebase origin/main

git checkout main
git merge --ff-only feature/search
```

### 11.3 “자동 커밋 전에 결과를 검토하고 싶다”
```bash
git checkout main
git merge --no-commit feature/metrics
# 워킹트리/인덱스 확인, 필요 수정
git commit -m "merge: feature/metrics into main"
```

### 11.4 “대형 리네임 + 수정 충돌”
```bash
# 리네임 감지 파라미터 강화(필요 시)
git config merge.renames true
git config diff.renames  true

# 충돌 파일을 '이름 이동'으로 인식시키고 내용 수동 병합
git mergetool
```

### 11.5 “바이너리 에셋 충돌”
```bash
# 한쪽 선택(ours/theirs)
git checkout --ours   path/to/logo.psd   # 현재 브랜치 버전 채택
# 또는
git checkout --theirs path/to/logo.psd   # 병합 대상 브랜치 버전 채택
git add path/to/logo.psd
git commit -m "resolve: choose ours for logo.psd"
```

### 11.6 “서브모듈 충돌(서로 다른 커밋 포인터)”
```bash
cd modules/libA
git checkout <원하는-서브모듈-커밋>
cd ../..
git add modules/libA
git commit -m "fix(submodule): point libA to <sha>"
```

---

## 12. merge vs rebase(확장 요약)

| 항목 | merge | rebase |
|---|---|---|
| 이력 형태 | 브랜치 구조 보존(분기/병합) | 선형화(깔끔) |
| 충돌 처리 | 병합 시 한 번 | rebase 과정에서 여러 번(커밋 단위) |
| 협업 안전성 | 높음(이력 보존) | 공유 브랜치에서 위험(이력 재작성) |
| 사용 맥락 | PR/팀 통합, 기록 보존 | 개인 브랜치 정리, 리뷰 전 선형화 |

> 팀 합의가 최우선. “개인 브랜치 rebase, 메인 병합 정책 준수”가 실무에서 흔한 절충안입니다.

---

## 13. 명령어 요약(치트시트)

```bash
# 기본
git checkout main
git merge feature/x

# FF 정책
git merge --ff-only feature/x     # FF만 허용
git merge --no-ff feature/x       # 병합 커밋 강제

# 스쿼시
git merge --squash feature/x
git commit -m "feat(x): squashed"

# 충돌 해결
git status
git mergetool
git add <files>
git commit -m "resolve: ..."

# 중단/재시도
git merge --abort

# 되돌리기
git revert -m 1 <merge-commit-sha>   # merge 커밋 되돌리기(안전)
git reset --hard <sha>               # 강제 되돌리기(주의)
git push --force-with-lease

# 히스토리 관찰
git log --oneline --graph --decorate --all
git diff main...feature/x
git range-diff main...feature/x
```

---

## 14. 연습용 미니 레포 시나리오(로컬에서 재현)

```bash
# 준비
mkdir merge-lab && cd merge-lab
git init
echo "v1" > app.txt
git add app.txt
git commit -m "init: app v1"
git branch -M main

# feature 브랜치
git checkout -b feature/ui
echo "header=v1" >> app.txt
git commit -am "feat(ui): header v1"

# main도 변경
git checkout main
echo "core=v1" >> app.txt
git commit -am "feat(core): core v1"

# 병합(Non-FF)
git merge feature/ui

# 충돌 유도
git checkout -b feature/ui-2
echo "header=v2" >> app.txt
git commit -am "feat(ui): header v2"
git checkout main
echo "header=vX" >> app.txt
git commit -am "feat(core): header tweak"

# 병합 시 충돌 발생
git merge feature/ui-2
# 파일 열어 충돌 해결 → add → commit
```

---

## 15. 결론

- 병합은 “코드 통합” 이상의 의미: **이력 설계, 리뷰 가시성, 디버깅 난이도, 릴리스 안정성**에 직결됩니다.
- 팀 정책에 맞춰 **FF/Non-FF/스쿼시/리베이스**를 적절히 사용하고, **충돌 유형별 대응**을 숙지하세요.
- 문제가 생기면 **revert**로 안전하게 되돌리고, 필요 시 **reset**은 팀 합의 아래 신중히.
- 바이너리/리네임/서브모듈/LFS 등 **특수 자산**의 병합 규칙을 `.gitattributes`와 가이드로 명시해두면 사고를 크게 줄일 수 있습니다.

---

## 참고
- Git Merge 공식 문서: https://git-scm.com/docs/git-merge
- GitHub 병합 가이드: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/merging-a-pull-request
