---
layout: post
title: DB 심화 - 동시성 구현 사례
date: 2025-10-19 20:25:23 +0900
category: DB 심화
---
# 동시성 높이기**, **선분이력(유효기간) 정합성 유지** (19c 기준)

> 목표
> - **일련번호 채번**의 다양한 요구(글로벌 증가/순서성/갭 허용 여부/분산·RAC)에서 **동시성·처리량**을 크게 높이는 패턴을 정리.
> - **선분이력(시점/유효기간 기반 이력; SCD Type 2)** 의 **무겹침(Non-overlap)**·**연속성(Contiguity)**·**동시성 충돌 방지**를 데이터베이스 레벨에서 견고히 보장하는 방법을 제시.
> - **예제 코드**(SQL/PL/패턴)와 **운영 팁**, **성능·정합성** 간 트레이드오프를 명확히 설명.

---

## 일련번호 채번 동시성 높이기

### 요구 사항 분해

- **글로벌 단조 증가**(모두가 "더 큰 숫자"만 받음) vs **진짜 순서 보장**(시간순=발급순).
- **갭 허용 여부**: `SEQUENCE`는 **갭 발생** 가능(롤백/캐시 손실 등).
- **RAC/샤딩**: 노드 간 병렬 발급 시 **병목 제거**가 핵심.
- **핫 인덱스 블록 문제**: 증가하는 키는 **인덱스 우측(리프 끝) 핫스팟**을 만든다.

현실 법칙: **"진짜 gap-less"** & **"글로벌 시간순"** & **"초고처리량"**을 **동시에** 달성하기는 매우 어렵다. 보통 **2가지를 택하고 1가지는 포기**한다. (예: *순서성+처리량*을 택하면 *gap-less* 포기)

---

### 기본: Oracle `SEQUENCE` 성능 최적화

#### 캐시와 순서옵션

```sql
-- 고처리량 (RAC까지 고려) 기본 예: NOORDER + 넉넉한 CACHE
CREATE SEQUENCE seq_order_id
  START WITH 1
  INCREMENT BY 1
  CACHE 10000
  NOORDER  NOCYCLE;

-- "인스턴스 간 순서 보장" 필요 시: ORDER (하지만 확장성↓)
CREATE SEQUENCE seq_order_id_ordered
  START WITH 1
  INCREMENT BY 1
  CACHE 1000
  ORDER NOCYCLE;
```
- **`CACHE`↑**: 래치/뮤텍스 경합 및 디스크 액세스 감소 → **발급 속도↑**.
- **`NOORDER`**(권장, 특히 RAC): 인스턴스별로 캐시 분배, **글로벌 발급순서 보장은 약함**이지만 **확장성↑**.
- **`ORDER`**: 글로벌 순서 보장 대가로 **GES(글로벌 동기)** 증가 → **처리량↓**.

#### 사용 패턴

```sql
-- INSERT 시 채번
INSERT INTO orders (order_id, customer_id, amount)
VALUES (seq_order_id.NEXTVAL, :cid, :amt);

-- 반환이 필요하면
INSERT INTO orders (order_id, customer_id, amount)
VALUES (seq_order_id.NEXTVAL, :cid, :amt)
RETURNING order_id INTO :v_order_id;

-- 혹은 SELECT만
SELECT seq_order_id.NEXTVAL INTO :v FROM dual;
```

#### 인덱스 핫스팟 완화

- **Reverse Key Index**: 증가 키의 리프 편향을 분산.
```sql
CREATE INDEX pk_orders_rev ON orders(order_id) REVERSE;
```
  - **장점**: 동시 삽입 시 **리프 핫블록 경합↓**.
  - **주의**: 범위 스캔이 필요하면 부적합(정렬·범위 조회가 비싸짐).
- **Hash 파티셔닝**: PK 또는 대체 파티션 키로 **삽입 분산**.
```sql
CREATE TABLE orders (
  order_id NUMBER PRIMARY KEY,
  ...
)
PARTITION BY HASH(order_id)
PARTITIONS 16;
```

---

### RAC/분산에서 더 빠르게: "스트라이프드 시퀀스(Striped Sequences)"

아이디어: **여러 시퀀스**를 준비해 **세션/노드/샤드**별로 **라운드로빈** 혹은 **해싱**으로 분배해 발급 병목을 제거.

```sql
-- 예: 8-way 스트라이프
CREATE SEQUENCE seq_order_id_0 CACHE 10000 NOORDER;
CREATE SEQUENCE seq_order_id_1 CACHE 10000 NOORDER;
...
CREATE SEQUENCE seq_order_id_7 CACHE 10000 NOORDER;

-- 애플리케이션 (의사코드)
s := session_id() MOD 8;
order_id := NEXTVAL(seq_order_id_s);
```

- **장점**: 단일 시퀀스에 몰리는 **뮤텍스/래치 경합**을 **8개로 분산**.
- **단점**: **글로벌 순서**가 느슨해짐(시퀀스 간 교차). **갭**은 여전히 존재.

---

### 패턴 — 앱 측 대량 발급

아이디어: DB는 **큰 단위 블록(Hi)** 만 부여하고, 앱은 그 안에서 **Lo**를 자체 증가. DB round-trip을 **블록 당 1회**로 줄여 **폭증 처리량** 달성.

```sql
-- hi 블록을 관리하는 테이블
CREATE TABLE id_allocator (
  name       VARCHAR2(30) PRIMARY KEY,  -- 'ORDER'
  next_hi    NUMBER NOT NULL
);

INSERT INTO id_allocator VALUES ('ORDER', 1);
COMMIT;

-- 다음 hi 블록을 가져오는 프로시저(원자적 증가)
CREATE OR REPLACE FUNCTION alloc_hi(p_name IN VARCHAR2) RETURN NUMBER IS
  l_next NUMBER;
BEGIN
  UPDATE id_allocator
     SET next_hi = next_hi + 1
   WHERE name = p_name
  RETURNING next_hi INTO l_next;
  COMMIT; -- 또는 호출자가 트랜잭션 경계 관리
  RETURN l_next;
END;
/

-- 애플리케이션 로직(의사):
--   hi := alloc_hi('ORDER');  -- 1회 DB 호출
--   base := (hi-1) * 1000000; -- 블록 크기: 1,000,000
--   for k in 1..N:
--      order_id := base + k   -- Lo 사용
```

- **장점**: DB 호출 **극소화**, **폭발적 처리량**.
- **단점**: **프로세스 크래시** 시 블록의 **미사용 여분 → 갭**.
- **글로벌 단조 증가**는 유지되나 **시간순=발급순**은 보장 안 될 수 있음(노드 시간/블록 배정 순서).

---

### "진짜 gap-less"가 꼭 필요하다면? (주의)

- **트랜잭션 확정(커밋) 시점에만 번호를 발급**해야 한다.
- 실무적으로는 **낮은 처리량**을 감수하고 **단일 테이블+행 잠금**으로 구현:

```sql
CREATE TABLE gapless_counter (
  key  VARCHAR2(30) PRIMARY KEY,
  val  NUMBER NOT NULL
);

INSERT INTO gapless_counter VALUES('ORDER', 0);
COMMIT;

-- 발급 (gap-less; 직렬 병목)
DECLARE
  l_val NUMBER;
BEGIN
  -- 단일행 잠금
  SELECT val INTO l_val
  FROM   gapless_counter
  WHERE  key = 'ORDER'
  FOR UPDATE;

  l_val := l_val + 1;

  UPDATE gapless_counter
     SET val = l_val
   WHERE key = 'ORDER';

  COMMIT;  -- 커밋된 건만 번호가 살아남음
  :v_order_no := l_val;
END;
/
```

- **처리량이 낮고 교착/대기가 많다.**
- 법/회계 등 "**정말** 갭 없는 번호"가 필요한 **소량** 발급 시에만 권장.
- 대량 트래픽은 **현실적으로 갭 허용**을 설득하거나, **일(日)·점포별 범위**로 분할해 병목을 줄인다.

---

### 인덱스/스토리지까지 포함한 전체 성능 팁

- **PK 인덱스 핫스팟**: Reverse Key / Hash 파티션 / 랜덤화(Hi/Lo+셔플)로 분산.
- **대량 INSERT**: APPEND/TABLELOCK는 동시성·행수준락과 상충(주의).
- **커밋 정책**: 너무 잦은 커밋은 `log file sync` 증가. **합리적 배치 크기**로 묶기.
- **RAC**: NOORDER, 스트라이프, 파티션 로컬 인덱스, 서비스/파티션 고정으로 **캐시 지역성** 확보.

---

## 선분이력 정합성 유지 (유효기간 이력, Non-Overlap/Contiguity)

용어
- **선분이력**: `(entity_id, valid_from, valid_to)` 로 표현되는 **기간 기반 이력**(SCD Type 2).
- 요구:
  1) **무겹침(Non-Overlap)** — 동일 `entity_id` 에 대해 유효구간이 **겹치면 안 됨**.
  2) **연속성(Contiguity)** — 정책에 따라 `valid_to` 와 **다음 행의 `valid_from`** 이 **연결**되어야 함(옵션).
  3) **동시성** — 여러 세션이 같은 개체의 이력을 동시에 수정할 때 **정합성** 유지.

### 테이블 스키마(기본형)

```sql
CREATE TABLE person_hist (
  person_id   NUMBER NOT NULL,
  valid_from  DATE   NOT NULL,
  valid_to    DATE   NOT NULL,
  name        VARCHAR2(100),
  status      VARCHAR2(30),
  CONSTRAINT pk_person_hist PRIMARY KEY (person_id, valid_from)
);

-- 기본 무결성
ALTER TABLE person_hist
  ADD CONSTRAINT chk_range
  CHECK (valid_from <= valid_to);
```

**Primary Key를 (person_id, valid_from)** 로 잡아 **시간순 삽입**을 촉진하고, 인덱스 탐색과 동시성 제어를 쉽게 한다.

---

### 보장 — 핵심 알고리즘

**문제**: Oracle은 Postgres의 "Exclusion Constraint" 처럼 **네이티브 비겹침 제약**이 없다.
**해결**: **동일 개체(person_id) 단위로 직렬화된 수정**을 보장하고, 삽입/수정 시 **겹침 여부를 검증**한다.

#### "자연 직렬화" — **잠금 대상 행을 선정**해 직렬화

- **잠금용 센티넬(sentinel) 행** 또는 **최근 이력 행을 `FOR UPDATE`로 잠금**:
  - 같은 `person_id`에 대한 병행 작업은 **한 시점에 하나**만 진행되도록 한다.
  - 구현이 간단하고, **성능/정합성** 균형이 좋다.

```sql
-- 최근 이력(마지막 선분) 잠금
SELECT valid_from, valid_to
FROM   person_hist
WHERE  person_id = :pid
ORDER  BY valid_from DESC
FETCH FIRST 1 ROW ONLY
FOR UPDATE;   -- 이 잠금으로 동일 pid 병행 수정 직렬화
```

#### 겹침 검증 쿼리

- 새로 넣으려는 선분 `(:f, :t)` 이 **기존 선분**과 **겹치지 않는지** 확인:

```sql
-- 겹침 존재 여부 검사
SELECT 1
FROM   person_hist
WHERE  person_id = :pid
  AND  NOT (:t < valid_from OR :f > valid_to)   -- De Morgan; 겹침 조건
FETCH FIRST 1 ROW ONLY;
```

- 결과가 존재하면 **에러** 발생 → **애플리케이션에서 보정**(수정/분할/밀착).

수학적 표현:
$$ \text{Overlap}((f_1,t_1),(f_2,t_2)) \iff \neg (t_1 < f_2 \ \lor\ f_1 > t_2) $$

---

### 보장 — 정책화

- **정책 A(밀착)**: `next.valid_from = cur.valid_to + 1일` (일 단위 캘린더)
- **정책 B(겹침 금지 + 공백 허용)**: 연속이면 더 좋지만 **비연속도 허용**
- **정책 C(실시간 시점)**: `valid_to` 를 **시각**까지 사용(초/밀리초). 동일 초 처리 주의.

**밀착 검증(옵션)**
```sql
-- 새 선분 (f,t)를 넣을 때 이전 선분 prev_t와 연속성 체크
-- prev.valid_to + 1일 = f ?
SELECT valid_to
FROM   person_hist
WHERE  person_id = :pid
  AND  valid_to <  :f
ORDER  BY valid_to DESC
FETCH FIRST 1 ROW ONLY;

-- 애플리케이션/프로시저에서 (prev.valid_to + 1) = :f 강제
```

- **시간 단위**(TIMESTAMP)로 운용 시: "+1초" 같은 절대 오프셋 대신 **바로 이전 끝 시각 = 다음 시작 시각**을 요구.

---

### PL/SQL API — "한 번에 안전 삽입/교체"

요구: `person_id=:pid` 대상에 **새 선분** `(:f,:t,name,status)` 를 **겹침 없이** 넣고, **연속성 옵션**이 켜져 있으면 **이전 끝시각**을 **자동 맞춤**.

```sql
CREATE OR REPLACE PROCEDURE upsert_person_hist(
  p_pid    IN NUMBER,
  p_from   IN DATE,
  p_to     IN DATE,
  p_name   IN VARCHAR2,
  p_status IN VARCHAR2,
  p_enforce_contiguity IN BOOLEAN DEFAULT TRUE
) IS
  l_prev_from DATE;
  l_prev_to   DATE;
  l_has_overlap NUMBER;
BEGIN
  IF p_from > p_to THEN
    RAISE_APPLICATION_ERROR(-20001, '기간 역전(valid_from > valid_to)');
  END IF;

  -- 1) 최근 선분 잠금으로 pid 단위 직렬화
  BEGIN
    SELECT valid_from, valid_to
      INTO l_prev_from, l_prev_to
    FROM (
      SELECT valid_from, valid_to
      FROM   person_hist
      WHERE  person_id = p_pid
      ORDER  BY valid_from DESC
    )
    WHERE ROWNUM = 1
    FOR UPDATE;   -- 없으면 NO_DATA_FOUND
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      NULL; -- 최초 삽입 케이스
  END;

  -- 2) 겹침 검사
  SELECT COUNT(*)
    INTO l_has_overlap
  FROM   person_hist
  WHERE  person_id = p_pid
    AND  NOT (p_to   < valid_from OR p_from > valid_to);

  IF l_has_overlap > 0 THEN
    RAISE_APPLICATION_ERROR(-20002, '겹치는 기간 존재');
  END IF;

  -- 3) 연속성 정책 적용(옵션)
  IF p_enforce_contiguity AND l_prev_to IS NOT NULL THEN
    -- 일 단위: 이전 끝 다음날이 새 시작이어야 함
    IF (l_prev_to + 1) <> p_from THEN
      -- 자동 보정(정책에 따라 거부로 바꿀 수도)
      UPDATE person_hist
         SET valid_to = p_from - 1
       WHERE person_id  = p_pid
         AND valid_from = l_prev_from;
    END IF;
  END IF;

  -- 4) 삽입
  INSERT INTO person_hist(person_id, valid_from, valid_to, name, status)
  VALUES (p_pid, p_from, p_to, p_name, p_status);

  COMMIT;
END;
/
```

- **포인트**
  - `FOR UPDATE` 로 **pid별 직렬화** → **경합은 대기**로 흡수되며 **겹침 금지** 보장.
  - 연속성은 **정책**(자동 보정 / 거부)으로 나눠 구현.
  - **동일 pid에 대한 병행 요청**이 많으면 큐잉도 고려.

---

### — 중간 시점 교체

새 선분이 기존 선분의 중간을 가로지르면 **기존 선분 분할**이 필요("스플릿").

```sql
-- 예시: 기존 [2024-01-01, 2024-12-31] 이 있는데
--       새 [2024-06-10, 2024-08-20] 를 삽입하려는 경우

-- 0) pid 직렬화 잠금
-- 1) 겹침 검증
-- 2) 기존 선분을 두 조각으로 분할
UPDATE person_hist
   SET valid_to = DATE '2024-06-09'
 WHERE person_id  = :pid
   AND valid_from = DATE '2024-01-01';

INSERT INTO person_hist(person_id, valid_from, valid_to, name, status)
VALUES (:pid, DATE '2024-06-10', DATE '2024-08-20', :name, :status);

INSERT INTO person_hist(person_id, valid_from, valid_to, name, status)
VALUES (:pid, DATE '2024-08-21', DATE '2024-12-31', :name_old, :status_old);

COMMIT;
```

- **주의**: 선분 분할 시에도 **겹침 금지**·**연속성 유지**가 깨지지 않도록 **트랜잭션 하나**에서 처리.

---

### 고동시성 큐잉 — `SKIP LOCKED`로 병행성 높이기

동일 `person_id` 에 대한 **이력 변경 요청**이 **폭주**하는 경우,
**(1) 요청을 큐 테이블에 쌓고** →
**(2) 워커들이 `FOR UPDATE SKIP LOCKED`** 로 **서로 다른 pid**만 집어가 처리.

```sql
CREATE TABLE hist_jobs (
  job_id     NUMBER PRIMARY KEY,
  person_id  NUMBER NOT NULL,
  payload    CLOB,
  status     VARCHAR2(10) DEFAULT 'READY'
);

-- 워커(동시에 N개 동작)
DECLARE
  CURSOR c IS
    SELECT job_id, person_id, payload
    FROM   hist_jobs
    WHERE  status = 'READY'
    FOR UPDATE SKIP LOCKED;
BEGIN
  FOR r IN c LOOP
    -- 1) person_id 잠금+이력 처리(§2.4 절차)
    -- 2) 완료 후:
    UPDATE hist_jobs
       SET status='DONE'
     WHERE CURRENT OF c;
    COMMIT;
  END LOOP;
END;
/
```

- **효과**: 같은 `person_id` 작업은 **자연 직렬화**, 서로 다른 `person_id` 는 **병렬 처리**.
- **장점**: 응답 시간 안정, 워커 수로 **처리량 선형 확장**.

---

### 보조 제약 및 진단 인덱스

- **빠른 겹침 검증**을 위해 `(person_id, valid_from)` PK 외에 `(person_id, valid_to)` 또는 `(person_id, valid_from, valid_to)` 보조 인덱스 고려.
- **데이터 헬스체크**(야간 배치로 정합성 검증):

```sql
-- 겹침 탐지 리포트
SELECT a.person_id, a.valid_from a_f, a.valid_to a_t,
       b.valid_from b_f, b.valid_to b_t
FROM   person_hist a
JOIN   person_hist b
  ON   a.person_id = b.person_id
 AND   a.valid_from < b.valid_from
 AND   NOT (a.valid_to < b.valid_from)
FETCH FIRST 100 ROWS ONLY;

-- 비연속(구멍) 탐지(옵션, 일 단위)
WITH s AS (
  SELECT person_id,
         valid_from,
         LAG(valid_to) OVER (PARTITION BY person_id ORDER BY valid_from) AS prev_to
  FROM   person_hist
)
SELECT person_id, prev_to, valid_from
FROM   s
WHERE  prev_to IS NOT NULL
AND    (prev_to + 1) <> valid_from;
```

---

## 둘을 함께 쓰는 복합 시나리오

### + 계약 이력(선분) 동시 처리"

- **Step 1**: **일련번호**는 `SEQUENCE`(+CACHE/스트라이프/HiLo)로 **고처리량** 발급.
- **Step 2**: **선분이력**은 **pid 직렬화 잠금 + 겹침검사**로 정합성 보장.
- **트랜잭션 분리**: 대량 트래픽이면 **채번·기본 레코드 INSERT** 와 **이력 반영**을 **비동기화**(큐)하여 피크를 분산.

---

## 성능·정합성 튜닝 관점

### 일련번호
- **SEQUENCE**: `CACHE`↑, `NOORDER` (RAC), **스트라이프**(여러 시퀀스), **Hi/Lo**(앱 대역)를 활용하세요.
- **인덱스 핫스팟**: Reverse Key/Hash 파티션/샤딩으로 분산하세요.
- **갭 요구**: 진정한 gap-less는 **단일행 잠금 카운터** + **낮은 TPS** + **장애/재시도 설계**를 요구합니다.

### 선분이력
- **pid 직렬화**: 최근 행 `FOR UPDATE`(또는 센티넬 행) — **겹침 금지**의 기초입니다.
- **검증 쿼리**: 겹침 조건(De Morgan)을 정확히, 인덱스로 빠르게 실행되도록 하세요.
- **연속성**: 정책(자동 보정 vs 거부)을 명시화하세요.
- **스플릿**: 한 트랜잭션에서 분할·삽입·보정까지 일괄 처리하세요.
- **대량 동시성**: `SKIP LOCKED` 큐로 수평 확장하세요.
- **정기 헬스체크**: 야간 배치로 겹침/구멍 리포트 → 자동 정비 도구를 구축하세요.

---

## 수학 감각(개념 근사)

- **SEQUENCE 발급 평균 비용**
  $$ \mathbb{E}[C_{\text{seq}}] \approx C_{\text{hit}} + \frac{1}{\text{CACHE}} \cdot C_{\text{miss}} $$
  `CACHE`가 클수록 **미스 비용**이 희석되어 평균 비용이 줄어든다.

- **Hi/Lo의 DB 라운드트립**
  $$ N \text{건 발급시 DB호출} \approx \left\lceil \frac{N}{\text{BLOCK\_SIZE}} \right\rceil $$
  `BLOCK_SIZE`↑ → DB호출↓ → 처리량↑(단, **갭**↑).

---

## FAQ

**Q1. "ORDER" 시퀀스가 왜 느리죠?**
A. RAC/병렬에서 **글로벌 순서 보장** 때문에 **동기화 비용**이 커집니다. 가능하면 **NOORDER** + **어플리케이션 레벨 정렬 키(시간/노드/seq)** 로 표현하세요.

**Q2. 선분이력 겹침을 트리거 없이 "순수 제약"으로 막을 수 있나요?**
A. Oracle은 **범위 배타 제약**이 없어 **직접은 불가**. 실전에서는 **행 잠금 + 검증 쿼리**(또는 머티리얼라이즈드 뷰 검사 + ON COMMIT) 조합을 씁니다.

**Q3. TIMESTAMP(초 단위) 이력에서 같은 초에 두 건이 들어오면?**
A. **마이크로초/나노초**까지 확장하거나, **(start_ts, surrogate_seq)** 복합키를 두고, **연속성 로직**이 같은 초에서도 정밀하게 동작하도록 설계하세요.

**Q4. "갭 없는 번호"를 대량으로 요구받습니다.**
A. **기술적·경제적 비용**을 명확히 제시하세요. 거의 항상 **시퀀스+갭 허용**이 합리적입니다. 정말 필요하면 **한정된 범위**(일자/점포별)로 나눠 병목을 줄이세요.

---

## 미니 실습 시나리오 요약

### 시퀀스 성능 차이 측정(개념)

```sql
-- A: NOORDER, CACHE 10000
-- B: ORDER,   CACHE 1000

-- 익명 블록으로 각각 1백만 NEXTVAL 호출 시간을 비교
DECLARE
  t NUMBER;
  v NUMBER;
BEGIN
  t := DBMS_UTILITY.get_time;
  FOR i IN 1..1000000 LOOP
    SELECT seq_order_id.NEXTVAL INTO v FROM dual;
  END LOOP;
  DBMS_OUTPUT.put_line('NOORDER elapsed (cs): '||(DBMS_UTILITY.get_time - t));

  t := DBMS_UTILITY.get_time;
  FOR i IN 1..1000000 LOOP
    SELECT seq_order_id_ordered.NEXTVAL INTO v FROM dual;
  END LOOP;
  DBMS_OUTPUT.put_line('ORDER elapsed (cs): '||(DBMS_UTILITY.get_time - t));
END;
/
```
- 보통 **NOORDER가 크게 빠름**(특히 RAC).

### 선분이력 동시 삽입 충돌(개념)

- **세션 A/B**가 같은 `person_id`에 다른 구간을 넣으면, **A가 잠근 동안 B는 대기** → 이후 **겹침검증 실패**시 B가 **롤백**.
- `SKIP LOCKED` 큐를 쓰면 B는 **다른 pid 작업**을 먼저 처리.

---

## 결론

오라클 환경에서 **일련번호 채번**과 **선분이력 관리**는 각각 고유한 동시성 문제를 안고 있습니다. 일련번호 채번에서는 **발급 속도와 확장성**을 최적화하는 것이 핵심인 반면, 선분이력 관리에서는 **데이터 정합성과 무결성**을 보장하는 것이 우선순위입니다.

일련번호 채번의 경우, 대량 트래픽 환경에서의 최적화는 `SEQUENCE` 객체의 `CACHE` 크기 증가, `NOORDER` 옵션 사용, 다중 시퀀스 스트라이핑, 그리고 애플리케이션 레벨의 Hi/Lo 알고리즘 적용을 통해 DB 경합을 최소화하고 확장성을 극대화할 수 있습니다. 반드시 필요한 경우가 아니라면 완전한 gap-less 보장보다는 성능과 확장성을 우선시하는 현실적인 접근이 바람직합니다.

선분이력 관리는 트리거나 제약만으로 해결하기 어려운 복잡한 무겹침(Non-overlap) 요구사항을 가지고 있습니다. 여기서는 **동일 엔터티에 대한 직렬화된 접근**을 보장하는 것이 핵심입니다. 최근 이력 행을 `FOR UPDATE`로 잠그는 방식과 함께, 겹침 여부를 검증하는 논리를 조합함으로써 데이터 레벨에서 강력한 정합성을 보장할 수 있습니다. 대량 동시 요청이 예상되는 경우 `SKIP LOCKED` 패턴을 활용한 큐잉 시스템을 도입하여 처리량을 선형적으로 확장할 수 있습니다.

두 영역 모두에서 공통적으로 중요한 점은 **비즈니스 요구사항의 명확한 정의**입니다. 진정한 gap-less가 필요한지, 완벽한 시간순 정렬이 필요한지, 선분의 연속성이 필수인지 선택적인지를 명확히 하고, 각 선택이 성능과 복잡성에 미치는 영향을 정량적으로 이해해야 합니다. 기술적 완벽함보다는 비즈니스에 실질적으로 필요한 수준의 정확성과 성능 요구사항을 충족시키는 실용적인 설계가 장기적인 시스템 안정성과 유지보수성을 보장합니다.

결국, 이러한 패턴과 기법들은 단순히 코드 스니펫이 아니라, 데이터 일관성, 시스템 성능, 그리고 비즈니스 요구사항 사이의 균형을 찾는 설계 철학의 구현체입니다. 각 시스템의 특성에 맞게 적절히 조합하고 적용할 때, 견고하면서도 확장 가능한 데이터 계층을 구축할 수 있습니다.