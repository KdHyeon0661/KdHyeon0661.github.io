---
layout: post
title: 형식언어와 오토마타 - Moore 기계
date: 2025-08-15 18:20:23 +0900
category: 형식언어와 오토마타
---
# Moore 기계(Finite-State **Moore** Machine)

**Moore 기계**는 각 **상태에 출력이 붙어 있는** 유한상태 장치다.
입력 기호를 읽어 **다음 상태로 이동**하고, **도착 상태의 출력**을 방출한다(초기 상태 출력 포함이 흔한 관례).
DFA가 “예/아니오”만 말한다면, Moore는 **입력 스트림 → 출력 스트림**(동기 변환)을 만든다는 점이 다르다.

---

## 0. 표기, 전제, 관례

결정적 Moore 기계
$$
M=(Q,\Sigma,\Gamma,\delta,\rho,q_0)
$$

- $$Q$$: 유한 상태 집합, $$q_0\in Q$$: 시작 상태
- $$\Sigma$$: 입력 알파벳, $$\Gamma$$: 출력 알파벳
- $$\delta:Q\times\Sigma\to Q$$: 다음 상태 함수
- $$\rho:Q\to \Gamma\ \text{ 또는 }\ \rho:Q\to \Gamma^\*$$: **상태 출력**(단일 기호가 표준, 문자열 확장도 가능)

문자열 확장(전통 1:1 출력 버전, **초기 출력 포함**):
입력 $$x=x_1x_2\cdots x_n$$ 에 대해
$$
q_0 \xrightarrow{x_1} q_1 \xrightarrow{x_2} q_2 \cdots \xrightarrow{x_n} q_n
$$
출력 스트림은
$$
\rho(q_0),\ \rho(q_1),\ \dots,\ \rho(q_n)\quad(\text{길이 }n+1).
$$

> **관례 주의**: 어떤 교재는 초기 출력을 생략해 길이를 $$n$$ 으로 둔다. **동치성 비교/최소화 문맥에서 무엇을 채택했는지** 명시하라.
> **지연**: Mealy는 “그 스텝 즉시” 출력, Moore는 “도착 상태” 출력이라 **1 스텝 지연**이 본질.

---

## 1. 실행 의미(Operational Semantics)

- 한 스텝: $$p \xrightarrow{a} q=\delta(p,a)$$ 이고 **\(\rho(q)\)** 를 출력.
- 출력은 **오직 상태**에만 의존 → 같은 상태로 도착하면 어떤 입력이었든 **같은 출력**.

---

## 2. 핵심 예제

### 2.1 패리티(짝수/홀수) 발생기

```text
Σ = Γ = {0,1}
상태/출력: qE(ρ=0), qO(ρ=1)         # 누적 XOR
전이:
qE --0--> qE
qE --1--> qO
qO --0--> qO
qO --1--> qE
# 출력: 시작시 ρ(qE)=0, 각 스텝 후 도착 상태의 ρ를 방출
```

### 2.2 '01' 패턴 검출(지연 체감 예)

```text
Σ = Γ = {0,1}
상태/출력: qS(0), q0(0), qH(1)
전이:
qS --0--> q0
qS --1--> qS
q0 --0--> q0
q0 --1--> qH      # '01'을 본 직후의 '다음 상태' qH에서 1 출력
qH --0--> q0
qH --1--> qS
# Mealy라면 둘째 글자(1)에서 바로 1을 내지만, Moore는 한 스텝 늦다.
```

### 2.3 간단 프로토콜 제어(글리치 억제 이점)

```text
상태/출력: IDLE(EN=0), ARM(EN=1), FIRE(EN=1)
입력: start, fire, stop
전이:
IDLE --start--> ARM
ARM  --fire --> FIRE
FIRE --stop --> IDLE
# 출력 EN은 상태 레벨에서 결정되어 클럭 경계에서만 변함 → 글리치 적음
```

---

## 3. Mealy ↔ Moore: 차이와 **상호 변환**

### 3.1 차이 요약

| 항목 | Mealy | Moore |
|---|---|---|
| 출력 의존 | (상태, **입력**) | (상태) |
| 반응 | **0-사이클 즉시** | **1-사이클 지연** |
| 글리치 | 상대적으로 큼 | **작음**(상태 레지스터 후단) |
| 상태 수 | 대개 적음 | **늘 수 있음**(전이 출력 다양성만큼 상태 분할) |

### 3.2 변환 공식

- **Moore → Mealy**: 각 전이 $$p\xrightarrow{a}q$$ 에 대해
  $$\lambda(p,a)=\rho(q),\quad \delta(p,a)=q$$
  상태 수 유지, **지연 제거**.

- **Mealy → Moore**: 전이별 출력 값을 상태에 흡수 →
  $$Q' \subseteq Q\times \Gamma\quad(\text{최대 }|Q|\cdot|\Sigma| \text{ 까지 증가})$$
  새 상태 $$(p,\gamma)$$ 의 출력은 $$\rho(p,\gamma)=\gamma$$.

> 변환 뒤 **동등성 검증 시 지연 정합**(초기 출력 포함 여부, 한 스텝 시프트)에 주의하라.

---

## 4. Moore **최소화**(Minimization)

### 4.1 상태 동치(State Equivalence)

상태 $$p,q\in Q$$ 가 동치(구별 불가)라 함은
$$
\boxed{\ \rho(p)=\rho(q)\ \land\ \forall a\in\Sigma:\ \delta(p,a)\sim \delta(q,a)\ }
$$
를 만족하는 가장 작은 동치관계 $$\sim$$ 에 속함을 뜻한다.

> DFA와 달리, **출력값**이 1차 분할 기준이다(수용/비수용 대신 상태 출력).

### 4.2 파티션 정제(Partition Refinement) — 기본형

1) **초기 분할**: 출력값이 같은 상태끼리 묶는다.
2) **정제(Refine)**: 분할 $$\Pi$$ 가 있을 때, 상태 $$q$$ 의 “서명”을
   $$\mathrm{Sig}_\Pi(q)= \big([\delta(q,a)]_\Pi\big)_{a\in\Sigma}$$
   (각 입력에 대한 **다음 상태의 블록 번호** 튜플)로 정의하고, **동일 서명끼리만 병합**.
3) 불변점 도달 시 종료 → 각 블록이 **최소 상태**.

- 복잡도(순진): 라운드당 $$O(|\Sigma||Q|)$$, 라운드 $$\le |Q|$$ → $$O(|\Sigma||Q|^2)$$.

### 4.3 Hopcroft 스타일 가속(작은쪽 퍼뜨리기)

DFA와 동일한 아이디어: 어떤 블록 $$B$$ 가 $$B_1\cup B_2$$ 로 갈라지면, **$$B$$ 로 들어오는 전이**를 가진 블록만 정제 후보로 삼고, **작은쪽**을 확산시켜 총 비용을 줄인다. Moore에서는 “서명”이 **다음 블록 튜플**이므로 구현만 다를 뿐 원리는 동일.
실무에서 $$O(|\Sigma|\cdot |Q|\log|Q|)$$ 근처까지 도달.

---

## 5. 단계별 최소화 **실습 예제**

다음 Moore 기계를 최소화하라.

```text
Σ = {0,1},  Γ = {0,1}
상태/출력:  A/0, B/0, E/0,   C/1, D/1, F/1      (시작 A)

전이:
A --0--> B    A --1--> C
B --0--> B    B --1--> D
C --0--> E    C --1--> C
D --0--> E    D --1--> C
E --0--> B    E --1--> D
F --0--> E    F --1--> C
```

**Step 1) 초기 분할(출력 기준)**
$$\Pi_0=\{\{A,B,E\},\{C,D,F\}\}$$

**Step 2) 정제(다음 블록 튜플 비교)**
두 블록 모두에서 모든 상태의 서명이 동일 → 추가 분할 없음.

따라서 **최소형은 2상태**:
$$[Z_0]=\{A,B,E\}(\rho=0),\ [Z_1]=\{C,D,F\}(\rho=1)$$
전이: $$Z_0\xrightarrow{0}Z_0,\ Z_0\xrightarrow{1}Z_1,\ Z_1\xrightarrow{0}Z_0,\ Z_1\xrightarrow{1}Z_1$$.

> 포인트: Moore는 **출력으로 먼저 나눈다** → 대규모 병합이 한 번에 이루어질 수 있다.
> 반대로 전이 패턴이 다르면 이후 라운드에서 세분화된다.

---

## 6. 동치성(Equivalence)과 포함성

### 6.1 동치성(초기 출력 정합 포함)

두 Moore 기계 $$M_1,M_2$$ 가 동치인지 확인하려면:

1) **초기 출력** 비교: $$\rho_1(q_{0,1})=\rho_2(q_{0,2})$$? 다르면 비동치.
2) 제품 기계를 따라, 같은 입력을 동시에 주며 **도달 상태 출력**이 **언제나** 같은지 확인.
3) 부분 기계라면 **정의역 차이**(한쪽만 전이가 존재하는 경로)도 반례.

### 6.2 포함성

일반 Moore는 “관계”가 아니라 **함수**이므로 포함 대신 **동치/차이 검출**이 실무 쟁점.
(일반화/비결정 확장 시 포함성은 어려워질 수 있으므로 가급적 **결정적/총기계** 유지 권장)

---

## 7. 합성(직렬/병렬)과 지연

- **직렬 합성**: $$M_1:\Sigma\!\to\!\Delta$$ 의 출력 스트림을 $$M_2:\Delta\!\to\!\Gamma$$ 의 입력으로.
  Moore→Moore 직렬은 **지연 1스텝**이 스테이지별 누적됨.
  지연을 줄이려면 **Mealy로 변환 후 합성·최소화**한 뒤 요구 지연에 맞추어 다시 Moore로 옮기는 전략이 흔하다.

- **병렬 합성**: 출력 벡터화(다중 제어선) 시, 상태를 **곱공간**으로 얹고 출력은 각 구성요소 출력의 결합.

---

## 8. 확장: 문자열 출력/꼬리 출력/가중

- **일반화 Moore**: $$\rho:Q\to\Gamma^\*$$ 로 상태가 **문자열**을 낼 수 있게(프리엠블/꼬리).
- **Subsequential Transducer(순차 변환기)**: Mealy에 **최종 출력** $$\tau:F\to\Gamma^\*$$ 를 더한 모델이 표준.
  Moore 스타일로도 가능하지만, 보통은 **Mealy+최종 출력** 정식이 더 간결하다.
- **가중(WFST)**: 상태/전이에 가중치(세미링) → 최단경로/N-best/합성으로 NLP·음성에서 광범위 사용.
  (표현력의 코어 한계는 **유한 상태**이므로 동일: 전역 복사/역순/균형 카운팅은 불가)

---

## 9. 하드웨어 관점(설계 포인트)

- **글리치 억제**: 상태 레지스터 후단의 조합 논리 없이도 **출력이 안정**.
- **지연-스루풋 트레이드오프**: 스테이지 쌓을수록 지연 증가 → 파이프라인 삽입/상태 통합으로 조율.
- **상태 인코딩**: 출력 비트가 상태에 종속 → 원핫/그레이/비트필드 등 시스템 제약에 맞춰 인코딩.
- **에러/예외**: 미정의 입력은 **Sink**(델타·출력 명확)로 흡수 → 디버깅/형식검증 용이.

---

## 10. 구현 레퍼런스(파이썬): Trim, 최소화, 동치성, Mealy↔Moore 변환

> 교육·검증용 간결 구현(성능/에러 체크 단순화). **초기 출력 포함 관례**를 따른다.

### 10.1 자료구조

```python
from collections import deque, defaultdict
from typing import Dict, Tuple, Set, Hashable, List

State = Hashable
Sym   = Hashable
Out   = Hashable

class DMoore:
    def __init__(self, Q:Set[State], Σ:Set[Sym], Γ:Set[Out],
                 δ:Dict[Tuple[State,Sym], State],
                 ρ:Dict[State, Out], q0:State):
        self.Q, self.Σ, self.Γ = set(Q), set(Σ), set(Γ)
        self.δ, self.ρ, self.q0 = dict(δ), dict(ρ), q0

    def reachable(self) -> Set[State]:
        seen, dq = set(), deque([self.q0])
        while dq:
            q = dq.popleft()
            if q in seen: continue
            seen.add(q)
            for a in self.Σ:
                nq = self.δ.get((q,a))
                if nq is not None:
                    dq.append(nq)
        return seen
```

### 10.2 총기계화(선택)

```python
    def totalize(self, sink:State="⟂", sink_out:Out=None):
        if sink_out is None:
            sink_out = ("<sink>",)
        if sink not in self.Q:
            self.Q.add(sink)
            self.ρ[sink] = sink_out
        for a in self.Σ:
            self.δ.setdefault((sink,a), sink)
        for q in list(self.Q):
            for a in self.Σ:
                self.δ.setdefault((q,a), sink)
```

### 10.3 Moore 최소화(파티션 정제 + Hopcroft풍 스케치)

```python
    def minimize(self):
        # 0) Trim
        R = self.reachable()
        Q = [q for q in self.Q if q in R]
        Σ = list(self.Σ)

        # 1) 초기 분할: 출력값으로
        groups = defaultdict(list)
        for q in Q:
            groups[self.ρ[q]].append(q)
        blocks: List[List[State]] = list(groups.values())

        # 2) 반복 정제 (순진 구현; Hopcroft는 역전이 캐시로 가속)
        changed = True
        while changed:
            changed = False
            new_blocks = []
            # 상태->현재 블록 인덱스
            where = {}
            for i,Blk in enumerate(blocks):
                for s in Blk: where[s] = i
            for B in blocks:
                sub = defaultdict(list)
                for q in B:
                    sig = tuple(where[self.δ[(q,a)]] for a in Σ)
                    sub[sig].append(q)
                if len(sub) == 1:
                    new_blocks.append(B)
                else:
                    changed = True
                    new_blocks.extend(sub.values())
            blocks = new_blocks

        # 3) 몫 기계 구성
        rep_id = { s:i for i,Blk in enumerate(blocks) for s in Blk }
        Qmin = set(rep_id.values())
        q0m  = rep_id[self.q0]
        δm, ρm = {}, {}
        for i,Blk in enumerate(blocks):
            qrep = Blk[0]
            ρm[i] = self.ρ[qrep]
            for a in Σ:
                δm[(i,a)] = rep_id[self.δ[(qrep,a)]]
        Γ = set(ρm.values())
        return DMoore(Qmin, set(Σ), Γ, δm, ρm, q0m), blocks
```

### 10.4 동치성(초기 출력 포함), 반례 입력 생성

```python
def equal_moore(M1:DMoore, M2:DMoore):
    # 가정: 동일 Σ, 총기계 혹은 동일 정의역
    if M1.ρ[M1.q0] != M2.ρ[M2.q0]:
        return False, []  # 초기 출력 불일치
    from collections import deque
    dq, seen = deque(), set()
    dq.append((M1.q0, M2.q0, []))
    Σ = list(M1.Σ)
    while dq:
        p,q,w = dq.popleft()
        if (p,q) in seen: continue
        seen.add((p,q))
        for a in Σ:
            p2, q2 = M1.δ[(p,a)], M2.δ[(q,a)]
            # 도착 상태 출력 비교
            if M1.ρ[p2] != M2.ρ[q2]:
                return False, w+[a]  # 반례 입력(최단)
            dq.append((p2,q2,w+[a]))
    return True, None
```

### 10.5 Mealy ↔ Moore 변환 유틸

```python
class DMealy:
    def __init__(self, Q:Set[State], Σ:Set[Sym], Γ:Set[Out],
                 δ:Dict[Tuple[State,Sym], State],
                 λ:Dict[Tuple[State,Sym], Out],
                 q0:State):
        self.Q, self.Σ, self.Γ = set(Q), set(Σ), set(Γ)
        self.δ, self.λ, self.q0 = dict(δ), dict(λ), q0

def moore_to_mealy(M:DMoore) -> DMealy:
    δ, λ = {}, {}
    for (q,a), nq in M.δ.items():
        δ[(q,a)] = nq
        λ[(q,a)] = M.ρ[nq]  # 도착 상태 출력
    Γ = set(M.ρ.values())
    return DMealy(M.Q, M.Σ, Γ, δ, λ, M.q0)

def mealy_to_moore(N:DMealy) -> DMoore:
    # (상태, '해당 전이 출력')로 세분화: 간단 구현(상태 폭증 가능)
    # 보다 타이트한 구성은 전이-출력별로 상태 분리 후 ε-병합 최적화가 필요
    Σ = list(N.Σ)
    Qp, ρp, δp = set(), {}, {}
    name = {}
    def get(p,a):
        γ = N.λ[(p,a)]
        key = (N.δ[(p,a)], γ)
        if key not in name:
            name[key] = key  # 상태 이름 튜플
        return name[key]

    # q0의 초기 출력 정의: Mealy→Moore 변환 시 '초기 출력' 관례 결정 필요
    # 여기서는 '초기 출력'을 별도 상수 γ0로 둔다(필요 시 비교 시 1-스텝 정합해줄 것)
    γ0 = ("<init>",)
    for p in N.Q:
        for a in Σ:
            nq, γ = N.δ[(p,a)], N.λ[(p,a)]
            sp = (nq, γ)
            Qp.add(sp); ρp[sp] = γ

    # 전이: (p,a)에서 도착할 (nq,λ(nq,·)) 형태가 아니라 간단화를 위해
    # '현재 상태 p'의 각 입력 a에 대해 '다음 상태 nq'와 그 상태의 출력 γ를 묶은 상태로 이동
    for p in N.Q:
        for a in Σ:
            sp = (N.δ[(p,a)], N.λ[(p,a)])
            for b in Σ:
                sp2 = (N.δ[(sp[0],b)], N.λ[(sp[0],b)])
                δp[(sp,b)] = sp2

    # 시작 상태: q0의 임의 입력에 상관없는 '초기 출력' 정의가 없으므로 보통 γ0를 사용
    # 실제 동치성 비교 때는 1-스텝 시프트로 정합한다.
    q0p = (N.q0, γ0)
    Qp.add(q0p); ρp[q0p] = γ0
    return DMoore(Qp, set(Σ), set(ρp.values()), δp, ρp, q0p)
```

> **비고**: `mealy_to_moore`는 교육용 단순화다. 산업/이론적으로는 **(전이, 출력) 묶음**을 정규화하고, 불필요 상태 제거·최소화까지 한 번에 수행한다(상태 폭증 억제).

---

## 11. 테스트/검증 시나리오(코드 사용 예)

- 주어진 Moore를 최소화 → 원본과 동치성 검사(반례 입력 없음을 확인).
- Moore→Mealy→Moore 왕복 후, **지연 정합**을 맞춘 동치성 검사.

```python
# Moore 예제(§5) 구성
Σ = {"0","1"}; Γ = {"0","1"}
Q = {"A","B","C","D","E","F"}
δ = {("A","0"):"B",("A","1"):"C",
     ("B","0"):"B",("B","1"):"D",
     ("C","0"):"E",("C","1"):"C",
     ("D","0"):"E",("D","1"):"C",
     ("E","0"):"B",("E","1"):"D",
     ("F","0"):"E",("F","1"):"C"}
ρ = {"A":"0","B":"0","E":"0","C":"1","D":"1","F":"1"}
M = DMoore(Q, Σ, Γ, δ, ρ, "A").totalize() or None  # 필요 시 총기계화

# 최소화
Mmin, blocks = DMoore(Q, Σ, Γ, δ, ρ, "A").minimize()

# 동치성 검사
ok, cex = equal_moore(Mmin, DMoore(Q, Σ, Γ, δ, ρ, "A"))
assert ok and cex is None
```

---

## 12. 엣지 케이스와 자주 하는 실수

1) **초기 출력 관례 미정**: 한쪽은 포함, 한쪽은 생략 → “동치 아님”으로 오판. **정합 규칙**을 고정하라.
2) **부분 기계**: 미정의 전이로 정제/동치 검사 중 예외 → 먼저 **총기계화**하라(덫 상태 + 명시 출력).
3) **대알파벳(유니코드 등)**: $$|\Sigma|$$ 가 크면 서명 튜플이 거대 → **클래스 묶음**(예: `\w`, `\s`)으로 전처리.
4) **문자열 출력 Moore**: 그냥 병합하면 **접두/접미 중복**이 생길 수 있음 → **Output Pushing**(정규형) 후 최소화.
5) **Mealy↔Moore 동치 검증**: Moore의 1-스텝 지연 때문에 **시프트 정합**이 필요(제품 기계에서 초기 출력 비교/버퍼 한 칸).

---

## 13. 이론 스냅샷(정당성의 골자)

- **우측-불변 합동(right-invariant congruence)**:
  $$p\sim q\ \Rightarrow\ \forall a\in\Sigma:\ \delta(p,a)\sim \delta(q,a)$$
  및 $$\rho(p)=\rho(q)$$ 를 동시에 만족하는 가장 거친(=블록 수 최소) 합동을 찾는 것이 최소화.
- **유일성**: Trim(도달 상태만) 가정하에 Moore 최소형은 **동형(isomorphic)까지 유일**.
- **복잡도**: Hopcroft 가속으로 $$\tilde O(|\Sigma||Q|)$$ 수준(상수는 구현 의존).

---

## 14. 실무 체크리스트

```text
[모델/관례]
- 초기 출력 포함/생략? 지연 정합 규칙 명시
- 총기계화 여부(Sink, 명시 출력)

[최소화]
- 초기 분할=출력값
- (다음 블록 튜플) 서명 정제
- 작은쪽 퍼뜨리기(역전이 캐시)로 가속

[검증]
- 제품 기계로 동치성(+ 초기 출력 검사)
- 반례 입력 자동 산출(최단)
- 상태-구분 입력(W-Method/HSI)로 회귀 테스트

[성능/규모]
- 정수 인덱싱, 희소 전이
- 대알파벳은 클래스화하여 서명 축소
- 문자열 출력이면 Output Pushing 후 최소화

[하드웨어]
- Moore 우선(출력 안정) vs Mealy 우선(지연 최소) 기준 결정
- 파이프라인 지연/스루풋 트레이드오프 문서화
```

---

## 15. 한 페이지 요약

- **정의**: $$M=(Q,\Sigma,\Gamma,\delta,\rho,q_0)$$, 출력은 **상태**에 의존 → **1 스텝 지연**.
- **최소화**: “출력으로 초기 분할 → (다음 블록 튜플) 서명 정제”로 고정점.
- **동치성**: 초기 출력 비교 후 제품 기계로 모든 스텝의 **도착 상태 출력** 비교.
- **Mealy↔Moore**: Moore→Mealy는 지연 제거(상태 보존), Mealy→Moore는 상태 증가 가능.
- **확장**: 문자열 출력/최종 출력/가중까지 가능하나, **유한 상태의 한계**는 그대로.
- **실무**: 총기계화·출력 정합·Hopcroft 가속·테스트 자동화가 품질/성능을 좌우한다.
