---
layout: post
title: 형식언어와 오토마타 - Moore 기계
date: 2025-08-15 18:20:23 +0900
category: 형식언어와 오토마타
---
# Moore 기계(Finite-State **Moore** Machine) 완전 가이드  
정의 · 실행 의미 · 예제 · Mealy↔Moore 변환 · 최소화/동치성 · 합성/확장 · 하드웨어 포인트

**Moore 기계**는 각 **상태에 출력이 붙어 있는** 유한상태 장치입니다.  
입력 기호를 읽어 **다음 상태로 이동**하고, **도착 상태의 출력**을 방출합니다(초기 상태 출력 포함).  
정규언어 인식용 DFA가 “예/아니오”만 말한다면, Moore는 **입력 스트림 → 출력 스트림**(동기 변환)을 만든다는 점이 다릅니다.

---

## 1) 형식적 정의(결정적 Moore)

\[
M=(Q,\Sigma,\Gamma,\delta,\rho,q_0)
\]
- \(Q\): 유한한 상태 집합, \(q_0\in Q\): 시작 상태  
- \(\Sigma\): 입력 알파벳, \(\Gamma\): 출력 알파벳  
- \(\delta:Q\times \Sigma\to Q\): 전이(다음 상태) 함수  
- \(\rho:Q\to \Gamma\) (혹은 \(\Gamma^\*\)): **상태 출력** 함수

### 문자열로의 확장(표준 1:1 출력 버전)
입력 \(x=x_1x_2\cdots x_n\) 에 대해
\[
q_0\ \xrightarrow{x_1}\ q_1\ \xrightarrow{x_2}\ q_2\ \cdots\ \xrightarrow{x_n}\ q_n
\]
출력 스트림은 통상
\[
\underbrace{\rho(q_0)}_{\text{초기 출력}},\ \rho(q_1),\ \rho(q_2),\ \dots,\ \rho(q_n)
\]
입니다. 즉 **출력 길이 = 입력 길이 + 1**(초기 출력 포함).  
(일부 교과서는 초기 출력을 생략해 길이를 같게 정의하기도 합니다. 무엇을 택했는지 명시만 하면 됩니다.)

> **즉시성/지연**: Mealy는 입력을 읽는 **그 스텝**에 출력하지만, Moore는 **다음 상태**의 출력이므로 **1스텝 지연**이 존재합니다.

---

## 2) 실행 의미와 직관

- 한 스텝: 현재 상태 \(p\)에서 입력 \(a\)를 읽으면 \(q=\delta(p,a)\)로 이동하고 **\(\rho(q)\)** 를 출력.  
- 출력은 **오직 상태**에만 의존하므로, **같은 상태**로 들어오면 **항상 같은 출력**이 납니다(입력에 직접 의존 X).

---

## 3) 핵심 예제

### 3.1 접두 **짝수/홀수 패리티** 발생기
입력 비트의 누적 XOR(패리티)을 출력(초기엔 짝수=0).

```text
Σ = Γ = {0,1}
상태/출력: qE(짝수, ρ=0), qO(홀수, ρ=1)   # 상태 자체가 출력값을 내포
전이:
qE --0--> qE
qE --1--> qO
qO --0--> qO
qO --1--> qE
# 출력: 시작 시 0(ρ(qE)), 각 입력 후 도착 상태의 ρ를 방출
```

### 3.2 “01” 패턴 검출(지연이 드러나는 예)
직전 기호가 0인지 기억하여, **그 다음 스텝에** 1을 내보냄.

```text
Σ = Γ = {0,1}
상태/출력: qS(0), q0(0), qHit(1)     # qHit에 있을 때만 1 출력
전이:
qS --0--> q0
qS --1--> qS
q0 --0--> q0
q0 --1--> qHit    # '01' 관측 후 다음 스텝의 출력이 1
qHit --0--> q0
qHit --1--> qS
```
Mealy라면 `01`의 **둘째 1을 읽는 스텝에서** 1을 바로 내보내지만, Moore는 **한 스텝 늦게** 나타납니다.

### 3.3 간단 **프로토콜 상태기계**(하이/로우 제어)
상태의 출력이 제어선(예: `ENABLE`)을 구동하므로 **글리치에 강함**.

```text
상태/출력: IDLE(EN=0), ARM(EN=1), FIRE(EN=1)
입력: start, fire, stop
전이:
IDLE --start--> ARM
ARM  --fire --> FIRE
FIRE --stop --> IDLE
```

---

## 4) Mealy ↔ Moore: 차이와 **상호 변환**

### 차이 요약

| 항목 | Mealy | Moore |
|---|---|---|
| 출력 의존 | (상태, **입력**) | (상태) |
| 반응 | **즉시**(0-사이클) | **1-사이클 지연** |
| 글리치 | 상대적으로 큼 | **작음**(클럭 경계에서만 변함) |
| 상태 수 | 대개 적음 | **늘 수 있음**(출력 다양성만큼 분할) |

### 변환 공식
- **Moore → Mealy**: 각 전이 \(p\xrightarrow{a}q\)에 대해  
  \[
  \lambda(p,a)=\rho(q),\quad \delta(p,a)=q
  \]
  (상태 수 유지, 지연 제거)
- **Mealy → Moore**: 전이별 출력이 다르면 상태를 세분화해야 해서  
  \[
  Q' \subseteq Q\times \Gamma
  \]
  꼴로 **최대 \(|Q|\cdot|\Sigma|\)** 까지 상태가 증가할 수 있음. \(\rho(p',)=\) 그 상태에 대응한 출력.

---

## 5) 최소화(결정적 Moore)

두 상태 \(p,q\)가 **동치**이려면  
1) **출력 동일**: \(\rho(p)=\rho(q)\),  
2) 모든 \(a\in \Sigma\)에 대해 \(\delta(p,a)\)와 \(\delta(q,a)\)가 **동치**여야 합니다.

### 파티션 정제 절차(개략)
1) 초기 분할: **출력값**이 같은 상태끼리 묶음(출력 다른 상태는 즉시 분리).  
2) 전이 목적지의 분할이 다르면 분할을 더 쪼갬.  
3) 안정화될 때까지 반복 → 각 블록이 **최소 상태**가 됨.

- 복잡도: Hopcroft류로 \(O(|\Sigma|\cdot |Q|\log|Q|)\) 근처.

---

## 6) 동치성/포함성 테스트

- **동치성**: 제품 기계에서 아무 입력을 주어도 **도달 상태 두 개의 \(\rho\)** 가 항상 같은지 검사(초기 출력도 비교).  
- **부분 Moore**(일부 입력 미정의)라면, **정의역** 차이도 함께 체크(한쪽만 정의된 경로가 있으면 비동치).

---

## 7) 합성(직렬 연결)과 폐포

Moore \(M_1:\Sigma\to\Delta\), \(M_2:\Delta\to\Gamma\) 를 **동기 클럭**으로 직렬 연결하면  
입력 \(\Sigma\)→중간 \(\Delta\)→출력 \(\Gamma\) 스트림이 나옵니다.  
- 실무에선 흔히 **Mealy(또는 순차 변환기)** 로 바꿔 합성·최소화한 뒤 Moore로 다시 옮깁니다.  
- Moore도 정규(합성/직렬/병렬/피드백) 구조에서 잘 동작하지만, **지연 1스텝**이 늘어난다는 점을 감안해 설계합니다.

---

## 8) 확장: 문자열 출력/가중/언어공학

- **일반화 Moore 변환기**: \(\rho:Q\to \Gamma^\*\) 로 상태가 **문자열**을 내도록 허용(프리엠블/꼬리 가능).  
  또는 “최종 출력” \(\tau:F\to\Gamma^\*\) 를 더한 **순차 변환기**(subsequential transducer)로 확장하면  
  텍스트 정규화/형태소 분석 같은 **실무 스트리밍 변환**을 깔끔히 모델링할 수 있습니다.
- **가중 Moore/WFST**: 상태/전이에 가중치를 두고 세미링 \((\oplus,\otimes)\) 위에서 경로 스코어를 계산(음성·NLP).

---

## 9) 설계 패턴과 팁

1) **출력 안정성**이 중요하면 Moore를 우선 고려(하드웨어 글리치 억제).  
2) **지연 허용도**를 먼저 정하라: 1사이클 지연이 문제면 Mealy → 파이프라인/레지스터 삽입으로 보정.  
3) **상태 의미를 출력과 결합**: “상태 = 출력값 + 문맥”으로 잡으면 설계·검증이 단순해진다.  
4) **에러 흡수**: 정의되지 않은 입력은 **덫 상태**(출력 명확)로 모아 디버깅을 쉽게.  
5) **테스트**: W-Method/HSI 등 **입력 구분 시퀀스**로 상태 동치성을 실험적으로 확인.

---

## 10) 간단 예제: 대문자화(공백 뒤 첫 글자만 대문자)

```text
Σ = Γ = {a..z, A..Z, ' '}
상태/출력: S0(ε), SCap(ε)   # 출력은 상태 도착 시 한 글자 배출(여기선 1:1 가정)
전이:
S0   --' '--> SCap
S0   --x-->   S0     ; 출력: x (이미 단어 중)
SCap --' '--> SCap
SCap --a..z--> S0    ; 출력: 대문자(x→X)
SCap --A..Z--> S0    ; 출력: 그대로(A)
```
- 출력이 상태에만 달려 있으므로, 실제 구현에선 전이 표 옆에 **“도착 상태의 출력 로직”** 을 배치합니다.

---

## 11) 하드웨어 관점 정리

- **타이밍**: Moore는 출력이 레지스터에 매달려 있어 **클럭 가장자리에만** 변함 → 메타안정성/글리치에 유리.  
- **리소스**: 같은 기능을 Mealy보다 **상태 수가 늘 수** 있음(전이별 출력 다양성을 상태로 흡수해야 해서).  
- **파이프라이닝**: 여러 Moore 스테이지를 직렬로 쌓으면 **지연이 누적**되므로, 요구 지연과 스루풋을 함께 조율.

---

## 12) 한 페이지 요약

- Moore: \((Q,\Sigma,\Gamma,\delta,\rho,q_0)\), **상태 출력** 모델.  
- **출력은 상태에만 의존**, **1사이클 지연**이 본질. Mealy보다 글리치에 강하지만 상태가 늘 수 있음.  
- **최소화**는 “출력 먼저 분할 → 전이 목적지 분할 정제”로 수행. 동치성은 제품기계로 검사.  
- 필요에 따라 **문자열 출력/최종 출력/가중**까지 확장 가능(순차 변환기·WFST).
