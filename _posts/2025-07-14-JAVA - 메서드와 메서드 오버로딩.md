---
layout: post
title: Java - 메서드와 메서드 오버로딩
date: 2025-07-14 20:20:23 +0900
category: Java
---
# Java 메서드(Method)와 메서드 오버로딩

## 1. 메서드란 무엇인가

### 1.1 선언 구조
```java
[접근제어자] [기타 한정자] 반환타입 메서드이름(매개변수목록) [throws 예외목록] {
    // 본문
    return 값; // 반환타입이 void가 아니면 필수
}
```

### 1.2 예시(기본)
```java
public int add(int a, int b) {
    return a + b;
}
```

---

## 2. 구성 요소와 한정자(modifiers)

| 요소 | 설명 | 예시 |
|---|---|---|
| 접근제어자 | `public`, `protected`, (package-private), `private` | `public void f(){}` |
| 반환타입 | `void` 또는 타입(원시/참조) | `String greet(...)` |
| 이름 | 식별자(소문자 시작 관례, 동사형 권장) | `computeTotal` |
| 매개변수 | `타입 이름` 쌍의 ,-리스트 | `(int n, String s)` |
| 예외 | 체크 예외 명시 | `throws IOException` |
| 기타 한정자 | `static`, `final`, `abstract`, `synchronized`, `native`, `strictfp` | `static int of(...)` |

> **서명(signature)** = **메서드 이름 + 매개변수 타입 목록**.
> 반환타입/예외/제네릭 매개변수/매개변수 이름은 **서명에 포함되지 않음**(오버로딩 판단에 영향 없음).

---

## 3. 메서드 호출과 바인딩

### 3.1 인스턴스 vs `static`
```java
public class Calculator {
    public int square(int x) {   // 인스턴스 메서드
        return x * x;
    }
    public static int doubleIt(int x) { // 정적 메서드
        return x * 2;
    }
}

Calculator c = new Calculator();
System.out.println(c.square(5));            // 인스턴스
System.out.println(Calculator.doubleIt(5)); // 정적
```

### 3.2 `this`/`super` 사용
```java
class Base {
    int v = 1;
    int val() { return v; }
}
class Derived extends Base {
    int v = 2;
    int val() { return v + super.val(); } // 2 + 1
}
```

### 3.3 전달 방식: **항상 pass-by-value**
- 원시형: 값 복사.
- 참조형: **참조의 값(주소) 자체를 복사**.
  객체 필드 변경은 호출자에 **영향 O**, 매개변수에 **새 참조를 대입**하는 것은 **영향 X**.

```java
class Box { int n; }
static void mutate(Box b) { b.n = 10; }   // 필드 변경 → 호출자에 반영
static void reassign(Box b) { b = new Box(); b.n = 20; } // 새 참조 대입 → 호출자 반영 X
```

---

## 4. 반환과 `void`

```java
public String greet(String name) { return "Hello, " + name; }
public void printHello() { System.out.println("Hello!"); } // 반환값 없음
```

- 여러 값을 반환해야 하면 **레코드(record)**, 도메인 클래스, `Optional<T>`(존재성), `Pair`/`Map.Entry` 등 사용.

---

## 5. 매개변수: 기본/가변/배열/불변성

### 5.1 기본 매개변수
```java
int multiply(int a, int b) { return a * b; }
```

### 5.2 가변인자(varargs)
```java
int sum(int... xs) { int s=0; for (int x: xs) s+=x; return s; }
sum(1); sum(1,2,3); sum(new int[]{4,5});
```
- 내부적으로 **배열 생성** → 빈번 호출/핫패스에서는 오버헤드 고려.

### 5.3 방어적 복사(배열/가변 자료)
```java
class Safe {
    private final int[] data;
    Safe(int[] src) { this.data = java.util.Arrays.copyOf(src, src.length); }
    public int[] data() { return java.util.Arrays.copyOf(data, data.length); }
}
```

---

## 6. 예외와 시그니처

```java
public void load(Path p) throws IOException {
    // 파일 작업
}
```
- **체크 예외**는 선언/처리 필요.
- 예외 목록은 오버로딩 판정에 **영향 없음**.
- 오버라이딩 시 체크 예외는 **좁혀야** 함(동일/하위 타입).

---

## 7. `static` vs 인스턴스 메서드

| 구분 | 특징 | 예 |
|---|---|---|
| `static` | 클래스 소속, 상태 없이 동작(함수형), **오버라이드 불가(숨김만 가능)** | `Math.max`, 팩토리 `of(...)` |
| 인스턴스 | 객체 상태 사용, 다형성(오버라이딩) | `list.size()` |

설계 팁: **상태 없는 유틸/팩토리**는 `static`, **객체 행위**는 인스턴스.

---

## 8. 메서드 오버로딩(Method Overloading)

> **같은 이름**으로 **서로 다른 매개변수 시그니처**를 가진 메서드를 여러 개 정의.

### 8.1 기본 규칙
- **반환타입만 다르면 불가**(컴파일 오류).
- 매개변수 **개수/타입/순서**가 달라야 함.
- 오버로딩 **선택은 컴파일 타임**에 결정(정적 바인딩).

```java
class Printer {
    void print()                    { System.out.println("출력 없음"); }
    void print(String s)            { System.out.println("출력: " + s); }
    void print(String s, int count) { for (int i=0;i<count;i++) System.out.println(s); }
}
```

### 8.2 숫자 계열 오버로딩과 **선택 우선순위**
오버로딩 해석 시 **한쪽으로만 변환되는** 최적 후보를 고릅니다(가장 구체적).

> **우선순위(높음 → 낮음)**
> **정수/실수의 확대 변환(widening)** 〉 **오토박싱/언박싱** 〉 **가변인자(varargs)**

```java
class Pick {
    void f(long x)     { System.out.println("long"); }
    void f(Long x)     { System.out.println("Long"); }
    void f(int... xs)  { System.out.println("varargs"); }
    public static void main(String[] args) {
        Pick p = new Pick();
        p.f(1);        // int → long (확대) → "long"
        // p.f(null);  // 모호(Reference 다수 후보: Long vs int...) → 컴파일 오류
    }
}
```

### 8.3 박싱 vs 확대의 경쟁
```java
class C {
    void g(long x) {}       // 확대
    void g(Integer x) {}    // 박싱
    void g(int... xs) {}    // varargs
    void h(double x) {}
    void h(Float x) {}

    void demo() {
        g(10);  // long이 선택(확대가 박싱보다 우선)
        h(3.14f); // float → double(확대) vs Float(박싱): double 선택
    }
}
```

### 8.4 `null` 인수와 모호성
```java
void m(String s) {}
void m(Object o) {}
// m(null);  // String이 더 구체적이므로 m(String) 선택

void n(Integer i) {}
void n(String s) {}
// n(null);  // 모호(둘 다 참조형, 공통 하위 없음) → 컴파일 오류
```
> 해결: **캐스트**로 의도 명시 `n((Integer) null);`

### 8.5 오버로딩과 제네릭·타입 소거
- 제네릭은 **타입 소거**로 바이트코드 서명이 같아질 수 있습니다.

```java
// 잘못된 예(서명 충돌):
// int size(List<String> x) { ... }
// int size(List<Integer> x) { ... } // 소거 후 둘 다 size(List)
```

- 제네릭 + 오버로딩은 **경계 타입**을 달리하거나 **이름을 다르게** 해 모호성을 피하세요.

### 8.6 오버로딩과 메서드 참조/람다
```java
class U {
    static void log(String s) {}
    static void log(Object o) {}
    // System.out::println 같은 참조는 대상 타입에 따라 바인딩 → 모호하면 캐스트 필요
    java.util.function.Consumer<String> c = U::log; // log(String)으로 결정
}
```

---

## 9. 오버로드 해석을 눈으로 확인하기(실행 예제)

```java
public class OverloadPlay {
    static void pick(int x)      { System.out.println("int"); }
    static void pick(long x)     { System.out.println("long"); }
    static void pick(Integer x)  { System.out.println("Integer"); }
    static void pick(int... xs)  { System.out.println("varargs"); }

    public static void main(String[] args) {
        pick(1);        // int
        pick(1L);       // long
        pick(new Integer(1)); // Integer
        pick();         // varargs
        pick(1,2,3);    // varargs

        // 우선순위: 확대 > 박싱 > varargs
        // pick(null);  // 모호(참조 후보 Integer vs int...) → 주석 처리
        pick((Integer) null); // Integer
    }
}
```

---

## 10. 오버로딩(정적) vs 오버라이딩(동적) 비교

| 구분 | Overloading | Overriding |
|---|---|---|
| 시점 | **컴파일 타임** 결정 | **런타임** 동적 디스패치 |
| 기준 | 메서드 **서명**(이름+매개변수) | **동일 서명**, 하위 클래스에서 재정의 |
| 반환타입 | 판단에 **영향 X** | **공변 반환(covariant)** 허용 |
| 예외 | 판단에 X | 체크 예외는 **좁히기만 가능** |
| `static` | 해당 없음 | **숨김(hiding)**: 오버라이딩 아님 |

```java
class P { void f(Number n){ System.out.println("P"); } }
class Q extends P { void f(Integer n){ System.out.println("Q-int"); } }

P x = new Q();
x.f(10);  // 정적 해석: 참조 타입 P 기준으로 f(Number) 선택 → 런타임 호출 결과 "P"
```
> **핵심**: 오버로딩은 **참조 변수의 컴파일타임 타입**으로 결정, 오버라이딩은 **실제 객체 타입**으로 호출.

---

## 11. 실전 사례로 배우는 오버로딩 설계

### 11.1 포맷팅 로거(API 사용자 친화)
```java
class Logger {
    void log(String msg) { System.out.println(msg); }
    void log(String fmt, Object... args) {
        System.out.println(String.format(fmt, args));
    }
    // 성능 민감 경로: StringBuilder 버전
    void log(StringBuilder sb) { System.out.println(sb.toString()); }
}
```

### 11.2 파서 오버로드(입력원 다양화)
```java
class Parser {
    Data parse(String json) { /* ... */ return new Data(); }
    Data parse(java.io.Reader r) { /* ... */ return new Data(); }
    Data parse(java.nio.file.Path p) throws java.io.IOException {
        try (var r = java.nio.file.Files.newBufferedReader(p)) {
            return parse(r);
        }
    }
}
```

### 11.3 팩토리 오버로드(타입·정밀도 선택)
```java
record Point(double x, double y) {
    static Point of(int x, int y)       { return new Point(x, y); }
    static Point of(double x, double y) { return new Point(x, y); }
}
```

---

## 12. 재귀 호출과 수학적 정의

예: 팩토리얼
$$
n! =
\begin{cases}
1, & n=0 \\\\
n \cdot (n-1)!, & n>0
\end{cases}
$$

```java
static long fact(int n) {
    if (n < 0) throw new IllegalArgumentException();
    if (n == 0) return 1L;
    return n * fact(n - 1);
}
```
- **꼬리 재귀 최적화는 Java에서 보장되지 않음** → 큰 `n`은 반복문/메모이제이션 고려.

---

## 13. 빌더·Optional·계약(Contract)과 문서화

- **불변/순수 함수** 지향: 사이드 이펙트 최소화.
- **사전조건/사후조건**: `Objects.requireNonNull`, `assert` 활용.
- **Optional**: “없음” 표현에 `Optional<T>` 반환 고려(매개변수에는 권장 X).
- **Javadoc**로 계약 명세:
  ```java
  /**
   * @param s null 불가
   * @return 트리밍된 문자열
   * @throws IllegalArgumentException s가 빈 문자열이면
   */
  public static String norm(String s) { ... }
  ```

---

## 14. 성능 관점(간략)

- **JIT 인라이닝**: 짧고 자주 호출되는 메서드는 자동 인라인될 수 있음.
- **오토박싱·varargs**: 힙 할당 유발 가능 → 핫패스에서 회피.
- **예외**는 정상 제어 흐름에 쓰지 말 것(비용 큼).

---

## 15. 종합 예제

### 15.1 계산기 + 오버로딩 결정 관찰
```java
public class OverloadLab {
    static Number add(int a, int b) { System.out.println("int+int"); return a + b; }
    static Number add(long a, long b) { System.out.println("long+long"); return a + b; }
    static Number add(Integer a, Integer b) { System.out.println("Integer+Integer"); return a + b; }
    static Number add(double... xs) { System.out.println("varargs double"); double s=0; for(double x:xs)s+=x; return s; }

    public static void main(String[] args) {
        System.out.println(add(1,2));            // int+int
        System.out.println(add(1L,2L));          // long+long
        System.out.println(add(Integer.valueOf(1), Integer.valueOf(2))); // Integer+Integer
        System.out.println(add(1.0,2.0,3.0));    // varargs double

        // 우선순위 확인: 1은 int
        System.out.println(add(1, 2L)); // long+long (int→long 확대)
    }
}
```

### 15.2 null 모호성 해소
```java
class NullPick {
    void show(String s)  { System.out.println("String"); }
    void show(Object o)  { System.out.println("Object"); }
    void show(Integer i) { System.out.println("Integer"); }

    void demo() {
        show((String) null);   // String
        show((Object) null);   // Object
        // show(null);        // 모호(여러 참조 후보) → 캐스트로 의도 명시
    }
}
```

### 15.3 제네릭 + 타당한 오버로드
```java
class Util {
    static <T> int count(java.util.Collection<T> c) { return c.size(); }
    static int count(int[] a) { return a.length; } // 서로 다른 서명(소거 충돌 없음)
}
```

---

## 16. 체크리스트

- [ ] **서명**은 “이름+매개변수 타입”. **반환타입**만 달라서는 오버로딩 불가.
- [ ] **오버로드 선택 우선순위**: **확대** ＞ **박싱** ＞ **가변인자**.
- [ ] `null` 인수는 **모호성** 유발 → **캐스트**로 의도 명시.
- [ ] **제네릭 소거**로 서명 충돌 가능 → 서로 다른 실질 서명 보장.
- [ ] **pass-by-value**: 참조 재대입은 호출자에 영향 없음, **객체 내부 변경**은 영향 O.
- [ ] 성능 민감 경로에서 **박싱/varargs 할당**을 경계.
- [ ] `static`은 **오버라이드 불가**(숨김). 다형성은 **인스턴스** 메서드에서.
- [ ] API는 **명확한 이름/불변 데이터/방어적 복사/Optional 반환**으로 안전하게.

---

## 17. 요약 표

| 주제 | 핵심 요점 |
|---|---|
| 선언/호출 | 이름·매개변수·반환·예외. 인스턴스 vs `static` |
| 전달 방식 | **항상 값에 의한 전달**(참조도 값으로 복사) |
| 예외 | 체크 예외는 선언/처리, 오버라이딩 시 좁히기 |
| 오버로딩 | **컴파일 타임** 해석, 반환타입 불개입 |
| 선택 규칙 | **확대 > 박싱 > varargs**, 가장 구체적 후보 |
| 모호성 | `null`/제네릭/동일 소거에 주의, 캐스트/이름 분리 |
| 설계 | 의미 있는 이름, 불변성, 방어적 복사, Optional, Javadoc |

---

## 18. 한 줄 결론
> 메서드는 **계약**이고, 오버로딩은 **사용자 경험**이다.
> **서명·선택 우선순위·소거 함정**을 정확히 이해하고, **명확한 이름·불변·방어적 복사**로 API를 설계하면, 유연하면서도 예측 가능한 인터페이스를 만들 수 있다.
