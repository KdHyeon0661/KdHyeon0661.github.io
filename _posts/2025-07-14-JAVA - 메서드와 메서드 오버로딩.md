---
layout: post
title: Java - 메서드와 메서드 오버로딩
date: 2025-07-14 20:20:23 +0900
category: Java
---
# Java 메서드(Method)와 메서드 오버로딩

## 1. 메서드란?

메서드는 **어떤 작업을 수행하는 코드 블록**이며, 객체 또는 클래스에서 호출하여 사용할 수 있습니다. 재사용 가능하고 유지보수에 용이한 구조를 만들어 줍니다.

### 메서드의 구조

```java
[접근제어자] [반환타입] 메서드이름([매개변수]) {
    // 실행 코드
    return 값;  // 반환타입이 void가 아니라면 필수
}
```

### 예시

```java
public int add(int a, int b) {
    return a + b;
}
```

---

## 2. 메서드의 구성 요소

| 구성 요소 | 설명 |
|-----------|------|
| 접근제어자 | public, private, protected 등 |
| 반환타입 | int, void, String 등 |
| 메서드 이름 | 식별자 (소문자 시작 관례) |
| 매개변수 | 메서드 실행 시 전달되는 값들 |
| return 문 | 결과 반환 (void는 생략 가능) |

---

## 3. 메서드 호출

메서드는 객체를 통해 호출하거나, static 메서드의 경우 클래스명을 통해 호출합니다.

```java
public class Calculator {
    public int square(int x) {
        return x * x;
    }

    public static int doubleIt(int x) {
        return x * 2;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator c = new Calculator();
        System.out.println(c.square(5));       // 인스턴스 메서드 호출
        System.out.println(Calculator.doubleIt(5)); // static 메서드 호출
    }
}
```

---

## 4. 반환값과 void

메서드는 결과값을 반환할 수도 있고(return), 아무 값도 반환하지 않을 수도 있습니다(void).

```java
// 반환값이 있는 메서드
public String greet(String name) {
    return "Hello, " + name;
}

// 반환값이 없는 메서드
public void printHello() {
    System.out.println("Hello!");
}
```

---

## 5. 매개변수(Parameter)

메서드 정의 시 입력으로 받을 값을 명시하며, 메서드 호출 시 실제 값(argument)을 전달합니다.

```java
public int multiply(int a, int b) {
    return a * b;
}
```

- `a`, `b`: 매개변수(Parameter)
- `multiply(2, 3)`: 인자(Argument)

---

## 6. 메서드 오버로딩 (Method Overloading)

**같은 이름의 메서드를 여러 개 정의할 수 있는 기능**입니다. 매개변수의 **개수 또는 타입이 다르면** 가능합니다.

### 특징

- 반환형은 오버로딩 기준이 **아님**
- 매개변수만 다르면 같은 이름의 메서드를 정의 가능

---

### 예시 1: 매개변수 개수 다르게

```java
public class Printer {
    void print() {
        System.out.println("출력 없음");
    }

    void print(String s) {
        System.out.println("출력: " + s);
    }

    void print(String s, int count) {
        for (int i = 0; i < count; i++) {
            System.out.println(s);
        }
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Printer p = new Printer();
        p.print();                   // 출력 없음
        p.print("Hello");            // 출력: Hello
        p.print("Hi", 3);            // Hi 3번 출력
    }
}
```

---

### 예시 2: 매개변수 타입 다르게

```java
class Adder {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    String add(String a, String b) {
        return a + b;
    }
}
```

```java
Adder ad = new Adder();
System.out.println(ad.add(1, 2));             // 3
System.out.println(ad.add(1.5, 2.5));         // 4.0
System.out.println(ad.add("Hello", "World")); // HelloWorld
```

---

## 7. 오버로딩 주의사항

| 오버로딩 가능 여부 | 설명 |
|--------------------|------|
| ✅ 매개변수 개수 다름 | 가능 |
| ✅ 매개변수 타입 다름 | 가능 |
| ❌ 반환타입만 다름   | 불가능 (컴파일 에러) |

```java
// 잘못된 예
int compute(int a) { return a; }
// float compute(int a) { return a; } // 컴파일 오류!
```

---

## 8. static 메서드 vs 인스턴스 메서드

| 구분 | 설명 | 예시 |
|------|------|------|
| static | 클래스 소속, 객체 없이 호출 가능 | `Math.abs(-10)` |
| 인스턴스 | 객체 생성 후 호출 | `String.toLowerCase()` |

---

## 9. 재사용성과 모듈화

메서드를 잘 정의하면 코드의 **중복 제거**, **가독성 향상**, **유지보수성 증가** 등의 장점이 있습니다.

예:

```java
class Calculator {
    int square(int x) {
        return x * x;
    }

    int cube(int x) {
        return x * square(x);
    }
}
```

---

## 10. 메서드와 클래스 설계

객체지향 설계에서는 객체의 동작을 메서드로 추상화합니다.

```java
class BankAccount {
    private int balance;

    public void deposit(int amount) {
        balance += amount;
    }

    public boolean withdraw(int amount) {
        if (amount > balance) return false;
        balance -= amount;
        return true;
    }

    public int getBalance() {
        return balance;
    }
}
```

---

## 요약

| 항목 | 설명 |
|------|------|
| 메서드 | 클래스 내부에서 정의된 함수 |
| 반환형 | void 또는 타입 |
| 매개변수 | 메서드 호출 시 전달하는 값 |
| 오버로딩 | 같은 이름, 다른 시그니처 |
| static | 클래스 메서드 (객체 없이 호출 가능) |
| 재사용성 | 코드 중복 제거, 가독성 증가 |

---

Java에서 메서드는 프로그램의 기본 단위이며, 오버로딩을 통해 **유연하고 직관적인 API**를 구성할 수 있습니다. 추후 `메서드 오버라이딩(Overriding)`이나 `람다식`, `스트림 API` 등으로도 확장 가능합니다.
