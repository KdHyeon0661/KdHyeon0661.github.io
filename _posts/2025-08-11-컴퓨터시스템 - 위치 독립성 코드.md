---
layout: post
title: 컴퓨터시스템 - 위치 독립성 코드
date: 2025-08-11 20:20:23 +0900
category: 컴퓨터시스템
---
# 위치 독립성 코드(PIC: Position-Independent Code) — 원리·도구·ELF·성능·보안

> 목표: **공유 라이브러리(.so)** 와 **PIE(위치 독립 실행 파일)** 가 왜/어떻게 “아무 주소에나” 적재되어도  
> 제대로 동작하는지, 컴파일러·링커·로더·하드웨어 관점에서 **끝까지** 파헤친다.  
> 예시는 x86-64/ELF·glibc 기준이며, ARM64도 곁들여 비교한다.

---

## 1) 왜 PIC인가?

### 1.1 필요성
- **ASLR**(Address Space Layout Randomization): 보안 강화를 위해 프로세스마다 코드/데이터 배치 주소를 무작위화.
- **공유 라이브러리 재사용**: 여러 프로세스가 같은 `.so`의 **읽기 전용 페이지를 공유**하려면, 코드가 **자기 자신을 절대주소로 참조하지 않아야** 한다.
- **빠른 로딩**: 텍스트(text) 섹션에 쓰기(rewrite)가 필요하면(=text relocation) 공유가 깨지고 보호비트 변경 필요 → **느리고 위험**. PIC은 이를 피한다.

### 1.2 용어
- **PIC**: 위치 독립 **코드**(주로 공유 라이브러리에서 요구).
- **PIE**(Position-Independent Executable): 위치 독립 **실행 파일**. 실행 파일도 `.so`처럼 베이스가 랜덤.
- **non-PIC/전통 실행 파일**: 텍스트에 절대주소가 박혀 있어서 고정 베이스 필요.

---

## 2) 큰 그림: “자신/타인”을 어떻게 참조하나?

PIC의 핵심은 **절대주소를 직접 박지 않고**,  
- **코드**는 **PC(RIP) 상대**로 점프/데이터 접근,  
- **외부 심볼**(다른 모듈 함수/데이터)은 **간접테이블**(PLT/GOT/TLS)로 접근한다는 점이다.

```
           ┌────────┐   call foo@PLT   ┌────────┐
code  ───► │  PLT   │ ────────────────► │  GOT   │ ──► [실제 foo 주소]
           └────────┘                   └────────┘
                     (첫 호출에 로더가 GOT[foo] 채움)
```

- **GOT**(Global Offset Table): 외부/위치가 바뀔 수 있는 **데이터·함수 주소**가 저장되는 테이블.
- **PLT**(Procedure Linkage Table): 외부 함수 호출용 **간접 점프 트램폴린**.
- **RIP-relative**: x86-64는 `lea %rip+off(%rip), ...` 처럼 **명령포인터 기반 상대주소**를 하드웨어가 지원한다.

---

## 3) 컴파일러/링커 옵션과 산출물

- **공유 라이브러리**: `-fPIC -shared`
- **PIE 실행 파일**: `-fpie -pie` (또는 `-fPIE -pie`)
- **확인**:
  ```bash
  readelf -h a.out | grep Type          # DYN(PIE) vs EXEC
  readelf -r a.out | less               # 남은 동적 재배치(RELATIVE/JUMP_SLOT/GLOB_DAT 등)
  objdump -d a.out | less               # RIP-relative, PLT 호출 확인
  ```

> x86-64는 작은/중간 코드 모델과 RIP-relative 덕분에 **PIC 페널티가 낮다**.  
> 반면 x86(32비트), 고전 ARM 등은 레지스터에 **GOT 베이스**를 세팅해야 해서 오버헤드가 더 컸다.

---

## 4) x86-64에서의 PIC 코드 패턴

### 4.1 로컬 read-only 데이터(상수/문자열) 접근 — RIP-relative
```c
// c
static const char msg[] = "hi";
const char* get_msg(void){ return msg; }
```
```asm
# asm (요지)
get_msg:
    lea rax, [rip + .Lmsg]   # RIP-relative로 자기 .rodata를 참조
    ret
```
- **장점**: **GOT 불필요**, 재배치도 **R_X86_64_RELATIVE**만 남아 빠름.
- **전제**: 심볼이 외부에서 **인터포지션**되지 않음(= 외부에서 바꿔치기 불가).  
  → 이를 보장하려면 **가시성 hidden** 또는 컴파일러 플래그(아래 §8.2).

### 4.2 외부 함수 호출 — PLT/GOT 간접
```c
extern int foo(int);
int use(int x){ return foo(x)+1; }
```
```asm
use:
    mov edi, esi
    call foo@PLT     # PLT→(첫 호출 시) 로더 바인더 → GOT[foo] 채움
    add eax, 1
    ret
```
- 첫 호출 때 **지연 바인딩(lazy)** 비용, 이후부터는 GOT 히트.

### 4.3 외부 데이터 전역 — GOT 로드
```c
extern int ext;
int g(void){ return ext; }
```
```asm
g:
    mov rax, qword ptr [rip + ext@GOTPCREL]  # GOT 엔트리 주소 얻기
    mov eax, dword ptr [rax]                 # 실제 전역 읽기
    ret
```

---

## 5) ARM64(AArch64) 한줌 비교

- **ADRP/ADD** 페어로 **페이지 베이스** + 오프셋을 합쳐 주소를 만든다.
- 외부 심볼은 보통 **GOT 로드** 뒤 사용, 함수는 **PLT 유사 트램폴린** 경유.
```asm
adrp x0, :got:foo
ldr  x0, [x0, :got_lo12:foo]   // GOT 엔트리 로드
blr  x0                        // 간접 호출
```
- 내부 상수/로컬 심볼은 `adrp+add`로 RIP-relative 유사 접근.

---

## 6) ELF 재배치와 PIC의 상관

주요 동적 재배치 타입(x86-64):
- **`R_X86_64_RELATIVE`**: **베이스+addend** → 빠르고 대량 처리(PIE/PIC 기본)
- **`R_X86_64_JUMP_SLOT`**: 함수(PLT) 엔트리 채움
- **`R_X86_64_GLOB_DAT`**: 데이터 전역의 GOT 엔트리 채움
- **`R_X86_64_COPY`**: 실행 파일로 전역 데이터 **복사 재배치**(과거 호환; 인터포지션 부작용)  
  → PIE+현대 툴체인에서는 가급적 회피

**PIC의 목표**: 텍스트 섹션에 “절대 주소 패치”가 없도록 하여 **텍스트 재배치(TEXTREL)**를 제거.  
그래야 텍스트가 **R-X**(읽기/실행)로만 매핑되고 **공유** 가능.

---

## 7) TLS(Thread-Local Storage)와 PIC

TLS 접근 모델(컴파일러가 선택/강제 가능):
- **LE(Local Exec)**: 정적 링크/고정 시 가장 빠름(비-PIC 친화).
- **IE(Initial Exec)**: 프로그램 시작 시 TLS이 정해지는 환경에서 빠름(DSO에서도 쓸 수 있음; 성능 우수).
- **LD(Local Dynamic)**/**GD(General Dynamic)**: 어디서든 동작(가장 범용)하지만 호출 오버헤드가 큼.

고성능 경로에서는 가능하면 **IE**를 선호(빌드/배치 제약을 수용 가능할 때).

---

## 8) 성능 최적화와 가시성/의미론

### 8.1 인터포지션의 비용
기본 ELF 의미론: **외부에서 내 함수/전역을 가로채기 가능**(interposition).  
컴파일러는 이를 가정하면 **외부처럼** 간접화(PLT/GOT)를 사용 → **인라이닝/상수 전파 제약**.

### 8.2 빠른 PIC를 위한 플래그
- DSO 내부 참조를 **자기 정의로 고정**:
  - 컴파일: `-fno-semantic-interposition` (Clang/GCC; 자기 모듈 내 호출 최적화 허용)
  - 링크(DSO): `-Wl,-Bsymbolic` 또는 심볼 가시성 **`hidden`/`protected`** 사용
- 외부 노출 최소화:  
  - 컴파일 전체 기본을 `-fvisibility=hidden`으로 두고, 공개 API만  
    `__attribute__((visibility("default")))` 로 내보내기
- 실행 파일에서 PLT 간접 최소화: `-fno-plt`(GCC; 일부 타깃)로 **레지스터 간접 호출** 유도

> 요지: **가시성을 좁히면** 컴파일러가 더 과감한 **RIP-relative/인라인/상수화**를 하고,  
> PIC이어도 **거의 non-PIC 수준 성능**을 낼 수 있다.

---

## 9) 보안과 배포: PIE, RELRO, NOW

- **PIE(`-fpie -pie`) + ASLR**: 실행 파일 베이스 랜덤화(코드 재사용 공격 방어력↑).
- **RELRO(Partial/Full)**: GOT를 읽기전용으로 잠금.  
  - 링크: `-Wl,-z,relro -Wl,-z,now`(Full RELRO) → **지연 바인딩 비활성**.  
  - 트레이드오프: 시작이 느릴 수 있음(하지만 보안/안정성↑).
- **취약점 완화**: 텍스트 재배치 금지(TEXTREL 없음), NX/CFI 등과 함께 사용.

---

## 10) 예제: 작은 라이브러리와 호출 관찰

### 10.1 코드
```c
// libx.c
#include <stdio.h>
int ext = 7;
__attribute__((visibility("hidden")))
static const char msg[] = "hello";
void x_hello(void){ puts(msg); }
int  x_add(int a){ return a + ext; }
```
```c
// app.c
#include <stdio.h>
void x_hello(void);
int  x_add(int);
int main(){
  x_hello();
  printf("%d\n", x_add(10));
}
```

### 10.2 빌드/관찰
```bash
gcc -fPIC -fvisibility=hidden -shared libx.c -o libx.so
gcc -fpie -pie app.c -L. -lx -Wl,-rpath,. -o app

objdump -d libx.so | less         # x_hello에서 RIP-relative로 msg 접근 확인
objdump -d app | grep x_add@PLT   # 외부 함수 호출은 PLT 경유
readelf -r app | less             # JUMP_SLOT/GLOB_DAT/RELATIVE 등 확인
```

- `msg`는 **hidden**이므로 DSO 내부에서 **직접 RIP-relative** 가능 → GOT 없이 빠름.
- `x_add` 호출은 **PLT** 경유(외부 모듈 함수).

---

## 11) 흔한 함정과 해결

| 문제 | 원인 | 해결 |
|---|---|---|
| 텍스트 재배치(TEXTREL) 발생 | 절대주소 상수 삽입, 잘못된 어셈블리 | `-fPIC` 사용, 어셈블리에서 RIP-relative/GOT 사용 |
| PLT 오버헤드/분기미스 | 인터포지션 가정 | `-fno-semantic-interposition`, 가시성 숨김, `-Bsymbolic` |
| 전역 데이터 접근 느림 | 항상 GOT 경유 | 내부 전용 데이터는 hidden/`static`으로 만들기 |
| TLS 접근 느림 | GD/LD 모델 강제 | IE/LE 모델 사용(가능할 때), 링크·배치 조건 조정 |
| 시작 지연 | lazy 바인딩 + 캐시 미스 | `-Wl,-z,now`(즉시 바인딩) 또는 핵심 경로만 `dlsym`/프리워밍 |

---

## 12) 빌드 체크리스트

- [ ] 공유 라이브러리: `-fPIC -shared`  
- [ ] PIE 실행 파일: `-fpie -pie`  
- [ ] 공개 API 이외는 **hidden**: `-fvisibility=hidden` + 필요 심볼만 `default`  
- [ ] DSO 내부 호출 최적화: `-fno-semantic-interposition`(또는 `-Bsymbolic`)  
- [ ] 보안: `-Wl,-z,relro -Wl,-z,now`, ASLR 활성(PIE)  
- [ ] 산출물 확인: `readelf -h/-r`, `objdump -d`, `ldd`

---

## 13) 요약 한 줄

**PIC/PIE**는 “**절대주소 대신 상대/간접**”이라는 단순 원리를 시스템적으로 구현한 결과다.  
**RIP-relative**(내부), **GOT/PLT**(외부), **RELATIVE 재배치**(로더 빠른 패치)의 삼각편대로  
**보안(ASLR)** 과 **성능(공유/최소 재배치)** 을 동시에 달성한다.  
마무리는 **가시성 축소**와 **인터포지션 무력화 옵션**으로 **non-PIC에 근접한 성능**을 뽑아내는 것이다.