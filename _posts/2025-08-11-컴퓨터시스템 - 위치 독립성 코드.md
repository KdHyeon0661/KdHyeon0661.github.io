---
layout: post
title: 컴퓨터시스템 - 위치 독립성 코드
date: 2025-08-11 20:20:23 +0900
category: 컴퓨터시스템
---
# 위치 독립성 코드(PIC: Position-Independent Code)

## 0. 한눈 요약(Executive Summary)

- **PIC/PIE의 핵심 원리**: 절대주소를 텍스트에 박지 않고 **RIP/PC-relative** + **간접 테이블(GOT/PLT/TLS)** 로 해결한다.  
- **이득**: ASLR 보안, 텍스트 공유(R-X), 빠른 로딩(텍스트 재배치 금지), 다수 프로세스 메모리 절감.  
- **성능**: x86-64는 RIP-relative 덕에 PIC 패널티가 매우 낮다. 가시성 축소·인터포지션 억제로 **non-PIC에 근접** 가능.  
- **빌드 규칙**:  
  - .so: `-fPIC -shared`  
  - PIE: `-fpie -pie` (또는 `-fPIE -pie`)  
  - 내부 호출 최적화: `-fno-semantic-interposition`, DSO에선 `-Wl,-Bsymbolic` 고려  
  - 보안: `-Wl,-z,relro -Wl,-z,now` + PIE  
  - 공개 API 외 **hidden** 기본(`-fvisibility=hidden`)  
- **확인**: `readelf -h/-l/-r/-d`, `objdump -d/-R`, `ldd`.

---

## 1. 왜 PIC인가?

### 1.1 필요성(ASLR·공유·로딩)
- **ASLR**: 주소 무작위화로 익스플로잇 난이도↑. 실행 파일도 **PIE**면 베이스가 랜덤.  
- **텍스트 공유**: 여러 프로세스가 같은 `.so`의 **R-X 페이지**를 공유하려면 텍스트에 **쓰기 재배치(TEXTREL)** 가 없어야 함 → PIC이 필수.  
- **로딩 속도/권한 최소화**: 텍스트에 패치가 필요하면 페이지 권한 전환(RWX→R-X)이 발생해 느리고 위험.

### 1.2 용어 정리
- **PIC**: 위치 독립 **코드** (주로 공유 라이브러리).  
- **PIE**: 위치 독립 **실행 파일** (ET\_DYN 타입의 a.out).  
- **non-PIC**: 절대주소 내장(구형 실행 파일/일부 오브젝트).

---

## 2. 큰 그림: “자신/타인”을 어떻게 참조하나?

핵심은 **절대주소 대신 상대/간접**이다.

```
           ┌──────────┐   call foo@PLT    ┌──────────┐
code  ───► │   PLT    │ ─────────────────►│   GOT    │──► [실제 foo 주소]
           └──────────┘                    └──────────┘
                      (첫 호출 때 로더가 GOT[foo] 채움: Lazy Binding)
```

- **RIP/PC-relative**: x86-64는 명령 포인터(RIP) 기준으로 상수/데이터/분기 타깃을 읽는다.  
- **GOT(Global Offset Table)**: 외부/변동 가능한 **데이터·함수 주소**를 담는 테이블.  
- **PLT(Procedure Linkage Table)**: 외부 함수 호출을 위한 **간접 점프 슬롯**.

---

## 3. 빌드 옵션과 산출물(ELF 타입)

```bash
# 공유 라이브러리(.so)
gcc -fPIC -shared libx.c -o libx.so

# PIE 실행 파일
gcc -fpie -pie app.c -o app

# 산출물 확인
readelf -h app | grep Type         # Type: DYN(Shared object file) → PIE
readelf -r app | less              # 남은 동적 재배치(RELATIVE/JUMP_SLOT 등)
objdump -d app | less              # RIP-relative, PLT 호출 패턴
```

- 전통 실행 파일(비-PIE)은 **ET\_EXEC**, PIE는 **ET\_DYN**.  
- 현대 x86-64는 RIP-relative 지원 덕에 PIC 페널티가 낮다(고전 x86/ARM 대비).

---

## 4. x86-64의 PIC 코드 패턴

### 4.1 로컬 read-only(문자열/상수): **RIP-relative**
```c
// c
static const char msg[] = "hi";
const char* get_msg(void){ return msg; }
```
```asm
# asm 개요
get_msg:
    lea rax, [rip + .Lmsg]   # RIP-relative로 .rodata 접근
    ret
```
- **GOT 불필요**, 재배치도 `R_X86_64_RELATIVE` 중심 → 빠름.  
- 외부에서 바뀔 수 없도록 **hidden/static**이 유리.

### 4.2 외부 함수: **PLT 경유**
```c
extern int foo(int);
int use(int x){ return foo(x)+1; }
```
```asm
use:
    mov edi, esi
    call foo@PLT
    add eax, 1
    ret
```
- 첫 호출은 바인더 진입(지연바인딩), 이후는 GOT 히트.

### 4.3 외부 전역 데이터: **GOT 로드**
```c
extern int ext;
int g(void){ return ext; }
```
```asm
g:
    mov rax, qword ptr [rip + ext@GOTPCREL]  # GOT 엔트리 주소
    mov eax, dword ptr [rax]                 # 실제 전역
    ret
```

### 4.4 `-fno-plt` (일부 타깃)
- `call foo@PLT` 대신 레지스터에 실제 주소를 로드해 간접 호출(분기 예측이 유리한 경우가 있음).

---

## 5. AArch64(ARM64) 비교 패턴

- **ADRP/ADD**로 페이지 베이스 + 오프셋 구성(PC-relative).  
- 외부 심볼은 **GOT 로드 후 BLR** 호출.

```asm
adrp x0, :got:foo
ldr  x0, [x0, :got_lo12:foo]   // GOT 엔트리 주소 로드
blr  x0                        // 간접 호출
```

- 로컬 상수는 `adrp+add`로 RIP-relative 유사 접근.

---

## 6. ELF 재배치와 PIC

주요 동적 재배치(x86-64):

| 타입 | 역할 |
|---|---|
| `R_X86_64_RELATIVE` | 베이스+애드엔드(대량/빠름, PIE/PIC 기본) |
| `R_X86_64_JUMP_SLOT` | 함수(PLT/GOT) 엔트리 채움 |
| `R_X86_64_GLOB_DAT` | 데이터 전역의 GOT 엔트리 채움 |
| `R_X86_64_COPY` | 실행 파일로 전역 **복사**(과거 호환; 권장X) |
| `R_X86_64_IRELATIVE` | IFUNC용(해결자 반환 주소로 패치) |

**목표**: 텍스트에 절대 패치가 없는 **TEXTREL=0**. 그래야 텍스트를 **R-X**로만 매핑해 공유·보안 모두 이득.

> 최신 툴체인은 상대 재배치 압축 형식 **RELR(DT\_RELR)** 를 지원해 재배치 테이블 크기도 줄인다(로딩 속도/캐시 이점).

---

## 7. PIE 로딩 시 로더의 일

1) `PT_INTERP`로 로더 매핑 → `DT_NEEDED` 따라 .so 탐색/매핑  
2) `RELATIVE/GLOB_DAT/JUMP_SLOT/IRELATIVE/TLS*` 적용  
3) `.init_array` 실행, 스택 초기화 → `_start` 진입

수식 관점(PC-relative):
$$
\text{Result} = S + A - P
$$
\(S\): 심볼 최종 주소, \(A\): 애드엔드, \(P\): 이 필드 다음 명령의 주소.

---

## 8. TLS(Thread-Local Storage)와 PIC

TLS 접근 모델(성능 ↔ 제약):

| 모델 | 특징 | 적합 |
|---|---|---|
| **LE(Local Exec)** | 정적/고정, 가장 빠름 | 정적 링크/초기 로딩 고정 |
| **IE(Initial Exec)** | 시작 시 고정, 빠름 | DSO/주요 모듈 |
| **LD/ GD(Local/General Dynamic)** | 어디서든 OK, 느림 | 플러그인/지연 로드 |

```c
__thread int tls_x;           // ELF TLS
int read_tls(void){ return tls_x; }  // 모델은 링크·로딩 형태로 결정
```

- 가능하면 **IE**로(링크·배치 제약 수용 시).  
- 재배치: `R_X86_64_TPOFF64`, `TLSDESC` 등 타깃별 상이.

---

## 9. IFUNC(Indirect Function)

런타임에 **해결자**가 최적 구현 주소를 선택:

```c
// ifunc.c
static void base(void){ /* ... */ }
static void avx2(void){ /* ... */ }
static void* resolver(void){
  return has_avx2() ? (void*)avx2 : (void*)base;
}
void foo(void) __attribute__((ifunc("resolver")));
```

- 재배치: `R_X86_64_IRELATIVE`  
- 주의: 초기화 순서/스레드 안전, 정적 링크 제약.

---

## 10. 가시성·인터포지션·최적화

### 10.1 가시성
- 기본을 `-fvisibility=hidden`으로, 공개 API만  
  `__attribute__((visibility("default")))`.

### 10.2 인터포지션 억제
- DSO 내부 참조 고정: `-Wl,-Bsymbolic` (또는 `-Bsymbolic-functions`)  
- 컴파일러 최적화 허용: `-fno-semantic-interposition`  
- 효과: 내부 호출이 **직접 결속**되어 인라이닝/상수 전파 가능, PLT 간접 감소.

### 10.3 심볼 버전(ABI)
- 버전 스크립트로 공개 범위·버전 명시:
```ld
LIB_1.0 {
  global: api_*;
  local:  *;
};
```

---

## 11. 보안: PIE·RELRO·NOW·CFI·CET/PAC

- **PIE + ASLR**: 코드 재사용 공격 방어력↑.  
- **RELRO**: GOT를 읽기 전용으로(Partial/Full). Full은 **NOW**(즉시 바인딩) 필요.
```bash
# 권장 링크 플래그
-Wl,-z,relro -Wl,-z,now
```
- **CFI/시그니처 검증**, x86 **CET(IBT)**, ARM64 **BTI/PAC** 와의 시너지도 큼(간접 분기 보호).

---

## 12. 성능: 언제 비용이 나고 어떻게 줄이나

- x86-64는 **RIP-relative** 덕에 **로컬 데이터/상수 접근의 오버헤드 ≈ 0**.  
- 비용이 나는 곳:  
  1) **외부 함수** PLT 간접 + (Lazy 첫 호출)  
  2) **외부 전역**의 GOT 간접  
  3) **TLS GD/LD** 모델  
- 줄이는 법:  
  - 가시성 숨김/`static`으로 내부는 **직접(RIP-relative)**  
  - `-fno-semantic-interposition`, `-Bsymbolic`  
  - 필요 시 `-fno-plt`  
  - TLS는 IE/LE 모델로 설계  
  - LTO/ThinLTO로 **DSO 경계 전**에 최대한 인라이닝/불필요 호출 제거

---

## 13. 도구 요약(검사/확인)

```bash
# ELF 타입/헤더/프로그램 헤더
readelf -h/-l a.out

# 재배치/동적 섹션
readelf -r a.out
readelf -d a.out

# 디스어셈(PLT/GOT, RIP-relative 확인)
objdump -d a.out | less
objdump -R a.out | less

# 런타임 의존/바인딩 로그
ldd a.out
LD_DEBUG=libs,reloc,bindings ./a.out 2>&1 | less
```

---

## 14. 워크드 랩: 작은 .so + PIE, 그리고 관찰

### 14.1 코드
```c
// libx.c
#include <stdio.h>
int ext = 7;
__attribute__((visibility("hidden")))
static const char msg[] = "hello";
void x_hello(void){ puts(msg); }
int  x_add(int a){ return a + ext; }
```

```c
// app.c
#include <stdio.h>
void x_hello(void);
int  x_add(int);
int main(){
  x_hello();
  printf("%d\n", x_add(10));
}
```

### 14.2 빌드 & 관찰
```bash
gcc -fPIC -fvisibility=hidden -shared libx.c -o libx.so
gcc -fpie -pie app.c -L. -lx -Wl,-rpath,. -o app

objdump -d libx.so | sed -n '1,120p'       # x_hello가 msg를 RIP-relative로 취함
objdump -d app | grep -n "x_add@PLT"       # 외부 함수 호출은 PLT 경유
readelf -r app | egrep 'JUMP_SLOT|GLOB_DAT|RELATIVE'
```

**관찰 포인트**  
- `msg`는 **hidden** → DSO 내부에서 **GOT 없이** RIP-relative 가능(빠르며 TEXTREL 없음).  
- `x_add` 호출은 **PLT** → Lazy 바인딩 1회 후 GOT 히트.  
- `app`는 PIE(ET\_DYN) → `R_X86_64_RELATIVE`가 다수, `JUMP_SLOT/GLOB_DAT`가 일부.

---

## 15. 함정·에지 케이스

| 증상 | 원인 | 해결 |
|---|---|---|
| TEXTREL 경고/실행 차단 | 절대주소 상수/어셈블리 실수 | `-fPIC`, 어셈블리에서 RIP-relative/GOT 사용 |
| 외부 오버라이드로 성능 급락 | 인터포지션 의미론 기본 | `-fno-semantic-interposition`, `-Bsymbolic`, hidden |
| 전역 데이터 일관성 붕괴 | `R_X86_64_COPY` 복사 재배치 | PIE+PIC, 실행 파일 전역을 DSO가 직접 참조하지 않기 |
| TLS 접근 느림 | GD/LD 모델 | IE/LE로 전환(링크/배치 제약 충족) |
| 시작만 버벅임 | Lazy 바인딩 첫 호출 | `-Wl,-z,now`(즉시 바인딩) or 사전 워밍업 |

**코드 모델(x86-64)**: `-mcmodel=small/medium/large`에 따라 코드/데이터 참조 생성이 달라져 PIC 가능 패턴과 성능에 영향. 일반 앱은 **small/medium** 권장.

---

## 16. 수식으로 보는 주소 결속

PIC/PIE에서 대표적 패치 수식 두 가지:

1) **PC-relative 분기/데이터**  
$$
\text{patch} = (S + A) - P
$$

2) **상대 재배치(RELATIVE)**  
$$
\text{dst} \leftarrow \text{base} + A
$$

여기서 \(S\): 심볼 주소, \(A\): 애드엔드, \(P\): 다음 명령 주소, \(\text{base}\): 로더가 정한 모듈 베이스.

---

## 17. 체크리스트

- [ ] .so: `-fPIC -shared`, PIE: `-fpie -pie`  
- [ ] 기본 가시성 **hidden**, 공개만 `default`  
- [ ] 내부 참조 최적화: `-fno-semantic-interposition`(+ DSO `-Bsymbolic` 검토)  
- [ ] 보안: `-Wl,-z,relro -Wl,-z,now` + PIE + NX  
- [ ] TLS 모델 점검(IE/LE 우선)  
- [ ] 산출물 점검: `readelf -h/-l/-r/-d`, `objdump -d/-R`, `ldd`  
- [ ] TEXTREL이 없는가? `readelf -r | grep -i textrel`  
- [ ] 불필요한 공개 심볼·NEEDED 제거(`--as-needed`, 버전 스크립트)

---

## 18. 부록: 스니펫 모음

### 18.1 공개 API만 노출(버전 스크립트)
```ld
LIBX_1.0 { global: x_*; local: *; };
```
```bash
gcc -fPIC -shared x.c -Wl,--version-script=exports.map -o libx.so
```

### 18.2 내부 고정 + 보안 플래그(템플릿)
```bash
CFLAGS="-O2 -fPIC -fvisibility=hidden -fno-semantic-interposition"
LDFLAGS="-shared -Wl,-z,relro -Wl,-z,now -Wl,--as-needed"
```

### 18.3 PIE 앱(템플릿)
```bash
CFLAGS="-O2 -fpie -fstack-protector-strong -D_FORTIFY_SOURCE=3"
LDFLAGS="-pie -Wl,-z,relro -Wl,-z,now"
```

---

## 19. 결론

**PIC/PIE는 “절대 대신 상대/간접”** 이라는 단순한 전제를 **ELF·컴파일러·로더·ISA** 전 층위에서 일관되게 구현한 결과다.  
**RIP-relative(내부)** + **GOT/PLT(외부)** + **RELATIVE 재배치(빠른 패치)** 의 삼각편대로  
보안(ASLR/RELRO)과 성능(텍스트 공유·낮은 오버헤드)을 같이 얻는다.  
실무에선 **가시성 축소·인터포지션 억제·TLS 모델 선택**을 습관화하라.  
마지막은 항상 **툴로 확인** — “말이 아니라 `readelf/objdump/LD_DEBUG`의 로그”가 정답이다.