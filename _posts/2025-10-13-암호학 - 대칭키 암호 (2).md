---
layout: post
title: 암호학 - 대칭키 암호 (2)
date: 2025-10-13 15:30:23 +0900
category: 암호학
---
# 5. 대칭키 암호(블록·스트림) (2) — 운용 모드 & AEAD (🔰→⚙️)

> 이 장은 “**블록암호 운용 모드**(ECB/CBC/CTR/GCM/XTS) → **Nonce·IV 규칙과 재사용 위험** → **인증암호(AEAD)**: GCM, ChaCha20-Poly1305” 순서로 정리합니다.  
> 핵심은 **무결성까지 제공하는 AEAD를 기본값으로** 쓰고, **Nonce/IV를 절대 재사용하지 않는 것**입니다. 모든 코드는 **교육용 예제**이며, 실무에서는 검증된 라이브러리를 그대로 사용하세요.

---

## ✅ 5.1 블록암호 운용 모드 — 왜 필요한가?

블록암호 \(E_K:\{0,1\}^n\to\{0,1\}^n\)는 **고정 길이** 블록만 처리합니다. 실제 데이터는 길이가 다양하므로, **운용 모드(mode of operation)** 로 “블록들을 어떻게 잇고, 무작위성(IV/Nonce)을 어떻게 섞을지”를 정합니다.

- **ECB** (Electronic Codebook): 각 블록 독립 암호화 → **패턴 노출** (금지)
- **CBC** (Cipher Block Chaining): 이전 암호문을 XOR해 연쇄 → **패딩·오라클 주의**
- **CTR** (Counter mode): 블록암호를 **스트림키 생성기**로 사용 → **Nonce/카운터 재사용 금지**
- **GCM** (Galois/Counter Mode): CTR + 다항 해시(GHASH)로 **인증**(AEAD)
- **XTS** (XEX-based Tweaked-CodeBook): **디스크 암호화**에 특화(무결성 제공 **X**)

---

## ✅ 5.2 ECB의 문제 — “패턴이 보인다”

**정의**  
\[
C_i = E_K(P_i)
\]
블록 사이의 의존이 **전혀 없음**. 동일한 평문 블록은 동일한 암호문 블록이 됩니다.

**결과**  
- 이미지/문서/프로토콜에서 **반복되는 구조**가 암호문에도 **같은 패턴**으로 나타납니다.
- 평문 분포 정보가 **직접 샌다** → 통계/선형 공격 표면 확대.

**결론**: **ECB는 절대 쓰지 마세요.** 실습/교재에서만 등장시키고, 코드/옵션에선 **막아두는 것**이 좋습니다.

---

## ✅ 5.3 CBC (Cipher Block Chaining) — 고전의 표준, 이제는 조심해서

**정의**
\[
\begin{aligned}
C_0 &= E_K(P_0 \oplus \mathrm{IV}) \\
C_i &= E_K(P_i \oplus C_{i-1}) \quad (i\ge1)
\end{aligned}
\]
복호는 \(P_0 = D_K(C_0) \oplus \mathrm{IV}\), \(P_i = D_K(C_i)\oplus C_{i-1}\).

**성질**
- **IV는 예측 불가(random)** 해야 안전. (재사용은 기밀성 저하)
- **패딩 필요**(PKCS#7 등). 패딩/에러 핸들링이 틀리면 **패딩 오라클**로 깨짐.

**패딩 오라클 위험 (직관)**
- 복호 시 “패딩 에러/정상”의 **반응 차이**가 있으면, 공격자가 암호문 블록을 조작하며 **바이트 단위 평문 복구** 가능(IND-CCA 실패).
- **대응**: CBC를 쓰더라도 반드시 **Encrypt-then-MAC**(복호 전에 MAC 검증) 또는 **AEAD** 사용.

**파이썬(교육용): CBC 사용 예 — 경고 포함**
```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
import os, hmac

key = os.urandom(16)
iv  = os.urandom(16)  # CBC IV: 예측 불가 무작위
cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())

# PKCS#7 패딩
padder = padding.PKCS7(128).padder()
pt = b"cbc demo message"
padded = padder.update(pt) + padder.finalize()

enc = cipher.encryptor()
ct = enc.update(padded) + enc.finalize()

# 복호(주의: 무결성 검증 없음 → 변조 탐지 X)
dec = cipher.decryptor()
unpadded = padding.PKCS7(128).unpadder().update(dec.update(ct)+dec.finalize()) + padding.PKCS7(128).unpadder().finalize()
# 실제 실무: 이렇게 쓰면 안 됩니다. AEAD나 EtM 필요!
```

**결론**  
- **오늘의 기준**: CBC 단독(무결성 없음) **금지**.  
- 레거시 호환이 필요하면 **EtM(MAC 먼저 검증, 그 다음 복호)** 로 감싼 프로토콜만 허용.

---

## ✅ 5.4 CTR (Counter) — 블록암호로 만드는 스트림 암호

**정의**
\[
\mathrm{keystream}_i = E_K(\mathrm{Nonce}\ \| \ \mathrm{Counter}+i),\qquad C_i = P_i \oplus \mathrm{keystream}_i
\]
복호는 XOR 동일.

**장점**
- 패딩이 **불필요**(스트림).
- 병렬화 가능, 구현 단순, 빠름.

**치명 규칙: Nonce/카운터 재사용 금지**
- **동일 키**에서 **동일 (Nonce, Counter)** 를 두 번 쓰면 **같은 키스트림**이 생성.
- 결과적으로 \(C^A \oplus C^B = P^A \oplus P^B\) → 두 평문에 대한 **강력한 정보 누설**.

**파이썬(설명용): 키스트림 재사용 누설**
```python
# 개념 시뮬레이션: 실제 CTR 구현 대신 XOR 스트림 가정
import os

def xor(a,b): return bytes(x^y for x,y in zip(a,b))

keystream = os.urandom(32)   # "같은 Nonce/Counter" 가정
PA = b"ATTACK AT DAWN-------"
PB = b"RETREAT AT DUSK------"
CA = xor(PA, keystream)
CB = xor(PB, keystream)

leak = xor(CA, CB)  # == PA ^ PB
print("PA^PB:", leak)  # 구조/단어 패턴이 드러남
```

**결론**  
- CTR 자체는 안전하지만, **Nonce/카운터 관리 실패**가 잦습니다.  
- 프로토콜에서는 **AEAD(GCM 등)** 으로 가고, Nonce는 **라이브러리 자동 생성**에 맡기세요.

---

## ✅ 5.5 GCM (Galois/Counter Mode) — AEAD의 대표

GCM은 **CTR 암호화** + **GHASH 인증**을 결합하여 **기밀성+무결성**을 동시에 제공합니다.

### 5.5.1 구성 개요
- **암호화**: CTR로 평문 암호화 → \(C = P \oplus \mathrm{KS}\)
- **인증**: GF(2^128)에서 **다항 해시 GHASH** 로 AAD와 암호문을 해싱 → 태그 생성
- **입력**: 키 \(K\), **Nonce(IV)**, AAD(연결되는 헤더/메타), 평문 \(P\)
- **출력**: 암호문 \(C\), **태그(Tag)**

**Nonce 길이**
- **96비트(12바이트)** 권장. 이 경우 내부 **J0 계산**이 단순/효율적.
- 다른 길이도 가능하지만 내부에서 GHASH로 96비트로 축약 → 성능·안전성 측면에서 **12바이트 쓰세요**.

### 5.5.2 Nonce 재사용의 위험 (중요!)
- **같은 키**에서 **같은 Nonce**를 **두 번** 쓰면, GCM의 **무결성/기밀성 안전성 모두 약화**.  
- 암호문과 태그 조합으로 **위조 가능성**이 증가합니다(수학적 한계).  
- 대규모 트래픽에서 **Nonce 충돌 확률 관리**가 필요(카운터·난수 혼합 등).

### 5.5.3 태그 길이
- 보통 **128비트**(16바이트). 일부 환경에서 96/64비트로 줄이기도 하나, **128비트 권장**.

### 5.5.4 파이썬(AES-GCM) — 표준 사용 예
```python
# pip install cryptography
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os

key   = AESGCM.generate_key(bit_length=256)
aes   = AESGCM(key)
nonce = os.urandom(12)                # 96-bit
aad   = b"route=/api/v1;seq=42"
pt    = b"gcm example payload"

ct = aes.encrypt(nonce, pt, aad)      # returns ciphertext || tag (tag length=16 by default)
pt2 = aes.decrypt(nonce, ct, aad)     # tamper → raises exception
print(pt2)
```

### 5.5.5 GCM 내부(요약 직관)
- **GHASH**: 암호 키로부터 생성한 **해시 서브키 \(H = E_K(0^{128})\)** 를 사용.  
- AAD와 암호문 블록들을 **GF(2^128)** 다항로 묶어 \(H\)로 평가(캐리 없는 곱/나눗셈) → 태그는 \(E_K(J_0)\oplus \mathrm{GHASH}\).  
- x86(PCLMULQDQ), ARM(PMULL) 등 **캐리리스 곱** 가속 덕분에 매우 빠름.

### 5.5.6 GCM 사용 팁
- Nonce **고유성** 확보(동일 키에서 중복 금지). 서버 팜/컨테이너/재부팅 고려하여 **난수+카운터+노드ID** 조합 또는 **라이브러리 자동**.  
- **AAD 설계**: 라우팅/버전/길이 등 **암호화하지 않지만** 무결성이 필요한 메타를 AAD로.  
- 태그/에러는 **균일 처리**(타이밍·메시지 차별 금지).

---

## ✅ 5.6 XTS — 디스크/블록 디바이스 전용 모드

**목적**: **랜덤 접근** 블록 장치에서 **섹터 단위**로 암호화. 파일/디스크의 **동일 오프셋**에 있는 패턴 노출을 막기 위해 **트윅(tweak)** 을 섞습니다.

**구성 (XEX with Tweak)**
\[
C = E_{K_1}(P \oplus T) \oplus T,\qquad T = \alpha^i \cdot E_{K_2}(\text{sector\_number})
\]
여기서 \(\alpha^i\)는 GF(2^128)에서의 left-shift 기반 스칼라(블록 인덱스 \(i\)에 따라 변함).

**장점**
- 동일 섹터 내 블록마다 서로 다른 트윅 → **ECB 패턴 제거**
- 랜덤 블록 접근 적합(디스크)

**주의/한계**
- **무결성 제공 X** → **비트플립 가능**(데이터 변조 탐지 불가).  
- **전송 보안용으로 부적절**(TLS 같은 스트림/메시지에 쓰지 말 것).  
- 섹터 크기·패딩 처리·마지막 부분 블록 처리가 까다로움 → **라이브러리/표준 구현** 필수.

---

## ✅ 5.7 인증암호(AEAD) — “기밀성 + 무결성 + AAD”

AEAD는 암호화 시 **인증 태그**를 함께 만들어, 복호 전 **무결성 검증**을 강제합니다.  
대표: **AES-GCM**, **ChaCha20-Poly1305**.

### 5.7.1 왜 AEAD가 기본인가?
- CBC/CTR과 달리 **변조를 즉시 탐지** → 패딩 오라클·비트플립 등 근본 봉쇄.
- **AAD**: 헤더·라우팅 정보처럼 **암호화하지 않지만 무결성이 필요한** 데이터를 보호.

### 5.7.2 ChaCha20-Poly1305 (RFC 8439) — 개요
- **ChaCha20**: ARX 기반 스트림키 생성(키/Nonce/카운터로 64B 블록)
- **Poly1305**: \(r\)·\(s\) 매개로 정의되는 **모듈러 \(2^{130}-5\)** MAC.  
  - 메시지 블록을 정수로 보고 \(\sum m_i r^i\) 형식으로 누적 후 \(s\) 더해 16바이트 태그 출력.
  - \(r\)의 비트는 ‘클램프(clamp)’로 일부 비트 마스킹(보안성·계산 안정성).

**안전 사용 규칙**
- **키 고정 + Nonce 고유**(96비트).  
- **동일 (키, Nonce)** 를 반복하면 **one-time Poly 키가 같아져** 위조 위험 급증. (GCM과 동일한 Nonce 재사용 위험)

**파이썬 예**
```python
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305
import os

key = ChaCha20Poly1305.generate_key()
aead = ChaCha20Poly1305(key)
nonce = os.urandom(12)
aad = b"hdr:account=1234"
pt  = b"chacha20-poly1305 example"

ct = aead.encrypt(nonce, pt, aad)
pt2 = aead.decrypt(nonce, ct, aad)   # 변조 시 예외
print(pt2)
```

### 5.7.3 GCM vs ChaCha20-Poly1305 — 선택 포인트
| 항목 | AES-GCM | ChaCha20-Poly1305 |
|---|---|---|
| 하드웨어 가속 | AES-NI/PMULL에서 **매우 빠름** | 가속 없이도 **일관되게 빠름** |
| 플랫폼 다양성 | x86/ARM 서버에 최적 | 모바일/임베디드에서 강점 |
| 구현 난이도 | GCM 구현·Nonce 관리 주의 | ARX 구조로 단순(그래도 직접 구현 금지) |
| Nonce 재사용 | **치명적** | **치명적** (동일) |
| 표준 채택 | TLS/SSH/IPsec/… | TLS/SSH/QUIC/… |

**요약**: 가능하면 둘 다 지원하고, **플랫폼에 맞게 자동 선택**하는 것이 이상적.

---

## ✅ 5.8 모드별 요약 & 올바른 선택

- **ECB**: 사용 금지
- **CBC**: 레거시/호환 외 비권장. 꼭 쓰면 **Encrypt-then-MAC**(EtM)로 래핑.
- **CTR**: 빠르고 단순, 하지만 **Nonce/카운터 재사용 금지**. 무결성은 별도 MAC 필요.
- **XTS**: **디스크 암호화 전용**(무결성 X). 전송·메시지 보호에 사용 금지.
- **GCM / ChaCha20-Poly1305**: **기본값**(AEAD). **12바이트 Nonce**(고유), **128비트 태그**.

---

## ✅ 5.9 AEAD 실습: 변조 탐지 시나리오

```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os

key = AESGCM.generate_key(bit_length=128)
gcm = AESGCM(key)
nonce = os.urandom(12)
aad = b"v=1;path=/pay"
pt  = b"amount=1000&to=bob"

ct = gcm.encrypt(nonce, pt, aad)

# 공격자가 암호문을 1바이트 바꿈
tampered = bytearray(ct)
tampered[5] ^= 0x01

try:
    _ = gcm.decrypt(nonce, bytes(tampered), aad)
    print("(!) 변조인데 복호됨? 이러면 안 됩니다")
except Exception as e:
    print("무결성 검출 OK:", type(e).__name__)
```

**포인트**: AEAD는 복호 전에 **태그 검증**을 수행하므로, 변조 시 **즉시 실패**합니다.

---

## ✅ 5.10 Nonce/IV 설계 — 충돌 방지 전략

1) **라이브러리 자동 생성**에 맡기기(가장 안전)
2) 직접 관리가 필요하다면:
   - **96비트 Nonce** = 32비트 **노드/인스턴스 ID** + 64비트 **카운터**  
   - 재시작 시 **카운터 복원**(저장/원자적 증가) 또는 **랜덤 프리픽스 + 카운터**
3) **멀티 프로세스/서버**:
   - 각 인스턴스에 **고유 Prefix** 배정
   - **원자적** 카운터 할당(예: DB 시퀀스/원자 파일/커널 도움)

**안티 패턴**
- 타임스탬프를 **그대로** Nonce로 사용(초 단위 충돌 가능)  
- 프로세스 재시작 시 카운터 **초기화** → 충돌  
- 로그/모니터링에 Nonce **노출**(공격 보조 정보)

---

## ✅ 5.11 CBC vs CTR vs GCM — 실무 시나리오 비교

- **파일 저장(무결성 필요)**: AEAD(GCM/ChaCha20-Poly1305)로 전체 파일에 **단일 Nonce** + 태그. 큰 파일은 **청크 단위** AEAD(각 청크 별도 Nonce) 고려.
- **네트워크 스트림**: TLS 1.3이 기본 제공(AEAD). 직접 모드 선택 **금지**.
- **DB 열/필드 암호화**: AEAD + AAD에 **스키마/버전/PK**를 포함 → 레코드 스와핑·리캐핑 탐지.
- **디스크 전용**: XTS + 별도 무결성 계층(파일 시스템/로그 구조/메타데이터 MAC).

---

## ✅ 5.12 보안 체크리스트

- [ ] **AEAD 기본값**: AES-GCM 또는 ChaCha20-Poly1305  
- [ ] **Nonce 96비트**(권장), **재사용 금지**. 라이브러리에 위임  
- [ ] **AAD 적극 활용**: 암호화하지 않지만 무결성 필요한 메타 포함  
- [ ] **ECB 금지**, **CBC 단독 금지**(EtM 없이는 사용하지 않음)  
- [ ] **XTS는 디스크 전용**(무결성 별도)  
- [ ] **에러 메시지/타이밍 균등화**: 태그 실패 시 동일 반응  
- [ ] **키·Nonce 로깅 금지**, 재부팅/수평확장 시 Nonce 충돌 방지 설계

---

## ✅ 5.13 자주 하는 실수(미스유스)

1) CTR/GCM/ChaCha20에서 **Nonce “거의” 고유**라며 타임스탬프만 사용 → **충돌**  
2) CBC에서 **무결성 없이** 복호 → 패딩/비트플립/삽입 공격  
3) XTS를 네트워크/파일 보호에 사용 → 변조 탐지 불가  
4) AEAD에서 태그 길이를 **무분별 축소**(64비트 이하) → 위조 확률 증가  
5) AAD를 **빠트림** → 헤더/라우팅/메타 변조 통로

---

## ✅ 5.14 요약 카드

- **ECB**: 패턴 노출 → 금지  
- **CBC**: 패딩/오라클 이슈 → EtM or AEAD 없으면 금지  
- **CTR**: 스트림; 빠름; **Nonce 재사용 금지**  
- **GCM**: CTR + GHASH = AEAD (Nonce 96b)  
- **ChaCha20-Poly1305**: 하드웨어 비가속 환경에서도 빠른 AEAD  
- **XTS**: 디스크 전용(무결성 X)  
- **실무 기본**: AEAD + 안전 Nonce + AAD + 균일 에러 처리

---

## ✅ 5.15 연습문제

1) CBC에서 **패딩 오라클**이 가능한 조건을 네 가지 요소(에러 구분, 타이밍, 패딩 규칙, 블록 조작)로 설명하라.  
2) CTR에서 **Nonce/카운터**가 재사용될 때 \(C^A\oplus C^B\)가 어떤 정보를 드러내는지 수식과 예로 설명하라.  
3) GCM에서 **96비트 Nonce**가 권장되는 이유와, 다른 길이의 Nonce가 들어올 때 내부에서 어떻게 처리되는지 요약하라.  
4) XTS가 디스크에 적합한 이유(트윅의 역할)와, 무결성 미제공에 따른 위험을 사례로 서술하라.  
5) AEAD의 **AAD**를 API 설계에서 어떻게 노출/강제할지(예: 필수 필드, 버전, 길이) 설계안을 제안하라.
