---
layout: post
title: Svelte - 데이터베이스 & 풀스택
date: 2025-10-03 21:30:23 +0900
category: Svelte
---
# 데이터베이스 & 풀스택

**Prisma/Drizzle 연동 · 서버 라우트(+server.ts) CRUD · RLS/멀티테넌시 · Supabase/Firebase 연계**

> 이 장은 SvelteKit에서 **데이터 계층을 안전하게 연결**하고, **서버 라우트(+server.ts)**로 CRUD를 완성하는 실전 레퍼런스다.
> - **Prisma**·**Drizzle**로 SQL DB(PostgreSQL 중심) 연동, 마이그레이션, 트랜잭션, 페이징, 낙관적 락
> - **서버 라우트(+server.ts)**에서 **Zod 검증**·오류 처리·권한 체크·캐싱·레이트 리미팅
> - **RLS(Row-Level Security)**로 테넌트 격리, **Supabase**(Postgres+RLS) / **Firebase**(Firestore) 패턴
> - **서버리스 환경**(Vercel/Netlify/Cloudflare) 커넥션 풀, HTTP 드라이버, Accelerate/Neon/PlanetScale 등

---

## 환경 준비 & 선택 가이드

### 어떤 스택을 쓸까?

- **PostgreSQL + Prisma**
  - DX 좋고 타입 안전. **서버리스**면 **Prisma Accelerate** 또는 **HTTP 드라이버** 권장.
- **PostgreSQL + Drizzle ORM**
  - 라이트하고 **SQL 친화적**(스키마가 코드). Edge/서버리스 친화.
- **Supabase**
  - **관리형 Postgres + Auth + 스토리지 + RLS**. 서버리스에 적합.
- **Firebase**
  - **문서형(NoSQL)**. 실시간/모바일에 강점. 간단 CRUD·실시간 동기화 용이.

> **서버리스**에서 전통적 DB 커넥션은 **풀 고갈**로 자주 터진다.
> - Postgres: **Neon/PlanetScale(HTTP)**, **Prisma Accelerate**, **pgBouncer** 등 고려.
> - Edge 런타임(Cloudflare Workers 등)에서는 **HTTP 기반** 클라이언트만 가능.

---

## Prisma로 PostgreSQL 연동

### 설치 & 스키마

```bash
pnpm add -D prisma
pnpm prisma init --datasource-provider postgresql
pnpm add @prisma/client
```

`.env` 예:
```ini
DATABASE_URL="postgresql://app:pass@db.example.com:5432/mydb?sslmode=require"
```

`prisma/schema.prisma`:
```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  plan      String   @default("free")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  todos     Todo[]
}

model Todo {
  id        String   @id @default(cuid())
  userId    String
  title     String
  done      Boolean  @default(false)
  // 낙관적 락
  version   Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, done])
}
```

마이그레이션:
```bash
pnpm prisma migrate dev -n init
```

### 클라이언트 초기화(서버 전용)

```ts
// src/lib/server/prisma.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };
export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query','error','warn'] : ['error']
});
if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

> **주의**: 이 모듈은 **서버 파일**에서만 import. 클라이언트로 절대 번들되지 않게 하자.

### 서버 라우트 CRUD(+server.ts)
#### 라우트 구조

```
src/routes/api/todos/
  +server.ts       # list/create (GET/POST)
  [id]/+server.ts  # get/update/delete (GET/PATCH/DELETE)
```

#### 스키마 검증(Zod)

```ts
// src/lib/validators/todo.ts
import { z } from 'zod';
export const CreateTodo = z.object({
  title: z.string().min(1).max(140)
});
export const UpdateTodo = z.object({
  title: z.string().min(1).max(140).optional(),
  done: z.boolean().optional(),
  version: z.number().int().positive() // 낙관적 락
});
```

#### 목록/생성

```ts
// src/routes/api/todos/+server.ts
import type { RequestHandler } from './$types';
import { prisma } from '$lib/server/prisma';
import { CreateTodo } from '$lib/validators/todo';

export const GET: RequestHandler = async ({ locals, url }) => {
  if (!locals.user) return new Response('Unauthorized', { status: 401 });
  const limit = Math.min(Number(url.searchParams.get('limit') ?? 20), 100);
  const cursor = url.searchParams.get('cursor') ?? undefined;

  const rows = await prisma.todo.findMany({
    where: { userId: locals.user.id },
    take: limit + 1,
    ...(cursor ? { cursor: { id: cursor }, skip: 1 } : {}),
    orderBy: { createdAt: 'desc' }
  });

  const next = rows.length > limit ? rows.pop()!.id : null;
  return new Response(JSON.stringify({ items: rows, next }), {
    headers: { 'content-type': 'application/json', 'cache-control': 'no-store' }
  });
};

export const POST: RequestHandler = async ({ locals, request }) => {
  if (!locals.user) return new Response('Unauthorized', { status: 401 });
  const body = await request.json().catch(() => ({}));
  const parsed = CreateTodo.safeParse(body);
  if (!parsed.success) return new Response(JSON.stringify(parsed.error.flatten()), { status: 400 });

  const item = await prisma.todo.create({
    data: { userId: locals.user.id, title: parsed.data.title }
  });
  return new Response(JSON.stringify(item), { status: 201, headers: { 'content-type': 'application/json' } });
};
```

#### 조회/수정/삭제(+ 낙관적 락)

```ts
// src/routes/api/todos/[id]/+server.ts
import type { RequestHandler } from './$types';
import { prisma } from '$lib/server/prisma';
import { UpdateTodo } from '$lib/validators/todo';

export const GET: RequestHandler = async ({ locals, params }) => {
  if (!locals.user) return new Response('Unauthorized', { status: 401 });
  const row = await prisma.todo.findFirst({ where: { id: params.id, userId: locals.user.id } });
  if (!row) return new Response('Not Found', { status: 404 });
  return new Response(JSON.stringify(row), { headers: { 'content-type': 'application/json' } });
};

export const PATCH: RequestHandler = async ({ locals, params, request }) => {
  if (!locals.user) return new Response('Unauthorized', { status: 401 });
  const body = await request.json().catch(() => ({}));
  const parsed = UpdateTodo.safeParse(body);
  if (!parsed.success) return new Response(JSON.stringify(parsed.error.flatten()), { status: 400 });

  const { version, ...changes } = parsed.data;
  // 낙관적 락: version이 일치할 때만 업데이트
  try {
    const updated = await prisma.todo.update({
      where: { id: params.id, AND: [{ userId: locals.user.id }, { version }] },
      data: { ...changes, version: { increment: 1 } }
    });
    return new Response(JSON.stringify(updated), { headers: { 'content-type': 'application/json' } });
  } catch {
    return new Response('Version conflict', { status: 409 });
  }
};

export const DELETE: RequestHandler = async ({ locals, params }) => {
  if (!locals.user) return new Response('Unauthorized', { status: 401 });
  await prisma.todo.deleteMany({ where: { id: params.id, userId: locals.user.id } });
  return new Response(null, { status: 204 });
};
```

> **보안 포인트**
> - **테넌트 경계**: `where: { userId: locals.user.id }` 필수
> - **입력 검증**: Zod로 **서버에서** 최종 검증
> - **Race 방지**: 낙관적 락(version) 또는 DB level `SELECT … FOR UPDATE`/unique constraints

### 트랜잭션 & 멱등성

```ts
// 임의 예: Todo 생성 + 로그 기록
await prisma.$transaction(async (tx) => {
  const todo = await tx.todo.create({ data: { userId, title } });
  await tx.auditLog.create({
    data: { userId, action: 'todo:create', subjectId: todo.id }
  });
});
```

멱등 키:
```ts
// 키 중복 시 중복 insert 차단
await prisma.todo.create({
  data: { id: idempotencyKey, userId, title },
});
```

### 서버리스 연결 이슈 & 해결

- **Prisma Accelerate** / **Data Proxy** / **HTTP Driver** 사용
- DB 공급자(Neon/PlanetScale/Dragonfly 등)의 **HTTP 엔드포인트** 활용
- Lambda/Functions: **`prisma` 전역 캐싱** + **`prisma.$disconnect()` 금지**(처리 후 종료되며 재사용 필요)

---

## Drizzle ORM으로 PostgreSQL 연동

### 설치 & 스키마(코드 우선)

```bash
pnpm add drizzle-orm drizzle-kit pg
```

`drizzle.config.ts`:
```ts
import type { Config } from 'drizzle-kit';
export default {
  schema: './src/lib/server/db/schema.ts',
  out: './drizzle',
  driver: 'pg'
} satisfies Config;
```

`schema.ts`:
```ts
// src/lib/server/db/schema.ts
import { pgTable, text, boolean, timestamp, varchar, integer } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: varchar('id').primaryKey(),
  email: varchar('email').unique().notNull(),
  name: varchar('name'),
  plan: varchar('plan').notNull().default('free'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull()
});

export const todos = pgTable('todos', {
  id: varchar('id').primaryKey(),
  userId: varchar('user_id').notNull(),
  title: text('title').notNull(),
  done: boolean('done').notNull().default(false),
  version: integer('version').notNull().default(1),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull()
});
```

클라이언트:
```ts
// src/lib/server/db/client.ts
import { drizzle } from 'drizzle-orm/node-postgres';
import pkg from 'pg';
const { Pool } = pkg;

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle(pool);
```

CRUD 예:
```ts
import { db } from './client';
import { todos } from './schema';
import { eq, and } from 'drizzle-orm';

export async function listTodos(userId: string, limit = 20) {
  return db.select().from(todos).where(eq(todos.userId, userId)).limit(limit);
}
export async function updateTodo(userId: string, id: string, data: Partial<{title:string;done:boolean;version:number}>) {
  // 낙관적 락
  const res = await db.update(todos)
    .set({ ...data, version: (data.version ?? 0) + 1 })
    .where(and(eq(todos.id, id), eq(todos.userId, userId), eq(todos.version, data.version!)))
    .returning();
  if (res.length === 0) throw new Error('version_conflict');
  return res[0];
}
```

> Drizzle은 Edge 환경에서도 HTTP 드라이버/Cloudflare D1 등과 조합이 좋다.

---

## 서버 라우트 패턴 정리(+server.ts)

### 표준 응답 규약

- 성공: `200|201` + `content-type: application/json`
- 유효성 오류: `400` + `{ fieldErrors }`
- 인증/인가: `401|403`
- 낙관적 락 충돌: `409`
- 서버 오류: `500` + 로그/추적ID

공통 유틸:
```ts
// src/lib/server/http.ts
export const json = (data: any, init: ResponseInit = {}) =>
  new Response(JSON.stringify(data), { ...init, headers: { 'content-type': 'application/json', ...(init.headers || {}) } });

export const bad = (errors: unknown, code = 400) => json({ errors }, { status: code });
```

### 레이트 리미팅(간단 메모리)

```ts
// src/lib/server/rate.ts
const bucket = new Map<string, { n: number; reset: number }>();
export function hit(key: string, limit = 30, windowMs = 60_000) {
  const now = Date.now();
  const r = bucket.get(key) ?? { n: 0, reset: now + windowMs };
  if (now > r.reset) { r.n = 0; r.reset = now + windowMs; }
  r.n++; bucket.set(key, r);
  return { allowed: r.n <= limit, remaining: Math.max(0, limit - r.n) };
}
```

사용:
```ts
const k = `${locals.user?.id ?? event.getClientAddress()}:todos:create`;
const { allowed } = hit(k, 10, 60_000);
if (!allowed) return new Response('Too Many', { status: 429 });
```

---

## & 멀티테넌시

### RLS 개념

- **DB 레벨**에서 **행 단위** 접근 제어
- 애플리케이션 레이어의 실수(쿼리 where 누락)를 **DB가 차단**
- Postgres는 `ALTER TABLE … ENABLE ROW LEVEL SECURITY` + `POLICY`로 구현

### 예: Postgres RLS 정책

```sql
-- 예시: todos 테이블
ALTER TABLE public.todos ENABLE ROW LEVEL SECURITY;

CREATE POLICY todos_isolation ON public.todos
  USING (user_id = current_setting('app.user_id', true));

-- 요청 시작 시 세션 변수 설정:
-- SET app.user_id = 'user-123';
```

SvelteKit에서 요청마다:
```ts
// 쿼리 전에
await prisma.$executeRawUnsafe(`SELECT set_config('app.user_id', $1, true)`, locals.user!.id);
```

> **주의**: Prisma는 세션 변수 유지가 커넥션에 종속. 서버리스/풀러 간 **연속성** 보장 안 되므로, RLS는 **JWT 기반(예: Supabase)** 방식이 실용적이다.

---

## Supabase 연동(Postgres + Auth + RLS)

### 클라이언트/서버 초기화

```bash
pnpm add @supabase/supabase-js
```

`.env`:
```ini
PUBLIC_SUPABASE_URL="https://xxxx.supabase.co"
SUPABASE_SERVICE_ROLE="eyJhbGciOi..."   # 서버 전용(절대 클라 X)
PUBLIC_SUPABASE_ANON="eyJhbGciOi..."    # 브라우저 anon 키
```

서버 클라이언트:
```ts
// src/lib/server/supabase.ts
import { createClient } from '@supabase/supabase-js';
import { env } from '$env/dynamic/private';

export const supaAdmin = createClient(env.PUBLIC_SUPABASE_URL!, env.SUPABASE_SERVICE_ROLE!, {
  auth: { persistSession: false }
});
```

브라우저/로드에서:
```ts
// src/lib/supabase-browser.ts
import { createClient } from '@supabase/supabase-js';
import { PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON } from '$env/static/public';

export const supa = createClient(PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON, {
  auth: { persistSession: true, autoRefreshToken: true }
});
```

### RLS 정책(테넌트 격리)

`todos(user_id uuid, title text, done bool)` 가정.

정책 예:
```sql
alter table public.todos enable row level security;

create policy "todo_owner_read" on public.todos
for select using (auth.uid() = user_id);

create policy "todo_owner_write" on public.todos
for insert with check (auth.uid() = user_id);

create policy "todo_owner_update" on public.todos
for update using (auth.uid() = user_id) with check (auth.uid() = user_id);

create policy "todo_owner_delete" on public.todos
for delete using (auth.uid() = user_id);
```

> **핵심**: **JWT의 `sub`**(= `auth.uid()`)가 RLS에서 식별자로 사용된다. 브라우저/서버 모두 **사용자 JWT**로 Supabase에 접근하면, DB가 행 필터링을 보장한다.

### 서버 라우트 예(+server.ts)

```ts
// src/routes/api/supa/todos/+server.ts
import type { RequestHandler } from './$types';
import { createClient } from '@supabase/supabase-js';
import { PUBLIC_SUPABASE_URL } from '$env/static/public';

export const GET: RequestHandler = async ({ locals, request }) => {
  if (!locals.user) return new Response('unauthorized', { status: 401 });
  // 사용자 세션의 access_token 필요(로그인 시 세팅했다고 가정)
  const token = locals.session?.access_token;
  const supa = createClient(PUBLIC_SUPABASE_URL, 'anonymous', { global: { headers: { Authorization: `Bearer ${token}` } } });

  const { data, error } = await supa.from('todos').select('*').order('created_at', { ascending:false }).limit(50);
  if (error) return new Response(error.message, { status: 500 });
  return new Response(JSON.stringify({ items: data }), { headers: { 'content-type': 'application/json' } });
};

export const POST: RequestHandler = async ({ locals, request }) => {
  if (!locals.user) return new Response('unauthorized', { status: 401 });
  const token = locals.session?.access_token;
  const supa = createClient(PUBLIC_SUPABASE_URL, 'anonymous', { global: { headers: { Authorization: `Bearer ${token}` } } });

  const body = await request.json().catch(()=>({}));
  const { data, error } = await supa.from('todos').insert({ user_id: locals.user.id, title: body.title ?? '' }).select('*').single();
  if (error) return new Response(error.message, { status: 400 });
  return new Response(JSON.stringify(data), { status: 201, headers: { 'content-type': 'application/json' } });
};
```

> 장점: 서버/클라 모두 **같은 RLS 규칙**. 애플리케이션에서 `user_id` where 누락으로 인한 데이터 누출 위험이 **근본적으로 낮아진다**.

---

## 연동

### 설치 & 초기화

```bash
pnpm add firebase
```

클라이언트:
```ts
// src/lib/firebase.ts
import { initializeApp } from 'firebase/app';
import { getFirestore } from 'firebase/firestore';

const app = initializeApp({
  apiKey: import.meta.env.VITE_FB_API_KEY,
  authDomain: import.meta.env.VITE_FB_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FB_PROJECT_ID
});
export const db = getFirestore(app);
```

### 규칙(Rules)로 RLS 유사 구현

`/todos/{id}` 문서 구조: `{ userId, title, done }`

Firestore Rules:
```c
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /todos/{id} {
      allow read, update, delete: if request.auth != null && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
    }
  }
}
```

### CRUD 예

```ts
import { db } from '$lib/firebase';
import { collection, addDoc, getDocs, query, where, updateDoc, doc, deleteDoc } from 'firebase/firestore';

export async function listTodos(uid: string) {
  const q = query(collection(db, 'todos'), where('userId', '==', uid));
  const snap = await getDocs(q);
  return snap.docs.map(d => ({ id: d.id, ...d.data() }));
}

export async function createTodo(uid: string, title: string) {
  const ref = await addDoc(collection(db, 'todos'), { userId: uid, title, done: false, createdAt: Date.now() });
  return ref.id;
}
```

> **실시간** 필요하면 `onSnapshot`으로 구독. 단, 복잡한 조인/분석은 **Cloud Functions**나 **주기적 동기화**로 처리.

---

## 페이징/정렬/검색 패턴

### 커서 기반 페이징(Prisma)

```ts
const limit = 30;
const rows = await prisma.todo.findMany({
  where: { userId },
  orderBy: { createdAt: 'desc' },
  take: limit + 1,
  ...(cursor ? { cursor: { id: cursor }, skip: 1 } : {})
});
const next = rows.length > limit ? rows.pop()!.id : null;
```

### 텍스트 검색

- Postgres: `to_tsvector` / `tsquery`, **trigram** 인덱스
- Firestore: **전용 검색**(Algolia/Meili) 연계 권장

---

## 캐싱/Invalidation

### HTTP 캐시

- 읽기 API: `cache-control: public, max-age=..., stale-while-revalidate=...`
- 사용자 기반 응답은 쿠키/인증 헤더 → **프라이빗 캐시** 또는 **CDN Key 추가** 필요

### SvelteKit 데이터 캐시 힌트

- 서버 `load`에서 `depends('key')` → 변경 시 `invalidate('key')`로 정밀 무효화
- API 응답에 `ETag`/`Last-Modified`로 **조건부 요청** 지원

간단 ETag:
```ts
import { createHash } from 'node:crypto';
const etagOf = (buf: Buffer|string) => `"${createHash('sha1').update(buf).digest('base64')}"`;
```

---

## 업서트/동시성/락

### 업서트

```ts
await prisma.todo.upsert({
  where: { id },
  create: { id, userId, title },
  update: { title }
});
```

### 비관적 락(예시)

```sql
BEGIN;
SELECT * FROM todos WHERE id = $1 FOR UPDATE;
-- 수정
COMMIT;
```

Prisma는 직접 `FOR UPDATE`를 노출하지 않으므로 쿼리 원문이 필요할 때 `$executeRaw` 사용(신중).

---

## 감사 로깅 & 데이터 마스킹

### 감사 테이블

```prisma
model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  action    String
  subjectId String?
  meta      Json?
  createdAt DateTime @default(now())
}
```

서버 라우트에서:
```ts
await prisma.auditLog.create({ data: { userId: locals.user?.id, action:'todo:update', subjectId:id, meta:{ patch: changes } } });
```

### 마스킹

- 로그에 **PII/비밀** 저장 금지
- 요청 본문에서 `password/access_token` 같은 필드는 **레드액션** 후 기록

---

## 예제: “프로젝트 & 작업” 풀스택

### 스키마(Prisma)

```prisma
model Project {
  id      String  @id @default(cuid())
  ownerId String
  name    String
  tasks   Task[]
  @@index([ownerId])
}

model Task {
  id        String   @id @default(cuid())
  projectId String
  title     String
  status    String   @default("open") // open | doing | done
  assignee  String?
  order     Int      @default(0)
  version   Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
}
```

### 라우트

```
/api/projects            GET/POST
/api/projects/[id]       GET/PATCH/DELETE
/api/projects/[id]/tasks GET/POST
/api/tasks/[id]          PATCH/DELETE
```

#### 생성 시 트랜잭션 + 기본 Task

```ts
// src/routes/api/projects/+server.ts (POST)
import { prisma } from '$lib/server/prisma';
export const POST = async ({ locals, request }) => {
  if (!locals.user) return new Response('401', { status: 401 });
  const { name } = await request.json();
  let created;
  await prisma.$transaction(async (tx) => {
    created = await tx.project.create({ data: { ownerId: locals.user.id, name } });
    await tx.task.create({
      data: { projectId: created.id, title: '첫 작업 만들기', order: 1 }
    });
  });
  return new Response(JSON.stringify(created), { status: 201, headers: { 'content-type': 'application/json' } });
};
```

#### 칸반 재정렬(동시성 고려)

```ts
// src/routes/api/projects/[id]/tasks/+server.ts (PATCH: reorder)
import { prisma } from '$lib/server/prisma';

export const PATCH = async ({ locals, params, request }) => {
  if (!locals.user) return new Response('401', { status: 401 });
  const { items } = await request.json() as { items: { id:string; order:number; version:number }[] };

  await prisma.$transaction(async (tx) => {
    for (const it of items) {
      const res = await tx.task.updateMany({
        where: { id: it.id, version: it.version },
        data: { order: it.order, version: { increment: 1 } }
      });
      if (res.count === 0) throw new Error('version_conflict');
    }
  });

  return new Response('ok');
};
```

---

## Edge/서버리스 배포 팁(데이터 관점)

- **Edge**: Node 모듈 불가 → **HTTP DB** 또는 **Supabase**/**D1**/**KV** 사용
- **Serverless**: 커넥션 폭증 방지 → **프록시/Accelerate**/**pgBouncer**
- **이미지/파일**: **서명 URL**로 직접 업로드(서버 메모리/시간 절약)
- **읽기 캐시**: CDN/Edge Cache + 조건부 요청/서버 캐시
- **장기 실행**(리포트)은 **큐/백엔드 워커**로 오프로딩

---

## 체크리스트(요약)

**연동/마이그레이션**
- [ ] Prisma/Drizzle 스키마 버전 관리(마이그레이션 파일 커밋)
- [ ] 서버와 클라 import 경계(서버 전용 모듈은 클라 금지)
- [ ] 서버리스면 HTTP/Accelerate/풀링 고려

**서버 라우트**
- [ ] Zod 유효성 검증(서버 우선)
- [ ] 테넌트 필터 `where: { userId }` 일관 적용
- [ ] 낙관적 락/버전, 409 처리
- [ ] 로그/감사/레이트 리미팅

**RLS/백엔드**
- [ ] Postgres RLS 또는 Supabase 정책 적용
- [ ] Firebase Rules로 문서 단위 권한 보장
- [ ] 키/토큰/세션 보관은 HttpOnly 쿠키(9장 참조)

**성능/운영**
- [ ] 페이징 커서, 인덱스 최적화
- [ ] 캐시 헤더/ETag/Invalidate
- [ ] 에러 추적(Sentry)·메트릭(Web Vitals/OTel)·구조적 로그

---

## 마무리

- **Prisma/Drizzle**는 타입 안전성과 SQL 제어 사이 스펙트럼을 커버한다.
- **서버 라우트(+server.ts)**는 **검증·권한·오류**를 모아서 구현하는 중심지다.
- **RLS**(특히 Supabase)는 데이터 격리를 **DB가 보증**하도록 하여 안전성을 크게 높인다.
- 배포 환경에 맞춰 **커넥션 전략/캐시/오프로딩**을 선택하면, **빠르고 안전한** 풀스택이 완성된다.
