---
layout: post
title: Java - 사용자 정의 애너테이션
date: 2025-08-09 16:20:23 +0900
category: Java
---
# 사용자 정의 애너테이션 (Custom Annotation)

Java에서는 표준 애너테이션(@Override, @Deprecated 등) 외에도 **개발자가 직접 새로운 애너테이션을 정의**할 수 있다.  
사용자 정의 애너테이션은 **코드에 메타데이터를 추가하여 컴파일러, 런타임, 프레임워크에서 특정 동작을 수행하게 하는 데** 활용된다.

---

## 1. 기본 구조

사용자 정의 애너테이션은 `@interface` 키워드를 사용하여 정의한다.

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)   // 유지 정책: 런타임에도 사용 가능
@Target(ElementType.METHOD)           // 적용 대상: 메서드
public @interface MyAnnotation {
    String value();                    // 필수 요소
    int count() default 1;             // 선택 요소 (기본값 지정 가능)
}
```

### 주요 요소
- `@interface` : 애너테이션 정의 시작.
- **요소(Element)**: 애너테이션 속성. 메서드처럼 정의하며, 매개변수는 없고 반환 타입만 지정.
- **기본값(default)**: 요소의 기본값을 설정할 수 있으며, 생략 시 필수 입력.
- 메타 애너테이션(`@Retention`, `@Target`)으로 애너테이션의 동작을 제어.

---

## 2. 메타 애너테이션 (Meta-Annotations)

사용자 정의 애너테이션을 만들 때 필수적으로 알아야 하는 메타 애너테이션들.

| 메타 애너테이션   | 설명 |
|------------------|------|
| `@Target`        | 애너테이션 적용 대상을 지정 (`TYPE`, `METHOD`, `FIELD`, `PARAMETER`, `CONSTRUCTOR`, `PACKAGE` 등). |
| `@Retention`     | 애너테이션 유지 기간을 지정 (`SOURCE`, `CLASS`, `RUNTIME`). |
| `@Documented`    | Javadoc에 애너테이션 포함 여부. |
| `@Inherited`     | 하위 클래스가 상위 클래스의 애너테이션을 상속받도록 설정. |
| `@Repeatable`    | 동일한 애너테이션을 여러 번 적용할 수 있게 함. |

---

## 3. 예제: 사용자 정의 애너테이션 정의 및 사용

### 3.1 애너테이션 정의
```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnnotation {
    String value();
    int count() default 1;
}
```

### 3.2 애너테이션 사용
```java
public class MyService {

    @MyAnnotation(value = "테스트", count = 3)
    public void doSomething() {
        System.out.println("작업 실행");
    }
}
```

---

## 4. 리플렉션(Reflection)으로 애너테이션 읽기

애너테이션의 가장 큰 장점은 런타임에 리플렉션 API를 통해 읽어서 동작을 제어할 수 있다는 점이다.

```java
import java.lang.reflect.Method;

public class AnnotationReader {
    public static void main(String[] args) throws Exception {
        Method method = MyService.class.getMethod("doSomething");

        // MyAnnotation 정보 가져오기
        MyAnnotation anno = method.getAnnotation(MyAnnotation.class);

        if (anno != null) {
            System.out.println("value: " + anno.value());
            System.out.println("count: " + anno.count());
        }
    }
}
```

**실행 결과**
```
value: 테스트
count: 3
```

---

## 5. 선택 요소 vs 필수 요소

- **필수 요소**: 기본값이 없으므로 반드시 값 지정 필요.
```java
@MyAnnotation("Hello")  // value만 필수
```

- **선택 요소**: `default` 값이 있는 경우, 생략 가능.
```java
@MyAnnotation(value = "Hello")  // count는 기본값 1 사용
```

---

## 6. 고급 기능

### 6.1 @Repeatable
하나의 대상에 동일 애너테이션을 여러 번 적용할 수 있음.
```java
@Repeatable(Tags.class)
public @interface Tag {
    String value();
}

public @interface Tags {
    Tag[] value();
}
```
사용:
```java
@Tag("Java")
@Tag("Annotation")
public class Example {}
```

### 6.2 @Inherited
부모 클래스의 애너테이션을 자식 클래스가 자동 상속.
```java
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Role {
    String value();
}

@Role("Admin")
class Parent {}

class Child extends Parent {} // Child도 Role("Admin")을 가짐
```

---

## 7. 실전 활용 예시

### 7.1 Spring Framework
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogExecutionTime {}
```
→ AOP(관점 지향 프로그래밍)으로 메서드 실행 시간을 로깅하는 기능 구현.

### 7.2 테스트 프레임워크 (JUnit)
- `@Test`, `@BeforeEach`, `@AfterEach` 등 메서드 실행 순서 제어.

---

## 8. 주의 사항
- 런타임 유지(RetentionPolicy.RUNTIME)를 설정하면 성능에 영향을 줄 수 있으므로 필요할 때만 사용.
- 너무 많은 사용자 정의 애너테이션은 코드 복잡도를 높일 수 있음.
- 단순 문서화 목적이면 `RetentionPolicy.SOURCE`를 사용.

---

## 9. 정리
- 사용자 정의 애너테이션은 **코드 메타데이터를 부여**하여 동적 처리와 자동화를 가능하게 함.
- 메타 애너테이션(@Target, @Retention 등) 설정이 핵심.
- 리플렉션과 결합하면 매우 유연한 프로그램 구조 설계 가능.