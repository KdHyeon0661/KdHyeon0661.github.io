---
layout: post
title: Java - 사용자 정의 애너테이션
date: 2025-08-09 16:20:23 +0900
category: Java
---
# 사용자 정의 애너테이션(Custom Annotation)

## 기본 구조와 규칙

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)   // 언제까지 유지? (SOURCE/CLASS/RUNTIME)
@Target(ElementType.METHOD)           // 어디에 붙일 수 있나?
@Documented                           // Javadoc에 표기
public @interface MyAnnotation {
    String value();                   // 필수 요소 (기본값 없음 → 반드시 지정)
    int count() default 1;            // 선택 요소 (기본값 제공)
}
```

### 선언 규칙 (반드시 알아야 할 제약)

사용자 정의 애너테이션의 **요소(속성)**는 아래 **반환 타입만** 가질 수 있다.

| 허용 타입 | 예시 |
|---|---|
| 원시 타입 | `int`, `long`, `double`, `boolean` 등 |
| `String` | `String value();` |
| `Class`/`Class<?>`/`Class<? extends T>` | `Class<?> type();` |
| `enum` | `Level level();` |
| 다른 애너테이션 타입 | `@interface Meta { ... }`, `Meta meta();` |
| 위 타입들의 **배열** | `String[] tags() default {};` |

> **금지**: 제네릭 타입, 임의의 참조 타입(예: `List<String>`), `null` 기본값.
> **기본값**은 **컴파일 타임 상수**만 가능(메서드 호출 결과 불가).

### 특별 규칙: `value()`의 축약 문법

요소 이름이 **`value`** 하나뿐이거나, 다른 요소가 모두 기본값을 가진다면 다음처럼 축약 가능:

```java
@MyAnnotation("hello")           // value="hello"의 축약
@MyAnn2("a")                     // 다른 요소가 기본값이면 value만 축약 허용
@MyAnn3(value="a", count=2)      // value 외 다른 요소 지정 시 풀 표기
```

---

## 메타 애너테이션 요약 (필수 암기)

| 메타 애너테이션 | 핵심 의미 | 대표 값/설정 | 비고 |
|---|---|---|---|
| `@Target` | 부착 가능한 위치 제한 | `TYPE`, `METHOD`, `FIELD`, `PARAMETER`, `CONSTRUCTOR`, `PACKAGE`, `MODULE(9+)`, `TYPE_PARAMETER(8+)`, `TYPE_USE(8+)`, `RECORD_COMPONENT(14+)` | **최소 범위**로 좁혀 오용 방지 |
| `@Retention` | 유지 기간 | `SOURCE`, `CLASS(기본)`, `RUNTIME` | 런타임 읽기면 **RUNTIME** |
| `@Documented` | Javadoc 포함 | (값 없음) | 공개 API용 애너테이션 권장 |
| `@Inherited` | 클래스 상속 시 전파 | (값 없음) | **클래스 수준(TYPE)**에만 효과 |
| `@Repeatable` | 반복 적용 가능 | 컨테이너 애너테이션 지정 | 컨테이너의 Target/Retention은 **원과 동일** |

**권장 규칙**
- 런타임에서 리플렉션으로 읽을 계획이라면 반드시 `@Retention(RUNTIME)`.
- 공개 라이브러리의 API 애너테이션은 `@Documented`.
- `@Target`은 필요한 최소 위치만 허용.

---

## 예제 1 — 정의/사용/리플렉션 읽기

### 정의

```java
import java.lang.annotation.*;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnnotation {
    String value();
    int count() default 1;
}
```

### 사용

```java
public class MyService {

    @MyAnnotation(value = "테스트", count = 3)
    public void doSomething() {
        System.out.println("작업 실행");
    }

    @MyAnnotation("축약표기")  // value만 있을 때 축약 가능
    public void doAnother() {
        System.out.println("또 다른 작업");
    }
}
```

### 리플렉션으로 읽기

```java
import java.lang.reflect.Method;

public class AnnotationReader {
    public static void main(String[] args) throws Exception {
        for (Method m : MyService.class.getDeclaredMethods()) {
            MyAnnotation anno = m.getAnnotation(MyAnnotation.class);
            if (anno != null) {
                System.out.printf("%s -> value=%s, count=%d%n",
                        m.getName(), anno.value(), anno.count());
            }
        }
    }
}
```

---

## 예제 2 — `@Repeatable`과 컨테이너

```java
import java.lang.annotation.*;

@Repeatable(Tags.class)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Tag { String value(); }

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Tags { Tag[] value(); }

// 사용
@Tag("java") @Tag("annotation")
class Article {}

// 조회
class Demo {
    public static void main(String[] args) {
        for (Tag t : Article.class.getAnnotationsByType(Tag.class)) {
            System.out.println(t.value()); // java, annotation
        }
    }
}
```

> **주의**: 컨테이너 `Tags`의 `@Target`/`@Retention`은 반드시 `Tag`와 동일하게 맞춰야 한다.

---

## 예제 3 — `@Inherited` (클래스 수준 전파)

```java
import java.lang.annotation.*;

@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface Role { String value(); }

@Role("Admin")
class Parent {}

class Child extends Parent {}

class CheckInherited {
    public static void main(String[] args) {
        System.out.println(Child.class.isAnnotationPresent(Role.class)); // true
        // getDeclaredAnnotation은 상속분을 반환하지 않음
        System.out.println(Child.class.getDeclaredAnnotation(Role.class)); // null
    }
}
```

> 인터페이스/메서드/필드에는 `@Inherited`가 **작동하지 않는다**.

---

## 실전 패턴 모음 (런타임 스캐닝 & 동작)

### 실행 시간 로깅(AOP 흉내)

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface LogExecutionTime {}

class TimedRunner {
    static Object invoke(Object target, String method) throws Exception {
        var m = target.getClass().getDeclaredMethod(method);
        m.setAccessible(true);
        boolean timed = m.isAnnotationPresent(LogExecutionTime.class);
        long t0 = System.nanoTime();
        try {
            return m.invoke(target);
        } finally {
            if (timed) {
                long dt = System.nanoTime() - t0;
                System.out.printf("[TIMED] %s.%s took %d μs%n",
                        target.getClass().getSimpleName(), method, dt/1000);
            }
        }
    }
}

class Work {
    @LogExecutionTime
    public void job() { /* ... */ }
}

class Demo {
    public static void main(String[] args) throws Exception {
        TimedRunner.invoke(new Work(), "job");
    }
}
```

### 간단한 검증기(필드 값 범위 검사)

```java
import java.lang.annotation.*;
import java.lang.reflect.Field;

@Documented
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@interface Range { int min(); int max(); }

class User {
    @Range(min=1, max=99)
    int age;
    User(int age) { this.age = age; }
}

class Validator {
    static void validate(Object o) throws Exception {
        for (Field f : o.getClass().getDeclaredFields()) {
            Range r = f.getAnnotation(Range.class);
            if (r == null) continue;
            f.setAccessible(true);
            int v = (int) f.get(o);
            if (v < r.min() || v > r.max()) {
                throw new IllegalArgumentException(
                    f.getName() + " out of range: " + v);
            }
        }
    }
}

class Demo2 {
    public static void main(String[] args) throws Exception {
        Validator.validate(new User(10));     // OK
        Validator.validate(new User(120));    // 예외
    }
}
```

### `TYPE_USE`로 정밀 타입 애너테이션 (런타임 체크 예)

```java
import java.lang.annotation.*;
import java.lang.reflect.AnnotatedType;

@Target(ElementType.TYPE_USE)
@Retention(RetentionPolicy.RUNTIME)
@interface NonEmpty {}

class Util {
    static void checkNonEmptyParams(Class<?> c, String method) throws Exception {
        var m = c.getDeclaredMethod(method, String.class, String.class);
        AnnotatedType[] pts = m.getAnnotatedParameterTypes();
        for (int i = 0; i < pts.length; i++) {
            boolean required = pts[i].isAnnotationPresent(NonEmpty.class);
            System.out.printf("param#%d NonEmpty? %s%n", i, required);
        }
    }
}

class Svc {
    String join(@NonEmpty String a, @NonEmpty String b) { return a+b; }
}

class Demo3 {
    public static void main(String[] args) throws Exception {
        Util.checkNonEmptyParams(Svc.class, "join");
    }
}
```

---

## — `@Retention(SOURCE)` 활용

**컴파일 시** 애너테이션을 읽어 **소스/리소스를 생성**하거나 **검증**하는 방식. (Lombok/MapStruct/Dagger 등)

### 애너테이션 & 프로세서 스텁

```java
// 애너테이션: 소스 유지
import java.lang.annotation.*;
@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.TYPE)
public @interface AutoBuilder { String value() default ""; }
```

```java
// 프로세서(간단 스텁)
import javax.annotation.processing.*;
import javax.lang.model.element.*;
import javax.lang.model.SourceVersion;
import java.util.Set;

@SupportedAnnotationTypes("com.example.AutoBuilder")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class AutoBuilderProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
        for (Element e : env.getElementsAnnotatedWith(
                processingEnv.getElementUtils().getTypeElement("com.example.AutoBuilder"))) {
            // e(클래스)의 필드를 스캔하여 빌더 소스 파일 생성하기...
            // processingEnv.getFiler().createSourceFile(...)
        }
        return true; // 우리가 처리함
    }
}
```

### `javac`로 직접 실행

```bash
javac -cp processor.jar \
      -processor com.example.AutoBuilderProcessor \
      -d out $(find src -name "*.java")
```

### Maven/Gradle에서 등록 (개요)

- Maven: `maven-compiler-plugin`의 `annotationProcessorPaths`에 프로세서 추가
- Gradle: `dependencies { annotationProcessor("group:artifact:ver") }`

> **포인트**: 런타임이 아닌 **컴파일 타임**에 작업하므로, **빌드 속도/경계**를 고려해 로직을 설계한다.

---

## 환경 고려 — 리플렉션과 `opens`

**Java 9+ 모듈 시스템**(JPMS)에서는, 비공개 패키지를 리플렉션으로 접근하려면 **모듈이 패키지를 열어야 한다.**

- 빌드 타임: `module-info.java`에서 패키지를 **개방**
  ```java
  module com.example.app {
      requires com.fasterxml.jackson.databind;
      opens com.example.app.model to com.fasterxml.jackson.databind; // 리플렉션 허용
  }
  ```
- 실행 옵션으로:
  ```bash
  java --add-opens com.example.app/com.example.app.model=ALL-UNNAMED ...
  ```

애너테이션 자체는 모듈 경계를 바꾸지 않지만, **애너테이션을 읽기 위해 리플렉션이 필요**한 경우 위 설정이 필수일 수 있다.

---

## 고급 설계 — enum/클래스 요소, 중첩 애너테이션, 기본값 상수화

### enum/클래스 요소

```java
enum Level { INFO, WARN, ERROR }

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface Log {
    Level level() default Level.INFO;
    Class<? extends RuntimeException> onException() default RuntimeException.class;
}
```

### 중첩 애너테이션 요소

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface Owner { String name(); }

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface Service {
    Owner owner();               // 중첩 애너테이션
    String[] tags() default {};  // 배열
}
```

### 기본값은 **컴파일 타임 상수**만 가능

```java
@interface A {
    int CONST = 10;                  // 상수 OK
    int x() default CONST;           // OK
    // int y() default foo();        // 불가 (메서드 호출 결과는 상수 아님)
}
```

---

## 실무 트러블슈팅

| 현상 | 원인 | 해결 |
|---|---|---|
| 런타임에서 애너테이션이 안 보임 | 기본 Retention은 `CLASS` | `@Retention(RUNTIME)` 명시 |
| `@Repeatable`인데 개별 요소가 안 잡힘 | 컨테이너 Retention/Target 불일치 | 컨테이너를 원과 **동일**하게 수정 |
| 상속받은 클래스에서 애너테이션 안 보임 | `@Inherited` 없음 / 멤버 애너테이션 | 클래스 수준에 `@Inherited` 사용, 멤버에는 불가 |
| JPMS 환경에서 `InaccessibleObjectException` | 모듈 캡슐화로 리플렉션 차단 | `opens` 또는 `--add-opens` |
| `value` 축약이 예상과 다르게 동작 | 다른 요소도 값 지정 필요 | 축약은 `value`만 지정 시에만 사용 |
| 요소 타입/기본값에서 컴파일 오류 | 허용 타입/컴파일 상수 제약 위반 | 표(§1.1) 제약 재확인 |

---

## 미니 프레임워크 예시

### `@Retry` — 예외 시 재시도

```java
import java.lang.annotation.*;
import java.lang.reflect.Method;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface Retry {
    int times() default 3;
    long backoffMs() default 100;
    Class<? extends Throwable> on() default Exception.class;
}

class Retrier {
    static Object call(Object target, String method) throws Exception {
        Method m = target.getClass().getDeclaredMethod(method);
        m.setAccessible(true);
        Retry r = m.getAnnotation(Retry.class);
        int times = r != null ? r.times() : 1;
        long wait = r != null ? r.backoffMs() : 0;
        Class<? extends Throwable> on = r != null ? r.on() : Exception.class;

        for (int i = 1; i <= times; i++) {
            try {
                return m.invoke(target);
            } catch (Exception e) {
                Throwable cause = e.getCause() != null ? e.getCause() : e;
                if (!on.isInstance(cause) || i == times) throw (cause instanceof Exception ? (Exception) cause : new Exception(cause));
                Thread.sleep(wait);
            }
        }
        return null; // 도달 불가
    }
}

class Unstable {
    int n = 0;
    @Retry(times=5, backoffMs=50, on=RuntimeException.class)
    public void ping() {
        if ((n++) < 3) throw new RuntimeException("flaky");
        System.out.println("OK at attempt " + n);
    }
}

class DemoRetry {
    public static void main(String[] args) throws Exception {
        Retrier.call(new Unstable(), "ping");
    }
}
```

### `@JsonField` — 필드 이름 매핑(간단 직렬화)

```java
import java.lang.annotation.*;
import java.lang.reflect.Field;
import java.util.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
@interface JsonField { String value(); }

class Json {
    static Map<String, Object> toMap(Object o) throws Exception {
        Map<String, Object> m = new LinkedHashMap<>();
        for (Field f : o.getClass().getDeclaredFields()) {
            f.setAccessible(true);
            JsonField jf = f.getAnnotation(JsonField.class);
            String name = (jf != null) ? jf.value() : f.getName();
            m.put(name, f.get(o));
        }
        return m;
    }
}

class Person {
    @JsonField("full_name") String name;
    @JsonField("years") int age;
    Person(String n, int a) { name=n; age=a; }
}

class DemoJson {
    public static void main(String[] args) throws Exception {
        System.out.println(Json.toMap(new Person("Kim", 28)));
        // {full_name=Kim, years=28}
    }
}
```

---

## 테스트 프레임워크 흉내 — `@Test`, `@BeforeEach`, `@AfterEach`

```java
import java.lang.annotation.*;
import java.lang.reflect.Method;

@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @interface Test {}
@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @interface BeforeEach {}
@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @interface AfterEach {}

class MiniRunner {
    static void run(Class<?> testClass) throws Exception {
        Object inst = testClass.getDeclaredConstructor().newInstance();
        Method[] ms = testClass.getDeclaredMethods();
        for (Method t : ms) {
            if (!t.isAnnotationPresent(Test.class)) continue;
            for (Method b : ms) if (b.isAnnotationPresent(BeforeEach.class)) { b.setAccessible(true); b.invoke(inst); }
            t.setAccessible(true);
            try {
                t.invoke(inst);
                System.out.printf("[PASS] %s%n", t.getName());
            } catch (Exception e) {
                System.out.printf("[FAIL] %s: %s%n", t.getName(), e.getCause());
            }
            for (Method a : ms) if (a.isAnnotationPresent(AfterEach.class)) { a.setAccessible(true); a.invoke(inst); }
        }
    }
}

class MyTests {
    int sum;
    @BeforeEach void setUp(){ sum=0; }
    @AfterEach void tearDown(){ /* cleanup */ }

    @Test void testAdd(){ sum += 2; if (sum != 2) throw new AssertionError(); }
    @Test void testFail(){ throw new RuntimeException("boom"); }
}

class DemoTest {
    public static void main(String[] args) throws Exception {
        MiniRunner.run(MyTests.class);
    }
}
```

---

## 빌드/실행 스니펫

### `javac`/`java`

```bash
# 컴파일

javac -d out src/**/*.java

# 실행

java -cp out DemoRetry
```

### Maven (요지)

- 런타임 스캐닝만 한다면 의존 없음.
- 애너테이션 프로세서는 `maven-compiler-plugin`의 `annotationProcessorPaths`에 추가.

### Gradle (Kotlin DSL 요지)

```kotlin
dependencies {
    // 런타임 스캔만 한다면 필요 없음
    // annotationProcessor("group:processor:ver") // 컴파일 타임 처리 필요 시
}
```

---

## 보안·성능 베스트 프랙티스

- **최소 범위**: `@Target`을 좁혀 잘못된 사용을 컴파일 타임에 차단.
- **Retention 의도**: 런타임 처리 → `RUNTIME`; 문서/스타일 → `SOURCE`.
- **리플렉션 최소화/캐싱**: `Method/Field` 조회는 비용 큼 → 캐시.
- **JPMS 고려**: 리플렉션 대상 패키지는 `opens` 또는 실행 옵션 `--add-opens`.
- **외부 입력 금지**: 사용자 입력으로 클래스/메서드명을 직접 로딩하지 말 것.
- **과도한 애너테이션 남용 금지**: 의미가 겹치는 마커는 통합. 팀 가이드 작성.

---

## 최종 체크리스트

- [ ] 요소 타입 제약 준수(§1.1) — 원시/String/Class/enum/annotation/배열
- [ ] 기본값은 컴파일 상수만 가능 — 메서드 호출 결과 불가
- [ ] `value()` 축약 규칙 이해 — 다른 요소 지정 시 풀 표기
- [ ] 런타임 읽기면 `@Retention(RUNTIME)`
- [ ] 반복 적용은 `@Repeatable` + 컨테이너(Target/Retention 동일)
- [ ] 상속 필요하면 클래스 수준에 `@Inherited`
- [ ] TYPE_USE/TYPE_PARAMETER 활용으로 정밀 타입 제약
- [ ] JPMS 리플렉션은 `opens` 설계 또는 `--add-opens`
- [ ] 리플렉션 결과 캐싱/테스트 포함

---

## 부록 — 빠른 참조 표

### ElementType

| 값 | 의미 |
|---|---|
| `TYPE` | 클래스/인터페이스/enum/record |
| `FIELD` | 필드 |
| `METHOD` | 메서드 |
| `PARAMETER` | 파라미터(선언) |
| `CONSTRUCTOR` | 생성자 |
| `LOCAL_VARIABLE` | 지역 변수 |
| `ANNOTATION_TYPE` | 애너테이션 타입 |
| `PACKAGE` | 패키지(package-info.java) |
| `TYPE_PARAMETER`(8+) | 제네릭 타입 변수 |
| `TYPE_USE`(8+) | 타입 사용 모든 위치 |
| `MODULE`(9+) | 모듈(module-info.java) |
| `RECORD_COMPONENT`(14+) | 레코드 컴포넌트 |

### Retention 선택

| 목적 | 권장 |
|---|---|
| 코드 스타일/컴파일러 힌트 | `SOURCE` |
| 바이트코드 도구/링커 | `CLASS` |
| 런타임 프레임워크 처리 | `RUNTIME` |

---

## 결론

사용자 정의 애너테이션은 **코드의 의도**를 정형화하고, **자동화된 처리**(컴파일/런타임)를 가능케 한다.
성공적인 설계를 위해서는 **요소 타입 제약**, **Target 최소화**, **Retention 의도 일치**, **Repeatable 정합성**, **JPMS 리플렉션 허용**을 정확히 지키고, 리플렉션 비용과 보안 위험을 관리하라.
