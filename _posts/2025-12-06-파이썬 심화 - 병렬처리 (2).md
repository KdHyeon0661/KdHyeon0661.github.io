---
layout: post
title: 파이썬 심화 - 병렬처리 (2)
date: 2025-12-06 16:30:23 +0900
category: 파이썬 심화
---
# 병렬처리 (2)

파이썬의 동시성 프로그래밍은 GIL(Global Interpreter Lock)의 제약에도 불구하고 I/O 바운드 작업과 병렬 처리를 효과적으로 수행할 수 있는 다양한 도구를 제공합니다. 스레드 안전성, 데드락 방지, 효율적인 자원 관리를 위한 심층적인 기법들을 살펴보겠습니다.

## 임계 영역 락과 스레드 동기화

### 다양한 락 메커니즘의 이해와 활용

```python
import threading
import time
import random
from contextlib import contextmanager
from typing import Any, Dict, List
from dataclasses import dataclass
from concurrent.futures import ThreadPoolExecutor
import queue

class ThreadSafeCounter:
    """스레드 안전한 카운터 클래스"""
    
    def __init__(self, initial_value: int = 0):
        self._value = initial_value
        self._lock = threading.Lock()  # 기본 락
        self._condition = threading.Condition(self._lock)  # 조건 변수
        self._readers = 0
        self._writers_waiting = 0
        self._write_lock = threading.Lock()
    
    def increment(self, amount: int = 1) -> int:
        """값 증가 (쓰기 작업)"""
        with self._lock:  # with 문을 사용한 자동 락 관리
            self._value += amount
            result = self._value
            
            # 조건 변수를 통한 신호 전달
            self._condition.notify_all()
            return result
    
    def get_value(self) -> int:
        """값 읽기"""
        with self._lock:
            return self._value
    
    def wait_for_value(self, target_value: int, timeout: float = None) -> bool:
        """특정 값 도달 대기"""
        with self._condition:
            # 조건이 충족될 때까지 대기
            return self._condition.wait_for(
                lambda: self._value >= target_value,
                timeout=timeout
            )
    
    def increment_with_rwlock(self, amount: int = 1) -> int:
        """읽기-쓰기 락을 사용한 증가"""
        # 쓰기 락 획득
        with self._write_lock:
            # 모든 읽기 작업 완료 대기
            while self._readers > 0:
                time.sleep(0.001)
            
            self._value += amount
            return self._value
    
    def get_value_with_rwlock(self) -> int:
        """읽기-쓰기 락을 사용한 값 읽기"""
        with self._write_lock:
            self._readers += 1
        
        try:
            return self._value
        finally:
            with self._write_lock:
                self._readers -= 1

class BankAccount:
    """실제 은행 계좌 시뮬레이션을 통한 락 활용 예제"""
    
    def __init__(self, account_number: str, initial_balance: float = 0):
        self.account_number = account_number
        self._balance = initial_balance
        self._lock = threading.RLock()  # 재진입 가능 락
        self._transaction_log: List[Dict] = []
        self._log_lock = threading.Lock()
    
    def deposit(self, amount: float, description: str = "") -> float:
        """입금"""
        with self._lock:  # RLock은 같은 스레드에서 재진입 가능
            if amount <= 0:
                raise ValueError("입금액은 0보다 커야 합니다")
            
            self._balance += amount
            
            # 트랜잭션 로깅 (중첩된 락)
            with self._log_lock:
                self._transaction_log.append({
                    'timestamp': time.time(),
                    'type': 'deposit',
                    'amount': amount,
                    'description': description,
                    'balance_after': self._balance
                })
            
            return self._balance
    
    def withdraw(self, amount: float, description: str = "") -> float:
        """출금"""
        with self._lock:
            if amount <= 0:
                raise ValueError("출금액은 0보다 커야 합니다")
            
            if self._balance < amount:
                raise ValueError("잔액이 부족합니다")
            
            self._balance -= amount
            
            with self._log_lock:
                self._transaction_log.append({
                    'timestamp': time.time(),
                    'type': 'withdrawal',
                    'amount': amount,
                    'description': description,
                    'balance_after': self._balance
                })
            
            return self._balance
    
    def transfer(self, to_account: 'BankAccount', amount: float, 
                 description: str = "") -> bool:
        """계좌 이체 (데드락 방지 전략 포함)"""
        # 데드락 방지를 위한 순서화: 계좌번호로 정렬
        accounts = sorted([self, to_account], 
                         key=lambda acc: acc.account_number)
        
        # 순서대로 락 획득
        with accounts[0]._lock:
            with accounts[1]._lock:
                if self._balance < amount:
                    return False
                
                self.withdraw(amount, f"이체: {description}")
                to_account.deposit(amount, f"입금: {description}")
                
                return True
    
    def get_balance(self) -> float:
        """잔액 조회"""
        with self._lock:
            return self._balance
    
    def get_transaction_history(self) -> List[Dict]:
        """거래 내역 조회"""
        with self._log_lock:
            return self._transaction_log.copy()

# 락 데모 실행
def demonstrate_locking():
    """락 메커니즘 데모"""
    print("=== 스레드 안전한 카운터 테스트 ===")
    
    counter = ThreadSafeCounter()
    
    def worker(counter_obj, iterations):
        for _ in range(iterations):
            counter_obj.increment(1)
            time.sleep(0.001)
    
    # 여러 스레드에서 동시에 카운터 증가
    threads = []
    for i in range(5):
        thread = threading.Thread(target=worker, args=(counter, 100))
        threads.append(thread)
        thread.start()
    
    for thread in threads:
        thread.join()
    
    print(f"최종 카운터 값: {counter.get_value()}")
    print(f"기대값: 500")
    
    print("\n=== 은행 계좌 동시성 테스트 ===")
    
    account = BankAccount("123-456-789", 1000.0)
    
    def deposit_worker(acc, amount, count):
        for _ in range(count):
            acc.deposit(amount, "정기 입금")
            time.sleep(random.uniform(0.001, 0.01))
    
    def withdraw_worker(acc, amount, count):
        for _ in range(count):
            try:
                acc.withdraw(amount, "정기 출금")
            except ValueError:
                pass  # 잔액 부족 무시
            time.sleep(random.uniform(0.001, 0.01))
    
    # 입금 및 출금 스레드 실행
    deposit_threads = [
        threading.Thread(target=deposit_worker, args=(account, 100, 10))
        for _ in range(3)
    ]
    
    withdraw_threads = [
        threading.Thread(target=withdraw_worker, args=(account, 50, 15))
        for _ in range(3)
    ]
    
    all_threads = deposit_threads + withdraw_threads
    
    for thread in all_threads:
        thread.start()
    
    for thread in all_threads:
        thread.join()
    
    print(f"최종 잔액: {account.get_balance():.2f}")
    print(f"거래 내역 수: {len(account.get_transaction_history())}")

demonstrate_locking()
```

## 락킹으로 데드락 피하기

### 데드락 감지 및 방지 전략

```python
class DeadlockFreeResourceManager:
    """데드락 방지 리소스 관리자"""
    
    def __init__(self):
        self._resources: Dict[str, Any] = {}
        self._locks: Dict[str, threading.Lock] = {}
        self._lock_order: Dict[str, int] = {}  # 락 순서 정의
        self._global_lock = threading.Lock()  # 메타데이터 보호용
        self._thread_locks: Dict[int, List[str]] = {}  # 스레드별 락 획득 추적
    
    def register_resource(self, resource_id: str, resource: Any):
        """리소스 등록"""
        with self._global_lock:
            if resource_id not in self._resources:
                self._resources[resource_id] = resource
                self._locks[resource_id] = threading.Lock()
                self._lock_order[resource_id] = len(self._lock_order)
                print(f"리소스 등록: {resource_id} (순서: {self._lock_order[resource_id]})")
    
    @contextmanager
    def acquire_resources(self, *resource_ids: str):
        """여러 리소스 안전하게 획득"""
        if not resource_ids:
            yield []
            return
        
        # 데드락 방지: 리소스 ID를 락 순서로 정렬
        sorted_resources = sorted(
            resource_ids,
            key=lambda rid: self._lock_order.get(rid, float('inf'))
        )
        
        acquired_locks = []
        current_thread = threading.get_ident()
        
        try:
            # 순서대로 락 획득
            for resource_id in sorted_resources:
                lock = self._locks.get(resource_id)
                if lock:
                    lock.acquire()
                    acquired_locks.append((resource_id, lock))
                    
                    # 락 획득 추적
                    with self._global_lock:
                        if current_thread not in self._thread_locks:
                            self._thread_locks[current_thread] = []
                        self._thread_locks[current_thread].append(resource_id)
                    
                    print(f"스레드 {current_thread}: {resource_id} 락 획득")
            
            # 획득한 리소스 반환
            resources = [self._resources[rid] for rid in resource_ids]
            yield resources
            
        finally:
            # 역순으로 락 해제 (필수는 아니지만 좋은 관행)
            for resource_id, lock in reversed(acquired_locks):
                lock.release()
                
                with self._global_lock:
                    if current_thread in self._thread_locks:
                        if resource_id in self._thread_locks[current_thread]:
                            self._thread_locks[current_thread].remove(resource_id)
                
                print(f"스레드 {current_thread}: {resource_id} 락 해제")
    
    def detect_deadlock(self) -> List[List[int]]:
        """데드락 탐지 (대기 그래프 분석)"""
        with self._global_lock:
            # 대기 그래프 구성
            graph = {}
            
            for thread_id, held_locks in self._thread_locks.items():
                if held_locks:
                    # 이 스레드가 획득한 마지막 락
                    last_lock = held_locks[-1]
                    
                    # 이 락을 기다리는 다른 스레드 찾기
                    for other_thread_id, other_held_locks in self._thread_locks.items():
                        if thread_id != other_thread_id and other_held_locks:
                            # 다른 스레드가 이 락을 다음에 획득하려고 하는지 확인
                            # (간단한 데모: 실제로는 더 복잡한 추적 필요)
                            graph.setdefault(thread_id, []).append(other_thread_id)
            
            # 사이클 탐지 (깊이 우선 탐색)
            def dfs(node, visited, stack, cycle):
                visited.add(node)
                stack.add(node)
                
                for neighbor in graph.get(node, []):
                    if neighbor not in visited:
                        if dfs(neighbor, visited, stack, cycle):
                            cycle.append(neighbor)
                            return True
                    elif neighbor in stack:
                        # 사이클 발견
                        cycle.append(neighbor)
                        return True
                
                stack.remove(node)
                return False
            
            # 모든 사이클 찾기
            cycles = []
            all_nodes = set(graph.keys())
            visited = set()
            
            for node in all_nodes:
                if node not in visited:
                    cycle = []
                    if dfs(node, visited, set(), cycle):
                        if cycle:
                            cycles.append(cycle)
            
            return cycles

class DiningPhilosophers:
    """식사하는 철학자 문제 해결"""
    
    def __init__(self, num_philosophers: int = 5):
        self.num_philosophers = num_philosophers
        self.forks = [threading.Lock() for _ in range(num_philosophers)]
        self.butler = threading.Semaphore(num_philosophers - 1)  # 집사 세마포어
        self.status = ['생각 중'] * num_philosophers
        self.status_lock = threading.Lock()
    
    def philosopher(self, idx: int, meals: int = 3):
        """철학자 행동"""
        left_fork = idx
        right_fork = (idx + 1) % self.num_philosophers
        
        for meal in range(meals):
            # 생각하기
            self._update_status(idx, f"생각 중 (식사 {meal + 1}/{meals})")
            time.sleep(random.uniform(0.1, 0.3))
            
            # 집사의 허가 받기 (데드락 방지)
            self.butler.acquire()
            
            try:
                # 데드락 방지 전략: 마지막 철학자는 순서 변경
                if idx == self.num_philosophers - 1:
                    first, second = right_fork, left_fork
                else:
                    first, second = left_fork, right_fork
                
                # 순서대로 포크 집기
                with self.forks[first]:
                    with self.forks[second]:
                        # 식사하기
                        self._update_status(idx, f"식사 중")
                        time.sleep(random.uniform(0.2, 0.4))
                        
                        # 식사 완료
                        self._update_status(idx, f"식사 완료")
            finally:
                self.butler.release()
            
            # 휴식
            time.sleep(random.uniform(0.05, 0.15))
        
        self._update_status(idx, "만족")
    
    def _update_status(self, idx: int, status: str):
        """상태 업데이트"""
        with self.status_lock:
            self.status[idx] = status
            self.display_table()
    
    def display_table(self):
        """식탁 상태 표시"""
        print("\n" + "=" * 60)
        print("식사하는 철학자들:")
        for i, stat in enumerate(self.status):
            print(f"철학자 {i}: {stat}")
        print("=" * 60)

def demonstrate_deadlock_prevention():
    """데드락 방지 데모"""
    print("\n=== 데드락 방지 리소스 관리자 ===")
    
    manager = DeadlockFreeResourceManager()
    
    # 리소스 등록
    resources = ["A", "B", "C", "D", "E"]
    for res in resources:
        manager.register_resource(res, f"데이터_{res}")
    
    def worker(worker_id, resource_sequence):
        """데드락 가능성이 있는 작업"""
        print(f"작업자 {worker_id}: 리소스 {resource_sequence} 요청")
        
        with manager.acquire_resources(*resource_sequence) as acquired:
            print(f"작업자 {worker_id}: 리소스 획득 완료")
            time.sleep(random.uniform(0.1, 0.3))
            print(f"작업자 {worker_id}: 작업 완료")
    
    # 다양한 순서로 리소스 요청 (데드락 가능성 있음)
    threads = []
    sequences = [
        ("A", "B", "C"),
        ("C", "D", "E"),
        ("B", "C", "D"),
        ("A", "E", "B"),
        ("D", "A", "C")
    ]
    
    for i, seq in enumerate(sequences):
        thread = threading.Thread(target=worker, args=(i, seq))
        threads.append(thread)
        thread.start()
        time.sleep(0.05)  # 시작 간격
    
    for thread in threads:
        thread.join()
    
    print("\n=== 식사하는 철학자 문제 해결 ===")
    
    philosophers = DiningPhilosophers(5)
    philosopher_threads = []
    
    for i in range(5):
        thread = threading.Thread(
            target=philosophers.philosopher,
            args=(i, 2)
        )
        philosopher_threads.append(thread)
        thread.start()
    
    for thread in philosopher_threads:
        thread.join()
    
    print("\n모든 철학자가 식사를 마쳤습니다!")

demonstrate_deadlock_prevention()
```

## 특정 스레드용 상태 저장

### 스레드 로컬 스토리지와 상태 관리

```python
import threading
from typing import Dict, Any, Optional
from contextvars import ContextVar
import uuid

class ThreadLocalContext:
    """고급 스레드 로컬 컨텍스트 관리"""
    
    def __init__(self):
        # 기본 스레드 로컬
        self._local = threading.local()
        
        # 컨텍스트 변수 (Python 3.7+)
        self.request_id_var = ContextVar('request_id', default=None)
        self.user_session_var = ContextVar('user_session', default=None)
        
        # 스레드별 메타데이터 추적
        self._thread_metadata: Dict[int, Dict] = {}
        self._metadata_lock = threading.Lock()
    
    def set_request_id(self, request_id: str):
        """요청 ID 설정"""
        self._local.request_id = request_id
        self.request_id_var.set(request_id)
        
        # 메타데이터에 저장
        thread_id = threading.get_ident()
        with self._metadata_lock:
            if thread_id not in self._thread_metadata:
                self._thread_metadata[thread_id] = {}
            self._thread_metadata[thread_id]['request_id'] = request_id
    
    def get_request_id(self) -> Optional[str]:
        """요청 ID 조회"""
        # 여러 저장소에서 시도
        if hasattr(self._local, 'request_id'):
            return self._local.request_id
        
        return self.request_id_var.get()
    
    def set_user_session(self, user_data: Dict[str, Any]):
        """사용자 세션 설정"""
        self._local.user_session = user_data
        self.user_session_var.set(user_data)
        
        thread_id = threading.get_ident()
        with self._metadata_lock:
            if thread_id not in self._thread_metadata:
                self._thread_metadata[thread_id] = {}
            self._thread_metadata[thread_id]['user_session'] = user_data
    
    def get_user_session(self) -> Optional[Dict[str, Any]]:
        """사용자 세션 조회"""
        if hasattr(self._local, 'user_session'):
            return self._local.user_session
        
        return self.user_session_var.get()
    
    def create_thread_context(self, **kwargs):
        """스레드 컨텍스트 생성"""
        thread_id = threading.get_ident()
        
        with self._metadata_lock:
            self._thread_metadata[thread_id] = {
                'thread_id': thread_id,
                'created_at': time.time(),
                'context_id': str(uuid.uuid4()),
                **kwargs
            }
        
        # 로컬 스토리지에도 저장
        for key, value in kwargs.items():
            setattr(self._local, key, value)
    
    def get_thread_context(self) -> Dict[str, Any]:
        """스레드 컨텍스트 조회"""
        thread_id = threading.get_ident()
        
        with self._metadata_lock:
            return self._thread_metadata.get(thread_id, {}).copy()
    
    def clear_thread_context(self):
        """스레드 컨텍스트 정리"""
        thread_id = threading.get_ident()
        
        with self._metadata_lock:
            if thread_id in self._thread_metadata:
                del self._thread_metadata[thread_id]
        
        # 로컬 스토리지 정리
        for attr in list(self._local.__dict__.keys()):
            delattr(self._local, attr)
        
        # 컨텍스트 변수 정리
        self.request_id_var.set(None)
        self.user_session_var.set(None)

class ThreadAwareTaskProcessor:
    """스레드 인식 태스크 프로세서"""
    
    def __init__(self):
        self.context = ThreadLocalContext()
        self.task_queue = queue.Queue()
        self.results: Dict[str, Any] = {}
        self.results_lock = threading.Lock()
    
    def submit_task(self, task_name: str, task_func, *args, **kwargs) -> str:
        """태스크 제출"""
        task_id = str(uuid.uuid4())
        
        # 현재 컨텍스트 저장
        current_context = self.context.get_thread_context().copy()
        
        # 태스크 큐에 추가
        self.task_queue.put({
            'task_id': task_id,
            'task_name': task_name,
            'task_func': task_func,
            'args': args,
            'kwargs': kwargs,
            'context': current_context
        })
        
        return task_id
    
    def worker_thread(self, worker_id: int):
        """작업자 스레드"""
        print(f"작업자 {worker_id} 시작")
        
        while True:
            try:
                task = self.task_queue.get(timeout=5)
                
                if task is None:  # 종료 신호
                    break
                
                # 태스크 컨텍스트 복원
                self.context.create_thread_context(**task['context'])
                self.context.set_request_id(f"worker_{worker_id}_{task['task_id']}")
                
                print(f"작업자 {worker_id}: {task['task_name']} 시작")
                
                # 태스크 실행
                try:
                    result = task['task_func'](*task['args'], **task['kwargs'])
                    
                    # 결과 저장
                    with self.results_lock:
                        self.results[task['task_id']] = {
                            'status': 'success',
                            'result': result,
                            'worker_id': worker_id,
                            'completed_at': time.time()
                        }
                    
                    print(f"작업자 {worker_id}: {task['task_name']} 완료")
                    
                except Exception as e:
                    with self.results_lock:
                        self.results[task['task_id']] = {
                            'status': 'error',
                            'error': str(e),
                            'worker_id': worker_id,
                            'completed_at': time.time()
                        }
                    
                    print(f"작업자 {worker_id}: {task['task_name']} 실패 - {e}")
                
                finally:
                    # 컨텍스트 정리
                    self.context.clear_thread_context()
                
                self.task_queue.task_done()
                
            except queue.Empty:
                # 작업 큐가 비었을 때
                break
    
    def start_workers(self, num_workers: int = 3):
        """작업자 스레드 시작"""
        self.workers = []
        
        for i in range(num_workers):
            worker = threading.Thread(
                target=self.worker_thread,
                args=(i,),
                daemon=True
            )
            self.workers.append(worker)
            worker.start()
    
    def wait_completion(self, timeout: float = None):
        """모든 작업 완료 대기"""
        self.task_queue.join()
        
        # 작업자 종료 신호
        for _ in range(len(self.workers)):
            self.task_queue.put(None)
        
        for worker in self.workers:
            worker.join(timeout)

def demonstrate_thread_local_storage():
    """스레드 로컬 스토리지 데모"""
    print("\n=== 스레드 로컬 컨텍스트 데모 ===")
    
    context = ThreadLocalContext()
    
    def worker_task(worker_id, user_name):
        # 스레드별 컨텍스트 설정
        context.create_thread_context(
            worker_id=worker_id,
            user_name=user_name,
            start_time=time.time()
        )
        
        # 요청 ID 설정
        context.set_request_id(f"req_{worker_id}_{int(time.time())}")
        
        # 스레드별 작업 수행
        print(f"\n작업자 {worker_id} ({user_name}) 실행 중")
        print(f"요청 ID: {context.get_request_id()}")
        print(f"컨텍스트: {context.get_thread_context()}")
        
        time.sleep(random.uniform(0.1, 0.3))
        
        # 컨텍스트 정리
        context.clear_thread_context()
    
    # 여러 스레드에서 작업 실행
    threads = []
    users = ["Alice", "Bob", "Charlie", "David", "Eve"]
    
    for i, user in enumerate(users):
        thread = threading.Thread(
            target=worker_task,
            args=(i, user)
        )
        threads.append(thread)
        thread.start()
    
    for thread in threads:
        thread.join()
    
    print("\n=== 스레드 인식 태스크 프로세서 데모 ===")
    
    processor = ThreadAwareTaskProcessor()
    
    # 태스크 정의
    def calculate_square(n):
        context = ThreadLocalContext()
        ctx = context.get_thread_context()
        print(f"태스크 실행 (작업자: {ctx.get('worker_id', 'unknown')})")
        return n * n
    
    def process_data(data):
        time.sleep(random.uniform(0.05, 0.15))
        return f"처리된_{data}"
    
    # 작업자 시작
    processor.start_workers(3)
    
    # 여러 태스크 제출
    task_ids = []
    for i in range(10):
        if i % 2 == 0:
            task_id = processor.submit_task(
                "제곱 계산",
                calculate_square,
                i
            )
        else:
            task_id = processor.submit_task(
                "데이터 처리",
                process_data,
                f"데이터_{i}"
            )
        task_ids.append(task_id)
    
    # 완료 대기
    processor.wait_completion()
    
    # 결과 출력
    print("\n태스크 결과:")
    for task_id in task_ids:
        if task_id in processor.results:
            result = processor.results[task_id]
            print(f"{task_id}: {result['status']} (작업자: {result['worker_id']})")

demonstrate_thread_local_storage()
```

## 스레드 풀 생성과 관리

### 고급 스레드 풀 구현

```python
class AdvancedThreadPool:
    """고급 기능을 갖춘 스레드 풀"""
    
    def __init__(self, min_workers: int = 2, max_workers: int = 10,
                 idle_timeout: float = 60.0, queue_size: int = 100):
        self.min_workers = min_workers
        self.max_workers = max_workers
        self.idle_timeout = idle_timeout
        self.queue_size = queue_size
        
        # 작업 큐
        self.task_queue = queue.Queue(maxsize=queue_size)
        
        # 작업자 관리
        self.workers: List[threading.Thread] = []
        self.worker_status: Dict[int, Dict] = {}  # 스레드 ID -> 상태
        self.worker_lock = threading.Lock()
        
        # 통계
        self.stats = {
            'tasks_completed': 0,
            'tasks_failed': 0,
            'tasks_submitted': 0,
            'workers_created': 0,
            'workers_destroyed': 0
        }
        self.stats_lock = threading.Lock()
        
        # 풀 상태
        self.running = False
        self.control_lock = threading.Lock()
        
        # 모니터링 스레드
        self.monitor_thread = None
        
        # 결과 콜백
        self.result_callbacks = []
        self.callback_lock = threading.Lock()
    
    def start(self):
        """스레드 풀 시작"""
        with self.control_lock:
            if self.running:
                return
            
            self.running = True
            
            # 최소 작업자 생성
            for _ in range(self.min_workers):
                self._create_worker()
            
            # 모니터링 스레드 시작
            self.monitor_thread = threading.Thread(
                target=self._monitor_pool,
                daemon=True
            )
            self.monitor_thread.start()
            
            print(f"스레드 풀 시작: {self.min_workers}-{self.max_workers} 작업자")
    
    def submit(self, func, *args, 
               callback=None, error_callback=None, 
               priority: int = 0, **kwargs) -> str:
        """태스크 제출"""
        task_id = str(uuid.uuid4())
        
        task = {
            'id': task_id,
            'func': func,
            'args': args,
            'kwargs': kwargs,
            'callback': callback,
            'error_callback': error_callback,
            'priority': priority,
            'submitted_at': time.time()
        }
        
        # 통계 업데이트
        with self.stats_lock:
            self.stats['tasks_submitted'] += 1
        
        # 작업 큐에 추가
        try:
            self.task_queue.put(task, timeout=5)
        except queue.Full:
            raise RuntimeError("작업 큐가 가득 찼습니다")
        
        # 동적 작업자 확장
        self._adjust_worker_count()
        
        return task_id
    
    def _create_worker(self):
        """새 작업자 생성"""
        worker_id = len(self.workers)
        
        def worker_func():
            thread_id = threading.get_ident()
            
            # 작업자 상태 초기화
            with self.worker_lock:
                self.worker_status[thread_id] = {
                    'id': worker_id,
                    'thread_id': thread_id,
                    'status': 'idle',
                    'last_active': time.time(),
                    'tasks_processed': 0
                }
            
            with self.stats_lock:
                self.stats['workers_created'] += 1
            
            print(f"작업자 {worker_id} 시작")
            
            while self.running:
                try:
                    # 작업 가져오기
                    task = self.task_queue.get(timeout=1)
                    
                    if task is None:  # 종료 신호
                        break
                    
                    # 작업자 상태 업데이트
                    with self.worker_lock:
                        self.worker_status[thread_id].update({
                            'status': 'busy',
                            'current_task': task['id'],
                            'last_active': time.time()
                        })
                    
                    # 작업 실행
                    try:
                        result = task['func'](*task['args'], **task['kwargs'])
                        
                        # 성공 콜백
                        if task['callback']:
                            try:
                                task['callback'](result)
                            except Exception as e:
                                print(f"콜백 실행 에러: {e}")
                        
                        # 통계 업데이트
                        with self.stats_lock:
                            self.stats['tasks_completed'] += 1
                        
                    except Exception as e:
                        # 실패 콜백
                        if task['error_callback']:
                            try:
                                task['error_callback'](e)
                            except Exception as cb_error:
                                print(f"에러 콜백 실행 에러: {cb_error}")
                        
                        with self.stats_lock:
                            self.stats['tasks_failed'] += 1
                        
                        print(f"태스크 {task['id']} 실패: {e}")
                    
                    finally:
                        # 작업자 상태 업데이트
                        with self.worker_lock:
                            status = self.worker_status[thread_id]
                            status.update({
                                'status': 'idle',
                                'tasks_processed': status['tasks_processed'] + 1,
                                'last_active': time.time()
                            })
                    
                    self.task_queue.task_done()
                    
                except queue.Empty:
                    # 작업이 없을 때
                    with self.worker_lock:
                        self.worker_status[thread_id]['last_active'] = time.time()
                    continue
            
            # 작업자 종료
            with self.worker_lock:
                if thread_id in self.worker_status:
                    del self.worker_status[thread_id]
            
            with self.stats_lock:
                self.stats['workers_destroyed'] += 1
            
            print(f"작업자 {worker_id} 종료")
        
        # 작업자 스레드 생성 및 시작
        worker = threading.Thread(target=worker_func, daemon=True)
        self.workers.append(worker)
        worker.start()
    
    def _adjust_worker_count(self):
        """작업자 수 조정"""
        with self.worker_lock:
            current_workers = len(self.worker_status)
        
        # 큐 길이에 따른 확장
        queue_size = self.task_queue.qsize()
        
        if (queue_size > current_workers * 2 and 
            current_workers < self.max_workers):
            # 작업자 추가
            workers_to_add = min(2, self.max_workers - current_workers)
            for _ in range(workers_to_add):
                self._create_worker()
    
    def _monitor_pool(self):
        """풀 모니터링"""
        while self.running:
            time.sleep(10)  # 10초마다 체크
            
            with self.worker_lock:
                current_time = time.time()
                idle_workers = []
                
                # 유휴 작업자 찾기
                for thread_id, status in self.worker_status.items():
                    if (status['status'] == 'idle' and 
                        current_time - status['last_active'] > self.idle_timeout):
                        idle_workers.append((thread_id, status['id']))
                
                # 최소 작업자 수를 유지하며 유휴 작업자 제거
                workers_to_remove = max(
                    0,
                    len(idle_workers) - self.min_workers
                )
                
                for i in range(workers_to_remove):
                    thread_id, worker_id = idle_workers[i]
                    # 종료 신호 전송
                    self.task_queue.put(None)
            
            # 통계 출력
            self._print_stats()
    
    def _print_stats(self):
        """통계 출력"""
        with self.stats_lock:
            stats = self.stats.copy()
        
        with self.worker_lock:
            active_workers = len(self.worker_status)
            busy_workers = sum(
                1 for s in self.worker_status.values() 
                if s['status'] == 'busy'
            )
        
        print(f"\n[풀 통계] 작업자: {active_workers}({busy_workers} 작업중) | "
              f"대기 작업: {self.task_queue.qsize()} | "
              f"완료: {stats['tasks_completed']} | "
              f"실패: {stats['tasks_failed']}")
    
    def shutdown(self, wait: bool = True, timeout: float = 30):
        """풀 종료"""
        with self.control_lock:
            if not self.running:
                return
            
            self.running = False
        
        # 모든 작업자에게 종료 신호
        for _ in range(len(self.workers)):
            self.task_queue.put(None)
        
        if wait:
            # 작업자 종료 대기
            for worker in self.workers:
                worker.join(timeout)
        
        # 모니터링 스레드 종료 대기
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5)
        
        print("\n스레드 풀 종료 완료")
        self._print_stats()

def demonstrate_thread_pool():
    """스레드 풀 데모"""
    print("\n=== 고급 스레드 풀 데모 ===")
    
    pool = AdvancedThreadPool(
        min_workers=2,
        max_workers=5,
        idle_timeout=10.0,
        queue_size=50
    )
    
    # 풀 시작
    pool.start()
    
    # 태스크 정의
    def long_task(task_id, duration):
        print(f"태스크 {task_id} 시작 (소요시간: {duration}s)")
        time.sleep(duration)
        result = f"태스크 {task_id} 완료"
        print(f"태스크 {task_id} 완료")
        return result
    
    def task_with_error(task_id):
        if random.random() < 0.2:  # 20% 실패율
            raise ValueError(f"태스크 {task_id} 의도적 실패")
        return f"태스크 {task_id} 성공"
    
    # 콜백 함수
    def success_callback(result):
        print(f"콜백: {result}")
    
    def error_callback(error):
        print(f"에러 콜백: {error}")
    
    # 여러 태스크 제출
    task_ids = []
    
    for i in range(15):
        if i % 3 == 0:
            # 오래 걸리는 태스크
            task_id = pool.submit(
                long_task,
                f"long_{i}",
                random.uniform(1, 3),
                callback=success_callback,
                error_callback=error_callback
            )
        else:
            # 짧은 태스크 (일부 실패)
            task_id = pool.submit(
                task_with_error,
                f"short_{i}",
                callback=success_callback,
                error_callback=error_callback
            )
        task_ids.append(task_id)
        
        time.sleep(random.uniform(0.05, 0.2))
    
    # 잠시 대기
    print("\n모든 태스크 제출 완료, 대기 중...")
    time.sleep(15)
    
    # 풀 종료
    pool.shutdown(wait=True)

demonstrate_thread_pool()
```

## 간단한 병렬 프로그램 수행

### 실제 응용: 병렬 데이터 처리 파이프라인

```python
class ParallelDataProcessor:
    """병렬 데이터 처리 파이프라인"""
    
    def __init__(self, num_workers: int = 4):
        self.num_workers = num_workers
        self.pool = AdvancedThreadPool(
            min_workers=num_workers,
            max_workers=num_workers * 2
        )
        
        # 데이터 처리 단계 정의
        self.pipeline_stages = []
        self.stage_lock = threading.Lock()
        
        # 결과 저장소
        self.results = {}
        self.result_lock = threading.Lock()
        
        # 메트릭스
        self.metrics = {
            'processed_items': 0,
            'failed_items': 0,
            'total_time': 0
        }
    
    def add_stage(self, stage_name: str, process_func, 
                  max_workers: int = None):
        """처리 단계 추가"""
        with self.stage_lock:
            self.pipeline_stages.append({
                'name': stage_name,
                'func': process_func,
                'max_workers': max_workers or self.num_workers,
                'queue': queue.Queue(),
                'results': {}
            })
    
    def process_data(self, data_items, progress_callback=None):
        """데이터 처리 실행"""
        start_time = time.time()
        
        if not self.pipeline_stages:
            raise ValueError("처리 단계가 정의되지 않았습니다")
        
        # 첫 번째 단계에 데이터 배포
        first_stage = self.pipeline_stages[0]
        for item in data_items:
            first_stage['queue'].put({
                'data': item,
                'stage': 0,
                'item_id': str(uuid.uuid4()),
                'metadata': {}
            })
        
        # 각 단계별 작업자 시작
        stage_workers = []
        for stage_idx, stage in enumerate(self.pipeline_stages):
            for worker_idx in range(stage['max_workers']):
                worker = threading.Thread(
                    target=self._stage_worker,
                    args=(stage_idx, worker_idx, progress_callback),
                    daemon=True
                )
                stage_workers.append(worker)
                worker.start()
        
        # 모든 데이터 처리 완료 대기
        for stage in self.pipeline_stages:
            stage['queue'].join()
        
        # 종료 신호 전송
        for _ in range(len(stage_workers)):
            self.pipeline_stages[-1]['queue'].put(None)
        
        for worker in stage_workers:
            worker.join(timeout=5)
        
        # 메트릭스 계산
        self.metrics['total_time'] = time.time() - start_time
        
        return self._collect_results()
    
    def _stage_worker(self, stage_idx, worker_idx, progress_callback):
        """단계별 작업자"""
        stage = self.pipeline_stages[stage_idx]
        next_stage = None
        
        if stage_idx + 1 < len(self.pipeline_stages):
            next_stage = self.pipeline_stages[stage_idx + 1]
        
        print(f"단계 {stage_idx} 작업자 {worker_idx} 시작: {stage['name']}")
        
        while True:
            try:
                # 작업 가져오기
                task = stage['queue'].get(timeout=1)
                
                if task is None:  # 종료 신호
                    if next_stage:
                        next_stage['queue'].put(None)
                    break
                
                try:
                    # 데이터 처리
                    result = stage['func'](
                        task['data'],
                        **task.get('metadata', {})
                    )
                    
                    # 메트릭스 업데이트
                    with self.result_lock:
                        if stage_idx not in self.results:
                            self.results[stage_idx] = []
                        self.results[stage_idx].append({
                            'item_id': task['item_id'],
                            'result': result,
                            'worker': worker_idx
                        })
                    
                    self.metrics['processed_items'] += 1
                    
                    # 다음 단계로 전달
                    if next_stage:
                        next_stage['queue'].put({
                            'data': result,
                            'stage': stage_idx + 1,
                            'item_id': task['item_id'],
                            'metadata': task.get('metadata', {})
                        })
                    
                    # 진행률 콜백
                    if progress_callback:
                        progress_callback(
                            stage_idx,
                            self.metrics['processed_items'],
                            task['item_id']
                        )
                
                except Exception as e:
                    print(f"처리 실패: {e}")
                    self.metrics['failed_items'] += 1
                
                finally:
                    stage['queue'].task_done()
            
            except queue.Empty:
                continue
    
    def _collect_results(self):
        """결과 수집"""
        final_results = []
        
        if self.pipeline_stages:
            last_stage = self.pipeline_stages[-1]
            if len(self.pipeline_stages) - 1 in self.results:
                for item in self.results[len(self.pipeline_stages) - 1]:
                    final_results.append(item['result'])
        
        return {
            'results': final_results,
            'metrics': self.metrics.copy(),
            'stages_completed': len(self.pipeline_stages)
        }

def demonstrate_parallel_processing():
    """병렬 처리 데모"""
    print("\n=== 병렬 데이터 처리 파이프라인 ===")
    
    # 샘플 데이터 생성
    def generate_data(num_items):
        return [{'id': i, 'value': random.randint(1, 100)} 
                for i in range(num_items)]
    
    # 처리 단계 정의
    def stage1_validation(data_item):
        """1단계: 데이터 검증"""
        time.sleep(random.uniform(0.01, 0.05))
        
        if data_item['value'] <= 0:
            raise ValueError("값이 0 이하입니다")
        
        data_item['validated'] = True
        data_item['validation_time'] = time.time()
        
        return data_item
    
    def stage2_transformation(data_item):
        """2단계: 데이터 변환"""
        time.sleep(random.uniform(0.02, 0.1))
        
        # 간단한 변환
        data_item['transformed_value'] = data_item['value'] * 2
        data_item['transformed_at'] = time.time()
        
        return data_item
    
    def stage3_enrichment(data_item):
        """3단계: 데이터 보강"""
        time.sleep(random.uniform(0.01, 0.03))
        
        # 추가 정보 보강
        data_item['is_even'] = data_item['value'] % 2 == 0
        data_item['category'] = 'high' if data_item['value'] > 50 else 'low'
        data_item['enriched_at'] = time.time()
        
        return data_item
    
    def stage4_aggregation(data_item):
        """4단계: 결과 집계 준비"""
        time.sleep(random.uniform(0.005, 0.02))
        
        # 최종 결과 형식
        result = {
            'original_id': data_item['id'],
            'original_value': data_item['value'],
            'final_value': data_item['transformed_value'],
            'category': data_item['category'],
            'is_even': data_item['is_even'],
            'processing_timeline': {
                'validation': data_item.get('validation_time'),
                'transformation': data_item.get('transformed_at'),
                'enrichment': data_item.get('enriched_at')
            }
        }
        
        return result
    
    # 진행률 콜백
    def progress_callback(stage, processed_count, item_id):
        if processed_count % 10 == 0:
            print(f"진행률: 단계 {stage}, 처리된 항목: {processed_count}")
    
    # 프로세서 생성 및 설정
    processor = ParallelDataProcessor(num_workers=3)
    
    processor.add_stage("검증", stage1_validation, max_workers=2)
    processor.add_stage("변환", stage2_transformation, max_workers=4)
    processor.add_stage("보강", stage3_enrichment, max_workers=3)
    processor.add_stage("집계", stage4_aggregation, max_workers=2)
    
    # 데이터 생성 (100개 항목)
    data = generate_data(100)
    
    print(f"처리 시작: {len(data)}개 항목")
    
    # 처리 실행
    result = processor.process_data(data, progress_callback)
    
    # 결과 출력
    print(f"\n처리 완료!")
    print(f"총 소요시간: {result['metrics']['total_time']:.2f}초")
    print(f"처리된 항목: {result['metrics']['processed_items']}")
    print(f"실패한 항목: {result['metrics']['failed_items']}")
    print(f"완료된 단계: {result['stages_completed']}")
    
    # 샘플 결과 출력
    print("\n처리 결과 샘플 (첫 3개 항목):")
    for i, item in enumerate(result['results'][:3]):
        print(f"{i+1}. {item}")

# 병렬 처리 데모 실행
demonstrate_parallel_processing()
```

## 결론

파이썬 동시성 프로그래밍은 GIL의 제약에도 불구하고 I/O 바운드 작업과 병렬 처리를 효과적으로 수행할 수 있는 강력한 도구들을 제공합니다. 효과적인 동시성 프로그래밍을 위해 다음 원칙을 준수해야 합니다:

1. **적절한 동기화 도구 선택**: 상황에 따라 Lock, RLock, Semaphore, Condition, Event 등을 적절히 선택하고, 읽기-쓰기 패턴에는 RLock이나 reader-writer lock 패턴을 고려합니다.

2. **데드락 방지 전략**: 락 획득 순서를 일관되게 유지하고, 타임아웃 설정, 데드락 감지 메커니즘을 구현하며, 가능한 경우 lock-free 데이터 구조를 활용합니다.

3. **스레드 로컬 상태 관리**: `threading.local`과 `contextvars`를 활용하여 스레드별 상태를 안전하게 관리하고, 컨텍스트 전파를 통해 비동기 코드에서도 상태를 유지합니다.

4. **효율적인 스레드 풀 활용**: 작업 특성에 맞는 스레드 풀 크기 설정, 작업 큐 관리, 동적 확장/축소 메커니즘을 구현하여 자원을 효율적으로 사용합니다.

5. **파이프라인 패턴 적용**: 복잡한 작업은 여러 단계로 나누어 각 단계별로 병렬 처리를 적용하고, 단계 간에는 큐를 통한 데이터 흐름을 구성합니다.

실제 프로덕션 환경에서는 추가적으로 다음 사항들을 고려해야 합니다:
- 비동기 I/O(asyncio)와의 통합 고려
- 분산 처리 시스템(celery, dask 등)으로의 확장성
- 모니터링과 로깅을 통한 성능 추적
- 메모리 사용량과 컨텍스트 스위칭 오버헤드 관리
- 예외 처리와 복원력(resilience) 보장

이러한 모범 사례들을 체계적으로 적용하면 파이썬에서도 효율적이고 안정적인 동시성 프로그래밍이 가능하며, 현대적인 웹 애플리케이션, 데이터 처리 파이프라인, 실시간 시스템 등을 효과적으로 구축할 수 있습니다.