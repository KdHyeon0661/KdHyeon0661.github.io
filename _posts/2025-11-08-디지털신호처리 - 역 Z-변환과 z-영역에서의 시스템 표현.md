---
layout: post
title: 디지털신호처리 - 역 Z-변환과 z-영역에서의 시스템 표현
date: 2025-11-08 23:25:23 +0900
category: 디지털신호처리
---
# 역 Z-변환과 z-영역에서의 시스템 표현

## 맥락과 목표

앞선 글(양측 Z-변환의 정의·성질, DTFT와의 연결, LTI 응답, 샘플링·복원)을 기반으로, 본 글은 **역 Z-변환과 z-영역 시스템 표현**을 실전 관점에서 한데 정리한다. 다음을 모두 다룬다.

- **역 Z-변환 기법 총정리**: 거듭제곱 전개, 부분분수, 다항 나눗셈(장항분해), 잔여정리(컨투어 적분)
- **ROC별 해석**: 우측/좌측/양측에 따라 “같은 유리함수라도 다른 시간영역 신호”가 됨을 명시
- **시스템 표현**: LCCDE → \(H(z)\), 극/영점과 안정·인과, 직렬·병렬·피드백 합성, IIR/FIR 실현 구조, 상태공간
- **GNU Octave 검증**: 각 단계별 **재현 가능한 코드** 제공(수치적 표준 함수 + 직접 구현 루틴)

---

## 역 Z-변환 개요: 정의·ROC·핵심 관찰

### Z-변환과 역변환(양측)

$$
X(z)=\sum_{n=-\infty}^{\infty} x[n]\,z^{-n},\qquad
x[n]=\frac{1}{2\pi j}\oint_{\mathcal{C}} X(z)\,z^{n-1}\,dz.
$$
- \(\mathcal{C}\): **ROC 내부**에 놓인 원형 폐곡선(극을 가로지르지 않게 선택).
- 잔여정리로 \(x[n]\)은 \(X(z)z^{n-1}\)의 **극들의 잔여 합**.

### ROC(Region of Convergence)

- 형태: **원점 중심 환대(annulus)**, **극은 ROC에 포함되지 않음**.
- 우측(right-sided): \(|z|>r_{\max}\) (무한대 포함).
- 좌측(left-sided): \(|z|<r_{\min}\) (원점 포함).
- 양측(two-sided): \(\rho_1<|z|<\rho_2\) (극들 사이 환대).
- DTFT 존재성: **단위원** \(|z|=1\)이 ROC에 포함되어야 \(X(e^{j\omega})\)가 유한.

> **핵심**: 같은 \(X(z)\)라도 **ROC가 달라지면** 역 Z-변환 \(x[n]\)이 달라진다.

---

## 역 Z-변환의 네 가지 주력 기법

### 거듭제곱 전개(power series)

\(|z|>|a|\)이면
$$
\frac{1}{1-a z^{-1}}=\sum_{n=0}^{\infty} a^n z^{-n}\;\Longleftrightarrow\; a^n u[n].
$$
\(|z|<|a|\)이면
$$
\frac{1}{1-a z^{-1}}=-\sum_{n=-\infty}^{-1} a^n z^{-n}\;\Longleftrightarrow\; -a^{n-1}u[-n-1].
$$
> **ROC가 전개 방향을 정한다.**

### 부분분수 분해(partial fraction)

단일극 \(p\):
$$
\frac{1}{1-p z^{-1}}\Longleftrightarrow p^n u[n]\quad(\text{우측 ROC}).
$$
중복극(차수 \(m\)):
$$
\frac{1}{(1-p z^{-1})^m}\Longleftrightarrow \binom{n+m-1}{m-1} p^n u[n].
$$

### 다항 나눗셈(장항분해)

비정상형(분자 차수 ≥ 분모 차수) \(X(z)\)는
$$
X(z)=Q(z)+R(z)\quad(\deg R<\deg \text{분모}),
$$
여기서 **\(Q(z)\)는 델타들의 선형결합**(시프트된 \(\delta[n]\))에 해당.

### 잔여정리(컨투어 적분)

$$
x[n]=\sum_{z_k\in\text{ROC 내부의 극}} \operatorname{Res}\{X(z)\,z^{n-1},z=z_k\}.
$$
- **좌측/양측**과 같이 표준 전개가 번거로울 때 **수치적 역변환**(원주 적분)으로 유용.

---

## “정석 절차” 레시피(시험·실무 공통)

1) **ROC 고정**(문제에서 명시/추론).
2) **비정상형**이면 먼저 **다항 나눗셈**으로 \(\delta\)-항 분리.
3) 남은 proper 유리함수는 **부분분수**(단·중복극/켤레극).
4) **ROC에 맞는 표준쌍**으로 각 항을 좌/우/양측으로 해석.
5) 필요 시 **잔여정리/수치 컨투어**로 교차검증.

---

## 예제로 익히는 역 Z-변환 (ROC별 대비)

### 예제 A — 우측 ROC: 서로 다른 두 단일극

$$
X(z)=\frac{1-0.5 z^{-1}}{(1-0.8 z^{-1})(1-0.3 z^{-1})},\qquad \text{ROC: } |z|>0.8.
$$
부분분수로
$$
X(z)=\frac{A}{1-0.8 z^{-1}}+\frac{B}{1-0.3 z^{-1}}
\;\Rightarrow\;
x[n]=A(0.8)^n u[n]+B(0.3)^n u[n].
$$

```octave
% 예제 A: 우측 ROC 확인 (PF vs impz)
clear; close all; clc; pkg load signal
b = [1 -0.5]; a = conv([1 -0.8], [1 -0.3]);
[r,p,k] = residuez(b, a);    % r_i/(1 - p_i z^-1)
N=48; n=0:N-1;
x_pf = zeros(size(n));
for i=1:numel(p), x_pf += r(i) * (p(i).^n); end
x_imp = impz(b, a, N);       % 우측 ROC 가정 임펄스응답
printf("RMS(PF,impz)=%.2e\n", rms(x_pf - x_imp));
stem(n,x_imp,'filled'); grid on; title('예제 A: x[n] (impz)');
```

---

### 예제 B — 같은 \(X(z)\), **양측 ROC** (\(0.3<|z|<0.8\))

위 \(X(z)\)에서 ROC가 \((0.3,0.8)\)라면
- \((1-0.8 z^{-1})^{-1}\): \(|z|<0.8\)에서 **좌측 전개**
- \((1-0.3 z^{-1})^{-1}\): \(|z|>0.3\)에서 **우측 전개**

따라서
$$
x[n]=A\cdot\big(-0.8^{\,n-1}u[-n-1]\big)+B\cdot\big(0.3^n u[n]\big).
$$

**수치 컨투어(원주 적분)로 ROC 선택 효과 확인**:

```octave
% 수치 역 Z-변환(원주 적분) 유틸 + ROC별 R 선택
function x = iz_numeric_by_contour(Xhandle, nvec, R, K)
  theta = linspace(0, 2*pi, K+1); theta(end)=[];
  z = R*exp(1j*theta);
  dz = 1j*R*exp(1j*theta)*(2*pi/K); % 근사: 등분할
  x = zeros(size(nvec));
  for ii=1:numel(nvec)
    n = nvec(ii);
    integrand = arrayfun(@(zz,dd) Xhandle(zz).* (zz.^(n-1)) .* dd, z, dz);
    x(ii) = (1/(2*pi*1j)) * sum(integrand);
  end
end

% 본문 X(z)
b = [1 -0.5]; a = conv([1 -0.8],[1 -0.3]);

% 함수 핸들 (z^-1 다항식 평가)
Xh = @(z) polyval(b, z.^-1) ./ polyval(a, z.^-1);

n = -30:30;
% ROC(0.3,0.8) 내부 반지름 R 선택: 예) R=0.6
xR = iz_numeric_by_contour(Xh, n, 0.6, 4096);

stem(n, real(xR), '.'); grid on
title('예제 B: 수치 컨투어 역 Z-변환 (R=0.6, ROC=(0.3,0.8))');
```

> R을 0.4(허용)나 0.7(허용)로 바꿔도 같은 결과(수치 오차 범위)여야 한다. R=0.2나 0.9처럼 ROC 밖 반지름을 선택하면 발산/왜곡됨.

---

### 예제 C — **중복극** → 다항×지수

$$
X(z)=\frac{z^{-2}}{(1-0.9 z^{-1})^2},\qquad \text{ROC: }|z|>0.9.
$$
시프트·중복극 공식:
$$
x[n]=(n-1)\,0.9^{\,n-2}u[n-2].
$$

```octave
% 중복극 공식 vs impz
clear; close all; clc; pkg load signal
b=[1 0 0]; a=conv([1 -0.9],[1 -0.9]);
N=56; n=0:N-1;
x_imp = impz(b,a,N);
x_form = zeros(size(n));
idx = find(n>=2);
x_form(idx) = ( (n(idx)-1) .* (0.9.^(n(idx)-2)) );
stem(n, x_imp,'filled'); hold on; stem(n, x_form,'r.'); grid on
legend('impz','formula'); title('예제 C: 중복극 역 Z-변환');
printf("RMS = %.2e\n", rms(x_imp - x_form));
```

---

### 예제 D — **복소 켤레극** → 감쇠 코사인

$$
X(z)=\frac{1}{1-2r\cos\omega_0\,z^{-1}+r^2 z^{-2}},\quad 0<r<1,
$$
$$
x[n]=\frac{\sin((n+1)\omega_0)}{\sin\omega_0}\,r^n\,u[n].
$$

```octave
clear; close all; clc; pkg load signal
r=0.92; w0=0.35*pi;
a=[1 -2*r*cos(w0) r^2]; b=1;
N=90; n=0:N-1; x_imp=impz(b,a,N);
x_form=(sin((n+1)*w0)/sin(w0)).*(r.^n);
stem(n,x_imp,'filled'); hold on; stem(n,x_form,'r.'); grid on
legend('impz','formula'); title('예제 D: 복소 켤레극 역 Z-변환');
printf("RMS = %.2e\n", rms(x_imp - x_form));
```

---

### 예제 E — **좌측 신호**: 원점 포함 ROC

$$
X(z)=\frac{-z}{z-a},\qquad \text{ROC: } |z|<|a|.
$$
전개:
$$
x[n]=-a^{n-1}u[-n-1].
$$

```octave
% 좌측 신호를 수치 컨투어(R<|a|)로 확인
clear; close all; clc
a=0.8;
Xh=@(z) (-z)./(z-a);
n=-40:0;
x = iz_numeric_by_contour(Xh, n, 0.5, 4096); % R=0.5 < |a|
stem(n, real(x),'filled'); grid on
title('예제 E: 좌측 신호 (ROC: |z|<|a|), contour inversion');
```

---

## z-영역 시스템 표현(해석 + 구현)

### LCCDE → \(H(z)\), 주파수응답

선형 상수계수:
$$
\sum_{m=0}^{M} a_m\,y[n-m]=\sum_{k=0}^{K} b_k\,x[n-k]
\;\Rightarrow\;
H(z)=\frac{Y(z)}{X(z)}=\frac{\sum_{k=0}^{K} b_k z^{-k}}{\sum_{m=0}^{M} a_m z^{-m}}.
$$
- 임펄스응답 \(h[n]=\mathcal{Z}^{-1}\{H(z)\}\).
- DTFT: \(H(e^{j\omega})=H(z)|_{z=e^{j\omega}}\).

### 안정·인과·DTFT 존재

- **안정**: ROC가 **단위원** 포함.
- **인과**: ROC가 **무한대** 포함(우측 \(h[n]\)).
- **안정+인과**: 모든 극이 **단위원 내부**.

### 극/영점과 응답

$$
H(z)=g\frac{\prod_i(1-z_i z^{-1})}{\prod_k(1-p_k z^{-1})}.
$$
단위원 근방에서 영점에 가까우면 감쇠, 극에 가까우면 증폭.

---

## 시스템 합성: 직렬·병렬·피드백

- **직렬**: \(H=H_1H_2\) (분자/분모 컨볼루션).
- **병렬**: \(H=\alpha H_1+\beta H_2\) (공통 분모로 정리).
- **피드백(단일)**: \(H=\dfrac{G}{1+GF}\) (부호 관례 주의).

```octave
clear; close all; clc; pkg load signal
[b1,a1]=butter(3,0.4); [b2,a2]=cheby1(3,1,0.3);
% 직렬
bS=conv(b1,b2); aS=conv(a1,a2);
[HS,w]=freqz(bS,aS,4096);
plot(w/pi,20*log10(abs(HS)+1e-12)); grid on; title('직렬 합성 |H|');
```

> 병렬/피드백은 분모 정렬(동치 변환) 정확성이 중요. 실무는 전용 유틸 사용 권장.

---

## 구현(실현) 구조: Direct Form·SOS·FIR·상태공간

### IIR Direct Form I/II

- **DF-I**: 입력측(분자)·출력측(분모) 지연줄기 분리 — 메모리↑, 수치 안정성 양호
- **DF-II**: 두 줄기 합침 — 메모리↓, 고차는 **SOS(2차 섹션)** 분해 권장

```octave
clear; close all; clc; pkg load signal
[b,a]=butter(6,0.45);
[H,w]=freqz(b,a,4096);
subplot(2,1,1); plot(w/pi,20*log10(abs(H)+1e-12)); grid on; title('|H| Butter(6,0.45)');
phi=unwrap(angle(H)); tau=-gradient(phi)./gradient(w);
subplot(2,1,2); plot(w/pi,tau); grid on; title('Group delay');
```

### FIR(선형위상)

대칭/반대칭 계수로 선형위상 구현, 군지연 \((N-1)/2\).

```octave
clear; close all; clc; pkg load signal
N=101; b=fir1(N-1,0.25,hamming(N)); a=1;
[H,w]=freqz(b,a,4096);
phi=unwrap(angle(H)); tau=-gradient(phi)./gradient(w);
subplot(2,1,1); plot(w/pi,20*log10(abs(H)+1e-12)); grid on; title('|H| (FIR)');
subplot(2,1,2); plot(w/pi,tau); grid on; title('Group delay ≈ (N-1)/2');
```

### 상태공간(개요)

$$
H(z)=C(zI-A)^{-1}B+D.
$$
- 제어가능/관측가능 표준형으로 수치 특성 제어.

---

## “역 Z-변환 = 임펄스응답” 빠른 검증 루틴

```octave
% 비정상형 처리 포함: iz via (long division) + impz
function [n, x] = iz_via_impulse(b, a, N)
  % 비정상형이면 deconv로 분리
  [q, r] = deconv(b, a);   % b/a = q + r/a (다항은 z^-1 기준)
  n = 0:N-1;
  x = impz(r, a, N);       % proper 부분
  % q(z^-1) = c0 + c1 z^-1 + ... -> delta열 합산
  M = numel(q)-1;
  for k=0:M
    x = x + q(k+1) * [zeros(1,k), 1, zeros(1, N-k-1)];
  end
end
```

테스트:

```octave
% 예: X(z) = (1 + 0.5 z^-1 + 0.25 z^-2) / (1 - 0.8 z^-1)
clear; close all; clc; pkg load signal
b=[1 0.5 0.25]; a=[1 -0.8];
[n, x] = iz_via_impulse(b,a,40);
stem(n,x,'filled'); grid on; title('iz via impulse (장항분해 포함)');
```

---

## 주파수영역으로 정상상태 응답 예측(검증 루틴)

입력 \(x[n]=\cos(\omega_0 n)\) → 과도 소멸 후
$$
y[n]=|H(e^{j\omega_0})|\cos\big(\omega_0 n + \angle H(e^{j\omega_0})\big).
$$

```octave
clear; close all; clc; pkg load signal
b=[1 -0.5]; a=[1 -0.8 0.15];
w0=0.4*pi; n=0:800; x=cos(w0*n);
y=filter(b,a,x);
H0=freqz(b,a,w0);
A=abs(H0); P=angle(H0);
tail=600:800;
y_pred=A*cos(w0*n(tail) + P);
plot(n(tail), y(tail),'k'); hold on; plot(n(tail), y_pred,'r--'); grid on
legend('sim','theory'); title('정상상태 사인 응답 검증');
```

---

## 특이/경계 케이스 체크리스트

- **비정상형** \(X(z)\): 먼저 **다항 나눗셈**으로 \(\delta\)-항 분리.
- **중복극**: \(n\) 다항 계수가 곱으로 등장 → 수치 오차에 민감(근이 거의겹치면 SOS 권장).
- **단위원 위의 극**: BIBO 안정 아님(출력 무계). 영이 단위원 위면 해당 주파수 완전 소거.
- **좌/우/양측 혼합**: 같은 형식이라도 **ROC가 답을 결정**.
- **수치 검증**: `impz`/`residuez`/`freqz` + **컨투어 수치 역변환**으로 교차확인.

---

## 연습문제(풀이 포함)

### 문제 1 — ROC별 역 Z-변환

\[
X(z)=\frac{1}{1-1.1 z^{-1}}.
\]
1) ROC: \(|z|>1.1\)일 때 \(x[n]\)?
2) ROC: \(|z|<1.1\)일 때 \(x[n]\)?
3) DTFT 존재?

**풀이**
1) \(x[n]=1.1^n u[n]\) (우측). 단위원 밖 극 → BIBO 비안정, DTFT 미존재.
2) \(x[n]=-1.1^{n-1}u[-n-1]\) (좌측).
3) 두 경우 모두 ROC가 단위원을 포함하지 않으므로 DTFT 미존재.

---

### 문제 2 — 중복극

\[
X(z)=\frac{2-0.4 z^{-1}}{(1-0.7 z^{-1})^2}.
\]
부분분수
\[
X(z)=\frac{A}{1-0.7 z^{-1}}+\frac{B}{(1-0.7 z^{-1})^2}
\Rightarrow
x[n]=(A+B(n+1))\,0.7^n u[n].
\]

```octave
b=[2 -0.4]; a=conv([1 -0.7],[1 -0.7]);
[r,p,k]=residuez(b,a), N=64; n=0:N-1;
x=zeros(size(n));
for i=1:numel(p), x+=r(i)*(p(i).^n); end
stem(n,x,'filled'); grid on; title('문제2: 중복극 역 Z-변환');
```

---

### 문제 3 — 양측 ROC

\[
X(z)=\frac{z}{z-0.5}+\frac{1}{1-0.9 z^{-1}},\quad \text{ROC: }0.5<|z|<0.9.
\]
- 첫 항: \(|z|<0.5\) 좌측, \(|z|>0.5\) 우측. ROC상 \(|z|>0.5\) 불가 → **좌측**
  \(\Rightarrow -0.5^{\,n-1}u[-n-1]\).
- 둘째 항: \(|z|<0.9\)에서는 **우측 불가**, 좌측 전개로
  \(-0.9^{\,n-1}u[-n-1]\).
- 합:
\[
x[n]=-0.5^{\,n-1}u[-n-1]-0.9^{\,n-1}u[-n-1].
\]

---

### 문제 4 — LCCDE 안정성

\[
y[n]-0.2 y[n-1]-0.16 y[n-2]=x[n].
\]
\[
H(z)=\frac{1}{1-0.2 z^{-1}-0.16 z^{-2}},\quad
z_{1,2}=\frac{0.2\pm\sqrt{0.68}}{2}.
\]
\(|z_{1,2}|<1\)이면 안정.

```octave
b=1; a=[1 -0.2 -0.16];
p=roots(fliplr(a));
printf("poles="); disp(p.'); printf("max |p|=%.3f\n", max(abs(p)));
```

---

## 핵심 요약(실무 포인트)

1) **ROC가 해를 결정**: 같은 \(X(z)\)라도 ROC가 다르면 다른 \(x[n]\).
2) **비정상형**은 먼저 **다항 나눗셈**으로 \(\delta\)-항 분리.
3) **부분분수** + **중복극 공식**(다항×지수) 숙지.
4) **좌·우·양측** 판단 후 해당 표준쌍으로 해석.
5) **컨투어 수치 역변환**으로 ROC별 결과를 직접 검증(우수한 디버깅 수단).
6) 시스템은 \(H(z)=B(z)/A(z)\). **안정=단위원 포함**, **인과=무한대 포함**.
7) 고차 IIR은 **SOS** 권장, FIR은 **선형위상** 설계 용이.
8) `impz`/`residuez`/`freqz`/컨투어 적분을 **교차검증** 루틴으로 습관화.

---

## 결론

역 Z-변환은 **형식(유리함수 구조)**과 **기하(ROC)**의 결합으로 **유일한 시간영역 신호**를 지정한다.
문제/설계 모두에서 **ROC를 먼저 고정**하고, **다항 나눗셈→부분분수→ROC맞춤 전개**의 정석 절차를 따르면 실수가 줄어든다.
시스템 해석은 \(H(z)\) 하나로 **안정/인과/주파수응답/구현 구조**까지 포괄한다. 본문의 **Octave 루틴**으로 모든 단계를 수치적으로 재현·검증하여, 설계→해석→검증의 **닫힌 고리**를 완성하라.
