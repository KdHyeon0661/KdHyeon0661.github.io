---
layout: post
title: 암호학 - 영지식증명 & 프라이버시 기술
date: 2025-10-13 23:30:23 +0900
category: 암호학
---
# 영지식증명 & 프라이버시 기술

> 이 장은 **Σ-프로토콜 직관** → **zk-SNARK/STARK 비교** → **산술화(범용 회로·R1CS vs PLONK-ish “플롱크/플랭크” 회로·AIR)** → **트러스트 셋업/투명성** → **응용(익명 인증·프라이버시 결제·익명 투표)** 순서로 정리합니다.
> 모든 코드는 **교육용 의사코드**이며, 실제 배포는 **표준 라이브러리/감사된 회로**를 사용하세요.

---

## 15.1 영지식의 핵심: “참을 설득하되, 비밀은 새지 않는다”

### 문제 설정

- 검증자 \(V\)는 **어떤 명제 \(\mathcal{R}(x,w)\)** 가 참인지 알고 싶다.
  - \(x\): 공개 입력(Statement)
  - \(w\): 비밀 증인(Witness), 예: “해시 \(x\)의 프리이미지 \(w\)를 안다”
- **정당성(Soundness)**: 거짓이면 들키게.
- **완전성(Completeness)**: 진실이면 통과.
- **영지식성(Zero-Knowledge)**: \(V\)는 “참”이라는 사실 외엔 \(w\)에 대한 **추가 정보**를 얻지 못함.

### 직관

3단계 상호작용형 프로토콜(Commit–Challenge–Response):

1) **커밋** \(a\): 증명자 \(P\)가 임의성 \(r\)로 “약속” \(a\)를 보냄
2) **도전** \(e\): 검증자 \(V\)가 무작위 챌린지 \(e\) 제시
3) **응답** \(z\): \(P\)가 \(z = f(w,r,e)\) 응답
검증자 \(V\)는 \((a,e,z)\)가 **검증 식**을 만족하는지 확인.

- **예: Schnorr Σ(이산로그)**
  - 공개: 군 \(G\), 생성원 \(g\), \(x = g^w\)
  - 커밋: \(a = g^r\)
  - 도전: \(e \xleftarrow{\$} \{0,1\}^\kappa\)
  - 응답: \(z = r + e\cdot w\)
  - 검증: \(g^z \stackrel{?}{=} a \cdot x^e\)

**특성**
- **HVZK(정직한 검증자 영지식)**: \(V\)가 챌린지를 무작위로 준다고 가정하면, 시뮬레이터가 \((a,e,z)\)를 “진짜처럼” 합성 가능.
- **특수 사운드니스**: 서로 다른 챌린지 \(e \neq e'\)에 대한 두 대화 \((a,e,z),(a,e',z')\)에서 \(w\)를 **추출** 가능.

### 비상호작용화: Fiat–Shamir(해시로 챌린지)

- \(e = H(\text{Transcript})\) 로 대체하여 **NIZK**(Non-Interactive)로 변환.
- 모델: **ROM(랜덤 오라클)** 또는 **\( \mathrm{Fiat\text{-}Shamir} \)** 의 표준-모델 변형(메르클라이즈드 transcript, Updatable CRS 등).
- **주의**: 해시 **도메인 분리**(label, protocol ID)를 명확히.

### 조합기술

- **AND/OR 증명**: 둘 다 참(AND) 또는 둘 중 하나가 참(OR)을 영지식으로.
- **지식 이전 없음**: OR-proof에서 어떤 분기가 참인지 검증자는 모름.
- **범위 증명**: \(x \in [0,2^k)\) 같은 명제를 **비트 Decomposition** 또는 **Lookup**(아래 §15.4.3)으로.

---

## 15.2 SNARK vs STARK — 큰 비교

| 항목 | **zk-SNARK** (예: Groth16, PLONK, Marlin, Halo2) | **zk-STARK** (FRI/AIR/IOP) |
|---|---|---|
| **증명 크기** | 매우 작음(수십~수백 바이트–킬로바이트) | 수십~수백 KB(작업 크기에 비례) |
| **검증 시간** | 매우 빠름(수 ms~수십 ms; 페어링/IPA) | 빠름(수-수십 ms; 해시/FRI), 약간 더 큼 |
| **프루버 시간/메모리** | 빠르나 회로·도메인 의존(FFT/KZG/IPA) | 대규모 추적(AIR)→증명 시간이 길 수 있음 |
| **신뢰 설정(CRS)** | 필요: **per-circuit**(Groth16) 또는 **universal/updatable**(PLONK/Marlin, KZG) | **불필요(투명)** |
| **암호 가정** | 주로 **KZG(쌍선형) 또는 IPA** + Fiat–Shamir | **해시/FRI**(투명, PQ-우호적) |
| **양자 내성** | KZG/페어링 가정은 양자 취약 가능성 | 해시 기반이라 **상대적 우호** |
| **산술화** | **R1CS** 또는 **PLONK-ish**(멀티폴리 가문, 퍼뮤테이션·루ック업) | **AIR**(상태 기계 전개) |
| **생태/도구** | circom/snarkjs, Halo2, Plonky2, gnark, arkworks… | Cairo/StarkNet, Winterfell, plonky-stark hybrids… |

> **요지**: **SNARK**는 **작고 빠른 검증** + (대개) **셋업 필요**, **STARK**는 **투명성·양자 우호** + **증명 크기 큼**.
> 실제 프로젝트는 **성능/투명성/하드웨어/에코시스템**을 고려해 선택 또는 **하이브리드**.

---

## 15.3 산술화(Arithmetization): “문제를 다항식 제약으로”

### 범용 회로 vs 문제-특화 산술화

- **범용 회로(Universal Circuit)**: 임의의 계산을 담는 큰 회로(프로그램/VM을 “해석”하는 회로). **유연**하나 **비용↑**.
- **문제-특화 회로**: 특정 애플리케이션(예: 머클 경로 검증, 서명 검증)에 맞춘 맞춤 회로. **빠름**.

### R1CS (Rank-1 Constraint System)

- 제약: \((\mathbf{A}\mathbf{z}) \circ (\mathbf{B}\mathbf{z}) = (\mathbf{C}\mathbf{z})\)
- 각 게이트(곱셈/덧셈/상수)를 선형 결합으로 표현 → 행렬 형태로 대규모로 적재.
- Groth16/Marlin/ark-plonkish 등 많은 툴이 **R1CS 또는 관련 폼**을 지원.

### & Lookup

- **PLONK 계열**: 단일/다중 다항식에 대해 **퍼뮤테이션 검증**(같은 테이블의 재배열), **게이트 시스템**으로 유연성↑.
- **Lookup(PLookup/LogUp/Scroll-lookup 등)**: “이 값이 **허용 테이블**에 존재함”을 효율적으로 증명 → **범위 체크·S-Box·SHA 라운드 상수** 등에 유리.
- **Custom Gate**: 예를 들어 \(a \cdot b + c \cdot d = e\) 를 한 번에.

### AIR (Algebraic Intermediate Representation, STARK)

- 계산을 **시간축(스텝)** 의 **상태 머신**으로 전개, **전이 제약**과 **경계 조건**으로 서술.
- 예: 레지스터 \(r_1,\dots,r_k\) 가 스텝마다 \(\mathsf{Trans}(r(t)) \to r(t{+}1)\) 를 만족.
- **FRI** 로 “긴 다항식이 저차다”를 검증 → 큰 추적에도 **투명/확장성**.

---

## 15.4 트러스트 셋업 & 커밋먼트

### CRS/셋업의 의미

- **CRS(Common Reference String)**: 증명 시스템에서 공유하는 매개(다항식 커밋 키 등).
- **신뢰 설정의 위험**: “toxic waste”(셋업 랜덤니스)가 유출되면 **위조 가능**.
- **모델**
  - **Per-circuit**: 회로마다 별도 셋업(Groth16).
  - **Universal/Updatable**: 한번(또는 업데이트 가능) 셋업으로 여러 회로(PLONK/Marlin).
  - **Transparent**: 셋업 불필요(STARK/FRI/Hash-IOP, IPA-based SNARK 일부).

### 다항식 커밋

- **KZG**(쌍선형, 매우 짧은 증명, 일점 평가 O(1), 셋업 필요).
- **IPA**(내적 인수분해; Bulletproofs-style, 셋업 불필요, 증명 O(log n)).
- **FRI**(저차성 테스트; 해시 기반, 투명, 증명 큼).

### 룩업/범위체크 두 가지 길

- **R1CS 비트분해**: \(x = \sum 2^i b_i\), \(b_i \in \{0,1\}\) → 제약 수↑.
- **Lookup 테이블**: 미리 0..255 테이블 준비, \(x \in T\) 증명 → 빠른 **range check**.

---

## 15.5 기본 예제: Schnorr Σ에서 서명, OR-proof, 범위증명 스케치

### Schnorr 서명 = Σ + Fiat–Shamir

```text
sk = w, pk = x = g^w
sign(m):
  r <-$ Z_q; a = g^r
  e = H( a || g || x || m )         # FS 챌린지(도메인 분리!)
  z = r + e*w mod q
  σ = (a, z)
verify(pk, m, σ=(a,z)):
  e = H( a || g || pk || m )
  check g^z == a * pk^e
```
- **주의**: `r` 재사용 금지(반복되면 \(w\) 누설).

### OR-proof(둘 중 하나의 비밀을 안다)

- 두 분기 중 **거짓 분기는 시뮬레이션**으로, **참 분기만 실제 응답**.
- 검증자는 어떤 분기가 참인지 모름(영지식).
- 링 서명, 익명 인증의 기본 재료.

### 범위 증명(개념)

- **목표**: \(v \in [0,2^k)\) 과 **커밋 \(C = g^v h^r\)** 가 일치함을 증명.
- **방법 A(비트 분해)**: \(v=\sum 2^i b_i\), 각 \(b_i \in \{0,1\}\)을 ZK로 증명.
- **방법 B(lookup)**: 바이트 단위 \(v_j \in [0,255]\) 를 테이블에 대한 ZK-lookup으로 증명.

---

## 15.6 프라이버시 결제의 구성요소(예: Zcash 스타일)

> **법·정책을 준수한 합법적 프라이버시**만 고려합니다. 불법 행위를 조장/지원하지 않습니다.

### 재료

- **커밋먼트**: \(\mathsf{Com}(m;r)\) — 내용 \(m\) 존재를 감추고 스냅샷에 바인딩(페더슨 커밋 등).
- **널리파이어(nullifier)**: 이미 쓴 노트(코인)를 **중복 사용(더블스펜드) 불가**로 만드는 익명 토큰.
- **머클 증명**: “내 커밋이 글로벌 트리에 들어 있다”를 ZK로 증명.
- **밸런스 제약**: 입력 합 = 출력 합(수수료 포함)을 ZK로 증명.

### 동작 개요

1) 송신자는 과거 받은 노트들의 커밋이 **머클 루트**에 포함됨을 증명.
2) 각 입력 노트마다 **nullifier**를 출력(중복 사용 방지), 누구의 노트인지는 은닉.
3) 출력 노트의 새 커밋 생성(수신자 키에 바인딩).
4) 전체 제약(밸런스, 범위, 키 소유)을 **하나의 ZK 회로**로 증명 ⇒ 체인에 게재.
5) 검증자는 **루트/널리파이어 중복/증명 검증**만으로 유효성 판단(금액·참가자 은닉).

### 설계 주의

- **커밋/널리파이어 해시 함수 선택**(Poseidon/Rescue 등 **회로 친화**)
- **도메인 분리**: 동일 해시를 커밋/머클/널리파이어에 **재사용 금지**
- **랜덤니스**: 커밋 blinding, 서명 nonce 안전 생성
- **감사/시뮬레이션 키**: 셋업/파라미터 운영(§15.4)

---

## 15.7 익명 인증: 그룹/링/자격증명(ZK-Cred)

### 링 서명

- **Statement**: “이 링 \(\{pk_1,\dots,pk_n\}\) 중 **누군가**다.”
- **영지식**: 누군지 **정확히 모르게** 하되, **한 번의 행위**라는 것(링 크기 \(n\) 기여)만 공개.
- **링 크기/링 업데이트 비용** 고려 필요.

### 그룹 서명

- **그룹 매니저**가 발급/탈퇴 관리, 필요 시 **오프닝**(회원 신원 복원).
- 기업/조직 익명 게시/리포팅 등.

### 자격증명

- **BBS+, CL, zk-SNARK 기반 VC**: 소유자는 속성(나이≥18, 소속=OO 등)의 **일부만 영지식 공개**.
- **시나리오**: “직원증 있음 + 유효기간 내 + 최소권한”을 사이트에 **익명 증명**.
- **레이트-리밋/더블유즈 방지**: **널리파이어/링크 태그**로 동일 자격의 다중 사용 감지(개인식별 없이).

---

## 설계 스케치

### 요구사항

- **비밀 투표**(누가 어떤 선택을 했는지 은닉),
- **무결성**(1인 1표), **검증 가능성**(누구나 전체 합산 검증),
- **감사 가능성**(자기 표가 포함되었는지).

### 두 가지 큰 계열

1) **혼합망(Mixnet)**: 암호문들을 랜덤 셔플+재암호화, **ZK로 정당성**(셔플/재암호화 정합) 증명.
2) **동형합산**: ElGamal/Paillier 등으로 **암호문 합산**, 최종 합만 복호.
   - 각 표가 **유효한 도메인**(예: \(\{0,1\}\))임을 **ZK 범위증명**으로 보장.
   - **2표 금지**: 등록/자격증명 단계에서 **단일성 증명** 또는 **널리파이어** 사용.

### 실무 포인트

- **키 관리**(위원회 분산 복호/멀티파티),
- **감사 로그**(영지식 증명/셔플 증명 아카이브),
- **익명성-무결성 균형**(소수 표본 deanonymization 방지).

---

## 15.9 회로 설계 실수와 방어

1) **제약 누락**: 범위 체크/캐리 제약/부호 제약 빠뜨려 **음수/오버플로 악용**
   - **대응**: 표준 **범위 위젯(lookup)**, 포괄적 **테스트/퍼지**
2) **해시 재사용/도메인 미분리** → **커밋=널리파이어** 혼동
   - **대응**: 모든 해시 입력에 **prefix/tag** 부여
3) **RNG/Nonce 재사용**(Schnorr류) → 비밀 누설
   - **대응**: OS CSPRNG, DRBG, **deterministic nonce**(RFC 6979-류)
4) **FS 전환 실수**: transcript 누락/순서 바뀜
   - **대응**: **canonical transcript** 구조 + 테스트
5) **셋업 관리 부실**: toxic-waste 유출, 전자서명 없는 파라미터 배포
   - **대응**: **업데이트 가능 셋업**·MPC·감사 로그·해시 고정
6) **증명/검증 버전 불일치**: 회로 해시(아트팩트) 불일치
   - **대응**: **circuit hash**/constraint count를 메타데이터로 고정

---

## 15.10 성능 감각 & 선택 가이드(요지)

- **온체인 검증 비용**: SNARK(KZG)는 **짧은 증명 + 빠른 검증**, STARK는 **증명 큼**(가스↑) → **롤업/데이터 가용성과 동반 고려**.
- **프루버 리소스**: STARK는 **해시/FRI**로 병렬화 우수, SNARK(KZG)는 **FFT/멀티스칼라곱** 최적화 필요(GPU/ASIC).
- **양자 모델**: 강한 요구면 **투명/해시 기반** 선호(STARK/IPA-SNARK).
- **유연성**: **PLONK-ish + lookup + custom gate** 조합은 “실무 회로 엔지니어링”에 매우 편리.

---

## 15.11 미니 의사코드: 머클 포함 증명 회로 스케치

> 목표: “리프 값 \(m\)의 커밋 \(C\)가 주어진 머클 루트 \(R\)에 포함” + “\(m\)이 범위 내”를 ZK로 증명.

```text
Public: R (Merkle root), C (commitment)
Secret: m (value), r (blinding), path = [(sib_i, dir_i)] for i=0..d-1

Constraints:
1) Commit check:   C == Pedersen(m, r)
2) Range check:    m ∈ [0, 2^64)          # lookup or bit-decomp
3) Merkle path:
   h0 = HashLeaf(C)
   For i in 0..d-1:
      if dir_i == 0: h_{i+1} = HashNode(h_i, sib_i)
      else          h_{i+1} = HashNode(sib_i, h_i)
   Enforce h_d == R
```

- 회로-친화 해시(Poseidon/Rescue/Anemoi 등) 사용.
- `dir_i`는 boolean 제약, lookup으로 강제.

---

## 15.12 프라이버시 시스템 운영 체크리스트

- **셋업/파라미터**
  - [ ] CRS/회로 해시 공개, MPC 로그·참가자 서명 보관
  - [ ] Updatable ceremony 선호, 파라미터 **버전 고정**
- **회로/증명**
  - [ ] 범위·균형·캐리·서명 검증 포함
  - [ ] 해시 **도메인 분리**, nonce/RNG 정책 문서화
  - [ ] 증명 실패/성공 **오류 메시지 균일화**(오라클 방지)
- **보안/프라이버시**
  - [ ] 로그/메타데이터 최소화(시간·크기·패턴로 deanonymization 주의)
  - [ ] 합법 준수(보존·보고·제재 목록 필터 등)
- **성능/운영**
  - [ ] 프로버 메모리/시간 모니터링, GPU/멀티스레드/배치
  - [ ] 온체인 검증 가스/데이터 가용성(DA) 예산
  - [ ] 회로/증명 **CI 재현**: constraint count, hash, proving key checksum

---

## 15.13 용어 빠른 지도

- **Σ-프로토콜**: 3-move 대화형 ZK, HVZK + 특수 사운드니스
- **NIZK**: 비상호작용 영지식(대개 Fiat–Shamir)
- **SNARK**: Succinct(짧은) + Non-interactive + ARgument of Knowledge
- **STARK**: Scalable + Transparent + ARgument of Knowledge
- **R1CS/PLONK-ish/AIR**: 산술화 패밀리
- **KZG/IPA/FRI**: 다항식 커밋·저차성 증명
- **CRS/셋업**: 공통참조문자열/신뢰설정, updatable/transparent
- **Lookup**: 값이 테이블에 속함을 증명(범위체크 등에 유용)

---

## 15.14 연습문제

1) **Schnorr Σ**에서 HVZK와 특수 사운드니스를 각각 3~4문장으로 요약하고, 두 챌린지로부터 \(w\)를 추출하는 식을 써라.
2) **CTR-모드**를 SNARK 회로로 만들 때 필요한 제약(덧셈 mod \(2^{128}\), XOR, S-box 유무 등)을 나열하고, **lookup**을 활용한 최적화 아이디어를 제시하라.
3) **SNARK(KZG)** 와 **STARK(FRI)** 의 보안 가정 차이를 설명하고, **양자 모델**에서의 상대적 성질을 비교하라.
4) **프라이버시 결제** 회로에서 “밸런스 보존”과 “이중지불 방지(nullifier)”를 각각 어떤 제약으로 강제하는지 수식/의사코드로 작성하라.
5) **익명 인증(Selective Disclosure)** 에서 도메인 분리 실패가 초래할 수 있는 공격을 예시와 함께 설명하라.
6) **투표 시스템**에서 혼합망과 동형합산 접근의 장단점을, 운영·감사 관점에서 비교하라.

---

## 15.15 요약 카드

- **Σ-프로토콜**: 커밋–챌린지–응답, FS로 비상호작용화.
- **SNARK vs STARK**: **작고 빠른 검증+셋업** ↔ **투명+증명큼**.
- **산술화**: 문제를 **R1CS/PLONK-ish/AIR**로, **lookup**과 **custom gate**로 실용화.
- **셋업/커밋**: **KZG/IPA/FRI** 선택, **updatable/transparent** 선호.
- **응용**: **익명 인증·프라이버시 결제·투표**는 커밋/머클/널리파이어/범위증명을 조합.
- **운영**: 도메인 분리·RNG·회로버전 고정·CI 재현·합법 준수.
