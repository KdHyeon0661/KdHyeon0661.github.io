---
layout: post
title: flask - 설정 & 구성
date: 2025-09-16 18:25:23 +0900
category: flask
---
# 6. 설정 & 구성

> 이 장은 **환경별 설정(Dev/Staging/Prod)과 안전한 시크릿 관리 → 인스턴스 폴더와 설정 계층화 → Feature Flag(기능 토글)** 를 “운영 실전” 기준으로 정리한다.  

---

## 6.1 큰그림: 12-Factor Config와 Flask

**핵심 원칙**

1) **설정은 코드에서 분리**: 코드 저장소엔 기본값/스키마만, 실제 값은 **환경변수/시크릿 스토어**.  
2) **환경별 분리(Dev/Staging/Prod)**: 로깅/디버그/데이터소스/도메인/보안 정책 분기.  
3) **안전한 시크릿 관리**: `.env`는 **로컬 개발용**만. 실제 운영은 **KMS/Secrets Manager/Vault**.  
4) **계층화/우선순위**를 문서화: “누가 누구를 덮어쓰는가?”  
5) **Feature Flag**: 위험한 변경은 **토글 가능**해야 한다(롤백/카나리/AB).  
6) **가시성**: 런타임에 **현재 설정 상태**를 점검/로그/헬스 엔드포인트로 확인.

---

## 6.2 Flask 설정 기초: 어디에 두고 어떻게 읽나

Flask는 내부적으로 `app.config`(dict-like)에 설정을 보관한다.

**대표 설정 예시**

- `DEBUG`, `TESTING`, `SECRET_KEY`  
- `SQLALCHEMY_DATABASE_URI`, `PREFERRED_URL_SCHEME`, `MAX_CONTENT_LENGTH`  
- `SEND_FILE_MAX_AGE_DEFAULT`, `SESSION_COOKIE_*`, `WTF_CSRF_*` 등

**로드 방법**

- `app = Flask(__name__, instance_relative_config=True)`  
- `app.config.from_mapping(...)`, `from_object(...)`, `from_pyfile(...)`, `from_envvar(...)`

---

## 6.3 환경별 설정 클래스(정석)

```python
# app/config.py
import os
from typing import Any, Dict

class BaseConfig:
    # ===== core =====
    APP_NAME = "FlaskApp"
    ENV = os.getenv("FLASK_ENV", "production")   # flask 기본 ENV
    DEBUG = False
    TESTING = False

    # ===== security =====
    SECRET_KEY = os.getenv("SECRET_KEY", "dev-insecure-key")  # Dev 기본값 (운영에서 반드시 환경변수로!)
    SESSION_COOKIE_SECURE = True
    SESSION_COOKIE_HTTPONLY = True
    SESSION_COOKIE_SAMESITE = "Lax"

    # ===== db =====
    DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///dev.db")

    # ===== assets & http =====
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024
    PREFERRED_URL_SCHEME = "https"
    SEND_FILE_MAX_AGE_DEFAULT = 31536000  # 1y

    # ===== feature flags (예: 기본값 모두 False) =====
    FEATURE_SIGNUP_V2 = False
    FEATURE_NEW_CHECKOUT = False

class DevelopmentConfig(BaseConfig):
    DEBUG = True
    SESSION_COOKIE_SECURE = False
    DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///dev.db")

class TestingConfig(BaseConfig):
    TESTING = True
    DEBUG = True
    SESSION_COOKIE_SECURE = False
    WTF_CSRF_ENABLED = False
    DATABASE_URL = "sqlite:///:memory:"

class StagingConfig(BaseConfig):
    # 운영과 거의 동일하되 리소스는 분리
    DEBUG = False

class ProductionConfig(BaseConfig):
    DEBUG = False
    # 운영은 반드시 환경변수로 SECRET_KEY/DATABASE_URL 제공

def load_config(name: str | None) -> Dict[str, Any]:
    env = (name or os.getenv("APP_ENV") or os.getenv("ENV") or "development").lower()
    mapping = {
        "dev": DevelopmentConfig,
        "development": DevelopmentConfig,
        "test": TestingConfig,
        "testing": TestingConfig,
        "staging": StagingConfig,
        "prod": ProductionConfig,
        "production": ProductionConfig,
    }
    cls = mapping.get(env, DevelopmentConfig)
    # config 객체의 UPPER 속성만 dict로 추출
    return {k: getattr(cls, k) for k in dir(cls) if k.isupper()}
```

**사용**

```python
# app/__init__.py
from flask import Flask
from .config import load_config

def create_app(config_name: str | None = None) -> Flask:
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(load_config(config_name))
    return app
```

---

## 6.4 설정 우선순위(권장)

1) **명시적 인자/오버라이드**: `app.config.from_mapping(...)`  
2) **환경변수**: `os.getenv()`로 클래스 안에서 읽은 값  
3) **인스턴스 폴더의 py파일**: `app.config.from_pyfile('config.py', silent=True)`  
4) **기본 클래스 값(Base/Dev/Prod)**

> **문서화 예시**: “운영에서 `SECRET_KEY` 는 환경변수 최우선, 없으면 인스턴스 폴더, 마지막으로 기본값(금지)” 같은 **정책을 README에 명시**하고 테스트까지 포함하라.

---

## 6.5 인스턴스 폴더(instance_relative_config=True)

**목적**: 코드 저장소와 분리된 **로컬/환경별 민감 설정**을 저장.

프로젝트 구조:

```
flaskapp/
├─ app/
│  ├─ __init__.py
│  └─ ...
├─ instance/
│  └─ config.py         # Git에 커밋하지 않음!
└─ wsgi.py
```

`instance/config.py` 예시:

```python
SECRET_KEY = "dev-local-override-key"
DATABASE_URL = "sqlite://///absolute/path/to/local.db"
```

앱에서 로드:

```python
def create_app(config_name=None):
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(load_config(config_name))
    app.config.from_pyfile("config.py", silent=True)  # instance/config.py
    return app
```

> **주의**: `instance/` 디렉토리는 **커밋 금지**(`.gitignore`)!

---

## 6.6 .env 로컬 개발 전략(python-dotenv)

```bash
pip install python-dotenv
```

`.env` / `.flaskenv` 예시(개발 편의):

```
# .flaskenv
FLASK_APP=wsgi.py
FLASK_ENV=development

# .env
APP_ENV=development
SECRET_KEY=dev-123
DATABASE_URL=postgresql+psycopg://dev:dev@localhost:5432/app
```

> Flask는 로컬에서 python-dotenv가 설치되어 있으면 `.env` 를 자동 로드(개발 편의).  
> **운영은 환경변수/시크릿 매니저**를 사용하고 `.env` 사용 지양.

---

## 6.7 안전한 시크릿 관리(운영): 선택지와 샘플

**원칙**: 시크릿은 저장소에 두지 않는다. **변경/회전/감사** 가능한 외부 스토어에 둔다.

### 6.7.1 Docker / Docker Swarm / Compose

- **Docker secrets**: 컨테이너 내부 `/run/secrets/<name>` 로 마운트.

```yaml
# docker-compose.yml (발췌)
services:
  web:
    image: myapp
    secrets:
      - secret_key
secrets:
  secret_key:
    file: ./secrets/secret_key.txt  # 저장소에 올리지 말 것
```

앱에서 로드:

```python
from pathlib import Path

def _read_secret_file(path: str) -> str | None:
    p = Path(path)
    return p.read_text().strip() if p.exists() else None

SECRET_FILE = "/run/secrets/secret_key"
file_val = _read_secret_file(SECRET_FILE)
if file_val:
    app.config["SECRET_KEY"] = file_val
```

### 6.7.2 Kubernetes (ConfigMap/Secret)

- **ConfigMap**: 비민감 설정  
- **Secret**: base64로 인코딩된 민감정보(실제로는 별도 KMS와 함께 사용)

`envFrom` 또는 `valueFrom`로 주입:

```yaml
env:
  - name: SECRET_KEY
    valueFrom:
      secretKeyRef:
        name: app-secrets
        key: secret_key
  - name: DATABASE_URL
    valueFrom:
      secretKeyRef:
        name: app-secrets
        key: database_url
```

### 6.7.3 AWS Systems Manager Parameter Store / Secrets Manager

**boto3** 예시:

```python
# app/secrets/aws.py
import os
import boto3

def load_from_ssm(app):
    if not os.getenv("AWS_REGION"):
        return
    ssm = boto3.client("ssm", region_name=os.getenv("AWS_REGION"))
    names = ["/myapp/prod/SECRET_KEY", "/myapp/prod/DATABASE_URL"]
    resp = ssm.get_parameters(Names=names, WithDecryption=True)
    kv = {p["Name"].split("/")[-1]: p["Value"] for p in resp.get("Parameters", [])}
    app.config.update(**kv)
```

초기화에서:

```python
def create_app(config_name=None):
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(load_config(config_name))
    # ...
    from .secrets.aws import load_from_ssm
    load_from_ssm(app)
    return app
```

### 6.7.4 HashiCorp Vault

- 앱은 **AppRole/Kubernetes Auth/JWT** 등으로 인증  
- KV 엔진에서 key/value 조회

```python
# app/secrets/vault.py
import hvac, os

def load_from_vault(app):
    url = os.getenv("VAULT_ADDR")
    role_id = os.getenv("VAULT_ROLE_ID")
    secret_id = os.getenv("VAULT_SECRET_ID")
    if not (url and role_id and secret_id):
        return
    client = hvac.Client(url=url)
    client.auth_approle(role_id, secret_id)
    data = client.secrets.kv.v2.read_secret_version(path="myapp/prod")["data"]["data"]
    app.config.update(**data)
```

> 운영에서는 **권한 최소화(least privilege)** 와 **로테이션/만료**를 정책화한다.

---

## 6.8 설정 계층화: 최종 권장 패턴

```python
def create_app(config_name=None):
    app = Flask(__name__, instance_relative_config=True)

    # 1) 코드에 내장된 환경별 기본값
    app.config.from_mapping(load_config(config_name))

    # 2) 인스턴스 폴더(머신/컨테이너 로컬 오버라이드)
    app.config.from_pyfile("config.py", silent=True)

    # 3) 외부 시크릿/파라미터 스토어(운영)
    try:
        from .secrets.aws import load_from_ssm
        load_from_ssm(app)
    except Exception as e:
        app.logger.warning("SSM load failed: %s", e)

    # 4) 마지막으로 환경변수 기반 오버라이드 유틸(선택)
    # 예: FLASKAPP__SECTION__KEY=value → 중첩 dict로 합치기
    _apply_env_overrides(app)

    return app
```

환경변수 오버라이드 유틸(간단 예):

```python
import os, json

def _apply_env_overrides(app):
    prefix = "APP_"
    for k, v in os.environ.items():
        if not k.startswith(prefix):
            continue
        key = k[len(prefix):]
        # JSON도 허용(예: 리스트/딕셔너리)
        try:
            val = json.loads(v)
        except Exception:
            val = v
        app.config[key] = val
```

> 문서화: “운영 오버라이드는 `APP_*` 환경변수로 한다. JSON 허용.”

---

## 6.9 설정 가시화: 안전하게 확인하는 엔드포인트/CLI

**주의**: 시크릿/민감정보는 절대 노출 금지. 마스킹 후 일부만 노출.

```python
# app/cli.py
from flask import current_app
import click

def register_cli(app):
    @app.cli.command("show-config")
    @click.option("--all", is_flag=True, help="민감값 마스킹 후 전체 표시")
    def show_config(all):
        cfg = dict(current_app.config)
        def mask(k, v):
            if "KEY" in k or "SECRET" in k or "TOKEN" in k or "PASSWORD" in k:
                return "***" if not v else v[:2] + "***"
            return v
        for k in sorted(cfg):
            if not all and k not in ("ENV", "DEBUG", "DATABASE_URL"):
                continue
            click.echo(f"{k}={mask(k, cfg[k])}")
```

엔드포인트(내부 관리자만):

```python
# app/blueprints/admin/ops.py
from flask import Blueprint, jsonify, current_app
from flask_login import login_required

ops_bp = Blueprint("ops", __name__)

@ops_bp.get("/ops/config")
@login_required
def ops_config():
    safe = {k: ("***" if ("KEY" in k or "SECRET" in k) else v) for k, v in current_app.config.items()}
    return jsonify(safe)
```

---

## 6.10 Feature Flag(기능 토글) — 전략과 구현

### 6.10.1 왜 필요한가?

- 위험한 변경을 **런타임에서 ON/OFF** 가능  
- **카나리/점진적 롤아웃**  
- **AB 테스트** / 실험 플래그  
- **핫픽스 롤백** 간편

### 6.10.2 정적 플래그(환경변수 기반)

```python
# config.BaseConfig
FEATURE_SIGNUP_V2 = os.getenv("FEATURE_SIGNUP_V2", "0") == "1"
```

사용:

```python
from flask import current_app

if current_app.config["FEATURE_SIGNUP_V2"]:
    # 신규 경로
else:
    # 구경로
```

장점: 간단/안전. 단점: 실시간 변경 어려움(재시작 필요/재배포 필요).

### 6.10.3 동적 플래그(in-memory + 원격 소스 동기화)

간단한 **토글 저장소**:

```python
# app/feature_flags.py
from threading import RLock

class FlagStore:
    def __init__(self, initial: dict[str, bool] | None = None):
        self._lock = RLock()
        self._flags = dict(initial or {})

    def is_on(self, key: str) -> bool:
        with self._lock:
            return bool(self._flags.get(key, False))

    def set(self, key: str, value: bool) -> None:
        with self._lock:
            self._flags[key] = value

FLAGS = FlagStore()
```

주입/동기화(예: Redis/DB/Unleash/LaunchDarkly 폴링):

```python
def sync_flags_from_redis():
    # Redis에서 dict를 가져와 FLAGS.set 반복
    ...

# create_app에서 주기적으로 백그라운드 스레드/CRON이 sync 호출
```

데코레이터:

```python
# app/decorators.py
from functools import wraps
from flask import abort
from .feature_flags import FLAGS

def require_flag(flag_name: str):
    def deco(fn):
        @wraps(fn)
        def _(*a, **kw):
            if not FLAGS.is_on(flag_name):
                abort(404)  # 노출 최소화
            return fn(*a, **kw)
        return _
    return deco
```

사용:

```python
@site_bp.get("/signup-v2")
@require_flag("FEATURE_SIGNUP_V2")
def signup_v2():
    ...
```

### 6.10.4 AB 실험(버킷팅)

간단한 사용자 해시 기반 버킷팅:

```python
import hashlib

def bucket(user_id: str, salt="exp1", buckets=100) -> int:
    h = hashlib.sha256(f"{salt}:{user_id}".encode()).hexdigest()
    return int(h[:8], 16) % buckets  # 0..99

def is_treatment(user_id: str, ratio=10) -> bool:
    return bucket(user_id) < ratio
```

---

## 6.11 Pydantic Settings로 설정 관리(대안/추천)

```bash
pip install pydantic==2.* pydantic-settings
```

```python
# app/settings.py
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field, AnyUrl

class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_prefix="APP_", env_file=".env", env_file_encoding="utf-8")

    APP_NAME: str = "FlaskApp"
    DEBUG: bool = False
    SECRET_KEY: str = Field(default="dev", min_length=8)
    DATABASE_URL: str = "sqlite:///dev.db"

    FEATURE_SIGNUP_V2: bool = False

# create_app에서:
def create_app(config_name=None):
    app = Flask(__name__)
    from .settings import Settings
    s = Settings()  # 환경변수/파일로부터 로드
    app.config.update(s.model_dump())
    return app
```

**장점**

- 타입 안전/검증/기본값/환경변수 자동 로드  
- 중첩/복잡한 설정도 손쉽게 모델링  
- 테스트에서 override 용이

---

## 6.12 Dynaconf(다계층 파일+환경변수 합치기)

```bash
pip install dynaconf
```

```python
# settings.toml
[default]
APP_NAME = "FlaskApp"
DEBUG = false

[development]
DEBUG = true
DATABASE_URL = "sqlite:///dev.db"

[production]
DEBUG = false
```

```python
# app/config_dynaconf.py
from dynaconf import Dynaconf

settings = Dynaconf(
  settings_files=["settings.toml", ".secrets.toml"],  # 암호파일은 외부 저장
  environments=True,  # 개발/운영 구간
  envvar_prefix="APP" # APP__DATABASE_URL 환경변수로 override
)

def create_app(...):
    app = Flask(__name__)
    app.config.update(settings.as_dict())
```

---

## 6.13 샘플: 설정 값의 안전한 사용 패턴

### 6.13.1 데이터베이스 (SQLAlchemy)

```python
# app/extensions.py
from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()

def init_extensions(app):
    app.config.setdefault("SQLALCHEMY_DATABASE_URI", app.config.get("DATABASE_URL"))
    app.config.setdefault("SQLALCHEMY_TRACK_MODIFICATIONS", False)
    db.init_app(app)
```

### 6.13.2 CORS/보안 헤더

```python
# app/security.py
from flask import Flask

def apply_security_headers(app: Flask) -> None:
    @app.after_request
    def _headers(resp):
        resp.headers.setdefault("X-Content-Type-Options", "nosniff")
        resp.headers.setdefault("X-Frame-Options", "DENY")
        # CSP는 환경별로 다르게
        csp = app.config.get("CSP", "default-src 'self'")
        resp.headers.setdefault("Content-Security-Policy", csp)
        return resp
```

설정으로 컨트롤:

```python
# instance/config.py (staging/prod)
CSP = "default-src 'self'; img-src 'self' https://cdn.example.com; script-src 'self';"
```

---

## 6.14 런타임 재로딩/핫스왑(주의)

- 간단한 플래그/정책은 **플래그 스토어**로 실시간 변경 가능  
- **보안/핵심 연결(데이터베이스/키)** 는 재시작/롤링배포로 처리  
- 재로딩이 필요한 경우 **관리자 전용 엔드포인트** + **서명/권한** 필수

```python
# 예시: 관리자에서 플래그 토글
@admin_bp.post("/ops/flags/<name>")
def set_flag(name):
    if not current_user.is_admin: abort(403)
    value = bool(request.json.get("value"))
    FLAGS.set(name, value)
    return {"ok": True}
```

---

## 6.15 테스트: 환경별 설정/우선순위 보증

```python
# tests/test_config.py
def test_config_precedence(app_factory):
    app = app_factory(env="testing")  # create_app("testing") 래퍼
    assert app.config["TESTING"] is True
    assert app.config["DEBUG"] is True
    # 환경변수 override
    import os
    os.environ["APP_DEBUG"] = "false"
    app2 = app_factory(env="testing")
    assert app2.config["DEBUG"] in (False, "false")  # 적용 여부 확인

def test_secret_masking(cli_runner):
    r = cli_runner.invoke(args=["show-config", "--all"])
    assert r.exit_code == 0
    assert "***" in r.output  # 마스킹 작동
```

---

## 6.16 운영 체크리스트

- [ ] **우선순위 문서화**: Base → 인스턴스 → 외부 시크릿 → 환경변수(최종)  
- [ ] **시크릿은 저장소 금지**: `.env` 는 로컬만, 운영은 Secret Manager/KMS  
- [ ] **로테이션 계획**: 키/토큰/DB 패스워드 주기적 교체  
- [ ] **마스킹**: 로그/툴/엔드포인트에 시크릿 노출 금지  
- [ ] **권한 최소화**: 시크릿 접근 역할/정책 최소  
- [ ] **감사/추적**: 누가 언제 어떤 값에 접근/변경했는지  
- [ ] **Feature Flag 표준화**: 네이밍/범위/만료/청소 정책  
- [ ] **Staging=Prod 가깝게**: 동형 환경(다만 리소스 분리)  
- [ ] **Fail-safe 기본값**: 값 미설정 시 안전모드로  
- [ ] **런북/문서**: 신규 환경 bring-up 절차, 필수 env list, 헬스체크

---

## 6.17 흔한 안티패턴

- **코드에 시크릿 하드코딩**: 소스/이미지 유출 위험  
- **.env를 운영에 그대로 사용**: 접근 통제/감사가 불가  
- **우선순위 혼란**: 어디서 덮었는지 모름 → 디버깅 지옥  
- **Feature Flag 남발**: 만료/정리 없이 누적 → 플래그 스파게티  
- **Staging가 Dev와 같음**: 운영 검증 실패  
- **설정 확인 수단 부재**: 런타임 상태를 못 봄 → 사고 시 판단 지연

---

## 6.18 미니 템플릿(복붙용)

```python
# app/__init__.py
from flask import Flask
from .config import load_config

def create_app(config_name=None):
    app = Flask(__name__, instance_relative_config=True)

    # base / env
    app.config.from_mapping(load_config(config_name))
    # instance override
    app.config.from_pyfile("config.py", silent=True)

    # external secrets (opt)
    try:
        from .secrets.aws import load_from_ssm
        load_from_ssm(app)
    except Exception:
        pass

    # feature flags (opt)
    from .feature_flags import FLAGS
    FLAGS.set("FEATURE_SIGNUP_V2", app.config.get("FEATURE_SIGNUP_V2", False))

    # extensions / blueprints / security headers
    from .extensions import init_extensions
    from .security import apply_security_headers
    init_extensions(app)
    apply_security_headers(app)

    return app
```

```python
# wsgi.py
from app import create_app
app = create_app()
```

```ini
# .gitignore (중요)
instance/
secrets/
.env
```

---

## 6.19 마무리

이 장에서는 **환경별 설정과 시크릿 관리의 원칙**, **인스턴스 폴더/우선순위/외부 시크릿 스토어 연동**, 그리고 **Feature Flag를 이용한 안전한 배포·롤백·실험**까지 실전 패턴을 정리했다.