---
layout: post
title: flask - 설정 & 구성
date: 2025-09-16 18:25:23 +0900
category: flask
---
# 설정 & 구성

## 큰 그림: 12-Factor Config와 Flask

현대적인 애플리케이션 구축에서 설정 관리의 핵심 원칙은 12-Factor App의 구성(Config) 항목에 잘 드러나 있습니다. Flask 애플리케이션에서도 이러한 원칙을 적용하여 안전하고 유연한 설정 관리를 구현할 수 있습니다.

**핵심 원칙**

1. **설정은 코드에서 분리**: 코드 저장소에는 기본값과 설정 스키마만 포함하고, 실제 값은 **환경변수나 시크릿 스토어**에서 관리합니다.
2. **환경별 분리**: 개발(Dev), 스테이징(Staging), 프로덕션(Prod) 환경에 따라 로깅, 디버그 모드, 데이터소스, 도메인, 보안 정책 등을 분리합니다.
3. **안전한 시크릿 관리**: `.env` 파일은 **로컬 개발용으로만 사용**하고, 실제 운영 환경에서는 **KMS, Secrets Manager, Vault** 같은 전문 시크릿 관리 도구를 활용합니다.
4. **계층화와 우선순위 명확화**: 설정이 어떻게 로드되고 덮어쓰이는지의 우선순위를 명확히 문서화합니다.
5. **Feature Flag 활용**: 위험한 변경사항은 **토글 가능한 기능 플래그**로 관리하여 롤백, 카나리 배포, A/B 테스트를 용이하게 합니다.
6. **가시성 확보**: 런타임에 **현재 설정 상태를 점검**할 수 있는 로그, 헬스 엔드포인트, 관리 도구를 제공합니다.

---

## Flask 설정 기초: 저장 위치와 로드 방법

Flask는 내부적으로 `app.config`(사전형 객체)에 모든 설정을 저장합니다. 이 객체를 통해 애플리케이션의 다양한 동작을 제어할 수 있습니다.

**대표적인 설정 항목들**

- `DEBUG`, `TESTING`, `SECRET_KEY`
- `SQLALCHEMY_DATABASE_URI`, `PREFERRED_URL_SCHEME`, `MAX_CONTENT_LENGTH`
- `SEND_FILE_MAX_AGE_DEFAULT`, `SESSION_COOKIE_*`, `WTF_CSRF_*` 등

**설정 로드 방법**

Flask는 여러 가지 방법으로 설정을 로드할 수 있습니다:
- `app = Flask(__name__, instance_relative_config=True)`
- `app.config.from_mapping(...)`
- `app.config.from_object(...)`
- `app.config.from_pyfile(...)`
- `app.config.from_envvar(...)`

---

## 환경별 설정 클래스(권장 패턴)

```python
# app/config.py

import os
from typing import Any, Dict

class BaseConfig:
    # ===== 핵심 설정 =====
    APP_NAME = "FlaskApp"
    ENV = os.getenv("FLASK_ENV", "production")   # flask 기본 환경 변수
    DEBUG = False
    TESTING = False

    # ===== 보안 설정 =====
    SECRET_KEY = os.getenv("SECRET_KEY", "dev-insecure-key")  # 개발용 기본값 (운영에서는 반드시 환경변수로 설정!)
    SESSION_COOKIE_SECURE = True
    SESSION_COOKIE_HTTPONLY = True
    SESSION_COOKIE_SAMESITE = "Lax"

    # ===== 데이터베이스 설정 =====
    DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///dev.db")

    # ===== 에셋과 HTTP 설정 =====
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024
    PREFERRED_URL_SCHEME = "https"
    SEND_FILE_MAX_AGE_DEFAULT = 31536000  # 1년

    # ===== 기능 플래그 (기본값 모두 False) =====
    FEATURE_SIGNUP_V2 = False
    FEATURE_NEW_CHECKOUT = False

class DevelopmentConfig(BaseConfig):
    DEBUG = True
    SESSION_COOKIE_SECURE = False
    DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///dev.db")

class TestingConfig(BaseConfig):
    TESTING = True
    DEBUG = True
    SESSION_COOKIE_SECURE = False
    WTF_CSRF_ENABLED = False
    DATABASE_URL = "sqlite:///:memory:"

class StagingConfig(BaseConfig):
    # 운영 환경과 거의 동일하되 리소스는 분리
    DEBUG = False

class ProductionConfig(BaseConfig):
    DEBUG = False
    # 운영 환경에서는 반드시 환경변수로 SECRET_KEY/DATABASE_URL 제공

def load_config(name: str | None) -> Dict[str, Any]:
    env = (name or os.getenv("APP_ENV") or os.getenv("ENV") or "development").lower()
    mapping = {
        "dev": DevelopmentConfig,
        "development": DevelopmentConfig,
        "test": TestingConfig,
        "testing": TestingConfig,
        "staging": StagingConfig,
        "prod": ProductionConfig,
        "production": ProductionConfig,
    }
    cls = mapping.get(env, DevelopmentConfig)
    # config 객체의 대문자 속성만 사전으로 추출
    return {k: getattr(cls, k) for k in dir(cls) if k.isupper()}
```

**사용 방법**

```python
# app/__init__.py

from flask import Flask
from .config import load_config

def create_app(config_name: str | None = None) -> Flask:
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(load_config(config_name))
    return app
```

---

## 설정 우선순위(권장 방식)

설정 값이 충돌할 때 어떤 것이 우선하는지 명확한 규칙을 수립하는 것이 중요합니다:

1. **명시적 인자/오버라이드**: `app.config.from_mapping(...)`으로 직접 설정
2. **환경변수**: `os.getenv()`를 통해 클래스 내부에서 읽은 값
3. **인스턴스 폴더의 파이썬 파일**: `app.config.from_pyfile('config.py', silent=True)`
4. **기본 클래스 값**(BaseConfig/DevelopmentConfig/ProductionConfig)

> **문서화 예시**: "운영 환경에서 `SECRET_KEY`는 환경변수가 최우선, 없으면 인스턴스 폴더 설정, 마지막으로 기본값(금지)" 같은 정책을 README에 명시하고 테스트까지 포함해야 합니다.

---

## 인스턴스 폴더(instance_relative_config=True)

**목적**: 코드 저장소와 분리된 **로컬 또는 환경별 민감 설정**을 저장하기 위한 공간을 제공합니다.

**프로젝트 구조**

```
flaskapp/
├─ app/
│  ├─ __init__.py
│  └─ ...
├─ instance/
│  └─ config.py         # Git에 커밋하지 않음!
└─ wsgi.py
```

**instance/config.py 예시**

```python
SECRET_KEY = "dev-local-override-key"
DATABASE_URL = "sqlite://///absolute/path/to/local.db"
```

**애플리케이션에서 로드**

```python
def create_app(config_name=None):
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(load_config(config_name))
    app.config.from_pyfile("config.py", silent=True)  # instance/config.py 로드
    return app
```

> **중요**: `instance/` 디렉토리는 **절대 커밋하지 마세요**(`.gitignore`에 추가).

---

## .env 파일을 활용한 로컬 개발 전략(python-dotenv)

```bash
pip install python-dotenv
```

**.flaskenv 파일 예시** (Flask 전용 설정):

```
FLASK_APP=wsgi.py
FLASK_ENV=development
```

**.env 파일 예시** (애플리케이션 설정):

```
APP_ENV=development
SECRET_KEY=dev-123
DATABASE_URL=postgresql+psycopg://dev:dev@localhost:5432/app
```

> Flask는 로컬 개발 환경에서 python-dotenv가 설치되어 있으면 자동으로 `.env` 파일을 로드합니다(개발 편의 기능).
> **운영 환경에서는 환경변수나 시크릿 매니저를 사용**하고 `.env` 파일 사용을 지양해야 합니다.

---

## 안전한 시크릿 관리(운영 환경): 선택지와 구현 예시

**원칙**: 시크릿(비밀번호, API 키, 토큰 등)은 절대 저장소에 저장하지 않습니다. 변경, 회전, 감사가 가능한 외부 스토어에 보관합니다.

### Docker / Docker Swarm / Compose 환경

- **Docker secrets**: 컨테이너 내부 `/run/secrets/<name>` 경로에 마운트.

```yaml
# docker-compose.yml (일부)

services:
  web:
    image: myapp
    secrets:
      - secret_key
secrets:
  secret_key:
    file: ./secrets/secret_key.txt  # 저장소에 올리지 않음
```

**애플리케이션에서 시크릿 파일 읽기**

```python
from pathlib import Path

def _read_secret_file(path: str) -> str | None:
    p = Path(path)
    return p.read_text().strip() if p.exists() else None

SECRET_FILE = "/run/secrets/secret_key"
file_val = _read_secret_file(SECRET_FILE)
if file_val:
    app.config["SECRET_KEY"] = file_val
```

### Kubernetes 환경 (ConfigMap/Secret 활용)

- **ConfigMap**: 민감하지 않은 설정 값 저장
- **Secret**: base64로 인코딩된 민감정보 저장(실제 운영에서는 별도 KMS와 함께 사용)

**환경변수로 주입**

```yaml
env:
  - name: SECRET_KEY
    valueFrom:
      secretKeyRef:
        name: app-secrets
        key: secret_key
  - name: DATABASE_URL
    valueFrom:
      secretKeyRef:
        name: app-secrets
        key: database_url
```

### AWS Systems Manager Parameter Store / Secrets Manager

**boto3를 활용한 예시**

```python
# app/secrets/aws.py

import os
import boto3

def load_from_ssm(app):
    if not os.getenv("AWS_REGION"):
        return
    ssm = boto3.client("ssm", region_name=os.getenv("AWS_REGION"))
    names = ["/myapp/prod/SECRET_KEY", "/myapp/prod/DATABASE_URL"]
    resp = ssm.get_parameters(Names=names, WithDecryption=True)
    kv = {p["Name"].split("/")[-1]: p["Value"] for p in resp.get("Parameters", [])}
    app.config.update(**kv)
```

**초기화 시 호출**

```python
def create_app(config_name=None):
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(load_config(config_name))
    # ...
    from .secrets.aws import load_from_ssm
    load_from_ssm(app)
    return app
```

### HashiCorp Vault

- 애플리케이션은 **AppRole, Kubernetes Auth, JWT** 등으로 인증
- KV 엔진에서 key/value 조회

```python
# app/secrets/vault.py

import hvac, os

def load_from_vault(app):
    url = os.getenv("VAULT_ADDR")
    role_id = os.getenv("VAULT_ROLE_ID")
    secret_id = os.getenv("VAULT_SECRET_ID")
    if not (url and role_id and secret_id):
        return
    client = hvac.Client(url=url)
    client.auth_approle(role_id, secret_id)
    data = client.secrets.kv.v2.read_secret_version(path="myapp/prod")["data"]["data"]
    app.config.update(**data)
```

> 운영 환경에서는 **최소 권한 원칙(least privilege)**과 **정기적 로테이션/만료 정책**을 반드시 수립해야 합니다.

---

## 설정 계층화: 최종 권장 패턴

```python
def create_app(config_name=None):
    app = Flask(__name__, instance_relative_config=True)

    # 1) 코드에 내장된 환경별 기본값
    app.config.from_mapping(load_config(config_name))

    # 2) 인스턴스 폴더(머신/컨테이너 로컬 오버라이드)
    app.config.from_pyfile("config.py", silent=True)

    # 3) 외부 시크릿/파라미터 스토어(운영 환경용)
    try:
        from .secrets.aws import load_from_ssm
        load_from_ssm(app)
    except Exception as e:
        app.logger.warning("SSM 로드 실패: %s", e)

    # 4) 환경변수 기반 오버라이드(선택 사항)
    # 예: FLASKAPP__SECTION__KEY=value → 중첩 dict로 변환
    _apply_env_overrides(app)

    return app
```

**환경변수 오버라이드 유틸리티**

```python
import os, json

def _apply_env_overrides(app):
    prefix = "APP_"
    for k, v in os.environ.items():
        if not k.startswith(prefix):
            continue
        key = k[len(prefix):]
        # JSON 형식도 허용(리스트/딕셔너리 지원)
        try:
            val = json.loads(v)
        except Exception:
            val = v
        app.config[key] = val
```

> 문서화: "운영 환경 오버라이드는 `APP_*` 접두사를 가진 환경변수로 설정합니다. JSON 형식도 지원됩니다."

---

## 설정 가시화: 안전하게 확인하는 엔드포인트와 CLI

**주의**: 시크릿이나 민감정보는 절대 노출해서는 안 됩니다. 마스킹 처리 후 일부만 표시해야 합니다.

**CLI 명령어 예시**

```python
# app/cli.py

from flask import current_app
import click

def register_cli(app):
    @app.cli.command("show-config")
    @click.option("--all", is_flag=True, help="민감값 마스킹 후 전체 설정 표시")
    def show_config(all):
        cfg = dict(current_app.config)
        def mask(k, v):
            if "KEY" in k or "SECRET" in k or "TOKEN" in k or "PASSWORD" in k:
                return "***" if not v else v[:2] + "***"
            return v
        for k in sorted(cfg):
            if not all and k not in ("ENV", "DEBUG", "DATABASE_URL"):
                continue
            click.echo(f"{k}={mask(k, cfg[k])}")
```

**내부 관리자용 엔드포인트**

```python
# app/blueprints/admin/ops.py

from flask import Blueprint, jsonify, current_app
from flask_login import login_required

ops_bp = Blueprint("ops", __name__)

@ops_bp.get("/ops/config")
@login_required
def ops_config():
    safe = {k: ("***" if ("KEY" in k or "SECRET" in k) else v) for k, v in current_app.config.items()}
    return jsonify(safe)
```

---

## 기능 플래그(Feature Flags): 전략과 구현

### 왜 필요한가?

- 위험한 변경사항을 **런타임에서 ON/OFF 가능**하게 합니다.
- **카나리 배포와 점진적 롤아웃**을 지원합니다.
- **A/B 테스트와 실험**을 가능하게 합니다.
- **핫픽스 롤백**을 간편하게 수행할 수 있습니다.

### 정적 플래그(환경변수 기반)

```python
# config.BaseConfig

FEATURE_SIGNUP_V2 = os.getenv("FEATURE_SIGNUP_V2", "0") == "1"
```

**사용 방법**

```python
from flask import current_app

if current_app.config["FEATURE_SIGNUP_V2"]:
    # 신규 가입 경로
else:
    # 기존 가입 경로
```

**장점**: 간단하고 안전합니다.  
**단점**: 실시간 변경이 어렵고 재시작이나 재배포가 필요합니다.

### 동적 플래그(메모리 저장 + 원격 소스 동기화)

**간단한 토글 저장소 구현**

```python
# app/feature_flags.py

from threading import RLock

class FlagStore:
    def __init__(self, initial: dict[str, bool] | None = None):
        self._lock = RLock()
        self._flags = dict(initial or {})

    def is_on(self, key: str) -> bool:
        with self._lock:
            return bool(self._flags.get(key, False))

    def set(self, key: str, value: bool) -> None:
        with self._lock:
            self._flags[key] = value

FLAGS = FlagStore()
```

**주기적 동기화**(Redis, 데이터베이스, Unleash, LaunchDarkly 등에서 폴링)

```python
def sync_flags_from_redis():
    # Redis에서 dict를 가져와 FLAGS.set 반복 호출
    ...

# create_app 함수에서 주기적으로 백그라운드 스레드나 CRON 작업으로 sync_flags_from_redis 호출
```

**데코레이터 구현**

```python
# app/decorators.py

from functools import wraps
from flask import abort
from .feature_flags import FLAGS

def require_flag(flag_name: str):
    def deco(fn):
        @wraps(fn)
        def _(*a, **kw):
            if not FLAGS.is_on(flag_name):
                abort(404)  # 존재하지 않는 페이지로 처리(노출 최소화)
            return fn(*a, **kw)
        return _
    return deco
```

**사용 예시**

```python
@site_bp.get("/signup-v2")
@require_flag("FEATURE_SIGNUP_V2")
def signup_v2():
    ...
```

### A/B 테스트(버킷팅)

**사용자 해시 기반 버킷팅 예시**

```python
import hashlib

def bucket(user_id: str, salt="exp1", buckets=100) -> int:
    h = hashlib.sha256(f"{salt}:{user_id}".encode()).hexdigest()
    return int(h[:8], 16) % buckets  # 0..99 반환

def is_treatment(user_id: str, ratio=10) -> bool:
    return bucket(user_id) < ratio
```

---

## Pydantic Settings로 설정 관리(대안/추천)

```bash
pip install pydantic==2.* pydantic-settings
```

```python
# app/settings.py

from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field, AnyUrl

class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_prefix="APP_", env_file=".env", env_file_encoding="utf-8")

    APP_NAME: str = "FlaskApp"
    DEBUG: bool = False
    SECRET_KEY: str = Field(default="dev", min_length=8)
    DATABASE_URL: str = "sqlite:///dev.db"

    FEATURE_SIGNUP_V2: bool = False

# create_app 함수에서 사용

def create_app(config_name=None):
    app = Flask(__name__)
    from .settings import Settings
    s = Settings()  # 환경변수/파일로부터 자동 로드
    app.config.update(s.model_dump())
    return app
```

**Pydantic Settings 장점**

- 타입 안전성, 검증, 기본값 설정이 용이합니다.
- 환경변수 자동 로드 기능을 제공합니다.
- 중첩되고 복잡한 설정도 쉽게 모델링할 수 있습니다.
- 테스트 환경에서 오버라이드가 간편합니다.

---

## Dynaconf 활용(다계층 파일 + 환경변수 통합)

```bash
pip install dynaconf
```

**settings.toml 파일**

```toml
[default]
APP_NAME = "FlaskApp"
DEBUG = false

[development]
DEBUG = true
DATABASE_URL = "sqlite:///dev.db"

[production]
DEBUG = false
```

**Dynaconf 설정**

```python
# app/config_dynaconf.py

from dynaconf import Dynaconf

settings = Dynaconf(
  settings_files=["settings.toml", ".secrets.toml"],  # 암호 파일은 외부에 저장
  environments=True,  # 개발/운영 환경 구분 지원
  envvar_prefix="APP" # APP__DATABASE_URL 환경변수로 오버라이드 가능
)

def create_app(...):
    app = Flask(__name__)
    app.config.update(settings.as_dict())
```

---

## 설정 값의 안전한 사용 패턴 예시

### 데이터베이스 연결(SQLAlchemy)

```python
# app/extensions.py

from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()

def init_extensions(app):
    app.config.setdefault("SQLALCHEMY_DATABASE_URI", app.config.get("DATABASE_URL"))
    app.config.setdefault("SQLALCHEMY_TRACK_MODIFICATIONS", False)
    db.init_app(app)
```

### CORS와 보안 헤더 설정

```python
# app/security.py

from flask import Flask

def apply_security_headers(app: Flask) -> None:
    @app.after_request
    def _headers(resp):
        resp.headers.setdefault("X-Content-Type-Options", "nosniff")
        resp.headers.setdefault("X-Frame-Options", "DENY")
        # CSP는 환경별로 다르게 설정
        csp = app.config.get("CSP", "default-src 'self'")
        resp.headers.setdefault("Content-Security-Policy", csp)
        return resp
```

**환경별 CSP 설정**

```python
# instance/config.py (staging/production 환경)

CSP = "default-src 'self'; img-src 'self' https://cdn.example.com; script-src 'self';"
```

---

## 런타임 재로딩과 핫스왑(주의사항)

- 간단한 기능 플래그나 정책 설정은 **플래그 스토어**를 통해 실시간 변경이 가능합니다.
- **보안 관련 설정이나 핵심 연결 정보**(데이터베이스, 암호화 키 등)는 재시작이나 롤링 배포를 통해 변경해야 합니다.
- 재로딩이 필요한 경우 **관리자 전용 엔드포인트**를 제공하고 **서명 검증과 권한 확인**을 필수로 구현해야 합니다.

```python
# 예시: 관리자 플래그 토글 엔드포인트

@admin_bp.post("/ops/flags/<name>")
def set_flag(name):
    if not current_user.is_admin:
        abort(403)
    value = bool(request.json.get("value"))
    FLAGS.set(name, value)
    return {"ok": True}
```

---

## 테스트: 환경별 설정과 우선순위 검증

```python
# tests/test_config.py

def test_config_precedence(app_factory):
    app = app_factory(env="testing")  # create_app("testing") 래퍼
    assert app.config["TESTING"] is True
    assert app.config["DEBUG"] is True
    # 환경변수 오버라이드 테스트
    import os
    os.environ["APP_DEBUG"] = "false"
    app2 = app_factory(env="testing")
    assert app2.config["DEBUG"] in (False, "false")  # 적용 여부 확인

def test_secret_masking(cli_runner):
    r = cli_runner.invoke(args=["show-config", "--all"])
    assert r.exit_code == 0
    assert "***" in r.output  # 마스킹 작동 확인
```

---

## 실전 통합 템플릿

```python
# app/__init__.py

from flask import Flask
from .config import load_config

def create_app(config_name=None):
    app = Flask(__name__, instance_relative_config=True)

    # 기본/환경별 설정
    app.config.from_mapping(load_config(config_name))
    # 인스턴스 오버라이드
    app.config.from_pyfile("config.py", silent=True)

    # 외부 시크릿 로드(선택 사항)
    try:
        from .secrets.aws import load_from_ssm
        load_from_ssm(app)
    except Exception:
        pass

    # 기능 플래그 초기화(선택 사항)
    from .feature_flags import FLAGS
    FLAGS.set("FEATURE_SIGNUP_V2", app.config.get("FEATURE_SIGNUP_V2", False))

    # 확장 기능 및 보안 헤더 설정
    from .extensions import init_extensions
    from .security import apply_security_headers
    init_extensions(app)
    apply_security_headers(app)

    return app
```

```python
# wsgi.py

from app import create_app
app = create_app()
```

```ini
# .gitignore (중요 설정)

instance/
secrets/
.env
```

---

## 결론

설정과 구성 관리는 Flask 애플리케이션 개발에서 단순한 기술적 문제를 넘어 운영 품질과 보안에 직결되는 핵심 요소입니다. 이번 장에서는 12-Factor App 원칙에 기반한 설정 관리의 기본 철학부터 시작하여, Flask 애플리케이션에서 환경별 설정을 구조화하는 방법, 다양한 시크릿 관리 전략, 기능 플래그를 통한 안전한 배포와 실험 시스템 구축까지 실제 운영 환경에서 검증된 패턴들을 상세히 살펴보았습니다.

설정 관리를 효과적으로 구현하기 위해서는 단일 기술이나 도구에 의존하기보다는 계층화된 접근 방식을 채택하고, 각 계층의 책임과 우선순위를 명확히 정의하는 것이 중요합니다. 또한 설정 값의 가시성과 안전한 접근 메커니즘을 함께 고려하여 운영자의 진단과 문제 해결을 지원해야 합니다.

최종적으로는 이러한 설정 관리 체계가 단순히 기술적 요구사항을 충족하는 것을 넘어, 팀의 개발 워크플로우와 배포 프로세스에 자연스럽게 통합되어 더 빠르고 안전한 소프트웨어 제공을 가능하게 하는 인프라의 일부로 자리 잡아야 합니다. 잘 설계된 설정 관리 시스템은 변화하는 비즈니스 요구사항에 유연하게 대응하면서도 시스템의 안정성과 보안을 유지하는 데 결정적인 역할을 합니다.