---
layout: post
title: 정보보안기사 - 소프트웨어 보안 기초
date: 2025-11-09 18:25:23 +0900
category: 정보보안기사
---
# 소프트웨어 보안 기초 — **SDLC, 위협모델링, 안전한 코딩**

## 0) 개요 — 왜 SDLC 보안인가?

- 결함의 수정 비용은 **요구사항 단계 대비 운영 단계**에서 **수십~수백 배**.  
- 보안 활동을 각 단계(요구·설계·구현·검증·배포·운영)에 배치하면, “나중에 뜯어고치기”를 줄입니다.

### 용어 한줄 요약
- **SSDLC**: Security by Design이 내장된 SDLC.  
- **SAST/DAST/IAST**: 정적/동적/대화형 분석.  
- **SCA/SBOM**: 오픈소스 의존성 분석 / 소프트웨어 자재명세.  
- **ASVS/CWE**: OWASP AppSec Verification Standard / 소프트웨어 약점 공통 분류.

---

# 1) 보안이 내장된 SDLC(SSDLC)

## 1.1 단계별 활동·산출물·게이트

| 단계 | 주요 활동 | 산출물(템플릿 예) | 게이트(통과 조건) |
|---|---|---|---|
| 요구사항 | 보안 요구(ASVS), 개인정보 분류, **오남용 스토리** | 보안 요구 체크리스트, 데이터 분류표 | 개인정보 영향평가 초안, 승인 |
| 설계 | **위협모델링(STRIDE)**, DFD/경계, 아키 보안패턴 | DFD, 위협 목록·완화 매핑 | 하이리스크 위협에 대한 설계 대안 |
| 구현 | 코딩 표준, 시크릿 관리, SAST/SCA, 코드리뷰 | 코드리뷰 로그, SAST 리포트, SBOM | **High/Critical 0건**(가드레일) |
| 검증 | DAST/IAST, API 보안테스트, fuzzing, 성능/리소스 | 테스트 리포트, 취약점 티켓 | 취약점 Remediation SLA 충족 |
| 배포 | 서명·무결성, 프로비넌스(SLSA), 구성스캔 | 서명 아티팩트, IaC 리포트 | 릴리즈 서명 검증 OK |
| 운영 | 로깅/모니터링, 런북, 패치·비밀 순환 | 보안 대시보드, 주간 리포트 | MTTD/MTTR 목표 준수 |

> **지표 예**: 보안 결함 유입률(코드 1k LoC당), High 취약점 평균 해결시간(SLA), 시크릿 유출 재발률.

---

# 2) 위협모델링(Threat Modeling)

## 2.1 절차(5단계)

1) **자산·목표 식별**: 보호할 가치(데이터, 가용성, 신뢰).  
2) **아키텍처·DFD 작성**: **신뢰경계(Trust Boundary)** 표시.  
3) **위협 식별**: **STRIDE**(Spoofing, Tampering, Repudiation, Information Disclosure, Denial, Elevation) 또는 LINDDUN(프라이버시).  
4) **리스크 평가**: 가능성×영향, **완화책 매핑**.  
5) **검증/추적**: 테스트, 티켓화, 릴리즈 게이트.

### 간단 DFD(ASCII) — “주문 API + 관리자 대시보드”
```
 [Browser] --HTTPS--> [API GW/Reverse Proxy] --mTLS--> [Order Service]
       \                                                      |
        \--HTTPS(Admin)--> [Admin SPA] ---JWT---> [Admin API] |
                         (Trust Boundary)                     v
                                                        [PostgreSQL]
```
- Trust Boundary: 인터넷↔DMZ, DMZ↔내부, 서비스↔DB.

## 2.2 STRIDE 표(발췌)

| 구성요소 | 위협(STRIDE) | 사례 | 완화 |
|---|---|---|---|
| API GW | **Spoofing** | 도용된 JWT로 호출 | **OIDC 검증**(aud/iss/exp), mTLS(내부) |
| Order Svc | **Tampering** | 주문 금액 파라미터 변조 | **서버측 가격조회**, 요청 스키마 검증 |
| DB | **Repudiation** | 감사불가 | **불변 감사로그**, 요청자/세션ID 포함 |
| Admin API | **Info Disclosure** | 상세 에러스택 노출 | **오류 핸들러**, 고객용/내부용 분리 |
| API GW | **Denial** | 대량 요청 | **레이트리밋**, 서킷브레이커 |
| Admin | **Elevation** | 권한상승(IDOR) | **오브젝트 레벨 권한검사** |

## 2.3 리스크 스코어(간이)

$$
\text{Risk} = \text{Likelihood} \times \text{Impact}
$$

- 등급: L/M/H/Critical.  
- **Bug Bar**: H/Critical은 GA 이전 **0건**.

## 2.4 “오남용(Abuse/Misuse) 스토리” 예
- “공격자로서, **다른 고객의 주문 상세**를 조회하고 싶다(예: `/orders/:id`).”  
  - **완화**: `where id=:id and owner_id=:current_user_id`.

---

# 3) 안전한 코딩(핵심 패턴·반패턴 + 코드)

> 아래 예제는 모두 **안전 패턴**을 보여줍니다(반패턴은 비교 목적 일부 포함).

## 3.1 입력검증·출력인코딩(XSS/Injection)

### [Python/Flask] SQL Injection — 안전한 쿼리
```python
# pip install flask sqlalchemy psycopg2-binary
from flask import Flask, request, jsonify
from sqlalchemy import text
from db import engine

app = Flask(__name__)

@app.post("/search")
def search():
    # ❌ 반패턴: f"SELECT * FROM products WHERE name LIKE '%{q}%'" (사용 금지)
    q = request.json.get("q", "")
    stmt = text("SELECT id,name,price FROM products WHERE name ILIKE :kw LIMIT 50")
    rows = engine.execute(stmt, {"kw": f"%{q}%"}).mappings().all()
    return jsonify(rows)
```

### [Node/Express + Pug] 반사형 XSS 방지
```javascript
// npm i express helmet pug
const express = require('express');
const helmet = require('helmet');
const app = express();
app.use(helmet());
app.set('view engine', 'pug');

app.get('/greet', (req,res) => {
  const name = req.query.name || 'friend';
  // Pug는 기본 이스케이프! != 사용 시만 비이스케이프임
  res.render('greet', { name });
});
// views/greet.pug
// h1 Hello #{name}
```

**체크포인트**  
- 입력: 길이·형식·범위 화이트리스트(숫자·UUID·ISO 날짜).  
- 출력: **컨텍스트 인코딩**(HTML/Attr/JS/URL), 템플릿 기본 이스케이프.

---

## 3.2 CSRF 방어

### [Flask] CSRF 토큰
```python
# pip install flask-wtf
from flask_wtf.csrf import CSRFProtect
csrf = CSRFProtect(app)

@app.post("/account/email")
def change_email():
    # CSRF 토큰 자동 검증
    ...
```

**기본 원칙**  
- 상태변경은 **POST/PUT/DELETE** + CSRF 토큰.  
- **SameSite=Lax/Strict** 쿠키, API는 **Bearer Token**로 분리.

---

## 3.3 인증/세션/JWT

### [Python] 비밀번호 해시(Argon2)
```python
# pip install argon2-cffi
from argon2 import PasswordHasher
ph = PasswordHasher()  # 기본 파라미터는 현대 HW 기준 안전
hash_ = ph.hash("user-plain-password")
ph.verify(hash_, "user-plain-password")
```

### [Node] JWT 검증 주의(iss/aud/exp/alg)
```javascript
// npm i jsonwebtoken jwks-rsa
const jwt = require('jsonwebtoken');
const jwksClient = require('jwks-rsa');
const client = jwksClient({ jwksUri: 'https://idp.example.com/jwks.json' });

function getKey(header, callback){
  client.getSigningKey(header.kid, (err, key) => {
    callback(null, key.getPublicKey());
  });
}
function verifyJWT(token){
  return new Promise((resolve,reject)=>{
    jwt.verify(token, getKey, {
      algorithms: ['RS256'],
      audience: 'orders-api',
      issuer: 'https://idp.example.com'
    }, (err, decoded) => err ? reject(err) : resolve(decoded));
  });
}
```

**원칙**  
- **짧은 수명 Access**, Refresh는 **회전(1회용)**.  
- 쿠키는 `Secure; HttpOnly; SameSite`.

---

## 3.4 접근제어(수평/수직, IDOR)

### [Express] 오브젝트 레벨 권한검사
```javascript
app.get('/orders/:id', async (req,res)=>{
  const userId = req.user.sub; // JWT subject
  const order = await db('orders').where({ id: req.params.id, owner_id: userId }).first();
  if(!order) return res.status(404).end();
  res.json(order);
});
```

**반패턴**: `/orders/:id`에서 **id만 검사** → 다른 사용자 주문 노출(=IDOR).  
**대원칙**: **서버측 소유권** 또는 **정책(ABAC/RBAC)** 검증.

---

## 3.5 파일 업로드/경로탐색(Path Traversal)

### [Spring Boot] 안전한 다운로드
```java
@GetMapping("/download")
public ResponseEntity<Resource> download(@RequestParam("name") String name) {
  Path base = Paths.get("/var/app/files").toAbsolutePath().normalize();
  Path cand = base.resolve(name).normalize();
  if(!cand.startsWith(base)) return ResponseEntity.status(400).build(); // ../ 차단
  Resource file = new FileSystemResource(cand.toFile());
  return ResponseEntity.ok()
    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + file.getFilename() + "\"")
    .body(file);
}
```

**추가**  
- **MIME 스니핑 금지** 헤더, 크기 제한, **Magic Number 검사**.

---

## 3.6 SSRF 방어

### [Python/requests] 아웃바운드 허용리스트
```python
import ipaddress, requests, socket

ALLOW_HOSTS = {"api.payments.example", "maps.example"}
def is_safe_host(host):
    try:
        ip = ipaddress.ip_address(socket.gethostbyname(host))
        return not (ip.is_private or ip.is_loopback or ip.is_link_local)
    except Exception:
        return False

def safe_get(url):
    host = url.split("/")[2].split(":")[0]
    if host not in ALLOW_HOSTS: raise ValueError("blocked host")
    if not is_safe_host(host): raise ValueError("private address blocked")
    return requests.get(url, timeout=3, allow_redirects=False)
```

---

## 3.7 커맨드 인젝션 방지

### [Python] shell=False, 인자 분리
```python
import subprocess
def safe_ls(path):
    return subprocess.check_output(["/bin/ls", "--", path], text=True)
```

---

## 3.8 역직렬화(Deserialization) 위험

### [Java] ObjectInputStream 대체/화이트리스트
```java
// 금지: new ObjectInputStream(in).readObject();
var mapper = new com.fasterxml.jackson.databind.ObjectMapper();
MyDto dto = mapper.readValue(in, MyDto.class); // 명시적 타입만 허용
```

---

## 3.9 암호화 사용 원칙

- **알고리즘**: AES-GCM/ChaCha20-Poly1305, Ed25519/ECDSA, ECDH(P-256+).  
- **랜덤**: **CSPRNG** 사용.  
- **키관리**: HSM/KMS/비밀관리(회전·권한 최소화).  
- **비교**: **상수시간 비교**.

### [Python] AES-GCM 예
```python
# pip install cryptography
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os
key = AESGCM.generate_key(bit_length=256)
aes = AESGCM(key)
nonce = os.urandom(12)
ct = aes.encrypt(nonce, b"secret data", b"aad")
pt = aes.decrypt(nonce, ct, b"aad")
```

### [Python] 상수시간 비교
```python
import hmac
def safe_eq(a: bytes, b: bytes) -> bool:
    return hmac.compare_digest(a, b)
```

---

## 3.10 정규식 DoS(“ReDoS”) 방지
```python
import re
# ❌ (a+)+ 같은 catastrophic backtracking 금지
SAFE = re.compile(r"^[a-z0-9_-]{3,32}$")  # 명확한 앵커·수량자
```

---

## 3.11 로깅·프라이버시

- **PII·비밀** 로그 금지(토큰·비번·카드).  
- **구조화 로그**(JSON), **Request ID/Trace ID** 포함, **시간 동기화(NTP)**.

```json
{"ts":"2025-11-04T01:15:22+09:00","severity":"INFO","req_id":"abc123","actor":"user:42","action":"order.create","result":"ok"}
```

---

## 3.12 C/C++ 메모리 안전(개요)

### 위험 반패턴
```c
// ❌ 버퍼 오버플로
char buf[16];
strcpy(buf, user_input); // 크기 미검증
```

### 대안
```c
// ✅ 길이 검사 + 안전 대체, 혹은 C++ std::string 사용
strncpy(buf, user_input, sizeof(buf)-1);
buf[sizeof(buf)-1] = '\0';
```
- 가능하면 **현대 C++ 컨테이너**, 더 안전한 언어(Rust/Go) 고려.  
- **ASLR/DEP/Fortify** 컴파일 옵션 사용.

---

# 4) 의존성·공급망 보안(DevSecOps)

## 4.1 SCA/SBOM
- Python: `pip-audit`, `pip freeze > requirements.txt`, `cyclonedx-bom`.  
- Node: `npm audit`, `npm pkg set engines`.  
- Gradle/Maven: OWASP Dependency-Check.

## 4.2 GitHub Actions 파이프라인(예)

```yaml
name: ci-secure
on: [push, pull_request]
jobs:
  build-test-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with: { python-version: '3.12' }
      - run: pip install -r requirements.txt
      - run: pytest -q
      - name: SAST (Semgrep)
        uses: returntocorp/semgrep-action@v1
        with: { config: p/owasp-top-ten }
      - name: Secrets Scan
        uses: zricethezav/gitleaks-action@v2
      - name: SCA (pip-audit)
        run: pip install pip-audit && pip-audit --strict
      - name: SBOM
        run: pip install cyclonedx-bom && cyclonedx-py --format json --outfile sbom.json
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with: { name: sbom, path: sbom.json }
```
- **가드레일**: High/Critical 발견 시 **빌드 실패**.

## 4.3 컨테이너 보안

### Dockerfile 베스트프랙티스
```dockerfile
FROM python:3.12-slim AS base
RUN useradd -m appuser
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
USER appuser
EXPOSE 8080
CMD ["gunicorn","-b","0.0.0.0:8080","app:app","--workers","2","--threads","4"]
```
- 비루트, 슬림 베이스, 소유권/권한, **애플리케이션 전용 포트만 노출**.  
- 이미지 스캔(Trivy/Grype), 서명(Cosign), 프로비넌스(SLSA).

## 4.4 IaC 스캔(Terraform)
```bash
# tfsec 또는 checkov 활용
tfsec .
# 예: 0.0.0.0/0 인바운드 허용 감지
```

---

# 5) 테스트·검증(DAST/IAST/Fuzz)

## 5.1 Fuzz(속성 기반 테스트)
```python
# pip install hypothesis
from hypothesis import given, strategies as st
import urllib.parse

@given(st.text(alphabet=st.characters(blacklist_categories=('Cs',)), min_size=0, max_size=50))
def test_urlencode_no_exception(s):
    urllib.parse.quote_plus(s)  # 예외 없이 동작해야 함
```

## 5.2 DAST 포인트
- 인증 흐름 포함, 세션/권한 전이 확인(“수평/수직”).  
- **블라인드 SSRF** 탐지 준비(콜백 엔드포인트).  
- 결과는 **위협모델·ASVS 요구**와 **트레이서빌리티** 유지.

---

# 6) 예제 시나리오 — “주문 API” 보안 점검 To-Do

1) **ASVS 매핑**: 인증/세션/액세스컨트롤/입력검증/암호화 스토리지/로깅.  
2) **위협모델링**: DFD, STRIDE, High 3건 식별(SSRF, IDOR, JWT 검증 미흡).  
3) **코드 수정**: SSRF 허용리스트, 오브젝트 권한검사, JWT iss/aud/exp/kid 검증.  
4) **테스트**: 단위·통합 + DAST(권한 테스트, 경계 테스트).  
5) **파이프라인**: SAST/SCA/Secrets/Git 서명, SBOM 산출.  
6) **운영**: 구조화 로그, 알람(403/401 비율 급증, 5xx 급증), 대시보드.

---

# 7) 체크리스트(현장용)

### 설계/위협모델
- [ ] DFD에 **신뢰경계** 표기  
- [ ] STRIDE 6대 위협, **완화 매핑**  
- [ ] 외부 통신: **인증/암호화/mTLS/허용리스트**

### 구현/코드
- [ ] 파라미터 바인딩(ORM/프리페어드)  
- [ ] 템플릿 **기본 이스케이프** / JSON 직렬화  
- [ ] CSRF 토큰 / SameSite  
- [ ] 파일 업/다운: 타입·크기·경로검증  
- [ ] 인증: **Argon2/bcrypt**, 2FA 선택  
- [ ] JWT: iss/aud/exp/nbf/alg, 키회전  
- [ ] 시크릿: **env/전용 비밀관리**, 레포 금지  
- [ ] 로깅: PII 마스킹, TraceID

### 테스트/배포
- [ ] SAST/SCA/Secrets 스캔 **빌드 게이트**  
- [ ] DAST(인증/권한 포함)  
- [ ] SBOM 산출/보관, 서명/프로비넌스  
- [ ] IaC/컨테이너 스캔  
- [ ] 런북(사고대응·비상차단)

---

# 8) 연습 문제(예상형)

### 객관식(발췌)
1) STRIDE에서 Tampering 대응으로 적절치 않은 것은?  
A. 무결성 체크섬  B. 서명  C. 입력 인코딩  D. mTLS  
**정답**: C(출력 인코딩은 XSS 맥락, Tampering은 무결성/서명/mTLS)

2) JWT 검증에서 필수 항목이 아닌 것은?  
A. aud  B. exp/nbf  C. iss  D. sub 길이  \*  
**정답**: D(식별자 길이는 정책일 뿐 필수 검증 필드 아님)

3) SSRF 완화 **핵심**은?  
A. 클라이언트 타임아웃  B. 서버측 허용리스트 + 사설대역 차단  C. 리다이렉션 허용  D. 큰 버퍼  
**정답**: B

### 서술형
- “IDOR를 탐지하고 방어하는 서버측 설계·코드 원칙을 기술하라.”  
  - **모범키워드**: 오브젝트 소유권 확인, **서버측 조회 조건**에 `owner_id=:me`, 캐시 고려, 목록 필터.

### 로그 해석
```
2025-11-04T01:12:11Z INFO allow path=/orders/101 actor=user:55
2025-11-04T01:12:12Z WARN deny path=/orders/102 actor=user:55 reason=ownership_mismatch
```
- **질문**: 어떤 공격을 차단했는가?  
  - **정답**: **IDOR** 시도(다른 주문 ID 접근).

---

# 9) 보너스: 수학으로 보는 보안 직관

### 9.1 패스워드 엔트로피(간단)
$$
H \approx L \cdot \log_2 |\Sigma|
$$
- 길이 \(L=14\), 문자 집합 62 → \(H \approx 14 \cdot \log_2 62 \approx 83 \) bits.

### 9.2 리스크 리덕션
- 완화 후 리스크 \(R' = p' \cdot i\), 여기서 \(p' = p \cdot (1-c)\), \(c\)는 통제효과.  
- **여러 통제 병렬**: \(p' = p \prod_j (1-c_j)\).

---

# 10) 레퍼런스 아키텍처 스냅샷

- **프록시/WAF 전단**: HSTS, TLS 1.3, JWT 검증, 레이트리밋, IP 허용리스트(관리).  
- **백엔드**: mTLS, 서비스 계정(ID), **권한검사 미들웨어** 공통화.  
- **데이터**: 최소 권한(DB 롤), **서버측 계산**(가격/권한/상태), **암호화 at-rest**(KMS).

---

# 11) 미니 실습 번들(요약 과제)

1) **위협모델 작성**: DFD + STRIDE 10개 위협 + 완화 매핑표.  
2) **코드 고치기**: (a) SQLi (b) IDOR (c) SSRF 반패턴 → 안전 패턴으로 교체.  
3) **파이프라인**: Semgrep/SCA/Secrets + SBOM + 빌드 게이트.  
4) **테스트**: 권한 경계 테스트(관리자/일반자 분리), fuzz 10분.

---

## 마무리

- 보안은 **사후 검사**가 아니라 **설계·코드·파이프라인·운영**에 내장되는 습관입니다.  
- 위협모델링으로 “무엇이 위험한지”를 합의하고, 안전한 코딩으로 “어떻게 막는지”를 코드에 새기며,  
  DevSecOps 파이프라인으로 **자동 가드레일**을 세우면 팀 전체의 **기본선**이 올라갑니다.