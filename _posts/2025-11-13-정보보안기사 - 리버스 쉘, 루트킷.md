---
layout: post
title: 정보보안기사 - 리버스 쉘, 루트킷
date: 2025-11-13 23:25:24 +0900
category: 정보보안기사
---
# SECTION 15 침해사고 유형별 시나리오 — 01. 리버스 쉘(Reverse Shell) · 02. 루트킷(Rootkit)

## 공통: 용어·범주

| 용어 | 의미 |
|---|---|
| **IOC** | Indicator of Compromise. 침해 정황을 드러내는 파일 해시, 도메인, IP, 레지스트리, 명령행 등 |
| **TTP** | Tactics/Techniques/Procedures. 공격자 전술/기술/절차(예: MITRE ATT&CK) |
| **EDR/XDR** | 엔드포인트 가시화·탐지·대응 플랫폼 |
| **SIEM** | 보안 이벤트 수집·상관분석·경보·대시보드 |
| **Containment** | 감염 확산 방지(네트워크 차단, 계정 잠금 등) |
| **Eradication** | 원인 제거(악성 파일 삭제, 악성 서비스/계정 제거 등) |
| **Recovery** | 정상화(클린 빌드/이미지 복구, 모니터링 상향) |

---

## 시나리오 01 — 리버스 쉘(Reverse Shell) 침해

### 개념 요약

- **공격 의도**: 내부 시스템이 외부 C2(공격자 제어 호스트)로 **나가는 연결**을 만들어, 원격 셸/명령 수행 통로를 확보.
- **유입 벡터(예)**: 웹 RCE 취약점, 잘못된 작업 스케줄러(크론/태스크), 피싱 매크로, 취약 서비스 구성, 악성 PowerShell 스크립트.
- **방어 관점 핵심**: (1) **비정상 네트워크 egress** 탐지, (2) **비정상 셸 스폰 트리**(부모→자식 관계), (3) **희귀 명령행 인자**, (4) **임시 디렉터리/프로필 경로에서의 실행**, (5) **보안 제품 예외 오남용**.

---

### 전형적 TTP (요약 매핑)

| 단계 | 예시 TTP(방어자 관점 설명) |
|---|---|
| 실행 | 스크립트 엔진(파워셸/스크립트 인터프리터)로 네트워크 연결 후 셸 바인딩/프록시 |
| 권한 상승 | 스케줄러 하이재킹, 서비스 권한 오남용, UAC 우회 시도 흔적 |
| 지속성 | 사용자/시스템 런 섹션, 스케줄러, 서비스, 프로파일 스크립트에 로더 추가 |
| C2 | 외부 IP:포트로 장기적 세션 유지(암호화/인코딩/프록시) |
| 회피 | AMSI/ETW 우회, 보안 제품 예외 등록, 명령행 난독화 |

> **주의**: 공격 명령의 구체 옵션(예: 특정 셸 인자)은 여기서 다루지 않음. 대신 **탐지 신호**를 중점화.

---

### 가시성 모델(프로세스/네트워크/파일/로그)

```
[취약 프로세스] -> [스크립트 해석기] -> [셸(spawn)] -> [비정상 외부 연결]
          |               |                    |
          |               |                    +-- [Parent-Child Chain: websvc -> script -> shell]
          |               +-- [인코딩/압축 흔적(Base64, Gzip), 다운로드/메모리로드]
          +-- [웹/앱 로그: RCE 의심 페이로드 흔적, 500/404/장시간 응답]
```

---

### 감지(Detection) — SIEM/EDR 룰 아이디어

#### (A) 리눅스: “네트워크 연결 직전/직후 셸 스폰 + 희귀 부모”

- 조건 예시(개념):
  - `/usr/bin/bash` 또는 `/bin/sh`가 **웹 서버 프로세스**(nginx/apache/php-fpm) 또는 `python/node/java` 등 **앱 런타임**의 자식으로 스폰
  - 같은 트랜잭션 윈도우 내에 **외부 IP**로의 `ESTABLISHED` 소켓 생성
  - 명령행에 난독화/인코딩 흔적(긴 Base64, `from base64 import`, `-EncodedCommand` 유사 문자열) 포함

```pseudo
RULE linux_reverse_shell_suspect
WHEN process_spawn(
       child_name in ["bash","sh","dash","ksh","zsh"],
       parent_name in ["nginx","apache2","httpd","php-fpm","uwsgi","gunicorn","node","java","python","perl"]
     )
AND  net_event(child_pid).dst_ip not in RFC1918
AND  time_window <= 5s
THEN alert("Possible reverse shell from web/app process")
```

#### (B) 윈도우: Sysmon 기반(개념 룰)

- **Event ID 1**(Process Create): `powershell.exe`, `wscript.exe`, `cscript.exe`, `cmd.exe`가 **IIS/톰캣/노드** 등 앱 런타임의 자식
- **Event ID 3**(Network Connection): 위 프로세스의 외부 연결(비표준 포트/국외 ASN)
- **Event ID 7/11**: DLL/파일 드롭 비정상 경로(`%TEMP%`, 사용자 프로필 숨김 폴더)

```xml
<!-- Sysmon concept: watch encoded/hidden PowerShell + net connections -->
<RuleGroup name="ReverseShellHunt" groupRelation="or">
  <ProcessCreate onmatch="include">
    <CommandLine condition="contains">-enc</CommandLine>
    <ParentImage condition="end with">w3wp.exe</ParentImage>
  </ProcessCreate>
  <NetworkConnect onmatch="include">
    <Image condition="end with">powershell.exe</Image>
    <DestinationIsIpv6 condition="is">true</DestinationIsIpv6>
  </NetworkConnect>
</RuleGroup>
```

> 실제 배포는 조직 표준 Sysmon 템플릿에 *우회 없는 범위*로 병합하고 **오탐 튜닝**을 수행한다.

---

### 네트워크 탐지(IDS/프록시/방화벽)

- **브라우저가 아닌** 서버 측 프로세스가 **외부로 TCP 아웃바운드**(특히 고용량 상주 연결, 비표준 포트) → 프록시/방화벽 egress 로그 상관.
- **DNS**: 희귀 TLD, 빠른 플럭스, 동일 호스트가 짧은 시간 내 다양한 서브도메인 질의.
- **TLS 지문**(JA3/JA3S): 서버 측 표준과 상이한 클라이언트 핸드셰이크 패턴.

```yaml
# (개념) Suricata 룰 스니펫 — 서버에서 외부로 비정상 셸 인터프리터 유사 UA/TLS 핑거프린트 탐지(구체 값은 예시)

alert tls any $HOME_NET -> any any (
  msg:"Outbound TLS with rare JA3 from server role";
  ja3_hash; content:"|12 34 56 78 9A|"; nocase;
  flow:established,to_server; sid:420001; rev:1;
)
```

> 실제 운영에서는 **조직 표준 JA3 화이트리스트**를 만든 뒤 **비정상만 경보**하는 방식이 효과적.

---

### 로그 예시(모의) & 파서

#### (A) Nginx 액세스 로그(의심 요청)

```
203.0.113.45 - - [12/Nov/2025:02:11:08 +0900] "POST /api/run HTTP/1.1" 200 123 "-" "Python-urllib/3.11"
203.0.113.45 - - [12/Nov/2025:02:11:08 +0900] "POST /api/run HTTP/1.1" 500 17 "-" "-"
```
- 동일 시각 **500 응답**과 **비브라우저 UA**(자동화 스크립트) 혼재 → **RCE 시도** 의심.

#### (B) Linux `auditd`(프로세스/네트워크)

```
type=EXECVE msg=audit(1731345068.441:812): argc=3 a0="/bin/sh" a1="-c" a2="(base64… | sh)"
type=SYSCALL msg=audit(1731345068.442:813): comm="sh" exe="/bin/sh"
type=SOCKADDR msg=audit(1731345068.447:814): saddr=10.10.20.5->198.51.100.77:4488
```
- Base64 인코딩 파이프라인 + 외부 IP:포트로 연결.

#### (C) 간단 파서(파이썬) — 모의 로그에서 이상 후보 추출

```python
import re, sys

nginx_re = re.compile(r'(?P<ip>\S+) .* "(?P<method>GET|POST) (?P<path>\S+) .*" (?P<status>\d{3}) .* "(?P<ua>[^"]*)"')
sus = []

for line in sys.stdin:
    m = nginx_re.search(line)
    if not m: continue
    ua = m.group('ua')
    status = int(m.group('status'))
    if "urllib" in ua.lower() or "curl" in ua.lower() or status >= 500:
        sus.append(line.strip())

print("\n".join(sus))
```

---

### 조사(분석) 체크리스트

- **프로세스 체인**: 부모-자식 트리(웹/앱 → 스크립트 → 셸). 명령행 길이·인자·인코딩 확인.
- **네트워크 세션**: 외부 연결 IP/포트/ASN, DNS 질의 타임라인.
- **파일 아티팩트**: `/tmp`, 사용자 프로필, 웹 루트 하위 `.well-known/`, `uploads/` 등 **의심 실행 가능 파일**.
- **지속성**: `crontab -l`, `/etc/cron.*`, `systemd` 유닛, 윈도우 런키/스케줄러/서비스.
- **자격증명**: 최근 로그인 시도, SSH `authorized_keys` 비정상 추가 여부.

---

### 대응(Containment/Eradication/Recovery)

1. **격리**: EDR 네트워크 격리, 방화벽 임시 차단(해당 호스트 egress 제한).
2. **계정 보호**: 관련 계정 암호 재설정·세션 무효화(MFA 강제).
3. **근절**: 악성 파일 삭제, 스케줄러/서비스 제거, 레지스트리/런키 정리, 프록시 예외 회수.
4. **취약점/원인 해결**: 웹·앱 패치, 업로드 디렉터리 실행 금지, WAF 룰 추가, PowerShell 제한(Constrained Language Mode 등).
5. **복구**: 클린 이미지 재배포(서버), 구성 코드 재적용, 모니터링 상향.
6. **사후학습**: 룰/대시보드 업데이트, 플레이북 보완, 개발·운영 팀 피드백 루프.

---

### 현장 자동화 예시(무해한 수준의 헌팅 스크립트)

#### (A) 리눅스 — “웹 계열 부모의 셸 스폰” 헌팅(개념)

```bash
# 부모/자식 프로세스 체인을 간략 점검(의심 후보만 출력)

ps -eo pid,ppid,comm,args --sort=ppid \
| awk '/(nginx|apache2|httpd|php-fpm|gunicorn|uwsgi|node|java|python)/ && /(sh|bash|dash|zsh)/'
```

#### (B) 윈도우 — PowerShell(무해한 조사 스니펫)

```powershell
# IIS 워커(w3wp)나 톰캣(java) 자식으로 생성된 쉘/스크립트 엔진 나열

Get-CimInstance Win32_Process |
  Where-Object {
    ($_.ParentProcessId -ne 0) -and
    (($_.Name -match 'powershell|cmd|wscript|cscript') -and
     (Get-Process -Id $_.ParentProcessId -ErrorAction SilentlyContinue).Name -match 'w3wp|java|node|python')
  } |
  Select-Object ProcessId, Name, CommandLine, ParentProcessId
```

---

## 시나리오 02 — 루트킷(Rootkit) 침해

### 개념 요약

- **루트킷**: 시스템의 **존재 은닉** 및 **권한 유지**를 위해, 사용자/커널 공간에서 프로세스·파일·네트워크·로그를 조작.
- **종류**: 사용자 공간(명령 대체/LD_PRELOAD), 커널 모듈형(LKM), 부트/펌웨어 레벨(고도화).
- **방어 핵심**: **선제 무결성(베이스라인)** + **행위 기반 이상 탐지** + **부트/커널 신뢰사슬(보안 부팅, ELAM/Device Guard)** + **신속한 재이미징**.

---

### 전형적 TTP & 징후(IOC)

| 관찰 지표 | 의심 신호 |
|---|---|
| 파일·프로세스 | `ps`, `ls`, `netstat` 결과 불일치, 숨김 파일/프로세스 |
| 커널 모듈 | `lsmod`에 보이지 않거나, 이름 위장/임의 심볼, dmesg에 이상 |
| 네트워크 | 특정 포트 은닉, RAW 소켓 후킹 |
| 로그 | 보안 로그 공백 구간, 특정 이벤트만 누락 |
| 무결성 | Tripwire/AIDE와 패키지 DB 해시 불일치 |
| 안정성 | 간헐적 커널 패닉/taint 플래그 |

---

### 감지(도구/체계)

- **정적·서명 기반**: `chkrootkit`, `rkhunter`(알려진 패턴·파일명·문자열).
- **무결성**: Tripwire/AIDE + 패키지 검증(`rpm -V`, `debsums`).
- **행위**: EDR 커널/사용자 후킹 이벤트, 시스템 호출 이상치(상용 솔루션).
- **부트 체인**: UEFI Secure Boot/TPM 측정값 변조 검출(엔터프라이즈 플랫폼).

> 서명 기반은 *오탐/미탐*이 가능. **교차 검증**이 필수.

---

### 모의 로그 & 교차 검증

#### (A) `chkrootkit` 출력(모의)

```
Checking `bindshell'... INFECTED (PORTS: 47017)
Checking `lkm'... suspicious
```
→ 즉시 확정 아님. 실제로는 합법 서비스가 해당 포트 사용 가능.

#### (B) 교차 검증 흐름(리눅스)

```bash
# 포트/프로세스 매핑

sudo ss -lntp | grep :47017
# 프로세스 바이너리 경로 확인

sudo readlink -f /proc/<PID>/exe
# 패키지 소속/무결성 검증

sudo dpkg -S /path/to/binary || sudo rpm -qf /path/to/binary
sudo debsums -s <pkg> || sudo rpm -V <pkg>
# 로드 모듈 이력/상태

sudo lsmod | head
sudo modinfo suspicious.ko
dmesg -T | egrep -i 'taint|module|hook|error|oops'
```

#### (C) 윈도우(개념) — ELAM/드라이버 검증

- **Event Viewer**: System → Code Integrity, Kernel-Boot 채널에서 드라이버 서명 오류·차단 이벤트 점검.
- **장치 가드 정책**: 허용 목록에 없는 드라이버 로드 시도 경보.

---

### 헌팅·수집 자동화(무해한 스크립트)

#### (A) 리눅스 — 모듈/무결성/네트워크 요약 컬렉터

```bash
#!/usr/bin/env bash

echo "# Modules (top10)"
lsmod | head

echo "# Kernel Messages (suspicious)"
dmesg -T | egrep -i 'taint|module|hook|error|oops' | tail -n 50

echo "# Listening sockets"
ss -lntp | awk '{print $1,$2,$3,$4,$5,$6}' | sed 1,1d

echo "# Package integrity (Debian-family)"
command -v debsums >/dev/null && debsums -s 2>/dev/null | head
```

#### (B) 윈도우 — 드라이버 서명 이슈 탐색(개념 PowerShell)

```powershell
Get-WinEvent -LogName "Microsoft-Windows-CodeIntegrity/Operational" -MaxEvents 200 |
  Where-Object { $_.Message -match "Driver" -and $_.Message -match "error|block|violation" } |
  Select-Object TimeCreated, Id, LevelDisplayName, Message
```

---

### 대응 전략(루트킷 특화)

1. **의심 수준 판단**: 사용자 공간? 커널/부트? → *커널/부트 의심*이면 **재이미징(클린 OS 재설치)** 우선 고려.
2. **격리**: 네트워크 차단, 계정 잠금, 크리덴셜 회수.
3. **증적 보존**: 디스크 이미지, 메모리 덤프(정책 허용 시), 로그 스냅샷, 모듈 바이너리 보존.
4. **근절**: 악성 모듈 제거 시도는 *불안정성 유발 가능*. **정상 이미지로 재구축**이 안전.
5. **재발 방지**: 보안 부팅/드라이버 서명 강제, 커널 모듈 로딩 정책(리눅스 LSM, `module.sig_enforce=1` 등 조직 정책에 맞게), EDR 확장 가시성.
6. **사후 검토**: 초기 유입점(취약 서비스/약한 자격증명)·수평 이동 흔적 정리.

---

## 통합 타임라인 예시(모의)

```
02:11:08  Nginx  POST /api/run 200 → 500 (UA: Python-urllib/3.11)
02:11:09  Linux  /bin/sh -c "..." spawned by php-fpm (auditd)
02:11:10  Net    10.10.20.5 → 198.51.100.77:4488 outbound established
02:11:12  EDR    Powershell.exe spawned by w3wp.exe (another host, lateral attempt)
02:20:43  chkrootkit  bindshell INFECTED on port 47017 (same host)  ← False Positive로 판정
02:25:00  Contain  Host isolated; creds rotated
03:10:00  Patch/Config  Web RCE fixed, upload exec disabled, WAF rule added
16:00:00  Rescan  High/Critical = 0, monitoring heightened
```

---

## 플레이북(요약 체크리스트)

### Reverse Shell 대응 체크리스트

- [ ] 비정상 셸 스폰(부모/자식) 및 외부 연결 상관 탐지 룰 활성
- [ ] 웹/앱 로그에서 비브라우저 UA + 5xx 스파이크 조회
- [ ] 업로드 디렉터리 실행 금지, WAF RCE 시그니처/가드
- [ ] PowerShell 제한(AMSI, Constrained Language Mode, Script Block Logging)
- [ ] egress 제어(서버 롤은 목적지 화이트리스트 원칙)
- [ ] 재현·재검증 시 동일 조건 스캔

### Rootkit 대응 체크리스트

- [ ] 서명 기반 점검(chkrootkit/rkhunter) + 무결성(AIDE/Tripwire) 동시 사용
- [ ] 패키지 DB 검증(rpm -V/debsums), 커널 메시지(dmesg) 정기 검토
- [ ] 보안 부팅/드라이버 서명 강제 정책 점검
- [ ] 감염 심각 단계(커널/부트)면 재이미징 원칙
- [ ] 원인(유입·지속성) 분석 및 방어 자산 업데이트

---

## 보고서 템플릿(재현 절차·영향·완화책)

| 항목 | 기재 내용 예시 |
|---|---|
| 개요 | “리버스 셸 시도로 판단되는 비정상 외부 연결과 셸 스폰 탐지” |
| 재현 절차(관찰) | 액세스 로그(UA/상태 코드), 프로세스 체인, 네트워크 세션, 이벤트 ID/Sysmon |
| 영향 평가 | 원격 명령 실행 가능성, 자격증명 유출 가능성, 수평 이동 리스크 |
| 근본 원인 | 웹 RCE 취약점(입력 검증 부재), 업로드 디렉터리 실행 허용 |
| 완화책 | 패치, 실행 금지, egress 제어, EDR 룰 추가, PowerShell 제한 |
| 재발 방지 | 보안 코딩/검수, CI/CD 자동 스캔, 정기 헌팅·무결성 검증 |
| 부록(IOC) | 의심 IP/도메인, JA3, 명령행 패턴, 파일 경로, 해시(정책 허용 범위) |

---

## 부록 — 교육용 모의 데이터 생성기(무해)

아래 파이썬은 **가짜(모의) 로그**를 만들고 간단한 헌팅을 적용한다. 실제 시스템에 영향 없음.

```python
import random, time, base64

def mock_nginx(n=50):
    uas = ["Mozilla/5.0", "curl/8.4.0", "Python-urllib/3.11"]
    paths = ["/", "/api/run", "/login", "/upload"]
    for _ in range(n):
        ip = f"203.0.113.{random.randint(1,254)}"
        path = random.choice(paths)
        ua = random.choice(uas)
        status = 200 if random.random() < 0.9 else random.choice([500,404])
        print(f'{ip} - - [12/Nov/2025:02:11:08 +0900] "POST {path} HTTP/1.1" {status} 123 "-" "{ua}"')

def hunt(lines):
    sus = []
    for line in lines:
        if "urllib" in line.lower() or "curl" in line.lower() or ' 500 ' in line:
            sus.append(line.strip())
    return sus

# generate & hunt

lines = []
for _ in range(60):
    lines.append('203.0.113.45 - - [12/Nov/2025:02:11:08 +0900] "POST /api/run HTTP/1.1" 500 17 "-" "-"')
lines.extend([ # normal-like
    '198.51.100.10 - - [12/Nov/2025:02:12:08 +0900] "GET / HTTP/1.1" 200 512 "-" "Mozilla/5.0"'
])
sus = hunt(lines)
print("\n".join(sus[:10]))
```

---

## 결론

- **리버스 쉘**은 “서버가 클라이언트처럼 외부로 연결하는” **행위 이상**으로 잡아야 한다. *프로세스 체인 + 네트워크 + 로그*의 **3점 교차**가 핵심.
- **루트킷**은 “보이지 않게 만드는 기술”. **무결성 베이스라인**과 **신뢰 사슬(보안 부팅/서명)** 없이는 완전한 확신 어렵다. **재이미징 원칙**을 명확히.
- 두 시나리오 모두, **자동화된 수집·핸드북화된 대응**과 **재검증 루프**가 성공을 좌우한다.

---
**면책**: 본 문서의 모든 예시/코드는 **방어·분석 목적의 모의 데이터/탐지 아이디어**이며, 침해 행위 유발·도구 악용을 의도·조장하지 않는다. 실제 테스트는 반드시 **명시적 허가**와 **격리된 환경**에서 수행해야 한다.
