---
layout: post
title: C++ - 포인터와 참조자
date: 2024-09-03 19:20:23 +0900
category: Cpp
---
# C++ 포인터와 참조자: 완전 가이드

## 왜 포인터와 참조자를 다시 이해해야 할까?

C++ 프로그래밍에서 값(value), 주소(address), 참조(reference)의 차이를 이해하는 것은 단순한 문법 이해를 넘어서 성능, 안전성, 코드 품질을 결정하는 핵심 요소입니다. 포인터와 참조자는 비슷해 보이지만 언어적 특성과 사용 제약에서 중요한 차이점이 있습니다. 여기에 rvalue 참조, 완전 전달(perfect forwarding), 스마트 포인터까지 더하면 실전 프로그래밍의 복잡도는 훨씬 증가합니다.

---

## 1. 포인터와 참조자의 기본 개념

### 포인터: 메모리 주소의 저장소

포인터는 메모리 주소를 저장하는 변수입니다. 변수의 메모리 위치를 직접 다룰 수 있게 해주며, 동적 메모리 할당과 데이터 구조 구현의 기반이 됩니다.

```cpp
#include <iostream>

int main() {
    int number = 42;
    int* pointer = &number;      // number 변수의 주소를 저장
    
    std::cout << "값: " << number << std::endl;
    std::cout << "주소: " << pointer << std::endl;
    std::cout << "역참조: " << *pointer << std::endl;
    
    *pointer = 100;              // 포인터를 통해 원본 값 변경
    std::cout << "변경 후 값: " << number << std::endl;
    
    // 널 포인터 (C++11 이후 권장)
    int* null_pointer = nullptr;
    if (null_pointer == nullptr) {
        std::cout << "널 포인터입니다." << std::endl;
    }
    
    return 0;
}
```

**포인터의 핵심 특성:**
- **재할당 가능**: 다른 변수의 주소로 변경할 수 있습니다.
- **널 가능**: 아무것도 가리키지 않음을 나타내는 `nullptr` 값을 가질 수 있습니다.
- **산술 연산 가능**: 포인터 연산을 통해 메모리를 탐색할 수 있습니다.
- **다단계 포인터**: 포인터의 포인터(`int**`)와 같은 복잡한 구조가 가능합니다.

### 참조자: 변수의 별칭

참조자는 다른 변수의 별칭(alias)으로, 원본 변수에 대한 또 다른 이름을 제공합니다. 참조자는 선언과 동시에 초기화되어야 하며, 한 번 초기화된 후에는 다른 변수를 참조할 수 없습니다.

```cpp
#include <iostream>

int main() {
    int original = 42;
    int& reference = original;   // reference는 original의 별칭
    
    std::cout << "원본: " << original << std::endl;
    std::cout << "참조자: " << reference << std::endl;
    
    reference = 100;              // 참조자를 통해 원본 값 변경
    std::cout << "변경 후 원본: " << original << std::endl;
    
    // 참조자는 반드시 초기화되어야 함
    // int& invalid_reference;  // 컴파일 오류!
    
    // 참조자는 재바인딩 불가
    int another = 200;
    // reference = another;      // 이건 대입 연산, 재바인딩이 아님
    // reference는 여전히 original을 참조
    
    return 0;
}
```

**참조자의 핵심 특성:**
- **널 불가**: 항상 유효한 객체를 참조해야 합니다.
- **재바인딩 불가**: 한 번 초기화되면 다른 객체를 참조할 수 없습니다.
- **문법 간결성**: 역참조 연산자(`*`) 없이 직접 사용할 수 있습니다.
- **의도 명확성**: 함수 인자에서 값 변경 여부를 명확히 표현할 수 있습니다.

---

## 2. 포인터 vs 참조자: 상세 비교

### 차이점 비교표

| 특성 | 포인터 | 참조자 |
|------|--------|--------|
| **초기화** | 초기화하지 않아도 됨 (위험) | 반드시 초기화해야 함 |
| **널 값** | `nullptr` 가능 | 널 불가 (언어적으로 보장) |
| **재할당** | 다른 주소로 변경 가능 | 다른 객체 참조 불가 |
| **메모리 사용** | 별도의 메모리 공간 차지 (주소 저장) | 구현에 따라 추가 메모리 사용 안 할 수 있음 |
| **문법** | `*`로 역참조, `&`로 주소 취득 | 변수처럼 직접 사용 |
| **연산** | 산술 연산 가능 | 일반 변수처럼 연산 |
| **다단계** | 포인터의 포인터 가능 | 참조자의 참조 불가 |
| **주요 용도** | 동적 메모리, 배열, C 호환성, 선택적 매개변수 | 함수 매개변수, 연산자 오버로딩, 반환값 최적화 |

### 실전 예제: 포인터와 참조자의 차이

```cpp
#include <iostream>

void modify_with_pointer(int* ptr) {
    if (ptr != nullptr) {
        *ptr = 100;  // 안전한 널 체크 후 접근
    }
}

void modify_with_reference(int& ref) {
    ref = 200;  // 널 체크 불필요 (참조자는 널일 수 없음)
}

int main() {
    int value = 42;
    
    // 포인터 사용: 명시적 널 체크 필요
    int* ptr = &value;
    modify_with_pointer(ptr);
    std::cout << "포인터 변경 후: " << value << std::endl;
    
    // 널 포인터 전달 가능
    modify_with_pointer(nullptr);  // 안전하게 처리됨
    
    // 참조자 사용: 더 간결한 문법
    modify_with_reference(value);
    std::cout << "참조자 변경 후: " << value << std::endl;
    
    // 참조자는 널이 될 수 없음
    // int& invalid_ref = nullptr;  // 컴파일 오류!
    
    return 0;
}
```

---

## 3. 함수 매개변수 전달 방식: 값, 포인터, 참조

함수에 매개변수를 전달하는 세 가지 주요 방식을 비교해봅시다. 각 방식은 성능, 안전성, 사용 편의성 측면에서 다른 특성을 가집니다.

```cpp
#include <iostream>
#include <vector>
#include <string>

// 1. 값에 의한 전달 (복사 발생)
void by_value(std::string str) {
    str = "변경됨";
    // 원본은 변경되지 않음 (복사본만 변경)
}

// 2. 포인터에 의한 전달 (명시적 널 체크 필요)
void by_pointer(std::string* str_ptr) {
    if (str_ptr != nullptr) {
        *str_ptr = "포인터로 변경";
    }
}

// 3. 참조자에 의한 전달 (가장 자연스러운 문법)
void by_reference(std::string& str_ref) {
    str_ref = "참조자로 변경";
}

// 4. const 참조자 (읽기 전용, 복사 비용 없음)
void read_only(const std::string& str) {
    std::cout << "읽기: " << str << std::endl;
    // str = "변경 시도";  // 컴파일 오류 (const)
}

// 5. rvalue 참조자 (임시 객체 전용)
void by_rvalue_reference(std::string&& str) {
    std::cout << "rvalue: " << str << std::endl;
    // 이동 의미론을 사용할 수 있음
}

int main() {
    std::string text = "원본";
    
    // 값 전달: 복사 발생
    by_value(text);
    std::cout << "값 전달 후: " << text << std::endl;
    
    // 포인터 전달: 명시적 주소 연산
    by_pointer(&text);
    std::cout << "포인터 전달 후: " << text << std::endl;
    
    // 참조자 전달: 가장 자연스러운 문법
    by_reference(text);
    std::cout << "참조자 전달 후: " << text << std::endl;
    
    // const 참조자: 읽기 전용 접근 (효율적)
    read_only(text);
    
    // rvalue 참조자: 임시 객체 전용
    by_rvalue_reference(std::string("임시 객체"));
    
    return 0;
}
```

### 선택 가이드라인

1. **값 전달을 사용할 때:**
   - 작은 기본 타입(`int`, `double`, `char` 등)
   - 객체의 복사 비용이 낮을 때
   - 원본을 변경하지 않아야 할 때

2. **const 참조자를 사용할 때:**
   - 큰 객체를 효율적으로 전달할 때
   - 읽기만 필요할 때
   - 복사 생성 비용이 높은 객체일 때

3. **참조자를 사용할 때:**
   - 객체를 수정해야 할 때
   - 널 가능성이 없는 매개변수일 때
   - 반환값과 함께 사용할 때 (출력 매개변수)

4. **포인터를 사용할 때:**
   - 선택적 매개변수 (널일 수 있는 경우)
   - C 스타일 API와의 호환성이 필요할 때
   - 배열을 전달할 때

---

## 4. const 정확성: 안전한 코드 작성의 핵심

const 정확성은 C++에서 코드의 안전성과 가독성을 높이는 중요한 개념입니다. const 키워드를 적절히 사용하면 의도하지 않은 수정을 방지하고 컴파일러 최적화를 도울 수 있습니다.

### 포인터와 const의 다양한 조합

```cpp
#include <iostream>

int main() {
    int value = 42;
    int another = 100;
    
    // 1. 가리키는 값이 상수 (값 변경 불가)
    const int* ptr_to_const = &value;
    // *ptr_to_const = 50;  // 컴파일 오류: 가리키는 값 변경 불가
    ptr_to_const = &another;     // OK: 포인터 자체는 변경 가능
    
    // 2. 포인터 자체가 상수 (주소 변경 불가)
    int* const const_ptr = &value;
    *const_ptr = 50;             // OK: 가리키는 값 변경 가능
    // const_ptr = &another;     // 컴파일 오류: 포인터 변경 불가
    
    // 3. 모두 상수
    const int* const const_ptr_to_const = &value;
    // *const_ptr_to_const = 60; // 컴파일 오류: 값 변경 불가
    // const_ptr_to_const = &another; // 컴파일 오류: 포인터 변경 불가
    
    // 4. 참조자와 const
    const int& const_ref = value;
    // const_ref = 70;           // 컴파일 오류: 참조자 통해 값 변경 불가
    
    std::cout << "값: " << value << std::endl;
    std::cout << "상수 참조: " << const_ref << std::endl;
    
    return 0;
}
```

### const 정확성의 실전 이점

```cpp
#include <iostream>
#include <vector>

class DataProcessor {
private:
    std::vector<int> data;
    
public:
    // const 멤버 함수: 객체 상태를 변경하지 않음을 보장
    void print() const {
        std::cout << "데이터 개수: " << data.size() << std::endl;
        // data.push_back(42);  // 컴파일 오류: const 함수 내부에서
                                // 비-const 멤버 함수 호출 불가
    }
    
    // 비-const 멤버 함수: 객체 상태 변경 가능
    void add_value(int value) {
        data.push_back(value);
    }
    
    // const 참조자 반환: 읽기 전용 접근 제공
    const std::vector<int>& get_data() const {
        return data;
    }
};

void process_const_object(const DataProcessor& processor) {
    // const 객체: const 멤버 함수만 호출 가능
    processor.print();
    // processor.add_value(10);  // 컴파일 오류
    
    const auto& data = processor.get_data();  // const 참조자 반환
    std::cout << "데이터 크기: " << data.size() << std::endl;
}

int main() {
    DataProcessor processor;
    processor.add_value(1);
    processor.add_value(2);
    processor.add_value(3);
    
    process_const_object(processor);
    
    return 0;
}
```

**const 정확성 원칙:**
1. 변경할 필요가 없는 모든 것은 const로 선언하세요.
2. 멤버 함수는 가능한 한 const로 만드세요.
3. 매개변수는 읽기만 필요하면 const 참조자로 전달하세요.
4. const 객체는 const 멤버 함수만 호출할 수 있습니다.

---

## 5. 수명 관리와 위험 패턴

포인터와 참조자를 사용할 때 가장 흔한 실수는 객체의 수명을 관리하지 못하는 것입니다. 댕글링 포인터/참조자는 미정의 동작을 일으키며, 디버깅하기 어려운 버그의 원인이 됩니다.

### 위험 패턴과 해결책

```cpp
#include <iostream>
#include <memory>
#include <vector>

// 1. 지역 변수의 참조 반환 (위험!)
const std::string& bad_return_reference() {
    std::string local = "지역 변수";
    return local;  // 함수 종료 시 local 파괴됨 → 댕글링 참조!
}

// 2. 올바른 반환 패턴
std::string good_return_by_value() {
    std::string local = "안전한 값";
    return local;  // RVO(Return Value Optimization)로 효율적 반환
}

// 3. 동적 할당 메모리 관리 (위험!)
void risky_dynamic_memory() {
    int* ptr = new int(42);  // 동적 할당
    
    // ... 여러 작업 ...
    
    // 메모리 누수 가능성: 예외 발생 시 delete 호출되지 않음
    // delete ptr;  // 누락 시 메모리 누수
}

// 4. 안전한 동적 메모리 관리
void safe_dynamic_memory() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    // 자동 메모리 관리: 함수 종료 시 자동 해제
    // 예외 발생해도 안전
}

// 5. 컨테이너 무효화 문제
void container_invalidation() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    int* first_element_ptr = &numbers[0];
    std::cout << "첫 번째 요소: " << *first_element_ptr << std::endl;
    
    // 많은 요소 추가 (재할당 발생 가능)
    for (int i = 0; i < 100; ++i) {
        numbers.push_back(i);
    }
    
    // 위험: 재할당 발생 시 이전 포인터 무효화
    // std::cout << "재할당 후: " << *first_element_ptr << std::endl;  // UB!
    
    // 안전한 접근
    std::cout << "안전한 접근: " << numbers[0] << std::endl;
}

int main() {
    // 안전한 코드
    std::string safe_result = good_return_by_value();
    std::cout << "안전한 반환: " << safe_result << std::endl;
    
    // 위험한 코드 (실행하지 마세요!)
    // const std::string& dangerous = bad_return_reference();
    // std::cout << dangerous << std::endl;  // 미정의 동작!
    
    safe_dynamic_memory();
    container_invalidation();
    
    return 0;
}
```

### 수명 관리 원칙

1. **지역 변수의 주소나 참조를 반환하지 마세요.** 함수가 종료되면 지역 변수는 소멸합니다.
2. **동적 메모리는 항상 스마트 포인터로 관리하세요.** `std::unique_ptr`이나 `std::shared_ptr`을 사용하면 자동으로 메모리가 관리됩니다.
3. **컨테이너 조작 시 무효화 규칙을 이해하세요.** `std::vector`의 `push_back()` 같은 연산은 기존 반복자와 포인터를 무효화할 수 있습니다.
4. **객체 수명을 문서화하세요.** API를 설계할 때, 반환된 포인터나 참조자의 유효 기간을 명확히 문서화하세요.

---

## 6. 배열과 포인터: 밀접한 관계

C++에서 배열과 포인터는 밀접하게 연관되어 있습니다. 배열 이름은 많은 상황에서 첫 번째 요소를 가리키는 포인터로 변환(decay)됩니다.

{% raw %}
```cpp
#include <iostream>

void process_array(int* arr, size_t size) {
    for (size_t i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

void process_array_reference(int (&arr)[5]) {
    // 배열 참조: 크기 정보 보존
    std::cout << "배열 크기: " << sizeof(arr) / sizeof(arr[0]) << std::endl;
    
    for (int value : arr) {
        std::cout << value << " ";
    }
    std::cout << std::endl;
}

int main() {
    int numbers[5] = {1, 2, 3, 4, 5};
    
    // 1. 배열 이름은 포인터로 decay
    int* ptr = numbers;  // &numbers[0]과 동일
    
    // 2. 포인터 산술을 통한 배열 접근
    std::cout << "포인터 산술:" << std::endl;
    for (int i = 0; i < 5; ++i) {
        std::cout << *(ptr + i) << " ";  // ptr[i]와 동일
    }
    std::cout << std::endl;
    
    // 3. 함수에 배열 전달 (포인터로 decay)
    process_array(numbers, 5);
    
    // 4. 함수에 배열 참조 전달 (크기 정보 보존)
    process_array_reference(numbers);
    
    // 5. 다차원 배열과 포인터
    int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
    int (*matrix_ptr)[3] = matrix;  // 3개 요소를 가진 배열에 대한 포인터
    
    std::cout << "다차원 배열:" << std::endl;
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 3; ++j) {
            std::cout << matrix_ptr[i][j] << " ";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```
{% endraw %}

**배열과 포인터 관계의 주요 점:**
1. 배열 이름은 대부분의 상황에서 첫 번째 요소의 포인터로 변환됩니다.
2. `sizeof(배열)`은 전체 배열의 바이트 크기를 반환하지만, `sizeof(포인터)`는 포인터 자체의 크기를 반환합니다.
3. 배열 참조(`int (&arr)[N]`)를 사용하면 컴파일 시간에 배열 크기를 알 수 있습니다.
4. C++11 이후에는 `std::array`를 사용하는 것이 더 안전하고 편리합니다.

---

## 7. 이동 의미론과 rvalue 참조자

C++11에 도입된 이동 의미론과 rvalue 참조자는 자원 관리를 효율적으로 만드는 중요한 기능입니다. 임시 객체의 자원을 "이동"하여 불필요한 복사를 피할 수 있습니다.

### 기본 개념

```cpp
#include <iostream>
#include <vector>
#include <string>

class ResourceHolder {
private:
    std::vector<int> data;
    std::string name;
    
public:
    // 기본 생성자
    ResourceHolder(std::string n) : name(std::move(n)) {
        std::cout << "생성: " << name << std::endl;
    }
    
    // 복사 생성자 (깊은 복사)
    ResourceHolder(const ResourceHolder& other) 
        : data(other.data), name(other.name + " (복사)") {
        std::cout << "복사 생성: " << name << std::endl;
    }
    
    // 이동 생성자 (자원 이동)
    ResourceHolder(ResourceHolder&& other) noexcept
        : data(std::move(other.data)), name(std::move(other.name)) {
        std::cout << "이동 생성: " << name << std::endl;
    }
    
    // 복사 대입 연산자
    ResourceHolder& operator=(const ResourceHolder& other) {
        if (this != &other) {
            data = other.data;
            name = other.name + " (복사 대입)";
            std::cout << "복사 대입: " << name << std::endl;
        }
        return *this;
    }
    
    // 이동 대입 연산자
    ResourceHolder& operator=(ResourceHolder&& other) noexcept {
        if (this != &other) {
            data = std::move(other.data);
            name = std::move(other.name);
            std::cout << "이동 대입: " << name << std::endl;
        }
        return *this;
    }
    
    // 소멸자
    ~ResourceHolder() {
        std::cout << "소멸: " << name << std::endl;
    }
    
    void add_data(int value) {
        data.push_back(value);
    }
    
    void print() const {
        std::cout << name << "의 데이터: ";
        for (int val : data) std::cout << val << " ";
        std::cout << std::endl;
    }
};

// lvalue 참조자 (일반 참조자)
void process_lvalue(ResourceHolder& holder) {
    std::cout << "lvalue 처리" << std::endl;
}

// rvalue 참조자 (임시 객체용)
void process_rvalue(ResourceHolder&& holder) {
    std::cout << "rvalue 처리" << std::endl;
    // holder는 임시 객체이므로 이동 가능
    ResourceHolder moved = std::move(holder);
}

int main() {
    std::cout << "=== 기본 예제 ===" << std::endl;
    
    ResourceHolder holder1("holder1");
    holder1.add_data(1);
    holder1.add_data(2);
    
    // lvalue: 이름이 있는 객체
    process_lvalue(holder1);
    
    // rvalue: 임시 객체
    process_rvalue(ResourceHolder("임시 객체"));
    
    std::cout << "\n=== 복사 vs 이동 비교 ===" << std::endl;
    
    // 복사 생성 (깊은 복사 발생)
    ResourceHolder holder2 = holder1;  // 복사 생성자 호출
    
    // 이동 생성 (효율적)
    ResourceHolder holder3 = std::move(holder1);  // 이동 생성자 호출
    
    // 이동 후 원본은 유효하지만 비어있음
    holder1.print();  // 비어있을 수 있음
    holder3.print();
    
    std::cout << "\n=== std::move의 올바른 사용 ===" << std::endl;
    
    // 올바른 std::move 사용
    ResourceHolder create_and_return() {
        ResourceHolder local("로컬 객체");
        local.add_data(42);
        return local;  // RVO(반환값 최적화) 발생 가능
        // return std::move(local);  // 이렇게 하면 RVO가 방해받을 수 있음!
    }
    
    auto returned = create_and_return();
    
    return 0;
}
```

### 완전 전달(Perfect Forwarding)

완전 전달은 함수 템플릿이 인자의 값 카테고리(lvalue/rvalue)를 보존하면서 다른 함수로 전달하는 기술입니다.

```cpp
#include <iostream>
#include <utility>

// 전달 참조(Forwarding Reference)와 완전 전달
template<typename T>
void wrapper(T&& arg) {
    // std::forward로 값 카테고리 보존
    process(std::forward<T>(arg));
}

// 오버로드된 함수
void process(int& x) {
    std::cout << "lvalue 처리: " << x << std::endl;
}

void process(int&& x) {
    std::cout << "rvalue 처리: " << x << std::endl;
}

// 완전 전달을 사용하는 팩토리 함수
template<typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

class Widget {
public:
    Widget(int a, const std::string& b) {
        std::cout << "Widget 생성: " << a << ", " << b << std::endl;
    }
};

int main() {
    int value = 42;
    
    // lvalue 전달
    wrapper(value);  // process(int&) 호출
    
    // rvalue 전달  
    wrapper(100);    // process(int&&) 호출
    
    // 완전 전달 팩토리 사용
    auto widget = make_unique<Widget>(10, "테스트");
    
    return 0;
}
```

**이동 의미론의 주요 원칙:**
1. 이동 생성자와 이동 대입 연산자는 `noexcept`로 선언하는 것이 좋습니다.
2. 이동 후 객체는 유효하지만 비어있는 상태가 됩니다.
3. `std::move`는 객체를 rvalue로 변환할 뿐, 실제 이동은 이동 생성자/대입 연산자가 수행합니다.
4. 함수에서 지역 변수를 반환할 때는 `std::move`를 사용하지 않는 것이 RVO 최적화에 유리합니다.

---

## 8. 스마트 포인터: 현대적인 메모리 관리

스마트 포인터는 동적 메모리 관리를 자동화하고 메모리 누수를 방지하는 C++의 핵심 기능입니다. C++11 이후 표준 라이브러리에 포함되었습니다.

### 세 가지 주요 스마트 포인터 비교

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Resource {
private:
    std::string name;
    
public:
    Resource(const std::string& n) : name(n) {
        std::cout << "리소스 생성: " << name << std::endl;
    }
    
    ~Resource() {
        std::cout << "리소스 소멸: " << name << std::endl;
    }
    
    void use() const {
        std::cout << "리소스 사용: " << name << std::endl;
    }
};

// 1. std::unique_ptr: 단일 소유권
void demonstrate_unique_ptr() {
    std::cout << "\n=== std::unique_ptr ===" << std::endl;
    
    // 생성 (make_unique 권장)
    std::unique_ptr<Resource> resource1 = std::make_unique<Resource>("고유 리소스");
    resource1->use();
    
    // 소유권 이동 (복사 불가)
    std::unique_ptr<Resource> resource2 = std::move(resource1);
    
    if (!resource1) {
        std::cout << "resource1은 이제 소유권이 없음" << std::endl;
    }
    
    if (resource2) {
        std::cout << "resource2가 소유권을 가짐" << std::endl;
        resource2->use();
    }
    
    // 함수에서 소유권 반환
    auto create_resource = []() -> std::unique_ptr<Resource> {
        return std::make_unique<Resource>("함수 생성 리소스");
    };
    
    auto returned_resource = create_resource();
    
    // 배열 지원
    std::unique_ptr<Resource[]> resource_array = 
        std::make_unique<Resource[]>(3);  // 3개의 Resource 배열
}

// 2. std::shared_ptr: 공유 소유권
void demonstrate_shared_ptr() {
    std::cout << "\n=== std::shared_ptr ===" << std::endl;
    
    // 생성 (make_shared 권장 - 더 효율적)
    std::shared_ptr<Resource> shared1 = std::make_shared<Resource>("공유 리소스1");
    
    // 참조 카운트 확인
    std::cout << "참조 카운트: " << shared1.use_count() << std::endl;
    
    // 복사 생성 (참조 카운트 증가)
    std::shared_ptr<Resource> shared2 = shared1;
    std::cout << "복사 후 참조 카운트: " << shared1.use_count() << std::endl;
    
    // 소유권 공유
    shared1->use();
    shared2->use();
    
    // 범위 벗어나면 참조 카운트 감소
    {
        std::shared_ptr<Resource> shared3 = shared2;
        std::cout << "내부 범위 참조 카운트: " << shared1.use_count() << std::endl;
    }
    
    std::cout << "내부 범위 종료 후 참조 카운트: " << shared1.use_count() << std::endl;
    
    // 순환 참조 문제
    struct Node {
        std::shared_ptr<Node> next;
        std::shared_ptr<Node> prev;
        int value;
        
        Node(int v) : value(v) {
            std::cout << "노드 생성: " << value << std::endl;
        }
        
        ~Node() {
            std::cout << "노드 소멸: " << value << std::endl;
        }
    };
    
    auto node1 = std::make_shared<Node>(1);
    auto node2 = std::make_shared<Node>(2);
    
    // 순환 참조 생성
    node1->next = node2;
    node2->prev = node1;
    
    // node1과 node2가 서로를 참조 → 참조 카운트가 0이 되지 않음
    // 메모리 누수 발생!
}

// 3. std::weak_ptr: 약한 참조 (순환 참조 해결)
void demonstrate_weak_ptr() {
    std::cout << "\n=== std::weak_ptr ===" << std::endl;
    
    std::shared_ptr<Resource> shared = std::make_shared<Resource>("약한 참조 대상");
    
    // weak_ptr 생성 (참조 카운트 증가 안 함)
    std::weak_ptr<Resource> weak = shared;
    
    std::cout << "weak_ptr 생성 후 참조 카운트: " << shared.use_count() << std::endl;
    
    // weak_ptr에서 shared_ptr 얻기
    if (auto locked = weak.lock()) {
        std::cout << "객체 아직 존재: ";
        locked->use();
    } else {
        std::cout << "객체 이미 소멸됨" << std::endl;
    }
    
    // shared_ptr 해제
    shared.reset();
    
    // 다시 확인
    if (auto locked = weak.lock()) {
        std::cout << "객체 아직 존재" << std::endl;
    } else {
        std::cout << "객체 소멸됨 (weak_ptr은 알아서 무효화)" << std::endl;
    }
    
    // 순환 참조 해결 예제
    struct SafeNode {
        std::shared_ptr<SafeNode> next;
        std::weak_ptr<SafeNode> prev;  // 약한 참조 사용
        int value;
        
        SafeNode(int v) : value(v) {
            std::cout << "안전 노드 생성: " << value << std::endl;
        }
        
        ~SafeNode() {
            std::cout << "안전 노드 소멸: " << value << std::endl;
        }
    };
    
    auto safe_node1 = std::make_shared<SafeNode>(1);
    auto safe_node2 = std::make_shared<SafeNode>(2);
    
    // 약한 참조로 순환 참조 방지
    safe_node1->next = safe_node2;
    safe_node2->prev = safe_node1;  // weak_ptr 사용
    
    // 메모리 누수 없음!
}

int main() {
    demonstrate_unique_ptr();
    demonstrate_shared_ptr();
    demonstrate_weak_ptr();
    
    return 0;
}
```

### 스마트 포인터 선택 가이드

| 상황 | 권장 스마트 포인터 | 이유 |
|------|-------------------|------|
| 단일 소유자 | `std::unique_ptr` | 가장 효율적, 오버헤드 없음 |
| 공유 소유권 필요 | `std::shared_ptr` | 여러 소유자가 객체를 공유할 때 |
| 순환 참조 가능성 | `std::weak_ptr` + `std::shared_ptr` | 순환 참조 방지 |
| C 스타일 API 호환 | `std::unique_ptr` + 커스텀 삭제자 | `delete` 외의 정리 함수 필요시 |
| 배열 관리 | `std::unique_ptr<T[]>` | 동적 배열 관리 |
| 성능이 중요한 코드 | `std::unique_ptr` | 참조 카운팅 오버헤드 없음 |

**스마트 포인터 사용 원칙:**
1. **새로운 코드에서는 `new`/`delete`를 직접 사용하지 마세요.** 항상 스마트 포인터를 사용하세요.
2. **`make_unique`와 `make_shared`를 선호하세요.** 예외 안전성이 더 좋고 효율적입니다.
3. **소유권을 명확히 표현하세요.** `unique_ptr`은 명확한 소유권을, `shared_ptr`은 공유 소유권을 나타냅니다.
4. **순환 참조를 주의하세요.** `shared_ptr`만 사용하면 메모리 누수가 발생할 수 있습니다. 필요한 곳에 `weak_ptr`을 사용하세요.

---

## 9. 실전 디자인 패턴과 모범 사례

### 패턴 1: PIMPL (Pointer to IMPLementation)

PIMPL 패턴은 클래스의 구현 세부사항을 헤더 파일에서 숨겨 컴파일 의존성을 줄이고 ABI 호환성을 유지합니다.

```cpp
// widget.h (헤더 파일)
#include <memory>

class Widget {
public:
    Widget();
    ~Widget();  // 소멸자 선언 필요
    
    void do_something();
    
    // 복사/이동 연산 (Rule of Five)
    Widget(const Widget&);
    Widget& operator=(const Widget&);
    Widget(Widget&&);
    Widget& operator=(Widget&&);
    
private:
    struct Impl;  // 전방 선언
    std::unique_ptr<Impl> pimpl;  // 구현 포인터
};

// widget.cpp (구현 파일)
#include "widget.h"
#include <iostream>
#include <vector>

// 구현 클래스 정의
struct Widget::Impl {
    std::vector<int> data;
    std::string name;
    
    void internal_method() {
        std::cout << "내부 메서드 호출" << std::endl;
    }
};

// 위젯 메서드 구현
Widget::Widget() : pimpl(std::make_unique<Impl>()) {
    pimpl->name = "위젯";
}

Widget::~Widget() = default;  // 소멸자 정의 (unique_ptr을 위해 필요)

// 복사 생성자
Widget::Widget(const Widget& other) 
    : pimpl(std::make_unique<Impl>(*other.pimpl)) {}

// 복사 대입 연산자
Widget& Widget::operator=(const Widget& other) {
    if (this != &other) {
        *pimpl = *other.pimpl;
    }
    return *this;
}

// 이동 생성자
Widget::Widget(Widget&& other) noexcept = default;

// 이동 대입 연산자  
Widget& Widget::operator=(Widget&& other) noexcept = default;

void Widget::do_something() {
    pimpl->internal_method();
    std::cout << pimpl->name << " 작업 수행" << std::endl;
}

// main.cpp
#include "widget.h"

int main() {
    Widget w1;
    w1.do_something();
    
    Widget w2 = w1;  // 복사
    Widget w3 = std::move(w1);  // 이동
    
    return 0;
}
```

### 패턴 2: 팩토리 메서드와 소유권 반환

```cpp
#include <memory>
#include <iostream>
#include <vector>

class Document {
public:
    virtual ~Document() = default;
    virtual void print() const = 0;
};

class PdfDocument : public Document {
public:
    void print() const override {
        std::cout << "PDF 문서 출력" << std::endl;
    }
};

class WordDocument : public Document {
public:
    void print() const override {
        std::cout << "Word 문서 출력" << std::endl;
    }
};

// 팩토리 함수: 소유권을 호출자에게 이전
std::unique_ptr<Document> create_document(const std::string& type) {
    if (type == "pdf") {
        return std::make_unique<PdfDocument>();
    } else if (type == "word") {
        return std::make_unique<WordDocument>();
    }
    return nullptr;
}

// 문서 관리자
class DocumentManager {
private:
    std::vector<std::unique_ptr<Document>> documents;
    
public:
    // 문서 추가 (소유권 이전)
    void add_document(std::unique_ptr<Document> doc) {
        if (doc) {
            documents.push_back(std::move(doc));
        }
    }
    
    // 모든 문서 출력
    void print_all() const {
        for (const auto& doc : documents) {
            doc->print();
        }
    }
    
    // 문서 검색 (비소유 포인터 반환)
    Document* find_document(size_t index) {
        if (index < documents.size()) {
            return documents[index].get();  // 소유권 없이 포인터만 반환
        }
        return nullptr;
    }
};

int main() {
    DocumentManager manager;
    
    // 팩토리에서 문서 생성 및 추가
    manager.add_document(create_document("pdf"));
    manager.add_document(create_document("word"));
    
    // 문서 출력
    manager.print_all();
    
    // 특정 문서 접근 (비소유 포인터)
    if (Document* doc = manager.find_document(0)) {
        doc->print();
    }
    
    return 0;
}
```

### 패턴 3: 관찰자 패턴과 약한 참조

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <algorithm>

class Observer;

// 관찰 대상
class Subject {
private:
    std::vector<std::weak_ptr<Observer>> observers;
    
public:
    void add_observer(std::weak_ptr<Observer> observer) {
        observers.push_back(observer);
    }
    
    void notify() {
        // 약한 참조 순회
        for (auto it = observers.begin(); it != observers.end();) {
            if (auto observer = it->lock()) {
                observer->update();
                ++it;
            } else {
                // 소멸된 관찰자 제거
                it = observers.erase(it);
            }
        }
    }
};

// 관찰자
class Observer : public std::enable_shared_from_this<Observer> {
public:
    void subscribe(Subject& subject) {
        subject.add_observer(weak_from_this());
    }
    
    virtual void update() = 0;
    virtual ~Observer() = default;
};

class ConcreteObserver : public Observer {
private:
    std::string name;
    
public:
    ConcreteObserver(const std::string& n) : name(n) {}
    
    void update() override {
        std::cout << name << "이(가) 업데이트 알림 받음" << std::endl;
    }
};

int main() {
    Subject subject;
    
    // 관찰자 생성
    auto observer1 = std::make_shared<ConcreteObserver>("관찰자1");
    auto observer2 = std::make_shared<ConcreteObserver>("관찰자2");
    
    // 구독
    observer1->subscribe(subject);
    observer2->subscribe(subject);
    
    // 알림
    subject.notify();
    
    // 관찰자 제거
    observer1.reset();
    
    // 다시 알림 (관찰자1은 자동으로 제거됨)
    subject.notify();
    
    return 0;
}
```

---

## 10. 결론: 현대 C++의 포인터와 참조자 철학

C++의 포인터와 참조자는 언어의 근본적인 개념으로, 메모리 관리와 객체 접근의 핵심 메커니즘을 제공합니다. 현대 C++ 프로그래밍에서는 이러한 기본 개념 위에 여러 레이어의 추상화가 구축되어 있습니다:

### 핵심 원칙 요약

1. **의도 표현이 최우선**
   - 읽기 전용 접근: `const T&`
   - 값 수정 필요: `T&`
   - 선택적 매개변수: `T*` (널 가능성 명시)
   - 소유권 이전: `std::unique_ptr<T>`
   - 공유 소유권: `std::shared_ptr<T>`

2. **안전성과 성능의 균형**
   - 참조자는 널 검사 없이 안전하게 사용할 수 있지만, 객체 수명 관리에 주의해야 합니다.
   - 스마트 포인터는 자동 메모리 관리를 제공하지만 약간의 오버헤드가 있습니다.
   - 기본 포인터는 성능이 중요하고 수명을 완전히 제어할 수 있을 때 사용합니다.

3. **모던 C++ 관용구 채택**
   - `new`/`delete` 대신 스마트 포인터 사용
   - `make_unique`/`make_shared`로 객체 생성
   - 이동 의미론으로 불필요한 복사 방지
   - 완전 전달로 효율적인 템플릿 코드 작성

4. **객체 수명 관리 철저히**
   - 댕글링 포인터/참조자 생성하지 않기
   - 컨테이너 무효화 규칙 이해하기
   - 순환 참조 방지를 위한 `weak_ptr` 사용

### 마지막 조언

포인터와 참조자의 세계는 처음에는 복잡해 보일 수 있지만, 기본 원칙을 이해하고 현대 C++의 도구들을 적절히 활용하면 강력하면서도 안전한 코드를 작성할 수 있습니다. 각 상황에 맞는 도구를 선택하는 능력이 전문 C++ 개발자의 핵심 역량입니다.

기억하세요: 좋은 C++ 코드는 단지 작동하는 코드가 아니라, 의도가 명확하고 안전하며 유지보수하기 쉬운 코드입니다. 포인터와 참조자를 올바르게 사용하는 것은 이러한 목표를 달성하는 데 중요한 첫걸음입니다.