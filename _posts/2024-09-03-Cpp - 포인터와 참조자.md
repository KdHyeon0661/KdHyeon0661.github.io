---
layout: post
title: C++ - 포인터와 참조자
date: 2024-09-03 19:20:23 +0900
category: Cpp
---
# 포인터와 참조자

## 개요 — 왜 다시 정리하나?

- C++에서 **값, 주소, 참조**의 차이는 **성능·안전성·추상화 품질**을 좌우한다.
- 포인터(pointer)와 참조자(reference)는 비슷해 보이지만 **언어적 성질**과 **제약**이 크게 다르다.
- 여기에 **rvalue 참조(&&)**, **완전 전달(perfect forwarding)**, **스마트 포인터**까지 더하면 실전 난이도가 급상승한다.
- 본 문서는 “**정의 → 차이 → 수명 → const 정확성 → 배열·함수 인자 → 고급 주제(rvalue/forwarding) → 스마트 포인터 비교 → 위험 패턴 점검표**” 순서로 다룬다.

---

## 기초

### 정의

- **메모리 주소를 저장하는 변수**.
- 선언형: `T* p;` (관용적으로 `T *p`도 쓰지만 통일을 권장)

```cpp
#include <iostream>

int main() {
    int a = 10;
    int* p = &a;         // a의 주소를 p에 저장
    std::cout << *p;     // 역참조 → 10
}
```

**핵심 용어**
- `&a` : a의 **주소**(address-of)
- `*p` : p가 가리키는 **값**(dereference)
- `nullptr` : **빈 주소**(C++11 이후), `NULL`/`0` 대신 사용

### 포인터 연산

- 증가/감소: `p++`, `p--` (포인터가 가리키는 **타입 크기**만큼 이동)
- 비교: 두 포인터는 **같은 배열/할당 블록 내부**일 때만 비교 의미가 정의됨
- 포인터 산술은 **배열·연속 메모리**에서만 안전

```cpp
int arr[3]{10,20,30};
int* p = arr;        // &arr[0]
*(p+1) = 99;         // arr[1] = 99
```

> **주의**: 포인터 산술은 **범위를 벗어나면 UB(미정의 동작)**. 검사 없는 인덱싱은 버그의 온상.

---

## 기초

### 정의

- **다른 변수의 별칭(alias)**.
- **반드시 초기화**해야 하며, **나중에 다른 대상을 재바인딩 불가**.

```cpp
int a = 10;
int& r = a;   // r은 a의 또 다른 이름
r = 20;       // a가 20으로 바뀜
```

### 성질

- **NULL 참조 없음**(언어 차원 가정). “빈 참조”를 인위적으로 만들면 UB.
- 문법이 간결: `*`/`&` 역참조/주소연산자 남발이 줄어듦.
- 함수 인자에서 **의도**가 드러남: “이 값을 바꾸려는가?”(비-const 참조) vs “읽기 전용인가?”(const 참조)

---

## 포인터 vs 참조자 — 차이 표 (보강)

| 구분 | 포인터 | 참조자 |
|---|---|---|
| 값의 정체 | “주소” 자체를 값으로 가짐 | 별칭(언어 차원에서 **널 아님**이 전제) |
| 재바인딩 | 가능(`p = &b;`) | 불가(초기 바인딩 고정) |
| null 가능 | 가능(`nullptr`) | 불가(정상 코드 기준) |
| 연산 | 포인터 산술, 비교 가능 | 일반 변수처럼 사용 |
| 구성원 | “포인터-포인터”, “포인터의 참조” 가능 | “참조의 참조”는 표면 문법상 없음(참조 붕괴 규칙) |
| 사용처 | 동적 메모리, C API, 배열, 소유권 표현 불가 | 인자 전달(읽기/쓰기), 연산자 오버로드, 반환 시 의도 전달 |

> 요약: **참조자는 “안전한 별칭”**, **포인터는 “주소 그 자체”**.
> 소유권을 표현하고 싶다면 **스마트 포인터**로 상위 추상화 사용.

---

## 값/포인터/참조 — 함수 인자 3종 비교

```cpp
void byValue(int x)      { x = 100; }       // 복사본만 변경
void byPointer(int* px)  { *px = 100; }     // 원본 변경 (nullptr 주의)
void byRef(int& x)       { x = 100; }       // 원본 변경 (널 없음)

int main() {
    int a = 10;
    byValue(a);    // a=10
    byPointer(&a); // a=100
    a = 10;
    byRef(a);      // a=100
}
```

**실전 팁**
- **읽기 전용 대용량 타입**은 `const T&`로 받으면 복사 비용 없이 안정적.
- 스칼라/작은 POD(예: `int`, `double`)는 값 전달이 더 단순하고 종종 더 빠르다(레지스터로 전달).
- **선택 기준**: 성능·의도·API 일관성.

---

## `const` 정확성 (const-correctness)

### 포인터와 const

| 선언 | 의미 |
|---|---|
| `const int* p` | **가리키는 값이 상수**. `*p` 수정 금지, 주소 변경은 가능 |
| `int* const p` | **포인터 자체가 상수**. 다른 곳 가리키기 불가, `*p` 수정 가능 |
| `const int* const p` | 둘 다 상수 |

```cpp
int x=1, y=2;
const int* p = &x; // *p 수정 불가
p = &y;            // OK (p는 바뀜)

int* const q = &x; // q는 고정
*q = 42;           // OK (*q 수정)
```

### 참조와 const

- `const T&` : **읽기 전용 참조**. 임시에 바인딩 허용(수명 연장, §7.2).

```cpp
std::string make();
const std::string& r = make(); // 임시의 수명 연장 (r의 수명까지)
```

> **규칙**: “변경 의도가 없다면 항상 `const`를 붙여라.” → API가 **명확**하고 **최적화 기회** 제공.

---

## 방지

### 잘못된 참조 반환

```cpp
const std::string& bad() {
    std::string s = "local";
    return s; // 지역 파괴 → 댕글링 참조 (UB)
}
```

### 올바른 반환 패턴

- **값 반환**: RVO/Move 최적화 → 비용 적음, 안전
- **소유권 이전**: `std::unique_ptr<T>` 반환

```cpp
std::string good() {
    std::string s = "ok";
    return s; // RVO
}
```

### 포인터/참조 보관 주의

- **원본 객체 수명**이 짧으면 보관 금지.
- 컨테이너 재할당 시 **내부 포인터/참조 무효화** 가능 → 문서 확인(`std::vector::push_back` 등).

---

## 참조의 특수 규칙 — 임시/수명 연장, 참조 붕괴

### const lvalue 참조와 임시

- `const T&`는 **rvalue(임시)** 에도 바인딩 → **임시 수명 연장**.

```cpp
const std::string& r = std::string("tmp"); // OK, 임시 수명 연장
```

### rvalue 참조(`T&&`)

- **이동语义**와 **완전 전달**의 기반.
- `T&&`는 **오직 rvalue**(임시/소모 가능 값)에 바인딩.

```cpp
void take(std::string&& s); // 이동 대상만
take(std::string("x"));     // OK
```

### 참조 붕괴 규칙 (Reference Collapsing)

$$
T\&  \&  \Rightarrow T\&,\quad
T\&  \&\&\Rightarrow T\&,\quad
T\&\&\& \Rightarrow T\&,\quad
T\&\&\&\&\Rightarrow T\&\&
$$

- 템플릿에서 `T&&`가 **전달 참조(Forwarding Reference)** 로 쓰일 때 `T`가 lvalue면 `T&`, rvalue면 `T&&`로 붕괴.

---

## 이동语义와 완전 전달(Perfect Forwarding)

### 이동语义 기본

```cpp
#include <utility>
#include <string>
#include <vector>

int main() {
    std::vector<std::string> v;
    std::string s = "payload";
    v.push_back(std::move(s)); // s의 내부 버퍼가 이동될 수 있음
}
```

- `std::move(x)`는 **x를 rvalue로 캐스트**만 함. 실제 이동은 타입의 **move ctor/assign**이 결정.

### 완전 전달

```cpp
#include <utility>

template<typename F, typename... Args>
auto call(F&& f, Args&&... args) {
    return std::forward<F>(f)(std::forward<Args>(args)...);
}
```

- **인자 카테고리(l/rvalue)** 를 보존하여 **가장 효율적 호출** 보장.

---

## 배열, 포인터, 참조 — 미묘한 점

### 배열의 포인터 decay

```cpp
int arr[3]{1,2,3};
int* p = arr;        // arr → &arr[0] 로 decay
```

### 배열 참조로 길이 보존

```cpp
template<size_t N>
void print_all(const int (&a)[N]) {        // 배열 참조
    for(size_t i=0;i<N;++i) std::cout<<a[i]<<" ";
}
```

### 함수 인자에서 `T*` vs `T(&)[N]`

- `T*`는 길이 정보가 **사라짐** → 별도 길이 전달 필요.
- 참조 시그니처(`T(&)[N]`)는 **컴파일 타임 길이 보존**.

---

## 동적 메모리와 스마트 포인터 대비

### `new/delete` 직접 사용 (교육용)

```cpp
int* p = new int(42);
delete p;
```

- **예외 안전/누수/예외 시 누락**에 취약 → 실전에서는 **스마트 포인터** 권장.

### `unique_ptr`/`shared_ptr` 핵심

```cpp
#include <memory>

std::unique_ptr<int> make() {
    return std::make_unique<int>(42); // 소유권 반환
}

int main(){
    auto sp = std::make_shared<int>(7);  // 공유 소유
}
```

| 타입 | 소유권 | 용도 |
|---|---|---|
| `unique_ptr<T>` | 단일 | 팩토리 반환, 명확한 수명 |
| `shared_ptr<T>` | 공유 | 다수 소유자, 사이클 주의 (`weak_ptr`) |
| `weak_ptr<T>` | 관찰자 | `shared_ptr` 순환 끊기, 존재 확인 |

> **규칙**: 새 코드에서 `new`/`delete`를 직접 노출하지 말자. **소유는 스마트 포인터, 비소유는 포인터/참조/`std::span`**로 표현.

---

## 함수 오버로드와 참조 — lvalue/rvalue 구분

```cpp
void f(const std::string& s) { std::cout << "lvalue\n"; }
void f(std::string&& s)      { std::cout << "rvalue\n"; }

int main(){
    std::string x = "hi";
    f(x);               // lvalue
    f(std::string("h"));// rvalue
    f(std::move(x));    // rvalue
}
```

- API에서 **소모 가능한 인자**(rvalue)와 **보존해야 하는 인자**(lvalue)를 분리해 최적화.

---

## 포인터 고급: 함수 포인터·멤버 포인터

### 함수 포인터

```cpp
int add(int a,int b){ return a+b; }
int (*pf)(int,int) = &add;
```

### 멤버 포인터

```cpp
struct S{ int mem(int x){return x;} };
int (S::*pm)(int) = &S::mem;

S s;
int v = (s.*pm)(3); // 호출
```

> 가독성·유연성 면에서 **람다/`std::function`** 이 더 나은 경우가 많다.

---

## 위험 패턴(안전 체크리스트)

- [ ] **댕글링 참조/포인터**: 지역 객체 주소/참조 보관 금지
- [ ] **이중 해제(double free)**: 동일 포인터 `delete` 두 번 금지 → 스마트 포인터 사용
- [ ] **nullptr 역참조**: 포인터 인자 사용 전 **널 검사**
- [ ] **범위 초과 접근**: 포인터 산술·인덱스 사용 시 범위 확인
- [ ] **const 누락**: 읽기만 하는 API에 `const` 적용
- [ ] **컨테이너 무효화 규칙 미숙지**: `vector` 재할당 후 이전 포인터/참조 사용 금지
- [ ] **엄격 별칭(Strict Aliasing) 위반**: 임의 타입 재해석 금지(필요시 `std::bit_cast`, `char` 예외 등 문서 확인)
- [ ] **스레드 안전성**: 포인터 공유 시 **동기화/수명 관리** 철저

---

## 사례로 보는 비교 — API 시그니처 설계

### 읽기 전용 대용량 객체

```cpp
void draw(const Image& img);       // 복사 없이 읽기
```

### 선택적 출력(out param)

```cpp
bool try_parse(std::string_view s, int& out); // 실패 시 out 변경 안 함(문서화)
```

### 소유권 반환

```cpp
std::unique_ptr<Node> make_node(...); // 호출자가 확실히 소유
```

### 다형성 + 비소유

```cpp
void render(Scene* scene); // nullptr 허용 시 의미 명확, 문서화 필수
```

---

## 예제 모음 (컴파일 가능한 스니펫)

### 포인터/참조/값 — 마이크로벤치 스케치

```cpp
#include <vector>
#include <numeric>

int sum_by_value(std::vector<int> v) { // 복사
    return std::accumulate(v.begin(), v.end(), 0);
}
int sum_by_ref(const std::vector<int>& v) { // 참조
    return std::accumulate(v.begin(), v.end(), 0);
}
```
> **경향**: 큰 컨테이너는 `const&`. 작은 구조체/스칼라는 값.

### `const` 포인터 조합

```cpp
int x=1, y=2;
const int* a = &x; // *a 읽기 전용
int* const b = &x; // b는 고정
const int* const c = &x;
a = &y;  // OK
// b = &y;  // 컴파일 에러
```

### rvalue 오버로드 + 이동

```cpp
#include <string>
#include <vector>

struct Bag {
    std::vector<std::string> v;
    void add(const std::string& s){ v.push_back(s); }      // 복사
    void add(std::string&& s)     { v.push_back(std::move(s)); } // 이동
};
```

### 완전 전달 팩토리

```cpp
#include <memory>
#include <utility>

template<typename T, typename... Args>
std::unique_ptr<T> make(Args&&... args){
    return std::make_unique<T>(std::forward<Args>(args)...);
}
```

---

## 수학적 관점(간단): 참조 붕괴 규칙 표기

$$
\begin{aligned}
&\text{Let } R \in \{\&,\ \&\&\}. \\
&\text{For a template parameter } T, \\
&T\& \ \& \ \Rightarrow T\&, \\
&T\& \ \&\& \Rightarrow T\&, \\
&T\&\& \ \& \Rightarrow T\&, \\
&T\&\& \ \&\& \Rightarrow T\&\&.
\end{aligned}
$$

- 전달 참조 컨텍스트에서 **인자의 값 범주를 보존**하도록 설계됨.

---

## 미니 프로젝트 예제 — 안전한 문자열 테이블

> 요구: 외부 입력을 **테이블(고정 풀)**에 저장하고, 조회는 **비소유 포인터/참조**로 제공하되 **수명 안전**을 보장.

```cpp
#include <vector>
#include <string>
#include <optional>
#include <iostream>

class StringTable {
    std::vector<std::string> pool_; // 소유
public:
    // 소유권은 table이 가짐: 외부는 참조만
    const std::string& insert(std::string s) {
        pool_.push_back(std::move(s));      // 이동
        return pool_.back();                // 참조 반환(수명: table과 동일)
    }
    const std::string* find_ptr(std::string_view key) const {
        for (auto& s : pool_) if (s == key) return &s; // nullptr 가능
        return nullptr;
    }
    std::optional<std::reference_wrapper<const std::string>>
    find_ref(std::string_view key) const {
        for (auto& s : pool_) if (s == key) return s;
        return std::nullopt;
    }
};

int main(){
    StringTable t;
    const std::string& ref = t.insert("alpha");
    std::cout << ref << "\n"; // "alpha"

    if (auto p = t.find_ptr("alpha")) std::cout << *p << "\n";
    if (auto r = t.find_ref("beta"))  std::cout << r->get() << "\n";
}
```

**포인트**
- **소유는 컨테이너**, 외부는 **참조/포인터**.
- 컨테이너가 **원소 재배치**를 유발하는 연산(큰 `vector`에서 `push_back`)은 **기존 포인터/참조 무효화** 가능 → 필요시 `std::deque`/`std::list`/**사전 예약**(`reserve`) 고려.

---

## 결론 & 요약 체크리스트

- [ ] **의도 우선**: 읽기만 ⇒ `const&`, 소모 ⇒ `T&&`, 소유 ⇒ 스마트 포인터
- [ ] **수명/소유권**을 설계의 1급 요소로 두기
- [ ] **const 정확성**으로 API 신뢰도 상승
- [ ] **값/참조/포인터**를 데이터 크기·사용 패턴·ABI 요구에 맞춰 선택
- [ ] **완전 전달**로 템플릿 API 효율 유지
- [ ] **스마트 포인터**로 `new/delete` 감추기
- [ ] 위험 패턴(댕글링/이중해제/null 역참조/무효화) 점검

---

# 부록 A. 자주 하는 실수와 교정

1) 지역 객체 참조 반환
```cpp
const T& f(){ T x; return x; } // ❌
T f(){ T x; return x; }        // ✅ 값 반환
```

2) `std::move` 남발
```cpp
T x; return std::move(x); // 대부분 ⛔: RVO가 깨질 수 있고 이점 없음
```

3) `shared_ptr` 과용
- 공유 소유가 필요할 때만. 기본은 `unique_ptr`.

4) C API 래핑
- 외부 라이브러리의 `T*`는 **RAII 래퍼**로 감싸기(커스텀 deleter).

---

# 부록 B. 짧은 테스트 스니펫 (포인터/참조 산문 테스트)

```cpp
#include <cassert>

int main(){
    int a=1, b=2;
    int* p=&a; *p=3;            assert(a==3);
    p=&b; *p=4;                 assert(b==4);

    int& r=a;                   r=5; assert(a==5);
    // &r = &b;                 // 컴파일 에러: 재바인딩 불가
}
```

---

# 부록 C. 표준 문서화 키워드(검색 포인트)

- “**const-correctness**”, “**reference collapsing**”, “**perfect forwarding**”, “**lifetime extension**”, “**iterator invalidation**”, “**strict aliasing**”, “**Rule of Zero/Three/Five**”.

---

## 끝맺음

포인터와 참조자는 C++의 **수명/소유권 모델**을 이해하는 관문이다.
여기에 rvalue 참조·완전 전달·스마트 포인터를 결합하면 **성능과 안전성을 동시에** 추구할 수 있다.
이 문서의 예제들을 토대로, 기존 코드의 **인자/반환 타입·수명·const 정책**을 점검해 보자.
