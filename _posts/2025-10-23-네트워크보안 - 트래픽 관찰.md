---
layout: post
title: 네트워크보안 - 트래픽 관찰
date: 2025-10-23 16:25:23 +0900
category: 네트워크보안
---
# 2. 트래픽 관찰(합법적 가시성)

> 목표: **네트워크를 “망가뜨리지 않고” 보는 법**을 익힌다.  
> 도구별 강점(tcpdump/WinDump, Wireshark, TShark, NetFlow/IPFIX/sFlow)을 구분하고,  
> **3-way/4-way 이상 징후·재전송·손실**을 **PCAP·플로우 지표**로 재현/탐지/보고까지 한 번에.

---

## 2.1 tcpdump/WinDump 필터 실전

### 2.1.1 철학 & 안전장치
- **원칙**: 캡처는 **합법적·사전 승인** 범위에서만. 운영망에선 **레이트/버퍼/디스크** 보호(회전 저장·시간 제한).
- **기본 안전장치**
  - `-G <sec>`(회전), `-C <MB>`(파일 크기 회전), `-W <files>`(보존 개수), `-s <snaplen>`(스냅샷 길이).
  - 예: 10분마다, 64MB 회전, 최근 30개만 보관, L7까지 보려면 `-s 0`.

```bash
# 10분 회전 + 파일 30개 보존 + 스냅샷 전체 + 링버퍼(라이트 스로틀)
sudo tcpdump -i eth0 -nn -s 0 -G 600 -W 30 -w 'cap-%Y%m%d-%H%M%S.pcap' \
  -Z nobody --time-stamp-precision=micro
```

> **WinDump**는 옵션이 거의 동일. 인터페이스명 확인: `WinDump -D`

---

### 2.1.2 BPF(필터) 즉전 레시피

#### (A) TCP 3-way/4-way 관찰
```bash
# SYN만(초기 연결 시도)
tcpdump -i any -nn 'tcp[tcpflags] & (tcp-syn|tcp-ack) == tcp-syn'
# SYN/ACK만(서버 응답)
tcpdump -i any -nn 'tcp[tcpflags] & (tcp-syn|tcp-ack) == (tcp-syn|tcp-ack)'
# FIN/RST(종료/이상 종료 관찰)
tcpdump -i any -nn 'tcp[tcpflags] & (tcp-fin|tcp-rst) != 0'
```

#### (B) PMTUD/프래그 문제 탐색
```bash
# DF=1인 IPv4 TCP 패킷(경로 MTU 이슈 의심 구간)
tcpdump -i any -nn 'ip[6] & 0x40 != 0 and tcp'
# ICMP Frag Needed(Type3 Code4)
tcpdump -i any -nn 'icmp[0] == 3 and icmp[1] == 4'
```

#### (C) 재전송·DupACK 힌트
```bash
# 완벽히 잡아내진 못하지만, 빠르게 감 잡는 필터
tcpdump -i any -nn 'tcp[13] & 0x10 != 0 and tcp[13] & 0x04 = 0'  # ACK들
# Wireshark로 분석 예정(2.2). 현장에선 TShark 해석이 더 정확.
```

#### (D) L7 샘플(주의: PII/민감정보!)
```bash
# HTTP 요청만
tcpdump -i any -nn -s 0 -A 'tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - \
((tcp[12]&0xf0)>>2)) != 0)' | grep -E '^(GET|POST|Host:)'
```

> 운영 망에선 **페이로드를 저장하지 않도록(-s 96 같은 헤더 위주) 기본값**을 정책화하고,  
> **사유가 있을 때만 -s 0 + 암호화 + 보존기간 단축**을 적용.

---

### 2.1.3 인터페이스·타임스탬프·성능

```bash
# 인터페이스 목록
tcpdump -D
# 하드웨어 타임스탬프(지원 카드/드라이버 한정)
sudo ethtool -T eth0
tcpdump --time-stamp-precision=nano
```

- **고성능 캡처 팁**
  - 불필요한 복호화/문자 출력 금지(`-w`로 파일 저장, 분석은 후단 도구로).
  - 스냅샷 축소(`-s 128`), BPF 선필터링, 미러 포트/어댑터 핀바인딩(irqbalance 조정).
  - 대용량이면 **DPDK 기반** 캡처(특수 도구) 고려.

---

### 2.1.4 미니 실습 – “SYN은 왔는데 SYN/ACK이 없다?”

**상황**: 클라이언트가 `10.10.0.10`에서 `web:80`으로 접속이 안 됨. L3는 통과.  
**가설**: 서버가 닿지만 방화벽 Drop/Blackhole, 또는 리스닝 X.

```bash
# 클라이언트 측: SYN을 던지는지
tcpdump -i eth0 -nn 'host 10.10.0.10 and tcp port 80 and tcp[tcpflags] & tcp-syn != 0'
# 서버 측: SYN이 도착했는지, 그리고 SYN/ACK을 내보내는지
tcpdump -i eth0 -nn 'tcp port 80 and (tcp[tcpflags] & (tcp-syn|tcp-ack)) != 0'
```

**판별**  
- 서버에서 SYN은 보이는데 **SYN/ACK이 안 나감** → 리스닝 안 함/로컬 FW Drop.  
- 서버에서 SYN/ACK 나가지만 클라에서 **SYN/ACK 못 봄** → 경로 중간 Drop/리턴 경로 이슈(라우팅/NAT).

---

## 2.2 Wireshark 컬러링 룰 / Expert Info / Follow Stream

### 2.2.1 컬러링 룰(눈으로 “패턴” 보이게 하기)

**개념**: 중요한 패킷을 색으로 구분해 **문양처럼 보이게** 한다.  
아래 5개만 만들어도 파형이 보인다.

| 우선 | 이름 | Display Filter | 색(예시) |
|---|---|---|---|
| 1 | TCP SYN only | `tcp.flags.syn==1 && tcp.flags.ack==0` | 강조 |
| 2 | TCP SYN/ACK | `tcp.flags.syn==1 && tcp.flags.ack==1` | 중간 |
| 3 | TCP Retransmission | `tcp.analysis.retransmission` | 빨강 |
| 4 | DupACK | `tcp.analysis.duplicate_ack` | 주황 |
| 5 | ICMP Frag Needed | `icmp.type==3 && icmp.code==4` | 보라 |

**적용**: `View → Coloring Rules → +`로 추가(룰 순서가 중요).  
**효과**: 3-way가 녹색→청색→흰색 흐름이라면, 재전송이 빨간 띠로 나타난다.

---

### 2.2.2 Expert Info로 “문제 냄새” 바로嗅觉

`Analyze → Expert Information`  
- Severity: Error/Warning/Note  
- 흔한 항목: `TCP Previous segment not captured`, `Retransmission`, `ZeroWindow`, `Out-of-Order`, `Window Full`, `Spurious Retransmission`

**활용팁**  
- **탑다운**: Expert Info에서 가장 많은 Error/Warning을 클릭 → 해당 패킷으로 점프 → 원인 계층(링크/라우팅/혼잡/애플리케이션)을 추정.
- **세션별 그룹화**: `Statistics → Conversations (TCP)`에서 문제 세션만 재필터링.

---

### 2.2.3 Follow Stream으로 L7 재조립(주의: PII!)

**HTTP/SMTP/DNS/…** 등은 `Follow → TCP/UDP Stream`으로 요청/응답 쌍을 재구성.  
- 안전망: **운영망**에선 보통 **헤더까지만** 보거나, PII 마스킹 후 처리.
- TLS는 평문 보이지 않음(키가 있거나 SSLKEYLOGFILE을 쓴 특수 상황 제외).

**미니 팁**  
- HTTP 성능 문제: Follow TCP Stream에서 **서버 응답 헤더**의 `Date`, `Server-Timing`, `Content-Length` 등으로 **서버 지연 vs 전송 지연** 분리.
- gRPC/HTTP2: `Decode As…`로 포트/프로토콜 맞춰주면 인사이트 상승.

---

### 2.2.4 TShark를 곁들인 “자동 요약”

```bash
# 연결 대화(Conversations) 요약
tshark -r cap.pcap -q -z conv,tcp

# TCP 스트림별 RTT/재전송 지표(필드 추출 예)
tshark -r cap.pcap -Y "tcp" -T fields \
  -e tcp.stream -e frame.time_epoch -e ip.src -e ip.dst -e tcp.flags \
  -e tcp.analysis.retransmission -e tcp.analysis.duplicate_ack \
  | awk -F'\t' '{count[$1]++; if($6==1) rtx[$1]++; if($7==1) dup[$1]++} \
     END{for(i in count) printf "stream=%s packets=%d rtx=%d dupack=%d\n", i, count[i], rtx[i], dup[i]}'
```

> **운영 자동화 아이디어**: PCAP을 **짧게** 잡고, TShark로 **지표 추출 → SIEM/Prometheus push**.  
> PCAP은 **암호화·단기 보관**(예: 7일) 정책.

---

## 2.3 NetFlow / IPFIX / sFlow로 본 “흐름 가시성”

### 2.3.1 왜 플로우인가?
- PCAP(패킷)은 **정밀하지만 무겁다**.  
- 플로우는 **헤더 요약**(5-tuple, 바이트/패킷/지속시간/플래그 등)으로 **장기·광역** 관제를 가능하게 한다.
- **NetFlow v5**: IPv4 중심, 필드 고정.  
- **IPFIX**: 표준화(IEC 5101), 템플릿 확장(IPv6, 앱필드 등).  
- **sFlow**: **샘플링** 기반(패킷·인터페이스 카운터), L2~L7 일부까지 가벼움.

### 2.3.2 에이전트/익스포터 & 콜렉터 구성 개념
- **Exporter(스위치/라우터/호스트)** → (UDP/2055 등) → **Collector**(nfdump/ElastiFlow 등) → **Storage/Query/Grafana**.
- 호스트 기반: `softflowd`, `fprobe`, `pmacct`, `goflow2` 등.
- sFlow 에이전트: `hsflowd`(Host sFlow).

### 2.3.3 예제 – softflowd + nfdump 빠른 체험(로컬)

**1) softflowd(Exporter) 실행**
```bash
# eth0 트래픽을 NetFlow v9로 127.0.0.1:2055에 보냄
sudo softflowd -i eth0 -v 9 -n 127.0.0.1:2055 -t maxlife=60 -t tcp_rst=5 -t tcp_fin=10
```

**2) nfcapd(Collector) 실행 & 조회**
```bash
# 콜렉터 실행(디렉토리에 5분 회전 저장)
nfcapd -l ./flows -p 2055 -t 300 &
# 간단 조회
nfdump -r ./flows/nfcapd.* -o "fmt:%ts %te %td %sa:%sp -> %da:%dp %pr %flg %byt %pkt"
# 상위 Talkers
nfdump -r ./flows/nfcapd.* -s srcip/bytes -n 10
```

**3) 지표로 본 이점**
- “어느 대화가 바이트/패킷을 많이 쓰나?”, “RST/FIN 플래그 비정상 세션이 많은가?”,  
- “단시간 다량 짧은 세션(스캔)?” 등을 **가볍게** 탐지.

---

### 2.3.4 예제 – hsflowd(sFlow) 간단 적용

`/etc/hsflowd.conf` (개념 예)
```ini
sflow {
  agent = eth0
  collector { ip = 127.0.0.1 UDP = 6343 }
  sampling = 1000
  polling = 30
}
```

콜렉터: `sflowtool`, `pmacct`, `goflow2`, `ElastiFlow(sFlow)` 등으로 수집/대시보드화.

---

### 2.3.5 Flow로 “재전송/손실”을 어떻게 느끼나?

- 순수 플로우는 L7 페이로드/패킷별 이벤트 없음 → **직접 재전송을 보진 못함**.  
- 대신 **지표 패턴**으로 우회 감지:
  - **짧은 시간 내 동일 5-tuple로 다수 세션 실패(0바이트/소량)** → 연결 실패/리셋/필터링 의심.
  - **대역폭 대비 비정상적인 패킷/바이트 비** → 작은 MSS/재전송 증가 시 나타날 수 있음(상관 탐색 필요).
  - **TCP 플래그 분포**(RST 비율 상승) → 장애/블랙홀 의심.
- 결론: **플로우 = 광역 레이더**, **PCAP = 현미경**. 둘을 함께 써야 **탐지→근거**가 매끄럽다.

---

## 2.4 실습: PCAP로 “3-way/4-way 이상 징후·재전송·손실” 찾기

> 아래 실습은 **격리 랩**에서만. 실제 운영망이라면 **스냅샷/마스킹/보관** 정책 엄수!

### 2.4.1 랩 토폴로지(컨테이너 예)
```
client ──(labnet)── mirror(tcpdump) ── server
                 └─ attacker(옵션)
```

`docker compose`(요지)
```yaml
version: "3.9"
services:
  server: { image: nginx:alpine, networks: [ labnet ] }
  client: { image: curlimages/curl:8.10.1, entrypoint: ["sleep","infinity"], networks: [ labnet ] }
  mirror:
    image: corfr/tcpdump
    command: ["-i","any","-s","0","-w","/pcap/lab.pcap"]
    volumes: [ "./pcap:/pcap" ]
    networks: [ labnet ]
    cap_add: ["NET_ADMIN","NET_RAW"]
networks: { labnet: { driver: bridge } }
```

**트래픽 생성**
```bash
docker compose up -d
docker compose exec client sh -c 'for i in 1 2 3; do curl -s http://server >/dev/null; sleep 1; done'
ls -lh pcap/lab.pcap
```

---

### 2.4.2 시나리오 A — “3-way 중 어딘가가 비정상”

**문제 주입(예시)**: 서버에서 FW로 `OUTPUT tcp dport 80 DROP`  
```bash
# 서버 컨테이너 안에서(예: apk add iptables 후)
iptables -A OUTPUT -p tcp --sport 80 --tcp-flags SYN,ACK SYN,ACK -j DROP
```

**기대 관찰**
- 클라이언트: SYN 송신, **SYN/ACK 미수신** → 재시도 후 RST 혹은 타임아웃.
- Wireshark Display Filter:
  - `tcp.flags.syn==1 && tcp.flags.ack==0` (SYN)
  - `tcp.flags.syn==1 && tcp.flags.ack==1` (SYN/ACK)
  - `tcp.analysis.retransmission`

**Expert Info**
- `Connection attempt failed`/`SYN Retransmission` 등 Warning/Notes 증가.

**원인 추적 로드맵**
1) 서버에서 SYN 수신 여부 확인(미러링 또는 서버 측 캡처).  
2) 서버가 SYN/ACK 보내는지 봄 → 없으면 로컬 방화벽/리스닝 X.  
3) SYN/ACK 보냈는데 클라가 못 받으면 경로/리턴 라우팅/NAT 문제.

---

### 2.4.3 시나리오 B — “4-way 종료가 지저분”

**문제 주입**: 서버 프로세스가 갑자기 종료(RST 남발).

**관찰 포인트**
- 정상 종료: `FIN → ACK → FIN → ACK` (4-way)  
- 비정상: **RST**가 끼어든다.  
- Wireshark: `tcp.flags.fin==1 || tcp.flags.rst==1`  
- Expert: `TCP RST` 급증.

**해석**
- 애플리케이션 크래시/리소스 부족/중간 프록시의 타임아웃 정책.  
- 사용자가 체감하는 “끊김”/“파일 손상” 발생 가능.

---

### 2.4.4 시나리오 C — “재전송/손실이 의심”

**문제 주입**: `tc netem`으로 손실/지연 인가(호스트 or server 컨테이너 네임스페이스)

```bash
# 1% 손실 + 50ms 지연
tc qdisc add dev eth0 root netem loss 1% delay 50ms
# 테스트 후 제거
tc qdisc del dev eth0 root
```

**관찰**
- Wireshark: `tcp.analysis.retransmission`, `tcp.analysis.fast_retransmission`, `tcp.analysis.duplicate_ack` 증가.
- Throughput 저하(`iperf3`)와 RTT 증가(`ping`).

**정량화(TShark)**
```bash
# 스트림별 재전송 카운트
tshark -r lab.pcap -Y "tcp.analysis.retransmission" -T fields -e tcp.stream \
  | sort | uniq -c | sort -nr | head
# DupACK 카운트
tshark -r lab.pcap -Y "tcp.analysis.duplicate_ack" -T fields -e tcp.stream \
  | sort | uniq -c | sort -nr | head
```

**수정 실험**
- 서버/클라 TCP 버퍼 확장(섹션 1.3.6 참조).  
- 라우터에서 AQM(fq_codel) 적용, 큐 지연/버스트 손실 완화.

---

### 2.4.5 시나리오 D — “PMTUD 실패로 큰 페이로드 멈칫”

**문제 주입**: 경로에서 **ICMP Frag Needed 차단**(실험망 전용).  
**현상**: 대용량 전송이 특정 크기에서 정체/타임아웃.

**관찰**
- DF=1 패킷 다수 + ICMP Type3 Code4 **부재**.  
- Wireshark 필터:  
  - `ip.flags.df==1 && tcp.len > 0`  
  - `icmp.type==3 && icmp.code==4`(없음)

**대응 실험**
- 라우터에서 `--clamp-mss-to-pmtu` 활성화 → 즉시 개선 확인.
```bash
iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN \
  -j TCPMSS --clamp-mss-to-pmtu
```

---

### 2.4.6 마스킹/보고 자동화(샘플)

**민감헤더 제거 + 요약 리포트**
```bash
# 1. HTTP만 추출(테스트망)
tshark -r lab.pcap -Y "http" -w http_only.pcap
# 2. Authorization 같은 민감 헤더 제거(간단 예, 실운영은 전문 툴 권장)
editcap --inject-secrets dyn,http,Authorization:REDACTED http_only.pcap http_sanitized.pcap
# 3. 요약 표
tshark -r lab.pcap -q -z conv,tcp > report.txt
```

**보고서 뼈대(마크다운)**
```markdown
# 네트워크 진단 보고서 — YYYY-MM-DD

## 요약
- 3-way 실패 스트림: 12개 (SYN/ACK 미수신)
- 재전송 많은 스트림 TOP5: stream 3(45회), 7(22회), ...

## 세부
### 1. 연결 실패(3-way)
- 현상/증거(패킷 번호, 시간, 필터 스크린샷)
- 원인 후보: 서버 리스닝X, 로컬 FW, 리턴 경로 누락
- 조치: ...

### 2. 재전송/손실
- DupACK/재전송 지표(표)
- RTT 분포
- AQM/MSS 조정 실험 결과

### 결론/권고
- 정책/튜닝/모니터링 추가
```

---

## 2.x 부록 — “무엇을, 언제, 어떻게” 보는 체크리스트

### 관찰 목적별 도구 선택
- **현상 재현/근거**: PCAP(tcpdump/Wireshark/TShark)
- **광역 트렌드**: NetFlow/IPFIX/sFlow(+ 대시보드)
- **L7 추적**: Follow Stream(평문 한정), 프록시/서버 로그 연계
- **자동 경보**: TShark 추출 → SIEM 규칙 / NDR(Suricata/Zeek) 룰

### Display/BPF 필터 치트
- 3-way: `tcp.flags.syn==1 && tcp.flags.ack==0`, `tcp.flags.syn==1 && tcp.flags.ack==1`
- 4-way/비정상: `tcp.flags.fin==1 || tcp.flags.rst==1`
- 재전송/dupACK: `tcp.analysis.retransmission`, `tcp.analysis.duplicate_ack`
- PMTUD: `ip.flags.df==1 && tcp.len>0`, `icmp.type==3 && icmp.code==4`
- DNS 쿼리: `dns.flags.response==0`

### 안전/윤리
- 스냅샷·회전 저장·암호화·보관기간 **정책**.
- PII/민감정보 **최소 수집/마스킹**.
- 합법/사전 승인(ROE) 문서화.

---

## 정리

- **tcpdump/WinDump**: 빠르고 가벼운 **채집기**. (필터·스냅샷·회전으로 안전하게)
- **Wireshark**: **컬러링/Expert/Follow**로 패턴을 **눈으로** 본다.
- **TShark**: 자동 요약·지표화로 **운영 루프**에 태운다.
- **NetFlow/IPFIX/sFlow**: **광역/장기 관제**. PCAP과 상호보완.