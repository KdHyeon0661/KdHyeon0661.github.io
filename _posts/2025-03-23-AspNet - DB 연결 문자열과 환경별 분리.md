---
layout: post
title: AspNet - DB 연결 문자열과 환경별 분리
date: 2025-03-23 20:20:23 +0900
category: AspNet
---
# ASP.NET Core에서 DB 연결 문자열과 환경별 분리

- 다중 환경 계층(Development/Staging/Production)과 **우선순위 병합 규칙**
- **Secret Manager / 환경변수 / Azure Key Vault** / Docker/K8s 설정 주입
- **여러 데이터베이스 동시 구성**(SQL Server/PostgreSQL/MySQL/SQLite)
- **읽기/쓰기 분리(Read/Write split)**, **다중 DbContext**와 연결 풀 관련 설정
- **재시도/탄력성 정책(Polly)**, **헬스 체크**, **마이그레이션 전략**
- **배포 시 실수 방지 체크리스트**와 운영 Troubleshooting

---

## Connection String의 구조와 병합 규칙 복습

### 연결 문자열 핵심 필드

```
Server=HOST_OR_INSTANCE;Database=DB_NAME;User Id=USER;Password=PASS;Encrypt=True;TrustServerCertificate=False;
```

> 공급자(DB Provider)에 따라 키 이름이 달라질 수 있음 (예: PostgreSQL: `Host=...;Port=5432;Username=...;Password=...;Database=...`).

### 설정 병합 우선순위

ASP.NET Core의 `Configuration`은 여러 소스가 **겹쳐질 때 나중에 추가된 소스가 우선**한다. 보통 템플릿 기본 순서:

1. `appsettings.json` (공통)
2. `appsettings.{Environment}.json` (환경별 오버라이드)
3. **User Secrets** (개발 전용, 로컬 사용자 스토리지)
4. **환경 변수(ENV)** (컨테이너/서버에서 주입)
5. **명령줄 인수** (`dotnet run --ConnectionStrings:DefaultConnection=...`)

> **규칙**: “뒤에 오는 소스가 이긴다”. 운영에서는 소스 노출 위험이 큰 파일보다 **환경 변수/Key Vault**가 우선되도록 설계한다.

---

## 환경별 구성 파일 — 기본 패턴과 예시

### 파일 레이아웃

```
appsettings.json
appsettings.Development.json
appsettings.Staging.json
appsettings.Production.json
```

### 공통(appsettings.json)

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=DevDb;Trusted_Connection=True;Encrypt=False"
  },
  "DatabaseOptions": {
    "CommandTimeoutSec": 30,
    "EnableDetailedErrors": false,
    "EnableSensitiveDataLogging": false
  }
}
```

### 개발(appsettings.Development.json)

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost;Database=DevDb;User Id=dev;Password=dev123;Encrypt=False"
  },
  "DatabaseOptions": {
    "EnableDetailedErrors": true,
    "EnableSensitiveDataLogging": true
  }
}
```

### 운영(appsettings.Production.json)

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=tcp:prod-sql,1433;Database=ProdDb;User Id=prod_admin;Password=__REDACTED__;Encrypt=True;TrustServerCertificate=False"
  },
  "DatabaseOptions": {
    "CommandTimeoutSec": 60,
    "EnableDetailedErrors": false,
    "EnableSensitiveDataLogging": false
  }
}
```

> **운영**은 암호화(Encrypt=True), 인증서 신뢰 설정(가능하면 `TrustServerCertificate=False`)을 기본으로.

---

## Program.cs — 구성 병합과 DbContext 등록

템플릿은 이미 환경별 파일/ENV를 자동 로드한다. 필요 시 명시적으로 확장한다.

```csharp
var builder = WebApplication.CreateBuilder(args);

// (선택) 구성 소스 체인 커스터마이즈
builder.Configuration
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json", optional:false, reloadOnChange:true)
    .AddJsonFile($"appsettings.{builder.Environment.EnvironmentName}.json", optional:true, reloadOnChange:true)
    .AddUserSecrets<Program>(optional:true) // 개발 환경에서만 의미 있음
    .AddEnvironmentVariables()
    .AddCommandLine(args);

// 강타입 DatabaseOptions 바인딩
builder.Services.Configure<DatabaseOptions>(
    builder.Configuration.GetSection("DatabaseOptions"));

// EF Core — SQL Server 예시
builder.Services.AddDbContext<AppDbContext>(opt =>
{
    var conn = builder.Configuration.GetConnectionString("DefaultConnection");
    var dbOpts = builder.Configuration.GetSection("DatabaseOptions").Get<DatabaseOptions>() ?? new();

    opt.UseSqlServer(conn, sql =>
    {
        sql.CommandTimeout(dbOpts.CommandTimeoutSec);
        sql.EnableRetryOnFailure( // 기본적인 재시도
            maxRetryCount: 5,
            maxRetryDelay: TimeSpan.FromSeconds(10),
            errorNumbersToAdd: null);
    });

    opt.EnableDetailedErrors(dbOpts.EnableDetailedErrors);
    opt.EnableSensitiveDataLogging(dbOpts.EnableSensitiveDataLogging && builder.Environment.IsDevelopment());
});

builder.Services.AddRazorPages();
var app = builder.Build();

// (선택) 마이그레이션 자동 적용 — 운영에선 신중히 사용
using (var scope = app.Services.CreateScope())
{
    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
    await db.Database.MigrateAsync();
}

app.MapRazorPages();
await app.RunAsync();

public record DatabaseOptions
{
    public int CommandTimeoutSec { get; init; } = 30;
    public bool EnableDetailedErrors { get; init; } = false;
    public bool EnableSensitiveDataLogging { get; init; } = false;
}
```

---

## Secret Manager / 환경 변수 / Azure Key Vault

### Secret Manager (로컬 개발)

```bash
dotnet user-secrets init
dotnet user-secrets set "ConnectionStrings:DefaultConnection" "Server=localhost;Database=DevDb;User Id=dev;Password=dev123;"
```

Program.cs:

```csharp
builder.Configuration.AddUserSecrets<Program>(optional:true);
```

> **로컬 파일에 저장되지 않으며 Git에 커밋되지 않는다.**

### 환경 변수(서버/컨테이너)

- 키 구분자는 `:` 대신 `__` 사용
- 예: `ConnectionStrings__DefaultConnection="Server=..."`

Docker `docker-compose.yml`:

```yaml
services:
  web:
    image: myapp:latest
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ConnectionStrings__DefaultConnection=Server=sql;Database=ProdDb;User Id=sa;Password=${SA_PASSWORD};Encrypt=True
```

Kubernetes Deployment:

```yaml
env:
- name: ASPNETCORE_ENVIRONMENT
  value: "Production"
- name: ConnectionStrings__DefaultConnection
  valueFrom:
    secretKeyRef:
      name: db-conn
      key: default-connection
```

### Azure Key Vault (운영 권장)

```csharp
using Azure.Identity;
using Azure.Security.KeyVault.Secrets;

if (builder.Environment.IsProduction())
{
    var kvUrl = builder.Configuration["KeyVault:Url"];
    if (!string.IsNullOrWhiteSpace(kvUrl))
    {
        builder.Configuration.AddAzureKeyVault(new Uri(kvUrl), new DefaultAzureCredential());
    }
}
```

Key Vault 값은 `Configuration`에 **바로 섞여** 들어오므로, `GetConnectionString`/`["ConnectionStrings:.."]` 방식 그대로 사용 가능.

---

## 여러 DB 연결과 다중 DbContext

### 다중 연결 문자열

```json
"ConnectionStrings": {
  "DefaultConnection": "Server=...;Database=MainDb;...",
  "LoggingDb": "Server=...;Database=LogsDb;...",
  "ReadReplica": "Server=read-sql;Database=MainDb;ApplicationIntent=ReadOnly;..."
}
```

### 다중 DbContext 등록

```csharp
builder.Services.AddDbContext<MainDbContext>(opt =>
    opt.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

builder.Services.AddDbContext<LoggingDbContext>(opt =>
    opt.UseSqlServer(builder.Configuration.GetConnectionString("LoggingDb")));
```

### 읽기/쓰기 분리(간단 전략)

- 쓰기: `MainDbContext(Primary)`
- 읽기: `ReadOnlyDbContext(ReadReplica, ApplicationIntent=ReadOnly)`

```csharp
builder.Services.AddDbContext<ReadOnlyDbContext>(opt =>
    opt.UseSqlServer(builder.Configuration.GetConnectionString("ReadReplica")));
```

서비스에서 의도에 맞는 컨텍스트를 주입받아 사용:

```csharp
public class BlogQueryService
{
    private readonly ReadOnlyDbContext _ro;
    public BlogQueryService(ReadOnlyDbContext ro) => _ro = ro;

    public Task<List<Blog>> GetLatestAsync(CancellationToken ct) =>
        _ro.Blogs.AsNoTracking()
           .OrderByDescending(b => b.CreatedAt)
           .Take(20)
           .ToListAsync(ct);
}

public class BlogCommandService
{
    private readonly MainDbContext _rw;
    public BlogCommandService(MainDbContext rw) => _rw = rw;

    public async Task<int> CreateAsync(Blog blog, CancellationToken ct)
    {
        _rw.Blogs.Add(blog);
        return await _rw.SaveChangesAsync(ct);
    }
}
```

> **주의**: 트랜잭션 일관성이 필요한 작업은 **동일 컨텍스트/동일 연결**을 사용.

---

## 다른 DB 프로바이더 예시

### PostgreSQL (Npgsql)

```bash
dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL
```

```csharp
builder.Services.AddDbContext<AppDbContext>(opt =>
{
    var conn = builder.Configuration.GetConnectionString("DefaultConnection");
    opt.UseNpgsql(conn, npg =>
    {
        npg.EnableRetryOnFailure(5, TimeSpan.FromSeconds(10), null);
    });
});
```

**예시 연결 문자열**

```
Host=localhost;Port=5432;Database=DevDb;Username=dev;Password=dev123;SSL Mode=Require;Trust Server Certificate=false;
```

### MySQL (Pomelo)

```bash
dotnet add package Pomelo.EntityFrameworkCore.MySql
```

```csharp
builder.Services.AddDbContext<AppDbContext>(opt =>
{
    var cs = builder.Configuration.GetConnectionString("DefaultConnection");
    var serverVersion = ServerVersion.AutoDetect(cs);
    opt.UseMySql(cs, serverVersion, my =>
    {
        my.EnableRetryOnFailure(5, TimeSpan.FromSeconds(10), null);
    });
});
```

### SQLite (개발/테스트에 적합)

```bash
dotnet add package Microsoft.EntityFrameworkCore.Sqlite
```

```csharp
builder.Services.AddDbContext<AppDbContext>(opt =>
    opt.UseSqlite(builder.Configuration.GetConnectionString("DefaultConnection")));
```

```
"ConnectionStrings": {
  "DefaultConnection": "Data Source=local.db"
}
```

---

## 연결 풀링과 성능/탄력성(Polly)

대부분의 ADO.NET Provider는 **기본적으로 연결 풀링**을 지원한다(최대/최소 풀 크기 설정 가능). 장시간 Idle/과부하 상황에 대비해 **재시도/백오프**를 켜는 것이 안정적.

- SQL Server: `EnableRetryOnFailure`
- PostgreSQL(MySQL 등): 유사 옵션 지원
- 더 정교한 정책: **Polly**를 통해 쿼리 단위 재시도/타임아웃/서킷브레이커

```bash
dotnet add package Polly
```

```csharp
using Polly;
using Polly.Extensions.Http;

// 예: 비즈니스 서비스에서 ADO.NET/외부호출에 Polly 적용 (EF 내부가 아니라면)
var retry = Policy
    .Handle<TimeoutException>()
    .Or<DbUpdateException>()
    .WaitAndRetryAsync(5, i => TimeSpan.FromMilliseconds(200 * i));
```

> EF Core SQL 재시도는 `EnableRetryOnFailure`가 1차 선택. 보다 복잡한 실패 시나리오는 아키텍처 단에서 Polly 조합을 고려.

---

## 헬스 체크(Health Checks) — DB 연결 확인

```bash
dotnet add package AspNetCore.HealthChecks.SqlServer
```

```csharp
builder.Services.AddHealthChecks()
    .AddSqlServer(
        connectionString: builder.Configuration.GetConnectionString("DefaultConnection"),
        name: "sql",
        failureStatus: Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus.Unhealthy,
        tags: new[] { "db", "sql" });

var app = builder.Build();
app.MapHealthChecks("/health"); // K8s liveness/readiness에 사용
```

---

## 마이그레이션 전략 — 환경 차등 처리

- **개발/스테이징**: 자동 마이그레이션 적용 허용 가능
- **운영**: 명시적 CI/CD 단계에서 `dotnet ef database update` 수행(스크립트 검토 포함)

GitHub Actions 예시:

```yaml
- name: Run EF Core Migrations
  run: dotnet ef database update --project src/MyApp/MyApp.csproj --context AppDbContext
  env:
    ConnectionStrings__DefaultConnection: ${{ secrets.PROD_SQL_CONN }}
    ASPNETCORE_ENVIRONMENT: Production
```

> 운영에서 앱 시작 시 마이그레이션 자동 적용은 충돌/다운타임 위험. **배포 파이프라인에서 사전 적용** 권장.

---

## 구성 바인딩과 IOptions 패턴(연결 관련 튜닝)

```json
"DatabaseOptions": {
  "CommandTimeoutSec": 45,
  "EnableDetailedErrors": false,
  "EnableSensitiveDataLogging": false,
  "MaxBatchSize": 128
}
```

```csharp
builder.Services.Configure<DatabaseOptions>(
    builder.Configuration.GetSection("DatabaseOptions"));

builder.Services.AddDbContext<AppDbContext>((sp, opt) =>
{
    var cfg = sp.GetRequiredService<IOptions<DatabaseOptions>>().Value;
    var cs = builder.Configuration.GetConnectionString("DefaultConnection");

    opt.UseSqlServer(cs, sql =>
    {
        sql.CommandTimeout(cfg.CommandTimeoutSec);
        sql.MaxBatchSize(cfg.MaxBatchSize);
        sql.EnableRetryOnFailure(5, TimeSpan.FromSeconds(10), null);
    });

    opt.EnableDetailedErrors(cfg.EnableDetailedErrors);
    opt.EnableSensitiveDataLogging(cfg.EnableSensitiveDataLogging && builder.Environment.IsDevelopment());
});
```

---

## 보안/운영 체크리스트

- [ ] **비밀번호/비밀은 코드/리포지토리에 넣지 않는다**
      User Secrets(개발), 환경 변수/Key Vault(운영)
- [ ] 운영 연결은 **암호화(Encrypt/SSL)** 활성화
- [ ] `TrustServerCertificate=False` + **공인/사내 CA 인증서** 사용
- [ ] 최소 권한 계정(읽기/쓰기 별 계정) — 필요 시 **읽기 전용 연결 문자열 분리**
- [ ] 연결 문자열은 **로그에 절대 출력하지 않는다** (`EnableSensitiveDataLogging=false`)
- [ ] 장애 시 **재시도/백오프**(EnableRetryOnFailure/Polly)와 대기열 전략
- [ ] **헬스 체크**와 대시보드, 알람 연동
- [ ] **마이그레이션은 배포 파이프라인에서 관리**(스크립트 검증)
- [ ] **K8s Secret/Key Vault 연동**으로 운영 환경 주입
- [ ] 성능 모니터링: 연결 풀 사용량, 쿼리 지연, 데드락/타임아웃 지표 수집

---

## 실전 시나리오 모음

### 로컬 개발: SQLite + User Secrets

`appsettings.Development.json`:

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=local.db"
  }
}
```

Program.cs:

```csharp
builder.Services.AddDbContext<AppDbContext>(opt =>
    opt.UseSqlite(builder.Configuration.GetConnectionString("DefaultConnection")));
```

### 스테이징: PostgreSQL + 환경 변수

`ASPNETCORE_ENVIRONMENT=Staging`
`ConnectionStrings__DefaultConnection="Host=stag-db;Database=App;Username=app;Password=********;SSL Mode=Require"`

### 운영: Azure SQL + Key Vault

Key Vault에 `ConnectionStrings--DefaultConnection` 저장 → `AddAzureKeyVault`로 주입 → `UseSqlServer` 등록

---

## 다층 환경에서의 문제 해결(FAQ)

- **개발에서 동작, 운영에서 실패**
  - 운영은 암호화/인증서 정책이 엄격 → `Encrypt=True`, `TrustServerCertificate=False`, 방화벽/서브넷/NSG 확인
- **간헐적 타임아웃/연결 오류**
  - `EnableRetryOnFailure` 활성화, 풀 크기/DB 리소스, 장기 실행 쿼리 튜닝, 인덱스/실행 계획 점검
- **읽기 전용 노드에 쓰기 시도**
  - 연결 문자열에 `ApplicationIntent=ReadOnly` 붙었는지 확인, 쓰기 경로의 컨텍스트/서비스 주입 검증
- **마이그레이션 충돌**
  - 자동 마이그레이션 해제, CI 단계에서 일괄 적용, 스냅샷/체크섬 원인 파악

---

## 코드 스니펫 모음

### 구성 키 전체 덤프(디버깅용)

```csharp
foreach (var kv in builder.Configuration.AsEnumerable(makePathsRelative: true))
{
    Console.WriteLine($"{kv.Key} = {kv.Value}");
}
```

### 읽기/쓰기 컨텍스트를 서비스에서 동시 사용

```csharp
public class BlogFacade
{
    private readonly ReadOnlyDbContext _ro;
    private readonly MainDbContext _rw;

    public BlogFacade(ReadOnlyDbContext ro, MainDbContext rw)
    {
        _ro = ro; _rw = rw;
    }

    public Task<List<Blog>> GetTopAsync(CancellationToken ct) =>
        _ro.Blogs.AsNoTracking().OrderByDescending(b => b.CreatedAt).Take(10).ToListAsync(ct);

    public async Task<int> CreateAsync(string title, string author, CancellationToken ct)
    {
        _rw.Blogs.Add(new Blog { Title = title, Author = author, CreatedAt = DateTime.UtcNow });
        return await _rw.SaveChangesAsync(ct);
    }
}
```

---

## 요약

| 주제 | 핵심 포인트 |
|---|---|
| 환경별 파일 | `appsettings.json` → `appsettings.{Env}.json`로 오버라이드, **나중 소스가 우선** |
| 비밀 관리 | 개발=User Secrets, 운영=환경 변수/Key Vault (절대 Git에 비밀번호 금지) |
| DbContext 등록 | `UseSqlServer/Npgsql/MySql/Sqlite` + `EnableRetryOnFailure` + 옵션 바인딩 |
| 다중 DB/읽기 분리 | 여러 `DbContext`/연결 문자열, 읽기 전용은 `ApplicationIntent=ReadOnly` |
| 성능/운영 | 연결 풀, 재시도/백오프, 헬스 체크, 마이그레이션은 **배포 파이프라인**에서 |
| 보안 | 암호화/인증서, 최소 권한 계정, 민감로그 금지, Key Vault/Secret 사용 |

---

## 추천 다음 주제

- EF Core **마이그레이션 파이프라인**(스크립트 생성/검토/승인)
- **Multi-Tenancy**를 위한 연결 문자열 동적 선택(테넌트별 DB)
- **IOptionsMonitor**로 런타임 연결/옵션 변경 반영(특정 시나리오)
- Cloud DB(Azure SQL, AWS RDS, Cloud SQL) 네트워킹/방화벽 베스트 프랙티스

---

### 부록) 간단한 수식 표기(성능 감 잡기)

> 평균 지연시간을 $$ \bar{t} $$, 재시도 횟수를 $$ r $$, 재시도 간 대기 증가를 $$ \Delta $$라 하면, 최대 지연 상한은

$$
T_{\max} \approx \bar{t} + \sum_{k=1}^{r} k\Delta = \bar{t} + \Delta \frac{r(r+1)}{2}.
$$

재시도/백오프 튜닝 시 **사용자 체감 지연의 상한**을 이렇게 가늠해보자.

---

# 결론

환경/비밀/프로바이더/운영 요소가 얽히는 **DB 연결 구성**은 단순히 문자열 하나가 아니다.
본 가이드는 초안의 내용을 확장해, **현업에서 바로 쓰는 수준의 분리·보안·탄력성·운영 체계**를 제시했다.
이 뼈대를 토대로 조직의 배포 파이프라인(Key Vault, CI/CD, 헬스체크, 관측성)과 접목하면
**안정적이고 안전한 데이터 액세스 계층**을 구현할 수 있다.
