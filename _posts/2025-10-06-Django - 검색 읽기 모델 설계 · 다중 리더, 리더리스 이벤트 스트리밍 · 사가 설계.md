---
layout: post
title: Django - 검색 읽기 모델 설계 · 다중 리더, 리더리스 이벤트 스트리밍 · 사가 설계
date: 2025-10-06 20:25:23 +0900
category: Django
---
# 검색(Indexing) 읽기 모델(Elasticsearch) 설계 · 다중 리더/리더리스 이벤트 스트리밍 · 사가 설계(오케스트레이션 vs 코레오그래피) 비교 (Django 5.x 기준)

> 이 장은 **Elasticsearch(ES) 기반 검색용 읽기 모델**을 Django/Outbox/CQRS 맥락에서 어떻게 설계/운영하는지,  
> **다중 리더/리더리스 이벤트 스트리밍 토폴로지**를 선택할 때의 트레이드오프,  
> 그리고 **사가(Saga) 설계**에서 **오케스트레이션**과 **코레오그래피**를 **끝까지 돌아가는 코드 예제**와 함께 비교합니다.  
> 모든 코드는 ``` 로 감싸며, 수학식이 필요하면 $$ 로 감싸지만 본 문서에는 수학식이 없습니다.

---

## 1) 검색(Indexing) 읽기 모델 — Elasticsearch 설계

### 1-1. 언제 ES 읽기 모델인가?
- **복합 검색**(전/후방 일치, 형태소 분석, 가중치, 하이라이트), **필터/정렬**(다중 필드/점수) 요구가 높음.
- **목록 트래픽**이 크고 RDBMS 인덱스만으로는 확장 한계.
- **CQRS**에서 **읽기 모델**을 “ES 인덱스”로 두면 적재/검색을 분리.

핵심 원칙:
1. **소스 오브 트루스**는 여전히 **쓰기 모델(DB)**.  
2. ES는 **파생 읽기 모델**이며 **최종 일관성**.  
3. **Outbox → Indexer**로 안전하게 적재(idempotent).  
4. **Reindex/백필** 절차를 자동화(롤링 인덱스/에일리어스).

---

### 1-2. 인덱스 설계(상품 Catalog 예시)

#### (1) 매핑/설정
- 한국어 검색: **nori** 형태소 분석기 + 사용자 사전(옵션).
- 정렬/집계에 사용할 **keyword/numeric/date** 필드 병행.
- 자동완성: **edge_ngram** 또는 **completion suggester**.

```json
{
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 1,
    "analysis": {
      "tokenizer": {
        "my_ngram": { "type": "edge_ngram", "min_gram": 1, "max_gram": 20 }
      },
      "analyzer": {
        "ko_nori": { "type": "custom", "tokenizer": "nori_tokenizer" },
        "ko_suggest": {
          "type": "custom",
          "tokenizer": "my_ngram",
          "filter": [ "lowercase" ]
        }
      }
    }
  },
  "mappings": {
    "dynamic": "false",
    "properties": {
      "id":         { "type": "keyword" },
      "tenant_id":  { "type": "keyword" },
      "name":       { "type": "text", "analyzer": "ko_nori", "fields": { "raw": { "type": "keyword" }, "sg": { "type": "text", "analyzer": "ko_suggest" } } },
      "desc":       { "type": "text", "analyzer": "ko_nori" },
      "category":   { "type": "keyword" },
      "price":      { "type": "integer" },
      "rating":     { "type": "float" },
      "is_public":  { "type": "boolean" },
      "created_at": { "type": "date" },
      "tags":       { "type": "keyword" },
      "variants":   { "type": "nested", "properties": {
        "sku": { "type": "keyword" },
        "stock": { "type": "integer" },
        "attrs": { "type": "keyword" }
      } }
    }
  }
}
```

> 팁  
> - 정렬/페이징은 `name.raw` 같은 **keyword 서브필드**로.  
> - 다국어가 많다면 `name_ko/name_en/...` 분리 또는 **multi-field** + **language analyzer**.

#### (2) 도큐먼트 스키마(denormalized)
```json
{
  "id": "P1234",
  "tenant_id": "T1",
  "name": "로지텍 무선 마우스 M650",
  "desc": "저소음 클릭...",
  "category": "peripherals",
  "price": 31900,
  "rating": 4.6,
  "is_public": true,
  "created_at": "2025-10-01T09:00:00Z",
  "tags": ["무선","저소음","사무"],
  "variants": [
    { "sku":"P1234-BK", "stock": 42, "attrs": ["black"] },
    { "sku":"P1234-WH", "stock": 0,  "attrs": ["white"] }
  ]
}
```

---

### 1-3. 인덱싱 파이프라인(Outbox → Indexer)

#### (1) Outbox 이벤트 발행(쓰기 트랜잭션에서)
```python
# apps/catalog/app/services.py (요약)
from shared.outbox.api import add_outbox_event

def publish_product(product):
    add_outbox_event(
        topic="catalog",
        type="ProductUpserted",
        aggregate_id=str(product.id),
        payload={
          "id": product.id, "tenant_id": product.tenant_id,
          "name": product.name, "desc": product.desc, "category": product.category,
          "price": product.price, "rating": float(product.rating),
          "is_public": product.is_public, "created_at": product.created_at.isoformat(),
          "tags": product.tags,
          "variants": [{"sku": v.sku, "stock": v.stock, "attrs": v.attrs} for v in product.variants.all()]
        }
    )
```

#### (2) Indexer(소비자): idempotent upsert
```python
# apps/search/indexer.py
import requests
from django.db import transaction
from shared.outbox.models import OutboxEvent

ES_ENDPOINT = "http://elasticsearch:9200"
INDEX_ALIAS = "products-current"

def index_product(doc):
    # 도큐먼트 ID는 원본 PK로 → 멱등 upsert
    r = requests.put(f"{ES_ENDPOINT}/{INDEX_ALIAS}/_doc/{doc['id']}", json=doc, timeout=5)
    r.raise_for_status()

def delete_product(doc_id):
    requests.delete(f"{ES_ENDPOINT}/{INDEX_ALIAS}/_doc/{doc_id}", timeout=5)

def run_indexer(batch=500):
    qs = OutboxEvent.objects.filter(published=False, topic="catalog").order_by("id")[:batch]
    for ev in qs:
        try:
            if ev.type in ("ProductUpserted",):
                index_product(ev.payload)
            elif ev.type in ("ProductDeleted",):
                delete_product(str(ev.payload["id"]))
            else:
                pass
            ev.published = True
            ev.save(update_fields=["published"])
        except Exception:
            # 재시도/에러 채널 전송
            continue
```

> **멱등성**  
> - 문서 ID 고정(PK) + 전체 스냅샷 적재 → **덮어쓰기**가 멱등.  
> - 부분 업데이트가 필요하면 **`_update`와 버전(version) 필드**를 활용.

---

### 1-4. 검색 API(뷰/DRF)

```python
# apps/search/ui/views.py
from django.http import JsonResponse
import requests

ES = "http://elasticsearch:9200"
ALIAS = "products-current"

def search_products(request):
    q = request.GET.get("q","").strip()
    tenant = request.GET.get("tenant")
    page = int(request.GET.get("page", 1))
    size = min(int(request.GET.get("size", 20)), 100)
    from_ = (page-1)*size

    must = []
    if q:
        must.append({ "multi_match": {
            "query": q,
            "fields": ["name^2", "desc", "tags"],
            "type": "best_fields",
            "operator": "and"
        }})
    if tenant:
        must.append({ "term": {"tenant_id": tenant}})

    body = {
      "from": from_, "size": size,
      "query": { "bool": { "must": must, "filter": [{ "term": {"is_public": True }}]}},
      "sort": [{ "_score": "desc" }, { "created_at": "desc" }],
      "highlight": { "fields": { "name": {}, "desc": {} } }
    }
    r = requests.get(f"{ES}/{ALIAS}/_search", json=body, timeout=5)
    return JsonResponse(r.json())
```

---

### 1-5. 롤링 인덱스/에일리어스 전략

- **버전드 인덱스**: `products-v001`, `products-v002` …  
- **에일리어스**: `products-current` → 버전 인덱스에 포인터.  
- 신규 매핑 변경 시:
  1) 새 인덱스 생성(매핑/설정)  
  2) 백필(Reindex) or Outbox 리플레이  
  3) 스위치: 에일리어스를 새 인덱스로 atomically 전환

```bash
# 1) 새 인덱스 생성
PUT /products-v002
{ ...settings..., ...mappings... }

# 2) Reindex (옵션)
POST /_reindex
{
  "source": { "index": "products-v001" },
  "dest": { "index": "products-v002" }
}

# 3) Alias 스위치
POST /_aliases
{
  "actions": [
    { "remove": { "alias":"products-current", "index":"products-v001" } },
    { "add":    { "alias":"products-current", "index":"products-v002" } }
  ]
}
```

---

### 1-6. 일관성/버전/삭제

- 이벤트 페이로드에 **`version`(증분)** 포함 → ES 문서에 `_version`(외부 버전)로 저장.  
- Indexer는 **낮은 버전** 이벤트는 **무시**(늦게 도착한 과거 이벤트).  
- 삭제는 **소프트 삭제**: `is_public=false` + **filter** 또는 진짜 삭제 이벤트 처리.

```python
# 예: 외부 버전 사용 (requests 예시)
def index_with_version(doc, version):
    r = requests.put(f"{ES_ENDPOINT}/{INDEX_ALIAS}/_doc/{doc['id']}?if_primary_term=1&if_seq_no=0",
                     json=doc, timeout=5, headers={"X-Event-Version": str(version)})
```

> ES의 공식 외부 버전 필드는 `version_type=external` 파라미터를 사용. 실제 요청 시 `?version=123&version_type=external`.

---

### 1-7. 성능/운영 체크리스트
- [ ] **배치 적재**: `/_bulk` API 사용, 5~15MB 청크 기준  
- [ ] **리프레시 정책**: 실시간성이 덜 중요하면 `refresh=false` + 주기적 `/_refresh`  
- [ ] **ILM**: 핫/웜/콜드/삭제 정책 설정(로그성 데이터)  
- [ ] **모니터링**: 색인 지연, 검색 지연, 큐 적체, 샤드 할당, GC  
- [ ] **보안**: API 키/역할 기반, PII 최소화(토큰화/필드 제거)

---

## 2) 다중 리더/리더리스 이벤트 스트리밍

읽기 모델/사가/서비스 간 통신을 위해 스트리밍 인프라를 선택합니다. 대표적 선택지들의 **의미적 보장/스케일/운영 복잡도**를 비교합니다.

### 2-1. 개념/옵션 개관

- **단일 리더(싱글 브로커/데이터베이스 기반 Outbox 폴링)**  
  - 장점: 단순/운영 쉬움, DB 트랜잭션과 일원화  
  - 단점: 처리량/지연 한계, 폴링 부하
- **다중 리더(분산 로그, Kafka 등)**  
  - 장점: 고처리량/내결함성, 파티션 단위 순서 보장  
  - 단점: 운영/러닝 커브, 스키마 진화/재처리까지 고려 필요
- **리더리스(서버리스 이벤트 버스, SNS/SQS, Pub/Sub)**  
  - 장점: 운영 단순, 자동 확장  
  - 단점: 정확히-한번(x1) 어려움, 순서 보장 약함(옵션/전략 필요)

---

### 2-2. 보장/특성 비교(요약)

| 항목 | 단일 리더(Outbox) | 다중 리더(Kafka 등) | 리더리스(SNS/SQS, Pub/Sub 등) |
|---|---|---|---|
| 처리량 | 중 | 매우 높음 | 높음(지역/서비스별) |
| 순서 | DB PK/시간순(대략) | **파티션 내 순서 보장** | 기본 비보장(옵션 일부) |
| 재처리 | DB 기반 리플레이 용이 | 오프셋 기반 리플레이 쉬움 | DLQ/재시도 패턴 |
| 정확히-한번 | 애플리케이션 멱등성으로 근사 | 트랜잭션/Idempotent 소비 + EOS(플랫폼 의존) | 멱등키/중복 제거로 근사 |
| 운영 복잡도 | 낮음 | 높음(클러스터/토픽 관리) | 낮음(관리형) |

> **권장**: **시작은 Outbox 폴링**으로, **트래픽/팀 성숙도**가 올라가면 Kafka 계열로 확장.

---

### 2-3. Kafka(다중 리더) 파티셔닝/키 설계

- **키 지정**: `aggregate_id` 또는 `tenant_id` + `aggregate_id` → **같은 애그리게이트의 이벤트 순서 보장**.  
- **컨슈머 그룹**: 스케일 아웃, **파티션 개수 ≥ 컨슈머 수**.  
- **정확히-한번**: Idempotent Producer + Transactional, Consumer의 멱등 처리(업서트/버전체크)로 현실적 만족.

```python
# pseudo-producer
producer.send("orders", key=b"order-123", value=payload_bytes)
```

컨슈머 멱등 처리:
```python
# 메시지마다 event_id/version 검사 → 이미 처리되었으면 skip
def handle_event(ev):
    if processed_log.exists(ev.id): return
    apply(ev)
    processed_log.add(ev.id)
```

---

### 2-4. 리더리스(SNS/SQS, Pub/Sub)에서 순서/중복 처리

- **FIFO 큐**(SQS FIFO): 메시지 그룹 ID로 순서 보장, 중복 제거(디듀플리케이션 ID).  
- **Pub/Sub**류: **중복 가능** → **멱등 키**(event_id)와 **업서트**로 해결.  
- **DLQ**: 독성 메시지 격리.

SQS FIFO 예:
```python
# boto3 pseudo
sqs.send_message(
  QueueUrl=URL, MessageBody=json.dumps(ev),
  MessageGroupId=f"order-{ev['order_id']}",
  MessageDeduplicationId=str(ev["event_id"])
)
```

---

### 2-5. 순서/일관성 설계 패턴

- **Same-partition guarantee**: 같은 애그리게이트 키로 파티셔닝.  
- **Out-of-order 수용**: 이벤트에 **버전** 포함 → 소비자는 낮은 버전 무시.  
- **Exactly-once 근사**: (1) 멱등 업서트, (2) 처리 로그 테이블(이벤트 ID 기록), (3) 트랜잭션 경계에서 커밋 순서 보장.

처리 로그 테이블:
```python
# processed_events(id primary key, processed_at)
# 핸들러:
if not ProcessedEvent.objects.filter(id=ev.id).exists():
    with transaction.atomic():
        apply(ev)
        ProcessedEvent.objects.create(id=ev.id)
```

---

## 3) 사가(Saga) 설계 — 오케스트레이션 vs 코레오그래피

도메인: **주문(Order) ←→ 결제(Payment) ←→ 재고(Inventory)**

### 3-1. 오케스트레이션(중앙 조정자)

- **오케스트레이터 서비스**가 각 참여자에게 **명령을 발행**하고 응답/이벤트를 수집, **상태머신**으로 흐름 제어.
- 장점: **제어/가시성** 높음, 타임아웃/보상 로직 중앙화.
- 단점: 중앙 집중/단일 실패점 가능, 복잡한 오케스트레이터 코드.

#### (1) 상태머신(간단)
```
NEW → (ReserveStock) → STOCK_RESERVED → (AuthorizePayment) → PAID → (Complete)
          └── 실패 → COMPENSATE(ReleaseStock)
```

#### (2) 오케스트레이터 구현 예

```python
# apps/saga/orchestrator.py
from dataclasses import dataclass
from enum import Enum
from django.db import transaction
from shared.outbox.api import add_outbox_event

class SagaState(str, Enum):
    NEW="NEW"; STOCK_RESERVED="STOCK_RESERVED"; PAID="PAID"; FAILED="FAILED"

@dataclass
class OrderSaga:
    order_id: int
    state: SagaState = SagaState.NEW
    reason: str | None = None

class OrderSagaRepo:
    # DB로 영속화하는 저장소 (생략)
    ...

class OrderOrchestrator:
    def __init__(self, repo: OrderSagaRepo):
        self.repo = repo

    def start(self, order_id: int):
        saga = OrderSaga(order_id)
        self.repo.save(saga)
        # 1) 재고 예약 명령 발행
        add_outbox_event("inventory", "ReserveStockCommand", str(order_id), {"order_id": order_id})

    def on_stock_reserved(self, order_id: int):
        saga = self.repo.get(order_id)
        if saga.state != SagaState.NEW: return
        saga.state = SagaState.STOCK_RESERVED
        self.repo.save(saga)
        # 2) 결제 승인 명령 발행
        add_outbox_event("payment", "AuthorizePaymentCommand", str(order_id), {"order_id": order_id})

    def on_payment_authorized(self, order_id: int):
        saga = self.repo.get(order_id)
        if saga.state != SagaState.STOCK_RESERVED: return
        saga.state = SagaState.PAID
        self.repo.save(saga)
        # 3) 주문 확정 이벤트
        add_outbox_event("orders", "OrderCompleted", str(order_id), {"order_id": order_id})

    def on_stock_failed(self, order_id: int, reason: str):
        saga = self.repo.get(order_id)
        if saga.state == SagaState.NEW:
            saga.state = SagaState.FAILED; saga.reason = reason; self.repo.save(saga)
            # 보상은 필요없음(예약 실패)
            add_outbox_event("orders","OrderCancelled",str(order_id),{"reason":reason})

    def on_payment_failed(self, order_id: int, reason: str):
        saga = self.repo.get(order_id)
        if saga.state == SagaState.STOCK_RESERVED:
            # 보상: 재고 예약 해제
            add_outbox_event("inventory","ReleaseStockCommand",str(order_id),{"order_id": order_id})
            saga.state = SagaState.FAILED; saga.reason = reason; self.repo.save(saga)
            add_outbox_event("orders","OrderCancelled",str(order_id),{"reason":reason})
```

이벤트 라우팅(컨슈머)에서 오케스트레이터 호출:

```python
# apps/saga/consumers.py
def on_inventory_event(ev):
    if ev.type == "StockReserved":
        orchestrator.on_stock_reserved(ev.payload["order_id"])
    elif ev.type == "StockReserveFailed":
        orchestrator.on_stock_failed(ev.payload["order_id"], ev.payload.get("reason",""))

def on_payment_event(ev):
    if ev.type == "PaymentAuthorized":
        orchestrator.on_payment_authorized(ev.payload["order_id"])
    elif ev.type == "PaymentFailed":
        orchestrator.on_payment_failed(ev.payload["order_id"], ev.payload.get("reason",""))
```

> **타임아웃/리트라이스**: 오케스트레이터가 **타이머 이벤트**를 갖고, 일정 시간 응답 없으면 보상/실패로 전이.

---

### 3-2. 코레오그래피(분산 협업)

- 중앙 조정자 없이 **각 서비스가 이벤트를 구독**하고 **다음 액션을 자율** 수행.
- 장점: 느슨한 결합, 간단한 시작.
- 단점: **흐름이 분산되어 가시성 저하**, 타임아웃/보상 로직의 **중복/복잡화**.

#### (1) 이벤트 흐름
```
Orders emits OrderCreated  ─→ Inventory reserves → emits StockReserved
                                             └→ 실패 시 StockReserveFailed
Orders consumes StockReserved → emits PaymentRequested
Payments consumes PaymentRequested → emits PaymentAuthorized / PaymentFailed
Orders consumes PaymentAuthorized → OrderCompleted
Orders consumes PaymentFailed → emits ReleaseStockRequested
Inventory consumes ReleaseStockRequested → release
```

#### (2) 각 서비스 간단 소비자 예

**Inventory**
```python
def on_order_created(ev):
    ok = try_reserve(ev["order_id"])
    if ok:
        add_outbox_event("inventory","StockReserved",str(ev["order_id"]),{"order_id": ev["order_id"]})
    else:
        add_outbox_event("inventory","StockReserveFailed",str(ev["order_id"]),{"order_id": ev["order_id"], "reason":"no stock"})
```

**Orders**
```python
def on_stock_reserved(ev):
    add_outbox_event("orders","PaymentRequested",str(ev["order_id"]),{"order_id": ev["order_id"]})

def on_payment_authorized(ev):
    add_outbox_event("orders","OrderCompleted",str(ev["order_id"]),{"order_id": ev["order_id"]})

def on_payment_failed(ev):
    add_outbox_event("orders","ReleaseStockRequested",str(ev["order_id"]),{"order_id": ev["order_id"], "reason":"pay fail"})
```

**Payments**
```python
def on_payment_requested(ev):
    if authorize(ev["order_id"]):
        add_outbox_event("payment","PaymentAuthorized",str(ev["order_id"]),{"order_id": ev["order_id"]})
    else:
        add_outbox_event("payment","PaymentFailed",str(ev["order_id"]),{"order_id": ev["order_id"]})
```

**Inventory(보상)**
```python
def on_release_stock_requested(ev):
    release(ev["order_id"])
```

> **가시성 보완**: **사가 로그**/추적을 **별도 읽기 모델**로 구성(각 이벤트 소비 시 상태머신 스냅샷 기록).

---

### 3-3. 어떤 방식을 선택할까?

| 기준 | 오케스트레이션 | 코레오그래피 |
|---|---|---|
| 제어/가시성 | **높음**(중앙 상태/타임라인) | 낮음(분산, 별도 관측 필요) |
| 복잡도 | 오케스트레이터 복잡 ↑ | 서비스 개별 핸들러 분산, 초기 단순 |
| 장애 고립 | 중앙 의존 ↑ | 분산, 서비스 독립 ↑ |
| 타임아웃/보상 | 중앙에서 일관 제어 | 각 서비스가 자체 구현(중복 우려) |
| 팀 규모/숙련 | 중~대팀에 적합 | 소~중 규모/단순 흐름에 적합 |

> **권장**: 코어 비즈니스 플로우/금전거래 등은 **오케스트레이션**(명확/감사 용이),  
> 주변/단순 워크플로는 **코레오그래피**.

---

### 3-4. 사가 운영 패턴

- **재시도/백오프**: 일시적 오류 회복.  
- **타임아웃 이벤트**: 오케스트레이터/각 서비스에서 타이머 기반 취소/보상.  
- **독성 메시지 처리(DLQ)**: 실패 이벤트 격리/수동 조사.  
- **관측성**: 사가 인스턴스 상태, 단계별 레이턴시, 실패율, 보상 빈도.

사가 대시보드 읽기 모델(요약):

```python
# apps/saga/readmodels.py
class SagaTimeline(models.Model):
    saga_id = models.UUIDField(db_index=True)
    order_id = models.IntegerField(db_index=True)
    step = models.CharField(max_length=40)
    status = models.CharField(max_length=20)
    meta = models.JSONField(default=dict)
    ts = models.DateTimeField(auto_now_add=True)
```

각 이벤트 소비 시 `SagaTimeline` 에 append → **타임라인 UI**.

---

## 4) E2E 운영 시나리오: “카탈로그 검색 + 주문 사가”

1) **카탈로그** 변경 → **Outbox** → **Indexer** → ES 인덱스 업데이트.  
2) 사용자는 ES로 검색/필터/정렬/자동완성.  
3) 주문 생성 → **사가 오케스트레이터**가 재고 예약/결제 승인 순차 수행.  
4) 각 단계 이벤트는 Outbox로 발행 → 읽기 모델(사가 타임라인/주문 요약) 업데이트.  
5) 실패 시 보상 로직(재고 해제/주문 취소) 적용.  
6) 모니터링: Outbox 적체/ES 색인 지연/사가 실패율/레이턴시.

---

## 5) 테스트/리플레이/백필

- **ES 백필**: RDB → 스냅샷 export → 배치 `/_bulk` 적재 or Outbox 전체 리플레이.  
- **사가 회귀 테스트**: 성공/실패/시간초과 케이스 JSON 시퀀스 재생.  
- **스트리밍 회귀**: 소비자 단위로 **샘플 이벤트** 재생(멱등/순서 무작위) 테스트.

예: 이벤트 재생 유틸
```python
def replay_events(events, consumers):
    # events: [(topic, type, payload, version), ...]
    for e in events:
        for c in consumers:
            c.consume(e)
```

---

## 6) 보안/컴플라이언스

- ES 인덱스에 **PII 저장 최소화**(익명화/토큰화).  
- 이벤트 페이로드 **스키마/버전 관리**(하위 호환, 업캐스트).  
- **감사 추적**: 사가 타임라인/Outbox/Event Store 접근 제어, 변경 불가(append-only).

---

## 7) 체크리스트(요약)

**ES**
- [ ] 파생 인덱스 스키마(검색/정렬/필터) 명확화  
- [ ] Outbox → Indexer 멱등 업서트, 외부 버전  
- [ ] 롤링 인덱스/에일리어스/리인덱스  
- [ ] `_bulk`/리프레시/ILM/모니터링

**스트리밍**
- [ ] 파티션 키(애그리게이트) 설계, out-of-order 대비 버전 비교  
- [ ] 멱등 처리(업서트/처리로그), DLQ  
- [ ] 선택: Outbox→(추후)Kafka/리더리스로 확장

**사가**
- [ ] 오케스트레이션 vs 코레오그래피 선택 기준 정의  
- [ ] 타임아웃/보상/재시도/대시보드  
- [ ] 사가 타임라인 읽기 모델

---

## 8) 부록 — 실전 스니펫 모음

### 8-1. ES Bulk 적재(파이썬)
```python
import requests, json

def bulk_index(index, docs):
    body = []
    for d in docs:
        body.append(json.dumps({"index": {"_index": index, "_id": d["id"]}}))
        body.append(json.dumps(d, ensure_ascii=False))
    data = "\n".join(body) + "\n"
    r = requests.post(f"http://elasticsearch:9200/_bulk", data=data.encode("utf-8"),
                      headers={"Content-Type":"application/x-ndjson"}, timeout=10)
    r.raise_for_status()
    res = r.json()
    if res.get("errors"):
        # 실패 항목 로깅/재시도
        pass
```

### 8-2. ES 제안(autocomplete) 쿼리
```json
{
  "suggest": {
    "name-suggest": {
      "prefix": "로지",
      "completion": { "field": "name.sg" }
    }
  }
}
```

### 8-3. 사가 타임아웃(단순)
```python
# 오케스트레이터 주기 잡에서
def sweep_timeouts():
    for saga in repo.find_state("STOCK_RESERVED"):
        if saga.updated_at < now() - timedelta(minutes=3):
            orchestrator.on_payment_failed(saga.order_id, "timeout")
```

### 8-4. 이벤트 업캐스터 공용 훅
```python
def upcast_event(ev: dict) -> dict:
    if ev["type"] == "ProductUpserted" and "rating" not in ev["payload"]:
        ev["payload"]["rating"] = 0.0
    return ev
```

---

## 9) 마무리

- **검색 읽기 모델**은 ES에 맞춰 **도큐먼트/매핑/인덱싱 파이프라인**을 설계하고, **Outbox 멱등성**과 **롤링 인덱스**로 안전하게 운용하세요.  
- **이벤트 스트리밍**은 **Outbox → (필요 시) Kafka/리더리스**로 성장 경로를 두고, **파티션/버전/멱등**을 표준화하세요.  
- **사가**는 비즈니스 중요도와 팀 역량에 맞춰 **오케스트레이션**(중앙 제어)과 **코레오그래피**(분산 협업)를 선택/혼용하며, **타임라인 읽기 모델**로 관측성을 확보하는 것이 핵심입니다.
