---
layout: post
title: MFC - 데이터베이스 연동
date: 2025-09-01 21:25:23 +0900
category: MFC
---
# 데이터베이스 연동: ODBC/DAO 개요, SQLite 연동 관점(서드파티 라이브러리 활용 방법론)

이 글은 MFC/Win32 C++ 앱에서 **데이터베이스에 안전하고 빠르게 연결**하는 법을 한 번에 정리합니다.  
전통 **ODBC/DAO**의 차이와 실전 팁, 그리고 **SQLite**를 **ODBC 드라이버** 혹은 **네이티브 라이브러리(sqlite3)** 로 붙이는 두 가지 전략을 **예제 중심**으로 다룹니다.

> 대상: Windows 10/11, x64/Unicode, MFC `CWinApp(Ex)` 기반 앱  
> 범위: 연결/트랜잭션/에러 처리/성능/동시성/마이그레이션/배포까지 실무 전 과정을 포함

---

## 0) 큰 그림 한 장 요약

| 항목 | ODBC | DAO | SQLite(ODBC) | SQLite(네이티브) |
|---|---|---|---|---|
| 개념 | 범용 DB 표준 드라이버 계층 | Jet/Access 중심(레거시) | SQLite 파일을 ODBC로 접속 | sqlite3 C API 직접 사용 |
| 의존성 | ODBC 드라이버 설치 필요 | MDAC/Jet(레거시·비추) | SQLite용 ODBC 드라이버 | `sqlite3.dll` 또는 정적 링크 |
| 장점 | **DB 교체 유연**(MSSQL/MySQL/…); MFC 도우미(`CDatabase`, `CRecordset`) | RAD 느낌(과거), Access에 적합 | 기존 ODBC 코드 재사용 | 의존 최소/속도 빠름/기능 최신 |
| 단점 | 드라이버/DSN 관리, 진단 코드 파악 필요 | 최신 윈도우/64비트에서 부담 | 드라이버 품질·옵션 편차 | C API라 래핑 필요 |
| 도입 추천 | 기업 DB, 교차 DB 지원 앱 | **권장 X(레거시)** | 기존 ODBC 레이어 유지 | **가장 일반&권장** |

**실무 기본 추천**  
- 기업 DB(서버): **ODBC (MSSQL, Oracle, MySQL/MariaDB, PostgreSQL 등)**  
- 단일 파일 DB/오프라인: **SQLite 네이티브(sqlite3)**  
- 기존 ODBC 기반 코드 재사용하면서 SQLite로 개발: **SQLite ODBC 드라이버**

---

# 1) ODBC 빠른 개요

### 1-1. 구조
- **Application** ↔ **ODBC Driver Manager** ↔ **ODBC Driver (DB별)** ↔ **DBMS**
- MFC 래퍼: **`CDatabase`(연결)**, **`CRecordset`(쿼리/레코드)**

### 1-2. DSN/DSN-less 연결
- DSN: 제어판 ODBC 관리자(32/64비트 구분)에서 **사전 구성**
- DSN-less: 연결 문자열로 **드라이버+옵션** 지정(배포 편의 ↑)

**예: DSN-less (SQL Server)**
```cpp
CDatabase db;
CString sConn = 
  L"Driver={ODBC Driver 17 for SQL Server};"
  L"Server=tcp:myserver.database.windows.net,1433;"
  L"Database=Sales;Uid=appuser;Pwd=****;Encrypt=yes;TrustServerCertificate=no;";
db.OpenEx(sConn, CDatabase::openReadOnly | CDatabase::noOdbcDialog);
```

### 1-3. 트랜잭션
```cpp
db.BeginTrans();
try {
    db.ExecuteSQL(L"INSERT INTO Orders(CustomerId,Amount) VALUES(42, 199.0)");
    db.ExecuteSQL(L"UPDATE Customers SET Balance = Balance + 199.0 WHERE Id=42");
    db.CommitTrans();
} catch (...) {
    db.Rollback();
    throw;
}
```

### 1-4. 레코드셋 바인딩(정적 SQL)
```cpp
class CCustomersSet : public CRecordset {
public:
    CString m_Name; long m_Id; double m_Balance;
    CCustomersSet(CDatabase* pDB): CRecordset(pDB){ m_nDefaultType=snapshot; }
    CString GetDefaultSQL() override { return L"[dbo].[Customers]"; }
    void DoFieldExchange(CFieldExchange* pFX) override {
        pFX->SetFieldType(CFieldExchange::outputColumn);
        RFX_Long   (pFX, L"[Id]",      m_Id);
        RFX_Text   (pFX, L"[Name]",    m_Name);
        RFX_Double (pFX, L"[Balance]", m_Balance);
    }
};

CCustomersSet rs(&db);
rs.Open();
while(!rs.IsEOF()){
    wprintf(L"%ld %s %.2f\n", rs.m_Id, rs.m_Name.GetString(), rs.m_Balance);
    rs.MoveNext();
}
```

### 1-5. 동적 SQL/파라미터 바인딩(실전)
```cpp
CRecordset rs(&db);
rs.m_nDefaultType = snapshot;
rs.Open(CRecordset::forwardOnly, L"{CALL GetOrdersForCustomer(?)}"); // 또는 "SELECT ... WHERE CustomerId=?"

short custId = 42;
rs.BindParam(0, SQL_PARAM_INPUT, SQL_C_SSHORT, SQL_SMALLINT, 0, 0, &custId, 0);
```
> MFC 기본 `CRecordset`은 **복잡한 파라미터 바인딩**이 번거로울 수 있습니다.  
> 고급 사용자는 **원시 ODBC API(SQLPrepare/SQLBindParameter/SQLExecute)** 를 직접 쓰기도 합니다.

### 1-6. 에러/진단
- `CDatabase::GetLastError` 또는 원시 ODBC `SQLGetDiagRec` 로 **SQLSTATE/Native Error** 확인
- **에러 메시지 로깅** 필수(장애 분석)

---

# 2) DAO 개요(레거시)

- **Microsoft Jet/Access**용으로 편리하지만, 64비트/최신 윈도우에서 투자 가치 ↓  
- 새로운 프로젝트에선 **권장하지 않음**. Access 파일을 다뤄야 한다면 **ACE OLEDB** 또는 **ODBC** 경로를 권장.

> 이하 본문은 **ODBC**와 **SQLite**에 집중합니다.

---

# 3) SQLite를 ODBC로: “ODBC 레이어 유지 + SQLite 파일 사용”

### 3-1. 언제 쓰나?
- 기존 ODBC 중심 코드/프레임워크가 이미 있을 때
- DB를 **파일형(SQLite)** 로 바꾸고 싶지만 **상위 코드 최소 변경**을 원할 때

### 3-2. 장단점
- 장점: 코드 재사용, DB 교체 유연성 유지  
- 단점: 드라이버마다 **성능/PRAGMA/확장** 편차. **sqlite3 네이티브 대비 느릴 수 있음**

### 3-3. 연결 예(DSN-less)
```cpp
CDatabase db;
CString sConn = 
  L"Driver=SQLite3 ODBC Driver;"
  L"Database=C:\\Data\\app.db;"
  L"Timeout=2000;";
db.OpenEx(sConn, CDatabase::noOdbcDialog);
db.ExecuteSQL(L"CREATE TABLE IF NOT EXISTS notes(id INTEGER PRIMARY KEY, text TEXT)");
db.ExecuteSQL(L"INSERT INTO notes(text) VALUES('hello via ODBC')");
```

### 3-4. 트랜잭션(중요)
```cpp
db.ExecuteSQL(L"BEGIN IMMEDIATE TRANSACTION");
try {
    db.ExecuteSQL(L"INSERT INTO notes(text) VALUES('bulk1')");
    db.ExecuteSQL(L"INSERT INTO notes(text) VALUES('bulk2')");
    db.ExecuteSQL(L"COMMIT");
} catch (...) {
    db.ExecuteSQL(L"ROLLBACK");
    throw;
}
```

> SQLite는 트랜잭션을 묶지 않으면 **삽입 수천 건에서 급격히 느려집니다.** 꼭 묶으세요.

---

# 4) SQLite 네이티브: sqlite3 C API 직접 사용(권장)

### 4-1. 배포/링크
- **sqlite.org**의 **Amalgamation**(sqlite3.c/.h) 정적 링크, 또는 `sqlite3.dll` 로 동적 링크
- x64/Release 최적화, `/utf-8` 사용 시 편의 ↑

### 4-2. 기본 흐름
```cpp
#include "sqlite3.h"

sqlite3* db = nullptr;
if (sqlite3_open16(L"c:\\data\\app.db", &db) != SQLITE_OK) {
    wprintf(L"open fail: %S\n", sqlite3_errmsg(db)); // errmsg는 UTF-8, %S로 출력
    return;
}

// 성능/일관성 권장 PRAGMA
sqlite3_exec(db, "PRAGMA journal_mode=WAL;", nullptr, nullptr, nullptr);
sqlite3_exec(db, "PRAGMA synchronous=NORMAL;", nullptr, nullptr, nullptr);
sqlite3_exec(db, "PRAGMA foreign_keys=ON;", nullptr, nullptr, nullptr);

sqlite3_exec(db, "CREATE TABLE IF NOT EXISTS notes(id INTEGER PRIMARY KEY, text TEXT)", nullptr, nullptr, nullptr);
sqlite3_close(db);
```

### 4-3. Prepared Statement + 바인딩
```cpp
sqlite3* db = nullptr;
sqlite3_open16(L"c:\\data\\app.db", &db);

sqlite3_stmt* stmt = nullptr;
sqlite3_prepare_v2(db, "INSERT INTO notes(text) VALUES(?)", -1, &stmt, nullptr);

const char* msg = "안녕하세요, SQLite!";
sqlite3_bind_text(stmt, 1, msg, -1, SQLITE_TRANSIENT); // UTF-8

sqlite3_step(stmt);             // 1행 수행
sqlite3_finalize(stmt);

// 조회
sqlite3_prepare_v2(db, "SELECT id, text FROM notes ORDER BY id", -1, &stmt, nullptr);
while (sqlite3_step(stmt) == SQLITE_ROW) {
    int id = sqlite3_column_int(stmt, 0);
    const unsigned char* txt = sqlite3_column_text(stmt, 1); // UTF-8
    printf("%d %s\n", id, txt);
}
sqlite3_finalize(stmt);
sqlite3_close(db);
```

### 4-4. 트랜잭션 + 대량 삽입(필수 패턴)
```cpp
sqlite3_exec(db, "BEGIN IMMEDIATE TRANSACTION", nullptr, nullptr, nullptr);

sqlite3_stmt* st=nullptr;
sqlite3_prepare_v2(db, "INSERT INTO logs(ts, msg) VALUES(strftime('%Y-%m-%dT%H:%M:%f','now'), ?)", -1, &st, nullptr);

for (int i=0;i<10000;i++){
    std::string m = "row-" + std::to_string(i);
    sqlite3_bind_text(st, 1, m.c_str(), -1, SQLITE_TRANSIENT);
    if (sqlite3_step(st) != SQLITE_DONE) { /* 에러 처리 */ }
    sqlite3_reset(st);
    sqlite3_clear_bindings(st);
}

sqlite3_finalize(st);
sqlite3_exec(db, "COMMIT", nullptr, nullptr, nullptr);
```

### 4-5. BLOB 처리
```cpp
// 저장
std::vector<uint8_t> blob = {/*...*/};
sqlite3_stmt* st=nullptr;
sqlite3_prepare_v2(db, "INSERT INTO blobs(name, data) VALUES(?, ?)", -1, &st, nullptr);
sqlite3_bind_text(st, 1, "image.bin", -1, SQLITE_STATIC);
sqlite3_bind_blob(st, 2, blob.data(), (int)blob.size(), SQLITE_TRANSIENT);
sqlite3_step(st);
sqlite3_finalize(st);

// 읽기
sqlite3_prepare_v2(db, "SELECT data FROM blobs WHERE name=?", -1, &st, nullptr);
sqlite3_bind_text(st, 1, "image.bin", -1, SQLITE_STATIC);
if (sqlite3_step(st) == SQLITE_ROW) {
    const void* p = sqlite3_column_blob(st, 0);
    int len = sqlite3_column_bytes(st, 0);
    std::vector<uint8_t> out((const uint8_t*)p, (const uint8_t*)p + len);
}
sqlite3_finalize(st);
```

### 4-6. Busy 핸들러/타임아웃(동시 접근)
```cpp
// 다른 프로세스/스레드가 파일 잠금 중일 때 대기
sqlite3_busy_timeout(db, 3000); // ms

// 또는 커스텀
sqlite3_busy_handler(db, [](void*, int cnt)->int {
    Sleep(50); return cnt < 60; // 최대 3초
}, nullptr);
```

### 4-7. 스레딩 모드
- 기본 빌드: **Serialized**(멀티스레드 안전) 권장
- 하나의 `sqlite3*` 를 여러 스레드가 동시에 사용해도 되지만, **Statement 단위 동시 호출 금지**
- 고성능은 **스레드별 연결**을 만들어 **작업 큐**로 분배

### 4-8. 마이그레이션(스키마 버전 관리)
```cpp
// 앱 시작 시
sqlite3_exec(db, 
"CREATE TABLE IF NOT EXISTS meta(key TEXT PRIMARY KEY, val TEXT);"
"INSERT OR IGNORE INTO meta(key,val) VALUES('schema','1');", nullptr,nullptr,nullptr);

// 현재 버전 확인
int ver = 0;
sqlite3_stmt* st=nullptr;
sqlite3_prepare_v2(db, "SELECT val FROM meta WHERE key='schema'", -1, &st, nullptr);
if (sqlite3_step(st)==SQLITE_ROW) ver = atoi((const char*)sqlite3_column_text(st,0));
sqlite3_finalize(st);

// 업그레이드
if (ver < 2) {
  sqlite3_exec(db, "BEGIN", nullptr,nullptr,nullptr);
  sqlite3_exec(db, "ALTER TABLE notes ADD COLUMN tag TEXT", nullptr,nullptr,nullptr);
  sqlite3_exec(db, "UPDATE meta SET val='2' WHERE key='schema'", nullptr,nullptr,nullptr);
  sqlite3_exec(db, "COMMIT", nullptr,nullptr,nullptr);
}
```

### 4-9. 인덱스/쿼리 튜닝
```sql
CREATE INDEX IF NOT EXISTS idx_notes_text ON notes(text);
EXPLAIN QUERY PLAN SELECT * FROM notes WHERE text LIKE 'foo%';
```
- **LIKE** 검색은 `PRAGMA case_sensitive_like=ON` / `fts5`(전문검색) 고려

### 4-10. 암호화(옵션)
- 공식 SEE(유료) 또는 **SQLCipher**(오픈소스)  
- 사용법은 드라이버/빌드에 따라 상이: `PRAGMA key='passphrase';` 등

---

# 5) MFC 통합(다이얼로그/뷰) — 실전 샘플

## 5-1. 모델 클래스(네이티브 SQLite)
```cpp
class NoteRepo {
    sqlite3* m_db{};
public:
    bool Open(const std::wstring& path) {
        if (sqlite3_open16(path.c_str(), &m_db) != SQLITE_OK) return false;
        sqlite3_exec(m_db, "PRAGMA journal_mode=WAL; PRAGMA synchronous=NORMAL; PRAGMA foreign_keys=ON;", nullptr,nullptr,nullptr);
        sqlite3_exec(m_db, "CREATE TABLE IF NOT EXISTS notes(id INTEGER PRIMARY KEY, text TEXT, created TEXT DEFAULT CURRENT_TIMESTAMP)", nullptr,nullptr,nullptr);
        return true;
    }
    ~NoteRepo(){ if(m_db) sqlite3_close(m_db); }

    bool Add(CStringW text) {
        sqlite3_stmt* st=nullptr;
        sqlite3_prepare_v2(m_db, "INSERT INTO notes(text) VALUES(?)", -1, &st, nullptr);
        std::string u8 = CW2A(text, CP_UTF8);
        sqlite3_bind_text(st, 1, u8.c_str(), -1, SQLITE_TRANSIENT);
        bool ok = (sqlite3_step(st) == SQLITE_DONE);
        sqlite3_finalize(st);
        return ok;
    }
    std::vector<std::tuple<int, CStringW, CStringW>> List() {
        std::vector<std::tuple<int, CStringW, CStringW>> out;
        sqlite3_stmt* st=nullptr;
        sqlite3_prepare_v2(m_db, "SELECT id,text,created FROM notes ORDER BY id DESC", -1, &st, nullptr);
        while(sqlite3_step(st)==SQLITE_ROW){
            int id = sqlite3_column_int(st,0);
            CStringW tx = CA2W((const char*)sqlite3_column_text(st,1), CP_UTF8);
            CStringW cr = CA2W((const char*)sqlite3_column_text(st,2), CP_UTF8);
            out.emplace_back(id, tx, cr);
        }
        sqlite3_finalize(st);
        return out;
    }
};
```

## 5-2. 다이얼로그에서 리스트뷰 채우기
```cpp
// 멤버: CListCtrl m_list; NoteRepo m_repo;

BOOL CMainDlg::OnInitDialog() {
    CDialogEx::OnInitDialog();
    m_list.SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_DOUBLEBUFFER);
    m_list.InsertColumn(0, L"ID", LVCFMT_RIGHT, 60);
    m_list.InsertColumn(1, L"Text", LVCFMT_LEFT, 300);
    m_list.InsertColumn(2, L"Created", LVCFMT_LEFT, 160);

    m_repo.Open(L"C:\\Data\\notes.db");
    RefreshList();
    return TRUE;
}

void CMainDlg::RefreshList(){
    m_list.DeleteAllItems();
    auto rows = m_repo.List();
    int i=0;
    for(auto& r : rows){
        int id; CStringW text, created;
        std::tie(id,text,created) = r;
        int row = m_list.InsertItem(i, std::to_wstring(id).c_str());
        m_list.SetItemText(row, 1, text);
        m_list.SetItemText(row, 2, created);
        ++i;
    }
}

void CMainDlg::OnBnClickedAdd(){
    CStringW s; GetDlgItemText(IDC_EDIT_TEXT, s);
    if (s.Trim().IsEmpty()) return;
    if (m_repo.Add(s)) RefreshList();
}
```

---

# 6) 오류 처리/로그/복구

- 네이티브: `sqlite3_errcode`, `sqlite3_errmsg`  
- ODBC: `SQLGetDiagRec` / `CDatabase::GetLastError`  
- **로그 파일 롤링** + **사용자 친화 메시지**(권한/경로/잠금/디스크 부족)

```cpp
auto ExecChecked = [&](sqlite3* db, const char* sql){
    char* err=nullptr;
    if (sqlite3_exec(db, sql, nullptr, nullptr, &err) != SQLITE_OK) {
        CStringW w = CA2W(err?err:"", CP_UTF8);
        // 로그 기록
        sqlite3_free(err);
        throw std::runtime_error("sqlite error");
    }
};
```

---

# 7) 동시성/락/백업

### 7-1. SQLite 파일 락과 WAL
- **WAL 모드**: **읽기 다중, 쓰기 단일**을 높은 처리량으로 허용  
- **busy_timeout** 으로 충돌 완화, **트랜잭션 길이 최소화**

### 7-2. 앱 전역 뮤텍스 + 트랜잭션
- 여러 프로세스가 같은 DB를 쓰면 충돌 ↑ → 가능하면 **단일 프로세스** 또는 **서버화** 고민  
- 백업은 **`sqlite3_backup` API** 권장(온더플라이)

```cpp
// 백업: src -> dst
sqlite3* src=nullptr; sqlite3_open("app.db", &src);
sqlite3* dst=nullptr; sqlite3_open("backup.db", &dst);

sqlite3_backup* bk = sqlite3_backup_init(dst, "main", src, "main");
if (bk) {
    sqlite3_backup_step(bk, -1); // all
    sqlite3_backup_finish(bk);
}
sqlite3_close(dst); sqlite3_close(src);
```

---

# 8) 성능 체크리스트

1. 대량 삽입/갱신은 **Prepared + 트랜잭션**  
2. 인덱스 전략 확인(WHERE/JOIN 컬럼)  
3. `PRAGMA journal_mode=WAL; PRAGMA synchronous=NORMAL;` (기본값 비교)  
4. 긴 텍스트/바이너리는 **BLOB/텍스트** 선택 일관화  
5. 결과 페이징: `LIMIT/OFFSET` 또는 **streaming fetch**  
6. ODBC: 드라이버 옵션(커서/패치 크기), 연결 풀링(DriverMgr)  
7. 파일 사이즈/프래그먼트: SQLite `VACUUM` 관리(필요 시)

---

# 9) 배포/설치

- **SQLite 네이티브**: `sqlite3.dll` (또는 정적 링크) + 스키마 생성 코드  
- **ODBC**: 해당 DB의 **x64 ODBC 드라이버** 설치 문서화, DSN-less 권장  
- 설정/DB 위치: `%PROGRAMDATA%`(공용) 또는 `%LOCALAPPDATA%`/문서 폴더(사용자별)  
- UAC/권한: Program Files에 **쓰기 금지**. 앱 데이터 폴더 사용.

---

# 10) 보안/암호화/개인정보

- 민감 데이터는 **암호화**(SQLite: SEE/SQLCipher) 또는 **필드 단위 암호화**  
- ODBC 서버 DB: **TLS/암호 정책/권한(Role)**  
- 로깅 시 **개인정보 마스킹**

---

# 11) 테스트/마이그레이션/리커버리

- **마이그레이션 스크립트** 버전 관리(앞/뒤 호환)  
- **단위 테스트**: CRUD + 트랜잭션 롤백/충돌/에러  
- **복구**: SQLite `.db-wal/.db-shm` 처리, ODBC는 서버 백업/트랜잭션 로그 체계 활용

---

# 12) 고급: 래퍼/ORM/서드파티

- **SQLiteCpp**, **sqlite3pp**, **SOCI**, **nanodbc**: C++ 래퍼/경량 ORM  
- 장점: RAII, 예외, 바인딩 편의  
- 단점: 의존/학습 비용. 필요 범위에 맞춰 선택

**예: SQLiteCpp 스타일(개념 코드)**
```cpp
SQLite::Database db("app.db", SQLite::OPEN_READWRITE|SQLite::OPEN_CREATE);
db.exec("CREATE TABLE IF NOT EXISTS notes(id INTEGER PRIMARY KEY, text TEXT)");
SQLite::Statement q(db, "INSERT INTO notes(text) VALUES(?)");
q.bind(1, "hello");
q.exec();
for (SQLite::Statement s(db, "SELECT id,text FROM notes"); s.executeStep(); ) {
    int id = s.getColumn(0).getInt();
    std::string text = s.getColumn(1).getString();
}
```

---

## 마무리

- **서버형 DB**(MSSQL 등) ↔ **ODBC**, **파일형 DB** ↔ **SQLite 네이티브**가 **가장 실전적 조합**입니다.  
- ODBC의 강점은 **교체 유연성/엔터프라이즈 호환**, SQLite의 강점은 **배포 단순/성능/의존성 최소화**입니다.  
- 어떤 경로든 **Prepared + 트랜잭션 + 에러/로그**가 핵심 3원칙입니다.  
- 위 예제들을 **모듈화(연결/쿼리/트랜잭션/마이그레이션/백업)** 해서 프로젝트에 바로 이식하세요.  