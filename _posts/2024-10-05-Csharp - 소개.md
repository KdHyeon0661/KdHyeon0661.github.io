---
layout: post
title: C# - 소개
date: 2024-10-05 19:20:23 +0900
category: Csharp
---
# C# 소개 및 .NET 개요

## 0. 빠른 개요 (TL;DR)

- **C#**: 정적 타입, OOP/FP 하이브리드, 현대 언어 기능 풍부(제네릭, 람다, LINQ, async/await, 패턴 매칭, records).
- **.NET**: **런타임(CLR)** + **BCL** + **SDK/CLI** + **언어들(C#, F#, VB)** + **프레임워크(ASP.NET Core, MAUI, WPF, WinForms, Worker, Azure Functions 등)**.
- **어디서 쓰나**: 웹(ASP.NET Core/Blazor), 데스크탑(WPF/WinForms/MAUI), 모바일(MAUI), 게임(Unity), 클라우드(Azure), 배치/도구(콘솔/Worker).
- **추천 시작 경로**: `dotnet new` → 콘솔/웹 템플릿 → 단위 테스트 → Docker 컨테이너라이즈 → 클라우드 배포.

---

## 1. C#이란?

**C# (C Sharp)**은 Microsoft가 설계한 **객체지향 + 함수형 요소를 갖춘** 정적 타입 언어입니다.
문법은 Java/C++ 계열과 유사하지만, **패턴 매칭**, **record**, **Span<T>**, **ValueTask**, **async streams**, **source generator** 등 현대 기능이 적극적으로 반영되어 생산성과 성능을 함께 추구합니다.

### 1.1 “Hello, World!”와 즉석 문법 설명

```csharp
using System;

class Program
{
    static void Main()
    {
        Console.WriteLine("Hello, World!");
    }
}
```

- `using System;` : BCL 네임스페이스 참조
- `Main()` : 진입점
- `Console.WriteLine()` : 콘솔 출력

**C# 9+ 탑레벨 문**을 쓰면 더 간단합니다.

```csharp
using System;

Console.WriteLine("Hello, World! (top-level statements)");
```

---

## 2. .NET이란?

**.NET**은 C# 등 다언어를 위한 **런타임/라이브러리/도구 생태계**입니다.

### 2.1 구성 요소 한 눈에

| 구성 요소 | 핵심 역할 |
|---|---|
| **CLR (Common Language Runtime)** | GC, 스레딩, 예외, JIT/컴파일, 보안 등 실행 엔진 |
| **BCL (Base Class Library)** | 파일 I/O, 네트워킹, 컬렉션, 리플렉션 등 표준 라이브러리 |
| **.NET SDK/CLI** | `dotnet` 명령, 컴파일/빌드/테스트/패키징/퍼블리시 |
| **NuGet** | 패키지 관리자(외부 라이브러리 확장) |
| **ASP.NET Core** | 고성능 웹 프레임워크(REST/SignalR/Blazor) |
| **EF Core** | ORM (LINQ 기반 데이터 액세스) |
| **MAUI/WPF/WinForms** | UI 프레임워크(멀티플랫폼/Windows 데스크탑) |
| **Worker/Functions** | 백그라운드/서버리스 워크로드 |

### 2.2 런타임과 배포 모델

- **JIT**: 실행 시 기계어로 컴파일 → 일반적 개발/운영 시 사용
- **R2R(ReadyToRun)**: 빌드 타임 일부 네이티브 → 빠른 시작
- **NativeAOT**: 완전 네이티브 바이너리 생성 → 극저메모리/빠른 cold-start/간편 배포

```bash
# Self-contained + 단일 파일 + R2R 예시
dotnet publish -c Release -r win-x64 -p:PublishSingleFile=true -p:PublishReadyToRun=true --self-contained true
```

---

## 3. 왜 C#/.NET인가? (장점과 상황별 적합성)

- **생산성**: 강력한 IDE/디버깅, 풍부한 표준 라이브러리, 관용구가 정리됨
- **성능**: Kestrel(웹 서버), Span<T>, NativeAOT, `async`/IO 처리
- **크로스플랫폼**: Windows/Linux/macOS, Docker 친화
- **영역 다양성**: 웹/데스크탑/모바일/게임/클라우드/배치/IoT

**언제 택하면 좋은가?**
- 고성능 웹 API, 정교한 엔터프라이즈 웹, Windows 데스크탑 도구/WPF, Unity 기반 게임, Azure 네이티브 서비스, 대규모 팀 협업

---

## 4. 개발 환경과 도구

### 4.1 .NET CLI 기본 명령

| 명령 | 용도 |
|---|---|
| `dotnet new` | 템플릿으로 새 프로젝트/솔루션 생성 |
| `dotnet build` | 컴파일 |
| `dotnet run` | 빌드+실행 |
| `dotnet test` | 단위 테스트 실행 |
| `dotnet publish` | 배포 산출물 생성 |
| `dotnet tool install` | 전역/로컬 개발 도구 설치(예: `dotnet-ef`, `dotnet-format`) |

```bash
dotnet new console -n HelloCSharp
cd HelloCSharp
dotnet run
```

### 4.2 프로젝트 파일(.csproj) 이해

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <PublishSingleFile>true</PublishSingleFile>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.*" />
  </ItemGroup>
</Project>
```

- `TargetFramework`: 타깃 런타임(예: `net8.0`, `net9.0`)
- `Nullable`: **nullable reference types** 활성화
- `ImplicitUsings`: 자주 쓰는 using 자동 포함
- `PackageReference`: NuGet 패키지 의존성

---

## 5. 언어 기초에서 현대 문법까지

### 5.1 타입 시스템, 값/참조, Null 가능성

```csharp
string? maybe = GetNameOrNull();
if (maybe is { Length: > 0 })
{
    Console.WriteLine(maybe.ToUpperInvariant());
}
```

- `string?` : null 허용
- 패턴 `{ Length: > 0 }` : *property pattern*

### 5.2 var, 타입 추론, 튜플/분해

```csharp
var (name, age) = ("Kim", 29);
Console.WriteLine($"{name} / {age}");
```

### 5.3 레코드/불변 모델

```csharp
public record User(string Id, string Name, int Age);

var u1 = new User("u-1", "Kim", 29);
var u2 = u1 with { Age = 30 }; // 비파괴적 복사
```

### 5.4 패턴 매칭 심화 (switch 표현식, 목록 패턴)

```csharp
int ScoreToGrade(int score) => score switch
{
    >= 90 => 1,
    >= 80 => 2,
    >= 70 => 3,
    _ => 4
};

bool IsIncreasing(int[] xs) => xs is [var a, var b, .. var rest] && xs.SequenceEqual(xs.OrderBy(x => x));
```

### 5.5 람다/델리게이트/이벤트

```csharp
Func<int,int,int> add = (x,y) => x + y;
event EventHandler? Changed;

void OnChanged() => Changed?.Invoke(this, EventArgs.Empty);
```

### 5.6 제네릭과 제약 조건

```csharp
T Max<T>(T a, T b) where T : IComparable<T>
    => a.CompareTo(b) >= 0 ? a : b;
```

### 5.7 예외/using/리소스 관리

```csharp
using var fs = File.OpenRead("data.bin");
// using 선언문: 스코프 종료 시 Dispose 자동 호출
```

**비동기 Dispose**:

```csharp
await using var conn = new Npgsql.NpgsqlConnection(cs);
```

---

## 6. 컬렉션과 LINQ

### 6.1 표준 컬렉션/스팬

- `List<T>`, `Dictionary<TKey,TValue>`, `Queue<T>`, `Stack<T>`
- **Span<T>/Memory<T>**: 힙 할당 최소화, 안전한 슬라이싱

```csharp
Span<int> data = stackalloc int[4] {1,2,3,4};
data[0] = 10;
```

### 6.2 LINQ (메서드/쿼리 구문)

```csharp
var names = new[] {"kim", "lee", "park", "choi"};
var q = names.Where(n => n.Length >= 4)
             .OrderBy(n => n)
             .Select(n => n.ToUpperInvariant());
```

```csharp
var q2 = from n in names
         where n.Length >= 4
         orderby n
         select n.ToUpperInvariant();
```

**주의**: `IQueryable`(지연-원격 변환) vs `IEnumerable`(메모리 내) 의미 차이.

---

## 7. 비동기 프로그래밍: async/await 정복

### 7.1 Task/ValueTask/CancellationToken

```csharp
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(3));

async Task<string> FetchAsync(HttpClient http, CancellationToken ct)
{
    var res = await http.GetStringAsync("https://example.com", ct);
    return res;
}
```

- **CancellationToken**: 타임아웃/취소 전달
- **ValueTask**: 고빈도 경량 호출에 할당 최소화

### 7.2 async 스트림

```csharp
async IAsyncEnumerable<int> CountAsync(int n, [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct = default)
{
    for (int i = 0; i < n; i++)
    {
        ct.ThrowIfCancellationRequested();
        await Task.Delay(10, ct);
        yield return i;
    }
}

await foreach (var x in CountAsync(5, cts.Token))
    Console.WriteLine(x);
```

---

## 8. 파일/네트워크/직렬화

```csharp
// 파일 읽기/쓰기
await File.WriteAllTextAsync("note.txt", "hello");
var txt = await File.ReadAllTextAsync("note.txt");

// HTTP
using var http = new HttpClient();
var json = await http.GetStringAsync("https://api.github.com/");

// JSON 직렬화
var obj = new { Name="Kim", Time=DateTimeOffset.UtcNow };
var s = System.Text.Json.JsonSerializer.Serialize(obj);
```

---

## 9. 의존성 주입, 구성, 로깅 (호스트 기반)

```csharp
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

var builder = Host.CreateApplicationBuilder(args);
builder.Services.AddLogging();
builder.Services.AddOptions<MyOptions>().Bind(builder.Configuration.GetSection("MyOptions"));
builder.Services.AddSingleton<IMyService, MyService>();

var app = builder.Build();
var log = app.Services.GetRequiredService<ILoggerFactory>().CreateLogger("App");

log.LogInformation("Started.");
await app.RunAsync();

// 설정 모델
public sealed class MyOptions { public string? ApiKey { get; set; } }
public interface IMyService { }
public class MyService : IMyService { }
```

- **Options 패턴**: 구성 값(환경변수/appsettings.json)을 POCO로 바인딩
- **로깅**: Console/Serilog/Application Insights 등 프로바이더

---

## 10. ASP.NET Core — Minimal API부터

### 10.1 Minimal API 예제

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddEndpointsApiExplorer().AddSwaggerGen();

var app = builder.Build();
app.UseSwagger().UseSwaggerUI();

app.MapGet("/health", () => new { ok = true });
app.MapPost("/echo", (Echo req) => Results.Ok(req with { ServerTime = DateTimeOffset.UtcNow }));

app.Run();

public record Echo(string Message, DateTimeOffset? ServerTime = null);
```

- `MapGet/MapPost`로 경량 REST 제공
- `record`와 `with`로 DTO 만들기 편리

### 10.2 MVC/DI/필터/미들웨어 확장

```csharp
builder.Services.AddControllers();
app.MapControllers();

[ApiController]
[Route("api/products")]
public class ProductsController : ControllerBase
{
    [HttpGet("{id:int}")]
    public ActionResult<ProductDto> Get(int id) => new(id, "Keyboard", 49_000);
}

public record ProductDto(int Id, string Name, int Price);
```

---

## 11. 데이터 접근 — EF Core

```csharp
public sealed class AppDb : DbContext
{
    public DbSet<Todo> Todos => Set<Todo>();
    public AppDb(DbContextOptions<AppDb> options) : base(options) {}
}

public class Todo { public int Id {get; set;} public string Title {get; set;} = ""; public bool Done {get; set;} }

builder.Services.AddDbContext<AppDb>(opt =>
    opt.UseSqlite("Data Source=app.db"));
```

```csharp
app.MapPost("/todo", async (AppDb db, Todo input) =>
{
    db.Todos.Add(input);
    await db.SaveChangesAsync();
    return Results.Created($"/todo/{input.Id}", input);
});
```

- `dotnet ef migrations add Init` → `dotnet ef database update`
- 추상화/테스트/성능 고려: Projection(Select) 최적화, 추적 비활성화, Raw SQL 필요 시 `FromSqlInterpolated`

---

## 12. 데스크탑 & 모바일 UI

### 12.1 WPF — MVVM 예시 (Windows)

```xml
<!-- MainWindow.xaml -->
<Window x:Class="Demo.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        Title="Counter" Height="200" Width="300">
  <StackPanel Margin="20">
    <TextBlock Text="{Binding Count}" FontSize="28"/>
    <Button Content="Inc" Command="{Binding IncCommand}" Margin="0,10,0,0"/>
  </StackPanel>
</Window>
```

```csharp
public class MainVm : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler? PropertyChanged;
    int _count;
    public int Count { get => _count; set { _count = value; PropertyChanged?.Invoke(this, new("Count")); } }
    public ICommand IncCommand { get; }

    public MainVm()
    {
        IncCommand = new RelayCommand(_ => Count++);
    }
}
```

### 12.2 .NET MAUI — 멀티플랫폼

```xml
<!-- MainPage.xaml -->
<VerticalStackLayout Padding="24">
    <Label Text="{Binding Message}" FontSize="24"/>
    <Button Text="Tap" Command="{Binding TapCommand}" />
</VerticalStackLayout>
```

```csharp
public class MainVm
{
    public string Message { get; set; } = "Hello, MAUI";
    public ICommand TapCommand { get; }
    public MainVm() => TapCommand = new Command(() => Message = DateTimeOffset.Now.ToString());
}
```

---

## 13. 게임 개발 — Unity와 C#

- Unity는 C# 스크립팅을 사용.
- **MonoBehaviour** 기반 생명주기: `Awake`/`Start`/`Update`.

```csharp
using UnityEngine;

public class Spawner : MonoBehaviour
{
    public GameObject Prefab;
    public float Interval = 1f;
    float _t;

    void Update()
    {
        _t += Time.deltaTime;
        if (_t >= Interval)
        {
            Instantiate(Prefab, Random.insideUnitSphere * 3f, Quaternion.identity);
            _t = 0;
        }
    }
}
```

---

## 14. 성능 관점 필수 팁

- **할당 줄이기**: `Span<T>`, `string.Create`, `ArrayPool<T>.Shared`
- **Hot path**: `struct` (주의: 박싱/복사), `readonly struct`, `in` 매개변수
- **비동기 I/O**: `async` 우선, 동기 I/O 지양
- **로깅 레벨**: 고빈도 경로에서 문자열 보간 X → 구조적 로깅
- **BenchmarkDotNet**로 측정

```csharp
[MemoryDiagnoser]
public class Bench
{
    [Benchmark] public int SumLinq() => Enumerable.Range(0, 1000).Sum();
    [Benchmark] public int SumLoop() { var s=0; for(int i=0;i<1000;i++) s+=i; return s; }
}
```

---

## 15. 네이티브 연동(P/Invoke) & unsafe

```csharp
using System.Runtime.InteropServices;

internal static class Native
{
    [DllImport("kernel32.dll")]
    public static extern uint GetTickCount();
}

Console.WriteLine(Native.GetTickCount());
```

```csharp
unsafe
{
    int x = 42;
    int* p = &x;
    Console.WriteLine(*p);
}
```

- 안전성/이식성 고려. 가능한 관리 코드/Span API로 대체.

---

## 16. 보안/비밀 관리/환경

- **개발**: `dotnet user-secrets init` → User Secrets로 API 키 저장
- **운영**: Azure Key Vault/Parameter Store, 앱 설정은 환경변수 우선
- **HTTP 클라이언트**: `HttpClientFactory` 재사용, TLS/인증서 검증
- **입력 검증**: 모델 유효성 검사(DataAnnotations/FluentValidation)
- **권한/인가**: ASP.NET Core AuthZ/Policy 기반

---

## 17. 테스트/품질

- **xUnit/NUnit/MSTest**: 단위/통합 테스트
- **FluentAssertions**: 가독성 높은 어서션
- **Minimal API 테스트**: `WebApplicationFactory` 이용

```csharp
public class MathTests
{
    [Fact]
    public void Add_Works() => (1+2).Should().Be(3);
}
```

---

## 18. 배포/컨테이너/Docker

```dockerfile
# Dockerfile (ASP.NET API)
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
WORKDIR /app

FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY . .
RUN dotnet publish -c Release -o /out

FROM base AS final
WORKDIR /app
COPY --from=build /out .
ENTRYPOINT ["dotnet", "MyApi.dll"]
```

```bash
docker build -t myapi:latest .
docker run -p 8080:80 myapi:latest
```

- **Self-contained/Single-file/ReadyToRun/NativeAOT** 조합으로 cold-start/배포 단순화.

---

## 19. 클라우드 (Azure 예시)

- **App Service**: GitHub Actions로 CI/CD
- **Azure SQL/Storage/Service Bus**: SDK로 액세스
- **Functions**: 서버리스 트리거(HTTP/Timer/Queue/Service Bus)

{% raw %}
```yaml
# .github/workflows/deploy.yml (예시)
on: [push]
jobs:
  build-deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-dotnet@v4
      with: { dotnet-version: '9.0.x' }
    - run: dotnet publish -c Release
    - name: 'Deploy to Azure WebApp'
      uses: azure/webapps-deploy@v3
      with:
        app-name: 'myapp-service'
        publish-profile: ${{ secrets.AZURE_PUBLISH_PROFILE }}
        package: ./src/MyApp/bin/Release/net9.0/publish
```
{% endraw %}

---

## 20. 흔한 함정/베스트 프랙티스

- **동기 I/O** 지양, `async` 전파
- **HttpClient** 재생성 금지 → `IHttpClientFactory`
- **EF Core**: Lazy Loading 과용 금지, Projection으로 필요한 것만
- **예외**: 흐름 제어로 쓰지 않기
- **로깅**: 민감정보 마스킹, 구조적 로깅
- **설계**: DI로 경계 분리, 인터페이스 최소/명확, 단일 책임
- **성능**: 컬렉션 복사/박싱 주의, 핫패스 할당 최소화

---

## 21. 수학/복잡도 표기 간단 메모

알고리즘 설명 시 사용하는 표기:

$$
T(n) = O(n \log n), \quad S(n) = O(n)
$$

- 예: LINQ `OrderBy` 평균 복잡도는 정렬 기준에 따라 대략 \( O(n \log n) \)로 이해.

---

## 22. 실전 시나리오 예제 모음

### 22.1 “로그 수집기” — Worker + Channel + Batching

```csharp
public sealed class LogWorker : BackgroundService
{
    private readonly Channel<string> _channel = Channel.CreateBounded<string>(1000);
    private readonly ILogger<LogWorker> _logger;

    public LogWorker(ILogger<LogWorker> logger) => _logger = logger;

    public ValueTask EnqueueAsync(string line) => _channel.Writer.WriteAsync(line);

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        var buffer = new List<string>(128);
        while (!stoppingToken.IsCancellationRequested)
        {
            while (buffer.Count < 128 && await _channel.Reader.WaitToReadAsync(stoppingToken))
            {
                while (buffer.Count < 128 && _channel.Reader.TryRead(out var item))
                    buffer.Add(item);
            }

            if (buffer.Count > 0)
            {
                // 배치 저장/전송
                _logger.LogInformation("Flushing {Count} items", buffer.Count);
                buffer.Clear();
            }
        }
    }
}
```

### 22.2 “이미지 파서” — Span/Memory로 파싱 비용 절감

```csharp
static ReadOnlySpan<byte> PngSignature => new byte[] {137,80,78,71,13,10,26,10};

static bool IsPng(ReadOnlySpan<byte> bytes)
    => bytes.Length >= 8 && bytes[..8].SequenceEqual(PngSignature);

var data = await File.ReadAllBytesAsync("image.png");
Console.WriteLine(IsPng(data));
```

### 22.3 “고성능 API” — Minimal API + 결과 캐시

```csharp
builder.Services.AddOutputCache();
app.UseOutputCache();

app.MapGet("/fib/{n:int}", (int n) => Fib(n))
   .CacheOutput() // 동일 입력 캐시
   .WithName("Fib");

static long Fib(int n) => n <= 1 ? n : Fib(n-1) + Fib(n-2);
```

---

## 23. 소스 제너레이터/분석기 도입(개요)

- **Source Generator**: 컴파일 시 코드 생성(보일러플레이트 감축, 성능 향상)
- **Roslyn Analyzer**: 코드 규칙/자동 수리(품질 가드레일)

---

## 24. 체크리스트

- [ ] `Nullable` ON, 경고를 빌드 실패로(품질 강화)
- [ ] `async` 전파/취소 토큰 지원
- [ ] 로깅/옵션/DI로 경계 분리
- [ ] 단위 테스트 + 베이스라인 벤치마크
- [ ] Dockerfile/CI 설정
- [ ] 비밀은 User Secrets/Key Vault

---

## 25. 확장 로드맵

- **고급 패턴 매칭**(리스트/관계 패턴) 더 연습
- **NativeAOT**로 CLIs 슬림화
- **EF Core 최적화**(NoTracking/CompiledQuery)
- **Blazor/SSR**로 대화형 웹
- **gRPC + protobuf**로 서비스 간 통신
- **Azure Functions/Service Bus/Kafka** 이벤트 아키텍처

---

## 26. 요약

- C#/.NET은 “**현대적 문법 + 강력 런타임 + 폭넓은 프레임워크**” 조합으로 **생산성/성능/생태계**를 고루 갖춘 스택입니다.
- 이 글의 예제들을 시작점으로 **콘솔 → 웹/데스크탑 → 테스트/배포** 흐름을 만들어보세요.

---

## 부록 A. 빠른 참조(치트시트)

### A.1 주요 키워드/기술

- 언어: records / pattern matching / tuples / async streams / Span<T> / ValueTask
- 런타임: JIT / R2R / NativeAOT / GC / ThreadPool
- 프레임워크: ASP.NET Core / EF Core / MAUI / WPF / Worker / Functions
- 도구: dotnet CLI / NuGet / BenchmarkDotNet / analyzers

### A.2 자주 쓰는 CLI

```bash
dotnet new webapi -n MyApi
dotnet add package Serilog.AspNetCore
dotnet tool install --global dotnet-ef
dotnet ef migrations add Init
dotnet ef database update
dotnet publish -c Release -r linux-x64 --self-contained true
```

---

## 부록 B. 최소 템플릿 모음

### B.1 Console

```csharp
Console.WriteLine("OK");
```

### B.2 Minimal API

```csharp
var app = WebApplication.Create(args);
app.MapGet("/", () => "OK");
app.Run();
```

### B.3 xUnit 테스트

```csharp
public class SampleTests
{
    [Fact]
    public void True_Is_True() => Assert.True(true);
}
```

---

## 마무리

- 본 글은 기초 소개를 바탕으로 **현대 C#/.NET의 실무 핵심**을 빠짐없이 담으려 했습니다.
- 필요에 따라 각 섹션을 **별도 포스트**로 확장(예: “async/await 완전정복”, “EF Core 성능 편”) 가능하도록 구성했습니다.
