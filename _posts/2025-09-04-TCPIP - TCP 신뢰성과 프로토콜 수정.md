---
layout: post
title: TCPIP - TCP 신뢰성과 프로토콜 수정
date: 2025-09-04 21:25:23 +0900
category: TCPIP
---
# TCP 신뢰성과 프로토콜 수정

TCP는 단순한 데이터 전송을 넘어, 신뢰성 보장과 효율적인 네트워크 자원 활용을 위한 정교한 메커니즘들을 구현하고 있습니다. 이러한 기능들은 가변적인 네트워크 조건에서도 안정적인 통신을 가능하게 합니다.

## TCP 세그먼트 재전송 타이머와 재전송 큐

### 재전송 타이머의 핵심 역할
재전송 타이머는 TCP 신뢰성의 핵심 메커니즘으로, 패킷 손실을 감지하고 적시에 재전송을 수행합니다.

**재전송 큐 관리:**
```
송신 측 데이터 흐름:
응용 프로그램 → 송신 버퍼 → [재전송 큐] → 네트워크 전송
                    ↑
              확인응답 시 제거
```

**재전송 큐 작동 방식:**
1. 전송된 각 세그먼트는 재전송 큐에 보관
2. 해당 세그먼트에 대한 확인응답 수신 시 큐에서 제거
3. 재전송 타임아웃(RTO) 발생 시 큐에서 재전송

### RTO 계산 알고리즘
**기본 개념:** RTT(Round-Trip Time) 측정을 기반으로 동적 조정

**자코비언 알고리즘 (Karn's Algorithm):**
- 재전송된 세그먼트의 RTT는 측정하지 않음 (모호성 문제 해결)
- 재전송 시 RTO를 기하급수적으로 증가 (백오프)

**RTT 측정 방법:**
```
SRTT(new) = α × SRTT(old) + (1-α) × RTT(sample)
RTTVAR(new) = β × RTTVAR(old) + (1-β) × |RTT(sample) - SRTT(old)|
RTO = SRTT + 4 × RTTVAR
```
- α = 0.875, β = 0.75 (일반적 값)
- 최소 RTO: 1초 (RFC 6298)

## TCP 비연속적 확인응답 처리와 선택적 확인응답 (SACK)

### 기존 누적 확인응답의 한계
기본 TCP는 **누적 확인응답**만을 사용하여, 중간 세그먼트 손실 시 모든 후속 데이터 재전송 문제 발생:

```
전송: 세그먼트 1-1000, 1001-2000, 2001-3000, 3001-4000
손실: 세그먼트 1001-2000
확인응답: ACK 1001 (2001-4000은 이미 수신했으나 확인응답 불가)
결과: 세그먼트 2001-4000까지 불필요하게 재전송
```

### 선택적 확인응답 (SACK) 메커니즘
RFC 2018에 정의된 SACK은 이러한 비효율성을 해결합니다:

**SACK 옵션 형식:**
```
Kind=5 | Length | Left Edge of 1st Block | Right Edge of 1st Block | ...
```
- 각 블록은 [왼쪽 경계, 오른쪽 경계) 형식
- 최대 3개의 블록까지 통보 가능 (옵션 길이 제한)

**작동 예시:**
```
전송: 세그먼트 1-1000, 1001-2000, 2001-3000, 3001-4000
손실: 세그먼트 1001-2000
확인응답: ACK 1001, SACK 블록 [2001, 4000]
재전송: 세그먼트 1001-2000만 재전송
```

### SACK 기반 재전송 최적화
**SACK 기반 빠른 재전송:**
- 3개의 중복 ACK 수신 시 손실로 판단
- SACK 정보를 통해 정확히 어떤 데이터가 손실되었는지 식별
- 선택적 재전송 수행

## TCP 적응형 재전송과 재전송 타이머 계산

### RTT 측정의 진화

**타임스탬프 옵션 (RFC 1323):**
- 각 세그먼트에 송신 시간 기록
- 정밀한 RTT 측정 가능 (마이크로초 단위)
- 재전송 모호성 완전 해결

**타임스탬프 작동:**
```
송신자: TSval = 현재 시간
수신자: 에코 응답 TSecr = 수신한 TSval
RTT = 현재 시간 - TSecr
```

### 고급 RTO 알고리즘

**Linux의 RTO 계산:**
```c
/* 실제 Linux 커널 구현 요약 */
m = 측정된 RTT 샘플
srtt = (7/8) * srtt + (1/8) * m
rttvar = (3/4) * rttvar + (1/4) * |srtt - m|
rto = srtt + 4 * rttvar
rto = max(rto, 1초)  /* 최소값 제한 */
rto = min(rto, 60초) /* 최대값 제한 */
```

**윈도우의 복합 TCP:**
- 여러 RTT 측정 기법 조합
- 네트워크 유형(유선/무선)에 따른 적응
- 혼잡 제어와 연동된 동적 조정

## TCP 윈도우 크기 조정과 흐름 제어

### 수신 윈도우 통보 메커니즘
수신자는 자신의 버퍼 여유 공간을 윈도우 크기 필드로 통보합니다:

**윈도우 크기 필드 제한:**
- 원본 TCP 헤더: 16비트 (최대 65,535바이트)
- 현대 고속 네트워크에서의 한계

**윈도우 스케일 옵션 (RFC 1323):**
- 윈도우 크기 왼쪽 시프트 계수 협상
- 최대 윈도우 크기: 65,535 × 2^14 ≈ 1GB

### 윈도우 관리 최적화

**제로 윈도우 탐침:**
- 수신 윈도우가 0이 된 경우 주기적 탐침 패킷 전송
- 윈도우 크기 갱신 시점 파악
- 연결 정지 방지

**지연된 ACK와 윈도우 업데이트:**
- ACK 지연 시 윈도우 크기 정보도 함께 지연
- 최대 500ms 지연 가능
- 버퍼 여유 공간 증가 시 즉시 윈도우 업데이트 권장

## TCP 윈도우 관리 문제점

### 윈도우 크기 조정의 딜레마

**작은 윈도우 문제:**
- 네트워크 대역폭 활용도 저하
- 왕복 시간(RTT) 대비 전송 데이터 양 부족

**과대한 윈도우 문제:**
- 수신자 버퍼 오버플로우
- 패킷 손실 증가
- 불필요한 재전송 발생

### 버퍼블로트 현상
**문제 정의:**
- 중간 라우터/스위치 버퍼 포화
- 큐잉 지연 증가
- 처리율(throughput) 저하

**해결 방안:**
- **Active Queue Management (AQM)**: RED, CoDel 알고리즘
- **Bufferbloat 인식 알고리즘**: LEDBAT, BBR

## TCP "어리석은 윈도우 증후군" 및 작은 윈도우 문제 방지를 위한 슬라이딩 윈도우 시스템 변경

### 어리석은 윈도우 증후군 정의
**발생 조건:**
1. 송신자가 작은 데이터 조각을 반복 전송
2. 수신자가 작은 버퍼 공간만 통보

**결과:**
- 네트워크 효율성 급격히 저하
- 오버헤드 비율 증가
- 예: 1바이트 데이터에 40바이트 헤더

### 네이글 알고리즘
**목적:** 작은 패킷 통합

**알고리즘:**
```
if (출력 버퍼에 미확인 데이터 존재 and 전송 가능 윈도우 ≥ MSS) {
    가능한 많은 데이터 전송
} else if (출력 버퍼에 미확인 데이터 없음) {
    모든 데이터 즉시 전송
} else {
    확인응답 대기
}
```

**문제점:**
- 대화형 응용 프로그램 지연
- 실시간 통신에 부적합

### 클락 알고리즘
**수신자 측 최적화:**
- 윈도우 업데이트 지연
- 충분한 버퍼 공간 확보 시까지 대기
- 일반적으로 최소 1 MSS 또는 버퍼의 50%까지 대기

**클락 알고리즘 로직:**
```
수신 버퍼 여유 공간이 다음 조건 중 하나를 만족할 때까지 윈도우 업데이트 지연:
1. 최대 세그먼트 크기(MSS) 이상
2. 버퍼 공간의 50% 이상
3. 지연 타이머 만료 (일반적으로 200-500ms)
```

## TCP 혼잡 처리 및 혼잡 회피 알고리즘

### TCP 혼잡 제어의 발전

**타호(Tahoe) 알고리즘 (초기):**
- 느린 시작 → 혼잡 회피
- 3 중복 ACK 또는 타임아웃 시 혼잡 윈도우 리셋

**Reno 알고리즘:**
- 빠른 재전송 도입
- 빠른 회복으로 성능 개선
- 여전히 여러 패킷 손실 시 비효율적

**NewReno 알고리즘:**
- 부분적 ACK 처리 개선
- 여러 패킷 손실 시에도 효율적 복구

### 현대 혼잡 제어 알고리즘

**CUBIC (리눅스 기본):**
```
cwnd = C × (t - K)^3 + W_max
```
- 큐빅 함수를 이용한 윈도우 증가
- 대역폭 지연 곱(BDP)에 빠르게 수렴
- 고속 장거리 네트워크에 최적화

**BBR (Bottleneck Bandwidth and RTT):**
- 대역폭과 RTT 직접 측정
- 버퍼블로트 최소화
- Google 개발, YouTube 등에서 사용

**BBR 동작 단계:**
1. **STARTUP**: 지수적 증가로 대역폭 탐색
2. **DRAIN**: 큐잉 지연 감소
3. **PROBE_BW**: 대역폭 변동 모니터링
4. **PROBE_RTT**: 최소 RTT 주기적 측정

### 혼잡 신호 다양화
**ECN (Explicit Congestion Notification):**
- IP 헤더 ECN 필드 활용
- 중간 라우터가 명시적 혼잡 통보
- 패킷 손실 없이 혼잡 조절 가능

**ECN 작동:**
```
송신자: ECN 설정 패킷 전송
라우터: 혼잡 시 ECN 표시
수신자: ECN 에코로 송신자에 통보
송신자: 혼잡 윈도우 조정
```

## TCP/IP 전송 계층 프로토콜 비교 (UDP와 TCP)

### 프로토콜 특성 비교표

| 특성 | TCP | UDP |
|------|-----|-----|
| 연결성 | 연결 지향 (가상 회선) | 비연결형 (데이터그램) |
| 신뢰성 | 높음 (확인응답, 재전송) | 없음 (최선형 전달) |
| 순서 보장 | 있음 (순서 번호) | 없음 |
| 흐름 제어 | 슬라이딩 윈도우 | 없음 |
| 혼잡 제어 | 다양함 (Reno, CUBIC, BBR 등) | 없음 |
| 헤더 크기 | 20-60바이트 | 8바이트 고정 |
| 오버헤드 | 높음 | 낮음 |
| 전송 방식 | 바이트 스트림 | 메시지 |
| 멀티플렉싱 | 포트 번호 | 포트 번호 |
| 브로드캐스트 | 지원 안 함 | 지원 |
| 일반 용도 | 웹, 이메일, 파일 전송 | DNS, VoIP, 실시간 게임 |

### 선택 기준

**TCP를 선택해야 할 때:**
1. 데이터 무결성이 중요한 경우
2. 대용량 파일 전송
3. 신뢰성 있는 순차적 데이터 전달 필요
4. 네트워크 혼잡 상황에서 공정한 자원 공유 필요

**UDP를 선택해야 할 때:**
1. 실시간성이 중요한 경우 (VoIP, 비디오 스트리밍)
2. 오버헤드 최소화 필요
3. 애플리케이션 수준의 신뢰성 구현 가능한 경우
4. 브로드캐스트/멀티캐스트 필요
5. 짧은 요청-응답 패턴 (DNS)

### 하이브리드 접근법

**QUIC 프로토콜:**
- UDP 위에 구축된 신뢰성 있는 전송
- 다중 스트림, 내장 암호화
- 빠른 연결 수립 (0-RTT)
- HTTP/3의 기반

**애플리케이션 계층 신뢰성:**
- UDP + 사용자 정의 재전송 메커니즘
- 특정 응용 요구사항에 맞춤 최적화
- 예: 실시간 통신 프로토콜

---

## 결론

TCP의 신뢰성과 흐름 제어 메커니즘은 단순한 프로토콜 기능을 넘어, **분산 시스템 설계의 교과서적인 사례**를 제공합니다. 40년이 넘는 발전 과정에서 TCP는 네트워크 환경의 근본적인 변화(대역폭 증가, 무선 통신 보급, 보안 요구 강화)에 지속적으로 적응하면서도, 그 핵심 설계 철학을 유지해 왔습니다.

TCP의 가장 큰 강점은 **다층적 적응 메커니즘**에 있습니다. 재전송 타이머의 동적 조정, 슬라이딩 윈도우의 유연한 크기 제어, 혼잡 제어 알고리즘의 상황 인식적 행동은 모두 불완전하고 가변적인 네트워크 환경에서 최적의 성능을 추구하는 동일한 목표를 서로 다른 수준에서 달성합니다. 특히 SACK의 도입은 단순한 기능 추가가 아닌, 프로토콜의 근본적 한계를 창의적으로 극복한 사례로, 기존 시스템과의 호환성을 유지하면서도 성능을 획기적으로 개선했습니다.

"어리석은 윈도우 증후군"과 같은 문제의 발견과 해결은 TCP 설계자들의 실용적 접근 방식을 잘 보여줍니다. 이론적으로 완벽해 보이는 알고리즘도 실제 배포 시 예상치 못한 문제를 일으킬 수 있으며, TCP는 이러한 문제들을 지속적으로 진단하고 개선해 왔습니다. 이러한 반복적 개선 과정은 소프트웨어 공학의 중요한 원칙을 입증합니다.

현대의 혼잡 제어 알고리즘(CUBIC, BBR 등)은 단순한 패킷 손실 감지를 넘어, 네트워크의 근본적 특성(대역폭, 지연, 버퍼 상태)을 직접 측정하고 모델링하는 방향으로 진화하고 있습니다. 이는 프로토콜 설계가 단순한 규칙 집합을 넘어, 시스템의 거시적 행동을 이해하고 제어하는 과학으로 발전했음을 보여줍니다.

UDP와 TCP의 선택 문제는 결코 이분법적이지 않습니다. QUIC과 같은 새로운 프로토콜은 이 두 극단 사이에서 새로운 균형점을 찾고 있으며, 이는 기술 발전의 본질적 패턴을 반영합니다. 네트워크 엔지니어와 개발자는 이러한 선택의 뉘앙스를 이해함으로써, 특정 응용 프로그램의 요구사항에 가장 적합한 전송 메커니즘을 설계할 수 있습니다.

궁극적으로 TCP의 진화는 인터넷이 어떻게 유기적 시스템으로 성장하는지를 보여주는 생생한 예입니다. 각 개선 사항은 특정 문제에 대한 응답이었으며, 이러한 점진적 개선들이 누적되어 오늘날 우리가 의지하는 견고한 통신 인프라를 구축했습니다. 이 역사는 기술 표준이 어떻게 살아 움직이는 생태계로서 기능하는지에 대한 귀중한 통찰을 제공합니다.