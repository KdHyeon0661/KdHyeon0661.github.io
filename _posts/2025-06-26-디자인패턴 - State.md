---
layout: post
title: 디자인패턴 - State
date: 2025-06-26 22:20:23 +0900
category: 디자인패턴
---
# State (상태 패턴)

## 1. 정의와 배경

**상태 패턴(State Pattern)**은 객체의 내부 **상태를 객체로 캡슐화**하고, 상태에 따라 **행동을 교체**하는 행위 패턴이다. 거대한 `if-elif-else`/`switch` 분기를 제거하고, 각 상태가 **스스로 다음 상태와 행동을 결정**하게 만든다.

> “상태에 따라 객체의 행동이 바뀌어야 한다면, 상태를 클래스로 분리하고 전이를 그 안에 넣어라.”

### 1.1 형식적 모델(FSM)

상태 패턴은 유한상태기계(FSM) 관점에서도 자연스럽다.
FSM은 다음 5-튜플로 표현된다:

$$
\mathcal{M} = (S, \Sigma, \delta, s_0, F)
$$

- \(S\): 상태 집합, \(\Sigma\): 입력 사건 집합
- \(\delta: S \times \Sigma \rightarrow S\): 전이 함수
- \(s_0\): 시작 상태, \(F\): 종료(수용) 상태 집합

상태 패턴은 **\(\delta\)** 를 **상태 객체의 메서드**로 분산 배치한다는 점이 핵심이다.

---

## 2. 구조 (UML)

사용자 초안의 핵심 구조를 유지하며 역할을 명확히 주석했다.

```
┌────────────┐
│  Context   │
│ - state    │───────────────┐
│ + request()│               │ delegates
│ + setState │               ▼
└────┬───────┘        ┌───────────────┐
     │                │    State      │  «interface/abstract»
     │                │ + handle(ctx) │
     │                └─────┬─────────┘
     │                      │
     ▼                      ▼
┌───────────────┐   ┌───────────────┐
│ ConcreteStateA │   │ ConcreteStateB │
│ + handle(ctx)  │   │ + handle(ctx)  │
└───────────────┘   └───────────────┘
```

- **Context**: 현재 상태를 보유, 클라이언트 요청을 상태에 위임
- **State**: 공통 인터페이스
- **ConcreteState**: 상태별 동작 및 전이 규칙 구현

---

## 3. 동기: 거대한 분기문을 제거하라

안티패턴(문자열/enum 기반 분기):

```python
def press_button(ctx):
    if ctx.state == "Locked":
        print("문이 잠겨 있음 → 해제")
        ctx.state = "Unlocked"
    elif ctx.state == "Unlocked":
        print("문이 열려 있음 → 잠금")
        ctx.state = "Locked"
    else:
        raise ValueError("알 수 없는 상태")
```

문제점
- 상태가 늘수록 분기가 기하급수적으로 비대해짐
- 전이 규칙이 **여러 곳에 산재** → 변경 비용 급증
- 테스트가 어려움(분기 조합 폭발)

상태 패턴으로 리팩터링하면 전이와 행동이 **상태 클래스 내부로 응집**된다.

---

## 4. 기본 구현(동기, 최소 골격)

```python
from abc import ABC, abstractmethod

# 1. State 인터페이스
class State(ABC):
    @abstractmethod
    def handle(self, context): ...

# 2. 구체 상태들
class LockedState(State):
    def handle(self, context):
        print("문이 잠겨 있습니다. 잠금을 해제합니다.")
        context.set_state(UnlockedState())

class UnlockedState(State):
    def handle(self, context):
        print("문이 열려 있습니다. 다시 잠급니다.")
        context.set_state(LockedState())

# 3. Context
class Door:
    def __init__(self, initial=None):
        self._state = initial or LockedState()
    def set_state(self, state: State):
        self._state = state
    def press_button(self):
        self._state.handle(self)

# 사용 예
door = Door()
door.press_button()  # Locked -> Unlocked
door.press_button()  # Unlocked -> Locked
```

출력
```
문이 잠겨 있습니다. 잠금을 해제합니다.
문이 열려 있습니다. 다시 잠급니다.
```

포인트
- 전이 로직이 상태 내부에만 존재 → **응집도↑, 결합도↓**
- 새 상태 추가 시 기존 상태/Context를 건드리지 않아도 된다(**OCP**)

---

## 5. 전이 테이블, 이벤트, 가드/액션

실전에서는 “입력 사건(event)”과 “조건(guard)”, “부수효과(action)”을 함께 다룬다.

### 5.1 전이 테이블 예

| 현재 상태        | 입력(event)    | 가드(조건)            | 액션(부수효과)       | 다음 상태        |
|------------------|----------------|-----------------------|----------------------|------------------|
| Locked           | press          | 인증됨?               | 로그 남김            | Unlocked         |
| Locked           | press          | 인증 안 됨            | 경고음               | Locked           |
| Unlocked         | press          | -                     | 로그 남김            | Locked           |
| Unlocked         | timeout        | -                     | 자동 잠금 알림       | Locked           |

### 5.2 테이블 기반 엔진(동기, 데이터드리븐)

```python
from typing import Callable, Dict, Tuple, Optional

Event = str
StateName = str
Guard = Callable[[], bool]
Action = Callable[[], None]

class Transition:
    def __init__(self, dst: StateName, guard: Optional[Guard]=None, action: Optional[Action]=None):
        self.dst, self.guard, self.action = dst, guard, action

class FSM:
    def __init__(self, initial: StateName):
        self.state = initial
        self.table: Dict[Tuple[StateName, Event], Transition] = {}

    def add(self, src: StateName, event: Event, dst: StateName, guard=None, action=None):
        self.table[(src, event)] = Transition(dst, guard, action)

    def dispatch(self, event: Event):
        key = (self.state, event)
        tr = self.table.get(key)
        if not tr:
            print(f"전이 없음: {self.state} --{event}--> ?")
            return
        if tr.guard and not tr.guard():
            print(f"가드 불충족: {self.state} --{event}--> {tr.dst}")
            return
        if tr.action: tr.action()
        print(f"{self.state} --{event}--> {tr.dst}")
        self.state = tr.dst

# 구성
auth = False
def is_authed(): return auth
def log(): print("로그 기록")
def alarm(): print("경고음")

fsm = FSM("Locked")
fsm.add("Locked",   "press", "Unlocked", guard=is_authed, action=log)
fsm.add("Locked",   "press", "Locked",   guard=lambda: not is_authed(), action=alarm)
fsm.add("Unlocked", "press", "Locked",   action=log)
fsm.add("Unlocked", "timeout", "Locked", action=lambda: print("자동 잠금"))

# 시나리오
fsm.dispatch("press")         # 인증 전
auth = True
fsm.dispatch("press")         # 인증 후 해제
fsm.dispatch("timeout")       # 자동 잠금
```

장점
- 전이를 **데이터로 선언** → 시각화/검증/테스트 용이
- 상태 패턴과 병행: 상태 클래스 내부에서 테이블을 사용해도 된다

---

## 6. 싱글턴 상태 객체(메모리/동등성/공유)

상태 객체가 불변이라면 싱글턴으로 두면 메모리 절약 및 비교가 쉬워진다.

```python
class Singleton(type):
    _inst={}
    def __call__(cls,*a,**kw):
        if cls not in cls._inst: cls._inst[cls]=super().__call__(*a,**kw)
        return cls._inst[cls]

class StateBase(metaclass=Singleton):
    pass

class Locked(StateBase):
    def handle(self, ctx):
        print("잠금→해제")
        ctx.set_state(Unlocked())

class Unlocked(StateBase):
    def handle(self, ctx):
        print("해제→잠금")
        ctx.set_state(Locked())

class Door2:
    def __init__(self): self._state = Locked()
    def set_state(self, s): self._state = s
    def press(self): self._state.handle(self)
```

---

## 7. 비동기 상태(네트워크/IO 바운드)

이벤트가 비동기라면 상태도 비동기로 설계할 수 있다.

```python
import asyncio
from abc import ABC, abstractmethod

class AState(ABC):
    @abstractmethod
    async def handle(self, ctx): ...

class Connecting(AState):
    async def handle(self, ctx):
        print("연결 중...")
        await asyncio.sleep(0.05)   # 네트워크 연결 가정
        ctx.set_state(Connected())

class Connected(AState):
    async def handle(self, ctx):
        print("연결됨 → 데이터 전송")
        await asyncio.sleep(0.01)
        ctx.set_state(Disconnecting())

class Disconnecting(AState):
    async def handle(self, ctx):
        print("연결 해제 중")
        await asyncio.sleep(0.01)
        ctx.set_state(Disconnected())

class Disconnected(AState):
    async def handle(self, ctx):
        print("이미 해제 상태")

class Client:
    def __init__(self): self._state = Disconnected()
    def set_state(self, s): self._state = s
    async def step(self): await self._state.handle(self)

async def demo():
    c = Client()
    c.set_state(Connecting())
    await c.step()   # 연결 중...
    await c.step()   # 연결됨 → 전송
    await c.step()   # 연결 해제 중
    await c.step()   # 이미 해제

asyncio.run(demo())
```

설계 팁
- 비동기 콜백 중 상태 교체가 연쇄적으로 일어날 수 있으므로 **재진입 가드**를 둘지 검토
- 예외를 상태로 승격(예: `ErrorState`)하여 회복 전략을 명시

---

## 8. 스레드 안전(락·스냅샷·재진입 가드)

멀티스레드에서 상태 전이는 원자적으로 이뤄져야 한다.

```python
import threading

class TSContext:
    def __init__(self, initial):
        self._state = initial
        self._lock = threading.RLock()
        self._notifying = False

    def set_state(self, s):
        with self._lock:
            self._state = s

    def request(self):
        with self._lock:
            if self._notifying: return
            self._notifying = True
            state = self._state
        try:
            state.handle(self)  # 락 보유 상태로 콜백하지 않음
        finally:
            with self._lock:
                self._notifying = False
```

원칙
- **락 보유 중 콜백 호출 금지**(교착 회피)
- 재진입 방지 플래그로 루프 차단

---

## 9. 복합 상태(HSM, 서브상태·초과도)

대형 도메인(TCP, UI 위젯, 주문/결제 플로우)에서는 **서브상태**가 필요하다.
예: `Connected` 아래에 `Idle`, `Transferring`, `Paused` 등 하위 상태를 둔다.

간단 예시(합성):

```python
class ConnectedSuper(State):
    def handle(self, ctx):
        print("상위 공통 동작")  # 예: 연결 유지 검사

class Transferring(State):
    def handle(self, ctx):
        print("전송 중")
        # 상위 공통 동작 호출
        ConnectedSuper().handle(ctx)
```

현업에서는 HSM 프레임워크(SCXML 등)나 표준화된 모델(상태도)을 코드에 매핑한다.
핵심은 **공통 로직은 상위 상태에**, **특화 로직은 하위 상태에** 배치하여 중복을 제거하는 것.

---

## 10. 로깅·모니터링·가시화

- 전이마다 `(timestamp, prev, event, next, reason)`를 남겨 **감사/디버깅** 가능
- 전이 테이블로부터 **상태도(dot/mermaid)**를 생성해 문서화 자동화
- 운영 지표: 전이 빈도, 실패율, 평균 체류 시간, 에러 상태 비율

간단 로거 데코레이터:

```python
def logged(handle):
    def wrapper(self, ctx):
        prev = type(self).__name__
        handle(self, ctx)
        next_ = type(ctx._state).__name__
        print(f"[TRANSITION] {prev} -> {next_}")
    return wrapper
```

---

## 11. 도메인 예시

### 11.1 미디어 플레이어

| 상태 | 이벤트 | 액션 | 다음 |
|---|---|---|---|
| Stopped | play | 로드 | Playing |
| Playing | pause | 일시정지 | Paused |
| Playing | stop  | 중지 | Stopped |
| Paused  | play  | 재개 | Playing |
| Paused  | stop  | 중지 | Stopped |

```python
class Stopped(State):
    def play(self, ctx): print("로드"); ctx.set_state(Playing())
    def stop(self, ctx): print("이미 중지")
class Playing(State):
    def pause(self, ctx): print("일시정지"); ctx.set_state(Paused())
    def stop(self, ctx): print("중지"); ctx.set_state(Stopped())
class Paused(State):
    def play(self, ctx): print("재개"); ctx.set_state(Playing())
    def stop(self, ctx): print("중지"); ctx.set_state(Stopped())
```

(메서드 분리형: `handle(event)` 대신 `play/pause/stop`를 개별 메서드로 두는 변형도 흔하다.)

### 11.2 주문 상태(간단)

| 현재 | 이벤트 | 가드 | 액션 | 다음 |
|---|---|---|---|---|
| Created  | pay    | 결제 승인 | 영수증 발급 | Paid   |
| Paid     | ship   | 재고 확인 | 운송장 생성 | Shipped|
| Shipped  | deliver| -        | 수령 처리   | Done   |
| Created  | cancel | -        | 취소 환불   | Canceled|
| Paid     | cancel | 출고 전  | 환불       | Canceled|

---

## 12. 테스트 전략(예: pytest 스타일)

```python
def test_door_toggle():
    d = Door()                  # Locked
    d.press_button()            # -> Unlocked
    d.press_button()            # -> Locked
    assert isinstance(d._state, LockedState)

def test_guard_denies(monkeypatch):
    allowed = False
    def guard(): return allowed

    fsm = FSM("Locked")
    fsm.add("Locked", "press", "Unlocked", guard=guard)
    fsm.dispatch("press")
    assert fsm.state == "Locked"
    allowed = True
    fsm.dispatch("press")
    assert fsm.state == "Unlocked"
```

체크리스트
- 전이 테이블 **전이 누락**(dead transition) 검출
- 불도달 상태(unreachable) 검사
- 순환 전이 중 **탈출 불가 루프** 탐지
- 에러 상태 전이 비율 모니터링

---

## 13. 성능과 복잡도 메모

- 상태 수 \(N\), 이벤트 수 \(E\)일 때 가능한 전이 수는 이론상 \(N \cdot E\).
  희소 전이의 경우 해시 기반 룩업으로 평균 \(O(1)\) 전이 결정 가능.
- 전이 검증/가드가 많아질수록 상수항 증가. 성능 이슈 시
  - 전이 테이블을 **사전컴파일(사전 바인딩)**
  - 가드 단락 평가(우선순위)
  - 배치 이벤트(큐)로 문턱 제어

---

## 14. State vs Strategy vs Command

| 패턴 | 핵심 목적 | 공통점 | 차이점 |
|------|-----------|--------|--------|
| State | 상태에 따라 행동 교체 | 객체에 행위를 위임 | 전이 규칙이 내재, 내부적으로 상태가 바뀜 |
| Strategy | 알고리즘 교체 | 행위 캡슐화 | 전이 개념 없음, 외부가 전략을 선택 |
| Command | 요청 캡슐화 | 실행 위임 | 실행/취소/큐잉 초점, 상태 전이가 주 목적 아님 |

---

## 15. 안티패턴과 주의점

- **문자열/enum 분기 남발**: 변경 파급이 크고 테스트가 어려움
- **Context가 전이를 직접 관리**: 상태 클래스 무력화 → 전이를 상태 내부로 환원
- **락 보유 중 콜백 호출**: 교착 위험 → 스냅샷 후 호출
- **예외 삼키기**: 실패가 조용히 묻힘 → 실패를 상태로 승격하거나 로깅·알람
- **전역 단일 상태**: 멀티 인스턴스에서 충돌 → 인스턴스 지역 상태로 유지

---

## 16. 실무 팁

- 상태 객체는 가능하면 **불변**으로, 전이는 **명시적**으로
- 이벤트 명세(스키마)를 문서화하고, 전이 테이블에서 **미정의 전이 시 정책**(무시/에러/보류)을 결정
- 복잡해지면 **상태도 자동 생성**(전이 테이블 → mermaid/graphviz)
- 성능 민감 구간에서는 **싱글턴 상태 + 전이함수 바인딩**으로 할당 최소화

---

## 17. 요약

- 상태 패턴은 **조건분기를 상태 객체로 대체**하여 응집도를 높이고 변경 비용을 낮춘다.
- 전이 테이블, 가드/액션, 비동기·동시성, 싱글턴 상태, 테스트 전략을 함께 사용하면 규모가 커져도 구조가 무너지지 않는다.
- 선택 기준: **상태 수가 많고 전이 규칙이 복잡**하거나 **행동 변경이 빈번**하다면, 상태 패턴을 우선 검토하라.
