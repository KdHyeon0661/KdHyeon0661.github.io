---
layout: post
title: 디자인패턴 - State
date: 2025-06-23 22:20:23 +0900
category: 디자인패턴
---
# State (상태 패턴)

## ✅ 정의

**상태 패턴(State Pattern)**은 객체의 내부 상태에 따라 **행동을 변경**하도록 설계하는 **행위 패턴(Behavioral Pattern)**입니다.  
상태를 객체로 캡슐화하여, 상태 전이에 따른 행동 변경을 유연하게 처리할 수 있게 해줍니다.

> “상태에 따라 객체의 행동을 바꾸고, 그 상태를 객체로 캡슐화한다.”

---

## 🎯 의도 (Intent)

- 객체의 상태 변화에 따라 **동작이 변경되는 경우**, 상태에 따른 분기(`if`, `switch`) 대신 **클래스를 분리**하여 유연하게 처리
- **상태 전이 로직**을 캡슐화하고, **각 상태별 행동**을 독립적으로 정의

---

## 📦 구조 (UML)

```
┌────────────┐
│  Context   │
└────┬───────┘
     │ setState(state)
     ▼
┌────────────┐
│   State    │◄────────────┐
└────┬───────┘             │
     ▼                     ▼
┌────────────┐     ┌────────────┐
│ConcreteStateA│   │ConcreteStateB│
└────────────┘     └────────────┘
```

- `Context`: 현재 상태를 유지하고, 상태에 따른 요청을 위임
- `State`: 상태가 공통으로 제공하는 인터페이스
- `ConcreteState`: 각 상태별 구체 동작 구현

---

## 🧑‍💻 구현 예시 (Python)

```python
from abc import ABC, abstractmethod

# State 인터페이스
class State(ABC):
    @abstractmethod
    def handle(self, context):
        pass

# ConcreteStateA
class LockedState(State):
    def handle(self, context):
        print("🔒 문이 잠겨 있습니다. 잠금을 해제합니다.")
        context.set_state(UnlockedState())

# ConcreteStateB
class UnlockedState(State):
    def handle(self, context):
        print("🔓 문이 열렸습니다. 다시 잠급니다.")
        context.set_state(LockedState())

# Context
class Door:
    def __init__(self):
        self.state = LockedState()  # 초기 상태

    def set_state(self, state):
        self.state = state

    def press_button(self):
        self.state.handle(self)

# 사용 예시
door = Door()
door.press_button()  # 🔒 → 🔓
door.press_button()  # 🔓 → 🔒
```

**출력 예시:**
```
🔒 문이 잠겨 있습니다. 잠금을 해제합니다.
🔓 문이 열렸습니다. 다시 잠급니다.
```

---

## ✅ 장점

- **상태 전이 로직**을 상태 클래스 내부로 옮겨서 **가독성과 유지보수성 향상**
- 조건문 (`if`, `switch`) 제거 → **확장 용이**
- 각 상태를 독립적으로 캡슐화하여 **SRP (단일 책임 원칙)** 준수

---

## ⚠️ 단점

- 상태가 많아질수록 **클래스 수 증가**
- 설계가 단순한 경우 **오버엔지니어링**이 될 수 있음

---

## 📌 사용 사례

| 분야 | 예시 |
|------|------|
| UI/UX 시스템 | 버튼 클릭 시 상태 전환 (활성/비활성 등) |
| 게임 개발 | 플레이어 상태 (점프, 걷기, 죽음 등) |
| TCP 연결 | TCP 상태 (LISTEN → SYN_SENT → ESTABLISHED 등) |
| ATM 기기 | 상태(대기 → 카드 입력 → 출금 요청 등)에 따라 동작 변경 |
| 문서 편집기 | 상태(읽기 전용, 편집 가능, 저장 중)에 따라 기능 제한 |
| 상태 기반 워크플로우 | 다음 단계 전이 조건 및 행동 정의 |

---

## 🧠 State vs Strategy vs Command

| 패턴 | 목적 | 공통점 | 차이점 |
|------|------|--------|--------|
| **State** | 상태에 따른 동작 변경 | 객체에 동작 위임 | 상태 전이에 따라 내부적으로 변경됨 |
| **Strategy** | 알고리즘 교체 | 동작 캡슐화 | 클라이언트가 전략을 외부에서 선택 |
| **Command** | 요청 캡슐화 | 실행 위임 | 요청 저장/실행/취소 중심 |

---

## ✅ 실무 팁

- 여러 상태 간 전이가 복잡한 경우 **상태 전이 테이블**을 그려보면 설계에 도움됨
- 게임, UI, FSM(Finite State Machine), 워크플로우 등에 매우 적합
- 상태 객체를 **싱글턴으로 구현**하면 메모리 사용을 줄일 수 있음

---

## 🧠 마무리

**State 패턴은 객체의 상태가 동작에 영향을 주는 상황에서**,  
**조건문을 제거하고 명확한 상태별 책임 분리를 통해 깔끔하고 유지보수 쉬운 구조를 제공합니다.**

복잡한 상태 전이, 명확한 행위 분리, 확장 가능한 설계를 필요로 한다면  
상태 패턴은 **가장 강력한 도구 중 하나**가 될 수 있습니다.