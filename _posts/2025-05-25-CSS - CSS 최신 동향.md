---
layout: post
title: CSS - CSS 최신 동향
date: 2025-05-25 21:20:23 +0900
category: CSS
---
# CSS 최신 동향과 트렌드 (2025 기준)

## 선택자·우선순위·구조의 진화

### `:has()` — 실전 “부모 선택자”

부모가 자식의 상태에 반응하는 **관계 선택자**입니다. 폼 검증, 아코디언, 네비게이션 활성화 등에서 JS 없이도 상태 기반 스타일링이 가능해졌습니다.

```css
/* 입력이 focus면 .field 감싸는 부모를 강조 */
.field:has(input:focus) {
  outline: 2px solid var(--primary, royalblue);
  outline-offset: 2px;
}

/* 체크박스를 포함하는 카드가 선택되었을 때 카드 전체 상태 변경 */
.card:has(input[type="checkbox"]:checked) {
  box-shadow: 0 0 0 3px color-mix(in oklch, var(--primary), white 70%);
}

/* 내비게이션: 현재 경로 링크를 가진 항목만 강조 */
.nav__item:has(a[aria-current="page"]) {
  background: var(--nav-active-bg, #eef2ff);
}
```

**언제 쓰나**
- 폼 상태(에러/포커스/값 존재) → **필드 래퍼** 강조
- 카드/리스트 내부의 **토글 상태**를 래퍼로 끌어올리기
- 네비게이션 **현재 위치** 하이라이트

---

### `@layer` — 계층으로 **우선순위**를 디자인

라이브러리/유틸/컴포넌트/페이지 순서를 명시해 **특정 레이어가 항상 이기거나 지도록** 만듭니다. Tailwind, Design System와의 충돌 방지에도 탁월합니다.

```css
@layer reset, base, components, utilities, overrides;

@layer reset {
  *,*::before,*::after { box-sizing: border-box; margin: 0; }
}
@layer base {
  :root {
    --radius: 10px;
    --fg: #111; --bg: #fff;
  }
  html { color: var(--fg); background: var(--bg); }
}
@layer components {
  .button { padding: .625rem 1rem; border-radius: var(--radius); }
  .card { border: 1px solid #ddd; border-radius: var(--radius); }
}
@layer utilities {
  .sr-only { position: absolute; clip: rect(0,0,0,0); }
  .text-red { color: #dc2626; }
}
@layer overrides {
  /* 특정 페이지에서만 덮어쓰기 */
  .card { border-color: rebeccapurple; }
}
```

---

### `:is()`/`:where()` — 선택자 **묶기**와 specificity 제어

- `:is()`는 가장 **강한** 선택자의 specificity를 따릅니다.
- `:where()`는 **항상 0**으로 계산되어 충돌을 완화합니다.

```css
/* 타이포 스케일 공통 간격 */
:is(h1,h2,h3,h4,h5,h6) { margin-block: .75rem; }

/* 버튼/링크 군집의 기본 색(우선순위 0) → 다른 계층에서 안심하고 덮기 */
:where(.btn,.link) { color: var(--primary); }
```

---

## 반응형의 재정의: 컨테이너 쿼리 · 서브그리드 · 네스팅

### 컨테이너 쿼리 — “화면이 아니라 **컴포넌트** 크기에 반응”

`@container`는 **요소 자신의 컨테이너 크기**에 따라 스타일을 바꿉니다. 레이아웃 조합이 많은 대규모 UI에서 **미디어쿼리의 단점(전역 뷰포트 의존)**을 해소합니다.
DevTools가 검사/디버깅도 지원합니다.

```css
.card {
  container-type: inline-size; /* 수평 크기 기준 컨테이너 */
  display: grid;
  gap: 1rem;
}

/* 카드가 충분히 넓어졌을 때, 이미지를 왼쪽으로 */
@container (min-width: 420px) {
  .card__media { grid-column: 1; }
  .card__body  { grid-column: 2; }
}
```

**패턴**
- 카드/패널/리스트 **항목**이 **배치 맥락**에 맞춰 스스로 변형
- 디자인 시스템: “컴포넌트 → 상황별 자가 반응”으로 **조립성** 증가

---

### `subgrid` — 그리드 **손자까지** 라인 공유

서브그리드는 **부모 그리드의 열/행 라인**을 그대로 상속해 **정렬 기준을 통일**합니다. 복잡한 기사/대시보드/프로필 레이아웃에서 헤더/본문/메타가 **한 줄 기준**으로 맞아떨어집니다.

```css
.article {
  display: grid;
  grid-template-columns: 1fr 2fr;
  gap: 1rem;
}

.article__meta,
.article__content {
  display: grid;
  grid-template-columns: subgrid; /* 부모 열 라인 사용 */
  grid-column: 1 / -1;            /* 부모 열 범위에 맞게 */
}
```

---

### CSS 네스팅 — SCSS 없이 **공식 CSS 문법**으로

브라우저가 **네이티브 네스팅**을 지원합니다. BEM/컴포넌트 스타일이 간결해지고, 빌드 없는 환경에서도 가독성을 얻습니다.

```css
.card {
  border: 1px solid #e5e7eb; border-radius: 10px; padding: 1rem;

  & .title { font-weight: 700; }
  &:hover { box-shadow: 0 4px 20px color-mix(in oklch, #000 10%, transparent); }

  &.is-selected {
    border-color: rebeccapurple;
  }
}
```

---

## 인터랙션 & 모션: 스크롤 타임라인, 성능 친화 애니메이션

### `@scroll-timeline` / `animation-timeline`

스크롤 위치를 애니메이션 타임라인에 **직접 바인딩**합니다. 스크롤-연동 페이드/파랄랙스/진행 바 등에서 JS 의존도를 줄입니다.

```css
@scroll-timeline heroReveal {
  source: auto;             /* 최근접 스크롤 컨테이너 */
  orientation: block;       /* 수직 스크롤 */
}

.hero__copy {
  animation: reveal 1s both;
  animation-timeline: heroReveal;
  animation-range: entry 20% cover 60%; /* 진입 후 ~ 덮을 때까지 */
}

@keyframes reveal {
  from { opacity: 0; translate: 0 2rem; }
  to   { opacity: 1; translate: 0 0; }
}
```

**권장 원칙**
- 가능하면 **transform/opacity**만 애니메이션(합성 단계)
- `will-change`는 **짧게, 필요한 동안만** 부여

---

## 디자인 시스템·테마: 커스텀 프로퍼티 + 레이어

CSS 변수는 다크모드·접근성 대비·프로덕트 브랜드 확장에서 **핵심 축**입니다. 레이어와 조합하면 “**기본값→컴포넌트→브랜드 오버라이드**”의 안전한 우선순위 사다리를 만들 수 있습니다.

```css
@layer tokens, semantics, components, themes;

@layer tokens {
  :root {
    --radius: 12px;
    --fg: oklch(20% 0.02 250); --bg: oklch(98% 0.01 250);
    --primary: oklch(55% 0.19 280);
  }
}

@layer semantics {
  :root {
    --link: var(--primary);
    --border: color-mix(in oklch, var(--fg), var(--bg) 85%);
  }
}

@layer components {
  .chip {
    border-radius: var(--radius);
    border: 1px solid var(--border);
    padding: .375rem .625rem;
  }
  .link { color: var(--link); }
}

@layer themes {
  [data-theme="dark"] {
    --fg: oklch(92% 0.02 250);
    --bg: oklch(12% 0.02 250);
  }
}
```

---

## 프레임워크·생태계 트렌드 (요지)

- **유틸리티 퍼스트/온디맨드**: 설정보다 구성. UnoCSS 같은 온디맨드 원자화 빌드는 **제로 런타임**을 지향.
- **변수 기반 시스템**: Open Props 같은 **표준 CSS 변수 팩**이 토큰 레이어로 도입 용이.
- **설문 트렌드**: 컨테이너 쿼리·네스팅·`:has()`가 **실사용 곡선**에 진입(2024~25 지표에서 채택률 급증 보고).

---

## 브라우저 지원·표준화 흐름 요약

- `:has()` — 최신 브라우저 전반 지원(모바일 포함).
- CSS 네스팅 — 주요 엔진이 기본 제공, 실사용 가능.
- `subgrid` — 파이어폭스 선도, 크로미움/사파리도 채택 확산.
- 스크롤 타임라인 — 점진적 지원 확대, 폴백 전략 권장.
- 컨테이너 쿼리 — 크롬/에지/사파리/파폭에서 개발자도구 지원 포함해 현실 적용 가능(검사·디버그 가이드 참고).

> **전략**: 위 기능들은 대체/폴백이 비교적 수월합니다. 핵심 경로(접근성·주요 플로우)는 폴백 확보, 장식/향상 영역은 최신 기능 적극 사용.

---

## 실무 패턴 모음 (붙여 쓰는 코드)

### 폼 필드 상태(값·에러)에 따른 부모 하이라이트 — `:has()`

```css
.field { display: grid; gap: .375rem; }
.field:has(input:user-invalid),
.field:has(textarea:user-invalid) {
  --ring: #ef4444;
  box-shadow: 0 0 0 3px color-mix(in oklch, var(--ring), white 70%);
}
.field:has(input:not(:placeholder-shown)) .field__label {
  opacity: .7;
  transform: translateY(-.25rem) scale(.95);
}
```

```html
<label class="field">
  <span class="field__label">Email</span>
  <input required type="email" placeholder=" ">
  <span class="field__desc">업무용 메일을 입력하세요</span>
</label>
```

---

### 카드가 “좁으면 스택, 넓으면 2열” — 컨테이너 쿼리

```css
.product-card { container-type: inline-size; display: grid; gap: 1rem; }
.product-card__media { aspect-ratio: 1/1; background: #f3f4f6; }

@container (min-width: 520px) {
  .product-card {
    grid-template-columns: 1fr 1.4fr;
    align-items: center;
  }
}
```

---

### 기사 레이아웃의 헤더·본문 라인 정렬 — `subgrid`

```css
.article {
  display: grid;
  grid-template-columns: 12rem 1fr;
  gap: 1rem 2rem;
}
.article__header,
.article__body {
  display: grid;
  grid-template-columns: subgrid; /* 부모 열 라인 재사용 */
  grid-column: 1 / -1;
}
```

---

### 스크롤-진행 바 — `@scroll-timeline`

```css
@scroll-timeline reading {
  source: auto;
  scroll-offsets: selector(#content) start 0, selector(#content) end 100%;
}

.progress {
  position: fixed; inset: 0 auto auto 0; height: 4px; width: 0;
  background: linear-gradient(90deg, var(--primary), hotpink);
  animation: grow 1s linear both;
  animation-timeline: reading;
  animation-range: 0% 100%;
}
@keyframes grow { to { width: 100vw; } }
```

---

### `@layer`로 “유틸 → 컴포넌트 → 페이지 오버라이드”

```css
@layer utilities, components, page;

@layer utilities {
  .stack > * + * { margin-block-start: var(--stack, 1rem); }
  .center { display: grid; place-items: center; }
}
@layer components {
  .button { padding: .5rem .875rem; border-radius: 10px; }
  .button--primary { background: var(--primary); color: white; }
}
@layer page {
  /* 이 페이지에서만 버튼 색 약간 다르게 */
  .button--primary { background: color-mix(in oklch, var(--primary), black 10%); }
}
```

---

## 도입·마이그레이션 체크리스트

- [ ] 브라우저 타깃 명시(Browserslist) 후 **폴리필/대체** 필요 기능 파악
- [ ] `@layer`로 **우선순위 체계** 먼저 수립 (reset/base/components/utilities/overrides)
- [ ] 디자인 토큰(컬러/타이포/레디우스)을 **CSS 변수**로 확정
- [ ] 컨테이너 쿼리 도입: **카드/패널 컴포넌트**부터 적용
- [ ] 스크롤 모션은 핵심 흐름 가리지 않는 **보조 채널**로만 (접근성 고려)
- [ ] DevTools로 컨테이너·그리드·타임라인 **시각 디버그** 활용

---

## 더 읽기 / 근거 자료

- MDN `:has()` — 관계 선택자, 지원 현황/예제.
- MDN CSS 네스팅 — 기본 문법과 사용 패턴.
- MDN `subgrid` — 라인 공유와 브라우저 상태.
- MDN `@scroll-timeline`/`animation-timeline` — 스크롤-연동 애니메이션.
- Chrome DevTools: **컨테이너 쿼리 디버깅** 가이드.
- Apple/WebKit 블로그: 최신 CSS 기능 채택 소식(사파리).
- State of CSS 2024: 채택률과 체감 트렌드 요약.

---

## 마무리

2025년의 CSS는 **컴포넌트의 맥락**과 **사용자 상태**를 직접 이해하고 반응합니다.
**`:has()` → 상태**, **`@container`/`subgrid` → 맥락**, **네스팅/레이어** → 구조/우선순위, **스크롤 타임라인** → 모션.
지금 가장 중요한 역량은 **“적용 기준”**을 세우는 일입니다.
- 핵심 경로는 **보수적**(폴백 필수),
- 부가·강화 섹션은 **공격적**(최신 기능 적극 적용).
이 기준으로 팀의 디자인 시스템을 한 단계 끌어올리세요.
