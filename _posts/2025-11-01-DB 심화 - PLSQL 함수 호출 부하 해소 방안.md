---
layout: post
title: DB 심화 - PL/SQL 함수 호출 부하 해소 방안
date: 2025-11-01 23:25:23 +0900
category: DB 심화
---
# 처리** + **DECODE/CASE로 함수 대체**

> **핵심 요약**
> - **함수 호출 부하**의 1차 원인은 “**행마다 호출**”과 “**함수 내부 재귀 SQL(N+1)**”이다.
> - **페이지 처리(부분범위 처리, STOPKEY)** 로 *읽는 행 자체*를 줄이면 **함수 호출 수**가 선형으로 감소한다.
> - **DECODE/CASE**(순수 SQL)로 **PL/SQL 함수**를 대체하면 **컨텍스트 전환**과 **라이브러리 캐시 의존**을 없애고 **SARGability**를 지키기 쉬워진다.
> - 정석 순서: **(1) 페이지 처리 설계 → (2) 함수 제거(=DECODE/CASE/조인/SQL 매크로) → (3) SARG 유지 → (4) TKPROF/SQL Monitor로 검증.**

---

## 공통 실습 스키마

```sql
-- 주문 테이블(2,000,000행 가정)
DROP TABLE orders PURGE;
CREATE TABLE orders (
  order_id     NUMBER PRIMARY KEY,
  customer_id  NUMBER NOT NULL,
  created_at   DATE   NOT NULL,
  region       VARCHAR2(20),
  status_code  NUMBER,
  amount       NUMBER(12,2)
);

INSERT /*+ APPEND */ INTO orders
SELECT level,
       MOD(level, 500000)+1,
       (TRUNC(SYSDATE) - MOD(level, 365)) + (MOD(level,86400)/86400),
       CASE MOD(level,4) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA'
                         WHEN 2 THEN 'AMER' ELSE 'OTHER' END,
       MOD(level, 6),  -- 0~5 코드
       ROUND(DBMS_RANDOM.VALUE(10, 1000), 2)
FROM dual CONNECT BY level <= 2000000;
COMMIT;

-- 상태 코드 사전(룩업)
DROP TABLE dim_status PURGE;
CREATE TABLE dim_status (
  status_code  NUMBER PRIMARY KEY,
  status_name  VARCHAR2(30) NOT NULL
);
INSERT INTO dim_status VALUES (0, 'NEW');
INSERT INTO dim_status VALUES (1, 'PAID');
INSERT INTO dim_status VALUES (2, 'SHIPPED');
INSERT INTO dim_status VALUES (3, 'DELIVERED');
INSERT INTO dim_status VALUES (4, 'RETURN');
INSERT INTO dim_status VALUES (5, 'CANCEL');
COMMIT;

-- 페이지 처리를 위한 인덱스(필터+정렬+tie-breaker)
CREATE INDEX ix_orders_cust_time
  ON orders(customer_id, created_at DESC, order_id DESC);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'ORDERS', cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'DIM_STATUS', cascade=>TRUE);
END;
/
```

---

## 문제 패턴: 함수로 인한 부하 (비교용 ‘나쁜’ 예)

### PL/SQL 함수(내부 재귀 SQL 포함)

```plsql
CREATE OR REPLACE FUNCTION get_status_name(p_code NUMBER)
  RETURN VARCHAR2
IS
  v VARCHAR2(30);
BEGIN
  SELECT status_name INTO v
  FROM   dim_status
  WHERE  status_code = p_code;
  RETURN v;
EXCEPTION WHEN NO_DATA_FOUND THEN
  RETURN 'UNKNOWN';
END;
/
```

```sql
-- ❌ 목록 화면(첫 페이지 50건)에 '함수'를 직접 사용
SELECT order_id,
       created_at,
       amount,
       get_status_name(status_code) AS status_name        -- 행마다 호출
FROM   orders
WHERE  customer_id = :cust
  AND  get_status_name(status_code) <> 'CANCEL'          -- 필터에서도 호출
ORDER  BY created_at DESC, order_id DESC
OFFSET :skip ROWS FETCH NEXT :take ROWS ONLY;            -- OFFSET 기반
```

- **문제점**
  1) **OFFSET** 방식: 페이지가 뒤로 갈수록 **앞부분을 읽고 버림** → I/O 급증.
  2) **함수 내부 재귀 SQL**: `orders`의 행 수만큼 `dim_status` SELECT 발생 → **N+1**.
  3) **필터에 함수**: SARGability 손실(인덱스 활용 불리).
  4) **컨텍스트 전환**(SQL↔PL/SQL): 호출 수에 비례해 CPU 증가.

> TKPROF 징후: `recursive calls`↑, `db file sequential read`↑, Fetch elapsed↑, `SQL*Net message from client` 다수.

---

## 해법 A — **페이지 처리(부분범위 처리, STOPKEY)로 함수 호출 수부터 줄이기**

### 원리

- TOP-N/Keyset Pagination으로 **항상 상위 N만** 읽는다 → **함수 호출 수도 N** 개 근사로 제한.
- Oracle 실행계획에서 `STOPKEY` 로 표현되며, **인덱스 정렬**이 맞으면 **정렬 없이** 중간에 **즉시 멈춤**.

### 코드: OFFSET → Keyset으로 전환

**첫 페이지(최신 50건)**

```sql
SELECT /*+ index(o ix_orders_cust_time) */
       o.order_id,
       o.created_at,
       o.amount,
       o.status_code
FROM   orders o
WHERE  o.customer_id = :cust
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;     -- STOPKEY
```

**다음 페이지(마지막 본 키 이후 50건)**

```sql
SELECT /*+ index(o ix_orders_cust_time) */
       o.order_id,
       o.created_at,
       o.amount,
       o.status_code
FROM   orders o
WHERE  o.customer_id = :cust
  AND (o.created_at, o.order_id) < (:last_ts, :last_id)
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;     -- STOPKEY
```

- **효과**
  - 읽는 행 수를 페이지 크기(50) 수준으로 제한 → **함수 호출 수 상한**.
  - `OFFSET` 제거로 **앞부분 버리기 비용** 해소.
  - Keyset은 동시성(중복/누락)에도 강함.

> **팁**: 목록 컬럼만 SELECT(필요 시 **커버링 인덱스** 고려) → I/O 추가 절감.

---

## 또는 조인으로 대체**

### 단순 매핑: **DECODE/CASE**로 즉시 변환

**필터 조건 개선 (함수 대신 CASE/DECODE)**

```sql
-- 상태 코드가 CANCEL이 아닌 주문
SELECT o.order_id, o.created_at, o.amount
FROM   orders o
WHERE  o.customer_id = :cust
  AND  CASE o.status_code
         WHEN 5 THEN 'CANCEL'
         ELSE 'OK'        -- 예시: 간략 매핑
       END <> 'CANCEL'
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

또는

```sql
WHERE DECODE(o.status_code, 5, 'CANCEL', 'OK') <> 'CANCEL'
```

- **장점**:
  - **컨텍스트 전환 0**(PL/SQL 호출 없음)
  - 옵티마이저가 **단일 SQL**로 최적화 가능
  - 간단 매핑은 **CASE/DECODE**가 가장 빠르고 안정

**표시 컬럼에만 매핑(투영 단계)**

```sql
SELECT o.order_id,
       o.created_at,
       o.amount,
       CASE o.status_code
         WHEN 0 THEN 'NEW'      WHEN 1 THEN 'PAID'
         WHEN 2 THEN 'SHIPPED'  WHEN 3 THEN 'DELIVERED'
         WHEN 4 THEN 'RETURN'   WHEN 5 THEN 'CANCEL'
         ELSE 'UNKNOWN'
       END AS status_name
FROM   orders o
WHERE  o.customer_id = :cust
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

- **권장 위치**: **투영(SELECT-LIST)** — 필터/조인으로 결과가 줄어든 후 **소수 행에만** 계산.

### 룩업 테이블 조인으로 대체 (스케일 잘 됨)

```sql
SELECT o.order_id,
       o.created_at,
       o.amount,
       s.status_name
FROM   orders o
JOIN   dim_status s
  ON   s.status_code = o.status_code
WHERE  o.customer_id = :cust
  AND  s.status_name <> 'CANCEL'
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

- **장점**:
  - **N+1 제거**: 조인 1회로 일괄 매핑
  - 통계/카디널리티 기반으로 올바른 플랜 도출
  - 룩업 변경이 잦아도 **데이터 주도**(CASE 하드코딩보다 유지보수 우수)

---

## 두 해법의 결합: “페이지 처리 + 함수 제거(=DECODE/CASE/조인)”

### 최적 형태(예시)

```sql
SELECT /*+ index(o ix_orders_cust_time) */
       o.order_id,
       o.created_at,
       o.amount,
       s.status_name
FROM   orders o
JOIN   dim_status s
  ON   s.status_code = o.status_code
WHERE  o.customer_id = :cust
  AND  s.status_name <> 'CANCEL'
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;   -- STOPKEY: 읽기량 자체 축소
```

- **이득 요약**
  - **STOPKEY** 로 **읽는 행 수 자체 축소** → CPU/I-O/락경합↓
  - **조인/CASE** 로 **컨텍스트 전환·재귀 SQL 0**
  - **필터 SARG 유지** → 인덱스 활용 유리
  - **전형적인 목록 API**에서 p95를 **수백 ms → 수십 ms**로 내릴 수 있음

---

## 유지 팁 — 함수 제거와 함께 반드시 점검

1) **열에 함수 적용 금지**: `WHERE TRUNC(created_at)=:d` → `created_at>=:d AND created_at<:d+1`
2) **정렬/필터 복합 인덱스**: `(customer_id, created_at DESC, order_id DESC)`
3) **필요 컬럼만 SELECT**(커버링 후보)
4) **Keyset 튜플 비교**: `(created_at, order_id) < (:last_ts, :last_id)`
5) **CASE/DECODE는 필터에도 안전**: 열 자체에 함수가 얹히지 않기 때문
   - 비교식 자체가 복잡해질 경우 **함수기반 인덱스(FBI)** 대안도 고려

---

## BEFORE → AFTER 비교(개요)

### BEFORE (함수 + OFFSET)

```sql
SELECT order_id,
       get_status_name(status_code) AS status_name
FROM   orders
WHERE  customer_id=:cust
  AND  get_status_name(status_code) <> 'CANCEL'
ORDER  BY created_at DESC, order_id DESC
OFFSET :skip ROWS FETCH NEXT :take ROWS ONLY;
```

**예상 증상**
- `recursive calls` 다수(행마다 dim_status SELECT)
- Fetch elapsed↑ (`SQL*Net message from client` 다수)
- Offset 커질수록 I/O 폭증

### AFTER (Keyset + 조인/CASE)

```sql
SELECT /*+ index(o ix_orders_cust_time) */
       o.order_id,
       o.created_at,
       o.amount,
       s.status_name
FROM   orders o
JOIN   dim_status s ON s.status_code=o.status_code
WHERE  o.customer_id=:cust
  AND  s.status_name <> 'CANCEL'
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

**개선 포인트**
- `recursive calls`≈0, Fetch count 1~2회, Execute I/O ↓
- 대기 이벤트 상위에서 `db file scattered/sequential read` 감소, `SQL*Net` 감소
- 전체 elapsed 대폭 감소

---

## “함수 → CASE/DECODE” 변환 패턴 모음

### 문자열 정규화(간단 규칙)

```sql
-- PL/SQL 함수 대신 CASE로 정규화
CASE TRIM(UPPER(region))
  WHEN 'APAC' THEN 'APAC'
  WHEN 'ASIA PACIFIC' THEN 'APAC'
  WHEN 'EMEA' THEN 'EMEA'
  WHEN 'EUROPE' THEN 'EMEA'
  WHEN 'AMER' THEN 'AMER'
  WHEN 'US'   THEN 'AMER'
  WHEN 'NA'   THEN 'AMER'
  ELSE 'OTHER'
END
```

**필터에 사용 시(열에 함수 금지)**

```sql
-- 바인드에만 정규화 적용: 열은 그대로 → 인덱스 사용에 유리
WHERE region = CASE TRIM(UPPER(:b_region))
                 WHEN 'ASIA PACIFIC' THEN 'APAC'
                 ELSE TRIM(UPPER(:b_region))
               END
```

### 숫자 코드 매핑

```sql
DECODE(status_code,
  0,'NEW', 1,'PAID', 2,'SHIPPED', 3,'DELIVERED', 4,'RETURN', 5,'CANCEL',
  'UNKNOWN')
```

### 범위 매핑(요금 등급)

```sql
CASE
  WHEN amount <  50  THEN 'LOW'
  WHEN amount < 200  THEN 'MID'
  WHEN amount < 1000 THEN 'HIGH'
  ELSE 'VIP'
END
```

> 모두 **순수 SQL** → 최적화/배치/병렬/조인과 잘 맞는다.

---

## “룩업이 자주 바뀌어요” — CASE 하드코딩 대신 **조인/SQL 매크로**

- **룩업 테이블 조인**을 기본으로 하고, 표시 목적일 때만 **투영에서 CASE** (배포 없이 UI 레이블 변경 가능).
- 19c+에서는 **SQL 매크로**로 패턴을 안전하게 캡슐화(PL/SQL 함수의 재귀 SQL 없이 SQL로 확장).

*(참고용 예시)*

```plsql
CREATE OR REPLACE FUNCTION m_orders_page(p_take NUMBER)
  RETURN VARCHAR2 SQL_MACRO(SCALAR) IS
BEGIN
  RETURN q'{
    SELECT /*+ index(o ix_orders_cust_time) */
           o.order_id, o.created_at, o.amount, s.status_name
    FROM   orders o
    JOIN   dim_status s ON s.status_code = o.status_code
    WHERE  o.customer_id = :cust
    ORDER  BY o.created_at DESC, o.order_id DESC
    FETCH FIRST p_take ROWS ONLY
  }';
END;
/
```

```sql
-- 사용 시에는 '함수'처럼 보이지만, 내부는 SQL로 확장 → 재귀 SQL 없음
SELECT * FROM m_orders_page(50);
```

---

## 측정 절차(간단 체크리스트)

1) **통계 레벨/트레이스**
   ```sql
   ALTER SESSION SET statistics_level=ALL;
   ALTER SESSION SET events '10046 trace name context forever, level 8';
   -- BEFORE/AFTER 각각 실행
   ALTER SESSION SET events '10046 trace name context off';
   ```
2) **TKPROF/SQL Monitor**에서 확인
   - `recursive calls` (함수 제거 시 급감)
   - `Fetch count` (Keyset+배열 페치로 1~2회 목표)
   - `consistent gets/physical reads` (STOPKEY로 감소)
   - 상위 대기 이벤트 변화(정렬/I-O/SQL*Net)

---

## 흔한 질문(FAQ)

- **CASE가 길어지면 느린가요?**
  - 대부분 **아니오**. *행마다 PL/SQL 함수*보다 훨씬 낫다. 룩업이 자주 바뀌면 **조인**으로 관리.

- **함수기반 인덱스(FBI)로 해결 안 되나요?**
  - 필터에서 **열에 함수 필수**라면 대안이지만, **FBI 생성/관리 비용**이 있다.
  - 가능하면 **바인드 쪽 변환** 또는 **조인/CASE**로 우회.

- **PRAGMA UDF, RESULT_CACHE 붙이면 되나요?**
  - **순수 계산형**에서만 부분 효과. **재귀 SQL**이 있으면 근본 해결이 아니다.

---

## 클라이언트 쪽 추가 팁(왕복 최소화)

- **Keyset + Array Fetch**
  - JDBC: `setFetchSize(1000~2000)`
  - ODP.NET: `FetchSize = 4~16MB`
  - Python: `cursor.arraysize = 1000~5000`
- **필요 컬럼만** 가져오기(네트워크/GC 절감)
- **Statement/Session Cursor Cache** 활성(파싱 오버헤드 최소화)

---

## 최종 ‘레시피’ 요약

1) **페이지 처리**를 **Keyset + STOPKEY**로 설계 (OFFSET 금지).
2) PL/SQL **함수 제거**:
   - 단순 매핑/정규화 → **DECODE/CASE**
   - 코드→명칭 → **룩업 조인**
   - 재사용 패턴 → **SQL 매크로**
3) **SARG 유지**: 정렬·필터 복합 인덱스, 열에 함수 금지(필요 시 FBI).
4) **배열 페치/소량 컬럼**으로 왕복·전송 최소화.
5) TKPROF/SQL Monitor로 **전/후 비교**(recursive calls, Fetch count, elapsed, 대기 이벤트).

---

## 완성 예 — 실무형 쿼리(첫/다음 페이지)

**첫 페이지**

```sql
SELECT /*+ index(o ix_orders_cust_time) */
       o.order_id,
       o.created_at,
       o.amount,
       s.status_name
FROM   orders o
JOIN   dim_status s
  ON   s.status_code = o.status_code
WHERE  o.customer_id = :cust
  AND  s.status_name <> 'CANCEL'
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST :take ROWS ONLY;
```

**다음 페이지**

```sql
SELECT /*+ index(o ix_orders_cust_time) */
       o.order_id,
       o.created_at,
       o.amount,
       s.status_name
FROM   orders o
JOIN   dim_status s
  ON   s.status_code = o.status_code
WHERE  o.customer_id = :cust
  AND  s.status_name <> 'CANCEL'
  AND  (o.created_at, o.order_id) < (:last_ts, :last_id)
ORDER  BY o.created_at DESC, o.order_id DESC
FETCH FIRST :take ROWS ONLY;
```

> **핵심**: 이 두 쿼리는 **함수 호출 0**, **부분범위 처리 YES**, **SARG 유지**를 만족한다.
> 목록/검색 화면에서 **가장 안전하고 빠른 기본형**이다.

---

## 결론

- **페이지(부분범위) 처리**는 PL/SQL 함수 호출 수를 **본질적으로 줄이는 1차 방어선**이다.
- **DECODE/CASE(또는 조인/SQL 매크로)** 로 **함수 자체를 제거**하면 컨텍스트 전환과 재귀 SQL이 사라져 **선형적으로 빨라진다**.
- 정렬·필터 인덱스와 SARG를 지키면서 Array Fetch를 결합하면, 대부분의 목록·검색 API에서 **p95가 한 자릿수~두 자릿수 ms**로 안정화된다.
- 언제나 **측정(Trace/TKPROF/Monitor)** 으로 전/후를 수치화해, “함수 → DECODE/CASE + 페이지 처리”의 효과를 확인하라.
