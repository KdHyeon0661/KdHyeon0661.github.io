---
layout: post
title: Svelte - 배포 & 운영
date: 2025-10-03 20:30:23 +0900
category: Svelte
---
# 14. 배포 & 운영
**어댑터(Node / Vercel / Netlify / Cloudflare) · Edge/서버리스 특성 비교 · 환경 변수/비밀 관리 · 로그 수집 · 오류 추적/성능 모니터링(Sentry 등)**

> 이 장은 SvelteKit 앱을 **현실 세계에 안전하게 배포**하고 **운영**하는 방법을 총정리한다.  
> - 플랫폼별 **어댑터 설정**과 배포 스크립트  
> - **Edge/서버리스/Node** 환경의 성능·제약 차이와 설계 패턴  
> - **환경 변수/비밀(Secrets)** 관리, **구성(Configurability)** 전략  
> - **로그/관측(Observability)**: 구조적 로깅, 상관관계 ID, 요청 추적  
> - **오류 추적/성능 모니터링**(Sentry/OTel) 실전 통합

---

## 14.1 어댑터 개요 — 배포 타깃에 맞게 빌드

SvelteKit은 **어댑터(adapter)**로 배포 아티팩트를 생성한다. 대표적 선택지:

- **@sveltejs/adapter-node**: 전통적 Node 서버 (PM2/Docker/K8s 등)  
- **@sveltejs/adapter-vercel**: Vercel(서버리스/Edge Functions)  
- **@sveltejs/adapter-netlify**: Netlify(Functions/Edge)  
- **@sveltejs/adapter-cloudflare**: Cloudflare(Workers/Pages Functions; Edge 런타임)

> 선택 기준: **지연(latency)**, **콜드스타트**, **CPU/메모리**, **런타임 제약**(Node API 사용 가능 여부), **가격/지역**, **데이터베이스 연결 모델**(롱커넥션 vs HTTP).

### 14.1.1 공통: `svelte.config.js`에 어댑터 설정

```js
// svelte.config.js (예시 템플릿)
import adapter from '@sveltejs/adapter-node'; // 배포 대상에 맞춰 교체
import preprocess from 'svelte-preprocess';

const config = {
  preprocess: preprocess(),
  kit: {
    adapter: adapter({
      // 어댑터별 옵션 (아래 섹션 참조)
    }),
    csrf: { checkOrigin: true } // 운영에선 기본적으로 권장
  }
};

export default config;
```

---

## 14.2 Node 어댑터 — 전통적 서버 / Docker / K8s

### 14.2.1 설치 & 빌드

```bash
pnpm add -D @sveltejs/adapter-node
# svelte.config.js에 adapter-node 설정
pnpm build
# .svelte-kit/output(내부) → build/ 로 서버 번들 생성
```

빌드 후 실행:

```bash
node build/index.js
```

### 14.2.2 프로세스 관리자(PM2) / Graceful Shutdown

```bash
pnpm add -D pm2

# ecosystem.config.js
module.exports = {
  apps: [{
    name: 'myapp',
    script: 'build/index.js',
    instances: 'max',
    exec_mode: 'cluster',
    env: { NODE_ENV: 'production' }
  }]
};
```

```bash
pnpm build
pm2 start ecosystem.config.js
# 로그 확인
pm2 logs myapp
```

SvelteKit(Node) 서버는 일반적으로 **SIGTERM/SIGINT**를 처리하여 종료한다. DB 커넥션/큐를 닫도록 **graceful shutdown**을 구현하자.

```js
// src/lib/server/lifecycle.ts
export function onShutdown(fn: () => Promise<void> | void) {
  ['SIGTERM', 'SIGINT'].forEach(sig => {
    process.on(sig, async () => {
      try { await fn(); } finally { process.exit(0); }
    });
  });
}
```

### 14.2.3 Nginx 리버스 프록시(HTTPS, 압축, 캐시)

```nginx
server {
  listen 443 ssl http2;
  server_name example.com;

  # SSL 설정 생략…

  location / {
    proxy_pass http://127.0.0.1:3000;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    # 정적 캐시(assets/* 는 immutable)
  }

  location /assets/ {
    expires 1y;
    add_header Cache-Control "public, max-age=31536000, immutable";
  }
}
```

### 14.2.4 Docker 배포

```dockerfile
# Dockerfile (multi-stage)
FROM node:20-alpine AS build
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN corepack enable && pnpm i --frozen-lockfile
COPY . .
RUN pnpm build

FROM node:20-alpine AS runner
ENV NODE_ENV=production
WORKDIR /app
COPY --from=build /app/build ./build
COPY package.json pnpm-lock.yaml ./
RUN corepack enable && pnpm i --prod --frozen-lockfile
EXPOSE 3000
CMD ["node", "build/index.js"]
```

Kubernetes 배포 시 **readinessProbe/livenessProbe**를 구현하자(간단 health route 권장).

---

## 14.3 Vercel 어댑터 — Serverless / Edge Functions

### 14.3.1 설치 & 설정

```bash
pnpm add -D @sveltejs/adapter-vercel
# svelte.config.js에 adapter-vercel
```

선택 옵션(개념):

- 서버리스/Edge 선택 (라우트별로도 지정 가능)  
- 이미지/정적 파일은 Vercel CDN에 자동 배치

`vercel.json`(선택):

```json
{
  "regions": ["icn1","hnd1"],
  "env": {
    "PUBLIC_API_BASE": "https://api.example.com"
  }
}
```

> **주의**: Edge Function에서는 **Node 전용 모듈(예: fs, crypto 일부)** 사용 불가. **Web/WHATWG** API 기반으로 작성.

### 14.3.2 Edge로 보내기(라우트 단위)

```ts
// src/routes/edge-only/+server.ts
export const config = {
  runtime: 'edge' // vercel edge runtime
};

export const GET = async () => {
  return new Response('hello from edge');
};
```

> 인증/쿠키/짧은 읽기 I/O, **지연 민감** API에 Edge를 고려. 대규모 CPU 작업은 서버리스/Node 쪽으로.

---

## 14.4 Netlify 어댑터 — Functions / Edge Functions

### 14.4.1 설치

```bash
pnpm add -D @sveltejs/adapter-netlify
```

`netlify.toml`:

```toml
[build]
  command = "pnpm build"
  publish = "build" # 어댑터가 생성한 배포물 위치를 자동으로 처리

[dev]
  command = "pnpm dev"

[[redirects]]
  from = "/api/*"
  to = "/.netlify/functions/server"
  status = 200
```

> Netlify Functions는 AWS Lambda 기반, Edge Functions는 Deno/Edge 런타임. **Node 전용 API 제약**을 확인.

---

## 14.5 Cloudflare 어댑터 — Workers / Pages Functions

### 14.5.1 설치 & Wrangler

```bash
pnpm add -D @sveltejs/adapter-cloudflare wrangler
# wrangler.toml 생성
```

`wrangler.toml` 예시:

```toml
name = "myapp"
main = "./.cloudflare/worker.js"
compatibility_date = "2025-01-01"

[vars]
PUBLIC_API_BASE = "https://api.example.com"

[[kv_namespaces]]
binding = "KV"
id = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

[[r2_buckets]]
binding = "R2"
bucket_name = "my-bucket"
```

> Cloudflare Workers는 **Edge 런타임**(V8 isolate). **Node 전용 API 미지원**.  
> 제공 자원: **KV, D1(SQLite 호환), R2(S3유사), Durable Objects**, **Cache API**.

### 14.5.2 플랫폼 API 접근

```ts
// src/routes/api/cache/+server.ts
import type { RequestHandler } from './$types';

export const GET: RequestHandler = async ({ platform, url, fetch }) => {
  const key = new Request(url.toString());
  const cache = platform?.caches?.default;
  if (cache) {
    const hit = await cache.match(key);
    if (hit) return hit;
    const upstream = await fetch('https://httpbin.org/json');
    const res = new Response(upstream.body, upstream);
    await cache.put(key, res.clone());
    return res;
  }
  return new Response('no cache api', { status: 501 });
};
```

---

## 14.6 Edge / 서버리스 / Node 비교 & 아키텍처 패턴

### 14.6.1 특성 비교(텍스트 요약)

- **Edge(Workers/Edge Functions)**  
  - **초저지연**(사용자 근접 POP) · **콜드스타트 매우 짧음**  
  - **제한된 런타임**(Node 내장 모듈 X, 파일시스템 X, 소켓 제약)  
  - **짧은 CPU 타임/메모리**  
  - **스토리지**는 KV/HTTP/API 위임 (롱커넥션 DB는 부적합)
- **Serverless(Lambda 계열)**  
  - **콜드스타트 존재**, CPU/메모리 제한  
  - Node 런타임 사용 가능(단, /tmp 정도만 쓰기 가능)  
  - 동시성·자동 스케일 좋음
- **Node 서버(Always-on)**  
  - **롱커넥션(DB/WebSocket)**, 파일 처리에 유리  
  - 콜드스타트 없음, **유지 비용/스케일링 자체 관리**

### 14.6.2 설계 패턴

- **하이브리드 라우팅**:  
  - **Edge**: 인증 체크, 캐시된 읽기, 지연 민감 라우트  
  - **Serverless/Node**: 이미지 변환/리포트 생성/대규모 연산/웹소켓/직접 DB
- **데이터 계층**:  
  - Edge에서는 **HTTP 데이터 API**(DB 프록시/PlanetScale HTTP, Prisma Accelerate, Neon HTTP) 사용  
  - Node/서버리스는 **Connection Pool** 주의(서버리스는 콜드/웜 고려)
- **파일 업로드**:  
  - 클라 → **Pre-signed URL**로 S3/R2 직접 업로드, 서버는 **메타만 기록**
- **캐시 전략**:  
  - Edge Cache(API 응답) + 브라우저 캐시 + CDN 캐시 헤더 조합
- **Cron/백그라운드 작업**:  
  - Edge/서버리스 제공 **Scheduler**(Cloudflare Cron, Vercel Scheduled Functions) 또는 외부 워커/큐 사용

---

## 14.7 환경 변수 / 비밀 관리

### 14.7.1 SvelteKit의 `$env` 네임스페이스

- **서버 전용(비공개)**  
  - `$env/dynamic/private` — 런타임에 환경 접근 (서버만)  
  - `$env/static/private` — 빌드 시 주입(서버만)
- **클라이언트 노출 허용(접두사 `PUBLIC_`)**  
  - `$env/dynamic/public` / `$env/static/public`

```ts
// src/lib/server/db.ts
import { env } from '$env/dynamic/private';
export const DB_URL = env.DB_URL; // 클라이언트에서 임포트 금지!
```

```ts
// src/lib/public.ts
import { PUBLIC_API_BASE } from '$env/static/public';
export const apiBase = PUBLIC_API_BASE;
```

> **규칙**: 클라이언트로 노출되는 변수는 반드시 `PUBLIC_` 접두사. 비밀/토큰은 **절대 클라이언트에 노출 금지**.

### 14.7.2 플랫폼별 비밀 주입

- **Vercel**: `vercel env` / 대시보드 → Edge/Functions 자동 주입  
- **Netlify**: Site settings → Environment variables  
- **Cloudflare**: `wrangler secret put` / `wrangler.toml` vars  
- **Node/Docker**: `.env` + 오케스트레이터(Secrets Manager/K8s Secret)

### 14.7.3 키 회전 & 구성 전략

- **버전 필드**를 토큰/세션에 포함 → 키 교체 기간 동안 **이중 검증** 가능  
- Feature Flag/환경 구분(`NODE_ENV`, `APP_ENV=staging|prod`)  
- **오류 메시지에 비밀 노출 금지**, 로깅 레드액션(redaction)

---

## 14.8 로그 수집 — 구조적 로깅 & 상관관계 ID

### 14.8.1 요청 로깅 훅

```ts
// src/hooks.server.ts
import type { Handle } from '@sveltejs/kit';
import { randomUUID } from 'crypto';

export const handle: Handle = async ({ event, resolve }) => {
  const rid = event.request.headers.get('x-request-id') || randomUUID();
  event.locals.rid = rid;

  const start = Date.now();
  let res;
  try {
    res = await resolve(event);
    return res;
  } finally {
    const ms = Date.now() - start;
    console.log(JSON.stringify({
      level: 'info',
      msg: 'request',
      rid,
      method: event.request.method,
      url: event.url.pathname,
      status: res?.status,
      ms
    }));
  }
};
```

> **구조적 JSON 로그**는 수집/검색/대시보드(ELK/Datadog/Cloud Logging)에서 **1급 자료**가 된다.

### 14.8.2 Pino(노드) / 콘솔(엣지)

```ts
// src/lib/server/logger.ts
import pino from 'pino';
export const logger = pino({ level: process.env.LOG_LEVEL ?? 'info' });
```

사용:

```ts
// 어떤 서버 라우트에서
import { logger } from '$lib/server/logger';
export const GET = async ({ locals }) => {
  logger.info({ rid: locals.rid, action: 'list-items' }, 'items fetch');
  return new Response('ok');
};
```

Cloudflare 등 Edge는 `console.log`가 가장 호환성이 좋다(개체는 JSON.stringify로).

### 14.8.3 민감 데이터 레드액션

```ts
logger.info({
  userId, // OK
  // 절대 기록 금지: access_token, password, card_number
}, 'login success');
```

---

## 14.9 오류 추적/성능 모니터링 — **Sentry** 통합

> 목표: **에러 스택/사용자 영향/성능 트레이스**를 한눈에 파악.

### 14.9.1 설치

```bash
pnpm add @sentry/sveltekit @sentry/tracing
```

### 14.9.2 서버 훅 통합

```ts
// src/hooks.server.ts
import * as Sentry from '@sentry/sveltekit';

Sentry.init({
  dsn: process.env.SENTRY_DSN,        // 비밀은 환경변수로
  tracesSampleRate: 0.2,              // 트레이싱 샘플링
  environment: process.env.APP_ENV || 'production',
  integrations: []
});

export const handleError = Sentry.handleErrorWithSentry();

export const handle = Sentry.sentryHandle();
```

> `handleError`를 등록하면 **Load/Action/엔드포인트**에서 throw된 에러가 Sentry에 전송된다.

### 14.9.3 클라이언트(브라우저) 통합

```ts
// src/hooks.client.ts
import * as Sentry from '@sentry/sveltekit';
Sentry.init({
  dsn: import.meta.env.VITE_SENTRY_DSN, // 또는 PUBLIC_ 접두사 변수
  tracesSampleRate: 0.1
});
```

> 브라우저에서 발생하는 **런타임 에러**와 **트레이스**(네비게이션/SPA 전환)를 수집한다.

### 14.9.4 사용자/릴리스/PII

```ts
// 로그인 성공 시
Sentry.setUser({ id: user.id, email: user.email }); // PII 동의/정책 고려
Sentry.setTag('plan', user.plan);
Sentry.setRelease(process.env.RELEASE || 'dev');
```

> **개인정보(PII)** 수집은 **정책/동의**가 선행되어야 한다. 기본은 최소화/익명화.

### 14.9.5 성능 트레이싱(핵심 구간 계측)

```ts
// src/routes/api/expensive/+server.ts
import * as Sentry from '@sentry/sveltekit';

export const GET = async () => {
  const span = Sentry.startInactiveSpan({ name: 'expensive.work', op: 'compute' });
  try {
    await expensiveWork();
    return new Response('ok');
  } catch (e) {
    Sentry.captureException(e);
    return new Response('error', { status: 500 });
  } finally {
    span.end();
  }
};
```

---

## 14.10 OpenTelemetry(선택) — 표준화된 추적/메트릭

> 벤더 중립 추적이 필요하면 OTel을 붙인다(수집 엔드포인트는 OTLP/HTTP 등). SvelteKit(Node)에서 서버 사이드 OTel SDK를 초기화하고, 백엔드/DB 클라이언트에 자동-계측을 추가할 수 있다. Edge 런타임은 제약이 많다.

개념 스니펫(요약):

```ts
// src/lib/server/otel.ts
import { NodeSDK } from '@opentelemetry/sdk-node';
import { HttpInstrumentation } from '@opentelemetry/instrumentation-http';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';

export function startOtel() {
  const sdk = new NodeSDK({
    instrumentations: [new HttpInstrumentation(), getNodeAutoInstrumentations()],
    // exporter 설정(OTLP 등)
  });
  sdk.start();
  return sdk;
}
```

서버 시작 시 한번 호출(어댑터-노드 환경).

---

## 14.11 운영 고려 — 업타임, 스케줄, 백그라운드, 파일

### 14.11.1 헬스 체크

```ts
// src/routes/healthz/+server.ts
export const GET = async () => {
  // DB ping 등 선택 수행
  return new Response('ok', { headers: { 'cache-control': 'no-store' } });
};
```

로드밸런서/K8s/Cloud 환경에 health 경로를 등록.

### 14.11.2 스케줄(크론)

- **Cloudflare**: wrangler `triggers.crons`  
- **Vercel**: Scheduled Functions  
- **Netlify**: Scheduled Functions  
- **Node**: cron(시스템) 또는 Bull/Cloud Tasks 등 큐 기반

```ts
// Cloudflare 예: wrangler.toml
[triggers]
crons = ["0 * * * *"]  # 매 정시
```

### 14.11.3 대용량 작업/레포트

- Edge/서버리스는 시간·메모리 한계 → **큐 + 워커**(Durable Object/Queues, Cloud Tasks, SQS 등)  
- 사용자 요청은 작업 **수락 후 비동기 처리**, 웹훅/폴링으로 결과 전달

### 14.11.4 파일 업로드/서명 URL

```ts
// src/routes/api/upload/url/+server.ts (S3 presign 예시 개념)
import { env } from '$env/dynamic/private';

export const GET = async ({ locals, url }) => {
  if (!locals.user) return new Response('unauthorized', { status: 401 });
  const object = url.searchParams.get('name') || `up/${crypto.randomUUID()}`;
  // presign(object, contentType…) 구현은 SDK/서명 로직 의존
  const signed = await presign(object);
  return new Response(JSON.stringify({ url: signed, object }), { headers: { 'content-type': 'application/json' } });
};
```

클라이언트는 해당 URL로 **직접 PUT** → 서버는 메타를 기록. 서버 메모리 부하 제거.

---

## 14.12 배포 파이프라인 (CI/CD) — GitHub Actions 예

### 14.12.1 공통 빌드 & 테스트

```yaml
name: ci
on: [push, pull_request]

jobs:
  test-build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v3
        with: { version: 9 }
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'pnpm' }
      - run: pnpm i --frozen-lockfile
      - run: pnpm typecheck && pnpm lint && pnpm test
      - run: pnpm build
```

### 14.12.2 Vercel 배포

```yaml
  vercel-deploy:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v3
        with: { version: 9 }
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'pnpm' }
      - run: pnpm i --frozen-lockfile
      - run: pnpm build
      - uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: .
          prod: true
```

### 14.12.3 Cloudflare Pages/Workers 배포

```yaml
  cf-deploy:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v3
        with: { version: 9 }
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'pnpm' }
      - run: pnpm i --frozen-lockfile
      - run: pnpm build
      - uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CF_API_TOKEN }}
          accountId: ${{ secrets.CF_ACCOUNT_ID }}
          command: publish
```

### 14.12.4 Netlify 배포

```yaml
  netlify-deploy:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v3
        with: { version: 9 }
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'pnpm' }
      - run: pnpm i --frozen-lockfile
      - run: pnpm build
      - run: npx netlify deploy --dir=build --prod --auth=${{ secrets.NETLIFY_AUTH_TOKEN }} --site=${{ secrets.NETLIFY_SITE_ID }}
```

### 14.12.5 Node(Docker) 배포

```yaml
  docker-push:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASS }}
      - uses: docker/build-push-action@v5
        with:
          push: true
          tags: myorg/myapp:latest
```

---

## 14.13 플랫폼별 체크리스트

### Node(어댑터-노드)
- [ ] **프로세스 관리자**(PM2/systemd), healthz, graceful shutdown  
- [ ] Docker/K8s → **리소스 제한/오토스케일**  
- [ ] **SSL/TLS**는 LB/프록시에서, 앱은 **HTTP 내부 포트**  
- [ ] **장기 커넥션**(DB/WebSocket) OK

### Vercel/Netlify(서버리스)
- [ ] **콜드스타트** 민감 로직 Edge로 이동/캐시  
- [ ] **DB 연결**: HTTP/데이터 프록시(PlanetScale HTTP, Prisma Accelerate, Neon HTTP)  
- [ ] **이미지 변환**은 플랫폼 이미지 서비스/백그라운드로  
- [ ] 스케줄 함수 필요 시 설정

### Cloudflare(Edge)
- [ ] Node API 금지 → Web 표준 API 사용  
- [ ] **KV/D1/R2/DO/Queues**로 상태/작업 분리  
- [ ] **Cache API** 적극 활용(HTML/Data 캐시)  
- [ ] 이미지/업로드는 **R2 + 서명 URL** 패턴

---

## 14.14 운영 플레이북(요약)

1) **Config as Code**: 어댑터/인프라 설정을 저장소에 버전 관리  
2) **Secrets**: 플랫폼 Secret Manager 사용, Rotating 전략  
3) **보안 헤더/CSP**: `hooks.server`에서 일괄 적용(9장 참조)  
4) **관측**:  
   - 구조적 로그(JSON), 상관관계 ID(`rid`)  
   - Sentry(에러/트레이스) + Web Vitals(RUM)  
   - 필요시 OTel로 벤더 중립 추적  
5) **성능**:  
   - Edge 캐시 + 정밀 무효화(SvelteKit `depends`/`invalidate`)  
   - 이미지/폰트 최적화(12장 체크리스트)  
6) **신뢰성**:  
   - 헬스 체크/프로브, 재시도/백오프, 레이트 리미팅  
   - 백그라운드 큐/스케줄 분리, 멱등성  
7) **비용**:  
   - 서버리스 호출/대역폭/스토리지 모니터링  
   - 로그 샘플링/트레이스 샘플링으로 비용 제어

---

## 14.15 예제: 다중 어댑터 모노레포 전략(선택)

**구조**

```
apps/
  web/            # sveltekit
  worker/         # cloudflare worker (이미지 썸네일, 웹훅)
  queue-worker/   # background jobs (Bull/Cloudflare Queues)
infra/
  terraform/      # DNS/CDN/스토리지/비밀
```

- **web**: Vercel로 배포, 동적 읽기 일부 Edge  
- **worker**: Cloudflare로 전세계 이미지 캐시/변환  
- **queue-worker**: Node 런타임(EC2/K8s)로 대용량 리포트  
- 공통 **Observability**: Sentry DSN 공유, Trace/Span 상관관계 헤더 전파

---

## 14.16 자주 만나는 문제 & 해결 가이드

- **서버리스에서 DB 연결 한계** → HTTP 데이터 레이어로 전환, read-heavy는 **캐시 레이어** 앞세우기  
- **요청 크기 제한**(서버리스) → 파일은 **직접 스토리지 업로드**, 서버는 **메타만**  
- **웹소켓 필요** → Node/서버 전용(또는 플랫폼 전용 WebSocket/DO)  
- **Edge에서 Node 전용 모듈 사용** → 라우트 분리(Edge/Serverless/Node)  
- **콜드스타트** → Edge/프리워밍/스케줄 ping/핫패스 캐시  
- **비밀 노출 위험** → `$env` 사용, PUBLIC_만 클라, 로깅 레드액션

---

## 14.17 마무리

- 배포는 **어댑터 선택**으로 시작해 **플랫폼 특성**에 맞는 **아키텍처 패턴**으로 완성된다.  
- 운영은 **가시성**이 전부다: **구조적 로그**, **Sentry/OTel**, **Web Vitals**를 바탕으로 **문제 재현성**과 **회귀 감시**를 확보하자.  
- **Edge + Serverless + Node**의 장단을 조합하면, 빠른 사용자 경험과 합리적 비용, 그리고 유지보수 가능한 코드를 동시에 달성할 수 있다.
