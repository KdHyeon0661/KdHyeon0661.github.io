---
layout: post
title: flask - 국제화(i18n) & 현지화(l10n)
date: 2025-09-21 14:25:23 +0900
category: flask
---
# 국제화(i18n) & 현지화(l10n)

## 개념 정리: i18n vs l10n vs t9n

- **i18n (Internationalization)**: 애플리케이션을 다국어/다문화 지원 가능하도록 **구조**를 마련하는 과정입니다. 문자열 추출, 날짜/숫자/통화 포맷, 복수형 규칙 등이 포함됩니다.
- **l10n (Localization)**: 특정 로케일(예: `ko_KR`, `en_US`)에 맞춘 **실제 번역, 형식, 이미지, 서식**을 적용하는 과정입니다.
- **t9n (Translation)**: 실제 **문자열 번역 작업**을 의미합니다.

**원칙**: **로케일**은 UI와 포맷의 규칙으로, **언어(language)** 와 **지역(country)** 이 합쳐진 형태입니다. 예를 들어 `pt_BR`, `zh_Hant_TW` 등이 있습니다.

---

## Flask-Babel 빠르게 시작

### 설치/초기화

```bash
pip install Flask-Babel Babel
```

```python
# app/extensions.py

from flask_babel import Babel

babel = Babel()

def init_babel(app):
    app.config.setdefault("BABEL_DEFAULT_LOCALE", "en")
    app.config.setdefault("BABEL_DEFAULT_TIMEZONE", "UTC")
    app.config.setdefault("BABEL_TRANSLATION_DIRECTORIES", "translations")
    babel.init_app(app)
```

```python
# app/__init__.py

from flask import Flask
from .extensions import init_babel

def create_app(config=None):
    app = Flask(__name__)
    app.config.update(
        BABEL_DEFAULT_LOCALE="en",
        BABEL_DEFAULT_TIMEZONE="Asia/Seoul",
        BABEL_TRANSLATION_DIRECTORIES="translations;more_translations",  # 다중 디렉토리도 가능(세미콜론 구분)
    )
    init_babel(app)
    return app
```

### 템플릿/파이썬에서 번역 호출

```python
# 파이썬

from flask_babel import gettext as _, ngettext, pgettext

greeting = _("Hello, %(name)s!", name=user.name)
count_msg = ngettext("%(num)d item", "%(num)d items", num, num=num)
ctx_msg   = pgettext("navbar", "Home")   # 같은 단어의 맥락 구분
```

{% raw %}
```jinja
{# Jinja2 템플릿 #}
<h1>{{ _("Welcome") }}</h1>
<p>{{ ngettext("%(num)d file", "%(num)d files", files|length, num=files|length) }}</p>
<p>{{ pgettext("sidebar", "Settings") }}</p>
```
{% endraw %}

**규칙**: 문자열 연결(f-string 포함)로 문장을 조립하지 말고 **완전한 문장으로 i18n 함수에 전달**해야 합니다. 변수는 **명명된 플레이스홀더**를 사용합니다(`%(name)s`).

---

## 로케일 결정 전략(우선순위 설계)

실무에서는 "**URL → 사용자 설정 → 헤더(Accept-Language) → 기본값**" 순으로 로케일을 결정하는 것을 권장합니다.

### URL 프리픽스 방식(`/<locale>/...`)

폴더 구조 & 블루프린트:

```
app/
├─ blueprints/
│  └─ site/
│     ├─ __init__.py
│     └─ views.py
└─ i18n/
   └─ routing.py
```

```python
# app/i18n/routing.py

from flask import g, request
from werkzeug.routing import BaseConverter

SUPPORTED_LOCALES = ("en", "ko", "ja")

class LocaleConverter(BaseConverter):
    regex = "|".join(SUPPORTED_LOCALES)

def register_locale_routing(app):
    app.url_map.converters["locale"] = LocaleConverter

    @app.url_defaults
    def add_language_code(endpoint, values):
        if "locale" in values or not g.get("current_locale"):
            return
        if app.url_map.is_endpoint_expecting(endpoint, "locale"):
            values["locale"] = g.current_locale

    @app.url_value_preprocessor
    def pull_locale(endpoint, values):
        if values is None:
            return
        locale = values.pop("locale", None)
        if locale in SUPPORTED_LOCALES:
            g.current_locale = locale
```

블루프린트 라우팅:

```python
# app/blueprints/site/__init__.py

from flask import Blueprint
site_bp = Blueprint("site", __name__)

# app/__init__.py 등록

app.register_blueprint(site_bp, url_prefix="/<locale>")
```

로케일 선택자:

```python
# app/extensions.py (Babel)

from flask import g, request
from flask_babel import Babel

babel = Babel()

@babel.localeselector
def select_locale():
    # 1) URL에서
    if g.get("current_locale"):
        return g.current_locale
    # 2) 사용자 설정(로그인 상태라면)
    try:
        from flask_login import current_user
        if getattr(current_user, "is_authenticated", False) and current_user.locale:
            return current_user.locale
    except Exception:
        pass
    # 3) 브라우저 Accept-Language
    return request.accept_languages.best_match(["en", "ko", "ja"], default="en")
```

**팁**:
- SEO/북마크 친화성: `/ko/…`, `/en/…` 로 콘텐츠를 고정합니다.
- 퍼머링크 유지: 언어 스위처가 `url_for(current_endpoint, **view_args, locale=new_locale)` 로 **경로를 유지**합니다.

언어 스위처 예시:

{% raw %}
```jinja
<nav class="lang-switcher">
  {% for lang in ("en","ko","ja") %}
    <a href="{{ url_for(request.endpoint, locale=lang, **request.view_args) }}">{{ lang }}</a>
  {% endfor %}
</nav>
```
{% endraw %}

### 헤더 기반(프리픽스 없이)

URL에 로케일을 넣지 않으려면 **Accept-Language** 협상을 기본으로 사용합니다:

```python
@babel.localeselector
def select_locale():
    from flask_login import current_user
    if getattr(current_user, "is_authenticated", False) and current_user.locale:
        return current_user.locale
    return request.accept_languages.best_match(["en", "ko", "ja"], default="en")
```

프론트엔드 SPA/모바일 클라이언트는 **사용자 설정 언어**를 API에 헤더로 보낼 수도 있습니다(예: `X-Locale: ko_KR`).

### 타임존 선택자

```python
from flask_babel import get_locale

@babel.timezoneselector
def select_tz():
    # 사용자 프로필 > 쿼리스트링 > 기본값
    tz = request.args.get("tz")
    if tz:
        return tz
    try:
        from flask_login import current_user
        if getattr(current_user, "is_authenticated", False) and current_user.timezone:
            return current_user.timezone
    except Exception:
        pass
    return "UTC"
```

---

## 문자열/날짜/숫자/통화 포맷

### 날짜/시간

```python
from datetime import datetime, timezone
from flask_babel import format_datetime, format_date, format_time

now = datetime.now(timezone.utc)
format_datetime(now)                   # 로케일/타임존 반영
format_date(now)                       # 2025. 10. 20. (ko_KR)
format_time(now)                       # 오후 2:31:05 (ko_KR)
format_datetime(now, "yyyy/MM/dd HH:mm")  # 커스텀 패턴(ICU)
```

Jinja:

{% raw %}
```jinja
<p>{{ format_datetime(order.placed_at, "yyyy년 M월 d일 (EEE) a h:mm") }}</p>
```
{% endraw %}

**ICU 패턴**을 사용합니다(파이썬 `strftime` 과 다릅니다). 날짜 로케일과 타임존은 `@timezoneselector`, `@localeselector` 결과를 따릅니다.

### 숫자/통화/퍼센트

```python
from flask_babel import format_decimal, format_currency, format_percent

format_decimal(12345.678)         # '12,345.678' (en), '12.345,678' (de)
format_currency(1299.9, "USD")    # '$1,299.90' (en_US)
format_currency(1299.9, "KRW")    # '₩1,300' (ko_KR)
format_percent(0.257)             # '25%' (ko_KR), '25%' (en)
```

Jinja:

{% raw %}
```jinja
가격: {{ format_currency(product.price, "USD") }}
```
{% endraw %}

### 복수형과 문맥(Context)

```python
from flask_babel import ngettext, pgettext, npgettext

ngettext("%(num)d apple", "%(num)d apples", num, num=num)
pgettext("menu", "Open")          # '열기' vs '영업중' 구분 가능(문맥)
npgettext("cart", "%(n)d item", "%(n)d items", n, n=n)
```

복수형 규칙은 **언어별로 다릅니다**. `.po` 헤더의 **Plural-Forms** 가 중요합니다(예: 러시아어는 3형).

### Lazy 번역(lazy_gettext)

폼/모델 정의 시 늦은 평가:

```python
from flask_babel import lazy_gettext as _l

label = _l("Email")
help_text = _l("Enter your email address.")
```

Lazy 문자열은 렌더 시점의 로케일을 사용합니다. DB에 저장할 문자열이라면 **명시적 로케일**을 함께 저장해야 합니다.

---

## 번역 도메인/카탈로그 구조

### 디렉터리 구조

```
translations/
├─ ko/
│  └─ LC_MESSAGES/
│     ├─ messages.po
│     ├─ messages.mo
│     ├─ emails.po
│     └─ emails.mo
├─ ja/
│  └─ LC_MESSAGES/...
└─ en/
   └─ LC_MESSAGES/...
```

- 기본 도메인: `messages`(Flask-Babel 기본값)
- 추가 도메인(예: `emails`, `errors`)을 나누어 관리 가능

### 도메인 사용

```python
from flask_babel import Domain

emails = Domain(domain="emails")  # translations/*/LC_MESSAGES/emails.po 사용

def send_welcome_mail(user):
    subject = emails.gettext("Welcome to %(site)s", site="Example")
    ...
```

Jinja에서 특정 도메인:

{% raw %}
```jinja
{% trans domain="emails" site="Example" %}Welcome to {{ site }}{% endtrans %}
```
{% endraw %}

---

## 문자열 추출/컴파일 워크플로우

### babel.cfg(추출 설정)

프로젝트 루트에 `babel.cfg`:

```
[python: **.py]
encoding = utf-8

[jinja2: **/templates/**.html]
extensions = jinja2.ext.do,jinja2.ext.loopcontrols
encoding = utf-8

# 추가: .txt/.md에서 추출하려면 커스텀 extractor 사용 가능
```

Flask-Babel은 Jinja의 {% raw %}`{% trans %}`{% endraw %} 블록, {% raw %}`{{ _("...") }}`{% endraw %} 호출도 추출합니다.

### 명령어

```bash
# 추출 → 템플릿(messages.pot)

pybabel extract -F babel.cfg -o messages.pot .

# 언어 초기화(최초 1회)

pybabel init -i messages.pot -d translations -l ko
pybabel init -i messages.pot -d translations -l ja

# 업데이트(문자열 변경 후)

pybabel update -i messages.pot -d translations

# 컴파일(.po → .mo, 런타임 사용)

pybabel compile -d translations
```

여러 도메인일 경우:

```bash
pybabel extract -F babel.cfg -o emails.pot --domain=emails .
pybabel init -i emails.pot -d translations -D emails -l ko
pybabel update -i emails.pot -d translations -D emails
pybabel compile -d translations -D emails
```

### .po 편집 요령

- 헤더의 `Plural-Forms` 확인(언어별 규칙 자동 생성됨)
- `#, fuzzy` 라벨은 **검토 필요**(자동 매칭 불확실)
- **HTML 포함 금지**: 번역 문자열에 `<b>` 등 넣지 말고 템플릿에서 감싸야 합니다.

Jinja 블록 예시:

{% raw %}
```jinja
{% trans here='<a href="%s">' ~ _("here") ~ '</a>'|safe %}Click {{ here }}{% endtrans %}
```
{% endraw %}

가능하면 **링크/태그도 placeholder로** 넘기고, 최종에서 `|safe` (신뢰된 값만) 사용합니다.

---

## URL/네비게이션 i18n 팁

### 라우트 이름/메뉴 i18n

라우트는 **영문 슬러그**로 고정하고, **표시 텍스트**만 번역합니다:

```python
# 올바른 예

@app.get("/pricing")
def pricing(): ...

# 안티패턴: /가격 (언어별 라우트는 SEO/중복/링크 관리 복잡)
```

메뉴:

{% raw %}
```jinja
<li><a href="{{ url_for('site.pricing') }}">{{ _("Pricing") }}</a></li>
```
{% endraw %}

### 로케일 유지한 url_for

앞서 `url_defaults` 로 `locale` 자동 주입을 구현했다면 다음이 가능합니다:

{% raw %}
```jinja
<a href="{{ url_for('site.home') }}">{{ _("Home") }}</a>
```
{% endraw %}

다른 언어로 전환할 때는 `url_for(request.endpoint, locale='ko', **request.view_args)`를 사용합니다.

---

## 언어 대응

아랍어(`ar`), 히브리어(`he`) 등 RTL 언어:

{% raw %}
```jinja
{% set dir = 'rtl' if get_locale().language in ('ar','he','fa','ur') else 'ltr' %}
<html lang="{{ get_locale() }}" dir="{{ dir }}">
```
{% endraw %}

CSS:

```css
[dir="rtl"] .ml-2 { margin-left: 0; margin-right: .5rem; }
/* 필요 시 RTL 전용 스타일 추가 */
```

아이콘/화살표/정렬 등도 **양방향성**을 고려해야 합니다.

---

## 서버/클라이언트 경계: JS 번역

Flask 템플릿 외에 **프론트엔드(JS)** 에 번역이 필요하면 두 가지 전략을 사용할 수 있습니다:

1. **서버 렌더링만**: 템플릿에서 번역된 문자열을 렌더 후 JS가 사용합니다.
2. **JS용 카탈로그 제공**: 현재 로케일의 문자열 딕셔너리 JSON을 제공합니다.

간단한 카탈로그 엔드포인트:

```python
# app/blueprints/i18n/api.py

from flask import Blueprint, jsonify
from flask_babel import gettext as _, get_locale

i18n_bp = Blueprint("i18n_api", __name__, url_prefix="/i18n")

@i18n_bp.get("/catalog")
def catalog():
    # 실제로는 자동 생성/추출된 키 목록을 제공하는 게 낫습니다.
    keys = ["OK", "Cancel", "Delete", "Search"]
    return jsonify({k: _(k) for k in keys, "locale": str(get_locale())})
```

규모가 커지면 프론트엔드 빌드 시스템(React i18next 등)과 **분리된 번역 파이프라인**을 마련하는 것이 좋습니다(서버/클라 카탈로그 별도).

---

## 이메일/문서 템플릿의 현지화

- HTML 이메일 템플릿도 **Jinja + Domain(`emails`)** 로 분리합니다.
- 날짜/통화/주소 **로케일 포맷**을 적용합니다(예: `format_date(order.date, format="long")`).
- 시각은 **수신자 시간대** 기준으로 변환합니다.

```python
# 이메일 도메인 사용 예

subject = emails.gettext("Reset your password")
body = render_template("emails/reset.html", user=user)
send_mail(user.email, subject, body)
```

---

## 번역 툴/CI 워크플로우

### 수동(개발자/번역가 협업)

1. 개발자가 문자열 변경 → PR
2. CI에서 `pybabel extract` 실행하여 `messages.pot` 갱신/아티팩트
3. 번역가는 `.po` 업데이트(POEdit/VSCode + i18n 플러그인)
4. `pybabel compile` → `.mo` 산출 → 배포

`Makefile` 예:

```make
I18N_DIR=translations
DOMAIN=messages
BABEL_CFG=babel.cfg

extract:
	pybabel extract -F $(BABEL_CFG) -o $(DOMAIN).pot .
update:
	pybabel update -i $(DOMAIN).pot -d $(I18N_DIR)
compile:
	pybabel compile -d $(I18N_DIR)
init-ko:
	pybabel init -i $(DOMAIN).pot -d $(I18N_DIR) -l ko
```

### 연동

- CI에서 `messages.pot` 업로드 → 번역 플랫폼에서 작업 → 완료 시 **자동 PR** 생성
- **용어집/스타일가이드** 유지(브랜드 용어 통일)
- **인증/개인정보 문자열** 특별 관리(오역 방지)

---

## 테스트 전략

### 로케일 선택 테스트

```python
def test_locale_from_url(client):
    r = client.get("/ko/")
    assert "lang=\"ko\"" in r.get_data(as_text=True)

def test_locale_from_accept_language(client):
    r = client.get("/", headers={"Accept-Language":"ja,en;q=0.8"})
    assert "lang=\"ja\"" in r.get_data(as_text=True)
```

### 포맷/복수형 테스트

```python
from flask_babel import force_locale

def test_plural(app):
    with app.app_context(), force_locale("en"):
        assert ngettext("%(n)d item","%(n)d items",1,n=1) == "1 item"
        assert ngettext("%(n)d item","%(n)d items",2,n=2) == "2 items"
```

`force_locale(locale)` 컨텍스트로 특정 로케일을 강제할 수 있습니다.

---

## 성능/캐시 관점

- `.mo`(바이너리) 로딩은 빠르지만, **프로세스 시작 후 캐시**됩니다.
- **대량 문자열 렌더** 페이지는 **partial caching(프래그먼트 캐시)** 를 고려합니다.
- **format_* 호출은 상대적으로 비용**이 있으므로, 리스트/테이블 대량 렌더 시 **사전 계산** 또는 **템플릿에서 최소화**합니다.

---

## 보안/UX 주의

- **언어 자동 전환**은 사용자 의도를 침해할 수 있으므로 **언어 선택 UI**를 제공하고 **쿠키/프로필**에 기억합니다.
- **피싱/스푸핑**: 다양한 스크립트(키릴/라틴 유사 문자) 혼용 위험. 민감 입력 UI에서 폰트/검증을 강화합니다.
- **유니코드 정규화**: 사용자 입력 비교 시 `unicodedata.normalize` 를 고려합니다.

---

## 미니 레퍼런스(붙여넣기)

### 필수 임포트

```python
from flask_babel import (
    gettext as _, ngettext, pgettext, npgettext,
    format_date, format_time, format_datetime,
    format_decimal, format_percent, format_currency,
    lazy_gettext as _l, get_locale
)
```

### URL 프리픽스 i18n 훅 요약

```python
@babel.localeselector
def select_locale():
    return g.get("current_locale") or request.accept_languages.best_match(["en","ko"], "en")

@app.url_value_preprocessor
def pull_locale(endpoint, values):
    g.current_locale = values.pop("locale", None) if values else None

@app.url_defaults
def add_lang_code(endpoint, values):
    if app.url_map.is_endpoint_expecting(endpoint, "locale") and "locale" not in values:
        values["locale"] = g.get("current_locale", "en")
```

---

## 흔한 안티패턴

- **f-string으로 조립된 문장 번역**: "Hello " + name + "!" → 번역 불가. 항상 **완전한 문장** + **명명 플레이스홀더** 사용.
- **HTML/마크업을 번역문에 직접 포함**: 유지보수/보안(XSS) 위험. 템플릿에서 분리.
- **언어별 라우트/파라미터 키 변경**: API/SEO/링크가 깨짐. 라우트는 고정.
- **Accept-Language만 의존**: 사용자가 바꿔도 고정되지 않음. **언어 스위처** 제공.
- **복수형 무시**: 영어 가정하고 단수/복수 처리하지 않음. `ngettext` 필수.
- **도메인 섞임**: `emails`/`messages` 를 혼용 → 카탈로그 충돌/누락.

---

## 종합 예제(요약 스캐폴딩)

```
app/
├─ __init__.py
├─ extensions.py
├─ i18n/
│  └─ routing.py
├─ blueprints/
│  └─ site/
│     ├─ __init__.py
│     └─ views.py
└─ templates/
   └─ home.html
```

```python
# app/__init__.py

from flask import Flask
from .extensions import babel, init_babel
from .i18n.routing import register_locale_routing
from .blueprints.site import site_bp

def create_app():
    app = Flask(__name__)
    app.config.update(
        BABEL_DEFAULT_LOCALE="en",
        BABEL_DEFAULT_TIMEZONE="UTC",
        BABEL_TRANSLATION_DIRECTORIES="translations",
    )
    register_locale_routing(app)
    init_babel(app)
    app.register_blueprint(site_bp, url_prefix="/<locale>")
    return app
```

```python
# app/blueprints/site/__init__.py

from flask import Blueprint, render_template
from flask_babel import gettext as _, format_datetime
from datetime import datetime

site_bp = Blueprint("site", __name__)

@site_bp.get("/")
def home():
    title = _("Welcome")
    now = format_datetime(datetime.utcnow())
    return render_template("home.html", title=title, now=now)
```

{% raw %}
```html
<!-- templates/home.html -->
<!doctype html>
<html lang="{{ get_locale() }}">
  <head><meta charset="utf-8"><title>{{ title }}</title></head>
  <body>
    <h1>{{ title }}</h1>
    <p>{{ _("Current time: %(now)s", now=now) }}</p>
    <nav>
      <a href="{{ url_for(request.endpoint, locale='en', **request.view_args) }}">English</a> |
      <a href="{{ url_for(request.endpoint, locale='ko', **request.view_args) }}">한국어</a>
    </nav>
  </body>
</html>
```
{% endraw %}

번역 추출/컴파일:

```bash
pybabel extract -F babel.cfg -o messages.pot .
pybabel init -i messages.pot -d translations -l ko
# translations/ko/LC_MESSAGES/messages.po 번역 후

pybabel compile -d translations
```

---

## 결론

이번 섹션에서는 Flask 애플리케이션에 국제화(i18n)와 현지화(l10n)를 적용하는 포괄적인 방법을 다루었습니다. Flask-Babel을 활용한 기본 설정부터 시작하여, 로케일 결정 전략, 문자열과 날짜/숫자/통화 포맷팅, 번역 도메인 관리, 그리고 실제 프로젝트에서의 워크플로우까지 다양한 측면을 살펴보았습니다.

국제화는 단순한 문자열 번역을 넘어 문화적 차이, 언어별 규칙, 사용자 경험까지 고려해야 하는 복잡한 작업입니다. URL 프리픽스를 통한 로케일 관리, ICU 포맷을 활용한 문화별 표현, 복수형 규칙 처리 등은 글로벌 서비스를 구축하는 데 필수적인 요소들입니다.

실제 프로젝트에서는 초기부터 국제화를 고려한 구조를 설계하는 것이 중요합니다. 문자열 분리, 템플릿 구조, 번역 워크플로우를 체계적으로 구축해야 나중에 추가 언어 지원이 용이해집니다. 또한 번역의 품질을 유지하기 위해 용어집과 스타일 가이드를 관리하고, CI/CD 파이프라인에 번역 프로세스를 통합하는 것이 좋습니다.

국제화된 애플리케이션은 더 넓은 사용자 기반을 확보하고, 글로벌 시장에서의 경쟁력을 높일 수 있습니다. Flask와 Flask-Babel은 이러한 요구사항을 충족시키기 위한 견고한 기반을 제공하며, 이 가이드에서 소개한 패턴과 모범 사례들을 적용하면 효과적인 다국어 애플리케이션을 구축할 수 있을 것입니다.