---
layout: post
title: flask - 국제화(i18n) & 현지화(l10n)
date: 2025-09-21 14:25:23 +0900
category: flask
---
# 12. 국제화(i18n) & 현지화(l10n)

> 이 장은 **Flask-Babel로 문자열/날짜/숫자 국제화**, **URL/헤더/사용자설정 기반 로케일 결정 전략**, **번역 워크플로우(po/mo 관리, 도메인 분리, CI 연동)** 를 **운영 실전** 관점에서 정리한다.

---

## 12.1 개념 정리: i18n vs l10n vs t9n

- **i18n (Internationalization)**: 앱을 다국어/다문화 지원 가능하도록 **구조**를 마련(문자열 추출, 날짜/숫자/통화 포맷, 플러럴 규칙 등).
- **l10n (Localization)**: 특정 로케일(예: `ko_KR`, `en_US`)에 맞춘 **실제 번역/형식/이미지/서식** 적용.
- **t9n (Translation)**: 실제 **문자열 번역 작업**.

> 원칙: **로케일은 UI·포맷의 규칙**이며, **언어(language)** 와 **지역(country)** 이 합쳐진다. 예) `pt_BR`, `zh_Hant_TW`.

---

## 12.2 Flask-Babel 빠르게 시작

### 12.2.1 설치/초기화

```bash
pip install Flask-Babel Babel
```

```python
# app/extensions.py
from flask_babel import Babel

babel = Babel()

def init_babel(app):
    app.config.setdefault("BABEL_DEFAULT_LOCALE", "en")
    app.config.setdefault("BABEL_DEFAULT_TIMEZONE", "UTC")
    app.config.setdefault("BABEL_TRANSLATION_DIRECTORIES", "translations")
    babel.init_app(app)
```

```python
# app/__init__.py
from flask import Flask
from .extensions import init_babel

def create_app(config=None):
    app = Flask(__name__)
    app.config.update(
        BABEL_DEFAULT_LOCALE="en",
        BABEL_DEFAULT_TIMEZONE="Asia/Seoul",
        BABEL_TRANSLATION_DIRECTORIES="translations;more_translations",  # 다중 디렉토리도 가능(세미콜론 구분)
    )
    init_babel(app)
    return app
```

### 12.2.2 템플릿/파이썬에서 번역 호출

```python
# 파이썬
from flask_babel import gettext as _, ngettext, pgettext

greeting = _("Hello, %(name)s!", name=user.name)
count_msg = ngettext("%(num)d item", "%(num)d items", num, num=num)
ctx_msg   = pgettext("navbar", "Home")   # 같은 단어의 맥락 구분
```

{% raw %}
```jinja
{# Jinja2 템플릿 #}
<h1>{{ _("Welcome") }}</h1>
<p>{{ ngettext("%(num)d file", "%(num)d files", files|length, num=files|length) }}</p>
<p>{{ pgettext("sidebar", "Settings") }}</p>
```
{% endraw %}

> **규칙**: 문자열 연결(f-string 포함)로 문장을 조립하지 말고 **완전한 문장으로 i18n 함수에 전달**하라. 변수는 **명명된 플레이스홀더** 사용(`%(name)s`).

---

## 12.3 로케일 결정 전략(우선순위 설계)

실무에서는 “**URL → 사용자 설정 → 헤더(Accept-Language) → 기본값**” 순으로 결정하는 것을 권장한다.

### 12.3.1 URL 프리픽스 방식(`/<locale>/...`)

폴더 구조 & 블루프린트:

```
app/
├─ blueprints/
│  └─ site/
│     ├─ __init__.py
│     └─ views.py
└─ i18n/
   └─ routing.py
```

```python
# app/i18n/routing.py
from flask import g, request
from werkzeug.routing import BaseConverter

SUPPORTED_LOCALES = ("en", "ko", "ja")

class LocaleConverter(BaseConverter):
    regex = "|".join(SUPPORTED_LOCALES)

def register_locale_routing(app):
    app.url_map.converters["locale"] = LocaleConverter

    @app.url_defaults
    def add_language_code(endpoint, values):
        if "locale" in values or not g.get("current_locale"):
            return
        if app.url_map.is_endpoint_expecting(endpoint, "locale"):
            values["locale"] = g.current_locale

    @app.url_value_preprocessor
    def pull_locale(endpoint, values):
        if values is None:
            return
        locale = values.pop("locale", None)
        if locale in SUPPORTED_LOCALES:
            g.current_locale = locale
```

블루프린트 라우팅:

```python
# app/blueprints/site/__init__.py
from flask import Blueprint
site_bp = Blueprint("site", __name__)

# app/__init__.py 등록
app.register_blueprint(site_bp, url_prefix="/<locale>")
```

로케일 선택자:

```python
# app/extensions.py (Babel)
from flask import g, request
from flask_babel import Babel

babel = Babel()

@babel.localeselector
def select_locale():
    # 1) URL에서
    if g.get("current_locale"):
        return g.current_locale
    # 2) 사용자 설정(로그인 상태라면)
    try:
        from flask_login import current_user
        if getattr(current_user, "is_authenticated", False) and current_user.locale:
            return current_user.locale
    except Exception:
        pass
    # 3) 브라우저 Accept-Language
    return request.accept_languages.best_match(["en", "ko", "ja"], default="en")
```

> **Tip**  
> - SEO/북마크 친화성: `/ko/…`, `/en/…` 로 콘텐츠 고정.  
> - 퍼머링크 유지: 언어 스위처가 `url_for(current_endpoint, **view_args, locale=new_locale)` 로 **경로 유지**.

언어 스위처 예시:

{% raw %}
```jinja
<nav class="lang-switcher">
  {% for lang in ("en","ko","ja") %}
    <a href="{{ url_for(request.endpoint, locale=lang, **request.view_args) }}">{{ lang }}</a>
  {% endfor %}
</nav>
```
{% endraw %}

### 12.3.2 헤더 기반(프리픽스 없이)

URL에 로케일을 넣지 않으려면 **Accept-Language** 협상을 기본으로:

```python
@babel.localeselector
def select_locale():
    from flask_login import current_user
    if getattr(current_user, "is_authenticated", False) and current_user.locale:
        return current_user.locale
    return request.accept_languages.best_match(["en", "ko", "ja"], default="en")
```

> 프론트엔드 SPA/모바일 클라이언트는 **사용자 설정 언어**를 API에 헤더로 보낼 수도 있다(예: `X-Locale: ko_KR`).

### 12.3.3 타임존 선택자

```python
from flask_babel import get_locale

@babel.timezoneselector
def select_tz():
    # 사용자 프로필 > 쿼리스트링 > 기본값
    tz = request.args.get("tz")
    if tz:
        return tz
    try:
        from flask_login import current_user
        if getattr(current_user, "is_authenticated", False) and current_user.timezone:
            return current_user.timezone
    except Exception:
        pass
    return "UTC"
```

---

## 12.4 문자열/날짜/숫자/통화 포맷

### 12.4.1 날짜/시간

```python
from datetime import datetime, timezone
from flask_babel import format_datetime, format_date, format_time

now = datetime.now(timezone.utc)
format_datetime(now)                   # 로케일/타임존 반영
format_date(now)                       # 2025. 10. 20. (ko_KR)
format_time(now)                       # 오후 2:31:05 (ko_KR)
format_datetime(now, "yyyy/MM/dd HH:mm")  # 커스텀 패턴(ICU)
```

Jinja:

{% raw %}
```jinja
<p>{{ format_datetime(order.placed_at, "yyyy년 M월 d일 (EEE) a h:mm") }}</p>
```
{% endraw %}

> **ICU 패턴**을 사용(파이썬 `strftime` 과 다름). 날짜 로케일/타임존은 `@timezoneselector`, `@localeselector` 결과를 따른다.

### 12.4.2 숫자/통화/퍼센트

```python
from flask_babel import format_decimal, format_currency, format_percent

format_decimal(12345.678)         # '12,345.678' (en), '12.345,678' (de)
format_currency(1299.9, "USD")    # '$1,299.90' (en_US)
format_currency(1299.9, "KRW")    # '₩1,300' (ko_KR)
format_percent(0.257)             # '25%' (ko_KR), '25%' (en)
```

Jinja:

{% raw %}
```jinja
가격: {{ format_currency(product.price, "USD") }}
```
{% endraw %}

### 12.4.3 복수형(Plural) & 문맥(Context)

```python
from flask_babel import ngettext, pgettext, npgettext

ngettext("%(num)d apple", "%(num)d apples", num, num=num)
pgettext("menu", "Open")          # '열기' vs '영업중' 구분 가능(문맥)
npgettext("cart", "%(n)d item", "%(n)d items", n, n=n)
```

> 복수 규칙은 **언어별로 다르다**. `.po` 헤더의 **Plural-Forms** 가 중요(예: 러시아어는 3형).

### 12.4.4 Lazy 번역(lazy_gettext)

폼/모델 정의 시 늦은 평가:

```python
from flask_babel import lazy_gettext as _l

label = _l("Email")
help_text = _l("Enter your email address.")
```

> Lazy 문자열은 렌더 시점의 로케일을 사용한다. DB에 저장할 문자열이라면 **명시적 로케일**을 함께 저장할 것.

---

## 12.5 번역 도메인/카탈로그 구조

### 12.5.1 디렉터리

```
translations/
├─ ko/
│  └─ LC_MESSAGES/
│     ├─ messages.po
│     ├─ messages.mo
│     ├─ emails.po
│     └─ emails.mo
├─ ja/
│  └─ LC_MESSAGES/...
└─ en/
   └─ LC_MESSAGES/...
```

- 기본 도메인: `messages`(Flask-Babel 기본값)
- 추가 도메인(예: `emails`, `errors`)을 나눠 관리 가능

### 12.5.2 도메인 사용

```python
from flask_babel import Domain

emails = Domain(domain="emails")  # translations/*/LC_MESSAGES/emails.po 사용

def send_welcome_mail(user):
    subject = emails.gettext("Welcome to %(site)s", site="Example")
    ...
```

Jinja에서 특정 도메인:

{% raw %}
```jinja
{% trans domain="emails" site="Example" %}Welcome to {{ site }}{% endtrans %}
```
{% endraw %}

---

## 12.6 문자열 추출/컴파일 워크플로우

### 12.6.1 babel.cfg(추출 설정)

프로젝트 루트에 `babel.cfg`:

```
[python: **.py]
encoding = utf-8

[jinja2: **/templates/**.html]
extensions = jinja2.ext.do,jinja2.ext.loopcontrols
encoding = utf-8

# 추가: .txt/.md에서 추출하려면 커스텀 extractor 사용 가능
```

> Flask-Babel은 Jinja의 `{% trans %}` 블록, `{{ _("...") }}` 호출도 추출한다.

### 12.6.2 명령

```bash
# 1) 추출 → 템플릿(messages.pot)
pybabel extract -F babel.cfg -o messages.pot .

# 2) 언어 초기화(최초 1회)
pybabel init -i messages.pot -d translations -l ko
pybabel init -i messages.pot -d translations -l ja

# 3) 업데이트(문자열 변경 후)
pybabel update -i messages.pot -d translations

# 4) 컴파일(.po → .mo, 런타임 사용)
pybabel compile -d translations
```

여러 도메인일 경우:

```bash
pybabel extract -F babel.cfg -o emails.pot --domain=emails .
pybabel init -i emails.pot -d translations -D emails -l ko
pybabel update -i emails.pot -d translations -D emails
pybabel compile -d translations -D emails
```

### 12.6.3 .po 편집 요령

- 헤더의 `Plural-Forms` 확인(언어별 규칙 자동 생성됨)
- `#, fuzzy` 라벨은 **검토 필요**(자동 매칭 불확실)
- **HTML 포함 금지**: 번역 문자열에 `<b>` 등 넣지 말고 템플릿에서 감싸라.  
  예) `_("Click %(here)s", here="<a>...</a>")` 대신, 템플릿에서 `trans` 블록으로 안전하게 처리.

Jinja 블록 예시:

{% raw %}
```jinja
{% trans here='<a href="%s">' ~ _("here") ~ '</a>'|safe %}Click {{ here }}{% endtrans %}
```
{% endraw %}

> 가능하면 **링크/태그도 placeholder로** 넘기고, 최종에서 `|safe` (신뢰된 값만) 사용.

---

## 12.7 URL/네비게이션 i18n 팁

### 12.7.1 라우트 이름/메뉴 i18n

라우트는 **영문 슬러그** 고정, **표시 텍스트**만 번역:

```python
# 올바른 예
@app.get("/pricing")
def pricing(): ...

# 안티패턴: /가격 (언어별 라우트는 SEO/중복/링크 관리 복잡)
```

메뉴:

{% raw %}
```jinja
<li><a href="{{ url_for('site.pricing') }}">{{ _("Pricing") }}</a></li>
```
{% endraw %}

### 12.7.2 로케일 유지한 url_for

앞서 `url_defaults` 로 `locale` 자동 주입을 구현했다면 다음이 가능:

{% raw %}
```jinja
<a href="{{ url_for('site.home') }}">{{ _("Home") }}</a>
```
{% endraw %}

> 다른 언어로 전환할 때는 `url_for(request.endpoint, locale='ko', **request.view_args)`.

---

## 12.8 RTL(우→좌) 언어 대응

아랍어(`ar`), 히브리어(`he`) 등 RTL 언어:

{% raw %}
```jinja
{% set dir = 'rtl' if get_locale().language in ('ar','he','fa','ur') else 'ltr' %}
<html lang="{{ get_locale() }}" dir="{{ dir }}">
```
{% endraw %}

CSS:

```css
[dir="rtl"] .ml-2 { margin-left: 0; margin-right: .5rem; }
/* 필요 시 RTL 전용 스타일 추가 */
```

아이콘/화살표/정렬 등도 **양방향성** 고려.

---

## 12.9 서버/클라이언트 경계: JS 번역

Flask 템플릿 외에 **프론트(JS)** 에 번역이 필요하면 2가지 전략:

1) **서버 렌더링만**: 템플릿에서 번역된 문자열을 렌더 후 JS가 사용.
2) **JS용 카탈로그 제공**: 현재 로케일의 문자열 딕셔너리 JSON 제공.

간단한 카탈로그 엔드포인트:

```python
# app/blueprints/i18n/api.py
from flask import Blueprint, jsonify
from flask_babel import gettext as _, get_locale

i18n_bp = Blueprint("i18n_api", __name__, url_prefix="/i18n")

@i18n_bp.get("/catalog")
def catalog():
    # 실제로는 자동 생성/추출된 키 목록을 제공하는 게 낫다.
    keys = ["OK", "Cancel", "Delete", "Search"]
    return jsonify({k: _(k) for k in keys, "locale": str(get_locale())})
```

> 규모가 커지면 프론트엔드 빌드 시스템(React i18next 등)과 **분리된 번역 파이프라인**을 마련(서버/클라 카탈로그 별도).

---

## 12.10 이메일/문서 템플릿의 현지화

- HTML 이메일 템플릿도 **Jinja + Domain(`emails`)** 로 분리.
- 날짜/통화/주소 **로케일 포맷** 적용(예: `format_date(order.date, format="long")`).
- 시각은 **수신자 시간대** 기준으로 변환.

```python
# 이메일 도메인 사용 예
subject = emails.gettext("Reset your password")
body = render_template("emails/reset.html", user=user)
send_mail(user.email, subject, body)
```

---

## 12.11 번역 툴/CI 워크플로우

### 12.11.1 수동(개발자/번역가 협업)

1) 개발자가 문자열 변경 → PR  
2) CI에서 `pybabel extract` 실행하여 `messages.pot` 갱신/아티팩트  
3) 번역가는 `.po` 업데이트(POEdit/VSCode + i18n 플러그인)  
4) `pybabel compile` → `.mo` 산출 → 배포

`Makefile` 예:

```make
I18N_DIR=translations
DOMAIN=messages
BABEL_CFG=babel.cfg

extract:
	pybabel extract -F $(BABEL_CFG) -o $(DOMAIN).pot .
update:
	pybabel update -i $(DOMAIN).pot -d $(I18N_DIR)
compile:
	pybabel compile -d $(I18N_DIR)
init-ko:
	pybabel init -i $(DOMAIN).pot -d $(I18N_DIR) -l ko
```

### 12.11.2 TMS(Transifex/Weblate/Crowdin) 연동

- CI에서 `messages.pot` 업로드 → 번역 플랫폼에서 작업 → 완료 시 **자동 PR** 생성
- **용어집/스타일가이드** 유지(브랜드 용어 통일)
- **인증/개인정보 문자열** 특별 관리(오역 방지)

---

## 12.12 테스트 전략

### 12.12.1 로케일 선택 테스트

```python
def test_locale_from_url(client):
    r = client.get("/ko/")
    assert "lang=\"ko\"" in r.get_data(as_text=True)

def test_locale_from_accept_language(client):
    r = client.get("/", headers={"Accept-Language":"ja,en;q=0.8"})
    assert "lang=\"ja\"" in r.get_data(as_text=True)
```

### 12.12.2 포맷/플러럴 테스트

```python
from flask_babel import force_locale

def test_plural(app):
    with app.app_context(), force_locale("en"):
        assert ngettext("%(n)d item","%(n)d items",1,n=1) == "1 item"
        assert ngettext("%(n)d item","%(n)d items",2,n=2) == "2 items"
```

> `force_locale(locale)` 컨텍스트로 특정 로케일 강제.

---

## 12.13 성능/캐시 관점

- `.mo`(바이너리) 로딩은 빠르지만, **프로세스 시작 후 캐시**됨.  
- **대량 문자열 렌더** 페이지는 **partial caching(프래그먼트 캐시)** 고려.  
- **format_* 호출은 상대적으로 비용**이 있으므로, 리스트/테이블 대량 렌더 시 **사전 계산** 또는 **템플릿에서 최소화**.

---

## 12.14 보안/UX 주의

- **언어 자동 전환**은 사용자 의도를 침해할 수 있음 → **언어 선택 UI** 제공 & **쿠키/프로필**에 기억.  
- **피싱/스푸핑**: 다양한 스크립트(키릴/라틴 유사 문자) 혼용 위험. 민감 입력 UI에서 폰트/검증 강화.  
- **유니코드 정규화**: 사용자 입력 비교 시 `unicodedata.normalize` 고려.

---

## 12.15 미니 레퍼런스(붙여넣기)

### 12.15.1 필수 임포트

```python
from flask_babel import (
    gettext as _, ngettext, pgettext, npgettext,
    format_date, format_time, format_datetime,
    format_decimal, format_percent, format_currency,
    lazy_gettext as _l, get_locale
)
```

### 12.15.2 Jinja 필터/글로벌(자동 등록)

{% raw %}
```python
# Flask-Babel 초기화 시 기본 필터 제공:
# {{ gettext('...') }} == {{ _('...') }}
# {{ format_datetime(dt) }} 등
```
{% endraw %}

### 12.15.3 URL 프리픽스 i18n 훅 요약

```python
@babel.localeselector
def select_locale():
    return g.get("current_locale") or request.accept_languages.best_match(["en","ko"], "en")

@app.url_value_preprocessor
def pull_locale(endpoint, values):
    g.current_locale = values.pop("locale", None) if values else None

@app.url_defaults
def add_lang_code(endpoint, values):
    if app.url_map.is_endpoint_expecting(endpoint, "locale") and "locale" not in values:
        values["locale"] = g.get("current_locale", "en")
```

---

## 12.16 흔한 안티패턴

- **f-string으로 조립된 문장 번역**: “Hello " + name + "!” → 번역 불가. 항상 **완전한 문장** + **명명 플레이스홀더**.  
- **HTML/마크업을 번역문에 직접 포함**: 유지보수/보안(XSS) 위험. 템플릿에서 분리.  
- **언어별 라우트/파라미터 키 변경**: API/SEO/링크가 깨짐. 라우트는 고정.  
- **Accept-Language만 의존**: 사용자가 바꿔도 고정되지 않음. **언어 스위처** 제공.  
- **복수형 무시**: 영어 가정하고 단수/복수 처리하지 않음. `ngettext` 필수.  
- **도메인 섞임**: `emails`/`messages` 를 혼용 → 카탈로그 충돌/누락.

---

## 12.17 종합 예제(요약 스캐폴딩)

```
app/
├─ __init__.py
├─ extensions.py
├─ i18n/
│  └─ routing.py
├─ blueprints/
│  └─ site/
│     ├─ __init__.py
│     └─ views.py
└─ templates/
   └─ home.html
```

```python
# app/__init__.py
from flask import Flask
from .extensions import babel, init_babel
from .i18n.routing import register_locale_routing
from .blueprints.site import site_bp

def create_app():
    app = Flask(__name__)
    app.config.update(
        BABEL_DEFAULT_LOCALE="en",
        BABEL_DEFAULT_TIMEZONE="UTC",
        BABEL_TRANSLATION_DIRECTORIES="translations",
    )
    register_locale_routing(app)
    init_babel(app)
    app.register_blueprint(site_bp, url_prefix="/<locale>")
    return app
```

```python
# app/blueprints/site/__init__.py
from flask import Blueprint, render_template
from flask_babel import gettext as _, format_datetime
from datetime import datetime

site_bp = Blueprint("site", __name__)

@site_bp.get("/")
def home():
    title = _("Welcome")
    now = format_datetime(datetime.utcnow())
    return render_template("home.html", title=title, now=now)
```

{% raw %}
```html
<!-- templates/home.html -->
<!doctype html>
<html lang="{{ get_locale() }}">
  <head><meta charset="utf-8"><title>{{ title }}</title></head>
  <body>
    <h1>{{ title }}</h1>
    <p>{{ _("Current time: %(now)s", now=now) }}</p>
    <nav>
      <a href="{{ url_for(request.endpoint, locale='en', **request.view_args) }}">English</a> |
      <a href="{{ url_for(request.endpoint, locale='ko', **request.view_args) }}">한국어</a>
    </nav>
  </body>
</html>
```
{% endraw %}

번역 추출/컴파일:

```bash
pybabel extract -F babel.cfg -o messages.pot .
pybabel init -i messages.pot -d translations -l ko
# translations/ko/LC_MESSAGES/messages.po 번역 후
pybabel compile -d translations
```