---
layout: post
title: DB - 그룹 함수 (2)
date: 2025-03-14 20:20:23 +0900
category: DB
---
# SQL 고급 집계(Part 2) — ROLLUP/CUBE/GROUPING SETS, GROUPING_ID, PIVOT/UNPIVOT, 퍼센타일/순위형 집계 패턴, 성능·정확성

- **ROLLUP / CUBE / GROUPING SETS / GROUPING / GROUPING_ID**
- **PIVOT / UNPIVOT** (행↔열 변환)
- **Ordered-Set Aggregates**(퍼센타일 등)과 **집계 + 윈도**의 혼합
- **DBMS별 차이(Oracle / SQL Server / PostgreSQL / MySQL)**
- **정확성(총계/소계 라벨링, NULL/미정 분류)** + **성능(통계·인덱스·물질화·증분 집계)**

---

## 공통 샘플 스키마

우리는 다음과 같은 **판매 데이터**를 예제로 사용한다.

```sql
CREATE TABLE Sales (
  sale_id        BIGINT PRIMARY KEY,
  sale_date      DATE,
  region         VARCHAR(20),     -- 'APAC' | 'EMEA' | 'AMER' ...
  country        VARCHAR(40),
  channel        VARCHAR(20),     -- 'ONLINE' | 'OFFLINE'
  category       VARCHAR(40),     -- 'ELECTRONICS' | 'FASHION' ...
  product_id     VARCHAR(50),
  qty            INT,
  amount         DECIMAL(18,2)    -- 통화는 단순화
);

-- 샘플 데이터(요약)
INSERT INTO Sales (sale_id, sale_date, region, country, channel, category, product_id, qty, amount) VALUES
(1, DATE '2025-01-05', 'APAC', 'Korea', 'ONLINE',  'ELECTRONICS', 'P-100', 2,  700.00),
(2, DATE '2025-01-07', 'APAC', 'Japan', 'OFFLINE', 'FASHION',     'P-210', 1,  120.00),
(3, DATE '2025-01-08', 'EMEA', 'Germany','ONLINE', 'ELECTRONICS', 'P-100', 1,  350.00),
(4, DATE '2025-01-09', 'AMER', 'USA',    'ONLINE', 'FASHION',     'P-220', 3,  450.00),
(5, DATE '2025-01-10', 'APAC', 'Korea',  'OFFLINE','ELECTRONICS', 'P-130', 5, 1750.00);
```

> 실제 환경에선 **날짜 차원**(연/월/일), **지역 차원**(지역/국가), **상품 차원**, **판매 채널** 등 **다차원 분석**이 요구된다. 고급 집계는 이 “다차원”을 한 번에 요약하는 데 특화돼 있다.

---

## ROLLUP — 계층형 소계와 총계를 한 번에

### 개념

`ROLLUP(a, b, c)`는 **(a,b,c) → (a,b) → (a) → ()** 순서로 **소계 → 상위 소계 → 총계**를 자동 생성한다.

### 기본 예제 (PostgreSQL/Oracle/SQL Server)

```sql
SELECT
  region,
  country,
  channel,
  SUM(amount) AS sales
FROM Sales
GROUP BY ROLLUP (region, country, channel)
ORDER BY region, country, channel;
```

**나오는 행의 의미**
- (region, country, channel) = 상세
- (region, country, NULL)   = 국가별 소계
- (region, NULL,   NULL)    = 지역별 소계
- (NULL,   NULL,   NULL)    = 총계

### 라벨링: GROUPING / GROUPING_ID

**ROLLUP 행**은 NULL이 나올 수 있어 “진짜 NULL(값 없음)”과 “소계/총계 NULL(요약 행)”을 구분해야 한다.
이를 위해 DBMS는 **`GROUPING(expr)` 또는 `GROUPING_ID(...)`**를 제공한다.

```sql
-- Oracle / SQL Server / PostgreSQL (이름은 동일)
SELECT
  CASE WHEN GROUPING(region)  = 1 THEN 'ALL-REGIONS'  ELSE region  END AS region_label,
  CASE WHEN GROUPING(country) = 1 THEN 'ALL-COUNTRIES' ELSE country END AS country_label,
  CASE WHEN GROUPING(channel) = 1 THEN 'ALL-CHANNELS' ELSE channel END AS channel_label,
  SUM(amount) AS sales
FROM Sales
GROUP BY ROLLUP (region, country, channel)
ORDER BY GROUPING(region), GROUPING(country), GROUPING(channel), region, country, channel;
```

- `GROUPING(expr) = 1`이면 **그 컬럼은 요약으로 인해 “집계됨”**(즉, 소계/총계 레벨)이라는 뜻.
- `GROUPING_ID(a,b,...)`는 **비트 플래그**를 반환하여 여러 컬럼의 집계 여부를 한 번에 판별한다.

```sql
-- 레벨에 따라 'LEVEL' 라벨링
SELECT
  region, country, channel,
  GROUPING_ID(region, country, channel) AS gid,  -- (예) channel만 집계: 1, country만: 2, region만: 4 ...
  CASE GROUPING_ID(region, country, channel)
    WHEN 0 THEN 'DETAIL'
    WHEN 1 THEN 'SUBTOTAL: (region,country)'
    WHEN 3 THEN 'SUBTOTAL: (region)'
    WHEN 7 THEN 'GRAND TOTAL'
    ELSE 'OTHER'
  END AS level_label,
  SUM(amount) AS sales
FROM Sales
GROUP BY ROLLUP (region, country, channel)
ORDER BY gid, region, country, channel;
```

> **주의**: `GROUPING_ID`의 비트 순서는 DBMS마다 셈의 방향이 다를 수 있으므로(좌→우/우→좌), 문서나 실험으로 확인하라.

---

## CUBE — 모든 조합의 총합(부분합) 생성

### 개념

`CUBE(a,b,c)`는 **a/b/c의 모든 조합**(8개 조합)으로 요약 행을 생성한다.
즉, **차원 축을 모두 큐브 형태로 확장**한 것.

### 예제

```sql
SELECT
  region, country, channel,
  SUM(amount) AS sales
FROM Sales
GROUP BY CUBE (region, country, channel)
ORDER BY region, country, channel;
```

**장점**: 다차원 분석(예: “지역만”, “국가만”, “채널만”, “지역+채널” 등)을 **한 번의 쿼리**로 추출.
**단점**: 조합 수가 **2^N**으로 늘어 **행 수 폭발** → **N이 큰 경우 ROLLUP/GROUPING SETS로 필요한 조합만** 선택하라.

---

## GROUPING SETS — 필요한 요약 조합만 골라서

### 개념

`GROUPING SETS`는 원하는 **그룹 조합을 명시**한다. “필요한 소계만” 만들 때 최고 유연성.

### 예제

```sql
SELECT
  region, country, channel,
  SUM(amount) AS sales
FROM Sales
GROUP BY GROUPING SETS (
  (region, country, channel),   -- 상세
  (region, channel),            -- 지역×채널 소계
  (region),                     -- 지역 소계
  ()                            -- 총계
)
ORDER BY region, country, channel;
```

> **읽을거리**: `ROLLUP(region,country,channel)`은 사실 `GROUPING SETS((region,country,channel),(region,country),(region),())`와 동치다.
> `CUBE(a,b)`는 `GROUPING SETS((a,b),(a),(b),())`와 동치.

---

## ROLLUP/CUBE/GS + HAVING/WHERE, NULL, “미정(UNKNOWN)” 전략

- **WHERE**는 **그룹 형성 전** 필터, **HAVING**은 **그룹 형성 후** 필터.
- 요약 행을 유지하면서 **값 없는 카테고리**를 “미정”으로 묶고 싶다면 **사전 정규화**가 최선. 그렇지 않으면 **라벨링**으로 대체.

```sql
-- NULL을 'UNKNOWN'으로 라벨링하되, GROUPING과 혼동되지 않도록 별도 표시
SELECT
  CASE WHEN GROUPING(region)  = 1 THEN 'ALL-REGIONS'
       WHEN region  IS NULL   THEN 'UNKNOWN-REGION'
       ELSE region END AS region_label,
  CASE WHEN GROUPING(country) = 1 THEN 'ALL-COUNTRIES'
       WHEN country IS NULL   THEN 'UNKNOWN-COUNTRY'
       ELSE country END AS country_label,
  SUM(amount) AS sales
FROM Sales
WHERE sale_date >= DATE '2025-01-01'   -- 행 필터(집계 전)
GROUP BY ROLLUP (region, country)
HAVING SUM(amount) > 0                  -- 그룹 필터(집계 후)
ORDER BY GROUPING(region), region_label, country_label;
```

---

## 소계/총계 라인 정렬 & 라벨 출력 베스트 패턴

**요약 라인을 아래쪽**으로 보내려면 `ORDER BY GROUPING(...)`을 활용한다.

```sql
SELECT
  region,
  country,
  SUM(amount) AS sales
FROM Sales
GROUP BY ROLLUP(region, country)
ORDER BY GROUPING(region), region, GROUPING(country), country;
```

- `GROUPING(region)=0`(상세/하위) → 먼저
- `GROUPING(region)=1`(총계) → 나중

**라벨형 합계 행**만 따로 보고 싶을 때:

```sql
SELECT 'GRAND TOTAL' AS region, '' AS country, SUM(amount) AS sales
FROM Sales
UNION ALL
SELECT region, 'SUBTOTAL', SUM(amount)
FROM Sales
GROUP BY region
UNION ALL
SELECT region, country, SUM(amount)
FROM Sales
GROUP BY region, country
ORDER BY region, country;
```

> 이 방식은 **표준성**이 좋지만, `GROUPING()` 기반 라벨링이 더 간결하고 안전하다.

---

## 백분율/기여도 계산 — **총계 대비 비율**을 ROLLUP과 결합

“**지역별 매출**과 **전사 대비 %**”를 한 결과셋에서 구하고 싶다면 **자체 조인** 또는 **윈도**를 결합한다.

### 윈도 결합(권장)

```sql
WITH base AS (
  SELECT region, country, SUM(amount) AS sales
  FROM Sales
  GROUP BY ROLLUP(region, country)
)
SELECT
  region, country, sales,
  100.0 * sales / NULLIF(SUM(sales) OVER (PARTITION BY region), 0)   AS pct_in_region,
  100.0 * sales / NULLIF(SUM(sales) OVER (), 0)                      AS pct_in_total
FROM base
ORDER BY GROUPING(region), region, GROUPING(country), country;
```

- `SUM(sales) OVER()` = 전체 총계
- `SUM(sales) OVER (PARTITION BY region)` = 지역 총계
- **주의**: 분모 0 방지 `NULLIF`.

---

## PIVOT — 행→열 변환으로 열 방향 요약

### 개념

**카테고리 값(예: 채널/카테고리/월)**을 **열 헤더**로 **회전**하여 보기 좋게 만든다.

> **DBMS 지원**
> - Oracle: `PIVOT` 구문 제공
> - SQL Server: `PIVOT` 구문 제공
> - PostgreSQL/MySQL: **직접 `PIVOT` 없음** → **조건부 집계(CASE WHEN)** 또는 **crosstab 확장(PSQL)** 사용

### Oracle / SQL Server의 PIVOT 예제

“지역×채널 매출”을 **채널이 열로** 오도록 피벗.

```sql
-- Oracle / SQL Server (구문 배리에이션 있음)
SELECT *
FROM (
  SELECT region, channel, amount
  FROM Sales
) s
PIVOT (
  SUM(amount) FOR channel IN ('ONLINE' AS ONLINE, 'OFFLINE' AS OFFLINE)
) p
ORDER BY region;
```

> **장점**: 간결하고, 컬럼명 라벨링 용이.
> **단점**: **열 목록이 고정**(동적 채널/카테고리의 경우 **다이내믹 SQL** 필요).

### PostgreSQL / MySQL의 PIVOT 대체(조건부 집계)

```sql
SELECT
  region,
  SUM(CASE WHEN channel = 'ONLINE'  THEN amount ELSE 0 END) AS online_sales,
  SUM(CASE WHEN channel = 'OFFLINE' THEN amount ELSE 0 END) AS offline_sales
FROM Sales
GROUP BY region
ORDER BY region;
```

> **실무 팁**: 대시보드에서 **열이 가변**이면 DB에서 피벗하지 말고 **애플리케이션/BI 툴에서 열 전개**를 맡기는 게 유지보수에 유리하다.

---

## UNPIVOT — 열→행 변환(정규화 복원)

### 개념

열에 흩어진 메트릭을 **행으로 녹여** “긴(long)” 형태로 만든다.

### Oracle / SQL Server의 UNPIVOT

```sql
-- 예: 월별 컬럼을 행으로 변환 (Jan, Feb, Mar ... 가 열)
SELECT region, month_name, amount
FROM SalesMonthly
UNPIVOT (
  amount FOR month_name IN (jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec)
) u;
```

### PostgreSQL / MySQL 대체: UNION ALL

```sql
SELECT region, 'jan' AS month_name, jan AS amount FROM SalesMonthly
UNION ALL
SELECT region, 'feb', feb FROM SalesMonthly
UNION ALL
SELECT region, 'mar', mar FROM SalesMonthly;
-- ... 필요 월만 이어서
```

---

## PIVOT + 소계/총계 — **피벗 결과에 총계 열/행** 붙이기

피벗 결과에 **행 합계/열 합계**를 추가하려면 **두 단계**가 안전하다.

```sql
-- 1) 지역×채널 피벗
WITH base AS (
  SELECT
    region,
    SUM(CASE WHEN channel = 'ONLINE'  THEN amount ELSE 0 END) AS online_sales,
    SUM(CASE WHEN channel = 'OFFLINE' THEN amount ELSE 0 END) AS offline_sales
  FROM Sales
  GROUP BY region
)
-- 2) 행 합계/총계 행 추가
SELECT
  region,
  online_sales,
  offline_sales,
  (online_sales + offline_sales) AS region_total
FROM base

UNION ALL

SELECT
  'ALL-REGIONS',
  SUM(online_sales),
  SUM(offline_sales),
  SUM(online_sales + offline_sales)
FROM base

ORDER BY CASE WHEN region = 'ALL-REGIONS' THEN 1 ELSE 0 END, region;
```

> **열 합계(컬럼 총계)**는 BI/리포팅 레이어에서 포맷팅하는 편이 더 단순할 때가 많다.

---

## Ordered-Set Aggregates & 백분위수 with GROUPING SETS

**퍼센타일**과 **부분합**을 한 번에 보고 싶다?
`GROUPING SETS`와 `PERCENTILE_CONT`(지원 DBMS)를 결합한다.

```sql
-- Oracle / PostgreSQL / SQL Server
SELECT
  region,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS p50,
  PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY amount) AS p90
FROM Sales
GROUP BY GROUPING SETS ((region), ());
```

- `()` 집합은 **전사 퍼센타일**.
- **주문별 amount 분포**가 넓은 서비스에서 강력.

> MySQL은 `PERCENTILE_CONT` 미지원 → **윈도 함수**로 근사(행수 기반 백분위) 또는 **사전 집계**로 해결.

---

## 윈도 함수 vs ROLLUP/CUBE — “축소 여부”와 “라벨/총계”

- **윈도**는 “축소 없이” **각 행 옆에 지표**를 붙임.
- **ROLLUP/CUBE/GS**는 **그룹당 1행**으로 **축소**하여 **소계/총계 행**을 만든다.
- 복잡 리포트에서는 **둘을 혼합**한다.

```sql
-- 예: 상세행 + 부서 평균 + 전사 평균 + ROLLUP 총계까지 하나의 리포트로
WITH d AS (
  SELECT region, country, channel, amount
  FROM Sales
),
roll AS (
  SELECT region, country, channel, SUM(amount) AS sales
  FROM d
  GROUP BY ROLLUP(region, country, channel)
),
win AS (
  SELECT
    region, country, channel, amount,
    AVG(amount) OVER (PARTITION BY region) AS avg_region,
    AVG(amount) OVER ()                    AS avg_total
  FROM d
)
SELECT * FROM roll
UNION ALL
SELECT
  region, country, channel, SUM(amount) AS sales
FROM win
GROUP BY region, country, channel
ORDER BY region NULLS LAST, country NULLS LAST, channel NULLS LAST;
```

> 실제로는 **두 블록을 따로 출력**(상단 요약, 하단 상세)하는 편이 가독성 좋다.

---

## DBMS별 차이(요약)

| 기능 | Oracle | SQL Server | PostgreSQL | MySQL |
|---|---|---|---|---|
| ROLLUP/CUBE/GS | 지원 | 지원 | 지원 | 8.0+에서 `WITH ROLLUP`(구식 변형), 표준 `GROUPING SETS` 미지원 |
| GROUPING/GROUPING_ID | 지원 | 지원 | 지원 | 제한/없음 |
| PIVOT/UNPIVOT | 지원 | 지원 | 기본 미지원(확장/CASE WHEN) | 기본 미지원(조건부 집계) |
| `PERCENTILE_CONT/DISC` | 지원 | 지원 | 지원 | 미지원(윈도/앱/사전계산) |

> **MySQL**: `GROUP BY WITH ROLLUP`은 **간단한 총계** 정도만 지원. 복합 다차원은 **조건부 집계** + **UNION ALL** + **앱 피벗** 전략을 쓰자.

---

## 성능·운영 전략

1) **차원 수 조절**: `CUBE`는 2^N 행으로 폭증. **정말 필요한 조합만** `GROUPING SETS`로 선택.
2) **선필터**: `WHERE`로 기간/범위를 줄여 **입력 행 수**를 줄여라.
3) **인덱스/파티션**: 차원 키, 날짜 키에 **파티션/인덱스**. 파티션 프루닝으로 I/O 절감.
4) **통계 최신화**: 옵티마이저가 해시/정렬 집계를 적절히 고르도록 **통계 갱신**.
5) **물질화된 뷰/요약 테이블**: 일/주/월 요약을 **증분 갱신**. ROLLUP/CUBE 결과를 정기 스냅샷으로 캐싱.
6) **동적 PIVOT**: 열 목록이 변하면 DB 단에서 **동적 SQL** 또는 **애플리케이션 피벗**이 관리상 유리.
7) **NULL/라벨링 규칙 통일**: `GROUPING()` 기반 라벨로 **총계/소계/미정**을 구분, 리포트 해석 오류 방지.

---

## 수학적 뒷받침 — 다차원 합의 보수성

다차원 합계에서 **총계는 부분합의 합**과 일치해야 한다.
$$
\sum_{\text{region}} \sum_{\text{channel}} \text{Sales}(\text{region},\text{channel})
= \sum_{\text{region}} \text{Sales}(\text{region})
= \sum_{\text{channel}} \text{Sales}(\text{channel})
= \text{Sales}(\text{total})
$$
데이터 모델에서 **중복 카운트(중복 조인)**가 있으면 위 보수성이 무너진다. **정규화/키 제약/중복 제거**를 먼저 확인하라.

---

## 실전 시나리오 총모음

### 월×지역×채널 다차원 요약(필요 조합만)

```sql
-- 월(YYYY-MM) 단위로 압축 + 필요한 조합만
WITH fact AS (
  SELECT
    TO_CHAR(sale_date, 'YYYY-MM') AS ym,
    region, channel, amount
  FROM Sales
  WHERE sale_date >= DATE '2025-01-01'
)
SELECT
  ym, region, channel,
  SUM(amount) AS sales
FROM fact
GROUP BY GROUPING SETS (
  (ym, region, channel),  -- 상세
  (ym, region),           -- 월×지역 소계
  (ym),                   -- 월 총계
  ()                      -- 전체 총계
)
ORDER BY ym NULLS LAST, region NULLS LAST, channel NULLS LAST;
```

### ROLLUP + 퍼센타일(전사/지역별)

```sql
-- 지원 DB (Oracle/PG/SQLServer)
WITH fact AS (
  SELECT region, amount FROM Sales WHERE amount IS NOT NULL
)
SELECT
  region,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS p50,
  PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY amount) AS p90
FROM fact
GROUP BY GROUPING SETS ((region), ());
```

### PIVOT + 행 합계 + 전사 총계

```sql
-- CASE WHEN 기반(모든 DB 호환)
WITH region_pivot AS (
  SELECT
    region,
    SUM(CASE WHEN channel='ONLINE'  THEN amount ELSE 0 END) AS online_sales,
    SUM(CASE WHEN channel='OFFLINE' THEN amount ELSE 0 END) AS offline_sales
  FROM Sales
  GROUP BY region
)
SELECT
  region,
  online_sales,
  offline_sales,
  (online_sales + offline_sales) AS region_total
FROM region_pivot
UNION ALL
SELECT
  'ALL-REGIONS',
  SUM(online_sales),
  SUM(offline_sales),
  SUM(online_sales + offline_sales)
FROM region_pivot
ORDER BY CASE WHEN region = 'ALL-REGIONS' THEN 1 ELSE 0 END, region;
```

### ROLLUP 라벨링 + 퍼센트 표시

```sql
WITH roll AS (
  SELECT region, country, SUM(amount) AS sales
  FROM Sales
  GROUP BY ROLLUP(region, country)
),
aug AS (
  SELECT
    region, country, sales,
    SUM(sales) OVER ()                           AS total_sales,
    SUM(sales) OVER (PARTITION BY region)        AS region_total
  FROM roll
)
SELECT
  CASE WHEN GROUPING(region) = 1 THEN 'ALL-REGIONS'
       WHEN region IS NULL THEN 'UNKNOWN'
       ELSE region END AS region_label,
  CASE WHEN GROUPING(country) = 1 THEN 'ALL-COUNTRIES'
       WHEN country IS NULL THEN 'UNKNOWN'
       ELSE country END AS country_label,
  sales,
  ROUND(100.0 * sales / NULLIF(region_total, 0), 2) AS pct_in_region,
  ROUND(100.0 * sales / NULLIF(total_sales, 0), 2)  AS pct_in_total
FROM aug
ORDER BY GROUPING(region), region_label, GROUPING(country), country_label;
```

---

## 정확성 체크리스트(리포트 QA)

- [ ] **GROUPING 라벨**: 총계/소계를 오해 없이 표기하는가?
- [ ] **NULL vs UNKNOWN**: 실제 Null과 집계 Null을 분리했는가?
- [ ] **보수성**: 부분합의 합 = 총계가 보장되는가? (중복 조인 없음)
- [ ] **분모 0 방지**: 퍼센트 계산에 `NULLIF(...,0)` 적용했는가?
- [ ] **시간대/월 경계**: 월 집계는 **UTC/로컬** 기준을 문서화했는가?
- [ ] **동적 열**: 피벗 열 목록 변경 시 전략(동적 SQL/앱)을 갖췄는가?
- [ ] **성능**: CUBE 남용 금지, 필요한 조합만 `GROUPING SETS`로. 통계/인덱스 최신화.

---

## 마무리

- **ROLLUP/CUBE/GROUPING SETS**는 **다차원 요약**을 한번에 만들고,
- **GROUPING/GROUPING_ID**로 **총계/소계 라벨링**을 정확히 할 수 있다.
- **PIVOT/UNPIVOT**은 **보기 좋은 테이블**로 바꿔주되, “동적 열” 이슈를 항상 염두에 둔다.
- 대규모 환경에서는 **사전 필터/증분 요약/물질화/인덱스/통계**가 성능의 핵심이다.
- Part 1의 **기본 집계/윈도**와 Part 2의 **다차원/피벗**을 함께 쓰면 **거의 모든 집계 리포트**를 데이터베이스 단에서 정확하고 빠르게 구현할 수 있다.
