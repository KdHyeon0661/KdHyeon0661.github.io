---
layout: post
title: DB - 그룹 함수 (2)
date: 2025-03-14 20:20:23 +0900
category: DB
---
# SQL 고급 집계 기법: ROLLUP, CUBE, GROUPING SETS, PIVOT, UNPIVOT

## 개요: 다차원 분석을 위한 고급 집계

현대 비즈니스 인텔리전스에서는 단순한 합계나 평균 이상의 복잡한 데이터 분석이 필요합니다. 다양한 차원(지역, 시간, 제품 카테고리 등)에서 데이터를 요약하고, 부분 합계와 총계를 동시에 확인하며, 데이터를 가로세로로 변환하여 가독성을 높이는 작업이 필수적입니다. SQL은 이러한 요구를 충족시키기 위해 여러 고급 집계 기능을 제공합니다.

주요 고급 집계 기능:
- **ROLLUP / CUBE / GROUPING SETS**: 다양한 수준의 부분 합계와 총계를 생성
- **GROUPING / GROUPING_ID**: 합계 행을 식별하고 라벨링
- **PIVOT / UNPIVOT**: 데이터를 행과 열 간에 변환
- **Ordered-Set Aggregates**: 백분위수 같은 통계적 측정값 계산

이러한 기능들은 다차원 데이터 분석, 재무 보고서 생성, 경영 대시보드 구축 등에 필수적입니다.

---

## 예제 데이터 구조

실습을 위한 기본 데이터 구조를 정의합니다:

```sql
-- 판매 데이터 테이블 생성
CREATE TABLE Sales (
  sale_id        BIGINT PRIMARY KEY,
  sale_date      DATE,
  region         VARCHAR(20),     -- 'APAC', 'EMEA', 'AMER' 등
  country        VARCHAR(40),
  channel        VARCHAR(20),     -- 'ONLINE', 'OFFLINE'
  category       VARCHAR(40),     -- 'ELECTRONICS', 'FASHION' 등
  product_id     VARCHAR(50),
  qty            INT,
  amount         DECIMAL(18,2)
);

-- 샘플 데이터 삽입
INSERT INTO Sales VALUES
(1, '2025-01-05', 'APAC', 'Korea', 'ONLINE', 'ELECTRONICS', 'P-100', 2, 700.00),
(2, '2025-01-07', 'APAC', 'Japan', 'OFFLINE', 'FASHION', 'P-210', 1, 120.00),
(3, '2025-01-08', 'EMEA', 'Germany', 'ONLINE', 'ELECTRONICS', 'P-100', 1, 350.00),
(4, '2025-01-09', 'AMER', 'USA', 'ONLINE', 'FASHION', 'P-220', 3, 450.00),
(5, '2025-01-10', 'APAC', 'Korea', 'OFFLINE', 'ELECTRONICS', 'P-130', 5, 1750.00);
```

---

## ROLLUP: 계층적 소계와 총계

### ROLLUP의 개념
ROLLUP은 계층적 데이터 구조에서 부분 합계와 총계를 생성합니다. 지정된 컬럼 순서에 따라 상세 수준에서 총계 수준까지 단계적으로 합계를 계산합니다.

### 기본 사용법
```sql
-- 지역, 국가, 채널별 매출과 부분 합계, 총계
SELECT
  region,
  country,
  channel,
  SUM(amount) AS sales
FROM Sales
GROUP BY ROLLUP (region, country, channel)
ORDER BY region, country, channel;
```

이 쿼리는 다음과 같은 결과를 생성합니다:
- (region, country, channel): 상세 수준 데이터
- (region, country, NULL): 국가별 소계
- (region, NULL, NULL): 지역별 소계  
- (NULL, NULL, NULL): 전체 총계

### 합계 행 식별하기: GROUPING 함수
ROLLUP으로 생성된 NULL 값(합계 행)과 실제 NULL 데이터를 구분하기 위해 GROUPING 함수를 사용합니다.

```sql
SELECT
  CASE 
    WHEN GROUPING(region) = 1 THEN '전체 지역'
    ELSE COALESCE(region, '알 수 없음')
  END AS region_label,
  CASE 
    WHEN GROUPING(country) = 1 THEN '전체 국가'
    ELSE COALESCE(country, '알 수 없음')
  END AS country_label,
  CASE 
    WHEN GROUPING(channel) = 1 THEN '전체 채널'
    ELSE COALESCE(channel, '알 수 없음')
  END AS channel_label,
  SUM(amount) AS sales
FROM Sales
GROUP BY ROLLUP (region, country, channel)
ORDER BY GROUPING(region), region, GROUPING(country), country, GROUPING(channel), channel;
```

GROUPING 함수는 해당 컬럼이 합계 계산으로 인해 NULL로 처리되었으면 1, 그렇지 않으면 0을 반환합니다.

---

## CUBE: 모든 조합의 부분 합계

### CUBE의 개념
CUBE는 지정된 모든 컬럼 조합에 대한 부분 합계를 생성합니다. ROLLUP이 계층적 합계를 생성하는 반면, CUBE는 모든 가능한 조합에 대한 합계를 생성합니다.

### 기본 사용법
```sql
-- 지역, 채널의 모든 조합에 대한 매출 합계
SELECT
  region,
  channel,
  SUM(amount) AS sales
FROM Sales
GROUP BY CUBE (region, channel)
ORDER BY region, channel;
```

이 쿼리는 다음 조합들에 대한 합계를 생성합니다:
- (region, channel): 지역과 채널별 상세
- (region, NULL): 지역별 합계
- (NULL, channel): 채널별 합계
- (NULL, NULL): 전체 합계

CUBE는 분석 가능성이 많지만, 컬럼 수가 증가하면 생성되는 조합 수가 기하급수적으로 늘어나므로 신중하게 사용해야 합니다.

---

## GROUPING SETS: 필요한 합계 조합만 지정

### GROUPING SETS의 개념
GROUPING SETS는 사용자가 원하는 특정 합계 조합만을 생성할 수 있게 해줍니다. ROLLUP이나 CUBE보다 더 세밀한 제어가 가능합니다.

### 기본 사용법
```sql
-- 필요한 합계 조합만 지정
SELECT
  region,
  country,
  channel,
  SUM(amount) AS sales
FROM Sales
GROUP BY GROUPING SETS (
  (region, country, channel),  -- 상세 수준
  (region, channel),           -- 지역과 채널 조합
  (region),                    -- 지역별
  ()                           -- 전체 합계
)
ORDER BY region, country, channel;
```

GROUPING SETS를 사용하면 불필요한 합계 조합을 생성하지 않고 정확히 필요한 분석만 수행할 수 있습니다.

---

## PIVOT: 행을 열로 변환

### PIVOT의 개념
PIVOT은 행 데이터를 열로 변환하여 보다 읽기 쉬운 형식으로 표시합니다. 주로 카테고리 값이 열 헤더가 되어야 하는 보고서에 사용됩니다.

### SQL Server와 Oracle의 PIVOT 구문
```sql
-- SQL Server: 채널별 매출을 열로 피벗
SELECT *
FROM (
  SELECT region, channel, amount
  FROM Sales
) AS SourceTable
PIVOT (
  SUM(amount)
  FOR channel IN ([ONLINE], [OFFLINE])
) AS PivotTable;

-- Oracle: 채널별 매출을 열로 피벗
SELECT *
FROM (
  SELECT region, channel, amount
  FROM Sales
)
PIVOT (
  SUM(amount)
  FOR channel IN ('ONLINE' AS ONLINE, 'OFFLINE' AS OFFLINE)
);
```

### PostgreSQL과 MySQL의 대체 방법
PIVOT 구문을 직접 지원하지 않는 데이터베이스에서는 조건부 집계를 사용합니다:

```sql
-- 조건부 집계를 통한 PIVOT 구현
SELECT
  region,
  SUM(CASE WHEN channel = 'ONLINE' THEN amount ELSE 0 END) AS online_sales,
  SUM(CASE WHEN channel = 'OFFLINE' THEN amount ELSE 0 END) AS offline_sales,
  SUM(CASE WHEN channel = 'ONLINE' THEN amount ELSE 0 END) +
  SUM(CASE WHEN channel = 'OFFLINE' THEN amount ELSE 0 END) AS total_sales
FROM Sales
GROUP BY region
ORDER BY region;
```

### 동적 PIVOT의 도전 과제
열 헤더가 동적으로 변해야 하는 경우(예: 월별 데이터에서 새로운 월이 추가될 때마다 열이 증가하는 경우)는 추가적인 처리가 필요합니다. 일반적으로 두 가지 접근 방식이 있습니다:

1. **동적 SQL**: 런타임에 SQL 문을 생성하고 실행
2. **애플리케이션 레벨 처리**: 데이터베이스에서는 긴 형식으로 데이터를 가져온 후 애플리케이션에서 피벗

---

## UNPIVOT: 열을 행으로 변환

### UNPIVOT의 개념
UNPIVOT은 PIVOT의 반대 작업으로, 열 데이터를 행으로 변환합니다. 정규화되지 않은 테이블 구조를 정규화하거나, 다른 분석 도구에 적합한 형식으로 데이터를 변환할 때 유용합니다.

### SQL Server와 Oracle의 UNPIVOT 구문
```sql
-- SQL Server: 월별 컬럼을 행으로 변환
SELECT region, month, sales
FROM MonthlySales
UNPIVOT (
  sales FOR month IN (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)
) AS UnpivotTable;

-- Oracle: 월별 컬럼을 행으로 변환
SELECT region, month, sales
FROM MonthlySales
UNPIVOT (
  sales FOR month IN (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)
);
```

### PostgreSQL과 MySQL의 대체 방법
```sql
-- UNION ALL을 사용한 UNPIVOT 구현
SELECT region, 'Jan' AS month, Jan AS sales FROM MonthlySales
UNION ALL
SELECT region, 'Feb' AS month, Feb AS sales FROM MonthlySales
UNION ALL
SELECT region, 'Mar' AS month, Mar AS sales FROM MonthlySales
-- ... 나머지 월에 대해 반복
ORDER BY region, month;
```

---

## 백분위수 계산과 통계적 집계

### 백분위수 함수
일부 데이터베이스는 백분위수 계산을 위한 전용 함수를 제공합니다:

```sql
-- PostgreSQL, SQL Server, Oracle: 중앙값(50번째 백분위수)과 90번째 백분위수 계산
SELECT
  region,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median_amount,
  PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY amount) AS p90_amount
FROM Sales
GROUP BY region;
```

### MySQL의 대체 방법
MySQL은 백분위수 함수를 직접 지원하지 않으므로 윈도우 함수를 사용하여 계산할 수 있습니다:

```sql
-- MySQL: 윈도우 함수를 사용한 백분위수 근사 계산
WITH RankedData AS (
  SELECT
    region,
    amount,
    ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount) AS row_num,
    COUNT(*) OVER (PARTITION BY region) AS total_count
  FROM Sales
)
SELECT
  region,
  MAX(CASE WHEN row_num = CEIL(total_count * 0.5) THEN amount END) AS approx_median,
  MAX(CASE WHEN row_num = CEIL(total_count * 0.9) THEN amount END) AS approx_p90
FROM RankedData
GROUP BY region;
```

---

## 데이터베이스별 지원 현황

각 데이터베이스 관리 시스템은 고급 집계 기능을 다르게 지원합니다:

| 기능 | PostgreSQL | SQL Server | Oracle | MySQL |
|------|------------|------------|--------|-------|
| **ROLLUP/CUBE** | 지원 | 지원 | 지원 | 8.0+ 지원 |
| **GROUPING SETS** | 지원 | 지원 | 지원 | 8.0+ 지원 |
| **GROUPING()** | 지원 | 지원 | 지원 | 제한적 지원 |
| **PIVOT/UNPIVOT** | 확장 기능으로 제공 | 지원 | 지원 | 미지원 |
| **백분위수 함수** | 지원 | 지원 | 지원 | 미지원 |

MySQL 8.0 이전 버전을 사용하는 경우, 많은 고급 기능을 조건부 집계와 UNION ALL을 조합하여 구현해야 합니다.

---

## 성능 최적화 전략

고급 집계 쿼리는 대용량 데이터에서 성능 문제를 일으킬 수 있습니다. 다음 전략을 통해 성능을 최적화할 수 있습니다:

### 1. 데이터 필터링 최적화
```sql
-- 비효율적: 모든 데이터 집계 후 필터링
SELECT region, SUM(amount)
FROM Sales
GROUP BY region
HAVING SUM(amount) > 1000;

-- 효율적: 집계 전에 데이터 필터링
SELECT region, SUM(amount)
FROM Sales
WHERE sale_date >= '2025-01-01'  -- 가능한 한 빨리 데이터 양 줄이기
GROUP BY region
HAVING SUM(amount) > 1000;
```

### 2. 인덱스 활용
집계에 자주 사용되는 컬럼에 인덱스를 생성합니다:
```sql
-- 지역과 날짜로 자주 집계하는 경우
CREATE INDEX idx_sales_region_date ON Sales(region, sale_date);

-- 채널과 카테고리로 자주 집계하는 경우
CREATE INDEX idx_sales_channel_category ON Sales(channel, category);
```

### 3. 파티셔닝
대용량 테이블의 경우 파티셔닝을 고려합니다:
```sql
-- 월별 파티셔닝된 테이블
CREATE TABLE Sales (
  sale_id BIGINT,
  sale_date DATE,
  amount DECIMAL(18,2)
) PARTITION BY RANGE (sale_date);

-- 특정 월의 데이터만 접근 (파티션 프루닝)
SELECT * FROM Sales 
WHERE sale_date BETWEEN '2025-01-01' AND '2025-01-31';
```

### 4. 물질화된 뷰
빈번하게 실행되는 복잡한 집계 쿼리의 경우 물질화된 뷰를 사용합니다:
```sql
-- PostgreSQL: 일일 매출 요약 물질화된 뷰
CREATE MATERIALIZED VIEW daily_sales_summary AS
SELECT 
  sale_date,
  region,
  channel,
  SUM(amount) AS total_sales,
  COUNT(*) AS transaction_count
FROM Sales
GROUP BY sale_date, region, channel;

-- 주기적으로 갱신
REFRESH MATERIALIZED VIEW daily_sales_summary;
```

---

## 실전 시나리오와 예제

### 시나리오 1: 다차원 판매 분석 리포트
```sql
-- 월별, 지역별, 채널별 매출 분석
WITH monthly_data AS (
  SELECT
    DATE_TRUNC('month', sale_date) AS sale_month,
    region,
    channel,
    SUM(amount) AS monthly_sales
  FROM Sales
  WHERE sale_date >= '2025-01-01'
  GROUP BY DATE_TRUNC('month', sale_date), region, channel
)
SELECT
  TO_CHAR(sale_month, 'YYYY-MM') AS month,
  region,
  channel,
  monthly_sales,
  SUM(monthly_sales) OVER (PARTITION BY sale_month, region) AS region_monthly_total,
  SUM(monthly_sales) OVER (PARTITION BY sale_month) AS monthly_total,
  ROUND(100.0 * monthly_sales / NULLIF(SUM(monthly_sales) OVER (PARTITION BY sale_month), 0), 2) AS pct_of_monthly_total
FROM monthly_data
ORDER BY sale_month DESC, region, channel;
```

### 시나리오 2: 제품 카테고리별 트렌드 분석
```sql
-- 카테고리별 월별 매출 피벗 테이블
SELECT *
FROM (
  SELECT
    TO_CHAR(sale_date, 'YYYY-MM') AS sale_month,
    category,
    amount
  FROM Sales
  WHERE sale_date >= '2025-01-01'
) AS source_data
PIVOT (
  SUM(amount)
  FOR category IN ('ELECTRONICS', 'FASHION')
) AS pivot_table
ORDER BY sale_month;
```

### 시나리오 3: 지역별 성과 비교
```sql
-- 지역별 주요 통계 비교
SELECT
  region,
  COUNT(*) AS transaction_count,
  SUM(amount) AS total_sales,
  AVG(amount) AS avg_transaction_value,
  MIN(amount) AS min_transaction_value,
  MAX(amount) AS max_transaction_value,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median_transaction_value
FROM Sales
WHERE sale_date >= '2025-01-01'
GROUP BY region
ORDER BY total_sales DESC;
```

---

## 결론

SQL의 고급 집계 기능은 현대 데이터 분석에서 필수적인 도구입니다. ROLLUP, CUBE, GROUPING SETS를 통해 다양한 수준의 부분 합계와 총계를 효율적으로 생성할 수 있으며, PIVOT과 UNPIVOT을 사용하면 데이터를 보다 읽기 쉬운 형식으로 변환할 수 있습니다.

효과적인 고급 집계 사용을 위한 핵심 원칙은 다음과 같습니다:

1. **적절한 도구 선택**: 필요한 분석에 맞는 집계 방법을 선택하세요. 단순한 계층적 합계에는 ROLLUP을, 모든 조합 분석에는 CUBE를, 특정 조합만 필요하면 GROUPING SETS를 사용하세요.

2. **성능 고려**: 대용량 데이터에서는 항상 성능을 고려하세요. 불필요한 CUBE 사용은 피하고, 가능한 한 빨리 데이터를 필터링하며, 적절한 인덱스와 파티셔닝을 활용하세요.

3. **데이터베이스 호환성**: 프로젝트의 데이터베이스가 지원하는 기능을 이해하세요. 모든 데이터베이스가 동일한 기능을 지원하는 것은 아니므로, 필요한 경우 대체 구현 방법을 알아두세요.

4. **가독성과 유지보수성**: 복잡한 집계 쿼리는 CTE(Common Table Expression)를 사용하여 모듈화하고, 의미 있는 컬럼 이름을 사용하며, 주석을 추가하여 가독성을 높이세요.

5. **데이터 정확성**: 합계 행과 실제 데이터를 명확히 구분하세요. GROUPING 함수를 사용하여 합계 행을 식별하고 적절히 라벨링하세요.

고급 집계 기능을 마스터하면 단순한 데이터 조회를 넘어 진정한 비즈니스 인텔리전스를 제공할 수 있습니다. 이러한 기능들은 데이터 기반 의사결정을 지원하고, 복잡한 비즈니스 질문에 답변하는 데 필수적입니다. 처음에는 복잡해 보일 수 있지만, 기본 개념을 이해하고 실습을 통해 경험을 쌓다 보면 점점 자연스럽게 사용할 수 있게 될 것입니다.