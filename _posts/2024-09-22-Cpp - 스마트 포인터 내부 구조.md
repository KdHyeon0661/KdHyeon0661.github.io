---
layout: post
title: C++ - 스마트 포인터 내부 구조
date: 2024-09-22 19:20:23 +0900
category: Cpp
---
# 스마트 포인터 내부 구조 심층 분석: unique_ptr vs shared_ptr

## 스마트 포인터의 철학: 자원 수명 관리의 자동화

C++에서 스마트 포인터는 단순히 메모리 관리를 편하게 해주는 도구가 아니라, **소유권과 수명 관리를 타입 시스템에 통합하는** 강력한 디자인 패턴입니다. `unique_ptr`과 `shared_ptr`은 이 패턴의 두 가지 핵심 구현체로, 각각 다른 소유권 모델과 성능 특성을 가지고 있습니다.

**핵심 차이점:**
- `unique_ptr`: **독점적 소유권** - "이 객체는 나만이 소유하며, 내가 사라질 때 함께 사라진다"
- `shared_ptr`: **공유 소유권** - "이 객체는 여러 주인이 있으며, 마지막 주인이 사라질 때 비로소 사라진다"

## unique_ptr: 단독 소유권의 구현

### 내부 구조와 설계 철학

`unique_ptr`의 핵심 설계 목표는 **오버헤드를 최소화**하면서도 안전한 자원 관리를 제공하는 것입니다. 이를 위해 컴파일러 최적화 기술을 적극 활용합니다.

```cpp
// unique_ptr의 개념적 구현 (단순화 버전)
template<typename T, typename Deleter = std::default_delete<T>>
class unique_ptr {
private:
    T* ptr = nullptr;
    [[no_unique_address]] Deleter deleter;  // EBO 최적화
    
public:
    // 생성자: 자원 획득
    explicit unique_ptr(T* p = nullptr) noexcept : ptr(p) {}
    
    // 소멸자: 자원 해제
    ~unique_ptr() {
        if (ptr) {
            deleter(ptr);
        }
    }
    
    // 복사 방지 (단독 소유권)
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
    
    // 이동 지원
    unique_ptr(unique_ptr&& other) noexcept 
        : ptr(std::exchange(other.ptr, nullptr)), 
          deleter(std::move(other.deleter)) {}
    
    // 값 접근
    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }
    T* get() const { return ptr; }
    
    // 소유권 포기
    T* release() noexcept {
        return std::exchange(ptr, nullptr);
    }
};
```

### EBO(Empty Base Optimization)의 마법

`unique_ptr`의 가장 뛰어난 디자인 특징 중 하나는 EBO를 활용한 크기 최적화입니다:

```cpp
#include <iostream>
#include <memory>

// 빈(empty) 삭제자
struct EmptyDeleter {
    void operator()(void*) const noexcept {}
};

// 상태를 가진 삭제자
struct StatefulDeleter {
    int some_state = 42;
    void operator()(void*) const noexcept {}
};

int main() {
    std::unique_ptr<int> p1;  // 일반 unique_ptr
    std::unique_ptr<int, EmptyDeleter> p2;  // 빈 삭제자 사용
    
    std::cout << "sizeof(p1): " << sizeof(p1) << "\n";  // 8 (포인터만)
    std::cout << "sizeof(p2): " << sizeof(p2) << "\n";  // 8 (EBO로 최적화)
    std::cout << "sizeof(StatefulDeleter): " << sizeof(StatefulDeleter) << "\n";  // 4
    std::cout << "sizeof(unique_ptr<int, StatefulDeleter>): " 
              << sizeof(std::unique_ptr<int, StatefulDeleter>) << "\n";  // 16 (포인터 + 삭제자)
}
```

**EBO의 핵심:** 삭제자가 빈 클래스(데이터 멤버 없는 클래스)일 경우, 컴파일러는 이를 별도의 공간에 저장하지 않고 `unique_ptr` 객체 자체에 "합쳐" 저장합니다. 이로 인해 `unique_ptr`의 크기가 일반 포인터와 동일하게 유지될 수 있습니다.

### 배열 지원과 타입 안전성

```cpp
#include <memory>

// 올바른 배열 사용법
void correct_array_usage() {
    // 배열은 unique_ptr<T[]> 사용
    auto array = std::make_unique<int[]>(10);
    array[0] = 1;
    array[9] = 10;
    
    // unique_ptr<T[]>는 delete[] 사용
    // 배열 인덱스 접근만 가능, 포인터 산술은 컴파일 오류
}

// 잘못된 사용법
void wrong_array_usage() {
    // ❌ 위험: 배열을 unique_ptr<T>로 관리
    // std::unique_ptr<int> bad_array(new int[10]);
    // delete 대신 delete[]가 호출되어야 함!
}
```

## shared_ptr: 공유 소유권과 참조 카운팅

### 컨트롤 블록: shared_ptr의 두뇌

`shared_ptr`의 핵심은 **컨트롤 블록**이라는 메타데이터 구조체에 있습니다. 이 블록은 참조 카운트와 기타 관리 정보를 저장합니다.

```cpp
// 컨트롤 블록의 개념적 구조
struct ControlBlock {
    std::atomic<long> use_count;      // shared_ptr 참조 수
    std::atomic<long> weak_count;     // weak_ptr 참조 수
    void* managed_object;             // 관리 대상 객체
    Deleter deleter;                  // 삭제자 (타입 지워짐)
    Allocator allocator;              // 할당자 (타입 지워짐)
    
    // 객체 삭제
    void destroy_object() {
        deleter(managed_object);
    }
    
    // 컨트롤 블록 자체 삭제
    void destroy_self() {
        // allocator를 사용하여 메모리 해제
    }
};
```

### 참조 카운팅의 작동 원리

```cpp
#include <memory>
#include <iostream>

void reference_counting_demo() {
    std::cout << "참조 카운팅 데모\n";
    
    // 1. 첫 번째 shared_ptr 생성
    auto sp1 = std::make_shared<int>(42);
    std::cout << "sp1 생성 후 use_count: " << sp1.use_count() << "\n";  // 1
    
    {
        // 2. 복사 생성: 참조 카운트 증가
        auto sp2 = sp1;  // 복사 생성자
        std::cout << "sp2 복사 후 use_count: " << sp1.use_count() << "\n";  // 2
        
        // 3. 또 다른 복사
        auto sp3 = sp2;
        std::cout << "sp3 복사 후 use_count: " << sp1.use_count() << "\n";  // 3
    }  // sp2, sp3 소멸: 참조 카운트 감소
    
    std::cout << "스코프 종료 후 use_count: " << sp1.use_count() << "\n";  // 1
}  // sp1 소멸: 참조 카운트 0 → 객체 삭제
```

### make_shared의 성능 이점

`make_shared`는 단순히 편의 함수가 아닌, 중요한 성능 최적화를 제공합니다:

```cpp
#include <memory>
#include <chrono>
#include <iostream>

struct LargeObject {
    double data[1000];  // 큰 객체
    LargeObject(double value) {
        for (auto& d : data) d = value;
    }
};

void performance_comparison() {
    const int iterations = 100000;
    
    // 방법 1: new + shared_ptr (2번 할당)
    auto start1 = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        std::shared_ptr<LargeObject> p(new LargeObject(i));
        // 할당 1: LargeObject
        // 할당 2: 컨트롤 블록
    }
    auto end1 = std::chrono::high_resolution_clock::now();
    
    // 방법 2: make_shared (1번 할당)
    auto start2 = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        auto p = std::make_shared<LargeObject>(i);
        // 할당 1: 컨트롤 블록 + LargeObject (한 덩어리)
    }
    auto end2 = std::chrono::high_resolution_clock::now();
    
    auto duration1 = std::chrono::duration_cast<std::chrono::milliseconds>(end1 - start1);
    auto duration2 = std::chrono::duration_cast<std::chrono::milliseconds>(end2 - start2);
    
    std::cout << "new + shared_ptr: " << duration1.count() << "ms\n";
    std::cout << "make_shared: " << duration2.count() << "ms\n";
    std::cout << "성능 차이: " << (duration1.count() - duration2.count()) << "ms\n";
}
```

**make_shared의 장점:**
1. **메모리 할당 1회 감소**: 객체와 컨트롤 블록을 연속된 메모리에 할당
2. **캐시 지역성 향상**: 객체 접근 시 컨트롤 블록도 함께 캐시에 로드
3. **예외 안전성**: 생성 중 예외 발생 시 메모리 누수 없음

### 약한 참조와 순환 참조 문제 해결

`shared_ptr`의 가장 큰 함정은 순환 참조입니다. `weak_ptr`은 이를 해결하는 열쇠입니다:

```cpp
#include <memory>
#include <iostream>

class Node {
public:
    std::string name;
    std::shared_ptr<Node> next;    // 강한 참조
    std::weak_ptr<Node> prev;      // 약한 참조 (순환 방지)
    
    Node(const std::string& n) : name(n) {
        std::cout << "Node " << name << " 생성\n";
    }
    
    ~Node() {
        std::cout << "Node " << name << " 소멸\n";
    }
};

void circular_reference_demo() {
    std::cout << "\n=== 순환 참조 데모 ===\n";
    
    // 순환 참조가 없는 경우 (정상적 소멸)
    {
        auto node1 = std::make_shared<Node>("A");
        auto node2 = std::make_shared<Node>("B");
        
        node1->next = node2;      // 강한 참조
        node2->prev = node1;      // 약한 참조
        
        std::cout << "스코프 종료 시점\n";
    }  // node1, node2 모두 정상 소멸
    
    // 순환 참조 문제 (메모리 누수)
    {
        auto node3 = std::make_shared<Node>("C");
        auto node4 = std::make_shared<Node>("D");
        
        node3->next = node4;
        node4->next = node3;      // ⚠️ 양방향 강한 참조: 순환 발생!
        
        std::cout << "스코프 종료 시점 (순환 참조)\n";
    }  // node3, node4 소멸되지 않음 (메모리 누수)
}

void weak_ptr_usage() {
    std::cout << "\n=== weak_ptr 사용법 ===\n";
    
    auto shared = std::make_shared<int>(100);
    std::weak_ptr<int> weak = shared;
    
    std::cout << "use_count: " << shared.use_count() << "\n";  // 1
    
    // weak_ptr로부터 shared_ptr 획득
    if (auto locked = weak.lock()) {
        std::cout << "객체 접근 성공: " << *locked << "\n";
        std::cout << "lock 후 use_count: " << shared.use_count() << "\n";  // 2
    }
    
    shared.reset();  // 객체 삭제
    
    if (auto locked = weak.lock()) {
        std::cout << "이 메시지는 출력되지 않음\n";
    } else {
        std::cout << "객체가 이미 소멸됨\n";
    }
}
```

## Aliasing 생성자: 독특한 공유 패턴

`shared_ptr`의 강력하지만 잘 알려지지 않은 기능 중 하나는 aliasing 생성자입니다:

```cpp
#include <memory>
#include <vector>
#include <iostream>

struct LargeData {
    std::vector<int> values;
    int metadata;
    
    LargeData(int size, int meta) : values(size), metadata(meta) {}
};

void aliasing_demo() {
    // 큰 데이터 구조체 생성
    auto data = std::make_shared<LargeData>(1000, 42);
    
    // aliasing: data의 수명을 공유하면서 vector 부분만 가리키는 shared_ptr
    std::shared_ptr<std::vector<int>> vec_ptr(data, &data->values);
    
    // vector 작업
    vec_ptr->push_back(1);
    vec_ptr->push_back(2);
    
    std::cout << "data use_count: " << data.use_count() << "\n";  // 2
    std::cout << "vec_ptr use_count: " << vec_ptr.use_count() << "\n";  // 2
    
    // vec_ptr이 소멸되어도 data는 여전히 존재
    vec_ptr.reset();
    std::cout << "vec_ptr 해제 후 data use_count: " << data.use_count() << "\n";  // 1
    
    // data가 소멸되면 LargeData 전체가 소멸됨
    // vec_ptr은 단지 LargeData 내부의 vector를 "빌려" 가리킬 뿐
}
```

**Aliasing의 핵심:** 서로 다른 타입의 `shared_ptr`이 동일한 컨트롤 블록(수명)을 공유하면서, 서로 다른 객체를 가리킬 수 있습니다.

## 스레드 안전성과 성능 고려사항

### 원자적 연산의 비용

```cpp
#include <memory>
#include <thread>
#include <vector>
#include <chrono>
#include <iostream>

void thread_safety_demo() {
    auto shared = std::make_shared<int>(0);
    
    // 멀티스레드 환경에서 shared_ptr 복사는 안전
    std::vector<std::thread> threads;
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back([shared]() {
            auto local_copy = shared;  // 원자적 참조 카운트 증가
            // 작업 수행
        });
    }
    
    for (auto& t : threads) {
        t.join();
    }
}

void performance_pitfall() {
    const int iterations = 1000000;
    
    // 나쁜 예: 핫 루프 내에서 불필요한 shared_ptr 복사
    auto shared = std::make_shared<int>(0);
    
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        auto copy = shared;  // 매번 원자적 증가
        // 작업
    }
    auto end = std::chrono::high_resolution_clock::now();
    
    // 좋은 예: raw 포인터 사용 (수명이 보장되는 경우)
    int* raw_ptr = shared.get();
    
    auto start2 = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        // raw_ptr 사용 (원자적 연산 없음)
        volatile int value = *raw_ptr;  // volatile로 컴파일러 최적화 방지
    }
    auto end2 = std::chrono::high_resolution_clock::now();
    
    auto duration1 = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    auto duration2 = std::chrono::duration_cast<std::chrono::microseconds>(end2 - start2);
    
    std::cout << "shared_ptr 복사: " << duration1.count() << "μs\n";
    std::cout << "raw 포인터 접근: " << duration2.count() << "μs\n";
}
```

## 실전 설계 패턴과 고려사항

### 팩토리 패턴에서의 활용

```cpp
#include <memory>
#include <iostream>
#include <vector>

class Document {
public:
    virtual void print() const = 0;
    virtual ~Document() = default;
};

class PdfDocument : public Document {
public:
    void print() const override {
        std::cout << "PDF 문서 출력\n";
    }
};

class WordDocument : public Document {
public:
    void print() const override {
        std::cout << "Word 문서 출력\n";
    }
};

// 팩토리 함수: unique_ptr 반환 (소유권 이전)
std::unique_ptr<Document> createDocument(const std::string& type) {
    if (type == "pdf") {
        return std::make_unique<PdfDocument>();
    } else if (type == "word") {
        return std::make_unique<WordDocument>();
    }
    return nullptr;
}

// 문서 관리자: shared_ptr 사용 (여러 컴포넌트에서 공유)
class DocumentManager {
private:
    std::vector<std::shared_ptr<Document>> documents;
    
public:
    void addDocument(std::shared_ptr<Document> doc) {
        documents.push_back(std::move(doc));
    }
    
    void printAll() const {
        for (const auto& doc : documents) {
            doc->print();
        }
    }
};
```

### 커스텀 삭제자를 활용한 리소스 관리

```cpp
#include <memory>
#include <iostream>
#include <sqlite3.h>

// SQLite 데이터베이스 커넥션 RAII 래퍼
class DatabaseConnection {
private:
    struct SQLiteDeleter {
        void operator()(sqlite3* db) const {
            if (db) {
                sqlite3_close(db);
                std::cout << "데이터베이스 연결 종료\n";
            }
        }
    };
    
    std::unique_ptr<sqlite3, SQLiteDeleter> db_handle;
    
public:
    DatabaseConnection(const std::string& filename) {
        sqlite3* raw_db = nullptr;
        if (sqlite3_open(filename.c_str(), &raw_db) != SQLITE_OK) {
            throw std::runtime_error("데이터베이스 연결 실패");
        }
        db_handle.reset(raw_db);
    }
    
    sqlite3* get() const { return db_handle.get(); }
};

// 파일 시스템 리소스
class FileResource {
private:
    struct FileDeleter {
        void operator()(FILE* file) const {
            if (file) {
                fclose(file);
                std::cout << "파일 닫힘\n";
            }
        }
    };
    
    std::unique_ptr<FILE, FileDeleter> file_handle;
    
public:
    FileResource(const std::string& filename, const std::string& mode) {
        FILE* file = fopen(filename.c_str(), mode.c_str());
        if (!file) {
            throw std::runtime_error("파일 열기 실패");
        }
        file_handle.reset(file);
    }
    
    void write(const std::string& data) {
        if (fputs(data.c_str(), file_handle.get()) == EOF) {
            throw std::runtime_error("파일 쓰기 실패");
        }
    }
};
```

## 성능 비교와 선택 가이드

### 메모리 사용량 비교

```cpp
#include <iostream>
#include <memory>

void memory_usage_comparison() {
    struct Data {
        int values[100];
    };
    
    // 각 포인터 타입의 크기 비교
    std::cout << "=== 메모리 사용량 비교 ===\n";
    std::cout << "sizeof(Data*): " << sizeof(Data*) << " bytes\n";
    std::cout << "sizeof(unique_ptr<Data>): " << sizeof(std::unique_ptr<Data>) << " bytes\n";
    std::cout << "sizeof(shared_ptr<Data>): " << sizeof(std::shared_ptr<Data>) << " bytes\n";
    std::cout << "sizeof(weak_ptr<Data>): " << sizeof(std::weak_ptr<Data>) << " bytes\n";
    
    // 실제 사용 시 추가 메모리
    auto unique = std::make_unique<Data>();
    auto shared = std::make_shared<Data>();
    auto weak = std::weak_ptr<Data>(shared);
    
    std::cout << "\n=== 실제 사용 시 고려사항 ===\n";
    std::cout << "unique_ptr: 객체 메모리만 사용\n";
    std::cout << "shared_ptr: 객체 메모리 + 컨트롤 블록(~16-40 bytes)\n";
    std::cout << "weak_ptr: 컨트롤 블록 참조만 (객체 메모리 없음)\n";
}
```

### 선택 가이드라인: 언제 무엇을 사용할 것인가?

**unique_ptr을 선택하는 경우:**
1. 단일 소유자가 명확한 경우
2. 성능이 중요한 핫 패스 코드
3. 복잡한 데이터 구조의 내부 구현
4. 팩토리 함수의 반환 타입

**shared_ptr을 선택하는 경우:**
1. 여러 컴포넌트가 객체를 공유해야 하는 경우
2. 객체 수명을 미리 알 수 없는 경우
3. 캐시나 레지스트리 같은 전역 자료 구조
4. 비동기 작업 콜백에 객체 전달

**weak_ptr을 선택하는 경우:**
1. 순환 참조 가능성이 있는 구조
2. 캐시 구현 (객체가 살아있는지 확인)
3. 옵저버 패턴 구현
4. 객체의 존재 여부만 확인하고 싶은 경우

## 결론: 현명한 스마트 포인터 사용법

스마트 포인터는 C++에서 메모리 관리를 근본적으로 변화시킨 도구입니다. 하지만 그 힘은 적절한 사용법을 이해할 때 발휘됩니다:

### 핵심 원칙

1. **소유권을 명시적으로 표현하라**
   - `unique_ptr`: "나는 단독 소유자다"
   - `shared_ptr`: "우리는 함께 소유한다"
   - `weak_ptr`: "나는 관찰만 한다"

2. **성능과 안전성의 균형을 유지하라**
   - `unique_ptr`은 거의 오버헤드 없음
   - `shared_ptr`은 원자적 연산 비용 있음
   - `make_shared`는 성능과 예외 안전성 모두 제공

3. **수명 관리 패턴을 이해하라**
   - RAII: 스코프 기반 수명 관리
   - 참조 카운팅: 공유 수명 관리
   - 약한 참조: 순환 참조 해결

### 실전 조언

1. **기본값은 `unique_ptr`**: 대부분의 경우 단독 소유권으로 충분합니다.
2. **`shared_ptr`은 신중하게**: 공유가 정말 필요할 때만 사용하세요.
3. **`make_shared`를 우선하라**: 성능과 안전성 모두 우수합니다.
4. **순환 참조에 주의하라**: `weak_ptr`로 예방하세요.
5. **성능 핫스팟을 측정하라**: 프로파일링 없이 최적화하지 마세요.
6. **타입 시스템을 신뢰하라**: 스마트 포인터는 컴파일 타임 안전성을 제공합니다.

스마트 포인터는 단순한 편의 도구가 아니라, C++의 타입 시스템과 RAII 패러다임을 활용한 강력한 추상화 도구입니다. 내부 동작 원리를 이해하면 더 효과적으로 사용할 수 있으며, 복잡한 메모리 관리 문제를 우아하게 해결할 수 있습니다. 현대 C++ 코드에서는 raw 포인터 대신 스마트 포인터를 기본으로 사용하고, 각 상황에 맞는 소유권 모델을 선택하는 것이 좋은 습관입니다.