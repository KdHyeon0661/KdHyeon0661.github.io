---
layout: post
title: C++ - 스마트 포인터 내부 구조
date: 2024-09-22 19:20:23 +0900
category: Cpp
---
# 스마트 포인터 내부 구조 분석: `shared_ptr` vs `unique_ptr`

## 0. 큰 그림 요약

- **`unique_ptr`**: *단독 소유* (move-only), 기본적으로 **포인터 1개만 저장**. 삭제는 **정적/사용자 정의 deleter**로 수행. 가장 가볍고 빠르다.
- **`shared_ptr`**: *공유 소유* (copyable). **컨트롤 블록**(참조 카운트, deleter/allocator/type-erasure 보관)과 **객체**를 관리. `make_shared`/`allocate_shared` 사용 시 **한 번의 할당**으로 **캐시/성능/예외 안전성**이 좋아진다.
- **핵심**: 소유권과 수명은 **누가 delete 할 지**의 문제. RAII + 스마트 포인터가 그 정책을 코드에 명시한다.

---

## 1. `unique_ptr` 내부 구조 ― “가벼운 소유권 박스”

### 1.1 최소 구현 스케치

```cpp
template<class T, class D = std::default_delete<T>>
class unique_ptr {
    T* p = nullptr;
    [[no_unique_address]] D del; // EBO/[[no_unique_address]]로 크기 최적화 가능
public:
    constexpr unique_ptr() noexcept = default;
    explicit unique_ptr(T* raw) noexcept : p(raw) {}
    unique_ptr(T* raw, D d) noexcept : p(raw), del(std::move(d)) {}

    unique_ptr(unique_ptr&& o) noexcept : p(o.p), del(std::move(o.del)) { o.p = nullptr; }
    unique_ptr& operator=(unique_ptr&& o) noexcept {
        if (this != &o) { reset(); p = o.p; del = std::move(o.del); o.p = nullptr; }
        return *this;
    }

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

    ~unique_ptr() { reset(); }

    T* get() const noexcept { return p; }
    T& operator*()  const noexcept { return *p; }
    T* operator->() const noexcept { return p; }

    T* release() noexcept { T* r = p; p = nullptr; return r; }     // 소유권 포기
    void reset(T* np = nullptr) noexcept { if (p) del(p); p = np; }
    explicit operator bool() const noexcept { return p != nullptr; }
};
```

**포인트**

- **EBO(Empty Base Optimization)** 또는 `[[no_unique_address]]`로 **deleter가 빈 타입이면 크기 0**이 되어, `unique_ptr<T>`의 크기는 **일반 포인터 크기와 동일**까지 줄어든다.
- `unique_ptr<T[]>` 전용 부분 특수화가 있어 **배열 삭제 시 `delete[]`** 호출.

### 1.2 사용자 정의 deleter/상속 변환/배열 주의

```cpp
struct CloseFD {
    void operator()(int* fd) const noexcept { if (fd && *fd >= 0) ::close(*fd); delete fd; }
};

std::unique_ptr<int, CloseFD> fd(new int(::open(...)), CloseFD{});
```

- **배열**: `unique_ptr<int[]> a(new int[1024]);` 처럼 배열 전용 사용(삭제자는 `delete[]`).
- **업캐스팅**: `unique_ptr<Derived>` → `unique_ptr<Base>` 전환 시 **deleter 타입**이 호환되어야 한다(일반적으로 OK).
- **다운캐스팅**은 금지(의미 없음). 필요 시 `static_cast`와 별도 관리.

### 1.3 `make_unique` 권장

```cpp
auto p = std::make_unique<Foo>(args...); // 예외 안전 + 간결
```

- `new` 노출 없이 **예외 안전**.
- C++14부터 **배열 버전**: `auto buf = std::make_unique<std::byte[]>(N);`

---

## 2. `shared_ptr` 내부 구조 ― “컨트롤 블록과 참조 카운트”

### 2.1 개념 구조

```
shared_ptr<T>
 ├─ raw pointer: T* p  (관리 대상)
 └─ control block
     ├─ atomic<long> use_count    // 공유 소유자 수
     ├─ atomic<long> weak_count   // weak 소유자 수(+use_count>0면 해제 지연)
     ├─ (type-erased) deleter     // T 소멸 방식
     └─ (type-erased) allocator   // 블록/객체 할당자
```

- **use_count == 0** → **객체 소멸**
- **use_count == 0 && weak_count == 0** → **컨트롤 블록 해제**

### 2.2 단순화 구현 스케치

```cpp
template<class T>
class shared_ptr {
    T* p = nullptr;
    struct control_block {
        std::atomic<long> use{1};
        std::atomic<long> weak{1};  // self-held weak to keep block alive while use>0
        void (*del)(void*) = +[](void* vp){ delete static_cast<T*>(vp); };
    } *cb = nullptr;

    void dec_use() noexcept {
        if (cb && cb->use.fetch_sub(1, std::memory_order_acq_rel) == 1) {
            cb->del(p); // 객체 삭제
            if (cb->weak.fetch_sub(1, std::memory_order_acq_rel) == 1) delete cb; // 블록 삭제
        }
    }

public:
    shared_ptr() noexcept = default;
    explicit shared_ptr(T* raw) : p(raw), cb(raw ? new control_block : nullptr) {}

    shared_ptr(const shared_ptr& o) noexcept : p(o.p), cb(o.cb) {
        if (cb) cb->use.fetch_add(1, std::memory_order_relaxed);
    }
    shared_ptr(shared_ptr&& o) noexcept : p(o.p), cb(o.cb) { o.p = nullptr; o.cb = nullptr; }

    ~shared_ptr() { dec_use(); }

    shared_ptr& operator=(const shared_ptr& o) noexcept {
        if (this != &o) { dec_use(); p = o.p; cb = o.cb; if (cb) cb->use.fetch_add(1, std::memory_order_relaxed); }
        return *this;
    }
    shared_ptr& operator=(shared_ptr&& o) noexcept {
        if (this != &o) { dec_use(); p = o.p; cb = o.cb; o.p = nullptr; o.cb = nullptr; }
        return *this;
    }

    long use_count() const noexcept { return cb ? cb->use.load(std::memory_order_acquire) : 0; }
    T*   get()       const noexcept { return p; }
    T&   operator*() const noexcept { return *p; }
    T*   operator->()const noexcept { return p; }
};
```

**포인트**

- **원자적(atomic) 증가/감소**로 **스레드 안전**.
- `use_count()` 조회 자체도 원자적 로드이므로 **비용이 있다**(핫 패스에서 남용 금지).
- 실제 표준 구현은 **type-erased deleter/allocator, enable_shared_from_this 연동, array 지원** 등 훨씬 더 복잡.

---

## 3. `make_shared` / `allocate_shared`가 유리한 진짜 이유

### 3.1 단일 할당(one-shot allocation)

```cpp
auto sp = std::make_shared<T>(args...);
// [컨트롤 블록 + T]를 한 덩어리로 할당 → 캐시 친화적, 할당 두 번 → 한 번
```

- **new + shared_ptr** 패턴:
  1) `new T` (T 메모리)
  2) `new control_block` (컨트롤 블록) → **2번 할당**
- **make_shared**:
  - [컨트롤 블록 + T] **단일 블록** → **CPU 캐시 지역성↑, 할당 오버헤드↓**

### 3.2 예외 안전성 (strong)

- 생성 중 예외 시 **부분 생성 누수 없음**(원자적으로 실패).
- 반면 `shared_ptr<T>(new T(...))` 중간에 다른 예외가 끼면 **누수 여지**가 생길 수 있다(실전에서는 보통 안전하나, `new` 노출이 코드 냄새).

### 3.3 `allocate_shared` — 커스텀 allocator와 결합

```cpp
template<class T, class Alloc, class...Args>
std::shared_ptr<T> allocate_shared(const Alloc& a, Args&&... args);
```

- **컨트롤 블록과 객체 모두**를 `a`로 관리 → 대규모/실시간 시스템에서 **메모리 풀** 최적화.

### 3.4 반례/함정: 커스텀 deleter/약한 제어

- **특정 deleter가 반드시 필요**(예: `fclose`, `CloseHandle`)하고, T의 메모리를 **외부에서 따로 관리**해야 한다면 `make_shared`를 쓰면 **컨트롤 블록과 객체가 분리되지 않아 곤란**할 수 있다. 이때는
  ```cpp
  std::shared_ptr<FILE> fp(::fopen(...), &::fclose); // OK (분리 할당)
  ```
  처럼 **직접 생성**이 맞다.

---

## 4. 사용자 정의 Deleter, `get_deleter`, 배열/서브오브젝트

### 4.1 deleter 보관과 조회

```cpp
auto sp = std::shared_ptr<FILE>(::fopen("x.txt", "r"), [](FILE* f){ if (f) ::fclose(f); });
if (auto* d = std::get_deleter<void(*)(FILE*)>(sp)) {
    // 구현체마다 type-erasure 방식 상이: 대개 정확한 타입으로만 꺼낼 수 있음
}
```

- **컨트롤 블록**에 type-erased 형태로 **deleter가 저장**.
- `get_deleter`는 **정확한 타입**으로만 접근 가능(실무에서는 조회 빈도 낮음).

### 4.2 배열과 `shared_ptr<T[]>`

- C++17부터 `shared_ptr<T[]>` 부분 특수화 존재.
- 다만 **`make_shared<T[]>()`는 제한**이 있으니 보통
  ```cpp
  std::shared_ptr<int[]> a(new int[N], std::default_delete<int[]>{});
  ```
  또는 **컨테이너 사용**(`std::vector`)을 우선 고려.

### 4.3 **Aliasing constructor** — 서브오브젝트 공유

```cpp
struct Big { Header h; Payload p; };
auto whole = std::make_shared<Big>();
// whole과 같은 컨트롤 블록을 공유하지만, 가리키는 포인터는 &whole->p
std::shared_ptr<Payload> part(whole, &whole->p);
```

- **컨트롤 블록은 공유**하면서 **`get()`은 서브오브젝트**를 가리키게 만들 수 있다.
- **서브오브젝트만 별도 소멸**하지 않으며, 상위 객체의 수명에 묶인다.
- 콜백/뷰 객체에서 매우 유용.

---

## 5. `enable_shared_from_this`와의 상호작용

- `shared_ptr`로 **처음 생성**된 객체에 한해 `shared_from_this()` 유효.
- **raw new로 만든 뒤** `shared_ptr`에 억지로 넣으면 **UB/예외**.

```cpp
struct Node : std::enable_shared_from_this<Node> {
    std::shared_ptr<Node> self() { return shared_from_this(); }
};

auto n = std::make_shared<Node>(); // OK
auto self = n->self();             // 같은 control block, use_count 증가

Node* raw = new Node;
//raw->shared_from_this(); // ❌ 예외: control block 연결 없음
```

---

## 6. 스레드 안전성과 비용 모델

### 6.1 원자적 증가/감소

`shared_ptr`는 **소유권 조작**(복사/파괴)이 **멀티스레드에서 안전**하도록 **원자 연산**을 사용한다. 이 비용은 무시할 수준은 아니다.

- 대략적으로 복사/파괴마다 **RMW(원자적 read-modify-write)** 발생.
- 핫 패스에서 `shared_ptr` 복사 남발은 **성능 병목**이 될 수 있다.

### 6.2 `use_count()` 호출 비용/정합성

- `use_count()`는 **원자 로드** → 비싸다. 디버깅/통계 외엔 남용 금지.
- 강한 일관성은 보장하지 않는다(관찰 경합 가능). “참조가 몇 개인가”로 로직 분기하는 설계는 **취약**.

---

## 7. 예외 안전성(기본/강한 보장)과 수식 모델

- RAII + 스마트 포인터의 기본 보장:

$$
\text{소유자} \xrightarrow{\text{스코프 종료}} \text{해제},\quad
\text{예외 발생} \Rightarrow \text{스택 언와인드 중 소멸자 호출}
$$

- `make_shared`/`make_unique`는 **생성-소유권 이전을 원자화**해 **강한 보장**을 준다(중간 누수 없음).
- 반면 raw `new` 노출 + 복잡한 경로 → **부분 실패 시 리소스 누수** 가능.

---

## 8. 성능/메모리 레이아웃 디테일

### 8.1 객체/컨트롤 블록 배치

- `make_shared`: `[control_block | T]` 한 덩어리 → **캐시 지역성↑**.
- `shared_ptr(new T)`: `[T]`와 `[control_block]` 분리 → **포인터 두 번 추적**.

### 8.2 deleter가 크면? (EBO/[[no_unique_address]])

- `unique_ptr`는 deleter 타입이 **비어 있으면** 크기 1포인터,
  deleter가 **큰 상태를 가진 타입**이면 **포인터+deleter** 크기 증가.
- `shared_ptr` deleter는 **컨트롤 블록 쪽**에 들어가므로 `shared_ptr` 객체 크기에는 영향 적다(대신 컨트롤 블록이 커짐).

### 8.3 `shared_ptr`을 값으로 컨테이너에 많이 담을 때

- 복사 비용(원자 증가)이 누적 → **지연/경합 증가**.
- **이동**(C++11)을 적극 활용하거나, **핫 패스에선 raw 관찰자 포인터**를 짧게 보관(단, 수명 보장 주의).

---

## 9. 순환 참조와 `weak_ptr` (필수)

```cpp
struct Node {
    std::shared_ptr<Node> next;
    std::weak_ptr<Node>   prev; // ← 여기 weak로 끊어야 함
};
```

- `shared_ptr`끼리 서로 가리키면 **use_count가 0이 안 돼** 누수.
- **소유 관계를 단방향**으로 설계하고, 역참조/옵저버는 `weak_ptr`로.

> `weak_ptr::lock()`은 안전한 순간 `shared_ptr`을 잠깐 만든다(없어지면 빈 포인터).

---

## 10. 자주 묻는 설계/실전 Q&A

### Q1. “`shared_ptr`만 쓰면 다 안전?”
A. **아니다.** 순환 참조/핫 패스 복사/잘못된 aliasing/잘못된 deleter로 여전히 터진다. 최소 권한 원칙: **기본은 `unique_ptr`**, 공유가 꼭 필요할 때만 `shared_ptr`.

### Q2. “콜백에서 `this`를 오래 살리고 싶다”
A. 클래스에 `enable_shared_from_this`를 붙이고, 콜백 람다에서 `self = shared_from_this()` 캡처. **절대 `shared_ptr(this)` 하지 말 것**.

```cpp
class Conn : public std::enable_shared_from_this<Conn> {
    void start() {
        auto self = shared_from_this();
        async_read([self]{ self->handle(); });
    }
};
```

### Q3. “커스텀 deleter + `make_shared`?”
A. **불가**. `make_shared`는 컨트롤 블록/객체를 *자체 방식*으로 만들기 때문에 외부 deleter 주입이 안 된다. 이 경우 **직접 생성**으로 가라.

### Q4. “subobject만 공유하고 싶다”
A. **Aliasing ctor** 사용: `shared_ptr<U> alias(owner, subptr)`. 수명은 `owner`가 관리, 관찰 포인터는 `subptr`.

---

## 11. 통합 예제: 파일 디스크립터, 메시지 버퍼, aliasing, 콜백

```cpp
#include <memory>
#include <vector>
#include <functional>
#include <cstdio>
#include <cstring>

// 1) 파일 핸들: shared_ptr + custom deleter (make_shared 사용 X)
using FilePtr = std::shared_ptr<FILE>;
FilePtr open_file(const char* path) {
    FILE* f = std::fopen(path, "rb");
    if (!f) throw std::runtime_error("open fail");
    return FilePtr(f, [](FILE* fp){ if (fp) std::fclose(fp); });
}

// 2) 큰 버퍼는 make_shared로: [control_block | vector] 한 덩어리
using Buffer = std::vector<std::byte>;
std::shared_ptr<Buffer> make_buffer(size_t n) {
    auto buf = std::make_shared<Buffer>(n);
    return buf;
}

// 3) aliasing: Buffer 전체는 유지, 콜백에는 “서브뷰 포인터”만 노출
struct View {
    const std::byte* data;
    size_t len;
};

using ViewPtr = std::shared_ptr<const std::byte>;

// aliasing shared_ptr: owner=buf, ptr=subobject
ViewPtr alias_view(std::shared_ptr<Buffer> buf, size_t off) {
    return ViewPtr(buf, buf->data() + off);
}

// 4) 콜백에 수명 안전하게 넘기기
void async_send(ViewPtr data_head, size_t len, std::function<void()> done) {
    // 전송 완료 후 done() 호출. data_head의 오너(buf)는 살아있음
    (void)data_head; (void)len;
    done();
}

void pipeline(const char* path) {
    auto file = open_file(path);
    auto buf  = make_buffer(4096);

    // fread 등으로 buf 채운다고 가정 …
    // aliasing으로 buf 수명은 공유하되, 콜백에는 포인터만 전달
    auto head = alias_view(buf, 0);

    async_send(head, buf->size(), [owner = std::move(buf)]{
        // owner 캡처로 전송 완료까지 buffer 생존 보장
        // 끝나면 자동 해제
    });
}
```

**포인트**

- 파일 핸들은 **custom deleter**가 필요하므로 `make_shared` 대신 직접 생성.
- 대용량 버퍼는 `make_shared<vector>`로 **할당 1회** + **지역성** 확보.
- **Aliasing**으로 부분 포인터만 외부에 노출하면서 **수명은 상위 오브젝트와 공유**.
- 콜백에서 `owner` 캡처로 **수명 연장** — 자연스러운 RAII.

---

## 12. 표 요약

| 항목                         | `unique_ptr`                                             | `shared_ptr`                                                                 |
|------------------------------|-----------------------------------------------------------|-------------------------------------------------------------------------------|
| 소유권                       | 단독 (move-only)                                         | 공유 (copy 가능)                                                             |
| 내부 저장                    | `T*` + `deleter` (EBO로 크기 최소화 가능)               | `T*` + **control block**(use/weak/ deleter/allocator/type-erasure)          |
| 삭제 시점                    | 소유자 소멸/`reset`                                      | `use_count == 0` 시 객체 삭제, `weak_count == 0` 시 블록 삭제               |
| 스레드 안전                  | 자체는 값 타입, 보통 안전(의미는 컨텍스트)              | 참조 카운트 **원자적 조작**으로 소유권 조작은 스레드 안전                   |
| 비용/성능                    | 가장 저렴함                                              | 복사/파괴 시 원자 연산 비용                                                  |
| 배열 지원                    | `unique_ptr<T[]>` 전용 특수화 (`delete[]`)               | `shared_ptr<T[]>` 가능(상황 따라 직접 deleter)                               |
| `make_*`                     | `make_unique` (배열도 지원)                              | `make_shared`/`allocate_shared` (**할당 1회**, 예외 안전, 캐시 지역성)      |
| 커스텀 deleter               | 타입 인자 D로 저장(EBO)                                   | 컨트롤 블록에 type-erasure로 저장(`get_deleter`로 조회 가능)               |
| 순환 참조                    | 해당 없음                                                 | **약점** → `weak_ptr`로 끊기                                                 |
| 특수 기능                    | —                                                         | **Aliasing ctor**, `enable_shared_from_this`, `weak_ptr::lock()`             |

---

## 13. 마무리 — 실전 가이드라인

1. **기본은 `unique_ptr`**: 소유권이 단일이면 가장 빠르고 안전하다.
2. 진짜 **공유 수명**이 필요할 때만 `shared_ptr`를 쓴다.
3. `shared_ptr`는 **`make_shared/allocate_shared`** 우선. 커스텀 deleter/외부 리소스면 직접 생성.
4. 콜백/비동기 설계에서 `enable_shared_from_this` + 캡처로 **수명 연장**을 명시하되, **`shared_ptr(this)` 금지**.
5. **Aliasing ctor**로 서브오브젝트/뷰를 안전하게 공유.
6. 핫 패스에서 `shared_ptr` 복사/`use_count()` 호출 남용 금지.
7. 순환 구조는 **`weak_ptr`**로 끊고, 소유 그래프를 **단방향**으로 설계.

스마트 포인터는 “delete를 없애는 도구”가 아니라, **수명/소유권 정책을 코드에 가시화**하고 **예외/스레드 안전**을 체계적으로 달성하게 해 주는 **언어적 메커니즘**이다. 내부 구조를 이해하면, _왜 여기선 unique, 저기선 shared, 그리고 어떤 생성 API를 써야 하는지_가 명확해진다.
