---
layout: post
title: 영상처리 - 모양 기술자 (C#)
date: 2025-12-11 18:30:23 +0900
category: 영상처리
---
# 모양 기술자

## 모양 기술자의 개요

모양 기술자(Shape Descriptor)는 **객체의 형상을 수치적 특징 벡터로 변환**하여 비교·분류·검색이 가능하도록 만드는 방법이다. 이는 영상 처리와 컴퓨터 비전의 핵심 요소로, 객체 인식, 산업 검사, 의료 영상 분석, 생체 인식 등 다양한 분야에서 활용된다.

### 모양 기술자의 필요성과 중요성

```
객체 인식 파이프라인:
원본 영상 → 영상 분할 → 모양 기술자 추출 → 특징 벡터 비교 → 분류/인식
        ↓           ↓              ↓               ↓
    전처리   이진화/세분화   수치적 표현 변환   유사도 측정
```

**좋은 모양 기술자가 갖춰야 할 특성:**

| 특성 | 설명 | 중요도 |
|------|------|--------|
| **이동 불변성** | 객체 위치에 무관 | 필수 |
| **회전 불변성** | 객체 방향에 무관 | 필수 |
| **크기 불변성** | 객체 스케일에 무관 | 필수 |
| **구분력** | 다른 모양은 다른 특징값 | 고 |
| **강건성** | 노이즈, 변형에 강함 | 고 |
| **계산 효율성** | 실시간 처리 가능 | 중 |
| **압축성** | 적은 차원으로 표현 | 중 |

### 모양 기술자 분류 체계

```
모양 기술자
├─ 경계 기반 (Boundary-based)
│  ├─ 푸리에 기술자 (Fourier Descriptors)
│  ├─ 체인 코드 (Chain Code)
│  ├─ 시그니처 (Signature)
│  └─ 곡률 스케일 공간 (Curvature Scale Space)
│
├─ 영역 기반 (Region-based)
│  ├─ 기하 모멘트 (Geometric Moments)
│  ├─ Hu 불변 모멘트 (Hu Invariant Moments)
│  ├─ Zernike 모멘트
│  └─ Legendre 모멘트
│
├─ 구조적 (Structural)
│  ├─ 변환 (Skeleton)
│  ├─ 그래프 표현 (Graph Representation)
│  └─ 문자열 표현 (String Representation)
│
└─ 통계적 (Statistical)
   ├─ 투영 프로파일 (Projection Profiles)
   ├─ 극좌표 히스토그램 (Polar Histogram)
   └─ 거리 히스토그램 (Distance Histogram)
```

---

## 모양 표현의 기본 개념

### 객체 표현 방법 비교

| 표현 방법 | 데이터 형태 | 장점 | 단점 | 적합한 응용 |
|-----------|------------|------|------|-------------|
| **바운딩 박스** | (x,y,w,h) | 계산 간단, 빠름 | 형태 정보 손실 | 빠른 검출 |
| **외곽선** | 점의 리스트 | 형태 정보 보존 | 노이즈 민감 | 정밀 분석 |
| **영역 마스크** | 이진 행렬 | 내부 정보 보존 | 메모리 많이 사용 | 면적 분석 |
| **골격** | 선의 집합 | 구조적 정보 | 계산 복잡 | 문자 인식 |
| **특징 벡터** | 수치 벡터 | 비교 용이, 압축 | 정보 손실 가능 | 분류/인식 |

### 객체 정규화 처리

모양 기술자를 계산하기 전에 객체를 정규화하는 과정이 필요하다:

```csharp
public class ShapeNormalizer
{
    // 객체 중심 이동 (이동 불변성)
    public List<Point> TranslateToCentroid(List<Point> contour)
    {
        double meanX = contour.Average(p => p.X);
        double meanY = contour.Average(p => p.Y);
        
        return contour.Select(p => 
            new Point(p.X - (int)meanX, p.Y - (int)meanY)).ToList();
    }
    
    // 크기 정규화 (크기 불변성)
    public List<Point> ScaleToUnit(List<Point> contour, double targetSize = 1.0)
    {
        // 최대 거리 계산
        double maxDist = 0;
        Point centroid = new Point(
            (int)contour.Average(p => p.X),
            (int)contour.Average(p => p.Y));
            
        foreach (Point p in contour)
        {
            double dist = Math.Sqrt(
                Math.Pow(p.X - centroid.X, 2) + 
                Math.Pow(p.Y - centroid.Y, 2));
            maxDist = Math.Max(maxDist, dist);
        }
        
        if (maxDist < 1e-6) return contour;
        
        // 정규화
        double scale = targetSize / maxDist;
        return contour.Select(p => 
            new Point((int)(p.X * scale), (int)(p.Y * scale))).ToList();
    }
    
    // 주축 정렬 (방향 불변성)
    public List<Point> AlignToPrincipalAxis(List<Point> contour)
    {
        if (contour.Count < 3) return contour;
        
        // 공분산 행렬 계산
        double[,] cov = ComputeCovarianceMatrix(contour);
        
        // 주성분 분석 (PCA)
        double[] eigenvalues = new double[2];
        double[,] eigenvectors = new double[2, 2];
        ComputePCA(cov, ref eigenvalues, ref eigenvectors);
        
        // 주축 방향으로 회전
        double angle = Math.Atan2(eigenvectors[1, 0], eigenvectors[0, 0]);
        return RotatePoints(contour, -angle);
    }
    
    private double[,] ComputeCovarianceMatrix(List<Point> contour)
    {
        double meanX = contour.Average(p => p.X);
        double meanY = contour.Average(p => p.Y);
        
        double[,] cov = new double[2, 2];
        int n = contour.Count;
        
        foreach (Point p in contour)
        {
            double dx = p.X - meanX;
            double dy = p.Y - meanY;
            cov[0, 0] += dx * dx; // var(X)
            cov[1, 1] += dy * dy; // var(Y)
            cov[0, 1] += dx * dy; // cov(X,Y)
        }
        
        cov[0, 0] /= n;
        cov[1, 1] /= n;
        cov[0, 1] /= n;
        cov[1, 0] = cov[0, 1]; // 대칭 행렬
        
        return cov;
    }
}
```

---

## 푸리에 기술자 (Fourier Descriptors)

### 이론적 배경

푸리에 기술자는 객체 외곽선을 주파수 영역에서 표현하는 방법으로, 원래 신호 처리 분야에서 개발된 푸리에 변환을 모양 분석에 적용한 것이다.

**수학적 표현:**

외곽선을 복소 평면상의 점으로 표현:
$$
z(k) = x(k) + j \cdot y(k), \quad k = 0, 1, \ldots, N-1
$$

여기서 $N$은 외곽선 점의 수, $j$는 허수 단위.

**이산 푸리에 변환(DFT):**
$$
Z(n) = \sum_{k=0}^{N-1} z(k) \cdot e^{-j2\pi nk/N}, \quad n = 0, 1, \ldots, N-1
$$

**역변환:**
$$
z(k) = \frac{1}{N} \sum_{n=0}^{N-1} Z(n) \cdot e^{j2\pi nk/N}
$$

### 푸리에 기술자의 물리적 의미

| 주파수 성분 | 물리적 의미 | 모양 정보 |
|-------------|-------------|-----------|
| **DC 성분 (n=0)** | 객체 중심 위치 | 이동 정보 |
| **저주파 성분** | 전체적인 형태 | 대략적 윤곽 |
| **중주파 성분** | 주요 특징 | 모서리, 굴곡 |
| **고주파 성분** | 세부 정보 | 노이즈, 미세 구조 |

### 불변성 확보 방법

```csharp
public class FourierDescriptor
{
    public enum NormalizationType
    {
        None,
        DCZero,      // 이동 불변
        Magnitude,   // 크기 불변
        Phase,       // 회전 불변
        Complete     // 완전 불변
    }
    
    public Complex[] ComputeDescriptors(List<Point> contour, 
                                        NormalizationType normType = NormalizationType.Complete)
    {
        // 1. 외곽선을 복소수 시퀀스로 변환
        Complex[] complexContour = new Complex[contour.Count];
        for (int i = 0; i < contour.Count; i++)
        {
            complexContour[i] = new Complex(contour[i].X, contour[i].Y);
        }
        
        // 2. 고속 푸리에 변환(FFT) 적용
        Complex[] spectrum = FFT(complexContour);
        
        // 3. 정규화
        spectrum = NormalizeSpectrum(spectrum, normType);
        
        return spectrum;
    }
    
    private Complex[] NormalizeSpectrum(Complex[] spectrum, NormalizationType normType)
    {
        if (normType == NormalizationType.None)
            return spectrum;
        
        Complex[] normalized = new Complex[spectrum.Length];
        Array.Copy(spectrum, normalized, spectrum.Length);
        
        switch (normType)
        {
            case NormalizationType.DCZero:
                // 이동 불변: DC 성분 제거
                normalized[0] = Complex.Zero;
                break;
                
            case NormalizationType.Magnitude:
                // 크기 불변: 첫 번째 비제로 성분으로 정규화
                int firstNonZero = 1;
                while (firstNonZero < normalized.Length && 
                       normalized[firstNonZero].Magnitude < 1e-6)
                    firstNonZero++;
                    
                if (firstNonZero < normalized.Length)
                {
                    double scale = normalized[firstNonZero].Magnitude;
                    for (int i = 0; i < normalized.Length; i++)
                        normalized[i] = normalized[i] / scale;
                }
                break;
                
            case NormalizationType.Phase:
                // 회전 불변: 위상 정규화
                for (int i = 0; i < normalized.Length; i++)
                    normalized[i] = Complex.FromPolarCoordinates(
                        normalized[i].Magnitude, 0);
                break;
                
            case NormalizationType.Complete:
                // 완전 불변: DC 제거 + 크기 정규화 + 위상 정규화
                normalized[0] = Complex.Zero;
                
                if (normalized.Length > 1)
                {
                    // 크기 정규화
                    double scale = normalized[1].Magnitude;
                    if (scale > 1e-6)
                    {
                        for (int i = 0; i < normalized.Length; i++)
                            normalized[i] = normalized[i] / scale;
                    }
                    
                    // 위상 정규화
                    for (int i = 0; i < normalized.Length; i++)
                        normalized[i] = Complex.FromPolarCoordinates(
                            normalized[i].Magnitude, 0);
                }
                break;
        }
        
        return normalized;
    }
    
    // 고속 푸리에 변환 구현
    private Complex[] FFT(Complex[] input)
    {
        int n = input.Length;
        
        // 기저 사례: 크기가 1이면 바로 반환
        if (n == 1) return new Complex[] { input[0] };
        
        // 짝수/홀수 인덱스 분리
        Complex[] even = new Complex[n / 2];
        Complex[] odd = new Complex[n / 2];
        
        for (int i = 0; i < n / 2; i++)
        {
            even[i] = input[2 * i];
            odd[i] = input[2 * i + 1];
        }
        
        // 재귀적 FFT
        Complex[] evenFFT = FFT(even);
        Complex[] oddFFT = FFT(odd);
        
        // 결과 합치기
        Complex[] result = new Complex[n];
        
        for (int k = 0; k < n / 2; k++)
        {
            Complex twiddle = Complex.FromPolarCoordinates(
                1, -2 * Math.PI * k / n);
            
            result[k] = evenFFT[k] + twiddle * oddFFT[k];
            result[k + n / 2] = evenFFT[k] - twiddle * oddFFT[k];
        }
        
        return result;
    }
    
    // 특징 벡터 추출 (저차 성분만 사용)
    public double[] ExtractFeatureVector(Complex[] descriptors, int numFeatures = 10)
    {
        // 중요: DC 성분(0)과 대칭 성분 제외
        int startIndex = 1;
        int endIndex = Math.Min(numFeatures * 2 + 1, descriptors.Length / 2);
        
        double[] features = new double[numFeatures];
        
        for (int i = 0; i < numFeatures; i++)
        {
            int idx = startIndex + i;
            if (idx < endIndex)
            {
                // 크기만 사용 (위상 정보 제외)
                features[i] = descriptors[idx].Magnitude;
            }
        }
        
        return features;
    }
    
    // 유사도 계산 (Euclidean 거리)
    public double ComputeSimilarity(double[] features1, double[] features2)
    {
        if (features1.Length != features2.Length)
            throw new ArgumentException("Feature vectors must have same length");
        
        double sumSquared = 0;
        for (int i = 0; i < features1.Length; i++)
        {
            double diff = features1[i] - features2[i];
            sumSquared += diff * diff;
        }
        
        return Math.Sqrt(sumSquared);
    }
}
```

### 푸리에 기술자 재구성 예제

```csharp
public class FourierReconstructor
{
    // 부분적 재구성 (저주파 성분만 사용)
    public List<Point> ReconstructContour(Complex[] descriptors, 
                                          int numComponents = 10)
    {
        int N = descriptors.Length;
        Complex[] partialSpectrum = new Complex[N];
        
        // 선택된 성분만 유지
        for (int i = 0; i < Math.Min(numComponents, N/2); i++)
        {
            partialSpectrum[i] = descriptors[i];
            partialSpectrum[N - i - 1] = descriptors[N - i - 1];
        }
        
        // 역 FFT
        Complex[] complexContour = InverseFFT(partialSpectrum);
        
        // 점 리스트로 변환
        List<Point> contour = new List<Point>();
        foreach (Complex c in complexContour)
        {
            contour.Add(new Point((int)c.Real, (int)c.Imaginary));
        }
        
        return contour;
    }
    
    private Complex[] InverseFFT(Complex[] spectrum)
    {
        // 켤레 복소수 취하고 FFT 적용
        Complex[] conjugated = new Complex[spectrum.Length];
        for (int i = 0; i < spectrum.Length; i++)
        {
            conjugated[i] = Complex.Conjugate(spectrum[i]);
        }
        
        Complex[] result = FFT(conjugated);
        
        // 다시 켤레 복소수 취하고 스케일링
        double scale = 1.0 / spectrum.Length;
        for (int i = 0; i < result.Length; i++)
        {
            result[i] = Complex.Conjugate(result[i]) * scale;
        }
        
        return result;
    }
}
```

### 푸리에 기술자의 장단점

| 장점 | 단점 |
|------|------|
| 계산 효율적 (FFT: O(n log n)) | 외곽선이 닫혀 있어야 함 |
| 압축률 높음 | 시작점 민감성 |
| 불변성 확보 용이 | 내부 정보 무시 |
| 다중 해상도 표현 가능 | 노이즈에 다소 민감 |

---

## 불변 모멘트 (Invariant Moments)

### 모멘트 이론의 수학적 기초

모멘트는 확률 분포의 형태를 설명하는 통계적 척도로, 영상 처리에서는 이진 객체의 질량 분포를 기술하는 데 사용된다.

**기하 모멘트 정의:**

$$
m_{pq} = \sum_{x} \sum_{y} x^p y^q f(x,y)
$$

여기서 $f(x,y)$는 $(x,y)$에서의 영상 값(이진일 경우 0 또는 1), $p,q$는 모멘트 차수.

**중심 모멘트 (중심 좌표 기준):**

$$
\mu_{pq} = \sum_{x} \sum_{y} (x - \bar{x})^p (y - \bar{y})^q f(x,y)
$$

여기서 $(\bar{x}, \bar{y})$는 무게 중심:
$$
\bar{x} = \frac{m_{10}}{m_{00}}, \quad \bar{y} = \frac{m_{01}}{m_{00}}
$$

**정규화 중심 모멘트 (크기 불변성):**

$$
\eta_{pq} = \frac{\mu_{pq}}{\mu_{00}^{\gamma}}, \quad \gamma = 1 + \frac{p+q}{2}
$$

### Hu의 7개 불변 모멘트 (1962)

M.K. Hu가 제안한 7개의 회전·이동·스케일 불변 모멘트:

1. **$\phi_1 = \eta_{20} + \eta_{02}$** - 확산도
2. **$\phi_2 = (\eta_{20} - \eta_{02})^2 + 4\eta_{11}^2$** - 비대칭도
3. **$\phi_3 = (\eta_{30} - 3\eta_{12})^2 + (3\eta_{21} - \eta_{03})^2$** - 왜곡도
4. **$\phi_4 = (\eta_{30} + \eta_{12})^2 + (\eta_{21} + \eta_{03})^2$** - 플랫토시시도
5. **$\phi_5 = (\eta_{30} - 3\eta_{12})(\eta_{30} + \eta_{12})[(\eta_{30} + \eta_{12})^2 - 3(\eta_{21} + \eta_{03})^2] + (3\eta_{21} - \eta_{03})(\eta_{21} + \eta_{03})[3(\eta_{30} + \eta_{12})^2 - (\eta_{21} + \eta_{03})^2]$**
6. **$\phi_6 = (\eta_{20} - \eta_{02})[(\eta_{30} + \eta_{12})^2 - (\eta_{21} + \eta_{03})^2] + 4\eta_{11}(\eta_{30} + \eta_{12})(\eta_{21} + \eta_{03})$**
7. **$\phi_7 = (3\eta_{21} - \eta_{03})(\eta_{30} + \eta_{12})[(\eta_{30} + \eta_{12})^2 - 3(\eta_{21} + \eta_{03})^2] - (\eta_{30} - 3\eta_{12})(\eta_{21} + \eta_{03})[3(\eta_{30} + \eta_{12})^2 - (\eta_{21} + \eta_{03})^2]$**

### 확장된 불변 모멘트

```csharp
public class InvariantMoments
{
    public enum MomentType
    {
        Hu,      // Hu의 7개 모멘트
        Flusser, // Flusser의 4개 모멘트
        Legendre // Legendre 모멘트
    }
    
    public class MomentResult
    {
        public double[] Moments { get; set; }
        public double Area { get; set; }
        public Point Centroid { get; set; }
        public double Orientation { get; set; }
        public double Eccentricity { get; set; }
    }
    
    public MomentResult ComputeMoments(bool[,] binaryImage, MomentType type = MomentType.Hu)
    {
        int height = binaryImage.GetLength(0);
        int width = binaryImage.GetLength(1);
        
        // 1차 모멘트 계산 (면적, 무게중심)
        double m00 = 0, m10 = 0, m01 = 0;
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (binaryImage[y, x])
                {
                    m00 += 1;           // 면적
                    m10 += x;           // x 모멘트
                    m01 += y;           // y 모멘트
                }
            }
        }
        
        // 무게중심
        double cx = m10 / m00;
        double cy = m01 / m00;
        
        // 2차 중심 모멘트 계산
        double mu20 = 0, mu02 = 0, mu11 = 0;
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (binaryImage[y, x])
                {
                    double dx = x - cx;
                    double dy = y - cy;
                    
                    mu20 += dx * dx;    // x 분산
                    mu02 += dy * dy;    // y 분산
                    mu11 += dx * dy;    // 공분산
                }
            }
        }
        
        // 정규화
        mu20 /= m00;
        mu02 /= m00;
        mu11 /= m00;
        
        // 고유값 계산 (방향성)
        double lambda1 = 0.5 * (mu20 + mu02) + 
            0.5 * Math.Sqrt(Math.Pow(mu20 - mu02, 2) + 4 * mu11 * mu11);
        double lambda2 = 0.5 * (mu20 + mu02) - 
            0.5 * Math.Sqrt(Math.Pow(mu20 - mu02, 2) + 4 * mu11 * mu11);
        
        double orientation = 0.5 * Math.Atan2(2 * mu11, mu20 - mu02);
        double eccentricity = Math.Sqrt(1 - lambda2 / lambda1);
        
        // Hu 모멘트 계산
        double[] moments = null;
        switch (type)
        {
            case MomentType.Hu:
                moments = ComputeHuMoments(binaryImage, cx, cy, m00);
                break;
            case MomentType.Flusser:
                moments = ComputeFlusserMoments(binaryImage, cx, cy, m00);
                break;
        }
        
        return new MomentResult
        {
            Moments = moments,
            Area = m00,
            Centroid = new Point((int)cx, (int)cy),
            Orientation = orientation,
            Eccentricity = eccentricity
        };
    }
    
    private double[] ComputeHuMoments(bool[,] image, double cx, double cy, double m00)
    {
        int height = image.GetLength(0);
        int width = image.GetLength(1);
        
        // 중심 모멘트 계산 (3차까지)
        double[,] mu = new double[4, 4]; // mu[p,q]
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (image[y, x])
                {
                    double dx = x - cx;
                    double dy = y - cy;
                    
                    for (int p = 0; p <= 3; p++)
                    {
                        for (int q = 0; q <= 3 - p; q++)
                        {
                            mu[p, q] += Math.Pow(dx, p) * Math.Pow(dy, q);
                        }
                    }
                }
            }
        }
        
        // 정규화
        for (int p = 0; p <= 3; p++)
        {
            for (int q = 0; q <= 3 - p; q++)
            {
                double gamma = 1 + (p + q) / 2.0;
                mu[p, q] /= Math.Pow(m00, gamma);
            }
        }
        
        // Hu 모멘트 계산
        double[] hu = new double[7];
        
        // φ1 = η20 + η02
        hu[0] = mu[2, 0] + mu[0, 2];
        
        // φ2 = (η20 - η02)² + 4η11²
        hu[1] = Math.Pow(mu[2, 0] - mu[0, 2], 2) + 4 * Math.Pow(mu[1, 1], 2);
        
        // φ3 = (η30 - 3η12)² + (3η21 - η03)²
        hu[2] = Math.Pow(mu[3, 0] - 3 * mu[1, 2], 2) + 
                Math.Pow(3 * mu[2, 1] - mu[0, 3], 2);
        
        // φ4 = (η30 + η12)² + (η21 + η03)²
        hu[3] = Math.Pow(mu[3, 0] + mu[1, 2], 2) + 
                Math.Pow(mu[2, 1] + mu[0, 3], 2);
        
        // φ5-φ7 (더 복잡한 조합)
        // ... 계산 생략 ...
        
        // 로그 스케일 변환 (동적 범위 축소)
        for (int i = 0; i < hu.Length; i++)
        {
            if (Math.Abs(hu[i]) > 1e-10)
                hu[i] = Math.Log(Math.Abs(hu[i]));
            else
                hu[i] = 0;
        }
        
        return hu;
    }
    
    // Flusser의 아핀 불변 모멘트
    private double[] ComputeFlusserMoments(bool[,] image, double cx, double cy, double m00)
    {
        // 2차 및 3차 모멘트 계산
        double mu20 = 0, mu02 = 0, mu11 = 0;
        double mu30 = 0, mu03 = 0, mu21 = 0, mu12 = 0;
        
        for (int y = 0; y < image.GetLength(0); y++)
        {
            for (int x = 0; x < image.GetLength(1); x++)
            {
                if (image[y, x])
                {
                    double dx = x - cx;
                    double dy = y - cy;
                    
                    double dx2 = dx * dx;
                    double dy2 = dy * dy;
                    
                    mu20 += dx2;
                    mu02 += dy2;
                    mu11 += dx * dy;
                    
                    mu30 += dx2 * dx;
                    mu03 += dy2 * dy;
                    mu21 += dx2 * dy;
                    mu12 += dx * dy2;
                }
            }
        }
        
        // 정규화
        double n20 = mu20 / (m00 * m00);
        double n02 = mu02 / (m00 * m00);
        double n11 = mu11 / (m00 * m00);
        double n30 = mu30 / (m00 * m00 * Math.Sqrt(m00));
        double n03 = mu03 / (m00 * m00 * Math.Sqrt(m00));
        double n21 = mu21 / (m00 * m00 * Math.Sqrt(m00));
        double n12 = mu12 / (m00 * m00 * Math.Sqrt(m00));
        
        // Flusser 모멘트
        double[] flusser = new double[4];
        
        flusser[0] = (n20 * n02 - n11 * n11) / Math.Pow(m00, 4);
        flusser[1] = (n30 * n30 * n03 * n03 - 6 * n30 * n21 * n12 * n03 +
                      4 * n30 * n12 * n12 * n12 + 4 * n21 * n21 * n21 * n03 -
                      3 * n21 * n21 * n12 * n12) / Math.Pow(m00, 10);
        
        // 추가 모멘트 계산...
        
        return flusser;
    }
    
    // 모멘트 기반 모양 분류
    public string ClassifyShape(MomentResult moments, Dictionary<string, double[]> trainingData)
    {
        double minDistance = double.MaxValue;
        string bestMatch = "Unknown";
        
        foreach (var entry in trainingData)
        {
            double distance = EuclideanDistance(moments.Moments, entry.Value);
            
            if (distance < minDistance)
            {
                minDistance = distance;
                bestMatch = entry.Key;
            }
        }
        
        return bestMatch;
    }
    
    private double EuclideanDistance(double[] v1, double[] v2)
    {
        double sum = 0;
        int minLength = Math.Min(v1.Length, v2.Length);
        
        for (int i = 0; i < minLength; i++)
        {
            double diff = v1[i] - v2[i];
            sum += diff * diff;
        }
        
        return Math.Sqrt(sum);
    }
}
```

### 모멘트 기반 모양 특징 추출

| 모멘트 차수 | 물리적 의미 | 모양 특성 |
|------------|-------------|-----------|
| **0차 (m00)** | 면적 | 크기 |
| **1차 (m10, m01)** | 무게 중심 | 위치 |
| **2차 (μ20, μ02, μ11)** | 관성 모멘트 | 방향성, 이심률 |
| **3차 이상** | 왜곡도, 첨도 | 비대칭성, 뾰족함 |

### Hu 모멘트의 한계와 대안

**한계:**
1. 정보 중복성 (상관관계 높음)
2. 동적 범위 넓음 (로그 변환 필요)
3. 고차 모멘트는 노이즈에 민감
4. 영역 내부 구분력 낮음

**대안:**
- Zernike 모멘트 (직교 기저 함수)
- Legendre 모멘트 (다항식 기저)
- Wavelet 모멘트 (다중 해상도)

---

## 저니키(Zernike) 모멘트

### 이론적 배경

저니키 모멘트는 단위 원판 위에서 정의된 직교 다항식 시스템을 기반으로 하며, 램지어(Rayleigh)와 저니키(Zernike)에 의해 개발되었다. 회전 불변성과 직교성으로 인해 모양 인식에 매우 효과적이다.

**저니키 다항식 정의:**

$$
V_{nm}(x,y) = V_{nm}(\rho,\theta) = R_{nm}(\rho)e^{jm\theta}
$$

여기서:
- $n$: 차수(non-negative integer)
- $m$: 위상(order), $|m| \le n$, $n - |m|$은 짝수
- $\rho = \sqrt{x^2 + y^2}$: 중심으로부터의 거리
- $\theta = \arctan(y/x)$: 각도
- $R_{nm}(\rho)$: 반경 다항식

**반경 다항식:**

$$
R_{nm}(\rho) = \sum_{k=0}^{(n-|m|)/2} \frac{(-1)^k (n-k)!}{k! \left(\frac{n+|m|}{2}-k\right)! \left(\frac{n-|m|}{2}-k\right)!} \rho^{n-2k}
$$

### 저니키 모멘트 계산

```csharp
public class ZernikeMoments
{
    public class ZernikeMoment
    {
        public int Order { get; set; }      // n
        public int Repetition { get; set; } // m
        public Complex Value { get; set; }  // Z_nm
    }
    
    public List<ZernikeMoment> ComputeZernikeMoments(bool[,] binaryImage, int maxOrder = 10)
    {
        int height = binaryImage.GetLength(0);
        int width = binaryImage.GetLength(1);
        
        // 무게중심 계산
        double m00 = 0, m10 = 0, m01 = 0;
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (binaryImage[y, x])
                {
                    m00 += 1;
                    m10 += x;
                    m01 += y;
                }
            }
        }
        
        double cx = m10 / m00;
        double cy = m01 / m00;
        
        // 최대 반지름 계산
        double maxRadius = 0;
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (binaryImage[y, x])
                {
                    double dx = x - cx;
                    double dy = y - cy;
                    double radius = Math.Sqrt(dx * dx + dy * dy);
                    maxRadius = Math.Max(maxRadius, radius);
                }
            }
        }
        
        List<ZernikeMoment> moments = new List<ZernikeMoment>();
        
        // 차수별 계산
        for (int n = 0; n <= maxOrder; n++)
        {
            for (int m = -n; m <= n; m += 2)
            {
                if (Math.Abs(m) > n) continue;
                
                Complex sum = Complex.Zero;
                
                // 모든 전경 픽셀에 대해 적분
                for (int y = 0; y < height; y++)
                {
                    for (int x = 0; x < width; x++)
                    {
                        if (binaryImage[y, x])
                        {
                            // 정규화 좌표 (-1 ~ 1 범위)
                            double nx = (x - cx) / maxRadius;
                            double ny = (y - cy) / maxRadius;
                            
                            double rho = Math.Sqrt(nx * nx + ny * ny);
                            if (rho > 1.0) continue; // 단위 원 외부
                            
                            double theta = Math.Atan2(ny, nx);
                            
                            // 저니키 다항식 계산
                            Complex polynomial = ComputeZernikePolynomial(n, m, rho, theta);
                            
                            sum += polynomial;
                        }
                    }
                }
                
                // 정규화
                Complex moment = sum * (n + 1) / Math.PI;
                
                moments.Add(new ZernikeMoment
                {
                    Order = n,
                    Repetition = m,
                    Value = moment
                });
            }
        }
        
        return moments;
    }
    
    private Complex ComputeZernikePolynomial(int n, int m, double rho, double theta)
    {
        // 반경 다항식 계산
        double R = ComputeRadialPolynomial(n, Math.Abs(m), rho);
        
        // 각도 부분
        Complex angular = Complex.FromPolarCoordinates(1, m * theta);
        
        // 결합
        return R * angular;
    }
    
    private double ComputeRadialPolynomial(int n, int m, double rho)
    {
        // R_nm(ρ) 계산
        double sum = 0;
        int kMax = (n - m) / 2;
        
        for (int k = 0; k <= kMax; k++)
        {
            double numerator = Factorial(n - k);
            double denominator = Factorial(k) * 
                                Factorial((n + m) / 2 - k) * 
                                Factorial((n - m) / 2 - k);
            
            double term = Math.Pow(-1, k) * numerator / denominator *
                         Math.Pow(rho, n - 2 * k);
            
            sum += term;
        }
        
        return sum;
    }
    
    private double Factorial(int n)
    {
        if (n <= 1) return 1;
        
        double result = 1;
        for (int i = 2; i <= n; i++)
            result *= i;
        
        return result;
    }
    
    // 회전 불변 저니키 모멘트 (크기만 사용)
    public double[] ComputeRotationInvariantMoments(List<ZernikeMoment> zernikeMoments)
    {
        // 동일 차수(n) 내에서 m의 크기 합산
        Dictionary<int, double> invariantMoments = new Dictionary<int, double>();
        
        foreach (var moment in zernikeMoments)
        {
            int n = moment.Order;
            double magnitude = moment.Value.Magnitude;
            
            if (!invariantMoments.ContainsKey(n))
                invariantMoments[n] = 0;
            
            invariantMoments[n] += magnitude * magnitude;
        }
        
        // 정렬된 배열로 변환
        return invariantMoments.OrderBy(kv => kv.Key)
                              .Select(kv => kv.Value)
                              .ToArray();
    }
    
    // 재구성 기능
    public bool[,] ReconstructImage(List<ZernikeMoment> moments, int size)
    {
        bool[,] reconstructed = new bool[size, size];
        double cx = size / 2.0;
        double cy = size / 2.0;
        double radius = size / 2.0;
        
        // 각 픽셀에 대해 재구성
        for (int y = 0; y < size; y++)
        {
            for (int x = 0; x < size; x++)
            {
                double nx = (x - cx) / radius;
                double ny = (y - cy) / radius;
                double rho = Math.Sqrt(nx * nx + ny * ny);
                
                if (rho > 1.0) continue;
                
                double theta = Math.Atan2(ny, nx);
                
                Complex value = Complex.Zero;
                
                // 모든 모멘트 합산
                foreach (var moment in moments)
                {
                    Complex polynomial = ComputeZernikePolynomial(
                        moment.Order, moment.Repetition, rho, theta);
                    
                    value += moment.Value * Complex.Conjugate(polynomial);
                }
                
                // 실수부 사용
                reconstructed[y, x] = value.Real > 0.5;
            }
        }
        
        return reconstructed;
    }
}
```

### 저니키 모멘트의 장단점

**장점:**
1. **회전 불변성**: 자연스러운 회전 불변 특성
2. **직교성**: 정보 중복 최소화
3. **노이즈 강건성**: 고차 모멘트도 비교적 안정적
4. **재구성 가능**: 원본 영상 재구성 가능

**단점:**
1. **계산 복잡도**: 팩토리얼 계산 비용 높음
2. **좌표 정규화 필요**: 단위 원 정규화 필수
3. **구현 복잡**: 재귀적 계산 필요

---

## 기타 모양 기술자

### 체인 코드 (Chain Code)

객체 외곽선을 방향 코드로 표현:

```csharp
public class ChainCode
{
    // 4-방향 코드: 0=동, 1=북, 2=서, 3=남
    // 8-방향 코드: 0=동, 1=북동, 2=북, 3=북서, 4=서, 5=남서, 6=남, 7=남동
    
    public int[] ComputeChainCode4(List<Point> contour)
    {
        if (contour.Count < 2) return new int[0];
        
        int[] codes = new int[contour.Count - 1];
        
        for (int i = 0; i < contour.Count - 1; i++)
        {
            Point current = contour[i];
            Point next = contour[i + 1];
            
            int dx = next.X - current.X;
            int dy = next.Y - current.Y;
            
            // 4-방향 코드로 변환
            if (dx > 0 && dy == 0) codes[i] = 0;      // 동
            else if (dx == 0 && dy < 0) codes[i] = 1; // 북
            else if (dx < 0 && dy == 0) codes[i] = 2; // 서
            else if (dx == 0 && dy > 0) codes[i] = 3; // 남
        }
        
        return codes;
    }
    
    // 차분 체인 코드 (회전 불변)
    public int[] ComputeDifferentialChainCode(int[] chainCode)
    {
        int[] diffCode = new int[chainCode.Length];
        
        for (int i = 0; i < chainCode.Length; i++)
        {
            int next = chainCode[(i + 1) % chainCode.Length];
            int current = chainCode[i];
            
            // 차분 계산 (0-3 범위 유지)
            diffCode[i] = (next - current + 4) % 4;
        }
        
        return diffCode;
    }
}
```

### 시그니처 (Signature)

중심에서 외곽선까지의 거리 함수:

```csharp
public class SignatureDescriptor
{
    public double[] ComputeSignature(List<Point> contour, int numSamples = 360)
    {
        // 무게중심 계산
        double cx = contour.Average(p => p.X);
        double cy = contour.Average(p => p.Y);
        
        double[] signature = new double[numSamples];
        
        for (int i = 0; i < numSamples; i++)
        {
            double angle = 2 * Math.PI * i / numSamples;
            
            // 각도 방향으로 가장 먼 점 찾기
            double maxDistance = 0;
            
            foreach (Point p in contour)
            {
                double dx = p.X - cx;
                double dy = p.Y - cy;
                double pointAngle = Math.Atan2(dy, dx);
                
                // 각도 차이 계산
                double angleDiff = Math.Abs(pointAngle - angle);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                
                // 특정 각도 범위 내 점만 고려
                if (angleDiff < Math.PI / numSamples)
                {
                    double distance = Math.Sqrt(dx * dx + dy * dy);
                    maxDistance = Math.Max(maxDistance, distance);
                }
            }
            
            signature[i] = maxDistance;
        }
        
        return signature;
    }
}
```

### 거리 변환 히스토그램

```csharp
public class DistanceHistogram
{
    public double[] ComputeDistanceHistogram(bool[,] binaryImage, int bins = 20)
    {
        int height = binaryImage.GetLength(0);
        int width = binaryImage.GetLength(1);
        
        // 무게중심
        double m00 = 0, m10 = 0, m01 = 0;
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (binaryImage[y, x])
                {
                    m00 += 1;
                    m10 += x;
                    m01 += y;
                }
            }
        }
        
        double cx = m10 / m00;
        double cy = m01 / m00;
        
        // 거리 계산 및 히스토그램 생성
        double[] histogram = new double[bins];
        double maxDistance = 0;
        List<double> distances = new List<double>();
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (binaryImage[y, x])
                {
                    double dx = x - cx;
                    double dy = y - cy;
                    double distance = Math.Sqrt(dx * dx + dy * dy);
                    
                    distances.Add(distance);
                    maxDistance = Math.Max(maxDistance, distance);
                }
            }
        }
        
        // 히스토그램 빈 채우기
        foreach (double distance in distances)
        {
            int bin = (int)((distance / maxDistance) * (bins - 1));
            histogram[bin]++;
        }
        
        // 정규화
        double total = histogram.Sum();
        if (total > 0)
        {
            for (int i = 0; i < bins; i++)
                histogram[i] /= total;
        }
        
        return histogram;
    }
}
```

---

## 모양 기술자 비교 및 선택 가이드

### 종합 비교표

| 기술자 | 차원 | 불변성 | 계산복잡도 | 노이즈 강건성 | 적합 응용 |
|--------|------|--------|------------|---------------|-----------|
| **Hu 모멘트** | 7-10 | 이동/회전/크기 | 낮음 | 중간 | 빠른 분류 |
| **Zernike 모멘트** | 가변 | 이동/회전/크기 | 높음 | 높음 | 정밀 인식 |
| **푸리에 기술자** | 가변 | 이동/회전/크기 | 중간 | 중간 | 외곽선 분석 |
| **체인 코드** | 가변 | 이동/크기 | 낮음 | 낮음 | 단순 패턴 |
| **시그니처** | 가변 | 이동/회전/크기 | 중간 | 중간 | 방사형 분석 |
| **거리 히스토그램** | 10-50 | 이동/회전/크기 | 중간 | 높음 | 통계적 분석 |

### 성능 평가 메트릭

```csharp
public class ShapeDescriptorEvaluator
{
    public class EvaluationResult
    {
        public string DescriptorName { get; set; }
        public double DiscriminationPower { get; set; } // 구분력
        public double RobustnessToNoise { get; set; }   // 노이즈 강건성
        public double ComputationalTime { get; set; }   // 계산 시간
        public double CompressionRatio { get; set; }    // 압축률
        public double OverallScore { get; set; }        // 종합 점수
    }
    
    public List<EvaluationResult> EvaluateDescriptors(
        List<List<bool[,]>> testShapes, // 여러 클래스의 테스트 영상
        Dictionary<string, Func<bool[,], double[]>> descriptors)
    {
        List<EvaluationResult> results = new List<EvaluationResult>();
        
        foreach (var descriptor in descriptors)
        {
            string name = descriptor.Key;
            var computeFunc = descriptor.Value;
            
            // 1. 구분력 평가 (클래스 간 거리 / 클래스 내 거리)
            double discrimination = EvaluateDiscrimination(
                testShapes, computeFunc);
            
            // 2. 노이즈 강건성 평가
            double robustness = EvaluateRobustness(testShapes, computeFunc);
            
            // 3. 계산 효율성 평가
            double efficiency = EvaluateEfficiency(computeFunc);
            
            // 4. 압축률 평가
            double compression = EvaluateCompression(computeFunc);
            
            // 종합 점수
            double overall = 0.4 * discrimination + 
                           0.3 * robustness + 
                           0.2 * efficiency + 
                           0.1 * compression;
            
            results.Add(new EvaluationResult
            {
                DescriptorName = name,
                DiscriminationPower = discrimination,
                RobustnessToNoise = robustness,
                ComputationalTime = efficiency,
                CompressionRatio = compression,
                OverallScore = overall
            });
        }
        
        return results.OrderByDescending(r => r.OverallScore).ToList();
    }
    
    private double EvaluateDiscrimination(
        List<List<bool[,]>> shapes, 
        Func<bool[,], double[]> descriptorFunc)
    {
        // 클래스 간 분산 / 클래스 내 분산 비율 계산
        // 값이 클수록 구분력 좋음
        
        // 구현 생략...
        return 0.0;
    }
}
```

### 선택 가이드라인

**응용 시나리오별 추천 기술자:**

1. **실시간 산업 검사 (속도 중요)**
   - Hu 모멘트 (7차원)
   - 푸리에 기술자 (10-20차원)

2. **의료 영상 분석 (정확도 중요)**
   - Zernike 모멘트 (20-30차원)
   - Legendre 모멘트

3. **문서/문자 인식**
   - 푸리에 기술자
   - 체인 코드
   - Zernike 모멘트

4. **생체 인식 (지문, 정맥)**
   - 미니유사점 기술자
   - 방향성 히스토그램
   - Gabor 필터 응답

5. **위성/항공 영상**
   - 다중 스케일 기술자
   - 텍스처 + 모양 결합
   - 딥러닝 기반 기술자

---

## 응용 예시: 다중 기술자 결합 시스템

```csharp
public class HybridShapeDescriptor
{
    private FourierDescriptor _fourier = new FourierDescriptor();
    private InvariantMoments _moments = new InvariantMoments();
    private ZernikeMoments _zernike = new ZernikeMoments();
    
    public class HybridFeatures
    {
        public double[] FourierFeatures { get; set; }
        public double[] HuMoments { get; set; }
        public double[] ZernikeFeatures { get; set; }
        public double[] CombinedFeatures { get; set; }
    }
    
    public HybridFeatures ExtractHybridFeatures(bool[,] binaryImage, List<Point> contour)
    {
        HybridFeatures features = new HybridFeatures();
        
        // 1. 푸리에 기술자 (외곽선 기반)
        if (contour.Count >= 8)
        {
            var fourierDescriptors = _fourier.ComputeDescriptors(
                contour, FourierDescriptor.NormalizationType.Complete);
            features.FourierFeatures = _fourier.ExtractFeatureVector(
                fourierDescriptors, 10);
        }
        
        // 2. Hu 모멘트 (영역 기반)
        var momentResult = _moments.ComputeMoments(binaryImage, 
            InvariantMoments.MomentType.Hu);
        features.HuMoments = momentResult.Moments;
        
        // 3. Zernike 모멘트 (직교 기반)
        var zernikeMoments = _zernike.ComputeZernikeMoments(binaryImage, 8);
        features.ZernikeFeatures = _zernike.ComputeRotationInvariantMoments(
            zernikeMoments);
        
        // 4. 특징 통합 (가중 결합)
        features.CombinedFeatures = CombineFeatures(
            features.FourierFeatures,
            features.HuMoments,
            features.ZernikeFeatures);
        
        return features;
    }
    
    private double[] CombineFeatures(double[] fourier, double[] hu, double[] zernike)
    {
        List<double> combined = new List<double>();
        
        // 정규화 및 결합
        if (fourier != null)
            combined.AddRange(NormalizeVector(fourier));
        
        if (hu != null)
            combined.AddRange(NormalizeVector(hu));
        
        if (zernike != null)
            combined.AddRange(NormalizeVector(zernike));
        
        return combined.ToArray();
    }
    
    private double[] NormalizeVector(double[] vector)
    {
        if (vector == null || vector.Length == 0)
            return new double[0];
        
        // Z-점수 정규화
        double mean = vector.Average();
        double std = Math.Sqrt(vector.Select(x => Math.Pow(x - mean, 2)).Sum() / vector.Length);
        
        if (std < 1e-6)
            return vector;
        
        return vector.Select(x => (x - mean) / std).ToArray();
    }
    
    // 다중 커널 SVM을 이용한 분류
    public string ClassifyWithMultipleKernels(HybridFeatures features, 
        Dictionary<string, HybridFeatures> trainingData)
    {
        // 각 기술자별 거리 계산
        Dictionary<string, double> scores = new Dictionary<string, double>();
        
        foreach (var entry in trainingData)
        {
            // 가중 합 거리
            double distance = 
                0.3 * EuclideanDistance(features.FourierFeatures, entry.Value.FourierFeatures) +
                0.4 * EuclideanDistance(features.HuMoments, entry.Value.HuMoments) +
                0.3 * EuclideanDistance(features.ZernikeFeatures, entry.Value.ZernikeFeatures);
            
            scores[entry.Key] = distance;
        }
        
        // 가장 가까운 클래스 반환
        return scores.OrderBy(kv => kv.Value).First().Key;
    }
}
```

---

## 딥러닝 기반 모양 기술자

### CNN 기반 특징 추출

```csharp
public class DeepShapeDescriptor
{
    // 사전 훈련된 CNN 모델 사용 (예: VGG, ResNet)
    public double[] ExtractDeepFeatures(Bitmap image, string modelType = "VGG16")
    {
        // 딥러닝 프레임워크 연동 (TensorFlow.NET, ONNX Runtime 등)
        // 구현 생략
        
        // 일반적인 접근 방식:
        // 1. 이미지 전처리 (크기 조정, 정규화)
        // 2. CNN 모델 통과
        // 3. 풀링 레이어 또는 FC 레이어 출력 추출
        // 4. 특징 벡터 반환
        
        return new double[0]; // 실제 구현 필요
    }
    
    // 오토인코더 기반 특징 학습
    public class AutoencoderDescriptor
    {
        private int inputSize;
        private int latentSize;
        
        public AutoencoderDescriptor(int inputSize, int latentSize)
        {
            this.inputSize = inputSize;
            this.latentSize = latentSize;
        }
        
        public double[] Encode(bool[,] binaryImage)
        {
            // 이미지를 1D 벡터로 변환
            double[] flattened = FlattenImage(binaryImage);
            
            // 오토인코더 인코더 부분 통과
            // (실제 구현은 신경망 라이브러리 필요)
            
            return new double[latentSize]; // 잠재 벡터 반환
        }
        
        private double[] FlattenImage(bool[,] image)
        {
            int height = image.GetLength(0);
            int width = image.GetLength(1);
            double[] flattened = new double[height * width];
            
            for (int y = 0; y < height; y++)
                for (int x = 0; x < width; x++)
                    flattened[y * width + x] = image[y, x] ? 1.0 : 0.0;
            
            return flattened;
        }
    }
}
```

---

## 정리

### 핵심 요약

1. **모양 기술자**는 객체 형상을 수치적 벡터로 변환하여 비교·분류를 가능하게 한다.
2. **전통적 기술자** (Hu, Zernike, 푸리에)는 수학적 기반이 명확하고 해석이 용이하다.
3. **현대적 접근**은 다중 기술자 결합과 딥러닝 기반 특징 학습으로 발전하고 있다.
4. **기술자 선택**은 응용 요구사항(속도, 정확도, 강건성)에 따라 결정되어야 한다.

### 발전 방향

| 분야 | 발전 내용 | 기대 효과 |
|------|----------|-----------|
| **다중 스케일** | 다양한 해상도에서 특징 추출 | 크기 변화 강건성 향상 |
| **딥러닝** | 데이터 기반 특징 학습 | 표현력 향상, 수작업 감소 |
| **3D 모양** | 볼륨 데이터 처리 | 의료, 로봇 비전 적용 |
| **실시간 처리** | 하드웨어 가속 (GPU, FPGA) | 산업 검사 속도 향상 |
| **시멘틱 기술자** | 의미 기반 모양 이해 | 고수준 분석 가능 |

### 실무 권장사항

1. **단일 기술자보다 다중 기술자 결합**이 일반적으로 더 나은 성능 제공
2. **도메인 특화** 기술자 개발이 중요 (산업별 최적화)
3. **전처리 정규화**가 기술자 성능에 큰 영향 미침
4. **기술자 선택 전에 항상 성능 평가** 수행 필요
5. **전통적 방법과 딥러닝 방법의 장단점 고려**하여 선택

모양 기술자는 컴퓨터 비전의 핵심 구성 요소로, 적절한 기술자 선택과 적용은 시스템 성능을 결정하는 중요한 요소이다. 전통적 방법의 명확한 수학적 해석과 딥러닝 방법의 강력한 표현력을 적절히 결합하는 것이 현대적 접근법이다.