---
layout: post
title: Avalonia - 라이트-다크 모드
date: 2025-01-12 19:20:23 +0900
category: Avalonia
---
# Avalonia에서 다크/라이트 모드 전환 기능 구현

## 0. 전체 구조

```
MyAvaloniaApp/
├── Themes/
│   ├── DarkTheme.axaml             # 색/브러시 등 리소스 (ResourceDictionary)
│   └── LightTheme.axaml
├── Styles/
│   └── Controls.axaml              # 컨트롤 공통 스타일(선택)
├── Services/
│   ├── ISettingsService.cs
│   ├── SettingsService.cs
│   └── ThemeService.cs             # 테마 로딩/교체 로직
├── ViewModels/
│   └── ThemeViewModel.cs
├── Views/
│   └── ThemeToggleView.axaml
├── Models/
│   └── AppSettings.cs
├── App.axaml
└── Program.cs
```

---

## 1. 테마 리소스 정의(색/브러시) — Light/Dark

> 컨트롤의 모양(Template)과 색/브러시는 역할이 다르다. **색·브러시·두께 등은 ResourceDictionary**로, Template/Style은 Styles에 넣는 편이 유지보수에 유리하다.

### 1.1 `Themes/LightTheme.axaml`

```xml
<ResourceDictionary xmlns="https://github.com/avaloniaui">
  <!-- 식별 마커: 런타임 교체를 쉽게 하기 위한 키 -->
  <x:String xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" x:Key="__ThemeMarker">Light</x:String>

  <!-- 색상 팔레트 -->
  <Color x:Key="Color.Background">#FFFFFFFF</Color>
  <Color x:Key="Color.Foreground">#FF101010</Color>
  <Color x:Key="Color.Accent">#FF0067C0</Color>
  <Color x:Key="Color.Border">#FFE0E0E0</Color>

  <!-- 브러시 -->
  <SolidColorBrush x:Key="Brush.Background" Color="{DynamicResource Color.Background}" />
  <SolidColorBrush x:Key="Brush.Foreground" Color="{DynamicResource Color.Foreground}" />
  <SolidColorBrush x:Key="Brush.Accent"     Color="{DynamicResource Color.Accent}" />
  <SolidColorBrush x:Key="Brush.Border"     Color="{DynamicResource Color.Border}" />
</ResourceDictionary>
```

### 1.2 `Themes/DarkTheme.axaml`

```xml
<ResourceDictionary xmlns="https://github.com/avaloniaui">
  <x:String xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" x:Key="__ThemeMarker">Dark</x:String>

  <Color x:Key="Color.Background">#FF1E1E1E</Color>
  <Color x:Key="Color.Foreground">#FFF1F1F1</Color>
  <Color x:Key="Color.Accent">#FF3399FF</Color>
  <Color x:Key="Color.Border">#FF2A2A2A</Color>

  <SolidColorBrush x:Key="Brush.Background" Color="{DynamicResource Color.Background}" />
  <SolidColorBrush x:Key="Brush.Foreground" Color="{DynamicResource Color.Foreground}" />
  <SolidColorBrush x:Key="Brush.Accent"     Color="{DynamicResource Color.Accent}" />
  <SolidColorBrush x:Key="Brush.Border"     Color="{DynamicResource Color.Border}" />
</ResourceDictionary>
```

> 포인트
> - **키 네이밍 규칙**을 정해두면, 대규모 앱에서도 충돌 없이 확장 가능하다.
> - **`DynamicResource`** 를 사용하면 런타임 교체 시점에 즉시 반영된다.

---

## 2. App 진입점에서 기본 스타일/리소스 구성

- FluentTheme: 컨트롤 룩앤필(플루언트 기반)
- Application.Resources.MergedDictionaries: **현재 테마 리소스 사전**

### 2.1 `App.axaml`

```xml
<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyAvaloniaApp.App">
  <Application.Styles>
    <!-- 컨트롤 기본 테마(플루언트) -->
    <FluentTheme Mode="Light"/>
    <!-- 선택: 공통 컨트롤 스타일(템플릿)은 Styles/Controls.axaml에 -->
    <!-- <StyleInclude Source="avares://MyAvaloniaApp/Styles/Controls.axaml"/> -->
  </Application.Styles>

  <!-- 전역 리소스 -->
  <Application.Resources>
    <ResourceDictionary>
      <!-- 앱 시작 시 Light 로드: 런타임 교체 대상 -->
      <ResourceDictionary.MergedDictionaries>
        <ResourceInclude Source="avares://MyAvaloniaApp/Themes/LightTheme.axaml" />
      </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
  </Application.Resources>
</Application>
```

> 주의
> - **색/브러시 테마는 Resources.MergedDictionaries에서 교체**하는 것이 안전하다.
> - `Application.Styles`는 Styles(IStyle) 목록이며, `ResourceDictionary`는 리소스다. 역할이 다르므로 섞지 않는다.

---

## 3. ThemeService: 테마 로딩/교체 유틸리티

리소스 사전을 교체할 때 **기존 테마 사전을 찾아 제거**하고, 새 사전을 추가한다. 마커 키(`__ThemeMarker`)로 찾으면 안전하다.

### 3.1 `Services/ThemeService.cs`

```csharp
using Avalonia;
using Avalonia.Markup.Xaml;
using System;
using System.Linq;

namespace MyAvaloniaApp.Services;

public static class ThemeService
{
    private const string ThemeMarkerKey = "__ThemeMarker";

    public static string? CurrentThemeName
        => FindThemeDictionary()?.ContainsKey(ThemeMarkerKey) == true
           ? FindThemeDictionary()?[ThemeMarkerKey]?.ToString()
           : null;

    public static void ApplyTheme(string themeName) // "Light" | "Dark"
    {
        var app = Application.Current ?? throw new InvalidOperationException("Application not ready.");
        var resources = app.Resources;

        // 1) 기존 테마 사전 제거
        var existing = FindThemeDictionary();
        if (existing != null)
            resources.MergedDictionaries.Remove(existing);

        // 2) 새 테마 로드
        var uri = themeName.Equals("Dark", StringComparison.OrdinalIgnoreCase)
            ? new Uri("avares://MyAvaloniaApp/Themes/DarkTheme.axaml")
            : new Uri("avares://MyAvaloniaApp/Themes/LightTheme.axaml");

        var include = new ResourceInclude(uri) { Source = uri };

        resources.MergedDictionaries.Add(include);
    }

    private static ResourceDictionary? FindThemeDictionary()
    {
        var app = Application.Current;
        if (app == null) return null;

        return app.Resources.MergedDictionaries
            .OfType<ResourceDictionary>()
            .FirstOrDefault(d => d.ContainsKey(ThemeMarkerKey));
    }
}
```

---

## 4. Settings 저장/복원

### 4.1 모델 — `Models/AppSettings.cs`

```csharp
namespace MyAvaloniaApp.Models;

public sealed class AppSettings
{
    public bool IsDarkMode { get; set; }
}
```

### 4.2 서비스 — `Services/ISettingsService.cs`

```csharp
using System.Threading.Tasks;
using MyAvaloniaApp.Models;

namespace MyAvaloniaApp.Services;

public interface ISettingsService
{
    Task SaveAsync(AppSettings settings);
    Task<AppSettings> LoadAsync();
}
```

### 4.3 구현 — `Services/SettingsService.cs`

```csharp
using System.IO;
using System.Text.Json;
using System.Threading.Tasks;
using MyAvaloniaApp.Models;

namespace MyAvaloniaApp.Services;

public sealed class SettingsService : ISettingsService
{
    private const string FileName = "appsettings.json";

    public async Task SaveAsync(AppSettings settings)
    {
        var json = JsonSerializer.Serialize(settings, new JsonSerializerOptions { WriteIndented = true });
        await File.WriteAllTextAsync(FileName, json);
    }

    public async Task<AppSettings> LoadAsync()
    {
        if (!File.Exists(FileName))
            return new AppSettings { IsDarkMode = false };

        var json = await File.ReadAllTextAsync(FileName);
        return JsonSerializer.Deserialize<AppSettings>(json) ?? new AppSettings();
    }
}
```

---

## 5. ThemeViewModel: MVVM 전환

- `IsDark` 토글 → ThemeService.ApplyTheme 호출
- 저장/복원은 SettingsService로 처리

### 5.1 `ViewModels/ThemeViewModel.cs`

```csharp
using ReactiveUI;
using System.Reactive;
using System.Threading.Tasks;
using MyAvaloniaApp.Models;
using MyAvaloniaApp.Services;

namespace MyAvaloniaApp.ViewModels;

public sealed class ThemeViewModel : ReactiveObject
{
    private readonly ISettingsService _settings;
    private bool _isDark;

    public bool IsDark
    {
        get => _isDark;
        set => this.RaiseAndSetIfChanged(ref _isDark, value);
    }

    public ReactiveCommand<Unit, Unit> ApplyCommand { get; }
    public ReactiveCommand<Unit, Unit> SaveCommand  { get; }
    public ReactiveCommand<Unit, Unit> LoadCommand  { get; }

    public ThemeViewModel()
        : this(new SettingsService()) {}

    public ThemeViewModel(ISettingsService settings)
    {
        _settings = settings;

        ApplyCommand = ReactiveCommand.Create(ApplyTheme);
        SaveCommand  = ReactiveCommand.CreateFromTask(SaveAsync);
        LoadCommand  = ReactiveCommand.CreateFromTask(LoadAsync);
    }

    private void ApplyTheme()
    {
        ThemeService.ApplyTheme(IsDark ? "Dark" : "Light");
        // FluentTheme의 ThemeVariant도 함께 바꾸고 싶다면 아래 선택:
        // var app = Avalonia.Application.Current;
        // app!.RequestedThemeVariant = IsDark ? ThemeVariant.Dark : ThemeVariant.Light;
    }

    private async Task SaveAsync()
    {
        await _settings.SaveAsync(new AppSettings { IsDarkMode = IsDark });
    }

    private async Task LoadAsync()
    {
        var s = await _settings.LoadAsync();
        IsDark = s.IsDarkMode;
        ApplyTheme();
    }
}
```

---

## 6. View: 토글 + 적용 버튼 + 저장/불러오기

### 6.1 `Views/ThemeToggleView.axaml`

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:MyAvaloniaApp.ViewModels"
             x:Class="MyAvaloniaApp.Views.ThemeToggleView"
             Width="360" Height="160">

  <UserControl.DataContext>
    <vm:ThemeViewModel/>
  </UserControl.DataContext>

  <StackPanel Margin="20" Spacing="8"
              Background="{DynamicResource Brush.Background}">
    <TextBlock Text="테마 전환"
               Foreground="{DynamicResource Brush.Foreground}"
               FontSize="18" />

    <ToggleSwitch IsChecked="{Binding IsDark}"
                  Content="다크 모드"
                  Foreground="{DynamicResource Brush.Foreground}"/>

    <StackPanel Orientation="Horizontal" Spacing="8">
      <Button Content="테마 적용" Command="{Binding ApplyCommand}"/>
      <Button Content="저장" Command="{Binding SaveCommand}"/>
      <Button Content="불러오기" Command="{Binding LoadCommand}"/>
    </StackPanel>

    <Border BorderBrush="{DynamicResource Brush.Border}" BorderThickness="1" Padding="8">
      <TextBlock Text="프리뷰: 이 영역의 배경/전경/테두리는 현재 테마 리소스로 그려집니다."
                 Foreground="{DynamicResource Brush.Foreground}"
                 TextWrapping="Wrap"/>
    </Border>
  </StackPanel>
</UserControl>
```

> 핵심: **`{DynamicResource}`** 로 연결된 색/브러시가 리소스 사전 교체 즉시 반영된다.

---

## 7. 뷰에서 테마 리소스 사용 예시

### 7.1 기존 View에 적용 — `MainView.axaml`

```xml
<StackPanel Background="{DynamicResource Brush.Background}" Padding="20" Spacing="8">
  <TextBlock Text="테마 테스트" Foreground="{DynamicResource Brush.Foreground}" FontSize="22"/>
  <Button Content="확인" Background="{DynamicResource Brush.Accent}" />
  <Border BorderBrush="{DynamicResource Brush.Border}" BorderThickness="1" Height="1"/>
</StackPanel>
```

---

## 8. ThemeVariant와 FluentTheme(선택)

Avalonia는 **ThemeVariant.Light / Dark / HighContrast**를 제공한다.
`Application.RequestedThemeVariant`에 설정하면 FluentTheme가 제공하는 기본 팔레트와 일부 스타일이 바뀐다.

```csharp
// 추가 옵션: VM의 ApplyTheme에서 테마 가변
var app = Avalonia.Application.Current;
if (app is not null)
    app.RequestedThemeVariant = IsDark ? Avalonia.Styling.ThemeVariant.Dark
                                       : Avalonia.Styling.ThemeVariant.Light;
```

> 팁
> - 본문에서는 **색/브러시 테마를 ResourceDictionary로 관리**하고, FluentTheme는 기본 룩앤필 용도로 둔다.
> - 제품 요구에 따라 두 체계를 **병행**할 수 있다(FluentTheme Variant + 사용자 정의 팔레트).

---

## 9. 전역 vs 지역 테마

- **전역(Global)**: `Application.Resources.MergedDictionaries` 교체 → 앱 전체에 즉시 반영
- **지역(Local)**: 특정 `Window` 또는 `UserControl`의 `Resources.MergedDictionaries`에 테마 사전을 추가 → 해당 범위만 덮어쓰기

예시(윈도우 전용 다크 테마):

```xml
<Window ...>
  <Window.Resources>
    <ResourceDictionary>
      <ResourceDictionary.MergedDictionaries>
        <ResourceInclude Source="avares://MyAvaloniaApp/Themes/DarkTheme.axaml"/>
      </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
  </Window.Resources>

  <!-- 이 Window 내부만 다크 팔레트 -->
</Window>
```

---

## 10. 시스템 테마 감지(옵션)

시작 시 OS 테마를 기본값으로 사용하고 싶다면 다음과 같이 초기화할 수 있다.

```csharp
// App.axaml.cs 또는 Startup 로직에서
protected override void OnFrameworkInitializationCompleted()
{
    base.OnFrameworkInitializationCompleted();

    var app = Application.Current!;
    var platform = app.PlatformSettings;
    var isSystemDark = platform?.GetColorValues()?.ThemeVariant == Avalonia.Styling.ThemeVariant.Dark;

    ThemeService.ApplyTheme(isSystemDark == true ? "Dark" : "Light");

    // 이후 SettingsService로 저장된 값이 있으면 그것을 우선 적용
}
```

> 주의: 플랫폼별 동작이 다를 수 있다. 저장된 사용자 설정이 있다면 **저장값**을 최우선으로 적용하고, 없을 때만 시스템 테마를 기본값으로 삼는 것이 일반적이다.

---

## 11. 단위 테스트(간단 검증 포인트)

테마 교체는 UI 리소스에 영향을 주므로 완전한 자동화는 제한적이지만, 교체 후 마커 확인 정도는 가능하다.

```csharp
using Xunit;
using MyAvaloniaApp.Services;

public class ThemeServiceTests
{
    [Fact]
    public void ApplyTheme_SetsMarker()
    {
        // App 초기화가 된 환경에서만 동작(통합 테스트 성격)
        ThemeService.ApplyTheme("Dark");
        Assert.Equal("Dark", ThemeService.CurrentThemeName);

        ThemeService.ApplyTheme("Light");
        Assert.Equal("Light", ThemeService.CurrentThemeName);
    }
}
```

---

## 12. 문제 해결 체크리스트

- 런타임 교체가 반영되지 않음
  → `DynamicResource`를 사용했는지 확인. `StaticResource`는 교체 시점에 재평가되지 않는다.
- 테마 파일을 `Application.Styles`에 넣음
  → 색/브러시 리소스는 `Application.Resources`에 넣는다. Styles와 Resources의 역할 구분.
- 교체 대상 찾기 어려움
  → 리소스 사전에 마커 키(`__ThemeMarker`)를 넣고 이를 기준으로 제거/교체하라.
- FluentTheme만 바꾸면 색이 안 바뀜
  → FluentTheme는 컨트롤 룩앤필/팔레트 중심. 사용자 지정 팔레트는 별도 리소스로 둔다.
- 저장/복원 순서 문제
  → 앱 시작 시 시스템 테마 → 저장된 설정이 있으면 덮어쓰기 → 초기 화면 진입.

---

## 13. 성능·설계 팁

- 테마 사전 내부에서 **`DynamicResource`로 연결된 2단 구조**(Color → Brush)를 유지하면, 특정 색만 교체해도 브러시가 자동 갱신된다.
- 자주 쓰는 색상 키를 **명명 규칙**으로 일원화(`Color.*`, `Brush.*`)하면 대규모 확장/리팩터링이 수월하다.
- 컨트롤 스타일(템플릿)은 `Styles/Controls.axaml` 등으로 분리하여 테마와 독립적으로 진화시킨다.
- 고급 사용: `ThemeDictionary`(Light/Dark 분기 포함)나 `ThemeVariant`별 스타일을 병행하면, 복잡한 시나리오에서도 일관성 있는 전환이 가능하다.

---

## 14. 결론

- **리소스 기반 테마**를 `Application.Resources.MergedDictionaries`로 관리하고, **`DynamicResource`** 를 사용해 런타임 전환을 실시간 반영하라.
- 전환 로직은 **ThemeService**로 캡슐화, UI는 **ThemeViewModel**로 제어(MVVM).
- **SettingsService**로 사용자 선택을 저장/복원하여, 재실행 후에도 동일한 테마를 유지하라.
- 필요 시 **ThemeVariant**(FluentTheme), **지역 테마**, **시스템 테마 감지**를 조합해 완성도를 높일 수 있다.

이 구조를 기반으로 색상 토큰 확장, 하이 콘트라스트 테마, 브랜드 테마(예: Blue/Green)까지 자연스럽게 확장 가능하다.
