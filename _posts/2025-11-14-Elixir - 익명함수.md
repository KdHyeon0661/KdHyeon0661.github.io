---
layout: post
title: Elixir - 익명함수
date: 2025-11-14 19:25:23 +0900
category: Elixir
---
# 엘릭서 5장 — 함수와 패턴 매칭, 고차 함수, 함수형 스타일 완전 정리

> 목표
> - 엘릭서의 **함수, 패턴 매칭, 가드, 멀티 클로즈, 고차 함수**를 한 번에 정리한다.
> - “함수 헤드 = 계약(contract)” 이라는 관점을 중심으로, **입력 형태·타입·규칙**을 코드 레벨에서 표현하는 방법을 익힌다.
> - `Enum`/`Stream`/`Task`·콜백·클로저·의존성 주입까지 실전에서 쓰이는 패턴을 코드와 함께 정리한다.

---

## 함수와 패턴 매칭 (Functions with Pattern Matching)

엘릭서에서 **함수 헤드**는 단순히 “이름 + 인자”를 넘어서 **입력 계약**의 역할을 한다.

- 어떤 모양의 값만 받는지
- 타입은 무엇인지
- 값에 어떤 제약(음수 금지, 길이 제한 등)이 있는지

이것을 **함수 본문 안 if/else** 로 풀어 쓰는 대신,
**함수 헤드의 패턴과 가드**에 “선언적으로” 적는 것이 엘릭서 스타일이다.

---

### 인자 자리에서의 패턴

가장 대표적인 예: **태그드 튜플(tagged tuple)** 로 타입 구분하기.

```elixir
defmodule Shape do
  # {:rect, w, h}
  def area({:rect, w, h}) when is_number(w) and is_number(h) and w >= 0 and h >= 0 do
    w * h
  end

  # {:circle, r}
  def area({:circle, r}) when is_number(r) and r > 0 do
    :math.pi() * r * r
  end

  # 나머지 모든 입력
  def area(_), do: {:error, :bad_shape}
end
```

여기서 드러나는 규칙:

- **패턴**: `{:rect, w, h}` / `{:circle, r}`
  - “이 함수는 **태그드 튜플**만 받는다.”
  - 잘못된 태그나 인자 수가 들어오면 마지막 절로 떨어진다.
- **가드(when)**: `is_number/1`, `r > 0`, `w >= 0`
  - “숫자여야 하고, 양수여야 한다.”
  - 조건을 만족 못 하면 다음 절로 넘어간다.

이 코드는 **if/else** 로 풀면 대략 이렇게 된다:

```elixir
def area(shape) do
  case shape do
    {:rect, w, h} when is_number(w) and is_number(h) and w >= 0 and h >= 0 ->
      w * h

    {:circle, r} when is_number(r) and r > 0 ->
      :math.pi() * r * r

    _ ->
      {:error, :bad_shape}
  end
end
```

즉, **멀티 클로즈 함수**는 내부적으로는 **패턴이 있는 case** 의 문법 설탕(sugar)에 가깝다.

---

#### “입력 계약”을 문서 대신 코드로

위 예제에서 문서 없이도 다음을 알 수 있다.

- `area/1` 는 **단위 없는 scalar** 를 직접 받지 않는다.
- `area/1` 는 **튜플 + 태그** 가 필요하다.
- 잘못된 입력은 `{:error, :bad_shape}` 로 정리된다.

즉, 타입/계약/에러 모델이 **함수 헤드에 드러난다**.

---

### 리스트, 맵, 바이너리 분해하기

함수 인자 자리에서는 **리스트/맵/문자열/바이너리** 를 바로 분해할 수 있다.
이를 잘 활용하면 본문이 훨씬 단순해진다.

```elixir
defmodule Parser do
  # 문자열 접두부 패턴
  def parse("OK:" <> rest),  do: {:ok, String.trim(rest)}
  def parse("ERR:" <> rest), do: {:error, String.trim(rest)}
  def parse(_),              do: :unknown

  # 맵: 필수 키 강제
  def id(%{id: id}) when is_integer(id), do: {:ok, id}
  def id(_), do: :error

  # 바이너리: 1바이트 타입 + 16비트 길이 + 본문 + 나머지
  def frame(<<type::8, len::16, body::binary-size(len), rest::binary>>) do
    {:ok, %{type: type, body: body}, rest}
  end

  def frame(_), do: :incomplete
end
```

설명:

- `"OK:" <> rest`
  - 문자열이 `"OK:"` 로 시작하면 나머지를 `rest`로 받는다.
  - 인덱스/substring 없이 **형태만으로** 분기된다.
- `%{id: id}`
  - `id` 키가 반드시 있어야 한다. 없으면 다른 절로 간다 (`:error`).
- `<<type::8, len::16, body::binary-size(len), rest::binary>>`
  - **바이너리 패턴**으로 “헤더 + 페이로드 + 나머지”를 한 번에 파싱.

이런 방식의 장점:

1. **본문이 짧고 명료**하다.
2. “입력이 조금이라도 기대와 다르면” **다른 절**로 떨어진다.
3. 여러 종류의 메시지를 명확히 구분할 수 있다.

---

### 핀(^)으로 외부 값 고정하기

2장에서 본 **핀 연산자(`^`)** 는 함수 헤드에서도 똑같이 사용된다.
“**외부에서 이미 가진 값**과 일치하는 경우만 이 절을 타라”는 의미다.

```elixir
defmodule Filter do
  def only_key(%{^key => v}, key), do: {:ok, v}
  def only_key(_, _), do: :error
end

key = :name
Filter.only_key(%{name: "Kim"}, key)  # {:ok, "Kim"}
Filter.only_key(%{age: 20}, key)      # :error
```

- `%{^key => v}`
  - “키가 **바깥에서 받은 key 값**이어야 한다.”
  - 바깥의 `key` 를 **패턴에서 재바인딩하지 않고 고정**한다.

이를 이용하면, **동적 키** 를 사용하면서도
패턴 매칭의 강력함을 그대로 살릴 수 있다.

---

### 인자 패턴 vs 본문 if/else — 스타일 비교

같은 로직을 **나쁜 스타일**로 쓴다면 아래처럼 된다.

```elixir
def area_bad(shape) do
  if is_tuple(shape) do
    case shape do
      {:rect, w, h} ->
        if is_number(w) and is_number(h) and w >= 0 and h >= 0 do
          w * h
        else
          {:error, :bad_shape}
        end

      {:circle, r} ->
        if is_number(r) and r > 0 do
          :math.pi() * r * r
        else
          {:error, :bad_shape}
        end

      _ ->
        {:error, :bad_shape}
    end
  else
    {:error, :bad_shape}
  end
end
```

차이점:

| 관점 | 인자 패턴/가드 | if/else/중첩 case |
|------|----------------|-------------------|
| 계약 표현 | 함수 헤드에서 선명 | 본문에 숨음 |
| 실패 시점 | 매칭 단계에서 즉시 | 깊은 분기 안에서 발생 |
| 가독성 | 짧고 규칙이 드러남 | 중첩이 깊어짐 |
| 테스트 | “틀린 입력”이 잘 드러남 | 분기별로 일일이 탐색 필요 |

엘릭서에서는 **가능한 한 “형태”와 “기본 검증”을 함수 헤드로 올리고**,
본문은 **정말 핵심 계산만 남기는 패턴**을 선호한다.

---

## 함수는 하나, 본문은 여러 개 (Multi-clause Functions)

동일한 **이름 + 아리티(arity)** 를 가진 함수를 여러 번 선언할 수 있다.
각 선언이 하나의 “클로즈(clause)”가 되고,
**패턴/가드에 따라 적절한 클로즈가 선택**되는 구조가 된다.

---

### 기본 멀티 클로즈 예제

```elixir
defmodule Auth do
  # 비밀번호 기반
  def login(%{provider: :password, email: e, pass: p})
      when is_binary(e) and is_binary(p) do
    {:ok, {:local, e}}
  end

  # OAuth 기반
  def login(%{provider: :oauth, token: t})
      when is_binary(t) and byte_size(t) > 0 do
    {:ok, {:oauth, t}}
  end

  # 그 외 모든 케이스
  def login(_), do: {:error, :bad_params}
end
```

특징:

- 모두 **`login/1`** 이다. (arity = 1)
- 순서는 위에서 아래로 매칭된다.
  - **보다 구체적인 패턴**을 위에 두는 것이 좋다.
- “비밀번호 로그인과 OAuth 로그인”의 규칙이 **함수 헤드에 드러난다**.

---

### 가드로 비즈니스 규칙 “문장화”

```elixir
defmodule Discount do
  # 골드 고객 + 큰 금액
  def rate(%{tier: :gold, amount: a})
      when is_number(a) and a >= 1000 do
    0.2
  end

  # 골드 고객 + 일반 금액
  def rate(%{tier: :gold}), do: 0.15

  # 실버 고객
  def rate(%{tier: :silver}), do: 0.1

  # 그 외 티어
  def rate(%{tier: _}), do: 0.0

  # 키 자체가 없으면 그냥 0
  def rate(_), do: 0.0
end
```

이 코드는 비즈니스 규칙을 **거의 자연어처럼** 읽을 수 있다.

- “골드이고, amount >= 1000이면 20%”
- “골드이면 15%”
- …

if/else 로 구현하면 규칙이 섞이지만,
멀티 클로즈 + 가드 구조에서는 **규칙이 나란히 서 있는 느낌**을 준다.

---

### 기본값 인자 vs 멀티 클로즈

기본값 인자는 사실 컴파일 시 **별도 함수**로 변환된다.

```elixir
def ping(url, timeout \\ 1000)
def ping(url, timeout) when is_binary(url) and is_integer(timeout) do
  {:ok, url, timeout}
end
def ping(_, _), do: {:error, :bad}
```

위 코드는 컴파일 시 대략:

- `ping/1` : `ping(url)` → `ping(url, 1000)` 을 호출
- `ping/2` : 실제 로직

이 방식이 좋은 이유:

- **기본값 선언**과 **실제 계약(패턴/가드)** 가 분리되어
  읽기에 좋고,
- 컴파일러가 만드는 “숨은 함수”를 의식하지 않아도 된다.

반대로 다음처럼 쓰면 매칭 순서가 헷갈릴 수 있다.

```elixir
# 권장하지 않는 스타일

def ping(url, timeout \\ 1000) when is_binary(url) and is_integer(timeout), do: ...
def ping(_, _), do: ...
```

- 내부적으로 어떤 순서로 확장되는지 헷갈리므로
  **기본값 선언과 구현을 분리하는 패턴**을 추천한다.

---

### 재귀와 꼬리 재귀 최적화(TCO 유사)

BEAM은 **꼬리 위치(tail position)** 에서 자기 자신을 호출할 때
**스택 프레임을 재사용**하도록 최적화한다.

대표 예: 리스트 합.

```elixir
defmodule Sum do
  # 공개 함수: 사용자에게 노출되는 인터페이스
  def list(xs), do: do_list(xs, 0)

  # 꼬리 재귀 내부 함수
  defp do_list([h | t], acc), do: do_list(t, acc + h)
  defp do_list([], acc), do: acc
end

Sum.list([1,2,3])   # 6
```

여기서 `do_list/2` 의 첫 번째 절:

```elixir
defp do_list([h | t], acc), do: do_list(t, acc + h)
```

- 마지막 동작이 `do_list/2` 호출이다.
- 그 뒤에 아무 연산도 없다.
- 이게 **꼬리 위치**이다.

이런 꼬리 재귀를 사용하면,

- 시간 복잡도: $$O(n)$$
- **추가 스택 공간**: 입력 길이에 비례해서 증가하지 않고,
  “현재 프레임”만 유지하는 수준이다.

반대로 꼬리 재귀가 아닌 형태:

```elixir
def bad_sum([h | t]), do: h + bad_sum(t)
def bad_sum([]), do: 0
```

- 마지막 동작이 `+` 이다.
- `bad_sum(t)` 호출 뒤에도 덧셈이 남아 있다.
- 재귀 깊이만큼 스택을 쌓아야 한다.

작은 입력에는 상관 없지만,
긴 리스트에 대해 반복 호출한다면
**꼬리 재귀 형태**로 바꾸는 것이 안전하다.

---

### 재귀와 멀티 클로즈를 이용한 여러 예제

#### 리스트 길이 구하기

```elixir
defmodule Length do
  def of(list), do: do_of(list, 0)

  defp do_of([_h | t], acc), do: do_of(t, acc + 1)
  defp do_of([], acc), do: acc
end
```

#### 리스트 필터링

```elixir
defmodule MyFilter do
  def keep_even(xs), do: do_keep_even(xs, [])

  defp do_keep_even([h | t], acc) when rem(h, 2) == 0,
    do: do_keep_even(t, [h | acc])

  defp do_keep_even([_h | t], acc),
    do: do_keep_even(t, acc)

  defp do_keep_even([], acc),
    do: :lists.reverse(acc)
end
```

- 이 예제는 2장에서 배운 **리스트 패턴, 가드, prepend + reverse 패턴**을
  다시 활용한 것이다.

---

## 함수를 반환하는 함수 (Functions that Return Functions)

엘릭서에서 **함수도 값**이다.
따라서 함수를 **반환(return)** 해서 **설정/환경을 캡처**하거나,
**동작을 조합**하는 것이 가능하다.

이 때 만들어지는 객체를 **클로저(closure)** 라고 부른다.

---

### 클로저로 “설정 바인딩”하기

```elixir
defmodule Greeter do
  def make(prefix) when is_binary(prefix) do
    fn name -> prefix <> ": " <> name end
  end
end

hello = Greeter.make("Hello")
hello.("Kim")  # "Hello: Kim"

warn = Greeter.make("[WARN]")
warn.("disk full")  # "[WARN]: disk full"
```

`make/1` 를 분석해보자.

- 인자: `prefix`
- 반환: `fn name -> ... end` 익명 함수
- 이 익명 함수는 **외부의 prefix** 를 캡처하고 있다.

즉, 각 호출 시점의 `prefix` 값을 **함수 안에 가둬서**
“설정이 다른 greeter” 를 여러 개 만드는 것이다.

---

### 조립

고차 함수 패턴은 **검증 로직**에서 특히 강력하다.

```elixir
defmodule Validate do
  def min_len(n) do
    fn s -> is_binary(s) and String.length(s) >= n end
  end

  def has?(substr) do
    fn s -> is_binary(s) and String.contains?(s, substr) end
  end

  def all(preds) do
    fn x -> Enum.all?(preds, & &1.(x)) end
  end

  def any(preds) do
    fn x -> Enum.any?(preds, & &1.(x)) end
  end
end

v = Validate.all([
  Validate.min_len(5),
  Validate.has?("@")
])

v.("kim@ex")   # true
v.("kim")      # false
```

- `min_len/1`, `has?/1` 은 **단일 조건**을 검사하는 작은 함수 생성기.
- `all/1`, `any/1` 는 여러 조건을 조립한다.

이런 패턴은:

- 비밀번호 규칙,
- 사용자 입력 필터,
- 폼 검증 등에 그대로 사용 가능하다.

---

### 캡처 연산자 `&` 와 부분 적용 흉내

자주 보는 패턴:

```elixir
inc   = &(&1 + 1)              # 인자 1개
pow   = &:math.pow/2           # 모듈/함수 캡처
square = &pow.(&1, 2.0)        # 두 번째 인자를 2로 고정
Enum.map([1, 2, 3], square)    # [1.0, 4.0, 9.0]
```

- `&:math.pow/2` : `&MODULE.fun/arity` 형태 캡처
- `square = &pow.(&1, 2.0)` : 클로저를 한 번 더 감싸서
  “두 번째 인자 고정”을 구현

이런 식으로, 정식 커링이 없어도
**인자 일부를 고정한 함수(부분 적용)** 를 쉽게 만들 수 있다.

---

### 리소스 관리: “정리자(cleanup)” 반환

클로저는 **정리 작업**을 함께 전달할 때도 유용하다.

```elixir
defmodule TempFile do
  def with_tmp(prefix \\ "tmp") do
    # 실제로는 임시 파일 생성 라이브러리나 File 모듈을 사용할 수 있다.
    {:ok, path} = File.mktemp(prefix <> "_")  # 예시용 (실제 구현은 다를 수 있음)
    cleanup = fn -> File.rm(path) end
    {path, cleanup}
  end
end

{path, cleanup} = TempFile.with_tmp("session")
# ... path 사용 ...

cleanup.()
```

- `with_tmp/1` 는 “경로”와 “정리 함수”를 같이 돌려준다.
- 호출자는 어떤 코드 경로(성공/에러)를 타더라도
  마지막에 `cleanup.()` 을 호출하기만 하면 된다.

이 패턴은:

- 임시 디렉터리
- 외부 프로세스 핸들
- 임시 테이블
등의 정리에 쓸 수 있다.

---

## 함수를 인자로 전달하기 (Passing Functions as Arguments)

표준 라이브러리 대부분이 **함수를 인자**로 받는다.
이를 통해 **동작을 주입**하고, **테스트 가능한 구조**를 만들 수 있다.

---

### `Enum`/`Stream` — 변환, 필터, 축약

```elixir
Enum.map([1, 2, 3], &(&1 * 2))          # [2,4,6]
Enum.filter(1..10, &(rem(&1, 2) == 0))  # [2,4,6,8,10]
Enum.reduce(1..5, 0, &+/2)              # 15
```

- `&+/2` 같이 연산자도 함수로 캡처할 수 있다.
- `Enum.*` 함수는 대부분 **첫 번째 인자 = 컬렉션**,
  이후 인자에 함수를 받는다.
  이것은 파이프(`|>`)와 상성이 좋다.

```elixir
1..100
|> Enum.map(&(&1 * &1))
|> Enum.filter(&(&1 <= 1000))
|> Enum.sum()
```

여기서 **각 단계를 독립적으로 테스트**할 수 있다.

- “제곱” 함수
- “필터” 함수
- “합” 단계

---

### 콜백 형태 — 전략 주입(Retry 예제)

```elixir
defmodule Retry do
  def with(max, fun, backoff \\ fn attempt -> :timer.sleep(attempt * 50) end) do
    do_with(1, max, fun, backoff)
  end

  defp do_with(a, max, fun, backoff) when a <= max do
    case fun.() do
      {:ok, v} ->
        {:ok, v}

      _ ->
        backoff.(a)
        do_with(a + 1, max, fun, backoff)
    end
  end

  defp do_with(_, _, _fun, _backoff), do: {:error, :give_up}
end
```

사용 예:

```elixir
Retry.with(3, fn ->
  if :rand.uniform() < 0.3, do: {:ok, :win}, else: :error
end)

# 지수 백오프 전략 주입

exp_backoff = fn attempt ->
  :timer.sleep(:math.pow(2, attempt) |> round())
end

Retry.with(5, fn -> do_call() end, exp_backoff)
```

- `fun`: 재시도할 동작.
- `backoff`: 각 시도 사이에 **얼마나 기다릴지** 결정하는 함수.

테스트 시에는:

```elixir
Retry.with(3, fn -> :error end, fn _ -> :ok end)
# → time.sleep 없이 즉시 반복

```

이렇게 하면 **테스트에서 기다릴 필요가 없다.**

---

### `Task.async_stream/3` — 병렬 처리 대상 함수를 전달

```elixir
urls = ["https://example1", "https://example2", "https://example3"]

urls
|> Task.async_stream(fn url ->
     # 실제 환경에서는 HTTP 클라이언트 라이브러리 사용
     {:ok, byte_size(url)}
   end, max_concurrency: 5, timeout: 1000)
|> Enum.map(fn {:ok, result} -> result end)
```

- 각 URL에 대해 실행할 **작업**을 함수로 전달.
- 런타임이 이 함수를 **여러 프로세스에서 병렬로** 수행한다.
- “무엇을 할지”와 “어떻게 병렬화할지”를 분리할 수 있다.

---

### 함수 vs MFA (Module-Function-Arity)

어떤 라이브러리는 콜백을 **익명 함수** 뿐 아니라
**MFA(MyMod, :fun, arity)** 형태로도 받는다.

엘릭서에서는 대개 그냥 캡처를 사용하면 된다.

```elixir
Enum.map([1,2,3], &Integer.to_string/1)
Enum.map([1,2,3], &:erlang.integer_to_binary/1)
```

이렇게 쓰면:

- `Integer.to_string/1`
- `:erlang.integer_to_binary/1`

함수 포인터와 같은 역할을 한다.

---

### 의존성 주입(테스트)을 함수 인자로

전역 상태나 전역 모킹 없이,
**함수 인자**로 의존성을 주입하는 패턴.

```elixir
defmodule Notifier do
  def send_email(user, deliver_fun \\ &Mailer.deliver/1) do
    deliver_fun.(user)
  end
end

# 실제 코드

Notifier.send_email(%{email: "real@example.com"})

# 테스트 코드

fake_deliver = fn user -> {:ok, {:fake_delivered, user.email}} end
Notifier.send_email(%{email: "test@example.com"}, fake_deliver)
```

장점:

- 테스트에서 **메일을 진짜 보내지 않는다.**
- 동시에 여러 테스트를 돌려도,
  **전역 설정** 때문에 꼬이는 일이 없다.
- 함수가 **의존성이 무엇인지** 명시적으로 드러낸다.

---

## 함수는 엘릭서의 핵심이다 (Why Functions are the Core)

이제까지 본 요소를 다시 묶어보면:

- 5.1: **함수 헤드 + 패턴/가드** → 계약, 형태, 타입을 코드에 문장화.
- 5.2: **멀티 클로즈** → 복잡한 분기를 구조적으로 표현.
- 5.3: **함수를 반환** → 설정/환경을 캡처하고, 전략을 조립.
- 5.4: **함수를 인자로 전달** → 동작을 주입, 병렬/지연 실행 설계.

이 모든 것이 엘릭서의 **불변 데이터 + 메시지 패싱 + 프로세스 모델**과 결합하면서
**동시성, 테스트, 확장성**을 만든다.

---

### “계약으로서의 함수 헤드” — 관측 가능성

함수 헤드를 잘 설계하면:

- 잘못된 데이터가 들어오면 **즉시 튕겨 나간다** (`MatchError`, 마지막 절 등)
- “필수 필드가 없다”는 상태가 **조용히 지나가지 않는다**.
- 케이스별 규칙이 **한눈에 보인다**.

```elixir
def signup(%{email: e, password: p} = params)
    when is_binary(e) and is_binary(p) and byte_size(p) >= 8 do
  # ...
end

def signup(_), do: {:error, :invalid_params}
```

위 두 줄만 봐도:

- 이 함수가 어떤 입력을 기대하는지,
- 어떤 경우에 실패로 처리하는지
곧바로 알 수 있다.

---

### “동작의 합성” — 모듈/서비스 경계를 단단하게

엘릭서에서는 **함수 간 합성**이 자연스럽다.

$$
(f \circ g \circ h)(x) = f(g(h(x)))
$$

이걸 코드로 쓰면 다음과 같이 된다.

```elixir
x
|> h()
|> g()
|> f()
```

이 패턴은:

- `Signup.normalize/1`
- `Signup.validate/1`
- `Signup.persist/1`

같은 단계로 쪼개고 합치는 데 사용된다.

각 함수는 **입력 → 출력**만 담당하고,
상태는 값으로 **밖으로만 흐른다**.

---

### 고차 함수 = 유연성·테스트·확장성

- **Retry/backoff** 예제에서 본 것처럼,
  “어떻게 재시도할지”는 고정하고
  “무엇을 재시도할지”만 함수로 넘겨주면
  여러 시나리오에 재사용 가능하다.
- **Notifier.send_email/2**처럼,
  실제 메일 발송 vs 테스트용 목업을 함수로 주입하면
  테스트가 단순해진다.
- **Validate 모듈**에서, 작은 판정자 함수를 조합해
  큰 규칙 집합을 만들 수 있다.

---

### 성능 관점에서 본 함수 중심 설계

- `Stream` 은 **고차 함수 + 지연 평가**를 결합해
  큰 데이터셋을 **한 번에 메모리에 올리지 않고** 처리할 수 있게 한다.
- `Task.async_stream` 은 “함수”만 넘기면
  BEAM이 알아서 **병렬로 돌리고 결과를 모은다.**
- iodata 기반 API들은
  함수가 소비할 **출력 트리**를 만들고
  마지막에만 선형화하게 하여,
  문자열/바이너리 결합 비용을 줄인다.

---

### 수학적 메모: 함수 합성과 파이프라인

함수 합성은 **결합 법칙**을 가진다.

$$
f \circ (g \circ h) = (f \circ g) \circ h
$$

엘릭서에서 파이프라인을 다음과 같이 쪼갤 수 있다.

```elixir
x
|> h()
|> g()
|> f()
```

이것은

```elixir
pipe = fn x -> x |> h() |> g() |> f() end
pipe.(x)
```

와 동일하다.

즉, 모든 파이프는 결국 **하나의 함수**로 묶을 수 있고,
이 함수는 다시 다른 파이프라인에 들어갈 수 있다.

이렇게 해서 거대한 시스템도 결국
**작은 순수 함수들의 합성**으로 재구성할 수 있다.

---

### 종합 예제: 미니 라우터 + 파이프라인 + 전략 주입

지금까지 나온 요소를 한 번에 활용한 예제.

```elixir
defmodule MiniRouter do
  @type req :: %{
          path: String.t(),
          method: atom(),
          body: binary(),
          headers: map()
        }

  @type resp :: %{
          status: pos_integer(),
          body: iodata(),
          headers: [{binary(), binary()}]
        }

  # 1) 라우팅: 함수 헤드 패턴으로 라우트 정의
  def handle(%{method: :get, path: "/health"} = req) do
    ok(req, "ok")
  end

  def handle(%{method: :post, path: "/echo", body: b} = req) do
    ok(req, b)
  end

  def handle(%{method: :post, path: "/sum", body: b} = req) do
    body =
      b
      |> String.trim()
      |> String.split(~r/\s+/, trim: true)
      |> Enum.map(&String.to_integer/1)
      |> Enum.reduce(0, &+/2)
      |> Integer.to_string()

    ok(req, body)
  end

  def handle(req) do
    err(req, 404, "not found")
  end

  # 2) 전략 주입: 응답 직렬화기를 함수로 받기
  def respond(req, serializer \\ &default_serializer/1) do
    req
    |> handle()
    |> serializer.()
  end

  defp ok(req, body) do
    %{
      status: 200,
      body: body,
      headers: [{"content-type", "text/plain"}],
      req: req
    }
  end

  defp err(req, code, msg) do
    %{
      status: code,
      body: msg,
      headers: [{"content-type", "text/plain"}],
      req: req
    }
  end

  # 3) iodata 직렬화
  defp default_serializer(%{status: s, headers: h, body: b}) do
    :erlang.iolist_to_binary([
      "HTTP/1.1 ",
      Integer.to_string(s),
      " OK\r\n",
      Enum.map(h, fn {k, v} -> [k, ": ", v, "\r\n"] end),
      "\r\n",
      b
    ])
  end
end

# 사용 예

req = %{path: "/sum", method: :post, body: "10  20  30", headers: %{}}
response_bin = MiniRouter.respond(req)
```

여기서:

- `handle/1` 는 **멀티 클로즈 + 패턴/가드** 로 라우팅/계약 구현.
- `respond/2` 는 **전략 주입**으로 직렬화 방식 교체 가능.
- `default_serializer/1` 는 **iodata** 를 사용해 효율적 바이너리 생성.

---

## 연습 문제와 해설

### 문제 1: 인증 헤더 파서

**요구:**
`"Bearer <TOKEN>"` 또는 `"Basic <CRED>"` 형식의 문자열을 받아서

- `"Bearer XXX"` → `{:bearer, "XXX"}`
- `"Basic YYY"`  → `{:basic, "YYY"}`
- 그 외 → `:bad`

를 반환하는 함수를 **함수 헤드 패턴**으로 작성하라.

**해설 예:**

```elixir
defmodule AuthHeader do
  def parse("Bearer " <> tok) when byte_size(tok) > 0, do: {:bearer, tok}
  def parse("Basic " <> cred)  when byte_size(cred) > 0, do: {:basic, cred}
  def parse(_), do: :bad
end
```

---

### 문제 2: Retry.with/3 에 지수 백오프 주입

**요구:**
앞서 정의한 `Retry.with/3` 를 사용해
실패 시 “1, 2, 4, 8, … ms” 로 대기하는 **지수 백오프**를 적용하라.

**해설 예:**

```elixir
exp_backoff = fn attempt ->
  delay = :math.pow(2, attempt - 1) |> round()
  :timer.sleep(delay)
end

Retry.with(5, fn -> do_call() end, exp_backoff)
```

---

### 문제 3: 금칙어 필터 클로저

**요구:**
`make_filter(["bad", "xxx"])` 를 호출하면
문자열을 받아 **금칙어가 하나라도 포함되어 있으면 true** 를 반환하는 함수를 돌려주는 코드를 작성하라.

**해설 예:**

```elixir
defmodule WordFilter do
  def make_filter(words) do
    fn s ->
      is_binary(s) and Enum.any?(words, &String.contains?(s, &1))
    end
  end
end

f = WordFilter.make_filter(["bad", "xxx"])
f.("this is bad")   # true
f.("clean")         # false
```

---

## 간단 테스트 스케치 (ExUnit)

```elixir
defmodule Ch5Test do
  use ExUnit.Case, async: true

  test "shape area" do
    assert_in_delta 12.56, Shape.area({:circle, 2}), 0.01
    assert 6 == Shape.area({:rect, 2, 3})
    assert {:error, :bad_shape} == Shape.area({:triangle, 3, 4, 5})
  end

  test "multi-clause login" do
    assert {:ok, {:local, _}} =
             Auth.login(%{provider: :password, email: "a", pass: "b"})

    assert {:ok, {:oauth, _}} =
             Auth.login(%{provider: :oauth, token: "t"})

    assert {:error, :bad_params} =
             Auth.login(%{})
  end

  test "closure validator" do
    v = Validate.all([Validate.min_len(3), Validate.has?("@")])
    assert v.("a@a")
    refute v.("aa")
  end

  test "mini router sum" do
    req = %{path: "/sum", method: :post, body: "1 2 3", headers: %{}}
    bin = MiniRouter.respond(req)
    assert String.contains?(bin, "6")
  end
end
```

---

## 마무리 정리

- **5.1**: 함수 헤드에서 **패턴/가드**로 입력 계약을 명시하라.
- **5.2**: 멀티 클로즈와 꼬리 재귀로 **분기·순회**를 구조적으로 표현하라.
- **5.3**: 클로저(함수 반환)로 **설정·전략·정리 작업**을 캡처하라.
- **5.4**: 함수를 인자로 전달하여 **동작을 주입·병렬화·지연 실행**하라.
- **5.5**: 이 모든 것은 결국 “**함수 중심 설계**” 로 모인다.

실전에서는 이 장의 패턴들이
GenServer, Supervisor, 웹 프레임워크, ETL 파이프라인, 테스트 코드 전체에 걸쳐 반복해서 등장한다.
각 예제 코드를 직접 `iex` 에서 실행하고,
자신의 도메인 모델/서비스 로직에 어떻게 옮겨올지 바로 실험해 보는 것이 가장 좋다.
