---
layout: post
title: DB 심화 - I/O 효율화 원리
date: 2025-11-04 22:25:23 +0900
category: DB 심화
---
# I/O 효율화 원리: 필요한 최소 블록만 읽도록 설계하는 방법

> **핵심 원칙**
> 데이터베이스 성능 최적화의 핵심은 필요한 최소한의 블록만 읽도록 쿼리와 인덱스를 설계하는 것입니다. 이를 위해 세 단계 접근법을 권장합니다

1) 쿼리 자체를 최적화하여 불필요한 데이터 접근을 근본적으로 줄입니다. 
2) 옵티마이저가 최적 경로를 선택할 수 있도록 정확한 통계 정보를 제공합니다. 
3) 필요한 경우 힌트를 사용하여 실행 계획을 안정화합니다.

---

## 실습 환경 설정

```sql
-- 실습용 테이블 생성
DROP TABLE customers PURGE;
DROP TABLE orders PURGE;
DROP TABLE order_items PURGE;

CREATE TABLE customers (
  cust_id    NUMBER PRIMARY KEY,
  region     VARCHAR2(8),
  grade      VARCHAR2(8),
  created_at DATE,
  name       VARCHAR2(60)
);

CREATE TABLE orders (
  order_id   NUMBER PRIMARY KEY,
  cust_id    NUMBER NOT NULL,
  order_dt   DATE   NOT NULL,
  status     VARCHAR2(8),
  amount     NUMBER(12,2)
);

CREATE TABLE order_items (
  item_id    NUMBER PRIMARY KEY,
  order_id   NUMBER NOT NULL,
  sku        VARCHAR2(32),
  qty        NUMBER,
  price      NUMBER(10,2)
);

-- 샘플 데이터 적재
BEGIN
  -- 고객 테이블: 50만 건
  INSERT /*+ APPEND */ INTO customers
  SELECT level, 
         CASE MOD(level,4) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA'
                           WHEN 2 THEN 'AMER' ELSE 'OTHR' END,
         CASE MOD(level,3) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' ELSE 'SILV' END,
         DATE '2024-01-01' + MOD(level,365),
         'CUST_'||TO_CHAR(level)
  FROM dual CONNECT BY level <= 500000;

  -- 주문 테이블: 300만 건
  INSERT /*+ APPEND */ INTO orders
  SELECT level,
         MOD(level, 500000)+1,
         DATE '2025-01-01' + MOD(level, 365),
         CASE MOD(level,4) WHEN 0 THEN 'OK' WHEN 1 THEN 'OK'
                           WHEN 2 THEN 'CXL' ELSE 'HOLD' END,
         ROUND(DBMS_RANDOM.VALUE(10, 2000),2)
  FROM dual CONNECT BY level <= 3000000;

  -- 주문 상세 테이블: 600만 건
  INSERT /*+ APPEND */ INTO order_items
  SELECT level,
         MOD(level, 3000000)+1,
         'SKU'||TO_CHAR(MOD(level,100000)),
         MOD(level,10)+1,
         ROUND(DBMS_RANDOM.VALUE(1, 200),2)
  FROM dual CONNECT BY level <= 6000000;

  COMMIT;
END;
/

-- 성능 최적화를 위한 인덱스 설계
CREATE INDEX ix_orders_cust_dt ON orders(cust_id, order_dt DESC, order_id DESC);
CREATE INDEX ix_orders_status ON orders(status);
CREATE INDEX ix_cust_region_grade ON customers(region, grade, cust_id);

-- 통계 정보 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS',cascade=>TRUE, 
    method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',cascade=>TRUE, 
    method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDER_ITEMS',cascade=>TRUE, 
    method_opt=>'for all columns size skewonly');
END;
/
```

---

## 첫 번째 원칙: 쿼리 구조 최적화

### SARGable 조건 사용
인덱스 활용성을 보장하는 조건(SARGable: Search Argument Able)을 사용해야 합니다.

**문제 있는 패턴:**
```sql
-- 함수로 컬럼을 감싸면 인덱스를 사용할 수 없음
SELECT COUNT(*)
FROM orders
WHERE TRUNC(order_dt) = DATE '2025-10-01';
```

**개선된 패턴:**
```sql
-- 범위 조건으로 인덱스 활용 가능
SELECT COUNT(*)
FROM orders
WHERE order_dt >= DATE '2025-10-01'
  AND order_dt < DATE '2025-10-02';
```

### 키셋 페이지네이션 구현
대량 데이터의 페이지네이션은 OFFSET 방식보다 키셋 방식이 효율적입니다.

**비효율적인 OFFSET 방식:**
```sql
-- 앞부분 데이터를 읽고 버리는 비효율 발생
SELECT order_id, order_dt, amount
FROM orders
WHERE cust_id = :cust
ORDER BY order_dt DESC
OFFSET 10000 ROWS FETCH NEXT 20 ROWS ONLY;
```

**효율적인 키셋 방식:**
```sql
-- 이전 페이지의 마지막 값 기준으로 다음 페이지 조회
SELECT /*+ index(o ix_orders_cust_dt) */
       order_id, order_dt, amount
FROM orders o
WHERE o.cust_id = :cust
  AND (o.order_dt < :last_dt
       OR (o.order_dt = :last_dt AND o.order_id < :last_id))
ORDER BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 20 ROWS ONLY;
```

### 커버링 인덱스 활용
테이블 접근 없이 인덱스만으로 쿼리를 완결할 수 있도록 설계합니다.

**인덱스 설계 예시:**
```sql
-- order_id, order_dt, amount 모두 인덱스에 포함
CREATE INDEX ix_orders_cust_dt_amt ON orders(cust_id, order_dt DESC, order_id DESC, amount);

-- 커버링 인덱스만으로 쿼리 수행
SELECT /*+ index(o ix_orders_cust_dt_amt) */
       o.order_id, o.order_dt, o.amount
FROM orders o
WHERE o.cust_id = :cust
  AND o.order_dt >= SYSDATE - 7
ORDER BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

### 조기 필터링 적용
가장 선택도가 높은 조건을 먼저 적용하여 처리 범위를 최대한 줄입니다.

**비효율적인 조인:**
```sql
-- 모든 조인을 수행한 후 필터링
SELECT c.cust_id, COUNT(*)
FROM customers c
JOIN orders o ON o.cust_id = c.cust_id
WHERE c.region = :r
  AND c.grade = :g
  AND o.order_dt >= SYSDATE - 7
GROUP BY c.cust_id;
```

**조기 필터링 적용:**
```sql
-- 먼저 필터링하여 처리할 데이터 양 축소
WITH filtered_customers AS (
  SELECT /*+ index(c ix_cust_region_grade) */
         c.cust_id
  FROM customers c
  WHERE c.region = :r
    AND c.grade = :g
)
SELECT /*+ leading(filtered_customers o) use_hash(o) */
       o.cust_id, COUNT(*)
FROM filtered_customers fc
JOIN orders o ON o.cust_id = fc.cust_id
WHERE o.order_dt >= SYSDATE - 7
GROUP BY o.cust_id;
```

---

## 두 번째 원칙: 옵티마이저 지원 최적화

### 정확한 통계 정보 제공
옵티마이저가 최적의 실행 계획을 선택할 수 있도록 정확한 통계 정보를 제공해야 합니다.

**기본 통계 수집:**
```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'ORDERS',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt => 'for all columns size auto',
    cascade    => TRUE
  );
END;
/
```

**히스토그램 생성 (편중된 데이터 분포 처리):**
```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'ORDERS',
    method_opt => 'for columns status size 254'
  );
END;
/
```

### 확장 통계로 상관관계 반영
여러 컬럼 간의 상관관계가 있을 때 확장 통계를 활용합니다.

```sql
-- region과 grade의 상관관계를 통계로 반영
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER, 'CUSTOMERS', '(region, grade)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS', 
    method_opt=>'for all columns size skewonly');
END;
/
```

### 클러스터링 팩터 개선
인덱스 키 순서와 테이블 물리적 저장 순서를 일치시켜 랜덤 I/O를 줄입니다.

```sql
-- 물리적 재구성을 통한 클러스터링 팩터 개선
CREATE TABLE orders_reorganized NOLOGGING AS
SELECT * FROM orders
ORDER BY cust_id, order_dt, order_id;

-- 기존 테이블 교체
ALTER TABLE orders RENAME TO orders_backup;
ALTER TABLE orders_reorganized RENAME TO orders;

-- 인덱스 재생성
CREATE INDEX ix_orders_cust_dt ON orders(cust_id, order_dt DESC, order_id DESC);
CREATE INDEX ix_orders_status ON orders(status);

-- 통계 재수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS', cascade=>TRUE);
END;
/
```

---

## 세 번째 원칙: 힌트를 통한 실행 계획 안정화

### 접근 경로 힌트
옵티마이저가 특정 인덱스를 사용하도록 유도합니다.

```sql
-- 특정 인덱스 사용 강제
SELECT /*+ index(o ix_orders_cust_dt) */ *
FROM orders o
WHERE o.cust_id = :cust
  AND o.order_dt >= SYSDATE - 7;

-- 풀 스캔 유도 (대량 데이터 처리 시)
SELECT /*+ full(o) parallel(o 8) */ COUNT(*)
FROM orders o
WHERE o.order_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -3);
```

### 조인 힌트
조인 순서와 방법을 명시적으로 지정합니다.

```sql
-- 해시 조인과 조인 순서 지정
WITH customer_subset AS (
  SELECT /*+ index(c ix_cust_region_grade) */
         cust_id
  FROM customers c
  WHERE c.region = :r AND c.grade = :g
)
SELECT /*+ leading(customer_subset o) use_hash(o) */
       o.cust_id, COUNT(*)
FROM customer_subset cs
JOIN orders o ON o.cust_id = cs.cust_id
WHERE o.order_dt >= SYSDATE - 7
GROUP BY o.cust_id;

-- 네스티드 루프 조인 유도 (소규모 반복 조회)
SELECT /*+ leading(o) use_nl(oi) index(oi(order_id)) */
       o.order_id, SUM(oi.qty * oi.price)
FROM orders o
JOIN order_items oi ON oi.order_id = o.order_id
WHERE o.cust_id = :cust
  AND o.order_dt >= SYSDATE - 7
GROUP BY o.order_id;
```

---

## 성능 측정과 검증

### 실행 계획 분석
```sql
-- 상세한 실행 계획 확인
ALTER SESSION SET statistics_level = ALL;

-- 쿼리 실행
SELECT o.order_id, o.order_dt, o.amount
FROM customers c
JOIN orders o ON o.cust_id = c.cust_id
WHERE c.region = 'APAC'
  AND c.grade = 'VIP'
  AND o.order_dt >= SYSDATE - 7
ORDER BY o.amount DESC
FETCH FIRST 10 ROWS ONLY;

-- 실행 계획 확인
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
  'ALLSTATS LAST +PEEKED_BINDS +ALIAS'));
```

### SQL 성능 모니터링
```sql
-- SQL별 I/O 패턴 분석
SELECT sql_id, plan_hash_value, executions,
       buffer_gets, disk_reads,
       ROUND(buffer_gets/NULLIF(executions,0)) AS avg_logical_reads,
       ROUND(disk_reads/NULLIF(executions,0)) AS avg_physical_reads,
       elapsed_time/1000000/NULLIF(executions,0) AS avg_elapsed_sec
FROM v$sql
WHERE sql_text LIKE '%orders%'
  AND parsing_schema_name = USER
ORDER BY avg_physical_reads DESC
FETCH FIRST 10 ROWS ONLY;
```

---

## 실전 최적화 패턴 요약

### 효율적인 패턴
1. **인덱스 활용 최적화**: SARGable 조건, 커버링 인덱스, 정렬 순서 일치
2. **데이터 접근 최소화**: 키셋 페이지네이션, 파티션 프루닝, 조기 필터링
3. **조인 전략 최적화**: 작은 결과집합 선행, 적절한 조인 방법 선택
4. **통계 기반 최적화**: 히스토그램, 확장 통계, 시스템 통계 활용

### 피해야 할 안티패턴
1. **비 SARGable 조건**: 컬럼에 함수 적용, 암시적 형변환
2. **비효율적 페이지네이션**: OFFSET 방식의 대량 데이터 건너뛰기
3. **과도한 테이블 접근**: 커버링 인덱스로 해결 가능한 쿼리의 테이블 스캔
4. **광범위 조인 후 필터링**: 조인 전 데이터 범위 축소 실패

---

## 종합 실전 예제: VIP 고객 주문 분석

### 초기 비효율 쿼리
```sql
SELECT o.order_id, o.order_dt, o.amount,
       c.name, c.grade
FROM customers c
JOIN orders o ON o.cust_id = c.cust_id
WHERE c.region = :region
  AND c.grade = 'VIP'
  AND TRUNC(o.order_dt) >= TRUNC(SYSDATE) - 7
ORDER BY o.amount DESC
OFFSET 0 ROWS FETCH NEXT 50 ROWS ONLY;
```

### 최적화된 쿼리
```sql
-- 1. 조기 필터링으로 VIP 고객 집합 축소
WITH vip_customers AS (
  SELECT /*+ index(c ix_cust_region_grade) */
         c.cust_id, c.name, c.grade
  FROM customers c
  WHERE c.region = :region
    AND c.grade = 'VIP'
)
-- 2. SARGable 조건과 효율적 정렬 적용
SELECT /*+ leading(vip_customers o) use_hash(o) */
       o.order_id, 
       o.order_dt, 
       o.amount,
       vc.name,
       vc.grade
FROM vip_customers vc
JOIN orders o ON o.cust_id = vc.cust_id
WHERE o.order_dt >= SYSDATE - 7  -- TRUNC 제거
ORDER BY o.amount DESC
FETCH FIRST 50 ROWS ONLY;        -- OFFSET 제거
```

### 추가 최적화 (커버링 인덱스)
```sql
-- amount를 포함하는 커버링 인덱스 생성
CREATE INDEX ix_orders_cust_dt_amt_cover ON orders(
  cust_id, order_dt DESC, amount DESC, order_id
);

-- 최종 최적화 쿼리
WITH vip_customers AS (
  SELECT cust_id, name, grade
  FROM customers
  WHERE region = :region AND grade = 'VIP'
)
SELECT /*+ leading(vc o) use_nl(o) index(o ix_orders_cust_dt_amt_cover) */
       o.order_id,
       o.order_dt,
       o.amount,
       vc.name,
       vc.grade
FROM vip_customers vc
JOIN orders o ON o.cust_id = vc.cust_id
WHERE o.order_dt >= SYSDATE - 7
ORDER BY o.amount DESC
FETCH FIRST 50 ROWS ONLY;
```

---

## 결론: I/O 효율화의 체계적 접근법

데이터베이스 성능 최적화는 단순한 기술 습득이 아니라 체계적인 접근 방식입니다. 다음 세 단계를 준수하면 효과적인 I/O 최적화를 달성할 수 있습니다:

### 1. 근본적인 쿼리 구조 최적화
가장 중요한 단계로, 불필요한 데이터 접근을 애초에 방지하는 설계가 필요합니다. SARGable 조건 적용, 키셋 페이지네이션 구현, 커버링 인덱스 활용, 조기 필터링 적용 등을 통해 쿼리 자체가 최소한의 블록만 읽도록 설계해야 합니다.

### 2. 옵티마이저 지원 강화
정확한 실행 계획 선택을 위해 옵티마이저에 필요한 모든 정보를 제공해야 합니다. 최신 통계 정보 유지, 히스토그램을 통한 데이터 분포 정확 반영, 확장 통계로 컬럼 간 상관관계 반영, 클러스터링 팩터 개선 등을 통해 옵티마이저의 결정 질을 높여야 합니다.

### 3. 실행 계획 안정화
앞선 두 단계를 적용한 후에도 실행 계획이 불안정한 경우, 힌트를 통한 명시적 제어를 고려할 수 있습니다. 그러나 힌트는 마지막 수단으로 활용해야 하며, 원인 분석과 근본적 해결을 우선시해야 합니다.

### 성공적인 최적화의 핵심 성과 지표
- **논리적 읽기 감소**: 버퍼 겟 횟수가 현저히 줄어듭니다.
- **물리적 읽기 감소**: 디스크 I/O가 최소화됩니다.
- **실행 시간 단축**: 응답 시간이 개선됩니다.
- **자원 사용 효율화**: CPU와 메모리 사용이 최적화됩니다.

최종적으로, 모든 최적화 작업은 실제 성능 측정을 통해 검증되어야 합니다. 실행 계획 분석, 실제 실행 통계 모니터링, AWR/ASH 리포트 분석 등을 통해 개선 효과를 정량적으로 평가하고, 지속적인 모니터링을 통해 시스템 성능을 유지해야 합니다.

이러한 체계적 접근법을 통해 데이터베이스 I/O 효율성을 극대화하면, 더 나은 사용자 경험과 안정적인 시스템 운영을 동시에 달성할 수 있습니다.