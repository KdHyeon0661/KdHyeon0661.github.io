---
layout: post
title: DB 심화 - I/O 효율화 원리
date: 2025-11-04 22:25:23 +0900
category: DB 심화
---
# I/O 효율화 원리 — “**필요한 최소 블록만** 읽게 만들고, 옵티마이저가 **그 선택을 확신**하도록 돕고, 마지막엔 **힌트로 안전 레일**을 깐다”)

> 핵심 메시지
> 1) **쿼리 자체**를 “최소 블록만 읽는” 형태로 재구성한다. (선택도↑, 조기 필터링, 커버링 인덱스, 파티션 프루닝, Stopkey/Top-N, Keyset 페이징 등)
> 2) 옵티마이저가 그 경로를 **자연스럽게** 고르도록 **정확한 팩터**(객체/시스템 통계, 히스토그램/확장 통계, 클러스터링 팩터, 바인드/상관관계 등)를 제공한다.
> 3) 그래도 흔들리면 **힌트**로 최적 경로로 **유도**한다. (그러나 “원인 교정”이 우선, 힌트는 마지막 수단)

---

## 실습 스키마 · 데이터 준비

```sql
-- 재현을 위한 샘플 스키마
DROP TABLE customers PURGE;
DROP TABLE orders PURGE;
DROP TABLE order_items PURGE;

CREATE TABLE customers (
  cust_id    NUMBER PRIMARY KEY,
  region     VARCHAR2(8),
  grade      VARCHAR2(8),
  created_at DATE,
  name       VARCHAR2(60)
);

CREATE TABLE orders (
  order_id   NUMBER PRIMARY KEY,
  cust_id    NUMBER NOT NULL,
  order_dt   DATE   NOT NULL,
  status     VARCHAR2(8),
  amount     NUMBER(12,2)
);

CREATE TABLE order_items (
  item_id    NUMBER PRIMARY KEY,
  order_id   NUMBER NOT NULL,
  sku        VARCHAR2(32),
  qty        NUMBER,
  price      NUMBER(10,2)
);

-- 데이터 적재(간이)
BEGIN
  INSERT /*+ APPEND */ INTO customers
  SELECT level, CASE MOD(level,4) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA'
                                  WHEN 2 THEN 'AMER' ELSE 'OTHR' END,
         CASE MOD(level,3) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' ELSE 'SILV' END,
         DATE '2024-01-01' + MOD(level,365),
         'CUST_'||TO_CHAR(level)
  FROM dual CONNECT BY level <= 500000;

  INSERT /*+ APPEND */ INTO orders
  SELECT level,
         MOD(level, 500000)+1,
         DATE '2025-01-01' + MOD(level, 365),
         CASE MOD(level,4) WHEN 0 THEN 'OK' WHEN 1 THEN 'OK'
                           WHEN 2 THEN 'CXL' ELSE 'HOLD' END,
         ROUND(DBMS_RANDOM.VALUE(10, 2000),2)
  FROM dual CONNECT BY level <= 3000000;

  INSERT /*+ APPEND */ INTO order_items
  SELECT level,
         MOD(level, 3000000)+1,
         'SKU'||TO_CHAR(MOD(level,100000)),
         MOD(level,10)+1,
         ROUND(DBMS_RANDOM.VALUE(1, 200),2)
  FROM dual CONNECT BY level <= 6000000;

  COMMIT;
END;
/

-- 인덱스 설계: SARGable 필터/조인/정렬에 맞춤
CREATE INDEX ix_orders_cust_dt ON orders(cust_id, order_dt DESC, order_id DESC);
CREATE INDEX ix_orders_status  ON orders(status);
CREATE INDEX ix_cust_region_grade ON customers(region, grade, cust_id);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS',cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDER_ITEMS',cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

## **필요한 최소 블록만** 읽도록 쿼리 작성

### 표현으로 바꾸기

- **나쁜 예**(함수로 컬럼 감싸기 → 인덱스 못 탐)
```sql
-- 인덱스(orders(order_dt))가 있어도 컬럼을 함수로 감싸면 범위 스캔 실패
SELECT COUNT(*)
FROM   orders
WHERE  TRUNC(order_dt) = DATE '2025-10-01';
```

- **개선**
```sql
-- 범위를 직접 지정: 인덱스 범위 스캔 유도 → 불필요 블록 최소화
SELECT COUNT(*)
FROM   orders
WHERE  order_dt >= DATE '2025-10-01'
AND    order_dt <  DATE '2025-10-02';
```

> 원리: “**컬럼** = 표현식”이 아니라 “**표현식** = 컬럼”으로 만들면 인덱스가 일함.

---

### **정렬 일치 + Stopkey(Top-N)** 로 앞부분만

- **나쁜 예**(정렬 후 OFFSET)
```sql
-- OFFSET은 앞 구간을 버려서 읽는다 → 불필요 스캔 증가
SELECT order_id, order_dt, amount
FROM   orders
WHERE  cust_id = :cust
ORDER  BY order_dt DESC
OFFSET 10000 ROWS FETCH NEXT 20 ROWS ONLY;
```

- **개선**(Keyset 페이징: “마지막 키” 기준)
```sql
-- 마지막 본 키(:last_dt, :last_id)를 저장했다가 다음 페이지부터 이어서
SELECT /*+ index(o ix_orders_cust_dt) */
       order_id, order_dt, amount
FROM   orders o
WHERE  o.cust_id = :cust
  AND (o.order_dt < :last_dt
       OR (o.order_dt = :last_dt AND o.order_id < :last_id))
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 20 ROWS ONLY;
```
> 인덱스 리프를 **연속 구간**만 읽는다 → **최소 블록**으로 페이지 네이션.

---

### **커버링 인덱스**로 테이블 방문 제거

- **나쁜 예**: 인덱스 스캔 후 테이블 BY ROWID 랜덤 읽기
```sql
SELECT order_id, order_dt, amount
FROM   orders
WHERE  cust_id = :cust
AND    order_dt >= SYSDATE - 7
ORDER  BY order_dt DESC, order_id DESC;
```

- **개선**: SELECT-LIST/정렬 컬럼을 인덱스에 포함 (**include**)
  이미 `ix_orders_cust_dt(cust_id, order_dt desc, order_id desc)` 로 커버 가능.
```sql
-- 커버링 인덱스만 읽고 결과 반환(테이블 무방문) → 랜덤 I/O 제거
SELECT /*+ index(o ix_orders_cust_dt) */
       o.order_id, o.order_dt
       , /* 필요 시 amount도 인덱스에 포함 설계 */
       o.amount
FROM   orders o
WHERE  o.cust_id = :cust
AND    o.order_dt >= SYSDATE - 7
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

---

### **조기 필터링**(선택도 높은 조건을 먼저 적용)

- **나쁜 예**: 광범위 조인 후 WHERE로 필터
```sql
SELECT /* 광범위 조인 → 많은 블록 읽음 */
       c.cust_id, COUNT(*)
FROM   customers c
JOIN   orders o ON o.cust_id = c.cust_id
WHERE  c.region = :r
AND    c.grade  = :g
AND    o.order_dt >= SYSDATE - 7
GROUP  BY c.cust_id;
```

- **개선**: 선택도 높은 쪽을 **인라인뷰/반정규화**로 먼저 좁힌다.
```sql
-- region/grade로 고객을 먼저 소수 집합으로 축소 → 그 다음 orders
WITH cand AS (
  SELECT /*+ index(c ix_cust_region_grade) */
         c.cust_id
  FROM   customers c
  WHERE  c.region = :r
  AND    c.grade  = :g
)
SELECT /*+ leading(cand o) use_hash(o) */
       o.cust_id, COUNT(*)
FROM   cand
JOIN   orders o ON o.cust_id = cand.cust_id
WHERE  o.order_dt >= SYSDATE - 7
GROUP  BY o.cust_id;
```
> 블록을 **먼저 적게** 읽도록 **입력 크기**를 줄인다.

---

### **파티션 프루닝**(읽기 범위를 물리적으로 줄이기)

> 대용량 `orders` 를 월별 RANGE 파티션 가정.

```sql
-- 파티션 키에 함수/형변환 금지, 경계값 명시
SELECT COUNT(*)
FROM   orders PARTITION FOR (TO_DATE('2025-10', 'YYYY-MM'))
WHERE  order_dt >= DATE '2025-10-01'
AND    order_dt <  DATE '2025-11-01';
```
- 파티션 키와 조건이 **동일 타입/표현**이어야 프루닝 100% 동작.
- **서브파티션**(예: HASH(cust_id))로 **핫셋 분산**도 가능.

---

### **세미조인/안티조인**으로 존재성만 확인

- **나쁜 예**
```sql
-- 존재성 확인에 COUNT(*)는 비효율적
SELECT COUNT(*)
FROM   orders o
WHERE  EXISTS (SELECT 1 FROM order_items oi WHERE oi.order_id = o.order_id);
```

- **개선**: `EXISTS` / `NOT EXISTS` 로 “존재만” 확인하고 종료
```sql
SELECT /* 존재성만 체크 → 부분범위 처리 유리 */
       o.order_id
FROM   orders o
WHERE  EXISTS (
  SELECT 1 FROM order_items oi WHERE oi.order_id = o.order_id
)
FETCH FIRST 1 ROW ONLY;
```

---

## **최적의 옵티마이징 팩터** 제공

> “좋은 쿼리”라도 **옵티마이저가 그걸 믿을 근거**(통계·시스템 특성)가 없으면 틀린 경로를 고를 수 있다.

### 객체 통계(카디널리티/선택도/히스토그램)

```sql
-- 기본 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/

-- 극단적 편중 컬럼(예: status)에 히스토그램 필요 시
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'ORDERS',
    method_opt => 'for columns status size 254'  -- 빈도/톱-프리퀀시
  );
END;
/
```
- **히스토그램**은 `WHERE status='OK'` 같은 **편중된 값**의 선택도 추정 정확도를 올려 **불필요한 풀스캔**을 피하게 한다.

### **확장 통계(Extended Stats)** — **상관관계** 반영

> `region` 과 `grade` 가 강한 상관이 있을 때 개별 컬럼 통계만으로는 조인/필터 선택도가 빗나간다.

```sql
-- 컬럼 그룹 확장 통계: (region, grade)
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER, 'CUSTOMERS', '(region, grade)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS', method_opt=>'for all columns size skewonly');
END;
/
```
- 옵티마이저가 `(region,grade)` **조합의 분포**를 알면 **정확한 카디널리티**로 **인덱스 경로**를 자신 있게 고른다.

### **클러스터링 팩터(Clustering Factor)** 개선

> 인덱스 키 순서가 테이블의 물리 저장 순서에 가깝도록 → **ROWID 랜덤 점프 최소화**.

```sql
-- 물리 재적재(CTAS)로 cust_id, order_dt 순서대로 정렬
CREATE TABLE orders_sorted NOLOGGING AS
SELECT * FROM orders
ORDER BY cust_id, order_dt, order_id;

ALTER TABLE orders RENAME TO orders_old;
ALTER TABLE orders_sorted RENAME TO orders;

-- 인덱스 재생성 및 통계 갱신
DROP INDEX ix_orders_cust_dt;
CREATE INDEX ix_orders_cust_dt ON orders(cust_id, order_dt DESC, order_id DESC);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS', cascade=>TRUE);
END;
/
```
- **효과**: B-Tree 스캔 후 테이블 BY ROWID 접근 시 **블록 재사용률↑** → **I/O 호출 수↓**.

### **시스템 통계(System Stats)** — IO/CPU/MBRC

> 하드웨어 특성(싱글/멀티블록 IO 시간, CPU 속도)이 **비용 모델**에 반영되면 **FULL vs INDEX** 판단이 현실적.

```sql
-- 운영 시간대에 시스템 통계 수집(주의: 정책/시간 고려)
BEGIN
  DBMS_STATS.GATHER_SYSTEM_STATS('INTERVAL', interval => 3600); -- 1시간
END;
/
-- 또는 수동 입력: SREADTIM/MREADTIM/MBRC/CPUSPEEDNW 등 (환경에 맞춰 DBA가 설정)
```

### **바인드 변수**와 **선택도 피킹(안정화)**

- 바인드 변수는 **파싱/커서 공유**에 유리하지만 **편중 값**에서는 잘못된 플랜 고착 위험(바인드 피킹).
- **해법**: 히스토그램 + **어댑티브/ACS(적응적 커서 공유)** / 리터럴 분리 전략을 **선별 적용**.

---

## **옵티마이저 힌트**로 최적 경로 유도(필요 시)

> 힌트는 **원인 교정 후**에도 **불확실**할 때 “**안전 레일**”로 사용.

### **액세스 경로** 유도

```sql
-- 인덱스 강제
SELECT /*+ index(o ix_orders_cust_dt) */ *
FROM   orders o
WHERE  o.cust_id = :cust
AND    o.order_dt >= SYSDATE - 7;

-- 풀스캔 강제 (DW/대량 범위)
SELECT /*+ full(o) parallel(o 8) */ COUNT(*)
FROM   orders o
WHERE  o.order_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -3);

-- 인덱스 Fast Full Scan (커버링 집계/카운트)
SELECT /*+ index_ffs(o ix_orders_status) */ status, COUNT(*)
FROM   orders o GROUP BY status;
```

### **조인 순서/방법** 유도

```sql
-- 선행 테이블(카디널리티 낮은 cand 먼저) + 해시 조인
WITH cand AS (
  SELECT /*+ index(c ix_cust_region_grade) */
         cust_id
  FROM   customers c
  WHERE  c.region = :r AND c.grade = :g
)
SELECT /*+ leading(cand o) use_hash(o) */
       o.cust_id, COUNT(*)
FROM   cand
JOIN   orders o ON o.cust_id = cand.cust_id
WHERE  o.order_dt >= SYSDATE - 7
GROUP  BY o.cust_id;

-- NL 조인 강제(키 기반 좁은 범위 반복 조회)
SELECT /*+ leading(o) use_nl(oi) index(oi(order_id)) */
       o.order_id, SUM(oi.qty*oi.price)
FROM   orders o
JOIN   order_items oi ON oi.order_id = o.order_id
WHERE  o.cust_id = :cust
AND    o.order_dt >= SYSDATE - 7
GROUP  BY o.order_id;
```

### **뷰 병합/프리디케이트 푸시** 제어

```sql
-- 조기 필터링 위해 뷰 병합 금지
SELECT /*+ no_merge(cand) */ *
FROM (
  SELECT /*+ index(c ix_cust_region_grade) */ cust_id
  FROM   customers c
  WHERE  region=:r AND grade=:g
) cand
JOIN orders o ON o.cust_id = cand.cust_id
WHERE o.order_dt >= SYSDATE - 7;

-- 프리디케이트 푸시(인라인뷰 내부로 WHERE 내려보내기)
SELECT /*+ push_pred */ *
FROM   (
  SELECT cust_id, order_dt, amount
  FROM   orders
  WHERE  order_dt >= SYSDATE - 7
) v
WHERE  v.amount > 1000;
```

---

## **전/후 측정**으로 I/O 절감 확인

### 실행계획 & 실제 수행 통계

```sql
ALTER SESSION SET statistics_level = ALL;

-- 대상 SQL 수행 후
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS +ALIAS'));
```
- `Buffers`/`Reads`(블록 수), `A-Rows`(실행 결과), `Starts` 로 **불필요 블록 감소** 확인.

### SQL별 I/O 프로파일

```sql
SELECT sql_id, plan_hash_value, executions,
       buffer_gets, disk_reads,
       ROUND(buffer_gets/NULLIF(executions,0)) AS avg_lio,
       ROUND(disk_reads/NULLIF(executions,0))  AS avg_pio
FROM   v$sql
WHERE  sql_text LIKE 'SELECT%orders%'
ORDER  BY avg_pio DESC
FETCH FIRST 20 ROWS ONLY;
```

### ASH/이벤트로 대기 패턴

```sql
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
AND    session_type='FOREGROUND'
AND    event IN ('db file sequential read','db file scattered read','db file parallel read')
GROUP  BY event
ORDER  BY samples DESC;
```

---

## “최소 블록 읽기”를 달성하는 **패턴/안티패턴 요약**

| 목표 | 패턴 | 안티패턴 |
|---|---|---|
| 범위 축소 | 파티션 프루닝, 인라인뷰로 후보 축소, 조기 필터 | 함수로 컬럼 감싸기, 불명확한 타입/형변환 |
| 랜덤 I/O 최소화 | 커버링 인덱스, 클러스터링 팩터 개선, BATCHED ROWID | SELECT-LIST 과다로 테이블 방문 증가 |
| 정렬 비용 절감 | 정렬 일치 인덱스 + Stopkey/Top-N | OFFSET 방식 페이지 네이션 |
| 존재성 확인 최적화 | EXISTS/NOT EXISTS, SEMI/ANTI JOIN | COUNT(*)로 존재 확인, DISTINCT 남발 |
| 조인 효율 | 선행 집합 축소 + 해시/NL 선택 | 광범위 조인 후 WHERE 필터 |
| 선택도 정확화 | 히스토그램/확장 통계, 시스템 통계 | 통계 부재/오래됨, 상관관계 무시 |

---

## 종합 시나리오: “최근 7일 VIP 고객 Top-K 주문 목록 + 합계”

### 나쁜 시작점

```sql
-- 1) 정렬 불일치 + OFFSET, 2) 광범위 조인 후 필터, 3) 통계 부정확
SELECT o.order_id, o.order_dt, o.amount
FROM   customers c
JOIN   orders o ON o.cust_id = c.cust_id
WHERE  c.region = :r
AND    c.grade  = 'VIP'
AND    TRUNC(o.order_dt) >= TRUNC(SYSDATE) - 7
ORDER  BY o.amount DESC
OFFSET :skip ROWS FETCH NEXT :take ROWS ONLY;
```

### 교정(쿼리 구조 → 팩터 → 힌트)

```sql
-- (A) 후보 축소: VIP 고객만 선행 집합으로
WITH vip AS (
  SELECT /*+ index(c ix_cust_region_grade) */
         c.cust_id
  FROM   customers c
  WHERE  c.region = :r
  AND    c.grade  = 'VIP'
)
-- (B) SARGable: TRUNC 제거, 범위형 조건
SELECT /*+ leading(vip o) use_hash(o) */
       o.order_id, o.order_dt, o.amount
FROM   vip
JOIN   orders o ON o.cust_id = vip.cust_id
WHERE  o.order_dt >= SYSDATE - 7
ORDER  BY o.amount DESC
FETCH FIRST :take ROWS ONLY;        -- Stopkey

-- (C) 통계 정비: 히스토그램/확장 통계/시스템 통계
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER, 'CUSTOMERS', '(region, grade)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS', method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',    method_opt=>'for all columns size skewonly');
END;
/
```
- **효과 기대**: 읽는 파티션/블록 수↓, 정렬량↓, NL/해시 선택이 정확, 디스크 읽기/버퍼 겟 대폭↓.

---

## 수학적 직관(간단)

- **총 블록 읽기 근사**
  $$ \text{Blocks} \approx \sum_{\text{row-source}} \big( \text{input rows} \times \text{per-row block touches} \big) $$
  - 입력 로우를 **극단적으로 줄이거나**(프루닝·조기 필터), **per-row 블록 접근을 1에 가깝게**(커버링/클러스터링) 만들면 **I/O가 선형으로 감소**.
- **정렬/Top-N 비용**
  $$ \text{Sort Cost} \propto \text{rows} \cdot \log(\text{rows}) $$
  - **Stopkey/인덱스 정렬 일치**로 **rows** 자체를 **앞부분만** 남기면 비용 급감.

---

## 체크리스트

- [ ] 컬럼에 함수/형변환을 씌운 조건을 **범위형 SARGable** 로 바꿨는가?
- [ ] **정렬 일치 인덱스 + Stopkey/Keyset** 로 앞부분만 읽는가?
- [ ] **커버링 인덱스** 로 테이블 랜덤 방문을 제거했는가?
- [ ] **파티션 프루닝** 이 100% 되는가(표현식/타입 주의)?
- [ ] **선행 집합 축소**(선택도 높은 조건/세미조인)로 **조인 입력**을 줄였는가?
- [ ] **객체/확장/시스템 통계**가 최신이며 **상관관계**가 반영되는가?
- [ ] 그래도 흔들리면 **힌트**로 안전 레일을 깔았는가(원인 교정 후)?
- [ ] 전/후 **DBMS_XPLAN + V$SQL + ASH** 로 **블록 수/대기/응답시간**이 실제로 줄었는가?

---

## 미니 벤치 루틴(복붙)

```sql
ALTER SESSION SET statistics_level = ALL;

-- BEFORE
SELECT o.order_id, o.order_dt, o.amount
FROM   customers c
JOIN   orders o ON o.cust_id = c.cust_id
WHERE  c.region = :r
AND    c.grade  = 'VIP'
AND    TRUNC(o.order_dt) >= TRUNC(SYSDATE) - 7
ORDER  BY o.amount DESC
OFFSET :skip ROWS FETCH NEXT :take ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

-- AFTER (개선안)
WITH vip AS (
  SELECT /*+ index(c ix_cust_region_grade) */ cust_id
  FROM   customers c
  WHERE  c.region = :r AND c.grade = 'VIP'
)
SELECT /*+ leading(vip o) use_hash(o) */
       o.order_id, o.order_dt, o.amount
FROM   vip
JOIN   orders o ON o.cust_id = vip.cust_id
WHERE  o.order_dt >= SYSDATE - 7
ORDER  BY o.amount DESC
FETCH FIRST :take ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

---

## 결론

- I/O 효율화의 정석은 **(1) 쿼리 구조 교정 → (2) 통계/팩터 제공 → (3) 힌트로 안전레일** 순서다.
- “**필요한 최소 블록만 읽게 만드는 것**”을 모든 선택 기준의 1순위에 두면,
  **응답시간/스루풋/자원 사용량**이 동시에 안정된다.
- 항상 **측정**(실행계획/블록 수/대기)을 통해 사실로 검증하라. “느낌이 아니라 숫자”가 답이다.
