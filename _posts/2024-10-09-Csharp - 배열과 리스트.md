---
layout: post
title: C# - 배열과 리스트
date: 2024-10-09 19:20:23 +0900
category: Csharp
---
# 배열과 리스트(List<T>)

## 상황별 컬렉션 선택 가이드

데이터를 어떻게 저장하고 접근할지 결정할 때, 다음 표를 참고하여 적절한 컬렉션을 선택하세요.

| 상황 | 추천 타입 | 주요 이유 및 참고사항 |
|---|---|---|
| 크기가 고정되고, 임의 접근(랜덤 액세스)이 빈번할 때 | `T[]` (1차원 배열) | 메모리가 연속적으로 할당되어 오버헤드가 가장 적고, 인덱스 접근 속도가 가장 빠릅니다. |
| 기존 배열의 일부를 읽기 전용으로 참조만 하고 싶을 때 | `ReadOnlySpan<T>` / `ArraySegment<T>` | 데이터를 복사하지 않고 원본의 특정 범위(슬라이스)를 참조할 수 있습니다. |
| 크기가 자주 변하고, 주로 끝에서 요소를 추가/삭제할 때 | `List<T>` | 내부적으로 동적 배열을 사용하여 자동으로 크기가 조정되며, 추가/삭제와 관련된 풍부한 API를 제공합니다. |
| 앞쪽이나 중간에서의 삽입·삭제가 매우 빈번할 때 | `LinkedList<T>` (또는 다른 자료구조) | 배열이나 리스트는 중간 삽입/삭제 시 요소를 이동(Shift)하는 비용이 큽니다. 연결 리스트는 이 비용이 적습니다. |
| 행과 열을 갖는 규칙적인 2차원 구조(예: 행렬)일 때 | `T[,]` (다차원 배열) | `[행, 열]` 형식의 인덱싱이 직관적입니다. 성능은 접근 패턴에 따라 다를 수 있습니다. |
| 각 행의 길이가 서로 다른 2차원 구조(예: 비정형 데이터)일 때 | `T[][]` (가변 배열) | 각 행을 독립적인 배열로 관리하여 메모리 사용을 최적화할 수 있습니다. |
| 여러 스레드에서 공유하거나, 컬렉션이 변경되지 않아야 할 때 | `ImmutableArray<T>` / `ImmutableList<T>` | 변경 시 원본을 수정하는 대신 새 컬렉션을 반환하여 스레드 안전성과 예측 가능성을 보장합니다. |

---

## 1. 배열(Array): 고정 크기의 데이터 컨테이너

배열은 동일한 타입의 요소들을 메모리에 연속적으로 저장하는 가장 기본적이고 효율적인 자료구조입니다. 크기가 고정되어 선언 시 결정되며, 0부터 시작하는 인덱스를 통해 빠르게 요소에 접근할 수 있습니다.

### 선언 및 초기화

```csharp
// 1. 크기만 지정 (기본값으로 초기화: 숫자는 0, 참조형은 null, bool은 false)
int[] numbers1 = new int[5]; // [0, 0, 0, 0, 0]

// 2. 크기와 값을 함께 지정
int[] numbers2 = new int[] { 90, 85, 77, 95, 88 };

// 3. 간결한 초기화 구문 (가장 일반적)
string[] weekdays = { "월", "화", "수", "목", "금" };

// 4. 명시적 타입 없이 var 사용 (컴파일러가 타입 추론)
var scores = new[] { 10.5, 20.3, 30.1 }; // double[]으로 추론
```

### 요소 접근, 수정, 순회

```csharp
int[] numbers = { 10, 20, 30, 40, 50 };

// 인덱스를 통한 접근과 수정
Console.WriteLine(numbers[1]); // 출력: 20
numbers[2] = 999; // 세 번째 요소를 999로 변경

// Length 속성을 이용한 for 루프 순회
for (int i = 0; i < numbers.Length; i++)
{
    Console.Write(numbers[i] + " "); // 10 20 999 40 50
}

// 간편한 foreach 루프 순회 (읽기 전용)
foreach (int num in numbers)
{
    Console.Write(num + " ");
}
```

### 배열의 크기 조정과 복사

배열은 크기가 고정되어 있으므로, "확장"은 사실 새 배열을 생성하고 기존 데이터를 복사하는 과정입니다.

```csharp
int[] source = { 1, 2, 3 };

// 1. Array.Copy를 이용한 수동 복사
int[] destination = new int[5];
Array.Copy(source, destination, source.Length); // destination: [1, 2, 3, 0, 0]

// 2. Array.Resize 정적 메서드 사용 (내부적으로 새 배열 생성)
Array.Resize(ref source, 5); // source는 이제 크기가 5인 새 배열을 참조합니다.
source[3] = 4; source[4] = 5; // [1, 2, 3, 4, 5]

// 3. LINQ의 ToArray() 메서드 (다른 컬렉션에서 변환 시 유용)
var list = new List<int> { 10, 20 };
int[] arrayFromList = list.ToArray(); // [10, 20]
```

### 부분 배열 참조하기 (복사 없이)

데이터를 복사하지 않고 원본 배열의 일부를 참조하여 작업할 때 사용합니다.

```csharp
int[] original = { 10, 20, 30, 40, 50, 60 };

// ArraySegment<T> 사용 (.NET Framework부터 제공)
var segment = new ArraySegment<int>(original, 1, 3); // 인덱스 1부터 3개 요소(20, 30, 40)
foreach (int value in segment)
{
    Console.WriteLine(value);
}

// Span<T> 사용 (.NET Core 2.1 / .NET 5+ 이후 권장, 성능 우수)
Span<int> spanSlice = original.AsSpan(2, 3); // 인덱스 2부터 3개 요소(30, 40, 50)
foreach (int value in spanSlice)
{
    Console.WriteLine(value);
}

// ReadOnlySpan<T> (읽기 전용으로 안전하게 참조)
ReadOnlySpan<int> readOnlySlice = original.AsSpan(1..4); // C# 8.0 범위 연산자 사용: 20, 30, 40
```

---

## 2. 다차원 배열 vs 가변 배열

### 다차원 배열(`T[,]`)

행과 열의 크기가 고정된 정형 2차원 구조에 적합합니다. 메모리에 단일 블록으로 할당됩니다.

```csharp
// 2행 3열의 2차원 정수 배열 선언 및 초기화
int[,] matrix = new int[2, 3]
{
    { 1, 2, 3 },
    { 4, 5, 6 }
};

Console.WriteLine(matrix[0, 1]); // 출력: 2 (0행 1열)
Console.WriteLine(matrix[1, 2]); // 출력: 6 (1행 2열)

// 각 차원의 길이 알아내기
int rows = matrix.GetLength(0); // 2 (첫 번째 차원: 행)
int cols = matrix.GetLength(1); // 3 (두 번째 차원: 열)
```

### 가변 배열(`T[][]`)

각 행이 독립적인 배열인 "배열의 배열"입니다. 행마다 길이가 다를 수 있어 비정형 데이터에 유용합니다.

```csharp
// 3개의 행을 가질 수 있는 가변 배열 선언 (각 행은 아직 null)
int[][] jagged = new int[3][];

// 각 행에 대해 길이가 다른 배열 할당
jagged[0] = new int[] { 1, 2, 3, 4 };       // 첫 번째 행: 길이 4
jagged[1] = new int[] { 10, 20 };           // 두 번째 행: 길이 2
jagged[2] = new int[] { 100, 200, 300 };    // 세 번째 행: 길이 3

Console.WriteLine(jagged[1][0]); // 출력: 10 (두 번째 행의 첫 번째 요소)
Console.WriteLine(jagged[2].Length); // 출력: 3 (세 번째 행의 길이)
```

### 선택 기준 비교

| 특성 | 다차원 배열 `T[,]` | 가변 배열 `T[][]` |
| :--- | :--- | :--- |
| **메모리 구조** | 모든 요소가 단일 연속 블록에 저장 | 각 행이 별도의 배열 객체 (간접 참조 발생) |
| **성능** | 일반적으로 캐시 지역성이 더 좋을 수 있음 | 행 접근 시 추가 간접 참조 비용 |
| **유연성** | 모든 행의 길이가 동일해야 함 | 각 행의 길이가 서로 달라도 됨 |
| **선언/초기화** | `int[,] arr = new int[2,3];` | `int[][] arr = new int[2][];` |
| **할당** | 한 번에 모든 메모리 할당 | 각 행별로 배열을 별도 할당 |

**결론**: 데이터가 완전한 행렬 형태(모든 행 길이 동일)이고 빠른 접근이 중요하면 `T[,]`를, 행마다 데이터 크기가 크게 다르거나 행을 동적으로 추가/삭제해야 한다면 `T[][]`를 고려하세요.

---

## 3. 배열의 유용한 정적 메서드

`Array` 클래스는 배열을 조작하는 다양한 정적 메서드를 제공합니다.

```csharp
int[] numbers = { 5, 2, 9, 1, 5, 6 };

// 1. 정렬 (원본 배열을 변경)
Array.Sort(numbers); // 오름차순 정렬: [1, 2, 5, 5, 6, 9]
Array.Sort(numbers, (a, b) => b.CompareTo(a)); // 내림차순 정렬 (비교자 사용)

// 2. 이진 검색 (반드시 정렬된 배열에서 사용)
int index = Array.BinarySearch(numbers, 5); // 첫 번째로 찾은 5의 인덱스(2) 반환
if (index >= 0)
    Console.WriteLine($"찾음: 인덱스 {index}");
else
    Console.WriteLine("없음");

// 3. 모든 요소를 다른 형식으로 변환
string[] stringNumbers = { "1", "2", "3" };
int[] intNumbers = Array.ConvertAll(stringNumbers, s => int.Parse(s)); // [1, 2, 3]

// 4. 조건을 만족하는 요소 찾기 (LINQ와 유사하지만 더 기본적)
int firstEven = Array.Find(numbers, n => n % 2 == 0); // 첫 번째 짝수: 2
int[] allEvens = Array.FindAll(numbers, n => n % 2 == 0); // 모든 짝수: [2, 6]

// 5. 배열 내용 지우기 (기본값으로 설정)
Array.Clear(numbers, 1, 3); // 인덱스 1부터 3개 요소를 0으로: [1, 0, 0, 0, 6, 9]
```

---

## 4. 리스트(List<T>): 동적 배열

`List<T>`는 가장 널리 사용되는 컬렉션으로, 필요에 따라 크기가 자동으로 증가하는 동적 배열을 구현합니다. 배열의 제한적인 크기 문제를 해결하면서도 인덱스 접근의 빠름을 유지합니다.

### 기본 사용법

```csharp
using System.Collections.Generic;

// 빈 리스트 생성
List<int> numbers = new List<int>();

// 컬렉션 초기화 구문을 이용한 생성과 동시에 요소 추가
List<string> fruits = new List<string> { "사과", "바나나", "오렌지" };

// 요소 추가
fruits.Add("딸기"); // 끝에 추가
fruits.AddRange(new[] { "포도", "복숭아" }); // 여러 요소 한 번에 추가

// 요소 접근 및 수정
Console.WriteLine(fruits[0]); // "사과"
fruits[1] = "키위"; // 두 번째 요소를 "키위"로 변경

// 요소 삭제
fruits.Remove("오렌지"); // 값으로 삭제 (첫 번째로 일치하는 요소)
fruits.RemoveAt(0); // 인덱스로 삭제 (첫 번째 요소 삭제)

// 유용한 속성과 메서드
int count = fruits.Count; // 현재 요소의 개수
bool hasApple = fruits.Contains("사과"); // 포함 여부 확인
int index = fruits.IndexOf("포도"); // 요소의 인덱스 찾기 (-1이면 없음)
```

### 순회 및 주의사항

```csharp
// foreach를 이용한 안전한 순회 (읽기 전용)
foreach (string fruit in fruits)
{
    Console.WriteLine(fruit);
}

// 주의: foreach 루프 내에서 컬렉션을 수정하면 예외 발생
// foreach (string fruit in fruits)
// {
//     if (fruit.Length < 2)
//         fruits.Remove(fruit); // 런타임 예외!
// }

// 수정이 필요할 때는 for 루프를 역방향으로 사용하는 것이 안전
for (int i = fruits.Count - 1; i >= 0; i--)
{
    if (fruits[i].Length < 2)
        fruits.RemoveAt(i);
}
```

### 내부 동작과 성능: Capacity와 Count

`List<T>`는 내부에 배열(`T[]`)을 유지하며, 두 가지 중요한 속성이 있습니다:
*   **`Count`**: 리스트에 실제로 포함된 요소의 수입니다.
*   **`Capacity`**: 내부 배열의 크기(용량)입니다. `Count`보다 크거나 같습니다.

```csharp
var list = new List<int>(); // Capacity = 0, Count = 0
list.Add(1); // 내부 배열이 생성되며 Capacity가 기본값(예: 4)으로 설정됨
list.Add(2); list.Add(3); list.Add(4); // Count = 4, Capacity = 4
list.Add(5); // 용량 부족! 내부 배열 크기를 늘림(일반적으로 두 배). Capacity = 8

// 예상 크기를 알고 있다면 생성 시 용량을 지정하여 불필요한 재할당 방지
var optimizedList = new List<int>(1000); // 초기 Capacity를 1000으로 설정
for (int i = 0; i < 1000; i++) optimizedList.Add(i); // 재할당 없이 빠르게 추가

// 작업 완료 후 불필요한 여유 공간을 제거하려면
list.TrimExcess(); // Capacity를 Count에 가깝게 조정 (용량이 90% 미만일 때만 조정)
```

**성능 특성**:
*   **인덱스 접근(`list[i]`)**: O(1) - 배열과 동일한 속도.
*   **끝에 추가(`Add`)**: 평균 O(1) (분할 상환 비용). 용량이 부족할 때만 O(n)의 재할당 비용 발생.
*   **중간 삽입/삭제(`Insert`, `RemoveAt`)**: O(n). 이후의 모든 요소를 이동시켜야 합니다.

### 리스트의 정렬과 검색

```csharp
var numbers = new List<int> { 23, 11, 45, 7, 19 };

// 정렬 (원본 변경)
numbers.Sort(); // 기본 오름차순: [7, 11, 19, 23, 45]
numbers.Sort((a, b) => b.CompareTo(a)); // 사용자 지정 비교자로 내림차순

// 이진 검색 (정렬된 리스트에서만 올바른 결과)
numbers.Sort();
int position = numbers.BinarySearch(19); // 인덱스 2 반환
if (position >= 0)
    Console.WriteLine($"찾은 위치: {position}");
```

### 읽기 전용 및 불변 버전

```csharp
var originalList = new List<string> { "A", "B", "C" };

// 1. 읽기 전용 래퍼 (IReadOnlyList<T> 반환)
IReadOnlyList<string> readOnlyView = originalList.AsReadOnly();
// readOnlyView.Add("D"); // 컴파일 오류: 추가 메서드 없음

// 2. 완전한 불변 리스트 (System.Collections.Immutable 패키지 필요)
using System.Collections.Immutable;
ImmutableList<string> immutableList = originalList.ToImmutableList();
ImmutableList<string> newList = immutableList.Add("D"); // 원본은 변경되지 않고, 새 리스트 반환
```

---

## 5. 배열 vs 리스트: 상세 비교 및 결정 요인

| 기준 | 배열 `T[]` | 리스트 `List<T>` |
| :--- | :--- | :--- |
| **크기** | 고정 (생성 시 결정) | 동적 (실행 중 자동 조정) |
| **성능** | 인덱스 접근: 최고속 | 인덱스 접근: 매우 빠름 (내부가 배열) |
| **메모리** | 최소 오버헤드 (고정) | 추가 오버헤드 (Capacity 관리) |
| **편의성** | 기본 기능만 제공 | 삽입, 삭제, 검색, 정렬 등 풍부한 API |
| **활용도** | 고성능 계산, 고정 데이터 | 일반적인 비즈니스 로직, 데이터 처리 |
| **변환** | `.ToList()`로 리스트로 변환 | `.ToArray()`로 배열로 변환 |
| **부분 작업** | `Span<T>`, `ArraySegment` 지원 | `.GetRange()`, `.AsReadOnly()` 지원 |

**핵심 결론**:
*   데이터 크기가 애플리케이션 전체에서 **절대 변하지 않는다면 배열**을 사용하세요.
*   데이터가 추가/삭제되거나 크기를 예측하기 어렵다면 **리스트**를 사용하세요.
*   성능이 극도로 중요한 핵심 루프에서는 배열이나 `Span<T>`를 고려하세요.

---

## 6. LINQ와의 조합

Language-Integrated Query(LINQ)는 컬렉션 데이터를 쿼리하기 위한 강력한 구문입니다. 배열과 리스트 모두 LINQ를 완벽하게 지원합니다.

```csharp
using System.Linq;

int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// 1. 필터링 (Where)
var evenNumbers = numbers.Where(n => n % 2 == 0); // [2, 4, 6, 8, 10]

// 2. 변환 (Select)
var squared = numbers.Select(n => n * n); // [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

// 3. 집계 (Aggregate)
int sum = numbers.Sum(); // 55
double avg = numbers.Average(); // 5.5
int max = numbers.Max(); // 10

// 4. 정렬 (OrderBy)
var sortedDesc = numbers.OrderByDescending(n => n); // [10, 9, 8, ... , 1]

// 중요: LINQ 쿼리는 지연 실행됩니다. 결과를 재사용하려면 구체화(Materialize)해야 합니다.
var query = numbers.Where(n => n > 5); // 아직 실행되지 않음
List<int> materialized = query.ToList(); // 실제로 쿼리 실행 후 리스트로 변환
int[] asArray = query.ToArray(); // 배열로 변환
```

---

## 7. 실전 예제와 패턴

### 예제 1: 성적 처리 (배열 활용)

```csharp
using System;

class GradeAnalyzer
{
    static void Main()
    {
        int[] scores = { 95, 82, 77, 61, 50, 100, 89, 73 };

        // 1. 기본 통계
        Array.Sort(scores);
        Console.WriteLine($"정렬된 점수: {string.Join(", ", scores)}");
        Console.WriteLine($"최고점: {scores[scores.Length - 1]}, 최저점: {scores[0]}");

        // 2. 상위 3개 점수 (복사 없이 슬라이스)
        var top3Span = scores.AsSpan(scores.Length - 3, 3);
        Console.WriteLine($"상위 3개: {string.Join(", ", top3Span.ToArray())}");

        // 3. 특정 점수 이상인 학생 수
        int passingCount = Array.FindAll(scores, s => s >= 70).Length;
        Console.WriteLine($"70점 이상 통과자: {passingCount}명");
    }
}
```

### 예제 2: 재고 관리 (리스트 활용)

```csharp
using System;
using System.Collections.Generic;

class InventoryItem
{
    public string Name { get; set; }
    public int Quantity { get; set; }
    public decimal Price { get; set; }

    public override string ToString() => $"{Name} (수량: {Quantity}, 가격: {Price:C})";
}

class InventoryManager
{
    static void Main()
    {
        var inventory = new List<InventoryItem>
        {
            new InventoryItem { Name = "노트북", Quantity = 5, Price = 1200000 },
            new InventoryItem { Name = "마우스", Quantity = 0, Price = 25000 }, // 품절
            new InventoryItem { Name = "키보드", Quantity = 12, Price = 80000 },
            new InventoryItem { Name = "모니터", Quantity = 3, Price = 300000 }
        };

        // 1. 품절된 항목 제거
        inventory.RemoveAll(item => item.Quantity == 0);
        Console.WriteLine("품절 제거 후:");
        inventory.ForEach(Console.WriteLine);

        // 2. 재고량 기준 내림차순 정렬
        inventory.Sort((a, b) => b.Quantity.CompareTo(a.Quantity));
        Console.WriteLine("\n재고량 순 정렬:");
        inventory.ForEach(Console.WriteLine);

        // 3. 특정 품목 검색
        var found = inventory.Find(item => item.Name.Contains("노트"));
        if (found != null)
            Console.WriteLine($"\n검색 결과: {found}");
    }
}
```

---

## 마무리: 컬렉션 선택의 예술

배열과 리스트는 C#에서 데이터를 조직화하는 가장 기본적이면서도 핵심적인 도구입니다. 올바른 선택은 애플리케이션의 성능과 유지보수성에 직접적인 영향을 미칩니다.

*   **배열**은 **단순함, 속도, 예측 가능성**이 핵심입니다. 크기가 확실히 고정된 데이터(예: 요일 이름, 고정된 설정값)나 극한의 성능이 필요한 수치 계산에 적합합니다. 최신 C#의 `Span<T>`와 함께 사용하면 메모리 효율성과 성능을 극대화할 수 있습니다.

*   **리스트**는 **유연성과 편의성**이 장점입니다. 실무에서 마주하는 대부분의 비즈니스 데이터(고객 목록, 주문 항목, 로그 메시지)는 그 크기를 미리 알 수 없거나 자주 변하기 때문에, `List<T>`가 사실상의 표준 선택이 됩니다. 풍부한 API는 생산성을 크게 높여줍니다.

이 두 가지를 이해한 후에는, 특수한 상황에 맞는 다른 컬렉션(`Dictionary<TKey, TValue>`, `HashSet<T>`, `Queue<T>`, `Stack<T>` 등)을 학습하는 것으로 자연스럽게 확장할 수 있습니다. 가장 중요한 것은 데이터의 특성과 애플리케이션의 요구사항을 정확히 이해하고, 그에 맞는 가장 단순하면서 효율적인 도구를 선택하는 것입니다.