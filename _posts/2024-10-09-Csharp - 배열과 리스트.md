---
layout: post
title: C# - 배열과 리스트
date: 2024-10-09 19:20:23 +0900
category: Csharp
---
# 배열과 리스트(List)

## 한눈에 보는 결정표

| 상황 | 추천 타입 | 이유/비고 |
|---|---|---|
| 크기가 고정, 인덱스 랜덤 접근 중심 | `T[]`(1차원 배열) | 메모리 연속, 오버헤드 최소, 가장 빠른 인덱싱 |
| 읽기 전용 슬라이스/부분 배열 | `ReadOnlySpan<T>` / `ArraySegment<T>` | 복사 없이 범위를 참조 |
| 변동 크기, 잦은 추가/삭제(주로 끝쪽) | `List<T>` | 자동 확장, 풍부한 API |
| 앞/중간 삽입·삭제가 많음 | `LinkedList<T>` / 다른 자료구조 | 배열/리스트는 불리(Shift 비용) |
| 다차원 수학적 인덱싱 | `T[,]`(다차원 배열) | 행·열 인덱싱 직관적(성능은 케이스별 확인) |
| 행 길이가 제각각 | `T[][]`(가변(Jagged) 배열) | 각 행을 독립 배열로 최적화 가능 |
| 스레드 간 공유, 불변 요구 | `ImmutableArray<T>` / `ImmutableList<T>` | 참조 공유 안전성 확보 |

---

## 배열(Array)

### 선언/초기화

```csharp
int[] numbers = new int[5];                 // 기본값으로 초기화(0)
int[] scores  = new int[] { 90, 80, 70 };   // 크기/값 지정
string[] names = { "Alice", "Bob", "Charlie" }; // 축약 초기화
```

- 배열은 **고정 크기**, **0 기반 인덱스**입니다.
- 기본값: 값형은 0/false, 참조형은 null.

### 접근/수정/길이

```csharp
Console.WriteLine(scores[1]); // 80
scores[2] = 75;

for (int i = 0; i < names.Length; i++)
    Console.WriteLine(names[i]);

foreach (var n in names)
    Console.WriteLine(n);
```

### 복사/확장(재할당) 패턴

```csharp
var src = new[] {1,2,3};
var dst = new int[src.Length];
Array.Copy(src, dst, src.Length);     // 빠른 메모리 복사

// "확장"은 새 배열을 만들어 옮기는 것(크기 고정이므로)
Array.Resize(ref dst, 5);             // [1,2,3,0,0]
dst[3] = 9; dst[4] = 8;
```

### 부분 뷰: ArraySegment / AsSpan

```csharp
var a = new[] {10,20,30,40,50};

var seg = new ArraySegment<int>(a, 1, 3); // 20,30,40
foreach (var v in seg) Console.WriteLine(v);

// .NET 6+: Span
ReadOnlySpan<int> s = a.AsSpan(1, 3);
foreach (var v in s) Console.WriteLine(v);
```

- **복사 없이** 부분 배열을 핸들링합니다.

---

## 다차원 vs 가변(Jagged) 배열

### 2차원(직사각) 배열 `T[,]`

```csharp
int[,] matrix = new int[2,3]
{
    {1,2,3},
    {4,5,6}
};

Console.WriteLine(matrix[1,2]); // 6
```

- 인덱스: `[행, 열]`.
- 메모리 배치/캐시 국면에서 패턴에 따라 성능 차이가 있을 수 있습니다.

### 가변(Jagged) 배열 `T[][]`

```csharp
int[][] jag = new int[2][];
jag[0] = new[] { 1, 2, 3, 4 };
jag[1] = new[] { 10, 20 };

Console.WriteLine(jag[1][0]); // 10
```

- 행마다 길이가 다를 때 유리.
- 각 행이 **독립 배열**이므로, 행별 확장이 쉬움.

### 선택 기준

| 항목 | `T[,]` | `T[][]` |
|---|---|---|
| 인덱싱 | `m[i,j]` | `m[i][j]` |
| 행 길이 | 모두 동일 | 각 행 독립 |
| 확장성 | 행/열 확장 불편 | 특정 행만 교체/확장 용이 |
| 메모리 | 단일 객체(행렬) | 행 개수만큼 배열 객체 추가 |

---

## 배열 정렬/검색/변환

### 정렬

```csharp
var a = new[] { 5, 2, 9, 1 };
Array.Sort(a); // 1,2,5,9

// 사용자 정의 비교자
Array.Sort(a, Comparer<int>.Create((x,y) => y.CompareTo(x))); // 내림차순
```

### 이진 검색(정렬 후)

```csharp
Array.Sort(a);                 // 반드시 정렬되어 있어야 함
int idx = Array.BinarySearch(a, 5); // 존재하면 인덱스(>=0), 없으면 음수
```

### 변환/투영

```csharp
string[] names = { "alice", "bob" };
var upper = Array.ConvertAll(names, s => s.ToUpperInvariant());
```

---

## Span/Memory로 복사 없는 슬라이스(고급)

> 성능 민감 루프에서 **할당을 줄이고** 슬라이스 기반 처리를 할 수 있습니다.

```csharp
Span<int> span = stackalloc int[4]; // 스택에 고정 크기(소량) 할당
span[0] = 10; span[1] = 20;

int[] big = { 1,2,3,4,5,6 };
Span<int> middle = big.AsSpan(2, 3); // 3,4,5
foreach (ref readonly var v in middle)
    Console.WriteLine(v);
```

- 파일/네트워크 버퍼 처리 등에서 유용.

---

## 리스트(List<T>)

### 선언/초기화/추가

```csharp
using System.Collections.Generic;

var list = new List<int>();                // 빈 리스트
list.Add(10);
list.Add(20);

var fruits = new List<string> { "사과", "바나나", "포도" }; // 컬렉션 초기자
```

### 핵심 API

| 멤버 | 설명 |
|---|---|
| `Add`, `AddRange` | 끝에 추가 |
| `Insert`, `InsertRange` | 특정 위치 삽입(뒤 요소 이동) |
| `Remove`, `RemoveAt`, `RemoveAll` | 값/인덱스/조건 삭제 |
| `Contains`, `IndexOf`, `Find`, `FindIndex` | 검색 |
| `Sort`, `Reverse` | 정렬/역순 |
| `ToArray`, `AsReadOnly` | 배열 변환/읽기전용 래핑 |
| `Capacity`, `Count` | 내부 버퍼 크기/요소 수 |

```csharp
fruits.Add("딸기");
fruits.Remove("바나나");
Console.WriteLine(fruits.Contains("사과")); // true
Console.WriteLine(fruits.Count);            // 3
```

### 순회

```csharp
foreach (string fruit in fruits)
    Console.WriteLine(fruit);
```

> **주의:** `foreach` 순회 중 리스트를 수정하면 예외가 발생합니다. 수정이 필요하면 `for` 사용이나 `ToList()`로 스냅샷을 만든 뒤 수정하세요.

```csharp
for (int i = fruits.Count - 1; i >= 0; i--)
    if (fruits[i].Length <= 2) fruits.RemoveAt(i);
```

### Capacity/성장 방식과 시간복잡도

- `List<T>`는 내부에 **동적 배열**을 가집니다.
- 용량이 찼을 때 보통 **두 배**로 확장(구현 버전에 따라 근사).
  삽입 평균 시간복잡도는 **$$\tilde O(1)$$**(암티), 최악은 **O(n)**(재할당/복사).
- 중간 삽입/삭제는 요소 이동(Shift)이 필요하므로 **O(n)**.

```csharp
var xs = new List<int>(capacity: 1024); // 예상 크기를 알면 미리 할당
for (int i = 0; i < 1000; i++) xs.Add(i);
xs.Capacity = xs.Count; // 필요 시 메모리 절감
```

### 정렬/검색

```csharp
var xs = new List<int> { 5,2,9,1 };
xs.Sort(); // 1,2,5,9
int pos = xs.BinarySearch(5); // 정렬 후에만 사용
```

- 사용자 정의 비교자:

```csharp
xs.Sort((a,b) => b.CompareTo(a)); // 내림차순
```

### 읽기 전용/불변 컬렉션

```csharp
var readOnly = fruits.AsReadOnly(); // IReadOnlyList<T> 유사 사용감(래퍼)

// System.Collections.Immutable
using System.Collections.Immutable;
var imm = fruits.ToImmutableList();  // 이후 Add 등은 새 리스트 반환(원본 불변)
```

- 불변 컬렉션은 **공유 안전성**과 **스레드 안전** 측면에서 유리합니다.

---

## 배열 vs 리스트: 상세 비교

| 항목 | 배열(`T[]`) | 리스트(`List<T>`) |
|---|---|---|
| 크기 | 고정 | 가변(자동 확장) |
| 접근 | 인덱스 O(1) | 인덱스 O(1) |
| 삽입/삭제(끝) | 새 배열로 교체 필요 | 평균 O(1) (암티) |
| 삽입/삭제(중간) | O(n) | O(n) |
| 메모리 | 최소 오버헤드 | 내부 버퍼 + 여유 Capacity |
| API 풍부함 | 제한적 | 풍부(검색/정렬/변환) |
| 부분 뷰 | `ArraySegment`, `Span` | `GetRange`, `AsReadOnly` |
| 읽기 전용 | `ReadOnlySpan<T>` 등 | `AsReadOnly`, `IReadOnlyList<T>` |
| 변환 | `ToList()` | `ToArray()` |

---

## LINQ와 함께 쓰기

```csharp
using System.Linq;

int[] data = { 1, 2, 3, 4, 5, 6 };
var evens = data.Where(x => x % 2 == 0).ToList();  // 2,4,6
var squares = data.Select(x => x * x).ToArray();   // 1,4,9,16,25,36
```

- **지연 실행**에 유의. 필요 시 `ToList`/`ToArray`로 실수행.

---

## 실전 예제

### 시험 점수 통계(배열 → 정렬/검색/슬라이스)

```csharp
using System;

class Program
{
    static void Main()
    {
        int[] scores = { 95, 82, 77, 61, 50, 100, 89, 73 };

        Array.Sort(scores); // 오름차순
        Console.WriteLine(string.Join(",", scores));

        // 상위 3개: 복사 없이 슬라이스
        var top3 = scores.AsSpan(scores.Length - 3, 3);
        Console.WriteLine(string.Join(",", top3.ToArray()));

        // 특정 점수 존재 여부(정렬 후 이진검색)
        int idx = Array.BinarySearch(scores, 89);
        Console.WriteLine(idx >= 0 ? "89 존재" : "89 없음");
    }
}
```

### 재고 관리(List<T>) — 조건 삭제/정렬/검색

```csharp
using System;
using System.Collections.Generic;

class Item { public string Name = ""; public int Qty; public override string ToString() => $"{Name}:{Qty}"; }

class Program
{
    static void Main()
    {
        var stock = new List<Item>
        {
            new() { Name="Pen", Qty=12 },
            new() { Name="Book", Qty=3 },
            new() { Name="Eraser", Qty=0 }
        };

        stock.RemoveAll(i => i.Qty == 0);         // 조건 삭제
        stock.Sort((a,b) => b.Qty.CompareTo(a.Qty)); // 수량 내림차순
        foreach (var it in stock) Console.WriteLine(it);
    }
}
```

### 다차원 vs 가변 배열 — 행 평균

```csharp
static double RowAvg(int[,] m, int r)
{
    int cols = m.GetLength(1);
    int sum = 0;
    for (int c = 0; c < cols; c++) sum += m[r,c];
    return (double)sum / cols;
}

static double RowAvgJag(int[][] m, int r)
{
    var row = m[r];
    int sum = 0;
    for (int i = 0; i < row.Length; i++) sum += row[i];
    return (double)sum / row.Length;
}
```

---

## 성능/메모리 포인트

1. **배열은 연속 메모리** → 캐시 친화적. 고정 크기일수록 유리.
2. **List<T>**는 성장 시 **재할당+복사** 비용. 예상 크기면 `new(capacity)` 권장.
3. **부분 처리**는 복사 대신 `Span`/`ArraySegment`/`GetRange` 고려.
4. **박싱** 방지: `List<object>`에 값형을 넣으면 박싱. 제네릭 타입을 맞추세요.
5. **정렬/검색**: 잦은 검색은 정렬 + BinarySearch 또는 `Dictionary/HashSet`로 전환.
6. **다차원 vs 가변**: 행별 길이 차이가 크면 가변 배열이 메모리/성능 측면에서 유리.
7. **foreach 수정 금지**: 수정 필요 시 `for` 또는 스냅샷.

---

## 수학적 메모 — 동적 배열 성장 비용(평균)

`List<T>`가 용량을 두 배로 늘린다고 가정하면, 총 `n`번 `Add` 수행의 복사 비용 총합은 등비수열 합에 의해 상수배로 상쇄되어 **평균 삽입 비용**은 다음과 같이 상수 시간으로 볼 수 있습니다.

$$
\text{AmortizedInsert} = O(1)
$$

단, **중간 삽입/삭제**는 요소 이동 때문에 $$O(n)$$.

---

## 자주 하는 실수와 대안

| 실수 | 문제 | 대안 |
|---|---|---|
| 반복적으로 `List<T>.Add` 하며 필요 용량 예측 무시 | 반복 성장 비용 누적 | 예상 크기면 `new(capacity)` |
| `foreach` 중 컬렉션 수정 | 예외/동기화 문제 | `for` 사용, 또는 `.ToList()` 후 수정 |
| 부분 배열을 `ToArray`로 매번 복사 | 불필요 할당 | `Span`/`ArraySegment`/`GetRange` |
| 검색을 매번 `List<T>.Contains` | $$O(n)$$ 반복 | `HashSet<T>`로 전환 |
| 2D 데이터인데 가변 배열 남용 | 캐시/간접 참조 비용 | 접근 패턴에 맞춰 `T[,]` 검토 |

---

## 연습 문제

1) 정수 배열에서 **상위 K개**만 오름차순으로 출력(정렬 + 슬라이스).
2) 문자열 리스트에서 길이가 **3 이하**인 항목 삭제(역방향 `for`).
3) 2차원 배열 `int[,]`의 대각합 계산.
4) Jagged 배열로 분 단위 로그를 시간별 버킷(60개)으로 묶고, 빈도 상위 3개 시간대 출력.
5) 재고 리스트를 **이름 사전순** 정렬 후 **이진검색**으로 품목 찾기.

---

## 요약

- **배열**은 고정 크기, 빠른 인덱스/연속 메모리. 슬라이스는 `Span`/`ArraySegment`.
- **List<T>**는 가변 크기, 풍부한 API. Capacity를 이해하고 사용.
- **다차원 vs 가변**은 데이터 형태/접근 패턴에 따라 선택.
- **정렬/검색/슬라이스** 조합으로 대부분의 실무 요구를 커버할 수 있습니다.
- 성능이 중요하면 **복사 최소화, 캐시 친화적 접근, 적절한 컬렉션 선택**이 핵심입니다.
