---
layout: post
title: DB 심화 - 소트를 발생시키는 오퍼레이션
date: 2025-11-21 20:25:23 +0900
category: DB 심화
---
# 소트 오퍼레이션 완전 분석: 성능 튜닝의 핵심

## 소트 오퍼레이션 이해의 중요성

데이터베이스에서 발생하는 소트(Sort) 오퍼레이션은 성능에 지대한 영향을 미치는 핵심 요소입니다. 소트 작업은 대량의 메모리와 I/O 자원을 소비하며, 잘못 관리되면 시스템 전체 성능을 저하시킬 수 있습니다. 이 가이드는 Oracle 데이터베이스에서 발생하는 다양한 소트 오퍼레이션을 심층적으로 분석하고 효과적인 튜닝 전략을 제시합니다.

## 실습 환경 설정 및 모니터링 체계 구축

### 기본 테이블 생성
```sql
CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

CREATE TABLE f_sales (
  sales_id  NUMBER PRIMARY KEY,
  prod_id   NUMBER NOT NULL REFERENCES d_product(prod_id),
  sales_dt  DATE   NOT NULL,
  qty       NUMBER NOT NULL,
  amount    NUMBER(12,2) NOT NULL
);

CREATE INDEX ix_sales_prod_dt ON f_sales(prod_id, sales_dt);
```

### 성능 모니터링을 위한 유틸리티
```sql
-- 소트 관련 통계를 캡처하기 위한 임시 테이블
CREATE GLOBAL TEMPORARY TABLE gtt_stat_snap (
  name VARCHAR2(64), 
  val NUMBER
) ON COMMIT PRESERVE ROWS;

-- 실행 전후 통계 비교 함수
CREATE OR REPLACE FUNCTION get_sort_stat_delta RETURN SYS_REFCURSOR IS
  v_cursor SYS_REFCURSOR;
BEGIN
  OPEN v_cursor FOR
    SELECT 
      a.name as stat_name,
      (b.val - a.val) as delta_value,
      CASE 
        WHEN (b.val - a.val) > 0 THEN '증가'
        WHEN (b.val - a.val) < 0 THEN '감소'
        ELSE '변화 없음'
      END as change_status
    FROM gtt_stat_snap a
    JOIN (
      SELECT sn.name, ms.value val
      FROM v$mystat ms 
      JOIN v$statname sn ON sn.stat# = ms.stat#
      WHERE sn.name IN (
        'sorts (memory)',
        'sorts (disk)',
        'workarea executions - optimal',
        'workarea executions - onepass',
        'workarea executions - multipass',
        'session pga memory',
        'session pga memory max'
      )
    ) b ON a.name = b.name
    ORDER BY ABS(b.val - a.val) DESC;
    
  RETURN v_cursor;
END;
/
```

## SORT AGGREGATE: 스칼라 집계의 비밀

### 발생 조건과 특징
SORT AGGREGATE는 `GROUP BY` 절 없이 집계 함수(`COUNT`, `SUM`, `AVG` 등)를 사용할 때 발생합니다. 이 작업은 전체 데이터를 스캔한 후 단일 행으로 결과를 축약합니다.

```sql
-- SORT AGGREGATE 발생 예시
SELECT COUNT(*) as total_count, 
       SUM(amount) as total_amount,
       AVG(amount) as average_amount
FROM f_sales;
```

### 성능 측정과 분석
```sql
-- 성능 측정 절차
DECLARE
  v_cursor SYS_REFCURSOR;
  v_stat_name VARCHAR2(64);
  v_delta NUMBER;
  v_status VARCHAR2(20);
BEGIN
  -- 초기 통계 캡처
  INSERT INTO gtt_stat_snap
  SELECT sn.name, ms.value
  FROM v$mystat ms 
  JOIN v$statname sn ON sn.stat# = ms.stat#
  WHERE sn.name IN ('sorts (memory)', 'sorts (disk)');
  
  -- 쿼리 실행
  FOR i IN (SELECT COUNT(*) as cnt, SUM(amount) as amt FROM f_sales) LOOP
    DBMS_OUTPUT.PUT_LINE('Count: ' || i.cnt || ', Amount: ' || i.amt);
  END LOOP;
  
  -- 통계 델타 확인
  v_cursor := get_sort_stat_delta();
  LOOP
    FETCH v_cursor INTO v_stat_name, v_delta, v_status;
    EXIT WHEN v_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_stat_name || ': ' || v_delta || ' (' || v_status || ')');
  END LOOP;
  CLOSE v_cursor;
END;
/
```

### 최적화 전략
1. **필터링 최적화**: WHERE 절을 사용하여 불필요한 데이터를 조기에 제거
2. **파티션 활용**: 파티션 테이블에서 필요한 파티션만 스캔
3. **물리적 디자인**: 적절한 인덱스를 사용하여 데이터 액세스 최적화

## SORT ORDER BY: 정렬 작업의 깊은 이해

### 발생 메커니즘
ORDER BY 절이 인덱스로 처리되지 못할 때 발생합니다. 대량 데이터를 정렬할 때는 TEMP 테이블스페이스를 사용하여 디스크 I/O가 발생할 수 있습니다.

```sql
-- 기본 정렬 쿼리
SELECT sales_id, prod_id, sales_dt, amount
FROM f_sales
ORDER BY amount DESC;
```

### 인덱스를 활용한 정렬 최적화
```sql
-- 정렬 방향에 맞는 인덱스 생성
CREATE INDEX ix_sales_amount_desc ON f_sales(amount DESC);

-- 인덱스를 활용한 정렬 (소트 제거)
SELECT /*+ INDEX(f_sales ix_sales_amount_desc) */
       sales_id, prod_id, sales_dt, amount
FROM f_sales
ORDER BY amount DESC;
```

### Top-N 쿼리 최적화
```sql
-- STOPKEY를 활용한 효율적인 Top-N 쿼리
SELECT sales_id, amount
FROM f_sales
ORDER BY amount DESC
FETCH FIRST 10 ROWS ONLY;

-- 실행 계획 확인
EXPLAIN PLAN FOR
SELECT sales_id, amount
FROM f_sales
ORDER BY amount DESC
FETCH FIRST 10 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## SORT GROUP BY vs HASH GROUP BY: 집계 방식의 선택

### 두 방식의 차이점 이해

| 특성 | SORT GROUP BY | HASH GROUP BY |
|------|---------------|---------------|
| **작동 방식** | 데이터 정렬 후 그룹화 | 해시 테이블을 사용한 그룹화 |
| **메모리 사용** | 중간 정도 | 상대적으로 많음 |
| **적합한 상황** | 데이터가 이미 정렬된 경우 | 대량 데이터, 그룹 수가 적은 경우 |
| **TEMP 사용** | 정렬이 필요하면 TEMP 사용 | 해시 테이블이 메모리를 초과하면 TEMP 사용 |

### 실전 예제와 비교
```sql
-- 기본 GROUP BY (옵티마이저가 선택)
SELECT prod_id, COUNT(*) as transaction_count, SUM(amount) as total_amount
FROM f_sales
GROUP BY prod_id;

-- 실행 계획 강제 지정 (튜닝 테스트용)
SELECT /*+ NO_USE_HASH_AGGREGATION */ 
       prod_id, COUNT(*), SUM(amount)
FROM f_sales
GROUP BY prod_id;  -- SORT GROUP BY 강제

SELECT /*+ USE_HASH_AGGREGATION */ 
       prod_id, COUNT(*), SUM(amount)
FROM f_sales
GROUP BY prod_id;  -- HASH GROUP BY 강제
```

### 상황별 최적 전략
1. **데이터가 이미 정렬된 경우**: SORT GROUP BY가 유리
2. **그룹 수가 적고 데이터량이 많은 경우**: HASH GROUP BY가 유리
3. **메모리 제약이 있는 경우**: 상황에 따라 테스트 필요

## SORT UNIQUE: 중복 제거의 비용

### DISTINCT와 UNION의 성능 영향
```sql
-- DISTINCT 사용 (SORT UNIQUE 발생)
SELECT DISTINCT prod_id
FROM f_sales;

-- UNION 사용 (정렬 + 중복 제거)
SELECT prod_id FROM f_sales WHERE amount >= 10000
UNION
SELECT prod_id FROM f_sales WHERE sales_dt >= DATE '2025-02-01';

-- UNION ALL 사용 (정렬 없음, 중복 허용)
SELECT prod_id FROM f_sales WHERE amount >= 10000
UNION ALL
SELECT prod_id FROM f_sales WHERE sales_dt >= DATE '2025-02-01';
```

### 대체 방안
```sql
-- EXISTS를 사용한 중복 제거 최적화
SELECT DISTINCT s.prod_id
FROM f_sales s
WHERE EXISTS (
  SELECT 1 FROM f_sales s2 
  WHERE s2.prod_id = s.prod_id 
  AND s2.amount >= 10000
)
OR EXISTS (
  SELECT 1 FROM f_sales s2 
  WHERE s2.prod_id = s.prod_id 
  AND s2.sales_dt >= DATE '2025-02-01'
);
```

## SORT JOIN: Sort-Merge Join의 내부 구조

### Sort-Merge Join의 작동 원리
Sort-Merge Join은 두 테이블을 각각 조인 키로 정렬한 후 머지하는 방식입니다. 대량 데이터 조인에서 유용할 수 있지만 정렬 비용이 추가됩니다.

```sql
-- Sort-Merge Join 예제
SELECT /*+ USE_MERGE(s p) */ 
       p.category, COUNT(*) as sale_count, SUM(s.amount) as total_amount
FROM f_sales s
JOIN d_product p ON p.prod_id = s.prod_id
GROUP BY p.category;
```

### 대체 조인 방식 비교
```sql
-- Nested Loops Join (인덱스 기반)
SELECT /*+ ORDERED USE_NL(s) INDEX(s) */ 
       p.category, COUNT(*) as sale_count
FROM d_product p
JOIN f_sales s ON s.prod_id = p.prod_id
GROUP BY p.category;

-- Hash Join (메모리 기반)
SELECT /*+ USE_HASH(s) */ 
       p.category, COUNT(*) as sale_count
FROM d_product p
JOIN f_sales s ON s.prod_id = p.prod_id
GROUP BY p.category;
```

## WINDOW SORT: 분석 함수의 정렬 비용

### 윈도우 함수의 성능 특성
윈도우 함수는 PARTITION BY와 ORDER BY를 사용하여 데이터를 정렬합니다. 대량 파티션에서는 상당한 정렬 비용이 발생할 수 있습니다.

```sql
-- 윈도우 함수 사용 예제
SELECT 
  prod_id,
  sales_dt,
  amount,
  SUM(amount) OVER (
    PARTITION BY prod_id 
    ORDER BY sales_dt
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) as running_total,
  ROW_NUMBER() OVER (
    PARTITION BY prod_id 
    ORDER BY amount DESC
  ) as rank_within_product
FROM f_sales;
```

### 윈도우 함수 최적화 전략
```sql
-- 1. 파티션 크기 최적화
-- 작은 파티션으로 분할
SELECT 
  TRUNC(sales_dt, 'MM') as month,
  prod_id,
  SUM(amount) as monthly_amount,
  SUM(SUM(amount)) OVER (
    PARTITION BY prod_id 
    ORDER BY TRUNC(sales_dt, 'MM')
  ) as cumulative_amount
FROM f_sales
GROUP BY TRUNC(sales_dt, 'MM'), prod_id;

-- 2. 필요 없는 정렬 제거
SELECT 
  prod_id,
  sales_dt,
  amount,
  SUM(amount) OVER (
    PARTITION BY prod_id 
    -- ORDER BY 제거 (정렬 불필요시)
  ) as total_by_product
FROM f_sales;
```

## 대량 데이터 시나리오 실전 튜닝

### 대량 데이터 준비
```sql
-- 테스트 데이터 생성
DECLARE
  v_start_id NUMBER := 1000000;
  v_batch_size NUMBER := 10000;
BEGIN
  FOR i IN 1..50 LOOP  -- 50만 행 생성
    INSERT /*+ APPEND */ INTO f_sales(sales_id, prod_id, sales_dt, qty, amount)
    SELECT 
      v_start_id + ROWNUM,
      CASE MOD(ROWNUM, 5) 
        WHEN 0 THEN 10 
        WHEN 1 THEN 20 
        WHEN 2 THEN 30 
        WHEN 3 THEN 40 
        ELSE 50 
      END,
      DATE '2025-01-01' + MOD(ROWNUM, 365),
      1 + MOD(ROWNUM, 10),
      1000 + MOD(ROWNUM, 9000)
    FROM dual
    CONNECT BY LEVEL <= v_batch_size;
    
    v_start_id := v_start_id + v_batch_size;
    COMMIT;
  END LOOP;
END;
/
```

### 복합 쿼리 성능 분석
```sql
-- 복잡한 분석 쿼리
WITH sales_summary AS (
  SELECT 
    prod_id,
    TRUNC(sales_dt, 'MM') as sales_month,
    COUNT(*) as transaction_count,
    SUM(amount) as total_amount,
    AVG(amount) as average_amount
  FROM f_sales
  WHERE sales_dt >= DATE '2025-01-01'
    AND sales_dt < DATE '2026-01-01'
  GROUP BY prod_id, TRUNC(sales_dt, 'MM')
),
product_ranking AS (
  SELECT 
    prod_id,
    sales_month,
    total_amount,
    RANK() OVER (
      PARTITION BY sales_month 
      ORDER BY total_amount DESC
    ) as monthly_rank,
    SUM(total_amount) OVER (
      PARTITION BY prod_id 
      ORDER BY sales_month
    ) as cumulative_amount
  FROM sales_summary
)
SELECT 
  pr.*,
  p.category,
  p.brand
FROM product_ranking pr
JOIN d_product p ON p.prod_id = pr.prod_id
WHERE pr.monthly_rank <= 10
ORDER BY pr.sales_month, pr.monthly_rank;
```

## 성능 모니터링과 진단 체계

### 종합 모니터링 쿼리
```sql
-- 현재 세션의 소트 관련 통계
SELECT 
  sn.name as statistic_name,
  ms.value as current_value,
  CASE 
    WHEN sn.name LIKE 'sorts%' THEN '소트 관련'
    WHEN sn.name LIKE 'workarea%' THEN '워크에어리어 관련'
    WHEN sn.name LIKE 'session pga%' THEN 'PGA 메모리'
    ELSE '기타'
  END as category,
  sn.class
FROM v$mystat ms
JOIN v$statname sn ON sn.stat# = ms.stat#
WHERE sn.name IN (
  'sorts (memory)',
  'sorts (disk)',
  'workarea executions - optimal',
  'workarea executions - onepass',
  'workarea executions - multipass',
  'session pga memory',
  'session pga memory max',
  'physical writes direct temporary tablespace',
  'physical reads direct temporary tablespace'
)
ORDER BY category, sn.name;

-- 실행 중인 쿼리의 워크에어리어 정보
SELECT 
  sql_id,
  operation_type,
  policy,
  estimated_optimal_size,
  estimated_onepass_size,
  last_memory_used,
  last_execution,
  total_executions,
  optimal_executions,
  onepass_executions,
  multipasses_executions
FROM v$sql_workarea
WHERE last_execution > SYSDATE - 1/24  -- 지난 1시간 이내 실행
ORDER BY last_execution DESC;
```

### 실행 계획 심층 분석
```sql
-- 상세 실행 계획 분석
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, 
  NULL, 
  'ALLSTATS LAST +PREDICATE +NOTE +ALIAS +PROJECTION +COST +BYTES'
));

-- TEMP 사용량이 포함된 실행 계획
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, 
  NULL, 
  'ALLSTATS LAST +MEMSTATS'
));
```

## 수학적 모델을 통한 소트 비용 이해

### 소트 알고리즘의 이론적 배경

소트 작업의 비용은 다음과 같은 수학적 모델로 이해할 수 있습니다:

```
총 I/O 비용 ≈ 2N × (1 + ⌈log_k(N/M)⌉)

여기서:
N = 입력 행 수
M = 메모리에 저장 가능한 행 수 (워크에어리어 크기)
k = 병합 시 한 번에 처리 가능한 런(run) 수
```

### 실제 시스템에서의 적용
```sql
-- 시스템 파라미터 확인
SELECT 
  name,
  value,
  description
FROM v$parameter
WHERE name IN (
  'pga_aggregate_target',
  'workarea_size_policy',
  'sort_area_size',
  'hash_area_size'
);

-- 실제 성능 예측을 위한 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname => USER,
    tabname => 'F_SALES',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt => 'FOR ALL COLUMNS SIZE AUTO'
  );
END;
/

-- 예상 소트 비용 계산 쿼리
SELECT 
  num_rows,
  blocks,
  avg_row_len,
  -- 예상 메모리 소트 가능 행수 계산
  ROUND((100 * 1024 * 1024) / avg_row_len) as estimated_memory_rows,  -- 100MB 기준
  -- 디스크 소트 필요 여부 판단
  CASE 
    WHEN num_rows > ROUND((100 * 1024 * 1024) / avg_row_len) THEN '디스크 소트 필요'
    ELSE '메모리 소트 가능'
  END as sort_requirement
FROM user_tables
WHERE table_name = 'F_SALES';
```

## 실전 튜닝 시나리오: 문제 해결 과정

### 시나리오 1: 느린 리포트 쿼리
**문제**: 월별 판매 리포트 쿼리가 점점 느려짐
```sql
-- 원본 쿼리
SELECT 
  TRUNC(sales_dt, 'MM') as month,
  p.category,
  COUNT(*) as count,
  SUM(s.amount) as amount,
  AVG(s.amount) as avg_amount
FROM f_sales s
JOIN d_product p ON p.prod_id = s.prod_id
GROUP BY TRUNC(sales_dt, 'MM'), p.category
ORDER BY month DESC, amount DESC;
```

**진단**: 
1. 실행 계획에서 SORT GROUP BY와 SORT ORDER BY 확인
2. TEMP 테이블스페이스 사용량 증가 관찰
3. 데이터 양의 지속적 증가로 인한 성능 저하

**해결 방안**:
```sql
-- 1. 물리적 디자인 개선
CREATE INDEX ix_sales_dt_prod ON f_sales(sales_dt, prod_id);
CREATE INDEX ix_product_category ON d_product(category, prod_id);

-- 2. 파티셔닝 적용
ALTER TABLE f_sales MODIFY
PARTITION BY RANGE (sales_dt) (
  PARTITION p2024_q1 VALUES LESS THAN (DATE '2024-04-01'),
  PARTITION p2024_q2 VALUES LESS THAN (DATE '2024-07-01'),
  PARTITION p2024_q3 VALUES LESS THAN (DATE '2024-10-01'),
  PARTITION p2024_q4 VALUES LESS THAN (DATE '2025-01-01'),
  PARTITION p2025_q1 VALUES LESS THAN (DATE '2025-04-01'),
  PARTITION p_future VALUES LESS THAN (MAXVALUE)
);

-- 3. 쿼리 재작성
WITH monthly_sales AS (
  SELECT /*+ INDEX(s ix_sales_dt_prod) */
    TRUNC(sales_dt, 'MM') as month,
    prod_id,
    COUNT(*) as count,
    SUM(amount) as amount
  FROM f_sales s
  WHERE sales_dt >= ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -12)  -- 최근 12개월만
  GROUP BY TRUNC(sales_dt, 'MM'), prod_id
)
SELECT 
  ms.month,
  p.category,
  SUM(ms.count) as total_count,
  SUM(ms.amount) as total_amount,
  ROUND(AVG(ms.amount), 2) as avg_amount
FROM monthly_sales ms
JOIN d_product p ON p.prod_id = ms.prod_id
GROUP BY ms.month, p.category
ORDER BY ms.month DESC, total_amount DESC;
```

## 결론: 소트 최적화의 핵심 원칙

데이터베이스에서 소트 오퍼레이션을 효과적으로 관리하는 것은 시스템 성능을 결정하는 중요한 요소입니다. 모든 튜닝 활동은 다음과 같은 핵심 원칙을 기반으로 해야 합니다:

### 1. 예방이 최선의 치료
소트 작업을 발생시키기 전에 "정말 필요한가?"를 질문하세요. 많은 경우, 애플리케이션 레벨에서 처리하거나 다른 방식으로 해결할 수 있습니다. DISTINCT, ORDER BY, GROUP BY의 사용을 비즈니스 요구사항에 맞게 최소화하세요.

### 2. 물리적 디자인의 힘
적절한 인덱스는 소트 작업을 완전히 제거할 수 있습니다. 특히 ORDER BY와 GROUP BY에서 사용되는 컬럼에 대한 인덱스를 전략적으로 설계하세요. 복합 인덱스에서는 컬럼 순서와 정렬 방향을 쿼리 패턴에 맞게 구성하세요.

### 3. 데이터 볼륨 관리
소트 비용은 데이터 양에 비례합니다. 파티셔닝을 활용하여 필요한 데이터만 처리하고, 필터 조건을 조기에 적용하여 처리 범위를 축소하세요. 대량 데이터 처리는 배치로 분할하는 것을 고려하세요.

### 4. 실행 계획의 이해
실행 계획을 정확히 읽고 해석할 수 있는 능력은 튜닝의 기본입니다. SORT 관련 오퍼레이션이 어떻게 나타나는지, TEMP 사용량은 어떻게 추정되는지 이해하세요. DBMS_XPLAN의 다양한 옵션을 활용하여 심층 분석하세요.

### 5. 시스템 자원의 합리적 배분
PGA 메모리를 적절히 구성하여 Optimal 모드의 실행을 최대화하세요. TEMP 테이블스페이스의 I/O 성능을 모니터링하고 필요시 SSD나 고성능 스토리지로 전환하세요.

### 6. 지속적 모니터링과 개선
소트 성능은 데이터 성장과 함께 변화합니다. 정기적으로 성능 통계를 수집하고, 문제 패턴을 식별하며, 사전에 대응하는 체계를 구축하세요. v$ 뷰와 AWR 리포트를 활용한 프로액티브 모니터링이 중요합니다.

### 7. 적절한 기술 선택
모든 상황에 완벽한 단일 해결책은 없습니다. HASH GROUP BY와 SORT GROUP BY, Nested Loops와 Hash Join, Sort-Merge Join 사이에서 데이터 특성과 시스템 환경에 맞는 최적의 선택을 하세요.

소트 최적화는 단순한 기술적 활동을 넘어 데이터 흐름과 비즈니스 요구사항을 깊이 이해하는 과정입니다. 각 소트 작업이 왜 발생하는지, 어떤 비용을 수반하는지, 어떻게 개선할 수 있는지 체계적으로 접근할 때 진정한 성능 개선을 달성할 수 있습니다. 이 가이드가 제시한 원칙과 기법을 현실의 문제에 창의적으로 적용하며, 지속적인 학습과 실험을 통해 데이터베이스 성능 최적화의 전문가로 성장하시기 바랍니다.