---
layout: post
title: DB 심화 - 소트를 발생시키는 오퍼레이션
date: 2025-11-21 20:25:23 +0900
category: DB 심화
---
# 소트를 발생시키는 오퍼레이션 완전 정복

**대상 오퍼레이션**: `SORT AGGREGATE`, `SORT ORDER BY`, `SORT GROUP BY`, `SORT UNIQUE`, `SORT JOIN`, `WINDOW SORT`
**핵심 목표**:
- 각 오퍼레이션이 **언제** 발생하고 **왜** 필요한지
- **실행계획**에서 **어떻게 보이는지**(라인/옵션)
- **측정 방법**(V$ 통계, Workarea, TEMP I/O, XPLAN Note)
- **튜닝 포인트**(인덱스 대체, 해시 대체, 입력 축소, Top-N, 파티션 프루닝)

---

## 0) 실습 스키마 & 준비

```sql
-- 제품/매출 샘플
CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

CREATE TABLE f_sales (
  sales_id  NUMBER PRIMARY KEY,
  prod_id   NUMBER NOT NULL REFERENCES d_product(prod_id),
  sales_dt  DATE   NOT NULL,
  qty       NUMBER NOT NULL,
  amount    NUMBER(12,2) NOT NULL
);

-- 인덱스(예시)
CREATE INDEX ix_sales_prod_dt ON f_sales(prod_id, sales_dt);

-- 샘플 데이터
INSERT INTO d_product VALUES (10,'ELEC','B0');
INSERT INTO d_product VALUES (20,'HOME','B1');

INSERT INTO f_sales VALUES (1001,10,DATE '2025-02-03',1,10000);
INSERT INTO f_sales VALUES (1002,20,DATE '2025-02-05',2,15000);
INSERT INTO f_sales VALUES (1003,10,DATE '2025-02-10',1, 9000);
COMMIT;

-- 통계 보기 도우미(세션 통계 스냅샷)
CREATE GLOBAL TEMPORARY TABLE gtt_stat_snap (name VARCHAR2(64), val NUMBER) ON COMMIT PRESERVE ROWS;

-- 모니터링할 지표 선택
COLUMN name FORMAT A35
```

**소트/워크에어리어 관련 지표**(전/후 비교용):

```sql
-- 스냅샷 저장
INSERT INTO gtt_stat_snap
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat# = ms.stat#
WHERE  sn.name IN (
  'sorts (memory)','sorts (disk)',
  'workarea executions - optimal',
  'workarea executions - onepass',
  'workarea executions - multipass',
  'session pga memory','session pga memory max'
);

-- 대상 SQL 실행 후 델타 확인
SELECT a.name, (b.val - a.val) AS delta
FROM   gtt_stat_snap a
JOIN  (SELECT sn.name, ms.value val
       FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
       WHERE  sn.name IN (
         'sorts (memory)','sorts (disk)',
         'workarea executions - optimal',
         'workarea executions - onepass',
         'workarea executions - multipass',
         'session pga memory','session pga memory max'
       )) b
ON a.name = b.name
ORDER BY 1;
```

**PLAN 확인**:

```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +NOTE +ALIAS'));
```

---

## 1) SORT AGGREGATE — 스칼라 집계용 소트(또는 집계 단계)

### 언제 발생하나?

- `GROUP BY`가 **없는** 집계(= 스칼라): `SELECT COUNT(*), SUM(amount) FROM f_sales`
- 실행계획에서 `SORT AGGREGATE`로 보이며, 입력을 모두 처리한 후 **단일 로우**로 축약.

> 주의: `GROUP BY`가 있으면 보통 `SORT GROUP BY`나 `HASH GROUP BY`로 나타납니다.
> 스칼라 집계는 `HASH GROUP BY`가 아닌 `SORT AGGREGATE` 라인으로 나타나는 경우가 많습니다.

### 예제

```sql
-- 스칼라 집계: 전체 매출 합/건수
SELECT COUNT(*) cnt, SUM(amount) amt
FROM   f_sales;
```

**PLAN 예(전형)**
- `SORT AGGREGATE`
- 그 아래에 테이블 액세스(풀/인덱스) 라인이 옵니다.

**측정 포인트**
- 대개 입력량이 크지 않으면 PGA 내에서 끝나고 `sorts (memory)`가 증가.
- 대량이면 TEMP 스필 → `sorts (disk)`/`workarea executions - onepass/multipass` 확인.

### 튜닝 포인트

- **입력량 감소**: WHERE로 범위 축소/파티션 프루닝.
- **사전 집계**: 서브쿼리에서 먼저 필터 후 집계.
- **필요 없다면 집계 제거**: 애플리케이션에서 같은 결과를 이미 갖고 있다면 DB 집계 최소화.

---

## 2) SORT ORDER BY — 정렬

### 언제 발생하나?

- `ORDER BY`가 있고, 인덱스로 정렬을 **대체**하지 못할 때.
- Top-N(`FETCH FIRST N ROWS`)은 `SORT ORDER BY STOPKEY`로 표현될 수 있음.

### 예제 및 대체

```sql
-- Before: 정렬 필요(내림차순)
SELECT sales_id, prod_id, sales_dt, amount
FROM   f_sales
ORDER  BY amount DESC;

-- After: 정렬 대체(인덱스 생성 & 사용)
CREATE INDEX ix_sales_amount_desc ON f_sales(amount DESC);

SELECT /*+ INDEX_DESC(f_sales ix_sales_amount_desc) */
       sales_id, prod_id, sales_dt, amount
FROM   f_sales
ORDER  BY amount DESC;   -- PLAN: INDEX FULL SCAN DESC → SORT 제거
```

**Top-N 최적화**

```sql
SELECT sales_id, amount
FROM   f_sales
ORDER  BY amount DESC
FETCH FIRST 10 ROWS ONLY;   -- PLAN: SORT ORDER BY STOPKEY (부분 소트/힙 유지)
```

**측정 포인트**
- `DBMS_XPLAN` Note의 `TempSpc` 및 `direct path write/read temp` 대기.
- 세션 통계의 `sorts(disk)`와 workarea pass 수.

### 튜닝 포인트 요약

- **인덱스 방향/정렬키 일치**로 SORT 자체 제거.
- **Top-N**이면 STOPKEY 활용.
- **입력 컬럼 축소**(LOB 제외), **선제 필터링**으로 입력량 줄이기.
- 병렬 사용 시 TEMP/PGA 압박 고려.

---

## 3) SORT GROUP BY — 그룹 집계용 소트

### 언제 발생하나?

- `GROUP BY` 수행 시.
- 오라클은 상황에 따라 `HASH GROUP BY`(해시 집계)를 선택하기도 함.
  - 메모리가 넉넉한 대량 집계는 일반적으로 **해시 집계**가 유리.
  - 정렬이 이미 되어 있거나 그룹 수가 매우 많아 해시 overflow가 빈번하면 `SORT GROUP BY`가 나올 수 있음.

### 예제: 제품별 매출

```sql
-- 기본: GROUP BY (오라클이 HASH GROUP BY를 택할 수 있음)
SELECT prod_id, COUNT(*) cnt, SUM(amount) amt
FROM   f_sales
GROUP  BY prod_id;

-- 소트 집계를 강제(비권장 예제): 해시 대신 소트
SELECT /*+ NO_USE_HASH_AGGREGATION */ prod_id, COUNT(*), SUM(amount)
FROM   f_sales
GROUP  BY prod_id;
```

**PLAN 확인**: `SORT GROUP BY` vs `HASH GROUP BY`.

**측정 포인트**
- 소트 집계는 대량 입력 시 `sorts (disk)` 및 TEMP 사용 증가 소지.
- 해시 집계는 `HASH GROUP BY` + workarea 스필 여부(`v$sql_workarea`)로 판단.

### 튜닝 포인트

- **해시 집계 우선**: 일반적으로 해시 집계가 정렬 대비 I/O 발생이 적음.
- **인덱스 기반 소트 회피**: `GROUP BY` 키 순으로 미리 정렬되어 들어오면 소트 부담 감소.
- **사전 필터/사전 집계**로 입력량을 줄이기.
- 적절한 `pga_aggregate_target`으로 **Optimal**/One-Pass 유지.

---

## 4) SORT UNIQUE — 중복 제거

### 언제 발생하나?

- `SELECT DISTINCT ...`
- `UNION`(※ `UNION ALL`은 정렬/중복제거 없음)
- 내부적으로 **정렬 후 중복 제거** 또는 해시 기반 중복 제거가 사용될 수 있으나, PLAN에는 보통 `SORT UNIQUE`로 표기.

### 예제

```sql
-- DISTINCT
SELECT DISTINCT prod_id
FROM   f_sales;

-- UNION (중복제거)
SELECT prod_id FROM f_sales WHERE amount >= 10000
UNION
SELECT prod_id FROM f_sales WHERE sales_dt >= DATE '2025-02-01';
```

**대체/최적화**
- 가능한 경우 **`UNION ALL` + 상위 집계(DISTINCT 효과)** 또는 **중복이 거의 없으면 UNION ALL**이 더 빠를 수 있음(요건 허용 시).
- **사전 필터링/사전 집계**로 입력 축소.

**측정 포인트**
- `SORT UNIQUE` 라인 Temp 사용량, `sorts(disk)`/`workarea executions` 상태, TEMP 대기.

### 주의

- DISTINCT/UNION은 **정렬/해시 부하**가 필연적 → **업무적 꼭 필요**한지 재검토.
- 넓은 로우(불필요 컬럼 포함)면 소트 폭 증가 → **프로젝션 축소**.

---

## 5) SORT JOIN — Sort-Merge Join(SMJ) 준비 정렬

### 언제 발생하나?

- 옵티마이저가 **Sort-Merge Join**을 선택했을 때 **각 입력**(혹은 하나)을 **조인 키로 정렬**해야 함.
- PLAN에 `SORT JOIN`(그리고 `MERGE JOIN`) 라인이 등장.

### 예제

```sql
-- SMJ 유도 (실습/비교용)
SELECT /*+ USE_MERGE(s p) */ COUNT(*)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id;
```

**대체**: **Nested Loops + 인덱스** 또는 **Hash Join**(대량/충분한 PGA)로 변경 가능.

```sql
-- NL 유도: 인덱스 범위스캔으로 JOIN 정렬 회피
SELECT /*+ ORDERED USE_NL(s p) INDEX(s ix_sales_prod_dt) */ COUNT(*)
FROM   d_product p
JOIN   f_sales s ON s.prod_id = p.prod_id;
```

**측정 포인트**
- 두 입력에 대한 `SORT JOIN`이 잡히면 TEMP I/O 위험.
- `DBMS_XPLAN`에서 `TempSpc`/A-Rows 확인, 세션 이벤트 `direct path write/read temp`.

### 튜닝 포인트

- **조인 방식 재선택**: Hash/NL로 전환.
- **인덱스로 대체**: 조인 키로 이미 정렬되어 있으면 SORT JOIN 생략 가능.
- **입력 축소**: 선제 필터/파티션 프루닝으로 소트 입력 줄이기.

---

## 6) WINDOW SORT — 윈도우 함수용 정렬

### 언제 발생하나?

- `… OVER (PARTITION BY … ORDER BY …)`
- 각 **PARTITION 단위로 정렬**해야 하므로, 큰 파티션은 TEMP 스필 위험.

### 예제

```sql
-- 제품별 일자 순 누적 매출
SELECT prod_id, sales_dt,
       SUM(amount) OVER (PARTITION BY prod_id ORDER BY sales_dt
                         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS run_sum
FROM   f_sales;
```

**PLAN**: `WINDOW SORT` 라인(혹은 `SORT ORDER BY` + Windowing 단계로 나타나는 버전도 있음).

**측정 포인트**
- 파티션 수/파티션 크기 분포에 따라 TEMP 사용량이 달라짐.
- `v$sql_workarea`에서 `operation_type`이 `WINDOW` 관련인지 확인(버전별 표기가 조금 다름) + TEMP 대기.

### 튜닝 포인트

- **PARTITION 키 재설계/재정의**: 파티션(윈도우의 PARTITION은 논리 파티션)당 규모를 줄여 정렬 부담 분산.
- **사전 정렬 데이터 공급**: 조인 순서/인덱스 사용으로 `ORDER BY` 키 순으로 읽히게.
- **필터링**: 불필요 로우를 윈도우 계산 전에 제거.
- **프레임 최적화**: 필요 이상 넓은 프레임(`RANGE BETWEEN UNBOUNDED PRECEDING …`)을 좁히면 메모리 사용 감소.

---

## 7) 오퍼레이션별 “전형적 튜닝 전략” 요약표

| 오퍼레이션 | 목적/상황 | 대표 비용 | 측정 포인트 | 대표 튜닝 |
|---|---|---|---|---|
| `SORT AGGREGATE` | 스칼라 집계 | 입력량×폭 | sorts(*), workarea passes | 입력 축소, 사전 필터 |
| `SORT ORDER BY` | 정렬 | 입력량×폭, TEMP I/O | TempSpc, direct path temp | 인덱스 대체, Top-N STOPKEY, 프로젝션 축소 |
| `SORT GROUP BY` | 그룹 집계 | 정렬/중복제거 I/O | sorts(disk), plan line | 해시 집계 선호, 입력 축소 |
| `SORT UNIQUE` | DISTINCT/UNION | 정렬+중복 제거 | sorts(disk), TempSpc | UNION ALL(+집계), 프로젝션 축소 |
| `SORT JOIN` | SMJ 준비 | 양쪽 정렬 I/O | 두 입력 Temp 사용 | 조인 방식 전환(NL/Hash), 인덱스 |
| `WINDOW SORT` | 윈도우 정렬 | 파티션별 정렬 | TEMP per partition | PARTITION 크기 제어, 사전 정렬 |

---

## 8) 대량 데이터 시나리오(통합 실습)

### 데이터 벌크업

```sql
-- 50만 행 정도 가정(환경에 맞게 조절)
WITH gen AS (SELECT LEVEL n FROM dual CONNECT BY LEVEL <= 500000)
INSERT /*+ APPEND */ INTO f_sales(sales_id, prod_id, sales_dt, qty, amount)
SELECT 300000 + n,
       CASE WHEN MOD(n,2)=0 THEN 10 ELSE 20 END,
       DATE '2025-02-01' + MOD(n, 20),
       1 + MOD(n, 3),
       10000 + MOD(n, 5000)
FROM gen;
COMMIT;
```

### 케이스 A — 대량 정렬(ORDER BY)

```sql
-- 스냅샷
INSERT INTO gtt_stat_snap
SELECT sn.name, ms.value
FROM v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE sn.name IN ('sorts (memory)','sorts (disk)','workarea executions - onepass','workarea executions - multipass');

-- 실행
SELECT /* big order */ sales_id, amount
FROM   f_sales
ORDER  BY amount DESC;

-- PLAN/TEMP 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +NOTE'));

-- 델타
SELECT a.name, (b.val - a.val) delta
FROM gtt_stat_snap a JOIN (SELECT sn.name, ms.value val
  FROM v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
  WHERE sn.name IN ('sorts (memory)','sorts (disk)','workarea executions - onepass','workarea executions - multipass')) b
ON a.name=b.name;
```

**개선**

```sql
CREATE INDEX ix_sales_amount_desc ON f_sales(amount DESC);

SELECT /*+ INDEX_DESC(f_sales ix_sales_amount_desc) */
       sales_id, amount
FROM   f_sales
ORDER  BY amount DESC;   -- SORT 제거
```

### 케이스 B — GROUP BY (소트 vs 해시)

```sql
-- 기본 GROUP BY (오라클이 해시 선택 가능)
SELECT prod_id, COUNT(*), SUM(amount)
FROM   f_sales
GROUP  BY prod_id;

-- 소트 집계 강제(비교용)
SELECT /*+ NO_USE_HASH_AGGREGATION */
       prod_id, COUNT(*), SUM(amount)
FROM   f_sales
GROUP  BY prod_id;

-- XPLAN에서 SORT GROUP BY vs HASH GROUP BY 비교
```

### 케이스 C — DISTINCT/UNION

```sql
-- DISTINCT (SORT UNIQUE)
SELECT DISTINCT prod_id FROM f_sales;

-- UNION vs UNION ALL 비교
SELECT prod_id FROM f_sales WHERE amount >= 12000
UNION
SELECT prod_id FROM f_sales WHERE sales_dt >= DATE '2025-02-10';

SELECT prod_id FROM f_sales WHERE amount >= 12000
UNION ALL
SELECT prod_id FROM f_sales WHERE sales_dt >= DATE '2025-02-10';
-- Note: 업무 요건상 중복 허용 시 UNION ALL이 보통 더 빠름
```

### 케이스 D — Sort-Merge Join

```sql
-- SMJ 유도
SELECT /*+ USE_MERGE(s p) */
       COUNT(*)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id;

-- NL 대체
SELECT /*+ ORDERED USE_NL(s p) INDEX(s ix_sales_prod_dt) */
       COUNT(*)
FROM   d_product p
JOIN   f_sales s ON s.prod_id = p.prod_id;
```

### 케이스 E — WINDOW SORT

```sql
SELECT prod_id, sales_dt,
       SUM(amount) OVER (PARTITION BY prod_id ORDER BY sales_dt) AS run_sum
FROM   f_sales;
-- 큰 파티션이면 TEMP 스필 → PARTITION 분산/필터 고려
```

---

## 9) 수학적 직관 — 외부소트 비용(근사)

입력 로우 수를 \(N\), 메모리로 만들 수 있는 run 크기를 \(M\), 한 번에 병합 가능한 run 수를 \(k\)라고 하면:

- 초기 run 개수: \(\left\lceil \frac{N}{M} \right\rceil\)
- 병합 패스 수: \(\left\lceil \log_{k} \left( \frac{N}{M} \right) \right\rceil\)

총 I/O(근사):
$$
\text{IO} \approx 2N \cdot \left(1 + \left\lceil \log_{k} \left( \frac{N}{M} \right) \right\rceil\right)
$$
**핵심**: \(M\)↑(워크에어리어↑), \(k\)↑(병합 버퍼↑) → **패스 수↓ → TEMP I/O↓**.

---

## 10) 운영 체크리스트(오퍼레이션 공통)

- [ ] **정렬을 반드시 해야 하나** 재검토(DISTINCT/UNION, ORDER BY)
- [ ] **인덱스 설계**로 정렬 제거(키/방향 일치, 커버링)
- [ ] **Top-N**이면 STOPKEY 활용
- [ ] **해시 집계** 우선 고려(`GROUP BY`)
- [ ] **조인 방식 전환**으로 `SORT JOIN` 회피(NL/Hash)
- [ ] **입력 로우/폭 축소**: 선제 필터, 프로젝션 축소(LOB 제외), 사전 집계
- [ ] **파티션 프루닝** & 파티션 친화적 조건 재작성
- [ ] **PGA 예산**: `workarea_size_policy=AUTO`, `pga_aggregate_target` 적정화
- [ ] **TEMP 인프라**: 용량/IOPS/그룹/모니터링(TempSpc, direct path temp)
- [ ] **검증**: `DBMS_XPLAN`, V$ 통계, SQL Monitor로 **정량 비교**

---

## 11) 마무리 — 한 문장 요약

- `SORT AGGREGATE/ORDER BY/GROUP BY/UNIQUE/JOIN/WINDOW`는 **필요한 때에만** 수행되도록 만들고,
- 가능하면 **인덱스/해시/Top-N/조인 방식 전환**으로 **정렬 자체**를 **없애거나 최소화**하라.
- 모든 변화는 **PLAN(TEMP 사용)** 과 **V$ 통계(Optimal/One-Pass/Multi-Pass, sorts(disk))** 로 **확인**하는 것이 정석이다.
