---
layout: post
title: 형식언어와 오토마타 - 정규 문법과 정규 언어
date: 2025-07-04 21:20:23 +0900
category: 형식언어와 오토마타
---
# 정규 문법과 정규 언어: 우선형 문법, 좌선형 문법, 그리고 동치성

> 목표
> - **정의**: 정규(=3형식) 문법, 우선형/좌선형 문법을 엄밀히 정리
> - **동치성**: 정규문법 ↔ (ε-)NFA/DFA ↔ 정규표현식(Regex) 동치성의 직관과 증명 스케치
> - **변환 알고리즘**: 우선형/좌선형 문법 ↔ NFA/DFA 상호 변환 절차
> - **예제·코드**: 실제 동작하는 **Python 레퍼런스 코드**로 변환/검증(유한 길이 테스트)
> - **실무 힌트**: 문법 정제(무용기호 제거), ε/단축 규칙 처리, 상태 폭증·최소화 등

---

## 표기(Notation)

- 알파벳(터미널 집합): $$\Sigma$$, 문자열 집합: $$\Sigma^\*$$, 공백문자열: $$\varepsilon$$
- 비터미널(Nonterminals) 집합: $$V$$, 시작기호: $$S\in V$$
- 문법: $$G=(V,\Sigma,R,S)$$, 규칙 집합 $$R$$
- 유한오토마타: $$M=(Q,\Sigma,\delta,q_0,F)$$ (필요 시 ε-전이 허용)

---

## 정규 문법(Regular Grammar)란?

> **정의**
> **정규 문법**은 촘스키 위계 Type-3 문법으로서, 모든 규칙이 **우선형 또는 좌선형**의 선형 형태만 허용되는 문법이다.
> 이 문법이 생성하는 언어의 족은 **정규 언어(regular languages)**이며, 정규표현식·DFA/NFA와 **표현력이 동치**다.

정규 문법은 두 가지 전형으로 나타난다.

---

## 우선형 문법(Right-linear Grammar, RLG)

### 정의

모든 규칙이 아래 중 하나:
1) $$A \to aB$$
2) $$A \to a$$
3) $$A \to \varepsilon$$
여기서 $$A,B\in V,\ a\in\Sigma$$.

### 예시(반복되는 `ab`)

문법 $$G=(\{S,A\},\{a,b\},R,S)$$
- $$S\to aA$$
- $$A\to bS$$
- $$S\to \varepsilon$$

유도 예:
- \(S \Rightarrow \varepsilon\) → “”
- \(S \Rightarrow aA \Rightarrow abS \Rightarrow \varepsilon\) → “ab”
- \(S \Rightarrow aA \Rightarrow abS \Rightarrow ab aA \Rightarrow ab ab S \Rightarrow \varepsilon\) → “abab”
⇒ $$L(G)=\{(ab)^n\mid n\ge 0\}$$.

---

## 좌선형 문법(Left-linear Grammar, LLG)

### 정의

모든 규칙이 아래 중 하나:
1) $$A \to Ba$$
2) $$A \to a$$
3) $$A \to \varepsilon$$

### 예시(짝수 개의 \(a\))

문법 $$G=(\{S,A\},\{a\},R,S)$$
- $$S\to Aa,\ A\to Sa,\ A\to \varepsilon$$

유도 예:
- \(S\Rightarrow Aa \Rightarrow \varepsilon a = a\) (홀수처럼 보이지만 \(S\)에서 한 번 더: \(S\Rightarrow Aa\Rightarrow Sa a\Rightarrow Aa a a\Rightarrow \cdots\); 실제 언어 확인은 아래 NFA 변환으로 검증)
이 문법이 생성하는 언어는 $$\{a^{2n}\mid n\ge 0\}$$ (예: \(\varepsilon, aa, aaaa,\dots\)).

> 좌선형은 우선형과 “읽기 방향”이 반대여서, **규칙→전이 매핑만 다르게** 하면 NFA로 쉽게 변환된다.

---

## RLG가 생성하는 언어는 정규 언어 — RLG → ε-NFA 변환

> **정리** 모든 우선형 문법 \(G\)에 대해 **ε-NFA** \(M\)이 존재하여 \(L(G)=L(M)\).

### 변환 규칙(구성)

- 상태: **비터미널을 상태로** 사용(필요 시 단일 수용상태 \(f\) 추가)
- 시작상태: \(q_0=S\)
- 전이:
  - 규칙 \(A\to aB\): \(\delta(A,a)\ni B\)
  - 규칙 \(A\to a\): \(\delta(A,a)\ni f\) (또는 \(A\)를 수용으로 두고 ε-전이 사용)
  - 규칙 \(A\to \varepsilon\): \(A\)를 **수용 상태**로 지정
- 수용상태: 규칙에 \(\varepsilon\)이 있는 비터미널들, 그리고 필요하면 \(f\)

> 직관: **비터미널=상태**, “터미널을 읽으며 다음 비터미널로 이동”.

---

## 모든 정규 언어는 우선형 문법으로 — DFA → RLG 변환

> **정리** 모든 DFA \(D\)에 대해, 이를 **동치 RLG** \(G\)로 변환 가능.

### 변환 규칙(구성)

- 비터미널: 상태 \(Q\)를 그대로 사용
- 시작기호: \(S:=q_0\)
- 규칙:
  - 전이 \(\delta(q_i,a)=q_j\)는 **\(q_i \to a q_j\)**
  - 수용상태 \(q_f\in F\)는 **\(q_f\to \varepsilon\)** 추가

> 직관: DFA가 읽는 과정을 **문자→비터미널** 꼬리로 옮겨 적는다.

---

## 좌선형 문법도 정규 언어를 생성 — LLG → ε-NFA (직접 변환)

LLG 규칙
- \(A\to Ba\) → **\(\delta(B,a)\ni A\)** (방향 반전!)
- \(A\to a\) → \(\delta(A,a)\ni f\) (혹은 \(A\)를 수용으로 만들고 ε)
- \(A\to \varepsilon\) → \(A\)를 수용 상태

시작상태 \(S\), 수용상태는 위에 따라 결정.
직관: 좌선형은 **앞쪽(왼편)에 비터미널**이 붙으므로, 전이를 “역참조”하면 오토마타가 **입력을 정방향으로 읽으면서** 좌선형 규칙을 시뮬레이션 가능.

> 다른 증명 경로: LLG가 만드는 언어 \(L\)에 대해 **역언어 \(L^R\)**는 RLG로 생성 가능(아래 7장). 정규어는 역연산에 닫혀 있으므로 \(L\)도 정규.

---

## RLG ↔ LLG의 관계(역언어)

- 우선형 RLG는 **오른쪽에 비터미널**이 붙는다 → **왼쪽에서 오른쪽**으로 확장
- 좌선형 LLG는 **왼쪽에 비터미널**이 붙는다 → **오른쪽에서 왼쪽**으로 읽는 셈

> **사실**: 좌선형 문법이 만드는 언어의 **역언어**는 우선형 문법으로 생성 가능.
> 정규어는 역연산에 대해 **닫힘** ⇒ 좌선형도 정규어만 생성.

---

## 정규 언어 동치성(확장된 Kleene 정리)

> **동치성**
> 다음 네 표현은 **동등**한 언어족(정규어)을 정의한다.
> 1) 정규표현식(Regex)
> 2) DFA / NFA / ε-NFA
> 3) 우선형 정규 문법(RLG)
> 4) 좌선형 정규 문법(LLG)

**증명 스케치**
- Regex ↔ ε-NFA: Thompson 구성 / 표준
- ε-NFA ↔ DFA: 부분집합 구성
- DFA ↔ RLG: §5의 구성
- RLG ↔ LLG: §6 또는 역언어 논증
연쇄하면 상호 변환이 가능해진다.

---

## 변환 알고리즘 — Python 레퍼런스(실행 가능)

> 교육용 간결 구현. 실서비스는 입력검증/최소화(Hopcroft)/비트셋 최적화 추가 권장.

### 자료구조

```python
from collections import defaultdict, deque
from typing import Dict, Set, Tuple, Iterable, Optional

Sym = str
NonTerm = str
State = str

class RightLinearGrammar:
    """우선형 정규 문법: A->aB | a | ε 만 허용(간단 표준형)"""
    def __init__(self,
                 V: Iterable[NonTerm],
                 Sigma: Iterable[Sym],
                 rules: Dict[NonTerm, Set[Tuple[Optional[Sym], Optional[NonTerm]]]],
                 S: NonTerm):
        """
        rules[A] contains pairs (a, B):
          - (a, B) with a in Sigma, B in V   for A -> aB
          - (a, None) with a in Sigma        for A -> a
          - (None, None)                     for A -> ε
        """
        self.V: Set[NonTerm] = set(V)
        self.Sigma: Set[Sym] = set(Sigma)
        self.R: Dict[NonTerm, Set[Tuple[Optional[Sym], Optional[NonTerm]]]] = defaultdict(set)
        for A, rhs in rules.items():
            self.R[A] |= rhs
        self.S: NonTerm = S

class LeftLinearGrammar:
    """좌선형 정규 문법: A->Ba | a | ε 만 허용"""
    def __init__(self,
                 V: Iterable[NonTerm],
                 Sigma: Iterable[Sym],
                 rules: Dict[NonTerm, Set[Tuple[Optional[NonTerm], Optional[Sym]]]],
                 S: NonTerm):
        """
        rules[A] contains pairs (B, a):
          - (B, a) with B in V, a in Sigma   for A -> Ba
          - (None, a) with a in Sigma        for A -> a
          - (None, None)                     for A -> ε
        """
        self.V: Set[NonTerm] = set(V)
        self.Sigma: Set[Sym] = set(Sigma)
        self.R: Dict[NonTerm, Set[Tuple[Optional[NonTerm], Optional[Sym]]]] = defaultdict(set)
        for A, rhs in rules.items():
            self.R[A] |= rhs
        self.S: NonTerm = S

class ENFA:
    """ε-NFA: delta[(q, a)] = {p,...}, a ∈ Σ ∪ {'ε'}"""
    def __init__(self,
                 Q: Iterable[State],
                 Sigma: Iterable[Sym],
                 delta: Dict[Tuple[State, Sym], Set[State]],
                 q0: State,
                 F: Iterable[State],
                 eps: Sym = 'ε'):
        self.Q: Set[State] = set(Q)
        self.Sigma: Set[Sym] = set(Sigma)
        self.delta: Dict[Tuple[State, Sym], Set[State]] = defaultdict(set)
        for (q, a), dests in delta.items():
            self.delta[(q, a)] |= set(dests)
        self.q0: State = q0
        self.F: Set[State] = set(F)
        self.eps: Sym = eps

    def eclosure(self, S: Iterable[State]) -> Set[State]:
        stack = list(S)
        seen = set(S)
        while stack:
            q = stack.pop()
            for r in self.delta.get((q, self.eps), set()):
                if r not in seen:
                    seen.add(r); stack.append(r)
        return seen

    def accepts(self, s: str) -> bool:
        curr = self.eclosure({self.q0})
        for ch in s:
            if ch not in self.Sigma: return False
            nxt = set()
            for q in curr:
                nxt |= self.delta.get((q, ch), set())
            curr = self.eclosure(nxt)
            if not curr: return False
        return len(curr & self.F) > 0

class DFA:
    """완전/불완전 DFA 모두 표현 가능(불완전은 run 중 None 발생)"""
    def __init__(self,
                 Q: Iterable[State],
                 Sigma: Iterable[Sym],
                 delta: Dict[Tuple[State, Sym], State],
                 q0: State,
                 F: Iterable[State]):
        self.Q = set(Q); self.Sigma = set(Sigma)
        self.delta = dict(delta); self.q0 = q0; self.F = set(F)

    def run(self, s: str) -> bool:
        q = self.q0
        for ch in s:
            q = self.delta.get((q, ch))
            if q is None: return False
        return q in self.F
```

### **RLG → ε-NFA** (우선형 문법을 오토마타로)

```python
def rlg_to_enfa(G: RightLinearGrammar, use_single_final=True) -> ENFA:
    Q = set(G.V)
    Sigma = set(G.Sigma)
    delta: Dict[Tuple[State, Sym], Set[State]] = defaultdict(set)
    F: Set[State] = set()
    q0 = G.S

    final = None
    if use_single_final:
        final = "__FINAL__"
        Q.add(final)

    for A, rhs_set in G.R.items():
        for (a, B) in rhs_set:
            if a is None and B is None:
                # A -> ε
                F.add(A)
            elif a is not None and B is None:
                # A -> a
                if use_single_final:
                    delta[(A, a)].add(final)
                else:
                    # 대안: A를 수용으로 지정 + ε전이로 구현 가능
                    F.add(A)  # 간단 처리
            elif a is not None and B is not None:
                # A -> aB
                delta[(A, a)].add(B)
            else:
                raise ValueError("Invalid RHS in RLG")

    if use_single_final:
        F.add(final)

    return ENFA(Q, Sigma, delta, q0, F)
```

### **DFA → RLG** (오토마타를 우선형 문법으로)

```python
def dfa_to_rlg(D: DFA) -> RightLinearGrammar:
    V = set(D.Q); Sigma = set(D.Sigma); S = D.q0
    rules: Dict[NonTerm, Set[Tuple[Optional[Sym], Optional[NonTerm]]]] = defaultdict(set)

    for (q, a), q2 in D.delta.items():
        rules[q].add((a, q2))  # q -> a q2

    for qf in D.F:
        rules[qf].add((None, None))  # qf -> ε

    return RightLinearGrammar(V, Sigma, rules, S)
```

### **LLG → ε-NFA** (좌선형 문법을 오토마타로)

```python
def llg_to_enfa(G: LeftLinearGrammar, use_single_final=True) -> ENFA:
    Q = set(G.V)
    Sigma = set(G.Sigma)
    delta: Dict[Tuple[State, Sym], Set[State]] = defaultdict(set)
    F: Set[State] = set()
    q0 = G.S

    final = None
    if use_single_final:
        final = "__FINAL__"
        Q.add(final)

    for A, rhs_set in G.R.items():
        for (B, a) in rhs_set:
            if B is None and a is None:
                # A -> ε
                F.add(A)
            elif B is None and a is not None:
                # A -> a
                if use_single_final:
                    delta[(A, a)].add(final)
                else:
                    F.add(A)  # 단순 처리
            elif B is not None and a is not None:
                # A -> B a   (좌선형)  ==> δ(B, a) ⊇ {A}
                delta[(B, a)].add(A)
            else:
                raise ValueError("Invalid RHS in LLG")

    if use_single_final:
        F.add(final)

    return ENFA(Q, Sigma, delta, q0, F)
```

---

## 예제 실습(문제→구성→검증)

### 예제 A — (ab)\* (우선형 문법)

**문법** (2장 예시):
\(S\to aA,\ A\to bS,\ S\to \varepsilon\)

```python
RLG_ab = RightLinearGrammar(
    V={'S','A'},
    Sigma={'a','b'},
    rules={
        'S': {('a','A'), (None,None)},  # S->aA | ε
        'A': {('b','S')},               # A->bS
    },
    S='S'
)

M_ab = rlg_to_enfa(RLG_ab)
tests = ["", "ab", "abab", "aba", "b", "aabb", "ababab"]
print({t: M_ab.accepts(t) for t in tests})
# 기대: "" True, "ab" True, "abab" True, "aba" False, "b" False, "aabb" False, "ababab" True

```

### 예제 B — 짝수 개의 a (좌선형 문법)

가능한 LLG 설계 1안(간단 루프):
- \(S\to \varepsilon\) (짝수 0)
- \(S\to Sa a\)를 좌선형으로 표현하려면 \(S\to S a\)만으로는 ‘한 번에 a 두 개’가 되지 않음.
  대안: **상태 2개**로 패리티 관리
  - \(S\) = 짝수, \(T\) = 홀수
  - **좌선형**으로 쓰려면 `A -> Ba` 형태가 필요. 아래처럼 구성:
    - \(S\to Ta\)   (짝수에서 a 하나 읽으면 홀수)
    - \(T\to Sa\)   (홀수에서 a 하나 읽으면 짝수)
    - \(S\to \varepsilon\)

```python
LLG_even_a = LeftLinearGrammar(
    V={'S','T'},
    Sigma={'a'},
    rules={
        'S': {('T','a'), (None,None)},  # S->Ta | ε
        'T': {('S','a')},               # T->Sa
    },
    S='S'
)

M_even = llg_to_enfa(LLG_even_a)
tests = ["", "a", "aa", "aaa", "aaaa"]
print({t: M_even.accepts(t) for t in tests})
# 기대: "" True, "a" False, "aa" True, "aaa" False, "aaaa" True

```

### 예제 C — DFA → RLG

짝수 a DFA (표준):

- 상태 \(Q=\{q_0,q_1\}\), 시작 \(q_0\), 수용 \(F=\{q_0\}\)
- \(\delta(q_0,a)=q_1,\ \delta(q_1,a)=q_0\)

```python
D_even = DFA(
    Q={'q0','q1'},
    Sigma={'a'},
    delta={('q0','a'):'q1', ('q1','a'):'q0'},
    q0='q0',
    F={'q0'}
)

G_from_D = dfa_to_rlg(D_even)
# 간단 점검: q0->a q1, q1->a q0, q0->ε

M_from_G = rlg_to_enfa(G_from_D)
print({t: (D_even.run(t), M_from_G.accepts(t)) for t in ["","a","aa","aaa","aaaa"]})
# 기대: 두 값이 모두 동일(True/False)하게 나옴

```

---

## 실무 팁: 문법 정제 & 오토마타 품질

1) **무용 기호 제거**
   - **생산 불가능**(터미널 문자열을 못 만드는 비터미널) & **도달 불가능**(S에서 도달 안 되는 비터미널) 제거
   - RLG/LLG→NFA 전에 정제하면 상태 수 감소

2) **ε/단축 규칙**
   - RLG/LLG에선 ε가 허용되지만, 변환 후 **ε-closure** 비용을 줄이기 위해 ε를 **최소화**하는 게 유리할 때가 많음

3) **완전화/최소화**
   - DFA가 필요하면 ε-NFA → DFA(부분집합 구성) 후 **Hopcroft 최소화** 적용
   - 정규 문법 → NFA → DFA → 최소 DFA → 다시 RLG 로 “간결한 문법”을 역추출하는 흐름도 가능

4) **상태 폭증 제어**
   - 부분집합 구성은 최악 \(2^{|Q|}\). **도달 가능한 부분집합만** 생성, 비트셋 구현, dead-state 조기 합치기

---

## 빈번한 함정(Pitfalls)

- **LLG 전이 방향**: \(A\to Ba\)를 \(\delta(A,a)=B\)로 쓰면 틀림. **\(\delta(B,a)\ni A\)** 가 맞다.
- **수용 처리**: \(A\to \varepsilon\)는 \(A\)를 **수용**으로(또는 최종상태로 ε), \(A\to a\)는 **읽고 곧바로 최종**으로.
- **문자열 방향/역언어**: 좌선형↔우선형 논증에서 **역언어** 개념을 빼먹지 말 것.
- **불완전 DFA로 집합연산**: 여집합/차집합 전엔 **완전 DFA**(sink 추가)로 만들기.

---

## 학습 과제(힌트 포함)

1) **LLG → RLG로 직접 변환**
   LLG \(G\)가 있을 때, \(L(G)^R\)을 RLG로 만드는 절차를 서술하고, 예제(짝수 a)로 검증하라.
   *힌트*: 규칙의 RHS를 **역순**으로 보고 비터미널 위치를 바꿔 적는다.

2) **Regex → RLG**
   정규식 \((a|bb)^\*ab\)를 Thompson으로 ε-NFA를 만든 뒤, DFA 최소화 → RLG 추출.
   *힌트*: §9의 흐름을 체인으로 연결.

3) **문법 정제**
   \(V=\{S,A,B\}\)에서 \(B\)가 생산·도달 모두 불가능한 예를 만들어 제거 전/후의 NFA 상태 수를 비교하라.

4) **두 RLG의 합집합**
   두 RLG \(G_1,G_2\)의 언어 합 \(L(G_1)\cup L(G_2)\)를 만드는 방법(오토마타 곱/직합)을 설계하고, 코드로 검증하라.
   *힌트*: NFA에선 시작에서 ε-분기로 두 기계를 병렬 연결하면 끝.

---

## 요약

- **정규 문법**(Type-3)은 **우선형/좌선형** 두 전형으로 기술되며, **정규 언어**만 생성한다.
- **동치성**: 정규표현식 ↔ ε-NFA/NFA/DFA ↔ RLG/LLG (모두 서로 변환 가능).
- **변환 핵심**:
  - RLG→NFA: \(A\to aB/ a/ \varepsilon\)를 전이/수용으로
  - DFA→RLG: \(\delta(q,a)=p \Rightarrow q\to ap,\ q_f\to \varepsilon\)
  - LLG→NFA: \(A\to Ba \Rightarrow \delta(B,a)\ni A\) (방향 주의)
- **실무**: 변환 전 **정제**, 변환 후 **최소화**로 상태/규칙을 깔끔히.

---

## 부록 A. 간단한 RLG/LLG 생성기(샘플)

> 연습용: 최대 길이 \(L\)까지의 도출을 나열(중복·순환 방지용 제한)

```python
def enumerate_rlg(G: RightLinearGrammar, max_len=4) -> Set[str]:
    results = set()
    from collections import deque
    # 형태: (비터미널 A, 현재 문자열 prefix)
    dq = deque([(G.S, "")])
    for _ in range(10000):
        if not dq: break
        A, pref = dq.popleft()
        for (a, B) in G.R[A]:
            if a is None and B is None:
                results.add(pref)  # ε
            elif a is not None and B is None:
                s = pref + a
                if len(s) <= max_len: results.add(s)
            elif a is not None and B is not None:
                s = pref + a
                if len(s) <= max_len: dq.append((B, s))
    return results

def enumerate_llg(G: LeftLinearGrammar, max_len=4) -> Set[str]:
    results = set()
    from collections import deque
    # 좌선형: A -> Ba / a / ε
    # 현재 문자열을 suffix로 쌓는 느낌(오른쪽에 a가 붙음)
    dq = deque([(G.S, "")])
    for _ in range(10000):
        if not dq: break
        A, suf = dq.popleft()
        for (B, a) in G.R[A]:
            if B is None and a is None:
                results.add(suf)
            elif B is None and a is not None:
                s = suf + a
                if len(s) <= max_len: results.add(s)
            elif B is not None and a is not None:
                s = suf + a
                if len(s) <= max_len: dq.append((B, s))
    return results

# 작은 확인

print("RLG (ab)* up to 4:", enumerate_rlg(RLG_ab, 4))
print("LLG even-a up to 4:", enumerate_llg(LLG_even_a, 4))
```

---

## 부록 B. 좌/우선형 변환 표(요약)

| 규칙 유형 | RLG → ε-NFA | LLG → ε-NFA |
|---|---|---|
| 비터미널 이동 | \(A\to aB \Rightarrow \delta(A,a)\ni B\) | \(A\to Ba \Rightarrow \delta(B,a)\ni A\) |
| 단말로 종료 | \(A\to a \Rightarrow \delta(A,a)\ni f\) | \(A\to a \Rightarrow \delta(A,a)\ni f\) |
| ε 종료 | \(A\to \varepsilon \Rightarrow A\in F\) | \(A\to \varepsilon \Rightarrow A\in F\) |
| 시작/수용 | \(q_0=S\), \(F=\{f\}\cup \{A:\ A\to\varepsilon\}\) | 동일 |
| 주의 | 방향 그대로(정방향) | **방향 반전**(좌선형은 역참조 전이) |

> 이 표만 기억해도, 대부분의 정규 문법 ↔ 오토마타 설계를 바로 할 수 있다.
