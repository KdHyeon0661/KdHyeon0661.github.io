---
layout: post
title: 파이썬 심화 - 네트워크와 웹 프로그래밍 (3)
date: 2025-12-03 23:30:23 +0900
category: 파이썬 심화
---
# 네트워크와 웹 프로그래밍 (3)

파이썬을 활용한 네트워크 프로그래밍은 단순한 통신을 넘어 보안, 인증, 효율적인 데이터 교환까지 포괄하는 종합적인 기술입니다. 현대적인 분산 시스템을 구축하기 위한 핵심 기술들을 심층적으로 살펴보겠습니다.

## 인터프리터 간 통신과 프로세스 간 통신(IPC)

### 다양한 IPC 메커니즘 비교
프로세스 간 데이터 교환을 위한 여러 방법과 각각의 적절한 사용 사례:

```python
import multiprocessing as mp
import socket
import os
import pickle
import json
from typing import Any

class IPCDemo:
    """IPC 메커니즘 데모 클래스"""
    
    @staticmethod
    def pipe_communication():
        """파이프를 이용한 양방향 통신"""
        parent_conn, child_conn = mp.Pipe()
        
        def child_process(conn):
            """자식 프로세스"""
            conn.send("자식에서 부모로 메시지 전송")
            data = conn.recv()
            print(f"자식 프로세스 수신: {data}")
            conn.close()
        
        # 자식 프로세스 생성
        p = mp.Process(target=child_process, args=(child_conn,))
        p.start()
        
        # 부모 프로세스에서 통신
        data = parent_conn.recv()
        print(f"부모 프로세스 수신: {data}")
        parent_conn.send("부모에서 자식으로 응답")
        
        p.join()
        parent_conn.close()
    
    @staticmethod
    def queue_communication():
        """멀티프로세싱 큐를 이용한 통신"""
        queue = mp.Queue(maxsize=10)
        
        def producer(q):
            """데이터 생산자"""
            for i in range(5):
                data = {"id": i, "value": f"데이터-{i}"}
                q.put(data)
                print(f"생산된 데이터: {data}")
            q.put(None)  # 종료 신호
        
        def consumer(q):
            """데이터 소비자"""
            while True:
                data = q.get()
                if data is None:
                    break
                print(f"소비된 데이터: {data}")
        
        # 생산자와 소비자 프로세스 생성
        producer_proc = mp.Process(target=producer, args=(queue,))
        consumer_proc = mp.Process(target=consumer, args=(queue,))
        
        producer_proc.start()
        consumer_proc.start()
        
        producer_proc.join()
        consumer_proc.join()
    
    @staticmethod
    def shared_memory_communication():
        """공유 메모리를 이용한 고성능 통신"""
        from multiprocessing import shared_memory
        
        # 공유 메모리 생성
        shm = shared_memory.SharedMemory(create=True, size=1024, name='shared_mem_demo')
        
        def writer_process():
            """공유 메모리에 데이터 쓰기"""
            try:
                # 기존 공유 메모리 접근
                existing_shm = shared_memory.SharedMemory(name='shared_mem_demo')
                
                # 데이터 직렬화 및 저장
                data = {"status": "running", "count": 42, "message": "Hello from writer"}
                serialized = pickle.dumps(data)
                
                # 길이 정보 먼저 저장
                existing_shm.buf[0:4] = len(serialized).to_bytes(4, 'big')
                # 데이터 저장
                existing_shm.buf[4:4+len(serialized)] = serialized
                
                existing_shm.close()
                print("공유 메모리에 데이터 기록 완료")
            except Exception as e:
                print(f"쓰기 에러: {e}")
        
        def reader_process():
            """공유 메모리에서 데이터 읽기"""
            import time
            time.sleep(0.5)  # 쓰기 완료 대기
            
            try:
                existing_shm = shared_memory.SharedMemory(name='shared_mem_demo')
                
                # 길이 정보 읽기
                length = int.from_bytes(existing_shm.buf[0:4], 'big')
                
                # 데이터 읽기
                serialized = bytes(existing_shm.buf[4:4+length])
                data = pickle.loads(serialized)
                
                print(f"공유 메모리에서 읽은 데이터: {data}")
                
                existing_shm.close()
                existing_shm.unlink()  # 공유 메모리 정리
            except Exception as e:
                print(f"읽기 에러: {e}")
        
        # 프로세스 실행
        writer = mp.Process(target=writer_process)
        reader = mp.Process(target=reader_process)
        
        writer.start()
        reader.start()
        
        writer.join()
        reader.join()
    
    @staticmethod
    def unix_domain_socket():
        """유닉스 도메인 소켓을 이용한 IPC"""
        import tempfile
        import threading
        
        # 임시 소켓 파일 생성
        sock_file = tempfile.mktemp(suffix='.sock')
        
        def server():
            """서버 측"""
            server_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            server_socket.bind(sock_file)
            server_socket.listen(1)
            
            print("서버 대기 중...")
            conn, addr = server_socket.accept()
            
            # 데이터 수신
            data = conn.recv(1024)
            print(f"서버 수신: {data.decode()}")
            
            # 응답 전송
            conn.send(b"서버 응답: 데이터 수신 완료")
            
            conn.close()
            server_socket.close()
            os.unlink(sock_file)
        
        def client():
            """클라이언트 측"""
            import time
            time.sleep(0.5)  # 서버 시작 대기
            
            client_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            
            try:
                client_socket.connect(sock_file)
                client_socket.send(b"클라이언트에서 서버로 메시지")
                
                response = client_socket.recv(1024)
                print(f"클라이언트 응답: {response.decode()}")
            finally:
                client_socket.close()
        
        # 서버와 클라이언트 스레드 실행
        server_thread = threading.Thread(target=server)
        client_thread = threading.Thread(target=client)
        
        server_thread.start()
        client_thread.start()
        
        server_thread.join()
        client_thread.join()

# 다양한 IPC 메커니즘 실행
demo = IPCDemo()
print("=== 파이프 통신 ===")
demo.pipe_communication()

print("\n=== 큐 통신 ===")
demo.queue_communication()

print("\n=== 공유 메모리 통신 ===")
demo.shared_memory_communication()

print("\n=== 유닉스 도메인 소켓 ===")
demo.unix_domain_socket()
```

## 원격 프로시저 호출(RPC) 구현

### 가벼운 RPC 프레임워크 구축
```python
import json
import socket
import threading
import inspect
import hashlib
from typing import Dict, Any, Callable, Optional
from dataclasses import dataclass, asdict
from enum import Enum

class RPCErrorCode(Enum):
    """RPC 오류 코드"""
    METHOD_NOT_FOUND = 1
    INVALID_PARAMS = 2
    INTERNAL_ERROR = 3
    UNAUTHORIZED = 4
    TIMEOUT = 5

@dataclass
class RPCRequest:
    """RPC 요청 데이터 클래스"""
    method: str
    params: Dict[str, Any]
    id: Optional[int] = None
    auth_token: Optional[str] = None
    
    def to_json(self) -> str:
        """JSON 직렬화"""
        return json.dumps(asdict(self))

@dataclass
class RPCResponse:
    """RPC 응답 데이터 클래스"""
    result: Optional[Any] = None
    error: Optional[Dict[str, Any]] = None
    id: Optional[int] = None
    
    def to_json(self) -> str:
        """JSON 직렬화"""
        return json.dumps(asdict(self))
    
    @classmethod
    def success(cls, result: Any, request_id: Optional[int] = None) -> 'RPCResponse':
        """성공 응답 생성"""
        return cls(result=result, id=request_id)
    
    @classmethod
    def error_response(cls, code: RPCErrorCode, message: str, 
                      request_id: Optional[int] = None) -> 'RPCResponse':
        """오류 응답 생성"""
        return cls(
            error={"code": code.value, "message": message},
            id=request_id
        )

class RPCServer:
    """커스텀 RPC 서버 구현"""
    
    def __init__(self, host: str = 'localhost', port: int = 9090):
        self.host = host
        self.port = port
        self.methods: Dict[str, Callable] = {}
        self.running = False
        self.server_socket: Optional[socket.socket] = None
        self.auth_tokens = set()
        self.request_handlers: Dict[int, threading.Thread] = {}
    
    def register_method(self, name: str = None):
        """메서드 등록 데코레이터"""
        def decorator(func: Callable):
            method_name = name or func.__name__
            self.methods[method_name] = func
            return func
        return decorator
    
    def generate_auth_token(self, username: str, password: str) -> str:
        """인증 토큰 생성"""
        secret = "server-secret-key"
        data = f"{username}:{password}:{secret}"
        token = hashlib.sha256(data.encode()).hexdigest()
        self.auth_tokens.add(token)
        return token
    
    def validate_request(self, request: RPCRequest) -> bool:
        """요청 검증"""
        # 인증 토큰 확인
        if request.auth_token and request.auth_token not in self.auth_tokens:
            return False
        
        # 메서드 존재 확인
        if request.method not in self.methods:
            return False
        
        # 파라미터 검증
        method = self.methods[request.method]
        sig = inspect.signature(method)
        
        try:
            # 필수 파라미터 확인
            bound_args = sig.bind(**request.params)
            bound_args.apply_defaults()
            return True
        except TypeError:
            return False
    
    def handle_client(self, client_socket: socket.socket, address: tuple):
        """클라이언트 연결 처리"""
        print(f"클라이언트 연결: {address}")
        
        try:
            while True:
                # 데이터 수신
                data = client_socket.recv(4096)
                if not data:
                    break
                
                # 요청 파싱
                try:
                    request_dict = json.loads(data.decode())
                    request = RPCRequest(**request_dict)
                except json.JSONDecodeError:
                    response = RPCResponse.error_response(
                        RPCErrorCode.INVALID_PARAMS,
                        "Invalid JSON"
                    )
                    client_socket.send(response.to_json().encode())
                    continue
                
                # 요청 처리
                response = self.process_request(request)
                
                # 응답 전송
                client_socket.send(response.to_json().encode())
        
        except ConnectionResetError:
            print(f"클라이언트 연결 끊김: {address}")
        finally:
            client_socket.close()
    
    def process_request(self, request: RPCRequest) -> RPCResponse:
        """RPC 요청 처리"""
        # 요청 검증
        if not self.validate_request(request):
            return RPCResponse.error_response(
                RPCErrorCode.UNAUTHORIZED if request.auth_token 
                else RPCErrorCode.METHOD_NOT_FOUND,
                "Unauthorized or method not found",
                request.id
            )
        
        try:
            # 메서드 실행
            method = self.methods[request.method]
            result = method(**request.params)
            
            return RPCResponse.success(result, request.id)
        
        except Exception as e:
            print(f"메서드 실행 에러: {e}")
            return RPCResponse.error_response(
                RPCErrorCode.INTERNAL_ERROR,
                str(e),
                request.id
            )
    
    def start(self):
        """서버 시작"""
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server_socket.bind((self.host, self.port))
        self.server_socket.listen(5)
        
        self.running = True
        print(f"RPC 서버 시작: {self.host}:{self.port}")
        
        try:
            while self.running:
                client_socket, address = self.server_socket.accept()
                
                # 새 스레드에서 클라이언트 처리
                client_thread = threading.Thread(
                    target=self.handle_client,
                    args=(client_socket, address),
                    daemon=True
                )
                client_thread.start()
        
        except KeyboardInterrupt:
            print("서버 종료 중...")
        finally:
            self.stop()
    
    def stop(self):
        """서버 정지"""
        self.running = False
        if self.server_socket:
            self.server_socket.close()

class RPCClient:
    """RPC 클라이언트 구현"""
    
    def __init__(self, host: str = 'localhost', port: int = 9090):
        self.host = host
        self.port = port
        self.request_id = 0
        self.auth_token: Optional[str] = None
    
    def connect(self):
        """서버 연결"""
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.connect((self.host, self.port))
    
    def authenticate(self, username: str, password: str) -> bool:
        """인증 및 토큰 획득"""
        # 실제 구현에서는 서버의 인증 엔드포인트 호출
        # 여기서는 데모를 위해 직접 토큰 생성
        data = f"{username}:{password}"
        self.auth_token = hashlib.sha256(data.encode()).hexdigest()
        return True
    
    def call(self, method: str, **params) -> Any:
        """원격 메서드 호출"""
        self.request_id += 1
        
        # 요청 생성
        request = RPCRequest(
            method=method,
            params=params,
            id=self.request_id,
            auth_token=self.auth_token
        )
        
        # 요청 전송
        self.socket.send(request.to_json().encode())
        
        # 응답 수신
        data = self.socket.recv(4096)
        response_dict = json.loads(data.decode())
        response = RPCResponse(**response_dict)
        
        # 오류 처리
        if response.error:
            error_msg = response.error.get('message', 'Unknown error')
            raise Exception(f"RPC Error: {error_msg}")
        
        return response.result
    
    def close(self):
        """연결 종료"""
        if hasattr(self, 'socket'):
            self.socket.close()

# RPC 서비스 구현 및 사용 예제
def run_rpc_demo():
    """RPC 데모 실행"""
    
    # 서버 생성 및 메서드 등록
    server = RPCServer('localhost', 9090)
    
    @server.register_method()
    def add(a: int, b: int) -> int:
        """덧셈 연산"""
        return a + b
    
    @server.register_method('multiply')
    def mul(x: float, y: float) -> float:
        """곱셈 연산"""
        return x * y
    
    @server.register_method()
    def process_data(data: list, prefix: str = "") -> list:
        """데이터 처리"""
        return [f"{prefix}{item}" for item in data]
    
    # 서버를 별도 스레드에서 실행
    import threading
    server_thread = threading.Thread(target=server.start, daemon=True)
    server_thread.start()
    
    # 잠시 대기
    import time
    time.sleep(0.5)
    
    # 클라이언트 생성 및 사용
    client = RPCClient('localhost', 9090)
    client.connect()
    
    try:
        # 원격 메서드 호출
        result1 = client.call('add', a=10, b=20)
        print(f"add(10, 20) = {result1}")
        
        result2 = client.call('multiply', x=5.5, y=2.0)
        print(f"multiply(5.5, 2.0) = {result2}")
        
        result3 = client.call('process_data', data=[1, 2, 3], prefix="item_")
        print(f"process_data = {result3}")
        
        # 잘못된 호출 (에러 발생)
        try:
            client.call('nonexistent_method')
        except Exception as e:
            print(f"예상된 에러: {e}")
    
    finally:
        client.close()
        server.stop()

# RPC 데모 실행
run_rpc_demo()
```

## 간단한 클라이언트 인증 시스템

### 다층 인증 시스템 구현
```python
import hashlib
import hmac
import os
import base64
import time
from datetime import datetime, timedelta
from typing import Optional, Dict, Tuple
import secrets

class AuthenticationSystem:
    """종합적인 인증 시스템"""
    
    def __init__(self):
        self.users: Dict[str, Dict] = {}
        self.sessions: Dict[str, Dict] = {}
        self.failed_attempts: Dict[str, int] = {}
        self.locked_accounts: Dict[str, float] = {}
        
        # 비밀 키 (실제 환경에서는 안전한 저장소에 보관)
        self.secret_key = secrets.token_bytes(32)
        
    def register_user(self, username: str, password: str, 
                     email: str, **extra_fields) -> bool:
        """사용자 등록"""
        if username in self.users:
            return False
        
        # 비밀번호 해시 생성
        salt = os.urandom(16)
        password_hash = self._hash_password(password, salt)
        
        # 사용자 정보 저장
        self.users[username] = {
            'password_hash': password_hash,
            'salt': salt,
            'email': email,
            'created_at': datetime.now(),
            'last_login': None,
            'failed_attempts': 0,
            'is_active': True,
            'roles': ['user'],  # 기본 역할
            **extra_fields
        }
        
        print(f"사용자 등록 완료: {username}")
        return True
    
    def _hash_password(self, password: str, salt: bytes) -> str:
        """비밀번호 해시 생성"""
        # PBKDF2-HMAC-SHA256 사용
        iterations = 100000
        dk = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt,
            iterations
        )
        return base64.b64encode(dk).decode('utf-8')
    
    def verify_password(self, username: str, password: str) -> bool:
        """비밀번호 검증"""
        # 계정 잠금 확인
        if username in self.locked_accounts:
            lock_time = self.locked_accounts[username]
            if time.time() - lock_time < 300:  # 5분 잠금
                raise AccountLockedError("계정이 잠겼습니다. 5분 후 다시 시도하세요.")
            else:
                del self.locked_accounts[username]
        
        # 사용자 존재 확인
        if username not in self.users:
            self._record_failed_attempt(username)
            return False
        
        user = self.users[username]
        
        # 비활성 계정 확인
        if not user['is_active']:
            raise InactiveAccountError("계정이 비활성화되었습니다.")
        
        # 비밀번호 검증
        salt = user['salt']
        password_hash = self._hash_password(password, salt)
        
        if hmac.compare_digest(password_hash, user['password_hash']):
            # 로그인 성공
            user['last_login'] = datetime.now()
            user['failed_attempts'] = 0
            self.failed_attempts.pop(username, None)
            return True
        else:
            # 로그인 실패
            self._record_failed_attempt(username)
            return False
    
    def _record_failed_attempt(self, username: str):
        """실패한 로그인 시도 기록"""
        self.failed_attempts[username] = self.failed_attempts.get(username, 0) + 1
        
        if username in self.users:
            self.users[username]['failed_attempts'] = self.failed_attempts[username]
        
        # 5회 이상 실패 시 계정 잠금
        if self.failed_attempts[username] >= 5:
            self.locked_accounts[username] = time.time()
            print(f"계정 잠금: {username}")
    
    def create_session(self, username: str, client_info: Dict) -> str:
        """인증 세션 생성"""
        # 세션 토큰 생성
        session_token = secrets.token_urlsafe(32)
        
        # 세션 정보 저장
        self.sessions[session_token] = {
            'username': username,
            'created_at': datetime.now(),
            'last_activity': datetime.now(),
            'client_ip': client_info.get('ip', ''),
            'user_agent': client_info.get('user_agent', ''),
            'expires_at': datetime.now() + timedelta(hours=1)
        }
        
        return session_token
    
    def validate_session(self, session_token: str) -> Optional[Dict]:
        """세션 토큰 검증"""
        if session_token not in self.sessions:
            return None
        
        session = self.sessions[session_token]
        
        # 세션 만료 확인
        if datetime.now() > session['expires_at']:
            del self.sessions[session_token]
            return None
        
        # 사용자 존재 확인
        username = session['username']
        if username not in self.users or not self.users[username]['is_active']:
            del self.sessions[session_token]
            return None
        
        # 활동 시간 갱신
        session['last_activity'] = datetime.now()
        session['expires_at'] = datetime.now() + timedelta(hours=1)
        
        return {
            'username': username,
            'roles': self.users[username]['roles'],
            'session': session
        }
    
    def revoke_session(self, session_token: str):
        """세션 무효화"""
        if session_token in self.sessions:
            del self.sessions[session_token]
    
    def generate_api_key(self, username: str, key_name: str) -> Tuple[str, str]:
        """API 키 생성"""
        # API 키와 시크릿 생성
        api_key = base64.b64encode(os.urandom(24)).decode('utf-8')
        api_secret = secrets.token_urlsafe(32)
        
        # 사용자 정보에 저장
        if username in self.users:
            if 'api_keys' not in self.users[username]:
                self.users[username]['api_keys'] = {}
            
            api_key_hash = hashlib.sha256(api_secret.encode()).hexdigest()
            self.users[username]['api_keys'][api_key] = {
                'name': key_name,
                'hash': api_key_hash,
                'created_at': datetime.now(),
                'last_used': None,
                'is_active': True
            }
        
        return api_key, api_secret
    
    def validate_api_key(self, api_key: str, api_secret: str) -> Optional[Dict]:
        """API 키 검증"""
        # API 키를 가진 사용자 찾기
        for username, user_data in self.users.items():
            if 'api_keys' in user_data and api_key in user_data['api_keys']:
                key_info = user_data['api_keys'][api_key]
                
                # 활성 상태 확인
                if not key_info['is_active']:
                    return None
                
                # 시크릿 검증
                provided_hash = hashlib.sha256(api_secret.encode()).hexdigest()
                if hmac.compare_digest(provided_hash, key_info['hash']):
                    # 사용 시간 업데이트
                    key_info['last_used'] = datetime.now()
                    
                    return {
                        'username': username,
                        'roles': user_data['roles'],
                        'key_info': key_info
                    }
        
        return None

class AuthenticationError(Exception):
    """인증 관련 기본 예외"""
    pass

class AccountLockedError(AuthenticationError):
    """계정 잠금 예외"""
    pass

class InactiveAccountError(AuthenticationError):
    """비활성 계정 예외"""
    pass

# 인증 시스템 데모
def run_auth_demo():
    """인증 시스템 데모 실행"""
    auth_system = AuthenticationSystem()
    
    # 사용자 등록
    auth_system.register_user(
        username="john_doe",
        password="SecurePass123!",
        email="john@example.com",
        full_name="John Doe"
    )
    
    # 비밀번호 검증
    print("=== 비밀번호 검증 ===")
    print(f"올바른 비밀번호: {auth_system.verify_password('john_doe', 'SecurePass123!')}")
    print(f"잘못된 비밀번호: {auth_system.verify_password('john_doe', 'WrongPass')}")
    
    # 세션 생성
    client_info = {
        'ip': '192.168.1.100',
        'user_agent': 'Mozilla/5.0'
    }
    session_token = auth_system.create_session('john_doe', client_info)
    print(f"\n생성된 세션 토큰: {session_token[:20]}...")
    
    # 세션 검증
    session_data = auth_system.validate_session(session_token)
    print(f"세션 검증 결과: {bool(session_data)}")
    if session_data:
        print(f"사용자: {session_data['username']}")
    
    # API 키 생성
    api_key, api_secret = auth_system.generate_api_key('john_doe', 'web-app')
    print(f"\n생성된 API 키: {api_key[:20]}...")
    print(f"API 시크릿: {api_secret[:20]}...")
    
    # API 키 검증
    api_auth = auth_system.validate_api_key(api_key, api_secret)
    print(f"API 키 검증 결과: {bool(api_auth)}")
    
    # 계정 잠금 시뮬레이션
    print("\n=== 계정 잠금 시뮬레이션 ===")
    for i in range(5):
        auth_system.verify_password('john_doe', 'WrongPassword')
    
    try:
        auth_system.verify_password('john_doe', 'SecurePass123!')
    except AccountLockedError as e:
        print(f"계정 잠금됨: {e}")

run_auth_demo()
```

## 네트워크 서비스에 SSL/TLS 추가

### 자체 서명된 인증서 생성과 SSL 서버 구현
```python
import ssl
import socket
import threading
import hashlib
from datetime import datetime, timedelta
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
import os

class SSLContextManager:
    """SSL 컨텍스트 관리 클래스"""
    
    @staticmethod
    def generate_self_signed_cert(hostname: str, 
                                 cert_file: str = "server.crt",
                                 key_file: str = "server.key"):
        """자체 서명된 인증서 생성"""
        
        # 개인 키 생성
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        
        # 공개 키 추출
        public_key = private_key.public_key()
        
        # 인증서 빌더 생성
        builder = x509.CertificateBuilder()
        
        # 주체 이름 설정
        subject = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "KR"),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "Seoul"),
            x509.NameAttribute(NameOID.LOCALITY_NAME, "Seoul"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "My Company"),
            x509.NameAttribute(NameOID.COMMON_NAME, hostname),
        ])
        
        issuer = subject  # 자체 서명이므로 발급자 = 주체
        
        builder = builder.subject_name(subject)
        builder = builder.issuer_name(issuer)
        
        # 유효 기간 설정
        builder = builder.not_valid_before(datetime.utcnow())
        builder = builder.not_valid_after(
            datetime.utcnow() + timedelta(days=365)
        )
        
        # 일련번호 설정
        builder = builder.serial_number(x509.random_serial_number())
        
        # 공개 키 설정
        builder = builder.public_key(public_key)
        
        # 사용 용도 추가
        builder = builder.add_extension(
            x509.SubjectAlternativeName([x509.DNSName(hostname)]),
            critical=False
        )
        
        builder = builder.add_extension(
            x509.BasicConstraints(ca=False, path_length=None),
            critical=True
        )
        
        builder = builder.add_extension(
            x509.KeyUsage(
                digital_signature=True,
                content_commitment=False,
                key_encipherment=True,
                data_encipherment=False,
                key_agreement=False,
                key_cert_sign=False,
                crl_sign=False,
                encipher_only=False,
                decipher_only=False
            ),
            critical=True
        )
        
        builder = builder.add_extension(
            x509.ExtendedKeyUsage([
                x509.oid.ExtendedKeyUsageOID.SERVER_AUTH,
                x509.oid.ExtendedKeyUsageOID.CLIENT_AUTH
            ]),
            critical=False
        )
        
        # 인증서 서명
        certificate = builder.sign(
            private_key=private_key,
            algorithm=hashes.SHA256(),
            backend=default_backend()
        )
        
        # 파일로 저장
        with open(cert_file, "wb") as f:
            f.write(certificate.public_bytes(
                encoding=serialization.Encoding.PEM
            ))
        
        with open(key_file, "wb") as f:
            f.write(private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=serialization.NoEncryption()
            ))
        
        print(f"인증서 생성 완료: {cert_file}, {key_file}")
        return cert_file, key_file
    
    @classmethod
    def create_server_context(cls, cert_file: str, key_file: str, 
                             client_auth: bool = False) -> ssl.SSLContext:
        """서버 SSL 컨텍스트 생성"""
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        
        # 인증서 로드
        context.load_cert_chain(certfile=cert_file, keyfile=key_file)
        
        # 클라이언트 인증 설정
        if client_auth:
            context.verify_mode = ssl.CERT_REQUIRED
            # 실제 환경에서는 신뢰할 수 있는 CA 인증서를 로드해야 함
            # context.load_verify_locations(cafile="ca.crt")
        
        # 보안 설정
        context.set_ciphers('ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20')
        context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1  # 오래된 프로토콜 비활성화
        
        return context
    
    @classmethod
    def create_client_context(cls, verify_server: bool = True) -> ssl.SSLContext:
        """클라이언트 SSL 컨텍스트 생성"""
        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
        
        if verify_server:
            # 실제 환경에서는 시스템의 신뢰할 수 있는 인증서 사용
            pass
        else:
            # 테스트 목적으로 서버 인증서 검증 비활성화 (위험!)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
        
        return context

class SecureTCPServer:
    """SSL/TLS 보안 TCP 서버"""
    
    def __init__(self, host: str = 'localhost', port: int = 8443,
                 cert_file: str = 'server.crt', key_file: str = 'server.key'):
        self.host = host
        self.port = port
        self.cert_file = cert_file
        self.key_file = key_file
        self.running = False
        
        # 인증서 파일이 없으면 생성
        if not os.path.exists(cert_file) or not os.path.exists(key_file):
            print("인증서 파일이 없습니다. 생성 중...")
            SSLContextManager.generate_self_signed_cert(hostname=host)
        
        # SSL 컨텍스트 생성
        self.ssl_context = SSLContextManager.create_server_context(
            cert_file, key_file
        )
    
    def handle_client(self, conn: ssl.SSLSocket, address: tuple):
        """클라이언트 연결 처리"""
        print(f"보안 연결 수립: {address}")
        
        try:
            # SSL 연결 정보 출력
            cipher = conn.cipher()
            print(f"사용 중인 암호화: {cipher[0]}, 버전: {cipher[1]}")
            
            # 클라이언트 인증서 정보 (있는 경우)
            try:
                client_cert = conn.getpeercert()
                if client_cert:
                    print(f"클라이언트 인증서 주체: {client_cert['subject']}")
            except:
                pass
            
            # 데이터 통신
            while True:
                data = conn.recv(1024)
                if not data:
                    break
                
                message = data.decode('utf-8').strip()
                print(f"수신: {message}")
                
                # 응답 생성
                response = f"암호화된 응답: {message.upper()}\n"
                conn.send(response.encode('utf-8'))
        
        except ssl.SSLError as e:
            print(f"SSL 에러: {e}")
        except Exception as e:
            print(f"에러: {e}")
        finally:
            conn.close()
            print(f"연결 종료: {address}")
    
    def start(self):
        """서버 시작"""
        # 기본 TCP 소켓 생성
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind((self.host, self.port))
        sock.listen(5)
        
        self.running = True
        print(f"보안 서버 시작: https://{self.host}:{self.port}")
        
        try:
            while self.running:
                client_socket, address = sock.accept()
                
                # SSL 소켓으로 래핑
                try:
                    ssl_socket = self.ssl_context.wrap_socket(
                        client_socket,
                        server_side=True
                    )
                    
                    # 새 스레드에서 클라이언트 처리
                    client_thread = threading.Thread(
                        target=self.handle_client,
                        args=(ssl_socket, address),
                        daemon=True
                    )
                    client_thread.start()
                    
                except ssl.SSLError as e:
                    print(f"SSL 핸드셰이크 실패: {e}")
                    client_socket.close()
        
        except KeyboardInterrupt:
            print("서버 종료 중...")
        finally:
            sock.close()
            self.running = False

class SecureTCPClient:
    """SSL/TLS 보안 TCP 클라이언트"""
    
    def __init__(self, host: str = 'localhost', port: int = 8443,
                 verify_server: bool = False):
        self.host = host
        self.port = port
        
        # SSL 컨텍스트 생성
        self.ssl_context = SSLContextManager.create_client_context(
            verify_server=verify_server
        )
    
    def connect(self):
        """서버 연결"""
        # 기본 TCP 소켓 생성
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        # SSL 소켓으로 래핑
        self.ssl_socket = self.ssl_context.wrap_socket(
            sock,
            server_hostname=self.host
        )
        
        self.ssl_socket.connect((self.host, self.port))
        
        # 연결 정보 출력
        cipher = self.ssl_socket.cipher()
        print(f"보안 연결 수립: {self.host}:{self.port}")
        print(f"암호화: {cipher[0]}, 버전: {cipher[1]}")
        
        # 서버 인증서 정보
        cert = self.ssl_socket.getpeercert()
        if cert:
            print(f"서버 인증서 주체: {cert['subject']}")
    
    def send_message(self, message: str) -> str:
        """메시지 전송 및 응답 수신"""
        self.ssl_socket.send(message.encode('utf-8'))
        response = self.ssl_socket.recv(1024)
        return response.decode('utf-8')
    
    def close(self):
        """연결 종료"""
        if hasattr(self, 'ssl_socket'):
            self.ssl_socket.close()

# 보안 통신 데모 실행
def run_secure_demo():
    """SSL/TLS 보안 통신 데모"""
    import threading
    import time
    
    # 서버 인증서 생성
    cert_file, key_file = SSLContextManager.generate_self_signed_cert("localhost")
    
    # 서버 시작
    server = SecureTCPServer('localhost', 8443, cert_file, key_file)
    server_thread = threading.Thread(target=server.start, daemon=True)
    server_thread.start()
    
    # 잠시 대기
    time.sleep(1)
    
    # 클라이언트 연결 및 통신
    client = SecureTCPClient('localhost', 8443, verify_server=False)
    
    try:
        client.connect()
        
        # 메시지 교환
        messages = ["안녕하세요", "보안 테스트", "암호화 통신"]
        
        for msg in messages:
            response = client.send_message(msg)
            print(f"응답: {response.strip()}")
            time.sleep(0.5)
    
    finally:
        client.close()

# 보안 통신 데모 실행
if __name__ == "__main__":
    print("=== SSL/TLS 보안 통신 데모 ===")
    run_secure_demo()
```

## 고급: TLS 상호 인증 구현

```python
def setup_mutual_tls_auth():
    """상호 TLS 인증 설정"""
    
    # 서버 컨텍스트
    server_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    server_context.load_cert_chain(
        certfile="server.crt",
        keyfile="server.key"
    )
    
    # 클라이언트 인증서 요구
    server_context.verify_mode = ssl.CERT_REQUIRED
    server_context.load_verify_locations(cafile="ca.crt")  # CA 인증서
    
    # 클라이언트 컨텍스트
    client_context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
    client_context.load_cert_chain(
        certfile="client.crt",
        keyfile="client.key"
    )
    client_context.load_verify_locations(cafile="ca.crt")
    
    return server_context, client_context
```

## 결론

파이썬을 활용한 네트워크 프로그래밍은 단순한 데이터 전송을 넘어 보안, 인증, 효율적인 통신을 아우르는 종합적인 기술입니다. 효과적인 시스템을 구축하기 위해 다음 원칙을 준수해야 합니다:

1. **통신 방식의 적절한 선택**: 프로세스 간 통신에는 공유 메모리나 파이프를, 네트워크 통신에는 소켓을 상황에 맞게 선택합니다.
2. **보안 통신의 필수적 적용**: 모든 네트워크 통신은 기본적으로 TLS/SSL을 적용하여 데이터 기밀성과 무결성을 보장합니다.
3. **다층 인증 시스템 구축**: 단일 인증 방식에 의존하지 않고 세션, 토큰, API 키 등 다중 인증 메커니즘을 구현합니다.
4. **오류 처리와 복원력**: 네트워크 통신의 불안정성을 고려하여 타임아웃, 재시도, 연결 풀링 등을 적절히 구현합니다.
5. **성능과 확장성 고려**: 비동기 I/O, 연결 풀, 메시지 큐 등을 활용하여 대규모 동시 접속을 효율적으로 처리합니다.

실제 프로덕션 환경에서는 추가적으로 다음과 같은 요소들을 고려해야 합니다:
- 인증서 관리와 주기적인 갱신
- 취약점 스캔과 보안 업데이트
- 모니터링과 로깅 시스템 구축
- 부하 분산과 고가용성 구성
- 규정 준수와 감사 요구사항 대응

이러한 모범 사례들을 체계적으로 적용하면 안전하고 확장 가능한 네트워크 애플리케이션을 구축할 수 있으며, 현대적인 마이크로서비스 아키텍처와 클라우드 네이티브 환경에서도 효과적으로 동작할 수 있습니다.