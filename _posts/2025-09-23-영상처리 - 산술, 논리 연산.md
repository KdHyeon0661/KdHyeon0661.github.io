---
layout: post
title: 영상처리 - 산술/논리 연산
date: 2025-09-23 14:25:23 +0900
category: 영상처리
---
# 산술/논리 연산으로 두 영상을 조합하기

이 장에서는 **두 장의 영상**을 픽셀 단위로 결합하는 방법을 다룹니다.
우리의 `ImageTool`(Win32, BGRA32 `IppDib`)에 **산술 연산(더하기/빼기/평균/차이)**, **논리 연산(AND/OR)** 을 추가하고, 메뉴에서 바로 실행되도록 합니다.

> 코드 블록은 한 번만 ``` 로 감싸며, 수식은 MathJax를 사용합니다.
> 모든 연산은 **알파 채널은 보존**(기본: “현재 창의 A” 유지), **B/G/R 채널만 처리**합니다.

---

## | **영상의 산술 연산**

### 개념 요약 (8-bit 채널, 0~255)

- **덧셈(Add)**
  \[
  v'=\min(255,\;v_A+v_B)
  \]
  밝기/강도의 합. 포화(클램프)로 하이라이트가 255를 넘지 않게 방지.

- **뺄셈(Subtract)**
  \[
  v'=\max(0,\;v_A-v_B)
  \]
  한 영상에서 다른 영상을 제거(음수는 0으로 바닥 포화).

- **평균(Average, Blend)**
  (단순 평균)
  \[
  v'=\left\lfloor\frac{v_A+v_B}{2}+0.5\right\rfloor
  \]
  (가중 평균, \(\alpha\in[0,1]\))
  \[
  v'=\left\lfloor (1-\alpha)\,v_A+\alpha\,v_B + 0.5\right\rfloor
  \]

- **차이(Difference, Absolute)**
  \[
  v'=\lvert v_A-v_B\rvert
  \]
  두 영상의 **변화/엣지** 검출에 유용.

> 두 영상의 크기가 다르면 **겹치는 영역(교집합 ROI)** 에만 연산하고, 나머지는 A 그대로 두겠습니다.

---

### 산술 연산 구현

아래 헤더 한 장으로 **공통 유틸 + 파일 열기 + 연산 본체**까지 구성합니다.

```cpp
// ArithLogicOps.h
#pragma once
#include <windows.h>
#include <commdlg.h>
#include <string>
#include <algorithm>
#include <cstdint>
#include <vector>
#include "IppDib.h"

// ---------- 유틸 ----------
inline uint8_t sat_add_u8(uint8_t a, uint8_t b){ int s=a+b; return (uint8_t)(s>255?255:s); }
inline uint8_t sat_sub_u8(uint8_t a, uint8_t b){ int d=a-b; return (uint8_t)(d<0?0:d); }
inline uint8_t avg_u8(uint8_t a, uint8_t b){ return (uint8_t)((a + b + 1) >> 1); } // 반올림 평균
inline uint8_t lerp_u8(uint8_t a, uint8_t b, double alpha) {
    // alpha: 0..1
    double v = (1.0-alpha)*a + alpha*b;
    if (v<0) v=0; if (v>255) v=255; return (uint8_t)std::lround(v);
}

// ---------- 보조: 파일 열기 ----------
inline bool OpenOtherImage(HWND owner, IppDib& out) {
    wchar_t buf[MAX_PATH]=L"";
    OPENFILENAMEW ofn{ sizeof(ofn) };
    ofn.hwndOwner = owner;
    ofn.lpstrFilter = L"BMP files (*.bmp)\0*.bmp\0All files (*.*)\0*.*\0";
    ofn.lpstrFile = buf; ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
    ofn.lpstrTitle = L"Select the other image (BMP)";
    if (!GetOpenFileNameW(&ofn)) return false;
    return out.loadBMP(buf);
}

// ---------- 공통 프레임: 두 영상 조합 ----------
template<typename PIXEL_OP>
inline bool CombineTwoImages_BGRA32(IppDib& A, const IppDib& B, PIXEL_OP op, bool keepAlphaFromA=true) {
    if (!A || !B) return false;
    const int W = std::min(A.width(),  B.width());
    const int H = std::min(A.height(), B.height());
    if (W<=0 || H<=0) return false;

    for (int y=0; y<H; ++y) {
        uint8_t* rA = (uint8_t*)A.bits() + (size_t)y * A.stride();
        const uint8_t* rB = (const uint8_t*)B.bits() + (size_t)y * B.stride();
        for (int x=0; x<W; ++x) {
            uint8_t* pA = &rA[x*4];
            const uint8_t* pB = &rB[x*4];
            // B,G,R만 처리
            uint8_t Bn, Gn, Rn;
            op(pA[0], pA[1], pA[2], pB[0], pB[1], pB[2], Bn, Gn, Rn);
            pA[0]=Bn; pA[1]=Gn; pA[2]=Rn;
            if (!keepAlphaFromA) pA[3] = std::max(pA[3], pB[3]); // 예시: 필요시 알파 조합
        }
    }
    return true;
}

// ---------- 1) 덧셈 ----------
inline bool Op_Add(IppDib& A, HWND owner) {
    IppDib B; if (!OpenOtherImage(owner, B)) return false;
    return CombineTwoImages_BGRA32(A, B,
        [](uint8_t Ab,uint8_t Ag,uint8_t Ar, uint8_t Bb,uint8_t Bg,uint8_t Br,
           uint8_t& Bo,uint8_t& Go,uint8_t& Ro){
            Bo = sat_add_u8(Ab, Bb);
            Go = sat_add_u8(Ag, Bg);
            Ro = sat_add_u8(Ar, Br);
        });
}

// ---------- 2) 뺄셈 ----------
inline bool Op_Sub(IppDib& A, HWND owner) {
    IppDib B; if (!OpenOtherImage(owner, B)) return false;
    return CombineTwoImages_BGRA32(A, B,
        [](uint8_t Ab,uint8_t Ag,uint8_t Ar, uint8_t Bb,uint8_t Bg,uint8_t Br,
           uint8_t& Bo,uint8_t& Go,uint8_t& Ro){
            Bo = sat_sub_u8(Ab, Bb);
            Go = sat_sub_u8(Ag, Bg);
            Ro = sat_sub_u8(Ar, Br);
        });
}

// ---------- 3) 평균 (단순 평균) ----------
inline bool Op_Avg(IppDib& A, HWND owner) {
    IppDib B; if (!OpenOtherImage(owner, B)) return false;
    return CombineTwoImages_BGRA32(A, B,
        [](uint8_t Ab,uint8_t Ag,uint8_t Ar, uint8_t Bb,uint8_t Bg,uint8_t Br,
           uint8_t& Bo,uint8_t& Go,uint8_t& Ro){
            Bo = avg_u8(Ab, Bb);
            Go = avg_u8(Ag, Bg);
            Ro = avg_u8(Ar, Br);
        });
}

// ---------- 3-확장) 가중 평균(블렌드) ----------
inline bool Op_Blend(IppDib& A, HWND owner, double alpha /*0..1*/) {
    IppDib B; if (!OpenOtherImage(owner, B)) return false;
    if (alpha<0) alpha=0; if (alpha>1) alpha=1;
    return CombineTwoImages_BGRA32(A, B,
        [alpha](uint8_t Ab,uint8_t Ag,uint8_t Ar, uint8_t Bb,uint8_t Bg,uint8_t Br,
                uint8_t& Bo,uint8_t& Go,uint8_t& Ro){
            Bo = lerp_u8(Ab, Bb, alpha);
            Go = lerp_u8(Ag, Bg, alpha);
            Ro = lerp_u8(Ar, Br, alpha);
        });
}

// ---------- 4) 차이(절대값) ----------
inline bool Op_Diff(IppDib& A, HWND owner) {
    IppDib B; if (!OpenOtherImage(owner, B)) return false;
    return CombineTwoImages_BGRA32(A, B,
        [](uint8_t Ab,uint8_t Ag,uint8_t Ar, uint8_t Bb,uint8_t Bg,uint8_t Br,
           uint8_t& Bo,uint8_t& Go,uint8_t& Ro){
            Bo = (uint8_t)( (Ab> Bb)? (Ab-Bb) : (Bb-Ab) );
            Go = (uint8_t)( (Ag> Bg)? (Ag-Bg) : (Bg-Ag) );
            Ro = (uint8_t)( (Ar> Br)? (Ar-Br) : (Br-Ar) );
        });
}

// ---------- 5) 논리 AND ----------
inline bool Op_And(IppDib& A, HWND owner) {
    IppDib B; if (!OpenOtherImage(owner, B)) return false;
    return CombineTwoImages_BGRA32(A, B,
        [](uint8_t Ab,uint8_t Ag,uint8_t Ar, uint8_t Bb,uint8_t Bg,uint8_t Br,
           uint8_t& Bo,uint8_t& Go,uint8_t& Ro){
            Bo = (uint8_t)(Ab & Bb);
            Go = (uint8_t)(Ag & Bg);
            Ro = (uint8_t)(Ar & Br);
        });
}

// ---------- 6) 논리 OR ----------
inline bool Op_Or(IppDib& A, HWND owner) {
    IppDib B; if (!OpenOtherImage(owner, B)) return false;
    return CombineTwoImages_BGRA32(A, B,
        [](uint8_t Ab,uint8_t Ag,uint8_t Ar, uint8_t Bb,uint8_t Bg,uint8_t Br,
           uint8_t& Bo,uint8_t& Go,uint8_t& Ro){
            Bo = (uint8_t)(Ab | Bb);
            Go = (uint8_t)(Ag | Bg);
            Ro = (uint8_t)(Ar | Br);
        });
}
```

#### 동작 요약

- `OpenOtherImage()` 로 **두 번째 영상**(BMP)을 고릅니다.
- `CombineTwoImages_BGRA32()` 가 **겹치는 영역**만 안전하게 처리합니다.
- 각 연산은 **람다**에 픽셀 연산만 정의해 간결합니다.

---

### **블렌드(가중 평균) 대화 상자**

평균 연산을 더 실용적으로 쓰기 위해, **가중치 \(\alpha\)** 를 입력받는 간단한 대화 상자를 추가할 수 있습니다.
(슬라이더 0~100% → \(\alpha=0.0\sim1.0\))

```cpp
// BlendDlg.h
#pragma once
#include <windows.h>
#include <commctrl.h>
#include "resource.h"

class BlendDlg {
public:
    explicit BlendDlg(HWND owner): owner_(owner) {}
    INT_PTR DoModal();
    double alpha() const { return alpha_; }

private:
    static INT_PTR CALLBACK DlgProc(HWND h, UINT m, WPARAM w, LPARAM l);
    INT_PTR OnInit(HWND h);
    INT_PTR OnHScroll(HWND h, WPARAM w, LPARAM l);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);

private:
    HWND owner_ = nullptr;
    double alpha_ = 0.5; // 기본 50%
};

// BlendDlg.cpp
#include "BlendDlg.h"

INT_PTR BlendDlg::DoModal() {
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_BLEND),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK BlendDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m==WM_INITDIALOG) {
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self = (BlendDlg*)l; return self->OnInit(h);
    }
    auto* self = (BlendDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    switch (m) {
    case WM_HSCROLL: return self->OnHScroll(h, w, l);
    case WM_COMMAND: return self->OnCommand(h, w, l);
    default: return FALSE;
    }
}
INT_PTR BlendDlg::OnInit(HWND h) {
    SendDlgItemMessageW(h, 1001/*IDC_SLD_ALPHA*/, TBM_SETRANGE, TRUE, MAKELPARAM(0,100));
    SendDlgItemMessageW(h, 1001, TBM_SETPOS, TRUE, 50);
    SetDlgItemInt(h, 1002/*IDC_EDIT_ALPHA*/, 50, FALSE);
    return TRUE;
}
INT_PTR BlendDlg::OnHScroll(HWND h, WPARAM, LPARAM l) {
    if ((HWND)l == GetDlgItem(h, 1001)) {
        int pos=(int)SendDlgItemMessageW(h, 1001, TBM_GETPOS,0,0);
        SetDlgItemInt(h, 1002, pos, FALSE);
    }
    return TRUE;
}
INT_PTR BlendDlg::OnCommand(HWND h, WPARAM w, LPARAM) {
    switch (LOWORD(w)) {
    case IDOK: {
        BOOL ok=FALSE; int v=GetDlgItemInt(h, 1002, &ok, FALSE);
        if (!ok) v=50; if (v<0) v=0; if (v>100) v=100;
        alpha_ = v/100.0;
        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL: EndDialog(h, IDCANCEL); return TRUE;
    default: return FALSE;
    }
}
```

리소스(간단 템플릿):

```cpp
// resource.h (추가)
#define IDD_BLEND       340
#define IDC_SLD_ALPHA   1001
#define IDC_EDIT_ALPHA  1002

```

```rc
// ImageTool.rc (추가)
IDD_BLEND DIALOGEX 0,0,160,70
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Blend (Average)"
FONT 9, "Segoe UI"
BEGIN
    LTEXT "Alpha (0..100%)", -1, 10, 12, 80, 10
    CONTROL "", IDC_SLD_ALPHA, TRACKBAR_CLASS, WS_TABSTOP | TBS_AUTOTICKS, 10, 24, 100, 16
    EDITTEXT IDC_EDIT_ALPHA, 120, 24, 30, 14, ES_NUMBER | WS_TABSTOP
    DEFPUSHBUTTON "OK", IDOK, 60, 48, 36, 14
    PUSHBUTTON "Cancel", IDCANCEL, 100, 48, 36, 14
END
```

메뉴에서 “Blend…” 를 눌렀을 때:

```cpp
// main_multiwin.cpp (WM_COMMAND 일부, st->dib 존재 가정)
case ID_IMAGE_BLEND:
    if (st && st->dib) {
        BlendDlg dlg(hWnd);
        if (dlg.DoModal()==IDOK) {
            if (Op_Blend(st->dib, hWnd, dlg.alpha())) {
                OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
                InvalidateRect(hWnd, nullptr, FALSE);
            }
        }
    }
    return 0;
```

---

## | **영상의 논리 연산**

### 개념 요약 (8-bit 채널의 비트 연산)

- **AND**
  \[
  v' = v_A \;\&\; v_B
  \]
  두 영상 모두 1인 비트만 남김 → **마스크 교집합**.

- **OR**
  \[
  v' = v_A \;|\; v_B
  \]
  어느 한 쪽이라도 1인 비트는 1 → **마스크 합집합**.

> 그레이/컬러 모두 “채널별 비트연산”으로 동일하게 적용됩니다. (B/G/R 각각 독립)

---

## | 메뉴 및 이벤트 처리기

### `resource.h` 명령 ID

```cpp
// 산술
#define ID_IMAGE_ADD         41000
#define ID_IMAGE_SUB         41001
#define ID_IMAGE_AVG         41002
#define ID_IMAGE_DIFF        41003
#define ID_IMAGE_BLEND       41004  // 가중 평균 대화상자

// 논리
#define ID_IMAGE_AND         41100
#define ID_IMAGE_OR          41101

```

### `ImageTool.rc` 메뉴에 추가

```rc
POPUP "&Image"
BEGIN
    MENUITEM "Brightness / Contrast...\tCtrl+B",  40200
    MENUITEM "Gamma Correction...\tCtrl+G",       40300
    MENUITEM SEPARATOR
    POPUP "Arithmetic"
    BEGIN
        MENUITEM "Add (A ⊕ B, clamp)",      ID_IMAGE_ADD
        MENUITEM "Subtract (A − B, clamp)", ID_IMAGE_SUB
        MENUITEM "Average (A+B)/2",         ID_IMAGE_AVG
        MENUITEM "Difference |A−B|",        ID_IMAGE_DIFF
        MENUITEM "Blend (A↔B, α)...",       ID_IMAGE_BLEND
    END
    POPUP "Logical"
    BEGIN
        MENUITEM "AND (A & B)",             ID_IMAGE_AND
        MENUITEM "OR  (A | B)",             ID_IMAGE_OR
    END
END

// (선택) 가속기
IDR_ACCEL ACCELERATORS
BEGIN
    "A", ID_IMAGE_ADD, VIRTKEY, CONTROL, SHIFT
    "S", ID_IMAGE_SUB, VIRTKEY, CONTROL, SHIFT
    "D", ID_IMAGE_DIFF, VIRTKEY, CONTROL, SHIFT
    "M", ID_IMAGE_AVG, VIRTKEY, CONTROL, SHIFT   // M=mean
    "L", ID_IMAGE_AND, VIRTKEY, CONTROL, SHIFT   // Logical AND
    "K", ID_IMAGE_OR,  VIRTKEY, CONTROL, SHIFT
END
```

### `main_multiwin.cpp` 핸들러

```cpp
#include "ArithLogicOps.h"

// ...
case ID_IMAGE_ADD:
    if (st && st->dib) {
        if (Op_Add(st->dib, hWnd)) { OutputBasicInfo(st); UpdateStatusBasic(hWnd, st); InvalidateRect(hWnd,nullptr,FALSE); }
    }
    return 0;

case ID_IMAGE_SUB:
    if (st && st->dib) {
        if (Op_Sub(st->dib, hWnd)) { OutputBasicInfo(st); UpdateStatusBasic(hWnd, st); InvalidateRect(hWnd,nullptr,FALSE); }
    }
    return 0;

case ID_IMAGE_AVG:
    if (st && st->dib) {
        if (Op_Avg(st->dib, hWnd)) { OutputBasicInfo(st); UpdateStatusBasic(hWnd, st); InvalidateRect(hWnd,nullptr,FALSE); }
    }
    return 0;

case ID_IMAGE_DIFF:
    if (st && st->dib) {
        if (Op_Diff(st->dib, hWnd)) { OutputBasicInfo(st); UpdateStatusBasic(hWnd, st); InvalidateRect(hWnd,nullptr,FALSE); }
    }
    return 0;

case ID_IMAGE_AND:
    if (st && st->dib) {
        if (Op_And(st->dib, hWnd)) { OutputBasicInfo(st); UpdateStatusBasic(hWnd, st); InvalidateRect(hWnd,nullptr,FALSE); }
    }
    return 0;

case ID_IMAGE_OR:
    if (st && st->dib) {
        if (Op_Or(st->dib, hWnd))  { OutputBasicInfo(st); UpdateStatusBasic(hWnd, st); InvalidateRect(hWnd,nullptr,FALSE); }
    }
    return 0;

case ID_IMAGE_BLEND:
    if (st && st->dib) {
        BlendDlg dlg(hWnd);
        if (dlg.DoModal()==IDOK) {
            if (Op_Blend(st->dib, hWnd, dlg.alpha())) {
                OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
                InvalidateRect(hWnd, nullptr, FALSE);
            }
        }
    }
    return 0;
```

---

## | 실습 팁과 주의점

### 크기/정렬

- 두 영상 크기가 다르면 **겹치는 영역**만 계산 → **남는 부분은 A 그대로**.
- 필요하면 “작은 쪽으로 크롭”/“큰 쪽으로 패드”/“리샘플” 등의 정책을 옵션으로 확장할 수 있습니다.

### 색공간/알파

- 여기서는 **BGRA32의 B/G/R만** 연산, **A는 A(현재 창) 유지**로 단순화했습니다.
- 합성 논리(프리멀티플라이드 알파 등)가 필요하면 `CombineTwoImages_BGRA32()`의 알파 분기에서 구현하세요.

### 데이터형

- 모든 산술은 **int 중간값** 사용 후 **0~255 포화**로 안전.
- 고정소수점(정수 연산)으로도 충분히 빠릅니다.

### 활용 예시

- **Add**: 장노출 합성(정확히는 평균/누적에 더 가깝지만 소량이면 Add+클램프로 근사)
- **Subtract/Diff**: 움직임 검출, 배경 제거, 프레임 간 변경점 시각화
- **Average/Blend**: 노이즈 저감, 다중 노출 합성(가중 평균)
- **AND/OR**: 마스크 결합, 바이너리 영상 처리

---

## | 테스트 시나리오

1) **정적 장면 두 프레임** → `Difference` 로 미세 움직임만 밝아짐 확인
2) **노이즈 많은 사진 두 장** → `Average` 로 노이즈 저감 효과 비교
3) **마스크(0/255)** 와 원본 → `AND` 로 마스킹, `OR` 로 합집합
4) 서로 다른 크기의 이미지 → 겹치는 영역만 변경되는지, 경계 artifact 없는지 확인

---

## | 확장 아이디어

- **XOR, NOT** 추가 (논리 연산 완성)
- **가중치 지도(알파맵)** 를 사용한 **위치 가변 블렌드**
- **정합(Registration)** 후 산술/논리 연산(특히 영상이 어긋나 있을 때)
- **16-bit/Float** 포맷 지원 (IppImage 템플릿으로 확장)
- **GPU 가속**(Direct2D/Compute Shader/OpenCL)로 대용량/실시간 처리

---

## 마무리

- 산술/논리 연산은 **가장 기초적인 영상 결합 도구**입니다.
- 본 구현은 **BGRA32/포화·절대값 처리/겹치는 영역 안전 처리**를 갖춘 실전용 스켈레톤입니다.
- 이후 장에서 이 연산들을 **필터/에지/스텐실**과 결합하면 한층 강력한 파이프라인을 만들 수 있습니다.
