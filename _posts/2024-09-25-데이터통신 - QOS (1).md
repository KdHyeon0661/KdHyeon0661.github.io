---
layout: post
title: 데이터 통신 - QOS (1)
date: 2024-09-25 22:20:23 +0900
category: DataCommunication
---
# Chapter 30. QoS – 데이터 흐름 특성과 QoS 향상을 위한 흐름 제어

---

이 장에서는 **QoS(Quality of Service)**를 두 단계로 나눠서 본다고 생각하면 편합니다.

1. **30.1 Data Flow Characteristics**
   - “어떤 종류의 트래픽이 어떤 품질을 필요로 하는가?”를 정량적으로 정의하고,
   - 애플리케이션이 지연/지터/손실에 얼마나 민감한지에 따라 **Flow Class**를 나눕니다.

2. **30.2 Flow Control to Improve QoS**
   - 실제 네트워크 장비(라우터/스위치)에서 **스케줄링·트래픽 셰이핑·리소스 예약·수락 제어(Admission Control)** 같은 메커니즘으로
     그 QoS 요구사항을 만족시키는 방법을 다룹니다.

---

## Data Flow Characteristics

### Definitions — QoS를 구성하는 기본 지표들

먼저 하나의 **Flow**(흐름)를 정의합니다.

- **Flow**: (송신 IP, 수신 IP, 송신 포트, 수신 포트, 프로토콜 번호, DSCP 등)의 조합으로 구분되는 **동질한 트래픽 집합**
  (예: 어떤 사용자의 Zoom 화상회의 세션, 특정 서버와의 TCP 연결 하나 등)

각 Flow에 대해 네트워크가 제공해야 하는 품질(QoS)을 다음 지표로 기술합니다.

1. **Bandwidth(대역폭)**
   - 단위 시간당 전송 가능한 데이터량 (bps)
   - 예:
     - HD 비디오 스트리밍: 보통 3~5 Mbps 수준
     - 4K 스트리밍: 서비스에 따라 15~25 Mbps 정도 요구

2. **Delay(End-to-End Delay, 지연)**
   - 송신 애플리케이션에서 패킷을 보낸 시점부터 수신 애플리케이션에 도착할 때까지 걸리는 시간
   - 구성 요소:
     - **전파 지연(propagation delay)**: 광섬유/무선 전파가 거리를 따라 이동하는 시간
     - **전송 지연(transmission delay)**: 링크 대역폭에 따라 패킷을 밀어 넣는 시간
       $$\text{Transmission delay} = \frac{\text{Packet size (bits)}}{\text{Link bandwidth (bps)}}$$
     - **처리 지연(processing delay)**: 라우터·스위치에서 헤더 파싱, 룰 적용, 큐 삽입 등
     - **큐잉 지연(queueing delay)**: 혼잡 시 큐에서 기다리는 시간

3. **Jitter(Delay Variation, 지연 변동)**
   - 패킷별 지연이 **얼마나 요동치는지**를 나타냄
   - 음성/영상 같은 실시간 애플리케이션에서는 평균 지연보다 **지터**가 더 문제입니다.
   - 간단한 정의 예:
     $$\text{Jitter} \approx |D_{i} - D_{i-1}|$$
     여기서 \(D_i\)는 i번째 패킷의 지연

4. **Packet Loss(패킷 손실률)**
   - 특정 구간에서 전송한 패킷 중 **손실된 패킷의 비율**
   - 예: 1,000개 중 10개 손실 → 손실률 1%
   - 혼잡, 버퍼 오버플로, 링크 오류, 무선 채널 잡음 등으로 발생

5. **Reliability(신뢰성)**
   - 단순 손실률뿐 아니라 **복구 가능성/복구 지연**까지 고려한 개념
   - 예:
     - TCP: 재전송·흐름 제어·혼잡 제어로 높은 신뢰성
     - UDP: 신뢰성은 애플리케이션 계층에서 별도로 구현해야 함

6. **Availability(가용성)**
   - “이 Flow가 연중 얼마나 자주, 얼마나 오랫동안 원하는 품질로 사용 가능한가”
   - 네트워크 사업자는 보통 **99.9%**, **99.99%** 같은 형식으로 SLA를 정의

#### 간단 예제: 지연·지터·손실을 함께 보는 시나리오

- 한 회사가 미국 동부(뉴욕) ↔ 미국 서부(샌프란시스코) 사이에
  **화상 회의(VoIP + 비디오)**를 한다고 가정합니다.
- 광섬유 왕복 지연(RTT)은 약 60~80 ms 수준입니다(백본 구조에 따라 상이).
- 화상회의 애플리케이션은 다음을 요구한다 가정:
  - 평균 지연: 150 ms 이하
  - 지터: 30 ms 이하
  - 패킷 손실률: 1% 이하
- 네트워크는 이 흐름(Flow)에 대해 위 조건을 만족하도록
  **우선순위, 트래픽 셰이핑, 혼잡 시 드롭 정책** 등을 구성해야 합니다.

이제 이런 특성에 따라 애플리케이션이 얼마나 민감한지를 분류합니다.

---

### Sensitivity of Applications — 어떤 앱이 무엇에 민감한가

애플리케이션은 크게 **Elastic(탄력적)** vs **Inelastic(비탄력적)** 으로 나누어 볼 수 있습니다.

- **Elastic 트래픽**
  - 지연이 조금 늘어나도, 손실이 약간 발생해도 **재전송·버퍼링으로 복구 가능**
  - 예: 파일 다운로드(HTTP/FTP), 이메일, 백업, 소프트웨어 업데이트
- **Inelastic 트래픽**
  - 지연·지터·손실에 매우 민감하며, 재전송을 해도 **시점이 지나면 의미가 없어짐**
  - 예: VoIP, 화상회의, 온라인 게임, 공장 제어(산업용 제어 트래픽)

애플리케이션별로 어떤 QoS 지표에 민감한지 표로 정리해보면:

| 애플리케이션 유형 | 예시 | 지연 민감도 | 지터 민감도 | 손실 민감도 | 전형적인 프로토콜 |
|------------------|------|-------------|-------------|-------------|--------------------|
| 파일 전송        | FTP, HTTP 다운로드 | 낮음 | 낮음 | 높음 (1bit도 틀리면 문제) | TCP |
| 웹 브라우징     | HTTP(S) 페이지 | 중간 | 낮음 | 중간 (재전송으로 회복) | TCP |
| 이메일          | SMTP/IMAP/POP | 낮음 | 낮음 | 매우 높음 (손실 불가) | TCP |
| VoIP 음성       | Zoom/Teams 음성 | 높음 (150ms 이상 체감) | 높음 | 중간 (약간의 손실 허용) | RTP/UDP + FEC |
| 실시간 영상      | 화상회의 | 매우 높음 | 매우 높음 | 중간 | RTP/UDP, QUIC 등 |
| 스트리밍 VOD     | Netflix, YouTube | 중간 (버퍼로 숨김) | 낮음 | 낮음~중간 | TCP/QUIC, DASH/HLS |
| 온라인 게임      | FPS, MOBA | 매우 높음 | 매우 높음 | 중간 | UDP 기반 프로토콜 |
| 산업 제어/SCADA | 공장 장비 제어 | 매우 높음 | 매우 높음 | 매우 높음 | 전용 실시간 프로토콜 |

이 표를 기반으로, 네트워크 설계자는 각 애플리케이션에 맞는 **클래스**(Flow Class)를 정의합니다.

---

### Flow Classes — 서비스 클래스 / 트래픽 클래스

IETF에서는 DiffServ 기반 QoS를 위해 몇 가지 대표적인 서비스 클래스를 정의해 놓고,
각각의 클래스에 맞게 트래픽을 분류/표시(마킹)하도록 권고합니다.

대표적인 클래스 개념을 조금 단순화해서 정리하면:

1. **Default / Best Effort Class (DF)**
   - 별도의 QoS 보장을 하지 않는 일반 트래픽
   - 웹, 이메일, 파일 다운로드 등 **Elastic 트래픽** 대부분이 여기에 속함
   - 지연·지터·손실에 대해 특별한 약속 없음

2. **Assured Forwarding (AF) Classes**
   - “가능하면 버리지 않고 전달하려는” **보증형 트래픽**
   - 예: 기업용 트랜잭션, 중요한 비즈니스 애플리케이션, 중요한 백엔드 API 트래픽 등
   - 혼잡 시에도 특정 우선순위를 유지해, **손실을 상대적으로 줄이는 것**에 초점

3. **Expedited Forwarding (EF) Class**
   - VoIP나 실시간 제어처럼 **지연·지터가 아주 작은 경로로 빠르게 전달해야 하는 트래픽**
   - EF 클래스에 들어온 패킷은 **작은 대기 큐, 엄격한 우선순위 스케줄링**을 통해 매우 빠르게 전달되도록 설계

이러한 클래스는 실제로는 **IP 헤더의 DSCP 필드**에 값(코드포인트)을 설정해 구분합니다.
예: EF 트래픽에 특정 DSCP 값, AF에 다른 DSCP 값 등.

#### 간단 예제: 사내 네트워크 Flow Class 설계

어떤 회사가 다음 네 가지 흐름 클래스를 정의했다고 가정합니다.

1. **Class 1 – Real-Time Voice/Video (EF)**
   - 줌/팀즈 회의, VoIP 콜
   - 요구사항: 평균 지연 < 100 ms, 지터 < 20 ms, 손실 < 1%

2. **Class 2 – Critical Business Apps (AF)**
   - ERP, DB 트랜잭션, 결제 시스템 등
   - 요구사항: 손실률 < 0.1%, 지연 < 200 ms

3. **Class 3 – Normal Applications (DF)**
   - 일반 웹, 이메일, 파일 다운로드

4. **Class 4 – Background / Bulk Transfer**
   - 백업, 대용량 로그 업로드, 배치 작업
   - 남는 대역폭을 활용 (우선순위 가장 낮음)

네트워크 관리자는 라우터/스위치에서 다음과 같이 정책을 설정합니다.

- IP/포트/URL 등의 조건으로 패킷을 분류 → DSCP/클래스 부여
- 각 클래스별 큐, 스케줄링 방식, 셰이핑 파라미터 설정
- 혼잡 시에는 Class 4부터 드롭, Class 1은 끝까지 보호

이렇게 **Flow Class를 먼저 설계**해두고,
다음 섹션의 **스케줄링·트래픽 셰이핑·리소스 예약**을 통해 실제로 QoS를 구현합니다.

---

## Flow Control to Improve QoS

QoS를 실제로 구현하는 네트워크 장비 입장에서 보면, 주요 도구는 다음 네 가지입니다.

1. **Scheduling**: 어떤 패킷을 먼저 내보낼지 결정
2. **Traffic Shaping / Policing**: 트래픽 속도와 버스트를 제한
3. **Resource Reservation**: 애초에 Flow에 쓸 수 있는 리소스를 확보해두는 것
4. **Admission Control**: 네트워크가 감당할 수 없으면 **새로운 흐름을 거절**

이 네 가지는 서로 결합해서 동작합니다.

---

### Scheduling — 큐에서 누구를 먼저 보낼 것인가

**Scheduling**은 라우터/스위치의 출력 포트에 있는 여러 큐에서
**어느 큐의 패킷을 어떤 순서로 내보낼지**를 결정하는 알고리즘입니다.

대표적인 알고리즘 몇 개를 통해 감을 잡아보겠습니다.

#### FIFO (First-In First-Out)

- 가장 단순한 방식: 먼저 들어온 패킷을 먼저 내보냄
- QoS 측면에서는 **모든 트래픽이 동일하게 취급**되므로
  실시간 트래픽과 백그라운드 트래픽이 섞여 있으면 문제가 됩니다.

장점:
- 구현이 매우 간단, 처리 비용 낮음

단점:
- 지연·지터에 민감한 트래픽을 보호하지 못함

#### Priority Queuing (PQ, 우선순위 큐)

- 여러 개의 큐를 두고, **우선순위 높은 큐부터 항상 먼저 처리**
- 보통:
  - High Priority: EF (음성/영상)
  - Medium: AF (중요 비즈니스 트래픽)
  - Low: DF, Background

간단한 동작 예:

1. 출력 포트에 High/Mid/Low 세 개 큐가 있음
2. 스케줄러는 항상 High 큐를 먼저 확인
   - 비어 있으면 Mid 큐, 그것도 비어 있으면 Low 큐
3. 혼잡 시 Low 큐는 거의 기회를 받지 못할 수 있음(Starvation)

장점:
- 고우선순위 트래픽에 **매우 낮은 지연** 제공

단점:
- 우선순위가 낮은 트래픽은 **영원히 서비스 못 받을 위험(기아, starvation)**

#### Weighted Fair Queuing (WFQ)

- 각 흐름(또는 클래스)에 **가중치(Weight)**를 부여하고, 가중치에 비례해 공평하게 대역폭을 나눔
- 직관적 비유:
  - Class 1(VoIP): Weight 4
  - Class 2(중요 앱): Weight 2
  - Class 3/4: Weight 1
- 전체를 한 사이클로 보면,
  Class 1이 4번, Class 2가 2번, Class 3이 1번, Class 4가 1번씩 **전송 기회**를 얻는 구조

중요 포인트:
- **지연과 대역폭**을 동시에 어느 정도 보장
- 개별 Flow가 과도하게 큐를 점유하지 못하도록 제어

아주 단순화한 WFQ 스타일 스케줄링 의사코드는 예를 들면 다음과 같습니다.

```python
# 매우 단순화된 WFQ 스타일 스케줄러 (실제 WFQ는 더 복잡한 가상시간 개념 사용)

queues = {
    "EF": [],   # 실시간
    "AF": [],   # 중요 비즈니스
    "BE": [],   # 기본
}

weights = {
    "EF": 4,
    "AF": 2,
    "BE": 1,
}

def wfq_schedule_one_round():
    sent_packets = []
    for class_name, w in weights.items():
        for _ in range(w):
            if queues[class_name]:
                pkt = queues[class_name].pop(0)
                sent_packets.append(pkt)
    return sent_packets
```

현실의 WFQ는 **패킷 길이까지 고려해 “가상 종료 시각”을 기반으로 순서를 결정**하지만,
개념적으로는 “각 클래스에 비례적 전송 기회 부여”라는 점이 핵심입니다.

#### Deficit Round Robin (DRR)

- WFQ의 아이디어를 단순화해서 구현한 라운드 로빈 기반 방식
- 각 큐에 **Deficit Counter(부족분 카운터)**를 두고,
  매 라운드마다 큐별로 **정해진 양의 크레딧(Quantum)**을 더해주며
  그 크레딧 안에서만 패킷을 내보냅니다.
- 패킷을 못 보냈다면 크레딧이 쌓여 다음 라운드에 더 많이 보낼 수 있음

장점:
- WFQ에 근접한 공정성을 제공하면서 구현이 간단
- 다양한 패킷 길이를 효율적으로 처리 가능

---

### Traffic Shaping or Policing — 트래픽 속도와 버스트 제어

**Traffic Shaping(셰이핑)**과 **Policing(폴리싱)**은
입력되는 트래픽의 **속도와 버스트를 네트워크가 감당할 수 있는 범위 내로 맞추는 작업**입니다.

- **Shaping**: 버스트가 들어오면 **버퍼에 잠시 저장했다가** 일정 속도로 내보냄
- **Policing**: 버스트가 계약된 속도를 넘으면 **버리거나 마킹**해버림

핵심 알고리즘은 **Leaky Bucket**과 **Token Bucket**입니다.

#### Leaky Bucket (구멍 난 양동이)

- 비유: 양동이에 물(패킷)이 들어오지만,
  양동이 바닥의 작은 구멍으로 **일정 속도**로만 물이 빠져나감.
- 패킷이 너무 빠른 속도로 많이 들어오면 양동이(버퍼)가 넘쳐 **패킷이 버려짐**.

특징:
- 출력 트래픽을 **거의 일정한 속도**로 만듦 → 버스트가 제거됨
- 너무 딱딱해서, Real-Time 트래픽에는 적합하지만
  약간의 버스트를 허용해야 하는 데이터 트래픽에는 다소 비효율적일 수 있음

#### Token Bucket (토큰 버킷) — 실무 표준 모델

- 비유: 버킷 안에 **토큰(token)**이 생기고, 패킷 하나를 내보낼 때마다
  그 패킷 길이에 비례해서 토큰을 소비해야 함.
- 토큰은 **평균 속도(CIR, Committed Information Rate)**에 따라 일정하게 채워짐.
- 버킷에는 최대 **버스트 크기(Burst Size)**만큼 토큰이 쌓일 수 있음.

수식(단순 모델):

- 토큰 생성 속도: \(r\) [bits/s]
- 버킷 크기: \(B\) [bits]
- 어떤 시점에 버킷에 토큰이 \(T\) 개 있다면,
  길이 \(L\) [bits]인 패킷은 \(T \ge L\)일 때만 전송 가능.
  전송 후 토큰은 \(T \leftarrow T - L\)
- 시간이 \(\Delta t\) 지난 후에는
  $$T \leftarrow \min(B, T + r\Delta t)$$

이 모델을 실제 DiffServ 트래픽 조건자에서 **단일 속도 3색 마커(srTCM)**,
**이중 속도 3색 마커(trTCM)** 같은 형태로 확장해 사용합니다.

##### 예제 시나리오: VoIP 셰이핑

- 회사 게이트웨이에서 VoIP 트래픽을 다음과 같이 계약했다고 가정:
  - 평균 2 Mbps, 버스트 200 KB
- Token Bucket 파라미터:
  - \(r = 2 \text{ Mbps} = 2,000,000 \text{ bits/s}\)
  - \(B = 200 \text{ KB} = 1,600,000 \text{ bits}\)
- 일정 시간 동안 버스트를 허용하지만,
  평균적으로는 2 Mbps를 넘지 않게 셰이핑할 수 있음.

#### Shaping vs Policing의 차이

- Shaping:
  - 오버 트래픽을 **버퍼에 저장**하고 스케줄링을 통해 천천히 내보냄
  - 지연이 증가하지만 손실을 줄일 수 있음
- Policing:
  - 오버 트래픽은 그냥 **드롭**하거나 **DSCP를 낮게 마킹**해서 네트워크 안에서 손실되게 만듦
  - 지연은 늘리지 않지만, 패킷 손실 가능성이 커짐

실제 네트워크에서는 **Ingress(입구)에서 Policing**,
**Egress(출구)에서 Shaping**을 조합하는 경우가 많습니다.

---

### Resource Reservation — 리소스를 먼저 떼어놓기

**Resource Reservation(리소스 예약)**은 특정 Flow에 대해
**대역폭·버퍼·처리 용량을 미리 확보해 두고**
새로운 Flow에게는 남은 리소스가 충분할 때만 서비스하게 하는 개념입니다.

IETF의 **IntServ(Integrated Services)**/RSVP(Resource Reservation Protocol)는
리소스 예약 기반 QoS의 대표적인 모델입니다.

#### IntServ + RSVP 개념

- 각 플로우(예: VoIP 세션)에 대해:
  1. **송신자가 Flow Spec(필요 대역폭, 지연 등)을 포함한 요청**을 보냄
  2. 중간 라우터들이 이 요청을 보고
     자신이 가진 리소스(링크 대역폭, 큐, CPU)가 충분한지 검사
  3. 모두 OK면 리소스를 예약하고 “승인(RESV)” 메시지를 돌려줌
  4. 이후 데이터 패킷은 **예약된 리소스 안에서** QoS를 보장받으며 전송

장점:
- Flow 단위로 **정교한 QoS 보장** 가능
- 예를 들어 128 kbps 오디오 스트림에 대해 네트워크 전체 경로에서
  정확히 그만큼의 리소스를 확보

단점:
- Flow 수가 많을 때 **라우터 상태(state)가 폭발** → 대규모 인터넷 전체에는 부적합
- 오늘날에는 **백본 전체에는 DiffServ, 특정 구간에는 IntServ/RSVP**를 혼합 사용하는 식으로 진화

#### 예제 시나리오: 기업 전용선에서의 RSVP

- 본사 ↔ 지사 간 MPLS 전용선이 있고, 지사에서 본사 VoIP 서버로
  100개의 동시 통화를 지원해야 한다고 가정
- 각 통화당 64 kbps(코덱 + 헤더 오버헤드 포함 80 kbps로 잡자) 필요
- 총 필요 대역폭:
  $$100 \times 80 \text{ kbps} = 8 \text{ Mbps}$$
- 회선 대역폭이 20 Mbps라면,
  RSVP로 VoIP 클래스에 대해 8 Mbps를 예약해놓고
  나머지 12 Mbps에는 Best Effort 트래픽만 받도록 구성할 수 있음.

이 때 DiffServ와 결합하면:

- RSVP로 예약된 트래픽을 EF 클래스에 매핑
- EF 클래스는 스케줄링에서 Strict Priority 또는 높은 Weight를 부여
- 토큰 버킷 셰이핑으로 VoIP 트래픽이 다른 클래스에 영향을 주지 않도록 제한

---

### Admission Control — 감당할 수 없으면 받지 않는다

**Admission Control(수락 제어)**는 말 그대로
“새로운 Flow를 받아줄지 말지 결정하는 정책”입니다.

- 리소스 예약이 없다면,
  - 모든 트래픽을 받아들였다가 혼잡이 심해지면 전체 QoS가 무너짐
- Admission Control이 있다면,
  - 네트워크가 감당할 수 없는 요청은 **처음부터 거절**해서
    기존 Flow의 QoS를 지켜줄 수 있음

#### 단순 Admission Control 규칙 예

- VoIP 클래스에 대해:
  - 예약된 용량: 8 Mbps
  - 현재까지 예약된 대역폭: 7 Mbps
  - 새로운 통화 요청 한 개: 80 kbps 필요
  - 남은 여유: 1 Mbps → 80 kbps 충분 → **허용**
- 어떤 시점에 요청이 들어왔는데:
  - 현재까지 7.9 Mbps 사용 중
  - 새로운 통화 3개(총 240 kbps 필요) 요청
  - 여유(100 kbps)가 부족 → 3개 중 일부 또는 전부 **거절**

이 로직은 다음과 같은 의사코드로 표현할 수 있습니다.

```python
MAX_VOIP_BW = 8_000_000   # 8 Mbps
current_reserved = 7_900_000  # 현재 7.9 Mbps 예약됨
NEW_CALL_BW = 80_000      # 한 통화당 80 kbps

def can_accept_new_calls(n_calls):
    required = n_calls * NEW_CALL_BW
    return (current_reserved + required) <= MAX_VOIP_BW

print(can_accept_new_calls(1))  # False
print(can_accept_new_calls(3))  # False
```

실제 장비에서는 이보다 훨씬 정교한 기준(지연, 버퍼 사용량, 링크 상태 등)을 쓰지만,
핵심은 “**새로운 세션 수락 여부를 QoS 관점에서 결정**”한다는 점입니다.

#### Admission Control과 사용자 경험

- 사용자가 화상회의를 하려는데, 네트워크가 과부하에 가까운 경우:
  - 아무 제어도 없으면 → 모든 참가자가 동시에 품질 저하(끊김, 지터, 패킷 손실)
  - Admission Control이 있다면 →
    **일부 사용자가 ‘지금은 접속 불가’ 메시지를 받고**,
    나머지 사용자들은 안정적인 품질로 회의를 진행
- 서비스 사업자 입장에서는 “모든 사용자에게 조금씩 나쁜 품질”보다
  “일부만 거절하고 나머지에게 좋은 품질”을 제공하는 것이
  더 나은 고객 경험일 때가 많습니다.

---

## 정리

- **30.1 Data Flow Characteristics**에서는
  - Flow에 대해 **대역폭·지연·지터·손실·신뢰성·가용성** 같은 지표를 정의하고,
  - 애플리케이션이 어떤 지표에 민감한지에 따라
    **Elastic / Inelastic**, **EF/AF/DF** 등 **Flow Class**를 설계하는 과정을 살펴봤습니다.

- **30.2 Flow Control to Improve QoS**에서는
  - **Scheduling(FIFO, PQ, WFQ, DRR)** 을 통해 어떤 패킷을 먼저 보낼지 결정하고,
  - **Traffic Shaping/Policing(Leaky Bucket, Token Bucket)** 으로 속도와 버스트를 제어하며,
  - **Resource Reservation(IntServ/RSVP)** 로 플로우별 리소스를 미리 확보하고,
  - **Admission Control** 로 네트워크가 감당할 수 없는 요청은 처음부터 거절하여
    기존 Flow의 QoS를 지키는 방법을 살펴봤습니다.

이 내용 위에, 다음 장들에서 다룰 **DiffServ, MPLS, 실무 장비 설정 예** 등을 덧붙이면
블로그에서 **이론 ↔ 실전 QoS 구성**이 자연스럽게 이어질 수 있습니다.
