---
layout: post
title: MFC - 메시지 루프 & 메시지 맵
date: 2025-08-20 22:25:23 +0900
category: MFC
---
# 메시지 루프 & 메시지 맵 · 대화상자(Dialog) 앱 구조 완전 가이드

이 글은 **MFC의 메시지 처리 핵심(메시지 루프/메시지 맵/명령 라우팅)**과 **대화상자 기반 앱 구조(모달·모델리스, DDX/DDV, 리소스 에디터 사용)**를 한 번에 정리합니다. 따라 하기용 **짧은 코드 스니펫**을 포함했어요.

---

## 1) 메시지 루프(Message Loop)와 메시지 맵(Message Map)

### 1-1. 메시지 루프란?
윈도우 프로그램은 OS가 전달하는 `WM_*` 메시지를 **루프**에서 꺼내 처리합니다. MFC는 `CWinThread::Run()`에 **표준 메시지 루프 + idle 처리**를 캡슐화해 둡니다.

```cpp
// (개념) MFC의 메시지 루프 요약
int CWinThread::Run() {
    MSG msg;
    for (;;) {
        // 메시지가 있으면 Pump, 없으면 Idle
        if (!::PeekMessage(&msg, nullptr, 0, 0, PM_NOREMOVE)) {
            if (!OnIdle(0)) continue;   // Idle 처리(화면 갱신, UI 업데이트 등)
        }
        if (!PumpMessage()) break;      // WM_QUIT => 루프 종료
    }
    return ExitInstance();
}
```

**중요 포인트**
- **가속기(단축키) 처리**: 루프 안에서 `TranslateAccelerator`가 호출되어 메뉴/툴바 단축키가 명령으로 변환됩니다.
- **IsDialogMessage**: 대화상자에 포커스가 있을 때 **Tab 이동/기본 버튼** 처리가 자동으로 이뤄집니다.
- **OnIdle**: 빈 시간에 UI 업데이트(예: `ON_UPDATE_COMMAND_UI`)가 호출됩니다.

### 1-2. 메시지 맵이란?
Win32의 `WndProc` `switch` 분기를 **클래스 멤버 함수**로 연결하는 MFC의 매크로 라우팅입니다.

```cpp
class CMainDlg : public CDialogEx {
public:
    CMainDlg() : CDialogEx(IDD_MAIN) {}
protected:
    afx_msg void OnPaint();
    afx_msg void OnTimer(UINT_PTR id);
    afx_msg void OnBnClickedOk();
    DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_WM_PAINT()                    // WM_PAINT → OnPaint
    ON_WM_TIMER()                    // WM_TIMER → OnTimer
    ON_BN_CLICKED(IDOK, OnBnClickedOk) // 버튼(IDOK) 클릭 → OnBnClickedOk
END_MESSAGE_MAP()
```

- `ON_WM_XXX()` : `WM_PAINT`, `WM_SIZE`, `WM_TIMER` 등 **윈도우 메시지**를 핸들러에 매핑
- `ON_COMMAND(id, ...)` : 메뉴/툴바/버튼 등 **명령(=WM_COMMAND)** 처리
- `ON_NOTIFY(...)` : 공용 컨트롤(트리/리스트)의 **통지 메시지(NM_*)** 처리
- `ON_UPDATE_COMMAND_UI(id, ...)` : 메뉴/툴바 **활성/체크/텍스트** 갱신

### 1-3. 명령 라우팅 흐름(Command Routing)
명령(메뉴/툴바/버튼)은 다음 순서로 **핸들러를 탐색**합니다.

- **Doc/View/Frame 앱(SDI/MDI)**  
  1) 활성 **CView** → 2) **CFrameWnd** → 3) **CDocument** → 4) **CWinApp**  
  (동일 순서로 `ON_UPDATE_COMMAND_UI`도 호출)
- **Dialog 기반 앱**  
  1) **CDialog**(현재 대화상자) → 2) **부모/소유자** → 3) **CWinApp**

> 왜 중요할까? — 핸들러를 **어디에 넣어야 할지** 결정하는 기준입니다. 예컨대 **문서 데이터 조작**은 `CDocument`, **표시/편집**은 `CView`, **전역 동작**은 `CWinApp`이 자연스럽습니다.

### 1-4. PreTranslateMessage로 세밀 제어
특정 키를 가로채거나, 가속기를 직접 처리하고 싶을 때 `PreTranslateMessage`를 씁니다.

```cpp
BOOL CMainDlg::PreTranslateMessage(MSG* pMsg) {
    if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE) {
        // ESC로 닫지 못하게 막기
        return TRUE; // 처리 완료: 더 이상 전달하지 않음
    }
    return CDialogEx::PreTranslateMessage(pMsg);
}
```

---

## 2) 대화상자(Dialog) 앱 구조

### 2-1. 모달 vs 모델리스
- **모달(Modal)**: `DoModal()`이 **반환될 때까지** 호출자(메인 루프)가 **블록**. 설정/알림창에 적합.
- **모델리스(Modeless)**: `Create()` + `ShowWindow()`. 앱과 **동시에 상호작용** 가능. 툴 윈도우/독립 패널에 적합.

```cpp
// 모달
CConfigDlg dlg; 
if (dlg.DoModal() == IDOK) { /* 설정 반영 */ }

// 모델리스
auto pAbout = new CAboutDlg;
pAbout->Create(IDD_ABOUT, this);
pAbout->ShowWindow(SW_SHOW);

// 모델리스의 안전한 수명 관리
void CAboutDlg::PostNcDestroy() { delete this; }  // DestroyWindow 후 delete
```

**닫기 처리**
- 모달: `OnOK()/OnCancel()` → `EndDialog(IDOK/IDCANCEL)`
- 모델리스: `OnOK()/OnCancel()` → `DestroyWindow()` → `PostNcDestroy()`에서 `delete this`

### 2-2. OK/Cancel 기본 동작과 키
- 리소스에서 **IDOK/IDCANCEL** 버튼을 쓰면 **Enter/ESC**에 매핑됩니다.
- 기본 동작을 막거나 수정하려면 `OnOK/OnCancel`을 **오버라이드** 하세요.

```cpp
void CMainDlg::OnOK() {
    // 1) 데이터 검증 성공 시에만 닫기
    if (!UpdateData(TRUE)) return; // DDX/DDV 실행, 실패 시 자동 메시지 + 포커스 이동
    // TODO: 저장/적용 로직
    CDialogEx::OnOK(); // EndDialog(IDOK)
}

void CMainDlg::OnCancel() {
    // ESC로 닫히는 것 차단 예시
    if (AfxMessageBox(_T("정말 닫을까요?"), MB_YESNO) == IDNO) return;
    CDialogEx::OnCancel();
}
```

### 2-3. DDX/DDV: 데이터 바인딩 & 검증
- **DDX (Dialog Data eXchange)**: 컨트롤 ↔ 멤버 변수 **바인딩**
- **DDV (Dialog Data Validation)**: 값 범위/형식 **검증**

**절차**
1) `DoDataExchange` 오버라이드에서 `DDX_*/DDV_*` 매핑  
2) `UpdateData(TRUE)` → 컨트롤 → 멤버로 **전송 + 검증**  
   `UpdateData(FALSE)` → 멤버 → 컨트롤로 **반영**

```cpp
// 리소스: IDC_EDIT_NAME, IDC_EDIT_AGE
class CMainDlg : public CDialogEx {
public:
    CString m_name;
    int     m_age = 20;
    CEdit   m_editName;

protected:
    virtual void DoDataExchange(CDataExchange* pDX) {
        CDialogEx::DoDataExchange(pDX);
        DDX_Control(pDX, IDC_EDIT_NAME, m_editName); // CEdit 핸들 얻기
        DDX_Text(pDX, IDC_EDIT_NAME, m_name);        // 문자열 바인딩
        DDX_Text(pDX, IDC_EDIT_AGE,  m_age);         // 정수 바인딩
        DDV_MinMaxInt(pDX, m_age, 1, 120);           // 나이 1~120 검증
        // 커스텀 검증(아래 함수 예시)
        DDV_RequireNonEmpty(pDX, m_name);
    }

    // 커스텀 DDV: 공백 금지
    static void DDV_RequireNonEmpty(CDataExchange* pDX, const CString& s) {
        if (pDX->m_bSaveAndValidate && s.Trim().IsEmpty()) {
            AfxMessageBox(_T("이름을 입력하세요."));
            pDX->Fail(); // 포커스와 선택을 문제 컨트롤로 복귀
        }
    }

    afx_msg void OnBnClickedOk() {
        if (!UpdateData(TRUE)) return; // 검증 실패 시 닫지 않음
        AfxMessageBox(_T("저장되었습니다."));
        CDialogEx::OnOK();
    }

    DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_BN_CLICKED(IDOK, &CMainDlg::OnBnClickedOk)
END_MESSAGE_MAP()
```

> 팁  
> - `UpdateData(TRUE)`는 **비싼 연산**입니다. 타이머/스크롤 등 **고빈도 이벤트**에서는 남용하지 마세요.  
> - 실시간 검증은 `EN_CHANGE`/`LVN_ITEMCHANGED` 같은 통지에서 **부분 검증**을 수행하고, 최종 저장 시 **DDV**로 마무리하는 패턴이 깔끔합니다.

### 2-4. 리소스 에디터 사용 핵심
- **대화상자 ID**: `IDD_...` (예: `IDD_MAIN`)  
- **컨트롤 ID**: `IDC_...` (예: `IDC_EDIT_NAME`)  
- **중복주의**: `IDC_STATIC`은 **공용 ID**라 데이터를 바인딩하지 않습니다. 바인딩하려면 **새 ID**를 부여하세요.
- **탭 순서**: 컨트롤에 `WS_TABSTOP` 설정, **Tab Order**를 올바르게 배치
- **기본 버튼**: `Default Button` 속성(Enter 키 대응)  
- **레이아웃**: 순정 MFC는 자동 앵커가 없습니다. `OnSize`에서 수동으로 **MoveWindow/SetWindowPos** 하거나 서드파티 레이아웃 클래스를 사용합니다.
- **DPI**: 매니페스트에서 `PerMonitorV2` 설정 검토(고해상도 환경에서 글자 잘림 방지)

### 2-5. 최소 대화상자 앱 골격
```cpp
// App 클래스
class CMyApp : public CWinApp {
public:
    BOOL InitInstance() override {
        CWinApp::InitInstance();
        CMainDlg dlg;
        m_pMainWnd = &dlg;
        dlg.DoModal();   // 모달 대화상자 실행
        return FALSE;    // 대화상자 종료 후 앱 종료
    }
} theApp;

// Dialog 클래스 (위 DDX/DDV 예시 재사용)
```

---

## 3) 자주 쓰는 ON_WM_XXX 핸들러 튜토리얼

```cpp
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_WM_TIMER()                    // 1초마다 시계 갱신
    ON_WM_PAINT()                    // 사용자 정의 그리기
    ON_BN_CLICKED(IDC_BTN_START, OnStart)
END_MESSAGE_MAP()

void CMainDlg::OnTimer(UINT_PTR id) {
    if (id == 1) {
        CTime t = CTime::GetCurrentTime();
        SetDlgItemText(IDC_STATIC_CLOCK, t.Format(_T("%H:%M:%S")));
    }
}

BOOL CMainDlg::OnInitDialog() {
    CDialogEx::OnInitDialog();
    SetTimer(1, 1000, nullptr); // 1초 타이머
    return TRUE;
}

void CMainDlg::OnPaint() {
    CPaintDC dc(this);
    CRect rc; GetClientRect(&rc);
    dc.DrawText(_T("Hello, MFC!"), -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
}
```

---

## 4) 대화상자에서의 UI 업데이트(ON_UPDATE_COMMAND_UI)
`ON_UPDATE_COMMAND_UI`는 기본적으로 **Frame 기반**에서 잘 동작합니다. **Dialog**에서는 **Idle 시점**에 `UpdateDialogControls(this, FALSE)`를 호출해야 합니다.

```cpp
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_UPDATE_COMMAND_UI(IDC_BTN_SAVE, OnUpdateBtnSave)
END_MESSAGE_MAP()

void CMainDlg::OnUpdateBtnSave(CCmdUI* pCmdUI) {
    // 저장 가능한 상태인지 활성화/비활성화
    pCmdUI->Enable(!m_name.Trim().IsEmpty());
}

// Idle에 UI 업데이트 트리거 (간단 예시)
BOOL CMainDlg::OnInitDialog() {
    CDialogEx::OnInitDialog();
    // ... 초기화 ...
    return TRUE;
}

BOOL CMainDlg::PreTranslateMessage(MSG* pMsg) {
    // 매우 잦은 호출이므로 과도한 연산 금지
    UpdateDialogControls(this, FALSE);
    return CDialogEx::PreTranslateMessage(pMsg);
}
```

> **주의**: `PreTranslateMessage`에서의 호출은 **자주** 실행됩니다. 복잡한 로직은 피하거나, 타이머/상태 변화 시 **명시적으로 한 번만** 호출하는 구조가 성능상 더 좋습니다.

---

## 5) 모델리스 추가 패널 패턴(도구창)
모델리스 창/패널을 안전하게 관리하는 표준 패턴입니다.

```cpp
class CToolPane : public CDialogEx {
public:
    CToolPane() : CDialogEx(IDD_TOOLPANE) {}
    void PostNcDestroy() override { delete this; } // DestroyWindow 후 delete
};

// 메인 대화상자에서 띄우기
void CMainDlg::OnBnClickedShowPane() {
    if (!m_pPane) {
        m_pPane = new CToolPane;
        m_pPane->Create(IDD_TOOLPANE, this);
    }
    m_pPane->ShowWindow(SW_SHOW);
}
```

---

## 6) 체크리스트 (실무 팁)
- **명령 라우팅**: 핸들러를 **역할에 맞는 클래스**에 배치(뷰=표시, 도큐먼트=데이터)
- **DDX/DDV**: 최종 저장 시 `UpdateData(TRUE)` / 초기화 시 `UpdateData(FALSE)`
- **Enter/ESC 커스터마이징**: `OnOK/OnCancel` 오버라이드 또는 `PreTranslateMessage`
- **리소스 ID 관리**: 데이터 바인딩 컨트롤은 `IDC_STATIC` 사용 금지
- **DPI/레이아웃**: `OnSize`에서 위치 조정, 고해상도 테스트 필수
- **Idle 업데이트**: Dialog에서는 `UpdateDialogControls` 호출 위치/빈도 주의
