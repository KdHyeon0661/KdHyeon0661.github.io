---
layout: post
title: MFC - 메시지 루프 & 메시지 맵
date: 2025-08-20 22:25:23 +0900
category: MFC
---
# 앱 구조 완전 가이드 (실전 스니펫 포함)

이 글은 **MFC의 메시지 처리 핵심(메시지 루프/메시지 맵/명령 라우팅)**과 **대화상자 기반 앱 구조(모달·모델리스, DDX/DDV, 리소스 에디터, 메시지 반사, 고급 팁)**를 한 번에 정리합니다.
본문은 개념 → 베스트 프랙티스 → **짧은 코드 스니펫** 순으로 구성합니다. (코드는 모두 ```로 감쌉니다)

---

## 메시지 루프(Message Loop)와 메시지 맵(Message Map)

### 1-1. 메시지 루프란?

Windows는 입력/화면/시스템 이벤트를 **메시지(`WM_*`)**로 보냅니다. 애플리케이션은 **메시지 큐**에서 꺼내 처리합니다.
MFC는 `CWinThread::Run()`으로 **표준 루프 + Idle 처리**를 캡슐화합니다.

```cpp
// (개념 요약) MFC 메시지 루프
int CWinThread::Run() {
    MSG msg;
    for (;;) {
        if (!::PeekMessage(&msg, nullptr, 0, 0, PM_NOREMOVE)) {
            // 메시지가 없을 땐 Idle 처리(메뉴/툴바 상태 갱신 등)
            if (!OnIdle(0)) continue;
        }
        if (!PumpMessage()) break;  // WM_QUIT 이면 false → 루프 종료
    }
    return ExitInstance();
}
```

**핵심 포인트**
- **가속기(Accelerator)**: 내부에서 `TranslateAccelerator`가 호출되어 **단축키 → 명령 ID**로 변환됩니다.
- **IsDialogMessage**: 포커스가 **대화상자**에 있으면 Tab/Enter/ESC 등의 **표준 키**를 자동 처리합니다.
- **OnIdle**: Idle 시 **`ON_UPDATE_COMMAND_UI`** 호출(메뉴/툴바 활성/체크/텍스트 갱신).

### 1-2. 메시지 맵(Message Map)

Win32 `WndProc`의 `switch` 분기를 **클래스 멤버 함수와 매핑**하는 MFC의 매크로 시스템.

```cpp
class CMainDlg : public CDialogEx {
public:
    CMainDlg() : CDialogEx(IDD_MAIN) {}
protected:
    afx_msg void OnPaint();
    afx_msg void OnTimer(UINT_PTR id);
    afx_msg void OnBnClickedOk();
    DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_WM_PAINT()                               // WM_PAINT → OnPaint
    ON_WM_TIMER()                               // WM_TIMER → OnTimer
    ON_BN_CLICKED(IDOK, &CMainDlg::OnBnClickedOk) // 버튼(IDOK) 클릭
END_MESSAGE_MAP()
```

**주요 매핑 계열**
- `ON_WM_XXX()` : 창 크기/그리기/마우스/키 등 **윈도우 메시지**
- `ON_COMMAND(id, fn)` : 메뉴/툴바/버튼 등 **명령(WM_COMMAND)**
- `ON_NOTIFY(code, id, fn)` : 공용 컨트롤의 **통지(NM_*)**
- `ON_UPDATE_COMMAND_UI(id, fn)` : **메뉴/툴바 상태 갱신**
- `ON_MESSAGE(msg, fn)` : 사용자 정의 **윈도우 메시지**
- `ON_REGISTERED_MESSAGE(msg, fn)` : **RegisterWindowMessage** 사용 시

### 1-3. 명령 라우팅(Command Routing)

명령(메뉴/툴바/단축키/버튼)을 **어느 객체가 처리할지** 찾는 순서입니다.

- **Doc/View 기반(SDI/MDI)**
  1) 활성 **`CView`** → 2) **`CFrameWnd`** → 3) **`CDocument`** → 4) **`CWinApp`**
- **Dialog 기반**
  1) **현재 `CDialog`** → 2) **부모/소유자** → 3) **`CWinApp`**

> 규칙: **표시/편집은 View/Dialog**, **데이터 조작은 Document**, **전역/창 관련은 Frame/App**에 둡니다.

### 1-4. `PreTranslateMessage`로 세밀 제어

특정 키를 가로채거나, 추가 가속기를 직접 처리할 수 있습니다.

```cpp
BOOL CMainDlg::PreTranslateMessage(MSG* pMsg) {
    if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE) {
        // ESC로 닫지 못하게 막기
        return TRUE; // handled
    }
    return CDialogEx::PreTranslateMessage(pMsg);
}
```

---

## 앱 구조

### 2-1. 모달 vs 모델리스

- **모달**: `DoModal()` 동안 **블록**. 설정창/확인 대화상자에 적합.
- **모델리스**: `Create()` + `ShowWindow()`. 메인과 **동시에 상호작용**.

```cpp
// 모달
CConfigDlg dlg;
if (dlg.DoModal() == IDOK) { /* 설정 반영 */ }

// 모델리스
auto pAbout = new CAboutDlg;
pAbout->Create(IDD_ABOUT, this);
pAbout->ShowWindow(SW_SHOW);

// 안전한 수명(모델리스)
void CAboutDlg::PostNcDestroy() { delete this; } // DestroyWindow 이후 delete
```

**닫기 처리**
- 모달: `OnOK()`/`OnCancel()` → `EndDialog(IDOK/IDCANCEL)`
- 모델리스: `OnOK()`/`OnCancel()` → `DestroyWindow()` → `PostNcDestroy()`

### 2-2. OK/Cancel 기본 동작과 키

`IDOK` / `IDCANCEL` 버튼은 각각 **Enter / ESC**에 매핑됩니다. 기본 동작을 바꾸려면 오버라이드:

```cpp
void CMainDlg::OnOK() {
    if (!UpdateData(TRUE)) return;  // DDX/DDV 검증
    // TODO: 저장/적용
    CDialogEx::OnOK();
}

void CMainDlg::OnCancel() {
    if (AfxMessageBox(_T("정말 닫을까요?"), MB_YESNO) == IDNO) return;
    CDialogEx::OnCancel();
}
```

### 2-3. DDX/DDV: 바인딩 & 검증

- **DDX**: 컨트롤 ↔ 멤버 변수
- **DDV**: 값 범위/형식 검증

```cpp
class CMainDlg : public CDialogEx {
public:
    CString m_name;
    int     m_age = 20;
    CEdit   m_editName;

protected:
    void DoDataExchange(CDataExchange* pDX) override {
        CDialogEx::DoDataExchange(pDX);
        DDX_Control(pDX, IDC_EDIT_NAME, m_editName);   // 핸들
        DDX_Text   (pDX, IDC_EDIT_NAME, m_name);       // 값 바인딩
        DDX_Text   (pDX, IDC_EDIT_AGE,  m_age);
        DDV_MinMaxInt(pDX, m_age, 1, 120);             // 검증
        DDV_RequireNonEmpty(pDX, m_name);              // 커스텀 검증
    }

    static void DDV_RequireNonEmpty(CDataExchange* pDX, const CString& s) {
        if (pDX->m_bSaveAndValidate && s.Trim().IsEmpty()) {
            AfxMessageBox(_T("이름을 입력하세요."));
            pDX->Fail();
        }
    }
};
```

> 팁: `UpdateData(TRUE)`는 비용 큽니다. 고빈도 이벤트(타이머 등)에서 남용 금지.
> 실시간 검증은 통지(예: `EN_CHANGE`)에서 가볍게, 최종 저장 순간에 DDV로 확정.

### 2-4. 리소스 에디터 핵심

- **대화상자 ID**: `IDD_*` / **컨트롤 ID**: `IDC_*`
- `IDC_STATIC`은 **공용** ID → **데이터 바인딩 불가**. 바인딩할 컨트롤엔 **새 ID** 부여.
- **Tab 순서**: `WS_TABSTOP` + Tab Order 정리.
- **Default Button** 속성으로 Enter 키 지정.
- **DPI 대응**: `PerMonitorV2` 매니페스트 검토, 글자/컨트롤 잘림 체크.
- **레이아웃**: 순정 MFC는 자동 앵커 없음 → `OnSize`에서 `MoveWindow/SetWindowPos`.

```cpp
void CMainDlg::OnSize(UINT nType, int cx, int cy) {
    CDialogEx::OnSize(nType, cx, cy);
    if (IsWindow(m_editName)) {
        CRect r(10, 10, cx - 10, 34);
        m_editName.MoveWindow(r);
    }
}
```

### 2-5. 최소 대화상자 앱 골격

```cpp
class CMyApp : public CWinApp {
public:
    BOOL InitInstance() override {
        CWinApp::InitInstance();
        CMainDlg dlg; m_pMainWnd = &dlg;
        dlg.DoModal();
        return FALSE; // 대화상자 종료 → 앱 종료
    }
} theApp;
```

---

## 자주 쓰는 메시지 & 패턴 모음

### 3-1. 타이머/그리기/버튼

```cpp
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_WM_TIMER()
    ON_WM_PAINT()
    ON_BN_CLICKED(IDC_BTN_START, &CMainDlg::OnStart)
END_MESSAGE_MAP()

BOOL CMainDlg::OnInitDialog() {
    CDialogEx::OnInitDialog();
    SetTimer(1, 1000, nullptr);
    return TRUE;
}
void CMainDlg::OnTimer(UINT_PTR id) {
    if (id==1) SetDlgItemText(IDC_STATIC_CLOCK, CTime::GetCurrentTime().Format(_T("%H:%M:%S")));
}
void CMainDlg::OnPaint() {
    CPaintDC dc(this); CRect rc; GetClientRect(&rc);
    dc.DrawText(_T("Hello, MFC!"), -1, &rc, DT_CENTER|DT_VCENTER|DT_SINGLELINE);
}
```

### 3-2. 통지/메시지 반사(Notify Reflection)

컨트롤 자신이 보낸 통지를 **자기 자신으로 되돌려** 처리(오너 드로우 등에서 유용).

```cpp
BEGIN_MESSAGE_MAP(CMyListCtrl, CListCtrl)
    ON_NOTIFY_REFLECT(NM_CUSTOMDRAW, &CMyListCtrl::OnCustomDraw) // ★_REFLECT
END_MESSAGE_MAP()
```

### 3-3. 사용자 정의 메시지/WM_APP/Registered

```cpp
// WM_APP 기반 사용자 메시지
#define WM_APP_TASKDONE (WM_APP + 100)

BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_MESSAGE(WM_APP_TASKDONE, &CMainDlg::OnTaskDone)
END_MESSAGE_MAP()

LRESULT CMainDlg::OnTaskDone(WPARAM w, LPARAM l) {
    // 백그라운드 작업 완료 처리
    return 0;
}

// Registered message(프로세스 간/컨트롤 간 계약)
UINT g_uMsgFoo = ::RegisterWindowMessage(L"MYAPP_MSG_FOO");
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_REGISTERED_MESSAGE(g_uMsgFoo, &CMainDlg::OnFoo)
END_MESSAGE_MAP()
```

### 3-4. `ON_UPDATE_COMMAND_UI` in Dialog

Dialog에서는 기본적으로 자동 호출되지 않으므로 **직접 트리거**해야 합니다.

```cpp
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_UPDATE_COMMAND_UI(IDC_BTN_SAVE, &CMainDlg::OnUpdateSave)
END_MESSAGE_MAP()

void CMainDlg::OnUpdateSave(CCmdUI* pUI) {
    CString name; GetDlgItemText(IDC_EDIT_NAME, name);
    pUI->Enable(!name.Trim().IsEmpty());
}

// 간단: 빈번 호출이 과하면 타이머/상태 변경 시점에만 호출하도록 설계
BOOL CMainDlg::PreTranslateMessage(MSG* pMsg) {
    UpdateDialogControls(this, FALSE);
    return CDialogEx::PreTranslateMessage(pMsg);
}
```

---

## 모델리스 도구창/패널 패턴

```cpp
class CToolPane : public CDialogEx {
public:
    CToolPane() : CDialogEx(IDD_TOOLPANE) {}
    void PostNcDestroy() override { delete this; }  // 안전한 delete
};

void CMainDlg::OnBnClickedShowPane() {
    if (!m_pPane) {
        m_pPane = new CToolPane;
        m_pPane->Create(IDD_TOOLPANE, this);
    }
    m_pPane->ShowWindow(SW_SHOW);
}
```

---

## 컨트롤 서브클래싱 & 메시지 필터

### 5-1. 서브클래싱

리소스의 기존 컨트롤을 **내 클래스**로 바꿔 고급 처리.

```cpp
class CUrlEdit : public CEdit {
    DECLARE_MESSAGE_MAP()
    afx_msg void OnChar(UINT ch, UINT rep, UINT flags) {
        if (ch == _T(' ')) return; // 공백 차단
        CEdit::OnChar(ch, rep, flags);
    }
};
BOOL CMainDlg::OnInitDialog() {
    CDialogEx::OnInitDialog();
    m_urlEdit.SubclassDlgItem(IDC_EDIT_URL, this);
    return TRUE;
}
```

### 5-2. 메시지 필터(IMessageFilter 유사)

MFC는 전역 메시지 필터는 없지만, `PreTranslateMessage`에서 **상위에서 하위로** 일괄 제어가 가능합니다.

---

## 스레드/비동기 & 메시지 통신

### 6-1. 작업자 스레드

```cpp
UINT WorkerProc(LPVOID p) {
    // 오래 걸리는 일…
    // UI 접근 금지 → 결과는 PostMessage로 메인 스레드에 전달
    CWnd* pWnd = (CWnd*)p;
    pWnd->PostMessage(WM_APP_TASKDONE, 0, 0);
    return 0;
}
void CMainDlg::OnBnClickedRun() {
    AfxBeginThread(WorkerProc, this); // 스레드 시작
}
```

### 6-2. SendMessage vs PostMessage

- **SendMessage**: 동기, 호출 스레드가 **대상 처리까지 대기**
- **PostMessage**: 비동기, 큐에 넣고 **즉시 반환** (UI 스레드 안전)

---

## 공용 컨트롤/초기화/Task Dialog

### 7-1. 공용 컨트롤 초기화

```cpp
BOOL CMyApp::InitInstance() {
    INITCOMMONCONTROLSEX icc{ sizeof(icc), ICC_WIN95_CLASSES|ICC_DATE_CLASSES|ICC_BAR_CLASSES };
    ::InitCommonControlsEx(&icc);
    return CWinApp::InitInstance();
}
```

### 7-2. Task Dialog(현대식 메시지 박스)

```cpp
#pragma comment(lib, "Comctl32.lib")

void ShowTaskDialog(HWND hParent) {
    TASKDIALOGCONFIG cfg = { sizeof(cfg) };
    cfg.hwndParent = hParent;
    cfg.pszWindowTitle = L"처리 결과";
    cfg.pszMainInstruction = L"작업이 완료되었습니다.";
    cfg.pszContent = L"세부 정보는 로그를 확인하세요.";
    cfg.dwCommonButtons = TDCBF_OK_BUTTON;
    TaskDialogIndirect(&cfg, nullptr, nullptr, nullptr);
}
```

---

## Property Sheet/Wizard(다단계 설정)

```cpp
class CPageGeneral : public CPropertyPage { /*…*/ };
class CPageAdvanced: public CPropertyPage { /*…*/ };

void CMainDlg::OnBnClickedSettings() {
    CPageGeneral pg1; CPageAdvanced pg2;
    CPropertySheet sheet(L"환경 설정");
    sheet.AddPage(&pg1); sheet.AddPage(&pg2);
    sheet.DoModal();
}
```

> 마법사 모드는 `PSH_WIZARD`/`PSH_WIZARD97` 스타일을 사용.

---

## DPI/텍스트/그리기 품질 팁

- **폰트 크기**는 시스템/모니터 DPI 고려(`GetDpiForWindow`/`LOGPIXELSX/Y`).
- **High DPI**: 매니페스트 `PerMonitorV2` + 폰트/컨트롤 리스케일.
- **GDI** 그리기 시 얇은 선은 DPI에 따라 **가시성 보정**(`Pen` 굵기 최소 1px 이상).

---

## 체크리스트 (실무 요약)

1. **라우팅 규칙**에 맞게 핸들러 배치(뷰/다이얼로그=표시, 문서=데이터, 프레임/앱=전역)
2. **DDX/DDV**로 저장 시 `UpdateData(TRUE)` / 초기화 시 `UpdateData(FALSE)`
3. **Dialog의 UI 업데이트**는 `UpdateDialogControls`로 직접 트리거
4. **모델리스 수명**: `DestroyWindow` → `PostNcDestroy`에서 `delete this`
5. **서브클래싱/메시지 반사**로 컨트롤 동작을 세밀 제어
6. **스레드 결과는 PostMessage**로 UI 스레드에 전달(SendMessage 남용 금지)
7. **DPI/Tab 순서/Default 버튼** 등 리소스 에디터 기본기를 정확히
8. **Registered/WM_APP 메시지**로 모듈 간 안정적 통신 규약 마련

---

## 미니 샘플: 대화상자 기반 “실시간 검증 + 저장 버튼 활성화”

```cpp
// 리소스: IDC_EDIT_NAME, IDC_BTN_SAVE(비활성으로 시작), IDC_STATIC_STATUS
class CMainDlg : public CDialogEx {
public:
    CString m_name;
    CEdit   m_editName;

    BOOL OnInitDialog() override {
        CDialogEx::OnInitDialog();
        m_editName.SubclassDlgItem(IDC_EDIT_NAME, this);
        SetDlgItemText(IDC_STATIC_STATUS, _T("이름을 입력하세요."));
        return TRUE;
    }

    afx_msg void OnEnChangeName() {
        GetDlgItemText(IDC_EDIT_NAME, m_name);
        SetDlgItemText(IDC_STATIC_STATUS, m_name.Trim().IsEmpty() ? _T("이름을 입력하세요.") : _T("OK"));
        UpdateDialogControls(this, FALSE); // 버튼 상태 갱신
    }
    afx_msg void OnUpdateBtnSave(CCmdUI* p) { p->Enable(!m_name.Trim().IsEmpty()); }
    afx_msg void OnBnClickedSave() {
        if (!UpdateData(TRUE)) return;  // DDV 통과
        AfxMessageBox(_T("저장 완료"));
    }

    void DoDataExchange(CDataExchange* pDX) override {
        CDialogEx::DoDataExchange(pDX);
        DDX_Text(pDX, IDC_EDIT_NAME, m_name);
        DDV_RequireNonEmpty(pDX, m_name);
    }
    static void DDV_RequireNonEmpty(CDataExchange* pDX, const CString& s) {
        if (pDX->m_bSaveAndValidate && s.Trim().IsEmpty()) {
            AfxMessageBox(_T("이름은 비워둘 수 없습니다."));
            pDX->Fail();
        }
    }

    DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_EN_CHANGE(IDC_EDIT_NAME, &CMainDlg::OnEnChangeName)
    ON_UPDATE_COMMAND_UI(IDC_BTN_SAVE, &CMainDlg::OnUpdateBtnSave)
    ON_BN_CLICKED(IDC_BTN_SAVE, &CMainDlg::OnBnClickedSave)
END_MESSAGE_MAP()
```

---

### 마무리

- **메시지 루프/맵/라우팅**을 이해하면 **왜 핸들러가 여기서 호출되는지**가 명확해지고,
- **Dialog 구조(모달/모델리스, DDX/DDV, 반사/서브클래싱)**를 익히면 **작고 민첩한 도구형 앱**을 빠르게 만들 수 있습니다.
- 여기에 **DPI/스레딩/Registered 메시지/PropertySheet**까지 더하면 실무 대부분의 UI 요구를 커버합니다.
