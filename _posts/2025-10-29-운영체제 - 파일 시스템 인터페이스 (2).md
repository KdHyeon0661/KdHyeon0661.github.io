---
layout: post
title: 운영체제 - 파일 시스템 인터페이스 (2)
date: 2025-10-29 15:25:23 +0900
category: 운영체제
---
# Chapter 13 — Protection & Memory-Mapped Files

## 13.4 Protection

### 13.4.1 목적과 모델
- **목표(CIA)**:
  - **Confidentiality**(기밀성): 권한 없는 주체가 읽지 못하게.
  - **Integrity**(무결성): 권한 없는 변경을 막고 추적 가능하게.
  - **Availability**(가용성): 합법적 접근은 지연 없이 가능하도록.
- **주체(Subjects)**: 사용자, 그룹, 역할(roles), 보안 도메인(컨테이너/VM).
- **객체(Objects)**: 파일/디렉터리/소켓/디바이스 노드/IPC 엔드포인트 등.
- **권한(Rights)**: read/write/execute/append/delete/chmod/chown/rename 등.

**보호 행렬(Protection Matrix)**
주체 집합 \(S\), 객체 집합 \(O\), 권한 집합 \(R\)에 대해
$$
M:S\times O \to \mathcal{P}(R)
$$
현실에서는 **ACL(객체→주체 권한 리스트)** 또는 **Capability(주체가 쥔 토큰)** 로 구현한다.

---

### 13.4.2 DAC/MAC/RBAC/Capabilities
- **DAC (Discretionary Access Control)**: 객체 소유자가 권한을 결정(UNIX 퍼미션/ACL).
- **MAC (Mandatory Access Control)**: **라벨** 기반 정책(SELinux, AppArmor, SMACK). 소유자 재량과 무관하게 정책이 우선.
- **RBAC**: 역할을 통해 권한을 부여/회수.
- **(Object) Capabilities**: 특정 권한이 부여된 **불forgeable** 참조(파일 디스크립터, Capsicum, seL4 스타일).

---

### 13.4.3 UNIX 권한·UMASK·특수 비트
- 권한 비트: `rwx` × (owner/group/others).
- **umask**: 새 객체 권한 = **요청 모드 AND (NOT umask)**
  $$ \text{mode}_{new} = \text{mode}_{req} \land \neg\text{umask} $$
- **setuid/setgid**(실행 파일에 설정 시): 실행 시 **파일 소유자/그룹 권한으로** 동작 → 보안 취약점의 주요 표면.
- **sticky bit**(디렉터리, 예: `/tmp`): 누구나 쓰기 가능하더라도 **자신이 소유한 파일만 삭제** 가능.

```bash
umask 027            # g: r-x, o: ---
chmod 4750 prog      # setuid + rwx r-x ---
chmod 1777 /tmp      # sticky bit on
```

---

### 13.4.4 POSIX ACL · 확장 속성(xattr)
- **ACL**: 사용자/그룹별 세밀한 허용. `getfacl/setfacl`.
- **xattr**: `user.*`, `security.*`, `system.*` 네임스페이스에 메타데이터 저장(예: 보안 라벨, 해시).

```bash
# ACL 예시: alice 읽기/쓰기, dev 그룹 읽기
setfacl -m u:alice:rw file.txt
setfacl -m g:dev:r file.txt
getfacl file.txt
```

---

### 13.4.5 Linux Capabilities & 파일 Cap
- 루트 권한을 **세분화**: `CAP_NET_BIND_SERVICE`(1024 미만 포트 바인드), `CAP_SYS_ADMIN`(광범위), …
- **파일 Cap**: 실행 파일에 특정 캡만 부여.

```bash
# 80포트 바인드 가능한 바이너리로 만들기(루트 전체 권한 불필요)
sudo setcap 'cap_net_bind_service=+ep' /usr/local/bin/myserver
getcap /usr/local/bin/myserver
```

---

### 13.4.6 MAC: SELinux/AppArmor (개요)
- **SELinux**: **주체/객체에 라벨(context)** 부여, **타입 기반(TE)** 정책으로 허용/거부.
  - 컨텍스트 예: `system_u:system_r:httpd_t:s0`(프로세스), `unconfined_u:object_r:httpd_sys_content_t:s0`(파일).
  - 모드: `enforcing`, `permissive`, `disabled`.
- **AppArmor**: **경로 기반 프로파일**로 파일/네트워크/능력 제한.

---

### 13.4.7 안전한 파일 열기 패턴(TOCTOU·심링크 레이스 방지)
- **openat() + 디렉터리 FD + O_NOFOLLOW** 사용.
- **권장**: `O_CLOEXEC`(FD 상속 방지), 필요 시 `O_TMPFILE` 로 임시 파일 원자 생성.

```c
// safe_openat.c — 신뢰된 디렉터리 기준으로 안전하게 열기
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
int main(){
  int dfd = open("trusted_dir", O_RDONLY|O_DIRECTORY|O_CLOEXEC);
  int fd  = openat(dfd, "user_payload", O_RDONLY|O_NOFOLLOW|O_CLOEXEC);
  if(fd<0){ perror("openat"); return 1; }
  // ... read/use ...
  close(fd); close(dfd); return 0;
}
```

---

### 13.4.8 안전한 임시 파일 생성
- `mktemp()`는 경쟁 조건으로 **금지**. `mkstemp()` 또는 `O_TMPFILE` 사용.

```c
// mkstemp_demo.c — 원자적 임시 파일
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
int main(){
  char tmpl[]="/tmp/myapp.XXXXXX";
  int fd = mkstemp(tmpl);
  if(fd<0){perror("mkstemp"); return 1;}
  dprintf(fd,"hello\n");
  // 필요 시 링크 후 rename으로 가시화(O_TMPFILE 대체)
  close(fd); unlink(tmpl); // 자동 삭제
  return 0;
}
```

---

### 13.4.9 네임스페이스·cgroup·seccomp(샌드박스)
- **user/mount/net/pid** 네임스페이스로 격리.
- **cgroup v2**로 CPU/메모리/IO 제한.
- **seccomp**로 허용된 **시스템콜 화이트리스트**만 통과.

---

### 13.4.10 로그 무결성 & 원자성 패턴
- **원자적 교체**: 임시 파일에 쓰고 `fsync(tmp) → rename()`
- **로그/저널**: Append-only + 주기적 체크포인트.
- **해시/xattr**: `security.*`에 **콘텐츠 해시**를 저장해 무결성 감시.

```bash
# 안전 저장 시퀀스(요약)
echo "data" > file.tmp && sync && mv -f file.tmp file
```

---

## 13.5 Memory-Mapped Files

### 13.5.1 개념과 장단점
- **`mmap`**: 파일(또는 익명 메모리)을 **프로세스 주소 공간**에 매핑하여 **배열처럼 접근**.
- **장점**
  - **복사 제거**(커널↔유저 복사 최소화).
  - **on-demand** 접근(페이지 폴트 시 필요한 페이지만 로드).
  - 여러 프로세스 간 **공유( `MAP_SHARED` )** 로 IPC 가능.
- **단점/주의**
  - 페이지 단위(보통 4KiB) 동작 → 자잘한 랜덤 접근은 페이지 폴트 폭증 가능.
  - 파일 길이 밖 접근 시 **SIGBUS**.
  - **msync/fsync** 의미 차이, 내구성 보장 주의.
  - 큰 워크셋이 RAM을 넘으면 **스래싱** 위험.

**정렬 제약**
매핑 시작 주소와 오프셋은 페이지 크기 \(P\)에 대해
$$
\text{offset} \equiv 0 \pmod{P},\quad \text{addr} \equiv 0 \pmod{P}
$$

---

### 13.5.2 API 빠른 지도(POSIX)
- `void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off);`
  - **prot**: `PROT_READ|PROT_WRITE|PROT_EXEC`
  - **flags**: `MAP_PRIVATE`(COW), `MAP_SHARED`(공유), `MAP_ANONYMOUS`(파일 없음), `MAP_FIXED`(지정 주소)
- `munmap(addr,len)`, `mprotect(addr,len,prot)`
- `msync(addr,len, MS_SYNC|MS_ASYNC|MS_INVALIDATE)`
- `madvise(addr,len, MADV_SEQUENTIAL|MADV_RANDOM|MADV_DONTNEED|…)`
- 보조: `ftruncate(fd,newlen)`(파일 크기 조정), `mincore`(메모리 상주 여부)

---

### 13.5.3 파일 매핑: 읽기 전용 스캐너
```c
// mmap_scan.c — 파일 매핑 후 특정 바이트 카운팅(읽기 전용)
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc,char**argv){
  if(argc<3){fprintf(stderr,"usage: %s <file> <char>\n",argv[0]); return 1;}
  int fd=open(argv[1],O_RDONLY);
  struct stat st; fstat(fd,&st);
  unsigned char* p=mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
  unsigned char t=argv[2][0]; size_t c=0;
  for(off_t i=0;i<st.st_size;i++) if(p[i]==t) c++;
  printf("count=%zu\n",c);
  munmap(p,st.st_size); close(fd); return 0;
}
```
- **`MAP_PRIVATE`**: 쓰기 시 COW 발생(파일 변하지 않음).
- 순차 접근이면 `madvise(...,MADV_SEQUENTIAL)`로 리드어헤드 힌트.

---

### 13.5.4 공유 매핑: 프로세스 간 IPC
- **`MAP_SHARED`** 로 매핑한 영역의 변경은 **다른 프로세스에도 보임**.
- 파일 기반 또는 **POSIX 공유 메모리**(`shm_open`, `/dev/shm`) 사용 가능.

```c
// shm_ring.c — shm_open + mmap 기반 단순 링버퍼(동일 호스트 두 프로세스용)
// 컴파일: gcc shm_ring.c -lrt -O2 -o shm_ring
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdatomic.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>

#define NAME "/demo_ring"
#define CAP  4096

typedef struct {
  _Atomic unsigned head; // write
  _Atomic unsigned tail; // read
  char data[CAP];
} ring_t;

int main(int argc,char**argv){
  int is_writer = (argc>1 && !strcmp(argv[1],"write"));
  int fd = shm_open(NAME, O_CREAT|O_RDWR, 0666);
  ftruncate(fd, sizeof(ring_t));
  ring_t* r = mmap(NULL,sizeof(ring_t),PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
  if(!is_writer){ // reader
    for(;;){
      unsigned t=atomic_load_explicit(&r->tail, memory_order_acquire);
      unsigned h=atomic_load_explicit(&r->head, memory_order_acquire);
      if(t==h){ usleep(1000); continue; }
      putchar(r->data[t%CAP]);
      atomic_store_explicit(&r->tail, t+1, memory_order_release);
    }
  } else { // writer
    const char* msg="hello mmap shm\n";
    for(const char* p=msg; *p; ++p){
      unsigned h=atomic_load_explicit(&r->head, memory_order_relaxed);
      unsigned t=atomic_load_explicit(&r->tail, memory_order_acquire);
      while(h-t>=CAP) usleep(1000);
      r->data[h%CAP]=*p;
      atomic_store_explicit(&r->head, h+1, memory_order_release);
    }
  }
  return 0;
}
```
- 데모 간단화를 위해 **busy-wait**를 썼다. 실전은 **futex/condvar/eventfd**로 sleep-wake를 사용.

---

### 13.5.5 쓰기·내구성: msync vs fsync
- `msync(MS_SYNC)` = **매핑된 범위의 dirty 페이지**를 **스토리지에 반영**.
- `fsync(fd)` = 파일의 데이터와 **메타데이터**(일부 FS에서 저널까지) 내구화.
- 저널링 FS/장치 캐시에 따라 의미가 다를 수 있으므로 **WAL/그룹 커밋**과 함께 설계.

```c
// mmap_write.c — 공유 매핑에 쓰고 msync로 반영
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
int main(){
  int fd=open("log.bin",O_RDWR|O_CREAT,0644);
  ftruncate(fd, 4096);
  char* p=mmap(NULL,4096,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
  strcpy(p,"record-0001\n");
  msync(p, 4096, MS_SYNC); // 장치로 밀어넣기
  munmap(p,4096); close(fd); return 0;
}
```

---

### 13.5.6 파일 크기 확장 & remap
- 매핑한 영역 밖으로 쓰면 **SIGBUS**. 먼저 `ftruncate`로 파일을 **늘린 후**, 필요한 경우 `mremap`으로 범위 확장.

```c
// mmap_grow.c — 파일 확장 후 안전한 append
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

int main(){
  int fd=open("data.bin",O_RDWR|O_CREAT,0644);
  size_t need=1<<20; // 1MiB
  ftruncate(fd, need);
  char* p=mmap(NULL,need,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
  memset(p, 0xAB, need);
  msync(p,need,MS_SYNC);
  // 파일 더 키우기
  size_t more=1<<20; ftruncate(fd, need+more);
  p = mremap(p, need, need+more, MREMAP_MAYMOVE); // 주소 바뀔 수 있음
  memset(p+need, 0xCD, more);
  msync(p,need+more,MS_SYNC);
  munmap(p,need+more); close(fd); return 0;
}
```

---

### 13.5.7 메모리 권한·W^X·JIT
- **W^X**(Write xor Execute): 쓰기 가능한 페이지는 실행 불가, 실행 가능한 페이지는 쓰기 불가.
- `mprotect(addr,len, PROT_READ|PROT_EXEC)`로 실행 허용, JIT는 **일시적으로** W→X 전환.

```c
// mprotect_exec.c — 코드 생성 후 실행(데모; 보안·이식성 주의)
#include <sys/mman.h>
#include <string.h>
#include <stdio.h>
typedef int (*fn_t)(void);
int main(){
  unsigned char code[] = { 0xB8,0x2A,0x00,0x00,0x00, 0xC3 }; // mov eax,42; ret
  void* p=mmap(NULL,4096,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANON,-1,0);
  memcpy(p,code,sizeof(code));
  mprotect(p,4096,PROT_READ|PROT_EXEC);
  int r=((fn_t)p)();
  printf("%d\n",r); munmap(p,4096); return 0;
}
```

---

### 13.5.8 성능 팁: 언제 mmap이 이득인가
- **랜덤 소량 읽기가 매우 빈번**하고, **커널 복사/시스템콜 오버헤드**가 문제일 때 유리.
- **대형 순차 IO**에서는 `read`/`write`와 큰 차이 없을 수 있음(커널 리드어헤드가 이미 최적).
- **TLB/페이지 폴트 비용**을 감안해 **작업세트(Working Set)** 가 RAM에 들어오도록 설계.
- 힌트: `madvise(MADV_SEQUENTIAL|RANDOM|WILLNEED|DONTNEED)`, `mlock`(잠금; 남용 금지).

---

### 13.5.9 오류·엣지케이스
- **SIGBUS**: 파일이 **truncate** 됐는데 매핑된 페이지를 접근, 또는 희소(hole) 영역에 **쓰기** 시 FS에 따라 발생.
- **동시성**: 여러 프로세스가 같은 페이지를 쓰면 **캐시 라인 false sharing** 가능 → **레코드 패딩/정렬**.
- **리네임/교체**: 이미 매핑한 **inode**는 유효; 경로가 새 파일로 바뀌어도 기존 매핑은 유지.
- **권한 전파**: `MAP_SHARED`는 다른 프로세스에 **즉시** 보이지만, **디스크 내구**는 `msync/fsync` 필요.

---

### 13.5.10 Windows 매핑(대비)
```c
// win_map_view.c — CreateFileMapping + MapViewOfFile (요약)
#include <windows.h>
#include <stdio.h>
int main(){
  HANDLE h = CreateFileA("data.bin", GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0, NULL);
  LARGE_INTEGER sz; sz.QuadPart = 1<<20; SetFilePointerEx(h, sz, NULL, FILE_BEGIN); SetEndOfFile(h);
  HANDLE m = CreateFileMappingA(h, NULL, PAGE_READWRITE, 0, 0, NULL);
  char* p = MapViewOfFile(m, FILE_MAP_ALL_ACCESS, 0, 0, 0);
  sprintf(p,"hello windows mmap\n");
  FlushViewOfFile(p, 1<<20); // msync 유사
  UnmapViewOfFile(p); CloseHandle(m); CloseHandle(h); return 0;
}
```
- 개념은 유사하지만 **API 이름/flush 의미**가 다르다(파일 핸들 FlushFileBuffers 필요).

---

### 13.5.11 Python으로 빠르게 맛보기
```python
# py_mmap_demo.py — Python mmap 모듈
import mmap, os
with open("pydata.bin","w+b") as f:
    f.truncate(1024*1024)
    with mmap.mmap(f.fileno(), 0) as mm:
        mm[0:5]=b"hello"
        print(mm[0:5])
        mm.flush()
```

---

## 통합 시나리오: “로그 수집기 — zero-copy 소비자”
**요구**: 초당 수십만 레코드가 기록되는 단일 호스트 로그를 **저지연 소비**하고, 장애시 데이터 유실 없이 디스크에 안전히 저장.

**설계**
1) **파일 기반 `MAP_SHARED`** 링버퍼 파일(`log.ring`), 헤더에 write/read 인덱스(원자 변수).
2) 프로듀서는 레코드를 작성 → `msync(MS_ASYNC)` 로 밀어 넣되, 10ms마다 **배치 `MS_SYNC`**.
3) 컨슈머 프로세스는 동일 파일을 매핑해 인덱스를 읽고 레코드 소비(파싱).
4) 시간별 롤오버는 새 파일 생성 후 **원자적 rename**. 구파일은 read-only로 전환.
5) 보안: 디렉터리 FD 고정 + `openat` 로만 접근, `O_NOFOLLOW`; 컨슈머는 **읽기 전용 매핑**.

**핵심 코드 스케치**: 위 `shm_ring.c`를 파일-backed로 바꾸고 `msync` 배치 추가.

---

## 체크리스트(Protection & mmap 종합)

1) **권한 체계**: DAC(퍼미션/ACL) + 필요한 범위만 Cap/FileCap 사용. 루트 전체 권한은 피하라.
2) **정책 강제**: SELinux/AppArmor로 “가능하면 거부” 기본 방침.
3) **안전한 파일 IO**: `openat`/`O_NOFOLLOW`/`O_CLOEXEC`/`mkstemp`/`O_TMPFILE`.
4) **로그/저장 원자성**: `fsync`/`msync` 의미 분리, rename 스왑.
5) **mmap 설계**: 접근 패턴에 맞는 `MAP_PRIVATE/SHARED`, `madvise` 힌트, 파일 확장·remap 절차 명시.
6) **동시성/무결성**: 원자 변수·futex, 레코드 패딩, SIGBUS 대비(try/except, 신호 핸들러).
7) **운영 관측**: 페이지 폴트/majflt, I/O 대기, `mincore`, SLO 기준 p99 모니터.

---

## 핵심 요약
- **13.4 Protection**: 모델(DAC/MAC/RBAC/Capabilities)을 올바르게 조합하고, **안전한 오픈 패턴/임시 파일/원자 교체**로 TOCTOU를 제거하라. SELinux/AppArmor/Capabilities로 **최소 권한 원칙**을 실현한다.
- **13.5 Memory-Mapped Files**: `mmap`은 **zero-copy + on-demand**의 강력한 도구다. `MAP_SHARED`/`msync`/`ftruncate`/`mremap` 흐름을 정확히 다루고, 워크셋·폴트·내구성의 트레이드오프를 이해하면 **저지연·고효율** 파일 처리가 가능하다.
