---
layout: post
title: C# - 멀티스레딩과 비동기 병렬 처리
date: 2024-10-22 19:20:23 +0900
category: Csharp
---
# C# 멀티스레딩과 비동기 병렬 처리

## 멀티스레딩의 기본 철학과 도구 선택

C#에서 동시성 처리는 크게 두 가지 패러다임으로 구분됩니다: **CPU 집약적 작업**을 위한 병렬 처리와 **I/O 대기 작업**을 위한 비동기 프로그래밍. 올바른 도구 선택은 애플리케이션의 성능과 안정성을 결정하는 핵심 요소입니다.

```csharp
// CPU 집약적 작업: Parallel, PLINQ, Task.Run
var parallelResult = Parallel.For(0, 1000000, i => 
{
    // 무거운 계산 작업
    var result = Math.Pow(i, 2) + Math.Sqrt(i);
});

// I/O 대기 작업: async/await
async Task<string> DownloadWebPageAsync(string url)
{
    using var httpClient = new HttpClient();
    return await httpClient.GetStringAsync(url);
}
```

---

## Thread와 ThreadPool: 저수준에서 고수준으로의 진화

### 직접 스레드 생성 (Thread)
```csharp
var thread = new Thread(() =>
{
    Console.WriteLine($"스레드 ID: {Thread.CurrentThread.ManagedThreadId}");
    Thread.Sleep(1000);
});

thread.IsBackground = true; // 백그라운드 스레드: 메인 스레드 종료시 함께 종료
thread.Start();
thread.Join(); // 스레드 완료 대기
```

**사용 시기**: 특수한 경우로 제한
- 실시간 처리 또는 특정 코어에 바인딩 필요한 작업
- 장기 실행되는 전용 모니터링 스레드
- 스레드 풀이 관리하지 않는 특별한 스레드 속성 필요 시

### 스레드 풀 활용 (ThreadPool)
```csharp
ThreadPool.QueueUserWorkItem(state =>
{
    Console.WriteLine($"스레드 풀 작업 실행: {Thread.CurrentThread.ManagedThreadId}");
});

// 스레드 풀 설정
ThreadPool.GetMinThreads(out int workerThreads, out int completionPortThreads);
ThreadPool.SetMinThreads(workerThreads * 2, completionPortThreads);
```

**핵심 개념**: 스레드 풀은 스레드 생성/파괴 비용을 줄이고 재사용을 최적화합니다. 대부분의 경우 직접 스레드를 생성하기보다 스레드 풀을 활용하는 것이 효율적입니다.

---

## Task: 현대적 비동기 프로그래밍의 표준

### 기본 사용법
```csharp
// 반환값 없는 작업
Task task = Task.Run(() =>
{
    Console.WriteLine("백그라운드 작업 실행");
});

// 반환값 있는 작업
Task<int> calculationTask = Task.Run(() =>
{
    Thread.Sleep(1000);
    return 42;
});

int result = await calculationTask;
Console.WriteLine($"결과: {result}");
```

### 작업 연쇄와 구성
```csharp
async Task ProcessDataAsync()
{
    // 순차 실행
    var data = await LoadDataAsync();
    var processed = await ProcessAsync(data);
    await SaveAsync(processed);
    
    // 병렬 실행
    var task1 = LoadUserDataAsync();
    var task2 = LoadProductDataAsync();
    var task3 = LoadOrderDataAsync();
    
    await Task.WhenAll(task1, task2, task3);
    
    // 결과 결합
    var userData = await task1;
    var productData = await task2;
    var orderData = await task3;
}
```

### 작업 상태 관리
```csharp
Task<Data> longRunningTask = Task.Run(() => ExpensiveCalculation());

// 작업 상태 확인
if (longRunningTask.IsCompletedSuccessfully)
{
    var data = longRunningTask.Result;
}
else if (longRunningTask.IsFaulted)
{
    Console.WriteLine($"작업 실패: {longRunningTask.Exception?.Message}");
}
else if (longRunningTask.IsCanceled)
{
    Console.WriteLine("작업 취소됨");
}
```

---

## async/await 패턴: I/O 작업의 혁명

### 기본 패턴
```csharp
public class DataService
{
    private readonly HttpClient _httpClient;
    
    public async Task<string> GetDataAsync(string url, CancellationToken cancellationToken = default)
    {
        try
        {
            // 비동기 호출
            var response = await _httpClient.GetAsync(url, cancellationToken);
            response.EnsureSuccessStatusCode();
            
            return await response.Content.ReadAsStringAsync(cancellationToken);
        }
        catch (HttpRequestException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)
        {
            // 특정 예외 처리
            return string.Empty;
        }
    }
}
```

### ConfigureAwait 이해하기
```csharp
public async Task ProcessMultipleItemsAsync(IEnumerable<string> items)
{
    foreach (var item in items)
    {
        // UI 컨텍스트 복귀 필요 없음 - 성능 최적화
        var data = await DownloadItemAsync(item).ConfigureAwait(false);
        
        // 추가 처리
        await ProcessItemAsync(data).ConfigureAwait(false);
    }
}
```

**규칙**: 
- UI 애플리케이션: 일반적으로 `ConfigureAwait(false)` 사용하지 않음 (UI 컨텍스트 복귀 필요)
- 라이브러리 코드: 항상 `ConfigureAwait(false)` 사용 (컨텍스트 복귀 오버헤드 방지)

---

## 병렬 처리: 데이터 병렬화와 작업 병렬화

### Parallel 클래스 활용
```csharp
public class ImageProcessor
{
    public void ProcessImagesParallel(List<Image> images)
    {
        var parallelOptions = new ParallelOptions
        {
            MaxDegreeOfParallelism = Environment.ProcessorCount,
            CancellationToken = CancellationToken.None
        };
        
        Parallel.ForEach(images, parallelOptions, image =>
        {
            // CPU 집약적 이미지 처리
            image.ApplyFilter();
            image.Compress();
            image.Save();
        });
    }
    
    public double CalculatePiParallel(int iterations)
    {
        double sum = 0.0;
        object lockObject = new object();
        
        Parallel.For(0, iterations, () => 0.0, (i, state, localSum) =>
        {
            double x = (i + 0.5) / iterations;
            return localSum + 4.0 / (1.0 + x * x);
        },
        localSum =>
        {
            lock (lockObject) sum += localSum;
        });
        
        return sum / iterations;
    }
}
```

### PLINQ (Parallel LINQ)
```csharp
public class DataAnalyzer
{
    public IEnumerable<AnalysisResult> AnalyzeLargeDataset(IEnumerable<DataPoint> data)
    {
        return data.AsParallel()
            .WithDegreeOfParallelism(Environment.ProcessorCount)
            .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
            .Where(point => point.IsValid())
            .Select(point => AnalyzePoint(point))
            .Where(result => result.Score > 0.7)
            .AsOrdered() // 원본 순서 유지 (성능 약간 저하)
            .ToList();
    }
}
```

**PLINQ 최적화 전략**:
1. 데이터 크기가 충분히 클 때만 병렬화 (일반적으로 1000개 이상)
2. `.AsOrdered()`는 정말 필요할 때만 사용
3. `.WithMergeOptions(ParallelMergeOptions.NotBuffered)`로 메모리 사용량 줄이기

---

## 동기화: 데이터 경합 방지의 기술

### lock과 Monitor
```csharp
public class ThreadSafeCounter
{
    private readonly object _lockObject = new object();
    private int _count = 0;
    
    public void Increment()
    {
        lock (_lockObject)
        {
            _count++;
        }
    }
    
    public bool TryIncrement()
    {
        bool lockTaken = false;
        try
        {
            Monitor.TryEnter(_lockObject, 100, ref lockTaken); // 타임아웃 100ms
            if (lockTaken)
            {
                _count++;
                return true;
            }
            return false;
        }
        finally
        {
            if (lockTaken) Monitor.Exit(_lockObject);
        }
    }
}
```

### ReaderWriterLockSlim: 읽기/쓰기 최적화
```csharp
public class ThreadSafeCache<TKey, TValue>
{
    private readonly Dictionary<TKey, TValue> _cache = new();
    private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();
    
    public TValue GetOrAdd(TKey key, Func<TKey, TValue> valueFactory)
    {
        // 읽기 잠금 시도 (다중 스레드 동시 읽기 가능)
        _lock.EnterReadLock();
        try
        {
            if (_cache.TryGetValue(key, out var value))
                return value;
        }
        finally
        {
            _lock.ExitReadLock();
        }
        
        // 캐시 미스: 쓰기 잠금 획득
        _lock.EnterWriteLock();
        try
        {
            // 더블 체크 (다른 스레드가 이미 추가했을 수 있음)
            if (!_cache.TryGetValue(key, out var value))
            {
                value = valueFactory(key);
                _cache[key] = value;
            }
            return value;
        }
        finally
        {
            _lock.ExitWriteLock();
        }
    }
}
```

### 세마포어와 뮤텍스
```csharp
public class RateLimitedApiClient
{
    private readonly SemaphoreSlim _throttler;
    
    public RateLimitedApiClient(int maxConcurrentRequests)
    {
        _throttler = new SemaphoreSlim(maxConcurrentRequests);
    }
    
    public async Task<string> CallApiAsync(string endpoint, CancellationToken cancellationToken)
    {
        await _throttler.WaitAsync(cancellationToken);
        try
        {
            // API 호출
            return await _httpClient.GetStringAsync(endpoint, cancellationToken);
        }
        finally
        {
            _throttler.Release();
        }
    }
}

// 프로세스 간 동기화
public class SingleInstanceApplication
{
    private static readonly Mutex _appMutex = new Mutex(true, @"Global\MyApplication");
    
    public static bool IsAlreadyRunning()
    {
        return !_appMutex.WaitOne(0, false);
    }
}
```

---

## 취소 메커니즘: 사용자 중심의 응답성

### 취소 토큰 패턴
```csharp
public class LongRunningProcessor
{
    public async Task ProcessAsync(IEnumerable<Item> items, CancellationToken cancellationToken = default)
    {
        foreach (var item in items)
        {
            // 취소 요청 확인
            cancellationToken.ThrowIfCancellationRequested();
            
            // 정기적 취소 확인
            if (cancellationToken.IsCancellationRequested)
            {
                await CleanupAsync();
                throw new OperationCanceledException(cancellationToken);
            }
            
            // 작업 실행 (취소 토큰 전파)
            await ProcessItemAsync(item, cancellationToken);
        }
    }
}

public class CancellationExample
{
    public async Task RunWithTimeoutAsync()
    {
        // 30초 타임아웃 설정
        using var timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
        
        // 외부 취소와 결합
        using var externalCts = new CancellationTokenSource();
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            timeoutCts.Token, 
            externalCts.Token
        );
        
        try
        {
            await LongRunningOperationAsync(linkedCts.Token);
        }
        catch (OperationCanceledException) when (timeoutCts.IsCancellationRequested)
        {
            Console.WriteLine("작업이 타임아웃되었습니다.");
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("작업이 취소되었습니다.");
        }
    }
}
```

---

## 고급 패턴과 실전 시나리오

### 생산자-소비자 패턴 (Channels)
```csharp
public class DataPipeline
{
    private readonly Channel<DataItem> _channel;
    
    public DataPipeline()
    {
        _channel = Channel.CreateBounded<DataItem>(new BoundedChannelOptions(1000)
        {
            FullMode = BoundedChannelFullMode.Wait,
            SingleWriter = false,
            SingleReader = false
        });
    }
    
    public async Task StartPipelineAsync(CancellationToken cancellationToken)
    {
        // 다중 생산자
        var producerTasks = Enumerable.Range(0, 3)
            .Select(i => Task.Run(() => ProduceDataAsync(i, cancellationToken)))
            .ToArray();
        
        // 다중 소비자
        var consumerTasks = Enumerable.Range(0, 2)
            .Select(i => Task.Run(() => ConsumeDataAsync(i, cancellationToken)))
            .ToArray();
        
        await Task.WhenAll(producerTasks);
        _channel.Writer.Complete();
        
        await Task.WhenAll(consumerTasks);
    }
    
    private async Task ProduceDataAsync(int producerId, CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            var item = await GenerateDataItemAsync(producerId, cancellationToken);
            await _channel.Writer.WriteAsync(item, cancellationToken);
        }
    }
    
    private async Task ConsumeDataAsync(int consumerId, CancellationToken cancellationToken)
    {
        await foreach (var item in _channel.Reader.ReadAllAsync(cancellationToken))
        {
            await ProcessItemAsync(item, consumerId, cancellationToken);
        }
    }
}
```

### 비동기 스트림 (IAsyncEnumerable)
```csharp
public class LogStreamer
{
    public async IAsyncEnumerable<LogEntry> StreamLogsAsync(
        DateTime startTime, 
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        using var connection = await ConnectToLogServerAsync(cancellationToken);
        
        while (!cancellationToken.IsCancellationRequested)
        {
            var batch = await connection.FetchLogBatchAsync(startTime, cancellationToken);
            
            if (batch.IsEmpty)
            {
                await Task.Delay(1000, cancellationToken);
                continue;
            }
            
            foreach (var entry in batch.Entries)
            {
                yield return entry;
            }
            
            startTime = batch.LastEntryTime;
        }
    }
}

// 사용 예
await foreach (var logEntry in logStreamer.StreamLogsAsync(DateTime.UtcNow.AddHours(-1)))
{
    Console.WriteLine($"[{logEntry.Timestamp}] {logEntry.Message}");
    
    if (logEntry.Level == LogLevel.Error)
    {
        await SendAlertAsync(logEntry);
    }
}
```

### 리액티브 프로그래밍 (System.Reactive)
```csharp
public class StockPriceMonitor
{
    private readonly Subject<PriceUpdate> _priceUpdates = new();
    
    public IObservable<PriceUpdate> PriceUpdates => _priceUpdates.AsObservable();
    
    public void StartMonitoring()
    {
        // 웹소켓 등 실시간 데이터 소스 구독
        var subscription = _websocketClient.PriceStream
            .Where(update => update.ChangePercent > 5.0) // 5% 이상 변동만 필터링
            .Throttle(TimeSpan.FromMilliseconds(500))    // 500ms 스로틀링
            .Buffer(TimeSpan.FromSeconds(5))            // 5초 단위 버퍼링
            .Subscribe(updates =>
            {
                foreach (var update in updates)
                {
                    _priceUpdates.OnNext(update);
                }
            });
    }
}
```

---

## 성능 최적화와 문제 해결

### 일반적인 문제와 해결책

1. **스레드 기아(Thread Starvation)**
```csharp
// 증상: 작업이 큐에 대기하지만 실행되지 않음
// 해결: 최소 스레드 수 증가
ThreadPool.GetMinThreads(out int worker, out int io);
ThreadPool.SetMinThreads(worker * 2, io * 2);
```

2. **데드락 방지**
```csharp
// 나쁜 예: async/await 체인에서 .Result 또는 .Wait() 사용
public string GetData() => DownloadDataAsync().Result;

// 좋은 예: 완전한 async/await 사용
public async Task<string> GetDataAsync() => await DownloadDataAsync();
```

3. **메모리 누수 방지**
```csharp
public class EventSubscriber : IDisposable
{
    private readonly EventPublisher _publisher;
    
    public EventSubscriber(EventPublisher publisher)
    {
        _publisher = publisher;
        _publisher.DataChanged += OnDataChanged; // 이벤트 구독
    }
    
    private void OnDataChanged(object sender, EventArgs e) { }
    
    public void Dispose()
    {
        _publisher.DataChanged -= OnDataChanged; // 필수: 이벤트 구독 해제
    }
}
```

### 진단 도구 활용
```csharp
public static class ConcurrencyDiagnostics
{
    public static void MonitorThreadPool()
    {
        ThreadPool.GetAvailableThreads(out int worker, out int io);
        ThreadPool.GetMinThreads(out int minWorker, out int minIo);
        ThreadPool.GetMaxThreads(out int maxWorker, out int maxIo);
        
        Console.WriteLine($"사용 가능: Worker={worker}, IO={io}");
        Console.WriteLine($"최소: Worker={minWorker}, IO={minIo}");
        Console.WriteLine($"최대: Worker={maxWorker}, IO={maxIo}");
    }
    
    public static async Task MeasurePerformanceAsync(Func<Task> operation)
    {
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            await operation();
        }
        finally
        {
            stopwatch.Stop();
            Console.WriteLine($"작업 수행 시간: {stopwatch.ElapsedMilliseconds}ms");
        }
    }
}
```

---

## 실전 예제: 완전한 비동기 마이크로서비스 컴포넌트

```csharp
public class OrderProcessingService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<OrderProcessingService> _logger;
    private readonly SemaphoreSlim _rateLimiter;
    private readonly Channel<Order> _orderChannel;
    
    public OrderProcessingService(HttpClient httpClient, ILogger<OrderProcessingService> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
        _rateLimiter = new SemaphoreSlim(10); // 최대 10개 동시 요청
        _orderChannel = Channel.CreateUnbounded<Order>();
        
        // 백그라운드 처리 시작
        _ = Task.Run(() => ProcessOrdersAsync(CancellationToken.None));
    }
    
    public async Task<OrderResult> PlaceOrderAsync(OrderRequest request, CancellationToken cancellationToken)
    {
        // 1. 주문 유효성 검사 (동기)
        ValidateOrderRequest(request);
        
        // 2. 재고 확인 (비동기 I/O)
        var inventoryCheck = await CheckInventoryAsync(request.ProductId, request.Quantity, cancellationToken);
        if (!inventoryCheck.IsAvailable)
            return OrderResult.Failed("재고 부족");
        
        // 3. 결제 처리 (네트워크 I/O)
        var paymentResult = await ProcessPaymentAsync(request.PaymentInfo, cancellationToken);
        if (!paymentResult.Success)
            return OrderResult.Failed("결제 실패");
        
        // 4. 주문 생성 및 채널에 전송
        var order = new Order(request, paymentResult.TransactionId);
        await _orderChannel.Writer.WriteAsync(order, cancellationToken);
        
        // 5. 즉시 응답 반환 (비동기 처리 계속)
        return OrderResult.Success(order.Id);
    }
    
    private async Task ProcessOrdersAsync(CancellationToken cancellationToken)
    {
        await foreach (var order in _orderChannel.Reader.ReadAllAsync(cancellationToken))
        {
            try
            {
                await _rateLimiter.WaitAsync(cancellationToken);
                
                // 병렬 처리: 이메일 발송, 배송 예약, 분석 데이터 전송
                var emailTask = SendConfirmationEmailAsync(order, cancellationToken);
                var shippingTask = ScheduleShippingAsync(order, cancellationToken);
                var analyticsTask = SendToAnalyticsAsync(order, cancellationToken);
                
                await Task.WhenAll(emailTask, shippingTask, analyticsTask);
                
                _logger.LogInformation("주문 {OrderId} 처리 완료", order.Id);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "주문 {OrderId} 처리 중 오류 발생", order.Id);
                await HandleOrderFailureAsync(order, ex, cancellationToken);
            }
            finally
            {
                _rateLimiter.Release();
            }
        }
    }
    
    // 병렬 집계 예제
    public async Task<OrderStatistics> GetMonthlyStatisticsAsync(int year, int month, CancellationToken cancellationToken)
    {
        var startDate = new DateTime(year, month, 1);
        var endDate = startDate.AddMonths(1);
        
        // 병렬 데이터 수집
        var totalSalesTask = _dbContext.Orders
            .Where(o => o.OrderDate >= startDate && o.OrderDate < endDate)
            .SumAsync(o => o.TotalAmount, cancellationToken);
        
        var orderCountTask = _dbContext.Orders
            .Where(o => o.OrderDate >= startDate && o.OrderDate < endDate)
            .CountAsync(cancellationToken);
        
        var topProductsTask = _dbContext.OrderItems
            .Where(oi => oi.Order.OrderDate >= startDate && oi.Order.OrderDate < endDate)
            .GroupBy(oi => oi.ProductId)
            .Select(g => new { ProductId = g.Key, Quantity = g.Sum(oi => oi.Quantity) })
            .OrderByDescending(x => x.Quantity)
            .Take(10)
            .ToListAsync(cancellationToken);
        
        // 모든 작업 병렬 실행
        await Task.WhenAll(totalSalesTask, orderCountTask, topProductsTask);
        
        return new OrderStatistics
        {
            TotalSales = await totalSalesTask,
            OrderCount = await orderCountTask,
            TopProducts = (await topProductsTask).ToDictionary(x => x.ProductId, x => x.Quantity)
        };
    }
}
```

---

## 결론: 현대적 C# 동시성 프로그래밍의 원칙

C#의 멀티스레딩과 비동기 프로그래밍은 단순한 기술적 구현을 넘어 소프트웨어 설계 철학을 반영합니다. 효과적인 동시성 처리를 위한 핵심 원칙을 정리하면 다음과 같습니다:

### 1. 도메인에 맞는 도구 선택
- **CPU 집약적 작업**: `Parallel`, `PLINQ`, `Task.Run`
- **I/O 대기 작업**: `async`/`await` + 비동기 API
- **실시간 데이터 스트림**: `IAsyncEnumerable`, 채널, 리액티브 확장
- **상태 공유 최소화**: 불변성, 순수 함수, 메시지 전달 패턴

### 2. 추상화 계층 이해
- **저수준**: `Thread`, `Monitor`, `Interlocked` (세밀한 제어 필요 시)
- **중간 수준**: `ThreadPool`, `Task`, 동기화 기본형
- **고수준**: `async`/`await`, `Parallel`, `IAsyncEnumerable` (일반적 사용)

### 3. 오류 처리와 복원력
- 비동기 호출 체인 전체에 `CancellationToken` 전파
- `OperationCanceledException`과 일반 예외 구분 처리
- `Task.WhenAll`의 부분 실패 처리 전략 수립
- 타임아웃과 재시도 메커니즘 구현

### 4. 성능과 안정성 균형
- 과도한 병렬화는 오히려 성능 저하 (컨텍스트 전환 오버헤드)
- 메모리 배리어와 가시성 문제 이해
- 프로파일링을 통한 실제 병목 지점 식별
- `ConfigureAwait` 적절한 사용으로 불필요한 컨텍스트 전환 방지

### 5. 테스트와 유지보수성
- 단위 테스트에서 `TaskCompletionSource` 활용
- 동시성 버그 재현을 위한 의도적 지연 도입
- 동기화 코드 최소화 및 명확한 락 순서 유지
- 취소와 타임아웃을 일급 개념으로 취급

### 6. 진화하는 패러다임 수용
- `async`/`await`는 I/O 바운드 작업의 표준
- 채널과 파이프라인 패턴의 부상
- 리액티브 프로그래밍과 데이터 스트림 처리
- `ValueTask`와 `IValueTaskSource`를 통한 고성능 최적화

C#의 동시성 기능은 계속 발전하고 있지만, 기본 원칙은 변함없이 중요합니다: **단순함을 유지하고, 추상화를 이해하며, 도메인에 맞는 적절한 도구를 선택하라**. 복잡한 동시성 코드는 필연적으로 버그와 성능 문제를 야기합니다. 항상 더 단순한 해결책이 있는지 고민하고, 정말 필요할 때만 복잡성을 도입해야 합니다.

마지막으로, 동시성 프로그래밍은 팀 스포츠입니다. 코드 리뷰, 페어 프로그래밍, 지식 공유를 통해 팀 전체의 동시성 이해도를 높이는 것이 장기적인 프로젝트 성공의 핵심입니다. 함께 배우고, 실험하고, 개선해 나가는 문화가 최고의 동시성 코드를 만들어냅니다.