---
layout: post
title: C# - 멀티스레딩과 비동기 병렬 처리
date: 2024-10-22 19:20:23 +0900
category: Csharp
---
# C# 멀티스레딩과 비동기 병렬 처리

## 큰 그림 — 언제 무엇을 쓸까

- **CPU-bound**(계산 위주): `Parallel.For/ForEach`, `Task.Run`, PLINQ, 파티셔닝/스케줄러 튜닝
- **I/O-bound**(디스크/네트워크 대기): `async/await` + `ReadAsync/WriteAsync/HttpClient` 등 **진짜 비동기 API**
- **UI 응답성**: UI 스레드에서 **`await`** 를 사용, 백그라운드는 `Task.Run` (WPF/WinForms/MAUI는 디스패처 필요)
- **긴 작업 취소/타임아웃**: `CancellationToken`, `WaitAsync(TimeSpan)`(.NET 6+) 또는 `CancellationTokenSource.CancelAfter`

> **핵심**: *스레드를 늘린다고 항상 빨라지지 않는다*. 비동기 I/O는 스레드를 “덜” 쓰게 해준다.

---

## Thread — 전통적 저수준 스레드

```csharp
using System;
using System.Threading;

var t = new Thread(() =>
{
    Console.WriteLine($"Worker on #{Thread.CurrentThread.ManagedThreadId}");
});
t.IsBackground = true; // 프로세스 종료 시 함께 종료되는 백그라운드 스레드
t.Start();
t.Join(); // 완료 대기
```

### 언제 쓰나?

- 매우 특수한 **장기 전용 스레드**(고정 코어 바인딩, 실시간 I/O 폴링 등)
- 대부분의 일반 업무에서는 **ThreadPool + Task**가 더 낫다.

### 주의

- 직접 생성은 비용↑, 스케줄링/수명 직접 관리
- 예외는 스레드를 **즉시 종료**시킨다(캡처/로그 필요)

---

## ThreadPool & Task — 기본 실행 단위

### Task.Run 으로 워커 큐에 던지기 (CPU-bound)

```csharp
using System.Threading.Tasks;

var t = Task.Run(() =>
{
    // CPU-bound work
    double s = 0;
    for (int i = 0; i < 10_000_000; i++) s += Math.Sqrt(i);
    return s;
});
double result = await t;
```

- **ThreadPool**이 적절한 수의 스레드를 관리하므로 보통 **직접 Thread 생성 불필요**.
- **긴 동기 I/O**를 `Task.Run`으로 감싸는 건 “UI 블로킹 회피용”으로만 제한적으로.

### Task 반환값/연쇄

```csharp
Task<int> t1 = Task.Run(() => 40 + 2);
int answer   = await t1; // 42

int z = await Task.Run(async () =>
{
    await Task.Delay(100);
    return 7;
});
```

### TaskCreationOptions

```csharp
var t = new Task(
    () => {/*…*/},
    TaskCreationOptions.LongRunning // 전용 스레드 힌트(스레드풀 우회) — 남용 금지
);
t.Start();
```

---

## async / await — 비동기 I/O의 표준

```csharp
async Task<string> DownloadAsync(HttpClient http, string url, CancellationToken ct)
{
    using var resp = await http.GetAsync(url, HttpCompletionOption.ResponseHeadersRead, ct);
    resp.EnsureSuccessStatusCode();
    return await resp.Content.ReadAsStringAsync(ct);
}

Console.WriteLine(await DownloadAsync(new HttpClient(), "https://example.com", default));
```

### 핵심 규칙

- `async Task`(반환 없음), `async Task<T>`(반환 있음), **`async void` 금지**(이벤트 핸들러 제외)
- **컨텍스트 캡처**: 라이브러리 코드에서 `ConfigureAwait(false)` 권장
  ```csharp
  await SomeIoAsync().ConfigureAwait(false); // 컨텍스트(동기화컨텍스트) 복귀 방지
  ```
- **예외**는 `await` 시 호출자에게 전파(try/catch로 감싸기)

### 타임아웃/취소

```csharp
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5)); // 5초 후 취소
await SomeIoAsync(cts.Token);
```

---

## 병렬 루프 — Parallel.For/ForEach

```csharp
using System.Threading.Tasks;

Parallel.For(0, 10, i =>
{
    Console.WriteLine($"#{Task.CurrentId} → {i}");
});
```

컬렉션:
```csharp
var items = Enumerable.Range(1, 1000).ToArray();
Parallel.ForEach(items, i =>
{
    // CPU-bound 작업
});
```

### ParallelOptions — 제한/취소/스케줄링

```csharp
var po = new ParallelOptions
{
    MaxDegreeOfParallelism = Environment.ProcessorCount, // 병렬도 제한
    CancellationToken = cts.Token
};

Parallel.ForEach(items, po, i =>
{
    po.CancellationToken.ThrowIfCancellationRequested();
    // …
});
```

### 예외

- 내부에서 여러 예외 → **AggregateException** 래핑

```csharp
try
{
    Parallel.For(0, 100, i => { if (i == 13) throw new InvalidOperationException(); });
}
catch (AggregateException ae)
{
    foreach (var ex in ae.Flatten().InnerExceptions) Console.WriteLine(ex.Message);
}
```

---

## PLINQ — 병렬 LINQ

```csharp
using System.Linq;

var query = Enumerable.Range(1, 1_000_000)
                      .AsParallel()                   // 병렬화
                      .WithDegreeOfParallelism(8)     // 병렬도
                      .WithExecutionMode(ParallelExecutionMode.ForceParallelism) // 힌트
                      .Select(Math.Sqrt)
                      .Where(d => d > 500);

double sum = query.Sum();
```

- **순서 유지**가 필요하면 `.AsOrdered()` → 성능 일부 감소
- **I/O 작업**과 혼용 금지(PLINQ는 CPU-bound 전용으로 생각하자)

---

## 동기화 — 자료 경쟁 방지

### `lock` / `Monitor`

```csharp
object gate = new object();
int counter = 0;

Parallel.For(0, 1000, _ =>
{
    lock (gate)
    {
        counter++; // 임계구역
    }
});
Console.WriteLine(counter); // 1000
```

- `lock (obj)` == `Monitor.Enter/Exit(obj)`의 문법 설탕
- **교착상태** 회피: 항상 **일관된 획득 순서** 준수

### `Interlocked` — 락 없는 원자 연산

```csharp
int x = 0;
Parallel.For(0, 1_000_000, _ => Interlocked.Increment(ref x));
Console.WriteLine(x);
```
- Add/Increment/Exchange/CompareExchange 등

### `volatile`

```csharp
volatile bool _stop;
```
- 단순 **가시성 보장**(재정렬/캐시 일관). 복합 연산 원자성은 아님 → Interlocked/lock 사용

### ReaderWriterLockSlim — 읽기 많고 쓰기 적을 때

```csharp
var rw = new ReaderWriterLockSlim();
var dict = new Dictionary<int, string>();

string? Get(int k)
{
    rw.EnterReadLock();
    try { return dict.TryGetValue(k, out var v) ? v : null; }
    finally { rw.ExitReadLock(); }
}

void Put(int k, string v)
{
    rw.EnterWriteLock();
    try { dict[k] = v; }
    finally { rw.ExitWriteLock(); }
}
```

### SemaphoreSlim — 동시 허용량 제한(스로틀)

```csharp
var sem = new SemaphoreSlim(initialCount: 5); // 최대 5 동시 실행
await sem.WaitAsync();
try
{
    await DoIoAsync();
}
finally
{
    sem.Release();
}
```

### Mutex — 프로세스 간 상호배제

```csharp
using var mtx = new Mutex(false, @"Global\MyApp_Mutex");
mtx.WaitOne();
try
{
    // 단일 인스턴스 보장
}
finally
{
    mtx.ReleaseMutex();
}
```

---

## 취소 — CancellationToken 패턴

### 기본

```csharp
using var cts = new CancellationTokenSource();

var job = Task.Run(async () =>
{
    while (!cts.Token.IsCancellationRequested)
    {
        await Task.Delay(100, cts.Token);
        // work…
    }
}, cts.Token);

// 나중에:
cts.Cancel(); // 협력적 취소
await job;    // OperationCanceledException → 관례적으로 삼킴/로그
```

### 연결/타임아웃/외부 신호 결합

```csharp
using var parent = new CancellationTokenSource(TimeSpan.FromSeconds(10));
using var linked = CancellationTokenSource.CreateLinkedTokenSource(parent.Token, external.Token);

await WorkAsync(linked.Token);
```

### Parallel + 취소

```csharp
var po = new ParallelOptions { CancellationToken = cts.Token };
try
{
    Parallel.ForEach(items, po, i =>
    {
        po.CancellationToken.ThrowIfCancellationRequested();
        // …
    });
}
catch (OperationCanceledException) { /* 취소 처리 */ }
```

---

## 예외 처리 — Task/async/Parallel

### async/await

```csharp
try
{
    await SomeAsync();
}
catch (HttpRequestException ex)
{
    // 네트워크 오류 대응
}
```

### Task.WhenAll — 부분 실패

```csharp
var tasks = urls.Select(u => DownloadAsync(http, u, ct)).ToArray();

try
{
    var results = await Task.WhenAll(tasks);
}
catch (Exception)
{
    foreach (var t in tasks.Where(t => t.IsFaulted))
        Console.Error.WriteLine(t.Exception!.Flatten().InnerException?.Message);
}
```

### Parallel

- 위 §4 참고: `AggregateException` 처리

---

## UI 스레드 — SynchronizationContext/Dispatcher

- WPF/WinForms/MAUI: `await` 후 **원래 컨텍스트로 복귀**(기본 동작) → UI 접근 가능
- 라이브러리/서버: `ConfigureAwait(false)`로 **컨텍스트 탈출**해서 오버헤드↓
- WPF 예:
```csharp
await Task.Run(Calc);               // 백그라운드 계산
MyText.Text = "Done";               // UI 스레드 복귀(기본 await 동작)
```

---

## I/O vs CPU — 적절한 도구

- **I/O-bound**: `async` API 필수 (`ReadAsync`, `SendAsync`, DB/HTTP 비동기)
- **CPU-bound**: `Parallel`/`PLINQ`/`Task.Run`
- 혼합 파이프라인: **배압/스로틀**(SemaphoreSlim), **큐**(System.Threading.Channels) 고려

### Channels 간단 예

```csharp
using System.Threading.Channels;

var ch = Channel.CreateBounded<int>(capacity: 100);

_ = Task.Run(async () => // producer
{
    for (int i = 0; i < 1000; i++)
        await ch.Writer.WriteAsync(i);
    ch.Writer.Complete();
});

await foreach (var x in ch.Reader.ReadAllAsync())
{
    // consumer
}
```

---

## 비동기 스트림 — IAsyncEnumerable<T>

```csharp
async IAsyncEnumerable<string> ReadLinesAsync(string path, [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct = default)
{
    using var sr = new StreamReader(path);
    while (!sr.EndOfStream)
    {
        ct.ThrowIfCancellationRequested();
        yield return await sr.ReadLineAsync()!;
    }
}

await foreach (var line in ReadLinesAsync("big.log", ct))
{
    Console.WriteLine(line);
}
```

---

## 성능 모델 & 직관

- **아암달의 법칙**(Amdahl): 병렬화 가능한 비율을 \(p\), 코어 수를 \(N\)이라 하면 기대 속도 향상은
  $$ S(N) = \frac{1}{(1-p) + \frac{p}{N}} $$
  직렬 구간(1-p)이 크면 코어를 늘려도 이득이 제한됨.
- 문맥 전환/캐시 로컬리티/False Sharing(같은 캐시라인을 여러 스레드가 자주 갱신) 유의
- **작업 분할/파티셔닝**이 좋으면 스케줄러 효율↑

---

## 실전 템플릿

### CPU-bound 배치 처리 — Parallel + 파티션 + 결과 수집(스레드 안전)

```csharp
using System.Collections.Concurrent;

var inputs = Enumerable.Range(1, 1_000_000);
var outputs = new ConcurrentBag<double>(); // 스레드 안전 컬렉션

Parallel.ForEach(
    Partitioner.Create(inputs, EnumerablePartitionerOptions.NoBuffering),
    new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount },
    i =>
    {
        double v = Math.Sqrt(i);
        outputs.Add(v);
    }
);

Console.WriteLine(outputs.Count);
```

### I/O-bound 동시성 — SemaphoreSlim으로 동시 요청 제한

```csharp
var http = new HttpClient();
var sem = new SemaphoreSlim(20); // 최대 20 동시
var urls = new[] { /*…*/ };

var tasks = urls.Select(async u =>
{
    await sem.WaitAsync();
    try
    {
        return await http.GetStringAsync(u);
    }
    finally
    {
        sem.Release();
    }
});

string[] bodies = await Task.WhenAll(tasks);
```

### 취소/타임아웃/진행률

```csharp
async Task CopyWithProgressAsync(Stream src, Stream dst, IProgress<double> progress, CancellationToken ct)
{
    byte[] buf = new byte[1 << 20];
    long total = src.CanSeek ? src.Length : -1, read = 0;
    int n;
    while ((n = await src.ReadAsync(buf, 0, buf.Length, ct)) > 0)
    {
        await dst.WriteAsync(buf, 0, n, ct);
        read += n;
        if (total > 0) progress.Report((double)read / total);
    }
}
```

---

## 데드락/라이브락/기아 — 회피 전략

- **락 순서 고정**: 여러 자원 락을 항상 **동일한 순서**로 획득
- **타임아웃 TryEnter**: 실패 시 롤백/재시도
- **작은 임계구역**: 락 시간 최소화
- **`async` 전체 체인**: 동기 블로킹(`Task.Wait/Result`) 금지 → 교착 원인
  ```csharp
  // 나쁨 (UI/ASP.NET에서 교착 가능)
  var s = SomeAsync().Result;
  // 좋음
  var s = await SomeAsync();
  ```

---

## 테스트/디버깅/진단

- **`Debugger.IsAttached`** 조건부 지연/로그
- **`TaskScheduler.UnobservedTaskException`** 구독해 누락 예외 탐지
- **Concurrency Visualizer**, **PerfView**, **dotnet-trace/dump**
- **`ThreadPool.GetMinThreads/GetMaxThreads/SetMinThreads`**(특수 상황만)

---

## 체크리스트

**설계**
- [ ] I/O-bound → **async/await**, CPU-bound → **Parallel/Task.Run**
- [ ] 공용 상태 최소화(불변/순수함수 지향), 공유 시 동기화 선택(lock/Interlocked/…)
- [ ] 취소/타임아웃/진행률 API 노출

**코드 품질**
- [ ] `async void` 금지(이벤트 핸들러 제외)
- [ ] 라이브러리 코드는 `ConfigureAwait(false)`
- [ ] 예외는 호출 경계에서 포착/로그, WhenAll/Parallel 예외 수집

**성능**
- [ ] 병렬도 조절(MaxDegreeOfParallelism)
- [ ] 과도한 `Task.Run` 남용 금지
- [ ] False sharing/캐시라인 주의(핫 카운터는 `Interlocked`/분할)

**안전성**
- [ ] 락 순서 고정/타임아웃/작은 임계구역
- [ ] 취소 토큰 협력적 전파
- [ ] Thread/ThreadPool 설정은 정말 필요한 경우에만

---

## 요약 표

| 범주 | 주도 API | 한 줄 요약 |
|---|---|---|
| 저수준 스레드 | `Thread` | 특수 전용 스레드 외 드묾 |
| 실행 단위 | `Task`, ThreadPool | 표준, 스케줄링/자원 효율↑ |
| 비동기 I/O | `async/await` + `*Async` | UI/서버 필수, 스레드 절약 |
| 병렬 루프 | `Parallel.For/ForEach` | CPU-bound 벌크 처리 |
| 병렬 쿼리 | `PLINQ` | 데이터 병렬 처리 파이프라인 |
| 동기화 | `lock`/`Interlocked`/`RWLock`/`SemaphoreSlim` | 상황별 정확한 도구 선택 |
| 취소/타임아웃 | `CancellationToken`/`CancelAfter` | 협력적 취소/탄력성 |
| 채널/파이프 | `System.Threading.Channels` | 생산자–소비자, 배압 |
| 디버깅 | AggregateException/시각화 | 예외/스케줄링 가시화 |

---

## 마무리

- **I/O 대기**는 `async/await`, **계산 병렬화**는 `Parallel/PLINQ/Task.Run`으로 역할 분리.
- **공유 상태 최소화**와 **적절한 동기화**가 성능과 안정성을 동시에 만든다.
- 본 글의 **템플릿/체크리스트**로 UI/서버/배치 어디서든 **응답성과 처리량**을 둘 다 챙길 수 있다.
