---
layout: post
title: Linux - 커널 보안 및 권한 제어
date: 2024-12-01 19:20:23 +0900
category: Linux
---
# 리눅스 커널 보안 및 권한 제어

## Linux Capabilities: 루트 권한의 세분화

전통적인 리눅스 권한 모델에서는 루트 사용자에게 모든 시스템 권한이 부여되었습니다. 이는 보안 관점에서 과도한 권한 부여로 이어질 수 있습니다. Linux Capabilities는 이러한 문제를 해결하기 위해 루트 권한을 세분화된 조각으로 나누어 필요한 권한만 부여할 수 있게 합니다.

### Capabilities의 핵심 개념

Capabilities는 루트 권한을 약 40개의 독립적인 권한 조각으로 분할합니다. 각 프로세스는 다음 다섯 가지 Capabilities 집합을 통해 권한을 관리합니다:

1. **Permitted(P)**: 프로세스가 가질 수 있는 Capabilities의 상한선입니다. 이 집합에 없는 Capability는 어떤 경우에도 획득할 수 없습니다.
2. **Effective(E)**: 실제로 권한이 행사되는 Capabilities 집합입니다.
3. **Inheritable(I)**: `execve()` 시스템 호출을 통해 자식 프로세스로 전달될 수 있는 Capabilities입니다.
4. **Ambient(A)**: 사용자 네임스페이스와 비특권 실행 환경에서도 유지될 수 있는 최신 전이 메커니즘입니다.
5. **Bounding(B)**: 시스템 전역 상한선으로, 이 집합에서 제외된 Capability는 어떤 방식으로도 획득할 수 없습니다.

**실무 적용 팁**: 운영 중인 시스템에서는 먼저 Bounding Set를 제한하여 시스템 전체의 Capabilities 상한을 낮춘 후, 각 서비스별로 필요한 최소한의 Effective 및 Ambient Capabilities만 부여하는 접근이 효과적입니다.

### 주요 Capabilities 및 활용 사례

| Capability | 주요 기능 | 사용 사례 및 주의사항 |
|---|---|---|
| `CAP_NET_BIND_SERVICE` | 1024 미만의 포트에 바인딩 | 웹 서버, 프록시 서버 등 표준 포트 사용 시 필요 |
| `CAP_NET_RAW` | raw 소켓 생성 및 사용 | `ping`, `traceroute` 등 네트워크 진단 도구 |
| `CAP_SYS_TIME` | 시스템 시간 변경 | 시간 동기화 서비스, 일반 컨테이너에서는 제거 권장 |
| `CAP_SYS_ADMIN` | 시스템 관리 권한 (사실상 루트와 동등) | 가능한 한 사용하지 않도록 권장 |
| `CAP_DAC_OVERRIDE` | 파일 접근 제어 무시 | 보안 위험도가 높으므로 신중히 사용 |
| `CAP_CHOWN` | 파일 소유자 변경 | 파일 마이그레이션 도구 등 특수한 경우에만 필요 |

### Capabilities 관리 명령어

```bash
# 현재 셸의 Capabilities 상태 확인
capsh --print

# 바이너리 파일에 Capability 부여 (예: ping 명령어)
sudo setcap cap_net_raw+ep /bin/ping

# 파일에 부여된 Capabilities 확인
getcap /bin/ping
```

Capability 부여 시 사용되는 주요 플래그:
- `+e`: Effective Capability로 설정
- `+p`: Permitted Capability로 설정  
- `+i`: Inheritable Capability로 설정

파일 Capabilities는 실행 파일에 직접 설정되어, 해당 파일이 실행될 때 프로세스에 특정 Capabilities를 부여할 수 있습니다. 이는 전통적인 setuid 방식을 대체하는 더 안전한 방법입니다.

### Securebits와 keepcaps

`prctl(PR_SET_KEEPCAPS, 1)` 시스템 호출을 사용하면 사용자 ID 전환 후에도 Capabilities를 유지할 수 있습니다. 이는 데몬이 권한을 낮추는(drop privileges) 패턴에서 유용하게 사용됩니다. `no_new_privs`(NnP) 플래그와 함께 사용하면 `execve()`를 통한 권한 상승을 효과적으로 억제할 수 있습니다.

---

## seccomp: 시스템 호출 제한을 통한 공격 표면 최소화

seccomp(Secure Computing Mode)는 프로세스가 실행할 수 있는 시스템 호출을 제한하는 커널 보안 기능입니다. 이를 통해 공격자가 악용할 수 있는 시스템 호출의 수를 최소화할 수 있습니다.

### seccomp 동작 모드

1. **STRICT 모드**: `read`, `write`, `exit`, `sigreturn` 시스템 호출만 허용합니다. 현대 애플리케이션에는 너무 제한적일 수 있습니다.
2. **FILTER 모드 (BPF 기반)**: Berkeley Packet Filter 프로그램을 사용하여 시스템 호출을 정밀하게 제어합니다. 허용, 거부, 오류 반환, 프로세스 종료, 로깅, 추적 등의 다양한 액션을 지정할 수 있습니다.

### 허용 목록(Allowlist) 설계 원칙

효과적인 seccomp 정책 설계를 위한 단계적 접근법:

1. **실행 경로 분석**: `strace`를 사용하여 애플리케이션의 시스템 호출 패턴을 분석합니다.
2. **허용 목록 구성**: 실제로 필요한 시스템 호출만 허용 목록에 포함시킵니다.
3. **인자 검증**: 시스템 호출의 인자를 검증하여 악의적인 사용을 방지합니다.

### C 언어 예제: libseccomp를 이용한 시스템 호출 필터링

```c
// 컴파일: gcc -Wall -lseccomp -o demo_seccomp demo_seccomp.c
#include <seccomp.h>
#include <stdio.h>
#include <unistd.h>

int main(void) {
    // 기본 정책: 시스템 호출 거부 시 프로세스 종료
    scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL);
    if (!ctx) return 1;

    // 필수 시스템 호출 허용
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(futex), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(clock_gettime), 0);

    // openat 시스템 호출 제한: 쓰기 모드로 열기 시도 시 EACCES 반환
    seccomp_rule_add(ctx, SCMP_ACT_ERRNO(13), SCMP_SYS(openat), 1,
        SCMP_A1(SCMP_CMP_MASKED_EQ, O_WRONLY|O_RDWR, O_WRONLY|O_RDWR));
    
    // 읽기 전용 모드의 openat 허용
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(openat), 0);

    // 필터 적용
    seccomp_load(ctx);
    seccomp_release(ctx);

    // 애플리케이션 작업 수행
    write(1, "hello\n", 6);
    return 0;
}
```

### Docker와 Kubernetes에서의 seccomp 활용

```bash
# Docker에서 기본 seccomp 프로파일 사용
docker run --rm --security-opt seccomp=default \
  --cap-drop=ALL --cap-add=NET_BIND_SERVICE \
  nginx:alpine
```

**보안 강화 전략**: Capabilities 최소화와 기본 seccomp 프로파일의 조합만으로도 공격 표면을 크게 줄일 수 있습니다. Kubernetes에서는 Pod 또는 Container 수준에서 SeccompProfile을 지정할 수 있으며, 이는 런타임과 버전에 따라 다소 상이할 수 있습니다.

---

## ptrace 제어: YAMA를 통한 디버깅 접근 관리

ptrace는 프로세스 디버깅을 위한 강력한 도구이지만, 악용될 경우 보안 위협이 될 수 있습니다. YAMA(Yet Another Module for ptrace Access Restriction)는 이러한 위험을 관리하는 Linux 보안 모듈입니다.

### YAMA 설정 및 관리

```bash
# 현재 ptrace 정책 확인
cat /proc/sys/kernel/yama/ptrace_scope

# ptrace 접근 제한 설정 (권장값: 1)
echo 1 | sudo tee /proc/sys/kernel/yama/ptrace_scope

# 영구적 설정
echo "kernel.yama.ptrace_scope=1" | sudo tee /etc/sysctl.d/10-ptrace.conf
sudo sysctl --system
```

### YAMA 정책 수준

| 값 | 의미 | 권장 사용처 |
|---|---|---|
| 0 | 무제한 ptrace 허용 | 개발 및 디버깅 환경 |
| 1 | 동일 사용자 ID 프로세스만 ptrace 허용 | **기본 권장 설정** |
| 2 | 자식 프로세스에만 ptrace 허용 | 높은 보안 요구사항 환경 |
| 3 | 모든 ptrace 금지 | 매우 엄격한 보안 환경 |

### 추가적인 보호 메커니즘

- `prctl(PR_SET_DUMPABLE, 0)`: 코어 덤프 생성 및 디버깅을 방지합니다.
- `/proc` 마운트 옵션: `hidepid=2`로 다른 사용자의 프로세스 정보를 숨기고, `kptr_restrict=2`로 커널 심볼 정보 노출을 제한합니다.
- 민감한 서비스 구성: `NoNewPrivileges=yes`, seccomp, 최소 Capabilities의 조합으로 보안을 강화합니다.

---

## systemd 보안 속성: 통합 보안 관리

systemd는 서비스 관리뿐만 아니라 강력한 보안 기능도 제공합니다. 서비스 유닛 파일을 통해 다양한 보안 속성을 설정할 수 있습니다.

### 보안 강화된 서비스 유닛 예제

```ini
# /etc/systemd/system/app.service
[Unit]
Description=Hardened Application Service

[Service]
ExecStart=/usr/local/bin/app
User=app
Group=app

# Capabilities 관리: NET_BIND_SERVICE만 허용
CapabilityBoundingSet=CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_BIND_SERVICE

# 권한 상승 방지
NoNewPrivileges=yes

# 파일 시스템 보호
ProtectSystem=strict
ProtectHome=yes
PrivateTmp=yes
PrivateDevices=yes
ProtectKernelTunables=yes
ProtectKernelModules=yes
ProtectControlGroups=yes

# 시스템 호출 필터링 (허용 목록 기반)
SystemCallFilter=@system-service @network-io ~keyring
SystemCallArchitectures=native

# 네트워크 주소 패밀리 제한 (IPv4/IPv6만 허용)
RestrictAddressFamilies=AF_INET AF_INET6

# 네임스페이스 기반 격리
PrivateMounts=yes

[Install]
WantedBy=multi-user.target
```

이러한 설정을 통해 Capabilities, seccomp, 마운트 네임스페이스, 파일 시스템 보호 등 다양한 보안 메커니즘을 서비스 수준에서 일관되게 적용할 수 있습니다.

### 임시 제한 적용을 통한 테스트

```bash
# 제한된 환경에서 애플리케이션 테스트 실행
systemd-run -t \
  -p MemoryMax=150M -p CPUQuota=80% \
  -p CapabilityBoundingSet=CAP_NET_BIND_SERVICE \
  -p AmbientCapabilities=CAP_NET_BIND_SERVICE \
  -p NoNewPrivileges=yes \
  /usr/local/bin/app --foreground
```

---

## 실전 적용 시나리오

### 시나리오 1: 낮은 번호 포트 바인딩

```bash
# 파일 Capabilities 방식
sudo setcap cap_net_bind_service=+ep /usr/local/bin/myweb

# systemd Ambient Capabilities 방식
# 서비스 유닛 파일에서 AmbientCapabilities=CAP_NET_BIND_SERVICE 지정
```

이러한 접근 방식을 통해 setuid root 없이도 1024 미만의 포트를 사용할 수 있습니다.

### 시나리오 2: 읽기 전용 파일 시스템과 제한된 시스템 호출

```bash
# 시스템 파일 보호 및 특정 디렉터리만 쓰기 허용
ProtectSystem=strict
ReadWritePaths=/var/lib/myapp

# 시스템 호출 필터링 (기본 I/O, 파일 시스템, 시그널 관련 호출만 허용)
SystemCallFilter=@basic-io @file-system @signal ~mount ptrace add_key keyctl
NoNewPrivileges=yes
```

### 시나리오 3: 네트워크 raw 소켓과 ptrace 완전 차단

```bash
# 위험한 Capabilities 제외
CapabilityBoundingSet=~CAP_NET_RAW CAP_SYS_PTRACE

# 위험한 시스템 호출 차단
SystemCallFilter=~ptrace process_vm_readv process_vm_writev
```

systemd 구문에서 `~`는 해당 항목을 제외한다는 의미입니다.

---

## 모니터링과 문제 해결

### 보안 이벤트 모니터링

```bash
# seccomp 거부 이벤트 확인
journalctl -k | grep -i seccomp

# audit 로그 확인 (활성화된 경우)
ausearch -m USER_AVC,AVC -ts recent

# 서비스별 보안 분석
systemd-analyze security app.service
```

### 시스템 호출 프로파일링

```bash
# 애플리케이션의 시스템 호출 패턴 분석
strace -f -o /tmp/app.trace /usr/local/bin/app --once
```

분석 결과를 바탕으로 필요한 시스템 호출 목록을 추출하여 허용 목록 기반의 seccomp 정책을 설계할 수 있습니다.

---

## 컨테이너 환경에서의 적용

```bash
# Docker를 이용한 보안 강화 컨테이너 실행
docker run --rm \
  --read-only \
  -v app-data:/var/lib/app \
  --cap-drop=ALL --cap-add=NET_BIND_SERVICE \
  --security-opt no-new-privileges \
  --security-opt seccomp=default \
  --pids-limit=256 \
  --memory=256m --memory-swap=256m \
  --cpus=1.0 \
  -p 80:80 app:latest
```

**핵심 보안 원칙**:
1. 읽기 전용 루트 파일 시스템
2. 모든 Capabilities 제거 후 필요한 것만 추가
3. 권한 상승 방지
4. 기본 seccomp 프로파일 적용
5. cgroup 기반 리소스 제한

---

## 보안 효과 수학적 모델

보안 강화의 효과를 단순화하여 수학적으로 표현해볼 수 있습니다. 시스템 호출 허용 개수를 \( N \)으로, 각 시스템 호출의 취약점 존재 확률을 \( p_i \)라고 할 때, 보안 위반 가능성은 다음과 같이 근사할 수 있습니다:

$$
\text{보안 위반 가능성} \approx 1 - \prod_{i=1}^{N} (1 - p_i)
$$

이 모델에서 허용 시스템 호출 수 \( N \)을 줄이고(seccomp 허용 목록), 각 호출의 위험도 \( p_i \)가 높은 것(예: `ptrace`, `keyctl`, `mount`)을 제거하면 보안 위험은 지수적으로 감소합니다.

---

## 문제 해결 가이드

| 증상 | 가능한 원인 | 해결 방안 |
|---|---|---|
| 80포트 바인딩 실패 | Capability 부족 또는 권한 상승 차단 | `CAP_NET_BIND_SERVICE` Capability 부여 (파일 또는 Ambient 방식) |
| 파일 쓰기 실패 | `ProtectSystem=strict`로 인한 루트 파일 시스템 읽기 전용 | `ReadWritePaths`로 쓰기 허용 경로 명시적 지정 |
| 라이브러리 로드 실패 | `SystemCallFilter`가 `openat` 또는 `mmap`의 특정 인자 차단 | `strace`로 실제 호출 패턴 분석 후 정책 조정 |
| 디버깅 불가능 | `ptrace_scope` 설정이 너무 제한적 | 운영 환경에서는 유지, 개발/디버깅 노드에서만 완화 |
| ping 명령 실패 | `CAP_NET_RAW` Capability 필요 | 파일 Capability 부여 또는 컨테이너에서 `cap-add` |

---

## 실습 예제: 종합적인 보안 샌드박스 구현

### 단계별 구현 프로세스

```bash
# 1. 애플리케이션 시스템 호출 패턴 분석
strace -f -o trace.log ./mytool --once

# 2. 필요한 Capabilities 부여
sudo setcap cap_net_bind_service+ep /usr/local/bin/mytool

# 3. systemd 서비스 유닛 생성
cat > /etc/systemd/system/mytool.service << 'UNIT'
[Unit]
Description=Hardened MyTool Service

[Service]
ExecStart=/usr/local/bin/mytool
User=mytool
Group=mytool
NoNewPrivileges=yes
CapabilityBoundingSet=CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_BIND_SERVICE
ProtectSystem=strict
ReadWritePaths=/var/lib/mytool
SystemCallFilter=@system-service @network-io ~ptrace keyctl
PrivateTmp=yes
PrivateDevices=yes

[Install]
WantedBy=multi-user.target
UNIT

# 4. 서비스 활성화
sudo systemctl daemon-reload
sudo systemctl enable --now mytool
```

---

## systemd 보안 속성 요약

| 속성 | 기능 | 권장 설정 |
|---|---|---|
| `NoNewPrivileges=yes` | execve를 통한 권한 상승 방지 | 항상 활성화 권장 |
| `CapabilityBoundingSet=` | 프로세스가 사용 가능한 Capabilities 상한 | 최소한의 Capabilities만 지정 |
| `AmbientCapabilities=` | exec 후에도 유지할 Capabilities | 필요한 Capabilities만 지정 |
| `SystemCallFilter=` | seccomp 기반 시스템 호출 필터 | 허용 목록 방식 권장 |
| `ProtectSystem=` | 시스템 파일 보호 | `strict` 또는 `full` 권장 |
| `ProtectHome=` | 사용자 홈 디렉터리 보호 | `yes` 또는 `read-only` 권장 |
| `PrivateTmp=` | 독립적인 /tmp 디렉터리 제공 | 항상 활성화 권장 |
| `PrivateDevices=` | 장치 노드 접근 제한 | 항상 활성화 권장 |
| `RestrictAddressFamilies=` | 허용 네트워크 주소 패밀리 | `AF_INET AF_INET6` (IPv4/IPv6만) |
| `MemoryMax`/`CPUQuota`/`TasksMax` | cgroup 기반 리소스 제한 | 서비스 요구사항에 맞게 설정 |

---

## 결론

리눅스 커널 보안은 다층적 접근 방식을 통해 효과적으로 구현될 수 있습니다. 세 가지 핵심 기술을 체계적으로 적용하는 것이 중요합니다:

1. **Linux Capabilities**: "무엇을 할 수 있는 권한이 있는가"를 세분화하여 필요한 최소한의 권한만 부여합니다.
2. **seccomp**: "커널에 어떤 요청을 할 수 있는가"를 시스템 호출 수준에서 제어합니다.
3. **ptrace/YAMA**: "누가 프로세스를 관찰하고 제어할 수 있는가"를 관리합니다.

systemd의 보안 속성은 이러한 기술들을 운영 표준으로 통합하여 일관되게 적용할 수 있게 해줍니다. 서비스마다 정량화된 최소 권한 정책을 구축하고, 지속적인 모니터링과 조정을 통해 보안 수준을 유지하는 것이 현대 리눅스 시스템 운영의 핵심입니다.

보안은 단일 기술이나 도구가 아닌, 체계적인 접근 방식과 지속적인 개선 과정임을 기억해야 합니다. 각 서비스의 특성과 위험 모델을 분석하여 적절한 보안 조치를 적용하고, 실제 운영 환경에서의 영향을 꾸준히 모니터링하여 최적의 보안 구성을 찾아가는 것이 중요합니다.