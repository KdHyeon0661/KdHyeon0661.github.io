---
layout: post
title: Linux - 커널 보안 및 권한 제어
date: 2024-12-01 19:20:23 +0900
category: Linux
---
# 리눅스 30편: 커널 보안 및 권한 제어

## Linux Capabilities — 루트 권한을 조각내어 최소화

### Capabilities 핵심 개념

- **루트 권한을 세분화**한 비트 플래그 집합. 전통적 setuid 대신, 필요한 조각만 부여.
- 프로세스는 다음 **5개 집합**으로 권한을 갖는다.
  - **Permitted(P)**: 보유할 수 있는 상한. Effective로 올릴 수 있는 후보군.
  - **Effective(E)**: 실제 권한이 행사되는 집합.
  - **Inheritable(I)**: `execve` 시 하위 프로세스로 **전이 가능한** 집합.
  - **Ambient(A)**: **user namespace/무권한 exec**에서도 유지 가능한 최신 전이 메커니즘.
  - **Bounding(B)**: **시스템 전역 상한**. 이 집합에서 제거되면 어떤 방식으로도 획득 불가(부팅 후 system-wide).

> 실무 요령: 운영 중인 서비스를 **BoundingSet로 상한을 먼저 깎고**, 각 서비스 단위로 **Effective/Ambient 최소 세트**를 지정한다.

### 대표 Capability와 주의점

| Capability | 효과 | 비고 |
|---|---|---|
| `CAP_NET_BIND_SERVICE` | 1024 미만 포트 바인딩 | 웹/프록시 등 80, 443 필요 시 |
| `CAP_NET_RAW` | raw 소켓 | `ping`, 저수준 네트워킹 |
| `CAP_SYS_TIME` | 시스템 시간 설정 | 컨테이너에 불필요, 제거 권장 |
| `CAP_SYS_ADMIN` | **과다 권한**(사실상 root) | 가능하면 절대 사용하지 말 것 |
| `CAP_DAC_OVERRIDE` | DAC 우회(읽기/쓰기 검사 무시) | 침투면 확장 위험 큼 |
| `CAP_CHOWN` | 파일 소유자 변경 | 특정 마이그레이션 도구만 |

### 현재 프로세스·바이너리 Capabilities 확인/부여

```bash
# 현재 셸의 capability 상태

capsh --print

# 바이너리에 파일 capability 부여(예: ping)

sudo setcap cap_net_raw+ep /bin/ping

# 부여 결과 확인

getcap /bin/ping
```
- `+e`(Effective), `+p`(Permitted), `+i`(Inheritable).
- 파일 Capability는 실행 시 프로세스 E/P에 반영된다. setuid 대체에 유용.

### Securebits와 keepcaps

- `prctl(PR_SET_KEEPCAPS, 1)`로 **UID 전환 후에도** caps 유지 가능(데몬 드랍-권한 패턴).
- `no_new_privs`(NnP)와 조합: **execve로 특권 상승 억제**.

---

## seccomp — 시스템콜 표면을 최소화하는 BPF 필터

### 모드와 개요

- **STRICT**: `read`, `write`, `exit`, `sigreturn`만 허용(현대 서비스에는 실용성 낮음).
- **FILTER(BPF)**: BPF 프로그램으로 syscall **허용/거부/errno/kill/log/trace/user_notif** 등 **정밀 제어**.
  - 반환코드 예: `SECCOMP_RET_ALLOW`, `…_KILL_PROCESS`, `…_ERRNO(EPERM)`, `…_TRACE`, `…_LOG`, `…_USER_NOTIF`.

### 최소 허용 셋 설계 원칙

1. **실행 경로 수집**: `strace -f -o trace.log`로 워크로드의 syscall 카탈로그화.
2. **허용 목록(allowlist)**: 필요한 syscall만 열고 나머지 전부 봉쇄.
3. **아키/아규먼트** 필터: `arch`(x86_64 등) 고정, 위험 인자(예: `clone3` 플래그) 검증.

### C 예제: libseccomp로 간결 허용 목록 구성

```c
// build: gcc -Wall -lseccomp -o demo_seccomp demo_seccomp.c
#include <seccomp.h>
#include <stdio.h>
#include <unistd.h>

int main(void) {
    scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); // 기본: kill
    if (!ctx) return 1;

    // 필수 syscall 허용
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(futex), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(clock_gettime), 0);

    // 예: openat은 읽기 전용만 허용
    seccomp_rule_add(ctx, SCMP_ACT_ERRNO(13), SCMP_SYS(openat), 1,
        SCMP_A1(SCMP_CMP_MASKED_EQ, O_WRONLY|O_RDWR, O_WRONLY|O_RDWR));
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(openat), 0);

    // 적용
    seccomp_load(ctx);
    seccomp_release(ctx);

    // 워크로드
    write(1, "hello\n", 6);
    return 0;
}
```

### Docker/K8s에서의 seccomp

```bash
# 기본 프로파일(대부분의 위험 콜 차단)

docker run --rm --security-opt seccomp=default \
  --cap-drop=ALL --cap-add=NET_BIND_SERVICE \
  nginx:alpine
```
- **capabilities 최소화 + seccomp 기본 프로파일**만으로도 공격면 대폭 축소.
- K8s는 `pod`/`container` 단위로 SeccompProfile 지정 가능(런타임·버전에 따라 경로/기능 상이).

---

## ptrace — 디버깅의 칼날을 둔화시키는 YAMA 정책

### ptrace 개요

- 다른 프로세스의 **레지스터/메모리/시스템콜**을 관측·변경. `strace`, `gdb` 등이 사용.
- 악용 시 비밀 데이터 탈취·코드 주입 우려 → **YAMA LSM**으로 기본 제한.

### YAMA 설정

```bash
# 현재 정책

cat /proc/sys/kernel/yama/ptrace_scope

# 권장: 1(동일 사용자만), 또는 2(직계 자식만). 3은 완전 차단.

echo 1 | sudo tee /proc/sys/kernel/yama/ptrace_scope

# 영구화

echo "kernel.yama.ptrace_scope=1" | sudo tee /etc/sysctl.d/10-ptrace.conf
sudo sysctl --system
```

| 값 | 의미 |
|---|---|
| 0 | 무제한 |
| 1 | **동일 UID**만 추적(기본) |
| 2 | **자식 프로세스**만 |
| 3 | 완전 차단 |

### 추가 경감책

- `prctl(PR_SET_DUMPABLE, 0)`로 코어덤프·디버깅 거부.
- `/proc` 마운트에 `hidepid=2`(프로세스 은닉), `kptr_restrict=2`(커널 심볼 노출 억제).
- 민감 서비스는 `NoNewPrivileges=yes` + seccomp + capabilities 최소화.

---

## systemd 보안 속성 — 고급 정책을 한 줄로

### 최소 권한 유닛 파일 예시

```ini
# /etc/systemd/system/app.service

[Unit]
Description=Hardened App

[Service]
ExecStart=/usr/local/bin/app
User=app
Group=app
# capabilities: NET_BIND_SERVICE만 필요하다고 가정

CapabilityBoundingSet=CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_BIND_SERVICE
# 특권 상승 차단

NoNewPrivileges=yes
# 파일시스템 보호

ProtectSystem=strict
ProtectHome=yes
PrivateTmp=yes
PrivateDevices=yes
ProtectKernelTunables=yes
ProtectKernelModules=yes
ProtectControlGroups=yes
# 시스템콜 필터(허용 목록 기반)

SystemCallFilter=@system-service @network-io ~keyring
SystemCallArchitectures=native
# 주소 패밀리 제한(IPv4/6만)

RestrictAddressFamilies=AF_INET AF_INET6
# 네임스페이스 기반 격리

PrivateMounts=yes

[Install]
WantedBy=multi-user.target
```
> 한 줄 요약: **capabilities·seccomp·mount/user 네임스페이스·파일시스템 보호**까지 **유닛 수준**에서 끝낸다.

### 임시로 제한 걸고 실행

```bash
# 150MB, 80% CPU, 바인드 권한만, 특권 상승 금지

systemd-run -t \
  -p MemoryMax=150M -p CPUQuota=80% \
  -p CapabilityBoundingSet=CAP_NET_BIND_SERVICE \
  -p AmbientCapabilities=CAP_NET_BIND_SERVICE \
  -p NoNewPrivileges=yes \
  /usr/local/bin/app --foreground
```

---

## 실전 시나리오 — 패턴으로 익히는 최소 권한

### 저권한 웹서버(80/443) 바인드

```bash
# (A) 파일 capability 방식

sudo setcap cap_net_bind_service=+ep /usr/local/bin/myweb

# (B) systemd ambient 방식
# 유닛 파일에서 AmbientCapabilities=CAP_NET_BIND_SERVICE 지정

```
- setuid root 없이 1024 미만 포트 사용 가능.

### 백엔드 작업자: 쓰기 금지 FS + 제한된 syscall

```bash
# Read-only root + 쓰기 가능한 특정 디렉터리만

ProtectSystem=strict
ReadWritePaths=/var/lib/myapp
SystemCallFilter=@basic-io @file-system @signal ~mount ptrace add_key keyctl
NoNewPrivileges=yes
```

### 데이터 수집기: raw 소켓 금지, ptrace 완전 봉쇄

```bash
CapabilityBoundingSet=~CAP_NET_RAW CAP_SYS_PTRACE
SystemCallFilter=~ptrace process_vm_readv process_vm_writev
```
- `~`는 제외 의미(systemd 구문).

---

## 관측과 디버깅 — 정책의 안착을 수치로 확인

### 보안 이벤트 확인

```bash
# seccomp 거부 로그(journal)

journalctl -k | grep -i seccomp

# audit(있다면)

ausearch -m USER_AVC,AVC -ts recent

# 유닛별 sandbox 보고

systemd-analyze security app.service
```

### strace로 사전 프로파일링

```bash
strace -f -o /tmp/app.trace /usr/local/bin/app --once
# -> 필요한 syscall 목록 뽑아 allowlist 설계

```

---

## 컨테이너와의 접점 — 런타임 옵션 총정리

```bash
# Docker 예시: 거의 기본 보안 모범

docker run --rm \
  --read-only \
  -v app-data:/var/lib/app \
  --cap-drop=ALL --cap-add=NET_BIND_SERVICE \
  --security-opt no-new-privileges \
  --security-opt seccomp=default \
  --pids-limit=256 \
  --memory=256m --memory-swap=256m \
  --cpus=1.0 \
  -p 80:80 app:latest
```
- 핵심: **read-only root**, **cap-drop 기본(ALL)**, **필요한 cap만 add**, **seccomp 기본**, **리소스 상한(cgroup)**.

---

## 위험 모델과 수학 한 컷

### 권한 표면 최소화 직관

**공격 표면(Attack Surface)**를 단순화해보자.
허용된 시스템콜 수를 \( N \), 각 syscall의 취약 확률을 \( p_i \)라고 할 때,
$$
\text{Breach Risk} \approx 1 - \prod_{i=1}^{N} (1 - p_i)
$$
허용 콜 수 \(N\)을 줄이고(=seccomp allowlist), 각 콜의 위험 \(p_i\)가 큰 것(예: `ptrace`, `keyctl`, `mount`)을 제거하면 **위험이 지수적으로 감소**한다.

---

## 체크리스트 — 배포 전 마지막 점검

- [ ] **CapabilityBoundingSet 최소화**: `CAP_SYS_ADMIN` 금지, `CAP_NET_RAW` 필요 시 신중.
- [ ] **AmbientCapabilities 필요한 것만**.
- [ ] **NoNewPrivileges=yes** 적용.
- [ ] **SystemCallFilter**로 allowlist(또는 위험콜 denylist라도 우선 적용).
- [ ] **ProtectSystem=strict / ReadWritePaths=…**로 FS 엄격화.
- [ ] **PrivateTmp/Devices/Mounts**로 네임스페이스 격리.
- [ ] **ptrace_scope ≥ 1** 및 `hidepid=2`, `kptr_restrict=2`.
- [ ] **strace 사전 수집 → seccomp 프로파일 수립**.
- [ ] **유닛별 systemd-analyze security 점수 확인**.
- [ ] **컨테이너**: `--cap-drop=ALL`, read-only root, seccomp 기본, cgroup limits.

---

## 트러블슈팅

| 증상 | 원인 | 해결 |
|---|---|---|
| 서비스가 80 포트 바인드 실패 | cap 없음, NnP로 특권 전이 차단 | `CAP_NET_BIND_SERVICE` 부여(파일 또는 Ambient) |
| 파일 쓰기 실패 | `ProtectSystem=strict`로 rootfs 읽기 전용 | `ReadWritePaths=/var/lib/…`로 쓰기 경로 화이트리스트 |
| 라이브러리 로드 실패 | `SystemCallFilter`가 `openat`/`mmap` 인자 차단 | trace로 인자 패턴 확인, 조건 완화 |
| 디버깅 불가 | `ptrace_scope` 강화 | 운영 경로에서는 유지, 디버그 노드만 완화 |
| ping 실행 실패 | `CAP_NET_RAW` 필요 | 파일 cap 또는 컨테이너 cap-add |

---

## 실습 패키지 — 최소 샌드박스 샘플

### 샌드박스 바이너리(파일 cap + seccomp)

```bash
# 필요한 syscall 수집

strace -f -o trace.log ./mytool --once

# seccomp 프로파일(런타임 기본) + 파일 capability 부여

sudo setcap cap_net_bind_service+ep /usr/local/bin/mytool

# systemd 유닛에서 추가 보호

cat >/etc/systemd/system/mytool.service <<'UNIT'
[Unit]
Description=MyTool (hardened)

[Service]
ExecStart=/usr/local/bin/mytool
User=mytool
Group=mytool
NoNewPrivileges=yes
CapabilityBoundingSet=CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_BIND_SERVICE
ProtectSystem=strict
ReadWritePaths=/var/lib/mytool
SystemCallFilter=@system-service @network-io ~ptrace keyctl
PrivateTmp=yes
PrivateDevices=yes

[Install]
WantedBy=multi-user.target
UNIT

sudo systemctl daemon-reload
sudo systemctl enable --now mytool
```

---

## 부록 A. 자주 쓰는 systemd 보안 속성 요약

| 속성 | 효과 |
|---|---|
| `NoNewPrivileges=yes` | execve 특권 상승 금지 |
| `CapabilityBoundingSet=` | 프로세스가 쓸 수 있는 cap 상한 |
| `AmbientCapabilities=` | exec 뒤에도 유지할 cap 지정 |
| `SystemCallFilter=` | seccomp 기반 syscall 필터 |
| `SystemCallArchitectures=` | 아키 제한 |
| `ProtectSystem=` | FS 읽기전용(=full/strict 권장) |
| `ProtectHome=` | 홈 디렉터리 격리 |
| `PrivateTmp=` | /tmp 네임스페이스 분리 |
| `PrivateDevices=` | 디바이스 노출 최소화 |
| `ProtectKernel*=` | 커널 인터페이스 보호 |
| `RestrictAddressFamilies=` | 허용 네트워크 패밀리만 |
| `LockPersonality=` | ABI 변경 금지 |
| `MemoryMax/CPUQuota/TasksMax` | cgroup 한도 |

---

## 부록 B. 선택적으로 알아둘 것

- **seccomp user notification**: 커널이 사용자 데몬에 “승인/거부” 질의(프록시형 샌드박스). 고급 정책에 유용.
- **Landlock LSM**: 비특권 파일시스템 접근 정책(추가 LSM, 커널 버전 요함).
- **LSM 계층**(SELinux/AppArmor)과 병행: **DAC → LSM → seccomp** 순서 고려.

---

## 마무리

커널 보안 3종 세트:
- **Capabilities**로 “무엇을 할 자격이 있는가”를 조각내어 **최소 집합**만 부여한다.
- **seccomp**로 “무엇을 커널에 요청할 수 있는가”를 시스템콜 단에서 **차단**한다.
- **ptrace/YAMA**로 “누가 나를 주시·조작할 수 있는가”를 **통제**한다.

그리고 **systemd 보안 속성**은 이 모든 걸 **운영 표준**으로 **일관되게 배포**하게 해준다.
이 편의 스니펫을 바로 적용해, 서비스마다 **정량화된 최소 권한 정책**을 구축하자.
