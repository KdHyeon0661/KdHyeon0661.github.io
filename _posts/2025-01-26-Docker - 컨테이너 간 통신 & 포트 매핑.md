---
layout: post
title: Docker - 컨테이너 간 통신 & 포트 매핑
date: 2025-01-26 21:20:23 +0900
category: Docker
---
# Docker: 컨테이너 간 통신과 포트 매핑 가이드

## 개요

Docker 네트워킹은 컨테이너 간 통신과 외부 접근을 관리하는 핵심 기능입니다. 이 가이드에서는 컨테이너가 서로 통신하는 방법과 호스트 시스템을 통해 외부에 서비스를 공개하는 포트 매핑 기술을 다룹니다. 네트워크 동작 원리, 실용적인 설정 패턴, 문제 해결 방법까지 종합적으로 설명합니다.

---

## 기본 개념 이해

### 컨테이너 네트워킹
Docker 컨테이너는 리눅스 네트워크 네임스페이스를 사용하여 격리된 가상 네트워크 환경에서 실행됩니다. 기본적으로 Docker는 `bridge`라는 가상 네트워크 드라이버를 사용하며, 이는 `docker0`라는 가상 스위치를 중심으로 작동합니다.

### 컨테이너 간 통신
동일한 사용자 정의 브리지 네트워크에 연결된 컨테이너들은 서로의 이름으로 직접 통신할 수 있습니다. Docker의 내장 DNS 서버(127.0.0.11)가 컨테이너 이름을 IP 주소로 변환해줍니다.

### 포트 매핑
컨테이너 내부에서 실행 중인 서비스를 외부에 공개하려면 포트 매핑을 사용합니다. 호스트 시스템의 특정 포트를 컨테이너의 포트로 연결하여 외부에서 접근할 수 있게 합니다.

### Host 네트워크 모드
컨테이너를 호스트의 네트워크 스택과 공유하는 모드로, 포트 매핑이 필요 없지만 보안 경계가 약화되고 포트 충돌 가능성이 있습니다.

---

## Docker 네트워크 드라이버

| 드라이버 | 사용 맥락 | 주요 특징 |
|---|---|---|
| `bridge` (기본) | 단일 호스트 내 대부분의 서비스 | 포트 매핑으로 외부 접근 제어, 사용자 정의 브리지 권장 |
| `host` | 성능 최적화가 필요한 경우 | 컨테이너가 호스트 네트워크를 직접 사용 |
| `none` | 네트워크 완전 격리 | 외부 네트워크 접근 불가 |
| `overlay` | 다중 호스트 환경 (Swarm) | 여러 Docker 호스트 간 네트워킹 |
| `macvlan` | 물리적 네트워크와 직접 통합 | 컨테이너가 물리적 네트워크의 독립 장치처럼 동작 |

---

## 컨테이너 간 통신: 사용자 정의 브리지 네트워크

### 기본 원리
사용자 정의 브리지 네트워크를 생성하면 해당 네트워크에 연결된 컨테이너들은 서로의 이름으로 직접 통신할 수 있습니다. 이는 기본 `bridge` 네트워크보다 향상된 DNS 기능과 네트워크 격리를 제공합니다.

### 실습: 사용자 정의 브리지 생성 및 컨테이너 통신

```bash
# 네트워크 생성
docker network create appnet

# 데이터베이스 컨테이너 실행
docker run -d --name db --network appnet \
  -e POSTGRES_PASSWORD=secret postgres:15

# 웹 서버 컨테이너 실행
docker run -d --name web --network appnet nginx:alpine

# 웹 컨테이너에서 데이터베이스 연결 테스트
docker exec -it web sh -lc "nslookup db 127.0.0.11"
```

### DNS 확인
사용자 정의 브리지 네트워크의 컨테이너들은 내장 DNS 서버를 통해 서로의 이름을 확인할 수 있습니다.

```bash
# 컨테이너 내부에서 DNS 설정 확인
docker exec -it web sh -lc "cat /etc/resolv.conf && nslookup db 127.0.0.11"
```

---

## 포트 매핑: 외부 접근 설정

### 기본 사용법

```bash
# 기본 포트 매핑 (호스트 8080 → 컨테이너 80)
docker run -d -p 8080:80 nginx

# 다중 포트 매핑
docker run -d -p 8080:80 -p 8443:443 nginx
```

### 고급 포트 매핑 옵션

```bash
# 특정 IP 주소에만 바인딩
docker run -d -p 127.0.0.1:8080:80 nginx  # 로컬호스트에서만 접근 가능

# 임의 포트 자동 할당
docker run -d -P nginx  # Dockerfile의 EXPOSE 포트를 임의 호스트 포트에 매핑

# 할당된 포트 확인
docker port <컨테이너이름>
```

### 명시적 구문 사용

```bash
docker run -d --publish 8080:80/tcp nginx
```

---

## 네트워크 아키텍처 이해

Docker의 브리지 네트워킹은 다음과 같은 방식으로 작동합니다:

```
[외부] ──> (호스트:8080) ──DNAT/iptables──> [docker0] ──> [컨테이너:80]
                       <──SNAT(응답)──────
```

- 외부에서 들어오는 패킷은 iptables의 NAT 규칙에 의해 컨테이너의 IP 주소로 변환(DNAT)됩니다.
- 컨테이너에서 나가는 응답은 호스트의 IP 주소로 변환(SNAT/MASQUERADE)되어 외부로 전달됩니다.
- 동일 브리지 네트워크 내의 컨테이너들은 L2 스위칭을 통해 직접 통신합니다.

### 네트워크 동작 관찰

```bash
# NAT 규칙 확인
iptables -t nat -S | grep DOCKER

# docker0 인터페이스 확인
ip addr show docker0

# 네트워크 트래픽 모니터링
sudo tcpdump -i docker0 -n 'tcp port 80'
```

---

## 실전 아키텍처 패턴

### 프론트엔드/백엔드 분리 패턴

외부에 공개되는 프론트엔드 서비스만 포트 매핑을 사용하고, 백엔드 서비스는 내부 네트워크에서만 접근 가능하도록 구성합니다.

```bash
# 네트워크 생성
docker network create appnet

# 백엔드 API 서비스 (외부에 노출되지 않음)
docker run -d --name api --network appnet hashicorp/http-echo -text="hello"

# 프론트엔드 웹 서버 (외부에 포트 매핑)
docker run -d --name fe --network appnet -p 8080:80 nginx:alpine

# Nginx 프록시 설정
docker exec -it fe sh -lc 'printf "server{listen 80; location / {proxy_pass http://api:5678;}}" > /etc/nginx/conf.d/default.conf && nginx -s reload'

# 접속 테스트
curl -s localhost:8080
```

### 다중 네트워크를 이용한 보안 강화

민감한 서비스(데이터베이스 등)는 별도의 비공개 네트워크에 배치하고, 프론트엔드 서비스만 공개 네트워크와 비공개 네트워크에 모두 연결합니다.

```bash
# 네트워크 생성
docker network create frontnet
docker network create backnet

# 데이터베이스 (비공개 네트워크만)
docker run -d --name db --network backnet postgres:15

# 프론트엔드 (양쪽 네트워크 모두)
docker run -d --name fe --network frontnet -p 80:80 nginx:alpine
docker network connect backnet fe
```

---

## Docker Compose를 이용한 네트워킹

### 기본 구성

```yaml
version: "3.9"
services:
  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: secret
  web:
    image: nginx:alpine
    ports:
      - "8080:80"
    depends_on:
      - db
```

Compose는 자동으로 프로젝트 전용 브리지 네트워크를 생성하여 서비스들이 이름으로 통신할 수 있게 합니다.

### 고급 네트워킹 구성

```yaml
version: "3.9"
networks:
  frontnet:
  backnet:

services:
  api:
    image: hashicorp/http-echo
    command: ["-text=hello"]
    networks: [backnet]

  fe:
    image: nginx:alpine
    ports:
      - "8080:80"
    networks:
      - frontnet
      - backnet
    depends_on: [api]
```

### 헬스 체크와 의존성 관리

```yaml
version: "3.9"
services:
  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: secret
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres || exit 1"]
      interval: 5s
      timeout: 2s
      retries: 10

  app:
    image: myorg/myapp:1.0
    depends_on:
      db:
        condition: service_healthy
```

---

## 운영 모범 사례

### 성능 최적화

대규모 연결을 처리하는 시스템에서는 호스트 시스템의 네트워크 설정을 튜닝할 필요가 있습니다.

```bash
# 커널 파라미터 튜닝 예시
sudo sysctl -w net.ipv4.ip_local_port_range="1024 65000"
sudo sysctl -w net.core.somaxconn=1024
sudo sysctl -w net.ipv4.tcp_fin_timeout=30
```

### 보안 강화

- 최소 권한 원칙: 필요한 포트만 외부에 공개
- 컨테이너 격리: 비루트 사용자, 읽기 전용 파일 시스템, 불필요한 권한 제거

```bash
docker run -d --cap-drop ALL --read-only --tmpfs /tmp \
  --user 65532:65532 -p 8080:80 nginx:alpine
```

### 모니터링과 관찰

{% raw %}
```bash
# 네트워크 상태 확인
docker network ls
docker network inspect appnet

# 포트 매핑 확인
docker ps --format 'table {{.Names}}\t{{.Ports}}'

# iptables 규칙 확인
iptables -t nat -L -n -v | sed -n '1,200p'

# 네트워크 트래픽 분석
sudo tcpdump -i docker0 -n 'tcp port 80'
```
{% endraw %}

---

## 플랫폼별 특성

### IPv6 지원
Docker 데몬 설정에서 IPv6를 활성화할 수 있습니다.

```json
{
  "ipv6": true,
  "fixed-cidr-v6": "2001:db8:1::/64"
}
```

### Windows 및 WSL2 환경
- Windows에서는 `host.docker.internal` 호스트명으로 호스트 시스템에 접근할 수 있습니다.
- WSL2 환경에서는 네트워크 브리징과 포트 포워딩에 주의가 필요합니다.

---

## 문제 해결 가이드

| 증상 | 가능한 원인 | 해결 방법 |
|---|---|---|
| localhost:8080 접속 불가 | 포트 매핑 누락 또는 오타 | `docker ps`로 포트 확인 후 올바른 매핑으로 재실행 |
| 특정 IP에서만 접근 가능 | 바인딩 범위 제한 | `-p 0.0.0.0:8080:80`으로 모든 인터페이스에 바인딩 |
| 방화벽 차단 | 시스템 방화벽 규칙 | 방화벽 규칙 확인 및 필요 포트 개방 |
| 컨테이너 간 통신 실패 | 서로 다른 네트워크에 위치 | 동일 사용자 정의 브리지 네트워크로 연결 |
| 이름 해석 실패 | 기본 브리지 네트워크 제한 | 사용자 정의 브리지 네트워크 사용 |
| Docker Desktop 성능 저하 | 가상화 계층 오버헤드 | 바인드 마운트 최소화, 볼륨 활용 |

---

## 실전 시나리오: 3계층 애플리케이션

### 단일 호스트 환경

```bash
# 네트워크 생성
docker network create tiernet

# 데이터베이스 계층
docker run -d --name db --network tiernet \
  -e POSTGRES_PASSWORD=secret postgres:15

# 애플리케이션 계층
docker run -d --name app --network tiernet \
  -e DB_HOST=db myorg/myapp:1.0

# 프론트엔드 계층
docker run -d --name fe --network tiernet -p 8080:80 nginx:alpine

# 프록시 설정
docker exec -it fe sh -lc 'printf "server{listen 80; location / {proxy_pass http://app:8080;}}" > /etc/nginx/conf.d/default.conf && nginx -s reload'

# 테스트
curl -s localhost:8080
```

---

## 자주 묻는 질문

### Q: 여러 컨테이너를 동일한 호스트 포트에 매핑할 수 있나요?
A: 한 호스트 포트는 하나의 컨테이너에만 바인딩할 수 있습니다. 여러 서비스를 공개하려면 리버스 프록시를 사용하거나 다른 호스트 포트를 사용해야 합니다.

### Q: 컨테이너에서 호스트 시스템으로 접근하는 방법은?
A: 리눅스 환경에서는 일반적으로 `host.docker.internal` 호스트명을 사용합니다. 또는 기본 게이트웨이 IP를 확인하여 사용할 수 있습니다:
```bash
docker exec 컨테이너이름 sh -c "ip route | awk '/default/ {print \$3}'"
```

### Q: 외부에서 컨테이너로의 접근은 허용하되, 컨테이너에서 외부로의 접근은 제한하려면?
A: 포트 매핑(`-p`) 없이 컨테이너를 실행하면 외부에서의 인바운드 접근은 차단되지만, 컨테이너에서 외부로의 아웃바운드 접근은 가능합니다.

---

## 테스트 및 디버깅 명령어

{% raw %}
```bash
# 네트워크 및 연결 상태 확인
docker network ls
docker network inspect appnet

# 컨테이너 포트 정보 확인
docker ps --format 'table {{.Names}}\t{{.Ports}}'
docker inspect <컨테이너> -f '{{json .NetworkSettings.Ports}}'

# 컨테이너 내부 네트워크 설정 확인
docker exec -it web sh -lc "ip addr; ip route; cat /etc/resolv.conf"

# DNS 해석 테스트
docker exec -it web sh -lc "nslookup db 127.0.0.11"

# 네트워크 트래픽 분석
sudo tcpdump -i docker0 -n 'tcp port 80'
```
{% endraw %}

---

## 실습: 내부 통신 API와 외부 공개 프론트엔드

```bash
# 네트워크 생성
docker network create svcnet

# 내부 API 서비스
docker run -d --name api --network svcnet hashicorp/http-echo -text="ok"

# 외부 공개 프론트엔드
docker run -d --name fe --network svcnet -p 8080:80 nginx:alpine

# 프록시 설정
docker exec -it fe sh -lc 'printf "server{listen 80; location / {proxy_pass http://api:5678;}}" > /etc/nginx/conf.d/default.conf && nginx -s reload'

# 테스트
curl -I localhost:8080
```

---

## 주요 명령어 요약

{% raw %}
```bash
# 네트워크 관리
docker network create appnet
docker network rm appnet
docker network inspect appnet

# 컨테이너 네트워크 연결 관리
docker network connect appnet <컨테이너>
docker network disconnect appnet <컨테이너>

# 포트 매핑
docker run -d -p 8080:80 nginx
docker run -d -p 127.0.0.1:8080:80 nginx
docker run -d -P nginx

# 상태 확인
docker ps --format 'table {{.Names}}\t{{.Ports}}'
```
{% endraw %}

---

## 결론

Docker 네트워킹은 컨테이너 기반 애플리케이션의 통신 구조를 정의하는 핵심 요소입니다. 효과적인 네트워크 설계를 위해 다음 원칙들을 준수하는 것이 좋습니다:

1. **사용자 정의 브리지 네트워크 활용**: 기본 브리지 대신 사용자 정의 브리지를 사용하여 향상된 DNS 기능과 네트워크 격리를 구현하세요.
2. **최소 노출 원칙**: 외부에 공개해야 하는 포트만 매핑하고, 내부 통신은 네트워크 분리를 통해 보호하세요.
3. **계층적 아키텍처**: 프론트엔드와 백엔드를 분리하고, 리버스 프록시를 통해 단일 진입점을 구성하세요.
4. **체계적 문제 해결**: 문제 발생 시 `docker ps` → `docker inspect` → `network inspect` → `iptables` → `tcpdump` 순서로 단계적으로 진단하세요.

이러한 원칙들을 적용하면 안전하고 효율적인 Docker 네트워크 환경을 구축할 수 있습니다. 네트워크 설계는 애플리케이션의 보안, 성능, 유지보수성에 직접적인 영향을 미치므로 신중하게 계획하고 구현해야 합니다.