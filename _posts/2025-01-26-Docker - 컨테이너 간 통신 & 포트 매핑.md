---
layout: post
title: Docker - 컨테이너 간 통신 & 포트 매핑
date: 2025-01-26 21:20:23 +0900
category: Docker
---
# Docker: 컨테이너 간 통신 & 포트 매핑

- **동작 원리**: veth/브리지/iptables DNAT·SNAT, 내장 DNS(127.0.0.11)
- **설계 패턴**: 사용자 정의 브리지, 프런트/백 분리, 리버스 프록시, 멀티 네트워크
- **포트 매핑**: 단일/다중 매핑, 랜덤 바인딩, IPv6, Docker Desktop/WSL2 차이
- **관찰성**: tcpdump, iptables, `docker network inspect`로 내부 살펴보기
- **트러블슈팅**: “안 열려요”를 끝장내는 체크리스트/원인→해결 매핑표

---

## 기본 개념 정리: 네트워크·포트·이름 해석

- **컨테이너 네트워크**: 리눅스 네임스페이스로 격리된 가상 네트워크. 기본은 `bridge`(가상 스위치 `docker0` 중심).
- **컨테이너 간 통신**: **같은 사용자 정의 브리지**에 있으면 **컨테이너 이름**으로 접근(내장 DNS, 127.0.0.11).
- **외부 ↔ 컨테이너**: **포트 매핑**(호스트포트:컨테이너포트)으로 DNAT/포워딩.
- **Host 네트워크**: 포트 매핑이 필요 없지만(무시됨), 포트 충돌/보안 경계가 약해질 수 있음.

---

## Docker 네트워크 드라이버 구분(요약)

| 드라이버 | 사용 맥락 | 메모 |
|---|---|---|
| `bridge`(기본) | 단일 호스트 내 대부분 서비스 | 포트 매핑으로 외부 공개, 사용자 정의 브리지 권장 |
| `host` | 초저지연·프록시·패킷 도구 | 포트 충돌/보안 유의, 매핑 무시 |
| `none` | 테스트/격리 | 네트워크 완전 차단 |
| `overlay` | Swarm(여러 호스트) | 여기서는 범위 밖 |
| `macvlan` | L2에서 별도 장치처럼 | 네트워크 팀과 협업 필요 |

---

## 컨테이너 간 통신 — 사용자 정의 브리지로 “이름 기반” 만들기

### 한 줄 요약

- **사용자 정의 브리지**를 만들면, 해당 네트워크 내 컨테이너는 **이름으로 DNS 조회** 가능.
- 기본 `bridge`도 통신은 되지만, 이름 해석/분리는 **사용자 정의 브리지**가 표준.

### 실습 ①: 사용자 정의 브리지 만들고 통신

```bash
# 네트워크 생성

docker network create appnet

# DB

docker run -d --name db --network appnet \
  -e POSTGRES_PASSWORD=secret postgres:15

# 웹(Nginx)

docker run -d --name web --network appnet nginx:alpine

# 웹 → DB 테스트(웹 컨테이너에서)

docker exec -it web sh -lc "apk add --no-cache psql || true; \
  echo 'SELECT 1;' | psql -h db -U postgres -p 5432"
# 주: 경량 이미지는 psql 클라이언트가 빠져 있음. 테스트는 nslookup/커넥션 시도 정도로도 충분.

```

### 이름 해석 확인(내장 DNS)

```bash
docker exec -it web sh -lc "cat /etc/resolv.conf && nslookup db 127.0.0.11"
```
- 내장 DNS(127.0.0.11)가 컨테이너 이름을 IP로 바꿉니다.

---

## 포트 매핑 — DNAT/포워딩의 모든 것

### 기본 패턴

```bash
docker run -d -p 8080:80 nginx      # 호스트 8080 → 컨테이너 80
docker run -d -p 8080:80 -p 8443:443 nginx
```

### 고급 바인딩

- **특정 IP에만 바인딩**:
```bash
docker run -d -p 127.0.0.1:8080:80 nginx   # 로컬에서만 접근
```
- **임의(랜덤) 포트 바인딩**:
```bash
docker run -d -P nginx  # EXPOSE된 포트를 임의 호스트 포트로 할당
docker port <컨테이너>
```

### `--publish` 구문(가독성)

```bash
docker run -d --publish 8080:80/tcp nginx
```

---

## 아키텍처: bridge 내부에서 실제로 무슨 일이?

```
[외부] ──> (호스트:8080) ──DNAT/iptables──> [docker0] ──> [컨테이너:80]
                       <──SNAT(응답)──────
```

- 호스트에 들어온 패킷은 `iptables -t nat`의 PREROUTING(또는 DOCKER 체인) 규칙으로 **DNAT** 되어 컨테이너 IP로 전달.
- 컨테이너에서 나가는 응답은 **SNAT(MASQUERADE)** 로 호스트 IP로 변환.
- 같은 브리지 내 컨테이너끼리는 L2 스위칭(iptables 경유 X)으로 통신.

관찰 팁:
```bash
iptables -t nat -S | grep DOCKER
ip addr show docker0
sudo tcpdump -i docker0 -n 'tcp port 80'
```

---

## 실전 패턴 — 프런트/백 분리, 리버스 프록시, 멀티 네트워크

### 프런트/백 분리

- 외부 공개는 프런트(nginx)만, 백(DB·API)는 외부 미노출.
- 프런트는 `-p`로 포트 매핑, 백은 **같은 브리지**에서 이름으로 접근.

```bash
docker network create appnet

# 백엔드(API)

docker run -d --name api --network appnet hashicorp/http-echo -text="hello"

# 프런트(Nginx, 외부 공개)

docker run -d --name fe --network appnet -p 8080:80 nginx:alpine

# 프록시 설정 주입(간단 샘플)

docker exec -it fe sh -lc 'printf "server{listen 80; location / {proxy_pass http://api:5678;}}" > /etc/nginx/conf.d/default.conf && nginx -s reload'

curl -s localhost:8080
```

### 멀티 네트워크(보안 경계 강화)

- 프런트는 `frontnet`(공개)와 `backnet`(비공개) **두 네트워크에 동시에** 붙는다.
- DB는 backnet에만 연결 → 외부 경로 차단.

```bash
docker network create frontnet
docker network create backnet

docker run -d --name db --network backnet postgres:15

docker run -d --name fe \
  --network frontnet \
  --network-alias fe \
  -p 80:80 nginx:alpine

# fe를 backnet에도 붙이기

docker network connect backnet fe

# 프록시 설정에서 db 이름(backnet) 사용

```

> 네트워크 분리는 “노출 범위 최소화”의 핵심입니다.

---

## Docker Compose — 통신·노출을 선언적으로

### 가장 단순한 웹+DB

```yaml
version: "3.9"
services:
  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: secret
  web:
    image: nginx:alpine
    ports:
      - "8080:80"
    depends_on:
      - db
```
- 기본적으로 Compose는 프로젝트 전용 `bridge` 네트워크를 만들어 **이름으로 통신** 가능(`db:5432`).

### 프런트/백 분리, 멀티 네트워크

```yaml
version: "3.9"
networks:
  frontnet:
  backnet:

services:
  api:
    image: hashicorp/http-echo
    command: ["-text=hello"]
    networks: [backnet]

  fe:
    image: nginx:alpine
    ports:
      - "8080:80"
    networks:
      - frontnet
      - backnet
    depends_on: [api]
```

---

## 운영 팁 — 성능·보안·관찰성

### 성능

- 대규모 연결/고TPS: 호스트 sysctl 튜닝(예)
```bash
sudo sysctl -w net.ipv4.ip_local_port_range="1024 65000"
sudo sysctl -w net.core.somaxconn=1024
sudo sysctl -w net.ipv4.tcp_fin_timeout=30
```
- Docker Desktop/WSL2: 하이퍼바이저 경로로 인해 **I/O·파일 바인드 지연**이 발생할 수 있음.

### 보안

- 외부 공개는 **정말 필요한 포트만** `-p`.
- 컨테이너는 가능하면 **비루트 사용자**, **read-only 루트FS**, **cap-drop**:
```bash
docker run -d --cap-drop ALL --read-only --tmpfs /tmp --user 65532:65532 -p 8080:80 nginx:alpine
```
- 네트워크 분할(멀티 브리지), 내부만 통신하도록 프록시 앞단에만 공개.

### 관찰성

{% raw %}
```bash
docker network ls
docker network inspect appnet
docker ps --format 'table {{.Names}}\t{{.Ports}}'
iptables -t nat -L -n -v | sed -n '1,200p'
sudo tcpdump -i docker0 -n 'tcp port 80'
```
{% endraw %}

---

## IPv6·WSL2·Docker Desktop 특성

- **IPv6**: `daemon.json`에서 활성화 후 사용자 정의 브리지에 프리픽스 부여. 방화벽/라우팅 정책 동시 검토.
```json
{
  "ipv6": true,
  "fixed-cidr-v6": "2001:db8:1::/64"
}
```
- **WSL2**: `host.docker.internal` 접근 규칙과 방화벽/포트포워딩 차이를 이해(Windows↔WSL NAT 경유).
- **Docker Desktop**: 내부 VM. 포트 포워딩과 파일 바인드 성능 특성 고려.

---

## 트러블슈팅 — “포트가 안 열립니다”를 끝내는 표

| 증상 | 원인 후보 | 진단 명령 | 해결 |
|---|---|---|---|
| `localhost:8080` 접속 불가 | `-p` 누락/오타 | `docker ps`, `docker inspect <컨테이너> -f '{{json .NetworkSettings.Ports}}'` | 정확한 포트 매핑으로 재실행 |
| 0.0.0.0가 아닌 127.0.0.1에만 바인딩 | 바인딩 범위 제한 | `ss -lntp` | 필요한 경우 `-p 0.0.0.0:8080:80` |
| 방화벽/SELinux 차단 | 정책 충돌 | `sudo iptables -S`, `sudo ufw status`, `sestatus` | 규칙 허용/컨텍스트 조정 |
| Host 모드인데 `-p`가 먹힘? | Host 모드에서 `-p`는 무시 | `docker inspect` | 포트 충돌 체크, host 모드 이해 |
| 컨테이너 간 접속 실패 | 서로 다른 네트워크 | `docker network inspect` | 동일 사용자 브리지로 연결 |
| 이름으로 접속 안 됨 | 기본 bridge의 제한/캐시 | 컨테이너 내 `nslookup` | 사용자 정의 브리지 사용 |
| Docker Desktop에서만 느림 | 가상화/파일 I/O | 환경만 바꿔 재현 | 바인드 최소화/볼륨·캐시 전략 |

---

## 실전 시나리오 — 웹/앱/DB 3계층(포트 매핑+이름 통신)

### 단일 호스트, 사용자 정의 브리지

```bash
docker network create tiernet

docker run -d --name db --network tiernet \
  -e POSTGRES_PASSWORD=secret \
  postgres:15

docker run -d --name app --network tiernet \
  -e DB_HOST=db -e DB_USER=postgres -e DB_PASS=secret \
  myorg/myapp:1.0  # 내부에서 postgresql://db:5432 사용

docker run -d --name fe --network tiernet -p 8080:80 nginx:alpine
docker exec -it fe sh -lc 'printf "server{listen 80; location / {proxy_pass http://app:8080;}}" > /etc/nginx/conf.d/default.conf && nginx -s reload'
curl -s localhost:8080
```

### 멀티 네트워크(외부·내부 분리)

```bash
docker network create frontnet
docker network create backnet

docker run -d --name db  --network backnet postgres:15
docker run -d --name app --network backnet myorg/myapp:1.0

docker run -d --name fe \
  --network frontnet \
  -p 80:80 nginx:alpine
docker network connect backnet fe

# fe의 프록시 설정에서 app:포트를 backnet 이름으로 지정

```

---

## 포트 매핑·네트워크 FAQ

### Q1. 여러 컨테이너를 같은 포트로 외부 공개하려면?

- **한 호스트 포트는 하나의 컨테이너에만** 바인딩 가능.
- Nginx/HAProxy 같은 **리버스 프록시**로 가상호스트/경로 기반 라우팅하세요.

### Q2. 동일 포트를 여러 개 써야 한다면?

- 다른 **호스트 포트**로 매핑하거나, **다른 호스트(또는 노드)** 로 분산.

### Q3. 컨테이너가 밖으로 나가지만, 밖에서 못 들어오게 하려면?

- `-p` 를 **생략**. 아웃바운드는 SNAT로 가능, 인바운드는 차단.

### Q4. 컨테이너 내부에서 호스트에 접속?

- 리눅스: 보통 `host.docker.internal`(환경/버전에 따라 다름).
  없다면 `ip route | awk '/default/ {print $3}'` 로 게이트웨이 IP 확인.

### Q5. IPv6?

- 데몬 IPv6 활성화 + 브리지 프리픽스. 방화벽·라우팅 정책 동시 구성 필요.

---

## Compose 고급: 네트워크·헬스체크·의존성

```yaml
version: "3.9"
networks:
  frontnet:
    driver: bridge
  backnet:
    driver: bridge

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: secret
    networks: [backnet]
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres || exit 1"]
      interval: 5s
      timeout: 2s
      retries: 10

  app:
    image: myorg/myapp:1.0
    environment:
      DB_HOST: db
      DB_USER: postgres
      DB_PASS: secret
    depends_on:
      db:
        condition: service_healthy
    networks: [backnet]

  fe:
    image: nginx:alpine
    ports:
      - "8080:80"
    networks:
      - frontnet
      - backnet
    depends_on: [app]
```
- 헬스체크로 “DB 기동 완료 후 앱” 순서를 현실적으로 다룸.

---

## 테스트·관찰 레시피 모음

{% raw %}
```bash
# 네트워크/연결 상태

docker network ls
docker network inspect appnet

# 포트 바인딩 확인

docker ps --format 'table {{.Names}}\t{{.Ports}}'

# 컨테이너 내부 네트워크 확인

docker exec -it web sh -lc "ip addr; ip route; cat /etc/resolv.conf"

# 이름 해석

docker exec -it web sh -lc "nslookup db 127.0.0.11"

# iptables NAT 규칙

sudo iptables -t nat -L -n -v | sed -n '1,200p'

# 브리지 패킷 캡처

sudo tcpdump -i docker0 -n 'tcp port 80'
```
{% endraw %}

---

## 수식 직관: 공개 범위 최소화의 가치

외부 노출 위험 \(R\) 을 **공개 포트 수 \(k\)** 와 **공격면 가중치 \(w_i\)** 로 단순화:
$$
R \approx \sum_{i=1}^{k} w_i
$$
- 불필요한 `-p` 를 제거할수록 \(k\) 감소 → \(R\) 감소.
- 프런트/백 분리, 멀티 네트워크는 **필수 포트만 공개**를 시스템적으로 강제.

---

## 결론(실무 4원칙)

1. **사용자 정의 브리지 + 이름 통신**을 기본값으로.
2. 외부 공개는 **정말 필요한 포트만 `-p`**.
3. **프런트/백 네트워크 분리**, 리버스 프록시로 단일 진입점 구성.
4. 문제 시 **관찰 순서**: `docker ps` → `docker inspect` → `network inspect` → `iptables nat` → `tcpdump`.

---

## 부록 A) 빠른 명령어 치트시트

{% raw %}
```bash
# 네트워크 생성/삭제

docker network create appnet
docker network rm appnet

# 네트워크 상세

docker network inspect appnet

# 컨테이너 네트워크 연결/분리

docker network connect appnet <container>
docker network disconnect appnet <container>

# 포트 매핑

docker run -d -p 8080:80 nginx
docker run -d -p 127.0.0.1:8080:80 nginx
docker run -d -P nginx               # 임의 포트 자동 할당

# 상태/포트 관찰

docker ps --format 'table {{.Names}}\t{{.Ports}}'
docker inspect <container> -f '{{json .NetworkSettings.Ports}}'
```
{% endraw %}

---

## 부록 B) 미니 실습: “내부만 통신하는 API + 외부 공개 프론트”

```bash
docker network create svcnet

docker run -d --name api --network svcnet \
  hashicorp/http-echo -text="ok"

docker run -d --name fe --network svcnet -p 8080:80 nginx:alpine
docker exec -it fe sh -lc 'printf "server{listen 80; location / {proxy_pass http://api:5678;}}" > /etc/nginx/conf.d/default.conf && nginx -s reload'
curl -I localhost:8080
```

위 실습만으로도 “**컨테이너 간 이름 통신 + 포트 매핑으로 외부 공개**”의 본질을 체득할 수 있습니다.
