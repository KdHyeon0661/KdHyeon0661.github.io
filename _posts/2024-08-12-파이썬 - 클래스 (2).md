---
layout: post
title: 파이썬 - 클래스 (2)
date: 2024-08-12 19:20:23 +0900
category: Python
---
# 파이썬 클래스 심화 – 상속, 오버라이딩, 오버로딩까지

## 상속 (Inheritance) — 재사용과 확장

- **목적**: 공통 로직 재사용, 다형성(polymorphism) 구현
- **원칙**: “is-a” 관계일 때만 상속. 그렇지 않다면 **조합(Composition)** 우선.

```python
class Animal:
    def speak(self):
        print("동물이 소리칩니다.")

class Dog(Animal):
    def bark(self):
        print("멍멍!")

d = Dog()
d.speak()  # 동물이 소리칩니다.
d.bark()   # 멍멍!
```

### 1-1) 다중상속과 MRO(Method Resolution Order)

- 파이썬은 **다중상속**을 지원.
- 메서드 탐색 순서는 **C3 선형화**(MRO)에 따름.

```python
class A:
    def who(self): print("A")
class B(A):
    def who(self): print("B")
class C(A):
    def who(self): print("C")
class D(B, C):
    pass

print(D.mro())
# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

D().who()  # B  (MRO에 따라 B→C→A 순서로 탐색)
```

> **팁**: 다이아몬드 상속 구조에서 `super()`가 **협력적(cooperative)** 으로 동작하도록 모든 클래스가 `super()`를 호출해야 합니다.

---

## 오버라이딩 (Overriding) — 규약과 `super()`

```python
class Animal:
    def speak(self):
        print("동물 소리")

class Dog(Animal):
    def speak(self):               # 오버라이딩
        print("멍멍")

Dog().speak()  # 멍멍
```

### 2-1) `super()`의 올바른 사용

- 다중상속에서 **모든 클래스가 같은 시그니처로 `super()`를 호출**해야 체인에 있는 **모든 부모**가 호출됩니다.

```python
class Base:
    def __init__(self, *a, **kw):
        print("Base")
        super().__init__(*a, **kw)

class Mixin1(Base):
    def __init__(self, *a, **kw):
        print("Mixin1")
        super().__init__(*a, **kw)

class Mixin2(Base):
    def __init__(self, *a, **kw):
        print("Mixin2")
        super().__init__(*a, **kw)

class Concrete(Mixin1, Mixin2):
    def __init__(self):
        print("Concrete")
        super().__init__()

Concrete()
# Concrete
# Mixin1
# Mixin2
# Base

```

> `super(SubClass, self).method()` 처럼 특정 부모를 **지정 호출**하면 *협력적 초기화 체인*이 끊어질 수 있으니 주의.

---

## 연산자 오버로딩 — 전체 스펙과 실전 규약

연산자 오버로딩은 **특수 메서드(던더)** 로 구현합니다.
아래 표는 자주 쓰는 항목을 실무 관점에서 정리한 것입니다.

| 범주 | 연산자 | 구현 메서드 | 메모 |
|---|---|---|---|
| 산술 | `+ - * / // % **` | `__add__ __sub__ __mul__ __truediv__ __floordiv__ __mod__ __pow__` | **반사**: `__radd__` 등, **제자리**: `__iadd__` 등 |
| 비교 | `== != < <= > >=` | `__eq__ __ne__ __lt__ __le__ __gt__ __ge__` | **부분만 구현**하면 일관성 깨짐 → `functools.total_ordering` 고려 |
| 컨테이너 | `in len [] iter` | `__contains__ __len__ __getitem__/__setitem__/__delitem__ __iter__` | 슬라이싱/키 접근 지원 |
| 변환 | `str repr bool int float hash` | `__str__ __repr__ __bool__ __int__ __float__ __hash__` | `__repr__`는 디버깅 친화적으로 |
| 호출/컨텍스트 | `()` `with` | `__call__ __enter__/__exit__` | **펑션형 객체**·자원관리 |

### 3-1) 2D 벡터 예시 (산술·비교·해시·표현)

```python
from functools import total_ordering

@total_ordering
class Vec2:
    __slots__ = ("x", "y")

    def __init__(self, x: float, y: float):
        self.x, self.y = x, y

    # 표현
    def __repr__(self): return f"Vec2({self.x}, {self.y})"
    def __str__(self):  return f"({self.x}, {self.y})"

    # 산술(우항, 반사, 제자리)
    def __add__(self, other):
        if isinstance(other, Vec2):  return Vec2(self.x + other.x, self.y + other.y)
        if isinstance(other, (int, float)): return Vec2(self.x + other, self.y + other)
        return NotImplemented

    def __radd__(self, other):       # 3 + v
        return self.__add__(other)

    def __iadd__(self, other):       # v += other (가능하면 in-place)
        if isinstance(other, Vec2):
            self.x += other.x; self.y += other.y; return self
        if isinstance(other, (int, float)):
            self.x += other; self.y += other; return self
        return NotImplemented

    def __mul__(self, k):
        if isinstance(k, (int, float)): return Vec2(self.x * k, self.y * k)
        return NotImplemented

    def __rmul__(self, k):           # k * v
        return self.__mul__(k)

    # 비교: total_ordering을 위해 __eq__ + 하나의 순서비교만 구현
    def __eq__(self, other):
        return isinstance(other, Vec2) and (self.x, self.y) == (other.x, other.y)

    def __lt__(self, other):
        if not isinstance(other, Vec2): return NotImplemented
        return (self.x, self.y) < (other.x, other.y)

    # 컨테이너/변환
    def __iter__(self):
        yield self.x; yield self.y

    def __hash__(self):
        # 불변처럼 쓴다면 해시 제공(가변이면 hash 제공 금지)
        return hash((self.x, self.y))
```

**실전 규약**

- **대칭성**: `a == b` → `b == a`가 성립하도록 작성.
- **해시 규약**: `__eq__`를 재정의하면, **불변 객체**에 한해 `__hash__`도 함께 정의(동일 비교 ⇒ 동일 해시).
- **반사/제자리 연산**: 숫자/사용자 타입 혼합 시 `__radd__`, 성능 최적화 시 `__iadd__` 고려.

---

## 메서드 오버로딩 — 파이썬에서의 “현실적인” 해결책

> 파이썬은 자바/C++식 **런타임 오버로딩**을 지원하지 않습니다(동일 이름·서로 다른 시그니처).
> 대신 아래처럼 **정적 타입 힌트 기반의 오버로드 선언**과 **런타임 분기**로 대체합니다.

### 4-1) `typing.overload` (+ 런타임 바디 하나)

```python
from typing import overload, Iterable, Union, List

class Flattener:
    @overload
    def flat(self, xs: List[int]) -> List[int]: ...
    @overload
    def flat(self, xs: List[List[int]]) -> List[int]: ...
    # 실제 구현(런타임엔 단 하나)
    def flat(self, xs: Union[List[int], List[List[int]]]):
        if all(isinstance(x, int) for x in xs):
            return xs[:]                      # 그대로
        return [y for row in xs for y in row] # 2D → 1D

f = Flattener()
print(f.flat([1,2,3]))        # [1, 2, 3]
print(f.flat([[1,2],[3,4]]))  # [1, 2, 3, 4]
```

- **장점**: 타입 체커/IDE 친화(호출별 반환 타입 추론).
- **주의**: `@overload` 함수는 바디가 없어야 하며, **마지막에 실제 구현 1개**만 존재해야 합니다.

### 4-2) `functools.singledispatchmethod` (런타임 단일 디스패치)

```python
from functools import singledispatchmethod

class Printer:
    @singledispatchmethod
    def show(self, arg):
        print("일반 객체:", arg)

    @show.register
    def _(self, arg: int):
        print("정수:", arg)

    @show.register
    def _(self, arg: str):
        print("문자열:", arg)

p = Printer()
p.show(10)       # 정수: 10
p.show("hello")  # 문자열: hello
p.show(3.14)     # 일반 객체: 3.14
```

### 4-3) 디폴트 값 / `*args` / `**kwargs`

```python
class Greeter:
    def hello(self, name=None, *args, **kwargs):
        if name is None:  print("Hello stranger")
        else:             print(f"Hello {name}")
```

> 요약: **정적 설계(IDE/타입체크)** 가 중요하면 `@overload`, **런타임 타입 분기**가 목적이면 `singledispatchmethod`가 깔끔합니다.

---

## 클래스 메서드 / 정적 메서드 — 언제 쓰는가

```python
class Config:
    _registry = {}
    def __init__(self, name): self.name = name

    @classmethod
    def register(cls, name: str, obj: "Config"):
        cls._registry[name] = obj

    @classmethod
    def get(cls, name: str) -> "Config":
        return cls._registry[name]

    @staticmethod
    def slugify(s: str) -> str:
        return s.strip().lower().replace(" ", "-")

cfg = Config("Main")
Config.register("main", cfg)
print(Config.get("main").name)   # Main
print(Config.slugify(" Hello World "))  # hello-world
```

- **`@classmethod`**: 클래스 상태(레지스트리, 팩토리/대체 생성자) 조작.
- **`@staticmethod`**: 클래스와 느슨하게 연관된 **순수 유틸리티 함수**.

---

## 비공개 멤버 — 한 밑줄과 두 밑줄

```python
class Secret:
    def __init__(self):
        self._hint = "관례상 내부사용"    # 외부 접근 가능하나 하지 말라는 신호
        self.__token = "mangle"         # _Secret__token 으로 맹글링

    def reveal(self):
        return self.__token

s = Secret()
print(s.reveal())             # mangle
# print(s.__token)           # AttributeError

print(s._Secret__token)       # 디버깅/반칙으로는 접근 가능
```

- **보안 기능이 아님**: 우발적 충돌/접근을 피하려는 **네임 맹글링**입니다. API 경계는 문서로.

---

## 믹스인(Mixin) — 기능 조각의 수평 결합

> 독립 동작을 얇게 분리한 **믹스인** 클래스를 만들어 여러 클래스에서 재사용.

```python
class ReprMixin:
    def __repr__(self):
        args = ", ".join(f"{k}={v!r}" for k, v in self.__dict__.items())
        return f"{self.__class__.__name__}({args})"

class EqualMixin:
    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

class User(ReprMixin, EqualMixin):
    def __init__(self, name, age):
        self.name, self.age = name, age

u1 = User("Ann", 30); u2 = User("Ann", 30)
print(u1)         # User(name='Ann', age=30)
print(u1 == u2)   # True
```

- 믹스인은 **상태/초기화에 의존적이지 않게** 설계(협력적 `super()` 호출 규칙 준수).

---

## 추상기반클래스(ABC)와 Protocol — 인터페이스 설계

### 8-1) ABC (런타임 강제)

```python
from abc import ABC, abstractmethod

class Serializer(ABC):
    @abstractmethod
    def dump(self, obj) -> str: ...
    @abstractmethod
    def load(self, s: str): ...

class JsonSerializer(Serializer):
    def dump(self, obj) -> str:
        import json; return json.dumps(obj)
    def load(self, s: str):
        import json; return json.loads(s)

# Serializer()  # TypeError: Can't instantiate abstract class

```

### 8-2) Protocol (구조적 서브타이핑, 정적 검사)

```python
from typing import Protocol

class SupportsClose(Protocol):
    def close(self) -> None: ...

def shutdown(x: SupportsClose):
    x.close()  # .close()만 있으면 "같은 취급" (덕 타이핑)

class FileLike:
    def close(self): print("closed")

shutdown(FileLike())  # 정적 타입체커 OK
```

- **ABC**: 런타임 강제(상속 기반).
- **Protocol**: **형태**가 맞으면 OK(상속 불필요) — 정적 타입체커가 유효성 보장.

---

## 데이터클래스 / 불변 / `__slots__` — 실전 모델링

```python
from dataclasses import dataclass

@dataclass(frozen=True, slots=True, order=True)
class Money:
    amount: int
    currency: str = "KRW"

m1 = Money(1000, "KRW")
m2 = Money(2000, "KRW")
# m1.amount = 0      # frozen → 불변, AttributeError

print(m1 < m2, hash(m1), m1)  # True, (해시가능), Money(amount=1000, currency='KRW')
```

- `frozen=True`: **불변** → `__hash__` 자동 제공(필드도 불변 권장).
- `slots=True`: 인스턴스 `__dict__` 제거 → **메모리 절약/속도↑**(Py3.10+).
- `order=True`: 비교 연산 자동 생성(필드 순서 기준).

---

## 컨테이너/이터레이터 프로토콜 구현

```python
class Deck:
    def __init__(self, cards):
        self._cards = list(cards)

    def __len__(self):                 # len(d)
        return len(self._cards)

    def __contains__(self, x):         # x in d
        return x in self._cards

    def __getitem__(self, idx):        # d[i] / d[i:j]
        return self._cards[idx]

    def __iter__(self):                # for x in d
        return iter(self._cards)

d = Deck(["A", "K", "Q"])
print(len(d), "A" in d, d[0], list(d))
```

---

## 컨텍스트/콜러블 — “자원 관리”와 “함수 같은 객체”

```python
class Locker:
    def __enter__(self):
        print("Lock acquire"); return self
    def __exit__(self, exc_t, exc, tb):
        print("Lock release"); return False

with Locker() as lk:
    print("work")
# Lock acquire
# work
# Lock release

```

```python
class Accumulator:
    def __init__(self): self.total = 0
    def __call__(self, x): self.total += x; return self.total

acc = Accumulator()
print(acc(3), acc(4))  # 3 7
```

---

## 실전 미니 프로젝트 — 수학적 다항식(Polynomial)

> 연산자 오버로딩(산술·비교는 동등성만), `__repr__/__str__`, 컨테이너 인터페이스, `@classmethod` 팩토리, 불변 디자인(frozen dataclass 유사)까지 한 번에.

```python
from typing import Dict, Iterable

class Poly:
    """단변수 다항식, 내부 표현: {차수: 계수}, 불변처럼 취급"""
    __slots__ = ("_coef",)
    def __init__(self, coef: Dict[int, float] | None = None):
        self._coef = {k: v for k, v in (coef or {}).items() if v != 0}

    # 표현
    def __repr__(self): return f"Poly({self._coef})"
    def __str__(self):
        if not self._coef: return "0"
        items = []
        for p in sorted(self._coef, reverse=True):
            c = self._coef[p]
            if p == 0:   term = f"{c}"
            elif p == 1: term = f"{c}x"
            else:        term = f"{c}x^{p}"
            items.append(term)
        return " + ".join(items).replace("+ -", "- ")

    # 팩토리
    @classmethod
    def from_roots(cls, roots: Iterable[float]):
        # (x-r1)(x-r2)... → 단순히 (x - r)의 곱을 전개
        p = cls({0:1})  # 상수 1
        for r in roots:
            p = p * cls({1:1, 0:-r})
        return p

    # 컨테이너
    def __len__(self): return max(self._coef, default=0)+1
    def __getitem__(self, power: int): return self._coef.get(power, 0.0)
    def degree(self): return max(self._coef, default=0)

    # 산술
    def __add__(self, o):
        if not isinstance(o, Poly): return NotImplemented
        res = self._coef.copy()
        for p, c in o._coef.items():
            res[p] = res.get(p, 0) + c
            if res[p] == 0: del res[p]
        return Poly(res)

    def __neg__(self):
        return Poly({p: -c for p, c in self._coef.items()})

    def __sub__(self, o):
        r = self + (-o)
        return r if r is not NotImplemented else NotImplemented

    def __mul__(self, o):
        if isinstance(o, (int, float)):
            return Poly({p: c*o for p,c in self._coef.items()})
        if isinstance(o, Poly):
            res: Dict[int, float] = {}
            for p1, c1 in self._coef.items():
                for p2, c2 in o._coef.items():
                    k = p1+p2
                    res[k] = res.get(k, 0) + c1*c2
                    if res[k] == 0: del res[k]
            return Poly(res)
        return NotImplemented

    def __rmul__(self, o):
        return self * o

    def __eq__(self, o):
        return isinstance(o, Poly) and self._coef == o._coef

# 사용 예

p = Poly({2:1, 1:-3, 0:2})   # x^2 - 3x + 2
q = Poly.from_roots([1,2])   # (x-1)(x-2) = x^2 - 3x + 2
print(p, q, p == q, sep="\n")
print("p(1) =", p[0] + p[1]*1 + p[2]*1*1)   # 평가 예시 (간단히)
print("degree:", p.degree())
print("sum:", p + Poly({1:3}))              # (x^2 - 3x + 2) + 3x = x^2 + 2
print("scale:", 2 * p)                      # 2x^2 - 6x + 4
```

---

## 체크리스트 (현업에서 자주 틀리는 포인트)

1. **오버라이딩 + 다중상속**: 모든 클래스가 **동일 시그니처**로 `super()` 호출.
2. **연산자 오버로딩**: `NotImplemented`를 적절히 반환(파이썬이 반사 연산 시도).
3. **비교/해시**: `__eq__`를 바꾸면 **해시 규약**도 함께(불변일 때만 `__hash__`).
4. **성능**: 대량 인스턴스면 `__slots__`, 불변이면 `frozen dataclass`.
5. **오버로딩**: 런타임 오버로딩은 없음. **`@overload` + 단일 구현** or **`singledispatchmethod`**.
6. **설계**: 상속보다 **조합**을 먼저 고려, 믹스인은 **가볍게**.
7. **API 경계**: 밑줄(관례), 맹글링(우발 방지). 보안은 **아님**.
8. **타입 설계**: ABC는 런타임 강제, Protocol은 **형태** 기반(정적 검사 강력).

---

## 부록) 빠른 레퍼런스: 자주 쓰는 특수 메서드(요약)

- **생성/소멸**: `__new__`, `__init__`, `__del__`
- **표현**: `__repr__`, `__str__`, `__format__`
- **산술**: `__add__`, `__radd__`, `__iadd__`(반사/제자리 포함의 모든 산술쌍)
- **비교**: `__eq__`, `__lt__`(+ `total_ordering`)
- **컨테이너**: `__len__`, `__contains__`, `__getitem__`/`__setitem__`/`__delitem__`, `__iter__`, `__reversed__`
- **변환/상태**: `__bool__`, `__hash__`, `__int__`, `__float__`
- **호출/컨텍스트**: `__call__`, `__enter__`/`__exit__`
- **속성 제어**: `__getattr__`, `__getattribute__`, `__setattr__`, `__delattr__`, 디스크립터: `__get__`/`__set__`/`__delete__`

---

## 마무리

- **상속**과 **오버라이딩**은 다형성의 핵심이지만, 복잡도가 늘면 **조합과 믹스인**을 검토하세요.
- **연산자 오버로딩**은 강력하지만, **반사/제자리/비교·해시 규약**까지 갖춰야 “파이썬스러운” 객체가 됩니다.
- **오버로딩**은 “정식 지원 X” — **타입 힌트 오버로드 + 단일 구현** 혹은 **`singledispatchmethod`**로 충분히 실무적 대안이 됩니다.
- 필요하면 다음 단계로 **디스크립터/메타클래스/프로퍼티 캐싱(`functools.cached_property`)** 까지 확장해 드리겠습니다.
