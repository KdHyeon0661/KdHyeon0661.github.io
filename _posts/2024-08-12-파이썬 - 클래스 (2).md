---
layout: post
title: 파이썬 - 클래스 심화
date: 2024-08-12 19:20:23 +0900
category: Python
---
# 파이썬 클래스 심화: 객체지향 프로그래밍의 완성

클래스는 파이썬에서 객체지향 프로그래밍을 구현하는 핵심 도구입니다. 기본적인 클래스 사용법을 넘어 상속, 다형성, 특수 메서드 구현 등 고급 기법을 이해하면 더 강력하고 유연한 코드를 작성할 수 있습니다. 이 글에서는 클래스의 심화 개념들을 실용적인 예제와 함께 깊이 있게 살펴보겠습니다.

## 상속: 코드 재사용과 계층 구조

상속은 기존 클래스의 기능을 확장하거나 수정하여 새로운 클래스를 만드는 메커니즘입니다. 이는 코드 재사용성을 높이고, 계층적인 클래스 구조를 만들 수 있게 해줍니다.

### 기본 상속 구조

```python
class Animal:
    """동물 클래스 (기본 클래스)"""
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        print(f"{self.name}이(가) 소리를 냅니다.")
    
    def move(self):
        print(f"{self.name}이(가) 움직입니다.")

class Dog(Animal):
    """개 클래스 (Animal을 상속)"""
    def speak(self):
        # 부모 클래스의 메서드 오버라이딩
        print(f"{self.name}: 멍멍!")
    
    def wag_tail(self):
        # Dog 클래스만의 고유 메서드
        print(f"{self.name}이(가) 꼬리를 흔듭니다.")

class Cat(Animal):
    """고양이 클래스 (Animal을 상속)"""
    def speak(self):
        print(f"{self.name}: 야옹!")
    
    def climb(self):
        print(f"{self.name}이(가) 나무를 올라갑니다.")

# 사용 예시
buddy = Dog("버디")
kitty = Cat("키티")

buddy.speak()      # 버디: 멍멍!
buddy.move()       # 버디이(가) 움직입니다.
buddy.wag_tail()   # 버디이(가) 꼬리를 흔듭니다.

kitty.speak()      # 키티: 야옹!
kitty.climb()      # 키티이(가) 나무를 올라갑니다.
```

### 상속 관계 확인하기

```python
# 상속 관계 확인
print(issubclass(Dog, Animal))    # True
print(issubclass(Cat, Animal))    # True
print(issubclass(Dog, Cat))       # False

# 인스턴스 타입 확인
print(isinstance(buddy, Dog))     # True
print(isinstance(buddy, Animal))  # True
print(isinstance(buddy, Cat))     # False
```

### `super()` 함수의 올바른 사용

`super()` 함수는 부모 클래스의 메서드를 호출할 때 사용합니다. 다중 상속이나 복잡한 클래스 계층에서 특히 중요합니다.

```python
class Vehicle:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
        print("Vehicle 생성자 호출됨")
    
    def display_info(self):
        return f"{self.brand} {self.model}"

class ElectricVehicle(Vehicle):
    def __init__(self, brand, model, battery_capacity):
        # 부모 클래스의 __init__ 호출
        super().__init__(brand, model)
        self.battery_capacity = battery_capacity  # kWh
        print("ElectricVehicle 생성자 호출됨")
    
    def display_info(self):
        # 부모 클래스의 메서드 활용
        base_info = super().display_info()
        return f"{base_info}, 배터리: {self.battery_capacity}kWh"

# 사용 예시
tesla = ElectricVehicle("Tesla", "Model S", 100)
print(tesla.display_info())  # Tesla Model S, 배터리: 100kWh
```

## 다중 상속과 MRO (Method Resolution Order)

파이썬은 여러 부모 클래스로부터 상속받는 다중 상속을 지원합니다. 이때 메서드 검색 순서는 MRO 알고리즘에 의해 결정됩니다.

```python
class Printable:
    def print_info(self):
        print("Printable 클래스의 print_info 메서드")

class Savable:
    def save(self):
        print("Savable 클래스의 save 메서드")
    
    def print_info(self):
        print("Savable 클래스의 print_info 메서드")

class Document(Printable, Savable):
    """다중 상속 예제"""
    def __init__(self, title, content):
        self.title = title
        self.content = content
    
    def print_info(self):
        # 부모 클래스의 메서드 호출
        super().print_info()
        print(f"문서 제목: {self.title}")

# MRO 확인
print(Document.mro())
# [<class '__main__.Document'>, <class '__main__.Printable'>, 
#  <class '__main__.Savable'>, <class 'object'>]

# 사용 예시
doc = Document("보고서", "내용입니다.")
doc.print_info()
# Printable 클래스의 print_info 메서드
# 문서 제목: 보고서

doc.save()  # Savable 클래스의 save 메서드
```

### 다이아몬드 상속 문제와 해결

다중 상속에서 동일한 부모 클래스를 두 번 이상 상속받는 경우 발생하는 문제를 해결하기 위해 파이썬은 C3 선형화 알고리즘을 사용합니다.

```python
class A:
    def method(self):
        print("A 클래스의 method")

class B(A):
    def method(self):
        print("B 클래스의 method")
        super().method()

class C(A):
    def method(self):
        print("C 클래스의 method")
        super().method()

class D(B, C):
    def method(self):
        print("D 클래스의 method")
        super().method()

# MRO 확인
print(D.mro())  # [D, B, C, A, object]

# 메서드 호출
d = D()
d.method()
# D 클래스의 method
# B 클래스의 method
# C 클래스의 method
# A 클래스의 method
```

## 연산자 오버로딩: 사용자 정의 타입에 연산 추가하기

연산자 오버로딩을 통해 사용자 정의 클래스에 수학적 연산자나 비교 연산자를 적용할 수 있습니다. 이는 특수 메서드(던더 메서드)를 구현함으로써 가능합니다.

### 기본 산술 연산자 오버로딩

```python
class Vector2D:
    """2차원 벡터 클래스"""
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    # 문자열 표현
    def __repr__(self):
        return f"Vector2D({self.x}, {self.y})"
    
    def __str__(self):
        return f"({self.x}, {self.y})"
    
    # 덧셈 연산자
    def __add__(self, other):
        if isinstance(other, Vector2D):
            return Vector2D(self.x + other.x, self.y + other.y)
        elif isinstance(other, (int, float)):
            return Vector2D(self.x + other, self.y + other)
        return NotImplemented
    
    # 반대쪽 덧셈 (3 + vector 같은 경우)
    def __radd__(self, other):
        return self.__add__(other)
    
    # 제자리 덧셈 (+= 연산자)
    def __iadd__(self, other):
        if isinstance(other, Vector2D):
            self.x += other.x
            self.y += other.y
        elif isinstance(other, (int, float)):
            self.x += other
            self.y += other
        else:
            return NotImplemented
        return self
    
    # 뺄셈 연산자
    def __sub__(self, other):
        if isinstance(other, Vector2D):
            return Vector2D(self.x - other.x, self.y - other.y)
        elif isinstance(other, (int, float)):
            return Vector2D(self.x - other, self.y - other)
        return NotImplemented
    
    # 곱셈 연산자 (스칼라 곱)
    def __mul__(self, scalar):
        if isinstance(scalar, (int, float)):
            return Vector2D(self.x * scalar, self.y * scalar)
        return NotImplemented
    
    def __rmul__(self, scalar):
        return self.__mul__(scalar)
    
    # 비교 연산자
    def __eq__(self, other):
        if isinstance(other, Vector2D):
            return self.x == other.x and self.y == other.y
        return NotImplemented
    
    # 길이 (벡터의 크기)
    def __abs__(self):
        return (self.x ** 2 + self.y ** 2) ** 0.5

# 사용 예시
v1 = Vector2D(1, 2)
v2 = Vector2D(3, 4)

print(v1 + v2)           # (4, 6)
print(v1 + 5)            # (6, 7)
print(5 + v1)            # (6, 7) - __radd__ 덕분에 가능
print(v1 - v2)           # (-2, -2)
print(v1 * 3)            # (3, 6)
print(3 * v1)            # (3, 6) - __rmul__ 덕분에 가능
print(v1 == Vector2D(1, 2))  # True
print(abs(v1))           # 2.236... (√5)

# 제자리 연산
v1 += v2
print(v1)  # (4, 6)
```

### 비교 연산자와 `functools.total_ordering`

여러 비교 연산자를 구현해야 할 때 `functools.total_ordering` 데코레이터를 사용하면 `__eq__`와 `__lt__`, `__le__`, `__gt__`, `__ge__` 중 하나만 구현해도 나머지 비교 연산자를 자동으로 제공합니다.

```python
from functools import total_ordering

@total_ordering
class Student:
    def __init__(self, name, score):
        self.name = name
        self.score = score
    
    def __repr__(self):
        return f"Student({self.name}, {self.score})"
    
    # 동등성 비교
    def __eq__(self, other):
        if not isinstance(other, Student):
            return NotImplemented
        return self.score == other.score
    
    # 작음 비교 (total_ordering이 나머지를 생성해줌)
    def __lt__(self, other):
        if not isinstance(other, Student):
            return NotImplemented
        return self.score < other.score

# 사용 예시
alice = Student("Alice", 85)
bob = Student("Bob", 92)
charlie = Student("Charlie", 85)

print(alice == charlie)   # True (점수가 같음)
print(alice < bob)        # True (85 < 92)
print(bob > alice)        # True (total_ordering이 자동 생성)
print(alice <= charlie)   # True (total_ordering이 자동 생성)
```

## 메서드 오버로딩: 파이썬의 접근 방식

파이썬은 전통적인 의미의 메서드 오버로딩(동일 이름, 다른 매개변수)을 명시적으로 지원하지 않지만, 여러 가지 방법으로 비슷한 기능을 구현할 수 있습니다.

### `typing.overload` 데코레이터 활용

타입 힌트와 함께 사용하여 정적 타입 검사기나 IDE에게 다른 시그니처를 알려줄 수 있습니다.

```python
from typing import overload, Union, List

class Calculator:
    @overload
    def add(self, x: int, y: int) -> int: ...
    
    @overload
    def add(self, x: float, y: float) -> float: ...
    
    @overload
    def add(self, x: str, y: str) -> str: ...
    
    # 실제 구현
    def add(self, x: Union[int, float, str], y: Union[int, float, str]) -> Union[int, float, str]:
        if isinstance(x, str) and isinstance(y, str):
            return x + y  # 문자열 연결
        elif isinstance(x, (int, float)) and isinstance(y, (int, float)):
            return x + y  # 수치 덧셈
        else:
            raise TypeError("같은 타입의 인자만 더할 수 있습니다.")

# 사용 예시
calc = Calculator()
print(calc.add(10, 20))        # 30
print(calc.add(3.14, 2.86))    # 6.0
print(calc.add("Hello, ", "World!"))  # "Hello, World!"
```

### `functools.singledispatchmethod` 활용

런타임에 인자의 타입에 따라 다른 동작을 수행하는 메서드를 만들 수 있습니다.

```python
from functools import singledispatchmethod
from datetime import date, datetime

class Formatter:
    @singledispatchmethod
    def format(self, value):
        return str(value)
    
    @format.register
    def _(self, value: int):
        return f"정수: {value:,}"
    
    @format.register
    def _(self, value: float):
        return f"실수: {value:.2f}"
    
    @format.register
    def _(self, value: date):
        return value.strftime("%Y년 %m월 %d일")
    
    @format.register
    def _(self, value: datetime):
        return value.strftime("%Y-%m-%d %H:%M:%S")

# 사용 예시
formatter = Formatter()
print(formatter.format(1000000))        # 정수: 1,000,000
print(formatter.format(3.14159))        # 실수: 3.14
print(formatter.format(date(2024, 8, 12)))  # 2024년 08월 12일
print(formatter.format(datetime.now())) # 현재 날짜시간 형식화
print(formatter.format([1, 2, 3]))      # [1, 2, 3] (기본 처리)
```

## 믹스인(Mixin): 코드 재사용의 유연한 접근

믹스인은 특정 기능을 제공하는 작은 클래스로, 다른 클래스에 쉽게 혼합할 수 있습니다. 상속보다 유연한 코드 재사용 방식을 제공합니다.

```python
class JSONSerializableMixin:
    """JSON 직렬화 기능을 제공하는 믹스인"""
    def to_json(self):
        import json
        # 객체의 __dict__를 JSON으로 변환
        return json.dumps(self.__dict__, ensure_ascii=False, indent=2)
    
    @classmethod
    def from_json(cls, json_str):
        import json
        data = json.loads(json_str)
        return cls(**data)

class ComparableMixin:
    """비교 연산 기능을 제공하는 믹스인"""
    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented
        return self.__dict__ == other.__dict__
    
    def __ne__(self, other):
        return not self.__eq__(other)

class ReprMixin:
    """자동 __repr__ 생성 기능을 제공하는 믹스인"""
    def __repr__(self):
        class_name = self.__class__.__name__
        attrs = ", ".join(f"{k}={v!r}" for k, v in self.__dict__.items())
        return f"{class_name}({attrs})"

# 믹스인을 활용한 클래스 생성
class Product(JSONSerializableMixin, ComparableMixin, ReprMixin):
    def __init__(self, name, price, category):
        self.name = name
        self.price = price
        self.category = category

# 사용 예시
product1 = Product("노트북", 1200000, "전자제품")
product2 = Product("노트북", 1200000, "전자제품")
product3 = Product("마우스", 25000, "전자제품")

print(product1)  # Product(name='노트북', price=1200000, category='전자제품')
print(product1 == product2)  # True
print(product1 == product3)  # False

# JSON 직렬화/역직렬화
json_str = product1.to_json()
print(json_str)

new_product = Product.from_json(json_str)
print(new_product)  # Product(name='노트북', price=1200000, category='전자제품')
```

## 추상 기반 클래스(ABC)와 프로토콜

### 추상 기반 클래스(Abstract Base Class)

ABC는 인터페이스를 정의하고, 하위 클래스가 특정 메서드를 구현하도록 강제하는 방법을 제공합니다.

```python
from abc import ABC, abstractmethod
from typing import List

class DataSource(ABC):
    """데이터 소스 인터페이스"""
    
    @abstractmethod
    def connect(self):
        """데이터 소스에 연결합니다."""
        pass
    
    @abstractmethod
    def disconnect(self):
        """데이터 소스 연결을 해제합니다."""
        pass
    
    @abstractmethod
    def fetch_data(self) -> List[dict]:
        """데이터를 가져옵니다."""
        pass
    
    @abstractmethod
    def save_data(self, data: List[dict]):
        """데이터를 저장합니다."""
        pass

class DatabaseSource(DataSource):
    """데이터베이스 데이터 소스 구현"""
    
    def __init__(self, connection_string):
        self.connection_string = connection_string
        self.connected = False
    
    def connect(self):
        print(f"데이터베이스에 연결: {self.connection_string}")
        self.connected = True
    
    def disconnect(self):
        if self.connected:
            print("데이터베이스 연결 해제")
            self.connected = False
    
    def fetch_data(self) -> List[dict]:
        if not self.connected:
            raise ConnectionError("데이터베이스에 연결되어 있지 않습니다.")
        print("데이터베이스에서 데이터 조회")
        # 실제 구현에서는 데이터베이스 쿼리 실행
        return [{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]
    
    def save_data(self, data: List[dict]):
        if not self.connected:
            raise ConnectionError("데이터베이스에 연결되어 있지 않습니다.")
        print(f"데이터베이스에 {len(data)}개 레코드 저장")
        # 실제 구현에서는 데이터베이스에 저장

# 사용 예시
try:
    # 추상 클래스는 직접 인스턴스화할 수 없음
    # source = DataSource()  # TypeError
    pass
except TypeError as e:
    print(f"에러: {e}")

# 구체적인 구현 클래스 사용
db_source = DatabaseSource("mysql://localhost/mydb")
db_source.connect()
data = db_source.fetch_data()
print(f"가져온 데이터: {data}")
db_source.disconnect()
```

### 프로토콜(Protocol)

프로토콜은 구조적 서브타이핑을 지원하여, 특정 메서드나 속성이 존재하기만 하면 호환되는 타입으로 간주합니다.

```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class Renderable(Protocol):
    """렌더링 가능한 객체 프로토콜"""
    def render(self) -> str:
        ...

class HTMLDocument:
    def __init__(self, title, content):
        self.title = title
        self.content = content
    
    def render(self) -> str:
        return f"<html><head><title>{self.title}</title></head><body>{self.content}</body></html>"

class MarkdownDocument:
    def __init__(self, title, content):
        self.title = title
        self.content = content
    
    def render(self) -> str:
        return f"# {self.title}\n\n{self.content}"

def render_document(doc: Renderable) -> str:
    """Renderable 프로토콜을 구현한 모든 객체를 렌더링"""
    return doc.render()

# 사용 예시
html_doc = HTMLDocument("제목", "HTML 내용")
md_doc = MarkdownDocument("제목", "마크다운 내용")

print(render_document(html_doc))
print(render_document(md_doc))

# 프로토콜 확인
print(isinstance(html_doc, Renderable))  # True
print(isinstance(md_doc, Renderable))    # True
```

## 데이터 클래스와 `__slots__`

### 데이터 클래스(Data Class)

`dataclass` 데코레이터는 주로 데이터를 저장하는 클래스를 간결하게 정의할 수 있게 해줍니다.

```python
from dataclasses import dataclass, field
from typing import List, Optional
from datetime import datetime

@dataclass(order=True, frozen=True)
class OrderItem:
    """주문 항목 (불변, 비교 가능)"""
    product_id: int
    product_name: str
    quantity: int
    unit_price: float
    
    @property
    def total_price(self) -> float:
        return self.quantity * self.unit_price

@dataclass
class Order:
    """주문 정보"""
    order_id: int
    customer_name: str
    items: List[OrderItem] = field(default_factory=list)
    order_date: datetime = field(default_factory=datetime.now)
    discount: Optional[float] = None
    
    def add_item(self, item: OrderItem):
        self.items.append(item)
    
    @property
    def subtotal(self) -> float:
        return sum(item.total_price for item in self.items)
    
    @property
    def total(self) -> float:
        subtotal = self.subtotal
        if self.discount:
            subtotal *= (1 - self.discount / 100)
        return subtotal
    
    def __str__(self):
        item_count = len(self.items)
        return f"주문 #{self.order_id}: {self.customer_name} ({item_count}개 항목)"

# 사용 예시
item1 = OrderItem(101, "노트북", 1, 1200000)
item2 = OrderItem(102, "마우스", 2, 25000)
item3 = OrderItem(103, "키보드", 1, 80000)

order = Order(1001, "김철수", discount=10.0)
order.add_item(item1)
order.add_item(item2)
order.add_item(item3)

print(order)
print(f"소계: {order.subtotal:,.0f}원")
print(f"할인 후: {order.total:,.0f}원")
print(f"주문 일시: {order.order_date.strftime('%Y-%m-%d %H:%M')}")

# 데이터 클래스 자동 생성 기능
print(order == Order(1001, "김철수", [item1, item2, item3]))  # False (order_date가 다름)
```

### `__slots__`를 이용한 메모리 최적화

`__slots__`를 사용하면 인스턴스의 속성 저장 방식을 최적화하여 메모리 사용량을 줄이고 속도를 높일 수 있습니다.

```python
class RegularPoint:
    """일반적인 클래스 (__dict__ 사용)"""
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

class OptimizedPoint:
    """__slots__를 사용한 최적화 클래스"""
    __slots__ = ('x', 'y', 'z')
    
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

# 메모리 사용량 비교
import sys

regular_points = [RegularPoint(i, i*2, i*3) for i in range(1000)]
optimized_points = [OptimizedPoint(i, i*2, i*3) for i in range(1000)]

print(f"일반 클래스 인스턴스 크기: {sys.getsizeof(regular_points[0])} bytes")
print(f"최적화 클래스 인스턴스 크기: {sys.getsizeof(optimized_points[0])} bytes")

total_regular = sum(sys.getsizeof(p) for p in regular_points)
total_optimized = sum(sys.getsizeof(p) for p in optimized_points)
print(f"1000개 일반 인스턴스 총 크기: {total_regular:,} bytes")
print(f"1000개 최적화 인스턴스 총 크기: {total_optimized:,} bytes")
print(f"메모리 절약율: {((total_regular - total_optimized) / total_regular * 100):.1f}%")

# __slots__ 사용 시 주의사항
try:
    optimized_points[0].color = "red"  # __slots__에 정의되지 않은 속성
except AttributeError as e:
    print(f"에러: {e}")  # 'OptimizedPoint' 객체에 'color' 속성이 없습니다
```

## 특수 메서드 심화: 컨테이너 프로토콜 구현

컨테이너 프로토콜을 구현하면 사용자 정의 객체를 리스트나 딕셔너리처럼 사용할 수 있습니다.

```python
class Playlist:
    """음악 플레이리스트 클래스 (컨테이너 프로토콜 구현)"""
    def __init__(self, name):
        self.name = name
        self._tracks = []
    
    def __len__(self):
        """len(playlist) 지원"""
        return len(self._tracks)
    
    def __getitem__(self, index):
        """playlist[index] 지원 (슬라이싱도 지원)"""
        if isinstance(index, slice):
            # 슬라이스 객체 처리
            return self._tracks[index]
        return self._tracks[index]
    
    def __setitem__(self, index, value):
        """playlist[index] = value 지원"""
        self._tracks[index] = value
    
    def __delitem__(self, index):
        """del playlist[index] 지원"""
        del self._tracks[index]
    
    def __iter__(self):
        """for track in playlist 지원"""
        return iter(self._tracks)
    
    def __contains__(self, item):
        """item in playlist 지원"""
        return item in self._tracks
    
    def __reversed__(self):
        """reversed(playlist) 지원"""
        return reversed(self._tracks)
    
    def append(self, track):
        """트랙 추가"""
        self._tracks.append(track)
    
    def insert(self, index, track):
        """특정 위치에 트랙 삽입"""
        self._tracks.insert(index, track)
    
    def __str__(self):
        track_list = "\n".join(f"  {i+1}. {track}" for i, track in enumerate(self._tracks))
        return f"플레이리스트: {self.name}\n{track_list}"

# 사용 예시
playlist = Playlist("주말 드라이빙")
playlist.append("Blinding Lights - The Weeknd")
playlist.append("Levitating - Dua Lipa")
playlist.append("Stay - The Kid LAROI, Justin Bieber")
playlist.append("Good 4 U - Olivia Rodrigo")

print(f"플레이리스트 길이: {len(playlist)}")
print(f"첫 번째 트랙: {playlist[0]}")
print(f"마지막 트랙: {playlist[-1]}")
print(f"처음 두 트랙: {playlist[:2]}")
print(f"'Stay'가 있나요? {'Stay - The Kid LAROI, Justin Bieber' in playlist}")

print("\n모든 트랙:")
for track in playlist:
    print(f"  - {track}")

print("\n역순:")
for track in reversed(playlist):
    print(f"  - {track}")

# 항목 수정
playlist[1] = "Levitating (feat. DaBaby) - Dua Lipa"
print(f"\n수정 후 두 번째 트랙: {playlist[1]}")

# 항목 삭제
del playlist[3]
print(f"\n삭제 후 길이: {len(playlist)}")
```

## 디스크립터(Descriptor): 속성 접근 제어

디스크립터는 속성 접근을 제어하는 강력한 메커니즘으로, 프로퍼티, 클래스 메서드, 정적 메서드 등이 내부적으로 디스크립터를 사용합니다.

```python
class ValidatedAttribute:
    """값 검증 디스크립터"""
    def __init__(self, min_value=None, max_value=None, allowed_values=None):
        self.min_value = min_value
        self.max_value = max_value
        self.allowed_values = allowed_values
        self.storage_name = None
    
    def __set_name__(self, owner, name):
        self.storage_name = f"_{name}"
    
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        return getattr(obj, self.storage_name)
    
    def __set__(self, obj, value):
        # 최소값 검증
        if self.min_value is not None and value < self.min_value:
            raise ValueError(f"{value}는 최소값 {self.min_value}보다 작을 수 없습니다.")
        
        # 최대값 검증
        if self.max_value is not None and value > self.max_value:
            raise ValueError(f"{value}는 최대값 {self.max_value}보다 클 수 없습니다.")
        
        # 허용 값 검증
        if self.allowed_values is not None and value not in self.allowed_values:
            raise ValueError(f"{value}는 허용된 값이 아닙니다. 허용값: {self.allowed_values}")
        
        setattr(obj, self.storage_name, value)

class ProductWithValidation:
    """검증이 적용된 상품 클래스"""
    # 디스크립터 인스턴스 생성
    price = ValidatedAttribute(min_value=0, max_value=10000000)
    quantity = ValidatedAttribute(min_value=0, max_value=1000)
    category = ValidatedAttribute(allowed_values=["전자제품", "의류", "식품", "가구"])
    
    def __init__(self, name, price, quantity, category):
        self.name = name
        self.price = price  # 디스크립터의 __set__ 호출
        self.quantity = quantity
        self.category = category
    
    @property
    def total_value(self):
        return self.price * self.quantity
    
    def __repr__(self):
        return f"Product(name={self.name!r}, price={self.price}, quantity={self.quantity}, category={self.category!r})"

# 사용 예시
try:
    # 정상적인 값
    laptop = ProductWithValidation("노트북", 1200000, 10, "전자제품")
    print(laptop)
    print(f"총 가치: {laptop.total_value:,}원")
    
    # 잘못된 가격
    # invalid_product = ProductWithValidation("상품", -1000, 10, "전자제품")
    
    # 잘못된 수량
    # invalid_product = ProductWithValidation("상품", 1000, -5, "전자제품")
    
    # 잘못된 카테고리
    # invalid_product = ProductWithValidation("상품", 1000, 10, "책")
    
    # 속성 값 변경 시에도 검증 적용
    laptop.price = 1500000  # 성공
    print(f"가격 변경 후: {laptop.price}")
    
    laptop.price = -500000  # ValueError 발생
    
except ValueError as e:
    print(f"검증 실패: {e}")
```

## 실전 예제: 은행 계좌 시스템 구현

여러 고급 개념을 종합적으로 적용한 실전 예제로 은행 계좌 시스템을 구현해보겠습니다.

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import List, Optional
from decimal import Decimal
import json

class Transaction:
    """거래 내역 클래스"""
    def __init__(self, amount: Decimal, transaction_type: str, description: str = ""):
        self.amount = amount
        self.type = transaction_type  # 'deposit', 'withdrawal', 'transfer'
        self.description = description
        self.timestamp = datetime.now()
    
    def __repr__(self):
        return (f"Transaction(amount={self.amount}, type={self.type!r}, "
                f"description={self.description!r}, timestamp={self.timestamp})")
    
    def to_dict(self):
        """딕셔너리로 변환"""
        return {
            'amount': float(self.amount),
            'type': self.type,
            'description': self.description,
            'timestamp': self.timestamp.isoformat()
        }

class Account(ABC):
    """계좌 추상 기본 클래스"""
    
    def __init__(self, account_number: str, owner_name: str, initial_balance: Decimal = Decimal('0')):
        self.account_number = account_number
        self.owner_name = owner_name
        self._balance = initial_balance
        self._transactions: List[Transaction] = []
        self._interest_rate = Decimal('0')
    
    @property
    def balance(self) -> Decimal:
        return self._balance
    
    @abstractmethod
    def calculate_interest(self) -> Decimal:
        """이자 계산 (하위 클래스에서 구현)"""
        pass
    
    def deposit(self, amount: Decimal, description: str = "") -> bool:
        """입금"""
        if amount <= 0:
            raise ValueError("입금액은 0보다 커야 합니다.")
        
        self._balance += amount
        transaction = Transaction(amount, 'deposit', description)
        self._transactions.append(transaction)
        return True
    
    def withdraw(self, amount: Decimal, description: str = "") -> bool:
        """출금"""
        if amount <= 0:
            raise ValueError("출금액은 0보다 커야 합니다.")
        
        if self._balance < amount:
            raise ValueError("잔액이 부족합니다.")
        
        self._balance -= amount
        transaction = Transaction(amount, 'withdrawal', description)
        self._transactions.append(transaction)
        return True
    
    def transfer(self, to_account: 'Account', amount: Decimal, description: str = "") -> bool:
        """다른 계좌로 이체"""
        if self.withdraw(amount, f"이체 to {to_account.account_number}: {description}"):
            to_account.deposit(amount, f"이체 from {self.account_number}: {description}")
            return True
        return False
    
    def get_transaction_history(self, limit: Optional[int] = None) -> List[Transaction]:
        """거래 내역 조회"""
        if limit:
            return self._transactions[-limit:]
        return self._transactions
    
    def get_statement(self) -> dict:
        """계좌 명세서 생성"""
        return {
            'account_number': self.account_number,
            'owner_name': self.owner_name,
            'balance': float(self.balance),
            'interest_rate': float(self._interest_rate),
            'transaction_count': len(self._transactions),
            'last_transaction': self._transactions[-1].to_dict() if self._transactions else None
        }
    
    def __str__(self):
        return (f"계좌번호: {self.account_number}\n"
                f"소유자: {self.owner_name}\n"
                f"잔액: {self.balance:,.0f}원\n"
                f"이자율: {self._interest_rate * 100:.2f}%")

class SavingsAccount(Account):
    """저축 계좌"""
    
    def __init__(self, account_number: str, owner_name: str, 
                 initial_balance: Decimal = Decimal('0'), 
                 interest_rate: Decimal = Decimal('0.02')):
        super().__init__(account_number, owner_name, initial_balance)
        self._interest_rate = interest_rate
    
    def calculate_interest(self) -> Decimal:
        """월별 이자 계산"""
        return self._balance * self._interest_rate / Decimal('12')
    
    def apply_interest(self):
        """이자 적용"""
        interest = self.calculate_interest()
        if interest > 0:
            self.deposit(interest, "이자 지급")

class CheckingAccount(Account):
    """당좌 계좌"""
    
    def __init__(self, account_number: str, owner_name: str, 
                 initial_balance: Decimal = Decimal('0'),
                 overdraft_limit: Decimal = Decimal('100000')):
        super().__init__(account_number, owner_name, initial_balance)
        self.overdraft_limit = overdraft_limit
    
    def calculate_interest(self) -> Decimal:
        """당좌 계좌는 이자가 없음"""
        return Decimal('0')
    
    def withdraw(self, amount: Decimal, description: str = "") -> bool:
        """한도 내에서 출금 가능 (마이너스 통장)"""
        if amount <= 0:
            raise ValueError("출금액은 0보다 커야 합니다.")
        
        if self._balance - amount < -self.overdraft_limit:
            raise ValueError("한도 초과로 출금할 수 없습니다.")
        
        self._balance -= amount
        transaction = Transaction(amount, 'withdrawal', description)
        self._transactions.append(transaction)
        return True

@dataclass
class Bank:
    """은행 클래스"""
    name: str
    accounts: List[Account] = field(default_factory=list)
    
    def open_account(self, account_type: str, owner_name: str, 
                     initial_balance: Decimal = Decimal('0'), **kwargs) -> Account:
        """새 계좌 개설"""
        import uuid
        account_number = str(uuid.uuid4())[:8].upper()
        
        if account_type == 'savings':
            account = SavingsAccount(account_number, owner_name, initial_balance, **kwargs)
        elif account_type == 'checking':
            account = CheckingAccount(account_number, owner_name, initial_balance, **kwargs)
        else:
            raise ValueError(f"알 수 없는 계좌 타입: {account_type}")
        
        self.accounts.append(account)
        return account
    
    def find_account(self, account_number: str) -> Optional[Account]:
        """계좌번호로 계좌 찾기"""
        for account in self.accounts:
            if account.account_number == account_number:
                return account
        return None
    
    def total_deposits(self) -> Decimal:
        """전체 예금 총액"""
        return sum(account.balance for account in self.accounts)
    
    def apply_interest_to_all(self):
        """모든 저축 계좌에 이자 적용"""
        for account in self.accounts:
            if isinstance(account, SavingsAccount):
                account.apply_interest()
    
    def generate_report(self) -> dict:
        """은행 리포트 생성"""
        return {
            'bank_name': self.name,
            'total_accounts': len(self.accounts),
            'total_deposits': float(self.total_deposits()),
            'accounts': [account.get_statement() for account in self.accounts]
        }

# 사용 예시
def main():
    # 은행 생성
    my_bank = Bank("행복은행")
    
    # 계좌 개설
    print("=== 계좌 개설 ===")
    alice_savings = my_bank.open_account(
        'savings', 'Alice', Decimal('1000000'), interest_rate=Decimal('0.03')
    )
    bob_checking = my_bank.open_account(
        'checking', 'Bob', Decimal('500000'), overdraft_limit=Decimal('200000')
    )
    
    print(f"Alice의 저축계좌:\n{alice_savings}\n")
    print(f"Bob의 당좌계좌:\n{bob_checking}\n")
    
    # 입출금 및 이체
    print("=== 거래 실행 ===")
    alice_savings.deposit(Decimal('200000'), "월급")
    print(f"Alice 입금 후 잔액: {alice_savings.balance:,.0f}원")
    
    bob_checking.withdraw(Decimal('100000'), "생활비")
    print(f"Bob 출금 후 잔액: {bob_checking.balance:,.0f}원")
    
    alice_savings.transfer(bob_checking, Decimal('300000'), "대출 상환")
    print(f"이체 후 Alice 잔액: {alice_savings.balance:,.0f}원")
    print(f"이체 후 Bob 잔액: {bob_checking.balance:,.0f}원")
    
    # 이자 적용
    print("\n=== 이자 적용 ===")
    alice_savings.apply_interest()
    print(f"이자 적용 후 Alice 잔액: {alice_savings.balance:,.0f}원")
    
    # 거래 내역 조회
    print("\n=== Alice 거래 내역 (최근 3건) ===")
    for transaction in alice_savings.get_transaction_history(3):
        print(f"  {transaction.timestamp.strftime('%Y-%m-%d %H:%M')}: "
              f"{transaction.type} {transaction.amount:,.0f}원 - {transaction.description}")
    
    # 은행 리포트
    print("\n=== 은행 리포트 ===")
    report = my_bank.generate_report()
    print(f"은행명: {report['bank_name']}")
    print(f"총 계좌수: {report['total_accounts']}")
    print(f"총 예금액: {report['total_deposits']:,.0f}원")

if __name__ == "__main__":
    main()
```

## 결론

파이썬의 클래스 시스템은 단순한 객체 생성 도구를 넘어서, 객체지향 프로그래밍의 모든 핵심 개념을 구현할 수 있는 풍부한 기능을 제공합니다. 상속과 다형성을 통한 코드 재사용, 연산자 오버로딩을 통한 자연스러운 사용자 정의 타입, 추상 클래스와 프로토콜을 통한 인터페이스 설계 등은 모두 강력한 소프트웨어를 구축하는 데 필수적인 도구들입니다.

이러한 고급 기능들을 효과적으로 활용하기 위해서는:

1. **적절한 상속 구조 설계**: "is-a" 관계가 명확할 때만 상속을 사용하고, 그렇지 않다면 조합(Composition)이나 믹스인을 고려하세요.
2. **연산자 오버로딩의 현명한 사용**: 사용자 정의 타입이 기본 타입처럼 자연스럽게 동작하도록 하지만, 지나친 오버로딩은 오히려 가독성을 해칠 수 있습니다.
3. **추상화의 적절한 수준**: ABC는 구현 강제가 필요할 때, 프로토콜은 덕 타이핑이 적합할 때 사용하세요.
4. **성능과 가독성의 균형**: `__slots__`나 데이터 클래스 같은 기능은 성능을 높이지만, 유연성을 제한할 수 있습니다.
5. **실제 문제 해결에 초점**: 고급 기능은 복잡성을 정당화할 만한 실제 문제를 해결할 때만 사용하세요.

파이썬 클래스의 심화 개념들을 이해하고 적절히 활용하면, 더 모듈화되고 유지보수하기 쉬운 코드를 작성할 수 있습니다. 이러한 개념들은 대규모 애플리케이션 개발, 프레임워크 설계, 복잡한 도메인 모델링 등에서 특히 중요하게 작용합니다.