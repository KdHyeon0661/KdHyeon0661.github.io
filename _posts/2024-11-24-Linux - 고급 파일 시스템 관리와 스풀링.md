---
layout: post
title: Linux - 고급 파일 시스템 관리와 스풀링
date: 2024-11-24 19:20:23 +0900
category: Linux
---
# 고급 파일 시스템 관리와 스풀링

## 1. 스풀링(Spooling) 이해 — **느린 장치 앞에 버퍼(큐)를 둔다**

스풀링은 **“Simultaneous Peripheral Operations On-Line”**의 약자로, I/O 속도가 느린 대상(프린터, 원격 MTA, 배치 작업 등) 앞에 **임시 저장소(대기열)**를 두고 **비동기 처리**하는 기술입니다. 핵심 포인트:

- **프로듀서(생산자)**: 애플리케이션/사용자 → **스풀 디렉토리**에 작업 제출
- **컨슈머(소비자)**: 데몬/서비스가 큐에서 읽어 실제 장치/원격지로 전송
- 실패 시 **재시도/지연 큐**로 이동, 관리 명령으로 **플러시/삭제/보류** 처리

### 대표 스풀 디렉토리(실무에서 자주 보는 경로)

| 서비스/기능 | 주요 스풀 경로(예) | 관리 명령(대표) |
|---|---|---|
| **cron** | `/var/spool/cron` (RHEL), `/var/spool/cron/crontabs` (Debian) | `crontab -l/-e`, 파일 직접 수정 금지 |
| **at** | `/var/spool/at` 또는 `/var/spool/atjobs` | `atq`, `atrm`, `at -c` |
| **메일(Postfix)** | `/var/spool/postfix/{active,deferred,maildrop,...}` | `postqueue -p`, `postfix flush`, `postsuper -d` |
| **메일(Exim)** | `/var/spool/exim` | `exim -bp`, `exim -Mrm`, `exim -qf` |
| **프린터(CUPS)** | `/var/spool/cups` | `lpstat -o`, `cancel`, `lpadmin`, `cupsctl` |
| **anacron** | `/var/spool/anacron` | `anacron -n`, 주기적 실행 |
| **maildir/mbox(사용자)** | `/var/spool/mail/USER`(mbox) 또는 각 홈의 `Maildir/` | MTA/IMAP 데몬이 관리 |

> **원칙**: 스풀 디렉토리의 파일을 **임의로 삭제**하기 전에 **해당 서비스의 관리 명령**으로 처리하는 것이 최우선입니다. (무삭제·무부하·무데이터손실)

---

## 2. 스풀 관리: **안전한 관측 → 큐 제어 → 필요 시 정리**

### 2.1 스풀 상태 점검(읽기 전용 관찰)

```bash
# CUPS 프린트 큐
lpstat -o          # 대기중 작업 목록
lpq                # 프린터별 큐 상태(전통)

# Postfix 메일 큐
postqueue -p       # 큐 나열
mailq              # 동일

# Exim 메일 큐
exim -bp           # 큐 요약
exiqgrep -i -o 1h  # 1시간 이상된 메시지 ID 추려보기

# cron 스풀 존재 확인 (직접 편집 금지)
ls -l /var/spool/cron
ls -l /var/spool/cron/crontabs    # Debian 계열
```

### 2.2 큐 제어(삭제/보류/재시도는 **서비스 명령**으로)

```bash
# Postfix: 지연 큐 강제 재시도 및 비우기(신중)
postfix flush             # 즉시 전송 시도
postsuper -d ALL deferred # 지연 큐 전체 삭제(복구 불가 주의)
postsuper -d <MSGID>      # 특정 메시지 삭제

# Exim
exim -Mrm <MSGID>         # 메시지 삭제
exim -qf                  # 큐 즉시 처리 시도

# CUPS 인쇄 작업 취소
lpstat -o
cancel <JOB-ID>
```

### 2.3 정말 지저분해졌다면? **서비스 중지 → 백업 → 정리 → 서비스 재기동**

```bash
# 1. 서비스 중지(스풀 파일이 변경 중이 아니게)
systemctl stop postfix
systemctl stop cups

# 2. 스풀 백업(삭제 전 스냅샷 관성)
tar -C /var/spool -czf /root/spool-backup-$(date +%F-%T).tar.gz postfix cups

# 3. 정책 기반 정리(예: 7일 이상 된 임시 파일만)
find /var/spool/postfix/deferred -type f -mtime +7 -print -delete

# 4. 서비스 재기동
systemctl start postfix
systemctl start cups
```

> **SELinux/AppArmor 활성 시스템**이라면, 수동 파일 조작 후 **컨텍스트 복구** 필요:
```bash
restorecon -R /var/spool/postfix
restorecon -R /var/spool/cups
```

---

## 3. 스풀 자동 청소 — `systemd-tmpfiles`와 주기적 정책

수동 스크립트 대신 **정책 파일** 한 장으로 깔끔하게 관리.

### 3.1 `tmpfiles.d` 규칙 예시

```ini
# /etc/tmpfiles.d/spool-cleanup.conf
# 형식: 타입 경로 모드 UID GID 나이 인수
# D: 디렉토리 보장, r: 정리, X: 패턴 제외
d /var/spool/cups 0755 root lp - -
r /var/spool/cups - - - 7d
r /var/spool/postfix/deferred - - - 10d
```

적용/시뮬레이션:
```bash
systemd-tmpfiles --create
systemd-tmpfiles --clean --prefix=/var/spool/cups
```

### 3.2 `cron`으로 주기 청소(대안)
```bash
# /etc/cron.daily/spool-vacuum
#!/bin/sh
find /var/spool/postfix/deferred -type f -mtime +10 -delete
find /var/spool/cups -type f -mtime +7 -delete
```

> **항상 원칙**: 먼저 **서비스 레벨 명령으로 큐를 비우는 방식**을 선호. 파일 직접 삭제는 마지막 수단.

---

## 4. 파일 시스템 점검과 복구 — **FS 타입별 정석 절차**

### 4.1 ext4 (e2fsck)

```bash
# 안전: 반드시 언마운트(또는 읽기전용 마운트) 후
umount /dev/sda1
e2fsck -f -C 0 /dev/sda1      # 강제 점검, 진행률
e2fsck -p /dev/sda1           # 자동 복구(무인)
e2fsck -y /dev/sda1           # 모든 질문 yes(신중)
```

루트 파티션은 **라이브 환경** 또는 **시스템 복구 모드**에서.

### 4.2 XFS (xfs_repair) — `fsck.xfs`는 **수리 불가 경고**

```bash
umount /dev/sdb1
xfs_repair -n /dev/sdb1   # 점검 시뮬레이션
xfs_repair    /dev/sdb1   # 실제 수리
```

> XFS는 저널링 설계상 e2fsck와 다르므로 **전용 도구**만 사용.

### 4.3 Btrfs — `scrub`/`check`/`balance`

```bash
# 온라인 scrub(데이터/메타데이터 검증, RAID라면 자동 복구)
btrfs scrub start -Bd /mnt

# 오프라인(신중) 체크
umount /dev/sdc1
btrfs check --readonly /dev/sdc1
# 강제 복구 옵션은 데이터 손실 위험 → 문서 숙지 후 제한적으로
```

### 4.4 루프/암호화/RAID/LVM 레이어 고려

- **LVM**: LV(device-mapper) 단위로 언마운트 후 점검 → `fsck /dev/mapper/vg-lv`
- **mdadm RAID**: `/proc/mdstat`로 재구성 상태 확인 후, 구성 디바이스가 아닌 **어레이 디바이스(mdX)**를 점검
- **LUKS**: `cryptsetup open`으로 매핑 장치 열고 **그 장치**에 fsck
- **스냅샷(권장)**: LVM/Btrfs/ZFS 스냅샷 후 점검/백업 → 롤백 안전

---

## 5. 용량/아이노드 문제를 “운영자처럼” 잡아내기

### 5.1 전체/마운트별 용량 & 아이노드

```bash
df -h            # 전체 용량
df -i            # 아이노드 사용량(작은 파일 폭탄 감지)
```

### 5.2 디렉토리별 상위 사용처 — `du`와 `ncdu`

```bash
du -xh --max-depth=1 /var | sort -h   # 파일시스템 경계 유지: -x
ncdu /var                             # 대화형 뷰(추천)
```

옵션 팁:
- `--apparent-size`: **스파스 파일**을 실제 데이터량 대신 **논리 크기**로 계산 (주의)
- `-x`: 다른 파일시스템으로 넘어가지 않도록(마운트 걸친 서버에서 유용)

### 5.3 삭제했는데 공간이 안 줄어든다? → `deleted-but-open` 누수

```bash
# 삭제된 파일을 아직 열고 있는 프로세스 찾기
lsof +L1 | awk 'NR==1 || $7<0'   # 링크 카운트 0(삭제)인데 열려있는 항목
# 또는
lsof | grep '(deleted)'
```

조치:
1) 해당 PID에 서비스 재시작(가장 안전)
2) 불가하면 해당 FD를 닫도록 프로세스 종료

### 5.4 저널/로그가 잡아먹는 공간 즉시 회수

```bash
# systemd-journald
journalctl --disk-usage
journalctl --vacuum-size=1G
journalctl --vacuum-time=7d
```

### 5.5 상위 N개 대형 파일/디렉토리 신속 파악

```bash
# 디렉토리 기준
du -xh / | sort -h | tail -n 50

# 파일 기준(하위 전체)
find / -xdev -type f -size +100M -printf '%s %p\n' 2>/dev/null \
| sort -nr | head -n 50
```

---

## 6. 예약 블록/마운트 옵션/튜닝 — **안정성 vs 성능 균형**

### 6.1 ext4 예약 블록 — `tune2fs -m`

```bash
# 예약 블록 비율 확인
tune2fs -l /dev/sda1 | grep -i 'Reserved block'

# 비율 조정(예: 1%)
tune2fs -m 1 /dev/sda1
```

- 대용량 데이터 전용 파티션(루트 아님)은 0~1% 권장
- 루트/시스템 파티션은 여유 유지(관리자 로그인/복구 여지)

### 6.2 /etc/fstab 마운트 옵션 설계

```fstab
UUID=...  /          ext4  defaults,relatime       0 1
UUID=...  /data      ext4  noatime,nodiratime      0 2
UUID=...  /var       xfs   noatime,attr2,inode64   0 2
UUID=...  /ssd       ext4  discard,errors=remount-ro 0 2
```

옵션 가이드:
- `relatime`(기본): 성능 괜찮고 atime 보존
- `noatime`/`nodiratime`: 쓰기 줄여 성능 ↑(atime 필요 없을 때)
- `discard`: SSD TRIM 온라인(대신 주기적 `fstrim.timer` 권장)
- `errors=remount-ro`: 오류 시 read-only 재마운트(데이터 보호)

### 6.3 파일시스템별 특징적 튜닝

- **ext4**: `tune2fs -O`로 기능 플래그(신중), `journal_async_commit` 등 마운트 최적화
- **XFS**: 기본 성능 우수, 파일 수/큰 파일에 강함. 마운트 시 `inode64`, `noatime` 흔함
- **Btrfs**: 압축(`compress=zstd`), 스냅샷, RAID 기능. 주기 `btrfs scrub` 강추

---

## 7. 스풀/파일시스템 **자동화 레시피** 모음

### 7.1 스풀 자동 정리 + 보고서 메일

```bash
#!/usr/bin/env bash
# /usr/local/sbin/spool-maint.sh
set -Eeuo pipefail
LOG="/var/log/spool-maint-$(date +%F).log"

{
  echo "# Spool maintenance @ $(date)"
  echo "## postfix deferred >10d"
  find /var/spool/postfix/deferred -type f -mtime +10 -printf '%P\n' | tee /dev/fd/3 | wc -l
  find /var/spool/postfix/deferred -type f -mtime +10 -delete

  echo "## cups >7d"
  find /var/spool/cups -type f -mtime +7 -printf '%P\n' | wc -l
  find /var/spool/cups -type f -mtime +7 -delete

  echo "## journal vacuum 7d"
  journalctl --vacuum-time=7d
} 3>>"$LOG" | tee -a "$LOG"

# 선택: 관리자 메일 보고(운영 메일링 구성 시)
# mail -s "[spool] cleanup report $(hostname)" admin@example.com < "$LOG"
```

크론 등록:
```cron
# /etc/cron.daily/spool-maint
/usr/local/sbin/spool-maint.sh
```

### 7.2 용량 경보(임계치 알림)

```bash
#!/usr/bin/env bash
THRESH=90
ALERT=""
while read -r use mount; do
  pct=${use%%%}
  if [ "$pct" -ge "$THRESH" ]; then
    ALERT="$ALERT\n$mount at ${use}"
  fi
done < <(df -hP | awk 'NR>1{print $5, $6}')

if [ -n "$ALERT" ]; then
  printf "Disk usage alert on %s:%b\n" "$(hostname)" "$ALERT" \
  | mail -s "Disk alert $(hostname)" admin@example.com
fi
```

### 7.3 아이노드 고갈 경보

```bash
#!/usr/bin/env bash
df -Pi | awk 'NR>1 { if ($5+0 >= 90) print "INODE ALERT:", $6, $5 }'
```

---

## 8. “망가지기 전에” 건강 상태 모니터링

- **SMART**: 물리 디스크 상태
  ```bash
  smartctl -a /dev/sda
  smartctl -t short /dev/sda
  ```
- **RAID(mdadm)**:
  ```bash
  cat /proc/mdstat
  mdadm --detail /dev/md0
  ```
- **Btrfs scrub**(월 1회):
  ```bash
  systemctl enable --now btrfs-scrub@-.timer
  ```
- **fstrim(SSD TRIM)**:
  ```bash
  systemctl status fstrim.timer
  systemctl enable --now fstrim.timer
  ```

---

## 9. 실전 트러블슈팅 시나리오

### 시나리오 A: `/var` 가득 참, 서비스 다운 직전
1) **누수 식별**
```bash
df -h /var
du -xh --max-depth=1 /var | sort -h | tail
lsof | grep '(deleted)' | grep '/var'   # 삭제됐지만 열린 로그?
journalctl --disk-usage
```
2) **즉시 응급 조치**
- `journalctl --vacuum-time=3d`
- 대형 로그 logrotate 강제:
  ```bash
  logrotate -vf /etc/logrotate.conf
  ```
- `lsof +L1`로 열린-삭제 파일 프로세스 재시작
3) **원인 해결**
- 과도한 큐(스풀) → 서비스 명령으로 플러시/삭제
- 로그 레벨/로테이션 정책 재설계

### 시나리오 B: “삭제했는데 여전히 100%”
- 대부분 **deleted-but-open** 케이스
```bash
lsof +L1 | awk 'NR==1 || $7<0'
# 대상 PID 서비스 재시작
systemctl restart myservice
```

### 시나리오 C: 루트 파일시스템 오류 의심
- **라이브 환경** 부팅 → 언마운트 후 fsck
- ext4:
  ```bash
  e2fsck -f -C 0 /dev/mapper/vg-root
  ```
- XFS:
  ```bash
  xfs_repair -n /dev/mapper/vg-root
  xfs_repair    /dev/mapper/vg-root
  ```
- 복구 전 **스냅샷/백업** 확보 필수

---

## 10. 명령어/파일 요약(운영자 포켓 레퍼런스)

| 영역 | 명령/파일 | 설명 |
|---|---|---|
| 스풀 큐 | `postqueue -p`, `postfix flush`, `postsuper -d`, `lpstat -o`, `cancel` | 메일/프린터 큐 관찰·제어 |
| 스풀 경로 | `/var/spool/postfix`, `/var/spool/cups`, `/var/spool/cron` | 서비스별 대기열 디렉토리 |
| 자동 정리 | `systemd-tmpfiles`, `/etc/tmpfiles.d/*.conf` | 정책 기반 청소 |
| 파일시스템 점검 | `e2fsck`, `xfs_repair`, `btrfs scrub/check` | FS별 전용 도구 |
| 용량/아이노드 | `df -h/-i`, `du -xh`, `ncdu` | 사용량/아이노드/상위 디렉토리 |
| 누수 추적 | `lsof +L1`, `journalctl --disk-usage` | 삭제됐지만 열린 파일, 저널 크기 |
| 튜닝 | `tune2fs -m`, `/etc/fstab`(`noatime`, `discard`, `relatime`) | 예약 블록·마운트 옵션 |
| 보안컨텍스트 | `restorecon -R /var/spool/...` | SELinux 문맥 복구 |
| SSD 관리 | `fstrim.timer` | 주기적 TRIM |

---

## 부록 A) 안전한 스풀 정리 스크립트(템플릿)

```bash
#!/usr/bin/env bash
# /usr/local/sbin/safe-spool-clean.sh
set -Eeuo pipefail

SERVICES=(postfix cups)
for s in "${SERVICES[@]}"; do systemctl is-active --quiet "$s" && systemctl stop "$s"; done

tar -C /var/spool -czf "/root/spool-snapshot-$(date +%F-%H%M).tgz" postfix cups || true

# 10일 지난 postfix 지연큐만 제거(정책에 맞게)
find /var/spool/postfix/deferred -type f -mtime +10 -print -delete

# 7일 지난 CUPS 잔재 제거
find /var/spool/cups -type f -mtime +7 -print -delete

restorecon -R /var/spool/postfix /var/spool/cups || true

for s in "${SERVICES[@]}"; do systemctl start "$s"; done
echo "Done."
```

---

## 부록 B) ext4 예약 블록/정보 조회

```bash
tune2fs -l /dev/sda1 | egrep -i 'Block count|Reserved block|Mount count|Last checked'
```

---

## 마무리

- **스풀(큐)은 파일이 아니라 “서비스가 관리하는 대기열”**입니다. 먼저 **서비스 명령으로 비우고**, 불가할 때에만 파일 수준 처리를 합니다.
- 파일 시스템 점검은 **타입별 정석 도구**를 쓰고, 가능하면 **스냅샷 후** 진행합니다.
- 용량 문제는 **아이노드/저널/삭제-열림 누수**를 함께 보세요.
- **예약 블록/마운트 옵션**은 안정성·성능 균형을 잡는 핵심 레버입니다.
- 마지막으로, **자동화(tmpfiles/크론)**로 “깨끗한 상태를 유지”하면 위기 자체가 줄어듭니다.
