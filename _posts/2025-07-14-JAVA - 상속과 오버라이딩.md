---
layout: post
title: Java - 상속과 오버라이딩
date: 2025-07-14 22:20:23 +0900
category: Java
---
# 상속(Inheritance)과 오버라이딩(Overriding)

## 1. 상속(Inheritance)

### 1.1 정의와 목적
- 기존 클래스를 **확장**해 **필드/메서드 재사용** + **행동 확장/변경**.
- **다형성(polymorphism)** 의 기반: 부모 타입으로 **자식 인스턴스 대체** 가능.

### 1.2 기본 문법과 특징
```java
class Parent {
    // 필드, 생성자, 메서드
}
class Child extends Parent {
    // 새로운 필드/메서드, 또는 오버라이딩
}
```

- Java는 **단일 상속**(클래스 기준)만 지원.
- 모든 클래스의 최상위는 **`java.lang.Object`**.
- **생성자(constructor)는 상속되지 않음**(하지만 `super(...)`로 호출 가능).

### 1.3 간단 예제
```java
class Animal {
    String name;
    void sound() { System.out.println("동물이 소리를 냅니다."); }
}
class Dog extends Animal {
    void bark() { System.out.println("멍멍!"); }
}
public class Demo1 {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.name = "바둑이"; // 부모 필드 사용
        d.sound();        // 부모 메서드
        d.bark();         // 자식 메서드
    }
}
```

### 1.4 접근 제어 및 가시성
| 한정자 | 동일 클래스 | 같은 패키지 | 하위 클래스(다른 패키지) | 모두 |
|---|---|---|---|---|
| `private` | O | X | X | X |
| (package-private) | O | O | X | X |
| `protected` | O | O | O(상속 경유 시) | X |
| `public` | O | O | O | O |

> **주의**: 다른 패키지의 하위 클래스에서 `protected` 멤버 접근은 **상속 경로를 통해서만** 가능.

---

## 2. 오버라이딩(Overriding)

### 2.1 정의와 성립 조건
- 부모의 메서드를 **자식 클래스에서 재정의**.
- **메서드 이름/매개변수 목록(서명)** 이 **완전히 동일**해야 함.
- 반환 타입은 **동일**하거나 **공변 반환(covariant)** (자식 타입) 허용.
- **접근 수준을 더 좁게 만들 수 없음**(동일 또는 더 넓게만 가능).
- **체크 예외**는 부모보다 **넓게 던질 수 없음**(동일/더 좁게만).

```java
class Animal {
    void sound() { System.out.println("동물 소리"); }
}
class Cat extends Animal {
    @Override
    void sound() { System.out.println("야옹!"); }
}
public class Demo2 {
    public static void main(String[] args) {
        Animal a = new Cat(); // 업캐스팅
        a.sound();            // "야옹!" (동적 디스패치)
    }
}
```

### 2.2 `@Override` 권장
- **컴파일 타임 검증** + **가독성 향상**.
- 인터페이스 메서드 구현에도 사용(현대 자바).

### 2.3 공변 반환(Covariant Return)
```java
class Parent { Number get() { return 1; } }
class Child  extends Parent {
    @Override
    Integer get() { return 2; } // Number의 하위 → 허용
}
```

> 제네릭은 **불변**이므로 `List<Object>` ← `List<String>` 식의 공변 반환은 **불가**.

### 2.4 예외 선언 제약
```java
class P {
    void f() throws java.io.IOException {}
}
class C extends P {
    @Override
    void f() /* throws Exception */ {} // 더 넓은 Exception은 불가
}
```
- **언체크(RuntimeException)** 는 제약 없음.

### 2.5 `final`/`static`/`private`와 오버라이딩
- `final` 메서드/클래스: **오버라이딩/상속 불가**.
- `static` 메서드는 **오버라이딩이 아니라 숨김(hiding)**.
- `private` 메서드는 상속되지 않으므로 **오버라이딩 대상이 아님**.

```java
class P {
    static void s() { System.out.println("P.s"); }
    private void h() {}
    final void k() {}
}
class C extends P {
    static void s() { System.out.println("C.s"); } // 숨김
    // @Override void h() {} // 불가(상속/가시성 X)
    // @Override void k() {} // 불가(final)
}
```

---

## 3. `super`와 생성자 체이닝

### 3.1 `super`로 부모 멤버 호출
```java
class Animal {
    void sound() { System.out.println("동물 소리"); }
}
class Dog extends Animal {
    @Override
    void sound() {
        super.sound();  // 부모 구현 사용
        System.out.println("멍멍!");
    }
}
```

### 3.2 생성자에서 `super(...)`
- **첫 문장**이어야 함.
- 생략 시 **암묵적 `super()`** 호출. 부모에 기본 생성자가 없으면 **명시** 필요.

```java
class Animal {
    Animal(String name) { System.out.println("Animal: " + name); }
}
class Dog extends Animal {
    Dog() {
        super("바둑이"); // 반드시 첫 줄
        System.out.println("Dog()");
    }
}
```

### 3.3 초기화(생성) 순서
1) **부모 필드/초기화 블록** → **부모 생성자**
2) **자식 필드/초기화 블록** → **자식 생성자**

> **함정**: 생성자/필드 초기화 중 **오버라이딩 가능한 메서드 호출 금지**. 아직 자식 필드가 초기화되지 않아 **NPE/이상 상태** 위험.

```java
class P {
    P() { init(); } // 오버라이딩 가능 메서드 호출(위험)
    void init() {}
}
class Q extends P {
    String s = "ready";
    @Override void init() { System.out.println(s.toUpperCase()); } // s 아직 null일 수 있음
}
```

---

## 4. 필드 숨김(Field Hiding) vs 메서드 오버라이딩

- **필드 접근은 정적 바인딩**(참조 타입 기준), **메서드는 동적 바인딩**(실제 객체 기준).

```java
class P {
    int v = 1;
    int getV() { return v; }
}
class C extends P {
    int v = 2; // 숨김
    @Override int getV() { return v; }
}
public class Demo3 {
    public static void main(String[] args) {
        P x = new C();
        System.out.println(x.v);     // 1 (필드: 참조 타입 P)
        System.out.println(x.getV()); // 2 (메서드: 동적 디스패치)
    }
}
```

필드를 꼭 구분해 접근해야 하면 `super.v`를 사용할 수 있습니다(가시성 허용 범위 내).

---

## 5. 추상 클래스/메서드와 템플릿 메서드

### 5.1 추상 선언
```java
abstract class Shape {
    abstract double area();   // 구현 강제
    void draw() { System.out.println("draw " + area()); } // 공통 로직
}
class Circle extends Shape {
    final int r;
    Circle(int r) { this.r = r; }
    @Override double area() { return Math.PI * r * r; }
}
```

### 5.2 템플릿 메서드 패턴
- 상위 클래스가 **알고리즘 골격**을 제공, 하위에서 **후크(hook)** 오버라이딩.

---

## 6. 인터페이스와 오버라이딩(구현)

### 6.1 기본
```java
interface Printer {
    void print(String s);
}
class ConsolePrinter implements Printer {
    @Override public void print(String s) { System.out.println(s); }
}
```

### 6.2 `default` 메서드(다중 상속 스타일)
```java
interface A { default void hello() { System.out.println("A"); } }
interface B { default void hello() { System.out.println("B"); } }
class D implements A, B {
    @Override
    public void hello() {
        A.hello(); // 혹은 B.hello()
        System.out.println("D");
    }
}
```
- **다중 상속 충돌**은 구현 클래스에서 **반드시 명시적으로 해결**해야 함.

### 6.3 `default` vs 클래스 우선 규칙
- **클래스의 메서드가 항상 우선**(Class wins).
- 인터페이스의 `default`는 **없으면 상속**받고, **충돌 시 구현 클래스에서 지정**.

---

## 7. 다형성(Polymorphism)과 동적 디스패치

### 7.1 핵심
- **참조 타입**은 부모, **실제 객체 타입**은 자식일 때 오버라이딩된 메서드가 **런타임**에 선택.

```java
class P { void f(){ System.out.println("P"); } }
class C extends P { @Override void f(){ System.out.println("C"); } }

public class Demo4 {
    static void call(P p) { p.f(); }
    public static void main(String[] args) {
        call(new P()); // P
        call(new C()); // C
    }
}
```

### 7.2 오버로딩과의 차이(중요)
| 항목 | 오버라이딩 | 오버로딩 |
|---|---|---|
| 결정 시점 | **런타임**(동적) | **컴파일 타임**(정적) |
| 기준 | **동일 서명** 재정의 | **같은 이름** + **다른 매개변수 목록** |
| 다형성 | 구현(동적 디스패치) | X |
| 반환타입 | (동일/공변) 제한 | 무관 |

---

## 8. LSP(리스코프 치환 원칙)와 설계 지침

- **상위 타입 객체가 사용되는 모든 곳에 하위 타입 객체를 대입해도 동작이 깨지면 안 됨**.
- 하위 타입은 상위 타입의 **계약(사전/사후조건, 예외, 불변식)**을 준수해야 함.
- 위반 사례: 상위는 `f()`가 항상 양수 반환인데, 하위가 음수를 반환.

> 계약 위반은 상속 기반 재사용을 **취약**하게 합니다. 상속보다 **조합(composition)** 을 우선 고려하세요.

---

## 9. `equals`/`hashCode`/`toString` 오버라이딩 요령

```java
class User {
    private final String id;
    private final String name;
    User(String id, String name) { this.id = id; this.name = name; }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User other)) return false;
        return java.util.Objects.equals(id, other.id);
    }
    @Override public int hashCode() { return java.util.Objects.hash(id); }
    @Override public String toString() { return "User(" + id + "," + name + ")"; }
}
```
- `equals`와 `hashCode`는 **동시에** 재정의.
- 동치관계 성질: **반사성/대칭성/추이성/일관성**을 만족해야 함.

수학적으로:
$$
\forall a,b,c\in S:\
(a=a)\land(a=b\Rightarrow b=a)\land(a=b\land b=c\Rightarrow a=c)
$$

---

## 10. 고급 주제

### 10.1 브리지 메서드(제네릭 + 공변 반환)
- 제네릭/공변 반환 조합에서 **컴파일러가 브리지 메서드**를 생성해 다형성을 유지. (사용자는 신경 쓸 필요 거의 없음)

### 10.2 `sealed` 클래스(봉인 계층, Java 17+)
```java
sealed class Shape permits Rect, Circle {}
final class Rect extends Shape {}
final class Circle extends Shape {}
```
- 상속 허용 타입을 **명시적으로 제한**해 **패턴 매칭 `switch`** 와 함께 안전한 분기 제공.

### 10.3 `record`/`enum`
- `record`는 암묵적 `final` → **상속 불가**.
- `enum` 역시 **암묵적 최종 클래스**(단, 상수별 익명 클래스 본문은 허용).

---

## 11. 실전 예제 모음

### 11.1 `super` + 템플릿 메서드
```java
abstract class Task {
    public final void run() { // 템플릿
        pre();
        exec();
        post();
    }
    protected void pre() { System.out.println("pre"); }
    protected abstract void exec();
    protected void post() { System.out.println("post"); }
}
class CompileTask extends Task {
    @Override protected void exec() { System.out.println("javac ..."); }
}
public class Demo5 { public static void main(String[] args){ new CompileTask().run(); } }
```

### 11.2 인터페이스 다중 상속 충돌 해소
```java
interface A { default String id(){ return "A"; } }
interface B { default String id(){ return "B"; } }
class M implements A, B {
    @Override public String id() { return A.super.id() + B.super.id(); }
}
```

### 11.3 생성자에서 오버라이딩 호출 금지 사례/대안
```java
class Bad {
    Bad() { init(); }  // 오버라이딩 가능 메서드 호출(나쁨)
    void init() { /* ... */ }
}
class Worse extends Bad {
    String s;
    @Override void init() { System.out.println(s.length()); } // NPE 위험
}

// 대안: final 초기화자로 분리
class Good {
    Good() { /* 필드 초기화만 */ }
    final void start() { init(); } // 생성 후 명시 호출
    private void init() { /* 안전 */ }
}
```

### 11.4 필드 숨김 vs 메서드 동적 디스패치 재확인
```java
class A { int v=1; int get(){return v;} }
class B extends A { int v=2; @Override int get(){return v;} }
public class Demo6 {
    public static void main(String[] args){
        A a = new B();
        System.out.println(a.v);   // 1
        System.out.println(a.get());// 2
    }
}
```

---

## 12. 체크리스트

- [ ] **오버라이딩 조건**: 동일 서명 + (동일/공변) 반환 + 접근수준 축소 금지 + 체크 예외 확장 금지
- [ ] `@Override` 항상 사용
- [ ] 생성자에서 **오버라이딩 가능한 메서드 호출 금지**
- [ ] **필드 숨김**은 정적 바인딩, **메서드**는 동적 디스패치
- [ ] `static`은 **숨김**이지 오버라이딩 아님
- [ ] 인터페이스 `default` 충돌은 **구현 클래스에서 해소** (`X.super.m()`)
- [ ] `equals/hashCode`는 **쌍으로** 재정의, 계약 준수
- [ ] 상속보다 **조합** 우선(변경 가능성 낮추기)
- [ ] LSP 준수: 상위 타입의 **계약**을 하위가 **강화/보존**

---

## 13. 요약 표

| 개념 | 핵심 |
|---|---|
| 상속 | 재사용·확장. 단일 상속(클래스), `Object`가 루트 |
| 오버라이딩 | 동일 서명, 공변 반환 허용, 접근수준 축소 금지, 체크 예외 확장 금지 |
| `super`/생성자 | `super(...)`는 **첫 줄**, 초기화 순서(부모→자식) |
| 필드/메서드 | 필드: 정적 바인딩(숨김) / 메서드: 동적 디스패치 |
| 추상/템플릿 | 공통 골격은 상위, 변하는 부분은 하위에서 오버라이드 |
| 인터페이스 | `default` 다중 상속, 충돌 시 클래스에서 해소 |
| 설계 원칙 | LSP·캡슐화·조합 우선, 계약 준수, 테스트 용이성 |

---

## 14. 한 줄 결론
> **오버라이딩은 “계약을 지키며 행동을 바꾸는 기술”** 입니다.
> 규칙(공변 반환/예외/접근수준)과 함정(생성자 호출/필드 숨김/`static`)을 정확히 이해하고, **LSP와 조합 우선 설계**를 지키면, 상속은 강력하고 안전한 확장 도구가 됩니다.
