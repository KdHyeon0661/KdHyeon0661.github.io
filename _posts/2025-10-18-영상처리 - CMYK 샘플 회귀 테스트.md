---
layout: post
title: 영상처리 - CMYK 샘플 회귀 테스트
date: 2025-10-18 23:25:23 +0900
category: 영상처리
---
# CMYK 샘플 **회귀 테스트**

> **주제**: Adobe APP14 마커를 포함한 CMYK/YCCK JPEG 샘플로 **색 정확성**과 **반전(inversion) 적용 여부**를 자동으로 검증하는 회귀 테스트를 만든다.
> **핵심**
> - APP14(“Adobe”)의 `color_transform` 해석
> - CMYK / YCCK → RGB 변환 시 **반전 필요 여부** 판정
> - lcms2(ICC) 기준선과 **수치 비교** / 간이(무 ICC) 변환과 비교
> - PASS/FAIL 기준(ΔE 또는 채널 MAE)으로 **자동화 테스트** 구현

---

## 배경 요약

### CMYK vs YCCK + Adobe APP14

- JPEG CMYK는 4 컴포넌트(C, M, Y, K) 기반.
- **YCCK**는 CMYK에서 C, M, Y 세 성분을 YCbCr 변환한 변종.
- Adobe **APP14** 마커가 있으면 보통 **inverted CMYK(=0이 100% 잉크)** 의미가 내포됨.
  - `color_transform` 값:
    - **0**: CMYK
    - **1**: YCbCr (RGB용)
    - **2**: **YCCK**
- 실무 규칙(간단판):
  - APP14가 있고 `color_transform` ∈ {0,2} → **반전 필요(true)**
  - APP14가 없으면 제조사별로 제각각 → **휴리스틱 or 옵션** 필요

> **주의**: 라이브러리 조합(일부 뷰어/디코더)은 자동 변환/반전이 되어 나올 수 있다. 회귀 테스트는 “**우리가 선택한 파이프라인이 일관**”되게 동작하는지 확인하는 것이 목적.

---

## 테스트 시나리오(샘플 매트릭스)

| 샘플 | 설명 | 기대 |
|---|---|---|
| `cmyk_adobe.jpg` | CMYK, APP14(Adobe), `color_transform=0` | **반전 필요** (C,M,Y,K 모두 0=full ink) |
| `ycck_adobe.jpg` | YCCK, APP14(Adobe), `color_transform=2` | **YCCK→CMYK→RGB + 반전 필요** |
| `cmyk_noadobe.jpg` | CMYK, APP14 없음 | **보통 비반전**(벤더에 따라 상이) |
| `synthetic_swatches.jpg` | 시안/마젠타/옐로/블랙 패치 | 색상 패치 RGB 기대치에 근접 |

> **권장 준비**: 포토샵/일러에서 CMYK JPEG(Adobe on/off), YCCK JPEG(저장 옵션으로 가능) 각 1개 이상. 혹은 공개 샘플(테스트 리포지터리)로 고정.

---

## APP14(Adobe) 마커 파서

```cpp
#include <jpeglib.h>
#include <vector>
#include <string>
#include <cstring>
#include <cstdio>

struct AdobeAPP14 {
    bool present = false;
    int  color_transform = -1; // 0=CMYK, 1=YCbCr, 2=YCCK
    uint16_t version = 0;
    uint16_t flags0 = 0, flags1 = 0;
};

static AdobeAPP14 ParseAdobeAPP14(j_decompress_ptr dinfo)
{
    AdobeAPP14 out{};
    for (jpeg_saved_marker_ptr m = dinfo->marker_list; m; m = m->next) {
        if (m->marker != (JPEG_APP0 + 14)) continue; // APP14
        if (m->data_length < 12) continue;           // "Adobe"+7
        const JOCTET* d = m->data;
        if (std::memcmp(d, "Adobe", 5) != 0) continue;
        out.present = true;
        // APP14: "Adobe"(5) + version(2) + flags0(2) + flags1(2) + color_transform(1)
        if (m->data_length >= 12) {
            out.version = (uint16_t)(d[5] << 8 | d[6]);
            out.flags0  = (uint16_t)(d[7] << 8 | d[8]);
            out.flags1  = (uint16_t)(d[9] << 8 | d[10]);
            out.color_transform = (int)d[11]; // 0,1,2
        }
        break;
    }
    return out;
}
```

---

## CMYK/YCCK 디코드 → CMYK 버퍼 획득

- libjpeg(-turbo) 사용.
- **출력 색공간**을 `JCS_CMYK` 로 설정하면 4채널을 그대로 받을 수 있다(라이브러리/빌드에 따라 지원).
- YCCK의 경우 내부에서 YCCK→CMYK 변환이 적용되는 구현도 있고, 아닌 구현도 있다.
  - 구현 미지원 시, `JCS_CMYK`로 받아지는 4채널이 **Y,Cb,Cr,K**일 수 있으므로 **확인 로그**를 반드시 남긴다.

```cpp
#include <jpeglib.h>
#include <csetjmp>
#include <memory>

struct Jerr { jpeg_error_mgr pub; jmp_buf jb; static void exit_(j_common_ptr c){ Jerr* s=(Jerr*)c->err; longjmp(s->jb,1);} };

struct ImageCMYK {
    int w=0,h=0,stride=0; // stride = w*4
    std::vector<unsigned char> data; // C M Y K (0..255)
};

bool DecodeAsCMYK(const std::string& path, ImageCMYK& out, J_COLOR_SPACE& jpegColorSpace, AdobeAPP14& adobe)
{
    std::unique_ptr<FILE, int(*)(FILE*)> fp(fopen(path.c_str(),"rb"), [](FILE* f){return f?fclose(f):0;});
    if(!fp) return false;

    Jerr jerr{};
    jpeg_decompress_struct dinfo{};
    dinfo.err = jpeg_std_error(&jerr.pub);
    jerr.pub.error_exit = Jerr::exit_;
    if(setjmp(jerr.jb)){ jpeg_destroy_decompress(&dinfo); return false; }

    jpeg_create_decompress(&dinfo);
    jpeg_stdio_src(&dinfo, fp.get());
    // APP14/APPn 저장(로깅용)
    jpeg_save_markers(&dinfo, JPEG_APP0+14, 0xFFFF);

    if(jpeg_read_header(&dinfo, TRUE) != JPEG_HEADER_OK){
        jpeg_destroy_decompress(&dinfo); return false;
    }

    jpegColorSpace = dinfo.jpeg_color_space; // JCS_CMYK or JCS_YCCK or others

    // CMYK로 출력 원함
    dinfo.out_color_space = JCS_CMYK;

    // (중요) 어떤 구현은 YCCK를 CMYK로 자동 변환, 어떤 구현은 raw YCCK를 던질 수 있음.
    // 확인을 위해 로그/스코프에서 adobe/color_transform를 추가로 본다.
    adobe = ParseAdobeAPP14(&dinfo);

    jpeg_start_decompress(&dinfo);
    out.w = dinfo.output_width; out.h = dinfo.output_height; out.stride = out.w*4;
    out.data.assign((size_t)out.stride*out.h, 0);
    while(dinfo.output_scanline < dinfo.output_height){
        JSAMPROW row = (JSAMPROW)(out.data.data() + (size_t)out.stride*dinfo.output_scanline);
        jpeg_read_scanlines(&dinfo, &row, 1);
    }
    jpeg_finish_decompress(&dinfo);
    jpeg_destroy_decompress(&dinfo);
    return true;
}
```

> **로그 예**
> - `jpeg_color_space=JCS_YCCK, APP14.color_transform=2` → YCCK 샘플
> - `jpeg_color_space=JCS_CMYK, APP14.color_transform=0` → CMYK 샘플

---

## CMYK → RGB 변환(반전 고려)

**정확한 변환식(비선형은 ICC에서 다룸, 여기선 표준 근사)**
- **비반전(0=0% 잉크)**:
  \[
  R = 255\cdot (1 - \frac{C}{255}) \cdot (1 - \frac{K}{255}),\quad
  G = 255\cdot (1 - \frac{M}{255}) \cdot (1 - \frac{K}{255}),\quad
  B = 255\cdot (1 - \frac{Y}{255}) \cdot (1 - \frac{K}{255})
  \]
- **반전(Adobe, 0=100% 잉크)**: 먼저 **C,M,Y,K ← 255 - C,M,Y,K** 한 뒤 위 식 적용.
  (많이 쓰는 빠른 근사: `R=255-min(255,C+K)` 등. 여기선 곱셈식 권장)

```cpp
#include <cmath>

static inline uint8_t clamp8(int v){ return (uint8_t)(v<0?0:v>255?255:v); }

struct ImageRGB {
    int w=0,h=0,stride=0; // stride = w*3
    std::vector<unsigned char> data;
};

ImageRGB CMYK_to_RGB(const ImageCMYK& cmyk, bool inverted /*Adobe 계열*/)
{
    ImageRGB out; out.w=cmyk.w; out.h=cmyk.h; out.stride=out.w*3;
    out.data.resize((size_t)out.stride*out.h);

    for(int y=0; y<cmyk.h; ++y){
        const unsigned char* s = cmyk.data.data() + (size_t)cmyk.stride*y;
        unsigned char* d = out.data.data() + (size_t)out.stride*y;
        for(int x=0; x<cmyk.w; ++x){
            int C=s[4*x+0], M=s[4*x+1], Y=s[4*x+2], K=s[4*x+3];
            if(inverted){ C=255-C; M=255-M; Y=255-Y; K=255-K; }
            // float 버전
            float cf=C/255.f, mf=M/255.f, yf=Y/255.f, kf=K/255.f;
            int R = (int)std::round(255.f*(1.f-cf)*(1.f-kf));
            int G = (int)std::round(255.f*(1.f-mf)*(1.f-kf));
            int B = (int)std::round(255.f*(1.f-yf)*(1.f-kf));
            d[3*x+0] = clamp8(R);
            d[3*x+1] = clamp8(G);
            d[3*x+2] = clamp8(B);
        }
    }
    return out;
}
```

> **반전 판정 가이드**
> - **기본**: `inverted = (adobe.present && (adobe.color_transform==0 || adobe.color_transform==2))`
> - **보수 옵션**: APP14가 없어도 평균/백색 패치 탐지(화이트가 어둡게 나오면 반전 의심)로 자동 스위치.

---

## ICC(정답 기준선)와 비교(선택)

**정확한 색**은 **ICC 프로파일**로 계산해야 한다. 테스트의 **골드 스탠더드**로 lcms2 경로를 깔아두면 좋다.

- 입력이 CMYK/YCCK라면, 내장/첨부 ICC가 **CMYK 프로파일**일 수 있다.
- lcms2로 `CMYK(out of JPEG)` → `sRGB` 변환을 한 결과를 **기준선**으로 두고,
- 우리의 간이 변환(CMYK 곱셈식) 결과와 **채널 MAE or ΔE**를 비교.

> **실전 Tip**: 회귀 테스트에서는 **간이 변환 결과**가 **기준선**에 비해 **MAE ≤ 5/255** 정도면 PASS로 잡는 등 **유연한 임계값**을 둔다(샘플·조명·프로파일에 따라 달라짐).

---

## 회귀 테스트 러너(디렉터리 일괄)

- 입력: 샘플 폴더의 JPEG 목록
- 절차:
  1) `DecodeAsCMYK()` → `jpeg_color_space`, `AdobeAPP14` 로깅
  2) `inverted` 결정 → `CMYK_to_RGB()`
  3) (선택) lcms2 경로로 **ICC→sRGB** 변환 → 기준선
  4) **MAE/PSNR** 계산 → PASS/FAIL
  5) 샘플별 결과 CSV/로그 출력

```cpp
#include <filesystem>
#include <cstdio>
#include <numeric>

struct Stats { double maeR=0,maeG=0,maeB=0, maeAvg=0; };

static Stats MAE_RGB(const ImageRGB& a, const ImageRGB& b){
    Stats s{};
    if(a.w!=b.w || a.h!=b.h) return s;
    size_t N=(size_t)a.w*a.h;
    double sr=0, sg=0, sb=0;
    for(int y=0;y<a.h;++y){
        const unsigned char* ap=a.data.data()+ (size_t)a.stride*y;
        const unsigned char* bp=b.data.data()+ (size_t)b.stride*y;
        for(int x=0;x<a.w;++x){
            sr += std::abs((int)ap[3*x+0] - (int)bp[3*x+0]);
            sg += std::abs((int)ap[3*x+1] - (int)bp[3*x+1]);
            sb += std::abs((int)ap[3*x+2] - (int)bp[3*x+2]);
        }
    }
    s.maeR = sr / N; s.maeG = sg / N; s.maeB = sb / N;
    s.maeAvg = (s.maeR + s.maeG + s.maeB)/3.0;
    return s;
}

// (선택) lcms2 기준선 생성 — CMYK→sRGB
#include <lcms2.h>

bool CMYK_to_sRGB_lcms(const ImageCMYK& cmyk, ImageRGB& out,
                       const std::vector<uint8_t>& cmykICC /*없으면 NULL*/, bool invertedAdobe)
{
    // sRGB 프로파일
    cmsHPROFILE hs = cmsCreate_sRGBProfile();
    if(!hs) return false;

    // 입력 프로파일
    cmsHPROFILE hi = nullptr;
    if(!cmykICC.empty()) hi = cmsOpenProfileFromMem(cmykICC.data(), (cmsUInt32Number)cmykICC.size());
    if(!hi) {
        // 프로파일이 없으면 Generic CMYK로 추정(관용적이지만 정확도 낮음)
        // 여기선 안전하게 실패 처리하거나, cmsCreateDeviceLink 등으로 우회 가능.
        cmsCloseProfile(hs);
        return false;
    }

    // CMYK 8비트 → sRGB 8비트
    int intent = INTENT_PERCEPTUAL;
    cmsHTRANSFORM xf = cmsCreateTransform(hi, TYPE_CMYK_8, hs, TYPE_RGB_8, intent, cmsFLAGS_BLACKPOINTCOMPENSATION);
    if(!xf){ cmsCloseProfile(hi); cmsCloseProfile(hs); return false; }

    out.w=cmyk.w; out.h=cmyk.h; out.stride=out.w*3; out.data.resize((size_t)out.stride*out.h);
    // inverted면 역반전 후 변환
    std::vector<unsigned char> tmp = cmyk.data;
    if(invertedAdobe){
        for(size_t i=0;i<tmp.size();++i) tmp[i] = 255 - tmp[i];
    }
    for(int y=0;y<cmyk.h;++y){
        const unsigned char* s = tmp.data() + (size_t)cmyk.stride*y;
        unsigned char* d = out.data.data() + (size_t)out.stride*y;
        cmsDoTransform(xf, s, d, (cmsUInt32Number)cmyk.w);
    }

    cmsDeleteTransform(xf);
    cmsCloseProfile(hi);
    cmsCloseProfile(hs);
    return true;
}
```

> **CMYK ICC 추출**: 일부 JPEG은 APP2(ICC) 마커로 프로파일을 담고 있다(앞 절의 ICC 파서 재사용). 없으면 기준선 변환을 **스킵**하거나, Generic CMYK를 쓰되 **임계값**을 완화.

---

## 메인 테스트: **색 정확성 / 반전 유무** 체크

- `inverted = (adobe.present && (adobe.color_transform==0 || adobe.color_transform==2))`
- 기준선(lcms2)이 있는 경우: **MAE ≤ τ(예: 5.0)** 이면 PASS
- 기준선이 없으면: **화이트/그레이 패치** 간이 검증(화이트가 검게 나오면 반전 누락) + 간이 기대치 비교

```cpp
bool IsWhiteReasonable(const ImageRGB& img) {
    // 중앙 5% 영역 평균이 밝은지 검사(간단 휴리스틱)
    int x0=img.w*47/100, x1=img.w*53/100, y0=img.h*47/100, y1=img.h*53/100;
    double r=0,g=0,b=0; size_t n=0;
    for(int y=y0; y<y1; ++y){
        const unsigned char* p = img.data.data() + (size_t)img.stride*y;
        for(int x=x0; x<x1; ++x){ r+=p[3*x+0]; g+=p[3*x+1]; b+=p[3*x+2]; ++n; }
    }
    r/=n; g/=n; b/=n;
    return (r>200 && g>200 && b>200); // 매우 어두우면 반전 누락 의심
}

struct TestResult {
    std::string file;
    J_COLOR_SPACE jpegCS;
    AdobeAPP14 adobe;
    bool invertedUsed=false;
    double maeAvg=-1.0;
    bool pass=false;
};

TestResult RunOne(const std::string& path,
                  const std::vector<uint8_t>& icc /*optional, parse from APP2 if 있음*/,
                  double maeThreshold = 5.0)
{
    TestResult tr{}; tr.file=path;

    ImageCMYK cmyk; J_COLOR_SPACE cs;
    AdobeAPP14 ad;
    if(!DecodeAsCMYK(path, cmyk, cs, ad)){
        std::fprintf(stderr, "decode fail: %s\n", path.c_str());
        return tr;
    }
    tr.jpegCS = cs; tr.adobe = ad;

    // 반전 여부 결정
    bool inverted = (ad.present && (ad.color_transform==0 || ad.color_transform==2));
    tr.invertedUsed = inverted;

    // 우리 변환
    ImageRGB ours = CMYK_to_RGB(cmyk, inverted);

    // 기준선(lcms2) 있으면 비교 → PASS/FAIL
    ImageRGB ref;
    if(!icc.empty() && CMYK_to_sRGB_lcms(cmyk, ref, icc, inverted)){
        Stats s = MAE_RGB(ours, ref);
        tr.maeAvg = s.maeAvg;
        tr.pass = (s.maeAvg <= maeThreshold);
    } else {
        // 기준선 없으면 간이 체크
        tr.pass = IsWhiteReasonable(ours); // 최소 검증
        tr.maeAvg = -1.0;
    }
    return tr;
}
```

---

## 실행/리포트 (샘플 폴더 일괄)

```cpp
#include <vector>
#include <filesystem>

int main(int argc, char** argv){
    if(argc<2){ std::puts("Usage: cmyk_regress <folder>"); return 0; }
    std::string dir = argv[1];

    // (선택) 폴더 내 각 파일의 ICC(APP2) 추출 유틸을 구현/재사용해 파일별 ICC를 로드
    auto loadICC = [&](const std::string& /*path*/)->std::vector<uint8_t>{
        // 여기서는 생략. 앞서 작성한 JPEG_ReadICCProfile(dinfo, outICC) 형태 재사용 권장.
        return {};
    };

    std::vector<TestResult> results;

    for (auto& e : std::filesystem::directory_iterator(dir)) {
        if(!e.is_regular_file()) continue;
        auto p = e.path().string();
        // 간단 확장자 필터
        auto ext = e.path().extension().string();
        for (auto& c : ext) c = (char)tolower(c);
        if(ext!=".jpg" && ext!=".jpeg") continue;

        std::vector<uint8_t> icc = loadICC(p);
        auto r = RunOne(p, icc, /*maeThreshold=*/5.0);
        results.push_back(r);
        std::printf("[%-20s] CS=%d Adobe=%d ct=%d inv=%d MAE=%.2f %s\n",
            e.path().filename().string().c_str(),
            (int)r.jpegCS,
            (int)r.adobe.present, r.adobe.color_transform,
            (int)r.invertedUsed,
            r.maeAvg,
            r.pass? "PASS":"FAIL");
    }

    // 요약
    int ok=0; for(auto& r: results) if(r.pass) ++ok;
    std::printf("TOTAL: %d, PASS: %d, FAIL: %d\n", (int)results.size(), ok, (int)results.size()-ok);
    return 0;
}
```

---

## **현실적인 체크리스트**

- [x] **APP14 파싱**으로 `color_transform` 로깅
- [x] `jpeg_color_space` 로깅: **JCS_CMYK vs JCS_YCCK**
- [x] CMYK 버퍼 확보(`JCS_CMYK` 출력) 실패 시 → RGB 출력 경로 백업(테스트 제외 표시)
- [x] **반전 규칙**: APP14 & `ct ∈ {0,2}` → invert
- [x] **간이 RGB 변환**(곱셈식) 구현
- [x] (가급적) **lcms2 기준선** 비교(MAE/ΔE)
- [x] 샘플 매트릭스(Adobe on/off, YCCK/CMYK)로 회귀

---

## 트러블슈팅

| 증상 | 원인 | 해결 |
|---|---|---|
| 시안/마젠타가 뒤바뀌거나 어둡게 | 반전 누락(Adobe) | APP14 `ct` 확인, `inverted=true` 적용 |
| YCCK가 이상한 색 | YCCK→CMYK 미지원 구현 | `out_color_space=JCS_CMYK`로 받고 **직접 변환**하거나, lcms2 경로 사용 |
| 기준선과 MAE↑ | ICC 없음/서로 다른 프로파일 | 임계값 완화 또는 샘플을 ICC 포함본으로 교체 |
| 파일마다 결과 흔들림 | 샘플이 벤더 특이 포맷 | 샘플 교체(표준 Adobe 저장본), 또는 파일별 정책 테이블 |

---

## **운영 권장안**

- 앱 로드 경로:
  1) `jpeg_read_header` → **APP14**/ICC 파싱
  2) `JCS_CMYK`로 디코드 시도
  3) **inverted 적용** → RGB
  4) 색 정확도 중요한 경로(인쇄/디자인)에서는 **ICC 변환** 사용
- 테스트는 **릴리스 빌드 CI**에 포함: 샘플 셋의 **MAE** 추이를 추적(회귀 방지).

---

## 요약

- CMYK/YCCK JPEG의 **색 정확성**은 **APP14(Adobe) 반전 처리**가 핵심 포인트.
- 본 회귀 테스트는 APP14/색공간을 **명시적으로 로깅**하고, **간이/ICC 기준선** 비교로 **자동 PASS/FAIL**을 제공한다.
- 팀/프로젝트의 JPEG 파이프라인 업데이트(라이브러리 변경, 최적화) 이후에도 **색 회귀**를 즉시 탐지할 수 있다.
