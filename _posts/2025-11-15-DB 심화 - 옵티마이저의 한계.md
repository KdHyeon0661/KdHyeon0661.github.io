---
layout: post
title: DB 심화 - 옵티마이저의 한계
date: 2025-11-15 18:25:23 +0900
category: DB 심화
---
# 옵티마이저의 한계

> 실험 후에는 반드시 아래 명령으로 **실측 플랜**과 **읽은 블록/메모리**를 확인하세요.
```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL,
       'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'));
```

---

## 공통 실습 스키마(간단)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

-- 고객/상품/주문/상세
DROP TABLE CUST PURGE;
DROP TABLE PROD PURGE;
DROP TABLE ORD  PURGE;
DROP TABLE OI   PURGE;

CREATE TABLE CUST (
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(8),          -- 스큐 유도: 'KOR' 다수
  TIER    VARCHAR2(8)           -- 'VIP','GOLD','SILVER','GEN'
);

CREATE TABLE PROD (
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12),
  BRAND    VARCHAR2(12)         -- 스큐 유도: 'B0' 대량
);

CREATE TABLE ORD (
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  ORDER_DT DATE   NOT NULL,
  STATUS   VARCHAR2(8)
);

CREATE TABLE OI (
  ORDER_ID NUMBER NOT NULL,
  LINE_NO  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  QTY      NUMBER NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY (ORDER_ID, LINE_NO)
);

-- 인덱스
CREATE INDEX IX_CUST_REGION    ON CUST(REGION, CUST_ID);
CREATE INDEX IX_ORD_CUST_DT    ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_PROD_CAT_BRAND ON PROD(CATEGORY, BRAND, PROD_ID);
CREATE INDEX IX_OI_PROD        ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER       ON OI(ORDER_ID);

-- 데이터(스큐 포함)
BEGIN
  FOR c IN 1..30000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,6) WHEN 0 THEN 'KOR' WHEN 1 THEN 'KOR' WHEN 2 THEN 'APAC'
                    WHEN 3 THEN 'EMEA' WHEN 4 THEN 'AMER' ELSE 'JPN' END,
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
                    WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..12000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD'
                    WHEN 2 THEN 'TOY'  WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 4000 THEN 'B0' ELSE 'B'||TO_CHAR(MOD(p,60)) END
    );
  END LOOP;

  FOR o IN 1..80000 LOOP
    INSERT INTO ORD VALUES(
      o, MOD(o,30000)+1,
      DATE '2024-01-01' + MOD(o,240),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID'
                    WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  FOR i IN 1..200000 LOOP
    INSERT INTO OI VALUES(
      MOD(i,80000)+1,
      1 + MOD(i,3),
      MOD(i,12000)+1,
      1 + MOD(i,5),
      ROUND(DBMS_RANDOM.VALUE(10,700),2)
    );
  END LOOP;

  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OI'  , cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

# **부족한 옵티마이징 팩터**

(Optimizer가 고려하지 못하거나 제한적으로만 반영하는 현실 요소들)

### 문제 배경

코스트 모델은 **일반화된 추정**을 기반으로 합니다. 실제 앱 레벨의 **캐시 재사용**, **커넥션/세션 로컬 상태**, **네트워크 왕복**, **어플리케이션 페이싱(think time)**, **병렬 경쟁**, **스토리지 캐시 정책** 등은 **직접 반영되지 않거나 거칠게만 반영**됩니다. 그 결과 “이론상 저렴”한 플랜이 실제로는 더 느려질 수 있습니다.

### 예제 — 애플리케이션 커서 캐시/배치 Fetch의 효과를 비용이 과소평가

```sql
-- 같은 WHERE라도, 앱에서 바인드 값만 바꿔 반복 호출(커서 재사용, Array Fetch) 시
-- 옵티마이저는 호출 패턴/네트워크 왕복 감소를 모릅니다.
VAR v_region VARCHAR2(8); EXEC :v_region := 'KOR';

SELECT /* app loops this many times with new binds */
       o.order_id, o.order_dt
FROM   ORD o
JOIN   CUST c ON c.cust_id = o.cust_id
WHERE  c.region = :v_region
AND    o.order_dt >= DATE '2024-05-01';
```
**관찰**
- DBMS_XPLAN은 **한 번 실행의 코스트/통계**만 보여줍니다.
- 실제 앱은 **커서 핫 캐시**·**배치 Fetch**·**네트워크 왕복 감소**로 훨씬 빠를 수 있음.

**완화 전략**
- DB 입장에서 **ArraySize/배치**를 확대(드라이버 설정).
- DB코스트로 설명 안 되면 **E2E(End-to-End) 지표**(호출수/왕복수/한 번당 평균 fetch/네트워크 시간)를 별도로 계측.

---

# **부정확한 통계**

(Out-of-date, 샘플 편향, 수집 누락 → 잘못된 카디널리티/플랜)

### 문제 배경

- 통계가 오래되거나 부분 수집일 때, 실제 행 수/NDV/분포가 바뀌어 **선택도 오판**.
- 급증/급감 테이블, 파티션 신규 주입, 시즌ality엔 **자동 통계**만으론 부족.

### 재현

```sql
-- PROD의 BRAND 분포를 일부러 바꿔 실제와 통계 불일치 유도
UPDATE PROD SET BRAND='B0' WHERE PROD_ID BETWEEN 10001 AND 12000;  -- B0 더 증가
COMMIT;

-- 통계를 일부러 수집하지 않은 상태로 질의
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   PROD
WHERE  BRAND='B0';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**관찰**
- 히스토그램이 없거나 오래된 경우, BRAND='B0'의 선택도를 낮게 잡아 **인덱스 범위 스캔** 같은 잘못된 플랜을 선택할 수 있음(실제는 대량이라 FFS/Full Scan이 싸다).

**완화**
```sql
-- 최신화
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    method_opt=>'FOR COLUMNS SIZE 254 BRAND');  -- 히스토그램 포함
END;
/
```
- 핫 파티션/핫 컬럼은 **더 자주** 수집.
- 대용량 병렬로 수집 시간을 줄이고, **변경량 기반**(stale%) 트리거.

---

# **히스토그램의 한계**

(값 단위 스큐는 반영하지만, **조합/상관관계**·**시간성 변화**에는 제한)

### 문제 배경

- 히스토그램은 특정 컬럼의 **값 분포**만 반영.
- 다중 컬럼의 **상관관계**(예: `REGION='KOR'`일 때 `TIER='VIP'` 비율이 다름)까지는 기본적으로 모름.
- 버전/유형에 따라 **Top-Frequency**는 상위 빈도만, **Height-Balanced**는 근사치만 제공합니다.

### 재현 — 단일 컬럼 히스토그램은 OK, 조합은 MISS

```sql
-- CUST(REGION)는 히스토그램, TIER는 없음 → 조합 선택도 왜곡
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST',
    method_opt=>'FOR COLUMNS SIZE 254 REGION');
END;
/

EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   CUST
WHERE  REGION='KOR' AND TIER='VIP';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**관찰**
- 실제로 `KOR`에서 `VIP` 비율이 높거나 낮아도, **독립 가정**으로 곱해 **과소/과대 추정**.

**완화**
- **확장 통계(컬럼 그룹)**: 상관관계가 강한 컬럼은 그룹 통계 추가.
```sql
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
```
- 주기적으로 **유효성 검증**(실행 결과 vs 추정치 비교).

---

# **바인드 변수 사용 시 균등분포 가정**

(+ Bind Peeking/Adaptive Cursor Sharing 이슈)

### 문제 배경

바인드 변수는 플랜 재사용에 유리하지만, **값에 따라 선택도가 크게 다른 컬럼**에서 **균등분포**로 가정되거나, **초기 peeking 값**에 과도하게 종속될 수 있습니다. 이후 다른 값으로 실행 시 **플랜 미스매치**가 발생.

### 재현 — Peeking의 함정

```sql
ALTER SYSTEM FLUSH SHARED_POOL;

VARIABLE b_brand VARCHAR2(12);

-- 1) 처음에 "희소값"으로 파싱(인덱스 스캔 플랜 획득)
EXEC :b_brand := 'B47';
SELECT /* bind demo */ COUNT(*) FROM PROD WHERE BRAND = :b_brand;

-- 2) 같은 커서를 "대량값"으로 실행(여전히 인덱스 스캔 플랜을 재사용할 가능성)
EXEC :b_brand := 'B0';
SELECT /* bind demo */ COUNT(*) FROM PROD WHERE BRAND = :b_brand;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL, 'ALLSTATS LAST +PEEKED_BINDS'));
```
**관찰**
- 첫 실행 값(B47) 기준으로 **인덱스 스캔 플랜**을 채택 → B0로 실행 시 **I/O 폭증**.

### Adaptive Cursor Sharing(ACS)로 완화… 하지만

- ACS는 **실행 후** 바인드 범위/선택도 스큐를 학습해 **바인드 별 다른 child cursor**를 생성.
- 하지만 **학습까지는 고통**이 따르고, **불안정성**(child cursor 폭증)도 있을 수 있음.

**완화 전략**
- **히스토그램**으로 스큐를 반영 + ACS 활성 환경에서 **반복 실행**을 통해 학습 유도.
- 업무 특성상 **항상 대량값**이면 **리터럴** 사용(플랜 강제)도 고려.
- 특정 중요 SQL은 **SQL Profile/Baseline**으로 **안정화**.

---

# 산정의 어려움**

(독립 가정/균등 가정 → 조합/상관관계/비선형 분포에 취약)

### 문제 배경

- 옵티마이저는 보통 조건 간 **독립**을 가정하고 선택도를 곱합니다.
- 실제 데이터는 **강하게 상관**되어 있을 수 있어 오차가 큼 → **잘못된 조인 순서/방법**.

### 재현 — REGION과 TIER의 상관, BRAND와 CATEGORY의 상관

```sql
EXPLAIN PLAN FOR
SELECT /* join selectivity miss */
       COUNT(*)
FROM   ORD o
JOIN   CUST c ON c.cust_id = o.cust_id
JOIN   OI   i ON i.order_id = o.order_id
JOIN   PROD p ON p.prod_id  = i.prod_id
WHERE  c.region='KOR' AND c.tier='VIP'
AND    p.category='ELEC' AND p.brand='B0';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**관찰**
- 인덱스/해시 선택이 어긋나거나, 조인 순서가 비상식적일 수 있음.

**완화**
- **확장 통계(컬럼 그룹)**, **분포가 크게 달라지는 파티션별 통계**.
- **LEADING/USE_NL/USE_HASH** 등 **최소 힌트**로 순서/방법을 고정.
- 중요 SQL은 **플랜 베이스라인**.

---

# 가정**

(블록 I/O 비용/캐시 히트/CPU 비용 고정, 고르게 섞여 있음 등)

### 문제 배경

- 코스트 모델은 환경 전체를 평균화/단순화합니다.
- 예: “멀티블록 읽기가 싱글블록보다 항상 싸다”, “해시는 정렬보다 항상 싸다” → **항상 그렇지 않음**.
- **핫 블록 경합/래치/버퍼 체인 충돌**은 모델에 거의 반영되지 않음.

### 재현 — Full Scan이 항상 빠르다고 보지만, 캐시에 전부 있으면?

```sql
-- 같은 테이블을 바로 반복 Full Scan하면 버퍼 캐시 히트로 매우 빠름.
-- 옵티마이저는 '2번째 실행은 캐시되어 빠르다'를 코스트에 넣지 못함.
SELECT /* fs1 */ COUNT(*) FROM OI;
SELECT /* fs2 */ COUNT(*) FROM OI; -- 현저히 빨라질 수 있음(환경에 따라)
```

**완화**
- 핵심 보고 쿼리는 **실행 패턴 기반**(Warm Cache vs Cold Cache)으로 **E2E 측정**.
- “첫 실행” 기준으로 필요한 경우 **SQL Plan Baseline**으로 보수적 플랜 고정.

---

# **규칙에 의존하는 CBO의 면모**

(Heuristic/Transformation Rule에 따른 예측 불가/과잉 변환/부적절 변환)

### 문제 배경

- CBO라도 **변환 단계**에서 **규칙 기반 판단**이 적용됩니다.
  - **뷰 머지(View Merging)**, **OR-Expansion**, **서브쿼리 Unnesting** 등.
- 어떤 변환이 “좋을지”는 데이터/통계/버전별 내부 휴리스틱에 의존 → **버전 업**에서 **예상치 못한 플랜 변경**.

### 재현 — 뷰 머지가 오히려 손해인 케이스

```sql
-- 내부적으로 MERGE되는 것이 손해일 때 'NO_MERGE'로 제어
SELECT /*+ NO_MERGE(v) */
       o.order_id
FROM (
  SELECT prod_id FROM PROD WHERE category='ELEC'
) v
JOIN OI i ON i.prod_id = v.prod_id
JOIN ORD o ON o.order_id = i.order_id
WHERE o.order_dt >= DATE '2024-05-01';
```
**관찰**
- 버전에 따라 머지/언네스트 유무가 달라져 **플랜 변동성**.

**완화**
- 변환이 나쁠 때는 **NO_MERGE/MATERIALIZE/UNNEST** 등으로 국지 제어.
- **optimizer_features_enable**로 **버전 호환 모드** 테스트 → 점진 전환.

---

# **하드웨어 성능 특성의 미반영/과소반영**

(SSD/HDD/스토리지 캐시, SAN, NUMA, CPU 캐시, 네트워크, 압축, In-Memory 등)

### 문제 배경

- 코스트 모델은 전통적 디스크 모델 기반으로 설계.
- **SSD/스토리지 캐시**에서 Random vs Sequential의 격차가 줄고, **Direct NFS**/SAN/스토리지 tiering 영향이 큼.
- **NUMA/CPU 캐시/메모리 대역폭**은 쿼리 형태에 따라 큰 변수이나, 모델 반영은 제한적.
- **압축**(행/열)·**In-Memory Column Store** 사용 시 **CPU vs I/O 트레이드오프**가 달라지지만, 코스트는 평균치.

### 관찰 실험 아이디어

```sql
-- 동일 SQL에 대해 병렬을 키고 끄고, DB 버퍼 크기/DB_FILE_MULTIBLOCK_READ_COUNT/인메모리 옵션에 따른
-- I/O vs CPU 변화를 AWR로 비교(환경 의존, 여기서는 개념만).
```

**완화**
- **시스템 통계** 재수집(스토리지/CPU 교체 후).
- **병렬 정책**/버퍼 캐시/Result Cache/In-Memory 설정을 업무별로 분리.
- 한번 정한 “플랜”이 하드웨어 변화에도 안전한지 **성능 회귀 테스트** 필수.

---

# 종합 예제: “한계”가 결합될 때의 전형적 사고 과정

**시나리오**
- 조건: `REGION='KOR' AND TIER='VIP'`, `CATEGORY='ELEC' AND BRAND='B0'`
- 문제: 히스토그램 없음 + 바인드 변수로 파싱 + 독립 가정 → **선택도 과소/과대 추정** → **조인 순서/방법 Miss**.

```sql
ALTER SYSTEM FLUSH SHARED_POOL;
VARIABLE b_r VARCHAR2(8); VARIABLE b_t VARCHAR2(8);
VARIABLE b_c VARCHAR2(12); VARIABLE b_b VARCHAR2(12);

EXEC :b_r:='KOR';  EXEC :b_t:='VIP';
EXEC :b_c:='ELEC'; EXEC :b_b:='B0';

SELECT /* stress */
       SUM(i.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
JOIN   PROD p ON p.prod_id  = i.prod_id
WHERE  c.region  = :b_r
AND    c.tier    = :b_t
AND    p.category= :b_c
AND    p.brand   = :b_b;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS'));
```

**발생 가능한 현상**
- 첫 peeking 값으로 고정된 플랜이 **다른 바인드 값**에 불리.
- 히스토그램 부재로 `B0`가 **대량**임을 반영 못함.
- 독립 가정으로 `REGION×TIER`의 상관 미반영.
- 결과: NL/HJ/SMJ의 선택이 뒤틀려 **응답 지연/Temp 폭증**.

**해결 절차(권장)**
1) `DBMS_STATS`로 **히스토그램**(BRAND), **확장 통계**(REGION,TIER) 수집.
2) **ACS**가 학습되도록 **반복 실행**(또는 **SQL Profile**로 가이드).
3) 중요 리포트면 **Baseline**으로 안정화.
4) 변환이 과도하면 **NO_MERGE/MATERIALIZE** 등으로 제어.
5) **시스템 통계** 검사(하드웨어 변경 반영).
6) `ALLSTATS LAST +IOSTATS +MEMSTATS`로 **실측** 확인, 필요 시 **힌트 최소화**(LEADING/USE_HASH 등).

---

# 섹션별 “실무 체크리스트”

### 통계/히스토그램

- [ ] 변경 많은 테이블/파티션은 **짧은 주기**로 수집.
- [ ] 스큐 컬럼엔 **히스토그램**, 상관관계는 **확장 통계**.
- [ ] 업그레이드/스토리지 변경 후 **시스템 통계** 재수집.

### 바인드 변수/ACS

- [ ] **선택도 스큐 컬럼**에서는 **바인드 남용 금지**(리터럴/SQL 분리 고려).
- [ ] ACS가 학습할 시간 필요 → **초기 튜닝/프리워밍**.
- [ ] child cursor 폭증 감시.

### SQL 구조/변환

- [ ] **SARGable** 형태 유지(컬럼 가공 금지, 상수 쪽 변환).
- [ ] 변환이 오히려 해치면 **NO_MERGE/UNNEST**로 제어.
- [ ] 조인 순서/방법은 **최소 힌트**로만 고정.

### 플랜 안정화

- [ ] **SQL Plan Baseline/Profile/Patch**로 핵심 SQL 보호.
- [ ] 배포 전/후 **회귀 테스트**와 **AWR/ASH** 비교.

### 하드웨어/시스템

- [ ] SSD/SAN/캐시 정책/NUMA/압축/인메모리 등 환경 특성을 **문서화**.
- [ ] 병렬 정책/버퍼/Result Cache 설정을 **워크로드별**로.
- [ ] **E2E 타이밍**(왕복/드라이버/배치)까지 모니터링.

---

## 부록 A. 히스토그램/확장통계 빠른 적용 스니펫

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    method_opt=>'FOR COLUMNS SIZE 254 BRAND'); -- 스큐 반영
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION,TIER)'); -- 상관관계
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
```

## 부록 B. 플랜 안정화 스니펫(개념)

```sql
-- (예) SQL Plan Baseline 캡처(자동/수동) → DBA_SQL_PLAN_BASELINES
-- (예) SQL Profile/SQL Patch 적용은 DBA 도구/스크립트로 수행
```

## 부록 C. 변환 제어/힌트 예시

```sql
-- 변환 제어
SELECT /*+ NO_MERGE(v) MATERIALIZE */ *
FROM (SELECT prod_id FROM PROD WHERE category='ELEC') v
JOIN OI i ON i.prod_id = v.prod_id;

-- 최소 힌트로 순서/방법 고정
SELECT /*+ ORDERED LEADING(c o i p) USE_HASH(p) USE_NL(o i) */
       ...
```

---

### 결론

옵티마이저는 강력하지만 **만능이 아닙니다**.
- **부정확한 통계/히스토그램 부재**, **바인드 스큐**, **결합 선택도 오판**, **규칙 기반 변환의 변동성**, **현대 하드웨어 특성 미반영** 때문에 **의도치 않은 플랜**이 나옵니다.
- 해결책은 **정확한 통계·확장 통계**, **히스토그램/ACS 이해**, **SARGable SQL**, **최소한의 힌트**, **플랜 안정화**, **E2E 관측**입니다.
- 즉, 옵티마이저의 한계를 **인지**하고, **데이터·워크로드·하드웨어 맥락**을 더해 **사실 기반**으로 보완하는 것이 “정석 해법”입니다.
