---
layout: post
title: DB 심화 - 옵티마이저의 한계
date: 2025-11-15 18:25:23 +0900
category: DB 심화
---
# 옵티마이저의 한계 — Oracle CBO가 “틀릴 수밖에 없는 이유”와 실전 보완법

## 0) 먼저 실측부터 — “내가 본 게 진짜 플랜이다”

**실험/튜닝은 항상 2단계로 끝난다.**

1) **변경 전후 SQL 실행**  
2) **실측 실행계획/IO·메모리** 확인

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
         'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'));
```

- `A-Rows / A-Time / Buffers / Reads / TempSpc / Mem`이 진짜 비용이다.
- `E-Rows`(추정 행)와 `A-Rows`(실행 행)의 괴리는 **한계가 터졌다는 신호**다.

---

## 1) 코스트 모델이 모르는 세계: 앱·네트워크·캐시·동시성

### 1.1 비용 모델은 “단일 SQL 1회 실행”만 본다

CBO의 비용은 **한 번의 실행에서 발생할 DB 내부 작업량**을 근사한다.  
하지만 실제 서비스는 보통 다음이 섞여 있다.

- **커서/버퍼 캐시의 “따뜻함”**(Warm cache vs Cold cache)
- **배치 Fetch(Array Fetch) / Prefetch**로 줄어드는 네트워크 왕복
- **세션 로컬 상태**(GTT, PL/SQL 패키지 캐시, PGA 재사용)
- **애플리케이션 think time**(사용자 대기)
- **동시성 경합**(hot block, buffer busy, latch, row lock)
- **스토리지 캐시/티어링 정책**(SAN, NVMe 캐시, 압축해제 CPU 등)

CBO는 이런 **E2E(end-to-end)** 패턴을 직접적으로 비용에 넣지 못한다.  
Oracle 개발 가이드도 “실제 앱의 연결/반복 패턴과 DB 비용의 차이를 별도 계측하라”는 관점을 강조한다. :contentReference[oaicite:0]{index=0}

### 1.2 재현: “앱 반복 호출” 비용을 과소평가

```sql
VAR v_region VARCHAR2(8);
EXEC :v_region := 'KOR';

-- 앱이 바인드만 바꿔 수백/수천 번 반복 실행한다고 가정
SELECT o.order_id, o.order_dt
FROM   ORD o
JOIN   CUST c ON c.cust_id = o.cust_id
WHERE  c.region = :v_region
AND    o.order_dt >= DATE '2025-05-01';
```

**관찰 포인트**
- DBMS_XPLAN의 코스트/통계는 **“한 번 실행”**만 반영한다.
- 실제 앱에서는 커서 재사용 + 배치 fetch로 **왕복/파싱/CPU**가 급감할 수 있다.

**완화 전략**
- 드라이버의 `arraysize/fetchsize`를 키워 왕복을 줄인다.
- SQL 단독 비용이 설명하지 못하면 **호출 수, 왕복 수, fetch당 행수** 같은 E2E 지표를 같이 본다.

---

## 2) 부정확한 통계: CBO 오판의 1번 원인

### 2.1 통계는 “과거의 스냅샷”이다

CBO의 모든 선택도/카디널리티는 통계에 의존한다.  
따라서 통계가 아래처럼 현실과 어긋나면 플랜이 틀어진다.

- **Out-of-date**(stale stats)
- **샘플 편향**(비대표 샘플)
- **수집 누락/부분 수집**(새 파티션, 신규 로드)
- **시즌성/급변**(프로모션, 배치 주입)

Oracle 튜닝 가이드는 “통계 최신성/적합성이 카디널리티의 기반이며, 틀리면 플랜이 틀린다”고 명시한다. :contentReference[oaicite:1]{index=1}

### 2.2 재현: 데이터 분포 변경 후 통계 미수집

```sql
-- BRAND='B0' 비율을 더 키워 스큐 악화
UPDATE PROD
SET    BRAND='B0'
WHERE  PROD_ID BETWEEN 10001 AND 12000;
COMMIT;

-- 통계를 수집하지 않은 상태에서 실행계획 확인
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   PROD
WHERE  BRAND='B0';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**가능한 현상**
- 통계가 “B0은 희소”라 오판 → **INDEX RANGE SCAN** 선택
- 실제는 대량 → 인덱스 스캔이 **랜덤 I/O 폭탄**이 될 수 있다.

### 2.3 완화: 스큐 컬럼은 히스토그램까지 포함해 수집

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND'
  );
END;
/
```

---

## 3) 히스토그램의 구조적 한계

### 3.1 히스토그램은 “단일 컬럼 분포”만 안다

Oracle의 히스토그램(Top-Frequency, Height-Balanced, Hybrid 등)은  
**특정 컬럼의 값 비균등**을 반영해 선택도를 개선한다. :contentReference[oaicite:2]{index=2}

하지만 다음은 기본적으로 모른다.

- **다중 컬럼 상관관계**
- **조건 조합의 비선형 변화**
- **시간에 따른 분포 이동**

즉, 히스토그램이 있어도 **조합 선택도는 여전히 독립 가정으로 곱해** 오판한다.

### 3.2 재현: 단일 히스토그램 OK, 조합은 MISS

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    USER, 'CUST',
    method_opt=>'FOR COLUMNS SIZE 254 REGION'
  );
END;
/

EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   CUST
WHERE  REGION='KOR' AND TIER='VIP';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**관찰**
- 실제로 KOR에서 VIP 비율이 높든 낮든,  
  CBO는 `sel(REGION) * sel(TIER)`로 독립 가정한다.

### 3.3 완화: 확장 통계(컬럼 그룹)로 상관 반영

Oracle은 **Extended Statistics(컬럼 그룹/표현식 통계)**를 제공해  
상관관계를 통계로 “학습”시킬 수 있다. :contentReference[oaicite:3]{index=3}

```sql
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(
    ownname => USER,
    tabname => 'CUST',
    extension => '(REGION, TIER)'
  );
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'CUST');
END;
/
```

---

## 4) 바인드 변수의 함정: 균등분포 가정 + Peeking + ACS

### 4.1 바인드 변수는 플랜 재사용의 축복이지만…

- 장점: **Hard parse 감소, 라이브러리 캐시 효율**
- 단점: 선택도 스큐가 큰 컬럼에서 **균등분포 가정** 또는 **초기 peeking 값 종속**이 발생

Oracle은 바인드 파싱 시 **Bind Peeking**을 수행하고,  
스큐가 관측되면 **Adaptive Cursor Sharing(ACS)**로 바인드별 child cursor를 만든다. :contentReference[oaicite:4]{index=4}

하지만 ACS는 **“실행 후 학습”**이므로  
학습 전에는 잘못된 플랜으로 고통받을 수 있고,  
학습이 과도하면 **child cursor 폭증**이 생긴다.

### 4.2 재현: 희소값으로 파싱 → 대량값 재사용

```sql
ALTER SYSTEM FLUSH SHARED_POOL;

VARIABLE b_brand VARCHAR2(12);

-- 1) 희소값으로 플랜 획득
EXEC :b_brand := 'B47';
SELECT COUNT(*) FROM PROD WHERE BRAND = :b_brand;

-- 2) 대량값으로 재사용
EXEC :b_brand := 'B0';
SELECT COUNT(*) FROM PROD WHERE BRAND = :b_brand;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS'));
```

**가능한 현상**
- B47 기준 인덱스 스캔 플랜이 B0에도 재사용 → I/O 폭증

### 4.3 실무 완화 패턴

- 스큐 컬럼에 **히스토그램 + ACS 학습 유도**
- 업무가 “항상 대량값”이면 **리터럴 분리/SQL 분기** 고려
- 중요 SQL은 **SQL Plan Baseline/Profile**로 안정화 :contentReference[oaicite:5]{index=5}

---

## 5) 선택도 산정의 근본적 어려움: 독립 가정의 늪

### 5.1 왜 독립 가정이 깨지는가

실제 데이터는 보통 “조건이 서로 연동”된다.

- VIP는 특정 REGION에 몰림
- 특정 BRAND는 특정 CATEGORY에 집중
- “최근 날짜” 파티션에 특정 상태값이 몰림

CBO가 이 상관을 모르면

- 조인 순서가 뒤집히고
- 해시/네스티드루프가 엇갈리며
- TMP 스필/메모리 과소·과대가 발생한다.

### 5.2 재현: 4개 테이블 상관 조합

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   ORD  o
JOIN   CUST c ON c.cust_id = o.cust_id
JOIN   OI   i ON i.order_id = o.order_id
JOIN   PROD p ON p.prod_id  = i.prod_id
WHERE  c.region='KOR' AND c.tier='VIP'
AND    p.category='ELEC' AND p.brand='B0';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 5.3 완화

- **확장 통계**
- 파티션별 통계/증분 통계
- 조인 순서/방법은 **최소 힌트**로 “살짝” 고정
- 핵심 리포트는 Baseline

---

## 6) 비용 가정의 고정값/평균화 문제

### 6.1 “Full Scan이 항상 싸다 / 해시가 항상 싸다”는 평균치

CBO의 비용은 일반화된 평균 모델이다.

- 멀티블록 읽기 비용
- 싱글블록 랜덤 비용
- 해시 빌드/프로브 CPU
- 소트 vs 해시의 상대 비용

하지만 현실은

- **버퍼 캐시 히트율**
- **hot block 경합**
- **PGA 여유/부족**
- **락/래치 충돌**
- **쿼리 동시성**

에 따라 비용 역전이 쉽게 일어난다.

### 6.2 재현: “두 번째 Full Scan은 아주 빠를 수 있다”

```sql
SELECT /* fs1 */ COUNT(*) FROM OI;
SELECT /* fs2 */ COUNT(*) FROM OI;
```

- 2번째는 캐시 히트로 급속히 빨라질 수 있지만  
  CBO는 이 “반복 패턴”을 비용에 못 넣는다.

### 6.3 완화

- Warm/Cold 실행을 나눠 E2E 측정
- 반복 실행 쿼리는 **실측 평균**으로 판단
- 환경이 자주 변하면 Baseline으로 보수적 보호

---

## 7) 규칙 기반 변환·적응형 기능의 변동성

### 7.1 CBO도 “변환 단계”는 휴리스틱이다

CBO는 비용기반이지만, **Query Transformation(재작성)** 단계의 일부는  
규칙/휴리스틱 기반이다. :contentReference[oaicite:6]{index=6}

대표 변환

- View Merging
- OR Expansion
- Subquery Unnesting
- Predicate Move-Around
- Join Elimination / Semi·Anti 변환

버전·통계·파라미터에 따라  
**같은 SQL이 다른 형태로 재작성**될 수 있고,  
그 결과 플랜도 급변한다.

### 7.2 재현: 뷰 머지가 손해일 때

```sql
SELECT /*+ NO_MERGE(v) */
       o.order_id
FROM (
  SELECT prod_id
  FROM   PROD
  WHERE  category='ELEC'
) v
JOIN OI  i ON i.prod_id  = v.prod_id
JOIN ORD o ON o.order_id = i.order_id
WHERE o.order_dt >= DATE '2025-05-01';
```

- 어떤 버전/통계에서는 MERGE가 이득, 어떤 환경에서는 손해.
- 따라서 “이 변환이 위험하다”면 **국지 힌트로 제어**한다.

### 7.3 적응형(Adaptive) 기능도 만능은 아니다

Oracle은 Dynamic Statistics, Cardinality Feedback, Adaptive Plans 등을 통해  
실행 중/실행 후 오판을 보정하려 한다. :contentReference[oaicite:7]{index=7}

하지만

- 첫 실행 비용은 여전히 비쌀 수 있고
- 학습 전 플랜은 틀릴 수 있으며
- 변화가 잦으면 **학습이 따라가지 못한다**.

---

## 8) 현대 하드웨어·스토리지와 코스트 모델의 갭

### 8.1 디스크 시대 가정의 잔재

전통 비용 모델은 “순차 I/O가 랜덤 I/O보다 훨씬 싸다”는 디스크 중심 모델이었다.  
그러나 요즘 환경은

- SSD/NVMe
- 대형 스토리지 캐시
- Direct NFS / SAN tiering
- NUMA / CPU 캐시 구조
- In-Memory Column Store
- 압축(행/열)

때문에 비용 지형이 달라진다.

Oracle은 시스템 통계를 통해 CPU/IO 성능을 비용 모델에 반영할 수 있게 했지만,  
하드웨어 교체/스토리지 변화 후 **재수집이 필요**하다. :contentReference[oaicite:8]{index=8}  
또한 In-Memory/Join Filter(Bloom) 같은 엔진 최적화는  
특정 워크로드에서 비용 예측이 더 어려워질 수 있다. :contentReference[oaicite:9]{index=9}

### 8.2 실무 완화

- 스토리지/CPU 교체 후 **시스템 통계 재수집**
- 워크로드별 병렬/버퍼/인메모리 정책 분리
- 버전 업은 `optimizer_features_enable`로 단계적 테스트

---

## 9) 한계가 겹칠 때의 전형적 사고 과정

### 9.1 시나리오

- 조건 조합
  - `REGION='KOR' AND TIER='VIP'`
  - `CATEGORY='ELEC' AND BRAND='B0'`
- 문제
  - BRAND 히스토그램 없음
  - (REGION,TIER) 상관 미반영
  - 바인드로 파싱 → peeking 값 종속
  - 독립 가정으로 선택도 왜곡

```sql
ALTER SYSTEM FLUSH SHARED_POOL;

VARIABLE b_r VARCHAR2(8);
VARIABLE b_t VARCHAR2(8);
VARIABLE b_c VARCHAR2(12);
VARIABLE b_b VARCHAR2(12);

EXEC :b_r:='KOR';
EXEC :b_t:='VIP';
EXEC :b_c:='ELEC';
EXEC :b_b:='B0';

SELECT SUM(i.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
JOIN   PROD p ON p.prod_id  = i.prod_id
WHERE  c.region   = :b_r
AND    c.tier     = :b_t
AND    p.category = :b_c
AND    p.brand    = :b_b;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS'));
```

### 9.2 발생 가능한 현상

- peeking 값 기반 인덱스/NL 플랜이 고정
- B0 대량을 희소로 오판 → 조인 순서 전복
- 독립 가정 → 카디널리티가 수십~수백 배 틀어짐
- 결과: 불필요 TEMP, 과다 랜덤 I/O, PGA 과소/과대

### 9.3 권장 해결 절차

1) BRAND 히스토그램 수집  
2) (REGION,TIER) 확장 통계 수집  
3) ACS 학습 또는 SQL Profile로 가이드  
4) 중요 SQL은 Baseline  
5) 변환이 과도하면 NO_MERGE/MATERIALIZE 등 국지 제어  
6) 시스템 통계 점검  
7) 실측 플랜으로 개선 폭 확인

---

## 10) 실무 체크리스트(요약판)

### 10.1 통계/히스토그램

- [ ] 변경량 큰 테이블/파티션은 짧은 주기로 수집
- [ ] 스큐 컬럼은 히스토그램
- [ ] 상관 강한 컬럼은 확장 통계
- [ ] 하드웨어/스토리지 교체 후 시스템 통계 재수집

### 10.2 바인드 변수/ACS

- [ ] 스큐 컬럼에 바인드 남용 금지
- [ ] ACS 학습 시간을 고려한 “초기 프리워밍”
- [ ] child cursor 증가 감시

### 10.3 SQL 구조/변환

- [ ] SARGable 유지(가공 금지, 범위는 컬럼 좌측)
- [ ] 변환이 해치면 NO_MERGE/NO_UNNEST/MATERIALIZE로 국지 제어
- [ ] 조인 순서/방법은 최소 힌트만

### 10.4 플랜 안정화/회귀

- [ ] Baseline/Profile/Patch로 핵심 SQL 보호
- [ ] 배포 전후 AWR/ASH 기반 회귀 테스트

### 10.5 E2E/동시성

- [ ] Warm/Cold 실행을 분리 측정
- [ ] 호출수·왕복수·배치 fetch 크기 계측
- [ ] 핫 블록/락 경합은 DB 비용과 별개로 진단

---

## 부록 A) 통계·확장통계 “빠른 적용” 묶음

```sql
BEGIN
  -- 스큐 컬럼 히스토그램
  DBMS_STATS.GATHER_TABLE_STATS(
    USER,'PROD',
    method_opt=>'FOR COLUMNS SIZE 254 BRAND',
    cascade=>TRUE
  );

  -- 상관관계 컬럼 그룹
  DBMS_STATS.CREATE_EXTENDED_STATS(
    USER,'CUST','(REGION,TIER)'
  );
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE);
END;
/
```

---

## 부록 B) 변환 제어·플랜 안정화 예시

```sql
-- 변환 제어(국지)
SELECT /*+ NO_MERGE(v) MATERIALIZE */
       *
FROM (
  SELECT prod_id FROM PROD WHERE category='ELEC'
) v
JOIN OI i ON i.prod_id = v.prod_id;

-- 최소 힌트로 조인 순서/방법 고정
SELECT /*+ LEADING(c o i p) USE_NL(o i) USE_HASH(p) */
       ...
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
JOIN   PROD p ON p.prod_id  = i.prod_id
WHERE  ...;
```

---

## 결론

옵티마이저는 매우 강력하지만 **만능은 아니다**.

- 비용 모델은 **앱 실행 패턴·캐시 재사용·동시성·네트워크**를 충분히 반영 못한다.
- 통계/히스토그램/확장통계가 부정확하면 **카디널리티가 무너져 플랜이 무너진다**.
- 바인드 변수/peeking/ACS는 “플랜 재사용”의 대가로 **스큐 오판 위험**을 동반한다.
- 변환 단계의 휴리스틱, 현대 하드웨어 특성, 상관관계·비선형 분포는 CBO의 구조적 한계다.

따라서 정석은 하나다.

1) **통계를 올바르게**  
2) **SQL을 SARGable하게**  
3) **최소 힌트로 논리만 보정**  
4) **필요하면 Baseline으로 보호**  
5) **E2E와 실측 플랜으로 증명**

이 5가지를 반복하면, “옵티마이저의 한계”는 **예측 가능한 변수**가 되고 튜닝은 훨씬 안정적이 된다.