---
layout: post
title: 정보보안기사 - 운영체제 명령 실행
date: 2025-11-13 05:25:23 +0900
category: 정보보안기사
---
# SECTION 08 웹 애플리케이션 취약점 — 05. 운영체제 명령 실행(OS Command Execution) 취약점 완전 정리 (원리·케이스·언어별 안티패턴→안전코드·입력검증·샌드박스/권한분리·로깅/탐지·체크리스트·실기 예상문제)

## 개요 — “웹앱이 셸을 대리 실행하는 순간”
**OS Command Execution(운영체제 명령 실행) 취약점**은 애플리케이션이 **외부 프로그램(셸/바이너리)**을 호출하는 경로에 **사용자 입력**이 섞이면서, 공격자가 **원래 의도와 다른 OS 명령**까지 실행하게 만드는 문제다.  
핵심 포인트:

- **문자열 결합**으로 셸 호출(`sh -c`, `cmd.exe /c`, `powershell`) 시 **메타문자**(`;`, `&&`, `|`, 백틱, `$(...)`, `&`)가 입력에 섞이면 **명령 주입**으로 이어진다.
- **PATH/인코딩/리다이렉션/환경변수**도 실행 대상/의미를 바꾼다(“경로 하이재킹”·“환경 주입”).
- 근본 대책은 **셸을 호출하지 않는 것**이다. **라이브러리-API로 대체**하거나, 불가피하면 **인자 배열 호출 + 엄격한 화이트리스트 + 최소 권한/샌드박스**로 방어한다.

---

## 위협 모델과 데이터 흐름

```
[사용자 입력] --> [웹앱] --(명령 문자열 결합)--> [셸/프로세스 실행] --> [OS]
                                 ^ 메타문자/경로/환경 조작
```

직관 수식:
\[
\text{Exploit} \iff \exists x \in \text{UserInput}: \; \mathsf{ShellParse}(B \Vert x) \not\simeq \mathsf{Intended}(B)
\]
- \(B\): 개발자가 의도한 베이스 명령
- \(\mathsf{ShellParse}\): 셸의 토큰화/확장/파이프/리다이렉트 처리
- **해결**은 \(\mathsf{ShellParse}\) 경유를 차단(셸 미사용)하거나, **정확한 인자 배열 호출 + 입력 화이트리스트**로 \(\mathsf{ShellParse}\)의 영향력을 제거하는 것.

---

## 흔한 취약 시나리오

### 1. 파일 스캔/압축/미디어 처리에 셸 호출
```python
# ❌ 취약(교육용): 사용자 파일명을 명령 문자열에 직접 결합
import os
def scan(fname):
    os.system(f"clamscan {fname}")  # ;, &&, | 등으로 우회 가능
```

### 2. 네트워크 유틸 호출
```js
// ❌ 취약(교육용): child_process.exec에 문자열 결합
const { exec } = require('child_process');
app.get('/ping', (req, res) => {
  exec(`ping -c 1 ${req.query.host}`, (e, out) => res.send(out));
});
```

### 3. Windows 환경에서 `cmd.exe /c` 위임
```csharp
// ❌ 취약(교육용): 공백·메타문자·따옴표 처리 실패
var psi = new ProcessStartInfo("cmd.exe", "/c " + "type " + userFile);
Process.Start(psi);
```

### 4. 경로 하이재킹(Path/Working Directory)
- `ProcessBuilder("ping")` 처럼 **절대경로 미지정** 시 현재 디렉터리/사용자 PATH에 있는 악성 바이너리 실행 위험.

---

## 셸 메타문자·플랫폼 차이 (요약 표)

| 범주 | POSIX(sh/bash/zsh 등) | Windows(cmd.exe) | PowerShell |
|---|---|---|---|
| 명령 구분/연결 | `;`, `&&`, `||`, `|`, `&` | `&`, `&&`, `||`, `|` | `;`, `&&`, `||`, `|` |
| 치환 | `` `...` ``, `$(...)` | 없음(직접 치환 없음) | `$()`, 백틱 |
| 리다이렉트 | `>`, `>>`, `<`, `2>&1` | `>`, `>>`, `<`, `2>&1` | `>`, `>>`, `<` |
| 와일드카드 | `*`, `?`, `[]` | `*`, `?` | `*`, `?` |
| 변수확장 | `$VAR`, `${...}` | `%VAR%` | `$var`, `${}` |
| 이스케이프 | `\`, `'...'`, `"..."` | `^`, `"..."` | `` ` ``, `'...'`, `"..."` |

> **요지**: **셸 문자열**로 명령을 만들면, 위 메타 처리로 **의도와 다른 실행**이 일어날 수 있다. **셸을 쓰지 말고 인자 배열 호출**을 쓰자.

---

## 언어별 안티패턴 → 안전 코드 레시피

### Python

**안티패턴**
```python
os.system("convert " + user_in + " out.jpg")
subprocess.Popen(f"ffmpeg -i {src} {dst}", shell=True)
```

**권장**
```python
import subprocess, shlex
# 1. 셸 미사용 + 인자 배열
subprocess.run(["ffmpeg", "-i", src, dst], check=True)

# 2. 절대경로·PATH 고정·타임아웃
subprocess.run(["/usr/bin/ffmpeg", "-i", src, dst], check=True, timeout=5)

# 3. 환경 축소(프록시/LD_* 등 제거)
env = {"PATH": "/usr/bin:/bin"}  # 필요한 최소만
subprocess.run(["/usr/bin/ffmpeg", "-i", src, dst], check=True, env=env)
```

**입력 검증(화이트리스트 예)**
```python
import re, pathlib
SAFE_NAME = re.compile(r'^[a-zA-Z0-9_.-]{1,64}$')
def ensure_safe_filename(name: str) -> pathlib.Path:
    if not SAFE_NAME.fullmatch(name):
        raise ValueError("invalid name")
    p = pathlib.Path("/srv/uploads", name).resolve()
    if not str(p).startswith("/srv/uploads/"):
        raise ValueError("path traversal")
    return p
```

### Node.js

**안티패턴**
```js
const { exec } = require('child_process');
exec(`tar -czf ${archive} ${dir}`);
```

**권장**
```js
import { spawn } from 'node:child_process';

// 1) spawn으로 인자 배열 전달, shell:false
const tar = spawn('/usr/bin/tar', ['-czf', archive, dir], {
  shell: false,
  env: { PATH: '/usr/bin:/bin' }
});

tar.on('exit', (code) => { /* ... */ });
```

**호출 대상 화이트리스트**
```js
const ALLOW = new Map([
  ['thumb', ['/usr/bin/convert']],
  ['scan',  ['/usr/bin/clamscan']]
]);

function safeCall(key, args) {
  const bin = ALLOW.get(key);
  if (!bin) throw new Error('not allowed');
  // args도 사전 정의된 옵션 규칙에 맞춰 검증
  return spawn(bin[0], args, { shell:false });
}
```

### Java (Spring 포함)

**안티패턴**
```java
Runtime.getRuntime().exec("sh -c 'ls " + user + "'");
Process p = Runtime.getRuntime().exec("ping " + host);
```

**권장**
```java
var pb = new ProcessBuilder("/bin/ping", "-c", "1", hostSafe);
pb.directory(new File("/"));                         // CWD 고정
pb.environment().clear(); pb.environment().put("PATH", "/usr/bin:/bin");
pb.redirectErrorStream(true);
var proc = pb.start();
// 타임아웃과 종료 코드 체크
proc.waitFor(3, TimeUnit.SECONDS);
if (proc.exitValue() != 0) throw new IllegalStateException("cmd failed");
```

**입력 검증(정형 도메인 예)**
```java
static final Pattern HOST_RE = Pattern.compile("^[a-zA-Z0-9.-]{1,253}$");
String hostSafe(String host){
  if (!HOST_RE.matcher(host).matches()) throw new IllegalArgumentException();
  return host;
}
```

### PHP

**안티패턴**
```php
system("grep " . $_GET['q'] . " /var/log/app.log");
```

**권장**
```php
// 1) escapeshellarg는 보조수단일 뿐. 가능하면 셸을 호출하지 말자.
// 2) proc_open 대신 라이브러리 사용(예: PHP 내부 함수) 권장.
// 3) 불가피하면 인자 배열을 받는 래퍼 사용(external tool을 CGI가 아닌 백엔드 서비스화).
```

### Go

**권장**
```go
cmd := exec.CommandContext(ctx, "/usr/bin/convert", "-resize", "200x", src, dst)
cmd.Env = []string{"PATH=/usr/bin:/bin"}
cmd.SysProcAttr = &syscall.SysProcAttr{ // 리눅스라면 seccomp/namespace와 병행
    // Chroot, Credential drop 등(별도 구성)
}
out, err := cmd.CombinedOutput()
if err != nil { /* 로깅 및 실패 처리 */ }
```

### .NET(C#)

**안티패턴**
```csharp
Process.Start("cmd.exe", "/c ping " + host);
```

**권장**
```csharp
var psi = new ProcessStartInfo {
  FileName = "/bin/ping",
  ArgumentList = { "-c", "1", host },  // .NET Core+ ArgumentList 권장
  UseShellExecute = false,
  RedirectStandardOutput = true,
  RedirectStandardError = true
};
// 환경/작업 디렉터리 고정
psi.WorkingDirectory = "/";
psi.Environment.Clear();
psi.Environment.Add("PATH", "/usr/bin:/bin");

using var p = Process.Start(psi);
if (!p.WaitForExit(3000)) { p.Kill(); throw new TimeoutException(); }
if (p.ExitCode != 0) throw new InvalidOperationException();
```

---

## “셸을 아예 쓰지 않기” — 기능 대체 전략

| 목적 | 셸 호출(취약) | 대체(권장) |
|---|---|---|
| 이미지 변환 | `convert` | 언어별 이미지 라이브러리(Sharp, Pillow, ImageMagick 바인딩도 인자 배열) |
| 압축 | `tar`, `zip` | 언어 내 압축 라이브러리(zip/tar APIs) |
| 네트워크 검사 | `ping`, `curl` | 네트워크/HTTP 라이브러리(소켓, HTTP 클라이언트) |
| 텍스트 검색 | `grep`, `awk` | 언어의 정규식 엔진 |
| 시스템 정보 | `uname`, `df` | 플랫폼 API/라이브러리 |

> **원칙**: “**시스템 명령 → 라이브러리/SDK**로 치환”이 가장 강력한 예방.

---

## 입력 검증·정규화·화이트리스트

1) **문맥별 화이트리스트**:  
   - 호스트명/ID/옵션은 **정규표현식 화이트리스트**로 **허용 가능한 형태만** 남긴다.  
   - 경로는 루트 디렉터리를 고정하고, **canonicalize 후 벗어나면 거부**.

2) **길이/문자 제한**:  
   - 최대 길이 제한(DoS 방지), 제어문자/개행/널바이트 금지.

3) **유니코드 정규화**:  
   - `NFKC` 등으로 정규화해 **혼동 문자**(유사 글자)·**우회 인코딩** 방지.

4) **이중 인코딩/디코딩 방지**:  
   - `%0a`, `%0d` 등 주입에 이용되는 **URL 인코딩 유의**.

---

## 실행 환경 하드닝(피해 최소화)

- **비루트 계정**으로만 외부 프로세스 실행, 필요 시 **seccomp/AppArmor/SELinux** 프로파일로 **시스템콜 제한**.
- **Chroot/컨테이너/네임스페이스 격리**: 파일시스템/네트워크/IPC를 분리.
- **권한·역할 최소화(Principle of Least Privilege)**: 읽기만 필요하면 **읽기 전용**.
- **네트워크/Egress 제어**: 외부 프로세스의 의도치 않은 네트워크 통신 차단.
- **타임아웃/메모리/파일 크기 제한**: `ulimit`, cgroup, Job Object(Windows).

**리눅스 예(서비스 전용 사용자/ulimit)**
```bash
useradd -r -s /usr/sbin/nologin imgsvc
ulimit -t 3 -f 1024 -n 64   # CPU 시간, 파일크기, FD 수 제한(서비스 유닛에서)
```

**systemd 서비스 하드닝 스니펫**
```ini
[Service]
User=imgsvc
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
RestrictAddressFamilies=AF_UNIX
RestrictNamespaces=true
MemoryDenyWriteExecute=true
```

---

## 로깅/탐지·운영 모니터링

- **실패/타임아웃/비정상 종료 코드**를 **구성 가능한 레벨**로 로그화.
- **메타문자 포착 룰**: 입력에 `;`, `&&`, `|`, `` ` ``, `$(`, `>` 등장 시 경고.
- **프로세스 트리/명령행 감시**: EDR/OSQuery/시스몬으로 웹앱 자식 프로세스 패턴 추적.
- **SIEM 룰(아이디어)**
  - `parent_process in (nginx, httpd, node, java, dotnet)` ∧ `child_process.name in (sh, bash, cmd.exe, powershell)` → 경보
  - `exit_code != 0`의 급증, `timeout kill` 빈발 → 공격 시도 또는 장애 신호

---

## 테스트 접근(합법적, 격리 환경)

- **SAST**: `exec`, `system`, `popen`, `Runtime.exec`, `child_process.exec` 등 호출 검색.
- **DAST**: 입력에 무해한 “센티넬” 문자열(예: 공백+파이프 기호)을 넣어 **오작동 여부** 확인.  
  - 예시: `name=SAFE && echo MARK` → **반드시** 사내 승인된 테스트 환경에서만. 실서비스에는 금지.
- **Fuzz**: 옵션 위치·공백·따옴표·유니코드 혼동 문자로 파서 경계 테스트.

---

## 미니 설계: 안전 실행 어댑터(의사 코드)

```text
function safe_exec(operation, user_args):
  # 0) 매핑된 작업만 허용
  allow = {
    "thumb": { bin: "/usr/bin/convert", args: ["-resize", "{WxH}", "{SRC}", "{DST}"], validators: { WxH: /^\d{1,4}x\d{1,4}$/ } },
    "scan":  { bin: "/usr/bin/clamscan", args: ["--no-summary", "{FILE}"], validators: { FILE: safe_path } }
  }
  spec = allow[operation] or deny

  # 1) 각 자리별 검증/정규화
  for each placeholder in spec.args:
    val = validate_and_canonicalize(user_args[placeholder])

  # 2) 인자 배열 생성, shell=false, env 최소화, 절대경로
  proc = spawn(spec.bin, realized_args, shell=false, env=min_env, cwd="/")

  # 3) 타임아웃/메모리/출력 크기 제한, 종료코드 확인
  # 4) 표준 출력 파싱 시에도 길이·형식 검사
```

---

## 체크리스트(현장용)

- [ ] **셸 호출 금지**(가능한 한 라이브러리 사용)
- [ ] 불가피하면 **인자 배열 호출 + shell=false**
- [ ] **절대경로** 지정, **PATH 의존 금지**
- [ ] **화이트리스트 입력 검증**(정규식·열거형·범위)
- [ ] **경로 정규화 + 루트 밖 탈출 차단**
- [ ] **환경/작업 디렉터리 고정**, 프록시/LD\_* 제거
- [ ] **타임아웃/리소스 상한**(ulimit/cgroup/Job Object)
- [ ] **비루트 계정 + MAC(SELinux/AppArmor)** 정책
- [ ] **로그/알림**: 메타문자 탐지, 비정상 종료 코드, 자식 프로세스 스폰 감시
- [ ] **SAST/DAST/Fuzz** 파이프라인에 포함, 회귀 테스트화

---

## 실무 Q&A (간단)

**Q1. `escapeshellarg`만 쓰면 안전?**  
A. **불충분**. 셸 자체를 쓰지 않는 것이 원칙. 인자 배열 호출이 우선이고, `escapeshellarg`는 보조 수단.

**Q2. `execFile`/`spawn`이면 모두 안전?**  
A. **입력 검증/절대경로/환경 고정**이 **함께** 필요. 또한 실행 결과를 **그대로 HTML에 반영**하면 또 다른 취약점(XSS 등)으로 이어진다.

**Q3. 컨테이너면 안전?**  
A. 격리는 **피해 범위를 줄일 뿐**. 컨테이너 내부 자원 파괴, 네트워크 레벨 이동, 데이터 유출은 여전히 가능. **네트워크/권한/리소스** 제한이 함께 가야 한다.

---

## 예상문제(실기 중심)

1) **문항**: 아래 Node.js 코드를 보고 취약점을 지적하고 보완 방안을 쓰시오.
```js
const { exec } = require('child_process');
app.get('/zip', (req, res) => {
  exec(`zip -r ${req.query.name}.zip ${req.query.dir}`, (e, out) => res.send('ok'));
});
```
**요지 답안**: `exec` + 문자열 결합으로 명령 주입 가능. `spawn/execFile`로 인자 배열 사용, `name/dir` 화이트리스트·경로 정규화, 절대 경로 지정, 타임아웃/환경 고정.

2) **문항**: 다음 중 OS 명령 실행 취약점 예방을 위해 **가장 우선**해야 할 조치 2가지를 고르시오.  
   a) 메타문자 이스케이프  b) 셸 미사용·인자 배열 호출  c) 컨테이너화  d) WAF 룰  
**정답**: b, a(보조) — 최우선은 **셸 배제 + 인자 배열**. 이스케이프는 보조. 컨테이너/WAF는 피해 감소·탐지 보조.

3) **문항**: Java에서 `Runtime.exec("ping " + host)` 대신 권장되는 호출 방법과 입력 검증 포인트는?  
**정답 요지**: `new ProcessBuilder("/bin/ping","-c","1",hostSafe)` 사용, 정규식 호스트 화이트리스트, 절대경로/환경 고정/타임아웃.

4) **문항**: 다음 PowerShell 명령 연결 연산자를 쓰고, 왜 위험한지 설명하라.  
**정답 예시**: `|`, `;`, `&&`, `||` 등으로 추가 명령 실행 가능 → 문자열 결합 시 주입 가능.

5) **문항**: 아래 systemd 유닛 옵션 중 외부 프로세스 피해 최소화에 직접 기여하는 것을 3개 고르시오.  
   `NoNewPrivileges, PrivateTmp, ProtectSystem, MemoryDenyWriteExecute, User=`  
**정답**: `User=`, `NoNewPrivileges`, `ProtectSystem` (그 외도 유효하지만 3개 고르기 예시)

---

## 간단 위험 모델 수식(직관)
\[
R = \frac{L \times I}{D}
\]
- \(L\) (발생 가능성) ↓: **셸 미사용**, **화이트리스트 검증**, **절대경로/환경 고정**
- \(I\) (영향) ↓: **권한분리/샌드박스**, **네트워크/리소스 제한**
- \(D\) (탐지/완화) ↑: **로깅/EDR/SIEM 룰**, **타임아웃/종료코드 모니터링**

---

## 결론
- OS 명령 실행 취약점은 **문자열 기반 셸 호출**이 주된 원인이다.  
- **셸을 호출하지 말고**, **언어/라이브러리 API**로 대체하라. 불가피하다면 **인자 배열 + 절대경로 + 환경 고정 + 입력 화이트리스트**를 적용하라.  
- 운영 단계에서는 **권한분리/샌드박스/리소스 제한**으로 피해 반경을 축소하고, **프로세스 트리/메타문자 입력**을 지속 모니터링하라.  
- 위 체크리스트와 코드 레시피를 **팀 표준**으로 만들어, SAST/DAST/테스트로 **자동 검증**을 돌리면 재발을 크게 줄일 수 있다.