---
layout: post
title: 디자인패턴 - Command
date: 2025-06-26 21:20:23 +0900
category: 디자인패턴
---
# Command (커맨드 패턴)

## ✅ 정의

**커맨드 패턴(Command Pattern)**은 **요청(행위)을 객체로 캡슐화하여, 실행, 취소, 큐잉, 로깅** 등의 다양한 기능을 부여할 수 있는 **행위 패턴**입니다.  
요청을 수행하는 **객체와 요청을 호출하는 객체를 분리**함으로써, 요청의 책임을 독립적으로 관리할 수 있게 합니다.

> “요청을 캡슐화하면, 나중에 실행하거나 취소할 수 있다”

---

## 🎯 의도 (Intent)

- 요청(명령)을 객체로 표현하여 **요청자와 실행자의 분리**
- **실행 취소, 요청 큐 저장, 명령 로그 기록 등** 다양한 기능을 유연하게 구현

---

## 📦 구조 (UML)

```
┌────────────┐
│  Client    │
└─────┬──────┘
      ▼
┌────────────┐          ┌────────────┐
│ Command    │◄─────────│ ConcreteCmd│
└─────┬──────┘          └────┬───────┘
      ▼                      ▼
┌────────────┐       ┌────────────┐
│ Invoker    │──────▶│ Receiver   │
└────────────┘       └────────────┘
```

- `Command`: 실행할 명령에 대한 인터페이스
- `ConcreteCommand`: 실제 명령 구현. Receiver에게 작업을 위임
- `Receiver`: 명령을 실제로 수행하는 객체
- `Invoker`: 명령을 요청하는 객체 (예: 버튼)
- `Client`: 명령을 설정하고 Invoker에 전달

---

## 🧑‍💻 구현 예시 (Python)

```python
from abc import ABC, abstractmethod

# Receiver: 실제 작업을 수행하는 객체
class Light:
    def on(self):
        print("💡 불을 켭니다.")
    def off(self):
        print("💡 불을 끕니다.")

# Command 인터페이스
class Command(ABC):
    @abstractmethod
    def execute(self):
        pass

# ConcreteCommand
class LightOnCommand(Command):
    def __init__(self, light: Light):
        self.light = light
    def execute(self):
        self.light.on()

class LightOffCommand(Command):
    def __init__(self, light: Light):
        self.light = light
    def execute(self):
        self.light.off()

# Invoker
class RemoteControl:
    def __init__(self):
        self.history = []
    def press_button(self, command: Command):
        command.execute()
        self.history.append(command)

# 사용 예시
light = Light()
on_cmd = LightOnCommand(light)
off_cmd = LightOffCommand(light)

remote = RemoteControl()
remote.press_button(on_cmd)
remote.press_button(off_cmd)
```

**출력 예시:**
```
💡 불을 켭니다.
💡 불을 끕니다.
```

---

## ✅ 장점

- **명령과 실행 주체 분리** (느슨한 결합)
- 명령을 **큐에 저장**, **로그 기록**, **취소/재실행** 등 기능 구현에 용이
- **OCP (Open/Closed Principle)** 준수: 명령 추가 시 기존 코드 변경 없음

---

## ⚠️ 단점

- 명령이 많아질수록 **클래스 수 증가**
- 간단한 작업에 적용하면 **과도한 설계**가 될 수 있음 (오버엔지니어링)

---

## 📌 사용 사례

| 분야 | 설명 |
|------|------|
| **UI 버튼 동작** | 버튼 → 명령 객체 실행 |
| **Undo/Redo 기능** | 명령을 저장하여 이전 작업 취소 가능 |
| **거래 시스템** | 요청을 큐에 저장 후 비동기 처리 |
| **Macro(매크로)** | 여러 명령을 조합하여 한 번에 실행 |
| **로봇 제어** | 명령어 스트림 생성 및 실행 |
| **게임 엔진** | 플레이어 입력 → 명령 객체로 처리 |

---

## 🔁 확장 기능

- **Undo 기능** 추가: `undo()` 메서드를 `Command` 인터페이스에 추가
- **매크로 명령**: 여러 `Command` 객체를 묶은 `MacroCommand` 구현
- **비동기 명령 큐**: 명령을 큐에 저장해 순차적으로 처리

---

## 🧠 Command vs Strategy vs Observer

| 패턴 | 핵심 목적 | 유사점 | 차이점 |
|------|-----------|--------|--------|
| Command | 요청 캡슐화 | 전략처럼 실행 추상화 | 명령을 저장/취소/지연 가능 |
| Strategy | 알고리즘 교체 | 커맨드처럼 캡슐화 | 실행 목적보다는 선택에 초점 |
| Observer | 이벤트 통보 | 간접 호출 방식 | 1:N 비동기적 호출 구조 |

---

## ✅ 실무 팁

- GUI, 게임, 워크플로우 시스템에서 **모든 동작을 명령으로 표현**하면 유연성이 극대화됨
- 실제로는 `Invoker`에 **명령 큐, 로그, Undo 스택** 등을 추가해 응용 가능
- 명령 객체를 JSON 등으로 **직렬화하여 영속화(저장)**할 수도 있음

---

## 🧠 마무리

**Command 패턴은 단순한 호출 로직을 캡슐화해 확장 가능한 구조로 전환시켜줍니다.**  
특히 사용자 동작을 저장하거나 되돌리는 등의 **복잡한 인터랙션 처리**가 필요한 경우에 매우 유용합니다.

GUI, 게임, 서버 시스템, 매크로 처리 등에서 매우 널리 활용됩니다.  
잘만 활용하면 **모든 동작을 객체화하여 재사용성과 제어력을 극대화할 수 있습니다.**