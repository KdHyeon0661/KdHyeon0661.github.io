---
layout: post
title: 디자인패턴 - Command
date: 2025-06-26 21:20:23 +0900
category: 디자인패턴
---
# Command (커맨드 패턴)

## 정의와 문제 맥락

**커맨드 패턴(Command Pattern)**은 **요청(행위)을 독립된 객체로 캡슐화**하여, 호출자와 수신자(실제 작업)의 결합을 끊고 다음을 가능케 한다.

- 요청의 **지연 실행**(defer), **큐잉**, **스케줄링**
- **취소/재실행(Undo/Redo)**, **로깅/감사**
- **매크로**(여러 명령의 합성), **원격 호출**(RPC, 메시지 버스)
- **권한/검증**의 경계 확립, **재시도·백오프**, **사가 패턴(보상 트랜잭션)**과의 결합

> “요청을 객체로 만들면, 실행 시점·맥락·수명주기를 제어할 수 있다.”

---

## 의도(Intent)와 효과

- **의도**: 요청을 객체로 표현하여 **요청자(Invoker)**와 **수행자(Receiver)**를 분리한다.
- **효과**
  - 요청을 **저장/전송/직렬화**할 수 있다.
  - **Undo/Redo**, **Macro**, **비동기 큐**로 확장 가능하다.
  - OCP(개방-폐쇄 원칙) 충족: 새 명령 추가 시 기존 호출부 수정이 거의 없다.

---

## 구조(Structure)와 참여자

### UML(ASCII)

```
┌────────────┐
│  Client    │
└─────┬──────┘
      ▼
┌────────────┐          ┌────────────┐
│  Command   │◄─────────│ConcreteCmd │
│+execute()  │          │+execute()  │
│[+undo()]   │          │[+undo()]   │
└─────┬──────┘          └────┬───────┘
      ▼                      ▼
┌────────────┐       ┌────────────┐
│  Invoker   │──────▶│  Receiver  │
└────────────┘       └────────────┘
```

### 참여자와 책임

- **Command**: 요청에 대한 인터페이스. `execute()`(필수), `undo()`(선택).
- **ConcreteCommand**: 구체 명령. 상태를 보유할 수 있으며 **Receiver**에게 작업을 위임한다.
- **Receiver**: 실제 작업을 수행.
- **Invoker**: 명령을 보유하고 실행/큐잉/로그/Undo 스택을 관리.
- **Client**: 구체 명령을 구성하여 Invoker에 주입.

---

## 구현 체크포인트

- **Undo 전략** 두 가지
  1) **역연산(inverse operation)**: delete ↔ insert, add ↔ subtract
  2) **Memento(스냅샷)**: 실행 전 상태를 저장하고 복원
  상태가 크면 역연산, 정확성이 중요하면 스냅샷을 선호.
- **Idempotency**: 재시도·중복 실행 가능성을 고려해 **멱등성 키**나 **중복 억제**를 설계.
- **직렬화 가능성**: 명령을 **JSON** 등으로 직렬화/영속화하면 재처리·감사가 용이.
- **보안/검증**: Invoker 앞단 혹은 Command 내부에서 **권한·유효성 검사**.
- **큐 스케줄링**: 우선순위, 실패 재시도, 지연 실행(Delay), 백오프 정책.

---

## 최소 예제(기본형)

```python
from abc import ABC, abstractmethod

# Receiver

class Light:
    def on(self):  print("Light ON")
    def off(self): print("Light OFF")

# Command

class Command(ABC):
    @abstractmethod
    def execute(self): ...
    def undo(self): pass  # 선택

# ConcreteCommand

class LightOn(Command):
    def __init__(self, light: Light): self.light = light
    def execute(self): self.light.on()
    def undo(self):    self.light.off()

class LightOff(Command):
    def __init__(self, light: Light): self.light = light
    def execute(self): self.light.off()
    def undo(self):    self.light.on()

# Invoker

class Remote:
    def __init__(self): self.history = []
    def press(self, cmd: Command):
        cmd.execute()
        self.history.append(cmd)
    def undo(self):
        if self.history:
            self.history.pop().undo()

light = Light()
remote = Remote()
remote.press(LightOn(light))   # Light ON
remote.press(LightOff(light))  # Light OFF
remote.undo()                  # Light ON
```

---

## 텍스트 에디터 예제 — Undo/Redo(역연산)와 스택

### 요구와 설계

- 요구: `insert`, `erase`를 지원하고 **Undo/Redo**가 가능해야 한다.
- 설계: `Command`에 `undo()`를 정의하고, Invoker가 **undo/redo 스택**을 관리한다.

### 코드

```python
from abc import ABC, abstractmethod

class Editor:
    def __init__(self): self.text = []
    def insert(self, s): self.text.append(s)
    def erase(self, n):
        erased = []
        for _ in range(min(n, len(self.text))):
            erased.append(self.text.pop())
        return "".join(reversed(erased))
    def content(self): return "".join(self.text)

class Command(ABC):
    @abstractmethod
    def execute(self): ...
    @abstractmethod
    def undo(self): ...

class Insert(Command):
    def __init__(self, ed: Editor, s: str): self.ed, self.s = ed, s
    def execute(self): self.ed.insert(self.s)
    def undo(self):    self.ed.erase(len(self.s))

class Erase(Command):
    def __init__(self, ed: Editor, n: int): self.ed, self.n, self.buf = ed, n, ""
    def execute(self): self.buf = self.ed.erase(self.n)
    def undo(self):    self.ed.insert(self.buf)

class Invoker:
    def __init__(self):
        self.undo_stack = []
        self.redo_stack = []
    def run(self, cmd: Command):
        cmd.execute()
        self.undo_stack.append(cmd)
        self.redo_stack.clear()
    def undo(self):
        if not self.undo_stack: return
        cmd = self.undo_stack.pop()
        cmd.undo()
        self.redo_stack.append(cmd)
    def redo(self):
        if not self.redo_stack: return
        cmd = self.redo_stack.pop()
        cmd.execute()
        self.undo_stack.append(cmd)

ed = Editor(); inv = Invoker()
inv.run(Insert(ed, "Hello"))
inv.run(Insert(ed, " World"))
print(ed.content())  # Hello World
inv.undo();          print(ed.content())  # Hello
inv.run(Erase(ed, 3)); print(ed.content())  # He
inv.undo();          print(ed.content())  # Hello
inv.redo();          print(ed.content())  # He
```

---

## 매크로 명령(Composite Command)

여러 명령을 하나로 묶어 **원자적**으로 실행/취소한다.

```python
class Macro(Command):
    def __init__(self, *cmds: Command): self.cmds = list(cmds)
    def execute(self):
        for c in self.cmds: c.execute()
    def undo(self):
        for c in reversed(self.cmds): c.undo()
```

활용 예: 복수 파일 이동, 주문 결제 절차(재고 차감 → 결제 승인 → 영수증 발행)를 하나의 클릭으로 처리하고, 실패 시 전체 취소.

---

## 비동기 큐·스케줄러(동시성 포함)

### 스레드 기반 간단 큐

```python
import queue, threading, time

class CommandBus:
    def __init__(self):
        self.q = queue.Queue()
        self.stop = False
        self.t = threading.Thread(target=self._worker, daemon=True)
        self.t.start()
    def dispatch(self, cmd: Command): self.q.put(cmd)
    def _worker(self):
        while not self.stop:
            cmd = self.q.get()
            try:
                cmd.execute()
            except Exception as e:
                # 로깅/재시도/백오프 가능
                print("ERROR:", e)
            finally:
                self.q.task_done()

bus = CommandBus()
bus.dispatch(LightOn(Light()))
time.sleep(0.05)
```

### asyncio 기반(지연 실행·우선순위는 확장)

```python
import asyncio

class AsyncCommand(ABC):
    @abstractmethod
    async def execute(self): ...
    async def undo(self): pass

class DelayPrint(AsyncCommand):
    def __init__(self, s, delay): self.s, self.delay = s, delay
    async def execute(self):
        await asyncio.sleep(self.delay)
        print(self.s)

async def run():
    tasks = [DelayPrint("A", 0.1), DelayPrint("B", 0.01)]
    await asyncio.gather(*(c.execute() for c in tasks))

asyncio.run(run())
```

### 큐 대기 시간의 근사

평균 도착률을 \(\lambda\), 평균 처리율을 \(\mu\) (\(\rho=\lambda/\mu < 1\))라 하면, 단일 서버 대기열의 평균 시스템 내 체류 시간(간단 근사)은

$$
\mathbb{E}[W] \approx \frac{1}{\mu - \lambda}.
$$

즉, **처리율 여유(\(\mu-\lambda\))가 작아질수록 지연이 급증**한다. 우선순위 큐·배치·샤딩으로 \(\mu\)를 높이거나 \(\lambda\)를 제어하라.

---

## 로깅·감사·직렬화(영속화)

명령을 **JSON**으로 직렬화하여 로그/감사/재처리에 활용한다.

```python
import json
from dataclasses import dataclass, asdict

@dataclass
class TransferMoney(Command):
    src: str; dst: str; amount: int
    def execute(self):
        print(f"transfer {self.amount} from {self.src} to {self.dst}")
    def undo(self):
        print(f"compensate {self.amount} from {self.dst} to {self.src}")
    def to_json(self): return json.dumps({"type": "TransferMoney", **asdict(self)})

# 역직렬화 레지스트리

REG = {"TransferMoney": lambda d: TransferMoney(d["src"], d["dst"], d["amount"])}

def from_json(s: str) -> Command:
    d = json.loads(s); return REG[d["type"]](d)

cmd = TransferMoney("A","B",100)
blob = cmd.to_json()
recovered = from_json(blob)
recovered.execute()
```

운영 팁
- **감사 로그**: 명령 ID, 상관관계 ID, 타임스탬프, 호출자, 결과/오류를 함께 기록.
- **멱등 키(idempotency key)**: 재실행 시 중복 적용 방지.
- **보안**: 민감 필드(카드번호 등)는 토큰화/마스킹.

---

## 거래적 시나리오 — 보상 트랜잭션(Saga)와의 결합

분산 환경에서 분산 트랜잭션 대신 **커맨드+보상 커맨드**를 사용한다.

```python
class ReserveStock(Command):
    def __init__(self, sku, qty): self.sku, self.qty = sku, qty
    def execute(self): print(f"reserve {self.qty} of {self.sku}")
    def undo(self):    print(f"release {self.qty} of {self.sku}")

class CapturePayment(Command):
    def __init__(self, order_id, amount): self.order_id, self.amount=order_id, amount
    def execute(self): print(f"capture {self.amount} for {self.order_id}")
    def undo(self):    print(f"refund {self.amount} for {self.order_id}")

class PlaceOrder(Macro):
    pass

order = PlaceOrder(
    ReserveStock("SKU-1", 2),
    CapturePayment("ORD-1", 10000)
)
try:
    order.execute()
except Exception:
    order.undo()
```

- 한 단계 실패 시 전체를 **보상(undo)**하여 **최종 일관성**을 확보한다.
- 각 커맨드는 **멱등성**을 가져야 재시도·중복에도 안전하다.

---

## 권한·검증·크로스컷팅

- **Protection Proxy** 스타일: Invoker 전단에서 토큰·역할 검증 후 커맨드를 허용.
- **데코레이터형 래퍼 커맨드**로 로깅/트레이싱/메트릭/리트라이를 횡단 관심사로 주입.

```python
class Logged(Command):
    def __init__(self, cmd: Command, name: str): self.cmd, self.name = cmd, name
    def execute(self):
        print(f"[begin] {self.name}")
        try:
            self.cmd.execute()
            print(f"[ok] {self.name}")
        except Exception as e:
            print(f"[err] {self.name}: {e}")
            raise
    def undo(self):
        print(f"[undo] {self.name}")
        self.cmd.undo()
```

---

## 비교표 — Strategy / Observer / Mediator

| 패턴 | 핵심 목적 | 유사점 | 차이점 |
|------|-----------|--------|--------|
| Command | 요청 캡슐화·제어 | 실행 추상화 공유 | 저장/취소/지연/직렬화에 최적 |
| Strategy | 알고리즘 교체 | 객체 캡슐화 | 선택·교체 중심, 이력·큐 부적합 |
| Observer | 변경 통보 | 간접 호출 | 1:N 비동기 방송, 명령 이력·Undo와 무관 |
| Mediator | 상호작용 중재 | 결합도 감소 | 네트워크·흐름 조정, 요청 객체화 필수 아님 |

---

## 성능·자원 비용 고려

- **객체 수 증가**: 명령당 인스턴스 생성 비용.
- **큐 지연**: 트래픽 증가 시 대기열 지연. 배치 처리·샤딩·우선순위 큐 고려.
- **로그/직렬화 비용**: 필드 수와 빈도에 비례. 핵심 필드만 선택적으로 로그.
- **메모리**: Undo 스택 크기 상한, 스냅샷 압축/차등 저장.

---

## 테스트·운영 체크리스트

- **계약 테스트**: `execute()`, `undo()`의 사전/사후 조건 명시.
- **멱등성 테스트**: 동일 명령을 반복 실행해도 상태가 일관적인지.
- **장애 주입**: 실행 중간 장애 발생 시 보상·재시도 동작 확인.
- **직렬화 회귀**: JSON 스키마 변경 시 역직렬화 호환성 검증.
- **트레이싱**: 상관관계 ID, 명령 ID를 로그·분산 트레이싱에 포함.

---

## 안티패턴·주의점

- **클래스 폭발**: 간단한 동작까지 전부 클래스로 만들면 과도한 복잡성.
  → 초기에 **함수(콜백)**로 시작하고, 필요할 때 **명령 객체로 승격**.
- **Undo 남용**: 외부 시스템(결제, 이메일)까지 역연산 보장이 어려움.
  → **사가/보상 커맨드**와 **멱등성** 설계로 대체.
- **Invoker 비대화**: 큐·권한·로깅·재시도 모두 Invoker가 담당하면 단일 책임 위배.
  → 역할 분리(커맨드 버스, 미들웨어 체인).

---

## 확장 예시 — 명령 버스 + 미들웨어(체인 결합)

```python
from typing import Callable, List

Middleware = Callable[[Command, Callable[[], None]], None]

class CommandBus:
    def __init__(self, middlewares: List[Middleware]): self.mws = middlewares

    def dispatch(self, cmd: Command):
        def call(i: int):
            if i == len(self.mws):
                cmd.execute(); return
            self.mws[i](cmd, lambda: call(i+1))
        call(0)

def logging_mw(cmd: Command, nxt):
    print("log:start", cmd.__class__.__name__); nxt(); print("log:end")

def retry_mw(cmd: Command, nxt, tries=3):
    for k in range(tries):
        try:
            nxt(); return
        except Exception:
            if k == tries-1: raise

bus = CommandBus([logging_mw, lambda c, n: retry_mw(c, n)])
bus.dispatch(LightOn(Light()))
```

- **Chain of Responsibility**와 결합해 **교차 관심사**를 모듈식으로 주입.

---

## 수학적 메모 — 기대 수행 시간(간단 모델)

명령 한 건의 처리 시간이 \(T\)이고, 독립 명령 \(n\)개를 직렬로 처리하면 총 시간은
\[
T_{\text{total}} = \sum_{i=1}^{n} T_i.
\]
동일 분포라 가정하면 \(\mathbb{E}[T_{\text{total}}] = n \cdot \mathbb{E}[T]\).
**매크로**로 묶어 오버헤드를 공유하거나, **병렬 큐/샤딩**으로 기대 지연을 줄일 수 있다.

---

## 요약

- **핵심**: 요청을 객체로 만들어 **시간·공간·경계**를 제어한다.
- **실무 가치**: Undo/Redo, 매크로, 큐·스케줄, 로깅·감사, 직렬화·영속화, 사가/보상 트랜잭션.
- **주의**: 과도한 클래스 증가, 비멱등 작업의 Undo, Invoker 비대화.
- **권장 절차**:
  1) 함수형 콜백으로 시작 →
  2) Undo/큐/영속 필요 시 **Command 객체로 승격** →
  3) **미들웨어/버스**로 횡단 관심사를 조립 →
  4) **멱등성·직렬화·감사**와 **테스트**를 체계화.

이로써 커맨드 패턴은 단순한 호출 로직을 **검증 가능하고 운영 친화적인 프로세스**로 승격시킨다.
