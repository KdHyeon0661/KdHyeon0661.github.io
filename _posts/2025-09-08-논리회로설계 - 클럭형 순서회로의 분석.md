---
layout: post
title: 논리회로설계 - 클럭형 순서회로의 분석
date: 2025-09-08 17:25:23 +0900
category: 논리회로설계
---
# 클럭형 순서회로의 분석 — **순서 패리티 검사기**, **타이밍도·신호 추적**, **상태표·상태그래프**, **순서회로의 일반화 모델**

## 1. 순서 패리티 검사기(Sequence Parity Checker)

### 1.1 개념과 설계 포인트
- **목표**: 시퀀스 \(x[0],x[1],\dots\)의 누적 패리티(짝/홀)를 추적.
  - **Moore형**: “지금까지의 데이터” 패리티를 **상태로 보유**하고 출력.
  - **Mealy형**: “이번 입력까지 반영한 결과”를 **즉시** 출력.
- 적용: 직렬 통신의 **프레이밍/패리티**(UART, SPI 변형), 블록 스트림의 **러닝 XOR 체크**, 간단 오류 검출(홀수 개 비트 오류 탐지).

### 1.2 최소 상태(2상태 FSM)와 전이
- 상태 \(E\)=짝수, \(O\)=홀수. 입력이 1이면 **토글**, 0이면 **유지**.

**Moore (노드 라벨=출력)**
```
   x=1       x=1
E ───▶ O ───▶ E
│ x=0 ▲ x=0 │
▼     │     ▼
E     O     O

출력: y=0 at E, y=1 at O
```

**Mealy (간선 라벨=입력/출력)**
```
E ──0/0──▶ E   E ──1/1──▶ O
O ──0/1──▶ O   O ──1/0──▶ E
```

### 1.3 상태방정식·플립플롭 구현
상태 비트 \(q\in\{0(\text{even}),1(\text{odd})\}\)로 잡으면
\[
q^+ = q \oplus x
\]
- **Moore 출력**: \(y=q\)
- **Mealy 출력**: \(y=q\oplus x\)
- **D-FF**: \(D = q \oplus x\)
- **T-FF**: \(T = x\)  (입력이 1일 때만 토글)

**VHDL(Moore, 합성 가능)**
```vhdl
library ieee; use ieee.std_logic_1164.all;
entity parity_moore is
  port (clk, rst, x : in std_logic; y : out std_logic);
end;
architecture rtl of parity_moore is
  signal q : std_logic := '0'; -- 0=even, 1=odd
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then q <= '0';
      else            q <= q xor x;
      end if;
    end if;
  end process;
  y <= q;
end;
```

**SystemVerilog(Mealy, 출력 등록 권장)**
```systemverilog
module parity_mealy (
  input  logic clk, rst, x,
  output logic y
);
  logic q, y_i;
  always_ff @(posedge clk) begin
    if (rst) begin q <= 1'b0; y_i <= 1'b0; end
    else begin
      y_i <= q ^ x;  // 이번 입력까지 반영
      q   <= q ^ x;
    end
  end
  assign y = y_i; // 글리치 방지: 레지스터링
endmodule
```

### 1.4 패킷 단위 패리티(프레임 끝의 패리티 비트 \(p\))
- 짝수 패리티 가정: 데이터 \(N\)비트 후 한 비트 \(p\)가 붙음.
\[
\text{에러(짝수)}=
\begin{cases}
q_N \oplus p & (\text{Moore}) \\
(q\oplus p)\ \text{at parity cycle} & (\text{Mealy})
\end{cases}
\]
- 실무: 데이터 구간에서 \(q^+=q\oplus x\); 패리티 구간에선 \(x\)가 \(p\). 비교 결과를 **1클럭 펄스**로 래치.

---

## 2. 타이밍도·신호 추적(워크플로)

### 2.1 절차(6단계)
1. **샘플 에지 지정**: ↑에지마다 상태 전이.
2. **초기 상태** \(q[0]\) 확정(미정이면 분기 분석).
3. **다음상태식** \(q^+=f(q,x)\) 평가.
4. **출력식** \(y=g(q)\) 또는 \(g(q,x)\) 평가.
5. **시퀀스 표**로 누적: \(k \mid x[k]\ ; q[k]\to q[k+1]\ ; y[k]\).
6. **파형 반영**(ASCII 또는 시뮬레이터 파형).

### 2.2 예시 A — 패리티(Moore)
- 식: \(q^+=q\oplus x,\ y=q\). 입력: `1 0 1 1 0`, 초기 \(q[0]=0\).

| k | x | q → q⁺ | y |
|:-:|:-:|:------:|:-:|
| 0 | 1 | 0→1    | 0 |
| 1 | 0 | 1→1    | 1 |
| 2 | 1 | 1→0    | 1 |
| 3 | 1 | 0→1    | 0 |
| 4 | 0 | 1→1    | 1 |

ASCII 파형(↑에지 샘플):
```
CLK: _/‾\_/‾\_/‾\_/‾\_/‾\_
x  : 1___0___1___1___0____
q  : 0---1---1---0---1-----
y  : 0---1---1---0---1-----  (Moore: y=q)
```

### 2.3 예시 B — 2비트 FSM 신호 추적
\[
\begin{aligned}
q_1^+ &= \overline{q_1}\,x + q_0\\
q_0^+ &= \overline{q_0}\,\overline{x} + q_1\,x\\
y &= q_1
\end{aligned}
\]
입력열 `1,0,1,1,…`, 초기 \(q_1q_0=00\). 에지마다 위 식을 대입해 표를 작성(§5 참조).
**팁**: **샘플 직전**의 \((q,x)\)로 \(q^+\)를 계산 → **샘플 직후**의 \((q)\)로 기록.

---

## 3. 상태표·상태그래프(회로↔모형)

### 3.1 정의
- **상태표(State Table)**: 각 \((\text{현재상태},\text{입력})\)에 대응하는 \((\text{다음상태},\text{출력})\)을 표로.
- **상태그래프(State Diagram)**: 상태=노드, 전이=간선.
  - **Mealy**: 간선 라벨 `입력/출력`.
  - **Moore**: 노드 라벨 `상태(출력)`.

### 3.2 회로→상태표 도출법
1) FF 수 \(n\) 확인 → 상태 공간 \(2^n\).
2) 모든 \((q,x)\) 조합에 대해 \(q^+=f(q,x)\) 계산.
3) 출력식 \(y=g(q)\) 또는 \(g(q,x)\)를 채움.
4) **불법 상태**의 귀결 정의(Self-start/락아웃 방지).

### 3.3 예시(패리티 FSM, Mealy)
| 현재 | 입력 | 다음 | 출력 |
|:---:|:---:|:---:|:---:|
| E | 0 | E | 0 |
| E | 1 | O | 1 |
| O | 0 | O | 1 |
| O | 1 | E | 0 |

그래프(간선 `x/y`):
```
E --0/0--> E,  E --1/1--> O
O --0/1--> O,  O --1/0--> E
```

### 3.4 최소화·부호화(개요)
- **최소화**: 동치 상태 병합(함의 차트/분할 정련).
- **상태할당**: 이진/그레이/원-핫/존슨 등(해밍-1 전이, 해저드, 타이밍에 영향).

---

## 4. 순서회로의 일반화 모델

### 4.1 수학적 FSM
- 집합 \(X\)(입력), \(S\)(상태), \(Z\)(출력).
- **Mealy**: \(\delta: S\times X\rightarrow S,\ \lambda: S\times X\rightarrow Z\)
- **Moore**: \(\delta: S\times X\rightarrow S,\ \lambda: S\rightarrow Z\)
- 이산시간:
\[
s[k+1]=\delta(s[k],x[k]),\quad
\begin{cases}
y[k]=\lambda(s[k],x[k]) & \text{(Mealy)}\\
y[k]=\lambda(s[k]) & \text{(Moore)}
\end{cases}
\]

### 4.2 하드웨어 분해(레지스터-조합)
\[
q[k+1]=F(q[k],x[k]),\qquad y[k]=G(q[k],x[k])\ \text{or}\ G(q[k])
\]
- 구성: **상태 레지스터(FF)** + **다음상태 로직 \(F\)** + **출력 로직 \(G\)**
- 규칙: **모든 피드백은 레지스터를 통해서만**, 조합 루프 금지.

### 4.3 초기화와 안정성(Self-start)
- 리셋으로 \(q[0]\) 설정.
- 불법 상태에서 **합법 루프 수렴**하도록 \(F\) 정의(others→IDLE 등).

---

## 5. 완전 예제 — 회로→상태표→그래프→타이밍 추적

### 5.1 문제(2 D-FF, 입력 1개)
\[
\begin{aligned}
q_1^+ &= \overline{q_1}\,x + q_0\\
q_0^+ &= \overline{q_0}\,\overline{x} + q_1\,x\\
y &= q_1 \oplus q_0
\end{aligned}
\]

### 5.2 상태표(현재 \(q_1q_0\), 입력 \(x\))
| \(q_1q_0\) | x | \(q_1^+q_0^+\) | y |
|:--:|:--:|:--:|:--:|
| 00 | 0 | 00 | 0 |
| 00 | 1 | 01 | 0 |
| 01 | 0 | 00 | 1 |
| 01 | 1 | 11 | 1 |
| 10 | 0 | 10 | 1 |
| 10 | 1 | 01 | 1 |
| 11 | 0 | 10 | 0 |
| 11 | 1 | 11 | 0 |

### 5.3 상태그래프(간선 `x/y`)
```
00 --0/0--> 00, 00 --1/0--> 01
01 --0/1--> 00, 01 --1/1--> 11
10 --0/1--> 10, 10 --1/1--> 01
11 --0/0--> 10, 11 --1/0--> 11
```

### 5.4 신호 추적(입력 `1,0,1,1,…`, 초기 `00`)
| k | x | q → q⁺ | y |
|:-:|:-:|:------:|:-:|
| 0 | 1 | 00→01 | 0 |
| 1 | 0 | 01→00 | 1 |
| 2 | 1 | 00→01 | 0 |
| 3 | 1 | 01→11 | 1 |
| 4 | 0 | 11→10 | 0 |
| … | … | …     | … |

---

## 6. 타이밍·실무 고려(분석 관점에서 반드시 확인)

### 6.1 동기 타이밍 한계
\[
T_{clk} \ge T_{CQ} + t_{comb} + T_{SU}
\]
- \(T_{CQ}\): FF 클럭→Q 지연, \(t_{comb}\): 조합 경로 지연, \(T_{SU}\): 세트업 시간.
- **대응**: 파이프라인 삽입, 리타이밍, 팬인 분해, 멀티사이클(정당할 때만).

### 6.2 Mealy 출력의 글리치와 등록
- Mealy는 \(G(q,x)\)가 입력에 즉각 반응 → **글리치 위험**.
- 실무: **출력을 한 클럭 등록**해 외부로 내보냄(§1.3 코드 참조).

### 6.3 비동기 입력과 메타안정
- 단일 비트는 **2FF 동기화**, 펄스/토글은 전용 동기화(토글 플롭+에지 검출).
- 비동기 리셋은 **해제 시점**을 클럭에 **동기화**(RDC 방지).

---

## 7. 확장 예제 — “프레임 패리티 검사기”의 전체 흐름

### 7.1 프레임 구조와 요구사항
- 프레임: `START(1) — D[0..N-1] — PARITY(p) — STOP(0)`
- 짝수 패리티 기준으로 **에러면 1클럭 `ERR`=1**.

### 7.2 FSM(원-핫 제안)과 데이터 경로
- 상태: `IDLE → DATA(i=0..N-1) → PAR → STOP/OUT`
- 러닝 패리티 레지스터 \(q\), 쉬프트/카운터 포함.

**VHDL 스케치(핵심부)**
```vhdl
-- tick: 비트 타이밍 펄스(오버샘플링에서 추출)
if rising_edge(clk) then
  if rst='1' then s<=IDLE; q<='0'; i<=0; ERR<='0'; VAL<='0';
  else
    VAL<='0'; ERR<='0';
    case s is
      when IDLE => if tick='1' and x='1' then s<=DATA; q<='0'; i<=0; end if;
      when DATA =>
        if tick='1' then
          q <= q xor x; i <= i + 1;
          if i=N-1 then s<=PAR; end if;
        end if;
      when PAR =>
        if tick='1' then
          if (q xor x)='1' then ERR<='1'; end if; -- x=p
          s<=STOP;
        end if;
      when STOP =>
        if tick='1' then
          if x='0' then VAL<='1'; else ERR<='1'; end if;
          s<=IDLE;
        end if;
    end case;
  end if;
end if;
```

---

## 8. 분석·학습 체크리스트

- [ ] 상태는 **↑에지에서만** 변한다는 가정으로 추적했는가?
- [ ] **다음상태식** \(q^+=F(q,x)\)과 **출력식** \(G(\cdot)\)를 분리했는가(Mealy/Moore 구분)?
- [ ] **상태표**를 입력 전체 도메인에 대해 **완전** 기입했는가(불법 상태 포함)?
- [ ] **Self-start/lockout** 방지가 있는가(others→IDLE 등)?
- [ ] 인코딩(이진/그레이/원-핫)이 **해밍-1 전이/해저드/타이밍**에 적합한가?
- [ ] 타이밍도 추적 시 **샘플 직전** 값으로 \(q^+\)를 계산했는가?
- [ ] Mealy 출력은 **등록**하여 외부로 내보내는가?
- [ ] 비동기 입력/리셋의 **동기 해제**를 처리했는가?

---

## 9. 연습문제(필요 시 해설 제공)

1) 길이 \(N\) 스트림에서 마지막 비트 직후 **짝수 패리티 OK이면 1을 1클럭** 출력하는 Mealy FSM 설계. 상태표/그래프/타이밍도 작성.
2) §5의 2비트 FSM에 **그레이 인코딩**을 적용하고, \(q^+=F(q,x)\)를 다시 유도. Mealy→Moore 변환 시 출력 지연을 정량 설명.
3) 입력 `1011`이 검출될 때마다 1클럭 `y=1`을 내는 검출기(Mealy)를 상태표→그래프→타이밍도로 분석. 중첩 허용과 비허용의 차이를 비교.
4) 불법 상태에서 가장 가까운 합법 상태로 **수렴**하도록 self-start 규칙을 설계하고 K-맵으로 최소화. Mealy 출력의 글리치 사례를 만들어 등록 유무에 따른 파형을 비교.

---

## 10. 포켓 요약
- **패리티 FSM**: \(q^+=q\oplus x\). Moore \(y=q\), Mealy \(y=q\oplus x\).
- **타이밍 추적**: ↑에지마다 \(F(q,x)\)로 \(q^+\) 계산 → 표/파형으로 검증.
- **상태표/그래프**: Mealy(간선 `x/y`), Moore(노드 `상태(출력)`).
- **일반화 모델**: \(q^+=F(q,x)\), \(y=G(q,x)\) 또는 \(G(q)\); 레지스터-조합 분해로 분석 단순화.
- **실무 안전수칙**: Mealy 출력 **등록**, 비동기 신호 **2FF 동기화**, 리셋 **동기 해제**, 타이밍 여유는 \(T_{CQ}+t_{comb}+T_{SU}\le T_{clk}\)로 점검.
