---
layout: post
title: 암호학 - 암호학 들어가기
date: 2025-10-08 20:30:23 +0900
category: 암호학
---
# 암호학 들어가기

## 1.1 암호학의 목표: “무엇을 지킬 것인가”

암호학은 보안을 네 가지 축으로 나눕니다.

1) **기밀성(Confidentiality)**
   - 내용이 **타인에게 읽히지 않도록** 하는 목표.
   - 보통 **암호화(Encryption)** 로 달성: 평문 \(M\) → 암호문 \(C\).

2) **무결성(Integrity)**
   - 데이터가 **변조되지 않았음**을 확인.
   - **MAC**(Message Authentication Code) 또는 **디지털 서명** 사용.

3) **인증(Authentication)**
   - 상대가 **누구인지** 확인(신원 인증·메시지 인증).
   - 비밀키 공유 기반(MAC) 또는 공개키(서명) 기반.

4) **부인방지(Non-repudiation)**
   - “**내가 보낸 적 없다**”를 나중에 **부인하지 못하게** 함.
   - 공개키 **서명**이 대표적 수단(법적 증거력까지는 제도적 요소와 결합).

> 정리:
> - **암호화**는 주로 *기밀성*.
> - **MAC/서명**은 주로 *무결성·인증* (서명은 *부인방지*까지).
> - 실무에서는 **AEAD**(Authenticated Encryption with Associated Data)로 *암호화+무결성*을 **동시에** 달성하는 것이 표준입니다.

---

## 1.2 시스템 관점에서 본 보안 목표의 분해

- **데이터 상태**: 저장(At-rest), 전송(In-transit), 사용(In-use)
  - At-rest: 디스크/DB 암호화(AES-XTS, TDE)
  - In-transit: TLS 1.3 (AEAD 스위트)
  - In-use: 평문이 메모리에 존재(사이드채널·비밀 관리 문제와 연결)

- **식별자/토큰**: 세션 토큰·JWT는 **기밀성**보다 **무결성과 만료·범위**가 핵심.
- **로그**: 보안 자체가 새 **기밀성 문제**를 만들 수 있음(키/토큰/개인정보 노출 주의).

---

## 1.3 공격자 모델(Adversary Model): “누구와 싸우는가”

암호학은 **위협 모델(Threat Model)** 을 명시하지 않으면 “안전”을 말할 수 없습니다.

### 접근 범위 관점

- **암흑상자(Black-box)**: 알고리즘 내부는 모름(현대 암호는 보통 *열린 상자* 가정)
- **화이트박스(White-box)**: 알고리즘·키가 있는 코드까지 관찰·추출 가능
- **그레이박스(Grey-box)**: 타이밍/캐시/전력 같은 **부수 정보(사이드채널)** 관찰 가능

> 실무 기본: **Kerckhoffs 원리**에 따라 알고리즘·구현은 공개되어도 안전해야 하고, **키만 비밀**이라고 가정합니다(화이트박스 수준이 아니더라도, 최소한 알고리즘 비공개에 기대지 않음).

### 질의 능력 관점: 암호화·복호화 오라클

- **Ciphertext-only**: 암호문만 볼 수 있음
- **Known-plaintext**: 일부 평문·암호문 쌍을 알고 있음
- **Chosen-plaintext (CPA)**: 공격자가 **원하는 평문**을 **암호화 시켜 볼 수 있음**
- **Chosen-ciphertext (CCA)**: 공격자가 **원하는 암호문**을 **복호화 시켜 볼 수 있음**
  - **CCA1(비적응)**: 공격 전 한 번의 복호 질의
  - **CCA2(적응)**: 공격 중간에도 복호 질의 가능(현대 네트워크 공격 모델과 근접)

> 현대 실용 보안은 최소 **IND-CPA**, 프로토콜·네트워크 환경이라면 **IND-CCA** 또는 **AEAD** 요구가 일반적입니다.

---

## 1.4 보안 정의: “안전하다는 말을 수학으로”

### 안전의 직관

- 공격자가 **현실적인 시간**과 **자원**으로 **성공 확률이 유의하게 높지 않다** → 안전.
- “유의하게(significantly)”는 **다항시간 적(Polynomial-time adversary)** 에 대해 **기대 성공 확률이 무시 가능(네글리저블)** 해야 함.

### IND-CPA (Indistinguishability under Chosen-Plaintext Attack)

- 게임(Game) 정의:
  1. 키 \(K \leftarrow \mathsf{KeyGen}\)
  2. 공격자 \(\mathcal{A}\)는 **암호화 오라클** \(\mathsf{Enc}_K(\cdot)\) 사용 가능
  3. \(\mathcal{A}\)가 서로 다른 길이 같음\(\)인 두 평문 \(m_0, m_1\) 제시
  4. 도전자 \(b \xleftarrow{\$} \{0,1\}\), **챌린지 암호문** \(c \leftarrow \mathsf{Enc}_K(m_b)\) 제공
  5. \(\mathcal{A}\)는 \(b\)를 맞추려 함.
- 이때
  \[
  \left|\Pr[b' = b] - \tfrac{1}{2}\right|
  \]
  이 **네글리저블**이면 IND-CPA 안전.

- 함의: **무작위 IV/Nonce**, **길이 유출 최소화**, **패딩·포맷 일관성** 등 구현 세부가 중요.

### IND-CCA (under Chosen-Ciphertext Attack)

- CPA 게임 + **복호 오라클** \(\mathsf{Dec}_K(\cdot)\) 제공
- 단, **챌린지 암호문** \(c\) 그 자체는 질의 금지.
- \(\mathcal{A}\)가 복호 오라클을 **적응적으로** 이용해도 \(\Pr[b'=b]\) 이 1/2 근처 → 안전.

- 함의: **패딩 오라클** 같은 에러 반응 차이, **인증 없는 암호화**의 위험이 그대로 **CCA 취약**과 연결.

### 무결성(정확성) 정의 (INT-CTXT / SUF-CMA)

- **INT-CTXT**(암호문 무결성): 공격자가 **새(valid) 암호문**을 위조해 수용되게 만들 **확률이 네글리저블**.
- **SUF-CMA**(서명 강적응 위조 불가): 공격자가 **임의 메시지에 대한 서명 질의**를 마음껏 해도, **새로운 메시지**에 대한 **새로운 유효 서명**을 만들 수 없어야 함.

> 요약: **AEAD**는 일반적으로 **IND-CPA + INT-CTXT**를 동시에 제공하도록 설계됩니다(예: AES-GCM, ChaCha20-Poly1305).

---

## 1.5 Shannon의 혼돈(Confusion)·확산(Diffusion)

클로드 섀넌은 “좋은 암호”의 성질을 두 단어로 요약했습니다.

- **혼돈**: 키 비트가 암호문에 **비선형적**으로 얽혀, 키에 대한 추론이 극히 어려움.
  - **S-box**(Substitution box) 같은 **비선형** 요소가 핵심.

- **확산**: 평문의 비트 하나가 암호문 전체에 **널리 퍼져** 영향.
  - **P-layer**(Permutation), **선형 확산층**이 핵심.

> 현대 블록암호(AES 등)는 **S(혼돈) → P(확산)** 를 여러 라운드 반복해, **차분/선형 공격** 등 구조적 분석을 어렵게 합니다.

---

## 1.6 Kerckhoffs 원리 & 안전한 기본 규칙

### Kerckhoffs 원리

- **알고리즘·구현이 모두 공개되어도** 시스템이 안전해야 한다.
- **키만 비밀**이라는 현실적 가정에 의존해야 한다.

### 안전한 기본 규칙(필수 체크리스트)

1) **검증된 표준 알고리즘·라이브러리 사용**
   - AES-GCM / ChaCha20-Poly1305, Ed25519/ECDH(X25519) 등

2) **Nonce/IV 재사용 금지**
   - GCM/CTR은 **Nonce 충돌** 시 기밀·무결성 모두 붕괴 가능

3) **AEAD 우선**
   - “Encrypt-then-MAC” 혹은 AEAD(내장된 인증) 사용.
   - “**MAC-then-Encrypt**”는 여러 취약 사례 존재.

4) **비밀번호는 해시가 아니라 KDF**
   - Argon2id / scrypt / PBKDF2(상대적으로 약함) + **솔트** + 충분한 **메모리 비용**

5) **에러 메시지는 일정하고, 타이밍/길이 정보 제한**
   - 패딩오라클·서명 타이밍 누설 방지. 가능하면 **상수 시간 비교**.

6) **키 수명주기 관리**
   - 생성→저장→사용→회전→폐기. 환경변수 노출·로그 유출 금지.
   - 가능하면 **HSM/KMS** 사용.

7) **업데이트·난수 품질 모니터링**
   - RNG 초기화 실패·플랫폼 편차 감시, 보안 패치 우선 적용.

---

## 1.7 미니 실험: “왜 AEAD가 기본인지” (Python)

> 아래 코드는 **교육용**입니다. 운영 환경에서는 검증된 고수준 API(예: `cryptography.hazmat.primitives.ciphers.aead.AESGCM`)만 사용하세요.

```python
# pip install cryptography

from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os

def aead_encrypt(key: bytes, nonce: bytes, msg: bytes, aad: bytes=b"") -> bytes:
    aesgcm = AESGCM(key)
    return aesgcm.encrypt(nonce, msg, aad)  # returns ciphertext || tag

def aead_decrypt(key: bytes, nonce: bytes, ct: bytes, aad: bytes=b"") -> bytes:
    aesgcm = AESGCM(key)
    return aesgcm.decrypt(nonce, ct, aad)

key  = AESGCM.generate_key(bit_length=128)
nonce = os.urandom(12)  # GCM 표준 Nonce 길이
msg   = b"meet at dawn"
aad   = b"header:route=v1"

ct = aead_encrypt(key, nonce, msg, aad)
pt = aead_decrypt(key, nonce, ct, aad)
print("복호 결과:", pt)
```

- **AEAD의 장점**:
  - 암호문 **변조** 시 복호 단계에서 **예외 발생**(무결성 보장).
  - AAD(Associated Data)는 **암호화하지 않지만** 무결성은 보장(예: 헤더/라우팅 정보).

---

## 1.8 “Nonce 재사용”이 왜 치명적인가 (직관 실험)

- 스트림 계열(CTR/GCM)의 **키스트림**은 \(\text{KS} = \mathsf{E}_K(\text{Nonce}, \text{Counter})\) 형태.
- **같은 Nonce**로 두 메시지를 암호화하면, 두 암호문을 XOR하면 **평문 XOR**이 드러남.

```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os

key   = AESGCM.generate_key(bit_length=128)
nonce = os.urandom(12)  # 실수로 동일 nonce 재사용한다고 가정

m1 = b"attack at dawn"
m2 = b"retreat at dusk"

aead = AESGCM(key)
c1 = aead.encrypt(nonce, m1, b"")
c2 = aead.encrypt(nonce, m2, b"")

# 교육용: 태그 길이를 모르면 분해가 어렵지만, Nonce 재사용은 근본적 위험.
# GCM은 내부적으로 해시 서브키·인증까지 있어 위처럼 단순 XOR 시연은 불충분하지만,
# 'Nonce 충돌'이 이론적으로 AE 보장(특히 무결성)을 약화시킨다는 점이 핵심이다.

print("c1 len, c2 len:", len(c1), len(c2))
```

> 실무 규칙: **Nonce는 절대 중복되지 않도록** 라이브러리의 안전한 난수/카운터를 사용하고, **스스로 관리하지 마세요**.

---

## 1.9 패딩 오라클의 직관: CCA가 필요한 이유

- **CBC** 모드에서 패딩 검사 결과(성공/실패)를 **미세하게 다르게** 반환하면,
  공격자는 암호문 블록을 조작하며 **바이트 단위로 평문을 복구**할 수 있습니다.
- 원인: **무결성 검증이 없는 암호화** + **에러 메시지 차이**.

> 대응: **AEAD 사용** 또는 “Encrypt-then-MAC”로 **복호 전에 무결성부터 검증**.
> 구현 시 **에러 메시지·타이밍·반응 시간**을 균등하게 유지.

---

## 1.10 ‘완전한 보안’과 OTP(One-Time Pad)

- **OTP**는 **키 길이 = 메시지 길이**, 키는 **완전한 랜덤**·**한 번만 사용**하면 **정보이론적으로 완전한 기밀성**.
- 수학적으로
  \[
  I(M;C) = 0
  \]
  (암호문 \(C\)는 평문 \(M\)에 대한 정보가 없음)

- **실무 한계**: 긴 키의 **분배/보관/동기화**가 불가.
- 따라서 현실에서는 **계산적 보안**(다항시간 공격자 상정) + **AEAD**를 채택.

**미니 시연 (XOR Pad - 교육용)**

```python
import os

def otp_encrypt(plaintext: bytes) -> tuple[bytes, bytes]:
    pad = os.urandom(len(plaintext))  # 진짜 랜덤이라 가정
    ct = bytes([p ^ k for p, k in zip(plaintext, pad)])
    return ct, pad

pt = b"HELLO OTP"
ct, pad = otp_encrypt(pt)
print("ct:", ct.hex())

# pad를 잃으면 복호 불가. pad 재사용은 절대 금지!

```

---

## 1.11 “안전한 기본 규칙” 체크리스트 (실무용)

- [ ] **AEAD**(AES-GCM 또는 ChaCha20-Poly1305) 사용
- [ ] **키**: 128/192/256비트 대칭, 공개키는 X25519/Ed25519 선호
- [ ] **Nonce**: 라이브러리에 맡기고 재사용 금지(12바이트 GCM)
- [ ] **비밀번호 저장**: Argon2id(salt, time/memory/parallelism 충분)
- [ ] **에러 처리**: 동일 메시지·동일 코드·상수시간 비교
- [ ] **키 관리**: KMS/HSM·권한 최소화·회전 주기·폐기 절차
- [ ] **로그/모니터링**: 비밀·키·토큰 미노출, 실패율 급증 감시
- [ ] **업데이트**: 라이브러리 CVE 추적, 알고리즘 감가상각 정책
- [ ] **테스트**: Wycheproof 등 **Known-answer test**로 회귀 검사

---

## 1.12 예제로 배우는 “보안 정의의 차이”

### 단순 암호화(기밀성만) vs AEAD(기밀성+무결성)

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305
from cryptography.hazmat.backends import default_backend
import os

# 무결성 없는 암호화 예시 - 교육용

def encrypt_cbc_unsafe(key, iv, pt):
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    enc = cipher.encryptor()
    # PKCS#7 패딩 생략(교육용) - 실제로는 반드시 필요. 이 예시는 오작동/취약.
    return enc.update(pt) + enc.finalize()

# AEAD

def encrypt_aead(key, nonce, pt, aad=b""):
    aead = ChaCha20Poly1305(key)
    return aead.encrypt(nonce, pt, aad)

key   = os.urandom(32)   # 256-bit
iv    = os.urandom(16)
nonce = os.urandom(12)

pt = b"message"

c1 = encrypt_cbc_unsafe(key[:16], iv, pt)     # 무결성 없음(교육용)
c2 = encrypt_aead(key, nonce, pt)             # 무결성 포함

print(len(c1), len(c2))
```

- **의미**: CBC 예시는 *그 자체로* 무결성 미보장(패딩·MAC 필요). 반면 AEAD는 **암호문 변조** 시 복호가 **실패**.

### AAD(Associated Data)의 쓰임

- 예: TLS에서 **헤더**(암호화하지 않음)는 AAD로 넣어 **변조 불가** 보장.

```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM, ChaCha20Poly1305
import os

key = AESGCM.generate_key(bit_length=128)
nonce = os.urandom(12)

pt  = b"payload"
aad = b"route=/api/v1,seq=42"  # 암호화되지 않지만, 위변조 시 검출됨

aesgcm = AESGCM(key)
ct = aesgcm.encrypt(nonce, pt, aad)

# aad가 다르면 복호 실패

try:
    print(aesgcm.decrypt(nonce, ct, b"route=/api/v1,seq=43"))
except Exception as e:
    print("무결성 검출 OK:", e)
```

---

## 1.13 흔한 함정과 대처

1) **“직접 구현” 금지**
   - 패딩, 난수, 타이밍, 에러 메시지 등 **사소해 보이는 결정**이 치명상 초래.

2) **Nonce 관리 실패**
   - 컨테이너 재시작·멀티프로세스·복제 환경에서 **충돌** 빈발.
   - **라이브러리/OS**에 맡기고, 필요시 **카운터+장치 ID** 설계.

3) **키/토큰 로그 유출**
   - 디버그 로그에 평문 비밀이 찍히지 않도록 **필터링**.
   - 프로덕션에서는 **민감 데이터 로깅 금지** 기본값.

4) **JWT 오용**
   - `alg=none` 허용, 대칭/비대칭 키 혼동, 영구 만료 미설정 등.
   - 해결: **서명 알고리즘 고정**, **키 종류 일치**, **만료/회수 전략**.

5) **비밀번호 해시**
   - **SHA-256 단독 사용 금지.** 반드시 **KDF(Argon2id)**.
   - 솔트·메모리 비용·동시성 파라미터 **정책화**.

---

## 1.14 작은 프로젝트: “안전한 메시지 상자” (AEAD & 정책)

**요구**:
- 메시지 본문은 **AEAD**로 암복호
- 헤더(수신자 ID, 버전)는 **AAD**로 무결성만 보장
- 키는 **세션마다 회전**(간단히 난수로 생성)
- **Nonce 자동 생성** + 재사용 방지
- 로그에 **비밀 금지**

```python
import os, json, base64, logging
from dataclasses import dataclass
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

logging.basicConfig(level=logging.INFO)

@dataclass
class Envelope:
    version: int
    recipient: str
    aad: bytes
    nonce: bytes
    ciphertext: bytes

def seal_message(recipient: str, message: bytes) -> tuple[Envelope, bytes]:
    # (데모) 세션 키 매번 생성 - 실제는 KMS에서 세션 키 래핑 등 사용
    key = AESGCM.generate_key(bit_length=256)
    nonce = os.urandom(12)
    aad = f"v=1,recipient={recipient}".encode()
    aes = AESGCM(key)
    ct = aes.encrypt(nonce, message, aad)
    return Envelope(1, recipient, aad, nonce, ct), key

def open_message(env: Envelope, key: bytes) -> bytes:
    aes = AESGCM(key)
    return aes.decrypt(env.nonce, env.ciphertext, env.aad)

env, key = seal_message("alice", b"meet at 10:00")
logging.info("envelope(meta only): %s", {
    "version": env.version,
    "recipient": env.recipient,
    "aad": env.aad.decode(),
    "nonce_b64": base64.b64encode(env.nonce).decode(),
    "ciphertext_len": len(env.ciphertext),
})

pt = open_message(env, key)
print("복호:", pt)
```

**정책 포인트**
- 키는 **장기 저장하지 않음**(예: 세션키라 가정). 장기 비밀은 KMS/HSM에.
- **AAD**에 라우팅/버전/수신자 식별자 포함 → 위변조 즉시 검출.
- **로그**에는 키·평문·암호문 본문 **미기록** (길이·메타만).

---

## 1.15 요약 카드

- **보안 목표**: 기밀성·무결성·인증·부인방지
- **공격자 모델**: CPA/CCA, 적응적·사이드채널·화이트박스 고려
- **보안 정의**: IND-CPA/IND-CCA, INT-CTXT, SUF-CMA
- **좋은 암호 구조**: 혼돈(S-box) + 확산(P-layer)
- **원리**: Kerckhoffs — 알고리즘 공개, **키만 비밀**
- **실무 규칙**: **AEAD 우선**, Nonce 재사용 금지, KDF(Argon2id), 상수시간 비교, 키 수명주기, 로깅 최소화

---

## 1.16 연습문제 (자기점검)

1) **정의 퀴즈**: IND-CPA와 IND-CCA의 차이를 “오라클”의 관점에서 서술하라.
2) **적용**: JWT를 사용할 때 “무결성”이 왜 핵심인지, 그리고 어떤 파라미터가 필수인지 정리하라.
3) **설계**: 다중 인스턴스 웹서버에서 GCM Nonce 충돌을 방지하는 두 가지 전략을 제안하라(난수, 카운터, Prefix 등).
4) **분석**: CBC + “복호 에러 메시지가 다르면” 왜 CCA에 약해지는지 시나리오로 설명하라.
5) **코드리뷰**: 비밀번호 저장에 bcrypt(salt, cost=10)를 쓰는 코드가 있다. Argon2id로 마이그레이션 시 **호환성**을 어떻게 확보할지 제안하라.
