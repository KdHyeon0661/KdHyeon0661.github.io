---
layout: post
title: 컴퓨터시스템 - 실행 가능한 목적 파일
date: 2025-08-11 16:20:23 +0900
category: 컴퓨터시스템
---
# 실행 가능한 목적 파일(Executable Object File)

## 0. 무엇을 알게 되는가

- **ELF 실행 파일**은 **ELF 헤더 + 프로그램 헤더(세그먼트) + 섹션들**로 구성되고, 커널은 **프로그램 헤더(PT_* )**를 기준으로 메모리에 매핑한다.  
- **ET_EXEC(비PIE)** 와 **ET_DYN(PIE)** 의 차이, **PT_INTERP**(동적 로더), **PT_GNU_RELRO/STACK/TLS**, **GOT/PLT**의 역할을 이해한다.  
- **ASLR/PIE/RELRO/NX/CET** 등 2025년 기준 기본 하드닝을 빌드 플래그로 넣는다.  
- `readelf/objdump/ldd/LD_DEBUG` 로 **실행 파일의 내부/로딩 과정을 재현하며 검증**한다.

---

## 1. 개념과 생성 흐름 — 소스에서 실행 파일까지

### 1.1 파이프라인(짧은 복습)
```
C 소스 ──(전처리)──▶ .i ──(컴파일)──▶ .s ──(어셈블)──▶ .o(ET_REL)
        └────────────────(링 크)────────────────────────▶ a.out(ET_EXEC/ET_DYN)
```

- `.o`(ET_REL)는 **주소가 미정**이므로 **재배치 엔트리**를 가진다.  
- **링커**가 여러 `.o`와 라이브러리(.a/.so)에서 **심볼 해석 + 재배치**를 수행해 **실행 가능한 목적 파일**을 만든다.

### 1.2 정적 vs 동적 vs PIE
- **정적 실행 파일(PT_INTERP 없음)**: 모든 코드가 실행 파일에 포함, 로더 생략.  
- **동적 실행 파일(PT_INTERP=ld.so)**: 공유 라이브러리 의존, 실행 시 ld.so가 로딩/재배치.  
- **PIE(ET_DYN)**: 실행 파일 자체가 **위치 독립** → **ASLR** 적용폭↑(권장).

---

## 2. ELF 실행 파일의 큰 그림

```
┌────────────────────────────────────────────────────────┐
│ ELF Header                                             │ e_ident/e_type/e_entry/e_phoff/…
├────────────────────────────────────────────────────────┤
│ Program Header Table (for loader)                      │ PT_LOAD/PT_INTERP/PT_DYNAMIC/…
├────────────────────────────────────────────────────────┤
│ Segment payloads (일반적으로 파일 중간~말미)           │ .text/.rodata/.data/.bss 등 대응
├────────────────────────────────────────────────────────┤
│ Section Header Table (for linkers/debuggers)           │ .symtab/.strtab/.shstrtab/.debug* …
└────────────────────────────────────────────────────────┘
```

- **커널 로더**는 **프로그램 헤더(PT_*)** 를 읽어 **세그먼트 매핑**을 수행한다.  
- **섹션 헤더**는 주로 **링커/디버거** 용(실행 때 커널은 보통 보지 않는다).

---

## 3. ELF 헤더·프로그램 헤더·섹션 — 필드와 의미

### 3.1 ELF 헤더(요점)
| 필드 | 설명 |
|---|---|
| `e_ident` | 매직(0x7F 'E' 'L' 'F'), 클래스(ELF64), 엔디안 |
| `e_type`  | ET_EXEC(비PIE), ET_DYN(PIE/DSO), ET_REL(.o) |
| `e_machine` | 아키텍처(x86-64 등) |
| `e_entry` | **진입점**(일반적으로 `_start`) |
| `e_phoff`/`e_phnum` | **프로그램 헤더 테이블** 위치/개수 |
| `e_shoff`/`e_shnum` | 섹션 헤더 테이블 위치/개수 |

### 3.2 프로그램 헤더(로더가 보는 표)
| 타입 | 의미 |
|---|---|
| **PT_LOAD** | 파일 일부를 메모리에 매핑(코드/데이터/BSS) |
| **PT_INTERP** | 동적 로더 경로(예: `/lib64/ld-linux-x86-64.so.2`) |
| **PT_DYNAMIC** | `.dynamic`(DT_NEEDED/DT_RPATH/DT_GNU_HASH…) |
| **PT_GNU_STACK** | 스택 권한(실행 금지 여부) |
| **PT_GNU_RELRO** | 재배치 후 읽기 전용으로 봉인할 영역 |
| **PT_TLS** | TLS 초기 템플릿(스레드 로컬 초기 데이터) |

**페이지 정렬 규칙**(파일 오프셋과 가상주소의 페이지 오프셋은 동일해야 함):
$$
(p\_offset \bmod P) = (p\_vaddr \bmod P),\quad P=\text{page size}
$$

### 3.3 섹션(링커/디버거 시각)
| 섹션 | 역할 |
|---|---|
| `.text` | 기계어 코드 |
| `.rodata` | 읽기 전용 상수(문자열 리터럴 포함) |
| `.data` | 초기화 전역/정적 |
| `.bss` | 0 초기화 전역/정적(파일 크기에 미반영) |
| `.symtab`/`.dynsym` | 정적/동적 심볼 테이블 |
| `.eh_frame(_hdr)` | 예외 언와인딩 메타 |
| `.init_array`/`.fini_array` | 전역 생성자/파괴자 |
| `.debug_*` | DWARF 디버그 정보(실행엔 불필요) |

---

## 4. 커널의 로딩(요약) — execve() 이후 무슨 일이

1. **ELF 검사**: 매직·아키·권한 검사.  
2. **PT_LOAD 세그먼트 매핑**:  
   - `.text/.rodata` → `RX`(읽기/실행), **공유 파일 페이지**  
   - `.data` → `RW`(읽기/쓰기), 쓰기 시 **CoW**  
   - `.bss` → **익명(zerofill)**  
3. **스택/auxv/argv/envp** 구성, `PT_GNU_STACK`로 스택 실행권 제어.  
4. **PT_INTERP 처리**: 있으면 ld.so 매핑 후 **제어를 ld.so로**.  
5. 없으면(정적 링크) 바로 `e_entry`로 점프(보통 `_start`).

---

## 5. 동적 링크(개요) — PLT/GOT/재배치/Lazy 바인딩

- 실행 파일에 `PT_INTERP`가 있으면 **ld.so**가 다음을 수행:
  1) `DT_NEEDED`로 공유 라이브러리 그래프 탐색·매핑  
  2) **재배치**(REL/RELA) 수행: GOT/데이터 주소 패치  
  3) **PLT/GOT** 구성: Lazy 모드에선 **첫 호출 때** 바인딩  
  4) `.init_array`/TLS 초기화 후 `_start`로 점프

- **Eager 바인딩**: `LD_BIND_NOW=1` 또는 `-Wl,-z,now`  
- **RELRO**: 재배치 후 **읽기 전용**으로 봉인(Full: Eager와 결합)

---

## 6. 실행 파일과 재배치 — 정적/동적/PIE

- **정적**: 모든 심볼이 링크 시 확정 → 실행 시 재배치 거의 없음(성능 예측성↑, 크기↑).  
- **동적**: 일부 심볼을 실행 시점에 해석 → GOT/PLT·재배치 필요.  
- **PIE(ET_DYN)**: 베이스 주소가 **무작위(ASLR)** → 모든 참조가 **상대/간접**으로 설계됨.

---

## 7. 실전 예제 — “같은 코드, 다른 빌드”

### 7.1 C 소스
```c
// main.c
#include <stdio.h>

int x = 42;

int main(void) {
    printf("x = %d\n", x);
    return 0;
}
```

### 7.2 빌드/관찰
```bash
# (A) 기본(대개 동적, 배포 환경 따라 PIE가 기본일 수 있음)
gcc -O2 main.c -o app
file app
readelf -h app | egrep 'Type|Entry'
readelf -l app | egrep 'INTERP|GNU_STACK|GNU_RELRO'
ldd app

# (B) 정적(동적 로더 생략)
gcc -O2 -static main.c -o app.static
file app.static
ldd app.static   # "not a dynamic executable" 기대

# (C) 명시적 PIE+하드닝
gcc -O2 -fpie -pie -Wl,-z,relro,-z,now -Wl,--as-needed main.c -o app.hard
checksec --file=app.hard 2>/dev/null || true
```

### 7.3 디스어셈블·심볼·동적 항목
```bash
objdump -d app | less
readelf -dW app | less      # DT_NEEDED/RUNPATH/GNU_HASH 등
objdump -R app | less       # 재배치 항목(GLOB_DAT/JUMP_SLOT 등)
```

---

## 8. 진입점과 C 런타임 — `_start`는 무엇을 하나

- ELF의 `e_entry`는 보통 링커 스크립트가 잡아준 **`_start`** 를 가리킨다.  
- `_start`는 스택에서 `argc/argv/envp/auxv` 정리 → **런타임 초기화** → `.init_array` 호출 → `main()` 호출 → 종료 시 `exit()`.  

### 8.1 아주 작은 어셈블리 예(리눅스 x86-64, libc 없이)
```asm
# start.S
# nasm -felf64 start.S && ld -o hello start.o
        global _start
        section .text
_start:
        mov rax, 1          ; write
        mov rdi, 1          ; fd=stdout
        mov rsi, msg
        mov rdx, msg_end - msg
        syscall
        mov rax, 60         ; exit
        xor rdi, rdi
        syscall
section .rodata
msg:    db "hello, elf", 10
msg_end:
```

---

## 9. 메모리 매핑과 정렬 — 수식으로 보는 규칙

세그먼트 매핑 시 파일 오프셋 `p_offset`과 가상주소 `p_vaddr`는 **페이지 오프셋**이 같아야 한다:

$$
(p\_offset \bmod P) = (p\_vaddr \bmod P)
$$

메모리에 반영할 크기 `p_memsz`와 파일에서 읽을 크기 `p_filesz`가 다를 수 있다(뒤쪽 초과분은 **BSS**로 0 채움):

$$
\text{BSS size} = p\_{memsz} - p\_{filesz} \quad (\ge 0)
$$

---

## 10. 보안·신뢰성 플래그(2025 권장 세트)

- **PIE/ASLR**: `-fpie -pie`  
- **RELRO**: `-Wl,-z,relro,-z,now` (Full RELRO)  
- **NX 스택**: 기본(PT_GNU_STACK로 통제), 필요 시 `-z noexecstack`  
- **스택 카나리**: `-fstack-protector-strong`  
- **FORTIFY**: `-D_FORTIFY_SOURCE=3 -O2`  
- **CET(가능 시)**: 최신 툴체인/커널 설정 필요(IBT/SHSTK)  
- **불필요 의존 제거**: `-Wl,--as-needed`  
- **해시**: `-Wl,--hash-style=gnu` (심볼 탐색 성능)

샘플:
```bash
CFLAGS="-O2 -fpie -fstack-protector-strong -D_FORTIFY_SOURCE=3"
LDFLAGS="-pie -Wl,-z,relro,-z,now -Wl,--as-needed -Wl,--hash-style=gnu"
gcc $CFLAGS main.c $LDFLAGS -o app.safe
```

---

## 11. 최적화·크기 관리 — 실행 파일 수준 실무 팁

- **죽은 섹션 제거**: `-ffunction-sections -fdata-sections` + `-Wl,--gc-sections`  
- **LTO/ThinLTO**: 링크 타임 인라이닝·제거 최적화  
- **strip**(주의): 배포 크기↓, 디버깅은 `.debug`로 분리 유지
  ```bash
  objcopy --only-keep-debug app app.debug
  strip --strip-unneeded app
  objcopy --add-gnu-debuglink=app.debug app
  ```

---

## 12. 디버깅·관찰 — “안을 들여다보는” 표준 도구

```bash
# 정체성/헤더
file app
readelf -hW app
readelf -lW app | egrep 'INTERP|GNU_STACK|GNU_RELRO|TLS'

# 동적 속성·의존
readelf -dW app
ldd app
patchelf --print-rpath app 2>/dev/null || true

# 재배치/PLT/GOT
objdump -R app
objdump -d app | less
objdump -x app | less

# 로딩 로그(동적)
LD_DEBUG=libs,reloc,bindings ./app 2>&1 | less
```

---

## 13. 실행 시 스택/auxv/vDSO — 로더가 남겨주는 힌트

- **auxv(AT_*)**: `AT_ENTRY`, `AT_PHDR`, `AT_PAGESZ`, `AT_RANDOM`, `AT_SECURE`, `AT_SYSINFO_EHDR(vDSO)` 등  
- **vDSO**: `clock_gettime()` 같은 콜을 **사용자 공간**에서 가속(시스콜 절약)

auxv 읽기 예:
```c
#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <elf.h>

int main(){
    int fd=open("/proc/self/auxv",O_RDONLY);
    Elf64_auxv_t a;
    while(read(fd,&a,sizeof a)==sizeof a && a.a_type)
        printf("AT_%lu = 0x%lx\n", (unsigned long)a.a_type, (unsigned long)a.a_un.a_val);
    return 0;
}
```

---

## 14. 실패·지연의 전형 사례와 처방

증상 | 진단 | 원인 | 해결
---|---|---|---
`error while loading shared libraries` | `LD_DEBUG=libs` | `DT_NEEDED`의 .so 경로 불일치 | `RUNPATH=$ORIGIN/lib` 설정 or `patchelf --set-rpath`
첫 호출 때 지연 스파이크 | `LD_DEBUG=bindings` | **Lazy 바인딩** | `LD_BIND_NOW=1` or `-Wl,-z,now`
보안 검사 취약 | `readelf -lW`, `checksec` | Partial RELRO/NX 미설정 | **Full RELRO**, `-z noexecstack`, PIE
PIE 미적용 | `file app` | ET_EXEC | `-fpie -pie` 로 재빌드
컨테이너 런타임 오류 | `ldd`, `strace -e file` | 필수 .so 누락 | 이미지에 의존성 포함, RPATH 고정

---

## 15. (짧게) PE/COFF·Mach-O 비교 포인트

항목 | ELF | PE/COFF(Windows) | Mach-O(macOS)
---|---|---|---
기본 단위 | 섹션/세그먼트 분리 | 섹션(이미지베이스) | LC(Load Command) 기반
로더 경로 | PT_INTERP | Import Table + loader | LC_LOAD_DYLIB/LC_RPATH
ASLR/PIE | ET_DYN(PIE) | /DYNAMICBASE, Reloc 필요 | PIE 기본(대부분)
RPATH | RUNPATH/RPATH | SxS/매니페스트/디렉티브 | @rpath/@loader_path
서명 | 선택(플랫폼마다) | Authenticode | Code Signing(강제)

---

## 16. 미니 랩 — “생성→검사→하드닝→관찰” 한 번에

```bash
# 1. 기본 빌드
gcc -O2 main.c -o app
file app; readelf -h app | egrep 'Type|Entry'; ldd app

# 2. PIE+Full RELRO 하드닝
gcc -O2 -fpie -pie -Wl,-z,relro,-z,now main.c -o app.hard
readelf -lW app.hard | egrep 'GNU_RELRO|GNU_STACK|INTERP'
checksec --file=app.hard 2>/dev/null || true

# 3. 내부 보기
readelf -dW app.hard | less
objdump -R app.hard | less

# 4. 런타임 로깅
LD_DEBUG=libs,reloc,bindings ./app.hard 2>&1 | less
```

---

## 17. 수식 코너 — “스타트업 시간” 구성 요인(개념)

동적 실행 파일의 초기 실행 지연을 아주 거칠게 적으면:

$$
T_{\text{start}} \approx T_{\text{mmap(DSO)}} + T_{\text{reloc}} +
\begin{cases}
T_{\text{first\_call\_bind}} & \text{(Lazy)} \\
T_{\text{all\_bind}} & \text{(Eager)}
\end{cases}
+ T_{\text{init\_array}}
$$

**개선 포인트**: DSO 수/깊이 축소, `--as-needed`, GNU 해시, Full RELRO+Eager의 보안/성능 절충, I/O 단축.

---

## 18. 체크리스트 — 배포 전 마지막 점검

- [ ] `file`, `readelf -hW`: **ET_DYN(PIE)** 여부, 아키/엔디안 확인  
- [ ] `readelf -lW`: `PT_INTERP/PT_GNU_STACK/PT_GNU_RELRO/PT_TLS`  
- [ ] `readelf -dW`: `DT_NEEDED/RUNPATH` 의도대로?  
- [ ] `ldd`: 런타임 의존 경로가 **$ORIGIN** 계열로 고정?  
- [ ] **보안**: `-fstack-protector-strong`, `-D_FORTIFY_SOURCE=3`, `-z relro,-z now`, **NX**, **PIE**  
- [ ] **크기/성능**: `--gc-sections`, LTO/ThinLTO, `--as-needed`  
- [ ] **디버깅**: `.debug` 분리 + `--add-gnu-debuglink`  
- [ ] 문제 시 `LD_DEBUG=libs,reloc,bindings` 로더 로그로 확인

---

## 19. 결론

**실행 가능한 목적 파일**을 제대로 이해한다는 것은,
- **링커 산출물(ELF)의 구조**를 읽고,
- **커널/동적 로더가 무엇을 왜 매핑/재배치/바인딩하는지**를 설명하며,
- **보안/성능 플래그**로 하드닝과 최적화를 적용하고,
- **툴로 관찰·검증**해 재현 가능한 방식으로 문제를 해결하는 일이다.

이 문서의 예제 명령과 플래그, 체크리스트를 **기본 템플릿**으로 삼아,  
프로젝트의 빌드 시스템(CMake/Meson/Make)에 **PIE+RELRO+NX+FORTIFY**를 표준화하라.  
그러면 “왜 실행이 실패/느림/위험한가?”에 대해 **근거 있는 답**을 낼 수 있다.