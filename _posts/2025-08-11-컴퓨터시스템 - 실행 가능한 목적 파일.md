---
layout: post
title: 컴퓨터시스템 - 실행 가능한 목적 파일
date: 2025-08-11 16:20:23 +0900
category: 컴퓨터시스템
---
# 실행 가능한 목적 파일(Executable Object File)

**실행 가능한 목적 파일**은 CPU가 직접 실행할 수 있는 **완전한 기계어 코드**와 필요한 모든 메타데이터를 포함하는 파일이다.  
ELF(Executable and Linkable Format), PE(Portable Executable), Mach-O 등이 대표적인 형식이며, CS:APP에서 주로 다루는 것은 **ELF**다.

---

## 1. 개념과 생성 과정

1. **소스 코드 작성**
   - 예: `main.c`
2. **컴파일 → 어셈블**
   - `.o` 목적 파일 생성
3. **정적/동적 링크**
   - 링커가 여러 목적 파일과 라이브러리를 결합
   - 모든 심볼이 해석되고 재배치 완료
4. **실행 가능한 목적 파일 생성**
   - 예: `a.out` 또는 지정한 실행 파일명
   - 운영체제 로더가 바로 메모리에 적재하여 실행 가능

---

## 2. ELF 실행 파일 구조

ELF 실행 파일은 크게 **ELF 헤더**, **프로그램 헤더 테이블**, **섹션 데이터**, **섹션 헤더 테이블**로 구성된다.

### 2.1 ELF 헤더
- 파일 형식 정보, 아키텍처, 엔디안, 진입점 주소(entry point) 등을 저장.
- 운영체제 로더가 파일을 분석할 때 가장 먼저 읽는 부분.

| 필드 | 설명 |
|------|------|
| e_ident | 매직 넘버, 클래스(32/64비트), 엔디안 |
| e_type  | 실행 파일, 재배치 가능, 공유 객체 구분 |
| e_entry | 프로그램 시작 주소(진입점) |
| e_phoff | 프로그램 헤더 테이블 오프셋 |
| e_shoff | 섹션 헤더 테이블 오프셋 |

---

### 2.2 프로그램 헤더 테이블 (Program Header Table)
- 로더가 **어떤 세그먼트를 메모리에 적재할지**를 지정.
- 각 엔트리는 세그먼트의 파일 오프셋, 메모리 주소, 크기, 권한(R/W/X) 포함.

세그먼트 유형:
- **PT_LOAD** : 실행 시 메모리에 로드되는 코드/데이터
- **PT_DYNAMIC** : 동적 링크 정보
- **PT_INTERP** : 인터프리터(동적 로더) 경로
- **PT_NOTE**, **PT_GNU_STACK** 등

---

### 2.3 주요 세그먼트
- **코드 세그먼트(.text)** : CPU가 실행할 기계어 명령 저장 (읽기/실행)
- **데이터 세그먼트(.data, .rodata)** : 전역변수, 상수 데이터 (읽기/쓰기 또는 읽기 전용)
- **BSS 세그먼트(.bss)** : 초기화되지 않은 전역변수, 실행 시 0으로 채움
- **힙/스택** : 실행 시 동적으로 할당됨(파일에는 없음)

---

### 2.4 섹션 헤더 테이블
- 링커와 디버거용 메타데이터.
- `.symtab` (심볼 테이블), `.strtab` (문자열 테이블), `.debug` 등.

---

## 3. 실행 가능한 목적 파일의 로딩 과정

1. **운영체제 커널이 exec() 호출 처리**
2. ELF 헤더를 읽어 아키텍처, 진입점 주소 확인
3. 프로그램 헤더 테이블을 순회하며 각 세그먼트를 메모리에 매핑
4. 동적 링크 필요 시 `ld.so` 실행하여 필요한 .so 파일 로드 및 재배치 처리
5. 스택 초기화(인자, 환경 변수, 보안 랜덤 값)
6. 진입점으로 점프 → `main()` 호출

---

## 4. 실행 파일과 재배치

- 정적 링크 실행 파일: 모든 심볼이 확정 → 실행 시 재배치 없음
- 동적 링크 실행 파일: 일부 심볼 주소가 실행 시점에 결정 → GOT/PLT 활용
- PIE(Position Independent Executable): 실행 시 베이스 주소 무작위(ASLR) 지원 → 모든 참조가 상대 주소 기반

---

## 5. 예제

### 5.1 C 코드

```c
#include <stdio.h>

int x = 42;

int main(void) {
    printf("x = %d\n", x);
    return 0;
}
```

```bash
gcc -o test test.c
readelf -h test      # ELF 헤더 확인
readelf -l test      # 프로그램 헤더 확인
objdump -d test      # 기계어 디스어셈블
```

---

### 5.2 readelf -h 출력 예시(일부)
```
ELF Header:
  Magic:   7f 45 4c 46 ...
  Class:                             ELF64
  Data:                              2's complement, little endian
  Type:                              EXEC (Executable file)
  Entry point address:               0x401040
```

---

## 6. 실행 파일 최적화 고려사항
- 불필요한 심볼 제거(`strip`) → 크기 감소
- 정적 링크 vs 동적 링크 트레이드오프
- PIE 사용 여부(보안 vs 성능)
- 세그먼트 정렬, 페이지 권한 최소화(보안)

---

## 7. 결론
실행 가능한 목적 파일은 **소스 코드가 CPU에서 바로 실행 가능한 형태로 완전히 변환된 산출물**이다.  
그 내부 구조를 이해하면 로더 동작, 성능 최적화, 보안(ASLR, NX bit) 등 시스템 프로그래밍의 기초를 탄탄히 다질 수 있다.