---
layout: post
title: 운영체제 - 데드락 (3)
date: 2025-10-20 23:30:23 +0900
category: 운영체제
---
# Deadlock **Avoidance** • **Detection** • **Recovery**

## Deadlock Avoidance (회피)

> **핵심 철학**: “**안전 상태(safe state)**만 허용하자.”
> 요청이 올 때마다 “그 요청을 수락해도 시스템에 **안전 실행 순서(safe sequence)** 가 남는가?”를 검사한다.

### 안전/불안전 상태 개념

- **안전 상태**: 프로세스들을 어떤 순서로든 **모두 완료**할 수 있는 순열 \( \langle P_{i_1},\dots,P_{i_n}\rangle \) 이 존재.
- **불안전 상태**: 당장 데드락은 아니지만, 특정 요청 시퀀스에서 **데드락으로 갈 수 있음**.

안전성의 직관적 정의:

$$
\exists \ \text{순열 } \langle P_{i_1},\dots,P_{i_n}\rangle \ \text{s.t.} \
\forall k,\ \text{Avail}_k \ge \text{Need}_{i_k} \Rightarrow
\text{Avail}_{k+1} = \text{Avail}_k + \text{Alloc}_{i_k}.
$$

여기서
- \( \text{Need} = \text{Max} - \text{Allocation} \)
- \( \text{Avail} \) 은 현재 가용 벡터

---

### Banker’s Algorithm (다중 인스턴스 자원 회피)

**가정**
1) 각 프로세스 \(P_i\)는 자원 타입별 **최대 필요량** \(Max[i]\)을 신고.
2) 시스템은 요청 \(Request[i]\)이 도착할 때 **가상 할당** 후 **안전성 검사**를 통과해야 승인.

**요청 승인 규칙**
1) $$Request[i] \le Need[i] = Max[i]-Allocation[i]$$
2) $$Request[i] \le Available$$
3) **가상 할당** 후 `is_safe()` 가 **True**이면 승인, 아니면 보류.

#### 파이썬 구현(요청 승인 + 안전성 검사)

```python
# banker_full.py

from typing import List, Tuple

def is_safe(available: List[int], maxm: List[List[int]], alloc: List[List[int]]) -> Tuple[bool, List[int]]:
    n, m = len(alloc), len(available)
    need = [[maxm[i][j] - alloc[i][j] for j in range(m)] for i in range(n)]
    work = available[:]
    finish = [False]*n
    order = []

    while True:
        progressed = False
        for i in range(n):
            if not finish[i] and all(need[i][j] <= work[j] for j in range(m)):
                # i 완료 가정 → 자원 회수
                for j in range(m): work[j] += alloc[i][j]
                finish[i] = True
                order.append(i)
                progressed = True
        if not progressed: break
    return (all(finish), order)

def request_grant(
    available: List[int], maxm: List[List[int]], alloc: List[List[int]],
    pid: int, req: List[int]
) -> Tuple[bool, str | List[int]]:
    m = len(available)
    need = [maxm[pid][j] - alloc[pid][j] for j in range(m)]
    if any(req[j] > need[j] for j in range(m)):
        return False, "exceeds need"
    if any(req[j] > available[j] for j in range(m)):
        return False, "insufficient available"

    # 가상 할당
    avail2 = available[:]
    alloc2 = [row[:] for row in alloc]
    for j in range(m):
        avail2[j]  -= req[j]
        alloc2[pid][j] += req[j]

    safe, order = is_safe(avail2, maxm, alloc2)
    return (True, order) if safe else (False, "unsafe (no safe sequence)")

if __name__ == "__main__":
    available = [3, 3, 2]
    maxm = [
        [7, 5, 3],
        [3, 2, 2],
        [9, 0, 2],
        [2, 2, 2],
        [4, 3, 3],
    ]
    alloc = [
        [0, 1, 0],
        [2, 0, 0],
        [3, 0, 2],
        [2, 1, 1],
        [0, 0, 2],
    ]
    print(is_safe(available, maxm, alloc))  # (True, [1, 3, 4, 0, 2]) 예시
    ok, info = request_grant(available, maxm, alloc, 1, [1,0,2])
    print(ok, info)
```

**복잡도**: \(O(n^2 m)\) 정도(최대 각 프로세스마다 한 번씩 스캔).

**장단점**
- 장점: 데드락 **완전 배제**.
- 단점: **최대 필요량** 사전 신고 필요, 보수적 승인으로 **병행성↓**, 동적/미지의 자원엔 불리.

---

### Claim Graph (단일 인스턴스 자원 회피)

- **RAG(Resource Allocation Graph)**에 **Claim edge**(점선) 사용.
- 실행 중 요청이 들어오면 **Claim edge → Request edge** 변환을 *가정*하고 **사이클이 생기지 않으면** 승인.
- 단일 인스턴스 자원 타입에 유용.

**알고리즘 요지**
1) \(P_i \to R_j\) 요청이 들어오면 해당 간선을 **Claim → Request**로 바꿨다고 가정.
2) 이때 **사이클이 생기면** 보류, 아니면 승인.

```python
# claim_graph_cycle.py — 단일 인스턴스 자원 회피(그래프 사이클 검사)

def makes_cycle_after_request(adj, pi, rj):
    # adj: dict node -> neighbors, nodes include processes "Pi" and resources "Rj"
    # 가정: Pi -> Rj 추가 후 사이클 검사
    from collections import defaultdict, deque
    g = {u:set(v) for u,v in adj.items()}
    g.setdefault(pi,set()).add(rj)
    # DFS cycle
    seen, stack = set(), set()
    def dfs(u):
        seen.add(u); stack.add(u)
        for v in g.get(u,()):
            if v not in seen:
                if dfs(v): return True
            elif v in stack:
                return True
        stack.remove(u); return False
    return any(dfs(u) for u in g)
```

> **주의**: 현실 시스템은 다중 인스턴스가 흔해 **Banker**가 더 일반적이다.

---

### 회피 설계 팁

- “최대 필요량”을 **상한 추정치**로 관리하여 과신고를 억제(팀 룰/자동 점검).
- 요청은 **작게 쪼개지 말고** 의미 있는 묶음으로(회피 검사 횟수 ↓).
- 핵심 서브시스템(결제/원자적 메타데이터 갱신)에만 적용하여 **오버헤드 국소화**.

---

## Deadlock Detection (검출)

> **회피/예방**을 쓰지 않거나, 전체 적용이 비현실적일 때 **주기적으로 검출**하고 **복구**한다.

### 단일 인스턴스 자원(락 등): Wait-For Graph 사이클

- **노드**: 프로세스/스레드
- **간선**: \(P_i \rightarrow P_j\) ( \(P_i\) 가 \(P_j\)가 보유한 자원을 기다림 )
- **사이클 ⇔ 데드락**

```python
# wfg_detect.py — DFS로 사이클 검출

def has_cycle(adj):
    n = len(adj)
    color = {u:0 for u in adj}  # 0=unseen,1=visiting,2=done
    def dfs(u):
        color[u]=1
        for v in adj[u]:
            if color[v]==1: return True
            if color[v]==0 and dfs(v): return True
        color[u]=2; return False
    return any(dfs(u) for u in adj if color[u]==0)

# 예: T1→T2, T2→T3, T3→T1

adj = {"T1":["T2"], "T2":["T3"], "T3":["T1"]}
print("deadlocked?", has_cycle(adj))  # True
```

**운영 적용**
- **C/C++**: 앱 레벨에서 “락 소유자/대기자” 로그를 주기적으로 수집해 그래프 구성.
- **Java**: `ThreadMXBean.findDeadlockedThreads()` 로 JVM 내부 WFG 기반 검출.

```java
// DeadlockCheck.java — JVM에서 교착 스레드 찾기
import java.lang.management.*;
import java.util.Arrays;
public class DeadlockCheck {
  public static void main(String[] a){
    ThreadMXBean mx = ManagementFactory.getThreadMXBean();
    long[] ids = mx.findDeadlockedThreads();
    if(ids!=null){
      ThreadInfo[] infos = mx.getThreadInfo(ids, true, true);
      Arrays.stream(infos).forEach(System.out::println);
    } else {
      System.out.println("No deadlocks.");
    }
  }
}
```

---

### 다중 인스턴스 자원: 행렬 기반 검출(Detection Algorithm)

- **입력 상태**:
  - \(Available[m]\)
  - \(Allocation[n][m]\)
  - \(Request[n][m]\)  *(현재 추가로 필요한 양 — 주의: 회피의 Need와 다름)*

- **검출 절차(요지)**
  1) \(Work \leftarrow Available\), \(Finish[i] \leftarrow (Allocation[i]==0)\)
  2) 어떤 \(i\)가 \(Finish[i]=False\) 이고 \(Request[i] \le Work\) 이면, \(Work \leftarrow Work + Allocation[i]\), \(Finish[i]\leftarrow True\)
  3) 더 이상 진행 불가하면, \(Finish[i]=False\) 인 작업들은 **교착 의심 집합**

```python
# detection_matrix.py — 교착 검출기

def detect(available, allocation, request):
    n, m = len(allocation), len(available)
    work = available[:]
    finish = [all(allocation[i][j]==0 for j in range(m)) for i in range(n)]
    progressed = True
    while progressed:
        progressed = False
        for i in range(n):
            if not finish[i] and all(request[i][j] <= work[j] for j in range(m)):
                # i 완료 가정
                for j in range(m):
                    work[j] += allocation[i][j]
                finish[i] = True
                progressed = True
    deadlocked = [i for i, f in enumerate(finish) if not f]
    return deadlocked

if __name__ == "__main__":
    available=[3,3,2]
    allocation=[[0,1,0],[2,0,0],[3,0,2],[2,1,1],[0,0,2]]
    request   =[[0,0,0],[2,0,2],[0,0,0],[1,0,0],[0,0,0]]
    print(detect(available, allocation, request))  # deadlocked 인덱스 목록
```

**복잡도**: \(O(n^2 m)\). 운영환경에서는 **부분 그래프/슬라이딩 윈도우**로 최적화.

---

### 검출 주기/오버헤드/가시성

- **주기**: 워크로드와 SLO에 따라 **초~분 단위**. 변경/대기 이벤트 기반 트리거 병행.
- **가시성**: 스냅샷에 **스레드 스택**, **락 히스토리**(획득 시각, 보유 시간), **대기열 길이** 포함.
- **안전성**: 스냅샷 생성 자체가 교착을 악화시키지 않도록 **락 없는 계측**(RCU/원자 카운터) 사용.

---

## Recovery from Deadlock (복구)

> 검출 후 **누구를 어떻게 풀어줄 것인가?** — **희생자 선택**, **선점/롤백**, **종료** 전략을 조합한다.

### 희생자 선택(Victim Selection)

**비용 함수 예시**
- \(C = w_1 \cdot \text{진행률 부족} + w_2 \cdot \text{우선순위 역순} + w_3 \cdot \text{보유 자원량} + w_4 \cdot \text{롤백 비용}\)

**정책**
- 동일 희생자 반복 방지(에이징).
- 트랜잭션/작업 단위를 **멱등(idempotent)** 하게 설계해 재시도 비용↓.

```python
# victim_select.py — 간단 비용 기반 희생자 선택

def choose_victim(candidates):
    # candidates: list of dicts {id, progress, priority, held, rollback_cost}
    best = None; best_cost = float('inf')
    for c in candidates:
        cost = (1-c['progress'])*5 + (10-c['priority'])*2 + c['held']*1 + c['rollback_cost']*3
        if cost < best_cost:
            best_cost, best = cost, c
    return best
```

---

### 복구 방법 ① — 프로세스/스레드 종료(Termination)

- **즉시성** 최고, **상태 손실** 위험.
- 안전종료를 위해 **취소 토큰/인터럽트 가능 대기** 제공.

```java
// CancelFriendly.java — 인터럽트 가능 대기 + 중단 가능 락
import java.util.concurrent.locks.*;
class CancelFriendly implements Runnable {
  private final Lock lock = new ReentrantLock();
  private volatile boolean stop = false;
  public void requestStop(){ stop = true; }
  public void run(){
    try{
      while(!stop){
        if(lock.tryLock()){
          try{ /* 짧은 임계구역 */ } finally { lock.unlock(); }
        }
        Thread.sleep(5); // 인터럽트 가능
      }
    } catch (InterruptedException e) {
      // 복구 경로
    }
  }
}
```

---

### & 롤백

- **선점**: 희생자에게서 자원을 회수 → **다른 프로세스 진행** 가능
- **롤백**: 체크포인트로 상태 되돌림 → 자원 일관성 유지

#### 사용자 공간 체크포인트/롤백 미니 프레임워크

```cpp
// tx_checkpoint.hpp — 미니 트랜잭션 로그
#include <vector>
#include <functional>

struct Tx {
  std::vector<std::function<void()>> undo_log;
  template<class F> void record_undo(F f){ undo_log.emplace_back(f); }
  void rollback(){ for(auto it=undo_log.rbegin(); it!=undo_log.rend(); ++it) (*it)(); undo_log.clear(); }
  void commit(){ undo_log.clear(); }
};

// 사용 예: (데드락 검출 시) 희생자 Tx.rollback() 호출
```

#### 희생자에게 **협력적 선점** 요구(타임아웃/tryLock 기반)

```cpp
// cooperative_preemption.cpp — 타임아웃-기반 협력적 선점
#include <mutex>
#include <chrono>
#include <thread>

std::timed_mutex A,B;

bool acquire_pair() {
  using namespace std::chrono_literals;
  if(!A.try_lock_for(10ms)) return false;
  if(!B.try_lock_for(10ms)) { A.unlock(); return false; }
  return true;
}
void worker(){
  while(true){
    if(acquire_pair()){
      // 임계구역
      B.unlock(); A.unlock();
      break;
    }else{
      std::this_thread::sleep_for(1ms); // backoff
    }
  }
}
```

> **의미**: 전통적 락은 선점 불가지만, **시간 제한**과 **재시도 정책**을 추가하면 “사실상 선점”이 가능.

---

### with Ordered Rollback

- 검출된 **WFG 사이클**에서 최소 비용 노드 하나를 선택해 **보유 자원 해제** 후 재시도.
- 데이터 일관성을 위해 **보상 트랜잭션**(compensation) 적용.

```python
# break_cycle.py — 사이클에서 노드 하나 제거

def break_cycle(adj, cost):
    # adj: dict u->list(v), cost: dict u->cost
    # 매우 단순: 사이클 구성원 중 비용 최소 노드 제거
    cyc_nodes = find_one_cycle(adj)  # 구현 생략: DFS로 부모 추적
    victim = min(cyc_nodes, key=lambda u: cost[u])
    # victim 종료/롤백 → 모든 간선 제거
    for u in list(adj):
        adj[u] = [v for v in adj[u] if v != victim]
    adj.pop(victim, None)
    return victim
```

---

### DB·트랜잭션 시스템의 복구

- **검출**: 대기 그래프 / 타임아웃
- **복구**: **트랜잭션 중단(ROLLBACK)**, 로그 기반 **UNDO/REDO**
- **희생자**: 가장 적게 진행된 트랜잭션, 롤백 비용 작은 것 우선
- **멱등성**: 재시도 설계(예: 결제 승인 토큰, 재고 예약 idempotency key)

---

### 운영 체크리스트(검출→복구 체계)

1) **검출 주기**와 **임계 임계치**(대기 시간, 보유 시간, 큐 길이) 정의
2) 검출 시 **스택/락맵/대기열 스냅샷** 자동 수집 → RCA 용이
3) **희생자 정책** 문서화(우선순위/진행률/비용) + 에이징
4) **중단 경로**: 타임아웃/인터럽트 가능 대기/취소 토큰/보상 트랜잭션
5) **SLO 연동**: 복구 시간(RTT), 롤백 성공률, 유실 작업 수를 모니터링
6) **사전 예방**: Ordered locking, 짧은 임계구역, 불변/RCU/락프리 병행

---

## 실습 패키지

### 실습 A — Banker 회피 vs Detection+Recovery 비교

- **워크로드**: 3자원, 5프로세스, 폭주 구간 포함.
- **A안(회피)**: `banker_full.py`로 승인/거부.
- **B안(검출+복구)**: `detection_matrix.py` + `victim_select.py` 로 사이클마다 희생자 종료.
- **평가 지표**: 승인 실패율, 평균 대기(p95/p99), 자원 활용률, 복구 횟수/시간.

### 실습 B — JVM Deadlock 실험 & 자동 해소

1) 의도적 교차 락 코드로 교착 유발.
2) `ThreadMXBean`으로 검출 → **희생자 인터럽트**(`Thread.interrupt()`) + **tryLock 재시도** 경로로 회복.
3) **결과**: 중단/회복 로그와 처리량 영향 측정.

### 실습 C — WFG 기반 사이클 브레이커(서비스 공용 라이브러리)

- 공용 모듈에 **락 대기/보유 이벤트** 훅을 넣어 **WFG**를 유지.
- 주기적으로 **사이클 탐색** → **정책 기반 희생자** 중단.
- **지표**: 한 달간 평균 교착 회피 건수, 오탐/미탐, 자동 복구 성공률.

---

## 한눈 요약

- **8.6 회피(Avoidance)**: **안전 상태만** 허용(Banker/Claim). 데드락 0이지만 **보수적**이며 최대 필요량 정보가 필요.
- **8.7 검출(Detection)**: 단일 인스턴스는 **WFG 사이클**, 다중 인스턴스는 **행렬 검출**. 주기·오버헤드·가시성이 관건.
- **8.8 복구(Recovery)**: **희생자 선택 → 종료/선점/롤백**으로 사이클을 깨고 진행 재개. 멱등/보상 트랜잭션이 안정성의 핵심.

> 실무의 정답은 **혼합 전략**:
> 핵심 경로엔 **예방/회피**, 전체 시스템엔 **검출+복구**, 그리고 **설계상 직렬 구간 단축(락 분할/불변/락프리)** 이 병행되어야 한다.
