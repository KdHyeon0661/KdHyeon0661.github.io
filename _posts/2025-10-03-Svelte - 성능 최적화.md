---
layout: post
title: Svelte - 성능 최적화
date: 2025-10-03 18:30:23 +0900
category: Svelte
---
# 성능 최적화

**번들 분할/코드 스플리팅/지연 로딩 · 이미지 최적화(포맷/리사이즈)· 폰트 전략 · SSR 비용/하이드레이션 · 부분 하이드레이션 논의 · Lighthouse & Web Vitals 모니터링**

> 이 장은 **Svelte/SvelteKit** 앱의 실전 성능 최적화 레퍼런스다.
> - **번들 분할**로 초기 전송을 최소화하고, **지연 로딩**으로 사용자 행동과 리소스를 정렬
> - **이미지 & 폰트**가 LCP/CLS에 미치는 영향과 대응
> - **SSR 비용/하이드레이션**을 줄이는 설계 포인트(섬/지연 상호작용 패턴)
> - **Lighthouse/Web Vitals**를 CI/운영에 연결해 지속 모니터링

---

## 번들 분할 · 코드 스플리팅 · 지연 로딩

### 라우트 단위 코드 스플리팅(기본)

SvelteKit는 **라우트 파일 단위**로 자동 코드 스플리팅 된다. 라우트가 나뉘어 있으면 대부분 이미 분할되고, 공통 의존성은 **shared chunk**로 올라간다.

**폴더 구성**
```
src/routes/
  +layout.svelte        # 공통 셸(헤더/푸터) — shared chunk
  marketing/            # 마케팅 라우트
    +page.svelte
  app/                  # 앱(로그인 필요)
    +layout.svelte
    dashboard/
      +page.svelte
    reports/
      +page.svelte
```

> 자동 분할은 기본이지만, **큰 서드파티**(예: charting, editor, map)는 **동적 import**로 **지연 로딩**을 더해야 한다.

---

### 컴포넌트 지연 로딩(동적 import)

큰 라이브러리(차트/맵/리치에디터 등)는 사용자에게 **정말 필요해질 때** 로드.

```svelte
<!-- src/lib/lazy/ChartHost.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  let ChartComp: any = null;
  export let data: any[];

  // 1) 첫 렌더엔 비어있고
  onMount(async () => {
    // 2) 상호작용이 생길 때/가시화될 때 불러오기(단순화: onMount에 바로)
    const mod = await import('./BigChart.svelte'); // 분할 청크 생성
    ChartComp = mod.default;
  });
</script>

{#if ChartComp}
  <svelte:component this={ChartComp} {data}/>
{:else}
  <!-- 스켈레톤/플레이스홀더 -->
  <div class="skeleton h-48 rounded-xl" aria-hidden="true"/>
{/if}
```

> **고급**: `IntersectionObserver`로 **뷰포트 진입 시**만 불러오면 더 좋다.

```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  let ref: HTMLElement; let visible = false;
  let ChartComp: any = null; export let data: any[];

  onMount(() => {
    const io = new IntersectionObserver(async ([e]) => {
      if (e.isIntersecting && !ChartComp) {
        ChartComp = (await import('./BigChart.svelte')).default;
        visible = true;
        io.disconnect();
      }
    }, { rootMargin: '200px' }); // 미리 로드
    io.observe(ref);
    return () => io.disconnect();
  });
</script>

<div bind:this={ref}>
  {#if ChartComp && visible}
    <svelte:component this={ChartComp} {data}/>
  {:else}
    <div class="skeleton h-48 rounded-xl"/>
  {/if}
</div>
```

---

### 클라이언트 전용 구간(SSR 차단) — 대시보드/에디터

서버에서 렌더 필요가 없는 영역은 **SSR을 끄고 CSR-only**로 만들어 초기 비용 절감.

```ts
// src/routes/app/+layout.ts
export const ssr = false; // /app 이하 SPA
```

> 앱 셸을 SPA로 돌리고 마케팅/블로그는 SSR/SSG 조합 → **하이브리드**가 가장 실용적.

---

### 선택적 상호작용(지연 하이드레이션 유사 패턴)

**초기 렌더는 순수 HTML**, 상호작용은 **가시화/유휴 시간**에 로드해 부하를 늦춘다.

```svelte
<script>
  import { onMount } from 'svelte';
  export let enhanceWhen: 'visible' | 'idle' = 'visible';
  let Interactive: any = null, host: HTMLElement;

  onMount(async () => {
    if (enhanceWhen === 'idle' && 'requestIdleCallback' in window) {
      (window as any).requestIdleCallback(load);
    } else {
      const io = new IntersectionObserver(([e]) => {
        if (e.isIntersecting) { load(); io.disconnect(); }
      }, { rootMargin: '200px' });
      io.observe(host);
    }
  });

  async function load() { Interactive = (await import('./Interactive.svelte')).default; }
</script>

<div bind:this={host}>
  {#if Interactive}<svelte:component this={Interactive}/>
  {:else}<div class="placeholder">정적 컨텐츠</div>{/if}
</div>
```

> 이 패턴은 흔히 **부분 하이드레이션**과 유사한 **섬(“islands”) 스타일**을 수동 구현한다.

---

### 중복 의존성 & 트리셰이킹

- **라이브러리 중복 회피**: moment 대신 dayjs/luxon, lodash는 per-method import
- **트리셰이킹 친화적**: ESM 모듈, sideEffects false
- **아이콘**: 전체 번들 대신 **개별 아이콘 import** 또는 **SVG inline**

```ts
// 나쁜 예
import _ from 'lodash';   // 전체 번들
// 좋은 예
import debounce from 'lodash/debounce';
```

---

## 이미지 최적화(포맷/리사이즈/전달)

### LCP 이미지 최적화 체크리스트

- **적절한 크기**(srcset/sizes)
- **현대 포맷**(AVIF/WebP)
- **프리로드**(LCP 1개) & **priority 힌트**
- **지연 로딩**(fold 아래)
- **폭/높이 지정**(CLS 방지)

```svelte
<!-- 히어로(LCP 후보): 프리로드 + width/height 명시 -->
<svelte:head>
  <link rel="preload" as="image" href="/hero-1280.avif" imagesrcset="/hero-1280.avif 1280w, /hero-1920.avif 1920w" imagesizes="100vw" />
</svelte:head>

<picture>
  <source srcset="/hero-1280.avif 1280w, /hero-1920.avif 1920w" type="image/avif" sizes="100vw" />
  <source srcset="/hero-1280.webp 1280w, /hero-1920.webp 1920w" type="image/webp" sizes="100vw" />
  <img
    src="/hero-1280.jpg"
    srcset="/hero-1280.jpg 1280w, /hero-1920.jpg 1920w"
    sizes="100vw"
    width="1280" height="720"
    alt="제품 히어로"
    fetchpriority="high" />
</picture>
```

> `fetchpriority="high"`는 LCP 후보에만 신중히 사용.

---

### 목록/카드 썸네일 — `loading="lazy"`

```svelte
{#each products as p}
  <img
    src={p.thumb_320}
    srcset={`${p.thumb_320} 320w, ${p.thumb_640} 640w`}
    sizes="(min-width: 1024px) 320px, 50vw"
    width="320" height="200"
    loading="lazy" decoding="async" alt={p.title}/>
{/each}
```

---

### 서버 변환(Sharp) & 캐시 헤더

```ts
// src/routes/i/[w]/[...path]/+server.ts
import type { RequestHandler } from './$types';
import sharp from 'sharp';
import { readFile } from 'node:fs/promises';

export const GET: RequestHandler = async ({ params, url }) => {
  const w = Math.min( Number(params.w), 1920 );
  const path = params.path; // 원본 경로 매핑
  const buf = await readFile(`static/${path}`);
  const out = await sharp(buf).resize({ width: w }).webp({ quality: 78 }).toBuffer();
  return new Response(out, {
    headers: {
      'content-type': 'image/webp',
      'cache-control': 'public, max-age=31536000, immutable'
    }
  });
};
```

> 캐시 가능한 **사이즈드 엔드포인트**를 두면 `srcset` 조합이 쉬워진다.

---

## 폰트 전략

### 핵심 개념

- **FOIT/FOUT 제어**: `font-display: swap|optional`
- **서브셋/가변 폰트**: 전송 크기 축소
- **preconnect/preload**: 웹폰트 CDN/호스트 최적화
- **CLS 방지**: fallback과 **metrics-compatible** 폰트 매칭

```svelte
<svelte:head>
  <!-- 폰트 호스트에 미리 연결 -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <!-- 핵심 텍스트 폰트 프리로드(자체 호스팅 권장) -->
  <link rel="preload" as="font" href="/fonts/Pretendard-Variable.woff2" type="font/woff2" crossorigin>
  <style>
    @font-face{
      font-family:"Pretendard VF";
      src:url("/fonts/Pretendard-Variable.woff2") format("woff2-variations");
      font-weight: 100 900;
      font-style: normal;
      font-display: swap;
    }
    html { font-family: "Pretendard VF", system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
  </style>
</svelte:head>
```

**서브셋 전략**
- **라틴/한글 분리** 또는 **빈도 높은 글자만**(서브셋1) + **나머지**(지연 로딩)
- 가변 폰트 1파일 vs 스타일별 여러 파일: **가변 폰트**가 종종 유리

---

## SSR 비용 · 하이드레이션 · 부분 하이드레이션 논의

### 비용 구성

- **SSR 비용**: 서버 CPU/메모리 + DB/API I/O + 템플릿 렌더
- **네트워크**: HTML/LCP 자원 전송
- **하이드레이션**: 클라이언트에서 컴포넌트 **초기화 비용**(JS 파싱/실행/바인딩)

**절감 요령**
1) **서버에서 무거운 일 최소화**: 캐시 헤더/ETag, 플랫폼 Cache 활용
2) **클라이언트 JS 전송 줄이기**: 동적 import/지연 로딩/CSR 영역 축소
3) **하이드레이션 대상 선별**: 정적 섹션은 **완전 정적**으로 두고, 상호작용 필요한 섹션만 하이드레이트

---

### 섬(Islands) 스타일(수동)

SvelteKit에는 내장 “islands” 문법은 없지만, **동적 import + 가시성/유휴시간 트리거**로 유사 효과 가능(§12.1.4 참고).

또는 **서브라우트 SPA**(예: `/app`에 `ssr=false`)로 **큰 상호작용 화면**을 분리하고, 나머지 공용 페이지는 SSR/SSG.

---

### 이벤트 첨부 최소화 & 리스트 최적화

- 큰 리스트는 **가상 스크롤**(virtualized list)
- 이벤트는 부모에 **위임**(delegation)하거나, 필요한 엘리먼트에만 바인딩
- heavy 컴포넌트는 **탈수(hydration skipping)** 대신 **지연 로딩**이 현실적

---

### Svelte 전용 팁

- **반응성 최소화**: 불필요한 `$:` 의존성 제거, 계산은 **파생 값**으로 메모
- **스토어 업데이트 묶기**: 한 틱에 여러 업데이트 → 컴포지트 비용 감소
- **Svelte 5/Runes**(채택 시): 세밀한 반응 범위로 재계산 폭을 줄인다

---

## Lighthouse · Web Vitals 모니터링

### 로컬/CI에서 Lighthouse

- 크롬 DevTools Lighthouse 탭
- **Lighthouse CI**로 PR 게이트

```json
// package.json (예)
{
  "scripts": {
    "lh:ci": "lighthouse http://localhost:4173 --preset=desktop --output=json --output-path=./.lighthouse/report.json"
  },
  "devDependencies": { "lighthouse": "^…" }
}
```

**GitHub Actions(개념)**
```yaml
name: lighthouse
on: [push, pull_request]
jobs:
  lh:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm ci
      - run: npm run build && npm run preview & npx wait-on http://localhost:4173
      - run: npm run lh:ci
      - uses: actions/upload-artifact@v4
        with: { name: lh-report, path: ./.lighthouse/report.json }
```

---

### Web Vitals 실측(클라이언트 → 서버 수집)

**지표**: **LCP/CLS/INP/TTFB**
- **INP**: 상호작용 반응성(새 표준)
- **실사용자 데이터(RUM)**로 지속 추적

```ts
// src/routes/api/vitals/+server.ts
import type { RequestHandler } from './$types';

export const POST: RequestHandler = async ({ request }) => {
  const body = await request.json(); // { name, value, id, rating, navigationType }
  // TODO: 로그/분석 저장(예: BigQuery/ClickHouse)
  return new Response('ok');
};
```

```svelte
<!-- src/lib/vitals.ts (브라우저에서) -->
<script>
  // web-vitals 패키지 사용 예 (개념)
  import { onMount } from 'svelte';

  async function send(metric) {
    navigator.sendBeacon?.('/api/vitals', JSON.stringify(metric))
      || fetch('/api/vitals', { method:'POST', body: JSON.stringify(metric), keepalive: true });
  }

  onMount(async () => {
    const { onLCP, onCLS, onINP, onTTFB } = await import('web-vitals');
    onLCP(send); onCLS(send); onINP(send); onTTFB(send);
  });
</script>
```

> **분석**: 페이지별/장치별 분포를 집계해 **회귀**를 조기 감지.

---

## 체크리스트

### 코드/번들

- [ ] 라우트 분할 확인(중복 의존성 제거, shared chunk 관리)
- [ ] 큰 라이브러리 동적 import + 가시성/유휴시간 로딩
- [ ] `/app` 등 SPA 섹션 분리(필요 시 `ssr=false`)
- [ ] 트리셰이킹/ESM/sideEffects 설정 확인

### 이미지

- [ ] LCP 이미지 프리로드 + `fetchpriority="high"`
- [ ] 모든 이미지 `width/height` 또는 `aspect-ratio` 지정(CLS 0에 가깝게)
- [ ] `srcset/sizes`로 **적절 크기 제공**, fold 아래 `loading="lazy"`
- [ ] AVIF/WebP 우선, 장기 캐시 + 해시/버전 파일명

### 폰트

- [ ] 자체 호스팅/프리로드, `font-display: swap|optional`
- [ ] 서브셋/가변 폰트, fallback 메트릭스 매칭
- [ ] 외부 폰트면 `preconnect`/`dns-prefetch`

### SSR/하이드레이션

- [ ] SSR은 필요한 곳에만, CSR-only 구간 분리
- [ ] 상호작용 섹션은 늦게 로드(가시성/idle)
- [ ] 큰 리스트에 가상 스크롤, 이벤트 위임

### 관측/운영

- [ ] Lighthouse CI로 **PR 마다** 회귀 방지
- [ ] Web Vitals RUM 수집(LCP/CLS/INP/TTFB)
- [ ] 실패 샘플 조사: LCP 후보/폰트/이미지/JS 실행 시간을 분리 분석

---

## 예제: 마케팅 + 앱 하이브리드 최적화

**목표**:
- "/"·"/pricing"은 **SSR+SSG**로 빠른 LCP
- "/app/**"는 **CSR-only**로 상호작용 집중
- 차트/에디터는 **가시성 로딩**, 이미지/폰트는 앞서 전략 준수

```ts
// src/routes/+layout.ts
export const prerender = true;   // 마케팅 전체 정적화
```

```ts
// src/routes/app/+layout.ts
export const ssr = false;        // 앱은 CSR-only
```

```svelte
<!-- src/routes/+layout.svelte (헤더의 폰트/프리로드/메타) -->
<svelte:head>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="preload" as="font" href="/fonts/Pretendard-Variable.woff2" type="font/woff2" crossorigin />
  <link rel="preload" as="image" href="/hero-1280.avif" />
</svelte:head>
<slot/>
```

```svelte
<!-- src/routes/marketing/+page.svelte (LCP 최적화) -->
<picture>
  <source srcset="/hero-1280.avif 1280w, /hero-1920.avif 1920w" type="image/avif" sizes="100vw"/>
  <img src="/hero-1280.jpg" width="1280" height="720" alt="Hero" fetchpriority="high"/>
</picture>
```

```svelte
<!-- src/routes/app/dashboard/+page.svelte (지연 상호작용) -->
<script>
  import ChartHost from '$lib/lazy/ChartHost.svelte';
  export let data;
</script>

<h1>Dashboard</h1>
<ChartHost data={data.series}/>
```

---

## 결론

- **전송(JS/이미지/폰트) 줄이기** + **지연 로딩**이 성능의 8할.
- **SSR/SSG + CSR-only 구간**을 조합해 **UX와 비용**을 균형 있게.
- **Lighthouse CI**로 회귀를 막고, **Web Vitals RUM**으로 실제 사용자 체감을 지속적으로 관찰하라.
- 설계 초기부터 **이미지/폰트/하이드레이션 전략**을 결정하면, 나중의 대공사를 피할 수 있다.
