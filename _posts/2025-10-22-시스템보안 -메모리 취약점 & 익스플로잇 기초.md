---
layout: post
title: 시스템보안 - 메모리 취약점 & 익스플로잇 기초
date: 2025-10-22 16:30:23 +0900
category: 시스템보안
---
# 3. 메모리 취약점 & 익스플로잇 기초 — “왜 깨지는가”를 몸으로 이해하기

> 목적: **스택 프레임/제어흐름**과 **대표 취약점 패턴**을 안전한 랩 환경에서 관찰·이해하고, 각 취약점의 **원인·증상·탐지·완화(패치)**를 손에 익힌다.
> 전제: 본 문서는 **교육/연구 목적**이다. 실서비스/타인 시스템에 대한 공격·오남용을 금지하며, 모든 실습은 **오프라인 VM(Host-only)**에서 더미 데이터만으로 수행한다.
> 빌드 타깃: Linux(x86-64) 기준. Windows/MSVC/WinDbg로도 동일 원리가 적용되며, 명령/옵션은 적절히 치환 가능.

---

## 3.0 랩 공통 세팅 (안전 장치)

- VM: Ubuntu LTS (Host-only), 스냅샷: `B0-Toolchain`, `B1-Lab`.
- 패키지:
  ```bash
  sudo apt update && sudo apt install -y build-essential gdb python3-pip \
    valgrind cppcheck clang llvm
  pip install pwn # (연구용 보조, 필수 아님)
  ```
- 컴파일 기본: **디버그 심볼 + 보호 ON**으로 먼저 빌드 → 증상 관찰 → **의도적으로** 보호 OFF로 재현(연구용).
  ```bash
  CFLAGS="-O0 -g -fno-omit-frame-pointer"
  ```

---

## 3.1 버퍼 오버플로우(C/C++)의 본질 — 스택 프레임과 EIP/RIP 하이재킹

### 3.1.1 스택 프레임 빠르게 복기
- 호출 규약(SysV x86-64):
  - 인자: `rdi, rsi, rdx, rcx, r8, r9` → 나머지 스택
  - `push %rbp`/`mov %rsp,% rbp`로 프레임 고정, `sub rsp, ...`로 로컬 버퍼 확보
  - **취약점 핵심**: “로컬 버퍼”(예: `char buf[16]`)에 **경계 체크 없는 쓰기** → **Saved RIP**(리턴주소)까지 덮침
- 하이재킹: Saved RIP를 공격자 제어 값으로 덮으면 **리턴 시 제어 흐름 이탈**.
  실제 공격(PoC)은 본 문서에서 다루지 않는다. 우리는 **원인/증상/방어**를 관찰한다.

### 3.1.2 교육용 취약 코드 (읽기 전용·오프라인)
```c
// 3_1_overflow_demo.c  (교육용, 절대 프로덕션 금지)
// 빌드(기본 보호 ON):   gcc $CFLAGS 3_1_overflow_demo.c -o oflow
// 빌드(연구: 일부 보호 OFF): gcc $CFLAGS -fno-stack-protector -z execstack -no-pie 3_1_overflow_demo.c -o oflow_unsafe
#include <stdio.h>
#include <string.h>

void greet(const char *name) {
    char buf[16];
    // 취약: 경계 검사 없이 복사
    strcpy(buf, name);
    printf("Hello, %s!\n", buf);
}

int main(int argc, char **argv){
    const char *name = (argc > 1) ? argv[1] : "world";
    greet(name);
    return 0;
}
```

#### ① 보호 ON 빌드 → 증상 관찰
```bash
gcc $CFLAGS 3_1_overflow_demo.c -o oflow
./oflow $(python3 - <<'PY'
print("A"*64)
PY)
# 일반적으로 스택 카나리 탐지로 abort (*** stack smashing detected ***)
```
- **관찰 포인트**: 카나리/ASLR/NX 등의 보호가 **비정상 종료**로 막는다.

#### ② (연구용) 보호 OFF 빌드 → 크래시 지점 보기
```bash
gcc $CFLAGS -fno-stack-protector -z execstack -no-pie 3_1_overflow_demo.c -o oflow_unsafe
gdb -q ./oflow_unsafe
(gdb) run $(python3 - <<'PY'
print("A"*40)
PY)
# → RIP/Saved RIP 근처가 '0x41414141...' (A)로 덮일 수 있음 (환경마다 상이)
(gdb) bt    # 백트레이스로 리턴 흐름 확인
(gdb) disassemble greet
(gdb) info frame
```

> **핵심 메시지**: 오버플로우는 **로컬 버퍼 경계**를 넘는 쓰기 → **프레임 구조** 이해가 곧 예방/탐지의 첫걸음.

---

### 3.1.3 안전한 대체/완화 (개발자 체크리스트)
- 입력 길이 제한: `strncpy`, `snprintf`, `fgets`(단, 사용 패턴 주의)
- 근본 해결: **버퍼 길이·사용자 입력 경로 검증** + **경계 기반 API**
- 정적분석/런타임 검증:
  - `-D_FORTIFY_SOURCE=2`(glibc 계열), `-fsanitize=address,undefined`
  - `clang-tidy`, `cppcheck`로 누수/오버런 지점 사전 탐지

```bash
gcc $CFLAGS -D_FORTIFY_SOURCE=2 -O2 -Wall -Wextra -fsanitize=address 3_1_overflow_demo.c -o oflow_safe
ASAN_OPTIONS=detect_stack_use_after_return=1 ./oflow_safe "$(python3 - <<'PY' ; )"
```

---

## 3.2 보호 기법 이해 — Canary, DEP/NX, ASLR, RELRO (그리고 PIE)

### 3.2.1 스택 카나리(Stack Protector)
- **원리**: 함수 진입 시 랜덤 **카나리 값**을 리턴주소 앞에 두고, 리턴 시 카나리를 검사 → 값 변조(오버플로우) 감지 시 종료.
- 도구 확인:
  ```bash
  gcc -fstack-protector-strong -O2 -c 3_1_overflow_demo.c -o t.o
  readelf -s t.o | grep __stack_chk
  ```
- 한계: **정보누출(Leak)**로 카나리 값이 노출되면 우회 여지. → 다른 보호와 **조합**이 중요.

### 3.2.2 DEP/NX (Data Execution Prevention)
- **원리**: 스택/힙 **실행 금지**(NX) → “데이터는 실행되지 않는다”.
- 확인:
  ```bash
  readelf -l oflow | grep GNU_STACK
  # RWE가 아니라 RW-여야 안전 (실행 금지)
  ```
- 한계: ROP/JOP와 같은 **Return-Oriented** 체인으로 **기존 코드 조각**을 조합하는 공격은 남음.
  (본 문서에서는 구현 세부를 다루지 않음 — 방어 중심 이해에만 필요)

### 3.2.3 ASLR (Address Space Layout Randomization)
- **원리**: 모듈/스택/힙/라이브러리의 **배치 주소 랜덤화** → 고정 주소 전제 공격 방해.
- 확인/실험:
  ```bash
  cat /proc/sys/kernel/randomize_va_space  # 2 권장
  ./oflow; ./oflow   # 두 번 실행하여 /proc/<pid>/maps 비교 → 베이스/스택 주소 변동
  ```
- 한계: **정보누출**이 있으면 랜덤화 무력화 가능 → 정보누출 차단이 중요.

### 3.2.4 RELRO (RELocation Read-Only)
- **Partial/Full RELRO**: GOT/재배치 영역을 **읽기 전용** 처리 → GOT overwrite류 공격 방지.
- 확인:
  ```bash
  checksec --file=oflow || true
  readelf -l oflow | grep -i relro
  ```
- 실무 팁: 린커 옵션 `-Wl,-z,relro,-z,now`(Full RELRO) 채택.

### 3.2.5 PIE (Position Independent Executable)
- 실행 파일 본체도 공유 라이브러리처럼 재배치 → **엔트리/함수 베이스 랜덤화**.
- 빌드:
  ```bash
  gcc $CFLAGS -fpie -pie 3_1_overflow_demo.c -o oflow_pie
  ./oflow_pie; ./oflow_pie  # main 주소가 매번 달라짐
  ```

### 3.2.6 “보호 조합” 관점
- **강한 기본선**: `-fstack-protector-strong -fpie -pie -Wl,-z,relro,-z,now -D_FORTIFY_SOURCE=2`
- 런타임 진단 보조: `-fsanitize=address,undefined` (테스트 빌드에만)

---

## 3.3 대표 취약점 4형제 — Format String, Use-After-Free, Double Free, Integer Overflow

### 3.3.1 Format String (형식 문자열)

#### (원인)
- `printf(user_input);` 같이 **형식 문자열에 외부 입력을 직접 사용**.
- `%x/%s/%n` 등 **제어 시퀀스가 공격자 제어**가 되면 정보누출/메모리 쓰기 가능.
- 본 문서에서는 **정보누출 증상 관찰**과 **안전 사용법**만 다룬다.

#### (취약 예제)
```c
// 3_3_fmt.c
#include <stdio.h>
int main(int argc, char **argv){
    if(argc < 2){ puts("usage: ./a <msg>"); return 0; }
    // 취약: 형식 문자열에 사용자 입력 직접 사용 (교육용)
    printf(argv[1]);      // <-- BAD
    printf("\n");
    return 0;
}
```
- 관찰:
  ```bash
  gcc $CFLAGS 3_3_fmt.c -o fmt
  ./fmt "Hello"            # 정상처럼 보임
  ./fmt "%x %x %x %x"      # 스택 값(쓰레기) 누출 가능
  ```
- 안전한 대체:
  ```c
  printf("%s\n", argv[1]); // GOOD
  ```
- 정적 분석/컴파일러 경고:
  ```bash
  gcc -Wall -Wformat -Wformat-security 3_3_fmt.c -o fmt_warn
  # 경고: format not a string literal and no format arguments
  ```

#### (탐지/완화)
- 정적: `-Wformat-security`, `-Werror=format-security`
- 런타임: 포맷 문자열 검사 도구(ASAN은 포맷 문제 직접 검출하진 않음)
- 코드 리뷰: 외부입력→포맷 경로를 **문자열 리터럴**로 고정

---

### 3.3.2 Use-After-Free (UAF)

#### (원인)
- 이미 **free()**된 포인터/객체를 **다시 사용**.
- C++의 경우 소유권/수명 규칙 위반(잘못된 `delete`, 이중 소유 공유 등).

#### (취약 예제)
```c
// 3_3_uaf.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char *name;
} user_t;

int main(){
    user_t *u = malloc(sizeof(user_t));
    u->name = strdup("alice");
    printf("user=%s\n", u->name);
    free(u->name);
    free(u);
    // UAF: 이미 해제된 u->name을 재사용 (교육용)
    printf("after free: %s\n", u->name); // <-- UAF (UB)
    return 0;
}
```

- 관찰:
  ```bash
  gcc $CFLAGS 3_3_uaf.c -o uaf
  ./uaf          # 운 좋으면(?) 그냥 출력되기도, 세그폴트도 나기도
  valgrind ./uaf # Invalid read of size ... 경고
  ```
- AddressSanitizer로 감지:
  ```bash
  gcc $CFLAGS -fsanitize=address 3_3_uaf.c -o uaf_asan
  ASAN_OPTIONS=detect_use_after_free=1 ./uaf_asan
  # → use-after-free 리포트, 스택트레이스 제공
  ```

#### (패치/예방)
- **소유권·수명 규칙 표준화**: “할당한 곳과 해제한 곳 같게”, “이후 포인터 NULL 세팅”
- C++: `std::unique_ptr`/`std::shared_ptr`로 소유권 명확화
- **이동 후 원본 초기화**(dangling 방지), 복사/대입 규칙 정의

```c
// 패치 스케치
free(u->name); u->name = NULL;
free(u); u = NULL;
```

---

### 3.3.3 Double Free (이중 해제)

#### (원인)
- 같은 포인터를 **두 번 이상 free()**.
- 해제 후 포인터를 **NULL로 초기화하지 않음** + 예외 경로 중복 free 등.

#### (취약 예제)
```c
// 3_3_doublefree.c
#include <stdio.h>
#include <stdlib.h>
int main(){
    char *p = malloc(32);
    free(p);
    // 다시 해제 (교육용)
    free(p);   // <-- Double free
    return 0;
}
```
- 관찰:
  ```bash
  gcc $CFLAGS 3_3_doublefree.c -o dfree
  ./dfree                 # 환경에 따라 조용히 종료될 수도, abort도 가능
  valgrind ./dfree        # Invalid free 리포트
  gcc $CFLAGS -fsanitize=address 3_3_doublefree.c -o dfree_asan
  ./dfree_asan            # ASAN이 즉시 잡아줌
  ```

#### (패치/예방)
- **해제 직후 NULL** 패턴:
  ```c
  free(p); p = NULL;
  ```
- 컨테이너/리스트에서 **소유권 한 곳으로 집중**, 해제 책임 분산 금지
- RAII(C++): 생성/소멸자 기반 자원관리

---

### 3.3.4 Integer Overflow (정수 오버플로우)

#### (원인)
- 크기 계산 시 **정수 범위 초과** → 작은 값으로 wrap → **버퍼 과소할당 → 오버플로우** 유발.
- 예: `len = a + b + 1; buf = malloc(len);`에서 `a+b+1`이 `UINT_MAX`를 넘어 wrap.

#### (취약 예제)
```c
// 3_3_int_overflow.c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
int main(int argc, char **argv){
    uint32_t a = 0xffffffffu; // 4294967295
    uint32_t b = 10u;
    uint32_t len = a + b + 1u;    // wrap → (a+b+1) mod 2^32 = 10
    char *buf = malloc(len);      // 아주 작은 버퍼
    memset(buf, 'A', a % 100);    // 큰 길이로 쓰기 → 오버플로우
    printf("len=%u\n", len);
    free(buf);
    return 0;
}
```
- 관찰:
  ```bash
  gcc $CFLAGS 3_3_int_overflow.c -o iof
  ./iof                    # 크래시/ASAN 탐지 가능
  gcc $CFLAGS -fsanitize=undefined 3_3_int_overflow.c -o iof_ubsan
  ./iof_ubsan              # undefined behavior 산티나이저 경고
  ```

#### (패치/예방)
- 안전한 덧셈/곱셈 체크 루틴 적용:
  ```c
  #include <stdint.h>
  int add_overflow_u32(uint32_t a, uint32_t b, uint32_t *out){
      uint64_t r = (uint64_t)a + (uint64_t)b;
      if (r > UINT32_MAX) return -1;
      *out = (uint32_t)r; return 0;
  }
  ```
- 길이 계산은 **size_t**(플랫폼 폭) 기반, 계산마다 **오버플로우 검사**
- 외부 입력 기반 크기는 **상한선** 설정(프로토콜/파일 포맷 스키마로 강제)

---

## 3.4 진단·재현·보고 템플릿 (현업형)

### 3.4.1 최소 재현 단계(RR: Repro Recipe)
1) 빌드 옵션(컴파일러/버전/플래그)
2) 입력/인자/환경변수(최소값), 데이터 샘플
3) 크래시/경고 로그, 산티나이저/Valgrind 리포트
4) `/proc/<pid>/maps`/`dmesg`(필요 시)

### 3.4.2 triage 체크포인트
- 오버플로우 vs 포맷 vs UAF/Double free vs 정수오류 **분류**
- **취약 함수 표면**(strcpy/strcat/sprintf 등) vs **로직 취약**(인덱스/경계 미검증)
- **보호 플래그 유무**(ASLR/NX/RELRO/PIE/FORTIFY) → 배포 파이프라인 수정

### 3.4.3 완화 우선순위(개발자 액션)
1) 입력 검증(길이/범위/서명/스키마) → 실패 시 즉시 중단·로그
2) 안전 API 대체 + 경계 기반 설계
3) 빌드 기본선 강화(PIE/RELRO/SSP/FORTIFY)
4) 테스트 커버리지: fuzz( libFuzzer/AFL-++ ), ASAN/UBSAN, 회귀 테스트

---

## 3.5 미니 랩: “안전하게 보는” 크래시에서 배움 얻기

> 목표: 각각의 취약 코드를 **보호 ON/OFF**로 빌드해 차이를 관찰하고, 산티나이저/Valgrind로 문제를 **정확히 분류**한다.
> 원칙: Host-only, 샌드박스 바이너리만.

1) **오버플로우**
   ```bash
   gcc $CFLAGS 3_1_overflow_demo.c -o oflow && ./oflow "$(python3 - <<'PY' ; )"
   gcc $CFLAGS -fno-stack-protector -z execstack -no-pie 3_1_overflow_demo.c -o oflow_unsafe
   gdb -q ./oflow_unsafe   # RIP 덮임 관찰(환경 의존)
   ```
2) **포맷 문자열**
   ```bash
   gcc $CFLAGS 3_3_fmt.c -o fmt
   ./fmt "%x %x %x %x"     # 정보누출 증상
   gcc -Wall -Wformat -Wformat-security 3_3_fmt.c -o fmt_warn
   ```
3) **UAF/Double free**
   ```bash
   gcc $CFLAGS 3_3_uaf.c -o uaf
   valgrind ./uaf
   gcc $CFLAGS -fsanitize=address 3_3_uaf.c -o uaf_asan && ./uaf_asan

   gcc $CFLAGS 3_3_doublefree.c -o dfree
   valgrind ./dfree
   gcc $CFLAGS -fsanitize=address 3_3_doublefree.c -o dfree_asan && ./dfree_asan
   ```
4) **정수 오버플로우**
   ```bash
   gcc $CFLAGS 3_3_int_overflow.c -o iof
   gcc $CFLAGS -fsanitize=undefined 3_3_int_overflow.c -o iof_ubsan
   ./iof_ubsan
   ```

- **관찰 기록 템플릿**(블로그용 표):
  - 소스/버전/빌드 플래그/보호
  - 증상(크래시/경고/로그)
  - 진단(오버플로우/포맷/UAF/DF/정수오류)
  - 패치 포인트(코드 라인/대체 API/검증 로직)
  - 재현 스크립트/테스트 벡터 해시

---

## 3.6 “개발팀에 주는” 방어 체크리스트 (요약)

- **코딩 규약**
  - 외부입력 길이/범위/스키마 검증 필수
  - 문자열: `snprintf`, `strlcpy/strlcat`(플랫폼별), 안전 래퍼 적용
  - 동적할당: 한 함수에서 할당한 것은 **동일 라이프사이클**에서 해제
  - 포인터 해제 후 즉시 `NULL`
  - 크기 계산은 **size_t** + 오버플로우 검사 유틸 사용

- **빌드 기본선**
  - `-fstack-protector-strong -fpie -pie -Wl,-z,relro,-z,now -D_FORTIFY_SOURCE=2`
  - 테스트 빌드에 `-fsanitize=address,undefined`(CI에서 샘플 실행)
  - 서드파티 라이브러리도 동일 정책

- **테스트/CI**
  - 단위테스트 + 경계값 + “대량/이상치” 입력
  - fuzz 타깃(파서/디코더/압축/네트워크 입력)
  - Valgrind/ASAN/UBSAN 주간 리포트, 크래시 샘플 아카이브(해시 봉인)

- **런타임/배포**
  - ASLR/NX/RELRO/PIE 켠 빌드만 배포
  - `seccomp`/AppArmor/SELinux 등 샌드박싱 고려(서버/CLI 툴)
  - 크래시 덤프의 **PII 제거** + 안전 저장/전송 정책

---

# 부록 A. 디버깅 치트시트

### gdb
```
set disassemble-next-line on
break *0xADDRESS / break func
run [args]
ni / si           # step over/into
bt                # backtrace
x/32xb $rsp       # 메모리 덤프
info frame        # 프레임 구조
info registers
```

### Valgrind
```
valgrind --leak-check=full --track-origins=yes ./bin args
```

### Address/Undefined Sanitizer
```
gcc -fsanitize=address -g file.c -o a.out
gcc -fsanitize=undefined -g file.c -o a.out
ASAN_OPTIONS=detect_use_after_free=1:halt_on_error=1 ./a.out
```

---

# 부록 B. “코드 리뷰”용 안티 패턴 리스트

- 문자열 복사/포맷에 **리터럴 형식 문자열 없는** `printf/scanf`류 호출
- `strcpy/strcat/gets`/`scanf("%s", buf)` 같이 **경계 미지정** API
- 외부 입력으로 **크기 계산**하면서 오버플로우 검사 누락
- **해제 후 사용**, **중복 해제** 가능성이 있는 복잡한 에러 경로
- 배열/컨테이너 인덱스에 **범위 검증 없음**
- 스택에 큰 구조체/배열 할당(고정 길이) — 오버런/스택 충돌 위험
- “TODO: check later” 주석과 함께 남은 검증

---

# 마무리

- **스택 프레임**과 **제어흐름**을 이해하면, 왜 오버플로우가 위험한지 **물리적으로** 보인다.
- **보호 기법**은 “겹겹이” 적용되어야 하고, **정보누출 차단**이 특히 중요하다.
- **포맷/UAF/Double-free/정수오류**는 모두 “경계·수명·수학”의 문제다 — 코딩 규약·정적분석·산티나이저·샌드박스로 **연쇄 방어**를 구축하자.
