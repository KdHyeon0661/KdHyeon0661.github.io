---
layout: post
title: Git - Monorepo
date: 2025-03-16 20:20:23 +0900
category: Git
---
# 모노레포(MonoRepo) 전략과 도구 활용 가이드

모노레포는 여러 프로젝트(예: 웹앱, API 서버, 공용 라이브러리)를 **하나의 저장소**에서 관리하는 방식입니다. 이 방식은 코드 공유, 툴링 일관성 유지, 단일화된 CI/CD 파이프라인 구축에 강점이 있지만, 저장소 크기와 빌드 속도 관리가 핵심 과제입니다.

## 모노레포의 구조와 장단점

### 표준 구조
일반적으로 다음과 같은 구조를 따릅니다.
```
my-org-repo/
├── apps/          # 배포 가능한 애플리케이션 (웹, 모바일, API)
├── packages/      # 내부 공유 라이브러리 및 컴포넌트
├── tools/         # 빌드, 코드 생성 등 개발 도구
└── 구성 파일 (package.json, turbo.json 등)
```

### 장단점 요약
**장점**:
*   **원자적 변경(Atomic Changes)**: 하나의 커밋으로 여러 패키지에 걸친 변경사항을 관리할 수 있습니다.
*   **코드 공유 용이**: 패키지 간 의존성을 `workspace:*` 같은 링크로 쉽게 설정할 수 있습니다.
*   **통일된 툴링과 검증**: 저장소 루트 하나에 린트, 테스트, 빌드 규칙을 일관되게 적용할 수 있습니다.

**단점과 해결 방향**:
*   **저장소 크기 증가**: Git의 `partial clone`과 `sparse-checkout` 기능으로 필요한 부분만 내려받습니다.
*   **빌드 시간 증가**: Turborepo나 Nx 같은 도구의 **캐싱**과 **변경 영향도 분석(Affected Build)** 을 활용합니다.
*   **권한 관리 복잡**: GitHub의 `CODEOWNERS` 파일과 브랜치 보호 규칙으로 디렉터리별 코드 오너를 지정할 수 있습니다.

## 핵심 Git 최적화 기술

대규모 모노레포에서 개발자 경험을 보존하려면 Git 최적화가 필수적입니다.

### 1. Sparse Checkout (희소 체크아웃)
워킹 디렉터리에 필요한 파일과 디렉터리만 체크아웃합니다. Git 공식 문서에 따르면, 이 명령은 추적된 파일의 하위 집합만 워킹 트리에 존재하도록 만듭니다.
```bash
# 저장소 클론 후 희소 체크아웃 모드 초기화
git clone <repo-url>
cd <repo-name>
git sparse-checkout init --cone
# apps/web과 packages/ui 디렉터리만 워킹 트리에 가져오기
git sparse-checkout set apps/web packages/ui
```
`--cone` 모드는 성능을 최적화하며, 지정한 디렉터리와 그 하위 모든 파일을 포함합니다.

### 2. Partial Clone (부분 복제)
히스토리나 파일 블롭(blob)을 처음부터 모두 다운로드하지 않습니다.
```bash
# 파일 내용(blob)은 필요할 때 가져오고, 나머지 데이터만 먼저 복제
git clone --filter=blob:none --no-checkout <repo-url>
cd <repo-name>
# 이후 sparse-checkout을 설정하면 필요한 blob만 내려받음
```
이 방식은 초기 클론 속도를 획기적으로 높여줍니다.

### 3. Shallow Fetch (얕은 가져오기)
CI 환경 등에서 최신 커밋만 필요할 때 사용합니다.
```bash
git fetch --depth=1 origin main
```

## 모노레포 빌드 및 작업 관리 도구

각 도구는 다른 철학과 장점을 가지고 있습니다. 프로젝트 규모와 요구사항에 따라 선택할 수 있습니다.

### Lerna
JavaScript 모노레포를 위한 오래되고 검증된 도구로, **패키지 버전 관리와 배포(Publish)** 에 강점이 있습니다. Lerna 공식 문서에서는 자신을 “여러 JavaScript/TypeScript 패키지를 동일 저장소에서 관리하고 배포하기 위한 빠르고 현대적인 빌드 시스템”으로 소개합니다.

### Nx
**스마트한 빌드 시스템과 고급 CI 기능**이 핵심입니다. Nx 공식 사이트는 “고급 CI 기능을 갖춘 빌드 시스템”으로 소개하며, 다음과 같은 기능을 강조합니다.
*   **의존성 그래프(Dependency Graph)**: 코드베이스의 관계를 시각화하고 분석합니다.
*   **변경 영향도 기반 실행(Affected Commands)**: 변경된 부분만 빌드하거나 테스트합니다.
*   **분산형 캐시(Distributed Caching)**: 로컬 및 원격 캐시로 빌드를 가속화합니다.
*   **코드 생성 및 자동화**: 일관된 구조의 코드를 생성하는 데 도움을 줍니다.

### Turborepo
**초고속 빌드 실행**에 특화된 도구입니다. Turborepo 공식 문서는 “JavaScript 및 TypeScript 코드베이스를 위한 고성능 빌드 시스템”이라 정의하며, 다음과 같은 원리로 작동합니다.
1. **파이프라인 정의**: `turbo.json` 파일에 `build`, `test`, `lint` 같은 작업과 그 의존 관계를 선언합니다.
2. **최대 병렬화**: 서로 의존하지 않는 작업은 동시에 실행합니다.
3. **지능형 캐싱**: 작업의 입력(파일, 환경 변수 등)을 해시화하여, 동일한 입력에 대해서는 캐시된 결과를 재사용합니다. 이 **원격 캐시(Remote Cache)** 기능은 팀 전체와 CI 환경의 빌드 속도를 혁신적으로 줄여줍니다.

Turborepo의 설정 스키마(`turbo.build/schema.json`)는 `pipeline`을 필수 요소로 정의하며, 각 작업에서 `dependsOn`, `outputs`, `cache` 등을 구성할 수 있도록 합니다.

### 패키지 매니저 Workspace (pnpm / yarn / npm)
위의 빌드 도구들은 대부분 패키지 매니저의 **워크스페이스(Workspace)** 기능과 결합되어 사용됩니다. 이 기능은 루트에서 의존성을 한 번에 설치하고(`pnpm i`), 패키지 간 로컬 링크를 자동으로 관리합니다.

## CI/CD 파이프라인 최적화

모든 패키지를 매번 빌드하는 것은 비효율적입니다. 변경사항이 발생한 영역만 지능적으로 처리해야 합니다.

### 변경 경로 기반 실행 (Paths Filter)
GitHub Actions에서 `dorny/paths-filter` 액션 등을 사용하여 특정 디렉터리가 변경되었을 때만 해당 작업을 실행하도록 할 수 있습니다.
```yaml
- name: Filter changed paths
  uses: dorny/paths-filter@v3
  with:
    filters: |
      web:
        - 'apps/web/**'
        - 'packages/ui/**'
      api:
        - 'apps/api/**'
        - 'packages/utils/**'

- name: Build Web App
  if: steps.filter.outputs.web == 'true'
  run: pnpm --filter ./apps/web build
```

### 영향도 기반 실행 (Affected Commands)
Nx나 Turborepo는 Git 히스토리를 분석하여 변경사항의 영향을 받는 프로젝트만 식별하는 내장 명령어를 제공합니다.
```bash
# Nx: 마지막 커밋 대비 변경된 프로젝트만 빌드
npx nx affected --target=build

# Turborepo: main 브랜치 대비 변경된 프로젝트의 테스트 실행
pnpm dlx turbo run test --filter=...[origin/main]
```

## 버전 관리 및 릴리스 전략

여러 패키지의 버전을 관리하는 방법은 크게 두 가지입니다.

| 전략 | 설명 | 적합한 경우 |
| :--- | :--- | :--- |
| **고정 버전 (Fixed)** | 모든 패키지가 동일한 버전 번호를 사용합니다. | 강하게 결합된 패키지군, 단일 제품. |
| **독립 버전 (Independent)** | 각 패키지가 자신의 버전 번호를 독립적으로 관리합니다. | 느슨하게 결합된 라이브러리, 다양한 배포 주기. |

**Changesets** 같은 도구는 독립 버전 전략을 구현하는 데 도움을 줍니다. 개발자는 `pnpm changeset` 명령으로 변경 내용을 설명하는 마크다운 파일을 생성하고, CI 단계에서 이 파일들을 모아 버전 업그레이드와 CHANGELOG 생성을 자동화할 수 있습니다.

## 거버넌스: 권한 및 협업 규칙

모노레포는 여러 팀이 함께 작업하기 때문에 명확한 규칙이 필요합니다.

*   **CODEOWNERS 파일**: `.github/CODEOWNERS` 파일에 디렉터리별 담당 팀이나 개인을 지정하면, PR이 생성될 때 자동으로 해당 리뷰어가 할당됩니다.
    ```
    /apps/web/          @frontend-team
    /apps/api/          @backend-team
    /packages/ui/       @design-system-team
    ```
*   **브랜치 보호 규칙 (Branch Protection)**: 메인 브랜치에 대해 필수 리뷰, 상태 검사(CI 통과) 통과, 선형 히스토리 등을 요구하여 코드 베이스의 안정성을 유지할 수 있습니다.

## 마무리: 모노레포 도입 판단 가이드

모노레포는 만능 해결사가 아닙니다. 다음 질문에 “예”가 많다면 모노레포를 고려해볼 만합니다.

*   여러 프로젝트가 **동일한 공용 컴포넌트나 유틸리티 라이브러리**를 빈번히 공유하나요?
*   **단일 기능을 구현하는 데 여러 저장소를 넘나드는 변경**이 자주 발생하나요?
*   린트, 포맷, 빌드, 테스트 실행과 같은 **개발 환경과 규칙을 통일**하고 싶나요?
*   **Atomic Commit** (관련된 모든 변경을 하나의 커밋으로)으로 배포하는 것이 중요한가요?

반면, 다음에 해당한다면 여러 저장소(Polyrepo)를 유지하는 것이 나을 수 있습니다.

*   프로젝트 간 **기술 스택이나 개발 주기가 완전히 다르고** 공유할 코드가 거의 없습니다.
*   **보안상이나 규제상으로 프로젝트를 반드시 격리**해야 합니다.
*   기존 저장소 구조가 너무 크고 복잡하여 마이그레이션 비용이 예상보다 매우 큽니다.

성공적인 모노레포 운영은 **적절한 도구 선택**, **철저한 CI/CD 최적화**, 그리고 **팀 간의 명확한 협업 규칙**에 달려 있습니다. 처음부터 모든 것을 완벽하게 구현하기보다, 핵심 가치를 제공하는 부분부터 점진적으로 도입하고 발전시키는 접근법이 현명합니다.