---
layout: post
title: 정보보안기사 - 컨테이너·CI/CD 보안
date: 2025-11-09 23:25:23 +0900
category: 정보보안기사
---
# 컨테이너·CI/CD 보안 — **이미지 서명 · 비밀관리 · 파이프라인 보호**

## 0) 큰 그림(아키텍처)

```
Dev → PR → [CI: Build] ──┬─ SCA/SAST/Secret Scan ── Fail Gate
                          ├─ SBOM 생성/첨부(이미지/앱)
                          ├─ 이미지 스캔(Trivy/Grype)
                          ├─ Cosign 서명/Provenance(키리스/OIDC)
                          └─ 사설 레지스트리 푸시(immutable tag/retention)

[CD: Deploy] → (승인/환경보호) → K8s
   └─ Admission: verifyImages(서명/다이제스트/레지스트리)
                  + PodSecurity(Non-root, readOnlyRootFS, Cap drop)
                  + NetworkPolicy/Egress 제어
   └─ Runtime 스캔/모니터링/알람
```

---

# 1) 이미지 보안(Image Security)

## 1.1 Dockerfile 베스트 프랙티스

- **멀티 스테이지** + **최소 베이스**(distroless/ubi-micro 등)  
- **USER** 비루트, **권한/소유권** 세팅  
- **read-only rootfs**, **capabilities drop**, **seccomp**  
- **빌드 시크릿은 이미지에 남기지 않기**(BuildKit secret mount)

### 예: Python FastAPI (멀티스테이지 + distroless + BuildKit 비밀)
```dockerfile
# syntax=docker/dockerfile:1.7-labs
FROM python:3.12-slim AS build
WORKDIR /app
COPY pyproject.toml poetry.lock ./
# (옵션) 사설 인덱스 토큰을 빌드시에만 주입
RUN --mount=type=secret,id=pip_token \
    export PIP_TOKEN=$(cat /run/secrets/pip_token) && \
    pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir poetry && \
    poetry export -f requirements.txt --output requirements.txt
COPY . .
RUN pip install --prefix=/install --no-warn-script-location -r requirements.txt

FROM gcr.io/distroless/python3-debian12:nonroot
WORKDIR /srv
COPY --from=build /install /usr/local
COPY --from=build /app /srv
USER nonroot:nonroot
EXPOSE 8080
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1
# 런타임 Cap 최소화/ReadOnlyRootFS는 K8s securityContext에서 강제
CMD ["-m","gunicorn","-b","0.0.0.0:8080","app:app","--workers","2","--threads","4"]
```

> **포인트**  
> - BuildKit: `docker build --secret id=pip_token,src=./.pip_token`  
> - distroless는 쉘/패키저 부재 → 공격면 축소.

### K8s Deployment 보안 컨텍스트(필수 필드)
```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: app, namespace: prod, labels: { app: app } }
spec:
  replicas: 2
  selector: { matchLabels: { app: app } }
  template:
    metadata: { labels: { app: app } }
    spec:
      securityContext:
        runAsNonRoot: true
        seccompProfile: { type: RuntimeDefault }
      containers:
      - name: app
        image: registry.example.com/app@sha256:deadbeef...   # 다이제스트 핀
        ports: [{ containerPort: 8080 }]
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities: { drop: ["ALL"] }
          runAsUser: 10001
        resources:
          requests: { cpu: "100m", memory: "128Mi" }
          limits:   { cpu: "500m", memory: "512Mi" }
```

### 네트워크/Egress 최소화 (예시)
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata: { name: app-netpol, namespace: prod }
spec:
  podSelector: { matchLabels: { app: app } }
  policyTypes: ["Ingress","Egress"]
  ingress:
  - from: [{ podSelector: { matchLabels: { role: api-gw } } }]
    ports: [{ protocol: TCP, port: 8080 }]
  egress:
  - to: [{ namespaceSelector: { matchLabels: { name: prod-db } } }]
    ports: [{ protocol: TCP, port: 5432 }]
```

---

## 1.2 이미지 스캔(빌드/배포 전)

```bash
# 애플리케이션/OS 취약점 스캔
trivy image --exit-code 1 --severity CRITICAL,HIGH registry.example.com/app:1.2.3
# SBOM 생성(이미지)
trivy image --format cyclonedx --output bom-image.json registry.example.com/app:1.2.3
```

---

## 1.3 이미지 서명 & 프로비넌스(Sigstore/Cosign)

### 키리스(OIDC) 서명 & 검증
```bash
# 로그인 불필요: OIDC 기반 키리스 서명(브라우저 흐름)
cosign sign registry.example.com/app:1.2.3

# 서명 확인(투명성 로그 검증 포함)
cosign verify registry.example.com/app:1.2.3
```

### SBOM/어태스테이션 첨부
```bash
# SBOM 첨부(OCI artifact로 이미지에 부착)
cosign attach sbom --sbom bom-image.json registry.example.com/app:1.2.3

# 빌드 Provenance(SLSA in-toto) 어태스테이션(간단 예)
cosign attest --predicate provenance.json \
  --type slsaprovenance \
  registry.example.com/app:1.2.3
```

> **정책**: 프로덕션 네임스페이스는 **서명된 이미지만 배포** 허용 + **레지스트리 화이트리스트**.

---

## 1.4 Admission 정책(배포 차단)

### Kyverno — 서명 검증 + 레지스트리 제한
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata: { name: verify-signed-images }
spec:
  validationFailureAction: Enforce
  rules:
  - name: signed-only
    match: { any: [{ resources: { kinds: ["Pod","Deployment","StatefulSet"] } }] }
    verifyImages:
    - imageReferences:
      - "registry.example.com/*"
      attestors:
      - entries:
        - keys:
            # (키리스 검증은 issuer/subject 검증으로 대체 가능)
            publicKeys: |-
              -----BEGIN PUBLIC KEY-----
              ...
              -----END PUBLIC KEY-----
  - name: limit-registries
    match: { any: [{ resources: { kinds: ["Pod","Deployment","StatefulSet"] } }] }
    validate:
      message: "이미지는 허용된 레지스트리에서만 가져올 수 있습니다."
      pattern:
        spec:
          containers:
          - image: "registry.example.com/*"
```

### Gatekeeper(OPA/Rego) — runAsNonRoot/readOnly 강제(요약)
```rego
package k8srequired

violation[{"msg": msg}] {
  input.review.kind.kind == "Pod"
  some c
  container := input.review.object.spec.containers[c]
  not container.securityContext.readOnlyRootFilesystem
  msg := "readOnlyRootFilesystem must be true"
}
```

---

# 2) 비밀관리(Secrets Management)

## 2.1 원칙 & 위협모델
- **레포/이미지에 비밀이 포함되면 끝** → 유효기간이 긴 키일수록 피해가 커짐.  
- 비밀은 **외부 비밀저장소**(Vault/Parameter Store/Secrets Manager)에 보관, **짧은 TTL**로 **런타임 주입**.  
- **정적 키 → 동적 크리덴셜**(데이터베이스/클라우드 롤 임시 발급)로 전환.

## 2.2 CI에서 클라우드 접근 — OIDC + 단기 토큰(예: GitHub→AWS)

```yaml
# .github/workflows/deploy.yml (발췌)
permissions:
  id-token: write     # OIDC 토큰 요청에만 필요한 최소 권한
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@b4ffde...   # 커밋 SHA로 핀(중요)
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@e3ddf...
        with:
          role-to-assume: arn:aws:iam::123456789012:role/gha-deploy
          role-session-name: gha-${{ github.run_id }}
          aws-region: ap-northeast-2
      - run: aws sts get-caller-identity
```

> **포인트**: 레포에 액세스키/시크릿키 저장 금지. **OIDC 페더레이션**으로 **수분~수십분 수명**의 임시 자격만 사용.

## 2.3 Kubernetes에 비밀 주입

### (A) External Secrets Operator(ESO) — AWS Secrets Manager 예
```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata: { name: db-credentials, namespace: prod }
spec:
  refreshInterval: 1h
  secretStoreRef: { name: aws-secrets, kind: ClusterSecretStore }
  target:
    name: db-credentials
    template:
      type: Opaque
  data:
  - secretKey: username
    remoteRef: { key: prod/db, property: username }
  - secretKey: password
    remoteRef: { key: prod/db, property: password }
```

### (B) SOPS + age — GitOps 레포 암호화(예: Argo CD)
```bash
# 생성
sops --encrypt --age age1qxy... secret.yaml > secret.enc.yaml
# 복호(컨트롤러가 수행), 레포에는 암호문만 저장
```
`secret.yaml` 예:
```yaml
apiVersion: v1
kind: Secret
metadata: { name: app-secret, namespace: prod }
type: Opaque
stringData:
  API_KEY: "super-secret"
```

### (C) Vault — K8s 서비스어카운트로 로그인(개요)
- 앱 Pod의 SA 토큰 → Vault K8s Auth로 교환 → **짧은 TTL** 비밀 발급 → 사이드카/에이전트가 파일/환경변수로 주입.

## 2.4 빌드 시크릿(이미지에 남기지 않기)

- BuildKit `--mount=type=secret`만 사용, `ARG/ENV`로 복사하지 말 것.  
- 패키지 설치 토큰/레지스트리 자격증명은 **런타임**에 필요 없으므로 빌드 단계에서만 사용.

## 2.5 비밀 유출 탐지(Shift-left)

```yaml
# GitHub Actions — gitleaks
- name: Secrets Scan
  uses: gitleaks/gitleaks-action@7d2db...
  with: { args: "--verbose --redact --exit-code 1" }
```

> **운영**: 레포에 유출 발견 시 **즉시 무효화/회전**, 감염 범위 파악, 서드파티 영향 확인.

---

# 3) 파이프라인 보호(CI/CD Hardening)

## 3.1 위협·안티패턴
- **서드파티 액션/스크립트 탈취**, **PR 파이프라인에서 비밀 노출**, **캐시/아티팩트 오염**, **과도한 토큰 권한**.  
- `curl | bash` 무검증 설치, **태그 최신버전 액션 사용**(SHA 미핀), `pull_request_target` 오용.

## 3.2 최소 권한/샌드박스

- **permissions: read-only** 기본, 작업별 필요한 권한만 부여.  
- **서드파티 액션은 커밋 SHA**로 **핀**(혹은 내부 미러).  
- 포크 PR은 **별도 잡**에서 **비밀 미제공** + **self-hosted runner 금지**.  
- **에페메럴 러너**(작업 종료 시 폐기), **네트워크 이그레스 제한**(필요 도메인만).

### GitHub Actions 템플릿(보안형)
```yaml
name: ci-secure
on: [push, pull_request]

permissions: { contents: read }  # 최소
env:
  REGISTRY: registry.example.com

jobs:
  build-sign:
    runs-on: ubuntu-latest
    permissions:
      id-token: write   # OIDC (cosign keyless)
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@b4ffde...
      - uses: actions/setup-node@60ed3a...
        with: { node-version: '20' }

      - name: Install deps
        run: npm ci --ignore-scripts  # postinstall 스크립트 위험 감소

      - name: SCA
        run: npm audit --audit-level=high

      - name: Build image
        run: |
          echo "$REGISTRY/app:${{ github.sha }}" > image_tag
          docker build --progress=plain -t $(cat image_tag) .

      - name: Trivy scan
        uses: aquasecurity/trivy-action@d44e6f...
        with: { image-ref: "${{ env.REGISTRY }}/app:${{ github.sha }}", severity: "CRITICAL,HIGH", exit-code: "1" }

      - name: Login to Registry (OIDC or short-lived creds)
        run: echo "…"

      - name: Push
        run: docker push $(cat image_tag)

      - name: Cosign sign (keyless)
        uses: sigstore/cosign-installer@a3d41b...
      - run: cosign sign $(cat image_tag)

      - name: SBOM attach
        run: |
          trivy image --format cyclonedx --output bom.json $(cat image_tag)
          cosign attach sbom --sbom bom.json $(cat image_tag)
```

> **주의**: `uses:`는 **커밋 SHA로 고정**. 레지스트리 푸시는 **OIDC/단기자격**으로.

## 3.3 GitLab CI 유사 구성(핵심)
```yaml
stages: [lint, build, scan, sign, deploy]

variables:
  DOCKER_DRIVER: overlay2

build:
  stage: build
  image: gcr.io/kaniko-project/executor:debug
  script:
    - /kaniko/executor --destination $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA --digest-file digest.txt
  artifacts: { paths: [digest.txt] }

scan:
  stage: scan
  image: aquasec/trivy:latest
  script:
    - trivy image --exit-code 1 --severity CRITICAL,HIGH $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

sign:
  stage: sign
  image: ghcr.io/sigstore/cosign:v2.4.1
  script:
    - cosign sign $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
```

## 3.4 아티팩트/캐시 보호
- **immutable** 태그(덮어쓰기 금지), **서명 검증 후 승격**(dev → prod).  
- 캐시는 **프로젝트/브랜치 분리**, **만료** 설정, 민감파일 캐시에 저장 금지.

## 3.5 배포 보호(환경 보호 규칙)
- **승인자 2인** 이상, **변경 윈도우**/Freeze, **런북 링크**.  
- **변경감지/감사**: 누가 어떤 SHA를 언제 배포했는지 추적.

---

# 4) 엔드-투-엔드 예제(앱→이미지→서명→검증→배포)

## 4.1 샘플 앱(Express)
```javascript
// app.js
const express = require('express');
const app = express();
app.get('/healthz', (_,res)=> res.json({ ok:true }));
app.listen(8080);
```

## 4.2 Dockerfile(요약)
```dockerfile
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci --ignore-scripts
COPY . .
RUN npm prune --omit=dev

FROM gcr.io/distroless/nodejs20-debian12:nonroot
WORKDIR /srv
COPY --from=build /app .
USER nonroot
EXPOSE 8080
CMD ["app.js"]
```

## 4.3 CI에서 빌드/스캔/서명/푸시(위 GH Actions 참조)

## 4.4 K8s 배포(서명 검증 + 보안 컨텍스트)
- Kyverno 정책(앞 장)으로 **서명/레지스트리/보안컨텍스트**를 강제.  
- Deployment는 **다이제스트**로 고정.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: web, namespace: prod, labels: { app: web } }
spec:
  replicas: 2
  selector: { matchLabels: { app: web } }
  template:
    metadata: { labels: { app: web } }
    spec:
      containers:
      - name: web
        image: registry.example.com/web@sha256:6f2d...
        securityContext:
          runAsNonRoot: true
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities: { drop: ["ALL"] }
```

---

# 5) 인시던트 대응 런북

## 5.1 “이미지 위조/오염 의심”
1) 레지스트리의 최근 푸시/태그 변경 **감사 로그** 확인(immutable 위반 여부).  
2) 배포 중 이미지 **서명 검증**(cosign verify) — 실패 시 즉시 롤백.  
3) Kyverno/Gatekeeper **정책 상태** 확인(Enforce인지 Audit인지).  
4) 오염 의심 이미지 **격리/삭제**, 안전 버전 **재배포**.  
5) 근본원인: CI 크리덴셜 노출? 액션/러너 침해? → **키 회전/러너 재생성**.

## 5.2 “레포에 비밀 커밋”
1) gitleaks 결과에서 비밀 유형/범위 식별 → **즉시 무효화/회전**.  
2) `git filter-repo`로 히스토리에서 제거, 강제푸시 → 팀에 알림.  
3) 영향 시스템(클라우드/DB/서드파티) **접속 기록** 확인.

## 5.3 “PR 파이프라인에서 비밀 노출”
1) 포크 PR 잡에서 비밀 제공 차단 확인.  
2) `pull_request_target` 사용 여부/스텝 검토 → 필요 시 **중지**.  
3) 서드파티 액션 **SHA 핀** 미흡 → 즉시 수정.

---

# 6) KPI & 체크리스트

### KPI
- **서명 검증 강제율**(프로덕션 네임스페이스): $$ \frac{\text{서명검증 통과 배포}}{\text{전체 배포}} \times 100\% $$
- **High/Critical 이미지 취약점 잔존수**(릴리스 시 0)
- **비밀 평균 TTL** 및 **장기키 사용률**
- **핀된 서드파티 액션 비율** (SHA or internal mirror)

### 체크리스트
- [ ] Dockerfile: 비루트/멀티스테이지/최소베이스/BuildKit 비밀  
- [ ] 이미지: **다이제스트 핀**, SBOM 첨부, 트리비 스캔 게이트  
- [ ] 서명: Cosign(키리스) 서명 + 레지스트리/배포 전 검증  
- [ ] Admission: Kyverno/Gatekeeper로 서명/레지스트리/보안컨텍스트 강제  
- [ ] 비밀: OIDC 페더레이션·ESO/Vault·SOPS, 레포 스캔(gitleaks)  
- [ ] CI: 최소 권한 `permissions`, 액션 **SHA 핀**, 포크 PR 분리  
- [ ] 배포: 환경 보호 규칙/승인/감사, 롤백 절차·런북  
- [ ] 로그/감사: 레지스트리 immutability, 푸시/태깅 감사 활성

---

# 7) 미니 연습문제(예상형)

1) **문**: “프로덕션 네임스페이스에서 **서명되지 않은 이미지**가 배포되려 한다. 어떤 구성으로 차단할 수 있는가?”  
   **답**: Kyverno `verifyImages` 규칙(또는 Sigstore policy-controller)로 **서명 검증 Enforce**, 레지스트리 화이트리스트와 **다이제스트 핀** 병행.

2) **문**: BuildKit에서 비밀을 안전하게 전달하는 올바른 방법은?  
   **답**: `RUN --mount=type=secret,id=...` 로 사용하고, Dockerfile에 `ARG/ENV`로 남기지 않는다.

3) **문**: 포크 PR에 비밀을 제공하면 왜 위험한가?  
   **답**: 공격자가 워크플로를 수정해 **비밀을 외부로 유출**할 수 있다. 포크 PR에는 **비밀 미제공**이 원칙.

4) **문**: 이미지 스캔에서 High 취약점이 발견되었지만 우회가 필요하다. 정책상 허용하려면?  
   **답**: **만료일/근거**가 있는 Waiver만 허용하고, 자동 만료/재평가를 설정한다.

---

## 마무리

- **이미지 최소화→스캔→서명→검증**, **비밀의 외부화·단기화**, **파이프라인 최소 권한·고정·정책 게이트**가 3대 축입니다.  
- 오늘 바로 할 일:  
  1) 프로덕션에 **서명 이미지 강제 정책**(Kyverno/Gatekeeper) 적용  
  2) CI에 **Trivy + SBOM + Cosign** 단계를 추가하고 **SHA 핀**으로 고정  
  3) 클라우드 접근은 **OIDC로 단기 권한**만 사용(장기 키 제거)  
  4) 레포 전역 **gitleaks** 스캔 및 **SOPS/ESO/Vault**로 비밀 외부화