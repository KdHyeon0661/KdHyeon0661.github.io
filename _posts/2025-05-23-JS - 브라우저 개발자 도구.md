---
layout: post
title: JavaScript - 브라우저 개발자 도구
date: 2025-05-23 22:20:23 +0900
category: JavaScript
---
# 브라우저 개발자 도구(DevTools) 활용법

## 0. 열기·기본 사용

- 열기: `F12` / `Ctrl+Shift+I` (macOS: `Cmd+Opt+I`) 또는 페이지 우클릭 → 검사(Inspect)
- 패널 전환: 상단 탭(Elements, Console, Sources, Network, …)
- 명령 팔레트: `Ctrl+Shift+P` / `Cmd+Shift+P` (기능 검색: “Show coverage”, “Disable cache” 등)
- 패널 도킹: DevTools 우상단 ⋮ → Dock side

---

## 1. Elements — DOM·CSS 실시간 편집과 구조 파악

### 핵심 기능
- **DOM 탐색/수정**: 요소 추가/삭제, 속성 편집, 클래스 토글
- **스타일 실험**: 우측 **Styles** 패널에서 CSS 규칙 추가/비활성화
- **상태 강제**: `:hov` 버튼 → `:hover`, `:focus`, `:active` 상태 강제
- **Device Toolbar**: 휴대폰/태블릿 뷰포트 시뮬레이션, DPR/회전, 네트워크 조건과 함께 사용 가능

### 예제: 특정 카드의 레이아웃 깨짐 추적
1. 카드 요소 선택(Elements 왼쪽 상단 화살표 도구로 페이지에서 직접 클릭).
2. **Styles**에서 적용 우선순위 확인(취소선 규칙은 상쇄됨).
3. **Computed**에서 최종 계산값 확인(특히 `width/height/display/position`).
4. **Layout**(또는 Flex/Grid 패널)에서 Flex 컨테이너/아이템의 축·정렬·gap 확인.
5. 문제 CSS를 임시 수정 후, 재현되면 소스 파일에서 수정.

```css
/* 문제: 텍스트 overflow */
.card-title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
```

> 팁: 요소 우클릭 → **Copy → Copy selector**로 정확한 선택자 복사.

---

## 2. Styles / Computed / Layout — CSS 디버깅 집중

- **Styles**: 어떤 규칙이 어떤 파일/라인에서 왔는지, 우선순위 확인
- **Computed**: 상속·계산 결과(최종)가 무엇인지 확인
- **Layout**: 박스 모델, Flex/Grid 레이아웃 시각화, 갭/정렬 디버깅

### 실무 팁
- **Source Maps** 활성화로 SASS/LESS/TS → 원본 파일로 이동
- 포맷 관련 이슈는 **Prettier**로, 논리/우선순위는 **Elements/Styles**로

---

## 3. Console — 즉시 실행·로그·프로파일링

### 자주 쓰는 명령
```js
console.log('디버그');
console.table([{ id: 1, name: 'A' }, { id: 2, name: 'B' }]);
console.time('job'); /* ... */ console.timeEnd('job'); // 시간 측정
copy(window.__APP_STATE__); // 객체를 클립보드로 복사
$_; // 마지막 Elements 선택 요소
$0; // Elements에서 현재 선택된 노드
clear(); // 콘솔 정리
```

### 런타임 평가
- 페이지 컨텍스트에서 **표현식 평가**(전역 변수, DOM 접근 가능)
- **Live Expression**(핀 버튼)으로 FPS, 스크롤 위치 등 상시 표시

---

## 4. Sources — 브레이크포인트·스텝 실행·워치·콜스택

### 브레이크포인트 종류
- **라인**(일반): 좌측 라인 번호 클릭
- **조건부**: 우클릭 → *Add conditional breakpoint…* (`i > 20`)
- **XHR/Fetch**: Network Breakpoints → 특정 URL/패턴에서 중단
- **DOM**: Elements → 우클릭 → *Break on…* → subtree/attribute/Node removal
- **Event Listener**: Sources 오른쪽 → Event Listener Breakpoints (`click`, `promise`, `timer` 등)

### 디버깅 흐름
1. **Pause on exceptions**(⏸ 아이콘) 활성화: 에러 발생 지점에서 즉시 중단
2. **Step over / in / out**로 흐름 추적
3. **Scope/Watch**에서 변수 관찰, **Call Stack**으로 호출 경로 파악
4. 번들/라이브러리는 **Blackbox script** 처리로 소음 제거

```js
// 예: 조건부 브레이크가 유용한 케이스
function calc(items) {
  for (let i = 0; i < items.length; i++) {
    // i === 128 일 때만 멈춰 원인 추적
    total += items[i].price;
  }
}
```

---

## 5. Network — 요청/응답·CORS·캐시·성능

### 기본 워크플로
1. **Preserve log** 켜서 페이지 전환 중 로그 유지
2. 필터(`method:POST`, `status-code:>=400`, `-type:image`)로 탐색 최적화
3. 요청 클릭 → **Headers/Preview/Response/Timing** 탭 분석
4. **Throttling**: Slow 3G, Offline, 사용자 지정(레이턴시·MB/s)
5. **Disable cache**: DevTools 열려 있는 동안 캐시 비활성화

### 예제: 500 에러 원인 분석
- **Request Headers**에서 Authorization 누락 여부
- **Response** 메시지/스택(백엔드 에러) 확인
- **Timing**으로 서버 처리 시간 확인(TTFB 길면 서버 병목)
- **Initiator** 탭으로 어떤 코드가 요청을 발생시켰는지 추적

```js
// fetch 재시도 유틸로 네트워크 이슈 방어
async function fetchRetry(url, opts = {}, retry = 3) {
  for (let i = 0; i < retry; i++) {
    try {
      const res = await fetch(url, opts);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res;
    } catch (e) {
      if (i === retry - 1) throw e;
      await new Promise(r => setTimeout(r, 500 * (i + 1)));
    }
  }
}
```

---

## 6. Application — Storage·PWA·Service Worker

### Storage
- **LocalStorage/SessionStorage**: 키-값 확인·수정·삭제
- **IndexedDB**: 오프라인 DB 테이블, 인덱스, 레코드 조회
- **Cookies**: 도메인별 쿠키, `HttpOnly/Secure/SameSite` 확인, 만료/경로/도메인 점검

### Cache & SW
- **Cache Storage**: PWA 캐시 항목(요청/응답) 확인·삭제
- **Service Workers**: 등록/활성 상태, 업데이트/강제 재로드, 푸시/백그라운드 동기 시뮬레이션

### Manifest
- 앱 이름, 아이콘, 색상, 설치 가능성 확인

> 팁: “**Clear storage**”로 쿠키/스토리지/캐시 한 번에 정리(상태 꼬임 해결).

---

## 7. Performance — 렌더링/스크립트 병목과 프레임 드롭 찾기

### 분석 절차
1. **Record** 시작 → 실제 사용자 흐름 재현 → Stop
2. Timeline 상단: FPS, CPU, 힙 메모리 곡선 관찰
3. **Main** 트랙의 **Long Task**(빨간 막대, 50ms+) 확인
4. **Bottom-Up/Call Tree**로 함수별 소요 시간 분석
5. **Screenshots**로 프레임 스크린샷과 타이밍 연동

### 성능 코드 예시: 스크롤 이벤트 최적화
```js
// 나쁨: 매 스크롤마다 레이아웃 강제/무거운 작업
window.addEventListener('scroll', onScroll);

// 개선: passive + rAF 배치
let ticking = false;
window.addEventListener('scroll', () => {
  if (!ticking) {
    window.requestAnimationFrame(() => {
      onScroll();
      ticking = false;
    });
    ticking = true;
  }
}, { passive: true });

function onScroll() {
  const y = window.scrollY;
  // 클래스 토글 정도로 경량화
  document.body.classList.toggle('scrolled', y > 10);
}
```

---

## 8. Memory — 힙 스냅샷·할당 타임라인·누수 탐정

### 도구
- **Heap snapshot**: 현재 힙 상태를 스냅샷, Retainers(참조 보유자)로 누수 경로 분석
- **Allocation instrumentation on timeline**: 구간별 할당량 급증 추적
- **Detached DOM tree**: DOM은 제거됐지만 JS 참조가 남아 있는 노드 탐지

### 누수 예시와 해결
```js
// 문제: 리스너 해제 누락 → 요소 제거 후에도 함수 참조가 남아 누수
const btn = document.getElementById('download');
const handler = () => {/* ... */};
btn.addEventListener('click', handler);

// 해결: 제거 전 반드시 해제
btn.removeEventListener('click', handler);

// WeakMap으로 추가 메타데이터 관리(수명 자동 관리)
const meta = new WeakMap();
function attach(el, data) { meta.set(el, data); }
```

---

## 9. Lighthouse — 성능·접근성·SEO·PWA 품질 자동 점검

- **Performance**: LCP/FID/CLS 등 핵심 웹 지표(Core Web Vitals)
- **Accessibility**: aria 속성, 대비, label 누락
- **Best Practices/SEO/PWA**: HTTPS, 이미지 최적화, 메타 태그, 매니페스트

**보고서 활용법**
- “**Opportunities**”에서 이미지/폰트/JS 번들 크기, Lazy-loading, 코드스플리팅 제안
- 개선 내역 적용 후 **재측정**해 추세 관리

---

## 10. Security — HTTPS·CSP·Mixed Content·인증서

- **Security** 패널에서 인증서 체인·만료·암호군 확인
- **Mixed Content**(HTTPS 페이지에서 HTTP 리소스) 경고 해결: 모든 리소스 HTTPS화
- **CSP(Content-Security-Policy)** 적용 여부, 위반 로그(콘솔) 확인

---

## 11. Recorder — 사용자 흐름 캡처·재생·성능 연결

- 사용자 시나리오를 **녹화**하여 재생/공유 가능
- Recorder → Performance로 보내 **실제 흐름 기반 성능 분석**

---

## 12. Coverage — 미사용 CSS/JS 감축

- `Ctrl+Shift+P` → “**Show Coverage**”
- 미사용 퍼센트를 확인해 **코드 분할/동적 import**/CSS pruning 계획 수립

---

## 13. Rendering / Layers / Paint Flashing — 레이아웃·페인트 가시화

- **Rendering** 패널: Paint flashing, Layer borders, FPS meter
- **Layers**: 레이어 구성 확인(복잡한 3D 변환/컴포지팅 이슈에 유용)

---

## 14. 네트워크·스토리지 실전 시나리오

### A. CORS 오류
- **Network → Headers**에서 `Origin`/`Access-Control-Allow-Origin`/`credentials` 정책 점검
- 프리플라이트(OPTIONS) 응답 상태 확인

### B. 캐시 꼬임/오프라인
- **Disable cache**, **Application → Clear storage**
- Service Worker 업데이트 강제, Cache Storage 삭제

### C. 인증 만료/토큰 불일치
- 헤더 `Authorization` 값 비교, 응답 401/403 분류
- Refresh 흐름 중단 여부(중복 요청 폭주) Timings/Initiator로 파악

---

## 15. 디버깅/성능/메모리 통합 워크플로

1. **Network**로 오류/병목 파악 → Timings/Initiator/Headers
2. **Sources** 브레이크포인트로 원인 지점 중단 → 변수/콜스택 확인
3. **Performance**로 스크립트/레이아웃 병목 추적 → 함수/프레임 분석
4. **Memory**로 누수/과할당 확인 → Retainers로 경로 차단
5. **Lighthouse**로 종합 지표 개선 → 개선 항목 반복 적용

---

## 16. DevTools Snippets(자주 쓰는 코드 조각)

```js
// 1) Reflow(레이아웃 강제) 탐지에 도움: getBoundingClientRect 호출 감시
(function () {
  const orig = Element.prototype.getBoundingClientRect;
  Element.prototype.getBoundingClientRect = function (...args) {
    console.log('[reflow]', this);
    return orig.apply(this, args);
  };
})();

// 2) 이미지 LQIP 테스트: 모든 img를 blur 처리
[...document.images].forEach(img => img.style.filter = 'blur(2px)');

// 3) 긴 태스크 감지: 50ms 넘는 루프 경고
console.time('task');
/* 작업 */
console.timeEnd('task');
```

---

## 17. 키보드 단축키(요약)

- 열기/닫기: `F12`, `Ctrl+Shift+I` / `Cmd+Opt+I`
- 명령 팔레트: `Ctrl+Shift+P` / `Cmd+Shift+P`
- 선택 도구(요소 선택): `Ctrl+Shift+C` / `Cmd+Shift+C`
- 검색(파일/문자열): `Ctrl+P` / `Cmd+P`, `Ctrl+Shift+F` / `Cmd+Opt+F`
- 콘솔 열기: `Esc`로 **미니콘솔 Drawer** 토글

---

## 18. 체크리스트 — 팀 도입 가이드

- [ ] DevTools **Disable cache**, **Preserve log** 사용 습관화
- [ ] **Recorder**로 주요 사용자 흐름 캡처 → 회귀 테스트
- [ ] **Lighthouse** 점수 기준/OKR 설정(LCP/CLS 목표치)
- [ ] **Coverage**로 미사용 코드 검출 → 번들링 전략 개선
- [ ] **Service Worker**/Cache Storage 운영 메뉴얼(초기화/업데이트 절차)
- [ ] **CSP**/Security 기준 합의 및 보고 루틴

---

## 19. 트러블슈팅 패턴 모음

| 증상 | 패널 | 관찰 포인트 | 해결 방향 |
|---|---|---|---|
| 무한 로딩 | Network | 요청 지연, 재시도 루프 | 타임아웃/재시도 백오프, 캐시/오프라인 가드 |
| 렌더링 끊김 | Performance | Long Task, Layout thrash | rAF 배치, passive, 스타일/레이아웃 최소화 |
| 메모리 증가 | Memory | Detached DOM, Retainers | 이벤트 해제, WeakMap/FinalizationRegistry |
| 폰트 늦게 표시 | Network/Performance | TTFB/TTI, FOIT/FOUT | `font-display`, preload, 캐시 |
| CORS 실패 | Network | 프리플라이트/헤더 | 서버 CORS 설정, `credentials` 정책 정렬 |
| PWA 업데이트 안됨 | Application/SW | SW 상태, Cache | skipWaiting/clientsClaim, 캐시 버전 전략 |

---

## 20. 마무리

DevTools는 **문제의 원인까지 도달**하게 해주는 나침반입니다.
- **Elements/Styles/Computed**로 시각적 이슈를 즉시 재현·수정
- **Sources**로 코드 흐름을 멈춰 상태를 관찰
- **Network**로 API 헤더/응답/타이밍을 수술
- **Performance/Memory**로 프레임 드롭·누수를 정량화
- **Application/Lighthouse/Security**로 품질과 안전을 자동화

위 워크플로를 프로젝트 일상에 녹이면, 디버깅/최적화의 속도와 정확도가 눈에 띄게 향상됩니다.

---

## 부록: 실습용 미니 예제

### A) XHR Breakpoint로 토큰 주입 확인
```js
// app.js — fetch 래퍼
export async function api(path, opts = {}) {
  const headers = { ...(opts.headers || {}), Authorization: `Bearer ${localStorage.getItem('t')}` };
  const res = await fetch(`/api/${path}`, { ...opts, headers });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}
```
- Sources → **XHR/fetch Breakpoints**에 `/api/` 추가 → 중단 시 `headers.Authorization` 값 검증

### B) 성능 캡처 시나리오
1. Performance Record 시작
2. 무한 스크롤 페이지 끝까지 스크롤
3. Long Task/GC 스파이크 구간 확인 → 렌더러 병목 함수 최적화

### C) Heap Snapshot 누수 경로
- Memory → Heap snapshot 1
- 페이지에서 모달 열고 닫기 100회
- Heap snapshot 2 → 비교(Comparison) → Detached DOM 증가 확인 → close 핸들러에서 이벤트 해제 누락 수정

---

## 참고 링크
- Chrome DevTools 공식 문서: https://developer.chrome.com/docs/devtools/
- DevTools Tips: https://devtoolstips.org/
- Web Vitals: https://web.dev/vitals/
- Lighthouse: https://web.dev/measure/
- Core Performance Patterns: https://web.dev/fast/
