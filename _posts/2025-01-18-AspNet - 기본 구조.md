---
layout: post
title: AspNet - 기본 구조
date: 2025-01-18 20:20:23 +0900
category: AspNet
---
# ASP.NET Core Razor Pages & 기본 프로젝트 구조 통합 가이드

## 0. 개요 확장 — Razor Pages를 선택하는 이유

- **페이지 지향 설계**: URL과 물리 파일(`Pages/...cshtml`)이 일치하여 탐색성과 유지보수성이 높습니다.
- **MVC 대비 단순성**: 모델 바인딩/검증/태그 헬퍼/레이아웃 등 MVC의 장점을 그대로 사용하면서, **컨트롤러 계층이 생략**되어 개발 흐름이 직관적입니다.
- **CRUD에 최적**: 목록/보기/생성/수정/삭제가 **페이지-모델 한 쌍**으로 응집되어, 엔드투엔드 구현과 테스트가 수월합니다.
- **현대 .NET 기능**: Minimal hosting, DI/옵션 바인딩, 미들웨어 파이프라인, EF Core, Identity, Health Checks, OpenAPI 등과 자연스럽게 통합됩니다.

---

## 1. 기본 프로젝트 구조 — 제공 내용 보강

사용자 제공 구조:

```
MyApp/
├── Pages/
│   ├── Index.cshtml
│   ├── Index.cshtml.cs
│   ├── Error.cshtml
│   ├── Privacy.cshtml
│   ├── Shared/
│   │   ├── _Layout.cshtml
│   │   └── _ValidationScriptsPartial.cshtml
│   └── _ViewImports.cshtml
│
├── wwwroot/
│   ├── css/
│   ├── js/
│   └── favicon.ico
│
├── Properties/
│   └── launchSettings.json
│
├── Program.cs
├── Startup.cs
├── appsettings.json
├── appsettings.Development.json
├── MyApp.csproj
└── bin/, obj/
```

### 1.1 실전에서 자주 추가하는 구조

```
MyApp/
├── Data/
│   ├── AppDbContext.cs
│   └── Seed.cs
├── Models/
│   └── Product.cs
├── Services/
│   ├── IProductService.cs
│   └── ProductService.cs
├── Pages/
│   ├── Products/
│   │   ├── Index.cshtml         # 목록 + 검색 + 페이징
│   │   ├── Index.cshtml.cs
│   │   ├── Create.cshtml        # 생성
│   │   ├── Create.cshtml.cs
│   │   ├── Edit.cshtml          # 수정
│   │   ├── Edit.cshtml.cs
│   │   ├── Delete.cshtml        # 삭제 확인
│   │   ├── Delete.cshtml.cs
│   │   └── _ListPartial.cshtml  # 부분 렌더링
│   └── _ViewImports.cshtml
├── ViewComponents/
│   └── SummaryViewComponent.cs  # 재사용 UI 컴포넌트
├── Filters/
│   └── PageTimingFilter.cs      # IAsyncPageFilter 예제
└── ...
```

---

## 2. Program.cs — 최소 호스팅과 파이프라인 구성

```csharp
// Program.cs (.NET 8)
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

// 1) 서비스 등록
builder.Services.AddRazorPages(o =>
{
    // 예: 폴더 권한 정책 적용, 규칙 기반 라우트 보강 등
    o.Conventions.AuthorizeFolder("/Products", "AdminOnly");
    o.Conventions.AddPageRoute("/Products/Index", "/items"); // 추가 라우트
});
builder.Services.AddAuthorization(o =>
{
    o.AddPolicy("AdminOnly", p => p.RequireRole("Admin"));
});

builder.Services.AddDbContext<AppDbContext>(opt =>
    opt.UseSqlite(builder.Configuration.GetConnectionString("Default")));

builder.Services.AddScoped<IProductService, ProductService>();

// 관측성/헬스 체크
builder.Services.AddHealthChecks().AddDbContextCheck<AppDbContext>();

// 2) 앱 빌드
var app = builder.Build();

// 3) 파이프라인
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();

app.MapRazorPages();
app.MapHealthChecks("/health");

app.Run();
```

`appsettings.json`:

```json
{
  "ConnectionStrings": {
    "Default": "Data Source=app.db"
  },
  "Logging": {
    "LogLevel": { "Default": "Information" }
  },
  "AllowedHosts": "*"
}
```

---

## 3. Razor Pages 핵심 개념 확장

### 3.1 Page와 PageModel 한 쌍

```csharp
// Pages/Index.cshtml.cs
using Microsoft.AspNetCore.Mvc.RazorPages;

public class IndexModel : PageModel
{
    public string Message { get; private set; } = string.Empty;
    public void OnGet() => Message = "페이지가 로드되었습니다.";
}
```

```cshtml
@page
@model IndexModel
@{
    ViewData["Title"] = "홈";
}
<h1>@ViewData["Title"]</h1>
<p>@Model.Message</p>
```

### 3.2 라우팅 템플릿과 제약

```cshtml
@page "{id:int:min(1)}"
@model ProductModel
<h2>Product #@Model.Id</h2>
```

```csharp
public class ProductModel : PageModel
{
    public int Id { get; private set; }
    public void OnGet(int id) => Id = id;
}
```

### 3.3 핸들러(다중 핸들러 패턴)

```csharp
public IActionResult OnPostSubmit() { /* 저장 */ return RedirectToPage("Success"); }
public IActionResult OnPostPreview() { /* 미리보기 */ return Page(); }
```

```cshtml
<form method="post" asp-page-handler="Submit"> ... </form>
<form method="post" asp-page-handler="Preview"> ... </form>
```

---

## 4. 모델 바인딩·검증·안티포저리

```csharp
using System.ComponentModel.DataAnnotations;

public class ContactForm
{
    [Required, StringLength(50)]
    public string Name { get; set; } = string.Empty;

    [Required, EmailAddress]
    public string Email { get; set; } = string.Empty;
}

public class ContactModel : PageModel
{
    [BindProperty] public ContactForm Form { get; set; } = new();

    public IActionResult OnPost()
    {
        if (!ModelState.IsValid) return Page();
        // 처리 로직
        return RedirectToPage("Thanks");
    }
}
```

```cshtml
@page
@model ContactModel
<form method="post">
    <div>
        <label asp-for="Form.Name"></label>
        <input asp-for="Form.Name" />
        <span asp-validation-for="Form.Name"></span>
    </div>
    <div>
        <label asp-for="Form.Email"></label>
        <input asp-for="Form.Email" />
        <span asp-validation-for="Form.Email"></span>
    </div>
    <button type="submit">제출</button>
</form>

<partial name="_ValidationScriptsPartial" />
```

- Razor Pages는 기본적으로 **안티포저리 토큰**이 활성화되어 POST 요청을 보호합니다.
- 클라이언트 유효성은 `_ValidationScriptsPartial`로 활성화할 수 있습니다.

---

## 5. 레이아웃/부분뷰/뷰 컴포넌트

### 5.1 레이아웃

`Pages/Shared/_Layout.cshtml`:

```cshtml
<!DOCTYPE html>
<html>
<head>
    <title>@ViewData["Title"] - MyApp</title>
    <link rel="stylesheet" href="~/css/site.css" />
</head>
<body>
<header>
    <a asp-page="/Index">홈</a> |
    <a asp-page="/Products/Index">상품</a>
</header>
<main role="main" class="container">
    @RenderBody()
</main>
<footer>
    <partial name="_FooterPartial" />
</footer>
@RenderSection("Scripts", required: false)
</body>
</html>
```

`Pages/_ViewImports.cshtml`:

```cshtml
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
@namespace MyApp.Pages
```

### 5.2 부분뷰(Partial)

`Pages/Products/_ListPartial.cshtml`:

```cshtml
@model IEnumerable<Product>
<table>
  <thead><tr><th>Id</th><th>Name</th><th>Price</th></tr></thead>
  <tbody>
  @foreach (var p in Model)
  {
      <tr><td>@p.Id</td><td>@p.Name</td><td>@p.Price</td></tr>
  }
  </tbody>
</table>
```

사용:

```cshtml
<partial name="_ListPartial" model="Model.Items" />
```

### 5.3 뷰 컴포넌트

`ViewComponents/SummaryViewComponent.cs`:

```csharp
using Microsoft.AspNetCore.Mvc;

public class SummaryViewComponent : ViewComponent
{
    private readonly IProductService _svc;
    public SummaryViewComponent(IProductService svc) => _svc = svc;

    public async Task<IViewComponentResult> InvokeAsync()
    {
        var count = await _svc.CountAsync();
        return View("Default", count);
    }
}
```

`Views/Shared/Components/Summary/Default.cshtml`:

```cshtml
@model int
<div>총 상품 수: @Model</div>
```

사용:

```cshtml
@await Component.InvokeAsync("Summary")
```

---

## 6. EF Core로 CRUD 구현 — Razor Pages 정석 예제

### 6.1 DbContext/엔터티

```csharp
// Data/AppDbContext.cs
using Microsoft.EntityFrameworkCore;
public class AppDbContext : DbContext
{
    public DbSet<Product> Products => Set<Product>();
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }
}

// Models/Product.cs
using System.ComponentModel.DataAnnotations;
public class Product
{
    public int Id { get; set; }
    [Required, StringLength(80)] public string Name { get; set; } = string.Empty;
    [Range(0, int.MaxValue)] public int Price { get; set; }
}
```

### 6.2 서비스 계층

```csharp
// Services/IProductService.cs
public interface IProductService
{
    Task<int> CountAsync();
    Task<List<Product>> GetPagedAsync(int page, int size, string? q);
    Task<Product?> FindAsync(int id);
    Task<int> CreateAsync(Product p);
    Task UpdateAsync(Product p);
    Task DeleteAsync(int id);
}

// Services/ProductService.cs
using Microsoft.EntityFrameworkCore;
public class ProductService : IProductService
{
    private readonly AppDbContext _db;
    public ProductService(AppDbContext db) => _db = db;

    public Task<int> CountAsync() => _db.Products.CountAsync();

    public async Task<List<Product>> GetPagedAsync(int page, int size, string? q)
    {
        var query = _db.Products.AsNoTracking();
        if (!string.IsNullOrWhiteSpace(q))
            query = query.Where(p => p.Name.Contains(q));
        return await query
            .OrderBy(p => p.Id)
            .Skip((page - 1) * size)
            .Take(size)
            .ToListAsync();
    }

    public Task<Product?> FindAsync(int id) => _db.Products.FindAsync(id).AsTask();

    public async Task<int> CreateAsync(Product p)
    {
        _db.Add(p);
        await _db.SaveChangesAsync();
        return p.Id;
    }

    public Task UpdateAsync(Product p)
    {
        _db.Update(p);
        return _db.SaveChangesAsync();
    }

    public async Task DeleteAsync(int id)
    {
        var e = await _db.Products.FindAsync(id);
        if (e is null) return;
        _db.Remove(e);
        await _db.SaveChangesAsync();
    }
}
```

### 6.3 목록 페이지(검색+페이징)

`Pages/Products/Index.cshtml.cs`:

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

public class IndexModel : PageModel
{
    private readonly IProductService _svc;
    public IndexModel(IProductService svc) => _svc = svc;

    [BindProperty(SupportsGet = true)]
    public string? Q { get; set; }

    [BindProperty(SupportsGet = true)]
    public int Page { get; set; } = 1;

    public List<Product> Items { get; private set; } = new();
    public int Total { get; private set; }
    public int PageSize { get; } = 10;

    public async Task OnGetAsync()
    {
        Total = await _svc.CountAsync();
        Items = await _svc.GetPagedAsync(Page, PageSize, Q);
    }
}
```

`Pages/Products/Index.cshtml`:

```cshtml
@page
@model IndexModel
@{
    ViewData["Title"] = "Products";
}
<h1>Products</h1>

<form method="get" class="search">
    <input type="text" name="Q" value="@Model.Q" placeholder="검색어" />
    <button type="submit">검색</button>
</form>

<partial name="_ListPartial" model="Model.Items" />

<nav class="pager">
    @if (Model.Page > 1)
    {
        <a asp-page="./Index" asp-route-page="@(Model.Page - 1)" asp-route-q="@Model.Q">이전</a>
    }
    <span>Page @Model.Page</span>
    @if (Model.Items.Count == Model.PageSize)
    {
        <a asp-page="./Index" asp-route-page="@(Model.Page + 1)" asp-route-q="@Model.Q">다음</a>
    }
</nav>
```

### 6.4 생성/수정/삭제

`Pages/Products/Create.cshtml.cs`:

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

public class CreateModel : PageModel
{
    private readonly IProductService _svc;
    public CreateModel(IProductService svc) => _svc = svc;

    [BindProperty] public Product Item { get; set; } = new();

    public void OnGet() { }

    public async Task<IActionResult> OnPostAsync()
    {
        if (!ModelState.IsValid) return Page();
        var id = await _svc.CreateAsync(Item);
        TempData["Message"] = $"Created #{id}";
        return RedirectToPage("./Index");
    }
}
```

`Pages/Products/Edit.cshtml.cs`:

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

public class EditModel : PageModel
{
    private readonly IProductService _svc;
    public EditModel(IProductService svc) => _svc = svc;

    [BindProperty] public Product Item { get; set; } = new();

    public async Task<IActionResult> OnGetAsync(int id)
    {
        var e = await _svc.FindAsync(id);
        if (e is null) return NotFound();
        Item = e;
        return Page();
    }

    public async Task<IActionResult> OnPostAsync()
    {
        if (!ModelState.IsValid) return Page();
        await _svc.UpdateAsync(Item);
        TempData["Message"] = $"Updated #{Item.Id}";
        return RedirectToPage("./Index");
    }
}
```

`Pages/Products/Delete.cshtml.cs`:

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

public class DeleteModel : PageModel
{
    private readonly IProductService _svc;
    public DeleteModel(IProductService svc) => _svc = svc;

    public Product? Item { get; private set; }

    public async Task<IActionResult> OnGetAsync(int id)
    {
        Item = await _svc.FindAsync(id);
        return Item is null ? NotFound() : Page();
    }

    public async Task<IActionResult> OnPostAsync(int id)
    {
        await _svc.DeleteAsync(id);
        TempData["Message"] = $"Deleted #{id}";
        return RedirectToPage("./Index");
    }
}
```

---

## 7. 파일 업로드/다운로드, 대용량 스트리밍

```csharp
public class UploadModel : PageModel
{
    [BindProperty] public IFormFile? File { get; set; }

    public async Task<IActionResult> OnPostAsync()
    {
        if (File is null || File.Length == 0) return Page();
        var path = Path.Combine("wwwroot/uploads", File.FileName);
        await using var fs = System.IO.File.Create(path);
        await File.CopyToAsync(fs);
        return RedirectToPage("Success");
    }
}
```

다운로드 핸들링은 컨트롤러 액션과 동일하게 `File(...)` 반환을 사용할 수 있습니다.

---

## 8. 보안 — 권한 부여 규칙, CORS, 헤더, XSRF

- **폴더 권한 부여**: `o.Conventions.AuthorizeFolder("/Products", "AdminOnly")`
- **개별 페이지 허용**: `o.Conventions.AllowAnonymousToPage("/Products/Index")`
- **정적 파일 보안 헤더**: 미들웨어에서 `X-Content-Type-Options`, `X-Frame-Options`, CSP 등을 추가
- **CORS**: API 혼합 시 `app.UseCors(...)`로 오리진/메서드/헤더 제어
- **XSRF**: 기본 활성화, API 호출 시 토큰 전달 규칙 점검

---

## 9. 성능 — 캐싱/압축/레이트리밋/쿼리 최적화

- 응답 압축 `AddResponseCompression` + `UseResponseCompression`
- 메모리 캐시(`IMemoryCache`) 혹은 분산 캐시(Redis)
- 레이트 리미팅(`AddRateLimiter`)으로 페이지 그룹 보호
- EF Core 최적화: Projection, AsNoTracking, 인덱스, 페이지네이션, N+1 회피

간단 캐싱 예:

```csharp
app.MapGet("/time", (IMemoryCache cache) =>
{
    if (!cache.TryGetValue("now", out string? value))
    {
        value = DateTime.UtcNow.ToString("O");
        cache.Set("now", value, TimeSpan.FromSeconds(10));
    }
    return Results.Text(value);
});
```

---

## 10. 필터와 횡단 관심사 — IAsyncPageFilter

```csharp
// Filters/PageTimingFilter.cs
using Microsoft.AspNetCore.Mvc.Filters;
public class PageTimingFilter : IAsyncPageFilter
{
    private readonly ILogger<PageTimingFilter> _log;
    public PageTimingFilter(ILogger<PageTimingFilter> log) => _log = log;

    public Task OnPageHandlerSelectionAsync(PageHandlerSelectedContext context) => Task.CompletedTask;

    public async Task OnPageHandlerExecutionAsync(PageHandlerExecutingContext context, PageHandlerExecutionDelegate next)
    {
        var sw = System.Diagnostics.Stopwatch.StartNew();
        var resultCtx = await next();
        sw.Stop();
        _log.LogInformation("Page {Page} took {Elapsed} ms",
            context.ActionDescriptor.DisplayName, sw.ElapsedMilliseconds);
    }
}
```

등록:

```csharp
builder.Services.AddRazorPages(o => o.Conventions.AddFolderApplicationModelConvention("/", model =>
{
    // 필요 시 세부 조정
}))
.AddMvcOptions(o => o.Filters.Add<PageTimingFilter>());
```

---

## 11. 로컬라이제이션(국제화)와 시간대

```csharp
builder.Services.AddLocalization();
builder.Services.Configure<RequestLocalizationOptions>(opt =>
{
    var supported = new[] { "ko-KR", "en-US" }.Select(c => new System.Globalization.CultureInfo(c)).ToList();
    opt.DefaultRequestCulture = new("ko-KR");
    opt.SupportedCultures = supported;
    opt.SupportedUICultures = supported;
});
app.UseRequestLocalization();
```

페이지에서:

```cshtml
@inject Microsoft.AspNetCore.Mvc.Localization.IViewLocalizer L
<h2>@L["Products"]</h2>
```

---

## 12. 테스트 — Razor Pages 단위/통합

xUnit + `WebApplicationFactory` 사용:

```csharp
using Microsoft.AspNetCore.Mvc.Testing;
using Xunit;

public class PagesTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public PagesTests(WebApplicationFactory<Program> f) => _client = f.CreateClient();

    [Fact]
    public async Task Index_Page_Loads()
    {
        var html = await _client.GetStringAsync("/Products");
        Assert.Contains("Products", html);
    }
}
```

---

## 13. 배포 — Docker/Nginx/GitHub Actions

### 13.1 Dockerfile

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY . .
RUN dotnet publish -c Release -o /out

FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build /out .
ENV ASPNETCORE_URLS=http://+:8080
EXPOSE 8080
ENTRYPOINT ["dotnet", "MyApp.dll"]
```

### 13.2 Nginx 리버스 프록시

```nginx
server {
  listen 80;
  server_name example.com;
  location / {
    proxy_pass http://app:8080;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
  }
}
```

### 13.3 GitHub Actions(요지)

```yaml
name: ci
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-dotnet@v4
      with: { dotnet-version: '8.0.x' }
    - run: dotnet restore
    - run: dotnet build -c Release --no-restore
    - run: dotnet test --no-build
    - run: dotnet publish -c Release -o out
```

---

## 14. Razor Class Library(RCL)와 재사용

- 공통 레이아웃/부분 뷰/태그헬퍼/리소스를 **RCL**로 묶어 여러 앱에서 재사용
- 디자인 시스템/관리 UI/폼 위젯을 공통화하기에 적합

---

## 15. Razor Pages와 API 혼합 — Minimal API/SignalR와 병행

- 같은 호스트에서 `app.MapRazorPages()`와 `app.MapGet("/api/...")`를 공존시켜 **페이지+API** 구성을 단일 프로세스에서 운영
- 대화형 페이지는 **SignalR** 허브를 연결하여 실시간 갱신(알림/진행bar/모니터링)에 활용

```csharp
builder.Services.AddSignalR();
app.MapHub<NotifyHub>("/hubs/notify");
```

---

## 16. 운영 팁 — 흔한 함정/체크리스트

- `UseAuthentication()`은 반드시 `UseAuthorization()` 앞
- CORS에서 `AllowAnyOrigin`과 `AllowCredentials` 동시 사용 금지
- Razor Pages의 POST는 기본 XSRF 보호. API 호출과 섞일 때 토큰 전달 규칙 점검
- EF Core N+1 예방: `.Include` 남용 대신 Projection, `AsNoTracking`
- Swagger는 페이지 앱과 공존 시 **민감 엔드포인트** 노출에 주의(환경 제한)

---

## 17. 예제 실행 요약 명령

```bash
# 템플릿
dotnet new webapp -n MyApp
cd MyApp

# 패키지
dotnet add package Microsoft.EntityFrameworkCore.Sqlite
dotnet add package Microsoft.EntityFrameworkCore.Design

# DB 마이그레이션
dotnet ef migrations add Init
dotnet ef database update

# 실행
dotnet run
```

---

## 18. 결론

- 본 가이드는 사용자가 제공한 **Razor Pages 개요**를 토대로, **.NET 8 기준 실무 설계/코드 예제/운영 요소**를 **추가·확장**했습니다.
- 소규모 CRUD는 **Razor Pages**로 빠르게 시작하고, 필요에 따라 **서비스/필터/뷰 컴포넌트/RCL**로 재사용성을 높이고, **API·SignalR·헬스 체크·관측성**을 더해 점진적으로 확장하십시오.
- 배포 환경은 기본적으로 **Docker + 리버스 프록시(Nginx/IIS)**를 표준으로, 환경설정과 비밀은 **appsettings + Secret Manager/Key Vault**를 사용해 안전하게 관리하십시오.

이 가이드의 코드 조각들을 프로젝트에 바로 옮겨 적용하면, **Razor Pages 중심의 안정적인 기본 골격**을 짧은 시간에 갖출 수 있습니다.
