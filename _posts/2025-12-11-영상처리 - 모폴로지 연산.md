---
layout: post
title: 영상처리 - 모폴로지 연산 (C#)
date: 2025-12-11 17:30:23 +0900
category: 영상처리
---
# 모폴로지 연산

## 모폴로지 연산의 개요

모폴로지(Morphology)는 **집합론(Set Theory)** 과 **격자 이론(Lattice Theory)** 을 기반으로 영상의 형상(shape)을 분석하고 조작하는 기법이다. 이 용어는 생물학적 형태학(morphology)에서 유래했으며, Georges Matheron과 Jean Serra가 1960년대에 수학적 기초를 확립했다.

### 모폴로지의 핵심 개념

```
모폴로지 처리 파이프라인:
원본 영상 → 구조 요소 정의 → 모폴로지 연산 적용 → 결과 영상
                      ↓
                형상 분석/조작 목적에 맞춤
```

### 응용 분야

| 분야 | 응용 | 주요 연산 |
|------|------|-----------|
| **의료 영상** | 세포 분할, 혈관 추출 | 침식/팽창, 열기/닫기 |
| **문서 처리** | 문자 분리, 노이즈 제거 | 열기, 모폴로지 재구성 |
| **산업 검사** | 결함 검출, 부품 측정 | 경계 추출, 두껍게 하기 |
| **위성 영상** | 도로 추출, 토지 분류 | 스켈레톤화, 모폴로지 그라디언트 |
| **자율주행** | 장애물 인식, 차선 감지 | 침식, 열기 |

---

## 집합론 기반 이론

### 기본 정의

이진 영상 $A$를 공간 $E$의 부분집합으로 정의:
$$
A \subseteq E, \quad E = \mathbb{Z}^2 \text{ (2D 격자 공간)}
$$

구조 요소(Structuring Element) $B$는 일반적으로 원점을 포함하는 작은 집합:
$$
B \subseteq E, \quad \text{원점 } O \in B
$$

### 평행 이동(Translation)

집합 $A$를 벡터 $x$만큼 평행 이동:
$$
A_x = \{ a + x \mid a \in A \}
$$

### 반사(Reflection)

집합 $B$의 반사:
$$
\hat{B} = \{ -b \mid b \in B \}
$$

---

## 구조 요소 (Structuring Element)

### 구조 요소 유형 비교표

| 유형 | 모양 | 마스크 예시 | 특성 | 용도 |
|------|------|------------|------|------|
| **사각형** | 정사각형 | 3×3 모두 1 | 등방성, 구현 간단 | 일반적 침식/팽창 |
| **십자형** | 십자 | 3×3 십자 | 4-연결성 유지 | 세밀한 형상 보존 |
| **원형** | 원 (근사) | 원판 마스크 | 등방성, 부드러운 경계 | 잡음 제거 |
| **선형** | 선분 | 1×n 또는 n×1 | 방향성 필터링 | 특정 방향 확장 |
| **사용자 정의** | 임의 형태 | 비대칭 마스크 | 특수 목적 | 전문적 응용 |

### 구조 요소 시각화

```
사각형(3×3)     십자형(3×3)      원형(반지름 2)    선형(수평, 길이 5)
1 1 1          0 1 0          0 0 1 0 0        1 1 1 1 1
1 1 1          1 1 1          0 1 1 1 0
1 1 1          0 1 0          1 1 1 1 1
                            0 1 1 1 0
                            0 0 1 0 0
```

### C# 구조 요소 구현

```csharp
public enum StructuringElementType
{
    Rectangle,      // 사각형
    Cross,          // 십자형
    Disk,           // 원형
    LineHorizontal, // 수평선
    LineVertical,   // 수직선
    Custom          // 사용자 정의
}

public class StructuringElement
{
    public int[,] Mask { get; private set; }
    public int Width { get; private set; }
    public int Height { get; private set; }
    public Point Anchor { get; private set; }
    public StructuringElementType Type { get; private set; }
    
    // 다양한 구조 요소 생성자
    public StructuringElement(StructuringElementType type, int size)
    {
        Type = type;
        
        switch (type)
        {
            case StructuringElementType.Rectangle:
                CreateRectangle(size, size);
                break;
            case StructuringElementType.Cross:
                CreateCross(size);
                break;
            case StructuringElementType.Disk:
                CreateDisk(size);
                break;
            default:
                throw new ArgumentException("Unsupported element type");
        }
        
        // 기본 앵커는 중심
        Anchor = new Point(Width / 2, Height / 2);
    }
    
    public StructuringElement(int[,] customMask, Point anchor)
    {
        Type = StructuringElementType.Custom;
        Mask = customMask;
        Height = customMask.GetLength(0);
        Width = customMask.GetLength(1);
        Anchor = anchor;
    }
    
    private void CreateRectangle(int width, int height)
    {
        Width = width;
        Height = height;
        Mask = new int[height, width];
        
        for (int y = 0; y < height; y++)
            for (int x = 0; x < width; x++)
                Mask[y, x] = 1;
    }
    
    private void CreateCross(int size)
    {
        // size는 십자의 팔 길이 (중심 포함 전체 크기: 2*size+1)
        int fullSize = 2 * size + 1;
        Width = Height = fullSize;
        Mask = new int[fullSize, fullSize];
        
        int center = size;
        for (int i = 0; i < fullSize; i++)
        {
            Mask[center, i] = 1; // 수평선
            Mask[i, center] = 1; // 수직선
        }
    }
    
    private void CreateDisk(int radius)
    {
        int diameter = 2 * radius + 1;
        Width = Height = diameter;
        Mask = new int[diameter, diameter];
        
        int center = radius;
        double radiusSquared = radius * radius;
        
        for (int y = 0; y < diameter; y++)
        {
            for (int x = 0; x < diameter; x++)
            {
                double distanceSquared = Math.Pow(x - center, 2) + Math.Pow(y - center, 2);
                if (distanceSquared <= radiusSquared + 0.5) // 0.5는 반올림을 위한 여유
                {
                    Mask[y, x] = 1;
                }
            }
        }
    }
    
    // 구조 요소 반사 계산
    public StructuringElement GetReflected()
    {
        int[,] reflectedMask = new int[Height, Width];
        
        for (int y = 0; y < Height; y++)
        {
            for (int x = 0; x < Width; x++)
            {
                int reflectedX = Width - 1 - x;
                int reflectedY = Height - 1 - y;
                reflectedMask[reflectedY, reflectedX] = Mask[y, x];
            }
        }
        
        Point reflectedAnchor = new Point(Width - 1 - Anchor.X, Height - 1 - Anchor.Y);
        return new StructuringElement(reflectedMask, reflectedAnchor);
    }
}
```

---

## 기본 모폴로지 연산

### 침식(Erosion) - 상세 이론

침식은 구조 요소 $B$가 영상 $A$ 안에 **완전히 포함되는 위치만 남기는 연산**이다.

**수학적 정의:**
$$
A \ominus B = \{ x \mid B_x \subseteq A \} = \bigcap_{b \in B} A_{-b}
$$

**해석:** 모든 $b \in B$에 대해 $x - b \in A$인 점 $x$의 집합

**효과:**
- 객체 축소 (경계가 안쪽으로 수축)
- 얇은 연결부 제거
- 작은 노이즈(흰 점) 제거
- 객체 분리

```
침식 효과 시각화:
원본:        침식 후:
██████       ████
██████  →    ████
██████       ████
(객체의 모든 경계가 안쪽으로 1픽셀 축소)
```

### 팽창(Dilation) - 상세 이론

팽창은 구조 요소 $B$가 영상 $A$와 **한 점이라도 겹치면 포함시키는 연산**이다.

**수학적 정의:**
$$
A \oplus B = \{ x \mid (\hat{B})_x \cap A \neq \varnothing \} = \bigcup_{b \in B} A_b
$$

**해석:** 적어도 하나의 $b \in B$에 대해 $x + b \in A$인 점 $x$의 집합

**효과:**
- 객체 확대 (경계가 바깥쪽으로 확장)
- 틈과 구멍 메움
- 끊어진 영역 연결
- 객체 병합

```
팽창 효과 시각화:
원본:        팽창 후:
  ██         █████
  ██   →     █████
            █████
(객체의 모든 경계가 바깥쪽으로 1픽셀 확장)
```

### 고성능 모폴로지 연산 구현

```csharp
public class MorphologicalOperator
{
    // 최적화된 침식 연산 (LockBits 사용)
    public unsafe Bitmap ErodeOptimized(Bitmap src, StructuringElement se)
    {
        Bitmap dst = new Bitmap(src.Width, src.Height);
        Rectangle rect = new Rectangle(0, 0, src.Width, src.Height);
        
        BitmapData srcData = src.LockBits(rect, 
            ImageLockMode.ReadOnly, PixelFormat.Format8bppIndexed);
        BitmapData dstData = dst.LockBits(rect,
            ImageLockMode.WriteOnly, PixelFormat.Format8bppIndexed);
        
        int srcStride = srcData.Stride;
        int dstStride = dstData.Stride;
        byte* srcPtr = (byte*)srcData.Scan0;
        byte* dstPtr = (byte*)dstData.Scan0;
        
        int seHeight = se.Height;
        int seWidth = se.Width;
        int anchorX = se.Anchor.X;
        int anchorY = se.Anchor.Y;
        
        // 병렬 처리 (여러 스레드 사용)
        Parallel.For(0, src.Height, y =>
        {
            byte* srcRow = srcPtr + (y * srcStride);
            byte* dstRow = dstPtr + (y * dstStride);
            
            for (int x = 0; x < src.Width; x++)
            {
                bool shouldErode = true;
                
                // 구조 요소 적용
                for (int j = 0; j < seHeight; j++)
                {
                    int ny = y + j - anchorY;
                    
                    // 행 경계 검사
                    if (ny < 0 || ny >= src.Height)
                    {
                        shouldErode = false;
                        break;
                    }
                    
                    byte* neighborRow = srcPtr + (ny * srcStride);
                    
                    for (int i = 0; i < seWidth; i++)
                    {
                        if (se.Mask[j, i] == 0) continue;
                        
                        int nx = x + i - anchorX;
                        
                        // 열 경계 검사
                        if (nx < 0 || nx >= src.Width)
                        {
                            shouldErode = false;
                            break;
                        }
                        
                        // 해당 위치의 픽셀이 배경(0)이면 침식 불가
                        if (neighborRow[nx] == 0)
                        {
                            shouldErode = false;
                            break;
                        }
                    }
                    
                    if (!shouldErode) break;
                }
                
                dstRow[x] = shouldErode ? (byte)255 : (byte)0;
            }
        });
        
        src.UnlockBits(srcData);
        dst.UnlockBits(dstData);
        
        return dst;
    }
    
    // 최적화된 팽창 연산
    public unsafe Bitmap DilateOptimized(Bitmap src, StructuringElement se)
    {
        Bitmap dst = new Bitmap(src.Width, src.Height);
        Rectangle rect = new Rectangle(0, 0, src.Width, src.Height);
        
        BitmapData srcData = src.LockBits(rect,
            ImageLockMode.ReadOnly, PixelFormat.Format8bppIndexed);
        BitmapData dstData = dst.LockBits(rect,
            ImageLockMode.WriteOnly, PixelFormat.Format8bppIndexed);
        
        int srcStride = srcData.Stride;
        int dstStride = dstData.Stride;
        byte* srcPtr = (byte*)srcData.Scan0;
        byte* dstPtr = (byte*)dstData.Scan0;
        
        int seHeight = se.Height;
        int seWidth = se.Width;
        int anchorX = se.Anchor.X;
        int anchorY = se.Anchor.Y;
        
        // 팽창의 경우 먼저 모든 픽셀을 0으로 초기화
        for (int y = 0; y < src.Height; y++)
        {
            byte* dstRow = dstPtr + (y * dstStride);
            for (int x = 0; x < src.Width; x++)
            {
                dstRow[x] = 0;
            }
        }
        
        // 병렬 처리: 각 전경 픽셀 주변에 구조 요소 적용
        Parallel.For(0, src.Height, y =>
        {
            byte* srcRow = srcPtr + (y * srcStride);
            
            for (int x = 0; x < src.Width; x++)
            {
                if (srcRow[x] == 0) continue; // 배경 픽셀 무시
                
                // 전경 픽셀 발견: 주변에 구조 요소 적용
                for (int j = 0; j < seHeight; j++)
                {
                    int ny = y + j - anchorY;
                    if (ny < 0 || ny >= src.Height) continue;
                    
                    byte* dstRow = dstPtr + (ny * dstStride);
                    
                    for (int i = 0; i < seWidth; i++)
                    {
                        if (se.Mask[j, i] == 0) continue;
                        
                        int nx = x + i - anchorX;
                        if (nx < 0 || nx >= src.Width) continue;
                        
                        dstRow[nx] = 255; // 팽창 결과
                    }
                }
            }
        });
        
        src.UnlockBits(srcData);
        dst.UnlockBits(dstData);
        
        return dst;
    }
    
    // 분해 가능한 구조 요소를 위한 빠른 팽창 (선형 분해 활용)
    public unsafe Bitmap FastDilation(Bitmap src, StructuringElement se)
    {
        // 구조 요소가 분해 가능한 경우 (예: 사각형 = 수평선 + 수직선)
        if (CanDecompose(se))
        {
            // 1D 구조 요소로 분해하여 연산
            var decomposed = DecomposeElement(se);
            Bitmap temp = src;
            
            foreach (var element in decomposed)
            {
                temp = DilateOptimized(temp, element);
            }
            
            return temp;
        }
        else
        {
            return DilateOptimized(src, se);
        }
    }
    
    private bool CanDecompose(StructuringElement se)
    {
        // 분해 가능성 검사 로직
        // 예: 사각형, 십자형 등은 선형 구조 요소의 조합으로 분해 가능
        return se.Type == StructuringElementType.Rectangle || 
               se.Type == StructuringElementType.Cross;
    }
    
    private List<StructuringElement> DecomposeElement(StructuringElement se)
    {
        var result = new List<StructuringElement>();
        
        if (se.Type == StructuringElementType.Rectangle)
        {
            // 사각형을 수평선과 수직선으로 분해
            int[,] horizontal = new int[1, se.Width];
            int[,] vertical = new int[se.Height, 1];
            
            for (int i = 0; i < se.Width; i++) horizontal[0, i] = 1;
            for (int i = 0; i < se.Height; i++) vertical[i, 0] = 1;
            
            result.Add(new StructuringElement(horizontal, new Point(se.Width/2, 0)));
            result.Add(new StructuringElement(vertical, new Point(0, se.Height/2)));
        }
        
        return result;
    }
}
```

### 열기(Opening) 연산 - 상세 이론

열기는 **침식 후 팽창**으로 정의된다.

**수학적 정의:**
$$
A \circ B = (A \ominus B) \oplus B
$$

**특성 (단조성, 증가성, 멱등성):**
1. $A \circ B \subseteq A$ (축소)
2. $(A \circ B) \circ B = A \circ B$ (멱등성)
3. $A_1 \subseteq A_2 \Rightarrow A_1 \circ B \subseteq A_2 \circ B$ (증가성)

**효과:**
- 작은 노이즈(흰 점) 제거
- 얇은 연결부 제거
- 객체의 전체적인 형태 유지
- 배경과 전경 분리 개선

```
열기 효과 시각화:
원본 (잡음 있음):    열기 후:
█ █ █                ███
 ███          →      ███
█ █ █                ███
(작은 노이즈 제거, 객체 형상 유지)
```

### 닫기(Closing) 연산 - 상세 이론

닫기는 **팽창 후 침식**으로 정의된다.

**수학적 정의:**
$$
A \bullet B = (A \oplus B) \ominus B
$$

**특성:**
1. $A \subseteq A \bullet B$ (확대)
2. $(A \bullet B) \bullet B = A \bullet B$ (멱등성)

**효과:**
- 작은 구멍과 틈 메우기
- 끊어진 경계 연결
- 객체 내부 결함 복원
- 배경 노이즈(검은 점) 제거

```
닫기 효과 시각화:
원본 (구멍 있음):    닫기 후:
████                ████
█  █         →      ████
████                ████
(내부 구멍 메움, 객체 완전성 복원)
```

### 열기/닫기 구현 및 비교

```csharp
public class AdvancedMorphology
{
    private MorphologicalOperator _operator = new MorphologicalOperator();
    
    public Bitmap Opening(Bitmap src, StructuringElement se, int iterations = 1)
    {
        Bitmap result = src;
        
        for (int i = 0; i < iterations; i++)
        {
            Bitmap eroded = _operator.ErodeOptimized(result, se);
            result = _operator.DilateOptimized(eroded, se);
        }
        
        return result;
    }
    
    public Bitmap Closing(Bitmap src, StructuringElement se, int iterations = 1)
    {
        Bitmap result = src;
        
        for (int i = 0; i < iterations; i++)
        {
            Bitmap dilated = _operator.DilateOptimized(result, se);
            result = _operator.ErodeOptimized(dilated, se);
        }
        
        return result;
    }
    
    // 토폴로지적 열기/닫기 (형상 기반)
    public Bitmap TopologicalOpening(Bitmap src, int minSize)
    {
        // 연결 성분 레이블링 후 작은 객체 제거
        var labeler = new ConnectedComponentLabeler();
        var result = labeler.Label(src, ConnectedComponentLabeler.Connectivity.Eight);
        
        Bitmap dst = new Bitmap(src.Width, src.Height);
        using (Graphics g = Graphics.FromImage(dst))
        {
            g.Clear(Color.Black);
            
            foreach (var component in result.Components)
            {
                if (component.Value.Count >= minSize)
                {
                    foreach (Point p in component.Value)
                    {
                        dst.SetPixel(p.X, p.Y, Color.White);
                    }
                }
            }
        }
        
        return dst;
    }
    
    // 모폴로지 연산 시각화 도구
    public Bitmap VisualizeMorphology(Bitmap src, StructuringElement se, 
                                      string operation, int step = 0)
    {
        Bitmap visualization = new Bitmap(src.Width * 2, src.Height * 2);
        using (Graphics g = Graphics.FromImage(visualization))
        {
            // 원본
            g.DrawImage(src, 0, 0, src.Width, src.Height);
            g.DrawString("Original", SystemFonts.DefaultFont, Brushes.White, 5, 5);
            
            // 중간 결과
            if (operation == "opening" || operation == "closing")
            {
                Bitmap intermediate;
                if (operation == "opening")
                {
                    intermediate = _operator.ErodeOptimized(src, se);
                    g.DrawImage(intermediate, src.Width, 0, src.Width, src.Height);
                    g.DrawString("Eroded", SystemFonts.DefaultFont, Brushes.White, 
                                src.Width + 5, 5);
                    
                    intermediate = _operator.DilateOptimized(intermediate, se);
                    g.DrawImage(intermediate, 0, src.Height, src.Width, src.Height);
                    g.DrawString("Opened", SystemFonts.DefaultFont, Brushes.White, 
                                5, src.Height + 5);
                }
                else // closing
                {
                    intermediate = _operator.DilateOptimized(src, se);
                    g.DrawImage(intermediate, src.Width, 0, src.Width, src.Height);
                    g.DrawString("Dilated", SystemFonts.DefaultFont, Brushes.White, 
                                src.Width + 5, 5);
                    
                    intermediate = _operator.ErodeOptimized(intermediate, se);
                    g.DrawImage(intermediate, 0, src.Height, src.Width, src.Height);
                    g.DrawString("Closed", SystemFonts.DefaultFont, Brushes.White, 
                                5, src.Height + 5);
                }
            }
            
            // 구조 요소 표시
            DrawStructuringElement(g, se, src.Width, src.Height);
        }
        
        return visualization;
    }
    
    private void DrawStructuringElement(Graphics g, StructuringElement se, int offsetX, int offsetY)
    {
        int cellSize = 20;
        int startX = offsetX + 10;
        int startY = offsetY + 10;
        
        // 구조 요소 그리드
        for (int y = 0; y < se.Height; y++)
        {
            for (int x = 0; x < se.Width; x++)
            {
                Rectangle rect = new Rectangle(
                    startX + x * cellSize,
                    startY + y * cellSize,
                    cellSize, cellSize);
                
                if (se.Mask[y, x] == 1)
                {
                    g.FillRectangle(Brushes.White, rect);
                }
                else
                {
                    g.FillRectangle(Brushes.Gray, rect);
                }
                
                g.DrawRectangle(Pens.Black, rect);
                
                // 앵커 표시
                if (x == se.Anchor.X && y == se.Anchor.Y)
                {
                    g.DrawEllipse(Pens.Red, rect);
                }
            }
        }
        
        g.DrawString("Structuring Element", SystemFonts.DefaultFont, 
                    Brushes.White, startX, startY + se.Height * cellSize + 5);
    }
}
```

---

## 고급 모폴로지 연산

### 모폴로지 연산 표

| 연산 | 수학적 정의 | 효과 | 주요 응용 |
|------|------------|------|-----------|
| **침식** | $A \ominus B$ | 객체 축소, 노이즈 제거 | 세포 분리, 작은 객체 제거 |
| **팽창** | $A \oplus B$ | 객체 확장, 틈 메움 | 문자 연결, 구멍 복구 |
| **열기** | $(A \ominus B) \oplus B$ | 작은 노이즈 제거 | 문서 정리, 전처리 |
| **닫기** | $(A \oplus B) \ominus B$ | 작은 구멍 메움 | 객체 완성화 |
| **히트-오어-미스** | $(A \ominus B_1) \cap (A^c \ominus B_2)$ | 특정 패턴 탐지 | 템플릿 매칭 |
| **모폴로지 그라디언트** | $(A \oplus B) \setminus (A \ominus B)$ | 경계 추출 | 객체 윤곽선 |
| **토햇 변환** | $A \setminus (A \circ B)$ | 작은 객체 분리 | 병변 검출 |
| **블랙햇 변환** | $(A \bullet B) \setminus A$ | 어두운 객체 검출 | 구멍 감지 |

### 히트-오어-미스(Hit-or-Miss) 변환

특정 패턴(구조 요소 쌍)을 정확히 찾는 연산:

**수학적 정의:**
$$
A \otimes (B_1, B_2) = (A \ominus B_1) \cap (A^c \ominus B_2)
$$

여기서 $B_1$은 전경에 일치, $B_2$는 배경에 일치해야 하는 패턴.

```csharp
public Bitmap HitOrMiss(Bitmap src, StructuringElement hitElement, 
                        StructuringElement missElement)
{
    // 히트: 전경 패턴 일치
    Bitmap hitResult = ErodeOptimized(src, hitElement);
    
    // 미스: 배경 패턴 일치 (원본의 보수 사용)
    Bitmap complement = GetComplement(src);
    Bitmap missResult = ErodeOptimized(complement, missElement);
    
    // 논리 AND 연산
    return LogicalAnd(hitResult, missResult);
}

private Bitmap GetComplement(Bitmap src)
{
    Bitmap result = new Bitmap(src.Width, src.Height);
    
    for (int y = 0; y < src.Height; y++)
    {
        for (int x = 0; x < src.Width; x++)
        {
            int value = src.GetPixel(x, y).R;
            int complement = 255 - value;
            result.SetPixel(x, y, Color.FromArgb(complement, complement, complement));
        }
    }
    
    return result;
}
```

### 모폴로지 그라디언트(Morphological Gradient)

객체 경계를 추출하는 연산:

**세 가지 변형:**
1. 외부 경계: $(A \oplus B) \setminus A$
2. 내부 경계: $A \setminus (A \ominus B)$
3. 전체 경계: $(A \oplus B) \setminus (A \ominus B)$

```csharp
public Bitmap MorphologicalGradient(Bitmap src, StructuringElement se, 
                                    GradientType type = GradientType.Full)
{
    Bitmap dilated = DilateOptimized(src, se);
    Bitmap eroded = ErodeOptimized(src, se);
    
    switch (type)
    {
        case GradientType.External:
            return Subtract(dilated, src);
        case GradientType.Internal:
            return Subtract(src, eroded);
        case GradientType.Full:
            return Subtract(dilated, eroded);
        default:
            throw new ArgumentException("Invalid gradient type");
    }
}

public enum GradientType { External, Internal, Full }
```

### 모폴로지 재구성(Morphological Reconstruction)

마커 영상을 기반으로 마스크 영상을 재구성:

**수학적 정의 (기울기 재구성):**
$$
R_f^g(g) = \lim_{n \to \infty} \delta_f^{(n)}(g)
$$
여기서 $\delta_f(g) = (g \oplus B) \wedge f$

```csharp
public Bitmap MorphologicalReconstruction(Bitmap marker, Bitmap mask, 
                                          bool geodesicDilation = true)
{
    Bitmap previous = marker;
    Bitmap current = marker;
    
    do
    {
        previous = current;
        
        if (geodesicDilation)
        {
            // 지형 팽창
            current = DilateOptimized(current, new StructuringElement(
                StructuringElementType.Rectangle, 3));
            current = LogicalAnd(current, mask);
        }
        else
        {
            // 지형 침식
            current = ErodeOptimized(current, new StructuringElement(
                StructuringElementType.Rectangle, 3));
            current = LogicalOr(current, mask);
        }
    }
    while (!AreEqual(previous, current)); // 안정화될 때까지 반복
    
    return current;
}
```

### 세밀화(Thinning)와 두껍게 하기(Thickening)

세밀화는 객체를 골격(skeleton) 형태로 줄이는 연산:

**수학적 정의 (히트-오어-미스를 이용):**
$$
A \otimes \{B\} = A \setminus (A \otimes (B_1, B_2))
$$

```csharp
public Bitmap Thinning(Bitmap src, int iterations = 0)
{
    // 8가지 방향의 구조 요소 쌍 (Zhang-Suen 알고리즘)
    var hitMissPairs = GetThinningTemplates();
    
    Bitmap result = src.Clone() as Bitmap;
    Bitmap previous;
    int iter = 0;
    
    do
    {
        previous = result.Clone() as Bitmap;
        
        foreach (var pair in hitMissPairs)
        {
            Bitmap hitMiss = HitOrMiss(result, pair.Item1, pair.Item2);
            result = Subtract(result, hitMiss);
        }
        
        iter++;
    }
    while (!AreEqual(previous, result) && (iterations == 0 || iter < iterations));
    
    return result;
}

private List<Tuple<StructuringElement, StructuringElement>> GetThinningTemplates()
{
    // Zhang-Suen 세밀화 템플릿
    // 8가지 회전 패턴 정의
    var templates = new List<Tuple<StructuringElement, StructuringElement>>();
    
    // 예: 첫 번째 템플릿
    int[,] hit1 = {
        {0,0,0},
        {0,1,0},
        {1,1,1}
    };
    
    int[,] miss1 = {
        {1,1,1},
        {0,0,0},
        {0,0,0}
    };
    
    templates.Add(Tuple.Create(
        new StructuringElement(hit1, new Point(1,1)),
        new StructuringElement(miss1, new Point(1,1))
    ));
    
    // 추가 템플릿들...
    
    return templates;
}
```

### 스켈레톤화(Skeletonization)

객체의 토폴로지를 보존하면서 최소한의 표현으로 줄이는 연산:

**수학적 정의:**
$$
S(A) = \bigcup_{k=0}^{K} (A \ominus kB) \setminus [(A \ominus kB) \circ B]
$$
여기서 $A \ominus kB$는 $k$회 침식을 의미.

```csharp
public Bitmap Skeletonize(Bitmap src, StructuringElement se)
{
    List<Bitmap> skeletons = new List<Bitmap>();
    Bitmap eroded = src;
    
    do
    {
        Bitmap opened = Opening(eroded, se);
        Bitmap skeleton = Subtract(eroded, opened);
        skeletons.Add(skeleton);
        
        Bitmap previous = eroded;
        eroded = ErodeOptimized(eroded, se);
        
        // 더 이상 침식할 픽셀이 없으면 종료
        if (IsEmpty(eroded))
            break;
            
    } while (true);
    
    // 모든 스켈레톤 합성
    Bitmap finalSkeleton = new Bitmap(src.Width, src.Height);
    using (Graphics g = Graphics.FromImage(finalSkeleton))
    {
        g.Clear(Color.Black);
        
        foreach (Bitmap skeleton in skeletons)
        {
            for (int y = 0; y < skeleton.Height; y++)
            {
                for (int x = 0; x < skeleton.Width; x++)
                {
                    if (skeleton.GetPixel(x, y).R > 0)
                    {
                        finalSkeleton.SetPixel(x, y, Color.White);
                    }
                }
            }
        }
    }
    
    return finalSkeleton;
}
```

---

## 응용 분야 구현

### 1. 문서 이미지 전처리

```csharp
public class DocumentPreprocessor
{
    public Bitmap PreprocessDocument(Bitmap scannedDocument)
    {
        // 1. 적응형 이진화
        Bitmap binary = AdaptiveBinarize(scannedDocument);
        
        // 2. 모폴로지 열기로 작은 노이즈 제거
        StructuringElement se = new StructuringElement(StructuringElementType.Rectangle, 2);
        Bitmap cleaned = Opening(binary, se);
        
        // 3. 모폴로지 닫기로 문자 내부 구멍 메우기
        se = new StructuringElement(StructuringElementType.Cross, 1);
        cleaned = Closing(cleaned, se);
        
        // 4. 스켈레톤화로 필기체 분석 (선택적)
        if (IsHandwritten(cleaned))
        {
            cleaned = Thinning(cleaned);
        }
        
        return cleaned;
    }
}
```

### 2. 의료 영상 혈관 추출

```csharp
public class VesselExtractor
{
    public Bitmap ExtractVessels(Bitmap retinaImage)
    {
        // 1. 전처리: 가우시안 필터
        Bitmap smoothed = ApplyGaussianBlur(retinaImage, 1.5);
        
        // 2. 토햇 변환으로 작은 혈관 강조
        StructuringElement disk = new StructuringElement(StructuringElementType.Disk, 3);
        Bitmap tophat = TopHatTransform(smoothed, disk);
        
        // 3. 모폴로지 재구성으로 연결성 강화
        Bitmap marker = CreateVesselMarker(tophat);
        Bitmap reconstructed = MorphologicalReconstruction(marker, tophat);
        
        // 4. 세밀화로 혈관 골격 추출
        Bitmap skeleton = Thinning(reconstructed);
        
        return skeleton;
    }
    
    private Bitmap TopHatTransform(Bitmap src, StructuringElement se)
    {
        Bitmap opened = Opening(src, se);
        return Subtract(src, opened);
    }
}
```

### 3. 산업 검사 결함 검출

```csharp
public class DefectDetector
{
    public List<Rectangle> DetectDefects(Bitmap productImage, Bitmap templateImage)
    {
        // 1. 템플릿과 차이 계산
        Bitmap difference = CalculateDifference(productImage, templateImage);
        
        // 2. 블랙햇 변환으로 어두운 결함 검출
        StructuringElement se = new StructuringElement(StructuringElementType.Disk, 5);
        Bitmap blackhat = BlackHatTransform(difference, se);
        
        // 3. 이진화
        Bitmap binary = Threshold(blackhat, 30);
        
        // 4. 모폴로지 연산으로 결함 강화
        binary = Closing(binary, se); // 작은 결함 연결
        binary = Opening(binary, new StructuringElement(
            StructuringElementType.Rectangle, 2)); // 노이즈 제거
        
        // 5. 연결 성분 분석
        var labeler = new ConnectedComponentLabeler();
        var result = labeler.Label(binary, ConnectedComponentLabeler.Connectivity.Eight);
        
        return result.BoundingBoxes.Values.ToList();
    }
    
    private Bitmap BlackHatTransform(Bitmap src, StructuringElement se)
    {
        Bitmap closed = Closing(src, se);
        return Subtract(closed, src);
    }
}
```

---

## 성능 최적화 기법

### 1. 구조 요소 분해 (Decomposition)

대형 구조 요소를 작은 구조 요소로 분해하여 계산량 감소:

```csharp
public Bitmap FastMorphology(Bitmap src, StructuringElement se, string operation)
{
    if (CanDecompose(se))
    {
        var decomposed = DecomposeSE(se);
        Bitmap result = src;
        
        foreach (var element in decomposed)
        {
            if (operation == "erode")
                result = ErodeOptimized(result, element);
            else if (operation == "dilate")
                result = DilateOptimized(result, element);
        }
        
        return result;
    }
    else
    {
        // 일반 연산
        return operation == "erode" ? 
            ErodeOptimized(src, se) : DilateOptimized(src, se);
    }
}
```

### 2. 적분 이미지 활용 (Integral Image)

큰 구조 요소에 대한 빠른 침식/팽창:

```csharp
public unsafe Bitmap ErodeUsingIntegral(Bitmap src, int kernelSize)
{
    // 적분 이미지 계산
    int[,] integral = ComputeIntegralImage(src);
    
    Bitmap dst = new Bitmap(src.Width, src.Height);
    int halfSize = kernelSize / 2;
    
    for (int y = 0; y < src.Height; y++)
    {
        for (int x = 0; x < src.Width; x++)
        {
            // 윈도우 경계
            int x1 = Math.Max(0, x - halfSize);
            int y1 = Math.Max(0, y - halfSize);
            int x2 = Math.Min(src.Width - 1, x + halfSize);
            int y2 = Math.Min(src.Height - 1, y + halfSize);
            
            // 윈도우 내 모든 픽셀이 전경인지 확인
            int area = (x2 - x1 + 1) * (y2 - y1 + 1);
            int sum = GetIntegralSum(integral, x1, y1, x2, y2);
            
            // 모든 픽셀이 흰색(255)이면 sum = area * 255
            bool shouldErode = (sum == area * 255);
            dst.SetPixel(x, y, shouldErode ? Color.White : Color.Black);
        }
    }
    
    return dst;
}
```

### 3. SIMD 병렬 처리

```csharp
public unsafe void MorphologySIMD(Bitmap src, Bitmap dst, int operation)
{
    // System.Numerics.Vector 사용
    int vectorSize = Vector<byte>.Count;
    
    fixed (byte* srcPtr = srcData, dstPtr = dstData)
    {
        for (int i = 0; i < dataLength; i += vectorSize)
        {
            Vector<byte> srcVector = new Vector<byte>(srcPtr + i);
            Vector<byte> result;
            
            // SIMD 연산으로 모폴로지 처리
            if (operation == 0) // 침식
            {
                // 최소값 연산 (모든 이웃이 255여야 함)
                result = Vector.ConditionalSelect(
                    Vector.Equals(srcVector, new Vector<byte>(255)),
                    new Vector<byte>(255),
                    new Vector<byte>(0));
            }
            else // 팽창
            {
                // 최대값 연산 (하나의 이웃이라도 255면 됨)
                result = Vector.ConditionalSelect(
                    Vector.GreaterThan(srcVector, new Vector<byte>(0)),
                    new Vector<byte>(255),
                    new Vector<byte>(0));
            }
            
            result.CopyTo(dstData, i);
        }
    }
}
```

### 4. GPU 가속 (CUDA/OpenCL)

```csharp
// 의사 코드 - 실제 구현은 CUDA나 OpenCL 라이브러리 필요
public class GPUMorphology
{
    /*
    [Kernel]
    public static void ErodeKernel(byte[] input, byte[] output, 
                                   int width, int height, int[] se)
    {
        int x = blockIdx.x * blockDim.x + threadIdx.x;
        int y = blockIdx.y * blockDim.y + threadIdx.y;
        
        if (x >= width || y >= height) return;
        
        bool shouldErode = true;
        for (int j = 0; j < seHeight; j++)
        {
            for (int i = 0; i < seWidth; i++)
            {
                if (se[j * seWidth + i] == 0) continue;
                
                int nx = x + i - anchorX;
                int ny = y + j - anchorY;
                
                if (nx < 0 || nx >= width || ny < 0 || ny >= height || 
                    input[ny * width + nx] == 0)
                {
                    shouldErode = false;
                    return;
                }
            }
        }
        
        output[y * width + x] = shouldErode ? (byte)255 : (byte)0;
    }
    */
}
```

---

## 정리

### 모폴로지 연산 선택 가이드

| 문제 상황 | 추천 연산 | 이유 | 구조 요소 |
|----------|----------|------|-----------|
| **작은 노이즈 제거** | 열기(Opening) | 전경 노이즈 제거 효과적 | 원형(반지름 1-2) |
| **작은 구멍 메우기** | 닫기(Closing) | 배경 노이즈/구멍 제거 | 십자형 |
| **객체 경계 추출** | 모폴로지 그라디언트 | 명확한 경계 얻음 | 작은 사각형 |
| **객체 골격화** | 세밀화(Thinning) | 토폴로지 보존 | 회전 구조 요소 집합 |
| **패턴 매칭** | 히트-오어-미스 | 정확한 패턴 탐지 | 템플릿 기반 |
| **영역 채우기** | 모폴로지 재구성 | 홀 채움, 영역 확장 | 십자형 |

### 모폴로지의 수학적 특성 요약

| 특성 | 설명 | 예시 |
|------|------|------|
| **단조성** | $A \subseteq B \Rightarrow \Psi(A) \subseteq \Psi(B)$ | 침식, 팽창 |
| **멱등성** | $\Psi(\Psi(A)) = \Psi(A)$ | 열기, 닫기 |
| **확대성** | $A \subseteq \Psi(A)$ | 팽창 |
| **축소성** | $\Psi(A) \subseteq A$ | 침식 |
| **공변성** | $\Psi(A_x) = \Psi(A)_x$ | 모든 모폴로지 연산 |

### 향후 발전 방향

1. **그레이스케일 모폴로지**: 평탄 구조 요소, 함수 모폴로지
2. **기하학적 모폴로지**: 곡률 기반, 형태 인식
3. **딥러닝 결합**: 신경망 기반 구조 요소 학습
4. **3D 모폴로지**: 볼륨 데이터 처리 (CT, MRI)
5. **동적 모폴로지**: 비디오 시퀀스 처리

모폴로지 연산은 단순하면서도 강력한 도구로, 적절한 구조 요소와 연산 조합을 선택하면 다양한 영상 처리 문제를 효과적으로 해결할 수 있다. 전통적인 이진 모폴로지는 여전히 실시간 시스템에서 유용하며, 고급 변형은 전문 영상 분석에 필수적이다.