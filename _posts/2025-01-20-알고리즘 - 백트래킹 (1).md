---
layout: post
title: 알고리즘 - 백트래킹 (1)
date: 2025-01-20 20:20:23 +0900
category: 알고리즘
---
# 백트래킹(Backtracking)

## 백트래킹이란?

- **정의**: 해 공간(탐색 트리)을 DFS로 순회하되, **유망하지 않은 부분해(partial solution)**를 발견하는 즉시 그 서브트리를 **잘라 버리는(가지치기, pruning)** 탐색 기법.
- **핵심 구성** = *(상태 표현)* + *(후보 생성)* + *(유망성 판정)* + *(복원)*.
- **브루트포스와의 차이**: 전수를 시도한다는 큰 틀은 같지만, **조건 기반의 조기 포기**로 탐색량을 대폭 줄인다.

---

## 탐색 트리 관점과 복잡도 직관

- 깊이 \(d\), 평균 분기수 \(b\)라면 완전 탐색 노드 수는
  $$
  1 + b + b^2 + \cdots + b^d = O(b^d).
  $$
- 백트래킹으로 **유망하지 않은 분기**를 미리 차단하면, 실제 탐색 노드 수가 \( \ll b^d \)가 된다.
- 성패는 **유망성 검사를 얼마나 싸고 정확하게 설계**하느냐에 달린다.

---

## 기본 골격(템플릿) — 안전하고 빠른 버전

### 공통 재귀 템플릿

```python
def backtrack(state):
    # 1) 기저 조건
    if is_complete(state):
        emit(state)         # 정답 처리(출력/수집/갱신)
        return

    # 2) 후보 생성 + 순서 휴리스틱(가급적 어려운 것부터)
    for choice in ordered_candidates(state):
        if not is_feasible(state, choice):
            continue
        apply(state, choice)          # 상태 갱신
        backtrack(state)              # 재귀 탐색
        undo(state, choice)           # 상태 복원 (필수)
```

#### 구현 요령

- `apply/undo`는 **O(1)~O(log n)** 가 되도록 상태 구조 설계.
- `ordered_candidates`에서 **변수/값 순서 휴리스틱**(예: 도메인 크기 최소 변수 먼저, 자주 위반되는 제약 먼저)을 적용하면 탐색량이 크게 준다.

---

## 상태 모델링과 프루닝 설계

### 상태 모델링

- **방문/사용 체크**: `visited[]`, 비트마스크(정수)
- **제약 추적**: 집합/카운터/비트셋(행·열·블록·대각선 등)
- **평가치**: 현재 최선/최악 가능 값의 경계(바운드)

### 프루닝(Pruning) 카탈로그

| 분류 | 의미 | 예시 |
|---|---|---|
| 불변 제약 위반 컷 | 제약을 위반하는 순간 중단 | N-Queen(열·대각선 충돌), 스도쿠(행/열/블록 중복) |
| 조기 불가능성 컷 | 남은 자원/자리로 조건 충족 불가 | 남은 합/개수 상·하한으로 충족 불가 |
| **브랜치&바운드** | 최적화 문제에서 상한/하한으로 컷 | 최대값 탐색에서 현재 상한 ≤ 전역 최선 |
| 대칭성 컷 | 대칭 케이스 제거 | 첫 원소 고정, 회전/반사 대칭 제외 |
| 도메인 축소 | 후보 집합을 앞당겨 줄임 | 스도쿠 **제약 전파**(한 칸 후보가 1개면 즉시 확정) |

---

## 가장 기본: 순열/조합/연산자 끼워넣기

### 순열(중복 없이)

```python
def permute(arr):
    n = len(arr)
    used = [False] * n
    path = []
    def dfs():
        if len(path) == n:
            print(*path)
            return
        for i in range(n):
            if used[i]:
                continue
            used[i] = True
            path.append(arr[i])
            dfs()
            path.pop()
            used[i] = False
    dfs()
```

### 조합(오름차순 시작 인덱스)

```python
def combine(arr, r):
    n = len(arr)
    path = []
    def dfs(start):
        if len(path) == r:
            print(*path)
            return
        # 남은 슬롯보다 남은 원소가 적으면 중단(필수 프루닝)
        for i in range(start, n - ((r - len(path)) - 1)):
            path.append(arr[i])
            dfs(i + 1)
            path.pop()
    dfs(0)
```

### 연산자 끼워넣기(BOJ 14888) — 브랜치&바운드 예시

```python
import sys
input = sys.stdin.readline

n = int(input())
nums = list(map(int, input().split()))
add, sub, mul, div = map(int, input().split())

best_min, best_max = 10**18, -10**18

def apply(a, b, op):  # 0:+, 1:-, 2:*, 3://
    if op == 0: return a + b
    if op == 1: return a - b
    if op == 2: return a * b
    # BOJ 규칙: 음수 // 양수는 0쪽으로 내림이 아니라 C/Java처럼 0쪽으로 truncate
    if a < 0:
        return -((-a) // b)
    return a // b

def dfs(i, cur, A, S, M, D):
    global best_min, best_max
    if i == n:
        best_min = min(best_min, cur)
        best_max = max(best_max, cur)
        return

    # (선택) 간단한 바운드: 남은 수들의 절대값 합으로 대략적 상/하한 추정 가능
    b = nums[i]
    if A: dfs(i+1, apply(cur, b, 0), A-1, S, M, D)
    if S: dfs(i+1, apply(cur, b, 1), A, S-1, M, D)
    if M: dfs(i+1, apply(cur, b, 2), A, S, M-1, D)
    if D: dfs(i+1, apply(cur, b, 3), A, S, M, D-1)

dfs(1, nums[0], add, sub, mul, div)
print(best_max, best_min, sep='\n')
```

---

## N-Queen(BOJ 9663) — 대각선 제약의 O(1) 검사

- 같은 열/대각선(좌하향, 우하향)에 다른 퀸이 있으면 불가.
- 대각선 식:
  - 좌상↘우하: \( r - c \) 고정
  - 우상↙좌하: \( r + c \) 고정

```python
n = int(input())
col = [False]*n
diag1 = [False]*(2*n)   # r-c+n
diag2 = [False]*(2*n)   # r+c
ans = 0

def dfs(r):
    global ans
    if r == n:
        ans += 1
        return
    for c in range(n):
        d1 = r - c + n
        d2 = r + c
        if col[c] or diag1[d1] or diag2[d2]:
            continue
        col[c] = diag1[d1] = diag2[d2] = True
        dfs(r+1)
        col[c] = diag1[d1] = diag2[d2] = False

dfs(0)
print(ans)
```

- **프루닝 포인트**: 열/대각선 점유를 비트마스크로 바꾸면 훨씬 빠르다.

```python
def solve_bitmask(n):
    ans = 0
    def dfs(r, cols, d1, d2):
        nonlocal ans
        if r == n:
            ans += 1
            return
        avail = ((1<<n)-1) & ~(cols | d1 | d2)
        while avail:
            pick = avail & -avail
            avail -= pick
            dfs(r+1, cols|pick, (d1|pick)<<1 & ((1<<(n+1))-1), (d2|pick)>>1)
    dfs(0, 0, 0, 0)
    return ans
```

---

## 스도쿠 — 제약 전파 + 백트래킹(강력 예제)

- **핵심**: 빈 칸의 **후보집합을 유지**하고, 후보가 하나뿐이면 즉시 확정(**전방 검사/제약 전파**).
- 행/열/블록의 사용 숫자를 비트셋으로 유지하면 후보 계산이 \(O(1)\) 수준.

```python
import sys
sys.setrecursionlimit(10000)

board = [list(map(int, sys.stdin.readline().split())) for _ in range(9)]
row = [0]*9
col = [0]*9
box = [0]*9
empties = []

def set_bit(mask, d):
    return mask | (1 << d)

def has_bit(mask, d):
    return (mask >> d) & 1

for r in range(9):
    for c in range(9):
        d = board[r][c]
        if d == 0:
            empties.append((r, c))
        else:
            d -= 1
            row[r] = set_bit(row[r], d)
            col[c] = set_bit(col[c], d)
            box[(r//3)*3 + (c//3)] = set_bit(box[(r//3)*3 + (c//3)], d)

# 최소 후보 칸 먼저(변수 순서 휴리스틱)

def get_candidates(r, c):
    used = row[r] | col[c] | box[(r//3)*3 + (c//3)]
    cand_mask = ~used & 0x1FF  # 9비트
    return cand_mask

def solve(idx=0):
    if idx == len(empties):
        return True
    # MRV: 후보 수 최소인 칸을 선택 (휴리스틱)
    best = idx
    best_cnt = 10
    for k in range(idx, len(empties)):
        r, c = empties[k]
        m = get_candidates(r, c)
        cnt = m.bit_count()
        if cnt < best_cnt:
            best_cnt, best = cnt, k
            if cnt == 1:
                break
    empties[idx], empties[best] = empties[best], empties[idx]
    r, c = empties[idx]
    cand = get_candidates(r, c)
    while cand:
        bit = cand & -cand
        d = (bit.bit_length() - 1)
        # apply
        board[r][c] = d+1
        row[r] |= bit
        col[c] |= bit
        b = (r//3)*3 + (c//3)
        box[b] |= bit

        if solve(idx+1):
            return True

        # undo
        board[r][c] = 0
        row[r] ^= bit
        col[c] ^= bit
        box[b] ^= bit

        cand -= bit

    empties[idx], empties[best] = empties[best], empties[idx]
    return False

solve()
for r in range(9):
    print(*board[r])
```

- **포인트**
  - **MRV(Minimum Remaining Values)**: 후보 수 최소인 변수(칸)부터 결정 → 백트래킹 성능 대폭 향상.
  - 비트셋으로 후보 계산·갱신·복원 모두 **상수 시간에 가깝게** 처리.

---

## 부분합/조합형 최적화 — 바운드로 큰 폭 가지치기

### 부분수열의 합: 조기 불가능성 컷

- 목표 합 \(S\), 남은 원소 합의 상한/하한으로 실패가 확실하면 컷.

```python
def subset_sum_maximize(arr, limit):
    arr.sort(reverse=True)
    n = len(arr)
    best = 0
    prefix = [0]*(n+1)
    for i in range(n):
        prefix[i+1] = prefix[i] + arr[i]

    def dfs(i, cur):
        nonlocal best
        if cur > limit:
            return
        # 남은 것 모두 더해도 현재 best를 못 넘으면 컷
        if cur + (prefix[n] - prefix[i]) <= best:
            return
        best = max(best, cur)
        if i == n:
            return
        dfs(i+1, cur + arr[i])   # 선택
        dfs(i+1, cur)            # 비선택
    dfs(0, 0)
    return best
```

### 배낭 문제(0-1 Knapsack) — 백트래킹 + 상한 추정(그리디 분수)

- 분수 배낭으로 계산한 **낙관적 상한**(upper bound)이 전역 최선 이하이면 서브트리 컷.

---

## 그래프 문제 백트래킹: 해밀턴 경로/색칠 문제

### 그래프 색칠(Chromatic Number) — 인접 제약

```python
def graph_coloring(adj, k):  # k색으로 칠 가능한지
    n = len(adj)
    color = [-1]*n

    order = sorted(range(n), key=lambda u: -len(adj[u]))  # 차수 큰 정점부터
    def feasible(u, c):
        return all(color[v] != c for v in adj[u] if color[v] != -1)

    def dfs(i):
        if i == n:
            return True
        u = order[i]
        for c in range(k):
            if feasible(u, c):
                color[u] = c
                if dfs(i+1): return True
                color[u] = -1
        return False

    return dfs(0)
```

- **프루닝**: 차수 내림차순(가장 어려운 정점부터), 사용 색상 상한/하한 추정으로 가지치기 가능.

---

## 비트마스크/상태압축 — 빠르고 간결한 백트래킹

- **순열/방문 집합** → 정수 한 개로 표현, `mask & (1<<i)`/`mask | (1<<i)`로 조작.
- **장점**: 메모리/속도/코드 간결성.

```python
def perm_mask(arr):
    n = len(arr)
    path = [None]*n
    def dfs(depth, used):
        if depth == n:
            print(path)
            return
        for i in range(n):
            if (used >> i) & 1:
                continue
            path[depth] = arr[i]
            dfs(depth+1, used | (1<<i))
    dfs(0, 0)
```

---

## 올-솔루션 vs 첫-솔루션 모드, 그리고 카운팅

- **첫-솔루션 모드**: 조건 만족 해 하나만 찾으면 즉시 상위로 반환(스도쿠, 해밀턴 경로 등).
- **올-솔루션 모드**: 모든 해를 수집(N-Queen 해 집합, 모든 순열 출력 등).
- **카운팅 모드**: 해의 수만 세기(메모리 절약).

---

## 정당성(올바른 프루닝)의 스케치

- **사실**: 잘라낸 서브트리의 모든 완성해가 **존재 불가** 또는 **최적값 갱신 가능성 없음**임을 보이면 정당.
- 예) 스도쿠: 같은 행/열/블록에 중복 → 어떤 확장도 규칙 위반.
- 예) 브랜치&바운드: 서브트리의 최선 상한 \(\le\) 전역 최선 → 어떠한 확장도 전역 최선 갱신 불가.

---

## 복잡도와 한계, 그리고 전략

- 최악 복잡도는 여전히 지수적:
  $$
  O(b^d)
  $$
- **대응 전략**
  1) **휴리스틱**: MRV, 차수 휴리스틱, 값 순서(LCV)
  2) **제약 전파**: 후보 축소(스도쿠)
  3) **바운딩**: 상/하한 추정으로 과감한 컷
  4) **대칭 제거**: 동일 해중복 방지
  5) **Meet-in-the-Middle**: 절반 분할 후 결합
  6) **하이브리드**: 백트래킹 + DP/그리디/로컬서치

---

## 파이썬 구현 최적화

- **I/O**: `sys.stdin.readline`, 출력 버퍼링
- **재귀 한도**: `sys.setrecursionlimit(10**6)` (필요시)
- **로컬 바인딩**: 반복 내 메서드/함수 로컬 변수에 바인딩
- **불변/비트연산**: 집합/리스트 대신 비트마스크로 가속
- **정렬 1회**: 후보 정렬은 초기 1회, 이후 인덱스만 활용

---

## 디버깅 체크리스트

1) **undo 누락**(복원 안 해서 상태가 오염)
2) **기저 조건 불명확**(무한 재귀/중복 출력)
3) **유효성 검사 범위**(엣지/경계에서 off-by-one)
4) **대칭 중복**(같은 해를 여러 번 방출)
5) **출력 형식**(공백/줄바꿈)
6) **시간 초과** → 휴리스틱/프루닝 강화, 비트마스크 전환

---

## 종합 예제: “합이 정확히 S인 부분집합 중 원소 수가 최소” — 다중 제약, 바운드, 휴리스틱

```python
def min_cardinality_subset_sum(arr, S):
    # 원소 수 최소(= 목적함수), 합 == S(= 제약)
    # 프루닝: 남은 원소 최대합/최소합으로 가능성 판정
    arr.sort(reverse=True)
    n = len(arr)
    prefix = [0]*(n+1)
    for i in range(n):
        prefix[i+1] = prefix[i] + arr[i]

    best = (10**9, None)  # (원소수, 솔루션)

    def dfs(i, cur_sum, cnt, pick):
        nonlocal best
        # 불가 컷 1: 초과
        if cur_sum > S:
            return
        # 낙관적 컷: 남은 원소 모두 더해도 S에 못 도달
        if cur_sum + (prefix[n]-prefix[i]) < S:
            return
        # 최적화 컷: 현재 cnt가 이미 best.count 이상이면 더 볼 필요 없음
        if cnt >= best[0]:
            return
        if cur_sum == S:
            best = (cnt, pick[:])
            return
        if i == n:
            return

        # 고를 때
        pick.append(arr[i])
        dfs(i+1, cur_sum + arr[i], cnt+1, pick)
        pick.pop()

        # 안 고를 때
        dfs(i+1, cur_sum, cnt, pick)

    dfs(0, 0, 0, [])
    return best if best[1] is not None else None
```

- **핵심**: 목적함수(원소 수 최소) 바운딩 + 합 가능성 컷 + 정렬 휴리스틱.

---

## 수식 요약

- 완전 탐색 노드 수:
  $$
  \sum_{i=0}^{d} b^i = O(b^d)
  $$
- 브랜치&바운드 컷 조건(최대화 예):
  $$
  \text{upper\_bound(subtree)} \le \text{current\_best} \Rightarrow \text{prune}
  $$
- N-Queen 대각선 충돌:
  $$
  \text{충돌} \Leftrightarrow r_1 - c_1 = r_2 - c_2 \quad \text{또는} \quad r_1 + c_1 = r_2 + c_2
  $$

---

## 마무리 결정표

| 상황 | 추천 전략 |
|---|---|
| 순열/조합/연산자 배치 | 방문/시작인덱스 + 간단 프루닝 |
| 제약 충돌 빈번(스도쿠/N-Queen) | 제약 전파 + MRV/대각선/열 비트마스크 |
| 최적화(최대/최소) | 브랜치&바운드 + 상한/하한 |
| 대규모 상태 | 비트마스크/상태압축, 입력 정렬, 휴리스틱 강화 |
| 첫 해만 필요 | 해 찾자마자 상위로 조기 반환 |
| 모든 해 필요 | 중복/대칭 제거를 먼저 설계 |

---

# 결론

초안의 핵심을 유지하며, **상태 설계→프루닝 근거→휴리스틱 적용→브랜치&바운드→비트마스크/제약 전파**까지 실전에서 바로 쓰는 기법을 모두 연결했다.
백트래킹의 본질은 “**불가능하거나 의미 없는 분기는 즉시 포기**”이며, 이를 가능케 하는 것은 **상태 표현**과 **유망성 판정**의 정교함이다. 위 템플릿과 예제들을 **필수 프루닝(안전), 선택 휴리스틱(효율)**의 계층으로 적용하면, 대부분의 코딩 테스트/알고리즘 대회 문제에서 **정확하고 빠른 정답**에 도달할 수 있다.
