---
layout: post
title: 파이썬 - 집합
date: 2024-08-03 19:20:23 +0900
category: Python
---
# 집합(Set)

파이썬의 **집합(Set)**은 수학에서의 집합 개념을 구현한 자료구조로, **중복을 허용하지 않는** 가변 컬렉션입니다. 순서가 없고 인덱싱이 불가능하며, 주로 고유한 요소들의 모음을 관리하거나 빠른 멤버십 테스트에 사용됩니다. 집합은 해시 테이블을 기반으로 구현되어 대부분의 연산이 평균 O(1) 시간 복잡도를 가지는 것이 특징입니다.

집합 생성에는 중괄호 `{}`를 사용하지만, 빈 집합을 만들 때는 주의가 필요합니다. 빈 중괄호 `{}`는 빈 딕셔너리를 생성하므로, 빈 집합은 반드시 `set()` 생성자를 사용해야 합니다.

```python
# 집합 생성 예시
numbers = {1, 2, 3, 4, 5}          # 요소가 있는 집합
empty_set = set()                  # 빈 집합 (주의: {}는 딕셔너리)
mixed_types = {1, True, "hello", 3.14}  # 서로 다른 타입 가능
from_list = set([1, 2, 2, 3, 3])  # 리스트로부터 생성 (중복 자동 제거) -> {1, 2, 3}
```

---

## 집합의 핵심 특성

### 순서 없음 (Unordered)
집합은 요소들의 저장 순서를 보장하지 않습니다. 이는 요소들이 내부 해시 값에 따라 배치되기 때문입니다. 따라서 인덱싱이나 슬라이싱이 불가능합니다.

```python
my_set = {'apple', 'banana', 'cherry'}
# print(my_set[0])  # TypeError: 'set' object is not subscriptable
```

### 중복 불가 (Unique Elements)
동일한 값을 여러 번 추가해도 하나만 유지됩니다. 이 특성은 데이터에서 중복을 제거할 때 매우 유용합니다.

```python
duplicates = {1, 2, 2, 3, 3, 3}
print(duplicates)  # {1, 2, 3} (중복 자동 제거)
```

### 가변성 (Mutable)
집합은 생성 후 요소를 추가하거나 삭제할 수 있습니다. `add()`, `remove()`, `discard()`, `pop()` 등의 메서드를 제공합니다.

### 해시 가능성 요구사항
집합의 모든 요소는 **해시 가능(Hashable)** 해야 합니다. 이는 요소의 값이 불변해야 하고, 고유한 해시 값을 가져야 함을 의미합니다.

```python
# 해시 가능한 요소들 (집합에 사용 가능)
valid_set = {1, 'hello', (1, 2, 3), frozenset([4, 5])}

# 해시 불가능한 요소들 (집합에 사용 불가)
# invalid_set = {[1, 2]}       # TypeError: list는 가변
# invalid_set = {{1, 2}}       # TypeError: set도 가변
```

> **해시 가능한 타입**: 정수, 실수, 문자열, 불변 튜플, frozenset 등
> **해시 불가능한 타입**: 리스트, 딕셔너리, 일반 집합 등

---

## 집합의 기본 연산

### 요소 추가 및 삭제

```python
fruits = {'apple', 'banana'}

# 요소 추가
fruits.add('orange')        # {'apple', 'banana', 'orange'}
fruits.add('apple')         # 변화 없음 (이미 존재)

# 요소 삭제
fruits.remove('banana')     # {'apple', 'orange'}
# fruits.remove('grape')    # KeyError: 'grape' (요소 없음)

fruits.discard('grape')     # 에러 발생하지 않음 (안전한 삭제)
fruits.discard('orange')    # {'apple'}

# 임의의 요소 제거 및 반환
random_fruit = fruits.pop()  # 어떤 요소가 제거될지는 보장되지 않음
print(fruits)                # 빈 집합

# 모든 요소 삭제
fruits.clear()               # set()
```

### 멤버십 테스트
집합의 가장 강력한 기능 중 하나는 평균 O(1) 시간 복잡도로 요소의 존재 여부를 확인할 수 있다는 점입니다.

```python
vowels = {'a', 'e', 'i', 'o', 'u'}
print('a' in vowels)     # True
print('x' in vowels)     # False
print('e' not in vowels) # False
```

---

## 집합 연산: 수학적 개념의 구현

파이썬 집합은 수학의 집합 연산을 직관적으로 지원합니다. 연산자와 메서드 두 가지 형태로 모두 사용할 수 있습니다.

### 기본 집합 연산

```python
A = {1, 2, 3, 4}
B = {3, 4, 5, 6}

# 합집합 (Union) - 두 집합의 모든 요소
print(A | B)               # {1, 2, 3, 4, 5, 6}
print(A.union(B))          # 동일한 결과

# 교집합 (Intersection) - 두 집합에 공통된 요소
print(A & B)               # {3, 4}
print(A.intersection(B))   # 동일한 결과

# 차집합 (Difference) - A에만 있고 B에는 없는 요소
print(A - B)               # {1, 2}
print(A.difference(B))     # 동일한 결과

# 대칭차집합 (Symmetric Difference) - 한쪽에만 있는 요소
print(A ^ B)               # {1, 2, 5, 6}
print(A.symmetric_difference(B))  # 동일한 결과
```

### 제자리 갱신 연산
집합을 직접 수정하는 연산으로, 새 집합 객체를 생성하지 않아 메모리 효율이 좋습니다.

```python
A = {1, 2, 3}
B = {3, 4, 5}

A |= B                     # A = A ∪ B
print(A)                   # {1, 2, 3, 4, 5}

A = {1, 2, 3}
A.update(B)               # 위와 동일한 연산 (메서드 버전)
print(A)                   # {1, 2, 3, 4, 5}
```

다른 제자리 갱신 연산들:
- `A &= B` 또는 `A.intersection_update(B)` - 교집합으로 갱신
- `A -= B` 또는 `A.difference_update(B)` - 차집합으로 갱신
- `A ^= B` 또는 `A.symmetric_difference_update(B)` - 대칭차집합으로 갱신

### 집합 관계 연산

```python
A = {1, 2, 3, 4, 5}
B = {2, 3, 4}
C = {6, 7, 8}

# 부분집합 여부
print(B <= A)              # True (B는 A의 부분집합)
print(B < A)               # True (B는 A의 진부분집합)
print(B.issubset(A))       # True

# 상위집합 여부
print(A >= B)              # True (A는 B의 상위집합)
print(A > B)               # True (A는 B의 진상위집합)
print(A.issuperset(B))     # True

# 서로소 집합 여부 (교집합이 공집합인지)
print(A.isdisjoint(C))     # True
print(A.isdisjoint(B))     # False (교집합 {2,3,4} 존재)
```

---

## 집합 메서드 총정리

| 메서드 | 설명 | 반환 값 | 시간 복잡도 |
|--------|------|---------|-------------|
| `add(element)` | 요소 추가 | None | 평균 O(1) |
| `remove(element)` | 요소 제거 (없으면 KeyError) | None | 평균 O(1) |
| `discard(element)` | 요소 제거 (없어도 에러 안 남) | None | 평균 O(1) |
| `pop()` | 임의 요소 제거 및 반환 | 제거된 요소 | 평균 O(1) |
| `clear()` | 모든 요소 제거 | None | O(n) |
| `copy()` | 얕은 복사본 생성 | 새 집합 | O(n) |
| `union(*others)` | 합집합 | 새 집합 | O(len(self) + len(others)) |
| `intersection(*others)` | 교집합 | 새 집합 | O(min(len(self), len(other))) |
| `difference(*others)` | 차집합 | 새 집합 | O(len(self)) |
| `symmetric_difference(other)` | 대칭차집합 | 새 집합 | O(len(self)) |
| `isdisjoint(other)` | 서로소 집합 여부 | bool | O(min(len(self), len(other))) |
| `issubset(other)` | 부분집합 여부 | bool | O(len(self)) |
| `issuperset(other)` | 상위집합 여부 | bool | O(len(other)) |

---

## 집합 내포 (Set Comprehension)

리스트 내포와 유사한 구문으로 집합을 생성할 수 있습니다. 중괄호를 사용하며, 자동으로 중복이 제거됩니다.

```python
# 0부터 9까지 수의 제곱 집합
squares = {x**2 for x in range(10)}
# {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}

# 조건문을 포함한 집합 내포
even_squares = {x**2 for x in range(10) if x % 2 == 0}
# {0, 4, 16, 36, 64}

# 문자열 처리 시 주의
chars = {char for char in "hello world" if char != ' '}
# {'h', 'e', 'l', 'o', 'w', 'r', 'd'} (중복 'l'은 하나만)
```

---

## frozenset: 불변 집합

`frozenset`은 불변 버전의 집합으로, 한번 생성되면 요소를 추가하거나 삭제할 수 없습니다. 이 불변성 때문에 해시가 가능해져, 딕셔너리의 키나 다른 집합의 요소로 사용할 수 있습니다.

```python
# frozenset 생성
immutable_set = frozenset([1, 2, 3, 4, 5])
print(immutable_set)  # frozenset({1, 2, 3, 4, 5})

# 요소 추가/삭제 시도
# immutable_set.add(6)  # AttributeError: 'frozenset' object has no attribute 'add'
# immutable_set.remove(1)  # AttributeError

# frozenset의 활용
# 1. 딕셔너리의 키로 사용
graph = {
    frozenset(['A', 'B']): 5,
    frozenset(['B', 'C']): 3,
}
print(graph[frozenset(['B', 'A'])])  # 5 (순서 무관)

# 2. 집합의 요소로 사용
set_of_sets = {frozenset([1, 2]), frozenset([3, 4])}
print(set_of_sets)  # {frozenset({1, 2}), frozenset({3, 4})}

# 3. 연산은 일반 집합과 동일
fs1 = frozenset([1, 2, 3])
fs2 = frozenset([3, 4, 5])
print(fs1 | fs2)  # frozenset({1, 2, 3, 4, 5})
```

---

## 실용적인 활용 패턴과 주의사항

### 1. 문자열 처리 시 주의점
문자열을 `set()`에 직접 전달하면 문자 단위로 분해됩니다. 단어나 문장 전체를 하나의 요소로 추가하려면 `add()` 메서드를 사용해야 합니다.

```python
# 주의: 문자열이 문자 단위로 분해됨
char_set = set("hello")
print(char_set)  # {'h', 'e', 'l', 'o'}

# 단어 전체를 요소로 추가하는 방법
word_set = set()
word_set.add("hello")
word_set.update(["world"])  # 리스트로 전달
print(word_set)  # {'hello', 'world'}
```

### 2. 순서 유지하며 중복 제거하기
집합은 순서를 보장하지 않으므로, 원본 리스트의 순서를 유지하며 중복을 제거하려면 추가적인 처리가 필요합니다.

```python
# 방법 1: dict.fromkeys() 활용 (Python 3.7+)
data = ['banana', 'apple', 'cherry', 'apple', 'banana', 'date']
unique_ordered = list(dict.fromkeys(data))
print(unique_ordered)  # ['banana', 'apple', 'cherry', 'date']

# 방법 2: 집합과 리스트 조합
seen = set()
result = []
for item in data:
    if item not in seen:
        seen.add(item)
        result.append(item)
print(result)  # ['banana', 'apple', 'cherry', 'date']
```

### 3. 집합 순회 중 수정 금지
집합을 순회하는 동안에는 집합의 크기를 변경할 수 없습니다. 수정이 필요하다면 복사본을 만들어 처리하세요.

```python
numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

# 위험한 방식 (RuntimeError 발생 가능)
# for num in numbers:
#     if num % 2 == 0:
#         numbers.remove(num)

# 안전한 방식 1: 복사본 순회
for num in numbers.copy():
    if num % 2 == 0:
        numbers.remove(num)
print(numbers)  # {1, 3, 5, 7, 9}

# 안전한 방식 2: 집합 내포 사용
numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
numbers = {num for num in numbers if num % 2 != 0}
print(numbers)  # {1, 3, 5, 7, 9}
```

### 4. 성능 비교: 리스트 vs 집합
멤버십 테스트에서 집합이 리스트보다 훨씬 빠릅니다.

```python
import time

# 큰 데이터셋에서 성능 비교
large_list = list(range(1_000_000))
large_set = set(large_list)

# 리스트에서 검색 (선형 시간)
start = time.time()
999_999 in large_list
list_time = time.time() - start

# 집합에서 검색 (상수 시간)
start = time.time()
999_999 in large_set
set_time = time.time() - start

print(f"리스트 검색 시간: {list_time:.6f}초")
print(f"집합 검색 시간: {set_time:.6f}초")
print(f"집합이 리스트보다 약 {list_time/set_time:.0f}배 빠름")
```

---

## 실제 응용 사례

### 1. 데이터 유효성 검사
```python
# 필수 필드 검증
required_fields = {'username', 'email', 'password'}
user_data = {'username': 'john', 'email': 'john@example.com', 'age': 25}

# 모든 필수 필드가 있는지 확인
missing = required_fields - user_data.keys()
if missing:
    print(f"필수 필드 누락: {missing}")
else:
    print("모든 필수 필드 존재")

# 교집합을 이용한 공통 관심사 찾기
user_interests = {'python', 'data science', 'machine learning'}
job_requirements = {'python', 'sql', 'statistics'}
common = user_interests & job_requirements
print(f"공통 기술: {common}")  # {'python'}
```

### 2. 중복 데이터 처리
```python
# 로그 데이터에서 고유 사용자 추출
log_entries = [
    "user123 로그인",
    "user456 구매",
    "user123 로그아웃", 
    "user789 조회",
    "user456 리뷰작성"
]

# 사용자 ID 추출 (간단한 예시)
user_ids = {entry.split()[0] for entry in log_entries}
print(f"고유 사용자 수: {len(user_ids)}")  # 3
print(f"사용자 목록: {user_ids}")  # {'user123', 'user456', 'user789'}
```

### 3. 두 데이터셋 비교
```python
# 데이터베이스와 API 응답 비교
db_users = {'alice', 'bob', 'charlie', 'david'}
api_users = {'bob', 'charlie', 'eve', 'frank'}

# 대칭차집합으로 변경된 사용자 찾기
changed_users = db_users ^ api_users
print(f"변경된 사용자: {changed_users}")  # {'alice', 'david', 'eve', 'frank'}

# 새로 추가된 사용자
new_users = api_users - db_users
print(f"새 사용자: {new_users}")  # {'eve', 'frank'}

# 삭제된 사용자
deleted_users = db_users - api_users
print(f"삭제된 사용자: {deleted_users}")  # {'alice', 'david'}
```

### 4. 그래프 알고리즘에 활용
```python
# 무방향 그래프 인접 리스트 표현
graph = {
    'A': {'B', 'C'},
    'B': {'A', 'D', 'E'},
    'C': {'A', 'F'},
    'D': {'B'},
    'E': {'B', 'F'},
    'F': {'C', 'E'}
}

# A의 이웃의 이웃 찾기 (거리 2)
neighbors_of_A = graph['A']
neighbors_of_neighbors = set()
for neighbor in neighbors_of_A:
    neighbors_of_neighbors.update(graph[neighbor])
    
# A 자신과 직접 이웃 제거
two_step_neighbors = neighbors_of_neighbors - neighbors_of_A - {'A'}
print(f"A에서 거리 2인 노드: {two_step_neighbors}")  # {'D', 'E', 'F'}
```

---

## 집합의 수학적 배경과 파이썬 구현

집합론의 기본 개념이 파이썬 집합 연산에 직접적으로 반영되어 있습니다:

1. **멱등성(Idempotent)**: `A | A == A`, `A & A == A`
2. **교환법칙(Commutative)**: `A | B == B | A`, `A & B == B & A`
3. **결합법칙(Associative)**: `(A | B) | C == A | (B | C)`
4. **분배법칙(Distributive)**: `A & (B | C) == (A & B) | (A & C)`
5. **드모르간 법칙(De Morgan)**: `(A | B).complement() == A.complement() & B.complement()`

이러한 수학적 성질들은 파이썬 코드에서도 그대로 유지되며, 복잡한 집합 연산을 간결하고 효율적으로 표현할 수 있게 해줍니다.

---

## 결론

파이썬의 집합은 중복 제거와 빠른 멤버십 테스트에 최적화된 강력한 자료구조입니다. 수학적 집합 연산을 직관적으로 지원하며, 데이터 정제, 유효성 검사, 관계 분석 등 다양한 상황에서 효율적인 해결책을 제공합니다.

집합을 효과적으로 사용하기 위해서는 다음 사항들을 기억하는 것이 중요합니다:

1. **적절한 사용 시나리오 이해**: 멤버십 테스트, 중복 제거, 집합 연산이 필요할 때 집합을 우선적으로 고려하세요.
2. **해시 가능성 요구사항**: 집합의 요소는 반드시 해시 가능한 불변 객체여야 합니다.
3. **성능 특성 활용**: 대규모 데이터에서의 멤버십 테스트는 리스트 대비 집합이 압도적으로 빠릅니다.
4. **`frozenset`의 활용**: 딕셔너리 키나 다른 집합의 요소로 사용해야 할 때는 불변 집합인 `frozenset`을 사용하세요.
5. **순서 없는 특성 고려**: 요소 순서가 중요한 경우에는 집합 대신 리스트를 사용하거나, 순서를 유지하는 별도의 처리가 필요합니다.

집합은 파이썬의 풍부한 자료구조 중에서도 특히 우아하고 효율적인 도구로, 데이터 처리 파이프라인에서 자주 마주치는 문제들을 간결하게 해결할 수 있게 해줍니다. 집합 연산의 수학적 명확성과 파이썬 구현의 실용성이 결합되어, 복잡한 데이터 관계를 명료한 코드로 표현할 수 있는 강력한 도구가 됩니다.