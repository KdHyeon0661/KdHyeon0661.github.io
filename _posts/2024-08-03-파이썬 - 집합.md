---
layout: post
title: 파이썬 - 집합
date: 2024-08-03 19:20:23 +0900
category: Python
---
# 집합(Set)

파이썬의 **집합(`set`)**은 **중복을 허용하지 않는** 가변 컬렉션입니다.  
**순서가 없고(unordered)** **인덱싱/슬라이싱이 불가**하며, **원소 추가/삭제가 가능**합니다.  
핵심은 **“고유 원소의 모음”**과 **빠른 멤버십 테스트**(`in`)입니다.

> `{}`는 **빈 딕셔너리**입니다. **빈 집합은 `set()`**으로 만드세요.

```python
# 집합 생성
my_set   = {1, 2, 3, 4, 5}
empty    = set()          # 빈 집합
mixed    = {1, True, "a"} # 서로 다른 타입도 가능(해시 가능하면)
```

---

## 1. 주요 특징

- **순서 없음 (Unordered)**: 내부 순서에 의미가 없습니다 → 인덱싱/슬라이싱 불가.
- **중복 없음 (Unique)**: 동일하다고 판단되는 값은 하나만 유지됩니다.
- **가변 (Mutable)**: `add`, `remove`, `discard`, `pop`, `clear`, `update` 등 지원.
- **집합 연산**: 합집합, 교집합, 차집합, 대칭차 등을 **연산자/메서드**로 지원.
- **원소는 해시 가능(hashable)** 이어야 함: 숫자/문자열/불변 튜플/`frozenset` 등은 가능, 리스트/딕셔너리/일반 set은 불가.

```python
ok   = {(1, 2), "x", 42}
# not_ok = {[1, 2]}         # TypeError: list는 해시 불가
# not_ok = { {1, 2} }       # TypeError: set도 해시 불가 (대신 frozenset 사용)
```

---

## 2. 생성과 기본 조작

```python
s = {1, 2, 3}
t = set([3, 4, 5])         # 임의의 이터러블로부터
u = set("hello")           # {'h', 'e', 'l', 'o'} (문자 단위 분해 주의)

# 존재 여부
print(3 in s)              # True

# 추가/삭제
s.add(4)                   # {1,2,3,4}
s.discard(2)               # {1,3,4} (없어도 오류 X)
# s.remove(2)              # KeyError (없으면 오류)
x = s.pop()                # 임의의 원소 하나 제거/반환 (어떤 값일지는 미정)
s.clear()                  # 빈 집합
```

> 문자열 전체를 한 원소로 넣고 싶다면 **`add("hello")`** 혹은 **`update(["hello"])`**를 사용하세요.  
> `update("hello")`는 `{'h','e','l','l','o'}`처럼 **문자 단위로** 들어갑니다.

---

## 3. 집합 연산: 연산자와 메서드

### 3.1 합집합 / 교집합 / 차집합 / 대칭차

```python
A = {1, 2, 3}
B = {3, 4, 5}

print(A | B)                  # 합집합: {1,2,3,4,5}
print(A & B)                  # 교집합: {3}
print(A - B)                  # 차집합: {1,2}
print(B - A)                  # 차집합: {4,5}
print(A ^ B)                  # 대칭차: {1,2,4,5}

print(A.union(B))             # 합집합
print(A.intersection(B))      # 교집합
print(A.difference(B))        # 차집합
print(A.symmetric_difference(B))  # 대칭차
```

### 3.2 “제자리” 갱신 (수정형)

```python
A |= B                        # A = A ∪ B
A &= B                        # A = A ∩ B
A -= B                        # A = A \ B
A ^= B                        # A = A △ B

# 메서드 버전
A.update(B)
A.intersection_update(B)
A.difference_update(B)
A.symmetric_difference_update(B)
```

> 큰 데이터에서 **제자리 갱신**은 **새 집합 생성보다 메모리를 아낄 수** 있습니다.

### 3.3 부분집합/상위집합/교집합 공집합 여부

```python
A = {1, 2, 3}
B = {1, 2}

print(B <= A)                 # 부분집합: True  (B.issubset(A))
print(B <  A)                 # 진부분집합: True
print(A >= B)                 # 상위집합: True  (A.issuperset(B))
print(A >  B)                 # 진상위집합: True
print(A.isdisjoint({4, 5}))   # 교집합이 공집합? True
```

---

## 4. 주요 메서드 레퍼런스

| 메서드 | 설명 | 예시 |
|---|---|---|
| `add(x)` | 원소 추가 | `s.add(10)` |
| `remove(x)` | 원소 제거 (없으면 `KeyError`) | `s.remove(3)` |
| `discard(x)` | 원소 제거 (없어도 조용히 통과) | `s.discard(3)` |
| `pop()` | 임의의 원소 제거·반환 | `x = s.pop()` |
| `clear()` | 전부 삭제 | `s.clear()` |
| `copy()` | 얕은 복사 | `t = s.copy()` |
| `update(*iterables)` | 합집합로 제자리 갱신 | `s.update([3,4], {5})` |
| `intersection(*iterables)` | 교집합 반환 | `s.intersection(t, u)` |
| `intersection_update(*it)` | 교집합로 제자리 갱신 | `s.intersection_update(t)` |
| `difference(*iterables)` | 차집합 반환 | `s.difference(t)` |
| `difference_update(*it)` | 차집합로 제자리 갱신 | `s.difference_update(t)` |
| `symmetric_difference(t)` | 대칭차 반환 | `s.symmetric_difference(t)` |
| `symmetric_difference_update(t)` | 대칭차로 제자리 갱신 | `s.symmetric_difference_update(t)` |
| `issubset(t)`/`issuperset(t)` | 부분/상위집합 검사 | `A.issubset(B)` |
| `isdisjoint(t)` | 교집합 공집합 여부 | `A.isdisjoint(B)` |

---

## 5. 시간 복잡도 & 성능 감각

- 평균적으로 **멤버십 테스트/추가/삭제 → O(1)** (해시 테이블 기반)  
- 합집합/교집합/차집합: 집합 크기에 비례 (대략 O(n) ~ O(n+m))
- **리스트 대비 멤버십 테스트가 매우 빠름** → **중복 제거/필터링**에 적합

```python
# 멤버십 테스트 예시
whitelist = set(["A", "B", "C"])
for x in ["A", "X", "B"]:
    if x in whitelist:    # 평균 O(1)
        ...
```

> **정렬이 필요하면** 집합을 **리스트로 변환 후 `sorted()`** 하세요.  
> 집합 자체는 순서가 없습니다.

---

## 6. 집합 내포(Set Comprehension)

```python
# 제곱 수 집합 (중복 자동 제거)
squares = {x*x for x in range(10)}           # {0,1,4,9,16,25,36,49,64,81}

# 필터 포함
evens = {x for x in range(20) if x % 2 == 0} # {0,2,4,...,18}
```

---

## 7. `frozenset`: 불변 집합(해시 가능)

- **불변/해시 가능** 집합 → **딕셔너리 키**나 **다른 집합의 원소**로 사용 가능
- 연산은 동일(합/교/차/대칭차 등)하나, **추가/삭제 불가**

```python
fs = frozenset([1, 2, 3])
# fs.add(4)        # AttributeError

outer = {fs, frozenset({3, 4})}     # OK: set of frozensets
d = {fs: "group1"}                  # dict key로도 가능
```

---

## 8. 자주 하는 실수 & 안전 패턴

### 8.1 빈 집합
```python
empty = set()   # O
# empty = {}    # X — 빈 dict
```

### 8.2 반복 가능한 인수에 문자열 전달
```python
s = set()
s.update("abc")         # {'a','b','c'}  ← 문자 단위로 들어감
s.update(["abc"])       # {'a','b','c', 'abc'} (두 번째는 리스트 원소 그대로)
s.add("abc")            # {'a','b','c','abc'}
```

### 8.3 순회하며 동시에 수정 금지
```python
s = {1, 2, 3, 4}
# for x in s:
#     if x % 2 == 0:
#         s.remove(x)   # RuntimeError 가능

to_del = {x for x in s if x % 2 == 0}
s -= to_del             # 안전
```

### 8.4 중복 제거 시 순서 유지
집합은 순서를 보존하지 않으므로, **처음 등장 순서를 유지**하며 중복 제거하려면:

```python
seen = set()
unique = [x for x in ["b","a","b","c","a"]
          if not (x in seen or seen.add(x))]
print(unique)           # ['b','a','c']
```

또는 **3.7+**: `dict.fromkeys(seq)` 활용

```python
unique = list(dict.fromkeys(["b","a","b","c","a"]))  # ['b','a','c']
```

---

## 9. 실전 스니펫

### 9.1 교집합 기반 필터
```python
required = {"id", "name", "age"}
payload  = {"id", "name", "age", "country"}

if required <= payload:
    print("모든 필수 필드 존재")
```

### 9.2 빠른 차집합으로 누락 항목 찾기
```python
expected = set(range(1, 11))
arrived  = {2, 3, 5, 7, 11, 13}
missing  = expected - arrived
print(missing)  # {1,4,6,8,9,10}
```

### 9.3 두 컬렉션의 공통 요소 감지 (효율)
```python
def any_common(a, b):
    return not set(a).isdisjoint(b)   # 교집합이 공집합이 아니면 True

print(any_common([1,2,3], [3,4]))     # True
```

### 9.4 텍스트 단어 집합과 중복 제거
```python
text = "to be or not to be that is the question"
words = text.split()
vocab = set(words)         # 고유 단어 집합
print(sorted(vocab))       # 정렬이 필요할 땐 sorted
```

### 9.5 그래프 인접 집합 표현
```python
graph = {
    "A": {"B", "C"},
    "B": {"A", "D"},
    "C": {"A", "D"},
    "D": {"B", "C"},
}
# 이웃 합집합
neighbors = graph["B"] | graph["C"]   # {'A','D'}
```

---

## 10. 수학적 메모 (카디널리티/포뮬러)

집합의 기본 공식(카디널리티) — **중복이 자동 제거**된다는 점과 연계해 생각해보면 직관적입니다.

$$
\begin{aligned}
&|A \cup B| = |A| + |B| - |A \cap B| \\
&|A \triangle B| = |A \cup B| - |A \cap B|
\end{aligned}
$$

파이썬에서는 연산자(`|`, `&`, `^`)와 함수를 통해 위 개념을 그대로 코드로 옮길 수 있습니다.

---

## 11. 요약 체크리스트

- **중복 제거/멤버십 검사**는 `set`이 정답 — 평균 O(1).
- **원소는 해시 가능**해야 함: 숫자/문자열/불변 튜플/`frozenset` 등.
- **빈 집합은 `set()`** ( `{}`는 dict ).
- **연산자 vs 메서드**: `| & - ^`, `union/intersection/difference/symmetric_difference`.
- **제자리 갱신**: `|=`, `&=`, `-=`, `^=` 또는 `*_update` 메서드.
- **순서 필요** 시 `sorted(set_obj)` 또는 중복 제거 시 `dict.fromkeys`.
- **불변 집합 필요** 시 `frozenset` 사용(키/원소로 활용 가능).

---

## 12. 종합 예제

```python
# 1. 로그 라인에서 고유 사용자 추출 + 공통/차이 계산
logs1 = ["alice", "bob", "alice", "choi"]
logs2 = ["bob", "dave", "alice", "erin"]

S1, S2 = set(logs1), set(logs2)
print("고유1:", S1)                      # {'alice','bob','choi'}
print("고유2:", S2)                      # {'alice','bob','dave','erin'}

print("공통:", S1 & S2)                  # {'alice','bob'}
print("서로만:", S1 ^ S2)               # {'choi','dave','erin'}
print("1만:", S1 - S2)                   # {'choi'}

# 2. 필수 권한 검사 (부분집합)
required = {"read", "write"}
granted  = {"read", "write", "delete"}
print(required <= granted)               # True

# 3. 순회 중 안전 제거
s = {0, 1, 2, 3, 4, 5}
to_remove = {x for x in s if x % 2 == 0}
s -= to_remove
print(s)                                 # {1, 3, 5}

# 4. frozenset로 딕셔너리 키 만들기
edges = {frozenset({"A","B"}): 7, frozenset({"B","C"}): 5}
print(edges[frozenset({"B","A"})])       # 7 (무향 간선처럼 취급)
```