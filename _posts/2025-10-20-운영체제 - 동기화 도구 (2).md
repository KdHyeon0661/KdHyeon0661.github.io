---
layout: post
title: 운영체제 - 동기화 도구 (2)
date: 2025-10-20 18:25:23 +0900
category: 운영체제
---
# Synchronization Tools (2)

## 6.4 Hardware Support for Synchronization

### 6.4.1 왜 하드웨어 지원이 필요한가
소프트웨어만으로 상호배제를 보장하려면 **강한 메모리 모델**과 섬세한 프로토콜(Peterson, Bakery)이 필요하다.
현대 CPU는 재배치/캐시/파이프라인 때문에 이를 만족시키기 어렵다. **원자적 RMW(읽기-수정-쓰기) 명령**과 **메모리 배리어**가 필수다.

### 6.4.2 대표 원자 연산
- **Test-and-Set (TAS)**
  원자적으로 `old = *p; *p = 1; return old;`
- **Compare-and-Swap (CAS)**
  `CAS(p, expected, new)`: `*p == expected`이면 `*p = new` 하고 **성공(true)**, 아니면 **실패(false)**
- **Fetch-and-Add (FAA)**
  `old = *p; *p += k; return old;` — 카운터/티켓락에 유용
- **Load-Linked/Store-Conditional (LL/SC)** (MIPS/ARM 일부)
  `LL`로 주소 감시, 이후 `SC`가 **감시 유효**시 성공

#### C++ 원자 API로 TAS/CAS 표현
```cpp
// tas_cas.cpp
#include <atomic>
bool tas(std::atomic<int>& lock){
    int expected = 0;              // 0: unlock, 1: lock
    return !lock.compare_exchange_strong(expected, 1,
                                          std::memory_order_acquire,
                                          std::memory_order_relaxed);
    // 실패 시 true(이미 누가 잡음), 성공 시 false
}
bool try_lock(std::atomic<int>& lock){
    int expected=0;
    return lock.compare_exchange_strong(expected,1,
                                        std::memory_order_acquire,
                                        std::memory_order_relaxed);
}
void unlock(std::atomic<int>& lock){
    lock.store(0, std::memory_order_release);
}
```

### 6.4.3 메모리 배리어(펜스)
- **Release**: 이전 write들이 외부에 보이도록 푸시
- **Acquire**: 이후 read가 앞선 write들을 관측하도록 순서 고정
- **Seq_cst**: 가장 강함(간단하지만 비용↑)

> **정리**: 락 획득에는 **acquire**, 해제에는 **release** 가 기본.
> 락 구현 내부에서 **crit-section의 모든 접근을 HB(happens-before)** 로 엮는 목적.

### 6.4.4 단순 스핀락 vs 개선 스핀락

#### (A) 단순 TAS 스핀락 (공정성/확장성 낮음)
```cpp
// spin_tas.h
#include <atomic>
struct SpinTAS {
    std::atomic<int> s{0};
    void lock(){ while(tas(s)) { /* busy */ } }
    void unlock(){ s.store(0, std::memory_order_release); }
};
```
- 장점: 구현 간단
- 단점: **경합 시 캐시 라인 뺏기기(thundering herd)**, 공정성 없음

#### (B) Test-Test-and-Set (TTAS) — 캐시 버스 감소
```cpp
struct SpinTTAS {
    std::atomic<int> s{0};
    void lock(){
        for(;;){
            while(s.load(std::memory_order_relaxed)!=0) { /* shared read spin */ }
            int expected=0;
            if(s.compare_exchange_weak(expected,1,std::memory_order_acquire)) return;
        }
    }
    void unlock(){ s.store(0, std::memory_order_release); }
};
```
- 바쁜 대기는 대부분 **shared read** (버스/Invalidation 감소)

#### (C) 티켓락 (FIFO 공정성, NUMA/SMT 영향)
```cpp
// ticket_lock.h
#include <atomic>
struct TicketLock {
    std::atomic<unsigned> next{0}, owner{0};
    void lock(){
        unsigned my = next.fetch_add(1, std::memory_order_relaxed);
        while(owner.load(std::memory_order_acquire)!=my) { /* spin */ }
    }
    void unlock(){
        owner.fetch_add(1, std::memory_order_release);
    }
};
```
- **공정(FIFO)** 보장, 다만 **모두가 owner 캐시라인에 스핀** → 코어 수↑ 시 스케일링 저하

#### (D) MCS 락 (큐잉 스핀락, 확장성↑)
```cpp
// mcs_lock.h (학습용 축약)
#include <atomic>
struct MCSNode { std::atomic<MCSNode*> next{nullptr}; std::atomic<bool> locked{false}; };
struct MCSLock {
    std::atomic<MCSNode*> tail{nullptr};
    void lock(MCSNode* me){
        me->next.store(nullptr, std::memory_order_relaxed);
        MCSNode* pred = tail.exchange(me, std::memory_order_acq_rel);
        if(pred){
            me->locked.store(true, std::memory_order_relaxed);
            pred->next.store(me, std::memory_order_release);
            while(me->locked.load(std::memory_order_acquire)) { /* local spin */ }
        }
    }
    void unlock(MCSNode* me){
        MCSNode* succ = me->next.load(std::memory_order_acquire);
        if(!succ){
            MCSNode* expected=me;
            if(tail.compare_exchange_strong(expected,nullptr,std::memory_order_acq_rel)) return;
            // 기다리는 동안 successor가 링크될 수 있으므로
            while(!(succ = me->next.load(std::memory_order_acquire))) { /* wait link */ }
        }
        succ->locked.store(false, std::memory_order_release);
    }
};
```
- **각 스레드가 자신의 노드에서만 스핀** → 캐시 간섭/버스 트래픽 최소화, 고경합에서 탁월

### 6.4.5 백오프(backoff)와 휴식(hint)
경합에서 연속 실패 시 **지수 백오프**로 버스/전력 절감. x86 `pause`, ARM `yield` 힌트로 SMT 간섭 완화.

```cpp
// backoff.h
static inline void cpu_relax(){
#if defined(__x86_64__) || defined(__i386__)
    __builtin_ia32_pause();
#elif defined(__aarch64__)
    asm volatile("yield");
#endif
}
```

---

## 6.5 Mutex Locks

### 6.5.1 개념과 API
- **상호배제 객체**: 한 시점 **단 하나의 소유자**.
- **기본 연산**: `lock()/unlock()` + `try_lock()` + `timed_lock()`
- 구현은 **스핀 → 커널 대기(futex 등)** 의 **2단계**가 보편적: 경합 짧으면 스핀, 길면 수면.

### 6.5.2 사용자 수준 구현 스케치: 스핀→슬립 하이브리드
```cpp
// mutex_hybrid.cpp (리눅스 futex 의존, 학습용)
#include <atomic>
#include <linux/futex.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <errno.h>

static int futex_wait(std::atomic<int>* addr, int val){
    return syscall(SYS_futex, reinterpret_cast<int*>(addr), FUTEX_WAIT, val, NULL, NULL, 0);
}
static int futex_wake(std::atomic<int>* addr, int n){
    return syscall(SYS_futex, reinterpret_cast<int*>(addr), FUTEX_WAKE, n, NULL, NULL, 0);
}

struct HybridMutex {
    std::atomic<int> state{0}; // 0: unlocked, 1: locked no-waiter, 2: locked with waiters
    void lock(){
        int spins=1000;
        for(int i=0;i<spins;i++){
            int ex=0;
            if(state.compare_exchange_weak(ex,1,std::memory_order_acquire)) return;
            // 가벼운 대기
            __builtin_ia32_pause();
        }
        // 슬립 경로
        int s = state.exchange(2, std::memory_order_acquire);
        while(s!=0){
            futex_wait(&state, 2);
            s = state.exchange(2, std::memory_order_acquire);
        }
    }
    void unlock(){
        int s = state.load(std::memory_order_relaxed);
        if(s==2){
            state.store(0, std::memory_order_release);
            futex_wake(&state, 1);
        }else{
            state.store(0, std::memory_order_release);
        }
    }
};
```
> **아이디어**: **짧은 임계구역**은 스핀으로, **긴 대기**는 커널에 위임. 실제 glibc/pthread mutex도 유사한 계층을 가진다.

### 6.5.3 사용 패턴과 베스트 프랙티스
- **RAII**로 반드시 해제를 보장
```cpp
#include <mutex>
std::mutex m;
void foo(){
    std::lock_guard<std::mutex> g(m); // 예외/return 경로에서도 자동 unlock
    // critical work
}
```
- **데드락 회피**:
  1) **정해진 순서**로 다중 락 획득
  2) `std::scoped_lock(a,b,c)` (교착 회피 알고리즘 내장)
  3) 가능한 **락 분할(sharding)**, **락 범위 축소**, **읽기-쓰기 락** 고려
- **`try_lock` 루프**는 백오프/양보를 섞어 CPU 낭비 줄이기
- **높은 경합**: **티켓락/MCS** 또는 **파티셔닝** 고려
- **NUMA/SMT**: 락 보호 데이터와 **같은 노드**에 스레드를 위치

### 6.5.4 공정성(Fairness)과 우선순위 역전
- **티켓락**은 FIFO로 기아 방지
- OS 뮤텍스는 **Priority Inheritance(PI)** 를 옵션으로 제공 가능 (리눅스 PI 뮤텍스, RT 시스템)

### 6.5.5 Readers–Writers 락(요약)
- **읽기 다수/쓰기 하나**. 읽기가 대부분이면 수익, 쓰기 비율 커지면 경합/스위칭 비용 증가.
- **스타베이션** 방지 정책(쓰기 우선/공정 정책)을 명시적으로 선택.

```cpp
// pthread_rwlock 사용 예
#include <pthread.h>
pthread_rwlock_t rw = PTHREAD_RWLOCK_INITIALIZER;
```

### 6.5.6 성능 계측 팁
- **락 경합**: Linux `perf lock`, bpftrace로 `futex_wait` 핫스폿
- **CS 길이 측정**: TSX(가능 시) or TSC 읽기, 샘플링 프로파일
- **p95/p99** 지연 관찰: 긴 꼬리의 원인 파악(메모리/NUMA/SMT 간섭)

---

## 6.6 Semaphores

### 6.6.1 개념
- **세마포어 S**: 정수 카운터 + 큐
  - **wait(P)**: `while S==0 wait; S--`
  - **signal(V)**: `S++ ; if (waiters) wake one`
- **이진 세마포어**: 뮤텍스와 유사(소유 개념은 약함)
- **카운팅 세마포어**: 버퍼 슬롯, 연결 수 등 **정량 자원** 제어

수학적 표기:
$$
\begin{aligned}
\text{wait}(S): &\quad S := S - 1; \quad \text{if } S < 0 \text{ then block()} \\
\text{signal}(S): &\quad S := S + 1; \quad \text{if } S \le 0 \text{ then wakeup()}
\end{aligned}
$$
> 많은 교재에서 **음수**를 대기자 수로 쓰지만, 실제 구현은 **비음수 카운터 + 대기 큐**로 표현한다.

### 6.6.2 POSIX 세마포어 사용 (이식성↑)
```c
// sem_posix.c
#include <semaphore.h>
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

sem_t slots, items; // bounded buffer slots/items
int buf[8], head=0, tail=0;

void* prod(void*){
    for(int x=1;x<=20;x++){
        sem_wait(&slots);          // 빈 슬롯 확보
        buf[head]=x; head=(head+1)%8;
        sem_post(&items);          // 아이템 증가 알림
        usleep(10000);
    }
    return NULL;
}
void* cons(void*){
    for(int i=0;i<20;i++){
        sem_wait(&items);          // 아이템 대기
        int x=buf[tail]; tail=(tail+1)%8;
        sem_post(&slots);          // 빈 슬롯 반환
        printf("got %d\n", x);
    }
    return NULL;
}

int main(){
    sem_init(&slots,0,8); // 초기 슬롯=버퍼 크기
    sem_init(&items,0,0); // 초기 아이템=0
    pthread_t p,c; pthread_create(&p,NULL,prod,NULL); pthread_create(&c,NULL,cons,NULL);
    pthread_join(p,NULL); pthread_join(c,NULL);
    sem_destroy(&slots); sem_destroy(&items);
}
```

### 6.6.3 세마포어로 **뮤텍스** 흉내내기 (이진 세마포어)
```c
// bin_sem_mutex.c
#include <semaphore.h>
#include <pthread.h>
#include <stdio.h>
sem_t bin; int shared=0;

void* worker(void*){
    for(int i=0;i<100000;i++){
        sem_wait(&bin);    // lock
        shared++;          // CS
        sem_post(&bin);    // unlock
    }
    return NULL;
}
int main(){
    sem_init(&bin,0,1); // 1 → unlock
    pthread_t a,b; pthread_create(&a,NULL,worker,NULL); pthread_create(&b,NULL,worker,NULL);
    pthread_join(a,NULL); pthread_join(b,NULL);
    printf("shared=%d\n", shared);
}
```

### 6.6.4 생산자/소비자 (Bounded Buffer) — 세마포어 + 뮤텍스 조합
- **세마포어 `slots`**: 남은 슬롯 수
- **세마포어 `items`**: 사용 가능 아이템 수
- **뮤텍스 `m`**: 큐(헤드/테일) 조작 보호

```c
// pc_combo.c
#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>

#define CAP 8
int q[CAP], h=0, t=0;
sem_t slots, items;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

void* prod(void*){
    for(int x=1;x<=40;x++){
        sem_wait(&slots);
        pthread_mutex_lock(&m);
        q[h]=x; h=(h+1)%CAP;
        pthread_mutex_unlock(&m);
        sem_post(&items);
    }
    return NULL;
}
void* cons(void*){
    for(int i=0;i<40;i++){
        sem_wait(&items);
        pthread_mutex_lock(&m);
        int x=q[t]; t=(t+1)%CAP;
        pthread_mutex_unlock(&m);
        sem_post(&slots);
        printf("got %d\n", x);
    }
    return NULL;
}
```

### 6.6.5 Readers–Writers (세마포어 버전: 쓰기 우선/읽기 우선 변형)

#### (A) 간단 “읽기 우선” 모델 — 쓰기가 기아 가능
```c
// rw_readpref.c
#include <semaphore.h>
#include <pthread.h>
#include <stdio.h>

sem_t rw_mutex;   // 공유 데이터 보호(읽기/쓰기 모두 필요)
sem_t rcount_mux; // rcount 보호
int readcount=0;  // 현재 reader 수

void* reader(void*){
    sem_wait(&rcount_mux);
    readcount++;
    if(readcount==1) sem_wait(&rw_mutex); // 첫 reader가 writer 차단
    sem_post(&rcount_mux);

    // 읽기 구역 ...

    sem_wait(&rcount_mux);
    readcount--;
    if(readcount==0) sem_post(&rw_mutex); // 마지막 reader가 writer 허용
    sem_post(&rcount_mux);
    return NULL;
}
void* writer(void*){
    sem_wait(&rw_mutex);
    // 쓰기 구역 ...
    sem_post(&rw_mutex);
    return NULL;
}
```

#### (B) “쓰기 우선” 모델 — 기아 방지(대기열 관문)
```c
// rw_writepref.c
sem_t rw_mutex, rcount_mux, queue; // queue로 공정성 부여
int readcount=0;

void* reader(void*){
    sem_wait(&queue);               // 대기열 통과
    sem_wait(&rcount_mux);
    readcount++;
    if(readcount==1) sem_wait(&rw_mutex);
    sem_post(&rcount_mux);
    sem_post(&queue);

    // 읽기 ...

    sem_wait(&rcount_mux);
    readcount--;
    if(readcount==0) sem_post(&rw_mutex);
    sem_post(&rcount_mux);
    return NULL;
}
void* writer(void*){
    sem_wait(&queue);       // 대기열 통과
    sem_wait(&rw_mutex);
    // 쓰기 ...
    sem_post(&rw_mutex);
    sem_post(&queue);
    return NULL;
}
```
- `queue`를 통해 **독점 진입 순서**를 만들며 writer 기아 방지.

### 6.6.6 Dining Philosophers — 세마포어 해법(간단, 기아 가능성 있음)
```c
// dining_simple.c (N 철학자, 포크=세마포어)
#include <semaphore.h>
#include <pthread.h>
#include <stdio.h>
#define N 5
sem_t forkS[N];

void* phil(void* arg){
    int i=(int)(size_t)arg, left=i, right=(i+1)%N;
    for(int k=0;k<100;k++){
        // 생각
        // 포크 집기(순서 동형이면 교착 위험 → 한명은 반대 순서로)
        if(i==0){ sem_wait(&forkS[right]); sem_wait(&forkS[left]); }
        else    { sem_wait(&forkS[left]);  sem_wait(&forkS[right]); }
        // 식사
        sem_post(&forkS[left]); sem_post(&forkS[right]);
    }
    return NULL;
}
int main(){
    for(int i=0;i<N;i++) sem_init(&forkS[i],0,1);
    pthread_t t[N]; for(int i=0;i<N;i++) pthread_create(&t[i],NULL,phil,(void*)(size_t)i);
    for(int i=0;i<N;i++) pthread_join(t[i],NULL);
}
```
- 개선: **중재자(웨이터) 세마포어**를 두어 `N-1`명만 동시에 포크를 들게 하거나, **자원 계수**/우선순위 도입.

### 6.6.7 세마포어의 함정과 모범 사례
- **순서 역전**: `wait(A); wait(B);` 와 다른 스레드의 `wait(B); wait(A);` → 교착
- **signal 잊음**: 영원히 자원 복구 안 됨 → RAII 스타일 래핑 권장
- **과도한 사용**: 뮤텍스/조건변수로 더 명확한 표현이 가능하면 그쪽을 우선
- **스핀 기반 세마포어**: 경합 짧은 경우만(그 외엔 커널 기반이 낫다)

### 6.6.8 세마포어 vs 조건변수
- 조건변수는 **조건(predicate)** 와 **뮤텍스 보호된 상태** 개념이 결합
- 세마포어는 **수량 자체**를 동기화 — **생산자/소비자** 패턴에 직관적

---

## 종합 예제 — “N-프로듀서 / M-컨슈머” 고성능 파이프라인
- **슬롯 세마포어**: `slots` (초기 CAP)
- **아이템 세마포어**: `items` (초기 0)
- **락**: MCS 락(고경합 시 확장성↑) 또는 `pthread_mutex`
- **배치 처리**: 컨슈머가 한 번에 여러 아이템을 가져가 **컨텍스트 스위치 감소**

```cpp
// pipeline.cpp (개념 구현)
#include <pthread.h>
#include <semaphore.h>
#include <vector>
#include <iostream>

constexpr int CAP=1024;
int q[CAP], h=0, t=0;
sem_t slots, items;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

void* prod(void* arg){
    int id=(int)(size_t)arg;
    for(int x=0;x<50000;x++){
        sem_wait(&slots);
        pthread_mutex_lock(&m);
        q[h]= (id<<24) | x;
        h = (h+1)%CAP;
        pthread_mutex_unlock(&m);
        sem_post(&items);
    }
    return NULL;
}
void* cons(void*){
    long long cnt=0;
    for(;;){
        // 종료 조건 예시 생략… (테스트에서는 총 생산량 기준)
        sem_wait(&items);
        pthread_mutex_lock(&m);
        int v = q[t]; t=(t+1)%CAP;
        pthread_mutex_unlock(&m);
        sem_post(&slots);
        cnt += v&0xFFFFFF ? 1:1;
        if(cnt>= (long long)4*50000) break;
    }
    std::cout<<"consumed="<<cnt<<"\n";
    return NULL;
}
int main(){
    sem_init(&slots,0,CAP);
    sem_init(&items,0,0);
    pthread_t p[4]; for(int i=0;i<4;i++) pthread_create(&p[i],NULL,prod,(void*)(size_t)i);
    pthread_t c; pthread_create(&c,NULL,cons,NULL);
    for(int i=0;i<4;i++) pthread_join(p[i],NULL);
    pthread_join(c,NULL);
}
```

---

## 운영/성능 체크리스트

1) **경합 관측**: `perf lock`, bpftrace `kprobe:futex_wait`
2) **슬라이스/배치**: 컨슈머의 배치 크기 튜닝 → p95 지연과 처리량 균형
3) **NUMA**: 버퍼를 노드별 **샤딩**(세마포어/락도 샤딩)
4) **락 선택**:
   - 경합 낮음: `std::mutex`/pthreads 기본
   - 경합 높음/코어↑: **MCS/티켓락**, 또는 분할/락프리 큐
5) **전력/열**: 스핀 백오프/`pause`/`yield` 활용, 긴 대기는 커널 수면으로

---

## 요약

- **6.4**: TAS/CAS/FAA 같은 **원자 연산**과 **배리어**가 상호배제의 기반. 스핀락은 단순하지만, **티켓/MCS**가 고경합에서 더 좋다.
- **6.5**: 실제 뮤텍스는 **스핀→슬립** 하이브리드. RAII, 순서 규약, 공정성/PI, NUMA 고려가 핵심.
- **6.6**: 세마포어는 **정량 자원** 동기화에 적합. bounded buffer, readers–writers, dining philosophers 등 고전 문제를 자연스럽게 풀 수 있다. 단, **교착/기아/과사용**에 주의.

---

## 추가 과제

1) **티켓락 vs MCS**: 코어 수(2→64)와 경합 수준을 바꿔 평균 획득 지연/버스 이벤트를 비교하라.
2) **세마포어 파라미터 스윕**: CAP, 프로듀서/컨슈머 수를 바꿔 처리량과 p99 지연을 플롯하라.
3) **하이브리드 뮤텍스**의 스핀 횟수(예: 100, 1,000, 10,000)를 바꿔 **전환 임계점**을 찾고, 워크로드별 최적값을 논하라.
4) **Readers–Writers**: 읽기:쓰기 비율(9:1, 1:1, 1:9)에서 읽기 우선/쓰기 우선/공정 정책을 비교하라.
5) **Dining Philosophers**:
