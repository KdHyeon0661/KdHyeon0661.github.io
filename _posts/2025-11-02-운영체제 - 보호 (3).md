---
layout: post
title: 운영체제 - 보호 (3)
date: 2025-11-02 16:25:23 +0900
category: 운영체제
---
# Chapter 17 — Protection (3)

## 17.7 Revocation of Access Rights

### 17.7.1 무엇을 철회(revoke)하나
권한은 **주체 S**가 **객체 O**에 대해 수행할 수 있는 **연산 집합 R**이다. 접근행렬 $$M$$에서 셀 $$M[S,O]\subseteq R$$ 을 **축소**하는 것이 철회다. 운영 관점에서 철회는 다음 속성으로 구분된다.

- **즉시 vs 지연**: 지금 막 **효력 발휘** vs TTL/리스 만료 후.
- **선택적 vs 전체**: 특정 주체/세션/핸들 **만** vs **모두**.
- **강제 vs 우아한**: 열린 핸들 강제 차단 vs 새 접근만 차단.
- **영구 vs 일시**: 회수/휴지 vs 임시 중단(maintenance).

> **현실의 함정**: ACL에서 권한을 지워도 **이미 열린 FD/핸들**은 여전히 유효할 수 있다. → 능력(capability)의 **간접화/버전**, **키 회전**, **리스**가 필요.

---

### 17.7.2 패턴 ① — ACL 기반 즉시 철회
객체의 ACL에서 엔트리를 제거한다. 새 `open()`은 막히지만 **기존 FD**는 살아있을 수 있다.

```bash
# POSIX ACL 예시 (리눅스)
setfacl -m u:alice:r-- /srv/data/report.csv   # 부여
setfacl -x u:alice   /srv/data/report.csv     # 철회
getfacl            /srv/data/report.csv
```

장점: 단순/직관.
단점: 열린 핸들 대응이 약함.

---

### 17.7.3 패턴 ② — 능력(capability) **간접화/버전**으로 선택적 철회
객체에 **버전**을 두고, 능력에는 (oid, version)을 포함한다. 객체의 버전을 증가시키면 **기존 능력**이 한 번에 무효화된다.

```python
# cap_revoke.py — 선택적 철회를 지원하는 간단한 능력 테이블
import os
class CapTable:
    def __init__(self):
        self.obj = {}     # oid -> {"data": bytes, "ver": int}
        self.caps = {}    # capid -> (oid, ver, rights)

    def create(self, data=b""):
        oid=os.urandom(8).hex()
        self.obj[oid]={"data":data, "ver":1}
        return oid

    def issue(self, oid, rights):
        cap=os.urandom(8).hex()
        self.caps[cap]=(oid, self.obj[oid]["ver"], set(rights))
        return cap

    def revoke_all_for_object(self, oid):
        self.obj[oid]["ver"] += 1           # 기존 cap 전부 무효화

    def read(self, cap):
        oid, ver, rights = self.caps[cap]
        if ver != self.obj[oid]["ver"] or "read" not in rights:
            raise PermissionError("revoked")
        return self.obj[oid]["data"]
```

장점: 열린 핸들 문제를 **객체 단위**로 일괄 해결.
단점: 구현 복잡도↑(참조를 항상 **간접 참조**해야 함).

---

### 17.7.4 패턴 ③ — **Lock–Key(자물쇠–열쇠)** 와 키 회전
여러 객체를 **키 집합**으로 보호하고, 주체는 **키**를 보유. 키를 회전하면 그 키로 보호되는 객체에 대한 접근을 **그룹 단위**로 철회 가능.

```python
# lock_key_revoke.py — 그룹 철회
class LK:
    def __init__(self):
        self.lock = {}     # obj -> set(keys)
        self.keys = {}     # subject -> set(keys)

    def allow(self, obj, *keys): self.lock.setdefault(obj,set()).update(keys)
    def give(self, s, *keys):     self.keys.setdefault(s,set()).update(keys)

    def can(self, s, obj): return len(self.lock[obj] & self.keys.get(s,set()))>0

    def rotate(self, oldk, newk):
        for o in self.lock:
            if oldk in self.lock[o]:
                self.lock[o].remove(oldk); self.lock[o].add(newk)
        # 주체 키도 배포/교체 필요
```

장점: **역할/부서** 단위 철회에 적합.
단점: 키 배포/교체 파이프라인 필요(운영 자동화).

---

### 17.7.5 패턴 ④ — **리스/만료(lease/TTL)**, **콜백 리콜**
권한을 **유효기간**으로 부여. 서버는 만료/리콜 시 새 접근을 거부하고, 필요하면 **콜백**으로 캐시 파기(예: NFSv4 delegation recall).

```python
# lease.py — TTL 기반 접근
import time
class LeaseCaps:
    def __init__(self): self.cap={}
    def issue(self, target, ttl):
        c=os.urandom(6).hex(); self.cap[c]=(target, time.time()+ttl); return c
    def use(self, c):
        tgt, exp=self.cap[c]
        if time.time()>exp: raise PermissionError("expired")
        return tgt
```

장점: 자동 회수, 대규모 분산에 적합.
단점: **시계 동기/네트워크** 전제, 만료 전 즉시 철회는 콜백/브레이크 필요.

---

### 17.7.6 패턴 ⑤ — **암호학적 철회**(Envelope + KID/회전)
데이터는 **자료키(DEK)** 로 암호화하고, **마스터키(MK)** 로 DEK를 래핑. **KID**로 키 버전을 식별. 접근 철회는 **새 KID로 재암호화** → 구 KID 폐기.

```python
# crypto_revoke.py — KID로 래핑된 DEK 회전(개념)
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os
store = {}  # obj -> {"kid":kid, "nonce":n, "ct":ct}
kms   = {"K1": os.urandom(32), "K2": os.urandom(32)}  # MK들

def wrap_dek(kid, dek):  # 간략화를 위해 XOR(실무: KMS wrap)
    from secrets import token_bytes
    mk=kms[kid]; return bytes(a^b for a,b in zip(dek,mk))

def encrypt(obj, kid, plain):
    dek=os.urandom(32); aes=AESGCM(dek); n=os.urandom(12)
    ct=aes.encrypt(n, plain, b"aad")
    w=wrap_dek(kid, dek)
    store[obj]={"kid":kid,"nonce":n,"ct":w+ct}

def rotate(obj, newkid):
    rec=store[obj]; oldkid=rec["kid"]
    # 복호(구 키 필요)→재암호(신 키). 생략: 실제 복호/검증.
    rec["kid"]=newkid
```

장점: 데이터가 **외부로 복제**되어도 키 교체로 효력 상실.
단점: 재암호/키 관리 비용.

---

### 17.7.7 운영 체크리스트
- 열린 FD/핸들 **상속 방지**: `O_CLOEXEC` / Windows `HANDLE_FLAG_INHERIT` off.
- **감사/추적**: 누가 가진 권한인지 **중앙 인벤토리**(cap-table/role 예산).
- **즉시 중단** 필요 시: 세션/프로세스 **kill**, 소켓 **RST**, 토큰 **deny-list**.
- **철회 지연 허용** 시: TTL/리스/키 회전으로 **운영비용** 최소화.

---

## 17.8 Role-Based Access Control (RBAC)

### 17.8.1 핵심 용어
- **사용자(User)**, **역할(Role)**, **권한(Permission)**, **세션(Session)**.
- 사용자는 0..N **역할을 보유**, 세션에서 **일부 역할을 활성화**한다(Least Privilege).

### 17.8.2 NIST RBAC 패밀리
- **RBAC0**: 사용자–역할–권한의 기본 매핑.
- **RBAC1**: **역할 계층**(상속).
- **RBAC2**: **제약(Constraints)** — 정적/동적 **분리의 원칙(SoD)**, 카디널리티 등.
- **RBAC3**: RBAC1 + RBAC2.

$$
\text{can}(u, p) \iff \exists r\in \text{activeRoles}(u):\ p\in \text{perm}(r) \lor \exists r'\le r: p\in \text{perm}(r')
$$

---

### 17.8.3 미니 RBAC 엔진 (계층·제약·세션)

```python
# rbac.py — RBAC0/1/2 핵심만 구현
from collections import defaultdict

class RBAC:
    def __init__(self):
        self.user_roles   = defaultdict(set)   # U -> {R}
        self.role_perms   = defaultdict(set)   # R -> {P}
        self.role_parents = defaultdict(set)   # R -> {R parent}
        # 제약
        self.s_sod = set()     # (R1,R2) 정적 SoD: 동시에 보유 불가
        self.d_sod = set()     # (R1,R2) 동적 SoD: 같은 세션에서 활성 불가
        self.card  = {}        # R -> max users

    def assign(self, u, r):
        # 정적 SoD
        for r2 in self.user_roles[u]:
            if (r,r2) in self.s_sod or (r2,r) in self.s_sod:
                raise PermissionError("static SoD violation")
        # 카디널리티
        if r in self.card:
            n = sum(1 for uu in self.user_roles if r in self.user_roles[uu])
            if n >= self.card[r]: raise PermissionError("cardinality exceeded")
        self.user_roles[u].add(r)

    def add_perm(self, r, p): self.role_perms[r].add(p)
    def add_inherit(self, child, parent): self.role_parents[child].add(parent)
    def add_static_sod(self, r1, r2): self.s_sod.add((r1,r2))
    def add_dynamic_sod(self, r1, r2): self.d_sod.add((r1,r2))
    def set_cardinality(self, r, k): self.card[r]=k

    def _closure_perms(self, r, vis=None):
        vis=vis or set();
        if r in vis: return set()
        vis.add(r)
        p=set(self.role_perms[r])
        for par in self.role_parents[r]:
            p |= self._closure_perms(par, vis)
        return p

    def new_session(self, u, activate):
        # 세션 활성화 집합 유효성
        act=set(activate)
        if not act <= self.user_roles[u]: raise PermissionError("role not assigned")
        for a in act:
            for b in act:
                if a==b: continue
                if (a,b) in self.d_sod or (b,a) in self.d_sod:
                    raise PermissionError("dynamic SoD violation")
        return act

    def can(self, session_roles, perm):
        perms=set()
        for r in session_roles:
            perms |= self._closure_perms(r)
        return perm in perms

# 예시 정책
rb=RBAC()
rb.add_perm("Engineer","read:/src"); rb.add_perm("Lead","merge:/src")
rb.add_inherit("Lead","Engineer")  # Lead ≥ Engineer
rb.add_perm("Auditor","read:/audit"); rb.add_dynamic_sod("Engineer","Auditor")
rb.assign("alice","Engineer"); rb.assign("bob","Lead"); rb.assign("charlie","Auditor")

sess = rb.new_session("bob", {"Engineer","Lead"})
assert rb.can(sess,"merge:/src") and rb.can(sess,"read:/src")
try:
    rb.new_session("alice", {"Engineer","Auditor"})  # 동적 SoD 위반
except PermissionError: pass
```

**포인트**
- **역할 계층**은 상속(부분순서)로 구현.
- **SoD**: 정적(소유 자체 금지)과 동적(세션 활성화 금지) 모두 지원.
- **카디널리티**: 특정 역할 사용자 수 제한(예: “ReleaseApprover=2명”).

---

### 17.8.4 OS/플랫폼 매핑 예

- **Linux/Unix**: “역할≈그룹”으로 근사. `gpasswd`, `newgrp`, `sudoers`(명령 단위 RBAC). SELinux **type/role**로 엄격한 RBAC(+MAC).
- **Windows**: **권한/그룹**(Local/Domain) + **UAC** + **Restricted Token**.
- **Kubernetes**: `Role/ClusterRole` + `RoleBinding/ClusterRoleBinding`. (정교한 **리소스·동사** 조합)

```yaml
# k8s-rbac.yaml — 네임스페이스 내 읽기 전용 role
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata: { name: reader, namespace: app }
rules:
- apiGroups: [""]   # core
  resources: ["pods","configmaps"]
  verbs: ["get","list","watch"]
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata: { name: bind-alice, namespace: app }
subjects: [{ kind: User, name: alice }]
roleRef: { kind: Role, name: reader, apiGroup: rbac.authorization.k8s.io }
```

---

### 17.8.5 RBAC 운영 팁
- **권한=권한**(Permission) 목록을 **작게** 정의하고, 역할은 **조합**으로 만든다.
- **승인 흐름**: 역할 부여/철회는 **티켓/감사**와 묶는다.
- **임시 역할**: 세션 만료/승인 시간대만 활성(“Just-In-Time” RBAC).
- **SoD**는 **업무 분리**를 반영(예: 청구 입력 vs 승인).

---

## 17.9 Mandatory Access Control (MAC)

### 17.9.1 DAC vs MAC
- **DAC(자율)**: 객체 소유자가 접근을 결정(Unix 권한/ACL). 유연하나 **권한 전이**로 누수 위험.
- **MAC(강제)**: **중앙 정책**(라벨/규칙)이 **무조건 강제**. 소유자도 예외 없다. **군/정부, 멀티테넌시, 컨테이너 격리** 등에서 중요.

### 17.9.2 격자(lattice)와 정보 흐름 모델
보안 레벨(예: **U < C < S < TS**)과 카테고리(부서/프로젝트)를 갖는 라벨 \(L=(\text{level},\ \text{cats})\) 에 대해 **부분순서** \(\preceq\) 를 정의한다.

- **Bell–LaPadula(기밀성)**
  $$\text{no read up},\quad \text{no write down}$$
  읽기: \(L_u \succeq L_o\), 쓰기: \(L_u \preceq L_o\).

- **Biba(무결성)**
  $$\text{no read down},\quad \text{no write up}$$

라벨 비교의 핵심:
$$
(l_1, C_1) \preceq (l_2, C_2) \iff l_1 \le l_2 \land C_1 \subseteq C_2
$$

---

### 17.9.3 미니 라벨 검사기 (BLP/Biba)

```python
# lattice_mac.py — 라벨 기반 접근 결정(카테고리 지원)
from dataclasses import dataclass
@dataclass(frozen=True)
class Label:
    level: int          # 0=U,1=C,2=S,3=TS
    cats:  frozenset    # {"FIN","R&D"}

def leq(a:Label, b:Label):  # a ⪯ b ?
    return a.level <= b.level and a.cats.issubset(b.cats)

def blp_can_read(user:Label, obj:Label):  # no read up
    return leq(obj, user)

def blp_can_write(user:Label, obj:Label): # no write down
    return leq(user, obj)

def biba_can_read(user:Label, obj:Label): # no read down
    return leq(user, obj)

def biba_can_write(user:Label, obj:Label):# no write up
    return leq(obj, user)

TS = Label(3, frozenset({"R&D"}))
S  = Label(2, frozenset({"R&D"}))
C  = Label(1, frozenset({"R&D"}))
U  = Label(0, frozenset())

assert blp_can_read(TS, S) and not blp_can_read(S, TS)
assert blp_can_write(S, TS) and not blp_can_write(TS, S)
```

**해석**
- BLP: 높은 사용자는 낮은 라벨을 **읽을 수 없다**(기밀성 보호).
- Biba: 높은 무결성 객체를 낮은 주체가 **쓸 수 없다**(무결성 보호).

---

### 17.9.4 SELinux/TE(Type Enforcement) 개념 스냅샷
- **주체(도메인) 타입**: `httpd_t`, `sshd_t` …
- **객체 타입**: `httpd_sys_content_t`, `var_log_t` …
- **정책**: `allow httpd_t httpd_sys_content_t:file { read open getattr };`
- **역할/유저**(RBAC)와 결합 가능. `type_transition` 으로 **도메인 전이** 자동화.

```text
# (개념) httpd는 웹 컨텐츠만 읽고, /var/log는 append만 허용
allow httpd_t httpd_sys_content_t:file { open read getattr };
allow httpd_t var_log_t:file { open append getattr };
```

**운영 명령(예시)**
- 라벨 보기: `ls -Z`, 컨텍스트 부여: `semanage fcontext -a -t httpd_sys_content_t '/srv/www(/.*)?' ; restorecon -Rv /srv/www`
- 모드: `setenforce 1`(Enforcing) / `0`(Permissive).

---

### 17.9.5 AppArmor(프로필 기반 MAC) 예시
경로/권한 기반 **프로필**로 프로그램의 파일/네트워크/능력을 제한.

```text
# /etc/apparmor.d/usr.bin.myapp (개념)
#include <tunables/global>
profile /usr/bin/myapp {
  #include <abstractions/base>
  capability net_bind_service,
  /usr/bin/myapp mr,
  /etc/myapp/** r,
  /var/log/myapp/** rwk,
  deny network raw,
}
```

적용:
```bash
apparmor_parser -r /etc/apparmor.d/usr.bin.myapp
aa-status
```

---

### 17.9.6 Windows MIC(무결성 레벨)·WDAC 요약
- **Integrity Level**: Low/Medium/High/System. Low 프로세스는 Medium 파일에 쓰기 불가.
- **ICACLS로 레벨 설정**: 파일/폴더에 `(OI)(CI)ML/HL` 지정.
- **WDAC/AppLocker**: **서명/정책 기반** 실행 허용 목록(코드 무결성).

```powershell
# 특정 폴더를 Low만 쓰기 금지(기본 Medium에서 상향)
icacls "C:\Sensitive" /setintegritylevel (OI)(CI)H
```

---

### 17.9.7 DAC·RBAC·MAC의 결합
현대 OS/플랫폼은 세 체계를 **중첩**한다.

- **DAC**: 일상 파일/프로세스 권한(소유자/그룹/ACL).
- **RBAC**: 역할/업무 기반 권한 묶음(승인/감사/세션 활성).
- **MAC**: 라벨·정책으로 **최종 방어선**(우연한 과권한/오류에도 차단).

> 예) Kubernetes: **RBAC**로 API 권한, **PodSecurity/SELinux(sVirt)** 로 **MAC 격리**, 컨테이너 내부는 **DAC**.

---

### 17.9.8 정보 흐름에서의 **해제/승격**
- **Declassification(기밀 해제)**: 정책적으로 정보 수준을 낮춤(감사 필수).
- **Endorsement(무결성 승격)**: 신뢰 절차를 거쳐 낮은 무결성 데이터를 승격.

이행은 **정해진 게이트웨이**에서만, 로그/서명/이중 승인(SoD) 요구.

---

## 종합 시나리오 — “감사 로그 보호”

**요구**
- `app_t`(웹앱)는 `/srv/www` 읽기만, `/var/log/app.log` 는 **append만**.
- **RBAC**: `Operator` 는 로그 **조회**, `Auditor` 는 **조회+보관**.
- **철회**: 사고 시, 기존 세션/핸들도 즉시 무효화.

**구성**
1) **MAC(SELinux/TE)**:
   - `app_t` → `httpd_sys_content_t` 읽기, `var_log_t` append.
2) **RBAC**:
   - `Operator` → `read:/var/log/app.log`
   - `Auditor`  → `read,archive:/var/log/app.log`
   - `Operator` ↔ `Auditor` 는 **동적 SoD**(같은 세션 불가).
3) **철회**:
   - 로그 파일을 **버전 프록시**(`log_v1`) 로 접근. 사고 시 `log_v2` 로 **스위치**(버전↑).
   - 구 버전 핸들은 **무효**(간접화/버전 패턴).

```python
# demo_audit_protect.py — RBAC + 간접화 기반 즉시 철회
from rbac import RBAC
from cap_revoke import CapTable

# RBAC
rb=RBAC()
rb.add_perm("Operator", "read:/log")
rb.add_perm("Auditor",  "read:/log"); rb.add_perm("Auditor","archive:/log")
rb.add_dynamic_sod("Operator","Auditor")
rb.assign("alice","Operator"); rb.assign("bob","Auditor")

sessA = rb.new_session("alice", {"Operator"})
assert rb.can(sessA,"read:/log") and not rb.can(sessA,"archive:/log")

# 간접화 로그
ct = CapTable()
oid = ct.create(b"logs-v1")
cap_read = ct.issue(oid, ["read"])
print(ct.read(cap_read)[:5])

# 사고 발생 → 버전 상승(즉시 폐쇄)
ct.revoke_all_for_object(oid)
try: ct.read(cap_read)
except PermissionError: print("revoked OK")
```

---

## 마무리 요약

- **17.7 철회**: 열린 핸들 문제를 인정하고 **간접화/버전**, **키 회전**, **리스/콜백**으로 해결하라. 토큰/세션은 **deny-list + 짧은 TTL**을 병행.
- **17.8 RBAC**: 역할/계층/제약/세션 활성 개념을 구현하면 **Least Privilege**가 실무에서 관리가능해진다. K8s/DB/OS에 쉽게 매핑 가능.
- **17.9 MAC**: DAC/RBAC 위에 **라벨·정책의 강제**를 덧씌워 **실수/오류**까지 막는다. BLP/Biba 격자 개념을 이해하고, SELinux/AppArmor/MIC로 실제 운영에 접목하라.
