---
layout: post
title: 소켓프로그래밍 - 성능 최적화
date: 2025-09-25 20:25:23 +0900
category: 소켓프로그래밍
---
## 16. 성능 최적화 카탈로그

> 목표: 작은 메시지(레이턴시)부터 큰 전송(처리량)까지 **TCP 스트림 위 최적화 포인트**를 체계적으로 정리한다.  
> 핵심 주제: **coalescing vs `TCP_NODELAY`**, **zero-copy 경로(`sendfile`, `writev/sendmsg`)**, **PMTUD/MSS/MTU** 실제 튜닝,  
> 그리고 **실습: 파일 송신기**로 `sendfile`과 `read+write` 경로를 비교(시간/MB/s/시스템콜 카운트 느낌)한다.  
> 기준: 리눅스 + C++23, 단일 프로세스/단일 스레드 예제를 기본으로 한다.

---

### 16.1 큰 그림 — 레이턴시/처리량, “작은 N vs 큰 N”

- **작은 메시지(수십~수백 바이트)**: 왕복지연(RTT) 지배.  
  최적화의 축은 **패킷화 정책**(Nagle, Cork), **앱 레벨 합치기(coalescing)**, **ACK 상호작용**.
- **큰 전송(수십 KB~GB)**: 대역폭 지배.  
  최적화의 축은 **데이터 복사 감소**(zero-copy), **시스템콜 amortization**(대용량 write, `writev`), **PMTUD/MSS** 정합.

레이턴시 근사(작은 페이로드, 1RTT 왕복형):
$$
\text{Latency} \approx \text{RTT} + \text{Queueing} + \text{Syscall/Copy Overheads}
$$

처리량 근사(대용량 연속 송신):
$$
\text{Throughput} \approx \frac{\text{Bytes}}{\text{RTT}\cdot(\text{윈도/혼잡})^{-1} + \text{Copy/Kernel Overheads}}
$$

---

## 16.2 작은 메시지 최적화: Coalescing vs `TCP_NODELAY`

### 16.2.1 Nagle의 알고리즘 & Delayed ACK 상호작용

- **Nagle**(기본 활성): **소량 write**를 **송신버퍼에서 모아** 한 세그먼트(MSS)에 가깝게 묶어서 보냄.  
  → **처리량↑, CPU↓** 그러나 **지연↑**(특히 “요청 한 줄 → 즉시 flush” 패턴에서).
- **Delayed ACK**(상대방): 수신측이 **ACK를 수 ms 지연**하여 **ACK 폭주**를 줄임.  
  **Nagle + Delayed ACK**가 **동시에** 작동하면, “작은 write 후 즉시 작은 write”가 **数ms 정지**되는 병목이 생길 수 있다.

### 16.2.2 선택지 3가지

1) **`TCP_NODELAY`(Nagle off)**  
   - 작은 write가 **즉시 세그먼트**로 나간다(커널 혼잡창/큐 여건 허용 시).  
   - **왕복형 인터랙션**(RPC ping, 게임 입력 등)에서 레이턴시 개선.  
   - **단점**: 매우 작은 write를 **남발**하면 **패킷/인터럽트 폭증**(처리량/CPU에 악영향).

2) **앱-레벨 coalescing**  
   - 사용자 공간에서 **헤더+바디** 또는 **여러 메시지**를 **한 번에 write**.  
   - **`writev`/`sendmsg`**로 **벡터화**하면 **복사 없이** 묶을 수 있다(헤더/바디 각각의 포인터를 그대로).

3) **`TCP_CORK`(리눅스)**  
   - 커널이 **최대한 묶어서** 보내게 강제.  
   - 헤더와 파일을 **연이어** 보낼 때 유리(아래 `sendfile`과 조합).  
   - 마무리 시점에 **명시적으로 uncork** 해야 즉시 송신.

> **실무 규칙**  
> - **상호작용/소량**: `TCP_NODELAY` 켠다 **(+ 앱에서 적당히 합치기)**  
> - **헤더+대용량 전송**: `TCP_CORK`로 **헤더→바디**를 **1~소수 패킷**으로 배치  
> - **무조건 NODELAY**가 정답은 아니다. **작은 write 남발**은 CPU/네트워크를 낭비한다.

### 16.2.3 미니 예제: `TCP_NODELAY` vs 합치기

```cpp
// tiny_send.cpp : 작은 메시지 전송 패턴 실험(개념)
// 빌드: g++ -std=c++23 -O2 tiny_send.cpp -o tiny_send
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <netinet/tcp.h>
#include <print>
#include <vector>
#include <string>

static int dial(const char* host, const char* port){
    addrinfo hints{},*res=nullptr; hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(host,port,&hints,&res)!=0) return -1;
    int s=-1; for (auto* ai=res; ai; ai=ai->ai_next){
        s=::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol); if (s<0) continue;
        if (::connect(s, ai->ai_addr, ai->ai_addrlen)==0) break; ::close(s); s=-1;
    } freeaddrinfo(res); return s;
}

int main(int argc, char** argv){
    if (argc<5){ std::print(stderr,"usage: {} <host> <port> <count> <mode:nodeley|coalesce>\n",argv[0]); return 1; }
    int s = dial(argv[1], argv[2]); if (s<0){ perror("connect"); return 1; }

    std::string mode = argv[4];
    if (mode=="nodelay"){
        int on=1; ::setsockopt(s, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on));
    }

    int count = std::stoi(argv[3]);
    std::string msg = "ping\n"; // 5B

    if (mode=="coalesce"){
        std::string big; big.reserve(count * msg.size());
        for (int i=0;i<count;i++) big += msg;
        ::send(s, big.data(), big.size(), 0);
    } else {
        for (int i=0;i<count;i++) ::send(s, msg.data(), msg.size(), 0);
    }
    ::close(s);
}
```

- **실험**: 수신측을 `nc -l 9000 > /dev/null` 로 두고  
  `./tiny_send 127.0.0.1 9000 10000 nodelay` vs `... coalesce` 로 **패킷 수**/CPU 변화를 체감.  
- **관찰 포인트**: `tcpdump`로 **세그먼트 수** 비교, `perf top`/CPU 시간, 서버 `Recv-Q` 패턴.

---

## 16.3 Zero-copy 경로: `writev/sendmsg`, `sendfile` (+ 보너스)

### 16.3.1 `writev/sendmsg` — **벡터화 전송** (헤더+바디 합치기)

- **장점**: 여러 버퍼를 **한 syscal**로 전송 → **syscall 오버헤드 감소**, **불필요한 memcpy 없음**.  
- **용례**: 응답 헤더(소량 문자열) + 바디(메모리) / 여러 작은 메시지 묶기.

```cpp
// writev_sample.cpp (요지)
// iovec 배열에 헤더/바디/트레일러를 넣고 한 번에 송신
#include <sys/uio.h>
#include <string>
#include <vector>
#include <unistd.h>

ssize_t send_header_body(int fd, std::string_view hdr, std::span<const std::byte> body){
    iovec v[2];
    v[0].iov_base = (void*)hdr.data(); v[0].iov_len = hdr.size();
    v[1].iov_base = (void*)body.data(); v[1].iov_len = body.size();
    return ::writev(fd, v, 2);
}
```

> **주의**: TCP는 스트림 → `writev`가 **하나의 패킷**을 보장하지 않는다.  
> 단, **`TCP_CORK`**를 함께 쓰면 커널이 **최대한 묶어서** 내보내도록 유도 가능.

### 16.3.2 `sendfile` — **디스크→소켓 “사용자 공간 복사” 제거**

- **경로**: 디스크 페이지 캐시 ↔(커널)↔ NIC → **유저 공간 데이터 복사 없음**.  
- **장점**: **CPU 캐시 오염/복사 비용** 감소, `read+write`보다 **syscall 수 절감** 가능.  
- **전제**: 파일이 페이지 캐시에 적중하거나 적절히 리드어헤드가 되어야 이득이 크다.

```cpp
// sendfile_sample.cpp (요지, Linux)
// 빌드: g++ -std=c++23 -O2 sendfile_sample.cpp -o sfs
#include <sys/sendfile.h>
#include <unistd.h>
#include <fcntl.h>
#include <cstdio>

ssize_t send_file(int out_fd, int in_fd, off_t* offset, size_t count){
    size_t sent=0;
    while (sent < count){
        ssize_t n = ::sendfile(out_fd, in_fd, offset, count - sent);
        if (n > 0) { sent += (size_t)n; continue; }
        if (n == 0) break; // EOF
        if (errno==EINTR) continue;
        if (errno==EAGAIN) { /* 비차단이면 폴링 후 계속 */ continue; }
        return -1;
    }
    return (ssize_t)sent;
}
```

- **헤더 + 파일**: 일반적으로  
  1) `TCP_CORK` **ON**,  
  2) `write`로 **헤더**를 보내고,  
  3) **`sendfile`로 파일 본문**,  
  4) `TCP_CORK` **OFF** 로 즉시 flush.  
  (CORK가 없다면 헤더 후 작은 패킷이 먼저 나갈 수 있음 → 세그먼트 증가)

### 16.3.3 (참고) `splice/tee` & `MSG_ZEROCOPY`

- **`splice`**: 커널 파이프를 이용하여 **파일↔파이프↔소켓** 경로를 연결(특정 시나리오에서 유용).  
- **`MSG_ZEROCOPY`**(리눅스 4.14+): **유저 공간 버퍼 → NIC**로 **페이지 맵핑**하여 **복사 없이** 송신(완전 zero-copy).  
  - `setsockopt(SOL_SOCKET, SO_ZEROCOPY)` 후 `send(..., MSG_ZEROCOPY)`  
  - **완료 알림**은 **`error queue`**로 별도 수신 필요.  
  - 큰 버퍼 송신에서만 유의미, 코드 복잡도 증가(운영단계 최적화).

---

## 16.4 PMTUD/MSS, MTU 이슈와 실제 튜닝

### 16.4.1 용어 정리

- **MTU**(Maximum Transmission Unit): 링크 계층 프레임에 실릴 수 있는 **최대 페이로드** 크기(이더넷 보통 1500B).  
- **MSS**(Maximum Segment Size): TCP 세그먼트에서 **IP/TCP 헤더 제외한** **데이터** 최대 크기.
  - IPv4 일반:  
    $$
    \text{MSS}_{v4} \approx 1500 - 20(\text{IPv4}) - 20(\text{TCP}) = 1460
    $$
  - IPv6 일반:  
    $$
    \text{MSS}_{v6} \approx 1500 - 40(\text{IPv6}) - 20(\text{TCP}) = 1440
    $$

- **PMTUD**(Path MTU Discovery): DF(Do-Not-Fragment) 비트 기반으로 **경로상의 최소 MTU**를 탐색. ICMP “Fragmentation needed”로 조정.  
  - **블랙홀**(ICMP 차단) 환경에서 문제 → 연결 성능 급락/타임아웃.

### 16.4.2 실제 튜닝 포인트

- **증상**: 특정 경로에서 대용량 송신 시 **멈춤/재전송↑/타임아웃** → PMTUD/MTU 의심.  
- **확인**:  
  - `ping -M do -s <size> <host>` (IPv4) 로 **경로 MTU** 탐색(권한 필요).  
  - 연결 중 **MSS 확인**: `getsockopt(TCP_MAXSEG)` 또는 `TCP_INFO`에서 `tcpi_snd_mss` 확인.
- **대응**:
  - **네트워크 장비**에서 **ICMP 필요 메시지 허용**(보안팀 협의).  
  - **VPN/터널** 사용 시 **MSS 클램핑**(방화벽에서 TCP 옵션 변경)으로 작은 MSS 강제(예: 1360).  
  - 애플리케이션 측에서 **레코드/프레임 사이즈**를 **MSS 배수**에 맞추면 효율↑(특히 TLS 레코드).

### 16.4.3 코드: 현재 MSS/RTT를 읽어보기

```cpp
// tcp_info_dump.cpp : 현재 소켓의 TCP_INFO/MSS 출력
#include <netinet/tcp.h>
#include <sys/socket.h>
#include <unistd.h>
#include <print>

void dump_tcpinfo(int fd){
    tcp_info ti{}; socklen_t len=sizeof(ti);
    if (getsockopt(fd, IPPROTO_TCP, TCP_INFO, &ti, &len)==0){
        std::print("rtt={}us, rcv_mss={}, snd_mss={}, snd_cwnd={}\n",
            ti.tcpi_rtt, ti.tcpi_rcv_mss, ti.tcpi_snd_mss, ti.tcpi_snd_cwnd);
    }
    int mss=0; len=sizeof(mss);
    if (getsockopt(fd, IPPROTO_TCP, TCP_MAXSEG, &mss, &len)==0){
        std::print("TCP_MAXSEG={}\n", mss);
    }
}
```

---

## 16.5 실습: **파일 송신기** — `sendfile` vs `read+write` 비교

> 목표: 같은 파일을 같은 소켓으로 보내되,  
> (A) **`sendfile` 경로**와 (B) **사용자 공간 버퍼 `read+write` 루프**를 비교한다.  
> 지표: **경과 시간**, **MB/s**, (옵션) **`TCP_CORK` 효과**.

### 16.5.1 준비

- 수신측(간단):  
  - **옵션1**: `nc -l 9000 > /dev/null` (로컬 discard)  
  - **옵션2**: `nc -l 9000 > /tmp/recv.bin` (검증용)  
- 송신 파일: `/path/to/bigfile` 를 몇백 MB 이상 준비(페이지 캐시 효과를 관찰하려면 두 번 돌려보자).

### 16.5.2 송신기 코드 (C++23, Linux)

```cpp
// file_sender.cpp — sendfile vs read+write 루프 비교
// 빌드: g++ -std=c++23 -O2 file_sender.cpp -o fsender
//
// 사용:
//   ./fsender <host> <port> <file> <mode> [block_kb] [cork=0|1]
//     mode: sendfile | write
//   예) ./fsender 127.0.0.1 9000 /tmp/big.bin sendfile 256 1
//
// 주: 리눅스 전용(sendfile). macOS/BSD는 sendfile 시그니처/헤더가 다름.

#include <arpa/inet.h>
#include <fcntl.h>
#include <netdb.h>
#include <netinet/tcp.h>
#include <sys/sendfile.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <unistd.h>

#include <chrono>
#include <cstring>
#include <expected>
#include <iostream>
#include <print>
#include <string>
#include <string_view>
#include <vector>

using clock = std::chrono::steady_clock;

static int dial(const char* host, const char* port) {
    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(host, port, &hints, &res)!=0) return -1;
    int s=-1;
    for (auto* ai=res; ai; ai=ai->ai_next){
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        if (::connect(s, ai->ai_addr, ai->ai_addrlen)==0) { freeaddrinfo(res); return s; }
        ::close(s); s=-1;
    }
    freeaddrinfo(res); return -1;
}

static off_t file_size(int fd){
    struct stat st{}; if (fstat(fd, &st)!=0) return -1; return st.st_size;
}

static std::expected<void, std::error_code> set_cork(int fd, bool on){
#ifdef TCP_CORK
    int v = on?1:0;
    if (::setsockopt(fd, IPPROTO_TCP, TCP_CORK, &v, sizeof(v))!=0)
        return std::unexpected(std::error_code(errno, std::generic_category()));
#else
    (void)fd; (void)on;
#endif
    return {};
}

int main(int argc, char** argv){
    if (argc < 5){
        std::print(stderr, "usage: {} <host> <port> <file> <sendfile|write> [block_kb] [cork=0|1]\n", argv[0]);
        return 1;
    }
    const char* host=argv[1]; const char* port=argv[2]; const char* path=argv[3];
    std::string mode=argv[4];
    size_t blk = (argc>5 ? (size_t)std::stoul(argv[5]) : 256) * 1024;
    bool cork = (argc>6 ? std::stoi(argv[6])!=0 : false);

    int fd = ::open(path, O_RDONLY);
    if (fd<0){ perror("open"); return 1; }
    off_t sz = file_size(fd);
    if (sz<0){ perror("stat"); ::close(fd); return 1; }

    int s = dial(host, port);
    if (s<0){ perror("connect"); ::close(fd); return 1; }

    if (cork) { auto rc=set_cork(s,true); (void)rc; }

    // (선택) 헤더를 먼저 보낸다 — writev로 "파일명/크기" 메타를 동봉(실험용)
    std::string hdr = std::string("X-File-Name: ") + path + "\r\nX-File-Size: " + std::to_string(sz) + "\r\n\r\n";
    iovec v{.iov_base=(void*)hdr.data(), .iov_len=hdr.size()};
    ::writev(s, &v, 1);

    auto t0 = clock::now();
    size_t total=0;

    if (mode=="sendfile"){
        off_t off=0;
        while (off < sz){
            // 한번에 너무 크게 주면 EAGAIN/혼잡 → 커널이 알아서 쪼갠다.
            ssize_t n = ::sendfile(s, fd, &off, (size_t)(sz - off));
            if (n > 0){ total += (size_t)n; continue; }
            if (n == 0) break;
            if (errno==EINTR) continue;
            if (errno==EAGAIN) { /* 수신측가 느리면 잠깐 쉼 */ continue; }
            perror("sendfile"); break;
        }
    } else {
        std::vector<char> buf(blk);
        while (true){
            ssize_t n = ::read(fd, buf.data(), buf.size());
            if (n > 0){
                size_t off=0;
                while (off < (size_t)n){
                    ssize_t m = ::send(s, buf.data()+off, (size_t)n - off, 0);
                    if (m > 0){ off += (size_t)m; total += (size_t)m; continue; }
                    if (m == 0) continue;
                    if (errno==EINTR) continue;
                    if (errno==EAGAIN) { /* 논블로킹이면 poll */ continue; }
                    perror("send"); goto done;
                }
                continue;
            }
            if (n==0) break; // EOF
            if (errno==EINTR) continue;
            perror("read"); break;
        }
    }

done:
    if (cork) { auto rc=set_cork(s,false); (void)rc; } // flush
    ::shutdown(s, SHUT_WR);
    // (선택) 상대가 모두 읽고 닫을 시간을 약간 준다(테스트 편의)
    ::close(s); ::close(fd);

    auto t1 = clock::now();
    double sec = std::chrono::duration<double>(t1-t0).count();
    double mb  = (double)total / (1024.0*1024.0);
    std::print("[mode={}] sent {:.2f} MB in {:.3f} s  =>  {:.2f} MB/s (blk={} KB, cork={})\n",
               mode, mb, sec, mb/sec, blk/1024, cork?1:0);
    return 0;
}
```

#### 16.5.3 실행 & 관찰

1) 수신:
```bash
nc -l 9000 > /dev/null
```

2) 송신(동일 파일):
```bash
./fsender 127.0.0.1 9000 /tmp/big.bin sendfile 256 1
./fsender 127.0.0.1 9000 /tmp/big.bin write    256 1
```

3) 관찰 포인트
- **MB/s**: `sendfile`이 보통 **동일 또는 우수**(특히 큰 파일, 캐시 적중).  
- **CPU 사용률**: `top`/`pidstat`/`perf`로 확인 → `sendfile` 경로는 **유저 공간 memcpy**가 사라져 CPU↓.  
- **패킷 수**: `tcpdump -i lo -n tcp port 9000` 로 세그먼트 갯수 비교(블록 크기/코르크의 영향).  
- **`TCP_CORK`**: 헤더와 바디가 **보다 큰 세그먼트**로 묶여 나가 **패킷 수↓**.

> **반례**: 파일이 **페이지 캐시에 전혀 없고**, 디스크 IO가 병목이면 `sendfile` 이득이 작다.  
> 카디널한 이득은 **유저 복사 제거** + **syscall 수 감소**에서 온다.

---

## 16.6 자주 묻는 질문(FAQ) & 체크리스트

### 16.6.1 `TCP_NODELAY`를 항상 켜도 되나?
- **아니오**. 왕복 지연이 중요한 **인터랙티브** 트래픽에는 좋지만,  
  **작은 write 폭주**를 낳아 **IRQ/패킷 수/CPU 비용**이 증가할 수 있다.  
  → **coalescing(앱/`writev`)**와 **적절한 flush 지점**을 먼저 고민.

### 16.6.2 `TCP_CORK` vs `TCP_NODELAY`
- **CORK**: “**묶어 보내기**” 강제, 해제 시점까지 큐잉. 헤더+큰 바디에 적합.  
- **NODELAY**: “**바로 보내기**”. 작은 write에 유리.  
- **둘 다** 켜면? CORK가 **우선**(리눅스). → 보통 **둘 중 하나**만 상황에 맞춰 사용.

### 16.6.3 `writev`와 `sendmsg` 차이
- `sendmsg`는 **제어 메시지(cmsg)**(예: **FD 전송**, **UDP GSO**, **IP_PKTINFO** 등)까지 포함 가능.  
- TCP 응답 헤더+바디 합치기엔 **둘 다** 충분. TCP에서는 **패킷 경계 보장은 없음**.

### 16.6.4 TLS를 쓰면 MSS/PMTUD는?
- **MSS**는 **TCP/IP 헤더 기준**이므로 **TLS 레코드**는 그 위의 **애플리케이션 데이터**.  
- TLS 레코드 크기를 **MSS 배수**에 가까이 맞추면 세그먼트 분할/패딩 낭비가 줄 수 있다(과도하게 신경쓸 필요는 없음).  
- PMTUD 블랙홀 시 TLS라도 **세그먼트 재전송/타임아웃** 증상은 동일.

### 16.6.5 체크리스트

- [ ] 작은 write 다발? → **앱 합치기** 또는 `writev`  
- [ ] 왕복 지연 민감? → `TCP_NODELAY` 고려  
- [ ] 헤더+파일 전송? → `TCP_CORK` + `sendfile`  
- [ ] 대용량 스트리밍? → **`sendfile` 우선**, 또는 `MSG_ZEROCOPY`(고급)  
- [ ] PMTUD 이슈 의심? → `ping -M do`, **ICMP 허용**, **MSS 클램핑** 검토  
- [ ] 측정 기반 조정: MB/s, p95 지연, 패킷 수, CPU 프로파일(`perf`)

---

## 16.7 보너스 팁 — 운영에서의 미세 조정

- **SNDBUF/RCVBUF**: **너무 작으면** 스톨, **너무 크면** 지연/메모리 증가. RTT×Bandwidth(BDP) 감으로 조정.  
- **TSO/GSO/GRO**: NIC/커널이 **큰 세그먼트**를 적절히 쪼개거나 합침. 애플리케이션이 **MSS/세그먼트 경계**를 지나치게 의식할 필요가 줄어듦.  
- **Preload**: 큰 파일은 **`posix_fadvise(fd,0,0,POSIX_FADV_WILLNEED)`**로 리드어헤드 힌트.  
- **NUMA/IRQ affinity**: 11장에서 논한 **코어/큐 바인딩**으로 **캐시 로컬리티** 유지.  
- **관측**: `TCP_INFO`로 **RTT/재전송/拥塞창**을 지표화 → 조치 전/후 비교.

---

### 16.8 정리

- 작은 메시지: **지연**이 전부 → **`TCP_NODELAY`**(선택) + **앱 합치기**(우선) + **`writev`**.  
- 큰 전송: **복사/시스템콜**이 전부 → **`sendfile`**(또는 `MSG_ZEROCOPY`) + **CORK**로 세그먼트 효율.  
- 경로 이슈: **PMTUD/MSS/MTU**를 이해하고 **ICMP/클램핑**/레코드 크기 등 **실용 포인트**를 집는다.  
- **측정-조정-재측정**이 성능 최적화의 전부다. 도구(`tcpdump`, `ss`, `perf`, `TCP_INFO`)로 **수치로 말하자**.
