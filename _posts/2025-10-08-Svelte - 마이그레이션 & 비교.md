---
layout: post
title: Svelte - 마이그레이션 & 비교
date: 2025-10-08 18:30:23 +0900
category: Svelte
---
# 마이그레이션 & 비교 — **React/Vue → Svelte 사고 전환 · Svelte 4 → 5 체크리스트 · 프레임워크 비교 요약**

> 이 장은 **실전 마이그레이션 관점**에서 정리한다.
> 1) **React/Vue에서 넘어올 때** 바꿔야 하는 사고/패턴을 “대응표 + 리팩터링 예제”로 제시
> 2) **Svelte 4 → 5 마이그레이션**에 필요한 체크리스트(룬즈 Runes 중심)
> 3) **프레임워크 비교 표**(사용성·성능·생태계)와 팀 도입 의사결정 팁

---

## React/Vue → Svelte: **사고 전환 포인트**

### “상태 = UI” 연결 방식의 차이

- **React**: setState/useState → _diff 기반 가상 DOM 재조합_
- **Vue**: ref/reactive/computed → _Proxy 트래킹_ + 가상 DOM
- **Svelte**: **컴파일 타임**에 반응 경로를 만들어 DOM을 직접 패치
  → “**할당이 곧 업데이트**” / `$:` **반응 구문** / 스토어 `$store` 자동 구독

#### 카운터: React → Svelte

```jsx
// React
import { useState } from 'react';
export default function Counter() {
  const [n, setN] = useState(0);
  return (
    <button onClick={() => setN(n + 1)}>
      {n}
    </button>
  );
}
```

```svelte
<!-- Svelte -->
<script>
  let n = 0;            // 값 변경만 하면 렌더가 갱신된다 (할당 기반)
</script>

<button on:click={() => n = n + 1}>
  {n}
</button>
```

포인트:
- setState/`ref.value` 같은 **setter 호출 불필요**
- **지역 변수에 할당**만 해도 템플릿이 갱신

---

### 파생 상태(derived/computed)의 차이

- **React**: `useMemo`로 메모이즈 (의존성 배열)
- **Vue**: `computed` (getter 기반)
- **Svelte**: `$:` **반응 구문**(Svelte 4) 또는 **Runes**(Svelte 5)에서 `$derived`

#### 합계/필터: React → Svelte 4

```jsx
// React
const [list, setList] = useState([1,2,3]);
const sum = useMemo(() => list.reduce((a,b)=>a+b,0), [list]);
```

```svelte
<!-- Svelte 4 -->
<script>
  let list = [1,2,3];
  let sum;
  $: sum = list.reduce((a,b)=>a+b,0); // list가 바뀌면 sum 재계산
</script>

<p>합계: {sum}</p>
```

#### Svelte 5 Runes 스타일 (맛보기)

```svelte
<script>
  // Svelte 5
  const list = $state([1,2,3]);
  const sum  = $derived(list.reduce((a,b)=>a+b,0));
</script>

<p>합계: {sum}</p>
<button on:click={() => list.push(4)}>추가</button>
```

---

### 양방향 바인딩 & 폼

- **React**: `value` + `onChange` 수동 동기화
- **Vue**: `v-model`
- **Svelte**: **`bind:`** 문법

```jsx
// React
const [name, setName] = useState('');
<input value={name} onChange={e => setName(e.target.value)} />
```

```svelte
<!-- Svelte -->
<script> let name = '';</script>
<input bind:value={name} />
```

바인딩 가능한 속성:
- `bind:value`(input, select, textarea)
- `bind:checked`, `bind:files`, `bind:this`(요소/컴포넌트 참조) 등

---

### Props & 이벤트

- **React**: props + `onClick`, 커스텀 이벤트는 콜백 props로
- **Vue**: props + `$emit`
- **Svelte**: `export let ...`로 **props**, `createEventDispatcher()`로 **커스텀 이벤트**

```svelte
<!-- Child.svelte -->
<script>
  import { createEventDispatcher } from 'svelte';
  export let value = 0;
  const dispatch = createEventDispatcher();
  function inc(){ dispatch('inc', { value: value + 1 }); }
</script>

<button on:click={inc}>+</button>
```

```svelte
<!-- Parent.svelte -->
<script> let n = 0; </script>
<Child {n} on:inc={(e) => n = e.detail.value} />
```

---

### 컨텍스트 & 전역 상태

- **React**: Context API, Redux/Zustand/Recoil 등
- **Vue**: provide/inject, Pinia/Vuex
- **Svelte**: `setContext/getContext`, **스토어**(`writable/readable/derived`)

```svelte
<!-- context: set -->
<script context="module">
  import { setContext } from 'svelte';
  export function loadContext(user){ setContext('user', user); }
</script>

<script>
  import { loadContext } from './this';
  loadContext({ id: 'u1' });
</script>
```

```svelte
<!-- context: get -->
<script>
  import { getContext } from 'svelte';
  const user = getContext('user');
</script>
<p>{user.id}</p>
```

스토어 예:
```js
// src/lib/store/user.js
import { writable } from 'svelte/store';
export const user = writable(null);
```

```svelte
<script>
  import { user } from '$lib/store/user';
  $: me = $user; // $store로 자동 구독/해제
</script>
```

---

### 라이프사이클 매핑

| React | Vue | Svelte |
|---|---|---|
| `useEffect(() => {...}, [])` | `onMounted` | `onMount` |
| `useEffect` (deps 변경) | `watch`, `onUpdated` | `$:` 반응 구문 / `beforeUpdate`·`afterUpdate` |
| `useEffect` clean-up | `onUnmounted` | `onDestroy` |

```svelte
<script>
  import { onMount, onDestroy } from 'svelte';
  let timer;
  onMount(() => { timer = setInterval(()=>console.log('tick'), 1000); });
  onDestroy(() => clearInterval(timer));
</script>
```

---

### 조건/반복/비동기 템플릿

- **React**: `{condition && <Comp/>}`, `{list.map(...)}`, `Suspense`
- **Vue**: `v-if`, `v-for`, `v-slot`, `<Suspense>`
- **Svelte**: `{#if}`, `{#each}`, `{#await}`

```svelte
{#if ready}
  <p>준비됨</p>
{:else}
  <p>로딩...</p>
{/if}

{#each items as it, i}
  <li>{i}:{it.name}</li>
{/each}

{#await fetchUser() then u}
  <p>{u.name}</p>
{:catch e}
  <p>에러: {e.message}</p>
{/await}
```

---

### CSS 스코프 & 스타일

- **React**: CSS-in-JS/모듈/전역 등 선택
- **Vue**: `<style scoped>`
- **Svelte**: **자동 스코프**(컴포넌트 로컬), 전역은 `:global(...)`

```svelte
<style>
  .btn { color: red; }       /* 컴포넌트 로컬 스코프 */
  :global(.prose h1){ ... }  /* 전역 */
</style>
```

---

### 마이그레이션 전략 (React/Vue → Svelte)

1. **위젯/하위 컴포넌트부터** 포팅(리스크 분산)
2. **라우팅/데이터 레이어** 유지, View만 SvelteKit로 교체(점진적)
3. **디자인 시스템**(버튼/입력/모달) 먼저 Svelte 컴포넌트화
4. “**할당 기반 반응성**”에 익숙해질 것 → **불변 업데이트 강박에서 해방**
5. **빌드 결과 비교**(번들·LCP·Hydration): Svelte가 대체로 유리

---

## Svelte 4 → 5 마이그레이션 **체크리스트**

> Svelte 5의 **Runes**( `$state`, `$derived`, `$effect`, `$props` 등) 도입으로 **표현력**과 **직관성**이 높아졌다.
> 마이그레이션은 **점진적**으로 가능: 기존 Svelte 4 문법은 여전히 유효하며, 필요한 곳부터 Runes를 적용하면 된다.

### 준비

- 의존성 업데이트: `svelte`, `@sveltejs/kit`, `vite-plugin-svelte`
- 타입스크립트/ESBuild/Vite 최신화
- ESLint/Prettier 플러그인 버전 호환 확인

### 반응성 전환 가이드(선택 적용)

| Svelte 4 | Svelte 5 (Runes) | 비고 |
|---|---|---|
| 지역 상태: `let x=0; x=1` | `const x=$state(0); x=1` | **$state**는 내부 변이 추적 (배열/객체를 직접 변경해도 반응) |
| 파생: `$: y=f(x)` | `const y=$derived(f(x))` | 의존 자동 추적 |
| 사이드이펙트: `$: { ... }` | `$effect(() => { ... })` | 의존 값 변경 시 재실행 |
| props: `export let a` | `const { a } = $props()` | 구조분해로 명시 |

#### 예: Svelte 4 → 5 변환

```svelte
<!-- Svelte 4 -->
<script>
  export let a = 1;
  let b = 2;
  $: sum = a + b;
</script>
<p>{sum}</p>
```

```svelte
<!-- Svelte 5 -->
<script>
  const { a } = $props();
  const b = $state(2);
  const sum = $derived(a + b);
</script>
<p>{sum}</p>
```

### 스토어 상호운용

- **여전히 사용 가능**: `writable/readable/derived` + `$store` 구문
- Runes와 혼용:
```svelte
<script>
  import { writable } from 'svelte/store';
  const userStore = writable(null);
  const local = $state({ count: 0 });

  $effect(() => {
    console.log('user', $userStore);   // 자동 구독문법 유지
  });
</script>
```

### 이벤트/바인딩/슬롯: API 변화 여부

- 핵심 문법(`on:`, `bind:`, `<slot>`)은 **기존과 동일**
- 마이그레이션에서 UI 구조 변경은 최소

### 라이프사이클

- `onMount/beforeUpdate/afterUpdate/onDestroy` **지속**
- Runes의 `$effect`로 많은 경우 대체 가능(의존 명시가 명확)

### 성능/번들 점검

- 빌드 후 번들 사이즈/하이드레이션 시간 비교
- **반응 경로 단순화**로 업데이트 비용이 줄어드는 지점 확인

### 테스트/릴리즈

- 컴포넌트 단위 스냅샷/DOM 테스트 유지
- CI에서 Svelte 4/5 공존 단계 지원(브랜치/플래그로 분리)
- 변경된 반응성으로 **랜더 타이밍**이 달라지는지 육안/테스트로 확인

---

## React/Vue → Svelte **리팩터링 캡슐**

### 리스트 필터/정렬

```jsx
// React
const [q, setQ] = useState('');
const filtered = useMemo(
  () => items.filter(it => it.name.includes(q)).sort((a,b)=>a.name.localeCompare(b.name)),
  [items, q]
);
```

```svelte
<!-- Svelte 4 -->
<script>
  let q = '';
  export let items = [];
  $: filtered = items
    .filter(it => it.name.includes(q))
    .sort((a,b)=>a.name.localeCompare(b.name));
</script>

<input bind:value={q} placeholder="검색" />
{#each filtered as it}<div>{it.name}</div>{/each}
```

Svelte 5:
```svelte
<script>
  const q = $state('');
  const items = $state([]);
  const filtered = $derived(items.filter(it => it.name.includes(q)).toSorted((a,b)=>a.name.localeCompare(b.name)));
</script>
```

---

### 모달/포털

- React/Vue: 포털 API 또는 라이브러리
- Svelte: **레이아웃 루트에 슬럿/조건 렌더**로 간단 처리, 필요시 `svelte:portal`(환경에 따라) 또는 DOM 컨테이너에 `append` 활용

```svelte
<!-- Modal.svelte -->
<script> export let open=false; export let onClose=()=>{}; </script>
{#if open}
  <div class="backdrop" on:click|stopPropagation={onClose}>
    <div class="panel" on:click|stopPropagation>
      <slot/>
    </div>
  </div>
{/if}
```

---

### 폼 검증

- React: react-hook-form + zod/yup
- Vue: vee-validate
- Svelte: **DOM 바인딩 + zod** 직접 결합 or `felte/sveltekit-superforms` 등

```svelte
<script>
  import { z } from 'zod';
  const schema = z.object({ email: z.string().email() });
  let email=''; let err='';
  function submit(){
    const r = schema.safeParse({ email });
    err = r.success ? '' : r.error.issues[0].message;
  }
</script>
<input bind:value={email} type="email" />
{#if err}<p class="error">{err}</p>{/if}
<button on:click={submit}>제출</button>
```

---

## 프레임워크 비교 요약 (사용성/성능/생태계)

### 큰 그림

| 항목 | **Svelte** | **React** | **Vue** |
|---|---|---|---|
| 렌더 철학 | **컴파일러**가 반응 경로 생성, DOM 직접 패치 | 가상 DOM diff | Proxy 트래킹 + 가상 DOM |
| 반응성 | **할당 기반** + `$:` / **Runes(Svelte 5)** | setState/Hook, 의존관리 필요 | ref/reactive/computed/watch |
| 번들/성능 | **작고 빠름**(런타임 적음) | 에코시스템 방대, 런타임 상대 큼 | 적당한 균형, 생태계 좋음 |
| 템플릿 | Svelte 템플릿 구문 | JSX (완전 JS) | 템플릿 + `<script setup>` |
| 양방향 바인딩 | `bind:` 내장 | 직접 관리 | `v-model` |
| 공식 풀스택 | **SvelteKit** | Next.js(별도) | Nuxt(별도) |
| 러닝커브 | 짧음(템플릿 직관) | JSX/Hook/상태 관리 선택지로 다양 | 친숙한 템플릿/옵션/컴포지션 API |
| 모바일/데스크톱 | Capacitor/Tauri 등 손쉬움 | React Native/Electron | Vue + Capacitor/Tauri |
| 기업/생태계 | 빠르게 성장 | **매우 거대** | **매우 크고 안정** |

### 성능 관찰 포인트

- 초기 페인트/LCP: Svelte의 **출력 HTML**이 가벼워 유리
- 하이드레이션 비용: 컴포넌트/상태 수가 많을수록 차이가 커짐
- 업데이트 비용: Svelte는 **정확한 DOM 지점**만 업데이트

개념 공식(단순화):
$$
T_{\mathrm{update}} \approx N_{\mathrm{dirty}}\cdot c_{\mathrm{patch}}
$$
- React/Vue는 dirty 측정과 가상 DOM diff 비용 포함
- Svelte는 **dirty 경로가 컴파일로 고정**되어 \(c_{\mathrm{patch}}\)가 작은 편

### 팀 도입 의사결정

- 기존 React/Vue 자산 크면 **혼용/부분 도입**이 현실적
- **새 프로젝트/그린필드** → SvelteKit 추천(학습/생산성·번들 측면)
- **사내 공통 UI Kit**: Svelte 컴포넌트 + **웹 컴포넌트(Custom Elements)** 병행 배포시 프레임워크 독립성 확보

---

## 체크리스트 (현실 적용)

### React/Vue → Svelte

- [ ] 공통 레이아웃/라우팅/데이터 페치 경로 파악
- [ ] 핵심 상태 모델링(지역/전역/URL 동기화)
- [ ] 입력/폼 → `bind:` 전환, 검증 라이브러리 연결(zod 등)
- [ ] 컴포넌트 이벤트 → `createEventDispatcher`로 통일
- [ ] 컨텍스트/API: `setContext/getContext`·스토어 구성
- [ ] 스타일 스코프 전략 확정(전역 reset, 디자인 토큰)

### Svelte 4 → 5

- [ ] Runes 사용 목표 영역 선정(핵심 상태/파생/이펙트)
- [ ] `$:` → `$derived`/`$effect`로 대체 가능한 곳 분류
- [ ] 배열/객체 **불변 업데이트** 습관 → **$state 변이 허용**으로 리팩터
- [ ] 스토어 혼용 전략 정의(점진적 적용)
- [ ] 퍼포먼스 회귀 테스트(렌더 횟수/시간)

---

## 실전 미니 마이그 예제

### React 검색 목록 → Svelte 4

```jsx
// React
function SearchList({ source }) {
  const [q, setQ] = useState('');
  const [items, setItems] = useState([]);
  useEffect(() => { source.fetch().then(setItems); }, [source]);
  const view = useMemo(() => items.filter(x => x.includes(q)), [items, q]);
  return <>
    <input value={q} onChange={e=>setQ(e.target.value)} />
    <ul>{view.map(x=><li key={x}>{x}</li>)}</ul>
  </>;
}
```

```svelte
<!-- Svelte -->
<script>
  export let source;
  let q = '';
  let items = [];
  $: source && source.fetch().then(v => items = v);   // 의존에 따라 자동 재실행
  $: view = items.filter(x => x.includes(q));
</script>

<input bind:value={q} />
<ul>{#each view as x}<li>{x}</li>{/each}</ul>
```

### Vue 컴포지션 → Svelte 5 (Runes)

```ts
// Vue (setup)
const q = ref('');
const items = ref<string[]>([]);
onMounted(async () => items.value = await fetchItems());
const view = computed(() => items.value.filter(x => x.includes(q.value)));
```

```svelte
<!-- Svelte 5 -->
<script>
  const q = $state('');
  const items = $state<string[]>([]);
  $effect(async () => { items.splice(0, items.length, ...(await fetchItems())); });
  const view = $derived(items.filter(x => x.includes(q)));
</script>
<input bind:value={q} />
{#each view as x}<li>{x}</li>{/each}
```

---

## FAQ

**Q. Redux/MobX 같은 상태 관리가 꼭 필요한가요?**
A. 대개 **필요 없음**. Svelte 스토어 + 컨텍스트로 충분. 단, 복잡한 캐시/비동기 요청 조합은 **TanStack Query** 같은 툴 병행 고려.

**Q. 거대한 앱에서 유지보수는?**
A. **컴파일러 기반 반응성**이 구조를 단순화한다. 폴더링·경계(컨테이너/프리젠테이션), 스토어 모듈화, 타입 명세로 스케일링.

**Q. 테스트 전략은?**
A. 로직은 유닛, 컴포넌트는 DOM 테스트(Testing Library), 페이지는 E2E(Playwright). Svelte 4/5 공통.

---

## 결론

- React/Vue에서 넘어올 때는 **“할당=업데이트”**와 **반응 구문/Runes**를 중심으로 **사고 전환**.
- Svelte 4 → 5는 **점진적**으로: 먼저 핵심 상태를 `$state/$derived/$effect`로 이식.
- 프레임워크 선택은 **팀의 자산/목표/생태계 의존도**를 고려하되, **새 프로젝트**라면 SvelteKit이 **학습·생산성·성능**에서 좋은 균형을 제공.
