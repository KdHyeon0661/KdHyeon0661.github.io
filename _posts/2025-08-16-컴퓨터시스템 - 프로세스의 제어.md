---
layout: post
title: 컴퓨터시스템 - 프로세스의 제어
date: 2025-08-16 16:20:23 +0900
category: 컴퓨터시스템
---
# 프로세스의 제어(Process Control)

## 큰 그림: 프로세스 제어의 범위와 모델

**프로세스 제어(Process Control)** = 커널이 제공하는 **시스템 콜**과 커널 자료구조(PCB 등)를 이용하여,
**생성 → 실행(전환) → 대기(블록) → 재개 → 종료(수거)** 의 생명주기를 관리하는 일.

프로세스는 단일 객체가 아니라 다음 **리소스의 묶음**이다.

- **주소공간**(페이지 테이블, VMA)
- **스레드(들)**(레지스터·스택·스케줄 상태)
- **열린 파일(디스크·파이프·소켓·이벤트FD…)**의 **FD 테이블**
- **보안 컨텍스트**(UID/GID, capabilities, LSM)
- **자원 한도**(RLIMIT), **cgroup**(CPU/Memory/I/O/CPuset)
- **시그널/타이머** 상태, **프로세스 그룹/세션** 정보

---

## 생명주기 상태와 전이(전통 + 리눅스 관점)

```
  New → Ready ↔ Running → Terminated
               ↘
                Blocked (I/O, futex, waitpid, poll/epoll…)
               ↗
          (이벤트 발생시 Ready로)
```

- **Ready**: CPU 배정 대기(런큐).
- **Running**: CPU에서 실행.
- **Blocked/Waiting**: 시스템콜/동기화 객체에서 이벤트 대기.
- **Stopped**: `SIGSTOP/TSTP` 등으로 일시정지.
- **Zombie**: 종료했으나 부모가 `wait*`로 **수거**하지 않아 잔존.

---

## PCB와 커널 구조(리눅스)

- `task_struct` (스레드/프로세스 제어 블록; 레지스터 컨텍스트, 상태, 스케줄러 엔트리)
- `mm_struct` (주소공간; 페이지 테이블 루트, `vm_area_struct` 목록)
- `files_struct` (FD 테이블), `fs_struct`(cwd/umask), `signal_struct`(시그널 큐·마스크)
- `cred` (UID/GID, capabilities), LSM label
- 리눅스는 **스레드=가벼운 프로세스**(LWP)로 구현: 같은 `mm_struct`/`files_struct` 공유 가능

**문맥 전환(Context Switch)**
- 저장/복원: 레지스터·FPU·TLS·(필요 시) 주소공간(mm)
- 스케줄러(CFS/RT/Deadline)가 다음 러너블 태스크 선택

---

## 생성과 실행 이미지 교체: `fork/exec`, `posix_spawn`, `clone3`

### `execve()`

```c
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    pid_t p = fork();
    if (p < 0) { perror("fork"); exit(1); }
    if (p == 0) {                       // child
        execlp("ls", "ls", "-l", NULL); // 이미지 교체
        _exit(127);                     // exec 실패 시
    }
    int st = 0;
    if (waitpid(p, &st, 0) == -1) { perror("waitpid"); }
    if (WIFEXITED(st)) printf("child exit=%d\n", WEXITSTATUS(st));
}
```
- **COW**: `fork()` 직후 부모/자식은 물리 페이지를 공유, **쓰기 시 복사**(효율적).
- **FD 상속**: `FD_CLOEXEC`(또는 생성시 `O_CLOEXEC`) 없으면 `exec` 뒤에도 열린다 → **보안/누수 주의**.

### 경량 실행: `posix_spawn(3)`

- glibc가 내부적으로 `vfork/exec` 또는 `clone` 기반으로 효율 구현.
- 단순 **런처**에 적합(파일 액션, 속성 지정이 간단).

```c
#include <spawn.h>
#include <sys/wait.h>

extern char **environ;

int run_ls() {
    pid_t pid; char *argv[] = {"ls", "-l", NULL};
    if (posix_spawn(&pid, "/bin/ls", NULL, NULL, argv, environ) != 0) return -1;
    int st; waitpid(pid, &st, 0);
    return WIFEXITED(st) ? WEXITSTATUS(st) : -1;
}
```

### 세밀 제어: `clone3(2)` (리눅스 5.3+)

- 스레드/네임스페이스/시그널 공유 등 플래그로 정밀 생성. 컨테이너 런타임에서 주력.
- 예: 새 PID/NET/MNT ns로 **격리된 프로세스** 생성.

---

## 실행 컨텍스트 구성: `execve` 디테일

- **인자/환경**: `argv[]`, `envp[]` 전달, 최대 길이 제한(스택 상주).
- **로더(ELF interpreter)**: 동적 링킹 시 **ld.so**가 PLT/GOT 재배치, 초기화 루틴(`.init_array`) 실행.
- **파일 액션**: `dup2`, `close`, `chdir`, `setsid`, `setpgid`, `umask`, `setuid/gid`, `prctl` 등으로 **환경을 정리**한 뒤 `exec` 권장.
- **보안**: `O_CLOEXEC`, 환경 정화(`clearenv`), 경로 해석 제한(`execveat`, `*at` 계열) 고려.

---

## 대기/수거: `wait*` 패밀리, 좀비/고아, 서브리퍼

### 기본 수거 루프(좀비 방지)

```c
#include <sys/wait.h>

void reap_all(void) {
    int st;
    for(;;) {
        pid_t r = waitpid(-1, &st, WNOHANG);
        if (r <= 0) break;
        // 로그 등 처리
    }
}
```

### 신호 기반 수거(신뢰성↑)

- `SIGCHLD` 핸들러에서 플래그만 세우고, 메인 루프에서 `reap_all()` 호출
  또는 **`signalfd`** 로 이벤트 드리븐 처리.

### 고아/서브리퍼

- 부모 종료 시 자식은 **PID 1**(또는 **서브리퍼**)에게 입양됨.
- 도구: `prctl(PR_SET_CHILD_SUBREAPER, 1)` → **슈퍼바이저/런처** 구현에 유용.

---

## 종료와 상태 코드, 수학적 해석

- 정상 종료: `exit(code)`; 상위 8비트로 전달 → \( \text{code} \in [0,255] \)
- 시그널 종료: `WIFSIGNALED(st)`, \( \text{sig} = WTERMSIG(st) \)
- 종료 상태(응답시간) 직관식:
  $$ \text{Turnaround} = \text{Waiting} + \text{Running} + \text{I/O} $$
  스케줄링 전략/부하에 따라 **Waiting** 성분이 지배적.

---

## 문맥 전환(Context Switch)과 스케줄링 제어

### 스케줄러 개요(리눅스)

- **CFS**: 일반 태스크. **가상 런타임** \( v_i \) 균등화
  $$ v_i \leftarrow v_i + \frac{\Delta t}{w_i} \quad (\text{niceness}\rightarrow w_i) $$
- **RT(FIFO/RR)**: CFS보다 절대 우선. **주의 깊게** 사용.
- **SCHED_DEADLINE**: \( \langle runtime, deadline, period \rangle \) 기반 보장.

### 실전 제어

```bash
nice -n 10 ./job                 # 우선순위 낮춤
renice -n -5 -p <pid>            # 실행 중 조정(-20..19)
chrt -f -p 80 <pid>              # RT FIFO 80
taskset -c 0-3 ./job             # CPU affinity
```

---

## 시그널과 제어: 종료·정지·재개·리로드·그룹신호

- 표준 순서(점진적): **TERM → INT → QUIT(코어덤프) → KILL**
```bash
kill -TERM <pid>
kill -KILL <pid>
kill -STOP <pid>; kill -CONT <pid>
pkill -HUP nginx   # 재로딩 관례
```
- **프로세스 그룹/세션**: `setpgid`, `setsid`; **foreground job** 제어 시 `tcsetpgrp` 사용.
- **그룹 신호**: `kill(-pgid, SIGTERM)` 형태로 **파이프라인 전체** 종료.

**안전 패턴**: `SIGPIPE` 무시 후 `EPIPE`로 처리.
```c
signal(SIGPIPE, SIG_IGN);
```

---

## 리소스 한도와 cgroup v2

### RLIMIT (프로세스 로컬 한도)

- `NOFILE`(FD 수), `STACK`, `NPROC`, `CORE`, `AS`(가상메모리) 등
```bash
prlimit --pid <pid> --nofile=65535
ulimit -a
```

### cgroup v2 (계층적 자원 관리)

- **CPU**(weight/quota), **Memory**(Low/High/Max), **I/O**(bw/IOPS), **PIDs**, **cpuset**
```bash
systemd-run -p CPUQuota=50% -p MemoryMax=1G --scope --pid <PID>
```
- **PSI(Pressure Stall Information)**: `/proc/pressure/{cpu,memory,io}`로 과부하 감지 → 자동 완화 로직에 활용.

---

## 네임스페이스/격리/권한: 프로세스 경계 강화

- 네임스페이스: **PID/NET/UTS/MNT/IPC/USER/CGROUP**
  샌드박스/컨테이너의 기본기
```bash
unshare --pid --net --uts --ipc --mount --fork --mount-proc bash
```
- **capabilities**: 루트 권한을 세분화(`setcap`, `capsh --print`)
- **seccomp**: 시스템콜 화이트리스트/필터(런타임 공격면 축소)

---

## 현대 신기술: pidfd/clone3/io_uring

- **pidfd_open(2)**: PID 재사용 레이스 없는 **안전 시그널/대기**
```c
#include <sys/syscall.h>
#include <unistd.h>
#include <signal.h>

int send_term_safely(pid_t pid){
    int pfd = syscall(SYS_pidfd_open, pid, 0);
    if (pfd < 0) return -1;
    // pidfd_send_signal(pfd, SIGTERM, NULL, 0)
    int r = syscall(SYS_pidfd_send_signal, pfd, SIGTERM, NULL, 0);
    close(pfd);
    return r;
}
```
- **clone3**: 세밀한 태스크 생성(플래그/스택/시그널 지정 확장)
- **io_uring**: 낮은 오버헤드 비동기 I/O(프로세스 제어 자체보단 I/O 대기 최적화에 기여)

---

## 안전한 스폰/슈퍼비전 패턴(누수·경쟁·좀비 방지)

### 부모가 파이프/시그널로 준비 확인 후 exec

```c
// 부모-자식 동기화용 파이프 + CLOEXEC, 실패시 안전 종료
int pfd[2]; pipe2(pfd, O_CLOEXEC);
pid_t c = fork();
if (c == 0) {
    // 세션 분리/그룹 설정 예시
    setsid(); setpgid(0,0);

    // 표준 스트림 재지정(필요 시)
    // dup2(in_fd, 0); dup2(out_fd, 1); dup2(err_fd, 2);

    execlp("myservice","myservice",NULL);
    _exit(127);
}
// 부모: 자식이 exec에 성공했는지 확인(예: 자식이 준비되면 소켓을 연다/표시 파일 생성 등)
```

### PR_SET_PDEATHSIG: 부모 죽으면 자식도 종료

```c
#include <sys/prctl.h>

prctl(PR_SET_PDEATHSIG, SIGTERM);
```

### signalfd + event loop 로 수거/종료

- `signalfd`와 `epoll`을 묶어 **SIGCHLD, SIGTERM** 등 이벤트를 **동기적 FD**로 처리 → 레이스·EINTR 감소.

---

## 대기/타임아웃/취소의 표준형

- **EINTR 루프**: 신호로 중단된 블록콜은 재시도.
- **데드라인 패턴**: 절대시간(모노토닉) 기반의 남은시간 계산.
- **poll/ppoll/epoll + O_NONBLOCK**: `EAGAIN`을 정상 흐름으로 간주, 준비되면 I/O.

```c
#include <poll.h>

ssize_t read_once_nb(int fd, void* buf, size_t n, int ms){
    struct pollfd p = { .fd=fd, .events=POLLIN };
    int r = poll(&p, 1, ms); if (r<=0) { errno = (r==0)? ETIMEDOUT:errno; return -1; }
    return read(fd, buf, n);    // 여전히 EINTR/EAGAIN 가능
}
```

---

## 프로세스 그룹/세션/TTY: 잡 컨트롤의 핵심

- **프로세스 그룹(PGID)**: 관련 프로세스 묶음(파이프라인). `kill(-pgid, sig)`로 그룹 신호.
- **세션(SID)**: 잡 컨트롤 단위. `setsid()`로 **컨트롤링 터미널** 탈착/획득.
- **포그라운드 프로세스 그룹**: TTY 입력/시그널(`SIGINT/SIGTSTP`)이 **그룹 전체**에 전달.

간단 파이프라인 예(부모가 그룹 전체 종료):
```bash
# 파이프라인을 한 그룹으로 실행 후 그룹 종료

( sleep 100 | cat ) & PG=$!   # 셸마다 구현 다름(일반적으로 하나의 잡)
kill -- -$(ps -o pgid= $PG)   # 그룹 전체에 신호 전송
```

---

## 관찰/추적/디버깅: /proc, lsof, strace, perf, bpf

```bash
ps -eLo pid,ppid,tid,psr,pcpu,stat,cmd --sort=-pcpu | head
cat /proc/<pid>/status
ls -l /proc/<pid>/fd
lsof -p <pid>
strace -f -ttT -p <pid>
perf top -p <pid>
```
- **코어덤프**: `ulimit -c unlimited` + `coredumpctl gdb` (systemd 환경)
- **bpftrace/bcc**: `execsnoop`, `opensnoop`, `runqlat`, `tcplife` 등 저오버헤드 관찰

---

## 보안·무결성: setuid, capabilities, seccomp, 환경 정리

- **권한 하향**: `setuid/setgid`, **capabilities** 최소화
- **seccomp-bpf**: 필요한 시스템콜만 허용(화이트리스트)
- **환경·FD 정리**: `clearenv()` 후 필요한 변수만 추가, `O_CLOEXEC` 철저
- **chroot/pivot_root/명시적 mount ns**: 파일 시스템 뷰 격리

---

## 실전 레시피

### “자식 실행 → 타임아웃 시 종료 → 정확히 수거”

```c
#define _GNU_SOURCE
#include <signal.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>

int run_with_timeout(char* const argv[], int timeout_sec){
    pid_t p = fork();
    if (p == 0){ execlp(argv[0], argv[0], argv[1], NULL); _exit(127); }

    struct timespec dl; clock_gettime(CLOCK_MONOTONIC, &dl);
    dl.tv_sec += timeout_sec;

    for(;;){
        int st; pid_t r = waitpid(p, &st, WNOHANG);
        if (r == p) return WIFEXITED(st) ? WEXITSTATUS(st) : 128+WTERMSIG(st);

        struct timespec now; clock_gettime(CLOCK_MONOTONIC, &now);
        if (now.tv_sec > dl.tv_sec || (now.tv_sec==dl.tv_sec && now.tv_nsec>=dl.tv_nsec)){
            kill(p, SIGTERM);      // 점진적 종료
            sleep(1);
            kill(p, SIGKILL);      // 강제 종료
        }
        usleep(1000*50); // 50ms 폴링(간단형; prod에선 signalfd/ppoll 권장)
    }
}
```

### “서비스를 격리해 CPU/메모리 제한 걸고 시작”

```bash
systemd-run --unit=myjob.scope --scope \
  -p CPUQuota=40% -p MemoryMax=1G -p TasksMax=256 \
  -- bash -c './myservice'
```

### “부모 죽으면 자식도 정리(PDEATHSIG)”

```c
#include <sys/prctl.h>

prctl(PR_SET_PDEATHSIG, SIGTERM);
```

---

## 함정 & 체크리스트

- [ ] **좀비 방지**: `SIGCHLD` 처리 + `waitpid(WNOHANG)` 루프 구현
- [ ] **FD 누수**: `O_CLOEXEC`/`FD_CLOEXEC` 일관적 사용
- [ ] **EINTR** 재시도: 블록콜 **모두** 루프 처리
- [ ] **SIGPIPE** 무시 또는 `MSG_NOSIGNAL`
- [ ] **PID 레이스**: 가능하면 **pidfd** 사용
- [ ] **RT 스케줄 남용 금지**: 시스템 응답성 저하
- [ ] **환경/경로 정리**: `execve` 전 최소권한·최소표면
- [ ] **ASLR/코어덤프/심볼**: 디버그 준비
- [ ] **cgroup v2**: 자원 격리/제한을 **설계 단계**에 반영

---

## 성능 직관(간단 식)

타임 슬라이스가 \( q \), 컨텍스트 스위치 오버헤드가 \( s \)일 때,
CPU 사용 효율 \(\eta\) 근사:
$$ \eta \approx \frac{q}{q+s} $$
너무 작은 \( q \)는 오버헤드 비중을 키워 효율 저하. 반대로 너무 크면 응답지연 증가 → **트레이드오프**.

---

## FAQ

**Q. `vfork()`는 언제 쓰나요?**
A. 부모 스택/주소공간을 공유한 채 자식이 `exec`만 즉시 호출할 때. **부주의하면 UB**(부모 스택 변조). 현대엔 `posix_spawn` 선호.

**Q. `kill -9`(SIGKILL)는 만능인가요?**
A. 커널이 전달은 보장하지만 **D(T) 상태**(디스크 I/O 중단 불가) 등에서는 반응 없을 수 있다. 먼저 **TERM/HUP**으로 정상 종료를 시도.

**Q. 동일 프로그램 다중 인스턴스 제어?**
A. pidfile/lockfile, `flock`, 또는 **cgroup**/systemd 단위로 관리.

---

## 요약

- 프로세스 제어는 **생성(fork/posix_spawn/clone3)**, **전환(스케줄러)**, **대기(wait/epoll)**, **종료/수거**, **시그널/그룹/세션**, **자원·권한·격리(cgroup/ns)** 를 종합적으로 다룬다.
- 현대 리눅스는 **pidfd**, **cgroup v2**, **PSI**, **SCHED_DEADLINE** 등으로 **안전성/관찰성/예측성**을 강화했다.
- 실전에서는 **표준 패턴(에러/타임아웃/부분 I/O/좀비 방지)** 를 템플릿화해 **견고한 런처·슈퍼바이저**를 구축하라.

---

## 자주 쓰는 명령 치트시트

```bash
# 찾기/관찰

ps -eLo pid,ppid,tid,psr,pcpu,stat,cmd --sort=-pcpu | head
lsof -p <pid>
cat /proc/<pid>/{status,limits,maps}
strace -f -ttT -p <pid>
perf top -p <pid>
bpftrace -e 'tracepoint:syscalls:sys_enter_execve { printf("%d %s\n", pid, comm); }'

# 제어

kill -TERM <pid>; sleep 1; kill -KILL <pid>
renice -n 10 -p <pid>
taskset -pc 0-3 <pid>
chrt -f -p 80 <pid>

# 자원/격리

prlimit --pid <pid> --nofile=65535
systemd-run -p MemoryMax=2G -p CPUQuota=60% --scope --pid <pid>
unshare --mount --uts --ipc --net --pid --fork --mount-proc bash
```
