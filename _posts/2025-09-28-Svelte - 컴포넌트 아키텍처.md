---
layout: post
title: Svelte - 컴포넌트 아키텍처
date: 2025-09-28 22:25:23 +0900
category: Svelte
---
# 6. 컴포넌트 아키텍처
**Prop/이벤트/슬롯 설계 규칙 · 컨텍스트 API(`setContext/getContext`) · 컨테이너–프리젠테이션 패턴 · 재사용 가능한 액션/유틸 모듈화**

> 이 장은 “컴포넌트를 어떻게 **설계**할 것인가?”에 초점을 둔다.  
> - 컴포넌트의 **공개 API(Prop/이벤트/슬롯)**를 일관된 규칙으로 설계하고  
> - **컨텍스트 API**로 트리 깊은 곳까지 상태/행동을 안전하게 주입하며  
> - **컨테이너–프리젠테이션**으로 데이터/표현 분리를 통해 테스트·확장성을 높이고  
> - **액션/유틸/스토어**를 모듈화해 재사용 가능한 빌딩 블록을 만든다.

---

## 6.1 Prop / 이벤트 / 슬롯 — **공개 API**의 3요소

### 6.1.1 설계 원칙 (요약 체크리스트)

- **Prop**
  - 기본값을 제공하고 `export let`에 **명확한 타입/설명**을 남긴다.
  - **불변 데이터**를 선호하고, 변경은 **이벤트**로 알린다.
  - 이름 규칙: 의미+상태(ex. `size`, `variant`, `disabled`, `value`).
  - `...$$restProps`로 **원시 DOM 속성**을 **그대로 전달**할 여지를 둔다.

- **이벤트**
  - **`createEventDispatcher()`**로 커스텀 이벤트를 만들고, 이름은 `change`, `open`, `select`, `submit`처럼 **행동 중심**으로.
  - payload는 `{ detail: ... }`에 **최소한의 필요한 정보**만 넣는다.
  - **버블링/캡처** 동작을 고려하고, 필요 시 문서화한다.

- **슬롯**
  - **기본 슬롯**과 **이름 슬롯**을 제공하되, 컴포넌트의 레이아웃/접근성 골격은 유지한다.
  - **슬롯 props**로 내부 상태를 노출할 수 있으나, “필요 최소한”만.
  - skeleton/placeholder 등 **대체 콘텐츠**를 기본 슬롯에 넣어 UX를 보장한다.

---

### 6.1.2 버튼 컴포넌트 예시: API 표면 설계

```svelte
<!-- src/lib/components/ui/Button.svelte -->
<script lang="ts">
  import { createEventDispatcher } from 'svelte';

  // 1) Props
  export let variant: 'primary' | 'outline' | 'ghost' = 'primary';
  export let size: 'sm' | 'md' | 'lg' = 'md';
  export let disabled = false;
  export let loading = false;
  export let type: 'button' | 'submit' = 'button';

  // $$restProps: 원시 DOM 속성(aria-*, data-*, id 등) 전달
  export let $$restProps: svelte.JSX.HTMLAttributes<HTMLButtonElement>;

  // 2) Dispatch
  const dispatch = createEventDispatcher<{ click: MouseEvent }>();

  function onClick(e: MouseEvent) {
    if (disabled || loading) {
      e.preventDefault();
      return;
    }
    dispatch('click', e);
  }

  // 3) 클래스 계산
  $: cls = [
    'btn',
    `btn--${variant}`,
    `btn--${size}`,
    disabled && 'is-disabled',
    loading && 'is-loading'
  ].filter(Boolean).join(' ');
</script>

<button
  class={cls}
  disabled={disabled}
  type={type}
  on:click|preventDefault={onClick}
  {...$$restProps}
>
  <!-- 이름 슬롯: 아이콘 영역 -->
  <slot name="leading" />
  <slot />
  <slot name="trailing" />
</button>

<style>
  .btn { display:inline-flex; align-items:center; gap:.5rem; border-radius:12px; padding:.5rem .9rem; border:1px solid var(--border); }
  .btn--primary { background: var(--color-btn); color: var(--color-btn-fg); border-color: var(--color-btn); }
  .btn--outline { background: var(--surface); color: var(--fg); }
  .btn--ghost { background: transparent; color: var(--fg); border-color: transparent; }
  .btn--sm { padding:.35rem .6rem; font-size:.9rem; }
  .btn--md { font-size:1rem; }
  .btn--lg { padding:.65rem 1rem; font-size:1.05rem; }
  .is-disabled { opacity:.6; pointer-events:none; }
  .is-loading { cursor:progress; }
</style>
```

사용:

```svelte
<script>
  import Button from '$lib/components/ui/Button.svelte';
  const save = () => console.log('save!');
</script>

<Button variant="outline" on:click={save} aria-label="Save">
  <svelte:fragment slot="leading">💾</svelte:fragment>
  Save
</Button>
```

> 포인트  
> - **DOM 속성 전달**을 위해 `$$restProps` 활용(접근성/테스트에 유용).  
> - 이벤트는 `dispatch('click', e)` 형태로 **표면을 단순화**.  
> - 슬롯으로 **아이콘/텍스트** 구조를 확장 가능.

---

### 6.1.3 입력 컴포넌트: `bind:value` 지원 + `change/input` 이벤트

```svelte
<!-- src/lib/components/form/TextField.svelte -->
<script lang="ts">
  import { createEventDispatcher } from 'svelte';

  export let value = '';
  export let label = '';
  export let id = crypto.randomUUID();
  export let placeholder = '';
  export let disabled = false;
  export let required = false;

  // 컴포넌트 바인딩을 위해 value prop + change 이벤트를 함께 제공
  const dispatch = createEventDispatcher<{ change: string, input: string }>();

  function onInput(e: Event) {
    const v = (e.currentTarget as HTMLInputElement).value;
    value = v;                    // 내부 상태 갱신
    dispatch('input', v);         // input 이벤트
    dispatch('change', v);        // 바인딩 대응
  }
</script>

<label for={id} class="label">{label}</label>
<input
  id={id}
  class="textfield"
  {placeholder}
  {required}
  {disabled}
  value={value}
  on:input={onInput}
/>

<style>
  .label { display:block; font-weight:600; margin-bottom:.25rem; }
  .textfield { width:100%; border:1px solid var(--border); border-radius:10px; padding:.5rem .7rem; }
</style>
```

부모에서 **컴포넌트 바인딩**:

```svelte
<script>
  import TextField from '$lib/components/form/TextField.svelte';
  let name = '';
</script>

<TextField bind:value={name} label="Name" placeholder="Your name" />
<p>Hi, {name || '...'}</p>
```

> 바인딩을 지원하려면 “prop + 같은 이름의 change 이벤트”를 내보내는 패턴이 직관적이다. (또는 Svelte 5 Runes에서는 `$state`를 노출하는 컴포지션도 가능하나, 컴포넌트 외부 API로는 이벤트 기반이 안전하다.)

---

### 6.1.4 슬롯 props — 내부 상태 일부를 필요시에만 노출

```svelte
<!-- src/lib/components/data/Table.svelte -->
<script lang="ts">
  export let rows: any[] = [];
  export let empty = 'No data';
</script>

<table class="tbl">
  <thead><slot name="head" /></thead>
  <tbody>
    {#if rows.length === 0}
      <tr><td colspan="100%">{empty}</td></tr>
    {:else}
      {#each rows as row, i}
        <slot name="row" {row} {i}>
          <!-- 기본 렌더 -->
          <tr><td>{JSON.stringify(row)}</td></tr>
        </slot>
      {/each}
    {/if}
  </tbody>
</table>

<style>
  .tbl { width:100%; border-collapse: collapse; }
  td, th { border:1px solid var(--border); padding:.5rem; }
</style>
```

사용:

```svelte
<script>
  import Table from '$lib/components/data/Table.svelte';
  const users = [{id:1,name:'Ada'},{id:2,name:'Linus'}];
</script>

<Table {rows}= {users} empty="사용자가 없습니다">
  <svelte:fragment slot="head">
    <tr><th>ID</th><th>Name</th></tr>
  </svelte:fragment>

  <svelte:fragment slot="row" let:row>
    <tr><td>{row.id}</td><td>{row.name}</td></tr>
  </svelte:fragment>
</Table>
```

> **기본 동작**을 제공하면서, 필요 시 슬롯으로 **완전 커스터마이즈** 가능하게 한다.

---

## 6.2 컨텍스트 API — 트리 깊숙이 **의존성 주입**

### 6.2.1 기본 개념

- `setContext(key, value)` : **조상** 컴포넌트에서 컨텍스트 값을 설정  
- `getContext(key)` : **하위(후손)** 컴포넌트에서 컨텍스트를 가져옴  
- key는 **Symbol**을 권장(이름 충돌 방지)  
- **SSR 요청 단위**로 스코프되므로 서버 메모리 누수 우려가 낮다.

### 6.2.2 메뉴/선택 그룹 설계 (액션과 섞지 말고 **컨텍스트**로 연결)

**컨테이너(Menu)**가 상태를 소유하고, **Item**은 컨텍스트로 제어 함수를 받아 선택을 보고한다.

```ts
// src/lib/context/menu.ts
export type MenuCtx = {
  register: (id: string) => void;
  select: (id: string) => void;
  isSelected: (id: string) => boolean;
};
export const MENU_CTX = Symbol('menu');
```

```svelte
<!-- src/lib/components/menu/Menu.svelte -->
<script lang="ts">
  import { setContext } from 'svelte';
  import { MENU_CTX, type MenuCtx } from '$lib/context/menu';

  export let value: string | null = null;
  let ids = new Set<string>();

  function register(id: string) { ids.add(id); }
  function select(id: string) { value = id; }
  function isSelected(id: string) { return value === id; }

  const ctx: MenuCtx = { register, select, isSelected };
  setContext(MENU_CTX, ctx);
</script>

<div class="menu" role="listbox" aria-activedescendant={value ?? undefined}>
  <slot />
</div>

<style>
  .menu { display:grid; gap:.25rem; }
</style>
```

```svelte
<!-- src/lib/components/menu/Item.svelte -->
<script lang="ts">
  import { getContext, onMount } from 'svelte';
  import { MENU_CTX, type MenuCtx } from '$lib/context/menu';

  export let id: string;
  export let as: 'button' | 'div' = 'button';

  const ctx = getContext<MenuCtx>(MENU_CTX);

  onMount(() => ctx.register(id));
  $: selected = ctx.isSelected(id);

  function pick() { ctx.select(id); }
</script>

<svelte:element
  this={as}
  role="option"
  aria-selected={selected}
  class:selected
  on:click={pick}
>
  <slot />
</svelte:element>

<style>
  .selected { background:#0ea5e9; color:#fff; border-radius:10px; }
</style>
```

사용:

```svelte
<script>
  import Menu from '$lib/components/menu/Menu.svelte';
  import Item from '$lib/components/menu/Item.svelte';
  let current = 'b';
</script>

<Menu bind:value={current}>
  <Item id="a">Alpha</Item>
  <Item id="b">Bravo</Item>
  <Item id="c">Charlie</Item>
</Menu>

<p>Selected: {current}</p>
```

> 장점  
> - 형제/손자 컴포넌트 간 **프롭 드릴링 없이** 상태 공유.  
> - 컴포넌트 API는 **간단**(부모는 `bind:value`만), 내부는 **컨텍스트**로 정돈.  
> - 시맨틱/접근성 역할(`listbox/option`)도 한 곳에서 정의.

---

### 6.2.3 Form 컨텍스트: 폼 바인딩/에러 수집

```ts
// src/lib/context/form.ts
export type FormCtx = {
  register: (name: string) => void;
  setError: (name: string, message: string | null) => void;
  errors: Record<string, string | null>;
  values: Record<string, any>;
};
export const FORM = Symbol('form');
```

```svelte
<!-- src/lib/components/form/Form.svelte -->
<script lang="ts">
  import { setContext } from 'svelte';
  import { FORM, type FormCtx } from '$lib/context/form';

  export let onSubmit: (data: Record<string, any>) => void;

  const ctx: FormCtx = {
    errors: {},
    values: {},
    register(name) { ctx.values[name] ??= ''; },
    setError(name, message) { ctx.errors[name] = message; }
  };
  setContext(FORM, ctx);

  function submit(e) {
    e.preventDefault();
    onSubmit(structuredClone(ctx.values));
  }
</script>

<form on:submit={submit}>
  <slot />
  <div class="errors">
    {#each Object.entries(ctx.errors) as [k, v] (k)}
      {#if v}<p style="color:#b00020">{k}: {v}</p>{/if}
    {/each}
  </div>
</form>
```

```svelte
<!-- src/lib/components/form/Field.svelte -->
<script lang="ts">
  import { getContext } from 'svelte';
  import { FORM, type FormCtx } from '$lib/context/form';

  export let name: string;
  export let label = name;
  export let required = false;

  const form = getContext<FormCtx>(FORM);
  form.register(name);

  function input(e) {
    form.values[name] = e.currentTarget.value;
    if (required) form.setError(name, form.values[name] ? null : '필수입니다');
  }
</script>

<label>
  <span>{label}</span>
  <input name={name} value={form.values[name]} on:input={input} aria-invalid={!!form.errors[name]} />
</label>
```

사용:

```svelte
<script>
  import Form from '$lib/components/form/Form.svelte';
  import Field from '$lib/components/form/Field.svelte';

  const submit = (data) => alert(JSON.stringify(data, null, 2));
</script>

<Form {submit} onSubmit={submit}>
  <Field name="email" required />
  <Field name="name" />
  <button type="submit">Submit</button>
</Form>
```

> 컨텍스트는 폼처럼 **분산된 입력**을 **한 곳에서 수집/검증**하기에 적합.

---

## 6.3 컨테이너–프리젠테이션 패턴

> **컨테이너(Container)**: 데이터 로딩/상태/행동을 소유(스토어/URL/네트워크).  
> **프리젠테이션(Presentational)**: 순수 UI, props로만 입력 받아 렌더.

장점:  
- 변경 이유 분리(SOLID의 SRP)  
- 테스트/스토리 작성이 쉬움(프리젠테이션은 **순수 함수**처럼)  
- 재사용 가능(컨테이너 교체로 다양한 데이터 소스 대응)

### 6.3.1 목록 페이지 예시

**프리젠테이션**:

```svelte
<!-- src/lib/components/products/ProductGrid.svelte -->
<script lang="ts">
  export type Product = { id: string; name: string; price: number };
  export let items: Product[] = [];
  export let loading = false;
  export let onSelect: (p: Product) => void;
</script>

{#if loading}
  <p>Loading…</p>
{:else if items.length === 0}
  <p>No products</p>
{:else}
  <div class="grid">
    {#each items as p (p.id)}
      <article class="card" on:click={() => onSelect?.(p)}>
        <h3>{p.name}</h3>
        <p>${p.price}</p>
      </article>
    {/each}
  </div>
{/if}

<style>
  .grid { display:grid; grid-template-columns: repeat(auto-fill,minmax(160px,1fr)); gap:12px; }
  .card { border:1px solid var(--border); border-radius:12px; padding:.75rem; cursor:pointer; }
</style>
```

**컨테이너**(SvelteKit 라우트):

```svelte
<!-- src/routes/products/+page.svelte -->
<script lang="ts">
  import ProductGrid from '$lib/components/products/ProductGrid.svelte';
  import { onMount } from 'svelte';

  let items = [];
  let loading = true;

  onMount(async () => {
    const res = await fetch('/api/products');
    items = await res.json();
    loading = false;
  });

  function select(p) { console.log('select', p); }
</script>

<ProductGrid {items} {loading} onSelect={select} />
```

> 나중에 데이터 소스를 **스토어/GraphQL/IndexedDB** 등으로 바꾸어도 그리드는 건드릴 필요가 없다.

---

### 6.3.2 컨테이너에서 **URL 동기화**까지 담당

```svelte
<!-- src/routes/products/+page.svelte -->
<script lang="ts">
  import ProductGrid from '$lib/components/products/ProductGrid.svelte';
  import { page } from '$app/stores';
  import { goto } from '$app/navigation';
  import { onDestroy } from 'svelte';

  let search = $page.url.searchParams.get('q') ?? '';
  let items = [];
  let loading = false;

  async function load() {
    loading = true;
    const res = await fetch('/api/products?q=' + encodeURIComponent(search));
    items = await res.json();
    loading = false;
  }

  // URL 변경 → 로컬 상태 갱신(뒤/앞으로가기 대응)
  const un = page.subscribe(($p) => {
    const q = $p.url.searchParams.get('q') ?? '';
    if (q !== search) { search = q; load(); }
  });
  onDestroy(un);

  function apply() {
    const url = new URL($page.url);
    if (search) url.searchParams.set('q', search); else url.searchParams.delete('q');
    goto(url, { replaceState: true });
  }

  $: load(); // 최초 로드 및 search 변경 시
</script>

<input bind:value={search} placeholder="Search…" />
<button on:click={apply}>Apply</button>

<ProductGrid {items} {loading} onSelect={(p)=>console.log(p)} />
```

> 컨테이너는 **라우팅/상태/네트워크**를 책임지고, 프리젠테이션은 **UI**만.

---

## 6.4 재사용 가능한 **액션** / **유틸** / **스토어** 모듈화

### 6.4.1 액션 라이브러리 폴더링

```
src/lib/actions/
  autofocus.ts
  clickOutside.ts
  intersect.ts
  longpress.ts
```

**`clickOutside`**:

```ts
// src/lib/actions/clickOutside.ts
export function clickOutside(node: HTMLElement, handler: (e: MouseEvent) => void) {
  const onDoc = (e: MouseEvent) => !node.contains(e.target as Node) && handler(e);
  document.addEventListener('mousedown', onDoc);
  return { destroy: () => document.removeEventListener('mousedown', onDoc) };
}
```

**`longpress`**:

```ts
// src/lib/actions/longpress.ts
export function longpress(node: HTMLElement, ms = 500) {
  let t: number | null = null;

  const start = () => {
    t = window.setTimeout(() => {
      node.dispatchEvent(new CustomEvent('longpress'));
    }, ms);
  };
  const clear = () => t && (clearTimeout(t), (t = null));

  node.addEventListener('pointerdown', start);
  node.addEventListener('pointerup', clear);
  node.addEventListener('pointerleave', clear);

  return {
    update(newMs: number) { ms = newMs; },
    destroy() {
      clear();
      node.removeEventListener('pointerdown', start);
      node.removeEventListener('pointerup', clear);
      node.removeEventListener('pointerleave', clear);
    }
  };
}
```

사용:

```svelte
<script>
  import { clickOutside } from '$lib/actions/clickOutside';
  import { longpress } from '$lib/actions/longpress';
  let open = true;
</script>

<div class="panel" use:clickOutside={() => open = false}>
  <button use:longpress on:longpress={() => alert('Hold!')}>Hold me</button>
</div>
```

> 액션은 **DOM 동작을 캡슐화**하므로, 컴포넌트/페이지 어디서나 바로 재사용할 수 있다.

---

### 6.4.2 유틸 모듈: fetcher/format/query

```ts
// src/lib/utils/fetcher.ts
export async function getJSON<T>(input: RequestInfo, init?: RequestInit) {
  const res = await fetch(input, init);
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
  return res.json() as Promise<T>;
}
```

```ts
// src/lib/utils/format.ts
export const money = (n: number, currency = 'USD') =>
  new Intl.NumberFormat(undefined, { style: 'currency', currency }).format(n);
```

```ts
// src/lib/utils/query.ts
export function setQuery(url: URL, dict: Record<string, string | number | null | undefined>) {
  for (const [k, v] of Object.entries(dict)) {
    if (v == null || v === '') url.searchParams.delete(k);
    else url.searchParams.set(k, String(v));
  }
}
```

> **유틸**은 테스트가 쉬우며, 컨테이너에서 주입해 사용하면 API 의존성을 한 곳에 묶을 수 있다.

---

### 6.4.3 스토어 모듈: 도메인별 API 캡슐화

```ts
// src/lib/stores/cart.ts
import { writable, derived } from 'svelte/store';

type Item = { id: string; name: string; price: number; qty: number };

function createCart() {
  const { subscribe, update, set } = writable<Item[]>([]);

  return {
    subscribe,
    add(p: Omit<Item, 'qty'>, qty = 1) {
      update((xs) => {
        const i = xs.findIndex((it) => it.id === p.id);
        if (i >= 0) {
          const next = xs.slice();
          next[i] = { ...next[i], qty: next[i].qty + qty };
          return next;
        }
        return [...xs, { ...p, qty }];
      });
    },
    remove(id: string) { update((xs) => xs.filter((x) => x.id !== id)); },
    clear() { set([]); }
  };
}

export const cart = createCart();
export const total = derived(cart, ($c) =>
  $c.reduce((s, i) => s + i.price * i.qty, 0)
);
```

사용:

```svelte
<script>
  import { cart, total } from '$lib/stores/cart';
  const add = () => cart.add({ id: 'b1', name:'Book', price:12 });
</script>

<button on:click={add}>Add</button>
<p>Total: {$total}</p>
```

> 스토어는 전역/공유 상태를 담당하고, **컴포넌트는 얇게** 유지한다.

---

## 6.5 안정성·접근성·테스트 전략

1) **접근성 우선**  
   - 역할/레이블/키보드 내비게이션을 컴포넌트에서 **디폴트 제공**  
   - `aria-*`/`role`을 **`$$restProps`**로 덮어쓸 수 있게 한다.

2) **타이핑/문서화**  
   - `export let`에 **타입·기본값·JSDoc**을 남긴다.  
   - 이벤트의 **detail 타입**도 제네릭으로 명시.

3) **불변 데이터 전달**  
   - 프리젠테이션 컴포넌트에는 **불변 props**를 전달(참조 이슈 최소화).

4) **변경 이유 분리**  
   - 컨테이너는 라우팅/데이터/스토어, 프리젠테이션은 렌더링만.

5) **테스트**  
   - 프리젠테이션은 **@testing-library/svelte**로 접근성 쿼리(`getByRole`, `getByLabelText`) 중심 테스트.  
   - 도메인 스토어/유틸은 **Vitest**로 단위 테스트.

---

## 6.6 안티 패턴 & 개선

- **모든 상태를 상위에서 props로 내리는 경우(Prop Drilling)**  
  → 컨텍스트/스토어로 **소유자**를 명확히 하자.

- **컴포넌트가 네트워크와 DOM을 동시에 다루는 경우**  
  → **컨테이너–프리젠테이션**으로 분리. 효과는 onMount/액션으로.

- **이벤트 detail에 거대한 객체 전달**  
  → 필요한 최소 정보만 전달, 나머지는 컨테이너가 **서비스/스토어**로 조회.

- **전역 스타일 과도/`:global` 남용**  
  → 스코프 CSS 유지, 전역은 토큰/유틸 클래스만.

---

## 6.7 종합 예제 — “필터 가능한 제품 리스트”

요구사항  
- 카테고리/검색/정렬 상태는 **컨테이너**가 소유 + **URL**에 동기화  
- 그리드는 **프리젠테이션**  
- **TextField/Button/Table** 재사용  
- **clickOutside** 액션으로 드롭다운 닫기

**프리젠테이션 – FilterBar**:

```svelte
<!-- src/lib/components/products/FilterBar.svelte -->
<script lang="ts">
  export let q = '';
  export let category: string | null = null;
  export let sort: 'recent'|'price'|'name' = 'recent';

  export let onChange: (next: { q: string; category: string | null; sort: typeof sort }) => void;

  let open = false;
  function emit() { onChange?.({ q, category, sort }); }
</script>

<div class="bar">
  <input class="search" placeholder="Search…" bind:value={q} on:change={emit} />
  <select bind:value={sort} on:change={emit}>
    <option value="recent">Recent</option>
    <option value="price">Price</option>
    <option value="name">Name</option>
  </select>
  <div class="dropdown">
    <button on:click={() => (open = !open)}>Category</button>
    {#if open}
      <ul class="menu">
        <li on:click={() => (category=null, open=false, emit())}>All</li>
        <li on:click={() => (category='book', open=false, emit())}>Book</li>
        <li on:click={() => (category='tool', open=false, emit())}>Tool</li>
      </ul>
    {/if}
  </div>
</div>

<style>
  .bar { display:flex; gap:.5rem; align-items:center; }
  .search { flex:1; }
  .dropdown { position:relative; }
  .menu { position:absolute; top:100%; left:0; background:#fff; border:1px solid var(--border); border-radius:10px; padding:.2rem; }
  .menu>li { padding:.35rem .6rem; cursor:pointer; }
  .menu>li:hover { background:#f8fafc; }
</style>
```

**프리젠테이션 – Grid**: (앞의 `ProductGrid.svelte` 재사용)

**컨테이너 – 페이지**:

```svelte
<!-- src/routes/catalog/+page.svelte -->
<script lang="ts">
  import FilterBar from '$lib/components/products/FilterBar.svelte';
  import ProductGrid from '$lib/components/products/ProductGrid.svelte';
  import { page } from '$app/stores';
  import { goto } from '$app/navigation';
  import { onMount, onDestroy } from 'svelte';

  let q = $page.url.searchParams.get('q') ?? '';
  let category = $page.url.searchParams.get('cat');
  let sort = ($page.url.searchParams.get('sort') ?? 'recent') as 'recent'|'price'|'name';

  let items = []; let loading = false;

  function syncURL() {
    const url = new URL($page.url);
    const set = (k: string, v?: string | null) => v ? url.searchParams.set(k, v) : url.searchParams.delete(k);
    set('q', q || null);
    set('cat', category || null);
    set('sort', sort);
    goto(url, { replaceState: true, keepfocus: true, noscroll: true });
  }

  async function load() {
    loading = true;
    const url = `/api/products?q=${encodeURIComponent(q)}&sort=${sort}${category?`&cat=${category}`:''}`;
    const res = await fetch(url);
    items = await res.json();
    loading = false;
  }

  // URL → 상태
  const un = page.subscribe(($p) => {
    const Q = $p.url.searchParams.get('q') ?? '';
    const C = $p.url.searchParams.get('cat');
    const S = ($p.url.searchParams.get('sort') ?? 'recent') as typeof sort;
    if (Q !== q || C !== category || S !== sort) {
      q = Q; category = C; sort = S; load();
    }
  });
  onDestroy(un);

  // 최초 로드
  onMount(load);

  function onChange(next) {
    q = next.q; category = next.category; sort = next.sort;
    syncURL();          // URL을 진실원천으로
    load();             // 데이터 새로 불러오기
  }

  function onSelect(p) { console.log('select', p); }
</script>

<FilterBar {q} {category} {sort} {onChange} />

<ProductGrid {items} {loading} onSelect={onSelect} />
```

> 결과: 컨테이너는 **URL 동기화 + 네트워크**를 책임지고, 두 프리젠테이션 컴포넌트는 **입력/출력**만 다룬다.

---

## 6.8 마무리 요약

- **Props/이벤트/슬롯**은 컴포넌트의 공개 계약(Contract) — **간결·일관**하게.
- **컨텍스트 API**로 트리 깊은 협업을 해결, **Symbol 키**와 타입으로 안전성 확보.
- **컨테이너–프리젠테이션**으로 데이터/표현 분리 → 테스트·재사용·확장성 ↑.
- **액션/유틸/스토어**는 폴더로 모듈화해 어디서든 가져다 쓰기.
- 접근성/타이핑/문서화를 **초기부터 내장**해 팀 품질을 올린다.