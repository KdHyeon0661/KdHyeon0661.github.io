---
layout: post
title: DB - 정규화
date: 2025-02-07 19:20:23 +0900
category: DB
---
# 정규화와 성능의 관계

## 0. 성능과 정규화: 핵심 원칙 요약

- 정규화는 **데이터 이상 제거**·**무결성 보장**을 위한 논리적 토대이다.
- 성능은 **쿼리 패턴**과 **물리 설계(인덱스/파티션/캐시)**가 좌우한다.
- **정규화를 먼저 수행**하고, **실측된 병목**에서만 **선택적 반정규화**를 고려한다.
- 반정규화는 항상 **정합성 유지 메커니즘(프로시저/트리거/CDC)**과 **검증·수선 루틴**을 동반해야 한다.

---

## 1. 정규화가 성능에 미치는 영향: 근사 비용 모델

정규화가 높을수록 조인이 늘 수 있다. 조인 비용의 근사:

$$
C_{\text{join}} \approx C_{\text{scan}}(R) + C_{\text{scan}}(S) + C_{\text{probe}}(R \bowtie S)
$$

- 해시 조인(OLAP):
  $$C_{\text{build}}=O(|R|),\quad C_{\text{probe}}=O(|S|)$$
- 인덱스 중첩 루프(OLTP):
  $$C \approx |R|\cdot \log|S|,$$
  특히 **커버링 인덱스**면 테이블 접근을 피하여 \(C\) 감소.

정규화로 **행 크기 축소**와 **중복 제거**로 인해 **캐시 적중률↑, I/O↓**가 되기도 한다. 반대로 조인이 과도해지면 **랜덤 I/O↑**.
결론: **조인 수**와 **조인 키에 대한 인덱스 품질**이 관건이다.

---

## 2. 1NF ~ 5NF: 이론 → 실무 → 성능

아래는 각 정규형을 “정의→이상 제거→성능 영향→실무 예제(DDL/SQL)”로 구성한 참조 섹션이다.

### 2.1 제1정규형(1NF) — 원자값 보장

**정의**: 모든 속성은 원자값(Atomic)이어야 하며 반복/다중 값 금지.

**제거되는 이상**
- “전화번호1, 전화번호2” 같은 반복 속성 → 삽입/수정/삭제 이상 제거.

**성능 영향**
- 한 열에 콤마-구분 다중값을 저장하면 **인덱스 비효율**·스캔 증가.
- 별도 테이블 분리로 행 수가 늘 수 있으나, **정확한 조인 + 인덱스**면 쿼리 최적화가 쉬워진다.

**예제(정규화 전→후)**

```sql
-- 비정규: 다중 전화번호를 한 열로
CREATE TABLE customer_bad (
  customer_id BIGINT PRIMARY KEY,
  name        TEXT NOT NULL,
  phones      TEXT  -- '010-1,010-2' 같은 CSV
);

-- 1NF 정규화: 별도 테이블로 분리
CREATE TABLE customer (
  customer_id BIGINT PRIMARY KEY,
  name        TEXT NOT NULL
);

CREATE TABLE customer_phone (
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id),
  phone       TEXT NOT NULL,
  PRIMARY KEY (customer_id, phone)
);

-- 조회 패턴 개선: 커버링 인덱스
CREATE INDEX idx_cust_phone ON customer_phone(customer_id, phone);
```

**검증 쿼리(원자성 위반 탐지)**

```sql
SELECT customer_id
FROM customer_bad
WHERE phones LIKE '%,%'; -- 다중값 흔적
```

---

### 2.2 제2정규형(2NF) — 부분 함수 종속 제거

**정의**: 1NF + **복합키의 부분집합**에 종속되는 속성 제거.

**제거되는 이상**
- 복합키 (주문ID, 상품ID) 테이블에 `상품명` 같은 열이 있으면 상품명 변경 시 **중복 수정** 필요.

**성능 영향**
- 상품 속성을 **차원 테이블로 분리**하면 조인 1회 증가.
- 그러나 차원 테이블은 **작고 안정적**이므로, **인메모리 캐싱/커버링 인덱스**로 조인 비용 완화 가능.

**예제**

```sql
-- 비정규
CREATE TABLE order_item_bad (
  order_id   BIGINT,
  product_id BIGINT,
  product_name TEXT,   -- 부분 종속
  qty        INT,
  PRIMARY KEY(order_id, product_id)
);

-- 2NF 정규화
CREATE TABLE product (
  product_id BIGINT PRIMARY KEY,
  name       TEXT NOT NULL
);

CREATE TABLE order_item (
  order_id   BIGINT,
  product_id BIGINT,
  qty        INT NOT NULL,
  PRIMARY KEY(order_id, product_id),
  FOREIGN KEY(product_id) REFERENCES product(product_id)
);

-- 조회 최적화 인덱스
CREATE INDEX idx_oi_ord ON order_item(order_id, product_id);
CREATE INDEX idx_product_name ON product(product_id, name);
```

---

### 2.3 제3정규형(3NF) — 이행 종속 제거

**정의**: 2NF + **A→B→C** 형태의 이행적 종속 제거(비주요 속성은 오직 키에만 종속).

**제거되는 이상**
- `사원(사원ID, 부서ID, 부서명)`에서 부서명은 부서ID에 종속 → 중복 업데이트 위험.

**성능 영향**
- 부서명 조회 시 조인 1회 증가.
- **읽기 많은 UI**에서 “부서명 스냅샷” 반정규화를 **선택적으로** 적용 가능(동기화 설계 필수).

**예제**

```sql
CREATE TABLE dept (
  dept_id  TEXT PRIMARY KEY,
  dept_name TEXT NOT NULL
);
CREATE TABLE employee (
  emp_id BIGINT PRIMARY KEY,
  dept_id TEXT NOT NULL REFERENCES dept(dept_id)
);
-- 부서명 조회
SELECT e.emp_id, d.dept_name
FROM employee e
JOIN dept d USING (dept_id);
```

---

### 2.4 BCNF — 모든 결정자가 후보키

**정의**: 3NF보다 엄격. **결정자 → 항상 후보키**.

**실무 포인트**
- 시간표/자원 배정 같은 **복합 결정자** 도메인에서 드물게 위배.
- BCNF 변환은 종종 **추가 테이블 분해**를 유발하여 조인 증가 → **핵심 쿼리 기준**으로 적용.

**간이 예제 스케치**

```sql
-- (강의실, 시간) → 교수, 교수 → 강의실  같은 복잡한 결정자 관계
-- 케이스에 따라 테이블을 두어로 분해하여 결정자를 후보키로 만들도록 설계
```

---

### 2.5 제4정규형(4NF) — 다치 종속 제거

**정의**: 한 키에 독립적인 다치 속성이 2개 이상이면 **분리**.

**실무 포인트**
- 콘텐츠 메타(배우 목록·언어 목록 등)에서 흔함.
- 분리하면 **교차 곱 중복** 제거, 저장공간·갱신 이상 감소.

**예제**

```sql
-- 학생-자격증, 학생-취미를 분리
CREATE TABLE student_license (
  student_id BIGINT,
  license    TEXT,
  PRIMARY KEY(student_id, license)
);
CREATE TABLE student_hobby (
  student_id BIGINT,
  hobby      TEXT,
  PRIMARY KEY(student_id, hobby)
);
```

---

### 2.6 제5정규형(5NF) — 조인 종속 제거(손실 없는 분해)

**정의**: 다자간(N-way) 관계를 **손실 없이** 더 작은 관계로 분해 가능해야 함.

**실무 포인트**
- 3자 이상 매칭(프로젝트·부서·직원 배정) 같은 고급 모델에서 등장.
- 이론적으로 중요하나 **실무에서는 3NF/BCNF + 제약/프로시저**로 관리하는 경우가 많다.

---

## 3. 정규화 수준과 성능의 실제: 패턴과 튜닝

정규화를 유지하면서 성능을 확보하는 기본 도구:

### 3.1 조인 키 인덱스 & 커버링 인덱스

```sql
-- 외래키 조인 키 인덱스
CREATE INDEX idx_order_customer ON "order"(customer_id);

-- 커버링(읽기 전용 경로)
CREATE INDEX idx_order_list ON "order"(customer_id, status, ordered_at DESC);
```

### 3.2 파티셔닝(시간/범위/해시)

```sql
-- PostgreSQL: 날짜 파티션
CREATE TABLE event (
  id BIGSERIAL PRIMARY KEY,
  occurred_at timestamptz NOT NULL,
  payload jsonb NOT NULL
) PARTITION BY RANGE (occurred_at);

CREATE TABLE event_2025_11 PARTITION OF event
  FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
```

### 3.3 물질화 뷰·요약 테이블(OLAP on OLTP 최소화)

```sql
-- 물질화 뷰
CREATE MATERIALIZED VIEW daily_sales AS
SELECT order_date::date d, SUM(amount) AS revenue
FROM fact_order
GROUP BY 1;

REFRESH MATERIALIZED VIEW CONCURRENTLY daily_sales;
```

### 3.4 CQRS: 쓰기(정규화)·읽기(전용 스냅샷) 분리

```sql
-- 읽기 모델(전용)
CREATE TABLE customer_read_model (
  customer_id BIGINT PRIMARY KEY,
  last30_revenue NUMERIC(18,2) NOT NULL,
  updated_at timestamptz NOT NULL DEFAULT now()
);
```

---

## 4. “정규화 → 성능 병목 → 선택적 반정규화”의 판단 근거

정규화 모델에서 병목이 확인될 때, **선택적 반정규화**를 고려한다. 기대 이득의 근사:

$$
\Delta \approx \alpha \cdot C_{\text{baseline}} - \beta \cdot C_{\text{maint}}
$$

- \(\alpha\): 대상 쿼리의 트래픽/비용 비중
- \(C_{\text{baseline}}\): 기존 조인/집계 비용
- \(\beta\): 반정규화 유지 비용(쓰기 증가/동기화/락)
- \(\Delta > 0\)이면 후보. 실제는 **A/B 벤치마크로 검증**.

**반정규화 패턴(대표)**

| 패턴 | 효과 | 주의 |
|---|---|---|
| 스냅샷 컬럼(고객명 등) | 조인 제거 | 변경 동기화(프로시저/트리거/CDC) |
| 카운터 컬럼(댓글 수) | 집계 제거 | 경쟁 상태/수선 잡 |
| 요약 테이블(일/월 합) | 대시보드 고속 | 유지/검증/환불·수정 반영 |
| 1:1 병합 | I/O 감소 | 행 잠금·쓰기 비용↑ |

---

## 5. 실전 시나리오 — 커머스 “최근 30일 매출” 대시보드

### 5.1 정규화 스키마

```sql
CREATE TABLE customer (
  customer_id BIGSERIAL PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name  TEXT NOT NULL
);
CREATE TABLE "order" (
  order_id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id),
  ordered_at timestamptz NOT NULL,
  amount NUMERIC(12,2) NOT NULL CHECK (amount >= 0),
  status TEXT NOT NULL CHECK (status IN ('PENDING','PAID','CANCELLED','SHIPPED','COMPLETED'))
);
CREATE INDEX idx_order_cust_dt ON "order"(customer_id, ordered_at DESC);
```

### 5.2 베이스라인 쿼리(느림)

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT c.customer_id, SUM(o.amount) AS last30
FROM customer c
JOIN "order" o USING (customer_id)
WHERE o.ordered_at >= now() - interval '30 days'
GROUP BY c.customer_id
ORDER BY last30 DESC
LIMIT 50;
```

- 조인+집계+정렬이 모두 관여 → p95 지연 큼.

### 5.3 단계적 개선

1) **파티션(월별)** + 인덱스 → 스캔 범위 축소
2) **요약 테이블**(고객×일 매출) 도입

```sql
CREATE TABLE daily_customer_sales (
  customer_id BIGINT NOT NULL,
  d date NOT NULL,
  revenue NUMERIC(18,2) NOT NULL,
  PRIMARY KEY (customer_id, d)
);

-- 일배치(또는 CDC)
INSERT INTO daily_customer_sales(customer_id, d, revenue)
SELECT customer_id, ordered_at::date, SUM(amount)
FROM "order"
WHERE ordered_at::date = current_date - 1
GROUP BY 1,2
ON CONFLICT (customer_id, d) DO UPDATE SET revenue = EXCLUDED.revenue;

-- 대시보드 쿼리 (고속)
SELECT customer_id, SUM(revenue) AS last30
FROM daily_customer_sales
WHERE d >= current_date - 30
GROUP BY customer_id
ORDER BY last30 DESC
LIMIT 50;
```

### 5.4 정합성 검증·수선

```sql
WITH ledger AS (
  SELECT customer_id, ordered_at::date d, SUM(amount) amt
  FROM "order"
  WHERE ordered_at >= now() - interval '30 days'
  GROUP BY 1,2
)
SELECT COUNT(*) diff_rows
FROM ledger l
LEFT JOIN daily_customer_sales s
  ON s.customer_id = l.customer_id AND s.d = l.d
WHERE l.amt IS DISTINCT FROM s.revenue;
```

---

## 6. 정규형 감지/검증을 위한 도구적 SQL

### 6.1 이행 종속(3NF 위반) 징후 탐지(설계 리뷰용)

```sql
-- 동일 dept_id에 대해 dept_name 값이 여러 개면 비정상
SELECT dept_id, COUNT(DISTINCT dept_name) AS variants
FROM employee_bad
GROUP BY dept_id
HAVING COUNT(DISTINCT dept_name) > 1;
```

### 6.2 다치 종속(4NF) 후보 탐지

```sql
-- 학생-자격증, 학생-취미가 한 테이블에 있을 때 교차 곱 패턴 추정
SELECT student_id, COUNT(DISTINCT license) * COUNT(DISTINCT hobby) AS expected,
       COUNT(*) AS actual
FROM student_profile_mixed
GROUP BY student_id
HAVING COUNT(*) = COUNT(DISTINCT license) * COUNT(DISTINCT hobby);
```

---

## 7. DB 유형별 전략(요약)

| 항목 | RDBMS | 문서형 NoSQL | 인메모리(KV) |
|---|---|---|---|
| 정규화 기본 | 3NF/BCNF 권장 | 약함(도큐먼트 중복 허용) | 비정규 구조 |
| 무결성 | 강함(PK/FK/트랜잭션) | 약함(앱에서 보완) | 없음(앱/TTL) |
| 읽기 최적화 | 인덱스/파티션/뷰 | 도큐먼트 한 번에 읽기 | 키 기반 초고속 |
| 쓰기 비용 | 제약/로그로 중간 | 유연·고속 | 초고속 |
| 혼합 전략 | CQRS/요약 테이블 | RDB + 캐시 + 검색 | 보조 캐시 |

**현실적 구성**: **RDB(진실원) + 캐시(Redis) + 분석(DW/컬럼나) + 검색(ES)** 조합.

---

## 8. 마이그레이션·롤백 절차(정규화 유지 + 선택적 반정규화)

1) 대상 쿼리·테이블 선정(탑K)
2) **정규화 모델 검토** & 인덱스/파티션/쿼리 재작성
3) 실패 시 반정규화 설계(스냅샷/요약/병합)
4) **DDL → 백필 → 동기화(프로시저/트리거/CDC) → 읽기 전환(플래그)**
5) 검증 뷰/수선 잡/알람 구축
6) 회귀 시 플래그 롤백, 동기화 중단, 스키마 정리

---

## 9. 벤치마크 루틴(실전)

```sql
-- 1) 베이스라인
EXPLAIN (ANALYZE, BUFFERS)
SELECT c.customer_id, SUM(o.amount)
FROM customer c
JOIN "order" o USING (customer_id)
WHERE o.ordered_at >= now() - interval '30 days'
GROUP BY c.customer_id;

-- 2) 개선 쿼리(요약 테이블)
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, SUM(revenue)
FROM daily_customer_sales
WHERE d >= current_date - 30
GROUP BY customer_id;
```

수집 지표: 실행시간, 공유버퍼 적중률, 읽은 블록 수, 정렬/해시 메모리, 임시 디스크 사용.
CI에 **대표 쿼리 스냅샷**을 포함하여 스키마 변경 시 회귀 방지.

---

## 10. 의사결정 트리(간단 버전)

1) 정규화는 완료되었는가? → 아니오 → **먼저 정규화**
2) 병목 쿼리가 인덱스로 해결되는가? → 예 → **종결**
3) 파티션/쿼리 재작성/캐시로 해결되는가? → 예 → **종결**
4) 읽기 SLA 미달·조인 과다·집계 과다인가? → 예 → **반정규화 후보**
5) 동기화/검증/수선/롤백 계획이 준비되었는가? → 예 → **적용** / 아니오 → **보류**

---

## 11. 보너스: 수학 메모(정규화 vs 반정규화 오차·비용)

비동기 유지(최종 일관성)에서 표시 오차 기대치:

$$
\mathbb{E}[\text{error}] \propto \lambda \cdot T
$$

- \(\lambda\): 단위시간 변경 이벤트율
- \(T\): 동기화 지연
\(\Rightarrow\) 변경률이 클수록, 지연이 길수록 오차가 커지므로 **핵심 UI는 동기/부분동기** 전략.

정규화의 저장 절감 효과(중복 제거율 \(r\)):

$$
\text{space\_saved} \approx r \cdot \text{total\_bytes}
$$

반정규화의 읽기 이득(조인 제거로 발생하는 지연 감소 \(\delta\))과 쓰기 비용 증가 \(\gamma\)가 있을 때:

$$
\Delta_{\text{SLO}} \approx q_{\text{read}}\cdot \delta - q_{\text{write}}\cdot \gamma
$$

- \(q_{\text{read}}, q_{\text{write}}\): 읽기/쓰기 비중
→ 읽기 중심 시스템에서 반정규화 이득이 커지나, **\(\gamma\)**(정합성 유지 비용)가 크면 역전 가능.

---

## 12. 결론

- **정규화는 기본값**이며, 데이터 품질·유지보수성·스토리지 효율을 높인다.
- 성능 저하는 **조인 증가**가 문제일 뿐, **인덱스/파티션/캐시/요약**으로 상당 부분 해결 가능하다.
- 불가피할 때만 **선택적 반정규화**를 적용하고, 반드시 **동기화·검증·수선·모니터링·롤백** 체계를 갖춘다.
- 실무의 균형점은 **3NF±α** 수준 + **핵심 쿼리 중심의 물리 설계**다.
