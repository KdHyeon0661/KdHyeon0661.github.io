---
layout: post
title: 정보보안기사 - 네트워크 기본
date: 2025-11-06 19:25:23 +0900
category: 정보보안기사
---
# 네트워크 기본(OSI/TCP/IP, 서브넷·라우팅·NAT) — 실전 가이드 + 예제

> **목표**: OSI ↔ TCP/IP 계층 이해 → IPv4 서브넷/CIDR/VLSM 계산 → 라우팅(정적/개념적 동적) → NAT(SNAT/DNAT/PAT)까지 **원리 → 예제 → 실습** 흐름으로 정리합니다.  
> **규칙**: 코드는 ```로 감싸고, 수식은 $$로 감쌉니다. 모든 실습은 **테스트 환경**에서 수행하세요.

---

## 0. 한 페이지 요약

- **OSI 7계층** ↔ **TCP/IP 4계층** 매핑, 캡슐화/역캡슐화 흐름
- **TCP vs UDP**: 신뢰/흐름제어/혼잡제어 vs 저지연/무연결
- **IPv4 주소/마스크**: CIDR, VLSM, 요약(Summarization)
- **라우팅**: LPM(가장 긴 일치), 정적 라우트, 기본 게이트웨이, ARP, TTL
- **NAT**: SNAT(MASQUERADE), DNAT(포트포워딩), PAT(다:1), 헤어핀 NAT
- **트러블슈팅**: ping/arping/traceroute/tcpdump/mtu-mss  
- **실습**: 리눅스 라우터로 NAT 구성, Windows NAT/포워딩, iperf3로 검증

---

# 1. OSI 7계층과 TCP/IP 4계층

## 1.1 계층 개요/매핑

| OSI | 이름 | TCP/IP | 대표 프로토콜/예 |
|---|---|---|---|
| 7 | 응용 | 응용 | HTTP, DNS, SSH, TLS |
| 6 | 표현 | 응용 | TLS(암호화), JSON/ASN.1 |
| 5 | 세션 | 응용 | TLS Handshake, gRPC 세션 |
| 4 | 전송 | 전송 | **TCP**, **UDP** |
| 3 | 네트워크 | 인터넷 | **IP**, ICMP, ARP(보조) |
| 2 | 데이터링크 | 링크 | 이더넷(802.3), VLAN(802.1Q) |
| 1 | 물리 | 링크 | UTP/광, 전송속도/신호 |

> 실무에선 OSI(개념) + TCP/IP(구현)를 함께 사용합니다.

## 1.2 캡슐화(Encapsulation)

```
응용데이터 → (TCP/UDP 헤더) → (IP 헤더) → (Ethernet 헤더/트레일러)
```

- 송신: 상위 → 하위로 **헤더가 붙음**  
- 수신: 하위 → 상위로 **헤더 제거**

**PDU 명칭**: L4=Segment/Datagram, L3=Packet, L2=Frame

---

# 2. 전송계층: TCP vs UDP 핵심

## 2.1 TCP
- **3-way 핸드셰이크**(SYN → SYN/ACK → ACK)  
- **신뢰성**(재전송/순서/흐름/혼잡제어)  
- **MSS/윈도우/슬로우스타트**

## 2.2 UDP
- **무연결/비신뢰**(간단/저지연), DNS/VoIP/스트리밍에 적합  
- 필요 시 **애플리케이션 레벨** 재전송/에러제어 구현

## 2.3 MTU/MSS 관계
- 이더넷 MTU=1500일 때 IPv4(20B)+TCP(20B) → **MSS=1460**  
- PMTUD(ICMP Frag Needed) 실패 시 **블랙홀** 발생 → MSS 클램핑 필요

```bash
# 예: 리눅스에서 TCP MSS 클램핑(nftables)
sudo nft add table inet mangle
sudo nft add chain inet mangle prerouting { type filter hook prerouting priority -150; }
sudo nft add rule inet mangle prerouting tcp flags syn tcp option maxseg size set 1360
```

---

# 3. 인터넷 계층: IPv4/ICMP/ARP

## 3.1 IPv4 주소·마스크·CIDR
- 주소 예: `192.168.10.23/24` → 네트워크 마스크 `255.255.255.0`
- **CIDR 표기**: `/24`는 **상위 24비트 네트워크**, 하위 8비트 호스트

**호스트 수 공식**(IPv4)
$$
\text{UsableHosts} = 2^{(32 - \text{prefix})} - 2
$$
- 예: `/26` → $2^{(32-26)}=2^{6}=64$ → **사용가능 62**(네트워크/브로드캐스트 제외)

> /31(점대점)과 /32(루프백/단일호스트)는 예외적으로 -2를 적용하지 않습니다.

## 3.2 ARP(주소 결정)
- L3 목적지가 **같은 서브넷**이면: 대상 IP의 **MAC**이 필요 → ARP 질의  
- **다른 서브넷**이면: **게이트웨이(MAC)**로 전송

```bash
ip neigh                 # ARP 캐시
arp -n                   # 전통 명령
```

## 3.3 ICMP
- 진단(ping), PMTUD, 에러알림(Time Exceeded, Dest Unreach)  
- **ICMP 완전 차단은 비권장**(PMTUD/진단 실패)

---

# 4. 서브넷(Subnetting) — 계산/설계

## 4.1 바이너리 감각 빠르게 익히기
- 옥텟 값: `128 64 32 16 8 4 2 1`  
- 마스크 `/27` = `255.255.255.`**`224`** (마지막 옥텟 128+64+32=224)

## 4.2 네트워크/브로드캐스트/호스트 범위 구하기 (예제 1)

**문제**: `192.168.10.77/26`의 네트워크 정보?  
- `/26` → 블록 크기 = $2^{(8-6)} = 64$  
- 4번째 옥텟 범위: `0–63`, `64–127`, `128–191`, `192–255`  
- `77`는 **64–127** 블록에 속함  
- **네트워크**: `192.168.10.64`  
- **브로드캐스트**: `192.168.10.127`  
- **호스트 범위**: `192.168.10.65`–`192.168.10.126` (사용가능 62)

> 블록 크기 공식(해당 옥텟에서): $$\text{Block} = 256 - \text{maskOctet}$$

## 4.3 /24를 /26으로 4개로 나누기 (예제 2)

`192.168.10.0/24` → `/26` 4개
- 0: `192.168.10.0/26` (0–63)
- 1: `192.168.10.64/26` (64–127)
- 2: `192.168.10.128/26` (128–191)
- 3: `192.168.10.192/26` (192–255)

각각 **사용 가능 62**호스트.

## 4.4 VLSM(가변 길이 서브넷) 설계 (예제 3)

**요구**:  
- A: 50대, B: 20대, C: 10대, D: 2대  
- 기반: `10.0.0.0/24`

**큰 서브넷부터 배정**
- A(≥50) → `/26`(64개) → `10.0.0.0/26`  
- B(≥20) → `/27`(32개) → `10.0.0.64/27`  
- C(≥10) → `/28`(16개) → `10.0.0.96/28`  
- D(≥2) → `/30`(4개) → `10.0.0.112/30`  
- 잔여: `10.0.0.116/30`… 이후 여유

> **팁**: **큰 요구부터** 순서대로, 경계(블록크기) 정렬을 유지.

## 4.5 Python으로 서브넷 계산(표준 라이브러리)

```python
# subnet_calc.py
import ipaddress as ip

n = ip.ip_network("192.168.10.0/24")
subs = list(n.subnets(prefixlen_diff=2))  # /24 -> /26 네 개
for s in subs:
    print(s, "usable hosts:", s.num_addresses - 2, "first:", list(s.hosts())[0], "last:", list(s.hosts())[-1])

# 네트워크/브로드캐스트/호스트 범위 구하기
ipaddr = ip.ip_interface("192.168.10.77/26")
net = ipaddr.network
print("network:", net.network_address, "broadcast:", net.broadcast_address)
```

---

# 5. 라우팅(Routing)

## 5.1 기본 개념
- **라우팅 테이블**: 목적지 프리픽스 → 다음 홉(게이트웨이)/출구 인터페이스  
- **LPM(Longest Prefix Match)**: 가장 **긴 프리픽스(정밀)**가 우선  
- **기본 경로**: `0.0.0.0/0` (모든 미상 트래픽)

## 5.2 정적 라우팅 예제

### Linux
```bash
# 현재 테이블
ip route
# 기본 게이트웨이 설정
sudo ip route add default via 192.168.10.1
# 특정 네트워크로 정적 경로
sudo ip route add 10.20.0.0/16 via 192.168.10.254
# 삭제
sudo ip route del 10.20.0.0/16
```

### Windows
```powershell
route print
route add 10.20.0.0 mask 255.255.0.0 192.168.10.254 metric 10
route delete 10.20.0.0
```

## 5.3 ARP와 다음 홉
- 라우터는 **다음 홉 IP**의 MAC을 알아야 전송 가능 → **ARP**  
- `ip neigh`(리눅스), `arp -a`(윈도우)로 확인

## 5.4 traceroute/TTL
- TTL은 홉 지날 때마다 감소, 0되면 **Time Exceeded(ICMP)** 반환  
```bash
traceroute 8.8.8.8        # Linux/macOS
tracert 8.8.8.8           # Windows
```

## 5.5 (개념) 동적 라우팅
- **RIP**(거리벡터, hop count), **OSPF**(링크상태, cost), **BGP**(AS 경로, 정책)  
- 실습은 보통 가상 라우터(FRR/Quagga)에서 수행

---

# 6. NAT(Network Address Translation)

## 6.1 NAT 종류

- **SNAT**: 내부 → 외부 갈 때 **소스 IP** 변환(사설→공인). 리눅스에선 **MASQUERADE**(동적)  
- **DNAT(포트포워딩)**: 외부 → 내부로 **목적지 IP/포트** 변환  
- **PAT(NAPT)**: 다수 내부 호스트가 **한 공인 IP**의 **서로 다른 포트**로 동시 접속  
- **1:1 NAT**: 내부 ↔ 외부 1:1 매핑  
- **헤어핀 NAT**: 내부 클라이언트가 **공인 IP(자신의 DNAT 대상)**으로 접속 시 내부로 다시 포워딩

> NAT는 **연결 추적(conntrack)**을 통해 응답 패킷을 역변환합니다.

## 6.2 리눅스 NAT 라우터 실습(eth0=WAN, eth1=LAN)

### 6.2.1 IP 포워딩 활성화
```bash
echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward
sudo sysctl -w net.ipv4.ip_forward=1
```

### 6.2.2 nftables로 SNAT(MASQUERADE)
```bash
sudo nft add table ip nat
sudo nft add chain ip nat postrouting { type nat hook postrouting priority 100; }
# LAN에서 WAN으로 나갈 때 소스 변환
sudo nft add rule ip nat postrouting oifname "eth0" ip saddr 10.0.0.0/24 masquerade
```

### 6.2.3 DNAT(포트 포워딩: WAN:80 → 10.0.0.10:8080)
```bash
sudo nft add chain ip nat prerouting { type nat hook prerouting priority -100; }
sudo nft add rule ip nat prerouting iifname "eth0" tcp dport 80 dnat to 10.0.0.10:8080
# 방화벽(필요 시) 포워딩 허용
sudo nft add table inet filter
sudo nft add chain inet filter forward { type filter hook forward priority 0; policy drop; }
sudo nft add rule inet filter forward ct state established,related accept
sudo nft add rule inet filter forward iif "eth0" oif "eth1" tcp dport 8080 ip daddr 10.0.0.10 accept
sudo nft add rule inet filter forward iif "eth1" oif "eth0" ct state new accept
```

> **검증**: 외부에서 `curl http://<WAN_IP>/` → 내부 10.0.0.10:8080 서비스가 응답.

### 6.2.4 iptables로 동일 작업(참고)
```bash
# SNAT(MASQUERADE)
sudo iptables -t nat -A POSTROUTING -o eth0 -s 10.0.0.0/24 -j MASQUERADE
# DNAT
sudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to 10.0.0.10:8080
sudo iptables -A FORWARD -i eth0 -o eth1 -p tcp -d 10.0.0.10 --dport 8080 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
sudo iptables -A FORWARD -i eth1 -o eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT
```

## 6.3 Windows 10+/Server — PowerShell NAT

### 6.3.1 내부 스위치/서브넷을 NAT
```powershell
# 내부 인터페이스에 10.0.0.1/24 설정(예)
New-NetIPAddress -InterfaceAlias "Ethernet" -IPAddress 10.0.0.1 -PrefixLength 24
# NAT 생성
New-NetNat -Name "LabNAT" -InternalIPInterfaceAddressPrefix 10.0.0.0/24
```

### 6.3.2 포트 포워딩(DNAT)
```powershell
# 공인:80 -> 내부 10.0.0.10:8080
Add-NetNatStaticMapping -NatName "LabNAT" -Protocol TCP -ExternalIPAddress "0.0.0.0" `
  -ExternalPort 80 -InternalIPAddress "10.0.0.10" -InternalPort 8080
Get-NetNatStaticMapping -NatName "LabNAT"
```

> Windows의 **RRAS**를 사용하면 보다 복잡한 NAT/라우팅 구성이 가능합니다.

## 6.4 NAT 동작 순서(요지)
1) 내부 10.0.0.5:12345 → 외부 93.184.216.34:80 (출발)  
2) SNAT: 소스 10.0.0.5 → WAN_IP:40001 로 변환(연결추적 테이블 기록)  
3) 응답 수신: 93.184.216.34:80 → WAN_IP:40001  
4) 역변환: 대상 WAN_IP:40001 → 10.0.0.5:12345로 복원 → 내부 전달

---

# 7. 라우팅 + NAT 소규모 랩 구성

## 7.1 토폴로지

```
[Internet]
    |
  (eth0: 공인/WAN)
 [Linux Router]
  (eth1: 10.0.0.1/24)
    |
  [LAN Switch]
    |-- 10.0.0.10 (Web:8080)
    |-- 10.0.0.11 (Client)
```

## 7.2 단계별

1) **라우터**: `ip_forward=1`, SNAT(MASQUERADE) 설정  
2) **웹서버(10.0.0.10)**: `python -m http.server 8080` 또는 Nginx  
3) **DNAT**: WAN:80 → 10.0.0.10:8080  
4) **클라이언트(외부)**: `curl http://<WAN_IP>/` → 정상 페이지  
5) **LAN 클라이언트(10.0.0.11)**: 인터넷 브라우징 가능(라우터 SNAT 확인)

**검증 도구**
```bash
# 라우터에서 NAT 히트 확인
sudo nft list ruleset
# 또는 conntrack
sudo conntrack -L | head
```

---

# 8. 네트워크 트러블슈팅 핵심

## 8.1 계층별 체크리스트
1) **L1/L2**: 링크 업? 스피드/듀플렉스, VLAN 태그  
2) **L3**: IP/마스크/게이트웨이, 라우팅 테이블(LPM)  
3) **L4/응용**: 방화벽 포트, 서비스 바인드 주소(127.0.0.1? 0.0.0.0?), 프록시

## 8.2 명령 모음

```bash
# Linux
ip addr        # IP/링크 상태
ip route       # 라우팅 테이블
ip neigh       # ARP
ping -c 3 8.8.8.8
traceroute 8.8.8.8
ss -ltnp       # 리스닝 포트
tcpdump -ni any host 8.8.8.8 and icmp

# Windows
ipconfig /all
route print
arp -a
tracert 8.8.8.8
netstat -ano | find ":80"
```

## 8.3 MTU/PMTUD 문제 해결(예)
- VPN/터널 사용 시 MTU↓ → **MSS 클램핑**  
- ICMP 차단 시 PMTUD 실패 → **프래그먼트 or MSS 조정**으로 완화

```bash
# iptables 예: TCP SYN에 MSS 1360 강제
sudo iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN SYN -j TCPMSS --set-mss 1360
```

---

# 9. 요약/요약문제(퀴즈 + 정답)

## 9.1 스니펫 암기장
- `/26` → 블록 64, 사용 62  
- `/27` → 블록 32, 사용 30  
- `/30` → 블록 4, 점대점(사용 2)  
- LPM: **가장 긴 프리픽스** 우선  
- SNAT=소스 변환, DNAT=목적지 변환, PAT=다:1 포트 NAT

## 9.2 퀴즈

**Q1.** `10.1.5.200/20`의 네트워크/브로드캐스트/호스트 범위는?  
- /20 → 255.255.240.0, 블록(3번째 옥텟)=16  
- 3번째 옥텟 5는 16 블록 중 **0–15? 16–31?**  
  - /20은 앞 20비트(= 255.255.240.0) ⇒ 3번째 옥텟에서 **240** → 블록 **16**  
  - `10.1.(0|16|32|48|...)` 단위. **5**는 **0–15** 블록  
- **네트워크**: `10.1.0.0`  
- **브로드캐스트**: `10.1.15.255`  
- **호스트범위**: `10.1.0.1`–`10.1.15.254`

**Q2.** `/24`를 A:100, B:50, C:20, D:10으로 VLSM 나누기(요지)  
- A→`/25`(128), B→`/26`(64), C→`/27`(32), D→`/28`(16)

**Q3.** LPM 상황: 테이블에 `0.0.0.0/0`, `10.0.0.0/8`, `10.1.0.0/16`, `10.1.2.0/24` 있을 때 `10.1.2.77`의 다음 홉은?  
- 가장 긴 `/24` 매칭 → `10.1.2.0/24`

**Q4.** NAT 헤어핀 동작 설명  
- 내부에서 공인 IP로 접속 시 DNAT→SNAT의 순서/정책으로 같은 라우터 내에서 다시 내부 서버로 연결

---

# 10. 부록: 구성 템플릿 모음

## 10.1 Nginx 안전 기본(복습)
```nginx
ssl_protocols TLSv1.2 TLSv1.3;
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
add_header X-Content-Type-Options "nosniff";
add_header X-Frame-Options "DENY";
add_header Content-Security-Policy "default-src 'self'";
```

## 10.2 nftables 기본 정책(서버)
```bash
sudo nft add table inet filter
sudo nft add chain inet filter input { type filter hook input priority 0; policy drop; }
sudo nft add rule inet filter input ct state established,related accept
sudo nft add rule inet filter input iif lo accept
sudo nft add rule inet filter input tcp dport {22,80,443} accept
```

## 10.3 iperf3 성능/연결 테스트
```bash
# 서버
iperf3 -s
# 클라이언트
iperf3 -c <server_ip> -p 5201 -t 10
```

---

# 11. 핵심 정리

- **OSI↔TCP/IP**: 모델/구현을 함께 이해하고, PDU/캡슐화 흐름을 그릴 수 있어야 한다.  
- **서브넷**: CIDR/VLSM 계산을 **블록 크기**와 **바이너리 감각**으로 빠르게 수행한다.  
- **라우팅**: LPM, 기본 경로, ARP/다음 홉 개념을 체득한다.  
- **NAT**: SNAT/DNAT/PAT/헤어핀 시나리오를 구분하고, **nftables/PowerShell**로 구현·검증한다.  
- **트러블슈팅**: ping/traceroute/ss/tcpdump/MTU-MSS로 **계층별 진단 루틴**을 확립한다.
