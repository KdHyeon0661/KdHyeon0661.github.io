---
layout: post
title: 정보통신기사 - 오류검출 · 정정
date: 2025-08-21 18:25:23 +0900
category: 정보통신기사
---
# 오류검출·정정 : 패리티 · CRC · 블록 · 컨벌루셔널 총정리

## 큰 그림: “검출 vs 정정”, 거리, 용어

- **검출(Detection)**: 오류가 **있다/없다**만 판단(재전송/폐기). 예: **패리티**, **CRC**.
- **정정(Correction)**: 수신 측에서 **스스로 복원**. 예: **해밍(7,4)**, **컨벌루셔널+Viterbi**.
- **최소해밍거리 $d_{\min}$**: 코드워드 간 최소 비트 차이.
  - **정정 가능 오차수** $t = \left\lfloor \frac{d_{\min}-1}{2}\right\rfloor$
  - **검출 가능 오차수** $d_{\min}-1$ (정확히는 “모든 오차패턴을” 검출할 수 있는 상한)
- **코드율 $R$**: $\displaystyle R=\frac{k}{n}$ (블록부호), $\displaystyle R=\frac{k}{n}$ (컨벌루셔널; 입력 $k$, 출력 $n$ 비트/스텝)
- **BER 감소**는 보통 **대역·지연·복잡도**와 맞교환. (ARQ/Hybrid-ARQ와 조합 중요)

---

## 패리티(Parity)

### 단일 패리티(1-D Parity)

- **아이디어**: 데이터 비트들의 합(‘1’의 개수)을 **짝수/홀수**가 되게 **패리티 비트** 1개를 붙임.
- **오류 검출능력**: **홀수 개수 비트 오류**는 검출, **짝수 개수 오류**는 **놓침**. → **검출 전용**, 정정 불가.
- **예**: 데이터 7비트 `1011010`, **짝수 패리티**면 ‘1’의 개수는 4(짝수) → 패리티=0.
  전송: `1011010 0`. 수신에서 ‘1’의 개수가 **홀수**로 바뀌면(단일 비트 오류 등) 에러 감지.

### 이차원 패리티(2-D Parity, 행·열 패리티)

- 데이터 블록을 **행×열**로 배치하고 **각 행·열에 패리티**를 붙임(총 2차원).
- **검출/정정능력**: **단일 비트 오류는 위치까지 특정**하여 **1비트 정정** 가능(해당 행·열 교차점).
  여러 비트 오류는 검출은 대체로 가능하나 **정정은 제한적**.
- **예**: 3×4 블록 + (행, 열 패리티) → 총 (3+1)×(4+1) 전송. 단일 비트 오류 발생 시 해당 행/열 패리티가 깨져 교차점에서 수정.

> **시험 포인트**
> - 1D 패리티: **홀수 오류 검출, 짝수 오류 누락**.
> - 2D 패리티: **단일 비트 정정 가능**, 다중 오류는 케이스 의존.

---

## CRC(Cyclic Redundancy Check, 순환중복검사)

### 핵심 개념(곱셈·나눗셈은 **GF(2)**, 즉 XOR)

- 메시지 $M(x)$에 **r차** 생성다항식 $G(x)$를 쓰면,
  (1) **r개의 0을 덧붙여** $x^r M(x)$을 만들고
  (2) 이를 $G(x)$로 **나눠 나머지 $R(x)$**를 구함(차수 < r).
  (3) **코드워드** $T(x)=x^r M(x)+R(x)$ 를 전송.
- 수신 측은 $T(x)$를 같은 $G(x)$로 나눠 **나머지가 0**이면 **오류 없음**으로 판단.

### 작은 예제로 절차 익히기

- 메시지: `1101` ($M$), 생성다항식: $G(x)=x^3+x+1$ → **비트** `1011` (차수 $r=3$)
- **1단계**: r개 0 붙이기 → `1101 000`
- **2단계**: `1101000 ÷ 1011`의 **모듈로-2 나눗셈(=XOR 뺄셈)**
  - (머리 1이 맞으면) 해당 자리에서 **1011 XOR** → 몫 1, 아니면 0
  - 끝까지 진행한 **나머지**가 `001`
- **3단계**: **CRC = `001`**, 전송 **코드워드** = `1101 001`
- **수신 검사**: `1101001 ÷ 1011` → **나머지 000** → 통과

> **Tip(손검산)**: XOR 나눗셈은 **뺄셈=비트 XOR**. 나눗셈 창의 **최상위 비트가 1**일 때만 **XOR** 수행.

### CRC가 **무엇을** 잘 잡아내나? (생성다항식에 좌우)

- $G(x)$가
  - **$x+1$**를 인수로 가지면 **모든 홀수 개 오류** 검출.
  - 특정 길이 **버스트 오류(연속 구간)**를 **r비트 이하 전부** 검출(`r`은 차수), `r+1` 이상은 높은 확률로 검출.
  - 적절히 선택하면 **2비트(쌍) 오류 전부** 검출(조건: $G(x)$가 $x^k+1$을 나누지 않음).
- **현업**: CRC-16-CCITT(0x1021), CRC-32(802.3: 0x04C11DB7) 등 **표준 다항식**은
  **랜덤/버스트/쌍오류**에 매우 강력—**충돌확률 극저**.

### CRC의 실무 함정(시험에도 단골)

- **비트 순서(Reflected/Normal)**, **초기값(Init)**, **최종 XOR**(XORout), **입출력 반전** 설정이 **구현마다 다름**.
  → 계산기/장비 간 대조 시 **파라미터 4종**을 반드시 맞춰야 합니다.
- **프레임화**: 헤더/페이로드/CRC 필드 범위를 **정확히**. (길이 필드 포함 여부 등)
- **검출 전용**: CRC는 **정정 불가**(단, 일부 시스템은 **에러로컬라이제이션+재전송/인터리빙**으로 실효율↑).

> **시험 포인트**
> - **절차**: 붙임 0 → 나눗셈 → 나머지 부착 → 수신 시 0 확인.
> - **홀수 오류** 검출 조건: $G(x)$에 $(x+1)$ 포함.
> - **버스트 r비트 이하 100% 검출**.

---

## 선형 블록부호 (Linear Block Codes)

### 정의와 행렬 표현

- $(n,k)$ **선형 블록부호**: $k$-비트 메시지를 **$n$-비트** 코드워드로 매핑.
- **생성행렬 $G$**(크기 $k\times n$):
  $$
  \mathbf{c} = \mathbf{u}\,\mathbf{G}\quad(\text{모듈로 2})
  $$
- **패리티검사행렬 $H$**(크기 $(n-k)\times n$):
  $$
  \mathbf{H}\,\mathbf{c}^\top = \mathbf{0}\quad\Rightarrow\quad\text{수신 } \mathbf{r}:\ \mathbf{s}=\mathbf{H}\mathbf{r}^\top\ (\text{신드롬})
  $$
  $\mathbf{s}\neq 0$이면 오류 존재, 값으로 **오류 위치/패턴**을 판정.

### 해밍(7,4) — 가장 클래식한 **단일오류정정**(SEC) 코드

- **파라미터**: $n=7, k=4, R=4/7$, $d_{\min}=3$ → **1비트 정정**, **2비트 검출**.
- **자리 배치**: $[p_1, p_2, d_1, p_4, d_2, d_3, d_4]$. (패러티 위치는 1,2,4=2⁰,2¹,2²)
- **H 행렬** (열 = 비트위치의 **이진 인덱스**; LSB가 윗행):
  $$
  \mathbf{H}=\begin{bmatrix}
  1&0&1&0&1&0&1\\
  0&1&1&0&0&1&1\\
  0&0&0&1&1&1&1
  \end{bmatrix}
  $$
  → 행1은 **비트1**이 1인 열 집합(1,3,5,7), 행2는 비트2(2,3,6,7), 행3은 비트4(4,5,6,7).
- **G 행렬(체계형)**:
  $$
  \mathbf{G}=
  \begin{bmatrix}
  1&1&1&0&0&0&0\\
  1&0&0&1&1&0&0\\
  0&1&0&1&0&1&0\\
  1&1&0&1&0&0&1
  \end{bmatrix}
  $$
  (열 3,5,6,7이 **단위행렬 $I_4$** → 코드워드에서 $d_1,d_2,d_3,d_4$ 위치가 그대로 보존)

#### 인코딩/패리티식(짝수 패리티)

- $p_1 = d_1\oplus d_2\oplus d_4$  (무리 $1,3,5,7$)
- $p_2 = d_1\oplus d_3\oplus d_4$  (무리 $2,3,6,7$)
- $p_4 = d_2\oplus d_3\oplus d_4$  (무리 $4,5,6,7$)
- 코드워드: $[p_1\ p_2\ d_1\ p_4\ d_2\ d_3\ d_4]$

#### 예제 — 인코딩/단일오류 정정

- 데이터 $[d_1,d_2,d_3,d_4]=[1,0,1,1]$ →
  $p_1=1\oplus0\oplus1=0$, $p_2=1\oplus1\oplus1=1$, $p_4=0\oplus1\oplus1=0$
  **코드워드** $c=[0,1,1,0,0,1,1]$
- 수신 $r=[0,1,1,0,0,0,1]$ (6번 위치 단일 오류)
  신드롬 $\mathbf{s}=\mathbf{H}r^\top=[0,1,1]$ → **$s_1+2s_2+4s_3=6$** → **6번 비트 뒤집어 복원**.

> **시험 포인트**
> - 해밍(7,4)은 $d_{\min}=3$ → **1비트 정정, 2비트 검출**.
> - **신드롬=에러 위치**(이진) 규칙 기억: $[s_1,s_2,s_4]$에서 $s_1$이 1의 자리.

### 일반 선형 블록부호의 거리와 한계

- **해밍경계**: $\displaystyle \sum_{i=0}^{t}\binom{n}{i}\le 2^{n-k}$. (구형구 포장 관점)
- **싱글톤 경계**: $d_{\min}\le n-k+1$. (RS가 등호 달성)
- **BCH/RS**:
  - **BCH**: 2진 확장체에서 생성 → 원하는 $t$까지 정정 설계 가능.
  - **RS(n,k)**: GF($2^m$) 상에서 작동(바이트 단위 정정/버스트에 강함), $d_{\min}=n-k+1$.

---

## 컨벌루셔널 부호(Convolutional Codes)

### 정의

- 과거 입력들에 대한 **선형 시프트레지스터** 출력(컨볼루션처럼 동작).
- 매 스텝 입력 $k$비트 → 출력 $n$비트, **율 $R=k/n$**.
- **제약장 $K$**: 메모리 $m$에 대해 $K=m+1$.
- **생성다항식** $g_i(D)$: 출력 $i$가 입력 지연선 $[u_k,u_{k-1},\dots,u_{k-m}]$의 어떤 XOR인지 지정.

### 대표 예: $R=\tfrac{1}{2}$, $K=3$ (메모리 2), $g_0=111_2(=7_\text{oct})$, $g_1=101_2(=5_\text{oct})$

- 출력:
  $$
  v_0 = u_k\oplus u_{k-1}\oplus u_{k-2},\qquad
  v_1 = u_k\oplus u_{k-2}
  $$
- **트렐리스** 상태: $[u_{k-1},u_{k-2}]\in\{00,01,10,11\}$
  각 상태에서 입력 0/1에 대해 **다음상태/브랜치 출력**이 결정.

#### 인코딩 예

입력 `1 0 1 1` (테일 `00`로 종료) → 출력 쌍
$$(1,1),(1,0),(0,0),(0,1),(0,1),(1,1)$$  (총 12비트)

### Viterbi(비터비) 복호: 최단경로(최소거리) 탐색

- 트렐리스에서 **경로메트릭**(하드결정=해밍거리, 소프트=LLR) 누적 최소를 선택.
- **출력쌍**과 **수신쌍**의 거리로 브랜치 비용을 계산 → 백트레이스(backtrace)로 입력 비트열 추정.
- **성능(대략)**: BER $\lesssim \sum_d A_d\,Q\!\big(\sqrt{2R\gamma_b\,d}\big)$
  ($d$: 경로 자유거리 $d_\mathrm{free}$, $A_d$: 그 계수, $\gamma_b=E_b/N_0$)

### 실무 확장

- **펑처링(puncturing)**: 일부 출력 비트를 **간헐적으로 삭제**하여 **율↑**(예: 1/2 → 2/3, 3/4). 복호는 **역펑처**로 가중치 처리.
- **테일바이팅(tail-biting)**: 별도 테일 0 없이 시작/끝 상태 일치 → 지연↓, 효율↑.
- **RSC(재귀적 체계형)**: 터보코드의 구성요소.
- **재난(catastrophic) 다항식 금지**: 생성다항식들이 공약수 가지면 **유한 입력오류가 무한 출력오류**로 번짐 → 반드시 **서로 서로소**.

> **시험 포인트**
> - 표준 조합: $R=\tfrac{1}{2},K=7$ (octal $133,171$) → 전형적 Viterbi 복호.
> - **펑처링** 개념, **트렐리스**/상태 개수 $=2^{K-1}$, **자유거리**가 성능 좌우.

---

## 기술 맵: 언제 무엇을 쓰나?

- **패리티/CRC**: **검출 전용**. **ARQ(재전송)**와 결합, 프레임 무결성 체크.
  - 고신뢰 제어채널/파일 전송: **CRC-16/32** 표준 다항식.
- **해밍 등 블록부호**: **낮은 복잡도, 짧은 코드워드**에서 **1~2비트 정정** 유용.
- **컨벌루셔널+Viterbi**: **스트리밍/무선**에서 강력(FEC), **인터리빙**과 조합해 버스트에 강해짐.
- **BCH/RS**: **버스트 오류** 및 **저장/방송**(바이트 단위)에서 표준.
- **현대식**: **터보, LDPC**가 광범위 채택. (본 글 범위 밖, 참고만)

---

## 케이스 스터디

### “CRC + 컨벌루셔널 + 인터리빙” (무선 링크 표준의 정석)

1) 패킷 페이로드에 **CRC-16** → **검출**
2) 비트열을 **컨벌루셔널(1/2, $K=7$) 인코딩** → **정정 여유**
3) **인터리빙**으로 버스트 오류를 무작위화 → **Viterbi**가 잘 잡아냄
4) 복호 후 **CRC 체크**로 최종 판단. **실패** 시 **ARQ 재전송**(Hybrid-ARQ: soft-combining)

### 링크 예산과 FEC 이득

- 같은 BER 목표에서 **코딩이득**으로 **필요 $E_b/N_0$**를 수 dB 낮출 수 있음.
- 예: $R=1/2, K=7$ 컨벌루셔널+Viterbi, BER $10^{-5}$에서 **약 4–6 dB** 이득(채널/검출 방식에 따라 변동).

---

## 연습문제(해설 포함)

### Q1. 1D 짝수 패리티는 어떤 오류를 놓칠 수 있나?

**풀이**: **짝수 개 비트 오류**(2,4,…)는 검출 실패 가능.

### Q2. CRC에서 $(x+1)$이 생성다항식의 인수로 있으면 의미는?

**풀이**: 모든 **홀수개 비트 오류**를 **항상** 검출.

### Q3. 해밍(7,4)의 $d_{\min}$과 정정/검출 능력은?

**풀이**: $d_{\min}=3$. **1비트 정정**, **2비트 검출**.

### Q4. 해밍(7,4)에서 데이터 $[1,0,1,1]$의 코드워드를 작성하고, 6번 비트 오류 시 신드롬은?

**풀이**: 코드워드 $[0,1,1,0,0,1,1]$. 수신 $[0,1,1,0,0,0,1]$ → 신드롬 $[0,1,1]$ → **6번**.

### Q5. 컨벌루셔널 $R=1/2,K=3$, $g=[111,101]$의 상태 수와 트렐리스 상태는?

**풀이**: 상태 수 $=2^{K-1}=4$. 상태는 $[u_{k-1},u_{k-2}]\in\{00,01,10,11\}$.

### Q6. 컨벌루셔널 부호에서 **펑처링**의 목적은?

**풀이**: 일부 출력을 **의도적으로 생략**해 **코드율을 높이는 것**(스루풋↑). 복호 시 생략 비트는 **가중치/소실 처리**.

---

## 실전 체크리스트 (설계/시험)

- [ ] **검출 vs 정정** 요구사항부터(ARQ 여부, 지연/비용)
- [ ] **CRC 다항식/Init/XOR/반전** 파라미터 일치 확인
- [ ] **라인코딩/프레이밍** 경계에 CRC 적용 범위 명확화
- [ ] **블록부호**: $G/H$ 일관성, **신드롬 테이블** 준비
- [ ] **컨벌루셔널**: $R, K, g$ 선택(표준 세트), **상태= $2^{K-1}$** 자원 산정
- [ ] **Viterbi**: 하드/소프트, 고정점 정밀도, 버퍼/지연
- [ ] **인터리빙**: 버스트 분산 길이 vs 지연
- [ ] **코딩이득** vs **대역/지연/복잡도** 트레이드오프

---

## 부록 A — CRC 손계산 미니 가이드

### 나눗셈 규칙(모듈로-2)

1) 생성다항식 $G$의 **최상위 1**을 **피제수** 현재 창의 최상위 1에 맞춤
2) 창 1…r+1 비트를 **XOR**(뺄셈)
3) 창을 한 비트 우로 이동, 끝까지 반복
4) 남은 r비트가 **나머지**(CRC)

> **검증 팁**: 송신 코드워드를 동일 $G$로 나누면 **항상 나머지 0**.

---

## 부록 B — 해밍(7,4) 신드롬 테이블(짝수 패리티)

| 오류 위치 | 신드롬 $[s_1 s_2 s_4]$ |
|---:|:---:|
| 1 | 100 |
| 2 | 010 |
| 3 | 110 |
| 4 | 001 |
| 5 | 101 |
| 6 | 011 |
| 7 | 111 |
| 무오류 | 000 |

> $[s_1,s_2,s_4]$을 **LSB→MSB**로 해석하면 **이진 위치**가 됨.

---

## 부록 C — 컨벌루셔널 트렐리스 브랜치(예: $g=[111,101], K=3$)

현재 상태 $[a,b]=[u_{k-1},u_{k-2}]$, 입력 $u_k\in\{0,1\}$

| 현재상태 | 입력 | 다음상태 | 출력 $(v_0,v_1)$ |
|:--:|:--:|:--:|:--:|
| 00 | 0 | 00 | (0⊕0⊕0, 0⊕0)=(0,0) |
| 00 | 1 | 10 | (1⊕0⊕0, 1⊕0)=(1,1) |
| 01 | 0 | 00 | (0⊕0⊕1, 0⊕1)=(1,1) |
| 01 | 1 | 10 | (1⊕0⊕1, 1⊕1)=(0,0) |
| 10 | 0 | 01 | (0⊕1⊕0, 0⊕0)=(1,0) |
| 10 | 1 | 11 | (1⊕1⊕0, 1⊕0)=(0,1) |
| 11 | 0 | 01 | (0⊕1⊕1, 0⊕1)=(0,1) |
| 11 | 1 | 11 | (1⊕1⊕1, 1⊕1)=(1,0) |

> 이 표를 바탕으로 **Viterbi**가 브랜치 해밍거리(하드) 또는 유사도(소프트)로 경로를 선택.

---

## 요약(시험 직전 10줄)

1) **패리티**: 1D는 **홀수 오류만**, 2D는 **1비트 정정** 가능.
2) **CRC**: “붙임0→나눗셈→나머지 부착”, $(x+1)$ 포함 시 **홀수 오류 전부 검출**. **버스트 r 이하 100%**.
3) **블록부호**: $\mathbf{c}=\mathbf{uG}$, $\mathbf{s}=\mathbf{Hr}^\top$. $d_{\min}\to t=\lfloor(d_{\min}-1)/2\rfloor$.
4) **해밍(7,4)**: $d_{\min}=3$, **1비트 정정/2비트 검출**, **신드롬=오류 위치**.
5) **컨벌루셔널**: $R=k/n, K=m+1$, 트렐리스 상태 $2^{K-1}$, **Viterbi**로 복호.
6) **펑처링**: 코드율↑. **인터리빙**: 버스트 분산.
7) **코딩이득**: 필요한 $E_b/N_0$ ↓ vs 복잡도/지연 ↑.
8) **현업 조합**: **CRC + (컨벌루셔널/터보/LDPC) + 인터리빙 + ARQ**.
9) 표준 다항식/파라미터(Init/XOR/Reflected)는 **정확히 일치**시켜야 함.
10) 거리/경계(해밍/싱글톤)를 **감각적으로** 기억해두자.
