---
layout: post
title: DB 심화 - 해시 조인 사용 기준
date: 2025-11-10 19:25:23 +0900
category: DB 심화
---
# 해시 조인 완전 가이드 — BUILD 스필, 키 스큐, 사용 기준까지

## 목표
1. **BUILD 입력이 hash workarea(PGA)를 초과할 때 Oracle이 어떻게 처리하는지** 이해하기
2. **해시 키 스큐(중복/편중)**가 해시 조인 성능에 미치는 영향 파악하기
3. 실무에서 **해시 조인을 적용하는 기준과 튜닝 체계** 정립하기

## 핵심 원칙
- 해시 조인은 **"작은 BUILD를 메모리에 올리고 큰 PROBE를 한 번 스캔하는"** 대량 처리 조인 방식입니다.
- 성능의 80%는 **BUILD 크기, 키 분포, 워크에어리어(메모리)**에서 결정됩니다.
- 모든 결론은 **실측 플랜 ALLSTATS LAST + MEMSTATS + IOSTATS**로 검증해야 합니다.

---

## 실습 환경 준비

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;
ALTER SESSION SET workarea_size_policy = AUTO;
```

실습 후에는 항상 다음 명령으로 실행계획과 통계를 확인합니다:

```sql
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'
));
```

---

## 해시 조인 메커니즘 — BUILD, PROBE, WORKAREA 이해

### BUILD 단계(해시 테이블 생성)
- 옵티마이저는 두 입력 중 **상대적으로 작은 것**을 BUILD로 선택합니다.
- BUILD 입력을 읽으면서 다음과 같은 작업을 수행합니다:
  1. 조인 키로 해시값 계산
  2. 해시 버킷(bucket) 결정
  3. 동일 버킷 체인(chain)에 행 연결
- 생성된 해시 테이블은 **PGA(workarea, hash area)**에 저장됩니다.

### PROBE 단계(매칭 탐색)
- PROBE 입력(상대적으로 큰 쪽)을 **순차 스캔**하면서:
  1. 동일한 해시 함수로 버킷 계산
  2. 버킷 체인에서 실제 키 비교
  3. 매칭된 결과 출력
- 이상적인 경우 PROBE는 **딱 한 번**만 읽히게 됩니다.

### Hash Workarea(메모리)와 실행 유형
Oracle은 실행 시점에 해시 테이블이 메모리에 완전히 상주하는지 여부를 판단하여 세 가지 방식으로 동작합니다.

| 실행 유형 | 의미 | PROBE 재읽기 횟수 | TEMP I/O 발생 |
|----------|------|-------------------|---------------|
| **Optimal(원패스-최적)** | BUILD 전체가 PGA에 상주 | 0회 | 거의 없음 |
| **One-pass(하이브리드/그레이스)** | BUILD 일부가 TEMP로 스필되지만, PROBE는 파티션 단위로 1회 재읽기 | **파티션별 1회** | 있음 |
| **Multi-pass(멀티패스)** | 스필된 특정 파티션이 또 커서 **재파티셔닝** 필요 | **여러 번** | 매우 큼 |

핵심 차이점:
- **Optimal**: "PROBE 1회 스캔"
- **One-pass**: "PROBE가 파티션별 1회씩 스캔"
- **Multi-pass**: "PROBE가 **여러 번 반복 스캔**"
  → 멀티패스가 발생하면 해시 조인의 성능이 크게 저하됩니다.

---

## BUILD 입력이 Hash Area를 초과할 때 — 하이브리드/멀티패스 동작 방식

### 파티셔닝(Grace Hash Join)의 필요성
BUILD가 PGA 용량을 초과하면:
- 해시 테이블 전체를 메모리에 유지할 수 없게 됩니다.
- PROBE가 해당 테이블을 조회하려면 **"동일한 해시 함수로 묶인 작은 조각"끼리만** 다시 조인해야 합니다.
- 따라서 Oracle은 **BUILD와 PROBE를 동일한 해시 함수로 파티셔닝**하는 전략을 사용합니다.

### 하이브리드(One-pass) 처리 흐름
1. BUILD 입력 읽기 시작
2. 해시 함수 기반으로 파티션 p1, p2, ...로 분할
3. **일부 파티션은 메모리에 유지**, 초과된 파티션은 TEMP로 스필
4. PROBE를 스캔하면서 동일한 방식으로 파티션 분할
5. **메모리 BUILD 파티션**은 즉시 매칭 처리
6. 스필된 파티션의 경우:
   - BUILD 파티션을 TEMP에서 읽어 PGA에 로드
   - PROBE 파티션을 TEMP에서 읽어 매칭 처리
7. 모든 파티션 쌍 처리 후 작업 종료

**중요한 특징**
- PROBE 원본을 한 번만 읽는 것이 아니라, **스필된 파티션만큼 PROBE 파티션을 다시 읽습니다**.
- 하지만 **각 파티션은 1번만** 재읽으므로 "one-pass"로 분류됩니다.

### 멀티패스(Multi-pass) 처리 흐름
하이브리드 처리 과정에서 **특정 파티션이 또 다시 메모리 용량을 초과하면**:

1. 해당 파티션을 더 작은 단위로 재파티셔닝
2. 해당하는 PROBE 파티션도 동일하게 재분할 후 재읽기
3. 이 작업이 반복되면 PROBE가 여러 번 재스캔됩니다.

결과적으로:
- **멀티패스 = PROBE 다회 재스캔**
- 성능이 TEMP 스토리지 대역폭에 크게 의존하게 됩니다.

---

## 스필 현상을 "눈으로" 확인하는 방법

### DBMS_XPLAN의 MEMSTATS / IOSTATS 활용

```sql
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'
));
```

해시 조인 노드에서 확인할 핵심 포인트:

- **TempSpc**(TEMP 공간 사용량)
  - 0에 가까움 → Optimal 가능성 높음
  - 유의미한 크기 → One-pass 이상 발생
- **IOSTATS**에서
  - `direct path write temp`, `direct path read temp` 증가 → 실제 BUILD/PROBE 스필 발생

### V$SQL_WORKAREA(_ACTIVE) 모니터링
실행 중인 해시/소트 워크에어리어 상태를 직접 확인합니다.

```sql
SELECT sid, sql_id, operation_type, policy,
       estimated_optimal_size,
       estimated_onepass_size,
       last_memory_used,
       number_passes,
       tempseg_size
FROM   v$sql_workarea_active
ORDER  BY last_execution DESC;
```

- `number_passes = 0` → Optimal 또는 One-pass 중 "재파티셔닝 없음"
- `number_passes > 0` → Multi-pass 발생 정황
- `tempseg_size` 크게 증가 → 스필 진행 중

완료된 실행은 다음으로 확인:

```sql
SELECT sql_id, operation_type,
       optimal_executions,
       onepass_executions,
       multipasses_executions,
       last_memory_used,
       last_tempseg_size
FROM   v$sql_workarea
WHERE  sql_id = :sql_id;
```

---

## BUILD 크기 조절을 통한 스필 유도 및 제거 실습

BUILD 입력 크기를 조절하여 Optimal, One-pass, Multi-pass의 경계를 관찰합니다.

### BUILD 축소: 스필 감소 또는 제거 케이스

```sql
SELECT /*+ LEADING(d f) USE_HASH(f) NO_USE_NL(f) NO_USE_MERGE(f) */
       d.tier, COUNT(*), SUM(f.v) total_v
FROM   D_DIM d
JOIN   F_FACT f
  ON   f.k = d.k
WHERE  d.tier IN ('VIP','GOLD')
AND    f.dt >= DATE '2024-06-01'
GROUP  BY d.tier;

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS +PREDICATE'
));
```

**예상 관찰 결과**
- `HASH JOIN` 노드의 `TempSpc`가 0 또는 매우 작음
- `direct path * temp` 작업 거의 없음
- Elapsed/Buffer Gets가 상대적으로 안정적

### BUILD 확대: 스필 발생 케이스

```sql
SELECT /*+ LEADING(d f) USE_HASH(f) */
       d.tier, COUNT(*), SUM(f.v)
FROM   D_DIM d
JOIN   F_FACT f
  ON   f.k = d.k
WHERE  d.tier IN ('VIP','GOLD','SILVER','BRONZE','GEN') -- 사실상 전체
AND    f.dt >= DATE '2024-06-01'
GROUP  BY d.tier;

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'
));
```

**예상 관찰 결과**
- `TempSpc` 증가
- TEMP read/write 증가
- 이전 쿼리 대비 Elapsed/IO/Temp 사용량 체감적 증가
  → **BUILD 초과로 One-pass 이상 동작**

---

## 해시 키 중복(스큐)으로 인한 성능 저하 문제

### 스큐의 세 가지 유형

1. **PROBE 키 스큐**
   - 특정 키가 PROBE에서 과도하게 빈번하게 등장
   - 해당 버킷 체인이 길어져 **CPU 비교 비용 폭증**

2. **BUILD 키 스큐**
   - BUILD의 특정 키 집합이 비대해짐
   - BUILD 자체가 메모리에 적재되지 못해 스필 유발

3. **양쪽 스큐 + 조합 스큐**
   - 특정 키가 BUILD와 PROBE 양쪽에서 집중적으로 등장
   - 해당 파티션이 과밀해져 One-pass/Multi-pass 가능성 증가
   - 병렬 처리 시 **로드 불균형** 발생

### 스큐의 비용 구조 분석
스큐가 심해질수록 다음과 같은 문제가 발생합니다:

- 버킷이 균등하게 분할되지 않음
- 일부 버킷/파티션의 체인이 과도하게 길어짐
- "해시 비교"가 **상수 시간(O(1))**에서 **선형 시간(O(chain length))**으로 변질
- 특정 파티션만 스필/재스필되어 TEMP I/O가 집중됨
- 병렬 처리 시 해당 파티션을 담당하는 PX 서버가 **병목 지점**이 됨

즉, **해시 조인의 기본 가정인 "균등 분할"이 깨지는 순간**, 해시 조인의 장점이 사라집니다.

### 스큐 재현 쿼리

```sql
SELECT /*+ LEADING(f d) USE_HASH(d) NO_USE_NL(d) NO_USE_MERGE(d) */
       d.tier, COUNT(*) cnt, SUM(f.v) sum_v
FROM   F_FACT f
JOIN   D_DIM  d
  ON   d.k = f.k
GROUP  BY d.tier;

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS +PREDICATE'
));
```

**예상 관찰 결과**
- 해시 조인에서 Elapsed 시간 증가
- TempSpc 증가(스필 발생) 또는 스필 없이도 CPU 사용량이 높음(버킷 체인 비교 증가)

---

## 스큐 확인과 진단 방법

### 키 분포 직접 확인

```sql
SELECT k, COUNT(*) cnt
FROM   F_FACT
GROUP  BY k
ORDER  BY cnt DESC
FETCH FIRST 20 ROWS ONLY;
```

- 상위 몇 개의 키가 **전체의 대부분(예: 70%)**을 차지하면 PROBE 쪽 스큐가 심각함을 의미합니다.

### 스큐로 인한 카디널리티 추정 오류
스큐가 존재하는데 히스토그램이나 확장 통계가 없으면 CBO는 균등/독립 가정으로 잘못된 추정을 합니다.

- 조인 카디널리티 오류는 해시 조인 **빌드 크기 예측**을 틀리게 만들어
  "원패스 예상했는데 실제로는 스필" 같은 문제를 발생시킵니다.
- Oracle 19c 이후에는 **SQL Plan Directive + Dynamic Statistics**로
  **데이터 스큐 조인을 자동 보정하는 기능**이 도입되었습니다.

---

## 스큐/스필 완화 전략

### BUILD 입력 축소(가장 효과적인 방법)

1. 조인 전 필터를 최대한 적용
2. DISTINCT/집계로 BUILD 압축
3. 필요한 컬럼만 선택하여 행 길이(rowlen) 축소

```sql
WITH D_MIN AS (
  SELECT /*+ MATERIALIZE */ DISTINCT k, tier
  FROM   D_DIM
  WHERE  tier IN ('VIP','GOLD')
)
SELECT /*+ LEADING(d f) USE_HASH(f) */
       d.tier, COUNT(*), SUM(f.v)
FROM   D_MIN d
JOIN   F_FACT f ON f.k = d.k
GROUP  BY d.tier;
```

- BUILD 행 수 감소 + rowlen 축소 → **workarea 요구량 급격히 감소**
- 스필 가능성을 가장 직접적으로 제거합니다.

### BUILD/PROBE 역할 반전(SWAP_JOIN_INPUTS)
스큐가 BUILD 쪽에 집중된 경우 BUILD와 PROBE 역할을 바꾸는 것이 유리할 수 있습니다.

```sql
SELECT /*+ LEADING(d f) USE_HASH(f) SWAP_JOIN_INPUTS(f) */
       d.tier, COUNT(*), SUM(f.v)
FROM   D_DIM d
JOIN   F_FACT f ON f.k = d.k
GROUP  BY d.tier;
```

- 단, 역할 반전 시 PROBE가 BUILD로 변환되어 **메모리 요구량이 증가**할 수도 있으므로
  반드시 MEMSTATS/IOSTATS로 성능을 비교해야 합니다.

### 통계 정보 최적화
- 스큐 컬럼에 히스토그램 생성
- 결합 상관관계가 높은 경우 확장 통계 활용
- 반복적인 추정 오류 시 Dynamic Statistics 적용

이 세 가지 방법은 "해시 조인 설계 시 빌드 크기 예측"의 안정성을 높입니다.

### 병렬 처리에서의 Bloom Filter(Join Filter)
데이터 웨어하우스/스타 스키마 조인에서는
BUILD에서 생성한 Bloom Filter를 PROBE 스캔 단계로 적용하여
**팩트 테이블 스캔량 자체를 줄여** 해시 조인의 부담을 감소시킵니다.

- Bloom Filter의 효율성은 **카디널리티 추정 정확도**에 의존하므로
  스큐 오류가 줄어들수록 Bloom Filter도 더 효과적으로 작동합니다.

---

## 해시 조인 사용 기준 — NL 조인, 머지 조인과의 선택 기준

### 해시 조인이 적합한 경우
- 두 입력이 모두 **대량**이고
- **등치(=) 조인**이며
- 인덱스 기반 NL 조인이 **랜덤 I/O 폭발**로 불리하고
- 결과가 "일부 몇 건"이 아니라 **대량 처리/집계**일 때

즉, ETL/리포팅/분석형 쿼리에 적합합니다.

### 해시 조인을 피해야 하는 경우
- **매우 선택적인 조회**(소수의 행만 필요)
  - 인덱스 + NL 조인이 압도적으로 유리
- **Top-N / StopKey / 화면 응답형 OLTP**
  - 해시 조인은 기본적으로 "PROBE 전체 스캔"이 필요하므로 불리함
- **비등치/기간/범위 조인**
  - 정렬되어 있거나 인덱스가 적절하면 **Sort Merge Join**이 자연스러움

### 상황별 조인 방식 선택 가이드

| 상황 | 우선 고려 방식 |
|------|----------------|
| Outer가 매우 작고 Inner 인덱스가 우수 | Nested Loops |
| 양쪽 모두 대량 + 등치 조인 + 리포팅/집계 | Hash Join |
| 비등치/범위/기간 매핑 + 정렬/인덱스 가능 | Sort Merge Join |
| Hash Join에서 스필/멀티패스 발생 | Hash 구조 개선 또는 NL/SMJ 재검토 |

---

## 해시 조인 튜닝 실무 가이드라인

### 메모리 및 스필 모니터링
- `HASH JOIN` 노드에서 `TempSpc` 값 확인하기
- `v$sql_workarea(_active)`에서 onepass/multipass 발생 여부 확인하기
- `direct path read/write temp` 작업 발생 여부 확인하기

### 스큐 및 카디널리티 관리
- 조인 키 분포를 Top-N 분석으로 스큐 확인하기
- 스큐 컬럼에 히스토그램 생성 여부 확인하기
- 결합 상관관계가 높은 경우 확장 통계 활용하기
- 예상 행 수(E-Rows)와 실제 행 수(A-Rows) 차이 분석하기

### 쿼리 구조 및 힌트 최적화
- BUILD 입력 최소화하기(필터, DISTINCT, 사전 집계)
- SWAP_JOIN_INPUTS로 빌드/프로브 역할 변경 테스트하기
- 병렬 처리 시 Bloom Filter/스타 변환 적용 여부 확인하기

---

## 결론

해시 조인은 대량 데이터 처리에 매우 효율적인 조인 방식이지만, 올바른 적용과 튜닝이 필요합니다:

1. **BUILD 입력 크기 관리가 핵심**입니다. BUILD가 PGA(해시 workarea)를 초과하면 Oracle은 Grace/Hybrid(One-pass) 해시 조인으로 전환하여 BUILD와 PROBE를 파티셔닝하고 TEMP로 스필합니다. 이때 PROBE는 파티션 단위로 재읽기됩니다. 특정 파티션이 또 커지면 Multi-pass로 재파티셔닝이 반복되어 PROBE가 여러 번 읽히고 TEMP I/O가 급증합니다.

2. **해시 키 스큐(중복/편중)**는 버킷/파티션 불균형을 초래하여 체인 길이 증가(CPU 폭증), 특정 파티션 스필 집중(TEMP 폭증), 병렬 로드 불균형 등 심각한 성능 문제를 야기합니다. 스큐 조인의 자동 보정을 위해 동적 통계와 SQL Plan Directive가 도입되었지만, 근본적인 해결책은 정확한 통계 정보와 적절한 쿼리 구조 개선에 있습니다.

3. **해시 조인의 성공 여부**는 (1) BUILD를 얼마나 작게 만들었는지, (2) 조인 키 분포가 얼마나 균등한지, (3) workarea가 충분한지에 따라 결정됩니다. 해시 조인은 대량 등치 조인과 집계/리포팅 작업에서 강점을 발휘하지만, 고선택 OLTP, Top-N, 비등치 조인에서는 Nested Loops나 Sort Merge Join이 더 적합할 수 있습니다.

4. **실전에서의 검증**은 반드시 `DBMS_XPLAN.DISPLAY_CURSOR`의 `ALLSTATS LAST + MEMSTATS + IOSTATS` 옵션을 사용하여 실제 실행 통계를 확인하는 것이 필수적입니다. 예상과 실제의 차이를 분석하고, 지속적인 모니터링과 튜닝을 통해 최적의 성능을 달성해야 합니다.

해시 조인을 효과적으로 활용하려면 데이터 특성, 쿼리 패턴, 시스템 리소스를 종합적으로 고려한 의사결정이 필요하며, 다양한 조인 방식의 장단점을 이해하고 상황에 맞게 적절히 적용하는 것이 전문가의 역량입니다.