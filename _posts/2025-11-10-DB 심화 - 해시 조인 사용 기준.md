---
layout: post
title: DB 심화 - 해시 조인 사용 기준
date: 2025-11-10 19:25:23 +0900
category: DB 심화
---
# 해시 조인 완전 가이드 — BUILD 스필(하이브리드/멀티패스), 키 스큐(중복) 비효율, 사용 기준까지

> 목표
> 1) **BUILD 입력이 hash workarea(PGA)를 넘을 때 Oracle이 어떻게 처리하는지**(원패스/하이브리드/멀티패스)
> 2) **해시 키 스큐(중복/편중)**가 왜 해시 조인을 망가뜨리는지, 어떤 **관측 신호**가 있는지
> 3) 실무에서 **해시 조인을 쓰는 기준과 튜닝 체계**

> 꼭 기억할 것
> - 해시 조인은 **“작은 BUILD를 메모리에 올리고 큰 PROBE를 한 번 훑는”** 대량 처리 조인이다.
> - 성능의 80%는 **BUILD 크기/키 분포/워크에어리어(메모리)**에서 결정된다.
> - 모든 결론은 **실측 플랜 ALLSTATS LAST + MEMSTATS + IOSTATS**로 검증한다.

---

## 0) 실습 준비(사용자 제공 스크립트 그대로)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;
ALTER SESSION SET workarea_size_policy = AUTO;
```

사용자 스키마/데이터(스큐·대용량 재현)는 그대로 사용한다.
이후 관측은 항상:

```sql
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'
));
```

---

## 1) 해시 조인 메커니즘 — BUILD/PROBE/WORKAREA

### BUILD(해시 테이블 생성)

- 옵티마이저는 두 입력 중 **“작을 것”**을 BUILD로 잡는다.
- BUILD 입력을 읽으며:
  1) 조인 키로 해시값 계산
  2) 해시 버킷(bucket) 결정
  3) 동일 버킷 체인(chain)에 행을 연결
- 이 해시 테이블은 **PGA(workarea, hash area)**에 생성된다.

### PROBE(매칭 탐색)

- PROBE 입력(큰 쪽)을 **순차 스캔**하며:
  1) 같은 해시 함수로 버킷 계산
  2) 버킷 체인에서 실제 키 비교
  3) 매칭 결과 출력
- 이상적인 경우 PROBE는 **딱 한 번**만 읽는다.

### Hash Workarea(메모리)와 종류

Oracle은 실행 시점에 “이 해시 조인이 메모리에 다 들어가는가?”를 보고 다음 세 부류로 동작한다.

| 종류 | 의미 | PROBE 재읽기 | TEMP I/O |
|---|---|---:|---:|
| **Optimal(원패스-최적)** | BUILD 전체가 PGA에 상주 | 0회 | 거의 없음 |
| **One-pass(하이브리드/그레이스)** | BUILD 일부가 TEMP로 스필되지만, PROBE는 파티션 단위로 1회 재읽기 | **파티션별 1회** | 있음 |
| **Multi-pass(멀티패스)** | 스필된 특정 파티션이 또 커서 **재파티셔닝** | **여러 번** | 매우 큼 |

핵심은:

- **Optimal**: “PROBE 1회”
- **One-pass**: “PROBE가 파티션별 1회씩”
- **Multi-pass**: “PROBE가 **여러 번 반복**”
  → 멀티패스가 나타나면 해시 조인은 사실상 “스필 폭탄”이다.

---

## 2) BUILD 입력이 Hash Area를 초과할 때 — 하이브리드/멀티패스의 실제 동작

### 왜 파티셔닝(Grace Hash Join)이 필요한가?

BUILD가 PGA를 넘으면:

- 해시 테이블을 통째로 메모리에 둘 수 없고
- PROBE가 그 테이블을 조회하려면
  **“같은 해시 함수로 묶인 작은 조각”끼리만** 다시 조인해야 한다.

그래서 Oracle은 **BUILD/PROBE를 동일 해시로 파티셔닝**하는 전략을 쓴다.

### 하이브리드(One-pass) 단계별 흐름

1) BUILD 읽기 시작
2) 파티션 p1,p2,…로 해시 분할
3) **일부 파티션은 메모리에 유지**, 초과 파티션은 TEMP로 스필
4) PROBE를 스캔하면서 같은 방식으로 파티션 분할
5) **메모리 BUILD 파티션**은 즉시 매칭
6) 스필된 파티션은
   - BUILD p_k를 TEMP에서 읽어 PGA에 로드
   - PROBE p_k를 TEMP에서 읽어 매칭
7) 모든 파티션 쌍 처리 후 종료

**중요 특징**
- PROBE 원본을 한 번만 읽고 끝내는 게 아니라,
  **스필된 파티션만큼 PROBE 파티션을 다시 읽는다.**
- 하지만 **각 파티션은 1번만** 재읽으므로 “one-pass”.

### 멀티패스(Multi-pass)의 흐름

하이브리드 과정에서
**특정 파티션 하나가 또 메모리를 넘으면**:

1) 그 파티션을 다시 해시로 더 쪼갠다(재파티셔닝)
2) 그에 해당하는 PROBE 파티션도 다시 쪼개 재읽는다
3) 이 작업이 반복되면 PROBE가 다회 재읽기된다.

즉,

- **멀티패스 = PROBE 다회 재스캔**
- 성능은 TEMP 대역폭에 종속된다.

---

## 3) 스필을 “눈으로” 확인하는 방법(실측)

### DBMS_XPLAN MEMSTATS / IOSTATS

```sql
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'
));
```

해시 조인 노드에서 보는 포인트:

- `TempSpc`(또는 Temp space 사용량 표시)
  - 0에 가깝다 → Optimal 가능성이 높음
  - 유의미하게 크다 → One-pass 이상
- IOSTATS에서
  - `direct path write temp`, `direct path read temp`가 늘면
    BUILD/PROBE 스필이 실제로 발생한 것.

### V$SQL_WORKAREA(_ACTIVE)

해시/소트 워크에어리어의 실행 결과를 직접 본다.

```sql
SELECT sid, sql_id, operation_type, policy,
       estimated_optimal_size,
       estimated_onepass_size,
       last_memory_used,
       number_passes,
       tempseg_size
FROM   v$sql_workarea_active
ORDER  BY last_execution DESC;
```

- `number_passes = 0` → Optimal 혹은 One-pass 중 “재파티셔닝 없음”
- `number_passes > 0` → Multi-pass 정황
- `tempseg_size`가 실행 중 크게 증가 → 스필 진행 중

완료된 실행은:

```sql
SELECT sql_id, operation_type,
       optimal_executions,
       onepass_executions,
       multipasses_executions,
       last_memory_used,
       last_tempseg_size
FROM   v$sql_workarea
WHERE  sql_id = :sql_id;
```

---

## 4) 실습 1 — BUILD 크기 조절로 스필을 유도/제거

아래에서 **빌드(D_DIM) 필터 강도**를 기점으로
Optimal ↔ One-pass ↔ Multi-pass 경계를 관찰한다.

### (A) BUILD 축소: 스필이 줄거나 사라지는 케이스

```sql
SELECT /*+ LEADING(d f) USE_HASH(f) NO_USE_NL(f) NO_USE_MERGE(f) */
       d.tier, COUNT(*), SUM(f.v) total_v
FROM   D_DIM d
JOIN   F_FACT f
  ON   f.k = d.k
WHERE  d.tier IN ('VIP','GOLD')
AND    f.dt >= DATE '2024-06-01'
GROUP  BY d.tier;

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS +PREDICATE'
));
```

**기대 관찰**
- `HASH JOIN` 노드의 `TempSpc`가 0 또는 매우 작은 수준
- `direct path * temp`가 거의 없음
- Elapsed/Buffer Gets가 상대적으로 안정적

### (B) BUILD 확대: 스필 발생

```sql
SELECT /*+ LEADING(d f) USE_HASH(f) */
       d.tier, COUNT(*), SUM(f.v)
FROM   D_DIM d
JOIN   F_FACT f
  ON   f.k = d.k
WHERE  d.tier IN ('VIP','GOLD','SILVER','BRONZE','GEN') -- 사실상 전체
AND    f.dt >= DATE '2024-06-01'
GROUP  BY d.tier;

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'
));
```

**기대 관찰**
- `TempSpc` 증가
- TEMP read/write 증가
- (A) 대비 Elapsed/IO/Temp가 체감될 정도로 증가
  → **BUILD 초과 → One-pass 이상**으로 동작

---

## 5) 해시 키 중복(스큐)로 인한 비효율 — 왜 해시 조인이 깨지는가?

### 스큐의 3가지 형태

1) **PROBE 키 스큐**
   - 특정 키가 PROBE에서 엄청 많이 등장
   - 해당 버킷 체인이 길어져 **CPU 비교가 폭증**

2) **BUILD 키 스큐**
   - BUILD의 특정 키 집합이 비대
   - BUILD 자체가 메모리에 안 들어가 스필 유발

3) **양쪽 스큐 + 조합 스큐**
   - 특정 키가 BUILD/PROBE 양쪽에서 폭발
   - 그 파티션만 과밀해 One-pass/Multi-pass 가능성을 키움
   - 병렬에서는 **로드 임밸런스**까지 발생

### 스큐의 비용 구조

스큐가 심할수록:

- 버킷이 균등하게 분할되지 않음
- 일부 버킷/파티션의 체인이 길어짐
- “해시 비교”가 **O(1)**이 아니라 **O(chain length)**로 변질
- 그 파티션만 스필/재스필 되어 TEMP I/O가 집중되고
- 병렬이면 그 파티션을 맡은 PX 서버가 **마지막까지 남아 전체 시간을 지배**

즉, **해시 조인의 이상적 가정(균등 분할)이 깨지는 순간**,
해시 조인의 장점은 사라진다.

### 스큐 재현(사용자 쿼리 그대로)

```sql
SELECT /*+ LEADING(f d) USE_HASH(d) NO_USE_NL(d) NO_USE_MERGE(d) */
       d.tier, COUNT(*) cnt, SUM(f.v) sum_v
FROM   F_FACT f
JOIN   D_DIM  d
  ON   d.k = f.k
GROUP  BY d.tier;

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS +PREDICATE'
));
```

**기대 관찰**
- 해시 조인에서 Elapsed가 커짐
- TempSpc가 증가하거나(스필)
  스필이 없어도 CPU가 큰 비중을 차지(버킷 체인 비교)

---

## 6) 스큐 확인과 “원인 분해” 진단 SQL

### 키 분포를 직접 확인

```sql
SELECT k, COUNT(*) cnt
FROM   F_FACT
GROUP  BY k
ORDER  BY cnt DESC
FETCH FIRST 20 ROWS ONLY;
```

- 상위 몇 키가 **전체의 대부분(예: 70%)**을 차지하면 PROBE 쪽 스큐가 심함.

### 스큐로 인한 조인 카디널리티 오판

스큐가 있는데 히스토그램/확장통계가 없으면
CBO는 균등/독립 가정으로 오판한다.

- 조인 오판은 해시 조인 **빌드 크기** 예측을 틀려
  “원패스라고 생각했는데 실제는 스필” 같은 뒤통수를 만든다.
- 19c 이후 Optimizer는 **SQL Plan Directive + Dynamic Statistics**로
  **데이터 스큐 조인을 자동 보정하려는 기능**을 갖는다.

---

## 7) 스큐/스필 완화 전략 (실전)

### BUILD 입력 축소(가장 확실)

1) 조인 전 필터를 최대한 아래로
2) DISTINCT/집계로 BUILD를 압축
3) 필요 컬럼만 남기기(rowlen 축소)

```sql
WITH D_MIN AS (
  SELECT /*+ MATERIALIZE */ DISTINCT k, tier
  FROM   D_DIM
  WHERE  tier IN ('VIP','GOLD')
)
SELECT /*+ LEADING(d f) USE_HASH(f) */
       d.tier, COUNT(*), SUM(f.v)
FROM   D_MIN d
JOIN   F_FACT f ON f.k = d.k
GROUP  BY d.tier;
```

- BUILD 행 수↓ + rowlen↓ → **workarea 요구량 급락**
- 스필 가능성을 가장 직접적으로 없앤다.

### BUILD/PROBE 뒤집기(SWAP_JOIN_INPUTS)

스큐가 BUILD 쪽에 몰렸다면
BUILD/PROBE를 반대로 두는 것이 유리할 수 있다.

```sql
SELECT /*+ LEADING(d f) USE_HASH(f) SWAP_JOIN_INPUTS(f) */
       d.tier, COUNT(*), SUM(f.v)
FROM   D_DIM d
JOIN   F_FACT f ON f.k = d.k
GROUP  BY d.tier;
```

- 단, 뒤집으면 PROBE가 BUILD로 변해
  **메모리 요구량이 더 커져 악화**될 수도 있으니
  반드시 MEMSTATS/IOSTATS로 비교한다.

### 히스토그램/확장 통계/동적 통계

- 스큐 컬럼에 히스토그램
- 결합 상관이 있으면 확장 통계
- 반복 오판이면 Dynamic Statistics 수용

이 3개가 “해시 조인 설계 시 빌드 크기 예측”을 안정화한다.

### 병렬에서의 Bloom Filter(Join Filter)

DW/스타 조인에서는
BUILD에서 만든 Bloom Filter를 PROBE 스캔 단계로 내려
**팩트 스캔 자체를 줄여** 해시 조인의 부담을 줄인다.

- Bloom 효율은 **카디널리티 정확도**에 의존하므로
  스큐 오판이 줄어들수록 Bloom도 잘 먹힌다.

---

## 8) 해시 조인을 쓰는 기준 — NL/SMJ와의 분기점

Oracle 공식 튜닝 가이드의 일반 원칙은 다음과 같다.

### 해시 조인이 좋은 경우

- 두 입력이 **대량**이고
- **등치(=) 조인**이며
- 인덱스 기반 NL이 **랜덤 I/O 폭발**로 불리하고
- 결과가 “일부 몇 건”이 아니라 **대량 처리/집계**일 때

즉, ETL/리포팅/분석형 SQL.

### 피해야 하는 경우

- **매우 선택적인 조회**(소수 행)
  - 인덱스 + NL이 압도적으로 유리
- **Top-N / StopKey / 화면 응답형 OLTP**
  - 해시 조인에선 “PROBE 전체 스캔”이 기본이라 불리
- **비등치/기간/밴드 조인**
  - 정렬되어 있거나 인덱스가 잘 맞으면 **SMJ**가 자연스럽다.

### 간단 의사결정 표

| 상황 | 우선 후보 |
|---|---|
| Outer가 매우 작고 Inner 인덱스가 좋다 | NL |
| 양쪽 대량 + 등치 + 리포팅/집계 | Hash |
| 비등치/범위/기간 매핑 + 정렬/인덱스 가능 | SMJ |
| Hash가 스필/멀티패스 발생 | Hash 구조 교정 후 재검토 또는 NL/SMJ |

---

## 9) 종합 체크리스트(실무 루틴)

### 스필/메모리

- [ ] `HASH JOIN` 노드에 `TempSpc`가 있는가?
- [ ] `v$sql_workarea(_active)`에서 onepass/multipass가 있는가?
- [ ] `direct path read/write temp`가 발생하는가?

### 스큐/카디널리티

- [ ] 조인 키 분포 Top-N으로 스큐를 확인했는가?
- [ ] 스큐 컬럼 히스토그램이 있는가?
- [ ] 결합 상관이 크다면 확장 통계가 있는가?
- [ ] E-Rows/A-Rows 괴리가 해시 조인 노드에서 큰가?

### 구조/힌트

- [ ] BUILD를 최소화했는가? (필터, DISTINCT, 사전 집계)
- [ ] SWAP_JOIN_INPUTS로 빌드/프로브를 바꿔 비교했는가?
- [ ] 병렬이라면 Bloom Filter/스타 변환이 실제로 내려왔는가?

---

## 10) 요약

- BUILD 입력이 PGA(해시 workarea)를 넘으면 Oracle은
  **Grace/Hybrid(One-pass) 해시 조인**으로 BUILD/PROBE를 파티셔닝해 TEMP로 스필한다.
  이때 PROBE는 **파티션 단위로 재읽기**된다.
- 특정 파티션이 또 커지면 **Multi-pass**로 재파티셔닝이 반복되어
  PROBE가 여러 번 읽히고 TEMP I/O가 폭증한다.
- 해시 키 스큐(중복/편중)는
  **버킷/파티션 불균형 → 체인 길이 증가(CPU 폭증) → 특정 파티션 스필 집중(TEMP 폭증) → 병렬 로드 임밸런스**를 만든다.
  스큐 조인의 자동 보정은 **동적 통계/SQL Plan Directive**로 일부 개선되지만,
  **근본은 통계와 SQL 구조 교정**이다.
- 해시 조인의 성패는
  **(1) BUILD를 얼마나 작게 만들었는지**와
  **(2) 조인 키 분포가 얼마나 균등한지**와
  **(3) workarea가 충분한지**에 달려 있다.
- 해시 조인은 **대량·등치·집계/리포팅**에서 강하고,
  **고선택 OLTP/Top-N/비등치 조인**에서는 NL/SMJ가 우선 후보다.
