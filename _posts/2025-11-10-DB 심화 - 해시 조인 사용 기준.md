---
layout: post
title: DB 심화 - 해시 조인 사용 기준
date: 2025-11-10 19:25:23 +0900
category: DB 심화
---
# 해시 조인(Oracle) — **빌드 입력이 Hash Area를 초과할 때의 처리, 해시 키 중복(스큐)로 인한 비효율, 해시 조인 사용 기준**

(재현 가능한 **실습 SQL** 포함. 실행계획/통계는 `DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')`로 확인)

---

## 0. 실습 준비

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;           -- DBMS_XPLAN ALLSTATS LAST
ALTER SESSION SET workarea_size_policy = AUTO;      -- (권장) 해시/소트 작업메모리 자동 관리
-- 필요시: ALTER SYSTEM SET pga_aggregate_target = <값> SCOPE=BOTH;  -- 권한/환경에 맞게
```

---

# 1. 스키마 & 데이터 (스큐/대용량 재현)

> **목표**
> - **BUILD 입력이 큰 경우**(PGA 초과)와 **해시 키 스큐(중복)**가 심한 케이스를 쉽게 만들어 **스필/비효율**을 관찰.
> - 팩트 테이블(매우 큼) + 디멘전(작거나/필터로 작게) 형태를 사용.

```sql
-- 정리
DROP TABLE D_DIM PURGE;
DROP TABLE F_FACT PURGE;

-- 디멘전 (BUILD 후보)
CREATE TABLE D_DIM (
  K       NUMBER       NOT NULL,
  TIER    VARCHAR2(8)  NOT NULL,
  PAD     VARCHAR2(50),
  CONSTRAINT PK_DIM PRIMARY KEY (K)
);

-- 팩트 (PROBE 후보)
CREATE TABLE F_FACT (
  K       NUMBER NOT NULL,    -- D_DIM.K 와 조인
  V       NUMBER NOT NULL,    -- 측정값
  DT      DATE   NOT NULL
);

-- 스큐(중복) 유발: 상위 몇 개 키에 데이터가 몰리게
DECLARE
  hi_keys  CONSTANT NUMBER := 5;        -- 상위 5개 키에 몰림
  dim_rows CONSTANT NUMBER := 100000;   -- DIM 크기
  fact_rows CONSTANT NUMBER := 2000000; -- FACT 크기 (환경에 맞게 조절)
BEGIN
  -- D_DIM: 균등 분포
  FOR i IN 1..dim_rows LOOP
    INSERT INTO D_DIM (K, TIER, PAD)
    VALUES (i,
            CASE MOD(i,5) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' WHEN 2 THEN 'SILVER' WHEN 3 THEN 'BRONZE' ELSE 'GEN' END,
            RPAD('x', 50, 'x'));
  END LOOP;

  -- F_FACT: 스큐 분포 (K=1..hi_keys 에 몰림 + 나머지는 균등)
  FOR i IN 1..fact_rows LOOP
    INSERT INTO F_FACT (K, V, DT)
    VALUES (
      CASE
        WHEN MOD(i,10) < 7 THEN MOD(i,hi_keys)+1 -- 약 70%가 상위 5키로 몰림
        ELSE MOD(i,dim_rows)+1
      END,
      TRUNC(DBMS_RANDOM.VALUE(1,1000)),
      DATE '2024-01-01' + MOD(i,365)
    );
  END LOOP;

  COMMIT;
END;
/

-- 통계
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'D_DIM',  cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'F_FACT', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

# 2. 해시 조인 **기본 메커니즘** 리마인드

- **BUILD 단계**: 작은 입력을 읽어 **PGA**에 **해시 테이블** 구축(버킷/체인).
- **PROBE 단계**: 큰 입력을 스캔하며 **동일 해시 버킷**에서 키 비교 후 매칭 출력.

> 메모리 여유 → **원패스(One-pass)**, 부족 → **하이브리드/멀티패스(파티셔닝/스필)**.
> $$ \text{총비용} \approx \text{빌드 읽기} + \text{프로브 한 번} + \text{스필/리로드 오버헤드(있다면)} $$

---

# 3. **BUILD 입력이 Hash Area(PGA)를 초과**할 때의 처리 (스필/파티셔닝)

## 3.1 동작 원리
1) **하이브리드 해시 조인(Partitioned/Grace Hash Join)**
   - 빌드 입력을 **해시 파티셔닝**하여 **일부는 메모리**, **초과분은 TEMP(스필)**에 기록.
   - 같은 해시 함수로 **프로브 입력**도 같은 파티션으로 분리.
   - 파티션 **쌍(빌드P, 프로브P)** 단위로 다시 빌드-프로브 실행 → **정확한 매칭** 유지.
2) **멀티패스(재파티셔닝)**
   - 특정 파티션이 여전히 커서 또 **나눠야** 할 때(드뭄). TEMP I/O 증가, 성능 급저하 가능.

> **관측 포인트**
> - **`DBMS_XPLAN ... +MEMSTATS`**에서 **TempSpc** 사용 증가
> - 대기/통계에서 **`direct path read/write temp`** 패턴
> - `V$SQL_WORKAREA_ACTIVE/ V$SQL_WORKAREA`에서 **onepass/multipass** 여부

## 3.2 실습: 스필 유도/관찰

> 아래 쿼리는 **D_DIM을 빌드**로, **F_FACT를 프로브**로 사용하도록 순서/힌트를 준다.
> `TIER` 필터를 약하게/강하게 조절하여 **빌드 크기**를 바꿔보자.

```sql
-- (A) 빌드 입력이 상대적으로 "작은" 경우: 스필이 줄거나 없음(환경에 따라)
SELECT /*+ LEADING(d f) USE_HASH(f) NO_USE_NL(f) NO_USE_MERGE(f) */
       d.tier, COUNT(*), SUM(f.v) total_v
FROM   D_DIM d
JOIN   F_FACT f
  ON   f.k = d.k
WHERE  d.tier IN ('VIP','GOLD')          -- 빌드 축소
AND    f.dt >= DATE '2024-06-01'
GROUP  BY d.tier;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS +PREDICATE'));

-- (B) 빌드 입력을 크게(필터 약화): 스필 가능성↑
SELECT /*+ LEADING(d f) USE_HASH(f) */
       d.tier, COUNT(*), SUM(f.v)
FROM   D_DIM d
JOIN   F_FACT f
  ON   f.k = d.k
WHERE  d.tier IN ('VIP','GOLD','SILVER','BRONZE','GEN')  -- 사실상 전체
AND    f.dt >= DATE '2024-06-01'
GROUP  BY d.tier;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'));
```

**결과 해석 팁**
- `HASH JOIN` 단계의 **`TempSpc`**(MEMSTATS)와 **Reads/Writes**(IOSTATS) 증가 → **스필** 발생.
- 동일 환경에서 (A) 대비 (B)에서 엘랩스/버퍼/Temp가 **뚜렷이 증가**한다면 **빌드 초과 → 하이브리드/멀티패스**로 동작했다는 정황.

---

# 4. **해시 키 중복(스큐)**로 인한 비효율

## 4.1 왜 문제인가?
- 해시 버킷에 **불균형**이 생겨 **몇몇 버킷/파티션만 과도하게 비대** →
  - 빌드 체인 길어져 **CPU 비교 비용↑**
  - 특정 파티션만 **스필/재스필** 되어 **TEMP I/O** 집중
  - 병렬 시 **파티션 간 불균등**으로 **로드 임밸런스** → 전체 시간은 **가장 느린 파티션**에 종속

## 4.2 스큐 재현과 관찰

```sql
-- 상위 5개 키에 70%가 몰려 있음(데이터 생성 시 반영됨)
-- 조인 + 집계를 해시 조인으로 강제
SELECT /*+ LEADING(f d) USE_HASH(d) NO_USE_NL(d) NO_USE_MERGE(d) */
       d.tier, COUNT(*) cnt, SUM(f.v) sum_v
FROM   F_FACT f
JOIN   D_DIM  d
  ON   d.k = f.k
GROUP  BY d.tier;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS +PREDICATE'));
```

**스큐 징후**
- 해시 조인 단계의 **Elapsed**가 크고, **TempSpc** 사용이 **일부 값 구간**에서 폭증(직접 파티션별 수치는 노출되진 않지만 총량으로 체감)
- 병렬 사용 시 일부 PX 서버만 오래 걸리고 나머지는 빨리 끝남(세션 모니터링 필요)

## 4.3 스큐 완화 방법(실전 팁)

1) **빌드 입력 축소**
   - 조인 전 **필터**(WHERE), **SEMI 조인**(EXISTS), **파티션 프루닝**
   - 조인 전에 **집계/중복 제거**로 **행 수/데이터량** 축소
     ```sql
     -- 빌드(D_DIM) 대신 "조인에 필요한 최소 컬럼 + DISTINCT" 미리 구성
     WITH D_MIN AS (
       SELECT /*+ MATERIALIZE */ DISTINCT k, tier
       FROM   D_DIM
       WHERE  tier IN ('VIP','GOLD')  -- 필터로 축소
     )
     SELECT /*+ LEADING(d f) USE_HASH(f) */
            d.tier, COUNT(*), SUM(f.v)
     FROM   D_MIN d
     JOIN   F_FACT f ON f.k = d.k
     GROUP  BY d.tier;
     ```
   - **결과**: BUILD 메모리 요구량↓ → **원패스** 가능성↑

2) **키 스큐 완화(“살팅”/복합키)**
   - 스큐가 극심한 일부 키에 **난수/시퀀스 조각**을 덧붙여 **해시 분산** 유도(모델 변경/중간 테이블 필요).
   - 또는 **복합 해시 키**로 조인(업무적으로 허용될 때만).

3) **히스토그램/ACS(Adaptive Cursor Sharing)**
   - 옵티마이저가 **값별 카디널리티**를 잘 맞추도록 **히스토그램** 생성(조인 전 필터 컬럼).
   - 바인드 값에 따라 **플랜 분기**(ACS)로 스큐 값에 NL/SMJ/해시 조인 선택 다르게.

4) **빌드/프로브 뒤집기**
   - 스큐가 빌드 쪽에 집중되면 **프로브로 바꾸고** 상대를 **빌드**로:
     ```sql
     SELECT /*+ LEADING(d f) USE_HASH(f) SWAP_JOIN_INPUTS(f) */
            d.tier, COUNT(*)
     FROM   D_DIM d JOIN F_FACT f ON f.k = d.k
     GROUP  BY d.tier;
     ```
   - 단, **반대로 더 악화**될 수 있으므로 반드시 **실측 비교**.

5) **병렬 + Bloom Filter(스타 조인)**
   - DW/스타 스키마에서 디멘전 필터를 Bloom으로 **팩트 스캔 단계에서 미리 걸러** I/O를 줄임. (병렬/PQ 환경)

---

# 5. 해시 조인 **사용 기준**(의사결정 가이드)

## 5.1 언제 해시 조인을 택하는가?
- **대량 스캔/집계**가 필연적이고 **조기 종료(Top-N/부분범위) 이점이 작을 때**
- Inner 인덱스가 없거나 있어도 **범위가 너무 넓어** NL의 랜덤 I/O가 폭증할 때
- **DW/보고서/ETL** 스타일(병렬/대량)
- **등치 조인** 중심. (비등치/기간 조인은 **SMJ**(소트 머지)가 자연스럽다)

## 5.2 언제 해시 조인을 피하는가?
- **작은 결과**를 **아주 빠르게** 얻어야 할 때(Top-N, 화면 조회) → **NL + 인덱스**
- **메모리/Temp**가 빡빡하고, 스필 I/O가 병목일 때
- **비등치/밴드 조인**(기간 매핑)은 **SMJ**가 대체로 유리

## 5.3 체크리스트
- [ ] **빌드 입력**을 **작게** 만들 수 있는가? (필터/중복제거/프루닝/집계)
- [ ] **LEADING/USE_HASH**로 **조인 순서/메소드**를 의도대로 만들었는가?
- [ ] **SWAP_JOIN_INPUTS**로 **빌드/프로브**를 바꿔보며 **MEMSTATS/IOSTATS**를 비교했는가?
- [ ] **TempSpc(스필)**가 발생하는가? 발생 시 **PGA 정책/쿼리 재작성**로 줄일 수 있는가?
- [ ] **스큐**(특정 키 과밀)가 있는가? **히스토그램/ACS/살팅/빌드 전 축소**로 완화했는가?
- [ ] NL/SMJ와 **실측 비교**로 최적을 선택했는가?

---

# 6. 종합 실습 시나리오

## 6.1 베이스라인(원패스 목표)

```sql
-- 빌드 축소: 상위 등급만
SELECT /*+ LEADING(d f) USE_HASH(f) NO_USE_NL(f) NO_USE_MERGE(f) */
       d.tier, COUNT(*), SUM(f.v) sum_v
FROM   D_DIM d
JOIN   F_FACT f
  ON   f.k = d.k
WHERE  d.tier IN ('VIP','GOLD')
AND    f.dt >= DATE '2024-06-01'
GROUP  BY d.tier;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'));
```
- **TempSpc≈0** 또는 매우 작고, Elapsed 양호 → **원패스** 추정.

## 6.2 스필 유도(필터 완화 → 빌드 과대)

```sql
SELECT /*+ LEADING(d f) USE_HASH(f) */
       d.tier, COUNT(*), SUM(f.v)
FROM   D_DIM d
JOIN   F_FACT f
  ON   f.k = d.k
-- WHERE d.tier IN ('VIP','GOLD','SILVER','BRONZE','GEN')  -- 전체(필터 제거와 동치)
AND    f.dt >= DATE '2024-01-01'
GROUP  BY d.tier;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'));
```
- **TempSpc/Reads/Writes** 증가 → **하이브리드/멀티패스** 동작 정황.

## 6.3 스큐 완화(빌드 전 중복 제거)

```sql
WITH D_MIN AS (
  SELECT /*+ MATERIALIZE */ DISTINCT k, tier
  FROM   D_DIM
  WHERE  tier IN ('VIP','GOLD','SILVER','BRONZE','GEN')
)
SELECT /*+ LEADING(d f) USE_HASH(f) */
       d.tier, COUNT(*), SUM(f.v)
FROM   D_MIN d
JOIN   F_FACT f ON f.k = d.k
GROUP  BY d.tier;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'));
```
- (6.2) 대비 **TempSpc/Elapsed 감소** 확인.

## 6.4 빌드/프로브 교체 실험

```sql
-- 동일 조건에서 빌드/프로브를 반대로
SELECT /*+ LEADING(d f) USE_HASH(f) SWAP_JOIN_INPUTS(f) */
       d.tier, COUNT(*), SUM(f.v)
FROM   D_DIM d
JOIN   F_FACT f
  ON   f.k = d.k
GROUP  BY d.tier;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'));
```
- **스필 패턴**/Elapsed 변화를 비교하여 **최적 방향**을 결정.

---

# 7. 운영/모니터링 팁

```sql
-- 최근 실행 쿼리의 워크에어리어(해시/소트) 사용 기록
SELECT sid, sql_id, operation_type, policy,
       estimated_optimal_size, estimated_onepass_size, last_memory_used,
       last_execution, number_passes, tempseg_size
FROM   v$sql_workarea_active
ORDER  BY last_execution DESC;

-- (완료된 실행 포함) 누적 기록
SELECT sql_id, operation_type, optimal_executions, onepass_executions, multipasses_executions,
       last_memory_used, last_tempseg_size
FROM   v$sql_workarea
WHERE  sql_id = :sql_id;  -- 관심 쿼리

-- 실행계획에서 해시 조인 노드만 확인
SELECT sql_id, child_number, id, operation, options, object_name
FROM   v$sql_plan
WHERE  operation LIKE 'HASH JOIN%'
AND    sql_id = :sql_id;
```

- **number_passes > 0**: 원패스가 아닌 실행(스필/멀티패스) 흔적
- **tempseg_size 증가**: TEMP 사용 증가 → I/O 병목 위험

---

# 8. 요약

- **Hash Area(PGA) 초과** 시 해시 조인은 **하이브리드/멀티패스**로 전환(파티셔닝/스필).
  - **증상**: `TempSpc`↑, `direct path read/write temp`↑, Elapsed↑.
  - **해법**: **빌드 축소**(필터/중복제거/집계/프루닝), **빌드/프로브 교체**, **PGA 정책 조정**, **병렬+Bloom**.
- **해시 키 스큐(중복)**는 **특정 버킷/파티션 과밀**로 CPU/Temp/I/O 비효율과 **로드 임밸런스**를 유발.
  - **해법**: **히스토그램/ACS**, **빌드 전 축소**, **살팅/복합키**, **빌드/프로브 전환**, **스타 변환/블룸**.
- **사용 기준**:
  - **대량 스캔·집계**에서 **인덱스 이점이 적고** **조기 종료 필요가 낮으면** 해시 조인.
  - **Top-N/부분범위**는 NL, **비등치(기간/밴드)**는 SMJ 우선 고려.
- 모든 선택은 **실측**으로: `ALLSTATS LAST +MEMSTATS +IOSTATS`와 `V$SQL_WORKAREA(Active)`를 **반드시 확인**하자.
