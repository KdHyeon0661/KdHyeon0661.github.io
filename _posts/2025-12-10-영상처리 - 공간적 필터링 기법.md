---
layout: post
title: 영상처리 - 공간적 필터링 기법 (C#)
date: 2025-12-10 21:30:23 +0900
category: 영상처리
---
# 공간적 필터링 기법: 이론, 구현 및 최적화

## 공간적 필터링의 개념과 수학적 기초

### 정의와 중요성

공간적 필터링은 **한 픽셀과 그 주변 이웃 픽셀들의 관계**를 이용하여 영상을 변환하는 기법으로, 국소 영역(Local Neighborhood) 기반 처리를 통해 다양한 영상 처리 작업을 수행합니다.

**주요 활용 분야**:
- 노이즈 제거 및 평활화
- 에지 검출 및 윤곽선 강화
- 영상 선명화
- 특징 추출
- 영상 복원

### 수학적 모델: 2차원 회선(Convolution)

#### 연속 영상에서의 회선

$$
g(x,y) = (f \ast h)(x,y) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(\tau,\nu) \cdot h(x-\tau, y-\nu) \, d\tau \, d\nu
$$

여기서:
- $$f(x,y)$$: 입력 영상
- $$h(x,y)$$: 필터 커널(마스크)
- $$g(x,y)$$: 출력 영상

#### 이산 영상에서의 회선

이산 공간에서는 적분이 합산으로 대체됩니다:

$$
g(x,y) = \sum_{i=-k}^{k} \sum_{j=-k}^{k} f(x+i, y+j) \cdot h(i,j)
$$

여기서 $$k$$는 필터 마스크의 반경(radius)을 나타냅니다.

---

## 필터 마스크의 구조와 설계 원칙

### 기본 마스크 구조

```
3×3 마스크 구조 (k=1):
+-------------+-------------+-------------+
| h(-1,-1)    | h(-1, 0)    | h(-1, 1)    |
+-------------+-------------+-------------+
| h( 0,-1)    | h( 0, 0)    | h( 0, 1)    |
+-------------+-------------+-------------+
| h( 1,-1)    | h( 1, 0)    | h( 1, 1)    |
+-------------+-------------+-------------+
```

### 필터 설계 원칙

| 원칙 | 설명 | 중요성 |
|------|------|--------|
| **에너지 보존** | 마스크 계수의 합 = 1 | 영상 평균 밝기 유지 |
| **대칭성** | 마스크가 대칭적일 때 선형 위상 특성 유지 | 에지 왜곡 방지 |
| **가중치 분포** | 중심에 가까울수록 높은 가중치 | 국부적 특성 강조 |
| **분리 가능성** | 마스크를 1D 필터로 분해 가능 | 계산 효율성 증대 |

---

## 회선(Convolution)의 효율적인 구현

### 기본 회선 알고리즘

```csharp
public class ConvolutionProcessor
{
    // 기본 2D 회선 구현
    public static MyImage Convolve2D(MyImage src, double[,] kernel)
    {
        int kWidth = kernel.GetLength(1);
        int kHeight = kernel.GetLength(0);
        int kCenterX = kWidth / 2;
        int kCenterY = kHeight / 2;
        
        MyImage dst = new MyImage(src.Width, src.Height);
        
        // 입력 영상 패딩
        MyImage padded = PadImage(src, kCenterX, kCenterY, PaddingType.Reflect);
        
        // 회선 수행
        for (int y = kCenterY; y < padded.Height - kCenterY; y++)
        {
            for (int x = kCenterX; x < padded.Width - kCenterX; x++)
            {
                double sum = 0.0;
                
                // 커널 영역 순회
                for (int ky = 0; ky < kHeight; ky++)
                {
                    int iy = y + ky - kCenterY;
                    for (int kx = 0; kx < kWidth; kx++)
                    {
                        int ix = x + kx - kCenterX;
                        byte pixel = padded.GetPixel(ix, iy);
                        sum += pixel * kernel[ky, kx];
                    }
                }
                
                // 결과 클램핑 및 저장
                dst.SetPixel(x - kCenterX, y - kCenterY, 
                    (byte)Math.Clamp(sum, 0, 255));
            }
        }
        
        return dst;
    }
    
    // 경계 처리 방법
    public enum PaddingType
    {
        Zero,       // 0으로 채움
        Constant,   // 상수 값으로 채움
        Reflect,    // 경계 반사
        Replicate,  // 가장자리 복제
        Wrap        // 순환
    }
    
    private static MyImage PadImage(MyImage src, int padX, int padY, PaddingType type)
    {
        int newWidth = src.Width + 2 * padX;
        int newHeight = src.Height + 2 * padY;
        MyImage padded = new MyImage(newWidth, newHeight);
        
        for (int y = 0; y < newHeight; y++)
        {
            for (int x = 0; x < newWidth; x++)
            {
                int srcX = x - padX;
                int srcY = y - padY;
                
                byte value = 0;
                
                if (srcX >= 0 && srcX < src.Width && 
                    srcY >= 0 && srcY < src.Height)
                {
                    // 원본 영역 내부
                    value = src.GetPixel(srcX, srcY);
                }
                else
                {
                    // 경계 처리
                    value = HandlePadding(src, srcX, srcY, type);
                }
                
                padded.SetPixel(x, y, value);
            }
        }
        
        return padded;
    }
}
```

### 성능 최적화 기법

#### 1. 분리 가능 필터(Separable Filter)

분리 가능한 필터는 2D 회선을 두 번의 1D 회선으로 분해하여 계산량을 줄입니다:

```csharp
public static MyImage ConvolveSeparable(MyImage src, double[] rowKernel, double[] colKernel)
{
    // 중간 결과 저장용 버퍼
    double[,] temp = new double[src.Height, src.Width];
    
    // 수평 방향 필터링 (Row-wise)
    for (int y = 0; y < src.Height; y++)
    {
        for (int x = 0; x < src.Width; x++)
        {
            double sum = 0.0;
            int kRadius = rowKernel.Length / 2;
            
            for (int k = -kRadius; k <= kRadius; k++)
            {
                int nx = Math.Clamp(x + k, 0, src.Width - 1);
                sum += src.GetPixel(nx, y) * rowKernel[k + kRadius];
            }
            
            temp[y, x] = sum;
        }
    }
    
    // 수직 방향 필터링 (Column-wise)
    MyImage dst = new MyImage(src.Width, src.Height);
    
    for (int x = 0; x < src.Width; x++)
    {
        for (int y = 0; y < src.Height; y++)
        {
            double sum = 0.0;
            int kRadius = colKernel.Length / 2;
            
            for (int k = -kRadius; k <= kRadius; k++)
            {
                int ny = Math.Clamp(y + k, 0, src.Height - 1);
                sum += temp[ny, x] * colKernel[k + kRadius];
            }
            
            dst.SetPixel(x, y, (byte)Math.Clamp(sum, 0, 255));
        }
    }
    
    return dst;
}
```

#### 2. SIMD 병렬 처리

```csharp
public unsafe static void ConvolveSIMD(byte* src, byte* dst, int width, int height, 
    double[,] kernel, int kernelSize)
{
    // SIMD 벡터화를 통한 성능 향상
    int vectorSize = Vector<double>.Count;
    int kRadius = kernelSize / 2;
    
    // 각 행에 대해 병렬 처리
    Parallel.For(kRadius, height - kRadius, y =>
    {
        fixed (byte* pRow = &src[y * width])
        {
            for (int x = kRadius; x < width - kRadius; x += vectorSize)
            {
                // 벡터화된 회선 연산
                Vector<double> sum = Vector<double>.Zero;
                
                for (int ky = -kRadius; ky <= kRadius; ky++)
                {
                    for (int kx = -kRadius; kx <= kRadius; kx++)
                    {
                        double weight = kernel[ky + kRadius, kx + kRadius];
                        
                        // 벡터화된 픽셀 값 로드
                        Vector<double> pixels = LoadPixelVector(pRow, width, 
                            x + kx, ky, vectorSize);
                        
                        sum += pixels * weight;
                    }
                }
                
                // 결과 저장
                StorePixelVector(dst, width, x, y, sum);
            }
        }
    });
}
```

#### 3. FFT 기반 빠른 회선

```csharp
public static MyImage ConvolveFFT(MyImage src, double[,] kernel)
{
    // FFT를 이용한 회선 (대규모 커널에 효율적)
    // 원리: 공간 도메인 회선 = 주파수 도메인 곱셈
    
    // 1. 입력 영상과 커널을 FFT
    Complex[,] srcFFT = FFT2D(ImageToComplex(src));
    Complex[,] kernelFFT = FFT2D(PadKernelToSize(kernel, src.Width, src.Height));
    
    // 2. 주파수 도메인에서 곱셈
    Complex[,] resultFFT = MultiplyComplexArrays(srcFFT, kernelFFT);
    
    // 3. 역 FFT 수행
    Complex[,] resultComplex = IFFT2D(resultFFT);
    
    // 4. 실수부 추출 및 정규화
    return ComplexToImage(resultComplex);
}
```

### 계산 복잡도 비교

| 방법 | 시간 복잡도 | 공간 복잡도 | 적합한 상황 |
|------|------------|-------------|------------|
| 기본 2D 회선 | O(W·H·K²) | O(1) | 작은 커널(K ≤ 7) |
| 분리 가능 필터 | O(W·H·K) | O(W·H) | 분리 가능 커널 |
| FFT 기반 | O(W·H·log(W·H)) | O(W·H) | 큰 커널(K > 15) |
| SIMD 최적화 | O(W·H·K²/V) | O(1) | 모든 크기, 하드웨어 지원 |

---

## 평활화(Smoothing) 필터

### 1. 평균(박스) 필터

#### 수학적 정의

$$
h_{box}(x,y) = \frac{1}{K^2} \quad \text{for } |x|,|y| \leq \frac{K-1}{2}
$$

#### 커널 예시 (3×3)

$$
\frac{1}{9}
\begin{bmatrix}
1 & 1 & 1 \\
1 & 1 & 1 \\
1 & 1 & 1
\end{bmatrix}
$$

#### 특성 분석

```csharp
public class BoxFilterAnalysis
{
    // 주파수 응답 분석
    public static double[] FrequencyResponse(int kernelSize)
    {
        // 박스 필터의 주파수 응답은 sinc 함수
        double[] response = new double[100];
        for (int f = 0; f < response.Length; f++)
        {
            double omega = f * Math.PI / response.Length;
            response[f] = Math.Abs(Math.Sin(omega * kernelSize / 2) 
                / (kernelSize * Math.Sin(omega / 2)));
        }
        return response;
    }
    
    // 최적 크기 선택 가이드
    public static int RecommendKernelSize(double noiseStdDev, 
        double desiredSmoothing)
    {
        // 경험적 규칙: K ≈ 2·ceil(3σ) + 1
        return (int)(2 * Math.Ceiling(3 * noiseStdDev) + 1);
    }
}
```

### 2. 가우시안 필터

#### 수학적 정의

2D 가우시안 함수:

$$
G(x,y) = \frac{1}{2\pi\sigma^2} \exp\left(-\frac{x^2 + y^2}{2\sigma^2}\right)
$$

#### 커널 생성 알고리즘

```csharp
public static class GaussianKernel
{
    public static double[,] Create2DGaussian(int size, double sigma)
    {
        if (size % 2 == 0) throw new ArgumentException("커널 크기는 홀수여야 합니다.");
        
        double[,] kernel = new double[size, size];
        int k = size / 2;
        double sum = 0.0;
        
        // 이산 샘플링
        for (int y = -k; y <= k; y++)
        {
            for (int x = -k; x <= k; x++)
            {
                double value = GaussianFunction(x, y, sigma);
                kernel[y + k, x + k] = value;
                sum += value;
            }
        }
        
        // 정규화
        for (int i = 0; i < size; i++)
        {
            for (int j = 0; j < size; j++)
            {
                kernel[i, j] /= sum;
            }
        }
        
        return kernel;
    }
    
    private static double GaussianFunction(double x, double y, double sigma)
    {
        return Math.Exp(-(x * x + y * y) / (2 * sigma * sigma)) 
            / (2 * Math.PI * sigma * sigma);
    }
    
    // 분리 가능 형태
    public static (double[], double[]) CreateSeparableGaussian(int size, double sigma)
    {
        double[] kernel1D = new double[size];
        int k = size / 2;
        double sum = 0.0;
        
        for (int i = -k; i <= k; i++)
        {
            double value = Math.Exp(-(i * i) / (2 * sigma * sigma));
            kernel1D[i + k] = value;
            sum += value;
        }
        
        // 정규화
        for (int i = 0; i < size; i++)
        {
            kernel1D[i] /= sum;
        }
        
        return (kernel1D, kernel1D);  // 대칭적이므로 동일
    }
    
    // σ에 따른 커널 크기 계산
    public static int CalculateKernelSize(double sigma)
    {
        // 99.7%의 에너지를 포함하는 크기: 2·ceil(3σ) + 1
        return 2 * (int)Math.Ceiling(3 * sigma) + 1;
    }
}
```

#### 가우시안 필터의 특성

| 특성 | 설명 | 영향 |
|------|------|------|
| **등방성** | 모든 방향으로 동일하게 평활화 | 에지 방향 유지 |
| **단조 감소** | 중심에서 멀어질수록 가중치 감소 | 자연스러운 블러 |
| **분리 가능** | 1D 필터 2번 적용으로 구현 가능 | 계산 효율성 |
| **스케일 공간** | σ 증가에 따른 다중 스케일 표현 | 스케일 불변 특징 추출 |

### 3. 중앙값 필터 (비선형 필터)

#### 알고리즘

```csharp
public class MedianFilter
{
    public static MyImage Apply(MyImage src, int kernelSize)
    {
        MyImage dst = new MyImage(src.Width, src.Height);
        int radius = kernelSize / 2;
        
        // 히스토그램 기반 중앙값 필터링 (효율적 구현)
        for (int y = radius; y < src.Height - radius; y++)
        {
            for (int x = radius; x < src.Width - radius; x++)
            {
                dst.SetPixel(x, y, GetMedianInWindow(src, x, y, radius));
            }
        }
        
        return dst;
    }
    
    private static byte GetMedianInWindow(MyImage src, int cx, int cy, int radius)
    {
        // 히스토그램 기반 중앙값 계산 (O(256) 시간 복잡도)
        int[] histogram = new int[256];
        int totalPixels = (2 * radius + 1) * (2 * radius + 1);
        
        // 히스토그램 구성
        for (int dy = -radius; dy <= radius; dy++)
        {
            for (int dx = -radius; dx <= radius; dx++)
            {
                byte value = src.GetPixel(cx + dx, cy + dy);
                histogram[value]++;
            }
        }
        
        // 중앙값 찾기
        int count = 0;
        int medianIndex = totalPixels / 2;
        
        for (int i = 0; i < 256; i++)
        {
            count += histogram[i];
            if (count > medianIndex)
            {
                return (byte)i;
            }
        }
        
        return 0;
    }
    
    // 가중 중앙값 필터 (Weighted Median Filter)
    public static byte GetWeightedMedian(MyImage src, int cx, int cy, 
        int radius, int[,] weights)
    {
        // 가중치가 적용된 샘플 리스트 생성
        List<byte> samples = new List<byte>();
        
        for (int dy = -radius; dy <= radius; dy++)
        {
            for (int dx = -radius; dx <= radius; dx++)
            {
                byte value = src.GetPixel(cx + dx, cy + dy);
                int weight = weights[dy + radius, dx + radius];
                
                // 가중치만큼 값 반복 추가
                for (int w = 0; w < weight; w++)
                {
                    samples.Add(value);
                }
            }
        }
        
        // 정렬 및 중앙값 반환
        samples.Sort();
        return samples[samples.Count / 2];
    }
}
```

#### 중앙값 필터 특성

| 특성 | 설명 | 장점 | 단점 |
|------|------|------|------|
| **임펄스 노이즈 제거** | 소금-후추 노이즈에 효과적 | 에지 보존 우수 | 계산 비용 높음 |
| **비선형성** | 평균 대신 중간값 사용 | 이상치 영향 적음 | 통계적 특성 복잡 |
| **에지 보존** | 스텝 에지 왜곡 적음 | 구조 유지 | 평활화 효과 제한적 |
| **반복 적용** | 반복 시 점진적 평활화 | 점진적 노이즈 제거 | 세부 정보 손실 가능 |

### 4. 양방향 필터 (Bilateral Filter)

#### 이론적 배경

양방향 필터는 공간적 근접성과 강도 유사성을 모두 고려한 비선형 필터입니다:

$$
BF[I]_p = \frac{1}{W_p} \sum_{q \in S} G_{\sigma_s}(\|p-q\|) G_{\sigma_r}(|I_p-I_q|) I_q
$$

여기서:
- $$G_{\sigma_s}$$: 공간적 가우시안 (위치 차이)
- $$G_{\sigma_r}$$: 범위 가우시안 (강도 차이)
- $$W_p$$: 정규화 상수

#### 구현

```csharp
public class BilateralFilter
{
    public static MyImage Apply(MyImage src, 
        double spatialSigma, double rangeSigma, int kernelSize)
    {
        MyImage dst = new MyImage(src.Width, src.Height);
        int radius = kernelSize / 2;
        
        // 사전 계산된 공간 가중치
        double[,] spatialWeights = ComputeSpatialWeights(radius, spatialSigma);
        
        for (int y = radius; y < src.Height - radius; y++)
        {
            for (int x = radius; x < src.Width - radius; x++)
            {
                dst.SetPixel(x, y, ApplyAtPixel(src, x, y, 
                    radius, spatialWeights, rangeSigma));
            }
        }
        
        return dst;
    }
    
    private static byte ApplyAtPixel(MyImage src, int x, int y, 
        int radius, double[,] spatialWeights, double rangeSigma)
    {
        double sum = 0.0;
        double normalization = 0.0;
        byte centerValue = src.GetPixel(x, y);
        
        for (int dy = -radius; dy <= radius; dy++)
        {
            for (int dx = -radius; dx <= radius; dx++)
            {
                byte neighborValue = src.GetPixel(x + dx, y + dy);
                
                // 공간 가중치
                double spatialWeight = spatialWeights[dy + radius, dx + radius];
                
                // 범위 가중치 (강도 차이)
                double intensityDiff = Math.Abs(centerValue - neighborValue);
                double rangeWeight = Math.Exp(-(intensityDiff * intensityDiff) 
                    / (2 * rangeSigma * rangeSigma));
                
                // 총 가중치
                double totalWeight = spatialWeight * rangeWeight;
                
                sum += totalWeight * neighborValue;
                normalization += totalWeight;
            }
        }
        
        return (byte)Math.Clamp(sum / normalization, 0, 255);
    }
    
    private static double[,] ComputeSpatialWeights(int radius, double sigma)
    {
        int size = 2 * radius + 1;
        double[,] weights = new double[size, size];
        
        for (int y = -radius; y <= radius; y++)
        {
            for (int x = -radius; x <= radius; x++)
            {
                double distance = x * x + y * y;
                weights[y + radius, x + radius] = 
                    Math.Exp(-distance / (2 * sigma * sigma));
            }
        }
        
        return weights;
    }
}
```

#### 양방향 필터 최적화

```csharp
public class FastBilateralFilter
{
    // 가속화된 양방향 필터 (그리드 기반 근사)
    public static MyImage ApplyFast(MyImage src, 
        double spatialSigma, double rangeSigma)
    {
        // 1. 강도 값 양자화 (예: 256 → 16 레벨)
        int intensityBins = 16;
        byte[] quantized = QuantizeIntensity(src, intensityBins);
        
        // 2. 각 강도 레벨에 대해 공간 필터링 적용
        MyImage[] filteredLayers = new MyImage[intensityBins];
        
        Parallel.For(0, intensityBins, i =>
        {
            // 해당 강도 레벨 마스크 생성
            MyImage mask = CreateIntensityMask(quantized, i, intensityBins);
            
            // 가우시안 필터 적용
            filteredLayers[i] = GaussianFilter.Apply(mask, spatialSigma);
        });
        
        // 3. 레이어 결합 (트라이리니어 보간)
        return CombineLayers(filteredLayers, quantized, intensityBins);
    }
    
    private static MyImage CombineLayers(MyImage[] layers, 
        byte[] quantized, int bins)
    {
        MyImage result = new MyImage(layers[0].Width, layers[0].Height);
        double binSize = 256.0 / bins;
        
        for (int i = 0; i < quantized.Length; i++)
        {
            byte intensity = quantized[i];
            
            // 양자화 인덱스 계산
            double idx = intensity / binSize;
            int lowerIdx = (int)Math.Floor(idx);
            int upperIdx = (int)Math.Ceiling(idx);
            double t = idx - lowerIdx;
            
            if (upperIdx >= bins) upperIdx = bins - 1;
            
            // 선형 보간
            double value = layers[lowerIdx].Buffer[i] * (1 - t) 
                + layers[upperIdx].Buffer[i] * t;
            
            result.Buffer[i] = (byte)Math.Clamp(value, 0, 255);
        }
        
        return result;
    }
}
```

---

## 샤프닝(Sharpening) 필터

### 1. 언샤프 마스킹 (Unsharp Masking)

#### 기본 원리

$$
g(x,y) = f(x,y) + \lambda \cdot (f(x,y) - f_{blur}(x,y))
$$

여기서:
- $$f_{blur}(x,y)$$: 저역통과 필터링된 영상
- $$\lambda$$: 샤프닝 강도

#### 구현

```csharp
public class UnsharpMasking
{
    public static MyImage Apply(MyImage src, 
        double strength = 1.0, double sigma = 1.0)
    {
        // 1. 저역통과 필터 적용 (가우시안 블러)
        MyImage blurred = GaussianFilter.Apply(src, sigma);
        
        // 2. 고주파 성분 추출 (원본 - 블러)
        MyImage highPass = SubtractImages(src, blurred);
        
        // 3. 고주파 성분 증폭 후 원본에 추가
        MyImage sharpened = AddWeighted(src, highPass, 1.0, strength);
        
        return sharpened;
    }
    
    // 적응형 언샤프 마스킹
    public static MyImage ApplyAdaptive(MyImage src, 
        double baseStrength = 1.0, double sigma = 1.0)
    {
        MyImage result = new MyImage(src.Width, src.Height);
        
        // 지역적 대비 분석을 통한 가변적 샤프닝
        for (int y = 0; y < src.Height; y++)
        {
            for (int x = 0; x < src.Width; x++)
            {
                // 지역적 표준편차 계산 (대비 측정)
                double localStdDev = CalculateLocalStdDev(src, x, y, 3);
                
                // 대비에 따른 샤프닝 강도 조정
                double adaptiveStrength = baseStrength * 
                    (1.0 + 0.5 * Math.Tanh(localStdDev / 20.0 - 1.0));
                
                // 픽셀별 언샤프 마스킹 적용
                result.SetPixel(x, y, ApplyAtPixel(src, x, y, 
                    adaptiveStrength, sigma));
            }
        }
        
        return result;
    }
    
    private static byte ApplyAtPixel(MyImage src, int x, int y, 
        double strength, double sigma)
    {
        // 지역적 블러링 (작은 커널)
        double blurred = LocalGaussian(src, x, y, sigma, 3);
        
        // 샤프닝 적용
        double sharpened = src.GetPixel(x, y) + 
            strength * (src.GetPixel(x, y) - blurred);
        
        return (byte)Math.Clamp(sharpened, 0, 255);
    }
}
```

### 2. 라플라시안 필터 (2차 미분 기반)

#### 수학적 정의

2D 라플라시안 연산자:

$$
\nabla^2 f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2}
$$

#### 이산 근사 마스크

**4-방향 라플라시안**:
$$
\begin{bmatrix}
0 & 1 & 0 \\
1 & -4 & 1 \\
0 & 1 & 0
\end{bmatrix}
$$

**8-방향 라플라시안**:
$$
\begin{bmatrix}
1 & 1 & 1 \\
1 & -8 & 1 \\
1 & 1 & 1
\end{bmatrix}
$$

#### 구현

```csharp
public class LaplacianFilter
{
    // 기본 라플라시안 필터
    public static MyImage Apply(MyImage src, LaplacianType type = LaplacianType.FourConnected)
    {
        double[,] kernel = GetKernel(type);
        return ConvolutionProcessor.Convolve2D(src, kernel);
    }
    
    public enum LaplacianType
    {
        FourConnected,  // 4-방향
        EightConnected, // 8-방향
        Diagonal        // 대각선 강조
    }
    
    private static double[,] GetKernel(LaplacianType type)
    {
        return type switch
        {
            LaplacianType.FourConnected => new double[,]
            {
                { 0,  1, 0 },
                { 1, -4, 1 },
                { 0,  1, 0 }
            },
            
            LaplacianType.EightConnected => new double[,]
            {
                { 1,  1, 1 },
                { 1, -8, 1 },
                { 1,  1, 1 }
            },
            
            LaplacianType.Diagonal => new double[,]
            {
                { 0.5,  1, 0.5 },
                { 1,   -6,   1 },
                { 0.5,  1, 0.5 }
            },
            
            _ => throw new ArgumentException("Unknown Laplacian type")
        };
    }
    
    // 라플라시안 피라미드 (다중 스케일 에지 검출)
    public static List<MyImage> BuildLaplacianPyramid(MyImage src, int levels)
    {
        List<MyImage> pyramid = new List<MyImage>();
        MyImage current = src;
        
        for (int i = 0; i < levels; i++)
        {
            // 1. 다운샘플링
            MyImage downsampled = Downsample(current);
            
            // 2. 업샘플링
            MyImage upsampled = Upsample(downsampled, current.Width, current.Height);
            
            // 3. 라플라시안 계산 (원본 - 업샘플링)
            MyImage laplacian = SubtractImages(current, upsampled);
            
            pyramid.Add(laplacian);
            current = downsampled;
        }
        
        // 마지막 레벨 (가장 낮은 해상도)
        pyramid.Add(current);
        
        return pyramid;
    }
    
    // LoG (Laplacian of Gaussian) - 에지 검출용
    public static MyImage ApplyLoG(MyImage src, double sigma)
    {
        // LoG = 가우시안 블러 + 라플라시안
        // 효율적 구현: 가우시안 2차 미분 직접 계산
        
        int kernelSize = GaussianKernel.CalculateKernelSize(sigma);
        double[,] logKernel = CreateLoGKernel(kernelSize, sigma);
        
        return ConvolutionProcessor.Convolve2D(src, logKernel);
    }
    
    private static double[,] CreateLoGKernel(int size, double sigma)
    {
        double[,] kernel = new double[size, size];
        int k = size / 2;
        
        double sigma2 = sigma * sigma;
        double sigma4 = sigma2 * sigma2;
        
        for (int y = -k; y <= k; y++)
        {
            for (int x = -k; x <= k; x++)
            {
                double r2 = x * x + y * y;
                double value = -(1.0 / (Math.PI * sigma4)) * 
                    (1 - r2 / (2 * sigma2)) * Math.Exp(-r2 / (2 * sigma2));
                kernel[y + k, x + k] = value;
            }
        }
        
        return kernel;
    }
}
```

### 3. 고주파 증폭 필터 (High-Frequency Emphasis)

#### 주파수 도메인 접근법

```csharp
public class FrequencyDomainSharpening
{
    public static MyImage ApplyHighFrequencyEmphasis(MyImage src, 
        double alpha = 1.5, double beta = 0.5)
    {
        // 1. FFT 변환
        Complex[,] fft = FFT2D(ImageToComplex(src));
        
        // 2. 주파수 도메인에서 고주파 증폭
        int width = src.Width;
        int height = src.Height;
        
        for (int v = 0; v < height; v++)
        {
            for (int u = 0; u < width; u++)
            {
                // 주파수 거리 계산
                double du = u - width / 2;
                double dv = v - height / 2;
                double distance = Math.Sqrt(du * du + dv * dv);
                
                // 고주파 증폭 필터 함수
                double factor = alpha + beta * distance;
                
                fft[v, u] *= factor;
            }
        }
        
        // 3. 역 FFT
        Complex[,] ifft = IFFT2D(fft);
        
        // 4. 실수부 추출 및 정규화
        return ComplexToImage(ifft);
    }
}
```

---

## 비등방성 확산 (Anisotropic Diffusion)

### 수학적 모델

Perona-Malik 방정식:

$$
\frac{\partial I}{\partial t} = \text{div}(c(\|\nabla I\|) \nabla I)
$$

여기서 $$c(\cdot)$$는 확산 계수로, 에지에서 작고 평탄 영역에서 큽니다.

### 구현

```csharp
public class AnisotropicDiffusion
{
    public static MyImage Apply(MyImage src, 
        int iterations = 10, double lambda = 0.25, 
        double k = 10.0, DiffusionFunction function = DiffusionFunction.PeronaMalik1)
    {
        MyImage current = src.Clone();
        
        for (int iter = 0; iter < iterations; iter++)
        {
            MyImage next = new MyImage(current.Width, current.Height);
            
            // 각 픽셀에 대해 확산 업데이트
            for (int y = 1; y < current.Height - 1; y++)
            {
                for (int x = 1; x < current.Width - 1; x++)
                {
                    // 4-방향 기울기 계산
                    double northGrad = current.GetPixel(x, y-1) - current.GetPixel(x, y);
                    double southGrad = current.GetPixel(x, y+1) - current.GetPixel(x, y);
                    double eastGrad = current.GetPixel(x+1, y) - current.GetPixel(x, y);
                    double westGrad = current.GetPixel(x-1, y) - current.GetPixel(x, y);
                    
                    // 확산 계수 계산
                    double cn = DiffusionCoefficient(northGrad, k, function);
                    double cs = DiffusionCoefficient(southGrad, k, function);
                    double ce = DiffusionCoefficient(eastGrad, k, function);
                    double cw = DiffusionCoefficient(westGrad, k, function);
                    
                    // 업데이트 계산
                    double update = lambda * (
                        cn * northGrad + cs * southGrad + 
                        ce * eastGrad + cw * westGrad);
                    
                    double newValue = current.GetPixel(x, y) + update;
                    next.SetPixel(x, y, (byte)Math.Clamp(newValue, 0, 255));
                }
            }
            
            current = next;
        }
        
        return current;
    }
    
    public enum DiffusionFunction
    {
        PeronaMalik1,  // c = exp(-(∇I/k)²)
        PeronaMalik2   // c = 1/(1+(∇I/k)²)
    }
    
    private static double DiffusionCoefficient(double gradient, 
        double k, DiffusionFunction function)
    {
        double ratio = gradient / k;
        double ratio2 = ratio * ratio;
        
        return function switch
        {
            DiffusionFunction.PeronaMalik1 => Math.Exp(-ratio2),
            DiffusionFunction.PeronaMalik2 => 1.0 / (1.0 + ratio2),
            _ => 1.0
        };
    }
    
    // 다중 스케일 비등방성 확산
    public static MyImage ApplyMultiScale(MyImage src, 
        int iterations = 10, double[] kValues = null)
    {
        kValues ??= new double[] { 5.0, 10.0, 20.0 };
        
        MyImage result = src.Clone();
        
        foreach (double k in kValues)
        {
            result = Apply(result, iterations / kValues.Length, 0.25, k);
        }
        
        return result;
    }
}
```

---

## 고급 필터링 기법

### 1. 가이드 필터 (Guided Filter)

```csharp
public class GuidedFilter
{
    public static MyImage Apply(MyImage src, MyImage guide, 
        int radius, double epsilon)
    {
        // 가이드 필터: q_i = a_k I_i + b_k, ∀i ∈ ω_k
        // 선형 회귀를 통해 a_k, b_k 계산
        
        // 1. mean_I, mean_p 계산
        MyImage meanI = BoxFilter.Apply(guide, radius);
        MyImage meanP = BoxFilter.Apply(src, radius);
        
        // 2. corr_I, corr_Ip 계산
        MyImage corrI = BoxFilter.Apply(MultiplyImages(guide, guide), radius);
        MyImage corrIp = BoxFilter.Apply(MultiplyImages(guide, src), radius);
        
        // 3. var_I, cov_Ip 계산
        MyImage varI = SubtractImages(corrI, MultiplyImages(meanI, meanI));
        MyImage covIp = SubtractImages(corrIp, MultiplyImages(meanI, meanP));
        
        // 4. a, b 계산
        MyImage a = DivideImages(covIp, AddConstant(varI, epsilon));
        MyImage b = SubtractImages(meanP, MultiplyImages(a, meanI));
        
        // 5. mean_a, mean_b 계산
        MyImage meanA = BoxFilter.Apply(a, radius);
        MyImage meanB = BoxFilter.Apply(b, radius);
        
        // 6. 출력 계산: q = mean_a * I + mean_b
        return AddImages(MultiplyImages(meanA, guide), meanB);
    }
}
```

### 2. 위너 필터 (Wiener Filter)

```csharp
public class WienerFilter
{
    public static MyImage Apply(MyImage degraded, MyImage psf, 
        double noiseVar)
    {
        // 주파수 도메인 위너 필터
        // F(u,v) = [H*(u,v) / (|H(u,v)|² + K)] * G(u,v)
        
        // 1. FFT 변환
        Complex[,] gFFT = FFT2D(ImageToComplex(degraded));
        Complex[,] hFFT = FFT2D(ImageToComplex(psf));
        
        // 2. 위너 필터 적용
        Complex[,] fFFT = new Complex[degraded.Height, degraded.Width];
        
        for (int v = 0; v < degraded.Height; v++)
        {
            for (int u = 0; u < degraded.Width; u++)
            {
                Complex h = hFFT[v, u];
                Complex hConj = Complex.Conjugate(h);
                double hMag2 = h.MagnitudeSquared();
                
                // 위너 필터 계수
                Complex w = hConj / (hMag2 + noiseVar);
                
                fFFT[v, u] = w * gFFT[v, u];
            }
        }
        
        // 3. 역 FFT
        Complex[,] resultComplex = IFFT2D(fFFT);
        
        return ComplexToImage(resultComplex);
    }
}
```

### 3. 비국소 평균 필터 (Non-Local Means)

```csharp
public class NonLocalMeansFilter
{
    public static MyImage Apply(MyImage src, 
        int searchWindow = 21, int patchSize = 7, double h = 10.0)
    {
        MyImage dst = new MyImage(src.Width, src.Height);
        
        // 각 픽셀에 대해
        Parallel.For(0, src.Height, y =>
        {
            for (int x = 0; x < src.Width; x++)
            {
                double sumWeights = 0.0;
                double sumValues = 0.0;
                
                // 탐색 창 내의 모든 패치 고려
                for (int dy = -searchWindow/2; dy <= searchWindow/2; dy++)
                {
                    for (int dx = -searchWindow/2; dx <= searchWindow/2; dx++)
                    {
                        int nx = x + dx;
                        int ny = y + dy;
                        
                        if (nx >= 0 && nx < src.Width && 
                            ny >= 0 && ny < src.Height)
                        {
                            // 패치 유사도 계산
                            double similarity = CalculatePatchSimilarity(
                                src, x, y, nx, ny, patchSize);
                            
                            // 가중치 계산 (유사도 기반)
                            double weight = Math.Exp(-similarity / (h * h));
                            
                            sumWeights += weight;
                            sumValues += weight * src.GetPixel(nx, ny);
                        }
                    }
                }
                
                dst.SetPixel(x, y, (byte)(sumValues / sumWeights));
            }
        });
        
        return dst;
    }
    
    private static double CalculatePatchSimilarity(MyImage src, 
        int x1, int y1, int x2, int y2, int patchSize)
    {
        double sumSquaredDiff = 0.0;
        int count = 0;
        
        for (int dy = -patchSize/2; dy <= patchSize/2; dy++)
        {
            for (int dx = -patchSize/2; dx <= patchSize/2; dx++)
            {
                int nx1 = x1 + dx;
                int ny1 = y1 + dy;
                int nx2 = x2 + dx;
                int ny2 = y2 + dy;
                
                if (nx1 >= 0 && nx1 < src.Width && ny1 >= 0 && ny1 < src.Height &&
                    nx2 >= 0 && nx2 < src.Width && ny2 >= 0 && ny2 < src.Height)
                {
                    double diff = src.GetPixel(nx1, ny1) - src.GetPixel(nx2, ny2);
                    sumSquaredDiff += diff * diff;
                    count++;
                }
            }
        }
        
        return sumSquaredDiff / count;
    }
}
```

---

## 필터 요약 비교 및 선택 가이드

### 필터 성능 비교 표

| 필터 유형 | 시간 복잡도 | 노이즈 제거 | 에지 보존 | 세부 보존 | 적합한 노이즈 |
|-----------|------------|-------------|-----------|-----------|----------------|
| 평균 필터 | O(K²·N) | ⭐⭐ | ⭐ | ⭐ | 가우시안 |
| 가우시안 | O(K²·N) | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ | 가우시안 |
| 중앙값 | O(K²·N log K) | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 임펄스 |
| 양방향 | O(K²·N) | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 가우시안 |
| 비등방 확산 | O(I·N) | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | 가우시안+소금후추 |
| 비국소 평균 | O(S²·P²·N) | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 모든 유형 |
| 가이드 필터 | O(K²·N) | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 구조 보존 필요 시 |

### 필터 선택 의사결정 트리

```
영상 노이즈 유형?
├── 가우시안 노이즈
│   ├── 에지 보존 중요? → 양방향 필터
│   ├── 계산 효율 중요? → 가우시안 필터
│   └── 최고 품질 요구? → 비국소 평균
├── 소금-후추 노이즈
│   ├── 작은 노이즈 밀도 → 중앙값 필터
│   └── 높은 노이즈 밀도 → 적응형 중앙값
├── 포아송 노이즈
│   └── → 비등방 확산 필터
└── 알 수 없는 노이즈
    ├── 보존적 접근 → 가우시안 + 중앙값 혼합
    └── 공격적 접근 → 비국소 평균

필터링 목적?
├── 순수 노이즈 제거 → 위 필터 선택
├── 에지 검출 전처리 → 가우시안 (σ 작게)
├── 영상 선명화 → 언샤프 마스킹
├── 구조-텍스처 분리 → 가이드 필터
└── 영상 복원 → 위너 필터
```

### 매개변수 튜닝 가이드라인

| 필터 | 주요 매개변수 | 튜닝 가이드 | 영향 |
|------|--------------|-------------|------|
| **가우시안** | σ (표준편차) | σ ≈ 노이즈 표준편차 × 1.5 | σ↑ → 더 많은 블러 |
| **중앙값** | 커널 크기 K | K ≈ 2×노이즈 크기 + 1 | K↑ → 더 강한 노이즈 제거 |
| **양방향** | σ_s, σ_r | σ_s ≈ 3-5, σ_r ≈ 10-20 | σ_r↑ → 더 많은 에지 보존 |
| **비등방 확산** | k, λ | k ≈ 10-30, λ ≤ 0.25 | k↑ → 더 많은 에지 보존 |
| **언샤프 마스크** | 강도 λ | λ = 0.5-2.0 | λ↑ → 더 강한 샤프닝 |

---

## 실제 응용 사례

### 의료 영상 처리 파이프라인

```csharp
public class MedicalImagePipeline
{
    public MyImage ProcessCTScan(MyImage rawScan)
    {
        // 1. 잡음 제거 (의료 영상 특성 고려)
        MyImage denoised = ApplyMedicalDenoising(rawScan);
        
        // 2. 에지 강화 (병변 경계 선명화)
        MyImage enhanced = AdaptiveEdgeEnhancement(denoised);
        
        // 3. 다중 스케일 분석
        MyImage multiScale = MultiScaleAnalysis(enhanced);
        
        return multiScale;
    }
    
    private MyImage ApplyMedicalDenoising(MyImage scan)
    {
        // 의료 영상 특성: 저조도, 고주파 잡음
        // 1. 비등방 확산으로 기본 잡음 제거
        MyImage step1 = AnisotropicDiffusion.Apply(scan, 
            iterations: 15, k: 15.0);
        
        // 2. 작은 임펄스 노이즈 제거
        MyImage step2 = MedianFilter.Apply(step1, kernelSize: 3);
        
        // 3. 구조 보존 필터링
        return BilateralFilter.Apply(step2, 
            spatialSigma: 2.0, rangeSigma: 25.0);
    }
}
```

### 실시간 컴퓨터 비전 시스템

```csharp
public class RealTimeVisionSystem
{
    public MyImage ProcessFrame(MyImage frame)
    {
        // 실시간 제약 조건: < 16ms/frame (60 FPS)
        
        // 1. 빠른 노이즈 감소 (최적화된 필터)
        MyImage denoised = FastBilateralFilter.ApplyFast(frame);
        
        // 2. GPU 가속 회선 (OpenCL/CUDA)
        MyImage features = ExtractFeaturesGPU(denoised);
        
        // 3. 피라미드 기반 다중 해상도 처리
        List<MyImage> pyramid = BuildGaussianPyramid(features, 3);
        
        return CombinePyramid(pyramid);
    }
    
    private MyImage FastBilateralFilter.ApplyFast(MyImage src)
    {
        // 분리 가능 근사 + LUT 사용
        // SIMD 병렬 처리 적용
        return OptimizedBilateralFilter(src);
    }
}
```

---

## 결론 및 구현 지침

### 핵심 원칙 정리

1. **필터 선택은 목적에 따라**: 노이즈 제거, 에지 검출, 선명화 등 목적에 맞는 필터 선택
2. **매개변수 민감성 이해**: 각 필터의 매개변수 영향을 이해하고 신중히 튜닝
3. **계산 비용 고려**: 실시간 시스템에서는 복잡도와 성능의 균형 중요
4. **하이브리드 접근법**: 단일 필터보다 여러 필터의 조합이 효과적인 경우 많음

### 모범 사례 체크리스트

- [ ] 적절한 패딩 전략 선택 (경계 처리)
- [ ] 필터 크기는 홀수로 설정
- [ ] 정규화 확인 (가중치 합 = 1)
- [ ] 다중 스레딩/GPU 가속 활용
- [ ] 메모리 접근 패턴 최적화
- [ ] 정밀도와 성능의 균형
- [ ] 적절한 데이터 타입 선택 (byte, float, double)
- [ ] 캐시 친화적인 메모리 레이아웃

### 미래 발전 방향

1. **딥러닝 기반 필터링**: 신경망을 이용한 적응형 필터 학습
2. **지능형 매개변수 튜닝**: 영상 내용 분석 기반 자동 튜닝
3. **하드웨어 특화 구현**: FPGA, GPU, TPU용 최적화
4. **3D/비디오 필터링**: 시공간적(spatio-temporal) 필터링
5. **양자 영상 처리**: 양자 알고리즘을 활용한 고속 필터링

공간적 필터링은 영상 처리의 핵심 기법으로, 기본 원리를 이해하고 다양한 필터의 특성을 파악하는 것이 효과적인 영상 처리 시스템 개발의 기초가 됩니다.