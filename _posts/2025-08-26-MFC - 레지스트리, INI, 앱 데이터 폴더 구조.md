---
layout: post
title: MFC - 레지스트리, INI, 앱 데이터 폴더 구조
date: 2025-08-26 15:25:23 +0900
category: MFC
---
# 파일/설정 저장: 레지스트리, INI, 앱 데이터 폴더 구조 (MFC 관점 총정리 · 실전 예제 포함)

이 글은 **MFC 애플리케이션의 설정/상태**를 어디에, 어떻게 저장할지에 대한 **실전 가이드**입니다.  
대상: MFC `CWinApp`/`CWinAppEx` 기반 앱(대화상자/SDI/MDI 모두), Windows 10/11 환경.

---

## 0) 한눈에 보는 선택 기준

| 상황 | 추천 저장소 | 이유/메모 |
|---|---|---|
| **개인별(사용자별) 설정** (테마, 최근 파일, 창 위치 등) | **레지스트리 HKCU** 또는 **`%APPDATA%`(Roaming)** | 계정별 격리/프로필 로밍(AD/도메인) |
| **캐시/썸네일/큰 임시 데이터** | **`%LOCALAPPDATA%`(Local)** | 용량 큼, 로밍 불필요 |
| **머신 전체 설정(모든 사용자 공통)** | **`%PROGRAMDATA%`** 또는 **레지스트리 HKLM(관리자 권한 필요)** | 시스템 범위, 배포·정책과 궁합 |
| **휴대/외부 편집이 쉬운 텍스트 설정** | **INI/JSON 파일(앱 데이터 하위)** | 백업/이식성, 형상관리 친화 |
| **UI 상태 자동 저장(MFC Feature Pack 도킹/리본 등)** | **레지스트리 HKCU** | MFC가 레지스트리 기반 헬퍼 제공 |

> 원칙: **코드/실행 파일 폴더(Program Files)** 에 쓰지 마세요(UAC로 차단/가상화).  
> 사용자 데이터는 **사용자 폴더**, 시스템 전역은 **ProgramData/HKLM**에 둡니다.

---

## 1) 레지스트리(Registry)

### 1-1. 기본 개념 & 경로
- **HKCU**(HKEY_CURRENT_USER): 현재 사용자 **개인 영역**. 앱 설정의 기본.
- **HKLM**(HKEY_LOCAL_MACHINE): **머신 전역**. 설치(관리자)에서 1회 기록, 런타임은 보통 읽기 전용.
- `SetRegistryKey(L"회사명")` 호출 후 `GetProfile…/WriteProfile…` 계열로 **간편 접근**.

```cpp
// CYourApp::InitInstance()
SetRegistryKey(L"Acme");                 // HKCU\Software\Acme\YourApp\...
// CWinAppEx 사용 시: SetRegistryBase(L"Software\\Acme\\YourApp");
WriteProfileString(L"Settings", L"Theme", L"Dark");
int lang = GetProfileInt(L"Settings", L"LanguageId", 1042);
```

### 1-2. 장단점
- **장점**: 빠른 조회, 트랜잭션성(상대적으로 안전), ACL, MFC UI 상태 저장과 궁합.
- **단점**: 사용자에게 **가시성/이식성** 떨어짐(백업·복원 UX 별도 제공 권장).

### 1-3. 키 설계 팁 & 버저닝
- 예시(개념)
```
HKCU\Software\Acme\PhotoTool\
  Settings\Theme="Dark"
  Settings\ConfigVersion=3
  UI\MainWindow\Pos="x=120,y=80,w=1280,h=800"
  UI\Ribbon\State=<BINARY>
```
- **`ConfigVersion`** 값을 두고 앱 시작 시 **마이그레이션**.

### 1-4. 보안/권한
- **민감 정보(토큰/암호)**: 평문 금지 → **DPAPI** 사용.

```cpp
// DPAPI 예시: 문자열을 사용자 바운드로 암호화하여 레지스트리에 저장
#include <wincrypt.h>
#pragma comment(lib, "crypt32.lib")

static BOOL ProtectString(const CString& plain, std::vector<BYTE>& out)
{
    DATA_BLOB in { (DWORD)((plain.GetLength()+1) * sizeof(wchar_t)), (BYTE*)plain.GetString() };
    DATA_BLOB enc{};
    if (!CryptProtectData(&in, L"cfg", nullptr, nullptr, nullptr, 0, &enc)) return FALSE;
    out.assign(enc.pbData, enc.pbData + enc.cbData);
    LocalFree(enc.pbData);
    return TRUE;
}

static BOOL UnprotectString(const BYTE* data, DWORD cb, CString& outStr)
{
    DATA_BLOB in{ cb, (BYTE*)data }, dec{};
    if (!CryptUnprotectData(&in, nullptr, nullptr, nullptr, nullptr, 0, &dec)) return FALSE;
    outStr = (LPCWSTR)dec.pbData;
    LocalFree(dec.pbData);
    return TRUE;
}
```

---

## 2) INI/JSON 등 파일 기반 설정

### 2-1. INI 개요(간단한 키-값)
```ini
[Settings]
Theme=Dark
Language=ko-KR

[Window]
X=120
Y=80
W=1280
H=800
```
- **장점**: 가볍고 휴대성 좋음.  
- **단점**: 배열/중첩 구조 취약, 인코딩 일관성·동시성·원자성 이슈.

```cpp
// INI 읽기/쓰기 (레거시 Win32 API)
CString path = L"C:\\Users\\...\\AppData\\Roaming\\Acme\\YourApp\\settings.ini";
WCHAR buf[256]{};
GetPrivateProfileString(L"Settings", L"Theme", L"Light", buf, 256, path);
WritePrivateProfileString(L"Settings", L"Theme", L"Dark", path);
```

### 2-2. JSON 권장 시나리오
- **복잡한 구조/배열**이 많을 때 유리. `"configVersion"` 포함.
- **원자적 저장**(tmp→교체), **UTF-8 with BOM** 등 인코딩 명시.

```cpp
// JSON 저장(경량 예시: 직접 직렬화, 실제로는 JSON 라이브러리 권장)
BOOL SaveJson(const CString& file, const std::map<CString,CString>& kv)
{
    CStdioFile f; if (!f.Open(file, CFile::modeCreate|CFile::modeWrite|CFile::typeText)) return FALSE;
    f.WriteString(L"{\n");
    size_t i=0; for (auto& p : kv) {
        CString line; line.Format(L"  \"%s\": \"%s\"%s\n", p.first.GetString(), p.second.GetString(),
                                  (++i<kv.size())?L",":L"");
        f.WriteString(line);
    }
    f.WriteString(L"}\n"); f.Close(); return TRUE;
}
```

---

## 3) 앱 데이터 폴더 구조(권장 레이아웃)

### 3-1. Known Folder 경로 얻기
```cpp
#include <ShlObj.h> // SHGetKnownFolderPath
#pragma comment(lib, "Shell32.lib")

static CString GetKnownFolder(REFKNOWNFOLDERID id)
{
    PWSTR p = nullptr; CString s;
    if (SUCCEEDED(SHGetKnownFolderPath(id, KF_FLAG_DEFAULT, nullptr, &p))) {
        s = p; CoTaskMemFree(p);
    }
    return s;
}

CString roam = GetKnownFolder(FOLDERID_RoamingAppData);  // %APPDATA%
CString local= GetKnownFolder(FOLDERID_LocalAppData);    // %LOCALAPPDATA%
CString common=GetKnownFolder(FOLDERID_ProgramData);     // %PROGRAMDATA%
```

### 3-2. 디렉터리 생성 & 레이아웃
```
%APPDATA%\Acme\PhotoTool\
  config\settings.json      // 로밍 설정
  config\shortcuts.json
  profiles\default\presets.json
%LOCALAPPDATA%\Acme\PhotoTool\
  cache\thumbs\*
  logs\app-2025-10-10.log
  temp\export\*
%PROGRAMDATA%\Acme\PhotoTool\
  machine.conf              // 머신 전역(설치 시)
```

```cpp
#include <Shlwapi.h>
#pragma comment(lib, "Shlwapi.lib")
#include <Shellapi.h>

static BOOL EnsureDir(PCWSTR path)
{
    return SHCreateDirectoryEx(nullptr, path, nullptr) == ERROR_SUCCESS ||
           PathIsDirectory(path);
}
```

---

## 4) CWinApp/CWinAppEx 프로필 API (추상화)

- `SetRegistryKey("회사명")` 이후:
  - `GetProfileInt/String/Section` ←→ `WriteProfileInt/String`
  - MRU(`CRecentFileList`), 도킹/리본 상태(`CWinAppEx::LoadState/SaveState`)와 **자동 연동**.

```cpp
// UI 상태 자동 저장(Feature Pack)
BOOL CYourApp::InitInstance()
{
    SetRegistryKey(L"Acme");
    // 상태 저장 루트 지정(옵션)
    // SetRegistryBase(L"Software\\Acme\\YourApp");
    LoadStdProfileSettings(10); // MRU
    return TRUE;
}
// 종료 시 또는 적절한 시점
// theApp.SaveState(); // 리본/도킹 등
// theApp.LoadState();
```

---

## 5) 원자적(안전) 쓰기 & 동시성

### 5-1. 파일 원자적 저장
1) `settings.json.tmp`에 쓰기 →  
2) **Flush & Close** →  
3) **교체**(`ReplaceFileW` 또는 `MoveFileEx(MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH)`).

```cpp
static BOOL AtomicReplace(PCWSTR finalPath, PCWSTR tmpPath, BOOL keepBackup)
{
    CString backup(finalPath); backup += L".bak";
    if (!PathFileExists(finalPath))
        return MoveFileEx(tmpPath, finalPath, MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH);
    if (ReplaceFileW(finalPath, tmpPath, backup, REPLACEFILE_WRITE_THROUGH, nullptr, nullptr))
        { if (!keepBackup) DeleteFileW(backup); return TRUE; }
    return FALSE;
}
```

### 5-2. 다중 인스턴스 동시 쓰기 방지
- **네임드 뮤텍스** 또는 **파일 잠금**.

```cpp
// 네임드 뮤텍스
HANDLE g_hMutex = CreateMutexW(nullptr, FALSE, L"Global\\YourApp.SettingsMutex");
// 저장 시:
WaitForSingleObject(g_hMutex, INFINITE);
// ... 쓰기 ...
ReleaseMutex(g_hMutex);

// 파일 잠금
HANDLE h = CreateFileW(path, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, nullptr, OPEN_ALWAYS, 0, nullptr);
OVERLAPPED ov{}; LockFileEx(h, LOCKFILE_EXCLUSIVE_LOCK, 0, MAXDWORD, MAXDWORD, &ov);
// ... 쓰기 ...
UnlockFileEx(h, 0, MAXDWORD, MAXDWORD, &ov);
CloseHandle(h);
```

---

## 6) 민감 정보 보호(필수)

- **DPAPI**(위 예제 참고)로 **유저/머신 바운드** 암호화 후 저장(레지스트리/파일 어디든).
- **키 회전/백업**: 가능한 **재발급 가능한 토큰**만 저장. 복구 불가 정책 고려(문서화).
- **로그**에 민감 값 출력 금지(마스킹).

---

## 7) 마이그레이션 & 호환성

- 설정에 **`ConfigVersion`** 저장 → 시작 시 현재 버전과 다르면 **변환기** 실행.
- 변환 전 **백업**(`.bak`) 생성.
- **레거시 INI/레지스트리 경로**에서 새로 설계한 AppData/레지스트리로 **초기 실행에 이관**(사용자 안내).

```cpp
// 예: 레거시 INI → JSON 마이그레이션 스케치
if (legacyIniExists && !newJsonExists) {
    // 읽기 → Map으로 구성 → SaveJson(newJsonPath, map);
    // 성공 시 legacyIni를 backup으로 이동
}
```

---

## 8) 백업/내보내기 UX

- **메뉴**: “설정 내보내기/가져오기”
  - 레지스트리: 앱이 **자체 JSON**으로 덤프(권장) 또는 `.reg` 익스포트 제공.
  - 파일 설정: `%APPDATA%\Vendor\App\config` **압축**/해제.
- **자동 스냅샷**: 대규모 변경 전에 `settings-YYYYMMDD-HHMM.json.bak`.

---

## 9) UAC/가상화/권한 주의

- Program Files/Windows 폴더에 **쓰기 금지**.  
- **HKLM/ProgramData**는 쓰기에 관리자 권한 필요할 수 있음(설치 시 초기화).
- 오래된 앱 호환 **가상화(Registry/File Virtualization)** 를 의존하지 말 것(예측 불가).

---

## 10) 로깅·캐시·정리 정책

- **경로 분리**: 설정(작음) vs 캐시/로그(큼).
- **로그 롤링**: 크기/일자 기준, 보관 기한 명시.
- **캐시 정리**: 용량 상한/최종 사용 시각 기준 청소.

```cpp
// 간단 로그 열기(UTF-8 BOM)
CStdioFile log;
log.Open(logPath, CFile::modeCreate|CFile::modeNoTruncate|CFile::modeWrite|CFile::typeText);
log.SeekToEnd();
log.WriteString(L"[2025-10-10 04:00] App started\n");
log.Close();
```

---

## 11) 실무 권장 조합(템플릿)

- **일반 데스크톱 앱**
  - 사용자 설정/최근 항목/도킹 상태 → **HKCU 레지스트리(프로필 API)**  
  - 복잡 설정/단축키 → **`%APPDATA%\Vendor\App\config\*.json`**  
  - 캐시/썸네일/로그 → **`%LOCALAPPDATA%\Vendor\App\...`**
- **기업 배포**
  - 기본 정책/라이선스/프록시 → **`%PROGRAMDATA%`** 또는 **HKLM**(설치 시)  
  - 사용자 오버라이드 → HKCU/`%APPDATA%` (레이어링: 사용자 값이 우선)

---

## 12) 체크리스트(최종)

1. **저장 위치**: HKCU/APPDATA/LOCALAPPDATA/PROGRAMDATA 구분이 명확한가?  
2. **원자적 저장**: tmp→교체, 크래시/전원 차단 시 **손상 최소화** 설계가 있는가?  
3. **동시성**: 다중 인스턴스/프로세스에서 **락**이 있는가?  
4. **보안**: 민감 정보는 **DPAPI**로 암호화했는가?  
5. **버전/마이그레이션**: `ConfigVersion`과 변환기, 백업·되돌리기가 준비됐는가?  
6. **로깅/캐시**: 크기/기한/정리 정책이 문서화됐는가?  
7. **백업/복원 UX**: 내보내기/가져오기 경로가 사용자 친화적인가?  
8. **테스트**: 권한/UAC/도메인 로밍/프로필 격리/오프라인에서 동작 확인했는가?

---

## 13) 미니 래퍼 설계 스케치(혼합 백엔드)

> 동일 인터페이스로 **Registry** ↔ **JSON 파일** 백엔드를 교체 가능하게.

```cpp
struct ISettingsStore {
    virtual bool LoadString(LPCWSTR sec, LPCWSTR key, CString& out) = 0;
    virtual bool SaveString(LPCWSTR sec, LPCWSTR key, LPCWSTR val) = 0;
    virtual bool LoadInt(LPCWSTR sec, LPCWSTR key, int& out, int def=0) = 0;
    virtual bool SaveInt(LPCWSTR sec, LPCWSTR key, int val) = 0;
    virtual ~ISettingsStore() {}
};

struct RegSettings : ISettingsStore {
    bool LoadString(LPCWSTR s, LPCWSTR k, CString& out) override {
        out = AfxGetApp()->GetProfileString(s, k, L""); return !out.IsEmpty();
    }
    bool SaveString(LPCWSTR s, LPCWSTR k, LPCWSTR v) override {
        return AfxGetApp()->WriteProfileString(s, k, v);
    }
    bool LoadInt(LPCWSTR s, LPCWSTR k, int& out, int def=0) override {
        out = AfxGetApp()->GetProfileInt(s, k, def); return true;
    }
    bool SaveInt(LPCWSTR s, LPCWSTR k, int v) override {
        return AfxGetApp()->WriteProfileInt(s, k, v);
    }
};

// JsonSettings는 내부 Map 캐시 + AtomicReplace 활용 (생략)
```

---

### 마무리

- **저장 위치를 올바르게 설계**하면 권한/배포/백업/성능 문제의 대부분이 예방됩니다.  
- **레지스트리(MFC 프로필)** 는 **가벼운 설정 & UI 상태**에 최적,  
  **앱 데이터(파일)** 는 **이식/편집/대용량/복잡 구조**에 강합니다.  
- 위의 폴더 구조/원자적 저장/보안/동시성/마이그레이션 체크리스트를 **프로젝트 초기에** 반영하세요.  
  그러면 이후 **기능 확장·유지보수**가 훨씬 수월해집니다.