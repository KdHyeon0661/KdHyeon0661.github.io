---
layout: post
title: 영상처리 - EXIF/메타데이터 처리
date: 2025-10-09 19:25:23 +0900
category: 영상처리
---
# EXIF/메타데이터 처리 (Orientation 포함)

## 왜 Orientation을 적용해야 하나?

스마트폰은 카메라 센서의 물리적 방향과 촬영 자세(세로/가로)가 항상 일치하지 않습니다. 많은 기기는 **픽셀은 회전 없이 저장**하고, 그 대신 **EXIF Orientation 태그(0x0112)** 에 “이 이미지는 이렇게 보이게 회전/반전해서 표시하라”는 **지시만 기록**합니다.
EXIF를 무시하고 픽셀만 그대로 그리면, 세로 사진이 **90° 돌아가 보이는** 문제가 생깁니다.

---

## Orientation 값과 실제 변환의 매핑

EXIF 표준(태그 0x0112, **SHORT**) 값 → 실제 화면 변환:

| 값 | 의미(표준 명칭) | 실제 픽셀 변환 (우리 도구가 해야 할 것) |
|---:|---|---|
| 1 | Top-left | 변환 없음 |
| 2 | Top-right | 좌우 반전 (Horizontal flip) |
| 3 | Bottom-right | 180° 회전 |
| 4 | Bottom-left | 상하 반전 (Vertical flip) |
| 5 | Left-top (**Transpose**) | **전치**(주대각선 대칭) = 90° CW 후 수평 반전과 동치 |
| 6 | Right-top | 90° **CW** 회전 |
| 7 | Right-bottom (**Transverse**) | **역전치**(부대각선 대칭) = 90° CW 후 수직 반전과 동치 |
| 8 | Left-bottom | 90° **CCW** 회전 |

> 팁: 5/7은 단순 회전이 아니라 **대각선 대칭**입니다. 구현은 “Transpose/Transverse” 전용 함수로 두거나, **회전+반전**의 조합으로 구현하면 됩니다.

---

## 파이프라인 개요

1. **디코더 설정**: `jpeg_save_markers(&cinfo, JPEG_APP0+1, 0xFFFF)` — APP1(EXIF)을 통째로 보관
2. **헤더 읽기**: `jpeg_read_header` → `cinfo.marker_list` 에 APP1들이 연결 리스트로 저장
3. **EXIF 블록 선택**: **"Exif\0\0"** 시그니처를 가진 **APP1** 찾기
4. **TIFF 파싱**: 엔디언(II/MM)·IFD0를 읽고 **태그 0x0112**(Orientation) 찾기
5. **픽셀 변환**: Orientation 값에 따라 `IppDib`에 **회전/반전 적용**
6. **저장 시 메타 유지**: 원본 APP1(그리고 원하면 ICC 등 APP2) **재주입**
   - Orientation을 픽셀에 적용했다면, 다음 저장 시 **Orientation=1** 로 **갱신**(또는 해당 태그 제거)하여 **이중 회전 방지**

---

## 코드 — **EXIF 읽기 + 회전/반전 적용 + 메타 유지 저장**

아래는 의존 라이브러리 없이 동작하는 **미니 EXIF 파서**와 `IppDib` 변환 유틸, 그리고 **로드/세이브**까지 한 번에 담은 실전 코드입니다.

```cpp
// ExifOrientation.hpp
#pragma once
#include <cstdint>
#include <vector>
#include <string>
#include <cstring>
#include <cstdio>
#include <cassert>
#include <jpeglib.h>
#include "IppDib.h"

// ----------------------------
// 1) JPEG marker 유틸
// ----------------------------
struct SavedMarker {
    int marker = 0;                 // JPEG_APP0 + n
    std::vector<uint8_t> data;      // payload
};

inline void JpegEnableSaveExif(j_decompress_ptr cinfo){
    // APP1(EXIF) 전체 저장
    jpeg_save_markers(cinfo, JPEG_APP0 + 1, 0xFFFF);
    // ICC(APP2)나 XMP(APP1) 등도 보존하려면 추가:
    // jpeg_save_markers(cinfo, JPEG_APP0 + 2, 0xFFFF); // ICC
}

inline std::vector<SavedMarker> JpegCollectSavedMarkers(j_decompress_ptr cinfo){
    std::vector<SavedMarker> out;
    for (jpeg_saved_marker_ptr m = cinfo->marker_list; m; m = m->next){
        SavedMarker sm; sm.marker = m->marker;
        sm.data.assign(m->data, m->data + m->data_length);
        out.push_back(std::move(sm));
    }
    return out;
}

// ----------------------------
// 2) EXIF APP1 찾기 (Exif\0\0)
// ----------------------------
inline int FindExifAPP1(const std::vector<SavedMarker>& markers){
    for (int i=0;i<(int)markers.size();++i){
        if (markers[i].marker == JPEG_APP0 + 1){
            const auto& d = markers[i].data;
            if (d.size() >= 6 && std::memcmp(d.data(), "Exif\0\0", 6) == 0)
                return i;
        }
    }
    return -1;
}

// ----------------------------
// 3) 간단한 TIFF/EXIF 파서 (Orientation만)
// ----------------------------
struct TiffView {
    const uint8_t* base = nullptr;  // TIFF 헤더의 시작
    size_t size = 0;                // TIFF 영역 크기
    bool bigEndian = false;         // 'MM'면 true, 'II'면 false
};

inline uint16_t rd16(const TiffView& t, const uint8_t* p){
    uint16_t v; std::memcpy(&v, p, 2);
    if (t.bigEndian) return (uint16_t)((v>>8) | (v<<8));
    return v;
}
inline uint32_t rd32(const TiffView& t, const uint8_t* p){
    uint32_t v; std::memcpy(&v, p, 4);
    if (t.bigEndian) return (v>>24)|((v>>8)&0x0000FF00)|((v<<8)&0x00FF0000)|(v<<24);
    return v;
}

// 안전 범위 체크
inline bool inRange(const TiffView& t, const uint8_t* p, size_t need){
    if (p < t.base) return false;
    size_t off = (size_t)(p - t.base);
    return (off + need) <= t.size;
}

// Orientation 파싱: 성공 시 true, 값은 1..8 중 하나 (기본 1)
inline bool ParseExifOrientation(const uint8_t* exifData, size_t exifLen, uint16_t& outOrient){
    outOrient = 1;
    if (!exifData || exifLen < 14) return false;
    // "Exif\0\0" + TIFF header
    if (std::memcmp(exifData, "Exif\0\0", 6) != 0) return false;

    TiffView tv;
    tv.base = exifData + 6;
    tv.size = exifLen  - 6;
    if (tv.size < 8) return false;

    // 엔디언
    if (!inRange(tv, tv.base, 8)) return false;
    if (tv.base[0]=='M' && tv.base[1]=='M') tv.bigEndian = true;
    else if (tv.base[0]=='I' && tv.base[1]=='I') tv.bigEndian = false;
    else return false;

    // TIFF magic 42
    if (rd16(tv, tv.base+2) != 42) return false;

    // 0th IFD offset
    uint32_t ifd0Off = rd32(tv, tv.base+4);
    if (ifd0Off >= tv.size) return false;
    const uint8_t* ifd = tv.base + ifd0Off;
    if (!inRange(tv, ifd, 2)) return false;

    uint16_t count = rd16(tv, ifd); ifd += 2;
    // 각 엔트리 12바이트
    for (uint16_t i=0;i<count;++i){
        const uint8_t* ent = ifd + i*12;
        if (!inRange(tv, ent, 12)) return false;

        uint16_t tag  = rd16(tv, ent+0);
        uint16_t type = rd16(tv, ent+2);
        uint32_t num  = rd32(tv, ent+4);
        const uint8_t* val = ent+8;

        if (tag == 0x0112){ // Orientation
            // Type 3 (SHORT), count >= 1
            if (type != 3 || num < 1) break;

            uint16_t v = 1;
            if (num == 1){
                // 값이 2바이트라면 4바이트 슬롯의 하위 2바이트에 저장
                if (!inRange(tv, val, 2)) return false;
                v = rd16(tv, val);
            }else{
                // 값이 여러 개인 경우, val는 오프셋
                uint32_t off = rd32(tv, val);
                if (off + num*2 > tv.size) return false;
                v = rd16(tv, tv.base + off); // 첫 값
            }
            if (v >= 1 && v <= 8) { outOrient = v; return true; }
            break;
        }
    }
    return false; // 태그 없음
}

// Orientation 값을 EXIF 블록에 "제자리 수정" (1..8)
// 성공하면 true. 실패하면 false (그럴 땐 저장 시 해당 태그 제거를 고려)
inline bool PatchExifOrientationInPlace(std::vector<uint8_t>& exifAPP1, uint16_t newVal){
    if (exifAPP1.size() < 14) return false;
    if (std::memcmp(exifAPP1.data(), "Exif\0\0", 6) != 0) return false;
    TiffView tv{ exifAPP1.data()+6, exifAPP1.size()-6, false };
    if (tv.size < 8) return false;

    if (tv.base[0]=='M' && tv.base[1]=='M') tv.bigEndian = true;
    else if (tv.base[0]=='I' && tv.base[1]=='I') tv.bigEndian = false;
    else return false;

    if (rd16(tv, tv.base+2) != 42) return false;
    uint32_t ifd0Off = rd32(tv, tv.base+4);
    if (ifd0Off >= tv.size) return false;
    const uint8_t* ifd = tv.base + ifd0Off;
    if (!inRange(tv, ifd, 2)) return false;

    uint16_t count = rd16(tv, ifd); ifd += 2;
    for (uint16_t i=0;i<count;++i){
        uint8_t* ent = const_cast<uint8_t*>(ifd) + i*12;
        if (!inRange(tv, ent, 12)) return false;

        uint16_t tag  = rd16(tv, ent+0);
        uint16_t type = rd16(tv, ent+2);
        uint32_t num  = rd32(tv, ent+4);
        uint8_t*  val = ent+8;

        if (tag == 0x0112 && type==3 && num>=1){
            if (num==1){
                if (!inRange(tv, val, 2)) return false;
                // 쓰기 (엔디언 보정)
                if (tv.bigEndian){ val[0] = (uint8_t)(newVal>>8); val[1]=(uint8_t)newVal; }
                else              { val[0] = (uint8_t)newVal;     val[1]=(uint8_t)(newVal>>8); }
                return true;
            }else{
                uint32_t off = rd32(tv, val);
                if (off + num*2 > tv.size) return false;
                uint8_t* p = const_cast<uint8_t*>(tv.base) + off;
                if (tv.bigEndian){ p[0]=(uint8_t)(newVal>>8); p[1]=(uint8_t)newVal; }
                else              { p[0]=(uint8_t)newVal;     p[1]=(uint8_t)(newVal>>8); }
                return true;
            }
        }
    }
    return false;
}

// ----------------------------
// 4) IppDib 회전/반전 유틸
// ----------------------------
inline IppDib FlipH(const IppDib& s){
    IppDib d; if (!s) return d;
    d.create(s.width(), s.height(), 32);
    for (int y=0;y<s.height();++y){
        const uint8_t* src = (const uint8_t*)s.bits() + (size_t)y*s.stride();
        uint8_t* dst = (uint8_t*)d.bits() + (size_t)y*d.stride();
        for (int x=0;x<s.width();++x){
            const uint8_t* p = src + (size_t)(s.width()-1-x)*4;
            std::memcpy(dst + x*4, p, 4);
        }
    }
    return d;
}
inline IppDib FlipV(const IppDib& s){
    IppDib d; if (!s) return d;
    d.create(s.width(), s.height(), 32);
    for (int y=0;y<s.height();++y){
        const uint8_t* src = (const uint8_t*)s.bits() + (size_t)(s.height()-1-y)*s.stride();
        std::memcpy((uint8_t*)d.bits() + (size_t)y*d.stride(), src, (size_t)s.width()*4);
    }
    return d;
}
inline IppDib Rot90CW(const IppDib& s){
    IppDib d; if (!s) return d;
    d.create(s.height(), s.width(), 32);
    for (int y=0;y<s.height();++y){
        const uint8_t* src = (const uint8_t*)s.bits() + (size_t)y*s.stride();
        for (int x=0;x<s.width();++x){
            uint8_t* pd = (uint8_t*)d.bits() + (size_t)x*d.stride() + (d.width()-1 - y)*4;
            std::memcpy(pd, src + x*4, 4);
        }
    }
    return d;
}
inline IppDib Rot90CCW(const IppDib& s){
    IppDib d; if (!s) return d;
    d.create(s.height(), s.width(), 32);
    for (int y=0;y<s.height();++y){
        const uint8_t* src = (const uint8_t*)s.bits() + (size_t)y*s.stride();
        for (int x=0;x<s.width();++x){
            uint8_t* pd = (uint8_t*)d.bits() + (size_t)(d.height()-1 - x)*d.stride() + y*4;
            std::memcpy(pd, src + x*4, 4);
        }
    }
    return d;
}
inline IppDib Rot180(const IppDib& s){
    IppDib d; if (!s) return d;
    d.create(s.width(), s.height(), 32);
    for (int y=0;y<s.height();++y){
        const uint8_t* src = (const uint8_t*)s.bits() + (size_t)y*s.stride();
        uint8_t* dst = (uint8_t*)d.bits() + (size_t)(d.height()-1-y)*d.stride();
        for (int x=0;x<s.width();++x){
            const uint8_t* p = src + (size_t)(s.width()-1-x)*4;
            std::memcpy(dst + x*4, p, 4);
        }
    }
    return d;
}
// Transpose: (x,y) -> (y,x)
inline IppDib Transpose(const IppDib& s){
    IppDib d; if (!s) return d;
    d.create(s.height(), s.width(), 32);
    for (int y=0;y<s.height();++y){
        const uint8_t* src = (const uint8_t*)s.bits() + (size_t)y*s.stride();
        for (int x=0;x<s.width();++x){
            uint8_t* pd = (uint8_t*)d.bits() + (size_t)x*d.stride() + y*4;
            std::memcpy(pd, src + x*4, 4);
        }
    }
    return d;
}
// Transverse: (x,y) -> (W-1-y, H-1-x)
inline IppDib Transverse(const IppDib& s){
    IppDib d; if (!s) return d;
    d.create(s.height(), s.width(), 32);
    for (int y=0;y<s.height();++y){
        const uint8_t* src = (const uint8_t*)s.bits() + (size_t)y*s.stride();
        for (int x=0;x<s.width();++x){
            uint8_t* pd = (uint8_t*)d.bits() + (size_t)(d.height()-1 - x)*d.stride() + (d.width()-1 - y)*4;
            std::memcpy(pd, src + x*4, 4);
        }
    }
    return d;
}

// Orientation 코드 -> 변환 적용
inline IppDib ApplyExifOrientation(const IppDib& in, uint16_t o){
    switch(o){
    default: case 1: return in;                // no-op
    case 2: return FlipH(in);
    case 3: return Rot180(in);
    case 4: return FlipV(in);
    case 5: return Transpose(in);
    case 6: return Rot90CW(in);
    case 7: return Transverse(in);
    case 8: return Rot90CCW(in);
    }
}

// ----------------------------
// 5) 로드: JPEG → IppDib + EXIF 수집 + Orientation 적용
// ----------------------------
struct JpegLoadResult {
    bool ok=false;
    IppDib image;                           // Orientation 반영된 최종 픽셀
    std::vector<SavedMarker> markers;       // 원본 APP들(보존용)
    uint16_t orientation=1;                 // 원본 Orientation
};

bool JpegLoadWithExif(const std::wstring& path, JpegLoadResult& out){
    out = JpegLoadResult{};
    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"rb");
    if (!fp) return false;

    jpeg_decompress_struct cinfo{};
    jpeg_error_mgr jerr{};
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);

    // 예외 복구는 setjmp 기반 커스텀 에러 핸들러를 쓰는 걸 권장(간략화)
    jpeg_stdio_src(&cinfo, fp);

    // EXIF 저장 설정(중요: read_header 이전)
    JpegEnableSaveExif(&cinfo);

    if (jpeg_read_header(&cinfo, TRUE) != JPEG_HEADER_OK){ jpeg_destroy_decompress(&cinfo); fclose(fp); return false; }

    // 저장된 APP 수집
    out.markers = JpegCollectSavedMarkers(&cinfo);

    // EXIF Orientation 읽기
    int idx = FindExifAPP1(out.markers);
    if (idx >= 0){
        uint16_t ori=1;
        if (ParseExifOrientation(out.markers[idx].data.data(), out.markers[idx].data.size(), ori))
            out.orientation = ori;
    }

    // RGB로 디코딩하고 BGRA로 변환
    cinfo.out_color_space = JCS_RGB;
    jpeg_start_decompress(&cinfo);
    out.image.create(cinfo.output_width, cinfo.output_height, 32);

    std::vector<uint8_t> row(out.image.width()*3);
    while (cinfo.output_scanline < cinfo.output_height){
        JSAMPROW rp = row.data();
        jpeg_read_scanlines(&cinfo, &rp, 1);
        uint8_t* dst = (uint8_t*)out.image.bits() + (size_t)(cinfo.output_scanline-1)*out.image.stride();
        for (int x=0;x<out.image.width();++x){
            uint8_t R=row[x*3+0], G=row[x*3+1], B=row[x*3+2];
            dst[x*4+0]=B; dst[x*4+1]=G; dst[x*4+2]=R; dst[x*4+3]=255;
        }
    }
    jpeg_finish_decompress(&cinfo);
    jpeg_destroy_decompress(&cinfo);
    fclose(fp);

    // Orientation 적용
    out.image = ApplyExifOrientation(out.image, out.orientation);
    out.ok = true;
    return true;
}

// ----------------------------
// 6) 저장: IppDib → JPEG (+ 메타 보존/Orientation=1로 패치)
// ----------------------------
bool SaveJpegWithMetadata(const IppDib& img, const std::wstring& path,
                          int quality,
                          std::vector<SavedMarker> markers,
                          bool setOrientationTo1 = true)
{
    if (!img) return false;
    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"wb"); if (!fp) return false;

    jpeg_compress_struct cinfo{}; jpeg_error_mgr jerr{};
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_compress(&cinfo);
    jpeg_stdio_dest(&cinfo, fp);

    cinfo.image_width  = img.width();
    cinfo.image_height = img.height();
    cinfo.input_components = 3;
    cinfo.in_color_space = JCS_RGB;

    jpeg_set_defaults(&cinfo);
    jpeg_set_quality(&cinfo, std::clamp(quality,1,100), TRUE);
    jpeg_set_colorspace(&cinfo, JCS_YCbCr);

    // 압축 시작
    jpeg_start_compress(&cinfo, TRUE);

    // (선택) EXIF Orientation=1로 패치
    if (setOrientationTo1){
        int i = FindExifAPP1(markers);
        if (i>=0){
            PatchExifOrientationInPlace(markers[i].data, 1);
        }
    }

    // 메타데이터 재주입 (SOI 뒤, 스캔라인 전)
    for (auto& m : markers){
        // 필요시 민감한 GPS 등은 건너뛸 수 있음
        jpeg_write_marker(&cinfo, m.marker, m.data.data(), (unsigned int)m.data.size());
    }

    // 스캔라인 쓰기 (BGRA→RGB)
    std::vector<uint8_t> rowRGB(img.width()*3);
    while (cinfo.next_scanline < cinfo.image_height){
        const uint8_t* s = (const uint8_t*)img.bits() + (size_t)cinfo.next_scanline*img.stride();
        for (int x=0;x<img.width();++x){
            rowRGB[x*3+0]=s[x*4+2];
            rowRGB[x*3+1]=s[x*4+1];
            rowRGB[x*3+2]=s[x*4+0];
        }
        JSAMPROW rp=rowRGB.data();
        jpeg_write_scanlines(&cinfo, &rp, 1);
    }

    jpeg_finish_compress(&cinfo);
    jpeg_destroy_compress(&cinfo);
    fclose(fp);
    return true;
}
```

---

## **상황별 예제**(UI/메뉴까지 연결)

### 예제 1 — **스마트폰 세로 사진이 90° 돌아가 보인다**

**상황**: 폴더에서 가져온 JPEG를 열자, 화면에 가로로 누워서 보임(Orientation=6, 90° CW 지시).
**해결 흐름**:

1) 메뉴 **File → Open JPEG…** → 아래 로드 함수를 사용
2) `JpegLoadWithExif()` 가 APP1에서 Orientation=6 을 읽어 옴
3) 디코드된 `IppDib`에 **Rot90CW** 적용
4) 사용자에게 정상 방향으로 표시
5) 저장 시 **Save as JPEG…** → `SaveJpegWithMetadata(..., setOrientationTo1=true)` 호출
   - 픽셀은 이미 회전됨 → EXIF Orientation 을 **1** 로 패치해서 **중복 회전 방지**

```cpp
// JpegOpenCmd.cpp (핵심 흐름)
#include "ExifOrientation.hpp"

void Cmd_OpenJpegHonorExif(HWND hOwner){
    wchar_t path[MAX_PATH]=L"";
    OPENFILENAMEW ofn{sizeof(ofn)};
    ofn.hwndOwner=hOwner;
    ofn.lpstrFilter=L"JPEG Image\0*.jpg;*.jpeg\0\0";
    ofn.lpstrFile=path; ofn.nMaxFile=MAX_PATH;
    if (!GetOpenFileNameW(&ofn)) return;

    JpegLoadResult lr;
    if (!JpegLoadWithExif(path, lr) || !lr.ok){
        MessageBoxW(hOwner, L"열기 실패", L"JPEG", MB_ICONERROR);
        return;
    }
    // lr.image : Orientation 반영 픽셀
    // lr.markers : 원본 메타데이터
    HWND hDoc = CreateDocWindowFromDib(lr.image, L"JPEG (EXIF applied)");
    // 필요하면 문서 컨텍스트에 markers를 붙여서 나중에 Save 시 이용
    AttachMarkersToDoc(hDoc, std::move(lr.markers));
}
```

```cpp
// JpegSaveCmd.cpp (핵심 흐름)
void Cmd_SaveJpegHonorExif(HWND hOwner, const IppDib& cur, HWND hDoc){
    if (!cur){ MessageBoxW(hOwner,L"이미지가 없습니다",L"JPEG",MB_ICONWARNING); return; }
    auto markers = GetMarkersFromDoc(hDoc); // Open 때 저장해둔 것
    wchar_t path[MAX_PATH]=L"";
    OPENFILENAMEW ofn{sizeof(ofn)};
    ofn.hwndOwner=hOwner;
    ofn.lpstrFilter=L"JPEG Image\0*.jpg;*.jpeg\0\0";
    ofn.lpstrFile=path; ofn.nMaxFile=MAX_PATH;
    ofn.lpstrDefExt=L"jpg";
    if (!GetSaveFileNameW(&ofn)) return;

    // 픽셀에 실제 회전/반전을 적용했으므로 Orientation=1로 패치하여 저장
    if (!SaveJpegWithMetadata(cur, path, 90, std::move(markers), /*setOrientationTo1*/true)){
        MessageBoxW(hOwner, L"저장 실패", L"JPEG", MB_ICONERROR);
    }
}
```

---

### 예제 2 — **EXIF는 유지하되, 픽셀은 건드리지 않는 “표시 전용 보정”**

**상황**: 원본 파일을 그대로 두되, 뷰에 보여줄 때만 Orientation 적용. 재저장 시에도 **원본 메타** 그대로 유지(전문 사진 워크플로우).
**전략**:
- 화면 표시에만 `ApplyExifOrientation()`을 사용
- **저장 시**: 픽셀을 원본 그대로 쓰고, EXIF Orientation **그대로** 둠(`setOrientationTo1=false`)

장점: **손실 없는 유지**. 단점: EXIF를 존중하지 않는 뷰어나 툴에서 다시 열면 돌아가 보일 수 있음.

---

### 예제 3 — **GPS/개인정보 메타 제거 옵션**

저장 직전, `markers`에서 **APP1(EXIF) 중 GPS IFD**(별도의 구조)나 전체 EXIF를 제거하고 저장할 수 있습니다.

```cpp
// 예: 모든 EXIF 제거(간단)
std::vector<SavedMarker> StripExif(std::vector<SavedMarker> mks){
    std::vector<SavedMarker> out;
    for (auto& m : mks){
        if (m.marker == JPEG_APP0+1){
            // 이 APP1이 Exif인지 확인
            if (m.data.size()>=6 && std::memcmp(m.data.data(), "Exif\0\0", 6)==0){
                continue; // drop
            }
        }
        out.push_back(std::move(m));
    }
    return out;
}
```

---

## 정확성·안정성 체크리스트

- [ ] **엔디언**: ‘MM’(빅) vs ‘II’(리틀) 구분해 SHORT/ULONG 읽기
- [ ] **범위 검증**: 모든 포인터/오프셋은 반드시 `inRange()`로 검증 (손상/악성 파일 방지)
- [ ] **멀티 APP1**: EXIF APP1 외에 **XMP(APP1)** 가 있을 수 있음. `"Exif\0\0"` 시그니처로 확실히 구분
- [ ] **Orientation 누락/비정상**: 없으면 기본 **1**
- [ ] **저장 시 이중 회전** 방지:
  - **픽셀을 회전**했다면 Orientation을 **1** 로 패치하거나 해당 태그를 삭제
  - **픽셀을 그대로**라면 Orientation을 유지
- [ ] **성능**: 회전/반전은 메모리 복사 중심 — 초고해상도에서는 타일링/멀티스레딩 고려

---

## 수학 관점의 보기 좋은 정식

픽셀 좌표를 **열 우선** 벡터 \(\mathbf{x}=(x,y)^T\) 로 두면, 일부 변환은 간단한 선형/아핀 변환으로 표현됩니다. 예를 들어,
- 180° 회전: \(\mathbf{x}' = \begin{bmatrix}-1&0\\0&-1\end{bmatrix}\mathbf{x} + \begin{bmatrix}W-1\\H-1\end{bmatrix}\)
- 90° CW: \(\mathbf{x}' = \begin{bmatrix}0&1\\-1&0\end{bmatrix}\mathbf{x} + \begin{bmatrix}H-1\\0\end{bmatrix}\)
- Transpose: \(\mathbf{x}' = \begin{bmatrix}0&1\\1&0\end{bmatrix}\mathbf{x}\)

(여기서 \(W,H\) 는 원본 폭/높이, 정수 좌표 보정은 우변 상수항으로 처리)

---

## 흔한 질문(FAQ)

**Q1. Orientation=6(90° CW)인데 8(90° CCW)처럼 보입니다.**
→ 화면 좌표계/원점 기준 착시일 수 있습니다. 위 유틸은 **top-down BGRA**(GDI 좌상단 원점) 기준으로 검증했습니다.

**Q2. Transpose/Transverse 구현을 회전+반전으로 바꿔도 되나요?**
→ 네. 다만 **중간 버퍼**를 최소화하려면 전용 복사 루프(위 코드)처럼 **한 번에** 맵핑하는 편이 효율적입니다.

**Q3. Orientation을 1로 패치하는 대신 태그를 지워도 되나요?**
→ 가능. 다만 다른 유용한 EXIF(촬영정보/GPS/썸네일)도 함께 들어 있으므로 **태그만 수정**을 권장합니다.

**Q4. CMYK JPEG은 이 코드로 안전한가요?**
→ 이 코드는 `JCS_RGB` 출력으로 통일했기 때문에 대부분 호환되지만, 일부 CMYK/YCCK는 별도 처리(Adobe APP14 인버전)가 필요합니다. 색 불일치가 보이면 색 변환 루틴을 추가하세요.

---

## 마무리

- **필수 요지**:
  1) `jpeg_save_markers` 로 EXIF 확보 →
  2) **Orientation 파싱** →
  3) **픽셀 회전/반전 적용** →
  4) 저장 시 **메타 재주입** + Orientation **1로 갱신**(또는 유지 전략 선택)

- 본문 코드는 **외부 파서 없이** Orientation만 정확히 처리합니다.
- 다음 확장: **ICC(색관리) APP2 보존**, **XMP 병행**, **GPS 제거 옵션**, **타깃 크기 품질 조정**, **손실 없는 `jpegtran` 회전**.
