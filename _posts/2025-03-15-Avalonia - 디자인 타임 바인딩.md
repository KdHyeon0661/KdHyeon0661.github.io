---
layout: post
title: Avalonia - 디자인 타임 바인딩
date: 2025-03-15 19:20:23 +0900
category: Avalonia
---
# 디자인 타임 바인딩(Design-Time Data)

## 왜 디자인 타임 데이터가 중요한가

- **레이아웃 검증**: 실제 API 연결 전에도 리스트 길이, 빈 상태, 긴 텍스트 등 UI 상태를 확인.
- **개발 생산성**: 디자이너/개발자 모두 “눈으로” 즉시 피드백.
- **버그 예방**: 런타임에만 보이는 바인딩 오류/스타일 붕괴를 조기 발견.

> 핵심: 디자인 타임과 런타임을 **명확히 분리**하되, 런타임 코드는 **절대** 디자인 타임에서 실행되지 않게 한다.

---

## 가장 쉬운 방법: `d:DataContext` (XAML 전용 더미 바인딩)

### 기본 형태

```xml
<UserControl
    xmlns="https://github.com/avaloniaui"
    xmlns:d="https://github.com/avaloniaui"
    xmlns:vm="clr-namespace:MyApp.ViewModels;assembly=MyApp">

    <!-- 런타임 DataContext (보통 코드비하인드/DI에서 설정) -->
    <UserControl.DataContext>
        <vm:MyViewModel />
    </UserControl.DataContext>

    <!-- 디자인 타임에만 적용되는 DataContext -->
    <UserControl.d:DataContext>
        <vm:MyViewModelDesign />
    </UserControl.d:DataContext>

    <StackPanel Spacing="8">
        <TextBlock Text="{Binding Title}" FontSize="24" />
        <ListBox Items="{Binding Items}" />
    </StackPanel>
</UserControl>
```

포인트
- `d:` 네임스페이스는 **디자인 타임 전용**.
- 런타임에는 **무시**되며, Previewer/디자이너에서만 **MyViewModelDesign** 인스턴스가 DataContext로 적용.

### 크기/표시 보정

```xml
<UserControl
  d:DesignWidth="1024"
  d:DesignHeight="600">
  ...
</UserControl>
```

디자인 타임에서 **레이아웃 폭/높이**를 고정해 미리보기 품질을 높인다.

---

## 디자인 전용 ViewModel/Model/Service를 분리하기

### ViewModelDesign: 상속으로 더미 데이터 넣기

```csharp
public class MyViewModel : ReactiveUI.ReactiveObject
{
    private string _title = "실제 데이터 로딩 중...";
    public string Title
    {
        get => _title;
        set => this.RaiseAndSetIfChanged(ref _title, value);
    }

    private ObservableCollection<string> _items = new();
    public ObservableCollection<string> Items
    {
        get => _items;
        set => this.RaiseAndSetIfChanged(ref _items, value);
    }

    // 실전에서는 생성자에서 API 호출/DI 주입 등 런타임 로직 진행
}

public class MyViewModelDesign : MyViewModel
{
    public MyViewModelDesign()
    {
        Title = "디자인 타이틀";
        Items = new ObservableCollection<string>
        {
            "사과",
            "바나나",
            "포도",
            "수박(긴 텍스트 예시) — 레이아웃 줄바꿈/오버플로 확인 용도"
        };
    }
}
```

장점
- 런타임용 로직은 **기본 VM**에 유지, 디자인용은 **상속으로 데이터만 주입**.
- **동일 바인딩 경로**를 사용하므로 런타임/디자인 타임 간 UI 표현이 일치.

### 디자인 전용 Service를 주입하기 (DI/Mock)

```csharp
public interface IDataService
{
    Task<IReadOnlyList<string>> GetItemsAsync(CancellationToken ct = default);
}

public class RealDataService : IDataService
{
    public async Task<IReadOnlyList<string>> GetItemsAsync(CancellationToken ct = default)
    {
        await Task.Delay(500, ct);
        return new[] { "실데이터1", "실데이터2" };
    }
}

public class DummyDataService : IDataService
{
    public Task<IReadOnlyList<string>> GetItemsAsync(CancellationToken ct = default)
        => Task.FromResult<IReadOnlyList<string>>(new[] { "더미1", "더미2", "더미3(긴 텍스트)" });
}
```

> 디자인 타임에는 **DummyDataService**, 런타임에는 **RealDataService**를 등록한다.

---

## 디자인 타임 감지와 부수효과 차단

디자인 타임에서 API 콜, 파일 접근, 네이티브 의존성 로딩 등 **부수효과**가 일어나면 Previewer가 깨진다.
**다음 중 하나**로 디자인 모드를 감지:

### `Design.IsDesignMode`

```csharp
using Avalonia.Controls;

public static class DesignModeGuard
{
    public static bool IsDesign => Design.IsDesignMode;
}
```

### ViewModel에서 보호

```csharp
public class MySafeViewModel : ReactiveUI.ReactiveObject
{
    public MySafeViewModel(IDataService service)
    {
        if (Design.IsDesignMode)
        {
            // 디자인 타임에는 서비스 호출/파일 I/O 차단
            return;
        }

        _ = LoadAsync(service);
    }

    private async Task LoadAsync(IDataService svc)
    {
        var items = await svc.GetItemsAsync();
        Items = new ObservableCollection<string>(items);
    }

    public ObservableCollection<string> Items { get; private set; } = new();
}
```

> 과거 WPF에는 `DesignerProperties.GetIsInDesignMode`를 쓰곤 했지만, Avalonia에선 `Design.IsDesignMode`가 표준적이다.

---

## DI 컨테이너: 디자인/런타임 분리 등록 패턴

### App.xaml.cs (예시)

```csharp
using Microsoft.Extensions.DependencyInjection;
using Avalonia.Controls;

public static class ContainerConfig
{
    public static IServiceProvider Build()
    {
        var services = new ServiceCollection();

        if (Design.IsDesignMode)
        {
            // 디자인 타임: 더미 서비스/더미 스토어
            services.AddSingleton<IDataService, DummyDataService>();
            services.AddTransient<MyViewModel, MyViewModelDesign>();
        }
        else
        {
            // 런타임: 실제 서비스
            services.AddSingleton<IDataService, RealDataService>();
            services.AddTransient<MyViewModel>();
        }

        return services.BuildServiceProvider();
    }
}
```

### View에서 DataContext를 DI로 주입

```csharp
public partial class MyView : UserControl
{
    public MyView()
    {
        InitializeComponent();

        if (!Design.IsDesignMode)
        {
            // 런타임에만 DI에서 Resolve
            DataContext = App.Services.GetRequiredService<MyViewModel>();
        }
        // 디자인 타임은 XAML의 d:DataContext가 동작
    }
}
```

> **원칙**: 디자인 타임에는 **코드비하인드에서 DI를 호출하지 않는다.** (Previewer가 DataContext를 강제로 구울 수 있게 비워두거나 d:DataContext만 사용)

---

## 컬렉션/템플릿/그리드의 디자인 타임 관찰 포인트

### 가상화 컨트롤(ItemsControl/TreeView/DataGrid)

디자인 타임에도 **ItemTemplate**이 제대로 바인딩되는지 확인하려면 **충분한 개수**의 더미 아이템과 **빈/긴/이상 데이터**를 같이 채운다.

```csharp
public class ComplexItem
{
    public string Title { get; set; } = "";
    public string Description { get; set; } = "";
    public int Count { get; set; }
    public bool IsActive { get; set; }
}

public class ComplexListDesignVM
{
    public ObservableCollection<ComplexItem> Items { get; } = new()
    {
        new ComplexItem { Title = "A", Description = "짧은 설명", Count = 1, IsActive = true },
        new ComplexItem { Title = "B(긴 제목 테스트) — 레이아웃 줄바꿈 확인", Description = "아주아주 긴 설명..." , Count = 123, IsActive = false },
        new ComplexItem { Title = "", Description = "빈 제목 시 레이아웃", Count = 0, IsActive = false }
    };
}
```

```xml
<ItemsControl Items="{Binding Items}">
  <ItemsControl.ItemTemplate>
    <DataTemplate>
      <DockPanel Margin="4">
        <CheckBox IsChecked="{Binding IsActive}" DockPanel.Dock="Left"/>
        <TextBlock Text="{Binding Title}" FontWeight="Bold"/>
        <TextBlock Text="{Binding Description}" TextWrapping="Wrap" Margin="8,0,0,0"/>
        <TextBlock Text="{Binding Count}" HorizontalAlignment="Right"/>
      </DockPanel>
    </DataTemplate>
  </ItemsControl.ItemTemplate>
</ItemsControl>
```

### 에러 템플릿/빈 상태 템플릿

디자인 타임에도 **빈 컬렉션**, **에러 상태**를 쉽게 재현하기 위해 디자인 VM에 스위치를 둔다.

```csharp
public class StateDesignVM
{
    public bool HasError { get; set; } = true;
    public string ErrorMessage => HasError ? "디자인 전용 오류 메시지" : "";
    public bool IsEmpty => !HasError && Items.Count == 0;

    public ObservableCollection<string> Items { get; } = new();
}
```

```xml
<ContentControl>
  <ContentControl.Styles>
    <Style Selector="ContentControl">
      <Style.Triggers>
        <DataTrigger Binding="{Binding HasError}" Value="True">
          <Setter Property="Content">
            <Setter.Value>
              <TextBlock Text="{Binding ErrorMessage}" Foreground="Red"/>
            </Setter.Value>
          </Setter>
        </DataTrigger>
        <DataTrigger Binding="{Binding IsEmpty}" Value="True">
          <Setter Property="Content">
            <Setter.Value>
              <TextBlock Text="항목이 없습니다." Opacity="0.6"/>
            </Setter.Value>
          </Setter>
        </DataTrigger>
      </Style.Triggers>
    </Style>
  </ContentControl.Styles>
</ContentControl>
```

---

## 명령/비동기 로직: 디자인 타임 안전 가드

디자인 타임에 **ReactiveCommand**, **ICommand**를 그대로 실행하면 Previewer가 멈출 수 있다.

### 더미 명령으로 교체

```csharp
public static class DesignCommand
{
    public static readonly ICommand Noop = ReactiveUI.ReactiveCommand.Create(() => { /* do nothing */ });
}

public class CommandDesignVM
{
    public ICommand SaveCommand { get; }
    public ICommand LoadCommand { get; }

    public CommandDesignVM()
    {
        SaveCommand = DesignCommand.Noop;
        LoadCommand = DesignCommand.Noop;
    }
}
```

### ViewModel에서 조건부 등록

```csharp
public class CommandVM : ReactiveUI.ReactiveObject
{
    public ReactiveUI.ReactiveCommand<Unit, Unit> SaveCommand { get; }

    public CommandVM()
    {
        if (Design.IsDesignMode)
            SaveCommand = ReactiveUI.ReactiveCommand.Create(() => { /* noop */ });
        else
            SaveCommand = ReactiveUI.ReactiveCommand.CreateFromTask(SaveAsync);
    }

    private Task SaveAsync() => Task.CompletedTask;
}
```

---

## 디자인 타임에서의 형식 안전(Compiled Bindings)과 상태

Avalonia는 **Compiled Bindings**를 지원한다(`x:DataType`) — 바인딩 경로 오타를 컴파일 타임에 검출할 수 있다.

```xml
<UserControl
  xmlns="https://github.com/avaloniaui"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  x:DataType="vm:MyViewModel">
  <StackPanel>
    <TextBlock Text="{Binding Title}"/>
  </StackPanel>
</UserControl>
```

주의
- 디자인 타임에는 `d:DataContext`에 **MyViewModelDesign**을 주입하지만, `x:DataType`은 **MyViewModel**로 고정되어 형식 검사가 이루어진다.
- 디자인 VM은 MyViewModel을 상속(또는 동일 인터페이스 구현)해 **멤버 일치**를 보장하자.

---

## Previewer 친화 설계 체크리스트

- **I/O, 네이티브 라이브러리 로드 금지**: `Design.IsDesignMode`로 차단.
- **DI 호출 최소화**: 디자인 타임에는 XAML의 `d:DataContext`만 사용.
- **긴 텍스트/빈 데이터/이상 데이터** 포함: 템플릿의 견고성 점검.
- **폭/높이 고정**: `d:DesignWidth/Height`로 미리보기 안정화.
- **템플릿 분기**: 빈 상태, 오류 상태에 대한 UI를 디자인 타임부터 검증.
- **명령은 Noop**: 네트워크/파일/DB 작업이 돌지 않도록 보호.

---

## Rider / Visual Studio / CLI Previewer

| 도구 | 준비 사항 |
|------|-----------|
| JetBrains Rider | Avalonia 플러그인, 프로젝트 로드만으로 Previewer 작동 |
| Visual Studio 2022+ | Avalonia Extension 설치 |
| CLI Previewer | `dotnet watch` 또는 `avalonia` 도구 사용(프로젝트 설정에 따름) |

> Previewer가 실패하면 **출력 창/로그**를 확인. 대체로 디자인 타임에서 실행된 I/O나 Native 호출이 원인이다.

---

## 실전 예제: 마스터-디테일 화면의 디자인 타임 데이터

### ViewModel(런타임용/디자인용)

```csharp
public class ProductItem
{
    public string Name { get; set; } = "";
    public string Category { get; set; } = "";
    public decimal Price { get; set; }
}

public class ProductListViewModel : ReactiveUI.ReactiveObject
{
    public ObservableCollection<ProductItem> Items { get; } = new();
    private ProductItem? _selected;
    public ProductItem? Selected
    {
        get => _selected;
        set => this.RaiseAndSetIfChanged(ref _selected, value);
    }

    public ProductListViewModel(IDataService svc)
    {
        if (!Design.IsDesignMode)
        {
            _ = LoadAsync(svc);
        }
    }

    private async Task LoadAsync(IDataService svc)
    {
        var data = await svc.GetItemsAsync();
        foreach (var name in data)
            Items.Add(new ProductItem { Name = name, Category = "실제", Price = 10m });
        Selected = Items.FirstOrDefault();
    }
}

public class ProductListDesignViewModel : ProductListViewModel
{
    public ProductListDesignViewModel() : base(new DummyDataService())
    {
        Items.Clear();
        Items.Add(new ProductItem { Name = "디자인 사과", Category = "과일", Price = 1.2m });
        Items.Add(new ProductItem { Name = "디자인 바나나(긴 이름 테스트) — 가격표시, 텍스트 줄바꿈", Category = "과일", Price = 2.34m });
        Items.Add(new ProductItem { Name = "", Category = "빈이름", Price = 0m });
        Selected = Items[1];
    }
}
```

### View(XAML)

```xml
<UserControl
    xmlns="https://github.com/avaloniaui"
    xmlns:d="https://github.com/avaloniaui"
    xmlns:vm="clr-namespace:MyApp.ViewModels;assembly=MyApp"
    d:DesignWidth="960" d:DesignHeight="540">
  <UserControl.d:DataContext>
    <vm:ProductListDesignViewModel/>
  </UserControl.d:DataContext>

  <Grid ColumnDefinitions="2*,3*" RowDefinitions="Auto,*" Margin="12">
    <TextBlock Text="상품 목록" FontSize="20" Grid.ColumnSpan="2" Margin="0,0,0,8"/>
    <!-- Master -->
    <ListBox Grid.Row="1" Items="{Binding Items}" SelectedItem="{Binding Selected}">
      <ListBox.ItemTemplate>
        <DataTemplate>
          <DockPanel Margin="4">
            <TextBlock Text="{Binding Name}" FontWeight="Bold"/>
            <TextBlock Text="{Binding Category}" Margin="8,0,0,0" Opacity="0.7"/>
            <TextBlock Text="{Binding Price}" HorizontalAlignment="Right"/>
          </DockPanel>
        </DataTemplate>
      </ListBox.ItemTemplate>
    </ListBox>

    <!-- Detail -->
    <StackPanel Grid.Column="1" Grid.Row="1" Margin="16" Spacing="8">
      <TextBlock Text="{Binding Selected.Name}" FontSize="18" FontWeight="Bold"/>
      <TextBlock Text="{Binding Selected.Category}" />
      <TextBlock Text="{Binding Selected.Price, StringFormat='가격: {0:C}'}" />
      <Button Content="구매" IsEnabled="{Binding Selected}"/>
    </StackPanel>
  </Grid>
</UserControl>
```

> 런타임에선 코드비하인드 또는 DI에서 `ProductListViewModel`을 주입한다. 디자인 타임은 `ProductListDesignViewModel`이 자동 적용되어 미리보기에 더미 데이터가 표시된다.

---

## 고급: 복합 화면(탭/다중 패널)에서의 디자인 타임 데이터 전략

- 각 탭/패널에 **별도의 디자인 VM**을 배치.
- **더미 네비게이션 상태**(현재 탭, 선택 인덱스, 권한 등)를 디자인 VM에 세팅.
- **역할 기반 UI**(Admin/Editor/User)를 프리뷰하려면 `d:DataContext`를 역할별 디자인 VM으로 바꿔가며 확인.

예시

```xml
<TabControl>
  <TabItem Header="개요">
    <local:OverviewView d:DataContext="{x:Static vm:OverviewDesign.Instance}"/>
  </TabItem>
  <TabItem Header="통계">
    <local:StatsView d:DataContext="{x:Static vm:StatsDesign.Instance}"/>
  </TabItem>
</TabControl>
```

---

## 테스트와 연계

- 디자인 전용 데이터는 **단위 테스트의 픽스처**로도 재사용 가능(모델 샘플, 에러/빈 상태).
- DataTemplate 바인딩 경로를 컴파일 바인딩(`x:DataType`)으로 묶으면 **오타/멤버 누락을 컴파일 단계에서 차단**.

---

## 문제 해결(FAQ)

| 증상 | 원인 | 해결 |
|------|------|------|
| Previewer 빈 화면 | View에서 DI로 실서비스 호출 | 디자인 타임에는 DI 사용 금지. `d:DataContext`만 사용 |
| Previewer 멈춤 | 비동기/명령 실행, 파일/네트워크 접근 | `Design.IsDesignMode`로 차단, Noop 명령 사용 |
| 바인딩 오류 표시 | 경로/멤버 불일치 | 디자인 VM이 런타임 VM과 동일 멤버 제공(상속/인터페이스) |
| 너무 작은 캔버스 | Previewer 기본 크기 | `d:DesignWidth/Height` 지정 |
| 다크/라이트 가독성 | 테마 차이 | 디자인 타임에 Theme 스위치 후 색상 대비 점검 |

---

## 결론

- **`d:DataContext`**로 디자인 전용 ViewModel을 주입하면, **런타임과 독립**적으로 미리보기가 가능하다.
- **Design.IsDesignMode**로 **I/O/네트워크/네이티브 로드**를 **철저히 차단**해 Previewer 안정성을 확보한다.
- **디자인 VM/서비스/픽스처**를 체계적으로 구성하면 **리스트/템플릿/에러/빈 상태/권한 분기**까지 UI 전 시나리오를 책상 위에서 검증할 수 있다.
- Compiled Bindings(`x:DataType`)로 **형식 안정성**을 높이고, 긴 텍스트/빈 데이터 등 **엣지 케이스를 포함한 더미 데이터**로 레이아웃 견고성을 강화하자.

---

## 부록 A. 최소 템플릿(복붙용)

```xml
<UserControl
    xmlns="https://github.com/avaloniaui"
    xmlns:d="https://github.com/avaloniaui"
    xmlns:vm="clr-namespace:MyApp.ViewModels;assembly=MyApp"
    d:DesignWidth="1024" d:DesignHeight="640">
  <UserControl.d:DataContext>
    <vm:MyViewModelDesign/>
  </UserControl.d:DataContext>

  <Grid Margin="16">
    <StackPanel Spacing="8">
      <TextBlock Text="{Binding Title}" FontSize="24"/>
      <ItemsControl Items="{Binding Items}"/>
    </StackPanel>
  </Grid>
</UserControl>
```

```csharp
public class MyViewModel : ReactiveUI.ReactiveObject
{
    public string Title { get; set; } = "실행 시 로딩됨";
    public ObservableCollection<string> Items { get; } = new();
}

public class MyViewModelDesign : MyViewModel
{
    public MyViewModelDesign()
    {
        Title = "디자인 타임 미리보기";
        Items.Add("더미 A");
        Items.Add("더미 B");
        Items.Add("더미 C (긴 텍스트로 줄바꿈 테스트)");
    }
}
```

---

## 참고 자료

- Avalonia Previewer 문서: 공식 가이드(설치/사용/제약)
- ReactiveUI: 디자인 타임에서도 PropertyChanged가 미리보기 반영에 유용

이 가이드를 토대로 프로젝트에 **디자인 타임 바인딩**을 도입하면, UI 개발 속도와 품질이 동시에 개선된다.
