---
layout: post
title: 웹해킹 - CORS 오구성 악용
date: 2025-10-05 15:25:23 +0900
category: 웹해킹
---
# CORS 오구성 악용 — 원리, 실전 징후, “안전 재현” 점검, 프레임워크·Nginx·CDN 방어 레시피

## 0) 한눈에 보기 (Executive Summary)

- **문제**  
  - `Access-Control-Allow-Origin: *`와 `Access-Control-Allow-Credentials: true`의 **부적절 조합**,  
    혹은 `Origin: null`(파일 스킴·샌드박스 iframe·브라우저 확장 등) **허용**으로  
    **크로스 도메인 데이터 탈취(read)**가 가능해질 수 있습니다.  
  - “리플렉션 화이트리스트(=아무 오리진이나 그대로 되돌려 주기)”는 **사실상 무제한 허용**과 같아 위험.

- **오해 바로잡기**  
  - 브라우저는 **사양상** `Access-Control-Allow-Credentials: true`와 `*`를 **동시에** 인정하지 않습니다.  
    하지만 **서버가 “임의 Origin을 그대로 반사”**(예: `Access-Control-Allow-Origin: https://attacker.tld`)하고  
    `Allow-Credentials: true`까지 설정하면 **쿠키/인증 헤더를 동반한 응답을 공격자 페이지에서 읽게** 됩니다.
  - CORS는 **“읽기 권한 제어”**입니다. **요청 전송 자체를 막지 않습니다**(CSRF와 다른 축).  
    즉, CSRF 차단이 잘 되어도 CORS 오구성은 **데이터 노출** 문제를 유발할 수 있습니다.

- **핵심 방어**  
  1) **명시 화이트리스트**만 허용(서브도메인 와일드카드 최소화, 패턴 검증 엄격)  
  2) `*`와 `Access-Control-Allow-Credentials: true` **동시 사용 금지**  
  3) `Origin: null` **거절**(정말 필요한 경우에만 특정 경로에서만 허용)  
  4) **프리플라이트(OPTIONS) 검증**: 메서드·헤더·오리진 모두 화이트리스트 매칭  
  5) **민감 응답은 기본 비공개**(인증·개인화 데이터는 CORS 허용 면밀 제한)  
  6) **응답 캐시 주의**: Origin에 따라 다른 응답이면 `Vary: Origin` 필수

---

# 1) 배경지식 — CORS 흐름 요약

1) **단순 요청(Simple Request)**: `GET/HEAD/POST` + 제한된 헤더·콘텐츠 타입.  
2) **프리플라이트(Preflight)**: `OPTIONS`로  
   - `Origin`, `Access-Control-Request-Method`, `Access-Control-Request-Headers` 전달 →  
   - 서버가 **허용 오리진/메서드/헤더**를 명시적으로 응답해야 본요청 허용.  
3) **자격 증명(쿠키) 포함 요청**: `fetch(..., { credentials: "include" })`  
   - 서버는 **특정 오리진을 지정**(`*` 금지) + `Access-Control-Allow-Credentials: true`  
   - 쿠키도 브라우저 정책(SameSite=None; Secure 등)을 충족해야 전송.

---

# 2) 대표 오구성과 위험 시나리오

## 2.1 무분별한 와일드카드
```http
Access-Control-Allow-Origin: *
```
- **영향**: **쿠키 없이도** 노출해서는 안 되는 민감 데이터라면, **임의 웹페이지**에서 `fetch`로 읽힐 수 있음.  
- 인증 쿠키를 **쓰지 않는** 공개/토큰 기반 API에서도 **읽기 허용 대상 오리진 최소화**가 원칙.

## 2.2 리플렉션 기반 허용 + Credentials=true
```pseudo
// 서버 로직 (취약)
res.set("Access-Control-Allow-Origin", req.headers.origin);
res.set("Access-Control-Allow-Credentials", "true");
```
- **영향**: 공격자 사이트 `https://evil.tld`에서 **사용자 세션 쿠키를 동반한 요청**의 **응답 바디를 읽기 가능**.  
- **징후**: 허용 리스트 없이 “보낸 Origin 그대로”를 되돌려 주는 패턴.

## 2.3 `Origin: null` 허용
- `file://` 스킴, 샌드박스 iframe(`sandbox` 속성), 일부 브라우저/확장 환경에서 **Origin 값이 `null`**.  
- **영향**: 로컬 파일 또는 샌드박스 컨텍스트에서 **민감 데이터 조회** 가능.  
- **방어**: 기본은 **거절**. 특별히 필요한 내부 도구 경로에서만 **제한적 허용**.

## 2.4 프리플라이트 무검증
- `OPTIONS` 요청만 오면 **기계적으로 200 + 허용 헤더 전부** 응답.  
- **영향**: **커스텀 헤더(Authorization 등)**를 동반한 본요청이 **무제한 허용**.

## 2.5 캐시·프록시 상호작용
- 오리진별로 다른 응답인데 **`Vary: Origin` 부재** → 다른 오리진에서 **재사용**(미스매치) 위험.  
- CDN/프록시가 **CORS 헤더를 임의 주입/값 수정** → 정책 혼선.

---

# 3) “안전 재현” 점검(스테이징 전용) — 막혀야 정상 ✅

> 목적: 우리 서버의 CORS 정책이 **화이트리스트 기반**이고, **null/리플렉션/프리플라이트 남용**이 **차단**되는지 확인.

### 3.1 단순 요청
```bash
# 임의 오리진에서 단순 GET — 허용되지 않아야 함(민감 경로)
curl -si https://staging.example.com/api/me \
  -H 'Origin: https://not-allowed.tld' | egrep -i 'access-control-allow|http/|vary'
# 기대: ACAO(Allow-Origin) 미포함 또는 특정 오리진만
```

### 3.2 프리플라이트
```bash
curl -si -X OPTIONS https://staging.example.com/api/me \
  -H 'Origin: https://not-allowed.tld' \
  -H 'Access-Control-Request-Method: GET' \
  -H 'Access-Control-Request-Headers: authorization,x-custom'
# 기대: 403/400 또는 허용되지 않은 헤더/오리진에 대해 비허용 응답
```

### 3.3 `Origin: null`
```bash
curl -si https://staging.example.com/api/me -H 'Origin: null'
# 기대: 거절(ACAO 미포함/403 등)
```

### 3.4 Credentials 포함 요청(브라우저 콘솔)
```js
// 스테이징 임의 오리진 페이지 콘솔에서
fetch("https://staging.example.com/api/me", { credentials: "include" })
  .then(r => [r.status, r.headers.get("access-control-allow-origin"),
              r.headers.get("access-control-allow-credentials")])
  .then(console.log);
```
- **기대**: 허용된 오리진이 **정확히 지정**되어 있고, 그 외에는 **읽기 불가**.

---

# 4) 프레임워크별 **정석 구현**

## 4.1 Node/Express — **정적 화이트리스트 + 프리플라이트 검증 + null 거절**

```js
// cors-guard.js
import { URL } from "node:url";

const ALLOWLIST = new Set([
  "https://app.example.com",
  "https://admin.example.com",
  // (선택) 특정 서브도메인만: 정확 문자열만 권장
]);

function isAllowedOrigin(origin) {
  if (!origin) return false;               // 브라우저가 보낸 CORS 요청이어야 함
  if (origin === "null") return false;     // 기본 거절
  try {
    const u = new URL(origin);
    // (선택) 포트/프로토콜까지 엄격 비교
    return ALLOWLIST.has(`${u.protocol}//${u.host}`);
  } catch { return false; }
}

export function corsGuard(req, res, next) {
  const origin = req.headers.origin;

  // 프리플라이트 처리
  if (req.method === "OPTIONS" && origin) {
    if (!isAllowedOrigin(origin)) return res.sendStatus(403);

    const reqMethod  = req.headers["access-control-request-method"];
    const reqHeaders = String(req.headers["access-control-request-headers"]||"")
                        .toLowerCase().split(",").map(s=>s.trim()).filter(Boolean);

    // 허용 메서드/헤더 화이트리스트
    const ALLOWED_METHODS = new Set(["GET","POST","PUT","DELETE","PATCH"]);
    const ALLOWED_HEADERS = new Set(["authorization","content-type","x-request-id"]);

    if (!ALLOWED_METHODS.has(String(reqMethod||"").toUpperCase()))
      return res.sendStatus(405);

    if (reqHeaders.some(h => !ALLOWED_HEADERS.has(h)))
      return res.sendStatus(400);

    res.set("Access-Control-Allow-Origin", origin);
    res.set("Vary", "Origin");
    res.set("Access-Control-Allow-Methods", Array.from(ALLOWED_METHODS).join(","));
    res.set("Access-Control-Allow-Headers", Array.from(ALLOWED_HEADERS).join(","));
    // credentials 허용은 꼭 필요한 경로에서만!
    res.set("Access-Control-Allow-Credentials", "true");
    res.set("Access-Control-Max-Age", "600");
    return res.sendStatus(204);
  }

  // 본요청 처리
  if (origin && isAllowedOrigin(origin)) {
    res.set("Access-Control-Allow-Origin", origin);
    res.set("Vary", "Origin");
    // 경로별 정책(민감 정보 제공 시에만)
    res.set("Access-Control-Allow-Credentials", "true");
  }
  return next();
}
```

```js
// app.js
import express from "express";
import bodyParser from "body-parser";
import { corsGuard } from "./cors-guard.js";

const app = express();
app.use(bodyParser.json({ limit: "100kb" }));
app.use(corsGuard);

app.get("/health", (_req,res)=>res.json({ok:true}));

// 민감 API — 오리진 엄격 검증 + 인증 필요
app.get("/api/me", (req, res) => {
  if (!req.user) return res.sendStatus(401);
  res.json({ id: req.user.id, email: req.user.email });
});

app.listen(8080, ()=>console.log("on 8080"));
```

> **포인트**  
> - **반사(reflect)**하지 말고 **화이트리스트 매칭**으로만 `Access-Control-Allow-Origin` 설정.  
> - 프리플라이트에서 **메서드/헤더**도 **화이트리스트 일치** 확인.  
> - `Vary: Origin`을 설정해 **캐시 혼선** 방지.

---

## 4.2 NestJS (유사 원칙)
```ts
// main.ts
const allowlist = new Set(["https://app.example.com","https://admin.example.com"]);

app.enableCors({
  origin: (origin, cb) => {
    if (!origin) return cb(null, false);       // 비CORS(동일 출처) 요청
    if (origin === "null") return cb(new Error("bad origin"));
    cb(null, allowlist.has(origin));
  },
  methods: ["GET","POST","PUT","DELETE","PATCH"],
  allowedHeaders: ["authorization","content-type","x-request-id"],
  credentials: true,                            // 꼭 필요한 경우에만
  maxAge: 600,
});
```

---

## 4.3 Spring Boot (자바)

```java
@Configuration
public class CorsConfig {
  @Bean
  public CorsConfigurationSource corsConfigurationSource() {
    var c = new CorsConfiguration();
    c.setAllowedOrigins(List.of("https://app.example.com", "https://admin.example.com"));
    c.setAllowCredentials(true); // '*'와 동시 사용 불가 (스프링이 막아줌)
    c.setAllowedMethods(List.of("GET","POST","PUT","DELETE","PATCH"));
    c.setAllowedHeaders(List.of("Authorization","Content-Type","X-Request-Id"));
    c.setMaxAge(600L);

    var source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/api/**", c);
    // /public/** 등은 별도 정책(예: credentials 불허, 읽기만)
    return source;
  }
}
```

> Spring 5.3+/Boot 2.4+에서는 `allowedOriginPatterns("*")`를 남용하지 말고 **정확한 목록**을 사용하세요.

---

## 4.4 Flask (파이썬)

```python
from flask import Flask, request, abort, jsonify

ALLOWLIST = {"https://app.example.com", "https://admin.example.com"}
ALLOWED_METHODS = {"GET","POST","PUT","DELETE","PATCH"}
ALLOWED_HEADERS = {"authorization","content-type","x-request-id"}

app = Flask(__name__)

@app.after_request
def add_cors(resp):
    origin = request.headers.get("Origin")
    if not origin: return resp  # same-origin
    if origin == "null" or origin not in ALLOWLIST:
        return resp              # CORS 허용하지 않음(헤더 미부여)
    # 본요청 허용
    resp.headers["Access-Control-Allow-Origin"] = origin
    resp.headers["Vary"] = "Origin"
    resp.headers["Access-Control-Allow-Credentials"] = "true"
    return resp

@app.route("/api/me", methods=["GET","OPTIONS"])
def me():
    origin = request.headers.get("Origin")
    if request.method == "OPTIONS":
        if origin not in ALLOWLIST: abort(403)
        req_method = request.headers.get("Access-Control-Request-Method","")
        req_headers = {h.strip().lower() for h in request.headers.get("Access-Control-Request-Headers","").split(",") if h}
        if req_method not in ALLOWED_METHODS or not req_headers.issubset(ALLOWED_HEADERS):
            abort(400)
        r = app.make_default_options_response()
        r.headers["Access-Control-Allow-Origin"] = origin
        r.headers["Vary"] = "Origin"
        r.headers["Access-Control-Allow-Methods"] = ",".join(ALLOWED_METHODS)
        r.headers["Access-Control-Allow-Headers"] = ",".join(ALLOWED_HEADERS)
        r.headers["Access-Control-Allow-Credentials"] = "true"
        r.headers["Access-Control-Max-Age"] = "600"
        return r
    # GET
    # (여기에 인증/권한 체크)
    return jsonify({"ok": True})
```

---

# 5) Nginx/리버스 프록시 — 정책 강제

## 5.1 “화이트리스트 오리진만 허용” (접두 매핑)

```nginx
# server { ... }
# 1) 허용 오리진 매핑
map $http_origin $cors_allow_origin {
  default "";
  "~^https://app\.example\.com$"   "$http_origin";
  "~^https://admin\.example\.com$" "$http_origin";
}

# 2) 프리플라이트 처리(민감 API 전용)
location /api/ {
  if ($request_method = OPTIONS) {
    if ($cors_allow_origin = "") { return 403; }
    add_header Access-Control-Allow-Origin $cors_allow_origin;
    add_header Vary Origin;
    add_header Access-Control-Allow-Methods "GET,POST,PUT,DELETE,PATCH";
    add_header Access-Control-Allow-Headers "Authorization,Content-Type,X-Request-Id";
    add_header Access-Control-Allow-Credentials true;
    add_header Access-Control-Max-Age 600;
    return 204;
  }

  # 본요청
  proxy_pass http://app_backend;
  add_header Access-Control-Allow-Origin $cors_allow_origin always;
  add_header Vary Origin always;
  add_header Access-Control-Allow-Credentials true always;
}
```

> **주의**  
> - `Access-Control-Allow-Origin: *` **금지**  
> - 정규식은 **정확 도메인**만(루트·서브·포트까지 포함하여 매칭)  
> - `Origin "null"`은 `map`에 매칭하지 않으므로 **자동 거절**

## 5.2 CDN/엣지(CloudFront/Cloudflare/Fastly)  
- **원본이 CORS를 올바르게 설정**하는 것이 1순위.  
- 엣지에서 CORS를 **주입**해야 한다면:  
  - **정확 오리진 화이트리스트**로만 주입  
  - **Vary: Origin** 추가  
  - 민감 경로 외에는 **credentials 불허**(헤더 제거)

---

# 6) 설계 상의 추가 수칙

- **민감 API 최소 공개**: 외부 오리진에 **읽힐 필요가 없는 API**는 **CORS 자체를 꺼두기**.  
- **Scope 축소**: 오리진 화이트리스트는 **운영툴로 승인/등록** 후 배포(런타임 반영 금지).  
- **메서드/헤더 제한**: 필요한 범위만 열고, `Authorization` 등 **민감 헤더 허용은 최소화**.  
- **Expose-Headers 최소화**: 토큰/식별자 헤더 노출 금지.  
- **프론트엔드 토큰 저장 전략**: 가능하면 **쿠키(HttpOnly)** + **엄격 CORS** 조합, `localStorage` 남용 지양.  
- **SameSite와 CORS**: 크로스사이트 쿠키 전송이 꼭 필요할 때만 `SameSite=None; Secure`를 사용.  
- **Private Network Access(PNA)**: 사설망 자원 요청은 프리플라이트가 추가됩니다. **원천 차단**을 고려.

---

# 7) 로깅·모니터링·알림

- **로그 필드**: `ts`, `route`, `origin`, `allowed(boolean)`, `isPreflight`, `reqMethod`, `reqHeaders`, `status`  
- **경보 룰 예시**  
  - 허용되지 않은 `Origin` 비율 급증  
  - `Origin: null` 시도 빈발  
  - `Access-Control-Allow-Origin: *` 응답 탐지(실수 배포)  
  - Credentials 허용 경로에서 `Vary: Origin` 부재 탐지

**Loki(LogQL)**
```logql
{service="edge"} |= "Access-Control-Allow-Origin: *"
| count_over_time(5m) > 0
```

**Splunk(SPL)**
```spl
index=api "Origin:" NOT ("app.example.com" OR "admin.example.com")
| stats count by origin, path
```

---

# 8) CI/파이프라인 자동 점검

- **정규식 스캔(서버/프록시 구성)**
  - `Access-Control-Allow-Origin: \*` → **실패 처리**  
  - Nginx `add_header Access-Control-Allow-Origin $http_origin` → **경고**(화이트리스트 없이 반사)  
- **E2E(스테이징)**: §3의 `curl` 시나리오 자동화 → 결과가 기대치(거절/허용)와 다르면 실패.

```bash
# 예: Nginx 렌더 결과 검사
nginx -T > /tmp/nginx.all.conf
grep -Rni 'Access-Control-Allow-Origin:\s*\*' /tmp/nginx.all.conf && \
  echo "::error :: CORS wildcard detected" && exit 1
grep -Rni 'add_header\s\+Access-Control-Allow-Origin\s\+\$http_origin' /tmp/nginx.all.conf && \
  echo "::warning :: origin reflection found — validate whitelist"
```

---

# 9) 체크리스트 (현장용)

- [ ] **허용 오리진 화이트리스트**만 사용(정확 도메인/프로토콜/포트 일치)  
- [ ] `Access-Control-Allow-Credentials: true` 필요 시, `Allow-Origin`에 **정확 오리진**만 → `*` 금지  
- [ ] `Origin: null` **거절**, 예외는 별도 경로에서만 제한적 허용  
- [ ] **프리플라이트 검증**: 메서드/헤더 화이트리스트 매칭  
- [ ] 민감 API는 **기본 비공개**(CORS 비활성) 또는 최소 오리진만  
- [ ] **Vary: Origin** 설정(오리진별 응답 차등 시)  
- [ ] CDN/프록시에서 **임의 CORS 주입 금지**, 원본과 정책 일치  
- [ ] 로깅: origin/allowed/isPreflight/headers, 알림 룰 운영  
- [ ] CI에서 `ACAO:*` 탐지·차단, 리플렉션 패턴 경고  
- [ ] 운영 문서에 **오리진 추가/변경 프로세스** 명문화(승인·리뷰 필수)

---

## 맺음말

CORS는 “**누가 우리 응답을 읽을 수 있는가**”를 결정합니다.  
**와일드카드/리플렉션/`null` 허용**은 작은 편의가 **대형 데이터 유출**로 이어지는 지름길입니다.  
**화이트리스트 + 프리플라이트 검증 + 캐시 주의(Vary: Origin)**를 표준으로 삼고,  
CI·로그·엣지 구성까지 **전 단계에서 일관된 정책**을 강제해 사고 가능성을 구조적으로 줄이세요.