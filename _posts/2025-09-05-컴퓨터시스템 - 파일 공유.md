---
layout: post
title: 컴퓨터시스템 - 파일 공유
date: 2025-09-05 17:20:23 +0900
category: 컴퓨터시스템
---
# 파일 공유(File Sharing)

## 큰 그림 — 무엇이 “공유”되나?

```
[Process] ── FD table (per-process) ──▶ [Open File Description] ──▶ [inode/vnode]
                 │                                  │
                 │ FD flags (FD_CLOEXEC, …)         │ file status flags (O_APPEND, O_NONBLOCK, …)
                 └─── dup/fork/SCM_RIGHTS ──────────┘ f_pos(공유 오프셋), refcount
```

- **FD 테이블(프로세스 단위)**: 정수 FD → **열린 파일 설명자(Open File Description, OFD)** 포인터 + **FD 플래그**(예: `FD_CLOEXEC`).
- **열린 파일 설명자(시스템 전역 `struct file`)**: **현재 파일 오프셋(f_pos)**, **파일 상태 플래그(`O_APPEND`, `O_NONBLOCK`, …)**, 접근 모드 보관. **여러 FD**(또는 프로세스)가 **하나의 OFD**를 공유 가능.
- **inode/vnode(파일 객체)**: 권한/소유/크기/타임스탬프, 자료 블록 연결. **모든 OFD**가 같은 inode를 참조 가능.

> 용어 주의: 여기서 “OFD”는 **커널의 열린 파일 설명자**를 의미합니다(혼동주의). 잠금 장에서 나오는 **OFD lock**(Open File Description lock, `F_OFD_SETLK`)과도 맥락상 연결됩니다.

---

## 공유가 생기는 경로와 **오프셋 공유 여부**

| 시나리오 | FD 공유 | OFD(`struct file`) 공유 | 오프셋/상태 플래그 공유 | 설명 |
|---|---|---|---|---|
| `fork()` | ✅ | ✅ | ✅ | 부모의 FD 테이블 복제 → **같은 OFD**를 가리킴 |
| `dup()/dup2()/dup3()` | ✅ | ✅ | ✅ | 같은 OFD 복수 FD가 참조 |
| Unix 도메인 `sendmsg(SCM_RIGHTS)` | ✅(수신 FD) | ✅ | ✅ | 프로세스 간 **같은 OFD** 전달 |
| 각각 독립적으로 `open()` | ❌ | ❌ | ❌ | inode는 같을 수 있어도 **OFD는 별개** |
| 경로 재열기(`openat`) | ❌ | ❌ | ❌ | 독립 오프셋/플래그 |

- **파일 상태 플래그**(`O_APPEND`, `O_NONBLOCK`)는 **OFD에 저장** → OFD 공유 시 **플래그도 공유**.
- **FD 플래그**(`FD_CLOEXEC`)는 **FD 테이블 항목**에 저장 → FD마다 독립.

---

## 경쟁 조건과 **원자성** — 올바른 쓰기/읽기 패턴

### `lseek+read/write`는 경쟁의 온상

```c
// 나쁜 예: 두 쓰레드/프로세스가 같은 OFD를 공유하면 레이스
off_t off = lseek(fd, 0, SEEK_END);
write(fd, buf, len);                // 사이에 다른 쓰기가 끼면 위치가 바뀜
```
- **해결책**: 위치 지정 I/O 사용
  - **`pread(fd, buf, n, off)` / `pwrite(fd, buf, n, off)`** → **공유 오프셋(f_pos)을 건드리지 않음**.
  - **append 로그**: `O_APPEND` + **한 레코드=한 번의 `write`**.

### `O_APPEND`의 의미(정규 파일)

- POSIX는 **`O_APPEND`에서 “파일 끝으로의 위치 설정과 쓰기”를 원자적**으로 취급.
  한 번의 `write` 호출 내 바이트들이 **다른 쓰기와 섞이지 않도록** 끝에 순차적으로 배치되는 것이 보장(단, **원격 FS/NFS에서는 서버/클라이언트 구현에 의존**할 수 있어 **교차 클라이언트 원자성**은 추가 잠금이 필요).
- **중요**: “파이프/FIFO”의 `{PIPE_BUF}` 원자성 보장은 정규 파일에 그대로 적용되지 않음. **한 레코드는 반드시 한 번의 `write`**로.

### 읽기 원자성

- 단일 `read` 호출은 그 호출 내에서의 **오프셋 이동+읽기**가 원자적.
  하지만 **호출 간**에는 **다른 `read/write`가 오프셋을 바꿀 수 있음** → **`pread`** 사용.

---

## 잠금 — `flock`, POSIX `fcntl` 잠금, **OFD 잠금**, Mandatory 잠금

### 비교 표

| 종류 | 범위 | 의미 | 상호운용 | 해제 규칙 |
|---|---|---|---|---|
| `flock(LOCK_SH/LOCK_EX)` | **파일 전체** | Advisory(권고) | 단순, NFS와의 상호운용은 제한적(버전/옵션 의존) | **해당 OFD**(열린 파일 설명자) **모두 닫히면** 해제 |
| POSIX `fcntl`(F_SETLK/W) | **바이트 범위(레코드)** | Advisory | 표준적, 네트워크 잠금 데몬(`lockd`) 경유 | **프로세스 단위**: **그 프로세스가 가진 FD 아무거나 닫아도** 같은 파일의 **모든 레코드 잠금 해제** |
| **OFD 잠금**(`F_OFD_SETLK/W`) | **바이트 범위** | Advisory | Linux 고유, 현대적/안전 | **해당 OFD**가 닫힐 때만 해제(다른 FD 닫아도 유지) |
| Mandatory 잠금 | **바이트 범위** | 커널이 **강제** | 특수 마운트/모드 필요, 이식성/예측성 낮음 | 커널이 강제, 권장X |

> **실무 권장**: **OFD 잠금**(Linux) 또는 POSIX 레코드 잠금. 전체 파일 레벨이면 `flock`도 실용적.

### 예: OFD 잠금으로 안전한 업데이트

```c
#include <fcntl.h>

int lock_ofd(int fd, short type, off_t off, off_t len, int wait) {
  struct flock fl = {
    .l_type  = type,          // F_RDLCK or F_WRLCK or F_UNLCK
    .l_whence= SEEK_SET,
    .l_start = off,
    .l_len   = len            // 0 == EOF까지
  };
  return fcntl(fd, wait? F_OFD_SETLKW : F_OFD_SETLK, &fl);
}
```

### Mandatory 잠금은 피하라

- 마운트 옵션 `-o mand` + 파일의 **setgid 비트 ON, group-exec 비트 OFF** 같은 조건 필요.
- 구현 차, 교착/성능 문제 → **Advisory 잠금이 상식**.

---

## `mmap`과 파일 공유 — 일관성과 함정

- **`MAP_SHARED`**: 페이지 캐시 공유. **한 프로세스의 `pwrite`와 다른 프로세스의 맵핑**은 커널 페이지 캐시에서 **같은 데이터**를 보지만, **동기화 시점/가시화 순서는 레이스**.
  - **쓰기 경합**: `msync(MS_SYNC)` 또는 잠금으로 순서 보장.
  - **파일 크기 축소/홀 펀칭** 중인 영역 접근 → **`SIGBUS`** 가능.
- **`MAP_PRIVATE`(COW)**: 쓰기 시 사본. 파일에는 바로 반영되지 않음.
- **규칙**: `mmap` + `write()`를 **혼용**한다면 반드시 **잠금/프로토콜**로 순서와 경계를 규정하라.

---

## 파일 수명과 디렉터리 엔트리 — `unlink/rename`의 공유 의미

- **열린 파일은 살아있다**: `unlink(path)`로 디렉터리 엔트리를 지워도, **참조 중인 OFD가 남아 있으면 데이터는 유지**. 마지막 OFD가 닫힐 때 실제 제거.
  → **임시 파일** 패턴(보안/청소 유리).
- **로그 로테이션**: `mv app.log app.log.1 && kill -HUP` 패턴에서 **프로세스는 여전히 옛 inode에 쓰는 중**. 새 파일에 쓰려면 **재열기(reopen)** 필요.
- **원자적 교체**: `tmp`에 쓰고 `fsync(tmp)` → `rename(tmp, dst)` → `fsync(dir)`.

---

## FD 관리 — `CLOEXEC`, 대량 FD 닫기, FD 전달

- **FD 유출 방지**: `open(..., O_CLOEXEC)` 또는 `dup3(..., O_CLOEXEC)`, `F_SETFD(FD_CLOEXEC)`.
- **대량 FD 닫기**: `close_range(3, ~0U, 0)`(Linux) / `closefrom(3)`(BSD) / `/proc/self/fd` 열거.
- **프로세스 간 FD 전달**(Unix domain):
  ```c
  // sendmsg/recvmsg with SCM_RIGHTS → 상대 프로세스가 "같은 OFD" 획득(오프셋/플래그 공유)
  ```

---

## 네트워크 파일 공유 — NFS vs SMB **일관성·잠금·리스**

### NFS

- **Close-to-open** 일관성: 다른 클라이언트의 쓰기가 **열기/닫기** 시점에 동기화된다고 **가정**. **미세한 시차** 가능.
- **속성/데이터 캐시**: `acregmin/acregmax` 등(마운트 옵션)에 따라 **신선도 창**이 존재.
- **잠금**: `lockd/statd`(v3), v4는 통합. **서버 강제 원자성은 구현 의존**. **교차 클라이언트 append 원자성**이 필요한 경우 **레코드 잠금 사용** 권장.
- **바이패스 옵션**: `noac`(캐시 최소화) 등은 **성능 하락**과 맞교환.

### SMB (CIFS/SMB2/3)

- **Oplock/Lease**: 클라이언트 캐시 권한(읽기/쓰기) 부여, 충돌 시 **브레이크**(무효화).
- **Share modes**(deny read/write)와 **byte-range lock**이 **강제**되는 경우 많음.
- **Durable handles**: 클라이언트 재연결 시 핸들 복구.
- **Case-sensitivity**: 서버/셰어 설정에 따라 달라짐(코드/스크립트 주의).

> **현장 원칙**: **여러 머신**에서 같은 파일에 **순서/원자성**이 필요하면 **파일 잠금(레코드 잠금) + fsync 규율**을 협약으로 넣어라.

---

## 내구성과 오류 전파 — `fsync`, `close` 체크

- **`fsync(fd)` / `fdatasync(fd)`**: **디스크에 기록**(데이터/메타데이터 차이).
- **`close(fd)`**: 지연된 쓰기 오류가 **여기서 보고**될 수 있음 → **반환값 반드시 확인**.
- 로그·DB 저널: **버스트 쓰기 → `fsync`의 주기/경로 설계**.

---

## 성능/튜닝 — 대량 공유 접근에서의 실무 팁

- **`writev/readv`**: 헤더+바디 **한 번의 syscall**.
- **`sendfile`/`copy_file_range`**: 유저/커널 복사 제거(제로카피).
- **`posix_fadvise`**: `SEQUENTIAL/RANDOM`, `DONTNEED` 힌트로 캐시 오염 줄이기.
- **`O_DIRECT`**: 페이지 캐시 우회(정렬/크기 제약, 멀티 프로세스에서 캐시 간섭 감소).
- **멀티리액터 + `SO_REUSEPORT`**: 코어별 수신 분배.
- **`io_uring`**: 완료 큐 기반 고성능 비동기 파일 I/O.

---

## 예제 모음

### **오프셋 공유 버그 → `pread/pwrite`로 수정**

```c
// buggy_write.c : OFD 공유 환경에서 interleave/경쟁 발생
void buggy_append(int fd, const void *buf, size_t n){
  lseek(fd, 0, SEEK_END);              // 경쟁: 사이에 다른 쓰기가 들어오면…
  write(fd, buf, n);
}

// safe_append.c : append 로그 (한 레코드 = 한 write)
void safe_append(int fd, const void *buf, size_t n){
  // fd는 O_APPEND로 열렸다고 가정
  // 한 레코드를 한 번의 write로 보장해야 interleave 없음
  write(fd, buf, n);
}

// random_write.c : 공유 오프셋 무해화
ssize_t safe_write_at(int fd, const void *buf, size_t n, off_t off){
  return pwrite(fd, buf, n, off);      // f_pos에 영향 없음
}
```

### **OFD 잠금으로 크리티컬 섹션 보호**

```c
int update_region(int fd, off_t off, size_t len, const void *data){
  if (lock_ofd(fd, F_WRLCK, off, (off_t)len, /*wait*/1) < 0) return -1;
  if (pwrite(fd, data, len, off) != (ssize_t)len) { lock_ofd(fd, F_UNLCK, off, len, 0); return -1; }
  if (fsync(fd) < 0) { lock_ofd(fd, F_UNLCK, off, len, 0); return -1; }
  return lock_ofd(fd, F_UNLCK, off, (off_t)len, 0);
}
```

### **Unix 도메인으로 FD 전달 (SCM_RIGHTS)**

```c
// 송신측: fd를 다른 프로세스에 넘김 → 받은 쪽은 **같은 OFD** 획득
ssize_t send_fd(int sock, int fd){
  struct msghdr msg={0}; char buf[CMSG_SPACE(sizeof(int))]; memset(buf,0,sizeof buf);
  struct iovec io={ .iov_base="F", .iov_len=1 };
  msg.msg_iov=&io; msg.msg_iovlen=1; msg.msg_control=buf; msg.msg_controllen=sizeof buf;
  struct cmsghdr *c=CMSG_FIRSTHDR(&msg);
  c->cmsg_level=SOL_SOCKET; c->cmsg_type=SCM_RIGHTS; c->cmsg_len=CMSG_LEN(sizeof(int));
  memcpy(CMSG_DATA(c), &fd, sizeof(int));
  msg.msg_controllen = c->cmsg_len;
  return sendmsg(sock, &msg, 0);
}
```

### **unlink 후에도 살아있는 임시파일 사용**

```c
int fd = open("tmp.bin", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0600);
unlink("tmp.bin");   // 이름 제거 → 디렉터리에서 보이지 않음
// fd로 계속 접근 가능, 마지막 close 시 자동 제거
```

---

## 흔한 함정 체크리스트

- [ ] **같은 OFD**를 여러 쓰레드/프로세스가 쓰나? → **`pwrite`/`O_APPEND` + 한 번의 `write`** 규율
- [ ] 파일 레벨 동기화 필요? → **OFD 잠금 / POSIX 레코드 잠금** 채택
- [ ] `mmap`과 `write` 혼용? → **잠금** + `msync` 전략, 크기 변경 시 `SIGBUS` 주의
- [ ] 파일 교체/갱신의 원자성? → **임시→`fsync`→`rename`→디렉터리 `fsync`**
- [ ] NFS/SMB 등 **원격 FS**? → **교차 클라이언트 원자성**과 **캐시 일관성**을 잠금으로 보완
- [ ] FD 유출? → **`O_CLOEXEC`/`FD_CLOEXEC`** 기본값처럼 사용
- [ ] 종료 시 오류? → **`close` 반환값 확인**(지연 오류 전파)
- [ ] 로그 다중 작성자? → **`O_APPEND` + 레코드=한 번의 `write`**
- [ ] 대량 FD 정리? → `close_range`/`closefrom` 활용

---

## 고급 주제(요약)

- **File leases**(`F_SETLEASE`): 다른 프로세스가 열기/쓰기 시 **SIGIO** 알림(캐시/편집기 최적화).
- **`memfd_create` + file seals**: 익명 파일에 **SEAL_WRITE/SHRINK/GROW**로 변경 금지(안전한 공유 버퍼).
- **홀 펀칭**(`fallocate -p`/`FALLOC_FL_PUNCH_HOLE`): 공유 파일에 희소 블록 조작 → 동시 접근 시 일관성 계약 필요.
- **`RWF_NOWAIT`/`RWF_DSYNC`**: `pwritev2`로 페이지 캐시 폴트 회피/동기 쓰기.

---

## 미니 벤치/실험 시나리오(학습)

1) **append 레이스**
   - 두 프로세스가 같은 OFD 공유(`fork` 후) → `O_APPEND` 없이 `lseek+write` vs **`O_APPEND` + 한 번의 `write`** 비교.
2) **NFS 교차 클라이언트**
   - 두 머신에서 동시에 append → 잠금 없이 레코드 경계 깨짐 관찰 → **레코드 잠금** 적용 후 개선 확인.
3) **`mmap` + `write` 가시화**
   - A: `MAP_SHARED`로 맵핑 후 폴링, B: `pwrite`로 쓰기 → A에서 가시화 타이밍/`msync` 차이 관찰.

---

## 요약 한 줄

> **무엇을 공유하는가(오프셋/플래그/수명)와 언제 동기화하는가(잠금/append 규율/`fsync`)를 명시하면, 단일 호스트든 NFS/SMB든 “파일 공유”는 안전하고 예측 가능하게 운용할 수 있다.**

---
```c
/* 부록: 안전한 갱신 템플릿(임시→rename) */
int atomic_replace(int dfd, const char *tmp, const char *dst, const void *data, size_t n){
  int tfd = openat(dfd, tmp, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 0644);
  if (tfd<0) return -1;
  if (pwrite(tfd, data, n, 0)!=(ssize_t)n) { close(tfd); return -1; }
  if (fsync(tfd)<0) { close(tfd); return -1; }
  if (close(tfd)<0) return -1;
  if (renameat(dfd, tmp, dfd, dst)<0) return -1;
  if (fsync(dfd)<0) return -1;    // 디렉터리 엔트리까지 내구성
  return 0;
}
```
