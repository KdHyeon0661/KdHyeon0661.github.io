---
layout: post
title: 컴퓨터시스템 - 파일 공유
date: 2025-09-05 17:20:23 +0900
category: 컴퓨터시스템
---
# 파일 공유 (File Sharing) — UNIX/Linux 관점에서 심층 분석

> **목표:**  
> 여러 프로세스가 동일 파일에 접근할 때 발생하는 **커널 내부 동작**,  
> **오픈 파일 테이블 / 파일 디스크립터 구조**, **동기화·경쟁 조건 처리**,  
> **읽기/쓰기 모드·잠금**, **네트워크 파일 공유(NFS, SMB)**까지.

---

## 1. 파일 공유의 의미

파일 공유란 **둘 이상의 프로세스가 동일한 파일(또는 동일한 파일의 내용)에 접근**하는 것을 말합니다.

이 접근은 다음과 같이 이루어질 수 있습니다.

1. **프로세스 간 직접 공유**: fork, dup 등을 통해 같은 열린 파일 디스크립터를 공유
2. **독립적으로 open 호출**: 서로 다른 파일 디스크립터이지만 동일한 파일(같은 inode)을 가리킴
3. **네트워크를 통한 공유**: NFS, SMB 등으로 여러 머신에서 동일 파일 접근

---

## 2. 커널 내부 구조 — 파일 공유의 기본 메커니즘

UNIX/Linux 커널에서 파일 접근은 **세 개의 주요 자료구조**를 통해 관리됩니다.

```
프로세스 테이블 (Process Table)
    └─ 열린 파일 디스크립터 테이블 (per-process FD table)
          └─ 열린 파일 테이블 (system-wide open file table)
                └─ v-node / inode 구조체 (파일 자체의 메타데이터)
```

### 2.1 FD 테이블 (File Descriptor Table)
- **각 프로세스별**로 존재
- 각 엔트리는 열린 파일 테이블의 포인터와 **파일 상태 플래그**(FD_CLOEXEC 등)를 가짐
- `dup`, `dup2`, `fork` 등으로 공유 가능

### 2.2 열린 파일 테이블 (Open File Table)
- **시스템 전역**에서 공유됨
- `struct file` 구조체로 구현
- **읽기/쓰기 오프셋(file offset)**, **파일 상태 플래그(O_APPEND 등)** 보관
- FD 테이블의 여러 엔트리가 동일한 `struct file`을 가리킬 수 있음 → 오프셋이 공유됨

### 2.3 v-node / inode 테이블
- 파일 시스템 계층에서 실제 파일 메타데이터(크기, 소유자, 권한 등)를 관리
- 모든 열린 파일 인스턴스가 동일 inode를 참조 가능

---

## 3. 파일 공유 시나리오별 동작

| 상황 | FD 공유 여부 | Open File Table 공유 여부 | 파일 오프셋 공유? | 비고 |
|------|-------------|--------------------------|-------------------|------|
| `fork()` 후 부모·자식이 같은 FD 사용 | ✅ | ✅ | ✅ | 부모·자식이 같은 오프셋 공유 |
| `dup()` / `dup2()` | ✅ | ✅ | ✅ | 같은 FD와 동일한 `struct file` |
| 두 프로세스가 같은 파일을 별도로 `open()` | ❌ | ❌ | ❌ | 오프셋 독립 |
| `sendmsg`로 FD를 다른 프로세스에 전달 (Unix 도메인 소켓) | ✅ | ✅ | ✅ | IPC를 통한 FD 공유 |

---

## 4. 파일 오프셋 공유의 영향

동일 열린 파일 테이블을 공유하면 **read/write**가 **공용 오프셋**을 사용하므로:

- **경쟁 조건** 가능:
    ```c
    // P1, P2가 같은 열린 파일 테이블 공유
    read(fd, buf, 10);  // P1: offset 0 → 10
    read(fd, buf, 10);  // P2: offset 10 → 20
    ```
- **원자성 보장**: POSIX는 단일 read/write 호출의 오프셋 이동과 I/O를 원자적으로 처리
- 하지만 **두 개 이상의 호출 간에는 보호되지 않음** → 필요 시 `pread/pwrite` 사용

---

## 5. 파일 상태 플래그 vs FD 상태 플래그

- **파일 상태 플래그(file status flags)**:  
  `O_APPEND`, `O_NONBLOCK` 등, **열린 파일 테이블**에 저장 → FD 공유 시 전파됨
- **FD 상태 플래그(file descriptor flags)**:  
  `FD_CLOEXEC` 등, **FD 테이블**에 저장 → FD마다 독립

---

## 6. 동기화 메커니즘

### 6.1 레코드 잠금 (Record Locking)
- `fcntl(fd, F_SETLK, ...)` 또는 `lockf`
- **Advisory lock**: 모든 프로세스가 이 규칙을 지켜야 의미 있음
- **Mandatory lock**: 커널이 강제 (특정 mount 옵션 필요)

### 6.2 전체 파일 잠금
- `flock(fd, LOCK_EX)` → 배타 잠금
- `flock(fd, LOCK_SH)` → 공유 잠금
- `LOCK_UN` → 해제

### 6.3 원자적 I/O
- `O_APPEND` → 쓰기 시 자동으로 파일 끝에 오프셋 설정
- `pwrite` / `pread` → 오프셋 지정 I/O, 기존 오프셋에 영향 없음

---

## 7. 네트워크 파일 공유

### 7.1 NFS (Network File System)
- 파일 시스템 호출을 네트워크 RPC로 전달
- **캐시 일관성 문제**: 클라이언트 캐시 동기화 지연 가능
- 파일 잠금은 `rpc.lockd` 데몬에 의해 구현

### 7.2 SMB / CIFS
- 윈도우·리눅스 간 파일 공유
- 세션 기반, 상태 저장
- 강제 잠금 지원

### 7.3 클라우드 기반 공유
- Amazon EFS, Google Filestore 등
- POSIX 호환 API 제공

---

## 8. 보안 이슈

- FD를 잘못 공유하면 권한 없는 프로세스가 민감 데이터 접근 가능
- `O_CLOEXEC` 플래그로 exec 시 FD 자동 닫기
- 네트워크 공유 시 SMB/NFS 인증·암호화 필요

---

## 9. 예제 — FD 공유로 인한 오프셋 공유 확인

```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd = open("test.txt", O_RDWR|O_CREAT|O_TRUNC, 0666);
    write(fd, "HelloWorld", 10);

    int fd2 = dup(fd); // FD 공유
    lseek(fd, 5, SEEK_SET);
    char buf[6] = {0};
    read(fd2, buf, 5); // fd2도 offset=5부터 읽음
    printf("Read from fd2: %s\n", buf);
    close(fd);
    close(fd2);
}
```
**결과**
```
Read from fd2: World
```
→ `fd`와 `fd2`가 **같은 열린 파일 테이블**을 공유하므로 오프셋이 함께 변경됨.

---

## 10. 요약

- **파일 공유**는 커널 자료구조 구조상 자연스럽게 발생
- 공유 여부에 따라 **오프셋·상태 플래그 전파 여부**가 달라짐
- 여러 프로세스 접근 시 **동기화·잠금·원자성** 보장이 필수
- 네트워크 환경에서는 **일관성·보안**이 더 중요

---

📌 **핵심 기억 포인트**
1. **FD 테이블**은 프로세스별, **Open File Table**은 시스템 전역  
2. 오프셋·파일 상태 플래그는 열린 파일 테이블에 저장  
3. 동기화 위해 **flock/fcntl/pread/pwrite** 사용  
4. 네트워크 공유 시 **캐시 일관성·보안** 주의