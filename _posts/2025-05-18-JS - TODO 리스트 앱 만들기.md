---
layout: post
title: JavaScript - TODO 리스트 앱 만들기
date: 2025-05-18 19:20:23 +0900
category: JavaScript
---
# 자바스크립트로 TODO 리스트 앱 만들기

## 기본판 — 단일 파일로 완성

### HTML (기본 구조)

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>TODO App (Basic)</title>
  <link rel="stylesheet" href="style.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
  <main class="container">
    <h1>나의 할 일</h1>

    <form id="todo-form" autocomplete="off">
      <label class="visually-hidden" for="todo-input">할 일 추가</label>
      <input type="text" id="todo-input" placeholder="할 일을 입력하세요" required />
      <button type="submit">추가</button>
    </form>

    <ul id="todo-list" aria-live="polite" aria-label="할 일 목록"></ul>

    <footer class="statusbar" aria-live="polite">
      <span id="count-remaining">0개 남음</span>
      <button id="clear-done" type="button">완료 모두 삭제</button>
    </footer>
  </main>

  <script src="app.basic.js" defer></script>
</body>
</html>
```

### CSS (기본 스타일)

```css
/* style.css */
:root {
  --gap: 12px;
  --border: #ddd;
  --muted: #777;
  --done: #9aa0a6;
  --accent: #1a73e8;
}

* { box-sizing: border-box; }
body {
  font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  margin: 0;
  color: #222;
}
.container {
  max-width: 560px;
  margin: 2rem auto;
  padding: 0 1rem 2rem;
}
h1 { margin: 0 0 1rem; }

#todo-form {

  display: flex;
  gap: var(--gap);
  margin-bottom: 1rem;
}
#todo-input {

  flex: 1;
  padding: .6rem .75rem;
  border: 1px solid var(--border);
  border-radius: 6px;
}
#todo-form button {

  padding: .6rem 1rem;
  border: 1px solid var(--border);
  background: #fff;
  border-radius: 6px;
  cursor: pointer;
}
#todo-form button:hover { border-color: #ccc; }

#todo-list {

  list-style: none;
  padding: 0;
  margin: 0;
}
.todo {
  display: grid;
  grid-template-columns: 28px 1fr auto;
  align-items: center;
  gap: var(--gap);
  padding: .5rem 0;
  border-bottom: 1px solid var(--border);
}
.todo .toggle {
  width: 18px;
  height: 18px;
  border-radius: 4px;
  border: 1px solid var(--border);
  display: inline-grid;
  place-items: center;
  cursor: pointer;
}
.todo.done .text {
  color: var(--done);
  text-decoration: line-through;
}
.todo .remove {
  border: 0;
  background: transparent;
  color: var(--muted);
  cursor: pointer;
}
.todo .remove:hover { color: #000; }

.statusbar {
  display: flex;
  justify-content: space-between;
  margin-top: 1rem;
  color: var(--muted);
}
.statusbar button {
  border: 0;
  background: transparent;
  color: var(--accent);
  cursor: pointer;
}
.statusbar button:hover { text-decoration: underline; }

.visually-hidden {
  position: absolute !important;
  width: 1px; height: 1px;
  margin: -1px; padding: 0;
  overflow: hidden; clip: rect(0 0 0 0);
  border: 0;
}
```

### JS (기본 동작)

```js
// app.basic.js
const form = document.getElementById("todo-form");
const input = document.getElementById("todo-input");
const list = document.getElementById("todo-list");
const countRemaining = document.getElementById("count-remaining");
const clearDoneBtn = document.getElementById("clear-done");

// 데이터 로드
let todos = JSON.parse(localStorage.getItem("todos.v1") || "[]");

const save = () => localStorage.setItem("todos.v1", JSON.stringify(todos));

const renderOne = (todo) => {
  const li = document.createElement("li");
  li.className = "todo" + (todo.done ? " done" : "");
  li.dataset.id = todo.id;

  const toggle = document.createElement("button");
  toggle.className = "toggle";
  toggle.setAttribute("aria-label", todo.done ? "완료 해제" : "완료 처리");
  toggle.innerHTML = todo.done ? "✓" : "";

  const text = document.createElement("span");
  text.className = "text";
  text.textContent = todo.text;

  const remove = document.createElement("button");
  remove.className = "remove";
  remove.textContent = "삭제";
  remove.setAttribute("aria-label", `${todo.text} 삭제`);

  li.append(toggle, text, remove);
  list.appendChild(li);
};

const renderAll = () => {
  list.innerHTML = "";
  todos.forEach(renderOne);
  const remaining = todos.filter(t => !t.done).length;
  countRemaining.textContent = `${remaining}개 남음`;
};

form.addEventListener("submit", (e) => {
  e.preventDefault();
  const text = input.value.trim();
  if (!text) return;
  const todo = { id: Date.now(), text, done: false };
  todos.push(todo);
  save();
  renderOne(todo);
  input.value = "";
  input.focus();
  const remaining = todos.filter(t => !t.done).length;
  countRemaining.textContent = `${remaining}개 남음`;
});

// 이벤트 위임: 완료 토글/삭제
list.addEventListener("click", (e) => {
  const li = e.target.closest(".todo");
  if (!li) return;
  const id = Number(li.dataset.id);
  const todo = todos.find(t => t.id === id);
  if (!todo) return;

  if (e.target.classList.contains("toggle")) {
    todo.done = !todo.done;
    save();
    li.classList.toggle("done");
    e.target.innerHTML = todo.done ? "✓" : "";
    e.target.setAttribute("aria-label", todo.done ? "완료 해제" : "완료 처리");
    const remaining = todos.filter(t => !t.done).length;
    countRemaining.textContent = `${remaining}개 남음`;
  }

  if (e.target.classList.contains("remove")) {
    todos = todos.filter(t => t.id !== id);
    save();
    li.remove();
    const remaining = todos.filter(t => !t.done).length;
    countRemaining.textContent = `${remaining}개 남음`;
  }
});

// 완료 모두 삭제
clearDoneBtn.addEventListener("click", () => {
  todos = todos.filter(t => !t.done);
  save();
  renderAll();
});

// 초기 렌더
renderAll();
```

여기까지가 가장 단순하면서도 실전에서 바로 쓸 수 있는 최소 구현입니다.

---

## 확장판 — 모듈화(MVC), 필터/편집/단축키/Undo

폴더 구조 예시:

```
/public
  index.html
  styles.css
  /js
    app.js
    model.js
    view.js
    controller.js
    storage.js
    utils.js
```

### HTML (필터/편집 대비 마크업)

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>TODO App (Pro)</title>
  <link rel="stylesheet" href="styles.css" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
  <main class="container">
    <h1>나의 할 일</h1>

    <form id="todo-form" autocomplete="off">
      <label for="todo-input" class="visually-hidden">할 일 추가</label>
      <input id="todo-input" placeholder="할 일을 입력하세요" required />
      <button type="submit">추가</button>
    </form>

    <nav class="filters" aria-label="보기 필터">
      <button data-filter="all" class="filter is-active">전체</button>
      <button data-filter="active" class="filter">진행중</button>
      <button data-filter="completed" class="filter">완료</button>
    </nav>

    <ul id="todo-list" role="list" aria-live="polite" aria-busy="false"></ul>

    <footer class="statusbar" aria-live="polite">
      <span id="count-remaining">0개 남음</span>
      <div class="actions">
        <button id="toggle-all" type="button">모두 완료/해제</button>
        <button id="clear-done" type="button">완료 모두 삭제</button>
        <button id="undo" type="button" disabled>실행 취소</button>
      </div>
    </footer>
  </main>

  <script type="module" src="./js/app.js"></script>
</body>
</html>
```

### Storage 유틸 (버전/스로틀/동기화)

```js
// js/storage.js
const KEY = 'todos.v2';
const VERSION = 2;

export function load() {
  try {
    const raw = localStorage.getItem(KEY);
    if (!raw) return { version: VERSION, items: [] };
    const parsed = JSON.parse(raw);
    // 간단한 마이그레이션 예시
    if (parsed.version !== VERSION) {
      const migrated = { version: VERSION, items: parsed.items || parsed };
      localStorage.setItem(KEY, JSON.stringify(migrated));
      return migrated;
    }
    return parsed;
  } catch {
    return { version: VERSION, items: [] };
  }
}

let saveTimer = null;
export function save(data, { throttle=120 } = {}) {
  if (saveTimer) cancelIdleCallback?.(saveTimer);
  // 유휴 시간에 저장(가능한 브라우저) + 스로틀
  saveTimer = requestIdleCallback?.(() => {
    localStorage.setItem(KEY, JSON.stringify(data));
  }, { timeout: throttle }) || setTimeout(() => {
    localStorage.setItem(KEY, JSON.stringify(data));
  }, throttle);
}

// 다른 탭에서 변경되면 sync
export function onExternalChange(cb) {
  window.addEventListener('storage', (e) => {
    if (e.key === KEY) cb();
  });
}
```

### Model (비즈니스 로직 + Undo 스택)

```js
// js/model.js
import { load, save, onExternalChange } from './storage.js';

export class TodoModel {
  constructor() {
    const { items } = load();
    this.items = items;           // [{id, text, done}]
    this.filter = 'all';          // all | active | completed
    this.undoStack = [];          // 직전 스냅샷
    onExternalChange(() => this._notify && this._notify('external'));
  }
  subscribe(fn) { this._notify = fn; }

  snapshot() { this.undoStack.push(structuredClone(this.items)); }

  undo() {
    const prev = this.undoStack.pop();
    if (!prev) return false;
    this.items = prev;
    this._persist();
    this._notify('undo');
    return true;
  }

  _persist() { save({ version: 2, items: this.items }); }

  list() {
    switch (this.filter) {
      case 'active': return this.items.filter(i => !i.done);
      case 'completed': return this.items.filter(i => i.done);
      default: return this.items;
    }
  }
  counts() {
    const remaining = this.items.filter(i => !i.done).length;
    const total = this.items.length;
    return { remaining, total };
  }

  add(text) {
    this.snapshot();
    this.items.push({ id: crypto.randomUUID?.() || Date.now(), text, done: false });
    this._persist(); this._notify('add');
  }
  toggle(id) {
    this.snapshot();
    const t = this.items.find(i => i.id === id);
    if (t) t.done = !t.done;
    this._persist(); this._notify('toggle');
  }
  remove(id) {
    this.snapshot();
    this.items = this.items.filter(i => i.id !== id);
    this._persist(); this._notify('remove');
  }
  edit(id, text) {
    this.snapshot();
    const t = this.items.find(i => i.id === id);
    if (t) t.text = text;
    this._persist(); this._notify('edit');
  }
  clearCompleted() {
    this.snapshot();
    this.items = this.items.filter(i => !i.done);
    this._persist(); this._notify('clearDone');
  }
  toggleAll() {
    this.snapshot();
    const allDone = this.items.length && this.items.every(i => i.done);
    this.items.forEach(i => i.done = !allDone);
    this._persist(); this._notify('toggleAll');
  }
  setFilter(f) {
    this.filter = f;
    this._notify('filter');
  }
}
```

### View (렌더/이벤트 위임/인라인 편집)

```js
// js/view.js
export class View {
  constructor() {
    this.dom = {
      form: document.getElementById('todo-form'),
      input: document.getElementById('todo-input'),
      list: document.getElementById('todo-list'),
      remaining: document.getElementById('count-remaining'),
      clearDone: document.getElementById('clear-done'),
      toggleAll: document.getElementById('toggle-all'),
      filters: document.querySelector('.filters'),
      undo: document.getElementById('undo'),
    };
    this.dom.list.addEventListener('click', this._onListClick.bind(this));
    this.dom.list.addEventListener('dblclick', this._onDblClick.bind(this));
    this.dom.list.addEventListener('keydown', this._onListKey.bind(this));
  }

  onAdd(handler) {
    this.dom.form.addEventListener('submit', (e) => {
      e.preventDefault();
      const text = this.dom.input.value.trim();
      if (!text) return;
      handler(text);
      this.dom.input.value = '';
      this.dom.input.focus();
    });
  }
  onToggle(handler) { this._toggleHandler = handler; }
  onRemove(handler) { this._removeHandler = handler; }
  onEdit(handler) { this._editHandler = handler; }
  onClearDone(handler) { this.dom.clearDone.addEventListener('click', handler); }
  onToggleAll(handler) { this.dom.toggleAll.addEventListener('click', handler); }
  onFilter(handler) {
    this.dom.filters.addEventListener('click', (e) => {
      const btn = e.target.closest('.filter');
      if (!btn) return;
      this.dom.filters.querySelectorAll('.filter').forEach(b => b.classList.remove('is-active'));
      btn.classList.add('is-active');
      handler(btn.dataset.filter);
    });
  }
  onUndo(handler) { this.dom.undo.addEventListener('click', handler); }

  render(items, { remaining }) {
    const frag = document.createDocumentFragment();
    for (const t of items) frag.appendChild(this._item(t));
    this.dom.list.innerHTML = '';
    this.dom.list.appendChild(frag);
    this.dom.remaining.textContent = `${remaining}개 남음`;
  }
  setUndoEnabled(enabled) { this.dom.undo.disabled = !enabled; }

  _item(todo) {
    const li = document.createElement('li');
    li.className = 'todo' + (todo.done ? ' done' : '');
    li.dataset.id = todo.id;

    const toggle = document.createElement('button');
    toggle.className = 'toggle';
    toggle.innerHTML = todo.done ? '✓' : '';
    toggle.setAttribute('aria-label', todo.done ? '완료 해제' : '완료 처리');

    const text = document.createElement('span');
    text.className = 'text';
    text.textContent = todo.text;
    text.tabIndex = 0; // 키보드 포커스 가능

    const remove = document.createElement('button');
    remove.className = 'remove';
    remove.textContent = '삭제';

    li.append(toggle, text, remove);
    return li;
  }

  _onListClick(e) {
    const li = e.target.closest('.todo');
    if (!li) return;
    const id = li.dataset.id;

    if (e.target.classList.contains('toggle')) this._toggleHandler?.(id);
    if (e.target.classList.contains('remove')) this._removeHandler?.(id);
  }

  // 더블클릭/Enter로 인라인 편집
  _onDblClick(e) {
    const span = e.target.closest('.text');
    if (!span) return;
    const li = span.closest('.todo');
    const id = li.dataset.id;
    const input = document.createElement('input');
    input.type = 'text';
    input.value = span.textContent;
    input.className = 'edit';
    input.setAttribute('aria-label', '항목 편집');
    li.replaceChild(input, span);
    input.focus();
    input.select();

    const commit = () => {
      const v = input.value.trim();
      const newText = v || span.textContent;
      this._editHandler?.(id, newText);
    };
    const cancel = () => { this._editHandler?.(id, span.textContent); };

    input.addEventListener('blur', commit, { once: true });
    input.addEventListener('keydown', (evt) => {
      if (evt.key === 'Enter') { evt.preventDefault(); commit(); }
      if (evt.key === 'Escape') { evt.preventDefault(); cancel(); }
    }, { once: true });
  }

  // Space로 완료 토글, Delete로 삭제
  _onListKey(e) {
    const li = e.target.closest('.todo');
    if (!li) return;
    const id = li.dataset.id;
    if (e.key === ' ' || e.key === 'Spacebar') {
      e.preventDefault();
      this._toggleHandler?.(id);
    }
    if (e.key === 'Delete') {
      e.preventDefault();
      this._removeHandler?.(id);
    }
  }
}
```

### Controller (연결/키바인딩)

```js
// js/controller.js
export class Controller {
  constructor(model, view) {
    this.model = model;
    this.view = view;

    this.model.subscribe((event) => {
      this.view.render(this.model.list(), this.model.counts());
      this.view.setUndoEnabled(this.model.undoStack.length > 0);
      if (event === 'external') {
        // 외부 탭 변경 알림 등 추가 UX 가능
      }
    });

    this.view.onAdd((text) => this.model.add(text));
    this.view.onToggle((id) => this.model.toggle(id));
    this.view.onRemove((id) => this.model.remove(id));
    this.view.onEdit((id, text) => this.model.edit(id, text));
    this.view.onClearDone(() => this.model.clearCompleted());
    this.view.onToggleAll(() => this.model.toggleAll());
    this.view.onFilter((f) => this.model.setFilter(f));
    this.view.onUndo(() => this.model.undo());

    // 초기 렌더
    this.view.render(this.model.list(), this.model.counts());
    this.view.setUndoEnabled(this.model.undoStack.length > 0);

    // 전역 단축키: Ctrl+Enter 추가, Ctrl+Z undo
    window.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'Enter') {
        const input = document.getElementById('todo-input');
        const v = input.value.trim();
        if (v) this.model.add(v);
      }
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
        this.model.undo();
      }
    });
  }
}
```

### 앱 엔트리

```js
// js/app.js
import { TodoModel } from './model.js';
import { View } from './view.js';
import { Controller } from './controller.js';

new Controller(new TodoModel(), new View());
```

---

## 데이터 영속화 심화

- **스키마 버전**을 키에 포함하거나 값에 `version` 필드로 두고 마이그레이션 경로를 유지합니다.
- 저장은 **스로틀/유휴 시간**에 묶어 과도한 디스크 I/O를 줄입니다.
- 다른 탭 동기화는 `storage` 이벤트로 반영합니다.

서버 동기화가 필요하면, **온라인/오프라인 이벤트**와 **백오프 재시도**를 결합하고, 충돌 해결 정책(라스트 라이터/병합)을 정의합니다.

---

## 접근성/UX

- 각 항목은 `role="listitem"`이 기본(UL/LI면 OK). 텍스트 스팬에 `tabindex="0"`으로 키보드 포커스 허용.
- 상태 변경 시 `aria-live="polite"` 영역 문구 업데이트(남은 개수).
- 인라인 편집 입력에 `aria-label` 제공, Enter/ESC/Blur로 완료/취소.
- 키보드: Space → 토글, Delete → 삭제, Ctrl+Z → Undo, Ctrl+Enter → 추가.
- 포커스 이동: 항목 삭제 후 **이전/다음 항목**으로 포커스 넘기면 조작성 향상.

---

## 성능/아키텍처 팁

- **이벤트 위임**: 리스트 전체에 한 번만 리스너를 붙이면 항목 수가 커져도 성능 유지.
- 렌더 최적화: 전체 재렌더 대신 **변경된 항목만 패치**(지금도 토글/삭제는 패치 방식).
- 대규모 목록: 화면 뷰포트 기준으로만 DOM을 유지하는 **가상 스크롤**(IntersectionObserver/라이브러리) 고려.
- 큰 텍스트 편집 시 입력 디바운스/스로틀로 잦은 저장 방지.

---

## 테스트/디버깅/배포 체크리스트

- 단위 테스트: Model 메서드(add/toggle/edit/remove/clearCompleted/toggleAll/undo)
- E2E: 추가→토글→필터→편집→삭제→완료 삭제 플로우
- 로컬 스토리지 손상 대비: `try/catch` + 초기화
- 배포 전: CSS/JS **압축**, 파일명 **캐시 버스팅**, `rel="preload"`로 핵심 리소스 앞당기기
- PWA 확장: `service worker`로 오프라인에서도 동작(추가 과제)

---

## 확장 아이디어

- 마감일/우선순위, 정렬/검색
- 태그/프로젝트 보드
- 알림(reminder) + Notification API
- 서버 동기화(계정/다중 디바이스), 충돌 해결
- 마크다운/첨부파일

---

## 최소 단일 파일 버전 (학습/실습용)

아래는 단일 HTML 파일만으로 동작하는 간략판입니다.

```html
<!DOCTYPE html>
<html lang="ko">
<meta charset="utf-8">
<title>TODO Single File</title>
<style>
  body { font-family: system-ui, sans-serif; max-width: 560px; margin: 2rem auto; }
  form { display: flex; gap: 8px; }
  input[type=text]{ flex:1; padding:.5rem; }
  ul{ list-style:none; padding:0; }
  li{ display:grid; grid-template-columns: 24px 1fr auto; gap:8px; align-items:center; border-bottom:1px solid #eee; padding:.4rem 0; }
  .done .txt{ color:#9aa0a6; text-decoration: line-through; }
  .toggle{ width:18px; height:18px; border:1px solid #ccc; border-radius:4px; display:inline-grid; place-items:center; }
  .remove{ background:transparent; border:0; color:#666; cursor:pointer; }
  .filters{ display:flex; gap:8px; margin:.5rem 0; }
  .filters .is-active{ font-weight:700; }
</style>
<body>
  <h1>TODO</h1>
  <form id="f"><input id="i" placeholder="할 일을 입력" required><button>추가</button></form>
  <nav class="filters">
    <button data-f="all" class="is-active">전체</button>
    <button data-f="active">진행중</button>
    <button data-f="completed">완료</button>
  </nav>
  <ul id="lst"></ul>
  <p id="cnt">0개 남음</p>

<script>
const f = document.getElementById('f'), i = document.getElementById('i'), lst = document.getElementById('lst'), cnt = document.getElementById('cnt');
let S = JSON.parse(localStorage.getItem('todos.v1')||'[]'), filter='all';

const save=()=>localStorage.setItem('todos.v1', JSON.stringify(S));
const view=()=>{ lst.innerHTML=''; S.filter(t=>filter==='active'?!t.done:filter==='completed'?t.done:true).forEach(t=>addDom(t)); cnt.textContent=`${S.filter(t=>!t.done).length}개 남음`; };

f.addEventListener('submit', e=>{ e.preventDefault(); const v=i.value.trim(); if(!v) return; const t={id:Date.now(), text:v, done:false}; S.push(t); save(); addDom(t); i.value=''; i.focus(); cnt.textContent=`${S.filter(x=>!x.done).length}개 남음`; });

lst.addEventListener('click', e=>{
  const li=e.target.closest('li'); if(!li) return; const id=+li.dataset.id; const t=S.find(x=>x.id===id); if(!t) return;
  if(e.target.classList.contains('toggle')){ t.done=!t.done; save(); li.classList.toggle('done'); e.target.textContent=t.done?'✓':''; cnt.textContent=`${S.filter(x=>!x.done).length}개 남음`; }
  if(e.target.classList.contains('remove')){ S=S.filter(x=>x.id!==id); save(); li.remove(); cnt.textContent=`${S.filter(x=>!x.done).length}개 남음`; }
});

document.querySelector('.filters').addEventListener('click', e=>{
  const b=e.target.closest('button'); if(!b) return; document.querySelectorAll('.filters button').forEach(x=>x.classList.remove('is-active')); b.classList.add('is-active'); filter=b.dataset.f; view();
});

function addDom(t){
  const li=document.createElement('li'); li.dataset.id=t.id; li.className='todo'+(t.done?' done':'');
  const tg=document.createElement('button'); tg.className='toggle'; tg.textContent=t.done?'✓':'';
  const sp=document.createElement('span'); sp.className='txt'; sp.textContent=t.text;
  const rm=document.createElement('button'); rm.className='remove'; rm.textContent='삭제';
  li.append(tg,sp,rm); lst.append(li);
}
view();
</script>
</body>
</html>
```
