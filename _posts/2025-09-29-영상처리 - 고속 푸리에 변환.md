---
layout: post
title: 영상처리 - 고속 푸리에 변환
date: 2025-09-29 17:25:23 +0900
category: 영상처리
---
# 고속 푸리에 변환(FFT)

## 고속 푸리에 변환의 이론적 배경

### DFT와 복잡도

- 직접 DFT: \(\mathcal{O}(N^2)\)
- FFT: 대표적으로 **Cooley–Tukey** 분할정복으로 \(\mathcal{O}(N\log_2N)\)

### Radix-2 DIT(Decimation in Time)

입력 길이 \(N=2^m\) 일 때,
- 시퀀스를 짝/홀 인덱스로 분해하고 (재귀적으로) 합성할 때 **나비 연산(butterfly)** 사용
- 각 스테이지마다 **twiddle factor** \(W_N^k = e^{-j2\pi k/N}\) 를 곱함
- 최종 단계에서 **비트반전(bit-reversal)** 정렬이 요구 → 반복형 구현에선 **초기에** 비트반전 재배치

### 역변환(IFFT)과 스케일

- IFFT는 지수 부호만 반대로 하거나 **켤레→정방 FFT→다시 켤레**로 계산
- 관례: **IFFT 출력에 \(1/N\) 스케일**을 곱함(앞선 장들과 동일)

### 2D FFT

- 1D FFT를 **모든 행** → **모든 열**에 차례로 적용 (Row–Column)
- 복잡도: \(\mathcal{O}(WH(\log W + \log H))\)

---

## 1D FFT — 반복형 Radix-2 (비트반전, 캐시 포함)

### 핵심 구현

- **비트반전 테이블**: 입력 재배치
- **단계별 나비**: 길이 \(2,4,8,\dots,N\) 블록
- **twiddle 캐시**: \(N\)별 \(W_N^k\) 미리 저장
- **정방/역변환**: `inverse=false/true` 플래그

```cpp
// fft1d.hpp
#pragma once
#include <vector>
#include <complex>
#include <cmath>
#include <unordered_map>
#include <stdexcept>
#include <cstdint>

using cd = std::complex<double>;
constexpr double PI = 3.14159265358979323846;

inline bool is_power_of_two(size_t n){ return n && ( (n & (n-1)) == 0 ); }
inline size_t next_pow2(size_t n){ size_t p=1; while (p<n) p<<=1; return p; }

// 비트반전 인덱스 테이블
inline std::vector<size_t> bitrev_indices(size_t N){
    size_t bits=0; while ((1u<<bits) < N) ++bits;
    std::vector<size_t> r(N);
    for (size_t i=0;i<N;++i){
        size_t x=i, y=0;
        for (size_t b=0;b<bits;++b){ y=(y<<1) | (x&1); x>>=1; }
        r[i]=y;
    }
    return r;
}

// N 별 twiddle 캐시: e^{±j2πk/N}
struct TwiddleStore {
    struct Pair { std::vector<cd> wFwd, wInv; };
    std::unordered_map<size_t, Pair> tbl;

    const Pair& get(size_t N){
        auto it = tbl.find(N);
        if (it!=tbl.end()) return it->second;
        Pair p; p.wFwd.resize(N); p.wInv.resize(N);
        for (size_t k=0;k<N;++k){
            double ang = -2.0*PI*double(k)/double(N);
            p.wFwd[k]=cd(std::cos(ang), std::sin(ang));
            p.wInv[k]=std::conj(p.wFwd[k]); // +j 부호
        }
        return tbl.emplace(N, std::move(p)).first->second;
    }
};

// In-place 반복형 FFT (Radix-2, DIT)
inline void fft1d_inplace(std::vector<cd>& a, bool inverse=false, TwiddleStore* store=nullptr){
    const size_t N=a.size();
    if (!is_power_of_two(N)) throw std::runtime_error("fft1d_inplace: N must be power of two");
    static TwiddleStore s_store;
    if (!store) store = &s_store;

    // 1) 비트반전 재배치
    auto br = bitrev_indices(N);
    for (size_t i=0;i<N;++i){
        size_t j=br[i];
        if (i<j) std::swap(a[i], a[j]);
    }

    // 2) 단계별 나비
    const auto& tw = store->get(N);
    const cd* W = inverse ? tw.wInv.data() : tw.wFwd.data();

    for (size_t len=2; len<=N; len<<=1){
        size_t half = len>>1;
        size_t step = N/len; // twiddle 증가량
        for (size_t i=0; i<N; i+=len){
            size_t k=0;
            for (size_t j=0; j<half; ++j, k+=step){
                cd u = a[i+j];
                cd v = a[i+j+half] * W[k];
                a[i+j]       = u + v;
                a[i+j+half]  = u - v;
            }
        }
    }

    // 3) IFFT 스케일
    if (inverse){
        double invN = 1.0/double(N);
        for (auto& z : a) z *= invN;
    }
}
```

---

## 2D 영상 FFT — 행·열 분리, 센터링/창/패딩 포함

### 센터링, 2D 패딩

- `IppDib → 그레이(double)` 변환
- 옵션별로 **창/센터링/패딩** 적용
- 복소행렬 \(A[y,x]\) 로 구성 후 **행 FFT→열 FFT**

```cpp
// fft2d.hpp
#pragma once
#include <vector>
#include <complex>
#include <cmath>
#include "IppDib.h"
#include "fft1d.hpp"

inline void DibToGray(const IppDib& src, std::vector<double>& G, int& W, int& H){
    if (!src){ W=H=0; G.clear(); return; }
    W=src.width(); H=src.height();
    G.assign((size_t)W*H, 0.0);
    for (int y=0;y<H;++y){
        const uint8_t* row=(const uint8_t*)src.bits()+(size_t)y*src.stride();
        for (int x=0;x<W;++x){
            int B=row[x*4+0], Gc=row[x*4+1], R=row[x*4+2];
            G[(size_t)y*W+x] = 0.114*B + 0.587*Gc + 0.299*R;
        }
    }
}
inline std::vector<double> hann1d(int N){
    std::vector<double> w(N,1.0); if (N<=1) return w;
    for (int n=0;n<N;++n) w[n]=0.5*(1.0 - std::cos(2.0*PI*n/(N-1)));
    return w;
}
inline void apply_window_2d(std::vector<double>& G, int W, int H, const std::vector<double>& wx, const std::vector<double>& wy){
    for (int y=0;y<H;++y) for (int x=0;x<W;++x) G[(size_t)y*W+x]*=wx[x]*wy[y];
}
inline void apply_centering_2d(std::vector<double>& G, int W, int H){
    for (int y=0;y<H;++y) for (int x=0;x<W;++x) if (((x^y)&1)) G[(size_t)y*W+x]*=-1.0;
}
inline void pad2d_real(const std::vector<double>& G, int W, int H, std::vector<cd>& A, int PW, int PH){
    A.assign((size_t)PW*PH, cd(0,0));
    for (int y=0;y<std::min(H,PH);++y){
        for (int x=0;x<std::min(W,PW);++x){
            A[(size_t)y*PW+x] = cd(G[(size_t)y*W+x], 0.0);
        }
    }
}

// A(PH×PW)에 대해: 모든 행→모든 열 FFT
inline void fft2d_inplace(std::vector<cd>& A, int PW, int PH, bool inverse=false, TwiddleStore* store=nullptr){
    // 행
    std::vector<cd> buf;
    for (int y=0;y<PH;++y){
        cd* row = &A[(size_t)y*PW];
        std::vector<cd> v(row, row+PW);
        fft1d_inplace(v, inverse, store);
        std::copy(v.begin(), v.end(), row);
    }
    // 열
    buf.resize((size_t)PH);
    for (int x=0;x<PW;++x){
        for (int y=0;y<PH;++y) buf[y]=A[(size_t)y*PW+x];
        fft1d_inplace(buf, inverse, store);
        for (int y=0;y<PH;++y) A[(size_t)y*PW+x]=buf[y];
    }
}

// log 스펙트럼(DIB)
inline IppDib SpectrumImage(const std::vector<cd>& F, int W, int H, bool alreadyCentered=true){
    std::vector<double> mag((size_t)W*H);
    double maxv=1e-12;
    for (size_t i=0;i<mag.size();++i){
        double v = std::log(1.0 + std::abs(F[i]));
        mag[i]=v; if (v>maxv) maxv=v;
    }
    double inv = 255.0/maxv;
    IppDib out; out.create(W,H,32);
    auto put=[&](int x,int y,uint8_t g){
        uint8_t* p=(uint8_t*)out.bits()+(size_t)y*out.stride()+x*4;
        p[0]=p[1]=p[2]=g; p[3]=255;
    };
    int cx=W/2, cy=H/2;
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            int sx = alreadyCentered ? (x+cx)%W : x;
            int sy = alreadyCentered ? (y+cy)%H : y;
            uint8_t g=(uint8_t)std::lround(std::min(255.0, mag[(size_t)sy*W+sx]*inv));
            put(x,y,g);
        }
    }
    return out;
}
```

### 고수준 파이프라인(정방/역방, 옵션)

```cpp
// fft_pipeline.hpp
#pragma once
#include "fft2d.hpp"

struct FFTOptions {
    bool  useHann=true;
    bool  centering=true;      // 입력에 (-1)^(x+y)
    bool  padToPow2=true;
    bool  inverse=false;       // false: 정방FFT(스펙트럼 출력), true: 역FFT(공간복원)
    int   forcePW=0, forcePH=0;// 0이면 자동
};

// 출력: 정방FFT면 스펙트럼 DIB, 역FFT면 공간 DIB
inline bool RunFFT2D(const IppDib& in, IppDib& out, FFTOptions opt){
    int W,H; std::vector<double> G;
    DibToGray(in, G, W, H); if (W<=0||H<=0) return false;

    if (opt.useHann){
        auto wx=hann1d(W), wy=hann1d(H);
        apply_window_2d(G, W, H, wx, wy);
    }
    if (opt.centering) apply_centering_2d(G, W, H);

    int PW = (opt.forcePW>0)? opt.forcePW : (opt.padToPow2? (int)next_pow2(W) : W);
    int PH = (opt.forcePH>0)? opt.forcePH : (opt.padToPow2? (int)next_pow2(H) : H);

    std::vector<cd> A;
    pad2d_real(G, W, H, A, PW, PH);

    // 정방/역
    TwiddleStore cache;
    if (!opt.inverse){
        fft2d_inplace(A, PW, PH, /*inverse=*/false, &cache);
        out = SpectrumImage(A, PW, PH, /*alreadyCentered=*/opt.centering);
    } else {
        // 역FFT 경로: A를 "주파수 도메인"으로 가정해야 함.
        // 본 예제는 교육을 위해 정방FFT→필터→역FFT를 한 턴에 수행하는 래퍼를 아래 별도 제공.
        return false;
    }
    return true;
}
```

---

## + **복원(IFFT)** 예제

아래는 한 번에: 입력 → (옵션)창/센터링/패딩 → **정방FFT** → **필터マ스크** 곱 → **역FFT** → (센터링 복원) → DIB.

```cpp
// fft_filter.hpp
#pragma once
#include "fft2d.hpp"

// 이상적 원형 저역통과 마스크
inline void ideal_lowpass_mask(std::vector<double>& M, int W, int H, double radius){
    M.assign((size_t)W*H, 0.0);
    double cx=W/2.0, cy=H/2.0;
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            double dx = std::min(std::abs(x-cx), std::abs(x-(cx+W))); // wrap 고려X(센터링 시 중앙 기준)
            double dy = std::min(std::abs(y-cy), std::abs(y-(cy+H)));
            double r = std::sqrt( (x-cx)*(x-cx) + (y-cy)*(y-cy) );
            M[(size_t)y*W+x] = (r<=radius)? 1.0 : 0.0;
        }
    }
}

// 주파수에서 간단 노치 예: (u0,v0)와 대칭점 차단
inline void notch_mask(std::vector<double>& M, int W, int H, int u0, int v0, int rad){
    if (M.empty()) M.assign((size_t)W*H, 1.0);
    auto knock=[&](int cx,int cy){
        for (int y=-rad;y<=rad;++y) for (int x=-rad;x<=rad;++x){
            int u=cx+x, v=cy+y;
            if (u>=0&&u<W&&v>=0&&v<H) M[(size_t)v*W+u]=0.0;
        }
    };
    int cx=W/2, cy=H/2;
    knock(cx+u0, cy+v0);
    knock(cx-u0, cy-v0);
}

// 정방FFT→마스크 곱→역FFT→(센터링 후 입력이었으면 센터링 되돌림)→DIB 반환
inline bool FFT_Filter_And_IFFT(const IppDib& in, IppDib& outSpatial,
                                bool useHann, bool centering, bool padPow2,
                                const std::vector<double>& customMask /*크기 PW×PH*/)
{
    int W,H; std::vector<double> G; DibToGray(in, G, W, H);
    if (W<=0||H<=0) return false;

    if (useHann){ auto wx=hann1d(W), wy=hann1d(H); apply_window_2d(G, W,H, wx,wy); }
    if (centering) apply_centering_2d(G, W,H);

    int PW = padPow2? (int)next_pow2(W) : W;
    int PH = padPow2? (int)next_pow2(H) : H;

    std::vector<cd> A; pad2d_real(G, W,H, A, PW,PH);

    // 정방 FFT
    TwiddleStore cache;
    fft2d_inplace(A, PW,PH, /*inverse=*/false, &cache);

    // 마스크 곱
    if (!customMask.empty()){
        if ((int)customMask.size() != PW*PH) return false;
        for (int i=0;i<PW*PH;++i) A[(size_t)i] *= customMask[(size_t)i];
    }

    // 역 FFT
    fft2d_inplace(A, PW,PH, /*inverse=*/true, &cache);

    // (센터링 입력이었다면) 공간에서 다시 (-1)^(x+y) 곱해 복원
    if (centering){
        for (int y=0;y<PH;++y) for (int x=0;x<PW;++x)
            if (((x^y)&1)) A[(size_t)y*PW+x] *= -1.0;
    }

    // 실수부→0..255 매핑 (원본 크기에 맞춰 잘라냄)
    IppDib out; out.create(W,H,32);
    // 값 범위 정규화
    double mn=1e30, mx=-1e30;
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            double v=A[(size_t)y*PW+x].real();
            if (v<mn) mn=v; if (v>mx) mx=v;
        }
    }
    double den = (mx>mn)? (255.0/(mx-mn)) : 1.0;
    for (int y=0;y<H;++y){
        uint8_t* row=(uint8_t*)out.bits()+(size_t)y*out.stride();
        for (int x=0;x<W;++x){
            double v=A[(size_t)y*PW+x].real();
            uint8_t g=(uint8_t)std::lround(std::clamp((v-mn)*den, 0.0, 255.0));
            row[x*4+0]=row[x*4+1]=row[x*4+2]=g; row[x*4+3]=255;
        }
    }
    outSpatial = out;
    return true;
}
```

---

## **FFT 옵션 대화 상자** & **메뉴 연동**

### 리소스 ID

```cpp
// resource.h (추가)
#define IDD_FFT_DLG                 3200
#define IDC_CHK_FFT_HANN            3201
#define IDC_CHK_FFT_CENTER          3202
#define IDC_CHK_FFT_PAD2            3203
#define IDC_RAD_FFT_FORWARD_SPEC    3204
#define IDC_RAD_FFT_FILTER_LP       3205
#define IDC_RAD_FFT_FILTER_NOTCH    3206
#define IDC_EDIT_FFT_LP_RADIUS      3207
#define IDC_EDIT_FFT_NOTCH_U        3208
#define IDC_EDIT_FFT_NOTCH_V        3209
#define IDC_EDIT_FFT_NOTCH_RAD      3210

// 메뉴
#define ID_MENU_FFT                 71000

```

### RC

```rc
// ImageTool.rc (추가)
IDD_FFT_DLG DIALOGEX 0,0, 260, 170
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "FFT Options"
FONT 9, "Segoe UI"
BEGIN
    AUTOCHECKBOX "Hann window",   IDC_CHK_FFT_HANN,   12, 12, 80, 12
    AUTOCHECKBOX "Centering (-1)^(x+y)", IDC_CHK_FFT_CENTER, 110,12, 120,12
    AUTOCHECKBOX "Pad to power-of-two",  IDC_CHK_FFT_PAD2,   12, 28, 110,12

    GROUPBOX "Operation", -1, 12, 44, 236, 82
    AUTORADIOBUTTON "Forward → Show spectrum", IDC_RAD_FFT_FORWARD_SPEC, 20, 58, 160, 12, WS_TABSTOP
    AUTORADIOBUTTON "Filter: Ideal Low-pass",  IDC_RAD_FFT_FILTER_LP,    20, 74, 140, 12
    LTEXT "Radius(px):", -1, 168, 74, 50, 10
    EDITTEXT IDC_EDIT_FFT_LP_RADIUS, 220, 72, 24, 14, ES_NUMBER

    AUTORADIOBUTTON "Filter: Notch(u0,v0,rad)", IDC_RAD_FFT_FILTER_NOTCH, 20, 92, 150, 12
    LTEXT "u0:", -1, 168, 92, 14, 10
    EDITTEXT IDC_EDIT_FFT_NOTCH_U, 184, 90, 20, 14, ES_NUMBER
    LTEXT "v0:", -1, 208, 92, 14, 10
    EDITTEXT IDC_EDIT_FFT_NOTCH_V, 224, 90, 20, 14, ES_NUMBER
    LTEXT "rad:", -1, 168, 108, 20, 10
    EDITTEXT IDC_EDIT_FFT_NOTCH_RAD, 192,106, 24, 14, ES_NUMBER

    DEFPUSHBUTTON "OK", IDOK,  140, 138, 48, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 196, 138, 48, 16
END

// 메뉴
POPUP "&Frequency"
BEGIN
    MENUITEM "FFT...\tCtrl+F", ID_MENU_FFT
END

IDR_ACCEL ACCELERATORS
BEGIN
    "F", ID_MENU_FFT, VIRTKEY, CONTROL
END
```

### 대화 상자 코드 & 메뉴 핸들러

```cpp
// FFTDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "fft_pipeline.hpp"
#include "fft_filter.hpp"

class FFTDlg {
public:
    FFTDlg(HWND owner, IppDib& dib): owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);

    int ReadInt(HWND h, int id, int def) const;
    bool IsChecked(HWND h, int id) const { return IsDlgButtonChecked(h,id)==BST_CHECKED; }

private:
    HWND owner_=nullptr;
    IppDib& dib_;
};
```

```cpp
// FFTDlg.cpp
#include "FFTDlg.h"

INT_PTR FFTDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_FFT_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK FFTDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(FFTDlg*)l; return self->OnInit(h); }
    auto* self=(FFTDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w,l);
    return FALSE;
}
INT_PTR FFTDlg::OnInit(HWND h){
    CheckDlgButton(h, IDC_CHK_FFT_HANN,   BST_CHECKED);
    CheckDlgButton(h, IDC_CHK_FFT_CENTER, BST_CHECKED);
    CheckDlgButton(h, IDC_CHK_FFT_PAD2,   BST_CHECKED);
    CheckRadioButton(h, IDC_RAD_FFT_FORWARD_SPEC, IDC_RAD_FFT_FILTER_NOTCH, IDC_RAD_FFT_FORWARD_SPEC);
    SetDlgItemInt(h, IDC_EDIT_FFT_LP_RADIUS, 30, FALSE);
    SetDlgItemInt(h, IDC_EDIT_FFT_NOTCH_U,  40, FALSE);
    SetDlgItemInt(h, IDC_EDIT_FFT_NOTCH_V,  0,  FALSE);
    SetDlgItemInt(h, IDC_EDIT_FFT_NOTCH_RAD, 3,  FALSE);
    return TRUE;
}
int FFTDlg::ReadInt(HWND h, int id, int def) const{
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE);
    return ok? v : def;
}
INT_PTR FFTDlg::OnCommand(HWND h, WPARAM w, LPARAM){
    switch (LOWORD(w)){
    case IDOK: {
        bool useHann   = IsChecked(h, IDC_CHK_FFT_HANN);
        bool centering = IsChecked(h, IDC_CHK_FFT_CENTER);
        bool pad2      = IsChecked(h, IDC_CHK_FFT_PAD2);

        // 1) Forward → Spectrum
        if (IsDlgButtonChecked(h, IDC_RAD_FFT_FORWARD_SPEC)==BST_CHECKED){
            IppDib spec;
            FFTOptions opt; opt.useHann=useHann; opt.centering=centering; opt.padToPow2=pad2; opt.inverse=false;
            if (RunFFT2D(dib_, spec, opt)) dib_ = spec;
        }
        // 2) Low-pass
        else if (IsDlgButtonChecked(h, IDC_RAD_FFT_FILTER_LP)==BST_CHECKED){
            int radius = ReadInt(h, IDC_EDIT_FFT_LP_RADIUS, 30);
            // 실제 마스크 크기는 패딩 후 크기(PW×PH)와 일치해야 하므로
            // 한 턴 래퍼를 쓰지 않고 마스크를 나중에 생성해야 한다.
            // 간단하게: 입력과 동일한 경로에서 마스크를 생성하기 위해 작은 헬퍼 작성:

            // 준비: 입력의 (패딩) 크기만 알아내기 위해 임시 실행
            int W,H; std::vector<double> G; DibToGray(dib_, G, W,H);
            int PW = pad2? (int)next_pow2(W) : W;
            int PH = pad2? (int)next_pow2(H) : H;

            std::vector<double> M; ideal_lowpass_mask(M, PW, PH, (double)radius);
            IppDib out;
            FFT_Filter_And_IFFT(dib_, out, useHann, centering, pad2, M);
            dib_ = out;
        }
        // 3) Notch
        else {
            int u0=ReadInt(h, IDC_EDIT_FFT_NOTCH_U, 40);
            int v0=ReadInt(h, IDC_EDIT_FFT_NOTCH_V, 0);
            int rad=ReadInt(h, IDC_EDIT_FFT_NOTCH_RAD, 3);

            int W,H; std::vector<double> G; DibToGray(dib_, G, W,H);
            int PW = pad2? (int)next_pow2(W) : W;
            int PH = pad2? (int)next_pow2(H) : H;

            std::vector<double> M; notch_mask(M, PW, PH, u0, v0, rad);
            IppDib out;
            FFT_Filter_And_IFFT(dib_, out, useHann, centering, pad2, M);
            dib_ = out;
        }

        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL: EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

```cpp
// main_multiwin.cpp (메뉴 처리 발췌)
#include "FFTDlg.h"

// ...
case ID_MENU_FFT:
    if (st && st->dib){
        FFTDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 실전 예제 & 상황

### **스펙트럼 보기(품질 진단)**

- **상황**: 인쇄물 스캔 이미지(300 dpi)에서 주기 줄무늬 의심
- **동작**: `Frequency → FFT…` → *Forward → Show spectrum*, Hann=ON, Center=ON, Pad2=ON
- **해석**: 중앙(DC) 주변에 수직 방향으로 대칭인 밝은 점(피크) → 줄무늬 주기 추정(피크 거리)

### **이상적 저역통과**로 잡음 완화

- **상황**: 고주파 잡음이 많은 사진
- **동작**: `FFT…` → *Filter: Ideal Low-pass*, radius=40(픽셀 스펙트럼 반경)
- **결과**: 고주파 억제 → 부드러워짐(경계 링잉 주의). radius를 줄였다 늘려가며 시각 최적점 탐색

### **노치 필터**로 스트라이프 제거

- **상황**: 수평 스트라이프 패턴(기계 진동)
- **동작**: 스펙트럼에서 수평 방향 피크 위치를 추정 후 `FFT…` → *Filter: Notch(u0,v0,rad)* 에 값 입력
- **결과**: 해당 주파수만 선택적으로 억제, 세부 텍스처는 보존

### **패딩 효과** 확인

- **상황**: 주기가 애매한 무늬
- **동작**: Pad2 ON/OFF 비교
- **결과**: Pad2 ON에서 스펙트럼 **격자 간격**이 촘촘해져 피크 위치를 더 정확히 읽기 쉬움(실제 분해능 향상이 아님)

---

## 정확성/성능/UX 팁

- **정확성**
  - 입력에 **센터링**을 곱하면 스펙트럼 DC가 **중앙**으로 와서 해석과 마스킹이 직관적
  - 역FFT 시 **센터링을 되돌리는** 것을 잊지 말 것
  - IFFT 결과의 **스케일링(1/N)** 을 적용해야 복원이 정확

- **성능**
  - Radix-2는 **길이가 2의 거듭제곱**에서 최상. 그렇지 않으면 `next_pow2`로 패딩
  - 큰 이미지: 행/열 FFT를 **멀티스레드**(행/열 블럭 병렬)로 쉽게 확장 가능
  - **twiddle 캐시**와 **비트반전 테이블** 재사용 → 반복 호출에서 2~3× 개선

- **UX**
  - 스펙트럼 표시를 **log(1+|F|)** 로 해야 어두운 고주파 피크도 보임
  - Notch 좌표는 (u0,v0)을 **센터 기준**으로 설명(대화 상자에 툴팁 안내 추천)

- **후처리**
  - 이상적 저역/노치는 링잉(깁스) 유발 가능 → **부드러운 마스크**(가우시안/버터워스)로 개선 가능
  - 실무에선 FFT 라이브러리(FFTW, MKL 등)를 쓰면 다채로운 실수전용/실시간 경로 지원

---

## 수학 요약

- 1D FFT 나비:
\[
\begin{aligned}
X^{(s+1)}[k] &= X^{(s)}[k] + W_N^{k'} X^{(s)}[k+\tfrac{N}{2^{s+1}}],\\
X^{(s+1)}[k+\tfrac{N}{2^{s+1}}] &= X^{(s)}[k] - W_N^{k'} X^{(s)}[k+\tfrac{N}{2^{s+1}}],
\end{aligned}
\]
여기서 \(s\)는 스테이지, \(W_N^{k'}=e^{-j2\pi k'/N}\).

- 2D FFT:
\[
\mathcal{F}\{f\}(u,v) = \mathcal{F}_y\{\mathcal{F}_x\{f(x,y)\}\}.
\]

---

## 요약

- Cooley–Tukey Radix-2 반복형 FFT로 **빠르고 안정적인** 1D/2D 변환 구현
- **센터링/창/패딩** 옵션으로 스펙트럼 해석력 강화
- 간단 **저역/노치 필터** 예제로 주파수 도메인 편집 → 역FFT 복원까지 일괄 제공
- **FFT 옵션 대화 상자 & 메뉴**를 통해 즉시 사용 가능
- 대규모/실시간은 멀티스레드·전문화된 라이브러리로 확장하세요.
