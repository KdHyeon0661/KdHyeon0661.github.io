---
layout: post
title: 운영체제 - 네트워크와 분산시스템 (1)
date: 2025-11-02 21:25:23 +0900
category: 운영체제
---
# Chapter 19 — Networks and Distributed Systems (1)

## 19.1 Advantages of Distributed Systems

분산 시스템은 “여러 대의 독립 노드가 네트워크를 통해 협력해 **하나의 일관된 서비스**를 제공”하는 구조다. 장점은 명확하지만, 네트워크/노드 장애·지연·일관성의 **근본적 제약**을 함께 가져온다.

### 19.1.1 확장성(Scalability)

- **수평 확장(Horizontal Scalability)**: 노드를 추가해 처리량(**Throughput**)을 선형에 가깝게 증가.  
- **파티셔닝/샤딩**: 키/범위를 기준으로 데이터·요청을 분할.  
- **캐싱/리플리케이션**: 읽기 집중 워크로드에 유리.

**성능 상한(개념)**  
- **암달의 법칙**  
  $$S(n)=\frac{1}{(1-p)+\frac{p}{n}}$$  
  \(p\): 병렬 가능한 비율, \(n\): 노드/코어 수.  
- **구스타프손 법칙**: 문제 크기가 커질수록 병렬 비율 증가로 효용이 커진다.

### 19.1.2 가용성/내결함성(Availability/Fault Tolerance)

- **복제(Replication)**: 동일 데이터의 다중 사본. 단, **일관성**과 **레이턴시**의 대가 필요.  
- **장애 도메인 분리**: 전원/랙/존/리전에 걸친 독립성.  
- **정량화**:  
  - 가용성 \(A=\frac{\text{MTBF}}{\text{MTBF}+\text{MTTR}}\)  
  - 독립 복제본 \(k\)개일 때(단순 근사, 독립 가정):  
    $$A_{\text{rep}}=1-\prod_{i=1}^{k}(1-A_i)$$

**쿼럼(Read/Write Quorum)**  
- 총 복제수 \(N\), 읽기 \(R\), 쓰기 \(W\)일 때 **충돌 회피**의 충분조건:  
  $$R+W > N,\quad W > \frac{N}{2}$$

### 19.1.3 성능/지연(Throughput & Latency)

- **지연의 꼬리(Tail Latency)**: 분산 호출은 \(P99\)가 쉽게 악화.  
- **병목 모델(M/M/1 근사)**  
  평균 대기시간 \(W=\frac{\rho}{\mu-\lambda}\) (단 \( \rho=\lambda/\mu <1\)).  
- **헤드오브라인(HoL) 블로킹**: 큐/연결 재사용 시 주의.

### 19.1.4 민첩성/조직적 이점

- 팀/서비스 단위로 **독립 배포**. 장애가 **격리**되어 전체 영향을 축소.  
- 이기종 환경(언어/OS/하드웨어)을 조합할 수 있음.

### 19.1.5 비용/지리적 근접성

- **상용 하드웨어**의 집합으로 고성능 달성(Scale-out).  
- **엣지**에 캐시/프록시를 배치해 사용자와 **물리적으로 가까워짐**.

### 19.1.6 필수 트레이드오프(CAP/PACELC)

- **CAP**: 네트워크 분할(P) 하에서 **일관성(C)** vs **가용성(A)** 선택.  
- **PACELC**: 분할 시(P) C/A, 평시(E)에도 **지연(L)** vs **일관성(C)** 트레이드오프.

---

### 예제 19.1 — 3중 복제 키-값 저장소의 쿼럼 읽기/쓰기

- 파라미터: \(N=3\), \(R=2\), \(W=2\) (Strict Quorum).  
- 쓰기는 2노드 ACK 후 성공, 읽기는 2노드 읽어 최신 버전을 선택.

```python
# quorum_kv.py — 매우 단순화한 쿼럼 K/V (버전=모노토닉 카운터)
import random, time, threading

class Node:
    def __init__(self, name):
        self.name=name; self.store={}; self.lock=threading.Lock()
    def write(self, k, v, ver):
        with self.lock: self.store[k]=(ver, v); return True
    def read(self, k):
        with self.lock: return self.store.get(k, (-1, None))

class QuorumKV:
    def __init__(self, nodes, R=2, W=2):
        self.nodes=nodes; self.R=R; self.W=W; self.ver=0
    def put(self, k, v):
        self.ver+=1
        acks=0
        for n in random.sample(self.nodes, len(self.nodes)):
            if n.write(k, v, self.ver): acks+=1
            if acks>=self.W: return True
        return False
    def get(self, k):
        res=[]
        for n in random.sample(self.nodes, len(self.nodes)):
            res.append(n.read(k))
            if len(res)>=self.R:
                return max(res, key=lambda x:x[0])[1]  # 최신 버전 선택

nodes=[Node("n1"),Node("n2"),Node("n3")]
kv=QuorumKV(nodes,R=2,W=2)
kv.put("a","v1"); print(kv.get("a"))
```

> **운영 포인트**: 네트워크 분할에서 \(R+W>N\) 이면 **가용성 희생**(일부 요청 실패) 대신 **일관성 보장**.

---

## 19.2 Network Structure

분산 시스템의 성패는 **네트워크 구조**에 크게 좌우된다. 설계는 **레이어**, **토폴로지**, **주소/라우팅**, **전송**, **오버레이**의 5축으로 나눠 생각한다.

### 19.2.1 레이어 관점

- **Internet 스택**: Link ↔ Network(IP) ↔ Transport(TCP/UDP/QUIC) ↔ Application(RPC/HTTP/…).
- **End-to-End 원칙**: 신뢰성/암호화/재전송 같은 **종단 의미**는 **종단**에 둔다.

### 19.2.2 토폴로지

- **데이터센터**: **리프-스파인(Leaf–Spine)**, **Fat-Tree**, ECMP로 다중 경로.  
- **LAN**: Star(스위치 중심), VLAN/VRF로 논리 분리.  
- **WAN**: MPLS/SD-WAN, Anycast로 가장 가까운 POP 유치.

```
Spine ─┬─ Leaf ─ Racks
       ├─ Leaf ─ Racks
       └─ Leaf ─ Racks
```

### 19.2.3 스위칭/라우팅

- **L2**: MAC 학습/브리징, VLAN 태깅(802.1Q).  
- **L3**: IP 라우팅(ECMP, OSPF/IS-IS/BGP).  
- **Anycast**: 동일 IP를 여러 위치에 광고 → 최근접 경로 선택.

### 19.2.4 주소/CIDR/서브넷

- **CIDR**: `/k` 프리픽스 → 주소 공간 크기 \(2^{32-k}\) (IPv4).  
- 예: `10.0.0.0/24`는 256개 주소, `/26`은 64개.

```python
# subnet_calc.py — CIDR 블록을 등분하는 유틸
import ipaddress
def split(prefix, parts):
    net=ipaddress.ip_network(prefix)
    new_prefix=net.prefixlen + (parts.bit_length()-1)  # 대략 n배 분할
    return list(net.subnets(new_prefix=new_prefix))
print(split("10.0.0.0/24", 4))  # /26 4개로
```

### 19.2.5 전송(Transport): TCP/UDP/QUIC

- **TCP**: 연결지향, 혼잡/흐름 제어(CUBIC/BBR), 재전송, 순서 보장(하지만 **HoL** 있음).  
- **UDP**: 단순/낮은 지연, 앱 레벨 재전송/순서/암호화 별도 구현.  
- **QUIC(UDP 상)**: 스트림 멀티플렉싱, 1-RTT/0-RTT 핸드셰이크, TLS 1.3 내장, 연결 마이그레이션.

**Nagle/Delayed ACK**: 작은 패킷 지연-병합 최적화이나, 지연 민감 워크로드엔 비활성화 고려.

### 19.2.6 NAT/로드밸런싱/프록시

- **L4 LB**: 5-튜플 해시 분배, 커넥션 당 고정(세션 고정).  
- **L7 LB/프록시**: HTTP 헤더·경로 기반 라우팅, 리트라이/관측성.  
- **NAT**: 사설↔공인 주소 변환, 상태 테이블/포트 고갈 주의.

### 19.2.7 오버레이/터널

- **VXLAN(UDP 4789)**: L2 over L3, 24-bit VNI로 ~1,600만 세그먼트.  
- **GRE/IP-in-IP**: 단순 터널, MTU 감소 주의(MSS 클램핑).

```bash
# 리눅스 VXLAN 인터페이스(개념)
ip link add vxlan10 type vxlan id 10 dev eth0 remote 192.0.2.10 dstport 4789
ip addr add 10.10.10.1/24 dev vxlan10
ip link set vxlan10 up
```

### 19.2.8 NIC/큐/오프로딩

- **RSS/RPS**: 다큐 분산, 멀티큐로 병렬 처리.  
- **TSO/GSO/LRO**: 세그먼트/병합 오프로딩(서버/트래픽 성격에 맞게 조정).  
- **DPDK/vhost**: 사용자 공간 폴-모드로 레이턴시/CPU 효율 개선.

---

## 19.3 Communication Structure

분산 시스템에서 “통신 구조”는 **API 설계, RPC 의미론, 메시징, 시간, 일관성**까지 포괄한다.

### 19.3.1 패턴: 요청/응답, 메시징, 스트리밍

- **요청/응답(RPC)**: 서비스 간 동기 호출, 타임아웃/리트라이/백오프/아이덴포턴시 필수.  
- **메시징(큐·버스·Pub/Sub)**: 비동기, 버퍼링/재시도/리플레이. 토픽/파티션·오더링 모델 이해 필요.  
- **스트리밍**: 지속 연결(HTTP/2/3, gRPC 스트림, WebSocket), **백프레셔** 중요.

### 19.3.2 RPC 의미론(실무 핵심)

- **at-most-once**: 중복 없음(성공·실패·타임아웃에서 추적 필요).  
- **at-least-once**: 중복 가능(아이덴포턴시 키 필수).  
- **exactly-once**: 일반 네트워크 환경에서 **공짜로는 불가**, **중복 억제 + 재실행 안전**으로 근사.

**백오프**  
- 지수 백오프 + **Jitter** 가 표준.  
  $$t_k = \min(t_{\max}, t_0 \cdot 2^k) + U[0,\,j]$$

```python
# backoff.py — 지수 백오프 + Full Jitter
import random, time
def retry(action, t0=0.05, tmax=2.0, attempts=5):
    for k in range(attempts):
        try: return action()
        except Exception as e:
            sleep = min(tmax, t0*(2**k)) * random.random()
            time.sleep(sleep)
    raise TimeoutError("exhausted")
```

### 19.3.3 메시지 프레이밍/헬스체크/Keep-Alive

길이-프리픽스 프레이밍은 TCP 스트림에서 안전한 경계 인식 방법.

```python
# lp_server.py — 길이-프리픽스 TCP 에코(Asyncio)
import asyncio, struct
async def handle(r,w):
    try:
        while True:
            hdr=await r.readexactly(4)
            (n,)=struct.unpack("!I", hdr)
            data=await r.readexactly(n)
            w.write(hdr+data); await w.drain()
    except asyncio.IncompleteReadError:
        pass
    w.close()
async def main(): 
    s=await asyncio.start_server(handle,"0.0.0.0",9000); await s.serve_forever()
asyncio.run(main())
```

**헬스체크**: TCP 연결 유지만으로 충분하지 않다. **어플리케이션 레벨 핑/상태**가 필요(의존 리소스·큐 적재량 포함).

### 19.3.4 직렬화/스키마 진화

- **JSON**: 인간 친화, 크기/속도는 손해.  
- **Protobuf/Avro/FlatBuffers/Cap’n Proto**: 바이너리·스키마 기반, **전/후방 호환** 규칙이 중요(필드 추가/예약/삭제).  
- **스키마 레지스트리**: 생산자/소비자 호환성 검증.

### 19.3.5 시간/순서: Lamport & Vector Clocks

- **Lamport Clock**: 부분 순서를 총순서로 임베딩(동시성 구분 불가).  
- **Vector Clock**: **동시성 감지** 가능, 크기=노드 수.

```python
# lamport.py — 람포트 시계(간단 데모)
class Lamport:
    def __init__(self): self.t=0
    def local(self): self.t+=1
    def send(self): self.local(); return self.t
    def recv(self, ts): self.t=max(self.t, ts)+1
A,B=Lamport(),Lamport()
A.local(); ts=A.send(); B.recv(ts)
print(A.t, B.t)  # 2,3 (인과 순서 보존)
```

### 19.3.6 합의/트랜잭션: 2PC vs 합의 알고리즘

- **2PC**: 코디네이터 기반 커밋 프로토콜(블로킹/코디네이터 장애 시 정지).  
- **3PC**: 네트워크 분할 상황을 완화하려 하나, 현실 적용은 드묾.  
- **합의(Paxos/Raft)**: 리더 선출·로그 복제·상태머신 일관성을 보장(장애 허용).

```python
# raft_heartbeat.py — 리더 하트비트(의사코드급)
import time, random, threading
class Node:
    def __init__(self, id, peers):
        self.id=id; self.peers=peers; self.term=0; self.leader=None; self.voted=False
        self.election_deadline=time.time()+random.uniform(0.15,0.3)
    def tick(self):
        now=time.time()
        if self.leader and now<self.election_deadline: return
        # 선거 시작
        self.term+=1; self.voted=True; votes=1
        for p in self.peers:
            votes+=p.request_vote(self.term)
        if votes>len(self.peers)//2:
            self.leader=self; self.reset_timer(); self.broadcast_heartbeat()
    def request_vote(self, term):
        if term>self.term and not self.voted:
            self.term=term; self.voted=True; return 1
        return 0
    def reset_timer(self): self.election_deadline=time.time()+random.uniform(0.15,0.3)
    def broadcast_heartbeat(self):
        for p in self.peers: p.on_heartbeat(self.term)
    def on_heartbeat(self, term):
        if term>=self.term: self.term=term; self.leader=True; self.reset_timer()
```

> **실무**: 합의 라이브러리(etcd/Raft)를 사용하고, **쿼럼/장애 도메인** 배치를 먼저 설계한다.

### 19.3.7 컨시스턴트 해싱(Consistent Hashing)

- 노드 추가/제거 시 재배치 비율을 감소.  
- 원형 해시공간에 **가상 노드(VNode)** 로 균등화.

```python
# chash.py — 간단한 컨시스턴트 해싱
import bisect, hashlib
class Ring:
    def __init__(self, replicas=100):
        self.replicas=replicas; self.keys=[]; self.nodes={}
    def _h(self, x): return int(hashlib.md5(x).hexdigest(),16)
    def add(self, node):
        for i in range(self.replicas):
            k=self._h(f"{node}:{i}".encode()); self.keys.append(k); self.nodes[k]=node
        self.keys.sort()
    def get(self, key):
        h=self._h(key.encode()); i=bisect.bisect(self.keys,h)%len(self.keys)
        return self.nodes[self.keys[i]]
ring=Ring(); [ring.add(n) for n in ("A","B","C")]
print(ring.get("user:42"))
```

### 19.3.8 멱등/중복 억제(Idempotency & De-dup)

- **Idempotency-Key**(요청 ID)로 서버가 **이미 처리된 요청**을 **무해하게** 무시.  
- **Upsert/Put** 스타일, **서버 생성 IDempotent**(키는 클라이언트가 제공).

```python
# idempotent_store.py — Idempotency-Key로 중복 억제
class Store:
    def __init__(self): self.done=set(); self.data={}
    def create(self, idem_key, key, val):
        if idem_key in self.done: return "OK(replay)"
        self.data[key]=val; self.done.add(idem_key); return "OK"
st=Store()
print(st.create("req-1","k","v1"))
print(st.create("req-1","k","v1"))  # 재시도 안전
```

### 19.3.9 보안: TLS/mTLS, 인증/인가

- **TLS 1.3**: 전송 암호화, PFS, 1-RTT 핸드셰이크.  
- **mTLS**: 양단 인증(서비스-서비스).  
- **인증서 회전/폐기** 자동화, 루트·중간 CA의 보안 관리.

---

### 예제 19.3 — gRPC로 at-most-once RPC (Python)

> 포인트: **데드라인(타임아웃)**, **리트라이 정책**, **Idempotency-Key** 를 함께 넣는다. (개념 코드)

```python
# greeter.proto (개념)
# syntax = "proto3";
# service Greeter { rpc Hello(HelloReq) returns (HelloResp); }
# message HelloReq { string name=1; string idem_key=2; }
# message HelloResp { string msg=1; }
```

```python
# server.py
import grpc, time
from concurrent import futures
import greeter_pb2 as pb, greeter_pb2_grpc as svc

class Greeter(svc.GreeterServicer):
    def __init__(self): self.done=set()
    def Hello(self, req, ctx):
        if req.idem_key in self.done:
            return pb.HelloResp(msg=f"(replay) Hello {req.name}")
        self.done.add(req.idem_key)
        return pb.HelloResp(msg=f"Hello {req.name}")

srv=grpc.server(futures.ThreadPoolExecutor())
svc.add_GreeterServicer_to_server(Greeter(), srv)
srv.add_insecure_port("[::]:50051"); srv.start(); srv.wait_for_termination()
```

```python
# client.py — 데드라인 + 리트라이(간단)
import grpc, time, random
import greeter_pb2 as pb, greeter_pb2_grpc as svc
ch=grpc.insecure_channel("localhost:50051")
stub=svc.GreeterStub(ch)
def call(name, idem):
    for k in range(3):
        try:
            resp=stub.Hello(pb.HelloReq(name=name, idem_key=idem), timeout=0.2)
            return resp.msg
        except grpc.RpcError:
            time.sleep(min(0.5, 0.05*(2**k))*random.random())
print(call("Alice","req-123"))
print(call("Alice","req-123"))  # 재시도해도 at-most-once처럼 동작
```

---

## 운영 체크리스트(요약)

1) **네트워크 구조**: Leaf-Spine + ECMP, Anycast/Hop 수 관리, MTU/터널 오버헤드 고려.  
2) **전송 레벨**: 타임아웃·백오프·Jitter·연결 풀·Nagle/Delayed ACK 정책.  
3) **통신 구조**: RPC vs 메시징 선택, 멱등 키/중복 억제, 스키마 호환성.  
4) **시간/순서**: NTP 동기, Lamport/Vector 시계로 인과 추적.  
5) **일관성**: 쿼럼 \(R,W\) 설계, 리더 기반/합의 사용처 구분.  
6) **보안**: mTLS, 키/인증서 회전 자동화, 최소권한 네트워크 정책.  
7) **관측성**: p95/p99 레이턴시, 에러율, 재시도율, 큐 길이, 드롭/리트랜스미션.

---

## 요약

- **19.1**: 분산의 이점—확장/가용성/성능/민첩성—과 **CAP/PACELC** 트레이드오프를 수식과 쿼럼 예제로 정리.  
- **19.2**: 네트워크 구조—레이어/토폴로지/주소/전송/오버레이/NIC—를 운영 관점에서 구성. CIDR/VXLAN 등의 실습 포함.  
- **19.3**: 통신 구조—RPC 의미론, 메시징, 프레이밍, 직렬화, 시간/순서, 합의, 멱등—을 코드로 보여주며 **현업에서 바로 쓰는 패턴**을 제시.
