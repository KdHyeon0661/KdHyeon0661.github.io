---
layout: post
title: Java - 단위 테스트 작성법
date: 2025-08-13 17:20:23 +0900
category: Java
---
# 단위 테스트 작성법 — JUnit 5 중심 실전 가이드

단위 테스트(Unit Test)는 **가장 작은 기능 단위(함수/메서드/클래스)**가 **의도대로 동작하는지** 빠르고 안정적으로 검증하는 테스트입니다.  
아래 가이드는 JUnit 5(Jupiter)를 중심으로 **원칙 → 구조 → 예제 → 테스트 더블 → 시간/IO/동시성 → TDD → 커버리지/안티패턴** 순으로 정리했습니다.

---

## 1) 좋은 단위 테스트의 원칙 — *FIRST*

- **F**ast: 수 ms~수십 ms 내로 **매우 빠르게** 실행되어야 함.
- **I**solated/Independent: 테스트 간 **독립적**이고 **외부 시스템에 의존 X**(네트워크/DB/파일 최소화).
- **R**epeatable: 어느 환경에서도 **항상 같은 결과**(비결정성 제거).
- **S**elf-validating: **assert**로 자동 판정(수동 로그 확인 금지).
- **T**imely: 구현 직후(또는 구현 전, TDD) **적시에 작성**.

---

## 2) 테스트 구조와 네이밍

- **AAA 패턴**: **Arrange(준비) → Act(실행) → Assert(검증)**  
  또는 **Given/When/Then**으로 의도 드러내기.
- **이름 짓기**: `메서드명_조건_기대결과()`, `should_행위_when_조건()` 등 **행위 중심**.
- 패키지/클래스 구조는 **`src/main/java`**를 **`src/test/java`**에서 **미러링**(동일 패키지)하면 찾기 쉽다.

---

## 3) 최소 설정 — 의존성

### Maven
```xml
<dependencies>
  <!-- JUnit 5 -->
  <dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.10.2</version>
    <scope>test</scope>
  </dependency>
  <!-- Mockito (선택) -->
  <dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-junit-jupiter</artifactId>
    <version>5.11.0</version>
    <scope>test</scope>
  </dependency>
</dependencies>
```

### Gradle (Kotlin DSL)
```kotlin
dependencies {
    testImplementation(platform("org.junit:junit-bom:5.10.2"))
    testImplementation("org.junit.jupiter:junit-jupiter")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
    testImplementation("org.mockito:mockito-junit-jupiter:5.11.0")
}
tasks.test { useJUnitPlatform() }
```

---

## 4) JUnit 5 테스트 클래스 골격

```java
import org.junit.jupiter.api.*;

import static org.junit.jupiter.api.Assertions.*;

class Calculator {
    int add(int a, int b) { return a + b; }
}

class CalculatorTest {

    Calculator sut; // system under test

    @BeforeEach
    void setUp() {
        sut = new Calculator();
    }

    @Test
    @DisplayName("add는 두 정수를 더해서 반환한다")
    void add_shouldSumTwoNumbers() {
        // Arrange (setUp에서 준비)
        // Act
        int result = sut.add(3, 4);
        // Assert
        assertEquals(7, result);
    }
}
```

### 라이프사이클 훅
- `@BeforeEach` / `@AfterEach` : 각 테스트 전/후
- `@BeforeAll` / `@AfterAll` : 클래스 전/후 (기본 `static`, `@TestInstance(PER_CLASS)`면 인스턴스 메서드 가능)
- 읽기 쉬운 이름은 `@DisplayName`으로 부여

---

## 5) Assertion, 예외, 파라미터화

### 5.1 Assertion 예시
```java
import static org.junit.jupiter.api.Assertions.*;

@Test void assertions_examples() {
    assertAll(
        () -> assertEquals(2, 1 + 1),
        () -> assertTrue("hello".startsWith("he")),
        () -> assertArrayEquals(new int[]{1,2}, new int[]{1,2})
    );
}
```

### 5.2 예외 검증
```java
@Test
void shouldThrowWhenInvalidInput() {
    IllegalArgumentException ex = assertThrows(
        IllegalArgumentException.class,
        () -> { throw new IllegalArgumentException("bad"); }
    );
    assertEquals("bad", ex.getMessage());
}
```

### 5.3 파라미터화 테스트
```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

@ParameterizedTest(name = "length(\"{0}\") == {1}")
@CsvSource({ "a,1", "'',0", "hello,5" })
void length(String input, int expected) {
    assertEquals(expected, input.length());
}
```

---

## 6) 테스트 더블(Test Double) — Stub/Mock/Fake/Spy

| 종류 | 목적 | 특징 |
|---|---|---|
| **Stub** | 고정된 응답 제공 | 상태 검증 중심 |
| **Mock** | 상호작용/호출 검증 | **행위 검증**(호출 여부/횟수) |
| **Fake** | 단순한 대체 구현 | 인메모리 저장소 등 |
| **Spy** | 실제 구현 + 호출 기록 | 부분 모킹 |

### Mockito 예제 — Repository를 모킹
```java
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.*;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class User {
    private final long id;
    private boolean active;
    private LocalDate activatedAt;
    User(long id){ this.id = id; }
    long getId(){ return id; }
    boolean isActive(){ return active; }
    LocalDate getActivatedAt(){ return activatedAt; }
    void activate(LocalDate date){ this.active = true; this.activatedAt = date; }
}

interface UserRepository {
    Optional<User> findById(long id);
    void save(User user);
}

final class UserService {
    private final UserRepository repo;
    private final Clock clock;
    UserService(UserRepository repo, Clock clock){ this.repo = repo; this.clock = clock; }
    void activate(long id){
        User u = repo.findById(id).orElseThrow(NoSuchElementException::new);
        u.activate(LocalDate.now(clock));
        repo.save(u);
    }
}

@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    @Mock UserRepository repo;
    Clock fixedClock;

    UserService sut;

    @BeforeEach
    void init(){
        fixedClock = Clock.fixed(Instant.parse("2025-01-01T00:00:00Z"), ZoneOffset.UTC);
        sut = new UserService(repo, fixedClock);
    }

    @Test
    void activate_setsDate_andSaves() {
        User user = new User(1L);
        when(repo.findById(1L)).thenReturn(Optional.of(user));

        sut.activate(1L);

        assertTrue(user.isActive());
        assertEquals(LocalDate.of(2025,1,1), user.getActivatedAt());
        verify(repo).save(user);                 // 행위 검증
        verify(repo, times(1)).findById(1L);
        verifyNoMoreInteractions(repo);
    }

    @Test
    void activate_throwsWhenNotFound() {
        when(repo.findById(99L)).thenReturn(Optional.empty());
        assertThrows(NoSuchElementException.class, () -> sut.activate(99L));
    }
}
```

> **포인트**  
> - **시간 의존성**은 `Clock`을 주입해 고정(Fixed) → **결정성 확보**  
> - 외부 리소스(DB/네트워크)는 **Mock/Fake**로 대체 → **빠른 단위 테스트**

---

## 7) 파일/시간/난수 의존성 다루기

### 7.1 파일 시스템 — `@TempDir`
```java
import org.junit.jupiter.api.io.TempDir;
import java.nio.file.*;

class FileTest {
    @TempDir Path tempDir;

    @Test
    void writesFileInTemp() throws Exception {
        Path out = tempDir.resolve("out.txt");
        Files.writeString(out, "hello");
        assertTrue(Files.exists(out));
    }
}
```

### 7.2 시간 — `Clock` 주입
- **프로덕션 코드**는 `LocalDate.now()` 대신 **`LocalDate.now(clock)`** 사용.
- 테스트에서는 `Clock.fixed(...)`로 고정.

### 7.3 난수 — `Random` 주입
- 생성자/세터로 `Random`(또는 seed) 주입 → 테스트에서 **고정 seed** 사용.

---

## 8) 동시성 단위 테스트(필요 최소한)

동시성은 가능하면 **분리된 통합/부하 테스트**에서 충분히 검증하고,  
단위 테스트에서는 **스레드-세이프 계약** 정도만 빠르게 확인합니다.

```java
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

final class Counter {
    private final AtomicInteger value = new AtomicInteger();
    int inc(){ return value.incrementAndGet(); }
    int get(){ return value.get(); }
}

@Test
void inc_isThreadSafe() throws Exception {
    Counter c = new Counter();
    int threads = 8, iters = 5_000;
    ExecutorService es = Executors.newFixedThreadPool(threads);
    CountDownLatch start = new CountDownLatch(1);
    CountDownLatch done = new CountDownLatch(threads);

    for (int t=0; t<threads; t++) {
        es.submit(() -> {
            start.await();
            for (int i=0; i<iters; i++) c.inc();
            done.countDown();
            return null;
        });
    }
    start.countDown();
    done.await();
    es.shutdown();
    assertEquals(threads * iters, c.get());
}
```

> **주의**: `Thread.sleep(...)`로 타이밍 맞추는 테스트는 **플레이키(flaky)** 해집니다. 동기화 도구(`Latch`, `Barrier`)를 쓰세요.

---

## 9) TDD 사이클(테스트 주도 개발)

1. **Red**: 실패하는 **작은 테스트** 작성  
2. **Green**: 테스트를 **통과시키는 최소 구현**  
3. **Refactor**: 중복 제거/설계 개선(테스트는 모두 **녹색** 유지)  

> 너무 큰 단위를 테스트로 잡지 마세요. **작게** 나누고, 실패 메시지가 **명확**해야 합니다.

---

## 10) 커버리지/품질 — 숫자보다 *신뢰도*

- **라인/브랜치 커버리지**는 **지표**일 뿐, 목표가 아닙니다.  
  80% 같은 임계치에 집착하기보다 **핵심 로직/에러 경로/경계값**이 검증되는지 확인.
- **뮤테이션 테스트**(PIT 등): 테스트가 버그를 **잡아낼 힘**이 있는지 확인하는 더 좋은 방법.
- **정적 분석 + 포매팅**: SpotBugs/Checkstyle/Spotless로 일관성↑.

---

## 11) 테스트 조직화 & 패턴

- **@Nested**로 시나리오 그룹화:
```java
@Nested
@DisplayName("activate()는")
class Activate {
    @Test @DisplayName("사용자가 존재하면 활성화한다") void ok(){ /* ... */ }
    @Test @DisplayName("없으면 예외") void notFound(){ /* ... */ }
}
```

- **Test Data Builder / Object Mother**: 복잡한 도메인 객체 생성을 **빌더**로 캡슐화해 가독성↑, 중복↓.
- **픽스처 최소화**: 필요 이상으로 많은 준비코드는 냄새. 테스트마다 **필요한 것만**.

---

## 12) 단위 vs 통합의 경계

- **단위 테스트**: 프로세스 내 **순수 자바 코드** 검증(의존성은 더블). **빠름**.
- **통합 테스트**: DB/네트워크/프레임워크와의 **실제 통합** 검증. **느림** → 빌드 파이프라인에서 **분리 실행** 권장.

---

## 13) 흔한 안티패턴(피해야 할 것)

- **네트워크/DB/파일에 직접 의존**하는 단위 테스트
- `sleep()` 기반 타이밍 맞추기, 랜덤/시간 의존(고정하지 않음)
- **전역 상태/싱글톤**이 테스트 간에 **누수**
- **구현 세부사항**(사소한 메서드 호출 순서 등)에 과도하게 결합된 테스트
- **Mock 남용**: 간단한 경우엔 **Fake(인메모리)**가 더 읽기 쉬움
- 실패 메시지 불명확, assert가 없는 테스트(로그만 출력)

---

## 14) 체크리스트 (실행 전 마지막 점검)

- [ ] 테스트 이름이 **의도를 설명**하는가?
- [ ] **AAA**로 구조가 명확한가?
- [ ] 외부 의존은 **더블로 대체**했는가?
- [ ] 시간/난수/환경 의존성을 **고정**했는가?
- [ ] 한 테스트가 **한 가지 행위**만 검증하는가?
- [ ] 실패 시 **원인 파악이 쉬운 메시지**인가?
- [ ] **빠르게**, **독립적으로** 실행되는가?

---

## 15) 보너스 — 빌드/CI 팁

- **Wrapper 사용**: `mvnw` / `gradlew`로 도구 버전 고정.
- **병렬 실행**: JUnit Platform/Gradle/Maven 설정으로 병렬화(테스트 간 격리 보장 전제).
- **리포트**: JUnit XML/HTML, 커버리지는 JaCoCo(Gradle: `jacoco` 플러그인, Maven: `jacoco-maven-plugin`).

---

### 마무리
단위 테스트는 **설계 품질을 피드백**하고, **리팩터링을 뒷받침**하는 안전망입니다.  
**작고 빠르고 결정적인 테스트**를 꾸준히 쌓으세요. 테스트는 문서이기도 합니다 — **의도**가 드러나야 합니다.
