---
layout: post
title: Java - 단위 테스트 작성법
date: 2025-08-13 17:20:23 +0900
category: Java
---
# 단위 테스트 작성법

## 좋은 단위 테스트의 원칙 — *FIRST*

- **Fast**: 수 ms~수십 ms 내로 **매우 빠르게** 돌아야 한다.
- **Isolated/Independent**: 테스트 간 **독립**. **외부 시스템(DB/네트워크/파일)** 에 직접 의존하지 않는다.
- **Repeatable**: 어느 환경에서도 **항상 같은 결과**(비결정성 제거).
- **Self-validating**: **assert**로 자동 판정(수동 로그 확인 금지).
- **Timely**: 구현 직후(또는 구현 전, TDD) **적시에 작성**.

> 목표는 “**작고, 빠르고, 결정적인 테스트**를 많이 갖추는 것”.

---

## 프로젝트 설정 — 최소 의존성과 런처

### Maven (5.x/6.x 공통 패턴: BOM 권장)

```xml
<dependencyManagement>
  <dependencies>
    <!-- JUnit 5: org.junit:junit-bom:5.x / JUnit 6: 6.x -->
    <dependency>
      <groupId>org.junit</groupId>
      <artifactId>junit-bom</artifactId>
      <version>5.10.2</version><!-- 또는 6.0.1 등 최신 -->
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>

<dependencies>
  <!-- Jupiter API & Engine -->
  <dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <scope>test</scope>
  </dependency>
  <dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-engine</artifactId>
    <scope>test</scope>
  </dependency>

  <!-- 파라미터화 테스트 -->
  <dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-params</artifactId>
    <scope>test</scope>
  </dependency>

  <!-- (선택) Mockito JUnit Jupiter 확장 -->
  <dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-junit-jupiter</artifactId>
    <version>5.11.0</version>
    <scope>test</scope>
  </dependency>

  <!-- (선택) JUnit 4 자산 공존 실행: Vintage -->
  <dependency>
    <groupId>org.junit.vintage</groupId>
    <artifactId>junit-vintage-engine</artifactId>
    <scope>test</scope>
  </dependency>
</dependencies>
```

### Gradle (Kotlin DSL)

```kotlin
dependencies {
    // JUnit 5: 5.x / JUnit 6: 6.x
    testImplementation(platform("org.junit:junit-bom:5.10.2"))
    testImplementation("org.junit.jupiter:junit-jupiter")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")

    // 파라미터화
    testImplementation("org.junit.jupiter:junit-jupiter-params")

    // Mockito 확장(선택)
    testImplementation("org.mockito:mockito-junit-jupiter:5.11.0")

    // (선택) JUnit4 공존
    testRuntimeOnly("org.junit.vintage:junit-vintage-engine")
}
tasks.test { useJUnitPlatform() }
```

> **자바 최소 버전**: JUnit 5는 일반적으로 **Java 8+**, JUnit 6은 **Java 17+**. 최신 LTS(JDK 21/25) 권장.

---

## 테스트 클래스 골격과 라이프사이클

```java
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

class Calculator {
    int add(int a, int b) { return a + b; }
}

class CalculatorTest {

    Calculator sut; // System Under Test

    @BeforeEach
    void setUp() { sut = new Calculator(); }

    @AfterEach
    void tearDown() { /* 필요하다면 정리 */ }

    @Test
    @DisplayName("add는 두 정수를 더해서 반환한다")
    void add_shouldSumTwoNumbers() {
        // Arrange (setUp에서 준비됨)
        // Act
        int result = sut.add(3, 4);
        // Assert
        assertEquals(7, result);
    }
}
```

- **@BeforeEach / @AfterEach**: 각 테스트 전/후
- **@BeforeAll / @AfterAll**: 클래스 전/후(기본 `static`, 단 **`@TestInstance(PER_CLASS)`**면 인스턴스 메서드 가능)
- **@DisplayName**로 리포트 가독성↑

---

## AAA 패턴과 네이밍

- **AAA(Arrange-Act-Assert)** 또는 **Given-When-Then** 으로 의도가 드러나게 작성
- 네이밍: `메서드명_조건_기대결과()`, `should_행위_when_조건()`
- 테스트 패키지는 **`src/main/java`** 구조를 **미러링**하면 찾기 쉽다.

---

## Assertions/예외/타임아웃

### Assertions 모음

```java
import static org.junit.jupiter.api.Assertions.*;

@Test void assertions_examples() {
    assertAll("한 번에 여러 검증",
        () -> assertEquals(2, 1 + 1),
        () -> assertTrue("hello".startsWith("he")),
        () -> assertArrayEquals(new int[]{1,2}, new int[]{1,2}),
        () -> assertLinesMatch(
              java.util.List.of("a.*", "b"),
              java.util.List.of("aaa", "b"))
    );
}
```

### 예외 검증

```java
@Test
void shouldThrowWhenInvalidInput() {
    IllegalArgumentException ex = assertThrows(
        IllegalArgumentException.class,
        () -> { throw new IllegalArgumentException("bad"); }
    );
    assertEquals("bad", ex.getMessage());
}
```

### 타임아웃

```java
@Test
void slow_with_timeout() {
    assertTimeout(java.time.Duration.ofMillis(200), () -> {
        // 200ms 내에 끝나야 함(코드 완료 대기)
    });
}
```
> 선제 중단이 필요하면 `assertTimeoutPreemptively(...)` 를 고려(환경에 따라 주의).

---

## 파라미터화 테스트 — 데이터 주도

```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.*;

class LengthTest {
    @ParameterizedTest(name = "length(\"{0}\") == {1}")
    @CsvSource({ "a,1", "'',0", "hello,5" })
    void length_matches(String input, int expected) {
        org.junit.jupiter.api.Assertions.assertEquals(expected, input.length());
    }

    @ParameterizedTest
    @NullSource @EmptySource @ValueSource(strings = {"a","ab"})
    void notNullOrEmpty(String s) {
        org.junit.jupiter.api.Assertions.assertTrue(s == null || s.length() >= 0);
    }

    @ParameterizedTest
    @EnumSource(TimeUnit.class)
    void enum_ok(TimeUnit unit) {
        org.junit.jupiter.api.Assertions.assertNotNull(unit);
    }

    static java.util.stream.Stream<org.junit.jupiter.params.provider.Arguments> cases() {
        return java.util.stream.Stream.of(
            org.junit.jupiter.params.provider.Arguments.of("ab", 2),
            org.junit.jupiter.params.provider.Arguments.of("abc", 3)
        );
    }

    @ParameterizedTest
    @MethodSource("cases")
    void methodSource(String s, int len) {
        org.junit.jupiter.api.Assertions.assertEquals(len, s.length());
    }
}
```

---

## Assumptions(가정) — 조건부 실행

```java
import static org.junit.jupiter.api.Assumptions.*;

@Test
void onlyOnCi() {
    assumeTrue("true".equals(System.getenv("CI")), "CI 환경에서만");
    // CI에서만 수행될 로직
}
```

실패가 아닌 **스킵**으로 처리된다. OS/JRE/환경변수 기반의 조건부 애너테이션(`@EnabledOnOs`, `@EnabledIfEnvironmentVariable` 등)도 활용 가능.

---

## 테스트 더블 — Stub/Mock/Fake/Spy (Mockito 예)

| 종류 | 목적 | 특징 |
|---|---|---|
| **Stub** | 고정 응답 제공 | 상태 검증 중심 |
| **Mock** | 상호작용 검증 | **호출/횟수** 검증 |
| **Fake** | 단순 대체 구현 | 인메모리 저장소 등 |
| **Spy** | 실제 + 호출 기록 | 부분 모킹 |

### 예제 — 리포지토리 모킹

```java
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.*;
import java.util.*;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

class User {
    private final long id;
    private boolean active;
    private LocalDate activatedAt;
    User(long id){ this.id = id; }
    long getId(){ return id; }
    boolean isActive(){ return active; }
    LocalDate getActivatedAt(){ return activatedAt; }
    void activate(LocalDate d){ active = true; activatedAt = d; }
}

interface UserRepository {
    Optional<User> findById(long id);
    void save(User user);
}

final class UserService {
    private final UserRepository repo;
    private final Clock clock;
    UserService(UserRepository repo, Clock clock){ this.repo = repo; this.clock = clock; }
    void activate(long id){
        User u = repo.findById(id).orElseThrow(NoSuchElementException::new);
        u.activate(LocalDate.now(clock));
        repo.save(u);
    }
}

@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    @Mock UserRepository repo;
    Clock fixedClock;
    UserService sut;

    @BeforeEach
    void init(){
        fixedClock = Clock.fixed(Instant.parse("2025-01-01T00:00:00Z"), ZoneOffset.UTC);
        sut = new UserService(repo, fixedClock);
    }

    @Test
    void activate_setsDate_andSaves() {
        User user = new User(1L);
        when(repo.findById(1L)).thenReturn(Optional.of(user));

        sut.activate(1L);

        assertTrue(user.isActive());
        assertEquals(LocalDate.of(2025,1,1), user.getActivatedAt());
        verify(repo).save(user);
        verify(repo, times(1)).findById(1L);
        verifyNoMoreInteractions(repo);
    }

    @Test
    void activate_throwsWhenNotFound() {
        when(repo.findById(99L)).thenReturn(Optional.empty());
        assertThrows(NoSuchElementException.class, () -> sut.activate(99L));
    }
}
```

> 포인트: **시간/난수/시계** 등은 **주입(Clock/Random/Seed)** 하여 **결정성**을 확보.

---

## 파일/시간/난수 의존성 다루기

### 임시 디렉터리 — `@TempDir`

```java
import org.junit.jupiter.api.io.TempDir;
import java.nio.file.*;
import static org.junit.jupiter.api.Assertions.*;

class FileTest {
    @TempDir Path tempDir;

    @Test
    void writesFileInTemp() throws Exception {
        Path out = tempDir.resolve("out.txt");
        Files.writeString(out, "hello");
        assertTrue(Files.exists(out));
    }
}
```

### 시간/난수 주입

- `LocalDate.now()` 대신 **`LocalDate.now(clock)`**, 테스트에서는 **`Clock.fixed(...)`** 사용.
- 난수는 **`Random`/`SplittableRandom`** 을 주입하거나 **seed 고정**.

---

## 동시성 단위 테스트 — 최소 검증

```java
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import static org.junit.jupiter.api.Assertions.*;

final class Counter {
    private final AtomicInteger value = new AtomicInteger();
    int inc(){ return value.incrementAndGet(); }
    int get(){ return value.get(); }
}

@org.junit.jupiter.api.Test
void inc_isThreadSafe() throws Exception {
    Counter c = new Counter();
    int threads = 8, iters = 5_000;
    ExecutorService es = Executors.newFixedThreadPool(threads);
    CountDownLatch start = new CountDownLatch(1), done = new CountDownLatch(threads);

    for (int t=0; t<threads; t++) {
        es.submit(() -> {
            start.await();
            for (int i=0; i<iters; i++) c.inc();
            done.countDown();
            return null;
        });
    }
    start.countDown();
    done.await();
    es.shutdown();
    assertEquals(threads * iters, c.get());
}
```

> **플레이키 방지**: `Thread.sleep(...)` 대신 **`Latch/Barrier`** 를 사용.

---

## 태깅/필터/수트/구조화

- **@Tag("slow")**, **@Tag("integration")**: 빌드/IDE/CI에서 **포함/제외** 필터링
- **@Nested**로 시나리오 그룹화:
```java
@Nested
@org.junit.jupiter.api.DisplayName("activate()는")
class Activate {
    @org.junit.jupiter.api.Test @org.junit.jupiter.api.DisplayName("사용자가 존재하면 활성화한다") void ok(){ /* ... */ }
    @org.junit.jupiter.api.Test @org.junit.jupiter.api.DisplayName("없으면 예외") void notFound(){ /* ... */ }
}
```
- **JUnit Platform Suite**(선택): 패키지/태그/클래스 조합으로 수트 구성

---

## 병렬 실행과 설정(`junit-platform.properties`)

프로젝트(테스트 리소스)에 **`junit-platform.properties`** 를 두고 병렬/런처 동작을 제어할 수 있다.

```properties
# 병렬 실행 활성화

junit.jupiter.execution.parallel.enabled=true
# 기본 모드: same_thread / concurrent

junit.jupiter.execution.parallel.mode.default=concurrent
# 클래스 레벨 동시성

junit.jupiter.execution.parallel.mode.classes.default=concurrent

# (선택) Vintage 엔진 병렬 제어

junit.vintage.execution.parallel.enabled=false
```

> I/O 바운드/독립 리소스는 **concurrent**, 전역 상태 공유가 있으면 **same_thread** 또는 리소스 격리.

---

## TDD 사이클과 실전 팁

- **Red → Green → Refactor**: 실패하는 **작은** 테스트 → **최소 구현** → **리팩터링**(녹색 유지)
- 작은 단위로 나누고, **의도 중심 이름**과 **명확한 실패 메시지**가 핵심
- 복잡한 픽스처는 **Test Data Builder** 로 캡슐화

---

## 커버리지와 품질

- 커버리지는 **지표**일 뿐 목표가 아니다.
  **핵심 로직/에러 경로/경계값**을 실제로 커버하는지 확인.
- **뮤테이션 테스트**(PIT 등)로 “테스트가 버그를 잡는 힘”을 점검.
- **정적 분석/포맷팅**: SpotBugs/Checkstyle/Spotless

---

## CI/빌드 — 빠르고 결정적으로

- **Wrapper** 사용: `mvnw` / `gradlew`
- **병렬 실행**: CI 워커/코어 수를 고려해 JUnit Platform + 빌드 툴에서 병렬화
- **리포트**: JUnit XML/HTML, 커버리지는 JaCoCo(Gradle `jacoco` 플러그인 / Maven `jacoco-maven-plugin`)

---

## 미니 예제 — 계정 잔액 이체(순수 단위 테스트)

### 도메인/서비스

```java
final class Account {
    private long balance;
    Account(long balance){ this.balance = balance; }
    long balance(){ return balance; }
    void deposit(long amount){ if (amount <= 0) throw new IllegalArgumentException(); balance += amount; }
    void withdraw(long amount){ if (amount <= 0 || amount > balance) throw new IllegalArgumentException(); balance -= amount; }
}

final class TransferService {
    void transfer(Account from, Account to, long amount) {
        if (from == null || to == null || from == to) throw new IllegalArgumentException();
        from.withdraw(amount);
        to.deposit(amount);
    }
}
```

### 테스트

```java
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

class TransferServiceTest {
    TransferService sut;

    @BeforeEach void setUp(){ sut = new TransferService(); }

    @Test
    void transfer_movesAmount() {
        Account a = new Account(10_000), b = new Account(0);
        sut.transfer(a, b, 3_000);
        assertAll(
            () -> assertEquals(7_000, a.balance()),
            () -> assertEquals(3_000, b.balance())
        );
    }

    @Test
    void transfer_failsOnInvalid() {
        Account a = new Account(1_000), b = new Account(0);
        assertThrows(IllegalArgumentException.class, () -> sut.transfer(a, b, 2_000)); // 초과 출금
        assertThrows(IllegalArgumentException.class, () -> sut.transfer(a, a, 100));   // 동일 계좌
        assertThrows(IllegalArgumentException.class, () -> sut.transfer(a, b, 0));     // 0 금액
    }
}
```

---

## 안티패턴 체크 — 피해야 할 것

- 단위 테스트에서 **네트워크/DB/파일** 직접 의존
- `Thread.sleep(...)` 로 타이밍 맞추기(플레이키)
- 전역 상태/싱글톤 **누수**
- 구현 세부사항(사소한 호출 순서 등)에 과도한 결합
- **Mock 남용**: 간단한 경우는 **Fake(인메모리)** 가 더 읽기 쉬움
- assert가 없는 “로그만 찍는” 테스트

---

## 마무리

- **JUnit 5(Jupiter)** 는 현대적 테스트의 표준이며, **JUnit 6에서도 동일한 Jupiter 경험**을 이어간다.
- 원칙은 변하지 않는다: **작고, 빠르고, 결정적**.
- 시간/난수/파일/동시성 같은 비결정성은 **주입/격리**로 통제하라.
- 태깅/조건/병렬/파라미터화/중첩/동적 테스트를 적절히 조합하면 **표현력·속도·유연성**이 모두 올라간다.
