---
layout: post
title: DB 심화 - 인덱스 파티셔닝
date: 2025-11-24 20:25:23 +0900
category: DB 심화
---
# Oracle **인덱스 파티셔닝**

> 목표: “**언제/무엇을** 만들고, **무엇이 어떻게** 빨라지는지”를 **예제로 검증**할 수 있게 설명합니다.
> 표준 가정: B-tree 기준(필요 시 Bitmap 언급), 8KB 블록, 11g 이상.

---

## 실습 공통 스키마(한 번만 실행)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';

-- 테이블: 월별 RANGE 파티셔닝
DROP TABLE sales PURGE;
CREATE TABLE sales (
  sales_id   NUMBER       NOT NULL,
  sales_dt   DATE         NOT NULL,
  cust_id    NUMBER       NOT NULL,
  region_cd  VARCHAR2(6)  NOT NULL,
  amount     NUMBER(12,2) NOT NULL,
  CONSTRAINT pk_sales PRIMARY KEY (sales_id)   -- (주의) pk는 글로벌 non-partitioned 인덱스로 생성됨
)
PARTITION BY RANGE (sales_dt) (
  PARTITION p2025m01 VALUES LESS THAN (DATE '2025-02-01'),
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION p2025m03 VALUES LESS THAN (DATE '2025-04-01'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

-- 차원(비파티션)
DROP TABLE dim_customer PURGE;
CREATE TABLE dim_customer (
  cust_id      NUMBER PRIMARY KEY,
  region_group VARCHAR2(10),
  grade        VARCHAR2(10),
  active_yn    CHAR(1)
);

-- 샘플 데이터
INSERT INTO dim_customer VALUES (101,'APAC','GOLD','Y');
INSERT INTO dim_customer VALUES (202,'AMER','SILVER','Y');
INSERT INTO dim_customer VALUES (303,'EMEA','BRONZE','N');

INSERT INTO sales VALUES ( 1, DATE '2025-02-10', 101, 'KR', 100.00);
INSERT INTO sales VALUES ( 2, DATE '2025-02-11', 202, 'US', 170.00);
INSERT INTO sales VALUES ( 3, DATE '2025-03-01', 202, 'US', 250.00);
COMMIT;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_CUSTOMER');
END;
/
```

---

## 인덱스 파티션 **유형 분류** (큰 그림)

| 구분 | 대상 | 파티셔닝 여부 | 주요 목적/특징 |
|---|---|---|---|
| **로컬(Local) 파티션 인덱스** | **파티션 테이블** | 인덱스도 **같이** 파티셔닝(파티션 당 인덱스 세그먼트 1개) | **운영·유지보수 최강**: ADD/SPLIT/MERGE/TRUNCATE 시 자동 정합. 파티션별 재빌드 가능. **UNIQUE 로컬**은 테이블 파티션 키가 **반드시** 인덱스 키에 포함되어야 함. |
| **비파티션(글로벌 Non-Partitioned)** | 파티션/비파티션 테이블 | **단일 세그먼트** | 테이블 전체에 유일성 보장, 소량 데이터 범용. 파티션 DDL 시 **UNUSABLE** 위험(UPDATE GLOBAL INDEXES/Rebuild 필요). |
| **글로벌 파티션 인덱스** | 주로 파티션 테이블 | 인덱스만 **독립 파티셔닝**(RANGE/HASH) | 전역 유니크 보장(전역 키), 병렬/경합 분산, 파티션 DDL 영향 받음(정책 필요). |

> Bitmap 인덱스도 **로컬/글로벌**(일부 버전 제한) 가능하지만, **OLTP 대량 DML**엔 부적합(조금만 수정해도 광범위 리밸런싱). **DW/스타쿼리**에 적합.

---

## **로컬(Local) 파티션 인덱스**

### 기본/효과

- **테이블 파티션**과 **1:1로 대응**하는 **인덱스 파티션**을 가짐.
- **프루닝 + 파티션 단위 병렬**이 자연스럽고, **유지보수(DDL)** 시 자동 정합 → **현업 기본값**.
- **UNIQUE LOCAL** 제약: **테이블 파티션 키**가 **인덱스 키에 포함**되어야 함(파티션 안에서만 유일).

### 예제: 로컬 B-tree 인덱스 2종

```sql
-- (A) 프리픽스(Prefixed) 로컬: 테이블 파티션 키(sales_dt)로 시작
CREATE INDEX sales_lix_pref
  ON sales(sales_dt, cust_id, amount) LOCAL;

-- (B) 논프리픽스(Non-Prefixed) 로컬: 파티션 키가 왼쪽이 아님
CREATE INDEX sales_lix_nonpref
  ON sales(cust_id, sales_dt) LOCAL;
```

#### 차이점(핵심)

- **Prefixed 로컬**
  - 인덱스 **리딩 컬럼 = 파티션 키** → **인덱스 파티션 프루닝**이 **더 직접적**.
  - `WHERE sales_dt BETWEEN ...` 같은 날짜 범위를 **인덱스 Range Scan**으로 바로 타기 쉬움.
- **Non-Prefixed 로컬**
  - 리딩 컬럼이 `cust_id`라면 `WHERE cust_id=:b`만 있을 때 **여러 인덱스 파티션을 전부** 건드릴 수 있음(파티션 키 제약이 없으므로).
  - 대신 `WHERE sales_dt BETWEEN ...`이 있으면 **테이블/인덱스 프루닝**은 여전히 가능.
  - **스타쿼리**에서 팩트 인덱스가 리딩 컬럼으로 조인키를 잡아주는 장점도 있음.

### 프루닝 비교(플랜으로 보기)

```sql
-- 날짜 조건만: Prefixed가 깔끔한 인덱스 range scan로 한 파티션만 접근
EXPLAIN PLAN FOR
SELECT /* Prefixed가 유리한 케이스 */
       SUM(amount)
FROM   sales
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));

-- 고객 조건만: Non-Prefixed는 cust_id로 인덱스 range 가능하나,
-- 파티션 키가 없으니 여러 인덱스 파티션을 탐색할 수 있음(버전/통계/플랜에 따라 병렬·조인필터와 결합).
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   sales
WHERE  cust_id = 202;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
```

### 로컬 **UNIQUE** 인덱스 규칙

```sql
-- (실패) 파티션 키가 빠져있으면 로컬 UNIQUE 불가
-- CREATE UNIQUE INDEX sales_u_bad ON sales(sales_id) LOCAL;  -- ORA-14039 유사 오류

-- (성공) 파티션 키 포함
CREATE UNIQUE INDEX sales_u_good
  ON sales(sales_id, sales_dt) LOCAL;
```
- 이유: 로컬 인덱스는 **파티션 내부**에서만 유일을 보장하므로,
  파티션을 구분하는 **키(sales_dt)**가 들어와야 테이블 전체 유일성이 의미를 가짐.

### 로컬 인덱스 유지보수(DDL)

```sql
-- 테이블 파티션 조작 시 로컬 인덱스는 자동 정합 처리
ALTER TABLE sales SPLIT PARTITION p2025m02 AT (DATE '2025-02-15')
  INTO (PARTITION p2025m02a, PARTITION p2025m02b);

-- 파티션별 인덱스 재빌드
ALTER INDEX sales_lix_pref REBUILD PARTITION p2025m02a;
ALTER INDEX sales_lix_pref REBUILD PARTITION p2025m02b;

-- 파티션 TRUNCATE 시에도 로컬 인덱스 자동 반영
ALTER TABLE sales TRUNCATE PARTITION p2025m01;
```

> **Bitmap 로컬**: DW 환경에서 `region_cd`같은 저선택도 컬럼에 유용.
> **주의**: 빈번한 DML에서는 **락·재빌드 비용**과 **대량 변경 시 비효율**이 크다.

---

## **비파티션(글로벌 Non-Partitioned) 인덱스** (GNI)

### 언제 쓰나

- 테이블 전체에서 **유일성**을 강제(예: `sales_id`가 **전 기간** 유일).
- 테이블 파티션 키를 **인덱스에 포함하기 싫거나** 포함할 수 없을 때.

```sql
-- (기본키로 이미 생성되었지만 예시 재현)
DROP INDEX pk_sales;
CREATE UNIQUE INDEX pk_sales ON sales(sales_id);  -- 글로벌 non-partitioned
ALTER TABLE sales ADD CONSTRAINT pk_sales PRIMARY KEY (sales_id) USING INDEX;
```

### 단점/운영 주의

- **파티션 DDL**(DROP/TRUNCATE/SPLIT/MERGE/EXCHANGE) 후
  글로벌 인덱스가 **UNUSABLE** 상태가 되기 쉽다 → **Rebuild** 필요.
```sql
-- 파티션 조작 후 상태 점검
SELECT index_name, status FROM user_indexes WHERE table_name='SALES';

-- 재빌드
ALTER INDEX pk_sales REBUILD ONLINE;
-- 또는 테이블 DDL 시 "UPDATE GLOBAL INDEXES" 옵션 사용(비용↑, 즉시 유지)
```

> **요약**: 유일성/조회 패턴 때문에 어쩔 수 없이 필요할 때만.
> 유지보수 코스트를 **정책화**해야 한다(배치창구에서 Rebuild, ONLINE 옵션 등).

---

## **글로벌 파티션 인덱스** (GPI: Global Partitioned Index)

### 개념/장점

- 인덱스만 **독립적으로** RANGE/HASH 파티셔닝.
- 대용량에서 **경합 분산**, **병렬 스캔/리밸런싱** 유리.
- **전역 유니크**도 가능(전 기간 유일성 + 파티셔닝은 인덱스 내부적).

### HASH 파티션 예시(전역)

```sql
-- 고객별 조회가 많다면 cust_id 기준 HASH 분산
CREATE INDEX sales_gpi_hash
  ON sales(cust_id, sales_dt)
  GLOBAL PARTITION BY HASH (cust_id)
  PARTITIONS 8
  STORE IN (ts_h1, ts_h2, ts_h3, ts_h4, ts_h5, ts_h6, ts_h7, ts_h8);
```

### RANGE 파티션 예시(전역)

```sql
-- 금액대별 범위로 전역 인덱스 파티션(예시)
CREATE INDEX sales_gpi_range
  ON sales(amount, sales_dt)
  GLOBAL PARTITION BY RANGE (amount) (
    PARTITION gpa_low   VALUES LESS THAN (100),
    PARTITION gpa_mid   VALUES LESS THAN (1000),
    PARTITION gpa_high  VALUES LESS THAN (MAXVALUE)
  );
```

### 유지보수

- 여전히 **테이블 파티션 DDL 영향**을 받는다(UNUSABLE 위험).
- 반면, 인덱스 자체는 전역 파티션이므로 **COALESCE/MOVE/REBUILD PARTITION**으로
  **인덱스만** 유지보수/튜닝 가능(경합/공간/Hot Partition 분리).

---

## **Prefixed vs Non-Prefixed** (정의/영향/예시)

### 정의

- **Prefixed**: **인덱스 파티셔닝 키**(또는 테이블 파티션 키)가 **인덱스 키의 왼쪽부터** 포함된 형태.
  - 로컬의 경우: **테이블 파티션 키 컬럼이 인덱스의 리딩 컬럼**에 온다 → 프루닝/Range Scan 유리.
  - 글로벌 파티션 인덱스의 경우: **인덱스 파티션 키**가 **인덱스 키의 왼쪽부터** 포함되면 **Prefixed GPI**.
- **Non-Prefixed**: 파티션 키가 인덱스 키 **왼쪽에 오지 않는** 형태.

### 성능/계획 영향

- **프루닝**: 파티션 키 조건이 있으면 **둘 다 프루닝 가능**하지만,
  **Prefixed**는 **인덱스 레벨에서 즉시** 범위를 좁히기 쉬움(Access Predicate가 인덱스 선두와 정합).
- **인덱스 Range Scan**: 리딩 컬럼 조건이 핵심 → Prefixed가 **날짜 범위/등치**에 더 강함.
- **UNIQUE LOCAL**: **Prefixed(=파티션 키 포함)**가 사실상 강제(규칙).
- **스타쿼리/DW**: 팩트 인덱스에 조인키(예: `cust_id`)를 **리딩**으로 두는 Non-Prefixed가 유리한 경우도 있다.
  (다만 파티션 키가 없으면 **여러 파티션**을 두드릴 수 있음을 감안)

### 검증 예시

```sql
-- (1) 날짜 범위만 있을 때: Prefixed가 깔끔하게 한 파티션 Range Scan
EXPLAIN PLAN FOR
SELECT /* 날짜 범위: Prefixed 유리 */
       COUNT(*)
FROM   sales
WHERE  sales_dt BETWEEN DATE '2025-02-01' AND DATE '2025-02-28';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));

-- (2) cust_id만 있을 때: Non-Prefixed가 리딩 컬럼 활용 가능
EXPLAIN PLAN FOR
SELECT /* 고객 조건: Non-Prefixed 리딩 활용 */
       SUM(amount)
FROM   sales
WHERE  cust_id = 202;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));

-- (3) 날짜+고객 동시: 둘 다 좋아짐(각각의 Access Predicate 성립)
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   sales
WHERE  sales_dt >= DATE '2025-02-01' AND sales_dt < DATE '2025-03-01'
AND    cust_id = 202;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
```

---

## **컴포지트(서브파티션) 테이블**에서의 로컬 인덱스

### × HASH(cust_id)

```sql
DROP TABLE sales_rh PURGE;
CREATE TABLE sales_rh (
  sales_id  NUMBER NOT NULL,
  sales_dt  DATE   NOT NULL,
  cust_id   NUMBER NOT NULL,
  amount    NUMBER,
  CONSTRAINT pk_sales_rh PRIMARY KEY (sales_id)
)
PARTITION BY RANGE (sales_dt)
SUBPARTITION BY HASH (cust_id) SUBPARTITIONS 8
(
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION p2025m03 VALUES LESS THAN (DATE '2025-04-01')
);

-- Prefixed 로컬(상위 파티션키 -> 하위 서브파티션키 순서)
CREATE INDEX sales_rh_lix
  ON sales_rh(sales_dt, cust_id, amount)
  LOCAL;  -- 테이블과 동일한 파티션/서브파티션 매핑
```

### 서브파티션 템플릿(선택)

```sql
-- 동일한 서브파티션 구조를 자동 반영하고 싶을 때(테이블에서 TEMPLATE 사용)
-- 위 예시는 이미 SUBPARTITION TEMPLATE를 내포한 형태.
```

### 효과

- `WHERE sales_dt BETWEEN ...` → **상위 RANGE 프루닝**
- `AND cust_id IN (...)` → **하위 HASH 서브파티션 프루닝**
- 플랜에서 `PSTART/PSTOP`뿐 아니라 **SUBPARTITION 프루닝** 신호를 볼 수 있다.

---

## **인덱스 파티셔닝 운영 DDL 모음**

### 로컬 인덱스 파티션 재빌드/이동

```sql
ALTER INDEX sales_lix_pref REBUILD PARTITION p2025m02 TABLESPACE ts_2025;
ALTER INDEX sales_lix_pref REBUILD SUBPARTITION p2025m02_sp3;     -- 서브파티션 단위
```

### 글로벌 인덱스 파티션 관리

```sql
ALTER INDEX sales_gpi_hash COALESCE PARTITION;          -- 해시 파티션 균형화
ALTER INDEX sales_gpi_range REBUILD PARTITION gpa_mid;  -- 범위 파티션 재빌드
```

### 테이블 파티션 DDL과 글로벌 인덱스

```sql
-- 즉시 전역 인덱스 유지(DDL 느려짐) vs 사후 REBUILD
ALTER TABLE sales TRUNCATE PARTITION p2025m01 UPDATE GLOBAL INDEXES;
-- (또는)
ALTER INDEX pk_sales REBUILD ONLINE;  -- 사후 재빌드
```

### 한 줄 메모

- 특정 테이블 파티션에 대해 **INDEXING ON/OFF** 설정 → 로컬 인덱스를 **일부 파티션만** 유지(핫 파티션만 인덱싱).
  (버전별 세부 제약 존재)

---

## **설계·선택 가이드** (현업 요약)

1. **기본값은 로컬**: 유지보수·프루닝·병렬이 자연스러움.
2. **UNIQUE가 전 기간**에서 필요하면 **글로벌(또는 글로벌 Non-Partitioned)**.
3. **조회 패턴이 날짜 범위 중심**이면 **Prefixed(Local)**(예: `(sales_dt, ...)`).
   **조인키/차원키 중심**이면 Non-Prefixed도 고려(스타쿼리).
4. **DW**: 로컬 **Bitmap** + 파티션 프루닝 + 조인필터(블룸) 조합이 강력.
5. **대량 DML OLTP**: Bitmap 지양, B-tree 로컬/글로벌 선택.
6. **파티션 DDL이 잦다**: 글로벌 인덱스의 **UNUSABLE 관리정책**을 미리 디자인(UPDATE GLOBAL INDEXES vs Rebuild 배치).
7. **컴포지트 구조**: 상·하위 프루닝을 함께 노리려면 인덱스도 **같이 정렬**(Prefixed Local).

---

## **끝까지 보는 구성 예시**(한 화면 요약 DDL)

```sql
-- 1) 테이블(월 RANGE)
CREATE TABLE sales (... 동일 ...)
PARTITION BY RANGE (sales_dt) (...);

-- 2) 로컬 인덱스 2개(용도별)
CREATE INDEX sales_lix_pref    ON sales(sales_dt, cust_id, amount) LOCAL;
CREATE INDEX sales_lix_nonpref ON sales(cust_id, sales_dt)          LOCAL;

-- 3) 글로벌 Non-Partitioned (전역 유일성)
CREATE UNIQUE INDEX sales_uid ON sales(sales_id);
ALTER TABLE sales ADD CONSTRAINT sales_uid_uk UNIQUE (sales_id) USING INDEX sales_uid;

-- 4) 글로벌 파티션 인덱스 (HASH)
CREATE INDEX sales_gpi_hash ON sales(cust_id, sales_dt)
  GLOBAL PARTITION BY HASH (cust_id) PARTITIONS 8;

-- 5) 프루닝 확인(예: 2월만)
EXPLAIN PLAN FOR
SELECT SUM(amount) FROM sales
WHERE sales_dt >= DATE '2025-02-01' AND sales_dt < DATE '2025-03-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));

-- 6) 유지보수: 파티션 SPLIT → 로컬 인덱스 자동 정합
ALTER TABLE sales SPLIT PARTITION p2025m02 AT (DATE '2025-02-15')
  INTO (PARTITION p2025m02a, PARTITION p2025m02b);

-- 7) 글로벌 인덱스 상태 체크/재빌드
SELECT index_name, status FROM user_indexes WHERE table_name='SALES';
ALTER INDEX sales_uid REBUILD ONLINE;
```

---

## **자주 받는 질문(FAQ) 요약**

- **Q. 로컬 UNIQUE 인덱스에서 파티션 키를 빼도 되나요?**
  A. **안 됩니다.** 로컬은 파티션 내부 유일만 보장되므로 **테이블 파티션 키를 인덱스 키에 포함**해야 전체 유일이 성립.

- **Q. 글로벌 Non-Partitioned vs 글로벌 파티션 인덱스?**
  A. 전자는 **단일 세그먼트**라 관리 단순하지만 파티션 DDL에 **취약**.
     후자는 **분산/병렬**에 유리하고 특정 파티션만 재빌드 가능, 그러나 역시 테이블 DDL 영향은 받음.

- **Q. Prefixed가 무조건 좋은가요?**
  A. “날짜 범위/프루닝/Range Scan”에는 명확히 유리. 다만 **조인키 선두**가 필요한 쿼리 패턴에선 Non-Prefixed가 유리할 수 있음(패턴에 맞춰 **둘을 병행**하기도).

- **Q. DW에서 Bitmap 로컬 인덱스는?**
  A. **읽기 중심·배치 적재**라면 매우 강력(스타 변환/AND-Equal 등). **OLTP 대량 DML**에는 부적합.

---

### 한 줄 결론

- **운영 기본값은 로컬**(Prefixed를 우선 고려)
- **전역 유일성/전역 접근 패턴**은 **글로벌(파티션/비파티션)**
- **쿼리 패턴**(날짜 vs 조인키)에 맞춰 **Prefixed/Non-Prefixed**를 **전략적으로 공존**시키면,
  파티션 프루닝·병렬성·유지보수 **세 마리 토끼**를 잡을 수 있습니다.
