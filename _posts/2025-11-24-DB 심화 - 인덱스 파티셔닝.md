---
layout: post
title: Oracle 인덱스 파티셔닝 실전 가이드
date: 2025-11-24 20:25:23 +0900
category: DB 심화
---
# Oracle 인덱스 파티셔닝: 실전 설계와 성능 검증

이 가이드는 Oracle 파티션 테이블에서 인덱스를 어떻게 설계하고 운영해야 하는지에 대한 실용적인 지침을 제공합니다. 단순한 개념 설명을 넘어, 실제 쿼리 플랜과 성능 통계를 통해 각 설계 선택이 어떤 영향을 미치는지 확인하는 방법을 중점적으로 다룹니다.

**핵심 목표:**
1. 로컬(Local)과 글로벌(Global) 인덱스의 적절한 사용 시기 이해
2. Prefixed와 Non-Prefixed 인덱스가 성능에 미치는 영향 분석
3. 파티션 DDL 작업 시 인덱스 관리 정책 수립
4. 실제 SQL과 실행 계획을 통한 검증 방법 습득

---

## 실습 환경 설정

다음 스키마를 사용하여 각 개념을 직접 실습해볼 수 있습니다.

```sql
-- 파티션 테이블 생성 (월 단위 RANGE 파티셔닝)
CREATE TABLE sales (
  sales_id   NUMBER       NOT NULL,
  sales_dt   DATE         NOT NULL,  -- 파티션 키
  cust_id    NUMBER       NOT NULL,
  region_cd  VARCHAR2(6)  NOT NULL,
  amount     NUMBER(12,2) NOT NULL,
  CONSTRAINT pk_sales PRIMARY KEY (sales_id)
)
PARTITION BY RANGE (sales_dt) (
  PARTITION p2025m01 VALUES LESS THAN (DATE '2025-02-01'),
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION p2025m03 VALUES LESS THAN (DATE '2025-04-01'),
  PARTITION p2025m04 VALUES LESS THAN (DATE '2025-05-01'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

-- 차원 테이블
CREATE TABLE dim_customer (
  cust_id      NUMBER PRIMARY KEY,
  region_group VARCHAR2(10),
  grade        VARCHAR2(10),
  active_yn    CHAR(1)
);

-- 샘플 데이터 삽입
INSERT INTO dim_customer VALUES (101,'AMER','GOLD','Y');
INSERT INTO dim_customer VALUES (202,'EMEA','SILVER','Y');
INSERT INTO dim_customer VALUES (303,'AMER','BRONZE','N');

-- 대량 샘플 데이터 생성 (각 파티션에 분산)
BEGIN
  FOR i IN 1..200000 LOOP
    INSERT INTO sales VALUES(
      i,
      DATE '2025-01-01' + MOD(i,140),  -- 1~5월에 걸쳐 분산
      CASE MOD(i,5000) WHEN 0 THEN 101 WHEN 1 THEN 202 ELSE 303 END,
      CASE MOD(i,4) WHEN 0 THEN 'US' WHEN 1 THEN 'DE' WHEN 2 THEN 'FR' ELSE 'UK' END,
      ROUND(DBMS_RANDOM.VALUE(10,5000),2)
    );
  END LOOP;
  COMMIT;
END;
/

-- 통계 수집
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES', cascade=>TRUE);
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_CUSTOMER');
```

**실행 계획 확인 방법:**
```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL,NULL,
         'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS +PEEKED_BINDS'
));
```

---

## 인덱스 파티셔닝의 본질: 세 가지 핵심 가치

파티션 테이블에 인덱스를 파티셔닝하는 주된 이유는 다음 세 가지입니다.

### 1. 프루닝(Partition Pruning) 최적화
파티션 키 조건이 WHERE 절에 존재하면 Oracle은 관련 파티션만 접근합니다. 인덱스도 동일하게 파티셔닝되어 있을 경우, 해당 인덱스 파티션만 스캔하여 I/O와 CPU 사용을 동시에 줄일 수 있습니다.

### 2. 운영 유지보수 효율성
월별 데이터 관리(추가/분할/병합/삭제/교체)가 빈번한 환경에서 로컬 파티션 인덱스는 테이블 파티션 변경 시 자동으로 동기화됩니다. 이는 글로벌 인덱스의 수동 재구성 부담을 크게 줄여줍니다.

### 3. 병렬 처리 및 경합 분산
파티션 단위로 작업이 분할되어 병렬 실행의 자연스러운 단위가 됩니다. 또한 인덱스 핫스팟을 파티션별로 분산시켜 경합을 완화할 수 있습니다.

**핵심 질문:** "우리 쿼리가 프루닝을 얼마나 활용하는가?"와 "파티션 DDL 작업이 얼마나 빈번한가?"를 먼저 평가해야 합니다.

---

## 인덱스 파티션의 세 가지 유형

| 유형 | 설명 | 파티셔닝 | 운영 DDL 영향 |
|------|------|----------|---------------|
| **로컬 파티션 인덱스** | 테이블 파티션과 1:1 대응 | 테이블과 동일한 방식 | 자동 동기화 (기본 권장) |
| **글로벌 비파티션 인덱스** | 전체 테이블을 아우르는 단일 인덱스 | 파티셔닝 없음 | UNUSABLE 위험 높음 |
| **글로벌 파티션 인덱스** | 테이블과 독립적인 파티셔닝 방식 | 독립적 파티셔닝 | 영향 있음 (정책 필요) |

---

## 로컬(Local) 파티션 인덱스: 현업의 기본 선택

### 기본 개념
로컬 인덱스는 테이블의 각 파티션과 정확히 1:1로 매핑됩니다. 각 파티션마다 별도의 인덱스 세그먼트가 생성되며, 테이블 파티션의 추가/분할/병합/삭제/교체 작업 시 자동으로 인덱스도 동기화됩니다.

### Prefixed vs Non-Prefixed 로컬 인덱스

#### Prefixed 로컬 인덱스
파티션 키가 인덱스 선두 컬럼인 경우입니다. 파티션 키 기반의 범위 검색에 최적화됩니다.

```sql
-- 파티션 키(sales_dt)가 선두 컬럼인 Prefixed 인덱스
CREATE INDEX sales_lix_pref
  ON sales(sales_dt, cust_id, amount) LOCAL;
```

**적합한 시나리오:**
- 파티션 키(예: 날짜)로 주로 검색하는 경우
- BETWEEN, >=, <= 등의 범위 조건 사용 시
- 특정 기간 데이터 집계 시

**성능 검증:**
```sql
-- 파티션 키 범위 조건 사용 시 Prefixed 인덱스 최적화 확인
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   sales
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01';

-- 실행 계획에서 PARTITION RANGE SINGLE/ITERATOR 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

#### Non-Prefixed 로컬 인덱스
파티션 키가 인덱스 선두에 오지 않는 경우입니다. 조인 키나 다른 고선택도 컬럼 기반 검색에 최적화됩니다.

```sql
-- 고객 ID가 선두, 파티션 키가 뒤에 있는 Non-Prefixed 인덱스
CREATE INDEX sales_lix_nonpref
  ON sales(cust_id, sales_dt) LOCAL;
```

**적합한 시나리오:**
- 특정 고객의 모든 거래 조회 시
- 차원 키 기반의 조인이 빈번한 스타 스키마 환경
- 파티션 키 없이 다른 컬럼으로 검색하는 경우

**성능 검증:**
```sql
-- 고객 ID 단일 조건 검색
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   sales
WHERE  cust_id = 202;

-- 실행 계획에서 INDEX RANGE SCAN 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 로컬 UNIQUE 인덱스의 중요 규칙

로컬 인덱스는 파티션 내에서만 유일성을 보장합니다. 따라서 테이블 전체의 유일성을 보장하려면 반드시 파티션 키를 인덱스 컬럼에 포함해야 합니다.

```sql
-- 잘못된 예: 파티션 키 없이 UNIQUE 로컬 인덱스 생성 시도
-- CREATE UNIQUE INDEX sales_u_bad ON sales(sales_id) LOCAL; -- 실패!

-- 올바른 예: 파티션 키 포함
CREATE UNIQUE INDEX sales_u_good
  ON sales(sales_id, sales_dt) LOCAL; -- 성공
```

### 로컬 인덱스의 자동 정합성 유지

로컬 인덱스는 테이블 파티션 DDL 작업 후에도 자동으로 유효한 상태를 유지합니다.

```sql
-- 파티션 분할: 로컬 인덱스 자동 동기화
ALTER TABLE sales SPLIT PARTITION p2025m02 AT (DATE '2025-02-15')
  INTO (PARTITION p2025m02a, PARTITION p2025m02b);

-- 상태 확인: 모든 로컬 인덱스가 VALID 상태 유지
SELECT index_name, partitioned, status
FROM   user_indexes
WHERE  table_name='SALES';
```

---

## 글로벌 비파티션 인덱스(GNI): 신중한 사용 필요

### 사용 시기
전체 테이블을 아우르는 유일성 제약이 필요하거나, 파티션 키를 인덱스에 포함하기 어려운 자연 키가 있을 때 사용합니다.

```sql
-- 기본 키로 글로벌 비파티션 인덱스 생성
CREATE UNIQUE INDEX pk_sales
  ON sales(sales_id);  -- 파티션 키 미포함

ALTER TABLE sales
  ADD CONSTRAINT pk_sales
  PRIMARY KEY (sales_id)
  USING INDEX pk_sales;
```

### 주요 위험: UNUSABLE 상태 전환

글로벌 비파티션 인덱스는 파티션 DDL 작업 시 전체 인덱스가 무효화될 수 있습니다.

```sql
-- 파티션 잘라내기: 글로벌 인덱스 무효화 가능성
ALTER TABLE sales TRUNCATE PARTITION p2025m02;

-- 상태 확인: UNUSABLE 가능성
SELECT index_name, status
FROM   user_indexes
WHERE  table_name='SALES' AND index_name = 'PK_SALES';
```

### 보호 메커니즘

인덱스를 유지하면서 DDL을 실행하려면 추가 옵션이 필요합니다.

```sql
-- 인덱스 유지 옵션 사용 (DDL 성능 저하)
ALTER TABLE sales TRUNCATE PARTITION p2025m02
  UPDATE GLOBAL INDEXES;
```

### 운영 정책: 배치 재구성

운영 환경에서는 DDL 속도를 위해 UNUSABLE을 수용하고, 배치 시간에 재구성하는 패턴이 일반적입니다.

```sql
-- 사후 재구성 (온라인으로 수행 가능)
ALTER INDEX pk_sales REBUILD ONLINE PARALLEL 4;
-- 병렬도 원복
ALTER INDEX pk_sales NOPARALLEL;
```

---

## 글로벌 파티션 인덱스(GPI): 전역 유일성 + 분산 성능

### 사용 시기
전체 테이블의 유일성을 유지하면서도 인덱스 접근 경합을 분산시키고 싶을 때 사용합니다.

### 해시 파티셔닝 GPI: 경합 분산

```sql
-- 고객 ID 기반 해시 파티셔닝 (OLTP 경합 분산)
CREATE INDEX sales_gpi_hash
  ON sales(cust_id, sales_dt)
  GLOBAL PARTITION BY HASH (cust_id)
  PARTITIONS 8;
```

**효과:** 동일한 `cust_id`에 대한 빈번한 접근이 여러 파티션으로 분산되어 루트/브랜치 블록 경합이 완화됩니다.

### 범위 파티셔닝 GPI: 데이터 분산

```sql
-- 금액 범위 기반 파티셔닝
CREATE INDEX sales_gpi_range
  ON sales(amount, sales_dt)
  GLOBAL PARTITION BY RANGE (amount) (
    PARTITION gpa_low  VALUES LESS THAN (100),
    PARTITION gpa_mid  VALUES LESS THAN (1000),
    PARTITION gpa_high VALUES LESS THAN (MAXVALUE)
  );
```

### GPI 관리: 파티션 단위 유지보수

GPI도 테이블 파티션 DDL의 영향을 받지만, 파티션 단위로 재구성할 수 있는 유연성이 있습니다.

```sql
-- 특정 파티션만 재구성
ALTER INDEX sales_gpi_range REBUILD PARTITION gpa_mid;

-- 해시 파티션 통합 (COALESCE)
ALTER INDEX sales_gpi_hash COALESCE PARTITION;
```

---

## Prefixed vs Non-Prefixed: 실전 설계 가이드

### 성능 특성 비교

| 특성 | Prefixed 인덱스 | Non-Prefixed 인덱스 |
|------|-----------------|---------------------|
| **파티션 프루닝** | 직접적이고 효율적 | 조건 구조에 의존적 |
| **범위 검색** | 파티션 키 범위 조건에 최적 | 선두 컬럼 조건 필요 |
| **조인 최적화** | 날짜 축 중심 모델에 강함 | 차원 키 중심 모델에 강함 |
| **유일성 제약** | 로컬 UNIQUE에 필수 | 파티션 키 없이 UNIQUE 불가 |

### 혼합 설계 전략

실제 서비스에서는 다양한 액세스 패턴을 수용하기 위해 두 유형을 조합하여 사용하는 것이 일반적입니다.

```sql
-- 시나리오 1: 날짜 범위 + 고객 조건 (혼합 패턴)
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   sales
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01'
AND    cust_id = 202;

-- Prefixed와 Non-Prefixed 인덱스 모두 효과적
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

## 고급 주제: 컴포지트 파티셔닝과 파티션-와이즈 조인

### 컴포지트(서브파티션) 테이블

RANGE-HASH와 같은 다중 수준 파티셔닝에서도 로컬 인덱스는 유효합니다.

```sql
-- RANGE-HASH 컴포지트 파티션 테이블
CREATE TABLE sales_rh (
  sales_id NUMBER NOT NULL,
  sales_dt DATE   NOT NULL,      -- RANGE 파티션 키
  cust_id  NUMBER NOT NULL,      -- HASH 서브파티션 키
  amount   NUMBER
)
PARTITION BY RANGE (sales_dt)
SUBPARTITION BY HASH (cust_id) SUBPARTITIONS 8
(
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION p2025m03 VALUES LESS THAN (DATE '2025-04-01'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

-- 로컬 인덱스 생성
CREATE INDEX sales_rh_lix
  ON sales_rh(sales_dt, cust_id, amount)
  LOCAL;
```

**2단계 프루닝 확인:**
```sql
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   sales_rh
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01'
AND    cust_id IN (101,202);

-- PARTITION RANGE SINGLE + SUBPARTITION HASH KEY 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 파티션-와이즈 조인(Partition-Wise Join)

동일한 파티션 키를 공유하는 두 테이블을 조인할 때 Oracle은 파티션 단위로 조인을 수행하여 성능을 극대화할 수 있습니다.

```sql
-- 환불 테이블 (동일한 파티션 구조)
CREATE TABLE refunds (
  refund_id NUMBER,
  sales_dt  DATE,      -- sales 테이블과 동일한 파티션 키
  sales_id  NUMBER,
  amt       NUMBER
)
PARTITION BY RANGE (sales_dt) (
  PARTITION p2025m01 VALUES LESS THAN (DATE '2025-02-01'),
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION p2025m03 VALUES LESS THAN (DATE '2025-04-01'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

-- 로컬 인덱스 생성
CREATE INDEX refunds_lix ON refunds(sales_dt, sales_id) LOCAL;

-- 파티션-와이즈 조인 예시
EXPLAIN PLAN FOR
SELECT /*+ USE_HASH(r) */
       SUM(s.amount - NVL(r.amt,0))
FROM   sales s
LEFT JOIN refunds r
  ON   r.sales_id = s.sales_id
 AND   r.sales_dt = s.sales_dt
WHERE  s.sales_dt BETWEEN DATE '2025-02-01' AND DATE '2025-03-31';

-- 파티션 단위 조인 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

## Bitmap 인덱스 파티셔닝: DW 환경에 특화

비트맵 인덱스는 데이터 웨어하우스 환경에서 저선택도 컬럼에 강력한 성능을 발휘하지만, OLTP 환경에서는 주의가 필요합니다.

### 로컬 Bitmap 인덱스 예시

```sql
-- 지역 코드에 대한 비트맵 인덱스 (로컬)
CREATE BITMAP INDEX sales_bix_region
  ON sales(region_cd)
  LOCAL;
```

### 사용 가이드라인

| 환경 | 권장 여부 | 이유 |
|------|-----------|------|
| **DW/배치** | 추천 | 읽기 위주, 집계 쿼리 최적화 |
| **OLTP** | 비추천 | DML 시 락 경합 증가, 재구성 비용 높음 |
| **혼합** | 제한적 사용 | 비트맵 인덱스가 필요한 컬럼만 선택적 적용 |

---

## 운영 DDL과 인덱스 관리 정책

### 로컬 인덱스 관리

```sql
-- 특정 파티션만 재구성 (운영 유연성)
ALTER INDEX sales_lix_pref REBUILD PARTITION p2025m02;

-- 여러 파티션 일괄 재구성
BEGIN
  FOR rec IN (SELECT partition_name 
              FROM user_ind_partitions 
              WHERE index_name = 'SALES_LIX_PREF'
              AND status = 'UNUSABLE') 
  LOOP
    EXECUTE IMMEDIATE 
      'ALTER INDEX sales_lix_pref REBUILD PARTITION ' || rec.partition_name;
  END LOOP;
END;
/
```

### 글로벌 인덱스 상태 모니터링

```sql
-- 인덱스 상태 점검
SELECT index_name, status, partitioned,
       CASE 
         WHEN status = 'UNUSABLE' THEN '주의: 재구성 필요'
         ELSE '정상'
       END AS alert
FROM   user_indexes
WHERE  table_name='SALES';

-- 파티션 인덱스 세부 상태
SELECT index_name, partition_name, status,
       last_analyzed, num_rows
FROM   user_ind_partitions
WHERE  index_name LIKE 'SALES_GPI%';
```

### 파티션 교체(EXCHANGE) 패턴

대량 데이터 적재 시 가장 효율적인 패턴입니다.

```sql
-- 1. 스테이징 테이블 준비
CREATE TABLE sales_stg AS SELECT * FROM sales WHERE 1=0;

-- 2. 스테이징 테이블에 데이터 적재
-- INSERT /*+ APPEND */ INTO sales_stg ...

-- 3. 파티션 교체 (로컬 인덱스 자동 정합)
ALTER TABLE sales EXCHANGE PARTITION p2025m04
  WITH TABLE sales_stg
  WITHOUT VALIDATION;

-- 4. 교체 후 통계 업데이트
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER, 'SALES', 
       partition_name=>'P2025M04', cascade=>TRUE);
```

### 글로벌 인덱스 DDL 정책 선택

운영 요구사항에 따라 두 가지 접근법 중 선택:

```sql
-- 옵션 A: DDL 속도 우선, 사후 재구성
ALTER TABLE sales DROP PARTITION p2025m01;
-- 배치 시간에 재구성
ALTER INDEX pk_sales REBUILD ONLINE;

-- 옵션 B: 인덱스 유지 우선, DDL 성능 저하 수용
ALTER TABLE sales DROP PARTITION p2025m01 
  UPDATE GLOBAL INDEXES;
```

---

## 실전 설계 의사결정 프레임워크

### 로컬 vs 글로벌 선택 가이드

1. **로컬 인덱스가 기본 선택인 경우:**
   - 월별/일별 파티션 관리가 빈번한 운영 환경
   - 대부분의 쿼리가 파티션 키를 조건으로 사용
   - 간단한 유지보수 정책을 원하는 경우

2. **글로벌 인덱스가 필요한 경우:**
   - 테이블 전체의 유일성 제약이 필수적인 경우
   - 파티션 키를 포함할 수 없는 자연 키 사용
   - 모든 파티션을 통틀어 빈번하게 검색되는 컬럼 존재

3. **글로벌 파티션 인덱스 고려:**
   - 전역 유일성과 병렬 처리 성능 모두 필요
   - 특정 인덱스의 핫스팟 경합이 문제인 경우
   - 파티션 단위 인덱스 관리가 가능한 운영 환경

### 인덱스 전략 매트릭스

| 시나리오 | 권장 인덱스 유형 | 추가 고려사항 |
|----------|-----------------|---------------|
| 날짜 범위 기반 리포트 | Prefixed 로컬 인덱스 | 파티션 프루닝 최적화 |
| 고객 중심 OLTP 조회 | Non-Prefixed 로컬 인덱스 | 조인 성능 최적화 |
| 전사적 유일성 제약 | 글로벌 비파티션 인덱스 | DDL 정책 필수 |
| 대량 데이터 적재 | 로컬 인덱스 + EXCHANGE | 배치 창구 최적화 |
| DW 집계 쿼리 | 로컬 Bitmap 인덱스 | 읽기 전용 환경 적합 |

### 설계 검증 체크리스트

1. **프루닝 효율성:** 쿼리가 파티션 키 조건을 효과적으로 사용하는가?
2. **인덱스 정합성:** 파티션 DDL 후 인덱스 상태가 어떻게 되는가?
3. **유일성 요구사항:** 테이블 전체 유일성이 필요한 컬럼이 있는가?
4. **운영 윈도우:** 인덱스 재구성을 위한 충분한 배치 시간이 있는가?
5. **성능 모니터링:** 인덱스 사용 통계를 수집하고 분석하는가?

---

## 흔한 문제와 해결 방안

### 문제 1: 파티션 키 없이 Prefixed 로컬 인덱스만 존재
**증상:** `PARTITION RANGE ALL` + 전체 인덱스 파티션 스캔
**해결:** Non-Prefixed 로컬 인덱스 추가 또는 글로벌 인덱스 고려

### 문제 2: 글로벌 인덱스 DDL 정책 없음
**증상:** 예기치 않은 `UNUSABLE` 상태로 서비스 장애
**해결:** DDL 정책 문서화 및 자동화 스크립트 구현

### 문제 3: 로컬 UNIQUE에 파티션 키 누락
**증상:** 인덱스 생성 실패 또는 논리적 오류
**해결:** 모든 로컬 UNIQUE 인덱스에 파티션 키 포함

### 문제 4: OLTP 환경에 Bitmap 인덱스 사용
**증상:** DML 성능 저하 및 락 경합 증가
**해결:** Bitmap 인덱스를 B-tree로 전환 또는 DW 전용으로 분리

### 문제 5: 파티션 통계 관리 소홀
**증상:** 최적화 기회 손실 및 잘못된 실행 계획
**해결:** 정기적인 파티션 단위 통계 수집 자동화

---

## 성능 검증을 위한 실측 루틴

모든 설계 결정은 실제 측정 데이터로 검증되어야 합니다.

### 1. 기준 성능 측정
```sql
-- 초기 상태 저장
CREATE GLOBAL TEMPORARY TABLE perf_baseline AS
SELECT sn.name, ms.value
FROM   v$mystat ms 
JOIN   v$statname sn ON sn.stat# = ms.stat#
WHERE  sn.name IN (
  'consistent gets',
  'physical reads',
  'physical writes',
  'session logical reads'
);
```

### 2. 쿼리 실행 및 플랜 분석
```sql
-- 대상 쿼리 실행
SELECT /*+ MONITOR */ 
       SUM(amount)
FROM   sales
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01'
AND    cust_id = 202;

-- 실측 플랜 확인 (가장 중요한 단계)
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL,NULL,
         'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'
));
```

### 3. 성능 지표 확인 포인트
- **프루닝 효율성:** `PSTART`/`PSTOP` 값으로 액세스한 파티션 범위 확인
- **인덱스 활용:** `INDEX RANGE SCAN` vs `INDEX FULL SCAN` 확인
- **I/O 효율:** `Buffers`와 `Reads` 값 비교
- **메모리 사용:** `PGA used`와 `TempSpc` 확인
- **실행 시간:** `A-Time` (실제 실행 시간) 확인

### 4. 변경 전후 비교
```sql
-- 성능 차이 분석
SELECT a.name,
       b.value - a.value AS delta,
       ROUND((b.value - a.value) / NULLIF(a.value, 0) * 100, 2) AS pct_change
FROM   perf_baseline a
JOIN   v$mystat b ON b.stat# = a.stat#
WHERE  a.name IN ('consistent gets', 'physical reads');
```

---

## 결론: 실전 적용을 위한 핵심 원칙

1. **로컬 인덱스를 기본으로 시작하라**
   - 파티션 테이블에서는 로컬 인덱스가 가장 안전하고 관리하기 쉬운 선택입니다.
   - Prefixed와 Non-Prefixed를 조합하여 다양한 액세스 패턴을 수용하세요.

2. **글로벌 인덱스는 신중하게 도입하라**
   - 필수적인 유일성 제약이 있을 때만 사용하고, 항상 DDL 정책을 수립하세요.
   - 글로벌 파티션 인덱스는 전역 유일성과 분산 성능이 모두 필요할 때 고려하세요.

3. **운영 정책을 사전에 수립하라**
   - 파티션 DDL 작업 시 인덱스 관리 정책을 명확히 정의하세요.
   - 정기적인 인덱스 상태 모니터링과 재구성 스케줄을 수립하세요.

4. **실제 데이터로 검증하라**
   - 모든 설계 결정은 실제 쿼리와 데이터로 성능을 측정하고 검증하세요.
   - 실행 계획과 성능 통계를 분석하는 습관을 들이세요.

5. **단순함을 유지하라**
   - 필요 이상의 복잡한 인덱스 구조는 유지보수 부담을 증가시킵니다.
   - 실제 사용 패턴을 분석하여 최소한의 효과적인 인덱스만 유지하세요.

인덱스 파티셔닝은 데이터베이스 성능과 운영 효율성에 직접적인 영향을 미치는 중요한 설계 결정입니다. 이 가이드의 원칙과 실습을 통해 실제 환경에 맞는 최적의 인덱스 전략을 수립할 수 있을 것입니다.