---
layout: post
title: DB 심화 - 인덱스 파티셔닝
date: 2025-11-24 20:25:23 +0900
category: DB 심화
---
# Oracle 인덱스 파티셔닝 (B-tree 중심, 11g+ 공통)

— **언제/무엇을 만들고, 무엇이 어떻게 빨라지는지**를 **실측으로 검증**하는 튜닝 관점의 정리

> 목표
> 1) 파티션 테이블에서 인덱스를 **로컬/글로벌로 어떻게 설계**해야 하는지
> 2) **Prefixed vs Non-Prefixed**가 **프루닝·Range Scan·조인**에 어떤 차이를 만드는지
> 3) 파티션 DDL(ADD/SPLIT/MERGE/TRUNCATE/EXCHANGE)과 인덱스의 **정합성/UNUSABLE/재빌드 정책**
> 4) 실습 SQL로 **플랜/통계(ALLSTATS LAST)**를 직접 확인하는 법
>
> 표준 가정
> - 인덱스는 **B-tree**(Bitmap은 필요한 곳에만 비교 언급)
> - 블록 크기 8KB, 11g 이상(12c/19c/21c에서도 큰 원리는 동일)
> - 파티션 키는 주로 **DATE RANGE**(월/일 단위)
>
> 실행 후 **실측 플랜**은 항상 이렇게 확인한다.
```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL,NULL,
         'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS +PEEKED_BINDS'
));
```

---

## 실습 공통 스키마(사용자가 준 스키마 + 검증용 보강)

아래 스키마는 그대로 쓰되, **검증이 잘 보이도록 데이터와 파티션을 조금 더 늘린 버전**을 함께 제공한다.
(당신이 준 버전으로도 동작한다.)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';

DROP TABLE sales PURGE;
CREATE TABLE sales (
  sales_id   NUMBER       NOT NULL,
  sales_dt   DATE         NOT NULL,
  cust_id    NUMBER       NOT NULL,
  region_cd  VARCHAR2(6)  NOT NULL,
  amount     NUMBER(12,2) NOT NULL,
  CONSTRAINT pk_sales PRIMARY KEY (sales_id)
)
PARTITION BY RANGE (sales_dt) (
  PARTITION p2025m01 VALUES LESS THAN (DATE '2025-02-01'),
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION p2025m03 VALUES LESS THAN (DATE '2025-04-01'),
  PARTITION p2025m04 VALUES LESS THAN (DATE '2025-05-01'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

DROP TABLE dim_customer PURGE;
CREATE TABLE dim_customer (
  cust_id      NUMBER PRIMARY KEY,
  region_group VARCHAR2(10),
  grade        VARCHAR2(10),
  active_yn    CHAR(1)
);

-- 샘플 차원
INSERT INTO dim_customer VALUES (101,'AMER','GOLD','Y');
INSERT INTO dim_customer VALUES (202,'EMEA','SILVER','Y');
INSERT INTO dim_customer VALUES (303,'AMER','BRONZE','N');

-- 팩트 샘플(각 파티션에 조금씩)
BEGIN
  FOR i IN 1..200000 LOOP
    INSERT INTO sales VALUES(
      i,
      DATE '2025-01-01' + MOD(i,140),           -- 1~5월에 걸치게
      CASE MOD(i,5000) WHEN 0 THEN 101 WHEN 1 THEN 202 ELSE 303 END,
      CASE MOD(i,4) WHEN 0 THEN 'US' WHEN 1 THEN 'DE' WHEN 2 THEN 'FR' ELSE 'UK' END,
      ROUND(DBMS_RANDOM.VALUE(10,5000),2)
    );
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_CUSTOMER', cascade=>TRUE);
END;
/
```

---

## 인덱스 파티셔닝의 본질: “프루닝 + 유지보수 + 병렬성”의 삼각형

파티션 테이블에서 인덱스를 파티셔닝하는 이유는 크게 3가지로 정리된다.

1. **프루닝(Partition Pruning)**
   - WHERE 절에 파티션 키 조건이 있으면 **테이블 파티션만 읽는다.**
   - 인덱스도 파티셔닝되어 있으면 **인덱스 파티션도 같이 프루닝**되어 I/O와 CPU가 같이 줄어든다.
2. **운영/유지보수(Manageability)**
   - “월별 데이터 Drop/Truncate/Split/Merge/Exchange” 같은 DDL이 잦은 테이블에서
     **인덱스 정합성 유지 비용**이 성능만큼 중요해진다.
3. **병렬성/경합 분산(Parallelism & Contention)**
   - 파티션 단위로 스캔·조인·집계가 나뉘어
     병렬 실행의 **자연스러운 분할 단위**가 된다.

> 즉, 인덱스 파티셔닝의 설계는
> **“우리 쿼리가 프루닝을 얼마나 잘 쓰는가?”**와
> **“우리 운영이 파티션 DDL을 얼마나 자주 하는가?”**로 결정된다.

---

## 인덱스 파티션 유형 3종(로컬 / 글로벌 비파티션 / 글로벌 파티션)

| 구분 | 대상 | 파티셔닝 여부 | 의미 | 운영 DDL 영향 |
|---|---|---|---|---|
| **로컬(Local Partitioned Index)** | **파티션 테이블** | 인덱스도 **테이블과 1:1로 같이 파티셔닝** | “파티션마다 인덱스 1개” | **파티션 DDL에 자동 정합**(기본값) |
| **글로벌 비파티션(Global Non-Partitioned Index, GNI)** | 파티션/비파티션 테이블 | **단일 인덱스 세그먼트** | 전 기간 유일성/범용 인덱스 | 파티션 DDL 시 **UNUSABLE 위험** |
| **글로벌 파티션(Global Partitioned Index, GPI)** | 주로 파티션 테이블 | 인덱스만 **독립적 파티셔닝** | 전역 유일성 + 파티션 분산 | 파티션 DDL 영향 받음(정책 필요) |

---

## 로컬(Local) 파티션 인덱스

### 정의와 특징

- **테이블 파티션과 인덱스 파티션이 1:1로 대응**
  → 각 파티션에 **별도 인덱스 세그먼트**가 생긴다.
- 테이블 파티션 DDL(ADD/SPLIT/MERGE/TRUNCATE/DROP/EXCHANGE)에 대해
  **로컬 인덱스가 자동으로 따라간다.**
- **현업의 기본 선택지**.
  (특별히 전역 유일성/전역 액세스 경로가 필요하지 않다면 로컬이 가장 안전)

---

### Prefixed vs Non-Prefixed 로컬

당신이 이미 적어둔 내용을 **실전 관점으로 더 확장**한다.

```sql
-- (A) Prefixed 로컬: 파티션 키가 리딩
CREATE INDEX sales_lix_pref
  ON sales(sales_dt, cust_id, amount) LOCAL;

-- (B) Non-Prefixed 로컬: 리딩이 조인키/조건키
CREATE INDEX sales_lix_nonpref
  ON sales(cust_id, sales_dt) LOCAL;
```

#### Prefixed 로컬이 강한 곳

- **파티션 키 조건이 단독/주요 조건일 때**
- **범위 조건(BETWEEN, >=/<)**이 파티션 키로 걸릴 때
- 인덱스 **Range Scan + 인덱스 파티션 프루닝**이 동시에 걸린다.

검증:

```sql
EXPLAIN PLAN FOR
SELECT /* prefixed best */
       SUM(amount)
FROM   sales
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
```

**기대 플랜 신호**
- `PARTITION RANGE SINGLE` 또는 `PARTITION RANGE ITERATOR`
- `INDEX RANGE SCAN sales_lix_pref`
- Access Predicate에 `sales_dt` 범위가 바로 들어감

#### Non-Prefixed 로컬이 강한 곳

- **조인키/고선택도 키(cust_id)** 중심 조회가 많을 때
- 스타 쿼리에서 Fact가 dimension 키로 먼저 줄어드는 패턴
- 단, `cust_id`만 있고 파티션키가 없으면 **여러 인덱스 파티션을 탐색**할 수도 있다.

검증:

```sql
EXPLAIN PLAN FOR
SELECT /* nonpref best */
       COUNT(*)
FROM   sales
WHERE  cust_id = 202;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
```

**기대 플랜 신호**
- `INDEX RANGE SCAN sales_lix_nonpref`
- 파티션 access가 `RANGE ALL`로 찍힐 수도 있음(파티션키가 없어서)

#### 둘 다 있는 실제 서비스 쿼리

```sql
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   sales
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01'
AND    cust_id = 202;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
```

- 이 케이스에선
  Prefixed/Non-Prefixed 모두 **좋은 플랜이 나오기 쉬움**
  (각각의 선두 컬럼 조건이 모두 있기 때문에)

---

### 로컬 UNIQUE 인덱스의 규칙(매우 중요)

로컬 인덱스는 **“파티션 내부 유일성”만 보장**한다.
즉,

- 파티션 키가 없는 UNIQUE 로컬은 **전 테이블 유일을 증명할 수 없다.**

```sql
-- (실패 예)
-- CREATE UNIQUE INDEX sales_u_bad ON sales(sales_id) LOCAL;

-- (성공 예)
CREATE UNIQUE INDEX sales_u_good
  ON sales(sales_id, sales_dt) LOCAL;
```

> **규칙**
> “로컬 UNIQUE(또는 로컬 PK) 인덱스는
> 반드시 **테이블 파티션 키를 인덱스 컬럼에 포함**해야 한다.”

---

### 로컬 인덱스의 파티션 DDL 자동 정합

```sql
-- 파티션 SPLIT
ALTER TABLE sales SPLIT PARTITION p2025m02 AT (DATE '2025-02-15')
  INTO (PARTITION p2025m02a, PARTITION p2025m02b);

-- 파티션 TRUNCATE
ALTER TABLE sales TRUNCATE PARTITION p2025m01;

-- 파티션 DROP
ALTER TABLE sales DROP PARTITION p2025m03;
```

**로컬 인덱스는 위 DDL 뒤에도 STATUS가 그대로 VALID**인 것이 정상이다.

확인:

```sql
SELECT index_name, partitioned, status
FROM   user_indexes
WHERE  table_name='SALES';
```

---

## 글로벌 비파티션 인덱스(GNI)

### 언제 필요한가?

- **전 기간(전 파티션) 유일성**이 필요할 때
- 파티션 키를 인덱스에 넣기 어려운 자연키가 존재할 때

예: 이미 PK로 생성된 전역 인덱스

```sql
DROP INDEX pk_sales;

CREATE UNIQUE INDEX pk_sales
  ON sales(sales_id);          -- 글로벌 비파티션

ALTER TABLE sales
  ADD CONSTRAINT pk_sales
  PRIMARY KEY (sales_id)
  USING INDEX pk_sales;
```

### 가장 큰 단점: UNUSABLE

파티션 테이블에 **글로벌 인덱스가 얹히면**,
파티션 DDL이 인덱스 전체 정합성을 깰 수 있다.

```sql
ALTER TABLE sales TRUNCATE PARTITION p2025m02;

SELECT index_name, status
FROM   user_indexes
WHERE  table_name='SALES';
```

- 종종 `UNUSABLE`이 뜬다.
- 즉시 유지하려면 DDL에 옵션을 줘야 한다.

```sql
ALTER TABLE sales TRUNCATE PARTITION p2025m02
  UPDATE GLOBAL INDEXES;
```

이 옵션은 **DDL 비용을 즉시 지불**하는 대신
인덱스를 계속 VALID로 유지한다.

### 사후 재빌드 정책

운영에서 흔한 패턴은

- 배치/점검 창구에서 **UNUSABLE을 감수**하고
- 사후에 ONLINE/병렬로 재빌드한다.

```sql
ALTER INDEX pk_sales REBUILD ONLINE PARALLEL 4;
ALTER INDEX pk_sales NOPARALLEL;
```

**정책이 없으면 글로벌 비파티션 인덱스는 운영 사고를 부른다.**

---

## 글로벌 파티션 인덱스(GPI)

### 왜 쓰나?

- 전역 유일성 + **인덱스 경합 분산**을 동시에 노릴 때
- **인덱스만 독립적으로 파티셔닝**해서
  핫스팟을 쪼개고 병렬성을 늘릴 때

### HASH 기반 GPI (cust_id 경합 분산)

```sql
CREATE INDEX sales_gpi_hash
  ON sales(cust_id, sales_dt)
  GLOBAL PARTITION BY HASH (cust_id)
  PARTITIONS 8;
```

**효과**
- `cust_id` 기반 OLTP 조회/조인이 많으면
  인덱스 루트/브랜치 경합이 **해시 파티션으로 나뉘어 완화**된다.

### RANGE 기반 GPI (전역 범위 유일/분산)

```sql
CREATE INDEX sales_gpi_range
  ON sales(amount, sales_dt)
  GLOBAL PARTITION BY RANGE (amount) (
    PARTITION gpa_low  VALUES LESS THAN (100),
    PARTITION gpa_mid  VALUES LESS THAN (1000),
    PARTITION gpa_high VALUES LESS THAN (MAXVALUE)
  );
```

### GPI도 테이블 DDL 영향을 받는다

- GPI는 파티션 DDL 후 **UNUSABLE 위험이 여전히 존재**한다.
- 다만 인덱스가 파티션화되어 있으므로
  **인덱스 파티션 단위로 재빌드/관리**가 가능하다.

```sql
ALTER INDEX sales_gpi_range REBUILD PARTITION gpa_mid;
ALTER INDEX sales_gpi_hash  COALESCE PARTITION;
```

---

## Prefixed vs Non-Prefixed (로컬/글로벌 공통 개념)

### 정의 재정리

- **Prefixed Index**
  인덱스 파티션 키(또는 테이블 파티션 키)가
  **인덱스 키의 리딩 컬럼에 연속적으로 포함**된 형태
- **Non-Prefixed Index**
  파티션 키가 **리딩에 오지 않거나** 중간/후단에 있는 형태

### 성능적 차이의 핵심

| 항목 | Prefixed | Non-Prefixed |
|---|---|---|
| 인덱스 파티션 프루닝 | 더 직접적/단순 | 가능하지만 조건 구조에 더 의존 |
| Range Scan | 파티션 키 범위 조건에 최적 | 리딩 컬럼 조건이 없으면 비효율 |
| 조인/스타쿼리 | 날짜 축 중심 모델에 강함 | 조인키 중심 모델에 강함 |
| 로컬 UNIQUE | 사실상 강제(e.g., sales_dt 포함) | 파티션 키 없으면 UNIQUE 불가 |

---

## 컴포지트(서브파티션) 테이블과 로컬 인덱스

### RANGE-HASH 테이블

```sql
DROP TABLE sales_rh PURGE;

CREATE TABLE sales_rh (
  sales_id NUMBER NOT NULL,
  sales_dt DATE   NOT NULL,
  cust_id  NUMBER NOT NULL,
  amount   NUMBER,
  CONSTRAINT pk_sales_rh PRIMARY KEY (sales_id)
)
PARTITION BY RANGE (sales_dt)
SUBPARTITION BY HASH (cust_id) SUBPARTITIONS 8
(
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION p2025m03 VALUES LESS THAN (DATE '2025-04-01'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

CREATE INDEX sales_rh_lix
  ON sales_rh(sales_dt, cust_id, amount)
  LOCAL;
```

### 프루닝이 2단으로 걸리는 모습을 보는 쿼리

```sql
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   sales_rh
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01'
AND    cust_id IN (101,202);

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
```

**기대**
- 상위 `PARTITION RANGE SINGLE`
- 하위 `SUBPARTITION HASH KEY` 등 서브파티션 프루닝 단서

---

## 파티션-와이즈 조인(Partition-Wise Join)과 인덱스 파티셔닝

### 개념

두 파티션 테이블이 **같은 파티션 키/기준**으로 파티셔닝되어 있고
조인 조건이 그 키를 활용할 때

- Oracle은 파티션끼리 1:1로 조인하는 **Partition-Wise Join**을 사용할 수 있다.
- 로컬 인덱스가 있을수록 최적화가 쉬워져
  **조인 단계 I/O를 파티션 단위로 줄인다.**

### 예시(간단 모형)

```sql
DROP TABLE refunds PURGE;

CREATE TABLE refunds (
  refund_id NUMBER,
  sales_dt  DATE,
  sales_id  NUMBER,
  amt       NUMBER
)
PARTITION BY RANGE (sales_dt) (
  PARTITION p2025m01 VALUES LESS THAN (DATE '2025-02-01'),
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION p2025m03 VALUES LESS THAN (DATE '2025-04-01'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

CREATE INDEX refunds_lix
  ON refunds(sales_dt, sales_id) LOCAL;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'REFUNDS',cascade=>TRUE);
END;
/

EXPLAIN PLAN FOR
SELECT /*+ USE_HASH(r) */
       SUM(s.amount - NVL(r.amt,0))
FROM   sales s
LEFT JOIN refunds r
  ON   r.sales_id = s.sales_id
 AND   r.sales_dt = s.sales_dt
WHERE  s.sales_dt BETWEEN DATE '2025-02-01' AND DATE '2025-03-31';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
```

**기대**
- 두 테이블이 동일한 RANGE 경계를 공유하면
  `PARTITION RANGE ITERATOR`가 양쪽에 걸리며
  각 파티션끼리 조인하는 모양으로 비용이 떨어진다.

---

## Bitmap 인덱스 파티셔닝(필요한 만큼만)

- Bitmap도 로컬/글로벌이 가능(버전에 따라 제약 있음).
- **저선택도 컬럼(예: region_cd, grade)**에 강함.
- 단, OLTP에서 DML이 잦으면
  - 한 행 업데이트가 **여러 비트맵 세그먼트에 파급**
  - TX 락 경합/리빌드 비용 증가
- 따라서
  - **DW/배치 적재 + 읽기 위주**: 로컬 Bitmap 강력
  - **OLTP 대량 DML**: Bitmap 지양, B-tree 사용

예(로컬 Bitmap):

```sql
CREATE BITMAP INDEX sales_bix_region
  ON sales(region_cd)
  LOCAL;
```

---

## 운영 DDL/정책 모음(실전에서 가장 사고가 잦은 영역)

### 로컬 인덱스 파티션 관리

```sql
ALTER INDEX sales_lix_pref REBUILD PARTITION p2025m02;
ALTER INDEX sales_lix_nonpref REBUILD PARTITION p2025m02;
```

- 로컬은 **파티션 단위 재빌드**가 가능해서
  운영 창구의 “핫 파티션만 리빌드” 같은 정책이 쉬움.

### 글로벌 인덱스의 상태 점검

```sql
SELECT index_name, status, partitioned
FROM   user_indexes
WHERE  table_name='SALES';

SELECT index_name, partition_name, status
FROM   user_ind_partitions
WHERE  index_name LIKE 'SALES_GPI%';
```

### 테이블 파티션 DDL 시 글로벌 인덱스 정책

- 즉시 유지(DDL 느려짐):
```sql
ALTER TABLE sales DROP PARTITION p2025m01 UPDATE GLOBAL INDEXES;
```

- 사후 유지(DDL 빠름, 재빌드 필요):
```sql
ALTER TABLE sales DROP PARTITION p2025m01;

ALTER INDEX pk_sales        REBUILD ONLINE;
ALTER INDEX sales_gpi_hash  REBUILD PARTITION <name>;
```

### EXCHANGE PARTITION + 로컬 인덱스

대량 적재에서 가장 많이 쓰는 패턴:

```sql
-- 1) 스테이징 테이블 준비(비파티션)
DROP TABLE sales_stg PURGE;
CREATE TABLE sales_stg AS SELECT * FROM sales WHERE 1=0;

-- 2) 스테이징에 대량 적재
-- INSERT /*+ APPEND */ INTO sales_stg ...

-- 3) 파티션 교체 (로컬 인덱스는 자동 정합)
ALTER TABLE sales EXCHANGE PARTITION p2025m04
  WITH TABLE sales_stg
  WITHOUT VALIDATION;
```

- 로컬 인덱스가 있어야 운영이 단순해진다.
- 글로벌 인덱스가 있으면 정책에 따라 UNUSABLE/갱신 고민이 들어온다.

---

## 설계 의사결정 매트릭스(현업용)

### 로컬 vs 글로벌

| 질문 | YES면 | NO면 |
|---|---|---|
| 파티션 DDL이 잦은가? | **로컬** 우선 | 글로벌도 고려 |
| 전 기간 유일성(자연키/PK)이 필요한가? | 글로벌(비파티션 or GPI) | 로컬로 충분 |
| 파티션 키 범위 조건이 대부분인가? | Prefixed 로컬 | Non-Prefixed 로컬 병행 |
| 조인키 중심 조회가 대부분인가? | Non-Prefixed 로컬 | Prefixed 로컬 |
| OLTP 대량 DML인가? | B-tree | Bitmap 지양 |
| DW/리포트 중심인가? | 로컬 + Bitmap 가능 | B-tree 중심 |

### Prefixed/Non-Prefixed 설계 규칙

1. **파티션 키(날짜) 범위 조건이 핵심이면 Prefixed를 최소 1개는 둔다.**
2. **조인키(차원 키) 기반 NL/HJ가 핵심이면 Non-Prefixed를 별도로 둔다.**
3. 인덱스가 과다해지면
   - 파티션 단위로 자주 쓰는 것만 남기고
   - “핫 파티션만 인덱싱(Partial Indexing)” 같은 정책을 고민한다.

---

## 흔한 함정과 교정

1. **파티션 키 조건이 없는데 Prefixed 로컬만 존재**
   - `PARTITION RANGE ALL` + 인덱스 파티션 전체 탐색
   - 해결: Non-Prefixed 로컬 추가 or 글로벌 인덱스 고려
2. **글로벌 인덱스 있는데 파티션 DDL 정책 없음**
   - 어느 순간 `UNUSABLE`로 서비스 장애
   - 해결: “UPDATE GLOBAL INDEXES vs Batch REBUILD” 정책 문서화
3. **로컬 UNIQUE에 파티션 키 누락**
   - 생성 자체가 실패하거나(버전별) 논리적으로 의미 없음
   - 해결: 파티션 키 포함
4. **Bitmap을 OLTP에 사용**
   - DML/락 경합으로 성능 폭발
   - 해결: Bitmap은 DW 전용으로 제한
5. **통계/히스토그램 없음**
   - 프루닝/조인 방향/액세스 경로 오판
   - 해결: 파티션 테이블은 **파티션 통계 + 글로벌 통계**를 주기적으로 유지

---

## 실측 검증 루틴(이 가이드의 핵심 “증거 기반 튜닝”)

아래 순서로 보면 “무엇이 어떻게 빨라졌는지”가 숫자로 보인다.

1. 쿼리 실행
2. **실측 플랜 확인**
```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL,NULL,
         'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'
));
```
3. 확인 포인트
   - `PSTART/PSTOP` (프루닝 범위)
   - 인덱스 액세스(`INDEX RANGE SCAN`, `INDEX FULL SCAN`)
   - `Buffers` / `Reads` / `TempSpc` / `PGA used`
   - Stopkey(Top-N) 여부

---

## 한 페이지 요약

- **로컬 인덱스(Local)**
  - 파티션 테이블의 기본값
  - 프루닝·병렬·유지보수 최강
  - 로컬 UNIQUE는 **파티션 키 포함 필수**
- **글로벌 비파티션(GNI)**
  - 전 기간 유일/전역 키 조회에 필요
  - 파티션 DDL 후 **UNUSABLE 위험 → 정책 필수**
- **글로벌 파티션(GPI)**
  - 전역 유일 + 경합/병렬 분산
  - 역시 파티션 DDL 영향 → 파티션 단위 재빌드/COALESCE로 운영
- **Prefixed vs Non-Prefixed**
  - Prefixed: 파티션 키 범위/프루닝/Range Scan에 강함
  - Non-Prefixed: 조인키/차원키 중심 조회에 강함
  - 실무에선 **둘을 전략적으로 공존**시키는 경우가 많다.
