---
layout: post
title: 웹해킹 - CSRF
date: 2025-09-24 17:25:23 +0900
category: 웹해킹
---
# CSRF (Cross-Site Request Forgery)

## 한눈에 보는 요지

- **CSRF**는 *사용자 브라우저가 가진 신뢰*를 악용해, 공격자 사이트에서 **희생자 브라우저로 타겟 사이트에 요청을 보내게** 만드는 공격입니다. 브라우저는 **쿠키/자격증명**(세션 쿠키 등)을 자동으로 첨부하기 때문에, 서버가 **정상 사용자의 요청**으로 오인합니다.
- **최신 방어의 골자**
  1) **CSRF 토큰**(동기화 토큰/더블 서브밋 등) — *주 방어 수단*으로 권장, 프레임워크 기본 기능을 우선 사용.
  2) **SameSite 쿠키** — 쿠키의 **교차 사이트 전송 제어**(기본 Lax), 단독 방어가 아니라 **방어 심화(Defense-in-Depth)**로 활용.
  3) **Origin/Referer 검증**, **Fetch Metadata(`Sec-Fetch-Site` 등)** — 정책 레벨의 **선 차단**.

---

## CSRF의 **원리** (브라우저의 “자동성” 악용)

### 기본 메커니즘

1) 사용자는 `bank.example`에 로그인(브라우저에 **세션 쿠키** 저장).
2) 공격자 페이지(`evil.example`) 방문 → **자동 전송 폼/이미지** 등으로 `bank.example`에 **상태 변경 요청**을 보냄.
3) 브라우저는 **같은 사이트로 인지**되는 경우 쿠키를 함께 첨부 → 서버는 **정상 사용자** 요청으로 처리.

### 간단한 공격 예(교육용)

```html
<!-- 공격자 페이지(POST 자동 전송) -->
<form action="https://bank.example/transfer" method="POST" id="f">
  <input type="hidden" name="to" value="attacker">
  <input type="hidden" name="amount" value="1000000">
</form>
<script>document.getElementById('f').submit()</script>
```
또는 **GET을 상태 변경에 오용**하는 사이트라면 단순 이미지 태그만으로도 가능:
```html
<img src="https://bank.example/transfer?to=attacker&amount=1000000">
```
> CSRF는 **상태 변경 요청**(송금, 비번 변경 등)을 노립니다. 데이터 조회만으로는 공격자 이득이 작지만, **로그인 CSRF** 같이 특수 케이스도 존재합니다.

---

## **오해 바로잡기** — 무엇이 CSRF를 못 막는가

- **CORS만 믿기**: CORS는 “응답 접근”을 제한합니다. 요청 자체는 전송될 수 있고, *그 자체로 상태 변경*을 일으킬 수 있습니다. **토큰/정책 기반** 대책이 필요합니다.
- **Content-Type 강제만으로 충분?**: `application/json`만 허용해도, 잘못 구성하면 우회 여지가 있습니다. “커스텀 헤더 요구 + CORS 미허용”을 함께 써야 효과가 납니다(§4.4).
- **XSS 방어 = CSRF 방어**가 아닙니다. 서로 다른 문제입니다(상호 보완 필요).

---

## **SameSite 쿠키** — 브라우저에 “교차 사이트 쿠키 전송 금지”를 시키기

### 동작 요약

- **SameSite=Strict**: *항상* 교차 사이트 요청에 쿠키 미전송.
- **SameSite=Lax**: **Top-level GET 네비게이션** 같은 제한적 경우에만 전송, 그 외 교차 사이트 요청에는 미전송(POST에는 기본 불전송).
- **SameSite=None; Secure**: **모든 컨텍스트 전송 허용**, 단 **반드시 Secure** 필요(HTTPS 전용).

> 2020+ **기본값 Lax**가 광범위 브라우저에 적용(“Lax-by-default”). Chrome은 일부 호환성 위해 **“Lax+POST” 2분 예외** 개입을 운영(짧은 시간 내 발생한 로그인 등). 설계 시 이를 고려하세요.

### 설정 예(서버)

```javascript
// Express: 세션 쿠키 예시
res.cookie("sid", sessionId, {
  httpOnly: true,
  secure: true,           // HTTPS
  sameSite: "Lax",        // 기본 Lax 권장
  path: "/",
  maxAge: 15 * 60 * 1000
});
```
```python
# Flask

resp.set_cookie("sid", sid, httponly=True, secure=True, samesite="Lax", path="/")
```
```java
// Spring Boot (application.yml)
server:
  servlet:
    session:
      cookie:
        secure: true
        http-only: true
        same-site: Lax
```
> **주의**: 교차 사이트 동작(임베디드 위젯/3rd-party 로그인 등)이 필요하면 해당 쿠키를 **SameSite=None; Secure**로 별도 분리. 기본 세션은 Lax/Strict 유지가 안전합니다.

---

## **CSRF 토큰** — “의도한 사용자 요청”임을 증명

> OWASP는 **토큰 기반 방어를 주 방어 수단**으로 권장합니다(상태풀=동기화 토큰, 스테이트리스=더블 서브밋 등). SameSite/Origin/Fetch-Metadata는 **보강책**으로 병행하세요.

### 동기화 토큰 패턴(Synchronizer Token, **상태풀**)

- 서버가 사용자 세션에 난수 토큰을 저장하고 **폼/페이지에 숨겨 넣어** 보냄 → 요청 시 제출된 토큰과 **세션의 토큰을 비교**.
- **토큰을 URL에 두지 말 것**(로그/히스토리/Referer로 누출). **쿠키로 동기화 토큰을 보내지 말라**(세션 토큰과 혼동, OWASP 권고).

#### Express(직접 구현 예)

{% raw %}
```javascript
// utils/csrf.js
import crypto from "node:crypto";
export function issueCsrf(req, res) {
  const t = crypto.randomBytes(32).toString("hex");
  req.session.csrf = t; // 세션에 저장
  res.locals.csrfToken = t; // 템플릿/메타로 전달
}
export function verifyCsrf(req, res, next) {
  const token = req.body._csrf || req.get("X-CSRF-Token");
  if (!token || token !== req.session.csrf) return res.sendStatus(403);
  next();
}

// 폼 렌더링
app.get("/transfer", (req, res) => { issueCsrf(req, res); res.render("transfer"); });

// 폼 템플릿 (Pug/Jinja류: 자동 이스케이프)
<form method="POST">
  <input type="hidden" name="_csrf" value="{{ csrfToken }}">
  ...
</form>

// 처리
app.post("/transfer", verifyCsrf, (req, res) => { /* 정상 처리 */ });
```
{% endraw %}

#### Django(기본 내장)

{% raw %}
```html
<!-- 템플릿 -->
<form method="post">{% csrf_token %} ... </form>
```
{% endraw %}
```python
# 미들웨어/설정은 기본 활성. 자세 동작은 공식 문서 참고.

```
Django는 **CSRF 쿠키(임의 비밀값)** + **폼 히든필드**를 조합해 검증합니다.

#### Spring Security(기본 활성)

```java
// 보통 추가 코드 불필요. 설정 명시 예:
http.csrf(csrf -> csrf.ignoringRequestMatchers("/webhook/**")); // 특정 경로 제외 등
```
Spring은 **안전하지 않은 메서드(POST/PUT/DELETE 등)**에 기본 CSRF 방어를 적용합니다.

#### Flask-WTF(간단)

{% raw %}
```python
from flask_wtf.csrf import CSRFProtect
csrf = CSRFProtect(app)  # 전역 활성
# 템플릿에서 {{ form.csrf_token }} 또는 AJAX 헤더로 X-CSRFToken 사용

```
{% endraw %}


### 더블 서브밋 쿠키(Double-Submit Cookie, **스테이트리스**)

- 서버가 **CSRF 토큰을 별도 쿠키**로 발급(일반적으로 **HttpOnly=false**, SameSite=Lax/Strict)하고, 프론트는 **폼 필드/커스텀 헤더**로 **동일 값**을 보냅니다. 서버는 **쿠키값 == 제출값** 비교. 세션 저장 없이 검증 가능.
- 실무에선 **동기화 토큰을 우선** 권장하되, **세션리스 API** 등에 한해 더블 서브밋을 고려합니다.

```javascript
// 예: 초기 HTML에 <meta name="csrf-token" content="...">를 주입하거나,
//     "csrf" 쿠키를 읽어 헤더에 첨부(단, HttpOnly=false여야 읽힘)
fetch("/api/transfer", {
  method: "POST",
  headers: { "X-CSRF-Token": readCsrfFromCookieOrMeta() },
  body: JSON.stringify({ to, amount })
});
```

> **토큰 강도**: 난수 길이가 \(L\), 문자공간 크기가 \(N\)이면 대략
> $$ H \approx L \cdot \log_2 N \ \text{(bits)} $$
> 실무에선 **32바이트(256비트) 이상**의 CSPRNG 토큰을 권장합니다.

### AJAX/SPA 패턴(메타 태그 + 헤더)

초기 HTML 렌더링 시 서버가 토큰을 `<meta name="csrf-token">`로 삽입 → 프런트가 이를 읽어 `X-CSRF-Token` 헤더로 보냄. **세션 토큰과 값 일치 여부**를 서버에서 확인합니다(또는 더블 서브밋 구조).

### “커스텀 헤더 필요 + CORS 미허용” 병행

- **교차 사이트 XHR/Fetch**는 **커스텀 헤더**가 있으면 **프리플라이트(OPTIONS)**가 발생; 서버가 허용하지 않으면 **본 요청 자체가 가지 않음** → **CSRF 억제**에 도움.
- 단독 대책이 아닌 **토큰과 병행**이 바람직합니다.

---

## **Origin/Referer 검증** & **Fetch Metadata** — 정책으로 **먼저** 걸러내기

### Origin/Referer

- **Origin**: JS에서 임의 조작 불가한 **금지 헤더**로, 주로 **비 GET** 요청에서 신뢰성 있게 옵니다. 화이트리스트(`https://app.example`)와 **정확 매칭** 권장. 일부 환경에서 누락될 수 있으므로 **토큰과 병행**.
- **Referer**: 개인정보 보호 기능·프록시로 **없거나 축약**될 수 있어 **보조 지표**로만. OWASP는 **토큰 우선**을 권고합니다.

**Express 미들웨어 예**
```javascript
function checkOrigin(req, res, next) {
  const origin = req.get("Origin");
  const allowed = new Set(["https://app.example"]);
  if (origin && !allowed.has(origin)) return res.sendStatus(403);
  next();
}
```

### Fetch Metadata (`Sec-Fetch-Site`, `Sec-Fetch-Mode`, `Sec-Fetch-Dest`)

브라우저가 요청의 **컨텍스트**를 헤더로 제공 → 서버는 `Sec-Fetch-Site: cross-site` 같은 **교차 사이트 요청을 기본 차단** 가능. **정적 자산/파비콘** 등 예외만 허용하는 **리소스 격리 정책**을 쉽게 구성할 수 있습니다.

**예: 간단 거부 로직**
```javascript
function fetchMetadataGuard(req, res, next) {
  const s = req.get("Sec-Fetch-Site");
  if (s && (s === "cross-site" || s === "none")) {
    // 크로스 사이트(또는 브라우저 UI 출처) 요청은 상태 변경 라우트에서 거부
    return res.sendStatus(403);
  }
  next();
}
```

> **권장 조합**: **CSRF 토큰(주 방어)** + **SameSite** + **Origin/Fetch-Metadata** = **다층 방어**. 최신 문서도 이 **레이어드 접근**을 권합니다.

---

## **프레임워크별** 실전 구성

### Django

{% raw %}
```html
<!-- 템플릿 -->
<form method="post">{% csrf_token %} ... </form>
```
{% endraw %}
```python
# settings.py (기본 활성이며, 중간에 비활성화하지 말 것)

MIDDLEWARE = [
  "django.middleware.csrf.CsrfViewMiddleware",
  ...
]
```
동작: **CSRF 쿠키(랜덤 비밀)** + **폼 히든 필드** 비교. SPA에선 `X-CSRFToken` 헤더 사용 가능.

### Spring Security

```java
// 보통 기본 활성. 필요시 세부 조정:
@Bean
SecurityFilterChain filter(HttpSecurity http) throws Exception {
  http
    .csrf(csrf -> csrf
      .ignoringRequestMatchers("/webhook/**")   // 외부 시스템 콜백
    );
  return http.build();
}
```
Spring은 **상태 변경 메소드** 보호를 기본 제공합니다. 템플릿/Thymeleaf는 토큰 자동 삽입 가능.

### Flask (Flask-WTF)

{% raw %}
```python
from flask_wtf.csrf import CSRFProtect
csrf = CSRFProtect(app)             # 전역 활성
# 폼: {{ form.csrf_token }} , AJAX: X-CSRFToken 헤더

```
{% endraw %}


### React/Vue/SPA(메타 태그 + 헤더)

{% raw %}
```html
<!-- 서버가 초기 HTML에 삽입 -->
<meta name="csrf-token" content="{{ csrfToken }}">
```
{% endraw %}
```ts
// 프런트 공통 요청 유틸
const token = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '';
export async function api(url: string, options: RequestInit = {}) {
  const headers = new Headers(options.headers || {});
  headers.set('X-CSRF-Token', token);
  headers.set('Content-Type', 'application/json');
  return fetch(url, { ...options, method: options.method || 'POST', headers, credentials: 'include' });
}
```

---

## **케이스 스터디** — 구성/오류/공격 전개/수정 레시피

### 폼 기반 송금(Stored Session, 서버 렌더링)

**취약 코드**
```python
# Flask: CSRF 없음

@app.post("/transfer")
def transfer():
    to = request.form["to"]; amount = request.form["amount"]
    do_transfer(current_user.id, to, amount); return "ok"
```
**공격 페이지**: 자동 폼 제출로 송금.
**수정**
{% raw %}
```python
# 전역 CSRF 활성 (Flask-WTF)

csrf = CSRFProtect(app)

# 템플릿 폼에 {{ form.csrf_token }} 또는 <input name="_csrf" ...>

```
{% endraw %}


### JSON API + SPA

- 요구사항: API는 **JSON**만 받고, 클라이언트는 **커스텀 헤더**를 항상 보냄.
- 방어: **동기화 토큰 + X-CSRF-Token** + **CORS 미허용**(3rd-party 도메인) + **Fetch Metadata**.
- 결과: 교차 사이트 폼/이미지는 JSON이나 커스텀 헤더를 **전송 불가** → **프리플라이트에서 차단**.

### OAuth/OIDC 로그인 흐름과 SameSite

- 서드파티 로그인·위젯은 **SameSite=None; Secure** 쿠키가 필요할 수 있습니다(기본 Lax/Strict는 끊김). 흩어진 쿠키/플로우를 **분리 관리**하고, **상태 파라미터/PKCE** 등 **프로토콜 보안**과 함께 점검하세요.

---

## **토큰 운용 베스트 프랙티스**

- **수명/재발급**: 토큰은 **세션 수명**과 연동. **요청당 토큰**(회전)도 가능(UX/캐시 고려).
- **전달 위치**: **숨은 필드**(서버 렌더링), **헤더**(AJAX). **URL 금지**.
- **유출 방지**: 로그/Analytics/Referer로 새나가지 않게 **헤더/바디로만** 전달.
- **무결성**: 스테이트리스 토큰은 **서명/HMAC**으로 위변조 방지.

---

## **서버 정책 미들웨어** — 실용 예제(Express)

```javascript
import helmet from "helmet";
app.use(helmet()); // 보안 헤더 기본

// 1) SameSite + Secure + HttpOnly 세션
app.use(session({ /* cookie: { sameSite: 'Lax', secure: true, httpOnly: true } */ }));

// 2) Origin 화이트리스트
app.use((req, res, next) => {
  const o = req.get("Origin");
  if (o && o !== "https://app.example") return res.sendStatus(403);
  next();
});

// 3) Fetch Metadata 기반 차단
app.use((req, res, next) => {
  const s = req.get("Sec-Fetch-Site");
  const m = req.get("Sec-Fetch-Mode");
  if (s === "cross-site" && m !== "navigate") return res.sendStatus(403); // 단순 탐색만 허용
  next();
});

// 4) CSRF 토큰 검증(주 방어)
app.post("/api/*", verifyCsrf);
```


---

## **테스트/점검** 체크리스트

### 스모크 시나리오(개발/QA 전용)

1) **공격 폼 페이지**에서 대상 앱의 **POST 엔드포인트**를 자동 제출 → **403/실패**여야 정상(토큰 미비).
2) **교차 사이트 JSON+커스텀 헤더** 요청 시 **프리플라이트 실패**로 본 요청 불발.
3) **`Sec-Fetch-Site: cross-site`** 로 오는 요청이 **정책에서 차단**되는지 로그 확인.

### 점검 가이드

- OWASP WSTG의 **CSRF 테스트 항목**으로 케이스 정리.
- 브라우저 콘솔에서 **쿠키 SameSite**와 **Secure/HttpOnly** 속성 점검.
- 로그인·결제·프로필 변경 등 **핵심 플로우**에 **재인증/일회용 토큰** 추가(고위험 작업).

---

## **자주 하는 실수 & 대안**

- **오직 SameSite만** 쓰기 → 브라우저/플로우/호환성 편차(예: “Lax+POST” 개입, 서드파티 로그인)로 빈틈. **토큰 병행**이 안전합니다.
- **토큰을 쿠키로만** 주고 끝내기 → **동기화 토큰**은 **서버 세션에 저장**해서 비교하세요(쿠키만 쓰면 더블 서브밋 패턴이고, 서명/검증 로직 필요).
- **URL에 토큰** → 로그/히스토리/Referer로 **누출 위험**. **절대 금지**.
- **GET으로 상태 변경** → 브라우저 프리미티브로 **손쉽게 트리거**됨. **POST/PUT/DELETE**로 설계하고 **토큰 필수**.

---

## **요약**

- CSRF는 **브라우저의 자동 자격증명 전송**을 악용합니다.
- **주 방어 수단**: **CSRF 토큰**(프레임워크 기본 기능 활용).
- **보강**: **SameSite 쿠키**, **Origin/Referer 검증**, **Fetch Metadata** **조합**.
- **SPA/API**: 메타 태그/헤더 기반 토큰 + **커스텀 헤더 요구** + **CORS 미허용**으로 **요청 자체를 막기**.
- **설계 원칙**: **상태 변경은 토큰·정책으로 보호**, **토큰은 URL 금지**, **쿠키 속성은 보수적**(Secure/HttpOnly/SameSite).
  최신 브라우저 동작(기본 Lax, `None; Secure` 요건, Lax+POST 개입)을 이해하고 적용하세요.
