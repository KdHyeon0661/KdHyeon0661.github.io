---
layout: post
title: flask - 템플릿 & 정적 리소스
date: 2025-09-16 14:25:23 +0900
category: flask
---
# 2. 템플릿 & 정적 리소스

## 2.1 Jinja2 기본 문법 한 눈에

Jinja2는 **표현식/제어구문/주석** 세 가지 구역이 핵심이다.

- **변수 출력**: {% raw %}`{{ ... }}`{% endraw %}
- **제어 구조**: {% raw %}`{% ... %}`{% endraw %} (`if`, `for`, `block`, `extends` 등)  
- **주석**: `{# ... #}`

{% raw %}
```html
<!-- templates/hello.html -->
<!doctype html>
<html lang="ko">
  <head><meta charset="utf-8"><title>Hello</title></head>
  <body>
    <h1>{{ user.name }}님, 환영합니다!</h1>
    {% if user.is_admin %}
      <p>관리자 권한으로 로그인했습니다.</p>
    {% else %}
      <p>일반 사용자입니다.</p>
    {% endif %}

    <ul>
    {% for item in items %}
      <li>{{ loop.index }}. {{ item|e }}</li>  {# loop.index는 1부터 시작 #}
    {% else %}
      <li>항목이 없습니다.</li>
    {% endfor %}
    </ul>
  </body>
</html>
```
{% endraw %}

```python
# app/blueprints/site/views.py
from flask import Blueprint, render_template

site_bp = Blueprint("site", __name__)

@site_bp.get("/hello")
def hello():
    user = {"name": "Alice", "is_admin": False}
    items = ["사과", "배", "<스크립트>"]
    return render_template("hello.html", user=user, items=items)
```

**안전성**: Jinja2는 **자동 이스케이프**가 기본. `|e`는 명시적 이스케이프, `|safe`는 HTML 신뢰 시 사용(주의).

---

## 2.2 템플릿 상속 — 공통 레이아웃/블록 구조

**상속**은 중복 제거의 핵심. `base.html`에서 공통 레이아웃과 **블록**을 정의한다.

{% raw %}
```html
<!-- templates/base.html -->
<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <title>{% block title %}기본 타이틀{% endblock %}</title>
    {% block head_meta %}{% endblock %}
    <link rel="stylesheet" href="{{ asset_url('css/app.css') }}">
    {% block head_css %}{% endblock %}
  </head>
  <body>
    <header>
      <a href="{{ url_for('site.home') }}">홈</a>
      {% block header %}{% endblock %}
    </header>

    <main class="container">
      {% block content %}{% endblock %}
    </main>

    <script src="{{ asset_url('js/app.js') }}" defer></script>
    {% block body_js %}{% endblock %}
  </body>
</html>
```
{% endraw %}

자식 템플릿:

{% raw %}
```html
<!-- templates/page/dashboard.html -->
{% extends "base.html" %}
{% block title %}대시보드{% endblock %}
{% block content %}
  <h1>대시보드</h1>
  <p>최근 알림: {{ notifications|length }}건</p>
{% endblock %}
```
{% endraw %}

```python
# app/blueprints/site/views.py
@site_bp.get("/")
def home():
    notifications = ["새 댓글 3건", "결제 완료 1건"]
    return render_template("page/dashboard.html", notifications=notifications)
```

**{% raw %}`{{ super() }}`{% endraw %}**: 블록에서 부모 내용도 유지하고 싶을 때 사용.

{% raw %}
```html
{% block head_css %}
  {{ super() }}
  <link rel="stylesheet" href="{{ asset_url('css/dashboard.css') }}">
{% endblock %}
```
{% endraw %}

---

## 2.3 include vs import — 부분 템플릿 & 매크로

### 2.3.1 `include`로 부분 템플릿 삽입

{% raw %}
```html
<!-- templates/partials/_nav.html -->
<nav>
  <a href="{{ url_for('site.home') }}" aria-current="{{ 'page' if active=='home' else 'false' }}">Home</a>
  <a href="{{ url_for('site.about') }}" aria-current="{{ 'page' if active=='about' else 'false' }}">About</a>
</nav>
```
{% endraw %}

{% raw %}
```html
<!-- templates/page/about.html -->
{% extends "base.html" %}
{% block content %}
  {% include "partials/_nav.html" with context %}
  <h2>About</h2>
{% endblock %}
```
{% endraw %}

`with context`는 현재 컨텍스트를 포함시킨다(생략해도 기본은 포함).

### 2.3.2 `import`/`from ... import`로 매크로 사용

**매크로**는 컴포넌트화의 핵심. 재사용 가능한 HTML 청크를 함수처럼 만든다.

{% raw %}
```html
<!-- templates/macros/forms.html -->
{% macro input_text(name, value='', label='', placeholder='', error=None) -%}
<div class="field">
  <label for="{{ name }}">{{ label or name|capitalize }}</label>
  <input id="{{ name }}" name="{{ name }}" type="text" value="{{ value|e }}" placeholder="{{ placeholder|e }}">
  {% if error %}<p class="error">{{ error }}</p>{% endif %}
</div>
{%- endmacro %}
```
{% endraw %}

사용:

{% raw %}
```html
{% extends "base.html" %}
{% import "macros/forms.html" as F %}

{% block content %}
  <form method="post" action="{{ url_for('site.profile_update') }}">
    {{ F.input_text('username', value=user.username, label='사용자명', error=errors.username) }}
    {{ F.input_text('email', value=user.email, label='이메일', error=errors.email) }}
    <button type="submit">저장</button>
  </form>
{% endblock %}
```
{% endraw %}

**`call` 블록**: 매크로에 **슬롯**(children) 전달.

{% raw %}
```html
<!-- templates/macros/panel.html -->
{% macro panel(title) -%}
  <section class="panel">
    <h3>{{ title }}</h3>
    <div class="panel-body">
      {{ caller() }}
    </div>
  </section>
{%- endmacro %}
```
{% endraw %}

{% raw %}
```html
{% from "macros/panel.html" import panel %}
{% call panel("공지사항") %}
  <ul>
    {% for n in notices %}<li>{{ n }}</li>{% endfor %}
  </ul>
{% endcall %}
```
{% endraw %}

---

## 2.4 필터/테스트 — 내장 + 커스텀

### 2.4.1 내장 필터 스냅샷

- 문자열: `e`(escape), `safe`, `truncate`, `replace`, `upper/lower`, `title`, `capitalize`  
- 리스트/시퀀스: `length`, `join`, `first/last`, `unique`, `sort`, `select`, `reject`  
- 날짜/시간(보통 커스텀/확장 사용)  
- JSON: `tojson`(JS에 안전하게 렌더링)

{% raw %}
```html
<script>
  const data = {{ items|tojson }};
</script>
```
{% endraw %}

### 2.4.2 커스텀 필터 등록

```python
# app/templating.py
from datetime import datetime, timezone
from flask import Flask

def datetime_ko(dt: datetime) -> str:
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    local = dt.astimezone(timezone.utc)  # 예시: 실제로는 Asia/Seoul로
    return local.strftime("%Y-%m-%d %H:%M")

def register_jinja_filters(app: Flask) -> None:
    app.jinja_env.filters["datetime_ko"] = datetime_ko
```

```python
# app/__init__.py
from .templating import register_jinja_filters

def create_app(config=None):
    app = Flask(__name__)
    register_jinja_filters(app)
    ...
    return app
```

{% raw %}
```html
<p>작성일: {{ post.created_at|datetime_ko }}</p>
```
{% endraw %}

### 2.4.3 테스트(conditions)

{% raw %}
```html
{% if user.email is defined and user.email is string %}
  이메일: {{ user.email }}
{% endif %}
```
{% endraw %}

**사용 예**: `is number`, `is string`, `is defined`, `is iterable`, `is mapping` 등.

---

## 2.5 컨텍스트 프로세서 — 모든 템플릿에 공통 값/함수 주입

컨텍스트 프로세서는 **모든 템플릿에서 자동으로 접근 가능한 전역**을 추가한다.

```python
# app/context.py
from flask import Flask, request, url_for, current_app

def register_context_processors(app: Flask) -> None:
    @app.context_processor
    def inject_globals():
        return {
            "app_name": "FlaskBlog",
            "current_path": request.path,
            "asset_url": lambda filename: asset_url(app=current_app, filename=filename),
        }
```

`asset_url`은 아래 **정적 파일 버전닝**에서 구현한다. 컨텍스트 프로세서로 주입해 **템플릿 어디에서나** {% raw %}`{{ asset_url('css/app.css') }}`{% endraw %} 사용 가능하게 만든다.

---

## 2.6 국제화(i18n)·지역화(l10n) 메모(간단)

문자열은 **템플릿에서 번역 함수**로 감싼다(예: Flask-Babel).

{% raw %}
```html
<h1>{{ _("대시보드") }}</h1>
<p>{{ ngettext("%(num)d건의 알림", "%(num)d건의 알림", count) }}</p>
```
{% endraw %}

> 상세 i18n 설정/번역 워크플로우는 별도 장에서 다룬다.

---

## 2.7 안전한 렌더링 — XSS/Autoescape/`safe` 사용 원칙

- 기본은 **autoescape on**.  
- 신뢰 가능한 HTML에만 `|safe` 사용.  
- 사용자 입력을 다시 뿌릴 땐 **무조건 이스케이프**.  
- JSON을 스크립트로 출력할 땐 `|tojson` 사용(문자열 이스케이프 안전).

{% raw %}
```html
<div class="content">{{ user_input }}</div>             {# 안전 #}
<div class="content">{{ user_input|safe }}</div>        {# 위험 — 검증 없이 금지 #}
```
{% endraw %}

---

## 2.8 정적 파일 서빙 — 기본/구조/블루프린트별 정적

Flask는 `static_folder`(기본: `<app_root>/static`)를 `/static`으로 제공한다.

```
app/
├─ static/
│  ├─ css/app.css
│  └─ js/app.js
└─ templates/...
```

{% raw %}
```html
<link rel="stylesheet" href="{{ url_for('static', filename='css/app.css') }}">
<script src="{{ url_for('static', filename='js/app.js') }}" defer></script>
```
{% endraw %}

블루프린트별 정적:

```python
site_bp = Blueprint(
    "site", __name__,
    static_folder="static",
    static_url_path="/site-static",
    template_folder="templates",
)
```

{% raw %}
```html
<link rel="stylesheet" href="{{ url_for('site.static', filename='css/site.css') }}">
```
{% endraw %}

---

## 2.9 정적 파일 **버전닝(캐시버스팅)** — 운영 필수

브라우저/프록시는 정적 파일을 **오래 캐시**하도록 하고, 파일 내용이 바뀌면 **URL이 바뀌게** 해야 한다.

### 2.9.1 간단한 쿼리스트링 버전(해시)

**원리**: 파일 내용 해시를 쿼리(`?v=...`)로 붙인다 → 변경 시 URL 변경 → 캐시 무효.

```python
# app/assets.py
import hashlib
from pathlib import Path
from functools import lru_cache
from flask import current_app, url_for

STATIC_ROOT = Path(__file__).resolve().parent / "static"

@lru_cache(maxsize=1024)
def _file_hash(relpath: str) -> str:
    path = STATIC_ROOT / relpath
    data = path.read_bytes()
    return hashlib.md5(data).hexdigest()[:10]

def asset_url(filename: str, app=None) -> str:
    # 템플릿에서 컨텍스트 프로세서로 주입해 사용
    h = _file_hash(filename)
    return url_for("static", filename=filename, v=h)
```

컨텍스트 프로세서에서 공개:

```python
# app/context.py (앞서 본 예시에서 import하여 사용)
from .assets import asset_url
```

템플릿:

{% raw %}
```html
<link rel="stylesheet" href="{{ asset_url('css/app.css') }}">
<script src="{{ asset_url('js/app.js') }}" defer></script>
```
{% endraw %}

**장점**: 간단/의존성 없음.  
**주의**: 파일 수가 많으면 초기 해시 계산 비용 → `lru_cache`로 완화. 빌드 단계에서 **매니페스트** 생성이 더 효율적(아래).

### 2.9.2 매니페스트 기반(빌드 툴 연동: Vite/Webpack/Rollup)

**원리**: 빌드 시 파일명에 **content hash**를 포함(`app.3f2a1c.css`). 원본→산출물 매핑을 JSON으로 제공.

예시 `manifest.json`:

```json
{
  "css/app.css": "css/app.3f2a1c.css",
  "js/app.js": "js/app.a91bcd.js"
}
```

파이썬에서 매핑:

```python
# app/assets.py (manifest 모드)
import json
from pathlib import Path
from flask import url_for

MANIFEST_PATH = Path(__file__).resolve().parent / "static" / "manifest.json"
_manifest = None

def load_manifest():
    global _manifest
    if _manifest is None:
        _manifest = json.loads(MANIFEST_PATH.read_text(encoding="utf-8"))
    return _manifest

def asset_url(filename: str, app=None) -> str:
    manifest = load_manifest()
    mapped = manifest.get(filename, filename)
    return url_for("static", filename=mapped)
```

템플릿은 동일:

{% raw %}
```html
<link rel="stylesheet" href="{{ asset_url('css/app.css') }}">
<script src="{{ asset_url('js/app.js') }}" defer></script>
```
{% endraw %}

**운영 권장**: 매니페스트 방식 + 강력 캐시 헤더.

### 2.9.3 캐시 헤더 설정

정적 파일은 **1년** 캐시를 권장(파일명에 해시가 있으므로 안전).

```python
# app/config.py
class ProductionConfig:
    SEND_FILE_MAX_AGE_DEFAULT = 31536000  # 1년 (초)
```

Nginx:

```
location /static/ {
    alias /app/app/static/;
    expires 1y;
    add_header Cache-Control "public, immutable";
}
```

**immutable**: 파일이 **절대** 바뀌지 않음을 알림(이름이 바뀌므로 안전).

---

## 2.10 CDN 연동 — URL 프리픽스/서명 URL/서버 설정

**목표**: 정적 파일을 **CDN(CloudFront/Cloudflare/아카마이 등)** 으로 서빙해 지연/트래픽을 줄인다.

### 2.10.1 가장 쉬운 방법 — `STATIC_URL` 프리픽스

```python
# app/assets.py (CDN 프리픽스 지원)
import os
CDN_PREFIX = os.getenv("STATIC_URL", "").rstrip("/")

def asset_url(filename: str, app=None) -> str:
    manifest = load_manifest()  # 또는 _file_hash 방식
    mapped = manifest.get(filename, filename)
    path = url_for("static", filename=mapped)  # "/static/js/app.a91bcd.js"
    if CDN_PREFIX:
        return f"{CDN_PREFIX}{path}"
    return path
```

운영 환경 변수:

```
STATIC_URL=https://cdn.example.com
```

템플릿은 변경 없음. CDN이 원본(예: Nginx `/static`)을 **오리진**으로 삼아 캐시/전파.

### 2.10.2 S3 + CloudFront 예시(요약)

- 빌드 산출물(해시된 파일)을 S3 버킷에 업로드  
- CloudFront 배포를 해당 버킷으로 설정  
- 앱의 `STATIC_URL`을 CloudFront 도메인으로 설정  
- 캐시 무효화는 **파일명이 해시로 바뀌므로 거의 불필요**(경로 기반 무효화 극소화)

### 2.10.3 보안/정책

- **CSP(Content-Security-Policy)**: 외부 CDN 도메인 허용 목록에 포함
- **서브리소스 무결성(SRI)**: `<script integrity="...">` 해시를 HTML에 넣어 위변조 방지(빌드 툴에서 자동화 권장)
- **HTTP/2/3**: CDN이 자동 병렬/멀티플렉싱 → 번들 전략 재평가

---

## 2.11 실전 컴포넌트: 페이지네이션/테이블/알림 매크로

### 2.11.1 페이지네이션 매크로

{% raw %}
```html
<!-- templates/macros/pagination.html -->
{% macro pager(page, total_pages, url_builder) -%}
<nav class="pager" role="navigation" aria-label="Pagination">
  <ul>
    <li class="{{ 'disabled' if page <= 1 }}">
      <a href="{{ url_builder(1) }}">&laquo; 처음</a>
    </li>
    <li class="{{ 'disabled' if page <= 1 }}">
      <a href="{{ url_builder(page-1) }}">이전</a>
    </li>
    <li class="{{ 'disabled' if page >= total_pages }}">
      <a href="{{ url_builder(page+1) }}">다음</a>
    </li>
    <li class="{{ 'disabled' if page >= total_pages }}">
      <a href="{{ url_builder(total_pages) }}">마지막 &raquo;</a>
    </li>
  </ul>
</nav>
{%- endmacro %}
```
{% endraw %}

사용:

{% raw %}
```html
{% from "macros/pagination.html" import pager %}
{{ pager(page, total_pages, url_builder=lambda p: url_for('site.list', page=p)) }}
```
{% endraw %}

### 2.11.2 알림 컴포넌트(매크로 + call)

{% raw %}
```html
<!-- templates/macros/alert.html -->
{% macro alert(kind='info') -%}
<div class="alert alert-{{ kind }}">
  {{ caller() }}
</div>
{%- endmacro %}
```
{% endraw %}

{% raw %}
```html
{% from "macros/alert.html" import alert %}
{% call alert('warning') %}
  주의: 이 작업은 되돌릴 수 없습니다.
{% endcall %}
```
{% endraw %}

---

## 2.12 템플릿 구조/네임스페이스 권장 레이아웃

```
app/
├─ templates/
│  ├─ base.html
│  ├─ layout/                # 공용 부분 레이아웃(헤더/푸터/모달 등)
│  ├─ partials/              # include 조각
│  ├─ macros/                # 재사용 가능한 매크로
│  ├─ page/                  # 뷰 페이지
│  │  ├─ dashboard.html
│  │  ├─ about.html
│  │  └─ profile.html
│  └─ errors/
│     ├─ 404.html
│     └─ 500.html
└─ static/
   ├─ css/
   ├─ js/
   └─ img/
```

- **partials/**: `include`로 자주 끼워 넣는 조각  
- **macros/**: 함수형 재사용  
- **layout/**: 레이아웃/공통 프레임(모달/오버레이 등)

---

## 2.13 에러 페이지/상태 코드 템플릿

```python
# app/errors.py
from flask import Blueprint, render_template

errors_bp = Blueprint("errors", __name__)

@errors_bp.app_errorhandler(404)
def nf(e):
    return render_template("errors/404.html"), 404

@errors_bp.app_errorhandler(500)
def ise(e):
    return render_template("errors/500.html"), 500
```

{% raw %}
```html
<!-- templates/errors/404.html -->
{% extends "base.html" %}
{% block title %}페이지를 찾을 수 없습니다{% endblock %}
{% block content %}
  <h1>404</h1>
  <p>요청하신 페이지를 찾을 수 없습니다.</p>
{% endblock %}
```
{% endraw %}

---

## 2.14 서버 사이드 렌더링(SSR) + 점진적 향상

- **핵심 콘텐츠는 서버에서 바로 렌더링** → FCP 개선  
- 상호작용(차트/필터)은 JS로 **점진적 향상**(defer 스크립트)  
- JSON을 템플릿에 안전하게 주입해 하이드레이션

{% raw %}
```html
<script>
  window.__BOOT__ = {{ boot|tojson }};
</script>
<script src="{{ asset_url('js/app.js') }}" defer></script>
```
{% endraw %}

---

## 2.15 개발 생산성 — 템플릿 디버그/재로딩

- 개발에서 `TEMPLATES_AUTO_RELOAD = True`로 변경 감지
- Jinja2 `environment`에 **undefined=StrictUndefined**로 엄격 모드(오타 빨리 발견)

```python
# app/config.py
class DevelopmentConfig:
    TEMPLATES_AUTO_RELOAD = True
```

```python
# app/__init__.py
from jinja2 import StrictUndefined

def create_app(config=None):
    app = Flask(__name__)
    app.jinja_env.undefined = StrictUndefined
    return app
```

---

## 2.16 성능/운영 체크리스트

- [ ] **상속/매크로**로 중복 제거 → 유지보수 비용 절감  
- [ ] **컨텍스트 프로세서**로 전역 값/헬퍼(예: `asset_url`) 주입  
- [ ] **tojson**으로 안전한 데이터 주입(스크립트 XSS 방지)  
- [ ] **정적 파일 해시 버전닝** + **1년 캐시 + immutable**  
- [ ] **매니페스트 방식**(Vite/Webpack) 도입해 빌드-런타임 분리  
- [ ] **CDN 프리픽스**(`STATIC_URL`)로 전 세계 전송 최적화  
- [ ] **CSP/SRI**로 보안 강화, 외부 도메인 허용 목록 관리  
- [ ] 에러 템플릿/상태 코드 일관성(404/500 등)  
- [ ] 템플릿 엄격 모드/자동 재로딩(개발), 캐시/압축(운영)  
- [ ] 템플릿 렌더링 시간 로깅/프로파일링(핫 경로 파악)

---

## 2.17 흔한 안티패턴

- **정적 파일에 해시 없음**: 변경 후에도 캐시된 오래된 파일이 계속 서빙  
- **`safe` 남용**: XSS 위험. 신뢰 가능한 HTML만 허용  
- **URL 하드코딩**: 리버스 프록시/경로 변경 시 대규모 수정 → `url_for`/헬퍼 사용  
- **매크로 없이 복붙**: 일관성 붕괴/버그 증가  
- **CDN 프리픽스와 앱 라우팅 혼동**: API/정적 도메인을 분리하고 CSP로 제어  
- **tojson 없이 JSON 삽입**: 따옴표/문자 인코딩 깨짐 → 스크립트 오류/취약점

---

## 2.18 완성 예제 — 최소 프로젝트에 통합

### 2.18.1 컨텍스트/에셋 헬퍼 등록

```python
# app/__init__.py
from flask import Flask
from .context import register_context_processors
from .templating import register_jinja_filters

def create_app(config=None):
    app = Flask(__name__)
    # 설정 로딩 생략...
    register_context_processors(app)
    register_jinja_filters(app)
    return app
```

```python
# app/context.py
from flask import Flask, request, current_app
from .assets import asset_url

def register_context_processors(app: Flask) -> None:
    @app.context_processor
    def inject_globals():
        return {
            "app_name": "FlaskBlog",
            "current_path": request.path,
            "asset_url": asset_url,  # 어디서나 사용 가능
        }
```

### 2.18.2 매니페스트/해시 방식 선택지

빌드 파이프라인이 있다면 **매니페스트**를, 없다면 **해시 쿼리**를 선택.

- 개발: 해시 쿼리  
- 운영: 매니페스트 + CDN

```python
# app/assets.py (통합 형태 — 환경 변수로 전략 선택)
import os, json, hashlib
from pathlib import Path
from flask import url_for

STATIC_ROOT = Path(__file__).resolve().parent / "static"
MANIFEST_PATH = STATIC_ROOT / "manifest.json"
STRATEGY = os.getenv("ASSET_STRATEGY", "manifest")  # or "hash"

_manifest = None

def _load_manifest():
    global _manifest
    if _manifest is None and MANIFEST_PATH.exists():
        _manifest = json.loads(MANIFEST_PATH.read_text(encoding="utf-8"))
    return _manifest or {}

def _hash(relpath: str) -> str:
    p = STATIC_ROOT / relpath
    return hashlib.md5(p.read_bytes()).hexdigest()[:10]

def asset_url(filename: str) -> str:
    cdn = os.getenv("STATIC_URL", "").rstrip("/")
    if STRATEGY == "manifest":
        mapped = _load_manifest().get(filename, filename)
        path = url_for("static", filename=mapped)
    else:
        h = _hash(filename)
        path = url_for("static", filename=filename, v=h)
    return f"{cdn}{path}" if cdn else path
```

### 2.18.3 템플릿에서 사용

{% raw %}
```html
<!-- templates/base.html -->
<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <title>{% block title %}FlaskBlog{% endblock %}</title>
    <link rel="stylesheet" href="{{ asset_url('css/app.css') }}">
    {% block head_css %}{% endblock %}
  </head>
  <body>
    {% block content %}{% endblock %}
    <script src="{{ asset_url('js/app.js') }}" defer></script>
    {% block body_js %}{% endblock %}
  </body>
</html>
```
{% endraw %}

---

## 2.19 마무리

이 장에서는 **Jinja2 문법/상속/매크로/필터/컨텍스트 프로세서**로 **깨끗한 템플릿 구조**를 만드는 방법과, **정적 파일 버전닝(해시/매니페스트) + 캐시 헤더 + CDN 프리픽스**를 통한 **운영 성능 최적화**까지 한 번에 정리했다.  

- 개발 단계: **상속/매크로/컨텍스트**로 생산성/일관성을 확보  
- 운영 단계: **매니페스트 해시 + 1년 캐시 + CDN**으로 속도/비용 개선  