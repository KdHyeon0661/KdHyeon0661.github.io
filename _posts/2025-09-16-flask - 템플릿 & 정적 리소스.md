---
layout: post
title: flask - 템플릿 & 정적 리소스
date: 2025-09-16 14:25:23 +0900
category: flask
---
# 템플릿 & 정적 리소스

## Jinja2 템플릿 엔진 기초

Jinja2는 Flask의 기본 템플릿 엔진으로, 동적 웹 페이지를 생성하는 강력한 도구입니다. 핵심 구문은 세 가지로 구분됩니다:

- **표현식 출력**: {% raw %}`{{ ... }}`{% endraw %} 안에 변수나 표현식을 넣어 결과를 출력합니다.
- **제어 구조**: {% raw %}`{% ... %}`{% endraw %} 블록으로 조건문, 반복문, 템플릿 상속 등을 처리합니다.
- **주석**: `{# ... #}` 안에 작성한 내용은 렌더링되지 않습니다.

{% raw %}
```html
<!-- templates/hello.html -->
<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <title>환영합니다</title>
  </head>
  <body>
    <h1>{{ user.name }}님, 환영합니다!</h1>
    
    {% if user.is_admin %}
      <p class="admin-notice">관리자 권한으로 로그인했습니다.</p>
    {% else %}
      <p>일반 사용자 계정입니다.</p>
    {% endif %}
    
    <h2>상품 목록</h2>
    <ul>
    {% for item in items %}
      <li>{{ loop.index }}. {{ item|e }}</li>
    {% else %}
      <li class="empty">표시할 항목이 없습니다.</li>
    {% endfor %}
    </ul>
  </body>
</html>
```
{% endraw %}

```python
# app/blueprints/site/views.py

from flask import Blueprint, render_template

site_bp = Blueprint("site", __name__)

@site_bp.get("/hello")
def hello():
    """템플릿 렌더링 예시"""
    user = {"name": "김철수", "is_admin": False}
    items = ["노트북", "스마트폰", "<특가>태블릿"]
    return render_template("hello.html", user=user, items=items)
```

**보안 주의사항**: Jinja2는 기본적으로 HTML 자동 이스케이프를 수행합니다. `|e` 필터는 명시적인 이스케이프를, `|safe` 필터는 신뢰할 수 있는 HTML 내용에만 사용해야 합니다. 사용자 입력을 그대로 출력할 때는 절대 `|safe`를 사용하지 마세요.

---

## 템플릿 상속을 통한 레이아웃 관리

템플릿 상속은 코드 중복을 줄이고 일관된 레이아웃을 유지하는 핵심 기술입니다. 기본 템플릿에서 공통 구조를 정의하고, 자식 템플릿에서 특정 부분만 재정의합니다.

{% raw %}
```html
<!-- templates/base.html -->
<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <title>{% block title %}사이트 제목{% endblock %}</title>
    
    {% block head_meta %}
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    {% endblock %}
    
    <link rel="stylesheet" href="{{ asset_url('css/app.css') }}">
    {% block head_css %}{% endblock %}
  </head>
  <body>
    <header class="site-header">
      <nav>
        <a href="{{ url_for('site.home') }}" class="logo">홈페이지</a>
        {% block header_nav %}{% endblock %}
      </nav>
    </header>
    
    <main class="main-content">
      {% block content %}
      <!-- 기본 콘텐츠 영역 -->
      {% endblock %}
    </main>
    
    <footer class="site-footer">
      {% block footer %}
      <p>&copy; 2024 사이트명. All rights reserved.</p>
      {% endblock %}
    </footer>
    
    <script src="{{ asset_url('js/app.js') }}" defer></script>
    {% block body_js %}{% endblock %}
  </body>
</html>
```
{% endraw %}

자식 템플릿은 {% raw %}`extends`{% endraw %} 지시어를 사용하여 기본 템플릿을 상속받고, `block` 섹션을 재정의합니다.

```html
<!-- templates/page/dashboard.html -->
{% extends "base.html" %}

{% block title %}대시보드 - 내 정보{% endblock %}

{% block head_css %}
  {{ super() }}
  <link rel="stylesheet" href="{{ asset_url('css/dashboard.css') }}">
{% endblock %}

{% block content %}
  <div class="dashboard-container">
    <h1>대시보드</h1>
    <div class="stats-grid">
      <div class="stat-card">
        <h3>새 알림</h3>
        <p class="count">{{ notifications|length }}</p>
      </div>
      <div class="stat-card">
        <h3>작업 중</h3>
        <p class="count">{{ pending_tasks }}</p>
      </div>
    </div>
  </div>
{% endblock %}
```

**`{{ super() }}`의 활용**: 부모 템플릿의 블록 내용을 유지하면서 추가 내용을 덧붙일 때 사용합니다. 위 예제에서 `head_css` 블록은 부모의 CSS 링크를 유지하면서 대시보드 전용 CSS를 추가로 로드합니다.

---

## 템플릿 모듈화: Include와 Import

### Include로 부분 템플릿 재사용

반복적으로 사용되는 UI 컴포넌트나 코드 조각을 별도 파일로 분리하여 `include`로 삽입할 수 있습니다.

{% raw %}
```html
<!-- templates/partials/navigation.html -->
<nav class="main-navigation" role="navigation">
  <ul class="nav-list">
    <li class="nav-item">
      <a href="{{ url_for('site.home') }}" 
         class="nav-link {% if active_page == 'home' %}active{% endif %}">
        홈
      </a>
    </li>
    <li class="nav-item">
      <a href="{{ url_for('site.about') }}" 
         class="nav-link {% if active_page == 'about' %}active{% endif %}">
        소개
      </a>
    </li>
    <li class="nav-item">
      <a href="{{ url_for('site.contact') }}" 
         class="nav-link {% if active_page == 'contact' %}active{% endif %}">
        연락처
      </a>
    </li>
  </ul>
</nav>
```
{% endraw %}

{% raw %}
```html
<!-- templates/page/about.html -->
{% extends "base.html" %}

{% block content %}
  {% include "partials/navigation.html" with context %}
  
  <div class="page-content">
    <h1>회사 소개</h1>
    <p>저희 회사는 2010년 설립된 기술 기업입니다...</p>
  </div>
{% endblock %}
```
{% endraw %}

`with context` 옵션은 현재 템플릿 컨텍스트를 포함된 템플릿에 전달합니다. 기본적으로는 포함되지만 명시적으로 작성하는 것이 좋습니다.

### Import와 Macro를 통한 컴포넌트화

매크로(Macro)는 함수처럼 재사용 가능한 템플릿 조각을 생성합니다. 특히 폼 요소나 UI 컴포넌트에 유용합니다.

{% raw %}
```html
<!-- templates/macros/forms.html -->
{% macro text_input(name, value='', label='', placeholder='', type='text', error=None, required=False) -%}
<div class="form-group">
  {% if label %}
    <label for="{{ name }}" class="form-label">
      {{ label }}
      {% if required %}<span class="required">*</span>{% endif %}
    </label>
  {% endif %}
  
  <input type="{{ type }}" 
         id="{{ name }}" 
         name="{{ name }}" 
         value="{{ value|e }}" 
         placeholder="{{ placeholder|e }}"
         class="form-control {% if error %}is-invalid{% endif %}"
         {% if required %}required{% endif %}>
  
  {% if error %}
    <div class="invalid-feedback">{{ error }}</div>
  {% endif %}
</div>
{%- endmacro %}
```
{% endraw %}

매크로를 사용하는 템플릿:

{% raw %}
```html
{% extends "base.html" %}
{% import "macros/forms.html" as forms %}

{% block content %}
  <form method="post" action="{{ url_for('user.update_profile') }}" class="profile-form">
    {{ forms.text_input(
        name='username',
        value=user.username,
        label='사용자 이름',
        placeholder='사용자 이름을 입력하세요',
        error=errors.username
      ) 
    }}
    
    {{ forms.text_input(
        name='email',
        value=user.email,
        label='이메일 주소',
        type='email',
        placeholder='user@example.com',
        required=true,
        error=errors.email
      ) 
    }}
    
    <button type="submit" class="btn btn-primary">프로필 업데이트</button>
  </form>
{% endblock %}
```
{% endraw %}

### Call 블록을 이용한 슬롯 패턴

매크로에 콘텐츠 블록을 전달할 수 있는 `call` 블록을 사용하면 더 유연한 컴포넌트를 만들 수 있습니다.

{% raw %}
```html
<!-- templates/macros/panel.html -->
{% macro panel(title, type='default') -%}
  <div class="panel panel-{{ type }}">
    <div class="panel-header">
      <h3 class="panel-title">{{ title }}</h3>
    </div>
    <div class="panel-body">
      {{ caller() }}
    </div>
  </div>
{%- endmacro %}
```
{% endraw %}

{% raw %}
```html
{% from "macros/panel.html" import panel %}

{% call panel("시스템 알림", type="warning") %}
  <p><strong>중요:</strong> 시스템 점검 예정일은 12월 25일입니다.</p>
  <p>점검 시간 동안 서비스가 일시 중단될 수 있습니다.</p>
{% endcall %}

{% call panel("최근 활동") %}
  <ul class="activity-list">
    {% for activity in recent_activities %}
      <li>{{ activity.description }} <small>{{ activity.time|datetime }}</small></li>
    {% endfor %}
  </ul>
{% endcall %}
```
{% endraw %}

---

## 필터와 테스트: 데이터 변환과 검증

### 내장 필터 활용

Jinja2는 다양한 내장 필터를 제공합니다:

- **문자열 처리**: `e`(이스케이프), `safe`, `truncate`, `replace`, `upper`, `lower`, `title`, `capitalize`
- **리스트/시퀀스**: `length`, `join`, `first`, `last`, `unique`, `sort`, `select`, `reject`
- **날짜/시간**: `datetimeformat` (Flask-Moment 등 확장 필요)
- **JSON 변환**: `tojson` (JavaScript에서 안전하게 사용 가능)

{% raw %}
```html
<script>
  // 템플릿에서 JavaScript로 데이터 전달
  const userData = {{ user|tojson }};
  const config = {{ config|tojson }};
  
  // 배열 데이터도 안전하게 전달
  const items = {{ items|tojson }};
</script>
```
{% endraw %}

### 커스텀 필터 등록

프로젝트 특화된 데이터 형식을 처리하기 위해 커스텀 필터를 등록할 수 있습니다.

```python
# app/templating/filters.py

from datetime import datetime, timezone
import pytz
from flask import Flask

def format_datetime_ko(value: datetime, format_str="%Y년 %m월 %d일 %H:%M") -> str:
    """datetime 객체를 한국 시간대와 형식으로 변환"""
    if value.tzinfo is None:
        # 시간대 정보가 없으면 UTC로 가정
        value = value.replace(tzinfo=timezone.utc)
    
    # 한국 시간대 변환
    korea_tz = pytz.timezone("Asia/Seoul")
    local_time = value.astimezone(korea_tz)
    
    return local_time.strftime(format_str)

def format_currency(value: float, currency="KRW") -> str:
    """통화 형식으로 변환"""
    if currency == "KRW":
        return f"{value:,.0f}원"
    elif currency == "USD":
        return f"${value:,.2f}"
    else:
        return f"{value:,.2f} {currency}"

def excerpt_text(text: str, length=150, suffix="...") -> str:
    """텍스트 요약 생성"""
    if len(text) <= length:
        return text
    return text[:length].rsplit(' ', 1)[0] + suffix

def register_filters(app: Flask) -> None:
    """Flask 애플리케이션에 커스텀 필터 등록"""
    app.jinja_env.filters["datetime_ko"] = format_datetime_ko
    app.jinja_env.filters["currency"] = format_currency
    app.jinja_env.filters["excerpt"] = excerpt_text
```

```python
# app/__init__.py

from .templating.filters import register_filters

def create_app():
    app = Flask(__name__)
    register_filters(app)
    # ... 기타 설정
    return app
```

{% raw %}
```html
<p class="post-meta">
  작성일: {{ post.created_at|datetime_ko }}
  | 수정일: {{ post.updated_at|datetime_ko("%Y-%m-%d") }}
</p>

<p class="price">가격: {{ product.price|currency }}</p>
<p class="summary">{{ article.content|excerpt(200) }}</p>
```
{% endraw %}

### 테스트(Test) 활용

테스트는 조건문에서 변수의 타입이나 상태를 검증하는 데 사용됩니다.

{% raw %}
```html
{% if user.email is defined and user.email is string %}
  <p>이메일: {{ user.email }}</p>
{% endif %}

{% if items is iterable and items|length > 0 %}
  <ul>
  {% for item in items %}
    <li>{{ item }}</li>
  {% endfor %}
  </ul>
{% else %}
  <p class="empty">표시할 항목이 없습니다.</p>
{% endif %}

{% if value is number %}
  <p>숫자 형식: {{ value|int }}</p>
{% endif %}
```
{% endraw %}

---

## 컨텍스트 프로세서: 전역 변수와 함수 주입

컨텍스트 프로세서는 모든 템플릿에서 자동으로 사용할 수 있는 변수나 함수를 등록하는 메커니즘입니다.

```python
# app/templating/context.py

from flask import Flask, request, current_app, g
import datetime

def register_context_processors(app: Flask) -> None:
    """템플릿 컨텍스트 프로세서 등록"""
    
    @app.context_processor
    def inject_global_variables():
        """전역 변수 주입"""
        return {
            "current_year": datetime.datetime.now().year,
            "app_name": current_app.config.get("APP_NAME", "Flask App"),
            "debug_mode": current_app.debug,
            "current_path": request.path,
        }
    
    @app.context_processor
    def inject_utility_functions():
        """유틸리티 함수 주입"""
        from .assets import asset_url
        from .helpers import format_phone_number
        
        return {
            "asset_url": asset_url,
            "format_phone": format_phone_number,
            "is_active_page": lambda page: "active" if request.path.startswith(page) else "",
        }
    
    @app.context_processor
    def inject_user_context():
        """사용자 컨텍스트 주입"""
        user_data = {}
        
        # g 객체나 세션에서 사용자 정보 가져오기
        if hasattr(g, "user"):
            user_data = {
                "current_user": g.user,
                "is_authenticated": True,
                "is_admin": getattr(g.user, "is_admin", False),
            }
        else:
            user_data = {
                "current_user": None,
                "is_authenticated": False,
                "is_admin": False,
            }
        
        return user_data
```

```python
# app/__init__.py

from .templating.context import register_context_processors

def create_app():
    app = Flask(__name__)
    register_context_processors(app)
    return app
```

이제 모든 템플릿에서 다음 변수와 함수를 사용할 수 있습니다:

{% raw %}
```html
<footer>
  <p>&copy; {{ current_year }} {{ app_name }}. All rights reserved.</p>
  {% if debug_mode %}
    <p class="debug-notice">디버그 모드 실행 중</p>
  {% endif %}
  
  {% if is_authenticated %}
    <p>안녕하세요, {{ current_user.name }}님!</p>
  {% endif %}
</footer>

<link rel="stylesheet" href="{{ asset_url('css/app.css') }}">
<p>문의: {{ format_phone('010-1234-5678') }}</p>
```
{% endraw %}

---

## 정적 파일 관리: 버전닝과 캐싱

### 기본 정적 파일 서빙

Flask는 기본적으로 `static` 폴더의 파일을 `/static` 경로로 서빙합니다.

```
app/
├── static/
│   ├── css/
│   │   ├── app.css
│   │   └── dashboard.css
│   ├── js/
│   │   ├── app.js
│   │   └── vendor.js
│   └── images/
│       ├── logo.png
│       └── banner.jpg
└── templates/
```

{% raw %}
```html
<link rel="stylesheet" href="{{ url_for('static', filename='css/app.css') }}">
<script src="{{ url_for('static', filename='js/app.js') }}"></script>
<img src="{{ url_for('static', filename='images/logo.png') }}" alt="로고">
```
{% endraw %}

### 블루프린트별 정적 파일

블루프린트마다 독립된 정적 파일을 관리할 수 있습니다.

```python
# 블루프린트 정의 시 정적 파일 설정
admin_bp = Blueprint(
    "admin",
    __name__,
    static_folder="static",
    static_url_path="/admin-static",
    template_folder="templates"
)

# 블루프린트별 정적 파일 사용
# url_for('admin.static', filename='css/admin.css')
```

### 정적 파일 버전닝 (캐시 버스팅)

정적 파일을 오래 캐시하면서도 변경 시 캐시를 무효화하려면 파일 내용에 기반한 버전 식별자를 추가해야 합니다. 두 가지 주요 접근법이 있습니다.

**쿼리스트링 해시 방식**: 파일 내용의 해시를 쿼리 파라미터로 추가합니다.

```python
# app/templating/assets.py

import hashlib
from pathlib import Path
from functools import lru_cache
from flask import current_app, url_for

STATIC_ROOT = Path(current_app.root_path) / "static"

@lru_cache(maxsize=512)
def get_file_hash(filename: str) -> str:
    """파일 내용의 MD5 해시 계산 (캐싱 적용)"""
    file_path = STATIC_ROOT / filename
    
    if not file_path.exists():
        return "0"  # 파일이 없을 경우 기본값
    
    with open(file_path, "rb") as f:
        file_hash = hashlib.md5(f.read()).hexdigest()
    
    return file_hash[:8]  # 앞 8자리만 사용

def asset_url(filename: str) -> str:
    """버전이 포함된 정적 파일 URL 생성"""
    file_hash = get_file_hash(filename)
    base_url = url_for("static", filename=filename)
    return f"{base_url}?v={file_hash}"
```

**매니페스트 파일 방식**: 빌드 도구가 생성한 매니페스트 파일을 사용합니다. 이 방식이 더 효율적이고 일반적입니다.

```python
# app/templating/assets.py

import json
from pathlib import Path
from flask import current_app, url_for
import os

def load_manifest() -> dict:
    """매니페스트 파일 로드"""
    manifest_path = Path(current_app.root_path) / "static" / "manifest.json"
    
    if not manifest_path.exists():
        return {}
    
    with open(manifest_path, "r", encoding="utf-8") as f:
        return json.load(f)

def asset_url(filename: str) -> str:
    """매니페스트 기반 정적 파일 URL 생성"""
    manifest = load_manifest()
    
    # 매니페스트에 파일명이 있으면 해시된 파일명으로 변환
    actual_filename = manifest.get(filename, filename)
    
    # CDN URL 프리픽스 적용 (환경별)
    cdn_prefix = current_app.config.get("CDN_URL", "").rstrip("/")
    base_url = url_for("static", filename=actual_filename)
    
    if cdn_prefix:
        return f"{cdn_prefix}{base_url}"
    return base_url
```

매니페스트 파일 예시 (`static/manifest.json`):
```json
{
  "css/app.css": "css/app.a1b2c3d4.css",
  "js/app.js": "js/app.e5f6g7h8.js",
  "images/logo.png": "images/logo.i9j0k1l2.png"
}
```

### 캐시 헤더 최적화

정적 파일에 적절한 캐시 헤더를 설정해야 합니다. Flask 자체 설정과 웹 서버(Nginx/Apache) 설정을 모두 고려해야 합니다.

**Flask 애플리케이션 설정**:
```python
# app/config.py

class ProductionConfig:
    # 정적 파일 캐시 시간 (초 단위)
    SEND_FILE_MAX_AGE_DEFAULT = 31536000  # 1년
```

**Nginx 설정 예시**:
```nginx
location /static/ {
    alias /path/to/app/static/;
    
    # 1년 캐시 (파일명에 해시가 포함되어 있으므로 안전)
    expires 1y;
    
    # immutable: 파일이 절대 변경되지 않음을 브라우저에 알림
    add_header Cache-Control "public, immutable, max-age=31536000";
    
    # 압축 지원
    gzip on;
    gzip_types text/css application/javascript image/svg+xml;
    
    # 보안 헤더
    add_header X-Content-Type-Options "nosniff";
}
```

### CDN 연동

CDN(Content Delivery Network)을 사용하면 전 세계 사용자에게 빠르게 정적 파일을 전달할 수 있습니다.

```python
# app/config.py

class ProductionConfig:
    # CDN URL 설정 (환경변수에서 로드)
    CDN_URL = os.getenv("CDN_URL", "https://cdn.example.com")
```

```python
# app/templating/assets.py (수정)

def asset_url(filename: str) -> str:
    """CDN 지원 정적 파일 URL 생성"""
    manifest = load_manifest()
    actual_filename = manifest.get(filename, filename)
    
    # CDN URL이 설정되어 있으면 사용
    cdn_url = current_app.config.get("CDN_URL", "").rstrip("/")
    
    if cdn_url:
        # CDN을 직접 사용 (정적 파일이 CDN에 업로드되어 있다고 가정)
        return f"{cdn_url}/{actual_filename}"
    else:
        # 로컬 정적 파일 사용
        return url_for("static", filename=actual_filename, _external=True)
```

**S3 + CloudFront 구성 예시**:
1. 정적 파일을 S3 버킷에 업로드
2. CloudFront 배포 생성 (S3를 Origin으로)
3. CloudFront 도메인을 `CDN_URL`로 설정
4. 빌드 프로세스에 S3 업로드 스크립트 통합

---

## 실전 컴포넌트 구현

### 페이지네이션 컴포넌트

{% raw %}
```html
<!-- templates/macros/pagination.html -->
{% macro pagination(page_obj, endpoint, params={}) -%}
{% if page_obj.pages > 1 %}
<nav class="pagination" aria-label="페이지 네비게이션">
  <ul class="pagination-list">
    {# 처음 페이지 링크 #}
    <li class="pagination-item {% if page_obj.page == 1 %}disabled{% endif %}">
      <a href="{{ url_for(endpoint, page=1, **params) }}" 
         class="pagination-link" 
         aria-label="처음 페이지">
        &laquo;
      </a>
    </li>
    
    {# 이전 페이지 링크 #}
    <li class="pagination-item {% if not page_obj.has_prev %}disabled{% endif %}">
      <a href="{{ url_for(endpoint, page=page_obj.prev_num, **params) if page_obj.has_prev else '#' }}" 
         class="pagination-link" 
         aria-label="이전 페이지">
        &lsaquo;
      </a>
    </li>
    
    {# 페이지 번호들 #}
    {%- for p in page_obj.iter_pages(left_edge=2, left_current=2, right_current=3, right_edge=2) %}
      {% if p %}
        {% if p == page_obj.page %}
          <li class="pagination-item active">
            <span class="pagination-link current">{{ p }}</span>
          </li>
        {% else %}
          <li class="pagination-item">
            <a href="{{ url_for(endpoint, page=p, **params) }}" class="pagination-link">{{ p }}</a>
          </li>
        {% endif %}
      {% else %}
        <li class="pagination-item disabled">
          <span class="pagination-ellipsis">&hellip;</span>
        </li>
      {% endif %}
    {%- endfor %}
    
    {# 다음 페이지 링크 #}
    <li class="pagination-item {% if not page_obj.has_next %}disabled{% endif %}">
      <a href="{{ url_for(endpoint, page=page_obj.next_num, **params) if page_obj.has_next else '#' }}" 
         class="pagination-link" 
         aria-label="다음 페이지">
        &rsaquo;
      </a>
    </li>
    
    {# 마지막 페이지 링크 #}
    <li class="pagination-item {% if page_obj.page == page_obj.pages %}disabled{% endif %}">
      <a href="{{ url_for(endpoint, page=page_obj.pages, **params) }}" 
         class="pagination-link" 
         aria-label="마지막 페이지">
        &raquo;
      </a>
    </li>
  </ul>
</nav>
{% endif %}
{%- endmacro %}
```
{% endraw %}

사용 예시:

{% raw %}
```html
{% from "macros/pagination.html" import pagination %}

<div class="search-results">
  <h2>검색 결과 (총 {{ items.total }}개)</h2>
  
  <div class="results-list">
    {% for item in items %}
      <div class="result-item">{{ item.title }}</div>
    {% endfor %}
  </div>
  
  {# 페이지네이션 표시 #}
  {{ pagination(
      page_obj=items, 
      endpoint='search.results', 
      params={'query': request.args.get('query', '')}
    ) 
  }}
</div>
```
{% endraw %}

### 알림 메시지 컴포넌트

{% raw %}
```html
<!-- templates/macros/flash_messages.html -->
{% macro render_flash_messages() -%}
{% with messages = get_flashed_messages(with_categories=true) %}
  {% if messages %}
    <div class="flash-messages">
      {% for category, message in messages %}
        <div class="alert alert-{{ category|default('info') }} alert-dismissible">
          {{ message }}
          <button type="button" class="close" data-dismiss="alert" aria-label="닫기">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
      {% endfor %}
    </div>
  {% endif %}
{% endwith %}
{%- endmacro %}

{% macro flash_message(message, category='info', dismissible=true) -%}
<div class="alert alert-{{ category }} {% if dismissible %}alert-dismissible{% endif %}">
  {{ message }}
  {% if dismissible %}
    <button type="button" class="close" data-dismiss="alert" aria-label="닫기">
      <span aria-hidden="true">&times;</span>
    </button>
  {% endif %}
</div>
{%- endmacro %}
```
{% endraw %}

---

## 템플릿 구조화와 에러 페이지

### 권장 템플릿 구조

체계적인 템플릿 구조는 유지보수성을 크게 향상시킵니다.

```
app/
├── templates/
│   ├── base.html                    # 기본 레이아웃
│   ├── layout/                      # 레이아웃 컴포넌트
│   │   ├── header.html
│   │   ├── footer.html
│   │   └── sidebar.html
│   ├── partials/                    # 포함용 템플릿 조각
│   │   ├── navigation.html
│   │   ├── breadcrumbs.html
│   │   └── modal.html
│   ├── macros/                      # 재사용 가능 매크로
│   │   ├── forms.html
│   │   ├── ui.html
│   │   └── pagination.html
│   ├── pages/                       # 실제 페이지 템플릿
│   │   ├── home.html
│   │   ├── dashboard/
│   │   │   ├── index.html
│   │   │   └── settings.html
│   │   └── auth/
│   │       ├── login.html
│   │       └── register.html
│   └── errors/                      # 에러 페이지
│       ├── 404.html
│       ├── 500.html
│       └── maintenance.html
└── static/
    └── ...                         # 정적 파일들
```

### 에러 페이지 템플릿

사용자 친화적인 에러 페이지를 제공하는 것이 중요합니다.

{% raw %}
```html
<!-- templates/errors/404.html -->
{% extends "base.html" %}

{% block title %}페이지를 찾을 수 없음 (404) - {{ super() }}{% endblock %}

{% block content %}
<div class="error-page">
  <div class="error-code">404</div>
  <h1 class="error-title">페이지를 찾을 수 없습니다</h1>
  
  <div class="error-message">
    <p>요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.</p>
    <p>URL을 다시 확인하시거나 아래 링크를 이용해주세요.</p>
  </div>
  
  <div class="error-actions">
    <a href="{{ url_for('site.home') }}" class="btn btn-primary">
      홈페이지로 돌아가기
    </a>
    <a href="javascript:history.back()" class="btn btn-secondary">
      이전 페이지로
    </a>
  </div>
</div>
{% endblock %}
```
{% endraw %}

```python
# app/errors/handlers.py

from flask import Blueprint, render_template

errors_bp = Blueprint("errors", __name__)

@errors_bp.app_errorhandler(404)
def not_found_error(error):
    """404 에러 처리"""
    return render_template("errors/404.html"), 404

@errors_bp.app_errorhandler(500)
def internal_error(error):
    """500 에러 처리"""
    # 데이터베이스 세션 롤백 등 정리 작업 수행
    return render_template("errors/500.html"), 500

@errors_bp.app_errorhandler(403)
def forbidden_error(error):
    """403 에러 처리"""
    return render_template("errors/403.html"), 403

# 애플리케이션에 등록
# app.register_blueprint(errors_bp)
```

---

## 보안 고려사항

### XSS 방지

Jinja2의 자동 이스케이프 기능을 이해하고 적절히 활용해야 합니다.

{% raw %}
```html
{# 안전: 자동 이스케이프 적용됨 #}
<p>{{ user_input }}</p>

{# 위험: 신뢰할 수 없는 HTML을 safe로 표시 #}
<p>{{ user_input|safe }}</p>  <!-- 절대 사용하지 마세요! -->

{# 안전: 신뢰할 수 있는 HTML만 safe 사용 #}
<p>{{ sanitized_html|safe }}</p>

{# 안전: JSON 데이터를 JavaScript에 전달 #}
<script>
  const config = {{ config_data|tojson }};
  // tojson은 문자열을 적절히 이스케이프합니다
</script>
```
{% endraw %}

### Content Security Policy (CSP)

CSP 헤더를 설정하여 XSS 공격을 방지할 수 있습니다.

```python
# app/security/csp.py

from flask import Flask
from flask_talisman import Talisman

def setup_csp(app: Flask) -> None:
    """Content Security Policy 설정"""
    
    csp_policy = {
        'default-src': "'self'",
        'script-src': [
            "'self'",
            "'unsafe-inline'",  # 개발 환경에서만
            "https://cdn.example.com"  # CDN 도메인
        ],
        'style-src': [
            "'self'",
            "'unsafe-inline'",
            "https://cdn.example.com"
        ],
        'img-src': [
            "'self'",
            "data:",
            "https://cdn.example.com"
        ],
        'font-src': [
            "'self'",
            "https://fonts.googleapis.com",
            "https://fonts.gstatic.com"
        ],
        'connect-src': [
            "'self'",
            "https://api.example.com"
        ],
    }
    
    # 개발 환경에서는 좀 더 유연한 정책
    if app.debug:
        csp_policy['script-src'].append("'unsafe-eval'")
    
    Talisman(
        app,
        content_security_policy=csp_policy,
        content_security_policy_nonce_in=['script-src']
    )
```

---

## 개발 생산성 향상

### 자동 리로드와 디버깅

개발 환경에서 템플릿 변경을 실시간으로 반영하고 디버깅을 용이하게 합니다.

```python
# app/config.py

class DevelopmentConfig:
    # 템플릿 자동 리로드
    TEMPLATES_AUTO_RELOAD = True
    
    # 디버그 모드
    DEBUG = True
    
    # 상세한 에러 페이지
    EXPLAIN_TEMPLATE_LOADING = True
```

```python
# app/__init__.py

from jinja2 import StrictUndefined

def create_app():
    app = Flask(__name__)
    
    # 엄격 모드: 정의되지 않은 변수 접근 시 에러 발생
    app.jinja_env.undefined = StrictUndefined
    
    # 사용자 정의 테스트 추가
    app.jinja_env.tests['even'] = lambda value: value % 2 == 0
    app.jinja_env.tests['odd'] = lambda value: value % 2 == 1
    
    return app
```

### 템플릿 프로파일링

템플릿 렌더링 성능을 측정하고 최적화합니다.

```python
# app/debug/template_profiler.py

import time
from functools import wraps
from flask import g, current_app

def template_profile(f):
    """템플릿 렌더링 성능 프로파일링 데코레이터"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_app.debug:
            return f(*args, **kwargs)
        
        # 렌더링 시작 시간 기록
        g.template_render_start = time.perf_counter()
        
        result = f(*args, **kwargs)
        
        # 렌더링 시간 계산 및 로깅
        render_time = time.perf_counter() - g.template_render_start
        current_app.logger.debug(
            f"템플릿 렌더링 시간: {render_time:.3f}초 - 함수: {f.__name__}"
        )
        
        return result
    return decorated_function

# 뷰 함수에 적용
@site_bp.get("/slow-page")
@template_profile
def slow_page():
    """템플릿 프로파일링 예시"""
    return render_template("slow_page.html", data=large_dataset)
```

---

## 결론

템플릿과 정적 리소스 관리는 Flask 애플리케이션의 사용자 경험과 성능에 직접적인 영향을 미치는 중요한 요소입니다.

**첫째, Jinja2 템플릿 엔진을 효과적으로 활용**해야 합니다. 템플릿 상속을 통해 일관된 레이아웃을 유지하고, 매크로와 include를 활용하여 코드 재사용성을 높이며, 컨텍스트 프로세서를 통해 전역 변수와 함수를 효율적으로 관리할 수 있습니다. 이러한 구조화된 접근 방식은 장기적인 유지보수성을 크게 향상시킵니다.

**둘째, 정적 리소스 관리는 성능 최적화의 핵심**입니다. 파일 버전닝(캐시 버스팅)을 구현하여 브라우저 캐싱을 효과적으로 활용하고, CDN을 통한 전 세계적 콘텐츠 전송을 고려해야 합니다. 매니페스트 기반 버전닝과 적절한 캐시 헤더 설정은 프로덕션 환경에서 필수적입니다.

**셋째, 보안을 항상 고려**해야 합니다. Jinja2의 자동 이스케이프 기능을 이해하고 적절히 활용하며, Content Security Policy를 설정하여 XSS 공격을 방지해야 합니다. 특히 사용자 입력을 템플릿에 출력할 때는 각별한 주의가 필요합니다.

**넷째, 개발 생산성을 위한 도구와 설정**을 활용해야 합니다. 템플릿 자동 리로드, 엄격 모드, 프로파일링 도구 등을 통해 개발 효율성을 높이고 성능 문제를 조기에 발견할 수 있습니다.

이러한 원칙들을 바탕으로 체계적인 템플릿과 정적 리소스 관리 시스템을 구축하면, 사용자에게 빠르고 안전하며 일관된 경험을 제공할 수 있는 견고한 웹 애플리케이션을 개발할 수 있을 것입니다. 템플릿은 단순히 HTML을 생성하는 도구가 아니라, 애플리케이션의 프레젠테이션 레이어를 체계적으로 관리하는 핵심 도구라는 점을 기억하세요.