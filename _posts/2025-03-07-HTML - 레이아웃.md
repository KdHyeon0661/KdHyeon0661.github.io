---
layout: post
title: HTML - 레이아웃
date: 2025-03-07 20:20:23 +0900
category: HTML
---
# HTML/CSS 레이아웃

## 1. 시맨틱 레이아웃의 뼈대

시맨틱 태그로 정보 구조를 먼저 고정하면, CSS 교체만으로도 레이아웃 교체가 쉬워진다.

```html
<body>
  <header>헤더</header>
  <nav aria-label="주요 메뉴">내비게이션</nav>
  <main id="content">
    <section aria-labelledby="sec-title">
      <h2 id="sec-title">본문 섹션</h2>
      <article>기사 A</article>
      <article>기사 B</article>
    </section>
    <aside>사이드바</aside>
  </main>
  <footer>푸터</footer>
</body>
```

> 팁: 페이지당 `<main>`은 1개, 스크린리더용 내비게이션은 `aria-label` or `aria-labelledby`로 명확히 설명.

---

## 2. 레이아웃 단위·논리적 속성·핵심 유틸

현대 레이아웃의 기본 도구:

- **논리적 속성**: `margin-inline`, `padding-block`, `inset-block-start` 등(언어 방향성에 강함).
- **유동 단위**: `%`, `vw`, `vh`, `svh`, `lvh`(모바일 주소창 높이 이슈 대응).
- **함수**: `min()`, `max()`, `clamp()`로 크기·여백의 상·하한을 안전하게 제어.
- **레이아웃 보조**: `aspect-ratio`, `object-fit`, `min-content/max-content`, `fit-content()`.

```css
:root {
  --content-max: 72rem;
  --gutter: clamp(1rem, 2vw, 2rem);
  --radius: 12px;
}

/* 중앙 래퍼 */
.wrapper {
  inline-size: min(100% - 2 * var(--gutter), var(--content-max));
  margin-inline: auto;
}

/* 논리적 여백 사용 */
.section {
  padding-block: clamp(1.5rem, 3vw, 3rem);
  padding-inline: var(--gutter);
  border-radius: var(--radius);
}

/* 유동 타이포 */
h1 { font-size: clamp(1.75rem, 3vw + 1rem, 3rem); }
```

---

## 3. Flexbox — 1차원(행 또는 열) 배치의 표준

### 3.1 기본 2컬럼(본문/사이드)

```html
<style>
  .layout {
    display: flex;
    gap: 1rem;
  }
  .main  { flex: 1 1 0; background: #f6f6f6; padding: 1rem; }
  .aside { flex: 0 0 320px; background: #eee; padding: 1rem; }
  @media (max-width: 768px) {
    .layout { flex-direction: column; }
    .aside  { order: -1; } /* 모바일에서 사이드 먼저 */
  }
</style>

<div class="layout">
  <main class="main">본문</main>
  <aside class="aside">사이드</aside>
</div>
```

### 3.2 수평/수직 정렬·랩·동적 비율

```css
.nav {
  display:flex;
  flex-wrap:wrap;
  align-items:center;           /* 교차축 정렬 */
  justify-content:space-between;/* 주축 정렬 */
  gap:.5rem 1rem;
}
.card-list {
  display:flex; flex-wrap:wrap; gap:1rem;
}
.card {
  flex: 1 1 clamp(240px, 25%, 320px); /* 행 내에서 유연하게 줄바꿈 */
}
```

> 체크: **Flex는 라인 간 제어(2차원)**에 약하다 → 격자/영역 설계는 Grid가 적격.

---

## 4. CSS Grid — 2차원 레이아웃의 주력

### 4.1 영역 기반(Grid Areas) — 페이지 프레임

```html
<style>
  .grid {
    display: grid;
    grid-template-areas:
      "header header"
      "nav    main"
      "footer footer";
    grid-template-columns: 280px 1fr;
    grid-template-rows: auto 1fr auto;
    min-height: 100svh; /* 모바일 안전 */
    gap: 0;
  }
  header { grid-area: header; background:#222; color:#fff; padding:1rem; }
  nav    { grid-area: nav;    background:#f0f0f0; padding:1rem; }
  main   { grid-area: main;   padding:1rem; }
  footer { grid-area: footer; background:#222; color:#fff; padding:1rem; }

  @media (max-width: 900px) {
    .grid {
      grid-template-areas:
        "header"
        "nav"
        "main"
        "footer";
      grid-template-columns: 1fr;
    }
  }
</style>

<div class="grid">
  <header>헤더</header>
  <nav>내비</nav>
  <main>본문</main>
  <footer>푸터</footer>
</div>
```

### 4.2 반복·자동 채움 — 카드 그리드

```css
.cards {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(16rem, 1fr));
  gap: 1rem;
}
```

### 4.3 `subgrid` — 중첩 요소 정렬 일치(지원 브라우저 확인)

```css
.grid-parent {
  display:grid;
  grid-template-columns: 1fr 2fr;
  gap: 1rem;
}
.child-list {
  display:grid;
  grid-template-columns: subgrid; /* 부모 열 정의 상속 */
  grid-column: 1 / -1;            /* 부모 전체 폭 사용 */
}
```

> 대안: CSS 변수를 사용해 부모 그리드 정의를 자식에 재사용.

---

## 5. 현대적 반응형 — 미디어 쿼리 + 컨테이너 쿼리 + 유동 크기

### 5.1 미디어 쿼리(전역 뷰포트 기준)

```css
@media (max-width: 48rem) { .layout { flex-direction: column; } }
```

### 5.2 **컨테이너 쿼리**(컴포넌트 자체 폭/높이 기준)

```html
<style>
  .card-grid {
    container-type: inline-size; /* 컨테이너 선언 */
    display: grid;
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  @container (min-width: 40rem) {
    .card-grid { grid-template-columns: repeat(2, 1fr); }
  }
  @container (min-width: 64rem) {
    .card-grid { grid-template-columns: repeat(3, 1fr); }
  }
</style>

<section class="card-grid">
  <article class="card">A</article>
  <article class="card">B</article>
  <article class="card">C</article>
</section>
```

### 5.3 유동 타이포·여백(안전 범위)

```css
h1 { font-size: clamp(1.8rem, 3.5vw, 3rem); }
.section { padding-block: clamp(1rem, 4vw, 3rem); }
```

---

## 6. 레이아웃 패턴 모음(실무 즉용)

### 6.1 Holy Grail(헤더/푸터 + 좌우 사이드 + 본문)

```html
<style>
  .holy {
    display:grid;
    grid-template:
      "header header header" auto
      "asideL main   asideR" 1fr
      "footer footer footer" auto
      / 240px 1fr 280px;
    min-height:100svh;
  }
  header { grid-area:header; }
  main   { grid-area:main; }
  aside.left  { grid-area:asideL; }
  aside.right { grid-area:asideR; }
  footer { grid-area:footer; }

  @media (max-width: 1100px) {
    .holy { grid-template:
      "header" auto
      "main"   auto
      "asideL" auto
      "asideR" auto
      "footer" auto / 1fr; }
  }
</style>

<div class="holy">
  <header>헤더</header>
  <aside class="left">왼쪽 사이드</aside>
  <main>본문</main>
  <aside class="right">오른쪽 사이드</aside>
  <footer>푸터</footer>
</div>
```

### 6.2 스티키 헤더/사이드바 + 스크롤 가능한 본문

```css
header { position: sticky; top: 0; z-index: 10; }
.sidebar { position: sticky; top: calc(56px + 1rem); } /* 헤더 높이 반영 */
```

### 6.3 Masonry 느낌(순수 CSS Grid 대안)

```css
.masonry {
  columns: 320px; /* 다단 컬럼 */
  column-gap: 1rem;
}
.masonry > article {
  break-inside: avoid; /* 카드 분할 방지 */
  margin-block: 0 1rem;
}
```

> 진짜 Masonry는 JS or 최신 스펙 실험적 구현 필요. 위 방식은 간편·호환성 좋음.

### 6.4 대시보드 카드(불균형 배치)

```css
.dashboard {
  display:grid;
  grid-template-columns: repeat(12, 1fr);
  gap: 1rem;
}
.card.span-6 { grid-column: span 6; }
.card.span-4 { grid-column: span 4; }
.card.span-3 { grid-column: span 3; }
```

---

## 7. 미디어·이미지 레이아웃

### 7.1 비율 고정

```css
.thumb { aspect-ratio: 16 / 9; object-fit: cover; }
.square { aspect-ratio: 1; object-fit: cover; }
```

### 7.2 아트디렉션(반응형 이미지 세트)

```html
<picture>
  <source media="(min-width: 62rem)" srcset="hero-xl.jpg">
  <source media="(min-width: 40rem)" srcset="hero-md.jpg">
  <img src="hero-sm.jpg" alt="제품 히어로 이미지" width="1200" height="600" loading="lazy">
</picture>
```

---

## 8. 스크롤·오버플로·적층 컨텍스트

```css
.scroll-x { overflow-x:auto; overscroll-behavior: contain; }
.sticky   { position: sticky; top: 0; background: #fff; }
.modal {
  position: fixed; inset: 0;
  display:grid; place-items:center;
  z-index: 1000; /* 스택 순서 명시 */
}
```

> `position`/`filter`/`transform`/`opacity` 등은 **새 적층 컨텍스트**를 생성 → 기대치 못한 z-index 충돌에 주의.

---

## 9. 접근성(a11y)·사용성·프린트

- **시맨틱**: 헤딩 레벨 계층, landmark(`header/nav/main/aside/footer`) 정확히.
- **키보드**: 포커스 이동 경로가 시각 레이아웃과 일치하도록 DOM 순서 설계.
- **색 대비/모션**: `prefers-color-scheme`, `prefers-reduced-motion` 대응.

```css
@media (prefers-color-scheme: dark) {
  :root { color-scheme: dark; }
  body { background:#111; color:#e5e5e5; }
}
@media (prefers-reduced-motion: reduce) {
  * { animation: none!important; transition: none!important; }
}
```

- **프린트**: 불필요 영역 숨기기, 링크 URL 표시.

```css
@media print {
  nav, aside, footer { display:none; }
  a[href]::after { content: " (" attr(href) ")"; font-size: .9em; }
}
```

---

## 10. 성능·유지보수 체크리스트

- [ ] **레이아웃 섞지 말기**: 복잡한 영역 배치는 Grid, 단일 줄/열 정렬은 Flex.
- [ ] **컨테이너 쿼리 우선**: 컴포넌트 독립성 ↑, 전역 브레이크포인트 남발 ↓.
- [ ] **CLS 방지**: `width/height` 또는 `aspect-ratio` 지정, 웹폰트 `font-display: swap`.
- [ ] **단위 일관성**: 여백·글꼴·그리드에 공통 스케일(예: 4/8pt).
- [ ] **디버깅**: `outline: 1px solid` 보조 클래스, 브라우저 레이아웃 오버레이 활용.

```css
/* 레이아웃 디버깅 유틸 */
.debug > * { outline: 1px dashed #8884; }
```

---

## 11. 예제: 완성형 반응형 블로그 프레임(Grid + 컨테이너 쿼리)

```html
<!doctype html>
<meta charset="utf-8">
<title>블로그 레이아웃</title>
<style>
  :root {
    --max: 72rem; --gap: clamp(.75rem, 2vw, 1.25rem);
    --radius: 12px;
  }
  * { box-sizing: border-box; }
  body { margin:0; font: 16px/1.6 system-ui, sans-serif; }
  a { color: inherit; }

  /* 프레임 */
  .shell {
    display:grid;
    grid-template:
      "header" auto
      "nav"    auto
      "main"   1fr
      "footer" auto / 1fr;
    min-height: 100svh;
  }
  header, nav, main, footer { padding-inline: var(--gap); }
  header, footer { background: #111; color:#fff; }
  header .wrap, nav .wrap, main .wrap, footer .wrap {
    inline-size: min(100% - 2*var(--gap), var(--max));
    margin-inline:auto;
  }
  header { position: sticky; top: 0; z-index: 10; }

  nav .menu {
    display:flex; gap:.75rem; overflow:auto; padding-block:.5rem;
  }

  /* 본문 그리드(컨테이너) */
  main .wrap { container-type: inline-size; }
  .grid {
    display:grid; gap: var(--gap);
    grid-template-columns: 1fr; /* 기본 1열 */
  }
  @container (min-width: 48rem) {
    .grid { grid-template-columns: 2fr 1fr; } /* 본문/사이드 */
  }

  .post, .aside { background:#f6f6f6; border-radius: var(--radius); padding: 1rem; }
  .cards {
    display:grid; gap: var(--gap);
    grid-template-columns: repeat(auto-fill, minmax(16rem, 1fr));
  }
  .card { background:#fff; border-radius: var(--radius); padding: 1rem; }

  /* 다크 모드 */
  @media (prefers-color-scheme: dark) {
    body { background:#0e0e0e; color:#e3e3e3; }
    .post, .aside { background:#181818; }
    .card { background:#111; }
  }
</style>

<div class="shell">
  <header>
    <div class="wrap">
      <h1 style="margin:0; padding-block: .75rem;">내 블로그</h1>
    </div>
  </header>

  <nav>
    <div class="wrap">
      <div class="menu">
        <a href="#">홈</a><a href="#">HTML</a><a href="#">CSS</a>
        <a href="#">JS</a><a href="#">데이터</a><a href="#">프로젝트</a>
      </div>
    </div>
  </nav>

  <main>
    <div class="wrap">
      <div class="grid">
        <article class="post">
          <h2>최신 글</h2>
          <div class="cards">
            <div class="card">카드 1</div>
            <div class="card">카드 2</div>
            <div class="card">카드 3</div>
            <div class="card">카드 4</div>
          </div>
        </article>
        <aside class="aside">
          <h3>사이드바</h3>
          <ul>
            <li>인기글</li><li>태그</li><li>링크</li>
          </ul>
        </aside>
      </div>
    </div>
  </main>

  <footer>
    <div class="wrap">
      <small>&copy; 2025 Do Hyun Kim</small>
    </div>
  </footer>
</div>
```

---

## 12. 자주 겪는 문제와 해결

| 증상 | 원인 | 해결 |
|---|---|---|
| 스티키가 동작 안 함 | 부모 `overflow`가 스크롤 컨테이너 | 부모의 `overflow` 제거·조정, `top` 값 확인 |
| 그리드 카드 고르지 않음 | 이미지 높이 가변 | `aspect-ratio` + `object-fit:cover`, 텍스트 최대줄 수 제한 |
| 모바일 주소창 높이로 레이아웃 흔들림 | `vh` 사용 | `svh/lvh/dvh` 사용 또는 패딩 기반 레이아웃 |
| z-index 충돌 | 새로운 적층 컨텍스트 생성(변환 등) | 상위 요소의 `position/transform` 확인, z-index 체계 재정렬 |
| 브레이크포인트 과도 | 전역 미디어 쿼리 남발 | 컨테이너 쿼리로 컴포넌트 자율 반응 |

---

## 13. 최종 요약

- **Flexbox**: 한 줄/한 축 배치(정렬·간격) → 카드·툴바·폼.
- **Grid**: 영역·격자(2차원) → 페이지 프레임·대시보드·목록.
- **컨테이너 쿼리**: 컴포넌트 폭 기준 반응형 → 재사용성·모듈성 향상.
- **논리적 속성·유동 함수**: 국제화·안전한 유동 스케일링.
- **접근성/성능**: 시맨틱 구조, 포커스/대비, CLS 예방, 다크/감속 모션.

이 가이드를 기반으로 **구조적이고 확장 가능한 레이아웃 시스템**을 설계하면, 디자인 변경·기기 다양성·콘텐츠 증가에 유연하게 대응할 수 있다.
