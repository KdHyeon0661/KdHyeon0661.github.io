---
layout: post
title: 파이썬 심화 - 자료구조와 알고리즘 (1)
date: 2025-11-26 14:25:23 +0900
category: 파이썬 심화
---
# 자료구조와 알고리즘 (1)

파이썬에서 데이터를 효율적으로 처리하기 위해 자주 사용하는 여러 가지 고급 기법들이 있습니다. 각 방법들은 특정 상황에서 코드의 가독성과 성능을 크게 향상시킬 수 있습니다.

## 시퀀스를 개별 변수로 언패킹하기

파이썬의 언패킹(unpacking) 기능은 시퀀스(리스트, 튜플 등)의 요소들을 개별 변수에 할당하는 편리한 방법을 제공합니다.

```python
# 기본 언패킹
data = [1, 2, 3]
x, y, z = data
print(f"x={x}, y={y}, z={z}")

# 중간 요소 건너뛰기
record = ('홍길동', 'developer@example.com', '010-1234-5678', '02-9876-5432')
name, email, *phone_numbers = record
print(name)  # 홍길동
print(phone_numbers)  # ['010-1234-5678', '02-9876-5432']

# 중첩 구조 언패킹
records = [('foo', 1, 2), ('bar', 'hello'), ('foo', 3, 4)]
for tag, *args in records:
    if tag == 'foo':
        print(f"foo: {args}")
```

## 이터러블 객체의 요소 분할하기

큰 이터러블 객체를 효율적으로 처리하기 위해 필요한 만큼의 요소만 분할하여 가져오는 방법입니다. 특히 메모리 효율성 측면에서 유용합니다.

```python
def chunk_iterator(iterable, size):
    """이터러블을 지정된 크기의 청크로 나눕니다."""
    it = iter(iterable)
    chunk = list(islice(it, size))
    while chunk:
        yield chunk
        chunk = list(islice(it, size))

# 파일에서 큰 데이터를 청크 단위로 처리
def read_large_file(file_path, chunk_size=1000):
    with open(file_path, 'r', encoding='utf-8') as f:
        for chunk in chunk_iterator(f, chunk_size):
            process_chunk(chunk)  # 각 청크 처리
```

## 최근 N개 아이템 유지하기

`collections.deque`는 최대 길이를 지정하면 자동으로 오래된 항목을 제거하면서 최근 항목만 유지하는 순환 버퍼를 구현합니다.

```python
from collections import deque

def search(lines, pattern, history=5):
    """검색 결과와 최근 검색 히스토리를 반환합니다."""
    previous_lines = deque(maxlen=history)
    for line in lines:
        if pattern in line:
            yield line, previous_lines
        previous_lines.append(line)

# 최근 N개 아이템에 대한 통계 계산
def moving_average(iterable, n=3):
    """이동 평균 계산"""
    d = deque(maxlen=n)
    for item in iterable:
        d.append(item)
        yield sum(d) / len(d) if len(d) == n else None
```

## N개 아이템의 최대값 또는 최소값 찾기

`heapq` 모듈은 큰 컬렉션에서 N개의 최대값이나 최소값을 효율적으로 찾을 수 있습니다.

```python
import heapq

# 가장 큰 N개의 값 찾기
portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]

# 가장 비싼 3개 주식
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
```

## 우선순위 큐 구현하기

우선순위 큐는 항상 정렬 순서대로 아이템을 반환하는 자료구조로, `heapq` 모듈을 사용하여 효율적으로 구현할 수 있습니다.

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0  # 동일 우선순위 항목 구분용
    
    def push(self, item, priority):
        """항목을 우선순위 큐에 추가"""
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1
    
    def pop(self):
        """가장 높은 우선순위의 항목을 제거하고 반환"""
        return heapq.heappop(self._queue)[-1]
    
    def is_empty(self):
        return len(self._queue) == 0
```

## 딕셔너리 키를 여러 값에 매핑하기

하나의 키에 여러 값을 연결해야 할 때는 `defaultdict`나 `set`, `list`를 활용할 수 있습니다.

```python
from collections import defaultdict

# 하나의 키에 여러 값을 저장하는 딕셔너리
d = defaultdict(list)  # 값의 순서가 중요할 때
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)

s = defaultdict(set)   # 값의 중복을 피하고자 할 때
s['a'].add(1)
s['a'].add(2)
s['a'].add(1)  # 중복 추가는 무시됨

# 일반 딕셔너리로 구현
pairs = [('a', 1), ('a', 2), ('b', 4)]
d = {}
for key, value in pairs:
    if key not in d:
        d[key] = []
    d[key].append(value)
```

## 딕셔너리의 순서 유지하기

Python 3.7부터 기본 딕셔너리가 삽입 순서를 보존하지만, 명시적으로 `OrderedDict`를 사용할 수도 있습니다.

```python
from collections import OrderedDict

# 정렬된 딕셔너리
d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4

for key in d:
    print(key, d[key])
# 출력: foo 1, bar 2, spam 3, grok 4 (삽입 순서 유지)

# JSON 직렬화 시 순서 유지
import json
json.dumps(d)  # {"foo": 1, "bar": 2, "spam": 3, "grok": 4}
```

## 딕셔너리 연산 수행하기

딕셔너리 데이터에 대한 다양한 계산(최소값, 최대값, 정렬 등)을 효율적으로 수행하는 방법입니다.

```python
prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}

# 최소값과 최대값 찾기
min_price = min(zip(prices.values(), prices.keys()))
max_price = max(zip(prices.values(), prices.keys()))

# 값으로 딕셔너리 정렬하기
prices_sorted = sorted(zip(prices.values(), prices.keys()))

# 딕셔너리 부분집합 추출
p1 = {key: value for key, value in prices.items() if value > 200}
p2 = dict((key, value) for key, value in prices.items() if value > 200)
```

## 두 딕셔너리의 공통점 찾기

두 딕셔너리가 공유하는 키나 값을 찾는 방법으로 집합 연산을 활용할 수 있습니다.

```python
a = {'x': 1, 'y': 2, 'z': 3}
b = {'w': 10, 'x': 11, 'y': 2}

# 공통 키 찾기
common_keys = a.keys() & b.keys()  # {'x', 'y'}

# a에만 있는 키
a_keys = a.keys() - b.keys()  # {'z'}

# 특정 키를 제외한 공통 항목
common_items = a.items() & b.items()  # {('y', 2)}

# 새로운 딕셔너리 생성 (특정 키 제거)
c = {key: a[key] for key in a.keys() - {'z', 'w'}}  # {'x': 1, 'y': 2}

# 값 기준 공통점 찾기
common_values = set(a.values()) & set(b.values())  # {2}
```

## 결론

이러한 파이썬 데이터 처리 기법들은 단순히 코드를 짧게 만드는 것 이상의 의미가 있습니다. 각 방법은 특정 문제 상황에 최적화되어 있어 코드의 가독성을 높이고 실행 효율을 개선하며, 메모리 사용을 최적화하는 데 도움을 줍니다. 데이터 분석, 웹 개발, 시스템 프로그래밍 등 다양한 분야에서 이러한 기법들을 적절히 활용하면 더 견고하고 효율적인 애플리케이션을 개발할 수 있습니다. 특히 대용량 데이터를 처리해야 하는 현대적인 애플리케이션에서는 이러한 고급 기법들의 중요성이 더욱 부각됩니다.