---
layout: post
title: Avalonia - 패키지 모듈화 전략
date: 2025-03-17 21:20:23 +0900
category: Avalonia
---
# Avalonia 앱의 패키지 모듈화 전략 (Avalonia.Modules, NuGet)

## 목표와 원칙

| 목표 | 설명 |
|------|------|
| 기능별 프로젝트 분리 | View, ViewModel, Model, Service, Converter, Command 등 명확히 분할 |
| 재사용 가능한 컴포넌트화 | 모듈을 독립 NuGet 패키지로 배포하여 다른 앱에서도 동일 코드 재사용 |
| 유지보수성/테스트성 | 각 모듈을 독립적으로 빌드/테스트/릴리스. 작은 단위의 변경과 빠른 릴리스 가능 |
| 안정적 통합 | 공통 DI/네비/테마/리소스 규칙으로 “합체가 쉬운” 모듈 계약 제공 |
| 호환성/버저닝 | SemVer, API 호환 가이드, 의존성 범위, 마이그레이션 노트 제공 |

---

## 최상위 레이아웃(예시)

```
MyApp/
 ├─ MainApp/                        # 실행 프로젝트(Avalonia.Desktop)
 │   ├─ App.xaml(.cs)
 │   ├─ Program.cs
 │   ├─ MainApp.csproj
 │   └─ CompositionRoot/            # DI/네비/테마/리소스 등록
 │
 ├─ Modules/
 │   ├─ Dashboard/
 │   │   ├─ Views/
 │   │   ├─ ViewModels/
 │   │   ├─ Models/
 │   │   ├─ Services/
 │   │   ├─ Assets/                 # icons, styles, axaml resource
 │   │   ├─ DashboardModule.csproj
 │   │   └─ ModuleStartup.cs        # IModule 구현: DI/리소스 등록 지점
 │   ├─ Reports/
 │   │   └─ ReportsModule.csproj
 │   └─ Shared/
 │       └─ MyApp.Modules.Abstractions.csproj  # IModule, 라우팅/메시지 계약 등
 │
 ├─ Common/
 │   ├─ Controls/                   # 재사용 컨트롤
 │   ├─ Converters/
 │   ├─ Themes/
 │   └─ Common.csproj               # 공통 라이브러리(패키지 가능)
 │
 ├─ Build/
 │   └─ Directory.Build.props       # 버전/SourceLink/Analyzer 공통 규칙
 │
 └─ NuGet.Config                    # 로컬/NuGet/GitHub 소스 등록
```

핵심: **Modules** 아래 각 기능은 독립 `.csproj`이며, **Abstractions** 프로젝트에 “공통 계약(인터페이스/DTO/이벤트/라우팅 키)”를 모아 **순환참조 없이** 조립한다.

---

## 모듈 프로젝트 `.csproj` 템플릿

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>

    <!-- Avalonia XAML 컴파일 -->
    <AvaloniaUseCompiledXaml>true</AvaloniaUseCompiledXaml>

    <!-- 패키지 설정 -->
    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
    <PackageId>MyApp.Modules.Dashboard</PackageId>
    <Version>1.0.0</Version>
    <Authors>Team</Authors>
    <Company>MyOrg</Company>
    <Description>Avalonia Dashboard module for MyApp</Description>
    <RepositoryUrl>https://github.com/myorg/myapp</RepositoryUrl>
    <PackageReadmeFile>README.md</PackageReadmeFile>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageIcon>icon.png</PackageIcon>

    <!-- 소스 링크/심볼 -->
    <PublishRepositoryUrl>true</PublishRepositoryUrl>
    <EmbedUntrackedSources>true</EmbedUntrackedSources>
    <IncludeSymbols>true</IncludeSymbols>
    <SymbolPackageFormat>snupkg</SymbolPackageFormat>

    <!-- 강력한 이름 서명(선택) -->
    <!--
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>..\..\Build\mykey.snk</AssemblyOriginatorKeyFile>
    -->
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Avalonia" Version="11.0.0" />
    <PackageReference Include="Avalonia.ReactiveUI" Version="11.0.0" />
    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.2.2" />
    <PackageReference Include="Microsoft.SourceLink.GitHub" Version="8.0.0" PrivateAssets="All" />
  </ItemGroup>

  <ItemGroup>
    <None Include="README.md" Pack="true" PackagePath="" />
    <None Include="icon.png" Pack="true" PackagePath="" />
  </ItemGroup>

</Project>
```

포인트:
- `AvaloniaUseCompiledXaml=true`로 axaml 빌드 시간 안전성↑, 배포 크기↓
- `GeneratePackageOnBuild=true`로 CI에서 자동 패키지 생성
- SourceLink/심볼: 디버깅·추적 품질↑
- 라이선스/아이콘/README 포함으로 패키지 품질↑

---

## 모듈 내부 규약(코딩 규약)

### 네임스페이스/폴더 규칙

- `MyApp.Modules.<Feature>.*`
- `Views`, `ViewModels`, `Models`, `Services`, `Converters`, `Resources(axaml, styles)` 정리

### View ↔ ViewModel 컨벤션

- View: `DashboardView.axaml`, VM: `DashboardViewModel.cs`
- `ViewLocator`가 `*ViewModel` → `*View` 매핑을 자동으로 찾는 규칙(아래 §9 참조)

### 리소스/스타일 번들

- `Assets/Styles.axaml`, `Assets/Icons/…` → `ResourceInclude`로 합치기
- 모듈에서 제공하는 테마/스타일은 **이름 충돌 방지**를 위해 `x:Key` 네임스페이스 접두사 사용 권장

```xml
<!-- Assets/Styles.axaml -->
<ResourceDictionary xmlns="https://github.com/avaloniaui">
  <Style x:Key="Dashboard.CardTitle" Selector="TextBlock.card-title">
    <Setter Property="FontSize" Value="18"/>
    <Setter Property="FontWeight" Value="SemiBold"/>
  </Style>
</ResourceDictionary>
```

모듈 `ModuleStartup`에서 앱의 `Styles`에 주입(§7 참조).

---

## 모듈 Startup 계약 — IModule

### Abstractions 정의

```csharp
namespace MyApp.Modules.Abstractions;

public interface IModule
{
    string Name { get; }
    Version Version { get; }
    void RegisterServices(IServiceCollection services);
    void RegisterRoutes(IModuleRouteRegistry routes);
    void RegisterResources(IResourceRegistry resources); // Styles/Assets
}
```

- DI/라우팅/리소스 등록을 분리하여 **MainApp의 CompositionRoot**에서 일괄 호출.

### 라우팅/리소스 레지스트리 계약

```csharp
public interface IModuleRouteRegistry
{
    void Map(string route, Func<IServiceProvider, object> vmFactory);
}

public interface IResourceRegistry
{
    void AddStyle(Uri axamlResourceUri);
}
```

---

## 모듈 구현 예시 — Dashboard

### ViewModel/Service

```csharp
// ViewModels/DashboardViewModel.cs
public sealed class DashboardViewModel : ObservableObject
{
    private readonly IDashboardService _svc;
    public ObservableCollection<ChartPoint> Points { get; } = new();

    public DashboardViewModel(IDashboardService svc)
    {
        _svc = svc;
        Load();
    }

    private async void Load()
    {
        var data = await _svc.GetPointsAsync();
        Points.Clear();
        foreach (var p in data) Points.Add(p);
    }
}

// Services/IDashboardService.cs
public interface IDashboardService
{
    Task<IReadOnlyList<ChartPoint>> GetPointsAsync();
}

// Services/DashboardService.cs
public sealed class DashboardService : IDashboardService
{
    public Task<IReadOnlyList<ChartPoint>> GetPointsAsync()
        => Task.FromResult<IReadOnlyList<ChartPoint>>(new[]
        {
            new ChartPoint(0, 10), new ChartPoint(1, 14), new ChartPoint(2, 8)
        });
}

public readonly record struct ChartPoint(double X, double Y);
```

### View

```xml
<!-- Views/DashboardView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:d="https://github.com/avaloniaui"
             xmlns:vm="clr-namespace:MyApp.Modules.Dashboard.ViewModels">
  <UserControl.d:DataContext>
    <vm:DashboardViewModel />
  </UserControl.d:DataContext>

  <StackPanel Margin="16" Spacing="8">
    <TextBlock Classes="card-title"
               Text="Dashboard"
               FontSize="20" />
    <ItemsControl Items="{Binding Points}">
      <ItemsControl.ItemTemplate>
        <DataTemplate>
          <TextBlock Text="{Binding Y}" />
        </DataTemplate>
      </ItemsControl.ItemTemplate>
    </ItemsControl>
  </StackPanel>
</UserControl>
```

### ModuleStartup

```csharp
using MyApp.Modules.Abstractions;
using Microsoft.Extensions.DependencyInjection;

public sealed class DashboardModule : IModule
{
    public string Name => "Dashboard";
    public Version Version => new(1, 0, 0);

    public void RegisterServices(IServiceCollection services)
    {
        services.AddTransient<IDashboardService, DashboardService>();
        services.AddTransient<DashboardViewModel>();
        services.AddTransient<DashboardView>();
    }

    public void RegisterRoutes(IModuleRouteRegistry routes)
    {
        routes.Map("dashboard", sp => sp.GetRequiredService<DashboardViewModel>());
    }

    public void RegisterResources(IResourceRegistry resources)
    {
        resources.AddStyle(new Uri("avares://MyApp.Modules.Dashboard/Assets/Styles.axaml"));
    }
}
```

---

## MainApp 통합 — CompositionRoot

### 레지스트리 구현

```csharp
public sealed class ModuleRouteRegistry : IModuleRouteRegistry
{
    private readonly Dictionary<string, Func<IServiceProvider, object>> _routes = new();
    public void Map(string route, Func<IServiceProvider, object> vmFactory) => _routes[route] = vmFactory;
    public object Resolve(string route, IServiceProvider sp) => _routes[route](sp);
}

public sealed class ResourceRegistry : IResourceRegistry
{
    private readonly Application _app;
    public ResourceRegistry(Application app) => _app = app;
    public void AddStyle(Uri axamlResourceUri)
    {
        var include = new StyleInclude(axamlResourceUri) { Source = axamlResourceUri };
        _app.Styles.Add(include);
    }
}
```

### 모듈 수동 등록(패키지 참조 시)

```csharp
var services = new ServiceCollection();
var routes = new ModuleRouteRegistry();
var resources = new ResourceRegistry(Application.Current!);

var modules = new IModule[]
{
    new MyApp.Modules.Dashboard.DashboardModule(),
    // 다른 모듈들...
};

foreach (var m in modules)
{
    m.RegisterServices(services);
    m.RegisterRoutes(routes);
    m.RegisterResources(resources);
}

var provider = services.BuildServiceProvider();
```

### 런타임 동적 검색(선택, 고급)

패키지 참조 대신 **폴더의 어셈블리 스캔**으로 모듈을 주입할 수도 있다(플러그인 유사).

```csharp
static IEnumerable<IModule> DiscoverModules(string folder)
{
    if (!Directory.Exists(folder)) yield break;
    foreach (var dll in Directory.GetFiles(folder, "*.dll"))
    {
        var asm = AssemblyLoadContext.Default.LoadFromAssemblyPath(Path.GetFullPath(dll));
        foreach (var t in asm.GetTypes())
        {
            if (!typeof(IModule).IsAssignableFrom(t) || t.IsAbstract) continue;
            yield return (IModule)Activator.CreateInstance(t)!;
        }
    }
}
```

> 보안·호환성·충돌을 고려해야 하므로, 운영 환경에서는 **서명 검증/허용 목록**과 함께 사용 권장.

---

## ViewLocator/VM Locator — 느슨한 결합

```csharp
public sealed class ViewLocator : IDataTemplate
{
    public IControl Build(object? data)
    {
        if (data is null) return new TextBlock { Text = "null" };
        var name = data.GetType().FullName!.Replace("ViewModel", "View");
        var type = Type.GetType(name);
        if (type is null) return new TextBlock { Text = $"not found: {name}" };
        return (Control)Activator.CreateInstance(type)!;
    }

    public bool Match(object? data) => data is not null;
}
```

App.xaml에서 등록:

```xml
<Application xmlns="https://github.com/avaloniaui">
  <Application.DataTemplates>
    <local:ViewLocator />
  </Application.DataTemplates>
</Application>
```

---

## 디자인 타임/샘플 데이터

- 모듈 단위로 `*ViewModelDesign`을 제공. XAML `d:DataContext`에 연결.
- 디자인 모드 분기:

```csharp
if (Design.IsDesignMode)
{
    // 더미 서비스 등록 또는 샘플 데이터 주입
}
```

---

## 테스트 전략 (모듈 단위)

- 각 모듈은 자체 `*.Tests` 프로젝트를 둔다.
- VM/Service 테스트 시 DI를 통해 더블/Mock 주입.
- XAML은 스냅샷 테스트나, 핵심 로직은 VM 테스트로 커버.

```csharp
public sealed class DashboardTests
{
    [Fact]
    public async Task LoadsPoints()
    {
        var svc = Substitute.For<IDashboardService>();
        svc.GetPointsAsync().Returns(Task.FromResult<IReadOnlyList<ChartPoint>>(new[] { new ChartPoint(0, 1) }));

        var vm = new DashboardViewModel(svc);
        await Task.Delay(10); // Load() async

        vm.Points.Should().ContainSingle(p => p.Y == 1);
    }
}
```

---

## 패키징/배포 — NuGet

### pack/push

```bash
# 패키지 생성

dotnet pack Modules/Dashboard/DashboardModule.csproj -c Release

# 로컬 폴더(캐시형)로 복사

mkdir -p C:\LocalPackages
copy Modules\Dashboard\bin\Release\*.nupkg C:\LocalPackages

# GitHub/nuget.org 푸시(토큰 필요)

dotnet nuget push *.nupkg --source "github"
# 또는

dotnet nuget push *.nupkg --source "nuget.org" --api-key <NUGET_API_KEY>
```

### NuGet.Config

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="Local" value="C:\LocalPackages" />
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
    <!-- GitHub Packages 예시
    <add key="github" value="https://nuget.pkg.github.com/myorg/index.json" />
    -->
  </packageSources>
</configuration>
```

---

## CI/CD — GitHub Actions 예시

```yaml
name: Modules CI

on:
  push:
    paths:
      - 'Modules/**'
      - '.github/workflows/modules.yml'
  pull_request:

jobs:
  build-pack:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
      - name: Restore
        run: dotnet restore
      - name: Build
        run: dotnet build -c Release --no-restore
      - name: Test
        run: dotnet test -c Release --no-build --verbosity normal
      - name: Pack
        run: dotnet pack Modules/Dashboard/DashboardModule.csproj -c Release -o artifacts
      - name: Publish to NuGet
        if: startsWith(github.ref, 'refs/tags/')
        run: dotnet nuget push artifacts\*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json
```

포인트:
- 태그 커밋에서만 공개 배포.
- 프리릴리스(`-beta`)는 브랜치/tag 규칙으로 분리.

---

## 버저닝/호환성(핵심)

- **SemVer**: `MAJOR.MINOR.PATCH`
  - **MAJOR**: 공용 API 파괴적 변경(타 모듈/앱 깨질 수 있음)
  - **MINOR**: 하위호환 추가(새 View/서비스/옵션)
  - **PATCH**: 버그 수정, 내부 최적화
- **호환성 규약**:
  - Abstractions(계약) 프로젝트는 **보수적 변경** 유지
  - MainApp과 모듈의 Avalonia/.NET 버전 범위 **명시**
  - `PackageReference`에 범위 지정: `<Version>[11.0.0,12.0.0)</Version>` 식
- **변경 로그/마이그레이션 가이드**를 릴리스에 첨부

---

## 리소스/테마 결합(고급)

### 모듈 테마를 App에 주입

```csharp
resources.AddStyle(new Uri("avares://MyApp.Modules.Dashboard/Assets/Styles.axaml"));
```

### 이름 충돌 방지

- 컨트롤 클래스/스타일 키에 접두사: `Dashboard.*`
- 글로벌 키는 자제, 필요한 경우 별도 Dictionary로 범위 한정

---

## 모듈 간 메시징(옵션) — Mediator/EventBus

Abstractions:

```csharp
public interface IAppEvent {}
public interface IEventBus
{
    void Publish(IAppEvent e);
    IObservable<T> Observe<T>() where T : IAppEvent;
}
```

구현은 Common에 두고, 모듈끼리 **느슨하게 통신**(의존성 최소화).
예: 대시보드가 “리포트 생성 완료” 이벤트를 발행, 다른 모듈이 구독.

---

## 런타임 동적 로딩(옵션)

- 어셈블리 서명·해시 검증, 신뢰된 공급자만 로드
- `AssemblyLoadContext`로 **고립 로딩**하여 버전 충돌/언로드 고려
- 모듈 메타데이터(JSON manifest) → Name/Version/Required-Avalonia/Permissions 등

```json
{
  "name": "Dashboard",
  "version": "1.2.0",
  "requiredAvalonia": "11.x",
  "routes": ["dashboard"],
  "resources": ["avares://.../Assets/Styles.axaml"]
}
```

> 운영 환경에선 **정적 패키지 참조**가 가장 안전/예측 가능. 동적 로딩은 플러그인 성격일 때만 신중히 도입.

---

## 성능/배포 최적화

- 단일파일(Self-contained) 빌드 시 모듈도 함께 포함.
- 다중 모듈이 공통 패키지 버전을 공유하도록 **Directory.Build.props**로 상향 통제.
- AOT/트리밍 고려 시 **리플렉션 사용 코드**에 `DynamicDependency`, `linker.xml` 등 보완.

---

## 예시: MainApp에서 라우팅/네비게이션

```csharp
public sealed class ShellViewModel : ObservableObject
{
    private readonly IServiceProvider _sp;
    private readonly ModuleRouteRegistry _routes;

    private object? _currentViewModel;
    public object? CurrentViewModel
    {
        get => _currentViewModel;
        set => SetProperty(ref _currentViewModel, value);
    }

    public ShellViewModel(IServiceProvider sp, ModuleRouteRegistry routes)
    {
        _sp = sp; _routes = routes;
        Navigate("dashboard");
    }

    public void Navigate(string route)
        => CurrentViewModel = _routes.Resolve(route, _sp);
}
```

```xml
<!-- ShellView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui">
  <ContentControl Content="{Binding CurrentViewModel}" />
</UserControl>
```

---

## 로컬 개발 루프(패키지 없이 프로젝트 참조)

- 모듈을 **ProjectReference**로 직접 연결하여 핫리로드/디버그를 빠르게
- 릴리스 직전 CI에서 pack → 배포 저장소 → MainApp은 패키지 버전 고정

`MainApp.csproj`:

```xml
<ItemGroup>
  <ProjectReference Include="..\Modules\Dashboard\DashboardModule.csproj" />
</ItemGroup>
```

릴리스 시:

```xml
<ItemGroup>
  <PackageReference Include="MyApp.Modules.Dashboard" Version="1.0.0" />
</ItemGroup>
```

---

## 실전 체크리스트

- [ ] Abstractions에 계약을 모아 순환참조 방지
- [ ] 각 모듈은 IModule로 DI/라우팅/리소스 등록 제공
- [ ] ViewLocator 규약으로 View/VM 자동 결합
- [ ] 디자인타임 데이터(d:DataContext) 준비
- [ ] 단위 테스트(모듈별) + 통합 테스트(핵심 플로우)
- [ ] SemVer/변경로그/의존성 범위/호환성 문서화
- [ ] CI: build/test/pack/publish, 태그 릴리스만 공개 배포
- [ ] SourceLink/심볼/서명/라이선스/아이콘/README 포함
- [ ] 보안: 동적 로딩 시 서명·화이트리스트·격리 고려

---

## 결론

- Avalonia 애플리케이션을 **모듈 단위**로 나누고, 각 모듈을 **NuGet 패키지**로 배포하면 재사용성·테스트성·협업 속도·배포 민첩성 모두를 확보할 수 있다.
- 핵심은 **IModule 계약**으로 **DI/라우팅/리소스**를 표준화하고, **Abstractions**에 공통 프로토콜을 모아 **느슨한 결합**을 유지하는 것이다.
- CI/CD와 버저닝 규율(변경 로그/호환성 가이드)을 깔끔히 운영하면, 대규모 앱에서도 **안정적 확장**이 가능하다.
