---
layout: post
title: 이산수학 - 포함-배제 원리의 응용
date: 2025-06-21 23:20:23 +0900
category: 이산수학
---
# 포함-배제 원리의 응용 (Applications of Inclusion–Exclusion, PIE)

## 핵심 직관

- “**다 더한다(포함)** → **겹친 것 뺀다(배제)** → **너무 뺐으면 다시 더한다** … 부호를 번갈아 적용”
- \(A_i\)가 조건(또는 사건)일 때,
  $$
  \left|\bigcup_{i=1}^m A_i\right|
  = \sum_i |A_i| - \sum_{i<j}|A_i\cap A_j| + \cdots + (-1)^{m+1}|A_1\cap\cdots\cap A_m|.
  $$

---

## 응용 1 — “**적어도 하나**의 조건을 만족” (배수 문제)

**문제**: \(1\le x\le 100\) 중 **2,3,5의 배수 중 하나 이상**인 수의 개수?

- \(A=\{2\mid x\}\), \(B=\{3\mid x\}\), \(C=\{5\mid x\}\):
  $$
  |A|=\left\lfloor\frac{100}{2}\right\rfloor=50,\quad
  |B|=33,\quad |C|=20
  $$
  $$
  |A\cap B|=\left\lfloor\frac{100}{6}\right\rfloor=16,\;
  |A\cap C|=10,\;
  |B\cap C|=6,\;
  |A\cap B\cap C|=\left\lfloor\frac{100}{30}\right\rfloor=3.
  $$
- 정답:
  $$
  50+33+20-16-10-6+3=74.
  $$

---

## 응용 2 — “**하나도 만족하지 않음**”은 보수로

- 전체 100개에서 “적어도 하나 만족(=74)”을 빼면
  $$
  100-74=26.
  $$
- **전략**: “하나도 만족하지 않음” = **전체 − (적어도 하나 만족)**.

---

## 응용 3 — **문자열/알파벳 제약** (A,B,C 중 적어도 하나 포함)

**문제**: 알파벳 26자에서 길이 5 문자열 중 **A 또는 B 또는 C**를 **적어도 1회 포함**?

- 전체: \(26^5\).
- A,B,C를 전혀 포함하지 않으면 가능한 문자는 23개 → \(23^5\).
- 정답(보수):
  $$
  26^5 - 23^5.
  $$
- 동일 아이디어로 “**대문자/소문자/숫자** 각각 최소 1회 포함”도 가능(§9 템플릿 코드).

---

## 응용 4 — **서로 다른 숫자의 3자리 수**

- 정면 해법(순열): \(A\in\{1..9\}\) 9가지, \(B\in\{0..9\}\setminus\{A\}\) 9가지, \(C\)는 8가지 → \(9\cdot9\cdot8=648\).
- **PIE로도** 가능하지만, 구조가 단순할 땐 순열/조합 공식을 쓰는 게 실무적으로 효율.

---

## 응용 5 — **정수론: 배수/공배수 & 오일러 피함수**

### 배수의 포함-배제 (일반 N, 다수의 약수)

- \(A_i=\{x\le N: d_i\mid x\}\Rightarrow |A_{i_1}\cap\cdots\cap A_{i_k}|=\left\lfloor \dfrac{N}{\mathrm{lcm}(d_{i_1},\dots,d_{i_k})}\right\rfloor\).
- 그대로 PIE 적용(아래 LCM-DFS 코드로 대형 입력 대응).

### — PIE에서 유도

- \(p_1,\dots,p_\ell\) — \(n\)의 서로 다른 소인수, \(A_i=\{1\le x\le n: p_i\mid x\}\).
- PIE로
  $$
  \varphi(n)
  = n - \sum_i \left\lfloor\frac{n}{p_i}\right\rfloor + \sum_{i<j}\left\lfloor\frac{n}{p_ip_j}\right\rfloor - \cdots
  = n\prod_{p\mid n}\Bigl(1-\frac{1}{p}\Bigr).
  $$

**코드(빠른 \(\varphi\))**:
```python
def phi(n: int) -> int:
    x, ans, p = n, n, 2
    while p*p <= x:
        if x % p == 0:
            ans -= ans // p
            while x % p == 0: x //= p
        p += 1
    if x > 1: ans -= ans // x
    return ans
```

---

## 응용 6 — **조합적 카운팅의 대표작: 전사 함수/데랑주망**

### 함수 \([n]\to[m]\)

- “적어도 하나의 공역 원소를 **아무도 고르지 않음**”을 제거:
  $$
  \#\{\text{onto}\} = \sum_{j=0}^{m} (-1)^j \binom{m}{j}(m-j)^n = m!\,S(n,m).
  $$
- **코드**:
```python
from math import comb
def onto_count(n: int, m: int) -> int:
    return sum(((-1)**j) * comb(m, j) * (m-j)**n for j in range(m+1))
```

### \(!n\)

- \(A_i\): i가 고정점 → \(|A_i|=(n-1)!\), \(|A_{i_1}\cap\cdots\cap A_{i_k}|=(n-k)!\)
  $$
  !n = \sum_{k=0}^{n} (-1)^k \binom{n}{k} (n-k)! = n!\sum_{k=0}^{n} \frac{(-1)^k}{k!}.
  $$

**코드**:
```python
import math
def derangements(n: int) -> int:
    s = sum(((-1)**k)/math.factorial(k) for k in range(n+1))
    return round(math.factorial(n)*s)
```

---

## 응용 7 — **정확히 \(t\)개의 조건을 만족**하는 개수

- \(A_1,\dots,A_m\)가 “만족” 조건. \(N(J)=\bigl|\cap_{j\in J} A_j\bigr|\).
- **크기만 의존**하는 대칭 상황(=모든 \(|J|=k\)에서 \(N(J)\) 동일)이라면
  $$
  S_k := \sum_{|J|=k} N(J)
  \quad\text{(교집합 총합)}
  $$
  일 때,
  $$
  \#\{\text{정확히 }t\text{개 만족}\}
  = \sum_{j=t}^{m} (-1)^{j-t}\binom{j-1}{t-1} S_j.
  $$
- **해설**: “적어도 \(t\)”에 PIE를 적용하고, \(\#(\text{정확히 }t)=\#(\text{적어도 }t)-\#(\text{적어도 }t+1)\)로 정리하면 위 계수가 나온다.

**코드(템플릿)**:
```python
from math import comb
def exactly_t_from_S(S: list[int], m: int, t: int) -> int:
    # S[k] = sum over |J|=k of |∩_{j∈J} A_j|  (1<=k<=m), 0-index는 더미
    ans = 0
    for j in range(t, m+1):
        ans += ((-1)**(j-t)) * comb(j-1, t-1) * S[j]
    return ans
```

---

## 응용 8 — **확률/신뢰성 & Bonferroni 경계**

- 사건 \(A_i\). 연합 확률:
  $$
  \mathbb{P}\Big(\bigcup_i A_i\Big) = \sum_i p_i - \sum_{i<j} p_{ij} + \sum_{i<j<k} p_{ijk} - \cdots
  $$
- 고차 교항이 **모델링/측정 곤란**할 때:
  - **상한**: \(S_1 - S_2 + \cdots + S_{2t-1}\),
  - **하한**: \(S_1 - S_2 + \cdots - S_{2t}\).
- **실전**: “사고/장애 최소 1회 발생 확률”의 대략적 경계로 자주 사용.

---

## 알고리즘 관점 — **비트마스크 PIE / LCM-DFS / SOS-DP**

### 비트마스크 PIE (조건 수 \(m\)이 작을 때)

- 조건 집합 \(\{0,\dots,m-1\}\)의 **부분집합**을 마스크 \(S\)로 표현.
- “교집합 크기”를 **함수**로 제공하면 일반 PIE를 바로 적용.

**템플릿**:
```python
from itertools import combinations

def inclusion_exclusion(m: int, intersection_size):
    """
    intersection_size(S: int mask) -> |∩_{i in S} A_i|
    반환: |⋃ A_i|
    """
    ans = 0
    for r in range(1, m+1):
        for comb_idx in combinations(range(m), r):
            S = 0
            for i in comb_idx: S |= 1<<i
            cnt = intersection_size(S)
            ans += cnt if (r % 2 == 1) else -cnt
    return ans
```

**예시(언어 문제 스케치)**
학생의 언어 mask를 \(M_s\)라 하면, 특정 언어 집합 \(S\)를 **모두 공통으로 아는** 학생 조합 수는 \(M_s\)의 **AND**가 \(S\)의 모든 비트를 포함해야 하므로, 집합/조합 카운팅을 곱/합으로 정의해 `intersection_size(S)`를 만들면 된다(데이터 크기에 따라 조합 카운팅은 DP/누적합 필요).

---

### LCM-DFS (배수 카운팅의 대형 입력 최적화)

**아이디어**: LCM이 \(>N\) 되면 이후 가지는 모두 0 → **가지치기**.

```python
from math import gcd

def count_multiples_lcm_dfs(N: int, divs: list[int]) -> int:
    divs = sorted(set(divs))
    ans = 0
    def dfs(i: int, cur_lcm: int, parity: int):
        nonlocal ans
        if i == len(divs):
            if cur_lcm > 1:
                ans += (N // cur_lcm) * (1 if parity else -1)
            return
        # skip i
        dfs(i+1, cur_lcm, parity)
        # take i
        d = divs[i]
        g = gcd(cur_lcm, d)
        nxt = cur_lcm // g * d
        if nxt <= N:
            dfs(i+1, nxt, parity ^ 1)
    dfs(0, 1, 0)
    return ans
```

---

### & 모비우스 반전

- 부분집합 격자에서의 **포함–배제 = 모비우스 반전**.
- 교집합/초집합 합을 **\(O(m2^m)\)**에 전역 처리.

```python
def zeta_superset(F):
    # F[S] = sum_{T⊇S} f(T)
    n = (len(F)-1).bit_length()
    for b in range(n):
        for S in range(len(F)):
            if (S>>b)&1 == 0:
                F[S] += F[S | (1<<b)]
    return F

def mobius_superset(F):
    # inverse
    n = (len(F)-1).bit_length()
    for b in range(n):
        for S in range(len(F)):
            if (S>>b)&1 == 0:
                F[S] -= F[S | (1<<b)]
    return F
```

> **언제 유용?** 교집합 크기가 “특정 속성들의 초집합 합” 형태로 주어질 때, PIE를 전역 변환으로 치환해 대폭 가속.

---

## 실전 예제 모음 (코드 포함)

### 배수의 포함-배제 (일반화 함수)

```python
from math import lcm
from itertools import combinations

def count_multiples(N: int, D: list[int]) -> int:
    D = [d for d in set(D) if d != 0]
    ans = 0
    m = len(D)
    for r in range(1, m+1):
        for comb in combinations(D, r):
            L = lcm(*comb)
            if L == 0: continue
            cnt = N // L
            ans += cnt if (r % 2 == 1) else -cnt
    return ans

print(count_multiples(100, [2,3,5]))  # 74
```

### — 모듈러 버전

```python
MOD = 10**9+7

def strong_password_count(L: int, U=26, Lc=26, D=10, mod=MOD) -> int:
    def pw(a): return pow(a, L, mod)
    tot = pw(U+Lc+D)
    bad1 = (pw(Lc+D) + pw(U+D) + pw(U+Lc)) % mod
    bad2 = (pw(D) + pw(U) + pw(Lc)) % mod
    return (tot - bad1 + bad2) % mod

print(strong_password_count(8))
```

### 전사 함수 브루트 검증(작은 n,m)

```python
from itertools import product

def onto_bruteforce(n: int, m: int) -> int:
    cnt = 0
    for f in product(range(m), repeat=n):
        if len(set(f)) == m: cnt += 1
    return cnt

for n,m in [(4,2),(4,3),(5,3)]:
    assert onto_count(n,m) == onto_bruteforce(n,m)
print("onto OK (small)")
```

### “정확히 t개 만족” 구현(대칭 케이스)

```python
# 예: m개의 단어 금지조건, 길이 L 문자열에서
# |∩_{|J|=k} A_J|의 합 S[k]만 안다고 할 때 exactly_t 계산

from math import comb

def exactly_t_from_S(S: list[int], m: int, t: int) -> int:
    ans = 0
    for j in range(t, m+1):
        ans += ((-1)**(j-t)) * comb(j-1, t-1) * S[j]
    return ans
```

---

## 검증 습관 — 작은 입력 브루트로 PIE 확인

**예**: 길이 \(n\)의 0/1 문자열에서 “0과 1을 **모두** 포함” 개수

- PIE 보수: \(2^n - 2\) (전부 0 또는 전부 1 제외).
- 브루트 비교:

```python
def brute(n: int) -> int:
    cnt = 0
    for x in range(1<<n):
        if x not in (0, (1<<n)-1):
            cnt += 1
    return cnt

for n in range(1,15):
    assert brute(n) == (1<<n) - 2
print("brute vs PIE OK")
```

---

## 자주 하는 실수 체크리스트

1. **교집합 크기 계산 실수**(특히 LCM/공약수).
2. **중복/약수 관계** 미정리(예: \(d_i\mid d_j\)) → LCM-DFS 또는 전처리로 중복 제거.
3. **부호** 오류(홀수는 \(+\), 짝수는 \(−\)).
4. 고차 교항이 **희소**한데도 끝까지 계산 → **Bonferroni 부분합**으로 상·하한 먼저.
5. 비트마스크 PIE에 **\(m\) 과대**(수십 이상) → 구조/대칭/모비우스/SOS-DP로 축소.
6. **확률에서 독립성 가정** 남발(의존이면 교항을 직접 모델링/추정해야 함).

---

## 요약 & 문제 설계 팁

- “**적어도 하나**”는 정면 PIE, “**하나도 없음**”은 보수.
- **정확히 \(t\)** 는 \(S_k\) 합을 이용한 공식으로 일괄 처리.
- **정수론**(배수, \(\varphi(n)\))·**조합**(전사, 데랑주망)·**문자열**(문자군/패턴)·**확률**(연합/경계)에서 상시 등장.
- 대형 입력은 **LCM-DFS 가지치기**, **비트마스크 PIE**, **SOS-DP/모비우스**로 실용화.
- 작은 입력으로 **브루트 검증 → 일반화** 루틴을 습관화.

---

## 연습 문제(스스로 풀어보기)

1) \(1\le x\le 10^9\) 중 \(\{6,10,15,21\}\) 중 적어도 하나의 배수 개수(LCM-DFS로).
2) 길이 \(L\) 비밀번호: 대/소/숫자/특수(10종) 중 **최소 3종 이상** 포함. (정확히 \(t\) 공식으로)
3) \([n]\to[m]\) **적어도 \(r\)개가 공역에서 비어있음**인 함수 개수(PIE로 교항 조합).
4) 사건 \(A_1,\dots,A_m\)의 1·2차 교항만 있을 때 **Bonferroni 상·하한** 계산해서 시뮬레이션 검증.
