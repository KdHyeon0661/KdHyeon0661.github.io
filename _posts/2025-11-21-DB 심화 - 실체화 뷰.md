---
layout: post
title: DB 심화 - 실체화 뷰와 쿼리 재작성
date: 2025-11-21 17:25:23 +0900
category: DB 심화
---
# 실체화 뷰와 쿼리 재작성

실체화 뷰(Materialized View, MV)는 데이터베이스 성능 최적화의 강력한 도구입니다. 이는 미리 계산된 조인, 집계, 필터 결과를 물리적으로 저장하는 "요약 테이블"로, 복잡한 쿼리의 성능을 획기적으로 향상시킵니다. 이 문서에서는 실체화 뷰의 설계, 생성, 그리고 가장 중요한 기능인 **쿼리 재작성(Query Rewrite)** 에 대해 심층적으로 다룹니다.

## 쿼리 재작성의 개념

쿼리 재작성은 사용자가 원본 테이블을 대상으로 작성한 일반 SQL을 데이터베이스 옵티마이저가 자동으로 변환하여 실체화 뷰를 읽도록 변경하는 기능입니다. 이 기능은 보고서, OLAP 분석, 대시보드 등의 응용에서 I/O와 CPU 사용량을 대폭 줄이고 응답 시간을 획기적으로 단축합니다.

간단히 말해, 동일한 결과를 생성하는 두 경로 중 실체화 뷰를 사용하는 경로가 더 효율적이라고 판단되면, 옵티마이저는 자동으로 실체화 뷰를 선택합니다.

## 환경 설정

### 필수 파라미터

쿼리 재작성을 사용하려면 먼저 적절한 세션 파라미터를 설정해야 합니다.

```sql
ALTER SESSION SET QUERY_REWRITE_ENABLED = TRUE;
ALTER SESSION SET QUERY_REWRITE_INTEGRITY = ENFORCED;
```

- **QUERY_REWRITE_ENABLED**: 쿼리 재작성 기능을 활성화합니다.
- **QUERY_REWRITE_INTEGRITY**: 재작성의 신뢰 수준을 정의합니다.
  - **ENFORCED**: 엄격한 모드. 검증된 제약과 정합성만 신뢰하며, 오래된(stale) 실체화 뷰는 사용하지 않습니다.
  - **TRUSTED**: RELY 제약, 차원 객체 등을 신뢰합니다.
  - **STALE_TOLERATED**: 실체화 뷰가 오래된 상태라도 재작성을 허용합니다.

### 예제 스키마

실습을 위한 스타 스키마 모델을 구성합니다.

```sql
-- 날짜 차원 테이블
CREATE TABLE d_date (
  dt       DATE PRIMARY KEY,
  yyyy     NUMBER NOT NULL,
  mm       NUMBER NOT NULL,
  yyyymm   NUMBER NOT NULL
);

-- 제품 차원 테이블
CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

-- 고객 차원 테이블
CREATE TABLE d_customer (
  cust_id  NUMBER PRIMARY KEY,
  region   VARCHAR2(8) NOT NULL,
  tier     VARCHAR2(8) NOT NULL
);

-- 사실 테이블 (파티션 구성)
CREATE TABLE f_sales (
  sales_id NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL REFERENCES d_customer(cust_id),
  prod_id  NUMBER NOT NULL REFERENCES d_product(prod_id),
  dt       DATE   NOT NULL REFERENCES d_date(dt),
  qty      NUMBER NOT NULL,
  amount   NUMBER(12,2) NOT NULL
) PARTITION BY RANGE (dt) (
  PARTITION p202501 VALUES LESS THAN (DATE '2025-02-01'),
  PARTITION p202502 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION pmax    VALUES LESS THAN (MAXVALUE)
);
```

## 실체화 뷰 생성

### FAST REFRESH를 위한 로그 설정

실체화 뷰를 빠르게 갱신하기 위해서는 원본 테이블에 변경 사항을 추적할 로그가 필요합니다.

```sql
-- 사실 테이블 로그 생성
CREATE MATERIALIZED VIEW LOG ON f_sales
  WITH ROWID, SEQUENCE (cust_id, prod_id, dt, qty, amount)
  INCLUDING NEW VALUES;

-- 차원 테이블 로그 생성
CREATE MATERIALIZED VIEW LOG ON d_product 
  WITH ROWID, SEQUENCE (prod_id, category, brand) 
  INCLUDING NEW VALUES;
```

### 기본 실체화 뷰 생성

월별, 제품별, 고객별 매출 집계를 위한 실체화 뷰를 생성합니다.

```sql
CREATE MATERIALIZED VIEW mv_sales_mpc
BUILD IMMEDIATE
REFRESH FAST ON COMMIT
ENABLE QUERY REWRITE
AS
SELECT
  s.prod_id,
  s.cust_id,
  dd.yyyymm,
  SUM(s.amount) AS sum_amount,
  SUM(s.qty)    AS sum_qty,
  COUNT(*)      AS cnt
FROM f_sales s
JOIN d_date dd ON dd.dt = s.dt
GROUP BY s.prod_id, s.cust_id, dd.yyyymm;
```

**중요한 옵션들:**
- **REFRESH FAST ON COMMIT**: 트랜잭션이 커밋될 때마다 증분 갱신
- **ENABLE QUERY REWRITE**: 쿼리 재작성 기능 활성화
- **BUILD IMMEDIATE**: 생성 즉시 데이터 로드

## 쿼리 재작성 실습

### 원본 쿼리

다음은 2025년 2월에 'ELEC' 카테고리 제품의 매출 합계를 구하는 쿼리입니다.

```sql
SELECT SUM(s.amount) AS amt
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_date    d ON d.dt      = s.dt
WHERE  p.category = 'ELEC'
AND    d.yyyymm   = 202502;
```

### 재작성 유도 및 검증

재작성이 작동하는지 확인하기 위해 특별한 힌트를 사용할 수 있습니다.

```sql
-- 재작성에 실패하면 오류 발생
SELECT /*+ REWRITE_OR_ERROR */ SUM(s.amount)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_date    d ON d.dt      = s.dt
WHERE  p.category = 'ELEC'
AND    d.yyyymm   = 202502;
```

실행 계획을 확인하여 실체화 뷰가 실제로 사용되는지 확인합니다.

```sql
EXPLAIN PLAN FOR
SELECT /*+ REWRITE */ SUM(s.amount)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_date    d ON d.dt      = s.dt
WHERE  p.category = 'ELEC'
AND    d.yyyymm   = 202502;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, NULL, 'BASIC +NOTE'));
```

실행 계획에서 `TABLE ACCESS FULL mv_sales_mpc`와 같은 항목이 나타나면 재작성이 성공한 것입니다.

## 차원(Dimension) 객체를 활용한 재작성 확장

실체화 뷰의 그룹화 수준보다 더 상위 수준의 집계가 필요한 경우, 차원 객체를 정의하여 재작성 가능성을 확장할 수 있습니다.

### 제품 차원 정의

```sql
CREATE DIMENSION dim_product
  LEVEL product IS (d_product.prod_id)
  LEVEL brand   IS (d_product.brand)
  LEVEL category IS (d_product.category)
  HIERARCHY prod_rollup (product CHILD OF brand CHILD OF category);
```

### 날짜 차원 정의

```sql
CREATE DIMENSION dim_date
  LEVEL day   IS (d_date.dt)
  LEVEL month IS (d_date.yyyymm)
  LEVEL year  IS (d_date.yyyy)
  HIERARCHY cal_rollup (day CHILD OF month CHILD OF year);
```

차원 객체를 정의하면 옵티마이저가 계층적 관계를 이해하고, 하위 수준의 실체화 뷰를 사용하여 상위 수준의 집계 쿼리를 처리할 수 있습니다.

## 다양한 실체화 뷰 유형

### 조인 전용 실체화 뷰

복잡한 조인을 미리 계산하여 저장합니다.

```sql
CREATE MATERIALIZED VIEW mv_sales_join
BUILD IMMEDIATE
REFRESH FAST ON COMMIT
ENABLE QUERY REWRITE
AS
SELECT s.sales_id, s.amount, s.qty, s.dt, s.prod_id, s.cust_id,
       p.category, p.brand, d.yyyymm, c.region, c.tier
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_date    d ON d.dt      = s.dt
JOIN   d_customer c ON c.cust_id = s.cust_id;
```

### ROLLUP/CUBE 집계 실체화 뷰

다양한 수준의 집계를 미리 계산합니다.

```sql
CREATE MATERIALIZED VIEW mv_sales_rollup
BUILD IMMEDIATE
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE
AS
SELECT d.yyyy, d.yyyymm, p.category, p.brand,
       SUM(s.amount) AS sum_amount, COUNT(*) AS cnt
FROM   f_sales s
JOIN   d_date d ON d.dt = s.dt
JOIN   d_product p ON p.prod_id = s.prod_id
GROUP BY ROLLUP (d.yyyy, d.yyyymm, p.category, p.brand);
```

## 실체화 뷰 갱신 전략

### 갱신 방법 선택

```sql
-- 수동 갱신
EXEC DBMS_MVIEW.REFRESH('MV_SALES_MPC', 'F');

-- 여러 실체화 뷰를 비원자적으로 갱신
EXEC DBMS_MVIEW.REFRESH(
  list => 'MV_SALES_MPC,MV_SALES_ROLLUP', 
  method => 'F', 
  atomic_refresh => FALSE
);
```

**갱신 방법:**
- **F (FAST)**: 증분 갱신
- **C (COMPLETE)**: 전체 재생성
- **?**: 옵티마이저가 선택

### 갱신 시기 결정

- **ON COMMIT**: 트랜잭션 커밋 시 자동 갱신 (실시간성 우수, OLTP 부하 가능)
- **ON DEMAND**: 명시적 호출 시 갱신 (배치 처리에 적합, 부하 분산)

## 트러블슈팅: 재작성 실패 원인 분석

### EXPLAIN_REWRITE 유틸리티

재작성이 실패하는 이유를 분석하는 데 유용한 도구입니다.

```sql
-- 먼저 REWRITE_TABLE 생성 (utlxrw.sql 실행)
BEGIN
  DBMS_MVIEW.EXPLAIN_REWRITE(
    query => 'SELECT SUM(s.amount) FROM f_sales s JOIN d_date d ON d.dt=s.dt WHERE d.yyyymm=202502',
    mv    => 'MV_SALES_MPC'
  );
END;
/

SELECT * FROM REWRITE_TABLE ORDER BY id;
```

### 일반적인 재작성 실패 원인

1. **파라미터 설정**: `QUERY_REWRITE_ENABLED`가 `FALSE`로 설정됨
2. **실체화 뷰 옵션**: `ENABLE QUERY REWRITE`가 누락됨
3. **데이터 신선도**: ENFORCED 모드에서 stale 상태의 실체화 뷰 사용 시도
4. **표현식 불일치**: 쿼리의 함수/표현식이 실체화 뷰와 정확히 일치하지 않음
5. **차원 정보 부족**: 조인백이나 롤업을 위한 차원 객체 또는 제약 정의가 없음
6. **지원되지 않는 연산**: COUNT(DISTINCT), 비결정적 함수 등 특정 연산 사용

## 성능 검증 방법

변경 전후의 성능 차이를 정량적으로 측정하는 것이 중요합니다.

```sql
-- 1. 재작성 비활성화 상태에서 원본 쿼리 실행
ALTER SESSION SET QUERY_REWRITE_ENABLED = FALSE;
-- 쿼리 실행 및 시간 측정

-- 2. 재작성 활성화 상태에서 동일 쿼리 실행
ALTER SESSION SET QUERY_REWRITE_ENABLED = TRUE;
-- 쿼리 실행 및 시간 측정

-- 3. 통계 비교
SELECT sn.name, ms.value
FROM v$mystat ms 
JOIN v$statname sn ON sn.stat# = ms.stat#
WHERE sn.name IN (
  'session logical reads',
  'physical reads',
  'sorts (memory)',
  'sorts (disk)'
);
```

## 실전 적용 시나리오

### 브랜드별 Top-5 매출 분석

```sql
-- 원본 쿼리
SELECT p.brand, SUM(s.amount) amt
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_date    d ON d.dt = s.dt
WHERE  d.yyyymm = 202502
GROUP BY p.brand
ORDER BY amt DESC
FETCH FIRST 5 ROWS ONLY;

-- 재작성 경로
-- mv_sales_rollup 또는 mv_sales_mpc에서 월/브랜드별 합계만 스캔
```

### VIP 고객의 전자제품 매출 연도별 추이

```sql
-- 원본 쿼리
SELECT d.yyyy, SUM(s.amount) amt
FROM   f_sales s
JOIN   d_customer c ON c.cust_id = s.cust_id
JOIN   d_product  p ON p.prod_id = s.prod_id
JOIN   d_date     d ON d.dt      = s.dt
WHERE  c.tier = 'VIP' AND p.category = 'ELEC'
GROUP BY d.yyyy;

-- 재작성 경로
-- mv_sales_mpc + 차원 객체를 통한 계층적 롤업
```

## 주의사항 및 제한사항

1. **비결정적 함수**: SYSDATE, DBMS_RANDOM 등의 함수는 일반적으로 재작성을 지원하지 않습니다.
2. **복잡한 조인 패턴**: 외부 조인, 비등가 조인을 포함하는 쿼리는 제한적입니다.
3. **특수 집계 함수**: COUNT(DISTINCT) 등은 지원 조건이 까다롭습니다.
4. **보안 정책**: VPD(가상 사설 데이터베이스)나 RLS(행 수준 보안)이 적용된 환경에서는 추가 검토가 필요합니다.
5. **유지 관리**: 실체화 뷰 로그의 관리와 저장 공간 고려가 필요합니다.

## 결론

실체화 뷰와 쿼리 재작성은 데이터 웨어하우스와 비즈니스 인텔리전스 시스템에서 성능 최적화를 위한 핵심 기술입니다. 효과적으로 활용하기 위해서는:

1. **적절한 실체화 뷰 설계**: 빈번하게 실행되고 비용이 높은 쿼리 패턴을 분석하여 적절한 집계 수준과 조인 구조를 가진 실체화 뷰를 설계하세요.

2. **차원 모델링**: 계층적 관계를 명확히 정의하는 차원 객체를 생성하면 재작성 가능성을 크게 확장할 수 있습니다.

3. **갱신 전략 수립**: 데이터 신선도 요구사항과 시스템 부하를 고려하여 적절한 갱신 주기와 방법을 선택하세요.

4. **체계적인 검증**: `EXPLAIN_REWRITE`, `EXPLAIN_MVIEW` 도구를 활용하여 재작성 가능성을 사전에 검증하고, 성능 개선 효과를 정량적으로 측정하세요.

5. **지속적인 모니터링**: 실체화 뷰의 사용 빈도, 갱신 성능, 저장 공간 사용량을 모니터링하여 최적의 상태를 유지하세요.

이러한 실체화 뷰 전략을 잘 수립하고 실행하면, 기존 응용 프로그램의 코드 변경 없이도 수십 배의 성능 향상을 달성할 수 있습니다. 이는 특히 대용량 데이터를 처리하는 보고서 시스템과 분석 애플리케이션에서 극적인 성능 개선을 가능하게 합니다.