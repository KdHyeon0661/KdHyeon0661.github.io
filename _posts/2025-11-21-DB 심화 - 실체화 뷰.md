---
layout: post
title: DB 심화 - 실체화 뷰
date: 2025-11-21 17:25:23 +0900
category: DB 심화
---
# 실체화 뷰(Materialized View) **쿼리로 재작성(Query Rewrite)**

> **한 줄 요약**
> 실체화 뷰(MV)는 미리 **JOIN/집계/필터**를 계산해 둔 “요약/요약+조인” 테이블입니다.
> **쿼리 재작성(Query Rewrite)** 은 사용자가 **원본 테이블을 대상으로 작성한 일반 SQL**을 옵티마이저가 **동치 변환**하여 **MV를 읽도록 자동 치환**하는 기능입니다.
> 보고서/OLAP/대시보드에서 **I/O·CPU를 대폭 절감**하고 **지연시간을 크게 줄일 수** 있습니다.

---

## 0) 쿼리 재작성의 직관

같은 결과를 내는 두 SQL 중 **MV를 이용한 경로**가 더 싸다면, 옵티마이저가 **자동으로 MV를 선택**합니다.

- 원래 비용(직접 스캔):
  $$ \text{Cost}_{\text{base}} \approx \text{scan}(F) + \text{join}(D) + \text{group} + \text{filter} $$
- MV 비용(재작성):
  $$ \text{Cost}_{\text{mv}} \approx \text{scan}(\text{MV}) + \text{(필요시) join-back} $$

일반적으로 $$\text{Cost}_{\text{mv}} \ll \text{Cost}_{\text{base}}$$ 이므로, **자동 재작성**이 성능의 핵심이 됩니다.

---

## 1) 환경 준비 — 파라미터/권한/기초 테이블

### 세션 파라미터

```sql
ALTER SESSION SET QUERY_REWRITE_ENABLED   = TRUE;          -- 재작성 활성화
ALTER SESSION SET QUERY_REWRITE_INTEGRITY = ENFORCED;      -- ENFORCED / TRUSTED / STALE_TOLERATED
-- 시스템 전역으로는 spfile/init.ora에서 설정 가능
```
- **ENFORCED**: 엄격. **검증된 제약/정합성**만 신뢰, **stale MV** 미사용.
- **TRUSTED**: RELY 제약/디멘전/기타 선언을 신뢰.
- **STALE_TOLERATED**: MV가 **stale**이어도 재작성 허용(신선도 < 정확성).

### 스키마(스타 모델 예시)

```sql
-- 날짜 차원
CREATE TABLE d_date (
  dt       DATE PRIMARY KEY,
  yyyy     NUMBER NOT NULL,
  mm       NUMBER NOT NULL,
  yyyymm   NUMBER NOT NULL
);

-- 제품 차원
CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

-- 고객 차원
CREATE TABLE d_customer (
  cust_id  NUMBER PRIMARY KEY,
  region   VARCHAR2(8) NOT NULL,
  tier     VARCHAR2(8) NOT NULL
);

-- 사실 테이블
CREATE TABLE f_sales (
  sales_id NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL REFERENCES d_customer(cust_id),
  prod_id  NUMBER NOT NULL REFERENCES d_product(prod_id),
  dt       DATE   NOT NULL REFERENCES d_date(dt),
  qty      NUMBER NOT NULL,
  amount   NUMBER(12,2) NOT NULL
) PARTITION BY RANGE (dt) (
  PARTITION p202501 VALUES LESS THAN (DATE '2025-02-01'),
  PARTITION p202502 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION pmax    VALUES LESS THAN (MAXVALUE)
);

-- 인덱스(대표)
CREATE INDEX ix_fs_cust_dt ON f_sales(cust_id, dt);
CREATE INDEX ix_fs_prod_dt ON f_sales(prod_id, dt);
CREATE INDEX ix_dd_ym      ON d_date(yyyymm);
CREATE INDEX ix_dp_cat     ON d_product(category, prod_id);
CREATE INDEX ix_dc_tier    ON d_customer(tier, cust_id);
```

샘플 데이터(간략):
```sql
INSERT INTO d_date(dt, yyyy, mm, yyyymm) VALUES (DATE '2025-02-01', 2025, 2, 202502);
-- … (실습에 필요한 만큼 삽입)
INSERT INTO d_product VALUES (10,'ELEC','B0');
INSERT INTO d_product VALUES (20,'HOME','B1');
INSERT INTO d_customer VALUES (1,'KOR','VIP');
INSERT INTO d_customer VALUES (2,'USA','STD');

INSERT INTO f_sales VALUES (1001,1,10,DATE '2025-02-03',1,10000);
INSERT INTO f_sales VALUES (1002,1,20,DATE '2025-01-15',2,15000);
INSERT INTO f_sales VALUES (1003,2,10,DATE '2025-02-10',1, 9000);
COMMIT;
```

---

## 2) “요약 MV” 만들기 — 월×제품×고객 합계

### FAST 리프레시를 위한 MV 로그

**FAST REFRESH** 를 쓰려면 보통 **MV Log**가 필요합니다(집계는 SEQUENCE/ROWID 포함 권장).
```sql
-- 사실 테이블 로그
CREATE MATERIALIZED VIEW LOG ON f_sales
  WITH ROWID, SEQUENCE (cust_id, prod_id, dt, qty, amount)
  INCLUDING NEW VALUES;

-- (조인/집계 MV에서 필요시) 차원 테이블 로그
CREATE MATERIALIZED VIEW LOG ON d_product WITH ROWID, SEQUENCE (prod_id, category, brand) INCLUDING NEW VALUES;
CREATE MATERIALIZED VIEW LOG ON d_customer WITH ROWID, SEQUENCE (cust_id, region, tier)   INCLUDING NEW VALUES;
CREATE MATERIALIZED VIEW LOG ON d_date     WITH ROWID, SEQUENCE (dt, yyyy, mm, yyyymm)     INCLUDING NEW VALUES;
```

### 월·제품·고객별 합계 MV

```sql
CREATE MATERIALIZED VIEW mv_sales_mpc
BUILD IMMEDIATE
REFRESH FAST ON COMMIT                  -- 트랜잭션 커밋마다 증분 갱신
ENABLE QUERY REWRITE
AS
SELECT
  s.prod_id,
  s.cust_id,
  dd.yyyymm,                            -- 월 키 (조인백/롤업에 유용)
  SUM(s.amount) AS sum_amount,
  SUM(s.qty)    AS sum_qty,
  COUNT(*)      AS cnt
FROM f_sales s
JOIN d_date dd ON dd.dt = s.dt
GROUP BY s.prod_id, s.cust_id, dd.yyyymm;
```

> 포인트
> - `ENABLE QUERY REWRITE` 필수.
> - Group-By 열은 **조인백(join-back)** 과 **상위 집계(예: yyyymm→yyyy)** 의 기반이 됩니다.

---

## 3) “원본 쿼리 → MV로 자동 재작성” 실습

### 원본 쿼리 (기본)

```sql
-- 2025-02 ELEC 매출 합계
SELECT SUM(s.amount) AS amt
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_date    d ON d.dt      = s.dt
WHERE  p.category = 'ELEC'
AND    d.yyyymm   = 202502;
```

### 재작성 유도/검증

- 세션 파라미터:
```sql
ALTER SESSION SET QUERY_REWRITE_ENABLED   = TRUE;
ALTER SESSION SET QUERY_REWRITE_INTEGRITY = ENFORCED; -- 필요에 따라 TRUSTED/STALE_TOLERATED
```
- **재작성 보장 테스트 힌트**:
```sql
-- REWRITE_OR_ERROR: MV 재작성에 실패하면 ORA-30393 에러로 알려줌
SELECT /*+ REWRITE_OR_ERROR */ SUM(s.amount)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_date    d ON d.dt      = s.dt
WHERE  p.category = 'ELEC'
AND    d.yyyymm   = 202502;
```
- 실행계획 확인(실제 MV 스캔되는지):
```sql
EXPLAIN PLAN FOR
SELECT /*+ REWRITE */ SUM(s.amount)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_date    d ON d.dt      = s.dt
WHERE  p.category = 'ELEC'
AND    d.yyyymm   = 202502;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, NULL, 'BASIC +NOTE'));
-- PLAN에서 TABLE ACCESS FULL mv_sales_mpc (또는 INDEX RANGE SCAN) 등 MV 접근이 나타나면 성공
```

### 왜 재작성 가능한가?

- 쿼리의 요구집계 = `SUM(amount)` **by nothing** (전체 합).
- MV는 **(prod_id, cust_id, yyyymm)별 합**을 가지고 있음 →
  `WHERE category='ELEC'`은 **조인백(join-back)** 으로 `d_product`에서 `prod_id`를 제한하고,
  `yyyymm=202502`로 **월 필터** 적용 → MV에서 **필터 후 합산**으로 동치.

---

## 4) 조인백(Join-back) & 디멘전(DIMENSION) 정의

오라클은 MV의 그룹화 키보다 **상위 속성**(brand, category, yyyy 등)으로 **블록을 재그룹**하기 위해
**디멘전 객체** 또는 **신뢰 가능한 제약(REL†Y/ENFORCED)** 을 활용해 **동치성을 추론**합니다.

### 제품 디멘전

```sql
CREATE DIMENSION dim_product
  LEVEL product IS (d_product.prod_id)
  LEVEL brand   IS (d_product.brand)
  LEVEL category IS (d_product.category)
  HIERARCHY prod_rollup (product CHILD OF brand CHILD OF category);
```

### 날짜 디멘전

```sql
CREATE DIMENSION dim_date
  LEVEL day   IS (d_date.dt)
  LEVEL month IS (d_date.yyyymm)
  LEVEL year  IS (d_date.yyyy)
  HIERARCHY cal_rollup (day CHILD OF month CHILD OF year);
```

> 디멘전 선언 또는 **유일/외래키 제약 & RELY** 로도 재작성 단서 제공이 가능합니다.
> **QUERY_REWRITE_INTEGRITY=TRUSTED** 일 때 RELY 제약을 신뢰합니다.

---

## 5) 다른 유형의 MV와 재작성

### **조인만** 미리 한 MV (Join-Only)

```sql
CREATE MATERIALIZED VIEW mv_sales_join
BUILD IMMEDIATE
REFRESH FAST ON COMMIT
ENABLE QUERY REWRITE
AS
SELECT s.sales_id, s.amount, s.qty, s.dt, s.prod_id, s.cust_id,
       p.category, p.brand, d.yyyymm, c.region, c.tier
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_date    d ON d.dt      = s.dt
JOIN   d_customer c ON c.cust_id = s.cust_id;
```
- 원본 쿼리가 같은 조인 구조라면 **그대로** 이 MV로 재작성될 수 있습니다(필터/프로젝션만 다르면 OK).

### **ROLLUP/CUBE** 요약 MV

```sql
CREATE MATERIALIZED VIEW mv_sales_rollup
BUILD IMMEDIATE
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE
AS
SELECT d.yyyy, d.yyyymm, p.category, p.brand,
       SUM(s.amount) AS sum_amount, COUNT(*) AS cnt
FROM   f_sales s
JOIN   d_date d ON d.dt = s.dt
JOIN   d_product p ON p.prod_id = s.prod_id
GROUP BY ROLLUP (d.yyyy, d.yyyymm, p.category, p.brand);
```
- 쿼리가 **연-월-카테고리-브랜드** 중 일부 레벨만 요청해도 **GROUP BY 제거/축소** 재작성 가능합니다.
- `GROUPING_ID()` 조건이 있으면 제약이 있으므로 주의.

### **파티션 변경 추적(PCT)** 기반 MV

- 사실 테이블이 파티션되어 있고, MV가 그 파티션 키를 **보존**하면 **PCT FAST REFRESH** 가능.
- 대량 로드 시 바뀐 **파티션만 반영**하므로 **대규모 요약 MV 관리에 효과적**.

---

## 6) 갱신(Refresh) 전략

### ON COMMIT vs ON DEMAND

```sql
-- 수동 갱신
EXEC DBMS_MVIEW.REFRESH('MV_SALES_MPC', 'F');      -- F: FAST, C: COMPLETE, ? 병행 옵션 가능
EXEC DBMS_MVIEW.REFRESH(list => 'MV_SALES_MPC,MV_SALES_ROLLUP', method => 'F', atomic_refresh => FALSE);

-- 자동 갱신
CREATE MATERIALIZED VIEW ... REFRESH FAST ON COMMIT ...
```
- **ON COMMIT**: DML 경로에 갱신 비용 포함 → OLTP에 부담될 수 있음.
- **ON DEMAND**: 배치/스케줄러로 갱신 → 리포트는 최신성(신선도) 요구에 맞춰 결정.

### FAST가 안 될 때

- MV Log 미비, 집계식/함수 제약, 외부 조인/서브쿼리 등으로 **COMPLETE** 로 떨어질 수 있음.
- 진단:
```sql
-- utlxmv.sql 로 MV_CAPABILITIES_TABLE 생성 후
EXEC DBMS_MVIEW.EXPLAIN_MVIEW('SELECT ...');  -- 왜 FAST가 안 되는지 reason 확인
SELECT capability_name, possible, msgtxt FROM MV_CAPABILITIES_TABLE;
```

---

## 7) “왜 재작성 안 되나요?” — 트러블슈팅

### EXPLAIN_REWRITE

```sql
-- utlxrw.sql 로 REWRITE_TABLE 생성 후
BEGIN
  DBMS_MVIEW.EXPLAIN_REWRITE(
    query => 'SELECT SUM(s.amount) FROM f_sales s JOIN d_date d ON d.dt=s.dt WHERE d.yyyymm=202502',
    mv    => 'MV_SALES_MPC'
  );
END;
/

SELECT * FROM REWRITE_TABLE ORDER BY id;
-- 이유/재작성 문장/단계 로그 확인
```

### 흔한 원인

- 세션 파라미터 `QUERY_REWRITE_ENABLED=FALSE` 이거나, `INTEGRITY` 가 너무 엄격(ENFORCED) → **TRUSTED/STALE_TOLERATED** 필요.
- MV 정의에 **ENABLE QUERY REWRITE** 누락.
- 쿼리의 **함수/표현식 비동치**(예: `TRUNC(dt,'MM')` vs `yyyymm`), **비결정 함수** 사용.
- MV가 **stale** 인데 **ENFORCED** 모드.
- 디멘전/제약이 없어 **조인백/롤업** 추론 불가.
- COUNT(DISTINCT) 등 **복잡 집계**로 인한 재작성 불가.
- ANSI 외부조인/비등가 조인 조합 등 **재작성 제약**.

---

## 8) 현업 상황별 패턴

### 보고서: 월×카테고리 합계 (MV로 초고속)

**원본 쿼리**
```sql
SELECT d.yyyymm, p.category, SUM(s.amount) AS amt
FROM   f_sales s
JOIN   d_date d ON d.dt = s.dt
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  d.yyyy = 2025
GROUP BY d.yyyymm, p.category;
```
**자동 재작성 기대 경로**
- `mv_sales_rollup` 에서 `yyyy=2025` 로 필터 + `GROUP BY yyyymm, category` 레벨만 **추출**.

### 대시보드: 실시간 근사 + 배치 정합

- OLTP 영향 최소화 위해 **ON DEMAND FAST** 를 5분/10분 주기.
- 더 엄격한 최신성 필요 시 **STALE_TOLERATED** 로 재작성 허용 → **MV stale** 상태라도 즉시 응답.

### 상위/하위 N

- `ORDER BY SUM(amount) DESC FETCH FIRST 10 ROWS` 같이 **Top-N** 은 MV에서 **이미 줄어든 입력**으로 처리돼 비용 절감.

---

## 9) 실전 체크리스트

- [ ] **ENABLE QUERY REWRITE** 로 MV 생성
- [ ] 세션/시스템 **QUERY_REWRITE_ENABLED=TRUE**
- [ ] **INTEGRITY** 모드 선택(ENFORCED/TRUSTED/STALE_TOLERATED)
- [ ] **MV Log**/PCT/파티셔닝 등 갱신 전략 확립
- [ ] 디멘전/RELY 제약으로 **조인백/롤업** 가능성 확보
- [ ] 원본 쿼리의 표현식이 **MV 컬럼과 동치**(또는 추론 가능) 인가
- [ ] `EXPLAIN_MVIEW` / `EXPLAIN_REWRITE` 로 **가능성/실패 원인** 사전 점검
- [ ] `REWRITE_OR_ERROR` 로 **테스트 실패 시 바로 알람**

---

## 10) 심화: 제약 기반(Query Rewrite by Constraints)

**제약(UNIQUE/FK/NOT NULL, RELY)** 만으로도 **등치/함의 관계**를 추론하여 재작성 범위를 넓힐 수 있습니다.
```sql
ALTER TABLE d_product ADD CONSTRAINT uk_dp_cat_brand UNIQUE (prod_id, category, brand) RELY;
-- TRUSTED 모드에서 옵티마이저가 이 RELY 제약을 신뢰 → 조인백 판단에 도움
```

---

## 11) 성능 검증 루틴

```sql
-- 1) 통계 스냅샷
SELECT sn.name, ms.value
FROM v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE sn.name IN ('session logical reads','physical reads','sorts (memory)','sorts (disk)');

-- 2) 원본 쿼리 실행(재작성 OFF)
ALTER SESSION SET QUERY_REWRITE_ENABLED = FALSE;
-- 원본 쿼리 실행/시간 기록

-- 3) 재작성 ON 후 동일 쿼리
ALTER SESSION SET QUERY_REWRITE_ENABLED = TRUE;
-- 동일 쿼리 실행/시간 기록

-- 4) 실행계획 비교
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +NOTE +PREDICATE'));
```
**목표**: MV 접근으로 **논리/물리 읽기 급감**, 소트/해시 단계 축소.

---

## 12) 주의 사항(제약/제한)

- **비결정 함수**(SYSDATE, SYSTIMESTAMP, DBMS_RANDOM 등)는 일반적으로 재작성 불가.
- **외부조인/비등가 조인** 포함 쿼리는 제약 많음.
- **COUNT(DISTINCT)**, **단조롭지 않은 표현식**은 요건을 만족해야 함(많이 까다로움).
- **뷰 머징/서브쿼리 변환**과 상호작용: 블록화/인라인 여부가 재작성 가능성에 영향.
- **보안 정책(VPD/RLS)**, **가상 컬럼**, **UDF** 등도 제약이 생길 수 있음(결정성/허용성 확인).

---

## 13) 요약 & 실전 적용 로드맵

1. **핵심 리포트 쿼리 Top-N** 선별 → 공통 패턴 도출(월/카테고리/브랜드/지역/고객 등).
2. **MV 후보 설계**:
   - `JOIN-ONLY MV`(폭넓은 재사용), `SUMMARY MV`(월/분기/연·그룹별 합계), `ROLLUP/CUBE MV`.
   - 파티셔닝/PCT 고려, **FAST ON DEMAND** 우선.
3. **ENABLE QUERY REWRITE** + **디멘전/RELY 제약** 정비.
4. **EXPLAIN_MVIEW / EXPLAIN_REWRITE** 로 사전 검증.
5. **REWRITE_OR_ERROR** 로 배포 전 자동화 테스트.
6. 모니터링: **V$SYSSTAT/V$SQL_PLAN/SQL Monitor** 로 **I/O/CPU/대기** 개선 확인.
7. 신선도 정책(ON COMMIT, 주기 갱신, STALE 허용) 결정.

---

## 14) 부록: 미니 시나리오 2개

### A) “브랜드 Top-5 (2025-02)”

**원본**
```sql
SELECT p.brand, SUM(s.amount) amt
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_date    d ON d.dt = s.dt
WHERE  d.yyyymm = 202502
GROUP BY p.brand
ORDER BY amt DESC
FETCH FIRST 5 ROWS ONLY;
```
**재작성**: `mv_sales_rollup` 또는 `mv_sales_mpc` + `d_product` 조인백으로 월/브랜드별 합계만 스캔 → **극소 읽기**.

### B) “VIP 고객 ELEC 매출(연도별)”

**원본**
```sql
SELECT d.yyyy, SUM(s.amount) amt
FROM   f_sales s
JOIN   d_customer c ON c.cust_id = s.cust_id
JOIN   d_product  p ON p.prod_id = s.prod_id
JOIN   d_date     d ON d.dt      = s.dt
WHERE  c.tier='VIP' AND p.category='ELEC'
GROUP  BY d.yyyy;
```
**재작성**: `mv_sales_mpc` (yyyymm까지 있음) + `dim_date`(month→year 롤업), `d_product`(prod→category), `d_customer`(cust→tier) 조인백 →
MV에서 **필터→롤업** 조합으로 빠르게 해결.

---

### 마무리

- **실체화 뷰 + 쿼리 재작성**은 **보고서/OLAP**의 체감 성능을 바꾸는 1등 공신입니다.
- 핵심은 **올바른 MV 설계(그룹키/조인키/표현식 동치)**, **신뢰 기반(디멘전/제약)**, **적절한 갱신전략(FAST/PCT)**, 그리고 **꾸준한 검증(EXPLAIN\_*)** 입니다.
- 이 가이드를 그대로 따라 설계→검증→배포하면, **같은 SQL**로도 **수 배~수십 배**의 성능 이득을 얻을 수 있습니다.
