---
layout: post
title: 시스템보안 - 암호·시스템 키 재사용의 위험
date: 2025-10-30 18:30:23 +0900
category: 시스템보안
---
# 14. 암호·시스템 키 재사용의 위험

## 핵심 요약
- **키/토큰/쿠키는 “재사용·중복·유출”이 곧 위험**입니다. 동일 비밀(또는 동일 nonce/IV)을 여러 컨텍스트에서 재사용하면 **암호 안전성이 붕괴**합니다.
- **보안 사고 3대 축**: (1) 저장 위치에서의 유출, (2) **nonce/IV 재사용**·패딩 오류 기반 **복호화 오라클**, (3) **RNG 취약/예측**.
- **방어 3대 축**: (1) **스코프 최소화**(기한·권한), (2) **고유성 보장**(nonce/IV/시드), (3) **키 순환(회전)+정책 게이트**(정적 분석/SCA/라이선스·비밀검출).

---

## 14.1 키/토큰/쿠키 저장과 탈취 루트

### 14.1.1 어디에 저장되나 (OS/앱·브라우저/클라우드)
- **OS/Keychain**
  - **Windows**: DPAPI(사용자/시스템 보호), Credential Manager, LSA/LSASS(민감)
  - **macOS**: Keychain(액세스 제어/UI 프롬프트), Hardened Runtime 연계
  - **Linux**: gnome-keyring/kwallet, 커널 keyrings, 파일 기반 지갑(권한 관리 중요)
- **브라우저**
  - **쿠키**(Secure/HttpOnly/SameSite), **localStorage**(XSS에 취약), **IndexedDB**
  - 자동완성/비밀번호 관리자(프로파일·마스터 키)
- **클라우드/개발**
  - 소스코드 레포(Git)·CI/CD 환경변수·IaC 템플릿
  - **클라우드 메타데이터** (예: `169.254.169.254`), **K8s 서비스어카운트 토큰**
  - 구성 파일: `~/.aws/credentials`, `gcloud application-default`, kubeconfig 등

### 14.1.2 어떻게 유출되나 (탈취 루트)
- **디스크/백업**
  - 로그에 비밀이 남음(예: Authorization 헤더, JWT, API key), 크래시 덤프/메모리 스냅샷, 스왑·하이버네이션 파일
  - 백업 아카이브/S3 버킷 퍼블릭 노출
- **메모리/프로세스**
  - **메모리 스캔**(EDR/포렌식), DLL 인젝션, 스냅샷/덤프(예: Windows minidump)
  - 브라우저 프로세스·프록시/프리미티브를 통한 **세션 쿠키 추출**
- **네트워크**
  - HTTPS 미사용/다운그레이드, 중간자(프록시·TLS 검사 장비 설정 오류)
  - OAuth PKCE 미사용·리다이렉트 URL 오용 → 코드 탈취
- **웹/앱 로직**
  - XSS로 `localStorage/sessionStorage` 탈취, Referer에 토큰 누출, URL에 토큰(로그/분석/북마크)
- **인프라/운영**
  - SSRF로 메타데이터 서비스 접근, K8s pod 내 **`/var/run/secrets/kubernetes.io/serviceaccount/token`** 노출
  - CI Job 로그/아티팩트에 **비밀 에코** (e.g., `set -x`)

### 14.1.3 방어 설계(체크리스트)
- **저장 최소화**
  - 브라우저: **`HttpOnly`+`Secure`+`SameSite`** 쿠키 우선, `localStorage`에 토큰 저장 금지
  - 서버: 비밀은 **KMS/HSM/Keychain**에만, 환경변수도 **임시/짧은 TTL**로
- **스코프 최소화**
  - API 키 **권한·리소스 한정**, IP 제한, **만료/회전**(자동)
  - OAuth: **PKCE**, 짧은 만료의 Access Token + Refresh Token 보호
- **비밀 검출**
  - **pre-commit**에서 **secret scanner**(gitleaks/trufflehog), CI에서 정책 게이트
- **무결성·복원력**
  - 키는 **버전/ID(kid)** 부여, 롤링 배포; **JWKS**로 공개키 회전
  - **키 폐기 Playbook**: 노출 시 롤백/무효화/전면 로테이션 절차 문서화
- **메모리 위생**
  - 장수 객체 대신 **세션형 핸들·OS 브로커** 사용, 사용 후 메모리 지움(언어별 주의)

---

## 14.2 암호 구현 취약(Nonce 재사용, Padding Oracle, RNG)

### 14.2.1 Nonce/IV 재사용의 파괴력

#### (A) CTR/GCM에서 **nonce 충돌** → 평문 노출/위조
- **CTR**: 동일 키·nonce → 같은 keystream. 두 암호문 \( C_1 = P_1 \oplus S \), \( C_2 = P_2 \oplus S \).
  ⇒ \( C_1 \oplus C_2 = P_1 \oplus P_2 \) (평문 XOR 관계 유출).
- **GCM**: nonce 재사용은 **기밀성** + **무결성** 둘 다 붕괴(태그 위조 가능).

**간단 실험 (Python, 교육용) — CTR nonce 재사용 위험**
```python
from Crypto.Cipher import AES
from Crypto.Util import Counter
from Crypto.Random import get_random_bytes

key = get_random_bytes(16)
nonce = 0x1234567890ABCDEF  # ❌ 재사용 (예시)
ctr = Counter.new(64, prefix=b"", initial_value=nonce)

def aes_ctr_enc(m):
    return AES.new(key, AES.MODE_CTR, counter=Counter.new(64, prefix=b"", initial_value=nonce)).encrypt(m)

p1 = b"attack at dawn!!!!!"
p2 = b"send cash asap!!!!!"
c1 = aes_ctr_enc(p1)
c2 = aes_ctr_enc(p2)

# 공격자 관점: c1^c2 = p1^p2 → 한쪽 평문을 조금만 알면 다른 쪽 복구
x = bytes(a ^ b for a,b in zip(c1, c2))
recovered_p2 = bytes(a ^ b for a,b in zip(x, p1))  # p1을 아는 경우
print(recovered_p2)  # b'send cash asap!!!!!'
```

**방어**
- 각 메시지마다 **전역 유일 nonce** (랜덤 96비트 권장)
- 키별 **nonce 카운터**는 **충돌 감지/거부**(영속 카운터 or HSM)
- **AEAD(GCM/ChaCha20-Poly1305)** 사용 시에도 **nonce 재사용 절대 금지**

#### (B) CBC에서 **고정 IV** → 평문 구조 누설
- 첫 블록: \( C_0 = E_K(P_0 \oplus IV) \). **IV를 고정**하면 **같은 평문 첫 블록은 같은 암호문**(패턴 유출).
- **방어**: 예측 불가 랜덤 IV(블록 크기), 매 메시지 새 IV. 인증은 **Encrypt-then-MAC** 또는 **AEAD**.

---

### 14.2.2 Padding Oracle 개념 & 미니 실습

**시나리오**
- 서버가 CBC 모드 복호화 후 **패딩 오류와 MAC 오류를 다르게 응답**하거나, **시간**/에러 메시지 차이로 “패딩 성공 여부”를 누설.
- 공격자는 **IV/암호문 바이트를 조작**해 서버의 응답을 보고 **평문 바이트를 점진적 복구**.

**개념 코드(교육용 Mock Oracle)**
> 실제 서비스에 대한 공격 코드는 제공하지 않습니다. 아래는 **자체 랩**에서 동작하는 **모의 오라클**입니다.

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

key = get_random_bytes(16)
iv  = get_random_bytes(16)

def encrypt(plaintext):
    return iv + AES.new(key, AES.MODE_CBC, iv).encrypt(pad(plaintext,16))

def oracle(ciphertext):
    """패딩 유효성만 노출하는 나쁜 서버를 모사 (절대 이렇게 구현하지 말 것)."""
    iv = ciphertext[:16]; ct = ciphertext[16:]
    try:
        pt = unpad(AES.new(key, AES.MODE_CBC, iv).decrypt(ct), 16)
        return True   # ❌ '패딩 OK' 정보가 외부에 노출
    except ValueError:
        return False  # ❌ '패딩 BAD'
```

- 위와 같이 **패딩 유효성**을 외부로 노출하면 블록 단위 **평문 복구**가 가능해집니다.

**방어**
- **AEAD 사용**(GCM/ChaCha20-Poly1305). CBC를 써야 한다면:
  - **Authenticate-then-Decrypt**(EtM)로 **MAC 검증 실패** 시 **동일 에러/동일 시간**에 실패
  - 에러 메시지/시간차 **균질화** (상수 시간/랜덤 지연 불허)
  - “패딩 오류” vs “MAC 오류” **구분 응답 금지**
  - **재시도 횟수·레이트 리밋**(오라클 쿼리 차단)

---

### 14.2.3 ECDSA/DSA **Nonce 재사용 → 개인키 유출**

- 서명 스킴(ECDSA/DSA)에서 각 서명에 **고유한 랜덤 \(k\)** 가 필요.
- **같은 \(k\)** 로 두 메시지를 서명하면 \(r\)이 동일해지고, 아래처럼 개인키 \(x\)가 추출됨.

수식(정의域 \(\mathbb{Z}_n\)):
- 서명: \( r = (kG)_x \mod n \), \( s = k^{-1}(H(m) + x r)\mod n \)
- 두 서명 \((r,s_1),(r,s_2)\)에 대해
  \[
  k = \frac{H(m_1)-H(m_2)}{s_1-s_2} \bmod n,\qquad
  x = \frac{s_1 k - H(m_1)}{r} \bmod n
  \]
- **부분 누설**(예: k 상위 비트만 노출)도 **lattice**로 복구 가능.

**실험(교육용) — 동일 nonce 시 개인키 복구**
```python
from hashlib import sha256
from ecdsa import SigningKey, SECP256k1
from ecdsa.numbertheory import inverse_mod

sk = SigningKey.generate(curve=SECP256k1)
vk = sk.get_verifying_key()
n  = sk.privkey.order
x  = sk.privkey.secret_multiplier

m1 = b"msg-1"; m2 = b"msg-2"
z1 = int.from_bytes(sha256(m1).digest(), 'big') % n
z2 = int.from_bytes(sha256(m2).digest(), 'big') % n

# ❌ 같은 k 사용 (교육용)
k = 12345678901234567890 % n
r = (sk.privkey.curve.generator * k).x() % n
s1 = (inverse_mod(k,n)*(z1 + x*r)) % n
s2 = (inverse_mod(k,n)*(z2 + x*r)) % n

# 공격자 관점: (r,s1),(r,s2), z1,z2 알면 x 복구
k_rec = ((z1 - z2) * inverse_mod((s1 - s2) % n, n)) % n
x_rec = (((s1 * k_rec - z1) * inverse_mod(r, n))) % n
assert x_rec == x
print("Recovered x =", x_rec == x)
```

**방어**
- ECDSA/DSA 서명은 **RFC 6979 (deterministic k)** 사용 → RNG에 의존하지 않음
- **키/nonce 재사용 금지**(하나의 키를 서로 다른 구현/라이브러리에서 혼용 시 주의)
- HSM/전용 서명 모듈로 **k 생성·보호** 일원화

---

### 14.2.4 RNG(난수) 취약과 시드 재사용
- **시간 기반 시드**(예: `srand(time(NULL))`), **MT19937** 같은 빠른 PRNG를 **암호 용도**에 사용 → **예측 가능**
- **취약 RNG**는 **nonce/IV/서명 k**를 취약하게 만들어 상기 위험을 촉발

**안티패턴(C)**
```c
// ❌ 암호용에 사용 금지
srand(time(NULL));
for (int i=0;i<16;i++) key[i] = rand() & 0xFF;
```

**대안**
- OS CSPRNG: `getrandom()`/`/dev/urandom`, Windows CNG(BCryptGenRandom), Python `secrets`, Go `crypto/rand`
- **DRBG(CTR-DRBG/HASH-DRBG)** 사용. 시드/재시드 정책 수립

**Python 예 — 안전한 랜덤**
```python
import secrets
key = secrets.token_bytes(32)   # 256-bit key
nonce = secrets.token_bytes(12) # 96-bit GCM nonce
```

---

### 14.2.5 안전한 구현 패턴(코드 스니펫)

**(1) AEAD-GCM (PyCryptodome)**
```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

def aead_encrypt(key: bytes, aad: bytes, plaintext: bytes):
    nonce = get_random_bytes(12)  # 96-bit
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce, mac_len=16)
    cipher.update(aad)
    ct, tag = cipher.encrypt_and_digest(plaintext)
    return nonce, ct, tag

def aead_decrypt(key: bytes, aad: bytes, nonce: bytes, ct: bytes, tag: bytes):
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce, mac_len=16)
    cipher.update(aad)
    # 태그 검증 실패 시 동일한 예외/메시지로 실패 (세부정보 숨김)
    try:
        return cipher.decrypt_and_verify(ct, tag)
    except ValueError:
        # 절대 "패딩 오류" vs "MAC 오류" 구분하지 말 것
        raise RuntimeError("decryption failed")
```

**(2) 쿠키/토큰(웹) — 서버측 세션 & 쿠키 옵션**
- **서버 세션**(DB/kv-store, TTL) + 쿠키에는 **세션 ID만**.
- 쿠키: `Secure`(HTTPS만), `HttpOnly`(JS 접근 금지), `SameSite=Strict/Lax`(CSRF 완화), **짧은 만료**.

**(3) JWT — 회전/키 식별자**
- 헤더에 `kid`, 서버는 **JWKS**로 공개키 제공.
- **Key rotation**: 새 키 추가 → 양쪽 허용 기간 → 구키 폐기.

**(4) KMS로 Envelope Encryption**
```python
# 의사 코드: data_key는 KMS에서 생성·랩핑, 로컬에서는 랩핑된 data_key만 저장
ciphertext = Encrypt(KMS.GenerateDataKey(), data)
# 저장: { wrapped_data_key, ciphertext, nonce, tag }
```

---

## 14.3 실전 운영 가이드 (종합 체크리스트)

### 14.3.1 비밀/키 관리
- [ ] 비밀은 **KMS/HSM/OS Keychain**으로 중앙화. 코드/이미지/레이어에 포함 금지
- [ ] **수명(TTL)·스코프** 최소화, 사용 후 즉시 폐기
- [ ] 키/토큰은 **버전(kid)** 부여, **회전 자동화**, 폐기 Playbook 준비

### 14.3.2 토큰/쿠키/세션
- [ ] 브라우저에는 **쿠키**(Secure/HttpOnly/SameSite) 우선, `localStorage` 금지
- [ ] CSRF 보호(토큰/Double Submit), OAuth는 **PKCE** 필수, 리다이렉트 URI 고정
- [ ] 재전송/리플레이 방지(nonce/일회성 토큰/서명 timestamp)

### 14.3.3 암호 구현
- [ ] **AEAD**(GCM/ChaCha20-Poly1305) 기본. CBC·CTR 사용 시 **IV/nonce 고유성** 강제
- [ ] **RFC 6979**(ECDSA k 결정론) 또는 HSM 서명
- [ ] 패딩/에러/시간 **동형 처리**(오라클 제거), 실패 사유 미노출

### 14.3.4 RNG/시드
- [ ] **OS CSPRNG**만 사용, 시드 재사용/시간 기반 금지
- [ ] 난수 소비량/고갈 시 **재시드 정책**(DRBG) 수립

### 14.3.5 비밀 검출/감사
- [ ] **pre-commit**에 secret scanner, CI 정책 게이트(High 이상 실패)
- [ ] 로그/에러/백업에 비밀 마스킹, 장기 보관 금지
- [ ] IR 시나리오: 노출 시 즉시 회전·폐기·영향 범위 평가

---

## 14.4 미니 랩: “안전 vs 취약” 비교 실습

### 랩 목표
1) **CTR nonce 재사용**으로 평문 복구 체감
2) **CBC 패딩 오라클**의 위험 이해(모의 오라클)
3) **ECDSA nonce 재사용**으로 개인키 복구

### 랩 구성
- Docker/venv로 **격리 환경** 준비
- 제공 스크립트 3종(위 예제 코드 참고)
- 위험 구현을 **안전 구현**으로 바꿔 테스트(테스트 케이스 포함)
- CI 파이프라인: **pytest + secret scanner + lint**

---

## 14.5 오류 사례 & 코드 리뷰 기준

**오류 패턴**
- [ ] “Nonce는 랜덤 한 번 생성해서 전역 재사용”
- [ ] JWT를 `localStorage`에 저장 + XSS 필터만 의존
- [ ] ECDSA에서 외부 PRNG 사용(플랫폼별 차이/고장)
- [ ] 에러 메시지에 “패딩 오류”/“MAC 오류” 구분 표기
- [ ] 로그에 `Authorization: Bearer ...` 전체 출력

**리뷰 질문**
- [ ] 이 비밀은 어디서 생성/저장/주입되며, **누가 접근**하는가?
- [ ] **유일성 보장**은 어디에서 강제되는가(코드/스토어/정책)?
- [ ] 실패 시 **동형 응답**과 **레이트 리밋**이 있는가?
- [ ] 회전/폐기/사고 대응이 **자동화**되어 있는가?

---

## 부록 A. 간단한 **nonce 충돌 방지기** (파일 기반 카운터)
```python
import os, struct, secrets

class NonceMgr:
    def __init__(self, path):
        self.path = path
        if not os.path.exists(path):
            with open(path,'wb') as f: f.write(struct.pack(">Q", secrets.randbits(64)))
    def next(self):
        with open(self.path,'r+b') as f:
            b = f.read(8)
            v = struct.unpack(">Q", b)[0]
            v = (v + 1) & ((1<<64)-1)
            f.seek(0); f.write(struct.pack(">Q", v))
            return struct.pack(">Q", v)  # 64-bit; GCM 96-bit이면 상위 32비트는 세션별 랜덤 salt 추가
# 사용: nonce = salt(4B) || NonceMgr(...).next() (12B)
```

## 부록 B. 오류를 숨기는 **균질화 예외 처리**
```python
def decrypt_aead(...):
    try:
        # verify tag
        ...
        return pt
    except Exception:
        # 항상 같은 오류, 같은 지연(지연 넣지 않는 편이 더 안전)
        raise RuntimeError("decryption failed")
```

---

# 결론
- **재사용(reuse)**은 암호 시스템의 천적입니다. **키/nonce/서명 k/쿠키/토큰**의 재사용·중복·혼용은 **즉시 금지**해야 합니다.
- **AEAD + 고유 nonce + RFC6979 + CSPRNG**는 현대적 기본 방어선입니다.
- 저장·전달·로그·백업까지 **전 주기**에서 비밀이 어떻게 흐르는지 맵을 만들고, **회전/게이트/감사**로 통제하십시오.
- 작은 습관(쿠키 옵션, 에러 동형화, secret scanner, 키 회전 자동화)이 **대형 사고**를 막습니다.
