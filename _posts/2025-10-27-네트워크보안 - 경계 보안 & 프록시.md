---
layout: post
title: 네트워크보안 - 경계 보안 & 프록시
date: 2025-10-27 16:25:23 +0900
category: 네트워크보안
---
# 11. 경계 보안 & 프록시

> 목표: **NGFW/WAF/리버스 프록시의 역할**을 명확히 구분하고, **DLP·카테고리 필터·CASB** 구성을 맥락화한다.
> **사용자·기기 인증(BYOD 포함)**을 “네트워크-아이덴티티-애플리케이션” 3계층으로 엮고,
> 실습으로 **리버스 프록시에서 TLS 종료·로깅·L7 룰**(IP/헤더/경로·속도·인증·업스트림 헬스체크)을 완성한다.

---

## 11.1 NGFW / WAF / 리버스 프록시 차이

### 11.1.1 개념 요약 표
| 구성요소 | 관점 | 주요 기능 | 장점 | 한계 |
|---|---|---|---|---|
| **NGFW** (Next-Gen Firewall) | L3~L4 + 일부 L7 | Stateful ACL, App-ID, IPS, DNS/URL 필터, SSL Inspection(옵션) | 네트워크 경계 통제의 중심, 대역폭/세션 처리 강함 | 세밀한 앱 로직 인지 한계, 복호 트래픽 처리시 성능 부담 |
| **WAF** (Web Application Firewall) | L7(HTTP/HTTPS) | 시그니처/규칙 기반 공격 차단(SQLi/XSS 등), 가상패치, 봇 억제 | 웹 취약점에 특화, 앱 변경 없이 방어 레이어 추가 | 룰 튜닝 필요, 신기술(HTTP/2/3, GraphQL) 적응 필요 |
| **리버스 프록시/ADC** | L4~L7 | TLS 종료, 라우팅, 로드밸런싱, 캐시, 압축, 인증/권한 위임 | 공통 기능을 중앙화, mTLS·OIDC·관측·정책의 허브 | 보안장비는 아님(정책 조합 필요), 잘못 설정 시 단일 실패점 |

> 실무 포인트: **NGFW**로 네트워크 경계(암·평문, 비HTTP까지), **리버스 프록시**로 TLS·라우팅·인증,
> **WAF**로 애플리케이션 공격 방어를 **레이어드**로 결합. 각자의 **역할 경계**를 문서화한다.

### 11.1.2 배치 패턴
- **(외부→) [NGFW] → [리버스 프록시] → [WAF 플러그인/앞단/인라인] → [앱]**
- **Service Mesh**(mTLS·정책)는 **동서(East-West)**, 리버스 프록시는 **남북(North-South)**가 주역.

---

## 11.2 DLP / 카테고리 필터, CASB

### 11.2.1 DLP(데이터 유출 방지)
- **트리거 채널**: 웹 업로드, 이메일, 클라우드 저장소, 프록시를 경유한 SaaS API
- **패턴 예시**(정규표현 + 체크디지트):
  - **주민등록번호**(예: 형식/체크): `\b\d{6}-\d{7}\b` + 유효성 함수
  - **신용카드 PAN**: `\b(?:\d[ -]*?){13,19}\b` + **Luhn** 검사
  - **고객코드/사번**: 접두 규칙 + 길이 제약
- **정책 설계**: “탐지 → 마스킹/차단 → 예외 요청(만료일) → 감사 로그/리포트”

**Python Luhn 예(검사용)**
```python
def luhn_ok(num):
    digits = [int(c) for c in num if c.isdigit()]
    s = 0
    for i,d in enumerate(digits[::-1]):
        s += d if i%2==0 else (d*2 - 9 if d*2>9 else d*2)
    return s % 10 == 0
```

### 11.2.2 카테고리(도메인/URL) 필터
- 목적: **업무 무관/위험군**(도박/성인/피싱/신생 도메인)을 **프록시/NGFW**에서 차단
- 부가: **파일형식 정책**(예: `application/octet-stream` 업로드 제한), **업로드 속도/크기** 제한

### 11.2.3 CASB(Cloud Access Security Broker)
- **가시성**: **Shadow IT**(허가받지 않은 SaaS) 탐지 — 프록시·DNS·FW 로그 → **앱 카탈로그** 매칭
- **정책**: 앱 위험등급(BBB 이상 허용), **다운로드 워터마킹**, 외부공유 차단, **단일세션 제어**(역프록시 방식)
- **통합**: IdP(SAML/OIDC), EDR/MDM(기기상태), DLP(콘텐츠), SWG(프록시)

> 실무 팁: CASB로 **허용 SaaS 리스트(Allow-list)**를 **문서화**하고, **미승인 앱 접근**은
> 리디렉션(신청 포털) + 사유 기록 + 재검토 워크플로우로 운영.

---

## 11.3 인증(기기/사용자)·BYOD 고려

### 11.3.1 아이덴티티 기반 경계
- **사용자 인증**: OIDC/SAML(SSO), **MFA**
- **기기 인증**: **mTLS(클라이언트 인증서)**, MDM 컴플라이언스(암호화·패치·EDR)
- **정책**: “**사용자** + **기기상태** + **위치/위험** + **시간대**” → **접근 결정을 컨텍스트화**

### 11.3.2 BYOD(비관리 기기) 정책 예
- **허용 범위**: 브라우저 기반 **OPAQUE/IdP** 접근만(다운로드 제한), **클립보드/프린트 제한**
- **프록시**: 역프록시에서 **헤더에 기기 ID·건강상태** 삽입 (비관리 기기는 `X-Device-Posture: unknown`)
- **옵션**: **Clientless ZTNA**(역프록시 + IdP + CASB)로 미관리 기기에 **읽기 전용** 권한

**역프록시 헤더 전달 예(허브로)**
```nginx
proxy_set_header X-User         $remote_user;
proxy_set_header X-Device-Posture  $http_x_device_posture; # IdP/CASB가 삽입
proxy_set_header X-Auth-Method  oidc;
```

### 11.3.3 세션 무결성
- **SameSite/Lax 또는 Strict**, `HttpOnly` 쿠키, **CSRF 토큰**
- 프록시에서 **헤더 화이트리스트**, **Hop-by-hop 헤더 제거**(`Connection`, `Transfer-Encoding`, `Upgrade*` 제어)
- **JWT 검증**(aud/iss/exp/nbf/sig) — **프록시 단계에서 1차 차단** 권장

---

## 11.4 실습: 리버스 프록시로 TLS 종료·로깅·L7 룰

> 목표: Nginx(혹은 Envoy/HAProxy)를 **정면에 배치**해
> **TLS 종료**, **OIDC 인증(선택)**, **요청 로깅(JSON)**, **L7 룰(속도·메서드/헤더/경로 제한)**,
> **WAF(ModSecurity CRS)**, **업스트림 헬스체크/회로차단**까지 구성한다.

### 11.4.1 랩 토폴로지
```
[Internet]
   │
[NGFW] ── [Reverse Proxy (Nginx/Envoy)] ── [WAF 모듈/측면] ── [App]
                     │
                 [IdP(OIDC)]
```

---

### 11.4.2 Nginx: TLS 종료 + 강한 암호군 + HSTS
```nginx
# /etc/nginx/conf.d/site.conf
server {
  listen 443 ssl http2;
  server_name app.example.com;

  # TLS
  ssl_certificate     /etc/nginx/certs/fullchain.pem;
  ssl_certificate_key /etc/nginx/certs/privkey.pem;
  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_ciphers 'ECDHE+AESGCM:ECDHE+CHACHA20:!aNULL:!MD5:!RC4:!3DES';
  ssl_prefer_server_ciphers on;
  ssl_session_timeout 1d;
  ssl_session_cache shared:SSL:50m;

  # HSTS (롤백 주의)
  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

  # 보안 헤더
  add_header X-Frame-Options DENY always;
  add_header X-Content-Type-Options nosniff always;
  add_header Referrer-Policy strict-origin-when-cross-origin always;
  add_header Content-Security-Policy "default-src 'self'" always;

  # 업스트림
  set $upstream "http://app_backend";
  location / {
    proxy_pass $upstream;
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
  }
}
upstream app_backend {
  zone app_zone 64k;
  server 10.10.10.20:8080 max_fails=3 fail_timeout=10s;
  server 10.10.10.21:8080 max_fails=3 fail_timeout=10s;
  keepalive 64;
}
```

**테스트**
```bash
curl -I https://app.example.com
# 응답 헤더에 HSTS/CSP/보안헤더 확인
```

---

### 11.4.3 구조화 로깅(JSON) + 요청/응답 샘플링
```nginx
log_format json_combined escape=json
  '{'
  '"time":"$time_iso8601",'
  '"remote":"$remote_addr",'
  '"method":"$request_method",'
  '"uri":"$request_uri",'
  '"status":$status,'
  '"bytes":$bytes_sent,'
  '"ua":"$http_user_agent",'
  '"ref":"$http_referer",'
  '"req_id":"$request_id",'
  '"upstream":"$upstream_addr",'
  '"up_status":"$upstream_status",'
  '"rt":$request_time,'
  '"urt":$upstream_response_time'
  '}';

access_log /var/log/nginx/access.json json_combined;

# 샘플링(에러/느린 요청은 항상 기록)
map $status $loggable { default 0; ~^[45] 1; }
map $request_time $slow { default 0; ~^([3-9]|\d{2,}) 1; }
map "$loggable$slow" $sample { default 0; "10" 1; "01" 1; "00" 0; }
map $request_id $rand { default 0; } # 외부 Lua 모듈/변수 사용 가능
```

> 실제 샘플링은 **OpenTelemetry Collector**나 **로그 파이프라인**에서 처리하는 편이 간결하다.

---

### 11.4.4 L7 룰: 메서드·경로·헤더·IP/국가·속도 제한

**(1) 메서드/경로 화이트리스트**
```nginx
location /api/ {
  if ($request_method !~ ^(GET|POST|PUT|DELETE)$) { return 405; }
  proxy_pass http://app_backend;
}
location ~* \.(php|cgi|sh|pl)$ { return 403; }  # 정적 경로 보호
```

**(2) 헤더 검증(Host, Content-Type)**
```nginx
# Host 헤더 고정
if ($host != "app.example.com") { return 421; }

# JSON만 받는 API
location /api/json {
  if ($http_content_type !~ "application/json") { return 415; }
  proxy_pass http://app_backend;
}
```

**(3) IP/국가 기반(GeoIP2 모듈 사용 가정)**
```nginx
# 예: 특정 국가만 허용(정책에 따라 차단/허용 반전 가능)
# geoip2 /etc/nginx/GeoLite2-Country.mmdb { ... }
# map $geoip2_data_country_code $allowed { default 0; KR 1; US 1; }
if ($allowed = 0) { return 451; }
```

**(4) 속도 제한(Rate Limit)**
```nginx
limit_req_zone $binary_remote_addr zone=api_rpm:10m rate=120r/m;
limit_conn_zone $binary_remote_addr zone=connip:10m;

location /api/ {
  limit_req zone=api_rpm burst=60 nodelay;
  limit_conn connip 20;
  proxy_pass http://app_backend;
}
```

---

### 11.4.5 JWT / OIDC(역프록시 선검증)

**(A) Nginx + lua-resty-jwt (개념)**
```nginx
# jwks 캐시/검증은 lua-resty-openidc 권장(단, 복잡)
location /api/secure/ {
  access_by_lua_block {
    local jwt = require "resty.jwt"
    local token = ngx.var.http_authorization
    if not token or not token:find("Bearer ") then
      return ngx.exit(401)
    end
    token = token:gsub("Bearer ","")
    local validators = {
      exp = true, nbf = true,
      iss = "https://idp.example.com/",
      aud = "myapi"
    }
    local jwk = get_jwk_cached_somehow() -- 구현 필요
    local verified = jwt:verify_jwk(token, jwk, validators)
    if not verified.valid then
      return ngx.exit(401)
    end
  }
  proxy_pass http://app_backend;
}
```

**(B) Envoy JWT 필터(대안)**
```yaml
http_filters:
- name: envoy.filters.http.jwt_authn
  typed_config:
    "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
    providers:
      idp:
        issuer: "https://idp.example.com/"
        remote_jwks:
          http_uri:
            uri: https://idp.example.com/.well-known/jwks.json
            cluster: idp_jwks
        forward: true
    rules:
    - match: { prefix: "/api/secure" }
      requires:
        provider_name: idp
```

> 권장: **Envoy/Traefik** 등 **네이티브 OIDC/JWT 필터** 사용(운영 난이도↓).

---

### 11.4.6 WAF(OWASP CRS) 통합

**Nginx + ModSecurity + CRS**
```nginx
modsecurity on;
modsecurity_rules_file /etc/nginx/modsec/main.conf;

# main.conf 내부(요지)
# Include OWASP CRS
# SecRuleEngine On
# SecRequestBodyAccess On
# SecRuleUpdateTargetById 942100 "!REQUEST_COOKIES:/^__Secure-/"  # 튜닝 예시
```

**튜닝 팁**
- 초기엔 **DetectionOnly**로 시작 → 오탐 분류 → 룰 스킵/문턱값 조정 → **차단 모드** 전환
- GraphQL/JSON API는 **REQUEST-901-INITIALIZATION** 튜닝 가이드 참조(페이로드 파서 조정)

---

### 11.4.7 업스트림 헬스체크·회로차단(고가용성)

**Nginx 헬스체크(openresty/plus 또는 nginx upstream health)**
```nginx
upstream app_backend {
  zone app_zone 64k;
  server 10.10.10.20:8080;
  server 10.10.10.21:8080;
  keepalive 64;

  # nginx-plus/모듈일 때:
  # health_check uri=/health interval=5s fails=3 passes=2;
}
```

**Envoy 회로차단(예)**
```yaml
clusters:
- name: app_backend
  connect_timeout: 0.25s
  type: STRICT_DNS
  load_assignment:
    cluster_name: app_backend
    endpoints:
    - lb_endpoints:
      - endpoint: { address: { socket_address: { address: 10.10.10.20, port_value: 8080 } } }
  circuit_breakers:
    thresholds:
    - max_connections: 10000
      max_pending_requests: 1000
      max_requests: 5000
  health_checks:
  - timeout: 1s
    interval: 5s
    unhealthy_threshold: 3
    healthy_threshold: 2
    http_health_check: { path: "/health" }
```

---

### 11.4.8 WebSocket/gRPC 지원

**Nginx(WebSocket)**
```nginx
location /ws/ {
  proxy_pass http://app_backend;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "Upgrade";
}
```

**gRPC**
```nginx
server {
  listen 443 http2 ssl;
  location / {
    grpc_pass grpcs://grpc_backend;
  }
}
upstream grpc_backend {
  server 10.10.10.30:8443;
}
```

---

### 11.4.9 요청/응답 헤더 위생(보안 경계)
```nginx
# 백엔드로 전달 금지(혹은 재설정)
proxy_set_header Connection "";
proxy_hide_header Server;
add_header Server "edge" always;

# Hop-by-hop 제거, 내부 헤더 보호
more_clear_headers "X-Internal-*";  # (headers-more 모듈)
```

---

### 11.4.10 테스트 시나리오

**보안 헤더 & TLS 확인**
```bash
curl -I https://app.example.com
openssl s_client -connect app.example.com:443 -servername app.example.com -tls1_3 </dev/null
```

**속도 제한 체감**
```bash
for i in {1..200}; do curl -s -o /dev/null -w "%{http_code}\n" https://app.example.com/api/ & done
# 일정 비율로 429 확인
```

**WAF 탐지(테스트 페이로드)**
```bash
curl -sS -H 'Content-Type: application/x-www-form-urlencoded' \
  --data 'q=1%27%20OR%201=1--' https://app.example.com/search
# ModSecurity 로그에서 룰 트리거 확인
```

**JWT/OIDC**
```bash
# 만료/서명오류 토큰으로 401/403 기대
curl -H "Authorization: Bearer <invalid>" -I https://app.example.com/api/secure/
```

---

## 운영 체크리스트

### 구성/정책
- [ ] **역할 분리**: NGFW(경계) / 프록시(TLS·라우팅·인증) / WAF(앱 방어)
- [ ] **TLS 1.3 우선**(+ 안전 1.2), HSTS/보안헤더
- [ ] **OIDC/JWT 선검증**, BYOD는 **기기상태 미충족 시 제한**
- [ ] **L7 Allow-list**(메서드/경로/헤더/콘텐츠타입), **속도 제한**
- [ ] **파일 업/다운로드 정책**(크기·확장자·MIME·DLP)

### 가시성/관측
- [ ] **JSON 접근로그**(req_id, upstream, rt/urt) → SIEM/OTel
- [ ] **헬스체크/회로차단** 알람, 5xx/429 비율 모니터
- [ ] **WAF 오탐/미탐** 주간 리뷰, 룰 릴리즈 노트 추적

### 변경/배포
- [ ] **GitOps**(코드 리뷰·테스트), **Blue/Green** 또는 **Canary**
- [ ] **롤백 플랜**(HSTS·TLS·WAF 룰 변경 시 특히)
- [ ] **비밀/키 관리**(KMS/HSM), 인증서 자동갱신

### 컴플라이언스/프라이버시
- [ ] SSL Inspection 또는 DLP 시 **고지/동의/감사** 준수
- [ ] 로그 **보존기간/마스킹**(PII/IP), 접근권한 최소화

---

## 부록 A. HAProxy 대안 구성(핵심만)
```haproxy
global
  log stdout format raw local0
  tune.ssl.default-dh-param 2048

defaults
  mode http
  log global
  option httplog
  timeout connect 5s
  timeout client  60s
  timeout server  60s

frontend https-in
  bind :443 ssl crt /etc/pki/cert.pem alpn h2,http/1.1
  http-response set-header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
  http-request deny if { path_end .php }    # 확장자 차단 예
  http-request set-header X-Forwarded-Proto https
  acl too_many req_rate(10s) gt 60
  http-request deny deny_status 429 if too_many
  default_backend app-bk

backend app-bk
  balance roundrobin
  option httpchk GET /health
  http-check expect status 200
  server s1 10.10.10.20:8080 check
  server s2 10.10.10.21:8080 check
```

## 부록 B. 간단 DLP Nginx lua (학습용)
```nginx
location /upload {
  client_max_body_size 5m;
  access_by_lua_block {
    ngx.req.read_body()
    local data = ngx.req.get_body_data() or ""
    if data:find("%d%d%d%d%d%d%-%d%d%d%d%d%d%d") then
      return ngx.exit(406)  -- 주민번호 패턴 발견(예시)
    end
  }
  proxy_pass http://app_backend;
}
```

## 부록 C. 정책 문서 템플릿(요약)
- 서비스/도메인/경로, 소유팀/중요도
- 인증 요구(사용자/기기), BYOD 범위
- 허용 메서드/경로/헤더/콘텐츠, 속도·사이즈·파일 정책
- 로그/가시성(SLO/에러율/레이턴시 목표)
- 예외 승인/만료/리뷰 주기, 롤백 조건

---

## 요약
- **NGFW–프록시–WAF**는 **역할 분리**가 핵심: 경계 통제 / TLS·라우팅·인증 / 앱 취약점 방어.
- **DLP·카테고리·CASB**는 **데이터/앱 경계**를 보강하고, **BYOD**는 **아이덴티티+기기상태**로 제어.
- 리버스 프록시는 **TLS 종료·구조화 로깅·L7 룰·인증·헬스체크**의 허브.
- 운영은 **탐지→튜닝→차단** 단계로, **GitOps·가시성·롤백**을 항상 준비한다.
