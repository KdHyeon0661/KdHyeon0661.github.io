---
layout: post
title: 디지털신호처리 - 양자화 과정과 오차 특성
date: 2025-11-16 15:25:23 +0900
category: 디지털신호처리
---
# 양자화 과정과 오차 특성

## 양자화란 무엇인가 — 연속값을 유한 비트로

### “연속값 → 격자(grid)”로 매핑

디지털 시스템에서 **실수 신호**는 결국 **유한 비트**로 표현된다.
표현 과정은 크게 두 단계:

1. **범위 제한(clipping, limit)**
   - 입력을 \([-X_{\max}, X_{\max}]\) 범위로 제한 (그 밖은 포화/클리핑)
2. **양자화(quantization)**
   - 이 범위를 **격자점(quantization levels)** 으로 나누고,
     각 입력값을 **가장 가까운 레벨**로 매핑

수학적으로 양자화기는 (스텝 \(\Delta\)):

$$
Q(x) = \Delta \cdot \mathrm{round}\left(\frac{x}{\Delta}\right)
$$

또는, 구현에 따라 floor/ceil을 사용한다.

양자화 오차(또는 양자화 잡음)는

$$
e(x) = Q(x) - x.
$$

### 균일 양자화와 스텝 크기

**균일(uniform) 양자화기**는 레벨 간격이 일정하다.

- 풀 스케일 범위: \([-X_{\max}, X_{\max}]\)
- 유효 코드 수: \(2^B\) (B 비트)
- 양자화 스텝:

$$
\Delta = \frac{2 X_{\max}}{2^B}.
$$

양자화 레벨은 미드트레드/미드라이즈에 따라 달라진다.

---

## 균일 양자화기: 미드트레드 vs 미드라이즈

### 양자화기

**0 주변에 레벨 0**(데드존)이 존재:

$$
Q_{\text{mt}}(x) = \Delta \cdot \left\lfloor \frac{x}{\Delta} + \frac{1}{2} \right\rfloor.
$$

- \(|x| < \Delta/2\) 이면 \(Q_{\text{mt}}(x) = 0\).
- 작은 DC 성분이 “0으로 끌려가는” 효과 → **작은 신호 바이어스** 가능.

### 양자화기

**레벨 0이 없음**, 0은 임계점(threshold):

$$
Q_{\text{mr}}(x) = \Delta \cdot \left( \left\lfloor \frac{x}{\Delta} \right\rfloor + \tfrac{1}{2} \right).
$$

- 레벨은 \(\pm \Delta/2, \pm 3\Delta/2, \dots\) 등.
- 아날로그-디지털 변환기에서 코딩 방식에 따라 채택.

### GNU Octave 구현 (미드트레드/미드라이즈)

```octave
function y = q_uniform_mid_tread(x, Delta)
  % 미드트레드: round() 사용
  y = Delta * round(x / Delta);
end

function y = q_uniform_mid_rise(x, Delta)
  % 미드라이즈: floor() + 0.5
  y = Delta * (floor(x / Delta) + 0.5);
end
```

**주의**: 실제 하드웨어 ADC는 코드 맵핑이 더 복잡할 수 있지만,
이 이상화 모델로도 **오차 특성, SNR** 분석에는 충분하다.

---

## 과립 영역 vs 과부하 영역

### 영역

\(|x| \ll X_{\max}\) 일 때, 양자화기 내부에서:

- 입력이 양자화 레벨 사이를 “자잘하게” 움직이고
- 오차 \(e\) 가 대략 \(\pm \Delta/2\) 범위에서 톱니파 모양으로 변화

이 영역에서는 양자화 오차를 대략 **균일 분포**로 모델링할 수 있다.

### 영역

\(|x| > X_{\max}\) 일 때:

- 출력은 \(\pm X_{\max}\) 근처 레벨로 **포화**
- 오차는 매우 큰 **비선형 왜곡**
  (하모닉, 인터모듈레이션, 스퓨리어스 발생)

이 영역의 오차는 단순한 “작은 잡음”이 아니라
**“클리핑에 의한 왜곡”** 으로 봐야 한다.

### Octave 실험: 과립 vs 과부하

```octave
clear; close all; clc;

Delta = 1/16;
Xmax  = 1;
B     = log2(2*Xmax/Delta);

n = 0:999;
t = n / 1000;

% (1) 과립 영역: 작게 진폭 조절
xg = 0.3 * sin(2*pi*5*t);   % |x| << Xmax
% (2) 과부하 영역: 포화 발생
xo = 1.2 * sin(2*pi*5*t);   % |x| > Xmax

yg = q_uniform_mid_tread(xg, Delta);
eg = yg - xg;

yo = q_uniform_mid_tread(xo, Delta);
eo = yo - xo;

printf("B≈%.1f bits\n", B);
printf("granular: var(e)=%.3e, max|e|=%.3f\n", var(eg), max(abs(eg)));
printf("overload: overload rate=%.2f%%, max|e|=%.3f\n", ...
       100*mean(abs(xo) > Xmax), max(abs(eo)));

figure;
subplot(2,1,1);
plot(t, xg, 'b-', t, yg, 'r.');
title('과립 영역: 입력/양자화 출력');
xlabel('time'); ylabel('amplitude'); grid on;
legend('x_g', 'Q(x_g)');

subplot(2,1,2);
plot(t, xo, 'b-', t, yo, 'r.');
title('과부하 영역: 입력/양자화 출력 (포화)');
xlabel('time'); ylabel('amplitude'); grid on;
legend('x_o', 'Q(x_o)');
```

- 과립 영역에서는 \(|e|\le \Delta/2\) 근처에서 작게 움직인다.
- 과부하 영역에서는 \(|e|\)가 매우 커지며 **포화 비선형**이 발생한다.

---

## 양자화 오차의 확률 모델

### 균일 잡음 가정 (Widrow 모델)

입력 신호가 다음 조건을 만족하면,

1. 양자화 스텝 \(\Delta\) 에 비해 **충분히 많은 레벨을 가로지르고**
2. 입력이 **“복잡한” (pseudo-random-like)** 분포를 가지며
3. 양자화 오차가 입력과 “작게 상관”된다

양자화 오차를 **균일 분포**로 근사하는 것이 일반적이다.

$$
e \sim \mathcal{U}\left(-\frac{\Delta}{2}, \frac{\Delta}{2}\right)
$$

이때

$$
\mathbb{E}[e] = 0, \quad
\mathrm{Var}(e) = \frac{\Delta^2}{12}.
$$

- 분산 \(\sigma_e^2 = \Delta^2/12\) 은 이후 SNR 계산의 기본.

### 이 근사가 깨지는 경우

- 입력이 **정수배 스텝의 사인파** 와 같이 “간단한” 경우
- 입력이 **고정된 소수개의 레벨만 차지**할 때
- 디더(dither)를 넣지 않은 경우에 **입력-오차 상관**이 강하게 남는다

이때는 양자화 오차가 **균일 잡음이 아니고**,
스펙트럼에 **선형성 왜곡 스파이크**가 나타난다 (THD 증가).

---

## 사인파 입력 SNR: \(6.02B + 1.76\) dB

### 풀스케일 사인파 파워

사인파 \(x[n] = A \sin(\cdot)\)에서 평균 전력은

$$
P_s = \frac{A^2}{2}.
$$

풀 스케일 사인으로 \(A = X_{\max}\) 라고 하면

$$
P_s = \frac{X_{\max}^2}{2}.
$$

### 양자화 잡음 전력

균일 잡음 가정에서

$$
P_e = \sigma_e^2 = \frac{\Delta^2}{12}.
$$

그리고 \(\Delta = \frac{2X_{\max}}{2^B}\) 이므로,

$$
\frac{P_s}{P_e}
= \frac{X_{\max}^2/2}{(2X_{\max}/2^B)^2/12}
= \frac{X_{\max}^2/2}{4X_{\max}^2/12 \cdot 2^{-2B}}
= \frac{X_{\max}^2/2}{(X_{\max}^2/3) \cdot 2^{-2B}}
= \frac{3}{2} \cdot 2^{2B}.
$$

따라서 SNR(dB):

$$
\mathrm{SNR}
= 10 \log_{10}\left( \frac{3}{2} \cdot 2^{2B} \right)
= 10 \log_{10}\left(\frac{3}{2}\right) + 20 \log_{10}(2^B).
$$

- \(20\log_{10}(2) \approx 6.02\)
- \(10\log_{10}(1.5) \approx 1.76\)

결과:

$$
\mathrm{SNR} \approx 6.02B + 1.76~\mathrm{dB}.
$$

이는 **미국/유럽 오디오 공학**에서 수십 년간 표준적으로 쓰이는 공식이다
(16-bit CD: 약 98.1 dB).

### GNU Octave로 SNR 공식 검증

```octave
clear; clc;

Fs = 48000;
N  = 48000;
n  = 0:N-1;
t  = n / Fs;

B_list = 4:2:16;  % 4,6,8,10,12,14,16 비트
Xmax   = 1;

for B = B_list
  Delta = 2*Xmax / (2^B);

  % 비정합 주파수로 사인파 생성 (스펙트럼 누수 방지)
  f0 = 997;
  x  = 0.999*Xmax * sin(2*pi*f0*t);

  y  = q_uniform_mid_tread(x, Delta);
  e  = y - x;

  Ps = mean(x.^2);
  Pe = mean(e.^2);

  SNR_meas = 10*log10(Ps/Pe);
  SNR_theo = 6.02*B + 1.76;

  fprintf("B=%2d: measured SNR=%.2f dB | theoretical≈%.2f dB | diff=%.2f dB\n", ...
          B, SNR_meas, SNR_theo, SNR_meas - SNR_theo);
end
```

실행해 보면 `SNR_meas` 와 `SNR_theo` 가 수 dB 이내에서 잘 맞는다
(사인파가 거의 풀스케일이고, 과부하/포화 거의 없음).

---

## 양자화 오차의 스펙트럼: 잡음 vs 왜곡

### “랜덤” 입력 vs “결정론적” 입력

- 입력이 **백색 잡음** 또는 “충분히 복잡한 통신 신호”일 때
  → 양자화 오차 스펙트럼이 거의 **백색 노이즈**에 가깝다.
- 입력이 **단일 사인파**일 때
  → 오차가 입력과 강하게 상관되어 **왜곡 하모닉**이 나타난다.

이 차이가 THD(전고조파왜곡), THD+N, SINAD 등에서 큰 차이를 만든다.

### GNU Octave: 오차 스펙트럼 계산

```octave
clear; close all; clc; pkg load signal;

Fs = 48000;
N  = 65536;
n  = 0:N-1;
t  = n / Fs;

B     = 10;
Xmax  = 1;
Delta = 2*Xmax / (2^B);

f0 = 1000.3;    % 약간 비정합
x  = 0.9*Xmax * sin(2*pi*f0*t);

y  = q_uniform_mid_tread(x, Delta);
e  = y - x;

% 창을 곱한 뒤 FFT
w = hann(N).';
E = fft(e .* w);
X = fft(x .* w);

f = (0:N-1)*Fs/N;

% 단측 스펙트럼
E_mag = 20*log10(abs(E(1:N/2))/max(abs(E(1:N/2))));
X_mag = 20*log10(abs(X(1:N/2))/max(abs(X(1:N/2))));

figure;
subplot(2,1,1);
plot(f(1:N/2), X_mag);
xlabel('Frequency [Hz]'); ylabel('Magnitude [dB]');
title('입력 사인파 스펙트럼');
grid on;

subplot(2,1,2);
plot(f(1:N/2), E_mag);
xlabel('Frequency [Hz]'); ylabel('Magnitude [dB]');
title('양자화 오차 스펙트럼');
grid on;
```

- 오차 스펙트럼에서 **입력 톤 주변/고조파 위치에 스파이크**가 보인다.
- 입력이 복잡해지거나 디더를 추가하면, 오차 스펙트럼이 더 평탄해진다.

---

## 디더(Dither): 왜곡을 잡음으로 바꾸기

### 디더의 목적

- 디더는 **의도적으로 넣는 작은 잡음**이다.
- 목표:
  - 양자화 오차를 **입력과 무상관**에 가깝게 만들고
  - **비선형 왜곡 스파이크**를 제거하며
  - 대신 **잡음 플로어**를 약간 높인다.

특히, 오디오/계측/영상에서 **디더+양자화**는 미국/유럽 표준 문헌에서
“왜곡 없는 선형 시스템 근사”를 위해 필수로 다루어진다.

### 디더

- 송신측:
  - \(u = x + d\) (입력에 디더 \(d\) 추가)
  - \(y = Q(u)\)
- 수신측:
  - \(\hat{x} = y - d = x + e'\)

이때 적절한 디더 분포를 쓰면:

- \(e'\)는 **입력과 무상관**, 평균 0
- 분포는 **균일 또는 다른 설계된 분포**

### RPDF vs TPDF 디더

- **RPDF(Random, Uniform) 디더**:
  - \(d \sim \mathcal{U}(-\Delta/2, \Delta/2)\)
  - 감산형 구조에서 **무상관/무바이어스** 조건을 만족시키지만,
    모든 경우에 스펙트럼 왜곡을 완벽히 제거하는 것은 아니다.
- **TPDF(Triangular) 디더**:
  - 독립 RPDF 두 개의 합: \(d = d_1 + d_2\),
    \(d_1, d_2 \sim \mathcal{U}(-\Delta/2, \Delta/2)\)
  - 분포는 \((- \Delta, \Delta)\) 범위의 삼각형
  - 감산형 TPDF 디더는 **바이어스/왜곡 제거** 측면에서 **표준적인 선택**이다.

TPDF 디더의 분산:

$$
\sigma_d^2 = 2 \cdot \frac{\Delta^2}{12} = \frac{\Delta^2}{6}.
$$

### GNU Octave: 디더 실험

```octave
clear; close all; clc;

Fs = 48000;
N  = 48000;
n  = 0:N-1;
t  = n / Fs;

B     = 12;
Xmax  = 1;
Delta = 2*Xmax/(2^B);

x = 0.8 * sin(2*pi*1000*t);

% (1) 무디더
y0 = q_uniform_mid_tread(x, Delta);
e0 = y0 - x;

% (2) 감산형 RPDF 디더
rand("seed", 0);
d1 = (rand(size(x)) - 0.5) * Delta;
y1 = q_uniform_mid_tread(x + d1, Delta);
e1 = (y1 - d1) - x;

% (3) 감산형 TPDF 디더
rand("seed", 0);
d2 = (rand(size(x)) - 0.5) * Delta + (rand(size(x)) - 0.5) * Delta;
y2 = q_uniform_mid_tread(x + d2, Delta);
e2 = (y2 - d2) - x;

printf("Var(e0)=%.3e | Var(e1)=%.3e | Var(e2)=%.3e (TPDF theory=Δ^2/6=%.3e)\n", ...
       var(e0), var(e1), var(e2), Delta^2/6);

printf("corr(x,e0)=%.3e | corr(x,e1)=%.3e | corr(x,e2)=%.3e\n", ...
       corr(x',e0'), corr(x',e1'), corr(x',e2'));

% 스펙트럼 비교
Nfft = 65536;
w    = hann(Nfft).';

E0 = fft(e0(1:Nfft).*w);
E2 = fft(e2(1:Nfft).*w);
f  = (0:Nfft-1)*Fs/Nfft;

E0_mag = 20*log10(abs(E0(1:Nfft/2))/max(abs(E0(1:Nfft/2))));
E2_mag = 20*log10(abs(E2(1:Nfft/2))/max(abs(E2(1:Nfft/2))));

figure;
subplot(2,1,1);
plot(f(1:Nfft/2), E0_mag);
title('무디더 양자화 오차 스펙트럼');
xlabel('Frequency [Hz]'); ylabel('dB'); grid on;

subplot(2,1,2);
plot(f(1:Nfft/2), E2_mag);
title('TPDF 디더 사용 양자화 오차 스펙트럼');
xlabel('Frequency [Hz]'); ylabel('dB'); grid on;
```

- `corr(x,e0)`는 0에서 멀어질 수 있고,
  `corr(x,e2)`는 0에 가깝게 나온다.
- 스펙트럼에서 무디더는 **스파이크**가 있고,
  TPDF 디더는 **더 평탄한 잡음 플로어**를 보인다.

---

## 비균일 양자화와 컴팬딩(μ-law, A-law)

### 왜 비균일인가?

청각/시지각은 대략 **로그 스케일**에 가깝다.

- 작은 신호 변화에는 민감
- 큰 신호에서는 상대적인 변화(%)에 민감

따라서 균일 양자화기보다,
**작은 진폭에 더 촘촘한 레벨**을 두는 것이 효율적이다.

### 구조

1. **압축기(compressor)** \(F(x)\):
   비선형 맵핑으로 작은 신호 구간을 확대
2. **균일 양자화기**: 압축된 값 \(u = F(x)\) 에 균일 양자화 적용
3. **역압축기(expander)** \(F^{-1}(u_q)\):
   복원 단계에서 재확장

이 전체 구조가 **비균일 양자화**와 동등하다.

### μ-law

표준방식 중 하나 (북미/일본에서 역사적으로 많이 쓰임):

입력 \(|x|\le 1\) (정규화) 에 대해

$$
F_\mu(x) = \operatorname{sgn}(x) \, \frac{\ln(1 + \mu |x|)}{\ln(1+\mu)}.
$$

- 파라미터 \(\mu \approx 255\) (8-bit 음성 코덱 등에서 사용).
- 작은 \(|x|\)에 대해 기울기가 크고, 큰 \(|x|\)에서 포화.

역함수(역압축):

$$
F_\mu^{-1}(y) = \operatorname{sgn}(y) \, \frac{(1+\mu)^{|y|}-1}{\mu}.
$$

### A-law

유럽 등에서 쓰인 방식:

$$
F_A(x)=
\begin{cases}
\operatorname{sgn}(x)\,\dfrac{A|x|}{1+\ln A}, & 0\le |x|<1/A\\[6pt]
\operatorname{sgn}(x)\,\dfrac{1+\ln(A|x|)}{1+\ln A}, & 1/A\le |x|\le 1
\end{cases}
$$

역함수도 구간별로 정의된다.

### GNU Octave: μ-law 실험

```octave
function y = mu_compress(x, mu)
  y = sign(x) .* log(1 + mu*abs(x)) / log(1 + mu);
end

function x = mu_expand(y, mu)
  x = sign(y) .* ((1 + mu) .^ abs(y) - 1) / mu;
end

clear; clc;

mu   = 255;
B    = 8;
Xmax = 1;
Delta = 2*Xmax/(2^B);

Fs = 48000;
t  = linspace(0, 1, Fs);

% 아주 작은 사인파
x = 0.05 * sin(2*pi*1000*t);

% (1) 균일 양자화만
y_uni = q_uniform_mid_tread(x, Delta);
e_uni = y_uni - x;

% (2) μ-law 컴팬딩 + 균일 양자화 + 역컴팬딩
u      = mu_compress(x, mu);
u_q    = q_uniform_mid_tread(u, Delta);
x_mu   = mu_expand(u_q, mu);
e_mu   = x_mu - x;

fprintf("RMS error (uniform) = %.3e\n", rms(e_uni));
fprintf("RMS error (μ-law)   = %.3e\n", rms(e_mu));

figure;
subplot(2,1,1);
plot(t, x, 'k', t, y_uni, 'r');
title('작은 신호: 균일 양자화 출력');
xlabel('time'); ylabel('amplitude'); grid on;

subplot(2,1,2);
plot(t, x, 'k', t, x_mu, 'b');
title('작은 신호: μ-law 컴팬딩 + 8-bit 양자화 후 복원');
xlabel('time'); ylabel('amplitude'); grid on;
```

- 작은 진폭 신호에서 μ-law는 **실질적으로 더 정밀**한 표현을 제공한다.
- 결과적으로 RMS 오차가 균일 양자화보다 줄어드는 것을 볼 수 있다.

---

## 노이즈 셰이핑(Noise Shaping)과 ΣΔ(Delta-Sigma)

### 기본 개념

**오버샘플링** + **노이즈 셰이핑**을 이용하면,
대역 내 잡음을 줄이고 대신 **대역 밖으로 밀어낸다**.

노이즈 셰이핑 필터의 전송함수:

- 신호 전달: STF(Signal Transfer Function)
- 잡음 전달: NTF(Noise Transfer Function)

간단한 1차 ΣΔ 모듈레이터의 NTF:

$$
\mathrm{NTF}(z) = 1 - z^{-1}.
$$

즉, 잡음은 고역(고주파)에 강조된다.

고차에서는

$$
\mathrm{NTF}(z) = (1 - z^{-1})^L.
$$

### 대역 내 잡음 파워 근사

오버샘플링 비(OSR)를 기준으로, 베이스밴드 대역 내 잡음은 대략

$$
P_e \approx \frac{\Delta^2}{12} \cdot \frac{\pi^{2L}}{(2L+1)\,\mathrm{OSR}^{2L+1}}.
$$

- \(L=0\) 이면 그냥 균일 양자화 잡음: \(\Delta^2/12\).
- \(L=1\) 이면 OSR에 대해 \(OSR^3\) 로 감소.
- \(L=2\) 이면 \(OSR^5\) 등.

즉, OSR을 키우고 NTF 차수를 높이면
**대역 내 SNR이 매우 빠르게 향상**된다.

### GNU Octave: 1차 ΣΔ 간단 시뮬레이션

아주 단순화된 1차 ΣΔ 모듈레이터를 구현해 보자.

```octave
clear; close all; clc;

Fs  = 192e3;          % 오버샘플링
N   = 65536;
n   = 0:N-1;
t   = n / Fs;

fin = 1000;
x   = 0.5 * sin(2*pi*fin*t);   % in-band tone

v   = 0;
y   = zeros(1, N);

for i = 1:N
  % 1차 ΣΔ 근사: 적분기 + 1-bit 양자화 + 피드백
  % (엄밀한 구조는 교과서에 나오는 블록도 기반으로 조정 필요)
  v     = v + x(i) - (i>1)*y(i-1);  % 이산 적분 + 단순 피드백
  y(i)  = sign(v);                  % 1비트 (±1)
end

% 간단한 저역통과 + 디시메이션
R = 64;
b = ones(1, R)/R;
ylp  = filter(b, 1, y);
xdec = x(1:R:end);
ydec = ylp(1:R:end);

SNR = 10*log10(mean(xdec.^2)/mean((xdec - ydec).^2));
fprintf("단순 1차 ΣΔ + 박스카 decim SNR ≈ %.2f dB (대략적인 값)\n", SNR);

figure;
subplot(2,1,1);
plot(t(1:2000), x(1:2000));
title('입력 x[n]');
xlabel('time'); grid on;

subplot(2,1,2);
plot(t(1:2000), y(1:2000));
title('1비트 ΣΔ 출력 y[n]');
xlabel('time'); grid on;
```

- 실제 설계에서는 **안정성, 오버로드, 다단 디시메이션 필터**를 고려해야 한다.
- 여기서는 단지 **노이즈 셰이핑의 개념**과
  “오버샘플링 후 디시메이션”의 효과를 체감하는 수준까지 시뮬레이션한다.

---

## 신호 양자화 vs 필터 계수 양자화

지금까지는 “**신호 자체**”를 양자화하는 경우를 봤다.

디지털 필터 구현에서는 한 단계 더 나아가:

1. **입출력 신호 양자화**
2. **필터 계수(고정 실수) 양자화**
3. **내부 상태(누산기, 지연선) 양자화**

가 모두 영향을 미친다.

### FIR vs IIR 계수 양자화

- FIR:
  - 계수 오류가 **직접적인 선형 결합** 형태로 주파수 응답에 반영
  - 일반적으로 IIR보다 **안정성 면에서 덜 민감** (극점이 없음)
- IIR:
  - 계수의 작은 변화가 **극점 위치**를 크게 흔들 수 있음
  - 특히 극점이 단위원 근처이면, 계수 양자화로 극점이 **단위원 밖으로 튀어나가 불안정**해질 수도 있다.

### 예: IIR 저역통과 필터 계수 양자화

GNU Octave에서 Chebyshev I형 저역통과를 설계하고,
계수를 고정소수점처럼 **n_frac 비트**로 양자화하여
주파수 응답 차이를 비교해 보자.

```octave
clear; close all; clc; pkg load signal;

Fs   = 48000;
fp   = 0.2;   % 정규화 통과대역
fsb  = 0.3;   % 정규화 저지대역
Rp   = 1;     % passband ripple (dB)
Rs   = 60;    % stopband attenuation (dB)

[n, Wn] = cheb1ord(fp, fsb, Rp, Rs);
[b, a]  = cheby1(n, Rp, Wn);

[H, w]  = freqz(b, a, 4096);

% 계수 양자화: fractional bits
nfrac = 12;
bq = round(b * 2^nfrac) / 2^nfrac;
aq = round(a * 2^nfrac) / 2^nfrac;

[Hq, ~] = freqz(bq, aq, 4096);

% 극점 위치 비교
p  = roots(a);
pq = roots(aq);

fprintf("Max |H|-|Hq| ≈ %.3e\n", max(abs(abs(H) - abs(Hq))));
fprintf("Pole radii: max(|p|)-1=%.3e → after quant=%.3e\n", ...
        max(abs(p)) - 1, max(abs(pq)) - 1);

figure;
subplot(2,1,1);
plot(w/pi, 20*log10(abs(H)+eps), 'b', ...
     w/pi, 20*log10(abs(Hq)+eps), 'r--');
xlabel('Normalized Frequency (\times\pi rad/sample)');
ylabel('Magnitude [dB]');
title('IIR 계수 양자화 전/후 주파수 응답');
legend('original', 'quantized');
grid on;

subplot(2,1,2);
plot(real(p), imag(p), 'bo', real(pq), imag(pq), 'rx');
xlabel('Real'); ylabel('Imag');
title('극점 위치 변화');
axis equal; grid on;
legend('original poles', 'quantized poles');
```

- `nfrac`이 작을수록(정밀도 낮을수록) 주파수 응답 에러와 극점 이동이 커진다.
- 특히 극점 반지름이 1에 가까운 경우, 양자화로 **불안정**해질 수 있음을 확인할 수 있다.

### FIR 계수 양자화 예

FIR는 비교적 안전하지만, 통과대역 리플/저지대역 감쇠가 변할 수 있다.

```octave
clear; close all; clc; pkg load signal;

N  = 63;           % 차수
Wc = 0.3;          % 정규화 컷오프
b  = fir1(N, Wc, hamming(N+1));  % 선형 위상 FIR

[H, w] = freqz(b, 1, 4096);

nfrac = 10;
bq    = round(b * 2^nfrac) / 2^nfrac;
[Hq,~]= freqz(bq, 1, 4096);

fprintf("Max |H|-|Hq| ≈ %.3e\n", max(abs(abs(H) - abs(Hq))));

figure;
plot(w/pi, 20*log10(abs(H)+eps), 'b', ...
     w/pi, 20*log10(abs(Hq)+eps), 'r--');
xlabel('Normalized Frequency'); ylabel('Magnitude [dB]');
title('FIR 계수 양자화 전/후 주파수 응답');
legend('original', 'quantized'); grid on;
```

- FIR에서는 주로 **리플, 저지대역 감쇠**가 조금씩 변화.
- IIR보다는 안정성 위기가 적지만, 고정소수점 정밀도가 낮으면 원하는 스펙이 쉽게 깨질 수 있다.

---

## 미드트레드 vs 미드라이즈: 작은 DC 바이어스 관찰

### 작은 DC 입력 실험

```octave
clear; clc;

Delta = 1/64;

dc = 0.2 * Delta;               % 0에 아주 가까운 DC
x  = dc + 1e-6*randn(1, 200000); % 작은 랜덤 섞음

ymt = q_uniform_mid_tread(x, Delta);
ymr = q_uniform_mid_rise(x, Delta);

printf("mean bias mid-tread = %.3e\n", mean(ymt - x));
printf("mean bias mid-rise  = %.3e\n", mean(ymr - x));
```

- 미드트레드는 0 데드존 때문에 작은 DC가 **0으로 강하게 끌려가** 바이어스가 커질 수 있다.
- 미드라이즈는 임계점이 0이라, 바이어스 특성이 다르다.
  (통신/음성 등에서는 각 방식의 장단점을 고려해 선택한다.)

---

## 오버샘플링의 이득 (디더 없이)

### 개념

오버샘플링만으로도 **대역 내 잡음**이 줄어든다.

- 샘플링 주파수 \(F_s \to OSR \cdot F_s\)
- 같은 양자화기(같은 \(\Delta\), 같은 B)라도
  신호 대역폭이 상대적으로 좁아지므로, 필터링 후 디시메이션하면
  **유효 대역 내 잡음**이 줄어든다.

### GNU Octave 실험

```octave
clear; clc;

B    = 8;
Xmax = 1;
Delta = 2*Xmax/(2^B);

OSR = 8;    % 오버샘플링 비
Fs  = 48000 * OSR;
N   = Fs;
n   = 0:N-1;
t   = n / Fs;
f0  = 1000.3;

x = 0.9*Xmax * sin(2*pi*f0*t);
y = q_uniform_mid_tread(x, Delta);
e = y - x;

% 박스카 저역통과 + 디시메이션
R   = OSR;
b   = ones(1,R)/R;
elp = filter(b, 1, e);
ed  = elp(1:R:end);

x_dec = x(1:R:end);
SNR   = 10*log10(mean(x_dec.^2)/mean(ed.^2));

fprintf("SNR with OSR=%d (rough) = %.2f dB\n", OSR, SNR);
```

- 이 실험은 **균일 잡음** + 이상적인 필터 가정 하에서의 오버샘플링 이득을
  간단하게 확인하는 데 의미가 있다.
- 노이즈 셰이핑까지 포함하면 이득은 더 커진다 (§9 참조).

---

## 실무 관점 체크리스트

정리 차원에서, 실제 시스템(오디오, 통신, 센서, 제어 등)에서
“양자화 과정과 오차 특성”을 다룰 때 체크해야 할 항목을 모아보면:

1. **풀스케일 매핑**
   - 입력 범위 \([-X_{\max}, X_{\max}]\) 와 양자화기 설계를 일치시키기.
   - 과부하(overload)가 허용되는 비율(%)을 미리 정의.
2. **비트 수와 SNR 목표**
   - \( \mathrm{SNR} \approx 6.02B + 1.76 \) dB 를 기준으로
     목표 SNR에 맞는 B 선택.
   - 오버샘플링/노이즈 셰이핑을 쓰면 **유효 비트 수(ENOB)** 측면에서 보정.
3. **디더 사용 여부**
   - THD+N 대신 **왜곡 없는 잡음 플로어**가 중요하다면,
     감산형 TPDF 디더가 매우 유용.
   - 다만, 전체 SNR은 조금 떨어질 수 있음 (잡음 파워 증가).
4. **컴팬딩/비균일 양자화**
   - 작은 신호 품질/주관적 품질이 중요할 때 고려 (음성/오디오).
   - μ-law, A-law 등 표준 스펙을 충실히 구현해야 함.
5. **노이즈 셰이핑/ΣΔ**
   - 고정 비트(예: 1-bit, 5-bit)로도 높은 유효 해상도를 확보하기 위한 핵심 기술.
   - 루프 안정성, 과부하, 디시메이션 필터 설계에 특히 주의.
6. **계수 양자화**
   - IIR: 극점 위치 변화를 반드시 확인. SOS(바이쿼드) 분할, DF-II-Transposed, 레벨 스케일링 필수.
   - FIR: 리플/저지대역 감쇠 변화 체크.
     다중레이트이면 Polyphase 구조에서 정수화 영향 확인.
7. **고정소수점 정책**
   - Rounding vs truncation: truncation은 바이어스를 키운다.
   - **포화(saturation)** vs 래핑(wrap-around): 제어/안정성을 위해 포화를 선호하는 경우 많음.
8. **평가 지표**
   - SNR, SINAD, THD, THD+N, SFDR, ENOB 등 목적에 맞도록 사용.
   - 정적 테스트(사인파)와 동적 테스트(복잡 신호) 둘 다 필요.

---

## 연습문제 (Octave 실습 포함)

### 문제 1: 비트 수 vs SNR 커브 그리기

- \(B = 4, 6, 8, \dots, 16\) 에 대해
  - 이론 SNR: \(6.02B+1.76\) dB
  - 사인파(풀스케일 근처) 입력으로 측정 SNR
- GNU Octave로 두 곡선을 한 그림에 그리고, 오차를 논하라.

**힌트 코드 스케치**

```octave
B_list = 4:2:16;
SNR_meas = zeros(size(B_list));
SNR_theo = 6.02*B_list + 1.76;
% ... 사인파 만들고, 양자화, SNR 측정 후 plot
```

---

### 문제 2: 미드트레드/미드라이즈 작은 DC 바이어스 비교

- \(\Delta\)를 정하고, \(|x| \ll \Delta\) 인 작은 DC 오프셋 \(dc\)에서:
  - 미드트레드, 미드라이즈 각각의 평균 바이어스를 측정하라.
- 결과를 표로 정리하고, 어느 구조가 어떤 상황에서 더 적합한지 논하라.

---

### 비교

- TPDF 디더 스케일을 \(k\Delta\) 로 바꾸어 가며 (\(k = 0.5, 1, 2\))
- 각각에 대해
  - \(P_e\), \(\mathrm{corr}(x,e)\)
  - 오차 스펙트럼의 평탄도
- “왜곡 제거 vs 잡음 파워 증가” 트레이드오프를 실험적으로 설명하라.

---

### 문제 4: μ-law vs A-law 작은 신호 SNR

- μ-law와 A-law 컴팬딩을 각각 구현한다.
- 동일한 8-bit 균일 양자화기를 사용하고,
  작은 사인파(예: 0.05, 0.01, 0.005 진폭)에 대해 RMS 오차를 비교하라.
- 어떤 입력 레벨에서 μ-law/A-law가 균일 양자화보다 유리한지 그래프로 보여라.

---

### 문제 5: FIR/IIR 계수 양자화 감도 비교

1. 동일한 목표 스펙의 저역통과 필터를
   - 선형 위상 FIR
   - IIR (Chebyshev 또는 Butterworth)
   로 설계한다.
2. 계수를 각각 10, 12, 14 비트 fractional로 양자화한다.
3. 주파수 응답 차이(리플, 저지대역 감쇠)와
   IIR의 극점 위치 변화를 비교하라.

---

### 문제 6: 오버샘플링 + 노이즈 셰이핑 조합 이득

- 1차 ΣΔ 구조를 기준으로,
  - OSR=4, 8, 16 으로 바꿔가며
  - 단일 톤 입력에 대한 SNR을 측정하라.
- OSR에 따른 SNR 증가를 이론식과 비교하고,
  “실제 구현에서는 왜 이론보다 낮게 나오는지”에 대한 이유를 설명하라.

---

## 수식 요약

- 균일 양자화 오차(이상 모델):

  $$
  e \sim \mathcal{U}\left(-\frac{\Delta}{2}, \frac{\Delta}{2}\right),
  \quad \sigma_e^2 = \frac{\Delta^2}{12}.
  $$

- 사인파 입력 SNR:

  $$
  \mathrm{SNR} \approx 6.02 B + 1.76~\mathrm{dB}.
  $$

- μ-law 컴프레서:

  $$
  F_\mu(x) = \operatorname{sgn}(x)\,
  \frac{\ln(1 + \mu |x|)}{\ln(1+\mu)}.
  $$

- μ-law 익스팬더:

  $$
  F_\mu^{-1}(y) = \operatorname{sgn}(y)\,
  \frac{(1+\mu)^{|y|} - 1}{\mu}.
  $$

- 1차 ΣΔ NTF:

  $$
  \mathrm{NTF}(z) = 1 - z^{-1}.
  $$

- \(L\)차 노이즈 셰이핑 대역 내 잡음(근사):

  $$
  P_e \approx \frac{\Delta^2}{12}\cdot
  \frac{\pi^{2L}}{(2L+1)\,\mathrm{OSR}^{2L+1}}.
  $$

---

## 마무리 — “양자화”를 설계 변수로 보기

양자화는 피할 수 없는 **필연적인 제약**이지만,
동시에 다음과 같은 **설계 레버**이기도 하다.

- 비트 수 \(B\), 양자화 스텝 \(\Delta\)
- 디더 종류/스케일 (TPDF, RPDF, 감산형/비감산형)
- 컴팬딩(μ-law, A-law, 일반 로그/루트)
- 오버샘플링 비(OSR), 노이즈 셰이핑(ΣΔ 차수, NTF 설계)
- 필터 계수 정밀도(고정소수점 비트 분배, SOS 구조, 스케일링)

이 글에서는 **이론 수식**과 **GNU Octave 실험**을 함께 제시했다.
실제 프로젝트(오디오, 통신, 센서, 제어, 임베디드 DSP 등)에서
여기 나온 스크립트를 바로 돌려 보면서,

- “이 설계에서 **정말로 필요한 비트 수**는 몇 비트인가?”
- “디더를 넣었을 때, **THD vs SNR** 트레이드오프는 어떠한가?”
- “계수 양자화가 필터의 안정성과 스펙에 **어디까지 영향을 주는가?**”

를 수치적으로 확인하고, 그 결과를 바탕으로
**구체적인 설계/구현/테스트 전략**을 세워 나가는 것이
“양자화 과정과 오차 특성”을 제대로 활용하는 길이다.
