---
layout: post
title: 형식언어와 오토마타 - 표준 튜링 기계
date: 2025-07-30 17:20:23 +0900
category: 형식언어와 오토마타
---
# 표준 튜링 기계(Turing Machine, TM) — 정의, **언어 승인기**, **변환기**

이 글은 **표준(단일 테이프) 튜링 기계**의 형식적 정의를 정리하고,  
(1) **언어 승인기(acceptor)** 로서의 의미와 (2) **변환기(transducer)** 로서의 의미를 구분해 자세히 설명한다.  

---

## 1) 표준 튜링 기계의 형식적 정의

튜링 기계는 다음 7-튜플로 정의한다.

\[
M \;=\; (Q,\; \Sigma,\; \Gamma,\; \delta,\; q_0,\; q_{\text{acc}},\; q_{\text{rej}})
\]

- \(Q\): 유한한 **상태** 집합  
- \(\Sigma\): **입력 알파벳** (공백 기호 \(\sqcup \notin \Sigma\))  
- \(\Gamma\): **테이프 알파벳** (\(\Sigma \subseteq \Gamma\), \(\sqcup \in \Gamma\))  
- \(\delta: (Q\setminus\{q_{\text{acc}},q_{\text{rej}}\}) \times \Gamma \to Q \times \Gamma \times \{L,R\}\)  
  (**전이 함수**: 현재 상태와 읽은 기호를 보고, 새 상태/쓰기/이동(L/R)을 결정)  
- \(q_0 \in Q\): **시작 상태**  
- \(q_{\text{acc}}, q_{\text{rej}} \in Q\): **수용/거절** 상태 (둘 다 **정지** 상태)

**테이프/헤드 모델**  
- **오른쪽으로 무한**한 1차원 테이프(왼쪽 끝 존재) 또는 **양방향 무한** 테이프 가운데 하나를 쓴다. 두 모델은 계산 능력에서 **동등**하다.  
- 전형적 “표준” 정의는 이동 집합을 \(\{L,R\}\)로 두지만, **정지(Stay, \(S\))** 이동을 허용해도 동등하다(표현력 불변).

**계산의 한 단계**  
현재 상태 \(q\)와 테이프 헤드가 가리키는 기호 \(a\)에서 \(\delta(q,a)=(q',b,D)\)이면, 기계는 \(a\)를 \(b\)로 **덮어쓰고**, 헤드를 \(D\in\{L,R\}\)로 **한 칸 이동**, 상태를 \(q'\)로 바꾼다.

---

## 2) 언어 **승인기(acceptor)** 로서의 튜링 기계

### 2.1 수용 의미(semantics)

입력 \(w\in \Sigma^*\)를 테이프의 가장 왼쪽부터 적고 나머지는 공백 \(\sqcup\)으로 채운 뒤, \(q_0\)에서 시작한다.  
계산이 **정지**하여

- \(q_{\text{acc}}\)에 도달하면 **수용(accept)**,  
- \(q_{\text{rej}}\)에 도달하면 **거절(reject)**,

이라고 한다. 정지하지 않고 영원히 진행하면 **무한 루프**다.

### 2.2 인식(recognize)과 결정(decide)

- \(M\)이 **인식(recognize)** 하는 언어:
  \[
  L(M) \;=\; \{\, w\in\Sigma^* \mid \text{계산이 } q_{\text{acc}} \text{에서 정지}\,\}.
  \]
  (거절해야 할 입력에서 **무한 루프**가 날 수도 있음.)  
  이런 언어를 **RE(Recursively Enumerable)** 또는 **튜링 인식 가능** 언어라 한다.

- \(M\)이 **결정(decide)** 하는 언어: 모든 입력에서 반드시 정지(accept 또는 reject)하며,
  \[
  w\in L \Rightarrow q_{\text{acc}} \text{에서 정지},\quad
  w\notin L \Rightarrow q_{\text{rej}} \text{에서 정지}.
  \]
  이런 언어를 **재귀적(Recursive)** 또는 **결정 가능한** 언어라 한다.

> 요약: **인식**은 accept일 때만 정지를 보장(거절 입력은 루프 가능)하고, **결정**은 **모든** 입력에서 정지를 보장한다.  
> \(\text{Recursive} \subsetneq \text{RE}\) 가 성립한다.

### 2.3 설계 관점 팁

- **거절 루프**를 의도적으로 사용하면 설계가 쉬운 경우가 많다(인식기).  
- **결정기(decider)** 를 원하면, 모든 분기에서 **반드시 정지**하도록 하드 케이스를 설계해야 한다.

---

## 3) **변환기(transducer)** 로서의 튜링 기계

언어 승인기는 예/아니오(decision)를 출력한다. 반면 **변환기**는 입력 문자열을 **다른 문자열**로 **계산**한다.

### 3.1 TM이 계산하는 함수의 정의

TM \(M\)이 (부분)함수 \(f:\Sigma^* \rightharpoonup \Gamma^*\) 를 **계산(compute)** 한다는 뜻은:

- 모든 \(x\in \mathrm{dom}(f)\)에 대해 계산이 정지하며,  
  테이프(혹은 전용 출력 테이프)에 \(f(x)\)가 **규약된 형식**으로 남는다.
- \(x\notin \mathrm{dom}(f)\)일 때는 정지하지 않을 수도 있다(부분 함수).  
  모든 입력에서 정지하면 **전함수(total)** 를 계산한다.

**출력 규약(convention)** — 몇 가지 등가적 방식이 널리 쓰인다.
1. **단일 테이프 출력**: 계산이 끝난 뒤 테이프에 **결과만** 남기고 헤드를 가장 왼쪽 결과 칸에 위치.  
2. **2-테이프 I/O**: 테이프1에 입력(읽기 전용), 테이프2에 출력(쓰기 전용).  
3. **다중 테이프**: 보조 테이프를 스택/작업 영역으로 사용.

이들 모델은 계산 가능한 함수의 **범위가 동일**하다(표현력 불변).

### 3.2 “수용”과 “계산”의 차이

- 승인기: \(\{0,1\}\)값(accept/reject)만 관심 → **언어**를 다룸.  
- 변환기: 임의의 문자열을 산출 → **함수**를 다룸.  
- 둘은 긴밀히 연결된다. 예를 들어, 승인기는 사실상 함수 \(f(w)\in\{0,1\}\)를 계산하는 특별한 변환기라고 볼 수 있다.

### 3.3 예시 — 간단한 변환기 설계

#### (a) **복사기**: \(f(w)=w\) (단일 테이프)
아이디어: 입력 오른쪽 끝을 찾은 뒤, 오른쪽에 **구분자** `#`를 적고 왼쪽으로 돌아가 한 글자씩 복사.

```
(q0, a) -> (q0, a, R)   # 오른쪽 끝(첫 공백)까지 주행
(q0, ␣) -> (q1, #, L)

# 복사 루프: 왼쪽으로 돌아가 가장 왼쪽 기호부터 하나씩 오른쪽 끝(# 뒤)에 써넣기
(q1, a) -> (q2, a, R)   # 원본의 'a'를 기억하며 오른쪽 끝으로 향함
...
(q2, #) -> (q3, #, R)
(q3, ␣) -> (q4, a, L)   # 'a'를 복사하여 # 뒤에 씀
(q4, #) -> (q1, #, L)   # 다음 문자를 복사하러 되돌아감
```

(실제 전이는 더 필요하지만 핵심 아이디어는 “표시(#)로 경계 관리 + 왕복하여 복사”이다.)

#### (b) **이진수 +1**: 가장 오른쪽에서부터 올림수(carry)를 전파

```
(q0, 1) -> (q0, 1, R)  # 끝으로 이동
(q0, 0) -> (q0, 0, R)
(q0, ␣) -> (q1, ␣, L)  # 마지막 비트로

# 올림 처리
(q1, 0) -> (q_acc, 1, S)  # 0을 1로 만들고 끝
(q1, 1) -> (q1, 0, L)     # 1->0, carry 계속 왼쪽
(q1, ␣) -> (q_acc, 1, S)  # 맨 앞에서 carry가 남으면 1을 새로 앞에 붙임
```

- 입력: `1011` → 출력: `1100`  
- 부분 함수가 아니라 전함수(모든 이진 문자열에서 정지).

> 위 같은 **함수 계산** 능력 때문에, 튜링 기계가 계산 가능한 함수의 전형적 모델이 된다(= **튜링 계산 가능 함수**).

---

## 4) (참고) 시간·공간 복잡도와 “표준성”

- **시간**: 입력 길이 \(n\)에 대한 수행 단계 수.  
- **공간**: 사용한 테이프 칸 수(공백 제외).  
- **표준 단일 테이프**는 이론적 기준점으로 쓰이며, 실용적 분석에서는 **다중 테이프**나 **RAM 모델**을 병행한다. (표현력은 동일, 효율성만 상수/다항 배수 차이)

---

## 5) 설계 시 유용한 관찰(요약)

- 언어 관점(승인기):  
  - **RE(반귀납적)**: accept 입력에서 정지만 보장(거절은 루프 가능).  
  - **Recursive(결정 가능)**: 모든 입력에서 정지.  
- 함수 관점(변환기):  
  - **부분/전** 함수를 구분. 출력 규약을 먼저 정해라(단일/다중 테이프).  
  - **마크(표식) 기법**과 **왕복 주행**이 핵심 패턴.

---

## 6) 한 화면 정리

- **정의**: \(M=(Q,\Sigma,\Gamma,\delta,q_0,q_{\text{acc}},q_{\text{rej}})\),  
  \(\delta: Q\times\Gamma\to Q\times\Gamma\times\{L,R\}\).  
- **언어 승인기**: \(L(M)=\{w\mid M \text{이 } w \text{에서 } q_{\text{acc}}\text{로 정지}\}\).  
  - 인식(RE) vs 결정(Recursive) 구분.  
- **변환기**: \(M\)이 \(f:\Sigma^*\rightharpoonup \Gamma^*\)를 계산 ⇔  
  입력이 도메인에 있으면 정지하며 **규약된 형식**으로 \(f(w)\)를 남김.