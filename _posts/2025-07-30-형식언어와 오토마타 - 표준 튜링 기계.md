---
layout: post
title: 형식언어와 오토마타 - 표준 튜링 기계
date: 2025-07-30 17:20:23 +0900
category: 형식언어와 오토마타
---
# 표준 튜링 기계(Turing Machine, TM) — 정의, **언어 승인기**, **변환기**

## 0) 표기와 준비

- 입력 알파벳: \(\Sigma\), 테이프 알파벳: \(\Gamma\) (공백 \(\sqcup\in\Gamma\), \(\sqcup\notin\Sigma\)).
- 문자열 길이: \(|w|\). 리버설 \(w^R\).
- 전이 표기(관용):  
  \[
  (q,a)\mapsto(q',b,D)\quad(D\in\{L,R\})
  \]
  을 텍스트로는 **`(q,a)->(q',b,D)`** 라 쓴다.
- 좌끝 표식(옵션): \(\vdash\) 또는 `⊢` (경계 안전 처리 시 유용).

---

## 1) 표준 튜링 기계의 형식적 정의

**정의.** 표준(단일 테이프) TM은 7-튜플
\[
M=(Q,\Sigma,\Gamma,\delta,q_0,q_{\mathrm{acc}},q_{\mathrm{rej}})
\]
- \(Q\): 유한 **상태 집합**
- \(\Sigma\): **입력 알파벳**(\(\sqcup\notin\Sigma\))
- \(\Gamma\): **테이프 알파벳**(\(\Sigma\subseteq\Gamma,\ \sqcup\in\Gamma\))
- \(\delta: (Q\setminus\{q_{\mathrm{acc}},q_{\mathrm{rej}}\})\times\Gamma\to Q\times\Gamma\times\{L,R\}\)
- \(q_0\in Q\): **시작 상태**
- \(q_{\mathrm{acc}},q_{\mathrm{rej}}\in Q\): **수용/거절(정지) 상태**

**테이프/헤드 모델**
- (i) **좌끝만 있는(오른쪽 무한)** 테이프 또는 (ii) **양방향 무한** 테이프 중 하나를 사용. **계산 능력은 동등**.
- 이동 집합에 \(\{L,R\}\)만 허용해도 충분. **Stay(S)** 허용 모델은 상수배 오버헤드로 모사 가능(§8.1 참고).

**한 단계 계산**
- 현재 상태 \(q\)와 읽은 기호 \(a\)에서 \(\delta(q,a)=(q',b,D)\)이면
  1) \(a\)를 \(b\)로 덮어쓰고,
  2) 헤드를 \(D\in\{L,R\}\)로 한 칸 이동하며,
  3) 상태를 \(q'\)로 바꾼다.

---

## 2) 언어 **승인기(acceptor)** 로서의 튜링 기계

### 2.1 의미(semantics)
- 입력 \(w\in\Sigma^*\)를 테이프 좌측부터 적고 나머지는 \(\sqcup\).
- \(q_0\)에서 시작해 계산이 정지하면:
  - \(q_{\mathrm{acc}}\): **수용(accept)**,
  - \(q_{\mathrm{rej}}\): **거절(reject)**.
- 정지하지 않으면 **무한 루프**.

### 2.2 인식(recognize) vs 결정(decide)
- **인식(Recognizer, RE)**  
  \[
  L(M)=\{\,w\mid \text{계산이 }q_{\mathrm{acc}}\text{에서 정지}\,\}.
  \]
  거절해야 할 입력에서 **무한 루프 가능**.
- **결정(Decider, Recursive)**  
  모든 입력에서 **반드시 정지**(accept 또는 reject).
  \[
  w\in L\Rightarrow \text{accept},\quad w\notin L\Rightarrow \text{reject}.
  \]
- 포함 관계: \(\textbf{Recursive}\subsetneq\textbf{RE}\).

> **실무 팁**  
> - “인식기”는 거절 쪽 설계가 까다로울 때 **루프**를 활용해 빠르게 만들 수 있다.  
> - “결정기”는 **모든 분기에서 반드시 정지**하도록 케이스를 닫아야 한다(에지 케이스, 경계, 빈 입력 포함).

### 2.3 승인기 예제 ① — 짝수 개의 `1`을 갖는 이진어
\[
L=\{\,w\in\{0,1\}^*\mid \#1(w)\equiv 0\ (\mathrm{mod}\ 2)\,\}
\]

**아이디어**: 패리티 상태 \(q_{\mathrm{even}},q_{\mathrm{odd}}\).
```
(q0, 0)->(q0,0,R)          (q0, 1)->(q1,1,R)
(q1, 0)->(q1,0,R)          (q1, 1)->(q0,1,R)
(q0, ␣)->(q_acc,␣,S)       (q1, ␣)->(q_rej,␣,S)
```
- \(q_0=q_{\mathrm{even}}\), \(q_1=q_{\mathrm{odd}}\).  
- 모든 입력에서 정지하므로 **결정기**.

### 2.4 승인기 예제 ② — \(L=\{a^n b^n\mid n\ge 0\}\)
**한 테이프(표준) 설계** — “교차 지우기(mark-and-sweep)”
- 미사용 마크: `A`(a-소거), `B`(b-소거).
- 단계:
  1) 왼쪽에서 아직 마크 안 된 `a`를 `A`로 바꾸고 오른쪽으로 달려가 첫 `b`를 `B`로 마크.
  2) 다시 왼쪽 끝로 돌아가 반복.
  3) `a`가 남았는데 `b`가 없거나 그 반대면 **거절**.
  4) 더 이상 마크 안 된 문자가 없으면 **수용**.

**전이 매크로(의사)**
```
# 오른쪽으로 가며 첫 미표시 a를 A로
find_a:   (qA,a)->(qA1,A,R) | (qA,b)->(qA,b,R) | (qA,␣)->(q_chk,␣,L)
# a를 찾았으면 b를 찾으러 계속 오른쪽
pair_b:   (qA1,B)->(qA1,B,R) | (qA1,b)->(qA2,B,L) | (qA1,␣)->(q_rej,␣,S)
# 왼쪽 끝으로 돌아가 다음 a 탐색
rewind:   (qA2,x)->(qA2,x,L) for x∈{A,B,a,b} | (qA2,␣)->(qA,␣,R)

# 검사: 미표시자 남았는지
check:    (q_chk,A/B)->(q_chk,*,L) | (q_chk,a/b)->(q_rej,*,S) | (q_chk,␣)->(q_acc,␣,S)
```
- 시간 복잡도(단일 테이프): 각 짝을 맞출 때마다 **양방향 스윕** → \(O(n^2)\).  
- 다중 테이프(두 테이프: a-카운트, b-카운트)로는 \(O(n)\)로 개선 가능(§7.2).

---

## 3) **변환기(transducer)** 로서의 튜링 기계

### 3.1 함수 계산의 정의
TM \(M\)이 (부분)함수 \(f:\Sigma^*\rightharpoonup\Gamma^*\)를 **계산**한다는 말은:
- 모든 \(x\in\mathrm{dom}(f)\)에서 정지하며, 테이프(또는 출력 테이프)에 **규약된 형식**으로 \(f(x)\)가 남는다.
- \(x\notin\mathrm{dom}(f)\)에서는 정지하지 않을 수 있다(부분 함수). 모든 입력에서 정지하면 **전함수**.

**출력 규약(동치)**
1) **단일 테이프**: 종료 시 결과만 남기고 헤드를 결과의 **맨 왼쪽**에 둔다.  
2) **2-테이프 I/O**: Tape1=입력(읽기 전용), Tape2=출력(쓰기 전용).  
3) **다중 테이프**: 추가 테이프를 작업/스택으로 사용.

> 어떤 규약이든 **계산 가능한 함수의 클래스는 동일** — 모델 변경은 **효율(상수·다항)** 만 영향.

### 3.2 변환기 예제 ① — **복사기** \(f(w)=w\) (단일 테이프)
**구상**: 입력 오른쪽 끝을 찾아 `#` 경계를 넣고, 왼쪽으로 돌아가 **한 글자씩 왕복 복사**.

```
# 끝까지 주행 후 # 삽입
(q0, x)->(q0,x,R) for x∈Σ
(q0, ␣)->(q1,#,L)

# 왼쪽으로 가며 아직 복사 안 한 문자를 만나면 오른쪽 끝(# 뒤)에 복사
(q1, ␣)->(q_done,␣,R)         # 빈 입력 케이스
(q1, #)->(q1,#,L)
(q1, a)->(q2, a, R)            # 원본 a를 기억하고 우측 끝으로
(q2, a/b/#/…)->(q2,*,R)
(q2, ␣)->(q3, a, L)            # # 뒤 공백에 a를 씀
(q3, x)->(q3,x,L)               # 다시 좌로 돌아가
(q3, #)->(q1,#,L)               # 다음 문자 복사
# 모든 원본이 표식으로 마킹되었다면 정지.
```

- **시간**: 각 문자당 끝까지 스윕 → \(O(n^2)\).  
- **다중 테이프**(입력/출력 분리)에서는 **한 번 스캔**으로 \(O(n)\).

### 3.3 변환기 예제 ② — **이진수 +1** (전함수, 한 테이프)
```
# 오른쪽 끝으로 이동
(q0, 0)->(q0,0,R)    (q0,1)->(q0,1,R)
(q0, ␣)->(q1,␣,L)

# 올림(carry) 전파
(q1, 0)->(q_acc,1,S)   # 끝
(q1, 1)->(q1,0,L)      # 1→0, carry 유지
(q1, ␣)->(q_acc,1,S)   # 최상위 비트 확장: ␣에 1을 씀(= 1xxxx)
```
- 입력 `1011` → 출력 `1100`.
- 한 번의 오른쪽 주행 + 왼쪽으로 짧은 전파 → \(O(n)\).

### 3.4 변환기 예제 ③ — **두 유니어리 수의 합** \(f(1^m\#1^n)=1^{m+n}\)
- 입력 형식: `111#1111`.  
- **아이디어**: `#`를 지우고 전체를 연속된 `1` 블록으로 합친다(또는 `#`를 `1`로 바꾸고 끝으로 스윕).  
- 한 테이프 \(O(n)\) 가능.

```
(q0,1)->(q0,1,R)   (q0,#)->(q1,1,R)   (q0,␣)->(q_acc,␣,S)
(q1,1)->(q1,1,R)   (q1,␣)->(q_acc,␣,S)
```

### 3.5 변환기 예제 ④ — **문자열 뒤집기** \(f(w)=w^R\)
- **단일 테이프**: 양끝 스왑(헤드 왕복)로 \(O(n^2)\).  
- **2-테이프**: Tape1에서 좌→우로 읽어 Tape2에 우→좌로 쓰면 \(O(n)\).

---

## 4) 승인기 ↔ 변환기: 관점 연결

- 승인기는 사실상 **부울 함수** \(f:\Sigma^*\to\{0,1\}\)를 계산하는 **특수한 변환기**.  
- 반대로, 변환기는 승인기 두 개(“형식 검증기” + “계산 완료 검증기”)로 **합성 검증** 구조를 짤 수 있다.  
- **설계 팁**: 복잡한 계산을 **모듈**로 나누고, 각 모듈을 승인/변환 관점으로 구분해 책임을 명확히 하라.

---

## 5) 설계 패턴(핵심 테크닉)

### 5.1 **마커(mark) & 왕복 스윕**
- 문자를 마킹(예: `a`→`A`)하고, 다른 블록에서 **짝**을 찾아 마킹.  
- 양방향 **왕복 스윕**으로 불변식 유지(예: “A의 개수 = B의 개수”).

### 5.2 **경계 표식 & 구획**
- `#`, `⊢` 등 경계를 둬 **데이터/작업 영역**을 구별.  
- 출력 규약: 종료 시 **결과만 남기기**(normalize) 또는 **별도 출력 테이프**.

### 5.3 **다중 테이프 사고**
- 설계는 **다중 테이프**로 먼저 직관화 → 필요하면 **단일 테이프** 인코딩.  
- 복사/정렬/병합처럼 **파이프라이닝**이 명확해져 버그 감소.

### 5.4 **상태 인코딩**
- “모드”를 상태로 인코딩: `q_scanRight`, `q_mark`, `q_rewind` …  
- 상태명이 곧 **불변식**을 설명하도록 짓기.

---

## 6) 복잡도 관점(요약)

- **시간**: 단계 수. **공간**: 사용한 테이프 칸 수(공백 제외).  
- 단일·다중 테이프는 **표현력 동일**. 효율만 상수~다항 차.
  - 다중 테이프 \(T(n)\) → 단일 테이프 \(O(T(n)^2)\) (고전 상한).
  - 단일 테이프 왕복 스윕은 흔히 \(O(n^2)\).
- **예**: \(a^n b^n\) 결정기
  - 단일 테이프(교차 지우기): \(O(n^2)\)  
  - 두 테이프(카운트 이송): \(O(n)\)

---

## 7) 확장 예제: **완전 설계** & 실행 트레이스

### 7.1 승인기: \(L=\{w\#w \mid w\in\{0,1\}^*\}\) (미러 일치)
**아이디어(1테이프)**  
1) 왼쪽 블록에서 가장 왼쪽 미표시 비트를 잡아 대문자(`0→X`, `1→Y`)로 마킹.  
2) `#`를 넘어가 **오른쪽 블록의 가장 왼쪽 미검사 비트**를 찾아 **같은 값**인지 비교 후 마킹(`x`, `y`).  
3) 양쪽 모두 소진되면 수용. 불일치·남음 발생 시 거절.

**핵심 전이 스케치**
```
# 왼블록에서 미표시 비트 탐색
(qL,0)->(qPick,X,R)  (qL,1)->(qPick,Y,R)  (qL,#)->(qChk,#,R)  (qL,X/Y)->(qL,*,R)

# 오른블록에서 대응 비트 검사
(qPick,0/1/X/Y)->(qPick,*,R)  ... 스킵하여 # 뒤 첫 미표시 비트 도달
(qPick,0)-> if prev==X then (qBack,x,L) else (q_rej,0,S)
(qPick,1)-> if prev==Y then (qBack,y,L) else (q_rej,1,S)

# 되돌아가 다음 라운드
(qBack,*,L) ... #를 지나 왼블록 시작으로 복귀 → (qL,*,R)

# 종료 검사
(qChk,x/y)->(qChk,*,R)  (qChk,␣)->(q_acc,␣,S)  (qChk,0/1)->(q_rej,*,S)
```

**트레이스 예**  
입력: `101#101`
1) `qL`에서 `1`→`Y` 마킹, 오른쪽으로 가 `1` 확인 후 `y` 마킹, 왼쪽 복귀.  
2) `0`→`X` 마킹, 오른쪽 `0`→`x` 마킹.  
3) `1`→`Y` ↔ `1`→`y`.  
4) `qChk`에서 남은 미표시 없음 → **accept**.

**복잡도**: 각 글자당 왕복 → \(O(n^2)\). 다중 테이프면 \(O(n)\).

### 7.2 변환기: \(f(w)=w^R\) (2테이프, \(O(n)\))
- Tape1: 입력, Tape2: 출력.
- 알고리즘: Tape1을 끝까지 간 뒤, 왼쪽으로 가면서 Tape2에 오른쪽으로 써 넣기.

**전이 의사코드**
```
init:   (q0, a)->(q0,a,R)           # Tape1 끝까지
end:    (q0, ␣)->(q1,␣,L)

copy:   (q1, a)->(q1, a, L)         # Tape1 왼쪽으로 한 칸
        [on Tape2] write a, move R
        (q1, ␣)->(q_acc,␣,S)
```
- 한 스캔 + 한 복사 → \(O(n)\).

---

## 8) 작은 변형과 **동등성** (간단 요약)

### 8.1 **Stay(S)** 이동 허용 ↔ 불허
- S를 허용하지 않는 표준 TM으로도 다음 **왕복 매크로**로 모사 가능:
```
(q,a)->(q_tmp,b,R)
(q_tmp,x)->(q',x,L)   # 즉시 한 칸 되돌아와 q'에 도달 → 실질적 S
```
- **상수배 시간** 오버헤드.

### 8.2 **1-방향** vs **2-방향** 무한 테이프
- 1-방향으로도 **좌우 인터리빙 인코딩**(0,+1,-1,+2,-2,…) 등으로 2-방향을 모사 가능.  
- 표현력 동일, **효율 상수·다항 오버헤드** 차이만 존재.

### 8.3 **오프라인 TM**(입력 읽기 전용 + 작업 테이프)
- 표준 TM과 동등. 초기 복사 \(O(n)\) 오버헤드 후 동일.

---

## 9) 디버깅 & 검증 체크리스트

- [ ] **빈 입력**과 **단문**(길이 1,2) 케이스가 정지하는가?  
- [ ] **좌끝 경계**에서 L 이동 시 안전한가(⊢ 표식 고려)?  
- [ ] **무한 루프** 의도 여부(인식기인지 결정기인지)에 부합하는가?  
- [ ] **출력 규약**(결과만 남기기, 헤드 위치)이 명확한가?  
- [ ] 다중 테이프 설계를 단일 테이프로 내릴 때 **마커/구획**이 충돌하지 않는가?  
- [ ] 상태명과 불변식이 일치하는가(예: `q_scanRight`에서 좌로 가지 않음)?

---

## 10) 요약 카드

- **정의**: \(M=(Q,\Sigma,\Gamma,\delta,q_0,q_{\mathrm{acc}},q_{\mathrm{rej}})\),  
  \(\delta:Q\times\Gamma\to Q\times\Gamma\times\{L,R\}\).
- **승인기**: \(L(M)=\{w\mid M\text{이 }q_{\mathrm{acc}}\text{로 정지}\}\).  
  - **RE**(인식): 거절 입력에서 루프 가능.  
  - **Recursive**(결정): 모든 입력에서 정지.
- **변환기**: \(M\)이 \(f:\Sigma^*\rightharpoonup\Gamma^*\)를 계산 ⟺ 도메인 내 입력에서 정지하며 **규약된 형식**으로 결과를 출력.
- **효율**: 표현력은 단일/다중 테이프가 동등. 효율은 상수/다항 차.  
- **패턴**: 마킹, 왕복 스윕, 경계 표식, 다중 테이프 사고 → 단일 테이프 인코딩.

---

## 11) 보너스: 미니 “TM 어셈블리” 스타일 코드 예

> 아래는 **학습용 의사 어셈블리**로, 전이를 블록으로 묶어 읽기 쉽게 표현한 것이다.

```text
# 문법:
# state LABEL:
#   on SYMBOL -> write W, move {L|R|S}, goto NEXT

state START:
  on 0 -> write 0, move R, goto START
  on 1 -> write 1, move R, goto START
  on ␣ -> write ␣, move L, goto INC

# 이진 +1
state INC:
  on 0 -> write 1, move S, goto HALT_ACCEPT
  on 1 -> write 0, move L, goto INC
  on ␣ -> write 1, move S, goto HALT_ACCEPT

state HALT_ACCEPT:
  (halt accept)

state HALT_REJECT:
  (halt reject)
```

- 이 “미니 어셈블리”를 전이표 \((q,a)\mapsto(q',b,D)\) 로 기계적으로 변환 가능.
- 실제로는 모든 기호와 상태에 대해 **완전성**을 채워 넣어야 한다.

---

## 12) 마무리

- **표준 튜링 기계**의 정의는 간결하지만, **승인기**·**변환기**로의 관점 전환과 **패턴화된 설계**가 실전의 관건이다.
- 승인기는 **언어(결정/인식)**, 변환기는 **함수(부분/전)**.
- **마커/스윕/경계/다중 테이프 사고**를 습관화하면, 명확하고 검증 가능한 설계를 빠르게 얻는다.
- **효율**은 모델 변형에 따라 상수~다항 변동만 있을 뿐, **무엇을 계산할 수 있는가**의 경계는 변하지 않는다.