---
layout: post
title: 영상처리 - 이진화 기법
date: 2025-10-04 17:25:23 +0900
category: 영상처리
---
# 이진화 기법

## 1. 영상의 **이진화** (Binarization)

### 1.1 정의
그레이스케일 영상 \(f(x,y)\in[0,255]\) 를 **검정/흰색(0/255)** 의 두 값만 갖는 영상 \(g(x,y)\) 로 변환:
\[
g(x,y)=
\begin{cases}
255, & f(x,y) > T \\
0,   & f(x,y) \le T
\end{cases}
\]
- \(T\): **임계값(threshold)**  
- 필요에 따라 **반전**(흰→검, 검→흰) 옵션을 둡니다.

### 1.2 전역 vs 지역(적응형)
- **전역 임계값**: 영상 전체에 **하나의 \(T\)** 를 사용(빠르고 간단).  
- **지역/적응형**: 블록/윈도우마다 다른 \(T\) (조명 불균일에 강함).  
본 절은 전역 임계값 중 **반복적 방법(Intermeans)** 으로 \(T\) 를 자동 추정합니다.

---

## 2. **반복적 방법(Intermeans / ISODATA)**

영상의 밝기 히스토그램이 대략 **두 집단**(배경/전경)으로 나뉘는 경우 유효.  
아이디어: 임의의 임계 \(T\) 를 기준으로 두 집단 평균을 구하고 평균의 중간으로 \(T\) 를 업데이트하여 **수렴**할 때까지 반복.

### 2.1 알고리즘
초기값 \(T^{(0)}\) 를 정하고, \(k=0,1,\dots\) 대해  
\[
\mathcal{C}_1 = \{(x,y)\mid f(x,y)\le T^{(k)}\},\quad
\mathcal{C}_2 = \{(x,y)\mid f(x,y)>T^{(k)}\}
\]
\[
\mu_1 = \frac{1}{|\mathcal{C}_1|}\sum\_{(x,y)\in \mathcal{C}_1} f(x,y),\quad
\mu_2 = \frac{1}{|\mathcal{C}_2|}\sum\_{(x,y)\in \mathcal{C}_2} f(x,y)
\]
\[
T^{(k+1)} = \frac{\mu_1+\mu_2}{2}
\]
\(|T^{(k+1)}-T^{(k)}|<\epsilon\) 이거나 \(k\) 가 상한을 넘으면 종료.

### 2.2 실용 구현(히스토그램 버전)
픽셀을 매번 스캔하지 말고, 256-bin 히스토그램 \(h[i]\) 을 이용:
- 누적 개수/밝기 합을 사용해 \([0..T]\), \([T+1..255]\) 구간의 평균을 **O(1)** 에 계산  
- 보통 **수 회** 내 수렴 → 매우 빠름

---

## 3. 코어 모듈 — **히스토그램, 반복 임계, 이진화**

```cpp
// Binarize.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <cmath>
#include <algorithm>
#include <string>
#include "IppDib.h"
#include "IppImage.h"

// ===== 유틸 =====
inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }

// BGRA32 DIB → 그레이 8비트로 (BT.601 루마 근사)
inline void DibToGray8(const IppDib& dib, IppImage<uint8_t>& gray){
    gray.create(dib.width(), dib.height());
    for (int y=0; y<dib.height(); ++y){
        const uint8_t* s = (const uint8_t*)dib.bits() + (size_t)y*dib.stride();
        uint8_t* d = gray.row(y);
        for (int x=0; x<dib.width(); ++x){
            uint8_t B=s[x*4+0], G=s[x*4+1], R=s[x*4+2];
            int Y = (114*B + 587*G + 299*R + 500) / 1000; // 반올림
            d[x] = clamp_u8(Y);
        }
    }
}

// 그레이 8비트 → BGRA32(흑백표시)
inline IppDib Gray8ToDib(const IppImage<uint8_t>& g){
    IppDib d; d.create(g.width(), g.height(), 32);
    for (int y=0; y<g.height(); ++y){
        const uint8_t* s = g.row(y);
        uint8_t* dd = (uint8_t*)d.bits() + (size_t)y*d.stride();
        for (int x=0; x<g.width(); ++x){
            dd[x*4+0]=dd[x*4+1]=dd[x*4+2]=s[x]; dd[x*4+3]=255;
        }
    }
    return d;
}

// 256-bin 히스토그램
inline void Hist256(const IppImage<uint8_t>& g, std::vector<int>& hist, int& N){
    hist.assign(256, 0); N = g.width()*g.height();
    for (int y=0; y<g.height(); ++y){
        const uint8_t* p = g.row(y);
        for (int x=0; x<g.width(); ++x) ++hist[p[x]];
    }
}

// 누적분포(개수/합)
inline void PrefixCountSum(const std::vector<int>& hist,
                           std::vector<int>& ccnt, std::vector<long long>& csum){
    ccnt.resize(256); csum.resize(256);
    int c=0; long long s=0;
    for (int i=0;i<256;++i){ c+=hist[i]; s+=1LL*i*hist[i]; ccnt[i]=c; csum[i]=s; }
}

// [0..t], [t+1..255] 평균을 O(1)에 계산
inline void MeansAroundT(const std::vector<int>& ccnt, const std::vector<long long>& csum,
                         int t, double& mu1, double& mu2){
    int n1 = ccnt[t];
    int n2 = ccnt[255] - ccnt[t];
    long long s1 = csum[t];
    long long s2 = csum[255] - csum[t];
    mu1 = (n1>0)? (double)s1/n1 : 0.0;
    mu2 = (n2>0)? (double)s2/n2 : 0.0;
}

// 반복적 방법(Intermeans / ISODATA) — 히스토그램 기반
inline int IterativeThreshold(const IppImage<uint8_t>& g, int* outIters=nullptr, double eps=0.5, int maxIters=64){
    std::vector<int> hist; int N=0; Hist256(g, hist, N);
    std::vector<int> ccnt; std::vector<long long> csum; PrefixCountSum(hist, ccnt, csum);

    // 초기값: 영상 평균 또는 히스토그램 중위
    double mean = (ccnt[255]>0)? (double)csum[255]/ccnt[255] : 0.0;
    int T = (int)std::lround(mean);
    int it=0;
    for (; it<maxIters; ++it){
        double m1, m2; MeansAroundT(ccnt, csum, T, m1, m2);
        int Tnew = (int)std::lround(0.5*(m1+m2));
        if (std::abs(Tnew - T) < eps){ T = Tnew; break; }
        T = Tnew;
    }
    if (outIters) *outIters = it+1;
    return std::clamp(T, 0, 255);
}

// 이진화 적용(수정/반전 지원)
inline void ApplyThreshold(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst, int T, bool invert=false){
    dst.create(src.width(), src.height());
    if (!invert){
        for (int y=0; y<src.height(); ++y){
            const uint8_t* s = src.row(y); uint8_t* d = dst.row(y);
            for (int x=0; x<src.width(); ++x) d[x] = (s[x] > T) ? 255 : 0;
        }
    } else {
        for (int y=0; y<src.height(); ++y){
            const uint8_t* s = src.row(y); uint8_t* d = dst.row(y);
            for (int x=0; x<src.width(); ++x) d[x] = (s[x] > T) ? 0 : 255;
        }
    }
}

// 공개 API: 자동(반복적) 이진화
struct BinarizeOptions {
    bool invert = false;
    bool gaussianPreSmooth = false; // σ≈1로 사전 평활(노이즈 억제) — 구현 선택
};

inline bool BinarizeIterative(const IppDib& in, IppDib& out, int* usedT=nullptr, const BinarizeOptions& opt=BinarizeOptions{}){
    if (!in) return false;
    IppImage<uint8_t> g; DibToGray8(in, g);
    // (선택) σ=1 가우시안 블러: 3x3 분리 커널로 간단 구현 가능 — 필요 시 추가
    int iters=0; int T = IterativeThreshold(g, &iters);
    IppImage<uint8_t> bw; ApplyThreshold(g, bw, T, opt.invert);
    out = Gray8ToDib(bw);
    if (usedT) *usedT = T;
    return true;
}

// 공개 API: 수동 임계값 이진화
inline bool BinarizeManual(const IppDib& in, IppDib& out, int T, bool invert=false){
    if (!in) return false;
    IppImage<uint8_t> g; DibToGray8(in, g);
    IppImage<uint8_t> bw; ApplyThreshold(g, bw, std::clamp(T,0,255), invert);
    out = Gray8ToDib(bw);
    return true;
}
```

---

## 4. **미리보기** 기능이 있는 이진화 대화 상자

### 4.1 UX 설계
- **모드**:  
  - `Auto (Iterative)` — 자동 계산된 \(T\)  
  - `Manual` — 슬라이더(0..255)로 직접 지정  
- **옵션**: `Invert`, `Preview(미리보기)`  
- 미리보기가 체크되면 슬라이더 변경/모드 전환 시 바로 메인 창에 **미리보기 적용**.  
- `OK` 누르면 확정, `Cancel` 시 **원복**.

### 4.2 리소스 ID

```cpp
// resource.h (추가)
#define ID_MENU_BINARIZE              84010

#define IDD_BINARIZE_DLG              4100
#define IDC_RAD_BIN_AUTO              4101
#define IDC_RAD_BIN_MANUAL            4102
#define IDC_TRK_BIN_T                 4103
#define IDC_STC_BIN_TVAL              4104
#define IDC_CHK_BIN_INVERT            4105
#define IDC_CHK_BIN_PREVIEW           4106
#define IDC_BTN_BIN_RECALC            4107
```

### 4.3 RC(대화 상자/메뉴/가속키)
```rc
// ImageTool.rc (추가)
#include <commctrl.h>

POPUP "&Binary"
BEGIN
    MENUITEM "Binarize...\tCtrl+B", ID_MENU_BINARIZE
END

IDR_ACCEL ACCELERATORS
BEGIN
    "B", ID_MENU_BINARIZE, VIRTKEY, CONTROL
END

IDD_BINARIZE_DLG DIALOGEX 0,0, 300, 168
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Binarize (Global Threshold)"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Mode", -1, 12, 10, 132, 50
    AUTORADIOBUTTON "Auto (Iterative)", IDC_RAD_BIN_AUTO,   22, 24, 92, 10, WS_TABSTOP
    AUTORADIOBUTTON "Manual",           IDC_RAD_BIN_MANUAL, 22, 38, 60, 10

    LTEXT "T:", -1, 160, 18, 12, 10
    CONTROL "", IDC_TRK_BIN_T, TRACKBAR_CLASS, WS_TABSTOP | TBS_AUTOTICKS, 176, 14, 108, 24
    LTEXT "128", IDC_STC_BIN_TVAL, 288, 18, 24, 10

    AUTOCHECKBOX "Invert output", IDC_CHK_BIN_INVERT, 160, 42, 80, 12
    AUTOCHECKBOX "Preview",       IDC_CHK_BIN_PREVIEW,160, 56, 60, 12
    PUSHBUTTON   "Recalc Auto T", IDC_BTN_BIN_RECALC, 232, 42, 56, 16

    DEFPUSHBUTTON "OK",     IDOK,     168, 126, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 218, 126, 44, 16
END
```

### 4.4 대화 상자 코드 (원복을 위한 백업 & 라이브 미리보기)

```cpp
// BinarizeDlg.h
#pragma once
#include <windows.h>
#include <commctrl.h>
#include <string>
#include "resource.h"
#include "Binarize.hpp"

class BinarizeDlg {
public:
    BinarizeDlg(HWND owner, IppDib& target) : owner_(owner), target_(target) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w);
    INT_PTR OnScroll(HWND h, WPARAM w, LPARAM l);
    void    UpdateThresholdText(HWND h, int T);
    void    ApplyPreview(HWND h);
    void    RestoreOriginal(); // Cancel 처리

private:
    HWND owner_{};
    IppDib& target_;
    IppDib backup_;     // 원본 백업(취소 시 복원)
    int T_auto_=128;    // 자동 계산된 T
    int T_manual_=128;  // 슬라이더 값
    bool appliedPreview_=false;
};
```

```cpp
// BinarizeDlg.cpp
#include "BinarizeDlg.h"

INT_PTR BinarizeDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_BINARIZE_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK BinarizeDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        return ((BinarizeDlg*)l)->OnInit(h); }
    auto* self=(BinarizeDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    switch(m){
    case WM_COMMAND: return self->OnCommand(h,w);
    case WM_HSCROLL: return self->OnScroll(h,w,l);
    case WM_DESTROY: if (self) self->RestoreOriginal(); break;
    }
    return FALSE;
}
INT_PTR BinarizeDlg::OnInit(HWND h){
    // 공용 컨트롤 초기화(앱 초기화 지점에서 InitCommonControlsEx 권장)
    backup_ = target_; // 원본 백업
    // 자동 임계 계산
    {
        IppDib tmp; int usedT=0;
        BinarizeOptions opt; opt.invert=false;
        // 단순히 T_auto_만 얻기 위해 변환 호출 후 out은 버립니다.
        IppImage<uint8_t> g; DibToGray8(target_, g);
        T_auto_ = IterativeThreshold(g, nullptr);
    }
    T_manual_ = T_auto_;

    SendDlgItemMessageW(h, IDC_TRK_BIN_T, TBM_SETRANGE, TRUE, MAKELONG(0,255));
    SendDlgItemMessageW(h, IDC_TRK_BIN_T, TBM_SETPOS, TRUE, T_manual_);
    UpdateThresholdText(h, T_manual_);

    CheckRadioButton(h, IDC_RAD_BIN_AUTO, IDC_RAD_BIN_MANUAL, IDC_RAD_BIN_AUTO);
    CheckDlgButton(h, IDC_CHK_BIN_PREVIEW, BST_CHECKED); // 기본 미리보기 ON
    return TRUE;
}
void BinarizeDlg::UpdateThresholdText(HWND h, int T){
    wchar_t buf[16]; wsprintfW(buf, L"%d", T);
    SetDlgItemTextW(h, IDC_STC_BIN_TVAL, buf);
}
void BinarizeDlg::ApplyPreview(HWND h){
    BOOL preview = (IsDlgButtonChecked(h, IDC_CHK_BIN_PREVIEW)==BST_CHECKED);
    if (!preview){ 
        if (appliedPreview_){ target_ = backup_; appliedPreview_=false; InvalidateRect(owner_, nullptr, FALSE); }
        return;
    }
    bool invert = (IsDlgButtonChecked(h, IDC_CHK_BIN_INVERT)==BST_CHECKED);
    bool isAuto = (IsDlgButtonChecked(h, IDC_RAD_BIN_AUTO)==BST_CHECKED);
    int T = isAuto? T_auto_ : T_manual_;

    IppDib out;
    BinarizeManual(target_, out, T, invert); // target_ 현재 상태 기준으로 적용
    target_ = out; appliedPreview_ = true;
    InvalidateRect(owner_, nullptr, FALSE);
}
void BinarizeDlg::RestoreOriginal(){
    if (appliedPreview_){
        target_ = backup_; appliedPreview_ = false;
        InvalidateRect(owner_, nullptr, FALSE);
    }
}
INT_PTR BinarizeDlg::OnCommand(HWND h, WPARAM w){
    switch(LOWORD(w)){
    case IDC_RAD_BIN_AUTO:
    case IDC_RAD_BIN_MANUAL:
    case IDC_CHK_BIN_INVERT:
        ApplyPreview(h); return TRUE;

    case IDC_BTN_BIN_RECALC: {
        // 원본 기준 재계산(조작으로 target_가 바뀌었을 수 있으므로 backup_ 사용 권장)
        IppImage<uint8_t> g; DibToGray8(backup_, g);
        T_auto_ = IterativeThreshold(g, nullptr);
        if (IsDlgButtonChecked(h, IDC_RAD_BIN_AUTO)==BST_CHECKED){
            UpdateThresholdText(h, T_auto_);
            ApplyPreview(h);
        }
        return TRUE;
    }
    case IDOK: {
        RestoreOriginal(); // 우선 원복
        bool invert = (IsDlgButtonChecked(h, IDC_CHK_BIN_INVERT)==BST_CHECKED);
        bool isAuto = (IsDlgButtonChecked(h, IDC_RAD_BIN_AUTO)==BST_CHECKED);
        int T = isAuto? T_auto_ : T_manual_;
        IppDib out; BinarizeManual(backup_, out, T, invert); // 원본에 확정 적용
        target_ = out;
        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL:
        RestoreOriginal(); EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
INT_PTR BinarizeDlg::OnScroll(HWND h, WPARAM, LPARAM l){
    if ((HWND)l == GetDlgItem(h, IDC_TRK_BIN_T)){
        T_manual_ = (int)SendDlgItemMessageW(h, IDC_TRK_BIN_T, TBM_GETPOS, 0, 0);
        UpdateThresholdText(h, T_manual_);
        if (IsDlgButtonChecked(h, IDC_RAD_BIN_MANUAL)==BST_CHECKED) ApplyPreview(h);
    }
    return TRUE;
}
```

> 구현 메모  
> - 미리보기는 **`target_`** 를 바로 갱신하므로 OK 시에는 **백업(backup_)** 에 최종 결과를 적용하여 확정합니다. Cancel/Destroy 시 **원복**.  
> - 아주 큰 영상의 경우 슬라이더 이동 때마다 전 프레임 이진화가 부담될 수 있습니다. 필요 시 **다운샘플 미리보기**(아래 §6.4) 를 적용할 수 있습니다.

---

## 5. **이진화 메뉴** 핸들러

```cpp
// main_multiwin.cpp (발췌)
#include "BinarizeDlg.h"

// ...
case ID_MENU_BINARIZE:
    if (st && st->dib){
        BinarizeDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            UpdateStatusBasic(hWnd, st); // 상태바에 T값 표시 등을 확장 가능
        }
    }
    return 0;
```

---

## 6. 예제 & 상황

### 예제 A) **문서 스캔 이진화(텍스트 추출 전처리)**
- **상황**: 조명이 약간 기울어진 스캔 문서.  
- **절차**:  
  1) `Binary → Binarize…` 열기 → **Auto(Iterative)**, `Preview` ON  
  2) 결과가 흐리면 `Invert` 체크(흰 배경/검은 글자 기준), 필요 시 **Manual** 로 조금 조정  
  3) `OK` → 필요하면 8.2절 **가우시안** 작은 σ로 노이즈 감소 후 다시 시도  
- **결과**: 텍스트 영역이 잘 분리된 흑백 영상 → OCR/박스 검출에 적합

### 예제 B) **부품 검사(밝은 배경 위 어두운 부품)**
- **상황**: 공정 사진에서 부품 경계 분리.  
- **절차**: Auto로 기본 T 계산 → 미리보기로 경계 확인 → Manual 모드에서 **1~2 단계** 상향 조정 → `OK`.  
- **결과**: 경계가 깨끗한 마스크 획득 → 11장(엣지/허프)와 결합해 측정.

### 예제 C) **동전 세그멘테이션(후속 라벨링)**
- **상황**: 동전들이 약간 반사, 배경 균일.  
- **절차**: `Y’ 균등화(12.4)` → 이진화 Auto → (선택) 1픽셀 조정 → `OK` → 모폴로지(팽창/침식) 후 라벨링.  
- **결과**: 접촉 영역을 최소화한 깔끔한 분할 마스크.

---

## 7. 수학·정확성 보조 메모

- 반복적 방법의 수렴 기준:
\[
|T^{(k+1)}-T^{(k)}|<\epsilon\quad \text{또는}\quad T^{(k+1)}=T^{(k)}
\]
- 히스토그램 기반 평균:
\[
\mu\_1=\frac{\sum\_{i=0}^{T} i\,h[i]}{\sum\_{i=0}^{T} h[i]},\quad
\mu\_2=\frac{\sum\_{i=T+1}^{255} i\,h[i]}{\sum\_{i=T+1}^{255} h[i]}
\]
- 초기값 \(T^{(0)}\): 전체 평균 \(\bar{I}\) 가 실무에서 안정적.

> 참고: 더 고급의 전역 임계값으로 **Otsu**(클래스간 분산 극대화)가 있으나, 본 절 요구는 “반복적 방법”이므로 구현은 여기까지. 필요 시 동일한 히스토그램 누적값으로 Otsu도 쉽게 확장 가능.

---

## 8. 성능·안정성·확장 팁

### 8.1 속도
- 반복적 방법의 시간 복잡도는 \(\mathcal{O}(WH + I)\) (히스토그램 계산 + 수렴 반복 수 \(I\) 는 보통 **< 10**).  
- 슬라이더 미리보기는 **전 프레임 재이진화**이므로, 큰 영상에선 **다운샘플 미리보기**를 권장.

### 8.2 노이즈/감마
- **소금&후추**가 많으면 이진화 전 **미디언 필터(8.5절)** 가 효과적.  
- 조명 기울기(비균일)가 심하면 전역 임계값 대신 **적응형(지역) 임계값**을 고려(박스/가우시안 평균 – 이후 장 확장).

### 8.3 결과 반전/극성
- 배경 밝기/전경 밝기 극성이 뒤바뀌면 `Invert` 옵션으로 즉시 전환.

### 8.4 (선택) **다운샘플 미리보기**
아주 큰 영상(예: 24MP)에서 슬라이더 이동이 버겁다면,  
미리보기는 \( \le 1\text{MP} \) 축소판으로 계산해 임계 \(T\) 를 얻고, OK 시 원본에 적용하는 전략이 유용.

```cpp
// (선택) 미리보기용 축소 그레이 생성
inline IppImage<uint8_t> MakePreviewGray(const IppDib& src){
    IppImage<uint8_t> g; DibToGray8(src, g);
    const int maxPix = 1000*1000;
    int W=g.width(), H=g.height();
    if (W*H <= maxPix) return g;
    double scale = std::sqrt((double)maxPix/(W*(double)H));
    int w2 = std::max(1, (int)std::lround(W*scale));
    int h2 = std::max(1, (int)std::lround(H*scale));
    IppImage<uint8_t> small(w2,h2);
    for (int y=0; y<h2; ++y){
        int sy = (int)((y+0.5)/scale);
        const uint8_t* srow = g.row(std::min(sy,H-1));
        uint8_t* drow = small.row(y);
        for (int x=0; x<w2; ++x){
            int sx = (int)((x+0.5)/scale);
            drow[x] = srow[std::min(sx,W-1)];
        }
    }
    return small;
}
```

---

## 9. 간단 테스트 스니펫

```cpp
// test_binarize.cpp
#include <cassert>
#include "IppDib.h"
#include "Binarize.hpp"

int main(){
    // 64x32: 좌측(0..31) 밝기 60, 우측(32..63) 밝기 200 → T는 중간 근처
    IppDib dib; dib.create(64,32,32);
    for(int y=0;y<32;++y){
        uint8_t* d=(uint8_t*)dib.bits()+y*dib.stride();
        for(int x=0;x<64;++x){
            uint8_t g = (x<32)? 60 : 200;
            d[x*4+0]=d[x*4+1]=d[x*4+2]=g; d[x*4+3]=255;
        }
    }
    IppDib out; int usedT=0;
    bool ok = BinarizeIterative(dib, out, &usedT); assert(ok);
    // 기대: usedT ~130± (분포에 따라 약간 변동)
    assert(usedT>80 && usedT<220);

    // 수동 이진화도 동작해야 함
    ok = BinarizeManual(dib, out, 128, false); assert(ok);
    return 0;
}
```

---

## 10. 요약
- 전역 이진화는 **단일 임계값 \(T\)** 로 밝기 값을 두 클래스로 나눕니다.  
- **반복적 방법(Intermeans)** 은 히스토그램을 이용해 두 집단 평균을 반복적으로 추정하여 **빠르게 수렴**하는 실전용 자동 임계 결정법입니다.  
- 제공한 모듈로 **히스토그램 계산 → 자동 \(T\) 추정 → 이진화 적용** 이 끝-to-end로 동작하며,  
  **미리보기 대화 상자** 를 통해 실시간으로 결과를 확인·조정할 수 있습니다.