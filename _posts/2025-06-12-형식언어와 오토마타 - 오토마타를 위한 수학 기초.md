---
layout: post
title: 형식언어와 오토마타 - 오토마타를 위한 수학 기초
date: 2025-06-12 20:20:23 +0900
category: 형식언어와 오토마타
---
# 형식언어와 오토마타를 위한 수학 기초 — 개선본(심화)

형식언어·오토마타 이론은 **집합론, 관계/함수, 그래프/트리** 위에 세워진다.

---

## 표기와 기본 합의(Notation)

- 알파벳(유한 집합): $$\Sigma$$
- 문자열: $$w\in\Sigma^\*$$, 길이 $$|w|$$, 공백 $$\varepsilon$$
- 언어: $$L\subseteq\Sigma^\*$$
- 연결: $$xy$$, 거듭제곱: $$x^k$$, 클리니 별: $$L^\*=\bigcup_{k\ge0}L^k$$, 역(반전): $$w^R$$

---

## 집합(Set)

**정의** 집합은 서로 다른 원소들의 모임. 오토마타에서는 **상태 집합** $$Q$$, **알파벳** $$\Sigma$$, **언어** $$L\subseteq\Sigma^\*$$ 등에서 필수.

### 기본 연산과 기호

- 원소 포함: $$x\in A,\ x\notin A$$
- 부분집합/진부분집합: $$A\subseteq B,\ A\subsetneq B$$
- 합/교/차/여: $$A\cup B,\ A\cap B,\ A\setminus B,\ \overline{A}$$
- 곱집합: $$A\times B=\{(a,b)\mid a\in A,b\in B\}$$
- 멱집합: $$\mathcal P(A)$$ (A의 모든 부분집합들의 집합)

**언어 관점 예**
- $$\Sigma=\{a,b\}$$이면 $$\Sigma^\*=\{\varepsilon, a, b, aa, ab, ba, bb, aaa,\dots\}$$
- $$L=\{w\in\Sigma^\*\mid \#_a(w)\equiv 0\pmod 2\}$$ (a가 짝수 개인 문자열의 집합)

### 카디널리티와 열거

- $$|A|$$: 원소 개수(유한/무한). $$|\mathbb N|=|\mathbb Z|=|\mathbb Q|$$(가산), $$|\mathbb R|$$(비가산)
- $$\Sigma$$가 유한이면 $$\Sigma^\*$$는 **가산 무한**(길이 순으로 열거 가능).

### 언어 연산(집합 연산의 특수화)

- **합/교/차/여**: 정규 언어의 폐쇄성 증명에 그대로 사용
- **연결/클리니-별/역**: 문자열 연산을 언어로 올린 것
- **호모몰피즘(homomorphism)**: $$h:\Sigma^\*\to\Gamma^\*$$ (문자에 대한 치환을 **연결 보존** 방식으로 확장)

> **오토마타 연결(미리보기)**
> 정규 언어는 **동형사상 이미지/역상**에 대해 닫힘.
> 이는 집합 연산과 함수의 상호작용(§2.4)을 이용해 **구성적 자동자**를 주는 방식으로 증명된다.

### 실습(집합/언어 연산 미니 유틸)

```python
from itertools import product

def sigma_star(sigma, max_len):
    """Σ*을 길이 max_len까지 열거(교육용)."""
    yield ""
    for L in range(1, max_len+1):
        for t in product(sigma, repeat=L):
            yield "".join(t)

def lang_even_a(sigma, max_len):
    """L = { w | #a(w) 짝수 }를 부분만 생성."""
    for w in sigma_star(sigma, max_len):
        if w.count('a') % 2 == 0:
            yield w

Sigma = ['a', 'b']
print(list(lang_even_a(Sigma, 2))[:8])  # ['', 'b', 'aa', 'ab', 'ba', 'bb']
```

---

## 관계(Relations)와 함수(Functions)

### 관계(Relation)

두 집합 $$A,B$$에 대해 관계 $$R\subseteq A\times B$$. 특수하게 $$R\subseteq A\times A$$이면 **이항관계**.

- **성질**
  - 반사적(reflexive): $$\forall a\in A,\ (a,a)\in R$$
  - 대칭적(symmetric): $$(a,b)\in R \Rightarrow (b,a)\in R$$
  - 반대칭(antisymmetric): $$(a,b),(b,a)\in R \Rightarrow a=b$$
  - 추이적(transitive): $$(a,b),(b,c)\in R \Rightarrow (a,c)\in R$$

- **등가관계**: 반사적·대칭적·추이적.
  **몫집합(quotient)**: $$A/{\sim}=\{[a]_{\sim}\mid a\in A\}$$ (동치류들의 집합)

- **부분순서(PO)**: 반사적·반대칭·추이적. **포셋(poset)**과 **하세 다이어그램**.

> **오토마타 연결 ① — Myhill–Nerode**
> $$x\equiv_L y \iff \forall z\in\Sigma^\*,\ xz\in L \Leftrightarrow yz\in L$$ 는 $$\Sigma^\*$$ 위 등가관계.
> 정규성 ⇔ 동치류가 **유한 개**, 최소 DFA 상태 수 = 동치류 수.

### 함수(Function)

함수 $$f:A\to B$$는 각 $$a\in A$$에 **정확히 하나**의 $$f(a)\in B$$를 대응.

- 전사(surjective): $$\forall b\in B,\ \exists a\in A:\ f(a)=b$$
- 단사(injective): $$f(a)=f(a') \Rightarrow a=a'$$
- 전단사(bijective): 단사+전사 (역함수 존재)
- 합성: $$(g\circ f)(a)=g(f(a))$$

**역상(preimage)과 상(image)**
- $$f^{-1}(S)=\{a\in A\mid f(a)\in S\}$$, $$f(T)=\{f(a)\mid a\in T\}$$
- 집합 연산과의 상호작용:
  $$f^{-1}(X\cup Y)=f^{-1}(X)\cup f^{-1}(Y)$$, $$f^{-1}(\overline{X})=\overline{f^{-1}(X)}$$ 등

> **오토마타 연결 ② — 전이 함수**
> DFA: $$\delta:Q\times\Sigma\to Q$$ (함수), NFA: $$\Delta:Q\times\Sigma\to \mathcal P(Q)$$ (관계)
> 확장 $$\hat\delta:Q\times\Sigma^\*\to Q$$ 는 재귀로 정의되어 **멤버십**을 판정.

> **오토마타 연결 ③ — 동형사상**
> **동형사상(모노이드 호모몰피즘)** $$h:\Sigma^\*\to\Gamma^\*$$에 대해 정규 언어는
> **이미지/역상** 둘 다 정규로 닫힘. (정규성 폐쇄성의 핵심 카드)

### 실습(등가관계 → 몫집합 만들기)

```python
def partition_by_equiv(A, key):
    """
    key: 동치류를 대표하는 키 함수(예: 길이 mod k).
    반환: {대표키: [원소...]} dict
    """
    blocks = {}
    for a in A:
        k = key(a)
        blocks.setdefault(k, []).append(a)
    return blocks

# 예: Σ* (길이 ≤ 4)에 대해 길이 mod 3 동치류

Sigma = ['a','b']
A = list(s for s in ([""] + [x for L in range(1,5) for x in map("".join, __import__('itertools').product(Sigma, repeat=L))]))
blocks = partition_by_equiv(A, key=lambda w: len(w)%3)
for k, group in blocks.items():
    print(k, group[:6], "...")
```

### 실습(역상으로 정규성 유지 시연)

```python
# h: {a,b}* -> {0,1}*  (a->01, b->1)

def h(w):
    return "".join("01" if ch=="a" else "1" for ch in w)

# 정규 L0 = (0|1)* 1  (1로 끝나는 언어)

def in_L0(x):
    return len(x)>0 and x[-1]=='1'

# 역상 h^{-1}(L0) = { w | h(w)가 1로 끝남 } = { w | 마지막 문자가 b }

def in_preimage(w):
    return in_L0(h(w))

tests = ["", "a", "b", "ab", "aa", "bb"]
print({t: in_preimage(t) for t in tests})
# 이 역상 언어는 'b로 끝남'이므로 정규(DFA 2상태) — 정규의 역상 닫힘을 체감.

```

---

## 그래프(Graphs)와 트리(Trees)

오토마타는 본질적으로 **라벨이 있는 방향 그래프**다.

### 그래프 기본

- 그래프: $$G=(V,E)$$, 방향 그래프는 $$E\subseteq V\times V$$
- 용어: 인접, 차수, 경로, 사이클, DAG(사이클 없음), **강연결요소(SCC)**

> **오토마타 연결 ④ — 전이 그래프**
> DFA/NFA는 **라벨 달린 유향 그래프**.
> - **도달 가능 상태 제거**: 시작상태에서 BFS/DFS로 도달 불가 상태를 삭제
> - **곱그래프(product)**: 정규 언어의 교집합·차집합 DFA 구성

### 트리와 파스 트리

- 트리: 사이클 없는 연결 그래프(여기서는 보통 **루트 유향 트리**)
- 깊이/높이, 리프(단말), 노드 차수
- **파스 트리(Parse Tree)**: CFG 유도과정의 트리 표현(리프의 열=문자열의 **yield**)

> **오토마타 연결 ⑤ — 문맥자유/파싱**
> CFG → 파스 트리(모호성 여부 판단), CNF → **CYK**로 멤버십 판정.
> 균형/중첩 구조는 **스택**(PDA)로 모델링되어 파스 트리와 1:1 감각으로 연결.

### 실습(그래프 탐색으로 “도달 가능 상태”만 남기기)

```python
from collections import deque, defaultdict

def reachable_states(states, start, delta, alphabet):
    """delta: dict[(q,a)] = q' (DFA 스타일, 불완전 허용)"""
    adj = defaultdict(list)
    for (q,a), q2 in delta.items():
        adj[q].append(q2)
    seen, dq = set([start]), deque([start])
    while dq:
        u = dq.popleft()
        for v in adj[u]:
            if v not in seen:
                seen.add(v); dq.append(v)
    return seen

# 예: 일부 상태가 도달 불가한 DFA를 정리

states = {'q0','q1','q2','dead'}
alphabet = {'a','b'}
delta = {('q0','a'):'q1', ('q1','b'):'q2'}  # 'dead'로 가는 전이 없음
print(reachable_states(states, 'q0', delta, alphabet))  # {'q0','q1','q2'}
```

### 실습(SCC로 순환 구조 파악: Kosaraju)

```python
def kosaraju_scc(V, edges):
    # V: 정점 집합, edges: [(u,v), ...]
    adj = {v: [] for v in V}
    radj = {v: [] for v in V}
    for u, v in edges:
        adj[u].append(v); radj[v].append(u)

    seen, order = set(), []
    def dfs(u):
        seen.add(u)
        for v in adj[u]:
            if v not in seen: dfs(v)
        order.append(u)

    for v in V:
        if v not in seen: dfs(v)

    comp, cid = {}, 0
    def rdfs(u, c):
        comp[u] = c
        for v in radj[u]:
            if v not in comp: rdfs(v, c)

    for v in reversed(order):
        if v not in comp:
            rdfs(v, cid); cid += 1
    return comp, cid

# 예: 전이 그래프의 SCC 분해

V = {'q0','q1','q2','q3'}
E = [('q0','q1'),('q1','q2'),('q2','q1'),('q2','q3')]
print(kosaraju_scc(V, E))  # comp mapping, scc 개수
```

### 파스 트리 미니 예(시각적 스케치)

문법 $$S\to aSb\mid \varepsilon$$ 의 `aabb` 유도:
```
       S
     / | \
    a  S  b
      /|\
     a S b
       |
       ε
```
- 리프의 열: **a a b b** = `aabb` = yield(S)

---

## 형식언어/오토마타로의 연결 고리(요약)

- **집합**: 언어는 집합, 정규 언어의 폐쇄성은 집합 연산 + 자동자 합성으로 증명
- **관계/함수**: DFA 전이는 함수, NFA 전이는 관계(멱집합으로 올리면 함수처럼 다룸).
  동형사상 이미지/역상의 닫힘성은 **preimage의 성질**로 깔끔히 보임.
- **그래프/트리**: 전이 그래프, 곱그래프, 도달 가능성, SCC. CFG는 파스 트리로.

---

## 미니 랩(작게 만들어 보는 실전 조각)

### Lab 1. 2진수 문자열의 값이 3의 배수인 언어 DFA

- 상태: $$\{0,1,2\}$$ (나머지)
- 전이: $$r \xrightarrow{a\in\{0,1\}} (2r+a)\bmod 3$$
```python
class DFA:
    def __init__(self, states, sigma, delta, start, accepts):
        self.states=set(states); self.sigma=set(sigma)
        self.delta=dict(delta); self.start=start; self.accepts=set(accepts)
    def run(self, s):
        q=self.start
        for ch in s:
            if ch not in self.sigma: return False
            q=self.delta[(q,ch)]
        return q in self.accepts

states={'0','1','2'}; sigma={'0','1'}
delta={(r,a): str((2*int(r)+int(a))%3) for r in states for a in sigma}
dfa = DFA(states, sigma, delta, '0', {'0'})
for t in ["", "0", "11", "110", "1010", "111"]:
    print(t or "ε", dfa.run(t))
```

### Lab 2. (정규식) (a|b)*abb NFA → DFA 변환 스케치

- Thompson으로 ε-NFA 구성 → ε-폐포 → 부분집합 구성으로 DFA
- 교육용 NFA→DFA 코드는 §2.4/§7.2 예제를 재사용.

### Lab 3. CNF + CYK로 멤버십 판정

- CNF: $$S\to AB\mid BC,\ A\to a,\ B\to b,\ C\to c$$
- `ab`,`bc`는 수용, `ac`는 거부(§7.3 코드 참조)

---

## 자주 하는 실수와 바로잡기

1) **펌핑 보조정리의 방향**을 뒤집음: “펌핑 가능 ⇒ 정규”는 거짓(필요조건임).
2) **정규식 엔진 = 정규 언어**로 혼동: 역참조/전후방 등은 이론 정규식에 없음(최악 지수).
3) **여집합 뒤집기**에 불완전 DFA 사용: 정의역 전이가 빠진 상태가 있으면 여집합이 잘못된다 → **sink 상태**로 완전화 후 뒤집기.
4) **등가관계/몫집합**과 **최소 DFA**의 연결을 빼먹음: Myhill–Nerode가 바로 그 다리.
5) **파스 트리 ≠ AST**: 파스 트리는 **문법에 충실**, AST는 **의미 중심 요약**(토큰 축약/우선순위 반영).

---

## 치트시트(핵심 표)

### 정규 언어의 폐쇄성

| 연산 | 합 | 교 | 차 | 여 | 연결 | 별 | 역 | 동형사상(이미지/역상) |
|---|---|---|---|---|---|---|---|---|
| 정규 | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ |

### 관계의 성질 조합

| 성질 | 의미 | 예 |
|---|---|---|
| 반사/대칭/추이 | 등가관계 | $$\equiv_L$$(Myhill–Nerode) |
| 반사/반대칭/추이 | 부분순서 | 정규식 포함관계(언어 포함은 반대칭이 아님에 유의) |

---

## 결론

- **집합**은 언어의 운동장이고, **관계/함수**는 자동자의 전이·동형사상·몫구조를 설명한다.
- **그래프/트리**는 전이 그래프·곱그래프·파스 트리로 구현되어 **정규/문맥자유**의 실전 파이프라인(렉서→파서)에 연결된다.
- 위 카드(집합 연산/역상·이미지/등가관계·SCC·CNF→CYK)를 손에 익히면 **증명·구성·최적화**가 한층 명료해진다.
