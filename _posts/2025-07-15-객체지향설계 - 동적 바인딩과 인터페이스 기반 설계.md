---
layout: post
title: 객체지향설계 - 동적 바인딩과 인터페이스 기반 설계
date: 2025-07-15 19:20:23 +0900
category: 객체지향설계
---
# 🔗 동적 바인딩과 인터페이스 기반 설계

---

## 1. 동적 바인딩 (Dynamic Binding)

### ✅ 정의

동적 바인딩이란, **프로그램이 실행될 때(run-time)에 호출할 메서드를 결정하는 방식**을 말합니다. 이는 정적 바인딩(static binding: 컴파일 시점에 결정)과 대조되는 개념입니다.

객체 지향 언어에서는 **다형성(polymorphism)**을 구현하기 위해 주로 동적 바인딩을 사용합니다.

### ✅ 예제 (Java)

```java
class Animal {
    void sound() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍!");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("야옹!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();
        Animal a2 = new Cat();

        a1.sound();  // 출력: 멍멍!
        a2.sound();  // 출력: 야옹!
    }
}
```

위 코드에서 변수 `a1`과 `a2`는 **컴파일 타임에는 `Animal` 타입**이지만, **런타임에는 `Dog`와 `Cat` 객체**를 참조합니다. 따라서 호출되는 메서드는 실행 시점에 결정됩니다.

---

### ✅ 왜 중요한가?

- **유연성 증가**: 상위 타입으로 코드를 작성하고, 하위 타입으로 행동을 바꾸는 유연한 구조 가능
- **확장성 확보**: 새로운 하위 클래스를 추가하더라도 기존 코드 수정 없이 기능 확장 가능
- **다형성 구현의 핵심**: 동일한 인터페이스로 여러 객체를 제어할 수 있음

---

## 2. 인터페이스 기반 설계 (Interface-Based Design)

### ✅ 정의

인터페이스 기반 설계는 **구현보다는 동작(계약)**에 집중하여, 클래스 간의 **결합도를 낮추고 유연성을 높이는 설계 기법**입니다.

즉, 구체적인 클래스가 아닌 **인터페이스(Interface)**를 기반으로 프로그래밍함으로써, **의존성을 추상화**합니다.

### ✅ 예제 (Java)

```java
interface Printer {
    void print(String message);
}

class ConsolePrinter implements Printer {
    public void print(String message) {
        System.out.println("Console: " + message);
    }
}

class FilePrinter implements Printer {
    public void print(String message) {
        // 파일에 출력하는 로직 (생략)
        System.out.println("File: " + message);
    }
}

class ReportService {
    private final Printer printer;

    public ReportService(Printer printer) {
        this.printer = printer;
    }

    public void printReport() {
        printer.print("리포트를 출력합니다.");
    }
}
```

### ✅ 사용 예

```java
Printer printer = new ConsolePrinter();
ReportService service = new ReportService(printer);
service.printReport();  // Console: 리포트를 출력합니다.
```

이처럼 `ReportService`는 구체 클래스가 아닌 `Printer` 인터페이스에 의존합니다. 이는 다음과 같은 이점을 줍니다.

---

### ✅ 장점

| 항목 | 설명 |
|------|------|
| 낮은 결합도 | 인터페이스에 의존함으로써 변경에 유연함 |
| 높은 응집도 | 하나의 역할에 집중된 구현 가능 |
| 테스트 용이 | 모의 객체(Mock)를 주입하여 단위 테스트 가능 |
| 확장성 | 새로운 구현체를 추가해도 기존 코드 변경 없이 사용 가능 |

---

## 3. 동적 바인딩 + 인터페이스 = 강력한 객체지향 설계

이 두 개념은 서로 **강하게 연결**되어 있으며, 같이 사용할 때 객체지향의 진가를 발휘합니다.

- 인터페이스 기반 설계는 **설계상의 유연성**을 보장
- 동적 바인딩은 **런타임에서의 다형성**을 구현

---

## 4. 비교 요약

| 개념 | 설명 | 예시 |
|------|------|------|
| 동적 바인딩 | 런타임 시점에 메서드를 결정 | 부모 타입 참조로 자식 메서드 호출 |
| 인터페이스 기반 설계 | 구현이 아닌 계약(동작)에 의존하는 설계 | `Printer` 인터페이스에 기반한 설계 |

---

## 🔚 마무리

동적 바인딩과 인터페이스 기반 설계는 객체지향 설계에서 **확장 가능하고 변경에 강한 구조**를 만드는 데 필수적인 기법입니다. 이 둘을 잘 활용하면 SOLID 원칙 중 **OCP(개방-폐쇄 원칙)**, **DIP(의존 역전 원칙)**을 자연스럽게 따르게 됩니다.