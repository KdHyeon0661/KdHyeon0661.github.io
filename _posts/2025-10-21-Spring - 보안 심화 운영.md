---
layout: post
title: Spring - 보안 심화 운영
date: 2025-10-21 22:25:23 +0900
category: Spring
---
# 26) 보안 심화 운영 — 비밀관리(Vault/Parameter Store) · 감사/액세스 로그 & 보안 모니터링 · 취약점 스캔(Dependency/Container/Image)

> 목표: **운영 환경에서 바로 쓸 수 있는** 시크릿 관리 전략, 감사/액세스 로깅 표준과 모니터링, 그리고 **파이프라인에 녹아드는 취약점 스캔**(정책 게이트)을 코드/설정/런북과 함께 정리한다.  
> 기준 스택: Spring Boot 3.3+, Java 21, K8s, GitHub Actions, Postgres, Redis, HashiCorp Vault(또는 AWS SSM/Secrets Manager), Loki/Prometheus/Grafana, Trivy/OWASP-Dependency-Check/Syft(CycloneDX SBOM), cosign.

---

## A. 비밀관리(Secrets) — Vault / Parameter Store (Secrets Manager) 통합

### A-1. 원칙과 안티패턴
- **레포/이미지/레이어/평문 env에 비밀 금지**(PR diff, 레이어 캐시 유출).
- **최소권한(Least Privilege)**: 시크릿은 **서비스·환경별** 세분화(예: `svc=order`, `env=prod`).
- **짧은 수명/자동 로테이션**: 동적 DB 크리덴셜(1h), API 키(30~90d), 접근키(90d).
- **주입 경로 표준화**: K8s **CSI Driver / Vault Agent Sidecar / InitContainer**.
- **핫 리로드 설계**: 시크릿 교체 시 **무중단**(커넥션 재생성/풀 재구성 전략 포함).

---

### A-2. HashiCorp Vault — Spring Cloud Vault + K8s

#### 1) Vault 배포(개념)
- K8s에서 Vault(HA) + **Kubernetes Auth** 활성화.
- 정책 예(최소 권한):
```hcl
# policy: app-api
path "secret/data/app/api/*" { capabilities = ["read"] }
path "database/creds/app-api" { capabilities = ["read"] } # 동적 DB 계정
```

#### 2) 앱 인증(K8s ServiceAccount 바인딩)
```yaml
apiVersion: v1
kind: ServiceAccount
metadata: { name: api-sa, namespace: prod }
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata: { name: vault-auth, namespace: prod }
# ... (Vault의 Kubernetes auth 역할과 매칭)
```

#### 3) Spring Cloud Vault 설정
```kotlin
dependencies {
  implementation("org.springframework.cloud:spring-cloud-starter-vault-config")
}
```
```yaml
spring:
  cloud:
    vault:
      uri: http://vault.vault:8200
      authentication: kubernetes
      kubernetes:
        role: api-role
      kv:
        enabled: true
        backend: secret
        default-context: app/api   # secret/data/app/api
  config.import: vault://
```

Vault KV 예(KV v2):
```json
{
  "SPRING_DATASOURCE_USERNAME":"app",
  "SPRING_DATASOURCE_PASSWORD":"***",
  "JWT_SIGNING_KEY":"base64:..."
}
```

#### 4) 동적 DB 크리덴셜(강력 추천)
- Vault DB 엔진에서 `postgres/roles/app-api` 생성(TTL 1h, max_ttl 24h).
- 애플리케이션 기동 시 **동적** 자격증명을 주입(주기적 갱신).
- 커넥션 풀(Hikari) 재구성 포인트:
  - **갱신 윈도**에 기존 커넥션은 만료 전 폐기 → 새 자격증명으로 재생성.
  - 운영 팁: `maxLifetime` < DB wait_timeout, **롤링 배포** 시 충돌 최소화.

#### 5) Vault Agent Sidecar(템플릿 렌더 → 파일 주입)
```yaml
containers:
- name: vault-agent
  image: hashicorp/vault:1.16
  args:
  - "agent"
  - "-config=/etc/vault/config.hcl"
  volumeMounts:
  - name: vault-config
    mountPath: /etc/vault
  - name: secrets
    mountPath: /vault/secrets
---
# /etc/vault/config.hcl
exit_after_auth = false
vault {
  address = "http://vault.vault:8200"
}
auto_auth {
  method "kubernetes" { mount_path="auth/kubernetes" config={ role="api-role" } }
  sink "file" { config={ path="/vault/secrets/token" } }
}
template {
  source      = "/etc/vault/templates/app.env.tpl"
  destination = "/vault/secrets/app.env"
}
```
`app.env.tpl`:
```
SPRING_DATASOURCE_USERNAME={{ with secret "database/creds/app-api" }}{{ .Data.username }}{{ end }}
SPRING_DATASOURCE_PASSWORD={{ with secret "database/creds/app-api" }}{{ .Data.password }}{{ end }}
JWT_SIGNING_KEY={{ with secret "secret/data/app/api" }}{{ .Data.data.JWT_SIGNING_KEY }}{{ end }}
```
앱 컨테이너가 `/vault/secrets/app.env`를 **envFrom**로 읽거나, 파일로부터 `spring.config.import=optional:file:/vault/secrets/` 로딩.

#### 6) 핫 리로드(Actuator refresh)
```yaml
management.endpoints.web.exposure.include: refresh,health,info
```
```bash
curl -X POST http://app:8080/actuator/refresh
```
> 주의: **DB 커넥션**은 재생성 필요. 스위치 윈도(저부하 시간) 고려.

---

### A-3. AWS Systems Manager Parameter Store / Secrets Manager

#### 1) 선택 기준
- **Parameter Store**: 구성값/경량 시크릿, 저비용, 버전·KMS 암호화.
- **Secrets Manager**: **로테이션 자동화**(RDS, Lambda), 시크릿 중심.

#### 2) 애플리케이션에서 읽기(환경 변수/부트 바인딩)
```yaml
db:
  password: ${SSM:/prod/db/password}   # 커스텀 Placeholder 전략 사용 시
jwt:
  key: ${SECRETS_MANAGER:prod/jwt}
```
혹은 기동 시 InitContainer로 싱크:
```bash
aws ssm get-parameter --name /prod/db/password --with-decryption \
  --query 'Parameter.Value' --output text > /secrets/db_password
```

#### 3) 로테이션 패턴(무중단)
1) **B 버전** 발행  
2) 앱이 **버전 A+B 동시 수용**(구·신 키 모두 검증)  
3) 롤링 배포(새 버전 우선 사용)  
4) B 안정 시 A 폐기  
5) 실패 대비 **그레이스 기간** 유지

**JWT 키 회전 예시(검증 다중 키)**
```java
@Bean
JwtDecoder jwtDecoder(List<PublicKey> keys) {
  var decoders = keys.stream().map(NimbusJwtDecoder::withPublicKey).map(Supplier::get).toList();
  return token -> {
    for (var d : decoders) try { return d.decode(token); } catch (Exception ignored) {}
    throw new JwtException("no key matched");
  };
}
```

---

## B. 감사 로그 / 액세스 로그 / 보안 모니터링

### B-1. 표준 스키마(ECS+커스텀) & PII 마스킹
필수 필드:
- `@timestamp`, `level`, `service.name`, `env`, `trace.id`, `span.id`
- `http.method/url/status`, `network.client.ip`, `user.id/roles`, `tenant.id`
- `event.type(action|access|security|audit)`, `event.action`, `event.outcome`
- `resource.type/id`, `pii.masked`(bool), `risk.score`(선택)

**PII 마스킹 유틸(Java)**
```java
public final class PiiMasker {
  public static String email(String v){ return v==null?null:v.replaceAll("(^.).*(@.*$)", "$1***$2"); }
  public static String phone(String v){ return v==null?null:v.replaceAll("(\\d{3})\\d{4}(\\d+)", "$1****$2"); }
}
```

### B-2. Logback JSON + MDC 주입
`logback-spring.xml` (요약)
```xml
<configuration>
  <appender name="JSON" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>/var/log/app/app.json</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>/var/log/app/app.%d{yyyy-MM-dd}.json.gz</fileNamePattern>
      <maxHistory>14</maxHistory>
    </rollingPolicy>
    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
      <customFields>{"service.name":"order-api","env":"prod"}</customFields>
    </encoder>
  </appender>
  <root level="INFO"><appender-ref ref="JSON"/></root>
</configuration>
```

**MDC 필터**
```java
@Component
public class TraceMdcFilter extends OncePerRequestFilter {
  @Override protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain c)
    throws ServletException, IOException {
    try {
      var trace = Optional.ofNullable(req.getHeader("X-Trace-Id")).orElse(UUID.randomUUID().toString());
      MDC.put("trace.id", trace);
      MDC.put("user.id", Optional.ofNullable(req.getUserPrincipal()).map(Principal::getName).orElse("anon"));
      MDC.put("tenant.id", req.getHeader("X-Tenant-Id")==null?"public":req.getHeader("X-Tenant-Id"));
      res.addHeader("X-Trace-Id", trace);
      c.doFilter(req, res);
    } finally { MDC.clear(); }
  }
}
```

### B-3. 감사 이벤트(별도 채널)
```java
public record AuditEvent(String action, String outcome, String resourceType, String resourceId, Map<String,Object> meta) {}
@Service
@RequiredArgsConstructor
public class AuditLogger {
  private static final Logger AUDIT = LoggerFactory.getLogger("AUDIT");
  public void log(AuditEvent e) {
    MDC.put("event.type","audit");
    MDC.put("event.action", e.action());
    MDC.put("event.outcome", e.outcome());
    MDC.put("resource.type", e.resourceType());
    MDC.put("resource.id", e.resourceId());
    AUDIT.info("{}", e.meta());
    MDC.clear();
  }
}
```
`logback-spring.xml`에 `logger name="AUDIT"`를 별도 파일로 라우팅(WORM/Object Lock 버킷에도 동시 전송).

### B-4. 보안 모니터링(애플리케이션 + 클러스터)

**1) 애플리케이션 지표**
- 로그인 실패율, 401/403 급증, 비정상 IP 대역, RateLimit 히트
- Prometheus 메트릭 예:
```java
Counter loginFail = Counter.builder("security_login_fail_total").register(meterRegistry);
Timer authLatency = Timer.builder("security_auth_ms").publishPercentileHistogram().register(meterRegistry);
```

**2) Loki(로그) 쿼리 예**
- **관리자 시도 실패 다량**:
```
{app="order-api"} |= "AUDIT" | json | user_id="admin" | event_action="login" | event_outcome="failure"
| unwrap @timestamp | count_over_time(1m)
```
- **동일 IP에서 5분 내 403 50회 이상**:
```
{app="order-api"} | json | http_status="403" | line_format "{{.network_client_ip}}"
| unwrap network_client_ip | count_over_time(5m) > 50
```

**3) Prometheus 경보 규칙 예**
```yaml
groups:
- name: security.rules
  rules:
  - alert: Excessive403
    expr: sum(rate(http_server_requests_seconds_count{status="403"}[5m])) > 50
    for: 2m
    labels: { severity: high }
    annotations: { summary: "403 spikes", description: "Check WAF / RBAC misconfig or attack" }
  - alert: ManyLoginFailures
    expr: sum(rate(security_login_fail_total[5m])) > 20
    for: 2m
    labels: { severity: high }
```

**4) Falco(옵션, 노드 보안)**
- 의심 프로세스 실행, 쉘 스폰 감지. 운영선 선택적.

---

## C. 취약점 스캔(Dependency/Container/Image) — “막히는” 정책 게이트

### C-1. 전략 개요
- **코드 → 의존성 스캔**(OWASP DC/Snyk)  
- **SBOM 생성**(CycloneDX 또는 SPDX, Syft) → **보관/서명**  
- **이미지 빌드 시** Trivy(패키지/CVE/Config) + **cosign 서명**  
- **배포 전**: 이미지 스캔 결과/서명 검증 실패 시 **거부**(Admission Policy: Kyverno/Gatekeeper)

---

### C-2. GitHub Actions 예시(의존성 스캔 + SBOM + 이미지 스캔 + 서명)

`.github/workflows/ci.yml`
```yaml
name: CI
on: [push, pull_request]
jobs:
  build-test:
    runs-on: ubuntu-22.04
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-java@v4
      with: { distribution: temurin, java-version: 21 }
    - run: ./gradlew clean build test jacocoTestReport

  dependency-scan:
    runs-on: ubuntu-22.04
    steps:
    - uses: actions/checkout@v4
    - name: OWASP Dependency Check
      uses: dependency-check/Dependency-Check_Action@v3.0.4
      with:
        format: "JSON,HTML"
        out: "build/reports/dependency-check"
    - name: Fail on HIGH/CRITICAL
      run: |
        jq '..|.severity? // empty' build/reports/dependency-check/dependency-check-report.json \
        | grep -E "HIGH|CRITICAL" && echo "High vulns found" && exit 1 || echo "No high vulns"

  sbom:
    runs-on: ubuntu-22.04
    steps:
    - uses: actions/checkout@v4
    - name: Syft SBOM(CycloneDX)
      uses: anchore/sbom-action@v0
      with:
        path: .
        format: cyclonedx-json
        output-file: sbom.cdx.json
    - uses: actions/upload-artifact@v4
      with: { name: sbom, path: sbom.cdx.json }

  docker:
    runs-on: ubuntu-22.04
    needs: [build-test, dependency-scan, sbom]
    steps:
    - uses: actions/checkout@v4
    - name: Build image
      run: |
        docker buildx build --load -t ghcr.io/org/order-api:${{ github.sha }} .
    - name: Trivy image scan
      uses: aquasecurity/trivy-action@0.24.0
      with:
        image-ref: ghcr.io/org/order-api:${{ github.sha }}
        format: 'table'
        vuln-type: 'os,library'
        severity: 'HIGH,CRITICAL'
        ignore-unfixed: true
        exit-code: '1'
    - name: Cosign sign
      env: { COSIGN_EXPERIMENTAL: "1", COSIGN_PASSWORD: "${{ secrets.COSIGN_PASSWORD }}" }
      run: |
        echo "${{ secrets.COSIGN_KEY }}" > cosign.key
        cosign sign --key cosign.key ghcr.io/org/order-api:${{ github.sha }}
    - name: Push image
      run: |
        echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u user --password-stdin
        docker push ghcr.io/org/order-api:${{ github.sha }}
```

**정책 포인트**
- OWASP DC: **HIGH/CRITICAL 존재 시 실패**.
- Trivy: **이미지 스캔 실패 시 배포 불가**.
- SBOM 생성·보관(감사/재현).

---

### C-3. 배포 게이트(Admission Policy) — 서명·스캔 검증

**Kyverno 정책(서명 필수)**
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata: { name: require-signed-images }
spec:
  validationFailureAction: Enforce
  rules:
  - name: signed-by-cosign
    match: { resources: { kinds: ["Pod","Deployment","StatefulSet"] } }
    verifyImages:
    - imageReferences: ["ghcr.io/org/*"]
      attestors:
      - entries:
        - keys:
            publicKeys: |-
              -----BEGIN PUBLIC KEY-----
              ...
              -----END PUBLIC KEY-----
```

**Kyverno 정책(취약점 예외 만료)**
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata: { name: image-vuln-allowlist-expiry }
spec:
  validationFailureAction: Enforce
  rules:
  - name: disallow-expired-vuln-allow
    match: { resources: { kinds: ["Pod","Deployment"] } }
    validate:
      message: "Expired vulnerability allowlist"
      deny:
        conditions:
        - key: "{{request.object.metadata.annotations.\"vuln-allow-expire\"}}"
          operator: LessThan
          value: "{{ time_now_utc() }}"
```
> 특정 CVE를 **일시적으로 허용**하되 `vuln-allow-expire`(UTC) 이후엔 자동 거부.

---

### C-4. 베이스 이미지 전략
- Distroless/Alpine(주의: glibc 필요시 UBI/Distroless base).
- **고정 태그** + 주기적 리빌드(주 1회) → CVE 패치 흡수.
- 멀티스테이지 빌드로 **레이어 최소화**(시크릿/빌드 캐시 유출 방지).

**Dockerfile 스니펫**
```dockerfile
# builder
FROM eclipse-temurin:21-jdk AS builder
WORKDIR /src
COPY . .
RUN ./gradlew clean bootJar

# runtime
FROM gcr.io/distroless/java21-debian12
WORKDIR /app
COPY --from=builder /src/apps/api/build/libs/api.jar /app/app.jar
USER 10001
EXPOSE 8080
ENTRYPOINT ["java","-jar","/app/app.jar"]
```

---

## D. 운영 시나리오 & 런북

### D-1. 시크릿 로테이션(데이터베이스) 런북
1) Vault/Secrets Manager에서 **새 버전 발행**(B)  
2) 애플리케이션이 A+B 모두 수용하도록 설정(검증키/크리덴셜 이중)  
3) 트래픽 저부하 시간대 **롤링 배포** 시작 → 신규 커넥션은 B 사용  
4) 모니터링: 인증 실패율/DB 접속 실패 여부  
5) **그레이스 기간** 후 A 폐기 → 만료/폐기 확인 로그 저장

### D-2. 침해 징후(IOC) 탐지 대응
- **알람**: 403 급증, 로그인 실패율 급증, 국가/ASN 이례적 증가, 관리자 엔드포인트 시도.  
- **즉시 조치**: WAF 룰 상승, RateLimit 강화, 관리자 경로 변경/차단, SSO 강제 재인증.  
- **포렌식**: 특정 `trace.id` / IP 추적(Loki), 관련 기간의 감사 로그 WORM 보관.  
- **사후**: 비밀번호 리셋, 토큰 일괄 무효화, 근본 원인 분석(RCA)·교육 항목 반영.

### D-3. 파이프라인 차단 시(취약점 발견)
- **PR**에 취약점 리포트 링크 노출.  
- 우회 필요 시: **임시 allowlist**에 CVE + **만료일**(Kyverno/PR bot) 필수.  
- 다음 액션: 베이스 이미지 업데이트/라이브러리 버전 업/코드 레벨 패치.

---

## E. 예제: “결제 API”의 보안 로그 & 알람

### E-1. 결제 요청 감사 로깅(민감 필드 마스킹)
```java
@PostMapping("/payments")
public ApiResponse<?> pay(@Valid @RequestBody PayReq req){
  var masked = Map.of("card","****"+req.card().substring(req.card().length()-4), "amount", req.amount());
  audit.log(new AuditEvent("payment.authorize","attempt","Order", req.orderId(), masked));
  var r = service.pay(req);
  audit.log(new AuditEvent("payment.authorize", r.approved()?"success":"failure","Order", req.orderId(), Map.of("tx",r.txId())));
  return ApiResponse.ok(r);
}
```

### E-2. Loki 쿼리(5분 내 실패율 5%↑)
```
{app="order-api"} |= "payment.authorize" | json | event_outcome="failure"
| rate(5m) / ({app="order-api"} |= "payment.authorize" | json | rate(5m)) > 0.05
```

### E-3. 경보
```yaml
- alert: PaymentFailureRateHigh
  expr: (sum(rate(payment_authorize_fail_total[5m])) / sum(rate(payment_authorize_total[5m]))) > 0.05
  for: 2m
  labels: { severity: critical }
  annotations:
    summary: "결제 실패율 5% 초과"
```

---

## F. 체크리스트(DoD: Definition of Done)

**시크릿**
- [ ] Vault/SSM 도입, **레포 평문 시크릿 0건**(스캔으로 보장)  
- [ ] 동적 DB 크리덴셜/짧은 수명(1~24h), **키 회전 런북** 문서화  
- [ ] 핫 리로드/롤링 배포로 **무중단 교체** 검증

**로그·감사**
- [ ] Logback JSON + **MDC(TraceId, User, Tenant)**  
- [ ] 감사 로그 별도 채널 + **WORM 보관**  
- [ ] PII 마스킹 필수(정규식/유틸)

**모니터링**
- [ ] 보안 메트릭(로그인 실패/403/레이트리밋/관리자 액션) 대시보드  
- [ ] Prometheus 경보/Slack 연동, **게임데이** 1회/분기

**스캔/정책**
- [ ] 의존성 스캔(HIGH/CRITICAL 실패), SBOM 생성/보관  
- [ ] Trivy 이미지 스캔 실패 시 **배포 차단**  
- [ ] cosign 서명, Kyverno **서명 검증** 강제  
- [ ] CVE allowlist는 **만료일 의무화**

---

## G. 한 장 요약(바로 적용)

1) **Vault/SSM**로 시크릿을 외부화하고, **동적 크리덴셜 + 회전**을 표준화.  
2) **JSON 로그 + MDC + 감사 채널**로 사람·행위·리소스를 추적 가능하게.  
3) **Trivy/OWASP DC + cosign + Admission Policy**로 **“안전하지 않으면 배포 불가”**를 기본값으로.  
4) 보안 대시보드/경보를 구성하고 **게임데이**를 주기적으로 돌려 SLO를 검증.  
5) 모든 흐름은 **런북/자동화 스크립트**로 문서화하여, 사람 없이도 **일관된 보안 운영**이 가능하게 만든다.

> 당장 할 일(스프린트 1주):  
> (1) Vault(또는 SSM) 연결 + DB 동적 크리덴셜 전환, (2) Logback JSON/MDC/감사 로그 채널 분리, (3) CI에 OWASP DC + Trivy + cosign, (4) Kyverno 서명 검증 정책 배포.  
> 이 4가지만 적용해도 **유출 위험↓, 배포 안전성↑, 추적 가능성↑**을 바로 체감할 수 있다.