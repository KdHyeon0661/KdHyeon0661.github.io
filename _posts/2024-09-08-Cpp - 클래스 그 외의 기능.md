---
layout: post
title: C++ - 클래스 그 외의 기능
date: 2024-09-08 19:20:23 +0900
category: Cpp
---
# 클래스 고급편: 가상 소멸자부터 `static`, 연산자 오버로딩까지

## 핵심 개념 개요

C++ 클래스 설계의 고급 기능들을 이해하고 효과적으로 활용하는 것은 견고한 소프트웨어를 만드는 데 필수적입니다. 가상 소멸자부터 연산자 오버로딩, `static` 멤버까지, 이러한 기능들은 각각 명확한 목적과 사용 시점을 가지고 있습니다. 이 글에서는 이러한 기능들의 적절한 사용법과 주의사항을 실용적인 관점에서 설명합니다.

---

## 가상 소멸자: 다형적 소멸의 필수 조건

### 왜 가상 소멸자가 필요한가?

상속 관계에서 기반 클래스 포인터를 통해 파생 클래스 객체를 삭제할 때, 기반 클래스의 소멸자가 가상이 아니라면 파생 클래스의 소멸자가 호출되지 않습니다. 이는 메모리 누수와 불완전한 소멸로 이어질 수 있습니다.

```cpp
#include <iostream>
#include <memory>

class ResourceHolder {
public:
    ResourceHolder() { std::cout << "자원 획득\n"; }
    virtual ~ResourceHolder() { std::cout << "자원 해제\n"; }  // 가상 소멸자
};

class DatabaseConnection : public ResourceHolder {
    std::unique_ptr<int[]> buffer;
public:
    DatabaseConnection() : buffer(std::make_unique<int[]>(1024)) {
        std::cout << "데이터베이스 연결 생성\n";
    }
    ~DatabaseConnection() override {
        std::cout << "데이터베이스 연결 종료\n";
        // buffer는 자동으로 해제됨
    }
};

int main() {
    ResourceHolder* conn = new DatabaseConnection();
    delete conn;  // DatabaseConnection 소멸자도 올바르게 호출됨
    return 0;
}
```

**핵심 원칙**: 클래스에 가상 함수가 하나라도 있다면, 소멸자도 반드시 가상으로 선언해야 합니다. 이는 다형적 삭제(polymorphic deletion)의 안전성을 보장합니다.

### 생성자와 소멸자 내에서의 가상 함수 호출

```cpp
class Base {
public:
    Base() { 
        // 생성자 내에서는 아직 파생 클래스 부분이 초기화되지 않음
        initialize();  // Base::initialize() 호출
    }
    
    virtual void initialize() { 
        std::cout << "Base 초기화\n"; 
    }
    
    virtual ~Base() {
        cleanup();  // Base::cleanup() 호출
    }
    
    virtual void cleanup() { 
        std::cout << "Base 정리\n"; 
    }
};

class Derived : public Base {
public:
    void initialize() override { 
        std::cout << "Derived 초기화\n"; 
    }
    
    void cleanup() override { 
        std::cout << "Derived 정리\n"; 
    }
};
```

생성자와 소멸자 내에서는 객체가 아직 완전한 형태가 아니므로 가상 함수 호출이 의도한 대로 동작하지 않습니다. 항상 현재 클래스의 구현이 호출됩니다.

---

## `protected` 접근 제어자: 확장을 위한 설계

`protected` 접근 제어자는 파생 클래스에게만 접근을 허용하는 중간 지점을 제공합니다. 이는 기반 클래스의 내부 구현을 확장할 수 있는 지점을 명시적으로 표시하는 데 사용됩니다.

```cpp
class Document {
private:
    std::string content;  // 완전히 캡슐화
    int version = 1;
    
protected:
    // 파생 클래스가 확장할 수 있는 훅(hook)
    virtual void beforeSave() { /* 기본 구현: 아무 작업도 하지 않음 */ }
    virtual void afterSave() { /* 기본 구현 */ }
    
    // 파생 클래스가 접근해야 하는 내부 상태
    int getVersion() const { return version; }
    void incrementVersion() { version++; }
    
public:
    void save() {
        beforeSave();      // 확장 포인트
        // 실제 저장 로직
        std::cout << "문서 저장 중...\n";
        afterSave();       // 확장 포인트
    }
};

class EncryptedDocument : public Document {
protected:
    void beforeSave() override {
        std::cout << "문서 암호화...\n";
    }
    
    void afterSave() override {
        std::cout << "암호화 완료, 버전: " << getVersion() << "\n";
        incrementVersion();
    }
};
```

`protected`는 신중하게 사용해야 합니다. 남용하면 캡슐화가 약화되고, 파생 클래스와 기반 클래스 간의 결합도가 증가할 수 있습니다.

---

## `explicit` 생성자: 의도를 명확히 하라

단일 매개변수를 받는 생성자는 암시적 변환을 허용합니다. 이는 때로는 편리하지만, 의도하지 않은 변환으로 인한 버그를 초래할 수 있습니다.

```cpp
class Temperature {
    double celsius;
public:
    // explicit 없으면 Temperature temp = 25.0; 이 허용됨
    explicit Temperature(double c) : celsius(c) {}
    
    double toFahrenheit() const {
        return celsius * 9.0 / 5.0 + 32.0;
    }
};

void displayTemperature(Temperature temp) {
    std::cout << temp.toFahrenheit() << "°F\n";
}

int main() {
    Temperature roomTemp(22.5);  // 명시적 생성
    
    // displayTemperature(25.0);  // 컴파일 오류: 암시적 변환 불가
    displayTemperature(Temperature(25.0));  // 명시적 변환 필요
    displayTemperature(static_cast<Temperature>(30.0));  // 명시적 캐스팅
    
    return 0;
}
```

**권장사항**: 단일 매개변수 생성자는 기본적으로 `explicit`로 선언하고, 진정한 의미의 변환이 필요한 경우에만 제한적으로 암시적 변환을 허용하세요.

---

## 연산자 오버로딩: 자연스러운 인터페이스 만들기

연산자 오버로딩은 사용자 정의 타입에 대해 자연스러운 문법을 제공하는 강력한 도구입니다. 하지만 남용하면 코드의 가독성을 해칠 수 있습니다.

### 기본 원칙

1. **의미가 명확할 때만 사용하라**: 수학적 개념(벡터, 행렬, 복소수)이나 스마트 포인터와 같이 연산자 사용이 직관적인 경우에 적합합니다.
2. **일관성을 유지하라**: 관련 연산자들을 함께 오버로딩하세요(예: `operator+`와 `operator+=`).
3. **기존 관례를 따르라**: `operator<<`는 출력에, `operator==`는 비교에 사용하는 등 기존의 관례를 존중하세요.

### 실용적인 예제: 2D 벡터 클래스

```cpp
#include <iostream>
#include <compare>
#include <cmath>

class Vector2D {
    double x, y;
    
public:
    Vector2D(double x = 0, double y = 0) : x(x), y(y) {}
    
    // 산술 연산자
    Vector2D operator+(const Vector2D& other) const {
        return Vector2D(x + other.x, y + other.y);
    }
    
    Vector2D operator-(const Vector2D& other) const {
        return Vector2D(x - other.x, y - other.y);
    }
    
    Vector2D& operator+=(const Vector2D& other) {
        x += other.x;
        y += other.y;
        return *this;
    }
    
    // 스칼라 곱셈
    Vector2D operator*(double scalar) const {
        return Vector2D(x * scalar, y * scalar);
    }
    
    // 비교 연산자 (C++20)
    auto operator<=>(const Vector2D& other) const = default;
    
    // 유틸리티 함수
    double length() const {
        return std::sqrt(x * x + y * y);
    }
    
    // 출력 연산자 (비멤버 함수, friend 선언)
    friend std::ostream& operator<<(std::ostream& os, const Vector2D& v) {
        return os << "(" << v.x << ", " << v.y << ")";
    }
};

// 스칼라 곱셈의 교환법칙 지원 (비멤버 함수)
inline Vector2D operator*(double scalar, const Vector2D& v) {
    return v * scalar;
}

int main() {
    Vector2D v1(3, 4);
    Vector2D v2(1, 2);
    
    Vector2D sum = v1 + v2;
    Vector2D scaled = 2.5 * v1;
    
    std::cout << "v1: " << v1 << "\n";
    std::cout << "v2: " << v2 << "\n";
    std::cout << "합: " << sum << "\n";
    std::cout << "2.5배: " << scaled << "\n";
    std::cout << "v1의 길이: " << v1.length() << "\n";
    
    return 0;
}
```

C++20의 `operator<=>`(세 방향 비교 연산자)를 사용하면 `==`, `!=`, `<`, `>`, `<=`, `>=` 연산자를 자동으로 생성할 수 있어 매우 편리합니다.

---

## `static` 멤버: 클래스 수준의 공유 자원

`static` 멤버는 모든 객체가 공유하는 클래스 수준의 변수나 함수입니다. 이는 전역 변수의 대안으로서 더 나은 캡슐화를 제공합니다.

### 전통적인 `static` 멤버

```cpp
class ObjectCounter {
    static int count;  // 선언
    
public:
    ObjectCounter() { ++count; }
    ~ObjectCounter() { --count; }
    
    static int getCount() { return count; }
};

// 정적 멤버 변수 정의
int ObjectCounter::count = 0;
```

### 모던 C++: `inline static` (C++17)

C++17부터는 `inline static`을 사용하여 헤더 파일에서 직접 정적 멤버를 초기화할 수 있습니다.

```cpp
class ApplicationConfig {
public:
    inline static std::string appName = "MyApp";
    inline static int maxConnections = 100;
    inline static bool debugMode = false;
    
    static void setDebugMode(bool enable) {
        debugMode = enable;
        if (enable) {
            std::cout << "디버그 모드 활성화\n";
        }
    }
};

// 사용 시
int main() {
    std::cout << "앱 이름: " << ApplicationConfig::appName << "\n";
    ApplicationConfig::setDebugMode(true);
    return 0;
}
```

### 스레드 안전한 싱글톤 패턴

```cpp
class Logger {
private:
    Logger() = default;  // private 생성자
    
public:
    // 삭제된 복사 생성자와 대입 연산자
    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;
    
    static Logger& getInstance() {
        static Logger instance;  // 스레드 안전한 초기화 (C++11)
        return instance;
    }
    
    void log(const std::string& message) {
        // 실제 로깅 구현
        std::cout << "[LOG] " << message << "\n";
    }
};

// 사용 예
Logger::getInstance().log("애플리케이션 시작");
```

---

## 타입 변환 연산자: `operator type()`

타입 변환 연산자를 사용하면 사용자 정의 타입을 다른 타입으로 변환할 수 있습니다. 하지만 암시적 변환은 예상치 못한 동작을 초래할 수 있으므로 주의가 필요합니다.

```cpp
class Percentage {
    double value;  // 0.0 ~ 1.0 범위
    
public:
    explicit Percentage(double v) : value(std::clamp(v, 0.0, 1.0)) {}
    
    // 명시적 변환만 허용
    explicit operator double() const { return value * 100.0; }
    
    // 문자열로의 명시적 변환
    explicit operator std::string() const {
        return std::to_string(value * 100.0) + "%";
    }
    
    // 비교를 위한 암시적 변환 (의도적)
    operator double() const { return value; }
};

int main() {
    Percentage p(0.75);
    
    // double percent = p;  // 컴파일 오류: 암시적 변환 불가
    double percent = static_cast<double>(p);  // OK: 명시적 변환
    std::string str = static_cast<std::string>(p);  // "75.000000%"
    
    // 비교는 암시적 변환 허용
    if (p > 0.5) {
        std::cout << "50% 초과\n";
    }
    
    return 0;
}
```

**권장사항**: 타입 변환 연산자는 가능하면 `explicit`로 선언하여 의도하지 않은 변환을 방지하세요. 비교 연산과 같이 자연스러운 경우에만 암시적 변환을 고려하세요.

---

## `mutable`: 논리적 상수성(Logical Constness)

`mutable` 키워드는 `const` 멤버 함수 내에서도 수정할 수 있는 멤버 변수를 표시합니다. 이는 객체의 논리적 상태는 변경하지 않으면서 내부적인 최적화나 캐싱을 가능하게 합니다.

```cpp
class ExpensiveCalculation {
private:
    mutable std::optional<double> cachedResult;
    mutable bool cacheValid = false;
    
    double computeExpensively() const {
        // 매우 비싼 계산을 시뮬레이션
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        return 42.0;  // 실제로는 복잡한 계산
    }
    
public:
    double getResult() const {
        if (!cacheValid) {
            cachedResult = computeExpensively();
            cacheValid = true;
        }
        return *cachedResult;
    }
    
    void invalidateCache() const {
        cacheValid = false;
        cachedResult.reset();
    }
};

int main() {
    const ExpensiveCalculation calc;
    
    // 첫 호출: 계산 수행
    auto start = std::chrono::high_resolution_clock::now();
    double result1 = calc.getResult();
    auto end = std::chrono::high_resolution_clock::now();
    std::cout << "첫 계산 시간: " 
              << std::chrono::duration<double, std::milli>(end - start).count() 
              << "ms\n";
    
    // 두 번째 호출: 캐시 사용
    start = std::chrono::high_resolution_clock::now();
    double result2 = calc.getResult();
    end = std::chrono::high_resolution_clock::now();
    std::cout << "캐시된 계산 시간: " 
              << std::chrono::duration<double, std::milli>(end - start).count() 
              << "ms\n";
    
    return 0;
}
```

**주의사항**: `mutable` 멤버는 멀티스레드 환경에서 동기화 문제를 일으킬 수 있습니다. 필요한 경우 적절한 동기화 메커니즘을 사용하세요.

---

## RTTI(Run-Time Type Information): 신중한 사용

RTTI는 `dynamic_cast`와 `typeid` 연산자를 통해 런타임에 타입 정보를 얻을 수 있게 합니다. 하지만 이는 설계적 문제를 가릴 수 있는 도움닫이 역할을 할 수 있습니다.

```cpp
class Animal {
public:
    virtual ~Animal() = default;
    virtual void makeSound() const = 0;
};

class Dog : public Animal {
public:
    void makeSound() const override {
        std::cout << "멍멍!\n";
    }
    
    void fetch() const {
        std::cout << "공을 물어옵니다!\n";
    }
};

class Cat : public Animal {
public:
    void makeSound() const override {
        std::cout << "야옹~\n";
    }
    
    void climb() const {
        std::cout << "나무를 올라갑니다!\n";
    }
};

// 나쁜 예: RTTI에 과도하게 의존
void handleAnimalBad(Animal* animal) {
    if (auto* dog = dynamic_cast<Dog*>(animal)) {
        dog->makeSound();
        dog->fetch();
    } else if (auto* cat = dynamic_cast<Cat*>(animal)) {
        cat->makeSound();
        cat->climb();
    }
}

// 좋은 예: 가상 함수로 다형성 활용
void handleAnimalGood(Animal* animal) {
    animal->makeSound();
    // 필요하다면 더 추상화된 인터페이스를 추가
}

int main() {
    Dog dog;
    Cat cat;
    
    std::cout << "나쁜 접근법:\n";
    handleAnimalBad(&dog);
    handleAnimalBad(&cat);
    
    std::cout << "\n좋은 접근법:\n";
    handleAnimalGood(&dog);
    handleAnimalGood(&cat);
    
    return 0;
}
```

**권장사항**: RTTI는 최후의 수단으로 사용하세요. 대부분의 경우 가상 함수나 방문자 패턴(Visitor Pattern)을 사용하는 것이 더 나은 설계입니다.

---

## 결론: 현명한 클래스 설계를 위한 원칙

C++의 고급 클래스 기능들은 강력한 도구이지만, 남용하면 복잡성과 유지보수 비용을 증가시킬 수 있습니다. 다음 원칙들을 기억하세요:

1. **가상 소멸자는 필수**: 다형적 기반 클래스에는 반드시 가상 소멸자를 제공하여 안전한 객체 소멸을 보장하세요.

2. **의도를 명확히**: `explicit` 생성자와 `explicit` 변환 연산자를 사용하여 의도하지 않은 변환을 방지하세요.

3. **연산자 오버로딩은 신중하게**: 연산자의 의미가 명확하고 자연스러울 때만 오버로딩하세요. 일관성과 기존 관례를 따르세요.

4. **인터페이스 설계에 집중**: `protected` 멤버는 신중하게 사용하고, 가능하면 공개 인터페이스(`public`)와 내부 구현(`private`)으로 명확히 구분하세요.

5. **정적 멤버는 전역 상태의 대안으로**: `inline static`을 활용하여 더 안전하고 캡슐화된 전역 상태를 관리하세요.

6. **상수성의 의미를 이해하라**: `mutable`은 논리적 상수성을 유지하면서 성능을 최적화하는 데 사용하되, 멀티스레드 환경에서는 주의하세요.

7. **RTTI는 최소화**: 런타임 타입 정보에 의존하기보다는 컴파일 타임에 검증할 수 있는 설계를 지향하세요.

8. **모던 C++ 기능 활용**: C++11/14/17/20의 기능들(`override`, `final`, `<=>`, `inline static` 등)을 활용하여 더 안전하고 명확한 코드를 작성하세요.

이러한 원칙들을 따르면 더 견고하고 유지보수하기 쉬운 C++ 코드를 작성할 수 있습니다. 각 기능은 특정 문제를 해결하기 위해 존재하므로, 상황에 맞게 적절히 활용하는 것이 중요합니다.