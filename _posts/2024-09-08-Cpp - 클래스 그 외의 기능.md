---
layout: post
title: C++ - 클래스 그 외의 기능
date: 2024-09-08 19:20:23 +0900
category: Cpp
---
# 클래스 고급편: 가상 소멸자부터 `static`, 연산자 오버로딩까지

## 0. 한눈 요약

- **가상 소멸자**: 폴리모픽 베이스는 반드시 가상 소멸자. `delete Base*` 시 **파생 소멸자 호출**을 보장.  
- **`protected`**: 외부 차단, 파생 허용. “확장 지점”으로 최소한만 공개.  
- **`explicit`**: 암시 변환(깜짝 생성)을 차단해 **의도 명확성** 확보.  
- **연산자 오버로딩**: 의미가 자연스러울 때만. `operator<<`, `==`, `<=>`는 실무 핵심.  
- **`static` 멤버**: 클래스 차원의 공유 상태/행위. C++17 `inline static`으로 정의 간소화.  
- **변환 연산자**: 꼭 필요할 때만. 보통 `explicit` 권장.  
- **`mutable`**: `const` 멤버 함수에서 내부 캐시/계수 등 “논리적 상수성”을 보존하며 갱신.  
- **RTTI**: `dynamic_cast`/`typeid`는 최소화. 다운캐스트 대신 **가상 인터페이스** 노출 권장.  
- **추상 클래스(인터페이스)**: 순수 가상만으로 계약 정의. 다중 상속은 **인터페이스**에 한정.

---

## 1. 가상 소멸자 (`virtual destructor`)

### 1.1 왜 필요한가?

- 베이스 포인터로 파생 객체를 소멸할 때, 베이스 소멸자만 가상이 아니면 파생 소멸자가 **호출되지 않음** → 자원 누수/부분 소멸.

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual ~Base() { cout << "Base 소멸\n"; }  // 가상 소멸자
};

class Derived : public Base {
public:
    ~Derived() override { cout << "Derived 소멸\n"; }
};

int main() {
    Base* p = new Derived();
    delete p; // Derived → Base 순으로 안전하게 소멸
}
```

> **규칙**: *가상 함수가 하나라도 있는 베이스*라면 **항상** 가상 소멸자를 선언.  
> 수학적 관점에서, 파생 클래스의 자원해제 비용을 $$C_D$$, 베이스만 소멸했을 때 누수 비용을 $$L_D$$라 하면, 기대 비용은
> $$
> \mathbb{E}[\text{비용}] = C_D \quad \text{(가상 소멸자)} \qquad \text{vs.} \qquad C_B + L_D \quad \text{(비가상 소멸자)}
> $$
> 누수를 제거하는 최적 정책은 **가상 소멸자 채택**이다.

### 1.2 생성자/소멸자 내 가상 호출 금지

```cpp
struct B {
    B(){ f(); }                 // ❌ 현재 타입(B)으로 정적 바인딩
    virtual void f(){ /*...*/ }
    virtual ~B(){ f(); }        // ❌ 여기서도 B::f
};
struct D : B {
    void f() override { /*...*/ }
};
```

- 생성/소멸 중에는 객체가 **완전한 D가 아님**. 가상 호출이 **정지**된다.  
- **NVI(§9)** 패턴으로 계약을 비가상 public → 내부 virtual로 분리하라.

---

## 2. `protected` 접근 제어자

- `private`는 **클래스 내부**만, `protected`는 **파생**에서도 접근 허용.
- 진짜 “확장 훅”만 `protected`로, 나머지는 `private`로 캡슐화.

```cpp
class Parent {
protected:
    int secret = 42;            // 확장 지점
public:
    int read() const { return secret; }
};

class Child : public Parent {
public:
    void reveal(){ secret += 1; } // 접근 가능
};
```

> 가이드: **외부 API는 `public`**, **상태는 `private`**, **명시적 확장 포인트만 `protected`**.

---

## 3. `explicit` 생성자 — 암시 변환 차단

```cpp
class Meter {
    double v_;
public:
    explicit Meter(double m) : v_(m) {}
    double value() const { return v_; }
};

void print(Meter m) { std::cout << m.value() << "\n"; }

int main() {
    // print(3.14);         // ❌ 암시 변환 차단
    print(Meter(3.14));     // ✅ 명시적 생성
    print(static_cast<Meter>(2.71)); // ✅ 명시적 변환
}
```

- 단일 인자 생성자는 **기본적으로 `explicit`**이 안전.  
- 예외: 진짜 “스칼라처럼” 자연스러운 변환(예: `std::string_view` ← `const char*`)에 한해 신중히 허용.

---

## 4. 연산자 오버로딩 (의미가 있을 때만)

### 4.1 산술/비교/출력 — 최소 필요한 것부터

```cpp
#include <compare>
#include <ostream>

class Point {
public:
    int x{}, y{};

    // 산술
    Point operator+(const Point& o) const { return {x+o.x, y+o.y}; }
    Point& operator+=(const Point& o)     { x+=o.x; y+=o.y; return *this; }

    // 비교(C++20)
    auto operator<=>(const Point& o) const = default; // x→y 순서 비교 기본

    // 출력(비멤버 + friend)
    friend std::ostream& operator<<(std::ostream& os, const Point& p){
        return os << "(" << p.x << ", " << p.y << ")";
    }
};
```

- **대칭성**이 필요한 연산(`<<`, `==`)은 **비멤버**(필요 시 `friend`)가 자연스럽다.  
- C++20 `operator<=>`(세 갈래 비교)로 **`==`, `<`, `>`** 자동 생성 가능.

### 4.2 강건 설계 포인트

- **불변식** 유지: 예를 들어 길이가 음수가 되지 않도록.  
- 복사/이동/예외 보증: 산술 연산은 **예외 안전**이어야 한다(실패 시 객체 상태 유지).  
- 컬렉션 키로 사용할 경우 **엄격 약정**(반사/대칭/추이성) 충족.

---

## 5. `static` 멤버 변수/함수

### 5.1 기본

```cpp
class Counter {
private:
    static int count;        // 선언
public:
    Counter(){ ++count; }
    static int value(){ return count; } // 객체 없이 호출 가능
};
int Counter::count = 0;      // 정의(전역 한 번)
```

### 5.2 C++17 `inline static`로 간소화

```cpp
class Config {
public:
    inline static int max_conn = 512; // 헤더에 선언+정의 OK(ODR 만족)
    static void set_max(int n){ max_conn = n; }
};
```

- **초기화 순서 문제**를 줄이고, 헤더만으로 구성 가능.

### 5.3 스레드 안전 초기화

- **함수 지역 정적**은 초기화가 **thread-safe**:
```cpp
const std::string& singleton_name(){
    static const std::string name = "app"; // 최초 1회 안전 초기화
    return name;
}
```

> 멀티스레드에서 `static` 공유 상태를 쓸 땐 **원자성/동기화**를 명시적으로 고려.

---

## 6. 타입 변환 연산자 (`operator T()`)

- 사용 시 **암시 변환 폭주** 위험. 가급적 **`explicit`** 권장(C++11~ 지원).

```cpp
class Ratio {
    int num_, den_;
public:
    Ratio(int n, int d) : num_(n), den_(d) {}
    explicit operator double() const {
        return static_cast<double>(num_) / den_;
    }
};

void f(double);
int main(){
    Ratio r(3,4);
    // f(r);           // ❌ explicit라 암시 변환 안 됨
    f(static_cast<double>(r)); // ✅ 명시적 변환
}
```

---

## 7. `mutable` — 논리적 상수성(Logical Constness)

```cpp
class Cache {
    mutable int hits_{0};           // const 함수에서도 갱신 허용
public:
    int get() const {
        ++hits_;                    // 통계/캐시 갱신
        return hits_;
    }
};
```

- **의미상 상수**지만 내부적으로 캐싱·계수·로그가 필요할 때 사용.  
- 데이터 레이스 위험이 있는 공유 객체에서는 **동기화**도 함께 고려.

---

## 8. RTTI & `dynamic_cast` / `typeid`

```cpp
class Base { public: virtual ~Base() = default; };
class Derived : public Base { public: void only_in_d(){} };

void use(Base* b){
    if(auto d = dynamic_cast<Derived*>(b)){ d->only_in_d(); } // 안전 다운캐스트
}
```

- RTTI는 **최후 수단**. 설계상 **가상 함수**로 다형 행위를 노출하는 편이 더 깔끔하다.  
- `typeid`는 실제 타입 확인에 쓰지만 **분기 설계**가 복잡해질 수 있다.

---

## 9. 추상 클래스와 인터페이스 구조

```cpp
struct Drawable {
    virtual void draw() = 0;         // 순수 가상 → 추상 클래스
    virtual ~Drawable() = default;
};
struct Clickable {
    virtual void onClick() = 0;
    virtual ~Clickable() = default;
};
class Button : public Drawable, public Clickable {
public:
    void draw() override    { std::cout << "버튼 그리기\n"; }
    void onClick() override { std::cout << "버튼 클릭됨\n"; }
};
```

- **인터페이스 다중 상속**은 안전(데이터 멤버 없음).  
- 구현 다중 상속은 **복잡성↑**(다이아몬드/오프셋 보정) → 꼭 필요할 때만.

---

## 10. Rule of Zero / Three / Five

- **Rule of Zero**: 자원은 컨테이너/스마트 포인터에 맡겨 **특별 멤버 함수 사용자 정의 불필요**.
- **Rule of Three**: **소멸자/복사 생성자/복사 대입** 중 하나를 정의하면 **셋 다** 고려.  
- **Rule of Five(C++11~)**: 위 3개 + **이동 생성자/이동 대입**까지.

```cpp
#include <algorithm>
#include <cstddef>

class Buffer {
    std::size_t n_{};
    int* data_{};
public:
    Buffer() = default;
    explicit Buffer(std::size_t n) : n_(n), data_(new int[n]{}) {}
    ~Buffer(){ delete[] data_; }

    Buffer(const Buffer& o) : Buffer(o.n_) { std::copy(o.data_, o.data_+n_, data_); }
    Buffer& operator=(const Buffer& o){
        if(this!=&o){
            Buffer tmp(o);
            swap(tmp);
        }
        return *this;
    }
    Buffer(Buffer&& o) noexcept : n_(o.n_), data_(o.data_) { o.n_=0; o.data_=nullptr; }
    Buffer& operator=(Buffer&& o) noexcept {
        if(this!=&o){
            delete[] data_;
            n_=o.n_; data_=o.data_;
            o.n_=0; o.data_=nullptr;
        }
        return *this;
    }
    void swap(Buffer& o) noexcept { std::swap(n_,o.n_); std::swap(data_,o.data_); }
};
```

---

## 11. NVI(Non-Virtual Interface)와 예외 보증

```cpp
struct Algo {
    void run(){ pre(); step(); post(); }  // 비가상 public
private:
    void pre(){ /* 검증/로그 */ }
    virtual void step() = 0;              // 재정의 지점
    void post(){ /* 정리 */ }
};
```

- 외부 계약은 **비가상**으로 통제, 확장 포인트는 **`virtual` private/protected**.  
- **강한 예외 보증**: 실패 시 전/후 불변식 유지.

---

## 12. 예제: `static` + 오버로딩 + 변환 연산자 + `explicit` 종합

```cpp
#include <iostream>
#include <compare>

class Meter {
    double v_{};
public:
    explicit Meter(double v) : v_(v) {}
    double value() const noexcept { return v_; }

    // 산술
    Meter operator+(const Meter& o) const { return Meter(v_ + o.v_); }
    Meter& operator+=(const Meter& o){ v_ += o.v_; return *this; }

    // 비교(C++20)
    auto operator<=>(const Meter& o) const = default;

    // 변환 연산자(명시적)
    explicit operator double() const noexcept { return v_; }
};

class MeterStat {
    inline static int created_ = 0;    // C++17 inline static
public:
    static void inc(){ ++created_; }
    static int count(){ return created_; }
};

int main(){
    Meter a(3.2), b(1.8);
    Meter c = a + b;
    std::cout << static_cast<double>(c) << "\n"; // 5.0

    MeterStat::inc(); MeterStat::inc();
    std::cout << "created=" << MeterStat::count() << "\n";
}
```

---

## 13. 예제: `mutable` 캐시 + 스레드 안전 고려

```cpp
#include <string>
#include <optional>
#include <mutex>

class Hasher {
    std::string s_;
    mutable std::optional<std::size_t> cache_;
    // 단일 객체를 여러 스레드가 호출한다면 필요
    mutable std::mutex m_;
public:
    explicit Hasher(std::string s) : s_(std::move(s)) {}
    std::size_t hash() const {
        std::scoped_lock lk(m_);
        if (!cache_) {
            std::hash<std::string> h;
            cache_ = h(s_);
        }
        return *cache_;
    }
};
```

- `mutable` 캐시는 편리하지만 **데이터 레이스**에 유의. 필요한 곳에서 동기화.

---

## 14. FAQ/함정 교정

1) **가상 소멸자 누락**
```cpp
struct Base { ~Base(){} }; // ❌
```
→
```cpp
struct Base { virtual ~Base() = default; }; // ✅
```

2) **암시 변환으로 모호 호출**
```cpp
struct X { X(int){ } };
void f(X);
f(0.1); // ❌ 의도 불명
```
→ `explicit X(int)` 또는 오버로드/호출부 명시적 변환.

3) **이름 숨김**
```cpp
struct B{ void f(int); };
struct D: B{ void f(double); }; // B::f 숨김
```
→
```cpp
struct D: B{ using B::f; void f(double); }; // ✅
```

4) **연산자 의미 위반**  
`operator==`가 비추이/비대칭이면 컨테이너/정렬에서 **UB 유발** 가능.

---

## 15. 테스트·툴링·옵션

- 컴파일:  
  ```bash
  g++ -std=c++20 -O2 -Wall -Wextra -Werror -pedantic main.cpp -o app
  ```
- Sanitizer: `-fsanitize=address,undefined` (런타임 결함 조기 탐지)  
- 정적 분석: **clang-tidy**(modernize-use-override, performance-*, bugprone-*)  
- 단위 테스트: **GoogleTest/Catch2**  
- 벤치마크: **google-benchmark**(가상 호출/정적 다형성 비용 비교)

---

## 16. 수학적 메모: 가상 디스패치의 비용 모델

가상 호출 1회의 기대 비용을 단순화하면,
$$
T_{\text{virtual}} \approx T_{\text{indirect\_load}} + T_{\text{branch\_predict\_miss}} + T_{\text{target\_icache}} + T_{\text{callee}}
$$
- **핫 루프**에서 누적되면 영향 큼 → **정적 다형성(CRTP/템플릿 전략)**, 인라이닝 고려.

---

## 17. PImpl(포인터에 의한 구현) — ABI 안정·컴파일 시간 단축

```cpp
// widget.hpp
#pragma once
#include <memory>
class Widget {
public:
    Widget();
    ~Widget();
    void draw() const;
private:
    struct Impl;
    std::unique_ptr<Impl> p_;
};

// widget.cpp
#include "widget.hpp"
#include <iostream>
struct Widget::Impl { void draw() const { std::cout<<"draw\n"; } };
Widget::Widget()  : p_(std::make_unique<Impl>()) {}
Widget::~Widget() = default;
void Widget::draw() const { p_->draw(); }
```

- 헤더에서 구현을 숨겨 **재컴파일 범위 축소**/ABI 안정성 ↑.

---

## 18. 체크리스트 (실전)

- [ ] **폴리모픽 베이스**에 **가상 소멸자** 선언  
- [ ] 생성/소멸에서 **가상 호출 금지**(NVI 도입)  
- [ ] **`explicit`**로 암시 변환 차단(정말 필요할 때만 허용)  
- [ ] **연산자 오버로딩**은 의미가 자연스러울 때만, 예외 보증/불변식 준수  
- [ ] `static` 초기화/스레드 안전 고려(`inline static`/함수 지역 정적)  
- [ ] 변환 연산자는 가능하면 **`explicit`**  
- [ ] `mutable`은 **논리적 상수성**에 한해 사용(+ 동기화)  
- [ ] **RTTI 최소화**, 다운캐스트 대신 **가상 인터페이스**  
- [ ] Rule of Zero/Five로 **수명/소유권 일관성** 확보  
- [ ] 컴파일 옵션/정적 분석/Sanitizer/테스트 자동화

---

## 19. 마무리 요약

- **가상 소멸자/다형성의 수명 규약**을 정확히 지키면 누수/UB를 원천 차단.  
- **`explicit`/연산자 오버로딩/변환 연산자**는 **오용 방지** 관점에서 설계.  
- **`static`/스레드 안전**과 **`mutable`/논리적 상수성**을 구분해서 사용.  
- **RTTI 대신 인터페이스**, **상속 대신 조합**을 우선.  
- 현대 C++ 도구들(`inline static`, `<=>`, `noexcept`, `constexpr`, 스마트 포인터)로 **안전/성능/명확성**을 모두 잡자.
