---
layout: post
title: 정보통신기사 - 운영체제 기초
date: 2025-08-23 11:25:23 +0900
category: 정보통신기사
---
# 운영체제 기초: 프로세스 · 스케줄링 · 메모리 완전정복 (tx-os-basics-psched-mem)

> **목표**: 정보통신·컴공·실무 엔지니어 관점에서 **프로세스/스레드**, **CPU 스케줄링**, **메모리 관리(가상메모리/페이징/교체)**를  
> “원리 → 공식/수식 → 예제 → 설계/튜닝 → 체크리스트 → 연습문제” 순으로 **생략 없이** 정리합니다.  
> 수식은 **MathJax**, 코드/명령은 **코드블록**, 구조는 **ASCII 도식**을 사용합니다.

---

## 0) 큰 그림: 실행은 흐름, 자원은 공간

```
[프로그램(파일)] --(로드)--> [프로세스(실행 컨텍스트)]
   ├─ 자원: 주소공간(코드/데이터/힙/스택), 핸들, 파일, 소켓
   └─ 흐름: 스레드(PC/레지스터/스택) 1개 이상
CPU 스케줄러가 "어느 프로세스/스레드가 언제 CPU를 쓰는가"를 결정
메모리 관리가 "어느 가상주소가 어느 물리프레임과 매핑되는가"를 결정
```

- **프로세스**: 실행 중인 프로그램 인스턴스(자원 + 권한 + 주소공간).  
- **스레드**: 프로세스 내 실행 흐름(PC/레지스터/스택).  
- **스케줄러**: 성능/응답성/공정성/마감(실시간)을 균형.  
- **메모리 관리자**: 보호/격리/효율(가상메모리·TLB·교체).

---

## 1) 프로세스 · 스레드 · 시스템콜

### 1.1 프로세스 상태/전이/PCB
- 상태: **New → Ready → Running → Blocked(Wait) → Ready → Running → Terminated**  
- **IO-bound**와 **CPU-bound**가 교대하며 Ready/Blocked를 오감.
- **PCB(Process Control Block)**: PID, 상태, **레지스터 스냅샷**, 프로그램 카운터(PC), 스케줄링 정보(우선순위/시간), 메모리 정보(페이지 테이블 포인터), 파일/소켓 테이블 등.

**컨텍스트 스위치**: 실행 중인 스레드의 레지스터/PC를 PCB에 저장하고, 다음 스레드의 컨텍스트를 복원. 오버헤드 있음(캐시/TLB 교란 포함).

### 1.2 프로세스 생성과 실행
- POSIX: `fork()`로 부모 복제(주소공간 **Copy-on-Write**), `execve()`로 새 프로그램 로드. `wait()`로 자식 종료 수거(좀비 방지).
- Windows: `CreateProcess()` 한 방 생성/로드.

```c
// fork/exec/wait (리눅스)
pid_t pid=fork();
if(pid==0){                // child
  char* argv[]={"ls","-l",NULL};
  execvp("ls",argv);       // 성공 시 아래 코드 실행 X
  perror("exec"); _exit(1);
}else{
  int st; waitpid(pid,&st,0);
}
```

### 1.3 스레드: 사용자/커널, 장단점
- 장점: 경량 생성/스위치, 공유 메모리로 통신 용이, I/O 겹치기.  
- 단점: **경쟁/교착/메모리 안전** 이슈, 한 스레드 크래시→프로세스 전체 영향.  
- 구현: **커널 스레드(1:1)**, 유저 스레드(M:N) + 스케줄러 협력(비선점/선점 혼합).

### 1.4 시스템콜/모드전환
- 사용자 모드 ↔ 커널 모드(트랩/인터럽트 게이트).  
- 파일/네트워크/프로세스 제어는 시스템콜을 통해서만.

---

## 2) CPU 스케줄링 기초

### 2.1 평가 지표
- **처리량(Throughput)**: 단위시간 완료 개수  
- **지연/반환시간(Turnaround)**: 완료−도착  
- **대기시간(Waiting)**: Ready 큐에서 대기 총합  
- **응답시간(Response)**: 첫 응답까지(대화형 중요)  
- **CPU 이용률**, **공정성**, **기아(Starvation)** 방지

### 2.2 선점/비선점
- **비선점**: 실행 중이면 양보 전까지 유지(FCFS/SJF).  
- **선점**: 타이머/이벤트로 강제 전환(RR/SRTF/우선순위/MLFQ).  
- **디스패처 지연**과 **컨텍스트 스위치 비용** 고려.

---

## 3) 전통 스케줄링 알고리즘과 예제

### 3.1 FCFS(First-Come, First-Served)
- 비선점, 간단하지만 **호위효과(Convoy Effect)**로 평균 대기↑.

**예)** 도착0: A=24, B=3, C=3  
Gantt: `| A(0–24) | B(24–27) | C(27–30) |`  
대기(A=0,B=24,C=27) 평균=**17.33**

### 3.2 SJF/SRTF
- **SJF**: 가장 짧은 CPU burst 우선(비선점).  
- **SRTF**: 남은 시간이 가장 짧은 것 우선(선점). 평균 대기 최소, **기아 가능**.

**예)** 도착0: A=6, 도착2: B=4, 도착4: C=2 (SRTF)  
- 0–2 A(남4), 2–4 B(남2), 4–6 C(완), 6–8 B(완), 8–12 A(완)  
대기(A=6, B=2, C=0) 평균=**2.67**

### 3.3 RR(Round Robin)
- 타임퀀텀 \(q\) 로 시분할. \(q\) 작을수록 응답성↑, 문맥교환 오버헤드↑.

**예)** A=5,B=5,C=5, \(q=2\)  
Gantt: `A(0–2) B(2–4) C(4–6) A(6–8) B(8–10) C(10–12) A(12–13) B(13–14) C(14–15)`  
대기(A=8,B=9,C=10) 평균=**9**

> **팁**: 실무/시험에서 RR은 **대기시간↑/응답성↑**로 요약.

### 3.4 우선순위 스케줄링(+ 에이징)
- 정적/동적 우선순위. **낮은 우선순위 기아** 방지 위해 **에이징**(대기시간에 비례해 우선순위↑).

### 3.5 다단계 피드백 큐(MLFQ)
- 규칙(전형, OSTEP 스타일):
  1) 우선순위가 높은 큐 먼저  
  2) 각 큐는 RR, 하위 큐는 더 긴 \(q\)  
  3) 새 작업은 최상위 큐 시작  
  4) 타임슬라이스 소진 시 하위 큐 강등  
  5) I/O로 빨리 양보하면 상위 큐 유지/승급  
  6) 주기적 **우선순위 부스팅**(모든 작업 최상위로) → 기아 방지

**효과**: 대화형(짧은 버스트) 우대, 배치 작업은 하위로.

### 3.6 실시간 스케줄링 개념
- **하드 RT**: 마감 초과는 실패(임베디드/제어).  
- **RM(Rate Monotonic)**: 주기가 짧을수록 우선, 고정 우선순위.  
- **EDF(Earliest Deadline First)**: 마감이 가까울수록 우선, 동적.  
\[
\text{RM 수용 한계(체어)}\ U=\sum_{i=1}^n \frac{C_i}{T_i} \le n(2^{1/n}-1) \xrightarrow[n\to\infty]{} \ln 2 \approx 0.693
\]
- EDF는 \(U\le 1\)이면 단일 프로세서에서 이론상 스케줄 가능.

---

## 4) 메모리: 주소공간 · 보호 · 단편화

### 4.1 주소공간 레이아웃(개념)
```
Low → [코드(text)] [데이터(bss, data)] [힙 ↑] ... [공유라이브러리] ... [스택 ↓] ← High
```
- **ASLR**: 각 구간 시작 주소 무작위화(보안).  
- **W^X**: 쓰기 가능 영역은 실행 금지 원칙.

### 4.2 로딩/링킹
- **정적 링크**: 실행파일에 포함(용량↑).  
- **동적 링크**: 런타임에 공유 라이브러리 매핑(메모리 공유).  
- **지연 로딩/데맨드 페이징**: 접근 시 로드.

### 4.3 연속 메모리 할당과 단편화
- **고정/가변 파티션**: 외부/내부 단편화 문제.  
- **첫적합/다음적합/최적적합/최악적합** 탐색 전략.  
- **압축(compaction)**: 외부 단편화 완화(비용 큼).

---

## 5) 가상메모리 · 페이징 · TLB

### 5.1 페이징
- 가상주소 = \([페이지 번호 | 오프셋]\), 물리주소 = \([프레임 번호 | 오프셋]\).  
- **페이지 테이블**: PTE(유효/읽기/쓰기/실행/Dirty/Accessed/프레임번호).  
- 보호/격리/공유(코드 공유)/큰 주소공간 지원.

### 5.2 다단 페이지 테이블
- 4KB 페이지, 48비트 VA → 4단(각 9비트) + 오프셋 12비트.  
- **Huge Page**: 2MB/1GB로 PTE 수/ TLB 미스↓.

### 5.3 TLB & EAT (유효 접근 시간)
\[
\text{EAT} = (1-\alpha)\cdot T_\text{miss} + \alpha\cdot T_\text{hit}
\]
- \(\alpha\): TLB 히트율.  
- 예) \(T_\text{hit}=1\text{ns}\), \(T_\text{miss}=40\text{ns}\), \(\alpha=0.98\) → **EAT = 1.78ns**

### 5.4 페이지 교체(참조열 기반)
- **Optimal(OPT)**: 미래 참조를 아는 이상적 상한(비교 기준).  
- **FIFO**: 오래된 것부터(벨라디 현상 가능).  
- **LRU**: 가장 오래 사용하지 않은 것(스택 속성).  
- **Clock(Second-Chance)**: 참조비트 이용한 LRU 근사.  
- **NRU/WSClock**: 참조/더티 고려, 작업셋 유지.

### 5.5 프레임 할당/스래싱
- **전역 vs 지역 교체**: 전역은 시스템 유연/불안정, 지역은 프로세스 격리/보수적.  
- **작업셋(Working Set)**: 최근 \(\Delta\) 윈도우에서 참조한 페이지 집합.  
- 총 요구 프레임 \(\sum WSS_i\) > 물리프레임 → **스래싱**(페이지 폴트 폭증, CPU 이용률↓).  
- 대책: **멀티프로그래밍도(MP)** 조절, **준거 프레임** 확보, I/O 전용/CPU 전용 균형.

### 5.6 Copy-on-Write(CoW) & mmap
- `fork()` 시 페이지를 공유(읽기 전용)하다가 쓰기 시 복사.  
- **메모리맵 파일(mmap)**: 파일을 가상주소에 매핑 → 페이지 캐시와 통합.

```c
// 간단 mmap 읽기 예제
int fd=open("data.bin",O_RDONLY);
size_t len=lseek(fd,0,SEEK_END);
void* p=mmap(NULL,len,PROT_READ,MAP_PRIVATE,fd,0);
write(1,p,len); // 표준출력
munmap(p,len); close(fd);
```

---

## 6) 운영체제 내부(리눅스 관점 한 줌)

### 6.1 스케줄러(CFS 개요)
- **CFS(Completely Fair Scheduler)**: 가상 실행시간(**vruntime**)으로 공정성 근사.  
- 우선순위/`nice` → 가중치로 변환, **레드블랙 트리**에서 가장 vruntime 작은 태스크 선택.  
- **RT 클래스**(SCHED_FIFO/RR)와 **CFS** 계층, **cgroups**로 CPU 쿼터/셰어 제어.

### 6.2 메모리 관리자
- **buddy allocator**(물리 페이지), **slab/slub**(소객체), **페이지 캐시**, **OOM killer**.  
- **VMA**(가상 메모리 영역)로 힙/스택/맵 영역 관리.  
- **Transparent Huge Pages(THP)**: 2MB 자동 결합(장점: TLB 미스↓, 단점: 단편화/latency 변동).

### 6.3 파일/페이지 캐시
- 파일 읽기는 대부분 **페이지 캐시** 경유. `O_DIRECT`로 우회 가능.  
- 쓰기: **Dirty 페이지** → 백그라운드 플러시.

---

## 7) 계산/그림으로 잡는 감(예제)

### 7.1 RR에서 컨텍스트 스위치 비용 반영
- 스위치 비용 \(s\)를 매 타임슬라이스에 가산.  
- 유효 CPU 시간 비율 \(\approx \frac{q}{q+s}\).  
  - 예) \(q=4\)ms, \(s=0.4\)ms → **90%**만 유효 작업.

### 7.2 AMAT & EAT 결합 감
- **주소변환도 메모리 접근**이므로, L1 히트라도 **TLB 미스**이면 **페이지 워크+L1** 시간.  
- 전체 평균:
\[
\text{메모리 접근} \approx \text{EAT(TLB)} + \text{AMAT(Cache)}\ (\text{보정항 포함})
\]
> 실제 CPU는 병렬 최적화(히든 히트)로 단순 합은 아니나, 병목 추정 용도로 유용.

### 7.3 스래싱 탐지 시나리오
- 증상: CPU 이용률↓, 디스크 I/O(페이지 인/아웃)↑, 런큐는 짧음.  
- 조치: 다중 프로그래밍도↓, 큰 작업 일시 보류, THP/프리페치 정책 조정.

---

## 8) 코드로 보는 스케줄링 시뮬 (교육용)

```python
# 간단 RR 시뮬레이터 (도착=0 가정)
from collections import deque
def rr(bursts, q=2, ctx=0):
    t, gantt, wait = 0, [], {i:0 for i in range(len(bursts))}
    rem = bursts[:]
    Q = deque(range(len(rem)))
    last_run = [0]*len(rem)
    while Q:
        i = Q.popleft()
        if rem[i]==0: continue
        # 대기시간 누적
        wait[i] += t - last_run[i]
        run = min(q, rem[i])
        gantt.append((i, t, t+run))
        t += run
        rem[i] -= run
        last_run[i] = t + ctx
        t += ctx
        if rem[i]>0: Q.append(i)
    avg_wait = sum(wait.values())/len(bursts)
    return gantt, avg_wait

g, w = rr([5,5,5], q=2, ctx=0)
print(g, "avg_wait=", w)
```

---

## 9) 메모리 교체 알고리즘 손으로 풀기(대표)

**참조열**: 1,2,3,4,1,2,5,1,2,3,4,5, 프레임=3

- **FIFO**: 부재 수 **9** (벨라디 가능성 주의)  
- **OPT**: 부재 **7**(이상 상한)  
- **LRU**: 부재 **9**  
- **Clock(Second-Chance)**: 구현에 따라 LRU 근사, 여기선 **9** 부근

> **스택 속성**: LRU/OPT는 프레임 수↑ 시 부재 수 **절대** 증가하지 않음. FIFO는 그 보장이 없어 **벨라디(Bélády’s anomaly)** 발생 가능.

---

## 10) 실무 튜닝/설계 체크포인트

### 프로세스/스레드
- [ ] I/O-bound vs CPU-bound 분류 → **스레드 풀/비동기**.  
- [ ] **락 경합** 측정(프로파일) 후 세분화/락프리/워크 분할.  
- [ ] `ulimit`, FD/스레드 상한, **pinning/affinity**(NUMA) 검토.

### 스케줄링
- [ ] 대화형 응답성: **RR/MLFQ** 계열, \(q\)를 RTT·UI 주기에 맞춤.  
- [ ] 배치 처리: **스루풋 우선**, 선점 비용 최소화.  
- [ ] 실시간: RM/EDF 모델링, **여유율**과 **우선순위 역전**(priority inversion → **상속**) 대책.

### 메모리
- [ ] **TLB 리치**(페이지 크기×엔트리 수) ≥ 워킹셋. 필요시 **Huge Page**.  
- [ ] **지역성**: 타일링/프리페치, 데이터 구조 **연속성** 확보.  
- [ ] **mmap + CoW**로 큰 파일 처리, 페이지 캐시 재활용.  
- [ ] **스래싱 감지**(pf/s, CPU idle↑) 시 동시 작업 수 ↓ 혹은 메모리 증설.  
- [ ] 보안: **ASLR, W^X, NX bit**, 최소 권한.

---

## 11) 자주 틀리는 포인트(정오표)

1) **프로세스=스레드**? → 스레드는 **주소공간 공유**, 프로세스는 **격리**.  
2) **SJF가 항상 최고**? → 평균 대기는 최소지만 **실현 어려움(예측)**, **기아** 위험.  
3) **RR에서 \(q\) 작을수록 좋다**? → 응답성↑ 대신 컨텍스트 스위치 비용↑.  
4) **TLB 미스=페이지 폴트**? → 아님. TLB 미스는 **페이지 워크**로 해결 가능, PTE가 없을 때만 폴트.  
5) **FIFO는 안전**? → **벨라디 현상**으로 프레임↑해도 부재가 늘 수 있음.  
6) **Huge Page는 무조건 이득**? → TLB 미스↓ 장점 vs **내부 단편화/NUMA 이동 비용**.

---

## 12) 연습문제(풀이 포함)

**Q1. (스케줄링)** 작업 (도착0): A=8, B=4, C=2. SJF(비선점) 평균 대기시간?  
**A.** 순서 C(0),B(2),A(6) → 대기(C=0,B=2,A=6) → **2.67**.

**Q2. (SRTF)** 도착/버스트: A(0,7), B(2,4), C(4,1). 평균 대기시간?  
**A.** 0–2 A(5), 2–6 B(0), 6–7 C(0), 7–12 A 완료. 대기(A=5,B=0,C=0)=**1.67**.

**Q3. (RR)** A=5,B=4,C=3, \(q=2\). 평균 대기시간?  
**A.** Gantt 계산 → 대기(A=6,B=6,C=4) 평균=**5.33**.

**Q4. (EAT)** \(T_\text{hit}=0.8\)ns, \(T_\text{miss}=35\)ns, \(\alpha=0.97\) → EAT?  
**A.** \(0.03×35+0.97×0.8=1.05+0.776=**1.826ns**\).

**Q5. (AMAT)** L1=1ns(m=5%), L2=4ns(m=10%), Mem=60ns → AMAT?  
**A.** \(1 + 0.05(4 + 0.10×60)=1.5\)ns.

**Q6. (페이지 교체)** 참조열 7,0,1,2,0,3,0,4,2,3,0,3,2, 프레임=3. LRU 부재 수?  
**A.** 손계산 결과 **9**.

**Q7. (RT)** 주기·실행시간: \((C,T)=(1,4),(1,5),(2,10)\). RM 수용성?  
**A.** \(U=1/4+1/5+2/10=0.25+0.2+0.2=0.65\le 0.779\ (n=3)\) → **수용**.

**Q8. (보호)** Base=0x2000, Limit=0x1000. 접근 주소 0x2F00 허용?  
**A.** 유효 범위 [0x2000, 0x2FFF]. 0x2F00 **허용**.

**Q9. (단편화)** 100B/500B/200B 자유블록, 212B 요청. 첫적합/최적적합 결과?  
**A.** 첫적합=500B 선택, 최적적합=200B는 부족 → 500B 선택(남 288B).

**Q10. (CoW)** `fork()` 직후 부모/자식이 같은 페이지에 쓰기?  
**A.** **페이지별 복사 발생**(CoW 깨짐), 독립 사본 생성.

---

## 13) 미니 랩 가이드(로컬 실습)

```bash
# 스케줄러/프로세스 관찰
ps -eLo pid,tid,pri,ni,psr,comm | head
top -H -p <PID>         # 스레드별 사용량
chrt -f 50 ./rt_task    # SCHED_FIFO로 실행(주의)

# 메모리/페이지
vmstat 1                # r(런큐), si/so(스왑), cs(컨텍스트 스위치)
perf stat -e cycles,instructions,task-clock,minor-faults,major-faults ./app
cat /proc/meminfo | egrep 'Huge|Anon|File'
numastat -p <PID>
```

---

## 14) 한 페이지 암기표(초압축 24줄)

1) 프로세스=자원+주소공간, 스레드=흐름(PC/레지스터/스택)  
2) PCB: PID/상태/레지스터/스케줄/메모리/파일  
3) 컨텍스트스위치=레지스터 저장/복원(+캐시/TLB 교란)  
4) 지표: 처리량/반환/대기/응답/이용률/공정성  
5) FCFS=간단, 호위효과 / SJF=평균대기↓, 예측/기아  
6) SRTF=최단남은시간, 선점 / RR=응답성↑, 오버헤드↑  
7) 우선순위=에이징 필수 / MLFQ=대화형 우대, 부스팅  
8) RT: RM \(U\le n(2^{1/n}-1)\), EDF \(U\le1\)  
9) 주소공간: 코드/데이터/힙↑/스택↓, ASLR, W^X  
10) 페이징: PTE(유효/R/W/X/A/D/프레임)  
11) 다단 PT: 4KB/48b → 4단×9b + offset12b  
12) TLB EAT \(=(1-\alpha)T_m + \alpha T_h\)  
13) 교체: OPT(상한), FIFO(벨라디), LRU(스택성), Clock  
14) 프레임 할당: 전역/지역, 작업셋, 스래싱  
15) CoW: 쓰기 시 복사 / mmap: 파일-메모리 매핑  
16) THP: TLB미스↓ vs 단편화/NUMA 비용  
17) CFS: vruntime/가중치, RB-Tree  
18) RT 클래스: FIFO/RR, 우선순위 역전→상속  
19) buddy/slab, 페이지 캐시, Dirty 플러시  
20) NUMA: first-touch, 바인딩(numactl)  
21) RR 유효비율 \(\approx q/(q+s)\)  
22) AMAT, TLB 미스와 페이지 폴트 구분  
23) 스래싱: pf↑, CPU↓, I/O↑ → MP↓  
24) 보안: NX, ASLR, 최소권한

---

## 15) 마무리

- **프로세스/스레드**는 “자원과 흐름”의 분리, **스케줄러**는 “누가 언제 CPU를 쓰는가”,  
  **메모리 관리자**는 “어느 가상주소가 어디에 있는가”를 결정합니다.  
- **수치**(대기/응답/EAT/AMAT/VRUNTIME)로 병목을 보며, **정책**(MLFQ/교체/작업셋)으로 통제하세요.  
- 암기 대신 **원리→공식→예제** 루틴을 반복하면 응용/서술형/계산형 모두 흔들리지 않습니다.