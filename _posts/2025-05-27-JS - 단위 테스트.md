---
layout: post
title: JavaScript - 단위 테스트
date: 2025-05-27 20:20:23 +0900
category: JavaScript
---
# 자바스크립트 단위 테스트 소개 (Jest, Mocha)

## 1) 단위 테스트란?

> 단위 테스트(Unit Test)는 프로그램의 **가장 작은 단위(함수, 모듈 등)**가 **의도대로 작동하는지 자동으로 검증**하는 테스트입니다.

### 왜 중요한가
- 변경 시 회귀 결함을 빠르게 감지
- 리팩토링·추가 개발의 안전망
- 명세서 역할(테스트가 곧 요구)
- CI/CD에서 자동화 가능

### 테스트 피라미드 요약
- **단위(Unit)**: 작고 빠른 테스트, 대부분을 차지
- **통합(Integration)**: 모듈 간 상호작용 검증
- **E2E(End-to-End)**: 사용자 시나리오 전체 흐름

---

## 2) 도구 개요: Jest, Mocha

| 도구 | 성격 | 장점 | 고려사항 |
|---|---|---|---|
| Jest | 올인원(러너+어설션+모킹+커버리지) | 설정 간단, 속도 빠름, 스냅샷, TS 지원 우수 | Node 순수 라이브러리면 과할 수 있음 |
| Mocha | 러너 중심(조합형) | 유연함, Node 유틸에 적합 | 어설션(Chai), 모킹(Sinon), 커버리지(istanbul/nyc) 별도 구성 필요 |
| Vitest | Vite/ESBuild 기반, Jest API 유사 | 매우 빠른 실행, ESM/TS 친화 | 생태계는 빠르게 성장 중 |

---

## 3) Jest 빠른 시작

### 설치
```bash
npm i -D jest
```

`package.json` 스크립트:
```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage"
  }
}
```

### 기본 예제

```
📦 src
 ┣ 📜 math.js
┗ 📦 __tests__
  ┗ 📜 math.test.js
```

`src/math.js`
```js
export function add(a, b) {
  return a + b;
}
```

`__tests__/math.test.js`
```js
import { add } from '../src/math';

test('add: 1 + 2 = 3', () => {
  expect(add(1, 2)).toBe(3);
});
```

실행:
```bash
npm test
```

### 대표 API 요약
- 정의: `test(name, fn)`, `it(name, fn)`, `describe(name, fn)`
- 어설션: `expect(value).toBe(x)`, `.toEqual(obj)`, `.toBeTruthy()`, `.toThrow()`
- 훅: `beforeAll`, `afterAll`, `beforeEach`, `afterEach`

---

## 4) Mocha 빠른 시작

### 설치
```bash
npm i -D mocha chai
```

구조:
```
📦 src
 ┣ 📜 math.js
📦 test
 ┗ 📜 math.test.js
```

`src/math.js`
```js
exports.add = (a, b) => a + b;
```

`test/math.test.js`
```js
const { expect } = require('chai');
const { add } = require('../src/math');

describe('add', () => {
  it('1 + 2 = 3', () => {
    expect(add(1, 2)).to.equal(3);
  });
});
```

실행:
```bash
npx mocha
```

> Mocha는 러너만 제공하므로, **어설션(Chai)**, **모킹(Sinon)**, **커버리지(nyc)** 등을 조합합니다.

---

## 5) 비동기 테스트(콜백/Promise/async)

### Jest
```js
// 콜백
test('비동기 콜백', (done) => {
  setTimeout(() => {
    expect(1 + 1).toBe(2);
    done();
  }, 10);
});

// Promise
test('Promise', () => {
  return fetchUser().then(u => expect(u.name).toBe('alice'));
});

// async/await
test('async/await', async () => {
  const u = await fetchUser();
  expect(u.name).toBe('alice');
});
```

### Mocha
```js
// 콜백
it('비동기 콜백', (done) => {
  setTimeout(() => {
    done();
  }, 10);
});

// Promise
it('Promise', () => {
  return fetchUser().then(/* ... */);
});

// async/await
it('async/await', async () => {
  const data = await fetchUser();
  // ...
});
```

---

## 6) 목킹/스파이/스텁

### Jest 내장 모킹

**함수 모킹**
```js
const send = jest.fn().mockReturnValue(true);
expect(send('hello')).toBe(true);
expect(send).toHaveBeenCalledWith('hello');
```

**모듈 모킹**
```js
// src/api.js
export async function getUser(id) {
  const res = await fetch(`/users/${id}`);
  return res.json();
}

// __tests__/api.test.js
import * as api from '../src/api';

global.fetch = jest.fn().mockResolvedValue({
  json: async () => ({ id: 1, name: 'alice' })
});

test('getUser', async () => {
  const u = await api.getUser(1);
  expect(u.name).toBe('alice');
  expect(fetch).toHaveBeenCalledWith('/users/1');
});
```

**타이머/시간 제어**
```js
jest.useFakeTimers();
const cb = jest.fn();
setTimeout(cb, 1000);
jest.advanceTimersByTime(1000);
expect(cb).toHaveBeenCalled();
```

### Mocha + Sinon 조합
```bash
npm i -D sinon
```

```js
const sinon = require('sinon');

it('스파이', () => {
  const fn = sinon.spy();
  fn('a');
  sinon.assert.calledWith(fn, 'a');
});

it('타이머', () => {
  const clock = sinon.useFakeTimers();
  const spy = sinon.spy();
  setTimeout(spy, 1000);
  clock.tick(1000);
  sinon.assert.calledOnce(spy);
  clock.restore();
});
```

---

## 7) 파라미터화 테스트(테이블 드리븐)

### Jest
```js
test.each([
  ['abc', 3],
  ['', 0],
  ['hello', 5],
])('length("%s") = %i', (input, len) => {
  expect(input.length).toBe(len);
});
```

### Mocha(간단 루프)
```js
[
  ['abc', 3],
  ['', 0],
  ['hello', 5],
].forEach(([input, len]) => {
  it(`length("${input}") = ${len}`, () => {
    expect(input.length).to.equal(len);
  });
});
```

---

## 8) 스냅샷 테스트(Jest)

UI 출력, 직렬화 가능한 구조 비교에 유용합니다.

```js
function renderUser(u) { return { tag: 'User', name: u.name }; }

test('스냅샷', () => {
  expect(renderUser({ name: 'alice' })).toMatchSnapshot();
});
```

- 최초 실행 시 스냅샷 파일이 생성됩니다.
- 의도된 변경이면 `--updateSnapshot`로 갱신합니다.

> DOM/컴포넌트는 `@testing-library/react` 등과 조합하여 스냅샷/접근성 쿼리로 검증합니다.

---

## 9) 커버리지 측정

### Jest
```bash
npm run test:cov
```

임계값 강제(권장):
```json
"jest": {
  "coverageThreshold": {
    "global": { "branches": 90, "functions": 95, "lines": 95, "statements": 95 }
  }
}
```

### Mocha + nyc
```bash
npm i -D nyc
```

`package.json`
```json
{
  "scripts": {
    "test": "mocha",
    "test:cov": "nyc mocha"
  },
  "nyc": {
    "reporter": ["text", "lcov"],
    "all": true,
    "exclude": ["test/**"]
  }
}
```

---

## 10) 폴더 구조와 네이밍

- **Jest**: `__tests__/**/*.test.js` 또는 `*.spec.js`를 자동 인식
- **Mocha**: 기본은 `test/**/*.js` 실행

예시
```
📦 project
 ┣ 📦 src
 ┃ ┣ 📜 math.js
 ┃ ┗ 📜 api.js
 ┣ 📦 __tests__
 ┃ ┣ 📜 math.test.js
 ┃ ┗ 📜 api.test.js
 ┗ 📜 package.json
```

---

## 11) 타입스크립트 지원

### Jest + ts-jest
```bash
npm i -D typescript ts-jest @types/jest
npx ts-jest config:init
```

`src/math.ts`
```ts
export const add = (a: number, b: number) => a + b;
```

`__tests__/math.test.ts`
```ts
import { add } from '../src/math';
test('add', () => expect(add(1, 2)).toBe(3));
```

### Mocha + ts-node
```bash
npm i -D ts-node typescript @types/mocha @types/chai
npx tsc --init
```

실행:
```bash
npx mocha -r ts-node/register "test/**/*.ts"
```

---

## 12) ESM 환경

### Jest
- Node ESM(`"type":"module"`) 사용 시 `transform` 또는 `babel-jest`/`ts-jest`로 처리
- 최신 Jest는 ESM 지원이 개선되었지만, 설정 확인 권장

`jest.config.js` (예시)
```js
export default {
  testEnvironment: 'node',
  transform: {}
}
```

### Mocha
```bash
node --loader ts-node/esm node_modules/mocha/bin/mocha "test/**/*.ts"
```
혹은 순수 ESM이라면 `import`만으로 동작하며 비교적 설정이 단순합니다.

---

## 13) HTTP 테스트(네트워크 레이어)

### fetch 목킹(Jest)
```js
global.fetch = jest.fn().mockResolvedValue({
  ok: true,
  json: async () => ({ ok: 1 })
});
```

### Express API 통합 테스트(supertest)
```bash
npm i -D supertest
```

```js
import request from 'supertest';
import app from '../src/app';

test('GET /health', async () => {
  const res = await request(app).get('/health');
  expect(res.status).toBe(200);
  expect(res.body).toEqual({ ok: 1 });
});
```

---

## 14) 비밀키/환경변수 분리

- 테스트용 `.env.test`를 두고, 런타임에만 주입
- `dotenv` 로드 시 `NODE_ENV === 'test'` 분기
- 민감정보가 스냅샷/로그/레포에 유출되지 않도록 주의

---

## 15) 성능·신뢰성 팁

- 테스트는 **독립적**이어야 함(순서 의존 X)
- 외부 자원(I/O, DB, 네트워크)은 **목킹/테스트 더블** 우선
- 비동기 테스트는 **반드시 종료 신호**를 명시(done/return/await)
- **플레이키(flaky) 테스트** 제거: 타이밍 의존/랜덤성 최소화, 가짜 타이머 사용
- 커버리지 수치보다 **의미 있는 케이스**(경계/에러 경로) 우선

---

## 16) CI 파이프라인 예시(GitHub Actions)

`.github/workflows/test.yml`
```yaml
name: test
on: [push, pull_request]
jobs:
  unit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - run: npm ci
      - run: npm run test:cov
```

---

## 17) 실전 예제 모음

### 17.1 계산 유틸(동치/예외/경계)
`src/div.js`
```js
export function div(a, b) {
  if (b === 0) throw new Error('divide by zero');
  return a / b;
}
```

`__tests__/div.test.js`
```js
import { div } from '../src/div';

describe('div', () => {
  test('정상 나눗셈', () => {
    expect(div(6, 2)).toBe(3);
  });
  test('0으로 나누면 예외', () => {
    expect(() => div(1, 0)).toThrow('divide by zero');
  });
});
```

### 17.2 파라미터화 + 경계값
```js
test.each([
  [6, 3, 2],
  [5, 2, 2.5],
  [0, 7, 0]
])('div(%i, %i) = %s', (a, b, out) => {
  expect(div(a, b)).toBe(out);
});
```

### 17.3 가짜 타이머 기반 타임아웃 함수
`src/wait.js`
```js
export function wait(ms) {
  return new Promise(res => setTimeout(res, ms));
}
```

`__tests__/wait.test.js`
```js
import { wait } from '../src/wait';

jest.useFakeTimers();

test('wait는 지정 시간 이후 resolve', async () => {
  const p = wait(1000);
  jest.advanceTimersByTime(999);
  let done = false;
  p.then(() => (done = true));
  expect(done).toBe(false);
  jest.advanceTimersByTime(1);
  await p;
  expect(done).toBe(true);
});
```

---

## 18) Mocha 조합 고급 예시

### Chai + Sinon + nyc
```bash
npm i -D mocha chai sinon nyc
```

`test/setup.js`
```js
const chai = require('chai');
global.expect = chai.expect;
```

실행 스크립트:
```json
{
  "scripts": {
    "test": "mocha -r ./test/setup.js",
    "test:cov": "nyc mocha -r ./test/setup.js"
  }
}
```

스파이/스텁:
```js
const sinon = require('sinon');

describe('스텁 예시', () => {
  it('Date.now를 스텁', () => {
    const stub = sinon.stub(Date, 'now').returns(1234567890);
    expect(Date.now()).to.equal(1234567890);
    stub.restore();
  });
});
```

---

## 19) 정리 표

| 항목 | Jest | Mocha |
|---|---|---|
| 러너/어설션/모킹/커버리지 | 포함 | 조합 필요(Chai/Sinon/nyc) |
| 설정 난이도 | 쉬움 | 자유롭지만 구성 필요 |
| 스냅샷 | 기본 지원 | 별도 라이브러리 |
| TS/ESM | 우수(추가 설정 간단) | 가능(조합으로 해결) |
| 사용처 | 프론트엔드·풀스택 | Node 유틸/백엔드·레거시 대체 |

---

## 20) 마무리 요약

- **단위 테스트**는 빠른 피드백과 안정적인 리팩토링의 핵심입니다.
- **Jest**는 올인원으로 쉽고 빠르게 시작할 수 있으며, 스냅샷/모킹/타이머/커버리지까지 기본 제공.
- **Mocha**는 조합의 자유도가 높고 Node 유틸 테스트에 적합합니다.
- **비동기/목킹/파라미터화/가짜 타이머/스냅샷**을 적극 활용해 **의미 있는 테스트**를 작성하세요.
- **커버리지 임계값**과 **CI 파이프라인**으로 품질을 자동화하고, 테스트가 곧 **명세**가 되도록 유지하세요.

--- 

## 참고 링크

- Jest: https://jestjs.io/
- Mocha: https://mochajs.org/
- Chai: https://www.chaijs.com/
- Sinon: https://sinonjs.org/
- NYC(Istanbul): https://github.com/istanbuljs/nyc
- Testing Library: https://testing-library.com/
- Vitest: https://vitest.dev/