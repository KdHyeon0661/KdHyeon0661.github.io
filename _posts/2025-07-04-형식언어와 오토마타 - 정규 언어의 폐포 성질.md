---
layout: post
title: 형식언어와 오토마타 - 정규 언어의 폐포 성질
date: 2025-07-04 22:20:23 +0900
category: 형식언어와 오토마타
---
# 정규 언어의 폐포 성질 (Closure Properties of Regular Languages)

## 0. 준비: 표기 & 직관

- 알파벳: $$\Sigma$$, 문자열 집합: $$\Sigma^\*$$, 공백문자열: $$\varepsilon$$  
- DFA: $$M=(Q,\Sigma,\delta,q_0,F)$$ (필요시 **sink** 추가로 완전화)  
- ε-NFA: $$\delta:Q\times(\Sigma\cup\{\varepsilon\})\to \mathcal P(Q)$$  
- **제품구성(product)**: 두 DFA $$A,B$$로부터 상태 $$Q_A\times Q_B$$의 새 DFA를 만드는 표준 합성  
- 핵심 아이디어: **정규어는 유한상태모형**으로 표현되므로, 연산에 대해 “**기계적으로 합성**”이 가능 → **폐포성**

---

## 1. 집합 연산: 합/교/차/여 (Union / Intersection / Difference / Complement)

### 1-A. 합집합 \(L_1\cup L_2\) — **폐포 ✓**

- **구성**(DFA): 제품구성, 시작 \((q^A_0,q^B_0)\), 수용 \(F=\{(p,q)\mid p\in F_A\ \lor\ q\in F_B\}\)  
- **직관**: “둘 중 **하나라도** 수용이면 수용”  
- **복잡도**: 상태 수 \(|Q_A||Q_B|\) (선형 시간 합성 + 선형 탐색)

### 1-B. 교집합 \(L_1\cap L_2\) — **폐포 ✓**

- **구성**: 제품구성, 수용 \(F=\{(p,q)\mid p\in F_A\ \land\ q\in F_B\}\)  
- **직관**: “둘 다 수용이면 수용”

### 1-C. 차집합 \(L_1-L_2\) — **폐포 ✓**

- **구성**: \(L_1\cap \overline{L_2}\). 여집합과 교집합을 조합  
- **주의**(보완 전제): DFA는 **완전화** 후 수용/비수용을 **반전**해야 정확

### 1-D. 여집합 \(\overline{L}\) — **폐포 ✓**

- **구성**: 완전 DFA에서 \(F\leftrightarrow Q\setminus F\) 반전

---

## 2. 기타 핵심 연산

### 2-A. 연접(Concatenation) \(L_1\cdot L_2\) — **폐포 ✓**

- **구성**: ε-NFA로 \(A\)의 모든 수용상태에서 \(B\)의 시작상태로 **ε-전이** 추가  
- **직관**: 앞부분을 \(A\)가, 이어서 \(B\)가 읽음  
- **참고**: DFA만으로 직접 합성하면 상태 폭증/복잡 → 보통 ε-NFA→DFA(필요 시)

### 2-B. Kleene-★ \(L^\*\) / \(L^+\) — **폐포 ✓**

- **구성**: 새 시작/수용 상태를 두고, 원 수용→원 시작 **ε-전이**(반복), 시작을 수용으로(빈 문자열 허용)  
- \(L^+=LL^\*\)

### 2-C. 역순(Reversal) \(L^R\) — **폐포 ✓**

- **구성**: DFA의 **모든 간선 방향을 뒤집고**, 새 시작에서 **기존 수용들로 ε-전이**, 기존 시작을 **수용**  
- **산출물**: 일반적으로 **NFA** (DFA를 뒤집으면 NFA가 됨)

### 2-D. 접두/접미/부분문자열 — **폐포 ✓**

- **접두** Pref\((L)\): DFA에서 “**수용에 도달 가능한** 모든 상태”를 **수용**으로 승격  
- **접미** Suff\((L)\): 시작에서 **도달 가능한 모든 상태**를 **시작상태 집합**으로 하는 NFA  
- **부분문자열** Substr\((L)\): 설계 방식 여러 개(모든 상태를 시작/수용으로 하는 변형 NFA 등)로 가능

### 2-E. Shuffle(삽입/교차 섞기) — **폐포 ✓**

- **정의**: \(u\shuffle v\)는 \(u\)와 \(v\)의 **상대적 순서를 보존**하며 섞은 문자열 집합  
- **구성**: 상태 \((p,q)\)에서 입력 \(a\)를 **둘 중 한 기계**가 소비  
  \((p,q)\xrightarrow{a}(\delta_A(p,a),q)\) 또는 \((p,\delta_B(q,a))\), 수용 \((p\in F_A,q\in F_B)\)

### 2-F. 호모몰피즘 / 역호모몰피즘 — **폐포 ✓**

- **호모몰피즘** \(h:\Sigma\to \Gamma^\*\):  
  \(h(L)=\{h(w)\mid w\in L\}\) — 전이를 \(a\mapsto h(a)\) **경로**로 확장한 ε-NFA 구성
- **역호모몰피즘** \(h^{-1}(L)=\{x\in \Sigma^\*\mid h(x)\in L\}\):  
  \(\Gamma\)-DFA를 **내부적으로 시뮬레이션**: 입력 \(a\)를 읽을 때마다 **\(h(a)\)** 경로를 내부에서 따라감 → ε-NFA

### 2-G. (좌/우) 몫(Quotient) — **폐포 ✓**

- **정의**: 우몫 \(L/K=\{x\mid \exists y\in K: xy\in L\}\), 좌몫 \(K\backslash L=\{y\mid \exists x\in K: xy\in L\}\)  
- **사실**: \(L\)이 정규이면 **\(K\)가 어떤 언어이든** \(L/K\)와 \(K\backslash L\)은 **정규**.  
  (존재 정리; **효과적 구성**은 \(K\)가 적어도 **재귀적으로 주어질 때** 가능. \(K\)가 **정규**면 제품구성으로 계산적 구성이 쉬움.)

---

## 3. 반례 주의(잘못된 진술 바로잡기)

- “\(a^n b^n\)”은 **정규가 아님**(펌핑 렘마). 따라서 “정규 \(\cap\) 비정규 = 정규” 같은 진술은 **오류**.  
- 교집합/합집합의 폐포성은 **양쪽 모두 정규**일 때만 성립.  
- 보완은 **완전 DFA**에서만 비트 반전으로 정확.

---

## 4. 파이썬 레퍼런스 코드 (DFA/ε-NFA + 합성기)

> 블로그 실습용 간결 구현. 실제 응용 시 입력검증/최소화(Hopcroft)/비트셋 최적화 권장.

```python
from collections import defaultdict, deque
from typing import Dict, Set, Tuple, Iterable, Optional

Sym = str
State = str

# ---------- ε-NFA ----------
class ENFA:
    def __init__(self, Q: Iterable[State], Sigma: Iterable[Sym],
                 delta: Dict[Tuple[State, Sym], Set[State]],
                 q0: State, F: Iterable[State], eps: Sym='ε'):
        self.Q, self.Sigma = set(Q), set(Sigma)
        self.delta = defaultdict(set)
        for (q,a), dests in delta.items():
            self.delta[(q,a)] |= set(dests)
        self.q0, self.F, self.eps = q0, set(F), eps

    def eclosure(self, S: Iterable[State]) -> Set[State]:
        st, seen = list(S), set(S)
        while st:
            q = st.pop()
            for r in self.delta.get((q, self.eps), set()):
                if r not in seen:
                    seen.add(r); st.append(r)
        return seen

    def accepts(self, w: str) -> bool:
        curr = self.eclosure({self.q0})
        for ch in w:
            if ch not in self.Sigma: return False
            nxt = set()
            for q in curr:
                nxt |= self.delta.get((q, ch), set())
            curr = self.eclosure(nxt)
            if not curr: return False
        return len(curr & self.F) > 0

# ---------- DFA ----------
class DFA:
    def __init__(self, Q: Iterable[State], Sigma: Iterable[Sym],
                 delta: Dict[Tuple[State, Sym], Optional[State]],
                 q0: State, F: Iterable[State]):
        self.Q, self.Sigma = set(Q), set(Sigma)
        self.delta, self.q0, self.F = dict(delta), q0, set(F)

    def run(self, w: str) -> bool:
        q = self.q0
        for ch in w:
            q = self.delta.get((q, ch))
            if q is None: return False
        return q in self.F

    def complete(self, sink="__SINK__") -> "DFA":
        if sink in self.Q: sink += "_0"
        Q, delta = set(self.Q), dict(self.delta)
        need = False
        for q in Q:
            for a in self.Sigma:
                if (q,a) not in delta: need = True
        if need:
            Q.add(sink)
            for a in self.Sigma: delta[(sink,a)] = sink
            for q in list(Q):
                for a in self.Sigma:
                    delta.setdefault((q,a), sink)
        return DFA(Q, self.Sigma, delta, self.q0, self.F)

# ---------- 1) 합/교/차/여 ----------
def product_dfa(A: DFA, B: DFA,
                accept_pred) -> DFA:
    assert A.Sigma == B.Sigma
    A, B = A.complete(), B.complete()
    Sigma = A.Sigma
    start = (A.q0, B.q0)
    Q, F, delta = set([start]), set(), {}
    dq = deque([start])
    while dq:
        p, q = dq.popleft()
        if accept_pred(p in A.F, q in B.F):
            F.add((p,q))
        for a in Sigma:
            np, nq = A.delta[(p,a)], B.delta[(q,a)]
            s = (np,nq)
            delta[((p,q), a)] = s
            if s not in Q:
                Q.add(s); dq.append(s)
    return DFA(Q, Sigma, delta, start, F)

def union_dfa(A: DFA, B: DFA) -> DFA:
    return product_dfa(A,B, lambda x,y: x or y)

def inter_dfa(A: DFA, B: DFA) -> DFA:
    return product_dfa(A,B, lambda x,y: x and y)

def diff_dfa(A: DFA, B: DFA) -> DFA:
    return product_dfa(A,B, lambda x,y: x and (not y))

def comp_dfa(A: DFA) -> DFA:
    C = A.complete()
    return DFA(C.Q, C.Sigma, C.delta, C.q0, C.Q - C.F)

# ---------- 2) 연접/별/역순 ----------
def dfa_to_enfa(D: DFA) -> ENFA:
    delta = defaultdict(set)
    for (q,a), p in D.delta.items():
        if p is not None:
            delta[(q,a)].add(p)
    return ENFA(D.Q, D.Sigma, delta, D.q0, D.F)

def concat_enfa(A: ENFA, B: ENFA) -> ENFA:
    assert A.Sigma == B.Sigma
    Q = set(A.Q) | set(B.Q)
    delta = defaultdict(set, A.delta)
    for k,v in B.delta.items(): delta[k] |= v
    # A의 모든 F에서 B.q0로 ε
    for f in A.F:
        delta[(f, A.eps)].add(B.q0)
    return ENFA(Q, A.Sigma, delta, A.q0, B.F | (A.F if B.q0 in B.F else set()))

def star_enfa(A: ENFA) -> ENFA:
    Q = set(A.Q) | {"__S__"}
    delta = defaultdict(set, A.delta)
    # 새 시작/수용
    q0, F = "__S__", set(A.F) | {"__S__"}
    # 새 시작에서 원 시작으로 ε
    delta[(q0, A.eps)].add(A.q0)
    # 원 F에서 원 시작으로 ε (반복)
    for f in A.F:
        delta[(f, A.eps)].add(A.q0)
    return ENFA(Q, A.Sigma, delta, q0, F)

def reverse_dfa_to_enfa(D: DFA) -> ENFA:
    # 간선 방향 뒤집기 + 새 시작에서 옛 F로 ε, 옛 시작을 수용
    delta = defaultdict(set)
    for (q,a), p in D.delta.items():
        if p is not None:
            delta[(p,a)].add(q)
    new_start = "__S__"
    Q = set(D.Q) | {new_start}
    for f in D.F:
        delta[(new_start,'ε')].add(f)
    return ENFA(Q, D.Sigma, delta, new_start, {D.q0})

# ---------- 3) Shuffle ----------
def shuffle_dfa(A: DFA, B: DFA) -> ENFA:
    # 상태 (p,q), 입력 a에서 둘 중 하나가 소비
    assert A.Sigma == B.Sigma
    Sigma = A.Sigma
    Q = set()
    delta = defaultdict(set)
    start = (A.q0, B.q0)
    F = set()
    dq = deque([start]); Q.add(start)
    while dq:
        (p,q) = dq.popleft()
        if p in A.F and q in B.F:
            F.add((p,q))
        for a in Sigma:
            np = A.delta.get((p,a))
            if np is not None:
                s = (np, q)
                delta[((p,q), a)].add(s)
                if s not in Q: Q.add(s); dq.append(s)
            nq = B.delta.get((q,a))
            if nq is not None:
                s = (p, nq)
                delta[((p,q), a)].add(s)
                if s not in Q: Q.add(s); dq.append(s)
    return ENFA(Q, Sigma, delta, start, F)

# ---------- 4) 호모몰피즘 / 역호모몰피즘 ----------
def homomorphism_enfa(D: DFA, h: Dict[Sym, str]) -> ENFA:
    # 각 전이 (q,a)->p 를 a->h(a) 경로로 확장 (중간 가상상태 부여)
    SigmaG = set().union(*[set(h[a]) for a in h]) if h else set()
    Q = set(D.Q)
    delta = defaultdict(set)
    nid = 0
    for (q,a), p in D.delta.items():
        if p is None: continue
        s = q
        word = h[a]
        if word == "":
            # h(a)=ε 이면 ε-전이
            delta[(s,'ε')].add(p)
            continue
        for i,ch in enumerate(word):
            if i == len(word)-1:
                # 마지막 글자
                delta[(s,ch)].add(p)
            else:
                mid = f"__H{nid}__"; nid += 1
                Q.add(mid)
                delta[(s,ch)].add(mid)
                s = mid
    return ENFA(Q, SigmaG, delta, D.q0, D.F)

def inverse_homomorphism_enfa(D: DFA, h: Dict[Sym, str], Sigma_src: Set[Sym]) -> ENFA:
    # 소스 알파벳(입력)의 각 a를 읽을 때, 내부적으로 h(a)를 D에서 시뮬레이션
    Q = set(D.Q) | {"__SINK__"}
    delta = defaultdict(set)
    for q in D.Q:
        for a in Sigma_src:
            # h(a)를 따라 내적 이동 경로 구성
            word = h[a]
            curr = {q}
            if word == "":
                # h(a)=ε : 상태 변화 없음, 즉 q 그대로 (ε-전이 아닌 'a' 라벨로)
                # NFA라서 (q,a)->q 로 본다
                delta[(q,a)].add(q)
                continue
            mids = set([q])
            for ch in word:
                nxt = set()
                for s in mids:
                    p = D.delta.get((s, ch))
                    if p is not None:
                        nxt.add(p)
                mids = nxt
            if not mids:
                continue
            for t in mids:
                delta[(q, a)].add(t)
    # 시작/수용 동일 (D를 내부로 시뮬레이션)
    return ENFA(Q, Sigma_src, delta, D.q0, D.F)

# ---------- 5) 접두/접미 ----------
def prefix_closure_dfa(D: DFA) -> DFA:
    # 역그래프로 F co-reach
    R = reachable(D)
    rev = defaultdict(list)
    for (q,a),p in D.delta.items():
        if q in R and p in R:
            rev[p].append(q)
    can_reach_F = set(D.F) & R
    dq = deque(can_reach_F)
    while dq:
        u = dq.popleft()
        for v in rev[u]:
            if v not in can_reach_F:
                can_reach_F.add(v); dq.append(v)
    new_delta = {(q,a):p for (q,a),p in D.delta.items() if q in R and p in R}
    return DFA(R, D.Sigma, new_delta, D.q0, can_reach_F)

def reachable(D: DFA) -> Set[State]:
    fwd = defaultdict(list)
    for (q,a),p in D.delta.items():
        if p is not None: fwd[q].append(p)
    seen, dq = {D.q0}, deque([D.q0])
    while dq:
        u = dq.popleft()
        for v in fwd[u]:
            if v not in seen:
                seen.add(v); dq.append(v)
    return seen
```

---

## 5. 실습 예제 (설계 → 합성 → 검사)

### 5-A. 합·교·차·여 — 짝수/홀수 패리티 언어

- \(L_{\text{even}a}=\{a^{2n}\}\), \(L_{\text{odd}a}=\{a^{2n+1}\}\) →  
  \(L_{\text{even}a}\cup L_{\text{odd}a}=a^\*\),  
  \(L_{\text{even}a}\cap L_{\text{odd}a}=\varnothing\)

```python
# DFA for even/odd number of 'a'
D_even = DFA({'e','o'},{'a'}, {('e','a'):'o', ('o','a'):'e'}, 'e', {'e'})
D_odd  = DFA({'e','o'},{'a'}, {('e','a'):'o', ('o','a'):'e'}, 'e', {'o'})

U = union_dfa(D_even, D_odd)   # == a*
I = inter_dfa(D_even, D_odd)   # == ∅
C = comp_dfa(D_even.complete()) # 보완: odd

tests = ["", "a", "aa", "aaa", "aaaa"]
print("Union (a*):", {t: U.run(t) for t in tests})
print("Inter (∅):",  {t: I.run(t) for t in tests})
print("Comp(even)=odd:", {t: C.run(t) for t in tests})
print("Diff even - odd (== even∩comp(odd)):", {t: diff_dfa(D_even, D_odd).run(t) for t in tests})
```

---

### 5-B. 연접·별 — \(a^+b^+\), \((ab)^\*\)

```python
# a+ (at least one 'a'), b+ over Σ={a,b}
D_a_plus = DFA({'S','A'},{'a','b'},
               {('S','a'):'A', ('S','b'):None, ('A','a'):'A', ('A','b'):None},
               'S', {'A'})
D_b_plus = DFA({'S','B'},{'a','b'},
               {('S','b'):'B', ('S','a'):None, ('B','b'):'B', ('B','a'):None},
               'S', {'B'})

A = dfa_to_enfa(D_a_plus)
B = dfa_to_enfa(D_b_plus)
AB = concat_enfa(A, B)  # a+ b+
print("a+ b+:",
      {"ab":AB.accepts("ab"), "aaabbb":AB.accepts("aaabbb"),
       "a":AB.accepts("a"), "b":AB.accepts("b"), "aab":AB.accepts("aab")})

# (ab)*
D_ab = DFA({'S','A','B'},{'a','b'},
           {('S','a'):'A', ('S','b'):None,
            ('A','b'):'S', ('A','a'):None,
            ('B','a'):None, ('B','b'):None}, 'S', {'S'})
# 위 DFA는 불완전 예시였으므로 보통은 ENFA로 별 구성하는 편이 안전
E = dfa_to_enfa(D_ab)
ESTAR = star_enfa(E)
print("(ab)*:", {"":ESTAR.accepts(""), "ab":ESTAR.accepts("ab"),
                 "abab":ESTAR.accepts("abab"), "aba":ESTAR.accepts("aba")})
```

---

### 5-C. 역순 — \(L=\{ab^n\}\Rightarrow L^R=\{b^n a\}\)

```python
# L = a b*  (a 다음 0개 이상 b)
D = DFA({'S','A','B'},{'a','b'},
        {('S','a'):'A', ('S','b'):None,
         ('A','b'):'A', ('A','a'):None,
         ('B','a'):None, ('B','b'):None},
        'S', {'A'})
R = reverse_dfa_to_enfa(D)
print("L:",   {"a":D.run("a"), "ab":D.run("ab"), "abb":D.run("abb"), "":D.run("")})
print("L^R:", {"a":R.accepts("a"), "ba":R.accepts("ba"), "bba":R.accepts("bba"),
               "":R.accepts(""), "ab":R.accepts("ab")})
```

---

### 5-D. Shuffle — \(a^\*\shuffle b^\*=\{a,b\}^\*\)

```python
# a* and b* over {a,b}
D_a_star = DFA({'S'},{'a','b'}, {('S','a'):'S', ('S','b'):None}, 'S', {'S'})
D_b_star = DFA({'S'},{'a','b'}, {('S','b'):'S', ('S','a'):None}, 'S', {'S'})

SH = shuffle_dfa(D_a_star, D_b_star)
for w in ["", "a", "b", "ab", "ba", "abba", "baba", "abbaab"]:
    print("shuffle:", w, "=>", SH.accepts(w))
# 모두 True (임의의 a/b 시퀀스가 a*와 b*의 셔플로 표현 가능)
```

---

### 5-E. 호모몰피즘 / 역호모몰피즘

```python
# 호모몰피즘 h: a->"ab", b->"aa";  L = a*  =>  h(L) = (ab)*
h = {'a':"ab", 'b':"aa"}  # b는 사용 안 함
L_a_star = DFA({'S'},{'a','b'}, {('S','a'):'S', ('S','b'):'S'}, 'S', {'S'})  # a,b 어떤 것도 허용(단순화)
# h 적용은 DFA의 'a' 전이만 관심. 예시를 위해 a*로 해석하려면 b를 죽이거나 테스트를 a로만.
H = homomorphism_enfa(L_a_star, {'a':"ab"})  # a만 정의
print("h(a*)=(ab)*:", {"":H.accepts(""), "ab":H.accepts("ab"), "abab":H.accepts("abab"),
                       "a":H.accepts("a"), "aba":H.accepts("aba")})

# 역호모몰피즘: Γ-언어 L_endab = {ends with 'ab'}, h: 0->"a", 1->"ab"
D_end_ab = DFA({'S','A','AB'},{'a','b'},
               {('S','a'):'A', ('S','b'):'S',
                ('A','a'):'A', ('A','b'):'AB',
                ('AB','a'):'A', ('AB','b'):'S'},
               'S', {'AB'})
h_inv = {'0':"a", '1':"ab"}   # Σ_src = {0,1}
IH = inverse_homomorphism_enfa(D_end_ab, h_inv, {'0','1'})
print("h^{-1}(endsWith ab):",
      {"":IH.accepts(""), "0":IH.accepts("0"), "1":IH.accepts("1"),
       "01":IH.accepts("01"), "001":IH.accepts("001"), "11":IH.accepts("11")})
# 해설: 입력의 0은 'a', 1은 'ab'로 확장되어 최종적으로 'ab'로 끝나면 수용
```

---

### 5-F. 접두/접미/부분문자열 (요약)

- **접두**: 위 `prefix_closure_dfa`로 생성 (수용 도달 가능한 상태 = 수용)  
- **접미**: 시작 도달 가능한 모든 상태를 시작상태화한 NFA (위 `suffix` 아이디어)  
- **부분문자열**: “임의 상태에서 시작해 임의 상태에서 끝나는” 경로를 수용으로 보이게 하여 구성 가능 (케이스에 맞게 정의)

---

## 6. 폐포성 한눈표 + 증명/구성 요약

| 연산 | 정규 폐포 | 대표 구성 |
|---|---|---|
| 합/교/차 | ✓ | 제품구성 + 수용조건 OR/AND/AND¬ |
| 여집합 | ✓ | 완전 DFA 보완(수용/비수용 반전) |
| 연접 | ✓ | ε-NFA: F(A)→q0(B) ε-전이 |
| Kleene-★ / + | ✓ | 새 시작/수용 + F→q0 ε |
| 역순 | ✓ | 간선 역전 + 새 시작→옛 F ε + 옛 q0 수용 |
| 접두/접미/부분문자열 | ✓ | co-reach(접두), multi-start(접미), 경로 기반(NFA) |
| Shuffle | ✓ | (p,q)에서 a를 A **또는** B가 소비 |
| 호모몰피즘 | ✓ | a→h(a) 경로 치환(ε-NFA) |
| 역호모몰피즘 | ✓ | 입력 a마다 내부에서 h(a) 시뮬(ε-NFA) |
| 좌/우 몫 | ✓ | 존재 정리(효과적 구성은 K가 주어질 때) |

---

## 7. 실무 팁 & 함정

- **보완 전 완전화**: 누락 전이 있으면 보완이 깨짐(sink 필요).  
- **제품구성 상태폭**: \(|Q_A||Q_B|\). 필요 시 **최소화(Hopcroft)**로 후처리.  
- **연접/별/역순**: 자연스레 **NFA**로 산출. DFA가 필요하면 subset-construction.  
- **역호모몰피즘**: 입력 기호가 **여러 문자**로 확장될 수 있음을 잊지 말 것(내부 시뮬).  
- **부분문자열/접미**: “도달 가능한 상태만” 초기 후보 — **비도달 상태**는 시작에서 출발 불가.  
- **증명과 구현 분리**: 폐포성은 “존재” 정리이고, “구성/계산 가능성”은 입력(언어 K 등)의 표현가능성/결정가능성과 별개.

---

## 8. 마무리

정규 언어는 합/교/차/여에서 시작해 연접·별·역순, 접두/접미/부분문자열, shuffle, (역)호모몰피즘, 몫에 이르기까지 **아주 폭넓은 연산에 닫혀** 있다.  
이 강력한 **폐포성** 덕분에, 복잡한 패턴도 **간단한 DFA/NFA 조각들을 합성**해 효율적으로 구축·검증할 수 있다.  
실전에서는 위 **합성기 함수들**(제품구성/보완/ε-전이 합성)을 표준 도구처럼 써서,  
- 원하는 연산을 **구성**하고,  
- 빠르게 **테스트**하고,  
- 필요 시 **최소화**해 배포 가능한 크기의 DFA로 정리하자.

> 핵심은 “**오토마타로 생각하기**”.  
> 연산을 **그래프 합성**으로 바꾸면, 정규 언어 설계가 놀랍도록 체계적이고 쉬워진다.