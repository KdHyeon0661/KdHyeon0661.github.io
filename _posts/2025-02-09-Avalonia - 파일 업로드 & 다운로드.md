---
layout: post
title: Avalonia - 파일 업로드 & 다운로드
date: 2025-02-09 21:20:23 +0900
category: Avalonia
---
# Avalonia에서 파일 업로드/다운로드 (HttpClient 연동)

## 0. 폴더 구조(확장 버전)

```
MyApp/
├── App.axaml / App.axaml.cs
├── Views/
│   └── FileTransferView.axaml / .cs
├── ViewModels/
│   └── FileTransferViewModel.cs
├── Services/
│   ├── IFileService.cs
│   ├── FileApiService.cs
│   ├── IFilePickerService.cs
│   ├── FilePickerService.cs
│   ├── IProgressSink.cs
│   └── BackoffPolicy.cs
└── Models/
    └── FileRecord.cs
```

> 차이점: **파일 다이얼로그를 서비스로 분리**(`IFilePickerService`)해 ViewModel이 `Window`를 몰라도 되도록 한다. 또한 진행률을 추상화하는 `IProgressSink`를 둔다.

---

## 1. 모델과 계약

### 1.1 업로드/다운로드 서버 계약(예시)

| 기능 | 엔드포인트 | 메서드 | 요청/응답 |
|---|---|---|---|
| 업로드 | `/api/files/upload` | `POST multipart/form-data` | `file`, `meta`(json) → `201 Created` + `id` |
| 다운로드 | `/api/files/{id}` | `GET` | 바이너리 스트림, `Content-Disposition` |

#### 서버 응답 JSON(업로드 결과 예)
```json
{ "id": 123, "name": "report.pdf", "size": 1048576, "sha256": "..." }
```

### 1.2 클라이언트 모델

```csharp
public sealed class FileRecord
{
    public int Id { get; init; }
    public string Name { get; init; } = string.Empty;
    public long Size { get; init; }
    public string? Sha256 { get; init; }
}
```

---

## 2. 인터페이스 설계

### 2.1 파일 서비스 (업/다운로드 + 진행률/취소)

```csharp
public interface IFileService
{
    // 단일 파일 업로드 (메타데이터 선택)
    Task<FileRecord> UploadAsync(
        string filePath,
        IDictionary<string, string>? metadata = null,
        IProgress<double>? progress = null,     // 0.0 ~ 100.0
        CancellationToken ct = default);

    // 다중 파일 업로드
    Task<IReadOnlyList<FileRecord>> UploadManyAsync(
        IReadOnlyList<string> filePaths,
        IDictionary<string, string>? commonMetadata = null,
        IProgress<(int index, double percent)>? progress = null,
        CancellationToken ct = default);

    // 파일 다운로드 (저장 경로 포함)
    Task DownloadAsync(
        int fileId,
        string savePath,
        IProgress<double>? progress = null,
        CancellationToken ct = default);

    // 파일 메타만 가져오기 (선택)
    Task<FileRecord?> GetInfoAsync(int fileId, CancellationToken ct = default);
}
```

### 2.2 파일 선택/저장 다이얼로그 서비스

```csharp
public interface IFilePickerService
{
    // 다중 선택 가능
    Task<string[]?> PickOpenAsync(
        string title,
        IEnumerable<(string Name, string[] Extensions)>? filters = null,
        bool allowMultiple = false);

    Task<string?> PickSaveAsync(
        string title,
        string suggestedFileName,
        IEnumerable<(string Name, string[] Extensions)>? filters = null);
}
```

> ViewModel은 이 서비스를 사용하므로 Avalonia의 `OpenFileDialog`, `SaveFileDialog`를 몰라도 된다.

### 2.3 진행률 싱크(옵션, UI 바인딩 보조)

```csharp
public interface IProgressSink
{
    void SetIndeterminate(bool on);
    void ReportPercent(double value); // 0~100
    void SetStatus(string message);
}
```

---

## 3. 구현 — 파일 선택/저장 다이얼로그

```csharp
public sealed class FilePickerService : IFilePickerService
{
    private static Window GetOwner()
    {
        var life = (IClassicDesktopStyleApplicationLifetime)Application.Current!.ApplicationLifetime!;
        return life.MainWindow!;
    }

    public async Task<string[]?> PickOpenAsync(
        string title,
        IEnumerable<(string Name, string[] Extensions)>? filters = null,
        bool allowMultiple = false)
    {
        var dlg = new OpenFileDialog { Title = title, AllowMultiple = allowMultiple };
        if (filters is not null)
        {
            dlg.Filters = filters.Select(f => new FileDialogFilter
            {
                Name = f.Name,
                Extensions = f.Extensions.ToList()
            }).ToList();
        }
        return await dlg.ShowAsync(GetOwner());
    }

    public async Task<string?> PickSaveAsync(
        string title,
        string suggestedFileName,
        IEnumerable<(string Name, string[] Extensions)>? filters = null)
    {
        var dlg = new SaveFileDialog
        {
            Title = title,
            InitialFileName = suggestedFileName
        };
        if (filters is not null)
        {
            dlg.Filters = filters.Select(f => new FileDialogFilter
            {
                Name = f.Name,
                Extensions = f.Extensions.ToList()
            }).ToList();
        }
        return await dlg.ShowAsync(GetOwner());
    }
}
```

---

## 4. 구현 — 백오프/재시도 정책

대역/서버 일시 오류를 위해 단순 **지수 백오프**를 제공한다.

```csharp
public static class BackoffPolicy
{
    public static async Task RunAsync(
        Func<Task> action,
        int maxRetries = 3,
        TimeSpan? initialDelay = null,
        Func<Exception, bool>? isTransient = null,
        CancellationToken ct = default)
    {
        initialDelay ??= TimeSpan.FromMilliseconds(300);
        isTransient ??= (ex => ex is HttpRequestException or IOException or TaskCanceledException);

        var delay = initialDelay.Value;

        for (int attempt = 0; ; attempt++)
        {
            ct.ThrowIfCancellationRequested();
            try
            {
                await action();
                return;
            }
            catch (Exception ex) when (attempt < maxRetries && isTransient(ex))
            {
                await Task.Delay(delay, ct);
                delay = TimeSpan.FromMilliseconds(Math.Min(delay.TotalMilliseconds * 2, 5000));
            }
        }
    }
}
```

---

## 5. 구현 — FileApiService (핵심)

- 업로드: `MultipartFormDataContent`, 스트림 업로드, 진행률 계산
- 다운로드: `HttpCompletionOption.ResponseHeadersRead`로 **스트리밍**
- 진행률: 총 바이트 기준, `IProgress<double>` 보고
- 취소: `CancellationToken` 전파
- 재시도: `BackoffPolicy` 사용

```csharp
public sealed class FileApiService : IFileService
{
    private readonly HttpClient _http;

    public FileApiService(HttpClient http) => _http = http;

    public async Task<FileRecord?> GetInfoAsync(int fileId, CancellationToken ct = default)
    {
        using var req = new HttpRequestMessage(HttpMethod.Get, $"/api/files/{fileId}/meta");
        using var res = await _http.SendAsync(req, ct);
        if (!res.IsSuccessStatusCode) return null;
        var json = await res.Content.ReadAsStringAsync(ct);
        return System.Text.Json.JsonSerializer.Deserialize<FileRecord>(json);
    }

    public async Task<FileRecord> UploadAsync(
        string filePath,
        IDictionary<string, string>? metadata = null,
        IProgress<double>? progress = null,
        CancellationToken ct = default)
    {
        if (!File.Exists(filePath))
            throw new FileNotFoundException(filePath);

        var fileName = Path.GetFileName(filePath);
        var fileLength = new FileInfo(filePath).Length;

        // 스트리밍 콘텐츠에 진행률 래퍼 적용
        using var fs = File.OpenRead(filePath);
        using var streamContent = new ProgressStreamContent(fs, 81920, bytes =>
        {
            if (fileLength > 0 && progress is not null)
            {
                var pct = (double)bytes / fileLength * 100.0;
                progress.Report(Math.Min(100.0, pct));
            }
        });

        // Content-Type은 서버 정책에 맞추되, 일반 파일은 application/octet-stream
        streamContent.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");
        streamContent.Headers.ContentDisposition = new ContentDispositionHeaderValue("form-data")
        {
            Name = "\"file\"",
            FileName = "\"" + fileName + "\""
        };

        using var multi = new MultipartFormDataContent();
        multi.Add(streamContent, "file", fileName);

        if (metadata is not null && metadata.Count > 0)
        {
            var metaJson = System.Text.Json.JsonSerializer.Serialize(metadata);
            multi.Add(new StringContent(metaJson, Encoding.UTF8, "application/json"), "meta");
        }

        FileRecord? result = null;

        await BackoffPolicy.RunAsync(async () =>
        {
            using var req = new HttpRequestMessage(HttpMethod.Post, "/api/files/upload") { Content = multi };
            using var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct);
            res.EnsureSuccessStatusCode();

            var json = await res.Content.ReadAsStringAsync(ct);
            result = System.Text.Json.JsonSerializer.Deserialize<FileRecord>(json)
                     ?? throw new InvalidOperationException("Invalid server response");
        }, ct: ct);

        progress?.Report(100.0);
        return result!;
    }

    public async Task<IReadOnlyList<FileRecord>> UploadManyAsync(
        IReadOnlyList<string> filePaths,
        IDictionary<string, string>? commonMetadata = null,
        IProgress<(int index, double percent)>? progress = null,
        CancellationToken ct = default)
    {
        var list = new List<FileRecord>(filePaths.Count);

        for (int i = 0; i < filePaths.Count; i++)
        {
            var index = i;
            var eachProgress = new Progress<double>(p => progress?.Report((index, p)));
            var record = await UploadAsync(filePaths[i], commonMetadata, eachProgress, ct);
            list.Add(record);
        }
        return list;
    }

    public async Task DownloadAsync(
        int fileId,
        string savePath,
        IProgress<double>? progress = null,
        CancellationToken ct = default)
    {
        Directory.CreateDirectory(Path.GetDirectoryName(savePath)!);
        var tempPath = savePath + ".partial";

        await BackoffPolicy.RunAsync(async () =>
        {
            using var req = new HttpRequestMessage(HttpMethod.Get, $"/api/files/download/{fileId}");
            using var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct);
            res.EnsureSuccessStatusCode();

            var contentLength = res.Content.Headers.ContentLength ?? -1L;

            await using var src = await res.Content.ReadAsStreamAsync(ct);
            await using var dst = new FileStream(tempPath, FileMode.Create, FileAccess.Write, FileShare.None, 81920, useAsync: true);

            var buffer = new byte[81920];
            long total = 0;
            int read;
            while ((read = await src.ReadAsync(buffer.AsMemory(0, buffer.Length), ct)) > 0)
            {
                await dst.WriteAsync(buffer.AsMemory(0, read), ct);
                total += read;

                if (contentLength > 0 && progress is not null)
                {
                    var pct = total * 100.0 / contentLength;
                    progress.Report(Math.Min(100.0, pct));
                }
            }
        }, ct: ct);

        // 원자적 교체
        if (File.Exists(savePath)) File.Delete(savePath);
        File.Move(tempPath, savePath);
        progress?.Report(100.0);
    }
}
```

#### 진행률 래퍼 `ProgressStreamContent`
```csharp
public sealed class ProgressStreamContent : HttpContent
{
    private readonly Stream _stream;
    private readonly int _bufferSize;
    private readonly Action<long> _onProgress;
    private long _sent;

    public ProgressStreamContent(Stream stream, int bufferSize, Action<long> onProgress)
    {
        _stream = stream;
        _bufferSize = bufferSize;
        _onProgress = onProgress;
        Headers.ContentLength = stream.CanSeek ? stream.Length : null;
    }

    protected override async Task SerializeToStreamAsync(Stream stream, TransportContext? context)
    {
        var buffer = new byte[_bufferSize];
        int read;
        while ((read = await _stream.ReadAsync(buffer.AsMemory(0, _bufferSize))) > 0)
        {
            await stream.WriteAsync(buffer.AsMemory(0, read));
            _sent += read;
            _onProgress(_sent);
        }
    }

    protected override bool TryComputeLength(out long length)
    {
        if (_stream.CanSeek)
        {
            length = _stream.Length;
            return true;
        }
        length = -1;
        return false;
    }
}
```

> 핵심 최적화: `ResponseHeadersRead`로 **다운로드 전체가 끝날 때까지 메모리에 적재하지 않고** 스트림 복사. 업로드는 `StreamContent`에 **진행률 래퍼** 적용.

---

## 6. ViewModel — UI 바인딩/진행률/취소

- ViewModel은 **서비스**만 주입받는다.
- 파일 다이얼로그는 `IFilePickerService`.
- 취소는 `CancellationTokenSource`.
- 진행률은 `Progress<double>`.

```csharp
public sealed class FileTransferViewModel : ReactiveObject
{
    private readonly IFileService _files;
    private readonly IFilePickerService _picker;

    public FileTransferViewModel(IFileService files, IFilePickerService picker)
    {
        _files = files;
        _picker = picker;

        UploadCommand = ReactiveCommand.CreateFromTask(UploadAsync);
        UploadManyCommand = ReactiveCommand.CreateFromTask(UploadManyAsync);
        DownloadCommand = ReactiveCommand.CreateFromTask(DownloadAsync);
        CancelCommand = ReactiveCommand.Create(Cancel);
    }

    private CancellationTokenSource? _cts;

    private double _progress;
    public double ProgressPercent
    {
        get => _progress;
        private set => this.RaiseAndSetIfChanged(ref _progress, value);
    }

    private string _status = "";
    public string StatusMessage
    {
        get => _status;
        private set => this.RaiseAndSetIfChanged(ref _status, value);
    }

    public ReactiveCommand<Unit, Unit> UploadCommand { get; }
    public ReactiveCommand<Unit, Unit> UploadManyCommand { get; }
    public ReactiveCommand<Unit, Unit> DownloadCommand { get; }
    public ReactiveCommand<Unit, Unit> CancelCommand { get; }

    private async Task UploadAsync()
    {
        var files = await _picker.PickOpenAsync(
            title: "업로드할 파일 선택",
            filters: new[] { ("모든 파일", new[] { "*" }) },
            allowMultiple: false);

        if (files is null || files.Length == 0) return;

        _cts = new CancellationTokenSource();
        ProgressPercent = 0;
        StatusMessage = "업로드 시작";

        try
        {
            var prog = new Progress<double>(p => ProgressPercent = p);
            var meta = new Dictionary<string, string> { ["uploader"] = Environment.UserName };
            var rec = await _files.UploadAsync(files[0], meta, prog, _cts.Token);
            StatusMessage = $"업로드 성공: #{rec.Id} {rec.Name}";
        }
        catch (OperationCanceledException)
        {
            StatusMessage = "업로드 취소됨";
        }
        catch (Exception ex)
        {
            StatusMessage = $"업로드 실패: {ex.Message}";
        }
        finally
        {
            _cts = null;
        }
    }

    private async Task UploadManyAsync()
    {
        var files = await _picker.PickOpenAsync(
            "여러 파일 업로드",
            new[] { ("이미지", new[] { "png", "jpg", "jpeg", "gif" }), ("모든 파일", new[] { "*" }) },
            allowMultiple: true);

        if (files is null || files.Length == 0) return;

        _cts = new CancellationTokenSource();
        ProgressPercent = 0;
        StatusMessage = "다중 업로드 시작";

        try
        {
            var prog = new Progress<(int index, double percent)>(p =>
            {
                // 전체 진행률(평균)으로 단순 집계
                ProgressPercent = (p.index + p.percent / 100.0) * 100.0 / files.Length;
            });

            var recs = await _files.UploadManyAsync(files, null, prog, _cts.Token);
            StatusMessage = $"업로드 완료: {recs.Count}개";
        }
        catch (OperationCanceledException)
        {
            StatusMessage = "다중 업로드 취소됨";
        }
        catch (Exception ex)
        {
            StatusMessage = $"다중 업로드 실패: {ex.Message}";
        }
        finally
        {
            _cts = null;
        }
    }

    private async Task DownloadAsync()
    {
        // 예시: 사용자에게 파일 ID를 받는 UI가 따로 있다고 가정
        int fileId = 1;

        var save = await _picker.PickSaveAsync(
            "저장 위치 선택",
            suggestedFileName: "downloaded.bin",
            filters: new[] { ("모든 파일", new[] { "*" }) });

        if (string.IsNullOrWhiteSpace(save)) return;

        _cts = new CancellationTokenSource();
        ProgressPercent = 0;
        StatusMessage = "다운로드 시작";

        try
        {
            var prog = new Progress<double>(p => ProgressPercent = p);
            await _files.DownloadAsync(fileId, save, prog, _cts.Token);
            StatusMessage = "다운로드 완료";
        }
        catch (OperationCanceledException)
        {
            StatusMessage = "다운로드 취소됨";
        }
        catch (Exception ex)
        {
            StatusMessage = $"다운로드 실패: {ex.Message}";
        }
        finally
        {
            _cts = null;
        }
    }

    private void Cancel()
    {
        _cts?.Cancel();
    }
}
```

---

## 7. View — 간단 UI

### Views/FileTransferView.axaml
```xml
<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="MyApp.Views.FileTransferView"
             xmlns:d="https://github.com/avaloniaui"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d">
  <StackPanel Margin="20" Spacing="10">
    <TextBlock Text="파일 업/다운로드" FontSize="20"/>
    <StackPanel Orientation="Horizontal" Spacing="8">
      <Button Content="업로드" Command="{Binding UploadCommand}"/>
      <Button Content="여러 파일 업로드" Command="{Binding UploadManyCommand}"/>
      <Button Content="다운로드" Command="{Binding DownloadCommand}"/>
      <Button Content="취소" Command="{Binding CancelCommand}"/>
    </StackPanel>

    <ProgressBar Minimum="0" Maximum="100" Value="{Binding ProgressPercent}" Height="12"/>
    <TextBlock Text="{Binding ProgressPercent, StringFormat='진행률: {0:F1}%'}"/>
    <TextBlock Text="{Binding StatusMessage}" />
  </StackPanel>
</UserControl>
```

> 필요 시 `IsIndeterminate="True"`를 토글할 수 있도록 `IProgressSink.SetIndeterminate()`를 활용하면 된다.

---

## 8. DI 등록

```csharp
private void ConfigureServices(IServiceCollection services)
{
    // 인증/로깅 핸들러가 있다면 DelegatingHandler 체인으로 추가
    services.AddSingleton(new HttpClient
    {
        BaseAddress = new Uri("https://api.example.com"),
        Timeout = TimeSpan.FromMinutes(10)
    });

    services.AddSingleton<IFileService, FileApiService>();
    services.AddSingleton<IFilePickerService, FilePickerService>();

    services.AddTransient<FileTransferViewModel>();
}
```

---

## 9. 보안/안전성 체크리스트

| 항목 | 설명 |
|---|---|
| 저장 경로 검증 | 사용자 입력 경로에 대해 **상대경로/루트 이탈 방지**. 저장 전 `Path.GetFullPath`로 검증. |
| 덮어쓰기 방지 | 기존 파일 존재 시 `.partial`로 임시 저장, 완료 후 `Move`로 원자적 교체. |
| 임시 파일 정리 | 실패/취소 시 `.partial` 삭제(try/catch). |
| MIME/확장자 | 서버/클라이언트 양쪽에서 허용 목록 지정, `Content-Type` 검증. |
| 사이즈 제한 | 너무 큰 파일 업로드 차단(서버 계약 확인), 클라이언트도 사전 검사. |
| 토큰/권한 | `Authorization: Bearer` 헤더; 만료/401 시 재인증 흐름. |
| 네트워크 장애 | 재시도 백오프 정책; 사용자에게 명확한 에러 메시지. |
| 바이러스 검사 | 업로드 직후 서버에서 검사(클라이언트 알림 처리). |
| 경합/동시성 | 동일 파일 동시에 다운로드 시 중복 처리 방지 키/락(앱 수준). |

---

## 10. 이어받기(Resume) 스케치

**아이디어**: 서버가 `Range` 요청과 `ETag`/`If-Range`를 지원한다면 다음과 같이 구현한다.

- 다운로드 중단 시 `savePath.partial` 길이를 확인 → `Range: bytes={length}-`로 재요청
- 응답 `206 Partial Content` 수신 시 이어 쓰기
- `ETag`가 바뀌면 새 파일로 다시 받기

```csharp
// 개략 예시
var existing = new FileInfo(tempPath);
long start = existing.Exists ? existing.Length : 0;

var req = new HttpRequestMessage(HttpMethod.Get, $"/api/files/download/{id}");
if (start > 0)
    req.Headers.Range = new RangeHeaderValue(start, null);

var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct);
if (res.StatusCode == HttpStatusCode.OK && start > 0)
{
    // 서버가 Range를 무시했다면 전체를 다시 받아야 함.
    existing.Delete();
}
// 이후 스트림 복사 로직은 위와 동일
```

> 이어받기는 **서버 지원**이 필수이므로 API 계약을 반드시 확인한다.

---

## 11. 드래그 앤 드롭 확장(개요)

- View에서 `DragDrop.AllowDrop="True"`, `AddHandler(DragDrop.DropEvent, ...)`
- `IDataObject`에서 파일 경로 추출 → `UploadManyAsync` 호출
- ViewModel로 이벤트를 전달하려면 **Behavior/Interaction** 또는 **이벤트 중개 서비스** 사용

```csharp
// code-behind 예시(간단)
private async void OnDrop(object? sender, DragEventArgs e)
{
    if (e.Data.Contains(DataFormats.FileNames))
    {
        var files = e.Data.GetFileNames()?.ToArray();
        if (DataContext is FileTransferViewModel vm && files?.Length > 0)
        {
            // vm.ExportedUploadMany(files) 같은 커맨드 노출로 연결
        }
    }
}
```

---

## 12. 테스트 전략

### 12.1 HttpClient 목킹 — `HttpMessageHandler`

```csharp
public sealed class FakeHandler : HttpMessageHandler
{
    private readonly Func<HttpRequestMessage, HttpResponseMessage> _responder;

    public FakeHandler(Func<HttpRequestMessage, HttpResponseMessage> responder)
    {
        _responder = responder;
    }

    protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        => Task.FromResult(_responder(request));
}
```

```csharp
// 업로드 응답 목킹
var handler = new FakeHandler(req =>
{
    if (req.RequestUri!.AbsolutePath == "/api/files/upload" && req.Method == HttpMethod.Post)
    {
        var json = "{\"id\":42,\"name\":\"x.bin\",\"size\":100}";
        return new HttpResponseMessage(HttpStatusCode.Created)
        {
            Content = new StringContent(json, Encoding.UTF8, "application/json")
        };
    }
    return new HttpResponseMessage(HttpStatusCode.NotFound);
});
var http = new HttpClient(handler) { BaseAddress = new Uri("https://fake") };

var svc = new FileApiService(http);
var rec = await svc.UploadAsync("test.bin", null, null, CancellationToken.None); // test.bin은 테스트에서 임시 파일 생성
```

### 12.2 ViewModel 테스트

- `IFilePickerService` 목 → 경로 반환
- `IFileService` 목 → 성공/실패/취소 시나리오
- `Progress<double>` 캡처하여 진행률 변화를 검증

```csharp
var picker = new Mock<IFilePickerService>();
picker.Setup(p => p.PickOpenAsync(It.IsAny<string>(), It.IsAny<IEnumerable<(string, string[])>>(), false))
      .ReturnsAsync(new[] { "C:\\tmp\\a.txt" });

var files = new Mock<IFileService>();
files.Setup(s => s.UploadAsync("C:\\tmp\\a.txt", It.IsAny<IDictionary<string, string>>(), It.IsAny<IProgress<double>>(), It.IsAny<CancellationToken>()))
     .ReturnsAsync(new FileRecord { Id = 1, Name = "a.txt", Size = 10 });

var vm = new FileTransferViewModel(files.Object, picker.Object);
await vm.UploadCommand.Execute();

vm.StatusMessage.Should().Contain("업로드 성공");
```

---

## 13. 서버 예시(참고: .NET Minimal API)

```csharp
var app = WebApplication.Create();

app.MapPost("/api/files/upload", async (HttpRequest req) =>
{
    if (!req.HasFormContentType) return Results.BadRequest();

    var form = await req.ReadFormAsync();
    var file = form.Files.GetFile("file");
    if (file is null) return Results.BadRequest();

    var metaJson = form["meta"].FirstOrDefault();
    var meta = metaJson is null ? null :
        System.Text.Json.JsonSerializer.Deserialize<Dictionary<string,string>>(metaJson);

    var savePath = Path.Combine("uploads", Path.GetFileName(file.FileName));
    Directory.CreateDirectory("uploads");
    await using (var fs = File.Create(savePath))
        await file.CopyToAsync(fs);

    var rec = new FileRecord { Id = Random.Shared.Next(1, 100000), Name = file.FileName, Size = file.Length };
    return Results.Created($"/api/files/{rec.Id}", rec);
});

app.MapGet("/api/files/download/{id:int}", (int id) =>
{
    // 데모: 고정 파일
    var path = Path.Combine("uploads", "demo.bin");
    if (!System.IO.File.Exists(path)) return Results.NotFound();

    return Results.File(path, "application/octet-stream", fileDownloadName: "demo.bin");
});

app.Run();
```

---

## 14. 트러블슈팅

| 증상 | 원인/대응 |
|---|---|
| 업로드시 `TaskCanceledException` | 네트워크/서버 타임아웃 → `HttpClient.Timeout` 증가 또는 `CancellationToken` 오남용 확인 |
| 대용량 다운로드 속도 저하 | `HttpCompletionOption.ResponseContentRead` 사용 중인지 확인, 스트림 버퍼 80KB 이상 |
| 서버가 `413 Payload Too Large` | 서버 업로드 제한 → 서버 설정 수정 또는 클라이언트 사이즈 제한/분할 업로드 |
| 파일이 손상됨 | 텍스트 인코딩으로 전송(문자열 컨텐츠)했는지 확인, 바이너리는 반드시 스트림/바이트 기반 |
| 덮어쓰기 문제 | `.partial` → `Move` 패턴 준수, 예외 시 롤백 처리 |

---

## 15. 요약

| 항목 | 권장 구현 |
|---|---|
| 구조 | `IFileService`로 네트워크/파일 I/O 캡슐화, `IFilePickerService`로 다이얼로그 분리 |
| 업로드 | `MultipartFormDataContent` + 진행률 스트리밍 |
| 다운로드 | `ResponseHeadersRead` + 스트림 복사 + 임시 파일 원자 교체 |
| 신뢰성 | 백오프 재시도, 취소 토큰, 명확한 상태 메시지 |
| 보안 | 경로 검증, 덮어쓰기 방지, MIME/사이즈 제한, 토큰 인증 |
| 확장 | 다중 업/다운로드, 이어받기, 드래그앤드롭, 대역폭 제어 |

이 설계를 적용하면 Avalonia MVVM 환경에서 **테스트가 용이하고**, **대용량에도 안전하며**, **사용자 경험(진행률/취소/에러 메시지)**을 갖춘 파일 전송 기능을 일관성 있게 제공할 수 있다.