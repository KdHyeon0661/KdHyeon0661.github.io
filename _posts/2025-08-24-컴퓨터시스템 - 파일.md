---
layout: post
title: 컴퓨터시스템 - 파일
date: 2025-08-24 21:20:23 +0900
category: 컴퓨터시스템
---
# 파일에 대해 — 컴퓨터 시스템 관점의 상세 정리

> **핵심 관점**
> - 유닉스/리눅스에서 **파일 = 바이트 시퀀스 + 메타데이터(inode)**, 이름은 디렉터리의 **엔트리(entry)**.
> - 커널은 **VFS(가상 파일 시스템)** 위에 여러 파일시스템(ext4, XFS, btrfs …)과 **특수 파일**(장치/파이프/소켓)을 통일적으로 다룬다.
> - 사용자 공간은 **FD(파일 디스크립터)** 로 열린 파일을 식별하고, **시스템 콜**(open/close/read/write/…​)로 I/O를 수행한다.
> - 성능·일관성은 **페이지 캐시**·재전송·저널링·writeback 정책과 깊이 관련된다.

---

## 1. 모델과 정의: “Everything is a file”

### 1.1 파일의 논리 모델
- **바이트의 순차 나열**: 0-기반 오프셋을 갖는 바이트 스트림.
- **임의 접근**: `lseek` 으로 파일 오프셋을 움직여 임의 위치 I/O.
- **타입은 내용이 아니라 해석**: 이미지/실행파일 여부는 내용(매직, 포맷)과 해석자(라이브러리/커널 로더)에 달림.

### 1.2 VFS 계층(요지)
```
User space (open/read/write/…)
          │
          ▼
VFS ──► dentry(이름 캐시) ─ inode(메타데이터) ─ superblock(파일시스템)
          │
          ▼
구현체(ext4, XFS, btrfs, tmpfs, procfs, sysfs, NFS, fuse, …)
```

---

## 2. 파일의 종류(유닉스 계열)

| 종류 | 의미/용도 | 비고/예시 |
|---|---|---|
| **일반 파일** (regular) | 텍스트/바이너리 데이터 | `/etc/passwd`, ELF 실행 파일 |
| **디렉터리** | 이름→inode 매핑 테이블 | `.`/`..` 포함, `readdir` 로 열거 |
| **심볼릭 링크** (symlink) | 경로 문자열을 가리키는 특수 파일 | 경로 해석 시 따라감, inode는 별도 |
| **하드 링크** | *같은* inode에 **여러 이름** | 동일 파일, 링크 수 증가 |
| **블록/문자 장치** | 커널 드라이버 인터페이스 | `/dev/sda`(block), `/dev/tty`(char) |
| **파이프/FIFO** | 단방향 IPC 스트림 | `mkfifo`, 크기 제한·커널 버퍼 |
| **소켓** | 네트워크/로컬 IPC | `/var/run/docker.sock` |
| **가상 FS 엔트리** | 커널/프로세스 상태 노출 | `/proc`, `/sys`, `tmpfs` |

> **하드링크 제약**: 서로 **다른 파일시스템** 간에는 불가, 디렉터리에는 제한.

---

## 3. 이름과 inode: 경로 해석과 캐시

### 3.1 디렉터리 엔트리와 inode
- **inode**: 파일의 *실체* 메타데이터(크기, 권한, 타임스탬프, 데이터 블록 포인터…).
- **디렉터리**: `이름(name) → inode 번호`의 테이블. **이름은 파일이 아니다.**
- **하드링크**: 새 이름을 같은 inode에 추가 → **링크 수(Links)** 증가.
- **심볼릭 링크**: *문자열 경로*를 저장하는 별도 inode. 해석 시 대상 경로로 전개.

### 3.2 경로 해석(namei)와 dentry 캐시
- 경로 요소를 한 단계씩 해석(`a/b/c`)하며 **dentry cache**(이름→inode 캐시) 사용.
- **mount point**: 경로 해석 중 다른 superblock로 전환되는 지점.

---

## 4. 메타데이터(stat/statx): 시간/권한/확장 속성

### 4.1 `stat` 필수 필드
- **mode**(파일 타입 + 퍼미션), **uid/gid**, **size**, **nlink**, **inode**(번호), **blksize**, **blocks**.
- 시간 3종: **atime(접근)**, **mtime(내용 변경)**, **ctime(inode 변경/권한/링크수/소유자 변경)**.
  - 최신 커널에선 `statx`로 **나노초 정밀도**·**birthtime**(생성시간, 파일시스템 의존) 조회.

### 4.2 atime 정책
- 마운트 옵션: `relatime`(기본), `noatime`, `strictatime`.
  - `relatime`: mtime/ctime이 더 최근이거나 하루 1회만 atime 갱신 → 오버헤드↓.

### 4.3 권한/umask/특수 비트
- 3원 집합: **소유자/그룹/기타** × **r/w/x**.
- **umask**: 생성 권한에서 **빼는 마스크**.
  $$\text{final\_mode} = \text{requested\_mode} \;\&\; \sim\text{umask}$$
- **setuid/setgid**: 실행 시 유효 UID/GID 승격.
- **sticky bit(디렉터리)**: `/tmp` 처럼 **소유자만 삭제 가능**.

### 4.4 ACL / xattr / capabilities
- **POSIX ACL**: 세밀한 주체별 권한. `getfacl/setfacl`.
- **확장 속성(xattr)**: `user.*`, `security.*` 등 키-값 메타. `getfattr/setfattr`.
- **파일 capabilities**: 루트 없이 특정 권한 부여. `setcap/getcap`.

---

## 5. FD와 커널의 “3단 테이블” 구조

### 5.1 3단 구조
1. **프로세스별 FD 테이블**: 작은 정수 FD → **open file** 엔트리 포인터.
2. **시스템 범위 open file 엔트리(`struct file`)**: **파일 오프셋, 플래그(O_APPEND …)**.
3. **inode/vnode**: 메타데이터·연결된 파일시스템 연산 테이블.

> **복제된 FD(dup)** 는 **같은 open file 엔트리**를 공유 → **오프셋 공유** 주의.

### 5.2 FD 조작
- `dup/dup2/dup3`(원자적), `fcntl(F_DUPFD, F_DUPFD_CLOEXEC)`
- **close-on-exec**: `FD_CLOEXEC` / `O_CLOEXEC` 로 서브프로세스 FD 누출 방지.
- **비차단**: `O_NONBLOCK` + `EAGAIN` 처리.
- **append**: `O_APPEND`는 커널이 **끝에서 원자적 쓰기** 보장.

---

## 6. 핵심 시스템 콜: 안전 패턴과 최신 API

### 6.1 `open` 계열
- `open`, **`openat`**, **`openat2`(Linux ≥ 5.6)**: 디렉터리 FD 기준으로 경로 해석(TOCTOU 회피),
  `RESOLVE_NO_SYMLINKS` 등 **보안 플래그**로 안전한 열기.

### 6.2 `read`/`write`와 부분 I/O
- **부분 I/O** 가능(특히 파이프/소켓/비차단) → 루프 필수.
- 시그널로 **EINTR** 발생 → 재시도 필요.

```c
ssize_t safe_read(int fd, void *buf, size_t n){
    for(;;){
        ssize_t r = read(fd, buf, n);
        if (r >= 0) return r;
        if (errno == EINTR) continue;
        return -1;
    }
}
```

### 6.3 `pread/pwrite`
- 오프셋 인자를 받는 **원자적** 단일 I/O(파일 오프셋 공유 문제 회피).

### 6.4 동기화·내구성
- `fsync`(데이터+메타), `fdatasync`(데이터 위주), `sync_file_range`(상황 의존).
- 파일 교체 패턴: **`rename`은 같은 FS 내에서 원자적** → `fsync(tmp) → fsync(dir) → rename`.

### 6.5 대용량·커널 오프로드
- `sendfile`(파일→소켓, zero-copy), `splice/tee/vmsplice`(파이프 기반 zero-copy),
- `copy_file_range`(커널 내부 복사·하드웨어 offload 가능),
- `fallocate`(공간 예약, **punch hole**/`FALLOC_FL_PUNCH_HOLE`), `posix_fadvise`/`readahead`.

### 6.6 메모리 매핑
- `mmap/munmap/msync/mprotect/madvise`: 페이지 캐시를 경유한 메모리형 I/O.
- `MAP_SHARED` 쓰기 ↔ `write()` 혼용 시 **일관성 규칙** 숙지(동시 접근 주의).

---

## 7. 디렉터리 I/O와 경로 무결성

### 7.1 나열/탐색
- C 표준: `opendir/readdir/closedir`. 커널 인터페이스: `getdents64`.
- 항목의 `d_type`(파일 종류) 활용(단, 모든 FS가 채우는 건 아님).

### 7.2 race-free 조작: *at 패밀리*
- `openat/renameat2/linkat/unlinkat/fchmodat/fchownat` …
- 기준 디렉터리 FD(`dirfd`)로 **TOCTOU** 위험을 줄임.
- `renameat2`의 **`RENAME_NOREPLACE`**, **`RENAME_EXCHANGE`** 등 유용.

### 7.3 안전 임시파일
- **`O_TMPFILE`**(디렉터리에 익명 생성 후 `linkat`로 이름 부여) 또는 `mkstemp` 사용.
- `mktemp`는 **취약**.

---

## 8. 링크의 실제 의미

| 항목 | 하드 링크 | 심볼릭 링크 |
|---|---|---|
| 대상 | 같은 inode(동일 파일) | 경로 문자열 |
| 파일시스템 경계 | 불가 | 가능 |
| 대상 삭제 영향 | 링크 수 0이 되면 제거 | 대상 없어지면 **dangling** |
| 권한/소유자 | 대상 inode의 것 | 링크 자체의 권한은 의미 제한 |

예시(하드링크 수 확인):

```bash
$ ln file A
$ ln file B
$ ls -li file A B
# 같은 inode 번호, nlink=3
```

---

## 9. 파이프/FIFO/소켓/특수 파일

- **파이프**: 커널 버퍼 기반 **익명** 스트림(`pipe()`), FD 페어 생성.
- **FIFO**: 경로가 있는 파이프(`mkfifo`), 프로세스 간 독립 생명주기.
- **소켓**: 네트워크 또는 `AF_UNIX` 로컬 통신.
- **장치 노드**: `mknod`로 major/minor 바인딩 → 드라이버로 연결.
- **특수 파일**: `/dev/null`, `/dev/zero`, `/dev/random`/`urandom`.

---

## 10. 파일 잠금: fcntl vs flock

| 항목 | `fcntl`(POSIX) | `flock`(BSD 계열) |
|---|---|---|
| 종류 | 바이트 범위 잠금 | 파일 단위 잠금 |
| 상호운용 | NFS 등에서 제약/구현 상이 | 네트워크 FS에서 동작 보장 X |
| 잠금 성격 | **Advisory**(합의 기반) | **Advisory** |

- `F_SETLK/F_SETLKW`(논블록/블록), `F_WRLCK/F_RDLCK/F_UNLCK`.
- **데드락** 위험 → 잠금 순서 일관, 타임아웃 설계.

```c
int lock_exclusive(int fd){
    struct flock lk = {.l_type=F_WRLCK,.l_whence=SEEK_SET,.l_start=0,.l_len=0};
    return fcntl(fd, F_SETLKW, &lk);
}
```

---

## 11. 스파스 파일과 할당

- **스파스**: 쓰지 않은 영역은 **디스크 블록 미할당**(논리 크기 ≠ 물리 사용량).
- **관찰**: `ls -l` 크기 vs `du -h` 차이.
- **구멍 탐색**: `lseek(fd, off, SEEK_HOLE/SEEK_DATA)`.

스파스 파일 생성·홀 펀치:

```c
int fd = open("sparse.img", O_WRONLY|O_CREAT, 0644);
off_t gb = (off_t)1<<30;                      // 1 GiB 논리 크기
lseek(fd, gb-1, SEEK_SET); write(fd, "", 1);  // 희소 확장
// 구간 비우기(할당 해제)
fallocate(fd, FALLOC_FL_PUNCH_HOLE|FALLOC_FL_KEEP_SIZE, 128<<20, 64<<20);
close(fd);
```

---

## 12. 페이지 캐시·writeback·내구성

### 12.1 단일 캐시 모델
- 리눅스는 **버퍼 캐시 + 페이지 캐시 통합**.
- `read()`/`mmap()`는 **페이지 캐시**를 경유. `write()`는 **dirty 페이지** 형성 → **writeback** 스레드가 비동기로 flush.

### 12.2 저널링(ext4 예)
- 모드: `data=ordered`(기본, 메타 저널링 + 데이터 순서화), `writeback`, `journal`(데이터까지 저널).
- **rename 원자성**: 같은 파일시스템 내에서 **원자적 교체**. 내구성은 **fsync** 순서에 좌우.

### 12.3 동기 옵션
- `O_SYNC`(메타 포함), `O_DSYNC`(데이터 중심).
- `barrier`/`cache flush`는 저장장치의 **전원 장애 내구성**을 좌우.

---

## 13. 표준 I/O vs UNIX I/O

| 항목 | UNIX I/O (`read/write`) | 표준 I/O (`fread/fwrite`) |
|---|---|---|
| 버퍼링 | 없음(커널 경유만) | 유저 공간 버퍼(라인/블록/비버퍼링 설정 가능) |
| 제어 | 세밀(플래그, O_DIRECT 등) | 고수준(포맷, 스트림) |
| 성능 | 소량 I/O 비효율적 | 대체로 효율적(버퍼 덕분) |
| 혼용 | 가능(주의) | 같은 FD를 **동시에** 혼용 금지(버퍼 교란) |

---

## 14. 보안·안전 코딩 포인트

- **경로 순회 공격**: `openat2` + `RESOLVE_NO_SYMLINKS`/`BENEATH`로 차단.
- **FD 누출**: `O_CLOEXEC` 또는 `FD_CLOEXEC`.
- **임시파일**: `O_TMPFILE`/`mkstemp`만 사용.
- **권한 최소화**: ACL/Capabilities로 필요한 권한만.
- **O_NOFOLLOW**: 링크 우회 방지.
- **정규화**: 로케일/UTF-8·NFC vs NFD(맥) 차이 고려(파일명 비교·정렬).

---

## 15. 실전 예제 모음

### 15.1 안전한 파일 복사(커널 오프로드 우선, 폴백 포함)

```c
// copy.c : copy_file_range → sendfile → read/write 루프 폴백
#define _GNU_SOURCE
#include <sys/sendfile.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static ssize_t xcopyfr(int in, loff_t *off_in, int out, loff_t *off_out, size_t len){
#ifdef __NR_copy_file_range
    return syscall(__NR_copy_file_range, in, off_in, out, off_out, len, 0);
#else
    errno = ENOSYS; return -1;
#endif
}

static int copy_all(int in, int out){
    struct stat st; fstat(in, &st);
    off_t off_in = 0, off_out = 0;
    while(off_in < st.st_size){
        size_t want = (size_t)(st.st_size - off_in);
        ssize_t n = xcopyfr(in, &off_in, out, &off_out, want);
        if (n > 0) continue;
        if (n < 0 && (errno==ENOSYS || errno==EXDEV || errno==EOPNOTSUPP)) break;
        if (n < 0) { perror("copy_file_range"); return -1; }
    }
    if (off_in == st.st_size) return 0; // 끝

    // sendfile 폴백 (일부 FS/커널 제한에서는 불가)
    off_in = 0;
    while(off_in < st.st_size){
        ssize_t n = sendfile(out, in, &off_in, st.st_size - off_in);
        if (n > 0) continue;
        if (n < 0 && (errno==EINVAL || errno==ENOSYS)) break;
        if (n < 0) { perror("sendfile"); return -1; }
    }
    if (off_in == st.st_size) return 0;

    // 마지막 폴백: read/write 루프
    if (lseek(in, 0, SEEK_SET) < 0) perror("lseek");
    char buf[1<<16];
    for(;;){
        ssize_t r = read(in, buf, sizeof buf);
        if (r == 0) break;
        if (r < 0) { if (errno==EINTR) continue; perror("read"); return -1; }
        ssize_t wtot = 0;
        while (wtot < r){
            ssize_t w = write(out, buf + wtot, r - wtot);
            if (w < 0) { if (errno==EINTR) continue; perror("write"); return -1; }
            wtot += w;
        }
    }
    return 0;
}

int main(int argc, char **argv){
    if (argc != 3){ fprintf(stderr, "Usage: %s SRC DST\n", argv[0]); return 2; }
    int in  = open(argv[1], O_RDONLY|O_CLOEXEC);
    if (in  < 0){ perror("open src"); return 1; }
    int out = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0644);
    if (out < 0){ perror("open dst"); return 1; }

    int rc = copy_all(in, out);
    if (!rc && fsync(out) < 0) perror("fsync");
    close(in); close(out);
    return rc;
}
```

### 15.2 stdout 리다이렉션(셸 없이)

```c
int fd = open("out.log", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0644);
dup2(fd, STDOUT_FILENO);  // 이후 printf → out.log
close(fd);
```

### 15.3 `splice`로 간단 cat(파이프 기반 zero-copy)

```c
int in = open(argv[1], O_RDONLY);
int out = STDOUT_FILENO;
int p[2]; pipe(p);
for(;;){
    ssize_t n = splice(in, NULL, p[1], NULL, 1<<20, 0);
    if (n == 0) break;
    splice(p[0], NULL, out, NULL, n, 0);
}
```

### 15.4 `openat2`로 안전 열기(심볼릭 링크/`..` 차단)

```c
#include <linux/openat2.h>
#include <sys/syscall.h>
int secure_open(int dirfd, const char *path, int flags, int mode){
    struct open_how how = {
        .flags = flags | O_CLOEXEC,
        .mode  = mode,
        .resolve = RESOLVE_BENEATH | RESOLVE_NO_SYMLINKS | RESOLVE_NO_MAGICLINKS
    };
    return syscall(SYS_openat2, dirfd, path, &how, sizeof(how));
}
```

### 15.5 `fcntl` 바이트 레인지 잠금

```c
int lock_range(int fd, off_t off, off_t len, short type){
  struct flock lk = {.l_type=type, .l_whence=SEEK_SET, .l_start=off, .l_len=len};
  return fcntl(fd, (type?F_SETLKW:F_SETLK), &lk);
}
```

---

## 16. 성능 최적화 체크포인트

- **I/O 병합**: 큰 버퍼(예: 128KiB~1MiB)로 batched I/O.
- **pread/pwrite**: 다중 스레드가 **한 FD**로 경쟁해도 오프셋 경쟁 없음.
- **readahead/posix_fadvise**: 순차 접근 힌트 제공.
- **Huge 파일**: `fallocate`로 미리 할당(조각화↓, ENOSPC 예측).
- **O_DIRECT**: 페이지 캐시 우회(정렬·크기 제약, DB에 적합).
- **io_uring**: 커널/유저 경계 비용↓(근대 커널, 라이브러리 필요).

---

## 17. 관찰·디버깅 명령 스니펫

```bash
# 열린 FD와 대상
lsof -p <pid> | head
ls -l /proc/<pid>/fd

# inode/링크/타임스탬프
stat some.file
statx -t -r some.file   # 더 풍부한 필드(툴/배포판 의존)

# xattr/ACL
getfattr -d some.file
getfacl some.file

# inotify로 변경 감시
inotifywait -m -e modify,create,delete .

# I/O 통계
iostat -xz 1
pidstat -d 1
```

---

## 18. 수식·규칙 몇 가지

### 18.1 umask 적용
$$
\text{final} = \text{requested} \;\&\; \sim\text{umask}
$$

### 18.2 디스크 사용량(개략)
$$
\text{disk\_used} \approx \left\lceil\frac{\text{size}}{\text{block\_size}}\right\rceil \cdot \text{block\_size}
$$
(스파스 파일/압축 FS/씬 프로비저닝은 예외)

---

## 19. 자주 하는 실수와 방어 요령

| 실수 | 결과 | 방어 |
|---|---|---|
| `mktemp`로 임시파일 | 경쟁/권한 취약 | `mkstemp`, `O_TMPFILE` |
| FD 누출 | 자식 프로세스에 퍼짐 | `O_CLOEXEC`/`FD_CLOEXEC` |
| 경로 TOCTOU | 링크·경계 우회 | `openat2` + `RESOLVE_*` |
| 부분 I/O 무시 | 데이터 손실 | 재시도 루프 |
| `mmap`/`write` 혼용 | 일관성 혼란 | 한 경로로 통일·`msync`/`fsync` 지점 정의 |
| 미동기 내구성 | 전원장애 손실 | `fsync(fd)`,`fsync(dir)` 순서 설계 |

---

## 20. 요약

- **파일**은 바이트 스트림(데이터)과 **inode 메타데이터**로 이루어진다.
- 이름은 디렉터리의 **엔트리**일 뿐이고, 링크는 **이름↔inode** 관계의 변형이다.
- 커널은 FD→open file→inode의 **3단 구조**로 열린 파일을 관리한다.
- 올바른 I/O는 **부분 I/O/EINTR**·**원자성(pread/pwrite/rename)**·**내구성(fsync)** 을 다룬다.
- 성능은 **페이지 캐시/대체 경로(sendfile/splice/copy_file_range)**, **할당/배치**, **동기화 정책**에 달려 있다.
- 보안은 **경로 해석 제어(openat2/RESOLVE)**, **FD 관리**, **권한 최소화**가 핵심이다.
