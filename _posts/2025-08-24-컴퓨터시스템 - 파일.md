---
layout: post
title: 컴퓨터시스템 - 파일
date: 2025-08-24 21:20:23 +0900
category: 컴퓨터시스템
---
# 📂 파일에 대해 — 컴퓨터 시스템 관점의 상세 정리

유닉스/리눅스 계열 운영체제에서 **파일(file)** 은 **데이터를 저장하거나 접근하는 기본 단위**입니다.  
여기서 파일은 단순한 텍스트/바이너리 데이터뿐 아니라 **디렉터리, 장치, 네트워크 소켓, 파이프**까지 포함합니다.  
즉, **"모든 것은 파일이다"**(Everything is a file)라는 철학을 따릅니다.

---

## 1. 파일의 기본 개념

### 1.1 정의
- 커널이 관리하는 **바이트(byte)의 순차적 나열**.
- 각 바이트는 **0부터 시작하는 오프셋**을 가짐.
- 파일의 크기는 바이트 단위로 표현.

### 1.2 파일의 주요 특징
- **순차 접근**과 **임의 접근(Random Access)** 가능
- 데이터 유형(텍스트/이미지/오디오 등)에 대한 정보는 **파일 내용이 아니라 파일 형식 및 해석 방식**에 의해 결정
- 커널은 파일을 **파일 디스크립터(File Descriptor)**를 통해 식별

---

## 2. 파일의 종류 (유닉스 계열)

| 종류 | 설명 | 예시 |
|------|------|------|
| 일반 파일 (Regular file) | 텍스트, 실행 파일, 이미지 등 일반 데이터 저장 | `/etc/passwd`, `/bin/ls` |
| 디렉터리 (Directory) | 다른 파일의 목록과 메타데이터 저장 | `/home`, `/usr/bin` |
| 심볼릭 링크 (Symbolic Link) | 다른 파일/디렉터리 참조 | `/lib64/ld-linux-x86-64.so.2` |
| 특수 파일 (Special file) | 하드웨어/커널 인터페이스 | `/dev/sda`, `/dev/null` |
| 파이프 (Pipe/FIFO) | 프로세스 간 통신 (IPC) | `/tmp/mypipe` |
| 소켓 (Socket) | 네트워크 통신/로컬 IPC | `/var/run/docker.sock` |

---

## 3. 파일의 메타데이터

커널은 각 파일의 **메타데이터(metadata)** 를 **inode**라는 자료구조에 저장합니다.

### 3.1 inode에 포함되는 정보
- 파일 유형
- 파일 크기
- 소유자 UID/GID
- 접근 권한 (rwx)
- 생성, 수정, 접근 시간 (`ctime`, `mtime`, `atime`)
- 하드링크 개수
- 데이터 블록 위치

```bash
$ stat /etc/passwd
  File: /etc/passwd
  Size: 2300       Blocks: 8          IO Block: 4096 regular file
Device: 802h/2050d Inode: 12345       Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/ root)   Gid: (    0/ root)
Access: 2025-08-10 12:00:00
Modify: 2025-07-30 10:20:00
Change: 2025-07-30 10:20:00
```

---

## 4. 파일 디스크립터 (File Descriptor)

- 프로세스에서 열린(open) 파일을 **정수 값**으로 식별.
- 프로세스 시작 시 기본적으로 세 개의 FD가 열려 있음:
  - **0**: 표준 입력 (`STDIN_FILENO`)
  - **1**: 표준 출력 (`STDOUT_FILENO`)
  - **2**: 표준 오류 (`STDERR_FILENO`)

---

## 5. 파일 연산 — UNIX 시스템 콜

### 5.1 열기
```c
int fd = open("data.txt", O_RDONLY);
```
- `O_RDONLY`, `O_WRONLY`, `O_RDWR` 등의 플래그 사용.
- `O_CREAT` 플래그 사용 시 mode(퍼미션) 지정 필요.

### 5.2 읽기
```c
char buf[100];
ssize_t n = read(fd, buf, sizeof(buf));
```
- 반환값이 0이면 EOF.

### 5.3 쓰기
```c
write(fd, buf, nbytes);
```
- 부분 쓰기 발생 가능 → 루프 필요.

### 5.4 위치 이동
```c
lseek(fd, offset, SEEK_SET); // 파일 포인터 이동
```

### 5.5 닫기
```c
close(fd);
```

---

## 6. 파일 접근 권한

- 권한은 **소유자(owner)**, **그룹(group)**, **기타(other)** 로 구분.
- 읽기(r), 쓰기(w), 실행(x) 권한 부여.
- 예시:
```bash
-rwxr-x---
```
- `chmod`, `chown`, `chgrp` 명령어로 변경.

---

## 7. 파일 오프셋과 접근 모드

### 7.1 오프셋
- 커널이 유지하는 **파일 포인터 위치**.
- `read`/`write`는 오프셋을 자동으로 증가시킴.

### 7.2 접근 모드
- `O_APPEND`: 항상 파일 끝에 쓰기
- `O_TRUNC`: 열 때 파일 내용 제거
- `O_NONBLOCK`: 비차단 모드

---

## 8. 파일의 종류별 I/O 특징

| 파일 유형 | 특징 | 예시 |
|-----------|------|------|
| 일반 파일 | 크기 제한 없음, 랜덤 접근 가능 | 로그 파일 |
| 디렉터리 | `opendir`, `readdir` 사용 | `/home/user` |
| 장치 파일 | 읽기/쓰기 → 디바이스 드라이버로 전달 | `/dev/sda` |
| 파이프/FIFO | 단방향 스트림, FIFO 순서 보장 | `/tmp/fifo1` |
| 소켓 | 양방향 통신, 네트워크 사용 가능 | TCP/UDP 소켓 |

---

## 9. 파일과 버퍼링

- **UNIX I/O** (`read`, `write`): 버퍼링 없음
- **표준 I/O** (`fread`, `fwrite`): 내부 버퍼 사용
- 버퍼링은 성능 향상을 위해 필수적이지만, 실시간성이 중요한 경우 비활성화 가능.

---

## 10. C 예제 — 파일 복사기

```c
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

#define BUF_SIZE 4096

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s src dst\n", argv[0]);
        exit(1);
    }

    int src = open(argv[1], O_RDONLY);
    if (src < 0) { perror("open src"); exit(1); }

    int dst = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (dst < 0) { perror("open dst"); close(src); exit(1); }

    char buf[BUF_SIZE];
    ssize_t n;
    while ((n = read(src, buf, BUF_SIZE)) > 0) {
        ssize_t written = 0;
        while (written < n) {
            ssize_t w = write(dst, buf + written, n - written);
            if (w < 0) { perror("write"); close(src); close(dst); exit(1); }
            written += w;
        }
    }

    if (n < 0) perror("read");

    close(src);
    close(dst);
    return 0;
}
```

---

## 11. 파일 시스템과 파일

- 파일은 **파일 시스템(File System)** 위에 존재.
- 파일 시스템은 **데이터 블록**, **메타데이터 블록**을 조직화하여 저장 장치를 관리.
- 예: EXT4, XFS, NTFS, FAT32

---

## 12. 파일 관련 고급 주제

### 12.1 메모리 매핑 I/O
- `mmap`을 사용하여 파일을 메모리에 직접 매핑.
- 예:
```c
void *addr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, 0);
```

### 12.2 파일 잠금
- `flock` 또는 `fcntl`로 파일 동시 접근 제어.
- 배타 잠금(Exclusive lock), 공유 잠금(Shared lock) 가능.

### 12.3 스파스 파일(Sparse File)
- 실제 데이터 없는 구간은 디스크 공간 소모 안 함.
- DB, VM 이미지 등에서 자주 사용.

---

## 13. 요약

- 파일은 **데이터와 메타데이터**로 구성되며, 모든 I/O의 기본 단위.
- 커널은 **inode + 파일 디스크립터**로 파일을 관리.
- 파일 시스템 콜(`open`, `read`, `write`, `close`, `lseek`)을 통해 접근.
- 파일의 종류와 접근 모드를 이해하면, **효율적인 I/O**와 **안전한 데이터 관리**가 가능.