---
layout: post
title: DB 심화 - 비트맵 인덱스
date: 2025-11-10 14:25:23 +0900
category: DB 심화
---
# 비트맵 인덱스 완전 정리

— **기본 구조 → 활용 패턴 → `records_per_block`(비트 위치 ↔ ROWID 매핑의 핵심) → 운영/튜닝/주의사항**
(Oracle 기준. 모든 예제는 실습용으로 설계했으며, 실행계획은 `DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE')`로 확인하세요.)

---

## 실습 공통 준비

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;  -- ALLSTATS LAST 확인용
```

---

# 비트맵 인덱스 기본 구조

## 무엇을 저장하나?

B-Tree 인덱스가 **키→ROWID 목록**을 “정렬된 포인터 묶음”으로 저장한다면, **비트맵 인덱스(Bitmap Index)**는 **키 값마다** 다음을 저장합니다.

- **(키 값, [비트맵 조각들의 집합])**
- 각 **비트맵 조각(bitmap segment)**은 **연속적인 ROWID 범위**를 대상으로 하며, 그 범위 안의 **각 ROWID 위치**에 대해 **해당 키 값이면 1, 아니면 0**을 가집니다.
- 비트맵 조각은 **Run-Length Encoding(RLE)** 등으로 **압축**되어 저장됩니다. (동일 값이 연속되기 쉬운 저/중복수 컬럼일수록 압축 효율↑)

> 요약: **키 값 하나 ↔ 여러 개의 “(ROWID 범위, 압축된 비트열)”**
> 쿼리 시에는 여러 키의 비트열을 **BITMAP AND/OR/ MINUS**로 연산한 뒤, **ROWIDs로 변환**하여 테이블(또는 IOT)을 방문합니다.

## 왜 빠른가? (특히 다차원 조건)

- 조건이 **상대적으로 저카디널리티**(예: `성별`, `상태코드`, `월`, `지역`)일 때,
  여러 조건의 결합(AND/OR)을 **비트 연산**으로 한 번에 수행 → **연산량이 스캔량보다 지배적**인 분석 쿼리에서 강력.
- **스타 스키마(팩트+디멘전)**에서 디멘전 조건을 **비트맵 인덱스 AND/OR**로 결합 후 팩트 방문 → **Star Transformation**의 핵.

## DML 주의 (OLTP와 상극인 이유)

- 비트맵은 **한 비트가 한 ROWID**에 해당. 특정 행에 대한 **UPDATE/DELETE**는 해당 **비트맵 조각**을 **잠금/갱신**해야 하므로,
  같은 조각을 공유하는 **다른 행들까지 경합**이 커질 수 있습니다. → **대량 DML/높은 동시성 OLTP**에는 부적합.
- 반대로, **읽기/분석(OLAP)·저빈도 DML**에는 매우 유리.

---

# 비트맵 인덱스 활용 시나리오

## 전형: 저/중복수 컬럼의 다차원 필터

- `성별, 지역, 상태, 카테고리, 월, 등급, 브랜드, …`
- **여러 필터**를 조합(AND/OR/NOT)해야 하는 **레포트/대시보드/Ad-hoc 분석**.

## 스타 스키마 (Bitmap Join Index 포함)

- 팩트 테이블의 외래키(또는 디멘전 속성)에 **비트맵 인덱스**.
- 또는 **Bitmap Join Index**로 **디멘전 속성→팩트 ROWID 비트맵**을 직접 생성.
  (조인 생략/축약으로 팩트 필터링을 빠르게 진행)

## 파티션 팩트 + 로컬 비트맵 인덱스

- **파티션 프루닝**과 결합 시, 파티션별 **로컬 비트맵 인덱스**가 **스캔 범위**를 크게 줄임.
- 대용량 DW에서 기본.

---

# 실습: 팩트 테이블 + 저카디널리티 속성

## 스키마 & 데이터

```sql
DROP TABLE sales PURGE;

CREATE TABLE sales (
  sale_id     NUMBER       PRIMARY KEY,
  sale_dt     DATE         NOT NULL,
  region      VARCHAR2(6)  NOT NULL,  -- 'APAC','EMEA','AMER' 등
  channel     VARCHAR2(6)  NOT NULL,  -- 'WEB','APP','STORE'
  category    VARCHAR2(10) NOT NULL,  -- 'ELEC','FASH','FOOD','ETC' 등
  amount      NUMBER(12,2) NOT NULL
);

BEGIN
  FOR i IN 1..2_000_00 LOOP  -- 200만 (환경 따라 줄이세요)
    INSERT INTO sales
    VALUES(
      i,
      DATE '2024-01-01' + MOD(i, 540),
      CASE MOD(i,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END,
      CASE MOD(i,3) WHEN 0 THEN 'WEB'  WHEN 1 THEN 'APP'  ELSE 'STORE' END,
      CASE MOD(i,4) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FASH' WHEN 2 THEN 'FOOD' ELSE 'ETC' END,
      ROUND(DBMS_RANDOM.VALUE(10, 200000),2)
    );
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES', cascade=>FALSE,
    method_opt=>'for all columns size skewonly');
END;
/
```

> 주의: 200만 행은 로컬 환경에 무거울 수 있습니다. 필요시 20~50만 행로 조절하세요.

## B-Tree vs Bitmap 인덱스 생성

```sql
-- 저카디널리티 컬럼에 비트맵 인덱스
CREATE BITMAP INDEX bix_sales_region  ON sales(region);
CREATE BITMAP INDEX bix_sales_channel ON sales(channel);
CREATE BITMAP INDEX bix_sales_cate    ON sales(category);

-- 비교: 동일 컬럼에 B-Tree도 만들 수 있으나(실습용), 실제 운영에서는 둘을 동시에 유지하지 않는 것이 일반적
-- CREATE INDEX ix_sales_region  ON sales(region);
-- CREATE INDEX ix_sales_channel ON sales(channel);
-- CREATE INDEX ix_sales_cate    ON sales(category);

BEGIN
  DBMS_STATS.GATHER_INDEX_STATS(USER,'BIX_SALES_REGION');
  DBMS_STATS.GATHER_INDEX_STATS(USER,'BIX_SALES_CHANNEL');
  DBMS_STATS.GATHER_INDEX_STATS(USER,'BIX_SALES_CATE');
END;
/
```

## 다차원 필터: 비트 연산으로 결합

```sql
-- “EMEA & WEB & ELEC” 조건 집계
SELECT /*+  NO_RESULT_CACHE */
       COUNT(*), SUM(amount)
FROM   sales
WHERE  region   = 'EMEA'
AND    channel  = 'WEB'
AND    category = 'ELEC';

-- 실행계획(요약 기대):
--  BITMAP INDEX SINGLE VALUE (각 bix…)
--  BITMAP AND
--  BITMAP CONVERSION TO ROWIDS
--  TABLE ACCESS BY ROWID SALES

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE'));
```

- 계획에 **`BITMAP AND`** / **`BITMAP OR`** / **`BITMAP MINUS`** 등이 보이면 제대로 결합되고 있는 것입니다.
- 동일 조건을 B-Tree로 처리할 경우, **필터 결합 비용**이나 **랜덤 I/O**가 커질 수 있습니다(분포에 따라 다름).

## 범위+다차원: 날짜는 B-Tree, 속성은 Bitmap

```sql
-- 최근 30일 + 카테고리·채널 필터
SELECT COUNT(*), SUM(amount)
FROM   sales
WHERE  sale_dt >= SYSDATE - 30
AND    category = 'FOOD'
AND    channel  = 'APP';

-- 권장 인덱스 조합(운영 설계):
--  1) B-Tree: (sale_dt) 혹은 (sale_dt DESC, sale_id DESC)  → 기간 프루닝/정렬 흡수
--  2) Bitmap: (category), (channel)                         → 비트 결합
```

---

# `records_per_block` — 비트 위치와 ROWID의 **매핑 단위**

## 개념

비트맵 인덱스가 **“ROWID 범위 + 비트열”**을 가진다고 했을 때, **비트 `k`**가 **어떤 ROWID**에 해당하는지 계산하려면, 한 블록에 **몇 개의 ROWID 슬롯**이 들어가는지를 알아야 합니다. 이를 개념적으로 여기서 **`records_per_block (RPB)`**라고 부르겠습니다.

- **정의(개념적)**: 인덱스가 비트열을 **ROWID 시퀀스**에 매핑할 때 사용하는 **“블록당 레코드 수”** 추정치.
- 매핑 공식(개념식):

  $$
  \begin{aligned}
  \text{bit\_pos} &= k \\
  \text{block\_offset} &= \left\lfloor \dfrac{k}{RPB} \right\rfloor \\
  \text{row\_slot} &= k \bmod RPB \\
  \text{rowid}(k) &= (\text{base\_block} + \text{block\_offset},\ \text{row\_slot})
  \end{aligned}
  $$

- 즉, **비트열을 블록 단위로 끊어** 각 비트를 **(블록, 행슬롯)**에 대응시키는 셈입니다. 여기서 **RPB**가 바로 그 **단위**입니다.

> ⚠️ 오해 방지
> - Oracle은 이 **RPB를 딕셔너리 뷰로 직접 공개하지 않습니다.** 내부 매핑과 압축 방식은 버전·세그먼트 상태에 따라 달라질 수 있습니다.
> - 다만 “**한 블록에 담길 수 있는 행 수의 상한/추정**”을 기반으로 비트 매핑이 이뤄진다는 **원리**를 이해하면,
>   **행 길이 변화, PCTFREE 변화, 행이동/행체인** 등이 **비트맵 밀도/효율**에 영향을 줄 수 있음을 직관화할 수 있습니다.

## 왜 중요한가?

- 같은 ROWID 범위를 대표하는 **비트열 조각**에서 **1의 밀도**가 높아지면 압축 효율이 좋아지고, 반대로 **희소**해지면 압축/연산 효율이 떨어질 수 있습니다.
- **행 길이 변화** 등으로 테이블의 **“실제 블록당 행 수”**가 바뀌면, **기존 비트맵의 RPB 기반 매핑 가정**과 **현실**의 괴리가 커지고, 결과적으로 **공간/연산 효율**이 악화될 수 있습니다. 이때 **인덱스 재생성(REBUILD)**이 의미 있는 경우가 있습니다.

## 현장에서 RPB를 “추정”하는 방법 (참고)

딕셔너리에서 RPB가 노출되진 않으므로, **표본 블록의 실제 행 슬롯 수(max/avg)**를 통해 **간접 추정**을 합니다.

```sql
-- 표본: 최근 N개의 블록에서 rowid 슬롯 수를 집계 (데모용; 실제로는 세그먼트 헤더/블록 샘플링 기법을 조합)
WITH T AS (
  SELECT rowid rid FROM sales WHERE ROWNUM <= 100000
)
SELECT /* 대략적 추정치 */
       MAX(DBMS_ROWID.ROWID_ROW_NUMBER(rid)) + 1 AS max_rows_per_block,
       AVG(DBMS_ROWID.ROWID_ROW_NUMBER(rid)) + 1 AS avg_rows_per_block
FROM   T;
```

- `ROWID_ROW_NUMBER`는 **블록 내 행 슬롯 번호(0부터)**를 줍니다 → `+1` 하면 **해당 표본에서의 “행 슬롯 수”**.
- 이 값이 **RPB의 현실 근사**가 됩니다. (정확한 내부 값과 다를 수 있으나, **경향 파악**에는 충분.)

## 언제 REBUILD를 고려하나?

- 테이블이 **가볍던 시절**에 만든 비트맵 인덱스가, 이후 **행 길이 증가/행 이동**으로 **블록당 행 수 분포**가 크게 변한 경우.
- 대량 삭제/재적재 후 **비트열 조각 구성**이 비효율적으로 바뀌어 **segment size/압축 효율**이 나빠진 경우.
- **증상**: 쿼리 동일/통계 적절인데 **BITMAP AND/OR 비용이 유독 커짐**, 인덱스 **세그먼트 바이트 증가** 등.

> 조치
> - `ALTER INDEX <bix> REBUILD` (버전에 따라 ONLINE 지원 제약 있음. **COALESCE는 B-Tree 전용**이라 비트맵에는 일반적으로 적용 불가)
> - **파티션 로컬 비트맵**이면 파티션 단위 REBUILD로 영향 최소화.

---

# 운영/튜닝 포인트

## 언제 비트맵을 쓰나?

- **읽기 위주/분석/리포팅/Ad-hoc**
- **저·중복수**(예: 2~수백 distinct 정도까지 실효)
- **다수 조건 결합**(AND/OR/NOT)
- **스타 스키마** + **파티션 프루닝**

## 언제 피하나?

- **빈번한 DML**, **높은 동시성 OLTP** (비트맵 조각 잠금/갱신 경합)
- **카디널리티가 매우 높아** 비트열이 희소할 때 (공간/연산 이득↓, 오히려 B-Tree가 나음)

## 통계/계획

- **열 히스토그램**이 선택도 추정에 유리(스큐 대응).
- 계획에서 **`BITMAP …` 연산자**들이 나타나는지 확인:
  - `BITMAP INDEX SINGLE VALUE`, `BITMAP INDEX RANGE SCAN`,
  - `BITMAP AND/OR/MINUS`,
  - `BITMAP CONVERSION TO ROWIDS`.

```sql
SELECT index_name, index_type, blevel, leaf_blocks, distinct_keys
FROM   user_indexes
WHERE  table_name = 'SALES';

-- index_type가 'BITMAP' 또는 'FUNCTION-BASED BITMAP' 등으로 보입니다.
```

## 파티셔닝과 함께

- **팩트 테이블 RANGE 파티션** + **로컬 비트맵 인덱스** = 파티션 프루닝으로 **스캔 범위 최소화**.
- 파티션 단위 **교체·재구성**이 쉬워 **운영 리스크↓**.

## 공간/유지보수

- 대량 삭제/재적재 후 **REBUILD**로 비트열 재팩토링.
- **NOLOGGING + PARALLEL** 옵션을 적절히 사용해 **빌드 시간 단축**(복구전략 고려).

---

# 고급: Bitmap Join Index (BJI) 맛보기

> **목표**: 디멘전 속성(예: `제품.브랜드='A'`)이 적용된 결과를, **팩트의 ROWID 비트열**로 **미리** 만들어 둡니다.
> 쿼리 시 디멘전 조인 없이 **비트맵 조회→팩트 필터**로 바로 진행.

```sql
-- 예시 스키마
DROP TABLE dim_product PURGE;
CREATE TABLE dim_product (
  prod_id  NUMBER PRIMARY KEY,
  brand    VARCHAR2(20) NOT NULL,
  cate     VARCHAR2(20) NOT NULL
);

-- 제품 로딩
BEGIN
  FOR p IN 1..10000 LOOP
    INSERT INTO dim_product
    VALUES(p,
           CASE MOD(p,5) WHEN 0 THEN 'BR_A' WHEN 1 THEN 'BR_B' WHEN 2 THEN 'BR_C'
                         WHEN 3 THEN 'BR_D' ELSE 'BR_E' END,
           CASE MOD(p,4) WHEN 0 THEN 'CAT1' WHEN 1 THEN 'CAT2' WHEN 2 THEN 'CAT3' ELSE 'CAT4' END);
  END LOOP;
  COMMIT;
END;
/

-- 팩트에 제품 FK 추가 (실습용)
ALTER TABLE sales ADD (prod_id NUMBER);
UPDATE sales s SET prod_id = MOD(s.sale_id, 10000)+1;
COMMIT;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_PRODUCT', cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES',       cascade=>FALSE);
END;
/

-- Bitmap Join Index: (dim.brand) → sales(ROWID) 비트맵
CREATE BITMAP INDEX bix_sales_brand
ON sales(dp.brand)
FROM sales s, dim_product dp
WHERE s.prod_id = dp.prod_id;

BEGIN DBMS_STATS.GATHER_INDEX_STATS(USER,'BIX_SALES_BRAND'); END;
/
```

```sql
-- 질의: 브랜드 + 채널 + 최근 30일 집계
SELECT COUNT(*), SUM(amount)
FROM   sales s
WHERE  s.sale_dt >= SYSDATE - 30
AND    s.channel = 'WEB'
AND    s.rowid IN (
  SELECT /* BJI가 사용되면 내부적으로 BITMAP→ROWID 변환 */
         ROWID
  FROM   sales
  WHERE  dp.brand = 'BR_A'   -- 논리적으로는 디멘전 속성 필터
);

-- 실행계획: BITMAP INDEX (bix_sales_brand) + BITMAP AND + BITMAP CONVERSION
```

> 현업에서는 **BJI 제약/요건**(FK 무결성, 조인 조건 단순성, 파티셔닝 호환성 등)을 반드시 문서 기준으로 검토하세요.

---

# 진단/검증 스니펫

```sql
-- 최근 실행 SQL 중 비트맵 연산 등장 여부(개략)
SELECT sql_id, child_number, plan_hash_value, operation, options, object_name
FROM   v$sql_plan
WHERE  operation LIKE 'BITMAP%'
ORDER  BY last_change_time DESC
FETCH FIRST 50 ROWS ONLY;

-- 인덱스 세그먼트 크기
SELECT segment_name, bytes/1024/1024 AS mb
FROM   user_segments
WHERE  segment_name IN ('BIX_SALES_REGION','BIX_SALES_CHANNEL','BIX_SALES_CATE','BIX_SALES_BRAND');
```

---

# 실무 체크리스트

- [ ] 대상 컬럼이 **저/중복수**인가? (수십~수백 distinct 정도까지가 보통 실효)
- [ ] **읽기/분석 위주**인가? (OLTP 대량 DML/동시성 ↑ 이면 **비트맵 금지**)
- [ ] **다차원 필터**를 자주 결합하나? (AND/OR/NOT)
- [ ] **파티션 프루닝**과 결합 가능한가? (로컬 비트맵 권장)
- [ ] 통계를 적절히 수집했나? (히스토그램으로 선택도 추정 보완)
- [ ] 계획에 **BITMAP 연산자**들이 등장하는가?
- [ ] **대량 삭제/재적재** 후 **REBUILD**로 압축/조각 최적화를 고려했나?
- [ ] (고급) **Bitmap Join Index**로 디멘전 조인을 축약할 수 있는가?
- [ ] **`records_per_block` 관점**에서 테이블의 **블록당 행 수 분포**가 크게 변했는가? (샘플링/세그먼트 점검 후 REBUILD 판단)

---

# 미세 팁 & 주의사항

- **COALESCE는 보통 B-Tree에 한정**됩니다. 비트맵은 **REBUILD**로 재팩토링.
- **ONLINE REBUILD** 지원 여부/제약은 **버전별 문서** 확인(버전에 따라 제한 존재).
- 비트맵 인덱스는 **NULL 값도 인덱싱** 가능합니다(분포에 따라 계획에 유용).
- **병렬 생성/스캔**과 궁합이 좋습니다: `CREATE BITMAP INDEX … PARALLEL n NOLOGGING` (복구/로깅 정책 고려).
- **혼합 전략**: 날짜/숫자 범위 탐색은 **B-Tree**, 다차원 속성은 **Bitmap** → **BITMAP AND**로 결합.

---

# 요약

- 비트맵 인덱스는 **키 값 → (ROWID 범위, 압축 비트열들)** 구조로 저장되며,
  다차원 필터를 **비트 연산**으로 빠르게 결합하는 **분석/레포트** 환경에서 강력합니다.
- **`records_per_block`**(개념적 RPB)은 **비트 위치와 ROWID를 매핑하는 단위**로,
  테이블의 **블록당 행 수** 변화(행 길이/행 이동/PCTFREE 등)와 함께 **비트밀도/압축 효율**에 간접적 영향을 줍니다.
  극단적으로 변했다면 **REBUILD**가 의미 있을 수 있습니다.
- **OLTP 대량 DML/동시성**에는 **부적합**(비트맵 조각 잠금), 대신 **DW/리포트/스타 스키마**에서
  **파티션 프루닝 + 로컬 비트맵 + (필요 시) BJI**로 최대 효과를 얻으세요.

> 마지막은 항상 **숫자**입니다.
> `DBMS_XPLAN`의 Buffers/Reads, `BITMAP AND/OR` 등장 여부, 세그먼트 크기 변화를 **실측**으로 확인하세요.
