---
layout: post
title: DB 심화 - 비트맵 인덱스
date: 2025-11-10 14:25:23 +0900
category: DB 심화
---
# 비트맵 인덱스

## 1. 인덱스 큰 그림: B-Tree vs Bitmap

### 1.1 논리 구조 비교

Oracle 공식 문서 기준으로 비트맵 인덱스는 **“인덱스된 데이터 + ROWID 범위”를 키로 하고, 데이터 영역에 비트열을 저장하는 구조**다. 즉, 인덱스 엔트리 하나가 여러 행을 가리킨다. 반대로 B-Tree는 엔트리 하나가 보통 하나의 ROWID를 가리킨다. :contentReference[oaicite:0]{index=0}  

이를 표로 정리하면 다음과 같다.

| 구분 | B-Tree 인덱스 | 비트맵 인덱스 |
|------|---------------|---------------|
| 인덱스 엔트리의 키 | (인덱스 컬럼 값) 또는 (컬럼 + ROWID) | (인덱스 컬럼 값 + ROWID 범위) |
| 인덱스 엔트리의 “데이터” | ROWID 또는 없음 | 비트열(압축된 bitmap) |
| 한 엔트리가 가리키는 행 수 | 보통 1행 (non-unique면 1행 이상이지만, 엔트리마다 ROWID 고유) | 특정 ROWID 범위 안의 **다수 행** |
| 주 활용 영역 | OLTP, 고카디널리티 컬럼, 포인트/범위 조회 | DW/OLAP, 저·중복수 컬럼, 다차원 필터(AND/OR/NOT) |
| DML 동시성 | 행 단위 잠금 | 비트맵 조각 단위 잠금 → OLTP에 취약 |

비트맵 인덱스에 대해 Oracle 문서는 다음과 같이 요약한다.  
- 인덱스 엔트리는 **인덱스된 데이터와 ROWID 범위를 키로 하고**,  
- 데이터 영역에 해당 범위의 행을 나타내는 **1/0 비트열**을 가진다. :contentReference[oaicite:1]{index=1}  

또 다른 정리에서는, 각 distinct 값마다 **별도의 비트맵**을 가지고, 비트맵은 다시 데이터 블록에 맞게 **조각(piece)** 으로 나뉘며, 각 조각이 `(키 값, 시작 ROWID, 끝 ROWID, 비트열)` 구조를 가진다고 설명한다. :contentReference[oaicite:2]{index=2}  

### 1.2 왜 다차원 조건에 강한가?

**비트맵 인덱스의 핵심 장점**은:

- 조건 1: `region = 'EMEA'` → 비트맵 A  
- 조건 2: `channel = 'WEB'` → 비트맵 B  
- 조건 3: `category = 'ELEC'` → 비트맵 C  

이면, 결과에 해당하는 행 집합은 비트 연산으로 표현된다.

$$
\text{ResultBitmap} = A \,\&\, B \,\&\, C
$$

또는 OR/NOT 조합:

$$
\text{ResultBitmap} = (A \lor B) \land \lnot C
$$

이 연산은 **CPU 레지스터 수준에서 매우 빠르게 처리 가능한 비트 연산**이며,  
B-Tree처럼 각 조건마다 ROWID 목록을 스캔하면서 조합하는 것보다  
**“조건 결합 비용” 측면에서 훨씬 유리**하다. :contentReference[oaicite:3]{index=3}  

특히,

- 저·중복수(예: 성별, 지역, 상태코드, 월, 등급, 브랜드 등) 열에  
- 다수의 조건을 AND/OR/NOT로 결합하는 **DW/OLAP 질의**에서 큰 장점을 가진다. :contentReference[oaicite:4]{index=4}  

---

## 2. 비트맵 인덱스 내부 구조

### 2.1 엔트리 단위 구조 (개념)

Oracle 문서의 요약을 기반으로 개념적으로 표현하면,  
비트맵 인덱스의 leaf 엔트리는 다음과 같은 형식이라고 볼 수 있다. :contentReference[oaicite:5]{index=5}  

- Key:  
  - 인덱스된 컬럼 값 (예: `region = 'EMEA'`)  
  - ROWID 범위 (예: `low_rowid`, `high_rowid`)
- Data:  
  - 해당 ROWID 범위에 대응하는 **비트열(압축)**

즉, **하나의 엔트리가 특정 값에 대해 “이 블록 범위 안에서 이 값인 행들은 어디인가”를 한 번에 표현**한다.

이를 텍스트로 나타내면:

```text
('EMEA', low_rowid, high_rowid, bitmap=10001010101000...)
```

- 비트열에서 **i번째 비트가 1**이면 →  
  `low_rowid`에서 i번째 위치에 해당하는 행은 `region = 'EMEA'`.
- 0이면 해당 값이 아님.

이 비트열은 저장 공간과 연산 효율을 위해 **Run-Length Encoding(RLE)** 등으로 압축되어 저장된다. :contentReference[oaicite:6]{index=6}  

### 2.2 전체 구조 vs B-Tree

중요한 점은, **비트맵 인덱스도 물리적으로는 B-Tree 구조 위에 올라간다**는 것이다.  
즉,

- 루트/브랜치/리프 노드 구조는 B-Tree와 동일하다.
- 차이점은 **리프 엔트리의 “데이터 부분”이 비트열이라는 것**이다. :contentReference[oaicite:7]{index=7}  

그래서:

- 인덱스 키 순서 검색(= 값으로 검색)은 B-Tree처럼 빠르고,
- 키를 찾은 뒤, **ROWID 대신 비트열을 읽어서 “후처리”** 하는 구조가 된다.

---

## 3. records_per_block (RPB)와 비트 → ROWID 매핑

### 3.1 개념 요약

각 비트맵 조각은 `(start_rowid, end_rowid, 비트열)`을 가지고 있다.  
여기서 i번째 비트를 ROWID로 변환하려면 대략 다음과 같은 “수학”이 필요하다. :contentReference[oaicite:8]{index=8}  

1. `start_rowid`와 `end_rowid`로 이 비트맵의 **ROWID 범위**를 알아낸다.
2. 해당 범위 안의 행들이 **블록별로 어떻게 배치되어 있는지**를 가정/추정한다.
3. i번째 비트가 어느 블록의 몇 번째 행(slots)에 해당하는지 계산한다.

이를 단순화하기 위해, 내부적으로는 “**블록당 ROWID 슬롯 수**”에 대한 어떤 기준값이 있을 수 있다.  
이 글에서는 이를 **`records_per_block (RPB)`** 라고 부른다 (정확한 내부 구현값이 아니라 **개념적** 파라미터).

개념적으로는:

- 비트맵 조각 내에서 **ROWID들을 0, 1, 2, …** 순서로 번호를 매기고,
- 한 블록에 **RPB개**의 ROWID를 배치한다고 가정하여,
- 비트 위치 `k`를 `(블록 offset, 블록 내 행 슬롯)`으로 매핑한다.

### 3.2 수식으로 쓰면

비트 위치를 0부터 시작한다고 하자.

$$
\begin{aligned}
\text{bit\_pos} &= k \quad (k = 0,1,2,\dots) \\
RPB &= \text{records\_per\_block} \\
\text{block\_offset} &= \left\lfloor \dfrac{k}{RPB} \right\rfloor \\
\text{row\_slot} &= k \bmod RPB
\end{aligned}
$$

이때 해당 비트에 대응하는 ROWID는 개념적으로:

$$
\text{ROWID}(k) = \bigl( \text{block} = \text{start\_block} + \text{block\_offset},\ \text{slot} = \text{row\_slot} \bigr)
$$

와 같이 표현할 수 있다.

> 실제 Oracle 내부는 위보다 훨씬 복잡하다.  
> - 데이터가 **연속 블록**에 깨끗이 배치되어 있지 않을 수도 있고,  
> - 행 삭제/이동/체인 등으로 **블록당 실제 행 수**가 들쭉날쭉일 수 있다.  
> - 비트맵 인덱스는 이런 현실을 어느 정도 추상화/압축해서 표현한다.  
> 여기서는 “**비트열과 ROWID 사이의 개념적 대응 관계**”를 이해하기 위한 모델로 본다.

### 3.3 왜 RPB가 중요한가?

RPB는 비트맵 인덱스 설계/운영에서 **간접적으로** 다음에 영향을 준다.

1. **비트 밀도 및 압축 효율**  
   - RPB가 크고, 특정 값이 **연속된 구간에서 자주 등장**하면  
     비트열에서 **긴 연속 1/0** 구간이 생겨 RLE 압축이 잘 된다.  
   - 반대로 행들이 파편화되어 있으면 비트 패턴이 `101010...`처럼 들쭉날쭉해져 압축 효율이 떨어진다.

2. **ROWID 변환·스캔 비용**  
   - Bitmap AND/OR 결과 비트열에서 **1의 밀도**가 높을수록  
     `BITMAP CONVERSION TO ROWIDS` 단계에서 생성해야 할 ROWID 수가 많아진다.  
   - 이때 실제 블록당 행 수와 RPB의 괴리가 크면,  
     비트열이 **실제보다 비효율적인 ROWID 분포를 나타내게 되어**  
     불필요한 I/O가 늘어날 수 있다.

3. **테이블 구조 변화의 영향**  
   - 컬럼 추가/삭제, 행 길이 증가, PCTFREE 변경 등으로  
     **테이블 블록당 평균 행 수**가 드라마틱하게 변하면,  
     비트맵 인덱스가 처음 생성될 때 가정했던 **RPB 기반 매핑**이  
     현실과 많이 어긋나는 상태가 될 수 있다.  
   - 이때 **비트맵 인덱스 REBUILD**가 의미 있는 개선을 줄 수 있다.

다시 강조하면, **RPB는 내부적으로 노출되지 않는 개념**이지만,  
“**비트열 ↔ ROWID 매핑의 단위**”라는 관점에서 생각하면  
**테이블 구조/분포 변화가 비트맵 인덱스 효율에 어떻게 영향을 주는지**를  
직관적으로 이해하는 데 큰 도움이 된다.

---

## 4. 실습 공통 준비

### 4.1 세션 설정

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;  -- DBMS_XPLAN ALLSTATS LAST용
```

실행계획 확인 시:

```sql
SELECT *
FROM   TABLE(
         DBMS_XPLAN.DISPLAY_CURSOR(
           NULL, NULL,
           'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'
         )
       );
```

을 사용할 것이다.

---

## 5. 기본 실습: SALES 팩트 테이블 + 저카디널리티 속성

### 5.1 테이블/데이터 생성

분석/리포트 환경을 가정한 간단한 **SALES 팩트 테이블**을 만든다.

```sql
DROP TABLE sales PURGE;

CREATE TABLE sales (
  sale_id     NUMBER       PRIMARY KEY,
  sale_dt     DATE         NOT NULL,
  region      VARCHAR2(6)  NOT NULL,  -- 'APAC','EMEA','AMER'
  channel     VARCHAR2(6)  NOT NULL,  -- 'WEB','APP','STORE'
  category    VARCHAR2(10) NOT NULL,  -- 'ELEC','FASH','FOOD','ETC'
  amount      NUMBER(12,2) NOT NULL
);
```

데이터는 다음과 같이 로딩한다(환경에 따라 행 수는 조절).

```sql
BEGIN
  FOR i IN 1..2000000 LOOP  -- 200만 (사양에 따라 200~500k로 줄여도 무방)
    INSERT INTO sales
    VALUES(
      i,
      DATE '2024-01-01' + MOD(i, 540),   -- 약 1년 반 범위
      CASE MOD(i,3)
        WHEN 0 THEN 'APAC'
        WHEN 1 THEN 'EMEA'
        ELSE     'AMER'
      END,
      CASE MOD(i,3)
        WHEN 0 THEN 'WEB'
        WHEN 1 THEN 'APP'
        ELSE     'STORE'
      END,
      CASE MOD(i,4)
        WHEN 0 THEN 'ELEC'
        WHEN 1 THEN 'FASH'
        WHEN 2 THEN 'FOOD'
        ELSE     'ETC'
      END,
      ROUND(DBMS_RANDOM.VALUE(10, 200000), 2)
    );
  END LOOP;
  COMMIT;
END;
/
```

통계 수집:

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    USER, 'SALES',
    cascade    => FALSE,
    method_opt => 'for all columns size skewonly'
  );
END;
/
```

### 5.2 비트맵 인덱스 생성

저카디널리티 컬럼에 비트맵 인덱스를 만든다.

```sql
CREATE BITMAP INDEX bix_sales_region
  ON sales(region);

CREATE BITMAP INDEX bix_sales_channel
  ON sales(channel);

CREATE BITMAP INDEX bix_sales_category
  ON sales(category);

BEGIN
  DBMS_STATS.GATHER_INDEX_STATS(USER,'BIX_SALES_REGION');
  DBMS_STATS.GATHER_INDEX_STATS(USER,'BIX_SALES_CHANNEL');
  DBMS_STATS.GATHER_INDEX_STATS(USER,'BIX_SALES_CATEGORY');
END;
/
```

이제 `USER_INDEXES`를 확인하면 `index_type = 'BITMAP'`으로 표시될 것이다. :contentReference[oaicite:9]{index=9}  

---

## 6. 다차원 필터 실습: 비트 연산과 실행계획

### 6.1 단순 다차원 필터

```sql
-- “EMEA & WEB & ELEC” 조건 집계
SELECT COUNT(*) AS cnt,
       SUM(amount) AS total_amount
FROM   sales
WHERE  region   = 'EMEA'
AND    channel  = 'WEB'
AND    category = 'ELEC';

SELECT *
FROM   TABLE(
         DBMS_XPLAN.DISPLAY_CURSOR(
           NULL, NULL,
           'ALLSTATS LAST +PREDICATE'
         )
       );
```

기대되는 실행계획 패턴(요약 형태):

```text
-----------------------------------------------------------------------------------
| Id | Operation                        | Name                | A-Rows | Buffers |
-----------------------------------------------------------------------------------
|  0 | SELECT STATEMENT                 |                     |       |         |
|  1 |  SORT AGGREGATE                  |                     |       |         |
|  2 |   TABLE ACCESS BY ROWID         | SALES               |   ... |    ...  |
|  3 |    BITMAP CONVERSION TO ROWIDS  |                     |       |         |
|  4 |     BITMAP AND                  |                     |       |         |
|  5 |      BITMAP INDEX SINGLE VALUE  | BIX_SALES_REGION    |       |         |
|  6 |      BITMAP INDEX SINGLE VALUE  | BIX_SALES_CHANNEL   |       |         |
|  7 |      BITMAP INDEX SINGLE VALUE  | BIX_SALES_CATEGORY  |       |         |
-----------------------------------------------------------------------------------
```

여기서:

- `BITMAP INDEX SINGLE VALUE` 단계에서 각 조건에 대한 **비트맵**이 생성된다.
- `BITMAP AND` 에서 세 비트맵을 비트 연산으로 결합한다.
- `BITMAP CONVERSION TO ROWIDS`에서 최종 비트맵을 **ROWID 목록으로 변환**한다.
- 마지막으로 `TABLE ACCESS BY ROWID SALES`로 필요한 행만 테이블에서 읽는다. :contentReference[oaicite:10]{index=10}  

이 구조가 바로 비트맵 인덱스의 힘이다.

### 6.2 범위 + 다차원 결합

```sql
-- 최근 30일 + 카테고리·채널 필터
SELECT COUNT(*) AS cnt,
       SUM(amount) AS total_amount
FROM   sales
WHERE  sale_dt  >= SYSDATE - 30
AND    category = 'FOOD'
AND    channel  = 'APP';
```

운영에서의 권장 인덱스 구조는 다음과 같이 나뉜다.

1. **B-Tree 인덱스**  
   - `(sale_dt)` 또는 `(sale_dt DESC, sale_id DESC)`  
   - 기간 조건 프루닝 및 정렬 흡수용.

2. **비트맵 인덱스**  
   - `(category)`, `(channel)`  
   - 다차원 속성 비트 결합용.

실행계획에서는:

- `sale_dt >= SYSDATE-30` 조건은 테이블 또는 B-Tree 인덱스에서 처리하고,
- `category`, `channel` 조건은 비트맵 인덱스로 bit 연산을 수행한 후
- 결과를 결합해 테이블 방문 범위를 줄이는 패턴이 나온다. :contentReference[oaicite:11]{index=11}  

---

## 7. records_per_block(RPB) 관점에서 테이블 살펴보기

### 7.1 ROWID 기반 블록/슬롯 확인

ROWID에서 **블록 번호**와 **행 슬롯 번호**를 구하는 Oracle 함수들을 이용해  
테이블의 “블록당 행 수”를 대략적으로 볼 수 있다.

```sql
-- 샘플 ROWID를 뽑아 블록/슬롯 분포 확인
WITH t AS (
  SELECT rowid AS rid
  FROM   sales
  WHERE  ROWNUM <= 100000
)
SELECT MIN(DBMS_ROWID.ROWID_BLOCK_NUMBER(rid)) AS min_block,
       MAX(DBMS_ROWID.ROWID_BLOCK_NUMBER(rid)) AS max_block,
       MIN(DBMS_ROWID.ROWID_ROW_NUMBER(rid))   AS min_row_slot,
       MAX(DBMS_ROWID.ROWID_ROW_NUMBER(rid))   AS max_row_slot,
       AVG(DBMS_ROWID.ROWID_ROW_NUMBER(rid))   AS avg_row_slot
FROM   t;
```

여기서:

- `ROWID_ROW_NUMBER(rid)`는 **블록 내 행 슬롯 번호(0부터 시작)** 를 나타낸다.
- `max_row_slot + 1`은 **샘플 블록 중 가장 많은 슬롯 번호**를 의미하므로  
  **최대 블록당 행 슬롯 수**의 근사치가 된다.
- `avg_row_slot + 1`은 샘플 기준 **평균 블록당 행 슬롯 수**의 근사치다.

이를 기반으로 개념적 RPB를 이렇게 추정할 수 있다.

```sql
WITH t AS (
  SELECT rowid AS rid
  FROM   sales
  WHERE  ROWNUM <= 100000
)
SELECT MAX(DBMS_ROWID.ROWID_ROW_NUMBER(rid)) + 1 AS approx_max_rpb,
       AVG(DBMS_ROWID.ROWID_ROW_NUMBER(rid)) + 1 AS approx_avg_rpb
FROM   t;
```

- `approx_max_rpb` ~ “이 테이블에서 한 블록에 담긴 행 슬롯 수의 최대(근사)”  
- `approx_avg_rpb` ~ “표본 기준 평균 블록당 행 수”

RPB(개념적)가 크면, **비트맵 조각 하나에 대응하는 행 수**가 많아지므로  
**비트열 길이**도 길어지지만, 그만큼 **연속 1/0 구간이 길어질 가능성**이 있어  
압축 효율은 상황에 따라 좋아질 수 있다.

### 7.2 테이블 구조 변경과 RPB

시간이 지나면서 테이블 구조가 다음과 같이 바뀔 수 있다.

- 컬럼이 많이 추가되고, 평균 행 길이가 커짐.
- PCTFREE 등이 달라져 블록당 행 수가 줄어듦.
- 대량 삭제/삽입으로 일부 블록은 거의 비어 있고 일부는 꽉 차 있는 상태가 됨.

이 경우:

- **처음 비트맵 인덱스를 생성할 때의 행 배치/압축 패턴**과
- 이후 테이블 상태가 상당히 달라지게 된다.

결과적으로:

- 비트맵 인덱스의 각 조각이 “실제 데이터 분포”와 덜 맞는 비트열을 갖게 되고,
- BITMAP AND/OR 연산 후 ROWID 변환 시 **불필요한 블록 접근**이 늘어날 수 있다.

이럴 때 **인덱스 REBUILD**를 하면, 현재 행 배치 상태에 맞게  
비트맵 조각이 다시 생성되므로:

- 세그먼트 크기 감소,
- BITMAP 연산 비용 감소,

와 같은 효과를 기대할 수 있다(정도는 환경마다 다르며, 실제 측정이 필수다). :contentReference[oaicite:12]{index=12}  

---

## 8. 비트맵 인덱스의 DML·동시성 이슈

### 8.1 왜 OLTP와 상극인가?

Ask Tom에서 반복적으로 언급되는 내용 중 하나는,  
**“비트맵 인덱스는 한 비트만 잠글 수 없기 때문에, 인덱스 엔트리 단위로 잠긴다”** 는 점이다. :contentReference[oaicite:13]{index=13}  

- 한 비트맵 엔트리는 `(키 값, ROWID 범위, 비트열)`로  
  **해당 범위의 다수 행을 한꺼번에 표현**한다.
- 어떤 행 하나를 UPDATE/DELETE 해도,  
  그 행이 속한 **비트맵 조각 전체**를 잠금/갱신해야 한다.
- 따라서 같은 조각 범위 안의 다른 행을 업데이트하려는 세션과  
  **경합**을 일으키기 쉽다.

DW/OLAP에서는 보통:

- DML 빈도가 낮고,
- 배치로 한 번에 작업하는 경우가 많아서

이 문제가 상대적으로 덜 두드러진다.

하지만 OLTP 환경에서:

- 다수의 세션이 동시에 같은 테이블에 UPDATE/DELETE를 수행하면,
- 비트맵 인덱스가 **병목 지점**으로 작동할 수 있다.

### 8.2 간단한 동시성 실험(개념 시나리오)

1. `sales` 테이블의 `region` 컬럼에 비트맵 인덱스가 있는 상태에서,
2. 두 세션이 같은 `region='EMEA'` 범위를 집중적으로 업데이트한다고 하자.

세션 1:

```sql
UPDATE sales
SET    amount = amount * 1.01
WHERE  region = 'EMEA'
AND    sale_id BETWEEN 100000 AND 100500;
```

세션 2(동시에):

```sql
UPDATE sales
SET    amount = amount * 1.02
WHERE  region = 'EMEA'
AND    sale_id BETWEEN 100300 AND 100800;
```

- 두 UPDATE 범위가 **겹치고**,  
- 비트맵 인덱스 상에서는 같은 비트맵 조각을 공유할 가능성이 크다.
- 이때 세션 간 대기/경합이 발생하기 쉽다.

같은 상황에서 **B-Tree 인덱스**라면, 각 행은 독립적인 ROWID 엔트리로 표현되므로  
잠금 범위가 상대적으로 작다.

정리하면:

- **DW/OLAP**처럼 **읽기 위주 + 저빈도 배치 DML**에서는 비트맵 인덱스가 매우 유용하다.
- **OLTP**처럼 **고빈도/고동시성 DML**에서는  
  **비트맵 인덱스를 피하는 것이 일반적인 권장사항**이다. :contentReference[oaicite:14]{index=14}  

---

## 9. 파티셔닝 + 비트맵 인덱스

### 9.1 RANGE 파티션 + 로컬 비트맵 인덱스

대용량 DW에서 전형적인 패턴:

- `SALES`를 `sale_dt` 기준 RANGE 파티션 (예: 월별/분기별)  
- 각 파티션에 대해 **로컬 비트맵 인덱스** 생성

예시:

```sql
DROP TABLE sales_part PURGE;

CREATE TABLE sales_part (
  sale_id     NUMBER       NOT NULL,
  sale_dt     DATE         NOT NULL,
  region      VARCHAR2(6)  NOT NULL,
  channel     VARCHAR2(6)  NOT NULL,
  category    VARCHAR2(10) NOT NULL,
  amount      NUMBER(12,2) NOT NULL,
  CONSTRAINT pk_sales_part PRIMARY KEY (sale_id)
)
PARTITION BY RANGE (sale_dt) (
  PARTITION p2024m01 VALUES LESS THAN (DATE '2024-02-01'),
  PARTITION p2024m02 VALUES LESS THAN (DATE '2024-03-01'),
  PARTITION p2024m03 VALUES LESS THAN (DATE '2024-04-01'),
  PARTITION pmax    VALUES LESS THAN (MAXVALUE)
);

-- 파티션 로컬 비트맵 인덱스
CREATE BITMAP INDEX bix_sp_region
ON sales_part(region)
LOCAL;

CREATE BITMAP INDEX bix_sp_channel
ON sales_part(channel)
LOCAL;
```

쿼리:

```sql
SELECT COUNT(*), SUM(amount)
FROM   sales_part
WHERE  sale_dt  BETWEEN DATE '2024-02-10' AND DATE '2024-02-20'
AND    region   = 'EMEA'
AND    channel  = 'WEB';
```

- 옵티마이저는 **파티션 프루닝**으로 필요한 파티션만 읽고,  
- 그 파티션의 로컬 비트맵 인덱스만 사용한다. :contentReference[oaicite:15]{index=15}  

장점:

- 파티션 단위 **트렁케이트/교체/재적재** 시 인덱스도 함께 관리하기 쉽다.
- 특정 기간의 인덱스만 **REBUILD** 할 수 있어 유지보수 부담을 줄인다.

---

## 10. Bitmap Join Index (BJI) 개념과 예제

### 10.1 개념

**Bitmap Join Index**는  
“**조인 결과**를 대상으로 비트맵 인덱스를 미리 만들어 두는 것”이다. :contentReference[oaicite:16]{index=16}  

예:

- 디멘전 테이블: `DIM_PRODUCT(prod_id, brand, cate, ...)`
- 팩트 테이블: `SALES(prod_id, amount, sale_dt, ...)`

일반적으로 `brand` 조건을 쓰면:

1. `DIM_PRODUCT`에서 `brand = 'BR_A'` 인 `prod_id` 리스트를 구하고,
2. 이 `prod_id` 값으로 `SALES`를 조인하여 필터링한다.

반면 BJI를 쓰면:

- 인덱스에서 `brand = 'BR_A'`에 대응하는 **비트맵(= SALES의 ROWID 집합)** 을  
  바로 꺼내서 사용하는 식으로 동작한다.

### 10.2 예제

#### 10.2.1 디멘전/팩트 준비

```sql
DROP TABLE dim_product PURGE;

CREATE TABLE dim_product (
  prod_id  NUMBER PRIMARY KEY,
  brand    VARCHAR2(20) NOT NULL,
  cate     VARCHAR2(20) NOT NULL
);

BEGIN
  FOR p IN 1..10000 LOOP
    INSERT INTO dim_product
    VALUES(
      p,
      CASE MOD(p,5)
        WHEN 0 THEN 'BR_A'
        WHEN 1 THEN 'BR_B'
        WHEN 2 THEN 'BR_C'
        WHEN 3 THEN 'BR_D'
        ELSE     'BR_E'
      END,
      CASE MOD(p,4)
        WHEN 0 THEN 'CAT1'
        WHEN 1 THEN 'CAT2'
        WHEN 2 THEN 'CAT3'
        ELSE     'CAT4'
      END
    );
  END LOOP;
  COMMIT;
END;
/
```

`SALES`에 제품 FK를 추가한다.

```sql
ALTER TABLE sales ADD (prod_id NUMBER);

UPDATE sales s
SET    prod_id = MOD(s.sale_id, 10000) + 1;

COMMIT;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_PRODUCT', cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES',       cascade=>FALSE);
END;
/
```

#### 10.2.2 Bitmap Join Index 생성

```sql
CREATE BITMAP INDEX bix_sales_brand
ON sales(dp.brand)
FROM sales s, dim_product dp
WHERE s.prod_id = dp.prod_id;

BEGIN
  DBMS_STATS.GATHER_INDEX_STATS(USER,'BIX_SALES_BRAND');
END;
/
```

이제 쿼리를 날려 본다.

```sql
SELECT COUNT(*) AS cnt,
       SUM(amount) AS total_amount
FROM   sales s
     , dim_product dp
WHERE  s.prod_id = dp.prod_id
AND    dp.brand  = 'BR_A'
AND    s.channel = 'WEB'
AND    s.sale_dt >= SYSDATE - 30;
```

실행계획을 보면, 디멘전 조인 없이:

- `BIX_SALES_BRAND` 비트맵 인덱스를 이용해  
  `brand='BR_A'`에 대응하는 **SALES의 ROWID 집합**을 빠르게 구성하고,
- 여기에 `channel`, `sale_dt` 조건을 얹어 필터링하는 패턴을 볼 수 있다. :contentReference[oaicite:17]{index=17}  

---

## 11. 비트맵 인덱스 액세스 패스 & 연산자

### 11.1 주요 연산자

실행계획에서 비트맵 관련 연산자는 다음과 같다. :contentReference[oaicite:18]{index=18}  

- `BITMAP INDEX SINGLE VALUE`
- `BITMAP INDEX RANGE SCAN`
- `BITMAP INDEX FULL SCAN`
- `BITMAP MERGE` (OR)
- `BITMAP AND`
- `BITMAP MINUS`
- `BITMAP CONVERSION TO ROWIDS`
- `BITMAP CONVERSION FROM ROWIDS` (특정 상황)

예시 쿼리 몇 가지를 통해 확인해 보자.

### 11.2 RANGE SCAN + MERGE 예제

```sql
-- 연도/월별 데이터에서 범위 조건 + 비트맵 결합
SELECT COUNT(*)
FROM   sales
WHERE  sale_dt BETWEEN DATE '2024-01-01' AND DATE '2024-03-31'
AND    region   IN ('EMEA','AMER')
AND    category = 'FOOD';
```

성공적인 경우, 실행계획 일부는 다음과 비슷할 수 있다.

```text
BITMAP MERGE
  BITMAP INDEX RANGE SCAN BIX_SALES_REGION   -- 'EMEA','AMER'
  BITMAP INDEX SINGLE VALUE BIX_SALES_CATEGORY -- 'FOOD'
```

- `region IN (...)`은 **RANGE SCAN + MERGE**로 구현될 수 있다.
- `category='FOOD'`는 `BITMAP INDEX SINGLE VALUE`.
- 둘을 `BITMAP AND`로 결합한 후, `BITMAP CONVERSION TO ROWIDS`.

---

## 12. 운영·튜닝 포인트 정리

### 12.1 언제 비트맵을 쓸 것인가?

다음 조건이면 비트맵 인덱스를 강하게 고려한다. :contentReference[oaicite:19]{index=19}  

1. **읽기/분석 위주** (DW/OLAP, 리포트, 대시보드, Ad-hoc 쿼리)
2. 컬럼의 **카디널리티가 낮거나 중간 수준**  
   - 예: 2~수백 distinct 정도에서 보통 실효가 크다.
3. **다차원 조건(AND/OR/NOT)**을 많이 사용한다.
4. **스타 스키마**에서 팩트 테이블 필터링을 최적화하고 싶다.
5. 파티셔닝과 결합해 **파티션 프루닝 + 로컬 비트맵** 구조를 활용하고 싶다.

### 12.2 언제 피해야 하나?

반대로 다음 조건이면 비트맵 인덱스를 피하는 것이 일반적으로 권장된다. :contentReference[oaicite:20]{index=20}  

1. **OLTP**  
   - 높은 동시성, 잦은 UPDATE/DELETE.
2. 카디널리티가 매우 높은 컬럼  
   - 예: 주문번호, 시리얼 번호, 이메일 등.
   - 이 경우 비트열이 사실상 B-Tree보다 이득이 거의 없다.
3. **행 단위 잠금**이 중요한 시스템  
   - 비트맵이 비트맵 조각 단위로 잠금을 걸기 때문에 경합 위험이 크다.

### 12.3 통계/플랜 관리

비트맵 인덱스를 쓸 때도 통계는 매우 중요하다.

- 열 히스토그램을 통해 **스큐**를 반영하면  
  옵티마이저가 비트맵 인덱스 사용 여부를 더 정확하게 판단한다. :contentReference[oaicite:21]{index=21}  
- 스타 스키마에서는 **스타 트랜스포메이션**과 연계되는 플랜도 관리해야 한다.
- 경우에 따라 `OPT_PARAM('_b_tree_bitmap_plans', true)` 등 특수 파라미터를 사용하는 환경도 있으나,  
  이는 DB 버전/가이드에 따라 신중히 검토해야 한다.

### 12.4 REBUILD 타이밍(특히 RPB 관점)

다음 신호가 보이면 비트맵 인덱스 REBUILD를 검토한다.

1. 대량 삭제/재적재 후 인덱스 세그먼트의 **바이트 크기**가 크게 증가함.
2. 동일한 필터 조건/통계인데도 **BITMAP AND/OR** 관련 비용이 눈에 띄게 커짐.
3. 테이블의 행 길이가 크게 늘어나 `approx_avg_rpb`가  
   이전에 비해 많이 줄어든 경우 (블록당 행 수 변화).

REBUILD 예:

```sql
ALTER INDEX bix_sales_region REBUILD;
ALTER INDEX bix_sales_channel REBUILD;
ALTER INDEX bix_sales_category REBUILD;
```

- 파티션 로컬 비트맵 인덱스라면 파티션 단위 REBUILD도 가능하다.

---

## 13. 진단/검증 스크립트 모음

### 13.1 최근 비트맵 관련 실행계획 검색

```sql
SELECT sql_id,
       child_number,
       plan_hash_value,
       operation,
       options,
       object_name
FROM   v$sql_plan
WHERE  operation LIKE 'BITMAP%'
ORDER  BY last_change_time DESC
FETCH FIRST 50 ROWS ONLY;
```

- 어떤 SQL들이 비트맵 인덱스를 쓰고 있는지 한눈에 본다.

### 13.2 인덱스 메타데이터

```sql
SELECT index_name,
       index_type,
       blevel,
       leaf_blocks,
       distinct_keys,
       clustering_factor
FROM   user_indexes
WHERE  table_name = 'SALES'
ORDER  BY index_name;
```

- `index_type`이 `BITMAP` 또는 `FUNCTION-BASED BITMAP`인지 확인.
- `clustering_factor`는 B-Tree 관점 지표지만,  
  테이블 물리 배치 상태를 보는 데 참고가 된다.

### 13.3 세그먼트 크기 확인

```sql
SELECT segment_name,
       bytes/1024/1024 AS mb
FROM   user_segments
WHERE  segment_name IN ('BIX_SALES_REGION',
                        'BIX_SALES_CHANNEL',
                        'BIX_SALES_CATEGORY',
                        'BIX_SALES_BRAND')
ORDER  BY segment_name;
```

REBUILD 전후로 세그먼트 크기 변화를 비교할 수 있다.

---

## 14. 실무 체크리스트

- [ ] 대상 컬럼이 **저/중복수**인가? (성별, 지역, 상태코드, 등급, 카테고리 등)
- [ ] 워크로드가 **읽기/분석 위주**인가? (OLTP 고동시성 DML이면 지양)
- [ ] **다차원 필터(AND/OR/NOT)**를 자주 결합하는가?
- [ ] **파티션 프루닝**과 조합 가능한가? (RANGE 파티션 + 로컬 비트맵)
- [ ] 통계(특히 히스토그램)를 적절히 수집했는가?
- [ ] 실행계획에 `BITMAP INDEX ...`, `BITMAP AND/OR/MERGE`, `BITMAP CONVERSION TO ROWIDS`가 나타나는가?
- [ ] `records_per_block` 관점에서 테이블의 **블록당 행 수 분포**가 크게 변하지 않았는가?
- [ ] 대량 삭제/재적재 후 **인덱스 세그먼트 크기/비용**이 과도하게 증가하지 않았는가?
- [ ] (고급) 스타 스키마에서 **Bitmap Join Index**로 디멘전 조인을 축약할 수 있는가?

---

## 15. 요약

1. **구조**  
   - 비트맵 인덱스는 **인덱스된 데이터 + ROWID 범위**를 키로 하고,  
     데이터 영역에 **압축된 비트열**을 저장하는 구조다.  
   - 하나의 인덱스 엔트리가 **여러 ROWID**를 표현한다.

2. **records_per_block (RPB)**  
   - 비트열의 각 비트를 “블록+행 슬롯”으로 매핑할 때  
     개념적으로 등장하는 **블록당 행 수 기준값**이다.  
   - 테이블의 블록당 행 수 분포 변화(행 길이, PCTFREE, 삭제/재적재 등)는  
     RPB 기반의 비트맵 구조 효율에 간접적으로 영향을 준다.  
   - 극단적으로 변하면 비트맵 인덱스 REBUILD를 고려할 수 있다.

3. **활용 영역**  
   - 저/중복수 컬럼에 대한 **다차원 필터(AND/OR/NOT)**  
   - DW/OLAP, 스타 스키마, 파티션 프루닝 환경에서 특히 강력하다.  
   - Bitmap Join Index를 사용하면 디멘전 조인을 인덱스 수준으로 끌어올려  
     팩트 필터링을 크게 가속할 수 있다.

4. **주의사항**  
   - 인덱스 엔트리가 **여러 행을 한 번에 잠그는 특성** 때문에  
     OLTP, 고동시성 DML에는 적합하지 않다.  
   - 통계/파티셔닝/REBUILD 전략까지 포함한 **전체 설계**가 중요하다.

마지막으로, 비트맵 인덱스는 “만능이 아니라 **특화된 도구**”에 가깝다.  
**언제, 어디에, 어떻게** 쓸지(또는 쓰지 않을지)를  
실제 데이터와 실행계획, I/O 통계로 **반복 검증**하는 것이  
가장 확실한 튜닝 방법이다.