---
layout: post
title: 컴퓨터시스템 - 정보 접근하기
date: 2025-07-21 21:20:23 +0900
category: 컴퓨터시스템
---
# 🧠 정보 접근하기 (Accessing Information)

컴퓨터 시스템에서 **정보에 접근하는 방법**은 성능에 매우 큰 영향을 끼친다. 이 장에서는 컴퓨터가 **어떻게 메모리에 저장된 정보에 접근하는가**, 특히 **배열과 포인터**, **구조체**, **비트 필드** 등의 C 언어 표현이 **어셈블리 코드 수준에서 어떻게 해석되는가**를 이해하는 데 중점을 둔다.

---

## 📌 주소와 포인터

컴퓨터 메모리는 바이트 주소를 기준으로 구성되어 있다. C에서는 포인터(pointer)를 통해 메모리 주소를 직접 조작할 수 있다.

```c
int x = 123;
int *p = &x;  // p는 x의 주소를 가리킨다.
```

- `p`는 x의 주소를 담고 있는 포인터
- `*p`는 해당 주소의 값을 읽거나 쓸 때 사용

포인터는 특정 **자료형**을 기반으로 해석되므로, `int *`는 4바이트 단위로 동작하는 포인터이다 (32비트 기준).

---

## 📌 배열(Array)

C에서 배열은 연속된 메모리 공간을 할당받는다. 예를 들어:

```c
int a[5] = {1, 2, 3, 4, 5};
```

이 배열은 아래와 같이 메모리에 배치된다 (4바이트 정수 기준):

```
주소:   0x1000  0x1004  0x1008  0x100C  0x1010
값:       1       2       3       4       5
```

C에서 배열 접근 `a[i]`는 사실 다음과 같은 포인터 연산이다:

```c
*(a + i)
```

따라서, `a[3]`는 `*(a + 3)`과 같다.

---

## 📌 포인터 산술(Pointer Arithmetic)

포인터 연산은 포인터의 자료형 크기에 따라 자동으로 바이트 단위 연산을 수행한다.

```c
int *p = a;      // 배열 a의 첫 번째 요소
int *q = p + 3;  // 세 번째 요소 (p + 3 * sizeof(int))
```

이처럼 `p + i`는 `p`가 가리키는 자료형의 크기만큼 곱해져 실제 주소가 계산된다.

---

## 📌 구조체(Struct)와 정렬(Alignment)

C에서 구조체는 여러 필드를 묶은 복합 자료형이다.

```c
struct Point {
    int x;
    int y;
};
```

이 구조체는 다음과 같이 메모리에 저장된다:

```
|   x (4 bytes)   |   y (4 bytes)   |
|    0x00~0x03    |    0x04~0x07    |
```

하지만 정렬 규칙에 따라 **패딩(padding)**이 삽입될 수 있다.

### ✅ 예시: 패딩 발생

```c
struct Example {
    char a;   // 1 byte
    int b;    // 4 bytes
};
```

이 구조체는 실제로 아래처럼 메모리에 저장된다:

```
|  a  | pad | pad | pad |  b  | b  | b  | b  |
| 0x0 |  x  |  x  |  x  | 0x4 | 0x5|0x6 |0x7 |
```

총 크기: **8바이트**  
패딩으로 인한 **공간 낭비** 발생

> 🎯 정렬(Alignment): 특정 타입의 자료는 메모리에서 그 크기만큼 정렬된 주소에 위치해야 성능상 유리하다.

---

## 📌 구조체 접근 예제

```c
struct Point p = {3, 7};
int x = p.x;  // 메모리에서 p의 x 필드 위치를 참조
```

컴파일러는 `p.x`를 다음과 같은 주소 계산으로 접근한다:

```assembly
mov eax, DWORD PTR [ebp - 8]  ; p.x가 저장된 메모리에서 읽기
```

---

## 📌 중첩 구조체(Nested Struct)

```c
struct Rectangle {
    struct Point bottom_left;
    struct Point top_right;
};
```

여기서 각 `Point`는 8바이트이므로, `Rectangle`은 16바이트가 된다. 필드 접근은 계층적으로 수행된다:

```c
r.bottom_left.x  // 첫 번째 필드로부터 0바이트 오프셋
r.top_right.y    // 두 번째 Point에서 4바이트 오프셋 추가
```

---

## 📌 공용체(Union)

```c
union U {
    int i;
    float f;
};
```

공용체는 **모든 필드가 같은 메모리 공간을 공유**한다. 가장 큰 필드 기준으로 전체 크기가 결정된다.

```c
union U u;
u.i = 0x40490fdb;  // float 3.14159로 해석 가능
printf("%f\n", u.f);  // 3.14159
```

---

## 📌 비트 필드(Bit-field)

```c
struct Flags {
    unsigned int a : 1;
    unsigned int b : 3;
    unsigned int c : 4;
};
```

- 총 8비트를 3개의 필드가 나눠서 사용
- 특정 비트를 직접 조작할 수 있음

비트 필드는 하드웨어 레지스터 제어 등에 유용하게 사용된다.

---

## 📌 배열과 포인터의 차이

배열 이름 `a`는 배열의 **시작 주소**를 나타내지만, **진짜 포인터는 아니다.**

```c
int a[5];
int *p = a;     // 가능
a = p;          // 불가능 (배열 이름은 lvalue가 아님)
```

배열은 **고정된 크기**와 주소를 가지며, 포인터는 **동적으로 값 변경 가능**

---

## 📌 메모리 주소 계산의 실제 예

```c
char a[3] = {'x', 'y', 'z'};
printf("%c\n", *(a + 1));  // 'y'
```

1. `a`는 `char *` 타입으로 해석됨
2. `a + 1` → 다음 바이트 주소
3. `*` 연산을 통해 해당 주소의 값을 가져옴

이러한 연산은 컴파일러에 의해 어셈블리로 변환될 때 정확한 주소 계산을 수행함

---

## 📌 배열을 인자로 넘기기

```c
void foo(int *arr) {
    printf("%d\n", arr[2]);
}
```

배열을 넘기면 실제로는 **포인터**가 전달되므로 크기 정보는 사라진다.  
즉, `sizeof(arr)`는 `sizeof(int *)`가 된다.

> 🎯 배열의 크기가 필요하면 따로 인자로 넘겨야 한다.

---

## 📌 다차원 배열

```c
int a[3][4];  // 3행 4열

a[i][j] == *(*(a + i) + j)
```

- 행 우선(row-major) 방식으로 저장
- 각 행은 연속된 메모리 공간에 배치됨

### 메모리 주소 계산

```c
int x = a[i][j];
```

주소 계산:

\[
\text{주소} = \text{base} + (i \times \text{열의 수} + j) \times \text{sizeof(int)}
\]

---

## 📌 요약: 정보 접근의 핵심

| 개념              | 설명 |
|-------------------|------|
| 포인터            | 메모리 주소를 나타내는 변수 |
| 배열              | 연속된 메모리 공간, `a[i] == *(a + i)` |
| 구조체            | 여러 자료형의 묶음, 정렬 필요 |
| 공용체            | 여러 필드가 같은 메모리 공간 공유 |
| 비트 필드         | 변수의 개별 비트를 조작 |
| 다차원 배열        | 행 우선 순서로 저장됨 |

---

## 📚 참고: 컴파일러 최적화와 정보 접근

- 배열은 **정적 크기**일 경우 루프 언롤링 등의 최적화 대상
- 구조체는 정렬 규칙에 따라 **패딩 삽입**
- 포인터를 잘못 쓰면 **버퍼 오버플로우** 발생

---

## 🔍 예제: 포인터 배열과 배열 포인터의 차이

```c
int *a[3];     // int에 대한 포인터 3개 (포인터 배열)
int (*b)[3];   // int 3개에 대한 배열 포인터
```

이 둘은 완전히 다르다:

- `a[i]`는 포인터이며, `*a[i]`로 값을 참조
- `b`는 전체 배열을 가리키며, `(*b)[i]`로 요소에 접근

---

## ✅ 정리

정보 접근은 단순히 데이터를 읽고 쓰는 것이 아니라, **자료의 배치**, **정렬**, **포인터 연산**, **어셈블리 수준의 주소 계산**까지 포함하는 복합적인 주제다. 이를 깊이 이해하면 프로그램의 **성능 최적화**, **시스템 이해도**, **버그 예방**에 큰 도움이 된다.
