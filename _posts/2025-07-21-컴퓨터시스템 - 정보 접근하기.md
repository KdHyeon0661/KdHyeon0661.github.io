---
layout: post
title: 컴퓨터시스템 - 정보 접근하기
date: 2025-07-21 21:20:23 +0900
category: 컴퓨터시스템
---
# 정보 접근하기 (Accessing Information)

## 메모리 모델과 주소 — 바이트 주소, 정렬, 크기

- **바이트 주소(byte addressable)**: 메모리의 최소 주소 단위는 1바이트.
- **포인터 크기**: LP64 기준(리눅스 x86-64) `sizeof(void*)==8`, ILP32(32비트)에서는 4.
- **정렬(Alignment)**: 타입 `T`는 보통 `alignof(T)`의 배수 주소에 놓일 때 접근이 빠르고, 일부 ISA에서는 **미정렬 접근이 예외** 또는 자동 분해.

| 타입 | 크기(일반적) | 정렬 | 비고 |
|---|---:|---:|---|
| `char` | 1 | 1 | 항상 정렬 가능 |
| `short` | 2 | 2 | |
| `int` | 4 | 4 | |
| `float` | 4 | 4 | |
| `double` | 8 | 8 | |
| 포인터 | 8(64비트) | 8 | ABI 의존 |

---

## 주소와 포인터 — 해석의 규칙과 제약

```c
int x = 123;
int *p = &x;     // p는 &x(주소)를 담는다.
*p = 456;        // 메모리[&x]에 456 저장
```

- 포인터의 **타입**이 메모리 해석 규칙(폭·정렬)을 결정한다.
- **표준 제약**: 서로 다른 **타입의 lvalue를 통해 같은 저장 공간을 읽거나 쓰는 것**은 **strict aliasing** 위반(UB).
  - 예외: 같은 타입/호환 타입, `unsigned char`/`std::byte`로의 접근, 공용체의 활성 멤버(일부는 구현 정의).

**안전한 타입 재해석(type punning)** 패턴:

```c
#include <stdint.h>
#include <string.h>

float u32_to_float(uint32_t u){
    float f; memcpy(&f, &u, sizeof f); return f;   // alias-safe
}
```

---

## 포인터 산술 — 단위는 “바이트가 아니라 타입 크기”

- C에서 `p + i`는 **바이트가 아닌 `sizeof(*p)`** 단위로 이동.
- **허용 범위**: 같은 “배열 객체(array object)” 내(마지막 다음 요소 `one-past` 포함). 밖으로 나간 산술은 UB.

```c
int a[5] = {1,2,3,4,5};
int *p = a;              // &a[0]
int *q = p + 3;          // &a[3]
ptrdiff_t d = q - p;     // 3 (같은 배열 내에서만 정의)
```

**바이트 단위** 오프셋이 필요하면 `char*` 또는 `std::byte*`로 변환:

```c
void *base = a;
int *third = (int*)((char*)base + 3 * sizeof(int));
```

수식으로 쓰면:

$$
\text{addr}(a[i]) = \text{base}(a) + i \times \text{sizeof}(*a)
$$

---

## — 연속 저장, 인수 전달 시 decay

```c
int a[5] = {1,2,3,4,5};
a[3]          /* == *(a + 3) */
```

- **스택/전역 배열**: 메모리에 **연속** 배치.
- **함수 인자**로 전달 시**배열 이름은 포인터로 decay**: `int a[]` 매개변수는 `int *a`와 동일 의미.
  → `sizeof(a)`는 호출자와 피호출자에서 **달라진다**.

```c
void f(int a[], size_t n) {            // a는 int*로 동작, 크기 정보 없음
    printf("%zu\n", sizeof a);         // 포인터 크기 출력
}
```

**배열 크기가 필요**하면 `n`을 별도로 전달하거나 `struct`로 함께 묶는다.

---

## 다차원 배열 — 행우선(row-major)과 올바른 시그니처

C는 **행우선(row-major)**: 마지막 첨자가 **연속**.

```c
int A[3][4]; // 3행 4열, A[i][j]의 주소:
```

$$
\text{addr}(A[i][j]) = \text{base}(A) + \big(i \times 4 + j\big) \times \text{sizeof(int)}
$$

함수 시그니처(정적 차원 필요):

```c
void g(size_t r, size_t c, int A[r][c]){  // C99 VLA
    // OK: 컴파일러가 열 크기 c를 알아야 주소 산출
}
```

잘못된 예:

```c
void bad(int **p);  // 2D 배열과 호환되지 않음(행이 연속 포인터 배열이 아님)
```

---

## — 정렬과 패딩, 레이아웃 관찰

```c
#include <stddef.h>
#include <stdio.h>

struct Example {
    char  a;   // 1
    int   b;   // 4 (정렬 4)
    short c;   // 2 (정렬 2)
};

int main(void){
    printf("sizeof = %zu\n", sizeof(struct Example));
    printf("off(a)=%zu, off(b)=%zu, off(c)=%zu\n",
        offsetof(struct Example,a),
        offsetof(struct Example,b),
        offsetof(struct Example,c));
}
```

예상 메모리(일반 x86-64):

```
| a | pad pad pad | b b b b | c c | pad pad |
 0    1   2   3     4..7      8 9   10 11
```

- 총 크기는 **가장 큰 정렬 단위의 배수**로 올림.
- **정렬을 제어**하려면:
  - C11: `_Alignas(T)` / `alignas(T)`
  - GNU 확장: `__attribute__((packed))` (외부 프로토콜/파일 포맷 한정, **CPU 접근 페널티/미정렬 예외** 주의)
  - MSVC: `#pragma pack(push,1)` … `#pragma pack(pop)`

**성능 최적화**: 필드를 **큰 것→작은 것** 순으로 배치하여 padding 최소화.

---

## 구조체 접근의 어셈블리 관점 — 필드 오프셋 사용

예제:

```c
struct Point { int x; int y; };

int sum_xy(struct Point *p){
    return p->x + p->y;
}
```

대략적 x86-64(System V) 어셈블리(개념):

```
sum_xy:
  mov eax, DWORD PTR [rdi+0]   ; x at +0
  add eax, DWORD PTR [rdi+4]   ; y at +4
  ret
```

- 컴파일러는 `offsetof(Point,x)==0`, `offsetof(Point,y)==4`를 사용.
- **중첩 구조체**는 오프셋의 합으로 접근.

---

## — 동일 저장 영역 공유와 안전한 용법

```c
union U { uint32_t u; float f; };

float pun(uint32_t bits){
    union U v = { .u = bits };
    return v.f;     // 일부 구현에서 허용, alias 규칙은 구현 정의
}
```

- **타입 별칭 규칙**에 민감. 이식성과 표준 안전성을 위해 **`memcpy` 선호**.
- 공용체는 **최대 필드 크기**로 크기가 결정, 정렬은 **가장 엄격한 필드 정렬**을 따른다.

---

## — 편하지만 이식성 주의

```c
struct Flags {
    unsigned a : 1;
    unsigned b : 3;
    unsigned c : 4;  // 합 8비트
};
```

- **배치 순서, 서명성, 엔디안, 상위/하위 비트 채움** 등 **구현 정의**.
- **네트워크/디스크 포맷**에는 비추천. → **마스크/시프트**를 쓰는 것이 이식성·명확성 ↑.

대안(포터블):

```c
struct Header { uint16_t raw; };
#define HDR_A(x)   (((x).raw >> 15) & 0x1)
#define HDR_B(x)   (((x).raw >> 12) & 0x7)
#define HDR_C(x)   (((x).raw >>  8) & 0xF)

```

---

## — 바이트 순서가 해석을 바꾼다

```
u32 = 0x12345678
리틀: 78 56 34 12
빅   : 12 34 56 78
```

- **필드 단위** 접근(예: `int` 읽기)은 ABI가 보장하는 내부 엔디안에 의존.
- **프로토콜/파일 입출력**엔 고정 순서(예: network byte order, 빅엔디안)를 **명시**하고 변환 함수를 사용할 것.

---

## 별칭(strict aliasing)과 `restrict` — 최적화의 열쇠

- **strict aliasing**: 서로 다른 불호환 타입 포인터가 같은 메모리를 가리킨다고 **가정하지 않음** → 재주기화 불필요로 **벡터화/레지스터 유지 최적화** 가능.
- **`restrict`(C99)**: 해당 포인터를 통해 접근하는 메모리를 **다른 포인터가 가리키지 않는다**는 약속.

```c
void saxpy(size_t n, float a,
           float *restrict x,
           float *restrict y){
    for(size_t i=0;i<n;i++) y[i] += a * x[i];
}
```

- 약속을 깨면 UB. 하지만 유지 시 컴파일러는 **로드 병합/벡터화**를 공격적으로 수행.

---

## `const`/`volatile` — 의미와 사용처

- `const`: **쓰기 금지**(논리적 상수). 최적화에 도움.
- `volatile`: **컴파일러가 제거/재배열하면 안 되는 부작용**(MMIO, 신호 플래그).
  - `volatile`은 **원자성/메모리 질서**를 보장하지 않는다(C11 원자 연산 사용 권장).

메모리 맵 IO 예:

```c
#define REG32(addr) (*(volatile uint32_t*)(addr))

REG32(0x40000000u) = 0x1;            // 장치 레지스터 쓰기
```

---

## 성능: 캐시·지역성·AoS vs SoA

- **공간 지역성**: 인접 데이터 접근이 빠름 → 배열 순차 접근 유리.
- **시간 지역성**: 최근 접근 데이터 재사용.
- **구조체 배열(AoS)** vs **배열 구조체(SoA)**:

```c
// AoS
struct P{ float x,y,z; };
struct P pt[N];

// SoA
float xs[N], ys[N], zs[N];
```

- 특정 필드만 대량 처리(예: 모든 `x` 갱신) → **SoA**가 캐시 적중·벡터화 유리.
- 즉, **접근 패턴**에 맞춰 레이아웃을 선택.

루프 예(연속 접근 최적):

```c
for(size_t i=0;i<N;i++) sum += a[i];   // 스트라이드 1
```

나쁜 패턴(큰 stride, 캐시 미스↑):

```c
for(size_t j=0;j<M;j++)
  for(size_t i=0;i<N;i++)
    use(A[i][j]); // 열 우선 접근(행우선 저장과 충돌)
```

---

## 실전: 안전한 필드/오프셋 계산 유틸

```c
#include <stddef.h>
#define OFFSETOF(T, m) ((size_t)&(((T*)0)->m))

struct H { uint32_t len; uint16_t type; uint16_t flags; };

_Static_assert(OFFSETOF(struct H,flags)==6, "ABI mismatch");
```

메모리에서 **바이트 오프셋**으로 접근하려면 `char*`를 사용:

```c
void set_u16(void *base, size_t off, uint16_t v){
    *(uint16_t*)((char*)base + off) = v;   // 정렬 보장 여부는 별도 고려
}
```

---

## 미정렬 접근 — 휴대성과 속도

- 일부 ISA(x86)는 미정렬 로드/스토어를 지원하나 **느릴 수 있음**.
- ARM구형/특정 모드에선 **미정렬 예외** → `memcpy`/정렬된 버퍼 사용.

```c
uint16_t load_u16_unaligned(const void *p){
    uint16_t v; memcpy(&v, p, sizeof v); return v;  // 휴대성↑
}
```

---

## 위험 사례 — 범위 밖 산술/비교, dangling, void* 규칙

- **범위 밖 포인터 산술/비교**: UB. **같은 배열** 내에서만.
- **dangling**: 지역변수 주소를 반환/보관 금지.

```c
int* bad(void){ int x=0; return &x; }  // UB
```

- `void*` 산술은 표준상 **정의 안 됨**(GNU 확장으로 1바이트 단위인 것처럼 동작하기도). **`char*`로 변환할 것**.

---

## 예제: 네트워크 헤더 파싱(포터블/고성능 버전)

### 포터블(엔디안·정렬 대응)

```c
#include <stdint.h>
#include <string.h>

static inline uint16_t get_be16(const void* p){
    unsigned char b[2]; memcpy(b, p, 2);
    return (uint16_t)b[0]<<8 | b[1];
}

struct ipv4_view {
    const unsigned char *buf; // 20바이트 이상 가정
};
static inline uint8_t  ip_ver(const struct ipv4_view* v){ return v->buf[0] >> 4; }
static inline uint8_t  ip_ihl(const struct ipv4_view* v){ return v->buf[0] & 0xF; }
static inline uint16_t ip_len(const struct ipv4_view* v){ return get_be16(v->buf+2); }
```

### — 컴파일러 내장 사용

```c
#include <arpa/inet.h>

struct ipv4_hdr {
    uint8_t  v_ihl;
    uint8_t  tos;
    uint16_t tot_len;    // network order
    /* ... */
} __attribute__((packed));

uint16_t total_len(const struct ipv4_hdr* h){
    return ntohs(h->tot_len);
}
```

> 외부와의 인터페이스에는 **바이트 순서 명시**·정렬 보장/검증을 함께.

---

## 수식으로 보는 주소 계산 요약

단일 배열:
$$
\text{addr}(a[i]) = \text{base}(a) + i\cdot \text{sizeof}(*a)
$$

2차원(행우선, 열= C):
$$
\text{addr}(A[i][j]) = \text{base}(A) + (i\cdot C + j)\cdot \text{sizeof}(\text{elem})
$$

중첩 구조체:
$$
\text{addr}(s.f.g) = \text{base}(s) + \text{offsetof}(S,f) + \text{offsetof}(\text{type}(f),g)
$$

---

## 종합 체크리스트 — 정확·안전·빠르게

1. **배열 vs 포인터**: decay/크기 상실을 이해하고 길이는 별도 전달.
2. **정렬/패딩**: ABI에 맞추고, 외부 포맷엔 packed+변환층.
3. **엔디안**: I/O 경계에서 변환 함수 사용(hton/ntoh).
4. **별칭 규칙**: `unsigned char` or `memcpy`로 재해석. `restrict`는 지킬 때만.
5. **범위 내 산술/비교**: 같은 배열 내에서만.
6. **미정렬**: 이식성 필요하면 `memcpy`, 성능은 프로파일링.
7. **접근 패턴**: 행우선, 스트라이드 1, SoA 검토.
8. **API 시그니처**: 다차원은 `T[r][c]`/포인터-배열 조합으로 선언.
9. **비트필드 금지(외부 포맷)**: 마스크/시프트 사용.
10. **검증**: `_Static_assert`, `offsetof`, 런타임 `sizeof` 로그로 ABI 보증.

---

## 연습 문제

1) `struct { char a; int b; short c; }`의 오프셋/총 크기를 `offsetof`로 출력하고, 필드 순서를 바꿔 padding을 최소화해라.
2) `int A[H][W]`에 대해 **열 우선** 순회를 **행 우선**으로 바꿔 성능을 비교하고 이유를 설명하라.
3) 포인터 두 개 `p,q`에 대해 `q-p`가 정의되는 조건을 서술하라.
4) 비트필드 대신 마스크/시프트로 12비트 헤더에서 `[11:9]=a(3), [8:4]=b(5), [3:0]=c(4)`를 추출/삽입하는 매크로를 작성하라.
5) `restrict`를 사용/미사용 두 버전의 `axpy`를 만들어 최적화 차이를 확인하라.
6) 리틀엔디안 시스템에서 `0x12345678`을 `uint8_t[4]`로 직렬화/역직렬화하는 함수를 작성하라.

---

## 참고 코드 모음

### 구조체 레이아웃 검사

```c
#include <stdio.h>
#include <stddef.h>

struct E { char a; int b; short c; };

int main(void){
    printf("sizeof(E)=%zu\n", sizeof(struct E));
    printf("off(a)=%zu off(b)=%zu off(c)=%zu\n",
        offsetof(struct E,a), offsetof(struct E,b), offsetof(struct E,c));
}
```

### 안전한 바이트 오프셋 접근

```c
#include <stdint.h>
#include <string.h>

uint32_t load_be32(const void* p){
    unsigned char b[4]; memcpy(b, p, 4);
    return (uint32_t)b[0]<<24 | (uint32_t)b[1]<<16 | (uint32_t)b[2]<<8 | b[3];
}

void store_be32(void* p, uint32_t v){
    unsigned char b[4] = { v>>24, v>>16, v>>8, v };
    memcpy(p, b, 4);
}
```

### 포인터 배열 vs 배열 포인터

```c
int *pa[3];     // 포인터 3개
int (*pb)[3];   // int[3]에 대한 포인터

void demo(void){
    int x=1,y=2,z=3;
    pa[0]=&x; pa[1]=&y; pa[2]=&z;     // 각각 다른 곳

    int arr[3]={10,20,30};
    pb = &arr;                        // 하나의 연속 배열을 가리킴
    printf("%d %d\n", *pa[0], (*pb)[1]);
}
```

---

## 결론 — “주소를 계산하는 법을 알면 성능과 안정성이 따라온다”

정보 접근은 **주소 계산**·**정렬/패딩**·**별칭 규칙**·**엔디안 변환**·**접근 패턴(지역성)**의 문제다.
어셈블리 수준의 **오프셋·로드/스토어** 관점으로 사고하면,
**버그(UB) 예방**, **ABI 호환**, **캐시 친화 레이아웃**이 자연스럽게 달성된다.

> 정확성은 **표준 규칙**에서, 속도는 **데이터 배치와 접근 패턴**에서 나온다.
> 오늘 코드에 **offsetof/sizeof/_Static_assert**와 **행우선 접근**을 도입하라.
> 내일의 성능 리그레션이 사라진다.
