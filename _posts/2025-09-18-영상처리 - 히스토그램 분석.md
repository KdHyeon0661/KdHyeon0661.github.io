---
layout: post
title: 영상처리 - 히스토그램 분석
date: 2025-09-18 22:25:23 +0900
category: 영상처리
---
# 히스토그램 분석

## 1. 히스토그램이란?

영상의 픽셀 값 분포를 **빈도수(frequency)** 로 나타낸 **막대 그래프**입니다. 8-bit 채널 \(v\in\{0,1,\dots,255\}\)에 대해, 각 값이 등장한 **픽셀 수**를 셉니다.

- 그레이스케일: 1개(밝기) 채널의 분포.
- 컬러: **B,G,R** 각각의 분포 또는 **휘도(명도, Luma)** 분포.  
  표준적 Luma(대략 sRGB/BT.601)는  
  \[
  Y \approx 0.299R + 0.587G + 0.114B
  \]

**활용**  
- 노출/대비/감마 조정의 기준  
- 자동 대비(스트레칭/이퀄라이즈) 기반 데이터  
- 임계값(Threshold) 추정(Otsu 등)의 기초 통계

---

## 2. 구현 개요

- **대화 상자**에 **히스토그램 전용 뷰(커스텀 컨트롤)** 를 넣고,  
  - 채널 선택: R/G/B/Luma  
  - **정규화**(Normalize) On/Off  
  - **로그 스케일**(Log) On/Off  
- **BGRA32 DIB**(IppDib)에서 256-bin histogram 계산,  
  - **최솟값/최댓값/평균/표준편차/중앙값** 통계도 함께 산출  
- **View → Histogram… (Ctrl+H)** 메뉴로 열기

---

## 3. 전체 코드

> 파일을 나눠도 되지만, 이해를 돕기 위해 한 블록에 **구분 주석**으로 제공합니다.

```cpp
// ==========================
// res/resource.h (추가/확인)
// ==========================
#pragma once

// --- 기존 항목은 유지 ---
// (예: IDR_MAINMENU, IDR_ACCEL, ID_VIEW_* 등)

// Dialog
#define IDD_HISTOGRAM                  330

// Controls (Histogram dialog)
#define IDC_HIST_VIEW                  1201
#define IDC_CH_R                       1202
#define IDC_CH_G                       1203
#define IDC_CH_B                       1204
#define IDC_CH_LUMA                    1205
#define IDC_CH_NORMALIZE               1206
#define IDC_CH_LOGSCALE                1207
#define IDC_STAT_R                     1210
#define IDC_STAT_G                     1211
#define IDC_STAT_B                     1212
#define IDC_STAT_L                     1213

// Menu command
#define ID_VIEW_HISTOGRAM              40400


// ==========================
// res/ImageTool.rc (추가)
// ==========================
#include <windows.h>
#include "resource.h"
#include <commctrl.h>

// ... 기존 MENU / ACCEL 테이블에 항목 추가 ...
// View 메뉴 안에 "Histogram..." 를 추가합니다.
IDR_MAINMENU MENU
BEGIN
    POPUP "&File"
    BEGIN
        MENUITEM "New &Window\tCtrl+N",      40001   // 예: ID_APP_NEWWINDOW
        MENUITEM "&Open...\tCtrl+O",         40002   // 예: ID_FILE_OPEN
        MENUITEM "Save &As...\tCtrl+S",      40003   // 예: ID_FILE_SAVEAS
        MENUITEM SEPARATOR
        MENUITEM "E&xit",                    0xF060
    END
    POPUP "&Edit"
    BEGIN
        MENUITEM "&Copy\tCtrl+C",            40010   // 예: ID_EDIT_COPY
        MENUITEM "&Paste\tCtrl+V",           40011   // 예: ID_EDIT_PASTE
        MENUITEM "&Invert\tCtrl+I",          40100   // 예: ID_EDIT_INVERT
    END
    POPUP "&View"
    BEGIN
        MENUITEM "Zoom &In\t+",              40020   // 예: ID_VIEW_ZOOMIN
        MENUITEM "Zoom &Out\t-",             40021   // 예: ID_VIEW_ZOOMOUT
        MENUITEM "&Actual Size 100%\t0",     40022   // 예: ID_VIEW_ZOOMRESET
        MENUITEM SEPARATOR
        MENUITEM "&Histogram...\tCtrl+H",    ID_VIEW_HISTOGRAM
    END
    POPUP "&Image"
    BEGIN
        MENUITEM "Brightness / Contrast...\tCtrl+B", 40200 // 예
        MENUITEM "Gamma Correction...\tCtrl+G",      40300 // 예
    END
END

// Accelerator 추가 (Ctrl+H)
IDR_ACCEL ACCELERATORS
BEGIN
    "H",  ID_VIEW_HISTOGRAM, VIRTKEY, CONTROL
END

// Histogram Dialog
IDD_HISTOGRAM DIALOGEX 0, 0, 360, 260
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Histogram"
FONT 9, "Segoe UI"
BEGIN
    // 좌측: 히스토그램 뷰 박스 (커스텀 자식 윈도우가 여기 영역에 생성됨)
    LTEXT       "", -1, 10, 10,  260, 200, SS_BLACKFRAME
    // 실제 히스토그램 뷰의 위치/크기는 OnInit에서 CreateWindow로 생성하여 동일 영역에 맞춥니다.

    GROUPBOX    "Channels", -1,  280, 10, 70, 78
    AUTOCHECKBOX "R", IDC_CH_R,         286, 24,  50, 10, WS_TABSTOP
    AUTOCHECKBOX "G", IDC_CH_G,         286, 38,  50, 10, WS_TABSTOP
    AUTOCHECKBOX "B", IDC_CH_B,         286, 52,  50, 10, WS_TABSTOP
    AUTOCHECKBOX "Luma", IDC_CH_LUMA,   286, 66,  50, 10, WS_TABSTOP

    GROUPBOX    "Options", -1,  280, 92, 70, 54
    AUTOCHECKBOX "Normalize", IDC_CH_NORMALIZE, 286, 106, 60, 10, WS_TABSTOP
    AUTOCHECKBOX "Log scale", IDC_CH_LOGSCALE, 286, 120, 60, 10, WS_TABSTOP

    LTEXT "R:", -1, 10, 215, 10, 10
    LTEXT "",  IDC_STAT_R,  20, 215, 250, 10, SS_LEFT

    LTEXT "G:", -1, 10, 228, 10, 10
    LTEXT "",  IDC_STAT_G,  20, 228, 250, 10, SS_LEFT

    LTEXT "B:", -1, 10, 241, 10, 10
    LTEXT "",  IDC_STAT_B,  20, 241, 250, 10, SS_LEFT

    LTEXT "Y:", -1, 10, 254, 10, 10
    LTEXT "",  IDC_STAT_L,  20, 254, 250, 10, SS_LEFT

    DEFPUSHBUTTON "OK",     IDOK,     280, 200,  70, 14
END


// ==========================
// src/Histogram.h
// ==========================
#pragma once
#include <cstdint>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <string>
#include <vector>

struct Hist256 {
    uint32_t bin[256];
    void clear() { std::memset(bin, 0, sizeof(bin)); }
    uint32_t maxCount() const {
        uint32_t m=0; for (int i=0;i<256;++i) m = std::max(m, bin[i]); return m;
    }
    uint64_t sum() const {
        uint64_t s=0; for (int i=0;i<256;++i) s += bin[i]; return s;
    }
};

struct HistStats {
    int     minv = 255;
    int     maxv = 0;
    double  mean = 0.0;
    double  stdev = 0.0;
    int     median = 0;
};

struct HistogramData {
    Hist256 r, g, b, y;      // R/G/B/Luma
    uint64_t total = 0;      // 총 픽셀 수
    HistStats rstat, gstat, bstat, ystat;
};

inline int clamp255(int v){ return v<0?0:(v>255?255:v); }

// count[]로부터 기본 통계 구하기
inline void compute_stats(const Hist256& h, HistStats& s) {
    // min/max
    s.minv = 255; s.maxv = 0;
    for (int i=0;i<256;++i) if (h.bin[i]) { s.minv = std::min(s.minv, i); s.maxv = std::max(s.maxv, i); }
    // mean, variance
    const double N = (double)h.sum();
    if (N <= 0) { s.mean=0; s.stdev=0; s.median=0; return; }
    double sum=0.0, sum2=0.0;
    for (int i=0;i<256;++i) { sum += i * (double)h.bin[i]; sum2 += (double)i*i * (double)h.bin[i]; }
    s.mean = sum / N;
    double var = sum2 / N - s.mean * s.mean;
    s.stdev = (var>0)? std::sqrt(var) : 0.0;
    // median
    uint64_t half = (uint64_t)(N/2);
    uint64_t acc = 0;
    for (int i=0;i<256;++i){ acc += h.bin[i]; if (acc >= half){ s.median = i; break; } }
}

inline std::wstring fmt_stats(const HistStats& s) {
    wchar_t buf[256];
    swprintf(buf, 256, L"min=%d  max=%d  mean=%.1f  std=%.1f  med=%d", s.minv, s.maxv, s.mean, s.stdev, s.median);
    return buf;
}


// ==========================
// src/HistogramCompute.h
// BGRA32 DIB에서 히스토그램 계산
// ==========================
#pragma once
#include "IppDib.h"
#include "Histogram.h"

// step: 샘플링 간격(1=모든 픽셀, 2=격자 샘플 등)
inline void ComputeHistogramFromDIB(const IppDib& dib, HistogramData& out, int step=1) {
    out.r.clear(); out.g.clear(); out.b.clear(); out.y.clear();
    out.total = 0;

    if (!dib) return;
    const int W = dib.width();
    const int H = dib.height();
    const int S = dib.stride();

    for (int y=0; y<H; y+=step) {
        const uint8_t* row = (const uint8_t*)dib.bits() + (size_t)y * S;
        for (int x=0; x<W; x+=step) {
            const uint8_t* p = &row[x*4];
            int B=p[0], G=p[1], R=p[2];
            // 채널 증가
            out.b.bin[B]++; out.g.bin[G]++; out.r.bin[R]++;
            // luma (0.299R + 0.587G + 0.114B)
            int Y = clamp255((int)std::lround(0.299*R + 0.587*G + 0.114*B));
            out.y.bin[Y]++;
            out.total++;
        }
    }
    compute_stats(out.r, out.rstat);
    compute_stats(out.g, out.gstat);
    compute_stats(out.b, out.bstat);
    compute_stats(out.y, out.ystat);
}


// ==========================
// src/HistogramCtrl.h
// 히스토그램 그리기용 커스텀 컨트롤
// ==========================
#pragma once
#include <windows.h>
#include "Histogram.h"

struct HistViewState {
    const HistogramData* data = nullptr; // 외부에서 제공
    bool showR=true, showG=true, showB=true, showY=false;
    bool normalize=true;  // 각 채널 최대=1 정규화
    bool logscale=false;  // log(1+v) 스케일
};

ATOM RegisterHistogramCtrl(HINSTANCE hinst);
HWND CreateHistogramCtrl(HWND hParent, HINSTANCE hinst, int x, int y, int w, int h, int ctrlId);
void HistView_SetState(HWND hCtrl, const HistViewState& st); // 상태 전달

// ==========================
// src/HistogramCtrl.cpp
// ==========================
#include "HistogramCtrl.h"
#include <algorithm>
#include <vector>
#include <string>

static const wchar_t* kHistCtrlClass = L"HistogramCtrl.Class";

static LRESULT CALLBACK HistCtrlProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    HistViewState* st = (HistViewState*)GetWindowLongPtrW(h, GWLP_USERDATA);
    switch (m) {
    case WM_NCCREATE: return TRUE;

    case WM_CREATE:
    {
        CREATESTRUCTW* cs = (CREATESTRUCTW*)l;
        SetWindowLongPtrW(h, GWLP_USERDATA, (LONG_PTR)cs->lpCreateParams);
        return 0;
    }
    case WM_PAINT:
    {
        PAINTSTRUCT ps; HDC dc = BeginPaint(h, &ps);
        RECT rc; GetClientRect(h, &rc);
        HBRUSH bg = CreateSolidBrush(RGB(255,255,255));
        FillRect(dc, &rc, bg); DeleteObject(bg);

        if (!st || !st->data || st->data->total==0) {
            const wchar_t* t=L"(no data)";
            SetBkMode(dc, TRANSPARENT);
            TextOutW(dc, 10, 10, t, lstrlenW(t));
            EndPaint(h, &ps); return 0;
        }

        // 여백과 그리드
        const int L=30, Rm=8, T=10, B=20;
        RECT plot{ rc.left+L, rc.top+T, rc.right-Rm, rc.bottom-B };
        FrameRect(dc, &plot, (HBRUSH)GetStockObject(BLACK_BRUSH));

        // 그리드 (수직 32 step, 수평 4 step)
        HPEN gpen = CreatePen(PS_DOT, 1, RGB(200,200,200));
        HPEN old = (HPEN)SelectObject(dc, gpen);
        for (int i=32;i<256;i+=32) {
            int x = plot.left + (i * (plot.right-plot.left))/255;
            MoveToEx(dc, x, plot.top, nullptr);
            LineTo(dc, x, plot.bottom);
        }
        for (int r=1;r<=3;++r) {
            int y = plot.bottom - r*(plot.bottom-plot.top)/4;
            MoveToEx(dc, plot.left, y, nullptr);
            LineTo(dc, plot.right, y);
        }
        SelectObject(dc, old); DeleteObject(gpen);

        // 채널별 최댓값(정규화/공통) 결정
        auto channelMax = [&](const Hist256& h)->double{
            double m = (double)h.maxCount();
            if (st->logscale) m = std::log1p(m);
            return (m<=0)?1:m;
        };
        double scaleR=1, scaleG=1, scaleB=1, scaleY=1;
        double commonMax=1;
        if (st->normalize) {
            if (st->showR) scaleR = channelMax(st->data->r);
            if (st->showG) scaleG = channelMax(st->data->g);
            if (st->showB) scaleB = channelMax(st->data->b);
            if (st->showY) scaleY = channelMax(st->data->y);
        } else {
            // 공통 최대
            double m=1;
            if (st->showR) m = std::max(m, channelMax(st->data->r));
            if (st->showG) m = std::max(m, channelMax(st->data->g));
            if (st->showB) m = std::max(m, channelMax(st->data->b));
            if (st->showY) m = std::max(m, channelMax(st->data->y));
            commonMax = (m<=0)?1:m;
            scaleR = scaleG = scaleB = scaleY = commonMax;
        }

        auto drawChannel = [&](const Hist256& h, COLORREF col, double scale) {
            HPEN pen = CreatePen(PS_SOLID, 1, col);
            HPEN oldp = (HPEN)SelectObject(dc, pen);
            int prevX=plot.left, prevY=plot.bottom;
            bool started=false;
            for (int i=0;i<256;++i) {
                double v = (double)h.bin[i];
                if (st->logscale) v = std::log1p(v);
                double t = (scale<=0)?0 : (v/scale);
                if (t<0) t=0; if (t>1) t=1;
                int x = plot.left + (i * (plot.right-plot.left))/255;
                int y = plot.bottom - (int)std::lround(t * (plot.bottom-plot.top));
                if (!started) { MoveToEx(dc, x, y, nullptr); started=true; }
                else LineTo(dc, x, y);
                prevX=x; prevY=y;
            }
            SelectObject(dc, oldp); DeleteObject(pen);
        };

        if (st->showB) drawChannel(st->data->b, RGB(80,120,255), scaleB);
        if (st->showG) drawChannel(st->data->g, RGB(80,200,120), scaleG);
        if (st->showR) drawChannel(st->data->r, RGB(255,80,80),  scaleR);
        if (st->showY) drawChannel(st->data->y, RGB(120,120,120),scaleY);

        // 축 레이블 (0,128,255)
        SetBkMode(dc, TRANSPARENT);
        wchar_t t0[16], t1[16], t2[16];
        wsprintfW(t0, L"0"); wsprintfW(t1, L"128"); wsprintfW(t2, L"255");
        TextOutW(dc, plot.left-10,  plot.bottom+2, t0, lstrlenW(t0));
        TextOutW(dc, plot.left+(plot.right-plot.left)/2-10, plot.bottom+2, t1, lstrlenW(t1));
        TextOutW(dc, plot.right-14, plot.bottom+2, t2, lstrlenW(t2));

        EndPaint(h, &ps);
        return 0;
    }
    case WM_SIZE:
        InvalidateRect(h, nullptr, TRUE);
        return 0;

    default:
        return DefWindowProcW(h, m, w, l);
    }
}

ATOM RegisterHistogramCtrl(HINSTANCE hinst) {
    WNDCLASSEXW wc{ sizeof(wc) };
    wc.lpfnWndProc = HistCtrlProc;
    wc.hInstance   = hinst;
    wc.hCursor     = LoadCursor(nullptr, IDC_CROSS);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszClassName = kHistCtrlClass;
    return RegisterClassExW(&wc);
}

HWND CreateHistogramCtrl(HWND hParent, HINSTANCE hinst, int x, int y, int w, int h, int ctrlId) {
    // HistViewState* 는 나중에 HistView_SetState 로 주입
    return CreateWindowExW(0, kHistCtrlClass, L"",
        WS_CHILD | WS_VISIBLE, x,y,w,h, hParent, (HMENU)ctrlId, hinst, nullptr);
}

void HistView_SetState(HWND hCtrl, const HistViewState& st) {
    // 힙에 상태 복사 저장
    HistViewState* mem = (HistViewState*)GetWindowLongPtrW(hCtrl, GWLP_USERDATA);
    if (!mem) {
        mem = new HistViewState(st);
        SetWindowLongPtrW(hCtrl, GWLP_USERDATA, (LONG_PTR)mem);
    } else {
        *mem = st;
    }
    InvalidateRect(hCtrl, nullptr, TRUE);
}


// ==========================
// src/HistogramDlg.h
// ==========================
#pragma once
#include <windows.h>
#include "Histogram.h"
#include "HistogramCompute.h"
#include "HistogramCtrl.h"
#include "resource.h"
#include "IppDib.h"

class HistogramDlg {
public:
    HistogramDlg(HWND owner, HINSTANCE hinst, const IppDib& dib)
        : owner_(owner), hinst_(hinst), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND h, UINT m, WPARAM w, LPARAM l);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);
    void    UpdateView(HWND h);
    void    UpdateStatsText(HWND h);

private:
    HWND owner_ = nullptr;
    HINSTANCE hinst_ = nullptr;
    const IppDib& dib_;
    HistogramData data_;
    HWND hView_ = nullptr;
    HistViewState st_;
};


// ==========================
// src/HistogramDlg.cpp
// ==========================
#include "HistogramDlg.h"

INT_PTR HistogramDlg::DoModal() {
    return DialogBoxParamW(hinst_, MAKEINTRESOURCEW(IDD_HISTOGRAM),
                           owner_, DlgProc, (LPARAM)this);
}

INT_PTR CALLBACK HistogramDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m == WM_INITDIALOG) {
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self = reinterpret_cast<HistogramDlg*>(l);
        return self->OnInit(h);
    }
    auto* self = reinterpret_cast<HistogramDlg*>(GetWindowLongPtrW(h, GWLP_USERDATA));
    if (!self) return FALSE;

    switch (m) {
    case WM_COMMAND:
        return self->OnCommand(h, w, l);
    default:
        return FALSE;
    }
}

INT_PTR HistogramDlg::OnInit(HWND h) {
    // 컨트롤 초기 체크 상태
    CheckDlgButton(h, IDC_CH_R,        BST_CHECKED);
    CheckDlgButton(h, IDC_CH_G,        BST_CHECKED);
    CheckDlgButton(h, IDC_CH_B,        BST_CHECKED);
    CheckDlgButton(h, IDC_CH_LUMA,     BST_UNCHECKED);
    CheckDlgButton(h, IDC_CH_NORMALIZE,BST_CHECKED);
    CheckDlgButton(h, IDC_CH_LOGSCALE, BST_UNCHECKED);

    st_.showR=true; st_.showG=true; st_.showB=true; st_.showY=false;
    st_.normalize=true; st_.logscale=false;

    // 히스토그램 계산 (샘플링 step=1)
    ComputeHistogramFromDIB(dib_, data_, 1);
    st_.data = &data_;

    // 히스토그램 뷰 생성: .rc 에서 left=10,top=10,w=260,h=200
    RegisterHistogramCtrl(hinst_);
    hView_ = CreateHistogramCtrl(h, hinst_, 10, 10, 260, 200, IDC_HIST_VIEW);
    HistView_SetState(hView_, st_);

    UpdateStatsText(h);
    return TRUE;
}

void HistogramDlg::UpdateStatsText(HWND h) {
    SetDlgItemTextW(h, IDC_STAT_R, fmt_stats(data_.rstat).c_str());
    SetDlgItemTextW(h, IDC_STAT_G, fmt_stats(data_.gstat).c_str());
    SetDlgItemTextW(h, IDC_STAT_B, fmt_stats(data_.bstat).c_str());
    SetDlgItemTextW(h, IDC_STAT_L, fmt_stats(data_.ystat).c_str());
}

void HistogramDlg::UpdateView(HWND h) {
    st_.showR = (IsDlgButtonChecked(h, IDC_CH_R)==BST_CHECKED);
    st_.showG = (IsDlgButtonChecked(h, IDC_CH_G)==BST_CHECKED);
    st_.showB = (IsDlgButtonChecked(h, IDC_CH_B)==BST_CHECKED);
    st_.showY = (IsDlgButtonChecked(h, IDC_CH_LUMA)==BST_CHECKED);
    st_.normalize = (IsDlgButtonChecked(h, IDC_CH_NORMALIZE)==BST_CHECKED);
    st_.logscale  = (IsDlgButtonChecked(h, IDC_CH_LOGSCALE)==BST_CHECKED);
    st_.data = &data_;
    HistView_SetState(hView_, st_);
}

INT_PTR HistogramDlg::OnCommand(HWND h, WPARAM w, LPARAM) {
    switch (LOWORD(w)) {
    case IDC_CH_R:
    case IDC_CH_G:
    case IDC_CH_B:
    case IDC_CH_LUMA:
    case IDC_CH_NORMALIZE:
    case IDC_CH_LOGSCALE:
        UpdateView(h);
        return TRUE;
    case IDOK:
    case IDCANCEL:
        EndDialog(h, LOWORD(w));
        return TRUE;
    }
    return FALSE;
}


// ==========================
// src/main_multiwin.cpp (중 요부분 발췌)
// - 멀티창 프레임/상태/툴바/출력창 구조는 이전 장과 동일
// - 여기서는 Histogram 메뉴 핸들러만 추가합니다.
// ==========================
#include "HistogramDlg.h"
// ... (기존 include/전역/구조체/유틸/생성 등 동일) ...

// WndProc 안 WM_COMMAND:
    // ...
    case ID_VIEW_HISTOGRAM:
        if (st && st->dib) {
            HistogramDlg dlg(hWnd, g_hInst, st->dib);
            dlg.DoModal();
        }
        return 0;
// ...
```

---

## 4. 그리기 로직 설명

1. **데이터 준비**  
   `ComputeHistogramFromDIB()` 가 BGRA32 버퍼를 한 바퀴 돌며  
   - R/G/B 카운트 256-bin  
   - Luma \(Y=0.299R+0.587G+0.114B\) 카운트 256-bin  
   - `min/max/mean/std/median` 통계까지 계산

2. **스케일 결정**  
   - **정규화 On**: 채널별 **자기 최대치**로 0..1 스케일 → **형상 비교**에 유리  
   - 정규화 Off: **선택 채널의 공통 최대치** 기준 → **절대 빈도 비교**에 유리  
   - **로그 스케일**: \(\log(1+n)\) 를 높이로 사용 → 고/저빈도 동시 가독성 확보

3. **렌더링**  
   - 흰 배경 + 검은 테두리  
   - 수직 그리드(32 step), 수평 그리드(4 step)  
   - 채널 폴리라인(Blue/Green/Red/Gray) 오버레이  
   - 축 레이블(0 / 128 / 255)

> 필요하면 막대(bar) 스타일도 간단합니다. `MoveToEx(x, bottom); LineTo(x, y)` 를 채널마다 그리면 됩니다(시각적으로는 폴리라인이 겹침 표시가 좋아서 채택).

---

## 5. 대화 상자 동작/UX

- **Channels**: R/G/B/Luma 체크로 개별 토글  
- **Normalize**: 각 채널 peak=1로 정규화(형상 비교)  
- **Log scale**: \(\log(1+c)\) 적용(희소/집중 분포 동시 확인)  
- **통계 텍스트**: `min/max/mean/std/median` 네 줄(R/G/B/Y)  
- **OK/Cancel**: 단순 닫기(히스토그램은 보기용이므로 영상 데이터 변경 없음)

---

## 6. 수학적 메모 (참고)

- 이산 히스토그램  
  \[
  h[k] \;=\; \#\{(x,y) \mid I(x,y)=k\},\quad k=0,\dots,255
  \]
- **평균/분산**
  \[
  \mu=\frac{1}{N}\sum_{k=0}^{255}k\,h[k],\qquad
  \sigma^2=\frac{1}{N}\sum_{k=0}^{255}k^2 h[k]-\mu^2
  \]
- **중앙값**: 누적합 \(H[k]=\sum_{i=0}^{k} h[i]\)가 \(N/2\) 이상이 되는 최소 k

---

## 7. 테스트 체크리스트

- [ ] 단색 이미지 → 단일 bin에 스파이크  
- [ ] 저대비 이미지 → 중앙 근처 좁은 분포  
- [ ] 과노출/과소노출 → 우측/좌측 치우침  
- [ ] Normalize/Log 토글 시 그래프 모양 변화 확인  
- [ ] Luma와 RGB의 차이 확인(푸른/붉은 사진에서 Y가 어디에 모이는지)

---

## 8. 확장 아이디어

- **누적 히스토그램(CDF)** 오버레이(점선)  
- **Bin 합치기(예: 128-bin)** 옵션 → 매끄러운 곡선  
- 히스토그램 영역 **드래그로 범위 표시** → 스트레칭/클리핑과 연계  
- **히스토그램 이퀄라이즈/매칭** 대화 상자와 통합

---

## 9. 요약

- BGRA32(DIB)에서 **256-bin 히스토그램**을 계산하고,  
- **대화 상자 내부 커스텀 컨트롤**로 **정규화/로그/채널 토글**을 지원하는 뷰를 구현,  
- **View → Histogram…** 메뉴(단축키 **Ctrl+H**)로 쉽게 확인.