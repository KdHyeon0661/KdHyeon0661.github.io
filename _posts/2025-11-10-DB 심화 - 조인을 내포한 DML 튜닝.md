---
layout: post
title: DB 심화 - 조인을 내포한 DML 튜닝
date: 2025-11-10 23:25:23 +0900
category: DB 심화
---
# 조인을 내포한 DML 튜닝 — Updatable Join View · MERGE · Multi-Table INSERT의 실전 패턴과 함정

**목표**
- 조인이 필수인 DML(UPDATE/DELETE/INSERT)을 **한 번의 스캔/한 번의 매칭**으로 끝내는 재작성 패턴을 체계화한다.
- **수정 가능 조인 뷰(Updatable Join View)**로 “조인 기반 UPDATE/DELETE”를 **단일 문장**으로 안정적으로 수행한다.
- **MERGE**로 “있으면 UPDATE, 없으면 INSERT(또는 DELETE)”를 **원자적(atomic)으로** 수행하면서, 스필·랜덤 I/O·Redo/Undo·락 시간을 최소화한다.
- **INSERT ALL / INSERT FIRST**로 소스 1회 스캔으로 다수 테이블에 **복수/분기 적재**를 구현하고 ETL/요약 동시 생성 성능을 극대화한다.

> 작업 원칙
> - **소스 집합을 먼저 줄이고(build 입력 축소)**
> - **중복 매칭을 제거(유일 매칭 보장)**
> - **불필요한 DML을 없애고(Redo/Undo 최소화)**
> - **락 범위를 줄이며(조기 필터·조건부 UPDATE)**
> - **실측으로 검증(ALLSTATS LAST + IOSTATS + MEMSTATS)**

---

## 0) 실습 스키마 & 공통 세팅

```sql
ALTER SESSION SET nls_date_format       = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level      = ALL;
ALTER SESSION SET workarea_size_policy  = AUTO;
```

### 테이블 & 인덱스 생성 + 데이터

아래는 **즉시 실행 가능한 전체 DDL/데이터**이다.

```sql
-- 마스터: 상품
DROP TABLE PROD PURGE;
CREATE TABLE PROD (
  PROD_ID   NUMBER       PRIMARY KEY,
  CATEGORY  VARCHAR2(20) NOT NULL,
  BRAND     VARCHAR2(20) NOT NULL,
  PRICE     NUMBER(10,2) NOT NULL,
  LAST_UPD  DATE         NOT NULL
);

-- 재고/가격 스테이징
DROP TABLE STG_PRICE PURGE;
CREATE TABLE STG_PRICE (
  PROD_ID   NUMBER       NOT NULL,
  NEW_PRICE NUMBER(10,2) NOT NULL,
  AS_OF_DT  DATE         NOT NULL
);

-- 주문 헤더/상세
DROP TABLE ORD PURGE;
CREATE TABLE ORD(
  ORDER_ID  NUMBER       PRIMARY KEY,
  ORDER_DT  DATE         NOT NULL,
  STATUS    VARCHAR2(8)  NOT NULL
);

DROP TABLE OI PURGE;
CREATE TABLE OI(
  ORDER_ID  NUMBER       NOT NULL,
  LINE_NO   NUMBER       NOT NULL,
  PROD_ID   NUMBER       NOT NULL,
  QTY       NUMBER       NOT NULL,
  AMOUNT    NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY(ORDER_ID, LINE_NO)
);

-- 요약 적재 대상
DROP TABLE SALES_DAILY PURGE;
CREATE TABLE SALES_DAILY (
  SALES_DT  DATE         NOT NULL,
  CATEGORY  VARCHAR2(20) NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL
);

DROP TABLE SALES_BRAND PURGE;
CREATE TABLE SALES_BRAND (
  SALES_DT  DATE         NOT NULL,
  BRAND     VARCHAR2(20) NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL
);

-- 인덱스
CREATE INDEX IX_OI_PROD    ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER   ON OI(ORDER_ID);
CREATE INDEX IX_ORD_DT     ON ORD(ORDER_DT);
CREATE INDEX IX_PROD_CAT   ON PROD(CATEGORY, PROD_ID);
CREATE INDEX IX_PROD_BRAND ON PROD(BRAND, PROD_ID);

-- 샘플 데이터(대량)
BEGIN
  FOR p IN 1..100000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5)
        WHEN 0 THEN 'ELEC'
        WHEN 1 THEN 'FASH'
        WHEN 2 THEN 'FOOD'
        WHEN 3 THEN 'HOME'
        ELSE 'TOY'
      END,
      'BR'||TO_CHAR(MOD(p,50)),
      ROUND(DBMS_RANDOM.VALUE(5,500),2),
      SYSDATE-10
    );
  END LOOP;

  FOR o IN 1..100000 LOOP
    INSERT INTO ORD VALUES(
      o,
      DATE '2024-01-01' + MOD(o,200),
      CASE MOD(o,4)
        WHEN 0 THEN 'NEW'
        WHEN 1 THEN 'PAID'
        WHEN 2 THEN 'SHIP'
        ELSE 'DONE'
      END
    );
  END LOOP;

  FOR i IN 1..300000 LOOP
    INSERT INTO OI VALUES(
      MOD(i,100000)+1,
      1 + MOD(i,3),
      MOD(i,100000)+1,
      TRUNC(DBMS_RANDOM.VALUE(1,5)),
      ROUND(DBMS_RANDOM.VALUE(10,1000),2)
    );
  END LOOP;

  -- 가격 변경 스테이징: 일부 상품만
  FOR s IN 1..30000 LOOP
    INSERT INTO STG_PRICE VALUES(
      MOD(s,100000)+1,
      ROUND(DBMS_RANDOM.VALUE(5,500),2),
      DATE '2024-07-01'
    );
  END LOOP;

  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OI'  , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'STG_PRICE', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

## 1) 조인이 필요한 DML의 “본질적 비용”을 먼저 이해하기

조인이 내포된 DML은 **SELECT보다 더 비싸다.** 이유는 다음과 같다.

1) **대상 행을 찾는 비용(조인/필터)**
2) **행을 잠그는 비용(row lock, ITL 확장, latch)**
3) **Undo 생성(원복 정보)**
4) **Redo 생성(복구/아카이브 로그)**
5) **인덱스 유지 비용(여러 인덱스를 갱신)**
6) **연관 객체(트리거, MV log, FK check) 비용**

따라서 튜닝의 핵심은
- **대상 행을 더 빨리/더 적게 찾고**
- **불필요한 갱신을 없애고**
- **한 번의 스캔/한 번의 매칭으로 끝내는 것**

이 철학이 곧 **Updatable Join View**, **MERGE**, **Multi-Table INSERT**다.

---

## 2) Updatable Join View(수정 가능 조인 뷰) — 조인 + UPDATE/DELETE를 한 문장으로

### 개념 핵심

**조인 뷰를 통해 UPDATE/DELETE가 가능하려면:**

- 갱신 대상 테이블이 **key-preserved table**이어야 한다.
  즉, 뷰 결과에서 그 테이블의 PK/UK가 **중복 없이 보존**되어야 함.
- **한 테이블만** 갱신 가능.
  (조인된 여러 테이블을 한 UPDATE로 동시에 바꾸는 것은 불가)
- 다음 요소가 뷰에 포함되면 **갱신 불가**:
  - 집계(GROUP BY, SUM 등)
  - DISTINCT
  - 집합 연산(UNION/INTERSECT/MINUS)
  - CONNECT BY / ROWNUM 기반 변형
  - 비결정적 함수로 키 보존을 깨는 경우

**중요한 직관**
- “조인해서 필터링은 하되, 실제로 바꾸는 테이블은 한 곳이다.”
- 이 원칙을 지키면 Oracle은 **조인 순서를 온전히 최적화**할 수 있고,
  사용자는 조인 결과를 따로 만들어 반복 UPDATE하는 비용을 피한다.

---

### 기본 예제 — “주문이 존재하는 ELEC 상품만 3% 인상”

```sql
UPDATE (
  SELECT /*+ LEADING(p i o) USE_NL(i) USE_NL(o) */
         p.price AS price_to_update
  FROM   PROD p
  JOIN   OI   i ON i.prod_id  = p.prod_id
  JOIN   ORD  o ON o.order_id = i.order_id
  WHERE  p.category = 'ELEC'
  AND    o.order_dt >= SYSDATE - 30
) v
SET v.price_to_update = v.price_to_update * 1.03;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

**왜 이게 좋은가**
- 조인 결과를 “임시 테이블로 만들고 그걸 다시 UPDATE”하는 2단계가 아니다.
- Oracle은 뷰 내부 조인을 **세미 조인/안티 조인/조인 필터** 등으로 자유롭게 변환 가능.
- 갱신 대상은 PROD 하나라서 key-preserved가 확실.

---

### 중복 매칭 위험과 해결

조인 때문에 같은 PROD가 여러 OI/ORD에 매칭될 수 있다면
뷰 업데이트가 **“중복 UPDATE 시도”**를 만들며, 경우에 따라 에러 혹은 비효율이 된다.

#### 가장 간단한 해결: EXISTS로 재작성

```sql
UPDATE (
  SELECT p.price AS price_to_update
  FROM   PROD p
  WHERE  p.category = 'ELEC'
  AND    EXISTS (
           SELECT 1
           FROM   OI i
           JOIN   ORD o ON o.order_id = i.order_id
           WHERE  i.prod_id = p.prod_id
           AND    o.order_dt >= SYSDATE - 30
         )
) v
SET v.price_to_update = v.price_to_update * 1.03;
```

- EXISTS는 내부가 매칭되면 **즉시 종료** → 조인 후보 폭증을 막는다.
- key-preserved가 자동으로 유지된다.

#### DISTINCT를 사용하는 방식(가능하지만 주의)

```sql
UPDATE (
  SELECT DISTINCT p.prod_id, p.price AS price_to_update
  FROM   PROD p
  JOIN   OI i  ON i.prod_id  = p.prod_id
  JOIN   ORD o ON o.order_id = i.order_id
  WHERE  p.category = 'ELEC'
  AND    o.order_dt >= SYSDATE - 30
) v
SET v.price_to_update = v.price_to_update * 1.03;
```

- DISTINCT가 들어가면 **일부 버전/상황에서 key-preserved 판단이 까다로워질 수 있다.**
- 가능하면 EXISTS 쪽이 더 안정적.

---

### Updatable Join View로 DELETE 하기

“주문이 한 번도 없는 상품을 삭제” 같은 패턴.

```sql
DELETE FROM (
  SELECT p.*
  FROM   PROD p
  WHERE  NOT EXISTS (
           SELECT 1
           FROM   OI i
           WHERE  i.prod_id = p.prod_id
         )
) v;
```

- 갱신 대상(삭제 대상) 테이블이 PROD 하나이므로 key-preserved.
- Anti-join이 자동으로 적용될 가능성이 높다.

---

### 외부조인/NULL 보존이 들어가면?

외부조인이 포함된 조인 뷰는
**의미 보존이 애매해지는 순간 key-preserved 판단을 못하고 갱신 불가**가 될 수 있다.

해결 방법은 두 가지.

1) **외부조인을 뷰 밖으로 빼 재작성**
2) **INSTEAD OF 트리거로 뷰를 "갱신 가능하게" 만든다.**

#### INSTEAD OF 트리거(개념+간단 예)

```sql
CREATE OR REPLACE VIEW V_PROD_EXT AS
SELECT p.prod_id, p.category, p.brand, p.price,
       s.new_price
FROM   PROD p
LEFT JOIN STG_PRICE s ON s.prod_id = p.prod_id;

CREATE OR REPLACE TRIGGER TR_V_PROD_EXT_UPD
INSTEAD OF UPDATE ON V_PROD_EXT
FOR EACH ROW
BEGIN
  UPDATE PROD
  SET price    = :NEW.price,
      last_upd = SYSDATE
  WHERE prod_id = :OLD.prod_id;
END;
/
```

- 복잡한 조인 뷰라도 “갱신 규칙을 직접 정의”하면 갱신 가능.
- 하지만 트리거는 **숨은 비용과 복잡성**이 있으니,
  먼저 수동 재작성으로 해결 가능한지 확인한다.

---

### Updatable Join View 튜닝 체크리스트

- [ ] 갱신 대상 테이블이 **PK/UK로 key-preserved**인가
- [ ] 조인으로 중복 매칭이 생기면 **EXISTS/세미 조인으로 바꿀 수 있는가**
- [ ] 뷰 내부에서 **집계/집합/DISTINCT/CONNECT BY**가 섞여 있지 않은가
- [ ] “대상 행 수”를 줄이는 강한 필터가 **가장 앞단에서 적용**되는가
- [ ] 조건부 UPDATE로 **불필요 Redo/Undo를 막는가**

---

## 3) MERGE — 조건부 UPDATE/INSERT/DELETE를 한 번에

### MERGE의 역할과 장점

`MERGE`는 다음을 **단일 DML**로 묶는다.

- **매칭된 행은 UPDATE**
- **매칭이 없으면 INSERT**
- (추가) **매칭된 행 중 조건부 DELETE**

따라서
- “찾고 → 갱신/삽입”의 **왕복을 제거**
- 동시성에서 **경쟁 조건(race condition)**을 줄인다.
- 소스 집합이 한 번만 스캔되면 매우 빠르다.

---

### 기본 예제 — STG_PRICE로 PROD 가격 동기화

```sql
MERGE /*+ USE_HASH(s) */ INTO PROD p
USING (
  SELECT /*+ MATERIALIZE */
         prod_id, new_price, as_of_dt
  FROM   STG_PRICE
) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.price    = s.new_price,
             p.last_upd = s.as_of_dt
  WHERE p.price <> s.new_price
WHEN NOT MATCHED THEN
  INSERT (p.prod_id, p.category, p.brand, p.price, p.last_upd)
  VALUES (s.prod_id, 'UNKNOWN', 'UNKNOWN', s.new_price, s.as_of_dt);

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

**핵심 튜닝 포인트**
1) `USING` 입력을 **먼저 줄여(필터/집계/Distinct)** 해시 빌드 입력을 작게 만든다.
2) `WHERE p.price <> s.new_price`로 **불필요 UPDATE 제거**
   - Redo/Undo 감소
   - row lock 유지 시간 감소
   - 인덱스 유지 비용 감소

---

### MERGE의 가장 흔한 실패: 복수 매칭(ORA-30926)

MERGE는 `ON`이 **유일 매칭**이어야 한다.
소스 STG_PRICE가 하나의 PROD_ID에 **2건 이상** 있으면 실패한다.

#### 소스에서 중복 제거

```sql
MERGE INTO PROD p
USING (
  SELECT prod_id,
         MAX(new_price) KEEP (DENSE_RANK LAST ORDER BY as_of_dt) AS new_price,
         MAX(as_of_dt)  AS as_of_dt
  FROM   STG_PRICE
  GROUP  BY prod_id
) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.price    = s.new_price,
             p.last_upd = s.as_of_dt
  WHERE p.price <> s.new_price
WHEN NOT MATCHED THEN
  INSERT (prod_id, category, brand, price, last_upd)
  VALUES (s.prod_id, 'UNKNOWN','UNKNOWN', s.new_price, s.as_of_dt);
```

- **“키별 최종 1건”**만 남겨 유일 매칭 보장.

---

### MERGE로 조건부 DELETE 포함하기

예: “스테이징에 있는 상품은 가격을 맞추고, 카테고리가 폐기 대상이면 삭제”

```sql
MERGE INTO PROD p
USING (
  SELECT prod_id, new_price, as_of_dt
  FROM   STG_PRICE
) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.price = s.new_price,
             p.last_upd = s.as_of_dt
DELETE WHERE p.category = 'TO_BE_PURGED';
```

**주의**
- DELETE WHERE는 **매칭된 행만** 후보가 된다.
- “스테이징에 없는 키를 삭제(anti-join delete)”는
  별도의 DELETE가 더 명확하고 빠를 때가 많다.

---

### MERGE 성능을 좌우하는 요소들

#### USING 서브쿼리의 “빌드 입력 크기”

- 해시 MERGE 플랜에서 `USING`이 build가 되는 순간,
  빌드 입력이 크면 TEMP 스필이 나고 성능이 급락한다.
- 따라서 `USING`에서 **반드시 1차 축소**를 시도.

```sql
MERGE INTO PROD p
USING (
  SELECT /*+ MATERIALIZE */
         prod_id, new_price, as_of_dt
  FROM   STG_PRICE
  WHERE  as_of_dt >= DATE '2024-07-01'
) s
ON (p.prod_id = s.prod_id)
...
```

#### 매칭 조건의 SARGability

- `ON (p.prod_id = s.prod_id)` 같은 **단순 등치**가 최선.
- 컬럼 가공이 들어가면 인덱스 접근이 약해지고 매칭이 비싸진다.

#### 타깃 인덱스의 수

- UPDATE/INSERT가 인덱스를 **모두 유지**해야 한다.
- 대량 배치라면
  1) 인덱스 최소화
  2) 적재 후 인덱스 재생성
  이 더 빠를 수 있다(업무 정책/락 허용 범위에 따라).

---

### MERGE와 동시성

- 동일 키에 대해 다수 세션이 동시에 MERGE/INSERT를 하면
  - 타깃에 PK/UK가 있으면 **unique 경합이 발생**할 수 있다.
  - MERGE는 내부적으로도 “매칭 검사 + 삽입”이 있어서 완벽한 해결책은 아니다.
- **동시 삽입이 빈번하면**
  - UPSERT를 **직렬화(큐/배치)**하거나
  - 애플리케이션에서 키 범위를 분할하거나
  - 필요 시 `INSERT ... ON CONFLICT`류의 애플리케이션 레벨 방식을 검토한다(Oracle에선 비슷한 패턴을 MERGE가 수행).

---

### MERGE 튜닝 체크리스트

- [ ] `ON` 조건이 유일 매칭을 보장하는가
- [ ] USING 입력을 **그룹/필터/Distinct로 축소**했는가
- [ ] 불필요 UPDATE를 막는 조건이 있는가
- [ ] 빌드 입력이 PGA에서 원패스 가능한가(MEMSTATS로 확인)
- [ ] 타깃 인덱스/트리거/제약이 과도하지 않은가
- [ ] 실행 후 A-Rows/Buffers/TempSpc를 확인했는가

---

## 4) 다중 테이블 INSERT — INSERT ALL / INSERT FIRST

### 역할

**한 번의 소스 스캔**으로 다음을 동시에 수행:

- 여러 테이블에 **복수 적재**
- 조건에 따라 **분기 적재**
- 요약/상세를 **동시 생성**
- 파티션별 분할 적재

즉, ETL에서 **I/O를 줄이는 최강의 무기**다.

---

### INSERT ALL — 모든 조건을 만족하면 모두 적재

#### 기본: 일자·카테고리와 일자·브랜드 요약 동시 적재

```sql
INSERT /*+ APPEND PARALLEL(4) */ ALL
  WHEN category IS NOT NULL THEN
    INTO SALES_DAILY (SALES_DT, CATEGORY, AMOUNT)
    VALUES (order_dt, category, amount)
  WHEN brand IS NOT NULL THEN
    INTO SALES_BRAND (SALES_DT, BRAND, AMOUNT)
    VALUES (order_dt, brand, amount)
SELECT /*+ LEADING(i p o) USE_HASH(p) USE_HASH(o) */
       TRUNC(o.order_dt) AS order_dt,
       p.category,
       p.brand,
       i.amount
FROM   OI i
JOIN   PROD p ON p.prod_id = i.prod_id
JOIN   ORD  o ON o.order_id = i.order_id
WHERE  o.order_dt BETWEEN DATE '2024-06-01' AND DATE '2024-06-30';

COMMIT;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
'ALLSTATS LAST +IOSTATS +MEMSTATS'));
```

**특징**
- 소스 스캔 1회.
- WHEN이 둘 다 참이면 **두 테이블 모두 적재**된다.

---

### INSERT FIRST — 첫 번째 조건만 적재(우선순위 분기)

```sql
INSERT /*+ APPEND */ FIRST
  WHEN category IN ('ELEC','FASH') THEN
    INTO SALES_DAILY (SALES_DT, CATEGORY, AMOUNT)
    VALUES (order_dt, category, amount)
  WHEN 1=1 THEN
    INTO SALES_BRAND (SALES_DT, BRAND, AMOUNT)
    VALUES (order_dt, brand, amount)
SELECT TRUNC(o.order_dt) order_dt, p.category, p.brand, i.amount
FROM   OI i
JOIN   PROD p ON p.prod_id = i.prod_id
JOIN   ORD  o ON o.order_id = i.order_id
WHERE  o.order_dt >= DATE '2024-06-01';
```

- `ELEC/FASH`는 DAILY에만 들어가고, 나머지는 BRAND에만 들어간다.
- “상호배타 분기”에 최적.

---

### 사전 집계 + Multi-Insert (대량에서 매우 중요)

요약 테이블은 원시 행을 그대로 적재하는 것보다
**집계해서 행 수를 줄인 뒤 적재**하는 편이 훨씬 싸다.

```sql
INSERT ALL
  INTO SALES_DAILY (SALES_DT, CATEGORY, AMOUNT)
  VALUES (sales_dt, category, amt)
  INTO SALES_BRAND (SALES_DT, BRAND, AMOUNT)
  VALUES (sales_dt, brand, amt)
SELECT sales_dt, category, brand, amt
FROM (
  SELECT TRUNC(o.order_dt) sales_dt,
         p.category,
         p.brand,
         SUM(i.amount) amt
  FROM   OI i
  JOIN   PROD p ON p.prod_id = i.prod_id
  JOIN   ORD  o ON o.order_id = i.order_id
  WHERE  o.order_dt BETWEEN DATE '2024-06-01' AND DATE '2024-06-30'
  GROUP BY TRUNC(o.order_dt), p.category, p.brand
);
```

**장점**
- 적재 행 수 급감 → Redo/Undo/인덱스 유지 비용 급감.
- 소스 집합을 `GROUP BY`로 줄이고 Multi-Insert 하므로
  전체 파이프라인이 가벼워진다.

---

### Multi-Insert에서 자주 겪는 문제들

1) **타깃 인덱스 과다**
- INSERT가 인덱스 유지 때문에 병목.

2) **APPEND 사용 시 인덱스/제약 비용**
- Direct-path insert는 데이터는 빠르지만
  인덱스 유지가 많은 테이블이면 오히려 느려질 수 있다.

3) **병렬 DML과 TEMP/PGA**
- 병렬로 스캔/집계/다중 적재 시
  PGA/Temp 사용량이 급증할 수 있다.

4) **조건 순서**
- INSERT FIRST에서는 WHEN 순서가 곧 **비즈니스 규칙**이다.
  잘못된 순서면 데이터가 잘못 들어간다.

---

### Multi-Insert 튜닝 체크리스트

- [ ] 소스는 **한 번만 스캔**되는가(실측 플랜 확인)
- [ ] 적재 전 **사전 집계가 가능한가**
- [ ] 타깃 인덱스를 최소화했는가(배치 적재라면 재생성 고려)
- [ ] INSERT FIRST의 **우선순위 WHEN 순서**가 맞는가
- [ ] APPEND/NOLOGGING/PARALLEL 정책이 업무 기준과 충돌하지 않는가
- [ ] 에러 로깅/부분 실패 허용이 필요한가

---

## 5) 도구별 선택 가이드와 성능 사고 순서

### 언제 Updatable Join View?

- **조인 조건으로 대상 행을 고르고**
- **갱신 대상이 1개 테이블**
- **중복 매칭이 EXISTS로 해결 가능**
- **집계/집합이 필요 없음**

즉, “조인 기반 필터 UPDATE/DELETE”라면 1순위.

### 언제 MERGE?

- **업서트(UPDATE+INSERT)**가 필요할 때
- 소스가 스테이징/외부 적재분으로 들어오고,
  타깃과 **동기화**해야 할 때
- 동시성/원자성을 확보하고 싶을 때

### 언제 Multi-Insert?

- **소스 1회 스캔으로 여러 테이블에 동시에 적재**
- ETL/요약/분기 적재/파티션 분할 로딩
- 보고용 요약 테이블을 “원천 로딩 단계에서 같이 만들고 싶을 때”

---

## 6) 실전 패턴 모음

### “매칭된 것만 UPDATE, 미매칭은 무시” — MERGE를 UPDATE 전용으로

```sql
MERGE INTO PROD p
USING (
  SELECT /*+ MATERIALIZE */ prod_id, new_price, as_of_dt
  FROM STG_PRICE
) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.price = s.new_price, p.last_upd = s.as_of_dt
  WHERE p.price <> s.new_price;
```

- “INSERT가 필요 없는 동기화”에 단순/안전.

---

### “미매칭만 INSERT, 매칭은 건드리지 않음” — INSERT 전용 MERGE

```sql
MERGE INTO PROD p
USING (
  SELECT prod_id, new_price, as_of_dt
  FROM STG_PRICE
) s
ON (p.prod_id = s.prod_id)
WHEN NOT MATCHED THEN
  INSERT (prod_id, category, brand, price, last_upd)
  VALUES (s.prod_id, 'UNKNOWN','UNKNOWN', s.new_price, s.as_of_dt);
```

- 신규만 적재하는 배치에서 “중복 키 무시”가 필요할 때.

---

### “키별 최종 상태만 반영” — USING에서 Top-1 per key 만들고 MERGE

```sql
MERGE INTO PROD p
USING (
  SELECT prod_id,
         MAX(new_price) KEEP (DENSE_RANK LAST ORDER BY as_of_dt) AS new_price,
         MAX(as_of_dt) AS as_of_dt
  FROM STG_PRICE
  GROUP BY prod_id
) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN UPDATE
  SET p.price = s.new_price, p.last_upd = s.as_of_dt
  WHERE p.price <> s.new_price;
```

- 중복 매칭 제거 + 입력 축소를 **한 번에**.

---

### “대상 소량, 내부 대량” — APPLY로 Top-1만 읽어 UPDATE

```sql
-- 전제: (prod_id, last_upd desc) 같은 인덱스가 있으면 더 좋음
UPDATE (
  SELECT p.price,
         v.new_price
  FROM PROD p
  CROSS APPLY (
    SELECT s.new_price
    FROM STG_PRICE s
    WHERE s.prod_id = p.prod_id
    ORDER BY s.as_of_dt DESC
    FETCH FIRST 1 ROWS ONLY
  ) v
  WHERE p.category = 'ELEC'
) x
SET x.price = x.new_price;
```

- Updatable join view + LATERAL Top-1.
- “바깥 소량”일 때 내부를 Stopkey로 1건만 읽어 랜덤 I/O 최소화.

---

## 7) 검증 방법 — 항상 실측으로 끝낸다

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL,NULL,
         'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'));
```

**실측을 볼 때의 순서**
1) **A-Rows가 E-Rows와 크게 다른가**
   → 통계/상관관계/히스토그램 점검
2) **Buffers가 과도한가**
   → 대상 행 수를 줄이는 필터 재작성/인덱스 검토
3) **TempSpc/MemSTATS에서 스필이 나는가**
   → USING/조인 입력 축소, 해시 워크에어리어 확대 검토
4) **UPDATE/INSERT Rows가 기대보다 많은가**
   → 불필요 DML 제거(조건부 UPDATE, Top-1)
5) **실행 시간의 대부분이 DML 단계인가**
   → 인덱스/트리거/제약/MV log 비용 점검

---

## 8) 최종 체크리스트(현장용)

- [ ] 조인 기반 UPDATE/DELETE는 **Updatable Join View + EXISTS**로 단일화했는가
- [ ] 업서트/동기화는 **MERGE**로 왕복을 제거했는가
- [ ] MERGE의 ON이 **유일 매칭**을 보장하는가(중복 제거 했는가)
- [ ] 불필요 UPDATE를 방지하는 조건이 있는가
- [ ] TRY: USING 입력을 먼저 줄였는가(필터/집계/Distinct/Top-1)
- [ ] 한 번 스캔으로 여러 적재가 필요하면 **INSERT ALL/FIRST**인가
- [ ] Multi-Insert 전 사전 집계로 행 수를 줄일 수 있는가
- [ ] 타깃 인덱스/트리거/제약이 대량 DML에 적합한가
- [ ] APPEND/PARALLEL/NOLOGGING 정책을 업무 기준과 맞췄는가
- [ ] 실측 플랜으로 Buffers/Rows/TempSpc/MemSTATS를 확인했는가

---

### 결론

- **Updatable Join View**는 “조인으로 대상을 골라 **한 테이블만** 바꾸는 DML”을 가장 간결하고 빠르게 만든다.
- **MERGE**는 “조건부 UPDATE/INSERT/DELETE”를 **원자적으로** 수행하며, 성능의 승부는 **USING 입력 축소와 불필요 DML 제거**에 달려 있다.
- **Multi-Table INSERT**는 “소스 1회 스캔으로 복수/분기 적재”를 구현하는 ETL의 표준이며, 대량에서는 **사전 집계 후 적재**가 절대적인 차이를 만든다.

이 세 도구를 정확히 쓰면, 조인이 들어간 DML도 **SELECT 수준의 단순한 비용 구조**로 환원되어 안정적으로 빠르게 튜닝할 수 있다.
