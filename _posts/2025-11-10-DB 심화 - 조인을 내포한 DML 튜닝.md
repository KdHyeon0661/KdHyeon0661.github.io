---
layout: post
title: DB 심화 - 조인을 내포한 DML 튜닝
date: 2025-11-10 23:25:23 +0900
category: DB 심화
---
# 조인을 내포한 DML 튜닝 (Oracle)

**— 수정 가능 조인 뷰(Updatable Join View) 활용 · MERGE 문 활용 · 다중 테이블 INSERT(INSERT ALL / FIRST) 활용**
모든 예제는 **즉시 실행 가능한 DDL/데이터/SQL**을 포함합니다. 실행 후에는
`DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS')`
로 실제 실행 통계를 확인하세요.

> 핵심 요약
> - **조인이 필요한 DML**(UPDATE/DELETE/INSERT)은 **재작성**(updatable join view, MERGE, multi-table insert)으로 **왕복 접근 줄이기**, **불필요한 스캔/정렬 제거**, **Redo/Undo/Temp 최소화**가 핵심.
> - **수정 가능 조인 뷰**: “**key-preserved table** 한 곳만 갱신” 원칙을 지키면 **조인 + UPDATE**를 **한 문장**으로 해결. 옵티마이저가 조인 순서를 유리하게 골라줄 수도 있음.
> - **MERGE**: “있으면 UPDATE, 없으면 INSERT”를 **한 번**에. **매칭 조건**과 **입력 집합 크기**를 줄여 **스필/랜덤 I/O**를 억제.
> - **다중 테이블 INSERT**: 한 번 스캔으로 여러 테이블에 **분기/복수 Insert**. ETL·분할 적재·요약 동시 생성에 최적.

---

## 실습 스키마 & 공통 세팅

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;      -- ALLSTATS LAST
ALTER SESSION SET workarea_size_policy = AUTO; -- 해시/소트 워크에어리어 자동
```

### 테이블 생성

```sql
-- 마스터: 상품
DROP TABLE PROD PURGE;
CREATE TABLE PROD (
  PROD_ID   NUMBER       PRIMARY KEY,
  CATEGORY  VARCHAR2(20) NOT NULL,
  BRAND     VARCHAR2(20) NOT NULL,
  PRICE     NUMBER(10,2) NOT NULL,
  LAST_UPD  DATE         NOT NULL
);

-- 재고/가격 마트(외부 소스 적재 대상)
DROP TABLE STG_PRICE PURGE;
CREATE TABLE STG_PRICE (
  PROD_ID   NUMBER       NOT NULL,
  NEW_PRICE NUMBER(10,2) NOT NULL,
  AS_OF_DT  DATE         NOT NULL
);

-- 주문 헤더/상세 (조인 DML 실습용)
DROP TABLE ORD PURGE;
CREATE TABLE ORD(
  ORDER_ID  NUMBER       PRIMARY KEY,
  ORDER_DT  DATE         NOT NULL,
  STATUS    VARCHAR2(8)  NOT NULL
);

DROP TABLE OI PURGE;
CREATE TABLE OI(
  ORDER_ID  NUMBER       NOT NULL,
  LINE_NO   NUMBER       NOT NULL,
  PROD_ID   NUMBER       NOT NULL,
  QTY       NUMBER       NOT NULL,
  AMOUNT    NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY(ORDER_ID, LINE_NO)
);

-- 보조/요약 적재 대상
DROP TABLE SALES_DAILY PURGE;
CREATE TABLE SALES_DAILY (
  SALES_DT  DATE         NOT NULL,
  CATEGORY  VARCHAR2(20) NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL
);

DROP TABLE SALES_BRAND PURGE;
CREATE TABLE SALES_BRAND (
  SALES_DT  DATE         NOT NULL,
  BRAND     VARCHAR2(20) NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL
);

-- 인덱스
CREATE INDEX IX_OI_PROD    ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER   ON OI(ORDER_ID);
CREATE INDEX IX_ORD_DT     ON ORD(ORDER_DT);
CREATE INDEX IX_PROD_CAT   ON PROD(CATEGORY, PROD_ID);
CREATE INDEX IX_PROD_BRAND ON PROD(BRAND, PROD_ID);

-- 샘플 데이터
BEGIN
  FOR p IN 1..100000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FASH' WHEN 2 THEN 'FOOD' WHEN 3 THEN 'HOME' ELSE 'TOY' END,
      'BR'||TO_CHAR(MOD(p,50)),
      ROUND(DBMS_RANDOM.VALUE(5,500),2),
      SYSDATE-10
    );
  END LOOP;

  FOR o IN 1..100000 LOOP
    INSERT INTO ORD VALUES(
      o,
      DATE '2024-01-01' + MOD(o,200),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  FOR i IN 1..300000 LOOP
    INSERT INTO OI VALUES(
      MOD(i,100000)+1,
      1 + MOD(i,3),
      MOD(i,100000)+1,
      TRUNC(DBMS_RANDOM.VALUE(1,5)),
      ROUND(DBMS_RANDOM.VALUE(10,1000),2)
    );
  END LOOP;

  -- 가격 변경 스테이징: 일부 상품만
  FOR s IN 1..30000 LOOP
    INSERT INTO STG_PRICE VALUES(
      MOD(s,100000)+1,
      ROUND(DBMS_RANDOM.VALUE(5,500),2),
      DATE '2024-07-01'
    );
  END LOOP;

  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OI'  , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'STG_PRICE', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

# 활용

## 개념 요약

- **조인 뷰를 통한 UPDATE/DELETE** 허용 조건:
  - 갱신 대상 테이블이 **key-preserved table**(뷰 결과에서 해당 테이블의 각 키가 “중복 없이” 보존)이어야 함.
  - **한 테이블만** 갱신(여러 테이블 동시 갱신은 불가).
  - **그 외 제약**(집계/집합연산/DISTINCT/CONNECT BY 등) 포함 시 갱신 불가.
- 장점: **조인 + 갱신**을 **한 문장**으로 수행 → **임시 집합** 생성/반복 조회 비용 제거.

## 존재 상품의 가격에 3% 가산”

- 대상: **PROD**만 갱신 (PROD는 PK로 key-preserved)
- 조인: **PROD ⨝ OI ⨝ ORD** (존재 확인/필터)

```sql
-- 30일 내 주문이 존재하는 ELEC 상품의 가격 ↑
UPDATE (
  SELECT /*+ LEADING(p i o) USE_NL(i) USE_NL(o) */
         p.price AS price_to_update
  FROM   PROD p
  JOIN   OI   i ON i.prod_id = p.prod_id
  JOIN   ORD  o ON o.order_id = i.order_id
  WHERE  p.category = 'ELEC'
  AND    o.order_dt >= SYSDATE - 30
) v
SET v.price_to_update = v.price_to_update * 1.03;

-- 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS'));
```

**튜닝 포인트**
- 인덱스 활용: `IX_OI_PROD`, `IX_ORD_DT`, `IX_PROD_CAT`.
- 드라이빙: `PROD(ELEC)` → `OI(PROD_ID)` → `ORD(ORDER_DT)`로 **필터 강한 순서**.
- 결과 집합을 `SELECT ... FOR UPDATE` 로 잠근 뒤 갱신하는 패턴도 가능하나, 위 방식이 **뷰 직접 갱신**으로 깔끔.

### 중복 방지(집계 필요 시)

- 조인으로 인해 같은 상품이 여러 번 매칭될 수 있다면, **중복 제거** 후 갱신해야 한다.
  - 방법1: `EXISTS`/`SEMI JOIN` 형태로 재작성 (가장 간단)
  - 방법2: 소뷰에서 `SELECT DISTINCT p.prod_id, p.price ...`로 key-preserved 보장

```sql
UPDATE (
  SELECT p.price AS price_to_update
  FROM   PROD p
  WHERE  p.category = 'ELEC'
  AND    EXISTS (
           SELECT 1
           FROM   OI i
           JOIN   ORD o ON o.order_id = i.order_id
           WHERE  i.prod_id = p.prod_id
           AND    o.order_dt >= SYSDATE - 30
         )
) v
SET v.price_to_update = v.price_to_update * 1.03;
```

**장점**: `EXISTS`는 **조기 종료** 가능 → 조인 비용 최소화.

---

# MERGE 문 활용 (존재하면 UPDATE, 없으면 INSERT)

## 개념 요약

- `MERGE INTO tgt t USING (subq) s ON (match)`:
  - `WHEN MATCHED THEN UPDATE ...`
  - `WHEN NOT MATCHED THEN INSERT ...`
  - (옵션) `DELETE WHERE` 절로 매칭된 행 중 삭제 조건을 줄 수도 있음.
- 장점: **두 단계(찾고→갱신/삽입)**를 **한 번**에, **중복 경쟁** 리스크 완화.
- 주의: `ON` 조건은 **유일 매칭**을 만들도록 구성(복수 매칭 금지).
  인덱스/UK 제약으로 **중복 방지**.

## 예제: STG_PRICE→PROD 가격 동기화

- **같은 PROD_ID**가 있으면 가격/일자 갱신, 없으면 신규 삽입(데모 목적상 PROD에 없는 ID가 거의 없지만 문법 시연).

```sql
MERGE /*+ USE_HASH(s) */ INTO PROD p
USING (
  SELECT /*+ MATERIALIZE */
         prod_id, new_price, as_of_dt
  FROM   STG_PRICE
) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.price = s.new_price,
             p.last_upd = s.as_of_dt
  WHERE p.price <> s.new_price              -- 불필요한 Redo 최소화
WHEN NOT MATCHED THEN
  INSERT (p.prod_id, p.category, p.brand, p.price, p.last_upd)
  VALUES (s.prod_id,
          'UNKNOWN', 'UNKNOWN',
          s.new_price, s.as_of_dt);

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

**튜닝 포인트**
- `STG_PRICE`가 크면 `USING` 서브쿼리에서 먼저 **필터/중복제거**로 **입력 축소**(`MATERIALIZE`) → 빌드 입력 축소로 **원패스 해시 조인** 유도.
- **불필요 UPDATE 방지** `WHERE p.price <> s.new_price`: Redo/Undo 감소, 행잠금 시간 단축.
- 대상 키(`PROD(PROD_ID)`)는 **PK/UK 인덱스** 필수.
- 대량 로딩 시 `PARALLEL`, `NOLOGGING`(업무 정책 허용 시), `APPEND`는 INSERT 경로에만 영향.

### 조건부 삭제(DELETE WHERE)

- “스테이징에 없는 키는 비활성화” 같은 **동기화 삭제** 패턴.

```sql
MERGE INTO PROD p
USING (SELECT prod_id FROM STG_PRICE) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.last_upd = SYSDATE
DELETE WHERE p.category = 'TO_BE_PURGED'; -- 매칭된 행 중 추가 조건 충족 시 삭제
```

> 삭제 조건은 **매칭된 행만** 대상으로 함. 전체 비교(anti-join 삭제)는 별도 DML이 나을 때도 많음.

### MERGE vs UPDATE+INSERT 비교

- **MERGE**는 **동시성 경쟁**(다른 세션이 같은 키를 거의 동시에 INSERT)에서 **ORA-00001**(unique 위반)보다 **안정적으로** 처리될 가능성이 높다.
- 단, **MERGE 자체가 느린 게 아니라** “USING 서브쿼리”/조인/소트가 비용을 좌우. **조인 순서/해시 빌드 축소**가 성능의 핵심.

---

# 다중 테이블 INSERT (INSERT ALL / INSERT FIRST)

## 개념 요약

- **한 번 스캔**으로 **여러 테이블**에 분기 INSERT:
  - `INSERT ALL`: **모든 WHEN** 매칭에 대해 **모두** INSERT.
  - `INSERT FIRST`: **첫 번째 매칭** WHEN만 INSERT(우선 순위 분기).
- 장점: **소스 집합 한 번** 읽고 다양한 요약 테이블/분할 테이블에 **동시에 적재** → **I/O 절약**.
- 주의: 각 타깃 테이블에 맞는 **인덱스/파티션 키** 설계, DML 로깅/병렬 정책.

## 한 번 스캔으로 “일자·카테고리 합계”와 “일자·브랜드 합계”를 **동시 적재**

```sql
-- 소스: OI + PROD 조인 후 일자/금액 산출
INSERT /*+ APPEND PARALLEL(4) */ ALL
  WHEN category IS NOT NULL THEN
    INTO SALES_DAILY (SALES_DT, CATEGORY, AMOUNT)
    VALUES (order_dt, category, amount)
  WHEN brand IS NOT NULL THEN
    INTO SALES_BRAND (SALES_DT, BRAND, AMOUNT)
    VALUES (order_dt, brand, amount)
SELECT /*+ LEADING(i p) USE_HASH(p) */
       TRUNC(o.order_dt) AS order_dt,
       p.category,
       p.brand,
       i.amount
FROM   OI i
JOIN   PROD p ON p.prod_id = i.prod_id
JOIN   ORD  o ON o.order_id = i.order_id
WHERE  o.order_dt BETWEEN DATE '2024-06-01' AND DATE '2024-06-30';

COMMIT;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +IOSTATS +MEMSTATS'));
```

> 위 예시는 **원시 행**을 그대로 두 요약 테이블에 **동시에 적재**.
> 원한다면 적재 전에 `GROUP BY`로 **집계 후 적재**(행 수 감소 → Redo/Undo 절감)도 가능.

### INSERT FIRST (우선순위 분기)

- 카테고리가 특정 세트면 A 테이블, 아니면 B 테이블에만 넣기(서로 배타).

```sql
INSERT /*+ APPEND */ FIRST
  WHEN category IN ('ELEC','FASH') THEN
    INTO SALES_DAILY (SALES_DT, CATEGORY, AMOUNT)
    VALUES (order_dt, category, amount)
  WHEN 1=1 THEN
    INTO SALES_BRAND (SALES_DT, BRAND, AMOUNT)
    VALUES (order_dt, brand, amount)
SELECT TRUNC(o.order_dt) order_dt, p.category, p.brand, i.amount
FROM   OI i
JOIN   PROD p ON p.prod_id = i.prod_id
JOIN   ORD  o ON o.order_id = i.order_id
WHERE  o.order_dt >= DATE '2024-06-01';
```

**튜닝 포인트**
- **조인 순서**: `LEADING/USE_HASH/USE_NL`로 유리한 순서 고정.
- **APPEND**: Direct-path insert로 **로깅/블록 경합** 감소(정책 허용 시, 인덱스 유지 비용 주의).
- **PARALLEL**: 타깃/소스 모두 병렬화 → 적절한 `DOP` 설정, `PGA/TEMP` 모니터링.
- **사전 집계**: 가능하면 `GROUP BY`로 **행 수 축소 후** 다중 insert → 비용 절감.

---

# 패턴 비교: 어떤 도구를 언제 쓸까?

| 상황/요구 | 추천 패턴 | 이유 |
|---|---|---|
| **조인 결과를 기준으로 한 테이블만 갱신** | **수정 가능 조인 뷰**(UPDATE ... FROM 형태) | 한 문장에 조인+갱신. `EXISTS`/세미조인으로 **중복 없이** 갱신. |
| **있으면 갱신, 없으면 삽입** | **MERGE** | 동시성 안전성↑, 왕복 감소. `ON` 유일 매칭·불필요 UPDATE 방지. |
| **한 번 스캔해서 여러 타깃에 분기 적재** | **INSERT ALL / FIRST** | 소스 I/O 1회. ETL/요약/분기 적재에 최적. |
| **Top-1/최근 행을 붙여 갱신** | **APPLY(LATERAL) + UPDATE** or 조인 뷰 | 인덱스 역순 + Stopkey로 **랜덤 I/O 최소화**. |
| **대량 배치/집계 중심** | MERGE/INSERT ALL + **해시 조인** | 빌드 입력 축소, `MEMSTATS` 확인으로 스필 방지. |
| **트랜잭션당 Redo 최소화** | 조건부 UPDATE/INSERT, **APPEND**, 배치 커밋 | 불필요 DML 최소화, Direct-path로 Redo/세그먼트 경합 완화. |

---

# 실전 시나리오

## “지난달 ELEC 매출 있는 상품만 5% 인상” — 조인 뷰 UPDATE vs MERGE

### 조인 뷰 UPDATE

```sql
UPDATE (
  SELECT p.price
  FROM   PROD p
  WHERE  p.category = 'ELEC'
  AND    EXISTS (
           SELECT 1
           FROM   OI i
           JOIN   ORD o ON o.order_id = i.order_id
           WHERE  i.prod_id = p.prod_id
           AND    o.order_dt BETWEEN ADD_MONTHS(TRUNC(SYSDATE,'MM'),-1)
                                    AND     TRUNC(SYSDATE,'MM') - 1
         )
) v
SET v.price = v.price * 1.05;
```

### MERGE (조건부 업데이트)

```sql
MERGE INTO PROD p
USING (
  SELECT /*+ MATERIALIZE */ DISTINCT i.prod_id
  FROM   OI i
  JOIN   ORD o ON o.order_id = i.order_id
  WHERE  o.order_dt BETWEEN ADD_MONTHS(TRUNC(SYSDATE,'MM'),-1)
                         AND     TRUNC(SYSDATE,'MM') - 1
) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.price = p.price * 1.05
  WHERE p.category = 'ELEC';
```

**비교 가이드**
- (A)는 `EXISTS`로 **조기 종료**, 조인 비용이 낮고 **한 테이블 갱신**에 직관적.
- (B)는 소스 집합을 **명시적으로 구성**(DISTINCT) → 매칭 당 **한 번** 업데이트 보장.
  대량일 때는 MERGE가 **실행 계획 안정성**에서 유리할 때가 많음.

## “STG_PRICE로 가격 동기화 + 로그 테이블에도 기록” — MERGE + 다중 INSERT

1) 먼저 MERGE로 PROD 갱신/삽입
2) 변경분을 캡처해 **로그**(감사/CDC 간이 버전)에도 남기기

```sql
-- 1) 변경분만 반환하는 MERGE는 표준 SQL로 직접 반환 불가 → 변경 대상 집합을 공통 서브쿼리로 구축
WITH CHG AS (
  SELECT /*+ MATERIALIZE */ p.prod_id, p.price AS old_price, s.new_price, s.as_of_dt
  FROM   STG_PRICE s
  LEFT   JOIN PROD p ON p.prod_id = s.prod_id
)
MERGE INTO PROD p
USING CHG c
ON (p.prod_id = c.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.price = c.new_price, p.last_upd = c.as_of_dt
  WHERE p.price <> c.new_price
WHEN NOT MATCHED THEN
  INSERT (prod_id, category, brand, price, last_upd)
  VALUES (c.prod_id, 'UNKNOWN', 'UNKNOWN', c.new_price, c.as_of_dt);

-- 2) 변경 로그 적재 (멀티 INSERT로 유형별 분기)
INSERT ALL
  WHEN old_price IS NULL THEN
    INTO PRICE_AUDIT (PROD_ID, EVT, OLD_PRICE, NEW_PRICE, EVT_DT)
    VALUES (prod_id, 'INSERT', NULL, new_price, as_of_dt)
  WHEN old_price IS NOT NULL AND old_price <> new_price THEN
    INTO PRICE_AUDIT (PROD_ID, EVT, OLD_PRICE, NEW_PRICE, EVT_DT)
    VALUES (prod_id, 'UPDATE', old_price, new_price, as_of_dt)
SELECT prod_id, old_price, new_price, as_of_dt
FROM   CHG;

COMMIT;
```

> 운영에서는 **DML Error Logging**(`LOG ERRORS INTO ... REJECT LIMIT ...`)으로 불량 레코드 분기도 함께 설계.

---

# 성능 점검 & 트러블슈팅

## 실행 계획/통계 확인

```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'));
```

- **HASH JOIN** 단계의 `TempSpc`↑ → 빌드 입력 축소 검토(`MATERIALIZE`, 선필터, DISTINCT).
- **UPDATE/INSERT 노드의 Buffers/Rows**로 **불필요 DML** 여부 판단(조건부 UPDATE 도입).
- **TABLE ACCESS BY INDEX ROWID BATCHED**: NL 내부 배치 읽기 적용 여부(랜덤 I/O 완화).

## 인덱스/잠금/Redo 전략

- **타깃 인덱스 과다** → INSERT/UPDATE 비용 급증. 대량 적재 시 **인덱스 최소화** 후 적재→재생성 고려.
- **조건부 UPDATE**로 **Redo/Undo 절감**.
- **배치 커밋**(너무 잦은 커밋은 성능 악화, 너무 드물면 UNDO/TEMP/락 장기 유지).
  일반적으로 **수천~수만 행 단위**로 환경에 맞게 조정.
- **APPEND**(Direct-Path) 사용 시: 병행 세션과의 **블록 경합 감소**, 단 **인덱스 유지/로깅 정책** 주의.

## 통계/카디널리티

- 조인 기반 DML은 **카디널리티 오차**에 민감 → `DBMS_STATS` 정기 수집, **히스토그램**(스큐 컬럼), **컬럼 그룹 통계**.
- 바인드 값에 따라 **플랜 분기** 필요 시 **Adaptive Cursor Sharing**.

## 에러 로깅 & 부분 실패 허용

```sql
-- 에러 로깅 테이블
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE DML_ERRLOG PURGE';
EXCEPTION WHEN OTHERS THEN NULL; END;
/

BEGIN
  DBMS_ERRLOG.CREATE_ERROR_LOG('PROD','DML_ERRLOG');
END;
/

-- 예: MERGE에 에러 로깅
MERGE INTO PROD p
USING STG_PRICE s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.price = s.new_price, p.last_upd = s.as_of_dt
WHEN NOT MATCHED THEN
  INSERT (prod_id, category, brand, price, last_upd)
  VALUES (s.prod_id,'UNKNOWN','UNKNOWN',s.new_price,s.as_of_dt)
LOG ERRORS INTO DML_ERRLOG ('PRICE_LOAD') REJECT LIMIT UNLIMITED;
```

---

# 체크리스트 (현장용)

- [ ] **업데이트 대상 1개 테이블**인가? → **수정 가능 조인 뷰**로 재작성 고려.
- [ ] **있으면 갱신/없으면 삽입**? → **MERGE**, `ON` 유일 매칭/불필요 UPDATE 방지.
- [ ] 한 번 스캔으로 여러 타깃 적재? → **INSERT ALL/FIRST**, 필요 시 **사전 집계**.
- [ ] **조인 순서/메소드** 고정 필요? → `LEADING/USE_HASH/USE_NL/NO_MERGE/MATERIALIZE`.
- [ ] **빌드 입력 축소**로 해시 원패스 유도(필터/중복제거).
- [ ] **인덱스 설계**: 조인 키/필터 컬럼 우선, 타깃 테이블 인덱스는 최소화.
- [ ] **Redo/Undo 절감**: 조건부 UPDATE, APPEND, 배치 커밋.
- [ ] **통계 최신/히스토그램** 반영, 플랜 안정화(SQL Baseline 필요 시).
- [ ] `DBMS_XPLAN ... +IOSTATS +MEMSTATS`로 **실측 검증**.

---

## 자주 쓰는 힌트/테크닉 스니펫

```sql
-- 조인 순서/메소드
SELECT /*+ ORDERED LEADING(s p) USE_HASH(p) NO_MERGE(s) MATERIALIZE */
...

-- Direct-path insert(대상 테이블 NOLOGGING 고려)
INSERT /*+ APPEND PARALLEL(8) */ INTO ...

-- MERGE에서 USING 서브쿼리 축소
MERGE INTO T
USING (SELECT /*+ MATERIALIZE */ ... FROM S WHERE ...) X
ON (...)
WHEN MATCHED THEN UPDATE ...
WHEN NOT MATCHED THEN INSERT ...;

-- EXISTS로 조기 종료
UPDATE (
  SELECT t.col
  FROM   T t
  WHERE  EXISTS (SELECT 1 FROM S WHERE S.key = T.key AND <강한 조건>)
) v
SET v.col = ...
```

---

### 마무리

- **조인 내포 DML**은 “어디서 얼마를 스캔/잠금/로그하느냐”가 전부다.
- **수정 가능 조인 뷰**로 **단일 UPDATE**를 만들고, **MERGE**로 **조건부 분기**를 한 번에 처리하며, **다중 테이블 INSERT**로 **한 번 스캔·복수 적재**를 구현하자.
- 마지막은 언제나 **플랜/실측**으로 확인! `ALLSTATS LAST +IOSTATS +MEMSTATS` 가 답을 준다.
