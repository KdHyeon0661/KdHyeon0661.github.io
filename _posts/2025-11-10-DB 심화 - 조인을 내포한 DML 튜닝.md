---
layout: post
title: DB 심화 - 조인을 내포한 DML 튜닝
date: 2025-11-10 23:25:23 +0900
category: DB 심화
---
# 조인을 내포한 DML 튜닝 — Updatable Join View · MERGE · Multi-Table INSERT의 실전 패턴과 함정

**목표**
- 조인이 필수인 DML(UPDATE/DELETE/INSERT)을 **한 번의 스캔, 한 번의 매칭**으로 처리하는 재작성 패턴을 체계적으로 정리합니다.
- **수정 가능 조인 뷰(Updatable Join View)**를 활용해 "조인 기반 UPDATE/DELETE"를 **단일 문장**으로 안정적으로 수행하는 방법을 학습합니다.
- **MERGE** 문을 사용해 "있으면 UPDATE, 없으면 INSERT(또는 DELETE)"를 **원자적(atomic)으로** 처리하면서 스필, 랜덤 I/O, Redo/Undo, 락 시간을 최소화합니다.
- **INSERT ALL / INSERT FIRST**를 활용해 소스를 1회만 스캔하여 다수 테이블에 **복수/분기 적재**를 구현하고 ETL/요약 동시 생성 성능을 극대화합니다.

**작업 원칙**
- **소스 집합을 먼저 줄여서(build 입력 축소)**
- **중복 매칭을 제거하고(유일 매칭 보장)**
- **불필요한 DML을 제거하며(Redo/Undo 최소화)**
- **락 범위를 줄이고(조기 필터·조건부 UPDATE)**
- **실측으로 검증합니다(ALLSTATS LAST + IOSTATS + MEMSTATS)**

---

## 실습 환경 준비

```sql
ALTER SESSION SET nls_date_format       = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level      = ALL;
ALTER SESSION SET workarea_size_policy  = AUTO;
```

### 테이블 및 인덱스 생성 + 샘플 데이터

아래는 즉시 실행 가능한 전체 DDL/데이터 생성 스크립트입니다.

```sql
-- 마스터: 상품 테이블
DROP TABLE PROD PURGE;
CREATE TABLE PROD (
  PROD_ID   NUMBER       PRIMARY KEY,
  CATEGORY  VARCHAR2(20) NOT NULL,
  BRAND     VARCHAR2(20) NOT NULL,
  PRICE     NUMBER(10,2) NOT NULL,
  LAST_UPD  DATE         NOT NULL
);

-- 재고/가격 스테이징 테이블
DROP TABLE STG_PRICE PURGE;
CREATE TABLE STG_PRICE (
  PROD_ID   NUMBER       NOT NULL,
  NEW_PRICE NUMBER(10,2) NOT NULL,
  AS_OF_DT  DATE         NOT NULL
);

-- 주문 헤더 테이블
DROP TABLE ORD PURGE;
CREATE TABLE ORD(
  ORDER_ID  NUMBER       PRIMARY KEY,
  ORDER_DT  DATE         NOT NULL,
  STATUS    VARCHAR2(8)  NOT NULL
);

-- 주문 상세 테이블
DROP TABLE OI PURGE;
CREATE TABLE OI(
  ORDER_ID  NUMBER       NOT NULL,
  LINE_NO   NUMBER       NOT NULL,
  PROD_ID   NUMBER       NOT NULL,
  QTY       NUMBER       NOT NULL,
  AMOUNT    NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY(ORDER_ID, LINE_NO)
);

-- 요약 적재 대상 테이블들
DROP TABLE SALES_DAILY PURGE;
CREATE TABLE SALES_DAILY (
  SALES_DT  DATE         NOT NULL,
  CATEGORY  VARCHAR2(20) NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL
);

DROP TABLE SALES_BRAND PURGE;
CREATE TABLE SALES_BRAND (
  SALES_DT  DATE         NOT NULL,
  BRAND     VARCHAR2(20) NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL
);

-- 성능을 위한 인덱스 생성
CREATE INDEX IX_OI_PROD    ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER   ON OI(ORDER_ID);
CREATE INDEX IX_ORD_DT     ON ORD(ORDER_DT);
CREATE INDEX IX_PROD_CAT   ON PROD(CATEGORY, PROD_ID);
CREATE INDEX IX_PROD_BRAND ON PROD(BRAND, PROD_ID);

-- 샘플 데이터 생성(대량)
BEGIN
  -- 10만 개 상품 데이터
  FOR p IN 1..100000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5)
        WHEN 0 THEN 'ELEC'
        WHEN 1 THEN 'FASH'
        WHEN 2 THEN 'FOOD'
        WHEN 3 THEN 'HOME'
        ELSE 'TOY'
      END,
      'BR'||TO_CHAR(MOD(p,50)),
      ROUND(DBMS_RANDOM.VALUE(5,500),2),
      SYSDATE-10
    );
  END LOOP;

  -- 10만 건 주문 데이터
  FOR o IN 1..100000 LOOP
    INSERT INTO ORD VALUES(
      o,
      DATE '2024-01-01' + MOD(o,200),
      CASE MOD(o,4)
        WHEN 0 THEN 'NEW'
        WHEN 1 THEN 'PAID'
        WHEN 2 THEN 'SHIP'
        ELSE 'DONE'
      END
    );
  END LOOP;

  -- 30만 건 주문 상세 데이터
  FOR i IN 1..300000 LOOP
    INSERT INTO OI VALUES(
      MOD(i,100000)+1,
      1 + MOD(i,3),
      MOD(i,100000)+1,
      TRUNC(DBMS_RANDOM.VALUE(1,5)),
      ROUND(DBMS_RANDOM.VALUE(10,1000),2)
    );
  END LOOP;

  -- 가격 변경 스테이징 데이터: 일부 상품만 포함
  FOR s IN 1..30000 LOOP
    INSERT INTO STG_PRICE VALUES(
      MOD(s,100000)+1,
      ROUND(DBMS_RANDOM.VALUE(5,500),2),
      DATE '2024-07-01'
    );
  END LOOP;

  COMMIT;
END;
/

-- 통계 정보 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OI'  , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'STG_PRICE', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

## 조인이 필요한 DML의 "본질적 비용" 이해하기

조인이 포함된 DML은 단순 SELECT보다 훨씬 더 비용이 높습니다. 그 이유를 명확히 이해해야 합니다.

1. **대상 행을 찾는 비용** - 조인과 필터링에 필요한 CPU 및 I/O
2. **행을 잠그는 비용** - row lock, ITL 확장, latch 경합
3. **Undo 생성 비용** - 원복 정보 저장을 위한 공간 및 I/O
4. **Redo 생성 비용** - 복구 및 아카이브 로그 기록
5. **인덱스 유지 비용** - 여러 인덱스의 갱신 작업
6. **연관 객체 처리 비용** - 트리거, MV log, FK 체크 등

이러한 비용 구조를 이해하면 DML 튜닝의 핵심이 명확해집니다:
- **대상 행을 더 빠르게, 더 적게 찾고**
- **불필요한 갱신을 제거하며**
- **한 번의 스캔과 한 번의 매칭으로 작업을 완료하는 것**

이러한 철학이 바로 **Updatable Join View**, **MERGE**, **Multi-Table INSERT**의 기반이 됩니다.

---

## Updatable Join View(수정 가능 조인 뷰) — 조인 + UPDATE/DELETE를 단일 문장으로

### 개념적 핵심

**조인 뷰를 통한 UPDATE/DELETE가 가능하려면 다음 조건을 충족해야 합니다:**

- 갱신 대상 테이블이 **key-preserved table**이어야 합니다.
  즉, 뷰 결과에서 해당 테이블의 PK/UK가 **중복 없이 보존**되어야 합니다.
- **한 테이블만** 갱신 가능합니다.
  (조인된 여러 테이블을 하나의 UPDATE 문으로 동시에 변경할 수 없습니다.)
- 다음 요소가 뷰에 포함되면 **갱신이 불가능**합니다:
  - 집계(GROUP BY, SUM 등)
  - DISTINCT
  - 집합 연산(UNION/INTERSECT/MINUS)
  - CONNECT BY / ROWNUM 기반 변형
  - 비결정적 함수로 키 보존을 해치는 경우

**중요한 직관**
- "조인을 통해 필터링은 수행하되, 실제로 변경하는 테이블은 한 곳만을 대상으로 한다."
- 이 원칙을 준수하면 Oracle은 **조인 순서를 자유롭게 최적화**할 수 있고,
  사용자는 조인 결과를 별도로 생성한 후 반복적인 UPDATE를 수행하는 비효율을 피할 수 있습니다.

### 기본 예제 — "주문이 존재하는 ELEC 상품만 3% 인상"

```sql
UPDATE (
  SELECT /*+ LEADING(p i o) USE_NL(i) USE_NL(o) */
         p.price AS price_to_update
  FROM   PROD p
  JOIN   OI   i ON i.prod_id  = p.prod_id
  JOIN   ORD  o ON o.order_id = i.order_id
  WHERE  p.category = 'ELEC'
  AND    o.order_dt >= SYSDATE - 30
) v
SET v.price_to_update = v.price_to_update * 1.03;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

**이 접근법의 장점**
- 조인 결과를 "임시 테이블로 생성한 후 다시 UPDATE"하는 2단계 프로세스가 아닙니다.
- Oracle은 뷰 내부의 조인을 **세미 조인, 안티 조인, 조인 필터** 등으로 자유롭게 변환할 수 있습니다.
- 갱신 대상이 PROD 테이블 하나이므로 key-preserved 조건이 명확히 충족됩니다.

### 중복 매칭의 위험과 해결 전략

조인으로 인해 동일한 PROD 행이 여러 OI/ORD 행과 매칭될 수 있다면,
뷰 업데이트가 **"중복 UPDATE 시도"**를 초래하며, 경우에 따라 에러나 비효율을 야기할 수 있습니다.

#### 가장 간단한 해결책: EXISTS로 재작성

```sql
UPDATE (
  SELECT p.price AS price_to_update
  FROM   PROD p
  WHERE  p.category = 'ELEC'
  AND    EXISTS (
           SELECT 1
           FROM   OI i
           JOIN   ORD o ON o.order_id = i.order_id
           WHERE  i.prod_id = p.prod_id
           AND    o.order_dt >= SYSDATE - 30
         )
) v
SET v.price_to_update = v.price_to_update * 1.03;
```

- EXISTS는 내부에서 매칭이 발견되면 **즉시 종료**되어 조인 결과 집합의 폭발적 증가를 방지합니다.
- key-preserved 조건이 자동으로 유지됩니다.

#### DISTINCT 사용 방식(주의 필요)

```sql
UPDATE (
  SELECT DISTINCT p.prod_id, p.price AS price_to_update
  FROM   PROD p
  JOIN   OI i  ON i.prod_id  = p.prod_id
  JOIN   ORD o ON o.order_id = i.order_id
  WHERE  p.category = 'ELEC'
  AND    o.order_dt >= SYSDATE - 30
) v
SET v.price_to_update = v.price_to_update * 1.03;
```

- DISTINCT가 포함되면 **일부 버전이나 상황에서 key-preserved 판단이 복잡해질 수 있습니다**.
- 가능하면 EXISTS 방식이 더 안정적입니다.

### Updatable Join View를 활용한 DELETE 작업

"주문이 한 번도 없는 상품 삭제"와 같은 패턴을 구현합니다.

```sql
DELETE FROM (
  SELECT p.*
  FROM   PROD p
  WHERE  NOT EXISTS (
           SELECT 1
           FROM   OI i
           WHERE  i.prod_id = p.prod_id
         )
) v;
```

- 갱신 대상(삭제 대상) 테이블이 PROD 하나이므로 key-preserved 조건이 충족됩니다.
- 안티 조인이 자동으로 적용될 가능성이 높습니다.

### 외부조인과 NULL 보존이 포함된 경우의 처리

외부조인이 포함된 조인 뷰는 **의미 보존이 애매해지는 순간 key-preserved 판단이 어려워지고 갱신이 불가능**해질 수 있습니다.

해결 방법은 두 가지입니다:

1. **외부조인을 뷰 외부로 이동하여 재작성**
2. **INSTEAD OF 트리거를 사용해 뷰를 "갱신 가능하게" 변환**

#### INSTEAD OF 트리거 활용 예시

```sql
CREATE OR REPLACE VIEW V_PROD_EXT AS
SELECT p.prod_id, p.category, p.brand, p.price,
       s.new_price
FROM   PROD p
LEFT JOIN STG_PRICE s ON s.prod_id = p.prod_id;

CREATE OR REPLACE TRIGGER TR_V_PROD_EXT_UPD
INSTEAD OF UPDATE ON V_PROD_EXT
FOR EACH ROW
BEGIN
  UPDATE PROD
  SET price    = :NEW.price,
      last_upd = SYSDATE
  WHERE prod_id = :OLD.prod_id;
END;
/
```

- 복잡한 조인 뷰라도 "갱신 규칙을 직접 정의"하면 갱신이 가능해집니다.
- 하지만 트리거는 **숨겨진 비용과 복잡성**이 수반되므로,
  먼저 수동 재작성으로 해결 가능한지 검토하는 것이 좋습니다.

---

## MERGE — 조건부 UPDATE/INSERT/DELETE를 단일 작업으로

### MERGE의 역할과 장점

`MERGE` 문은 다음 작업들을 **단일 DML 작업**으로 통합합니다:

- **매칭된 행은 UPDATE**
- **매칭되지 않은 행은 INSERT**
- **(선택적) 매칭된 행 중 조건을 만족하는 경우 DELETE**

이러한 통합으로 다음과 같은 이점을 얻을 수 있습니다:

- "찾고 → 갱신/삽입"의 **왕복 작업을 제거**
- 동시성 상황에서 **경쟁 조건(race condition)을 최소화**
- 소스 집합이 한 번만 스캔되면 매우 빠른 성능 달성

### 기본 예제 — STG_PRICE를 활용한 PROD 가격 동기화

```sql
MERGE /*+ USE_HASH(s) */ INTO PROD p
USING (
  SELECT /*+ MATERIALIZE */
         prod_id, new_price, as_of_dt
  FROM   STG_PRICE
) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.price    = s.new_price,
             p.last_upd = s.as_of_dt
  WHERE p.price <> s.new_price
WHEN NOT MATCHED THEN
  INSERT (p.prod_id, p.category, p.brand, p.price, p.last_upd)
  VALUES (s.prod_id, 'UNKNOWN', 'UNKNOWN', s.new_price, s.as_of_dt);

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

**핵심 튜닝 포인트**
1. `USING` 절의 입력을 **먼저 줄여서(필터링/집계/Distinct)** 해시 빌드 입력 크기를 최소화합니다.
2. `WHERE p.price <> s.new_price` 조건으로 **불필요한 UPDATE를 제거**합니다.
   - Redo/Undo 생성량 감소
   - row lock 유지 시간 단축
   - 인덱스 유지 비용 절감

### MERGE의 가장 흔한 실패 원인: 복수 매칭(ORA-30926)

MERGE 작업에서 `ON` 조건은 **유일한 매칭**을 보장해야 합니다.
소스 STG_PRICE에 동일한 PROD_ID가 **2건 이상** 존재하면 작업이 실패합니다.

#### 소스에서 중복 제거 방법

```sql
MERGE INTO PROD p
USING (
  SELECT prod_id,
         MAX(new_price) KEEP (DENSE_RANK LAST ORDER BY as_of_dt) AS new_price,
         MAX(as_of_dt)  AS as_of_dt
  FROM   STG_PRICE
  GROUP  BY prod_id
) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.price    = s.new_price,
             p.last_upd = s.as_of_dt
  WHERE p.price <> s.new_price
WHEN NOT MATCHED THEN
  INSERT (prod_id, category, brand, price, last_upd)
  VALUES (s.prod_id, 'UNKNOWN','UNKNOWN', s.new_price, s.as_of_dt);
```

- **"키별 최종 1건"**만 남겨 유일 매칭을 보장합니다.

### MERGE로 조건부 DELETE 포함하기

예시: "스테이징에 있는 상품은 가격을 동기화하고, 특정 카테고리는 삭제"

```sql
MERGE INTO PROD p
USING (
  SELECT prod_id, new_price, as_of_dt
  FROM   STG_PRICE
) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.price = s.new_price,
             p.last_upd = s.as_of_dt
DELETE WHERE p.category = 'TO_BE_PURGED';
```

**주의사항**
- DELETE WHERE 절은 **매칭된 행만** 후보 대상이 됩니다.
- "스테이징에 없는 키를 삭제(anti-join delete)"는
  별도의 DELETE 문이 더 명확하고 빠를 수 있습니다.

### MERGE 성능에 영향을 미치는 주요 요소들

#### USING 서브쿼리의 "빌드 입력 크기"

- 해시 MERGE 실행계획에서 `USING` 절이 빌드 입력이 되는 경우,
  빌드 입력이 크면 TEMP 스필이 발생하고 성능이 급격히 저하됩니다.
- 따라서 `USING` 절에서 **반드시 1차 축소**를 시도해야 합니다.

```sql
MERGE INTO PROD p
USING (
  SELECT /*+ MATERIALIZE */
         prod_id, new_price, as_of_dt
  FROM   STG_PRICE
  WHERE  as_of_dt >= DATE '2024-07-01'
) s
ON (p.prod_id = s.prod_id)
...
```

#### 매칭 조건의 SARGability

- `ON (p.prod_id = s.prod_id)`와 같은 **단순 등치 조건**이 최선입니다.
- 컬럼에 함수나 연산이 포함되면 인덱스 접근이 어려워지고 매칭 비용이 증가합니다.

#### 대상 테이블의 인덱스 수

- UPDATE/INSERT 작업은 모든 인덱스를 **유지보수**해야 합니다.
- 대량 배치 작업의 경우:
  1) 인덱스를 최소화하거나
  2) 적재 완료 후 인덱스를 재생성하는 전략이 더 빠를 수 있습니다(업무 정책과 락 허용 범위에 따라).

### MERGE와 동시성 고려사항

- 동일한 키에 대해 다중 세션이 동시에 MERGE/INSERT를 수행하면
  - 대상 테이블에 PK/UK가 존재하면 **unique 제약 조건 위반이 발생**할 수 있습니다.
  - MERGE는 내부적으로 "매칭 검사 + 삽입" 작업을 포함하므로 완벽한 동시성 해결책은 아닙니다.
- **동시 삽입이 빈번한 상황**에서는
  - UPSERT 작업을 **직렬화(큐/배치)**하거나
  - 애플리케이션 레벨에서 키 범위를 분할하거나
  - 필요 시 `INSERT ... ON CONFLICT`와 유사한 패턴을 검토합니다(Oracle에서는 MERGE가 유사한 역할 수행).

---

## 다중 테이블 INSERT — INSERT ALL / INSERT FIRST

### 역할과 장점

**한 번의 소스 스캔**으로 다음과 같은 작업을 동시에 수행할 수 있습니다:

- 여러 테이블에 **복수 적재**
- 조건에 따라 **분기 적재**
- 요약 테이블과 상세 테이블을 **동시 생성**
- 파티션별 분할 적재

이는 ETL 작업에서 **I/O를 최소화하는 강력한 도구**입니다.

### INSERT ALL — 모든 조건을 만족하면 모두 적재

#### 기본 예제: 일자별 카테고리 및 브랜드 요약 동시 적재

```sql
INSERT /*+ APPEND PARALLEL(4) */ ALL
  WHEN category IS NOT NULL THEN
    INTO SALES_DAILY (SALES_DT, CATEGORY, AMOUNT)
    VALUES (order_dt, category, amount)
  WHEN brand IS NOT NULL THEN
    INTO SALES_BRAND (SALES_DT, BRAND, AMOUNT)
    VALUES (order_dt, brand, amount)
SELECT /*+ LEADING(i p o) USE_HASH(p) USE_HASH(o) */
       TRUNC(o.order_dt) AS order_dt,
       p.category,
       p.brand,
       i.amount
FROM   OI i
JOIN   PROD p ON p.prod_id = i.prod_id
JOIN   ORD  o ON o.order_id = i.order_id
WHERE  o.order_dt BETWEEN DATE '2024-06-01' AND DATE '2024-06-30';

COMMIT;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
'ALLSTATS LAST +IOSTATS +MEMSTATS'));
```

**특징**
- 소스 데이터를 1회만 스캔합니다.
- WHEN 조건이 모두 참이면 **두 테이블 모두에 적재**됩니다.

### INSERT FIRST — 첫 번째 충족 조건만 적재(우선순위 기반 분기)

```sql
INSERT /*+ APPEND */ FIRST
  WHEN category IN ('ELEC','FASH') THEN
    INTO SALES_DAILY (SALES_DT, CATEGORY, AMOUNT)
    VALUES (order_dt, category, amount)
  WHEN 1=1 THEN
    INTO SALES_BRAND (SALES_DT, BRAND, AMOUNT)
    VALUES (order_dt, brand, amount)
SELECT TRUNC(o.order_dt) order_dt, p.category, p.brand, i.amount
FROM   OI i
JOIN   PROD p ON p.prod_id = i.prod_id
JOIN   ORD  o ON o.order_id = i.order_id
WHERE  o.order_dt >= DATE '2024-06-01';
```

- `ELEC/FASH` 카테고리는 DAILY 테이블에만 적재되고, 나머지는 BRAND 테이블에만 적재됩니다.
- **상호배타적 분기**에 최적화된 패턴입니다.

### 사전 집계 + Multi-Insert (대량 데이터 처리에 매우 중요)

요약 테이블에 원시 데이터를 그대로 적재하는 것보다
**사전 집계를 통해 행 수를 줄인 후 적재**하는 것이 훨씬 효율적입니다.

```sql
INSERT ALL
  INTO SALES_DAILY (SALES_DT, CATEGORY, AMOUNT)
  VALUES (sales_dt, category, amt)
  INTO SALES_BRAND (SALES_DT, BRAND, AMOUNT)
  VALUES (sales_dt, brand, amt)
SELECT sales_dt, category, brand, amt
FROM (
  SELECT TRUNC(o.order_dt) sales_dt,
         p.category,
         p.brand,
         SUM(i.amount) amt
  FROM   OI i
  JOIN   PROD p ON p.prod_id = i.prod_id
  JOIN   ORD  o ON o.order_id = i.order_id
  WHERE  o.order_dt BETWEEN DATE '2024-06-01' AND DATE '2024-06-30'
  GROUP BY TRUNC(o.order_dt), p.category, p.brand
);
```

**장점**
- 적재 대상 행 수가 급감하여 Redo/Undo 및 인덱스 유지 비용이 대폭 감소합니다.
- 소스 집합을 `GROUP BY`로 축소한 후 Multi-Insert를 수행하므로
  전체 파이프라인이 가벼워집니다.

### Multi-Insert에서 자주 발생하는 문제점들

1. **대상 테이블의 인덱스 과다**
   - INSERT 작업이 인덱스 유지 비용으로 인해 병목 현상이 발생할 수 있습니다.

2. **APPEND 힌트 사용 시 인덱스/제약 조건 비용**
   - Direct-path insert는 데이터 삽입 자체는 빠르지만
     많은 인덱스가 있는 테이블에서는 오히려 성능이 저하될 수 있습니다.

3. **병렬 DML과 TEMP/PGA 사용량**
   - 병렬로 스캔, 집계, 다중 적재를 수행할 경우
     PGA/TEMP 사용량이 급증할 수 있습니다.

4. **조건 순서의 중요성**
   - INSERT FIRST에서는 WHEN 절의 순서가 **비즈니스 규칙** 그 자체입니다.
     순서가 잘못되면 데이터가 의도하지 않은 테이블에 적재될 수 있습니다.

---

## 도구별 선택 가이드와 성능 개선 순서

### 언제 Updatable Join View를 사용할까?

- **조인 조건으로 대상 행을 필터링하고**
- **갱신 대상이 하나의 테이블만 해당되며**
- **중복 매칭을 EXISTS로 해결 가능하고**
- **집계나 집합 연산이 필요하지 않은 경우**

즉, "조인 기반 필터링이 필요한 UPDATE/DELETE" 작업의 1순위 선택입니다.

### 언제 MERGE를 사용할까?

- **업서트(UPDATE+INSERT)가 필요한 경우**
- 소스가 스테이징/외부 시스템에서 제공되고,
  대상 테이블과 **동기화**가 필요한 경우
- 작업의 **동시성과 원자성**을 보장해야 하는 경우

### 언제 Multi-Insert를 사용할까?

- **소스를 1회 스캔하여 여러 테이블에 동시 적재**가 필요한 경우
- ETL 작업, 요약 테이블 생성, 분기 적재, 파티션 분할 로딩
- 보고용 요약 테이블을 "원천 데이터 로딩 단계에서 함께 생성"해야 하는 경우

---

## 실전 패턴 모음

### "매칭된 것만 UPDATE, 미매칭은 무시" — UPDATE 전용 MERGE

```sql
MERGE INTO PROD p
USING (
  SELECT /*+ MATERIALIZE */ prod_id, new_price, as_of_dt
  FROM STG_PRICE
) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN
  UPDATE SET p.price = s.new_price, p.last_upd = s.as_of_dt
  WHERE p.price <> s.new_price;
```

- "INSERT가 필요 없는 동기화" 작업에 단순하고 안전한 패턴입니다.

### "미매칭만 INSERT, 매칭은 무시" — INSERT 전용 MERGE

```sql
MERGE INTO PROD p
USING (
  SELECT prod_id, new_price, as_of_dt
  FROM STG_PRICE
) s
ON (p.prod_id = s.prod_id)
WHEN NOT MATCHED THEN
  INSERT (prod_id, category, brand, price, last_upd)
  VALUES (s.prod_id, 'UNKNOWN','UNKNOWN', s.new_price, s.as_of_dt);
```

- 신규 데이터만 적재하는 배치 작업에서 "중복 키는 무시"해야 할 때 유용합니다.

### "키별 최종 상태만 반영" — USING에서 Top-1 생성 후 MERGE

```sql
MERGE INTO PROD p
USING (
  SELECT prod_id,
         MAX(new_price) KEEP (DENSE_RANK LAST ORDER BY as_of_dt) AS new_price,
         MAX(as_of_dt) AS as_of_dt
  FROM STG_PRICE
  GROUP BY prod_id
) s
ON (p.prod_id = s.prod_id)
WHEN MATCHED THEN UPDATE
  SET p.price = s.new_price, p.last_upd = s.as_of_dt
  WHERE p.price <> s.new_price;
```

- 중복 매칭 제거와 입력 축소를 **한 번에 수행**합니다.

### "대상 소량, 내부 대량" — APPLY로 Top-1만 읽어 UPDATE

```sql
-- 전제: (prod_id, last_upd desc) 같은 인덱스가 있으면 더 좋음
UPDATE (
  SELECT p.price,
         v.new_price
  FROM PROD p
  CROSS APPLY (
    SELECT s.new_price
    FROM STG_PRICE s
    WHERE s.prod_id = p.prod_id
    ORDER BY s.as_of_dt DESC
    FETCH FIRST 1 ROWS ONLY
  ) v
  WHERE p.category = 'ELEC'
) x
SET x.price = x.new_price;
```

- Updatable join view와 LATERAL Top-1의 조합입니다.
- "외부는 소량"일 때 내부를 Stopkey로 1건만 읽어 랜덤 I/O를 최소화합니다.

---

## 검증 방법 — 실측 데이터로 확인하기

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL,NULL,
         'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'));
```

**실측 데이터 분석 순서**
1. **A-Rows가 E-Rows와 크게 다른가?**
   → 통계 정보, 상관관계, 히스토그램 재검토 필요

2. **Buffers 수치가 과도한가?**
   → 대상 행 수를 줄이는 필터 재작성 또는 인덱스 개선 검토

3. **TempSpc/MemSTATS에서 스필이 발생하는가?**
   → USING/조인 입력 축소, 해시 워크에어리어 확대 검토

4. **UPDATE/INSERT 행 수가 예상보다 많은가?**
   → 불필요한 DML 제거(조건부 UPDATE, Top-1) 검토

5. **실행 시간 대부분이 DML 단계인가?**
   → 인덱스, 트리거, 제약 조건, MV log 비용 점검

---

## 결론

조인이 포함된 DML 작업을 효과적으로 튜닝하기 위해 세 가지 강력한 도구를 적절히 활용해야 합니다:

**Updatable Join View**는 "조인을 통해 대상을 필터링하여 한 테이블만 변경하는 DML"을 가장 간결하고 효율적으로 처리하는 방법입니다. 특히 EXISTS 패턴과 결합하면 중복 매칭 문제를 우아하게 해결할 수 있습니다.

**MERGE**는 "조건부 UPDATE/INSERT/DELETE"를 원자적으로 수행하며, 성능 향상의 핵심은 **USING 입력 축소와 불필요한 DML 제거**에 있습니다. 중복 매칭 문제를 사전에 해결하고, 변경이 실제로 필요한 경우에만 작업을 수행하는 것이 중요합니다.

**Multi-Table INSERT**는 "소스를 1회만 스캔하여 복수 테이블에 분기 적재"를 구현하는 ETL의 표준 패턴입니다. 대량 데이터 처리 시에는 **사전 집계 후 적재** 전략이 결정적인 성능 차이를 만들어냅니다.

이 세 가지 도구를 정확히 이해하고 상황에 맞게 적용하면, 조인이 포함된 복잡한 DML 작업도 **SELECT 수준의 단순한 비용 구조**로 환원하여 안정적이고 빠른 튜닝을 달성할 수 있습니다. 최종적으로는 항상 실측 실행계획과 통계를 통해 성능 개선 효과를 검증하는 습관이 필요합니다.