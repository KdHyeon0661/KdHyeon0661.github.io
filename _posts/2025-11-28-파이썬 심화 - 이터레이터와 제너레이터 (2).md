---
layout: post
title: 파이썬 심화 - 이터레이터와 제너레이터 (2)
date: 2025-11-28 15:25:23 +0900
category: 파이썬 심화
---
# 이터레이터와 제너레이터 (2)

파이썬에서 이터레이터와 제너레이터를 효과적으로 다루는 방법은 데이터 처리의 효율성과 코드의 가독성을 크게 향상시킵니다. 다양한 순회 패턴과 조합 기법을 통해 복잡한 데이터 구조도 우아하게 처리할 수 있습니다.

## 이터레이터의 일부 얻기

대용량 이터러블 객체에서 처음 몇 개의 요소만 확인하거나 특정 조건을 만족하는 요소들만 추출하는 방법을 살펴봅니다.

```python
# 1. itertools.islice()를 이용한 슬라이싱
import itertools

def read_large_file_in_chunks(file_path, chunk_size=1000):
    """
    대용량 파일을 청크 단위로 읽는 제너레이터
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        while True:
            chunk = list(itertools.islice(f, chunk_size))
            if not chunk:
                break
            yield chunk

# 2. 제너레이터 표현식과 islice 결합
def get_first_n_primes(n):
    """
    처음 n개의 소수를 찾는 제너레이터
    """
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True
    
    count = 0
    num = 2
    while count < n:
        if is_prime(num):
            yield num
            count += 1
        num += 1

# 처음 10개의 소수 출력
first_10_primes = list(itertools.islice(get_first_n_primes(100), 10))
print(f"처음 10개의 소수: {first_10_primes}")

# 3. 조건에 맞는 요소들만 추출
data_stream = [1, 4, -2, 10, -8, 3, 0, -5, 7, -1]

# 양수만 추출
positive_numbers = (x for x in data_stream if x > 0)
first_5_positives = list(itertools.islice(positive_numbers, 5))
print(f"처음 5개 양수: {first_5_positives}")

# 4. 무한 이터레이터에서 유한 부분 추출
# 무한 카운터에서 일부만 가져오기
counter = itertools.count(start=10, step=2)  # 10부터 2씩 증가하는 무한 시퀀스
first_10_even = list(itertools.islice(counter, 10))
print(f"10부터 시작하는 10개의 짝수: {first_10_even}")

# 5. 실시간 데이터 스트림 처리 시뮬레이션
import random
import time

def generate_sensor_data():
    """
    센서 데이터를 실시간으로 생성하는 시뮬레이션
    """
    while True:
        # 온도, 습도, 압력 데이터 생성
        temperature = 20 + random.uniform(-5, 5)
        humidity = 50 + random.uniform(-10, 10)
        pressure = 1013 + random.uniform(-10, 10)
        yield {
            'temperature': round(temperature, 2),
            'humidity': round(humidity, 2),
            'pressure': round(pressure, 2),
            'timestamp': time.time()
        }

# 최근 5개의 센서 데이터만 모니터링
sensor_stream = generate_sensor_data()
recent_readings = []

for _ in range(20):  # 20개 데이터 생성
    data = next(sensor_stream)
    recent_readings.append(data)
    if len(recent_readings) > 5:  # 최근 5개만 유지
        recent_readings.pop(0)
    
    print(f"\n최근 {len(recent_readings)}개 측정값:")
    for reading in recent_readings:
        print(f"  온도: {reading['temperature']}°C, 습도: {reading['humidity']}%")
    time.sleep(0.1)

# 6. 슬라이싱과 필터링 조합
def process_log_file(file_path, keyword, max_results=50):
    """
    대용량 로그 파일에서 특정 키워드가 포함된 줄만 제한적으로 검색
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        # 제너레이터 표현식으로 메모리 효율적으로 필터링
        filtered_lines = (line for line in f if keyword in line)
        # 결과 수 제한
        results = itertools.islice(filtered_lines, max_results)
        return list(results)

# 7. 윈도우 기반 데이터 처리
def sliding_window(data, window_size):
    """
    데이터 스트림을 슬라이딩 윈도우로 처리
    """
    it = iter(data)
    window = list(itertools.islice(it, window_size))
    yield window
    
    for elem in it:
        window = window[1:] + [elem]
        yield window

# 이동 평균 계산
stock_prices = [100, 102, 101, 105, 104, 106, 108, 110, 109, 111]
window_size = 3

print(f"\n주식 가격의 {window_size}일 이동 평균:")
for window in sliding_window(stock_prices, window_size):
    avg = sum(window) / len(window)
    print(f"  {window} → 평균: {avg:.2f}")
```

## 순환 객체의 첫 번째 부분 건너뛰기

데이터의 헤더, 주석, 또는 초기 불필요한 부분을 건너뛰고 실제 데이터부터 처리하는 방법을 다룹니다.

```python
import itertools

# 1. itertools.dropwhile()을 이용한 조건부 스킵
def process_csv_file(file_path):
    """
    CSV 파일에서 주석(#)으로 시작하는 줄을 건너뛰고 데이터 처리
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        # '#'으로 시작하지 않는 첫 줄부터 시작
        data_lines = itertools.dropwhile(lambda line: line.strip().startswith('#'), f)
        
        for line in data_lines:
            if line.strip():  # 빈 줄 건너뛰기
                yield line.strip().split(',')

# CSV 파일 처리 예시
csv_content = """# 주석: 이 파일은 샘플 데이터입니다.
# 생성일: 2024-01-15
name,age,city,score
김철수,30,서울,85
이영희,28,부산,92
박지민,35,대구,78
# 추가 데이터...
최윤호,40,인천,88"""

# 파일로 저장 후 처리 (시뮬레이션)
import tempfile
with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False, encoding='utf-8') as f:
    f.write(csv_content)
    temp_file = f.name

print("CSV 파일 처리 결과:")
for row in process_csv_file(temp_file):
    print(f"  {row}")

# 2. itertools.takewhile()과 dropwhile() 조합
def read_config_file(file_path):
    """
    설정 파일에서 [Header] 섹션 건너뛰고 [Data] 섹션부터 읽기
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        # [Header] 섹션 건너뛰기
        lines_after_header = itertools.dropwhile(
            lambda line: line.strip() != '[Data]', 
            f
        )
        
        # [Data] 섹션 다음 줄부터 시작
        next(lines_after_header)  # [Data] 줄 자체는 건너뛰기
        
        # [End]를 만날 때까지 데이터 읽기
        data_lines = itertools.takewhile(
            lambda line: line.strip() != '[End]',
            lines_after_header
        )
        
        return [line.strip() for line in data_lines if line.strip()]

# 3. 헤더가 있는 데이터 파일 처리
def parse_data_with_header(file_path):
    """
    헤더 줄을 건너뛰고 실제 데이터 파싱
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        lines = iter(f)
        
        # 헤더 건너뛰기 (첫 줄)
        header = next(lines)
        print(f"헤더: {header.strip()}")
        
        # 두 번째 줄부터 데이터 처리
        for i, line in enumerate(lines, 1):
            if line.strip():  # 빈 줄 제외
                values = line.strip().split()
                print(f"데이터 {i}: {values}")

# 4. 실시간 스트림에서 초기 캘리브레이션 데이터 스킵
def process_sensor_stream_with_calibration(sensor_stream, calibration_samples=100):
    """
    센서 데이터 스트림에서 초기 캘리브레이션 단계 건너뛰기
    """
    # 캘리브레이션 샘플 건너뛰기
    calibrated_stream = itertools.islice(sensor_stream, calibration_samples, None)
    
    for data in calibrated_stream:
        yield data

# 5. 다양한 패턴의 데이터 스킵
def skip_initial_pattern(data, pattern_func):
    """
    특정 패턴이 끝날 때까지 데이터 건너뛰기
    """
    it = iter(data)
    
    # 패턴 함수가 True를 반환하는 동안 건너뛰기
    for item in it:
        if not pattern_func(item):
            # 패턴이 끝나면 현재 item부터 시작
            yield item
            break
    
    # 나머지 데이터 처리
    for item in it:
        yield item

# 테스트: 0보다 작은 숫자가 나올 때까지 건너뛰기
test_data = [1, 2, 3, 4, -1, 5, 6, 7, -2, 8, 9]
result = list(skip_initial_pattern(test_data, lambda x: x > 0))
print(f"\n양수 패턴 스킵 결과: {result}")

# 6. 멀티라인 헤더 처리
def skip_multiline_header(file_obj, header_lines=3):
    """
    여러 줄로 구성된 헤더 건너뛰기
    """
    for _ in range(header_lines):
        next(file_obj)
    
    for line in file_obj:
        yield line

# 7. 조건부 스킵을 이용한 데이터 정제
def clean_data_stream(data_stream, outlier_threshold=100):
    """
    초기 아웃라이어를 건너뛰고 안정된 데이터부터 처리
    """
    # 아웃라이어 건너뛰기
    stable_stream = itertools.dropwhile(
        lambda x: abs(x) > outlier_threshold,
        data_stream
    )
    
    return stable_stream

# 시뮬레이션: 초기 노이즈가 있는 센서 데이터
sensor_readings = [150, 180, 120, 95, 25, 23, 24, 22, 25, 23, 24]
clean_readings = list(clean_data_stream(sensor_readings, outlier_threshold=100))
print(f"\n정제된 센서 데이터: {clean_readings}")
```

## 가능한 모든 순열과 조합 순환

수학적 조합과 순열을 생성하고 순회하는 방법으로, 검색 공간 탐색이나 모든 가능한 경우의 수 분석에 유용합니다.

```python
import itertools
import math

# 1. 순열(Permutation) 생성
def generate_permutations_example():
    """
    순열: 순서가 중요한 조합 (nPr)
    """
    items = ['A', 'B', 'C']
    
    print("1. 모든 순열 (전체 순서 재배열):")
    all_perms = list(itertools.permutations(items))
    for i, perm in enumerate(all_perms, 1):
        print(f"  {i}. {perm}")
    
    print(f"\n총 {len(all_perms)}개의 순열")
    
    print("\n2. r개의 요소를 선택한 순열 (nPr):")
    for r in range(1, len(items) + 1):
        perms_r = list(itertools.permutations(items, r))
        print(f"  P({len(items)}, {r}) = {len(perms_r)}개: {perms_r}")
    
    return all_perms

# 2. 조합(Combination) 생성
def generate_combinations_example():
    """
    조합: 순서가 중요하지 않은 조합 (nCr)
    """
    items = ['W', 'X', 'Y', 'Z']
    
    print("\n3. 모든 조합 (부분집합):")
    all_combs = []
    for r in range(1, len(items) + 1):
        combs_r = list(itertools.combinations(items, r))
        all_combs.extend(combs_r)
        
        print(f"  C({len(items)}, {r}) = {len(combs_r)}개:")
        for comb in combs_r:
            print(f"    {comb}")
    
    print(f"\n총 {len(all_combs)}개의 조합")
    return all_combs

# 3. 중복을 허용한 순열과 조합
def generate_with_repetition():
    """
    중복을 허용한 순열과 조합
    """
    items = ['A', 'B']
    
    print("\n4. 중복 순열 (중복 허용, 순서 중요):")
    # product는 데카르트 곱으로 중복 순열 생성
    repeat_perm = list(itertools.product(items, repeat=3))
    print(f"  {len(items)}³ = {len(repeat_perm)}개:")
    for perm in repeat_perm:
        print(f"    {perm}")
    
    print("\n5. 중복 조합 (중복 허용, 순서 무관):")
    # combinations_with_replacement는 중복 조합
    repeat_comb = list(itertools.combinations_with_replacement(items, 3))
    print(f"  H({len(items)}, 3) = {len(repeat_comb)}개:")
    for comb in repeat_comb:
        print(f"    {comb}")

# 4. 실전 예제 1: 비밀번호 크래킹 시뮬레이션
def password_cracking_simulation():
    """
    가능한 모든 비밀번호 조합 생성 (교육 목적)
    """
    characters = ['a', 'b', 'c', '1', '2', '3']
    password_length = 3
    
    print("\n6. 비밀번호 조합 생성 시뮬레이션:")
    print(f"  문자 집합: {characters}")
    print(f"  비밀번호 길이: {password_length}")
    
    total_combinations = len(characters) ** password_length
    print(f"  가능한 조합 수: {total_combinations:,}")
    
    # 메모리 효율적으로 조합 생성 (제너레이터 사용)
    password_generator = itertools.product(characters, repeat=password_length)
    
    # 샘플로 일부만 출력
    print("  샘플 조합:")
    sample_passwords = list(itertools.islice(password_generator, 10))
    for i, pwd in enumerate(sample_passwords, 1):
        print(f"    {i}. {''.join(pwd)}")
    
    print(f"  ... (총 {total_combinations:,}개 중 10개만 표시)")

# 5. 실전 예제 2: 팀 구성 최적화
def optimize_team_formation():
    """
    가능한 모든 팀 구성 탐색
    """
    players = ['김철수', '이영희', '박지민', '최윤호', '정민지']
    team_size = 3
    
    print("\n7. 팀 구성 최적화:")
    print(f"  선수: {players}")
    print(f"  팀 크기: {team_size}명")
    
    # 가능한 모든 팀 조합
    team_combinations = list(itertools.combinations(players, team_size))
    
    print(f"  가능한 팀 수: {len(team_combinations)}")
    print("  모든 팀 조합:")
    for i, team in enumerate(team_combinations, 1):
        print(f"    팀 {i}: {team}")

# 6. 실전 예제 3: 여행 경로 계획
def plan_travel_routes():
    """
    가능한 모든 여행 경로 탐색
    """
    cities = ['서울', '부산', '대구', '광주', '대전']
    
    print("\n8. 여행 경로 계획:")
    print(f"  방문할 도시: {cities}")
    
    # 모든 가능한 경로 (순열)
    all_routes = list(itertools.permutations(cities))
    
    print(f"  가능한 경로 수: {len(all_routes):,}")
    
    # 각 경로의 거리 계산 (가상의 거리 행렬)
    distance_matrix = {
        ('서울', '부산'): 325,
        ('서울', '대구'): 237,
        ('서울', '광주'): 268,
        ('서울', '대전'): 140,
        ('부산', '대구'): 88,
        ('부산', '광주'): 200,
        ('부산', '대전'): 240,
        ('대구', '광주'): 150,
        ('대구', '대전'): 120,
        ('광주', '대전'): 160,
    }
    
    # 대칭 거리 추가
    for (city1, city2), dist in list(distance_matrix.items()):
        distance_matrix[(city2, city1)] = dist
    
    # 최단 경로 찾기
    shortest_route = None
    shortest_distance = float('inf')
    
    for route in all_routes:
        total_distance = 0
        for i in range(len(route) - 1):
            city1, city2 = route[i], route[i + 1]
            total_distance += distance_matrix.get((city1, city2), 0)
        
        if total_distance < shortest_distance:
            shortest_distance = total_distance
            shortest_route = route
    
    print(f"  최단 경로: {' → '.join(shortest_route)}")
    print(f"  최단 거리: {shortest_distance}km")

# 7. 실전 예제 4: 수학 문제 생성
def generate_math_problems():
    """
    모든 가능한 수식 조합 생성
    """
    numbers = [2, 3, 5, 7]
    operators = ['+', '-', '*', '/']
    
    print("\n9. 수학 문제 생성기:")
    
    # 모든 숫자 순열 (3개 숫자 선택)
    number_perms = list(itertools.permutations(numbers, 3))
    
    # 모든 연산자 조합 (2개 연산자 선택, 중복 허용)
    operator_combs = list(itertools.product(operators, repeat=2))
    
    print(f"  숫자: {numbers}")
    print(f"  연산자: {operators}")
    print(f"  숫자 순열: {len(number_perms)}개")
    print(f"  연산자 조합: {len(operator_combs)}개")
    print(f"  총 문제 수: {len(number_perms) * len(operator_combs):,}")
    
    print("\n  샘플 문제:")
    sample_count = 0
    for nums in number_perms[:2]:  # 샘플로 2개만
        for ops in operator_combs[:2]:  # 샘플로 2개만
            expression = f"({nums[0]} {ops[0]} {nums[1]}) {ops[1]} {nums[2]}"
            
            # 안전한 계산 (0으로 나누기 방지)
            try:
                result = eval(expression)
                print(f"    {expression} = {result:.2f}")
                sample_count += 1
                if sample_count >= 5:
                    break
            except ZeroDivisionError:
                continue
        if sample_count >= 5:
            break

# 8. 실전 예제 5: 제품 구성 옵션
def generate_product_configurations():
    """
    제품의 가능한 모든 구성 옵션 생성
    """
    colors = ['빨강', '파랑', '검정']
    sizes = ['S', 'M', 'L', 'XL']
    materials = ['면', '폴리에스터', '울']
    
    print("\n10. 제품 구성 옵션 생성:")
    print(f"  색상: {colors}")
    print(f"  사이즈: {sizes}")
    print(f"  소재: {materials}")
    
    # 모든 가능한 조합 (데카르트 곱)
    all_configs = list(itertools.product(colors, sizes, materials))
    
    print(f"  총 구성 수: {len(all_configs)}")
    print("\n  구성 목록:")
    for i, config in enumerate(all_configs[:10], 1):  # 처음 10개만 출력
        color, size, material = config
        print(f"    {i}. 색상: {color}, 사이즈: {size}, 소재: {material}")
    
    print(f"    ... (총 {len(all_configs)}개 중 10개만 표시)")

# 모든 예제 실행
if __name__ == "__main__":
    generate_permutations_example()
    generate_combinations_example()
    generate_with_repetition()
    password_cracking_simulation()
    optimize_team_formation()
    plan_travel_routes()
    generate_math_problems()
    generate_product_configurations()
```

## 인덱스-값 페어 시퀀스 순환

시퀀스를 순회하면서 인덱스와 값을 동시에 얻는 다양한 방법을 살펴봅니다.

```python
# 1. enumerate() 기본 사용법
def basic_enumerate_examples():
    """enumerate()의 다양한 활용법"""
    
    print("1. enumerate() 기본 사용")
    print("=" * 50)
    
    fruits = ['사과', '바나나', '체리', '딸기', '포도']
    
    # 가장 기본적인 사용법
    print("기본형 (인덱스와 값):")
    for index, fruit in enumerate(fruits):
        print(f"  인덱스 {index}: {fruit}")
    
    # 시작 인덱스 지정
    print("\n시작 인덱스 1부터:")
    for index, fruit in enumerate(fruits, start=1):
        print(f"  항목 {index}: {fruit}")
    
    # enumerate 객체를 리스트로 변환
    enumerated_list = list(enumerate(fruits, start=100))
    print(f"\nenumerate 객체를 리스트로: {enumerated_list}")

# 2. 실전 예제: 로그 파일 분석
def analyze_log_with_enumerate():
    """로그 파일을 분석하면서 줄 번호와 내용 처리"""
    
    print("\n\n2. 로그 파일 분석 예제")
    print("=" * 50)
    
    # 샘플 로그 데이터
    log_entries = [
        "2024-01-15 10:00:00 INFO: 시스템 시작",
        "2024-01-15 10:00:05 WARNING: 메모리 사용량 85%",
        "2024-01-15 10:00:10 ERROR: 데이터베이스 연결 실패",
        "2024-01-15 10:00:15 INFO: 연결 재시도",
        "2024-01-15 10:00:20 INFO: 연결 성공",
        "2024-01-15 10:00:25 WARNING: 디스크 공간 부족",
        "2024-01-15 10:00:30 INFO: 임시 파일 정리 완료"
    ]
    
    print("로그 파일 분석 (에러 위치 찾기):")
    error_lines = []
    
    for line_num, log_entry in enumerate(log_entries, start=1):
        if "ERROR" in log_entry:
            error_lines.append((line_num, log_entry))
            print(f"  ⚠️ 줄 {line_num}: {log_entry}")
        elif "WARNING" in log_entry:
            print(f"  ⚠️ 줄 {line_num}: {log_entry}")
    
    print(f"\n총 {len(error_lines)}개의 에러가 발견되었습니다.")

# 3. enumerate를 활용한 데이터 처리
def process_data_with_index():
    """인덱스 정보가 필요한 데이터 처리"""
    
    print("\n\n3. 인덱스를 활용한 데이터 처리")
    print("=" * 50)
    
    # 학생 점수 데이터
    student_scores = [
        ('김철수', 85),
        ('이영희', 92),
        ('박지민', 78),
        ('최윤호', 88),
        ('정민지', 95)
    ]
    
    print("학생 성적 처리:")
    
    # 1) 순위 매기기
    print("\n성적 순위:")
    # 점수로 정렬 (높은 점수순)
    sorted_students = sorted(student_scores, key=lambda x: x[1], reverse=True)
    
    for rank, (name, score) in enumerate(sorted_students, start=1):
        print(f"  {rank}위: {name} ({score}점)")
    
    # 2) 평균 이상/이하 학생 분류
    total_score = sum(score for _, score in student_scores)
    average_score = total_score / len(student_scores)
    
    print(f"\n평균 점수: {average_score:.1f}")
    print("평균 이상 학생:")
    
    above_average = []
    for idx, (name, score) in enumerate(student_scores):
        if score >= average_score:
            above_average.append((idx, name, score))
            print(f"  {name}: {score}점 (원래 순서: {idx})")

# 4. 다차원 데이터 인덱싱
def multi_dimensional_indexing():
    """다차원 배열의 인덱스 처리"""
    
    print("\n\n4. 다차원 데이터 인덱싱")
    print("=" * 50)
    
    # 2차원 그리드 데이터
    grid = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9, 10, 11, 12]
    ]
    
    print("2차원 그리드 순회:")
    
    # 행과 열 인덱스 모두 필요할 때
    for row_idx, row in enumerate(grid):
        for col_idx, value in enumerate(row):
            print(f"  grid[{row_idx}][{col_idx}] = {value}")
    
    # 특정 패턴 찾기 (대각선 요소)
    print("\n주 대각선 요소:")
    min_dim = min(len(grid), len(grid[0]))
    for i in range(min_dim):
        print(f"  grid[{i}][{i}] = {grid[i][i]}")

# 5. enumerate와 zip 조합
def enumerate_with_zip():
    """여러 시퀀스를 동시에 인덱싱"""
    
    print("\n\n5. enumerate와 zip 조합")
    print("=" * 50)
    
    names = ['김철수', '이영희', '박지민', '최윤호']
    ages = [30, 28, 35, 40]
    departments = ['개발팀', '디자인팀', '영업팀', '관리팀']
    
    print("직원 정보 통합 처리:")
    
    for idx, (name, age, dept) in enumerate(zip(names, ages, departments), start=1):
        print(f"  {idx}. {name} ({age}세, {dept})")
    
    # 데이터 검증
    print("\n데이터 검증 (나이 30세 이상):")
    for idx, (name, age, dept) in enumerate(zip(names, ages, departments)):
        if age >= 30:
            print(f"  ✓ {name}: {age}세")

# 6. 제너레이터와 enumerate 결합
def enumerate_with_generator():
    """제너레이터와 함께 enumerate 사용"""
    
    print("\n\n6. 제너레이터와 enumerate")
    print("=" * 50)
    
    def fibonacci_generator(n):
        """피보나치 수열 제너레이터"""
        a, b = 0, 1
        for _ in range(n):
            yield a
            a, b = b, a + b
    
    print("피보나치 수열 (처음 10개):")
    
    fib_numbers = list(fibonacci_generator(10))
    for idx, num in enumerate(fib_numbers):
        print(f"  F({idx}) = {num}")

# 7. enumerate를 이용한 데이터 변환
def data_transformation_with_enumerate():
    """인덱스를 활용한 데이터 변환"""
    
    print("\n\n7. 인덱스 기반 데이터 변환")
    print("=" * 50)
    
    # 원본 데이터
    raw_data = ['apple', 'banana', 'cherry', 'date', 'elderberry']
    
    print("원본 데이터:", raw_data)
    
    # 1) 인덱스를 접두사로 추가
    prefixed_data = [f"{idx}_{item}" for idx, item in enumerate(raw_data)]
    print("\n인덱스 접두사 추가:", prefixed_data)
    
    # 2) 짝수 인덱스만 대문자로 변환
    transformed_data = [
        item.upper() if idx % 2 == 0 else item 
        for idx, item in enumerate(raw_data)
    ]
    print("짝수 인덱스 대문자 변환:", transformed_data)
    
    # 3) 인덱스 기반 필터링
    filtered_data = [
        item for idx, item in enumerate(raw_data) 
        if idx not in [1, 3]  # 1번과 3번 인덱스 제외
    ]
    print("특정 인덱스 제외 필터링:", filtered_data)

# 8. enumerate와 딕셔너리 생성
def create_dict_with_enumerate():
    """enumerate를 이용한 딕셔너리 생성"""
    
    print("\n\n8. enumerate를 활용한 딕셔너리 생성")
    print("=" * 50)
    
    items = ['사과', '바나나', '체리', '딸기', '포도']
    
    # 1) 인덱스를 키로 하는 딕셔너리
    index_dict = {idx: item for idx, item in enumerate(items)}
    print("인덱스 기반 딕셔너리:", index_dict)
    
    # 2) 값을 키로, 인덱스를 값으로 하는 딕셔너리
    reverse_dict = {item: idx for idx, item in enumerate(items)}
    print("역방향 딕셔너리:", reverse_dict)
    
    # 3) 복잡한 키 생성
    complex_dict = {
        f"item_{idx:03d}": {
            'name': item,
            'position': idx,
            'length': len(item)
        }
        for idx, item in enumerate(items)
    }
    print("\n복합 구조 딕셔너리:")
    for key, value in complex_dict.items():
        print(f"  {key}: {value}")

# 9. 실전 예제: 파일 비교 도구
def file_comparison_tool():
    """두 파일을 줄 단위로 비교"""
    
    print("\n\n9. 파일 비교 도구 (시뮬레이션)")
    print("=" * 50)
    
    # 샘플 파일 내용
    file1_content = [
        "첫 번째 줄",
        "두 번째 줄",
        "세 번째 줄",
        "네 번째 줄",
        "다섯 번째 줄"
    ]
    
    file2_content = [
        "첫 번째 줄",
        "두 번째 줄 (수정됨)",
        "세 번째 줄",
        "추가된 줄",
        "다섯 번째 줄"
    ]
    
    print("파일 비교 결과:")
    print("-" * 50)
    
    max_lines = max(len(file1_content), len(file2_content))
    
    for line_num in range(max_lines):
        line1 = file1_content[line_num] if line_num < len(file1_content) else "[없음]"
        line2 = file2_content[line_num] if line_num < len(file2_content) else "[없음]"
        
        if line1 == line2:
            print(f"줄 {line_num+1:3d}: ✓ 동일")
        else:
            print(f"줄 {line_num+1:3d}: ✗ 다름")
            print(f"     파일1: {line1}")
            print(f"     파일2: {line2}")

# 10. 고급 활용: 커스텀 이터레이터와 enumerate
class PaginatedData:
    """페이지네이션된 데이터를 처리하는 커스텀 이터레이터"""
    
    def __init__(self, data, page_size=3):
        self.data = data
        self.page_size = page_size
        self.current_page = 0
    
    def __iter__(self):
        return self
    
    def __next__(self):
        start_idx = self.current_page * self.page_size
        end_idx = start_idx + self.page_size
        
        if start_idx >= len(self.data):
            raise StopIteration
        
        page_data = self.data[start_idx:end_idx]
        self.current_page += 1
        
        # 페이지 번호와 데이터를 함께 반환
        return self.current_page - 1, page_data

def custom_iterator_example():
    """커스텀 이터레이터와 enumerate 활용"""
    
    print("\n\n10. 커스텀 이터레이터와 페이지네이션")
    print("=" * 50)
    
    # 대용량 데이터 시뮬레이션
    all_data = [f"데이터_{i}" for i in range(1, 11)]
    
    paginator = PaginatedData(all_data, page_size=3)
    
    print("페이지별 데이터 처리:")
    for page_num, page_data in paginator:
        print(f"\n페이지 {page_num + 1}:")
        for item_idx, item in enumerate(page_data, start=1):
            print(f"  {item_idx}. {item}")

# 모든 예제 실행
if __name__ == "__main__":
    basic_enumerate_examples()
    analyze_log_with_enumerate()
    process_data_with_index()
    multi_dimensional_indexing()
    enumerate_with_zip()
    enumerate_with_generator()
    data_transformation_with_enumerate()
    create_dict_with_enumerate()
    file_comparison_tool()
    custom_iterator_example()
```

## 여러 시퀀스 동시에 순환

여러 개의 시퀀스를 병렬로 처리하고 비교하는 방법을 살펴봅니다.

```python
import itertools
from collections import defaultdict

# 1. zip() 기본 사용법
def basic_zip_examples():
    """zip() 함수의 다양한 활용법"""
    
    print("1. zip() 기본 사용")
    print("=" * 50)
    
    # 기본적인 zip 사용
    names = ['김철수', '이영희', '박지민']
    ages = [30, 28, 35]
    cities = ['서울', '부산', '대구']
    
    print("기본 zip (튜플로 묶기):")
    for name, age, city in zip(names, ages, cities):
        print(f"  {name}({age}세) - {city}")
    
    # zip 객체 확인
    zipped = zip(names, ages, cities)
    print(f"\nzip 객체: {zipped}")
    print(f"리스트로 변환: {list(zipped)}")
    
    # 길이가 다른 시퀀스
    list1 = [1, 2, 3, 4, 5]
    list2 = ['a', 'b', 'c']
    
    print("\n길이가 다른 시퀀스 zip:")
    for item1, item2 in zip(list1, list2):
        print(f"  {item1} - {item2}")
    
    print("  ※ 짧은 시퀀스에 맞춰 멈춥니다")

# 2. itertools.zip_longest()
def zip_longest_example():
    """itertools.zip_longest()를 이용한 동시 순회"""
    
    print("\n\n2. itertools.zip_longest()")
    print("=" * 50)
    
    list1 = ['A', 'B', 'C', 'D']
    list2 = [1, 2, 3]
    
    print("zip (짧은 길이 기준):")
    for a, b in zip(list1, list2):
        print(f"  {a} - {b}")
    
    print("\nzip_longest (긴 길이 기준, fillvalue 지정):")
    for a, b in itertools.zip_longest(list1, list2, fillvalue='N/A'):
        print(f"  {a} - {b}")

# 3. 실전 예제: 데이터 정합성 검사
def data_consistency_check():
    """여러 데이터 소스의 일관성 검증"""
    
    print("\n\n3. 데이터 정합성 검사")
    print("=" * 50)
    
    # 데이터베이스와 파일에서 읽은 데이터 (시뮬레이션)
    db_data = [
        {'id': 1, 'name': '김철수', 'score': 85},
        {'id': 2, 'name': '이영희', 'score': 92},
        {'id': 3, 'name': '박지민', 'score': 78},
        {'id': 4, 'name': '최윤호', 'score': 88}
    ]
    
    file_data = [
        {'id': 1, 'name': '김철수', 'score': 85},
        {'id': 2, 'name': '이영희', 'score': 90},  # 일부러 다른 값
        {'id': 3, 'name': '박지민', 'score': 78},
        {'id': 5, 'name': '정민지', 'score': 95}   # 새로운 데이터
    ]
    
    print("데이터베이스 vs 파일 데이터 비교:")
    print("-" * 50)
    
    # ID를 기준으로 데이터 매칭
    db_dict = {item['id']: item for item in db_data}
    file_dict = {item['id']: item for item in file_data}
    
    all_ids = sorted(set(db_dict.keys()) | set(file_dict.keys()))
    
    inconsistencies = []
    
    for id_num in all_ids:
        db_item = db_dict.get(id_num)
        file_item = file_dict.get(id_num)
        
        if db_item and file_item:
            if db_item['score'] != file_item['score']:
                inconsistencies.append(id_num)
                print(f"ID {id_num}: 점수 불일치")
                print(f"  DB: {db_item['score']}점, 파일: {file_item['score']}점")
        elif db_item and not file_item:
            print(f"ID {id_num}: 파일에 없음 (DB에만 존재)")
        elif not db_item and file_item:
            print(f"ID {id_num}: DB에 없음 (파일에만 존재)")
    
    print(f"\n총 {len(inconsistencies)}개의 불일치 발견")

# 4. 병렬 데이터 처리
def parallel_data_processing():
    """여러 데이터셋을 병렬로 처리"""
    
    print("\n\n4. 병렬 데이터 처리")
    print("=" * 50)
    
    # 여러 센서의 동시 측정 데이터
    temperature_data = [22.5, 23.1, 22.8, 23.5, 22.9]
    humidity_data = [45, 47, 46, 48, 47]
    pressure_data = [1013, 1012, 1014, 1013, 1015]
    timestamps = [10.0, 10.5, 11.0, 11.5, 12.0]
    
    print("센서 데이터 통합 분석:")
    print("-" * 50)
    
    for temp, hum, press, time in zip(temperature_data, humidity_data, 
                                       pressure_data, timestamps):
        # 데이터 품질 검증
        issues = []
        
        if temp < 20 or temp > 25:
            issues.append(f"온도 이상({temp}°C)")
        if hum < 40 or hum > 60:
            issues.append(f"습도 이상({hum}%)")
        if press < 1000 or press > 1020:
            issues.append(f"기압 이상({press}hPa)")
        
        status = "정상" if not issues else "이상: " + ", ".join(issues)
        print(f"시간 {time}s: 온도 {temp}°C, 습도 {hum}%, 기압 {press}hPa - {status}")
    
    # 통계 계산
    print("\n전체 통계:")
    print(f"평균 온도: {sum(temperature_data)/len(temperature_data):.1f}°C")
    print(f"평균 습도: {sum(humidity_data)/len(humidity_data):.1f}%")
    print(f"평균 기압: {sum(pressure_data)/len(pressure_data):.1f}hPa")

# 5. 다중 조건 정렬
def multi_key_sorting():
    """여러 키를 기준으로 데이터 정렬"""
    
    print("\n\n5. 다중 조건 정렬")
    print("=" * 50)
    
    students = [
        ('김철수', 85, '수학'),
        ('이영희', 92, '과학'),
        ('박지민', 85, '영어'),
        ('최윤호', 78, '수학'),
        ('정민지', 92, '영어')
    ]
    
    print("원본 데이터:")
    for name, score, subject in students:
        print(f"  {name}: {score}점 ({subject})")
    
    # 1) 점수 내림차순, 이름 오름차순 정렬
    sorted_by_score = sorted(students, key=lambda x: (-x[1], x[0]))
    
    print("\n점수 높은순, 이름순 정렬:")
    for name, score, subject in sorted_by_score:
        print(f"  {name}: {score}점 ({subject})")
    
    # 2) 과목별, 점수 내림차순 정렬
    sorted_by_subject = sorted(students, key=lambda x: (x[2], -x[1]))
    
    print("\n과목별, 점수 높은순 정렬:")
    current_subject = None
    for name, score, subject in sorted_by_subject:
        if subject != current_subject:
            print(f"\n{subject}:")
            current_subject = subject
        print(f"  {name}: {score}점")

# 6. 데이터 병합과 변환
def data_merge_and_transform():
    """여러 데이터 소스를 병합하고 변환"""
    
    print("\n\n6. 데이터 병합과 변환")
    print("=" * 50)
    
    # 제품 정보 (다른 소스에서 가져옴)
    product_ids = [101, 102, 103, 104, 105]
    product_names = ['노트북', '마우스', '키보드', '모니터', '헤드폰']
    product_prices = [1200000, 25000, 35000, 300000, 150000]
    product_stock = [15, 100, 75, 30, 50]
    
    print("제품 정보 병합:")
    print("-" * 50)
    
    # 데이터 병합
    merged_products = []
    for pid, name, price, stock in zip(product_ids, product_names, 
                                        product_prices, product_stock):
        product = {
            'id': pid,
            'name': name,
            'price': price,
            'stock': stock,
            'total_value': price * stock
        }
        merged_products.append(product)
        print(f"  {name} (ID: {pid}): {price:,}원, 재고: {stock}개, 총가치: {product['total_value']:,}원")
    
    # 추가 분석
    print("\n재고 분석:")
    total_value = sum(p['total_value'] for p in merged_products)
    average_price = sum(p['price'] for p in merged_products) / len(merged_products)
    
    print(f"총 재고 가치: {total_value:,}원")
    print(f"평균 제품 가격: {average_price:,.0f}원")
    
    # 저가/고가 제품 분류
    low_price_items = [p for p in merged_products if p['price'] < 100000]
    high_price_items = [p for p in merged_products if p['price'] >= 100000]
    
    print(f"\n저가 제품({len(low_price_items)}개): {[p['name'] for p in low_price_items]}")
    print(f"고가 제품({len(high_price_items)}개): {[p['name'] for p in high_price_items]}")

# 7. 실시간 데이터 스트림 동기화
def realtime_stream_synchronization():
    """실시간 데이터 스트림 동기화"""
    
    print("\n\n7. 실시간 데이터 스트림 동기화")
    print("=" * 50)
    
    # 여러 데이터 스트림 생성기
    def generate_stream_a():
        """스트림 A: 온도 데이터"""
        temperatures = [20.1, 20.3, 20.5, 20.8, 21.0, 21.2, 21.5]
        for temp in temperatures:
            yield {'type': 'temperature', 'value': temp, 'unit': '°C'}
    
    def generate_stream_b():
        """스트림 B: 습도 데이터"""
        humidities = [45, 46, 47, 48, 49, 50, 51]
        for hum in humidities:
            yield {'type': 'humidity', 'value': hum, 'unit': '%'}
    
    def generate_stream_c():
        """스트림 C: 압력 데이터"""
        pressures = [1013, 1012, 1013, 1012, 1011, 1013, 1014]
        for press in pressures:
            yield {'type': 'pressure', 'value': press, 'unit': 'hPa'}
    
    print("다중 센서 데이터 스트림 동기화:")
    print("-" * 50)
    
    stream_a = generate_stream_a()
    stream_b = generate_stream_b()
    stream_c = generate_stream_c()
    
    sync_data = []
    
    # 동기화된 데이터 수집
    for a, b, c in zip(stream_a, stream_b, stream_c):
        sync_point = {
            'timestamp': len(sync_data) + 1,
            'temperature': a['value'],
            'humidity': b['value'],
            'pressure': c['value']
        }
        sync_data.append(sync_point)
        
        print(f"시간 {sync_point['timestamp']}: "
              f"온도 {a['value']}{a['unit']}, "
              f"습도 {b['value']}{b['unit']}, "
              f"기압 {c['value']}{c['unit']}")
    
    # 통합 분석
    print("\n통합 분석 결과:")
    avg_temp = sum(d['temperature'] for d in sync_data) / len(sync_data)
    avg_hum = sum(d['humidity'] for d in sync_data) / len(sync_data)
    avg_press = sum(d['pressure'] for d in sync_data) / len(sync_data)
    
    print(f"평균 온도: {avg_temp:.1f}°C")
    print(f"평균 습도: {avg_hum:.1f}%")
    print(f"평균 기압: {avg_press:.1f}hPa")

# 8. itertools.chain()을 이용한 시퀀스 연결
def chain_sequences_example():
    """여러 시퀀스를 하나로 연결"""
    
    print("\n\n8. 시퀀스 연결 (itertools.chain)")
    print("=" * 50)
    
    list1 = [1, 2, 3]
    list2 = [4, 5, 6]
    list3 = [7, 8, 9]
    
    # 기본 chain 사용
    print("기본 chain:")
    chained = itertools.chain(list1, list2, list3)
    for item in chained:
        print(f"  {item}", end=' ')
    print()
    
    # chain.from_iterable 사용
    print("\nchain.from_iterable:")
    nested_lists = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]
    flattened = itertools.chain.from_iterable(nested_lists)
    print(f"  평탄화 결과: {list(flattened)}")
    
    # 실전 예제: 여러 파일의 내용 읽기
    print("\n여러 파일 내용 연결 (시뮬레이션):")
    
    file_contents = [
        ["파일1: 첫 번째 줄", "파일1: 두 번째 줄"],
        ["파일2: 시작", "파일2: 중간", "파일2: 끝"],
        ["파일3: 내용"]
    ]
    
    all_lines = itertools.chain.from_iterable(file_contents)
    
    for i, line in enumerate(all_lines, 1):
        print(f"  줄 {i}: {line}")

# 9. 데이터 비교 및 대조
def data_comparison_and_contrast():
    """데이터셋 비교 분석"""
    
    print("\n\n9. 데이터셋 비교 분석")
    print("=" * 50)
    
    # 이번 달과 지난 달의 판매 데이터
    last_month_sales = {
        '노트북': 15,
        '마우스': 120,
        '키보드': 85,
        '모니터': 25,
        '헤드폰': 40
    }
    
    this_month_sales = {
        '노트북': 18,
        '마우스': 150,
        '키보드': 95,
        '모니터': 30,
        '스피커': 25  # 새로운 제품
    }
    
    print("월별 판매 데이터 비교:")
    print("-" * 50)
    
    all_products = sorted(set(last_month_sales.keys()) | set(this_month_sales.keys()))
    
    print(f"{'제품':<10} {'지난달':>8} {'이번달':>8} {'변화':>10} {'증감율':>10}")
    print("-" * 50)
    
    total_change = 0
    for product in all_products:
        last = last_month_sales.get(product, 0)
        current = this_month_sales.get(product, 0)
        
        change = current - last
        if last > 0:
            change_rate = (change / last) * 100
        else:
            change_rate = float('inf') if current > 0 else 0
        
        total_change += change
        
        change_str = f"{change:+d}"
        rate_str = f"{change_rate:+.1f}%" if last > 0 else "N/A"
        
        print(f"{product:<10} {last:>8} {current:>8} {change_str:>10} {rate_str:>10}")
    
    print("-" * 50)
    print(f"{'총계':<10} {sum(last_month_sales.values()):>8} "
          f"{sum(this_month_sales.values()):>8} {total_change:>+10}")

# 10. 고급: 커스텀 병렬 이터레이터
class ParallelIterator:
    """여러 이터러블을 병렬로 순회하는 커스텀 이터레이터"""
    
    def __init__(self, *iterables):
        self.iterators = [iter(it) for it in iterables]
        self.active_count = len(self.iterators)
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.active_count == 0:
            raise StopIteration
        
        results = []
        for i, iterator in enumerate(self.iterators):
            try:
                results.append(next(iterator))
            except StopIteration:
                results.append(None)
                # 이 이터레이터는 더 이상 활성화되지 않음
                if self.iterators[i] is not None:
                    self.iterators[i] = None
                    self.active_count -= 1
        
        if self.active_count == 0:
            raise StopIteration
        
        return tuple(results)

def custom_parallel_iterator_example():
    """커스텀 병렬 이터레이터 사용"""
    
    print("\n\n10. 커스텀 병렬 이터레이터")
    print("=" * 50)
    
    list1 = [1, 2, 3, 4, 5]
    list2 = ['A', 'B', 'C']
    list3 = [10.1, 20.2, 30.3, 40.4]
    
    print("병렬 순회 (길이가 다른 시퀀스):")
    
    parallel_iter = ParallelIterator(list1, list2, list3)
    
    for i, items in enumerate(parallel_iter, 1):
        print(f"  순회 {i}: {items}")

# 모든 예제 실행
if __name__ == "__main__":
    basic_zip_examples()
    zip_longest_example()
    data_consistency_check()
    parallel_data_processing()
    multi_key_sorting()
    data_merge_and_transform()
    realtime_stream_synchronization()
    chain_sequences_example()
    data_comparison_and_contrast()
    custom_parallel_iterator_example()
```

## 결론

파이썬의 이터레이터와 순회 기법은 데이터 처리의 효율성과 코드 가독성을 크게 향상시키는 강력한 도구입니다. `itertools` 모듈을 활용하면 복잡한 순회 패턴도 간결하게 표현할 수 있으며, `enumerate`와 `zip`을 적절히 활용하면 다중 데이터 소스의 동기화와 처리가 용이해집니다.

이러한 기법들을 숙지하면 대용량 데이터 스트림 처리, 실시간 데이터 분석, 복잡한 알고리즘 구현 등 다양한 영역에서 더 견고하고 효율적인 코드를 작성할 수 있습니다. 특히 메모리 제약이 있는 환경이나 실시간 처리 시스템에서는 이터레이터와 제너레이터를 효과적으로 사용하는 것이 성능과 안정성 측면에서 결정적인 차이를 만듭니다. 각 상황에 맞는 최적의 순회 패턴을 선택하고, 필요시 커스텀 이터레이터를 구현하면 더욱 유연하고 강력한 데이터 처리 파이프라인을 구축할 수 있습니다.