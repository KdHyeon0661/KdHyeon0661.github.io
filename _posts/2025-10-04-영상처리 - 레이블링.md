---
layout: post
title: 영상처리 - 레이블링
date: 2025-10-04 18:25:23 +0900
category: 영상처리
---
# 레이블링 (Connected-Component Labeling)

## 1) 레이블링이란?

### 1.1 정의
이진 영상 \(B(x,y)\in\{0,255\}\) 에서 **연결된 전경 픽셀 집합**을 찾아 각각에 **정수 레이블** \(L\in\{1,\dots,K\}\)을 부여:
\[
L(x,y)=
\begin{cases}
\text{컴포넌트 ID (1..K)}, & B(x,y)=255 \\
0, & B(x,y)=0
\end{cases}
\]

### 1.2 연결성(Connectivity)
- **4-연결**: 상/하/좌/우 이웃(Manhattan).  
- **8-연결**: 대각 포함(상하좌우 + 4대각).  
4/8 연결은 **배경/전경 선택**에 따라 교환 법칙이 성립하지 않으니(“이중성”), 통일된 정의가 중요합니다. 본 구현은 **전경 연결성**을 옵션(4 또는 8)으로 받습니다.

---

## 2) 고전적 레이블링 기법(2-패스 + 동치 집합)

### 2.1 개요
1. **1패스(첫 스캔)**: 왼→오, 위→아래로 스캔하며 전경 픽셀의 **이웃 레이블**을 관찰  
   - 이웃에 전경 레이블이 없으면 **새 레이블** 할당  
   - 여러 레이블이 보이면 **동치(Equivalence) 기록**(Union–Find으로 병합)
2. **2패스(정규화)**: 모든 임시 레이블을 동치의 **대표(root)** 로 치환 → 연속된 \(1..K\)로 **압축(compaction)**

### 2.2 이웃 집합
- **4-연결**: \(\{(x-1,y), (x,y-1)\}\) → 좌, 상  
- **8-연결**: \(\{(x-1,y), (x,y-1), (x-1,y-1), (x+1,y-1)\}\) → 좌, 상, 좌상, 우상  
스캔 시점 기준으로 **이미 확정된** 이웃만 본다는 점이 핵심(미래 참조 없음).

### 2.3 시간/공간 복잡도
- 시간: \(\mathcal{O}(WH \,\alpha(N))\) (거의 선형; \(\alpha\)는 inverse Ackermann)  
- 공간: \(\mathcal{O}(WH)\) (레이블 버퍼, Union–Find)

---

## 3) 구현 — **Union–Find + 2-패스 레이블링 + 통계**

```cpp
// Labeling.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <algorithm>
#include <cmath>
#include <string>
#include <limits>
#include "IppImage.h"
#include "IppDib.h"

// ---------- 공통 ----------
inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }

// BGRA32 → 8비트 이진(0/255). 이미 이진이면 그대로, 아니면 >0 → 255 처리.
inline void DibToBinary8(const IppDib& dib, IppImage<uint8_t>& bin){
    bin.create(dib.width(), dib.height());
    for(int y=0;y<dib.height();++y){
        const uint8_t* s=(const uint8_t*)dib.bits() + (size_t)y*dib.stride();
        uint8_t* d=bin.row(y);
        for(int x=0;x<dib.width();++x){
            uint8_t B=s[x*4+0], G=s[x*4+1], R=s[x*4+2];
            // 기준: 0이면 배경, 그 외 전경. (이미 이진이면 정확히 0/255)
            uint8_t v = (R|G|B) ? 255 : 0;
            d[x]=v;
        }
    }
}

// 8비트 이진 → BGRA32 (전경은 흰색)
inline IppDib Binary8ToDib(const IppImage<uint8_t>& g){
    IppDib d; d.create(g.width(), g.height(), 32);
    for(int y=0;y<g.height();++y){
        const uint8_t* s=g.row(y);
        uint8_t* dd=(uint8_t*)d.bits() + (size_t)y*d.stride();
        for(int x=0;x<g.width();++x){
            uint8_t v=s[x];
            dd[x*4+0]=dd[x*4+1]=dd[x*4+2]=v; dd[x*4+3]=255;
        }
    }
    return d;
}

// ---------- Union-Find ----------
struct DSU {
    std::vector<int> p, r;
    explicit DSU(int n=0){ reset(n); }
    void reset(int n){ p.resize(n); r.assign(n,0); for(int i=0;i<n;++i)p[i]=i; }
    int find(int a){ return p[a]==a? a : p[a]=find(p[a]); }
    void unite(int a,int b){
        a=find(a); b=find(b); if (a==b) return;
        if (r[a]<r[b]) std::swap(a,b);
        p[b]=a; if (r[a]==r[b]) r[a]++;
    }
};

// ---------- 옵션/통계 ----------
enum class Connectivity { C4, C8 };

struct LabelStat {
    int id=0;                  // 1..K
    int area=0;                // 픽셀 수
    int minx=+INT32_MAX, miny=+INT32_MAX;
    int maxx=-INT32_MAX, maxy=-INT32_MAX;
    double cx=0, cy=0;         // 무게중심(정밀 계산은 최종 나눗셈에서)
    int perimeter=0;           // 4-이웃 경계 길이(픽셀 단위)
};

struct LabelingOptions {
    Connectivity conn = Connectivity::C8;
    int minArea = 1;           // 이 미만은 제거(배경화)
};

struct LabelingResult {
    IppImage<int> labels;          // 0..K, same size
    std::vector<LabelStat> stats;  // id=1..K
    int numLabels=0;
};

// ---------- 핵심: 2-패스 레이블링 ----------
inline LabelingResult LabelComponents(const IppImage<uint8_t>& bin, const LabelingOptions& opt){
    const int W=bin.width(), H=bin.height();
    IppImage<int> lab(W,H); // 0.. provisional labels
    // 상한 추정(최악의 경우 전 픽셀 레이블) — 현실적으로 훨씬 작음
    DSU dsu(W*H/2 + 1024);

    int nextLabel=1; // 1부터 시작
    auto getLab=[&](int x,int y)->int&{ return lab.row(y)[x]; };

    // 1패스
    for(int y=0;y<H;++y){
        const uint8_t* s = bin.row(y);
        for(int x=0;x<W;++x){
            if (s[x]==0){ getLab(x,y)=0; continue; }
            // 이웃 레이블 수집
            int nbs[4]={0,0,0,0}; int nbCount=0;
            auto Lget=[&](int xx,int yy)->int{
                if ((unsigned)xx>=(unsigned)W || (unsigned)yy>=(unsigned)H) return 0;
                if (bin.row(yy)[xx]==0) return 0;
                return getLab(xx,yy);
            };
            // 좌, 상, 좌상, 우상(8연결이면 둘 포함)
            int L = Lget(x-1,y); if (L) nbs[nbCount++]=L;
            L = Lget(x,y-1);     if (L) nbs[nbCount++]=L;
            if (opt.conn==Connectivity::C8){
                L = Lget(x-1,y-1); if (L) nbs[nbCount++]=L;
                L = Lget(x+1,y-1); if (L) nbs[nbCount++]=L;
            }
            if (nbCount==0){
                getLab(x,y) = nextLabel++;
                if ((int)dsu.p.size()<=nextLabel+1) dsu.p.resize(nextLabel+1024), dsu.r.resize(nextLabel+1024);
            }else{
                // 이웃 중 최소 레이블
                int m=nbs[0];
                for(int i=1;i<nbCount;++i) m=std::min(m,nbs[i]);
                getLab(x,y)=m;
                // 동치 병합
                for(int i=0;i<nbCount;++i) dsu.unite(m, nbs[i]);
            }
        }
    }

    // 2패스: 대표로 치환 & 압축 매핑
    std::vector<int> map(nextLabel+1,0); // old -> new(1..K)
    int K=0;
    for(int y=0;y<H;++y){
        int* Lrow = lab.row(y);
        for(int x=0;x<W;++x){
            int L=Lrow[x]; if (L==0) continue;
            int r=dsu.find(L);
            if (map[r]==0) map[r]=++K;
            Lrow[x]=map[r];
        }
    }

    // 통계 초기화
    std::vector<LabelStat> stats(K+1); // 1..K 사용
    for(int i=1;i<=K;++i){ stats[i].id=i; }
    // 면적/무게중심/바운딩박스/둘레
    auto accum=[&](int x,int y){
        int L=lab.at(y,x); if (L<=0) return;
        LabelStat& st=stats[L];
        st.area++;
        st.minx=std::min(st.minx,x); st.maxx=std::max(st.maxx,x);
        st.miny=std::min(st.miny,y); st.maxy=std::max(st.maxy,y);
        st.cx += x; st.cy += y;
        // 둘레: 4-이웃 중 배경 접촉 수만큼 증가
        static const int dx[4]={-1,1,0,0};
        static const int dy[4]={0,0,-1,1};
        for(int k=0;k<4;++k){
            int nx=x+dx[k], ny=y+dy[k];
            if ((unsigned)nx>=(unsigned)W || (unsigned)ny>=(unsigned)H || lab.at(ny,nx)==0) st.perimeter++;
        }
    };
    for(int y=0;y<H;++y) for(int x=0;x<W;++x) if (lab.at(y,x)>0) accum(x,y);

    for(int i=1;i<=K;++i){
        if (stats[i].area>0){
            stats[i].cx/=stats[i].area; stats[i].cy/=stats[i].area;
        }else{
            stats[i].minx=stats[i].miny=0; stats[i].maxx=stats[i].maxy=-1; // empty
        }
    }

    // 면적 필터( minArea 미만 → 배경화 ), 그리고 다시 1..K로 압축
    if (opt.minArea>1){
        for(int y=0;y<H;++y){
            int* Lrow=lab.row(y);
            for(int x=0;x<W;++x){
                int L=Lrow[x]; if (L>0 && stats[L].area < opt.minArea) Lrow[x]=0;
            }
        }
        // 재압축
        std::vector<int> used(K+1,0); for(int y=0;y<H;++y){ int* r=lab.row(y); for(int x=0;x<W;++x) if (r[x]>0) used[r[x]]=1; }
        std::vector<int> newmap(K+1,0); int kk=0; for(int i=1;i<=K;++i) if (used[i]) newmap[i]=++kk;
        for(int y=0;y<H;++y){ int* r=lab.row(y); for(int x=0;x<W;++x) if (r[x]>0) r[x]=newmap[r[x]]; }
        // 통계 재계산
        stats.assign(kk+1, LabelStat{}); for(int i=1;i<=kk;++i) stats[i].id=i;
        for(int y=0;y<H;++y){
            const int* r=lab.row(y);
            for(int x=0;x<W;++x){
                int L=r[x]; if (L<=0) continue;
                LabelStat& st=stats[L];
                st.id=L; st.area++; st.minx=std::min(st.minx,x); st.miny=std::min(st.miny,y);
                st.maxx=std::max(st.maxx,x); st.maxy=std::max(st.maxy,y);
                st.cx+=x; st.cy+=y;
            }
        }
        for(int i=1;i<=kk;++i){ if (stats[i].area){ stats[i].cx/=stats[i].area; stats[i].cy/=stats[i].area; } }
        // 둘레 재계산
        for(int y=0;y<H;++y){
            const int* r=lab.row(y);
            for(int x=0;x<W;++x){
                int L=r[x]; if (L<=0) continue;
                LabelStat& st=stats[L];
                static const int dx[4]={-1,1,0,0};
                static const int dy[4]={0,0,-1,1};
                int inc=0;
                for(int k=0;k<4;++k){
                    int nx=x+dx[k], ny=y+dy[k];
                    if ((unsigned)nx>=(unsigned)W || (unsigned)ny>=(unsigned)H || lab.at(ny,nx)==0) inc++;
                }
                st.perimeter+=inc;
            }
        }
        K=kk;
    }

    LabelingResult res; res.labels=lab; res.stats.resize(K+1); for(int i=1;i<=K;++i) res.stats[i]=stats[i]; res.numLabels=K;
    return res;
}

// ---------- 색상화 (HSV → RGB) ----------
struct RGB24 { uint8_t r,g,b; };
inline RGB24 HSV2RGB(float h, float s, float v){
    // h:0..360, s:0..1, v:0..1
    if (s<=0.f){ uint8_t g=(uint8_t)std::lround(v*255); return {g,g,g}; }
    h = std::fmodf(h,360.f); if (h<0) h+=360.f;
    float c=v*s, x=c*(1.f-std::fabs(std::fmodf(h/60.f,2.f)-1.f)), m=v-c;
    float r=0,g=0,b=0;
    int hi=(int)(h/60.f);
    switch(hi){
        case 0: r=c; g=x; b=0; break; case 1: r=x; g=c; b=0; break;
        case 2: r=0; g=c; b=x; break; case 3: r=0; g=x; b=c; break;
        case 4: r=x; g=0; b=c; break; default: r=c; g=0; b=x; break;
    }
    auto to8=[&](float u){ int q=(int)std::lround((u+m)*255.f); return clamp_u8(q); };
    return {to8(r),to8(g),to8(b)};
}

inline RGB24 LabelToColor(int L){
    if (L<=0) return {0,0,0}; // 배경은 검정
    // 골든앵글(≈137.5°)로 Hue 분산 → 시각적으로 구분 쉬움
    float h = std::fmodf(137.50776f * L, 360.f);
    return HSV2RGB(h, 0.65f, 1.0f);
}

inline IppDib ColorizeLabels(const LabelingResult& r){
    const int W=r.labels.width(), H=r.labels.height();
    IppDib d; d.create(W,H,32);
    for(int y=0;y<H;++y){
        const int* L=r.labels.row(y); uint8_t* dd=(uint8_t*)d.bits() + (size_t)y*d.stride();
        for(int x=0;x<W;++x){
            RGB24 c = LabelToColor(L[x]);
            dd[x*4+0]=c.b; dd[x*4+1]=c.g; dd[x*4+2]=c.r; dd[x*4+3]=255;
        }
    }
    return d;
}

// ---------- 단순 도형(바운딩박스) 그리기 ----------
inline void DrawRectOnDib(IppDib& d, int x0,int y0,int x1,int y1, uint8_t R=255,uint8_t G=255,uint8_t B=0){
    const int W=d.width(), H=d.height();
    x0=std::max(0,std::min(W-1,x0)); x1=std::max(0,std::min(W-1,x1));
    y0=std::max(0,std::min(H-1,y0)); y1=std::max(0,std::min(H-1,y1));
    if (x0>x1) std::swap(x0,x1); if (y0>y1) std::swap(y0,y1);
    auto P=[&](int x,int y){ uint8_t* p=(uint8_t*)d.bits()+ (size_t)y*d.stride()+ x*4; p[0]=B;p[1]=G;p[2]=R; };
    for(int x=x0;x<=x1;++x){ P(x,y0); P(x,y1); }
    for(int y=y0;y<=y1;++y){ P(x0,y); P(x1,y); }
}
```

---

## 4) UI — **레이블링 대화 상자** & 메뉴

### 4.1 리소스 ID

```cpp
// resource.h (추가)
#define ID_MENU_LABELING                  85010

#define IDD_LABELING_DLG                  4200
#define IDC_RAD_LBL_4                     4201
#define IDC_RAD_LBL_8                     4202
#define IDC_EDIT_LBL_MINAREA              4203
#define IDC_CHK_LBL_DRAWBOX               4204
#define IDC_CHK_LBL_NEWWINDOW             4205
#define IDC_BTN_LBL_RUN                   4206
#define IDC_STC_LBL_SUMMARY               4207
```

### 4.2 RC

```rc
// ImageTool.rc (추가)
POPUP "&Analyze"
BEGIN
    MENUITEM "Label Connected Components...\tCtrl+L", ID_MENU_LABELING
END

IDD_LABELING_DLG DIALOGEX 0,0, 280, 156
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Connected-Component Labeling"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Connectivity", -1, 12, 10, 120, 40
    AUTORADIOBUTTON "4-connected", IDC_RAD_LBL_4,  22, 24, 70, 10, WS_TABSTOP
    AUTORADIOBUTTON "8-connected", IDC_RAD_LBL_8,  22, 36, 70, 10

    LTEXT "Min area (px):", -1, 150, 18, 64, 10
    EDITTEXT IDC_EDIT_LBL_MINAREA, 216, 16, 40, 14, ES_NUMBER

    AUTOCHECKBOX "Draw bounding boxes", IDC_CHK_LBL_DRAWBOX, 12, 58, 110, 12
    AUTOCHECKBOX "Open in new window",  IDC_CHK_LBL_NEWWINDOW,12, 74, 110, 12

    LTEXT "Summary:", -1, 12, 96, 50, 10
    LTEXT "", IDC_STC_LBL_SUMMARY, 62, 96, 194, 32

    DEFPUSHBUTTON "Run", IDOK,  164, 126, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 214, 126, 44, 16
END
```

### 4.3 대화 상자 코드 & 핸들러

```cpp
// LabelingDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "Labeling.hpp"

// 앱 제공(앞 절들과 동일 스타일)
struct DocRef { HWND hwnd; IppDib* dib; std::wstring title; };
std::vector<DocRef> GetOpenDocs();
HWND CreateDocWindowFromDib(const IppDib& dib, const std::wstring& title);

class LabelingDlg {
public:
    LabelingDlg(HWND owner, IppDib& target) : owner_(owner), target_(target) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM);

    void RunLabeling(HWND h);
    void ShowSummary(HWND h, const LabelingResult& r);

private:
    HWND owner_{};
    IppDib& target_;
};
```

```cpp
// LabelingDlg.cpp
#include "LabelingDlg.h"

INT_PTR LabelingDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_LABELING_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK LabelingDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        return ((LabelingDlg*)l)->OnInit(h); }
    auto* self=(LabelingDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w);
    return FALSE;
}
INT_PTR LabelingDlg::OnInit(HWND h){
    CheckRadioButton(h, IDC_RAD_LBL_4, IDC_RAD_LBL_8, IDC_RAD_LBL_8);
    SetDlgItemInt(h, IDC_EDIT_LBL_MINAREA, 1, FALSE);
    CheckDlgButton(h, IDC_CHK_LBL_DRAWBOX, BST_CHECKED);
    CheckDlgButton(h, IDC_CHK_LBL_NEWWINDOW, BST_CHECKED);
    SetDlgItemTextW(h, IDC_STC_LBL_SUMMARY, L"(ready)");
    return TRUE;
}
void LabelingDlg::ShowSummary(HWND h, const LabelingResult& r){
    wchar_t buf[128];
    wsprintfW(buf, L"K=%d labels", r.numLabels);
    SetDlgItemTextW(h, IDC_STC_LBL_SUMMARY, buf);
}
void LabelingDlg::RunLabeling(HWND h){
    BOOL ok=FALSE; int minA=GetDlgItemInt(h, IDC_EDIT_LBL_MINAREA, &ok, FALSE);
    if (!ok || minA<1) minA=1;
    LabelingOptions opt;
    opt.conn = (IsDlgButtonChecked(h, IDC_RAD_LBL_4)==BST_CHECKED) ? Connectivity::C4 : Connectivity::C8;
    opt.minArea = minA;

    // 입력 이진화
    IppImage<uint8_t> bin; DibToBinary8(target_, bin);

    // 레이블링
    LabelingResult r = LabelComponents(bin, opt);

    // 색상화
    IppDib colored = ColorizeLabels(r);

    // 바운딩박스 표시(선택)
    if (IsDlgButtonChecked(h, IDC_CHK_LBL_DRAWBOX)==BST_CHECKED){
        for (int i=1;i<=r.numLabels;++i){
            const auto& st=r.stats[i];
            if (st.area<=0) continue;
            DrawRectOnDib(colored, st.minx, st.miny, st.maxx, st.maxy, /*R=*/255,/*G=*/255,/*B=*/0);
        }
    }
    ShowSummary(h, r);

    // 출력: 새 창 or 현재 창 덮어쓰기
    if (IsDlgButtonChecked(h, IDC_CHK_LBL_NEWWINDOW)==BST_CHECKED){
        CreateDocWindowFromDib(colored, L"Labels");
    }else{
        target_ = colored;
        InvalidateRect(owner_, nullptr, FALSE);
    }

    // 간단한 통계 팝업(상위 10개)
    // 면적 내림차순
    std::vector<LabelStat> sorted; sorted.reserve(r.numLabels);
    for(int i=1;i<=r.numLabels;++i) if (r.stats[i].area>0) sorted.push_back(r.stats[i]);
    std::sort(sorted.begin(),sorted.end(),[](auto& a, auto& b){ return a.area>b.area; });
    std::wstring msg=L"Top components by area:\n";
    int cnt=0; for(auto& st:sorted){ 
        wchar_t line[160];
        wsprintfW(line, L" #%d: A=%d, C=(%.1f,%.1f), Box=[%d,%d]-[%d,%d]\n",
                  st.id, st.area, st.cx, st.cy, st.minx, st.miny, st.maxx, st.maxy);
        msg+=line; if (++cnt>=10) break;
    }
    MessageBoxW(owner_, msg.c_str(), L"Labeling Stats", MB_OK|MB_ICONINFORMATION);
}
INT_PTR LabelingDlg::OnCommand(HWND h, WPARAM w){
    switch(LOWORD(w)){
    case IDOK:    RunLabeling(h); EndDialog(h, IDOK); return TRUE;
    case IDCANCEL: EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

### 4.4 메뉴 핸들러

```cpp
// main_multiwin.cpp (발췌)
#include "LabelingDlg.h"

// ...
case ID_MENU_LABELING:
    if (st && st->dib){
        LabelingDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            UpdateStatusBasic(hWnd, st); // 상태바에 객체 수 등 표시 가능
        }
    }
    return 0;
```

---

## 5) 예제 시나리오

### 예제 A) **동전 분할 → 레이블링 → 개수 세기**
- **상황**: 균일 배경 위 동전 여러 개(서로 약간 떨어짐).  
- **절차**:  
  1) 13.1절 **이진화**(Auto, 임계 약간 조정)  
  2) `Analyze → Label Connected Components…`  
     - Connectivity = **8-connected** (대각 접촉까지 묶음)  
     - Min area = **50 px** (작은 노이즈 제거)  
     - Draw bounding boxes = ON, Open in new window = ON  
  3) `Run`  
- **결과**: 동전마다 **서로 다른 색**의 라벨, 바운딩박스 표시, 팝업에 **K(개수)** 출력 → 자동 계수 가능.

### 예제 B) **문서 스캔: 글자 라벨 분리 후 필터**
- **상황**: 이진화된 텍스트 이미지(작은 잡티 존재).  
- **절차**: 4-연결(문자 세그멘트 분리 강화), Min area = 10~20 px → 작은 점 잡티(노이즈) 제거.  
- **결과**: 글자/기호별 라벨 → 바코드/주소 영역 등 **블록 수준** 필터링 가능.

### 예제 C) **PCB/부품 검사: 결함 검출**
- **상황**: 기준치 이하로 작은 라벨(스크래치)만 카운트.  
- **절차**: 8-연결, Min area = 3~10 px, 결과에서 작은 라벨들의 **위치/둘레**로 결함 유형 분류.  
- **결과**: **작은 결함**만 강조된 마스크와 통계.

---

## 6) 정확성 · 성능 · 확장

### 6.1 정확성
- **연결성 선택**: 대각 접촉을 같은 물체로 보려면 **8-연결**. 서로 분리하려면 **4-연결**.  
- **둘레(perimeter)**: 간단한 4-이웃 에지 카운트. 서브픽셀이 필요하면 외곽선 추출(체인코드)로 개선.  
- **면적 필터**: 결과 후처리로 **재압축(compaction)** 필수(레이블 갭 제거).

### 6.2 성능
- **캐시 친화 스캔**: 행 우선 2-패스는 메모리 대역폭 지배.  
- **멀티스레드**: 블록 분할 + 경계 병합(Union–Find)로 확장 가능(고급).  
- **RLE 기반 레이블링**: 줄 단위 Run-Length를 레이블링하면 매우 빠름(산업계 표준). 본 장은 가독성을 위해 픽셀 기반을 제시.

### 6.3 확장
- **홀 채우기**: 라벨의 바운딩 박스 내 **배경 구멍**을 추가 전경으로 병합.  
- **형상 지표**: 원형도 \(4\pi A / P^2\), 길이/너비, 주관성(Major/Minor axis) 등 PCA 기반 특징.  
- **색상 입력**: 컬러 영상에서도 **마스크**만 이진이면 동일하게 적용됩니다.

---

## 7) 간단 테스트

```cpp
// test_labeling.cpp
#include <cassert>
#include "IppDib.h"
#include "Labeling.hpp"

int main(){
    // 64x48: 두 개의 사각형 전경(하나는 대각으로 접촉)
    IppDib dib; dib.create(64,48,32);
    // 배경 0
    for(int y=0;y<48;++y){
        uint8_t* d=(uint8_t*)dib.bits()+y*dib.stride();
        for(int x=0;x<64;++x){ d[x*4+0]=d[x*4+1]=d[x*4+2]=0; d[x*4+3]=255; }
    }
    // 사각형 A: [4..20]x[6..30], B: [18..34]x[22..44] (대각 접촉)
    auto fill=[&](int x0,int y0,int x1,int y1){
        for(int y=y0;y<=y1;++y){
            uint8_t* d=(uint8_t*)dib.bits()+y*dib.stride();
            for(int x=x0;x<=x1;++x){ d[x*4+0]=d[x*4+1]=d[x*4+2]=255; }
        }
    };
    fill(4,6,20,30); fill(18,22,34,44);

    IppImage<uint8_t> bin; DibToBinary8(dib, bin);

    // 4-연결: 대각 접촉이지만 서로 다른 라벨 2개여야 함
    LabelingOptions o4; o4.conn=Connectivity::C4; o4.minArea=1;
    auto r4 = LabelComponents(bin, o4);
    assert(r4.numLabels==2);

    // 8-연결: 대각 접촉 → 하나의 라벨로 묶임
    LabelingOptions o8; o8.conn=Connectivity::C8; o8.minArea=1;
    auto r8 = LabelComponents(bin, o8);
    assert(r8.numLabels==1);

    // 색상화만 검사
    IppDib c = ColorizeLabels(r4); (void)c;
    return 0;
}
```

---

## 8) 요약
- **고전적 2-패스 레이블링**은 간단·빠르고, **Union–Find** 로 동치 집합을 해결합니다.  
- **4/8-연결** 및 **면적 필터** 옵션은 실제 데이터(문서/부품/자연물)에 매우 중요합니다.