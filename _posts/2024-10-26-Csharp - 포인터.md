---
layout: post
title: C# - 포인터
date: 2024-10-26 19:20:23 +0900
category: Csharp
---
# C# 포인터 완전 정리 (unsafe, fixed, *, &, ->, IntPtr, Span<T> 등)

## 빠른 개념 지도

- **포인터**: 메모리 주소를 담는 값. `int*`, `byte*`, `void*` 등.
- **unsafe 블록**: 컴파일러의 안전성 보장을 일부 해제. `/unsafe` 옵션 필요.
- **fixed**: GC 이동을 **일시 정지**(pinning)하여 참조형/관리 배열의 **고정 주소**를 얻는다.
- **IntPtr/nint**: 주소 크기와 동일한 정수형 래퍼. 포인터 연산 없이 주소 보관/전달.
- **Span<T>/Memory<T>**: 포인터대신 **경계체크/슬라이스/stackalloc**과 결합해 **안전·고성능** 버퍼 접근 제공.
- **StructLayout/Marshal/GCHandle**: 네이티브 상호운용, 메모리 레이아웃 제어.
- **function pointer (`delegate*`)**: 오버헤드 적은 네이티브/관리 함수 포인터 호출(unsafe).

---

## 컴파일/실행 준비

### `/unsafe` 활성화

- **CLI**: `dotnet build -c Release /p:AllowUnsafeBlocks=true`
- **csproj**:
```xml
<PropertyGroup>
  <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  <Optimize>true</Optimize>
</PropertyGroup>
```

### 최소 콘솔 예제

```csharp
using System;

class Program
{
    unsafe static void Main()
    {
        int a = 10;
        int* p = &a;      // 주소 취득
        Console.WriteLine(*p);   // 역참조 -> 10
        *p = 42;                 // 쓰기
        Console.WriteLine(a);    // 42
    }
}
```

---

## 포인터 문법 총정리

| 구문 | 의미/예시 |
|---|---|
| `T*` | 포인터 선언. `int*`, `byte*`, `void*`, `MyStruct*` |
| `&expr` | 주소 연산자. `int* p = &a;` |
| `*p` | 역참조. `*p = 5; var v = *p;` |
| `p + n` | 포인터 산술(요소 단위). `*(p + 2)` |
| `p[i]` | 인덱서 문법 당연 지원. `p[i] == *(p + i)` |
| `->` | 구조체 필드 접근. `point->X` == `(*point).X` |
| `void*` | 타입 미지정 포인터(바이트 단위 캐스팅 필요) |

> 규칙: **참조형(`class`, `string`)은 직접 포인터 불가**. 주소가 필요한 경우 **고정(`fixed`)**이 필요하다.

---

## fixed — 고정(pinning)과 주소 얻기

GC는 이동식(compacting)이다. 따라서 **배열/문자열/고정버퍼** 주소를 얻으려면 **`fixed`** 로 GC의 이동을 일시 금지해야 한다.

```csharp
unsafe static void PinArray()
{
    int[] arr = { 10, 20, 30, 40 };
    fixed (int* p = arr) // 범위 내 pinning
    {
        for (int i = 0; i < arr.Length; i++)
            Console.WriteLine(p[i]);
        // 여기서 arr은 GC가 못 옮긴다
    }
}
```

### 여러 대상 고정

```csharp
unsafe static void MultiPin()
{
    int a = 1, b = 2;
    fixed (int* pa = &a, pb = &b)
    {
        *pa += *pb;
    }
}
```

### 문자열 고정

```csharp
unsafe static void PinString()
{
    string s = "ABC";
    fixed (char* p = s)
    {
        // char 단위 접근 가능 (읽기 전용으로만!)
        Console.WriteLine(p[0]); // 'A'
    }
}
```

> **주의**: pinning 남용은 **GC 단편화/성능 저하**. pin 범위를 최대한 **짧게** 잡자.

---

## 구조체와 포인터

```csharp
struct Point { public int X; public int Y; }

unsafe static void StructPtr()
{
    Point pt = new() { X = 7, Y = 9 };
    Point* p = &pt;
    Console.WriteLine(p->X + p->Y); // 16
    p->X = 100;
}
```

### 필드 (unsafe struct 내)

```csharp
unsafe struct Buffer64
{
    public fixed byte Data[64]; // struct 내 고정 길이 버퍼
}

unsafe static void UseFixedBuffer()
{
    Buffer64 b = default;
    for (int i = 0; i < 64; i++)
        b.Data[i] = (byte)i;
}
```

---

## 포인터 산술과 정렬(alignment)

```csharp
unsafe static void PtrMath()
{
    int[] a = { 1, 2, 3, 4 };
    fixed (int* p = a)
    {
        int second = *(p + 1); // == a[1]
        p[2] = 42;             // == a[2] = 42
    }
}
```

- 산술 단위는 **요소 크기**. `int* p; p + 1`은 주소 `sizeof(int)`만큼 이동.
- 잘못된 정렬로 접근하면 **플랫폼에 따라 예외/성능 저하**.

**간단 모델**: 요소 크기를 \( s \), 시작 주소를 \( A \)라 하면, 인덱스 \( i \) 요소 주소는
$$ \text{addr}(i) = A + i \cdot s $$

---

## sizeof / stackalloc / fixed vs stackalloc

### `sizeof`

```csharp
unsafe static void Sizes()
{
    Console.WriteLine(sizeof(int));    // 4
    Console.WriteLine(sizeof(double)); // 8
    Console.WriteLine(sizeof(Point));  // 8 (int 2개)
}
```

### `stackalloc` — 스택에 고정 길이 버퍼

```csharp
unsafe static void StackAlloc()
{
    int* p = stackalloc int[4]; // 스택에 16바이트
    for (int i = 0; i < 4; i++) p[i] = i + 1;
}
```

- **함수 프레임 종료 시 자동 해제**, **매우 빠름**, 너무 크게 할당하면 **스택 오버플로**.
- 참조를 **함수 밖으로 반환 금지**.

### `Span<T>` 와 `stackalloc` (안전 대안)

```csharp
static void SpanStackalloc()
{
    Span<int> buf = stackalloc int[4];
    for (int i = 0; i < buf.Length; i++) buf[i] = i + 1;
}
```

---

## IntPtr / UIntPtr / nint / nuint

- `IntPtr` / `UIntPtr`: **런타임 포인터 크기**를 따르는 정수 포장형. 보관·핸들 전달용.
- `nint` / `nuint`: C# 9의 **네이티브 정수** 키워드 (산술 가능).

```csharp
nint addr = (nint)123456;
IntPtr ip = (IntPtr)addr;
long raw = ip.ToInt64();
```

> 포인터 연산은 아니므로 **역참조 불가**. 필요 시 **`Unsafe.AsPointer(ref)`** 또는 **`Marshal`** 로 변환.

---

## P/Invoke, StructLayout, Marshal, GCHandle

### StructLayout — 레이아웃 고정

```csharp
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 1)]
struct Header
{
    public byte Magic;
    public int Length;
}
```

### P/Invoke 선언 예

```csharp
[DllImport("kernel32.dll", SetLastError = true)]
static extern unsafe bool ReadFile(
    IntPtr hFile,
    void* lpBuffer,
    uint nNumberOfBytesToRead,
    out uint lpNumberOfBytesRead,
    IntPtr lpOverlapped);
```

### GCHandle — 수동 pin

```csharp
using System.Runtime.InteropServices;

static unsafe void PinWithGCHandle(byte[] data)
{
    var handle = GCHandle.Alloc(data, GCHandleType.Pinned);
    try
    {
        byte* p = (byte*)handle.AddrOfPinnedObject();
        // 사용
    }
    finally
    {
        handle.Free(); // 반드시 해제
    }
}
```

> **원칙**: pinning 범위는 **짧고 명확**하게. 장기간 pin은 **힙 단편화** 유발.

---

## MemoryMarshal / Unsafe 유틸(고급)

> 고급 시나리오: `System.Runtime.InteropServices.MemoryMarshal`, `System.Runtime.CompilerServices.Unsafe`
> (후자는 NuGet `System.Runtime.CompilerServices.Unsafe` 필요)

### Span ↔ 포인터

```csharp
using System;
using System.Runtime.InteropServices;

unsafe static void SpanToPtr()
{
    Span<int> s = stackalloc int[3] { 1, 2, 3 };
    ref int r0 = ref MemoryMarshal.GetReference(s); // 첫 요소 ref
    fixed (int* p = &r0)
    {
        Console.WriteLine(p[1]); // 2
    }
}
```

### 바이트 캐스팅

```csharp
Span<int> a = stackalloc int[2] { 0x11223344, 0xAABBCCDD };
Span<byte> b = MemoryMarshal.AsBytes(a);
```

### 위험하지만 강력한 `Unsafe`

```csharp
// ref를 포인터로, 포인터를 ref로, 임의 캐스팅 등
// 무결성 보장이 어려우므로 꼭 필요할 때만 사용
```

---

## ReadOnlySpan<T>, Span<T>, Memory<T>, IMemoryOwner<T>

- `Span<T>`: **스택/관리/비관리** 메모리를 **슬라이스 가능한 안전 뷰**로 접근.
- `ReadOnlySpan<T>`: 읽기 전용.
- `Memory<T>`/`ReadOnlyMemory<T>`: **힙에서 보관 가능**(비동기/필드 저장).
- `IMemoryOwner<T>`: **풀링된 버퍼** 소유/해제 패턴.

```csharp
static void SliceDemo(ReadOnlySpan<byte> data)
{
    var header = data.Slice(0, 16);
    var payload = data.Slice(16);
}
```

> 일상적인 고성능 I/O, 파싱, 직렬화는 **포인터보다 Span**이 선호된다.

---

## — 호출 오버헤드 최소화

```csharp
unsafe static class Fp
{
    // 관리 함수 포인터
    public static int Add(int a, int b) => a + b;

    public static void Demo()
    {
        delegate*<int, int, int> f = &Add; // 관리 함수 포인터
        int r = f(3, 4); // 7
        Console.WriteLine(r);
    }
}
```

### 언매니지드 호출 규약

```csharp
unsafe static class Native
{
    // unmanaged function pointer
    private static extern delegate* unmanaged[Cdecl]<int, int, int> GetAdder();

    static void Use()
    {
        var fp = GetAdder();
        int r = fp(10, 20);
    }
}
```

> 고급 최적화 도구. **unsafe**이며 호환성·라이프사이클을 스스로 보장해야 한다.

---

## 고속 처리 실전 예 — 이미지 라인 반전

### unsafe 포인터

```csharp
unsafe static void Invert(byte[] line)
{
    fixed (byte* p = line)
    {
        for (int i = 0; i < line.Length; i++)
            p[i] = (byte)(255 - p[i]);
    }
}
```

### Span 대안

```csharp
static void InvertSpan(Span<byte> line)
{
    for (int i = 0; i < line.Length; i++)
        line[i] = (byte)(255 - line[i]);
}
```

> 대부분의 경우 **JIT 경계체크 제거 + 벡터화** 덕분에 `Span<T>` 버전도 상당히 빠르다.
> 포인터는 인터롭·특수 레이아웃·비관리 메모리에서만 최소화 사용을 권장.

---

## 성능 팁 & 함정

- **Pinning 최소화**: `fixed`/`GCHandle` 범위는 작게. 가능하면 **복사 후 작업**.
- **큰 버퍼는 힙 풀**: `ArrayPool<T>`, `MemoryPool<T>`로 재사용.
- **정렬/패딩**: `StructLayout(Pack=1)`은 I/O에는 좋지만 CPU 접근은 느릴 수 있다.
- **경합 회피**: 여러 스레드가 같은 메모리를 수정하지 않게 **샤딩/슬라이스**.
- **경계 체크 제거**: `Span<T>` + `for` + JIT 최적화로 포인터 급 성능 확보.
- **플랫폼 차이**: 32/64비트, 엔디안, 호출 규약 차이 주의.

---

## 안전 체크리스트

- [ ] unmanaged 접근이 꼭 필요한가? → **Span/Memory**로 대체 가능성 검토
- [ ] pinning 범위를 꼭 **최소화**했는가?
- [ ] `fixed` 내부에서 **예외** 발생 시 리소스/상태는 안전한가?
- [ ] `StructLayout`/필드 순서/패딩을 **명시적으로** 확인했는가?
- [ ] `Marshal.FreeHGlobal` / `IMemoryOwner.Dispose` 등 **해제 책임**을 분명히 했는가?
- [ ] 함수 포인터/콜백의 **수명과 스레드 안전**을 보장했는가?

---

## 미세 최적화와 모델

- 주소 산술은 **요소 크기** 단위: \( \text{addr}(i)=A+i\cdot s \).
- 핫루프에서 경계 체크/분기/분산 메모리 접근을 줄이면 **IPC**(instructions per cycle) 상승.
- **SIMD(System.Runtime.Intrinsics)** 활용 시 정렬과 연속성 보장이 성능 핵심.

---

## 실전: 바이트 시퀀스에서 구조체 파싱

### unsafe 캐스팅 (정렬 보장 가정)

```csharp
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 1)]
struct MyHeader
{
    public int Magic;
    public short Version;
    public short Flags;
}

unsafe static MyHeader ParseHeader(byte[] bytes)
{
    fixed (byte* p = bytes)
        return *(MyHeader*)p; // 위험: 길이/정렬 미검증
}
```

### 안전한 Span + MemoryMarshal

```csharp
using System;
using System.Runtime.InteropServices;

static MyHeader ParseHeaderSafe(ReadOnlySpan<byte> bytes)
{
    if (bytes.Length < Unsafe.SizeOf<MyHeader>())
        throw new ArgumentException("Too short");

    return MemoryMarshal.Read<MyHeader>(bytes);
}
```

> 실무에서는 **Span + MemoryMarshal** 방식을 권장.

---

## 요약

- C# 포인터는 **인터롭/특수 성능** 요구에서만 최소화 사용.
- 주소가 필요하면 **`fixed`로 pinning** 후 **짧게** 쓰고 벗어나라.
- 주소 보관/호출 규약은 **`IntPtr`/`nint`/`delegate*`**로, 버퍼 조작은 **`Span<T>`/`Memory<T>`** 로 우선 설계.
- 레이아웃/수명/경합/정렬을 명시적으로 관리하라. 이것이 **안전한 고성능 C#**의 핵심이다.
