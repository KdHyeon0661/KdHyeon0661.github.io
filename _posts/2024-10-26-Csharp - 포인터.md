---
layout: post
title: C# - 포인터
date: 2024-10-26 19:20:23 +0900
category: Csharp
---
# C# 포인터 완전 정리 (unsafe, fixed, *, &, ->, IntPtr, Span<T> 등)

## 소개: 메모리 직접 접근의 필요성과 위험성

C#은 주로 안전한(safe) 코드를 작성하도록 설계된 언어이지만, 성능이 중요한 특정 시나리오나 네이티브 코드와의 상호 운용이 필요할 때는 메모리를 직접 접근해야 할 경우가 있습니다. 이러한 경우 C#은 `unsafe` 키워드를 통해 포인터와 같은 저수준 메모리 조작 기능을 제공합니다. 이 기능들은 강력하지만 잘못 사용하면 메모리 손상, 보안 취약점, 애플리케이션 충돌 등 심각한 문제를 일으킬 수 있습니다.

포인터를 이해하는 것은 최신 C#의 `Span<T>`, `Memory<T>` 같은 고성능 메모리 접근 기능을 이해하는 데도 도움이 됩니다. 이 가이드는 C#에서 포인터를 안전하고 효과적으로 사용하는 방법을 체계적으로 설명합니다.

---

## 1. 기본 개념: 포인터와 unsafe 컨텍스트

### 포인터란 무엇인가?

포인터는 메모리 주소를 저장하는 변수입니다. C#에서 포인터 타입은 타입 이름 뒤에 `*`를 붙여 표시합니다.

```csharp
int number = 42;      // 일반 정수 변수
int* pointer;         // 정수 포인터 (아직 어떤 메모리도 가리키지 않음)
```

### unsafe 컨텍스트

포인터를 사용하려면 `unsafe` 키워드로 표시된 컨텍스트 내에서 작업해야 합니다.

```csharp
using System;

class Program
{
    unsafe static void Main()
    {
        int value = 10;
        int* pointer = &value;  // value의 주소를 얻음
        
        Console.WriteLine($"값: {value}");           // 10
        Console.WriteLine($"주소: {(long)pointer:X}"); // 메모리 주소 (16진수)
        Console.WriteLine($"포인터를 통한 값: {*pointer}"); // 10 (역참조)
        
        *pointer = 20;  // 포인터를 통해 값 변경
        Console.WriteLine($"변경된 값: {value}");     // 20
    }
}
```

### 프로젝트에 unsafe 허용하기

포인터를 사용하려면 프로젝트 설정에서 unsafe 코드를 허용해야 합니다.

**프로젝트 파일(.csproj)에 추가:**
```xml
<PropertyGroup>
  <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
</PropertyGroup>
```

**또는 명령줄에서 빌드:**
```bash
dotnet build -c Release /p:AllowUnsafeBlocks=true
```

---

## 2. 포인터 기본 문법과 연산

### 주소 연산자(&)와 역참조 연산자(*)

```csharp
unsafe static void PointerBasics()
{
    int number = 100;
    
    // 주소 연산자(&): 변수의 메모리 주소 얻기
    int* pointer = &number;
    
    // 역참조 연산자(*): 포인터가 가리키는 메모리의 값 접근
    int value = *pointer;
    
    Console.WriteLine($"원본 값: {number}");          // 100
    Console.WriteLine($"포인터 주소: {(long)pointer:X}"); 
    Console.WriteLine($"역참조 값: {value}");         // 100
    
    // 포인터를 통한 값 변경
    *pointer = 200;
    Console.WriteLine($"변경 후 원본 값: {number}");  // 200
}
```

### 포인터 산술 연산

포인터에 정수를 더하거나 빼면 메모리 주소가 이동합니다. 이동 크기는 포인터 타입의 크기에 따라 결정됩니다.

```csharp
unsafe static void PointerArithmetic()
{
    int[] numbers = { 10, 20, 30, 40, 50 };
    
    fixed (int* ptr = &numbers[0])
    {
        // 포인터 산술: ptr + 2는 두 번째 인덱스로 이동
        int* secondElement = ptr + 2;
        Console.WriteLine($"두 번째 요소: {*secondElement}"); // 30
        
        // 포인터 인덱서 사용
        Console.WriteLine($"인덱서 [3]: {ptr[3]}"); // 40
        
        // 포인터 차이 계산
        long difference = secondElement - ptr;
        Console.WriteLine($"포인터 차이: {difference}"); // 2 (요소 개수 차이)
    }
}
```

### 구조체 포인터와 화살표 연산자(->)

```csharp
unsafe struct Point
{
    public int X;
    public int Y;
}

unsafe static void StructPointers()
{
    Point point = new Point { X = 5, Y = 10 };
    Point* ptr = &point;
    
    // 화살표 연산자(->)로 구조체 필드 접근
    Console.WriteLine($"X: {ptr->X}, Y: {ptr->Y}"); // X: 5, Y: 10
    
    // 역참조 후 점 연산자로도 접근 가능
    Console.WriteLine($"X: {(*ptr).X}, Y: {(*ptr).Y}"); // 동일한 결과
    
    // 구조체 필드 수정
    ptr->X = 100;
    Console.WriteLine($"수정 후 X: {point.X}"); // 100
}
```

---

## 3. 메모리 관리와 GC 상호작용

### 문제: 가비지 컬렉터와 메모리 이동

C#의 가비지 컬렉터(GC)는 메모리를 효율적으로 관리하기 위해 객체를 힙 내에서 이동시킬 수 있습니다. 이는 포인터 사용에 큰 문제를 일으킵니다.

```csharp
unsafe static void GarbageCollectorProblem()
{
    int[] array = { 1, 2, 3, 4, 5 };
    int* pointer;
    
    // 이 코드는 문제가 있습니다!
    // fixed 없이 배열 주소를 얻으면 GC가 배열을 이동시킬 수 있음
    // pointer = &array[0]; // 위험!
}
```

### 해결책: fixed 키워드로 메모리 고정

`fixed` 키워드는 GC가 객체를 이동시키지 못하도록 "고정"합니다.

```csharp
unsafe static void FixedExample()
{
    int[] array = { 1, 2, 3, 4, 5 };
    
    // fixed 블록 내에서 배열이 고정됨
    fixed (int* ptr = array)
    {
        // 이 블록 내에서는 GC가 array를 이동시키지 않음
        for (int i = 0; i < array.Length; i++)
        {
            Console.WriteLine($"array[{i}] = {ptr[i]}");
        }
    } // fixed 블록이 끝나면 고정 해제
}
```

### 여러 객체를 한 번에 고정

```csharp
unsafe static void MultipleFixed()
{
    int x = 10, y = 20, z = 30;
    
    fixed (int* px = &x, py = &y, pz = &z)
    {
        *px = 100;
        *py = 200;
        *pz = 300;
    }
    
    Console.WriteLine($"x: {x}, y: {y}, z: {z}"); // 100, 200, 300
}
```

### 문자열 고정

```csharp
unsafe static void FixedString()
{
    string text = "Hello";
    
    fixed (char* ptr = text)
    {
        // 문자열은 불변이므로 읽기만 가능
        for (int i = 0; i < text.Length; i++)
        {
            Console.Write(ptr[i]); // H, e, l, l, o
        }
        Console.WriteLine();
        
        // 다음 코드는 컴파일 오류: 문자열은 읽기 전용
        // ptr[0] = 'h';
    }
}
```

**중요**: `fixed` 블록을 가능한 한 짧게 유지하세요. 장시간 메모리를 고정하면 GC 효율이 저하되고 메모리 단편화를 일으킬 수 있습니다.

---

## 4. stackalloc: 스택에 메모리 할당

`stackalloc` 키워드를 사용하면 스택에 메모리를 할당할 수 있습니다. 이 메모리는 메서드가 반환될 때 자동으로 해제됩니다.

```csharp
unsafe static void StackAllocExample()
{
    // 스택에 10개의 int 공간 할당
    int* buffer = stackalloc int[10];
    
    for (int i = 0; i < 10; i++)
    {
        buffer[i] = i * 2;
    }
    
    for (int i = 0; i < 10; i++)
    {
        Console.WriteLine($"buffer[{i}] = {buffer[i]}");
    }
    
    // 메서드가 끝나면 자동으로 해제됨
}
```

### Span<T>와 함께 사용하는 안전한 stackalloc

C# 7.2부터는 `stackalloc`을 `Span<T>`와 함께 사용할 수 있어 더 안전합니다.

```csharp
static void SafeStackAlloc()
{
    // unsafe 없이 stackalloc 사용 가능
    Span<int> buffer = stackalloc int[10];
    
    for (int i = 0; i < buffer.Length; i++)
    {
        buffer[i] = i * 3;
    }
    
    foreach (int value in buffer)
    {
        Console.WriteLine(value);
    }
    
    // Span을 슬라이스할 수도 있음
    Span<int> slice = buffer.Slice(2, 5);
    Console.WriteLine($"슬라이스 길이: {slice.Length}"); // 5
}
```

**주의**: `stackalloc`으로 할당한 메모리는 스택에 있으므로:
- 크기가 크면 스택 오버플로가 발생할 수 있습니다.
- 메서드 범위를 벗어나서 사용할 수 없습니다.

---

## 5. IntPtr, nint, GCHandle: 포인터 래퍼

### IntPtr과 nint

`IntPtr`과 `UIntPtr`은 플랫폼에 따라 크기가 달라지는 정수 타입으로, 포인터를 안전하게 저장하고 전달하는 데 사용됩니다.

```csharp
using System;

class IntPtrExample
{
    static void Main()
    {
        // IntPtr 생성
        IntPtr pointer = new IntPtr(0x12345678);
        Console.WriteLine($"IntPtr 값: {pointer.ToInt64():X}");
        
        // nint (C# 9.0+)
        nint nativeInt = 0x87654321;
        Console.WriteLine($"nint 값: {nativeInt:X}");
        
        // 포인터에서 IntPtr 생성
        unsafe
        {
            int value = 42;
            int* ptr = &value;
            IntPtr intPtr = (IntPtr)ptr;
            Console.WriteLine($"포인터에서 생성한 IntPtr: {intPtr.ToInt64():X}");
            
            // IntPtr에서 포인터로 변환
            int* ptr2 = (int*)intPtr;
            Console.WriteLine($"IntPtr에서 역변환한 값: {*ptr2}");
        }
    }
}
```

### GCHandle: 수동 메모리 관리

`GCHandle`을 사용하면 수동으로 메모리를 고정할 수 있습니다.

```csharp
using System;
using System.Runtime.InteropServices;

class GCHandleExample
{
    unsafe static void Main()
    {
        byte[] data = new byte[100];
        
        // 메모리 고정
        GCHandle handle = GCHandle.Alloc(data, GCHandleType.Pinned);
        
        try
        {
            // 고정된 메모리의 주소 얻기
            IntPtr address = handle.AddrOfPinnedObject();
            Console.WriteLine($"고정된 배열 주소: {address.ToInt64():X}");
            
            // 포인터로 변환하여 사용
            byte* ptr = (byte*)address;
            for (int i = 0; i < data.Length; i++)
            {
                ptr[i] = (byte)i;
            }
        }
        finally
        {
            // 반드시 해제해야 함
            handle.Free();
        }
    }
}
```

---

## 6. Span<T>와 Memory<T>: 안전한 고성능 메모리 접근

### Span<T> 소개

`Span<T>`는 힙, 스택, 비관리 메모리에 있는 연속 메모리 영역을 나타내는 값 타입입니다. 포인터보다 안전하면서도 비슷한 성능을 제공합니다.

```csharp
using System;

class SpanExample
{
    static void Main()
    {
        // 배열에서 Span 생성
        int[] array = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        Span<int> span = array.AsSpan();
        
        // 슬라이싱
        Span<int> middle = span.Slice(2, 5); // 인덱스 2부터 5개 요소
        Console.WriteLine($"중간 부분: {string.Join(", ", middle.ToArray())}");
        
        // 읽기 전용 Span
        ReadOnlySpan<int> readOnlySpan = array.AsSpan();
        
        // 문자열을 Span<char>로 다루기
        string text = "Hello, World!";
        ReadOnlySpan<char> textSpan = text.AsSpan();
        Console.WriteLine($"첫 5글자: {textSpan.Slice(0, 5).ToString()}");
        
        // 메모리 복사 없이 처리
        ProcessData(span);
    }
    
    static void ProcessData(Span<int> data)
    {
        for (int i = 0; i < data.Length; i++)
        {
            data[i] *= 2; // 원본 배열도 변경됨
        }
    }
}
```

### Memory<T>와 IMemoryOwner<T>

`Memory<T>`는 `Span<T>`와 유사하지만 비동기 코드나 클래스 필드에 저장할 수 있습니다.

```csharp
using System;
using System.Buffers;

class MemoryExample
{
    static void Main()
    {
        // 배열 풀에서 메모리 임대
        IMemoryOwner<int> memoryOwner = MemoryPool<int>.Shared.Rent(100);
        
        try
        {
            Memory<int> memory = memoryOwner.Memory;
            Span<int> span = memory.Span;
            
            // 메모리 사용
            for (int i = 0; i < span.Length; i++)
            {
                span[i] = i;
            }
            
            Console.WriteLine($"처리된 요소 수: {span.Length}");
        }
        finally
        {
            // 메모리 반환
            memoryOwner.Dispose();
        }
    }
}
```

---

## 7. 실전 예제: 고성능 이미지 처리

### 포인터를 사용한 이미지 밝기 조정

```csharp
using System;
using System.Diagnostics;

unsafe class ImageProcessor
{
    // 포인터를 사용한 빠른 이미지 처리
    public static void AdjustBrightness(byte[] imageData, float factor)
    {
        if (imageData == null) throw new ArgumentNullException(nameof(imageData));
        
        fixed (byte* ptr = imageData)
        {
            byte* current = ptr;
            byte* end = ptr + imageData.Length;
            
            while (current < end)
            {
                // 밝기 조정 (간단한 예제)
                int value = *current;
                value = (int)(value * factor);
                
                // 0-255 범위 제한
                if (value < 0) value = 0;
                if (value > 255) value = 255;
                
                *current = (byte)value;
                current++;
            }
        }
    }
    
    // Span을 사용한 더 안전한 버전
    public static void AdjustBrightnessSpan(Span<byte> imageData, float factor)
    {
        for (int i = 0; i < imageData.Length; i++)
        {
            int value = imageData[i];
            value = (int)(value * factor);
            
            if (value < 0) value = 0;
            if (value > 255) value = 255;
            
            imageData[i] = (byte)value;
        }
    }
}

class Program
{
    static void Main()
    {
        // 테스트 데이터 생성 (가짜 이미지 데이터)
        byte[] imageData = new byte[1920 * 1080 * 3]; // Full HD RGB 이미지
        var random = new Random();
        random.NextBytes(imageData);
        
        // 성능 비교
        var stopwatch = Stopwatch.StartNew();
        
        // 포인터 버전
        ImageProcessor.AdjustBrightness(imageData, 1.2f);
        Console.WriteLine($"포인터 버전: {stopwatch.ElapsedMilliseconds}ms");
        
        stopwatch.Restart();
        
        // Span 버전
        ImageProcessor.AdjustBrightnessSpan(imageData, 0.8f);
        Console.WriteLine($"Span 버전: {stopwatch.ElapsedMilliseconds}ms");
        
        // 실제 상황에서는 Span 버전이 더 안전하면서도
        // JIT 컴파일러의 최적화로 인해 포인터와 비슷한 성능을 낼 수 있습니다.
    }
}
```

---

## 8. 주의사항과 모범 사례

### 포인터 사용 시 주의사항

1. **메모리 안전성**: 포인터 연산으로 잘못된 메모리 영역에 접근하면 애플리케이션이 충돌할 수 있습니다.
2. **가비지 컬렉터**: `fixed` 없이 관리 객체의 주소를 사용하지 마세요.
3. **정렬**: 일부 플랫폼에서는 정렬되지 않은 메모리 접근이 느리거나 예외를 발생시킬 수 있습니다.
4. **엔디안**: 다른 시스템과 데이터를 교환할 때는 엔디안(endianness) 문제를 고려하세요.

### 모범 사례

1. **필요할 때만 사용**: 대부분의 경우 `Span<T>`나 `Memory<T>`로 충분합니다.
2. **최소 범위**: `fixed` 블록을 가능한 한 짧게 유지하세요.
3. **경계 검사**: 포인터 인덱싱 시 항상 범위를 확인하세요.
4. **리소스 정리**: `GCHandle`이나 비관리 메모리를 사용한 후에는 반드시 정리하세요.
5. **코드 문서화**: unsafe 코드는 왜 필요한지 명확히 문서화하세요.

### 대안 우선 순위

성능이 중요한 작업을 할 때는 다음 순서로 접근하는 것이 좋습니다:

1. **일반적인 C# 코드**로 시작
2. 필요하면 **Span<T>/Memory<T>** 사용
3. 정말 필요할 때만 **unsafe 포인터** 사용

```csharp
// 1. 일반적인 방법 (가장 안전)
int[] data = GetData();
for (int i = 0; i < data.Length; i++)
{
    Process(data[i]);
}

// 2. Span<T> 사용 (안전하면서도 빠름)
Span<int> span = GetDataAsSpan();
foreach (ref int item in span)
{
    Process(item);
}

// 3. unsafe 포인터 (최후의 수단)
unsafe
{
    fixed (int* ptr = GetData())
    {
        int* end = ptr + dataLength;
        for (int* p = ptr; p < end; p++)
        {
            Process(*p);
        }
    }
}
```

---

## 9. P/Invoke와의 통합

포인터는 네이티브 코드와의 상호 운용(P/Invoke)에서 자주 사용됩니다.

```csharp
using System;
using System.Runtime.InteropServices;

class NativeInterop
{
    // 네이티브 함수 선언
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern unsafe bool ReadFile(
        IntPtr hFile,
        void* lpBuffer,
        uint nNumberOfBytesToRead,
        out uint lpNumberOfBytesRead,
        IntPtr lpOverlapped);
    
    unsafe static void ReadFromFile(string filePath)
    {
        const int bufferSize = 4096;
        byte* buffer = stackalloc byte[bufferSize];
        
        // 파일 열기 등 나머지 코드...
        // ReadFile(buffer, ...);
        
        // 버퍼 처리
        for (int i = 0; i < bufferSize; i++)
        {
            // buffer[i] 사용...
        }
    }
}
```

---

## 결론: 적절한 도구 선택의 중요성

C#의 포인터 기능은 강력한 도구이지만, 위험한 도구이기도 합니다. 올바르게 사용하면 네이티브 코드와의 상호 운용이나 극한의 성능 최적화가 가능하지만, 잘못 사용하면 메모리 손상이나 애플리케이션 충돌을 일으킬 수 있습니다.

**핵심 원칙을 정리해 보겠습니다:**

1. **필요할 때만 사용하세요**: 대부분의 애플리케이션에서는 포인터가 필요하지 않습니다. 먼저 `Span<T>`, `Memory<T>`, `ArraySegment<T>` 같은 안전한 대안을 고려하세요.

2. **안전을 최우선으로 하세요**: `fixed` 블록을 사용하여 GC 문제를 방지하고, 포인터 연산 시 범위를 항상 확인하세요.

3. **성능 측정하세요**: 포인터를 사용하기 전과 후에 성능을 측정하여 실제 이점이 있는지 확인하세요. 많은 경우 `Span<T>`가 충분히 빠릅니다.

4. **코드를 명확히 문서화하세요**: unsafe 코드는 왜 필요한지, 어떻게 동작하는지 명확히 문서화하세요. 이는 미래의 유지보수 개발자에게 중요합니다.

5. **최신 기능을 활용하세요**: C# 7.2 이후로 도입된 `Span<T>`, `Memory<T>`, 안전한 `stackalloc` 같은 기능들은 포인터의 많은 사용 사례를 더 안전하게 대체할 수 있습니다.

포인터는 C#의 "비상 탈출구" 같은 기능입니다. 필요한 경우에만 신중하게 사용하고, 가능하면 더 안전한 대안을 선택하세요. 이렇게 하면 성능과 안전성 사이의 균형을 잘 유지할 수 있을 것입니다.