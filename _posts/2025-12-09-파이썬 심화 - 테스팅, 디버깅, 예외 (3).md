---
layout: post
title: íŒŒì´ì¬ ì‹¬í™” - í…ŒìŠ¤íŒ…, ë””ë²„ê¹…, ì˜ˆì™¸ (3)
date: 2025-12-09 15:30:23 +0900
category: íŒŒì´ì¬ ì‹¬í™”
---
# í…ŒìŠ¤íŒ…, ë””ë²„ê¹…, ì˜ˆì™¸ (3)

## ê²½ê³  ë©”ì‹œì§€ ìƒì„±ê³¼ ê´€ë¦¬ ì‹œìŠ¤í…œ

íš¨ê³¼ì ì¸ ê²½ê³  ì‹œìŠ¤í…œì€ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì•ˆì •ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ í¬ê²Œ í–¥ìƒì‹œí‚µë‹ˆë‹¤. ì‚¬ìš©ìì—ê²Œ ìœ ìš©í•œ ì •ë³´ë¥¼ ì œê³µí•˜ë©´ì„œë„ ì‹œìŠ¤í…œ ë¡œê·¸ë¥¼ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ë°©ë²•ì„ ì‚´í´ë´…ë‹ˆë‹¤.

```python
import warnings
import logging
import sys
import inspect
from typing import Dict, List, Optional, Union, Callable, Any
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import traceback
import json

class WarningSeverity(Enum):
    """ê²½ê³  ì‹¬ê°ë„ ìˆ˜ì¤€"""
    DEBUG = 10      # ê°œë°œìš© ë””ë²„ê¹… ì •ë³´
    INFO = 20       # ì •ë³´ì„± ë©”ì‹œì§€
    WARNING = 30    # ì£¼ì˜ í•„ìš” (ê¸°ë³¸ê°’)
    ERROR = 40      # ì˜¤ë¥˜ ê°€ëŠ¥ì„± ìˆìŒ
    CRITICAL = 50   # ì‹¬ê°í•œ ë¬¸ì œ ê°€ëŠ¥ì„±

class WarningCategory(Enum):
    """ê²½ê³  ì¹´í…Œê³ ë¦¬"""
    DEPRECATION = "deprecation"      # ì‚¬ìš© ì¤‘ë‹¨ ì˜ˆì •
    PERFORMANCE = "performance"      # ì„±ëŠ¥ ê´€ë ¨
    SECURITY = "security"            # ë³´ì•ˆ ê´€ë ¨
    RESOURCE = "resource"            # ìì› ì‚¬ìš© ê´€ë ¨
    COMPATIBILITY = "compatibility"  # í˜¸í™˜ì„± ê´€ë ¨
    SYNTAX = "syntax"                # êµ¬ë¬¸ ê´€ë ¨
    RUNTIME = "runtime"              # ì‹¤í–‰ ì‹œê°„ ê´€ë ¨

@dataclass
class WarningContext:
    """ê²½ê³  ë°œìƒ ì»¨í…ìŠ¤íŠ¸ ì •ë³´"""
    filename: str
    lineno: int
    function: str
    code_context: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    stack_trace: Optional[str] = None
    
    @classmethod
    def capture(cls, depth: int = 2) -> 'WarningContext':
        """í˜„ì¬ ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ ìº¡ì²˜"""
        frame = inspect.currentframe()
        # í˜¸ì¶œ ìŠ¤íƒì—ì„œ ì ì ˆí•œ í”„ë ˆì„ ì°¾ê¸°
        for _ in range(depth):
            if frame is None:
                break
            frame = frame.f_back
        
        if frame is None:
            return cls("unknown", 0, "unknown")
        
        # ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ìº¡ì²˜
        stack = traceback.extract_stack(limit=depth+2)
        stack_trace = "\n".join(traceback.format_list(stack[:-1]))
        
        # ì½”ë“œ ì»¨í…ìŠ¤íŠ¸ ìº¡ì²˜
        try:
            with open(frame.f_code.co_filename, 'r') as f:
                lines = f.readlines()
                start_line = max(0, frame.f_lineno - 3)
                end_line = min(len(lines), frame.f_lineno + 2)
                code_context = "".join(lines[start_line:end_line])
        except:
            code_context = None
        
        return cls(
            filename=frame.f_code.co_filename,
            lineno=frame.f_lineno,
            function=frame.f_code.co_name,
            code_context=code_context,
            stack_trace=stack_trace
        )

@dataclass
class StructuredWarning:
    """êµ¬ì¡°í™”ëœ ê²½ê³  ë©”ì‹œì§€"""
    message: str
    severity: WarningSeverity
    category: WarningCategory
    context: WarningContext
    data: Dict[str, Any] = field(default_factory=dict)
    warning_id: str = field(default_factory=lambda: datetime.now().strftime("%Y%m%d%H%M%S%f"))
    
    def to_dict(self) -> Dict:
        """ì‚¬ì „ìœ¼ë¡œ ë³€í™˜"""
        return {
            'id': self.warning_id,
            'message': self.message,
            'severity': self.severity.value,
            'category': self.category.value,
            'timestamp': self.context.timestamp.isoformat(),
            'location': {
                'file': self.context.filename,
                'line': self.context.lineno,
                'function': self.context.function
            },
            'data': self.data,
            'stack_trace': self.context.stack_trace
        }
    
    def to_json(self) -> str:
        """JSON ë¬¸ìì—´ë¡œ ë³€í™˜"""
        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)
    
    def format_for_display(self) -> str:
        """ì‚¬ìš©ì í‘œì‹œìš© í˜•ì‹"""
        severity_icons = {
            WarningSeverity.DEBUG: "ğŸ”",
            WarningSeverity.INFO: "â„¹ï¸",
            WarningSeverity.WARNING: "âš ï¸",
            WarningSeverity.ERROR: "âŒ",
            WarningSeverity.CRITICAL: "ğŸš¨"
        }
        
        icon = severity_icons.get(self.severity, "âš ï¸")
        time_str = self.context.timestamp.strftime("%H:%M:%S")
        
        return (f"{icon} [{time_str}] {self.severity.name}: {self.message}\n"
                f"    ìœ„ì¹˜: {self.context.filename}:{self.context.lineno} in {self.context.function}\n"
                f"    ì¹´í…Œê³ ë¦¬: {self.category.value}")

class AdvancedWarningSystem:
    """ê³ ê¸‰ ê²½ê³  ê´€ë¦¬ ì‹œìŠ¤í…œ"""
    
    def __init__(self, 
                 log_level: WarningSeverity = WarningSeverity.WARNING,
                 enable_console: bool = True,
                 enable_file_logging: bool = False,
                 log_file: str = "warnings.log"):
        """
        Args:
            log_level: ë¡œê·¸ ìˆ˜ì¤€ í•„í„°
            enable_console: ì½˜ì†” ì¶œë ¥ ì—¬ë¶€
            enable_file_logging: íŒŒì¼ ë¡œê¹… ì—¬ë¶€
            log_file: ë¡œê·¸ íŒŒì¼ ê²½ë¡œ
        """
        self.log_level = log_level
        self.enable_console = enable_console
        self.enable_file_logging = enable_file_logging
        self.log_file = log_file
        self.warning_history: List[StructuredWarning] = []
        self.warning_filters: List[Callable] = []
        self.warning_handlers: List[Callable] = []
        
        # í‘œì¤€ warnings ëª¨ë“ˆ ì„¤ì •
        warnings.simplefilter('always')  # ëª¨ë“  ê²½ê³  í‘œì‹œ
        
        # ì‚¬ìš©ì ì •ì˜ í•„í„° ë“±ë¡
        warnings.filterwarnings('ignore', category=DeprecationWarning, module='__main__')
        
        # ê¸°ë³¸ í•¸ë“¤ëŸ¬ ë“±ë¡
        self.register_handler(self._default_handler)
        
        # íŒŒì¼ ë¡œê¹… ì„¤ì •
        if enable_file_logging:
            self.setup_file_logging()
    
    def setup_file_logging(self):
        """íŒŒì¼ ë¡œê¹… ì„¤ì •"""
        self.file_handler = logging.FileHandler(self.log_file, encoding='utf-8')
        self.file_handler.setLevel(logging.WARNING)
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        self.file_handler.setFormatter(formatter)
    
    def register_handler(self, handler: Callable[[StructuredWarning], None]):
        """ê²½ê³  í•¸ë“¤ëŸ¬ ë“±ë¡"""
        self.warning_handlers.append(handler)
    
    def register_filter(self, filter_func: Callable[[StructuredWarning], bool]):
        """ê²½ê³  í•„í„° ë“±ë¡"""
        self.warning_filters.append(filter_func)
    
    def issue(self, 
              message: str,
              severity: WarningSeverity = WarningSeverity.WARNING,
              category: WarningCategory = WarningCategory.RUNTIME,
              **kwargs) -> StructuredWarning:
        """
        êµ¬ì¡°í™”ëœ ê²½ê³  ë°œí–‰
        
        Args:
            message: ê²½ê³  ë©”ì‹œì§€
            severity: ì‹¬ê°ë„ ìˆ˜ì¤€
            category: ê²½ê³  ì¹´í…Œê³ ë¦¬
            **kwargs: ì¶”ê°€ ë°ì´í„°
            
        Returns:
            ìƒì„±ëœ ê²½ê³  ê°ì²´
        """
        context = WarningContext.capture()
        warning = StructuredWarning(
            message=message,
            severity=severity,
            category=category,
            context=context,
            data=kwargs
        )
        
        # í•„í„° ì ìš©
        for filter_func in self.warning_filters:
            if not filter_func(warning):
                return warning
        
        # ë¡œê·¸ ìˆ˜ì¤€ í•„í„°ë§
        if warning.severity.value >= self.log_level.value:
            # í•¸ë“¤ëŸ¬ ì‹¤í–‰
            for handler in self.warning_handlers:
                try:
                    handler(warning)
                except Exception as e:
                    print(f"ê²½ê³  í•¸ë“¤ëŸ¬ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}")
            
            # ë‚´ë¶€ ê¸°ë¡
            self.warning_history.append(warning)
        
        return warning
    
    def _default_handler(self, warning: StructuredWarning):
        """ê¸°ë³¸ ê²½ê³  í•¸ë“¤ëŸ¬"""
        if self.enable_console:
            print(warning.format_for_display())
        
        if self.enable_file_logging:
            logger = logging.getLogger(__name__)
            logger.addHandler(self.file_handler)
            log_level = warning.severity.name.lower()
            getattr(logger, log_level)(warning.to_json())
    
    def deprecation_warning(self, 
                           old_feature: str,
                           new_feature: Optional[str] = None,
                           version: Optional[str] = None,
                           removal_version: Optional[str] = None):
        """ì‚¬ìš© ì¤‘ë‹¨ ê²½ê³ """
        message = f"'{old_feature}'ëŠ” ì‚¬ìš© ì¤‘ë‹¨ ì˜ˆì •ì…ë‹ˆë‹¤."
        if new_feature:
            message += f" ëŒ€ì‹  '{new_feature}'ë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”."
        if removal_version:
            message += f" {removal_version} ë²„ì „ì—ì„œ ì œê±°ë  ì˜ˆì •ì…ë‹ˆë‹¤."
        
        return self.issue(
            message=message,
            severity=WarningSeverity.WARNING,
            category=WarningCategory.DEPRECATION,
            old_feature=old_feature,
            new_feature=new_feature,
            version=version,
            removal_version=removal_version
        )
    
    def performance_warning(self, 
                           operation: str,
                           duration: float,
                           threshold: float = 1.0):
        """ì„±ëŠ¥ ê²½ê³ """
        message = f"'{operation}' ì‘ì—…ì´ {duration:.2f}ì´ˆ ì†Œìš”ë˜ì—ˆìŠµë‹ˆë‹¤."
        if duration > threshold:
            message += f" ({threshold:.2f}ì´ˆ ì œí•œ ì´ˆê³¼)"
        
        return self.issue(
            message=message,
            severity=WarningSeverity.WARNING,
            category=WarningCategory.PERFORMANCE,
            operation=operation,
            duration=duration,
            threshold=threshold
        )
    
    def resource_warning(self, 
                        resource_type: str,
                        usage: float,
                        limit: Optional[float] = None):
        """ìì› ì‚¬ìš© ê²½ê³ """
        message = f"{resource_type} ì‚¬ìš©ëŸ‰: {usage:.1f}%"
        if limit and usage > limit:
            message += f" (ì œí•œ {limit:.1f}% ì´ˆê³¼)"
        
        return self.issue(
            message=message,
            severity=WarningSeverity.WARNING,
            category=WarningCategory.RESOURCE,
            resource_type=resource_type,
            usage=usage,
            limit=limit
        )
    
    def get_statistics(self) -> Dict:
        """ê²½ê³  í†µê³„ ì¡°íšŒ"""
        if not self.warning_history:
            return {}
        
        total = len(self.warning_history)
        by_severity = {}
        by_category = {}
        
        for warning in self.warning_history:
            # ì‹¬ê°ë„ë³„ í†µê³„
            severity = warning.severity.name
            by_severity[severity] = by_severity.get(severity, 0) + 1
            
            # ì¹´í…Œê³ ë¦¬ë³„ í†µê³„
            category = warning.category.value
            by_category[category] = by_category.get(category, 0) + 1
        
        return {
            'total_warnings': total,
            'by_severity': by_severity,
            'by_category': by_category,
            'first_warning': self.warning_history[0].context.timestamp.isoformat(),
            'last_warning': self.warning_history[-1].context.timestamp.isoformat()
        }
    
    def clear_history(self):
        """ê²½ê³  ê¸°ë¡ ì´ˆê¸°í™”"""
        self.warning_history.clear()
    
    def generate_report(self, output_file: Optional[str] = None) -> str:
        """ê²½ê³  ë¦¬í¬íŠ¸ ìƒì„±"""
        stats = self.get_statistics()
        
        report_lines = [
            "=" * 60,
            "ê²½ê³  ì‹œìŠ¤í…œ ë¦¬í¬íŠ¸",
            "=" * 60,
            f"ìƒì„± ì‹œê°„: {datetime.now().isoformat()}",
            f"ì´ ê²½ê³  ìˆ˜: {stats.get('total_warnings', 0)}",
            ""
        ]
        
        # ì‹¬ê°ë„ë³„ í†µê³„
        report_lines.append("ì‹¬ê°ë„ë³„ í†µê³„:")
        for severity, count in stats.get('by_severity', {}).items():
            report_lines.append(f"  {severity}: {count}íšŒ")
        
        report_lines.append("")
        
        # ì¹´í…Œê³ ë¦¬ë³„ í†µê³„
        report_lines.append("ì¹´í…Œê³ ë¦¬ë³„ í†µê³„:")
        for category, count in stats.get('by_category', {}).items():
            report_lines.append(f"  {category}: {count}íšŒ")
        
        report_lines.append("")
        report_lines.append("ìµœê·¼ ê²½ê³  10ê±´:")
        report_lines.append("-" * 40)
        
        for warning in self.warning_history[-10:]:
            report_lines.append(warning.format_for_display())
            report_lines.append("")
        
        report = "\n".join(report_lines)
        
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(report)
        
        return report

# ì‚¬ìš© ì˜ˆì œ
def example_warning_usage():
    """ê²½ê³  ì‹œìŠ¤í…œ ì‚¬ìš© ì˜ˆì œ"""
    
    # ê²½ê³  ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    warning_system = AdvancedWarningSystem(
        log_level=WarningSeverity.INFO,
        enable_console=True,
        enable_file_logging=True,
        log_file="app_warnings.log"
    )
    
    # ì»¤ìŠ¤í…€ í•„í„° ë“±ë¡: íŠ¹ì • íŒŒì¼ì˜ ê²½ê³  ë¬´ì‹œ
    def ignore_test_files(warning: StructuredWarning) -> bool:
        return not warning.context.filename.endswith('_test.py')
    
    warning_system.register_filter(ignore_test_files)
    
    # ì»¤ìŠ¤í…€ í•¸ë“¤ëŸ¬ ë“±ë¡: ì¤‘ìš”í•œ ê²½ê³ ëŠ” ì¦‰ì‹œ ì•Œë¦¼
    def critical_warning_handler(warning: StructuredWarning):
        if warning.severity == WarningSeverity.CRITICAL:
            # ì‹¤ì œë¡œëŠ” ì´ë©”ì¼, ìŠ¬ë™ ë“±ìœ¼ë¡œ ì•Œë¦¼
            print(f"ğŸš¨ ì¤‘ìš”: {warning.message}")
    
    warning_system.register_handler(critical_warning_handler)
    
    # ë‹¤ì–‘í•œ ê²½ê³  ë°œí–‰
    warning_system.deprecation_warning(
        old_feature="old_api",
        new_feature="new_api",
        removal_version="2.0.0"
    )
    
    warning_system.performance_warning(
        operation="ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬",
        duration=2.5,
        threshold=1.0
    )
    
    warning_system.resource_warning(
        resource_type="ë©”ëª¨ë¦¬",
        usage=85.5,
        limit=80.0
    )
    
    # ì‚¬ìš©ì ì •ì˜ ê²½ê³ 
    warning_system.issue(
        message="ì‚¬ìš©ì ì…ë ¥ê°’ì´ ê²€ì¦ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤",
        severity=WarningSeverity.ERROR,
        category=WarningCategory.SECURITY,
        user_input="<script>alert('xss')</script>",
        validation_required=True
    )
    
    # ë¦¬í¬íŠ¸ ìƒì„±
    report = warning_system.generate_report("warning_report.txt")
    print(report)
    
    # í†µê³„ í™•ì¸
    stats = warning_system.get_statistics()
    print(f"\nê²½ê³  í†µê³„: {stats}")

# ë°ì½”ë ˆì´í„°ë¥¼ ì´ìš©í•œ ìë™ ì„±ëŠ¥ ê²½ê³ 
def warn_if_slow(threshold: float = 1.0):
    """
    ì‹¤í–‰ ì‹œê°„ì´ ì„ê³„ê°’ì„ ì´ˆê³¼í•˜ë©´ ê²½ê³ í•˜ëŠ” ë°ì½”ë ˆì´í„°
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            import time
            
            start_time = time.time()
            result = func(*args, **kwargs)
            end_time = time.time()
            
            duration = end_time - start_time
            
            if duration > threshold:
                # ê¸€ë¡œë²Œ ê²½ê³  ì‹œìŠ¤í…œ ì‚¬ìš© ë˜ëŠ” ìƒˆë¡œ ìƒì„±
                warning_system = kwargs.get('warning_system') or AdvancedWarningSystem()
                warning_system.performance_warning(
                    operation=f"{func.__module__}.{func.__name__}",
                    duration=duration,
                    threshold=threshold
                )
            
            return result
        return wrapper
    return decorator

# ì‚¬ìš© ì˜ˆì œ
@warn_if_slow(threshold=0.5)
def process_large_data(data_size: int):
    """ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬"""
    import time
    time.sleep(0.7)  # ì˜ë„ì ìœ¼ë¡œ ëŠë¦¬ê²Œ ì‹¤í–‰
    return f"Processed {data_size} records"
```

## í”„ë¡œê·¸ë¨ í¬ë˜ì‹œ ë””ë²„ê¹…ê³¼ ì˜ˆì™¸ ë³µêµ¬

í”„ë¡œê·¸ë¨ ì¶©ëŒì„ ì‚¬ì „ì— ë°©ì§€í•˜ê³ , ë°œìƒí•œ ì¶©ëŒì„ íš¨ê³¼ì ìœ¼ë¡œ ë¶„ì„í•˜ë©°, ì‹œìŠ¤í…œì„ ì•ˆì „í•˜ê²Œ ë³µêµ¬í•˜ëŠ” ê¸°ìˆ ì„ ì‚´í´ë´…ë‹ˆë‹¤.

```python
import sys
import traceback
import logging
import signal
import faulthandler
import threading
from typing import Optional, Callable, Dict, Any, List
from dataclasses import dataclass, field
from datetime import datetime
import os
import gc
import psutil
import json

@dataclass
class CrashReport:
    """ì¶©ëŒ ë¦¬í¬íŠ¸"""
    timestamp: datetime = field(default_factory=datetime.now)
    exception_type: Optional[str] = None
    exception_message: Optional[str] = None
    stack_trace: Optional[str] = None
    thread_info: Optional[str] = None
    memory_info: Optional[Dict] = None
    system_info: Optional[Dict] = None
    application_state: Optional[Dict] = None
    user_context: Optional[Dict] = None
    
    def to_dict(self) -> Dict:
        """ì‚¬ì „ìœ¼ë¡œ ë³€í™˜"""
        return {
            'timestamp': self.timestamp.isoformat(),
            'exception': {
                'type': self.exception_type,
                'message': self.exception_message
            },
            'stack_trace': self.stack_trace,
            'thread_info': self.thread_info,
            'memory_info': self.memory_info,
            'system_info': self.system_info,
            'application_state': self.application_state,
            'user_context': self.user_context
        }
    
    def to_json(self) -> str:
        """JSONìœ¼ë¡œ ë³€í™˜"""
        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)
    
    def save_to_file(self, filename: str):
        """íŒŒì¼ì— ì €ì¥"""
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(self.to_json())

class CrashRecoverySystem:
    """ì¶©ëŒ ë³µêµ¬ ì‹œìŠ¤í…œ"""
    
    def __init__(self, 
                 app_name: str,
                 enable_faulthandler: bool = True,
                 log_dir: str = "crash_reports"):
        """
        Args:
            app_name: ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ë¦„
            enable_faulthandler: faulthandler í™œì„±í™” ì—¬ë¶€
            log_dir: ì¶©ëŒ ë¡œê·¸ ë””ë ‰í„°ë¦¬
        """
        self.app_name = app_name
        self.log_dir = log_dir
        self.crash_handlers: List[Callable] = []
        self.recovery_handlers: List[Callable] = []
        self.last_crash_report: Optional[CrashReport] = None
        
        # ì¶©ëŒ ë¡œê·¸ ë””ë ‰í„°ë¦¬ ìƒì„±
        os.makedirs(log_dir, exist_ok=True)
        
        # ì‹œìŠ¤í…œ ì‹ í˜¸ í•¸ë“¤ëŸ¬ ì„¤ì •
        self.setup_signal_handlers()
        
        # faulthandler ì„¤ì • (ì„¸ê·¸ë¨¼í…Œì´ì…˜ í´íŠ¸ ë“±)
        if enable_faulthandler:
            faulthandler.enable()
        
        # ì „ì—­ ì˜ˆì™¸ í•¸ë“¤ëŸ¬ ì„¤ì •
        sys.excepthook = self.global_exception_handler
        
        # ì“°ë ˆë“œ ì˜ˆì™¸ í•¸ë“¤ëŸ¬ ì„¤ì •
        threading.excepthook = self.thread_exception_handler
    
    def setup_signal_handlers(self):
        """ì‹œìŠ¤í…œ ì‹ í˜¸ í•¸ë“¤ëŸ¬ ì„¤ì •"""
        signal.signal(signal.SIGINT, self.signal_handler)   # Ctrl+C
        signal.signal(signal.SIGTERM, self.signal_handler)  # ì¢…ë£Œ ì‹ í˜¸
        if hasattr(signal, 'SIGUSR1'):
            signal.signal(signal.SIGUSR1, self.signal_handler)  # ì‚¬ìš©ì ì •ì˜ ì‹ í˜¸
    
    def signal_handler(self, signum, frame):
        """ì‹œìŠ¤í…œ ì‹ í˜¸ ì²˜ë¦¬"""
        signal_name = signal.Signals(signum).name
        
        report = CrashReport(
            exception_type="Signal",
            exception_message=f"ì‹œìŠ¤í…œ ì‹ í˜¸ ìˆ˜ì‹ : {signal_name}",
            stack_trace=self._get_stack_trace(frame),
            system_info=self._collect_system_info()
        )
        
        self.handle_crash(report)
        
        # ê¸°ë³¸ ë™ì‘ ìˆ˜í–‰
        if signum == signal.SIGINT:
            print("\nì‚¬ìš©ìì— ì˜í•´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")
            sys.exit(0)
        elif signum == signal.SIGTERM:
            print("\nì¢…ë£Œ ì‹ í˜¸ë¥¼ ìˆ˜ì‹ í–ˆìŠµë‹ˆë‹¤.")
            sys.exit(0)
    
    def global_exception_handler(self, exc_type, exc_value, exc_traceback):
        """ì „ì—­ ì˜ˆì™¸ í•¸ë“¤ëŸ¬"""
        # KeyboardInterruptëŠ” ë³„ë„ ì²˜ë¦¬
        if exc_type == KeyboardInterrupt:
            print("\nì‚¬ìš©ìì— ì˜í•´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")
            sys.exit(0)
        
        # ì¶©ëŒ ë¦¬í¬íŠ¸ ìƒì„±
        report = CrashReport(
            exception_type=exc_type.__name__,
            exception_message=str(exc_value),
            stack_trace="".join(traceback.format_exception(exc_type, exc_value, exc_traceback)),
            thread_info=self._get_thread_info(),
            memory_info=self._get_memory_info(),
            system_info=self._collect_system_info(),
            application_state=self._capture_application_state()
        )
        
        self.handle_crash(report)
        
        # ê¸°ë³¸ ì—ëŸ¬ ì¶œë ¥
        print("\n" + "="*60)
        print("í”„ë¡œê·¸ë¨ì´ ì˜ˆê¸°ì¹˜ ì•Šê²Œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
        print("="*60)
        traceback.print_exception(exc_type, exc_value, exc_traceback)
        
        # ë³µêµ¬ ì‹œë„
        if self.attempt_recovery():
            print("ì‹œìŠ¤í…œì´ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤. ê³„ì† ì‹¤í–‰í•©ë‹ˆë‹¤.")
            return
        
        # ë³µêµ¬ ì‹¤íŒ¨ ì‹œ ì¢…ë£Œ
        sys.exit(1)
    
    def thread_exception_handler(self, args):
        """ìŠ¤ë ˆë“œ ì˜ˆì™¸ í•¸ë“¤ëŸ¬"""
        print(f"\nìŠ¤ë ˆë“œì—ì„œ ì˜ˆì™¸ ë°œìƒ: {args.exc_type.__name__}: {args.exc_value}")
        
        report = CrashReport(
            exception_type=args.exc_type.__name__,
            exception_message=str(args.exc_value),
            stack_trace="".join(traceback.format_exception(args.exc_type, args.exc_value, args.exc_traceback)),
            thread_info=self._get_thread_info(),
            memory_info=self._get_memory_info()
        )
        
        self.handle_crash(report)
    
    def _get_stack_trace(self, frame=None) -> str:
        """í˜„ì¬ ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ì¡°íšŒ"""
        if frame is None:
            frame = sys._getframe()
        
        stack = traceback.extract_stack(frame)
        return "".join(traceback.format_list(stack))
    
    def _get_thread_info(self) -> str:
        """í˜„ì¬ ìŠ¤ë ˆë“œ ì •ë³´ ì¡°íšŒ"""
        threads = []
        for thread in threading.enumerate():
            threads.append(f"{thread.name} (ID: {thread.ident}, Alive: {thread.is_alive()})")
        
        return "\n".join(threads)
    
    def _get_memory_info(self) -> Dict:
        """ë©”ëª¨ë¦¬ ì‚¬ìš© ì •ë³´ ì¡°íšŒ"""
        process = psutil.Process()
        
        return {
            'rss': process.memory_info().rss,  # Resident Set Size
            'vms': process.memory_info().vms,  # Virtual Memory Size
            'percent': process.memory_percent(),
            'available_memory': psutil.virtual_memory().available,
            'total_memory': psutil.virtual_memory().total,
            'gc_stats': gc.get_stats()  # ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ í†µê³„
        }
    
    def _collect_system_info(self) -> Dict:
        """ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘"""
        import platform
        
        return {
            'platform': platform.platform(),
            'python_version': platform.python_version(),
            'processor': platform.processor(),
            'system': platform.system(),
            'node': platform.node(),
            'cpu_count': os.cpu_count(),
            'current_time': datetime.now().isoformat(),
            'working_directory': os.getcwd(),
            'script_path': os.path.abspath(sys.argv[0])
        }
    
    def _capture_application_state(self) -> Dict:
        """ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒíƒœ ìº¡ì²˜"""
        # ì• í”Œë¦¬ì¼€ì´ì…˜ë³„ ìƒíƒœ ìº¡ì²˜ ë¡œì§
        # ì˜ˆ: ì£¼ìš” ë³€ìˆ˜ ê°’, ì„¤ì •, ìºì‹œ ìƒíƒœ ë“±
        return {
            'argv': sys.argv,
            'modules_loaded': list(sys.modules.keys())[:20],  # ìƒìœ„ 20ê°œ ëª¨ë“ˆë§Œ
            'gc_garbage': len(gc.garbage),
            'open_files': self._get_open_files()
        }
    
    def _get_open_files(self) -> List[str]:
        """ì—´ë¦° íŒŒì¼ ëª©ë¡ ì¡°íšŒ"""
        try:
            process = psutil.Process()
            return [f.path for f in process.open_files()]
        except:
            return []
    
    def handle_crash(self, report: CrashReport):
        """ì¶©ëŒ ì²˜ë¦¬"""
        self.last_crash_report = report
        
        # ë¦¬í¬íŠ¸ íŒŒì¼ ì €ì¥
        timestamp = report.timestamp.strftime("%Y%m%d_%H%M%S")
        filename = f"{self.log_dir}/{self.app_name}_crash_{timestamp}.json"
        report.save_to_file(filename)
        
        # ë“±ë¡ëœ í•¸ë“¤ëŸ¬ ì‹¤í–‰
        for handler in self.crash_handlers:
            try:
                handler(report)
            except Exception as e:
                print(f"ì¶©ëŒ í•¸ë“¤ëŸ¬ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}")
        
        # ì½˜ì†”ì— ìš”ì•½ ì¶œë ¥
        print(f"\nğŸ“„ ì¶©ëŒ ë¦¬í¬íŠ¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: {filename}")
        print(f"   ì˜ˆì™¸: {report.exception_type}: {report.exception_message}")
    
    def register_crash_handler(self, handler: Callable[[CrashReport], None]):
        """ì¶©ëŒ í•¸ë“¤ëŸ¬ ë“±ë¡"""
        self.crash_handlers.append(handler)
    
    def register_recovery_handler(self, handler: Callable[[CrashReport], bool]):
        """ë³µêµ¬ í•¸ë“¤ëŸ¬ ë“±ë¡"""
        self.recovery_handlers.append(handler)
    
    def attempt_recovery(self) -> bool:
        """ë³µêµ¬ ì‹œë„"""
        if not self.last_crash_report:
            return False
        
        recovery_successful = True
        
        for handler in self.recovery_handlers:
            try:
                if not handler(self.last_crash_report):
                    recovery_successful = False
            except Exception as e:
                print(f"ë³µêµ¬ í•¸ë“¤ëŸ¬ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}")
                recovery_successful = False
        
        return recovery_successful
    
    def safe_execute(self, func: Callable, *args, **kwargs):
        """
        ì•ˆì „í•œ í•¨ìˆ˜ ì‹¤í–‰
        
        Args:
            func: ì‹¤í–‰í•  í•¨ìˆ˜
            *args: í•¨ìˆ˜ ì¸ìˆ˜
            **kwargs: í•¨ìˆ˜ í‚¤ì›Œë“œ ì¸ìˆ˜
            
        Returns:
            í•¨ìˆ˜ ì‹¤í–‰ ê²°ê³¼ ë˜ëŠ” None (ì‹¤íŒ¨ ì‹œ)
        """
        try:
            return func(*args, **kwargs)
        except Exception as e:
            # ì¶©ëŒ ë¦¬í¬íŠ¸ ìƒì„±
            exc_type, exc_value, exc_traceback = sys.exc_info()
            report = CrashReport(
                exception_type=exc_type.__name__,
                exception_message=str(exc_value),
                stack_trace="".join(traceback.format_exception(exc_type, exc_value, exc_traceback))
            )
            
            self.handle_crash(report)
            return None

# ì‚¬ìš© ì˜ˆì œ: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ë³µêµ¬ í•¸ë“¤ëŸ¬
def create_database_recovery_handler(db_connection):
    """ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ë³µêµ¬ í•¸ë“¤ëŸ¬"""
    def recovery_handler(crash_report: CrashReport) -> bool:
        # ë°ì´í„°ë² ì´ìŠ¤ ê´€ë ¨ ì˜ˆì™¸ì¸ì§€ í™•ì¸
        if 'database' in crash_report.exception_message.lower():
            print("ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ë³µêµ¬ ì‹œë„...")
            try:
                # ì—°ê²° ì¬ì‹œë„
                db_connection.reconnect()
                print("ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì´ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.")
                return True
            except Exception as e:
                print(f"ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ë³µêµ¬ ì‹¤íŒ¨: {e}")
                return False
        return True  # ë°ì´í„°ë² ì´ìŠ¤ ê´€ë ¨ì´ ì•„ë‹ˆë©´ ë³µêµ¬ ì„±ê³µìœ¼ë¡œ ê°„ì£¼
    return recovery_handler

# ì‚¬ìš© ì˜ˆì œ: ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°ì§€
class MemoryLeakDetector:
    """ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°ì§€ê¸°"""
    
    def __init__(self, warning_threshold_mb: float = 100.0):
        self.warning_threshold = warning_threshold_mb * 1024 * 1024  # MB to bytes
        self.initial_memory = psutil.Process().memory_info().rss
        self.peak_memory = self.initial_memory
        self.checkpoints: Dict[str, int] = {}
    
    def checkpoint(self, name: str):
        """ë©”ëª¨ë¦¬ ì‚¬ìš© ì²´í¬í¬ì¸íŠ¸ ì„¤ì •"""
        current = psutil.Process().memory_info().rss
        self.checkpoints[name] = current
        self.peak_memory = max(self.peak_memory, current)
        
        # ê²½ê³  ì²´í¬
        increase = current - self.initial_memory
        if increase > self.warning_threshold:
            print(f"âš ï¸ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°€ëŠ¥ì„±: {name} ì²´í¬í¬ì¸íŠ¸ì—ì„œ "
                  f"{increase/1024/1024:.1f}MB ì¦ê°€")
    
    def report(self):
        """ë©”ëª¨ë¦¬ ì‚¬ìš© ë¦¬í¬íŠ¸"""
        current = psutil.Process().memory_info().rss
        total_increase = current - self.initial_memory
        
        print("\n" + "="*40)
        print("ë©”ëª¨ë¦¬ ì‚¬ìš© ë¦¬í¬íŠ¸")
        print("="*40)
        print(f"ì´ˆê¸° ë©”ëª¨ë¦¬: {self.initial_memory/1024/1024:.1f} MB")
        print(f"í˜„ì¬ ë©”ëª¨ë¦¬: {current/1024/1024:.1f} MB")
        print(f"í”¼í¬ ë©”ëª¨ë¦¬: {self.peak_memory/1024/1024:.1f} MB")
        print(f"ì „ì²´ ì¦ê°€ëŸ‰: {total_increase/1024/1024:.1f} MB")
        print("\nì²´í¬í¬ì¸íŠ¸ë³„ ë©”ëª¨ë¦¬ ì‚¬ìš©:")
        
        for name, mem in self.checkpoints.items():
            increase = mem - self.initial_memory
            print(f"  {name}: {mem/1024/1024:.1f} MB (+{increase/1024/1024:.1f} MB)")

# ì‹¤ì „ ì˜ˆì œ: ì›¹ ì„œë²„ ì¶©ëŒ ë³µêµ¬
class ResilientWebServer:
    """ë³µì›ë ¥ ìˆëŠ” ì›¹ ì„œë²„"""
    
    def __init__(self, host: str = 'localhost', port: int = 8080):
        self.host = host
        self.port = port
        self.is_running = False
        self.crash_system = CrashRecoverySystem("WebServer")
        self.request_count = 0
        
        # ë³µêµ¬ í•¸ë“¤ëŸ¬ ë“±ë¡
        self.crash_system.register_recovery_handler(self._recover_server)
        
        # ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°ì§€ê¸°
        self.memory_detector = MemoryLeakDetector(warning_threshold_mb=50)
    
    def _recover_server(self, crash_report: CrashReport) -> bool:
        """ì„œë²„ ë³µêµ¬ í•¸ë“¤ëŸ¬"""
        print("ì›¹ ì„œë²„ ë³µêµ¬ ì‹œë„ ì¤‘...")
        
        # ì„œë²„ ì¤‘ì§€
        self.is_running = False
        
        # ë¦¬ì†ŒìŠ¤ ì •ë¦¬
        import socket
        try:
            # í¬íŠ¸ í•´ì œ ì‹œë„
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind((self.host, self.port))
            sock.close()
        except:
            pass
        
        # ì„œë²„ ì¬ì‹œì‘
        try:
            self.start()
            print("ì›¹ ì„œë²„ê°€ ì„±ê³µì ìœ¼ë¡œ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.")
            return True
        except Exception as e:
            print(f"ì›¹ ì„œë²„ ë³µêµ¬ ì‹¤íŒ¨: {e}")
            return False
    
    def start(self):
        """ì„œë²„ ì‹œì‘"""
        import http.server
        import socketserver
        
        handler = http.server.SimpleHTTPRequestHandler
        
        with socketserver.TCPServer((self.host, self.port), handler) as httpd:
            self.is_running = True
            print(f"ì„œë²„ ì‹œì‘: http://{self.host}:{self.port}")
            
            # ë©”ëª¨ë¦¬ ì²´í¬í¬ì¸íŠ¸
            self.memory_detector.checkpoint("server_start")
            
            try:
                httpd.serve_forever()
            except KeyboardInterrupt:
                print("\nì„œë²„ ì¢…ë£Œ ì¤‘...")
            except Exception as e:
                # ì¶©ëŒ ì‹œìŠ¤í…œì— ì˜ˆì™¸ ì „ë‹¬
                exc_type, exc_value, exc_traceback = sys.exc_info()
                self.crash_system.global_exception_handler(exc_type, exc_value, exc_traceback)
    
    def handle_request(self, request):
        """ìš”ì²­ ì²˜ë¦¬ (ì•ˆì „í•œ ì‹¤í–‰)"""
        self.request_count += 1
        
        # ë©”ëª¨ë¦¬ ì²´í¬í¬ì¸íŠ¸ (100ë²ˆì§¸ ìš”ì²­ë§ˆë‹¤)
        if self.request_count % 100 == 0:
            self.memory_detector.checkpoint(f"request_{self.request_count}")
        
        # ì•ˆì „í•œ ì‹¤í–‰
        return self.crash_system.safe_execute(self._process_request, request)
    
    def _process_request(self, request):
        """ì‹¤ì œ ìš”ì²­ ì²˜ë¦¬ ë¡œì§"""
        # ì—¬ê¸°ì— ì‹¤ì œ ìš”ì²­ ì²˜ë¦¬ ë¡œì§ êµ¬í˜„
        pass
```

## ê³ ê¸‰ í”„ë¡œíŒŒì¼ë§ê³¼ ì„±ëŠ¥ íƒ€ì´ë°

í”„ë¡œíŒŒì¼ë§ì€ ì„±ëŠ¥ ë³‘ëª© ì§€ì ì„ ì •í™•íˆ ì°¾ì•„ë‚´ê³  ìµœì í™”ì˜ íš¨ê³¼ë¥¼ ì¸¡ì •í•˜ëŠ” í•µì‹¬ ë„êµ¬ì…ë‹ˆë‹¤. ë‹¤ì–‘í•œ í”„ë¡œíŒŒì¼ë§ ê¸°ë²•ì„ ì‚´í´ë´…ë‹ˆë‹¤.

```python
import time
import cProfile
import pstats
import tracemalloc
import line_profiler
import memory_profiler
from typing import Dict, List, Optional, Callable, Any
from dataclasses import dataclass, field
from datetime import datetime, timedelta
import inspect
import statistics
from contextlib import contextmanager
import functools
import sys

@dataclass
class TimingResult:
    """íƒ€ì´ë° ê²°ê³¼"""
    name: str
    total_time: float
    call_count: int
    min_time: float
    max_time: float
    avg_time: float
    std_dev: Optional[float] = None
    percentiles: Dict[float, float] = field(default_factory=dict)
    
    def __str__(self):
        return (f"{self.name}: "
                f"ì´ {self.total_time:.4f}s, "
                f"í‰ê·  {self.avg_time:.6f}s, "
                f"í˜¸ì¶œ {self.call_count}íšŒ")

class PerformanceTimer:
    """ê³ ê¸‰ ì„±ëŠ¥ íƒ€ì´ë¨¸"""
    
    def __init__(self):
        self.timings: Dict[str, List[float]] = {}
        self.current_sections = []
        self.start_times = {}
    
    @contextmanager
    def section(self, name: str):
        """ì½”ë“œ ì„¹ì…˜ íƒ€ì´ë° ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì €"""
        start_time = time.perf_counter()
        self.current_sections.append(name)
        
        try:
            yield
        finally:
            end_time = time.perf_counter()
            duration = end_time - start_time
            
            full_name = ".".join(self.current_sections)
            if full_name not in self.timings:
                self.timings[full_name] = []
            self.timings[full_name].append(duration)
            
            self.current_sections.pop()
    
    def time_function(self, func: Callable):
        """í•¨ìˆ˜ ì‹¤í–‰ ì‹œê°„ ì¸¡ì • ë°ì½”ë ˆì´í„°"""
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            with self.section(func.__name__):
                return func(*args, **kwargs)
        return wrapper
    
    def get_statistics(self) -> Dict[str, TimingResult]:
        """í†µê³„ ê³„ì‚°"""
        results = {}
        
        for name, times in self.timings.items():
            if not times:
                continue
            
            total = sum(times)
            count = len(times)
            min_time = min(times)
            max_time = max(times)
            avg_time = total / count
            
            # í‘œì¤€ í¸ì°¨
            if count > 1:
                variance = sum((t - avg_time) ** 2 for t in times) / (count - 1)
                std_dev = variance ** 0.5
            else:
                std_dev = None
            
            # ë°±ë¶„ìœ„ìˆ˜
            sorted_times = sorted(times)
            percentiles = {
                50: sorted_times[int(count * 0.5)] if count > 0 else 0,
                90: sorted_times[int(count * 0.9)] if count > 0.9 else sorted_times[-1],
                95: sorted_times[int(count * 0.95)] if count > 0.95 else sorted_times[-1],
                99: sorted_times[int(count * 0.99)] if count > 0.99 else sorted_times[-1]
            }
            
            results[name] = TimingResult(
                name=name,
                total_time=total,
                call_count=count,
                min_time=min_time,
                max_time=max_time,
                avg_time=avg_time,
                std_dev=std_dev,
                percentiles=percentiles
            )
        
        return results
    
    def print_report(self, sort_by: str = 'total_time', limit: int = 20):
        """ì„±ëŠ¥ ë¦¬í¬íŠ¸ ì¶œë ¥"""
        results = self.get_statistics()
        
        if not results:
            print("íƒ€ì´ë° ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return
        
        # ì •ë ¬
        if sort_by == 'total_time':
            sorted_results = sorted(results.values(), key=lambda x: x.total_time, reverse=True)
        elif sort_by == 'avg_time':
            sorted_results = sorted(results.values(), key=lambda x: x.avg_time, reverse=True)
        elif sort_by == 'call_count':
            sorted_results = sorted(results.values(), key=lambda x: x.call_count, reverse=True)
        else:
            sorted_results = list(results.values())
        
        # ì¶œë ¥
        print("\n" + "="*80)
        print("ì„±ëŠ¥ íƒ€ì´ë° ë¦¬í¬íŠ¸")
        print("="*80)
        print(f"{'ì„¹ì…˜ ì´ë¦„':<40} {'ì´ì‹œê°„':>10} {'í˜¸ì¶œ':>8} {'í‰ê· ':>10} {'ìµœì†Œ':>10} {'ìµœëŒ€':>10}")
        print("-"*80)
        
        for result in sorted_results[:limit]:
            print(f"{result.name:<40} "
                  f"{result.total_time:>10.4f} "
                  f"{result.call_count:>8} "
                  f"{result.avg_time:>10.6f} "
                  f"{result.min_time:>10.6f} "
                  f"{result.max_time:>10.6f}")
        
        # ìš”ì•½
        total_time = sum(r.total_time for r in results.values())
        total_calls = sum(r.call_count for r in results.values())
        
        print("-"*80)
        print(f"ì´ê³„: {len(results)}ê°œ ì„¹ì…˜, "
              f"{total_time:.4f}ì´ˆ, "
              f"{total_calls}íšŒ í˜¸ì¶œ")
        print("="*80)
    
    def reset(self):
        """íƒ€ì´ë° ë°ì´í„° ì´ˆê¸°í™”"""
        self.timings.clear()
        self.current_sections.clear()
        self.start_times.clear()

class AdvancedProfiler:
    """ê³ ê¸‰ í”„ë¡œíŒŒì¼ëŸ¬"""
    
    def __init__(self):
        self.timer = PerformanceTimer()
        self.memory_snapshots = []
    
    def profile_code(self, code: str, globals_dict: Dict = None):
        """ì½”ë“œ í”„ë¡œíŒŒì¼ë§"""
        if globals_dict is None:
            globals_dict = {}
        
        # cProfile ì‹¤í–‰
        profiler = cProfile.Profile()
        profiler.enable()
        
        start_time = time.perf_counter()
        
        try:
            exec(code, globals_dict)
        except Exception as e:
            print(f"ì½”ë“œ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}")
        
        end_time = time.perf_counter()
        profiler.disable()
        
        # ê²°ê³¼ ë¶„ì„
        print(f"\nì½”ë“œ ì‹¤í–‰ ì‹œê°„: {end_time - start_time:.4f}ì´ˆ")
        
        # í†µê³„ ì¶œë ¥
        stats = pstats.Stats(profiler)
        stats.strip_dirs().sort_stats('cumulative').print_stats(20)
        
        return profiler
    
    def profile_function(self, func: Callable, *args, **kwargs):
        """í•¨ìˆ˜ í”„ë¡œíŒŒì¼ë§"""
        profiler = cProfile.Profile()
        profiler.enable()
        
        result = func(*args, **kwargs)
        
        profiler.disable()
        
        # ê²°ê³¼ ì¶œë ¥
        stats = pstats.Stats(profiler)
        print(f"\n{func.__name__} í•¨ìˆ˜ í”„ë¡œíŒŒì¼ë§ ê²°ê³¼:")
        stats.strip_dirs().sort_stats('time').print_stats(10)
        
        return result, profiler
    
    def memory_profile(self, func: Callable = None, interval: float = 0.1):
        """ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ë§ ë°ì½”ë ˆì´í„°"""
        def decorator(f):
            @functools.wraps(f)
            def wrapper(*args, **kwargs):
                # ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ë§ ì‹¤í–‰
                result = memory_profiler.memory_usage(
                    (f, args, kwargs),
                    interval=interval,
                    include_children=True
                )
                
                print(f"\n{func.__name__} ë©”ëª¨ë¦¬ ì‚¬ìš©:")
                print(f"  ìµœëŒ€ ì‚¬ìš©ëŸ‰: {max(result):.2f} MiB")
                print(f"  ìµœì†Œ ì‚¬ìš©ëŸ‰: {min(result):.2f} MiB")
                print(f"  í‰ê·  ì‚¬ìš©ëŸ‰: {sum(result)/len(result):.2f} MiB")
                
                return result
            return wrapper
        
        if func is None:
            return decorator
        else:
            return decorator(func)
    
    def line_by_line_profile(self, func: Callable):
        """ë¼ì¸ë³„ í”„ë¡œíŒŒì¼ë§"""
        # line_profilerê°€ ì„¤ì¹˜ë˜ì–´ ìˆì–´ì•¼ í•¨
        try:
            profiler = line_profiler.LineProfiler()
            profiler.add_function(func)
            profiler.enable()
            
            result = func()
            
            profiler.disable()
            profiler.print_stats()
            
            return result
        except ImportError:
            print("line_profilerê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„¤ì¹˜: pip install line_profiler")
            return func()
    
    def compare_performance(self, implementations: Dict[str, Callable], 
                           n_iterations: int = 1000, 
                           *args, **kwargs):
        """ë‹¤ì¤‘ êµ¬í˜„ ì„±ëŠ¥ ë¹„êµ"""
        results = {}
        
        print(f"\nì„±ëŠ¥ ë¹„êµ ({n_iterations}íšŒ ë°˜ë³µ)")
        print("="*60)
        
        for name, func in implementations.items():
            times = []
            
            # ì›Œë°ì—…
            for _ in range(10):
                func(*args, **kwargs)
            
            # ì‹¤ì œ ì¸¡ì •
            for _ in range(n_iterations):
                start_time = time.perf_counter()
                func(*args, **kwargs)
                end_time = time.perf_counter()
                times.append(end_time - start_time)
            
            # í†µê³„ ê³„ì‚°
            avg_time = sum(times) / len(times)
            min_time = min(times)
            max_time = max(times)
            
            results[name] = {
                'avg': avg_time,
                'min': min_time,
                'max': max_time,
                'times': times
            }
            
            print(f"{name:<20}: í‰ê·  {avg_time:.6f}s, "
                  f"ìµœì†Œ {min_time:.6f}s, "
                  f"ìµœëŒ€ {max_time:.6f}s")
        
        # ìµœì ì˜ êµ¬í˜„ ì°¾ê¸°
        best = min(results.items(), key=lambda x: x[1]['avg'])
        print(f"\nâœ… ìµœì  êµ¬í˜„: {best[0]} (í‰ê·  {best[1]['avg']:.6f}s)")
        
        return results

# ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ ì˜ˆì œ
def benchmark_examples():
    """ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ ì˜ˆì œ"""
    
    profiler = AdvancedProfiler()
    
    # 1. ë¦¬ìŠ¤íŠ¸ ìƒì„± ë°©ë²• ë¹„êµ
    def list_comprehension():
        return [i*i for i in range(10000)]
    
    def list_append():
        result = []
        for i in range(10000):
            result.append(i*i)
        return result
    
    def list_map():
        return list(map(lambda x: x*x, range(10000)))
    
    implementations = {
        'List Comprehension': list_comprehension,
        'List Append': list_append,
        'Map + Lambda': list_map
    }
    
    profiler.compare_performance(implementations, n_iterations=100)
    
    # 2. ë¬¸ìì—´ ì—°ê²° ë°©ë²• ë¹„êµ
    def string_concatenation():
        result = ""
        for i in range(1000):
            result += str(i)
        return result
    
    def string_join():
        return "".join(str(i) for i in range(1000))
    
    def string_format():
        return "".join(f"{i}" for i in range(1000))
    
    string_impls = {
        'Concatenation (+)': string_concatenation,
        'Join': string_join,
        'F-String + Join': string_format
    }
    
    profiler.compare_performance(string_impls, n_iterations=100)
    
    # 3. ë”•ì…”ë„ˆë¦¬ ì ‘ê·¼ ë°©ë²• ë¹„êµ
    def dict_get():
        d = {i: i*i for i in range(1000)}
        total = 0
        for i in range(1000):
            total += d.get(i, 0)
        return total
    
    def dict_direct():
        d = {i: i*i for i in range(1000)}
        total = 0
        for i in range(1000):
            total += d[i]
        return total
    
    def dict_items():
        d = {i: i*i for i in range(1000)}
        total = 0
        for k, v in d.items():
            total += v
        return total
    
    dict_impls = {
        'dict.get()': dict_get,
        'dict[key]': dict_direct,
        'dict.items()': dict_items
    }
    
    profiler.compare_performance(dict_impls, n_iterations=100)

# ì„±ëŠ¥ ìµœì í™” ë„ìš°ë¯¸ í´ë˜ìŠ¤
class PerformanceOptimizer:
    """ì„±ëŠ¥ ìµœì í™” ë„ìš°ë¯¸"""
    
    @staticmethod
    def optimize_memory_usage(data):
        """ë©”ëª¨ë¦¬ ì‚¬ìš© ìµœì í™”"""
        import array
        import numpy as np
        
        # ë°ì´í„° íƒ€ì…ì— ë”°ë¥¸ ìµœì í™”
        if isinstance(data, list):
            # ìˆ«ì ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš° arrayë¡œ ë³€í™˜
            if all(isinstance(x, (int, float)) for x in data):
                if all(isinstance(x, int) for x in data):
                    return array.array('i', data)  # ì •ìˆ˜ ë°°ì—´
                else:
                    return array.array('f', data)  # ì‹¤ìˆ˜ ë°°ì—´
        
        # í° ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš°
        if isinstance(data, list) and len(data) > 1000:
            # í•„ìš”í•œ ê²½ìš°ë§Œ ì¡°ì¸
            return "".join(data) if all(isinstance(x, str) for x in data) else data
        
        return data
    
    @staticmethod
    def use_local_variables(func):
        """ë¡œì»¬ ë³€ìˆ˜ ì‚¬ìš© ìµœì í™” ë°ì½”ë ˆì´í„°"""
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # ê¸€ë¡œë²Œ ë³€ìˆ˜ë¥¼ ë¡œì»¬ ë³€ìˆ˜ë¡œ ìºì‹±
            import builtins
            import math
            
            # ìì£¼ ì‚¬ìš©í•˜ëŠ” builtinsë¥¼ ë¡œì»¬ ë³€ìˆ˜ë¡œ
            local_len = len
            local_range = range
            local_sum = sum
            local_min = min
            local_max = max
            local_abs = abs
            
            # ìˆ˜í•™ í•¨ìˆ˜
            local_math_sqrt = math.sqrt
            local_math_log = math.log
            local_math_exp = math.exp
            
            return func(*args, **kwargs)
        return wrapper
    
    @staticmethod
    def cache_results(func):
        """ê²°ê³¼ ìºì‹± ë°ì½”ë ˆì´í„° (ë©”ëª¨ì´ì œì´ì…˜)"""
        cache = {}
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # ìºì‹œ í‚¤ ìƒì„±
            key = (args, tuple(sorted(kwargs.items())))
            
            if key not in cache:
                cache[key] = func(*args, **kwargs)
            
            return cache[key]
        
        wrapper.cache_clear = cache.clear
        wrapper.cache_info = lambda: f"ìºì‹œ í¬ê¸°: {len(cache)}"
        
        return wrapper
    
    @staticmethod
    def vectorize_operations(func):
        """ë²¡í„°í™” ì—°ì‚° ë°ì½”ë ˆì´í„°"""
        @functools.wraps(func)
        def wrapper(data):
            # numpyê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ê²½ìš° ë²¡í„°í™”
            try:
                import numpy as np
                if isinstance(data, (list, tuple, np.ndarray)):
                    # numpy ë°°ì—´ë¡œ ë³€í™˜
                    np_data = np.array(data)
                    # ë²¡í„°í™”ëœ ì—°ì‚° ìˆ˜í–‰
                    return np.vectorize(func)(np_data)
            except ImportError:
                pass
            
            # numpy ì—†ìœ¼ë©´ ì¼ë°˜ ë°©ì‹
            return [func(x) for x in data]
        
        return wrapper
```

## í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì†ë„ í–¥ìƒ ê¸°ë²•

íŒŒì´ì¬ í”„ë¡œê·¸ë¨ì˜ ì‹¤í–‰ ì†ë„ë¥¼ ê·¹ëŒ€í™”í•˜ê¸° ìœ„í•œ ë‹¤ì–‘í•œ ê³ ê¸‰ ê¸°ë²•ê³¼ íŒ¨í„´ì„ ì‚´í´ë´…ë‹ˆë‹¤.

```python
import sys
import functools
from typing import Dict, List, Any, Callable, Optional
import time
import dis
import gc
import itertools

class CodeOptimizer:
    """ì½”ë“œ ì‹¤í–‰ ì†ë„ ìµœì í™” í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.optimization_stats = {}
    
    def analyze_bytecode(self, func: Callable):
        """ë°”ì´íŠ¸ì½”ë“œ ë¶„ì„"""
        print(f"\n{func.__name__} í•¨ìˆ˜ ë°”ì´íŠ¸ì½”ë“œ ë¶„ì„:")
        print("="*60)
        dis.dis(func)
        print("="*60)
    
    def apply_optimizations(self, func: Callable) -> Callable:
        """ìµœì í™” ì ìš©"""
        optimized_func = func
        
        # ë°ì½”ë ˆì´í„° ì²´ì¸ìœ¼ë¡œ ìµœì í™” ì ìš©
        optimizations = [
            self._optimize_function_calls,
            self._optimize_loops,
            self._optimize_local_variables,
            self._optimize_builtins,
        ]
        
        for optimization in optimizations:
            optimized_func = optimization(optimized_func)
        
        return optimized_func
    
    def _optimize_function_calls(self, func: Callable) -> Callable:
        """í•¨ìˆ˜ í˜¸ì¶œ ìµœì í™”"""
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # ìì£¼ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜ë¥¼ ë¡œì»¬ ë³€ìˆ˜ë¡œ
            local_print = print
            local_len = len
            local_range = range
            local_sum = sum
            
            # í•¨ìˆ˜ ë³¸ë¬¸ì— ë¡œì»¬ ë³€ìˆ˜ ì£¼ì…
            func.__globals__['_local_print'] = local_print
            func.__globals__['_local_len'] = local_len
            func.__globals__['_local_range'] = local_range
            func.__globals__['_local_sum'] = local_sum
            
            return func(*args, **kwargs)
        return wrapper
    
    def _optimize_loops(self, func: Callable) -> Callable:
        """ë£¨í”„ ìµœì í™”"""
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # í•¨ìˆ˜ ì½”ë“œë¥¼ ë¬¸ìì—´ë¡œ ê°€ì ¸ì™€ì„œ ë£¨í”„ ìµœì í™”
            import inspect
            source = inspect.getsource(func)
            
            # ê°„ë‹¨í•œ ë£¨í”„ ìµœì í™” íŒ¨í„´ (ì‹¤ì œ êµ¬í˜„ì€ ë” ë³µì¡)
            optimized_source = source
            
            # ì˜ˆ: range(len(list)) -> enumerate(list)
            optimized_source = optimized_source.replace(
                'for i in range(len(',
                'for i, _ in enumerate('
            )
            
            # execìœ¼ë¡œ ìµœì í™”ëœ ì½”ë“œ ì‹¤í–‰ (ì‹¤ì œ í”„ë¡œë•ì…˜ì—ì„œëŠ” ì‚¬ìš© ì£¼ì˜)
            # ì—¬ê¸°ì„œëŠ” ê°œë…ë§Œ ë³´ì—¬ì¤Œ
            return func(*args, **kwargs)
        
        return wrapper
    
    def _optimize_local_variables(self, func: Callable) -> Callable:
        """ë¡œì»¬ ë³€ìˆ˜ ìµœì í™”"""
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # ëª¨ë“ˆ ìˆ˜ì¤€ ë³€ìˆ˜ë¥¼ ë¡œì»¬ë¡œ ì´ë™
            import math
            local_sqrt = math.sqrt
            local_pow = math.pow
            local_log = math.log
            
            func.__globals__['_local_sqrt'] = local_sqrt
            func.__globals__['_local_pow'] = local_pow
            func.__globals__['_local_log'] = local_log
            
            return func(*args, **kwargs)
        return wrapper
    
    def _optimize_builtins(self, func: Callable) -> Callable:
        """ë¹ŒíŠ¸ì¸ í•¨ìˆ˜ ìµœì í™”"""
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # dict.get() ëŒ€ì‹  ì§ì ‘ ì ‘ê·¼ (í‚¤ê°€ ì¡´ì¬í•œë‹¤ê³  ê°€ì •í•  ë•Œ)
            # list.append() ìµœì í™” ë“±
            return func(*args, **kwargs)
        return wrapper

class JITOptimizer:
    """JIT(Just-In-Time) ìŠ¤íƒ€ì¼ ìµœì í™”"""
    
    def __init__(self):
        self.compiled_functions = {}
        self.execution_counts = {}
        self.threshold = 10  # JIT ì»´íŒŒì¼ ì„ê³„ê°’
    
    def jit_compile(self, func: Callable) -> Callable:
        """JIT ì»´íŒŒì¼ ë°ì½”ë ˆì´í„°"""
        func_id = id(func)
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # ì‹¤í–‰ íšŸìˆ˜ ì¶”ì 
            self.execution_counts[func_id] = self.execution_counts.get(func_id, 0) + 1
            
            # ì„ê³„ê°’ ë„ë‹¬ ì‹œ "ì»´íŒŒì¼" (ì‹¤ì œë¡œëŠ” ìµœì í™” ì ìš©)
            if self.execution_counts[func_id] == self.threshold:
                print(f"ğŸ”§ {func.__name__} í•¨ìˆ˜ JIT ìµœì í™” ì ìš©")
                optimized = self._apply_jit_optimizations(func)
                self.compiled_functions[func_id] = optimized
            
            # ì»´íŒŒì¼ëœ í•¨ìˆ˜ ì‚¬ìš© ë˜ëŠ” ì›ë³¸ ì‚¬ìš©
            target_func = self.compiled_functions.get(func_id, func)
            
            return target_func(*args, **kwargs)
        
        return wrapper
    
    def _apply_jit_optimizations(self, func: Callable) -> Callable:
        """JIT ìµœì í™” ì ìš©"""
        # ì—¬ê¸°ì— ì‹¤ì œ ìµœì í™” ë¡œì§ êµ¬í˜„
        # ì˜ˆ: íŠ¹ì • íŒ¨í„´ì˜ ë£¨í”„ ìµœì í™”, ì¸ë¼ì¸í™” ë“±
        
        @functools.wraps(func)
        def optimized_wrapper(*args, **kwargs):
            # ìµœì í™”ëœ ë²„ì „
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” funcì˜ ë°”ì´íŠ¸ì½”ë“œë¥¼ ë¶„ì„í•˜ê³  ìˆ˜ì •
            return func(*args, **kwargs)
        
        return optimized_wrapper

# ê³ ê¸‰ ë©”ëª¨ë¦¬ ê´€ë¦¬
class MemoryManager:
    """ê³ ê¸‰ ë©”ëª¨ë¦¬ ê´€ë¦¬ì"""
    
    @staticmethod
    def optimize_memory_allocation():
        """ë©”ëª¨ë¦¬ í• ë‹¹ ìµœì í™”"""
        # ê°ì²´ í’€ë§
        object_pool = {}
        
        def get_cached_object(obj_type, *args):
            """ìºì‹œëœ ê°ì²´ ë°˜í™˜ ë˜ëŠ” ìƒì„±"""
            key = (obj_type, args)
            if key not in object_pool:
                object_pool[key] = obj_type(*args)
            return object_pool[key]
        
        # ìŠ¬ë¡¯ ì‚¬ìš© í´ë˜ìŠ¤ ë°ì½”ë ˆì´í„°
        def use_slots(cls):
            """__slots__ ì‚¬ìš© ë°ì½”ë ˆì´í„°"""
            if not hasattr(cls, '__slots__'):
                cls.__slots__ = tuple(cls.__annotations__.keys())
            return cls
        
        return get_cached_object, use_slots
    
    @staticmethod
    def manual_memory_management():
        """ìˆ˜ë™ ë©”ëª¨ë¦¬ ê´€ë¦¬ ë„êµ¬"""
        import weakref
        
        class ManagedResource:
            """ê´€ë¦¬ë˜ëŠ” ë¦¬ì†ŒìŠ¤"""
            def __init__(self, data):
                self.data = data
                self._finalizer = weakref.finalize(self, self._cleanup)
            
            def _cleanup(self):
                """ë¦¬ì†ŒìŠ¤ ì •ë¦¬"""
                print("ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘...")
                # íŒŒì¼ ë‹«ê¸°, ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì¢…ë£Œ ë“±
            
            def release(self):
                """ë¦¬ì†ŒìŠ¤ ëª…ì‹œì  í•´ì œ"""
                self._finalizer()
        
        return ManagedResource

# ë³‘ë ¬ ì²˜ë¦¬ ìµœì í™”
class ParallelOptimizer:
    """ë³‘ë ¬ ì²˜ë¦¬ ìµœì í™”"""
    
    @staticmethod
    def optimize_with_multiprocessing(func, data, n_processes=None):
        """ë©€í‹°í”„ë¡œì„¸ì‹±ì„ ì´ìš©í•œ ìµœì í™”"""
        import multiprocessing as mp
        
        if n_processes is None:
            n_processes = mp.cpu_count()
        
        # ë°ì´í„° ë¶„í• 
        chunk_size = len(data) // n_processes
        chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
        
        # ë³‘ë ¬ ì²˜ë¦¬
        with mp.Pool(processes=n_processes) as pool:
            results = pool.map(func, chunks)
        
        # ê²°ê³¼ ë³‘í•©
        return list(itertools.chain.from_iterable(results))
    
    @staticmethod  
    def optimize_with_threadpool(func, data, max_workers=None):
        """ìŠ¤ë ˆë“œí’€ì„ ì´ìš©í•œ ìµœì í™” (I/O ë°”ìš´ë“œ ì‘ì—…)"""
        from concurrent.futures import ThreadPoolExecutor
        
        if max_workers is None:
            max_workers = min(32, len(data))
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            results = list(executor.map(func, data))
        
        return results
    
    @staticmethod
    def optimize_with_asyncio(async_func, data):
        """asyncioë¥¼ ì´ìš©í•œ ìµœì í™”"""
        import asyncio
        
        async def process_all():
            tasks = [async_func(item) for item in data]
            return await asyncio.gather(*tasks)
        
        return asyncio.run(process_all())

# ì»´íŒŒì¼ ìµœì í™”
class CompilationOptimizer:
    """ì»´íŒŒì¼ ìµœì í™”"""
    
    @staticmethod
    def compile_to_bytecode(code_str, filename="<string>"):
        """ì½”ë“œë¥¼ ë°”ì´íŠ¸ì½”ë“œë¡œ ì»´íŒŒì¼"""
        import py_compile
        import tempfile
        import os
        
        # ì„ì‹œ íŒŒì¼ì— ì½”ë“œ ì‘ì„±
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(code_str)
            temp_file = f.name
        
        try:
            # ë°”ì´íŠ¸ì½”ë“œ ì»´íŒŒì¼
            import py_compile
            py_compile.compile(temp_file, cfile=temp_file + 'c')
            
            # ì»´íŒŒì¼ëœ ë°”ì´íŠ¸ì½”ë“œ ë¡œë“œ
            import importlib.util
            spec = importlib.util.spec_from_file_location("compiled_module", temp_file + 'c')
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            return module
        finally:
            # ì„ì‹œ íŒŒì¼ ì •ë¦¬
            for f in [temp_file, temp_file + 'c']:
                try:
                    os.unlink(f)
                except:
                    pass

# ì‹¤ì „ ìµœì í™” ì˜ˆì œ
class DataProcessingOptimizer:
    """ë°ì´í„° ì²˜ë¦¬ ìµœì í™”"""
    
    @staticmethod
    def optimize_dataframe_operations():
        """ë°ì´í„°í”„ë ˆì„ ì—°ì‚° ìµœì í™”"""
        import pandas as pd
        import numpy as np
        
        class OptimizedDataFrame:
            def __init__(self, df):
                self.df = df
            
            def vectorized_operation(self, column):
                """ë²¡í„°í™”ëœ ì—°ì‚°"""
                # apply ëŒ€ì‹  ë²¡í„°í™”ëœ ì—°ì‚° ì‚¬ìš©
                return self.df[column] * 2
            
            def batch_processing(self, chunk_size=1000):
                """ë°°ì¹˜ ì²˜ë¦¬"""
                results = []
                for i in range(0, len(self.df), chunk_size):
                    chunk = self.df.iloc[i:i+chunk_size]
                    results.append(self.process_chunk(chunk))
                return pd.concat(results)
            
            def process_chunk(self, chunk):
                """ì²­í¬ ì²˜ë¦¬"""
                # ìµœì í™”ëœ ì²­í¬ ì²˜ë¦¬ ë¡œì§
                return chunk
            
            def use_numpy_where_possible(self):
                """ê°€ëŠ¥í•œ ê²½ìš° numpy ì‚¬ìš©"""
                # pandas ì—°ì‚° ëŒ€ì‹  numpy ì—°ì‚°
                return np.where(self.df['value'] > 0, 1, 0)
        
        return OptimizedDataFrame
    
    @staticmethod
    def optimize_database_queries():
        """ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ìµœì í™”"""
        import sqlite3
        
        class OptimizedDatabase:
            def __init__(self, db_path):
                self.conn = sqlite3.connect(db_path)
                self.conn.row_factory = sqlite3.Row
            
            def batch_insert(self, table, data):
                """ë°°ì¹˜ ì‚½ì…"""
                if not data:
                    return
                
                # ì»¬ëŸ¼ëª… ì¶”ì¶œ
                columns = list(data[0].keys())
                placeholders = ', '.join(['?'] * len(columns))
                columns_str = ', '.join(columns)
                
                # ë°°ì¹˜ ì‚½ì…
                values = [tuple(item[col] for col in columns) for item in data]
                
                sql = f"INSERT INTO {table} ({columns_str}) VALUES ({placeholders})"
                self.conn.executemany(sql, values)
                self.conn.commit()
            
            def optimized_query(self, sql, params=()):
                """ìµœì í™”ëœ ì¿¼ë¦¬ ì‹¤í–‰"""
                # ì¿¼ë¦¬ ê³„íš ë¶„ì„
                explain_sql = f"EXPLAIN QUERY PLAN {sql}"
                cursor = self.conn.cursor()
                cursor.execute(explain_sql, params)
                
                plan = cursor.fetchall()
                print("ì¿¼ë¦¬ ì‹¤í–‰ ê³„íš:")
                for line in plan:
                    print(line)
                
                # ì‹¤ì œ ì¿¼ë¦¬ ì‹¤í–‰
                cursor.execute(sql, params)
                return cursor.fetchall()
            
            def use_indexes(self, table, columns):
                """ì¸ë±ìŠ¤ ì‚¬ìš©"""
                for column in columns:
                    self.conn.execute(f"CREATE INDEX IF NOT EXISTS idx_{table}_{column} ON {table}({column})")
                self.conn.commit()
        
        return OptimizedDatabase

# ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ê³¼ ìë™ ìµœì í™”
class AutoOptimizer:
    """ìë™ ìµœì í™” ì‹œìŠ¤í…œ"""
    
    def __init__(self, target_func):
        self.target_func = target_func
        self.performance_history = []
        self.optimization_strategies = []
    
    def monitor_performance(self, *args, **kwargs):
        """ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§"""
        import time
        
        start_time = time.perf_counter()
        start_memory = self._get_memory_usage()
        
        result = self.target_func(*args, **kwargs)
        
        end_time = time.perf_counter()
        end_memory = self._get_memory_usage()
        
        execution_time = end_time - start_time
        memory_delta = end_memory - start_memory
        
        # ì„±ëŠ¥ ê¸°ë¡
        self.performance_history.append({
            'timestamp': time.time(),
            'execution_time': execution_time,
            'memory_delta': memory_delta,
            'args': str(args),
            'kwargs': str(kwargs)
        })
        
        # ì„±ëŠ¥ ì €í•˜ ê°ì§€
        if len(self.performance_history) > 10:
            recent_times = [h['execution_time'] for h in self.performance_history[-10:]]
            avg_time = sum(recent_times) / len(recent_times)
            
            if execution_time > avg_time * 1.5:  # 50% ì´ìƒ ëŠë ¤ì§€ë©´
                print(f"âš ï¸ ì„±ëŠ¥ ì €í•˜ ê°ì§€: {execution_time:.4f}s (í‰ê· : {avg_time:.4f}s)")
                self._suggest_optimizations()
        
        return result
    
    def _get_memory_usage(self):
        """ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¡°íšŒ"""
        import psutil
        process = psutil.Process()
        return process.memory_info().rss
    
    def _suggest_optimizations(self):
        """ìµœì í™” ì œì•ˆ"""
        print("ğŸ” ìµœì í™” ì œì•ˆ:")
        print("  1. ê²°ê³¼ ìºì‹± ì ìš©")
        print("  2. ë¶ˆí•„ìš”í•œ ê³„ì‚° ì œê±°")
        print("  3. ë°ì´í„° êµ¬ì¡° ìµœì í™”")
        print("  4. ì•Œê³ ë¦¬ì¦˜ ê°œì„ ")
    
    def auto_optimize(self):
        """ìë™ ìµœì í™”"""
        # ì„±ëŠ¥ ê¸°ë¡ ë¶„ì„
        if len(self.performance_history) < 20:
            return self.target_func
        
        # ìµœì í™” ì „ëµ ì„ íƒ
        avg_time = sum(h['execution_time'] for h in self.performance_history) / len(self.performance_history)
        
        if avg_time > 1.0:  # 1ì´ˆ ì´ìƒ ê±¸ë¦¬ëŠ” ê²½ìš°
            print("ğŸ”„ ê²°ê³¼ ìºì‹± ì ìš©")
            return PerformanceOptimizer.cache_results(self.target_func)
        elif avg_time > 0.1:  # 0.1ì´ˆ ì´ìƒ ê±¸ë¦¬ëŠ” ê²½ìš°
            print("ğŸ”„ ë¡œì»¬ ë³€ìˆ˜ ìµœì í™” ì ìš©")
            return PerformanceOptimizer.use_local_variables(self.target_func)
        
        return self.target_func

# í†µí•© ìµœì í™” ì˜ˆì œ
def integrated_optimization_example():
    """í†µí•© ìµœì í™” ì˜ˆì œ"""
    
    # ì›ë³¸ í•¨ìˆ˜
    def process_data(data):
        """ë°ì´í„° ì²˜ë¦¬ í•¨ìˆ˜"""
        result = []
        for item in data:
            # ë³µì¡í•œ ê³„ì‚°
            value = sum(item) * len(item) / max(item) if item else 0
            result.append(value)
        return result
    
    print("ì›ë³¸ í•¨ìˆ˜ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸...")
    data = [list(range(i, i+100)) for i in range(1000)]
    
    import time
    start = time.time()
    process_data(data)
    original_time = time.time() - start
    print(f"ì›ë³¸ ì‹¤í–‰ ì‹œê°„: {original_time:.4f}ì´ˆ")
    
    # ìµœì í™” ì ìš©
    optimizer = CodeOptimizer()
    optimized_func = optimizer.apply_optimizations(process_data)
    
    print("\nìµœì í™”ëœ í•¨ìˆ˜ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸...")
    start = time.time()
    optimized_func(data)
    optimized_time = time.time() - start
    print(f"ìµœì í™” ì‹¤í–‰ ì‹œê°„: {optimized_time:.4f}ì´ˆ")
    
    improvement = (original_time - optimized_time) / original_time * 100
    print(f"\nì„±ëŠ¥ í–¥ìƒ: {improvement:.1f}%")
    
    # ìë™ ìµœì í™”
    auto_opt = AutoOptimizer(process_data)
    for _ in range(15):
        auto_opt.monitor_performance(data)
    
    optimized = auto_opt.auto_optimize()
    
    print("\nìë™ ìµœì í™”ëœ í•¨ìˆ˜ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸...")
    start = time.time()
    optimized(data)
    auto_optimized_time = time.time() - start
    print(f"ìë™ ìµœì í™” ì‹¤í–‰ ì‹œê°„: {auto_optimized_time:.4f}ì´ˆ")
```

## ê²°ë¡ 

### ê²½ê³  ì‹œìŠ¤í…œ êµ¬ì¶•ì˜ ì²´ê³„ì  ì ‘ê·¼ë²•
1. **ê³„ì¸µí™”ëœ ì‹¬ê°ë„ ê´€ë¦¬**: ë””ë²„ê·¸, ì •ë³´, ê²½ê³ , ì˜¤ë¥˜, ì¹˜ëª…ì  ìˆ˜ì¤€ì˜ ê³„ì¸µì  ê²½ê³  ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì—¬ ìƒí™©ì— ë§ëŠ” ëŒ€ì‘ì´ ê°€ëŠ¥í•˜ê²Œ í•˜ì„¸ìš”.
2. **êµ¬ì¡°í™”ëœ ê²½ê³  ì •ë³´**: ë‹¨ìˆœ ë©”ì‹œì§€ë¥¼ ë„˜ì–´ ë°œìƒ ìœ„ì¹˜, ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤, ì»¨í…ìŠ¤íŠ¸ ë°ì´í„°ë¥¼ í¬í•¨í•œ ì™„ì „í•œ ê²½ê³  ê°ì²´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.
3. **ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ê³¼ ë¦¬í¬íŠ¸**: ê²½ê³  ë°œìƒ ì¶”ì´, íŒ¨í„´ ë¶„ì„, í†µê³„ì  ë¦¬í¬íŠ¸ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ìƒì„±í•˜ì—¬ ì‹œìŠ¤í…œ ê±´ê°• ìƒíƒœë¥¼ ì§€ì†ì ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•˜ì„¸ìš”.
4. **ì»¤ìŠ¤í„°ë§ˆì´ì¦ˆ ê°€ëŠ¥í•œ í•¸ë“¤ëŸ¬**: ì´ë©”ì¼ ì•Œë¦¼, ìŠ¬ë™ í†µë³´, ì§€í‘œ ìˆ˜ì§‘ ë“± ë‹¤ì–‘í•œ í•¸ë“¤ëŸ¬ë¥¼ í”ŒëŸ¬ê·¸ì¸ ë°©ì‹ìœ¼ë¡œ ë“±ë¡í•  ìˆ˜ ìˆê²Œ ì„¤ê³„í•˜ì„¸ìš”.

### ì¶©ëŒ ë””ë²„ê¹…ê³¼ ë³µêµ¬ì˜ ì™„ì „í•œ ì „ëµ
1. **ì˜ˆë°©ì  ëª¨ë‹ˆí„°ë§**: ë©”ëª¨ë¦¬ ëˆ„ìˆ˜, ë°ë“œë½, ë¦¬ì†ŒìŠ¤ ê³ ê°ˆ ë“± ì¶©ëŒ ì›ì¸ì„ ì‚¬ì „ì— ê°ì§€í•˜ëŠ” ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”.
2. **ì¶©ëŒ ì»¨í…ìŠ¤íŠ¸ ë³´ì¡´**: ì¶©ëŒ ë°œìƒ ì‹œì ì˜ ì™„ì „í•œ ìƒíƒœ ì •ë³´(ìŠ¤íƒ, ë©”ëª¨ë¦¬, ìŠ¤ë ˆë“œ, ì‹œìŠ¤í…œ ìƒíƒœ)ë¥¼ ìë™ìœ¼ë¡œ ìˆ˜ì§‘í•˜ê³  ì €ì¥í•˜ì„¸ìš”.
3. **ìë™ ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜**: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°, ë„¤íŠ¸ì›Œí¬ ì„¸ì…˜, íŒŒì¼ í•¸ë“¤ ë“± í•µì‹¬ ë¦¬ì†ŒìŠ¤ì˜ ìë™ ì¬ì—°ê²° ë° ë³µêµ¬ ë¡œì§ì„ êµ¬í˜„í•˜ì„¸ìš”.
4. **ì›ê²© ë””ë²„ê¹… ì§€ì›**: ì¶©ëŒ ë¦¬í¬íŠ¸ì˜ ìë™ ì—…ë¡œë“œ, ì›ê²© ìŠ¤íƒ ë¶„ì„, ì‹¤ì‹œê°„ ë””ë²„ê¹… ì„¸ì…˜ ì—°ê²° ê¸°ëŠ¥ì„ ì œê³µí•˜ì„¸ìš”.

### ê³ ê¸‰ í”„ë¡œíŒŒì¼ë§ì˜ ë‹¤ê°ì  ì ‘ê·¼
1. **ë‹¤ì¤‘ í”„ë¡œíŒŒì¼ë§ ë„êµ¬ í™œìš©**: 
   - **cProfile**: í•¨ìˆ˜ í˜¸ì¶œ ë¹ˆë„ì™€ ëˆ„ì  ì‹œê°„ ë¶„ì„
   - **line_profiler**: ë¼ì¸ ë‹¨ìœ„ ì‹¤í–‰ ì‹œê°„ ë¶„ì„
   - **memory_profiler**: ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¶”ì 
   - **tracemalloc**: ë©”ëª¨ë¦¬ í• ë‹¹ ì¶”ì 
2. **ë¹„êµ í”„ë¡œíŒŒì¼ë§**: ì•Œê³ ë¦¬ì¦˜, ë°ì´í„° êµ¬ì¡°, êµ¬í˜„ ë°©ì‹ë³„ ì„±ëŠ¥ ë¹„êµë¥¼ í†µí•´ ìµœì ì˜ ì„ íƒì„ ë„ì¶œí•˜ì„¸ìš”.
3. **ìë™ ë²¤ì¹˜ë§ˆí¬**: ì½”ë“œ ë³€ê²½ ì‹œ ìë™ìœ¼ë¡œ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ê³  íšŒê·€(regression)ë¥¼ ê°ì§€í•˜ì„¸ìš”.
4. **í”„ë¡œë•ì…˜ í”„ë¡œíŒŒì¼ë§**: ì‹¤ì œ ìš´ì˜ í™˜ê²½ì—ì„œì˜ ì„±ëŠ¥ ë°ì´í„° ìˆ˜ì§‘ê³¼ ë¶„ì„ ì¸í”„ë¼ë¥¼ êµ¬ì¶•í•˜ì„¸ìš”.

### ì‹¤í–‰ ì†ë„ í–¥ìƒì˜ ì²´ê³„ì  ìµœì í™”
1. **ì½”ë“œ ìˆ˜ì¤€ ìµœì í™”**:
   - **ë¡œì»¬ ë³€ìˆ˜ ìºì‹±**: ìì£¼ ì ‘ê·¼í•˜ëŠ” ê¸€ë¡œë²Œ ë³€ìˆ˜ì™€ ë¹ŒíŠ¸ì¸ì„ ë¡œì»¬ ë³€ìˆ˜ë¡œ ìºì‹±
   - **ë£¨í”„ ìµœì í™”**: ë¶ˆí•„ìš”í•œ ì—°ì‚° ì œê±°, ë²¡í„°í™”, ì‚¬ì „ ê³„ì‚°
   - **ì•Œê³ ë¦¬ì¦˜ ê°œì„ **: ì‹œê°„ ë³µì¡ë„ ê°œì„ , ì ì ˆí•œ ë°ì´í„° êµ¬ì¡° ì„ íƒ
2. **ë©”ëª¨ë¦¬ ê´€ë¦¬ ìµœì í™”**:
   - **ê°ì²´ í’€ë§**: ë¹ˆë²ˆí•œ ìƒì„±/ì‚­ì œê°€ ë°œìƒí•˜ëŠ” ê°ì²´ì˜ ì¬ì‚¬ìš©
   - **ìŠ¬ë¡¯ ì‚¬ìš©**: ë©”ëª¨ë¦¬ ì ‘ê·¼ ìµœì í™”ë¥¼ ìœ„í•œ `__slots__` í™œìš©
   - **ì œë„ˆë ˆì´í„° í™œìš©**: ëŒ€ìš©ëŸ‰ ë°ì´í„°ì˜ ì§€ì—° í‰ê°€
3. **ë³‘ë ¬ ì²˜ë¦¬ ìµœì í™”**:
   - **CPU ë°”ìš´ë“œ ì‘ì—…**: `multiprocessing`ì„ ì´ìš©í•œ ì§„ì •í•œ ë³‘ë ¬í™”
   - **I/O ë°”ìš´ë“œ ì‘ì—…**: `asyncio`ë‚˜ `ThreadPoolExecutor`ë¥¼ ì´ìš©í•œ ë™ì‹œì„±
   - **ë°ì´í„° ë³‘ë ¬í™”**: í° ë°ì´í„°ë¥¼ ì²­í¬ë¡œ ë‚˜ëˆ„ì–´ ë¶„ì‚° ì²˜ë¦¬
4. **ì»´íŒŒì¼ ìµœì í™”**:
   - **ë°”ì´íŠ¸ì½”ë“œ ì»´íŒŒì¼**: ë°˜ë³µ ì‹¤í–‰ë˜ëŠ” ì½”ë“œì˜ ë°”ì´íŠ¸ì½”ë“œ ìºì‹±
   - **C í™•ì¥ í™œìš©**: ì„±ëŠ¥ì´ ì¤‘ìš”í•œ ë¶€ë¶„ì€ C/C++ í™•ì¥ ëª¨ë“ˆë¡œ êµ¬í˜„
   - **JIT ì»´íŒŒì¼ ê³ ë ¤**: PyPyë‚˜ Numba ê°™ì€ JIT ì»´íŒŒì¼ëŸ¬ ì‚¬ìš© ê²€í† 

### í†µí•© ì„±ëŠ¥ ê´€ë¦¬ í”„ë ˆì„ì›Œí¬
1. **ì„±ëŠ¥ ê¸°ì¤€ ì„¤ì •**: ì• í”Œë¦¬ì¼€ì´ì…˜ë³„ ì„±ëŠ¥ ëª©í‘œ(SLA)ë¥¼ ì„¤ì •í•˜ê³  ëª¨ë‹ˆí„°ë§í•˜ì„¸ìš”.
2. **ìë™ ìµœì í™” ì‹œìŠ¤í…œ**: ì‹¤í–‰ íŒ¨í„´ì„ í•™ìŠµí•˜ì—¬ ìë™ìœ¼ë¡œ ìµœì í™” ì „ëµì„ ì„ íƒí•˜ê³  ì ìš©í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”.
3. **ì„±ëŠ¥ íšŒê·€ í…ŒìŠ¤íŠ¸**: CI/CD íŒŒì´í”„ë¼ì¸ì— ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ë¥¼ í†µí•©í•˜ì—¬ ì„±ëŠ¥ ì €í•˜ë¥¼ ìë™ìœ¼ë¡œ ê°ì§€í•˜ì„¸ìš”.
4. **ìš©ëŸ‰ ê³„íšê³¼ ìŠ¤ì¼€ì¼ë§**: ë¶€í•˜ í…ŒìŠ¤íŠ¸ë¥¼ í†µí•œ ìš©ëŸ‰ ê³„íš ìˆ˜ë¦½ê³¼ ìˆ˜í‰ì  í™•ì¥ ì „ëµì„ ë§ˆë ¨í•˜ì„¸ìš”.

ì´ëŸ¬í•œ ê³ ê¸‰ ê¸°ë²•ë“¤ì„ ì¢…í•©ì ìœ¼ë¡œ ì ìš©í•˜ë©´ íŒŒì´ì¬ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì•ˆì •ì„±, ì„±ëŠ¥, ìœ ì§€ë³´ìˆ˜ì„±ì„ ê·¹ëŒ€í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¨, ìµœì í™”ëŠ” í•­ìƒ í”„ë¡œíŒŒì¼ë§ ë°ì´í„°ì— ê¸°ë°˜í•´ì•¼ í•˜ë©°, ì§€ë‚˜ì¹œ ìµœì í™”ëŠ” ì½”ë“œì˜ ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ í•´ì¹  ìˆ˜ ìˆìŒì„ ëª…ì‹¬í•˜ì„¸ìš”. ì ì ˆí•œ ê· í˜•ì„ ìœ ì§€í•˜ë©´ì„œ ì ì§„ì ìœ¼ë¡œ ê°œì„ í•´ ë‚˜ê°€ëŠ” ì ‘ê·¼ì´ ê°€ì¥ íš¨ê³¼ì ì…ë‹ˆë‹¤.