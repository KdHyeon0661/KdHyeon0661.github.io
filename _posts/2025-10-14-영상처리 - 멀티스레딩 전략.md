---
layout: post
title: 영상처리 - 멀티스레딩 전략
date: 2025-10-14 20:25:23 +0900
category: 영상처리
---
# 3) **멀티스레딩 전략**: 프레임/파일 단위 병렬 인코딩  
> *(한 `cinfo`/`tjhandle`는 **단일 스레드 전용**, 스레드별 **독립 인스턴스**를 재사용하라)*

- **핵심 아이디어**  
  - **프레임(파일) 단위 병렬화**: 각 스레드가 서로 다른 이미지(또는 비디오 프레임)를 담당.  
  - **한 인코더 핸들 = 한 스레드**: `jpeglib`의 `jpeg_compress_struct`/`jpeg_decompress_struct`(= `cinfo`)와 TurboJPEG의 `tjhandle`은 **동시 공유 금지**. 스레드마다 **자기 것**을 만들고 **재사용**.  
  - **파이프라인 or 풀 병렬**: I/O, 전처리, 인코딩을 **스테이지 분리**(파이프라인)하거나 **단일 워커 풀**로 묶기.  
  - **백프레셔**: **유한 큐**(bounded queue)로 메모리 폭주 방지.  
  - **에러 격리**: 스레드 로컬에서 에러 처리(setjmp/longjmp 또는 TurboJPEG 에러 문자열) 후, 메인에 결과/로그 전달.

---

## 0) 왜 프레임/파일 단위 병렬화인가?

- libjpeg(-turbo)는 내부에서 **SIMD**(AVX2/NEON 등)로 **타일 수준 최적화**는 해주지만, **한 이미지 내부를 다중 스레드로 나누어 인코드**하는 API는 제공하지 않음.  
- 대신 **여러 이미지**(또는 **영상 프레임**)를 **각기 다른 스레드**에서 처리하면 **선형에 가까운 스케일링**을 얻기 쉽다.

> **스케일링 직관(아름달의 법칙/Amdahl’s Law)**  
> 전체 작업 중 병렬 가능한 비율을 \(p\), 스레드 수를 \(N\)이라 할 때, 이론상 속도 향상은
> \[
> S(N) = \frac{1}{(1-p) + \frac{p}{N}}
> \]
> JPEG 일괄 인코딩처럼 각 파일이 독립이면 \(p \approx 0.95\) 이상인 경우가 흔해, **CPU 코어 수에 비교적 비례**하여 향상.

---

## 1) 아키텍처 선택지

### 1.1 단일 워커 풀(권장 기본)
- **구성**: Producer(작업 생성) → **Worker Pool**(N개 스레드) → Consumer(저장/집계)  
- **장점**: 구현 단순, 스레드 수만 조절하면 대부분 워크로드에 적합.

### 1.2 스테이지 파이프라인
- **구성**: [I/O] → [디코드] → [처리] → [인코드] → [저장]  
- 각 스테이지마다 **전용 스레드 풀과 큐**를 둬 **단계별 병목**을 분산.  
- 대용량 I/O(네트워크·NAS), 무거운 전처리(리사이즈·필터) 혼재 시 이점.

> 둘 모두 **스레드별 인코더 인스턴스 재사용**이 공통 핵심.

---

## 2) 스레드 안전 원칙(필수)

- **libjpeg(jpeglib)**  
  - 스레드마다 **자기 `jpeg_compress_struct`** / **`jpeg_decompress_struct`**를 만들 것.  
  - **공유 금지**: 하나의 `cinfo`를 여러 스레드가 동시에 호출하면 **UB**(정의되지 않은 동작).  
  - **메모리 소스/대상**(`jpeg_mem_src/dest`) 버퍼도 **스레드 로컬**.

- **TurboJPEG**  
  - `tjhandle`은 **스레드 안전하지 않음** → **스레드마다** `tjInitCompress`/`tjInitDecompress`로 생성하고, 워커 스레드 **수명 동안 재사용**(job 간 재사용 OK, **동시 공유 X**).

- **공유 데이터**  
  - 컬러 변환 테이블, ICC/EXIF 템플릿 등 **읽기 전용**은 공유 가능하지만, **쓰기 있는 객체**는 락 또는 스레드 로컬 복제.

---

## 3) 실전 패턴 — **워커 풀 + 유한 큐**

아래 예제는 **TurboJPEG** 경로로 **BGRA → JPEG** 일괄 인코더를 구현합니다. (jpeglib 예제는 뒤 6장)

### 3.1 Job 정의 & 결과 구조

```cpp
#include <string>
#include <vector>
#include <optional>

struct EncodePreset {
    int subsamp;   // TJSAMP_420 (사진), TJSAMP_444 (UI)
    int quality;   // 1..100
    int flags;     // TJFLAG_*
};

struct EncodeJob {
    std::wstring inPath;      // 입력 이미지 경로(JPEG/PNG 등)
    std::wstring outPath;     // 출력 JPEG 경로
    EncodePreset preset;      // 프리셋(앞 절의 4:2:0/4:4:4 등)
    int maxThumb = 0;         // 디코드 스케일(0=원본, 256=긴변 256 등)
};

struct EncodeResult {
    std::wstring inPath;
    std::wstring outPath;
    bool ok = false;
    std::string message;
    size_t outBytes = 0;
    double msDecode = 0.0;
    double msProcess = 0.0;
    double msEncode = 0.0;
};
```

### 3.2 유한 큐(멀티 프로듀서·멀티 컨슈머)

```cpp
#include <mutex>
#include <condition_variable>
#include <queue>

template<typename T>
class BoundedQueue {
public:
    explicit BoundedQueue(size_t cap): cap_(cap) {}
    void close(){ 
        std::lock_guard<std::mutex> lk(m_); 
        closed_ = true; 
        cvP_.notify_all(); 
        cvC_.notify_all(); 
    }
    bool push(T v){
        std::unique_lock<std::mutex> lk(m_);
        cvP_.wait(lk, [&]{ return q_.size()<cap_ || closed_; });
        if (closed_) return false;
        q_.push(std::move(v));
        cvC_.notify_one();
        return true;
    }
    bool pop(T& out){
        std::unique_lock<std::mutex> lk(m_);
        cvC_.wait(lk, [&]{ return !q_.empty() || closed_; });
        if (q_.empty()) return false;
        out = std::move(q_.front()); q_.pop();
        cvP_.notify_one();
        return true;
    }
private:
    size_t cap_;
    std::mutex m_;
    std::condition_variable cvP_, cvC_;
    std::queue<T> q_;
    bool closed_=false;
};
```

### 3.3 TurboJPEG 워커(스레드 로컬 핸들 재사용)

```cpp
#include <turbojpeg.h>
#include <thread>
#include <atomic>
#include <chrono>
#include "IppDib.h"

// 디코드(TurboJPEG) → IppDib(BGRA)
bool TJ_Decode_BGRA(const std::wstring& path, int maxThumb, IppDib& out, std::string& err);

// 인코드(TurboJPEG) ← IppDib(BGRA)
bool TJ_Encode_BGRA(const IppDib& img, const EncodePreset& p,
                    std::vector<unsigned char>& outJpg, std::string& err);

class TJWorker {
public:
    TJWorker(BoundedQueue<EncodeJob>& in, BoundedQueue<EncodeResult>& out)
        : inQ_(in), outQ_(out) {}

    void operator()(){
        // 스레드 로컬: 필요 시 여기서 핸들/버퍼 등을 캐시. (간단성을 위해 TJ_* 함수 내부에 핸들 생성/파괴)
        EncodeJob job;
        while (inQ_.pop(job)){
            EncodeResult R; R.inPath=job.inPath; R.outPath=job.outPath;
            auto t0 = Clock::now();

            IppDib dib;
            std::string err;
            {
                auto d0=Clock::now();
                if (!TJ_Decode_BGRA(job.inPath, job.maxThumb, dib, err)){
                    R.ok=false; R.message="decode: "+err; outQ_.push(std::move(R)); continue;
                }
                R.msDecode = ms(Clock::now()-d0);
            }

            // (선택) 처리 단계(리사이즈/필터 등)
            {
                auto p0=Clock::now();
                // ex) no-op, 혹은 dib = ResizeBilinear(dib, ...);
                R.msProcess = ms(Clock::now()-p0);
            }

            std::vector<unsigned char> jpg;
            {
                auto e0=Clock::now();
                if (!TJ_Encode_BGRA(dib, job.preset, jpg, err)){
                    R.ok=false; R.message="encode: "+err; outQ_.push(std::move(R)); continue;
                }
                R.msEncode = ms(Clock::now()-e0);
            }

            // 저장
            if (FILE* fp=nullptr; _wfopen_s(&fp, job.outPath.c_str(), L"wb")==0) {
                fwrite(jpg.data(),1,jpg.size(),fp); fclose(fp);
                R.ok=true; R.outBytes=jpg.size();
            } else {
                R.ok=false; R.message="save failed";
            }

            outQ_.push(std::move(R));
        }
    }
private:
    using Clock = std::chrono::high_resolution_clock;
    static double ms(std::chrono::high_resolution_clock::duration d){
        return std::chrono::duration_cast<std::chrono::duration<double, std::milli>>(d).count();
    }
    BoundedQueue<EncodeJob>& inQ_;
    BoundedQueue<EncodeResult>& outQ_;
};
```

> **팁**: 위 예제는 매 Job마다 `tjInitCompress`/`tjDestroy`를 내부에서 호출해도 되지만, **성능 최적화**를 위해 워커 생성 시점에 `tjhandle`을 만들고 **반복 재사용**하도록 바꾸면 더 좋습니다(“핸들 캐시”).  
> 단, 핸들은 **이 워커 스레드에서만** 사용하세요.

### 3.4 풀 실행기

```cpp
#include <filesystem>
#include <iostream>

int wmain(int argc, wchar_t** argv){
    if (argc<3){
        std::wcout<<L"usage: mtjpeg <inputDir> <outputDir>\n"; return 0;
    }
    std::filesystem::path inDir = argv[1], outDir = argv[2];
    std::filesystem::create_directories(outDir);

    // 1) 작업 생성
    BoundedQueue<EncodeJob>    inQ(64);   // 큐 용량(백프레셔)
    BoundedQueue<EncodeResult> outQ(64);

    // 2) 워커 수
    unsigned threads = std::max(1u, std::thread::hardware_concurrency());
    std::vector<std::thread> pool; pool.reserve(threads);
    for (unsigned i=0;i<threads;i++)
        pool.emplace_back(TJWorker(inQ, outQ));

    // 3) Producer: 입력 디렉터리 순회
    EncodePreset photo420{ /*subsamp*/TJSAMP_420, /*Q*/90, /*flags*/ TJFLAG_FASTDCT|TJFLAG_OPTIMIZE_CODING|TJFLAG_PROGRESSIVE };
    for (auto& p : std::filesystem::directory_iterator(inDir)){
        if (!p.is_regular_file()) continue;
        auto ext = p.path().extension().wstring();
        std::transform(ext.begin(), ext.end(), ext.begin(), ::towlower);
        if (ext==L".jpg" || ext==L".jpeg" || ext==L".png" || ext==L".bmp"){
            EncodeJob j;
            j.inPath  = p.path().wstring();
            j.outPath = (outDir / (p.path().stem().wstring() + L"_q90_420.jpg")).wstring();
            j.preset  = photo420;
            j.maxThumb= 0; // 원본 해상도 디코드
            inQ.push(std::move(j));
        }
    }

    // 4) Producer 종료
    inQ.close();

    // 5) 결과 소비(리포트)
    size_t done=0, ok=0, bytes=0;
    EncodeResult R;
    while (true){
        if (!outQ.pop(R)){
            // 워커들도 모두 종료됐는지 확인
            bool allJoined=true;
            for (auto& t: pool) if (t.joinable()) { allJoined=false; break; }
            if (allJoined) break;
            std::this_thread::sleep_for(std::chrono::milliseconds(5));
            continue;
        }
        done++;
        if (R.ok){ ok++; bytes+=R.outBytes; }
        std::wcout<<(R.ok?L"[OK] ":L"[NG] ")<<R.inPath<<L" -> "<<R.outPath
                    <<L" ("<<R.msDecode+R.msProcess+R.msEncode<<L" ms)\n";
    }

    // 6) 조인
    for (auto& t: pool) if (t.joinable()) t.join();
    std::wcout<<L"done="<<done<<L" ok="<<ok<<L" bytes="<<bytes<<L"\n";
    return 0;
}
```

---

## 4) TurboJPEG 보조 함수(디코드/인코드)

> 실제 프로젝트에서 이미 앞 파트에 구현한 것들을 재사용해도 됩니다. 여기서는 **스레드 로컬 핸들 캐시 없이** 간단 버전으로 제시합니다.

```cpp
#include <turbojpeg.h>

bool TJ_Decode_BGRA(const std::wstring& path, int maxThumb, IppDib& out, std::string& err){
    err.clear(); out.destroy();

    // 파일 → 메모리
    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"rb");
    if(!fp){ err="open failed"; return false; }
    fseek(fp, 0, SEEK_END); long sz = ftell(fp); fseek(fp, 0, SEEK_SET);
    if (sz<=0){ fclose(fp); err="empty"; return false; }
    std::vector<unsigned char> bytes(sz);
    if (fread(bytes.data(),1,bytes.size(),fp)!=(size_t)sz){ fclose(fp); err="read"; return false; }
    fclose(fp);

    tjhandle td = tjInitDecompress();
    if (!td){ err="tjInitDecompress"; return false; }

    int w=0,h=0,subsamp=0,cs=0;
    if (tjDecompressHeader3(td, bytes.data(), (unsigned long)bytes.size(), &w,&h,&subsamp,&cs)!=0){
        err = tjGetErrorStr2(td); tjDestroy(td); return false;
    }

    int outW=w, outH=h;
    if (maxThumb>0){
        int ns=0; tjscalingfactor* sfs = tjGetScalingFactors(&ns);
        double best=0.0; for (int i=0;i<ns;++i){
            int sw=TJSCALED(w,sfs[i]), sh=TJSCALED(h,sfs[i]);
            int longer=std::max(sw,sh);
            if (longer<=maxThumb){
                double sc=(double)sw/w; if (sc>best){ best=sc; outW=sw; outH=sh; }
            }
        }
    }

    if (!out.create(outW,outH,32)){ tjDestroy(td); err="alloc"; return false; }
    int flags = TJFLAG_FASTUPSAMPLE | TJFLAG_LIMITSCANS | TJFLAG_FASTDCT;
    if (tjDecompress2(td, bytes.data(), (unsigned long)bytes.size(),
                      (unsigned char*)out.bits(), outW, out.stride(), outH,
                      TJPF_BGRA, flags)!=0){
        err=tjGetErrorStr2(td); tjDestroy(td); out.destroy(); return false;
    }
    tjDestroy(td);
    return true;
}

bool TJ_Encode_BGRA(const IppDib& img, const EncodePreset& p,
                    std::vector<unsigned char>& outJpg, std::string& err){
    err.clear(); outJpg.clear();
    if (!img){ err="no image"; return false; }
    tjhandle tc = tjInitCompress();
    if (!tc){ err="tjInitCompress"; return false; }

    unsigned char* buf=nullptr; unsigned long len=0;
    if (tjCompress2(tc, (unsigned char*)img.bits(), img.width(), img.stride(), img.height(),
                    TJPF_BGRA, &buf, &len,
                    p.subsamp, p.quality, p.flags)!=0){
        err=tjGetErrorStr2(tc); tjDestroy(tc); return false;
    }
    outJpg.assign(buf, buf+len);
    tjFree(buf); tjDestroy(tc);
    return true;
}
```

---

## 5) 성능 최적화 팁

1. **핸들 재사용**:  
   - TurboJPEG: 워커 생성 시 `tjInitCompress`/`tjInitDecompress`를 1회만 만들고, **루프에서 재사용** → 생성/파괴 비용 절감.  
   - jpeglib: `jpeg_create_compress/decompress`도 스레드 시작 시점 1회만 호출하고, 잡마다 `jpeg_*_dest/src`와 `jpeg_start_*`/`jpeg_finish_*`만 반복.

2. **유한 큐**: 32~256 사이로 시작, 메모리/속도 트레이드오프를 측정해 결정.

3. **I/O 비동기화**:  
   - 디코드/인코드 스레드와 별도로 **저장 스레드**(싱글)로 파일 쓰기 직렬화(디스크 시킹 감소).

4. **메모리 풀**:  
   - 빈번한 `IppDib.create/free` 대신 **고정 크기 버퍼 풀**. 해상도가 다양한 경우, **최대 해상도**로 잡고 내부에 `view` 개념 사용.

5. **NUMA/Pinning(고급)**:  
   - 워커를 NUMA 노드별로 분할, 소켓 간 메모리 이동 최소화.

---

## 6) jpeglib 멀티스레드 워커(에러 복구 포함)

- 스레드마다 **자기 `jpeg_compress_struct`/`jpeg_decompress_struct`**를 보유.  
- **에러 핸들러**는 스레드 로컬 `setjmp/longjmp`로.

```cpp
#include <jpeglib.h>
#include <setjmp.h>

struct JpegThreadErr {
    jpeg_error_mgr pub;
    jmp_buf jmp;
    char msg[JMSG_LENGTH_MAX]{};
};
static void onErrorExit(j_common_ptr c){
    auto* e = (JpegThreadErr*)c->err;
    (*c->err->format_message)(c, e->msg);
    longjmp(e->jmp, 1);
}

class JpegWorker {
public:
    JpegWorker(BoundedQueue<EncodeJob>& in, BoundedQueue<EncodeResult>& out)
        : inQ_(in), outQ_(out)
    {
        // (선택) 스레드 수명 동안 재사용할 cinfo 준비 가능
    }

    void operator()(){
        EncodeJob job;
        while (inQ_.pop(job)){
            EncodeResult R; R.inPath=job.inPath; R.outPath=job.outPath;

            // 1) 입력 디코드(jpeglib or TurboJPEG) — 여기선 TurboJPEG 재사용 가능
            IppDib dib; std::string err;
            if (!TJ_Decode_BGRA(job.inPath, job.maxThumb, dib, err)){
                R.ok=false; R.message="decode: "+err; outQ_.push(std::move(R)); continue;
            }

            // 2) 인코드(jpeglib) 예시
            std::vector<uint8_t> jpg;
            if (!encodeJpeg_Jpeglib(dib, job.preset, jpg, err)){
                R.ok=false; R.message="encode: "+err; outQ_.push(std::move(R)); continue;
            }

            if (FILE* fp=nullptr; _wfopen_s(&fp, job.outPath.c_str(), L"wb")==0){
                fwrite(jpg.data(),1,jpg.size(),fp); fclose(fp);
                R.ok=true; R.outBytes=jpg.size();
            } else {
                R.ok=false; R.message="save failed";
            }
            outQ_.push(std::move(R));
        }
    }

private:
    static bool encodeJpeg_Jpeglib(const IppDib& img, const EncodePreset& p,
                                   std::vector<uint8_t>& outJpg, std::string& err)
    {
        err.clear(); outJpg.clear();
        jpeg_compress_struct c{};
        JpegThreadErr e{};
        c.err = jpeg_std_error(&e.pub);
        e.pub.error_exit = onErrorExit;
        jpeg_create_compress(&c);

        if (setjmp(e.jmp)){
            jpeg_destroy_compress(&c);
            err = e.msg; return false;
        }

        unsigned char* mem=nullptr; unsigned long memSize=0;
        jpeg_mem_dest(&c, &mem, &memSize);

        c.image_width  = img.width();
        c.image_height = img.height();
#ifdef JCS_EXTENSIONS
        c.in_color_space = JCS_EXT_BGRA; c.input_components = 4;
#else
        c.in_color_space = JCS_RGB;      c.input_components = 3;
#endif
        jpeg_set_defaults(&c);
        // 서브샘플링
        setChromaSampling(c, p.subsamp); // 구현: comp_info[].h/v_samp_factor 조정
        // 품질·허프만 최적화
        jpeg_set_quality(&c, p.quality, TRUE);
        c.optimize_coding = (p.flags & TJFLAG_OPTIMIZE_CODING) != 0;
        // (선택) 진행형/Restart 등 추가 설정
        if (p.flags & TJFLAG_PROGRESSIVE) jpeg_simple_progression(&c);

        jpeg_start_compress(&c, TRUE);

        while (c.next_scanline < c.image_height){
            const uint8_t* s = (const uint8_t*)img.bits() + (size_t)c.next_scanline * img.stride();
#ifdef JCS_EXTENSIONS
            JSAMPROW rp = (JSAMPROW)s;
#else
            static thread_local std::vector<uint8_t> row;
            row.resize(img.width()*3);
            for (int x=0;x<img.width();++x){
                row[x*3+0]=s[x*4+2]; row[x*3+1]=s[x*4+1]; row[x*3+2]=s[x*4+0];
            }
            JSAMPROW rp = row.data();
#endif
            jpeg_write_scanlines(&c, &rp, 1);
        }

        jpeg_finish_compress(&c);
        outJpg.assign(mem, mem+memSize);
        free(mem);

        jpeg_destroy_compress(&c);
        return true;
    }

    static void setChromaSampling(jpeg_compress_struct& c, int subsamp){
        // 간단 매핑: 420/444만 예시
        // Y(0), Cb(1), Cr(2)
        c.comp_info[0].h_samp_factor = (subsamp==TJSAMP_420)? 2:1;
        c.comp_info[0].v_samp_factor = (subsamp==TJSAMP_420)? 2:1;
        for (int i=1;i<c.num_components; ++i){
            c.comp_info[i].h_samp_factor = 1;
            c.comp_info[i].v_samp_factor = 1;
        }
    }

    BoundedQueue<EncodeJob>& inQ_;
    BoundedQueue<EncodeResult>& outQ_;
};
```

**요점 요약**
- 각 스레드에서 **자신의 `jpeg_*_compress` 객체**를 만들고 파괴(**동시 공유 X**).  
- `setjmp/longjmp`를 **스레드 로컬**로 두어 에러를 안전 복구.  
- RGB 변환 임시 버퍼는 `thread_local`로 재사용 → 할당·해제 비용 감소.

---

## 7) 상황별 전략

### 7.1 대량 폴더 일괄 변환
- **워커 수 = 물리 코어 수** 권장(하이퍼스레딩 고려해 +1~+2 실험).  
- I/O가 느리면 **프리페치 스레드** 추가: 파일을 읽어 **메모리 바이트**를 큐에 넣고, 워커는 메모리에서 바로 디코드.

### 7.2 비디오(프레임) 인코딩
- 디코더(FFmpeg 등)에서 프레임을 **BGRA**로 꺼내 **프레임 번호**와 함께 Job으로 투입.  
- 결과 JPEG는 **프레임 순서 유지**가 필요하면 **순서 큐**(오더링 버퍼) 사용.

```cpp
// 간단 오더링 버퍼 아이디어
std::atomic<uint64_t> nextToWrite{0};
std::map<uint64_t, EncodeResult> pending;
std::mutex pm; 
// 각 결과 R에 frameIdx가 있다 가정
if (R.frameIdx == nextToWrite){
    write(R); nextToWrite++;
    std::lock_guard lk(pm);
    while (auto it=pending.find(nextToWrite); it!=pending.end()){
        write(it->second); pending.erase(it); nextToWrite++;
    }
} else {
    std::lock_guard lk(pm); pending.emplace(R.frameIdx, std::move(R));
}
```

### 7.3 UI/문서와 사진 혼재
- **자동 분류**(앞 절) 후 프리셋 분기(444 vs 420).  
- 워커 측에서 분기에 따라 `EncodePreset` 선택만 달리하면 됨.

---

## 8) 흔한 함정과 대처

- **같은 `tjhandle`/`cinfo`를 두 스레드에서 동시 사용** → **데이터 레이스/크래시**.  
  → 스레드마다 **독립 핸들**을 만들고, **그 스레드에서만** 사용.

- **무제한 큐** → 메모리 고갈.  
  → **bounded queue**와 **백프레셔** 사용.

- **쓰레기 수집 없는 C++에서 누수**  
  → `IppDib`/버퍼에 **명확한 소유권**과 **RAII** 적용. `thread_local` 버퍼 재사용.

- **EXIF/ICC 메타 병합**  
  → 메타 조작은 보통 **jpeglib 경로**에서 처리. TurboJPEG 인코딩 결과에 **재주입**(APP 마커)하려면 워커에서 jpeglib 루틴을 **추가로** 호출.

- **Huge Page/NUMA**  
  → 초대형 이미지/프레임 처리 시 NUMA 분리와 소켓 로컬 할당이 성능에 의미. 우선순위는 낮음.

---

## 9) 성능 측정 체크리스트

- [ ] **스레드 수 스윕**: 1, 2, 4, 8, 16… 처리 시간(ms) vs CPU 사용률.  
- [ ] **핸들 재사용** 전/후: 초당 프레임, 평균/최대 지연.  
- [ ] **큐 용량**: 16/32/64/128… 메모리 peak/스루풋.  
- [ ] **I/O 병목**: SSD vs NAS; 프리페치 스레드의 효과.  
- [ ] **프리셋 차이**: 420/Q=90 vs 444/Q=92의 시간/용량 비교.

---

## 10) 수식으로 보는 병렬 이득(참고)

- 이상적인 병렬 구간 비율 \(p\)와 스레드 수 \(N\)일 때 속도 향상:
\[
S(N)=\frac{1}{(1-p)+\frac{p}{N}},\quad 
\text{Throughput}\approx \frac{N}{(1-p)N+p}\times \text{Throughput}_\text{single}
\]
- I/O 비중이 크면 \(p\)가 줄어들므로, **프리페치/쓰기 직렬화 최적화**가 병렬 이득을 키운다.

---

## 11) 결론

- **정석**: “**프레임/파일 단위 병렬화** + **스레드별 인코더 인스턴스 재사용** + **유한 큐**”.  
- **TurboJPEG**은 BGRA 직결/고속으로 워커 구현이 간결하고,  
- **jpeglib**은 메타/Restart/세세 제어가 필요할 때 병행.  
- 이 패턴은 폴더 일괄 변환, 썸네일 파이프라인, MJPEG 프레임 덤프 등 **대부분의 실무 시나리오**에서 **가장 높은 ROI**를 제공합니다.

> 원하시면 위 코드를 **ImageTool** 메뉴 “멀티스레드 배치 변환…”으로 묶어  
> 스레드 수/큐 용량/프리셋/스케일/Restart/허프만 최적화까지 한 번에 제어하는 **대화상자**를 설계해 드릴게요.

--- 

### 부록 A. 간단한 워커별 핸들 캐시(TurboJPEG) 스케치

```cpp
class TJWorkerCached {
public:
    TJWorkerCached(BoundedQueue<EncodeJob>& in, BoundedQueue<EncodeResult>& out)
        : inQ_(in), outQ_(out)
    {
        td_ = tjInitDecompress();
        tc_ = tjInitCompress();
    }
    ~TJWorkerCached(){ if (td_) tjDestroy(td_); if (tc_) tjDestroy(tc_); }

    void operator()(){
        EncodeJob job;
        while (inQ_.pop(job)){
            EncodeResult R; R.inPath=job.inPath; R.outPath=job.outPath;
            std::string err; IppDib dib;

            if (!DecodeWith(td_, job.inPath, job.maxThumb, dib, err)){
                R.ok=false; R.message="decode: "+err; outQ_.push(std::move(R)); continue;
            }
            std::vector<unsigned char> jpg;
            if (!EncodeWith(tc_, dib, job.preset, jpg, err)){
                R.ok=false; R.message="encode: "+err; outQ_.push(std::move(R)); continue;
            }
            // 저장 … 생략
        }
    }
private:
    static bool DecodeWith(tjhandle td, const std::wstring& path, int maxThumb, IppDib& out, std::string& err){ /* 위 TJ_Decode_BGRA에서 td 재사용 형태로 변경 */ return true; }
    static bool EncodeWith(tjhandle tc, const IppDib& img, const EncodePreset& p, std::vector<unsigned char>& outJpg, std::string& err){ /* 위 TJ_Encode_BGRA 변형 */ return true; }

    BoundedQueue<EncodeJob>& inQ_;
    BoundedQueue<EncodeResult>& outQ_;
    tjhandle td_{nullptr}, tc_{nullptr}; // ★ 이 워커 전용(동시 공유 금지)
};
```

핸들을 **워커 수명 전체**에서 재사용하면, **초당 작업 수(throughput)**가 유의하게 오릅니다.
