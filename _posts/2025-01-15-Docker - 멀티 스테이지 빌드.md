---
layout: post
title: Docker - 멀티 스테이지 빌드
date: 2025-01-15 21:20:23 +0900
category: Docker
---
# Docker 멀티 스테이지 빌드(Multi-stage Build) 완전 가이드 — 개념→패턴→언어별 예제→최적화→보안→재현성→트러블슈팅

본 글은 기존 정리(개념/필요성/기본 구조/Node·Go·Python 예제)를 **실무 수준으로 확장**한 자료입니다.
- 왜 멀티 스테이지가 필요한지, 어떤 패턴이 있는지
- 언어별(Go/Node/Python/Java/.NET/Rust) 최적화 템플릿
- BuildKit 고급 기능(cache/secrets/SSH/heredoc)
- 보안(USER 전환/read-only/cap-drop), 재현성(다이제스트/잠금파일/SBOM/서명)
- CI/CD, 테스트/린트 스테이지, 멀티아치(buildx), 이미지 크기/속도 측정
- 반대로 하면 느려지고 비대해지는 **안티 패턴**과 **트러블슈팅 표**
까지 한 번에 정리합니다. 모든 코드는 ``` 코드펜스, 수식은 $$...$$ 로 표기합니다.

---

## 1. 개념 복습 — 멀티 스테이지 빌드는 “빌드와 실행의 분리”

- 하나의 Dockerfile에 **여러 `FROM`**을 선언하여 **빌드용 단계**와 **런타임 단계**를 분리.
- 최종 이미지는 **마지막 `FROM` 스테이지**만 사용 → **빌드 도구/임시 산출물 미포함**.
- 이전 단계의 파일은 `COPY --from=<stage|index>`로 **필요한 결과물만 선별 복사**.

핵심 효과:
- **이미지 경량화**: 빌드 도구(node/gcc/openjdk 등) 제거
- **보안 강화**: 소스/비밀/테스트 파일 등 노출 최소화
- **빌드 속도 최적화**: 캐시 전략과 결합 시 효과 극대화

간단 직관(크기/속도 개선 기대치):
$$
\text{size}_{\text{final}} \approx \text{size}_{\text{runtime}} + \text{size}_{\text{artifacts}} \ll \text{size}_{\text{builder}}
$$
$$
\mathbb{E}[T_{\text{build}}] \approx \sum_i (1-p_i)\,c_i \quad\text{(레이어 캐시 적중률 } p_i \text{, 비용 } c_i)
$$
→ **비용 큰 단계(의존성 설치)를 위로**, **변동 큰 소스 복사는 아래로** 두면 유리.

---

## 2. 기본 구조(재정돈) + 캐시 고려

```Dockerfile
# 1. 빌드 스테이지
FROM node:20 AS builder
WORKDIR /app
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm npm ci
COPY . .
RUN npm run build

# 2. 런타임 스테이지
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

캐시 팁:
- 의존성 정의(`package*.json`, `requirements.txt`, `go.mod/sum`, `pom.xml`)를 **먼저 COPY** → `npm ci`, `pip wheel`, `mvn -o package` 등 후 소스 COPY.
- BuildKit `--mount=type=cache`로 의존성 캐시.

---

## 3. 언어/런타임별 최적화 템플릿

### 3.1 Node.js SPA → Nginx (정적 서빙)
```Dockerfile
# syntax=docker/dockerfile:1.7
FROM node:20-slim AS build
WORKDIR /app
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm npm ci
COPY . .
RUN npm run build

FROM nginx:alpine
# 보안: 최소 설정(예시), gzip 등은 conf로
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80
ENTRYPOINT ["nginx","-g","daemon off;"]
```
- 최종 이미지에는 **정적 파일만** 존재 → 작고 빠름.

### 3.2 Node.js SSR/Backend (Node 런타임 유지)
```Dockerfile
FROM node:20-slim AS deps
WORKDIR /app
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm npm ci --omit=dev

FROM node:20-slim AS runtime
WORKDIR /app
ENV NODE_ENV=production
COPY --from=deps /app/node_modules /app/node_modules
COPY . .
USER node
EXPOSE 3000
CMD ["node","server.js"]
```
- dev 의존성 제외(`--omit=dev`), 비루트 `USER node`.

### 3.3 Python (wheel 전략/멀티스테이지)
```Dockerfile
# syntax=docker/dockerfile:1.7
FROM python:3.12-slim AS base
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1
WORKDIR /app

FROM base AS deps
COPY requirements.txt .
RUN --mount=type=cache,target=/root/.cache/pip \
    pip wheel --no-cache-dir --no-deps -r requirements.txt -w /wheels

FROM base AS runtime
COPY --from=deps /wheels /wheels
RUN pip install --no-cache-dir /wheels/*
COPY . .
RUN addgroup --system app && adduser --system --ingroup app app
USER app
EXPOSE 5000
ENTRYPOINT ["gunicorn"]
CMD ["-w","2","-b","0.0.0.0:5000","app:app"]
```
- wheel 캐시로 **빌드 빠르고** 최종 이미지 **슬림**.

### 3.4 Go → scratch/distroless
```Dockerfile
FROM golang:1.22-alpine AS build
WORKDIR /src
COPY go.mod go.sum ./
RUN --mount=type=cache,target=/go/pkg/mod go mod download
COPY . .
RUN --mount=type=cache,target=/root/.cache/go-build \
    CGO_ENABLED=0 go build -o /out/app ./cmd/app

FROM scratch
COPY --from=build /out/app /app
ENTRYPOINT ["/app"]
```
- 정적 링크 전제(`CGO_ENABLED=0`), 최종 **수 MB**.

### 3.5 Java (Maven/Gradle → JRE 실행)
```Dockerfile
# Build
FROM maven:3.9-eclipse-temurin-21 AS build
WORKDIR /src
COPY pom.xml .
RUN mvn -B -q -e -DskipTests dependency:go-offline
COPY src ./src
RUN mvn -B -q -DskipTests package

# Runtime
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY --from=build /src/target/*.jar /app/app.jar
EXPOSE 8080
ENTRYPOINT ["java","-XX:+UseContainerSupport","-jar","/app/app.jar"]
```
- 오프라인 의존성 준비 → 빌드 반복 속도↑
- 컨테이너 메모리 친화 옵션 일부 반영.

### 3.6 .NET (SDK → ASP.NET 런타임)
```Dockerfile
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY *.sln ./
COPY src/ ./src/
RUN dotnet restore
RUN dotnet publish ./src/MyApp.csproj -c Release -o /out

FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build /out .
EXPOSE 8080
ENTRYPOINT ["dotnet","MyApp.dll"]
```

### 3.7 Rust (cargo 캐시 적극 활용)
```Dockerfile
# syntax=docker/dockerfile:1.7
FROM rust:1.80-slim AS build
WORKDIR /app
RUN --mount=type=cache,target=/usr/local/cargo/registry \
    --mount=type=cache,target=/app/target \
    true
COPY Cargo.toml Cargo.lock ./
RUN --mount=type=cache,target=/usr/local/cargo/registry \
    --mount=type=cache,target=/app/target \
    cargo fetch
COPY src ./src
RUN --mount=type=cache,target=/usr/local/cargo/registry \
    --mount=type=cache,target=/app/target \
    cargo build --release

FROM gcr.io/distroless/cc
COPY --from=build /app/target/release/myapp /usr/local/bin/myapp
ENTRYPOINT ["/usr/local/bin/myapp"]
```

---

## 4. BuildKit 고급기능 — cache/secrets/SSH/heredoc

BuildKit 활성화:
```bash
export DOCKER_BUILDKIT=1
```

### 4.1 캐시 마운트
```Dockerfile
RUN --mount=type=cache,target=/root/.cache/pip pip install -r requirements.txt
RUN --mount=type=cache,target=/root/.npm npm ci
RUN --mount=type=cache,target=/go/pkg/mod go mod download
```

### 4.2 시크릿(빌드시 비밀 노출 금지)
```Dockerfile
# syntax=docker/dockerfile:1.7
FROM alpine
RUN --mount=type=secret,id=npmrc \
    cp /run/secrets/npmrc /root/.npmrc && npm ci || true
```
```bash
docker build --secret id=npmrc,src=$HOME/.npmrc -t myapp:secret .
```

### 4.3 SSH 포워딩(프라이빗 Git)
```Dockerfile
# syntax=docker/dockerfile:1.7
FROM alpine:3.20
RUN apk add --no-cache git openssh
RUN --mount=type=ssh git clone git@github.com:org/private.git /src
```
```bash
docker build --ssh default -t app:git .
```

### 4.4 Heredoc(가독성)
```Dockerfile
# syntax=docker/dockerfile:1.7
RUN <<'SH'
set -eux
apk add --no-cache curl jq
curl -s https://example.com | jq .
SH
```

---

## 5. 고급 패턴 — 테스트/린트/팩토리 이미지/타깃 나누기

### 5.1 테스트/린트를 독립 스테이지로
```Dockerfile
FROM node:20 AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .

FROM deps AS test
RUN npm test

FROM deps AS lint
RUN npm run lint

FROM deps AS build
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
```
CI에서:
```bash
docker build --target test -t app:test .
docker build --target lint -t app:lint .
docker build -t app:prod .
```

### 5.2 “팩토리” 스테이지 만들기(공통 산출물 재활용)
- 공통 의존성/wheel/node_modules를 **deps 스테이지**에 제작
- build/runtime 스테이지에서 복사해 **중복 설치 최소화**

### 5.3 타깃(`--target`)로 부분만 실행
- 로컬 디버깅 시 빌드를 **중간 스테이지만 빠르게** 수행 가능.

---

## 6. 멀티 아키텍처/플랫폼 — buildx

여러 아키텍처(amd64/arm64) 동시 빌드:
```bash
docker buildx create --use
docker buildx build --platform linux/amd64,linux/arm64 -t ghcr.io/acme/app:1.0 --push .
```
- 베이스/네이티브 확장 호환성 체크 필수.
- Go의 경우 `GOOS/GOARCH` 환경변수로 크로스 컴파일 조정.

---

## 7. 보안 강화를 멀티 스테이지와 함께

### 7.1 비루트 실행 + 최소 권한
```Dockerfile
RUN addgroup -S app && adduser -S app -G app
USER app
```
실행 시:
```bash
docker run --rm \
  --read-only \
  --tmpfs /tmp --tmpfs /run \
  --cap-drop ALL --security-opt no-new-privileges \
  --user 65532:65532 \
  myimg:prod
```

### 7.2 이미지 내용 최소화
- 멀티 스테이지로 **디버그 툴/컴파일러 제거**
- `distroless`/`scratch`는 셸/패키지 없음 → 공격면 축소(필요시 busybox 제공 베이스 선택)

---

## 8. 재현성/서명/SBOM

- 베이스 이미지 **다이제스트 고정**(태그 변동 위험 최소화)
{% raw %}
```bash
docker inspect --format='{{index .RepoDigests 0}}' nginx:alpine
docker run --rm nginx@sha256:...
```
{% endraw %}
- 의존성 잠금: `package-lock.json`/`poetry.lock`/`go.sum`/`pom.xml` reproducible 옵션.
- SBOM/취약점/서명:
  - SBOM: `syft packages docker:IMAGE -o json`
  - 취약점: `trivy image IMAGE`
  - 서명/검증: `cosign sign|verify`

---

## 9. CI/CD 연동(예시: GitHub Actions)

{% raw %}
```yaml
name: build
on: [push]
jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ghcr.io/acme/app:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
```
{% endraw %}
- 캐시를 CI에 저장(`cache-to`)해 **재빌드 가속**.
- 필요 시 `--target test`로 테스트만 실행.

---

## 10. 이미지 크기/속도 측정 & 검증

```bash
docker images
docker history <image:tag>      # 레이어/명령 확인
docker system df                # 디스크 사용량
dive <image:tag>                # 레이어별 파일 구성(외부 도구)
docker run -it --rm <image> sh  # 실제 파일 확인(셸 있는 베이스)
```

---

## 11. 안티 패턴 — 이렇게 하면 비대/느림/위험

- **단일 스테이지**에 빌드+런타임+테스트+소스 전부 포함
- `COPY . .`를 상단에 두어 **캐시 무효화** 연쇄
- `apt-get update`와 `apt-get install`을 다른 RUN에 분리(인덱스 stale)
- dev 의존성/빌드 툴을 최종 이미지까지 가져감
- 비밀 키/.env를 COPY(또는 `.dockerignore` 미설정)
- shell form ENTRYPOINT로 신호 전달 망가뜨리기

---

## 12. 트러블슈팅 표

| 증상 | 원인 | 진단 | 해결 |
|---|---|---|---|
| 최종 이미지 거대 | 빌드 툴/테스트/소스 포함 | `docker history`, `dive` | 멀티 스테이지로 결과물만 COPY |
| 빌드 매번 느림 | 컨텍스트 과대, 캐시 무효화 | `.dockerignore`, 로그 | 의존성 파일 먼저 COPY, BuildKit cache mount |
| apt 404/stale | update/install 분리 | Dockerfile 확인 | **한 RUN**에 `update && install` |
| 비밀 유출 의심 | .env/키 COPY됨 | `dive`, 컨텍스트 점검 | `.dockerignore`, BuildKit secrets |
| 런타임 권한 과다 | root 실행 | `docker run` 옵션 확인 | USER 비루트, read-only, cap-drop |
| 신호/종료 불안 | shell form ENTRYPOINT | 종료 로그 | ENTRYPOINT exec form, `--init` 고려 |
| multi-arch 실패 | 베이스/네이티브 빌드 차이 | 빌드 로그, `--platform` | 호환 베이스 선택, 빌드 옵션 교정 |

---

## 13. “상황별” 완성 예제 3선

### 13.1 React/Vite 앱 → Nginx + 헬스엔드포인트
```Dockerfile
# syntax=docker/dockerfile:1.7
FROM node:20-slim AS build
WORKDIR /app
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm npm ci
COPY . .
RUN npm run build

FROM nginx:alpine
# 간단한 헬스 보강(예시)
RUN <<'NGINX'
printf "events {}\nhttp { server { listen 80; location /health { return 200 'ok'; } location / { root /usr/share/nginx/html; try_files \$uri /index.html; } } }" > /etc/nginx/nginx.conf
NGINX
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80
ENTRYPOINT ["nginx","-g","daemon off;"]
```

### 13.2 Flask(API) — wheel + 비루트 + 보안 실행옵션
```Dockerfile
# syntax=docker/dockerfile:1.7
FROM python:3.12-slim AS deps
WORKDIR /app
COPY requirements.txt .
RUN --mount=type=cache,target=/root/.cache/pip \
    pip wheel --no-cache-dir --no-deps -r requirements.txt -w /wheels

FROM python:3.12-slim
WORKDIR /app
COPY --from=deps /wheels /wheels
RUN pip install --no-cache-dir /wheels/*
COPY . .
RUN addgroup --system app && adduser --system --ingroup app app
USER app
EXPOSE 5000
ENTRYPOINT ["gunicorn"]
CMD ["-w","2","-b","0.0.0.0:5000","app:app"]
```
실행(예):
```bash
docker run -d --name api -p 5000:5000 \
  --read-only --tmpfs /tmp --tmpfs /run \
  --cap-drop ALL --security-opt no-new-privileges \
  --user 65532:65532 \
  myapi:latest
```

### 13.3 Go(REST) — distroless, 헬스체크, STOPSIGNAL
```Dockerfile
FROM golang:1.22-alpine AS build
WORKDIR /src
COPY go.mod go.sum ./
RUN --mount=type=cache,target=/go/pkg/mod go mod download
COPY . .
RUN --mount=type=cache,target=/root/.cache/go-build \
    CGO_ENABLED=0 go build -o /out/app ./cmd/server

FROM gcr.io/distroless/static
COPY --from=build /out/app /app
EXPOSE 8080
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD ["/app","-health"]
STOPSIGNAL SIGTERM
ENTRYPOINT ["/app"]
```

---

## 14. 수학으로 보는 “멀티 스테이지의 이득” (직관)

- 단일 스테이지 대비 멀티 스테이지의 **최종 이미지 크기** 기대 감소량:
$$
\Delta S \approx S_{\text{build tools}} + S_{\text{sources}} + S_{\text{dev deps}} - \epsilon
$$
(\(\epsilon\): 런타임에 필요한 최소 부가물)
- 빌드 시간은 레이어 캐시 적중률 \(p_i\)와 비용 \(c_i\)에 의존:
$$
\mathbb{E}[T_{\text{build}}] \approx \sum_i (1 - p_i)\, c_i
$$
→ 의존성 설치를 위쪽 레이어로 고정, 변동 많은 코드는 아래에 두어 \(p_i\) 최대화.

---

## 15. 결론 요약

- **멀티 스테이지 = 필수 교양**: 작고 안전하며 빠른 이미지를 만드는 표준.
- **패턴**: deps(의존성) → build(컴파일/번들) → runtime(최소 실행) → test/lint(선택).
- **BuildKit**(cache/secrets/SSH/heredoc)로 속도·보안 동시 개선.
- **보안**: 비루트, read-only, cap-drop, distroless/scratch 검토.
- **재현성**: 잠금 파일 + 다이제스트 고정 + SBOM/서명.
- **측정/검증**: `history/system df/dive`로 레이어·용량·구성 확인.
- **안티 패턴**(단일 스테이지/비밀 포함/캐시 무효화)만 피해도 절반은 성공.

---

## 부록 A) 실전 체크리스트

- [ ] `.dockerignore`에 `.git`, `.env`, 캐시/로그/빌드 산출물 제외
- [ ] `COPY deps` → 설치 → `COPY . .` 순서로 캐시 활용
- [ ] 멀티 스테이지로 **빌드 도구** 제거
- [ ] ENTRYPOINT/CMD **exec form**
- [ ] `USER` 비루트 + `--read-only` + `--cap-drop ALL`
- [ ] BuildKit 캐시/시크릿/SSH 사용
- [ ] 다이제스트 고정, SBOM/취약점 스캔, 서명
- [ ] `docker history`, `dive`로 검증
- [ ] CI에서 `--target test|lint`로 품질 게이트
- [ ] 필요 시 `buildx`로 멀티 아키텍처 빌드
