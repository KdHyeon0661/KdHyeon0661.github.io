---
layout: post
title: Docker - 멀티 스테이지 빌드
date: 2025-01-15 21:20:23 +0900
category: Docker
---
# Docker 멀티 스테이지 빌드

Docker 멀티 스테이지 빌드는 현대적인 컨테이너 이미지 빌드의 핵심 기술입니다. 이 기술을 효과적으로 활용하면 더 작고 안전하며 빠른 이미지를 생성할 수 있습니다. 본 가이드에서는 멀티 스테이지 빌드의 기본 개념부터 고급 패턴, 언어별 최적화 방법, 보안 고려사항까지 종합적으로 다루어 실무에서 바로 적용할 수 있는 지식을 제공합니다.

## 멀티 스테이지 빌드의 핵심 개념 이해하기

멀티 스테이지 빌드는 하나의 Dockerfile 안에 여러 개의 `FROM` 지시문을 사용하여 빌드 과정을 여러 단계로 분리하는 기술입니다. 각 단계는 독립적인 빌드 환경을 구성하며, 최종 이미지는 마지막 단계만을 포함하게 됩니다.

### 기본 원리와 장점

**작동 방식**:
- 하나의 Dockerfile에 여러 빌드 단계 정의
- 각 단계는 독립적인 베이스 이미지를 가짐
- 이전 단계의 파일은 `COPY --from=<단계명>`으로 선택적으로 복사
- 최종 이미지에는 마지막 단계만 포함

**주요 장점**:
1. **이미지 크기 최소화**: 컴파일러, 빌드 도구, 개발 의존성 등이 최종 이미지에 포함되지 않음
2. **보안 강화**: 소스 코드, 비밀키, 테스트 파일 등 불필요한 파일 노출 방지
3. **빌드 속도 향상**: 레이어 캐시 전략과 결합하여 빌드 효율성 극대화
4. **관리 용이성**: 빌드와 런타임 환경의 명확한 분리

### 개념적 이해를 위한 수식 표현

멀티 스테이지 빌드의 효과를 수학적으로 표현해보면:

최종 이미지 크기 개선:
```
최종_이미지_크기 ≈ 런타임_크기 + 산출물_크기 ≪ 빌더_이미지_크기
```

빌드 시간 기대치:
```
기대_빌드_시간 ≈ Σ(1 - 캐시_적중률_i) × 비용_i
```

이 수식들은 중요한 원칙을 보여줍니다: 비용이 큰 작업(의존성 설치)을 상위 레이어에, 변경이 잦은 작업(소스 코드 복사)을 하위 레이어에 배치해야 캐시 적중률을 높이고 전체 빌드 시간을 줄일 수 있습니다.

## 기본적인 멀티 스테이지 빌드 패턴

가장 일반적인 멀티 스테이지 패턴은 의존성 설치, 빌드, 런타임의 세 단계로 구성됩니다.

```Dockerfile
# 빌드 스테이지
FROM node:20 AS builder
WORKDIR /app

# 의존성 파일 먼저 복사 (캐시 최적화)
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm npm ci

# 소스 코드 복사 및 빌드
COPY . .
RUN npm run build

# 런타임 스테이지
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

이 패턴의 핵심은 캐시 최적화에 있습니다. 의존성 정의 파일을 먼저 복사하고 설치한 후에 소스 코드를 복사함으로써, 소스 코드가 변경되더라도 의존성 설치 레이어의 캐시를 재사용할 수 있습니다. BuildKit의 캐시 마운트 기능을 활용하면 의존성 캐시를 영구적으로 유지할 수 있어 빌드 속도를 더욱 향상시킬 수 있습니다.

## 언어별 최적화 템플릿

각 프로그래밍 언어와 프레임워크는 고유한 특성을 가지고 있으므로, 언어별로 최적화된 Dockerfile 템플릿을 사용하는 것이 중요합니다.

### Node.js SPA 애플리케이션 (정적 파일 서빙)

```Dockerfile
# syntax=docker/dockerfile:1.7

# 빌드 스테이지
FROM node:20-slim AS build
WORKDIR /app
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm npm ci
COPY . .
RUN npm run build

# 런타임 스테이지 (Nginx 사용)
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80
ENTRYPOINT ["nginx", "-g", "daemon off;"]
```

이 패턴의 장점은 최종 이미지에 정적 파일만 포함된다는 점입니다. Nginx는 가볍고 정적 파일 서빙에 최적화되어 있어 작은 이미지 크기와 빠른 시작 시간을 제공합니다.

### Node.js 서버사이드 렌더링 또는 백엔드

```Dockerfile
# 의존성 설치 스테이지
FROM node:20-slim AS deps
WORKDIR /app
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm npm ci --omit=dev

# 런타임 스테이지
FROM node:20-slim AS runtime
WORKDIR /app
ENV NODE_ENV=production

# 의존성 복사
COPY --from=deps /app/node_modules /app/node_modules

# 애플리케이션 코드 복사
COPY . .

# 비루트 사용자로 전환
USER node

EXPOSE 3000
CMD ["node", "server.js"]
```

이 패턴은 개발 의존성을 제외하고(`--omit=dev`) 비루트 사용자로 실행하여 보안을 강화합니다. 의존성 설치와 런타임을 분리함으로써 캐시 효율성을 높입니다.

### Python 애플리케이션 (Wheel 패키지 활용)

```Dockerfile
# syntax=docker/dockerfile:1.7

# 기본 베이스 이미지
FROM python:3.12-slim AS base
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1
WORKDIR /app

# 의존성 스테이지 (Wheel 생성)
FROM base AS deps
COPY requirements.txt .
RUN --mount=type=cache,target=/root/.cache/pip \
    pip wheel --no-cache-dir --no-deps -r requirements.txt -w /wheels

# 런타임 스테이지
FROM base AS runtime
COPY --from=deps /wheels /wheels
RUN pip install --no-cache-dir /wheels/*
COPY . .

# 비루트 사용자 생성 및 전환
RUN addgroup --system app && adduser --system --ingroup app app
USER app

EXPOSE 5000
ENTRYPOINT ["gunicorn"]
CMD ["-w", "2", "-b", "0.0.0.0:5000", "app:app"]
```

Python의 경우 Wheel 패키지를 사용하면 의존성 설치 속도를 크게 향상시킬 수 있습니다. Wheel은 미리 컴파일된 패키지 형식으로, 런타임에서의 설치 시간을 단축시킵니다.

### Go 애플리케이션 (초경량 이미지)

```Dockerfile
# 빌드 스테이지
FROM golang:1.22-alpine AS build
WORKDIR /src
COPY go.mod go.sum ./
RUN --mount=type=cache,target=/go/pkg/mod go mod download
COPY . .
RUN --mount=type=cache,target=/root/.cache/go-build \
    CGO_ENABLED=0 go build -o /out/app ./cmd/app

# 런타임 스테이지 (스크래치 이미지)
FROM scratch
COPY --from=build /out/app /app
ENTRYPOINT ["/app"]
```

Go 언어는 정적 링크(`CGO_ENABLED=0`)를 통해 모든 의존성을 실행 파일에 포함시킬 수 있어, 완전히 빈 베이스 이미지(`scratch`)에서도 실행 가능합니다. 이로 인해 이미지 크기가 수 MB 수준으로 유지됩니다.

### Java 애플리케이션 (Maven 빌드)

```Dockerfile
# 빌드 스테이지
FROM maven:3.9-eclipse-temurin-21 AS build
WORKDIR /src
COPY pom.xml .
RUN mvn -B -q -e -DskipTests dependency:go-offline
COPY src ./src
RUN mvn -B -q -DskipTests package

# 런타임 스테이지
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY --from=build /src/target/*.jar /app/app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-XX:+UseContainerSupport", "-jar", "/app/app.jar"]
```

Maven의 오프라인 모드를 활용하면 의존성을 미리 다운로드하여 빌드 속도를 높일 수 있습니다. 컨테이너 환경에 최적화된 JVM 옵션(`-XX:+UseContainerSupport`)을 사용하는 것도 중요합니다.

## BuildKit의 고급 기능 활용

Docker BuildKit은 현대적인 빌드 시스템으로, 다양한 고급 기능을 제공합니다. 이러한 기능들을 활용하면 빌드 속도, 보안, 유연성을 크게 향상시킬 수 있습니다.

### BuildKit 활성화

```bash
# 환경 변수를 통한 활성화
export DOCKER_BUILDKIT=1

# 또는 Docker 데몬 설정으로 영구 활성화
# /etc/docker/daemon.json 파일에 다음 내용 추가:
# {
#   "features": {"buildkit": true}
# }
```

### 캐시 마운트를 통한 의존성 캐시 관리

```Dockerfile
# Python 의존성 캐시
RUN --mount=type=cache,target=/root/.cache/pip pip install -r requirements.txt

# Node.js 의존성 캐시
RUN --mount=type=cache,target=/root/.npm npm ci

# Go 모듈 캐시
RUN --mount=type=cache,target=/go/pkg/mod go mod download
```

캐시 마운트는 빌드 간에 의존성 캐시를 유지하여 반복적인 다운로드를 방지합니다. 이로 인해 특히 대규모 의존성을 가진 프로젝트에서 빌드 속도가 크게 향상됩니다.

### 시크릿 관리를 통한 보안 강화

```Dockerfile
# syntax=docker/dockerfile:1.7

FROM alpine
# 시크릿 마운트를 통한 npmrc 파일 사용
RUN --mount=type=secret,id=npmrc \
    cp /run/secrets/npmrc /root/.npmrc && npm ci || true
```

빌드 시 시크릿 전달:
```bash
docker build --secret id=npmrc,src=$HOME/.npmrc -t myapp:secret .
```

이 방법을 사용하면 빌드 과정에서 필요한 비밀 정보(API 키, 인증 토큰 등)를 이미지에 포함시키지 않고 안전하게 전달할 수 있습니다.

### SSH 에이전트 포워딩을 통한 프라이빗 저장소 접근

```Dockerfile
# syntax=docker/dockerfile:1.7

FROM alpine:3.20
RUN apk add --no-cache git openssh
# SSH 마운트를 통한 프라이빗 저장소 클론
RUN --mount=type=ssh git clone git@github.com:organization/private-repo.git /src
```

빌드 시 SSH 에이전트 전달:
```bash
docker build --ssh default -t app:git .
```

이 기능을 사용하면 빌드 과정에서 프라이빗 Git 저장소에 접근할 수 있어, 의존성 관리가 훨씬 편리해집니다.

### Heredoc 문법을 통한 가독성 향상

```Dockerfile
# syntax=docker/dockerfile:1.7

# 다중 명령어를 heredoc으로 그룹화
RUN <<'SH'
set -eux
apk add --no-cache curl jq
curl -s https://api.example.com/data | jq .
SH
```

Heredoc 문법을 사용하면 여러 줄에 걸친 복잡한 스크립트를 더 읽기 쉽게 구성할 수 있습니다.

## 고급 빌드 패턴과 CI/CD 통합

### 테스트와 린트를 독립적인 스테이지로 분리

```Dockerfile
# 공통 의존성 스테이지
FROM node:20 AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .

# 테스트 스테이지
FROM deps AS test
RUN npm test

# 린트 스테이지
FROM deps AS lint
RUN npm run lint

# 빌드 스테이지
FROM deps AS build
RUN npm run build

# 런타임 스테이지
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
```

CI/CD 파이프라인에서 각 단계를 독립적으로 실행:
```bash
# 테스트 실행
docker build --target test -t app:test .

# 린트 실행
docker build --target lint -t app:lint .

# 프로덕션 빌드
docker build -t app:prod .
```

이 패턴은 품질 관리를 빌드 프로세스에 자연스럽게 통합합니다. 각 단계가 독립적이므로 특정 단계(예: 테스트)가 실패하더라도 다른 단계에 영향을 주지 않습니다.

### 팩토리 스테이지를 통한 의존성 재사용

여러 빌드 단계에서 동일한 의존성을 사용하는 경우, 의존성 설치를 별도의 "팩토리" 스테이지로 분리하여 중복 설치를 방지할 수 있습니다.

```Dockerfile
# 의존성 팩토리 스테이지
FROM python:3.12-slim AS deps-factory
WORKDIR /app
COPY requirements.txt .
RUN pip wheel --no-cache-dir -r requirements.txt -w /wheels

# 개발 빌드 스테이지
FROM python:3.12-slim AS dev
COPY --from=deps-factory /wheels /wheels
RUN pip install --no-cache-dir /wheels/*
COPY . .

# 프로덕션 빌드 스테이지
FROM python:3.12-slim AS prod
COPY --from=deps-factory /wheels /wheels
RUN pip install --no-cache-dir /wheels/*
COPY . .
# 프로덕션 전용 설정 적용
```

## 멀티 아키텍처 빌드 (Buildx 활용)

다양한 CPU 아키텍처(amd64, arm64 등)를 지원하는 이미지를 생성해야 할 때는 Docker Buildx를 사용할 수 있습니다.

```bash
# Buildx 빌더 인스턴스 생성 및 사용
docker buildx create --use --name multiarch-builder

# 멀티 아키텍처 이미지 빌드 및 푸시
docker buildx build \
  --platform linux/amd64,linux/arm64 \
  -t myregistry.com/myapp:1.0.0 \
  --push .
```

이 방법을 사용하면 단일 빌드 명령으로 여러 아키텍처용 이미지를 동시에 생성할 수 있습니다. 특히 Go 언어의 경우 `GOOS`와 `GOARCH` 환경 변수를 설정하여 크로스 컴파일을 지원합니다.

## 보안 강화를 위한 모범 사례

### 비루트 사용자 실행과 권한 최소화

```Dockerfile
# 비루트 사용자 생성
RUN addgroup -S app && adduser -S app -G app

# 사용자 전환
USER app
```

컨테이너 실행 시 추가 보안 설정:
```bash
docker run --rm \
  --read-only \                    # 루트 파일 시스템 읽기 전용
  --tmpfs /tmp --tmpfs /run \     # 쓰기 가능한 임시 파일시스템
  --cap-drop ALL \                # 모든 권한 제거
  --security-opt no-new-privileges \  # 권한 상승 방지
  --user 1000:1000 \              # 비루트 사용자 지정
  myimage:latest
```

### Distroless 또는 Scratch 베이스 이미지 사용

Distroless 이미지는 셸과 패키지 관리자를 포함하지 않는 최소한의 런타임 환경을 제공합니다. 이로 인해 공격 표면이 크게 줄어들어 보안성이 향상됩니다.

```Dockerfile
FROM gcr.io/distroless/static
COPY --from=build /out/app /app
ENTRYPOINT ["/app"]
```

Scratch는 완전히 빈 베이스 이미지로, 정적으로 링크된 실행 파일만 필요로 하는 애플리케이션에 적합합니다.

## 재현성, SBOM, 이미지 서명

### 이미지 다이제스트를 통한 재현성 보장

태그는 시간이 지남에 따라 다른 이미지를 가리킬 수 있으므로, 재현성을 보장하기 위해 다이제스트를 사용하는 것이 좋습니다.

{% raw %}
```bash
# 이미지 다이제스트 확인
docker inspect --format='{{index .RepoDigests 0}}' nginx:alpine

# 다이제스트를 사용한 컨테이너 실행
docker run --rm nginx@sha256:abcdef123456...
```
{% endraw %}

### 의존성 잠금 파일 관리

각 언어의 의존성 잠금 파일을 사용하면 동일한 의존성 버전을 보장할 수 있습니다:
- Node.js: `package-lock.json` 또는 `yarn.lock`
- Python: `poetry.lock` 또는 `pipenv.lock`
- Go: `go.sum`
- Java: `pom.xml` (재현 가능 옵션 사용)

### SBOM 생성과 취약점 스캔

소프트웨어 재료 명세서(SBOM)를 생성하고 정기적인 취약점 스캔을 수행하는 것은 현대적인 소프트웨어 공급망 보안의 필수 요소입니다.

```bash
# SBOM 생성 (Syft 사용)
syft packages docker:myimage:latest -o json > sbom.json

# 취약점 스캔 (Trivy 사용)
trivy image myimage:latest

# 이미지 서명 (Cosign 사용)
cosign sign --key cosign.key myregistry.com/myimage:1.0.0
cosign verify --key cosign.pub myregistry.com/myimage:1.0.0
```

## CI/CD 파이프라인과의 통합

GitHub Actions를 사용한 CI/CD 파이프라인 예시:

{% raw %}
```yaml
name: Docker Build and Push
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: |
            ghcr.io/${{ github.repository }}:latest
            ghcr.io/${{ github.repository }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Run security scan
        if: ${{ github.event_name != 'pull_request' }}
        run: |
          docker run --rm \
            -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest \
            image --severity HIGH,CRITICAL \
            ghcr.io/${{ github.repository }}:latest
```
{% endraw %}

이 파이프라인은 여러 중요한 기능을 포함합니다:
- GitHub Actions 캐시를 활용한 빌드 속도 향상
- 풀 리퀘스트와 푸시 이벤트에 대한 다른 동작
- 멀티 아키텍처 지원
- 보안 스캔 통합

## 이미지 성능 측정과 분석

생성된 Docker 이미지의 성능을 측정하고 분석하는 것은 지속적인 개선에 필수적입니다.

```bash
# 이미지 크기 확인
docker images

# 레이어 상세 정보 확인
docker history myimage:latest

# 디스크 사용량 확인
docker system df

# 레이어별 파일 구성 분석 (Dive 도구 사용)
dive myimage:latest

# 실제 컨테이너 실행 테스트
docker run -it --rm myimage:latest sh
```

Dive와 같은 도구를 사용하면 각 레이어에 어떤 파일이 포함되어 있는지 시각적으로 확인할 수 있어, 불필요한 파일을 제거하는 데 도움이 됩니다.

## 피해야 할 안티 패턴

Docker 이미지 빌드 시 흔히 발생하는 실수들을 인지하고 피하는 것이 중요합니다.

### 주요 안티 패턴

1. **단일 스테이지에 모든 것을 포함**: 빌드 도구, 런타임, 테스트, 소스 코드를 하나의 이미지에 포함하면 이미지가 불필요하게 커지고 보안 위험이 증가합니다.

2. **캐시 무효화를 유발하는 레이어 순서**: 소스 코드를 의존성 파일보다 먼저 복사하면 소스 코드가 조금만 변경되어도 의존성 설치 레이어의 캐시가 무효화됩니다.

3. **apt-get update와 install 분리**: 패키지 인덱스 업데이트와 패키지 설치를 다른 RUN 명령으로 분리하면 오래된 인덱스 캐시를 사용할 위험이 있습니다.

4. **개발 의존성을 프로덕션 이미지에 포함**: 개발 및 테스트용 도구와 의존성을 프로덕션 이미지에 포함하면 불필요한 공격 표면이 증가합니다.

5. **비밀 정보를 이미지에 포함**: 환경 변수나 비밀 키를 Dockerfile에 하드코딩하거나 `.dockerignore` 없이 빌드하면 보안 위험이 발생합니다.

6. **Shell Form ENTRYPOINT 사용**: Shell Form을 사용하면 신호 처리가 제대로 이루어지지 않아 컨테이너 종료에 문제가 발생할 수 있습니다.

## 실전 문제 해결 가이드

Docker 이미지 빌드 과정에서 발생할 수 있는 일반적인 문제들과 해결 방법을 알아봅니다.

### 이미지 크기가 예상보다 큰 경우

**증상**: 생성된 이미지가 예상보다 훨씬 큼
**원인**: 빌드 도구, 테스트 파일, 소스 코드 등이 최종 이미지에 포함됨
**진단**: `docker history`와 `dive` 명령으로 레이어 분석
**해결**: 멀티 스테이지 빌드로 전환하고 필요한 산출물만 복사

### 빌드 속도가 너무 느린 경우

**증상**: 매번 빌드할 때마다 시간이 오래 걸림
**원인**: 과도한 빌드 컨텍스트, 캐시 미활용
**진단**: `.dockerignore` 파일 확인, 빌드 로그 분석
**해결**: 의존성 파일을 먼저 복사, BuildKit 캐시 마운트 활용

### 패키지 설치 실패 (404 오류)

**증상**: apt-get install 명령이 404 오류 발생
**원인**: apt-get update와 install이 다른 RUN 명령으로 분리됨
**진단**: Dockerfile의 RUN 명령 확인
**해결**: apt-get update와 install을 하나의 RUN 명령으로 결합

### 비밀 정보 유출 위험

**증상**: 비밀 키나 인증 정보가 이미지에 포함된 것 같음
**원인**: `.env` 파일이나 키 파일이 COPY됨
**진단**: `dive`로 이미지 내용 검사, 빌드 컨텍스트 점검
**해결**: `.dockerignore`에 비밀 파일 추가, BuildKit secrets 활용

### 런타임 권한 문제

**증상**: 컨테이너가 필요 이상의 권한으로 실행됨
**원인**: root 사용자로 실행
**진단**: `docker run` 옵션과 Dockerfile의 USER 지시문 확인
**해결**: 비루트 사용자 생성 및 전환, read-only 파일시스템 적용

### 멀티 아키텍처 빌드 실패

**증상**: 다른 아키텍처용 이미지 빌드 실패
**원인**: 베이스 이미지나 네이티브 빌드 호환성 문제
**진단**: 빌드 로그 확인, `--platform` 옵션 검토
**해결**: 호환되는 베이스 이미지 선택, 빌드 옵션 조정

## 실제 시나리오별 완성 예제

### React/Vite 애플리케이션 with Nginx

```Dockerfile
# syntax=docker/dockerfile:1.7

# 빌드 스테이지
FROM node:20-slim AS build
WORKDIR /app
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm npm ci
COPY . .
RUN npm run build

# 런타임 스테이지
FROM nginx:alpine

# Nginx 기본 설정 생성
RUN printf "events {}\nhttp { \
  server { \
    listen 80; \
    location /health { return 200 'ok'; } \
    location / { \
      root /usr/share/nginx/html; \
      try_files \$uri /index.html; \
    } \
  } \
}" > /etc/nginx/nginx.conf

# 빌드 산출물 복사
COPY --from=build /app/dist /usr/share/nginx/html

EXPOSE 80
ENTRYPOINT ["nginx", "-g", "daemon off;"]
```

### Python 애플리케이션 with 보안 강화

```Dockerfile
# syntax=docker/dockerfile:1.7

# 의존성 스테이지
FROM python:3.12-slim AS deps
WORKDIR /app
COPY requirements.txt .
RUN --mount=type=cache,target=/root/.cache/pip \
    pip wheel --no-cache-dir --no-deps -r requirements.txt -w /wheels

# 런타임 스테이지
FROM python:3.12-slim
WORKDIR /app

# Wheel 패키지 설치
COPY --from=deps /wheels /wheels
RUN pip install --no-cache-dir /wheels/*

# 애플리케이션 코드 복사
COPY . .

# 비루트 사용자 생성 및 전환
RUN addgroup --system app && adduser --system --ingroup app app
USER app

EXPOSE 5000
ENTRYPOINT ["gunicorn"]
CMD ["-w", "2", "-b", "0.0.0.0:5000", "app:app"]
```

보안 강화 실행 예시:
```bash
docker run -d --name api -p 5000:5000 \
  --read-only \
  --tmpfs /tmp --tmpfs /run \
  --cap-drop ALL \
  --security-opt no-new-privileges \
  --user 1000:1000 \
  myapi:latest
```

### Distroless with 헬스체크 및 신호 처리

```Dockerfile
# 빌드 스테이지
FROM golang:1.22-alpine AS build
WORKDIR /src
COPY go.mod go.sum ./
RUN --mount=type=cache,target=/go/pkg/mod go mod download
COPY . .
RUN --mount=type=cache,target=/root/.cache/go-build \
    CGO_ENABLED=0 go build -o /out/app ./cmd/server

# 런타임 스테이지
FROM gcr.io/distroless/static
COPY --from=build /out/app /app
EXPOSE 8080

# 헬스체크 설정
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD ["/app", "-health"]

# 정상 종료 신호 설정
STOPSIGNAL SIGTERM

ENTRYPOINT ["/app"]
```

## 결론

Docker 멀티 스테이지 빌드는 현대적인 컨테이너 기반 애플리케이션 개발과 배포의 필수 기술입니다. 이 가이드에서 다룬 핵심 개념과 패턴들을 정리하면 다음과 같습니다:

**멀티 스테이지 빌드의 필수성**: 단일 스테이지 빌드에 비해 멀티 스테이지 빌드는 이미지 크기를 획기적으로 줄이고 보안성을 향상시키며 빌드 속도를 개선합니다. 이는 현대적인 소프트웨어 배포에서 반드시 고려해야 할 요소입니다.

**효과적인 패턴 활용**: 의존성 관리, 빌드, 테스트, 린트, 런타임 단계를 명확히 분리하고, 각 단계를 독립적으로 관리하는 패턴을 적용해야 합니다. BuildKit의 고급 기능(캐시 마운트, 시크릿 관리, SSH 포워딩 등)을 적극 활용하면 빌드 효율성과 보안성을 동시에 높일 수 있습니다.

**보안 우선 접근법**: 비루트 사용자 실행, 최소 권한 원칙, 읽기 전용 파일시스템, Distroless/Scratch 베이스 이미지 사용 등 기본적인 보안 모범 사례를 준수해야 합니다. 이미지 서명, SBOM 생성, 정기적인 취약점 스캔도 현대적인 소프트웨어 공급망 보안의 일부로 간주해야 합니다.

**재현성 보장**: 이미지 다이제스트 고정, 의존성 잠금 파일 관리, 환경 변수 통제 등을 통해 동일한 입력에 대해 항상 동일한 출력을 보장하는 재현 가능한 빌드를 구현해야 합니다.

**지속적인 측정과 개선**: `docker history`, `dive`, `docker system df` 등의 도구를 사용하여 이미지 크기와 구성을 정기적으로 분석하고, 지속적으로 최적화해야 합니다. CI/CD 파이프라인에 품질 게이트를 통합하여 자동화된 검증을 구현하는 것도 중요합니다.

이러한 원칙들을 프로젝트에 적용하면 더 효율적이고 안전하며 관리하기 쉬운 Docker 이미지를 생성할 수 있습니다. 처음에는 기본 패턴을 따르다가 점차 프로젝트의 특수한 요구사항에 맞게 조정해나가는 접근법을 권장합니다. Docker 이미지 설계는 단순한 기술 작업이 아닌, 애플리케이션의 전체 라이프사이클을 고려한 종합적인 아키텍처 결정의 일환이라는 점을 기억하시기 바랍니다.