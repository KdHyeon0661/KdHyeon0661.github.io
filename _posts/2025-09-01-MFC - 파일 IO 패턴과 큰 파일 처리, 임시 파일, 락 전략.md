---
layout: post
title: MFC - 파일 I/O 패턴과 큰 파일 처리, 임시 파일, 락 전략
date: 2025-09-01 20:25:23 +0900
category: MFC
---
# 파일 I/O 패턴과 큰 파일 처리, 임시 파일/락 전략 (MFC/Win32 실전 총정리 + 예제 다수)

이 글은 **Windows 데스크톱(C++/MFC/Win32)** 환경에서
- **안전 저장(Atomic Save)**
- **임시 파일/롤백 전략**
- **락(파일 잠금/프로세스 간 동기화)**
- **큰 파일(GB~TB) 처리**
- **메모리 매핑/비동기 I/O/버퍼링 튜닝**
- **경로/유니코드/권한/에러 복구**

까지 **생략 없이** 정리합니다. 모든 코드는 ``` 로 감싸며, **바로 붙여 넣어** 테스트 가능한 형태를 지향합니다.

> 대상: SDI/MDI/대화상자 앱, Windows 10/11, x64/Unicode 권장  
> 파일 API: Win32(권장), MFC `CFile`/`CStdioFile`, 표준 C++ 스트림의 한계와 주의점 포함

---

## 0) 큰 그림: “무조건 안전, 예측 가능한 성능”

1. **항상 임시 파일 → 원자 교체(ReplaceFile/MoveFileEx)**  
2. **같은 볼륨**에서 작업(메타데이터 스왑은 원자적)  
3. **FlushFileBuffers** 로 내구성 보장(필요한 경우에만)  
4. **락**은 **바이트 범위 락(협조적)** + **프로세스 단위 네임드 뮤텍스** 병행  
5. **큰 파일**은 **청크/스트리밍** + **CopyFileEx(콜백)** 또는 **Overlapped/IOCP**  
6. **무조건 64비트 오프셋/경로**(`CreateFileW`, `\\?\` 프리픽스)  
7. **에러 복구**: 디스크 부족/권한/충돌 → **롤백·사용자 메시지·재시도**  

---

# 1) 기본 열기 패턴(Win32) — 공유/버퍼/플래그 튜닝

```cpp
// 유니코드 경로 안전 열기 (긴 경로 대비 \\?\ 프리픽스)
HANDLE OpenForRead(const std::wstring& path) {
    std::wstring p = path;
    if (!p.starts_with(LR"(\\?\)")) p = LR"(\\?\)" + p; // 긴 경로 허용
    HANDLE h = CreateFileW(
        p.c_str(),
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, // 다른 프로세스와 공존 허용(읽기)
        nullptr,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,       // 순차 읽기 힌트
        nullptr);
    return (h==INVALID_HANDLE_VALUE) ? nullptr : h;
}

HANDLE OpenForWriteReplace(const std::wstring& path) {
    std::wstring p = path;
    if (!p.starts_with(LR"(\\?\)")) p = LR"(\\?\)" + p;
    HANDLE h = CreateFileW(
        p.c_str(),
        GENERIC_WRITE,
        0,                                  // 덮어쓰는 동안 독점
        nullptr,
        CREATE_ALWAYS,                      // 항상 새 파일 생성(임시에 사용)
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, // 전원보장 필요 시만 WRITE_THROUGH
        nullptr);
    return (h==INVALID_HANDLE_VALUE) ? nullptr : h;
}
```

### 공유 모드 가이드
- 단독 쓰기 시: `FILE_SHARE_NONE` (기본값 0) 또는 최소화  
- 읽기-공존 허용: `FILE_SHARE_READ`  
- 자동 저장/임시 파일 → 충돌 최소화: `FILE_SHARE_READ|WRITE|DELETE`  
- **주의**: 공유 모드는 **다른 프로세스의 Open 시도**에 영향을 줌(상호 호환 설계)

### 성능 힌트 플래그
- `FILE_FLAG_SEQUENTIAL_SCAN` / `FILE_FLAG_RANDOM_ACCESS` : OS 캐시 힌트  
- `FILE_FLAG_WRITE_THROUGH` : 쓰기 캐시를 건너뛰어 내구성↑(성능↓)  
- `FILE_FLAG_OVERLAPPED` : 비동기 I/O  
- `FILE_ATTRIBUTE_TEMPORARY` : 파일 캐시 우선(짧게 쓰고 지울 때)  
- `FILE_FLAG_DELETE_ON_CLOSE` : 핸들 닫을 때 자동 삭제(진짜 임시)

---

# 2) 안전 저장(Atomic Save) — 임시 파일 + 원자 교체

## 2-1) ReplaceFile/MoveFileEx 패턴

**원칙**: **같은 폴더**에 임시 파일을 쓰고 **교체**해야 원자성 확보(다른 볼륨 간 Move는 복사 후 삭제 → 원자 아님)

```cpp
bool AtomicSave(const std::wstring& finalPath, const std::function<bool(HANDLE)>& writer) {
    // 1) 같은 디렉터리에 임시 파일 이름 생성
    std::filesystem::path dst(finalPath);
    auto dir  = dst.parent_path();
    auto temp = dir / (dst.filename().wstring() + L".tmp");

    // 2) 임시 파일 열기
    HANDLE h = CreateFileW(
        (L"\\\\?\\" + temp.wstring()).c_str(),
        GENERIC_WRITE,
        0, nullptr, CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL, nullptr);
    if (h==INVALID_HANDLE_VALUE) return false;

    // 3) 실제 내용을 임시 파일에 기록
    bool ok = writer(h);

    // 4) Flush + Close
    if (ok) ok = !!FlushFileBuffers(h);
    CloseHandle(h);
    if (!ok) { DeleteFileW((L"\\\\?\\" + temp.wstring()).c_str()); return false; }

    // 5) 백업 파일 옵션(선택)
    std::wstring backup = dst.wstring() + L".bak";
    // ReplaceFileW 가 백업 파일을 자동으로 생성/대체할 수 있음(옵션)
    BOOL replaced = ReplaceFileW(
        (L"\\\\?\\" + dst.wstring()).c_str(),
        (L"\\\\?\\" + temp.wstring()).c_str(),
        (L"\\\\?\\" + backup).c_str(),        // 백업 경로(없으면 nullptr)
        REPLACEFILE_WRITE_THROUGH,            // 메타까지 쓰기 보장
        nullptr, nullptr);

    if (!replaced) {
        // ReplaceFile 실패 시 MoveFileEx로 대체(기존 파일이 없을 수 있는 첫 저장)
        BOOL moved = MoveFileExW(
            (L"\\\\?\\" + temp.wstring()).c_str(),
            (L"\\\\?\\" + dst.wstring()).c_str(),
            MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
        if (!moved) {
            // 최종 실패 → 임시 삭제
            DeleteFileW((L"\\\\?\\" + temp.wstring()).c_str());
            return false;
        }
    }
    return true;
}
```

**핵심**  
- `FlushFileBuffers`(임시) + `REPLACEFILE_WRITE_THROUGH` 로 **전원 차단에도 안전**  
- `.bak` 백업 보존/롤링 정책은 앱 요구에 맞게(최근 N개)

## 2-2) MFC `CFile`로 구현 (간단 버전)

```cpp
bool AtomicSaveCFile(const CStringW& path, const std::function<void(CFile&)>& writeFn)
{
    CStringW dir = path.Left(path.ReverseFind(L'\\'));
    CStringW tmp = path + L".tmp";

    CFile tmpFile;
    if (!tmpFile.Open(tmp, CFile::modeCreate|CFile::modeWrite|CFile::shareExclusive))
        return false;

    try {
        writeFn(tmpFile);
        tmpFile.Flush();
        tmpFile.Close();
        // 기존 파일 백업(옵션)
        CStringW bak = path + L".bak";
        // 안전 교체
        if (!::ReplaceFileW(path, tmp, bak, REPLACEFILE_WRITE_THROUGH, nullptr, nullptr)) {
            // ReplaceFile이 안 될 수 있음(첫 저장) → Move 대체
            if (!::MoveFileExW(tmp, path, MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH)) {
                ::DeleteFileW(tmp);
                return false;
            }
        }
        return true;
    } catch(...) {
        tmpFile.Close();
        ::DeleteFileW(tmp);
        return false;
    }
}
```

---

# 3) 큰 파일 처리(GB~TB) — 스트리밍/청크/오버랩/진행률

## 3-1) 64비트 오프셋으로 청크 읽기/쓰기

```cpp
bool ReadChunk(HANDLE h, void* buf, DWORD bytesToRead, LONGLONG offset64, DWORD& bytesRead) {
    OVERLAPPED ov{};
    ov.Offset     = (DWORD)(offset64 & 0xFFFFFFFF);
    ov.OffsetHigh = (DWORD)((offset64 >> 32) & 0xFFFFFFFF);
    return !!ReadFile(h, buf, bytesToRead, &bytesRead, &ov);
}

bool WriteChunk(HANDLE h, const void* buf, DWORD bytesToWrite, LONGLONG offset64, DWORD& bytesWritten) {
    OVERLAPPED ov{};
    ov.Offset     = (DWORD)(offset64 & 0xFFFFFFFF);
    ov.OffsetHigh = (DWORD)((offset64 >> 32) & 0xFFFFFFFF);
    return !!WriteFile(h, buf, bytesToWrite, &bytesWritten, &ov);
}
```

- **포인터 이동(SetFilePointerEx)** 없이 임의 위치 I/O  
- **청크 크기**: 1MB~8MB 사이부터 테스트 → 장치/FS/CPU에 맞춰 튜닝

## 3-2) 대용량 복사(진행률 포함) — CopyFileEx

```cpp
static DWORD CALLBACK CopyProgress(
    LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile,
    HANDLE hDestinationFile, LPVOID lpData)
{
    UNREFERENCED_PARAMETER(StreamSize);
    UNREFERENCED_PARAMETER(StreamBytesTransferred);
    UNREFERENCED_PARAMETER(dwStreamNumber);
    UNREFERENCED_PARAMETER(hSourceFile);
    UNREFERENCED_PARAMETER(hDestinationFile);
    UNREFERENCED_PARAMETER(lpData);

    if (dwCallbackReason==CALLBACK_CHUNK_FINISHED || dwCallbackReason==CALLBACK_STREAM_SWITCH) {
        double pct = (double)TotalBytesTransferred.QuadPart / (double)TotalFileSize.QuadPart * 100.0;
        // TODO: 진행률 표시(ProgressBar 등)
    }
    return PROGRESS_CONTINUE; // 취소 시 PROGRESS_CANCEL
}

bool CopyLargeFile(const std::wstring& src, const std::wstring& dst)
{
    return !!CopyFileExW(
        src.c_str(), dst.c_str(),
        CopyProgress, nullptr, FALSE,
        COPY_FILE_NO_BUFFERING // 또는 0 / COPY_FILE_RESTARTABLE 등
    );
}
```

> `COPY_FILE_RESTARTABLE` 은 중단 후 재시도 가능(네트워크 복사 등)

## 3-3) Overlapped(비동기) + IOCP(요약)

- **Throughput** 극대화를 원할 때: `FILE_FLAG_OVERLAPPED`로 열고 스레드 풀/IOCP로 파이프라인  
- 구현이 복잡 → **파일 한 개 스트리밍**은 `CopyFileEx`/큰 청크 Sync I/O로도 충분한 경우 多

---

# 4) 메모리 매핑(Memory-Mapped File) — 랜덤 액세스/거대 파일 뷰

## 4-1) 기본 패턴

```cpp
struct MappedView {
    HANDLE hFile = nullptr;
    HANDLE hMap  = nullptr;
    BYTE*  base  = nullptr; // view 시작 주소
    size_t size  = 0;

    bool Open(const std::wstring& path, bool write) {
        hFile = CreateFileW(path.c_str(), write?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                            FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
        if (hFile==INVALID_HANDLE_VALUE) return false;

        LARGE_INTEGER sz; GetFileSizeEx(hFile, &sz);
        size = (size_t)sz.QuadPart;

        hMap = CreateFileMappingW(hFile, nullptr, write?PAGE_READWRITE:PAGE_READONLY, sz.HighPart, sz.LowPart, nullptr);
        if (!hMap) { CloseHandle(hFile); hFile=nullptr; return false; }

        base = (BYTE*)MapViewOfFile(hMap, write?FILE_MAP_WRITE:FILE_MAP_READ, 0,0, 0); // 전체 매핑(거대 파일은 부분 뷰 권장)
        if (!base) { CloseHandle(hMap); CloseHandle(hFile); hMap=nullptr; hFile=nullptr; return false; }
        return true;
    }
    void Close() {
        if (base) UnmapViewOfFile(base), base=nullptr;
        if (hMap) CloseHandle(hMap), hMap=nullptr;
        if (hFile) CloseHandle(hFile), hFile=nullptr;
    }
};
```

### 주의
- **거대 파일(수십~수백 GB)**: **부분 뷰**를 스크롤처럼 맵/언맵  
- 뷰 정렬은 **시스템 할당 단위(AllocationGranularity)** 에 맞춰야 함 (`GetSystemInfo`)

```cpp
SYSTEM_INFO si; GetSystemInfo(&si);
DWORD gran = si.dwAllocationGranularity; // 보통 64KB
// 원하는 오프셋을 gran 배수로 내림, 내부 오프셋은 + delta 로 접근
```

### 장점/단점
- 장점: `memcpy` 처럼 사용자 코드 단순, OS 페이지 캐시 사용  
- 단점: 쓰기 시 **예기치 않은 페이지 오류/예외** 가능 → 예외 처리 필요, 커밋/FlushViewOfFile 고려

---

# 5) 임시 파일 전략 — 이름, 위치, 용량, 충돌

## 5-1) 어디에 만들까?

- **원자 교체 목적**: **최종 파일과 같은 디렉터리**(같은 볼륨)  
- 일반 임시: `%TEMP%` (`GetTempPath`, `GetTempFileName`)  
- 대용량: 대상 볼륨의 **여유 공간** 먼저 확인(`GetDiskFreeSpaceEx`)

```cpp
std::wstring MakeSiblingTemp(const std::wstring& finalPath) {
    std::filesystem::path p(finalPath);
    auto dir = p.parent_path();
    for (int i=0;i<100;i++) {
        auto t = dir / (p.filename().wstring() + L".tmp" + std::to_wstring(i));
        if (!std::filesystem::exists(t)) return t.wstring();
    }
    // fallback
    WCHAR tmpdir[MAX_PATH]; GetTempPathW(MAX_PATH, tmpdir);
    WCHAR tmpfile[MAX_PATH]; GetTempFileNameW(tmpdir, L"APP", 0, tmpfile);
    return tmpfile;
}
```

## 5-2) 용량 예약(Preallocation)

- 큰 파일 쓸 때 **조각화 방지/디스크 부족 사전 감지**  
- `SetFilePointerEx` + `SetEndOfFile` 로 사이즈 설정  
- 관리자 권한 + 정책에 따라 `SetFileValidData`(Zeroing 없이 확장 → 빠름) 가능

```cpp
bool Preallocate(HANDLE h, LONGLONG size) {
    LARGE_INTEGER li; li.QuadPart = size;
    if (!SetFilePointerEx(h, li, nullptr, FILE_BEGIN)) return false;
    return !!SetEndOfFile(h);
}
```

---

# 6) 락 전략 — 바이트 범위 락 + 네임드 뮤텍스

## 6-1) 파일 내부 레코드/범위 보호 — LockFileEx

- **협조적(Advisory)** 잠금: 협력 프로세스 간에만 유효  
- **블로킹/비블로킹** 선택

```cpp
bool LockRange(HANDLE h, LONGLONG offset, LONGLONG len, bool exclusive, bool wait) {
    OVERLAPPED ov{}; ov.Offset=(DWORD)(offset&0xFFFFFFFF); ov.OffsetHigh=(DWORD)(offset>>32);
    DWORD flags = exclusive ? LOCKFILE_EXCLUSIVE_LOCK : 0;
    if (!wait) flags |= LOCKFILE_FAIL_IMMEDIATELY;
    return !!LockFileEx(h, flags, 0, (DWORD)(len&0xFFFFFFFF), (DWORD)(len>>32), &ov);
}
void UnlockRange(HANDLE h, LONGLONG offset, LONGLONG len) {
    OVERLAPPED ov{}; ov.Offset=(DWORD)(offset&0xFFFFFFFF); ov.OffsetHigh=(DWORD)(offset>>32);
    UnlockFileEx(h, 0, (DWORD)(len&0xFFFFFFFF), (DWORD)(len>>32), &ov);
}
```

### 패턴
- 헤더(0~4KB) 영역을 짧게 **독점 락** → 메타 업데이트 중 동시 접근 차단  
- 데이터 영역은 레코드 단위 공유/독점 락 조합

## 6-2) 프로세스 간 단일 접근 보장 — 네임드 뮤텍스

```cpp
class ProcessMutex {
    HANDLE h = nullptr;
public:
    bool OpenOrCreate(const wchar_t* name) {
        h = CreateMutexW(nullptr, FALSE, name);
        return h!=nullptr;
    }
    bool Lock(DWORD timeoutMs = INFINITE) {
        return WaitForSingleObject(h, timeoutMs)==WAIT_OBJECT_0;
    }
    void Unlock(){ ReleaseMutex(h); }
    ~ProcessMutex(){ if(h) CloseHandle(h); }
};
// 사용: "Global\\Vendor_App_SaveMutex"
```

**권장**: **뮤텍스 + 바이트 범위 락** 병행(전역 동작 보호 + 파일 내부 세분화)

---

# 7) 버퍼링/캐시/플래그 — 예측 가능한 성능

| 시나리오 | 권장 플래그 | 비고 |
|---|---|---|
| 순차 대용량 읽기 | `FILE_FLAG_SEQUENTIAL_SCAN` | ReadAhead ↑, 페이지 캐시 효율 ↑ |
| 랜덤 액세스 | `FILE_FLAG_RANDOM_ACCESS` | ReadAhead ↓ |
| 저지연 동기 쓰기 | `FILE_FLAG_WRITE_THROUGH` | 성능↓, 내구성↑ |
| 수십~수백 MB 임시 | `FILE_ATTRIBUTE_TEMPORARY` | 시스템 캐시 우선 |
| 스트림 병렬 처리 | `FILE_FLAG_OVERLAPPED` | IOCP/스레드 풀 |

**주의**: ‘무조건 WRITE_THROUGH’는 성능을 크게 떨어뜨림 → **Atomic Save + Flush**로 충분한 경우가 많음.

---

# 8) 텍스트/바이너리/인코딩 — UTF-8/UTF-16, BOM, 줄바꿈

- 윈도우 기본 텍스트 API는 **UTF-16(LE)**  
- 교차 호환/깃/툴 호환은 **UTF-8 + BOM 또는 BOM 없음** 채택  
- `CStdioFile` 사용 시 **코드페이지** 주의(UTF-8 다루려면 별도 변환 또는 `std::ofstream` + `u8`)

```cpp
// 간단 UTF-8 저장
bool SaveUtf8(const std::wstring& path, std::string_view utf8) {
    HANDLE h = CreateFileW(path.c_str(), GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (h==INVALID_HANDLE_VALUE) return false;
    // BOM(옵션)
    static const BYTE bom[3] = {0xEF,0xBB,0xBF};
    DWORD wr=0; WriteFile(h, bom, 3, &wr, nullptr);
    WriteFile(h, utf8.data(), (DWORD)utf8.size(), &wr, nullptr);
    FlushFileBuffers(h);
    CloseHandle(h);
    return true;
}
```

---

# 9) 오류 처리/복구 UX — 디스크 부족/권한/충돌/바이러스 검사

- 모든 Win32 호출 후 `GetLastError()` → 사용자 메시지/로그  
- 디스크 부족: **사전 용량 체크** + **친절한 안내**(대상 볼륨 여유 공간, 저장 경로 변경 제안)  
- 권한 거부: 관리자 권한 필요/폴더 권한 안내  
- 실시간 백신/인덱서에 의한 일시적 실패: **재시도 정책(100ms backoff × N회)**  
- 저장 실패 시: **원본 유지 + 임시/백업 유지** 안내(자동 복구 옵션)

```cpp
std::wstring ExplainLastError(DWORD e=GetLastError()){
    LPWSTR buf=nullptr; FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_IGNORE_INSERTS,
        nullptr, e, 0, (LPWSTR)&buf, 0, nullptr);
    std::wstring s = buf?buf:L"";
    if (buf) LocalFree(buf);
    return s;
}
```

---

# 10) 보안/암호화/무결성

- **DPAPI** 로 민감 데이터 암호화 후 저장(사용자/머신 바인딩)

```cpp
#include <dpapi.h>
#pragma comment(lib, "Crypt32.lib")

bool ProtectUser(std::span<const BYTE> plain, std::vector<BYTE>& out) {
    DATA_BLOB in{ (DWORD)plain.size(), (BYTE*)plain.data() }, enc{};
    BOOL ok = CryptProtectData(&in, L"", nullptr, nullptr, nullptr, 0, &enc);
    if (!ok) return false;
    out.assign(enc.pbData, enc.pbData+enc.cbData);
    LocalFree(enc.pbData);
    return true;
}
bool UnprotectUser(std::span<const BYTE> blob, std::vector<BYTE>& out) {
    DATA_BLOB in{ (DWORD)blob.size(), (BYTE*)blob.data() }, dec{};
    LPWSTR desc = nullptr;
    BOOL ok = CryptUnprotectData(&in, &desc, nullptr, nullptr, nullptr, 0, &dec);
    if (desc) LocalFree(desc);
    if (!ok) return false;
    out.assign(dec.pbData, dec.pbData+dec.cbData);
    LocalFree(dec.pbData);
    return true;
}
```

- **무결성 확인**: SHA-256 해시/CRC32 등(큰 파일은 스트리밍 해시)  
- **암호 파일**: 전체를 암호화하면 랜덤 접근/충돌 복구가 어려움 → **헤더+청크 암호화** 고려

---

# 11) 경로/유니코드/긴 경로

- 항상 **`CreateFileW`** / Wide API  
- 260자 초과 긴 경로 → `\\?\` 프리픽스 필수  
- 네트워크 경로 `\\server\share` → `\\?\UNC\server\share\...`

---

# 12) MFC `CFile`/`CArchive`와 Win32 혼용 팁

- `CFile`은 내부적으로 Win32 핸들 래핑, 성능/플래그 제어가 제한적  
- 큰 파일/특수 플래그/락/Overlapped는 **Win32로 직접**  
- 직렬화 포맷은 `CArchive`로, 저장은 **Atomic Save Win32**로 분리하여 사용 가능

---

# 13) 예제 모음

## 13-1) 대용량 스트리밍 복사(진행률 + 취소)

```cpp
struct CopyCtx {
    std::atomic<bool> cancel{false};
    std::function<void(double)> onProgress;
};

bool CopyStreamed(const std::wstring& src, const std::wstring& dst, CopyCtx& ctx)
{
    HANDLE hs = CreateFileW(src.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN, nullptr);
    if (hs==INVALID_HANDLE_VALUE) return false;
    HANDLE hd = CreateFileW(dst.c_str(), GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL, nullptr);
    if (hd==INVALID_HANDLE_VALUE){ CloseHandle(hs); return false; }

    LARGE_INTEGER sz; GetFileSizeEx(hs, &sz);
    const DWORD CHUNK = 4*1024*1024;
    std::vector<BYTE> buf(CHUNK);
    LONGLONG done=0;
    for (;;) {
        if (ctx.cancel.load()) { CloseHandle(hd); CloseHandle(hs); DeleteFileW(dst.c_str()); return false; }
        DWORD rd=0; if (!ReadFile(hs, buf.data(), CHUNK, &rd, nullptr) || rd==0) break;
        DWORD wr=0; if (!WriteFile(hd, buf.data(), rd, &wr, nullptr) || wr!=rd) { CloseHandle(hd); CloseHandle(hs); return false; }
        done += rd;
        if (ctx.onProgress) ctx.onProgress((double)done / (double)sz.QuadPart);
    }
    FlushFileBuffers(hd);
    CloseHandle(hd); CloseHandle(hs);
    return true;
}
```

## 13-2) 부분 업데이트(패치) — 헤더/테이블만 갱신

```cpp
struct Header { char magic[4]; uint32_t version; uint64_t recordCount; };

bool UpdateHeader(const std::wstring& path, const Header& h) {
    HANDLE f = CreateFileW(path.c_str(), GENERIC_WRITE|GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr);
    if (f==INVALID_HANDLE_VALUE) return false;
    // 락(헤더 영역)
    if (!LockRange(f, 0, 4096, true, true)) { CloseHandle(f); return false; }
    DWORD wr=0;
    SetFilePointer(f, 0, nullptr, FILE_BEGIN);
    BOOL ok = WriteFile(f, &h, sizeof(h), &wr, nullptr);
    FlushFileBuffers(f);
    UnlockRange(f, 0, 4096);
    CloseHandle(f);
    return ok && wr==sizeof(h);
}
```

## 13-3) 로그 파일 롤링(크기 기준)

```cpp
void AppendLog(const std::wstring& path, const std::wstring& line, size_t maxSizeBytes=10*1024*1024) {
    // 롤링: 크기 초과 시 .1, .2 … 순환
    WIN32_FILE_ATTRIBUTE_DATA fad{};
    if (GetFileAttributesExW(path.c_str(), GetFileExInfoStandard, &fad)) {
        ULONGLONG size = ((ULONGLONG)fad.nFileSizeHigh<<32) | fad.nFileSizeLow;
        if (size > maxSizeBytes) {
            // 간단: 기존 파일을 .1로
            std::wstring bak = path + L".1";
            DeleteFileW(bak.c_str());
            MoveFileW(path.c_str(), bak.c_str());
        }
    }
    HANDLE h = CreateFileW(path.c_str(), FILE_APPEND_DATA, FILE_SHARE_READ, nullptr, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (h==INVALID_HANDLE_VALUE) return;
    // UTF-8로 쓰기(간단화)
    std::string u8 = /* 변환 */ std::string(line.begin(), line.end());
    DWORD wr=0; WriteFile(h, u8.data(), (DWORD)u8.size(), &wr, nullptr);
    WriteFile(h, "\r\n", 2, &wr, nullptr);
    CloseHandle(h);
}
```

---

# 14) 파일 감시/동기화 — ReadDirectoryChangesW

- 설정 파일 자동 리로드, 외부 편집 감지, 충돌 방지 UX

```cpp
void WatchFolder(const std::wstring& dir, std::function<void()> onChange) {
    HANDLE h = CreateFileW(dir.c_str(), FILE_LIST_DIRECTORY,
        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
        nullptr, OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_OVERLAPPED, nullptr);
    if (h==INVALID_HANDLE_VALUE) return;

    std::vector<BYTE> buf(64*1024);
    OVERLAPPED ov{}; HANDLE ev = CreateEventW(nullptr, TRUE, FALSE, nullptr); ov.hEvent = ev;

    while (true) {
        DWORD ret=0;
        BOOL ok = ReadDirectoryChangesW(h, buf.data(), (DWORD)buf.size(), TRUE,
            FILE_NOTIFY_CHANGE_FILE_NAME|FILE_NOTIFY_CHANGE_LAST_WRITE|FILE_NOTIFY_CHANGE_SIZE,
            &ret, &ov, nullptr);
        if (!ok) break;
        DWORD w = WaitForSingleObject(ev, 5000);
        if (w==WAIT_OBJECT_0) {
            ResetEvent(ev);
            onChange();
        }
        // 취소 조건/종료 로직 추가 가능
    }
    CloseHandle(h); CloseHandle(ev);
}
```

---

# 15) QA 체크리스트

1. **전원 차단** 시 파일 손상? → 임시 + 원자 교체 + Flush  
2. **디스크 부족**: 예외 처리/메시지/롤백/남은 용량 표시  
3. **경합**: 다른 프로세스가 같은 파일을 열 때 충돌? → 공유 모드/락/뮤텍스 조정  
4. **대용량**: 50GB+ 파일 스트리밍/해시/복사 속도 검증  
5. **경로**: 260자 넘는 긴 경로/네트워크 UNC 경로 테스트  
6. **DPI/UAC**: Program Files/Windows 폴더 저장 금지, 사용자 데이터는 `%USERPROFILE%`/AppData  
7. **백신 간섭**: 쓰기 직후 접근 실패 재현 → 재시도 정책  
8. **복원**: .bak/.tmp 발견 시 “복구” 안내 루틴

---

# 16) 실무 레시피 요약

- **저장**: `AtomicSave(final, writer)` (같은 폴더 .tmp → ReplaceFile/MoveFileEx)  
- **대용량 복사**: `CopyFileEx`(콜백) 또는 **4~8MB 청크** Sync I/O  
- **랜덤 접근**: **메모리 매핑**(부분 뷰) + 범위 락  
- **동시성**: **네임드 뮤텍스**(앱 전역) + **LockFileEx**(세부 범위)  
- **성능 플래그**: 순차/랜덤 힌트, 필요 시 Overlapped, Write-Through는 최소 사용  
- **보안**: DPAPI(민감 데이터), 해시(무결성), 권한/ACL 문서화  
- **에러 복구**: .tmp/.bak 정책 + 사용자 메시지 + 자동 복구

---

## 마무리

- **임시 파일 → 원자 교체**는 모든 파일 앱의 **표준 안전망**입니다.  
- 큰 파일은 **청크 스트리밍**과 **적절한 플래그/버퍼링**만으로도 충분히 빠르고 안정적입니다.  
- 동시 접근은 **락(파일 범위) + 뮤텍스**로 **명확한 규약**을 세우세요.  
- 이 글의 스니펫들을 조합하면, **문서형 앱/에디터/백업 툴/미디어 처리기**까지 **안전·성능·복구**를 모두 갖춘 I/O 파이프라인을 빠르게 구축할 수 있습니다.