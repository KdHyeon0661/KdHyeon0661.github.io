---
layout: post
title: MFC - 파일 I/O 패턴과 큰 파일 처리, 임시 파일, 락 전략
date: 2025-09-01 20:25:23 +0900
category: MFC
---
# 파일 I/O 패턴과 큰 파일 처리, 임시 파일/락 전략

- **안전 저장(Atomic Save)**
- **임시 파일/롤백/저널 전략**
- **락(파일 잠금/프로세스 간 동기화)**
- **큰 파일(GB~TB) 처리**
- **메모리 매핑/비동기 I/O/버퍼링 튜닝**
- **경로/유니코드/권한/에러 복구 UX**

> 대상: SDI/MDI/대화상자 기반 앱, Windows 10/11, x64/Unicode 빌드  
> 사용 API: Win32(핵심), MFC `CFile`/`CStdioFile`, 표준 C++ 스트림은 보조로만 사용

---

## 1. 큰 그림: “무조건 안전, 예측 가능한 성능”

먼저 전체 철학부터 잡고 들어간다.

1. **항상 임시 파일 → 원자 교체(ReplaceFile/MoveFileEx)**  
   - “파일을 직접 덮어쓰기” 대신 항상 **같은 폴더의 임시 파일**을 쓴 뒤 **단 한 번의 원자적 교체**로 마무리.
2. **같은 볼륨에서 작업**  
   - 같은 디스크/볼륨 내에서의 Rename/Replace는 **메타데이터 스왑**으로 동작 → 원자성 보장.
3. **FlushFileBuffers** 로 내구성 보장(“정말” 필요할 때만)  
   - 매번 쓰면 성능이 크게 떨어지므로, 중요 저장·마지막 단계에서만 사용.
4. **락**은 두 층으로 나눔  
   - 파일 내부: **바이트 범위 락(협조적 LockFileEx)**  
   - 프로세스 간 전역: **네임드 뮤텍스/세마포어**
5. **큰 파일**은 **청크/스트리밍**  
   - 1~8MB 청크 + CopyFileEx(콜백) 또는 Overlapped/IOCP
6. **항상 64비트 오프셋/유니코드 경로**  
   - `CreateFileW`, `GetFileSizeEx`, `\\?\` 프리픽스
7. **에러 복구**  
   - 디스크 부족/권한/충돌 → **롤백·백업 파일·사용자 메시지·재시도** 루틴까지 설계

이 철학을 기준으로, Win32/MFC API를 어떻게 구성할지 구체적인 패턴과 코드로 풀어보자.

---

## 2. Win32 vs MFC vs C++ 스트림: 어디에 무엇을 쓸까

### 2.1 Win32 API (CreateFile, ReadFile…)

- 장점
  - **모든 기능의 원형**: 공유 모드, 플래그, Overlapped, 메모리 매핑 등.
  - 성능 및 플래그를 가장 세밀하게 컨트롤 가능.
- 단점
  - 코드가 장황, 예외 안전/RAII 직접 구현 필요.

### 2.2 MFC `CFile`, `CStdioFile`, `CArchive`

- 장점
  - RAII, 예외 처리 편의, 직렬화(`CArchive`)와 자동 연계.
- 단점
  - 내부 플래그/공유 모드/Overlapped, 긴 경로, 특정 플래그(예: `FILE_FLAG_SEQUENTIAL_SCAN`)를 완벽 제어하기 어렵다.
  - **정말 중요한 I/O 경로**는 Win32로 직접 처리하고, 상위 레벨만 `CFile`/`CArchive`를 얹는 것이 안전하다.

### 2.3 C++ 표준 스트림 (`std::ifstream`, `std::ofstream`)

- 장점
  - 플랫폼 중립, 템플릿/알고리즘과의 연동 편리.
- 단점
  - Windows 전용 기능(공유 모드, Overlapped, 메모리 매핑 등)을 컨트롤하기 어렵다.
  - 기본적으로 **공유 모드 = 없음**이 되며, 예기치 않은 공유 오류를 낼 수 있다.

**결론**:  
- **핵심 영속성/큰 파일/동시성/락** 관련 코드는 Win32로 설계.  
- UI/직렬화/간단 텍스트 입출력에만 MFC/C++ 스트림을 얹어서 사용.

---

## 3. 경로/유니코드/긴 경로

### 3.1 유니코드 기본

- 프로젝트는 **Unicode** 설정(x64, `UNICODE`/`_UNICODE` 정의).
- 항상 `CreateFileW`, `DeleteFileW`, `MoveFileExW` 등 **Wide API** 사용.

### 3.2 긴 경로(`\\?\` 프리픽스)

전통 윈도우는 **MAX_PATH = 260자** 제한이 있었지만, modern Windows에서는 다음과 같이 우회한다.

- 로컬 경로:  
  `C:\Very\Long\Path\...` → `\\?\C:\Very\Long\Path\...`
- UNC 경로:  
  `\\server\share\dir\...` → `\\?\UNC\server\share\dir\...`

긴 경로 대응 헬퍼:

```cpp
std::wstring NormalizeLongPath(const std::wstring& path)
{
    if (path.rfind(LR"(\\?\)", 0) == 0)
        return path;

    if (path.rfind(LR"(\\)", 0) == 0) {
        // UNC 경로
        return LR"(\\?\UNC\)" + path.substr(2);
    }
    return LR"(\\?\)" + path;
}
```

---

## 4. 파일 열기 기본 패턴: 공유/버퍼/플래그 튜닝

### 4.1 안전한 열기 헬퍼 (읽기/쓰기)

```cpp
// 유니코드 경로 안전 열기 (긴 경로 대응)
HANDLE OpenForRead(const std::wstring& path)
{
    std::wstring p = NormalizeLongPath(path);

    HANDLE h = CreateFileW(
        p.c_str(),
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, // 읽기 시 공유 허용
        nullptr,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,       // 순차 읽기 힌트
        nullptr);

    return (h == INVALID_HANDLE_VALUE) ? nullptr : h;
}

HANDLE OpenForWriteReplace(const std::wstring& path)
{
    std::wstring p = NormalizeLongPath(path);

    HANDLE h = CreateFileW(
        p.c_str(),
        GENERIC_WRITE,
        0,                                  // 덮어쓰는 동안 독점
        nullptr,
        CREATE_ALWAYS,                      // 항상 새 파일 생성
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, // 전원보장 필요 시만 WRITE_THROUGH
        nullptr);

    return (h == INVALID_HANDLE_VALUE) ? nullptr : h;
}
```

### 4.2 공유 모드 가이드

- **단독 쓰기**  
  - `dwShareMode = 0` (혹은 최소한으로)
- **여러 프로세스가 읽기만**  
  - `FILE_SHARE_READ`
- **자동 저장/임시 파일**처럼 충돌을 피하고 싶은 경우  
  - `FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE`
- 공유 모드는 **“내가 여는 방식” + “상대가 열었던 방식”**이 서로 호환될 때만 성공한다.  
  즉, 협조적인 설계가 필요하다.

### 4.3 성능/캐시 플래그 정리

| 플래그 | 의미 | 사용 시나리오 |
|---|---|---|
| `FILE_FLAG_SEQUENTIAL_SCAN` | 순차 접근 힌트 | 큰 파일 전체 읽기, 백업 등 |
| `FILE_FLAG_RANDOM_ACCESS` | 랜덤 접근 힌트 | DB/인덱스 파일, 랜덤 시킹 |
| `FILE_FLAG_WRITE_THROUGH` | 캐시 우회(동기) | 회계/거래 로그 등 강한 내구성 요구 |
| `FILE_FLAG_OVERLAPPED` | 비동기 I/O | IOCP 등 고성능 서버 |
| `FILE_ATTRIBUTE_TEMPORARY` | 캐시에 우선 유지 | 임시 작업용 파일 |
| `FILE_FLAG_DELETE_ON_CLOSE` | 핸들 닫히면 삭제 | 진짜 임시, 흔적 최소화 |

**주의**:  
“안전해야 하니까 무조건 WRITE_THROUGH”는 성능을 크게 망친다.  
실제로는 **Atomic Save + FlushFileBuffers** 조합으로 충분한 경우가 대부분이다.

---

## 5. 임시 파일 + 원자 교체(Atomic Save)

### 5.1 원자 저장 개념

1. **원본 파일은 건드리지 않는다.**
2. 동일 디렉터리에 임시 파일을 생성한다.
3. 임시 파일에 **전체 내용**을 쓴다.
4. 쓰기가 성공하면 **FlushFileBuffers** 호출.
5. `ReplaceFileW` 또는 `MoveFileExW`로 원본 파일과 교체한다.

이 과정이 한 번만 성공하면, 그 시점에는 항상

- “이전 버전 파일”이거나
- “새 버전 파일” 중 하나만 존재하고,  
  “깨진 중간 상태 파일”은 없다.

### 5.2 Win32 기반 AtomicSave 구현

```cpp
bool AtomicSave(const std::wstring& finalPath,
                const std::function<bool(HANDLE)>& writer)
{
    // 1) 같은 디렉터리에 임시 파일 이름 생성
    std::filesystem::path dst(finalPath);
    auto dir  = dst.parent_path();
    auto temp = dir / (dst.filename().wstring() + L".tmp");

    std::wstring tempPath = NormalizeLongPath(temp.wstring());
    std::wstring dstPath  = NormalizeLongPath(dst.wstring());
    std::wstring bakPath  = NormalizeLongPath((dst.wstring() + L".bak"));

    // 2) 임시 파일 열기
    HANDLE h = CreateFileW(
        tempPath.c_str(),
        GENERIC_WRITE,
        0, nullptr, CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        nullptr);

    if (h == INVALID_HANDLE_VALUE)
        return false;

    // 3) 실제 내용을 임시 파일에 기록
    bool ok = writer(h);

    // 4) Flush + Close
    if (ok)
        ok = !!FlushFileBuffers(h);

    CloseHandle(h);

    if (!ok) {
        DeleteFileW(tempPath.c_str());
        return false;
    }

    // 5) ReplaceFileW로 원자 교체 + 백업
    BOOL replaced = ReplaceFileW(
        dstPath.c_str(),
        tempPath.c_str(),
        bakPath.c_str(),                      // 백업 경로(없으면 nullptr)
        REPLACEFILE_WRITE_THROUGH,            // 메타까지 쓰기 보장
        nullptr, nullptr);

    if (!replaced) {
        // ReplaceFile 실패 시 MoveFileEx로 대체(첫 저장 등)
        BOOL moved = MoveFileExW(
            tempPath.c_str(),
            dstPath.c_str(),
            MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
        if (!moved) {
            DeleteFileW(tempPath.c_str());
            return false;
        }
    }
    return true;
}
```

### 5.3 MFC `CFile` 기반 AtomicSave 래퍼

```cpp
bool AtomicSaveCFile(const CStringW& path,
                     const std::function<void(CFile&)>& writeFn)
{
    CStringW tmp = path + L".tmp";
    CStringW bak = path + L".bak";

    CFile tmpFile;
    if (!tmpFile.Open(tmp,
        CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive))
        return false;

    try {
        writeFn(tmpFile);
        tmpFile.Flush();
        tmpFile.Close();

        // ReplaceFile 시 Wide 문자열 필요
        if (!::ReplaceFileW(path, tmp, bak,
            REPLACEFILE_WRITE_THROUGH, nullptr, nullptr))
        {
            if (!::MoveFileExW(tmp, path,
                MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH))
            {
                ::DeleteFileW(tmp);
                return false;
            }
        }
        return true;
    }
    catch (...) {
        tmpFile.Close();
        ::DeleteFileW(tmp);
        return false;
    }
}
```

### 5.4 상황 예제 – 문서 편집기

- 사용자가 100MB짜리 문서를 편집 중.
- 저장 버튼을 눌렀을 때:
  1. `AtomicSave(L"C:\\docs\\report.rpt", writer)` 호출.
  2. writer는 현재 메모리 모델을 직렬화하여 임시 파일에 기록.
  3. Flush 후 ReplaceFile 성공 → 이전 버전은 `.bak`, 새 버전이 본 파일.
- 저장 중 전원 장애가 발생하더라도,
  - 아예 교체 전이면 **기존 파일**만 남고,
  - 교체 후면 **새 파일**만 남는다.

---

## 6. 큰 파일(GB~TB) 스트리밍과 복사

### 6.1 64비트 오프셋으로 청크 I/O

```cpp
bool ReadChunk(HANDLE h, void* buf, DWORD bytesToRead,
               LONGLONG offset64, DWORD& bytesRead)
{
    OVERLAPPED ov{};
    ov.Offset     = (DWORD)(offset64 & 0xFFFFFFFF);
    ov.OffsetHigh = (DWORD)((offset64 >> 32) & 0xFFFFFFFF);

    return !!ReadFile(h, buf, bytesToRead, &bytesRead, &ov);
}

bool WriteChunk(HANDLE h, const void* buf, DWORD bytesToWrite,
                LONGLONG offset64, DWORD& bytesWritten)
{
    OVERLAPPED ov{};
    ov.Offset     = (DWORD)(offset64 & 0xFFFFFFFF);
    ov.OffsetHigh = (DWORD)((offset64 >> 32) & 0xFFFFFFFF);

    return !!WriteFile(h, buf, bytesToWrite, &bytesWritten, &ov);
}
```

- 장점
  - `SetFilePointerEx` 호출 없이 **임의 위치** I/O 가능.
  - Overlapped기 때문에 IOCP와도 호환.

### 6.2 CopyFileEx로 대용량 복사 + 진행률/취소

```cpp
static DWORD CALLBACK CopyProgress(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD         dwStreamNumber,
    DWORD         dwCallbackReason,
    HANDLE        hSourceFile,
    HANDLE        hDestinationFile,
    LPVOID        lpData)
{
    UNREFERENCED_PARAMETER(StreamSize);
    UNREFERENCED_PARAMETER(StreamBytesTransferred);
    UNREFERENCED_PARAMETER(dwStreamNumber);
    UNREFERENCED_PARAMETER(hSourceFile);
    UNREFERENCED_PARAMETER(hDestinationFile);

    auto* cancelFlag = reinterpret_cast<std::atomic<bool>*>(lpData);
    if (cancelFlag && cancelFlag->load())
        return PROGRESS_CANCEL;

    if (dwCallbackReason == CALLBACK_CHUNK_FINISHED ||
        dwCallbackReason == CALLBACK_STREAM_SWITCH)
    {
        if (TotalFileSize.QuadPart > 0) {
            double pct = (double)TotalBytesTransferred.QuadPart /
                         (double)TotalFileSize.QuadPart * 100.0;
            // TODO: UI에 진행률 반영
        }
    }
    return PROGRESS_CONTINUE;
}

bool CopyLargeFile(const std::wstring& src,
                   const std::wstring& dst,
                   std::atomic<bool>& cancelFlag)
{
    std::wstring s = NormalizeLongPath(src);
    std::wstring d = NormalizeLongPath(dst);

    return !!CopyFileExW(
        s.c_str(), d.c_str(),
        CopyProgress,
        &cancelFlag,
        FALSE,                       // 취소 이벤트 핸들 대신 콜백에서 cancelFlag 사용
        0);                          // COPY_FILE_NO_BUFFERING 등 옵션 필요 시 사용
}
```

### 6.3 순차 스트리밍 복사 예제 (직접 구현)

```cpp
struct CopyCtx {
    std::atomic<bool> cancel{ false };
    std::function<void(double)> onProgress;
};

bool CopyStreamed(const std::wstring& src,
                  const std::wstring& dst,
                  CopyCtx& ctx)
{
    std::wstring s = NormalizeLongPath(src);
    std::wstring d = NormalizeLongPath(dst);

    HANDLE hs = CreateFileW(s.c_str(),
        GENERIC_READ,
        FILE_SHARE_READ,
        nullptr, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        nullptr);
    if (hs == INVALID_HANDLE_VALUE)
        return false;

    HANDLE hd = CreateFileW(d.c_str(),
        GENERIC_WRITE,
        0, nullptr, CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        nullptr);
    if (hd == INVALID_HANDLE_VALUE) {
        CloseHandle(hs);
        return false;
    }

    LARGE_INTEGER sz{};
    GetFileSizeEx(hs, &sz);

    const DWORD CHUNK = 4 * 1024 * 1024;
    std::vector<BYTE> buf(CHUNK);

    LONGLONG done = 0;

    for (;;) {
        if (ctx.cancel.load()) {
            CloseHandle(hd);
            CloseHandle(hs);
            DeleteFileW(d.c_str());
            return false;
        }

        DWORD rd = 0;
        if (!ReadFile(hs, buf.data(), CHUNK, &rd, nullptr) || rd == 0)
            break;

        DWORD wr = 0;
        if (!WriteFile(hd, buf.data(), rd, &wr, nullptr) || wr != rd) {
            CloseHandle(hd);
            CloseHandle(hs);
            return false;
        }

        done += rd;
        if (ctx.onProgress && sz.QuadPart > 0) {
            ctx.onProgress((double)done / (double)sz.QuadPart);
        }
    }

    FlushFileBuffers(hd);
    CloseHandle(hd);
    CloseHandle(hs);
    return true;
}
```

여기에서 기대할 수 있는 처리량(단순 모델)은

$$
\text{Throughput} \approx
\frac{\text{복사한 바이트 수}}{\text{소요 시간(초)}}
$$

이며, 청크 크기·디스크 속도·CPU·백신·압축 여부 등 여러 요소에 의해 결정된다.

---

## 7. Overlapped I/O와 IOCP(개요)

큰 파일을 여러 개 동시에 처리하거나, 네트워크/디스크를 동시에 활용해야 하는 경우:

1. 파일을 `FILE_FLAG_OVERLAPPED` 로 연다.
2. 여러 개의 Overlapped 구조체를 준비한다.
3. `ReadFile`/`WriteFile` 을 Overlapped로 호출한 후 즉시 반환.
4. IOCP(Completion Port) 또는 `GetQueuedCompletionStatus` 로 완료를 수신한다.

간단한 패턴 예:

```cpp
HANDLE hFile = CreateFileW(path.c_str(),
    GENERIC_READ,
    FILE_SHARE_READ,
    nullptr, OPEN_EXISTING,
    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
    nullptr);

// IOCP 생성 및 hFile 등록
HANDLE hIOCP = CreateIoCompletionPort(hFile, nullptr, (ULONG_PTR)1, 0);

// Overlapped 요청
struct IOBlock {
    OVERLAPPED ov{};
    std::vector<BYTE> buf;
};

IOBlock block;
block.buf.resize(4*1024*1024);
block.ov.Offset = 0;
DWORD bytesRead = 0;

ReadFile(hFile, block.buf.data(), (DWORD)block.buf.size(), nullptr, &block.ov);

// 다른 작업 수행 ...

// 완료 대기
ULONG_PTR key;
LPOVERLAPPED pov = nullptr;
DWORD transferred = 0;
BOOL ok = GetQueuedCompletionStatus(hIOCP, &transferred, &key, &pov, INFINITE);
if (ok) {
    // transferred 바이트만큼 읽음
}
```

실제 IOCP 설계는 꽤 복잡해지므로, **데스크톱 앱**에서는 보통

- **CopyFileEx + UI 스레드 콜백**
- **백그라운드 워커 스레드 + 동기 I/O + 큰 청크**

만으로도 충분한 경우가 많다.

---

## 8. 메모리 매핑과 랜덤 액세스

### 8.1 전체 매핑 vs 부분 매핑

```cpp
struct MappedView {
    HANDLE hFile = nullptr;
    HANDLE hMap  = nullptr;
    BYTE*  base  = nullptr;
    size_t size  = 0;

    bool Open(const std::wstring& path, bool write)
    {
        std::wstring p = NormalizeLongPath(path);
        hFile = CreateFileW(p.c_str(),
            write ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
            FILE_SHARE_READ,
            nullptr, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            nullptr);
        if (hFile == INVALID_HANDLE_VALUE)
            return false;

        LARGE_INTEGER sz{};
        GetFileSizeEx(hFile, &sz);
        size = (size_t)sz.QuadPart;

        hMap = CreateFileMappingW(
            hFile, nullptr,
            write ? PAGE_READWRITE : PAGE_READONLY,
            sz.HighPart, sz.LowPart, nullptr);
        if (!hMap) {
            CloseHandle(hFile); hFile = nullptr;
            return false;
        }

        base = (BYTE*)MapViewOfFile(
            hMap,
            write ? FILE_MAP_WRITE : FILE_MAP_READ,
            0, 0, 0); // 전체 맵
        if (!base) {
            CloseHandle(hMap); hMap = nullptr;
            CloseHandle(hFile); hFile = nullptr;
            return false;
        }
        return true;
    }

    void Close()
    {
        if (base) { UnmapViewOfFile(base); base = nullptr; }
        if (hMap) { CloseHandle(hMap); hMap = nullptr; }
        if (hFile){ CloseHandle(hFile); hFile = nullptr; }
    }
};
```

- 작은/중간 크기 파일(수십~수백 MB)은 전체 매핑도 무리 없지만,
- 수십~수백 GB 파일은 **부분 매핑**이 필수.

### 8.2 부분 매핑의 정렬 규칙

Windows의 메모리 맵 뷰는 **AllocationGranularity** 단위로 정렬되어야 한다.

```cpp
SYSTEM_INFO si{};
GetSystemInfo(&si);
DWORD gran = si.dwAllocationGranularity; // 보통 64KB
```

예: `offset = 100MB`에 뷰를 만들고 싶다면,

- 실제 매핑 시작 오프셋 = `offsetRounded = (offset / gran) * gran`
- 뷰 내에서의 내부 오프셋 = `delta = offset - offsetRounded`

그리고 `MapViewOfFile` 호출 시 `offsetRounded`를 사용하고, 데이터 접근은 `base + delta`로 한다.

### 8.3 메모리 매핑의 장단점

- 장점
  - 코드가 단순 (포인터로 직접 접근).
  - OS가 자동으로 페이지 캐시/프리페칭 관리.
- 단점
  - 쓰기 오류 시 **Access Violation**으로 나타날 수 있어 예외 처리 필요.
  - 큰 파일 전체 매핑 시 가상 메모리/페이지 파일 사용량 관리에 신경 써야 한다.

---

## 9. 임시 파일 전략 — 위치, 이름, 용량, 정리

### 9.1 임시 파일 위치 결정

- **Atomic Save** 용 임시 파일
  - 항상 **최종 파일과 같은 디렉터리**에 생성해야 한다.  
    그래야 ReplaceFile/MoveFileEx가 **동일 볼륨 내 원자 교체**가 된다.
- 일반 임시 데이터
  - `%TEMP%` (`GetTempPathW`) 사용.
- 대용량 임시 데이터
  - 대상 볼륨의 여유 공간을 `GetDiskFreeSpaceExW`으로 확인 후, 용량이 충분한 볼륨 선택.

### 9.2 형제 임시 파일 생성

```cpp
std::wstring MakeSiblingTemp(const std::wstring& finalPath)
{
    std::filesystem::path p(finalPath);
    auto dir = p.parent_path();

    for (int i = 0; i < 100; ++i) {
        auto t = dir / (p.filename().wstring() +
                        L".tmp" + std::to_wstring(i));
        if (!std::filesystem::exists(t))
            return t.wstring();
    }

    // fallback: 시스템 TEMP 사용
    WCHAR tmpdir[MAX_PATH];
    GetTempPathW(MAX_PATH, tmpdir);
    WCHAR tmpfile[MAX_PATH];
    GetTempFileNameW(tmpdir, L"APP", 0, tmpfile);
    return tmpfile;
}
```

### 9.3 용량 예약(Preallocation)

```cpp
bool Preallocate(HANDLE h, LONGLONG size)
{
    LARGE_INTEGER li{};
    li.QuadPart = size;
    if (!SetFilePointerEx(h, li, nullptr, FILE_BEGIN))
        return false;

    return !!SetEndOfFile(h);
}
```

- 대용량 파일 생성 시 조각화를 줄이고, 디스크 부족을 **미리 탐지**하는 효과가 있다.

---

## 10. 락 전략 — 바이트 범위 락 + 네임드 뮤텍스

### 10.1 파일 내부 범위 보호 (LockFileEx)

```cpp
bool LockRange(HANDLE h, LONGLONG offset, LONGLONG len,
               bool exclusive, bool wait)
{
    OVERLAPPED ov{};
    ov.Offset     = (DWORD)(offset & 0xFFFFFFFF);
    ov.OffsetHigh = (DWORD)((offset >> 32) & 0xFFFFFFFF);

    DWORD flags = exclusive ? LOCKFILE_EXCLUSIVE_LOCK : 0;
    if (!wait)
        flags |= LOCKFILE_FAIL_IMMEDIATELY;

    return !!LockFileEx(
        h, flags,
        0,
        (DWORD)(len & 0xFFFFFFFF),
        (DWORD)((len >> 32) & 0xFFFFFFFF),
        &ov);
}

void UnlockRange(HANDLE h, LONGLONG offset, LONGLONG len)
{
    OVERLAPPED ov{};
    ov.Offset     = (DWORD)(offset & 0xFFFFFFFF);
    ov.OffsetHigh = (DWORD)((offset >> 32) & 0xFFFFFFFF);

    UnlockFileEx(
        h,
        0,
        (DWORD)(len & 0xFFFFFFFF),
        (DWORD)((len >> 32) & 0xFFFFFFFF),
        &ov);
}
```

패턴:

- 헤더/메타 영역(예: 처음 4KB)을 독점 락 → 헤더 갱신 중 다른 프로세스가 접근하지 못하게.
- 데이터 영역은 레코드 단위로 공유/독점 락 조합.

### 10.2 프로세스 전역 동기화 — 네임드 뮤텍스

```cpp
class ProcessMutex {
    HANDLE h = nullptr;
public:
    bool OpenOrCreate(const wchar_t* name) {
        h = CreateMutexW(nullptr, FALSE, name);
        return h != nullptr;
    }
    bool Lock(DWORD timeoutMs = INFINITE) {
        DWORD r = WaitForSingleObject(h, timeoutMs);
        return r == WAIT_OBJECT_0;
    }
    void Unlock() {
        if (h) ReleaseMutex(h);
    }
    ~ProcessMutex() {
        if (h) CloseHandle(h);
    }
};
```

- 예: `"Global\\Vendor_App_SaveMutex"` 같은 이름으로,
  - 단일 인스턴스 보장,
  - 동시에 두 앱이 같은 프로젝트 폴더를 열지 못하게 막는 등.

### 10.3 조합 전략

1. **모든 저장 작업 전**: 전역 뮤텍스 획득.
2. **파일별로**:
   - 헤더/인덱스를 업데이트할 때 헤더 영역 범위 락.
   - 특정 레코드를 수정할 때 해당 레코드 범위 락.
3. 작업 완료 후 범위 락 해제, 전역 뮤텍스도 해제.

---

## 11. 텍스트/바이너리/인코딩 – UTF-8/UTF-16, BOM, 줄바꿈

### 11.1 권장 인코딩 전략

- 내부 문자열: **UTF-16 (wchar_t, CStringW)**.
- 파일 포맷:
  - 설정/스크립트/텍스트 문서: **UTF-8** (BOM 유무는 명시적으로 결정).
  - 이진 포맷: 자체 헤더 + 바이트 배열(엔디언/버전 명시).

### 11.2 간단 UTF-8 저장 함수

```cpp
bool SaveUtf8(const std::wstring& path, std::string_view utf8, bool withBom = true)
{
    std::wstring p = NormalizeLongPath(path);

    HANDLE h = CreateFileW(
        p.c_str(),
        GENERIC_WRITE,
        0, nullptr,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        nullptr);

    if (h == INVALID_HANDLE_VALUE)
        return false;

    DWORD wr = 0;
    if (withBom) {
        static const BYTE bom[3] = {0xEF, 0xBB, 0xBF};
        if (!WriteFile(h, bom, 3, &wr, nullptr)) {
            CloseHandle(h);
            return false;
        }
    }

    if (!WriteFile(h, utf8.data(), (DWORD)utf8.size(), &wr, nullptr)) {
        CloseHandle(h);
        return false;
    }

    FlushFileBuffers(h);
    CloseHandle(h);
    return true;
}
```

### 11.3 UTF-8 변환 헬퍼(MFC/Win32)

```cpp
std::string WideToUtf8(const std::wstring& s)
{
    if (s.empty()) return {};
    int len = WideCharToMultiByte(
        CP_UTF8, 0, s.c_str(), (int)s.size(),
        nullptr, 0, nullptr, nullptr);
    std::string out(len, '\0');
    WideCharToMultiByte(
        CP_UTF8, 0, s.c_str(), (int)s.size(),
        &out[0], len, nullptr, nullptr);
    return out;
}

std::wstring Utf8ToWide(std::string_view s)
{
    if (s.empty()) return {};
    int len = MultiByteToWideChar(
        CP_UTF8, 0, s.data(), (int)s.size(),
        nullptr, 0);
    std::wstring out(len, L'\0');
    MultiByteToWideChar(
        CP_UTF8, 0, s.data(), (int)s.size(),
        &out[0], len);
    return out;
}
```

### 11.4 줄바꿈

- Windows 표준: `\r\n`
- Git/툴 호환으로 대부분 `\n`도 안전하지만, Win32 텍스트 모드(`CStdioFile::WriteString`)는 `\n` → `\r\n` 변환을 수행할 수 있으므로, **바이너리 쓰기**와 섞어 쓸 때 주의.

---

## 12. 로그/저널/롤백 전략

### 12.1 간단 로그 롤링(크기 기준)

```cpp
void AppendLog(const std::wstring& path,
               const std::wstring& line,
               size_t maxSizeBytes = 10 * 1024 * 1024)
{
    std::wstring p = NormalizeLongPath(path);

    // 롤링: 크기 초과 시 .1로 교체
    WIN32_FILE_ATTRIBUTE_DATA fad{};
    if (GetFileAttributesExW(p.c_str(), GetFileExInfoStandard, &fad)) {
        ULONGLONG size =
            ((ULONGLONG)fad.nFileSizeHigh << 32) | fad.nFileSizeLow;
        if (size > maxSizeBytes) {
            std::wstring bak = p + L".1";
            DeleteFileW(bak.c_str());
            MoveFileW(p.c_str(), bak.c_str());
        }
    }

    HANDLE h = CreateFileW(
        p.c_str(), FILE_APPEND_DATA,
        FILE_SHARE_READ,
        nullptr, OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        nullptr);
    if (h == INVALID_HANDLE_VALUE)
        return;

    std::string u8 = WideToUtf8(line);
    DWORD wr = 0;
    WriteFile(h, u8.data(), (DWORD)u8.size(), &wr, nullptr);
    WriteFile(h, "\r\n", 2, &wr, nullptr);
    CloseHandle(h);
}
```

### 12.2 저널(Journal) 기반 롤백

1. **저널 파일(.jnl)** 에 “무엇을 어떻게 변경할 예정인지” 기록.
2. 실제 데이터 파일에 변경 적용.
3. 성공하면 저널에 “COMMIT” 기록 후 저널 삭제.

간단한 형식 예:

```text
BEGIN
FILE=C:\data\project.bin
OLDHASH=...
NEWHASH=...
PATCH_OFFSET=...
PATCH_LENGTH=...
...
COMMIT
```

앱 시작 시:

- 미완료 저널(END/COMMIT 없음)이 있다면,
  - 데이터 파일을 `.bak`로 옮기고 사용자에게 “복구/롤백” 선택지를 제공하거나,
  - 가능한 범위에서 자동 롤백.

---

## 13. 보안/권한/무결성

### 13.1 DPAPI로 민감 데이터 보호

```cpp
#include <dpapi.h>
#pragma comment(lib, "Crypt32.lib")

bool ProtectUser(std::span<const BYTE> plain,
                 std::vector<BYTE>& out)
{
    DATA_BLOB in{ (DWORD)plain.size(), (BYTE*)plain.data() };
    DATA_BLOB enc{};

    BOOL ok = CryptProtectData(
        &in, L"", nullptr, nullptr, nullptr,
        0, &enc);
    if (!ok) return false;

    out.assign(enc.pbData, enc.pbData + enc.cbData);
    LocalFree(enc.pbData);
    return true;
}

bool UnprotectUser(std::span<const BYTE> blob,
                   std::vector<BYTE>& out)
{
    DATA_BLOB in{ (DWORD)blob.size(), (BYTE*)blob.data() };
    DATA_BLOB dec{};
    LPWSTR desc = nullptr;

    BOOL ok = CryptUnprotectData(
        &in, &desc, nullptr, nullptr, nullptr,
        0, &dec);
    if (desc) LocalFree(desc);
    if (!ok) return false;

    out.assign(dec.pbData, dec.pbData + dec.cbData);
    LocalFree(dec.pbData);
    return true;
}
```

- 사용자별 설정/토큰/키를 DPAPI로 암호화하여 저장하면,
  - 같은 PC의 같은 사용자만 복호화할 수 있다.

### 13.2 무결성 해시

큰 파일에 대해 SHA-256 등을 계산할 때도 스트리밍 패턴을 그대로 사용한다.

```cpp
// 의사 코드 – 실제로는 CryptoAPI/CNG나 외부 라이브러리 사용
bool HashFileSha256(const std::wstring& path,
                    BYTE outHash[32])
{
    HANDLE h = OpenForRead(path);
    if (!h) return false;

    const DWORD CHUNK = 4*1024*1024;
    std::vector<BYTE> buf(CHUNK);
    DWORD rd = 0;

    // InitSHA256();
    for (;;) {
        if (!ReadFile(h, buf.data(), CHUNK, &rd, nullptr) || rd == 0)
            break;
        // UpdateSHA256(buf.data(), rd);
    }
    CloseHandle(h);
    // FinalSHA256(outHash);
    return true;
}
```

---

## 14. 오류 처리와 UX – 디스크 부족/권한/충돌/백신

### 14.1 에러 메시지 문자열화

```cpp
std::wstring ExplainLastError(DWORD e = GetLastError())
{
    LPWSTR buf = nullptr;
    DWORD flags = FORMAT_MESSAGE_FROM_SYSTEM |
                  FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_IGNORE_INSERTS;

    DWORD len = FormatMessageW(
        flags, nullptr, e, 0,
        (LPWSTR)&buf, 0, nullptr);

    std::wstring s;
    if (len && buf) s.assign(buf, len);
    if (buf) LocalFree(buf);
    return s;
}
```

MFC에서:

```cpp
void ShowFileError(const CStringW& path, DWORD err)
{
    CStringW msg;
    msg.Format(L"파일 작업 실패:\n\n%s\n\n오류 코드: %lu\n\n%s",
        path.GetString(),
        err,
        ExplainLastError(err).c_str());
    AfxMessageBox(msg, MB_ICONERROR | MB_OK);
}
```

### 14.2 디스크 부족 시나리오

- 저장 전에 `GetDiskFreeSpaceExW`로 여유 공간 확인:
  - “필요한 최소 크기 + 여유 버퍼(예: 10%)”보다 작으면 미리 경고.
- Atomic Save 도중 실패 시:
  - 임시 파일·백업 파일은 그대로 두고,
  - 다음 실행 때 복구 마법사를 띄워 사용자가 선택하도록.

### 14.3 실시간 백신/인덱서 간섭

- 증상: 파일 닫자마자 곧바로 열려고 하면 “Access denied” 또는 공유 오류.
- 대응:
  - 100~200ms 간격으로 최대 N회 재시도.
  - 가급적 **파일을 너무 자주 열닫지 말고**, 핸들을 적당히 유지.

---

## 15. MFC 아키텍처 안에 녹이기

### 15.1 `CDocument::OnOpenDocument` 패턴

```cpp
BOOL CMyDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
    if (!CDocument::OnOpenDocument(lpszPathName))
        return FALSE;

    std::wstring path = lpszPathName;

    HANDLE h = OpenForRead(path);
    if (!h) {
        ShowFileError(lpszPathName, GetLastError());
        return FALSE;
    }

    // TODO: 헤더 파싱, 데이터 로딩(스트리밍/매핑 등)
    // this->m_model = ...

    CloseHandle(h);
    return TRUE;
}
```

### 15.2 `CDocument::OnSaveDocument` + AtomicSave

```cpp
BOOL CMyDoc::OnSaveDocument(LPCTSTR lpszPathName)
{
    std::wstring path = lpszPathName;

    bool ok = AtomicSave(path,
        [this](HANDLE h) -> bool
        {
            // this->m_model 을 바이너리/텍스트로 직렬화
            // 예: 큰 청크로 WriteFile
            DWORD wr = 0;
            // ... 직렬화 코드 ...
            // 전체 성공 시 true
            return true;
        });

    if (!ok) {
        ShowFileError(lpszPathName, GetLastError());
        return FALSE;
    }

    SetModifiedFlag(FALSE);
    return TRUE;
}
```

### 15.3 백그라운드 저장(자동 저장, 큰 파일)

- UI 멈춤을 피하기 위해 워커 스레드에서 I/O 수행:
  - `AfxBeginThread`로 워커 시작.
  - 저장 완료/실패는 `PostMessage`로 메인 스레드에 보고.
- 주의:
  - 스레드 간 공유 데이터(`m_model`)는 **스냅샷 복사** 또는 **락**을 이용.

---

## 16. 파일 감시/동기화 – ReadDirectoryChangesW

설정 파일이나 외부에서 수정되는 파일을 감지할 수 있다.

```cpp
void WatchFolder(const std::wstring& dir,
                 std::function<void()> onChange)
{
    std::wstring d = NormalizeLongPath(dir);
    HANDLE h = CreateFileW(
        d.c_str(),
        FILE_LIST_DIRECTORY,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        nullptr, OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
        nullptr);

    if (h == INVALID_HANDLE_VALUE)
        return;

    std::vector<BYTE> buf(64 * 1024);
    OVERLAPPED ov{};
    HANDLE ev = CreateEventW(nullptr, TRUE, FALSE, nullptr);
    ov.hEvent = ev;

    while (true) {
        DWORD ret = 0;
        BOOL ok = ReadDirectoryChangesW(
            h,
            buf.data(), (DWORD)buf.size(),
            TRUE,   // 서브디렉터리 포함
            FILE_NOTIFY_CHANGE_FILE_NAME |
            FILE_NOTIFY_CHANGE_LAST_WRITE |
            FILE_NOTIFY_CHANGE_SIZE,
            &ret, &ov, nullptr);

        if (!ok)
            break;

        DWORD w = WaitForSingleObject(ev, 5000);
        if (w == WAIT_OBJECT_0) {
            ResetEvent(ev);
            onChange();
        }
        // 종료 조건/플래그를 보고 break 하는 로직 추가 가능
    }

    CloseHandle(h);
    CloseHandle(ev);
}
```

---

## 17. QA 체크리스트

1. **전원 차단 시** 파일 손상 여부
   - 임시 + Atomic Save + FlushFileBuffers 조합 테스트.
2. **디스크 부족** 상황 재현
   - 가상 디스크/쿼터를 이용해 실패 경로 테스트.
3. **동시 접근(경합)** 시나리오
   - 두 프로세스에서 같은 파일을 열고 저장 시, 공유 모드/락이 의도대로 동작하는지 확인.
4. **대용량 파일(50GB+)**
   - 복사/해시/부분 읽기 속도, 메모리 사용량, 조각화 여부.
5. **긴 경로/UNC**
   - 260자 넘는 경로, `\\server\share` 경로, `\\?\UNC\...` 경로.
6. **권한/UAC**
   - Program Files, Windows 폴더 같은 보호된 위치에서 저장 실패 UX.
7. **백신/인덱서 간섭**
   - 실시간 백신 켠 상태에서 저장 직후 재열기.
8. **복구 시나리오**
   - .tmp/.bak/.jnl 파일이 남았을 때 사용자에게 “복구/롤백”을 어떻게 안내하는지.

---

## 18. 실무 레시피 요약

- **저장**  
  - `AtomicSave(final, writer)` 패턴으로 항상 임시 파일 → 원자 교체.
- **대용량 복사**  
  - `CopyFileEx` + 진행률 콜백 또는 4~8MB 청크 스트리밍.
- **랜덤 접근**  
  - 메모리 매핑(전체/부분 뷰) + 범위 락.
- **동시성**  
  - 네임드 뮤텍스(앱 전체) + LockFileEx(파일 내부 세분화).
- **성능 플래그**  
  - 순차/랜덤 힌트 정리, 필요 시 Overlapped, Write-Through는 “정말 필요할 때만”.
- **보안**  
  - DPAPI로 민감 데이터, SHA-256/CRC32로 무결성, ACL/권한 설계.
- **에러 복구**  
  - .tmp/.bak/.jnl 정책 + 사용자 메시지 + 자동 복구 루틴.

---

## 19. 마무리

- **임시 파일 → 원자 교체**는 “문서/프로젝트/설정”을 다루는 데스크톱 앱에서 사실상 **필수 안전망**이다.
- **큰 파일**은 청크 스트리밍 + 적절한 플래그/버퍼링만으로도 충분히 빠르고 안정적으로 처리할 수 있다.
- **락 전략**을 설계해 두면, 나중에 기능이 커져도 동시성 버그에 시달리지 않는다.
- 이 글의 스니펫과 패턴을 조합하면,  
  **문서형 에디터, 백업 도구, 미디어 처리기, 데이터 뷰어**까지  
  “**안전·성능·복구**” 관점에서 균형 잡힌 파일 I/O 파이프라인을 구축할 수 있다.
