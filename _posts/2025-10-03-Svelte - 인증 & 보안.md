---
layout: post
title: Svelte - 인증 & 보안
date: 2025-10-03 15:30:23 +0900
category: Svelte
---
# 9. 인증 & 보안
**세션/쿠키/토큰(JWT) 기초 · OAuth/OIDC(소셜 로그인) 흐름 · 서버 훅(`hooks.server.ts`) 가드 · CSRF/XSS/보안 헤더 · 비밀키 관리(.env)**

> 이 장은 **SvelteKit**에서 인증/인가를 안전하게 설계하는 실무 레퍼런스다.
> - **세션/쿠키/토큰(JWT)**의 차이점과 선택 기준
> - **OAuth/OIDC**(소셜 로그인) **Auth Code + PKCE** 플로우를 처음부터 구현하는 예시
> - **`hooks.server.ts`**에서 **가드(Guard)**와 **`handleFetch`**로 내부 API 보호
> - **CSRF/XSS** 방어, **CSP/HSTS/CORS/쿠키 속성** 등 **보안 헤더** 체크리스트
> - **비밀키 관리**: `.env`·서버 전용 모듈 분리·회전(Rotation) 전략

---

## 9.1 인증 모델 개요 — 세션 vs JWT, 언제 무엇을 쓸까?

### 9.1.1 용어 정리
- **인증(Authentication)**: “누구인가?”를 증명 (로그인)
- **인가(Authorization)**: “무엇을 할 수 있는가?” (권한/역할)
- **식별자(Subject, `sub`)**: 사용자 고유 ID
- **클레임(Claims)**: 사용자/권한/만료 등 부가 정보

### 9.1.2 세션(서버 상태) vs JWT(무상태)
- **세션 쿠키(서버 세션)**
  - 서버 저장소(메모리/Redis/DB)에 세션 레코드 → **쿠키에는 세션ID**만 저장
  - **장점**: 토큰 탈취 시 서버에서 **만료·폐기** 가능(강제 로그아웃 쉬움), 페이로드가 서버 밖으로 노출되지 않음
  - **단점**: 서버/캐시/스케일링 고려(세션 스토어 필요)
- **JWT(클라이언트 상태)**
  - 서버가 서명한 토큰을 **클라이언트가 보관**(대개 쿠키/스토리지)
  - **장점**: 서버 무상태(수평 확장 쉬움), **다중 서비스** 간 전달 편리
  - **단점**: **폐기/회수 어려움**(블랙리스트/버전 필드/단수 사용 원칙 필요), 잘못 쓰면 **XSS/CSRF에 취약**

> **실무 팁**
> - **웹 앱(SSR/폼 중심)**: **세션 쿠키**가 기본적으로 안전/단순.
> - **모바일/SPA + API 게이트웨이**: **단수(Short-lived) Access JWT + Refresh 토큰(쿠키) + 회전** 조합.
> - 어떤 방식을 선택해도 **쿠키는 `HttpOnly; Secure; SameSite=Lax(or Strict); Path=/`**가 기본.

---

## 9.2 세션 쿠키 구현 – 최소 안전 예제

### 9.2.1 서버 전용 모듈 – 세션 스토어
```ts
// src/lib/server/session.ts
import { randomBytes, createHmac, timingSafeEqual } from 'crypto';
import { env } from '$env/dynamic/private';

// 간단 예제: 메모리 스토어 (실무는 Redis/DB 사용)
const store = new Map<string, { uid: string; iat: number; data?: any }>();

const secret = env.SESSION_SECRET || 'dev-secret-change-me';
const sign = (v: string) => createHmac('sha256', secret).update(v).digest('base64url');

export function createSession(uid: string, data?: any, ttlSec = 60 * 60 * 24 * 7) {
  const sidRaw = randomBytes(18).toString('base64url');
  const sig = sign(sidRaw);
  const key = `${sidRaw}.${sig}`;
  store.set(sidRaw, { uid, iat: Date.now(), data });
  return { key, maxAge: ttlSec };
}

export function parseSession(cookieVal?: string) {
  if (!cookieVal) return null;
  const [sidRaw, sig] = cookieVal.split('.');
  if (!sidRaw || !sig) return null;
  const expected = sign(sidRaw);
  const ok = timingSafeEqual(Buffer.from(sig), Buffer.from(expected));
  if (!ok) return null;
  const rec = store.get(sidRaw);
  return rec ? { ...rec, sid: sidRaw } : null;
}

export function destroySession(sid: string) {
  store.delete(sid);
}
```

### 9.2.2 로그인/로그아웃 엔드포인트
```ts
// src/routes/api/auth/login/+server.ts
import type { RequestHandler } from './$types';
import { createSession } from '$lib/server/session';
import { fail, json } from '@sveltejs/kit';

export const POST: RequestHandler = async ({ request, cookies }) => {
  const fd = await request.formData();
  const email = String(fd.get('email') ?? '').trim();
  const pass = String(fd.get('password') ?? '');

  // TODO: DB에서 사용자 조회 + 해시 검증(아래 9.8 참고)
  if (email !== 'demo@example.com' || pass !== 's3cret') {
    return json({ message: 'invalid' }, { status: 401 });
  }

  const sess = createSession('user-123', { email });
  cookies.set('sid', sess.key, {
    path: '/',
    httpOnly: true,
    secure: true,
    sameSite: 'lax',
    maxAge: sess.maxAge
  });
  return json({ ok: true });
};
```

```ts
// src/routes/api/auth/logout/+server.ts
import type { RequestHandler } from './$types';
import { destroySession } from '$lib/server/session';

export const POST: RequestHandler = async ({ cookies }) => {
  const val = cookies.get('sid');
  if (val) {
    const [sid] = val.split('.');
    destroySession(sid);
  }
  cookies.delete('sid', { path: '/' });
  return new Response('ok');
};
```

---

## 9.3 JWT(Access / Refresh) – 회전(Rotation) 패턴

### 9.3.1 서명/검증 유틸
```ts
// src/lib/server/jwt.ts
import { createHmac, timingSafeEqual } from 'crypto';
import { env } from '$env/dynamic/private';

const secret = env.JWT_SECRET || 'dev-jwt-change';
const base64url = (b: Buffer) => b.toString('base64url');

function signHS256(header: any, payload: any) {
  const h = base64url(Buffer.from(JSON.stringify(header)));
  const p = base64url(Buffer.from(JSON.stringify(payload)));
  const sig = createHmac('sha256', secret).update(`${h}.${p}`).digest('base64url');
  return `${h}.${p}.${sig}`;
}

function verifyHS256(token: string) {
  const [h, p, s] = token.split('.');
  if (!h || !p || !s) return null;
  const expSig = createHmac('sha256', secret).update(`${h}.${p}`).digest('base64url');
  if (!timingSafeEqual(Buffer.from(s), Buffer.from(expSig))) return null;
  const payload = JSON.parse(Buffer.from(p, 'base64url').toString());
  if (payload.exp && Date.now() / 1000 > payload.exp) return null;
  return payload;
}

export const JWT = { signHS256, verifyHS256 };
```

### 9.3.2 발급/회전 플로우
- **Access**: **단수(짧게)** (예: 10~15분)
- **Refresh**: **더 길게**(예: 7~30일), **쿠키(HttpOnly)**로 저장, **회전**(사용시마다 갱신)
- 서버는 Refresh 토큰을 **화이트리스트(버전 필드)**로 관리

```ts
// src/lib/server/token.ts
import { JWT } from './jwt';
import { randomBytes } from 'crypto';

const whitelist = new Map<string, { uid: string; version: number }>();

export function mintTokens(uid: string) {
  const version = Math.floor(Math.random() * 1e9);
  const rid = randomBytes(18).toString('base64url');

  whitelist.set(rid, { uid, version });

  const now = Math.floor(Date.now()/1000);
  const access = JWT.signHS256({ alg: 'HS256', typ: 'JWT' }, { sub: uid, ver: version, iat: now, exp: now + 900 });
  const refresh = JWT.signHS256({ alg: 'HS256', typ: 'JWT' }, { sub: uid, rid, ver: version, iat: now, exp: now + 60*60*24*14 });

  return { access, refresh, rid, version };
}

export function rotateRefresh(refresh: string) {
  const payload = JWT.verifyHS256(refresh);
  if (!payload) return null;
  const { sub, rid, ver } = payload;
  const rec = whitelist.get(rid);
  if (!rec || rec.uid !== sub || rec.version !== ver) return null; // 취소/도난 방지
  whitelist.delete(rid); // 회전(이전 리프레시 무효)
  return mintTokens(sub);
}

export function revokeByRid(rid: string) { whitelist.delete(rid); }
```

엔드포인트:
```ts
// src/routes/api/auth/token/+server.ts
import type { RequestHandler } from './$types';
import { mintTokens, rotateRefresh } from '$lib/server/token';

export const POST: RequestHandler = async ({ request, cookies }) => {
  const body = await request.json();
  if (body.grant_type === 'password') {
    // TODO: 사용자 검증
    const { access, refresh } = mintTokens('user-123');
    cookies.set('refresh', refresh, { path:'/', httpOnly:true, secure:true, sameSite:'lax' });
    return new Response(JSON.stringify({ access }), { headers:{'content-type':'application/json'} });
  }
  if (body.grant_type === 'refresh_token') {
    const old = cookies.get('refresh');
    if (!old) return new Response('no refresh', { status: 401 });
    const rotated = rotateRefresh(old);
    if (!rotated) return new Response('invalid refresh', { status: 401 });
    cookies.set('refresh', rotated.refresh, { path:'/', httpOnly:true, secure:true, sameSite:'lax' });
    return new Response(JSON.stringify({ access: rotated.access }), { headers:{'content-type':'application/json'} });
  }
  return new Response('bad request', { status: 400 });
};
```

> **실무 포인트**
> - **Access는 메모리** 보관(스토리지 X, XSS 방어). 요청마다 `Authorization: Bearer`로 보냄.
> - Refresh는 **HttpOnly 쿠키**. **회전**으로 도난 감지/폐기.
> - 절대 **로컬스토리지에 장기 토큰** 저장하지 않는다.

---

## 9.4 OAuth/OIDC(소셜 로그인) — Authorization Code + PKCE

### 9.4.1 개념
- **Authorization Code + PKCE**: SPA/공개 클라이언트에도 안전.
- **state**: CSRF/세션 고정 방지.
- **nonce**: OIDC id_token 재생/변조 방지.
- **redirect_uri**: 화이트리스트 등록 필요.

### 9.4.2 PKCE 유틸
```ts
// src/lib/server/pkce.ts
import { createHash, randomBytes } from 'crypto';

export function pkcePair() {
  const verifier = randomBytes(32).toString('base64url');
  const challenge = createHash('sha256').update(verifier).digest('base64url');
  return { verifier, challenge };
}
```

### 9.4.3 시작: 공급자 로그인 페이지로 리다이렉트
```ts
// src/routes/auth/[provider]/start/+server.ts
import type { RequestHandler } from './$types';
import { pkcePair } from '$lib/server/pkce';
import { env } from '$env/dynamic/private';

const PROVIDERS = {
  google: {
    auth: 'https://accounts.google.com/o/oauth2/v2/auth',
    token: 'https://oauth2.googleapis.com/token',
    scope: 'openid email profile',
    client_id: env.GOOGLE_CLIENT_ID,
    client_secret: env.GOOGLE_CLIENT_SECRET
  }
};

export const GET: RequestHandler = async ({ params, cookies, url }) => {
  const p = PROVIDERS[params.provider as 'google'];
  if (!p) return new Response('unknown provider', { status: 404 });

  const { verifier, challenge } = pkcePair();
  const state = crypto.randomUUID();
  const nonce = crypto.randomUUID();

  cookies.set('oauth_state', state, { path:'/', httpOnly:true, secure:true, sameSite:'lax', maxAge:600 });
  cookies.set('oauth_verifier', verifier, { path:'/', httpOnly:true, secure:true, sameSite:'lax', maxAge:600 });
  cookies.set('oauth_nonce', nonce, { path:'/', httpOnly:true, secure:true, sameSite:'lax', maxAge:600 });

  const redirect_uri = `${url.origin}/auth/${params.provider}/callback`;
  const authUrl = new URL(p.auth);
  authUrl.searchParams.set('client_id', p.client_id);
  authUrl.searchParams.set('response_type', 'code');
  authUrl.searchParams.set('redirect_uri', redirect_uri);
  authUrl.searchParams.set('scope', p.scope);
  authUrl.searchParams.set('state', state);
  authUrl.searchParams.set('nonce', nonce);
  authUrl.searchParams.set('code_challenge', challenge);
  authUrl.searchParams.set('code_challenge_method', 'S256');

  return Response.redirect(authUrl.toString(), 302);
};
```

### 9.4.4 콜백: 코드→토큰 교환 + 사용자 식별
```ts
// src/routes/auth/[provider]/callback/+server.ts
import type { RequestHandler } from './$types';
import { env } from '$env/dynamic/private';

const P = {
  google: {
    token: 'https://oauth2.googleapis.com/token',
    userinfo: 'https://openidconnect.googleapis.com/v1/userinfo',
    client_id: env.GOOGLE_CLIENT_ID,
    client_secret: env.GOOGLE_CLIENT_SECRET
  }
};

export const GET: RequestHandler = async ({ url, params, cookies, fetch }) => {
  const prov = P[params.provider as 'google'];
  if (!prov) return new Response('unknown', { status: 404 });

  const code = url.searchParams.get('code');
  const state = url.searchParams.get('state');
  if (!code || !state) return new Response('bad request', { status: 400 });

  // CSRF
  const st = cookies.get('oauth_state');
  if (!st || st !== state) return new Response('state mismatch', { status: 400 });

  const verifier = cookies.get('oauth_verifier')!;
  const redirect_uri = `${url.origin}/auth/${params.provider}/callback`;

  // 코드 → 토큰
  const tokenRes = await fetch(prov.token, {
    method: 'POST',
    headers: { 'content-type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code, redirect_uri,
      client_id: prov.client_id,
      code_verifier: verifier,
      client_secret: prov.client_secret
    })
  });
  if (!tokenRes.ok) return new Response('token error', { status: 500 });
  const token = await tokenRes.json();

  // OIDC userinfo (id_token 검증이 이상적이나 예제에선 생략)
  const meRes = await fetch('https://openidconnect.googleapis.com/v1/userinfo', {
    headers: { 'authorization': `Bearer ${token.access_token}` }
  });
  const me = await meRes.json(); // { sub, email, name, picture, ... }

  // DB upsert(생략) 후 세션 발급
  const { createSession } = await import('$lib/server/session');
  const sess = createSession(me.sub, { email: me.email, name: me.name });

  cookies.set('sid', sess.key, { path:'/', httpOnly:true, secure:true, sameSite:'lax', maxAge: sess.maxAge });
  // 임시 쿠키 삭제
  cookies.delete('oauth_state', { path:'/' });
  cookies.delete('oauth_verifier', { path:'/' });
  cookies.delete('oauth_nonce', { path:'/' });

  return Response.redirect('/', 303);
};
```

> **보안 포인트**
> - **PKCE**(code_verifier/challenge) + **state** + **nonce**로 위조/재생 방지
> - **redirect_uri**는 공급자 콘솔 화이트리스트와 정확히 일치
> - id_token(JWT) **서명/nonce 검증**을 추가로 수행하면 더 안전

---

## 9.5 서버 훅: `hooks.server.ts`에서 가드/주입/프록시

### 9.5.1 사용자 주입(`handle`)
```ts
// src/hooks.server.ts
import type { Handle } from '@sveltejs/kit';
import { parseSession } from '$lib/server/session';

export const handle: Handle = async ({ event, resolve }) => {
  // 세션 파싱 → locals.user에 주입
  const sess = parseSession(event.cookies.get('sid'));
  if (sess) {
    event.locals.user = { id: sess.uid, email: sess.data?.email };
  } else {
    event.locals.user = null;
  }

  // 보안 헤더(기본 예시)
  const response = await resolve(event, {
    filterSerializedResponseHeaders(name) {
      // 데이터 유출 방지: 특정 헤더만 클라이언트로 전달 허용
      return ['content-type', 'cache-control'].includes(name.toLowerCase());
    }
  });

  response.headers.set('x-frame-options', 'DENY');
  response.headers.set('x-content-type-options', 'nosniff');
  response.headers.set('referrer-policy', 'strict-origin-when-cross-origin');
  // HSTS(HTTPS 배포 환경에서만)
  // response.headers.set('strict-transport-security', 'max-age=31536000; includeSubDomains; preload');

  return response;
};
```

> **`locals`**는 동일 요청 생명주기 동안 서버 전역으로 접근 가능(`load.server`, `+server.ts`, 액션 등).

### 9.5.2 내부 API에 자동 인증 부여(`handleFetch`)
```ts
// src/hooks.server.ts (동일 파일 안에)
export const handleFetch = async ({ event, request, fetch }) => {
  // 서버 내부 API로 향하는 요청이면 유저 콘텍스트 헤더 삽입(옵션)
  if (new URL(request.url).pathname.startsWith('/api/')) {
    const u = event.locals.user;
    if (u) {
      const headers = new Headers(request.headers);
      headers.set('x-user-id', u.id);
      request = new Request(request, { headers });
    }
  }
  return fetch(request);
};
```

> 인증 정보는 **쿠키 기반**이면 자동 전파되므로 보통 별도 헤더는 필요 없지만, **감사(로그)**나 **서비스 경계**에서 도움이 된다.

---

## 9.6 라우트 가드 – 보호된 페이지/엔드포인트

### 9.6.1 페이지 가드
```ts
// src/routes/app/+layout.server.ts
import { redirect } from '@sveltejs/kit';
export const load = async ({ locals }) => {
  if (!locals.user) throw redirect(303, '/login');
  return { user: locals.user };
};
```

### 9.6.2 엔드포인트 가드
```ts
// src/routes/api/private/+server.ts
import type { RequestHandler } from './$types';

export const GET: RequestHandler = async ({ locals }) => {
  if (!locals.user) return new Response('unauthorized', { status: 401 });
  return new Response(JSON.stringify({ secret: '42' }), { headers: { 'content-type': 'application/json' } });
};
```

---

## 9.7 CSRF 방어 — Double Submit Token 패턴

> **전제**: **SameSite=Lax**인 HttpOnly 쿠키는 **기본적인 CSRF 방어**에 크게 기여한다. 그러나 **크로스-사이트 POST**가 필요한 경우(또는 Lax를 완화하는 경우) **추가 토큰**을 사용하자.

### 9.7.1 토큰 발급
```ts
// src/lib/server/csrf.ts
import { randomBytes, timingSafeEqual, createHmac } from 'crypto';
import { env } from '$env/dynamic/private';

const secret = env.CSRF_SECRET || 'dev-csrf-change';
const mac = (v: string) => createHmac('sha256', secret).update(v).digest('base64url');

export function makeCSRF() {
  const token = randomBytes(18).toString('base64url');
  const sig = mac(token);
  return `${token}.${sig}`; // 서명된 토큰 (쿠키와 폼 양쪽에 동일)
}

export function verifyCSRF(v?: string) {
  if (!v) return false;
  const [t, s] = v.split('.');
  if (!t || !s) return false;
  const exp = mac(t);
  return timingSafeEqual(Buffer.from(s), Buffer.from(exp));
}
```

### 9.7.2 페이지에 주입(서버 load)
```ts
// src/routes/form/+page.server.ts
import type { PageServerLoad, Actions } from './$types';
import { makeCSRF, verifyCSRF } from '$lib/server/csrf';

export const load: PageServerLoad = async ({ cookies }) => {
  const csrf = makeCSRF();
  cookies.set('csrf', csrf, { path:'/', httpOnly:true, sameSite:'lax', secure:true });
  return { csrf };
};

export const actions: Actions = {
  default: async ({ request, cookies }) => {
    const fd = await request.formData();
    const formToken = String(fd.get('csrf') ?? '');
    const cookieToken = cookies.get('csrf');
    if (!verifyCSRF(formToken) || formToken !== cookieToken) {
      return new Response('CSRF', { status: 403 });
    }
    // 정상 처리...
    return { ok: true };
  }
};
```

```svelte
<!-- src/routes/form/+page.svelte -->
<script lang="ts"> export let data: { csrf: string };</script>
<form method="POST">
  <input type="hidden" name="csrf" value={data.csrf} />
  <button>Submit</button>
</form>
```

> **요점**: **Double Submit** — 동일 토큰을 **쿠키와 폼** 둘 다에 두고 **비교**. (SameSite=Lax와 함께 사용)

---

## 9.8 XSS/컨텐츠 보안 정책(CSP)

### 9.8.1 출력 살균(escape) & `{@html}` 주의
- 기본 템플릿 바인딩 `{value}`는 **자동 escape**
- **`{@html}`** 사용 시 **신뢰된/살균된 HTML만** 넣을 것(정말 불가피할 때만)

### 9.8.2 CSP 헤더 설정(Nonce 기반)
```ts
// src/hooks.server.ts (응답마다 nonce 생성)
export const handle: Handle = async ({ event, resolve }) => {
  const nonce = crypto.randomUUID().replace(/-/g, '');
  event.locals.cspNonce = nonce;

  const res = await resolve(event, {
    transformPageChunk: ({ html }) => html.replace('%cspnonce%', nonce)
  });

  const csp = [
    `default-src 'self'`,
    `script-src 'self' 'nonce-${nonce}'`,
    `style-src 'self' 'unsafe-inline'`, // CSS-in-JS가 필요 없다면 'self'로
    `img-src 'self' data:`,
    `connect-src 'self'`,
    `frame-ancestors 'none'`
  ].join('; ');

  res.headers.set('content-security-policy', csp);
  return res;
};
```

```html
<!-- src/app.html (SvelteKit) -->
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    %sveltekit.head%
  </head>
  <body data-sveltekit-preload-data="hover">
    <div style="display: contents">%sveltekit.body%</div>
    <!-- inline script가 필요하면 nonce 적용 -->
    <script nonce="%cspnonce%">/* minimal inline (지양) */</script>
  </body>
</html>
```

> **중요**: **`'unsafe-inline'` 스크립트 금지**, 외부 스크립트는 해시/nonce, CDN은 **서브리소스 무결성(SRI)** 고려.

---

## 9.9 보안 헤더 모음(Cheat Sheet)

- `Strict-Transport-Security: max-age=31536000; includeSubDomains; preload` (HTTPS 전제)
- `X-Frame-Options: DENY` (클릭재킹 방지)
- `X-Content-Type-Options: nosniff` (MIME 스니핑 방지)
- `Referrer-Policy: strict-origin-when-cross-origin`
- `Permissions-Policy: geolocation=(), camera=(), microphone=()` (필요 권한만 허용)
- `Content-Security-Policy: ...` (위 섹션 참고)
- **쿠키**: `HttpOnly; Secure; SameSite=Lax|Strict; Path=/; Max-Age=...`
- **CORS**(외부에서 API 호출 필요 시):
  - `Access-Control-Allow-Origin: https://trust.example`
  - `Access-Control-Allow-Credentials: true` (쿠키 기반이면)
  - `Vary: Origin`

> **주의**: `Access-Control-Allow-Origin: *` + Credentials는 **불가**. 출처를 명시해야 한다.

---

## 9.10 비밀키(.env) & 서버 전용 모듈

### 9.10.1 분리 & 접근
- **서버 전용**: `$env/dynamic/private`, `$env/static/private`
- **클라이언트 허용**: `$env/dynamic/public`, `$env/static/public` (접두사 `PUBLIC_`)

```ts
// src/lib/server/mail.ts
import { env } from '$env/dynamic/private';
export async function sendMail(to: string, body: string) {
  // env.MAIL_TOKEN 사용
}
```

> 클라이언트 코드(`.svelte`, `+page.ts`)에서 **server 모듈을 import하지 않는다**.

### 9.10.2 키 회전 전략
- **버전 필드**(세션/JWT)에 포함 → 키 교체 후 **이중 검증 기간** 운영
- 오래된 토큰/세션을 **자동 만료** 또는 **점진 폐기**

---

## 9.11 암호 저장(해시) — bcrypt/argon2

```ts
// src/lib/server/hash.ts
import { randomBytes, scryptSync, timingSafeEqual } from 'crypto';

export function hash(password: string) {
  const salt = randomBytes(16);
  const digest = scryptSync(password, salt, 64);
  return `${salt.toString('base64')}.${digest.toString('base64')}`;
}
export function verify(password: string, hashStr: string) {
  const [saltB64, digestB64] = hashStr.split('.');
  const salt = Buffer.from(saltB64, 'base64');
  const digest = Buffer.from(digestB64, 'base64');
  const test = scryptSync(password, salt, 64);
  return timingSafeEqual(test, digest);
}
```

> 실무에서는 **argon2id** 또는 **bcrypt(적정 cost)**를 추천. (Node 네이티브 모듈/워커풀 고려)

---

## 9.12 감사 로깅/레이트 리미팅/브루트포스 방지

### 9.12.1 간단 레이트 리미팅(메모리 예제)
```ts
// src/lib/server/rate.ts
const bucket = new Map<string, { count: number; reset: number }>();
export function hit(ip: string, limit = 20, windowMs = 60_000) {
  const now = Date.now();
  const r = bucket.get(ip) ?? { count: 0, reset: now + windowMs };
  if (now > r.reset) { r.count = 0; r.reset = now + windowMs; }
  r.count++; bucket.set(ip, r);
  return { allowed: r.count <= limit, remaining: Math.max(0, limit - r.count), reset: r.reset };
}
```

```ts
// src/routes/api/auth/login/+server.ts (앞선 예제에 적용)
import { hit } from '$lib/server/rate';
export const POST = async ({ request, getClientAddress }) => {
  const { allowed, remaining } = hit(getClientAddress(), 10, 60_000);
  if (!allowed) return new Response('Too Many', { status: 429 });
  // ... 나머지 로그인 처리
};
```

---

## 9.13 UI/UX: 로그인 흐름, 에러, 리다이렉트

### 9.13.1 페이지 전환 UX
- 로그인 성공 시 **303 Redirect**(PRG 패턴)
- 에러는 `fail(400, { message })`로 폼에 되돌려 보여주기

```ts
// src/routes/login/+page.server.ts
import type { Actions } from './$types';
import { fail, redirect } from '@sveltejs/kit';
import { createSession } from '$lib/server/session';

export const actions: Actions = {
  default: async ({ request, cookies }) => {
    const fd = await request.formData();
    const email = String(fd.get('email') ?? '');
    const pass = String(fd.get('password') ?? '');
    if (!email || !pass) return fail(400, { message: 'Required', values: Object.fromEntries(fd) });

    // TODO: 인증
    const sess = createSession('user-123', { email });
    cookies.set('sid', sess.key, { path:'/', httpOnly:true, secure:true, sameSite:'lax', maxAge:sess.maxAge });

    throw redirect(303, '/app');
  }
};
```

```svelte
<!-- src/routes/login/+page.svelte -->
<script lang="ts"> export let form; </script>
<form method="POST">
  <input name="email" value={form?.values?.email ?? ''} />
  <input type="password" name="password" />
  {#if form?.message}<p style="color:#b00020">{form.message}</p>{/if}
  <button>Login</button>
</form>
```

---

## 9.14 통합 예시 — “보호된 대시보드 + API”

### 9.14.1 가드 레이아웃
```ts
// src/routes/app/+layout.server.ts
import { redirect } from '@sveltejs/kit';
export const load = async ({ locals }) => {
  if (!locals.user) throw redirect(303, '/login');
  return { user: locals.user };
};
```

```svelte
<!-- src/routes/app/+layout.svelte -->
<script lang="ts"> export let data: { user: { id:string; email:string } };</script>
<nav>
  <span>Welcome, {data.user.email}</span>
  <form method="POST" action="/api/auth/logout"><button>Logout</button></form>
</nav>
<slot/>
```

### 9.14.2 보호된 API
```ts
// src/routes/api/app/data/+server.ts
import type { RequestHandler } from './$types';
export const GET: RequestHandler = async ({ locals }) => {
  if (!locals.user) return new Response('unauthorized', { status: 401 });
  return new Response(JSON.stringify({ records: [1,2,3], uid: locals.user.id }), { headers: { 'content-type':'application/json' } });
};
```

### 9.14.3 페이지
```ts
// src/routes/app/+page.ts
import type { PageLoad } from './$types';
export const load: PageLoad = async ({ fetch }) => {
  const data = await fetch('/api/app/data').then(r=>r.json());
  return { data };
};
```

```svelte
<!-- src/routes/app/+page.svelte -->
<script lang="ts"> export let data: { data: any };</script>
<h1>Dashboard</h1>
<pre>{JSON.stringify(data.data, null, 2)}</pre>
```

---

## 9.15 체크리스트(요약)

- [ ] **세션 쿠키**: `HttpOnly; Secure; SameSite=Lax/Strict; Path=/; Max-Age`
- [ ] **JWT**: **단수 Access + Refresh(쿠키) 회전**; Access는 **메모리 보관**
- [ ] **OAuth/OIDC**: **PKCE + state + nonce**, redirect_uri 화이트리스트
- [ ] **`hooks.server.ts`**: `locals.user` 주입, 보안 헤더, `handleFetch`로 내부 API 보호
- [ ] **라우트 가드**: 보호 구간은 `+layout.server.ts`에서 `redirect`
- [ ] **CSRF**: SameSite + **Double Submit Token**
- [ ] **XSS**: `{@html}` 최소화, **CSP Nonce/Hash**, SRI
- [ ] **보안 헤더**: HSTS, XFO, X-CTO, Referrer-Policy, Permissions-Policy
- [ ] **비밀키**: `.env` + **서버 전용 모듈**; 키 **회전** 계획
- [ ] **레이트 리미팅**: 로그인/민감 API에 적용, 감사 로깅
- [ ] **에러/UX**: `fail`로 폼 값 보존, 성공 시 **303 리다이렉트**(PRG)

---

## 9.16 마무리
- **웹 앱**은 기본적으로 **세션 쿠키**가 안전/단순하며 SSR과 궁합이 좋다.
- **API/모바일/멀티 서비스**는 **짧은 Access JWT + Refresh 회전**을 검토하자.
- 어떤 방식이든 **훅에서 가드/보안 헤더**를 일관되게 적용하고, **CSRF/XSS**를 먼저 차단하라.
- **비밀키/환경변수**는 서버 전용 경계 안으로, **키 회전**과 **레이트 리미팅**을 계획에 넣자.
- OAuth/OIDC는 **PKCE + state + nonce**가 핵심. 공급자별 설정/리다이렉트 URI를 정확히 관리하자.
