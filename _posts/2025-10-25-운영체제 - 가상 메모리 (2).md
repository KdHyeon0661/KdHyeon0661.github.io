---
layout: post
title: 운영체제 - 가상 메모리 (2)
date: 2025-10-25 17:30:23 +0900
category: 운영체제
---
# Page Replacement • Allocation of Frames • Thrashing

## Page Replacement (교체 알고리즘)

### 문제 정의

- **목표**: 제한된 물리 프레임 수에서 **페이지 폴트 수를 최소화**.
- **입력**: 페이지 참조 시퀀스 \( R = \langle r_1, r_2, \dots \rangle \), 프레임 수 \( F \).
- **출력**: 폴트 발생 시 퇴출할 페이지 선택 정책.

**평가 지표**
- **Faults**(총 폴트 수), **Miss ratio** \( = \frac{\text{faults}}{|R|} \)
- **Hit ratio**, **EAT**(유효 접근 시간), **I/O** 횟수.

---

### 기준 알고리즘들

#### (A) OPT(MIN, Belady’s optimal)

- **정의**: 앞으로 가장 **오래 후에** 참조될 페이지를 교체.
- **성질**: **이상적인 하한**(현실 구현 불가), **스택 알고리즘** → **Belady anomaly 없음**.
- **용도**: 다른 정책들의 **비교 기준**.

```python
# opt_lru_fifo_clock.py — 여러 교체정책 시뮬

from collections import deque, defaultdict, OrderedDict

def run_opt(seq, frames):
    inmem, pos = set(), defaultdict(deque)
    for i,p in enumerate(seq): pos[p].append(i)
    mem, faults = set(), 0
    for i,p in enumerate(seq):
        pos[p].popleft()  # 현재 참조 제거
        if p in mem:
            continue
        faults += 1
        if len(mem) < frames:
            mem.add(p); continue
        # 교체: 미래 사용이 가장 늦은(또는 없는) 페이지
        victim, far = None, -1
        for q in mem:
            nxt = pos[q][0] if pos[q] else float('inf')
            if nxt > far: far, victim = nxt, q
        mem.remove(victim); mem.add(p)
    return faults
```

#### (B) FIFO

- 들어온 순서대로 가장 오래된 페이지를 퇴출.
- **간단**하지만 **Belady anomaly** 존재(프레임을 늘려도 폴트↑ 가능).

```python
def run_fifo(seq, frames):
    q, s, faults = deque(), set(), 0
    for p in seq:
        if p not in s:
            faults += 1
            if len(q) == frames:
                v = q.popleft(); s.remove(v)
            q.append(p); s.add(p)
    return faults
```

#### (C) LRU (Least Recently Used)

- **최근에 가장 오래 접근되지 않은** 페이지를 퇴출.
- **지역성** 가정과 맞아 현실적으로 좋은 근사.
- 구현: **카운터/스택/해시+리스트**(오버헤드) 또는 **하드웨어 참조비트**로 근사.

```python
def run_lru(seq, frames):
    # OrderedDict로 최근 사용 갱신
    od, faults = OrderedDict(), 0
    for p in seq:
        if p in od:
            od.move_to_end(p)        # 최근 사용
        else:
            faults += 1
            if len(od) == frames:
                od.popitem(last=False) # LRU victim
            od[p] = True
    return faults
```

#### (D) Second-Chance / Clock

- FIFO를 보완. **참조비트** \(R\) 있으면 한 번 기회를 주고 0으로 리셋.
- **Clock**: 원형 버퍼 + 포인터(“시계 바늘”).

```python
def run_clock(seq, frames):
    frame = [-1]*frames
    R = [0]*frames
    hand = 0; faults = 0
    for p in seq:
        if p in frame:
            R[frame.index(p)] = 1
            continue
        faults += 1
        while True:
            if frame[hand] == -1:
                frame[hand] = p; R[hand] = 1; hand=(hand+1)%frames; break
            if R[hand] == 0:
                frame[hand] = p; R[hand] = 1; hand=(hand+1)%frames; break
            R[hand] = 0
            hand = (hand+1)%frames
    return faults
```

#### (E) LFU / MFU

- **LFU**: 참조 횟수 가장 적은 페이지 퇴출(오래된 히트 편향으로 **고착** 가능).
- **MFU**: 가장 많이 참조된 페이지가 “더 이상 필요 없을 수도”라는 가정(특수한 경우만).

```python
def run_lfu(seq, frames):
    cnt = defaultdict(int); mem=set(); faults=0
    for p in seq:
        cnt[p]+=1
        if p in mem: continue
        faults+=1
        if len(mem)<frames: mem.add(p); continue
        victim = min(mem, key=lambda x:(cnt[x], x))
        mem.remove(victim); mem.add(p)
    return faults
```

#### (F) NRU (Not Recently Used, Enhanced Second-Chance)

- **(R, D)** 비트로 4분류: (0,0) → (0,1) → (1,0) → (1,1) 우선 교체.
- **주기적**으로 \(R\)을 0으로 클리어해 계층을 리프레시.

---

### 스택 알고리즘과 Belady anomaly

- **스택 알고리즘**: 프레임 수가 증가할수록 **메모리 집합이 포함 관계**를 유지 → 폴트 수 **비증가**.
- **LRU/OPT**는 스택 알고리즘, **FIFO/LFU**는 일반적으로 **아님** → **Belady anomaly** 가능.

---

### 참조 스트링 사례 비교

```python
if __name__ == "__main__":
    seq = [7,0,1,2,0,3,0,4,2,3,0,3,2]
    for f in (3,4):
        print(f"F={f}  OPT={run_opt(seq,f)}  LRU={run_lru(seq,f)}  CLOCK={run_clock(seq,f)}  FIFO={run_fifo(seq,f)}  LFU={run_lfu(seq,f)}")
```

**해설 포인트**
- `F=3`에서 FIFO가 `F=4`보다 **폴트가 더 적을 수도** → Belady anomaly 확인.
- LRU/CLOCK이 실무에서 **안정적으로 우수**한 편.

---

### 하드웨어 지원과 현실 구현

- **참조비트(Accessed/Referenced, A/AF)**, **더티비트(D)** → NRU/Clock 구현에 필수.
- **Page Walk Cache**, **TLB** → 미스시 다단계 테이블 접근 비용 상쇄.
- **Huge Page**: TLB 커버리지↑ ↔ 내부 단편화/복사비용 트레이드오프.

---

## Allocation of Frames (프레임 할당)

### 전역 vs 지역 교체

- **Global replacement**: 프로세스 간 **프레임 풀 공유**, 폴트 시 **다른 프로세스** 페이지를 뺏을 수 있음 → **높은 활용성**, 그러나 **간섭**으로 예측 어려움.
- **Local replacement**: 각 프로세스에 **고정된 resident set**. 예측 용이, **격리** 좋음, 유휴 프레임 활용도↓.

### 프레임 배분 정책

#### (A) 균등 할당(Equal)

- \(N\)개 프로세스, 총 \(F\) 프레임 → 프로세스당 \( \lfloor F/N \rfloor \).

#### (B) 비례 할당(Proportional)

- 각 프로세스의 **가상 메모리 크기/우선순위**에 비례해 프레임 할당.
- 예: \( frames_i = \left\lfloor \frac{S_i}{\sum_j S_j} \cdot F \right\rfloor \)

#### (C) 우선순위 할당(Priority)

- 우선순위 높은 프로세스의 폴트 시 **낮은 우선순위** 프로세스의 프레임을 회수(글로벌 치환).

#### (D) 최소 보장(Minimum) + 글로벌 여유

- 각 프로세스 **최소 프레임 수** 보장(예: 3~4), 나머지는 **글로벌 풀**로 탄력 배분.

#### (E) NUMA 고려

- 프레임은 **로컬 노드**에서 우선 할당(퍼스트 터치). 교체/이동 시 **원격 접근 비용** 고려.

---

### Working Set Model (Denning)

- **정의**: 시간 창 \( \Delta \) 내에 참조된 페이지 집합 \( W(t,\Delta) \) → **현재 작업 집합**.
- **목표**: 각 프로세스에 \( |W| \) 이상 프레임을 주면 폴트율 급감.
- **합** \( \sum_i |W_i| \) 가 총 프레임 \(F\)를 초과하면 **스로싱** 위험 → **정도(Multiprogramming degree)** 축소 필요.

```python
# working_set_est.py — 최근 W 창으로 근사적 working set 크기 추정

from collections import deque
def working_set_len(seq, window):
    s, q, res = set(), deque(), []
    for p in seq:
        q.append(p); s.add(p)
        if len(q)>window:
            old = q.popleft()
            if old not in q: s.remove(old)
        res.append(len(s))
    return res
```

---

### Page-Fault Frequency (PFF) 제어

- **아이디어**: 폴트 간격이 너무 짧으면 프레임↑, 너무 길면 프레임↓.
- **장점**: 파라미터 \(\Delta\) 선택 난해 문제를 우회, **적응적**.

```python
# pff_control.py — 단순 PFF 제어 스케치

def pff_control(fault_times, low=10, high=100):
    # fault_times: 폴트 발생 시각 리스트(단위 임의)
    # 인접 폴트 간격이 high보다 길면 프레임↓, low보다 짧으면 프레임↑
    actions=[]
    for i in range(1,len(fault_times)):
        gap = fault_times[i]-fault_times[i-1]
        if gap < low: actions.append("INC")
        elif gap > high: actions.append("DEC")
        else: actions.append("HOLD")
    return actions
```

---

### 최소 프레임 수 제약

- CPU 아키텍처/OS는 **명령 실행에 필요한 최소 페이지 수**가 있음(예: 명령, 오퍼랜드, 스택 등).
- 예: **인스트럭션 fetch + 데이터 + 스택** → 최소 3~4프레임 필요.

---

## Thrashing (스로싱)

### 정의와 증상

- **정의**: 프로세스(혹은 시스템 전체)가 **지속적인 페이지 폴트**로 대부분의 시간을 **I/O 대기**에 소비하여 **처리량이 극적으로 감소**하는 상태.
- **증상**: CPU 사용률↓, 디스크 I/O↑(pgpgin/pgpgout 폭증), 평균 지연↑, 런큐 길이 낮음.

### 원인

- **Resident set**이 **작업 집합**보다 작을 때.
- **Global replacement**에서 프로세스 간 **프레임 쟁탈**이 심할 때.
- **멀티프로그래밍 정도**가 과도하게 높을 때(동시 실행 프로세스 과다).

### 수학적 직관

- 페이지 폴트 확률 \(p\)와 디스크 지연 \(D\)가 클수록 \(EAT\) 상승:
  $$
  EAT \approx h(t+m) + (1-h)(t+2m) + pD,\quad \text{where } D \gg m.
  $$
- 스로싱 영역에선 \(p\)가 커져 \(pD\) 항이 **지배적**.

### 탐지/진단

- **OS 지표**: `vmstat`, `sar -B`, `/proc/vmstat`: `pgfault/majflt`, `pswpin/out`, `pgscan`, `kswapd`.
- **관측 패턴**: CPU idle↑ + context switch↓ + 디스크 큐↑.
- **PFF/Working set** 기반 추정: **폴트 간격 분포**가 아주 짧게 몰림.

```python
# thrashing_synth.py — 작은 프레임으로 큰 순환 워크셋을 접근하여 스로싱 유도

def simulate_seq(n_pages, frames, rounds=100):
    # 워크셋 = n_pages, 프레임 << n_pages → 거의 매 참조 폴트
    seq = list(range(n_pages))*rounds
    return {
        "FIFO": run_fifo(seq, frames),
        "LRU" : run_lru(seq, frames),
        "CLK" : run_clock(seq, frames)
    }
print(simulate_seq(n_pages=64, frames=8))
```

---

### 해결/완화 전략

#### (A) 멀티프로그래밍 정도(MPD) 조절

- 총 working set 추정 \( \sum_i |W_i| \) 가 **총 프레임 \(F\)** 를 넘으면 **일부 프로세스 일시 중지**(스와핑) 또는 시작 지연.

#### (B) Resident Set 관리

- **Local replacement** 채택, 프로세스별 **min/max 프레임** 설정.
- **PFF 제어**: 폴트 간격이 짧은 프로세스에 프레임 추가, 긴 프로세스에서 회수.

#### (C) 접근 패턴 개선/힌트

- **순차 접근**: OS가 리드어헤드로 도움.
- **랜덤 접근**: `mlock`/`madvise(MADV_WILLNEED)` 등으로 필요한 데이터 **선제 적재**.
- **COW** 남발로 초기 쓰기 폭발을 유발하지 않도록 배치.

#### (D) 저장장치/메모리 계층 최적화

- **zswap/zram**: 스왑 I/O 감소.
- **Huge Page**: TLB 미스와 페이지 테이블 워크↓(내부 단편화와 균형).
- **NUMA 바인딩**: 원격 메모리 접근 최소화.

---

## 통합 실습: 정책 비교와 스로싱 경계 찾기

```python
# lab_vm.py — 정책/프레임/워크셋 스윕 실험

import random
def random_workload(unique_pages=64, length=5000, locality=0.9, window=8):
    seq=[]; cur=random.randrange(unique_pages)
    for _ in range(length):
        if random.random()<locality:
            cur = (cur + random.randint(1,window)) % unique_pages
        else:
            cur = random.randrange(unique_pages)
        seq.append(cur)
    return seq

def compare(seq, frames_list=(4,8,12,16)):
    algs = {"OPT":run_opt,"LRU":run_lru,"CLOCK":run_clock,"FIFO":run_fifo,"LFU":run_lfu}
    res={}
    for f in frames_list:
        res[f]={name:fn(seq,f) for name,fn in algs.items()}
    return res

if __name__=="__main__":
    seq = random_workload(unique_pages=128, length=20000, locality=0.95, window=4)
    table = compare(seq, frames_list=(4,8,12,16,24,32))
    for f,row in table.items():
        print(f"Frames={f}:", row)
```

**관찰 가이드**
- **LRU/Clock** vs **FIFO/LFU**: 프레임 증가 시 비증가 여부(스택성) 비교.
- 프레임 수를 줄이며 **스로싱 임계점** 확인(폴트/접근 비율이 급상승하는 구간).

---

## 운영 체크리스트

1) **교체 정책**: LRU 근사(Clock/Second-Chance/NRU) 기본, 더티-우선/클린 선호 정책 튜닝.
2) **프레임 배분**: 최소 보장 + 글로벌 여유, 우선순위/비례 가중치.
3) **스로싱 방지**: MPD 제한, PFF/WS 추정, 프로세스 일시중지/재개 정책.
4) **힌트 API**: `madvise`, `mlock`, `posix_fadvise`, 파일 접근 패턴 최적화.
5) **TLB/페이지 크기**: THP/HugeTLB 정책(`always/madvise/never`), 워크로드별 AB 테스트.
6) **관측**: `vmstat`, `sar -B`, `perf`(page-faults, major-faults), cgroup 메모리/스왑 지표.
7) **NUMA**: 퍼스트-터치, 바인딩, 인터리빙 전략.

---

## 핵심 요약

- **10.4 교체**: OPT는 하한, 실무는 **LRU 근계열(Clock/NRU)** 이 주력. **Belady anomaly**는 FIFO 등 비스택 알고리즘에서 발생.
- **10.5 프레임 할당**: **Global vs Local** 선택, **Working Set**/**PFF**로 적응적 배분. 최소 프레임 보장과 NUMA 고려가 중요.
- **10.6 스로싱**: 폴트 주도 I/O로 처리량 붕괴. **MPD 조절, WS/PFF 기반 제어, 힌트/대페이지/NUMA**로 방지·완화.
