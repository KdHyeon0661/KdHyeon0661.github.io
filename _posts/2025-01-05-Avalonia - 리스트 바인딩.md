---
layout: post
title: Avalonia - 리스트 바인딩
date: 2025-01-05 19:20:23 +0900
category: Avalonia
---
# Avalonia에서 리스트(ListBox/ListView) 바인딩하기

## 1. 목표와 기본 개념 정리

- ViewModel은 `ObservableCollection<T>`로 리스트를 관리한다.
- View는 `ListBox`(또는 `ListView`)의 `Items`/`ItemsSource`에 바인딩하고, 선택은 `SelectedItem`(또는 `SelectedItems`)으로 바인딩한다.
- `DataTemplate`으로 각 항목의 UI를 자유롭게 구성한다.
- “테이블(헤더/열)”이 필요하면 **ListBox(또는 ListView) + 템플릿** 조합 대신 **DataGrid**를 고려한다.

---

## 2. 예제 디렉토리

```
MyAvaloniaApp/
├── Models/
│   └── Person.cs
├── ViewModels/
│   └── PeopleViewModel.cs
└── Views/
    └── PeopleView.axaml
```

---

## 3. Model — 불변(Immutable)과 가변(Mutable) 중 선택

초안은 set 접근자 기반(가변)을 사용하였다. **양방향 편집**이 자연스러운 UI에는 가변 모델이 실용적이다.  
대신 “참조 동일성 문제”나 “부분 변경 추적”이 까다로운 경우 **불변 + 교체**가 깔끔하다(성능/메모리 트레이드오프).

### 3.1 가변형 예시(초안 유지)

```csharp
public class Person
{
    public string Name { get; set; }    // 단순 데모: set 허용
    public int Age { get; set; }
}
```

### 3.2 불변형 예시(선택)

```csharp
public sealed class Person
{
    public string Name { get; }
    public int Age { get; }

    public Person(string name, int age) { Name = name; Age = age; }
    public Person With(string? name = null, int? age = null)
        => new(name ?? Name, age ?? Age);
}
```

---

## 4. ViewModel — 단일 선택/다중 선택, 필터, 추가/삭제, 선택 인덱스

아래는 **ReactiveUI** 기반 예시다. 동일 구조를 **CommunityToolkit.Mvvm**으로도 쉽게 바꿀 수 있다(§9 참고).

```csharp
using ReactiveUI;
using System.Collections.ObjectModel;

public class PeopleViewModel : ReactiveObject
{
    public ObservableCollection<Person> People { get; } = new();

    private Person? _selectedPerson;
    public Person? SelectedPerson
    {
        get => _selectedPerson;
        set => this.RaiseAndSetIfChanged(ref _selectedPerson, value);
    }

    // 선택 인덱스를 쓰고 싶다면
    private int _selectedIndex = -1;
    public int SelectedIndex
    {
        get => _selectedIndex;
        set => this.RaiseAndSetIfChanged(ref _selectedIndex, value);
    }

    // 입력(추가용)
    private string _nameInput = "";
    public string NameInput
    {
        get => _nameInput;
        set => this.RaiseAndSetIfChanged(ref _nameInput, value);
    }

    private string _ageInput = "";
    public string AgeInput
    {
        get => _ageInput;
        set => this.RaiseAndSetIfChanged(ref _ageInput, value);
    }

    public PeopleViewModel()
    {
        People.Add(new Person { Name = "홍길동", Age = 30 });
        People.Add(new Person { Name = "김철수", Age = 25 });
        People.Add(new Person { Name = "이영희", Age = 28 });
    }

    public void Add()
    {
        if (string.IsNullOrWhiteSpace(NameInput)) return;
        if (!int.TryParse(AgeInput, out var age) || age <= 0) return;

        People.Add(new Person { Name = NameInput.Trim(), Age = age });
        NameInput = ""; AgeInput = "";
    }

    public void RemoveSelected()
    {
        if (SelectedPerson is null) return;
        People.Remove(SelectedPerson);
        SelectedPerson = null;
        SelectedIndex = -1;
    }
}
```

포인트
- `SelectedItem`과 `SelectedIndex`를 **동시에 관리**하면 “UI 인덱스 기반 처리”가 필요할 때 유용하다.
- `ObservableCollection<T>`는 “컬렉션 변경”을 UI에 자동 반영한다. 단일 아이템의 **프로퍼티 변경 통지**는 모델이 `INotifyPropertyChanged`를 구현하거나, 불변 모델을 **교체**하는 방식으로 처리한다.

---

## 5. View — ListBox 바인딩(템플릿 기반)

초안의 XAML을 **Avalonia 권장 형태**로 다듬고, 몇 가지 실전 팁을 추가했다.

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:MyAvaloniaApp.ViewModels"
             x:Class="MyAvaloniaApp.Views.PeopleView"
             Width="420" Height="340">
  <UserControl.DataContext>
    <vm:PeopleViewModel/>
  </UserControl.DataContext>

  <Grid RowDefinitions="Auto,* ,Auto" Margin="10" RowSpacing="8">
    <!-- 제목 -->
    <TextBlock Grid.Row="0" Text="사람 목록" FontSize="20"/>

    <!-- 리스트 -->
    <ListBox Grid.Row="1"
             Items="{Binding People}"
             SelectedItem="{Binding SelectedPerson, Mode=TwoWay}"
             SelectedIndex="{Binding SelectedIndex, Mode=TwoWay}">
      <ListBox.ItemTemplate>
        <DataTemplate>
          <!-- 항목 템플릿: 자유롭게 구성 가능 -->
          <Grid ColumnDefinitions="*,80" Margin="0,2">
            <TextBlock Text="{Binding Name}"/>
            <TextBlock Grid.Column="1" Text="{Binding Age}" HorizontalAlignment="Right"/>
          </Grid>
        </DataTemplate>
      </ListBox.ItemTemplate>

      <!-- 항목 컨테이너 스타일: 선택/포커스, 마진/패딩, 상태별 스타일링 -->
      <ListBox.ItemContainerTheme>
        <Style Selector="ListBoxItem">
          <Setter Property="Padding" Value="8,4"/>
        </Style>
      </ListBox.ItemContainerTheme>
    </ListBox>

    <!-- 선택 상세 + 추가/삭제 -->
    <StackPanel Grid.Row="2" Orientation="Vertical" Spacing="6">
      <StackPanel Orientation="Horizontal" Spacing="6">
        <TextBlock Text="선택:"/>
        <TextBlock Text="{Binding SelectedPerson.Name}" FontWeight="Bold"/>
        <TextBlock Text="{Binding SelectedPerson.Age}" />
      </StackPanel>

      <StackPanel Orientation="Horizontal" Spacing="6">
        <TextBox Width="160" Watermark="이름" Text="{Binding NameInput, Mode=TwoWay}"/>
        <TextBox Width="80"  Watermark="나이"  Text="{Binding AgeInput, Mode=TwoWay}"/>
        <Button Content="추가" Click="OnAddClicked"/>
        <Button Content="선택 삭제" Click="OnRemoveClicked"/>
      </StackPanel>
    </StackPanel>
  </Grid>
</UserControl>
```

> **왜 Button에 Command가 아니라 Click 이벤트인가?**  
> 데모 단순화를 위해 `Click`으로 연결했지만, MVVM 원칙상 `ICommand`(ReactiveCommand/RelayCommand)를 쓰는 게 이상적이다(§8에서 커맨드 버전 제공).

`PeopleView.axaml.cs`에서 이벤트를 ViewModel 메서드로 위임:

```csharp
using Avalonia.Controls;

namespace MyAvaloniaApp.Views;

public partial class PeopleView : UserControl
{
    public PeopleView()
    {
        InitializeComponent();
    }

    private PeopleViewModel? Vm => DataContext as PeopleViewModel;

    private void OnAddClicked(object? sender, global::Avalonia.Interactivity.RoutedEventArgs e)
        => Vm?.Add();

    private void OnRemoveClicked(object? sender, global::Avalonia.Interactivity.RoutedEventArgs e)
        => Vm?.RemoveSelected();
}
```

**MVVM 순도를 더 높이려면** 버튼에 Command 바인딩을 사용하자(§8 참조).

---

## 6. ListView는 언제 쓰나?

Avalonia의 `ListView`는 **ListBox의 스타일 변형**에 가깝다(멀티 셀렉션/키보드 내비 등 기본 값이 약간 다름).  
- “일반적인 리스트”는 **ListBox**로 충분하다.  
- “헤더/열이 있는 테이블”은 **ListView가 아닌 DataGrid**를 쓰자(§7 참조).  
- “간단한 카드/행 템플릿”은 ListBox + `ItemTemplate` 조합이 가장 유연하다.

예) `ListView` 사용 자체는 바인딩 방식이 `ListBox`와 동일하다.

```xml
<ListView Items="{Binding People}"
          SelectedItem="{Binding SelectedPerson}">
  <ListView.ItemTemplate>
    <DataTemplate>
      <StackPanel Orientation="Horizontal" Spacing="10">
        <TextBlock Text="{Binding Name}"/>
        <TextBlock Text="{Binding Age}"/>
      </StackPanel>
    </DataTemplate>
  </ListView.ItemTemplate>
</ListView>
```

---

## 7. “열이 있는 테이블”이 필요하면 — DataGrid 권장

DataGrid 사용을 위해선 패키지 참조가 필요하다.

```bash
dotnet add package Avalonia.Controls.DataGrid
```

간단한 예:

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:dg="clr-namespace:Avalonia.Controls;assembly=Avalonia.Controls.DataGrid"
             x:Class="MyAvaloniaApp.Views.PeopleGridView">
  <UserControl.DataContext>
    <vm:PeopleViewModel/>
  </UserControl.DataContext>

  <dg:DataGrid Items="{Binding People}"
               AutoGenerateColumns="False"
               IsReadOnly="True"
               SelectionMode="Single"
               SelectedItem="{Binding SelectedPerson}">
    <dg:DataGrid.Columns>
      <dg:DataGridTextColumn Header="이름" Binding="{Binding Name}" Width="*"/>
      <dg:DataGridTextColumn Header="나이" Binding="{Binding Age}"  Width="120"/>
    </dg:DataGrid.Columns>
  </dg:DataGrid>
</UserControl>
```

- 정렬/필터가 필요하면 `DataGridCollectionView`(코드 비하인드에서 생성)로 고급 조작이 가능하다.
- 대량 데이터에서는 DataGrid의 **가상화** 이점을 살릴 수 있다.

---

## 8. MVVM 규범: Click 대신 Command 사용(권장)

### 8.1 ReactiveUI 커맨드 버전

```csharp
using ReactiveUI;
using System;
using System.Reactive;
using System.Reactive.Linq;
using System.Collections.ObjectModel;

public class PeopleViewModel : ReactiveObject
{
    public ObservableCollection<Person> People { get; } = new();

    private Person? _selectedPerson;
    public Person? SelectedPerson
    {
        get => _selectedPerson;
        set => this.RaiseAndSetIfChanged(ref _selectedPerson, value);
    }

    public string NameInput { get => _nameInput; set => this.RaiseAndSetIfChanged(ref _nameInput, value); }
    private string _nameInput = "";

    public string AgeInput  { get => _ageInput;  set => this.RaiseAndSetIfChanged(ref _ageInput, value); }
    private string _ageInput = "";

    public ReactiveCommand<Unit, Unit> AddCommand { get; }
    public ReactiveCommand<Unit, Unit> RemoveCommand { get; }

    public PeopleViewModel()
    {
        People.Add(new Person { Name = "홍길동", Age = 30 });
        People.Add(new Person { Name = "김철수", Age = 25 });

        var canAdd    = this.WhenAnyValue(vm => vm.NameInput, vm => vm.AgeInput,
                              (name, age) => !string.IsNullOrWhiteSpace(name) && int.TryParse(age, out var n) && n > 0);

        var canRemove = this.WhenAnyValue(vm => vm.SelectedPerson, sp => sp != null);

        AddCommand    = ReactiveCommand.Create(Add, canAdd);
        RemoveCommand = ReactiveCommand.Create(RemoveSelected, canRemove);
    }

    private void Add()
    {
        var age = int.Parse(AgeInput);
        People.Add(new Person { Name = NameInput.Trim(), Age = age });
        NameInput = ""; AgeInput = "";
    }

    private void RemoveSelected()
    {
        if (SelectedPerson is null) return;
        People.Remove(SelectedPerson);
        SelectedPerson = null;
    }
}
```

XAML

```xml
<StackPanel Orientation="Horizontal" Spacing="6">
  <TextBox Width="160" Watermark="이름" Text="{Binding NameInput, Mode=TwoWay}"/>
  <TextBox Width="80"  Watermark="나이"  Text="{Binding AgeInput,  Mode=TwoWay}"/>
  <Button Content="추가"         Command="{Binding AddCommand}"/>
  <Button Content="선택 삭제"     Command="{Binding RemoveCommand}"/>
</StackPanel>
```

### 8.2 CommunityToolkit.Mvvm 대안

```csharp
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Collections.ObjectModel;

public partial class PeopleViewModel : ObservableObject
{
    public ObservableCollection<Person> People { get; } = new();

    [ObservableProperty] private Person? selectedPerson;
    [ObservableProperty] private string nameInput = "";
    [ObservableProperty] private string ageInput  = "";

    public PeopleViewModel()
    {
        People.Add(new Person { Name = "홍길동", Age = 30 });
        People.Add(new Person { Name = "김철수", Age = 25 });
    }

    [RelayCommand(CanExecute = nameof(CanAdd))]
    private void Add()
    {
        var age = int.Parse(AgeInput);
        People.Add(new Person { Name = NameInput.Trim(), Age = age });
        NameInput = ""; AgeInput = "";
    }
    private bool CanAdd() => !string.IsNullOrWhiteSpace(NameInput) && int.TryParse(AgeInput, out var n) && n > 0;

    [RelayCommand(CanExecute = nameof(CanRemove))]
    private void Remove() { if (SelectedPerson is not null) People.Remove(SelectedPerson); }
    private bool CanRemove() => SelectedPerson is not null;
}
```

---

## 9. 필터/정렬 — 간단 패턴

`People` 컬렉션을 직접 변형하지 않고, **보여줄 전용 컬렉션**(`Filtered`)을 따로 두는 패턴이 흔하다. 또는 DataGrid를 쓰는 경우 `DataGridCollectionView`를 활용한다.

간단 예(필터 텍스트가 바뀌면 즉시 적용):

```csharp
public ObservableCollection<Person> People { get; } = new();
public ObservableCollection<Person> Filtered { get; } = new();

private string _filterText = "";
public string FilterText
{
    get => _filterText;
    set { this.RaiseAndSetIfChanged(ref _filterText, value); ApplyFilter(); }
}

private void ApplyFilter()
{
    Filtered.Clear();
    foreach (var p in People)
    {
        if (string.IsNullOrWhiteSpace(FilterText) ||
            p.Name.Contains(FilterText, StringComparison.OrdinalIgnoreCase))
        {
            Filtered.Add(p);
        }
    }
}
```

XAML은 `Items="{Binding Filtered}"`로 바꿔 바인딩한다.  
입력값이 잦으면 **디바운스**(`Throttle`)를 걸어 불필요한 리스트 재구성을 줄일 수 있다.

---

## 10. 다중 선택(Multi-Select)

ViewModel:

```csharp
public ObservableCollection<Person> SelectedPeople { get; } = new(); // 선택 모음(뷰→VM 반영은 사용자 코드 필요)
```

XAML:

```xml
<ListBox Items="{Binding People}" SelectionMode="Multiple">
  <!-- ItemTemplate ... -->
</ListBox>
```

> Avalonia는 `SelectedItems="{Binding ...}"` **양방향 자동 바인딩을 기본 제공하지 않는다**(버전에 따라 달라질 수 있음).  
> 다중 선택을 VM에 싱크하려면 **Behavior** 또는 코드 비하인드에서 `SelectionChanged`를 구독해 `SelectedPeople`을 갱신하는 보조 코드가 필요하다.

---

## 11. 스타일링/컨테이너/가상화/접근성 팁

- **ItemContainerStyle(Theme)**: `ListBox.ItemContainerTheme`로 항목의 패딩/마진/포커스/포인터 상태를 일괄 지정.
- **Alternation**: 짝/홀 줄 배경 등을 줄 때 `:nth-child(even/odd)` 셀렉터 패턴이나 `AlternationIndex`를 활용(스타일 파일에서 정의).
- **가상화**: ListBox/DataGrid는 내부적으로 **가상화 컨테이너**를 사용(대량 데이터에서 메모리/속도 이점).  
  너무 복잡한 템플릿/효과/Converters 남용은 가상화 이점을 떨어뜨릴 수 있다.
- **접근성**: 키보드 내비게이션(↑/↓/PgUp/PgDn), 포커스 시각 표시, 적절한 `Margin/Whitespace`, 명도 대비를 고려.
- **성능**: 잦은 필터/정렬 시 “보여줄 컬렉션”을 새로 채우는 대신, 특성이 맞는 경우 `DataGridCollectionView`의 정렬/필터 기능을 활용.

---

## 12. 디자인 타임 데이터

디자인 타임에서 템플릿을 확인하고 싶다면 `Design.DataContext`를 쓴다.

```xml
<UserControl
  xmlns="https://github.com/avaloniaui"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="https://github.com/avaloniaui/2016/xaml"
  xmlns:vm="using:MyAvaloniaApp.ViewModels"
  x:Class="MyAvaloniaApp.Views.PeopleView">
  <Design.DataContext>
    <vm:PeopleViewModel/>
  </Design.DataContext>

  <!-- 나머지 UI -->
</UserControl>
```

---

## 13. 단위 테스트(간단 뼈대)

```csharp
using Xunit;

public class PeopleViewModelTests
{
    [Fact]
    public void Add_AddsItem_WhenInputValid()
    {
        var vm = new PeopleViewModel();
        var before = vm.People.Count;

        vm.NameInput = "테스터";
        vm.AgeInput  = "33";
        vm.Add();

        Assert.Equal(before + 1, vm.People.Count);
        Assert.Contains(vm.People, p => p.Name == "테스터" && p.Age == 33);
    }

    [Fact]
    public void Remove_RemovesSelected()
    {
        var vm = new PeopleViewModel();
        vm.SelectedPerson = vm.People[0];
        var expectName = vm.SelectedPerson!.Name;

        vm.RemoveSelected();

        Assert.DoesNotContain(vm.People, p => p.Name == expectName);
        Assert.Null(vm.SelectedPerson);
    }
}
```

---

## 14. 오류/함정 모음

- **ListView 열(컬럼)**: WPF의 `GridViewColumn` 방식은 Avalonia `ListView`에 없다. **DataGrid**를 사용하자.
- **SelectedItems 바인딩**: 다중 선택 상태를 VM과 자동 동기화하려면 별도 코드/Behavior가 필요하다.
- **바인딩 실패**: 로그를 확인하고, 프로퍼티명/경로/INPC 구현 여부를 점검한다.
- **디자인 타임 컴파일 오류**: `xmlns:vm="using:...ViewModels"` 네임스페이스/클래스 풀네임 오탈자 주의.
- **대량 데이터**: 템플릿을 단순화하고, 변환기/복잡한 시각 효과를 최소화한다.

---

## 15. 핵심 요약 표

| 주제 | 권장 패턴 |
|------|-----------|
| 리스트 표시 | `ListBox` + `ItemTemplate` |
| 테이블(열/헤더) | `DataGrid` 사용(별도 패키지) |
| 선택 바인딩 | `SelectedItem`(단일), 다중은 Behavior/코드로 싱크 |
| 데이터 구조 | `ObservableCollection<T>` |
| 항목 UI | `DataTemplate`로 자유 구성 |
| 추가/삭제 | `ICommand`(ReactiveCommand/RelayCommand) 권장 |
| 필터/정렬 | 보여줄 전용 컬렉션 or DataGridCollectionView |
| 성능/UX | 가상화 유지, 템플릿 단순화, 키보드 내비/접근성 고려 |

---

## 16. 결론

초안의 흐름(컬렉션 → ListBox/ListView 바인딩 → 항목 템플릿 → 선택 표시)을 유지하면서, Avalonia에서 **실무적으로 반드시 알아야 할 차이점**(ListView-GridViewColumn 부재, DataGrid 권장), **커맨드/필터/성능/접근성/테스트**까지 보강했다.  
이 가이드를 토대로 시작하면, 리스트 UI는 **MVVM 원칙을 지키며 확장 가능하고 유지보수 쉬운 구조**로 성장시킬 수 있다.