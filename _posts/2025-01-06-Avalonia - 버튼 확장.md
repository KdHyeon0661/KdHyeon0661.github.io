---
layout: post
title: Avalonia - 버튼 확장
date: 2025-01-06 20:20:23 +0900
category: Avalonia
---
# Avalonia 버튼 확장 기능

## 예제 디렉터리(확장 버전)

```
MyAvaloniaApp/
├── App.axaml
├── App.axaml.cs
├── Models/
│   ├── UserSettings.cs
│   └── Person.cs
├── Services/
│   ├── IDialogService.cs
│   ├── DialogService.cs
│   ├── ISettingsService.cs
│   └── SettingsService.cs
├── ViewModels/
│   ├── ViewModelBase.cs
│   ├── DashboardViewModel.cs
│   ├── SettingsViewModel.cs
│   └── ShellViewModel.cs            # Navigation의 셸
└── Views/
    ├── DashboardView.axaml
    ├── SettingsView.axaml
    ├── MainWindow.axaml             # 셸 윈도우
    └── MainWindow.axaml.cs
```

---

## 버튼과 MVVM의 기본 — ICommand로 일관되게

버튼을 Click 이벤트로 처리하는 대신, **ViewModel의 ICommand**에 바인딩하면 테스트 가능성이 높아지고, 뷰와 로직이 분리된다.

### ViewModelBase (ReactiveUI 버전)

```csharp
// ViewModels/ViewModelBase.cs
using ReactiveUI;

public class ViewModelBase : ReactiveObject { }
```

### 간단 버튼 예제 (DashboardViewModel)

```csharp
// ViewModels/DashboardViewModel.cs
using ReactiveUI;
using System.Reactive;
using System.Threading.Tasks;

public sealed class DashboardViewModel : ViewModelBase
{
    private string _status = "대기";
    public string Status
    {
        get => _status;
        set => this.RaiseAndSetIfChanged(ref _status, value);
    }

    public ReactiveCommand<Unit, Unit> LoadDataCommand { get; }

    public DashboardViewModel()
    {
        LoadDataCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            Status = "로딩 중...";
            await Task.Delay(1500);
            Status = "완료";
        });
    }
}
```

### View(XAML)

```xml
<!-- Views/DashboardView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyAvaloniaApp.Views.DashboardView">

  <StackPanel Margin="16" Spacing="8">
    <Button Content="데이터 로드" Command="{Binding LoadDataCommand}"/>
    <TextBlock Text="{Binding Status}"/>
  </StackPanel>
</UserControl>
```

---

## 다이얼로그 서비스 — 메시지/확인/입력/파일 선택

**중요 포인트**
- ViewModel이 `Window`를 직접 만들지 않도록, **IDialogService**를 통해 요청한다.
- **Owner(소유자 창)**를 지정하면 모달 동작·포커스·Z-Order가 안정적이다.
- 파일 다이얼로그는 Avalonia의 `OpenFileDialog/SaveFileDialog`를 사용한다.

### IDialogService 인터페이스

```csharp
// Services/IDialogService.cs
using System.Threading.Tasks;

public interface IDialogService
{
    Task ShowMessageAsync(string title, string message);
    Task<bool> ShowConfirmAsync(string title, string message); // Yes/No
    Task<string?> ShowPromptAsync(string title, string message, string? defaultText = null);

    Task<string[]?> ShowOpenFilesAsync(string title, string? initialDir = null, params string[] filters);
    Task<string?>   ShowSaveFileAsync(string title, string? suggestedName = null, params string[] filters);
}
```

### DialogService 구현

```csharp
// Services/DialogService.cs
using Avalonia.Controls;
using Avalonia.Platform.Storage;
using System.Linq;
using System.Threading.Tasks;

public sealed class DialogService : IDialogService
{
    private readonly Window _owner;

    public DialogService(Window owner) => _owner = owner;

    public async Task ShowMessageAsync(string title, string message)
    {
        var w = new Window
        {
            Title = title,
            Width = 360,
            Height = 180,
            Content = new TextBlock { Text = message, Margin = new Thickness(16) },
            WindowStartupLocation = WindowStartupLocation.CenterOwner
        };
        await w.ShowDialog(_owner);
    }

    public async Task<bool> ShowConfirmAsync(string title, string message)
    {
        var dialog = new Window
        {
            Title = title,
            Width = 380,
            Height = 200,
            WindowStartupLocation = WindowStartupLocation.CenterOwner
        };

        var txt = new TextBlock { Text = message, Margin = new Thickness(16) };
        var btnYes = new Button { Content = "예", MinWidth = 80, Margin = new Thickness(8,0,8,0) };
        var btnNo  = new Button { Content = "아니오", MinWidth = 80, Margin = new Thickness(8,0,8,0) };

        var panel = new StackPanel { Margin = new Thickness(12) };
        panel.Children.Add(txt);
        panel.Children.Add(new StackPanel
        {
            Orientation = Orientation.Horizontal,
            HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Right,
            Spacing = 8,
            Children = { btnYes, btnNo }
        });

        dialog.Content = panel;

        var tcs = new TaskCompletionSource<bool>();
        btnYes.Click += (_, __) => { tcs.TrySetResult(true);  dialog.Close(); };
        btnNo.Click  += (_, __) => { tcs.TrySetResult(false); dialog.Close(); };

        await dialog.ShowDialog(_owner);
        return await tcs.Task;
    }

    public async Task<string?> ShowPromptAsync(string title, string message, string? defaultText = null)
    {
        var dialog = new Window
        {
            Title = title,
            Width = 420,
            Height = 220,
            WindowStartupLocation = WindowStartupLocation.CenterOwner
        };

        var input = new TextBox { Text = defaultText ?? "", Margin = new Thickness(0,8,0,8) };
        var btnOk = new Button { Content = "확인", MinWidth = 80, Margin = new Thickness(8,0,8,0) };
        var btnCancel = new Button { Content = "취소", MinWidth = 80, Margin = new Thickness(8,0,8,0) };

        var panel = new StackPanel { Margin = new Thickness(12) };
        panel.Children.Add(new TextBlock { Text = message });
        panel.Children.Add(input);
        panel.Children.Add(new StackPanel
        {
            Orientation = Orientation.Horizontal,
            HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Right,
            Spacing = 8,
            Children = { btnOk, btnCancel }
        });

        dialog.Content = panel;

        var tcs = new TaskCompletionSource<string?>();
        btnOk.Click     += (_, __) => { tcs.TrySetResult(input.Text); dialog.Close(); };
        btnCancel.Click += (_, __) => { tcs.TrySetResult(null);       dialog.Close(); };

        await dialog.ShowDialog(_owner);
        return await tcs.Task;
    }

    public async Task<string[]?> ShowOpenFilesAsync(string title, string? initialDir = null, params string[] filters)
    {
        var storageProvider = _owner.StorageProvider;
        if (storageProvider is null) return null;

        var result = await storageProvider.OpenFilePickerAsync(new FilePickerOpenOptions
        {
            Title = title,
            AllowMultiple = true,
            SuggestedStartLocation = null,
            FileTypeFilter = filters?.Length > 0
                ? filters.Select(f => new FilePickerFileType(f){ Patterns = new[] { $"*{f.TrimStart('.')}" } }).ToList()
                : null
        });

        return result?.Select(f => f.Path.LocalPath).ToArray();
    }

    public async Task<string?> ShowSaveFileAsync(string title, string? suggestedName = null, params string[] filters)
    {
        var storageProvider = _owner.StorageProvider;
        if (storageProvider is null) return null;

        var result = await storageProvider.SaveFilePickerAsync(new FilePickerSaveOptions
        {
            Title = title,
            SuggestedFileName = suggestedName,
            FileTypeChoices = filters?.Length > 0
                ? filters.Select(f => new FilePickerFileType(f){ Patterns = new[] { $"*{f.TrimStart('.')}" } }).ToList()
                : null
        });

        return result?.Path.LocalPath;
    }
}
```

> 실제 앱에서는 **MessageBox.Avalonia** 같은 라이브러리를 사용해도 되지만(별도 NuGet), 위처럼 **순수 Avalonia**로도 충분히 구현 가능하다.

### 서비스 주입(Owner 연결)

`MainWindow` 생성 시 `DialogService`에 **현재 창**을 주입한다.

```csharp
// App.axaml.cs (일례)
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Microsoft.Extensions.DependencyInjection;

public partial class App : Application
{
    public static ServiceProvider Services { get; private set; } = default!;

    public override void OnFrameworkInitializationCompleted()
    {
        var sc = new ServiceCollection();
        sc.AddTransient<SettingsViewModel>();
        sc.AddTransient<DashboardViewModel>();
        sc.AddSingleton<ShellViewModel>();

        Services = sc.BuildServiceProvider();

        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            var win = new Views.MainWindow();
            // DialogService는 Owner(윈도우)를 필요로 하므로 여기서 구성
            win.DataContext = new ShellViewModel(
                new DialogService(win), // 주입
                Services.GetRequiredService<DashboardViewModel>(),
                Services.GetRequiredService<SettingsViewModel>()
            );
            desktop.MainWindow = win;
        }

        base.OnFrameworkInitializationCompleted();
    }
}
```

---

## 로딩 애니메이션 — IsExecuting/IsBusy + 취소 토큰

**핵심 패턴**
- 비동기 `ReactiveCommand`의 `IsExecuting`을 바인딩해 스피너/메시지를 표시
- 또는 `IsBusy` 속성을 명시적으로 관리
- 긴 작업에는 `CancellationToken`을 제공해 취소 버튼을 두는 편이 좋다

### ViewModel

```csharp
using ReactiveUI;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Reactive;

public sealed class SettingsViewModel : ViewModelBase
{
    private CancellationTokenSource? _cts;

    public string Status { get => _status; set => this.RaiseAndSetIfChanged(ref _status, value); }
    private string _status = "대기";

    public ReactiveCommand<Unit, Unit> LoadCommand { get; }
    public ReactiveCommand<Unit, Unit> CancelCommand { get; }
    public bool IsBusy => _isBusy?.Value ?? false;
    private readonly ObservableAsPropertyHelper<bool>? _isBusy;

    public SettingsViewModel()
    {
        LoadCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            _cts?.Cancel(); _cts = new CancellationTokenSource();
            Status = "로딩 중...";
            await Task.Delay(2000, _cts.Token); // 실제 I/O 대체
            Status = "완료";
        });

        CancelCommand = ReactiveCommand.Create(() => _cts?.Cancel());

        _isBusy = LoadCommand.IsExecuting
            .ToProperty(this, vm => vm.IsBusy, scheduler: RxApp.MainThreadScheduler);
    }
}
```

### View(XAML)

```xml
<StackPanel Spacing="8">
  <Button Content="불러오기" Command="{Binding LoadCommand}"/>
  <Button Content="취소" Command="{Binding CancelCommand}" IsEnabled="{Binding IsBusy}"/>

  <!-- 간단 스피너: ProgressBar를 Indeterminate로 -->
  <ProgressBar IsVisible="{Binding IsBusy}" IsIndeterminate="True" Height="6"/>
  <TextBlock Text="{Binding Status}"/>
</StackPanel>
```

---

## — 서비스로 확인 후 동작 분기

```csharp
public sealed class DashboardViewModel : ViewModelBase
{
    private readonly IDialogService _dialogs;

    public ReactiveCommand<Unit, Unit> DangerousCommand { get; }

    public DashboardViewModel(IDialogService dialogs)
    {
        _dialogs = dialogs;

        DangerousCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            var ok = await _dialogs.ShowConfirmAsync("삭제", "정말 삭제하시겠습니까?");
            if (ok)
                await _dialogs.ShowMessageAsync("결과", "삭제 완료");
            else
                await _dialogs.ShowMessageAsync("결과", "취소됨");
        });
    }
}
```

XAML

```xml
<Button Content="삭제" Command="{Binding DangerousCommand}"/>
```

---

## 페이지 전환 — ContentControl + DataTemplate

**패턴 요약**
- 셸 VM에 `Current`(현재 페이지 VM)를 둔다.
- App 리소스에 **DataTemplate**으로 VM→View를 매핑한다.
- 버튼은 `Current`를 다른 VM으로 교체하는 Command를 실행한다.

### ShellViewModel

```csharp
public sealed class ShellViewModel : ViewModelBase
{
    private readonly IDialogService _dialogs;

    public ViewModelBase Current { get => _current; set => this.RaiseAndSetIfChanged(ref _current, value); }
    private ViewModelBase _current;

    public DashboardViewModel Dashboard { get; }
    public SettingsViewModel  Settings  { get; }

    public ReactiveCommand<Unit, Unit> GoDashboardCommand { get; }
    public ReactiveCommand<Unit, Unit> GoSettingsCommand  { get; }

    public ShellViewModel(IDialogService dialogs, DashboardViewModel dashboard, SettingsViewModel settings)
    {
        _dialogs = dialogs;
        Dashboard = dashboard;
        Settings  = settings;

        Current = Dashboard;

        GoDashboardCommand = ReactiveCommand.Create(() => Current = Dashboard);
        GoSettingsCommand  = ReactiveCommand.Create(() => Current = Settings);
    }
}
```

### MainWindow.axaml

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="MyAvaloniaApp.Views.MainWindow"
        Width="960" Height="640" Title="MyAvaloniaApp">
  <Grid RowDefinitions="Auto,*">
    <StackPanel Grid.Row="0" Orientation="Horizontal" Spacing="8" Margin="8">
      <Button Content="대시보드" Command="{Binding GoDashboardCommand}"/>
      <Button Content="설정"    Command="{Binding GoSettingsCommand}"/>
    </StackPanel>

    <Border Grid.Row="1" Margin="12" Padding="12">
      <ContentControl Content="{Binding Current}"/>
    </Border>
  </Grid>
</Window>
```

### App.axaml의 DataTemplate 등록

```xml
<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:MyAvaloniaApp"
             xmlns:views="using:MyAvaloniaApp.Views"
             x:Class="MyAvaloniaApp.App">
  <Application.DataTemplates>
    <DataTemplate DataType="{x:Type vm:DashboardViewModel}">
      <views:DashboardView/>
    </DataTemplate>
    <DataTemplate DataType="{x:Type vm:SettingsViewModel}">
      <views:SettingsView/>
    </DataTemplate>
  </Application.DataTemplates>

  <Application.Styles>
    <FluentTheme Mode="Light"/>
  </Application.Styles>
</Application>
```

---

## vs ObservableValidator(고급)

초안의 `IValidatableObject` 접근을 유지하되, **명확한 메시지**와 **Command 연계** 형태로 다듬는다.
대안으로 CommunityToolkit.Mvvm의 `ObservableValidator`를 쓰면 **프로퍼티별 오류 컬렉션**을 자동 노출할 수 있다(여기서는 DataAnnotations 기반 예제를 유지).

### 모델/설정 DTO

```csharp
// Models/UserSettings.cs
public class UserSettings
{
    public string UserName { get; set; } = "";
    public int Age { get; set; }
}
```

### 설정 저장 서비스

```csharp
// Services/ISettingsService.cs
using System.Threading.Tasks;

public interface ISettingsService
{
    Task SaveAsync(UserSettings settings);
    Task<UserSettings?> LoadAsync();
}
```

```csharp
// Services/SettingsService.cs
using System.Text.Json;
using System.IO;
using System.Threading.Tasks;

public sealed class SettingsService : ISettingsService
{
    private const string FilePath = "user-settings.json";

    public async Task SaveAsync(UserSettings settings)
    {
        var json = JsonSerializer.Serialize(settings, new JsonSerializerOptions { WriteIndented = true });
        await File.WriteAllTextAsync(FilePath, json);
    }

    public async Task<UserSettings?> LoadAsync()
    {
        if (!File.Exists(FilePath)) return null;
        var json = await File.ReadAllTextAsync(FilePath);
        return JsonSerializer.Deserialize<UserSettings>(json);
    }
}
```

### SettingsViewModel — 검증 + 저장/불러오기

```csharp
using ReactiveUI;
using System.ComponentModel.DataAnnotations;
using System.Collections.Generic;
using System.Linq;
using System.Reactive;
using System.Threading.Tasks;

public sealed class SettingsViewModel : ViewModelBase, IValidatableObject
{
    private readonly ISettingsService _settings;

    public SettingsViewModel(ISettingsService settings)
    {
        _settings = settings;

        SaveCommand = ReactiveCommand.CreateFromTask(SaveAsync);
        LoadCommand = ReactiveCommand.CreateFromTask(LoadAsync);
    }

    public string UserName { get => _userName; set => this.RaiseAndSetIfChanged(ref _userName, value); }
    private string _userName = "";

    public int Age { get => _age; set => this.RaiseAndSetIfChanged(ref _age, value); }
    private int _age;

    public string Result { get => _result; private set => this.RaiseAndSetIfChanged(ref _result, value); }
    private string _result = "";

    public ReactiveCommand<Unit, Unit> SaveCommand { get; }
    public ReactiveCommand<Unit, Unit> LoadCommand { get; }

    private async Task SaveAsync()
    {
        var errors = ValidateAll();
        if (errors.Any())
        {
            Result = string.Join("\n", errors);
            return;
        }

        await _settings.SaveAsync(new UserSettings { UserName = UserName, Age = Age });
        Result = "저장 완료";
    }

    private async Task LoadAsync()
    {
        var loaded = await _settings.LoadAsync();
        if (loaded is null)
        {
            Result = "저장된 설정이 없습니다";
            return;
        }

        UserName = loaded.UserName;
        Age = loaded.Age;
        Result = "설정 불러오기 완료";
    }

    private IEnumerable<string> ValidateAll()
    {
        var results = new List<ValidationResult>();
        var ctx = new ValidationContext(this, null, null);
        Validator.TryValidateObject(this, ctx, results, true);
        return results.Select(r => r.ErrorMessage ?? "유효성 오류");
    }

    public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
    {
        if (string.IsNullOrWhiteSpace(UserName))
            yield return new ValidationResult("이름은 비어 있을 수 없습니다.", new[] { nameof(UserName) });
        if (Age <= 0)
            yield return new ValidationResult("나이는 0보다 커야 합니다.", new[] { nameof(Age) });
    }
}
```

### SettingsView — 검증 버튼·메시지 표시

```xml
<!-- Views/SettingsView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyAvaloniaApp.Views.SettingsView">
  <StackPanel Margin="16" Spacing="8">
    <TextBlock Text="사용자 설정" FontSize="18"/>

    <TextBox Watermark="이름" Text="{Binding UserName, Mode=TwoWay}"/>
    <TextBox Watermark="나이"  Text="{Binding Age, Mode=TwoWay}"/>

    <StackPanel Orientation="Horizontal" Spacing="8">
      <Button Content="저장" Command="{Binding SaveCommand}"/>
      <Button Content="불러오기" Command="{Binding LoadCommand}"/>
    </StackPanel>

    <TextBlock Text="{Binding Result}" TextWrapping="Wrap"/>
  </StackPanel>
</UserControl>
```

---

## 버튼이 연결된 다이얼로그/파일 동작 예

**시나리오**: 대시보드에서 파일 선택 → 확인창 → 처리 → 메시지 출력

```csharp
public sealed class DashboardViewModel : ViewModelBase
{
    private readonly IDialogService _dialogs;

    public ReactiveCommand<Unit, Unit> ImportCommand { get; }

    public DashboardViewModel(IDialogService dialogs)
    {
        _dialogs = dialogs;

        ImportCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            var files = await _dialogs.ShowOpenFilesAsync("불러올 파일 선택", null, ".json", ".csv");
            if (files is null || files.Length == 0)
            {
                await _dialogs.ShowMessageAsync("결과", "선택된 파일이 없습니다");
                return;
            }

            var ok = await _dialogs.ShowConfirmAsync("확인", $"{files.Length}개 파일을 불러올까요?");
            if (!ok) return;

            // TODO: 실제 처리
            await _dialogs.ShowMessageAsync("결과", "불러오기 완료");
        });
    }
}
```

XAML

```xml
<Button Content="파일 불러오기" Command="{Binding ImportCommand}"/>
```

---

## 테스트 가능성과 에러 처리

- `IDialogService`, `ISettingsService`는 **인터페이스**이므로 단위 테스트에서 **목(mock)** 으로 치환 가능하다.
- 긴 작업은 `try/catch`로 감싸 **사용자 메시지**를 제공하고, **로그**에 상세 예외를 남긴다.
- `ReactiveCommand.ThrownExceptions`를 구독해 중앙 처리 핸들러를 둘 수도 있다.

```csharp
LoadCommand.ThrownExceptions.Subscribe(async ex =>
{
    // 로깅
    // await _dialogs.ShowMessageAsync("오류", ex.Message);
});
```

---

## CommunityToolkit.Mvvm 대안(선택)

ReactiveUI 대신 **CommunityToolkit.Mvvm** 사용 시, 다음과 같이 간결하게 작성할 수 있다.

```csharp
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.ComponentModel.DataAnnotations;
using System.Collections.Generic;

public partial class SettingsViewModel : ObservableValidator
{
    [ObservableProperty]
    [NotifyDataErrorInfo] // 필요 시
    [Required(ErrorMessage = "이름은 비어 있을 수 없습니다.")]
    private string userName = "";

    [ObservableProperty]
    [Range(1, int.MaxValue, ErrorMessage = "나이는 0보다 커야 합니다.")]
    private int age;

    [ObservableProperty]
    private string result = "";

    [RelayCommand]
    private void Save()
    {
        ValidateAllProperties();
        if (HasErrors)
        {
            Result = string.Join("\n", GetErrors().Select(e => e.ErrorMessage));
            return;
        }
        Result = "저장 완료";
    }
}
```

XAML 바인딩 방식은 동일하며, `ErrorsChanged` 이벤트로 `Validation` UI를 정교하게 표현할 수 있다.

---

## 자주 겪는 문제와 해결

- **Owner 없는 ShowDialog**: 포커스/모달 문제가 생길 수 있다. **반드시 Owner를 지정**해 `ShowDialog(owner)` 호출.
- **UI 스레드 차단**: 비동기 작업에 `Task.Run`/`await`를 쓰고, `ObservableCollection` 변경은 **UI 스레드**에서 수행.
- **Command CanExecute**: ReactiveUI는 `canExecute` 스트림, Toolkit은 `[RelayCommand(CanExecute=...)]`로 제어.
- **디자인 타임 오류**: XAML 네임스페이스(`using:`)·정규 풀네임 확인, `Design.DataContext`로 미리보기 안정화.
- **파일 다이얼로그 권한**: 플랫폼별 저장소 제공자 특성 상 상대/절대 경로 처리에 유의.

---

## 전체 흐름 요약 표

| 기능 | 핵심 기술 | 패턴 |
|------|-----------|------|
| 버튼 → 비동기 작업 | ReactiveCommand.CreateFromTask | IsExecuting로 바운드 |
| 다이얼로그(메시지/확인/입력) | IDialogService + Owner 지정 | MVVM에서 서비스로 추상화 |
| 파일 열기/저장 | StorageProvider(Open/Save) | 필터/초기 디렉터리 지정 |
| 로딩 애니메이션 | ProgressBar IsIndeterminate | IsExecuting/IsBusy 바인딩 |
| 취소 | CancellationTokenSource | 취소 버튼 → `Cancel()` |
| 페이지 전환 | ContentControl + DataTemplate | ShellVM.Current 교체 |
| 검증 | DataAnnotations / ObservableValidator | 저장/제출 전에 Validate |
| 설정 저장 | JsonSerializer | ISettingsService로 분리 |

---

## 결론 및 다음 단계

이 글은 버튼을 기점으로 **다이얼로그**, **로딩**, **확인 흐름**, **페이지 전환**을 **서비스/커맨드/템플릿**으로 결합하는 **Avalonia MVVM 실전 패턴**을 정리했다.
여기에 이어서 다음을 적용해보자.

- 입력 폼에 **필드별 오류 표시 템플릿**(Adorner/Style) 구성
- 대용량 처리 시 **진행률(Progress) 보고**와 **중간 취소**
- Navigation을 `INavigationService`로 일반화(딥링크, 히스토리 관리)
- 설정 저장소를 **환경/사용자별 경로**, **암호화**, **SQLite**로 확장

실무에서는 위 구조를 토대로, 테스트와 유지보수를 고려한 **서비스 경계**와 **의존성 주입**을 일관성 있게 유지하는 것이 핵심이다.
