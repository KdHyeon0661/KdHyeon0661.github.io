---
layout: post
title: 운영체제 - 가상 메모리 (3)
date: 2025-10-25 18:25:23 +0900
category: 운영체제
---
# Advanced Virtual Memory Topics

## Memory Compression

### 개념

**메모리 압축(memory compression)**은 스왑으로 내보내기 전에 **메모리 상에서** 페이지를 **압축**해 저장하는 기법이다.
- 장점: 디스크 스왑 I/O 감소(수 ms 지연을 µs~ns급 CPU 압축으로 대체).
- 비용: CPU 사용량↑, 압축/해제 지연.
- 사례: Linux **zswap/zram**, macOS **VM Compressor**.

**압축률**을 \(r\) (원본 크기 대비 압축 후 크기)라고 할 때, \(N\)개의 페이지(크기 \(P\))를 압축 저장하면 필요한 메모리는:
$$
\text{Compressed RAM} \approx r \cdot N \cdot P.
$$
압축 캐시 미스 확률을 \(p_c\), 디스크 스왑 확률을 \(p_d\), 각 지연을 \(C, D\)라 하면 EAT에 미치는 추가항은:
$$
\Delta EAT \approx p_c \cdot C + p_d \cdot D,\quad \text{보통 } D \gg C.
$$

### 동작 흐름(예: zswap)

1) 페이지 교체 대상 선정(Clock/NRU 등).
2) **압축 시도** → 성공 시 **압축 메모리 풀**(zbud/zpool)에 저장하고, 원래 프레임 해제.
3) 후속 접근 시: 압축 풀에서 **해제(decompress)** → 다시 매핑.
4) 압축 풀 가득 참 → 정책에 따라 **실스왑**으로 페이지 배출.

### 설계 포인트

- **알고리즘**: LZO/LZ4(zstd) — 속도 vs 압축률 trade-off.
- **할당기**: 압축 결과가 “절반 페이지/가변 크기” → **특수 슬래브/버디** 필요.
- **중복 제거**(dedup): 동일 페이지 내용 **해시**로 공유.
- **보안**: 압축 메모리의 **암호화**(macOS) 또는 최소한 **KASLR/SMAP/SMEP**와의 상호작용 점검.

### 미니 실험: 압축 캐시의 임계(파이썬 시뮬)

```python
# memcomp_sim.py — 압축 캐시 hit/miss와 디스크 스왑의 효과 비교

import zlib, os, random

PAGE=4096
def synth_page(kind="zero"):
    if kind=="zero":
        return b'\x00'*PAGE
    if kind=="text":
        s = (b"hello world " * 100)[:PAGE]
        return s + b'\x00'*(PAGE-len(s))
    if kind=="rand":
        return os.urandom(PAGE)

def compress_ratio(data):
    c = zlib.compress(data, level=1)
    return len(c)/len(data)

samples = [synth_page(k) for k in ["zero","text","rand"]]
print([round(compress_ratio(x),3) for x in samples])  # 0.005~0.8대 등
```

### 사용자 공간 구현 패턴(개념)

**압축 페이지 캐시**(CPC)를 만들어 **메모리 핫셋**을 압축 보관:
- 키: 가상 페이지 번호(VPN), 값: 압축 바이트.
- 먼저 CPC 조회 → 히트 시 압축 해제 후 제공, 미스 시 디스크/원본 로드.

```python
# cpc_map.py — 단순 압축 캐시 스케치

import zlib
from collections import OrderedDict

class CompressedPageCache(OrderedDict):
    def __init__(self, cap_bytes):
        super().__init__(); self.cap = cap_bytes; self.size=0
    def put_page(self, vpn, page_bytes):
        c = zlib.compress(page_bytes,1)
        while self.size + len(c) > self.cap and self:
            _, old = self.popitem(last=False); self.size -= len(old)
        self[vpn]=c; self.size += len(c)
    def get_page(self, vpn):
        c = super().get(vpn)
        if c is None: return None
        self.move_to_end(vpn)
        return zlib.decompress(c)
```

---

## Allocating Kernel Memory

### 요구사항

커널 메모리는 사용자 공간과 달리 다음 제약을 가진다.
- **페이지 폴트 불가 경로**(인터럽트/스케줄러/드라이버)에서 **즉시** 할당/해제 가능.
- **물리 연속성**이 필요한 경우(DMA, 페이지 테이블, 대페이지 매핑).
- **캐시라인/NUMA** 정렬, **메모리 색채우기(page coloring)**, **SLAB 재사용**.
- **메모리 손상 탐지**(red zone, canary)와 **프리 리스트 무결성**.

### 전형적 계층(리눅스 관점)

1) **Buddy Allocator**(페이지 단위, 2^k 블록) — 물리 프레임의 연속 블록 제공.
2) **SLAB/SLUB/SLOB** — **소객체 캐시**(kmalloc, kmem_cache).
3) **vmalloc** — **가상 연속**이지만 **물리 비연속**(큰 배열; TLB 비용↑).
4) **per-CPU allocator** — CPU별 소객체 저장, **락 경합↓**.
5) **GFP flags** — 존(zone)/컨텍스트/재시도 정책: `GFP_KERNEL`, `GFP_ATOMIC`, `__GFP_ZERO`, `GFP_DMA32` 등.

#### 버디 알로케이터 미니 시뮬(파이썬)

```python
# buddy_sim.py — 1D buddy allocator toy

class Buddy:
    def __init__(self, order_max=10):
        self.order_max = order_max
        self.free = {o:[0] if o==order_max else [] for o in range(order_max+1)} # one big block
        self.used = {}
    def alloc(self, order):
        o=order
        while o<=self.order_max and not self.free[o]: o+=1
        if o>self.order_max: return None
        idx = self.free[o].pop()
        while o>order:
            o-=1
            self.free[o].append(idx + (1<<o))  # split buddy
        self.used[idx]=order
        return idx
    def free_block(self, idx):
        order = self.used.pop(idx)
        while order<self.order_max:
            buddy = idx ^ (1<<order)
            if buddy in self.free[order]:
                self.free[order].remove(buddy)
                idx = min(idx, buddy); order+=1
            else:
                break
        self.free[order].append(idx)

b=Buddy(5); a=b.alloc(2); c=b.alloc(2); b.free_block(a); b.free_block(c)  # 병합 확인
```

#### 핵심

- **kmem_cache**: 동일 크기 객체 풀.
- **슬랩(slab)**: 여러 객체를 담는 페이지 묶음.
- **컬러링/패딩**: 캐시 미스/폴스 셰어링 완화.
- **디버깅**: red-zone/poison, constructor/destructor.

```python
# slab_toy.py — 단순 슬랩 캐시 스케치

class SlabCache:
    def __init__(self, objsz, slab_pages=1, page_size=4096):
        self.objsz=objsz
        self.cap = (slab_pages*page_size)//objsz
        self.slabs=[]; self.free=[]
    def _new_slab(self):
        slab=[bytearray(self.objsz) for _ in range(self.cap)]
        self.slabs.append(slab)
        for i in range(self.cap): self.free.append((len(self.slabs)-1, i))
    def alloc(self):
        if not self.free: self._new_slab()
        return self.free.pop()
    def free_obj(self, handle):
        self.free.append(handle)
```

#### vmalloc vs kmalloc

- `kmalloc(n)` → **물리 연속** (버디 기반), 빠른 DMA/하드웨어 접근.
- `vmalloc(n)` → **가상 연속**, 물리는 조각 → 큰 버퍼에 유리, TLB 비용·매핑 비용↑.

### DMA / IOMMU

- 장치가 **물리 주소**로 메모리에 접근 → **DMA 가능 메모리(GFP_DMA, DMA32)** 필요.
- **IOMMU**가 있으면 장치에도 **가상→물리** 변환 계층을 제공 → **연속성 요구 완화**, **격리/보안** 향상.
- **cache coherency**: `dma_map_*` API로 **캐시 flush/invalidate** 보장.

### 커널 메모리 안전/디버깅

- **KASAN**(AddressSanitizer), **KFENCE**, **KMSAN**(init 누락 감지).
- **init-on-alloc/free**(0 or poison), **SLAB freelist hardening**.
- **Double-free/Use-after-free** 방지 강화를 위한 **pointer tagging**(ARM TBI, HWASan 유사 개념).

### Windows/기타 용어 브리핑

- Windows: **Paged/Nonpaged Pool**, **Lookaside Lists**, **Large Page**(`AllocateUserPhysicalPages`/`VirtualAlloc` with flags).
- macOS/XNU: **kalloc zone allocator**, **zalloc**, **UMA-like**(per-CPU magazines), **VM Compressor**와 협력.

---

## Other Considerations

### NUMA

- **노드 로컬** 메모리 접근이 원격보다 **지연↓ 대역폭↑**.
- 정책: **퍼스트-터치**, **바인딩/인터리빙**, **자동 마이그레이션**.
- VM/컨테이너: **cpuset/mempolicy**, **hugepage**와 함께 고려.

### Huge Pages / TLB Reach

- **TLB Reach** \(= \text{TLB entries} \times \text{page size}\) 가 워크셋보다 크면 TLB 미스↓.
- 대페이지는 **TLB 커버리지↑** ↔ **내부 단편화**, **복사/스왑 비용↑**.

### Page Coloring

- L2/L3 캐시 **인덱스 충돌**을 줄이기 위해 페이지 색을 고려해 매핑.
- 현대 CPU의 **상위 어드레스 비트 XOR** 인덱싱 등으로 효과가 축소되었지만, 일부 워크로드에서 여전히 유의미.

### Memory-Mapped I/O (MMIO)와 캐시 속성

- 디바이스 레지스터/버퍼를 **메모리에 매핑**.
- **비캐시/강순서** 속성 필요(ARM MAIR, x86 PAT).
- 잘못된 캐시 속성은 **데이터 손상/순서 오류** 유발.

### 보안: W^X, KPTI, 암호화 메모리

- **W^X**: 쓰기 가능이면 실행 불가(NX), JIT는 **RW→RX 전환**.
- **KPTI**: Meltdown 완화 — 유저/커널 PT 분리 → TLB 비용, PCID로 완화.
- **메모리 암호화**: AMD SEV/SME, Intel TME/MKTME — **물리 메모리 암호화**로 공격면 축소.

### Persistent Memory (PMEM)

- DAX(Direct Access)로 파일을 **페이지 캐시 없이** 매핑 — **로드/스토어** 접근.
- 영속성 보장 위해 **캐시 플러시**(CLWB)와 **배리어** 필요, 로그/카피-온-라이트 설계.

---

## Operating-System Examples

### Linux (요약과 실습 코드)

**구성 요소**
- 페이징: 다단계 PT, TLB, THP/hugetlbfs.
- 교체: **Clock 변형**(LRU-lists with Active/Inactive), **kswapd**, **pgscan**.
- 스왑: **zswap/zram**(압축), swap 파일/파티션.
- 할당: **Buddy + SLUB**, `kmalloc`, `vmalloc`, `alloc_pages`.
- NUMA: `mbind`, **AutoNUMA**(스캔 후 마이그레이션).
- 보안: **KPTI**, **SMEP/SMAP**, **KASLR**, **NX**.

**유저 공간 예제: THP 힌트 & NUMA 바인딩**
```c
// thp_numa.c — THP 힌트 + NUMA 바인딩(리눅스)
#define _GNU_SOURCE
#include <numa.h>
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>

int main(){
  size_t sz = 1UL<<30; // 1GiB
  void* p = mmap(NULL, sz, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
  madvise(p, sz, MADV_HUGEPAGE);           // 투명 대페이지 후보
  if(numa_available()!=-1){
    struct bitmask* bm = numa_allocate_nodemask();
    numa_bitmask_setbit(bm, 0);            // 노드0 바인딩
    numa_mbind(p, sz, MPOL_BIND, bm->maskp, bm->size+1, 0);
    numa_free_nodemask(bm);
  }
  // 첫 접근이 노드0에 실제 페이지 할당(퍼스트 터치)
  for(size_t i=0;i<sz;i+=4096) ((char*)p)[i]=1;
  munmap(p, sz);
}
```

**커널 슬랩/버디의 효과를 관찰하는 사용자 공간 장난감**
```c
// touch_pages.c — 연속/랜덤 접근으로 폴트/대페이지/NUMA 효과 관찰
#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(int argc,char**argv){
  size_t n = (argc>1? atol(argv[1]): (1<<28)); // 256MiB
  char* p = mmap(NULL,n,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
  madvise(p, n, MADV_HUGEPAGE);
  srand(0xC0FFEE);
  // 접근 패턴 선택
  for(size_t i=0;i<n;i+=4096) p[i]=1;          // 순차
  for(int k=0;k<100000;k++){ p[(rand()% (n/4096))*4096]++; } // 랜덤
  munmap(p,n);
}
```

### 개요

- **가상 메모리 관리자**: 워킹셋/트림, **페이지드/논페이지드 풀**, **UMD/HMD(Heap)**.
- **Large Pages**: 2MB/1GB (x64) — `VirtualAlloc` with `MEM_LARGE_PAGES`.
- **Lookaside Lists**: 소객체 빠른 할당.
- **Memory Compression**: Windows 10+ 시스템 압축(working set trim 시 압축).

**예제: 큰 페이지 요청(관리자 권한 & 정책 필요)**
```c
// win_largepage.c — Windows: 2MB Large Page 예약
#include <windows.h>
#include <stdio.h>

int main(){
  SIZE_T sz = 2*1024*1024;
  HANDLE tok; OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &tok);
  TOKEN_PRIVILEGES tp; LUID luid;
  LookupPrivilegeValue(NULL, SE_LOCK_MEMORY_NAME, &luid);
  tp.PrivilegeCount=1; tp.Privileges[0].Luid=luid; tp.Privileges[0].Attributes=SE_PRIVILEGE_ENABLED;
  AdjustTokenPrivileges(tok, FALSE, &tp, 0, NULL, 0);
  void* p = VirtualAlloc(NULL, sz, MEM_RESERVE|MEM_COMMIT|MEM_LARGE_PAGES, PAGE_READWRITE);
  printf("ptr=%p\n", p);
}
```

### macOS / iOS (XNU)

- **VM Compressor**: 기본 내장 메모리 압축(메모리 부족 시 우선).
- **Zone allocator**: `zalloc` 기반 소객체 캐시, **magazine/per-CPU** 유사.
- **Unified buffer cache**: 파일 캐시/VM 통합.
- **Sandbox/AMFI**와 W^X, `MAP_JIT`(JIT에 한정된 RW→RX 전환).

**예제: MAP_JIT 사용(컨셉, 실제 빌드 옵션/권한 필요)**
```c
// map_jit.c — JIT용 RW->RX 전환(개념 코드)
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>

int main(){
  size_t sz = 4096;
  void* p = mmap(NULL, sz, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON
#ifdef MAP_JIT

  | MAP_JIT
#endif

  , -1, 0);
  unsigned char code[] = { 0xC3 }; // x86-64: ret
  memcpy(p, code, sizeof(code));
  mprotect(p, sz, PROT_READ|PROT_EXEC);   // W^X 준수
  // ((void(*)())p)(); // 실제 실행(보안 환경 허용 시)
  munmap(p, sz);
}
```

### Android / Embedded

- Linux 기반: **zram + lowmemorykiller(PSI/LMKD)** 로 메모리 압력 대응.
- **ashmem/ion/dma-buf**: 프로세스 간 버퍼 공유/그래픽/DSP.
- **cgroup v2**: foreground/background 메모리 제한, reclaim 우선순위.

---

## 실습 과제 & 체크리스트

### 실습 A — 압축 vs 스왑 경계 찾기

1) `memcomp_sim.py`로 압축률 프로파일링.
2) zram(메모리 스왑) vs 디스크 스왑에서 **p95 지연** 비교.
3) CPU 사용률/에너지와 교환관계 정리.

### 실습 B — 슬랩/버디 특성 관찰

1) `buddy_sim.py`, `slab_toy.py`로 외부 단편화/소객체 캐시 히트 비교.
2) 실제 시스템에서 `slabtop`, `/proc/buddyinfo` 관찰과 대조.

### 실습 C — NUMA + Huge Page AB Test

1) `thp_numa.c`로 THP/NUMA 바인딩 on/off 간 **TLB 미스/IPC** 비교.
2) 랜덤 vs 순차 접근에서 이득/손실 차이 기록.

### 운영 체크리스트

- **압축**: 알고리즘/풀 크기/배출 정책(zram vs zswap), 전력-지연 트레이드오프.
- **커널 할당**: GFP 플래그, ATOMIC 경로(IRQ)에서 실패 대책, DMA/IOMMU.
- **보안/안전**: W^X, NX, SLAB hardening, KASAN/KFENCE, init-on-alloc/free.
- **NUMA**: 퍼스트-터치, 마이그레이션 비용, cgroup과의 상호작용.
- **대페이지**: THP 정책(`always/madvise/never`)과 워크로드 특성 매칭.
- **MMIO/속성**: PAT/MAIR 일관성(버퍼가 “디바이스”인지 “정상 메모리”인지).

---

## 핵심 요약

- **10.7 메모리 압축**: 디스크 스왑을 **CPU 압축**으로 대체해 지연을 줄인다. 압축률/CPU 비용/캐시 설계가 핵심.
- **10.8 커널 메모리 할당**: **Buddy→SLAB** 계층, `kmalloc/vmalloc`, per-CPU, DMA/IOMMU, GFP 플래그로 다양한 요구를 충족.
- **10.9 기타 고려**: **NUMA**, **Huge Page**, **Page Coloring**, **MMIO 속성**, **보안(KPTI/W^X/NX)**, **PMEM** 등 시스템 전반의 맥락을 고려.
- **10.10 OS 사례**: Linux(kswapd/SLUB/zswap/THP), Windows(Paged/Nonpaged/Large Page, 시스템 압축), macOS(Compressor/zalloc), Android(zram/LMKD).
현대 VM 설계의 본질은 **“폴트율·TLB 미스·I/O 지연을 최소화하면서, 보안/안전/예측가능성을 보장”**하는 **균형의 기술**이다.
