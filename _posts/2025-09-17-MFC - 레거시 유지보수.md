---
layout: post
title: MFC - 레거시 유지보수
date: 2025-09-17 16:25:23 +0900
category: MFC
---
# 레거시 유지보수 전략: **위험도 낮은 개선 순서(리소스, 로깅, 크래시, 성능)**

> “크게 고치지 말고, **보이는 위험부터** 작게, 반복적으로.”  
> 이 글은 수년간 방치된 Win32/MFC 레거시 앱을 **서비스 중단 없이** 개선하는 **저위험 순서**를 제안합니다.  
> 포커스는 **리소스 안정화 → 로깅/관측성 → 크래시 복원력 → 성능/응답성**입니다.  
> 각 단계는 **롤백 가능**하고, **테스트 없이도**(또는 최소 테스트로) 적용 가능한 **안전한 패턴** 위주로 구성했습니다.

---

## 0) 전체 전략 한 장 요약

1. **리소스(아이콘/문자열/메모리/GDI/DPI) 안정화**  
   - 위험도 ★☆☆ | 체감도 ★★☆ | ROI ★★★  
   - 목표: 눈에 보이는 오류/누수 제거, DPI/현지화로 **사용 가능성** 향상.
2. **로깅/관측성 도입**  
   - 위험도 ★☆☆ | 체감도 ★★★ | ROI ★★★  
   - 목표: **사용자 불만→증거**로 변환(재현 불가 이슈 해결의 시작).
3. **크래시/복원력**(예외 필터, 미니덤프, 자동 재시작)  
   - 위험도 ★★☆ | 체감도 ★★★ | ROI ★★★★  
   - 목표: 죽어도 **원인 확보**, 사용자 **작업 보존**.
4. **성능/응답성 개선(측정→핫스팟만)**  
   - 위험도 ★★☆ | 체감도 ★★★★ | ROI ★★★  
   - 목표: 프리징/스톨 제거, **지각 가능한** 속도 개선.

> 각 단계는 **독립 배포 가능**하도록 설계하세요. 실패 시 **원복 스위치**(feature flag)로 되돌릴 수 있어야 합니다.

---

## 1) 착수 전 체크리스트(5일짜리 빠른 진단)

- [ ] **현행 릴리스 자산 확보**: 최신 설치본, 심볼(PDB), 소스 커밋/브랜치
- [ ] **빌드 파이프라인** 확인: 현재 빌드가 깨끗이 재현 가능한가?
- [ ] **고객 불만/로그** 수집: 3개월/1년 이슈 키워드(크래시/느림/깨짐/한글)
- [ ] **기술 부채 지도**: GDI 누수 의심, 크래시 다발 UI, 큰 I/O, 네트워크 재시도 없음
- [ ] **롤백 플랜**: 설치 패키지/설정에 “이전 버전으로 되돌리기” 버튼/옵션 마련

---

## 2) 1단계 — **리소스 안정화** (눈에 보이는 결함부터)

### 2-1. 문자열/리소스 정리(국제화 기초, 하드코딩 제거)

**목표**: 코드에 박힌 하드코딩 텍스트를 리소스로 이동 → 다국어/브랜딩/QA 용이.

```cpp
// BEFORE
AfxMessageBox(_T("저장되었습니다."));

// AFTER (string table: IDS_SAVED_OK)
CString msg; msg.LoadString(IDS_SAVED_OK);
AfxMessageBox(msg);
```

**체크리스트**
- [ ] 리소스 문자열 ID 규칙 정리(`IDS_ERR_...`, `IDS_MSG_...`)
- [ ] `AfxFormatString`/`CString::Format`로 자리표시자 사용(숫자/이름 바인딩)
- [ ] **UTF-16 정착**: `TCHAR` → `wchar_t`(유니코드 빌드)로 통일

### 2-2. 아이콘/이미지 현대화(DPI & 다크 모드 대비)

- `ICON` 리소스에 **멀티 크기**(16/20/24/32/48/64 px) 포함
- 고해상도에서 **스케일링 흐릿함** 제거
- 다크 모드 대비 흰색 아이콘은 **알파 채널**로 반전 대응

```rc
IDI_APP ICON "res\\app.ico" // 여러 해상도 내장
```

### 2-3. GDI/핸들 누수 초간단 방지

**패턴**: 핸들 생성/선택/원복/삭제 **4행 템플릿**.

```cpp
CPen pen(PS_SOLID, 1, RGB(0,0,0));
CPen* pOld = dc.SelectObject(&pen);
dc.MoveTo(...); dc.LineTo(...);
dc.SelectObject(pOld);   // 원복!
```

**도입 즉시 효과**: 프린트/대형 캔버스에서 **점점 느려지는 현상**(핸들 고갈) 사라짐.

### 2-4. DPI 대응(퍼모니터V2)

**최저 침습** 방법: **텍스트 기반 UI** 면 **윗단계 폰트/DPI로 크기 재계산**.

```cpp
// OnInitDialog에서
CFont font; LOGFONT lf{}; SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, 0);
font.CreateFontIndirect(&lf);
SendMessageToDescendants(WM_SETFONT, (WPARAM)font.m_hFont, TRUE);
```

**추가**: 레이아웃 매직 넘버 제거(Anchoring/Autosize 매크로 도입 — 나중 단계에 확장).

---

## 3) 2단계 — **로깅/관측성**(현장에서 재현 불가 문제 해결의 시작)

### 3-1. “함수가 아니라 **사건(Event)** 을 로그하라”

- 사용자 행동(열기/저장/옵션변경), 외부 호출(파일/네트워크), 오류(Win32/GetLastError)
- **PII 제거**: 경로/이름 마스킹, 해시 처리

### 3-2. 로깅 코어 — 단 100줄로 시작

```cpp
// Log.h
#pragma once
#include <string>
#include <mutex>
#include <fstream>
#include <chrono>
#include <filesystem>

enum class LogLv { Error, Warn, Info, Debug, Trace };

class Logger {
public:
    explicit Logger(std::wstring path, LogLv lv = LogLv::Info)
        : level(lv), ofs(path, std::ios::app) {}
    void write(LogLv lv, const std::wstring& msg) {
        if (lv > level) return;
        std::lock_guard<std::mutex> lk(mu);
        ofs << stamp() << L" [" << levelName(lv) << L"] " << msg << L"\n";
        ofs.flush();
    }
    void info(const std::wstring& m){ write(LogLv::Info, m); }
    void error(const std::wstring& m){ write(LogLv::Error, m); }
private:
    std::wstring stamp() {
        using namespace std::chrono;
        auto t = system_clock::to_time_t(system_clock::now());
        struct tm tm{}; localtime_s(&tm, &t);
        wchar_t buf[32]; wcsftime(buf,32,L"%F %T",&tm);
        return buf;
    }
    const wchar_t* levelName(LogLv lv) {
        switch(lv){ case LogLv::Error: return L"E";
        case LogLv::Warn: return L"W"; case LogLv::Info: return L"I";
        case LogLv::Debug: return L"D"; default: return L"T"; }
    }
    std::mutex mu; std::wofstream ofs; LogLv level;
};

extern Logger* gLog;
```

```cpp
// Log.cpp
#include "Log.h"
Logger* gLog = nullptr;
```

```cpp
// App.InitInstance()
std::filesystem::path p = /* %LOCALAPPDATA%/Vendor/App/logs/app-YYYYMMDD.txt */;
static Logger log(p.wstring(), LogLv::Info);
gLog = &log;
gLog->info(L"App start " + CStringW(AfxGetAppName()));
```

**팁**
- 로그 **롤링**: 날짜별 파일, 10MB 초과 시 숫자 증가
- **크래시 직전** 로그를 위해 **플러시** 습관화
- 성능 민감 경로는 **비동기 큐**로 전환(후속 단계)

### 3-3. Win32 오류 래핑

```cpp
inline std::wstring FormatLastError(DWORD e=GetLastError()){
    LPWSTR buf=nullptr;
    FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM|
                   FORMAT_MESSAGE_IGNORE_INSERTS,NULL,e,0,(LPWSTR)&buf,0,NULL);
    std::wstring s = buf?buf:L"(unknown)";
    if (buf) LocalFree(buf);
    return s;
}

// 사용
if (!::CreateDirectoryW(p.c_str(), nullptr)) {
    gLog->error(L"CreateDirectory failed: " + FormatLastError());
}
```

### 3-4. 사용 흔적/성능 카운터 간단 계측

```cpp
struct ScopeTimer {
    const wchar_t* name; std::chrono::high_resolution_clock::time_point t0;
    ScopeTimer(const wchar_t* n) : name(n), t0(std::chrono::high_resolution_clock::now()) {}
    ~ScopeTimer() {
        using namespace std::chrono;
        auto us = duration_cast<microseconds>(high_resolution_clock::now()-t0).count();
        if (gLog) gLog->info(std::wstring(L"[T] ") + name + L" " + std::to_wstring(us) + L" us");
    }
};

// 예: 파일 로드 구간
void CMyDoc::LoadHeavy() { ScopeTimer st(L"LoadHeavy"); /* ... */ }
```

---

## 4) 3단계 — **크래시/복원력** (예외 필터, 미니덤프, 재시작)

### 4-1. 전역 예외 필터(Top-Level SEH + C++ 예외)

```cpp
// CrashFilter.h
LONG WINAPI TopLevelFilter(EXCEPTION_POINTERS* ep);

BOOL InitCrashFilter() {
    SetUnhandledExceptionFilter(TopLevelFilter);
    // CRT: unexpected / terminate 핸들러도 연결(선택)
    return TRUE;
}
```

```cpp
// CrashFilter.cpp
#include <DbgHelp.h>
#pragma comment(lib, "Dbghelp.lib")

static void WriteMiniDump(EXCEPTION_POINTERS* ep) {
    SYSTEMTIME st; GetLocalTime(&st);
    wchar_t name[MAX_PATH];
    swprintf_s(name, L"crash-%04d%02d%02d-%02d%02d%02d.dmp",
        st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
    HANDLE h = CreateFileW(name, GENERIC_WRITE,0,nullptr,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,nullptr);
    if (h==INVALID_HANDLE_VALUE) return;

    MINIDUMP_EXCEPTION_INFORMATION mei{};
    mei.ThreadId = GetCurrentThreadId();
    mei.ExceptionPointers = ep;
    mei.ClientPointers = FALSE;

    MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), h,
        MiniDumpWithFullMemory, &mei, nullptr, nullptr);
    CloseHandle(h);
}

LONG WINAPI TopLevelFilter(EXCEPTION_POINTERS* ep) {
    if (gLog) gLog->error(L"Unhandled exception: writing minidump");
    WriteMiniDump(ep);
    return EXCEPTION_EXECUTE_HANDLER; // 프로세스 종료
}
```

**주의**
- DbgHelp.dll 버전 호환(시스템 것 사용)
- PDB(심볼) 보관: 같은 빌드의 기호로 **덤프 열람** 가능

### 4-2. 자동 재시작 & 작업 복구(간단 UX)

- 종료 전 **열려 있던 파일 목록/상태**를 `%APPDATA%/recovery.json`에 덤프
- 다음 실행에서 발견되면 **“복구하시겠습니까?”** 다이얼로그

```cpp
// 종료 직전
SaveRecoveryState(docPaths, recentActions);

// 시작 시
if (auto s = LoadRecoveryState()) {
    if (AskYesNo(L"이전 세션이 비정상 종료되었습니다. 복구하시겠습니까?")) Restore(s);
}
```

### 4-3. 위험한 서드파티 호출 보호

- 플러그인/스크립트/외부 DLL 호출 **경계**에 `__try/__except`(SEH)로 보호
- 실패 시 **해당 기능만** 비활성화 후 앱은 계속

```cpp
__try { plugin->Process(...); }
__except(EXCEPTION_EXECUTE_HANDLER) {
    gLog->error(L"Plugin crashed. Disabled.");
    DisablePlugin(plugin);
}
```

---

## 5) 4단계 — **성능/응답성** (측정 기반, 국소 개선)

> “**측정 없이 최적화하지 않는다**” — 프로파일과 로그를 먼저.

### 5-1. UI 프리징 제거(메시지 펌프 유지)

- 오래 걸리는 작업은 **워커 스레드**로, UI는 **진행률/취소**만
- 타임아웃/취소 토큰을 **API 표면**에 추가

```cpp
// 긴 작업 시작
m_worker = std::thread([this]{
    for (int i=0;i<chunks && !m_cancel.load();++i) {
        DoChunk(i);
        PostMessage(WM_APP_PROGRESS, i, 0);
    }
    PostMessage(WM_APP_DONE, 0, 0);
});
```

### 5-2. 그리기 배치(Invalidation 최소화, 더블버퍼)

- **InvalidateRect** 최소 호출, 영역 합치기
- **WM_PAINT 내에서만** 그리기(타 이벤트에서 DC 얻지 않기)
- 더블버퍼(메모리 DC → BitBlt)

```cpp
void CCanvas::OnPaint() {
    CPaintDC dc(this);
    CRect rc; GetClientRect(&rc);
    CDC mem; mem.CreateCompatibleDC(&dc);
    CBitmap bmp; bmp.CreateCompatibleBitmap(&dc, rc.Width(), rc.Height());
    auto old = mem.SelectObject(&bmp);
    mem.FillSolidRect(rc, RGB(255,255,255));
    RenderScene(mem);
    dc.BitBlt(0,0,rc.Width(),rc.Height(), &mem, 0,0, SRCCOPY);
    mem.SelectObject(old);
}
```

### 5-3. I/O 병렬화 & 캐싱

- 큰 파일 **스트리밍**: `ReadFile` 반복 + **진행률**
- **임시 캐시**: 썸네일/파싱 결과를 `%LOCALAPPDATA%\cache`에 저장
- 네트워크는 **비동기**(`WinHTTP async`/`CAsyncSocket`) + **재시도/지수 백오프**

### 5-4. 핫스팟: 컨테이너/문자열/락

- `std::vector` 재할당 비용 → `reserve`
- 반복적인 `CString` 연결 → `std::wstring` + `reserve` or `fmt::format`
- **락 경쟁**: 긴 구간 → 락 분할/락 없는 구조(리더-복제)/`std::scoped_lock`

---

## 6) 위험도 낮은 **릴리즈 루프**(2주 스프린트 예시)

| 주차 | 목표 | 교체/추가 | 롤백 스위치 |
|---|---|---|---|
| 1주차 | 리소스 정리/DPI 기초 | 문자열 리소스화, 아이콘 교체 | `/NoDpi` 플래그 |
| 2주차 | 로깅 배포 | 파일 로그 + 롤링 | `app.ini: Logging=0/1` |
| 3주차 | 크래시 필터/덤프 | SEH + 미니덤프 | `app.ini: CrashDump=0/1` |
| 4주차 | 성능 핫스팟 2건 | 더블버퍼/워커 전환 | 기능 플래그별 on/off |

**원칙**
- 매주 **작게** 배포, **문제 생기면 즉시 롤백**.
- 새 기능은 **기본 OFF**, 내부에서만 켜서 검증 후 **사용자 10%** → 점차 확대.

---

## 7) 코드 스니펫 모음(즉시 붙여넣기용)

### 7-1. 안전 파일 쓰기(원자 교체)

```cpp
bool AtomicWriteFile(const std::wstring& path, const std::string& data) {
    auto tmp = path + L".tmp";
    HANDLE h = CreateFileW(tmp.c_str(), GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (h==INVALID_HANDLE_VALUE) return false;
    DWORD w=0; WriteFile(h, data.data(), (DWORD)data.size(), &w, nullptr);
    FlushFileBuffers(h); CloseHandle(h);
    // 기존 -> .bak (옵션), tmp -> 본파일
    MoveFileExW(tmp.c_str(), path.c_str(), MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
    return true;
}
```

### 7-2. 간편 Feature Flag

```cpp
bool IsFeatureOn(const wchar_t* name){
    CString v = GetProfileStringW(L"Features", name, L"0");
    return v == L"1";
}
// 사용
if (IsFeatureOn(L"CrashDump")) InitCrashFilter();
```

### 7-3. UI 스레드 디스패처

```cpp
void PostUI(std::function<void()> fn) {
    auto p = new std::function<void()>(std::move(fn));
    PostMessage(g_hMainWnd, WM_APP+777, (WPARAM)p, 0);
}
LRESULT CMainFrame::OnDispatch(WPARAM w, LPARAM) {
    auto p = (std::function<void()>*)w;
    (*p)(); delete p; return 0;
}
```

---

## 8) “거의 무해한” 리팩터링 규칙(레거시에 맞춘)

- **함수 시그니처 변경 금지**, 내부에서만 개선  
- **전역 상태** 접근 최소화(읽기 전용에 가깝게)  
- **새 코드 경로는 기본 OFF**, 기존 경로와 **동작 동등성** 유지  
- **포맷/스타일 대규모 변경 금지**(diff 지옥 방지)  
- **배포 전**: 스모크(실행/주요 화면/열기/저장/종료)만이라도 자동화

---

## 9) 배포/운영 팁

- **로그/덤프 제출 버튼**: 사용자가 즉시 보낼 수 있게  
- **버전/빌드 번호**를 **타이틀/로그 첫 줄**에 노출  
- **이전 버전 보관 2~3개**: 즉시 롤백 가능  
- 설치 프로그램에 **“클린 설정 초기화”** 옵션(레지스트리/설정 폴더 초기화)

---

## 10) 성숙도 로드맵(6개월)

1. **월 1** — 리소스/로깅/덤프/핫스팟 1~2건  
2. **월 2~3** — 네트워크/파일 I/O 재시도/타임아웃/백오프 정책 도입  
3. **월 4~5** — 플러그인 경계 보호(SEH), 장애 플러그인 블랙리스트 자동화  
4. **월 6** — 모듈화/테스트 가능한 구조(간단 MVP/MVVM-ish)로 핵심 화면 1~2개 전환

---

## 11) 위험/효과 매트릭스 — 우선순위 결정 가이드

| 개선 | 위험 | 효과 | 코멘트 |
|---|---|---|---|
| 문자열 리소스화 | 낮음 | 중간 | 테스트 쉬움 |
| DPI 폰트/아이콘 | 낮음 | 중간 | 호환성↑ |
| 파일 로그 | 낮음 | 높음 | 문제 재현성↑ |
| 미니덤프 | 낮음 | 매우 높음 | 원인 확보 |
| 더블버퍼 | 중간 | 중간~높음 | 깜빡임/CPU↓ |
| 워커 전환 | 중간 | 높음 | 프리징 제거 |
| 네트워크 재시도 | 중간 | 높음 | 현장 안정성↑ |
| 대규모 리팩터 | 매우 높음 | 다양 | **초기 금지** 권장 |

---

## 12) 실제 적용 사례(축약)

- **문제**: “가끔 저장하면 앱이 멈춘다”  
- **적용 순서**: 로그 → 덤프 → 더블버퍼/워커 → 파일 원자쓰기  
- **결과**: 로그상 `FlushFileBuffers`에서 4~7초 블록 → 워커로 이동, UI는 진행률.  
  크래시 케이스는 **플러그인 JPEG 디코더** 예외 → 경계 SEH로 **비활성화**.

---

## 13) 최종 체크리스트

- [ ] 문자열/아이콘/폰트 리소스화, GDI 핸들 원복  
- [ ] 파일 로그 + 롤링, Win32 오류 포맷 헬퍼  
- [ ] 전역 예외 필터, 미니덤프, 재시작/복구  
- [ ] 핫스팟: 더블버퍼, 워커 전환, I/O 스트리밍  
- [ ] Feature Flag/롤백 스위치  
- [ ] 배포/되돌리기/증거 수집 UX  
- [ ] 스모크 자동화(빌드 후 2분 이내)

---

## 14) 마무리

레거시 개선은 **신규 개발**과 다릅니다.  
우선은 **망가지지 않게**, **보이는 위험부터** 제거하며,  
**증거(로그/덤프)** 를 모아 **정확히** 손댈 곳만 손대는 것이 관건입니다.

이 글의 순서(리소스 → 로깅 → 크래시 → 성능)는  
- 팀에 새로 들어온 엔지니어도 **안전하게** 적용할 수 있고,  
- 경영진/고객에게 **눈에 띄는 가시적 개선**을 **짧은 주기**로 제공합니다.