---
layout: post
title: C++ - 스마트 포인터 구현 (4)
date: 2024-09-26 19:20:23 +0900
category: Cpp
---
# C++ 스마트 포인터 구현 4/6 — **배열**, **커스텀 Deleter**, **다형성 캐스팅**, **불완전형 지원**

> 목표: 1~3편에서 만든 `MyUniquePtr / MySharedPtr / MyWeakPtr / enable_shared_from_this`를 **실전에서 바로 쓰게** 만드는 고급 기능을 추가한다.
> 이번 편에서는
> (A) **배열(Array) 관리**
> (B) **커스텀 Deleter** (파일/소켓/OS 핸들 등)
> (C) **다형성 캐스팅 유틸** (`static_pointer_cast`/`dynamic_pointer_cast` 등)
> (D) **불완전형(incomplete type)** 패턴
> (E) **메모리 모델·스레드 안전성 주의점**
> 을 설계·구현·검증한다.

---

## 로드맵 리마인드

- 1편: `MyUniquePtr` — 단독 소유(이동 전용)
- 2편: `MySharedPtr` — 컨트롤 블록/참조 카운팅/`my_make_shared`/**aliasing 생성자**
- 3편: `MyWeakPtr` + `enable_shared_from_this`
- **4편(이번)**: **배열**, **커스텀 deleter**, **다형성 캐스팅**, **불완전형**, **메모리 모델 고급**
- 5편: 실전 적용·벤치마킹·도구 연동
- 6편: 테스트 스위트/디버그 어댑터/인터페이스 폴리시

> 이하 코드는 2~3편의 컨트롤 블록과 카운팅 로직을 **그대로 재사용**한다.
> (동일 네임스페이스/헤더에 누적해도 되고, 별도 `*.hpp`로 분리해도 된다.)

---

## A. **배열(Array) 관리**

### A-1) `MyUniquePtr<T[]>` 부분 특수화

`unique_ptr<T[]>`는 **배열 전용 인터페이스**( `operator[]` )와 **`delete[]` 소멸**을 제공한다. 우리도 동일한 UX를 제공하자.

```cpp
// unique_array.hpp
template <class T>
class MyUniquePtr<T[]> {
    T* ptr_ = nullptr;
public:
    using element_type = T;

    MyUniquePtr() noexcept = default;
    explicit MyUniquePtr(T* p) noexcept : ptr_(p) {}

    // 이동만 허용
    MyUniquePtr(MyUniquePtr&& o) noexcept : ptr_(o.ptr_) { o.ptr_ = nullptr; }
    MyUniquePtr& operator=(MyUniquePtr&& o) noexcept {
        if (this != &o) { reset(); ptr_ = o.ptr_; o.ptr_ = nullptr; }
        return *this;
    }
    MyUniquePtr(const MyUniquePtr&) = delete;
    MyUniquePtr& operator=(const MyUniquePtr&) = delete;

    ~MyUniquePtr() { delete[] ptr_; }

    // 배열 전용 연산
    T& operator[](std::size_t i) const noexcept { return ptr_[i]; }

    // 유틸
    T* get() const noexcept { return ptr_; }
    explicit operator bool() const noexcept { return ptr_ != nullptr; }

    T* release() noexcept { T* tmp = ptr_; ptr_ = nullptr; return tmp; }
    void reset(T* p = nullptr) noexcept { if (ptr_ != p) { delete[] ptr_; ptr_ = p; } }
    void swap(MyUniquePtr& other) noexcept { using std::swap; swap(ptr_, other.ptr_); }
};

// 헬퍼: 값 0으로 초기화된 배열
template <class T>
MyUniquePtr<T[]> my_make_unique_array_zero(std::size_t n) {
    return MyUniquePtr<T[]>(n ? new T[n]{} : nullptr);
}

// 헬퍼: 생성자 호출(기본값/값 초기화는 T에 따름)
template <class T>
MyUniquePtr<T[]> my_make_unique_array(std::size_t n) {
    return MyUniquePtr<T[]>(n ? new T[n] : nullptr);
}
```

#### 사용 예: 바이너리 읽기

```cpp
#include <fstream>
#include <iostream>

void load_bin(const char* path) {
    std::ifstream fin(path, std::ios::binary);
    fin.seekg(0, std::ios::end);
    std::size_t n = static_cast<std::size_t>(fin.tellg());
    fin.seekg(0);

    auto buf = my_make_unique_array_zero<unsigned char>(n);
    fin.read(reinterpret_cast<char*>(buf.get()), n);

    std::cout << "first byte: " << (int)buf[0] << "\n";
} // buf 소멸 시 delete[] 자동 호출
```

---

### A-2) `MySharedPtr<T[]>` 부분 특수화

표준도 `shared_ptr<T[]>`을 제공한다(C++17~).
우리는 **컨트롤 블록은 그대로** 쓰되, **배열 UX**( `operator[]` )만 얹는다.

핵심 아이디어:
- 배열은 **요소 수**가 필요할 때가 많다 → 선택적으로 `size_`를 저장.
- 생성은 보통 **두 번 할당**: `new T[n]` + `new ControlBlockPtr< T[], default_delete<T[]> >`.
- (고급) **단일 할당**을 원한다면 `ControlBlockArray`를 설계해 **내부에 n개를 배치**해야 한다(복잡). 여기선 실용 노선을 택한다.

```cpp
// shared_array.hpp
template <class T>
class MySharedPtr<T[]> {
    T* ptr_ = nullptr;
    ControlBlockBase* ctrl_ = nullptr;
    std::size_t size_ = 0; // 선택 저장(0이면 미기록)

    void inc_shared() noexcept { if (ctrl_) ctrl_->shared_count.fetch_add(1); }
    void release_shared() noexcept {
        if (!ctrl_) return;
        if (ctrl_->shared_count.fetch_sub(1, std::memory_order_acq_rel) == 1) {
            ctrl_->destroy_object(); // delete[] or 커스텀 deleter
            if (ctrl_->weak_count.load(std::memory_order_acquire) == 0) ctrl_->delete_this();
        }
        ptr_ = nullptr; ctrl_ = nullptr; size_ = 0;
    }

    // 내부 전용 생성자
    MySharedPtr(ControlBlockBase* c, T* p, std::size_t n) noexcept : ptr_(p), ctrl_(c), size_(n) {}

    template <class U> friend class MyWeakPtr; // 필요 시
    template <class U> friend class MySharedPtr;
    template <class U> friend MySharedPtr<U[]> my_make_shared_array(std::size_t);
    template <class U> friend MySharedPtr<U[]> my_shared_from_raw_array(U*, std::size_t);

public:
    using element_type = T;

    MySharedPtr() noexcept = default;

    // raw 포인터 + 기본 deleter(delete[]) 채택
    explicit MySharedPtr(T* p, std::size_t n = 0) {
        if (p) {
            ctrl_ = new ControlBlockPtr<T[], std::default_delete<T[]>>(p, std::default_delete<T[]>{});
            ptr_ = p; size_ = n;
        }
    }

    // 복사/이동/소멸
    MySharedPtr(const MySharedPtr& o) noexcept : ptr_(o.ptr_), ctrl_(o.ctrl_), size_(o.size_) { inc_shared(); }
    MySharedPtr(MySharedPtr&& o) noexcept : ptr_(o.ptr_), ctrl_(o.ctrl_), size_(o.size_) { o.ptr_=nullptr; o.ctrl_=nullptr; o.size_=0; }
    ~MySharedPtr() { release_shared(); }

    MySharedPtr& operator=(const MySharedPtr& o) noexcept {
        if (this != &o) { release_shared(); ptr_=o.ptr_; ctrl_=o.ctrl_; size_=o.size_; inc_shared(); }
        return *this;
    }
    MySharedPtr& operator=(MySharedPtr&& o) noexcept {
        if (this != &o) { release_shared(); ptr_=o.ptr_; ctrl_=o.ctrl_; size_=o.size_; o.ptr_=nullptr; o.ctrl_=nullptr; o.size_=0; }
        return *this;
    }

    // 배열 UX
    T& operator[](std::size_t i) const noexcept { return ptr_[i]; }
    T* get() const noexcept { return ptr_; }
    std::size_t size() const noexcept { return size_; }
    explicit operator bool() const noexcept { return ptr_ != nullptr; }

    long use_count() const noexcept { return ctrl_ ? ctrl_->shared_count.load() : 0; }
    void reset() noexcept { MySharedPtr().swap(*this); }
    void swap(MySharedPtr& o) noexcept { using std::swap; swap(ptr_,o.ptr_); swap(ctrl_,o.ctrl_); swap(size_,o.size_); }
};

// 헬퍼: 값 0 초기화된 배열
template <class T>
MySharedPtr<T[]> my_make_shared_array(std::size_t n) {
    if (!n) return {};
    T* raw = new T[n]{}; // 값 0 초기화(필요 시 다른 정책으로)
    auto* ctrl = new ControlBlockPtr<T[], std::default_delete<T[]>>(raw, std::default_delete<T[]>{});
    return MySharedPtr<T[]>(ctrl, raw, n);
}

// 헬퍼: 외부 메모리 + 커스텀 deleter로도 가능하도록 T[] 델리터를 가진 ControlBlock 사용
template <class T, class D>
MySharedPtr<T[]> my_shared_from_raw_array(T* p, std::size_t n, D deleter) {
    if (!p) return {};
    auto* ctrl = new ControlBlockPtr<T[], D>(p, std::move(deleter));
    return MySharedPtr<T[]>(ctrl, p, n);
}
```

#### 사용 예: 이미지 버퍼 공유

```cpp
struct Image {
    int w, h;
    MySharedPtr<unsigned char[]> pixels; // 공유 버퍼
    Image(int w, int h) : w(w), h(h), pixels(my_make_shared_array<unsigned char>(w*h*4)) {}
};

void blend(Image& a, Image& b) {
    auto n = std::min(a.pixels.size(), b.pixels.size());
    for (std::size_t i = 0; i < n; ++i) a.pixels[i] = (a.pixels[i] + b.pixels[i]) / 2;
}
```

---

## B. **커스텀 Deleter**

파일/소켓/HANDLE/`free()`/GPU buffer 등 **`delete`로 파괴할 수 없는 자원**은 **Deleter**로 처리한다.
우리는 컨트롤 블록이 이미 `(포인터, Deleter)`를 저장할 수 있으므로 **헬퍼 팩토리**만 추가하면 된다.

```cpp
// shared_from_raw.hpp

// 단일 객체: T, 임의 deleter
template <class T, class D>
MySharedPtr<T> my_shared_from_raw(T* p, D deleter) {
    if (!p) return {};
    auto* ctrl = new ControlBlockPtr<T, D>(p, std::move(deleter));
    return MySharedPtr<T>(ctrl, p); // 내부 전용 생성자(2편) 가정
}

// 배열 객체: T[], 임의 deleter
template <class T, class D>
MySharedPtr<T[]> my_shared_from_raw_array(T* p, std::size_t n, D deleter) {
    if (!p) return {};
    auto* ctrl = new ControlBlockPtr<T[], D>(p, std::move(deleter));
    return MySharedPtr<T[]>(ctrl, p, n);
}
```

#### 사용 예 1: `FILE*`

```cpp
#include <cstdio>
#include <iostream>

MySharedPtr<FILE> open_file(const char* path, const char* mode) {
    FILE* fp = std::fopen(path, mode);
    return my_shared_from_raw(fp, [](FILE* f){ if (f) std::fclose(f); });
}

int main() {
    auto file = open_file("out.txt", "wb");
    if (file) {
        const char msg[] = "hello\n";
        std::fwrite(msg, 1, sizeof(msg)-1, file.get());
    }
} // 자동 fclose
```

#### 사용 예 2: `malloc`/`free`

```cpp
#include <cstdlib>

auto buf = my_shared_from_raw_array(
    static_cast<unsigned char*>(std::malloc(1024)), 1024,
    [](unsigned char* p){ std::free(p); }
);
```

#### 사용 예 3: OS Handle (Windows 예시)

```cpp
// pseudo: HANDLE CloseHandle(HANDLE)
struct HandleDeleter { void operator()(void* h) const noexcept { /* CloseHandle((HANDLE)h); */ } };
MySharedPtr<void> h = my_shared_from_raw(/*HANDLE*/(void*)0xDEADBEEF, HandleDeleter{});
```

> **핵심**: 컨트롤 블록은 **Deleter를 소유**하므로, **객체 파괴 시점**에 정확한 함수를 호출해 준다.

---

## C. **다형성 캐스팅 유틸**

표준 `shared_ptr`의 `static_pointer_cast` / `dynamic_pointer_cast` / `const_pointer_cast`와 동일 UX를 제공.
**컨트롤 블록은 유지**, **포인터만 변환**(aliasing 생성자를 활용).

```cpp
// pointer_cast.hpp
template <class To, class From>
MySharedPtr<To> my_static_pointer_cast(const MySharedPtr<From>& sp) noexcept {
    To* p = static_cast<To*>(sp.get());
    return MySharedPtr<To>(sp, p); // 2편의 aliasing 생성자
}

template <class To, class From>
MySharedPtr<To> my_dynamic_pointer_cast(const MySharedPtr<From>& sp) noexcept {
    if (auto p = dynamic_cast<To*>(sp.get())) return MySharedPtr<To>(sp, p);
    return {}; // 실패 시 빈 포인터
}

template <class To, class From>
MySharedPtr<To> my_const_pointer_cast(const MySharedPtr<From>& sp) noexcept {
    To* p = const_cast<To*>(sp.get());
    return MySharedPtr<To>(sp, p);
}
```

#### 사용 예: 업/다운캐스팅

```cpp
struct Base { virtual ~Base(){} };
struct Der : Base { void hello(){} };

MySharedPtr<Base> b = my_make_shared<Der>();
auto d_ok = my_dynamic_pointer_cast<Der>(b);
if (d_ok) d_ok->hello(); // ok

auto d_bad = my_dynamic_pointer_cast<Der>(my_make_shared<Base>());
if (!d_bad) { /* 캐스팅 실패 처리 */ }
```

> **참조 카운트는 그대로 유지**되고, **동일 컨트롤 블록을 공유**한다.

---

## D. **불완전형(Incomplete Type) 지원 패턴**

실전에서 **헤더 분리**를 위해 타입을 **선언만 먼저**하는 경우가 많다.

### D-1) `MySharedPtr` 과 불완전형

`shared_ptr`은 **타입 T가 불완전해도 선언·대입 가능**이다.
**소멸 시점**에 컨트롤 블록이 보유한 **Deleter**가 호출되며, 그때 T가 **완전형으로 보이는 번역단위**라면 정상 `delete` 된다.

**권장 패턴**:

```cpp
// Foo_fwd.hpp
struct Foo;                       // 전방 선언
MySharedPtr<Foo> makeFoo();       // 팩토리 선언

// Foo.hpp
#include "Foo_fwd.hpp"

struct Foo { /* ... */ };
MySharedPtr<Foo> makeFoo();       // 정의

// Foo.cpp
#include "Foo.hpp"

MySharedPtr<Foo> makeFoo() {
    return my_make_shared<Foo>(); // 컨트롤 블록도 이 TU에서 생성
}
```

- **핵심**: `my_make_shared<Foo>()` 가 **Foo를 완전하게 아는** 번역 단위에서 정의되도록.

### D-2) `MyUniquePtr<T, D>` 스타일과 불완전형

`unique_ptr`은 **디폴트 deleter**를 쓰면 **소멸 지점에서 T가 완전형이어야** 한다.
불완전형이라면 **커스텀 deleter**를 **헤더에서 타입 완전성을 보지 않고도** 인라인으로 호출 가능한 방식으로 설계해야 한다.

우리의 `MyUniquePtr`은 deleter를 템플릿 파라미터로 받지 않는 단순형이므로,
**불완전형에서는 `MySharedPtr + 커스텀 deleter`**를 우선 추천한다.
(5편에서 `MyUniquePtr<T, D>` 변형을 추가해도 된다.)

---

## E. **메모리 모델 & 스레드 안전성(고급)**

2~3편에서 우리는 `std::atomic<long>`로 **shared/weak 카운트**를 관리했다.
여기서 **왜 이 메모리 오더인가**를 요약한다.

- **공유 카운트 증가** (`inc_shared()`): `fetch_add(1)`
  - 단순 **참조 관계만** 만드는 경우 → `memory_order_relaxed`도 가능한 선택.
  - 우리는 보수적으로 기본 `seq_cst`(구현체 기본) 또는 `acq_rel`를 사용해도 충분.

- **공유 카운트 감소** (`release_shared()`):
  - `fetch_sub(1, memory_order_acq_rel) == 1` → **마지막 참조**.
  - 이후 `destroy_object()` 호출 전까지의 **쓰기 가시성 보장**을 위해 `acquire`/`release`의 **경계**가 필요.
  - 오브젝트 파괴가 **다른 스레드의 쓰기**를 모두 관측 가능한 상태여야 한다(파괴 중 데이터 레이스 회피).

- **weak lock**:
  - `while (cnt > 0) CAS(cnt, cnt+1)` — **생존 중인 컨트롤 블록을 안전히 붙잡기**.
  - 실패 시 재시도. 0이면 이미 파괴 완료.

> 안전성 불변식 (직관식):
>
> $$
> \text{shared\_count} = 0 \Rightarrow \text{객체 파괴 완료}
> $$
> $$
> \text{shared\_count} = 0 \land \text{weak\_count} = 0 \Rightarrow \text{컨트롤 블록 파괴}
> $$

### 간단 스트레스 테스트(개념)

```cpp
#include <thread>
#include <vector>
#include <cassert>

struct Big { int x[1<<16]{}; }; // 큰 객체
void stress() {
    auto sp = my_make_shared<Big>();
    constexpr int N = 8;
    std::vector<MySharedPtr<Big>> keep(N);

    std::thread t1([&]{ for (int i=0;i<100000;++i) keep[i%N] = sp; });
    std::thread t2([&]{ for (int i=0;i<100000;++i) keep[i%N].reset(); });

    t1.join(); t2.join();
    // sp 살아있음
    assert(sp.use_count() >= 1);
}
```

---

## F. **검증 시나리오 모음**

1) **배열 복합 시나리오**
```cpp
auto a = my_make_shared_array<int>(8);
auto b = a;              // 복사
b[3] = 7;
a.reset();               // b가 소유 유지
```

2) **파일 핸들/에러 경로**
```cpp
auto fp = open_file("not_exist.txt", "rb"); // nullptr일 수 있음
if (!fp) {
    // 빈 MySharedPtr
}
```

3) **다형성 캐스팅**
```cpp
MySharedPtr<Base> b = my_make_shared<Der>();
auto d = my_dynamic_pointer_cast<Der>(b);
assert( (bool)d );
```

4) **불완전형 헤더 분리**
- `makeFoo()` 팩토리를 **Foo.cpp**에 두고, 헤더에는 선언만.

---

## G. **자주 하는 실수와 가이드**

- [ ] **배열에 `MySharedPtr<T>`를 쓰고 `delete[]`를 기대**하지 말 것 → `MySharedPtr<T[]>`(또는 커스텀 deleter) 사용.
- [ ] **외부 자원**(`FILE*`, 소켓, HANDLE, `free()` 등)은 **반드시 커스텀 Deleter**.
- [ ] **캐스팅 시 새 컨트롤 블록**을 만들지 말 것 → **aliasing 생성자**로 **동일 블록 공유**.
- [ ] **불완전형**을 소멸하는 위치를 통제할 것 → 팩토리/정의 분리.
- [ ] 멀티스레드에서 **`weak.lock()`의 CAS 루프**는 정상(경합 해소).
- [ ] `enable_shared_from_this`는 **오너십 획득 직후 1회만 연결**(2·3편 구현 참고).

---

## H. **요약 체크리스트(4편 달성)**

- [x] `MyUniquePtr<T[]>` — 배열 전용 연산/`delete[]`
- [x] `MySharedPtr<T[]>` — 배열 UX + 컨트롤 블록 재사용
- [x] 커스텀 Deleter 헬퍼 — 파일/OS 핸들/`free()`/GPU 등
- [x] 다형성 캐스팅 — `my_static/dynamic/const_pointer_cast`
- [x] 불완전형 분리 패턴 — 헤더/소스 설계 가이드
- [x] 메모리 모델 논의 — 카운팅/파괴 경계/`weak.lock()` CAS
