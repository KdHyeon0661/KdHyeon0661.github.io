---
layout: post
title: C++ - 스마트 포인터 구현 (4)
date: 2024-09-26 19:20:23 +0900
category: Cpp
---
# C++ 스마트 포인터 실전 활용: 배열, 커스텀 리소스, 다형성 캐스팅

이전 편들에서 스마트 포인터의 기본 메커니즘을 구현했다면, 이제는 이 도구들을 실전에서 바로 사용할 수 있도록 다양한 고급 기능을 추가할 때입니다. 배열 관리, 커스텀 리소스 처리, 다형성 캐스팅, 불완전형 지원 등의 실용적인 기능들을 구현하며, 우리의 스마트 포인터 시스템을 완성해 나가겠습니다.

## 배열 관리: 단순함과 안전성의 조화

배열은 단일 객체와는 다른 특별한 관리가 필요합니다. 가장 큰 차이는 메모리 해제 시 `delete[]`를 사용해야 한다는 점입니다. `MyUniquePtr`과 `MySharedPtr` 모두 배열 전용 특수화를 통해 이 요구를 안전하게 만족시킵니다.

### MyUniquePtr 배열 특수화

`MyUniquePtr<T[]>`의 구현은 단순하면서도 강력합니다:

```cpp
template <class T>
class MyUniquePtr<T[]> {
    T* ptr_ = nullptr;
    
public:
    // 배열 전용 연산자
    T& operator[](std::size_t i) const noexcept { 
        return ptr_[i]; 
    }
    
    // 올바른 메모리 해제
    ~MyUniquePtr() { 
        delete[] ptr_; 
    }
    
    // 배열용 헬퍼 함수
    void reset(T* p = nullptr) noexcept {
        if (ptr_ != p) {
            delete[] ptr_;
            ptr_ = p;
        }
    }
};

// 사용 예: 바이너리 데이터 읽기
void process_image(const char* filename) {
    std::ifstream file(filename, std::ios::binary | std::ios::ate);
    std::size_t size = file.tellg();
    file.seekg(0);
    
    // 배열 버퍼 자동 관리
    auto buffer = my_make_unique_array_zero<unsigned char>(size);
    file.read(reinterpret_cast<char*>(buffer.get()), size);
    
    // 배열 인덱싱
    for (std::size_t i = 0; i < 10; ++i) {
        std::cout << "Byte " << i << ": " << static_cast<int>(buffer[i]) << "\n";
    }
} // 버퍼 자동 해제
```

### MySharedPtr 배열 특수화

`MySharedPtr<T[]>`는 참조 카운팅의 이점을 배열 관리에 적용합니다:

```cpp
template <class T>
class MySharedPtr<T[]> {
    T* ptr_ = nullptr;
    ControlBlockBase* ctrl_ = nullptr;
    std::size_t size_ = 0;  // 배열 크기 정보 보관
    
public:
    // 배열 크기 정보 접근
    std::size_t size() const noexcept { 
        return size_; 
    }
    
    // 안전한 배열 인덱싱
    T& operator[](std::size_t i) const noexcept {
        // 실제 구현에서는 범위 검사 권장
        return ptr_[i];
    }
};

// 이미지 처리 시스템 예시
struct Image {
    int width, height;
    MySharedPtr<float[]> pixels;  // 부동소수점 픽셀 데이터 공유
    
    Image(int w, int h) 
        : width(w), height(h),
          pixels(my_make_shared_array<float>(w * h * 3)) {
        // 모든 픽셀을 0으로 초기화
        std::fill(pixels.get(), pixels.get() + pixels.size(), 0.0f);
    }
    
    // 이미지 복사 없이 픽셀 데이터 공유
    Image create_gray_version() const {
        Image gray(width, height);
        for (int i = 0; i < width * height; ++i) {
            // RGB 평균 계산
            float r = pixels[i * 3];
            float g = pixels[i * 3 + 1];
            float b = pixels[i * 3 + 2];
            float gray_value = (r + g + b) / 3.0f;
            
            gray.pixels[i * 3] = gray_value;
            gray.pixels[i * 3 + 1] = gray_value;
            gray.pixels[i * 3 + 2] = gray_value;
        }
        return gray;
    }
};
```

## 커스텀 리소스 관리: C API와의 원활한 통합

C++ 코드베이스에는 종종 C API의 리소스(파일, 소켓, 메모리 등)를 관리해야 하는 경우가 많습니다. 커스텀 삭제자는 이러한 이종 리소스들을 일관된 RAII 패턴으로 관리할 수 있게 합니다.

### 다양한 리소스 유형 통합 관리

```cpp
// 파일 핸들 관리
MySharedPtr<FILE> open_file(const char* path, const char* mode) {
    FILE* fp = std::fopen(path, mode);
    return my_shared_from_raw(fp, [](FILE* f) { 
        if (f) std::fclose(f); 
    });
}

// malloc/free 기반 메모리
auto buffer = my_shared_from_raw_array(
    static_cast<float*>(std::malloc(1024 * sizeof(float))),
    1024,
    [](float* p) { std::free(p); }
);

// Windows 핸들 (개념적 예시)
#ifdef _WIN32
struct HandleDeleter {
    void operator()(HANDLE h) const noexcept {
        if (h != INVALID_HANDLE_VALUE) {
            CloseHandle(h);
        }
    }
};

auto file_handle = my_shared_from_raw(
    CreateFileA("data.bin", GENERIC_READ, 0, nullptr,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr),
    HandleDeleter{}
);
#endif
```

### 리소스 풀 패턴

커스텀 삭제자를 활용하면 복잡한 리소스 관리 정책도 구현할 수 있습니다:

```cpp
class DatabaseConnection {
    // 데이터베이스 연결 상태...
    
public:
    static MySharedPtr<DatabaseConnection> create() {
        // 실제 구현에서는 연결 풀에서 재사용
        return my_make_shared<DatabaseConnection>();
    }
    
    void execute_query(const std::string& query) {
        // 쿼리 실행 로직
    }
};

// 커스텀 삭제자: 연결을 닫는 대신 풀로 반환
struct ConnectionReleaser {
    ConnectionPool* pool;
    
    void operator()(DatabaseConnection* conn) const noexcept {
        if (conn && pool) {
            pool->release(conn);  // 연결 닫지 않고 풀에 반환
        }
    }
};

// 사용 예
auto conn = my_shared_from_raw(
    DatabaseConnection::create().get(),
    ConnectionReleaser{&connection_pool}
);
```

## 다형성 캐스팅: 유연한 타입 변환

상속 계층을 다룰 때는 타입 캐스팅이 빈번히 필요합니다. 표준 `shared_ptr`의 캐스팅 함수들을 구현하면 안전하고 효율적인 타입 변환을 제공할 수 있습니다.

### 안전한 캐스팅 유틸리티 구현

```cpp
// 정적 캐스팅: 컴파일 타임에 타입 안전성 검증
template <class To, class From>
MySharedPtr<To> my_static_pointer_cast(const MySharedPtr<From>& sp) noexcept {
    To* p = static_cast<To*>(sp.get());
    return MySharedPtr<To>(sp, p);  // 기존 컨트롤 블록 공유
}

// 동적 캐스팅: 런타임 타입 검사
template <class To, class From>
MySharedPtr<To> my_dynamic_pointer_cast(const MySharedPtr<From>& sp) noexcept {
    if (auto p = dynamic_cast<To*>(sp.get())) {
        return MySharedPtr<To>(sp, p);
    }
    return {};  // 캐스팅 실패 시 빈 포인터
}

// const 캐스팅: 상수성 제거
template <class To, class From>
MySharedPtr<To> my_const_pointer_cast(const MySharedPtr<From>& sp) noexcept {
    To* p = const_cast<To*>(sp.get());
    return MySharedPtr<To>(sp, p);
}
```

### 다형성 시스템에서의 활용

```cpp
class Shape {
public:
    virtual ~Shape() = default;
    virtual double area() const = 0;
    virtual void draw() const = 0;
};

class Circle : public Shape {
    double radius_;
public:
    Circle(double r) : radius_(r) {}
    double area() const override { return 3.14159 * radius_ * radius_; }
    void draw() const override { /* 원 그리기 구현 */ }
    double radius() const { return radius_; }
};

class Square : public Shape {
    double side_;
public:
    Square(double s) : side_(s) {}
    double area() const override { return side_ * side_; }
    void draw() const override { /* 사각형 그리기 구현 */ }
    double side() const { return side_; }
};

// 도형 처리 시스템
void process_shapes() {
    std::vector<MySharedPtr<Shape>> shapes;
    shapes.push_back(my_make_shared<Circle>(5.0));
    shapes.push_back(my_make_shared<Square>(4.0));
    
    for (auto& shape : shapes) {
        // 공통 인터페이스 사용
        std::cout << "Area: " << shape->area() << "\n";
        
        // 특정 타입으로 다운캐스팅
        if (auto circle = my_dynamic_pointer_cast<Circle>(shape)) {
            std::cout << "Radius: " << circle->radius() << "\n";
        } else if (auto square = my_dynamic_pointer_cast<Square>(shape)) {
            std::cout << "Side: " << square->side() << "\n";
        }
    }
}
```

## 불완전형 지원: 헤더 분리와 컴파일 시간 최적화

대규모 프로젝트에서는 컴파일 의존성을 최소화하기 위해 전방 선언을 자주 사용합니다. 불완전형(incomplete type) 지원은 이러한 상황에서 스마트 포인터를 사용할 수 있게 합니다.

### PImpl 패턴과의 통합

```cpp
// Widget.h - 사용자에게 공개되는 헤더
#include "mysp_all.hpp"

class Widget {
    struct Impl;  // 전방 선언만
    MyUniquePtr<Impl> pImpl_;  // 불완전형 사용 가능
    
public:
    Widget();
    ~Widget();
    Widget(Widget&&) noexcept;
    Widget& operator=(Widget&&) noexcept;
    
    // 복사 연산은 명시적 구현 필요
    Widget(const Widget&);
    Widget& operator=(const Widget&);
    
    void perform_action();
    int calculate_value() const;
};

// Widget.cpp - 구현 세부사항 숨김
#include "Widget.h"

struct Widget::Impl {
    int data;
    std::string name;
    std::vector<double> values;
    
    int compute() const {
        return data + static_cast<int>(values.size());
    }
};

// 소멸자 정의: 여기서 Impl은 완전한 타입
Widget::~Widget() = default;

Widget::Widget() : pImpl_(new Impl{}) {}

void Widget::perform_action() {
    // pImpl_ 멤버에 안전하게 접근
    pImpl_->data = 42;
}
```

### 팩토리 패턴과 불완전형

```cpp
// Database.h - 인터페이스만 공개
#include "mysp_all.hpp"

class Database {
public:
    virtual ~Database() = default;
    virtual void connect() = 0;
    virtual void disconnect() = 0;
    virtual std::string query(const std::string& sql) = 0;
    
    // 팩토리 메서드: 구현 세부사항 숨김
    static MySharedPtr<Database> create(const std::string& connection_string);
};

// Database.cpp - 구현 세부사항
#include "Database.h"
#include "PostgresBackend.h"  // 실제 구현 클래스

MySharedPtr<Database> Database::create(const std::string& connection_string) {
    // 사용자는 PostgresBackend의 존재를 알 필요 없음
    return my_make_shared<PostgresBackend>(connection_string);
}
```

## 메모리 모델과 스레드 안전성: 고급 고려사항

멀티스레드 환경에서 스마트 포인터를 사용할 때는 메모리 모델에 대한 이해가 중요합니다.

### 원자적 연산과 메모리 순서

```cpp
void MySharedPtr<T>::release_shared() noexcept {
    if (!ctrl_) return;
    
    // 메모리 장벽: 이전 쓰기 연산들이 완료되도록 보장
    if (ctrl_->shared_count.fetch_sub(1, std::memory_order_acq_rel) == 1) {
        // 객체 파괴: 모든 스레드에서의 쓰기가 가시화됨
        ctrl_->destroy_object();
        
        // 약한 참조도 확인
        if (ctrl_->weak_count.load(std::memory_order_acquire) == 0) {
            ctrl_->delete_this();
        }
    }
}
```

메모리 순서 선택의 트레이드오프:
- `memory_order_relaxed`: 최고 성능, 동기화 없음
- `memory_order_acquire/relaease`: 적절한 성능과 동기화
- `memory_order_seq_cst`: 최대 안전성, 가장 느림

### 스레드 안전성 패턴

```cpp
class ThreadSafeResource {
    mutable std::mutex mutex_;
    MySharedPtr<Data> data_;
    
public:
    void update_data() {
        // 새 데이터 준비 (스레드 안전한 영역 외부)
        auto new_data = my_make_shared<Data>(/*...*/);
        
        {
            std::lock_guard<std::mutex> lock(mutex_);
            // 빠른 교체: shared_ptr 할당은 원자적
            data_ = std::move(new_data);
        }
        // 락 해제 후에도 이전 데이터 참조 가능
    }
    
    MySharedPtr<Data> get_snapshot() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return data_;  // 참조 카운트 증가로 스냅샷 생성
    }
};
```

## 결론

이번 편을 통해 우리의 스마트 포인터 시스템은 실전 적용 준비가 거의 완료되었습니다. 배열 지원을 통해 데이터 집합을 안전하게 관리하고, 커스텀 삭제자를 통해 다양한 외부 리소스를 통합 관리할 수 있게 되었습니다. 다형성 캐스팅 유틸리티는 객체지향 설계에서의 유연성을 제공하고, 불완전형 지원은 대규모 프로젝트의 컴파일 의존성 관리를 가능하게 합니다.

이러한 기능들은 단순히 사용 편의성을 높이는 것을 넘어, C++의 강력한 추상화 능력을 보여줍니다. 템플릿, RAII, 타입 소거, 메모리 모델 등의 개념들이 조화롭게 결합되어 복잡한 자원 관리 문제를 우아하게 해결합니다.

그러나 모든 추상화에는 비용이 따릅니다. 배열 특수화의 추가 복잡성, 커스텀 삭제자의 런타임 오버헤드, 원자적 연산의 성능 비용 등을 이해하고 상황에 맞는 선택을 하는 것이 중요합니다. 다행히 C++의 스마트 포인터 시스템은 이러한 다양한 요구사항을 균형 있게 충족하도록 설계되어 있습니다.

다음 편에서는 이러한 구현들을 실제 코드베이스에 통합하고 성능을 측정하며, 디버깅과 테스트를 위한 도구들을 구축해보겠습니다. 이론적 구현을 넘어 실전에서 견고하게 동작하는 시스템으로 발전시키는 과정을 살펴볼 것입니다.