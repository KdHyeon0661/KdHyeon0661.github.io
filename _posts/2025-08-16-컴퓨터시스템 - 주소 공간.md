---
layout: post
title: 컴퓨터시스템 - 주소 공간
date: 2025-08-16 20:20:23 +0900
category: 컴퓨터시스템
---
# 주소 공간(Address Space)

## 큰 그림 요약

- **주소 공간(Address Space)** = 프로세스(또는 커널)가 **가상 주소**로 바라보는 메모리의 논리적 배치도
- **하드웨어 MMU** + **페이지 테이블**이 가상→물리 변환, **TLB**가 결과 캐싱
- **운영체제 커널**은 주소 공간을 **구획(VMA)** 으로 관리하고, **권한(R/W/X)** 과 **정책**을 적용
- **보안/격리**(U/S, NX, W^X, KASLR), **유연성**(mmap, COW, 공유 라이브러리), **성능**(TLB, huge page, NUMA)을 동시에 달성

---

## 주소 공간이란 무엇인가

- **정의**: 프로세스나 커널이 사용할 수 있도록 **추상화된 가상 주소의 집합**
- **목적**: (1) **격리/보호** (다른 프로세스·커널 메모리 침범 방지) (2) **유연한 배치** (산개한 물리를 연속처럼) (3) **풍부한 기능** (COW, 파일 매핑, 힙/스택 확장)

```
[프로세스 A의 주소 공간]  ── 서로 완전히 논리적으로 독립 ──  [프로세스 B의 주소 공간]
```

---

## 사용자/커널 주소 공간 (일반적 관례)

현대 리눅스 x86-64(4-level, 48-bit canonical) 단순화 예:

```
[ 높은 주소 ]
──────────────────────────────────────────────
커널 공간 (전 프로세스에서 공유)     ← U/S=Supervisor, SMEP/SMAP 보호
──────────────────────────────────────────────
사용자 공간 (프로세스별 독립)        ← U/S=User
  • 스택(ASLR, guard)
  • 공유 라이브러리/파일 매핑(mmap)
  • 힙(brk/mmap)
  • 데이터/BSS
  • 코드(PIE 권장)
──────────────────────────────────────────────
[ 낮은 주소 ]
```

> **참고**: x86-64는 전통적으로 **48-bit canonical** 주소(상위는 sign-extended)를 사용.
> 최신 시스템은 **LA57(57-bit)** 를 지원할 수 있으며 커널 설정에 따라 사용자/커널 분할 경계가 달라질 수 있다.
> 실제 배치는 `cat /proc/self/maps` 로 확인하는 것이 가장 정확하다.

---

## 주소 공간의 구성 요소

| 영역 | 전형적 권한 | 내용/특징 |
|---|---|---|
| **코드(Text)** | `R–X` | 실행 기계어. **W^X** 정책으로 쓰기를 금지. |
| **데이터(Data)** | `RW-` | 초기화된 전역/정적 변수. |
| **BSS** | `RW-` | 0으로 초기화되는 전역/정적 변수. 파일 크기 증가 없음. |
| **힙(Heap)** | `RW-` | 동적 할당. `brk`/`mmap` 기반으로 확장. |
| **스택(Stack)** | `RW-` | 함수 호출 프레임, 리턴 주소. 보통 **상위→하위**로 성장 + **guard page**. |
| **mmap 영역** | 다양 | 공유 라이브러리, 파일 매핑, 익명 매핑, JIT 코드 등. |
| **vDSO/vVAR** | `R–X`/`R--` | 커널이 제공하는 사용자 공간 헬퍼/타이밍 데이터. |

---

## 가상→물리 변환: 페이지, PTE, TLB

- **페이지(Page)**: 변환/보호의 최소 단위(일반 **4KB**, 또한 **2MB/1GB** huge page 가능)
- **PTE**: 가상 페이지(VPN) → 물리 프레임(PFN) 매핑 + **권한 비트**(R/W/X, U/S, NX, A/D, Present 등)
- **TLB**: 변환 결과 캐시. 대부분 접근은 **TLB hit**로 해결

수식으로:

$$
\text{VA} = \underbrace{\text{VPN}}_{\text{상위 비트}} \,\|\, \underbrace{\text{Offset}}_{\log_2(\text{PageSize})}
$$

$$
\text{PA} = \underbrace{\text{PFN}}_{\text{물리 프레임}} \,\|\, \text{Offset}
$$

> **x86-64 4KB 페이지 & 4-level 예**
> `Offset=12`비트, 그 위로 PML4/PDPT/PD/PT 각 9비트 인덱스(총 48-bit canonical).

---

## VMA와 페이지 테이블: “논리 지도” vs “세부 주소록”

- **VMA(vm_area_struct)**: 동일한 속성(권한/백킹 파일/플래그)을 갖는 **연속 가상 구간**
  - 예: `[0x7f..a000, 0x7f..c000) R--p /lib/libc.so`
- **페이지 테이블**: VMA 내부의 각 페이지를 **물리 프레임**과 연결
  - 최초 접근 때 **수요 페이징(Demand Paging)** 으로 실제 매핑 완성

즉, VMA는 **고수준 구획**, PTE는 **저수준 매핑**.

---

## ASLR, PIE, 공유 라이브러리 매핑

- **ASLR**: 코드/힙/스택/mmap 시작점 무작위화 → 익스플로잇 난이도 ↑
- **PIE(Position-Independent Executable)**: 실행 파일도 `.so`처럼 임의 베이스에 적재
- **공유 라이브러리**: 텍스트/rodata 페이지를 여러 프로세스가 **동일 물리 페이지 공유**

> 성능 팁: 텍스트에 **절대주소 패치(TEXTREL)** 가 있으면 공유/보호가 깨진다.
> 현대 툴체인은 기본적으로 PIC/PIE를 생성하며 TEXTREL을 금지한다.

---

## 힙과 mmap: 할당 전략

### `brk/sbrk` vs `mmap`

- **brk**: 전통적 힙 “꼬리”를 늘려 연속 공간 확보(프래그먼트 완화는 할당기 몫)
- **mmap**: **임의 가상 주소**에 페이지 단위로 매핑. 큰 블록·정렬·보호 제어·파일 매핑에 적합

현대 할당기(glibc malloc 등)는 **작은 할당은 brk**, **큰 할당(예: ≥128KB)** 은 **mmap**을 혼용.

### 예: 큰 가상 공간 예약(지연 커밋)

```c
#include <sys/mman.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>

int main(){
    size_t ps = sysconf(_SC_PAGESIZE);
    size_t reserve = 1UL<<30; // 1 GiB 가상 공간 "예약"
    void *p = mmap(NULL, reserve, PROT_NONE,
                   MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    if (p == MAP_FAILED) { perror("mmap"); return 1; }

    // 일부만 사용: 첫 2페이지를 쓸 수 있게 열고 쓰기
    mprotect(p, 2*ps, PROT_READ|PROT_WRITE);
    memset(p, 0xA5, 2*ps);

    // 나머지는 여전히 PROT_NONE → 접근 시 SIGSEGV
    munmap(p, reserve);
    return 0;
}
```

> 운영체제는 “가상 공간”을 넓게 할당해도 물리 메모리를 즉시 배정하지 않는다(수요 페이징).
> 접근하는 시점에 실제 프레임이 배정된다.

---

## 스택: 성장, 가드, 오버플로 보호

- 스택은 보통 **상위 주소→하위 주소**로 성장하며, 끝에 **guard page**(`PROT_NONE`)를 둬 **오버플로 시 즉시 SIGSEGV**.
- 스레드마다 **개별 스택**. POSIX 스레드는 `pthread_attr_setstack`/`pthread_attr_setguardsize`로 제어 가능.

```c
#include <pthread.h>
#include <sys/mman.h>

void *worker(void *arg){ return NULL; }

int main(){
    pthread_t th;
    pthread_attr_t a; pthread_attr_init(&a);
    size_t stack_sz = 1<<20; // 1 MiB
    size_t guard_sz = 1<<16; // 64 KiB
    pthread_attr_setstacksize(&a, stack_sz);
    pthread_attr_setguardsize(&a, guard_sz);
    pthread_create(&th, &a, worker, NULL);
    pthread_join(th, NULL);
    pthread_attr_destroy(&a);
}
```

---

## 페이지 보호와 W^X, JIT 안전 토글

- **NX(또는 XD)**: 데이터 페이지 실행 금지
- **W^X 정책**: 동일 페이지에 **동시에** Write와 Execute 부여 금지
- JIT는 “작성→실행”을 **두 단계**로 분리

```c
// (1) RW로 매핑해 코드 바이트 생성
void *code = mmap(NULL, 4096, PROT_READ|PROT_WRITE,
                  MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
// ... write machine code ...

// (2) 실행 전엔 반드시 RX로 전환
mprotect(code, 4096, PROT_READ|PROT_EXEC);

// 이제 함수 포인터로 호출 가능
```

---

## COW(Copy-On-Write)와 fork

- `fork()` 직후 부모/자식은 동일 물리 페이지를 **읽기 전용 공유**
- 어떤 쪽이 **쓰기를 시도**하면 **그 페이지만 복사** → 효율적 프로세스 생성

> `vfork()`는 다른 의미(주소 공간 공유/제약)라서 일반 코드에 사용 금지.

---

## huge page: 2MB/1GB로 TLB 압박 줄이기

- **장점**: TLB 엔트리당 커버리지가 커서 **TLB miss 감소**, page walk 비용 ↓
- **종류**
  - **THP(Transparent Huge Pages)**: 커널이 힌트/휴리스틱으로 자동 결합 (`madvise(MADV_HUGEPAGE)`)
  - **고정 huge page(hugetlbfs)**: 명시 크기/풀에서 할당, 더 예측 가능
- **주의**: 내부 단편화↑, 메모리 회수/스왑 상호작용이 달라질 수 있음. 워킹셋/접근 패턴을 보고 결정.

```c
madvise(ptr, len, MADV_HUGEPAGE);   // THP 힌트
// 고정 huge page는 hugetlbfs 마운트 + O_HUGETLB(MAP_HUGETLB) 등 별도 절차
```

---

## NUMA: 주소 공간과 노드 지역성

- NUMA 시스템에서 **어느 노드의 물리 프레임**을 배정하느냐가 성능에 영향
- **first-touch** 정책: 처음 접근하는 CPU의 노드에 배정되는 경향
- 고급 제어: `numactl`/`libnuma`(정책·바인딩), `mbind()/set_mempolicy()` 시스템 콜

> 멀티소켓 대용량 워킹셋은 “노드별 파티셔닝 + NUMA 바인딩 + huge page”가 강력한 조합.

---

## TLB/PCID/ASID, 문맥 전환과 KPTI

- **TLB flush**는 비싸다. 문맥 전환마다 전부 비우면 성능 저하
- x86-64 **PCID**(Process-Context ID): 서로 다른 주소 공간의 TLB 항목을 태깅해 **부분 유지**
- 커널/사용자 분리 강화를 위한 **KPTI** 적용 시(스펙터/멜트다운 완화), PCID/옵티마이제이션이 중요
- ARM64는 **ASID**로 유사 개념 제공

---

## I/O와 주소: 파일·공유 메모리·IOMMU

- **파일 매핑(mmap)**: 파일을 주소 공간에 곧장 매핑 → I/O를 메모리 접근처럼
- **공유 메모리**: 서로 다른 프로세스의 주소 공간에 **같은 물리 페이지**를 매핑
- **IOMMU**: 장치에도 “장치-가상→물리” 변환 제공 → DMA 격리/보안/연속 가상 버퍼

---

## 가상화: 게스트 주소 공간과 EPT/NPT

- 게스트 내부: **VA→GPA(게스트 물리)**
- 하이퍼바이저: **GPA→HPA(호스트 물리)** (**EPT/NPT** 2차 변환)
- TLB/huge page 최적화가 중요(“nested TLB”, EPT huge page 등)

---

## 주소 공간 진단 도구

### `/proc` 기반

```bash
cat /proc/$$/maps      # 매핑 구간 + 권한 + 백킹 객체
cat /proc/$$/smaps     # RSS/PSS/Anon/File/Shared 등 상세 통계
pmap $$                # 간단 요약
```

출력 예(일부):
```
00400000-00452000 r-xp  /usr/bin/bash
00651000-00652000 r--p  /usr/bin/bash
00652000-00653000 rw-p  /usr/bin/bash
7f1b54000000-7f1b54221000 rw-p  [heap]
7fff5c000000-7fff5c021000 rw-p  [stack]
```

### ELF/로딩 확인

```bash
readelf -lW ./a.out   # PT_LOAD, PT_GNU_STACK, PT_GNU_RELRO 등
objdump -h ./a.out    # 섹션별 크기/정렬/권한
ldd ./a.out           # 필요한 .so
```

---

## 실습: 주소와 보호, mmap/mprotect

```c
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main() {
    size_t ps = sysconf(_SC_PAGESIZE);
    void *p = mmap(NULL, ps, PROT_READ|PROT_WRITE,
                   MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    printf("page @ %p (size=%zu)\n", p, ps);
    strcpy((char*)p, "hello, address space!\n");
    write(1, p, strlen((char*)p));

    // 실행 금지 테스트: 보통 NX로 보호되어 실행 불가
    // ((void(*)(void))p)(); // 주석 해제 시 SIGSEGV 가능

    mprotect(p, ps, PROT_READ); // 쓰기 제거
    // ((char*)p)[0] = 'H';     // 보호 위반 → SIGSEGV

    munmap(p, ps);
}
```

---

## 자주 겪는 함정과 대처

| 함정 | 설명 | 대처 |
|---|---|---|
| **`MAP_FIXED` 오용** | 기존 매핑을 **강제 덮어씀** | 웬만하면 **`MAP_FIXED_NOREPLACE`**(지원 시) 또는 NULL 힌트 사용 |
| **32-bit 주소 고갈** | 3GB/2GB 한계로 큰 매핑 실패 | 64-bit로 마이그레이션 |
| **포인터 산술/정렬 오류** | 페이지 경계/정렬 무시 | `sysconf(_SC_PAGESIZE)`, `align_up/down` 사용 |
| **W^X 위반(JIT)** | RWX 동시 부여 | “RW→RX 전환” 2단계 시퀀스 사용 |
| **THP 오판** | 작은 랜덤 접근에 THP가 역효과 | 워킹셋/패턴 관찰 후 `MADV_NOHUGEPAGE`/hugetlbfs 선택 |
| **NUMA 원격 접근 폭증** | 바인딩 없음 + first-touch | 초기화 스레드 배치, `numactl --interleave/bind` |
| **SIGBUS (파일 매핑)** | 잘못 잘린 파일 페이지 접근 | 파일 크기/`msync`/오류 경로 설계 |
| **KASLR/PIE 미적용** | ASLR 효과 반감 | **PIE 빌드**와 보안 플래그 적용 |

---

## 성능 관점: 수학적 TLB 커버리지

4KB 페이지, L1 D-TLB 64엔트리라면 한 번에 커버하는 주소 범위는
$$ 64 \times 4\text{KB} = 256\text{KB} $$
반면 2MB huge page라면,
$$ 64 \times 2\text{MB} = 128\text{MB} $$
→ 순차 대용량 워킹셋에서 **TLB miss** 감소 효과가 매우 크다(내부 단편화와 교환 고려).

---

## 주소 공간과 보안: 핵심 정책 정리

- **격리**: 사용자(U)/커널(S) 분리, SMEP/SMAP/PAN
- **무작위화**: ASLR(KASLR), PIE, 스택/힙 난수화
- **실행 제어**: NX, W^X, CFI/BTI(간접 분기 보호)
- **표면 축소**: 불필요한 매핑 제거, 최소 권한(`PROT_READ` 우선, 필요 시에만 `PROT_WRITE/EXEC`)

---

## 주소 공간 관찰 예제: `/proc/self/maps` 파싱

```c
#include <stdio.h>
#include <string.h>

int main() {
    FILE *fp = fopen("/proc/self/maps", "r");
    if (!fp) return 1;
    char line[512];
    while (fgets(line, sizeof line, fp)) {
        // 대략적 파싱: 시작/끝, 권한, 오프셋, 장치, inode, 경로
        // 예: 00400000-00452000 r-xp 00000000 08:02 123456 /usr/bin/bash
        puts(line);
    }
    fclose(fp);
    return 0;
}
```

---

## 흔한 질문(FAQ)

**Q1. 사용자 코드에서의 포인터는 가상 주소인가요?**
A. **항상 가상 주소**다. 물리 주소는 커널/드라이버 영역의 일.

**Q2. 같은 라이브러리를 여러 프로세스가 써도 메모리 낭비가 없나요?**
A. 텍스트/RO 데이터 페이지는 **동일 물리 페이지를 공유**한다(각 프로세스에서 다른 VA로 매핑).

**Q3. 64-bit이면 진짜 2⁶⁴ 공간을 쓰나요?**
A. 아키텍처/플랫폼 별로 **유효 비트**만 사용(전통 x86-64는 48-bit canonical, 최신은 57-bit 가능).
실제 경계/분할은 커널 설정에 따르므로 `/proc/self/maps` 로 확인하라.

---

## 체크리스트(설계·성능·보안)

- [ ] **PIE** 빌드 + ASLR 활성
- [ ] **W^X/NX** 준수, JIT는 RW→RX 전환
- [ ] 큰 워킹셋: **THP/hugetlbfs** 검토 + **NUMA 바인딩**
- [ ] 대규모 매핑: `mmap` + `madvise`로 정책 힌트
- [ ] 파일 갱신: **크래시 안전 시퀀스**(tmp→`fsync`→`rename`→부모 `fsync`)
- [ ] 진단 루틴: `/proc/*/maps/smaps`, `pmap`, `readelf -lW`, `objdump -h`
- [ ] 위험 플래그: `MAP_FIXED` 자제, `MAP_FIXED_NOREPLACE` 선호(가능 시)

---

## 마무리 한 줄

**주소 공간**은 개발자에게 **넓고 안전한 가상 무대**를 제공한다.
그 무대 뒤편에서 **MMU/페이지 테이블/TLB**가 물리 세계와 교섭하고,
커널은 **VMA/권한/정책**으로 질서를 유지한다.
이 구조를 이해하면 **성능(huge page/NUMA/PCID)**, **기능(mmap/COW)**, **보안(ASLR/NX/W^X)** 을
의도적으로 설계할 수 있다.
