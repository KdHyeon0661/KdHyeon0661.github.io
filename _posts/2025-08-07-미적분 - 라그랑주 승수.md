---
layout: post
title: 미적분 - 라그랑주 승수
date: 2025-08-07 23:20:23 +0900
category: 미적분
---
# 라그랑주 승수(Lagrange Multipliers) — 기하학 → 정식화 → 해법 → 판정 → 확장(KKT·2계조건·수치)까지

본 글은 앞서 다룬 **방향도함수·그래디언트**, **접평면과 전미분**, **편도함수의 극대/극소**를 토대로, **제약식 하에서의 극값 문제**를 체계적으로 정리한다. 핵심은 다음 한 줄이다.

> **핵심 한 줄**
> 제약 \(g(x)=0\) 위에서 \(f\)의 극값은, 국소적으로 **레벨곡면의 접평면이 서로 평행**(법선이 일치)한 지점에서 일어난다. 수식으로는
> $$\nabla f(x^\star)=\lambda\,\nabla g(x^\star)$$
> (여러 제약이면 \(\nabla f=\sum_i \lambda_i \nabla g_i\)).

이 글에서는 **기하학적 직관**→**정식화**→**해법 패턴**→**2계 조건**→**여러 제약**→**불등식(KKT) 개요**→**수치·코드**→**실전 예제** 순으로 빠짐없이 다룬다. 모든 수식은 $$\cdot$$로 감싸고, 코드는 ```로 감싼다.

---

## 0. 문제형과 기하학적 직관

### 0.1 표준 문제형
- **등식 제약 1개**:
  $$\max/\min\ f(x)\quad\text{s.t.}\quad g(x)=0,\ \ x\in\mathbb{R}^n.$$
- **등식 제약 여러 개**:
  $$\max/\min\ f(x)\quad\text{s.t.}\quad g_i(x)=0,\ i=1,\dots,m.$$

### 0.2 기하학적 의미
- \(f=\text{const}\)는 **레벨곡면(등고선)**, \(g=\text{const}\)도 레벨곡면.
- 제약 \(g=0\) 위에서 \(f\)를 극대/극소로 만들면, 지점 \(x^\star\)에서 **두 접평면이 같아진다**.
  즉, **법선 벡터가 같은 방향**:
  $$\nabla f(x^\star)=\lambda\,\nabla g(x^\star).$$
- 여러 제약이면 제약들의 **법선공간의 선형조합**으로 \(\nabla f\)가 표현된다.

> 앞서 다룬 그래디언트·접평면의 해석(법선=그래디언트)이 여기서 그대로 쓰인다.

---

## 1. 라그랑주 승수법: 1개의 등식 제약

### 1.1 정리(필요조건)
다음 두 조건을 만족하는 임계점 \(x^\star\)와 승수 \(\lambda^\star\)가 존재한다(정칙성 가정 하):
- **정역**: \(g(x^\star)=0\).
- **정상성**:
  $$\nabla f(x^\star)=\lambda^\star \nabla g(x^\star).$$

여기서 \(\nabla g(x^\star)\neq 0\) (정칙) 이어야 한다. 정칙하지 않으면 별도 검토(§7.4).

### 1.2 라그랑주 함수
한 개 제약일 때
$$
\mathcal{L}(x,\lambda)=f(x)-\lambda\,g(x).
$$
필요조건은
$$
\nabla_x \mathcal{L}(x^\star,\lambda^\star)=0,\qquad g(x^\star)=0.
$$

### 1.3 2계 조건(등식 1개)
- **접공간**(tangent space)
  $$T=\{d\in\mathbb{R}^n:\ \nabla g(x^\star)^\top d=0\}.$$
- **제한된 헤시안**
  $$\nabla_{xx}^2 \mathcal{L}(x^\star,\lambda^\star)=\nabla^2 f(x^\star)-\lambda^\star \nabla^2 g(x^\star).$$
- **국소 최소**: 위 이차형이 \(T\)에서 **양의 정부호**.
  **국소 최대**: \(T\)에서 **음의 정부호**.
  **부정부호**면 **안장**.

> 이 2계조건은 “접평면 위의 2차 근사”를 보는 것이며, §2에서 좌표로 확인한다.

---

## 2. 라그랑주 승수법: 여러 등식 제약

제약 \(g_i(x)=0\ (i=1,\dots,m)\), 보통 \(m<n\), 그리고 \(\{\nabla g_i(x^\star)\}\)가 **독립**(정칙성).

### 2.1 필요조건
라그랑주 함수
$$
\mathcal{L}(x,\lambda)=f(x)-\sum_{i=1}^m \lambda_i g_i(x).
$$
필요조건:
$$
\nabla_x \mathcal{L}(x^\star,\lambda^\star)=0,\qquad g_i(x^\star)=0\ (i=1,\dots,m).
$$
즉,
$$
\nabla f(x^\star) = \sum_{i=1}^m \lambda_i^\star \nabla g_i(x^\star).
$$

### 2.2 2계 조건(요지)
- 접공간
  $$T=\{d:\ \nabla g_i(x^\star)^\top d=0,\ \forall i\}.$$
- 제한된 헤시안
  $$\nabla_{xx}^2 \mathcal{L}(x^\star,\lambda^\star)=\nabla^2 f(x^\star)-\sum_{i=1}^m \lambda_i^\star \nabla^2 g_i(x^\star).$$
- 판정은 §1.3과 동일하되 \(T\)가 다해차원.

---

## 3. 기초 예제

### 3.1 단위원에서의 최대곱: \(\max xy\) s.t. \(x^2+y^2=1\)
- \(f(x,y)=xy\), \(g(x,y)=x^2+y^2-1=0\).
- 조건:
  $$
  \nabla f=(y,x)=\lambda (2x,2y).
  $$
  즉 \(y=2\lambda x,\ x=2\lambda y\Rightarrow x=2\lambda(2\lambda x)\).
  \(x\neq 0\)라면 \(1=4\lambda^2\Rightarrow \lambda=\pm\frac{1}{2}\).
  \(\lambda=\frac{1}{2}\Rightarrow y=x,\ x^2+y^2=2x^2=1\Rightarrow x=y=\frac{1}{\sqrt2}\) → \(f=\frac12\).
  \(\lambda=-\frac{1}{2}\Rightarrow y=-x\Rightarrow f=-\frac12\).
  \(x=0\) 혹은 \(y=0\)이면 \(f=0\) (극값 아님).
- 결론: 최대 \(\frac12\) at \((\frac{1}{\sqrt2},\frac{1}{\sqrt2})\), 최소 \(-\frac12\) at \((\frac{1}{\sqrt2},-\frac{1}{\sqrt2})\) 등.

**2계 판정(스케치)**: 접공간 \(T=\{d:\ (2x,2y)\cdot d=0\}\). 최댓점에서 제한헤시안 음정부호 확인 가능.

---

### 3.2 최단거리: 점에서 직선으로 \(\min (x-a)^2+(y-b)^2\) s.t. \(\alpha x+\beta y+\gamma=0\)
- \(f=\|(x,y)-(a,b)\|^2\), \(g=\alpha x+\beta y+\gamma\).
- \(\nabla f=(2(x-a),2(y-b))=\lambda(\alpha,\beta)\).
- 즉
  $$x=a+\frac{\lambda}{2}\alpha,\qquad y=b+\frac{\lambda}{2}\beta,$$
  제약 대입: \(\alpha a+\beta b+\gamma+\frac{\lambda}{2}(\alpha^2+\beta^2)=0\),
  $$\lambda^\star=-\frac{2(\alpha a+\beta b+\gamma)}{\alpha^2+\beta^2}.$$
- 투영 공식의 미분학적 유도.

---

### 3.3 레일리 비(고유값 문제): \(\max x^\top A x\) s.t. \(x^\top x=1\)
- \(f(x)=x^\top A x\), \(g(x)=x^\top x-1\).
- \(\nabla f=2Ax=\lambda 2x\Rightarrow Ax=\lambda x\).
  즉 **고유값 문제**. 최대/최소는 각각 **최댓/최솟 고유값**, 점은 그 고유벡터.

> 라그랑주 승수법이 선형대수의 핵심 결과와 직접 연결됨.

---

## 4. 경제·데이터 예제

### 4.1 예산 제약 효용 최대화(코브-더글라스)
- \(\max\ u(x,y)=x^\alpha y^\beta\) s.t. \(p_x x+p_y y=M\), \(\alpha,\beta>0\).
- 로그로 단순화: \(\max \alpha\ln x+\beta\ln y\) s.t. \(p_x x+p_y y=M\).
- \(\mathcal{L}=\alpha\ln x+\beta\ln y-\lambda(p_x x+p_y y-M)\).
- 정상성: \(\frac{\alpha}{x}=\lambda p_x,\ \frac{\beta}{y}=\lambda p_y\Rightarrow \frac{y}{x}=\frac{\beta p_x}{\alpha p_y}\).
- 예산 대입해 해 도출:
  $$x^\star=\frac{\alpha}{\alpha+\beta}\frac{M}{p_x},\quad y^\star=\frac{\beta}{\alpha+\beta}\frac{M}{p_y}.$$

### 4.2 선형 제약 하 최소제곱(정칙 케이스)
- \(\min \frac12\|Ax-b\|^2\) s.t. \(C x=d\) (정칙).
- \(\mathcal{L}=\frac12\|Ax-b\|^2-\lambda^\top (Cx-d)\).
- 정상성: \(A^\top(Ax-b)-C^\top\lambda=0,\ Cx=d\).
- 블록정리로 해:
  $$
  \begin{pmatrix} A^\top A & -C^\top \\ C & 0\end{pmatrix}
  \begin{pmatrix} x \\ \lambda \end{pmatrix}
  =
  \begin{pmatrix} A^\top b \\ d \end{pmatrix}.
  $$

---

## 5. 2계 조건 상세(등식 제약)

### 5.1 접공간-제한헤시안 판정
- 접공간 \(T=\{d:\ \nabla g_i^\top d=0\ \forall i\}\).
- 제한헤시안 \(H_L=\nabla^2 f - \sum_i \lambda_i \nabla^2 g_i\).
- \(d\in T\)에 대해 \(d^\top H_L d\)\(\begin{cases}>0 &\Rightarrow\) 국소 최소\\<0 &\Rightarrow\) 국소 최대\\부호섞임 &\Rightarrow\) 안장\(\end{cases}\).

### 5.2 좌표적 확인(2D, 제약 1개)
- \(\nabla g\neq 0\)에서 제약곡선을 매개화 \(x(t)\)로 두고 1변수 \(f(x(t))\)의 2계 도함수 판정과 합치며, 그 결과가 \(H_L\) 제한 판정과 일치한다.

---

## 6. 여러 제약(독립·비독립)

- 독립(정칙)일 때 필요조건은 \(\nabla f=\sum\lambda_i \nabla g_i\).
- 비독립이면 **제약 자격조건**(C.Q.) 위반. 예: \(\nabla g_1,\nabla g_2\)가 같은 방향이면 람다 표현이 비유일. 이때는
  - 제약 축소(독립 집합 선택),
  - 비정칙 해(§7.4) 포함 점검.

---

## 7. 확장: 부등식 제약과 KKT(개요)

### 7.1 문제형
$$
\min f(x)\quad \text{s.t.}\quad g_i(x)=0,\ i\in\mathcal{E};\ \ h_j(x)\le 0,\ j\in\mathcal{I}.
$$

### 7.2 KKT 조건(정칙성 하 필요조건)
- **정상성**:
  $$\nabla f(x^\star)=\sum_{i\in\mathcal{E}}\lambda_i \nabla g_i(x^\star)+\sum_{j\in\mathcal{I}}\mu_j \nabla h_j(x^\star).$$
- **실현성**: \(g_i(x^\star)=0,\ h_j(x^\star)\le 0\).
- **보완슬랙**: \(\mu_j\ge 0,\ \mu_j\, h_j(x^\star)=0\) (활성 제약만 영향).
- **정칙성(C.Q.)**: LICQ 등.

> 부등식 제약은 “활성 제약만 등식처럼” 작동한다는 점이 핵심. 보완슬랙이 그 역할을 한다.

### 7.3 간단 예: 상자 제약
- \(\min \frac12\|x\|^2\) s.t. \(\ell\le x\le u\).
  정답은 단순 클리핑이지만, KKT로도 \(\mu^-,\mu^+\)를 통해 동일 결론.

### 7.4 정칙성 실패(비정칙점)
- \(\nabla g(x^\star)=0\)이면 기저 필요조건이 약화.
- 이 경우 **고차 조건**·**직접 매개화**·**문제 재정식화** 필요.

---

## 8. 수치·알고리즘

- **심볼릭 해**: 소규모, 다항·유리·삼각조합 → SymPy 등.
- **선형/2차**: KKT 블록, 정칙이면 직접해.
- **비선형**: SQP, Augmented Lagrangian(AL), Interior-point(장내점), Projected Newtown 등.
- **2계 정보**: 제약 포함 헤시안-라그랑주안 필요. 수치적으로는 **구조**(희소성, 대칭성) 활용.

---

## 9. 코드 예제(심볼릭·수치)

### 9.1 심볼릭: \(\max xy\) s.t. \(x^2+y^2=1\)
```python
import sympy as sp

x, y, lam = sp.symbols('x y lam', real=True)
f  = x*y
g  = x**2 + y**2 - 1
L  = f - lam*g

eqs = [
    sp.diff(L, x),
    sp.diff(L, y),
    g
]
sol = sp.solve(eqs, [x, y, lam], dict=True)

sol
# 기대: (±1/√2, ±1/√2, λ=±1/2) 등 부호 조합 4개
```

### 9.2 심볼릭: 레일리 비(고유값)
```python
# A는 2x2 대칭행렬 케이스
a11, a12, a22 = sp.symbols('a11 a12 a22', real=True)
A = sp.Matrix([[a11, a12],[a12, a22]])
x1, x2, lam = sp.symbols('x1 x2 lam', real=True)
xv = sp.Matrix([x1, x2])

f = (xv.T * A * xv)[0]
g = (xv.T * xv)[0] - 1
L = f - lam * g

eqs = [sp.diff(L, x1), sp.diff(L, x2), g]
sp.solve(eqs, [x1, x2, lam], dict=True)
# 해는 Ax = lam x. lam은 고유값, x는 고유벡터.
```

### 9.3 수치: 선형 제약 최소제곱 KKT
```python
import numpy as np

# min 1/2 ||Ax-b||^2 s.t. Cx=d
np.random.seed(0)
m, n, p = 6, 3, 2
A = np.random.randn(m, n)
b = np.random.randn(m)
C = np.random.randn(p, n)
d = np.random.randn(p)

K = np.block([
    [A.T @ A, -C.T],
    [C,       np.zeros((p,p))]
])
rhs = np.concatenate([A.T @ b, d])
sol = np.linalg.solve(K, rhs)
x = sol[:n]
lam = sol[n:]

# 검증: 정상성, 제약 만족
print("norm stationarity:", np.linalg.norm(A.T @ (A @ x - b) - C.T @ lam))
print("constraint residual:", np.linalg.norm(C @ x - d))
```

### 9.4 수치: 비선형 제약 심볼릭→수치(코브-더글라스)
```python
import sympy as sp

x, y, lam = sp.symbols('x y lam', positive=True, real=True)
px, py, M, a, b = sp.symbols('px py M a b', positive=True, real=True)

f = a*sp.log(x) + b*sp.log(y)
g = px*x + py*y - M
L = f - lam * g

eqs = [sp.diff(L, x), sp.diff(L, y), g]
sol = sp.solve(eqs, [x, y, lam], dict=True)[0]
sp.simplify(sol[x]), sp.simplify(sol[y])
# (a/(a+b) * M/px, b/(a+b) * M/py)
```

---

## 10. 실전 시나리오

### 10.1 기하학: 구와 평면의 교집합 위에서의 최소거리
- 점 \(p\)에서 구 \(x^\top x=R^2\) ∩ 평면 \(n^\top x=c\)까지의 최단점:
  두 제약 \(g_1=x^\top x-R^2=0,\ g_2=n^\top x-c=0\).
  \(\nabla f=2(x-p)=\lambda_1(2x)+\lambda_2 n\) → 선형 시스템.
  실제로는 두 제약으로 잠금된 1차원 원(서클) 위에서의 투영.

### 10.2 데이터: 공분산 제한 최적화(정규화된 벡터)
- \(\max v^\top \Sigma v\) s.t. \(\|v\|=1\) → 최대 고유값·고유벡터.
  PCA의 주성분이 라그랑주 승수의 직접 산출임.

### 10.3 제어·물리: 에너지 최소화 under 보존 제약
- 예: \(\min \int \|\dot{x}\|^2\) s.t. 경계조건 + 보존량(등식). 연속체 버전은 변분법 + 승수 함수.

---

## 11. 함정·체크리스트

- □ **정칙성(Constraint Qualification)**: \(\{\nabla g_i\}\) 독립? 아니면 재정식화/활성 집합 수정.
- □ **2계 판정**: 제한헤시안이 접공간에서 정부호/음정부호인지 확인.
- □ **경계·활성**: 부등식 제약이면 KKT **보완슬랙** 필수.
- □ **국소 vs 전역**: 승수법은 **국소 필요조건**. 전역성은 별도(볼록성, 다항구조, 브랜치&바운드 등).
- □ **수치안정성**: KKT 블록행렬의 조건수, 스케일링/정규화.
- □ **해 다중성**: 대칭성(예: 원), 비정칙점에서 해 다수.
- □ **좌표 독립성**: 기하적(접평면/법선) 관점으로 점검.

---

## 12. 연습문제(정답 스케치 포함)

1) \(\max x^2y\) s.t. \(x^2+y^2=1\).
   \(\nabla f=(2xy,x^2)\). 승수 조건과 제약으로 후보점, 2계 판정.

2) \(\min \|(x,y)-(1,0)\|^2\) s.t. \(\frac{x^2}{4}+y^2=1\).
   타원 투영: 라그랑주로 닫힌형 존재(4차 방정식), 수치검증 병행.

3) \(\max x+y\) s.t. \(x^2+y^2\le 1\).
   KKT: 활성 제약에서 레일리 비와 유사한 방정식 → 해는 \((\frac{1}{\sqrt2},\frac{1}{\sqrt2})\).

4) \(\min \|Ax-b\|^2\) s.t. \(\mathbf{1}^\top x=1,\ x\ge 0\) (심플렉스).
   KKT로 활성집합 식별 → 포트폴리오/믹스 최적화 기초.

---

## 13. 앞선 글과의 연결 고리(복습 포인트)

- **방향도함수·그래디언트**: \(\nabla f\)는 최대 기울기 방향, 승수조건은 \(\nabla f\)가 제약의 법선공간에 **정확히** 들어간다는 진술.
- **접평면과 전미분**: 레벨집합의 접평면이 일치 → 전미분 선형근사 관점에서 국소적으로 극값이 유지.
- **편도함수의 극대/극소**: 제약을 추가하면 “접공간에서의 2계 판정”으로 자연 확장.

---

## 14. 한 페이지 요약(치트시트)

- 등식 1개:
  $$\nabla f(x^\star)=\lambda\nabla g(x^\star),\quad g(x^\star)=0.$$
  접공간 \(T=\{d:\ \nabla g^\top d=0\}\)에서 \(\nabla^2 f - \lambda\nabla^2 g\)의 정부호성으로 판정.

- 등식 다수:
  $$\nabla f=\sum_i \lambda_i \nabla g_i,\quad g_i=0.$$
  \(T=\{d:\ \nabla g_i^\top d=0\ \forall i\}\)에서 제한헤시안 판정.

- 부등식(KKT):
  정상성 + 실현성 + 보완슬랙 + 정칙성.

- 기하학: **법선 정렬**(레벨집합의 접평면 일치).

- 수치: KKT 블록 / SQP / 내부점 / AL.

---

## 15. 추가 코드: KKT 간단 구현(부등식 포함, 활성 추정)

```python
import numpy as np

def kkt_quadratic_qp(H, c, Aeq=None, beq=None, Aineq=None, bineq=None, tol=1e-9):
    """
    Solve: min 1/2 x^T H x + c^T x
           s.t. Aeq x = beq
                Aineq x <= bineq
    Naive active-set: start with none active, greedily add violated, solve KKT.
    WARNING: pedagogical only (no pivoting, no degeneracy handling).
    """
    n = H.shape[0]
    if Aeq is None:
        Aeq = np.zeros((0,n))
        beq = np.zeros(0)
    if Aineq is None:
        Aineq = np.zeros((0,n))
        bineq = np.zeros(0)

    # start with feasible x via least-squares on eq, ignore ineq
    # if no eq, start at zero
    if Aeq.shape[0] > 0:
        # minimal norm solution among eq-feasible (ignore inequality for start)
        # solve Aeq x = beq in least squares sense, then project?
        # here, simple: x0 from LS, may violate inequalities
        x = np.linalg.lstsq(Aeq, beq, rcond=None)[0] if Aeq.shape[0] == n else np.zeros(n)
    else:
        x = np.zeros(n)

    active = []
    for _ in range(100):
        # check violations
        viol = Aineq @ x - bineq
        worst_idx = np.argmax(viol)
        if Aineq.shape[0] > 0 and viol[worst_idx] > tol:
            if worst_idx not in active:
                active.append(worst_idx)
        # build KKT with active set
        Aact = np.vstack([Aeq, Aineq[active]]) if active else Aeq
        m = Aact.shape[0]
        KKT = np.block([[H, Aact.T],
                        [Aact, np.zeros((m,m))]])
        rhs = -np.concatenate([c + H @ x, Aact @ x - np.concatenate([beq, bineq[active]])])
        try:
            step = np.linalg.solve(KKT, rhs)
        except np.linalg.LinAlgError:
            break
        dx = step[:n]
        dl = step[n:]
        if np.linalg.norm(dx) < 1e-10:
            # check Lagrange multipliers for inequality: must be >=0
            if active:
                mu = dl[Aeq.shape[0]:]
                # drop negative multipliers
                drop = [active[i] for i,mui in enumerate(mu) if mui < -1e-10]
                if drop:
                    active = [j for j in active if j not in drop]
                    continue
            break
        x = x + dx

    return x, active

# quick demo
np.random.seed(1)
n = 3
H = np.eye(n)
c = np.array([-1.0, -2.0, 0.0])   # minimize 1/2||x||^2 - [1,2,0]^T x
Aeq = np.array([[1., 1., 1.]])
beq = np.array([1.])
Aineq = np.eye(n)
bineq = np.ones(n)                 # x <= 1 (componentwise)
x_star, active = kkt_quadratic_qp(H, c, Aeq, beq, Aineq, bineq)
print("x*", x_star, "active ineq", active)
# True solution is projection of [1,2,0] onto simplex with x<=1: likely x~[0,1,0] then adjust with equality.
```

---

## 16. 마무리

라그랑주 승수는 “**법선 정렬** ⇒ **정상 조건** ⇒ **접공간 2계 판정**”이라는 한 줄 철학으로 요약된다.
이 관점은 기하학(접평면), 해석학(전미분), 최적화(KKT·2계 조건), 선형대수(고유값)까지 자연스럽게 연결하며,
실제 구현에서는 KKT 블록 구조·SQP·내부점 등 수치 기법으로 이어진다.
앞서 정리했던 **그래디언트·접평면·편도함수 극값**과의 연결을 상시 염두에 두면,
문제 모델링 → 조건 도출 → 판정 → 수치검증의 전 과정을 견고하게 운용할 수 있다.
