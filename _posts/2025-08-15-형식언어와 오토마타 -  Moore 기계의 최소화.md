---
layout: post
title: 형식언어와 오토마타 - Moore 기계의 최소화
date: 2025-08-15 21:20:23 +0900
category: 형식언어와 오토마타
---
# Moore 기계의 **최소화**

Moore 기계는 각 **상태에 출력**이 붙어 있는 유한상태 변환기다.  
최소화(minimization)의 목표는 **같은 변환(입력 → 출력 스트림)** 을 수행하면서 **상태 수가 최소**인 동치 기계를 만드는 것.  

---

## 0. 모델·출력 스트림 관례

결정적 Moore 기계
$$
M=(Q,\Sigma,\Gamma,\delta,\rho,q_0),\quad
\delta:Q\times\Sigma\to Q,\quad \rho:Q\to\Gamma.
$$

- 입력 기호 \(a\)를 읽어 \(p \xrightarrow{a} q=\delta(p,a)\)로 이동하고, **도착 상태의 출력** \(\rho(q)\)를 방출한다.
- **출력 스트림 길이 관례** 두 가지
  1) **초기 출력 포함**: 시작 시점에 \(\rho(q_0)\)를 먼저 출력하고, 이후 읽을 때마다 1개 출력 → 길이 \(=|w|+1\).
  2) **초기 출력 미포함**: 첫 입력을 읽고 도착 상태의 출력부터 방출 → 길이 \(=|w|\).

본 문서에서는 **초기 출력 포함**을 기본으로 한다. (다른 관례를 쓰면 동치 정의에서 “초기 출력 비교” 한 줄만 바뀐다.)

---

## 1. **상태 동치**와 트리밍

### 1.1 상태 동치(State Equivalence)

상태 \(p,q\in Q\)가 동치(기호 \(p \sim q\))라 함은, **모든 입력 단어** \(x\in\Sigma^*\)에 대해 두 상태에서 시작한 출력 스트림이 동일함을 뜻한다. 등가적 귀납 정의:

$$
\boxed{\ \rho(p)=\rho(q)\ \ \text{and}\ \ \forall a\in\Sigma:\ \delta(p,a)\sim\delta(q,a)\ }.
$$

- DFA 최소화의 Myhill–Nerode에서 “수용/비수용”이 1차 분할이었다면, Moore에서는 **현재 출력값 \(\rho(\cdot)\)** 이 1차 분할이다.

### 1.2 트리밍(Reachability)

최소화 전 **도달 불가 상태**를 제거한다:

$$
Q \leftarrow \{\,q\in Q\mid q\ \text{is reachable from}\ q_0\,\}.
$$

co-reachability(수용 도달 가능성)는 Moore엔 없다. 단, **부분 기계**(미정의 전이 존재)라면 §5의 Sink로 총기계화 후 진행한다.

---

## 2. 기본 알고리즘 — **파티션 정제(Moore 방식)**

아이디어: “현재 출력으로 **초기 분할**” → “각 상태의 **서명(signature)** (다음 블록들 튜플)”으로 계속 쪼갠다 → 고정점에서 멈춘다.

### 2.1 초기 분할

출력이 같은 상태끼리 묶는다:
$$
\Pi_0 := \big\{\ \{\,q\in Q \mid \rho(q)=\gamma\,\}\ :\ \gamma\in\Gamma\ \big\}.
$$

### 2.2 서명(Signature)

현재 분할 \(\Pi\)가 있을 때 상태 \(q\)의 서명:
$$
\mathrm{Sig}_\Pi(q)\ :=\ \Big([\delta(q,a)]_\Pi\Big)_{a\in\Sigma},
$$
즉 각 입력 \(a\)에 대해 “다음 상태가 속한 **블록의 ID**”들의 튜플. (출력 \(\rho(q)\)는 이미 초기 분할에 반영되었으므로 서명에 포함할 필요가 없다.)

### 2.3 반복·종료·몫 기계

```text
Input: Moore M=(Q,Σ,Γ,δ,ρ,q0)  # 총/결정적이라고 가정
Q := reachable_from(q0)

Π := partition Q by current output ρ(q)     # 초기 분할

repeat
  Π' := partition Q by signature Sig_Π(q) = ( class_Π(δ(q,a)) for a in Σ )
  if Π' == Π: break
  Π := Π'
until fixed

# Quotient(몫) 구성
states_min  := { each block B in Π }                   # 대표 [q]
δ_min([q],a) := [ δ(q,a) ]                             
ρ_min([q])   := ρ(q)                                   # 블록 내 동일
q0_min       := [ q0 ]

return M_min = (states_min, Σ, Γ, δ_min, ρ_min, q0_min)
```

- **정지성**: 유한 집합 \(Q\)에서 분할은 더 이상 쪼갤 수 없을 때 멈춘다.
- **정당성**(스케치): 귀납 길이 인자 \(k\)에 대해 같은 블록이면 길이 \(\le k\)의 모든 접미 입력에 대해 동일한 출력 접두를 만든다. 극한 \(k\to\infty\)로 모든 길이에서 동일.

### 2.4 복잡도

- 순진 구현: 라운드마다 \(O(|\Sigma|\cdot|Q|)\), 라운드가 최악 \(|Q|\) → \(O(|\Sigma|\cdot|Q|^2)\).
- Hopcroft 스타일 가속(§3)로 **\(O((|Q|+|E|)\log|Q|)\)** 근처까지 가능. (여기서 \(E=|Q|\cdot|\Sigma|\) for total; 부분·희소 전이에선 실제 \(E\) 사용)

---

## 3. **Hopcroft 스타일 가속** — “작은 분할부터 퍼뜨리기”

핵심은 **분할자(splitting set)** 를 worklist에 두고, **항상 작은 쪽**을 퍼뜨려 전체 비용을 줄이는 것이다. DFA 최소화의 구조를, Moore의 “다음 블록 튜플” 트리거로 그대로 재사용한다.

```text
Hopcroft-Minimize-Moore(M):

Π := partition Q by ρ           # 출력값으로 초기 분할
W := all blocks in Π            # 작업 큐(분할자 집합)

# 역전이(predecessor) 인덱스를 준비하면 비용이 확 준다.
# pred[a][S] = { p | δ(p,a) ∈ S } 를 효율적으로 찾게 한다.

while W not empty:
  S := pop_smallest(W)          # 작은 블록 먼저
  for a in Σ:
    Pred := { p ∈ Q | δ(p,a) ∈ S }     # a-전이의 역이미지
    for each block B in Π that intersects Pred:
      B1 := B ∩ Pred
      B2 := B \ Pred
      if B1≠∅ and B2≠∅:
        replace B by B1,B2 in Π
        push smaller_of(B1,B2) into W  # 작은 쪽만 전파

# Π가 고정점 → quotient 구성은 §2.3과 동일
```

- **역전이 인덱스**: 입력 \(a\)와 블록 \(S\)가 주어졌을 때, \(a\)로 \(S\)에 **들어오는 선행 상태 집합**을 빠르게 얻어야 한다.  
  이를 위해 각 \(a\)마다 **역 adjacency**를 저장한다(메모리: \(O(E)\)).
- **성능**: 각 분할의 작은쪽만 전파되므로 **로그 인자**로 수렴. 희소 전이에서는 \(E\)에 선형.

---

## 4. **예제** — 단계별 최소화

아래 Moore 기계를 최소화한다.

```text
Σ = {0,1},  Γ = {0,1}
상태/출력:  A/0, B/0, E/0,   C/1, D/1, F/1      (시작 A)

전이:
A --0--> B    A --1--> C
B --0--> B    B --1--> D
C --0--> E    C --1--> C
D --0--> E    D --1--> C
E --0--> B    E --1--> D
F --0--> E    F --1--> C
```

### 4.1 초기 분할(출력)

- \(\Pi_0=\{\,X_0=\{A,B,E\},\ X_1=\{C,D,F\}\,\}\)

### 4.2 1차 정제(서명 비교)

- \(X_0\)의 각 원소 서명:
  - \(A\): (0→\(X_0\), 1→\(X_1\))
  - \(B\): (0→\(X_0\), 1→\(X_1\))
  - \(E\): (0→\(X_0\), 1→\(X_1\)) → **동일**
- \(X_1\)의 각 원소 서명:
  - \(C\): (0→\(X_0\), 1→\(X_1\))
  - \(D\): (0→\(X_0\), 1→\(X_1\))
  - \(F\): (0→\(X_0\), 1→\(X_1\)) → **동일**

쪼개짐 없음 → **최소 기계는 2상태**:

- \([Z_0]=\{A,B,E\}\) with \(\rho=0\)
- \([Z_1]=\{C,D,F\}\) with \(\rho=1\)

전이:
- \(Z_0 \xrightarrow{0} Z_0,\ Z_0 \xrightarrow{1} Z_1\)
- \(Z_1 \xrightarrow{0} Z_0,\ Z_1 \xrightarrow{1} Z_1\)

검증: 모든 입력 스트림에 대해 출력이 동일(초기 출력 포함 시 \(Z_0\)의 초기 출력 0).

> 교훈: Moore는 **출력 레이블**이 강력한 초기 분할을 준다. 많은 병합이 한 번에 일어난다.  
> 반대로 전이 패턴 차이가 서명에서 드러나면 이후 라운드에서 세분화된다.

---

## 5. **부분 기계**(미정의 전이)와 **총기계화**(Sink)

일부 \((q,a)\) 전이가 정의되지 않은 **부분 Moore**는 다음 중 하나를 선택한다.

1) **총기계화**: Sink 상태 \(\bot\)을 추가해 모든 미정의를 \(\delta(q,a)=\bot\)으로 채우고  
   \(\rho(\bot)=\gamma_\bot\) (관례적으로 별도 출력)로 둔 뒤 최소화한다.  
   이렇게 하면 “한쪽만 정의”인 경우가 **즉시 비동치**로 드러난다.

2) **영향 없는 입력 제거**: 과업에 따라 특정 입력을 도메인 밖으로 간주할 수도 있지만,  
   **동치성/최소화 정리**를 적용하려면 **총기계화**가 표준적이고 안전하다.

---

## 6. **두 Moore 기계 동치성 검사**

두 기계 \(M_1,M_2\)가 **동일 변환**을 하느냐를 확인하려면:

1) **초기 출력 비교**: \(\rho_1(q_{0,1})\stackrel{?}{=}\rho_2(q_{0,2})\). 다르면 즉시 비동치.
2) **제품 그래프 동시 탐색**:  
   쌍 \((p,q)\)에서 모든 \(a\in\Sigma\)에 대해 \((\delta_1(p,a),\delta_2(q,a))\)로 진행하면서,  
   매 스텝 도착 상태의 출력 \(\rho_1,\rho_2\)가 다른 지점이 있는지 검사.
3) 차이가 없고 탐색이 끝나면 동치.

복잡도는 **상태·전이 수에 선형**. 이 검사 중 찾은 “최초 불일치 입력”이 곧 **증거 입력**이다.

---

## 7. **Mealy** 와의 차이·연계

- **출력의 위치**
  - *Moore*: **상태**가 출력. 초기 출력이 자연스럽다.
  - *Mealy*: **전이**가 출력. 입력-출력 페어가 edge에 붙는다.
- **초기 분할**
  - *Moore*: **\(\rho\)** 로 분할 → 매우 강력.
  - *Mealy*: 각 전이에 대해 \((출력, 다음 블록)\) 쌍으로 서명 생성.
- **상태 폭증**
  - Mealy → Moore 변환 시 전이 출력을 상태로 흡수하면 최악에 \(|Q|\cdot|\Gamma|\) 수준까지 늘 수 있다.
- **최소화 절차**
  - 파티션 정제·Hopcroft 가속 **그대로** 적용 가능(서명 정의만 다름).

---

## 8. 문자열 출력/최종 출력이 있는 경우(순차 변환기)

일부 Moore 변형(예: subsequential transducer)은 **상태 출력 + 전이 출력의 누적**을 갖거나, **최종 출력**을 가진다.  
이때는 **출력 푸시(output pushing)** 로 정상형을 만든 뒤, “현재 상태의 즉시 출력” 기준 초기 분할 → 파티션 정제를 적용한다.  
푸시는 출력의 접두/접미를 상태·전이로 이동시켜 **동치 비교가 보존**되도록 하는 표준 기법이다.

---

## 9. **정확성 스케치** — 코arsest 안정 분할 = 최소 몫

- **안정 분할**: 분할 \(\Pi\)가 모든 \(a\in\Sigma\)에 대해 “같은 블록이면 \(a\)-후속 상태도 같은 블록”을 만족.
- **코arsest 안정 분할**: 초기 분할(같은 \(\rho\))을 세분화하되 안정 조건을 만족하는 것 중 **가장 거친** 것.
- **정리**: 파티션 정제/혹은 Hopcroft 알고리즘이 만든 \(\Pi^\*\)는 코arsest 안정 분할이며, 그 몫 기계 \(M/{\sim}\) 이 Moore 최소기계.  
  **유일성**: 최소기계는 **상태 재명명까지 유일**.

증명은 DFA 최소화와 동일한 틀(귀납/동치·안정·호환성)로 진행된다. Moore에서는 “출력 동일”이 초기 조건으로 들어간다.

---

## 10. **구현** — 의사코드와 Python 예시

### 10.1 순진 파티션 정제(완전 전이 가정; 초기 출력 포함 관례)

```text
Minimize-Moore-Naive(Q, Σ, δ, ρ, q0):
  Q := Reachable(Q, Σ, δ, q0)              # BFS/DFS
  Π := partition Q by ρ(q)                  # dict: output -> {states}

  while True:
    # 서명: 각 상태 q에 대해 tuple( class(δ(q,a)) for a in Σ )
    sig_map = empty map from signature -> set of states
    for q in Q:
      sig = tuple( classID( δ(q,a), Π ) for a in Σ )
      sig_map[sig].add(q)
    Π' := { each set in sig_map.values() }
    if Π' == Π: break
    Π := Π'

  # quotient
  rep = pick representative per block
  Qmin = { rep(B) for B in Π }
  δmin = dict()
  ρmin = dict()
  for B in Π:
    r = rep(B)
    ρmin[r] = ρ(r)
    for a in Σ:
      δmin[(r,a)] = rep( class( δ(r,a), Π ) )
  q0min = rep( class(q0, Π) )
  return (Qmin, Σ, δmin, ρmin, q0min)
```

### 10.2 Hopcroft 가속(역전이 활용; 희소 전이 지원)

```text
Hopcroft-Moore(Q, Σ, δ, ρ, q0):
  Q := Reachable(Q, Σ, δ, q0)

  # 초기 분할: 출력별
  Π = partition-by-output(Q, ρ)
  W = priority-queue(by size) with all blocks in Π

  # 역전이 pred[a][s]: δ(s,a)=t 일 때 t의 역으로 s를 등록
  pred = { a: map state->set(preds) for a in Σ }
  for s in Q:
    for a in Σ:
      t = δ(s,a)                # 총기계화 가정
      pred[a][t].add(s)

  while W not empty:
    S = pop_smallest(W)
    for a in Σ:
      # a로 S에 들어오는 선행 상태들의 집합
      P = union over t in S of pred[a][t]
      # Π의 각 블록과 교차
      for each block B in Π such that B∩P ≠ ∅ and B\P ≠ ∅:
        B1 = B ∩ P; B2 = B \ P
        replace B by B1,B2 in Π
        push smaller_of(B1,B2) into W

  # quotient 생성은 동일
  return quotient(Π, δ, ρ, q0)
```

### 10.3 Python 데이터 구조 예시

```python
# 상태는 0..n-1, Σ는 튜플(예: (0,1)), δ는 dict[(q,a)] = q'
def minimize_moore(states, alphabet, delta, rho, q0):
    # 1) Reachable
    from collections import deque, defaultdict
    vis, dq = set([q0]), deque([q0])
    while dq:
        u = dq.popleft()
        for a in alphabet:
            v = delta[(u,a)]
            if v not in vis:
                vis.add(v); dq.append(v)
    Q = sorted(vis)

    # 2) 초기 분할(출력별)
    block_id = {}
    blocks = {}
    for q in Q:
        blocks.setdefault(rho[q], set()).add(q)
    Π = [blk for blk in blocks.values()]
    for i, B in enumerate(Π):
        for q in B: block_id[q] = i

    # 3) 정제 반복
    while True:
        sig2states = defaultdict(set)
        for q in Q:
            sig = tuple(block_id[delta[(q,a)]] for a in alphabet)
            sig2states[sig].add(q)
        Π_new = [S for S in sig2states.values()]
        # 고정점 검사
        if len(Π_new) == len(Π) and all(len(Π_new[i])==len(Π[i]) for i in range(len(Π))):
            Π = Π_new; break
        Π = Π_new
        # block_id 갱신
        block_id = {}
        for i, B in enumerate(Π):
            for q in B: block_id[q] = i

    # 4) 몫 구성
    rep = [next(iter(B)) for B in Π]
    rep_of = {}
    for i,B in enumerate(Π):
        for q in B: rep_of[q] = rep[i]

    Qmin = sorted(set(rep))
    ρmin = { r: rho[r] for r in Qmin }
    δmin = {}
    for r in Qmin:
        for a in alphabet:
            δmin[(r,a)] = rep_of[ delta[(r,a)] ]
    q0min = rep_of[q0]
    return Qmin, alphabet, δmin, ρmin, q0min
```

- **입력**은 총/결정적을 가정. 부분 기계는 §5에 따라 Sink를 추가해 총기계화 후 적용한다.
- **검증**은 §11의 테스트 전략을 따른다.

---

## 11. **검증 전략** — 최소화 후 동치성·반례 찾기

- **출력 스트림 비교 테스트**: 난수 입력 스트링들 \(w\)에 대해 `simulate(M,w)` vs `simulate(M_min,w)`의 스트림이 같은지 확인.
- **완전 검증**: 두 기계의 **제품 탐색**으로 **최초 불일치 입력**을 찾는다(§6). 불일치가 없다면 동치.
- **회귀 테스트**: Hopcroft 결과와 순진 정제 결과의 상태 수가 동일한지, 전이/출력 레이블링이 일대일 대응하는지 체크.

```text
simulate(M, w):
  out = [ ρ(q0) ]    # 초기 출력 포함 관례
  q = q0
  for a in w:
    q = δ(q,a)
    out.append( ρ(q) )
  return out
```

---

## 12. **실전 포인트** — 데이터 구조와 대알파벳, 희소 전이

- **역전이(pred) 인덱스**: Hopcroft 가속의 생명. \(O(E)\) 메모리를 써서 각 \(a\)마다 역 adjacency를 보관.
- **블록 ID 압축**: 블록을 연속 ID로 관리하면 서명 해시가 가볍다(고정길이 튜플).
- **대알파벳 최적화**: \(|\Sigma|\)가 크면 각 상태가 실질적으로 가지는 전이만 저장(**희소 맵**). 없는 전이는 Sink로 통일.
- **작은쪽 전파**: 분할 시 항상 작은쪽만 worklist에 넣어 전체 비용을 줄인다.
- **스트리밍/온더플라이**: 매우 큰 기계는 도달 상태만 온더플라이로 확장하며 정제(메모리 절약).

---

## 13. **추가 예제** — “서명으로 쪼개지는” 경우

```text
Σ={x,y}, Γ={0,1}, 시작 S
출력: S/0, A/0, B/0, C/1, D/1
전이:
S -x-> A,  S -y-> C
A -x-> A,  A -y-> D
B -x-> A,  B -y-> C
C -x-> B,  C -y-> C
D -x-> B,  D -y-> C
```

- 초기 분할: \(\{S,A,B\}\) vs \(\{C,D\}\) (출력 0 vs 1)
- 정제:
  - \(\{S,A,B\}\) 내부 서명
    - \(S: (x→\{S,A,B\}, y→\{C,D\})\)
    - \(A: (x→\{S,A,B\}, y→\{C,D\})\)
    - \(B: (x→\{S,A,B\}, y→\{C,D\})\) → 동일, 유지
  - \(\{C,D\}\) 내부 서명
    - \(C: (x→\{S,A,B\}, y→\{C,D\})\)
    - \(D: (x→\{S,A,B\}, y→\{C,D\})\) → 동일, 유지
- 최소형은 2상태.  
만약 \(D -x-> S\) 였다면, \(C\)와 \(D\)의 서명이 달라져 \(\{C\}\), \(\{D\}\)로 분할된다.

---

## 14. **경계 사례** — 출력만 같아도 항상 병합되나?

- **아니다**. 초기엔 같은 블록이지만, **다음 블록 튜플**이 달라지는 순간 분할된다.  
  상위 출력이 같아도 **깊은 입력에서 다른 출력 패턴**을 만들면 서명이 달라져 분해된다.
- **항상 병합되는 경우**: 어떤 깊이에서도 동일한 다음 블록 튜플을 유지 → 그 둘은 진정한 동치.

---

## 15. **복잡도 비교** 요약

| 알고리즘 | 전이 수 \(E\) | 시간 복잡도(전형) | 비고 |
|---|---:|---:|---|
| 순진 파티션 정제 | \(|Q||\Sigma|\) | \(O(|\Sigma|\cdot|Q|^2)\) | 구현 간단 |
| Hopcroft(역전이) | \(E\) | \(O((|Q|+E)\log|Q|)\) | 작은쪽 전파 |
| Paige–Tarjan 계열 | \(E\) | \(O(E\log|Q|)\) | 분해 유지 구조화 |

- Moore에서도 DFA와 같은 상한을 기대할 수 있다(서명·분할 트리거만 다르다).

---

## 16. **Mealy ↔ Moore** 변환 메모

- **Mealy → Moore**: 전이 출력 \(o\)를 도착 상태의 **즉시 출력**으로 흡수.  
  필요한 경우 “전이-출력 조합”만큼 상태가 늘 수 있다.
- **Moore → Mealy**: 상태 출력 \(\rho(q)\)를, \(q\xrightarrow{a}q'\)의 전이 출력으로 옮긴다(초기 출력 처리 주의).

변환 후 **최소화**는 본 절차를 그대로 적용한다.

---

## 17. **테스트·도구 연계**(현업 팁)

- **동치성 기반 테스트**: 원기계와 최소기계의 제품 탐색으로 자동 **증거 입력** 생성.
- **W-Method/HSI**: 모델 기반 테스트 패턴으로 상태 구분 **대표 입력 집합**을 자동 생성해 회귀 테스트에 활용.
- **직렬화 포맷**: 상태→블록 ID 맵, 전이 테이블, 출력 벡터를 고정 포맷으로 남겨 디프/캐시 가능.

---

## 18. **FAQ**

- **출력 알파벳이 큰데 초기 분할 비용이 큰가?**  
  출력 값→상태 리스트 맵 하나면 \(O(|Q|)\)에 끝난다. 병목은 정제 단계다.
- **부분 기계는 반드시 Sink가 필요한가?**  
  “정의 불일치”로 동치를 가르고 싶다면 Sink가 안전하다. 그렇지 않으면 입력 도메인을 동일화해야 한다.
- **초기 출력 미포함 관례도 가능한가?**  
  가능. 그땐 “초기 출력 비교”를 빼고, 첫 입력 처리 후의 출력부터 비교하면 된다.

---

## 19. 한 페이지 요약

- **동치**: $$\rho(p)=\rho(q)\ \land\ \forall a:\ \delta(p,a)\sim\delta(q,a)$$  
- **최소화**: (1) 도달 상태만 유지 → (2) 출력값으로 초기 분할 → (3) **다음 블록 튜플**로 파티션 정제 → (4) 몫 구성.  
- **복잡도**: 순진 \(O(|\Sigma|\cdot|Q|^2)\) → Hopcroft \(O((|Q|+E)\log|Q|)\).  
- **부분 기계**: Sink로 총기계화 후 처리.  
- **Mealy**: 서명 정의만 다르며, 절차·가속 아이디어는 동일.

---
```python
# [보너스] 간단 검증 스크립트 스케치 (개념)
# 두 Moore M1, M2가 동치인지와 반례 입력을 찾아준다.
from collections import deque

def equivalent_moore(M1, M2, alphabet):
    Q1, δ1, ρ1, q01 = M1
    Q2, δ2, ρ2, q02 = M2
    if ρ1[q01] != ρ2[q02]:
        return False, []  # 초기 출력 불일치
    seen = set([(q01,q02)])
    dq = deque([ (q01,q02, []) ])
    while dq:
        p, q, w = dq.popleft()
        for a in alphabet:
            p2, q2 = δ1[(p,a)], δ2[(q,a)]
            if ρ1[p2] != ρ2[q2]:
                return False, w+[a]  # 최초 불일치 입력
            if (p2,q2) not in seen:
                seen.add((p2,q2)); dq.append((p2,q2, w+[a]))
    return True, None
```
위 스케치는 §6의 제품 탐색을 코드로 옮긴 것이다. 실제 구현에서는 입력 길이 제한 없이 도달 가능한 모든 쌍을 탐색하면 충분하다(유한 상태·총 전이 가정).

---

# 요약 체크리스트

[ ] 총기계화(Sink) 완료, 도달 상태만 유지
[ ] 출력값으로 초기 분할
[ ] 역전이 인덱스 준비(pred[a][state])
[ ] 작은쪽 분할 전파(Hopcroft 스타일)
[ ] 몫 구성 및 제품 탐색으로 동치성 검증
[ ] 대표 입력 생성(W-Method/HSI)로 회귀 테스트 확보
