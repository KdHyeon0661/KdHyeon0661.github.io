---
layout: post
title: 형식언어와 오토마타 - Moore 기계의 최소화
date: 2025-08-15 21:20:23 +0900
category: 형식언어와 오토마타
---
# Moore 기계의 **최소화** — 상태 동치, 파티션 정제, Hopcroft 가속, 예제, 실전 포인트

Moore 기계는 각 **상태에 출력**이 붙어 있는 유한상태 변환기입니다.  
최소화(minimization)의 목적은 **같은 변환(입력→출력 스트림)** 을 수행하면서 **상태 수가 최소**인 동치 기계를 만드는 것.  
여기선 (1) 동치의 정의, (2) **파티션 정제(Partition Refinement)** 기본 알고리즘, (3) **Hopcroft 스타일 가속**,  
(4) 단계별 예제, (5) 부분 기계·Sink 처리, (6) Mealy와의 차이·확장까지 한 번에 정리합니다.  
수식은 MathJax, 절차는 코드 블록(```)으로 표기합니다.

---

## 1) 모델과 **동치** 정의

결정적 Moore 기계
\[
M=(Q,\Sigma,\Gamma,\delta,\rho,q_0),\quad
\delta:Q\times\Sigma\to Q,\ \ \rho:Q\to\Gamma
\]
- 입력 \(a\)를 읽을 때 \(p\xrightarrow{a}q=\delta(p,a)\)로 이동하고, **도착 상태 출력** \(\rho(q)\)를 방출합니다.
- (관례) 초기 상태의 출력 \(\rho(q_0)\)도 스트림의 **첫 기호**로 본다.  
  문서마다 초기를 생략하기도 하므로 **동치 비교 시 무엇을 채택했는지 일관**해야 합니다.

### 1.1 상태 동치(State Equivalence)
상태 \(p,q\in Q\)가 동치라 함은
\[
\boxed{\ \rho(p)=\rho(q)\ \ \text{and}\ \ \forall a\in\Sigma:\ \delta(p,a)\sim\delta(q,a)\ }
\]
가 되도록 가장 작은 동치관계 \(\sim\) 를 뜻합니다.  
즉 **현재 출력이 같고** 모든 입력에 대해 **다음 상태들도 다시 동치**여야 합니다.

> DFA(수용/비수용) 최소화와 달리, Moore는 **출력 레이블 자체**가 1차 분할 기준입니다.

### 1.2 트리밍(Reachability)
최소화 전 **도달 불가 상태**를 제거하세요.
\[
Q \leftarrow \{\,q\in Q \mid q\ \text{is reachable from}\ q_0\,\}
\]
(수용 개념이 없으므로 co-reachability는 필수가 아닙니다.)

---

## 2) 기본 알고리즘 — **파티션 정제(Moore 방식)**

핵심은 “서명(signature)”로 **구별 가능성**을 반복해서 드러내는 것.

### 2.1 초기 분할
출력이 같은 상태끼리 묶습니다.
\[
\Pi_0 := \{\, \{ q\in Q \mid \rho(q)=\gamma\}\ :\ \gamma\in\Gamma \,\}
\]

### 2.2 서명(Signature)
현재 분할 \(\Pi\)가 있을 때, 상태 \(q\)의 서명:
\[
\mathrm{Sig}_\Pi(q)\ :=\ \Big( \ [\delta(q,a)]_{\Pi}\ \Big)_{a\in\Sigma}
\]
- 각 입력 \(a\)에 대해 “다음 상태가 속한 **블록 번호**”의 튜플입니다.
- 출력 \(\rho(q)\)는 이미 초기 분할에서 반영했으므로 **서명엔 포함하지 않아도** 됩니다.

### 2.3 정제 반복과 종료
```text
Input: Moore M=(Q,Σ,Γ,δ,ρ,q0)
Q := reachable_from(q0)

Π := partition Q by ρ(q)                      # 초기 분할

repeat
  Π' := partition Q by Sig_Π(q)=( class_Π(δ(q,a)) for a in Σ )
  if Π' == Π: break
  Π := Π'
until fixed

# Quotient 구성
상태는 각 블록 B∈Π 로 대체(대표 [q]).
δ_min([q],a) := [ δ(q,a) ]
ρ_min([q])   := ρ(q)
q0_min       := [ q0 ]
return M_min
```

- **정지 조건**: 더 이상 어떤 입력에도 블록이 쪼개지지 않으면 완료(불변점).
- **정당성**: 귀납으로, 같은 블록에 있으면 **모든 길이의 접미 입력**에 대해 출력 스트림이 동일합니다.

### 2.4 복잡도
- 단순 구현: 매 라운드 \(O(|\Sigma|\cdot|Q|)\), 라운드 최대 \(|Q|\) → \(O(|\Sigma|\cdot|Q|^2)\).
- §3의 Hopcroft 가속으로 \(O(|\Sigma|\cdot|Q|\log|Q|)\) 근처까지 감소.

---

## 3) **Hopcroft 스타일 가속** (작은 분할부터 퍼뜨리기)

DFA 최소화 아이디어를 그대로 적용하되, **분할 기준이 “다음 블록 튜플”** 임을 유념.

```text
Π := partition by ρ
W := all blocks in Π                       # 작업 큐(분할자 집합)

while W not empty:
  S := pop_smallest(W)                     # 항상 작은 쪽을 선택(분해 비용 ↓)
  for a in Σ:
    # a로 S에 '들어가는' 전이를 가진 블록들만 세분화
    for each block B in Π:
      B1 := { q∈B : δ(q,a) ∈ S }
      B2 := B \ B1
      if B1≠∅ and B2≠∅:
        replace B by B1,B2 in Π
        push smaller_of(B1,B2) into W
return Π
```

- Moore에서도 분할 트리거는 **(입력 a, 목적 블록 S)** 형태입니다.  
- 매 분해가 **최소쪽만 전파**되므로 전체 비용이 로그 인자로 줄어듭니다.

---

## 4) 단계별 **예제**

아래 Moore 기계를 최소화해 봅니다.

```text
Σ = {0,1},  Γ = {0,1}
상태/출력:  A/0, B/0, E/0,   C/1, D/1, F/1      (시작 A)

전이:
A --0--> B    A --1--> C
B --0--> B    B --1--> D
C --0--> E    C --1--> C
D --0--> E    D --1--> C
E --0--> B    E --1--> D
F --0--> E    F --1--> C
```

**Step 1) 초기 분할** (출력 기준)  
\(\Pi_0=\{\{A,B,E\},\{C,D,F\}\}\)

**Step 2) 정제** (다음 블록 튜플 비교)
- 블록 \(\{A,B,E\}\):  
  - A: (0→\{A,B,E\}, 1→\{C,D,F\})  
  - B: (0→\{A,B,E\}, 1→\{C,D,F\})  
  - E: (0→\{A,B,E\}, 1→\{C,D,F\}) → **동일**
- 블록 \(\{C,D,F\}\):  
  - C: (0→\{A,B,E\}, 1→\{C,D,F\})  
  - D: (0→\{A,B,E\}, 1→\{C,D,F\})  
  - F: (0→\{A,B,E\}, 1→\{C,D,F\}) → **동일**

추가 분할 없음 → **최소형은 2상태**:  
\([Z_0]=\{A,B,E\}\) (출력 0), \([Z_1]=\{C,D,F\}\) (출력 1).  
전이는 \(Z_0\xrightarrow{0}Z_0,\ Z_0\xrightarrow{1}Z_1,\ Z_1\xrightarrow{0}Z_0,\ Z_1\xrightarrow{1}Z_1\).

> 포인트: Moore는 **출력부터 나눈다** → 많은 병합이 한 방에 이뤄집니다.  
> 반대로 전이 패턴이 다르면 이후 라운드에서 더 쪼개집니다.

---

## 5) **부분** Moore와 **총기계화**(Sink)

일부 \((q,a)\) 전이가 미정의라면:
- **Sink(덫) 상태** \(\bot\)을 도입해 \(\delta(q,a)=\bot\), \(\rho(\bot)=\gamma_\bot\) 로 **총기계화**(totalization) 후 최소화하는 것이 안전합니다.
- 동치/최소화 판단에서 “한쪽만 정의인 입력”을 **즉시 구분**하게 해 줍니다.

---

## 6) 동치성 검사(두 Moore 기계)

두 기계 \(M_1,M_2\)가 **동치**인지 확인하려면:
1) **초기 출력**부터 비교(\(\rho_1(q_{0,1})\) vs \(\rho_2(q_{0,2})\)); 다르면 비동치.  
2) **제품 기계**에서 같은 입력을 동시에 주입하며, 매 스텝 도착 상태 출력이 다르면 **증거** 발견.  
3) 전 공간을 탐색해도 차이가 없으면 동치.  
결정적/총인 경우 **상태·전이 수에 선형**한 시간에 가능합니다.

---

## 7) Mealy 최소화와의 차이·연계

- **초기 분할**:  
  - *Moore*: **출력값**으로 먼저 분리.  
  - *Mealy*: 전이의 **(출력, 다음 블록)** 쌍이 곧 서명.
- **상태 폭증**:  
  - *Mealy→Moore 변환* 시 전이별 출력을 상태로 흡수 → 최대 \(|Q|\cdot|\Gamma|\) 까지 상태가 늘 수 있음.  
  - 최소화 자체는 여기 제시한 절차로 동일하게 진행됩니다.
- **복잡도/가속**: Hopcroft 가속이 두 모델 모두에 동일한 이득을 줍니다.

---

## 8) (확장) 문자열 출력/최종 출력이 있는 경우

문자 하나가 아니라 **문자열**을 내거나 **최종 출력**이 있는 **순차 변환기**(subsequential transducer)에서는  
그냥 병합하면 출력 접두/접미가 겹칠 수 있으므로, 먼저 **출력 푸시(output pushing)** 로 **정규형**을 만든 뒤  
여기와 같은 파티션 정제를 적용합니다(그 경우에도 초기 분할은 “현재 상태의 즉시 출력” 기준).

---

## 9) 구현 팁

- **서명 해시**: \(\mathrm{Sig}_\Pi(q)\) 를 고정 길이 벡터(알파벳 크기)로 해시해 빠르게 분류.  
- **작은쪽-퍼뜨리기**: 분할이 생기면 **작은 조각**만 worklist에 넣어 비용 절감.  
- **대알파벳 최적화**: 희소 전이 맵(해시/정렬 배열)로 저장하고, 결측은 Sink로 통일.  
- **테스트**: 모델 기반(W-Method/HSI)로 상태 구분 입력을 자동 생성해 최소형을 검증.

---

## 10) 한 페이지 요약

- **동치**: 현재 출력이 같고, 모든 입력에 대해 **다음 상태들도 동치**.  
- **알고리즘**: (1) 도달 상태만 유지 → (2) 출력값으로 초기 분할 → (3) **다음 블록 튜플**로 파티션 정제 → (4) 몫 기계 구성.  
- **복잡도**: 단순 \(O(|\Sigma|\cdot|Q|^2)\) → Hopcroft 가속으로 \(O(|\Sigma|\cdot|Q|\log|Q|)\) 근처.  
- **부분 기계**는 Sink로 **총기계화** 후 최소화.  
- **Mealy와 비교**: Moore는 출력으로 먼저 가르고, Mealy보다 상태가 늘 수 있으나 최소화 절차는 유사.
