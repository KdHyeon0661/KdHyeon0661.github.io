---
layout: post
title: 논리회로설계 - 부울 대수 응용
date: 2025-08-28 19:25:23 +0900
category: 논리회로설계
---
# 부울 대수 응용 — **서술문 → 부울식 변환**, **진리표 기반 조합논리 설계**, **최소항·최대항 전개** (개정판 2025)

## 0. 개요·표기·목표
- 표기 규칙:  
  $$
  +=\text{OR},\quad \cdot=\text{AND}\ (\text{또는 생략}),\quad \overline{A}=\text{NOT }A,\quad \oplus=\text{XOR},\quad \odot=\text{XNOR}
  $$
- 목표:
  1) 자연어 서술을 **정확한 부울식**으로 치환  
  2) **진리표**로 설계/검증  
  3) **최소항(미터姆)/최대항(맥스텀)** 전개로 SOP/POS 정규형 도출  
  4) 필요 시 **K-맵/대수**로 최소화(+해저드 관점)

---

## 1. 서술문 → 부울식 변환

### 1.1 빠른 변환 표
- “그리고/동시에/둘 다” → AND:  
  $$
  A\ \text{그리고}\ B\ \Rightarrow\ AB
  $$
- “또는/혹은(포함적)” → OR:  
  $$
  A\ \text{또는}\ B\ \Rightarrow\ A+B
  $$
- “정확히 하나만” → XOR:  
  $$
  \text{exactly-one}(A,B)\Rightarrow A\oplus B
  $$
- “~이 아님/없음” → NOT:  
  $$
  \text{아님 }A\Rightarrow \overline{A}
  $$
- “\(A\)이면 \(B\)”(충분조건) → 함의:  
  $$
  A\Rightarrow B\ \equiv\ \overline{A}+B
  $$
- “\(A\)일 때만 \(B\)”(필요조건) →  
  $$
  B\Rightarrow A\ \equiv\ \overline{B}+A
  $$
- “\(A\)일 때 그리고 그때에 한해 \(B\)” → 동치:  
  $$
  A\Leftrightarrow B\ \equiv\ A\odot B
  $$
- “적어도 하나/모두/하나도 없을 때만”:  
  $$
  \text{at-least-one}(A,B,\dots)=A+B+\cdots,\quad \text{all}=ABC\cdots,\quad \text{none}=\overline{A}\,\overline{B}\cdots
  $$

> 한국어 “또는”은 기본적으로 **포함적 OR**입니다. 배타를 의도하면 “정확히 하나” 등으로 명시하고 XOR로 모델링합니다.

### 1.2 절차(안전한 5단계)
1) **변수 선언**: 이름·의미·활성 레벨(1=활성?)  
2) **문장 분해**: 충분/필요/배타/부정 요소 분리  
3) **연산 치환**: 위 표로 AND/OR/NOT/XOR/함의 적용  
4) **모호성 제거**: “일 때만”이 필요조건인지, 동치인지 확인  
5) **정규화**: SOP 또는 POS로 재구성(필요 시 드모르간/분배)

### 1.3 예제 A — 보안 경보
- 서술: “문 또는 창문이 열려 있고 재실이 아닐 때만 경보.”  
- 변수: \(D=\)문 열림, \(W=\)창문 열림, \(H=\)재실(1=사람 있음)  
- 변환:  
  $$
  Alarm=(D+W)\ \overline{H}
  $$

### 1.4 예제 B — 접근 권한
- 서술: “관리자이거나, 카드와 핀을 모두 갖추면 입장 가능.”  
- 변수: \(M,C,P\)  
- 변환:  
  $$
  Entry = M + CP
  $$

### 1.5 예제 C — ‘일 때만’ vs ‘이면’
- 서술: “비상 버튼이 눌렸을 때만 사이렌이 켜진다.”  
- 보수적 해석(필요조건):  
  $$
  S\Rightarrow E\ \equiv\ \overline{S}+E
  $$
- 보통 의도(동치):  
  $$
  S=E
  $$

---

## 2. 진리표 기반 조합논리 설계

### 2.1 표준 절차
1) 입력/출력 변수 정의(\(n\)입력이면 행 \(2^n\))  
2) 모든 조합에 대해 출력 채움(불사용 항목은 \(X\): don’t care)  
3) 정규형 전개(둘 중 하나, 또는 둘 다 기록)
   $$
   F=\sum m(\text{1인 인덱스})\quad\text{또는}\quad F=\prod M(\text{0인 인덱스})
   $$
4) 최소화(K-맵/대수/퀘인–맥클러스키) — \(X\)는 묶음에 **유리할 때만** 포함  
5) 구현 선택(NAND/NOR-only, PLA/ROM, MUX 등)

### 2.2 예제 1 — 3입력 다수결(Majority)
- 정의: \(A,B,C\) 중 **둘 이상** 1이면 1  
- 진리표(발췌)  
  ```
  A B C | F
  -------
  0 0 0 | 0
  0 1 1 | 1
  1 0 1 | 1
  1 1 0 | 1
  1 1 1 | 1
  ```
- SOP 정규형/최소형:  
  $$
  F=\sum m(3,5,6,7)=AB+AC+BC
  $$

### 2.3 예제 2 — 홀수 패리티(odd parity)
- 정의: 1의 개수 홀수 → 1  
- 결과:  
  $$
  P=A\oplus B\oplus C
  $$

### 2.4 예제 3 — 코드 변환기의 don’t care
- 입력 \(XYZ\) 중 \(000\sim011\)만 유효, 나머지 \(X\):  
  $$
  X\ \text{를 적절히 포함해 K\text{-}맵 묶음을 확대}\ \Rightarrow\ \text{게이트 수 감소}
  $$

---

## 3. 최소항·최대항 전개

### 3.1 정의(3변수 예)
- 최소항 \(m_i\): 모든 변수를 **1회** 포함(보수 포함)하는 AND 항 — **해당 조합에서만 1**  
- 최대항 \(M_i\): 모든 변수를 1회 포함하는 OR 항 — **해당 조합에서만 0**

### 3.2 매핑(관례: \(A\) MSB)
| \(A\) | \(B\) | \(C\) | 인덱스 \(i\) | \(m_i\) | \(M_i\) |
|:---:|:---:|:---:|---:|---|---|
|0|0|0|0| \(\overline{A}\,\overline{B}\,\overline{C}\) | \(A+B+C\) |
|0|0|1|1| \(\overline{A}\,\overline{B}C\) | \(A+B+\overline{C}\) |
|0|1|0|2| \(\overline{A}B\overline{C}\) | \(A+\overline{B}+C\) |
|0|1|1|3| \(\overline{A}BC\) | \(A+\overline{B}+\overline{C}\) |
|1|0|0|4| \(A\overline{B}\overline{C}\) | \(\overline{A}+B+C\) |
|1|0|1|5| \(A\overline{B}C\) | \(\overline{A}+B+\overline{C}\) |
|1|1|0|6| \(AB\overline{C}\) | \(\overline{A}+\overline{B}+C\) |
|1|1|1|7| \(ABC\) | \(\overline{A}+\overline{B}+\overline{C}\) |

### 3.3 정규형
- SOP(곱의 합):  
  $$
  F=\sum m(I)=\bigoplus_{\ i\in I\ } m_i\ \text{(여기서 }+\text{=OR)}
  $$
- POS(합의 곱):  
  $$
  F=\prod M(J)=\bigwedge_{\ i\in J\ } M_i\ \text{(여기서 }\cdot\text{=AND)}
  $$

### 3.4 예 — 다수결의 정규형
- \(F=1\) 인덱스 \(3,5,6,7\):  
  $$
  F=\sum m(3,5,6,7)=\overline{A}BC + A\overline{B}C + AB\overline{C} + ABC
  $$
- K-맵 최소화:  
  $$
  F=AB+AC+BC
  $$
- POS도 가능:  
  $$
  F=\prod M(0,1,2,4)
  $$

### 3.5 don’t care 포함
- 사용 불가 집합 \(D\)가 있으면:  
  $$
  F=\sum m(I)+d(D)\quad(\text{최소화 시 }D\text{는 포함/제외 임의})
  $$

### 3.6 보수와 전개
- 보수는 인덱스 여집합:  
  $$
  \overline{F}=\prod M(I)\ \text{ if }\ F=\sum m(\overline{I})
  $$
  $$
  \overline{F}=\sum m(J)\ \text{ if }\ F=\prod M(\overline{J})
  $$

---

## 4. 종합 예제 — 서술 → 진리표 → 전개 → 최소화

### 4.1 “정확히 하나만 1이면 1”
- 문제: 3입력 \(A,B,C\), **exactly one** → 1  
- 부울식:  
  $$
  F=\overline{A}\,\overline{B}C + \overline{A}B\,\overline{C} + A\,\overline{B}\,\overline{C}
  $$
- 진리표(발췌)  
  ```
  A B C | F
  0 0 1 | 1
  0 1 0 | 1
  1 0 0 | 1
  (기타) | 0
  ```
- SOP:  
  $$
  F=\sum m(1,2,4)
  $$
- 주의:  
  $$
  A\oplus B\oplus C\ \text{는 홀수 패리티(1 또는 3개)}\Rightarrow \text{이번 문제와 다름}
  $$
  $$
  \text{정확히 하나}= (A\oplus B\oplus C)\cdot \overline{ABC}
  $$

### 4.2 “9 이상이면 1”(4비트 크기 비교)
- 입력: \(A,B,C,D\) (가중치 8,4,2,1)  
- 조건: \(\text{value}\ge 9\Rightarrow\) 인덱스 \(\{9,10,11,12,13,14,15\}\)  
- SOP 정규형:  
  $$
  F=\sum m(9,10,11,12,13,14,15)
  $$
- 대수 최소화(한 줄 요지):  
  $$
  F= A + (\overline{A}BCD\text{ 패밀리})\Rightarrow F=A + (B C + B D + C D)\ (\text{상세는 K-맵})
  $$

---

## 5. 자동화 도우미(파이썬) — 진리표·SOP/POS·등가성

{% raw %}
```python
from itertools import product

def truth_table(vars_, f):
    """vars_: ['A','B',...]
       f: callable(bits)->{0,1}
       returns list of tuples (*bits, val) in lexicographic bit order (A as MSB)."""
    rows=[]
    for bits in product([0,1], repeat=len(vars_)):
        rows.append((*bits, int(bool(f(bits)))))
    return rows

def minterm(vars_, bits):
    # LaTeX-friendly minterm string: A or \overline{A}
    out=[]
    for v,b in zip(vars_, bits):
        out.append(v if b==1 else f'\\overline{{{v}}}')
    return ''.join(out)

def maxterm(vars_, bits):
    # (A + B + \overline{C}) style
    parts=[]
    for v,b in zip(vars_, bits):
        parts.append(v if b==0 else f'\\overline{{{v}}}')
    return '(' + ' + '.join(parts) + ')'

def to_sop_pos(vars_, f):
    sop_terms=[]; pos_terms=[]
    all_bits=list(product([0,1], repeat=len(vars_)))
    for bits in all_bits:
        val=int(bool(f(bits)))
        if val==1: sop_terms.append(minterm(vars_, bits))
        else:      pos_terms.append(maxterm(vars_, bits))
    sop = ' + '.join(sop_terms) if sop_terms else '0'
    pos = ' '.join(pos_terms) if pos_terms else '1'
    return sop, pos

def equivalent(vars_, f, g):
    for bits in product([0,1], repeat=len(vars_)):
        if int(bool(f(bits))) != int(bool(g(bits))):
            return False, dict(zip(vars_, bits))
    return True, None

# 예제: Majority(AB+AC+BC)와 \sum m(3,5,6,7) 동치 확인
def F_major(bits):
    A,B,C=bits
    return (A and B) or (A and C) or (B and C)

vars_=['A','B','C']
sop,pos = to_sop_pos(vars_, F_major)
print("SOP:", sop)
print("POS:", pos)
ok, cex = equivalent(vars_, F_major,
                     lambda t: int(t in [(0,1,1),(1,0,1),(1,1,0),(1,1,1)]))
print("Equivalent?", ok, cex)
```
{% endraw %}

**활용 팁**
- 설계 초안 → `to_sop_pos`로 정규형 기록  
- 수작업 최소화 결과와 `equivalent`로 **동치 검증**  
- 변수 6~8개 이내면 전수검사도 충분히 빠름

---

## 6. 설계 체크리스트·함정

- 텍스트 해석:
  $$
  \text{‘이면’(}\Rightarrow\text{) vs ‘일 때만’(}\Leftarrow\text{) vs ‘당且’(}\Leftrightarrow\text{)}\ \text{명확히}
  $$
- “또는”은 포함적 OR, “정확히 하나”는 XOR로 분리  
- 인덱스 규약(예: \(A\)가 MSB) 표로 고정  
- don’t care는 **묶음 키우기**에만 사용(오동작 여지 최소화)  
- 최소화 후 **해저드** 가능 시 합의항 추가 검토:
  $$
  AB+\overline{A}C\ \xrightarrow{\text{합의항 추가}}\ AB+\overline{A}C+BC
  $$
- SOP/POS 모두 기록해 상호 검증 습관화

---

## 7. 연습문제(+풀이 스케치)

### 7.1 서술 → 부울식
- 문제: “재실이 없고(\(H=0\)) 창문이 열렸거나(\(W=1\)) 유리 파손 센서(\(G=1\))가 트리거되면 경보.”  
- 해석:  
  $$
  Alarm=\overline{H}(W+G)
  $$

### 7.2 진리표 설계 — “4비트 값이 9 이상”
- 입력: \(A,B,C,D\) (8,4,2,1)  
- 1인 인덱스:  
  $$
  \{9,10,11,12,13,14,15\}
  $$
- SOP 정규형:  
  $$
  F=\sum m(9,10,11,12,13,14,15)
  $$
- 힌트 최소화:  
  $$
  F = A + (\overline{A}BC + \overline{A}BD + \overline{A}CD)\ \Rightarrow\ A + (BC+BD+CD)
  $$

### 7.3 최소항 전개·K-맵 최소화
- 진리표:  
  ```
  A B C | F
  0 0 0 | 0
  0 0 1 | 1
  0 1 0 | 1
  0 1 1 | 0
  1 0 0 | 1
  1 0 1 | 0
  1 1 0 | 0
  1 1 1 | 1
  ```
- SOP 정규형:  
  $$
  F=\sum m(1,2,4,7)=\overline{A}\,\overline{B}C+\overline{A}B\overline{C}+A\overline{B}\overline{C}+ABC
  $$
- K-맵 최소화(2개×2개 묶음 관찰):  
  $$
  F=\overline{B}C + A\overline{B}\overline{C} + \overline{A}B\overline{C}\ \Rightarrow\ \overline{B}C + \overline{C}(A\overline{B}+\overline{A}B)
  $$
  $$
  =\overline{B}C + \overline{C}(A\oplus B)
  $$

### 7.4 최대항 전개·동치 확인
- 7.3의 0 인덱스: \(\{0,3,5,6\}\)  
- POS 정규형:  
  $$
  F=\prod M(0,3,5,6)
  $$
- 드모르간·분배로 SOP 최소형과 동치 확인(코드로 `equivalent` 추천)

### 7.5 “정확히 둘” — 4입력
- 정의: \(A,B,C,D\) 중 **정확히 2개만** 1 → 1  
- (a) SOP 전개(조합 6개):
  $$
  \begin{aligned}
  F&=\overline{A}\,\overline{B}CD+\overline{A}B\,\overline{C}D+\overline{A}BC\,\overline{D}\\
   &\quad +A\,\overline{B}\,\overline{C}D+A\,\overline{B}C\,\overline{D}+AB\,\overline{C}\,\overline{D}
  \end{aligned}
  $$
- (b) 짝수 패리티 관점(“홀수= XOR, 짝수= XNOR 체인”):
  $$
  \text{짝수 패리티}= \overline{A\oplus B\oplus C\oplus D}
  $$
  $$
  \text{정확히 둘}=\ \text{짝수 패리티}\ \cdot\ \overline{(A+B+C+D=0)}\ \cdot\ \overline{(A+B+C+D=4)}
  $$
  실무에선 **카운터/비교기**로 구현하는 편이 명료. 논리식만으로는 위 SOP가 가장 직관적입니다.

---

## 8. 부록 — 간단 K-맵(3변수) 시각 가이드
그레이 순서(행 \(AB\)=00,01,11,10 / 열 \(C\)=0,1):
```
      C
      0 1
AB 00 0 1
   01 1 0
   11 0 1
   10 1 0
```
- 인접(한 비트 차) 칸을 \(1,2,4,\dots\) 칸 묶기로 그룹 → 변수 수 감소  
- don’t care는 묶음 확대에만 사용

---

## 9. 결론 요약
- 자연어→부울식은 **연산 치환표**와 **충분/필요/동치** 구분이 핵심  
- 진리표→정규형은  
  $$
  F=\sum m(\cdot)\ \text{또는}\ F=\prod M(\cdot)
  $$
- 최소화는 K-맵/대수/알고리즘(Q–M) 병행, **해저드 시 합의항 추가** 고려  
- 코드로 **정규형 생성**·**등가성 검증**을 습관화하면 안전하다