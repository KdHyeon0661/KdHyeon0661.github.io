---
layout: post
title: DB 심화 - 데이터 모델 측면에서의 검토
date: 2025-11-21 21:25:23 +0900
category: DB 심화
---
# 데이터 모델링의 예술: 성능과 정합성을 위한 설계 전략

## 데이터 모델링의 본질적 가치

데이터 모델링은 단순한 테이블 설계를 넘어, 시스템의 성능, 확장성, 유지보수성을 결정하는 핵심적인 설계 활동입니다. OLTP와 분석 환경이 혼재된 현대 시스템에서 효과적인 데이터 모델은 비즈니스 요구사항을 지원하면서도 기술적 제약을 극복할 수 있도록 균형을 맞추어야 합니다.

## 실전 예제: 리테일 스타 스키마 + 트랜잭션 시스템

데이터 모델링 원칙을 설명하기 위해 리테일 환경의 통합 데이터 모델을 제시합니다. 이 모델은 OLTP 트랜잭션과 분석용 데이터 웨어하우스를 동시에 고려한 하이브리드 접근법을 보여줍니다.

```sql
-- 차원 테이블: 마스터 데이터
CREATE TABLE D_PRODUCT (
  PROD_SK       NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  -- 대리키: 내부 조인용
  PROD_BK       VARCHAR2(30) NOT NULL,                            -- 자연키: 외부 시스템 통합용
  CATEGORY      VARCHAR2(20) NOT NULL,
  BRAND         VARCHAR2(20) NOT NULL,
  CONSTRAINT UK_D_PRODUCT_BK UNIQUE(PROD_BK)                       -- 자연키 중복 방지
);

CREATE TABLE D_CUSTOMER (
  CUST_SK       NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  CUST_BK       VARCHAR2(30) NOT NULL,
  REGION        VARCHAR2(10) NOT NULL,
  TIER          VARCHAR2(10) NOT NULL,
  CONSTRAINT UK_D_CUSTOMER_BK UNIQUE(CUST_BK)
);

-- 분석용 사실 테이블: 대규모 데이터 처리 최적화
CREATE TABLE F_SALES (
  SALES_ID      NUMBER PRIMARY KEY,
  DT            DATE        NOT NULL,        -- 파티션 키
  PROD_SK       NUMBER      NOT NULL REFERENCES D_PRODUCT(PROD_SK),
  CUST_SK       NUMBER      NOT NULL REFERENCES D_CUSTOMER(CUST_SK),
  QTY           NUMBER      NOT NULL CHECK (QTY > 0),
  AMOUNT        NUMBER(12,2) NOT NULL CHECK (AMOUNT >= 0),
  -- 비즈니스 계산을 표준화하는 가상 컬럼
  UNIT_PRICE    GENERATED ALWAYS AS (
    CASE WHEN QTY > 0 THEN ROUND(AMOUNT / QTY, 2) END
  ) VIRTUAL
)
PARTITION BY RANGE (DT) (
  PARTITION P202501 VALUES LESS THAN (DATE '2025-02-01'),
  PARTITION P202502 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION PMAX    VALUES LESS THAN (MAXVALUE)
);

-- 파티션 친화적인 로컬 인덱스
CREATE INDEX IX_FS_PROD_DT ON F_SALES (PROD_SK, DT) LOCAL;
CREATE INDEX IX_FS_CUST_DT ON F_SALES (CUST_SK, DT) LOCAL;

-- OLTP 트랜잭션 테이블
CREATE TABLE T_ORDER (
  ORDER_ID      NUMBER PRIMARY KEY,
  CUST_SK       NUMBER NOT NULL REFERENCES D_CUSTOMER(CUST_SK),
  ORDER_TS      TIMESTAMP(6) WITH LOCAL TIME ZONE NOT NULL,
  STATUS        VARCHAR2(12) NOT NULL CHECK (STATUS IN ('NEW','PAID','CANCEL','SHIPPED')),
  IS_DELETED    CHAR(1) DEFAULT 'N' CHECK (IS_DELETED IN ('Y','N'))
);

CREATE TABLE T_ORDER_LINE (
  ORDER_ID      NUMBER NOT NULL REFERENCES T_ORDER(ORDER_ID),
  LINE_NO       NUMBER NOT NULL,
  PROD_SK       NUMBER NOT NULL REFERENCES D_PRODUCT(PROD_SK),
  QTY           NUMBER NOT NULL CHECK (QTY > 0),
  AMOUNT        NUMBER(12,2) NOT NULL CHECK (AMOUNT >= 0),
  PRIMARY KEY (ORDER_ID, LINE_NO)
);

-- 외래키 인덱스: 부모 테이블 DML 작업 시 자식 테이블의 잠금 경합 방지
CREATE INDEX IX_OL_FK_ORDER ON T_ORDER_LINE(ORDER_ID);
CREATE INDEX IX_OL_FK_PROD ON T_ORDER_LINE(PROD_SK);
```

이 모델의 설계 철학은 다음과 같습니다:
1. **내부/외부 식별자 분리**: 대리키(SK)는 내부 조인과 인덱싱을 최적화하고, 자연키(BK)는 외부 시스템과의 통합을 보장합니다.
2. **사용 패턴에 따른 저장 전략**: 자주 조회되는 분석 데이터는 파티셔닝하고, 트랜잭션 데이터는 정규화하여 무결성을 유지합니다.
3. **제약 조건의 적극적 활용**: 데이터 무결성을 보장하면서도 옵티마이저의 카디널리티 추정을 돕습니다.

## 키 설계 전략: 자연키, 대리키, 그리고 합성키의 균형

### 각 키 유형의 특징과 적절한 사용 시기

| 키 유형 | 장점 | 단점 | 권장 사용처 |
|---------|------|------|------------|
| **자연키(BK)** | 비즈니스 의미 명확, 외부 시스템과의 일관성 유지 | 변경 가능성, 길이가 길 수 있음, 복합키일 경우 관리 복잡 | 외부 시스템과의 통합 인터페이스, 데이터 교환 |
| **대리키(SK)** | 짧고 간단, 변경되지 않음, 조인 성능 우수 | 비즈니스 의미가 없음 | 내부 조인, 파티셔닝, 인덱스 키 |
| **합성키** | 복합 비즈니스 규칙을 정확히 표현 | 관리 복잡, 조인 성능 저하 가능 | 도메인 제약이 복합적인 경우 |

### 실무 권장 패턴: 이중 키 시스템

```sql
-- 차원 테이블에서의 이중 키 구현
CREATE TABLE D_PRODUCT (
  PROD_SK NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  -- 대리키
  PROD_BK VARCHAR2(30) NOT NULL,                            -- 자연키
  -- ... 다른 컬럼들
  CONSTRAINT UK_D_PRODUCT_BK UNIQUE(PROD_BK)                -- 자연키 유니크
);

-- 조인 시 대리키 사용으로 성능 최적화
SELECT f.*, p.CATEGORY
FROM F_SALES f
JOIN D_PRODUCT p ON p.PROD_SK = f.PROD_SK;  -- 짧은 숫자 키로 효율적 조인
```

이 패턴의 핵심 이점은 다음과 같습니다:
- **성능**: 짧은 숫자형 키는 인덱스 효율과 조인 성능을 극대화합니다.
- **안정성**: 비즈니스 키가 변경되더라도 내부 참조 무결성은 유지됩니다.
- **유연성**: 외부 시스템과의 통합 시 자연키를 사용할 수 있습니다.

## 데이터 타입과 도메인 설계의 중요성

### 암묵적 형변환의 위험과 방지

가장 흔한 설계 실수 중 하나는 숫자 데이터를 문자열로 저장하는 것입니다. 이는 성능과 정확성 모두에 심각한 영향을 미칩니다.

```sql
-- 문제 있는 설계: 숫자를 문자열로 저장
CREATE TABLE T_PRODUCT (
  PRODUCT_CODE VARCHAR2(20) PRIMARY KEY,  -- '1001', '1002' 형식
  PRICE        VARCHAR2(20)               -- '15000' 형식
);

-- 문제 발생: 암묵적 형변환으로 인덱스 사용 불가
SELECT * FROM T_PRODUCT WHERE PRODUCT_CODE = 1001;  -- 인덱스 미사용

-- 올바른 설계: 적절한 데이터 타입 사용
CREATE TABLE T_PRODUCT (
  PRODUCT_ID   NUMBER PRIMARY KEY,        -- 숫자형 대리키
  PRODUCT_CODE VARCHAR2(20) NOT NULL UNIQUE, -- 자연키지만 문자열
  PRICE        NUMBER(12,2) NOT NULL      -- 숫자형 가격
);

-- 효율적인 쿼리: 타입 일치로 인덱스 사용
SELECT * FROM T_PRODUCT WHERE PRODUCT_ID = 1001;    -- 인덱스 사용
SELECT * FROM T_PRODUCT WHERE PRODUCT_CODE = '1001'; -- 인덱스 사용
```

### 날짜/시간 데이터 처리의 모범 사례

```sql
-- 올바른 날짜 처리
CREATE TABLE T_ORDER (
  ORDER_ID     NUMBER PRIMARY KEY,
  ORDER_DATE   DATE NOT NULL,                    -- 날짜만 필요할 때
  ORDER_TS     TIMESTAMP(6) WITH LOCAL TIME ZONE, -- 정밀한 시간대 정보 필요시
  DUE_DATE     DATE,
  CONSTRAINT CHK_DUE_DATE CHECK (DUE_DATE >= ORDER_DATE)
);

-- 효율적인 날짜 범위 검색
SELECT * FROM T_ORDER 
WHERE ORDER_DATE >= DATE '2024-01-01' 
  AND ORDER_DATE < DATE '2024-02-01';  -- 인덱스 효율적 사용
```

## 정규화와 비정규화의 현명한 균형

### 정규화의 원칙과 비정규화의 전략적 적용

정규화는 데이터 무결성과 중복 최소화를 보장하지만, 과도한 정규화는 조인 복잡성과 성능 저하를 초래할 수 있습니다.

```sql
-- 비정규화의 전략적 적용 예시
-- 상황: 카테고리 정보가 거의 모든 판매 분석 쿼리에서 사용됨

-- 원본 (완전 정규화)
SELECT s.SALES_ID, p.CATEGORY, s.AMOUNT
FROM F_SALES s
JOIN D_PRODUCT p ON p.PROD_SK = s.PROD_SK
WHERE p.CATEGORY = 'ELECTRONICS';

-- 비정규화 적용 후
ALTER TABLE F_SALES ADD (
  CATEGORY VARCHAR2(20)  -- 차원 테이블의 CATEGORY 중복 저장
);

-- 로딩 프로세스에서 값 채우기
UPDATE F_SALES s
SET CATEGORY = (SELECT p.CATEGORY FROM D_PRODUCT p WHERE p.PROD_SK = s.PROD_SK)
WHERE CATEGORY IS NULL;

-- 개선된 쿼리
SELECT SALES_ID, CATEGORY, AMOUNT
FROM F_SALES
WHERE CATEGORY = 'ELECTRONICS';  -- 조인 불필요, 성능 향상
```

비정규화 결정을 위한 체크리스트:
- [ ] 해당 컬럼이 대부분의 쿼리에서 조인되어 사용되는가?
- [ ] 컬럼 값이 자주 변경되지 않는가?
- [ ] 저장 공간 증가가 시스템에 부담이 되지 않는가?
- [ ] 비정규화로 인한 데이터 정합성 유지 메커니즘이 있는가?

## 파티셔닝 전략: 성능과 관리성의 조화

### 파티션 키 선정의 원칙

파티셔닝의 효과는 적절한 파티션 키 선택에 달려 있습니다. 최적의 파티션 키는 다음과 같은 특성을 가집니다:
1. 쿼리에서 자주 필터링 조건으로 사용됨
2. 데이터 분포가 균등함
3. 자연스러운 데이터 보관 주기를 반영함

```sql
-- 월 단위 파티셔닝의 효과적인 예
CREATE TABLE F_SALES (
  SALES_ID NUMBER,
  SALE_DATE DATE NOT NULL,  -- 파티션 키
  -- ... 다른 컬럼들
)
PARTITION BY RANGE (SALE_DATE) (
  PARTITION P202401 VALUES LESS THAN (DATE '2024-02-01'),
  PARTITION P202402 VALUES LESS THAN (DATE '2024-03-01'),
  PARTITION P202403 VALUES LESS THAN (DATE '2024-04-01'),
  PARTITION P_MAX VALUES LESS THAN (MAXVALUE)
);

-- 파티션 프루닝으로 성능 향상
SELECT SUM(AMOUNT) 
FROM F_SALES 
WHERE SALE_DATE BETWEEN DATE '2024-01-01' AND DATE '2024-01-31';
-- P202401 파티션만 스캔
```

### 로컬 vs 글로벌 인덱스 결정 가이드

| 인덱스 유형 | 장점 | 단점 | 적합한 상황 |
|------------|------|------|------------|
| **로컬 인덱스** | 파티션 관리 용이, 프루닝 지원 | 파티션 간 범위 스캔 비효율 | 파티션 키가 검색 조건에 포함되는 경우 |
| **글로벌 인덱스** | 전체 테이블 범위 검색 효율 | 파티션 유지보수 시 재생성 필요 | 파티션 키와 무관한 검색이 빈번한 경우 |

## 시간 이력 데이터 모델링 패턴

### 점 이력 vs 선분 이력

시간 이력 데이터를 모델링할 때는 비즈니스 요구사항에 맞는 패턴을 선택해야 합니다.

```sql
-- 점 이력: 상태 변경 이벤트 기록
CREATE TABLE CUSTOMER_STATUS_HISTORY (
  CUST_ID NUMBER NOT NULL,
  STATUS VARCHAR2(20) NOT NULL,
  CHANGE_TIMESTAMP TIMESTAMP NOT NULL,
  CHANGED_BY VARCHAR2(50) NOT NULL
);

-- 선분 이력: 시간 구간별 상태 기록
CREATE TABLE CUSTOMER_STATUS_SEGMENT (
  CUST_ID NUMBER NOT NULL,
  STATUS VARCHAR2(20) NOT NULL,
  EFF_START_DATE DATE NOT NULL,
  EFF_END_DATE DATE NOT NULL,
  CURRENT_FLAG CHAR(1) DEFAULT 'N' CHECK (CURRENT_FLAG IN ('Y','N')),
  CONSTRAINT PK_CUST_STATUS PRIMARY KEY (CUST_ID, EFF_START_DATE),
  CONSTRAINT CHK_VALID_INTERVAL CHECK (EFF_START_DATE < EFF_END_DATE)
);

-- 특정 시점의 상태 조회
SELECT * FROM CUSTOMER_STATUS_SEGMENT
WHERE CUST_ID = 1001
  AND DATE '2024-06-15' BETWEEN EFF_START_DATE AND EFF_END_DATE;
```

선분 이력에서 겹침 방지를 위한 트리거 예시:
```sql
CREATE OR REPLACE TRIGGER TRG_NO_OVERLAP_STATUS
BEFORE INSERT ON CUSTOMER_STATUS_SEGMENT
FOR EACH ROW
DECLARE
  overlapping_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO overlapping_count
  FROM CUSTOMER_STATUS_SEGMENT
  WHERE CUST_ID = :NEW.CUST_ID
    AND :NEW.EFF_START_DATE < EFF_END_DATE
    AND :NEW.EFF_END_DATE > EFF_START_DATE;
    
  IF overlapping_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 
      '시간 구간이 기존 레코드와 겹칩니다.');
  END IF;
END;
/
```

## 인덱스 설계의 전략적 접근

### 결합 인덱스 컬럼 순서의 과학

결합 인덱스의 컬럼 순서는 성능에 지대한 영향을 미칩니다. 일반적인 원칙은:
1. **등치 조건**에 사용되는 컬럼을 먼저 위치
2. **범위 조건**에 사용되는 컬럼을 다음에 위치
3. **커버링 인덱스**가 필요한 경우 SELECT 컬럼을 마지막에 포함

```sql
-- 효과적인 결합 인덱스 예시
CREATE INDEX IX_ORDER_SEARCH ON T_ORDER (
  CUSTOMER_ID,        -- 등치 조건으로 자주 사용
  ORDER_DATE DESC,    -- 최근 주문 먼저 정렬
  STATUS              -- 추가 필터 조건
);

-- 인덱스를 완전히 활용하는 쿼리
SELECT ORDER_ID, ORDER_DATE, STATUS
FROM T_ORDER
WHERE CUSTOMER_ID = 1001          -- 선두 컬럼 등치 조건
  AND ORDER_DATE >= DATE '2024-01-01'  -- 두번째 컬럼 범위 조건
  AND STATUS = 'SHIPPED'          -- 마지막 컬럼 등치 조건
ORDER BY ORDER_DATE DESC;         -- 인덱스 정렬 순서 활용
```

## 고급 기능의 전략적 활용

### 가상 컬럼과 함수기반 인덱스

```sql
-- 비즈니스 규칙을 적용한 가상 컬럼
ALTER TABLE F_SALES ADD (
  TAX_AMOUNT GENERATED ALWAYS AS (
    CASE 
      WHEN CATEGORY = 'LUXURY' THEN ROUND(AMOUNT * 0.2, 2)
      WHEN CATEGORY = 'STANDARD' THEN ROUND(AMOUNT * 0.1, 2)
      ELSE 0
    END
  ) VIRTUAL,
  
  NET_AMOUNT GENERATED ALWAYS AS (
    AMOUNT - CASE 
      WHEN CATEGORY = 'LUXURY' THEN ROUND(AMOUNT * 0.2, 2)
      WHEN CATEGORY = 'STANDARD' THEN ROUND(AMOUNT * 0.1, 2)
      ELSE 0
    END
  ) VIRTUAL
);

-- 가상 컬럼에 대한 함수기반 인덱스
CREATE INDEX IX_SALES_TAX_AMOUNT ON F_SALES(TAX_AMOUNT);
CREATE INDEX IX_SALES_NET_AMOUNT ON F_SALES(NET_AMOUNT);

-- 효율적인 검색
SELECT * FROM F_SALES
WHERE TAX_AMOUNT > 1000;  -- 인덱스 사용 가능
```

### Materialized View를 통한 성능 최적화

```sql
-- 자주 사용되는 집계 쿼리를 위한 Materialized View
CREATE MATERIALIZED VIEW MV_SALES_SUMMARY
REFRESH COMPLETE ON DEMAND
ENABLE QUERY REWRITE
AS
SELECT 
  TRUNC(s.SALE_DATE, 'MM') AS MONTH,
  p.CATEGORY,
  c.REGION,
  COUNT(*) AS TRANSACTION_COUNT,
  SUM(s.AMOUNT) AS TOTAL_AMOUNT,
  AVG(s.AMOUNT) AS AVG_AMOUNT
FROM F_SALES s
JOIN D_PRODUCT p ON p.PROD_SK = s.PROD_SK
JOIN D_CUSTOMER c ON c.CUST_SK = s.CUST_SK
GROUP BY TRUNC(s.SALE_DATE, 'MM'), p.CATEGORY, c.REGION;

-- 원본 쿼리와 동일하지만 MV를 사용하는 쿼리
SELECT MONTH, CATEGORY, SUM(TOTAL_AMOUNT)
FROM MV_SALES_SUMMARY
WHERE REGION = 'ASIA'
GROUP BY MONTH, CATEGORY;
-- 옵티마이저가 자동으로 MV로 리라이트
```

## RAC 환경을 고려한 동시성 설계

### 시퀀스와 핫블록 문제 해결

```sql
-- RAC 친화적인 시퀀스 설계
CREATE SEQUENCE SEQ_ORDER_ID
START WITH 1
INCREMENT BY 1
CACHE 1000              -- 캐시로 인한 핫블록 감소
NOORDER                 -- 정렬 불필요로 성능 향상
NOCYCLE;

-- 시퀀스 캐시 크기 최적화을 위한 모니터링
SELECT sequence_name, cache_size, highwater
FROM v$_sequences
WHERE sequence_owner = USER;
```

### Reverse Key 인덱스를 통한 핫블록 분산

```sql
-- 단조 증가 PK의 핫블록 문제 해결
CREATE TABLE T_ORDER (
  ORDER_ID NUMBER PRIMARY KEY,
  -- ... 다른 컬럼들
)
ORGANIZATION INDEX;

-- Reverse Key 인덱스 적용
CREATE INDEX PK_ORDER_REVERSE ON T_ORDER(ORDER_ID) REVERSE;

-- INSERT 분산 효과
-- ORDER_ID: 1001 → 1001 (Reverse: 1001)
-- ORDER_ID: 1002 → 2001 (Reverse: 1002)
-- ORDER_ID: 1003 → 3001 (Reverse: 1003)
-- 다른 리프 블록에 분산 저장
```

## 데이터 품질과 감사 기능

### 포괄적인 감사 추적 시스템

```sql
-- 모든 테이블에 적용할 감사 컬럼
ALTER TABLE T_ORDER ADD (
  CREATED_BY      VARCHAR2(50) DEFAULT USER NOT NULL,
  CREATED_TS      TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
  MODIFIED_BY     VARCHAR2(50),
  MODIFIED_TS     TIMESTAMP,
  VERSION_NUMBER  NUMBER DEFAULT 1 NOT NULL
);

-- 변경 이력을 위한 히스토리 테이블
CREATE TABLE T_ORDER_HISTORY (
  HIST_ID        NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  ORDER_ID       NUMBER NOT NULL,
  COLUMN_NAME    VARCHAR2(30) NOT NULL,
  OLD_VALUE      VARCHAR2(4000),
  NEW_VALUE      VARCHAR2(4000),
  CHANGE_TYPE    VARCHAR2(10) CHECK (CHANGE_TYPE IN ('INSERT','UPDATE','DELETE')),
  CHANGED_BY     VARCHAR2(50) NOT NULL,
  CHANGED_TS     TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL
);

-- 변경 추적 트리거
CREATE OR REPLACE TRIGGER TRG_ORDER_AUDIT
AFTER INSERT OR UPDATE OR DELETE ON T_ORDER
FOR EACH ROW
DECLARE
  v_change_type VARCHAR2(10);
BEGIN
  IF INSERTING THEN
    v_change_type := 'INSERT';
    -- 히스토리 테이블에 전체 레코드 저장
    INSERT INTO T_ORDER_HISTORY(ORDER_ID, COLUMN_NAME, NEW_VALUE, CHANGE_TYPE, CHANGED_BY)
    VALUES (:NEW.ORDER_ID, 'FULL_RECORD', 
            TO_CLOB(:NEW.ORDER_ID || '|' || :NEW.CUSTOMER_ID || '|' || :NEW.ORDER_DATE),
            v_change_type, USER);
  ELSIF UPDATING THEN
    v_change_type := 'UPDATE';
    -- 변경된 컬럼만 히스토리 저장
    IF :OLD.STATUS != :NEW.STATUS THEN
      INSERT INTO T_ORDER_HISTORY(ORDER_ID, COLUMN_NAME, OLD_VALUE, NEW_VALUE, CHANGE_TYPE, CHANGED_BY)
      VALUES (:NEW.ORDER_ID, 'STATUS', :OLD.STATUS, :NEW.STATUS, v_change_type, USER);
    END IF;
    -- 다른 컬럼 변경에 대해 반복...
  ELSIF DELETING THEN
    v_change_type := 'DELETE';
    INSERT INTO T_ORDER_HISTORY(ORDER_ID, COLUMN_NAME, OLD_VALUE, CHANGE_TYPE, CHANGED_BY)
    VALUES (:OLD.ORDER_ID, 'FULL_RECORD', 
            TO_CLOB(:OLD.ORDER_ID || '|' || :OLD.CUSTOMER_ID || '|' || :OLD.ORDER_DATE),
            v_change_type, USER);
  END IF;
END;
/
```

## 성능 검증 방법론

### 데이터 모델 변경의 효과 측정

```sql
-- 변경 전 성능 기준선 측정
SET AUTOTRACE TRACEONLY STATISTICS;

-- 대표적인 쿼리 실행
SELECT /*+ BASELINE_QUERY */ 
       p.CATEGORY, c.REGION, SUM(s.AMOUNT) as TOTAL_SALES
FROM F_SALES s
JOIN D_PRODUCT p ON p.PROD_SK = s.PROD_SK
JOIN D_CUSTOMER c ON c.CUST_SK = s.CUST_SK
WHERE s.SALE_DATE BETWEEN DATE '2024-01-01' AND DATE '2024-03-31'
GROUP BY p.CATEGORY, c.REGION
ORDER BY TOTAL_SALES DESC;

-- 통계 정보 캡처
SELECT 
  'BASELINE' as PHASE,
  sn.name as STAT_NAME,
  ms.value as STAT_VALUE
FROM v$mystat ms
JOIN v$statname sn ON sn.stat# = ms.stat#
WHERE sn.name IN (
  'consistent gets',     -- 논리적 읽기
  'physical reads',      -- 물리적 읽기
  'sorts (memory)',      -- 메모리 정렬
  'sorts (disk)',        -- 디스크 정렬
  'parse time elapsed'   -- 파싱 시간
);

-- 변경 후 동일 쿼리 실행 및 통계 비교
```

## 실전 시나리오: 안티패턴 리팩토링

### 일반적인 안티패턴과 개선 방안

**안티패턴 1: 제네릭 EAV(Entity-Attribute-Value) 모델**
```sql
-- 문제: 유연성은 높지만 성능과 무결성이 낮음
CREATE TABLE GENERIC_ENTITY (
  ENTITY_ID NUMBER,
  ATTRIBUTE_NAME VARCHAR2(100),
  ATTRIBUTE_VALUE VARCHAR2(4000)
);

-- 개선: JSON 타입 활용 (Oracle 21c 이상)
CREATE TABLE PRODUCT_ATTRIBUTES (
  PRODUCT_ID NUMBER PRIMARY KEY,
  ATTRIBUTES JSON,
  -- 가상 컬럼으로 자주 검색되는 속성 추출
  WEIGHT NUMBER GENERATED ALWAYS AS (
    JSON_VALUE(ATTRIBUTES, '$.weight' RETURNING NUMBER)
  ) VIRTUAL,
  DIMENSIONS VARCHAR2(100) GENERATED ALWAYS AS (
    JSON_VALUE(ATTRIBUTES, '$.dimensions')
  ) VIRTUAL
);

-- 가상 컬럼에 인덱스 생성
CREATE INDEX IX_PRODUCT_WEIGHT ON PRODUCT_ATTRIBUTES(WEIGHT);
```

**안티패턴 2: 날짜를 문자열로 저장**
```sql
-- 문제 있는 설계
CREATE TABLE EVENTS (
  EVENT_ID NUMBER,
  EVENT_DATE VARCHAR2(10)  -- '2024-01-15' 형식
);

-- 개선된 설계
CREATE TABLE EVENTS (
  EVENT_ID NUMBER,
  EVENT_DATE DATE,          -- DATE 타입 사용
  EVENT_DATE_STR VARCHAR2(10) GENERATED ALWAYS AS (
    TO_CHAR(EVENT_DATE, 'YYYY-MM-DD')
  ) VIRTUAL  -- 문자열 표현이 필요할 경우 가상 컬럼
);

-- 효율적인 범위 검색
SELECT * FROM EVENTS
WHERE EVENT_DATE BETWEEN DATE '2024-01-01' AND DATE '2024-01-31';
```

## 종합적 설계 원칙과 마무리

효과적인 데이터 모델링은 기술적 정확성과 비즈니스 요구사항 사이의 균형을 찾는 과정입니다. 다음 원칙들을 염두에 두어 설계를 진행하시기 바랍니다:

### 핵심 설계 원칙 요약

1. **목적에 맞는 키 전략**: 대리키와 자연키의 이중 시스템으로 내부 효율성과 외부 통합성을 동시에 확보하세요.

2. **적절한 데이터 타입 선택**: 성능 문제의 상당수가 잘못된 데이터 타입 선택에서 비롯됩니다. 숫자는 NUMBER, 날짜는 DATE/TIMESTAMP를 사용하세요.

3. **정규화와 비정규화의 지혜로운 균형**: 데이터 무결성을 유지하면서도 빈번한 조회 패턴을 최적화하세요. 비정규화는 측정 가능한 성능 이점이 있을 때만 적용하세요.

4. **파티셔닝의 전략적 활용**: 데이터 볼륨이 크고 접근 패턴이 예측 가능한 경우 파티셔닝으로 관리성과 성능을 동시에 개선하세요.

5. **인덱스 설계의 과학적 접근**: 실제 쿼리 패턴을 분석하여 결합 인덱스의 컬럼 순서를 결정하세요. 선두 컬럼은 등치 조건으로 가장 자주 사용되는 컬럼이어야 합니다.

6. **시간 차원의 명확한 모델링**: 비즈니스 요구에 따라 점 이력과 선분 이력을 적절히 선택하세요. 시간 기반 조회가 빈번한 경우 선분 이력이 유리할 수 있습니다.

7. **고급 기능의 전략적 활용**: 가상 컬럼, 함수기반 인덱스, Materialized View 등 Oracle의 고급 기능을 이해하고 적절히 활용하세요.

8. **동시성과 확장성 고려**: RAC 환경이나 높은 동시성 환경을 대비하여 시퀀스 캐싱, Reverse Key 인덱스 등을 고려하세요.

9. **데이터 품질과 감사의 내재화**: 감사 추적, 변경 이력, 데이터 검증을 데이터 모델의 일부로 설계하세요.

10. **지속적인 검증과 개선**: 데이터 모델은 정적이지 않습니다. 성능 측정, 사용자 피드백, 비즈니스 변화에 따라 지속적으로 개선하세요.

### 최종 조언: 단순함의 힘

가장 효과적인 데이터 모델은 종종 가장 단순한 모델입니다. 불필요한 복잡성을 추가하기 전에, 현재의 간단한 설계로 비즈니스 요구사항을 충족할 수 있는지 항상 질문하세요. 복잡성은 정당화된 비즈니스 가치가 있을 때만 도입하세요.

데이터 모델링은 예술과 과학의 조화입니다. 기술적 원칙을 따르면서도 비즈니스 맥락을 이해하는 것이 진정한 전문가의 길입니다. 이 가이드가 제시하는 원칙들과 패턴들은 출발점일 뿐, 각 조직의 고유한 요구사항에 맞게 적응하고 발전시켜 나가시기 바랍니다.