---
layout: post
title: DB 심화 - 데이터 모델 측면에서의 검토
date: 2025-11-21 21:25:23 +0900
category: DB 심화
---
# 데이터 모델 측면에서의 검토

> **목표**
> - OLTP/분석 혼합 환경에서 **성능·확장성·정합성**을 동시에 만족하는 **데이터 모델링 체크리스트** 제공
> - **정규화 vs 비정규화**, **키 전략(자연/대리/합성)**, **NULL·도메인 제약**, **파티셔닝/인덱스/스토리지 옵션**,
>   **시간 이력(점/선분 이력, SCD)**, **FK/삭제/잠금**, **RAC·시퀀스·핫블록**, **가상 컬럼·함수기반 인덱스**,
>   **MV(실체화 뷰)/요약 테이블**, **품질·모니터링**까지 ‘모델’ 레벨에서 점검

---

## 0) 공통 예제 스키마 (리테일 미니 스타 스키마 + 트랜잭션)

- **사실 테이블** `F_SALES` (매출)
- **차원 테이블** `D_PRODUCT`, `D_CUSTOMER`, `D_DATE`
- **거래 테이블(OLTP)** `T_ORDER`, `T_ORDER_LINE`

```sql
-- 차원
CREATE TABLE D_PRODUCT (
  PROD_SK       NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,        -- 대리키
  PROD_BK       VARCHAR2(30) NOT NULL,                                  -- 자연키(외부 코드)
  CATEGORY      VARCHAR2(20) NOT NULL,
  BRAND         VARCHAR2(20) NOT NULL,
  CONSTRAINT UK_D_PRODUCT_BK UNIQUE(PROD_BK)                             -- 자연키 유니크
);

CREATE TABLE D_CUSTOMER (
  CUST_SK       NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  CUST_BK       VARCHAR2(30) NOT NULL,
  REGION        VARCHAR2(10) NOT NULL,
  TIER          VARCHAR2(10) NOT NULL,
  CONSTRAINT UK_D_CUSTOMER_BK UNIQUE(CUST_BK)
);

CREATE TABLE D_DATE (
  DT            DATE PRIMARY KEY,                                        -- 날짜 자체를 PK로
  YYYYMM        NUMBER(6) NOT NULL,
  DOW           NUMBER(1) NOT NULL,
  IS_WEEKEND    CHAR(1)  NOT NULL CHECK (IS_WEEKEND IN ('Y','N'))
);

-- 사실: 파티션(월 단위), 로컬 인덱스
CREATE TABLE F_SALES (
  SALES_ID      NUMBER PRIMARY KEY,
  DT            DATE        NOT NULL,
  PROD_SK       NUMBER      NOT NULL REFERENCES D_PRODUCT(PROD_SK),
  CUST_SK       NUMBER      NOT NULL REFERENCES D_CUSTOMER(CUST_SK),
  QTY           NUMBER      NOT NULL CHECK (QTY > 0),
  AMOUNT        NUMBER(12,2) NOT NULL CHECK (AMOUNT >= 0),
  -- 가상 컬럼(단가)
  UNIT_PRICE    GENERATED ALWAYS AS (CASE WHEN QTY > 0 THEN AMOUNT / QTY END) VIRTUAL
)
PARTITION BY RANGE (DT) (
  PARTITION P202501 VALUES LESS THAN (DATE '2025-02-01'),
  PARTITION P202502 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION PMAX    VALUES LESS THAN (MAXVALUE)
);

CREATE INDEX IX_FS_PROD_DT      ON F_SALES (PROD_SK, DT) LOCAL;
CREATE INDEX IX_FS_CUST_DT      ON F_SALES (CUST_SK, DT)  LOCAL;
CREATE INDEX IX_FS_DT_AMOUNT    ON F_SALES (DT, AMOUNT)   LOCAL;

-- 트랜잭션(OLTP)
CREATE TABLE T_ORDER (
  ORDER_ID      NUMBER PRIMARY KEY,
  CUST_SK       NUMBER NOT NULL REFERENCES D_CUSTOMER(CUST_SK),
  ORDER_TS      TIMESTAMP(6) WITH LOCAL TIME ZONE NOT NULL,
  STATUS        VARCHAR2(12) NOT NULL CHECK (STATUS IN ('NEW','PAID','CANCEL','SHIPPED')),
  -- 소프트 삭제 플래그
  IS_DELETED    CHAR(1) DEFAULT 'N' CHECK (IS_DELETED IN ('Y','N'))
);

CREATE TABLE T_ORDER_LINE (
  ORDER_ID      NUMBER NOT NULL REFERENCES T_ORDER(ORDER_ID),
  LINE_NO       NUMBER NOT NULL,
  PROD_SK       NUMBER NOT NULL REFERENCES D_PRODUCT(PROD_SK),
  QTY           NUMBER NOT NULL CHECK (QTY > 0),
  AMOUNT        NUMBER(12,2) NOT NULL CHECK (AMOUNT >= 0),
  PRIMARY KEY (ORDER_ID, LINE_NO)
);

-- FK 컬럼 인덱스(삭제·업데이트 트랜잭션 잠금 경합 방지)
CREATE INDEX IX_OL_FK_ORDER ON T_ORDER_LINE(ORDER_ID);
CREATE INDEX IX_OL_FK_PROD  ON T_ORDER_LINE(PROD_SK);
```

> **포인트**
> - **대리키(SK)** + **자연키(BK)** 병행: 로딩/조인 안정성과 외부 시스템 정합성 유지
> - **파티션 키=자주 필터링하는 컬럼**(DT): **프루닝**과 **로컬 인덱스 관리성** 확보
> - **FK 인덱스 필수**: 부모 삭제/상태변경 시 **TM/ROW 잠금 경합** 방지
> - **CHECK/NOT NULL/UNIQUE** 등 **제약의 적극적 사용**: 정합성 + 옵티마이저 추론(카디널리티) 도움
> - **가상 컬럼 + 함수기반 인덱스**(필요 시): 일관된 계산·필터 성능

---

## 1) 키(식별자) 설계: 자연키 vs 대리키 vs 합성키
### 선택 기준

- **자연키(BK)**: 외부 교환/식별 의미가 강함. 변경 가능성·길이·복합성(다필드) 위험이 있다.
- **대리키(SK)**: 내부 조인·파티션·인덱스 효율, **짧고 단일 숫자 값** 선호.
- **합성키**: 특정 도메인에서 유일성이 **복합 컬럼**으로만 표현될 때(예: `(BK, EFF_START)`).

**권장 패턴**:
- 차원/마스터: **SK(숫자) PK + BK 유니크 제약**
- 사실/자세: **숫자형 PK**(시퀀스·ID) 또는 **비즈니스상 자연 합성키** + 대리키 병행(필요 시)

```sql
-- 자연키 유니크 + 대리키 PK
ALTER TABLE D_PRODUCT ADD CONSTRAINT UK_D_PRODUCT_BK UNIQUE(PROD_BK);
```

**장점**
- **조인 키가 짧아** NL/해시 조인 시 CPU/메모리 압박 ↓
- **통계/히스토그램** 관리가 쉬움(숫자 컬럼)
- **변경 안전성**: BK 변경 시 SK 유지

---

## 2) 도메인·NULL·형 선택 (암묵 변환/카디널리티 위험 제거)
### 숫자를 `VARCHAR2`로 저장하지 말 것

- **암묵 형변환** + 인덱스 무력화 위험
- **카디널리티 추정 오류** 발생 빈번

```sql
-- 안티 패턴
-- WHERE PROD_BK = 10   -- PROD_BK가 VARCHAR2면 암묵변환 발생

-- 개선
-- WHERE PROD_BK = '10' -- 타입 일치
```

### 날짜/시간: `DATE`/`TIMESTAMP WITH LOCAL TIME ZONE`

- 문자열 비교·형변환 대신 **바인드** + **범위 조건**
```sql
WHERE ORDER_TS >= :from_ts AND ORDER_TS < :to_ts
```

### NULL 정책

- **미확정/없음**은 NULL, **의미 있는 0/공백**과 구분
- **필수 조인 키**는 **NOT NULL** + FK로 **Join Elimination/카디널리티** 개선
- **조건부 유니크**가 필요하면 **함수기반 유니크 인덱스** 활용
```sql
-- 소프트 삭제가 'N'일 때만 유니크 강제
CREATE UNIQUE INDEX UX_T_ORDER_UNDUP
ON T_ORDER (CASE WHEN IS_DELETED = 'N' THEN ORDER_ID END);
```

---

## 3) 정규화 vs 비정규화: 읽기/쓰기 패턴 기반 선택
### 원칙

- **OLTP**: 3정규형 중심(중복 최소, 쓰기·정합성 유리)
- **DW/리포팅**: 스타/스노우플레이크(조인 단순화·스캔 효율)
- **하이브리드**: 읽기 집중 컬럼 일부 **비정규화**(성능·단순성) + 트리거나 배치로 동기화

### 비정규화 판단 체크

- **상수에 가까운 조인**이 항상 발생? → 차원 속성 일부 **사실 테이블에 캐시**(예: `CATEGORY`)
- **정렬/그룹 빈발 키**를 사실에 중복 보관하면 소트 제거/인덱스 활용 여지 ↑
- 단, **변경 파급**·**이중 진실**(single source of truth 붕괴) 위험 관리 필요.

```sql
-- 사실에 카테고리 캐시(선택)
ALTER TABLE F_SALES ADD (CATEGORY VARCHAR2(20));
-- 로딩 파이프라인에서 D_PRODUCT와 조인해 채움
```

---

## 4) 파티셔닝 전략: 프루닝·관리성·조인 효율
### 키 선택

- **가장 흔한 필터/보관주기 기준** → `DT` RANGE 파티션
- **대규모 차원**은 LIST/HASH, **사실**은 RANGE-HASH **서브파티션** 고려
- **참조 파티셔닝**: 자식(사실)을 **부모 차원** 파티션에 정렬(관리/조인 유리)

```sql
-- 참조 파티셔닝 예(간단 개념)
-- F_SALES (child) 가 D_DATE(DT) 또는 D_PRODUCT(PROD_SK) 기준과 정렬될 수 있는 모델
```

### 로컬 vs 글로벌 인덱스

- **로컬 인덱스**: 관리성·프루닝 친화적, 파티션 독립 리빌드
- **글로벌 인덱스**: 전 범위 질의 최적(크로스 파티션), 파티션 유지보수 시 인덱스 영향 고려

### 파티션 와이즈 조인(PWJ)

- 양쪽 테이블이 **동일 키/방식으로 코파티션**되면 **로컬 병렬** + **재분배 최소화**
- 모델 단계에서 조인 키와 파티션 키의 **일관성**을 설계

---

## 5) 인덱스 전략: 컬럼 순서·길이·선택도·핫블록
### 결합 인덱스 순서

- **선행 컬럼**: 선택도 높고 **자주 필터**되는 컬럼
- 정렬 제거 목적이면 **ORDER BY 순서/방향 일치**
```sql
-- 정렬 제거
CREATE INDEX IX_FS_DT_AMT_DESC ON F_SALES(DT, AMOUNT DESC) LOCAL;
```

### FK 인덱스(필수)

- 부모 삭제/상태 변경 시 자식 테이블 **ROW SHARE/EXCLUSIVE 잠금 경합** 방지

### Monotonic PK + 핫블록(RAC)

- 단조 증가 PK(시퀀스) + **B*Tree 인덱스** → **루트 끝단 핫블록**
- 완화: **REVERSE KEY** 인덱스 또는 **해시 파티션 인덱스**, **스케일러블/캐시 시퀀스** 사용

```sql
-- Reverse Key 예(범위 스캔은 불리하니 액세스 패턴 고려)
CREATE INDEX PK_T_ORDER_REV ON T_ORDER(ORDER_ID) REVERSE;
```

---

## 6) 시간 이력 모델: 점/선분, SCD, 중복/겹침 방지
### 점(스냅샷) vs 선분(유효기간)

- **점 이력**: 이벤트/스냅샷(ORDER_TS)
- **선분 이력**: `EFF_START`, `EFF_END`(열린/닫힌 구간) + **겹침 금지**

```sql
-- SCD Type 2 (선분 이력) 예
CREATE TABLE D_CUSTOMER_SCD2 (
  CUST_SK    NUMBER NOT NULL,
  CUST_BK    VARCHAR2(30) NOT NULL,
  REGION     VARCHAR2(10) NOT NULL,
  TIER       VARCHAR2(10) NOT NULL,
  EFF_START  DATE NOT NULL,
  EFF_END    DATE NOT NULL,
  CURRENT_FL CHAR(1) NOT NULL CHECK (CURRENT_FL IN ('Y','N')),
  CONSTRAINT PK_D_CUST_SCD2 PRIMARY KEY (CUST_SK, EFF_START),
  CONSTRAINT UK_D_CUST_BK_INTERVAL UNIQUE (CUST_BK, EFF_START) DEFERRABLE INITIALLY DEFERRED
);

-- 선분 겹침 방지(오라클에 '배타 제약' 없으므로 트리거/프로시저로 검증)
```

**조회(시점 일관성)**
```sql
-- 기준일자에 유효한 고객 속성
SELECT /*+ INDEX(dc uk_d_cust_bk_interval) */
       dc.*
FROM   D_CUSTOMER_SCD2 dc
WHERE  dc.CUST_BK = :bk
AND    :asof_date >= dc.EFF_START
AND    :asof_date <  dc.EFF_END;
```

**선분 조인 패턴(성능 주의)**
- `(A.start < B.end) AND (B.start < A.end)` 형태의 **선분 교집합**
- 인덱스: `(BK, EFF_START)` 또는 `(BK, EFF_END)` + **필터 재작성**으로 범위 축소
- **비정규화(스냅샷/사전전개)** 도 고려(보고서 요구가 고정적일 때)

---

## 7) 소프트 삭제/상태머신/부분 유니크

- **소프트 삭제**: `IS_DELETED` + **함수기반 유니크**로 ‘살아있는 행’만 유니크 보장
- **상태머신**: 허용 전이만 저장하는 **상태 전이 테이블** 또는 **체크 제약**
- **부분 인덱스 대용**: 함수기반 인덱스로 조건부 인덱싱

```sql
-- 상태머신 전이(간단)
CREATE TABLE T_ORDER_STATE (
  FROM_STATUS  VARCHAR2(12),
  TO_STATUS    VARCHAR2(12),
  CONSTRAINT UK_STATE UNIQUE(FROM_STATUS, TO_STATUS)
);

-- 전이 검증(트리거 샘플)
CREATE OR REPLACE TRIGGER TR_ORDER_STATUS
BEFORE UPDATE OF STATUS ON T_ORDER
FOR EACH ROW
DECLARE
  v_cnt INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_cnt
  FROM T_ORDER_STATE
  WHERE FROM_STATUS = :OLD.STATUS AND TO_STATUS = :NEW.STATUS;
  IF v_cnt = 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Invalid state transition');
  END IF;
END;
/
```

---

## 8) 가상 컬럼/함수기반 인덱스(FBI): SARGABLE 보장

- **비즈니스 계산**을 **단일 정의**(가상 컬럼)로 표준화
- **FBI**로 `WHERE` 절의 가공을 인덱스에 반영

```sql
-- 가상 컬럼(단가) + FBI
ALTER TABLE F_SALES ADD UNIT_PRICE_V GENERATED ALWAYS AS (ROUND(AMOUNT / NULLIF(QTY,0), 2)) VIRTUAL;
CREATE INDEX IX_FS_UNIT_PRICE ON F_SALES(UNIT_PRICE_V);

-- 질의
SELECT *
FROM F_SALES
WHERE UNIT_PRICE_V BETWEEN 1000 AND 2000;  -- 인덱스 사용 가능
```

---

## 9) 요약 테이블·MV(실체화 뷰)·Query Rewrite

- 리포팅/대시보드 **응답 시간 단축**
- **사실 테이블 대용량 GROUP BY**를 **사전 집계**
- **FAST REFRESH**를 위해 **MV 로그** 준비

```sql
-- MV 로그
CREATE MATERIALIZED VIEW LOG ON F_SALES WITH ROWID, SEQUENCE (DT, PROD_SK, CUST_SK, QTY, AMOUNT) INCLUDING NEW VALUES;

-- 일별·상품별 요약 MV
CREATE MATERIALIZED VIEW MV_SALES_D_PROD
BUILD IMMEDIATE
REFRESH FAST ON COMMIT
ENABLE QUERY REWRITE
AS
SELECT DT, PROD_SK, SUM(QTY) QTY, SUM(AMOUNT) AMT
FROM   F_SALES
GROUP  BY DT, PROD_SK;
```

> **모델 설계 시 고려**
> - 집계 그레인(일/주/월)과 키 일치
> - 파티션 매핑(REFRESH·DROP/EXCHANGE 편의)
> - `ENABLE QUERY REWRITE`로 **애플리케이션 SQL 무변경** 가속

---

## 10) 스토리지·세그먼트 옵션: PCTFREE/압축/행 체이닝

- **PCTFREE**: 업데이트로 컬럼 길이가 늘어나는 테이블은 **여유 공간↑**(체이닝·마이그레이션 방지)
- **압축**:
  - **OLTP 압축**: 쓰기 영향 최소화 + 읽기 I/O 절감
  - **HCC**(컬럼너 저장) 계열: 아카이브/리포트 스캔에 유리(엔진·스토리지 요구사항 확인)
- **컬럼 순서**: 유사 값 인접 → 압축 효율 ↑
- **행 폭 큰 테이블**: **열 쪼개기(수평/수직 분할)** 고려

```sql
-- OLTP 압축 예(엔터프라이즈 옵션)
ALTER TABLE F_SALES MOVE COMPRESS FOR OLTP;
ALTER INDEX IX_FS_PROD_DT REBUILD;
```

---

## 11) 통계·히스토그램과 모델

- **선택도 높은 컬럼**: 히스토그램 수집 → 카디널리티 정확화
- **FK NOT NULL/UNIQUE**: 옵티마이저 CBQT/Join Elimination 도움
- **샘플링**: 파티션/대규모 테이블은 **파티션 통계** + **글로벌 통계** 전략

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'D_PRODUCT',
    method_opt => 'FOR COLUMNS SIZE AUTO CATEGORY, BRAND');
END;
/
```

---

## 12) 시퀀스/ID·병렬·RAC·핫스팟

- **시퀀스**: `CACHE` 활성, **노오더(NOORDER)**로 분산, **스케일러블 시퀀스**(인스턴스별 고비트) 고려
- **단조 증가 PK** 인덱스 핫스팟 회피: **REVERSE KEY**, **해시 파티션 인덱스**, **랜덤화된 키** 전략
- **배치 삽입**: **APPEND 병렬**은 세그먼트 하이워터 부근 경합 감소(OLTP와 분리 스케줄)

```sql
CREATE SEQUENCE SEQ_ORDER CACHE 1000 NOORDER;
```

---

## 13) 데이터 품질·제약·감사

- **CHECK/유니크/FK**는 성능 비용이 아닌 **비용 대비 이득**(오류 예방 + 옵티마이저 도움)
- **DEFERRED 제약**: 로딩 시 완화, 커밋 시 검증
- **감사**: 변경 이력 테이블, **감사 컬럼**(CREATED_TS/USER, UPDATED_TS/USER) 표준화

```sql
ALTER TABLE T_ORDER ADD (
  CREATED_TS TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  CREATED_BY VARCHAR2(64) DEFAULT SYS_CONTEXT('USERENV','SESSION_USER') NOT NULL,
  UPDATED_TS TIMESTAMP(6),
  UPDATED_BY VARCHAR2(64)
);
```

---

## 14) 안티패턴 → 리팩터링 예시

### 안티패턴(요약)

- 숫자를 문자열로 저장, 날짜도 문자열 → **암묵 변환 + 인덱스 미사용**
- FK 미인덱스 → **삭제/갱신 시 대기 이벤트**
- 단조 증가 PK + B*Tree → **핫블록**
- 파티션 키 부적합(드문 필터) → **프루닝 부재**
- 선분 이력 겹침 허용 → **리포팅 오류**

### 리팩터링 스텝(샘플)

1) 컬럼 타입 정정(숫자/날짜) + **CHECK/NOT NULL/UNIQUE** 추가
2) FK 인덱스 생성
3) 파티션 키 재선정(월 단위 DT) + 로컬 인덱스
4) PK 인덱스 **REVERSE** 또는 **해시 파티션**
5) 선분 이력에 **검증 프로시저** 적용

---

## 15) 모델이 성능에 미치는 **정량적 확인** (실행계획/통계)

```sql
-- 1) 후보 질의
SELECT /* top 100 by amount in Feb 2025 */
       s.SALES_ID, s.PROD_SK, s.AMOUNT
FROM   F_SALES s
WHERE  s.DT >= DATE '2025-02-01'
AND    s.DT <  DATE '2025-03-01'
ORDER  BY s.AMOUNT DESC
FETCH  FIRST 100 ROWS ONLY;

-- 2) 인덱스/파티션 모델 전/후 비교
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +NOTE'));

-- 3) 세션 통계 델타(정렬·TEMP·PGA)
WITH base AS (
  SELECT sn.name, ms.value
  FROM v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
  WHERE sn.name IN ('session logical reads','physical reads','sorts (memory)','sorts (disk)',
                    'workarea executions - onepass','workarea executions - multipass')
)
SELECT * FROM base;  -- 실행 전 캡처 → 실행 후 재조회하여 차이 비교
```

---

## 16) 체크리스트 (데이터 모델 관점)

### 스키마/키

- [ ] 차원/마스터는 **SK 숫자 PK + BK 유니크**
- [ ] 사실은 **프루닝 친화 파티션 키** 채용
- [ ] FK는 **NOT NULL**(가능시) + **인덱스** 확보

### 타입/도메인

- [ ] 숫자/날짜/시간은 **적절한 타입** 사용(문자 금지)
- [ ] 도메인 값은 **CHECK/참조 테이블**로 강제
- [ ] NULL 정책: **미확정/결측**은 NULL, 조건부 유니크는 **함수기반 유니크**

### 파티셔닝/인덱스

- [ ] RANGE/LIST/HASH/서브파티션 조합 → **프루닝 최대화**
- [ ] 로컬 인덱스 기본, 글로벌은 요구 쿼리에 한정
- [ ] 결합 인덱스 선두는 **선택도 높고 자주 쓰는 필터/정렬 컬럼**

### 시간 이력

- [ ] 점/선분 요구 구분, **겹침 방지 로직** 존재
- [ ] 리포팅 고정 요구는 **요약/MV/스냅샷** 설계

### RAC/동시성

- [ ] 단조 증가 PK 핫블록 완화(Reverse/해시/스케일러블 시퀀스)
- [ ] FK 인덱스 필수(부모 DML 경합 방지)

### 스토리지/품질

- [ ] PCTFREE/압축 정책 적합
- [ ] 생성/수정 사용자/시간 컬럼 표준화
- [ ] 통계 수집 전략(히스토그램 포함) 테이블별 선호값 정의

---

## 17) 실전 Q&A(짧게)

**Q. 차원 테이블에 자연키만 PK로 쓰면 뭐가 문제?**
A. 길고 변경 위험이 크며 조인·인덱스 비용↑. **대리키 SK**가 조인/파티셔닝에 유리.

**Q. 소프트 삭제 행만 유니크 보장하고 싶다**
A. **함수기반 유니크 인덱스**: `CREATE UNIQUE INDEX ... ON (CASE WHEN IS_DELETED='N' THEN BK END)`.

**Q. 시퀀스 INSERT가 RAC에서 핫스팟을 만든다**
A. **REVERSE KEY**, **해시 파티션 인덱스**, **스케일러블 시퀀스**, **캐시** 옵션 조합.

**Q. 선분 이력 겹침 방지는 어떻게?**
A. 트리거/프로시저로 `(start < other_end) AND (other_start < end)` 위반 검출, 또는 로딩 파이프라인에서 **단일 라이너라이즈**.

---

### 맺음말

데이터 모델은 **튜닝의 출발점**이다.
- 키·도메인·제약·파티션·인덱스·시간 이력·RAC 동시성·스토리지 **결정**이 곧 **실행계획**을 좌우한다.
- “쿼리 튜닝” 전에 **모델**을 점검하고, **측정 가능한**(PLAN/통계) 개선을 설계하라.
- **간단하고 일관된 규칙**(SK+BK, FK 인덱스, 프루닝 키, SARGABLE, 함수기반 인덱스, MV)만 지켜도 시스템은 놀랍게 안정적이고 빠르다.
