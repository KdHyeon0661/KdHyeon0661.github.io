---
layout: post
title: C# - 컬렉션
date: 2024-10-18 19:20:23 +0900
category: Csharp
---
# C# 컬렉션 클래스 총정리 (List, Dictionary, Queue, Stack, HashSet 등)

## 컬렉션의 큰 그림 이해하기

C#의 컬렉션 시스템은 다양한 데이터 구조적 요구사항을 충족하기 위해 설계된 풍부한 라이브러리입니다. `System.Collections.Generic` 네임스페이스에서 제공되는 제네릭 컬렉션들은 타입 안전성과 성능을 동시에 보장하며, 각각 고유한 특성과 최적의 사용 시나리오를 가지고 있습니다. 컬렉션 선택은 단순히 데이터를 저장하는 것을 넘어 애플리케이션의 성능, 확장성, 유지보수성에 직접적인 영향을 미치는 중요한 설계 결정입니다.

---

## List<T> - 동적 배열의 구현

`List<T>`는 가장 일반적으로 사용되는 컬렉션으로, 가변 크기의 배열을 제공합니다. 인덱스를 통한 빠른 접근이 필요한 시나리오에서 이상적입니다.

```csharp
var inventory = new List<Product>();
inventory.Add(new Product("Laptop", 1200));
inventory.Add(new Product("Mouse", 25));
inventory.RemoveAt(0); // 첫 번째 항목 제거

// 인덱서를 통한 직접 접근
var firstItem = inventory[0];
```

### 내부 동작과 성능 특성

`List<T>`는 내부적으로 배열을 사용하며, 용량(capacity)과 실제 요소 수(count)를 별도로 관리합니다. 요소 추가 시 용량을 초과하면 더 큰 배열로 재할당이 발생합니다:

```csharp
// 초기 용량 설정으로 재할당 최소화
var largeList = new List<int>(capacity: 10000);
for (int i = 0; i < 10000; i++)
{
    largeList.Add(i); // 재할당 없이 효율적으로 추가
}
```

- **인덱스 접근**: O(1) - 배열 기반이므로 즉시 접근 가능
- **끝에 추가**: 평균 O(1) - 재할당 시 O(n)
- **중간 삽입/삭제**: O(n) - 요소 이동 필요
- **검색**: `Contains()`는 O(n), `BinarySearch()`는 O(log n) (정렬된 상태에서)

### 실제 활용 팁

```csharp
// 효율적인 필터링: RemoveAll 사용
var numbers = new List<int> { 1, 2, 3, 4, 5, 6 };
numbers.RemoveAll(n => n % 2 == 0); // 짝수 제거

// 정렬 사용자 정의
var people = new List<Person>();
people.Sort((p1, p2) => p1.Age.CompareTo(p2.Age));

// 메모리 최적화: 불필요한 용량 제거
numbers.TrimExcess();
```

---

## Dictionary<TKey, TValue> - 키-값 매핑의 표준

해시 테이블을 기반으로 하는 `Dictionary<TKey, TValue>`는 키를 통한 빠른 조회가 필요할 때 선택해야 할 컬렉션입니다.

```csharp
var employeeDirectory = new Dictionary<int, Employee>();
employeeDirectory[101] = new Employee("Alice", "Engineering");
employeeDirectory[102] = new Employee("Bob", "Marketing");

// 안전한 조회 패턴
if (employeeDirectory.TryGetValue(103, out var employee))
{
    Console.WriteLine(employee.Name);
}
else
{
    Console.WriteLine("직원을 찾을 수 없습니다.");
}
```

### 키 동등성과 해시 코드

`Dictionary`의 성능은 키 타입의 `GetHashCode()`와 `Equals()` 구현에 크게 의존합니다:

```csharp
public class ProductId : IEquatable<ProductId>
{
    public int Id { get; }
    
    public ProductId(int id) => Id = id;
    
    public override bool Equals(object? obj) => 
        obj is ProductId other && Equals(other);
    
    public bool Equals(ProductId? other) => 
        other != null && Id == other.Id;
    
    public override int GetHashCode() => Id.GetHashCode();
}

// 커스텀 비교자 사용
var caseInsensitiveDict = new Dictionary<string, int>(
    StringComparer.OrdinalIgnoreCase
);
```

### 성능 특성

- 평균 조회/삽입/삭제: O(1)
- 해시 충돌이 심할 경우: 최악 O(n)
- 메모리 오버헤드: 해시 테이블 구조로 인한 추가 메모리 사용

### 고급 활용

```csharp
// 값이 없는 경우 기본값 반환
var value = employeeDirectory.GetValueOrDefault(999, defaultValue);

// 업데이트와 추가를 한 번에
employeeDirectory.AddOrUpdate(
    101,
    key => new Employee("Charlie", "Sales"), // 추가 시
    (key, existing) => existing with { Department = "HR" } // 업데이트 시
);
```

---

## HashSet<T> - 고유한 요소의 집합

중복을 허용하지 않는 요소 집합이 필요할 때 `HashSet<T>`를 사용합니다. 집합 연산(교집합, 합집합, 차집합)을 내장 지원합니다.

```csharp
var uniqueTags = new HashSet<string>();
uniqueTags.Add("C#");
uniqueTags.Add(".NET");
uniqueTags.Add("C#"); // 중복 추가 시 무시됨

Console.WriteLine(uniqueTags.Count); // 2
```

### 집합 연산의 수학적 표현

```csharp
var developers = new HashSet<string> { "Alice", "Bob", "Charlie" };
var designers = new HashSet<string> { "Bob", "Diana", "Eve" };

// 합집합: A ∪ B
var allTeamMembers = new HashSet<string>(developers);
allTeamMembers.UnionWith(designers);

// 교집합: A ∩ B
var bothRoles = new HashSet<string>(developers);
bothRoles.IntersectWith(designers); // {"Bob"}

// 차집합: A \ B
var onlyDevelopers = new HashSet<string>(developers);
onlyDevelopers.ExceptWith(designers); // {"Alice", "Charlie"}

// 대칭차: (A ∪ B) \ (A ∩ B)
var exclusiveRoles = new HashSet<string>(developers);
exclusiveRoles.SymmetricExceptWith(designers);
```

### 성능 고려사항

- 요소 추가/삭제/검색: 평균 O(1)
- 순서 보장하지 않음 (순서가 필요하면 `SortedSet<T>` 사용)
- 메모리 사용: 해시 테이블 기반이므로 `List<T>`보다 오버헤드 큼

---

## Queue<T>와 Stack<T> - 선입선출 vs 후입선출

### Queue<T> - 선입선출(FIFO)

작업 대기열, 메시지 처리, BFS(너비 우선 탐색) 등에 사용됩니다:

```csharp
var printQueue = new Queue<PrintJob>();
printQueue.Enqueue(new PrintJob("Report.pdf"));
printQueue.Enqueue(new PrintJob("Invoice.docx"));

while (printQueue.Count > 0)
{
    var job = printQueue.Dequeue();
    ProcessPrintJob(job);
}
```

### Stack<T> - 후입선출(LIFO)

실행 취소(Undo), DFS(깊이 우선 탐색), 표현식 평가 등에 사용됩니다:

```csharp
var navigationHistory = new Stack<string>();
navigationHistory.Push("Home");
navigationHistory.Push("Products");
navigationHistory.Push("Product Details");

// 뒤로 가기 구현
var currentPage = navigationHistory.Pop(); // "Product Details"로 이동
```

---

## 정렬된 컬렉션 - 순서 보장이 필요할 때

### SortedDictionary<TKey, TValue>

레드-블랙 트리를 사용하여 키 순서를 유지하는 딕셔너리입니다:

```csharp
var scoreboard = new SortedDictionary<int, string>();
scoreboard[1500] = "Alice";
scoreboard[1700] = "Bob";
scoreboard[1600] = "Charlie";

// 키 순서대로 자동 정렬
foreach (var kvp in scoreboard)
{
    Console.WriteLine($"{kvp.Key}: {kvp.Value}");
}
// 출력: 1500: Alice, 1600: Charlie, 1700: Bob
```

### SortedSet<T>

정렬된 상태를 유지하는 집합입니다:

```csharp
var sortedNumbers = new SortedSet<int> { 5, 1, 9, 3, 7 };
// 항상 정렬된 상태 유지: {1, 3, 5, 7, 9}

// 범위 기반 조회
var middleRange = sortedNumbers.GetViewBetween(3, 7); // {3, 5, 7}
```

**성능 특성**: 삽입/삭제/검색 모두 O(log n)

---

## LinkedList<T> - 연결 리스트 구현

중간 삽입/삭제가 빈번한 경우에 유용하지만, 인덱스 접근에는 비효율적입니다:

```csharp
var playlist = new LinkedList<Song>();
var firstSong = playlist.AddFirst(new Song("Song A"));
var lastSong = playlist.AddLast(new Song("Song B"));
var middleSong = playlist.AddAfter(firstSong, new Song("Song C"));

// 노드 직접 조작 가능
playlist.Remove(middleSong);
```

---

## 동시성 컬렉션 - 멀티스레드 환경에서의 안전

`System.Collections.Concurrent` 네임스페이스의 컬렉션들은 스레드 안전성을 내장하고 있습니다:

### ConcurrentDictionary<TKey, TValue>

```csharp
var concurrentCache = new ConcurrentDictionary<string, object>();

// 원자적 연산
var value = concurrentCache.GetOrAdd("key", key => ExpensiveComputation(key));

// 업데이트
concurrentCache.AddOrUpdate("key", 
    key => new object(),
    (key, existing) => UpdatedValue(existing)
);
```

### ConcurrentQueue<T>와 ConcurrentStack<T>

```csharp
var taskQueue = new ConcurrentQueue<Action>();

// 생산자
Parallel.For(0, 100, i => taskQueue.Enqueue(() => ProcessTask(i)));

// 소비자
List<Task> tasks = new();
while (taskQueue.TryDequeue(out var action))
{
    tasks.Add(Task.Run(action));
}
Task.WaitAll(tasks.ToArray());
```

### BlockingCollection<T> - 생산자-소비자 패턴

```csharp
var buffer = new BlockingCollection<int>(boundedCapacity: 10);

// 생산자
Task.Run(() =>
{
    for (int i = 0; i < 100; i++)
    {
        buffer.Add(i);
        Thread.Sleep(10);
    }
    buffer.CompleteAdding();
});

// 소비자
foreach (var item in buffer.GetConsumingEnumerable())
{
    Process(item);
}
```

---

## 불변 컬렉션 - 함수형 접근 방식

`System.Collections.Immutable` 패키지는 구조적 공유를 통해 메모리 효율적인 불변 컬렉션을 제공합니다:

```csharp
using System.Collections.Immutable;

var initialConfig = ImmutableDictionary<string, string>.Empty
    .Add("Theme", "Dark")
    .Add("Language", "en-US");

// 기존 컬렉션을 변경하지 않고 새 컬렉션 생성
var updatedConfig = initialConfig.SetItem("Theme", "Light");

// 두 컬렉션 공유 가능
Console.WriteLine(initialConfig["Theme"]); // "Dark"
Console.WriteLine(updatedConfig["Theme"]); // "Light"
```

**장점**: 스레드 안전, 예측 가능한 상태, 스냅샷 기능
**단점**: 단일 연산 비용이 가변 컬렉션보다 높을 수 있음

---

## 6️⃣ 컬렉션 차이: 핵심 비교

### ✅ List<T> vs IEnumerable<T>

`List<T>`는 구체적인 컬렉션 타입이고, `IEnumerable<T>`는 모든 컬렉션이 구현하는 인터페이스입니다. 이 둘의 차이는 **메서드 반환 타입 선택**에서 중요해집니다.

**핵심 차이**:
- **List<T>** : 즉시 실행, 메모리에 전체 데이터 로드, 인덱스 접근 가능, 수정 가능
- **IEnumerable<T>** : 지연 실행(LINQ), 데이터를 순회할 때마다 다시 평가될 수 있음, 읽기 전용, 인덱스 접근 불가

**반환 타입 선택 가이드**:
```csharp
// ✅ 내부 구현을 숨기고 싶다면 IEnumerable<T> 반환
public IEnumerable<Product> GetActiveProducts()
{
    return _productList.Where(p => p.IsActive); // 지연 실행
}

// ✅ 호출자가 인덱스 접근이나 수정이 필요하면 List<T> 반환
public List<Product> GetProductsForEditing()
{
    return _productList.ToList(); // 즉시 실행, 복사본
}
```

**성능 주의**: `IEnumerable<T>`를 여러 번 순회하면 쿼리가 여러 번 실행될 수 있습니다.
```csharp
var query = GetActiveProducts(); // LINQ 쿼리, 아직 실행 안 됨
var count = query.Count();       // 첫 번째 실행
var first = query.First();       // 두 번째 실행 (다시 DB 조회)
```

---

### ✅ IQueryable<T>

`IQueryable<T>`는 주로 ORM(Entity Framework 등)에서 사용되며, **데이터베이스와 같은 외부 데이터 소스에 대한 쿼리**를 표현합니다.

**IEnumerable<T>와의 차이**:
- **IEnumerable<T>** : 메모리 내 객체에 대한 LINQ (LINQ to Objects)
- **IQueryable<T>** : 외부 소스에 대한 LINQ, 표현식 트리(Expression Tree)를 구성하여 실제 실행 시점에 최적화된 SQL 등으로 변환

```csharp
using (var context = new AppDbContext())
{
    // IQueryable: 아직 DB에 쿼리 안 함
    IQueryable<Customer> query = context.Customers
        .Where(c => c.City == "Seoul")
        .OrderBy(c => c.Name);
    
    // 이 시점에 SQL 생성 및 실행
    List<Customer> result = query.ToList();
}
```

**주의사항**:
- `IQueryable`은 데이터 소스의 표현식을 그대로 유지하므로, 외부 소스에서 지원하지 않는 메서드를 호출하면 런타임 오류가 발생할 수 있습니다.
- `IQueryable`을 `IEnumerable`로 변환하면(`AsEnumerable()`) 이후의 LINQ 연산은 메모리에서 수행됩니다.

---

### ✅ Dictionary<TKey, TValue> – 이미 충분히 설명됨

핵심 요약: 해시 테이블 기반, 키를 통한 O(1) 조회, 중복 키 불가, 순서 없음.

---

### ✅ HashSet<T> – 이미 충분히 설명됨

핵심 요약: 고유 요소 집합, 중복 자동 제거, 집합 연산(합집합, 교집합 등) 지원, O(1) 검색.

---

### 📊 컬렉션 선택 한눈에 보기

| 컬렉션 | 내부 구조 | 접근 속도 | 순서 유지 | 중복 허용 | 키/값 |
|--------|-----------|-----------|-----------|-----------|--------|
| `List<T>` | 동적 배열 | 인덱스 O(1) | 삽입 순서 | 예 | 인덱스 |
| `Dictionary<TKey,TValue>` | 해시 테이블 | 키 O(1) | 없음 | 키 불가, 값 가능 | 키 |
| `HashSet<T>` | 해시 테이블 | 요소 O(1) | 없음 | 불가 | - |
| `SortedSet<T>` | 레드-블랙 트리 | O(log n) | 정렬됨 | 불가 | - |
| `Queue<T>` | 배열 기반 FIFO | 앞/뒤 O(1) | 삽입 순서 | 예 | - |
| `Stack<T>` | 배열 기반 LIFO | 위/아래 O(1) | 삽입 역순 | 예 | - |
| `LinkedList<T>` | 이중 연결 리스트 | 노드 O(1) (접근은 O(n)) | 삽입 순서 | 예 | - |

---

## 컬렉션 선택을 위한 실용적 가이드라인

### 데이터 접근 패턴에 따른 선택

1. **빈번한 인덱스 접근이 필요한가?** → `List<T>`
2. **키를 통한 빠른 조회가 중요한가?** → `Dictionary<TKey, TValue>`
3. **중복을 허용하지 않는 집합이 필요한가?** → `HashSet<T>`
4. **순서가 중요한 집합이 필요한가?** → `SortedSet<T>`
5. **정렬된 키-값 쌍이 필요한가?** → `SortedDictionary<TKey, TValue>`
6. **FIFO 처리 큐가 필요한가?** → `Queue<T>`
7. **LIFO 스택이 필요한가?** → `Stack<T>`
8. **멀티스레드 환경인가?** → `Concurrent*` 컬렉션
9. **불변성이 필요한가?** → `Immutable*` 컬렉션
10. **데이터베이스 쿼리를 표현해야 하는가?** → `IQueryable<T>`
11. **내부 구현을 숨기고 최소한의 인터페이스만 노출하려면?** → `IEnumerable<T>` 반환

### 성능 최적화를 위한 체크리스트

- **용량 예측 가능**: `List<T>`와 `Dictionary<TKey, TValue>`는 생성 시 초기 용량을 지정
- **문자열 키 처리**: `StringComparer.Ordinal` 또는 `StringComparer.OrdinalIgnoreCase` 사용
- **값 타입의 박싱 방지**: 제네릭 컬렉션 사용으로 박싱 최소화
- **대량 데이터 처리**: LINQ의 지연 실행과 즉시 실행 차이 이해
- **메모리 관리**: `TrimExcess()`로 불필요한 용량 회수
- **여러 번 순회**: `IEnumerable<T>`를 여러 번 순회해야 한다면 `ToList()`로 한 번만 실행

### 흔한 실수와 해결책

```csharp
// ❌ 잘못된 사용: foreach 중 수정
foreach (var item in list)
{
    if (ShouldRemove(item))
        list.Remove(item); // InvalidOperationException 발생
}

// ✅ 올바른 사용: 역순으로 처리
for (int i = list.Count - 1; i >= 0; i--)
{
    if (ShouldRemove(list[i]))
        list.RemoveAt(i);
}

// ✅ 올바른 사용: RemoveAll 사용
list.RemoveAll(ShouldRemove);
```

---

## 실제 시나리오 적용 예제

### 웹 API 요청 로깅 시스템

```csharp
public class RequestLogger
{
    // 최근 요청을 시간 순서대로 저장 (FIFO)
    private readonly Queue<RequestLog> _recentRequests = new();
    
    // 엔드포인트별 통계 저장
    private readonly Dictionary<string, EndpointStats> _endpointStats = new();
    
    // 고유 사용자 세션 추적
    private readonly HashSet<string> _activeSessions = new();
    
    // 요청 처리 시간을 정렬된 상태로 유지 (상위 N개 조회용)
    private readonly SortedSet<RequestDuration> _slowestRequests = new();
    
    public void LogRequest(HttpRequest request)
    {
        var log = new RequestLog(request);
        
        // 최근 요청 큐 관리 (최대 1000개 유지)
        _recentRequests.Enqueue(log);
        if (_recentRequests.Count > 1000)
            _recentRequests.Dequeue();
        
        // 엔드포인트 통계 업데이트
        var endpoint = request.Path;
        if (!_endpointStats.TryGetValue(endpoint, out var stats))
        {
            stats = new EndpointStats();
            _endpointStats[endpoint] = stats;
        }
        stats.LogRequest(log.Duration);
        
        // 느린 요청 추적 (상위 10개만 유지)
        var duration = new RequestDuration(endpoint, log.Duration);
        _slowestRequests.Add(duration);
        if (_slowestRequests.Count > 10)
            _slowestRequests.Remove(_slowestRequests.Min);
        
        // 활성 세션 추적
        if (!string.IsNullOrEmpty(log.SessionId))
            _activeSessions.Add(log.SessionId);
    }
    
    public RequestAnalysis GetAnalysis()
    {
        return new RequestAnalysis
        {
            RecentRequests = _recentRequests.ToList(),
            EndpointStats = _endpointStats.ToDictionary(kvp => kvp.Key, kvp => kvp.Value),
            ActiveSessionCount = _activeSessions.Count,
            SlowestEndpoints = _slowestRequests.Take(5).ToList()
        };
    }
}
```

---

## 결론

C# 컬렉션 클래스들은 각각 고유한 특성과 최적의 사용 사례를 가지고 있습니다. 올바른 컬렉션 선택은 애플리케이션의 성능, 메모리 사용 효율성, 코드 가독성에 직접적인 영향을 미칩니다.

핵심 원칙은 다음과 같습니다:
1. **데이터 접근 패턴을 먼저 분석하라**: 조회, 삽입, 삭제의 빈도와 패턴을 이해해야 적절한 컬렉션을 선택할 수 있습니다.
2. **성능 특성을 이해하라**: 시간 복잡도뿐만 아니라 메모리 지역성, 캐시 효율성, 할당 비용도 고려해야 합니다.
3. **스레드 안전성을 고려하라**: 단일 스레드 환경에서는 표준 컬렉션을, 동시성 환경에서는 `Concurrent*` 컬렉션을 사용하세요.
4. **불변성의 가치를 인식하라**: 함수형 스타일이나 스냅샷 기능이 필요하다면 불변 컬렉션을 고려하세요.
5. **LINQ와의 통합을 활용하라**: 컬렉션은 LINQ와 자연스럽게 통합되지만, 성능이 중요한 부분에서는 적절한 컬렉션 메서드를 직접 사용하세요.
6. **반환 타입을 신중히 선택하라**: `IEnumerable<T>`와 `IQueryable<T>`의 차이를 이해하고, 호출자의 필요에 따라 적절한 타입을 반환하세요.

최종적으로, 컬렉션 선택은 데이터의 본질과 애플리케이션의 요구사항을 깊이 이해한 후에 이루어져야 합니다. 올바른 컬렉션 선택은 단순한 코딩 기술을 넘어 시스템 설계의 핵심 요소입니다. 각 컬렉션의 내부 동작 방식을 이해하고, 실제 사용 패턴에 맞춰 선택할 때 비로소 최적의 성능과 유지보수성을 달성할 수 있습니다.