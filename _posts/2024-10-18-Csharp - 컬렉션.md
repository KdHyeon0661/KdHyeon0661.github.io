---
layout: post
title: C# - 컬렉션
date: 2024-10-18 19:20:23 +0900
category: Csharp
---
# C# 컬렉션 클래스 총정리 (List, Dictionary, Queue, Stack, HashSet 등)

## 큰 그림

- 대부분의 제네릭 컬렉션은 **`System.Collections.Generic`**에 있습니다.
- 공통 인터페이스: `IEnumerable<T>` → `ICollection<T>` → `IList<T>`/`IDictionary<K,V>`/`ISet<T>`.
- 선택 기준 요약:

| 필요사항 | 추천 |
|---|---|
| 인덱스 기반, 가변 길이, 빈번한 추가/읽기 | `List<T>` |
| 키→값 빠른 조회 | `Dictionary<K,V>` |
| 집합 연산(중복X) | `HashSet<T>` |
| FIFO 작업 대기열 | `Queue<T>` |
| LIFO 되돌리기/히스토리 | `Stack<T>` |
| 정렬 유지(키/집합) | `SortedDictionary<K,V>`, `SortedSet<T>` |
| 다중 쓰레드 안전 큐/맵 | `ConcurrentQueue<T>`, `ConcurrentDictionary<K,V>` |
| 스냅샷·참조 공유에 안전한 불변 | `System.Collections.Immutable` 계열 |

---

## List<T> — 가변 길이 배열

```csharp
using System;
using System.Collections.Generic;

var fruits = new List<string>();
fruits.Add("Apple");
fruits.Add("Banana");
fruits.Remove("Apple");
Console.WriteLine(fruits[0]); // Banana
```

### 핵심 메서드/속성

- `Add`, `AddRange`, `Insert`, `Remove`, `RemoveAt`, `RemoveAll(Predicate<T>)`
- `Contains`, `IndexOf`, `BinarySearch`(정렬 전제)
- `Sort(Comparison<T> / IComparer<T>)`, `Reverse()`
- `Capacity`, `TrimExcess()`

### 성능 메모(대략)

- 인덱스 접근: **O(1)**
- 끝에 `Add`: **평균 O(1)** (리사이즈 시 **O(n)**)
- 중간 `Insert/RemoveAt`: **O(n)** (시프트 비용)

### 팁

```csharp
var list = new List<int>(capacity: 10_000); // 예상 크기 지정 → 재할당 줄임
list.TrimExcess(); // 최종 확정 후 메모리 회수
```

---

## Dictionary<TKey, TValue> — 해시 기반 맵

```csharp
var scores = new Dictionary<string, int>();
scores["Alice"] = 90;
scores["Bob"] = 85;

if (scores.TryGetValue("Alice", out var a))
    Console.WriteLine(a); // 90
```

### 핵심 포인트

- 키 중복 불가, 값 중복 가능
- `ContainsKey`, `TryGetValue`, `Remove`, `GetValueOrDefault`
- **커스텀 비교자**로 키 동치/해시 규칙 변경 가능

```csharp
var ci = StringComparer.OrdinalIgnoreCase;
var dict = new Dictionary<string, int>(ci);
dict["ID"] = 1;
Console.WriteLine(dict.ContainsKey("id")); // True
```

### 성능

- 평균 조회/삽입/삭제: **O(1)**, 해시 충돌 시 **O(n)**까지 악화 가능
- 키 타입은 **`GetHashCode/Equals`**가 잘 정의되어야 함
  (`string`은 기본적으로 우수, 사용자 정의 타입은 `IEquatable<T>` 권장)

---

## Queue<T> — FIFO

```csharp
var q = new Queue<string>();
q.Enqueue("First");
q.Enqueue("Second");
Console.WriteLine(q.Dequeue()); // First
Console.WriteLine(q.Peek());    // Second
```

- 작업 대기열, 버퍼링, 생산자→소비자 패턴에 적합
- 복수 스레드 환경에서는 `ConcurrentQueue<T>` 고려

---

## Stack<T> — LIFO

```csharp
var st = new Stack<int>();
st.Push(10);
st.Push(20);
Console.WriteLine(st.Pop());  // 20
Console.WriteLine(st.Peek()); // 10
```

- 되돌리기(Undo), DFS, 백트래킹 등에 활용

---

## HashSet<T> — 중복 없는 집합

```csharp
var set = new HashSet<int> { 1, 2, 1 }; // {1,2}
Console.WriteLine(set.Contains(2)); // True

var a = new HashSet<int> { 1,2,3 };
var b = new HashSet<int> { 3,4 };
a.IntersectWith(b); // a={3}
```

### 집합 연산(수학적 관점)

- 합집합: `A.UnionWith(B)` → $$A \leftarrow A \cup B$$
- 교집합: `A.IntersectWith(B)` → $$A \leftarrow A \cap B$$
- 차집합: `A.ExceptWith(B)` → $$A \leftarrow A \setminus B$$
- 대칭차: `A.SymmetricExceptWith(B)` → $$A \leftarrow (A\cup B)\setminus (A\cap B)$$

> `HashSet<T>`도 키 비교는 `Equals`/`GetHashCode`에 의존. 대소문자 무시 문자열 집합은 `new HashSet<string>(StringComparer.OrdinalIgnoreCase)`.

---

## 컬렉션 반복 — foreach & LINQ

```csharp
foreach (var f in fruits)
    Console.WriteLine(f);

// LINQ: 필터링/투영/정렬
using System.Linq;
var top2 = fruits.Where(x => x.StartsWith("B"))
                 .OrderBy(x => x)
                 .Take(2)
                 .ToList();
```

> **주의**: `foreach` 중 **원본 컬렉션 수정**은 `InvalidOperationException` 발생(일부 타입 제외).

---

## 컬렉션 초기화 문법

```csharp
var colors = new List<string> { "Red", "Green", "Blue" };

var capitals = new Dictionary<string, string>
{
    ["Korea"] = "Seoul",
    ["Japan"] = "Tokyo"
};
```

---

## 정렬 유지 컬렉션

### SortedDictionary<TKey, TValue>

- 내부는 **균형 트리**(레드-블랙 트리)
- 키 정렬 유지, `Comparer<TKey>`로 정렬 규칙 지정

```csharp
var sd = new SortedDictionary<string, int>(StringComparer.Ordinal)
{
    ["b"] = 2, ["a"] = 1, ["c"] = 3
};
foreach (var kv in sd) Console.WriteLine(kv.Key); // a b c
```

### SortedSet<T>

- **정렬된 집합**, 범위/뷰 제공 (`GetViewBetween`)
```csharp
var ss = new SortedSet<int> { 5,1,3,2,4 };
var mid = ss.GetViewBetween(2,4); // {2,3,4}
```

**복잡도**: 탐색/삽입/삭제 **O(log n)**.
**사례**: 정렬된 출력/범위쿼리/순회 최적화가 필요할 때.

---

## LinkedList<T> — 양방향 연결 리스트

```csharp
var ll = new LinkedList<int>();
var n1 = ll.AddLast(1);
var n2 = ll.AddLast(2);
ll.AddAfter(n1, 10); // 1,10,2
ll.Remove(n2);       // 1,10
```

- 노드 참조를 쥐고 **중간 삽입/삭제 O(1)**
- 랜덤 인덱스 접근은 **비효율적**(O(n)) → 인덱스 기반이 필요하면 `List<T>`

---

## 읽기 전용 뷰/인터페이스

- `IReadOnlyList<T>`, `IReadOnlyCollection<T>`, `IReadOnlyDictionary<K,V>`: **읽기 전용 계약**
- `AsReadOnly()`로 **읽기 전용 래퍼** 생성

```csharp
var ro = fruits.AsReadOnly();
// ro[0] 접근 가능, Add/Remove 불가
```

---

## 동시성 컬렉션 (System.Collections.Concurrent)

멀티스레드 환경에서 락 부담을 줄이려면:

- `ConcurrentDictionary<K,V>`
- `ConcurrentQueue<T>` / `ConcurrentStack<T>`
- `ConcurrentBag<T>`(순서 X, 작업 배분에 적합)
- `BlockingCollection<T>`(생산자-소비자 + 완료 신호)

```csharp
using System.Collections.Concurrent;

var q = new ConcurrentQueue<int>();
Parallel.For(0, 100_000, i => q.Enqueue(i));

int sum = 0;
while (q.TryDequeue(out var x)) sum += x;
Console.WriteLine(sum);
```

> **주의**: 동시성 컬렉션도 **복합 연산(찾고→삽입)**은 원자 아님. `GetOrAdd`, `AddOrUpdate` 같은 **원자 API** 사용.

---

## 컬렉션

`System.Collections.Immutable` 패키지(별도 설치)
- `ImmutableList<T>`, `ImmutableDictionary<K,V>`, `ImmutableHashSet<T>` 등
- **구조적 공유**로 큰 컬렉션을 복사 없이 “변경한 새 버전”을 만들 수 있음

```csharp
using System.Collections.Immutable;

var baseList = ImmutableList<int>.Empty.AddRange(new[] {1,2,3});
var v2 = baseList.Add(4);     // baseList는 그대로, v2는 1,2,3,4
```

**장점**: 멀티스레드 안정성↑, 스냅샷/타임머신 패턴 쉬움
**비용**: 단일 업데이트가 가변 컬렉션보다 비쌀 수 있음(대신 공유로 총량 절약)

---

## 커스텀 비교/동치 — `IEqualityComparer<T>`, `IEquatable<T>`

### 값 타입/레코드의 동치 정의

```csharp
public readonly record struct Point(int X, int Y);
// HashSet<Point>에서 좌표 동일이면 중복 처리
```

### 커스텀 비교자 예시

```csharp
class ModComparer : IEqualityComparer<int>
{
    private readonly int _m;
    public ModComparer(int m) => _m = m;
    public bool Equals(int a, int b) => a % _m == b % _m;
    public int GetHashCode(int x) => (x % _m).GetHashCode();
}

var set = new HashSet<int>(new ModComparer(10)) { 1, 11, 21 };
Console.WriteLine(set.Count); // 1
```

---

## 패턴 모음

### 빈번한 조회 → `TryGetValue` 패턴

```csharp
if (!scores.TryGetValue("Alice", out var alice))
{
    // 키 없음: 초기값 삽입
    scores["Alice"] = 0;
}
```

### `ToLookup` vs `GroupBy`

```csharp
var lookup = fruits.ToLookup(f => f.Length); // 즉시 색인화(멀티맵)
foreach (var s in lookup[6]) Console.WriteLine(s);
```

### 멀티맵 구현(간단)

```csharp
var mm = new Dictionary<string, List<int>>();
void Add(string key, int v)
{
    if (!mm.TryGetValue(key, out var list)) mm[key] = list = new();
    list.Add(v);
}
```

---

## 실전 성능 체크리스트

- **예상 크기**가 있다면 `List<T>(capacity)`, `Dictionary<K,V>(capacity)` 미리 할당
- 다량 삭제/삽입이 중간에서 발생 → `LinkedList<T>` 고려(단, 순회 많으면 재평가)
- 키로 문자열 사용 시 **`StringComparer.Ordinal`(또는 IgnoreCase)** 명시
  (기본 CurrentCulture는 의도치 않은 비교/성능 이슈 가능)
- **박싱 방지**: 값 타입 키/값이 인터페이스 경로로 나가지 않게(제네릭 경로 유지)
- **foreach 중 수정 금지**: 필요시 **스냅샷** 혹은 **for 인덱싱** 사용(가능한 타입에서만)

---

## 컬렉션 선택 플로우

1) **키-값?** → `Dictionary` / 정렬 필요 → `SortedDictionary`
2) **중복 제거/집합 연산?** → `HashSet`, 정렬 필요 → `SortedSet`
3) **순서 + 인덱스 접근?** → `List`
4) **FIFO/LIFO?** → `Queue`/`Stack`
5) **동시성?** → `Concurrent*`
6) **스냅샷 안전/함수형 스타일?** → `Immutable*`

---

## 종합 예제 — “로그 인덱서” (키워드→라인번호 멀티맵)

요구:
- 로그 라인에서 키워드를 찾아 **키워드→라인 번호들**을 만든다.
- 대/소문자 구분 없이 저장 (`OrdinalIgnoreCase`), 결과는 **읽기 전용 뷰**로 배포.
- “정확 단어 매칭”과 “부분 문자열 매칭” 모드 지원.

```csharp
using System;
using System.Collections.Generic;

public sealed class LogIndexer
{
    private readonly Dictionary<string, List<int>> _map;

    public LogIndexer() =>
        _map = new Dictionary<string, List<int>>(StringComparer.OrdinalIgnoreCase);

    public void IndexLines(IReadOnlyList<string> lines, IEnumerable<string> keywords, bool wholeWord = true)
    {
        var set = new HashSet<string>(keywords, StringComparer.OrdinalIgnoreCase);
        for (int i = 0; i < lines.Count; i++)
        {
            var line = lines[i];
            foreach (var kw in set)
            {
                if (Match(line, kw, wholeWord))
                {
                    if (!_map.TryGetValue(kw, out var list)) _map[kw] = list = new();
                    list.Add(i + 1); // 1-based line no
                }
            }
        }
    }

    public IReadOnlyDictionary<string, IReadOnlyList<int>> Snapshot()
    {
        var ro = new Dictionary<string, IReadOnlyList<int>>(_map.Comparer);
        foreach (var (k, v) in _map)
            ro[k] = v.AsReadOnly();
        return ro;
    }

    private static bool Match(string line, string kw, bool wholeWord)
    {
        if (!wholeWord) return line.IndexOf(kw, StringComparison.OrdinalIgnoreCase) >= 0;

        // 간단한 단어 경계 체크(알파뉴메릭 기준)
        int idx = line.IndexOf(kw, StringComparison.OrdinalIgnoreCase);
        if (idx < 0) return false;

        bool leftOk  = idx == 0 || !char.IsLetterOrDigit(line[idx - 1]);
        int end      = idx + kw.Length;
        bool rightOk = end == line.Length || !char.IsLetterOrDigit(line[end]);
        return leftOk && rightOk;
    }
}

// 사용 예
var lines = new List<string> {
    "Error: Disk full at node A",
    "Warning: disk temperature high",
    "Info: user login from 10.0.0.1"
};
var idx = new LogIndexer();
idx.IndexLines(lines, new[] { "disk", "user" }, wholeWord: false);

var snap = idx.Snapshot();
foreach (var (k, v) in snap)
    Console.WriteLine($"{k}: [{string.Join(", ", v)}]");
```

**포인트**
- 멀티맵 구현: `Dictionary<string, List<int>>` + `TryGetValue`
- 외부 공개는 **읽기 전용**으로 스냅샷
- 비교 규칙을 `StringComparer`로 명시

---

## FAQ & 함정

- **Q. `Dictionary` 순서는 보장되나요?**
  A. .NET Core 이후 **삽입 순서 유지**가 구현상 유지되지만, **계약상 보장 아님**. 순서가 필요하면 `SortedDictionary` 또는 별도 리스트 유지.
- **Q. `HashSet`의 항목 순서?**
  A. 해시 버킷 순서로 **비결정적**. 순서가 중요하면 `SortedSet`.
- **Q. `List.Remove(item)` vs `RemoveAt(index)`**
  A. 전자는 첫 일치를 찾아 **O(n)**, 후자는 **인덱스로 바로 삭제**(시프트는 O(n)).
- **Q. 큰 값 타입을 `Dictionary`의 값으로 써도 되나요?**
  A. 빈번한 복사/박싱 경로면 비용↑. 필요 시 참조 타입/레코드 클래스로 전환 검토.
- **Q. foreach 중 컬렉션 수정?**
  A. 대부분 타입에서 예외. 필요하면 **수정 목록 별도 저장 후 일괄 적용** 또는 **for 루프** 사용.

---

## 요약 표

| 컬렉션 | 평균 조회 | 삽입 | 삭제 | 특성 |
|---|---:|---:|---:|---|
| `List<T>` | O(1, index) | 끝:O(1*) / 중간:O(n) | 중간:O(n) | 연속 배열, 인덱스 접근 강점 |
| `Dictionary<K,V>` | O(1) | O(1) | O(1) | 키→값 매핑, 비교자/해시 영향 |
| `HashSet<T>` | O(1) | O(1) | O(1) | 중복 제거, 집합 연산 |
| `Queue<T>` | O(1) | Enqueue O(1) | Dequeue O(1) | FIFO |
| `Stack<T>` | O(1) | Push O(1) | Pop O(1) | LIFO |
| `SortedDictionary<K,V>` | O(log n) | O(log n) | O(log n) | 정렬 유지, 범위 순회 |
| `SortedSet<T>` | O(log n) | O(log n) | O(log n) | 정렬 집합, 뷰 제공 |
| `ConcurrentDictionary<K,V>` | ~O(1) | ~O(1) | ~O(1) | 멀티스레드 안전(원자 API) |
| `Immutable*` | 조회 ~O(1)/O(log n) | 새 컬렉션 생성 | 새 컬렉션 생성 | 구조적 공유, 스냅샷에 적합 |

\* `List<T>.Add`는 재할당 없는 한 **평균 O(1)**.

---

## 연습 과제

1) `SortedSet<DateTime>`로 **영업시간 블록**을 유지하고, 특정 시간 범위 `GetViewBetween`으로 캘린더 UI에 바인딩.
2) `ConcurrentDictionary<string,int>`로 API 호출 회수 카운터를 만들고, 초당 top-N 엔드포인트를 `SortedSet`에 투영.
3) `ImmutableDictionary<string, string>`로 설정 스냅샷을 유지하고 핫 리로드 시 **스왑**만 하여 락-프리 읽기 달성.
4) `HashSet<string>`(IgnoreCase) 기반 **금칙어 필터**. 새 규칙은 새 Set로 빌드 후 원자 교체(읽기 락 없음).
5) 사용자 정의 타입을 `Dictionary` 키로 사용하면서 `IEquatable<T>`/`GetHashCode`를 직접 구현하고, 해시 분포 테스트.

---

## 결론

- “**무엇을 최적화할 것인가(조회/삽입/정렬/동시성/스냅샷)**”를 기준으로 컬렉션을 고르세요.
- **비교자/해시/용량/불변성/동시성**을 의식하면, 초기 설계만으로도 **성능과 유지보수성**이 크게 달라집니다.
- LINQ는 강력하지만 **핫패스 누적 할당**에 주의—필요 시 **Span/가변 컬렉션**으로 내려오세요.
