---
layout: post
title: 이산수학 - 카탈란 수, 벨 수, 스털링 수
date: 2025-06-08 23:20:23 +0900
category: 이산수학
---
# 고급 조합 수열: 카탈란 수 / 벨 수 / 스털링 수(2종) 완전 가이드

## 0. 왜 이 셋인가?

- **카탈란 수** \(C_n\): “**교차 없이 쌓이는 구조**”의 표준 답. 괄호열, Dyck 경로, 이진트리, 다각형 삼각분할, non-crossing 분할 등.
- **스털링 수(2종)** \(S(n,k)\): **서로 다른 n개를 정확히 k개의 비어있지 않은 집합**으로 분할.
- **벨 수** \(B_n\): **집합 분할의 총합**. 즉 \(B_n=\sum_{k=0}^n S(n,k)\).

서로 촘촘히 연결되어 있어, **구조적 조합** 문제의 90%를 커버합니다.

---

## 1. 카탈란 수 \(C_n\)

### 1.1 대표 공식(폐형식)

$$
\boxed{C_n=\frac{1}{n+1}\binom{2n}{n}=\binom{2n}{n}-\binom{2n}{n+1}},\quad C_0=1.
$$

- **초기값**: \(1,1,2,5,14,42,132,429,\dots\)

### 1.2 조합적 해석(대표 10선)

1) **올바른 괄호열** 길이 \(2n\).
2) **Dyck 경로**: \((0,0)\to(2n,0)\)에서 위/아래(혹은 우/상) 움직임으로 결코 음수 높이로 내려가지 않는 경로.
3) **이진 트리** 노드 \(n\)개(혹은 간선 \(n\)개) 구조의 수.
4) **\(n\!+\!2\)각형의 삼각분할 수**.
5) **non-crossing 분할**(원 위에 점 \(n\)개, 교차 없이 끈 연결).
6) **Heap-ordered tree** 등 다양한 트리형 구조.
7) **곱셈 괄호 배치 방법** \(n\)개의 항 곱의 괄호 배치.
8) **스택 sortable permutation**(231-패턴 회피) 갯수.
9) **루트가 같은 정점 쌍 나누기** 등 그래프적 해석.
10) **정렬된 BST 삽입 순서의 수**(균형 조건 포함 변형).

### 1.3 핵심 항등식/점화식

- **카탈란 컨볼루션**(이항 컨볼루션과 유사):
  $$
  \boxed{C_{n+1}=\sum_{i=0}^{n} C_i\,C_{n-i}},\quad C_0=1.
  $$
  (괄호열을 첫 블록/나머지로 분할하는 표준적 분해)

- **생성함수(Ordinary GF)** \(C(x)=\sum_{n\ge 0} C_n x^n\):
  $$
  \boxed{C(x)=1+x\,C(x)^2=\frac{1-\sqrt{1-4x}}{2x}}.
  $$

- **비대칭 경로를 막는 반사법**(Ballot/Lattice 방법)에서 폐형식 유도 가능.

- **정교화(나라야나 수)**: 피크 수 \(k\)를 세는 정제(refinement)
  $$
  N(n,k)=\frac{1}{n}\binom{n}{k}\binom{n}{k-1},\quad \sum_{k=1}^{n}N(n,k)=C_n.
  $$

### 1.4 성장률(점근식)

$$
\boxed{C_n \sim \frac{4^n}{n^{3/2}\sqrt{\pi}}}\quad (n\to\infty).
$$

### 1.5 알고리즘

#### (A) DP by 컨볼루션 — \(O(n^2)\)
```python
def catalan_dp(n):
    C = [0]*(n+1)
    C[0] = 1
    for m in range(1, n+1):
        C[m] = sum(C[i]*C[m-1-i] for i in range(m))
    return C[n]
```

#### (B) 이항계수 이용 — \(O(n)\) 곱셈/나눗셈(정확한 정수)
- 안전한 누적곱 방식(매 단계 정수 나눗셈이 되게 구성):
```python
def catalan_binom(n):
    # C_n = (1/(n+1)) * (2n choose n)
    from math import prod
    # (2n choose n) = prod_{i=1..n} (n+i)/i
    num = 1
    den = 1
    for i in range(1, n+1):
        num *= (n+i)
        den *= i
        g = gcd(num, den)
        num //= g; den //= g
    binom = num // den
    return binom // (n+1)

def gcd(a,b):
    while b: a,b = b, a%b
    return a
```

#### (C) 올바른 괄호열 생성(기본 백트래킹)
```python
def generate_parentheses(n):
    res = []
    def dfs(opened, closed, path):
        if opened == n and closed == n:
            res.append("".join(path))
            return
        if opened < n:
            path.append("("); dfs(opened+1, closed, path); path.pop()
        if closed < opened:
            path.append(")"); dfs(opened, closed+1, path); path.pop()
    dfs(0,0,[])
    return res

# 검증: len == C_n
print(len(generate_parentheses(4)))  # 14
```

---

## 2. 스털링 수(제2종) \(S(n,k)\)

### 2.1 정의 & 경계

- **정의**: 서로 다른 \(n\)개를 **정확히 \(k\)개의 비어있지 않은 부분집합**으로 분할하는 경우의 수.
- **경계**:
  $$
  S(0,0)=1,\quad S(n,0)=0\ (n>0),\quad S(0,k)=0\ (k>0),\quad S(n,1)=S(n,n)=1.
  $$

### 2.2 점화식(조합적 의미가 명확)
$$
\boxed{S(n,k)=k\,S(n-1,k)+S(n-1,k-1).}
$$
- 새 원소 \(x\)가 **기존 \(k\)개 집합 중 하나에 들어가는 경우**: \(k S(n-1,k)\)
- **새 집합을 만들어** \(x\)가 단독으로 들어가는 경우: \(S(n-1,k-1)\)

### 2.3 닫힌형(포함배제)
$$
\boxed{S(n,k)=\frac{1}{k!}\sum_{j=0}^{k}(-1)^{k-j}\binom{k}{j} j^n.}
$$

### 2.4 생성함수(EGF)
$$
\sum_{n\ge 0} S(n,k)\frac{x^n}{n!}=\frac{(e^x-1)^k}{k!}.
$$

### 2.5 onto 함수와의 관계
- **서젝션(전사 함수)** 개수: \(A\to B\)에서 \(|A|=n, |B|=k\)
  $$
  \#\{\text{onto}\}=k!\,S(n,k).
  $$

### 2.6 DP 구현(정수, \(O(nk)\))
```python
def stirling2(n, k):
    dp = [[0]*(k+1) for _ in range(n+1)]
    dp[0][0] = 1
    for i in range(1, n+1):
        for j in range(1, min(i, k)+1):
            dp[i][j] = j*dp[i-1][j] + dp[i-1][j-1]
    return dp[n][k]
```

### 2.7 포함배제(검증용)
```python
from math import comb
def stirling2_inclusion(n, k):
    return sum(((-1)**(k-j))*comb(k, j)*(j**n) for j in range(k+1)) // factorial(k)

from math import factorial
```

---

## 3. 벨 수 \(B_n\)

### 3.1 정의
- **서로 다른 \(n\)개를 임의 개수의 비어있지 않은 부분집합으로 분할**하는 경우의 수(총합).
- **관계**:
  $$
  \boxed{B_n=\sum_{k=0}^{n} S(n,k)}.
  $$

### 3.2 초기값
- \(1,1,2,5,15,52,203,877,4140,21147,\dots\)

### 3.3 재귀(벨 삼각형 / Bell triangle)
- **Aitken(혹은 Peirce) 삼각형** 규칙:
  - 첫 원소: \(T_{n,0}=T_{n-1,n-1}\)
  - 나머지: \(T_{n,j}=T_{n,j-1}+T_{n-1,j-1}\)
  - 각 행의 첫 원소 \(T_{n,0}\)가 \(B_n\).

```python
def bell_triangle(n):
    T = [[0]*(n+1) for _ in range(n+1)]
    T[0][0] = 1
    for i in range(1, n+1):
        T[i][0] = T[i-1][i-1]
        for j in range(1, i+1):
            T[i][j] = T[i][j-1] + T[i-1][j-1]
    # B_n = T[n][0]
    return [T[i][0] for i in range(n+1)]

print(bell_triangle(10))  # B_0..B_10
```

### 3.4 EGF & 도빈스키(Dobinski) 공식

- **EGF**:
  $$
  \boxed{\sum_{n\ge 0} B_n\frac{x^n}{n!}=\exp(e^x-1)}.
  $$

- **Dobinski**:
  $$
  \boxed{B_n=\frac{1}{e}\sum_{k=0}^{\infty}\frac{k^n}{k!}}
  $$
  (수치 근사/확률적 해석에 유용: 포아송(1) 변수 \(X\)에 대해 \(B_n=\mathbb{E}[X^n]\cdot e^{-1}\) 꼴로 해석 가능)

- **성장률**: 초지수(super-exponential)에 가깝게 매우 큼(정밀 점근식은 Moser–Wyman).

### 3.5 직접 DP(스털링 수 합)
```python
def bell_via_stirling(n):
    # B_n = sum_{k=0..n} S(n,k)
    S = [[0]*(n+1) for _ in range(n+1)]
    S[0][0] = 1
    for i in range(1, n+1):
        for k in range(1, i+1):
            S[i][k] = k*S[i-1][k] + S[i-1][k-1]
    return [sum(S[i][k] for k in range(i+1)) for i in range(n+1)]
```

---

## 4. 상호 관계 요약

- \( \boxed{B_n=\sum_{k=0}^{n} S(n,k)} \)
- **서젝션 수**: \(k!\,S(n,k)\).
- **non-crossing 분할 수**(원 위 점 \(n\)개를 교차 없이 블록으로 나눔) = \(C_n\).
- **다각형 삼각분할**: \((n+2)\)-각형의 삼각분할 수 = \(C_n\).
- **AST/파스 트리** 수(모호한 문법의 구조 개수)는 많이 \(C_n\)로 귀결.

---

## 5. 표/작은 값으로 감 잡기

### 5.1 \(C_n\) (n=0..10)
- \(1,1,2,5,14,42,132,429,1430,4862,16796\)

### 5.2 \(S(n,k)\) (n≤6)
| n\k | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|---:|---:|---:|---:|---:|---:|---:|---:|
| 0  | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1  | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
| 2  | 0 | 1 | 1 | 0 | 0 | 0 | 0 |
| 3  | 0 | 1 | 3 | 1 | 0 | 0 | 0 |
| 4  | 0 | 1 | 7 | 6 | 1 | 0 | 0 |
| 5  | 0 | 1 | 15| 25| 10| 1 | 0 |
| 6  | 0 | 1 | 31| 90| 65| 15| 1 |

(각 행 합 = \(B_n\))

### 5.3 \(B_n\) (n=0..10)
- \(1,1,2,5,15,52,203,877,4140,21147,115975\)

---

## 6. 증명 스케치(핵심 아이디어)

- **Catalan 컨볼루션**: 올바른 괄호열을 가장 왼쪽 괄호의 짝이 닫히는 지점에서 분할 → 왼쪽/오른쪽 부분이 독립적 올바른 괄호열 ⇒ 합성곱.
- **Catalan 폐형식**: GF \(C=1+xC^2\) 를 대수적으로 풀거나, **반사법**으로 라플라스 경로에서 음수 진입 경로를 제외해 유도.
- **Stirling(2종) 점화**: 새 원소 \(x\)가 기존 집합 중 하나에 들어가는 \(k\)가지 vs 새 집합으로 분기.
- **Dobinski**: 포아송 측도와 모멘트의 연결, EGF \(\exp(e^x-1)\)에서 계수 추출.

---

## 7. 실전 모델링 레시피

1) **“괄호/삼각분할/교차금지/스택 1개”** 느껴지면 → **카탈란** 후보.
2) **“n개를 k그룹(비어있지 않음)”** → **스털링(2종)**, onto 함수는 여기에 \(k!\)만 곱하면 OK.
3) **“분할 총합(그룹 수 자유)”** → **벨 수**.
4) **라벨/순서/용량 제약**이 보이면: 스털링/벨에서 한 단계 더(가중치/제약) → **생성함수/포함배제/DP**로 확장.

---

## 8. 파이썬: 통합 유틸 + 검증

```python
from math import comb, factorial
from functools import lru_cache

# 1. Catalan
def catalan_dp(n):
    C = [0]*(n+1)
    C[0] = 1
    for m in range(1, n+1):
        C[m] = sum(C[i]*C[m-1-i] for i in range(m))
    return C[n]

def catalan_binom(n):
    # C_n = (1/(n+1)) * (2n choose n)
    return comb(2*n, n) // (n+1)

# 2. Stirling(2nd)
def stirling2(n, k):
    if k < 0 or k > n: return 0
    dp = [[0]*(k+1) for _ in range(n+1)]
    dp[0][0] = 1
    for i in range(1, n+1):
        for j in range(1, min(i, k)+1):
            dp[i][j] = j*dp[i-1][j] + dp[i-1][j-1]
    return dp[n][k]

def stirling2_inclusion(n, k):
    if k < 0 or k > n: return 0
    s = 0
    for j in range(k+1):
        s += ((-1)**(k-j)) * comb(k, j) * (j**n)
    return s // factorial(k)

# 3. Bell
def bell_via_stirling(n):
    # returns list [B_0, ..., B_n]
    S = [[0]*(n+1) for _ in range(n+1)]
    S[0][0] = 1
    for i in range(1, n+1):
        for k in range(1, i+1):
            S[i][k] = k*S[i-1][k] + S[i-1][k-1]
    return [sum(S[i][k] for k in range(i+1)) for i in range(n+1)]

def bell_triangle_values(n):
    T = [[0]*(n+1) for _ in range(n+1)]
    T[0][0] = 1
    for i in range(1, n+1):
        T[i][0] = T[i-1][i-1]
        for j in range(1, i+1):
            T[i][j] = T[i][j-1] + T[i-1][j-1]
    return [T[i][0] for i in range(n+1)]

# 4. Quick sanity checks
for n in range(11):
    assert catalan_dp(n) == catalan_binom(n)

for n in range(7):
    for k in range(n+1):
        assert stirling2(n,k) == stirling2_inclusion(n,k)

B1 = bell_via_stirling(10)
B2 = bell_triangle_values(10)
assert B1 == B2

print("Sanity OK. C_10, S(6,3), B_10 =", catalan_binom(10), stirling2(6,3), B1[10])
```

---

## 9. 응용 시나리오(구체)

- **파서/컴파일러**: 길이 \(2n\) 토큰의 괄호형 언어의 **파스 트리 수** ≈ \(C_n\).
- **클러스터링/세그먼트**: 라벨 없는 \(n\)개 객체의 **분할 수** = \(B_n\) → 모델 선택/페널티로 활용.
- **해시/샤딩**: 서로 다른 키 \(n\)개를 **정확히 k개의 버킷**에 비어있지 않게 배치(서젝션) → \(k!S(n,k)\).
- **Non-crossing 설계**: 교차 금지 배선/행동 순서 → 카탈란.
- **언어모델/수학교육**: 괄호열 생성/평가, Dyck 언어 학습 데이터 수 산정.

---

## 10. 심화 포인트 & 팁

- **카탈란의 정제(Narayana)** 로 “피크 수/리프 수” 같은 **미세 통계**까지 제어 가능.
- **스털링 수**는 **로그 오목성** 등 좋은 성질을 가지며, 확률/평균 블록수(벨 수와 결합) 계산에 자주 등장.
- **벨 수**는 초대형이므로, 실제 계산은 **벨 삼각형** 또는 **스털링 합**(DP) 기반 정수 연산이 안전.
- **큰 n**에서는 생성함수로 **계수 추출**(Sympy), 또는 **모듈러 연산**(소수 p)에 기반한 수치 안정화 고려.

---

## 11. 미니 연습

1) 길이 8의 올바른 괄호열 개수는?
   $$C_4=14.$$

2) \(n=6\)개 원소를 **정확히 3개 집합**으로 분할: \(S(6,3)=90\).
   (검증: DP 또는 닫힌형)

3) \(n=7\)의 **집합 분할 총수** \(B_7\)은?
   \(877\) (표·코드로 확인)

4) onto 함수 개수: \(|A|=8, |B|=4\) → \(4!\,S(8,4)\).

5) \((n+2)\)-다각형 삼각분할 수? → \(C_n\).

---

## 마무리

- **카탈란**: 교차 없는 구조(괄호/경로/삼각분할/이진트리) ⇒ \(C_n\), GF \(C=1+xC^2\).
- **스털링(2종)**: \(n\)을 정확히 \(k\) 블록으로 ⇒ \(S(n,k)\), 점화 \(kS(n-1,k)+S(n-1,k-1)\), EGF \((e^x-1)^k/k!\).
- **벨**: 모든 분할의 합 ⇒ \(B_n=\sum_k S(n,k)\), EGF \(\exp(e^x-1)\), Dobinski로 근사/해석.
