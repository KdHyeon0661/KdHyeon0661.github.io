---
layout: post
title: flask - 시작
date: 2025-09-15 21:25:23 +0900
category: flask
---
# 0. 시작하기 (필수)

> 본 문서는 **Flask란 무엇인가 → 설치와 스캐폴딩 → 실행(개발/운영) → 환경변수/.env 전략 → 앱 팩토리 & 컨텍스트**까지 “처음부터 프로덕션 직전” 수준으로 **예제 중심**으로 자세히 설명한다.  
> 코드 블록은 모두 ```로 감싸며, 수식이 필요하면 $$로 표기한다(본 장에서는 수식이 거의 없다).

---

## 0.1 Flask란? — 마이크로 프레임워크 철학과 12-Factor 앱

### 0.1.1 “Micro”의 의미
- **핵심만 제공**: 라우팅(Werkzeug), 템플릿(Jinja2), 요청/응답, 컨텍스트, 확장 포인트.
- **필요한 것만 선택**: DB, 인증, 마이그레이션, 캐싱 등은 *확장(extensions)* 으로 조립.
- 결과: **경량, 가독성, 학습 곡선 완만**. 대신 설계는 개발자 책임(구조화/규약 필요).

### 0.1.2 12-Factor 앱과 Flask의 궁합
12-Factor는 **운영 환경에서의 애플리케이션 품질**을 위한 12가지 원칙. Flask는 다음 항목과 특히 궁합이 좋다.

1) **Config(환경변수)**: 설정을 코드와 분리. `FLASK_ENV`, DB URL, Secret Key 등은 환경변수로.  
2) **Dependencies(의존성)**: `requirements.txt` 또는 `pyproject.toml`로 명시적 관리.  
3) **Backing Services**: DB/Cache/Queue를 *attached resource*로 취급, URL로 교체 용이.  
4) **Build, Release, Run**: Docker 멀티 스테이지 빌드로 분리, Flask CLI로 런 명령 단일화.  
5) **Logs**: stdout/stderr로 구조화 로그 → 수집/집계.  
6) **Processes**: Gunicorn(uWSGI) + Nginx 프로세스 모델과 자연스럽게 접합.  

> 팁: 개발 초기부터 12-Factor 관점으로 폴더 구조, 설정, 로그, 의존성, 배포 방식을 글로 정의해 두면 팀 온보딩과 운영 전환이 쉬워진다.

---

## 0.2 설치 & 프로젝트 스캐폴딩(venv/poetry, 디렉터리 구조 베스트프랙티스)

### 0.2.1 가상환경(venv) or Poetry

#### (A) 표준 venv + pip
```bash
# Python 3.11 기준 예시
python -m venv .venv
# Windows
.venv\Scripts\activate
# macOS/Linux
source .venv/bin/activate

pip install --upgrade pip
pip install flask python-dotenv gunicorn
pip freeze > requirements.txt
```

#### (B) Poetry (권장: 의존성 잠금, 스크립트, 배포 편의)
```bash
pip install --user poetry
poetry init -n
poetry add flask python-dotenv
# 운영 WSGI 서버
poetry add --group prod gunicorn
# 개발 도구
poetry add --group dev black isort mypy pytest pytest-cov
```

### 0.2.2 디렉터리 구조(앱 팩토리/블루프린트 친화형)

> 다음 구조는 “앱 팩토리 + 설정 계층화 + 블루프린트 + 테스트”를 즉시 적용 가능하도록 최소/명확성을 목표로 한다.

```
flaskapp/
├─ pyproject.toml or requirements.txt
├─ .env                      # 개발 기본 환경변수 (절대 Git에 비밀 넣지 말 것!)
├─ .env.example              # 공유용 템플릿 (값은 비워두거나 dummy)
├─ .flaskenv                 # 필요시 FLASK_APP 등 개발 편의
├─ README.md
├─ wsgi.py                   # WSGI 엔트리(배포용)
├─ manage.py                 # Flask CLI 커맨드 확장(선택)
├─ app/
│  ├─ __init__.py            # create_app() 앱 팩토리
│  ├─ config.py              # 설정 클래스/로딩 로직
│  ├─ extensions.py          # 확장 초기화 (db, migrate, cache 등)
│  ├─ blueprints/
│  │  ├─ __init__.py
│  │  ├─ main/               # 예: 메인 페이지
│  │  │  ├─ __init__.py      # blueprint 인스턴스
│  │  │  ├─ views.py         # route 핸들러
│  │  │  ├─ forms.py         # 선택
│  │  │  └─ services.py      # 선택 (도메인 로직)
│  │  └─ api/                # 예: REST API
│  │     ├─ __init__.py
│  │     ├─ v1/
│  │     │  ├─ __init__.py
│  │     │  ├─ resources.py
│  │     │  └─ schemas.py
│  │     └─ v2/ ...          # 선택
│  ├─ templates/
│  │  └─ base.html           # Jinja2 base
│  ├─ static/
│  │  └─ css/app.css
│  └─ cli.py                 # 커스텀 CLI 명령 정의(선택)
└─ tests/
   ├─ conftest.py            # pytest 픽스처 (app, client)
   ├─ test_main.py
   └─ test_api.py
```

---

## 0.3 앱 실행 방법(개발용/프로덕션용), 환경변수(.env) 전략

### 0.3.1 개발 서버(Flask 내장)
- **핫 리로드**, 디버거 제공 → 개발 시 편의.
- 내장 서버는 운영용이 아님(싱글 스레드, 성능/보안 미흡).

```bash
# 환경변수(venv 활성화 가정)
export FLASK_APP=wsgi.py
export FLASK_ENV=development
export FLASK_DEBUG=1

# 또는 .flaskenv 파일에:
# FLASK_APP=wsgi.py
# FLASK_ENV=development
# FLASK_DEBUG=1

flask run --host=0.0.0.0 --port=5000
```

### 0.3.2 운영 서버(Gunicorn + Nginx 예시)
- **WSGI 서버**: Gunicorn/uWSGI/Waitress 등 중 선택.
- **리버스 프록시**: Nginx(압축/Keep-Alive/정적 캐싱/SSL 종단).

```bash
# 프로세스 수=코어수*2+1 권장(부하 테스트로 조절)
gunicorn --bind 0.0.0.0:8000 --workers 5 "wsgi:app"
```

> 정적 파일은 가능하면 Nginx가 직접 서빙(CDN/캐시). Python은 동적 요청만 처리.

### 0.3.3 .env 전략(개발 편의 vs 운영 보안)

- **개발**: `python-dotenv`로 `.env` 자동 로드(디버그 on, 로컬 DB 등).  
- **운영**: Docker/K8s의 **환경변수** 또는 **Secret/ConfigMap**으로 주입. `.env` 파일 자체는 git에서 제외하고, 운영 서버에 파일로 두지 않는 것을 권장.

`.env.example` 예시(공유용 템플릿)
```
# .env.example
FLASK_ENV=development
SECRET_KEY=change-me-in-prod
DATABASE_URL=postgresql+psycopg://user:pass@localhost:5432/devdb
REDIS_URL=redis://localhost:6379/0
```

> 보안 팁: **절대로** 진짜 비밀(프로덕션 키/토큰)을 저장소에 올리지 말 것. Vault/Secret Manager 사용 고려.

---

## 0.4 앱 팩토리 패턴과 컨텍스트(애플리케이션/요청)

### 0.4.1 앱 팩토리 패턴이란?
- 전역 `app = Flask(__name__)` 대신 **함수**로 앱을 생성:
  - 테스트 격리 용이(다중 인스턴스 생성 가능)
  - 환경별 설정/확장 초기화를 **주입** 방식으로 분리
  - 블루프린트/확장을 **지연 초기화**(import 사이클 완화)

```python
# app/__init__.py
from flask import Flask
from .config import load_config
from .extensions import init_extensions
from .blueprints.main import main_bp
from .blueprints.api.v1 import api_v1_bp

def create_app(config_name: str | None = None) -> Flask:
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(load_config(config_name))
    init_extensions(app)
    app.register_blueprint(main_bp)
    app.register_blueprint(api_v1_bp, url_prefix="/api/v1")
    register_error_handlers(app)
    register_cli_commands(app)
    return app

def register_error_handlers(app: Flask) -> None:
    @app.errorhandler(404)
    def not_found(e):  # noqa: ANN001
        return {"error": "Not Found"}, 404

def register_cli_commands(app: Flask) -> None:
    @app.cli.command("hello")
    def hello():
        print("Hello from Flask CLI!")
```

### 0.4.2 설정 로딩(환경변수 기반 계층화)

```python
# app/config.py
import os
from typing import Any, Dict

class BaseConfig:
    SECRET_KEY = os.getenv("SECRET_KEY", "dev-secret-key")
    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL", "sqlite:///dev.db")
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    # 예: 캐시/메일/기타 서비스 URL...
    # CACHE_REDIS_URL = os.getenv("REDIS_URL")

class DevelopmentConfig(BaseConfig):
    DEBUG = True

class TestingConfig(BaseConfig):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = "sqlite:///:memory:"

class ProductionConfig(BaseConfig):
    DEBUG = False

def load_config(name: str | None) -> Dict[str, Any]:
    # FLASK_ENV, APP_ENV 등으로 분기
    env = name or os.getenv("APP_ENV", "development").lower()
    if env == "production":
        cls = ProductionConfig
    elif env == "testing":
        cls = TestingConfig
    else:
        cls = DevelopmentConfig
    cfg = {k: getattr(cls, k) for k in dir(cls) if k.isupper()}
    return cfg
```

> 팁: Pydantic Settings(또는 Dynaconf)로도 구성 가능. 팀/조직 표준을 따를 것.

### 0.4.3 확장 초기화 분리

```python
# app/extensions.py
# 필요 확장을 지연 초기화하고 create_app에서 init_app 호출
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate

db = SQLAlchemy()
migrate = Migrate()

def init_extensions(app):
    db.init_app(app)
    migrate.init_app(app, db)
```

### 0.4.4 블루프린트 구조

```python
# app/blueprints/main/__init__.py
from flask import Blueprint

main_bp = Blueprint("main", __name__)

from . import views  # noqa: E402,F401  (라우트 등록)
```

```python
# app/blueprints/main/views.py
from flask import render_template, current_app, g, request
from . import main_bp

@main_bp.before_app_request
def before_any_request():
    # 요청 전 공통 훅: 예) 트레이싱/로케일 결정/요청 ID
    g.request_id = request.headers.get("X-Request-ID")

@main_bp.route("/")
def index():
    current_app.logger.info("index called, req_id=%s", getattr(g, "request_id", "-"))
    return render_template("base.html", message="Hello Flask")
```

```python
# app/blueprints/api/v1/__init__.py
from flask import Blueprint

api_v1_bp = Blueprint("api_v1", __name__)

from . import resources  # noqa: E402,F401
```

```python
# app/blueprints/api/v1/resources.py
from flask import jsonify
from . import api_v1_bp

@api_v1_bp.get("/health")
def health():
    return jsonify(status="ok")
```

### 0.4.5 템플릿/정적 예시

```html
<!-- app/templates/base.html -->
<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>Flask Starter</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/app.css') }}" />
  </head>
  <body>
    <h1>{{ message }}</h1>
  </body>
</html>
```

```css
/* app/static/css/app.css */
body { font-family: system-ui, sans-serif; margin: 2rem; }
h1 { font-weight: 700; }
```

### 0.4.6 WSGI 엔트리 & 개발 실행

```python
# wsgi.py
from app import create_app

app = create_app()
```

```bash
# 개발 실행(내장 서버)
export FLASK_APP=wsgi.py
flask run -p 5000
```

### 0.4.7 Flask CLI/관리 스크립트(선택)

```python
# manage.py
from flask.cli import FlaskGroup
from app import create_app

def create_my_app():
    return create_app()

cli = FlaskGroup(create_app=create_my_app)

@cli.command("show-config")
def show_config():
    """현재 설정 일부를 출력"""
    app = create_my_app()
    print("ENV:", app.config.get("ENV"))
    print("DEBUG:", app.config.get("DEBUG"))
    print("DB:", app.config.get("SQLALCHEMY_DATABASE_URI"))

if __name__ == "__main__":
    cli()
```

```bash
python manage.py show-config
```

---

## 0.5 애플리케이션 컨텍스트 vs 요청 컨텍스트

Flask는 전역처럼 보이는 객체(`current_app`, `g`, `request`, `session`)를 **컨텍스트 로컬**로 관리한다.

- **애플리케이션 컨텍스트**: `current_app`, `g`  
  - 앱 인스턴스와 **앱 단위 상태**에 접근할 때 필요.
- **요청 컨텍스트**: `request`, `session`  
  - HTTP 요청 처리 중에만 접근 가능. 요청이 없는데 접근하면 오류.

### 0.5.1 컨텍스트 활용 예시

```python
# 예: 서비스 함수 내부에서 current_app 사용
from flask import current_app, g

def do_something():
    logger = current_app.logger
    logger.info("service starts")
    if not hasattr(g, "cache"):
        g.cache = {}
    g.cache["answer"] = 42
    return g.cache["answer"]
```

```python
# 라우트에서 호출
from flask import jsonify
from . import main_bp
from .services import do_something

@main_bp.get("/compute")
def compute():
    value = do_something()
    return jsonify(result=value)
```

### 0.5.2 요청 밖에서 애플리케이션 컨텍스트 사용
- 예: 셸/스크립트/비동기 작업에서 DB/설정 접근.

```python
# scripts/oneoff.py (예시)
from app import create_app
from app.extensions import db

app = create_app("production")

with app.app_context():
    # 여기는 current_app, g 사용 가능
    print("DB URI:", app.config["SQLALCHEMY_DATABASE_URI"])
    # db.session 등 접근 가능
```

> 주의: **요청 컨텍스트가 없으므로** `request`에는 접근 불가.

### 0.5.3 컨텍스트 수명 주기
1) WSGI 서버가 요청 수신  
2) Flask가 **요청 컨텍스트** 푸시 → `request`/`session` 사용 가능  
3) 라우트/미들웨어 처리  
4) 응답 생성  
5) 컨텍스트 팝(pop) → 컨텍스트 로컬 정리(메모리 누수 예방)

---

## 0.6 개발·운영 실행 심화(실전 팁)

### 0.6.1 Gunicorn 파라미터 예시
```bash
# CPU 바운드 vs IO 바운드에 따라 workers, threads 조정
gunicorn "wsgi:app" \
  --bind 0.0.0.0:8000 \
  --workers 4 \
  --threads 2 \
  --timeout 30 \
  --graceful-timeout 30 \
  --access-logfile '-' \
  --error-logfile '-'
```

- **workers**: `cores * 2 + 1` 가이드에서 시작 → 부하 테스트로 튜닝  
- **threads**: 블로킹 IO(DB/HTTP) 많은 경우 증가 고려  
- **timeout**: 장기 요청 방지, 앱 수준 타임아웃 전략과 함께 조정

### 0.6.2 Nginx 리버스 프록시 스니펫
```nginx
server {
    listen 80;
    server_name _;

    client_max_body_size 16m;

    location /static/ {
        alias /app/app/static/;  # 정적 파일 직접 서빙
        expires 7d;
    }

    location / {
        proxy_pass http://gunicorn:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_read_timeout 60;
    }
}
```

### 0.6.3 Docker 멀티 스테이지(예시)
```dockerfile
# syntax=docker/dockerfile:1
FROM python:3.11-slim AS base
WORKDIR /app
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1

FROM base AS builder
RUN pip install --upgrade pip
COPY pyproject.toml poetry.lock* ./
RUN pip install poetry && poetry export -f requirements.txt --output requirements.txt
RUN pip wheel --no-cache-dir --no-deps -r requirements.txt -w /wheels

FROM base
COPY --from=builder /wheels /wheels
RUN pip install --no-cache /wheels/*
COPY . .
ENV APP_ENV=production
CMD ["gunicorn", "-b", "0.0.0.0:8000", "wsgi:app"]
```

---

## 0.7 환경변수(.env) 상세 전략

### 0.7.1 python-dotenv 자동 로드
Flask는 개발에서 `.env`, `.flaskenv`를 자동 로드(파이썬 도트엔브 설치 시).

```bash
pip install python-dotenv
```

`.flaskenv` (개발 편의용)
```
FLASK_APP=wsgi.py
FLASK_ENV=development
FLASK_DEBUG=1
```

`.env` (민감정보는 로컬 개발용으로만)
```
SECRET_KEY=dev-key
DATABASE_URL=sqlite:///dev.db
```

> 운영: **런타임 환경변수**(K8s Secret/ConfigMap, ECS Task Env, Systemd), 또는 Vault 연동.

### 0.7.2 설정 우선순위
1) **실행 시 환경변수**  
2) `.env`(개발)  
3) 코드 기본값(`config.py`)  
4) 인스턴스 폴더 별도 설정(선택)

> 의도적 우선순위를 문서화하고 테스트로 보증(예: `test_config_precedence`).

---

## 0.8 예제: 최소 구동부터 컨텍스트까지 “작동하는” 스타터

### 0.8.1 최소 라우트
```python
# app/blueprints/main/views.py
from flask import current_app, jsonify
from . import main_bp

@main_bp.get("/ping")
def ping():
    current_app.logger.debug("ping called")
    return jsonify(pong=True)
```

### 0.8.2 요청 전/후 훅으로 공통 처리
```python
# app/blueprints/main/views.py (일부)
from flask import g, request

@main_bp.before_app_request
def inject_request_id():
    g.request_id = request.headers.get("X-Request-ID") or "generated-...-123"

@main_bp.after_app_request
def add_common_headers(response):
    response.headers["X-App"] = "flask-starter"
    response.headers["X-Request-ID"] = getattr(g, "request_id", "-")
    return response
```

### 0.8.3 로깅(구조화) 초기가이드
```python
# app/__init__.py (일부)
import logging
from pythonjsonlogger import jsonlogger  # pip install python-json-logger

def _setup_logging(app):
    handler = logging.StreamHandler()
    formatter = jsonlogger.JsonFormatter("%(levelname)s %(name)s %(message)s")
    handler.setFormatter(formatter)
    app.logger.handlers.clear()
    app.logger.addHandler(handler)
    app.logger.setLevel(logging.INFO)

def create_app(config_name=None):
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(load_config(config_name))
    _setup_logging(app)
    ...
    return app
```

---

## 0.9 테스트 스캐폴딩(pytest) — 앱 팩토리의 진가

### 0.9.1 pytest 픽스처
```python
# tests/conftest.py
import pytest
from app import create_app

@pytest.fixture()
def app():
    app = create_app("testing")
    yield app

@pytest.fixture()
def client(app):
    return app.test_client()
```

### 0.9.2 간단 테스트
```python
# tests/test_main.py
def test_ping(client):
    resp = client.get("/ping")
    assert resp.status_code == 200
    assert resp.get_json() == {"pong": True}
```

```bash
pytest -q --maxfail=1
```

> 테스트는 “설정/컨텍스트/라우팅/에러 핸들러/로그/DB 트랜잭션”까지 확장. 초기부터 CI에 붙여 *회귀 방지*.

---

## 0.10 흔한 안티패턴 & 체크리스트

### 0.10.1 안티패턴
- **전역 앱 인스턴스 남발**: 테스트 어려움, 임포트 사이클.
- **설정 하드코딩**: 운영 전환 시 재빌드 필요, 시크릿 노출 위험.
- **내장 서버로 운영**: 스레드/프로세스/보안/성능 이슈.
- **컨텍스트 오해**: 요청 밖에서 `request` 접근 → RuntimeError.
- **모놀리식 파일**: views, services, models, schemas 뒤섞임 → 유지보수 지옥.

### 0.10.2 체크리스트
- [ ] 앱 팩토리 도입(`create_app`)  
- [ ] 설정 계층화(개발/테스트/운영) & 환경변수 우선  
- [ ] 확장 지연 초기화(`extensions.py`)  
- [ ] 블루프린트로 도메인 분리  
- [ ] 로깅/에러 핸들러/헬스체크 준비  
- [ ] 테스트 픽스처 & 첫 테스트 구축  
- [ ] WSGI + 프록시 구성 문서화  
- [ ] .env 보안 규칙 & 시크릿 관리 정책 수립

---

## 0.11 자주 묻는 질문(FAQ)

**Q1. 왜 앱 팩토리여야 하나요?**  
A. 테스트 격리, 환경 주입, 확장 지연 초기화, 임포트 사이클 회피. 팀 개발에서 *필수에 가까움*.

**Q2. .env를 운영에서 쓰면 안 되나요?**  
A. 기술적으로 가능하나 추천하지 않음. **환경변수/시크릿 매니저** 사용이 보안/감사 추적에 유리.

**Q3. Gunicorn만 쓰면 되나요?**  
A. 대부분 OK. 고성능/특수 경우 uWSGI/Waitress/Hypercorn 등 고려. 중요한 건 **부하 테스트**로 **객관적 수치** 확보.

**Q4. 컨텍스트는 언제 직접 푸시하나요?**  
A. 요청 외부(셸/스크립트/백그라운드)에서 `current_app/db` 접근 시 `with app.app_context():`로 **애플리케이션 컨텍스트**를 푸시.

---

## 0.12 한 걸음 더 — 초반에 고려하면 좋은 것들

- **프리커밋 훅**: black/isort/ruff/mypy/pytest 실행 → 코드 품질 자동화.
- **OpenTelemetry**: 요청 ID/트레이스 ID로 백엔드 전체 추적(Flask/DB/HTTP 연동).
- **구성 문서화**: README에 *실행/테스트/배포/설정* 명령을 복붙 가능하게 정리.
- **헬스/레디니스**: `/health`, `/ready` 구분으로 K8s 라이프사이클 연결.
- **서킷 브레이커/리트라이**: 외부 API 연동은 실패 전제를 기본으로.

---

# 부록 A: 빠른 스타터(복붙용)

> 아래 코드는 “동작하는 최소 + 팩토리/블루프린트/컨텍스트/헬스”를 담은 **한 번에 실행되는** 샘플이다.

```bash
# 1) 스캐폴딩
mkdir -p flaskapp/app/blueprints/main flaskapp/app/blueprints/api/v1 flaskapp/app/templates flaskapp/app/static/css flaskapp/tests
cd flaskapp
python -m venv .venv && source .venv/bin/activate
pip install flask python-dotenv gunicorn pytest
```

```python
# app/__init__.py
from flask import Flask
from .config import load_config

def create_app(config_name: str | None = None) -> Flask:
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(load_config(config_name))

    from .blueprints.main import main_bp
    from .blueprints.api.v1 import api_v1_bp

    app.register_blueprint(main_bp)
    app.register_blueprint(api_v1_bp, url_prefix="/api/v1")

    @app.errorhandler(404)
    def nf(e):  # noqa: ANN001
        return {"error": "not-found"}, 404

    return app
```

```python
# app/config.py
import os
from typing import Any, Dict

class Base:
    SECRET_KEY = os.getenv("SECRET_KEY", "dev-key")

class Dev(Base):
    DEBUG = True

class Prod(Base):
    DEBUG = False

def load_config(name: str | None) -> Dict[str, Any]:
    env = (name or os.getenv("APP_ENV", "dev")).lower()
    cls = Prod if env.startswith("prod") else Dev
    return {k: getattr(cls, k) for k in dir(cls) if k.isupper()}
```

```python
# app/blueprints/main/__init__.py
from flask import Blueprint
main_bp = Blueprint("main", __name__)
from . import views  # noqa
```

```python
# app/blueprints/main/views.py
from flask import current_app, g, render_template, request
from . import main_bp

@main_bp.before_app_request
def before():
    g.req_id = request.headers.get("X-Request-ID", "dev-reqid")

@main_bp.get("/")
def index():
    current_app.logger.info("index req_id=%s", g.req_id)
    return render_template("base.html", message="Hello Flask Starter")
```

```python
# app/blueprints/api/v1/__init__.py
from flask import Blueprint
api_v1_bp = Blueprint("api_v1", __name__)
from . import resources  # noqa
```

```python
# app/blueprints/api/v1/resources.py
from flask import jsonify
from . import api_v1_bp

@api_v1_bp.get("/health")
def health():
    return jsonify(status="ok")
```

```html
<!-- app/templates/base.html -->
<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <title>Starter</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/app.css') }}">
  </head>
  <body>
    <h1>{{ message }}</h1>
  </body>
</html>
```

```css
/* app/static/css/app.css */
body { margin: 2rem; font-family: system-ui, sans-serif; }
```

```python
# wsgi.py
from app import create_app
app = create_app()
```

```python
# tests/test_health.py
from app import create_app

def test_health():
    app = create_app("dev")
    client = app.test_client()
    res = client.get("/api/v1/health")
    assert res.status_code == 200
    assert res.get_json() == {"status": "ok"}
```

```bash
# 실행
export FLASK_APP=wsgi.py
flask run

# 테스트
pytest -q
```

---

# 부록 B: 문제 해결 가이드(초기 장애 Top 10)

1. **ImportError: cannot import name 'app'**  
   - WSGI 엔트리의 경로/모듈명 확인: `gunicorn "wsgi:app"`  
2. **RuntimeError: Working outside of application context**  
   - 요청 외부에서 `current_app` 접근 시 `with app.app_context():` 사용.  
3. **설정이 안 먹는다**  
   - 환경변수 우선순위/APP_ENV 값/`load_config` 로직 점검.  
4. **템플릿 경로 에러**  
   - `Flask(__name__)` 기준 상대 경로, 패키지 구조 재확인.  
5. **정적 파일 404**  
   - `url_for('static', filename='...')` / Nginx `alias` 경로 점검.  
6. **.env가 반영 안 됨**  
   - `python-dotenv` 설치 여부, `.flaskenv`/`.env` 위치 확인.  
7. **개발은 되는데 운영에서 느림**  
   - Gunicorn workers/threads/timeout/keep-alive 튜닝 + Nginx 캐시.  
8. **요청 중 메모리 누수 의심**  
   - 컨텍스트 로컬에 대형 객체 보관 금지, after_request 정리.  
9. **CORS 문제**  
   - Flask-CORS로 정확한 오리진/메서드/헤더 화이트리스트 지정.  
10. **시크릿 노출 위험**  
    - `.env`와 비밀 값은 저장소 제외, Secret Manager 도입.

---

## 마무리

이 장에서 **Flask의 철학 → 스캐폴딩 → 개발/운영 실행 → .env 전략 → 앱 팩토리 & 컨텍스트**까지 *예제와 함께* 정리했다.