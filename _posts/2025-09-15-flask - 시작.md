---
layout: post
title: flask - 시작
date: 2025-09-15 21:25:23 +0900
category: flask
---
# Flask 시작하기

## Flask란? — 마이크로 프레임워크 철학과 12-Factor 앱

### “Micro”의 의미

Flask는 **마이크로 프레임워크**로 분류되지만, 이는 기능이 부족하다는 의미가 아닙니다. 오히려 핵심을 명확히 제공함으로써 개발자에게 자유도와 유연성을 부여하는 철학을 나타냅니다.

- **핵심만 제공**: 라우팅(Werkzeug), 템플릿(Jinja2), 요청/응답 처리, 컨텍스트 관리, 확장 포인트 같은 기본적인 웹 애플리케이션의 골격을 제공합니다.
- **필요한 것만 선택**: 데이터베이스, 인증, 마이그레이션, 캐싱 등의 고급 기능은 *확장(Extensions)* 을 통해 필요에 따라 조립하면 됩니다. 이는 불필요한 복잡성을 제거합니다.

이 접근 방식의 결과는 **경량화, 높은 가독성, 완만한 학습 곡선**입니다. 반면, 애플리케이션의 구조와 설계에 대한 책임은 개발자에게 있습니다. 규모가 커질수록 체계적인 구조화와 규약이 필요해집니다.

### 12-Factor 앱과 Flask의 궁합

12-Factor는 클라우드 네이티브 환경에서 애플리케이션의 유지보수성과 확장성을 보장하기 위한 12가지 방법론입니다. Flask의 설계 철학은 다음과 같은 항목과 특히 잘 맞습니다.

1) **설정(Config)**: 설정을 코드와 분리합니다. `FLASK_ENV`, 데이터베이스 URL, 비밀 키 등은 환경변수로 관리하도록 권장합니다.
2) **의존성(Dependencies)**: `requirements.txt` 또는 `pyproject.toml`을 통해 명시적으로 관리합니다.
3) **백엔드 서비스(Backing Services)**: 데이터베이스나 캐시와 같은 서비스를 애플리케이션에 연결된 리소스로 취급하며, URL을 통해 쉽게 교체할 수 있도록 합니다.
4) **빌드, 릴리스, 실행(Build, Release, Run)**: 각 단계를 분리합니다. Docker 멀티 스테이지 빌드를 사용하고, Flask CLI를 통해 실행 명령을 단일화할 수 있습니다.
5) **로그(Logs)**: 표준 출력(stdout/stderr)으로 구조화된 로그를 작성하여 외부 도구에서 수집하고 집계할 수 있게 합니다.
6) **프로세스(Processes)**: Gunicorn이나 uWSGI 같은 WSGI 서버와 Nginx를 결합한 프로세스 모델과 자연스럽게 연동됩니다.

> 개발 초기부터 12-Factor 원칙에 따라 폴더 구조, 설정 관리, 로깅, 의존성, 배포 방식을 문서화해 두면, 팀 협업과 운영 환경으로의 전환이 훨씬 수월해집니다.

---

## 설치 & 프로젝트 구조화 (venv/poetry, 디렉터리 구조)

### 설치 방법

#### 표준 venv + pip

```bash
# Python 가상 환경 생성 및 활성화
python -m venv .venv

# Windows
.venv\Scripts\activate
# macOS/Linux
source .venv/bin/activate

# 필수 패키지 설치
pip install --upgrade pip
pip install flask python-dotenv gunicorn

# 의존성 목록 저장
pip freeze > requirements.txt
```

#### Poetry (권장: 의존성 잠금 및 프로젝트 관리)

```bash
# Poetry 설치
pip install --user poetry

# 새 프로젝트 초기화 (대화형 없이)
poetry init -n

# 기본 의존성 추가
poetry add flask python-dotenv

# 운영 환경용 WSGI 서버 (별도 그룹으로 추가)
poetry add --group prod gunicorn

# 개발 도구 (별도 그룹으로 추가)
poetry add --group dev black isort mypy pytest pytest-cov
```

### 디렉터리 구조 (앱 팩토리 & 블루프린트 준비)

아래 구조는 "앱 팩토리 패턴", "계층화된 설정", "블루프린트 기반 모듈화", "테스트 용이성"을 고려한 실전 베스트 프랙티스를 반영했습니다.

```
flaskapp/
├─ pyproject.toml 혹은 requirements.txt
├─ .env                      # 개발 환경변수 (Git 추적 금지)
├─ .env.example              # 필요한 환경변수 목록 템플릿
├─ .flaskenv                 # Flask CLI 관련 환경변수
├─ README.md
├─ wsgi.py                   # 프로덕션 WSGI 진입점
├─ manage.py                 # 선택적 Flask CLI 확장 스크립트
├─ app/
│  ├─ __init__.py            # 앱 팩토리 함수(create_app) 정의
│  ├─ config.py              # 환경별 설정 클래스
│  ├─ extensions.py          # Flask 확장(SQLAlchemy 등) 초기화
│  ├─ blueprints/
│  │  ├─ __init__.py
│  │  ├─ main/               # 메인 페이지 관련
│  │  │  ├─ __init__.py      # 블루프린트 인스턴스 생성
│  │  │  ├─ views.py         # 라우트와 뷰 함수
│  │  │  ├─ forms.py         # WTForms 등 (선택)
│  │  │  └─ services.py      # 비즈니스 로직 (선택)
│  │  └─ api/                # REST API 관련
│  │     ├─ __init__.py
│  │     ├─ v1/              # API 버전 1
│  │     │  ├─ __init__.py
│  │     │  ├─ resources.py  # API 엔드포인트 (뷰 함수)
│  │     │  └─ schemas.py    # Marshmallow 등 스키마 정의
│  │     └─ v2/              # API 버전 2 (선택)
│  ├─ templates/
│  │  └─ base.html           # Jinja2 기본 템플릿
│  ├─ static/
│  │  └─ css/app.css
│  └─ cli.py                 # 커스텀 CLI 명령어 (선택)
└─ tests/
   ├─ conftest.py            # pytest 픽스처 정의 (app, client)
   ├─ test_main.py
   └─ test_api.py
```

---

## 실행 전략: 개발 vs 운영

### 개발 서버 (Flask 내장 서버)

내장 서버는 자동 리로드와 디버거를 제공하여 개발 단계에서 매우 유용합니다. 하지만 단일 스레드로 동작하며 보안과 성능 측면에서 운영 환경에 부적합합니다.

```bash
# 환경변수 설정 (가상 환경 활성화 가정)
export FLASK_APP=wsgi.py
export FLASK_ENV=development
export FLASK_DEBUG=1

# 또는 .flaskenv 파일에 다음 내용을 작성하면 매번 설정할 필요가 없습니다.
# FLASK_APP=wsgi.py
# FLASK_ENV=development
# FLASK_DEBUG=1

# 개발 서버 실행
flask run --host=0.0.0.0 --port=5000
```

### 운영 서버 (Gunicorn + Nginx)

실제 서비스 환경에서는 WSGI 애플리케이션 서버와 리버스 프록시를 조합하여 사용합니다.

- **WSGI 서버**: Gunicorn, uWSGI, Waitress 중 선택합니다. 다중 워커 프로세스를 통해 동시 요청을 처리합니다.
- **리버스 프록시 (Nginx)**: 정적 파일 서빙, SSL 종료, 요청 버퍼링, 로드 밸런싱 등의 역할을 담당합니다.

```bash
# Gunicorn 기본 실행 예시
# 워커 수는 (코어 수 * 2 + 1) 공식을 시작점으로, 부하 테스트를 통해 조정합니다.
gunicorn --bind 0.0.0.0:8000 --workers 5 "wsgi:app"
```

> 정적 파일(이미지, CSS, JS)은 가능하면 Nginx나 CDN이 직접 서빙하도록 구성하는 것이 효율적입니다. Flask는 동적 요청 처리에 집중하도록 합니다.

### 환경변수 관리 전략 (개발 편의 vs 운영 보안)

- **개발 환경**: `python-dotenv` 패키지를 사용하면 `.env` 파일이 자동으로 로드되어 편리합니다. 로컬 데이터베이스 연결 정보나 디버그 설정을 여기에 넣을 수 있습니다.
- **운영 환경**: 보안을 위해 환경변수 파일(`.env`) 자체를 서버에 두지 않는 것이 좋습니다. 대신 Docker/Kubernetes의 **환경변수**나 **Secret/ConfigMap**을 통해 설정 값을 주입합니다.

`.env.example` 파일은 저장소에 커밋하여 팀원들이 필요한 환경변수를 알 수 있도록 합니다.
```
# .env.example

FLASK_ENV=development
SECRET_KEY=change-me-in-production
DATABASE_URL=postgresql+psycopg://user:pass@localhost:5432/devdb
REDIS_URL=redis://localhost:6379/0
```

> 보안 원칙: **절대로** 실제 프로덕션 비밀키, API 토큰, 데이터베이스 비밀번호 등을 `.env` 파일에 넣어 저장소에 커밋하지 마십시오. Vault나 클라우드 제공자의 Secret Manager 사용을 고려하세요.

---

## 앱 팩토리 패턴과 컨텍스트 이해

### 앱 팩토리 패턴의 장점

전역 변수 `app = Flask(__name__)` 대신 앱 인스턴스를 생성하는 함수(`create_app`)를 사용하는 패턴입니다.

- **테스트 용이성**: 서로 다른 설정을 가진 여러 앱 인스턴스를 쉽게 생성하여 테스트를 격리할 수 있습니다.
- **설정 주입**: 개발, 테스트, 운영 환경에 맞는 설정을 함수 인자로 전달할 수 있습니다.
- **확장 지연 초기화**: 확장(예: SQLAlchemy) 객체를 먼저 생성한 후 `init_app()` 메서드로 앱에 연결함으로써 임포트 순환 의존성 문제를 피할 수 있습니다.
- **블루프린트 등록 관리**: 앱 생성 로직 내에서 블루프린트를 체계적으로 등록할 수 있습니다.

```python
# app/__init__.py

from flask import Flask
from .config import load_config
from .extensions import init_extensions
from .blueprints.main import main_bp
from .blueprints.api.v1 import api_v1_bp

def create_app(config_name: str | None = None) -> Flask:
    """애플리케이션 팩토리 함수"""
    app = Flask(__name__, instance_relative_config=True)
    
    # 1. 설정 로드
    app.config.from_mapping(load_config(config_name))
    
    # 2. 확장(Extension) 초기화
    init_extensions(app)
    
    # 3. 블루프린트 등록
    app.register_blueprint(main_bp)
    app.register_blueprint(api_v1_bp, url_prefix="/api/v1")
    
    # 4. 에러 핸들러, CLI 명령어 등 추가 설정
    register_error_handlers(app)
    register_cli_commands(app)
    
    return app

def register_error_handlers(app: Flask) -> None:
    @app.errorhandler(404)
    def not_found(e):
        return {"error": "Not Found"}, 404

def register_cli_commands(app: Flask) -> None:
    @app.cli.command("hello")
    def hello():
        """간단한 커스텀 CLI 명령어 예시"""
        print("Hello from Flask CLI!")
```

### 환경별 설정 관리

```python
# app/config.py

import os
from typing import Any, Dict

class BaseConfig:
    """모든 환경의 공통 설정"""
    SECRET_KEY = os.getenv("SECRET_KEY", "dev-secret-key-change-me")
    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL", "sqlite:///dev.db")
    SQLALCHEMY_TRACK_MODIFICATIONS = False

class DevelopmentConfig(BaseConfig):
    DEBUG = True

class TestingConfig(BaseConfig):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = "sqlite:///:memory:"  # 인메모리 DB 사용

class ProductionConfig(BaseConfig):
    DEBUG = False
    # 프로덕션에서는 SECRET_KEY, DATABASE_URL 등이 반드시 환경변수로 설정되어야 함

def load_config(name: str | None) -> Dict[str, Any]:
    """환경 이름에 따라 적절한 설정 클래스를 선택하여 딕셔너리로 반환"""
    env = name or os.getenv("APP_ENV", "development").lower()
    
    config_map = {
        "production": ProductionConfig,
        "testing": TestingConfig,
        "development": DevelopmentConfig,
    }
    
    config_class = config_map.get(env, DevelopmentConfig)
    
    # 대문자로 된 속성만 설정 딕셔너리로 추출
    cfg = {k: getattr(config_class, k) for k in dir(config_class) if k.isupper()}
    return cfg
```

### 확장(Extensions) 초기화 분리

```python
# app/extensions.py

from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate

# 확장 객체 생성 (아직 앱과 연결되지 않음)
db = SQLAlchemy()
migrate = Migrate()

def init_extensions(app):
    """생성된 앱 인스턴스와 확장 객체를 연결"""
    db.init_app(app)
    migrate.init_app(app, db)
```

### 블루프린트 구조 예시

```python
# app/blueprints/main/__init__.py

from flask import Blueprint

main_bp = Blueprint("main", __name__)

# 뷰 함수가 정의된 모듈을 임포트하여 라우트를 등록
from . import views
```

```python
# app/blueprints/main/views.py

from flask import render_template, current_app, g, request
from . import main_bp

@main_bp.before_app_request
def before_any_request():
    """모든 요청 전에 실행되는 훅. 예: 요청 ID 설정"""
    g.request_id = request.headers.get("X-Request-ID", "unknown")

@main_bp.route("/")
def index():
    current_app.logger.info(f"Index page accessed. Request ID: {g.request_id}")
    return render_template("base.html", message="Welcome to Flask")
```

### WSGI 진입점과 개발 실행

```python
# wsgi.py

from app import create_app

app = create_app()
```

```bash
# 앱 실행
export FLASK_APP=wsgi.py
flask run --port=5000
```

---

## Flask 컨텍스트: Application Context vs Request Context

Flask는 `current_app`, `g`, `request`, `session` 같은 객체를 **컨텍스트 로컬**이라는 개념으로 관리합니다. 이는 마치 전역 변수처럼 보이지만, 실제로는 현재 실행 중인 스레드나 코루틴에 고유한 상태를 가집니다.

- **애플리케이션 컨텍스트 (Application Context)**:
    - `current_app`: 현재 활성화된 앱 인스턴스를 가리킵니다.
    - `g`: 한 번의 요청-응답 사이클 내에서, 또는 앱 컨텍스트 내에서 데이터를 임시로 저장하는 객체입니다.
    - 이 컨텍스트는 앱이 실행되는 동안 필요한 앱 단위의 리소스(예: 설정, 데이터베이스 연결)에 접근할 때 사용됩니다.

- **요청 컨텍스트 (Request Context)**:
    - `request`: 현재 들어온 HTTP 요청 정보를 담고 있습니다.
    - `session`: 사용자 세션 데이터를 저장합니다.
    - 이 컨텍스트는 HTTP 요청이 처리되는 동안만 존재하며, 요청이 끝나면 소멸됩니다.

**핵심**: `request`나 `session`은 HTTP 요청이 존재할 때만 접근 가능합니다. 백그라운드 작업이나 Flask 쉘에서 이 객체들을 사용하려고 하면 `RuntimeError: Working outside of request context` 오류가 발생합니다.

### 컨텍스트 활용 예시

```python
# 서비스 레이어 함수에서 앱 로거 사용하기

from flask import current_app, g

def business_logic():
    # current_app을 통해 현재 앱의 로거에 접근
    current_app.logger.info("Business logic started.")
    
    # g 객체를 통해 요청 내에서 상태 공유 (주의: 스레드/워커 간 공유 안 됨)
    if not hasattr(g, "my_cache"):
        g.my_cache = {"processed": 0}
    g.my_cache["processed"] += 1
    
    return g.my_cache["processed"]
```

```python
# 라우트에서 서비스 함수 호출

from flask import jsonify
from . import main_bp
from .services import business_logic

@main_bp.get("/process")
def process_route():
    result = business_logic()
    return jsonify({"processed_count": result})
```

### 요청 밖에서 애플리케이션 컨텍스트 사용하기

배치 작업, CLI 스크립트, 데이터베이스 마이그레이션 스크립트 등을 작성할 때는 HTTP 요청이 없지만, 앱의 설정이나 데이터베이스에 접근해야 할 수 있습니다. 이때 `app.app_context()`를 사용합니다.

```python
# scripts/backup_data.py (예시)

from app import create_app
from app.extensions import db

app = create_app("production")

with app.app_context():
    # 이 블록 안에서는 current_app, g 사용 가능
    print(f"Database URI: {current_app.config['SQLALCHEMY_DATABASE_URI']}")
    # 데이터베이스 쿼리 실행 가능
    users = db.session.query(User).all()
    print(f"Total users: {len(users)}")
```

> 주의: `app.app_context()`는 **애플리케이션 컨텍스트**만 푸시합니다. 따라서 `request` 객체에는 접근할 수 없습니다.

### 컨텍스트의 생명주기

1. WSGI 서버(예: Gunicorn)가 HTTP 요청을 받습니다.
2. Flask는 해당 요청에 대해 **요청 컨텍스트**를 생성(푸시)합니다. 이 시점부터 `request`, `session` 사용 가능합니다. 요청 컨텍스트는 내부적으로 애플리케이션 컨텍스트도 함께 푸시합니다.
3. 등록된 `before_request` 훅과 라우트 함수, 뷰 함수가 실행됩니다.
4. 응답이 생성되고, `after_request` 훅이 실행됩니다.
5. 요청 처리가 완료되면 Flask는 컨텍스트를 제거(팝)합니다. 이 과정은 메모리 누수를 방지하는 데 중요합니다.

---

## 고급 실행 구성 및 실전 팁

### Gunicorn 고급 옵션

```bash
gunicorn "wsgi:app" \
  --bind 0.0.0.0:8000 \
  --workers 4 \          # CPU 코어 수에 맞게 조정
  --threads 2 \          # I/O 바운드 작업이 많은 경우 스레드 수 증가 고려
  --timeout 30 \         # 작업자(worker)가 요청 처리에 걸리는 최대 시간(초)
  --graceful-timeout 30 \ # 워커 재시작 시 기존 요청 처리 대기 시간
  --access-logfile '-' \ # 접근 로그를 표준 출력으로 (Docker와 호환性好)
  --error-logfile '-'    # 오류 로그를 표준 출력으로
```

### Nginx 기본 리버스 프록시 설정

```nginx
server {
    listen 80;
    server_name your_domain.com;

    client_max_body_size 16m; # 파일 업로드 크기 제한

    # 정적 파일은 Nginx가 직접 처리 (성능 향상)
    location /static/ {
        alias /path/to/your/app/static/;
        expires 7d; # 브라우저 캐싱 유도
    }

    # 동적 요청은 Gunicorn(Flask)으로 전달
    location / {
        proxy_pass http://127.0.0.1:8000; # Gunicorn 주소
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_read_timeout 60;
    }
}
```

### Docker 멀티 스테이지 빌드 예시

```dockerfile
# 빌드 단계
FROM python:3.11-slim AS builder
WORKDIR /build
COPY pyproject.toml poetry.lock ./
RUN pip install --upgrade pip && \
    pip install poetry && \
    poetry export -f requirements.txt --output requirements.txt --without-hashes
RUN pip wheel --no-cache-dir --no-deps -r requirements.txt -w /wheels

# 실행 단계
FROM python:3.11-slim
WORKDIR /app
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1

# 빌드 단계에서 생성한 휠 파일 복사 및 설치
COPY --from=builder /wheels /wheels
RUN pip install --no-cache /wheels/*

# 애플리케이션 코드 복사
COPY . .

# 프로덕션 환경변수 설정 (실제 값은 런타임에 주입)
ENV APP_ENV=production

# Gunicorn으로 앱 실행
CMD ["gunicorn", "-b", "0.0.0.0:8000", "--workers", "4", "wsgi:app"]
```

---

## 자주 묻는 질문 (FAQ)

**Q: 왜 앱 팩토리 패턴을 사용해야 하나요?**
A: 테스트 용이성, 환경별 설정 주입의 편리함, 확장 초기화 시 발생할 수 있는 임포트 사이클 문제 회피 등이 주요 장점입니다. 특히 팀 프로젝트나 복잡한 애플리케이션에서는 사실상 표준이라 할 수 있습니다.

**Q: 운영 환경에서도 `.env` 파일을 사용해도 되나요?**
A: 기술적으로 가능하지만 보안상 권장하지 않습니다. 운영 환경에서는 Docker/Kubernetes의 환경변수, 또는 AWS Secrets Manager, HashiCorp Vault 같은 전용 시크릿 관리 도구를 사용하는 것이 보안 감사와 관리 측면에서 유리합니다.

**Q: Gunicorn만으로도 충분한가요?**
A: 대부분의 웹 애플리케이션에는 Gunicorn으로 충분합니다. 극한의 성능이 필요하거나 특정 기능(예: 웹소켓)이 필요하다면 uWSGI나 ASGI 서버인 Hypercorn 등을 고려해볼 수 있습니다. 어떤 서버를 선택하든, 실제 트래픽을 모방한 부하 테스트를 수행하여 객관적인 성능 지표를 확인하는 것이 가장 중요합니다.

**Q: `RuntimeError: Working outside of application context` 오류는 언제 발생하나요?**
A: `current_app`이나 `g` 객체에 접근해야 하는 코드(예: 데이터베이스 모델을 임포트하는 코드)가 애플리케이션 컨텍스트가 활성화되지 않은 상태에서 실행될 때 발생합니다. Flask 쉘에서 모델을 조회하거나, 독립적인 Python 스크립트에서 Flask 확장을 사용할 때는 반드시 `with app.app_context():` 블록 안에서 작업을 수행해야 합니다.

---

## 결론

Flask는 단순함에서 시작하지만, 프로덕션 수준의 견고한 애플리케이션을 구축하기 위한 모든 요소를 제공합니다. 성공적인 Flask 프로젝트의 핵심은 초기부터 체계적인 구조를 설계하는 데 있습니다.

1.  **앱 팩토리 패턴**을 도입하여 테스트와 설정 관리의 유연성을 확보하세요.
2.  설정은 **환경변수**를 최우선으로 하는 계층화된 방식으로 관리하고, 비밀 정보는 안전하게 보관하세요.
3.  **블루프린트**를 활용해 관심사를 분리하고 애플리케이션을 모듈화하세요.
4.  개발에는 내장 서버를, 운영에는 **Gunicorn + Nginx**와 같은 조합을 사용하세요.
5.  **애플리케이션 컨텍스트**와 **요청 컨텍스트**의 차이를 이해하고, 컨텍스트 밖에서 작업할 때는 명시적으로 컨텍스트를 푸시하세요.

이 가이드에서 제시한 구조와 원칙은 작은 프로토타입에서부터 대규모 서비스까지 적용 가능한 기반을 제공할 것입니다. 이제 `flask run`을 실행하고, 본인의 아이디어를 구체화하는 여정을 시작해 보세요.