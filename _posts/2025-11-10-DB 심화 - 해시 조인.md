---
layout: post
title: DB 심화 - 해시 조인
date: 2025-11-10 18:25:23 +0900
category: DB 심화
---
# 해시 조인(Hash Join)

## 0) 실측 플랜 확인 루틴(필수)

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'
));
```

- `ALLSTATS LAST` : **추정(E-Rows)**과 **실측(A-Rows)**을 바로 비교.
- `IOSTATS` : 버퍼/디스크 I/O.
- `MEMSTATS` : 해시/소트 workarea의 **PGA 사용량·TEMP 스필 여부**를 보여준다. `MEMSTATS`는 내부적으로 `V$SQL_WORKAREA` 요약을 끌어온다.

---

## 1) 해시 조인의 본질: “작은 쪽 빌드, 큰 쪽 프로브”

해시 조인은 **등치 조인(equi-join)** 에 특화된 “두 단계 조인 엔진”이다.

### BUILD 단계(해시 테이블 구성)

1. **빌드 입력(Build Input)** 을 읽는다.
2. 조인 키에 해시 함수를 적용해 **버킷(bucket)** 을 결정한다.
3. 버킷 내부에는 **체인 구조**로 행(혹은 필요한 컬럼)을 저장한다.
4. 이 해시 테이블은 **PGA(세션 메모리)** 의 workarea에 만들어진다.

### PROBE 단계(해시 테이블 탐색)

1. **프로브 입력(Probe Input)** 을 순차적으로 읽는다.
2. 같은 해시 함수를 적용해 버킷을 찾는다.
3. 버킷 체인을 따라가며 **동일 키를 실제 비교**하여 결과를 낸다.

> 직관
> - “**작은 집합을 메모리에 올려놓고**, 큰 집합을 **한 번만 훑으면서** 맞춰본다.”
> - 그래서 **빌드가 작을수록** 빠르고 안정적이다.

---

## 2) 언제 해시 조인이 최선인가?

해시 조인은 “**대량·범위 넓음·인덱스가 별 의미 없음**”일 때 빛을 발한다.

### 유리한 상황

- **대량 스캔/집계형 조인**
  - 두 테이블을 어차피 크게 읽어야 하는 경우.
- **인덱스 NL이 비효율**
  - Inner 인덱스가 없거나, 선택도가 낮아 랜덤 I/O가 폭증하는 경우.
- **DW/OLAP, 스타 조인 계열**
  - 병렬 해시 조인 + **Bloom Filter(JOIN FILTER)** 로 프로브 집합을 크게 줄일 수 있을 때.

### 불리한 상황(해시 조인을 피해야 할 때)

- **조기 종료(early-out)가 중요한 Top-N/부분 범위**
  - 예: `WHERE key=:b FETCH FIRST 10 ROWS` 같은 경우는 NL이 더 유리.
- **빌드가 커서 메모리 스필이 반복**
  - TEMP I/O가 병목이면 해시 조인은 급격히 느려진다.
- **비등치(range) 조인 중심**
  - 해시는 등치가 핵심이고, 비등치는 후단 필터로 처리되어 이점이 줄 수 있다.

---

## 3) Oracle 메모리 모델: Optimal / One-pass / Multi-pass

Oracle은 해시 조인을 **workarea 크기(PGA)** 에 따라 3가지 예산 구간으로 나눠 실행한다.

- **Optimal(In-Memory)** : 빌드 해시 테이블이 **완전히 PGA에 들어감** → TEMP 사용 0.
- **One-pass(Hybrid)** : 일부만 TEMP로 스필하되, **각 파티션을 1번씩만** 처리.
- **Multi-pass(Grace/Partitioned)** : 파티션이 여전히 커서 **여러 번 재분할/재탐색** → TEMP I/O 폭발.

이 구분은 `V$SQL_WORKAREA_HISTOGRAM` / `V$SYSSTAT`에서도 관측된다.

### 왜 스필이 느린가?

- 해시 조인 스필은 **빌드와 프로브 양쪽을 파티셔닝(Grace)** 해서 TEMP에 쓰고,
  파티션별로 다시 빌드-프로브를 반복한다.
- 결국 “큰 집합을 1번만 훑는” 장점이 줄고, **디스크 왕복과 재스캔**이 생긴다.

---

## 4) 두 가지 실제 알고리즘: One-pass vs Hybrid/Multi-pass

### One-pass(=Optimal) 해시 조인

- **빌드 전체가 PGA에 적합**할 때 수행.
- 단계
  1) 빌드 입력 전체 → 해시 테이블
  2) 프로브 입력 1회 스캔 → 즉시 매칭

**특징**
- 가장 빠름.
- TEMP 사용이 0에 가깝고, HASH JOIN 노드에서 `TempSpc=0` 또는 매우 작게 나온다.

#### One-pass를 만들기 위한 실전 요령

1) **빌드 측 선필터**
2) **파티션 프루닝으로 빌드 축소**
3) **집계/Distinct로 빌드 축소(의미 보존되는 경우)**
4) **조인 순서/빌드 입력을 작은 쪽으로 강제**

### Hybrid / Multi-pass(Grace) 해시 조인

- 빌드가 PGA를 초과하면 **해시 파티셔닝**을 수행한다.
- 파티션 중 **일부는 메모리에 남겨 In-Memory로 처리(하이브리드)**,
  나머지는 TEMP에 스필.
- 파티션이 다시 커지면 **재분할(멀티패스)** 이 일어날 수 있다.

**간단한 내부 흐름(개념도)**

```text
BUILD 쪽 파티션
  R -> hash(HF1) -> R1, R2, ..., Rn
      (메모리에 들어가는 Ri는 즉시 해시 테이블 유지)
      (초과 Ri는 TEMP에 write)

PROBE 쪽 파티션
  S -> hash(HF1) -> S1, S2, ..., Sn
      (TEMP에 write)

파티션별 조인
  for i=1..n:
     load Ri (메모리)
     scan Si (메모리 or TEMP) -> match
```

---

## 5) 해시 조인에서 “빌드/프로브 선택”이 중요한 이유

- 빌드는 **메모리에 상주**해야 하고(크기 민감),
- 프로브는 **순차 스트림**이어야 의미가 있다.

즉, **빌드 입력을 잘못 고르면**
- 스필 발생
- TEMP I/O 증가
- 전체 조인 시간이 폭증한다.

---

## 6) 힌트로 조인 순서·빌드 입력 통제하기

Oracle은 기본적으로 **추정 카디널리티**에 따라
- 조인 순서
- build/probe
를 비용 기반으로 결정한다.

하지만 실무에서는 **추정 오판** 또는 **특수 목적** 때문에
의도적으로 구조를 고정해야 할 때가 있다.

### 조인 순서 고정: LEADING / ORDERED

```sql
SELECT /*+ LEADING(c o) */ ...
FROM   D_CUSTOMERS c
JOIN   F_ORDERS    o ON ...
```

- `LEADING(c o)` : c → o 순서의 left-deep 트리를 강제.
- `ORDERED` : FROM 절 순서대로.

### 해시 조인 강제: USE_HASH

```sql
SELECT /*+ USE_HASH(o) */ ...
FROM   D_CUSTOMERS c
JOIN   F_ORDERS    o ON ...
```

- `USE_HASH(o)` 는 “**o를 직전 row-source와 해시 조인하라**”는 의미로,
  해시 조인 선택 자체를 강제한다.

### 빌드/프로브 교체: SWAP_JOIN_INPUTS / NO_SWAP_JOIN_INPUTS

**중요 포인트**:
- 해시 조인은 **조인 순서와 독립적으로** CBO가 build/probe를 바꾸는 “input swap”을 고려한다.
- `USE_HASH` 만으로는 **빌드가 확정되지 않을 수 있다.**

```sql
-- 빌드/프로브를 바꾸고 싶을 때
SELECT /*+ LEADING(c o) USE_HASH(o) SWAP_JOIN_INPUTS(o) */
       ...
FROM   D_CUSTOMERS c
JOIN   F_ORDERS    o ON o.cust_id = c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
AND    o.status = 'PAID';
```

- `SWAP_JOIN_INPUTS(o)` : o가 참여하는 해시 조인에서 **o를 빌드로** 바꾸도록 유도.
- `NO_SWAP_JOIN_INPUTS(o)` : 스왑 금지.

### “작은 디멘전 빌드, 큰 팩트 프로브” 정석 예제

```sql
SELECT /*+
          LEADING(c o)
          USE_HASH(o)
          NO_USE_NL(o)
          NO_USE_MERGE(o)
       */
       o.order_id, o.order_dt, c.region, c.tier
FROM   D_CUSTOMERS c
JOIN   F_ORDERS    o
  ON   o.cust_id = c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
AND    o.status = 'PAID';
```

- 일반적으로 `c`가 빌드, `o`가 프로브가 되도록 비용 기반으로 잡힌다.
- 만약 통계 오판으로 반대가 되면 `SWAP_JOIN_INPUTS(o)`로 교정.

---

## 7) 해시 조인과 값 분포(스큐): “버킷 과밀” 문제

해시 조인은 키를 해싱해 버킷에 넣지만,

- **빌드 측 조인 키가 심하게 스큐**면
  특정 버킷 체인이 길어져 CPU가 증가한다.
- 프로브 측 스큐는 상대적으로 덜 치명적이고,
  “빌드 스큐가 성능을 좌우”한다는 점이 실무적 핵심이다.

**대응 전략**
1) **히스토그램/확장 통계**로 추정 정확도를 확보해
   잘못된 build 선택이나 조인 순서 오판을 막는다.
2) 스큐 값에 따라 SQL을 분리하거나(값별 전략),
3) 필요하면 NL/SMJ로 전환한다.

---

## 8) 병렬 해시 조인과 Bloom Filter(JOIN FILTER)

DW/대용량 병렬에서 Oracle은 해시 조인과 함께
**Bloom Filter(Join Filter)** 를 사용해서 프로브 입력을 **스캔 단계에서 조기 차단**할 수 있다.

- 빌드 쪽 키로 **Bloom Filter를 생성**
- 프로브 쪽에서 **“조인 가능성이 없는 행”을 미리 버림**
- 실행계획에 `JOIN FILTER` 로 표시된다.

### Bloom Filter가 특히 강력한 조건

- 빌드 입력이 **상대적으로 작고**
- 빌드 키가 프로브에서 **강하게 필터링될 수 있을 때**
- 병렬(PX) 환경에서 데이터 재분배를 줄이는 효과가 큼.

---

## 9) 해시 조인 vs NL/SMJ: “선택 기준”을 더 정교하게

| 항목 | 해시 조인 | NL 조인 | 소트 머지 조인 |
|---|---|---|---|
| 최적 영역 | **대량/광범위** | **소량/Top-N/부분범위** | 대량·비등치에서도 안정(정렬) |
| 인덱스 의존 | 낮음 | 매우 높음 | 낮음 |
| 조기 종료 | 약함 | **강함** | 약함 |
| 메모리/Temp | **PGA 의존**, 스필 시 TEMP | 거의 없음 | PGA/TEMP 정렬 |
| 병렬/스타조인 | **매우 우수** | 제한적 | 우수 |

**실무 결론**
- 해시 조인이 선택됐다면 적어도 CBO는
  “**인덱스 랜덤 액세스가 더 비싸다**”라고 판단한 것이다.
- 그 판단이 맞는지 **E-Rows vs A-Rows, MEMSTATS, TEMP 사용량**으로 검증해야 한다.

---

## 10) 스필 진단: “내 해시 조인이 왜 느린가?”

### DBMS_XPLAN에서 확인할 것

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS +PREDICATE'
));
```

- `TempSpc` 가 크면 **One-pass/Multipass 스필 가능성**이 크다.
- HASH JOIN 단계의 A-Rows가 E-Rows보다 훨씬 크면
  **빌드 선택/조인 순서/선택도 추정 오판**을 의심.

### 시스템 차원 통계로 보는 방법

```sql
SELECT name, value
FROM   v$sysstat
WHERE  name LIKE 'workarea executions%';
```

- `optimal / onepass / multipass` 분포를 보면
  인스턴스 전체의 해시·소트 스필 빈도를 가늠할 수 있다.

---

## 11) 해시 조인 튜닝의 “진짜 순서”

해시 조인 튜닝은 **힌트 이전에 구조와 통계가 먼저**다.

### 1단계: 빌드 입력을 줄여라

- WHERE 필터를 **빌드 측으로 최대한 밀어 넣기**
- 파티션 프루닝
- 의미가 보존되는 범위 내 **사전 집계/Distinct**
- 불필요 컬럼 제거(프로젝션 최소화)

### 2단계: 조인 순서를 정리하라

- 큰 팩트 ↔ 작은 디멘전
- 여러 디멘전이 있으면 **각 조인 단계마다 작은 쪽이 빌드**가 되도록
  left-deep 체인을 만드는 것이 보통 안정적.

### 3단계: 통계/분포를 교정하라

- 스큐 컬럼 히스토그램
- 상관관계 컬럼 확장 통계
- 결과적 목적: **빌드/프로브 추정이 정확히 서도록** 한다.

### 4단계: 그래도 안 되면 힌트

- `LEADING / USE_HASH / SWAP_JOIN_INPUTS`
- “**딱 필요한 부분만 고정**”이 원칙.

---

## 12) 실전 시나리오 3종

### 시나리오 A — 해시 조인이 맞는 전형적 DW 조인

```sql
SELECT /*+ LEADING(c o) USE_HASH(o) */
       c.region, SUM(o.amount)
FROM   D_CUSTOMERS c
JOIN   F_ORDERS    o ON o.cust_id = c.cust_id
WHERE  o.order_dt >= DATE '2024-03-01'
AND    o.order_dt <  DATE '2024-04-01'
GROUP  BY c.region;
```

- 한 달치 주문이 크고,
  지역별 집계를 위해 결국 많이 읽어야 하는 패턴.
- 해시 + 병렬 + Bloom Filter 조합이 잘 먹는 구간이다.

### 시나리오 B — 빌드가 커져 스필이 나는 경우

```sql
SELECT /*+ LEADING(o c) USE_HASH(c) SWAP_JOIN_INPUTS(c) */
       COUNT(*)
FROM   F_ORDERS    o
JOIN   D_CUSTOMERS c ON o.cust_id = c.cust_id
WHERE  o.status = 'PAID';
```

- 의도적으로 **큰 쪽을 빌드**로 만들어 TEMP 스필을 관찰하는 실험.
- `TempSpc` 증가, elapsed 증가를 확인하라.

### 시나리오 C — NL이 더 나은데 해시가 잡히는 회귀

```sql
-- VIP 소수 고객의 최근 10건
SELECT /*+ LEADING(c o) USE_NL(o) INDEX(o IX_FO_CUST_DT) */
       o.*
FROM   D_CUSTOMERS c
JOIN   F_ORDERS    o ON o.cust_id = c.cust_id
WHERE  c.cust_id = :vip_id
AND    o.order_dt >= SYSDATE - 7
FETCH FIRST 10 ROWS ONLY;
```

- 조기 종료가 핵심인 Top-N → NL이 유리.
- 해시가 잡히면 통계/바인드/모드/ACS 문제를 먼저 의심해야 한다.

---

## 13) 23ai/Exadata 계열 최신 흐름(간단 정리)

- 23ai/Exadata 최신 스택에서는
  **대형 테이블 해시 조인 가속(스캔/필터/전송 최소화)** 같은 하드웨어·스토리지 레벨 최적화가 더 강화되었다.
- 따라서 최신 환경일수록
  “대량이라면 해시 + 병렬”의 효율이 더 좋아지는 쪽으로 코스트 모델이 진화하는 중이다.
- 다만 이는 **플랫폼/옵션(Exadata, In-Memory, PX 설정)에 강하게 의존**한다.

---

## 14) 해시 조인 트러블슈팅 패턴

### 빌드 과대 → 스필 → 느림

- 빌드를 줄이거나
- 조인 순서를 바꾸거나
- `SWAP_JOIN_INPUTS`로 build를 작은 쪽으로.

### 특정 키 스큐 → 버킷 과밀

- 히스토그램/ACS로 오판 방지.
- 값별 SQL 분기.

### TEMP 병목

- multipass 빈도 증가 → workload/PGA 정책 점검.
- TEMPfile IOPS/확장, 병렬 제한 검토.
- (운영) TEMP 부족은 해시 조인 실패의 전형적 원인이다.

### 플랜 불안정

- E-Rows/A-Rows 괴리 → 통계/바인드/동적 샘플링 점검.
- 핵심 조인만 최소 힌트로 고정.

---

## 15) 현업용 최종 체크리스트

- [ ] **빌드 입력이 충분히 작은가?** (필터/프루닝/집계)
- [ ] 조인 순서가 **“작은 쪽 빌드, 큰 쪽 프로브”** 원칙을 따르는가?
- [ ] `USE_HASH`만으로 빌드가 확정되지 않을 수 있으니
      필요하면 `SWAP_JOIN_INPUTS/NO_SWAP_JOIN_INPUTS`로 보정했는가?
- [ ] `MEMSTATS`에서 **TempSpc=0(Optimal)** 을 목표로 했는가?
- [ ] 스큐/상관관계 컬럼에 **히스토그램/확장 통계**가 반영되었는가?
- [ ] 병렬 환경이라면 **JOIN FILTER(Bloom)** 가 생성·활용되는가?
- [ ] 해시가 정말 최선인지 **NL/SMJ와 실측 비교**했는가?

---

## 16) 마무리

해시 조인은 Oracle에서 **대용량 조인의 핵심 메소드**다.
성공 여부는 거의 항상 아래 3가지로 결정된다.

1) **빌드 입력이 얼마나 작게 유지되는가**
2) **PGA가 빌드를 수용해 One-pass(Optimal)를 만들 수 있는가**
3) **통계/분포가 정확해서 CBO가 올바른 빌드·프로브를 고르는가**

결국 해시 조인의 정답은
**“실측(A-Rows) + MEMSTATS(TEMP 스필) + 비용 모델(E-Rows) 일치”**다.
그 일치를 만들어내는 것이 튜닝의 본질이다.
