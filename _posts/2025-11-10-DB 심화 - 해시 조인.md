---
layout: post
title: DB 심화 - 해시 조인
date: 2025-11-10 18:25:23 +0900
category: DB 심화
---
# 해시 조인(Hash Join)

— **기본 메커니즘(빌드·프로브) → 힌트로 조인 순서/빌드 입력 제어 → 두 가지 해시 조인 알고리즘(원패스/하이브리드·멀티패스)**
실습 SQL은 바로 실행 가능하도록 작성했습니다. 실행 계획/실행 통계는 `DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')`로 확인하세요.

---

## 공통 세션 설정 (실습 추천)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;                   -- ALLSTATS LAST
ALTER SESSION SET optimizer_features_enable = '19.1.0';     -- 환경에 맞게
ALTER SESSION SET workarea_size_policy = AUTO;              -- 해시/소트 작업 메모리 자동
```

> 참고
> - `+IOSTATS +MEMSTATS`로 **PGA/TEMP 사용량**을 함께 보며, **스필(spill)** 여부를 감지합니다.
> - 해시 조인은 **메모리 충분**하면 **원패스(One-Pass, In-Memory)**, 부족하면 **하이브리드/멀티패스(Grace/Partitioned)**로 동작합니다.

---

# 실습 스키마 (간단/현실적인 크기)

```sql
-- 기존에 있다면 정리
DROP TABLE D_CUSTOMERS PURGE;
DROP TABLE F_ORDERS PURGE;
DROP TABLE D_PRODUCTS PURGE;
DROP TABLE F_ORDER_ITEMS PURGE;

-- 디멘전: 고객
CREATE TABLE D_CUSTOMERS (
  CUST_ID   NUMBER       PRIMARY KEY,
  REGION    VARCHAR2(6)  NOT NULL,
  TIER      VARCHAR2(8)  NOT NULL
);

-- 디멘전: 제품
CREATE TABLE D_PRODUCTS (
  PROD_ID   NUMBER       PRIMARY KEY,
  CATEGORY  VARCHAR2(12) NOT NULL,
  BRAND     VARCHAR2(12) NOT NULL,
  PRICE     NUMBER(10,2) NOT NULL
);

-- 팩트: 주문 헤더
CREATE TABLE F_ORDERS (
  ORDER_ID  NUMBER       PRIMARY KEY,
  CUST_ID   NUMBER       NOT NULL,
  ORDER_DT  DATE         NOT NULL,
  STATUS    VARCHAR2(8)  NOT NULL
);

-- 팩트: 주문 상세
CREATE TABLE F_ORDER_ITEMS (
  ORDER_ID  NUMBER       NOT NULL,
  ITEM_NO   NUMBER       NOT NULL,
  PROD_ID   NUMBER       NOT NULL,
  QTY       NUMBER       NOT NULL,
  AMOUNT    NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_FOI PRIMARY KEY(ORDER_ID, ITEM_NO)
);

-- 인덱스(조인 키 중심)
CREATE INDEX IX_FO_CUST   ON F_ORDERS(CUST_ID);
CREATE INDEX IX_FOI_ORDER ON F_ORDER_ITEMS(ORDER_ID);
CREATE INDEX IX_FOI_PROD  ON F_ORDER_ITEMS(PROD_ID);

-- 샘플 데이터 로딩 (환경에 맞게 크기 조절)
BEGIN
  FOR c IN 1..100000 LOOP
    INSERT INTO D_CUSTOMERS VALUES(
      c,
      CASE MOD(c,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END,
      CASE MOD(c,5) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' WHEN 2 THEN 'SILVER' WHEN 3 THEN 'BRONZE' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..50000 LOOP
    INSERT INTO D_PRODUCTS VALUES(
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FASH' WHEN 2 THEN 'FOOD' WHEN 3 THEN 'HOME' ELSE 'TOY' END,
      CASE MOD(p,7) WHEN 0 THEN 'BR0' WHEN 1 THEN 'BR1' WHEN 2 THEN 'BR2' WHEN 3 THEN 'BR3'
                    WHEN 4 THEN 'BR4' WHEN 5 THEN 'BR5' ELSE 'BR6' END,
      ROUND(DBMS_RANDOM.VALUE(5,1000),2)
    );
  END LOOP;

  FOR o IN 1..600000 LOOP
    INSERT INTO F_ORDERS VALUES(
      o,
      MOD(o,100000)+1,
      DATE '2024-01-01' + MOD(o,540),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  FOR x IN 1..750000 LOOP
    INSERT INTO F_ORDER_ITEMS VALUES(
      MOD(x,600000)+1,
      1 + MOD(x,3),
      MOD(x,50000)+1,
      TRUNC(DBMS_RANDOM.VALUE(1,5)),
      ROUND(DBMS_RANDOM.VALUE(10,2000),2)
    );
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'D_CUSTOMERS', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'D_PRODUCTS',  cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'F_ORDERS',    cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'F_ORDER_ITEMS', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

# 해시 조인의 **기본 메커니즘**

## 두 단계 요약 (등치 조인 기준)

- **BUILD(빌드) 단계**: 상대적으로 **작은 입력**(Build Input)을 읽어 **해시 테이블**을 **메모리(PGA)**에 구성
  - 조인 키에 해시 함수를 적용해 **버킷**에 배치하고, 행 전체(또는 필요한 컬럼)를 **체인** 형태로 저장
- **PROBE(프로브) 단계**: **큰 입력**(Probe Input)을 순차 스캔하며 키를 해싱 → **버킷** 탐색 → **동일 키** 매칭 출력

> 핵심 직관
> - 빌드는 “**작은 쪽을 메모리에** 깔아놓고”, 프로브는 “**큰 쪽을 한 번만 훑으면서**” 매칭한다.
> - 메모리 부족 시 **파티셔닝(Grace/Hybrid)**으로 나눠서 처리 (아래 §4 참조).

## 언제 해시 조인이 좋은가?

- **대량 스캔·집계형** 조인 (조기 종료 이득이 적을 때)
- **인덱스가 없거나(또는 의미 없거나)**, **범위가 넓어** 인덱스 NL이 비효율적일 때
- **분포/선택도**상, 두 입력을 크게 읽는 것이 불가피할 때
- 병렬 처리, **스타 조인**(Bloom Filter 포함) 등 **DW/OLAP** 패턴

---

# 힌트로 **조인 순서 & 빌드 입력** 제어

> Oracle은 보통 **조인 순서**와 **크기 추정**을 기반으로 자동으로 Build/Probe를 정합니다.
> 그러나, **LEADING/ORDERED + USE_HASH + SWAP_JOIN_INPUTS** 조합으로 원하는 모양을 만들 수 있습니다.

## 조인 순서 고정

- `/*+ ORDERED */` : FROM절 순서대로
- `/*+ LEADING(a b c) */` : 명시적으로 **a → b → c** 순서로 조인

## 해시 조인 강제

- `/*+ USE_HASH(t) */` : **t**와 해시 조인하도록 유도 (해당 조인에 NL/MERGE 대신 HASH 선택)
- (보완) `/*+ NO_USE_NL(t) NO_USE_MERGE(t) */` 로 다른 메소드를 배제

## 빌드/프로브 선택 (중요)

- **원칙**: 해시 조인은 “**조인에서 **뒤에 오는**(두 번째) 입력**”을 **빌드**로 삼는 경향이 큼 (조인 순서에 좌우)
- 힌트
  - `/*+ SWAP_JOIN_INPUTS(t) */` : **t**가 참여하는 해시 조인에서 **빌드/프로브를 교체**
  - `/*+ NO_SWAP_JOIN_INPUTS(t) */` : 스왑 금지
- 따라서, **LEADING**(조인 순서)로 **첫 입력(프로브)**, **둘째 입력(빌드)**를 만들고, 필요 시 **SWAP_JOIN_INPUTS**로 **빌드 대상을 바꾼다**.

### 예시 1) 고객→주문 헤더 조인 (고객이 작다는 가정: 고객=빌드, 주문=프로브)

```sql
-- 의도: D_CUSTOMERS(작은 디멘전)을 빌드, F_ORDERS(큰 팩트)를 프로브
SELECT /*+ LEADING(c o) USE_HASH(o) NO_USE_NL(o) NO_USE_MERGE(o) */
       o.order_id, o.order_dt, c.region, c.tier
FROM   D_CUSTOMERS c
JOIN   F_ORDERS    o
  ON   o.cust_id = c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
AND    o.status = 'PAID';

-- 확인: 해시 조인, 빌드=고객(왼쪽 또는 오른쪽 위치와 상관 없이 '두 번째 입력' 여부를 주목),
-- 필요하면 SWAP_JOIN_INPUTS(o)로 교체 실험
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS +PEEKED_BINDS'));
```

### 예시 2) 빌드/프로브 **교체** 실험

```sql
-- 의도 반전: 오더(상대적으로 큼)를 빌드로 만들어 보기 (일반적으로 비추천, 실험용)
SELECT /*+ LEADING(c o) USE_HASH(o) SWAP_JOIN_INPUTS(o) */
       o.order_id, o.order_dt, c.region, c.tier
FROM   D_CUSTOMERS c
JOIN   F_ORDERS    o
  ON   o.cust_id = c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
AND    o.status = 'PAID';

-- 결과의 MEMSTATS/TEMP 변화, Elapsed 시간 비교
```

> 실무 원칙
> - **빌드 입력은 작을수록 유리** (메모리 체류 가능성↑, 파티셔닝 필요↓)
> - **프로브 입력은 큰 스트림**을 **한 번만** 훑는 데 의미가 있음
> - 빌드/프로브 선택은 **(1) 조인 순서**로 1차 결정, **(2) SWAP_JOIN_INPUTS**로 수정

---

# **두 가지 해시 조인 알고리즘** (Oracle 동작 관점)

Oracle은 내부적으로 메모리 여건에 따라 해시 조인을 **여러 방식**으로 수행합니다. 개념적으로 다음 두 가지를 기억하면 충분합니다.

## **원패스 해시 조인(One-Pass / In-Memory Hash Join)**

- 빌드 입력 전체가 **PGA 메모리**에 **수용**됨 → 디스크 스필 없음
- 단계
  1) **빌드 입력 전체를 읽어 해시 테이블 구성**(메모리)
  2) 프로브 입력을 **한 번 스캔**하며 매칭
- **가장 빠르고 단순**한 케이스

**원패스 유도 팁**
- 빌드 입력을 **충분히 작게**: 조인 전 **필터링**(WHERE), **프루닝(파티션)**, **집계/디스틴트** 등
- 세션/시스템에 **PGA 여유** 확보 (단, 전체 서버 리소스·동시성 고려가 우선)

### 원패스 관측 예

```sql
-- VIP/GOLD 고객(작게) ↔ 큰 오더
SELECT /*+ LEADING(c o) USE_HASH(o) */
       COUNT(*)
FROM   D_CUSTOMERS c
JOIN   F_ORDERS    o
  ON   o.cust_id = c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
AND    o.status = 'PAID';

-- MEMSTATS에 TempSpc가 0이거나 매우 작고,
-- Hash Join 단계의 One-Pass 느낌(스필 없음)을 간접 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'));
```

## **하이브리드/멀티패스 해시 조인(Hybrid / Grace / Partitioned)**

메모리가 부족하면 **입력을 해시 파티셔닝**하여 디스크(Temp)에 **분산 저장**하고, **파트별로** 빌드-프로브를 수행합니다.

- **아이디어**: 동일 해시 버킷끼리만 매칭되므로, **파티션 단위**로 나눠도 결과는 동일
- **하이브리드**: 메모리에 들어오는 부분은 **그대로 In-Memory**로 처리, 초과분만 **스필**(둘 다 섞음)
- **멀티패스(Grace)**: 파티션이 여전히 커서 한 번 더 나눠야 할 수도 있음(드뭄)

**스필 감지 포인트(간접)**
- `+MEMSTATS`에서 **TempSpc 사용량 증가**
- 대기 이벤트/통계에서 **temp read/write** 흔적
- 실행 시간/블록 읽기 증가

### 스필 유발/관찰 실험 (개념)

- 의도적으로 빌드 입력을 크게 만들거나(필터 약화)
- (실습에서는 인스턴스 파라미터 조정이 제한적이므로) **필터를 약화**시켜 **빌드 측**을 키움

```sql
-- 빌드 입력을 '크게' 만들기: 조인 순서를 바꿔서 D_CUSTOMERS를 프로브, F_ORDERS를 빌드로 만들어 보자
-- (일반적으로 나쁜 선택) + USE_HASH + SWAP_JOIN_INPUTS로 강조
SELECT /*+ LEADING(o c) USE_HASH(c) SWAP_JOIN_INPUTS(c) */
       COUNT(*)
FROM   F_ORDERS    o
JOIN   D_CUSTOMERS c
  ON   o.cust_id = c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
AND    o.status = 'PAID';

-- MEMSTATS에서 TempSpc 증가 등을 확인 (환경 따라 다르며, 항상 스필이 보장되진 않음)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'));
```

> 정리
> - **원패스**: 가장 이상적 (PGA 내 빌드 → 프로브 1회)
> - **하이브리드/멀티패스**: **파티셔닝 + 스필**. 느려질 수 있으나 **대용량**에서 현실적인 전략
> - 빌드 입력을 작게/선택도 높게 만들면 원패스 가능성↑

---

# 추가 예제: **다중 조인**에서 빌드 입력 통제

해시 조인은 **조인 체인**에서도 “**항상 작은 쪽을 빌드**” 원칙이 유효합니다.

## 팩트 ↔ 디멘전 ↔ 디멘전 (2단 해시)

```sql
-- (F_ORDER_ITEMS → D_PRODUCTS) → (결과 → D_CUSTOMERS)
-- 의도: 각 단계에서 빌드는 '작은 쪽'
SELECT /*+
          LEADING(i p c)
          USE_HASH(p) USE_HASH(c)
          NO_USE_NL(p) NO_USE_NL(c)
          NO_USE_MERGE(p) NO_USE_MERGE(c)
       */
       c.region, p.category, SUM(i.amount) AS sales
FROM   F_ORDER_ITEMS i
JOIN   D_PRODUCTS   p ON p.prod_id = i.prod_id
JOIN   D_CUSTOMERS  c ON c.cust_id = (SELECT o.cust_id FROM F_ORDERS o WHERE o.order_id = i.order_id)
GROUP  BY c.region, p.category;

-- 실제로는 F_ORDER_ITEMS ↔ F_ORDERS ↔ D_CUSTOMERS 형태가 더 일반적.
-- (서브쿼리는 단순화를 위한 예시)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +MEMSTATS +IOSTATS'));
```

> 포인트
> - **LEADING**로 조인 순서를 선명히, 각 조인에서 **USE_HASH**로 메소드 고정
> - 통계/히스토그램이 좋을수록 옵티마이저 추정이 정확 → 빌드 선택도 안정화

---

# 해시 조인 vs NL/SMJ **간단 비교**

| 항목 | 해시 조인 | NL 조인 | 소트 머지 조인 |
|---|---|---|---|
| 데이터 양 | **대량**에 강함 | 소량/Top-N/부분범위 | 대량에도 안정적(정렬 비용) |
| 인덱스 의존 | 낮음 | 높음(Inner 인덱스 필요) | 낮음(정렬 필요) |
| 조기 종료 | 약함 | **강함** | 약함 |
| 비등치 | 등치 최적(범위는 변형 필요) | 가능(인덱스 필수) | **자연스러움** |
| 메모리 의존 | **PGA 의존**(스필 시 TEMP) | 낮음 | PGA/TEMP 의존(정렬) |
| 병렬 | **우수**(파티션/블룸) | 제한적 | 좋음 |

---

# 실전 체크리스트

- [ ] **빌드 입력을 작게** 만들었는가? (필터/집계/프루닝)
- [ ] **조인 순서**가 의도대로인가? (`LEADING/ORDERED`)
- [ ] **USE_HASH**와 **SWAP_JOIN_INPUTS**로 빌드/프로브를 적절히 배치했는가?
- [ ] `ALLSTATS LAST +MEMSTATS`로 **PGA/TEMP** 사용을 확인했는가? (스필 감지)
- [ ] 해시가 맞는 상황인가? (대량/인덱스 무의미/조기 종료 불필요)
- [ ] 값 분포 스큐 → **히스토그램/ACS** 반영, **플랜 고정** 필요 여부 점검
- [ ] **병렬**/**블룸 필터**(스타 조인) 활용 가능성 검토 (DW)

---

# 트러블슈팅 패턴

1) **해시 빌드 과대** → 스필 → 느림
   - 빌드 전 **필터 강화** 또는 **조인 순서 변경**
   - `SWAP_JOIN_INPUTS`로 더 작은 쪽을 빌드로
2) **값 스큐**로 특정 버킷 과밀
   - 히스토그램/ACS, 경우에 따라 **SQL 분리**(값별 전략)
3) **TEMP 병목**
   - `pga_aggregate_target` 정책/동시성 재점검, TEMPfile 확충/IOPS 확보, 병렬 제한
4) **실행계획 불안정**
   - **LEADING/USE_HASH** 명시, **SQL Plan Management**(Baselines) 고려

---

# 요약

- 해시 조인은 **빌드(작은 입력) → 프로브(큰 입력)**의 **2단 구조**로, **대량 스캔/집계**에 강합니다.
- **LEADING/ORDERED**로 **조인 순서**를, **USE_HASH + SWAP_JOIN_INPUTS**로 **빌드/프로브**를 통제하세요.
- 알고리즘은 **원패스(메모리 적합)**가 최선, 부족하면 **하이브리드/멀티패스(파티셔닝/스필)**로 전환됩니다.
- 항상 `ALLSTATS LAST +MEMSTATS +IOSTATS`로 **PGA/TEMP 사용**과 **I/O**를 확인하고,
  상황에 따라 NL/SMJ와 **실측 비교**로 최적을 선택하세요.

---

## (부록) 실습 후 확인 스니펫

```sql
-- 최근 실행 SQL의 해시 조인 노드
SELECT sql_id, child_number, plan_hash_value, id, operation, options, object_name
FROM   v$sql_plan
WHERE  operation LIKE 'HASH JOIN%'
ORDER  BY last_change_time DESC
FETCH FIRST 30 ROWS ONLY;

-- 메모리/Temp 사용 체크 (마지막 실행)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'));
```
