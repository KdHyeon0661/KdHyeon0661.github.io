---
layout: post
title: C# - 파일 입출력과 비동기 처리
date: 2024-10-21 19:20:23 +0900
category: Csharp
---
# C# 파일 입출력과 비동기 처리

## 0) 큰 그림: .NET I/O 계층

- **File / Directory / Path**: 정적 유틸리티 (간단 읽고/쓰기, 파일 시스템 조작)
- **Stream**: 추상 기반. `FileStream`, `MemoryStream`, `NetworkStream`, `GZipStream` 등
- **Reader/Writer 계층**: `StreamReader/Writer`(텍스트), `BinaryReader/Writer`(바이너리)
- **동기 vs 비동기**: `Read/Write` ↔ `ReadAsync/WriteAsync` (`async/await`와 궁합)
- **버퍼링**: 내부 버퍼 + `BufferedStream`로 IOPS 감소, 처리량 향상

---

## 1) 텍스트 파일 — 가장 간단한 API

### 1.1 단일 문자열 쓰기/읽기

```csharp
using System.IO;

File.WriteAllText("hello.txt", "Hello, world!");
string text = File.ReadAllText("hello.txt");
Console.WriteLine(text);
```

### 1.2 줄 단위

```csharp
var lines = new[] { "Line 1", "Line 2" };
File.WriteAllLines("lines.txt", lines);

foreach (var line in File.ReadAllLines("lines.txt"))
    Console.WriteLine(line);
```

### 1.3 인코딩 지정 (기본: UTF-8 with BOM 아님/.NET Core+는 UTF-8)

```csharp
using System.Text;

File.WriteAllText("euckr.txt", "텍스트", Encoding.GetEncoding(51949));
string s = File.ReadAllText("euckr.txt", Encoding.GetEncoding(51949));
```

> **권장**: 표준은 **UTF-8**. 외부 시스템 연동에 한해 인코딩 지정.

---

## 2) StreamReader / StreamWriter — 스트림 기반 텍스트

### 2.1 쓰기 (append, 인코딩, 버퍼크기)

```csharp
using var sw = new StreamWriter(
    path: "app.log",
    append: true,
    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false),
    bufferSize: 1 << 14 // 16 KB
);
sw.WriteLine($"[{DateTime.Now:O}] 로그 추가");
```

### 2.2 읽기 (줄 단위)

```csharp
using var sr = new StreamReader("app.log");
string? line;
while ((line = sr.ReadLine()) is not null)
{
    Console.WriteLine(line);
}
```

### 2.3 `using`과 `Dispose/Flush`

- `using` 종료 시 **자동 Flush + Close**  
- 명시 플러시는 드물게만 필요: `sw.Flush()` (아주 긴 타이밍 민감 로그 등)

---

## 3) FileStream — 저수준 바이너리 I/O

### 3.1 기본 쓰기/읽기

```csharp
using var fs = new FileStream("data.bin", FileMode.Create, FileAccess.Write, FileShare.None);
byte[] bytes = { 0x10, 0x20, 0x30 };
fs.Write(bytes, 0, bytes.Length);

fs.Flush(true); // true: OS 버퍼까지 플러시(Write-Through 유사)
```

읽기:

```csharp
using var fs = new FileStream("data.bin", FileMode.Open, FileAccess.Read, FileShare.Read);
var buf = new byte[3];
int n = fs.Read(buf, 0, buf.Length); // 3
```

### 3.2 고급 옵션

```csharp
using var fs = new FileStream(
    path: "big.dat",
    mode: FileMode.OpenOrCreate,
    access: FileAccess.ReadWrite,
    share: FileShare.Read,
    bufferSize: 1 << 20, // 1 MB
    options: FileOptions.Asynchronous | FileOptions.SequentialScan | FileOptions.WriteThrough
);
```

- **Asynchronous**: OS 레벨 비동기
- **SequentialScan**: OS 프리페치 힌트
- **RandomAccess**: 임의 접근 최적화 힌트
- **WriteThrough**: 중간 버퍼 우회(성능↓, 내구성↑)

### 3.3 임의 접근(Seek)과 길이(Length/SetLength)

```csharp
fs.Seek(offset: 1024, SeekOrigin.Begin);
fs.Write(new byte[] { 1,2,3 }, 0, 3);
long len = fs.Length;
fs.SetLength(10_000); // 파일 길이 늘리거나 자르기
```

---

## 4) BinaryReader / BinaryWriter — 형태 있는 바이너리

```csharp
using var fs = new FileStream("user.dat", FileMode.Create);
using var bw = new BinaryWriter(fs);
bw.Write(42);            // Int32
bw.Write(3.14);          // Double
bw.Write("Alice");       // 길이-접두 문자열(UTF-8)

using var fr = new FileStream("user.dat", FileMode.Open);
using var br = new BinaryReader(fr);
int    n = br.ReadInt32();
double d = br.ReadDouble();
string s = br.ReadString();
```

> 별도 포맷(json/protobuf/msgpack)을 쓰면 상호운용성이 좋아진다.

---

## 5) 경로/디렉터리 — 안전한 조립과 검사

### 5.1 Path/Directory/File 유틸

```csharp
Directory.CreateDirectory("out/logs");                // 존재해도 OK
bool exists = File.Exists("file.txt");
string full  = Path.GetFullPath("file.txt");

string combined = Path.Combine("out", "2025", "11", "log.txt");
string changedExt = Path.ChangeExtension("a.tmp", ".bin");
string nameOnly = Path.GetFileNameWithoutExtension(combined);
```

### 5.2 플랫폼 안전 경로 구성

- **절대로** 직접 `\` 또는 `/` 하드코딩 X → 항상 **`Path.Combine`**
- 환경 디렉터리:
```csharp
string appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
```

---

## 6) 비동기 I/O — async/await

### 6.1 간단 비동기

```csharp
await File.WriteAllTextAsync("async.txt", "비동기 쓰기 완료");
string content = await File.ReadAllTextAsync("async.txt");
```

### 6.2 StreamWriter/StreamReader 비동기

```csharp
await using var sw = new StreamWriter("asynclog.txt"); // .NET 6+: IAsyncDisposable 고려
await sw.WriteLineAsync("비동기 로그");

await using var sr = new StreamReader("asynclog.txt");
string? line = await sr.ReadLineAsync();
Console.WriteLine(line);
```

### 6.3 FileStream 비동기 — 큰 파일 복사(진행률 포함)

```csharp
static async Task CopyWithProgressAsync(string src, string dst, IProgress<double>? progress = null, CancellationToken ct = default)
{
    const int BUF = 1 << 20; // 1MB
    await using var input = new FileStream(src, FileMode.Open, FileAccess.Read, FileShare.Read,
                                           bufferSize: BUF, options: FileOptions.Asynchronous | FileOptions.SequentialScan);
    await using var output = new FileStream(dst, FileMode.Create, FileAccess.Write, FileShare.None,
                                            bufferSize: BUF, options: FileOptions.Asynchronous | FileOptions.SequentialScan);

    var buffer = new byte[BUF];
    long total = input.Length, read = 0;
    int n;
    while ((n = await input.ReadAsync(buffer, 0, buffer.Length, ct)) > 0)
    {
        await output.WriteAsync(buffer, 0, n, ct);
        read += n;
        progress?.Report((double)read / total);
    }
    await output.FlushAsync(ct);
}
```

---

## 7) 버퍼링 전략과 `BufferedStream`

- 텍스트/바이너리 리더/라이터는 내부 버퍼를 가지며, 큰 쓰기/읽기 묶음이 효율적
- 추가로 `BufferedStream` 래핑:

```csharp
await using var fs = new FileStream("big.bin", FileMode.Open);
await using var bs = new BufferedStream(fs, bufferSize: 1 << 20);
int n = await bs.ReadAsync(new byte[4096], 0, 4096);
```

> 너무 큰 버퍼는 메모리 낭비, 너무 작은 버퍼는 IOPS 증가. **수십 KB ~ 수 MB** 사이에서 워크로드에 맞춰 튜닝.

---

## 8) CSV/JSON 라인 스트리밍 — 대용량 처리 템플릿

### 8.1 CSV 라인 스트림 (간단 예)

```csharp
static async IAsyncEnumerable<string[]> ReadCsvAsync(string path, [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct = default)
{
    await using var sr = new StreamReader(path);
    string? line;
    while ((line = await sr.ReadLineAsync()) is not null)
    {
        ct.ThrowIfCancellationRequested();
        // 아주 단순한 split, 실전은 CSV 파서 사용 권장
        yield return line.Split(',');
    }
}
```

사용:

```csharp
await foreach (var cols in ReadCsvAsync("data.csv"))
{
    // 처리
}
```

### 8.2 JSON 스트리밍(System.Text.Json)

```csharp
using System.Text.Json;

await using var fs = File.OpenRead("large.json");
var doc = await JsonDocument.ParseAsync(fs, new JsonDocumentOptions { AllowTrailingCommas = true });
// 루트/배열/속성 순회로 메모리 절약적 처리 (또는 Utf8JsonReader로 낮은 레벨 파싱)
```

---

## 9) 안전한 저장 — 원자적(Atomic) 교체

**쓰기 중단(크래시/전원오류)로 파일이 깨지는 것**을 막으려면:  
1) 임시 파일에 완전히 쓴 다음,  
2) **교체**(rename/replace)를 원자적으로 수행.

```csharp
static void AtomicWrite(string path, string content)
{
    string tmp = path + ".tmp";
    File.WriteAllText(tmp, content);
    // Windows: File.Replace로 ACL/메타 유지 + 백업 옵션
    // Cross-platform: 기존 삭제 후 Move가 보통 원자적이진 않음(파일시스템 의존)
    if (OperatingSystem.IsWindows())
        File.Replace(tmp, path, path + ".bak", ignoreMetadataErrors: true);
    else
    {
        if (File.Exists(path)) File.Delete(path);
        File.Move(tmp, path);
    }
}
```

---

## 10) 압축/아카이브 — GZipStream/DeflateStream

```csharp
using System.IO.Compression;

// 압축
await using (var original = File.OpenRead("raw.dat"))
await using (var gz = new GZipStream(File.Create("raw.dat.gz"), CompressionMode.Compress))
{
    await original.CopyToAsync(gz);
}

// 해제
await using (var gz = new GZipStream(File.OpenRead("raw.dat.gz"), CompressionMode.Decompress))
await using (var outFs = File.Create("raw.unzipped"))
{
    await gz.CopyToAsync(outFs);
}
```

---

## 11) MemoryStream / Span / Pipelines (간단 포인터)

### 11.1 MemoryStream — 메모리 상 임시 버퍼

```csharp
using var ms = new MemoryStream();
await using var sw = new StreamWriter(ms);
await sw.WriteAsync("in-memory");
await sw.FlushAsync();
ms.Position = 0;
using var sr = new StreamReader(ms);
Console.WriteLine(await sr.ReadToEndAsync());
```

### 11.2 `Span<T>/Memory<T>` — 고성능 처리(파일 I/O에는 `Read(Span<byte>)` 오버로드 활용)

```csharp
using var fs = File.OpenRead("data.bin");
Span<byte> buf = stackalloc byte[1024];
int n = fs.Read(buf); // 동기 Span 버전
```

> 고성능 파이프라인은 `System.IO.Pipelines` 고려(네트워킹/프로토콜에 유리).

---

## 12) 파일 잠금/접근/공유 — FileAccess/FileShare

```csharp
using var fs = new FileStream(
    "shared.txt",
    FileMode.OpenOrCreate,
    FileAccess.ReadWrite,
    FileShare.Read // 다른 프로세스가 Read는 가능
);
```

- **FileShare.None**: 독점. 다른 프로세스 접근 실패(예외).
- 교차 프로세스/스레드 시나리오는 Lock/Share 전략을 명확히.

---

## 13) 파일 이동/복사/교체

```csharp
File.Copy("a.txt", "b.txt", overwrite: true);
File.Move("b.txt", "c.txt", overwrite: true); // .NET 6+
File.Replace("c.txt", "a.txt", "a.bak");      // Windows 중심
```

> 메타데이터·권한 유지가 중요하면 `Replace`(Windows), 플랫폼별 주의.

---

## 14) 파일 감시 — FileSystemWatcher

```csharp
using var watcher = new FileSystemWatcher
{
    Path = "watched",
    Filter = "*.txt",
    IncludeSubdirectories = true,
    EnableRaisingEvents = true
};

watcher.Created += (s, e) => Console.WriteLine($"생성: {e.FullPath}");
watcher.Changed += (s, e) => Console.WriteLine($"변경: {e.FullPath}");
watcher.Deleted += (s, e) => Console.WriteLine($"삭제: {e.FullPath}");
watcher.Renamed += (s, e) => Console.WriteLine($"이름변경: {e.OldFullPath} -> {e.FullPath}");

Console.WriteLine("감시중... 아무 키나 누르면 종료");
Console.ReadKey();
```

> **이벤트 폭주/중복** 가능 → 디바운스/스로틀, 재시도 큐 등 보강.

---

## 15) 예외 처리 — 빈번한 패턴

```csharp
try
{
    using var fs = File.OpenRead("maybe-missing.txt");
}
catch (FileNotFoundException ex)
{
    // 사용자 친화 메시지 + 대체 경로 안내
}
catch (UnauthorizedAccessException ex)
{
    // 관리자 권한/디렉터리 권한 요구
}
catch (IOException ex) when ((ex.HResult & 0xFFFF) == 32 /* 공유 위반 등 */)
{
    // 잠금/공유 위반: 잠시 대기 후 재시도 전략
}
```

- **빈 catch** 금지, 반드시 로그/재시도/대안 처리.
- `throw;` (원본 스택 유지) vs `throw ex;` (스택 손실).

---

## 16) 대용량 파일 — 청크 처리 + CRC/해시 검증

```csharp
using var hasher = System.Security.Cryptography.SHA256.Create();
await using var fs = new FileStream("big.bin", FileMode.Open, FileAccess.Read, FileShare.Read,
                                    bufferSize: 1 << 20, options: FileOptions.Asynchronous | FileOptions.SequentialScan);

var buffer = new byte[1 << 20];
int n;
while ((n = await fs.ReadAsync(buffer, 0, buffer.Length)) > 0)
{
    hasher.TransformBlock(buffer, 0, n, null, 0);
}
hasher.TransformFinalBlock(Array.Empty<byte>(), 0, 0);
string hex = Convert.ToHexString(hasher.Hash!);
Console.WriteLine(hex);
```

---

## 17) 임시 파일/디렉터리

```csharp
string tmpFile = Path.GetTempFileName(); // 자동 생성(0-byte 파일+고유 이름)
string tmpDir  = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
Directory.CreateDirectory(tmpDir);
```

> 작업 완료 후 **반드시 정리**(삭제).

---

## 18) 메모리 매핑 — MemoryMappedFile (초대용량/랜덤 접근)

```csharp
using System.IO.MemoryMappedFiles;

using var mmf = MemoryMappedFile.CreateFromFile("huge.dat", FileMode.Open);
using var accessor = mmf.CreateViewAccessor(offset: 0, size: 1024);

int value = accessor.ReadInt32(0);
accessor.Write(4, 12345);
```

- 여러 프로세스 간 **공유 메모리** 패턴도 가능.
- **주소공간**과 **스레드 안전** 유의.

---

## 19) 실전 예제 — “로그 롤링 + 비동기 압축 + 원자 교체”

요구사항:
1) `app.log`가 **10 MB를 넘으면** `app_yyyyMMdd_HHmmss.log`로 **회전(roll)**  
2) 회전본은 **백그라운드에서 gzip 압축**  
3) 메인 로그는 **원자 교체**로 안전하게 이어쓰기

```csharp
using System.IO.Compression;
using System.Text;

public sealed class RollingLogger : IAsyncDisposable
{
    private readonly string _logPath;
    private readonly long _maxBytes;
    private readonly SemaphoreSlim _gate = new(1,1);

    public RollingLogger(string logPath, long maxBytes = 10 * 1024 * 1024)
    {
        _logPath = logPath;
        _maxBytes = maxBytes;
        Directory.CreateDirectory(Path.GetDirectoryName(_logPath)!);
    }

    public async Task WriteLineAsync(string line, CancellationToken ct = default)
    {
        await _gate.WaitAsync(ct);
        try
        {
            // 원자 저장(간단 버전): 임시→Move
            string tmp = _logPath + ".tmp";
            string content = line + Environment.NewLine;

            await File.AppendAllTextAsync(tmp, content, new UTF8Encoding(false), ct);
            if (File.Exists(_logPath)) File.AppendAllText(tmp, File.ReadAllText(_logPath)); // 단순 병합 예시(실전은 반대 순서/IO 절감 고려)
            if (File.Exists(_logPath)) File.Delete(_logPath);
            File.Move(tmp, _logPath);

            var fi = new FileInfo(_logPath);
            if (fi.Length > _maxBytes)
                _ = Task.Run(() => RotateAsync(ct)); // fire-and-forget (로그 실패 허용)
        }
        finally
        {
            _gate.Release();
        }
    }

    private async Task RotateAsync(CancellationToken ct)
    {
        string ts = DateTime.Now.ToString("yyyyMMdd_HHmmss");
        string rolled = Path.Combine(Path.GetDirectoryName(_logPath)!, $"app_{ts}.log");
        try
        {
            // 회전
            if (File.Exists(rolled)) File.Delete(rolled);
            File.Move(_logPath, rolled, overwrite: false);

            // 압축
            await using var input = File.OpenRead(rolled);
            await using var gz = new GZipStream(File.Create(rolled + ".gz"), CompressionMode.Compress);
            await input.CopyToAsync(gz, ct);

            File.Delete(rolled);
        }
        catch (Exception ex)
        {
            // 실패 시 회전본을 남겨 디버깅 가능
            Console.Error.WriteLine(ex);
        }
    }

    public ValueTask DisposeAsync()
    {
        _gate.Dispose();
        return ValueTask.CompletedTask;
    }
}
```

> 단순화를 위해 성능/원자성 세부는 일부 생략. 실전은 **한 방향 append + 파일 핸들 유지**가 더 효율적이며, 회전 시 **핸들 교체** 전략을 쓴다.

---

## 20) 체크리스트

**설계**
- [ ] 텍스트면 `StreamReader/Writer` + UTF-8, 바이너리면 `FileStream + BinaryReader/Writer`
- [ ] 대용량/스트리밍은 **청크 + async** (`ReadAsync/WriteAsync/CopyToAsync`)
- [ ] Random vs Sequential 접근 힌트 지정 (`FileOptions`)

**안전성**
- [ ] 저장은 **임시 파일 → 원자 교체**(특히 크래시/전원오류 대비)
- [ ] `using`/`await using`으로 **자원 누수 방지**
- [ ] 예외는 **구체적으로** 잡고 로그/재시도

**성능**
- [ ] 적절한 **버퍼 크기**(수십 KB~수 MB)와 **옵션**(Asynchronous, SequentialScan)
- [ ] **불필요한 다중 Flush/Close 금지**
- [ ] 반복 라인 처리 시 **IAsyncEnumerable**로 메모리 상한 유지

**호환성**
- [ ] 경로는 항상 **`Path.Combine`** (플랫폼 중립)
- [ ] 인코딩은 가능하면 **UTF-8** 고정

---

## 21) 요약 표

| 범주 | API/타입 | 핵심 포인트 |
|---|---|---|
| 간단 텍스트 | `File.Read/WriteAllText/Lines` | 빠른 프로토타이핑 |
| 스트림 텍스트 | `StreamReader/Writer` | 인코딩/버퍼 제어 |
| 바이너리 | `FileStream`, `BinaryReader/Writer` | 정형 데이터 |
| 비동기 | `ReadAsync/WriteAsync/CopyToAsync` | UI/서버에서 필수 |
| 버퍼링 | 내부 버퍼, `BufferedStream` | IOPS↓ 처리량↑ |
| 경로/폴더 | `Path/Directory` | 안전한 조립/조작 |
| 압축 | `GZipStream` | 로그/백업 축소 |
| 감시 | `FileSystemWatcher` | 실시간 반응 |
| 메모리맵 | `MemoryMappedFile` | 초대용량/랜덤 접근 |
| 원자 저장 | `File.Replace/Move` | 내구성 보장 |

---

## 22) 마무리

- **Stream 사고방식**: “어디에”가 아니라 “**흐름을 어떻게**” 읽고/쓴다.  
- **async/await**로 **응답성/처리량**을 확보하고, 파일 시스템의 **특성(버퍼/옵션/잠금)**을 이해해야 한다.  
- 본 문서의 템플릿과 패턴(청크 복사, 원자 저장, 감시, 압축, 라인 스트리밍)을 조합하면, **작은 유틸부터 대용량 파이프라인**까지 안정적으로 구성할 수 있다.
