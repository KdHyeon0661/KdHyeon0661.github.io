---
layout: post
title: 컴퓨터시스템 - 동시성 프로그래밍
date: 2025-09-10 17:20:23 +0900
category: 컴퓨터시스템
---
# 동시성 프로그래밍

## 0) 동시성 프로그래밍이란?

**동시성(Concurrency)** 은 여러 작업을 *겹쳐서* 다루는 구조/기법입니다. 실제 같은 시각에 여러 CPU에서 수행되는 **병렬성(Parallelism)** 과는 구별됩니다. 한 코어에서도 인터리빙으로 동시처럼 보이게 진행할 수 있습니다.

- **목표**
  - **응답성**: 느린 I/O(디스크/네트워크/사용자 입력) 대기 중에도 다른 일 진행
  - **처리량**: 멀티코어·멀티소켓을 활용해 더 많은 작업 처리
  - **구조화**: 독립적인 작업 단위를 나눠 설계·배치(프로세스·스레드·코루틴)

> 본 가이드는 **프로세스 기반 동시성**에 초점을 둡니다. 스레드 대비 장단점, IPC, 실전 패턴, 안전 API, 운영/보안/성능까지 한 번에 정리합니다.

---

## 1) 왜 “프로세스 기반” 동시성인가?

### 장점
- **격리(고립성)**: 독립 주소 공간 → 한 프로세스의 메모리/UB가 다른 프로세스에 전파되지 않음.
- **보안/권한 분리**: UID/GID, 파일시스템 루트(`chroot`), 리눅스 **capabilities**, **seccomp**로 최소권한 실행.
- **런타임 제약 우회**: 예) Python **GIL** 회피를 멀티프로세스로.
- **운영과 복구 용이**: 코어덤프·재시작·감시(슈퍼바이저) 구조가 단순. 프로세스 단위 롤링/격리.

### 단점
- **생성/전환 비용↑**: `fork/exec`는 스레드 생성보다 무겁습니다(페이지 테이블·COW 비용).
- **공유 메모리 기본 부재**: 명시적 **IPC**(파이프/소켓/공유메모리/메시지큐)가 필요.
- **메모리 복제 부담**: 부모의 큰 힙은 COW 깨짐 시 물리 메모리 압박.

### 판단 요령
- **안정성/격리/보안 최우선** → 프로세스 유리
- **미세 공유·저지연 공유 메모리 필요** → 스레드, 또는 프로세스+공유메모리(복잡)
- **I/O 중심 서버** → 프리포크/프로세스 풀, 혹은 이벤트(epoll)+워커 혼합

---

## 2) 프로세스 생명주기 & 안전 API

| 목적 | 우선 고려할 API | 비고 |
|---|---|---|
| 생성/실행 | `posix_spawn` → `fork`+`exec*` | 멀티스레드 환경에서는 **`posix_spawn` 권장**(fork 안전성) |
| 종료/회수 | `waitpid`, `SIGCHLD` | 좀비 수거, 재시작(Respawn) |
| 신호 | `sigaction`, `sigprocmask`, `signalfd` | 비동기 이벤트를 **동기 FD**로 처리 가능 |
| FD 상속 제어 | `O_CLOEXEC`, `FD_CLOEXEC` | `exec` 시 FD 유출 방지(경로적 버그 예방) |
| fork-안전 | `pthread_atfork` | 락 일관성 확보(불가피하게 `fork` 쓸 때) |

### 2.1 `posix_spawn`가 기본값이어야 하는 이유
멀티스레드 프로세스에서 `fork()` 직후 **자식에는 한 스레드만** 남아 잠금 상태가 불명확해질 수 있습니다. `posix_spawn()`은 커널/런타임이 안전하게 `exec` 경로를 구성해 이러한 위험을 줄입니다.

```c
#include <spawn.h>
#include <unistd.h>
extern char **environ;

int spawn_worker(const char* path, char* const argv[]) {
    pid_t pid;
    int rc = posix_spawn(&pid, path, NULL, NULL, argv, environ);
    return rc == 0 ? (int)pid : -1;
}
```

### 2.2 FD 유출 방지: CLOEXEC 플래그
자식 `exec` 후에도 열려 있으면 안 되는 FD에는 **무조건** `O_CLOEXEC`(생성 시) 또는 `FD_CLOEXEC`(사후 설정)을 부여합니다.

```c
int s = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0); // 생성 시
// 또는
int fl = fcntl(fd, F_GETFD);
fcntl(fd, F_SETFD, fl | FD_CLOEXEC); // 사후
```

---

## 3) IPC(프로세스 간 통신) 카탈로그 & 선택 가이드

| 수단 | 장점 | 단점 | 전형적 용도 |
|---|---|---|---|
| **파이프(`pipe/pipe2`)** | 간단·저오버헤드(커널 버퍼) | 단방향·익명 | 필터/파이프라인 |
| **FIFO(네임드 파이프)** | 파일경로로 연결 | 파일시스템 필요 | 단순 다자 연결 |
| **UNIX 도메인 소켓** | 양방향·스트림/데이터그램·**FD 전달** | 로컬 전용 | 서버-워커 협업, 제어채널 |
| **TCP/UDP 소켓** | 네트워크 투명 | 비용/보안 | 분산/마이크로서비스 |
| **공유메모리(`mmap`/`shm_open`)** | 초저지연·대역폭 큼 | 동기화 설계 난이도↑ | 고성능 큐/버퍼 |
| **메시지 큐**(POSIX/SysV) | 커널 큐 관리 | 크기·성능 제약 | 제어/신호 메시지 |

> **FD 전달(SCM_RIGHTS)** 은 리슨 소켓/오픈 파일을 워커에 넘기는 **핵심 기술**입니다(§4).

---

## 4) 파일 디스크립터(FD) 전달 — SCM_RIGHTS

**UNIX 도메인 소켓**으로 **열린 FD**를 워커에게 넘길 수 있습니다. 마스터가 리슨 FD를 열고 워커에게 넘기면, 워커는 자신이 직접 `socket`/`bind` 없이 `accept`/`read`를 수행할 수 있습니다.

```c
// send_fd.c : 소켓으로 FD 전달 (마스터 → 워커)
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

int send_fd(int sock, int fd_to_send){
    struct msghdr msg = {0};
    char buf[CMSG_SPACE(sizeof(int))];
    memset(buf, 0, sizeof(buf));
    struct iovec io = { .iov_base = (void*)"X", .iov_len = 1 };
    msg.msg_iov = &io; msg.msg_iovlen = 1;

    msg.msg_control = buf; msg.msg_controllen = sizeof(buf);
    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET; cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));
    memcpy(CMSG_DATA(cmsg), &fd_to_send, sizeof(int));
    msg.msg_controllen = cmsg->cmsg_len;

    return sendmsg(sock, &msg, 0);
}
```

```c
// recv_fd.c : 소켓으로 FD 수신 (워커)
int recv_fd(int sock){
    struct msghdr msg = {0};
    char m_buffer[1];
    struct iovec io = { .iov_base = m_buffer, .iov_len = sizeof(m_buffer) };
    msg.msg_iov = &io; msg.msg_iovlen = 1;

    char c_buffer[CMSG_SPACE(sizeof(int))];
    msg.msg_control = c_buffer; msg.msg_controllen = sizeof(c_buffer);

    if (recvmsg(sock, &msg, 0) <= 0) return -1;
    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    if (cmsg && cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_RIGHTS){
        int fd; memcpy(&fd, CMSG_DATA(cmsg), sizeof(int));
        return fd;
    }
    return -1;
}
```

> 참고: 리눅스는 발신자 **자격증명(SCM_CREDENTIALS)** 전달도 지원합니다(워크플로우 감사/권한 검증에 유용).

---

## 5) 프리포크(Pre-fork) 서버 — 견고판

### 5.1 핵심 설계 포인트
- **부모**가 리슨 소켓을 만들고 **N개 자식**을 미리 `fork` → 각 자식이 `accept()`로 요청 처리.
- 리눅스 최신 커널에서는 `accept` 웨이크업이 개선되었지만, 다수 워커에서 같은 리스너를 감시할 땐 **`SO_REUSEPORT`** 로 **코어별 리스너**를 두는 것도 효과적.
- **SIGPIPE 무시**, **EINTR 재시도**, **좀비 수거** 필수.
- **권한 강하(drop privileges)**, **CLOEXEC** 일괄 적용.

### 5.2 예제: 프리포크 TCP 에코(강화 옵션 포함)

```c
// prefork_echo_strong.c
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <errno.h>
#include <netinet/in.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define PORT 9000
#define NWORKERS 4
#define BSZ 8192

static int create_listener_reuseport(void){
    int s = socket(AF_INET6, SOCK_STREAM | SOCK_CLOEXEC, 0);
    int on=1, v6only=0;
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
    setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &on, sizeof(on));
    setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));

    struct sockaddr_in6 a = {0};
    a.sin6_family = AF_INET6; a.sin6_addr = in6addr_any; a.sin6_port = htons(PORT);
    if (bind(s, (struct sockaddr*)&a, sizeof(a)) < 0) { perror("bind"); exit(1); }
    if (listen(s, 512) < 0) { perror("listen"); exit(1); }
    return s;
}
static void reap(int sig){ (void)sig; while (waitpid(-1, NULL, WNOHANG) > 0) {} }

static void serve(int ls){
    for (;;){
        int c = accept4(ls, NULL, NULL, SOCK_CLOEXEC);
        if (c < 0){ if (errno==EINTR) continue; perror("accept"); continue; }
        char buf[BSZ];
        for (;;){
            ssize_t n = read(c, buf, BSZ);
            if (n > 0){
                ssize_t w=0; while (w<n){ ssize_t k=write(c, buf+w, n-w);
                    if (k<0){ if (errno==EINTR) continue; goto OUT; } w+=k; }
            } else if (n==0) break; else { if (errno==EINTR) continue; break; }
        }
OUT:    close(c);
    }
}

int main(void){
    signal(SIGPIPE, SIG_IGN);
    struct sigaction sa = { .sa_handler = reap, .sa_flags = SA_RESTART };
    sigemptyset(&sa.sa_mask); sigaction(SIGCHLD, &sa, NULL);

    // 코어별 리스너(각 자식이 자체 리스너 생성: SO_REUSEPORT)
    for (int i=0;i<NWORKERS;i++){
        pid_t pid = fork();
        if (pid==0){
            int ls = create_listener_reuseport();
            serve(ls);
            exit(0);
        }
    }
    for(;;) pause();
}
```

**해설**
- `SO_REUSEPORT`: 각 워커가 **자기 리스너**를 가짐 → 커널이 CPU/해시 기반으로 분배, 락 경합 완화.
- `accept4(..., SOCK_CLOEXEC)`: FD 유출 방지.
- `SA_RESTART`: 신호 후 시스템콜 자동 재시작(일부 콜 제외).

---

## 6) 파이프라인 (Producer → Filter → Consumer)

유닉스 철학: “작은 프로그램을 조합하여 큰 일을”. 각 단계를 프로세스로 나누고 `pipe` 로 연결합니다.

```c
// pipeline_wc.c : 부모가 텍스트 공급 → 자식이 wc -l로 라인수 세기
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(){
    int p[2]; if (pipe(p) < 0) { perror("pipe"); return 1; }
    pid_t pid = fork();
    if (pid==0){
        dup2(p[0], 0); close(p[0]); close(p[1]);
        execlp("wc", "wc", "-l", NULL);
        perror("exec wc"); _exit(1);
    }
    close(p[0]);
    for (int i=0;i<1000;i++) dprintf(p[1], "line %d\n", i);
    close(p[1]); // EOF → wc 종료
    wait(NULL);
    return 0;
}
```

---

## 7) 공유 메모리 + **프로세스 간** 동기화 (뮤텍스/조건변수)

### 7.1 프로세스 공유 속성
프로세스 간 `pthread_mutex`/`pthread_cond`를 쓰려면 **속성**을 `PTHREAD_PROCESS_SHARED` 로 설정해야 합니다.

```c
// shm_pthread_shared.c : 프로세스 간 큐(조건변수로 동기화)
#define _GNU_SOURCE
#include <pthread.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

#define QN 16

typedef struct {
  pthread_mutex_t m;
  pthread_cond_t  cv_not_full;
  pthread_cond_t  cv_not_empty;
  int q[QN], head, tail, cnt;
} shared_t;

int main(){
  int fd = shm_open("/shm.q", O_CREAT|O_RDWR, 0600);
  ftruncate(fd, sizeof(shared_t));
  shared_t* sh = mmap(NULL, sizeof(*sh), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
  close(fd);

  // 최초 초기화(간소화: 첫 실행 가정)
  pthread_mutexattr_t ma; pthread_condattr_t ca;
  pthread_mutexattr_init(&ma); pthread_mutexattr_setpshared(&ma, PTHREAD_PROCESS_SHARED);
  pthread_condattr_init(&ca);  pthread_condattr_setpshared(&ca, PTHREAD_PROCESS_SHARED);
  pthread_mutex_init(&sh->m, &ma);
  pthread_cond_init(&sh->cv_not_full, &ca);
  pthread_cond_init(&sh->cv_not_empty, &ca);
  sh->head=sh->tail=sh->cnt=0;

  if (fork()==0){
    // 소비자
    for (int i=0;i<100;i++){
      pthread_mutex_lock(&sh->m);
      while (sh->cnt==0) pthread_cond_wait(&sh->cv_not_empty, &sh->m);
      int x = sh->q[sh->head]; sh->head = (sh->head+1)%QN; sh->cnt--;
      pthread_cond_signal(&sh->cv_not_full);
      pthread_mutex_unlock(&sh->m);
      printf("consumed %d\n", x);
    }
    _exit(0);
  }

  // 생산자
  for (int i=0;i<100;i++){
    pthread_mutex_lock(&sh->m);
    while (sh->cnt==QN) pthread_cond_wait(&sh->cv_not_full, &sh->m);
    sh->q[sh->tail]=i; sh->tail=(sh->tail+1)%QN; sh->cnt++;
    pthread_cond_signal(&sh->cv_not_empty);
    pthread_mutex_unlock(&sh->m);
  }
  wait(NULL);
  shm_unlink("/shm.q");
  return 0;
}
```

### 7.2 **Robust Mutex**(고장 회복)
작업 중 죽은 프로세스가 **락을 쥔 채 종료**하면? `PTHREAD_MUTEX_ROBUST` 를 쓰면 다음 획득자가 `EOWNERDEAD` 를 감지해 **상태 복구** 후 `pthread_mutex_consistent` 로 락 일관성을 회복할 수 있습니다.

---

## 8) 제로카피 I/O (고성능 서버)

- **`sendfile`**: 파일 → 소켓으로 커널 내에서 바로 복사(사용자 공간 경유 없음).
- **`splice`/`tee`**: 파이프를 경유해 FD 간 데이터 이동(고급).
- **주의**: TLS가 끼면 일반적으로 사용자 공간 처리 필요(리눅스 kTLS가 일부 완화). 큰 파일 전송은 **`sendfile`** 부터 고려.

```c
// sendfile_skel.c : 간단 파일→소켓 전송
#include <sys/sendfile.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

off_t send_file(int out_fd, const char* path){
    int in_fd = open(path, O_RDONLY|O_CLOEXEC);
    struct stat st; fstat(in_fd, &st);
    off_t sent = 0;
    while (sent < st.st_size){
        ssize_t n = sendfile(out_fd, in_fd, &sent, st.st_size - sent);
        if (n < 0){ if (errno==EINTR) continue; break; }
    }
    close(in_fd);
    return sent;
}
```

---

## 9) 신호·타임아웃·정리

- **SIGCHLD**: 좀비 수거(§5 예제).
- **SIGPIPE**: 닫힌 피어로 `write` 시 프로세스 종료 → **무시** 또는 `MSG_NOSIGNAL`.
- **EINTR**: 신호로 중단된 시스템콜 → **재시도** 또는 `SA_RESTART`.
- **`signalfd`**: 신호를 **FD**로 받아 이벤트 루프에서 동기 처리.

```c
// signalfd 예시
#include <sys/signalfd.h>
#include <signal.h>
int sfd_setup(){
  sigset_t ss; sigemptyset(&ss);
  sigaddsig(&ss, SIGTERM); sigaddsig(&ss, SIGINT);
  sigprocmask(SIG_BLOCK, &ss, NULL);
  return signalfd(-1, &ss, SFD_CLOEXEC|SFD_NONBLOCK);
}
```

---

## 10) 운영/배포: 슈퍼바이저, 소켓 활성화, cgroups

### 10.1 슈퍼바이저
- **systemd**/`supervisord` 로 서비스화. 크래시 시 자동 재시작, 로그 관리.
- **Crash-only** 설계: 비정상 종료에도 데이터 일관성 유지(저널링/리플레이/멱등).

### 10.2 **소켓 활성화**(systemd)
systemd가 리슨 소켓을 열고 **워커에 넘겨줍니다**. 서버는 환경변수 `LISTEN_FDS`/`LISTEN_PID`를 확인해 **이미 열린 FD**를 사용(노다운 타이밍 개선).

```c
// sd_listen.c : systemd가 넘긴 리스너 재사용
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int get_systemd_listener(){
  const char* e1 = getenv("LISTEN_PID");
  const char* e2 = getenv("LISTEN_FDS");
  if (!e1 || !e2) return -1;
  if ((pid_t)atoi(e1) != getpid()) return -1;
  int n = atoi(e2);
  // systemd는 FD를 3부터 연속으로 넘김
  return n >= 1 ? 3 : -1;
}
```

### 10.3 **cgroups v2** 리소스 제한
- CPU/메모리/PID/IO를 **컨트롤 그룹**으로 제한해 **폭주 방지**.
- systemd 단위에서 `CPUAccounting`, `MemoryMax=` 등으로 구성.

---

## 11) 보안 하드닝

- **권한 강하**: 초기화 후 `setgid` → `setuid` 로 비특권 전환.
- **Chroot/네임스페이스**: `chroot` 또는 컨테이너 네임스페이스로 파일시스템 격리.
- **Seccomp**: 필요 시스템콜만 허용(필터 BPF). 공격면 축소.
- **Capabilities**: `CAP_NET_BIND_SERVICE` 등 필요한 능력만 보유.

```c
// 간단 권한 강하
#include <unistd.h>
#include <sys/types.h>
int drop_priv(uid_t uid, gid_t gid){
  if (setgid(gid)<0) return -1;
  if (setuid(uid)<0) return -1;
  return 0;
}
```

---

## 12) 성능·스케일링 힌트

- **워커 수**: CPU-바운드라면 물리 코어 수±α. I/O-바운드는 더 많아도 좋지만 **컨텍스트 스위치/메모리** 고려.
- **네트워크 튜닝**: `SO_REUSEPORT`, `TCP_NODELAY`, 적절한 `SO_RCVBUF/SO_SNDBUF`, `somaxconn`.
- **관찰**: `ss -tlnp`, `strace`, `perf`, eBPF(bpftrace)로 핫패스·블로킹 구간 확인.
- **제로카피**: 정적 파일/대량 전송은 `sendfile`/`splice` 검토.

### 12.1 Amdahl / Little
$$
S(N)=\frac{1}{(1-P)+\frac{P}{N}},\quad
L=\lambda W
$$
- 병렬화 비율 \(P\)를 높이는 핵심은 **공유/직렬 구간 축소(IPC·락)** 이며, 큐 체류 \(L\) 관리는 **유한 큐+백프레셔**로.

---

## 13) 자주 겪는 오류 & 해결

| 증상 | 원인 | 해결 |
|---|---|---|
| 좀비 누적 | `waitpid` 미호출 | `SIGCHLD` 핸들러에서 **반복 수거** |
| `EADDRINUSE` 재시작 실패 | TIME_WAIT/포트 점유 | `SO_REUSEADDR` (+ `SO_REUSEPORT` 고려) |
| 클라이언트 쓰기 중 종료 | `SIGPIPE` | `signal(SIGPIPE, SIG_IGN)` or `MSG_NOSIGNAL` |
| 입출력 중단 | `EINTR` | 재시도 루프 또는 `SA_RESTART` |
| FD 유출 | `exec` 후 열린 FD 유지 | `O_CLOEXEC`/`FD_CLOEXEC` 철저 |
| 성능 저하 | 워커 과다/IPC 과잉 | 워커 수 튜닝, 데이터 배치/공유 최소화 |

---

## 14) 미니 요리책(Cookbook)

### 14.1 안전한 `fork`+`exec`(멀티스레드 환경)
- 가능하면 **`posix_spawn`** 사용.
- 불가피한 경우 `pthread_atfork` 로 **락 상태** 정리.

```c
pthread_mutex_t M = PTHREAD_MUTEX_INITIALIZER;
void prepare(){ pthread_mutex_lock(&M); }
void parent(){  pthread_mutex_unlock(&M); }
void child(){   pthread_mutex_init(&M, NULL); } // 자식에서 재초기화
pthread_atfork(prepare, parent, child);
```

### 14.2 `prctl(PR_SET_PDEATHSIG)`
부모가 죽으면 자식에게 신호 전달(고아 방지/빠른 종료).

```c
#include <sys/prctl.h>
prctl(PR_SET_PDEATHSIG, SIGTERM);
```

### 14.3 두 파이프를 이용한 **양방향** 부모-자식 통신
```c
int p2c[2], c2p[2]; pipe(p2c); pipe(c2p);
if (fork()==0){
  dup2(p2c[0],0); dup2(c2p[1],1);
  close(p2c[1]); close(c2p[0]); /* ... exec ... */
} else {
  close(p2c[0]); close(c2p[1]); /* 부모는 write(p2c[1]) / read(c2p[0]) */
}
```

### 14.4 `ulimit`/`setrlimit` 로 FD·메모리 상한
```c
#include <sys/resource.h>
struct rlimit rl = { .rlim_cur=65536, .rlim_max=65536 };
setrlimit(RLIMIT_NOFILE, &rl);
```

---

## 15) 체크리스트(운영/보안/성능)

- [ ] `posix_spawn` 우선, `fork` 사용 시 `pthread_atfork`·**async-signal-safe** 준수  
- [ ] 모든 리슨·연결 FD에 `CLOEXEC` 적용, 출력 경로 **에러 처리(EINTR, EPIPE)**  
- [ ] `SIGCHLD` 핸들러에서 **좀비 수거**, 크래시 시 **재시작 전략**  
- [ ] **권한 강하**(setuid/setgid), **capabilities** 최소화, **seccomp** 필터  
- [ ] **FD 전달(SCM_RIGHTS)**·공유메모리·메시지큐 등 **IPC 선택**을 문서화  
- [ ] 대용량 전송은 **sendfile/splice**, 로그/메트릭으로 **핫패스 가시화**  
- [ ] **유한 큐 + 백프레셔**로 폭주 억제, 타임아웃·재시도 정책 명확화  
- [ ] systemd **소켓 활성화**·cgroups v2 리소스 한계 설정  
- [ ] 회귀 테스트: `strace`/`perf`/eBPF/부하도구로 성능·정확성 동시 검증

---

## 16) 결론

**프로세스 기반 동시성**은 격리·보안·운영 편의가 뛰어나, 프록시/웹/ETL/런타임 제약 회피 등에서 여전히 강력한 선택입니다.  
핵심은 ① **안전한 생성/실행 경로**(`posix_spawn`, CLOEXEC), ② **맞춤 IPC**(FD 전달/공유메모리/파이프), ③ **신호·좀비·EINTR·SIGPIPE** 등 운영 이슈 처리, ④ **성능**(REUSEPORT·제로카피·리소스 상한)입니다.  
본 가이드의 프리포크 서버·파이프라인·프로세스 공유 동기화 예제를 바탕으로, 워크로드에 맞는 **안정적이고 빠른 프로세스 동시성 아키텍처**를 구축하세요.