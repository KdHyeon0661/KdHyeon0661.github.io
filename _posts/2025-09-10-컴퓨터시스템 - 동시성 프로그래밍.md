---
layout: post
title: 컴퓨터시스템 - 동시성 프로그래밍
date: 2025-09-10 17:20:23 +0900
category: 컴퓨터시스템
---
# 동시성 프로그래밍

---

## 0) 동시성 프로그래밍이란?

**동시성(Concurrency)** 은 “여러 작업을 *겹쳐서* 다루는 구조/기법”입니다. 실제로 같은 순간에 여러 CPU에서 동시에 실행(**병렬성, Parallelism**)될 수도 있고, 하나의 CPU에서 빠르게 전환하며 *동시처럼 보이게* 실행될 수도 있습니다.

- **목표**
  - **응답성**: 느린 I/O(디스크/네트워크/사용자 입력)를 기다리는 동안 다른 일을 진행
  - **처리량**: 멀티코어·멀티소켓 자원을 활용해 더 많은 업무를 빠르게 처리
  - **구조화**: 복잡한 문제를 독립 “작업 단위(프로세스·스레드·코루틴)”로 나눠 설계

- **동시성 vs 병렬성**
  - 동시성: 여러 작업의 **구성/상호작용**에 초점 (스케줄링/인터리빙)
  - 병렬성: **동일 시점**에 여러 작업을 **물리적으로** 수행 (멀티코어)

> 이 문서에서는 동시성 구현 수단 중 **프로세스(process)** 를 중심으로 설명합니다. 스레드와 비교 시 장점/단점, IPC, 패턴, 실전 코드까지 다룹니다.

---

## 1) 왜 “프로세스 기반” 동시성인가?

### 장점
- **격리(고립성)**: 각 프로세스는 독립 주소 공간을 가짐 → 한 프로세스의 메모리 오류가 다른 프로세스를 망치지 않음.
- **보안/권한 분리**: 프로세스별 유저/그룹 ID, `chroot`, capability 등으로 최소 권한 실행.
- **언어/런타임 제약 우회**: (예) Python의 GIL을 **멀티프로세스**로 회피.
- **예측 가능한 디버깅**: 코어덤프·리스타트·감시(슈퍼바이저) 구조가 단순.

### 단점
- **생성/컨텍스트 스위치 비용↑**: `fork/exec`는 스레드 생성보다 비쌈(단, COW로 초기 복사는 싸지만 여전히 비싸다).
- **공유 메모리가 기본 없음**: 데이터 교환은 **IPC** 필요(파이프/소켓/공유메모리/메시지큐 등).
- **메모리 중복**: 큰 힙을 가진 부모를 다수 fork하면 COW가 깨질 때 메모리 압박.

### 요약 판단
- **안정성/격리/보안** 최우선 → 프로세스
- **고성능 메모리 공유/미세 동기화** 필요 → 스레드 또는 프로세스+공유메모리(복잡)
- **I/O 중심 서버(확장성)** → 프리포크/프로세스풀, 또는 이벤트+스레드 혼합

---

## 2) POSIX 프로세스 동시성 핵심 API 지도

| 목적 | 주요 API | 한 줄 설명 |
|---|---|---|
| 생성/실행 | `fork`, `vfork`(권장X), `execve`, `exec*`, `posix_spawn` | 새 프로세스 만들고 다른 프로그램 실행 |
| 종료/회수 | `wait`, `waitpid`, `waitid`, `SIGCHLD` | 좀비(Zombie) 수거 |
| 신호 | `signal`, `sigaction`, `sigprocmask`, `kill` | 비동기 이벤트 전달/처리 |
| 파이프 | `pipe`, `pipe2`, `dup2` | 단방향 바이트 스트림 |
| 소켓 | `socketpair`, `AF_UNIX`, `sendmsg/recvmsg`(FD전달) | 양방향/메시지/FD 공유 |
| 공유메모리 | `shm_open`+`mmap`, `mmap(MAP_SHARED)`, SysV shm | 주소공간을 일부 공유 |
| 동기화 | **POSIX 세마포어** `sem_init/sem_post/sem_wait`(pshared=1) | 프로세스 간 락/카운팅 |
| 파일잠금 | `flock`, `fcntl(F_SETLK/F_SETLKW)` | 레코드/파일 단위 상호배제 |
| 타임아웃 | `select/poll/epoll`(I/O), `alarm`, `timerfd` | 대기와 깨어남 제어 |
| 자원제한 | `setrlimit`, cgroup(리눅스) | 폭주 방지 |

---

## 3) IPC(프로세스 간 통신) 빠른 카탈로그

| 수단 | 장점 | 단점 | 용도 |
|---|---|---|---|
| **파이프(pipe)** | 간단/빠름, 부모-자식 연결에 적합 | 익명, 단방향 | 필터/파이프라인 |
| **명명파이프(FIFO)** | 경로로 접근, 무관계 프로세스 연결 | 파일시스템 필요 | 간단 다자 연결 |
| **UNIX 도메인 소켓** | 양방향, **FD 전달(핵심)**, 스트림/데이터그램 | 로컬 전용 | 서버-워커 협업 |
| **TCP/UDP 소켓** | 네트워크 가능 | 오버헤드/보안 | 분산/마이크로서비스 |
| **공유메모리+세마포어** | 매우 빠름 | 동기화 설계 난이도↑ | 고성능 큐/버퍼 |
| **메시지 큐** | 커널 관리 큐 | 크기/성능 제약 | 제어 메시지 |

> **FD 전달**(SCM_RIGHTS)은 “리스너 FD를 워커에게 건네기” 같은 고급 패턴의 핵심입니다.

---

## 4) 동시성 패턴 (프로세스 버전)

### 4.1 프리포크(Pre-fork) 서버
- **부모**가 리슨 소켓을 만들고 **N개의 자식**을 미리 `fork` → 각 자식이 `accept()` → 요청 처리.
- 장점: 워커 크래시가 전체에 영향 제한, 언어 런타임(GIL) 제약 회피.
- 이슈: **쓰던링 헤드(Thundering Herd)** → 최신 커널은 `accept` 웨이크업 개선, 또는 `SO_REUSEPORT`로 포트 분할.

### 4.2 프로세스 풀 & 작업 전달
- 부모가 **작업 큐**(UNIX 소켓/공유메모리 큐)를 관리 → 워커가 **pull** 또는 라운드로빈 할당.
- 파일/소켓 FD는 **SCM_RIGHTS**로 전달.

### 4.3 파이프라인(Producer → Filter → Consumer)
- 각 단계가 독립 프로세스, `pipe`로 연결. 유닉스 철학 “작은 것들을 연결”.

### 4.4 팬아웃/팬인(Fan-out/Fan-in)
- 부모가 N개 워커를 띄워 병렬 처리 → 결과를 **공유메모리**나 소켓으로 모아 집계.

---

## 5) 실전 ①: 프리포크 에코 서버(간결판, C)

```c
// prefork_echo.c : 리눅스/유닉스 간단 프리포크 TCP 에코
#include <arpa/inet.h>
#include <errno.h>
#include <netinet/in.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <unistd.h>

#define PORT 9000
#define NWORKERS 4
#define BSZ 4096

static int create_listener(void){
    int s = socket(AF_INET6, SOCK_STREAM, 0);
    int on=1, v6only=0;
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
    setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));

    struct sockaddr_in6 addr = {0};
    addr.sin6_family = AF_INET6;
    addr.sin6_addr   = in6addr_any;
    addr.sin6_port   = htons(PORT);
    if (bind(s,(struct sockaddr*)&addr,sizeof(addr))<0) { perror("bind"); exit(1); }
    if (listen(s, 128)<0) { perror("listen"); exit(1); }
    return s;
}

static void worker_loop(int ls){
    for (;;) {
        int c = accept(ls, NULL, NULL);
        if (c < 0) { if (errno==EINTR) continue; perror("accept"); continue; }
        char buf[BSZ];
        ssize_t n;
        while ((n = read(c, buf, BSZ)) > 0) {
            ssize_t w=0; while (w<n) { ssize_t k=write(c, buf+w, n-w); if (k<0){ if(errno==EINTR)continue; n=-1;break;} w+=k; }
        }
        close(c);
    }
}

static void reap(int sig){
    (void)sig;
    while (waitpid(-1, NULL, WNOHANG) > 0) {}
}

int main(void){
    signal(SIGPIPE, SIG_IGN);
    struct sigaction sa = { .sa_handler=reap, .sa_flags=SA_RESTART };
    sigemptyset(&sa.sa_mask); sigaction(SIGCHLD, &sa, NULL);

    int ls = create_listener();
    for (int i=0;i<NWORKERS;i++){
        pid_t pid = fork();
        if (pid==0){ worker_loop(ls); exit(0); }
    }
    // 부모: 워커 감시 (간략히 대기)
    for(;;) pause();
}
```

**포인트**
- 모든 워커가 **같은 리슨 FD**에서 `accept()` → 커널이 분배.
- `SIGCHLD` 핸들러에서 **좀비 수거**.
- 실제 서비스는 워커가 죽으면 **재생성**(respawn) 로직 포함.

---

## 6) 실전 ②: 파이프라인 구성(부모→자식 gzip)

```c
// pipe_gzip.c : 부모가 생성한 데이터를 자식(gzip)에 파이프로 압축
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
    int p[2]; pipe(p);
    pid_t pid = fork();
    if (pid==0){
        // child: gzip stdin->stdout
        dup2(p[0], 0); close(p[0]); close(p[1]);
        execlp("gzip","gzip","-c",NULL);
        perror("exec gzip"); exit(1);
    }
    // parent: write data then read compressed from child's stdout via another pipe or redirect to file
    // 간단히 stdout로 리다이렉트 예
    close(p[0]);
    const char *msg = "Hello concurrent process pipeline!\n";
    for (int i=0;i<5;i++) write(p[1], msg, strlen(msg));
    close(p[1]);
    // gzip은 부모 stdout으로 압축 데이터 출력하도록 별도 구성 필요(여기선 shell 리다이렉트 권장)
    return 0;
}
```

> 연습: **양방향** 파이프라인은 `pipe` 2쌍이 필요(부모→자식, 자식→부모). 실무는 **UNIX 도메인 소켓**(양방향·FD전달)을 선호.

---

## 7) 실전 ③: 공유 메모리 + 세마포어로 안전한 카운터

```c
// shm_sem_counter.c : 다수 프로세스가 공유메모리의 카운터를 증가
#define _GNU_SOURCE
#include <fcntl.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <unistd.h>

typedef struct {
    sem_t  sem;     // 프로세스 간 공유 세마포어
    long   value;
} shared_t;

int main(){
    int fd = shm_open("/shm.counter", O_CREAT|O_RDWR, 0600);
    ftruncate(fd, sizeof(shared_t));
    shared_t* sh = mmap(NULL, sizeof(*sh), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    close(fd);

    // pshared=1 → 프로세스 간
    sem_init(&sh->sem, 1, 1);
    sh->value = 0;

    int N=4, ITER=250000;
    for (int i=0;i<N;i++){
        if (fork()==0){
            for (int k=0;k<ITER;k++){
                sem_wait(&sh->sem);
                sh->value++;
                sem_post(&sh->sem);
            }
            _exit(0);
        }
    }
    for (int i=0;i<N;i++) wait(NULL);
    printf("value=%ld (expected %d)\n", sh->value, N*ITER);

    sem_destroy(&sh->sem);
    munmap(sh, sizeof(*sh));
    shm_unlink("/shm.counter");
    return 0;
}
```

**포인트**
- `sem_init(pshared=1)` 로 **프로세스 간 세마포어** 활성화.
- `shm_open+ftruncate+mmap(MAP_SHARED)` 로 **공유영역** 확보.
- 데이터 레이스 없이 정확히 **N×ITER** 도달.

---

## 8) 워커 관리, 신호, 좀비/고아 방지

- **좀비(Zombie)**: 자식 종료 후 `wait`하지 않으면 **프로세스 테이블 엔트리**가 남음 → `SIGCHLD` 핸들러에서 `waitpid(-1, &st, WNOHANG)` 반복으로 수거.
- **고아(Orphan)**: 부모가 먼저 죽으면 자식의 부모가 `init`(PID 1)로 변경 → 보통 문제 없음(슈퍼바이저가 관리).
- **SIGPIPE**: 닫힌 피어로 `write` 시 프로세스 종료 위험 → `signal(SIGPIPE, SIG_IGN)` 또는 `send(..., MSG_NOSIGNAL)`.
- **EINTR**: 신호로 깨진 시스템콜은 **재시도 루프** 또는 `SA_RESTART` 사용.

신호 핸들러 예(재시작 포함):

```c
struct sigaction sa = {.sa_handler = reap, .sa_flags = SA_RESTART};
sigemptyset(&sa.sa_mask);
sigaction(SIGCHLD, &sa, NULL);
```

---

## 9) 성능·스케일링 팁

- **프로세스 수**: CPU-바운드면 `코어 수`±α, I/O-바운드면 더 많아도 유효(단, 컨텍스트 스위치/메모리 고려).
- **accept 분산**: 최신 리눅스는 쓰던링 헤드 완화. 그래도 필요하면 `SO_REUSEPORT`로 포트별 큐 분할.
- **큰 전송**: 파일 응답은 `sendfile`(제로카피) 또는 `mmap+write`.
- **데이터 교환량**이 많다면: 공유메모리+Lock-Free 구조 또는 스레드/이벤트 기반 재검토.
- **감시/재시작**: 워커가 크래시하면 **부모가 즉시 재생성**. 시스템 서비스는 `systemd`/`supervisord`.

---

## 10) 안전 설계 체크리스트

- [ ] `fork` 직후 **필요 없는 FD 닫기** (`O_CLOEXEC`/`FD_CLOEXEC`로 유출 방지)  
- [ ] 다중 스레드 프로세스에서 `fork` 사용 주의(안전 함수만). 가능하면 **`posix_spawn`** 선택  
- [ ] 입력 크기·시간 제한(DoS 차단), `alarm`/타임아웃, 요청 상한  
- [ ] 경로 정규화/권한 분리(프록시/워커 `setuid`, `chroot`)  
- [ ] 로그/모니터링: PID/요청ID/지연/오류 코드 기록

---

## 11) 스레드와의 비교(요약)

| 항목 | 프로세스 | 스레드 |
|---|---|---|
| 격리 | 강함(주소공간 분리) | 약함(공유 메모리) |
| 생성/전환 비용 | 큼 | 작음 |
| 통신 | IPC 필요 | 메모리 직접 공유 |
| 안정성 | 한쪽 크래시 영향 제한 | 크래시 시 프로세스 전체 위험 |
| 언어 런타임 제약 | 회피 가능(예: Python GIL) | 런타임 제약 영향 받음 |

---

## 12) Python 한 줄 맛보기(멀티프로세싱)

```python
from multiprocessing import Pool, cpu_count

def f(x): return x*x

if __name__ == "__main__":
    with Pool(cpu_count()) as p:
        print(p.map(f, range(10)))
```

- GIL의 영향 없이 각 워커가 **독립 프로세스**로 병렬 계산.

---

## 13) 자주 겪는 오류 & 해결

| 증상 | 원인 | 해결 |
|---|---|---|
| 좀비 누적 | `wait` 미호출 | `SIGCHLD` 핸들러에서 수거 |
| `EADDRINUSE` 재시작 실패 | TIME_WAIT/포트 점유 | `SO_REUSEADDR` 사용 |
| 클라이언트에 쓰기 중 종료 | `SIGPIPE` | 무시하거나 `MSG_NOSIGNAL` |
| 입출력 중간에 실패 | `EINTR` | 루프 재시도 또는 `SA_RESTART` |
| FD 유출 | `exec` 후에도 열림 | `O_CLOEXEC`/`FD_CLOEXEC` 설정 |
| 성능 저하 | 과다 프로세스/컨텍스트 스위치 | 워커 수 튜닝, IPC 최소화 |

---

## 14) 마무리

**프로세스 기반 동시성**은 **안정성/격리/보안**이 중요한 시스템(웹 서버 프리포크, 프록시, ETL 파이프라인, 런타임 제약 회피)에 특히 유효합니다.  
핵심은 **올바른 IPC 선택**과 **워커 생명주기 관리(생성→작업→종료/재시작)**, 그리고 **신호/에러 처리(EINTR, SIGCHLD, SIGPIPE)** 입니다.  
여기 제시한 프리포크 서버·파이프라인·공유메모리+세마포어 예제를 발판으로, 여러분의 워크로드에 맞는 **프로세스 동시성 아키텍처**를 구성해 보세요.