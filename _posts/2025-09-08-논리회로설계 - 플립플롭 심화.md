---
layout: post
title: 논리회로설계 - 플립플롭 심화
date: 2025-09-08 14:25:23 +0900
category: 논리회로설계
---
# 플립플롭 심화 — **J–K 플립플롭**, **T 플립플롭**, **부가 입력(CE/Set/Reset/Load)**, **비동기 순서회로**

> 표기: \( \overline{X} \)=NOT \(X\), \(X^+\)=다음 상태, \(X\oplus Y\)=XOR.  
> 래치=**레벨 감지**, 플립플롭(FF)=**에지 감지**. 아래 내용은 **동기 설계 관점의 FF**를 중심으로, 끝엔 **비동기 순서회로**(클록 없이 동작)까지 정리합니다.

---

## 1) J–K 플립플롭 (JK FF)

### 1.1 정의와 진리표
- 입력: \(J\) (set 경향), \(K\) (reset 경향), 시계(↑/↓ 에지).  
- 동작(↑에지 기준):

| J | K | \(Q^+\) | 설명 |
|:-:|:-:|:--:|:--|
| 0 | 0 | \(Q\) | 유지(hold) |
| 1 | 0 | 1 | Set |
| 0 | 1 | 0 | Reset |
| 1 | 1 | \(\overline{Q}\) | **토글(toggle)** |

- **특징:** \(J=K=1\)에서 **한 번만** 토글(에지 트리거).  
  (레벨 트리거 JK는 **클록 폭이 길면 race-around**로 여러 번 토글 → 오늘날엔 **에지 트리거** 사용이 표준)

### 1.2 특성방정식(Characteristic Equation)
\[
Q^+ = J\,\overline{Q} \;+\; \overline{K}\,Q
\]

### 1.3 여기사표(Excitation Table) — 순서회로 합성에 사용
\[
\begin{array}{c|c|c}
Q & Q^+ & (J,K) \\
\hline
0 & 0 & (0,\; X) \\
0 & 1 & (1,\; X) \\
1 & 0 & (X,\; 1) \\
1 & 1 & (X,\; 0)
\end{array}
\]
(\(X\)=don’t care)

### 1.4 변환(구현) 공식
- **D로 구현하기**:  
  \[
  D = J\,\overline{Q} + \overline{K}\,Q
  \]
- **T로 구현하기**: 토글 조건이 \(J=1,Q=0\) 또는 \(K=1,Q=1\)  
  \[
  T = J\,\overline{Q} + K\,Q
  \]
- **D↔JK** (역변환):
  \[
  J = D\,\overline{Q},\qquad K = \overline{D}\,Q
  \]

### 1.5 타이밍
- 셋업 \(t_{su}\), 홀드 \(t_h\), 클록→Q \(t_{CQ}\)는 **D FF와 동일 개념**.  
- **동기화 입력**(J,K)이 복잡할수록 경로 지연 차(글리치)가 에지 근처에 생기지 않도록 주의.

---

## 2) T 플립플롭 (Toggle FF)

### 2.1 정의와 진리표
- 입력 \(T\)가 **1일 때 토글**, **0일 때 유지**.

| T | \(Q^+\) | 설명 |
|:-:|:--:|:--|
| 0 | \(Q\) | 유지 |
| 1 | \(\overline{Q}\) | 토글 |

- **특성방정식**  
  \[
  Q^* = T \oplus Q
  \]

### 2.2 구현과 용도
- **JK로**: \(J=K=T\).  
- **D로**: \(D = T \oplus Q\). (XOR 한 개)  
- **대표 용도**: 분주기(÷2), 비동기/동기 카운터의 기본 소자.

### 2.3 여기사표
\[
\begin{array}{c|c|c}
Q & Q^+ & T \\
\hline
0 & 0 & 0\\
0 & 1 & 1\\
1 & 0 & 1\\
1 & 1 & 0
\end{array}
\]
즉 \(T = Q \oplus Q^+\).

---

## 3) 플립플롭의 **부가 입력**(Additional Inputs)

> 표준 셀/FPGA FF는 대개 다음을 옵션으로 가집니다.

### 3.1 비동기 Set/Reset (Preset/Clear, **ASYNC**)
- **활성 시** 클록 없이 즉시 Q를 강제:  
  - preset(PR)=1 → \(Q\gets 1\)  
  - clear(CLR)=1 → \(Q\gets 0\)  (많이 쓰는 형은 **active-low**: \(\overline{\text{PR}},\overline{\text{CLR}}\))
- **우선순위**: 많은 셀이 **Reset 우선** 또는 **Set 우선**을 명세. 동시 활성은 **금지/비결정** → 회피.  
- **해제(deassert) 타이밍**: 클록 근처에서 해제하면 메타안정/불일치 가능 → **클록 동기화된 해제**(동기 release) 권장.  
- **복구/제거 시간** \(t_{rec}, t_{rem}\) 준수 필수.

### 3.2 동기 Set/Reset (**SYNC**)
- **클록 에지에서만** 적용. 조합 논리로 \(D\)를 강제하는 것과 동등(예: reset이면 \(D\gets 0\)).  
- 장점: 타이밍 분석 용이, 글리치 안전.

### 3.3 클록 인에이블(CE)
- \(CE=1\)일 때만 샘플.  
- 동작식(↑에지 D FF):  
  \[
  Q^+ = \begin{cases}
  D, & CE=1\\
  Q, & CE=0
  \end{cases}
  \quad\Rightarrow\quad
  D_{\text{eff}} = (CE\cdot D) + (\overline{CE}\cdot Q)
  \]
- **주의**: **클록 게이팅**(AND로 clk 차단)은 글리치 위험. 가능하면 **CE 포트** 사용.

### 3.4 동기 Load / 병렬 로드(Load)
- \(LOAD=1\)이면 \(Q\gets \text{DATA}\) (에지에서), 아니면 일반 \(D\) 샘플.  
- 레지스터 파일/시프트 레지스터에서 흔함.

### 3.5 스캔(DFT)
- **Scan Enable(SE)**, **SI/SO**로 체인을 구성해 제조 테스트(ATPG)에 활용.  
- 기능 모드와 스캔 모드의 **타이밍 제약** 각기 분석.

---

## 4) **비동기 순서회로**(Asynchronous Sequential Circuits)

> **클록 없이** 내부 래치/피드백으로 동작. 입력 변화에 따라 **즉시** 다음 상태를 향해 과도 응답을 거쳐 새로운 안정점에 도달.

### 4.1 모드와 전제
- **근본 모드(Fundamental mode)**  
  - **한 번에 하나의 입력만** 변화, 회로가 **안정**한 뒤에야 다음 입력 변화.  
  - 분석/설계가 상대적으로 단순.
- **펄스 모드(Pulse mode)**: 짧은 펄스 입력에 반응하도록 설계, **펄스 폭 제약** 필요.

### 4.2 모델링: **원시 흐름표(Primitive Flow Table)** → **상태표/그래프**
- 행: 현재 **내부 상태**(코드 없이 기호 상태 \(S_i\))  
- 열: **입력 조합**  
- 셀: **다음 상태**(불안정/과도 포함)와 **출력**  
- 절차
  1) **흐름표 작성**(사양→출력/다음상태)  
  2) **상태 감소(State reduction)** 및 **병합**  
  3) **상태 할당(State assignment)** — **race-free**가 되도록 코드 부여  
  4) **논리 합성** — 래치(보통 **S–R** 또는 **D 래치**) + 조합 논리로 구현

### 4.3 **레이스(race)**와 방지
- **레이스**: 두(이상) 상태 비트가 **거의 동시에** 바뀌어 **중간 경로**로 잘못된 상태에 도달.  
- **치명 레이스(critical race)**: 최종 목표 상태가 코드 의존으로 **달라짐**(오동작).  
- **예방**
  - **그레이/one-hot 할당**: **한 번에 1비트만** 바뀌게 상태 코딩  
  - **중간 단계 삽입**: 다비트 전환을 **직렬 단계**로 분해  
  - **입력 변화 단독 보장**: 근본 모드 준수(외부에서 시퀀싱)
  - **Muller C-element** 등 **속도독립(speed-independent)** 구조 사용

### 4.4 해저드(비동기에서 더 민감)
- **정적/동적 해저드**: 조합 경로 지연 불균형 → 글리치  
  - **합의항** 추가로 해저드 프리 커버 확보(앞선 장에서 다룸)  
- **필수(essential) 해저드**: 물리 경로의 성질로 발생(예: 입력이 직접 래치와 출력 모두에 영향)  
  - **경로 지연 균등화**(버퍼), **구조 변경** 필요
- **속도독립/지연불변 이론(요약)**
  - **Speed-Independent(SI)**: 게이트 지연 임의, **배선 지연=0** 가정(**isochronic fork** 예외)  
  - **Quasi-Delay-Insensitive(QDI)**: 거의 모든 지연 임의, **isochronic fork** 가정  
  - **Delay-Insensitive(DI)**: 이상적(현실적으론 제약 큼)

### 4.5 설계 예(개념) — **버튼 디바운스**(SR 래치)
- **노이즈/바운스** 입력을 **SR 래치**로 안정화:  
  \[
  S=\text{BTN\_filtered},\quad R=\text{BTN\_filtered\_release}
  \]
- **주의**: 기계식 바운스는 근본 모드 전제를 깨뜨릴 수 있어 **히스테리시스/RC 필터**와 병행.

### 4.6 타이밍 가이드
- **내부 안정 시간**을 고려하여 **입력 변경 간 최소 간격**을 확보(근본 모드).  
- 출력이 다른 블록의 **클록**으로 쓰이지 않게(글리치→클록 오동작 위험).

---

## 5) 타이밍 & 파형(ASCII)

### 5.1 JK 토글(↑에지, \(J=K=1\))
```
CLK: _/‾\_/‾\_/‾\_/‾\_
Q  : 0───1────0────1──  ← 에지마다 한 번씩 토글
```

### 5.2 T FF ÷2
```
CLK: _/‾\_/‾\_/‾\_/‾\_
T=1: ─────────────────
Q  : 0────1────0────1─  ← 입력 클록의 1/2 주파수
```

---

## 6) VHDL 모델(참고: 합성 가능 템플릿)

> 합성 시 **지연(`after`) 금지**, 비동기 신호는 **비동기 포트**에만.

### 6.1 JK FF (동기, ↑에지)
```vhdl
library ieee; use ieee.std_logic_1164.all;
entity jk_ff is
  port (clk : in std_logic; J,K : in std_logic; Q : out std_logic);
end;
architecture rtl of jk_ff is
  signal qi : std_logic := '0';
begin
  process(clk) is
  begin
    if rising_edge(clk) then
      case (J & K) is
        when "10"   => qi <= '1';
        when "01"   => qi <= '0';
        when "11"   => qi <= not qi;
        when others => null; -- hold
      end case;
    end if;
  end process;
  Q <= qi;
end;
```

### 6.2 T FF (↑에지), CE 포함
```vhdl
entity t_ff is
  port (clk, ce, T : in std_logic; Q : out std_logic);
end;
architecture rtl of t_ff is
  signal qi : std_logic := '0';
begin
  process(clk) is
  begin
    if rising_edge(clk) then
      if ce='1' then
        if T='1' then qi <= not qi; end if;
      end if;
    end if;
  end process;
  Q <= qi;
end;
```

### 6.3 D FF + 비동기 클리어/동기 세트
```vhdl
entity dff_ce_asclr is
  port (clk, ce, clr_n, set : in std_logic; D : in std_logic; Q : out std_logic);
end;
architecture rtl of dff_ce_asclr is
  signal qi : std_logic := '0';
begin
  process(clk, clr_n) is
  begin
    if clr_n='0' then
      qi <= '0';                           -- 비동기 Clear(우선)
    elsif rising_edge(clk) then
      if ce='1' then
        if set='1' then qi <= '1';        -- 동기 Set
        else             qi <= D;
        end if;
      end if;
    end if;
  end process;
  Q <= qi;
end;
```

---

## 7) 빠른 변환표(요약)

| 목표 | 사용 | 관계식 |
|---|---|---|
| JK → D | D FF | \(D = J\,\overline{Q} + \overline{K}\,Q\) |
| JK → T | T FF | \(T = J\,\overline{Q} + K\,Q\) |
| T → D | D FF | \(D = T \oplus Q\) |
| D → JK | JK FF | \(J = D\,\overline{Q},\; K = \overline{D}\,Q\) |
| T → JK | JK FF | \(J = T\,\overline{Q},\; K = T\,Q\) |

---

## 8) 체크리스트

- [ ] JK(레벨) 사용 금지? → **에지 트리거**로 race-around 제거.  
- [ ] **비동기 Set/Reset** 동시활성 금지, **해제는 동기화**.  
- [ ] **CE 사용**, **클록 게이팅 회피**(게이팅 필요 시 전용 cell/CDC 처리).  
- [ ] T/JK의 토글 조건 근처 **글리치**가 에지로 들어가지 않도록 경로 균형/레지스터링.  
- [ ] 비동기 순서회로는 **근본 모드 가정**, **race-free 상태코딩**과 **해저드 프리** 커버 확보.

---

## 9) 연습문제 (원하면 해설 제공)

1) 상태표가 \(Q_{t+1} = X \oplus Q_t\) 인 1비트 상태기계를 **(a) T FF**, **(b) JK FF**, **(c) D FF**로 각각 구현하라.  
2) 2비트 동기 카운터를 **T FF**로 설계하고, 동일 기능을 **JK FF**로 설계할 때의 입력식을 유도하라.  
3) 비동기 순서회로의 흐름표가 주어졌을 때 **race-free 상태 할당**을 제시하고 해저드 제거 임플리컨트를 추가하라.  
4) **비동기 Clear**와 **동기 Reset**을 모두 가진 FF의 **우선순위**를 어떻게 정의할지, 파형 예와 함께 장단점을 논하라.
