---
layout: post
title: 논리회로설계 - 플립플롭 심화
date: 2025-09-08 14:25:23 +0900
category: 논리회로설계
---
# 플립플롭 심화 — **J–K 플립플롭**, **T 플립플롭**, **부가 입력(CE/Set/Reset/Load)**, **비동기 순서회로**

## 개요와 핵심 요약

- **JK FF**: \(J\)·\(K\)의 조합으로 Set/Reset/Toggle/유지를 모두 표현하는 범용 FF. 오늘날 FPGA/ASIC에서는 **LUT+ D FF**로 구현(네이티브 JK 거의 없음) → 실제론 **식 변환(→D)**을 통해 사용.
- **T FF**: \(T=1\)일 때 **토글**, 가장 간단한 분주기(÷2). 동기 카운터 합성에 매우 유용.
- **부가 입력**: **비동기 Set/Reset**, **동기 Set/Reset**, **Clock Enable(CE)**, **Load**. 특히 **비동기 해제는 동기화**가 필수(복구/제거 시간).
- **비동기 순서회로**: 클록 없이 상태가 조합·래치로 정해짐. **근본 모드**, **레이스/해저드** 제거, **race-free 상태부호화**가 핵심. SI/QDI 개념(속도독립/지연불변)도 함께.

---

## J–K 플립플롭 (JK FF)

### 정의와 진리표(에지 트리거 기준)

| J | K | \(Q^+\)        | 동작 |
|:-:|:-:|:--------------:|:-----|
| 0 | 0 | \(Q\)          | 유지 |
| 1 | 0 | 1              | Set  |
| 0 | 1 | 0              | Reset|
| 1 | 1 | \(\overline{Q}\)| 토글 |

> **레벨 트리거 JK**는 클럭 폭이 길면 **race-around**(다중 토글) 위험. 현대 설계는 **에지 트리거** 또는 **마스터-슬레이브** 구조 사용. FPGA/ASIC에서는 내부 구현이 **D FF**이므로, 아래 특성식으로 변환해 쓰는 것이 표준입니다.

### 특성방정식과 등가 변환

- **특성식**
  $$
  Q^+ = J\,\overline{Q} + \overline{K}\,Q
  $$
- **D FF로 구현**
  $$
  D = J\,\overline{Q} + \overline{K}\,Q
  $$
- **T FF로 구현(토글 조건의 OR)**
  $$
  T = J\,\overline{Q} + K\,Q
  $$

### 여기사표(Excitation Table) — 합성 역문제에 사용

| \(Q\) | \(Q^+\) | \((J,K)\) |
|:----:|:------:|:---------:|
| 0    | 0      | (0, X)    |
| 0    | 1      | (1, X)    |
| 1    | 0      | (X, 1)    |
| 1    | 1      | (X, 0)    |

> 주어진 \(Q\to Q^+\) 전이로부터 필요한 \(J,K\)를 역으로 선택할 때 사용. \(X\)=don’t-care는 K-맵 최소화에 유리합니다.

### 실무 팁

- FPGA/ASIC 라이브러리 대부분 **JK 원시 셀 미제공** → **식 변환 후 D FF** 사용.
- JK 입력 로직이 복잡하면 에지 근처 글리치가 \(D\)에 전이될 수 있으므로 **레벨 안정(레지스터 삽입)** 또는 **시간적 여유**를 확보하세요.

---

## T 플립플롭 (Toggle FF)

### 정의·특성

| T | \(Q^+\)            | 동작 |
|:-:|:------------------:|:-----|
| 0 | \(Q\)              | 유지 |
| 1 | \(\overline{Q}\)   | 토글 |

- **특성식**: \(Q^+ = T \oplus Q\)

**구현**
- JK로: \(J=K=T\)
- D로: \(D = T \oplus Q\)  (XOR 한 개)

### 대표 용도 — 분주기·동기 카운터

- **÷2 분주**: T=1 고정 → Q가 입력 클록의 절반 주파수.
- **동기 카운터 합성(3비트 예)**
  \[
  \begin{aligned}
  T_0 &= 1 \\
  T_1 &= Q_0 \\
  T_2 &= Q_0 \cdot Q_1
  \end{aligned}
  \]
  일반화: \(T_i = \prod_{k=0}^{i-1} Q_k\) (상위 비트는 하위 모든 비트가 1일 때 토글)

**SystemVerilog 예 — 3비트 동기 카운터(T FF 스타일)**
```systemverilog
module sync_counter_3bit (
  input  logic clk, rst,
  output logic [2:0] q
);
  logic [2:0] t;
  assign t[0] = 1'b1;
  assign t[1] = q[0];
  assign t[2] = q[0] & q[1];

  always_ff @(posedge clk) begin
    if (rst) q <= 3'b000;
    else begin
      q[0] <= t[0] ? ~q[0] : q[0];
      q[1] <= t[1] ? ~q[1] : q[1];
      q[2] <= t[2] ? ~q[2] : q[2];
    end
  end
endmodule
```

### ASCII 파형(÷2)

```
CLK: _/‾\_/‾\_/‾\_/‾\_
T=1: ─────────────────
Q  : 0────1────0────1─
```

---

## 플립플롭의 **부가 입력** (CE/Set/Reset/Load/Scan)

### 비동기 Set/Reset (Preset/Clear, **ASYNC**)

- **즉시 강제**: 클록과 무관하게 Q를 1/0으로. 표준셀은 보통 **우선순위**를 명시(예: Reset 우선).
- **해제(deassert) 시점이 핵심**: 클록 에지 근처 해제는 메타안정·불일치 유발.
- **복구/제거 시간**
  $$
  t_{rec},\ t_{rem} \text{ 제약을 만족하도록 해제 타이밍을 분리}
  $$
- **권장**: **Async assert, Sync deassert** — 비동기 입력으로 즉시 잡고, **해제는 동기화**.

**VHDL 템플릿 — 비동기 클리어 + 동기 해제**
```vhdl
process(clk, clr_n) begin
  if clr_n='0' then
    q <= '0'; -- async assert
  elsif rising_edge(clk) then
    -- sync deassert path
    q <= d;
  end if;
end process;
```

### 동기 Set/Reset (**SYNC**)

- 클록 에지에서만 적용 → **타이밍 분석 용이**, 글리치 안전.
- D-mux 형태로 해석 가능:
  \[
  D_{\text{eff}} = R?0 : (S?1 : D)
  \]

### Clock Enable(CE)

- \(CE=1\)일 때만 샘플:
  \[
  Q^+ = \begin{cases}
  D, & CE=1\\
  Q, & CE=0
  \end{cases}
  \quad\Rightarrow\quad
  D_{\text{eff}} = (CE\cdot D) + (\overline{CE}\cdot Q)
  \]
- **클록 게이팅을 직접 AND로 구현 금지**. FPGA는 **전용 BUFGCE/CE 포트** 사용.

**SystemVerilog — D FF with CE/Sync Reset**
```systemverilog
always_ff @(posedge clk) begin
  if (rst)      q <= 1'b0;
  else if (ce)  q <= d;
end
```

### 동기 Load (병렬 로드)

- \(LOAD=1\)이면 에지에서 \(Q \gets DATA\). 쉬프트/레지스터 파일 등에서 활용.

**VHDL — Load/Shift 혼합 예**
```vhdl
if rising_edge(clk) then
  if rst='1' then
    q <= (others=>'0');
  elsif load='1' then
    q <= data_in;         -- 병렬 로드
  elsif sh_en='1' then
    q <= q(q'high-1 downto 0) & ser_in; -- 시프트
  end if;
end if;
```

### Scan(DFT)

- 제조 테스트를 위해 FF를 체인으로 연결(**SE/SI/SO**).
- 기능/스캔 모드 각각 타이밍 제약 분석 필요.

---

## 비동기 순서회로(Asynchronous Sequential Circuits)

> **클록 없이** 입력 변화→조합 로직→래치 피드백으로 즉시 상태가 이동. **안정점** 간 전이가 목표이며, 과도(glitch)·경로지연이 동작에 매우 큰 영향.

### 운용 모드

- **근본 모드(Fundamental mode)**: **입력은 한 번에 하나만** 변화, 회로가 새로운 안정 상태에 **완전히 도달한 뒤** 다음 입력 변화.
- **펄스 모드**: 펄스 폭·간격 제약 하에 동작(펄스가 내부 경로 지연 합보다 길어야 함).

### 원시 흐름표(Primitive Flow Table) → 설계 절차

1) **흐름표 작성**(현재 내부 상태 vs 입력 조합, 셀에 다음 상태/출력 기재)
2) **상태 감소/병합**(동치동작 병합)
3) **race-free 상태할당**(그레이/원-핫/중간상태 삽입)
4) **래치+조합 로직 합성**(보통 S–R/D 래치 사용)

### 레이스와 방지

- **레이스**: 여러 상태비트가 거의 동시에 변해 **중간 경로로 다른 상태에 착지**.
- **치명 레이스**: 최종 상태가 입력 코드·지연에 **의존** → 기능 오류.
- **방지책**
  - **그레이/one-hot 부호화**: 전이마다 **1비트만** 변하도록
  - **중간 상태 삽입**: 다비트 전환을 직렬화
  - **근본 모드 준수**(환경 제어)
  - **속도독립(SI)/지연불변(QDI) 스타일** 채용, **C-element** 활용

### 해저드(비동기에서 특히 중요)

- **정적/동적 해저드**: 경로 지연 불균형 → 단발성 글리치. **합의항**(consensus term) 추가로 제거.
- **필수 해저드**: 배선 지연 구조로 인해 발생(예: 한 입력이 래치와 출력으로 갈라지는 isochronic 가정 위반). **경로 지연 균등화/구조 변경** 필요.

### Muller C-element (SI 설계의 핵심 소자)

- **동작**: 입력이 모두 1이면 1, 모두 0이면 0, **그 외엔 이전 상태 유지**.
- **상태방정식**
  $$
  y^+ = a b + y(a + b)
  $$
- 핸드셰이크(4-phase req/ack) 구현에 유리.

**Verilog — C-element(행동 수준 예시)**
```verilog
module c_element(input a, b, output reg y);
  always @(*) begin
    case ({a,b})
      2'b00: y = 1'b0;
      2'b11: y = 1'b1;
      default: y = y; // 유지
    endcase
  end
endmodule
```
> 합성 시 래치로 추론될 수 있음(의도된 상태 유지). 표준셀에 전용 C-gate가 없으면 래치+게이트로 합성.

### 예: 버튼 디바운스(비동기 래치 기반 개념)

- 입력 바운스를 S–R 래치로 흡수 → **근본 모드**를 지키도록 외부 RC/Schmitt 트리거 병행이 바람직.

---

## 타이밍 & 파형

### JK 토글(↑에지, \(J=K=1\))

```
CLK: _/‾\_/‾\_/‾\_/‾\_
Q  : 0───1────0────1──  (에지마다 한 번 토글)
```

### T FF ÷2

```
CLK: _/‾\_/‾\_/‾\_/‾\_
T=1: ─────────────────
Q  : 0────1────0────1─
```

---

## 종합 예제

### 예제 A — **Mod-5 동기 카운터** (T FF 접근 → D FF 합성)

목표: 0→1→2→3→4→0 순환(3비트 상태, 5개만 사용).

1) **상태열/토글 조건**
   \[
   \begin{array}{c|c|c|c}
   \text{상태}(Q_2Q_1Q_0) & \text{다음} & T_0 & T_1,\ T_2 \\
   \hline
   000(0) & 001(1) & 1 & T_1=Q_0,\ T_2=0 \\
   001(1) & 010(2) & 1 & \\
   010(2) & 011(3) & 1 & \\
   011(3) & 100(4) & 1 & \\
   100(4) & 000(0) & 0 & T_1=0,\ T_2=1
   \end{array}
   \]
   → K-맵으로 최소화하면
   \[
   T_0= \overline{Q_2} + (Q_2\overline{Q_1}\overline{Q_0}) \approx 1\ \text{(상태 4만 예외)}
   \]
   실제 구현은 **D FF**가 간결: 테이블에서 직접 \(Q^+\) K-맵.

2) **SystemVerilog(간결 D 방식)**
```systemverilog
module mod5_counter (
  input  logic clk, rst,
  output logic [2:0] q
);
  logic [2:0] d;
  always_comb begin
    unique case (q)
      3'd0: d = 3'd1;
      3'd1: d = 3'd2;
      3'd2: d = 3'd3;
      3'd3: d = 3'd4;
      3'd4: d = 3'd0;
      default: d = 3'd0; // self-start
    endcase
  end
  always_ff @(posedge clk) begin
    if (rst) q <= 3'd0;
    else     q <= d;
  end
endmodule
```

### 예제 B — **JK FF로 상태방정식 구현**(식 변환)

다음상태가
\[
Q^+ = X\overline{Q} + \overline{X}Q
\]
이면 D식은 \(D= X\overline{Q} + \overline{X}Q = X \oplus Q\).
**JK로** 구현하려면
\[
J = D\,\overline{Q} = (X \oplus Q)\overline{Q} = X\overline{Q},\quad
K = \overline{D}\,Q = \overline{X \oplus Q}\,Q = \overline{X}Q
\]
즉 \(J=X\overline{Q},\ K=\overline{X}Q\).

**VHDL 스니펫**
```vhdl
-- JK 입력식 직접 코딩 (합성 시 D로 변환됨)
qi <= (J and not qi) or ((not K) and qi); -- Q^+ 특성식
J  <= x and (not qi);
K  <= (not x) and qi;
```

---

## 시뮬레이션·검증(간단 TB)

**SystemVerilog TB — JK 토글 & Mod-5**
```systemverilog
module tb;
  logic clk=0, rst=1;
  logic j=1, k=1, q_jk;
  logic [2:0] q_mod5;

  // DUTs
  jk_ff u_jk(.clk, .J(j), .K(k), .Q(q_jk));
  mod5_counter u_c(.clk, .rst, .q(q_mod5));

  // clock
  always #5ns clk = ~clk;

  initial begin
    #20ns rst=0;
    repeat (12) @(posedge clk);
    $finish;
  end

  // assertions
  property mod5_seq;
    @(posedge clk) disable iff (rst)
      (q_mod5 inside {0,1,2,3,4}) |-> ##1
      (q_mod5 == (q_mod5==4 ? 0 : q_mod5+1));
  endproperty
  assert property(mod5_seq);
endmodule
```

---

## 변환·여기사 **요약표**

### FF 상호 변환식

| 변환 | 식 |
|---|---|
| JK → D | \(D = J\,\overline{Q} + \overline{K}\,Q\) |
| JK → T | \(T = J\,\overline{Q} + K\,Q\) |
| T  → D | \(D = T \oplus Q\) |
| D  → JK| \(J = D\,\overline{Q},\; K = \overline{D}\,Q\) |
| T  → JK| \(J = T\,\overline{Q},\; K = T\,Q\) |

### 여기사표 모음

**D FF**
| \(Q\) | \(Q^+\) | D |
|:----:|:------:|:--:|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

**T FF**
| \(Q\) | \(Q^+\) | T |
|:----:|:------:|:--:|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

**JK FF** — §1.3 표 참조

**SR FF(금지 \(S=R=1\))**
| \(Q\) | \(Q^+\) | (S,R) |
|:----:|:------:|:-----:|
| 0 | 0 | (0,0) or (0,1) |
| 0 | 1 | (1,0) |
| 1 | 0 | (0,1) |
| 1 | 1 | (0,0) or (1,0) |

---

## 실무 체크리스트

- [ ] **JK 원시 셀 기대 금지**: 식을 **D로 변환**하라.
- [ ] **CE 사용**, 직접 **클록 게이팅 금지**(필요 시 전용 게이팅 셀/BUFGCE).
- [ ] **비동기 Set/Reset 동시활성 금지**, **해제 동기화**, \(t_{rec}/t_{rem}\) 준수.
- [ ] Mealy/토글 경계에서 **글리치**가 에지에 들어가지 않도록 **레지스터링/경로 균형**.
- [ ] 비동기 회로는 **근본 모드**, **race-free 코딩**, **해저드 프리 커버** 확보.
- [ ] Self-start: 불법 상태에서 합법 루프 수렴(others→IDLE).

---

## 연습문제

1) \(Q^+ = X \oplus Q\)를 **(a) T**, **(b) JK**, **(c) D** FF로 각각 합성하라(식 유도 포함).
2) 4비트 동기 카운터를 **T FF**로 설계: \(T_i=\prod_{k=0}^{i-1}Q_k\)를 증명하고 파형을 제시하라.
3) 비동기 흐름표가 주어졌을 때 **race-free 상태할당**을 제안하고, 정적 해저드 제거를 위한 **합의항**을 추가하여 식을 정리하라.
4) **Async Clear + Sync Reset**을 가진 FF의 우선순위(Async 우선)를 정의하고, 잘못된 해제 타이밍에서의 파형을 그려 문제점을 설명하라.
