---
layout: post
title: ì„ í˜•ëŒ€ìˆ˜ - ì§êµ í–‰ë ¬ê³¼ ì§êµ ë³€í™˜
date: 2025-06-06 22:20:23 +0900
category: ì„ í˜•ëŒ€ìˆ˜
---
# ğŸ§Š ì§êµ í–‰ë ¬ê³¼ ì§êµ ë³€í™˜ (Orthogonal Matrix & Transformation)

> **TL;DR**
> ì§êµ í–‰ë ¬ \(Q\)ëŠ” \(Q^\top Q=I\)ë¥¼ ë§Œì¡±í•˜ë©° ê¸¸ì´Â·ê°ë„Â·ë‚´ì ì„ **ë³´ì¡´**í•œë‹¤.
> ê¸°í•˜í•™ì ìœ¼ë¡œëŠ” **íšŒì „(rotation)** ë˜ëŠ” **ë°˜ì‚¬(reflection)**(í˜¹ì€ ë‘˜ì˜ ì¡°í•©)ì´ë‹¤.
> ìˆ˜ì¹˜í•´ì„ì—ì„  ì¡°ê±´ìˆ˜ê°€ 1ì´ë¼ **ì˜¤ì°¨ë¥¼ ì¦í­í•˜ì§€ ì•ŠëŠ”** â€œì•ˆì „í•œâ€ ë³€í™˜ì´ê³ ,
> PCAÂ·SVDÂ·QRÂ·ProcrustesÂ·ê·¸ë˜í”½ìŠ¤Â·ë¡œë´‡ê³µí•™ì— ê´‘ë²”ìœ„í•˜ê²Œ ì“°ì¸ë‹¤.

---

## ì •ì˜ì™€ ì¦‰ì‹œ ê²°ê³¼

### ì •ì˜

ì •ë°©í–‰ë ¬ \(Q\in\mathbb{R}^{n\times n}\)ê°€
$$
\boxed{Q^\top Q \;=\; QQ^\top \;=\; I}
$$
ë¥¼ ë§Œì¡±í•˜ë©´ **ì§êµ í–‰ë ¬(orthogonal matrix)** ë˜ëŠ” **ì •ê·œì§êµ í–‰ë ¬**ì´ë¼ í•œë‹¤. ë”°ë¼ì„œ
$$
\boxed{Q^{-1}=Q^\top}
$$

### ì¦‰ì‹œ ì„±ì§ˆ(ì¦ëª… ìŠ¤ì¼€ì¹˜ í¬í•¨)

- **ë‚´ì /ê¸¸ì´ ë³´ì¡´**
  ëª¨ë“  \(u,v\)ì— ëŒ€í•´
  $$
  (Qu)\cdot(Qv) \;=\; u^\top Q^\top Q v \;=\; u^\top v
  \quad\Rightarrow\quad \|Qv\|=\|v\|
  $$
- **ê°ë„ ë³´ì¡´(ë“±ê±°ë¦¬Â·ë“±ê° ë³€í™˜)**
  \(\cos\angle(Qu,Qv)=\cos\angle(u,v)\).
- **í–‰ë ¬ì‹**
  \(|\det Q|=1\)ì´ë©°, \(\det Q=+1\Rightarrow\) **íšŒì „êµ°**(\(SO(n)\)), \(\det Q=-1\Rightarrow\) **ë°˜ì‚¬ í¬í•¨**.
- **ìˆ˜ì¹˜ì  ì•ˆì •ì„±**
  2-ë…¸ë¦„ ì¡°ê±´ìˆ˜ \(\kappa_2(Q)=\|Q\|_2\|Q^{-1}\|_2=1\). â†’ **ì˜¤ì°¨ ì¦í­ ì—†ìŒ**.

---

## ê¸°í•˜í•™ì  ì˜ë¯¸: íšŒì „ê³¼ ë°˜ì‚¬

- **íšŒì „(rotation)**: ê¸¸ì´Â·ê°ë„ë¥¼ ìœ ì§€í•˜ë©° ë°©í–¥ì„±(ì˜¤ë¦¬ì—”í…Œì´ì…˜)ì„ **ë³´ì¡´**(\(\det Q=+1\)).
- **ë°˜ì‚¬(reflection)**: íŠ¹ì • ì´ˆí‰ë©´ì— ëŒ€í•´ ë’¤ì§‘ëŠ” ë³€í™˜, ë°©í–¥ì„± **ë°˜ì „**(\(\det Q=-1\)).
- ì¼ë°˜ ì§êµ ë³€í™˜ì€ íšŒì „ê³¼ ë°˜ì‚¬ì˜ **ì¡°í•©**(ì˜ˆ: â€œë¶€ì ì ˆ íšŒì „â€ = íšŒì „+ë°˜ì‚¬).

### 2DÂ·3D ëŒ€í‘œ ê¼´

- 2D íšŒì „:
  $$
  R(\theta)=\begin{bmatrix}\cos\theta&-\sin\theta\\[2pt]\sin\theta&\cos\theta\end{bmatrix}
  $$
- 2D ë°˜ì‚¬(ì˜ˆ: yì¶• ë°˜ì‚¬):
  $$
  \mathrm{Ref}_y=\begin{bmatrix}-1&0\\[2pt]0&1\end{bmatrix},\qquad \det=-1
  $$
- 3D **Householder ë°˜ì‚¬**(ë²•ì„  \(u\)ì— ëŒ€í•œ ë°˜ì‚¬):
  $$
  H \;=\; I - 2\frac{uu^\top}{u^\top u},\qquad H^\top H=I,\ \det H=-1
  $$

---

## ì§êµ êµ°ê³¼ ë¦¬ ëŒ€ìˆ˜ (ê³ ê¸‰ ê°œë… í•œ ì¥)

- **ì§êµêµ°** \(O(n)=\{Q\mid Q^\top Q=I\}\), **íŠ¹ìˆ˜ì§êµêµ°** \(SO(n)=\{Q\in O(n)\mid \det Q=+1\}\).
- **ë¦¬ ëŒ€ìˆ˜** \(\mathfrak{so}(n)=\{\Omega\in\mathbb{R}^{n\times n}\mid \Omega^\top=-\Omega\}\) (ìŠ¤í-ëŒ€ì¹­).
- **ì§€ìˆ˜ì‚¬ìƒ**: \(\exp(\Omega)\in SO(n)\) (ëª¨ë“  ì‘ì€ íšŒì „ì€ ìŠ¤í-ëŒ€ì¹­ ìƒì„±ì \(\Omega\)ì˜ ì§€ìˆ˜ë¡œ í‘œí˜„).
- 3D **Rodrigues ê³µì‹**: ì¶•-ê° \((\hat{n},\theta)\)ì—ì„œ
  $$
  R(\hat{n},\theta) \;=\; I+\sin\theta\,[\hat{n}]_\times+(1-\cos\theta)\,[\hat{n}]_\times^2,
  $$
  \([\hat{n}]_\times\)ëŠ” \(\hat{n}\)ì˜ ì™¸ì  í–‰ë ¬.

---

## ë§Œë“¤ê¸°Â·ë¶„í•´í•˜ê¸°: Gramâ€“Schmidt, Householder, Givens, QR, SVD, Polar

- **Gramâ€“Schmidt**: ì—´ì„ ì •ê·œì§êµí™”í•´ \(A=QR\) (ìˆ˜ì •í˜• MGS ê¶Œì¥).
- **Householder**: ë°˜ì‚¬ë¡œ ì—´ì„ ì°¨ë¡€ë¡œ â€œì²­ì†Œâ€í•˜ì—¬ ì•ˆì •ì ì¸ \(QR\) íšë“(ì‹¤ë¬´ í‘œì¤€).
- **Givens íšŒì „**: í•œ ë²ˆì— 2ê°œ ì„±ë¶„ë§Œ ì†Œê±°(í¬ì†Œ/ìŠ¤íŠ¸ë¦¬ë° ì¹œí™”).
- **QR ë¶„í•´**: \(A=QR\), \(Q\) ì§êµ, \(R\) ìƒì‚¼ê° â†’ ìµœì†Œì œê³±, ê³ ìœ ê°’ ì•Œê³ ë¦¬ì¦˜.
- **SVD**: \(A=U\Sigma V^\top\), \(U,V\) ì§êµ. PCAÂ·ì €ë­í¬ ê·¼ì‚¬ í•µì‹¬.
- **Polar ë¶„í•´**: \(A=QH\) (\(Q\) ì§êµ, \(H\) ëŒ€ì¹­ ì–‘ì •), \(A=U\Sigma V^\top\)ì—ì„œ \(Q=UV^\top\), \(H=V\Sigma V^\top\).

---

## ìŠ¤í™íŠ¸ëŸ´ ì •ë¦¬Â·ìœ ì‚¬ë³€í™˜(orthogonal similarity)

- (ì‹¤ëŒ€ì¹­ \(A\)) **ìŠ¤í™íŠ¸ëŸ´ ì •ë¦¬**: \(A=Q\Lambda Q^\top\) (ê³ ìœ³ê°’ \(\Lambda\), ì§êµ ê³ ìœ ê¸°ì € \(Q\)).
- **ì§êµ ìœ ì‚¬ë³€í™˜** \(B=Q^\top A Q\): ë…¸ë¦„Â·ì¡°ê±´ìˆ˜Â·ê³ ìœ³ê°’ **ë³´ì¡´**, ëŒ€ì¹­ì„±ë„ ë³´ì¡´.
  â†’ ìˆ˜ì¹˜ì„ í˜•ëŒ€ìˆ˜ì—ì„œ ì§êµ ìœ ì‚¬ë³€í™˜ìœ¼ë¡œ **ì˜¤ì°¨ë¥¼ í‚¤ìš°ì§€ ì•Šê³ ** ë‹¨ìˆœí™”.

---

## íˆ¬ì˜ vs ì§êµ ë³€í™˜ (í—·ê°ˆë¦¬ê¸° ì‰¬ìš´ í¬ì¸íŠ¸)

- **ì§êµ í–‰ë ¬**ì€ \(Q^\top Q=I\)ì¸ **ì„ í˜• ë“±ê±°ë¦¬ ë³€í™˜**.
- **ì§êµ íˆ¬ì˜í–‰ë ¬** \(P\)ëŠ” \(P^2=P,\ P^\top=P\) (ëŒ€ì¹­ ë©±ë“±)ì´ë©° ì¼ë°˜ì ìœ¼ë¡œ **ì§êµ í–‰ë ¬ì´ ì•„ë‹˜**.
  (ì˜ˆì™¸: \(P=0\) ë˜ëŠ” \(P=I\)ë§Œ ì§êµ í–‰ë ¬)

---

## ì‹¤ì „ ì‘ìš©

- **PCA**: ê³µë¶„ì‚° \(C\)ë¥¼ \(C=Q\Lambda Q^\top\)ë¡œ ëŒ€ê°í™”. \(Q\)ëŠ” ì£¼ì„±ë¶„ ì¶•, íˆ¬ì˜ì€ \(Q^\top x\).
- **ìµœì†Œì œê³±**: \(A=QR\Rightarrow Rx=Q^\top b\) (ì•ˆì •ì ).
- **Procrustes ë¬¸ì œ**: \(\min_{Q\in O(n)}\|AQ-B\|_F\). \(A^\top B=U\Sigma V^\top\Rightarrow Q^\*=UV^\top\).
- **ê·¸ë˜í”½ìŠ¤/ë¡œë³´í‹±ìŠ¤**: ìì„¸ í‘œí˜„(íšŒì „í–‰ë ¬/í€˜í„°ë‹ˆì–¸), ì¹´ë©”ë¼Â·ë§í¬ ë³€í™˜(íšŒì „ì€ ì§êµ).
- **ìˆ˜ì¹˜ì•ˆì •í™”**: ì§êµ ì „ì¹˜ê³±ìœ¼ë¡œ ìŠ¤ì¼€ì¼ì„ **ë³´ì¡´**í•˜ë©° ì „ì²˜ë¦¬/ì •ê·œí™”ë¥¼ ìˆ˜í–‰.

---

## êµ¬í˜„Â·ê²€ì¦ í¬ì¸íŠ¸

- **ì •í™• ë¹„êµ ê¸ˆì§€**: ìˆ˜ì¹˜ì˜¤ì°¨ ë•Œë¬¸ì— \(Q^\top Q\approx I\)ë¥¼ `allclose`ë¡œ í™•ì¸.
- **ìœ íš¨ì •ê·œí™”**: ì •ê·œì§êµí™” ì‹œ ì–¸ë”í”Œë¡œ/ì˜¤ë²„í”Œë¡œì— ì£¼ì˜(ìŠ¤ì¼€ì¼ë§, MGS/Householder).
- **\(\det Q\) íŒì •**: \(+1\) íšŒì „, \(-1\) ë°˜ì‚¬ í¬í•¨.
- **ì¡°ê±´ìˆ˜**: \(\kappa_2(Q)=1\) í™•ì¸ìœ¼ë¡œ ì•ˆì „ì„± ì ê²€.

---

## ì†ê³„ì‚° ë¯¸ë‹ˆ ì˜ˆì œ

### 2D íšŒì „

\[
R(30^\circ)=
\begin{bmatrix}
\frac{\sqrt{3}}{2} & -\frac12\\[2pt]
\frac12 & \frac{\sqrt{3}}{2}
\end{bmatrix},\quad
R^\top R=I,\ \det R=1
\]

### 3D í‰ë©´ ë°˜ì‚¬(ë²•ì„  \(u=[0,0,1]^\top\))

\[
H=I-2uu^\top=\mathrm{diag}(1,1,-1),\quad \det H=-1
\]

### ì¶•-ê° íšŒì „(ì¶• \(\hat{n}=\frac{1}{\sqrt3}[1,1,1]^\top\), ê° \(\theta\))

Rodrigues ê³µì‹ì„ ì ìš©í•˜ì—¬ \(R(\hat{n},\theta)\) êµ¬ì„± ê°€ëŠ¥.

---

## Python ì‹¤ì „ ì½”ë“œ (NumPy)

> **íŒ**: ì•„ë˜ ëª¨ë“  ê²€ì‚¬ëŠ” `np.allclose(Â·, Â·, atol=1e-12)` ê°™ì€ **í—ˆìš©ì˜¤ì°¨**ë¥¼ ê¼­ ì‚¬ìš©í•˜ì„¸ìš”.

```python
import numpy as np

# ---------- ê³µí†µ ìœ í‹¸ ----------

def is_orthogonal(Q, tol=1e-12):
    n = Q.shape[0]
    return np.allclose(Q.T @ Q, np.eye(n), atol=tol) and np.allclose(Q @ Q.T, np.eye(n), atol=tol)

def random_orthogonal(n, seed=0):
    # QRë¡œ ë¬´ì‘ìœ„ ì§êµí–‰ë ¬ ìƒì„±
    rng = np.random.default_rng(seed)
    A = rng.standard_normal((n, n))
    Q, R = np.linalg.qr(A)
    # det(Q)= -1ì´ë©´ ë§ˆì§€ë§‰ ì—´ ë¶€í˜¸ë¥¼ ë’¤ì§‘ì–´ SO(n)ìœ¼ë¡œ ë§ì¶¤(ì„ íƒì‚¬í•­)
    if np.linalg.det(Q) < 0:
        Q[:, -1] *= -1
    return Q

# 2D íšŒì „ ----------

theta = np.deg2rad(30)  # 30 degrees
R = np.array([[np.cos(theta), -np.sin(theta)],
              [np.sin(theta),  np.cos(theta)]])
print("R orthogonal? ", is_orthogonal(R))
print("det(R) =", np.linalg.det(R))

v = np.array([3., 4.])
print("len preserved? ", np.allclose(np.linalg.norm(R @ v), np.linalg.norm(v)))

# 3D ë°˜ì‚¬ (Householder) ----------

u = np.array([0., 0., 1.])  # z-ì¶• ë²•ì„  (í‰ë©´ z=0ì— ëŒ€í•œ ë°˜ì‚¬)
H = np.eye(3) - 2.0 * np.outer(u, u) / (u @ u)
print("H orthogonal? ", is_orthogonal(H), " det(H) =", np.linalg.det(H))

x = np.array([1., 2., 3.])
xr = H @ x
print("reflect z: x->", x, " Hx->", xr)  # z ë¶€í˜¸ê°€ ë’¤ì§‘í˜

# ì¶•-ê° -> íšŒì „í–‰ë ¬ (Rodrigues) ----------

def rodrigues(axis, theta):
    axis = np.asarray(axis, float)
    axis = axis / np.linalg.norm(axis)
    x, y, z = axis
    K = np.array([[ 0, -z,  y],
                  [ z,  0, -x],
                  [-y,  x,  0]])
    I = np.eye(3)
    return I + np.sin(theta) * K + (1 - np.cos(theta)) * (K @ K)

axis = [1., 1., 1.]
R3 = rodrigues(axis, np.deg2rad(45))
print("Rodrigues orthogonal? ", is_orthogonal(R3), " det=", np.linalg.det(R3))

# QR ë¶„í•´ë¡œ ì§êµí–‰ë ¬ ì–»ê¸° ----------

A = np.array([[2., 1., 0.],
              [1., 3., 1.],
              [0., 1., 2.]])
Q, S = np.linalg.qr(A)   # A = Q S
print("Q orthogonal? ", is_orthogonal(Q))
print("reconstruction ok? ", np.allclose(Q @ S, A))

# Procrustes: min ||AQ - B||_F over orthogonal Q ----------

def orthogonal_procrustes(A, B):
    M = A.T @ B
    U, _, Vt = np.linalg.svd(M)
    Q = U @ Vt
    # ì„ íƒì ìœ¼ë¡œ det(Q)=+1ë¡œ ê°•ì œ: ë°˜ì‚¬ ë°°ì œ
    if np.linalg.det(Q) < 0:
        U[:, -1] *= -1
        Q = U @ Vt
    return Q

A_data = np.array([[1., 0.],
                   [0., 1.],
                   [1., 1.]])    # (3x2)
# ì–´ë–¤ íšŒì „ Rì™€ ë…¸ì´ì¦ˆë¥¼ ì ìš©í•´ Bë¥¼ ë§Œë“¤ì—ˆë‹¤ê³  ê°€ì •

theta2 = np.deg2rad(20)
R2 = np.array([[np.cos(theta2), -np.sin(theta2)],
               [np.sin(theta2),  np.cos(theta2)]])
B_data = A_data @ R2 + 0.01*np.random.default_rng(0).standard_normal((3,2))

Qstar = orthogonal_procrustes(A_data, B_data)
print("Procrustes Q orthogonal? ", is_orthogonal(Qstar))
print("alignment error ||AQ-B||_F = ", np.linalg.norm(A_data @ Qstar - B_data, 'fro'))

# ì„ì˜ ì§êµí–‰ë ¬ ìƒì„± ë° ê²€ì¦ ----------

Qrand = random_orthogonal(5, seed=42)
print("Random Q orthogonal? ", is_orthogonal(Qrand), " det=", np.linalg.det(Qrand))

# ë‚´ì /ê°ë„ ë³´ì¡´ ê²€ì¦ ----------

a = np.random.default_rng(1).standard_normal(5)
b = np.random.default_rng(2).standard_normal(5)
Qa, Qb = Qrand @ a, Qrand @ b
dot_eq = np.allclose(a @ b, Qa @ Qb)
len_eq = np.allclose(np.linalg.norm(a), np.linalg.norm(Qa))
print("dot preserved?", dot_eq, " length preserved?", len_eq)
```

---

## ì²´í¬ë¦¬ìŠ¤íŠ¸ & ìì£¼ í•˜ëŠ” ì‹¤ìˆ˜

1. **ì§êµ vs ì •ì‚¬ì˜** í˜¼ë™ ê¸ˆì§€: \(Q\) ì§êµ â‡” \(Q^\top Q=I\). ì •ì‚¬ì˜ \(P\): \(P^2=P,\ P^\top=P\)ì´ë©° ë³´í†µ ì§êµ ì•„ë‹˜.
2. **ì •í™• ë¹„êµ ê¸ˆì§€**: ë¶€ë™ì†Œìˆ˜ì ì—ì„  `==` ëŒ€ì‹  `allclose`.
3. **\(\det Q\) ë¶€í˜¸**: íšŒì „ë§Œ í—ˆìš©í•˜ë ¤ë©´ \(\det Q=+1\) ê°•ì œ(ë§ˆì§€ë§‰ ì—´ ë¶€í˜¸ ì¡°ì •).
4. **ì •ê·œí™” ëˆ„ë½**: ì¶•-ê°Â·Householderì—ì„œ ì¶•/ë²•ì„ ì€ ë°˜ë“œì‹œ **ë‹¨ìœ„í™”**.
5. **ë¶ˆì•ˆì • GS**: í´ë˜ì‹ Gramâ€“SchmidtëŠ” ìˆ˜ì¹˜ë¶ˆì•ˆì • â†’ **MGS** ë˜ëŠ” **Householder** ì¶”ì²œ.

---

## ìš”ì•½(í•œ ì¥)

| í•­ëª© | í•µì‹¬ |
|---|---|
| ì •ì˜ | \(Q^\top Q=I \Rightarrow Q^{-1}=Q^\top\) |
| ê¸°í•˜ | íšŒì „(\(\det=+1\))Â·ë°˜ì‚¬(\(\det=-1\))Â·ì¡°í•© |
| ë³´ì¡´ | ê¸¸ì´Â·ê°ë„Â·ë‚´ì Â·2-ë…¸ë¦„, \(\kappa_2(Q)=1\) |
| ë¶„í•´ | QR(Gramâ€“Schmidt/Householder/Givens), SVD, Polar |
| ìŠ¤í™íŠ¸ëŸ´ | ëŒ€ì¹­ \(A\)ëŠ” \(A=Q\Lambda Q^\top\) ë¡œ ì§êµ ëŒ€ê°í™” |
| ì‘ìš© | PCA, ìµœì†Œì œê³±, Procrustes, ê·¸ë˜í”½ìŠ¤/ë¡œë´‡ ìì„¸ |
| êµ¬í˜„ | `allclose`, ì •ê·œí™”, \(\det\) ë¶€í˜¸ ê´€ë¦¬ |

---
```python
# ë³´ë„ˆìŠ¤: Householderë¡œ ì„ì˜ ë²¡í„°ë¥¼ e1 ë°©í–¥ìœ¼ë¡œ ë³´ë‚´ê¸° (QRì˜ í•µì‹¬ìŠ¤í…)

import numpy as np

def householder_to_e1(x):
    x = x.astype(float)
    v = x.copy()
    v[0] += np.copysign(np.linalg.norm(x), x[0])  # ì•ˆì •ì  ì„ íƒ
    v /= np.linalg.norm(v)
    H = np.eye(len(x)) - 2*np.outer(v, v)
    return H

x = np.array([3., 4., 5.])
H = householder_to_e1(x)
print("Hx =", H @ x)      # ì²« ì„±ë¶„ë§Œ ë‚¨ê³  ë‚˜ë¨¸ì§€ ~0
print("H orthogonal?", np.allclose(H.T @ H, np.eye(3)))
```
