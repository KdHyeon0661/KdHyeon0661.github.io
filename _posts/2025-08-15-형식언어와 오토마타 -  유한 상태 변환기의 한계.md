---
layout: post
title: 형식언어와 오토마타 - 유한 상태 변환기의 한계
date: 2025-08-15 22:20:23 +0900
category: 형식언어와 오토마타
---
# 유한-상태 변환기(FST)의 **한계** — 표현력·결정화·동기화·폐포·실무적 제약까지

유한-상태 변환기(Finite-State Transducer, FST)는 입력 문자열을 출력 문자열로 바꾸는 **유한 기억** 장치다.
표현력이 강력하고(정규 관계), 합성·결정화·최소화 등 공학적 도구도 훌륭하지만, **유한 상태**라는 본질 때문에 피할 수 없는 한계가 있다.

---

## 모델 스펙트럼(용어 정리)

- **1-way FST**: 입력을 좌→우 **한 번** 스캔.
  - **DFT(결정적 순차 변환기, subsequential)**: 상태/전이별 **결정적** 선택, 전이마다 고정 문자열 출력, (선택적으로) **최종 출력**.
  - **NFT(비결정 FST)**: 전이 다중 선택 허용(관계/다가 함수).
- **2-way FST(2DFT/2NFT)**: 입력 헤드를 좌↔우 이동 가능(왕복 스캔).
- **SST(Streaming String Transducer)**: 유한 개의 **출력 변수**(스트링 레지스터)에 **병합-복사 제한** 하 대입.
- **PDT(푸시다운 변환기)**: FST + **스택**(문맥자유급 의존성).

> 큰 그림:
> $$\text{DFT(순차 함수)}\subsetneq \text{2DFT} \equiv \text{SST} \subsetneq \text{PDT}$$
> (관계 수준에선 NFT가 **정규(=rational) 관계**를 포괄)

---

## **표현력의 경계** — 1-way의 본질적 한계

### “정규 관계(Rational Relation)”로의 상한

1-way FST가 표현하는 관계는 **정규(=rational) 관계**에 한정된다.
즉, **스택/무한 레지스터 없이** 가능한 **유한-요약 기반** 지역 변환만 안정적으로 처리한다.

### **무한 기억**이 필요한 전역 제약 불가

- **균형 카운팅**:
  $$L=\{\,a^n b^n \mid n\ge0\,\}$$
  같은 **카운트 일치**를 정확히 반영해야 하는 변환(예: $a^n b^n\mapsto c^n$)은 1-way FST로 불가.
  유한 상태만으론 두 구간의 **임의 길이 카운트 동일성**을 기억·검증할 수 없다.

- **중첩 괄호(Dyck) 구조**:
  $$\{\,\text{balanced parentheses}\,\}$$
  같은 **중첩 의존**은 스택이 필요 → PDT 급.

- **멀리 떨어진 구간의 동일성 검사**:
  “앞 절반 = 뒤 절반?” 같은 **글로벌 동형성**은 불가.

### 불가

- **역순**: $$w \mapsto w^R$$ 은 1-way FST 함수로 불가.
  첫 출력 문자를 내기 전에 **마지막 입력**을 알아야 한다. 유한 지연으로 해결 불가.

- **끝-문자 맨앞으로**: $$ua \mapsto au$$ (마지막 문자 $a$를 앞에 붙임)도 불가.
  앞부분 출력 결정을 위해 **끝 정보**가 필요 → **무한 지연** 요구.

- **복사(전역 중복)**: $$w \mapsto ww$$ 불가.
  전이 출력은 **고정 문자열**, 유한 상태는 입력 전체를 저장할 수 없으므로 **두 번째 사본**을 생성 불가.
  (반면 **문자별 복제**: $a_1a_2\cdots a_n\mapsto a_1a_1a_2a_2\cdots a_n a_n$ 은 가능 — 전이마다 `aa` 출력)

> 요약: 1-way FST 출력은 입력과 **근거리 동기화**되어야 한다. **뒤집기·끝-의존 재배열·전역 복사**는 모델상 막힌다.

---

## **결정화(Determinization)**의 한계 — Twinning/Delay

비결정 FST(NFT)가 **함수**를 정하더라도 **언제나 DFT로 결정화**되는 것은 아니다.

### 지연(delay)·twinning property(유계 지연)

두 경로가 같은 입력 접두어를 읽었을 때, **출력 길이/내용 차이**가 **유계(k-동기)** 로 제어되면 결정화 가능성이 높다.
반대로, 입력이 길어질수록 경로 간 출력 지연이 무한히 벌어질 수 있으면 **결정화 불가**.

직관: “미래를 조금이라도 봐야 결정되는 출력”이 누적되면, 1-way 결정 과정에서 **유한 lookahead**로 해소 불가.

### 결정화 실패를 유발하는 전형 패턴

- **마지막 문자를 앞에 붙이기**: $$f(w)=\text{last}(w)\cdot w$$
  출력의 첫 글자를 내기 위해 **마지막 입력**을 알아야 함 → 지연 무계. NFT(관계)로는 흉내 가능하더라도 **순차 함수**로는 불가.

- **조건부 접두 삽입(끝-의존)**: 입력 끝에서 속성 판단 후 앞에 삽입하는 패턴 전반.

---

## **출력 길이·지연**의 구조적 상한

정상화(ε-출력 루프 제거) 가정하, DFT의 출력 길이는 입력 길이에 대해 **선형 상계**를 갖는다:

$$
\exists c_0,c_1\ge0\ \ \forall x\in\Sigma^*:\quad |\mathrm{out}(x)| \le c_0 + c_1\cdot |x|.
$$

- 전이마다 출력은 **고정 문자열**이므로, 입력 1글자당 출력 기여가 상수로 제한.
- **지수/초선형 폭증**(예: $2^{|x|}$ 길이)은 불가.

또한 DFT는 각 입력 스텝의 출력이 **즉시** 또는 **유계 지연**으로만 결정된다.
최종 출력(상태별 상수 문자열)로 **입력-의존 가변 꼬리**를 무한히 붙일 수 없다.

---

## **폐포·연산**에서의 한계(DFT/NFT 대비)

| 연산/속성 | DFT(순차 함수) | NFT(정규 관계) |
|---|---|---|
| 합성(∘) | 닫힘(결정화 가능한 범위) | 닫힘(구성은 가능, 크기 폭증) |
| 역함수 | 일반적으로 **닫힘 아님** | 관계로서 역은 항상 **존재** |
| 동치성 | **결정 가능**(선형~다항) | 일반 NFT **결정 불가** 경우 다수 |
| 포함성 | 두 DFT 간 **결정 가능** | 일반 NFT **결정 불가** 빈번 |
| 역순 입력 처리 | 순차성 유지 **보장 없음** | 관계로는 표기 가능하나 합성 시 난해 |
| 최소화 | DFT는 **가능**(특수 알고리즘) | NFT 최소화 개념이 애매/제한적 |

> 실무 팁: 파이프라인을 **결정적**(순차)로 유지하면 검증/최적화가 쉽다.
> 비결정 요소를 넣으면 **동치/포함** 문제의 자동화가 급격히 어려워진다.

---

## **동기화(synchronization)** — “입출력 정렬”의 제약

- **k-동기 변환**: 어떤 실행에서도 “읽은 입력 길이와 낸 출력 길이의 차이”가 $$\le k$$ 로 유계.
  DFT는 보통 **유계 지연**을 만족.
- **불가 패턴**: 요구 지연이 **입력 길이에 비례**해 커지는 경우(끝-의존 접두/역순/전역 복사 등).

정리하면 1-way FST가 허용하는 재배열은 **상수 폭 이내**의 **국소 치환/삽입/삭제**로 한정된다.

---

## **가중치·확률**(WFST)을 올려도 본질은 동일

WFST(가중/확률)로 비용·점수를 얹어도 **기억 한계**는 그대로다.

- **가능**: 최단경로, N-best, 모듈 합성(발음/언어 모델)
- **한계 유지**: 역순·전역 복사·중첩 구조 등 **메모리 요구** 문제는 여전히 불가

---

## **대체 모델**로의 우회(언제 무엇을 쓸까?)

| 요구 기능 | 권장 모델 | 메모 |
|---|---|---|
| 역순/끝-의존 재배열 | **2DFT** / **SST** | 2-way로 왕복 스캔, SST는 레지스터로 상수회 복사 |
| 전역 복사(상수회) | **SST** / **2DFT** | SST는 **복사수 제한** 기반 MSO-정의 함수와 등가 |
| 중첩·균형 | **PDT** | 문맥자유급 의존성 |
| 복잡 검증·전역 제약 | **FST + SMT/정적분석** | 전처리 FST, 후처리 검증기 결합 |

실무 전략: **가능한 곳엔 1-way DFT**, 꼭 필요한 지점만 **2DFT/SST/PDT** 로 승격(표현력 최소 확장).

---

## **예제**로 보는 가능/불가능

### 가능: 문자별 복제(각 문자를 두 번)

```text
# DFT 스케치 (입력 Σ, 출력 same Σ)

상태: q0 (유일)
전이: q0 --a/aa--> q0   (모든 a∈Σ)
최종 출력: ε
# 성질: |out(x)| = 2|x| (선형), k-동기

```

### 불가능: 전역 복사(ww)

- 필요 출력 길이: $$|out(x)| = 2|x|$$ 이라서 선형이긴 하지만, **두 번째 사본**은 **입력 전부를 기억**해야 생성 가능.
- DFT 전이는 **고정 출력**이므로 “과거 전체”를 한 번에 재생산할 수 없다 → **1-way 불가**.
- **대안**: SST(레지스터에 접두를 모으며 최종 단계에 **상수회** 복사) 또는 2DFT.

### 불가능: 역순(w → w^R)

- 첫 출력 문자를 내기 전에 마지막 입력을 알아야 함 → **무한 지연** 필요.
- **대안**: 2DFT(끝까지 갔다가 좌로 되돌며 출력)·SST(레지스터를 앞에 붙이는 방식으로 유지).

### 불가능: 마지막 문자를 맨 앞에 붙이기

- $$f(a_1a_2\cdots a_n) = a_n a_1a_2\cdots a_n$$
- 첫 출력 \(a_n\)을 위해 끝 정보를 알아야 함 → **지연 무계** → DFT 불가.
- **대안**: 2DFT로 끝까지 스캔 후 헤더 출력, 좌로 복귀해 나머지 출력.

---

## **코드 예제** — 간단 DFT 시뮬레이터와 패턴 구현

아래는 결정 FST(DFT)를 파이썬으로 흉내 내는 **간단 시뮬레이터**다.
전이 `(state, a) -> (state', out)` 과 **최종 출력** `final_out[state]` 을 사용한다.

```python
# DFT 시뮬레이터 (교육용 단순 구현)

from typing import Dict, Tuple

State = str
Sym = str

class DFT:
    def __init__(self, q0: State, delta: Dict[Tuple[State, Sym], Tuple[State, str]], final_out: Dict[State, str]):
        self.q0 = q0
        self.delta = delta
        self.final_out = final_out

    def transduce(self, s: str) -> str:
        q = self.q0
        out = []
        for ch in s:
            if (q, ch) not in self.delta:
                raise ValueError(f"no transition from {q} on {ch}")
            q, o = self.delta[(q, ch)]
            out.append(o)
        out.append(self.final_out.get(q, ""))
        return "".join(out)

# 문자별 복제 (a->aa, b->bb, ...)

alphabet = ['a','b','c']
delta = {}
for a in alphabet:
    delta[('q0', a)] = ('q0', a+a)
dft_dup = DFT('q0', delta, {'q0': ""})
print(dft_dup.transduce("abca"))  # aabbccaa
```

**불가능 케이스는 어떻게 드러나는가?**
역순/끝-접두는 “전이 단계에서 **고정 길이 출력**만 허용”되는 이 모델에선 **표현 자체가 불가**다.
시뮬레이터에서 억지로 만들 수 없고, 설계 시도 과정에서 “첫 출력이 무엇인지 **미리 결정 불가**” 문제로 막힌다.

---

## 점검 스케치

NFT를 설계했는데 결정화(DFT)로 옮기고 싶을 때, **지연 유계(=twinning)** 를 직관적으로 점검하는 방법:

```text
Check-Determinizable(NFT):
  1) ε-출력 루프 제거/정상화
  2) 같은 입력 접두어를 읽는 "두 경로"를 추적:
     - 각 접두어 길이 k에 대해, 출력 차이 Delay(k)의 길이를 재보면
       Delay(k)가 어떤 상수 K로 항상 |Delay(k)|≤K 인가?
  3) 상수 K가 존재하면 (경험적으로) 결정화 가능성이 큼.
     무한히 커지는 입력열이 있으면 결정화 실패 가능성이 큼.
```

**자동 판정 알고리즘**은 더 정교하지만, 실무에선 “끝-의존/멀리-의존을 요구하는지”를 보는 **패턴 기반 점검**이 효과적이다.

---

## **실무 제약** — 설계·성능·검증

### 모델링 제약

- 규칙이 늘면 **상태 폭증** / **전이 폭증**(특히 큰 알파벳·문맥 조건 다수).
- 비결정 요소가 남아 있으면 **동치/포함/최소화 어려움**.

### 성능·자원

- 큰 사전/규칙 → **메모리 상주 비용** 큼.
- 합성(composition)·determinization·minimization은 **최악 지수적** 폭증 가능 → **모듈화** 설계가 필수.

### 검증·테스트

- DFT로 유지하면 **동치성 검사**가 쉽다(제품 탐색 선형~다항).
- 회귀: 골든 DFT와 신규 DFT를 제품 구성해 **최초 불일치 입력**을 자동 산출.

```text
# 두 DFT 동등성(개념)

Equal-DFT(M1, M2):
  if final_out(q0_1) != final_out(q0_2): return False, ε
  BFS over pairs (p,q):
    for a in Σ:
      (p', o1) = δ1(p,a)
      (q', o2) = δ2(q,a)
      if o1 != o2: return False, a on path
      enqueue (p',q') if new
  return True, None
```

---

## **디자인 패턴** — “FST로 충분한가?” 체크리스트

1) **재배열 폭**: 상수 거리 내 국소 치환인가? → FST OK / 끝-의존·역순·전역 복사인가? → **2DFT/SST**.
2) **복제/출력 길이**: 출력이 입력의 **상수배(선형)** 이내인가? 초선형이면 **불가**.
3) **의존성**: 카운트 일치·중첩? → **PDT/CFG**.
4) **결정성**: 지연 유계인가? 아니라면 결정화 **불가** 위험.
5) **검증**: 동치/포함 자동화가 필요하면 **DFT 유지**를 최우선.
6) **엔지니어링**: 합성·최소화 단계별 **스냅샷/캐시**, 대규모 규칙은 **온디맨드** 로딩.

---

## **케이스 스터디** — 세 가지 전형

### 토큰 정규화(숫자→말로 읽기) — **가능**

- “123” → “일백이십삼” 같이 **좌→우** 진행, **국소 컨텍스트**로 충분.
- DFT로 세 자리 그룹을 처리하며 **고정 패턴 출력**.

```python
# '0'~'9' → 한글 숫자명, 자리수에 따라 접미사

num = {'0':'영','1':'일','2':'이','3':'삼','4':'사','5':'오','6':'육','7':'칠','8':'팔','9':'구'}
suf = {0:'', 1:'십', 2:'백', 3:'천'}  # 블록 내 자리
# 상태는 "블록 위치(0..3)"와 "전체 내 위치" 등 유한 정보로 표현 가능

```

### 마지막 글자 규칙(끝이 모음이면 접두 ‘y’ 추가) — **불가능(1-way)**

- “끝이 모음인지”는 **마지막에 결정**됨 → 접두 삽입은 **무한 지연** 요구 → DFT 불가.
- **대안**: 2DFT(끝에서 검사 후 좌로 이동해 접두 출력) 또는 SST(변수에 전체를 모아두고 앞에 상수 붙이기).

### 괄호 균형에 따른 변환 — **불가능(1-way)**

- “균형 검사” 자체가 Dyck 스택 요구 → FST 불가.
- **대안**: PDT.

---

## **자주 하는 오해** 체크

- “출력을 전부 끝에서 내면 역순 가능?” → **아님**.
  최종 출력은 상태별 **상수 문자열**이어야 하므로, 입력 내용에 따라 달라지는 **가변 길이 꼬리**를 임의로 만들 수 없다.

- “비결정으로 때우면 되지 않나?” → **핵심 한계는 그대로**.
  비결정은 선택지를 늘릴 뿐, **유한 기억** 제약은 못 깬다. 결정화가 **불가능**해질 수도 있다(지연 무계).

---

## 수학 메모(요지)

- **선형 출력 상계**:
  $$|\mathrm{out}(x)|\le c_0 + c_1|x|$$
  (ε-출력 사이클 제거/정상형 가정)

- **k-동기**(bounded delay):
  $$\exists k\ \forall \text{run }r: \big|\#\text{read}(r_{\le t}) - \#\text{out}(r_{\le t})\big|\le k$$

- **순차 함수 ⊊ 2-way/SST**:
  2-way/SST는 역순·끝-의존 재배열·상수회 복사 가능, DFT는 불가.

---

## 마무리 — 실전 요약

- 1-way FST는 **정규 관계**까지. **역순/전역 복사/끝-의존/중첩**은 **모델상 불가**.
- NFT의 함수도 **항상 결정화**되진 않는다(지연 유계 필요).
- 출력 길이는 **선형 상계**. 전역 폭증/무한 지연은 금지.
- 검증·최적화·운영을 생각하면 **가능한 한 DFT로 유지**하되, 필요한 곳만 **2DFT/SST/PDT**로 단계적 확장하라.

---


# 실무 체크리스트 (한 장)

[ ] 문제의 재배열 폭: 상수? → FST / 전역? → 2DFT/SST
[ ] 출력 길이: 선형 상계? 초선형이면 불가
[ ] 의존성: 카운트/중첩? → PDT
[ ] 결정성: 지연 유계(Twinning) 확인
[ ] 아키텍처: 결정적 모듈로 분해, 합성·결정화·최소화 지점 관리
[ ] 검증: 제품 탐색으로 동치·반례 자동화, 회귀 테스트 세트 확보
