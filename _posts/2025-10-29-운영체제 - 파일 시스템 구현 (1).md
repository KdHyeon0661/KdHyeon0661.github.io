---
layout: post
title: 운영체제 - 파일 시스템 구현 (1)
date: 2025-10-29 16:25:23 +0900
category: 운영체제
---
# Chapter 14 — File-System Implementation

## File-System Structure

### 온디스크 레이아웃(전형적 예)

아래는 “블록 기반, 아이노드, 저널(선택)”을 쓰는 전형적 레이아웃의 개념도다.

```
| Boot | Superblock | GroupDesc... | [Block Group 0] | [Block Group 1] | ... |
               └─ FS-wide 정보(블록 크기, inode/블록 수, 마운트 상태, 저널 위치…)

[Block Group k]
  | Superblock copy (선택)
  | Block bitmap
  | Inode bitmap
  | Inode table
  | Data blocks (파일/디렉터리/간접블록/저널 등)
```

- **Superblock**: 블록 크기/개수, inode 개수, features(저널링, extents 등), 클린 마운트 플래그.
- **Inode**: 파일 메타데이터 + **블록 매핑**(직접/간접/이중/삼중 또는 **extent**).
- **Block Group**(or Allocation Group): **지역성(locality)** 향상 · 동시성 증가 · 빠른 복구를 위해 공간을 적당히 나눔.
- **저널 영역**(메타데이터 또는 데이터+메타데이터): **write ordering** 를 단순화, 크래시 일관성 확보.

> 설계 축: **블록 크기(4KiB? 16KiB?)**, **매핑 방식(block map vs extent)**, **저널링 vs Copy-on-Write(COW)**, **검증(체크섬)**, **압축/암호화**.

---

### 페이지 캐시 & 버퍼 캐시 & 블록 계층

- **페이지 캐시**: 파일 내용 캐시(읽기 hit/리드어헤드, 지연쓰기).
- **버퍼 캐시**: 블록 장치의 메타블록 캐시(현대 Linux는 페이지 캐시 기반으로 통합).
- **블록 계층**: 요청 병합/정렬/스케줄러(Deadline/BFQ/Kyber), 멀티큐(blk-mq), **FUA/flush**.

---

### 주소 변환: 파일 오프셋 → 블록 LBA

- **Block-map**: `direct[0..11]`, `single_indirect`, `double_indirect`, `triple_indirect`.
- **Extent**: `(start_lba, length)` 조각들의 목록(큰 연속 공간을 효율적으로 표현).

**랜덤 접근 복잡도**
- Block-map: 깊이 최대 3(삼중 간접) → 오버헤드 ↑, 하지만 작은 파일엔 효율적.
- Extent: 큰 파일에 유리(메타데이터 작음), **프래그먼트** 심하면 extent 수 증가.

---

### 비트맵/프리리스트/범위 트리

**공간 할당자**는 빈 공간을 관리한다.
- **비트맵**: 1비트=1블록. 연속 찾기는 스캔/힙 구조 병용.
- **프리리스트**: 자유 블록의 연결 리스트(랜덤성↑/관리비용↑).
- **범위 트리(예: RB/B+ tree)**: (시작, 길이)로 자유 공간을 모형화 → **큰 extent** 빠르게 할당.

**간략 수식**: 비트맵 스캔 평균 비용
빈도 \(f\) (빈 블록 비율)에서 연속 길이 \(k\) 찾기 기대 스캔량 \(E[S]\)는 근사적으로
$$
E[S] \approx \frac{k}{f}
$$
(f가 낮을수록(조각↑) 스캔 비용이 가파르게 증가)

---

### 무결성/일관성: 저널링 vs COW vs 로깅

- **저널링(Write-ahead logging)**
  - **메타데이터 only**(ext4 ordered), **데이터+메타데이터**(data=journal) 모드.
  - 순서: *저널 기록 → 커밋 → 홈 장소 반영*. 크래시 때 재생(redo).
- **COW(ZFS, Btrfs)**
  - 새로운 블록을 **항상 새 위치**에 기록, **루트 포인터 스윙**으로 원자적 커밋.
  - 체크섬/압축/스냅샷이 자연스러움. **유지보수는 GC/스페이스앰프** 고려.
- **Log-structured**
  - 순차 로그처럼 쓰고, **세그먼트 정리**로 살아있는 데이터만 집약.

**쓰기 증폭(Write Amplification) 근사**
- 블록 크기 \(B\), 평균 쓰기 청크 \(w\), 저널 커밋 오버헤드 \(J\) →
  $$ \text{WA} \approx \frac{w + J}{w} $$
- COW에서 GC가 개입하면, **활성 비율** \(\alpha\)와 세그먼트 청소 오버헤드 \(C\)로 증가.

---

### (토이) 슈퍼블록/아이노드 구조 스케치(C)

```c
// toyfs_meta.h — 개념용(실제 FS 아님)
#include <stdint.h>
#define TOY_BLKSZ 4096
#define TOY_NDIRECT 12

typedef struct {
  uint32_t magic;         // 'T','F','S','1'
  uint32_t block_count;
  uint32_t inode_count;
  uint32_t free_block_head;    // free list or bitmap start
  uint32_t inode_table_start;
  uint32_t journal_start;      // 0 = no journal
  uint32_t features;           // bit flags
} toy_super_t;

typedef struct {
  uint16_t mode;      // rwx bits + type
  uint16_t links;
  uint32_t uid, gid;
  uint64_t size;
  uint64_t atime, mtime, ctime;
  uint32_t direct[TOY_NDIRECT];
  uint32_t single_indirect;
  uint32_t double_indirect;
} toy_inode_t;
```

---

## File-System Operations

### 경로 해석(Path Resolution)

1) 루트(또는 cwd) inode에서 시작.
2) 컴포넌트별로 디렉터리 엔트리에서 **이름→inode** 조회(캐시: **dentry**).
3) 심볼릭 링크면 대상 경로로 전개( hop 제한).
4) 대상 inode를 얻어 **권한 체크** 후 핸들(열린 파일 객체) 생성.

```c
// pseudo: vfs_open(path, flags)
inode = resolve_path(path);         // dcache + 디렉터리 인덱스 탐색
check_access(inode, flags);
file *f = alloc_file(inode, flags); // per-process open-file table 엔트리
return fd_install(f);
```

---

### 읽기(Read) 경로

- **페이지 캐시 hit** → 유저 버퍼로 복사.
- miss → 블록 I/O 발행(리드어헤드), 완료되면 캐시에 반영 → 유저로 복사.
- **mmap**은 폴트 시 페이지 단위로 당김.

```c
// pseudo: vfs_read(f, buf, n, off)
while(n>0){
  page = pagecache_lookup(f->inode, off);
  if(!page) page = do_page_in(f->inode, off);  // 블록 읽기
  copy_to_user(buf, page->data + (off%PAGE), min(n, remain));
  off += took; n -= took;
}
```

---

### 쓰기(Write) 경로 & 지연쓰기(writeback)

- **커널 버퍼/페이지 캐시**에 쓰고 **dirty**로 마크 → 나중에 **writeback** 스레드가 배치로 디스크 반영.
- 파일 시스템이 **delayed allocation**을 쓰면, 실제 **블록 할당은 flush 시점**에 진행(조각화 감소).

**순서 보장**: 데이터 무결성이 중요하면
1) 데이터 블록 쓰기 →
2) **배리어/flush(FUA)** →
3) 메타데이터(크기/시간/디렉터리 엔트리) 커밋

---

### fsync()/fdatasync() 알고리즘(요약)

- 해당 파일의 dirty 페이지/메타데이터를 **홈 위치**에 기록하고 **장치 배리어**로 **미디어 내구**를 확보.
- 저널 FS라면 **해당 트랜잭션 커밋 완료**까지 기다림.

```c
// pseudo: vfs_fsync(f)
writeback_data_pages(f->inode);
journal_commit_metadata(f->inode);  // FS별 구현
blkdev_flush_cache();               // FUA/flush
```

---

### 원자적 rename() & TOCTOU 방지

- `rename(old, new)`는 대개 **원자적**. 새 이름에 다른 파일이 있으면 **교체**(동일 FS 내).
- 임시 파일에 쓰고 → `fsync(tmp)` → **`rename()`** 으로 교체하면 **크래시 일관성**이 좋다.

---

### 링크/언링크

- **하드 링크**: 같은 inode의 **참조 카운트** 증가. 삭제는 링크 수 0 & 열려있는 핸들 없음 → **공간 회수**.
- **심볼릭 링크**: 텍스트 경로 저장, 대상 소멸 시 **dangling** 가능.

---

### 크래시 일관성 시나리오

- **저널링**: 크래시 후 저널 재생으로 “메타데이터는 항상 일관된 상태” 보장. 데이터는 `ordered` 모드면 “적어도 **쓰인 바이트는 이전 쓰레기 대신 새 데이터**” 조건 만족.
- **COW**: 루트 스윙 전까지는 **옛 스냅샷**이 유효. 크래시에 강하지만 **GC/메타 증폭** 고려.
- **데이터=저널** 모드는 아주 안전하지만 쓰기 증폭↑.

---

### (토이) 파일 생성/쓰기/트렁크/삭제 로직 예제(Python 시뮬레이터)

```python
# toyfs_mem.py — 메모리 상 간단 FS: 비트맵, inode, 파일/디렉터리 연산

from dataclasses import dataclass, field
BLKSZ=4096; NBLK=4096; NIN=1024

@dataclass
class Inode:
    mode:int=0o100644; size:int=0; links:int=1
    blocks:list=field(default_factory=list)  # LBA 리스트 (direct only)

@dataclass
class FS:
    sb=dict; bitmap:list=field(default_factory=lambda:[0]*NBLK)
    inodes:list=field(default_factory=lambda:[None]*NIN)
    root:dict=field(default_factory=dict)  # name->inode#
    def __post_init__(self): self.inodes[0]=Inode(mode=0o040755); self.root={}
    def alloc_block(self):
        for i,b in enumerate(self.bitmap):
            if b==0: self.bitmap[i]=1; return i
        raise RuntimeError("no space")
    def free_block(self,i): self.bitmap[i]=0
    def alloc_inode(self):
        for i,x in enumerate(self.inodes):
            if x is None: self.inodes[i]=Inode(); return i
        raise RuntimeError("no inode")
    def create(self,name):
        ino=self.alloc_inode(); self.root[name]=ino; return ino
    def write(self,ino,off,data):
        f=self.inodes[ino]; pos=0
        while pos<len(data):
            blk_idx=(off+pos)//BLKSZ; blk_off=(off+pos)%BLKSZ; take=min(BLKSZ-blk_off,len(data)-pos)
            while blk_idx>=len(f.blocks):
                f.blocks.append(self.alloc_block())
            # (진짜로는 디바이스에 써야하지만 여기선 생략)
            pos+=take
        f.size=max(f.size, off+len(data))
    def truncate(self,ino,newsz):
        f=self.inodes[ino]; need=(newsz+BLKSZ-1)//BLKSZ
        while len(f.blocks)>need:
            self.free_block(f.blocks.pop())
        f.size=newsz
    def unlink(self,name):
        ino=self.root.pop(name); f=self.inodes[ino]; f.links-=1
        if f.links==0:
            for b in f.blocks: self.free_block(b)
            self.inodes[ino]=None

fs=FS(sb={"blksz":BLKSZ})
ino=fs.create("a.txt")
fs.write(ino, 0, b"hello"*1000)
fs.truncate(ino, 123)
fs.unlink("a.txt")
print("ok")
```

> *현실 FS* 는 저널/동시성/권한/디렉터리 인덱스/시간/오류 복구 등 훨씬 복잡하다. 위 코드는 연산 순서와 자원 생명주기 **개념 확인**용.

---

## Directory Implementation

### 디렉터리 엔트리 포맷

- **변길 엔트리(variable-length)**: `(name_len, name, inode, rec_len)` 형태로 패킹 → 삭제 시 **구멍 합치기(compaction)** 필요.
- **고정 길이**: 단순하지만 공간 낭비↑.
- 엔트리에는 보통 **타입 힌트**(file/dir/link)가 포함되나 **진실은 inode**에 있다.

```c
// toy_dirent.h — 개념
typedef struct {
  uint32_t ino;
  uint16_t rec_len;     // 이 엔트리 슬롯 길이
  uint8_t  name_len;
  uint8_t  file_type;   // 1=reg, 2=dir, 7=symlink...
  char     name[];      // name_len bytes (뒤에 패딩)
} toy_dirent_t;
```

---

### 선형 리스트(작은 디렉터리)

- **장점**: 구현/디버깅이 가장 간단.
- **단점**: 항목 수 \(N\)이 커지면 lookup 비용 \(O(N)\).

```python
# dir_linear.py — 선형 탐색/삭제/삽입

class Dir:
    def __init__(self): self.items=[]  # (name, ino)
    def lookup(self,name):
        for n,i in self.items:
            if n==name: return i
        return None
    def insert(self,name,ino):
        if self.lookup(name) is not None: raise ValueError("exist")
        self.items.append((name,ino))
    def remove(self,name):
        for k,(n,_) in enumerate(self.items):
            if n==name: self.items.pop(k); return
        raise FileNotFoundError
```

---

### 해시 디렉터리(HTree/dirhash)

- **아이디어**: 이름 해시 → **버킷** → bucket page에서 선형 탐색.
- **장점**: 기대 \(O(1)\) 근사 lookup, 디렉터리 수십/수백만 항목에서도 견딤.
- **충돌**: **체이닝** 또는 **재해싱**.
- ext4의 **HTree**는 B-tree 유사 구조에 **해시 범위**를 저장.

**버킷 과부하율** \( \alpha = \frac{n}{m} \) 에서 평균 탐색 길이(체인) 근사:
$$
E[\text{probe}] \approx 1 + \frac{\alpha}{2} \quad (\text{성공 시})
$$

```python
# dir_hash.py — 간단 체이닝 해시 디렉터리

from collections import defaultdict
class HashDir:
    def __init__(self, m=1024): self.m=m; self.tbl=defaultdict(list)
    def _h(self, name): return (hash(name) & 0xffffffff) % self.m
    def lookup(self, name):
        b=self._h(name)
        for n,i in self.tbl[b]:
            if n==name: return i
    def insert(self, name, ino):
        b=self._h(name)
        for n,_ in self.tbl[b]:
            if n==name: raise ValueError("exist")
        self.tbl[b].append((name,ino))
```

---

### B+-Tree 디렉터리(대형/정렬 필요)

- **키**: 파일 이름(정규화/대소문자 규칙 반영).
- **내부 노드**: 키 경계와 자식 포인터.
- **리프**: `(name, inode)` 정렬 리스트 + **순차 링크**(range scan 효율↑).
- **장점**: \(O(\log N)\), 범위 열거/정렬 리스트에 적합, **리밸런싱/스플릿** 지원.

```python
# bptree_dir.py — 아주 단순화된 B+Tree 리프만 스케치(실서비스 수준 아님)

class Leaf:
    def __init__(self): self.items=[]; self.next=None
    def insert(self, name, ino):
        import bisect
        keys=[k for k,_ in self.items]
        i=bisect.bisect_left(keys, name)
        if i<len(keys) and keys[i]==name: raise ValueError("exist")
        self.items.insert(i, (name,ino))
    def lookup(self, name):
        import bisect
        keys=[k for k,_ in self.items]
        i=bisect.bisect_left(keys, name)
        if i<len(keys) and keys[i]==name: return self.items[i][1]
```

> 실제 구현은 **고정 크기 블록**에 맞춰 엔트리를 패킹하고, **split/merge**, **트랜잭션(저널/코위팅)** 과 결합한다.

---

### 디렉터리 동시성 & 락 순서

- **락 계층**: 부모 디렉터리 → 자식 디렉터리/파일 순으로 취득(**교착 회피**).
- **rename(A→B)**: 두 디렉터리가 다르면 **정해진 순서**로 락(예: inode 번호 순) → 엔트리 이동 → 링크/타임스탬프 갱신 → 저널/커밋.
- **readdir vs 변경**: 일관된 스냅샷을 위해 **seqcount** 또는 **제너레이션 카운터** 사용.

---

### 대/소문자 & 유니코드 정규화

- **Case-sensitive**(리눅스 대부분) vs **case-insensitive(보존)**(윈도/일부 macOS 볼륨).
- 유니코드 **NFC/NFD** 차이로 “같아 보이는 이름”이 다른 바이트열일 수 있음 → 동일 FS 내 통일 규칙을 강제하거나 **정규화 키** 저장.

---

### 보안: `.`/`..`, 심링크 레이스, `openat()`

- 디렉터리에 하드 링크 금지(일반적) → **비순환 트리** 유지.
- 사용자 제공 경로 열기 시 **디렉터리 FD 기준 openat + O_NOFOLLOW** 로 심링크 레이스 방지(13장에서 실습 코드 제시).
- **Sticky bit** 디렉터리(`/tmp`): 소유자만 자신의 파일 삭제 가능.

---

### (토이) 디렉터리 이미지 생성기: 선형 vs 해시 성능 비교

```python
# dir_bench.py — 1M 엔트리에서 선형/해시 lookup 비교(개념)

import random, string, time
from dir_linear import Dir
from dir_hash import HashDir

def rndname(n=12):
    return ''.join(random.choice(string.ascii_letters) for _ in range(n))

N=200000
names=[rndname() for _ in range(N)]
target=random.choice(names)

dl=Dir();   t0=time.time()
for i,n in enumerate(names): dl.insert(n,i)
t1=time.time()
print("linear build:", t1-t0, "s")

dh=HashDir(4096); t0=time.time()
for i,n in enumerate(names): dh.insert(n,i)
t1=time.time()
print("hash build:", t1-t0, "s")

t0=time.time(); dl.lookup(target); t1=time.time()
print("linear lookup:", (t1-t0)*1e6, "us")

t0=time.time(); dh.lookup(target); t1=time.time()
print("hash lookup:", (t1-t0)*1e6, "us")
```

---

## 계산적 인터메조: 조각화와 연속성

평균 파일이 \(m\)개의 extent로 나뉘고, 각 extent 접근 시 고정 오버헤드 \(t_0\), 단위 바이트 전송 시간 \(t_b\)라면 크기 \(S\) 파일의 추정 I/O 시간은
$$
T \approx m \cdot t_0 + S \cdot t_b
$$
따라서 **extent 수 \(m\)** 를 줄이는 할당(가깝고 큰 연속 공간 선호)이 중요하다. **지연 할당**과 **범위 트리 기반 할당자**가 이에 효과적.

---

## 실전 체크리스트(요약)

1) **레이아웃/블록 크기**: 워크로드(작은 파일 vs 대용량 연속)에 맞는 블록/클러스터/extent 정책.
2) **공간 관리자**: 비트맵 + 범위 트리로 대형 연속 할당을 우선, 그룹/AG로 지역성 확보.
3) **일관성**: ordered-data 저널 또는 COW의 **원자성 경계**를 문서화. `fsync` 의미와 비용을 SLA에 반영.
4) **디렉터리**: 작은 곳은 선형, 큰 곳은 **해시/B+트리**. 이름 정규화/대소문자 정책을 한곳에 강제.
5) **동시성/락**: rename/링크/삭제의 락 순서를 고정. readdir와의 경합을 계측.
6) **운영**: 스크럽/체크섬, quota, 오류 주입 테스트(전원 차단 시나리오), 장치 flush(배리어) 확인.

---

## 통합 실습: “미니 이미지 FS” (학습용)

**목표**: 단일 파일(`toy.img`) 안에 매우 간단한 FS를 만들고, `mkfs`/`mkdir`/`create`/`write`/`ls`를 실행.

**구현 아이디어**
- 고정 블록 크기 4KiB, 비트맵으로 공간 관리, 선형 디렉터리.
- 아이노드는 정적 배열(테이블). 파일은 **직접블록 N개 + 단일 간접**.
- 메타 업데이트는 “메타 먼저 저널 파일에 append → 커밋 레코드 → 홈 위치 반영”(초간단 저널).

> 분량상 여기서는 **핵심 루틴**만 제시한다. (전체 실행형 구현은 위 스케치들을 조합)

```python
# mkfs_toy.py — 이미지 파일 초기화

import os, struct
BLKSZ=4096; NBLK=8192; NIN=512
MAGIC=b'TFS1'
sb_fmt="<4sIIIHHII"  # magic, blks, ins, blksz, nin, rsv, ino_tbl_blk, bmap_blk
def mkfs(path):
    with open(path,"wb") as f:
        f.truncate(BLKSZ*NBLK)
        sb = struct.pack(sb_fmt, MAGIC, NBLK, NIN, BLKSZ, NIN, 0, 1, 2)
        f.write(sb + b"\x00"*(BLKSZ-len(sb)))      # super @0
        f.seek(BLKSZ*2)                            # bitmap @2
        f.write(b"\x00"*BLKSZ)
        # inode table @1 block부터 (여기선 단순화)
        # root inode(0)를 디렉터리로 초기화 (실제로는 별도 구조 필요)
if __name__=="__main__": mkfs("toy.img"); print("ok")
```

```python
# toy_dir_pack.py — 디렉터리 블록 패킹/언패킹 (변길 엔트리)

import struct
def pack_dir(entries):
    data=b""
    for name,ino in entries:
        n=name.encode(); rec=8+1+len(n) # ino(4)+reclen(2)+typ(1)+name
        rec2=(rec+3)&~3                  # 4B 정렬
        data+=struct.pack("<IHB", ino, rec2, 1)+n + b"\x00"*(rec2-rec)
    return data + b"\x00"*(4096-len(data))
def unpack_dir(block):
    off=0; out=[]
    while off+8<=4096:
        ino,rec,typ=struct.unpack_from("<IHB", block, off)
        if rec==0: break
        name=block[off+7:off+rec].rstrip(b"\x00")
        if ino!=0: out.append((name.decode(),ino))
        off+=rec
    return out
```

> 위 조각들로 **mkfs→root 디렉터리 생성→파일 생성/쓰기→디렉터리 열거**까지 엮으면 “학습용 미니 FS”를 완성할 수 있다. 핵심은 **온디스크 포맷을 고정하고, 블록 단위로 일관성 있게 읽고/쓰기**다.

---

## 핵심 요약

- **14.1 구조**: 슈퍼블록·아이노드·블록 그룹·저널/로그·(block-map vs extent)·비트맵/범위트리로 공간을 관리한다. **페이지 캐시/블록 계층**이 성능의 1차 방정식.
- **14.2 연산**: 경로 해석→권한 검증→페이지 캐시·writeback·저널/배리어를 통한 **일관성 보장**. 원자적 `rename`와 `fsync` 시맨틱이 **크래시 안전성**의 열쇠.
- **14.3 디렉터리**: 선형/해시/B+트리 구현 중 워크로드에 맞춰 선택. 대형 디렉터리는 **해시/B+트리**, 이름 정규화·락 순서·TOCTOU 방지를 체계화해야 한다.
