---
layout: post
title: DB 심화 - 라이브러리 캐시 구조
date: 2025-10-28 17:25:23 +0900
category: DB 심화
---
# Oracle **라이브러리 캐시(Library Cache) 구조**

> 목표
> - 라이브러리 캐시가 **무엇을 저장**하고 **어떻게 찾고**(해시/체인), **어떻게 보호**(락/핀/뮤텍스)하는지 구조적으로 이해한다.  
> - **SQL 커서(Parent/Child)**, **PL/SQL 객체**, **데이터베이스 오브젝트(테이블/인덱스/뷰)** 가 **KGL(Kernel Generic Library)** 네임스페이스에서 어떻게 관리되는지 안다.  
> - **무효화(DDL/통계변경)** → **재파싱** → **경합(라이브러리 캐시 락/핀/뮤텍스)** → **성능문제**의 전형을 **증상→원인→해법** 순서로 다룬다.  
> - `V$` / `DBA_` 주요 뷰를 사용하여 **진단 스크립트**를 만들고, **예방/최적화** 기법을 정리한다.

---

## 0) 큰 그림: 라이브러리 캐시는 **“실행 가능한 코드/계획(커서)”와 메타데이터 저장소**
- **Shared Pool** 안에 위치한 **Library Cache**는 다음을 저장한다.
  - **SQL 커서**: 파싱된 문장(파스 트리), **실행계획(Plan)**, 바인드/환경, Runtime 구조.
  - **PL/SQL 코드**: 패키지/프로시저/함수/트리거의 파싱/컴파일 결과.
  - **데이터베이스 오브젝트 정의**: 테이블/인덱스/뷰/시노님 등의 **의존성과 메타**(캐시된 딕셔너리).
- 이들은 **KGL 네임스페이스**(`SQL AREA`, `TABLE/PROCEDURE`, `TRIGGER`, `VIEW` 등)로 관리된다.
- 키 포인트:
  1) **해시 버킷**에 텍스트/이름 기반으로 매핑 → **체인 검색** 후 **커서/오브젝트 핸들** 획득.  
  2) **Lock/Pin/Mutex**로 일관성 보장(파스, 실행, 컴파일/무효화 동시성).  
  3) **Aging(재사용 LRU)** / **Flush** 로 메모리 압박 시 청소.  
  4) **Invalidation(무효화)**: DDL/통계 변경/권한 변경 등으로 커서/오브젝트 재검증·재파싱 필요.

---

## 1) 네임스페이스 & 핵심 개념(용어 정리)
- **KGL(Kernel Generic Library)**: 라이브러리 캐시 공통 인프라 계층.  
- **Namespace**: 동일 종류의 엔트리 분류(대표적으로)  
  - `SQL AREA` (SQL 커서)  
  - `TABLE/PROCEDURE` (PL/SQL/오브젝트)  
  - `TRIGGER`, `VIEW`, `JAVA SOURCE`, `JAVA CLASS` 등  
- **Handle / Object**:
  - **Handle**: 이름(키)→오브젝트(버전)에 접근하기 위한 **헤더**(메타, 위치).  
  - **Object(또는 Heap들)**: 실제 내용(파스 트리/코드/플랜 등)이 들어 있는 **메모리 힙 집합**.
- **Parent Cursor / Child Cursor**(SQL의 경우):
  - **Parent**: **SQL 텍스트** 단위 식별(= `SQL_ID`).  
  - **Child**: 같은 텍스트라도 **환경/세팅/바인드 패턴/스키마 차이**로 분기된 **실행 가능한 단위**.
- **Heaps**(대표):
  - Heap 0(핵심 메타), Heap 6(실행계획, predicate 등) 등 **세부 힙**으로 나뉘어 관리(버전별 상이).
- **의존성(Dependency)**:
  - 커서/PLSQL → **테이블/인덱스/뷰** 등 참조 오브젝트에 **의존**.  
  - 참조 대상 DDL/통계/권한 변경 시 **Invalidation** 트리거링.

---

## 2) 구조: 해시 버킷 → 해시 체인 → 핸들(Parent) → 오브젝트(Child/Heaps)
1. **Hashing**:  
   - SQL은 **정규화된 텍스트**(공백/대소문자 표준화 + NLS 환경 등 영향)로 해시 → **해시 버킷** 선택.  
   - PL/SQL/오브젝트는 **이름/스키마** 기반으로 해시.
2. **Bucket Chain Lookup**:  
   - **동일 해시**를 가진 **핸들(Parent)** 들이 체인으로 연결.  
   - 체인에서 **키 동일**한 핸들을 찾아 잠금/핀 후 내부로 진입.
3. **Child 찾기**(SQL):
   - Parent 아래에 **Child 리스트**(실행가능 단위).  
   - **옵티마이저 환경/바인드 패턴/스키마 차이** 등 **공유 불가** 요인에 따라 여러 Child 공존.
4. **Heaps**:
   - Child마다 **여러 힙**(파스 트리, 실행계획, 통계, outline 등)을 보유.  
   - 필요 시 **Aging**(부분/전체) 또는 **무효화**로 해제.

> 관점: “**문장(Parent)** 를 찾고, 그 안에서 **조건 맞는 실행체(Child)** 를 찾는다.”

---

## 3) 라이브러리 캐시 보호: **Lock / Pin / Mutex**
- **Library Cache Lock**: **오브젝트 정의** 사용 중 **DDL/드롭** 등 구조 변경으로부터 보호(공유/독점).  
- **Library Cache Pin**: **메모리 힙(콘텐츠)** 를 사용/변경할 때 **컨시스턴시** 보장(실행/컴파일 시).  
- **Mutex**(현대 오라클에서 latch를 대체하는 경량 동기화):
  - **`library cache: mutex X`/`S`** 대기 이벤트로 드러나는 경합.  
  - **Child Cursor 레벨**의 매우 미세한 보호(파스/컴파일/플랜 접근/바인드 캡처 등).

### 3.1 언제 잠구는가?
- **파싱/최적화**: 커서 생성/변환/플랜 생성 중 Parent/Child에 대한 **X/S Mutex/Pin**.  
- **실행**: Child 접근 시 **S 공유 보호**(일반적으로 S 수준).  
- **Invalidation/DDL**: 참조 대상 변동 시 **Lock/Pin 전환/무효화 작업** 필요 → 동시성 영향.

---

## 4) 무효화(Invalidation)와 재파싱(Re-Parse)
- **트리거**: DDL(ALTER TABLE/INDEX …), 통계 변경(큰 차이), 권한 변경, 종속 오브젝트 재컴파일 등.  
- **효과**: 커서/오브젝트 **상태 INVALID** → 다음 실행 시 **재파싱/재컴파일** 필요.  
- **증상**: 하드파싱 증가, `library cache lock/pin` or `library cache: mutex X` 대기 증가, CPU 스파이크.

### 4.1 실습: 무효화 관찰
```sql
-- 1) 실험용 쿼리 실행
SELECT /* libcache demo */ COUNT(*) FROM orders WHERE order_date >= DATE '2025-10-01';

-- 2) 같은 세션에서 실행계획 확인(커서 존재)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'BASIC +NOTE'));

-- 3) 다른 세션에서 대상 테이블 DDL 수행(인덱스 추가 등)
CREATE INDEX ix_orders_dt ON orders(order_date);

-- 4) 원 세션에서 재실행 → 재파싱 필요(무효화 후)
SELECT /* libcache demo */ COUNT(*) FROM orders WHERE order_date >= DATE '2025-10-01';

-- 5) V$SQL에서 parse_calls 증가 확인
SELECT sql_id, child_number, executions, parse_calls, invalidations
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* libcache demo */ COUNT(*) FROM orders%';
```

---

## 5) Aging(청소)와 메모리 힙
- **Aging/LRU**: Shared Pool 압박이 오면 **오래 안 쓰인 힙/커서**부터 **청소**.  
- **Partial Aging**: Child 일부 힙만 방출, 다음 접근 시 재로딩.  
- **Full Flush**: `ALTER SYSTEM FLUSH SHARED_POOL` (주의: 광범위 하드파싱 유발).  
- **DBMS_SHARED_POOL.KEEP/UNKEEP**: 중요 PL/SQL/패키지/일부 커서를 **핀**(Evict 방지) — 신중히 사용.

```sql
-- 패키지 핀(자주 사용하는 PL/SQL 코드 상주)
BEGIN
  DBMS_SHARED_POOL.KEEP('MYAPP.PKG_ORDER');  -- 오브젝트 이름(OWNER.OBJECT)
END;
/
-- 해제
BEGIN
  DBMS_SHARED_POOL.UNKEEP('MYAPP.PKG_ORDER');
END;
/
```

---

## 6) SQL 커서 구조(Parent/Child)와 공유 실패 원인
- **Parent(=SQL_ID)** 아래에 **Child들**이 존재; Child는 **환경 차이**로 분기:
  - **바인드 관련**: 바인드 타입/길이/패턴 불일치, 바인드 센서티브/어웨어 차이.  
  - **옵티마이저 환경**: 세션 파라미터/환경 변수(`optimizer_mode`, NLS 등).  
  - **스키마/권한**: 파싱 스키마 다른 경우(동일 텍스트라도 다른 오브젝트 가리킴).  
  - **버전/기능**: 기능 사용 여부(Adaptive, 결과 캐시 등).
- 원인 확인: `V$SQL_SHARED_CURSOR`
```sql
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_id = :sql_id
  AND  reason IS NOT NULL AND reason <> 'N';
```

### 6.1 Child 폭증 진단
```sql
SELECT sql_id, COUNT(*) children,
       SUM(parse_calls) parse_calls,
       MAX(is_bind_sensitive) bs, MAX(is_bind_aware) ba
FROM   v$sql
GROUP  BY sql_id
HAVING COUNT(*) > 10
ORDER  BY children DESC FETCH FIRST 20 ROWS ONLY;
```
**대응**  
- **바인드 변수** 표준화(리터럴 남발 금지)  
- **히스토그램 + ACS** 로 바인드 스큐 안정  
- **환경 통일**(세션 파라미터 표준)  
- 임시 회피: `CURSOR_SHARING=FORCE` (부작용 위험, 설계/검증 필수)

---

## 7) 라이브러리 캐시 관찰 뷰와 지표
- `V$LIBRARYCACHE`: 네임스페이스별 **Get/Pin 요청/미스/Reload/Invalidation** 통계
```sql
SELECT namespace, gets, gethits, pins, pinhits, reloads, invalidations
FROM   v$librarycache
ORDER  BY namespace;
```
- `V$DB_OBJECT_CACHE`: 캐시된 오브젝트 목록/상태/잠금/핀
```sql
SELECT owner, name, type, locks, pins, kept
FROM   v$db_object_cache
ORDER  BY pins DESC FETCH FIRST 20 ROWS ONLY;
```
- `V$SQL`, `V$SQLAREA`, `V$SQL_PLAN`: 커서/집계/플랜  
- `V$SQL_SHARED_CURSOR`: 공유 실패 이유  
- `V$EVENT_NAME` / `V$SYSTEM_EVENT` / `V$SESSION`: 대기 이벤트  
  - `library cache: mutex X/S`, `library cache lock`, `library cache pin` 등

---

## 8) 동시성 & 대기 이벤트(증상→원인→해법)

### 8.1 `library cache: mutex X` / `library cache: mutex S`
- **증상**: 파스/실행 중 대기 증가, CPU 낮은데 응답 느림.  
- **원인 패턴**  
  1) **하드파싱 과다**(리터럴 SQL/DDL 빈발) → Child 생성/컴파일 경합.  
  2) 특정 인기 커서(“핫 커서”)에 대한 접근 경합.  
  3) 대량 `INVALIDATION` 후 재파싱 폭주.
- **해법**  
  - **바인드 사용**, `SESSION_CACHED_CURSORS` 적절히, 하드파싱 원인 제거.  
  - **핫 커서 분산**: 바인드 변형/앱 설계(단, 커서 공유 이점 상실하지 않도록).  
  - 불필요 DDL/통계 재수집 줄이기, 스케줄 분산.

### 8.2 `library cache lock` / `library cache pin`
- **증상**: DDL/컴파일/오브젝트 재검증 시 대기.  
- **원인**: 실행 중인 세션이 오브젝트를 **Pin/Lock**으로 보호하는 동안, DDL/무효화를 요청한 세션이 대기.  
- **해법**: 배포/DDL 타이밍 **창 분리**, 장수행 커서/PLSQL **분할**, **커밋 주기** 조정.

### 8.3 진단 스크립트(최근 15분, 라이브러리 캐시 관련 대기)
```sql
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '15' MINUTE; EXEC :t2 := SYSTIMESTAMP;

SELECT session_id, event, sql_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event IN ('library cache: mutex X','library cache: mutex S',
                 'library cache lock','library cache pin')
GROUP  BY session_id, event, sql_id
ORDER  BY samples DESC FETCH FIRST 30 ROWS;
```

---

## 9) 실전 시나리오

### 9.1 시나리오 A — “리터럴 폭주” → 하드파싱 경합
**증상**: `library cache: mutex X` 증가, `parse count (hard)`↑, CPU는 평범.  
**원인**: 애플리케이션이 바인드 대신 **리터럴**로 SQL 생성.  
**해법**:
1) 애플리케이션 **바인드 변수 표준화**  
2) (임시) `CURSOR_SHARING=FORCE` 로 급한 불 끄기(정확도 저하 주의)  
3) `SESSION_CACHED_CURSORS` ↑ 로 소프트파싱 증가  
**검증**: `V$SYSSTAT`의 `parse count (hard)`↓, `mutex` 이벤트 샘플↓.

### 9.2 시나리오 B — “배포 직후” → Invalidations 폭주
**증상**: 배포 시점 `library cache lock/pin` 급증, 응답 지연.  
**원인**: DDL/패키지 재컴파일이 **동시에** 발생, 장수행 세션이 오브젝트 Pin 유지.  
**해법**:  
- 배포/DDL **윈도우** 설정(사용자 저부하 시간), 오브젝트 단위 **순차 재컴파일**  
- **세션 드레인**(장수행 종료 후 배포)  
**검증**: 배포 시 이벤트 샘플/피크 시간 **완화**.

### 9.3 시나리오 C — “핫 커서” 쏠림
**증상**: 특정 `SQL_ID`에서 `library cache: mutex S/X` 집중.  
**원인**: 동일 커서에 **집중 접근**, Child 조건도 동일 → 동일 핫 스팟.  
**해법**:  
- **바인드 범위별 ACS 유도**(히스토그램/스큐), 일부 Child로 분산  
- 커서 텍스트/힌트/옵션 **미세 분기**(신중)  
**검증**: 동일 시각 Child가 **여러 개**로 균등 실행, 이벤트 샘플 분산.

---

## 10) 개발자가 당장 쓸 수 있는 **예방 체크리스트**
1) **바인드 변수** 사용(ORM/프레임워크 기본 옵션 확인).  
2) **리포트/배치** SQL은 최대한 **재사용 가능한 형태**로 설계.  
3) 자주 쓰는 PL/SQL 패키지는 **컴파일 경고 제거** 및 필요 시 **KEEP**(핀) 검토.  
4) 변경(DDL/통계 수집)은 **저부하 시간**에, 대규모는 **순차화/배치화**.  
5) **세션 파라미터/NLS** 등 환경 차 이를 **일관화**.  
6) **핫 커서 모니터링**: 상위 `executions`/`parse_calls`/`loads`/`invalidations` 확인.  
7) **테스트 환경**에서도 실제와 같은 **바인드 분포**를 재현(ACS/히스토그램 효과 검증).

---

## 11) 라이브러리 캐시 관찰/튜닝 **스크립트 모음**

### 11.1 네임스페이스 상태
```sql
SELECT namespace,
       gets, gethits, ROUND(gethits*100/NULLIF(gets,0),1) get_hit_pct,
       pins, pinhits, ROUND(pinhits*100/NULLIF(pins,0),1) pin_hit_pct,
       reloads, invalidations
FROM   v$librarycache
ORDER  BY namespace;
```

### 11.2 캐시된 오브젝트 상위(핀/락/보존)
```sql
SELECT owner, name, type, locks, pins, kept
FROM   v$db_object_cache
ORDER  BY pins DESC
FETCH FIRST 30 ROWS ONLY;
```

### 11.3 커서 재사용/하드파싱 부담
```sql
-- 시스템 지표
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('parse count (total)','parse count (hard)','parse time elapsed','session cursor cache hits')
ORDER  BY name;

-- 리터럴 의심(Child 폭증 SQL)
SELECT sql_id, COUNT(*) children, SUM(parse_calls) parse_calls, MAX(loads) loads
FROM   v$sql
GROUP  BY sql_id
HAVING COUNT(*) > 8
ORDER  BY children DESC FETCH FIRST 20 ROWS;
```

### 11.4 공유 실패 이유
```sql
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_id = :sql_id
  AND  reason IS NOT NULL AND reason <> 'N'
ORDER  BY child_number;
```

### 11.5 라이브러리 캐시 관련 대기(ASH)
```sql
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '30' MINUTE; EXEC :t2 := SYSTIMESTAMP;

SELECT event, sql_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event IN ('library cache: mutex X','library cache: mutex S','library cache lock','library cache pin')
GROUP  BY event, sql_id
ORDER  BY samples DESC FETCH FIRST 30 ROWS;
```

### 11.6 커서 텍스트/플랜 확인
```sql
-- 텍스트(부분)
SELECT sql_id, child_number, DBMS_LOB.SUBSTR(sql_fulltext, 1000, 1) sql_text
FROM   v$sql
WHERE  sql_id = :sql_id;

-- 라인 통계(마지막 실행)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(:sql_id, :child,
  'ALLSTATS LAST +PEEKED_BINDS +NOTE +OUTLINE'));
```

---

## 12) PL/SQL & 라이브러리 캐시

### 12.1 PL/SQL도 라이브러리 캐시에 컴파일 산출물이 상주
- 패키지/함수/프로시저/트리거는 **`TABLE/PROCEDURE`** 네임스페이스 등으로 관리.  
- **의존성**: 참조 테이블/뷰 변경 시 **재컴파일/무효화**.  
- **KEEP**으로 상주(자주 호출되는 유틸 패키지), 단 스페이스 관리에 유의.

### 12.2 간단 예제
```sql
CREATE OR REPLACE PACKAGE pkg_demo AS
  FUNCTION f_order_cnt (p_from DATE) RETURN NUMBER;
END;
/

CREATE OR REPLACE PACKAGE BODY pkg_demo AS
  FUNCTION f_order_cnt(p_from DATE) RETURN NUMBER IS
    v_cnt NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_cnt FROM orders WHERE order_date >= p_from;
    RETURN v_cnt;
  END;
END;
/

-- 호출
VAR d DATE; EXEC :d := DATE '2025-10-01';
VAR c NUMBER; EXEC :c := pkg_demo.f_order_cnt(:d);

-- 캐시에서 확인
SELECT owner, name, type, locks, pins, kept
FROM   v$db_object_cache
WHERE  name = 'PKG_DEMO';
```

---

## 13) 메모리 힙(Heaps)과 리로드(Reload)
- **Heap 0**: 헤더/핵심 메타,  
- **Heap 6**: 실행계획·Predicate/Projection 등(버전별로 구성 차이 존재).  
- **Reloads**: 힙 일부가 aged out → 다음 접근 시 **재로딩**(성능 오버헤드).  
- **대응**: Shared Pool 크기/프래그먼트 관리, **큰 커서/PLSQL** 핀(핀은 과용 금지).

```sql
-- 네임스페이스 리로드/무효화 관찰
SELECT namespace, reloads, invalidations
FROM   v$librarycache
ORDER  BY reloads DESC;
```

---

## 14) RAC 환경 포인트
- 각 인스턴스는 **자체 라이브러리 캐시** 보유.  
- 커서 공유는 **인스턴스 로컬**(동일 SQL도 인스턴스마다 존재).  
- DDL/통계 변경은 **클러스터 광역