---
layout: post
title: 데이터 통신 - Data Link Control (1)
date: 2024-07-29 21:20:23 +0900
category: DataCommunication
---
# Chapter 11. Data Link Control — DLC Services & 기본 프로토콜 (Simple / Stop-and-Wait / Piggybacking)

- 물리 계층(신호, 비트 전송) 위에서
  - **비트를 “프레임(frame)” 단위로 자르고 붙이고,**
  - **흐름제어(flow control)** 로 빠른 송신자를 제어하며,
  - **오류제어(error control)** 로 손상/손실을 복구하고,
  - 필요하면 **연결지향 논리 링크**까지 제공하는 것이 DLC의 역할이다.

---

## DLC Services

데이터링크 계층이 상위(IP 계층 등)에 제공하는 기본 서비스는 크게 네 가지로 묶을 수 있다.

1. **Framing**
   비트 스트림을 **논리적인 프레임 단위**로 나누고 식별하는 기능.
2. **Flow and Error Control**
   수신 버퍼가 넘치지 않도록 속도를 조절하고, 프레임 손상·손실을 처리하는 기능.
3. **Connectionless / Connection-oriented 서비스**
   상위 계층에 **단순한 프레임 전달(service)** 만 제공할지,
   **논리 링크(연결) 설정·해제·신뢰성 보장**까지 포함한 서비스를 제공할지 결정하는 것.

각 항목을 조금 더 세밀하게 본다.

---

### Framing

#### 1) 왜 프레이밍이 필요한가?

물리 계층은 그냥 **“비트의 연속”** 을 전송할 뿐이다.
하지만 상위 계층(네트워크 계층, 전송 계층)은 **“패킷/세그먼트 단위”** 로 데이터를 다룬다.

그 사이에서 데이터링크 계층은 다음을 해결해야 한다.

- 어디서부터 어디까지가 **한 덩어리(프레임)** 인지 구분
- 각 프레임에 **주소(MAC 주소 등), 제어 정보, 에러 검출 필드(CRC)** 추가
- 상위 계층의 “패킷”을 내부적으로 여러 프레임으로 나누거나, 반대로 합치는 작업

즉, DLC는 **“비트 스트림”을 “프레임”이라는 논리 단위로 정리해 주는 계층**이다.

---

#### 2) 일반적인 프레임 구조

많은 표준(HDLC, PPP, 이더넷 등)을 추상화하면 프레임은 보통 다음과 같은 구조다.

| 필드 | 역할 |
|------|------|
| 헤더(Header) | 목적지/출발지 주소, 제어 정보, 프로토콜 타입 등 |
| 페이로드(Payload) | 상위 계층에서 내려온 데이터 (예: IP 패킷) |
| 트레일러(Trailer) | 에러 검출 코드(CRC 등), 종료 플래그 등 |

이 구조의 핵심은 “**프레임 경계(boundary)**”를 어떻게 표시하느냐이다.

---

#### 3) 프레임 경계 표시 방법

대표적인 방법 3가지를 요약해 보면:

1. **문자 카운트(Character/Length Count) 방식**
2. **플래그(Flag) + 바이트 스터핑(Byte Stuffing)**
3. **플래그 + 비트 스터핑(Bit Stuffing)**

여기서는 개념적인 이해를 위해 간단히 구조만 정리한다.

##### (1) Length 필드 방식

- 헤더에 **“이 프레임의 길이(바이트 수)”**를 명시하는 방식.
- 이더넷의 `Length/Type` 필드처럼 “길이 또는 상위 프로토콜 타입”을 넣는 경우도 있다.
- 수신 측은
  1. 헤더를 먼저 읽고,
  2. `Length` 만큼 비트를 더 읽어 하나의 프레임을 완성한다.

장점:

- 프레임 내부에 어떤 비트 패턴이 오든 **경계 인식에는 문제가 없다.**

단점:

- **Length 필드가 손상되면 전체 프레임 경계 인식이 무너질 수 있다.**
  (이 문제를 줄이기 위해 헤더 보호를 강화하거나, 상위에서 재동기화 메커니즘을 둔다.)

---

##### (2) 플래그 + 바이트 스터핑

일부 프로토콜(문자 지향, 예전 PPP 변형 등)은 **특정 바이트 패턴을 프레임 시작/끝의 ‘플래그(flag)’로 사용**한다.

예를 들어, 1바이트 플래그 `0x7E` 를 사용한다고 하자.

- 송신 측은 프레임 앞뒤에 `0x7E`를 붙인다.
- 수신 측은 비트 스트림을 보다가 `0x7E`가 나타나면 “프레임의 경계”로 인식한다.

문제:

- 프레임 내부의 데이터에도 우연히 `0x7E`가 나타날 수 있다.
- 이 값을 “가짜 플래그”로 오인하면, 프레임이 잘못 잘린다.

해결책:

- 프레임 내부에서 실제 데이터가 `0x7E`일 경우, 앞에 **ESC(escape) 바이트**를 붙이는 식으로 **바이트 스터핑(byte stuffing)** 을 한다.
- 수신 측은 ESC가 나오면 “**다음 바이트는 진짜 데이터, 플래그로 해석하지 말 것**”이라고 해석하여 원복한다.

즉, “**프레임 경계를 나타내는 특수 패턴**”을 데이터 안에서 **강제로 배제**하는 기법이다.

---

##### (3) 플래그 + 비트 스터핑

HDLC 계열 프로토콜은 대표적인 플래그/비트 스터핑 방식을 사용한다. 여기서 플래그는 보통

- `01111110` (0x7E)

라는 8비트 패턴이다.

송신 측 규칙(개념적 설명):

- 데이터 비트열을 순서대로 보내되,
- **1이 5개 연속으로 나타나면, 그 뒤에 0을 하나 강제로 삽입**한다.
  - 예: `0111110` → (중간에 11111 뒤에 0 삽입)
- 프레임 앞뒤에는 플래그 `01111110` 를 붙인다.

이렇게 하면, 데이터 내부에서 **“01111110”이라는 정확한 플래그 패턴이 자연스럽게 만들어지는 일이 거의 없게 된다.**
수신 측은 비트열을 읽으면서,

- 플래그 패턴 `01111110` 을 만나면 프레임 경계로 인식,
- 데이터 부분에서는 1이 5개 연속 나온 다음에 오는 0은 **“스터핑된 0”으로 보고 제거**한다.

이 방식은 비트 수준에서 프레임을 다루기 때문에, **문자 집합에 독립적**이고 다양한 상위 프로토콜을 실을 수 있다.

---

### Flow and Error Control

Framing으로 “프레임의 경계”를 정의했다면, 이제 그 프레임들을 **얼마나 빨리, 어떻게 안정적으로** 보낼 것인지가 문제다.

#### 1) 흐름제어(Flow Control)의 필요성

흐름제어의 기본 문제는 다음과 같이 표현할 수 있다.

> 송신자는 “라인 속도(예: 1Gbps)” + “CPU 성능” 덕분에 매우 빠르게 프레임을 보낼 수 있지만,
> 수신자는 “버퍼 크기”, “처리 속도”가 제한되어 있어 **너무 빠른 속도의 프레임을 다 받지 못할 수 있다.**

이때 수신 측 버퍼가 꽉 차면

- **새로 도착한 프레임은 버려지거나 덮어쓰기** 될 수 있다.
- 결국 상위 계층 입장에서 **데이터 손실**로 이어진다.

따라서 DLC는

- 수신자가 **“이만큼까지는 받아도 된다”** 는 신호를 보내고,
- 송신자가 그 범위 내에서만 프레임을 전송하도록 **속도를 조절(Throttle)** 해야 한다.

이 장에서 다루는 **stop-and-wait** 프로토콜은 가장 단순한 흐름제어 기법이다.
(슬라이딩 윈도우는 더 발전된 형태로, 다른 절에서 별도로 다루는 경우가 많다.)

---

#### 2) 오류제어(Error Control)의 필요성

물리 계층은

- 잡음(noise),
- 감쇠(attenuation),
- 간섭(interference),
- 충돌(collision) (공유 매체일 경우)

등으로 인해 비트가 뒤집히거나(0→1, 1→0), 프레임 일부/전체가 사라질 수 있다.

에러 제어는 크게 두 가지 전략으로 나뉜다.

1. **Forward Error Correction (FEC)**
   - 프레임에 **추가적인冗長(redundant) 비트**를 넣어, 수신 측이 재전송 없이도 **오류를 스스로 정정**할 수 있게 하는 방식.
   - 실시간 음성/영상, 위성 링크 등 재전송이 비싸거나 불가능한 환경에서 많이 사용.
2. **Automatic Repeat reQuest (ARQ)**
   - 프레임에 **에러 검출 코드(CRC 등)** 만 넣고,
   - 오류가 감지되면 **수신 측이 재전송을 요청**하는 방식.
   - 대부분의 링크 계층 프로토콜(HDLC, PPP, 일부 무선 링크)은 다양한 ARQ 변종을 사용.

데이터링크 제어에서 우리가 주로 모형화하는 것은 **ARQ 기반 오류제어**이다.

---

#### 3) ARQ에서 필요한 요소들

ARQ 프로토콜을 설계하려면 최소한 다음 요소들이 필요하다.

1. **긍정 응답(ACK, Acknowledgment)**
   - “N번 프레임을 제대로 받았다”는 신호.
2. **부정 응답(NAK, Negative Ack) (선택적)**
   - “N번 프레임이 손상되었으니 다시 보내달라”는 신호.
3. **타임아웃(Timeout)**
   - 일정 시간 동안 ACK/NAK를 받지 못하면 **프레임이 손실/손상된 것으로 간주하고 재전송**.
4. **시퀀스 번호(Sequence Number)**
   - 프레임마다 번호를 붙여 **중복 프레임(재전송분)** 과 **새로운 프레임**을 구분.
5. **재전송 전략**
   - 어떤 경우에 어떤 프레임을 얼마나 자주, 언제까지 재전송할 것인지에 대한 정책.

이 요소들이 결합되어 stop-and-wait, sliding window 같은 구체적인 프로토콜이 된다.

---

#### 4) 간단 예: 프레임 손실과 재전송

상황:

- A가 B에게 프레임 1, 2, 3을 순서대로 보낸다고 하자.
- 프로토콜은 stop-and-wait 방식이다.
  - A는 한 번에 1개 프레임만 전송하고, ACK를 기다린 후 다음 프레임을 보낸다.

진행:

1. A → B: 프레임 1 전송
2. B → A: ACK(1) 전송
3. A → B: 프레임 2 전송
4. 프레임 2가 중간에서 손실
5. A는 일정 시간 동안 ACK(2)를 기다리다가 타임아웃 발생
6. A → B: 프레임 2 재전송
7. B는 프레임 2를 받고 ACK(2) 전송
8. A → B: 프레임 3 전송 …

이 모형 안에 흐름제어와 오류제어가 동시에 포함되어 있다.

- A는 **ACK를 기다림으로써 B의 처리 속도에 맞춰 전송**한다 → 흐름제어
- 손실된 프레임 2는 **타임아웃 + 재전송**으로 복구된다 → 오류제어

---

### Connectionless and Connection-Oriented 서비스

데이터링크 계층 자체가 상위 계층에 어떤 **서비스 추상화**를 제공하느냐에 따라,
크게 두 가지 스타일로 나뉜다.

1. **Connectionless 서비스**
   - 논리적 연결 설정 없이, **각 프레임을 독립적으로 전송**.
2. **Connection-oriented 서비스**
   - 통신 전에 **논리 링크(logical link)** 를 설정하고,
     그 위에서 **시퀀스, 흐름제어, 오류제어**를 통합적으로 제공.

---

#### 1) Connectionless DLC 서비스

대표적인 예:

- 이더넷(Ethernet)
- 대부분의 LAN에서 사용하는 MAC 계층

특징:

- **연결 설정/해제 절차가 없다.**
- 송신자는 프레임을 만들어 목적지 MAC 주소와 상위 프로토콜 타입(예: IPv4, IPv6)을 넣고 **바로 보낸다.**
- 네트워크는 최대한 전달을 시도하지만,
  - 프레임이 손실될 수 있고,
  - 중복 전달될 수 있고,
  - 순서가 바뀔 수도 있다.
- 이런 특성 때문에 상위의 IP 계층도 **“best effort, 비연결형”** 이고, 그 위의 TCP가 **연결 지향, 신뢰성**을 구현한다.

Connectionless DLC는

- **지연이 적고 구현이 단순**하며,
- 브로드캐스트/멀티캐스트 등 다양한 트래픽 패턴을 지원하기 쉽다.

하지만 **링크 자체에서 강력한 신뢰성 보장은 하지 않는다**는 것이 기본 전제다
(실제 무선 LAN에서는 링크 수준에서 재전송/ACK를 수행하지만, 여전히 “완전 신뢰적인 연결 서비스”까지는 제공하지 않는다고 보는 것이 일반적이다).

---

#### 2) Connection-Oriented DLC 서비스

대표적인 예:

- HDLC(High-level Data Link Control) 논리 링크
- X.25의 LAPB
- 일부 WAN 링크 프로토콜의 데이터링크 부분

특징:

- **통신 전에 논리 링크 설정(connection establishment)** 을 한다.
  - 예: “Set Asynchronous Balanced Mode (SABM)” 같은 제어 프레임 교환.
- 각 프레임에는 **시퀀스 번호**가 붙는다.
- **양 끝단이 역할(주/종, peer-to-peer)을 정하고**, 흐름/오류 제어를 위한 제어 프레임(ACK, NAK, 상태 프레임 등)을 교환하며 데이터 통신을 수행한다.
- 통신이 끝나면 **“disconnect”** 단계로 논리 링크를 정리한다.

이런 link-level connection-oriented 서비스는 상위 계층에 사실상 “**신뢰적인 점대점 바이트 스트림**”에 가까운 추상화를 제공할 수 있다.
그 위에 더 간단한 네트워크 계층 프로토콜(예: 단순 패킷 전달)이나 애플리케이션을 얹기도 한다.

---

#### 3) Connectionless vs Connection-Oriented 요약

| 기준 | Connectionless DLC | Connection-Oriented DLC |
|------|--------------------|-------------------------|
| 연결 설정 | 없음 | 있음 (설정/해제 절차) |
| 단위 | 독립적인 프레임 | 논리 링크 상의 순서화된 프레임 |
| 오류 처리 | 보통 단순 (검출 + 상위에 맡김) | 링크 차원에서 재전송·순서제어 수행 |
| 지연 | 짧음 (오버헤드 작음) | 설정/해제 오버헤드 존재 |
| 예 | 이더넷, 대부분의 LAN MAC | HDLC, LAPB, 일부 WAN DLC |

실제 인터넷은

- 하위(이더넷, Wi-Fi 등): **connectionless DLC + 일부 링크 수준 ARQ**
- 상위(TCP): **연결 지향, 신뢰적 바이트 스트림**

이라는 조합을 선택했다.

---

## Data Link Layer Protocols

이제 **데이터링크 계층 프로토콜의 동작을 이해하기 위한 추상 모델** 3가지를 살펴본다.

1. Simple Protocol (무한 버퍼, 오류 없는 채널 가정)
2. Stop-and-Wait Protocol (흐름제어 + 오류 없는 채널 / 또는 약간 noisy 채널)
3. Piggybacking (양방향 통신에서 ACK를 데이터와 함께 싣는 최적화)

이 프로토콜들은 “실제 표준 그대로”는 아니지만,
HDLC, PPP, 802.11, TCP 등 **실무 프로토콜의 설계 원리를 연습하기 위한 모델**로 많이 쓰인다.

---

### Simple Protocol

#### 1) 가정

Simple Protocol은 가장 이상적인 상황을 가정한 모델이다.

- 링크는 **완전히 오류가 없다.**
  - 비트 손상, 프레임 손실, 중복 없음.
- 수신자는 **무한 버퍼**를 가진다.
- 수신 측 처리 속도가 송신자보다 절대 느리지 않다.
- 데이터는 **한 방향(패킷 A→B)** 로만 흐른다고 가정한다.
- 각 프레임에는 시퀀스 번호, ACK, 기타 제어 정보가 없다.
- 송신자는 상위 계층이 내려주는 데이터가 있는 한, **멈추지 않고 계속 프레임을 보낸다.**

현실에는 거의 존재하지 않는 환경이지만,
이 모델을 통해 **“프레임만 만들고 계속 보내면 어떤 일이 벌어지는가”** 를 생각해 볼 수 있다.

---

#### 2) 동작 요약

- 상위 계층에서 IP 패킷(혹은 임의의 데이터)이 내려오면,
- 송신 DLC는
  1. 그 데이터를 프레임으로 감싸고(헤더·트레일러 추가),
  2. 물리 계층에게 바로 전송을 요청한다.
- 수신 DLC는
  1. 도착한 비트를 프레임 단위로 자르고,
  2. 에러 검사를 한다 (이 모델에서는 항상 통과).
  3. 프레임 페이로드를 상위 계층으로 바로 넘긴다.

동기/비동기 통신 문제도 없고, 흐름제어도 필요 없다.

---

#### 3) 예: Simple Protocol 동작 시나리오

상황:

- A가 B에게 파일을 전송한다.
- 파일은 4개의 데이터 블록으로 나뉘어 상위 계층에서 A의 DLC로 내려온다.
  - 데이터 블록: P1, P2, P3, P4

Simple Protocol에서 A의 DLC는:

1. P1을 받아 프레임 F1으로 만든 뒤, 곧바로 전송
2. P2 → 프레임 F2 → 즉시 전송
3. P3 → 프레임 F3 → 즉시 전송
4. P4 → 프레임 F4 → 즉시 전송

B의 DLC는:

- F1, F2, F3, F4를 차례로 받고,
- 에러가 없으므로 그대로 IP 계층 등 상위에 P1, P2, P3, P4를 넘긴다.

이 환경에서는 **ACK도, 시퀀스 번호도, 타임아웃도 필요 없다.**

---

#### 4) Simple Protocol의 한계

이 모델의 한계는 두 가지 방향에서 생각할 수 있다.

1. **현실의 링크는 오류가 있다.**
   - 비트가 뒤집히거나, 프레임이 손실될 수 있다.
   - Simple Protocol에는 재전송 메커니즘이 전혀 없다.
2. **수신 처리 능력은 항상 유한하다.**
   - Simple Protocol은 흐름제어가 없기 때문에,
     실제 환경에서 수신 버퍼가 쉽게 overflow 될 수 있다.

따라서 Simple Protocol은 **“이상적인 경우의 기본 모델”** 로 이해해야 한다.
이 모델에 하나씩 기능(ACK, 타임아웃, 시퀀스 번호)을 추가해 나가면,
실제 쓰이는 프로토콜 구조와 점점 가까워진다.

---

### Stop-and-Wait Protocol

Stop-and-Wait는 DLC 수준의 **가장 기본적인 흐름제어·오류제어 프로토콜**이다.

#### 1) 기본 아이디어

이름 그대로:

> “한 번에 프레임 하나를 보내고,
>  그 프레임에 대한 ACK를 받을 때까지 **기다렸다가(stop)**
>  다음 프레임을 다시 보내는(wait) 방식”

이다.

가정:

- 우선 **오류 없는 채널** 버전부터 생각해 보자.
- 이후에 채널에 오류가 있는 경우(노이즈, 손실)를 추가한다.

---

#### 2) 오류 없는 채널에서의 Stop-and-Wait

오류가 없다고 가정하면,
Stop-and-Wait 프로토콜의 흐름은 다음과 같이 단순하다.

1. 송신자 A가 상위 계층에서 데이터 블록 P1을 받는다.
2. A는 프레임 F1을 만들어 전송.
3. 수신자 B는 F1을 받고, 데이터를 상위 계층으로 전달한 후 **ACK(1)** 을 A에게 보낸다.
4. A는 ACK(1)을 받으면 다음 데이터 P2를 프레임 F2로 만들어 전송.
5. B는 F2를 받고 ACK(2)를 보낸다.
6. 이 과정을 반복.

이 구조만으로도 Flow Control이 어느 정도 구현된다.

- B의 처리 속도가 느리면, ACK를 보내는 속도도 느려진다.
- A는 ACK가 올 때까지 다음 프레임을 보내지 않으므로,
  **자동으로 B의 처리 속도에 맞춰진다.**

---

#### 3) 오류 있는 채널에서의 Stop-and-Wait

이제 현실을 조금 더 반영해,
**프레임이나 ACK가 손실/손상될 수 있다**고 가정해 보자.

텍스트만으로 기본 규칙을 정리하면:

- 각 데이터 프레임에는 **시퀀스 번호**를 붙인다.
  - 단순 stop-and-wait에서는 **0, 1 두 개만 번갈아 쓰는(binary sequence number)** 로도 충분하다.
- 수신자는 프레임을 올바르게 받으면, 해당 번호를 담은 ACK를 보낸다.
- 송신자는
  - 프레임을 보낸 뒤, **타이머를 시작**한다.
  - 타이머 안에 올바른 ACK를 받지 못하면, 해당 프레임을 **다시 전송**한다.
- 수신자는 **중복 프레임**을 구분하기 위해,
  마지막으로 제대로 받은 시퀀스 번호를 기억한다.
  - 같은 번호의 프레임이 또 오면,
    “이건 재전송된 중복 프레임”이라고 판단하고 상위 계층에는 다시 전달하지 않는다.
  - 대신 ACK만 다시 보내어 송신자의 타이머를 멈추게 한다.

---

#### 4) 상세 예: 프레임 손실

상황:

- A가 B에게 두 개의 프레임 F0, F1을 보낸다고 한다.
- 시퀀스 번호는 0, 1로 번갈아 쓴다.
- F0는 잘 가지만, F1은 손실된다고 가정한다.

진행:

1. A는 F0(시퀀스 번호 0)을 전송하고 타이머를 시작.
2. B는 F0를 올바르게 받고, 상위 계층에 전달하고, ACK0를 전송.
3. A는 ACK0를 받고, 타이머를 멈추고, 다음 프레임 F1(시퀀스 번호 1)을 전송.
4. F1이 채널에서 손실된다.
5. A는 타이머가 만료될 때까지 ACK1을 기다리지만, 오지 않는다.
6. 타임아웃 발생 → A는 F1을 **다시 전송**.
7. 이번에는 F1이 B에 도달한다.
8. B는 마지막으로 받은 프레임 번호가 0이었고, 새로 온 프레임이 1이므로, “새로운 프레임”으로 판단.
   - F1 내용을 상위 계층으로 전달하고,
   - ACK1을 보낸다.
9. A는 ACK1을 받고 다음 프레임으로 진행.

이 과정에서 **데이터 손실 없이** F1이 결국 B에 도달한다.

---

#### 5) 상세 예: ACK 손실

이제 반대로 **프레임은 잘 도착하지만 ACK가 손실되는 경우**를 생각해 보자.

상황:

- F0는 B에 잘 도착한다.
- B가 보낸 ACK0가 채널에서 손실된다.

진행:

1. A → B: F0(번호 0) 전송, 타이머 시작.
2. B는 F0를 제대로 수신, 상위 계층에 전달, ACK0 전송.
3. ACK0가 중간에서 손실된다.
4. A는 타이머가 만료될 때까지 ACK0를 기다리지만 못 받는다.
5. 타임아웃 발생 → A는 “F0이 손실/손상되었다”고 판단하고 F0를 **재전송**.
6. B는 이미 F0를 수신한 상태이고, 마지막 수신 번호는 0이다.
7. 다시 F0(번호 0)가 도착하자,
   - 시퀀스 번호를 보고 “이건 **중복 프레임**”이라고 판단.
   - 상위 계층에는 **다시 전달하지 않고**,
   - ACK0만 다시 보내 준다.
8. 이번에는 ACK0가 A에게 도달하고, A는 다음 프레임 F1로 넘어간다.

핵심:

- **시퀀스 번호** 덕분에,
  - 수신자는 “F0의 재전송분”을 새 데이터로 오해하지 않는다.
- 프로토콜은 **“일부 프레임이나 ACK가 손실되더라도, 데이터 중복 없이 한 번씩만 상위에 전달”**되도록 보장한다.

---

#### 6) Stop-and-Wait의 효율(채널 이용률)

Stop-and-Wait는 구조가 단순한 대신, **딱 한 개의 프레임만 채널 위에 떠 있게** 만든다.
이것은 RTT가 긴 링크에서 **심각한 비효율**을 야기한다.

전송 시간과 지연을 간단히 정의하면:

- 한 프레임의 전송 시간(송신기에서 채널로 밀어 넣는 시간):
  $$T_{\text{frame}}$$
- 한 방향 전파 지연(Propagation delay):
  $$T_{\text{prop}}$$
- ACK의 전송 시간은 프레임보다 매우 짧다고 가정하고 무시한다.

그러면 Stop-and-Wait에서 **한 프레임 당 걸리는 왕복 시간**은 대략

$$
T_{\text{cycle}} \approx T_{\text{frame}} + 2T_{\text{prop}}
$$

이다.

실제 데이터를 보내는 시간은 $$T_{\text{frame}}$$ 뿐이고,
나머지 $$2T_{\text{prop}}$$ 동안은 **채널이 놀고 있는 시간**이다.

따라서 채널 이용률(효율) $$U$$ 를

$$
U = \frac{T_{\text{frame}}}{T_{\text{frame}} + 2T_{\text{prop}}}
$$

로 정의할 수 있다.

- $$T_{\text{frame}} \gg T_{\text{prop}}$$ 인 **근거리·저속 링크**에서는 $$U \approx 1$$ 에 가까워 효율이 좋다.
- 반대로 **고속·지연이 긴 링크(예: 위성 링크)** 에서는
  - $$T_{\text{frame}}$$ 는 거의 0에 가깝고,
  - $$T_{\text{prop}}$$ 가 매우 크기 때문에,
  - $$U$$ 가 매우 작아진다 → 대부분의 시간을 ACK 기다리느라 소비.

이 문제를 해결하기 위해 나온 것이 **슬라이딩 윈도우(Sliding Window) 프로토콜**이며,
여기서는 개념만 짚고 넘어간다.

---

### Piggybacking

Stop-and-Wait를 비롯한 기본 ARQ는,
대부분 “한 방향 데이터 흐름”을 염두에 두고 있다.
하지만 실제 통신(예: TCP 연결)은 **양방향(full-duplex)** 이다.

예:

- 클라이언트는 서버에 요청과 함께 데이터(HTTP POST 등)를 보내고,
- 서버는 응답을 보내면서 그 안에 또 다른 요청에 대한 응답을 포함할 수도 있다.

이 상황에서 “ACK를 별도의 프레임으로 계속 보내는 것”은 비효율적이다.
그래서 등장하는 개념이 **piggybacking(피기백)** 이다.

---

#### 1) 기본 아이디어

Piggybacking은 다음 아이디어를 따른다.

> “어차피 양쪽 모두 **데이터 프레임을 전송** 하고 있으니,
>  **상대방 데이터를 잘 받았다는 ACK 정보를 데이터 프레임의 헤더에 같이 실어 보내자.**
>  별도의 ACK 프레임을 보내느라 대역폭을 낭비하지 말자.”

즉,

- 한 링크에서 양방향으로 데이터를 주고받는 상황에서,
- 각 방향의 데이터 프레임에 **“내가 마지막으로 제대로 받은 프레임 번호”** 를 같이 실어 보내면,
- 그 값이 곧 상대방 입장에서는 “나에 대한 ACK”가 된다.

---

#### 2) Piggybacking 프레임 헤더의 구조 (추상)

양방향, sliding window 스타일 프로토콜에서 프레임 헤더에는 보통 다음 같은 필드가 들어간다.

- `Seq` (Sequence number):
  - **내가 지금 보내는 데이터의 번호**
  - 예: `Seq = 5` → “이 프레임은 내가 보내는 다섯 번째 데이터 블록이다.”
- `Ack` (Acknowledgment number):
  - **상대로부터 받은 데이터 중, 내가 마지막으로 제대로 받은 번호**
  - 예: `Ack = 12` → “너(상대)가 보낸 0~12번 데이터는 잘 받았다.”

이 두 필드를 한 프레임에 **동시에** 싣는 것이 piggybacking의 핵심이다.

---

#### 3) Piggybacking이 없는 경우 (비교)

먼저, piggybacking이 전혀 없는 구조를 상상해 보자.

- A ↔ B는 모두 데이터를 주고받는다.
- A는 B에게 데이터 프레임만 전송하고,
- B는 A에게 데이터 프레임 + 별도의 ACK 프레임을 전송한다.

이 경우:

- B가 데이터 프레임을 보낼 때마다 A는 **데이터 프레임 하나**를 받고,
- 그 외에도 B가 보낸 **순수 ACK 프레임**들도 추가로 네트워크를 점유한다.

이때 대역폭 사용량을 단순히 세어 보면:

- A→B 방향 데이터 프레임 수: N
- B→A 방향 데이터 프레임 수: M
- B→A 방향 ACK 프레임 수: 대략 N (혹은 그 이상)

즉, B→A 방향의 **프레임 수가 많아지고, 불필요한 오버헤드**가 늘어난다.

---

#### 4) Piggybacking을 사용하는 경우

Piggybacking 구조에서는 다음처럼 동작한다.

- B는 어차피 A에게 데이터 프레임을 보내야 할 때,
  그 프레임 헤더의 `Ack` 필드에 **“A가 보낸 데이터에 대한 ACK”** 를 기록한다.
- 별도의 ACK 전용 프레임은,
  - “B가 당장 보낼 데이터가 없는데 ACK를 꼭 보내야 할 때”만 사용하거나,
  - 아예 사용하지 않고 일정 시간 안에 보낼 데이터가 나오기를 잠시 기다리는 전략도 있다.

예를 들어,

1. A가 B에게 데이터 프레임 1, 2를 보냈다.
2. B는 이 두 프레임을 잘 받았다.
3. B도 A에게 데이터를 보내고 싶다.
   첫 데이터 프레임을 보낼 때 헤더에 `Ack = 2`를 넣는다.
   이 프레임은
   - “내가 보낸 데이터(Seq = X)”와
   - “너(A)의 데이터 0~2는 잘 받았다(Ack = 2)”라는 의미를 한번에 갖는다.
4. A는 B로부터 온 데이터 프레임을 받으면서, `Ack = 2`를 읽고
   “내 프레임 2까지는 제대로 전달되었구나”라고 이해한다.

이렇게 하면:

- **순수 ACK 전용 프레임의 수가 크게 줄어들고,**
- 전체 데이터 전송 효율이 올라간다.

---

#### 5) Piggybacking의 설계 고려사항

Piggybacking은 효율을 높여주지만, 몇 가지 설계 상 고려사항이 있다.

1. **ACK 지연 문제**
   - 만약 B가 당장 보낼 데이터가 없다면,
     “데이터가 생길 때까지” ACK를 계속 지연시키면 어떻게 될까?
   - 송신자 A는 ACK를 기다리는 동안 **타임아웃이 발생**할 수 있다.
   - 그러면 **불필요한 재전송**이 일어나고, 오히려 효율이 떨어진다.
   - 해결책:
     - **“ACK 지연 한도(délayed ACK timer)”** 를 둔다.
       - 예: 일정 시간 동안 B가 보낼 데이터가 생기면 그때 piggyback해서 ACK를 같이 보내고,
       - 그 시간이 지나도록 데이터가 없으면 **순수 ACK 프레임을 따로 보낸다.**

2. **프레임 손실 시 재전송 처리**
   - A→B 데이터 프레임이 손실되면, B는 그 프레임의 번호에 대한 ACK를 보낼 수 없다.
   - B는 자신이 받은 마지막 번호까지만 Ack에 넣을 수 있다.
   - A는 일정 시간 동안 Ack가 증가하지 않으면 해당 프레임을 재전송하게 된다.
   - 이 과정에서 B가 보내는 데이터 프레임의 `Ack` 값은
     재전송 상황을 A에게 알려주는 주요 수단이 된다.

3. **대칭/비대칭 트래픽**
   - A→B 방향 데이터가 많고, B→A 방향 데이터가 거의 없을 수도 있다.
   - 이 경우 B는 piggybacking할 기회가 적기 때문에,
     결국 **순수 ACK 전용 프레임을 자주 보내야 한다.**
   - Piggybacking은 “양방향으로 데이터가 어느 정도 균형 있게 흐르는 상황일 때”
     가장 큰 효율 향상을 제공한다.

---

#### 6) 예: 양방향 파일 전송에서의 Piggybacking

상황:

- A와 B는 서로 큰 파일 하나씩을 교환하고 있다.
- 둘 다 stop-and-wait가 아니라, sliding window + piggybacking을 사용하는 프로토콜을 쓴다고 하자.
- A는 B에게 프레임 0,1,2,…를, B는 A에게 프레임 0,1,2,…를 각각 보낸다.

진행 개념:

1. A → B: `Seq=0, Ack=−` (B에게 아직 받은 데이터가 없으니 Ack 없음)
2. B → A: `Seq=0, Ack=0` (A의 0번 프레임 잘 받았다는 의미)
3. A → B: `Seq=1, Ack=0` (B의 0번 프레임만 받은 상태)
4. B → A: `Seq=1, Ack=1` (A의 1번까지 잘 받았다는 의미)
5. A → B: `Seq=2, Ack=1`
6. …

이 과정에서 **별도의 ACK 프레임 없이도**,
서로의 데이터에 대한 ACK 정보가 계속 상호 교환된다.

만약 어느 시점에 B가 더 이상 보낼 데이터가 없는데도,
A는 계속해서 B에게 데이터를 보내고 있다면,

- B는 더 이상 piggyback할 데이터가 없으므로,
- 일정 시간마다 순수 ACK 프레임만 따로 보내게 된다.

---

## 정리

이 장에서 다룬 내용들을 한 번 정리해 보자.

1. **DLC Services**
   - **Framing**: 비트 스트림을 프레임 단위로 자르고 헤더/트레일러를 붙이는 기능.
     플래그/바이트 스터핑, 비트 스터핑, Length 필드 등의 방법으로 프레임 경계를 표시한다.
   - **Flow & Error Control**:
     흐름제어(수신 버퍼 보호)와 오류제어(검출·정정, 재전송)를 결합해,
     상위 계층에 더 안정적인 전달 서비스를 제공한다.
   - **Connectionless vs Connection-Oriented**:
     이더넷처럼 단순 프레임 전달만 하는 서비스부터,
     HDLC처럼 논리 링크를 설정·해제하고 신뢰성을 보장하는 DLC까지 스펙트럼이 있다.

2. **Data Link Layer Protocols (모형)**
   - **Simple Protocol**:
     오류 없는 채널, 무한 버퍼, 흐름제어 없음.
     “프레임을 만들어 그냥 계속 보내면 어떤 구조가 되는가”를 보여주는 기본 모델.
   - **Stop-and-Wait Protocol**:
     한 번에 한 프레임만 보내고 ACK를 기다리는 프로토콜.
     흐름제어 + 기본 ARQ 기능을 구현한다.
     시퀀스 번호, 타임아웃, 중복 프레임 처리 등 ARQ의 기본 개념을 담고 있다.
   - **Piggybacking**:
     양방향 통신에서 ACK를 데이터 프레임의 헤더에 같이 싣는 최적화.
     별도 ACK 프레임 수를 줄여 대역폭 효율을 높인다.
     대신 ACK 지연, 데이터 유무, 재전송 전략을 설계할 때 추가 고려가 필요하다.

이 모형들을 이해하면, 실제 이더넷/HDLC/PPP/802.11/TCP 등의 설계를 볼 때

- “여기서의 시퀀스 번호는 어떤 역할을 하나?”
- “이 프로토콜은 흐름제어를 링크에서 하는가, 상위 계층에서 하는가?”
- “ACK는 별도 프레임인가, piggybacking하는가?”
- “프레임 경계는 어떤 방식으로 표시하는가?”

같은 질문을 던지면서 각 레이어의 책임 분담과 구현 방식을 명확히 볼 수 있게 된다.
