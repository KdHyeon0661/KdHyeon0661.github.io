---
layout: post
title: 파이썬 - 클래스 (1)
date: 2024-08-11 19:20:23 +0900
category: Python
---
# 파이썬 클래스 기초 - 객체지향 프로그래밍의 시작

객체지향 프로그래밍(OOP)은 현대 프로그래밍의 핵심 패러다임 중 하나로, 파이썬에서도 클래스를 통해 객체지향 개념을 완벽하게 지원합니다. 클래스는 데이터와 그 데이터를 처리하는 함수를 하나로 묶어 복잡한 문제를 모델링하는 강력한 도구입니다. 이 글에서는 파이썬 클래스의 기본 개념부터 실제 활용까지 단계별로 알아보겠습니다.

## 클래스의 기본 개념과 정의

### 클래스와 인스턴스 이해하기

클래스는 객체의 설계도나 틀로 생각할 수 있습니다. 이 설계도를 바탕으로 생성된 실제 객체를 인스턴스라고 합니다.

```python
# 기본 클래스 정의
class Dog:
    """개를 나타내는 클래스"""
    
    def __init__(self, name, age):
        """생성자 메서드: 인스턴스 초기화"""
        self.name = name  # 인스턴스 속성 설정
        self.age = age    # self는 현재 인스턴스를 가리킴
    
    def bark(self):
        """짖는 동작"""
        return f"{self.name}가 멍멍 짖습니다!"
    
    def get_human_age(self):
        """사람 나이로 변환"""
        return self.age * 7

# 클래스를 사용하여 인스턴스 생성
my_dog = Dog("초코", 3)
your_dog = Dog("바둑이", 5)

print(my_dog.name)           # 초코
print(my_dog.bark())         # 초코가 멍멍 짖습니다!
print(my_dog.get_human_age()) # 21

print(your_dog.name)         # 바둑이
print(your_dog.get_human_age()) # 35
```

### `self`의 의미와 역할

`self`는 클래스 메서드의 첫 번째 매개변수로, 현재 인스턴스를 가리킵니다. 파이썬에서 `self`는 관례적인 이름일 뿐이지만, 모든 인스턴스 메서드는 첫 번째 매개변수로 인스턴스를 받도록 설계되어 있습니다.

```python
class Counter:
    """간단한 카운터 클래스"""
    
    def __init__(self):
        self.count = 0
    
    def increment(self):
        """카운터 증가"""
        self.count += 1
    
    def get_count(self):
        """현재 카운터 값 반환"""
        return self.count

# 인스턴스 생성 및 사용
counter1 = Counter()
counter2 = Counter()

counter1.increment()
counter1.increment()
counter2.increment()

print(f"counter1: {counter1.get_count()}")  # 2
print(f"counter2: {counter2.get_count()}")  # 1

# self의 실제 동작 이해
print("메서드 호출 방식 비교:")
print(f"일반 호출: {counter1.get_count()}")  # 2
print(f"클래스 호출: {Counter.get_count(counter1)}")  # 2 (동일한 결과)
```

## 클래스 속성과 인스턴스 속성

클래스 속성은 모든 인스턴스가 공유하는 데이터이고, 인스턴스 속성은 각 인스턴스마다 고유한 데이터입니다.

```python
class BankAccount:
    """은행 계좌 클래스"""
    
    # 클래스 속성 (모든 인스턴스가 공유)
    interest_rate = 0.02  # 기본 이자율 2%
    bank_name = "파이썬 은행"
    
    def __init__(self, account_holder, initial_balance=0):
        """계좌 초기화"""
        # 인스턴스 속성 (각 계좌마다 고유)
        self.account_holder = account_holder
        self.balance = initial_balance
        self.account_number = self._generate_account_number()
    
    def _generate_account_number(self):
        """계좌번호 생성 (내부 메서드)"""
        import random
        return f"{self.bank_name[:2]}{random.randint(10000, 99999)}"
    
    def deposit(self, amount):
        """입금"""
        if amount > 0:
            self.balance += amount
            print(f"{amount}원 입금되었습니다. 현재 잔액: {self.balance:,}원")
        else:
            print("유효한 금액을 입력해주세요.")
    
    def withdraw(self, amount):
        """출금"""
        if 0 < amount <= self.balance:
            self.balance -= amount
            print(f"{amount}원 출금되었습니다. 현재 잔액: {self.balance:,}원")
        else:
            print("잔액이 부족하거나 유효하지 않은 금액입니다.")
    
    def apply_interest(self):
        """이자 적용"""
        interest = self.balance * self.interest_rate
        self.balance += interest
        print(f"이자 {interest:,.0f}원이 적용되었습니다. 현재 잔액: {self.balance:,}원")
    
    @classmethod
    def change_interest_rate(cls, new_rate):
        """이자율 변경 (클래스 메서드)"""
        cls.interest_rate = new_rate
        print(f"이자율이 {new_rate*100:.1f}%로 변경되었습니다.")

# 사용 예제
account1 = BankAccount("김철수", 1000000)
account2 = BankAccount("이영희", 500000)

print(f"은행 이름: {BankAccount.bank_name}")
print(f"기본 이자율: {BankAccount.interest_rate*100:.1f}%")

account1.deposit(500000)    # 500,000원 입금
account2.withdraw(100000)   # 100,000원 출금

# 이자율 변경 (모든 계좌에 적용)
BankAccount.change_interest_rate(0.025)  # 2.5%로 변경

account1.apply_interest()
account2.apply_interest()

# 인스턴스 정보 출력
print(f"\n{account1.account_holder}님의 계좌:")
print(f"  계좌번호: {account1.account_number}")
print(f"  잔액: {account1.balance:,}원")

print(f"\n{account2.account_holder}님의 계좌:")
print(f"  계좌번호: {account2.account_number}")
print(f"  잔액: {account2.balance:,}원")
```

## 다양한 메서드 유형

### 인스턴스 메서드, 클래스 메서드, 정적 메서드

```python
class MathOperations:
    """수학 연산을 제공하는 클래스"""
    
    PI = 3.141592653589793  # 클래스 상수
    
    def __init__(self, value=0):
        """초기화"""
        self.value = value
    
    # 인스턴스 메서드
    def square(self):
        """값의 제곱을 계산"""
        return self.value ** 2
    
    def multiply_by(self, factor):
        """값에 배수를 곱함"""
        return self.value * factor
    
    # 클래스 메서드
    @classmethod
    def circle_area(cls, radius):
        """원의 넓이 계산"""
        return cls.PI * (radius ** 2)
    
    @classmethod
    def create_from_string(cls, string_value):
        """문자열로부터 인스턴스 생성"""
        try:
            value = float(string_value)
            return cls(value)
        except ValueError:
            return cls(0)
    
    # 정적 메서드
    @staticmethod
    def is_even(number):
        """짝수 여부 확인"""
        return number % 2 == 0
    
    @staticmethod
    def factorial(n):
        """팩토리얼 계산"""
        if n < 0:
            raise ValueError("음수는 팩토리얼을 계산할 수 없습니다.")
        result = 1
        for i in range(2, n + 1):
            result *= i
        return result

# 다양한 메서드 사용
math_obj = MathOperations(5)

# 인스턴스 메서드 사용
print(f"제곱: {math_obj.square()}")              # 25
print(f"3배: {math_obj.multiply_by(3)}")         # 15

# 클래스 메서드 사용 (인스턴스 없이도 호출 가능)
print(f"반지름 3인 원의 넓이: {MathOperations.circle_area(3):.2f}")  # 28.27

# 클래스 메서드를 이용한 대체 생성자
new_obj = MathOperations.create_from_string("10.5")
print(f"문자열로 생성된 객체 값: {new_obj.value}")  # 10.5

# 정적 메서드 사용
print(f"7은 짝수인가? {MathOperations.is_even(7)}")  # False
print(f"5! = {MathOperations.factorial(5)}")         # 120
```

### `@property` 데코레이터를 이용한 계산 속성

```python
class Rectangle:
    """사각형 클래스"""
    
    def __init__(self, width, height):
        """초기화"""
        self._width = width
        self._height = height
    
    @property
    def width(self):
        """가로 길이 (읽기 전용)"""
        return self._width
    
    @width.setter
    def width(self, value):
        """가로 길이 설정 (검증 포함)"""
        if value <= 0:
            raise ValueError("가로 길이는 0보다 커야 합니다.")
        self._width = value
    
    @property
    def height(self):
        """세로 길이 (읽기 전용)"""
        return self._height
    
    @height.setter
    def height(self, value):
        """세로 길이 설정 (검증 포함)"""
        if value <= 0:
            raise ValueError("세로 길이는 0보다 커야 합니다.")
        self._height = value
    
    @property
    def area(self):
        """면적 (계산 속성)"""
        return self._width * self._height
    
    @property
    def perimeter(self):
        """둘레 (계산 속성)"""
        return 2 * (self._width + self._height)
    
    @property
    def is_square(self):
        """정사각형 여부 (계산 속성)"""
        return self._width == self._height

# 사용 예제
rect = Rectangle(10, 5)

print(f"가로: {rect.width}")        # 10
print(f"세로: {rect.height}")       # 5
print(f"면적: {rect.area}")         # 50
print(f"둘레: {rect.perimeter}")    # 30
print(f"정사각형인가? {rect.is_square}")  # False

# 세터 사용
rect.width = 15
print(f"변경된 가로: {rect.width}")  # 15
print(f"변경된 면적: {rect.area}")   # 75

# 잘못된 값 설정 시 (검증 동작)
try:
    rect.height = -5
except ValueError as e:
    print(f"오류 발생: {e}")  # 세로 길이는 0보다 커야 합니다.

# 정사각형 만들기
rect.height = 15
print(f"정사각형인가? {rect.is_square}")  # True
```

## 상속과 다형성

### 기본 상속 구조

```python
# 기본 클래스 (부모 클래스)
class Animal:
    """동물 기본 클래스"""
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def make_sound(self):
        """소리내기 (기본 구현)"""
        return "동물이 소리를 냅니다."
    
    def eat(self):
        """먹기"""
        return f"{self.name}이(가) 먹습니다."
    
    def sleep(self):
        """자기"""
        return f"{self.name}이(가) 잠을 잡니다."
    
    def __str__(self):
        """문자열 표현"""
        return f"{self.name} ({self.age}세)"

# 자식 클래스 1
class Dog(Animal):
    """개 클래스"""
    
    def __init__(self, name, age, breed):
        # 부모 클래스의 __init__ 호출
        super().__init__(name, age)
        self.breed = breed
    
    def make_sound(self):
        """메서드 오버라이딩 (다형성)"""
        return "멍멍!"
    
    def wag_tail(self):
        """개만의 특별한 행동"""
        return f"{self.name}이(가) 꼬리를 흔듭니다."
    
    def __str__(self):
        """부모 클래스의 __str__ 확장"""
        parent_str = super().__str__()
        return f"{parent_str} - {self.breed} 종"

# 자식 클래스 2
class Cat(Animal):
    """고양이 클래스"""
    
    def __init__(self, name, age, color):
        super().__init__(name, age)
        self.color = color
    
    def make_sound(self):
        """메서드 오버라이딩"""
        return "야옹!"
    
    def climb_tree(self):
        """고양이만의 특별한 행동"""
        return f"{self.name}이(가) 나무를 탑니다."
    
    def __str__(self):
        parent_str = super().__str__()
        return f"{parent_str} - {self.color}색"

# 상속 사용 예제
animals = [
    Animal("일반 동물", 5),
    Dog("초코", 3, "진돗개"),
    Cat("나비", 2, "삼색"),
    Dog("멍뭉이", 4, "말티즈"),
    Cat("치즈", 1, "노란색")
]

print("동물원에 오신 것을 환영합니다!")
print("=" * 50)

for animal in animals:
    print(f"{animal}")
    print(f"  소리: {animal.make_sound()}")
    print(f"  식사: {animal.eat()}")
    
    # 특정 클래스의 고유 메서드 호출
    if isinstance(animal, Dog):
        print(f"  특별 행동: {animal.wag_tail()}")
    elif isinstance(animal, Cat):
        print(f"  특별 행동: {animal.climb_tree()}")
    
    print("-" * 30)
```

### 다중 상속과 MRO (Method Resolution Order)

```python
class Printable:
    """출력 가능한 객체 믹스인"""
    
    def print_info(self):
        """객체 정보 출력"""
        print(f"객체 정보: {self}")
    
    def __str__(self):
        return "Printable 객체"

class Serializable:
    """직렬화 가능한 객체 믹스인"""
    
    def to_dict(self):
        """딕셔너리로 변환"""
        return {"type": self.__class__.__name__}
    
    def __str__(self):
        return "Serializable 객체"

class DataObject(Printable, Serializable):
    """두 믹스인을 상속받는 클래스"""
    
    def __init__(self, data):
        self.data = data
    
    def __str__(self):
        # 부모 클래스의 __str__을 호출하지 않고 직접 구현
        return f"DataObject(data={self.data})"
    
    def to_dict(self):
        """부모 클래스의 메서드 확장"""
        base_dict = super().to_dict()
        base_dict["data"] = self.data
        return base_dict

# MRO 확인
print("DataObject의 MRO:")
for cls in DataObject.__mro__:
    print(f"  {cls}")

# 사용 예제
obj = DataObject("중요한 데이터")

print("\n객체 사용:")
print(f"문자열 표현: {obj}")
print(f"딕셔너리 변환: {obj.to_dict()}")
obj.print_info()

# isinstance와 issubclass 사용
print(f"\nisinstance 체크:")
print(f"  DataObject의 인스턴스인가? {isinstance(obj, DataObject)}")  # True
print(f"  Printable의 인스턴스인가? {isinstance(obj, Printable)}")    # True
print(f"  Serializable의 인스턴스인가? {isinstance(obj, Serializable)}") # True
print(f"  Animal의 인스턴스인가? {isinstance(obj, Animal)}")          # False

print(f"\nissubclass 체크:")
print(f"  DataObject는 Printable의 서브클래스인가? {issubclass(DataObject, Printable)}")  # True
print(f"  DataObject는 Serializable의 서브클래스인가? {issubclass(DataObject, Serializable)}") # True
```

## 특별 메서드 (Magic Methods / Dunder Methods)

### 기본적인 특별 메서드들

```python
class Vector2D:
    """2차원 벡터 클래스"""
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    # 표현 관련 메서드
    def __repr__(self):
        """개발자용 문자열 표현 (eval로 복원 가능)"""
        return f"Vector2D({self.x}, {self.y})"
    
    def __str__(self):
        """사용자용 문자열 표현"""
        return f"({self.x}, {self.y})"
    
    # 산술 연산 메서드
    def __add__(self, other):
        """벡터 덧셈"""
        if isinstance(other, Vector2D):
            return Vector2D(self.x + other.x, self.y + other.y)
        return NotImplemented
    
    def __sub__(self, other):
        """벡터 뺄셈"""
        if isinstance(other, Vector2D):
            return Vector2D(self.x - other.x, self.y - other.y)
        return NotImplemented
    
    def __mul__(self, scalar):
        """스칼라 곱셈"""
        if isinstance(scalar, (int, float)):
            return Vector2D(self.x * scalar, self.y * scalar)
        return NotImplemented
    
    def __rmul__(self, scalar):
        """오른쪽 곱셈 (스칼라 * 벡터)"""
        return self.__mul__(scalar)
    
    # 비교 연산 메서드
    def __eq__(self, other):
        """동등성 비교"""
        if isinstance(other, Vector2D):
            return self.x == other.x and self.y == other.y
        return False
    
    def __ne__(self, other):
        """부등 비교"""
        return not self.__eq__(other)
    
    # 길이 관련 메서드
    def __abs__(self):
        """벡터의 크기"""
        return (self.x ** 2 + self.y ** 2) ** 0.5
    
    def __bool__(self):
        """진리값 평가 (영벡터인지 확인)"""
        return self.x != 0 or self.y != 0
    
    # 컨테이너 흉내 메서드
    def __len__(self):
        """차원 수 (항상 2)"""
        return 2
    
    def __getitem__(self, index):
        """인덱스 접근"""
        if index == 0:
            return self.x
        elif index == 1:
            return self.y
        elif index == 'x' or index == 'X':
            return self.x
        elif index == 'y' or index == 'Y':
            return self.y
        raise IndexError("Vector2D 인덱스는 0, 1, 'x', 'y'만 가능합니다.")

# 특별 메서드 사용 예제
v1 = Vector2D(3, 4)
v2 = Vector2D(1, 2)

print("벡터 생성 및 표현:")
print(f"v1 = {v1}")        # (3, 4)
print(f"repr(v1) = {repr(v1)}")  # Vector2D(3, 4)

print("\n산술 연산:")
print(f"v1 + v2 = {v1 + v2}")      # (4, 6)
print(f"v1 - v2 = {v1 - v2}")      # (2, 2)
print(f"v1 * 2 = {v1 * 2}")        # (6, 8)
print(f"3 * v1 = {3 * v1}")        # (9, 12)

print("\n비교 연산:")
print(f"v1 == v2? {v1 == v2}")     # False
print(f"v1 != v2? {v1 != v2}")     # True
print(f"v1 == Vector2D(3, 4)? {v1 == Vector2D(3, 4)}")  # True

print("\n기타 연산:")
print(f"v1의 크기 = {abs(v1):.2f}")  # 5.00
print(f"v1은 영벡터인가? {bool(v1)}")  # True
print(f"차원 수: {len(v1)}")        # 2

print("\n인덱스 접근:")
print(f"v1[0] = {v1[0]}")          # 3
print(f"v1[1] = {v1[1]}")          # 4
print(f"v1['x'] = {v1['x']}")      # 3
print(f"v1['y'] = {v1['y']}")      # 4

# 반복문에서 사용
print("\n반복문에서의 사용:")
for component in [v1[0], v1[1]]:
    print(f"  성분: {component}")
```

## 실전 예제: 온라인 쇼핑 시스템

```python
class Product:
    """상품 기본 클래스"""
    
    def __init__(self, name, price, stock):
        self.name = name
        self.price = price
        self.stock = stock
        self.sku = self._generate_sku()
    
    def _generate_sku(self):
        """SKU 생성"""
        import hashlib
        import time
        data = f"{self.name}{time.time()}"
        return hashlib.md5(data.encode()).hexdigest()[:8].upper()
    
    def update_stock(self, quantity):
        """재고 업데이트"""
        if self.stock + quantity < 0:
            raise ValueError("재고는 0보다 작을 수 없습니다.")
        self.stock += quantity
    
    def apply_discount(self, percentage):
        """할인 적용"""
        if not 0 <= percentage <= 100:
            raise ValueError("할인율은 0~100 사이여야 합니다.")
        self.price *= (1 - percentage / 100)
    
    def __str__(self):
        return f"{self.name} - ₩{self.price:,.0f} (재고: {self.stock})"
    
    def __repr__(self):
        return f"Product(name={self.name!r}, price={self.price}, stock={self.stock})"

class DigitalProduct(Product):
    """디지털 상품 클래스"""
    
    def __init__(self, name, price, file_size, download_link):
        super().__init__(name, price, stock=float('inf'))  # 무제한 재고
        self.file_size = file_size  # MB 단위
        self.download_link = download_link
    
    def download_info(self):
        """다운로드 정보"""
        return f"{self.name} 다운로드 ({self.file_size}MB): {self.download_link}"
    
    def __str__(self):
        base_str = super().__str__()
        return f"{base_str} [디지털]"

class ShoppingCart:
    """장바구니 클래스"""
    
    def __init__(self):
        self.items = {}  # {product: quantity}
    
    def add_item(self, product, quantity=1):
        """상품 추가"""
        if quantity <= 0:
            raise ValueError("수량은 1 이상이어야 합니다.")
        
        if product.stock < quantity:
            raise ValueError(f"재고가 부족합니다. (현재 재고: {product.stock})")
        
        if product in self.items:
            self.items[product] += quantity
        else:
            self.items[product] = quantity
    
    def remove_item(self, product, quantity=None):
        """상품 제거"""
        if product not in self.items:
            raise ValueError("장바구니에 해당 상품이 없습니다.")
        
        if quantity is None or quantity >= self.items[product]:
            del self.items[product]
        else:
            self.items[product] -= quantity
    
    def get_total(self):
        """총 금액 계산"""
        total = 0
        for product, quantity in self.items.items():
            total += product.price * quantity
        return total
    
    def checkout(self):
        """결제 처리"""
        if not self.items:
            raise ValueError("장바구니가 비어 있습니다.")
        
        # 재고 업데이트
        for product, quantity in self.items.items():
            product.update_stock(-quantity)
        
        total = self.get_total()
        self.items.clear()
        return total
    
    def __str__(self):
        if not self.items:
            return "장바구니가 비어 있습니다."
        
        result = ["장바구니 내용:"]
        for product, quantity in self.items.items():
            result.append(f"  {product.name} x{quantity}: ₩{product.price * quantity:,.0f}")
        result.append(f"총 금액: ₩{self.get_total():,.0f}")
        return "\n".join(result)
    
    def __len__(self):
        """장바구니에 있는 상품 종류 수"""
        return len(self.items)
    
    def __iter__(self):
        """장바구니 순회"""
        return iter(self.items.items())

# 온라인 쇼핑 시스템 사용 예제
print("온라인 쇼핑몰 시스템")
print("=" * 50)

# 상품 생성
physical_product1 = Product("파이썬 책", 25000, 50)
physical_product2 = Product("마우스", 35000, 100)
digital_product = DigitalProduct("이북", 15000, 5, "https://example.com/ebook")

print("상품 목록:")
print(f"1. {physical_product1}")
print(f"2. {physical_product2}")
print(f"3. {digital_product}")

# 장바구니 생성 및 사용
cart = ShoppingCart()

print("\n장바구니에 상품 추가:")
try:
    cart.add_item(physical_product1, 2)
    cart.add_item(physical_product2, 1)
    cart.add_item(digital_product, 3)
    
    print(cart)
    print(f"장바구니 상품 종류 수: {len(cart)}")
    
    # 장바구니 순회
    print("\n장바구니 상세:")
    for product, quantity in cart:
        print(f"  {product.name}: {quantity}개")
    
    # 결제
    print("\n결제 진행...")
    total = cart.checkout()
    print(f"결제 완료! 총 금액: ₩{total:,.0f}")
    
    # 재고 확인
    print("\n결제 후 재고 현황:")
    print(f"{physical_product1.name} 재고: {physical_product1.stock}개")
    print(f"{physical_product2.name} 재고: {physical_product2.stock}개")
    
except ValueError as e:
    print(f"오류 발생: {e}")
```

## 결론

파이썬의 클래스는 객체지향 프로그래밍의 강력한 도구로, 복잡한 문제를 구조화하고 모델링하는 데 필수적입니다. 기본적인 클래스 정의와 인스턴스 생성부터 시작하여, 상속을 통한 코드 재사용, 다형성을 통한 유연한 설계, 특별 메서드를 이용한 직관적인 인터페이스 구축까지 다양한 개념을 이해하고 활용할 수 있어야 합니다.

실제 프로젝트에서는 클래스를 사용하여 도메인 모델을 명확하게 표현하고, 비즈니스 로직을 캡슐화하며, 코드의 재사용성과 유지보수성을 높이는 것이 중요합니다. 클래스 설계 시에는 단일 책임 원칙을 지키고, 필요한 경우에만 상속을 사용하며, 인터페이스를 명확하게 정의하는 것이 좋은 객체지향 설계의 핵심입니다.

다음 글에서는 클래스의 고급 기능인 메타클래스, 추상 클래스, 디스크립터 프로토콜 등에 대해 더 깊이 알아보겠습니다. 이러한 개념들을 이해하면 파이썬의 객체 시스템을 더욱 효과적으로 활용할 수 있을 것입니다.