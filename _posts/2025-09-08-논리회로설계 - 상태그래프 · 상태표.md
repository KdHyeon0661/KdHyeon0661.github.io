---
layout: post
title: 논리회로설계 - 상태그래프 · 상태표
date: 2025-09-08 18:25:23 +0900
category: 논리회로설계
---
# 상태그래프 · 상태표 — **순서열(시퀀스) 검출기 설계**, **복잡한 설계 문제**, **상태그래프 작성 가이드라인**

> 표기: 입력 \(x\in\{0,1\}\), 출력 \(y\in\{0,1\}\), 상태 \(q\) 또는 상태벡터 \(\mathbf{Q}\), 다음상태 \(q^+\).
> Mealy: \(y=\lambda(q,x)\), Moore: \(y=\lambda(q)\). 플립플롭은 ↑에지 트리거(D FF) 가정.

---

## 1. 순서열(시퀀스) 검출기의 **설계 절차**

### 1.1 문제 정식화(필수 명세)
- **패턴**: 예) `1011` (길이 \(m\)).
- **중첩(Overlap)**: `10111`에 `1011`이 **겹쳐** 두 번 잡혀야 하는가?
- **모델**: **Mealy**(간선 출력, 즉시) vs **Moore**(노드 출력, 1클럭 지연).
- **출력 형태**: 1클럭 펄스 / 유지형 / 카운트업.
- **리셋**: 동기/비동기, 초기상태.
- **환경**: 입력 동기화 필요 여부(CDC), 허용 지연·자원.

### 1.2 DFA(유한상태기계) 접근 — “접두/접미(prefix/suffix)” 원리
- 상태는 “현재까지 읽은 입력열의 **가장 긴 접두(prefix)** 가 **접미(suffix)** 로 남아있는 길이”로 정의.
  패턴 `1011`의 접두 집합: \(\{\epsilon, 1, 10, 101, 1011\}\).
- 입력 비트가 오면, **현 접두에 비트를 붙인 문자열**의 가장 긴 **접두==접미** 길이를 계산해 전이.
- 이 규칙은 KMP의 **실패함수**와 동일 → **중첩 허용/불허** 케이스를 체계적으로 처리.

### 1.3 Mealy vs Moore — 구현/타이밍 비교
| 구분 | 출력 위치 | 지연 | 글리치 위험 | 자원/속도 특징 |
|---|---|---|---|---|
| Mealy | 간선(\(q,x\)) | **0클럭**(조합) | 높음(조합경로) → 보통 **출력 레지스터** 1단 추가 | 상태수 적을 수 있음 |
| Moore | 노드(\(q\)) | **1클럭** | 낮음(등록된 출력) | 상태 하나 더 필요(검출 전용 상태) 빈번 |

> **실무 권장**: Mealy를 써도 **y를 1클럭 등록**해서 외부로 내보내면 안전하고 타이밍 닫기 쉬움.

### 1.4 인코딩(FF 수 vs 논리 복잡도)
| 인코딩 | FF 수 | 전이당 비트 변화 | 합성 난이도 | 용도 |
|---|---:|---:|---|---|
| 이진(Binary) | \(\lceil\log_2 N\rceil\) | 다비트 | K-map 필요 | FF 절약(ASIC) |
| 원-핫(One-Hot) | \(N\) | 2비트 | **매우 쉬움** | FPGA(카리체인/루트 쉬움) |
| 그레이 | \(\lceil\log_2 N\rceil\) | 1비트 | 중간 | EMI/해저드 민감 회로 |

---

## 2. 예제 A — **Mealy, Overlap 허용**: 패턴 `1011`

### 2.1 상태 정의(길이 기반)
- \(S_0\): 매치 길이 0
- \(S_1\): `1`
- \(S_2\): `10`
- \(S_3\): `101`
- **검출**: \(S_3\)에서 \(x=1\)이면 즉시 \(y=1\).

### 2.2 전이 규칙(접두/접미 규칙)
- \(S_0\): `0→S_0`, `1→S_1`
- \(S_1\): `0→S_2`, `1→S_1`
- \(S_2\): `1→S_3`, `0→S_0`
- \(S_3\): `1→S_1`(**y=1**), `0→S_2`

### 2.3 상태표 (Mealy: 칸=다음상태/출력)
| 현재 | x=0        | x=1        |
|:---:|:-----------|:-----------|
| S0  | S0 / 0     | S1 / 0     |
| S1  | S2 / 0     | S1 / 0     |
| S2  | S0 / 0     | S3 / 0     |
| S3  | S2 / 0     | S1 / **1** |

### 2.4 상태그래프(ASCII, 간선 라벨 `x/y`)
```
S0 --0/0--> S0   S0 --1/0--> S1
S1 --0/0--> S2   S1 --1/0--> S1
S2 --0/0--> S0   S2 --1/0--> S3
S3 --0/0--> S2   S3 --1/1--> S1
```

### 2.5 **원-핫** 다음상태/출력 식(합성 친화)
현재상태 FF \(S_i\in\{0,1\}\), 입력 \(x\).
$$
\begin{aligned}
S_0^+ &= S_0\overline{x} + S_2\overline{x} \\
S_1^+ &= x(S_0+S_1+S_3) \\
S_2^+ &= \overline{x}(S_1+S_3) \\
S_3^+ &= S_2 x \\
y     &= S_3 x
\end{aligned}
$$

### 2.6 VHDL(원-핫, Mealy→출력 등록)
```vhdl
-- 1011 Mealy detector (overlap), registered output
library ieee; use ieee.std_logic_1164.all;
entity det_1011_mealy is
  port (clk, rst: in std_logic; x: in std_logic; y: out std_logic);
end;
architecture rtl of det_1011_mealy is
  signal S0,S1,S2,S3 : std_logic := '1','0','0','0';
  signal y_i : std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        S0 <= '1'; S1 <= '0'; S2 <= '0'; S3 <= '0'; y_i <= '0';
      else
        S0 <= (S0 and not x) or (S2 and not x);
        S1 <= (S0 and x) or (S1 and x) or (S3 and x);
        S2 <= (S1 and not x) or (S3 and not x);
        S3 <= (S2 and x);
        y_i <= (S3 and x); -- registered Mealy output
      end if;
    end if;
  end process;
  y <= y_i;
end;
```

### 2.7 **이진 인코딩**(예: S0=00, S1=01, S2=10, S3=11)로 **D식 유도 예**
| 현재 \(Q_1Q_0\) | x | 다음 \(Q_1^+Q_0^+\) | y |
|:--:|:--:|:--:|:--:|
| 00 | 0 | 00 | 0 |
| 00 | 1 | 01 | 0 |
| 01 | 0 | 10 | 0 |
| 01 | 1 | 01 | 0 |
| 10 | 0 | 00 | 0 |
| 10 | 1 | 11 | 0 |
| 11 | 0 | 10 | 0 |
| 11 | 1 | 01 | 1 |

K-map 최소화 결과의 한 예:
\[
\begin{aligned}
D_1 &= Q_1\overline{Q_0}\,\overline{x} \;+\; \overline{Q_1}Q_0\,\overline{x} \;+\; \overline{Q_1}\overline{Q_0}\,x \\
D_0 &= \overline{Q_1}\,\overline{Q_0}\,x \;+\; Q_1\overline{Q_0}\,\overline{x} \;+\; Q_1Q_0\,\overline{x} \\
y   &= Q_1Q_0 x
\end{aligned}
\]
> 이진 인코딩은 FF 적지만 논리가 복잡해지기 쉬움. FPGA는 원-핫이 대체로 유리.

---

## 3. 예제 B — **Moore, Overlap/Non-Overlap**

### 3.1 Moore로 변환(검출 상태 \(S_4\))
- \(S_3\)에서 `x=1`이면 **다음 클럭에** \(S_4\)로 들어감. \(S_4\) 노드에서 \(y=1\).

### 3.2 Overlap 허용/비허용 차이표
| 현재 | x=0 (다음/출력) | x=1 (다음/출력) |
|:---:|:--|:--|
| S0 | S0/0 | S1/0 |
| S1 | S2/0 | S1/0 |
| S2 | S0/0 | S3/0 |
| S3 | S2/0 | **S4/0** |
| S4(Overlap) | S1/**1** | S1/**1** |
| S4(Non-Overlap) | S0/**1** | S0/**1** |

### 3.3 VHDL(원-핫, Moore, Overlap/Non-Overlap 토글)
```vhdl
library ieee; use ieee.std_logic_1164.all;
entity det_1011_moore is
  generic (OVERLAP: boolean := true);
  port (clk, rst: in std_logic; x: in std_logic; y: out std_logic);
end;
architecture rtl of det_1011_moore is
  signal S0,S1,S2,S3,S4: std_logic := '1','0','0','0','0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        S0<='1'; S1<='0'; S2<='0'; S3<='0'; S4<='0';
      else
        S0 <= (S0 and not x) or (S2 and not x) or (S4 and (not OVERLAP));
        S1 <= (S0 and x) or (S1 and x) or (S4 and OVERLAP) or (S3 and x);
        S2 <= (S1 and not x) or (S3 and not x);
        S3 <= (S2 and x);
        S4 <= (S3 and x);
      end if;
    end if;
  end process;
  y <= S4; -- Moore
end;
```

---

## 4. 예제 C — **다중 패턴**(Aho–Corasick 아이디어)

### 4.1 “`1011` 또는 `1001`” (Mealy, 겹침 허용)
- 접두 기반 상태: \(\epsilon, 1, 10, 100, 101, 1011, 1001\) 등.
- 각 상태에서 `0/1` 입력 시 **가장 긴 접두==접미**로 이동.
- 출력은 간선이 **어느 패턴을 완결**하는지에 따라 1.

| 상태(의미) | x=0 (다음/출력) | x=1 (다음/출력) |
|---|---|---|
| \(\epsilon\) | \(\epsilon\)/0 | 1/0 |
| 1 | 10/0 | 1/0 |
| 10 | 100/0 | 101/0 |
| 100 | 100/0 | 1001/**1** |
| 101 | 10/0 | 1011/**1** |
| 1001 | 1/0 | 1/0 |
| 1011 | 1/0 | 1/0 |

> 두 패턴 동시 종료가 있을 수 있으므로 실제 설계에선 다중 출력선 또는 인덱스 코딩이 필요.

### 4.2 구현 메모
- 원-핫이면 다음상태식은 “**해당 간선 조건의 OR**”로 단순화.
- 다수 패턴일수록 **상태수↑** → 테이블 드리븐(ROM) 접근이 유리해짐(§5.1).

---

## 5. **복잡한 설계 문제**와 해법 패턴

### 5.1 매우 긴 패턴(수십~수백 비트)
- 상태수 \(m+1\) → 이진 인코딩 + **테이블 룩업 FSM**(주소=\(q,x\), 데이터=\(q^+,y\)).
- CRC/프리앰블 같이 선형 구조는 **LFSR**/다항식 기반 설계로 변환.

### 5.2 다비트 입력(\(|\Sigma|=2^k\))
- 비트당 FSM 병렬 vs **바이트 단위 DFA**(입력 라인 수↑).
- 타이밍 여유가 빡빡하면 **파이프라인 단계** 추가(상태 분할).

### 5.3 “조건부 검출” & 금지 구간
- 패턴 FSM ⨉ 제약 FSM(윈도우/마스크)을 **직접곱**으로 합성.
- 또는 Mealy 출력에 조건 신호를 **AND**.

### 5.4 CDC/노이즈
- 외부 신호는 **2단 동기화 후** FSM 투입.
- Mealy 출력은 **반드시 레지스터** 후 외부 배선.

### 5.5 최적화 포인트
- **인코딩 선택**(원-핫 vs 이진), **출력 등록**, **상태 최소화**(동치 상태 병합), **Self-start**(모든 상태→합법 루프 수렴).

---

## 6. 상태그래프 **작성 가이드라인**

### 6.1 체크리스트
| 항목 | 내용 |
|---|---|
| 모델/중첩 | Mealy/Moore 선택, overlap 여부 명시 |
| 상태 의미 | “여기까지 매치” 등 텍스트로 먼저 정의 |
| 전이 완전화 | 모든 상태에서 x=0/1 전이 **모두** 기입 |
| 출력 배치 | Mealy=간선 `x/y`, Moore=노드 `y` |
| 리셋/초기 | 초기상태/리셋 경로 명시 |
| Self-start | 불법 상태에서 루프로 복귀 경로 존재 |
| 가독성 | 교차 최소, 전진 우/하향, 루프 곡선 |
| 단위 테스트 | 짧은 입력열로 손 추적 → 표와 일치 검증 |

### 6.2 안티패턴
- 일부 입력에 대한 **전이 미정**(합성기 래치/‘X’).
- Mealy 출력 **무등록**으로 외부에 직결.
- 비동기 리셋 **해제** 타이밍 무시(메타안정 위험).

---

## 7. 상태표→논리식 유도(요약 공식)

### 7.1 이진 인코딩
- \(D_i = Q_i^+(Q,x)\)를 **K-map**으로 최소화.
- Mealy 출력 \(y=\lambda(Q,x)\) 역시 K-map 최소화.

### 7.2 원-핫 인코딩(권장)
$$
S_j^+ \;=\; \bigvee_{(i,x):\,\delta(S_i,x)=S_j} \bigl(S_i \land \chi_x\bigr), \qquad
\chi_x \in \{x,\overline{x},\text{(여러 입력일 땐 디코더 조합)}\}
$$
- Moore 출력: \(y=\lambda(S)\) 는 단순 조합.
- Mealy 출력: \(y=\lambda(S,x)\) → **레지스터 1단** 후 외부로.

---

## 8. 타이밍/해저드 관점의 주의점

### 8.1 지연·펄스폭
- Mealy는 \(y\)가 **조합 경로** → 입력과 동시 변동 시 **짧은 펄스** 가능.
- 펄스폭 최소 보장 필요 시: **출력 레지스터** + **펄스 스트레처**.

### 8.2 합성/배선
- FPGA: 원-핫 + **플랫 논리**가 라우팅·Fmax에 유리.
- ASIC: 상태 수 많으면 이진 인코딩 + **균형 트리**.

---

## 9. 검증(Verification) — 테스트벤치 & SVA

### 9.1 간단 TB(임의 비트스트림, 스코어보드 비교)
```verilog
`timescale 1ns/1ps
module tb_1011;
  reg clk=0, rst=1, x=0; wire y;
  det_1011_mealy dut(.clk(clk), .rst(rst), .x(x), .y(y));
  always #5 clk = ~clk;

  // 황금모델: 쉬프트 윈도 + 비교 (overlap 허용)
  reg [3:0] win; integer i;
  function ref_y(input [3:0] w); ref_y = (w==4'b1011); endfunction

  initial begin
    repeat(2) @(posedge clk); rst=0;
    for (i=0;i<200;i++) begin
      x = $urandom_range(0,1);
      @(negedge clk); win = {win[2:0], x};
      @(posedge clk); // y는 등록됨(1클럭 지연)
      if (y !== ref_y(win)) $display("MISCOMPARE @%0t win=%b y=%0b", $time, win, y);
    end
    $finish;
  end
endmodule
```

### 9.2 SVA(Overlap 허용 검출 타이밍 확인)
```verilog
// Mealy 등록 출력: S3&x가 클럭에 샘플되면 다음 클럭에 y==1
property p_detect;
  @(posedge clk) disable iff (rst)
    (dut.S3 && x) |=> (y==1);
endproperty
assert property (p_detect);
```

### 9.3 커버리지
- **전이 커버**: 모든 상태×입력 조합이 적어도 1회 발생.
- **패턴 커버**: ‘1011’ 검출이 다양한 경계(초기·연속·잡음 전후)에서 발생.

---

## 10. 구현 대안: **쉬프트+비교** vs **FSM**
| 방법 | 지연 | 자원 | 장점 | 단점 |
|---|---|---|---|---|
| FSM(DFA) | 1클럭(등록 기준) | 상태 FF + 소량 조합 | 중첩·와일드카드·다중 패턴 확장 쉬움 | 설계/검증 필요 |
| 쉬프트+비교 | 1클럭(등록 기준) | \(m\)비트 쉬프트 + 동등 비교 | 단일 패턴 고정 시 단순 | 와일드카드/다중 패턴 부적합, 전력↑ |

> 다중 패턴/조건부 규칙이 많으면 FSM(특히 테이블 드리븐)이 유리.

---

## 11. 연습문제(원하면 해설 제공)

1) `1101` 검출기(Mealy, overlap) 상태표·그래프 작성, 원-핫 다음상태식을 유도하라.
2) `101` 검출 후 **정확히 3클럭 뒤** 펄스를 내는 **Moore** FSM을 설계하라(카운터 구성 포함).
3) “`1011` 또는 `1001`”을 Aho–Corasick 방식으로 설계하고 상태수·전이를 표로 제시하라.
4) Mealy→출력 레지스터 1단 추가 시 **펄스 타이밍** 변화를 타이밍도로 그려라.
5) 이진 인코딩으로 구현 시 \(D_1,D_0,y\)에 대한 K-map을 작성하고 최소식을 구하라.

---

## 포켓 요약
- **핵심 원리**: 접두/접미 규칙로 DFA 구성 → Mealy/Moore, overlap 정책 반영.
- **구현**: FPGA는 **원-핫 + 출력 등록**이 단순·고속. Mealy 글리치는 등록으로 방지.
- **검증**: TB+SVA로 검출 타이밍·중첩·self-start를 커버.
- **확장**: 다중 패턴은 Aho–Corasick 개념으로 테이블 드리븐 접근이 효과적.
