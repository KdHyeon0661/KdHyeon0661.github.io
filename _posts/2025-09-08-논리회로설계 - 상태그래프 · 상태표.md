---
layout: post
title: 논리회로설계 - 상태그래프 · 상태표
date: 2025-09-08 18:25:23 +0900
category: 논리회로설계
---
# 상태그래프 · 상태표 — **순서열(시퀀스) 검출기 설계**, **복잡한 설계 문제**, **상태그래프 작성 가이드라인**

> 표기: 입력 \(x\in\{0,1\}\), 출력 \(y\in\{0,1\}\), 상태 \(q\) 또는 상태벡터 \(\mathbf{Q}\), 다음상태 \(q^+\).  
> Mealy: \(y=\lambda(q,x)\), Moore: \(y=\lambda(q)\). 플립플롭은 ↑에지 트리거(D FF) 가정.

---

## 1) 순서열(시퀀스) 검출기의 **설계 절차**

### 1.1 문제 정식화(필수 명세)
- **패턴**: 예) `1011` (길이 \(m\)).  
- **중첩(Overlap)** 허용 여부: `10111`에서 `1011`을 **두 번** 인식할 것인가?  
- **모델**: **Mealy**(즉시 출력) vs **Moore**(다음 클럭에 출력).  
- **출력 폭**: 펄스 1클럭, 유지형, 혹은 카운트업 등.  
- **초기/리셋**: 동기/비동기, 초기 상태.

### 1.2 DFA(유한상태기계) 접근 — “접두/접미(prefix/suffix)” 원리
- 상태는 **가장 긴 접두(prefix)** 가 현재까지의 입력열의 **접미(suffix)** 와 일치하는 길이로 정의한다.  
  - `1011`의 접두 집합: \(\{\epsilon, 1, 10, 101, 1011\}\).  
  - 입력 비트가 오면, 현 접두 뒤에 비트를 붙인 문자열의 **가장 긴 접두==접미** 길이로 전이.  
- 이 규칙은 KMP의 **실패함수**(failure function)와 동일하며 **중첩 처리**가 자동으로 해결된다.

### 1.3 상태 수와 인코딩
- **이진 인코딩**: \(\lceil \log_2 N\rceil\) FF (최소 FF), 논리 복잡도↑ 가능.  
- **원-핫(one-hot)**: 상태수 \(N\)개의 FF (FPGA 친화, 논리 단순, 속도↑).  
- **그레이/존슨**: 전이 해저드/EMI 고려 시 선택.

---

## 2) 예제 A — **Mealy, Overlap 허용**: 패턴 `1011`

### 2.1 상태 정의(길이 기반)
- \(S_0\): 매치 길이 0 (아무 접두도 아님)  
- \(S_1\): `1`  
- \(S_2\): `10`  
- \(S_3\): `101`  
- **검출 조건**: \(S_3\)에서 \(x=1\) 입력이 오면 `1011` 완성 → 즉시 \(y=1\).

### 2.2 전이 규칙(접두/접미 규칙 적용)
- \(S_0\): `0→S_0`, `1→S_1`  
- \(S_1\): `0→S_2` (`10`), `1→S_1` (`11`의 접미= `1`)  
- \(S_2\): `1→S_3` (`101`), `0→S_0` (`100`의 접미 접두 최장은 \(\epsilon\))  
- \(S_3\): `1→S_1` (**출력1**) (`1011`의 접미 접두 최장=`1`), `0→S_2` (`1010`의 접미 접두 최장=`10`)

### 2.3 상태표 (Mealy: 칸에 `다음상태/출력`)
| 현재 | x=0        | x=1        |
|:---:|:-----------|:-----------|
| S0  | S0 / 0     | S1 / 0     |
| S1  | S2 / 0     | S1 / 0     |
| S2  | S0 / 0     | S3 / 0     |
| S3  | S2 / 0     | S1 / **1** |

### 2.4 상태그래프(간선 라벨 `x/y`)
```
S0 --0/0--> S0,  S0 --1/0--> S1
S1 --0/0--> S2,  S1 --1/0--> S1
S2 --0/0--> S0,  S2 --1/0--> S3
S3 --0/0--> S2,  S3 --1/1--> S1
```

### 2.5 원-핫 다음상태식(간단·합성 친화)
현재상태 플립플롭 \(S_i\in\{0,1\}\), 입력 \(x\).
\[
\begin{aligned}
S_0^+ &= S_0\overline{x} \;+\; S_2\overline{x} \\
S_1^+ &= S_0 x \;+\; S_1 x \;+\; S_3 x \\
S_2^+ &= S_1 \overline{x} \;+\; S_3 \overline{x} \\
S_3^+ &= S_2 x \\
y     &= S_3 x \quad (\text{Mealy})
\end{aligned}
\]
> 이 식을 K-map/대수로 조금 더 묶어 게이트 수를 줄일 수 있습니다(예: \(S_1^+=x(S_0+S_1+S_3)\)).

---

## 3) 예제 B — **Moore, Overlap/Non-Overlap**

### 3.1 Moore로 바꾸기
- **검출 전용 상태** \(S_4\)를 추가하고 이 상태의 **노드 출력**을 \(y=1\)로 둔다.  
- \(S_3\)에서 `x=1`을 받으면 **다음 클럭**에 \(S_4\)로 들어가며 \(y=1\)이 1클럭 발생.

### 3.2 Overlap 허용/비허용 차이
- **Overlap 허용**: \(S_4\)에서 **다음 접두**로 점프 (여기선 `1` → \(S_1\)).  
- **Non-Overlap**: \(S_4\) 다음을 **초기 상태 \(S_0\)** 로 강제.

### 3.3 상태표(요지)
| 현재 | x=0 (다음/출력) | x=1 (다음/출력) |
|:---:|:-----------------|:-----------------|
| S0  | S0/0 | S1/0 |
| S1  | S2/0 | S1/0 |
| S2  | S0/0 | S3/0 |
| S3  | S2/0 | **S4/0** |
| S4  | (Overlap) S1/**1**  | (Same) S1/**1** |
| S4  | (Non-Overlap) S0/**1** | (Same) S0/**1** |

> Moore는 출력이 노드에 붙으므로 표에서 모든 칸의 출력은 **현재 노드의 출력**(S4=1, 나머지=0)입니다. 위 표는 읽기 편하게 전이만 강조했습니다.

---

## 4) 예제 C — **다중 패턴** 및 확장

### 4.1 “`1011` **또는** `1001`” 검출 (Mealy, 겹침 허용)
- 상태를 “가장 긴 공통 접두” 기반으로 정의 → **Aho–Corasick** 다중 패턴 DFA 개념.  
- 핵심은 전이를 “각 상태에서 `0/1` 입력 시 **가장 긴 접두**로 이동”으로 통일하는 것.  
- 출력은 도착 상태/간선이 어느 패턴을 **끝맺는지**에 따라 설정(두 패턴이 한 에지에서 동시에 끝나면 **2개 출력선** 또는 **디코더**).

### 4.2 와일드카드·범위
- “`10x1`”(세 번째 비트 don’t-care): 상태 \(S_2\)(`10`)에서 `x=0/1` 모두 **검출 직전 상태**로 이동.  
- 값 범위(예: 직렬 8b 값 중 `0xA?`): **비트-레벨 DFA** 또는 **평행 파이프라인**(8개의 비트 동시 입력)으로 처리.

### 4.3 잡음/메타안정 & 입력 동기화
- 외부 비트스트림은 **클럭 동기화**(두단 FF) 후 DFA에 공급.  
- Mealy 출력은 **조합이므로 글리치 가능** → 일반적으로 **출력을 1클럭 레지스터**에 싣는다.

---

## 5) **복잡한 설계 문제**: 전략과 패턴

### 5.1 길이가 긴 패턴(수십~수백 비트)
- **ROM/표 기반**: 길이 \(m\)일 때 상태수 \(m\!+\!1\). 이진 인코딩 후 **다음상태=테이블 룩업**(주소=\(q,x\)).  
- **LFSR/해시 보조**: 긴 정형 패턴(CRC, 프리앰블)은 선형성 이용.

### 5.2 복수 입력·여러 도메인
- 입력 \(x\)가 **다비트**면 알파벳 크기 \(|\Sigma|=2^k\)인 DFA로 모델.  
- 다른 클럭 도메인에서 오는 플래그/펄스 → **CDC 동기화** + 펄스 스트레처.

### 5.3 “조건부 검출” / 금지 구간
- 예: `1011` 검출 **단,** 직전 16클럭 안에 에러 플래그가 없을 것.  
  - **직렬 구성**: (에러-윈도우 FSM) ⨉ (패턴 FSM) **직접곱** 상태공간으로 합성.  
  - 또는 **게이트**: 패턴 검출 출력을 “윈도우 OK” 신호로 마스킹.

### 5.4 계층화/모듈화
- 긴 패턴을 **서브패턴** FSM으로 나눠 **핸드셰이크** 연결(“전단 `101` 검출 → 후단 `1` 검증”).  
- 재사용/검증 용이, 그러나 **파이프라인 지연**을 명세에 반영해야 함.

### 5.5 최적화 포인트
- **인코딩 선택**: FPGA면 **원-핫** or “원-핫 + 출력등록”이 빈번히 최적.  
- **상태 최소화**: 동치 상태 병합(모든 입력에서 같은 행동·출력).  
- **출력 글리치**: Mealy는 **등록**해서 사용(특히 외부 인터럽트/클리어로 쓰일 때).  
- **Self-start**: 모든 **불법 상태**에서 초기 루프로 돌아오게 전이 추가.

---

## 6) 상태그래프 **작성 가이드라인**

### 6.1 작성 순서(체크리스트)
1. **모델 결정**: Mealy vs Moore, **중첩 허용 여부**.  
2. **상태 의미**를 **텍스트로** 먼저 정의(예: “`101`까지 매치”).  
3. 각 상태에 대해 입력별 **다음상태를 완전하게** 채움(0/1 모두). **미정 칸 금지**.  
4. **출력 정의**: Mealy는 간선에 `x/y`, Moore는 노드에 `y`.  
5. **초기 상태**와 **리셋 경로** 명시.  
6. **Self-start**: 모든 상태에서 합법 루프로 수렴하도록 전이 추가.  
7. **간선 라벨** 간결화: 동일 전이/출력은 `0,1/…`로 묶기.  
8. **가독성**: 루프는 곡선, 전진은 오른쪽/아래 방향. **교차 최소화**.  
9. **단위 테스트**: 짧은 입력열로 수작업 추적 → 그래프와 일치 확인.  
10. **상태표 동등성 검증**: 그래프↔표가 서로 역변환됨을 확인.

### 6.2 좋은 습관 / 안티패턴
- **좋은 습관**
  - 상태 이름에 **의미**를 담기: `S101`(“101까지 매치”) 등.  
  - 불법/미사용 상태의 **전이도 정의**(락아웃 방지).  
  - Mealy 출력은 **레지스터**해서 외부에 내보내기.
- **안티패턴**
  - 일부 입력에 대한 **전이 미정**(합성 시 래치/‘X’).  
  - **조합 루프**(출력→입력 직결) 생성.  
  - **리셋 동작** 미규정, 또는 비동기 리셋 **해제** 타이밍 무시.

### 6.3 상태표 작성 팁
- 표의 행=현재상태, 열=입력. 칸에는 **다음상태/출력**(Mealy) 또는 **다음상태**(Moore).  
- FPGA 원-핫을 염두에 두면, 표에서 각 상태의 **활성 조건**이 곧 **다음상태 FF의 D식**이 된다.

---

## 7) 상태표→논리식 유도(요약 공식)

상태 인코딩(이진 또는 원-핫) 후, \(D\) 입력은 **다음상태**이다.
- **이진 인코딩**: \(D_i = Q_i^+(Q,x)\)를 K-map으로 최소화.  
- **원-핫 인코딩**(권장):
  \[
  S_j^+ = \bigvee_{\text{모든 }(i,x)\text{: } \delta(S_i,x)=S_j} (S_i \land \chi_x),
  \]
  \(\chi_x\)는 입력 값 판별(예: \(x\) 또는 \(\overline{x}\)).  
- Mealy 출력: 조합식 \(y=\lambda(q,x)\) **→ 레지스터**해서 사용 권장.  
- Moore 출력: \(y=\lambda(q)\) → 상태 FF 출력의 조합.

---

## 8) VHDL 구현 스니펫 (원-핫, 예제 A: `1011`, Mealy→출력 레지스터)

```vhdl
-- one-hot FSM for 1011 detector (Mealy overlap), registered output
library ieee; use ieee.std_logic_1164.all;
entity det_1011 is
  port (clk, rst : in std_logic;
        x        : in std_logic;
        y        : out std_logic);
end;
architecture rtl of det_1011 is
  signal S0,S1,S2,S3 : std_logic := '1','0','0','0';
  signal y_i : std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        S0 <= '1'; S1 <= '0'; S2 <= '0'; S3 <= '0'; y_i <= '0';
      else
        -- next state
        S0 <= (S0 and not x) or (S2 and not x);
        S1 <= (S0 and x) or (S1 and x) or (S3 and x);
        S2 <= (S1 and not x) or (S3 and not x);
        S3 <= (S2 and x);
        -- registered Mealy output
        y_i <= (S3 and x);
      end if;
    end if;
  end process;
  y <= y_i;
end;
```

---

## 9) 연습 문제(해설 원하면 이어서 제공)

1) `1101` 검출기(Mealy, overlap 허용)의 상태표·그래프를 작성하고, 원-핫 다음상태식을 유도하라.  
2) `101` 검출 후 **딱 3클럭 뒤**에 펄스 1을 내는 Moore FSM을 설계하라(카운터/상태 확장).  
3) “`1011` 또는 `1001`” 검출기를 Aho–Corasick 방식으로 설계하고 상태수와 전이를 표로 제시하라.  
4) Mealy로 만든 검출기를 출력 레지스터 1단 추가 시 **펄스 타이밍**이 어떻게 변하는지 타이밍도에 그려라.  
5) 불법 상태에서 **가장 긴 접두 복귀** 규칙으로 self-start를 증명하라.

---

### 포켓 요약
- **설계 핵심**: 접두/접미 원리로 DFA를 만들고(Mealy/Moore, overlap 여부 포함), 상태표/그래프를 서로 검증.  
- **실무 팁**: FPGA는 **원-핫 + 출력 레지스터**가 단순·고속. Mealy 글리치는 **등록**으로 방지.  
- **가이드라인**: 전이 완전화, self-start, 리셋 명세, 가독성 있는 그래프, 상태 의미 문서화.
