---
layout: post
title: DB - ERD 표기법
date: 2025-02-02 19:20:23 +0900
category: DB
---
# ERD 표기법 (Crow’s Foot, IE Notation)

## 0. 리마인드 (핵심 요약)

- **ERD**는 **엔티티(사각형), 관계(선), 속성(필드)**과 **카디널리티/옵셔널리티**를 명시하는 **논리 모델** 도구다.  
- **Crow’s Foot**: `○`(0), `|`(1), `—`(1), `<`(N)의 조합으로 **최소/최대**를 직관 표현.  
- **IE**: **(min, max)**로 최소/최대 참여수를 **수치**로 표현.  
- 설계는 **개념→논리→물리** 흐름으로, ERD의 제약은 **PK/FK/UNIQUE/CHECK/트리거** 등으로 **코드화**되어야 한다.

---

## 1. Crow’s Foot Notation — 기호와 조합의 정밀 해석

### 1.1 기본 기호(최소/최대)
- 최소(Minimum) 참여: `○` = 0, `|` = 1  
- 최대(Maximum) 참여: `—` = 1, `<` = N

### 1.2 조합 표 (한 쪽 끝의 의미)

| 표기 | 의미 | 해석(참여수) |
|---|---|---|
| `○—` | 0..1 | 선택적 단일 |
| `|—` | 1..1 | 필수 단일 |
| `○<` | 0..N | 선택적 다수 |
| `|<` | 1..N | 필수 다수 |

> 관계의 **양쪽 끝**에 위 기호가 각각 붙는다. 각 끝의 표기는 **반대쪽 엔티티**의 참여수를 의미한다(관습적 표기 주의).

### 1.3 예시 — 고객과 주문 (1:N, 주문은 반드시 고객에 속함)

```text
고객 |—< 주문
```

- 고객 쪽에서 주문을 볼 때: `|<` ⇒ **고객 1명**은 **주문 여러 건**(최소 1, 최대 N)을 가질 수 있다.  
- 주문 쪽에서 고객을 볼 때: `|—` ⇒ **주문 1건**은 **고객 1명**에 **필수**로 속한다(0 불가).

### 1.4 IE로 동치 표기
- 고객—주문: 고객 측에서 주문 참여수 (1,N), 주문 측에서 고객 참여수 (1,1)  
- IE 표기: `고객 —(1,N)— 주문` & `주문 —(1,1)— 고객`

---

## 2. IE Notation — (min, max)의 엄밀화

- 표기: **(최소, 최대)**  
- 예: `(0,1)`, `(1,1)`, `(0,N)`, `(1,N)`

### 2.1 예시 — 직원과 부서
- “직원은 반드시 한 부서에 소속된다. 부서는 0명 이상의 직원을 가질 수 있다.”
- IE: `직원 —(1,1)— 부서` & `부서 —(0,N)— 직원`
- Crow’s Foot: `부서 ○< 직원` & `직원 |— 부서`

---

## 3. Crow’s Foot ↔ IE 변환 규칙

| Crow’s Foot | IE (min,max) | 설명 |
|---|---|---|
| `○—` | (0,1) | 선택 단일 |
| `|—` | (1,1) | 필수 단일 |
| `○<` | (0,N) | 선택 다수 |
| `|<` | (1,N) | 필수 다수 |

> 변환 시 **관계의 방향성**보다 **각 끝의 참여수 해석**이 중요하다. 도구마다 선/기호 배치가 다를 수 있으니 **문서 예시를 함께 넣어 오해를 방지**한다.

---

## 4. 식별/비식별 관계의 표기와 물리 매핑

- **식별(Identifying)**: **부모 PK가 자식 PK에 포함**(약 엔티티). Crow’s Foot에서 **굵은 선/실선**으로 표기하는 툴이 많다.  
- **비식별(Non-identifying)**: 자식은 **독립 PK**, 부모 PK는 **자식의 FK**로만 존재. 종종 **점선**으로 표기.

### 4.1 예시 — 주문/주문항목(식별자 관계, 약 엔티티)

Crow’s Foot(개념):
```text
주문 |—< 주문항목
(주문항목 PK에 주문의 PK가 포함됨: PK=(OrderID, LineNo))
```

SQL(물리):
```sql
CREATE TABLE "order" (
  order_id   BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE RESTRICT,
  ordered_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE order_item (
  order_id BIGINT NOT NULL,
  line_no  INT    NOT NULL,
  product_id BIGINT NOT NULL REFERENCES product(product_id),
  qty      INT    NOT NULL CHECK (qty > 0),
  price_at NUMERIC(12,2) NOT NULL CHECK (price_at >= 0),
  PRIMARY KEY (order_id, line_no),
  FOREIGN KEY (order_id) REFERENCES "order"(order_id) ON DELETE CASCADE
);
```

### 4.2 비식별 관계 예 — 주문-결제(결제는 독립 PK, 주문 FK만 보유)

```sql
CREATE TABLE payment (
  payment_id BIGSERIAL PRIMARY KEY,
  order_id   BIGINT NOT NULL UNIQUE REFERENCES "order"(order_id) ON DELETE CASCADE,
  amount     NUMERIC(12,2) NOT NULL,
  paid_at    timestamptz NOT NULL
);
```

---

## 5. 재귀(자기) 관계 표기

### 5.1 트리형 카테고리

Crow’s Foot:
```text
카테고리  ○—<  카테고리
(parent_id 선택, 자식 여러 개)
```

IE:
- 부모 측에서 자식 참여: `(0,N)`  
- 자식 측에서 부모 참여: `(0,1)` 또는 `(1,1)`(필수 여부에 따라)

SQL:
```sql
CREATE TABLE category (
  category_id BIGSERIAL PRIMARY KEY,
  name        text NOT NULL,
  parent_id   BIGINT REFERENCES category(category_id) ON DELETE SET NULL
);
```

> “루트 허용”이면 `(0,1)`, 반드시 상위가 있어야 하면 `(1,1)`.

---

## 6. 삼항/다항(n-ary) 관계 표기와 분해

### 6.1 삼항(예: 의사-환자-진료일)

개념(삼항 관계 그대로 표기 가능하나, **대부분 2항 조합 + 조인 엔티티**로 분해):

```text
[진료] 엔티티 = (의사, 환자, 진료일) + 속성들(진단코드, 처치)
의사 |—< 진료 >—| 환자
진료 —|— 진료일(날짜)
```

SQL(조인 엔티티로 구현):
```sql
CREATE TABLE visit (
  doctor_id BIGINT NOT NULL REFERENCES doctor(doctor_id),
  patient_id BIGINT NOT NULL REFERENCES patient(patient_id),
  visit_date date NOT NULL,
  diagnosis_code text,
  treatment text,
  PRIMARY KEY (doctor_id, patient_id, visit_date)
);
```

> **삼항을 이항들로 나눌 때 의미 손실**이 생길 수 있다. **조인 엔티티**로 **동시 제약**을 모델링하는 편이 안전하다.

---

## 7. 슈퍼타입/서브타입(상속) 표기

Crow’s Foot/IE 모두 **하나의 슈퍼타입**에서 **여러 서브타입으로 분기**를 표현할 수 있다.  
- **완전/불완전**: 모든 인스턴스가 서브타입에 속해야 하는지(완전) 여부.  
- **상호배타/중첩가능**: 서브타입 간 배타성.

### 7.1 결제 예(카드/계좌)

개념:
```text
[결제] ──< [카드결제]
     └──< [계좌결제]
(완전/배타 가정: 결제는 반드시 한 방법, 동시에 두 방법 불가)
```

SQL(클래스별 테이블):
```sql
CREATE TABLE payment (
  payment_id BIGSERIAL PRIMARY KEY,
  order_id   BIGINT NOT NULL UNIQUE REFERENCES "order"(order_id) ON DELETE CASCADE,
  amount     NUMERIC(12,2) NOT NULL,
  paid_at    timestamptz NOT NULL,
  method     text NOT NULL CHECK (method IN ('CARD','BANK'))
);

CREATE TABLE card_payment (
  payment_id  BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  card_no_hash text NOT NULL,
  auth_code    text NOT NULL
);

CREATE TABLE bank_payment (
  payment_id BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  bank_code  text NOT NULL,
  account_no text NOT NULL
);
```

> 일부 툴은 슈퍼타입/서브타입을 **UML Generalization**처럼 그리며, Crow’s Foot/IE 혼용 시 **범례**를 붙여 오해를 방지한다.

---

## 8. Crow’s Foot와 IE로 같은 모델 그리기(종합 예)

### 8.1 도메인: 고객–주문–주문항목–상품–결제–주소

Crow’s Foot(ASCII):
```text
고객 |—< 주문 |—< 주문항목 >—| 상품
고객 ○—< 주소
주문 |— 카드결제
    |— 계좌결제   (슈퍼타입: 결제)
```

IE(문장):
- 고객—주문: 고객 (1,N) 주문, 주문 (1,1) 고객  
- 주문—주문항목: 주문 (1,N) 주문항목, 주문항목 (1,1) 주문  
- 주문항목—상품: 주문항목 (1,1) 상품, 상품 (0,N) 주문항목  
- 고객—주소: 고객 (0,N) 주소, 주소 (1,1) 고객  
- 주문—결제(슈퍼타입): 주문 (0,1) 결제, 결제 (1,1) 주문  
- 결제—카드결제/계좌결제: 결제 (0,1) 각 서브타입, 서브타입 (1,1) 결제

---

## 9. 표기와 물리 구현 매핑 규칙(핵심 패턴)

| 모델 제약 | DDL 매핑 |
|---|---|
| 1:1 (필수/선택) | FK + UNIQUE(또는 PK 공유) + NOT NULL/NULL |
| 1:N | N쪽 테이블에 FK (필수면 NOT NULL, 선택이면 NULL 허용) |
| N:M | 조인 엔티티 + `(fk1, fk2, …)`에 PK/UNIQUE |
| 식별 관계 | 자식 PK에 부모 PK 포함(복합 PK) |
| 비식별 관계 | 자식은 독립 PK + FK |
| 필수 참여 | FK NOT NULL + ON DELETE 제약(업무 규칙에 맞게) |
| 기간 겹침 금지 | CHECK/배타 제약(Exclusion) 또는 트리거 |
| 배타 서브타입 | 슈퍼타입의 `method` + CHECK 또는 트리거 |

---

## 10. 도구별 흔한 차이/주의점

- **Visio/Lucidchart/draw.io**: Crow’s Foot 기본. **옵셔널/필수 기호 배치** 옵션 확인.  
- **ERWin/PowerDesigner**: IE 주력. **(min,max)**가 **관계 양쪽에 별도 표기**됨.  
- **엑스포트 DDL** 시 **NULL/UNIQUE/IDENTITY/시퀀스** 자동화 여부, **소문자/대문자 인용** 규칙 확인.  
- **관계선 스타일(실선/점선)**이 **식별/비식별** 의미를 내포하는지 도구 설정을 문서화.

---

## 11. 실전 시나리오 1 — 옵션/필수의 SQL 구현

요구: “주문은 **반드시 고객**에 속한다(1:1 on 주문→고객 필수). 배송주소는 **선택**이다(0:1).”

Crow’s Foot:
```text
고객 |—< 주문
주소 ○— 주문  (주문은 주소 0..1)
```

SQL:
```sql
CREATE TABLE customer (
  customer_id BIGSERIAL PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name  TEXT NOT NULL
);

CREATE TABLE address (
  address_id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE CASCADE,
  line1 TEXT NOT NULL,
  city  TEXT NOT NULL
);

CREATE TABLE "order" (
  order_id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE RESTRICT,
  ship_to_address_id BIGINT NULL REFERENCES address(address_id) ON DELETE SET NULL,
  ordered_at timestamptz NOT NULL DEFAULT now()
);
```

검증 쿼리:
```sql
-- 고객 없는 주문(무결성 위반) 탐지: 존재하면 설계/데이터 문제
SELECT o.order_id
FROM "order" o
LEFT JOIN customer c ON c.customer_id = o.customer_id
WHERE c.customer_id IS NULL;
```

---

## 12. 실전 시나리오 2 — N:M을 조인 엔티티로

요구: “학생은 과목을 여러 개 수강, 과목도 여러 학생을 가진다. **재수강** 가능(시도번호).”

Crow’s Foot:
```text
학생 |—< 수강 >—| 과목
(수강: 조인 엔티티, attempt_no 포함)
```

SQL:
```sql
CREATE TABLE student (
  student_id BIGSERIAL PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE course (
  course_id BIGSERIAL PRIMARY KEY,
  title TEXT NOT NULL
);

CREATE TABLE enrollment (
  student_id BIGINT NOT NULL REFERENCES student(student_id),
  course_id  BIGINT NOT NULL REFERENCES course(course_id),
  attempt_no INT    NOT NULL DEFAULT 1,
  enroll_date date  NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('ENROLLED','DROPPED','COMPLETED')),
  PRIMARY KEY (student_id, course_id, attempt_no)
);
```

---

## 13. 재귀 트리의 구현 선택지 비교

| 모델 | 장점 | 단점 | SQL 예 |
|---|---|---|---|
| 인접 리스트(parent_id) | 단순 | 경로/서브트리 쿼리 복잡 | 위 `category` 예 |
| 경로 열(path text) | 경로 조회 쉬움 | 갱신 시 path 업데이트 필요 | `path LIKE '1/3/%'` |
| 중첩 집합(lft/rgt) | 서브트리 빠름 | 삽입/이동 비용 큼 | `BETWEEN` 범위 |
| 클로저 테이블 | 유연, 복수 루트/그래프 | 별도 테이블 관리 | `(ancestor,descendant)` |

---

## 14. Crow’s Foot/IE와 UML 클래스 다이어그램 매핑

| ERD 개념 | UML |
|---|---|
| 엔티티 | 클래스 |
| 속성 | 속성(필드) |
| 1:1 / 1:N / N:M | Association(1,*, 0..1 등) |
| 슈퍼/서브타입 | Generalization |
| 식별/비식별 | UML엔 직접 개념 없음(제약/스테레오타입으로 보조) |

> ERD→UML 전환 시 **식별성/키/제약**은 **UML의 OCL 제약** 혹은 **문서화**로 보강해야 한다.

---

## 15. 제약을 수학으로 점검하기(옵셔널/필수, 기간)

### 15.1 참여 제약(예: 주문-고객)
- 주문은 고객에 **필수 참여**:  
  $$ \forall o \in \text{Order},\ \exists! c \in \text{Customer}:\ o.customer\_id = c.id $$

### 15.2 기간 겹침 금지(배치/배정)
- 두 배정 구간 \([s_1,e_1), [s_2,e_2)\)가 **겹치지 않음**:  
  $$
  [s_1,e_1) \cap [s_2,e_2) = \emptyset
  \iff e_1 \le s_2 \ \lor\ e_2 \le s_1
  $$

---

## 16. 품질 점검 SQL(ERD→데이터 무결성 검사)

```sql
-- 1) FK 고아 데이터 검사(모든 관계에 대해 템플릿화)
SELECT o.order_id
FROM "order" o
LEFT JOIN customer c ON c.customer_id = o.customer_id
WHERE c.customer_id IS NULL;

-- 2) N:M 조인 엔티티 중복 검사(유니크 키 누락 여부)
SELECT student_id, course_id, attempt_no, COUNT(*) cnt
FROM enrollment
GROUP BY student_id, course_id, attempt_no
HAVING COUNT(*) > 1;

-- 3) 선택 관계에서 필수로 오염된 경우(예: 주소가 없는 줄 알았는데 NULL 허용 위반)
--   → NOT NULL 제약/데이터 입력 경로 점검
```

---

## 17. 표기·코드 동기화 체크리스트

- ERD의 **최소/최대 참여** ↔ **NOT NULL/UNIQUE**/조합키로 **정확히 반영**되었는가?  
- **식별/비식별** 관계가 **PK/복합PK/독립PK**로 일치하는가?  
- **N:M**는 **조인 엔티티**로 분해했고, **업무 속성**(등록일, 상태 등)을 포함했는가?  
- **옵셔널 관계**는 **NULL 허용/ON DELETE 정책**이 설계서와 동일한가?  
- **슈퍼/서브타입**의 **완전/배타** 제약이 CHECK/트리거/뷰로 강제되는가?

---

## 18. 팀 표준(Style Guide) 제안

- **표기법 통일**: 프로젝트 문서/도구 설정(예: Crow’s Foot 고정, IE는 별첨).  
- **범례 포함**: 다이어그램 상단에 기호 의미/샘플 표기.  
- **네이밍**: 단수형, 약어 최소화, FK 컬럼은 `<참조테이블>_id`.  
- **색상 레이어**: 기준/주/보조/조인/템포럴 등 엔티티 유형별 색상.  
- **DDL 자동화**: 도구의 **DDL Export** 규칙 문서화(컬럼 인용, 타입 매핑, NOT NULL/DEFAULT 표준).

---

## 19. 실습: 같은 모델을 두 표기법으로 그리고 SQL 내리기

### 19.1 과제 모델
- 고객—주문(1:N, 주문→고객 필수)  
- 주문—주문항목(1:N, 식별자 관계, PK=(order_id,line_no))  
- 주문항목—상품(N:1, 선택적)  
- 고객—주소(1:N, 주소는 고객에 필수, 고객당 기본주소 1개)  
- 결제(슈퍼타입) — 카드/계좌(서브타입, 배타)

Crow’s Foot(텍스트):
```text
고객 |—< 주문 |—< 주문항목 >—| 상품
고객 |—< 주소(기본주소 1개 제약은 UNIQUE 조건으로)
주문 |— 결제(슈퍼) — 카드결제/계좌결제(배타)
```

IE(문장):
- 고객—주문: (1,N)/(1,1), 주문—주문항목: (1,N)/(1,1), 주문항목—상품: (1,1)/(0,N)  
- 고객—주소: (1,N)/(1,1), 기본주소 1개는 `(customer_id WHERE is_default=true)` UNIQUE

SQL(핵심 부분):
```sql
CREATE TABLE customer (
  customer_id BIGSERIAL PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name  TEXT NOT NULL
);

CREATE TABLE address (
  address_id   BIGSERIAL PRIMARY KEY,
  customer_id  BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE CASCADE,
  line1 TEXT NOT NULL, city TEXT NOT NULL,
  is_default BOOLEAN NOT NULL DEFAULT FALSE
);
CREATE UNIQUE INDEX uq_customer_default_addr
  ON address(customer_id) WHERE is_default;

CREATE TABLE "order" (
  order_id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE RESTRICT,
  ordered_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE product (
  product_id BIGSERIAL PRIMARY KEY,
  sku TEXT NOT NULL UNIQUE, name TEXT NOT NULL, price NUMERIC(12,2) NOT NULL CHECK (price >= 0)
);

CREATE TABLE order_item (
  order_id   BIGINT NOT NULL REFERENCES "order"(order_id) ON DELETE CASCADE,
  line_no    INT    NOT NULL,
  product_id BIGINT REFERENCES product(product_id) ON DELETE SET NULL,
  qty        INT    NOT NULL CHECK (qty > 0),
  price_at   NUMERIC(12,2) NOT NULL CHECK (price_at >= 0),
  PRIMARY KEY (order_id, line_no)
);

CREATE TABLE payment (
  payment_id BIGSERIAL PRIMARY KEY,
  order_id   BIGINT NOT NULL UNIQUE REFERENCES "order"(order_id) ON DELETE CASCADE,
  amount     NUMERIC(12,2) NOT NULL,
  paid_at    timestamptz   NOT NULL,
  method     TEXT NOT NULL CHECK (method IN ('CARD','BANK'))
);

CREATE TABLE card_payment (
  payment_id BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  card_no_hash TEXT NOT NULL,
  auth_code    TEXT NOT NULL
);

CREATE TABLE bank_payment (
  payment_id BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  bank_code TEXT NOT NULL,
  account_no TEXT NOT NULL
);
```

검증 쿼리:
```sql
-- 기본주소 1개 제약 검증
SELECT customer_id
FROM address
WHERE is_default
GROUP BY customer_id
HAVING COUNT(*) > 1;

-- 주문 고아 탐지
SELECT o.order_id
FROM "order" o LEFT JOIN customer c USING (customer_id)
WHERE c.customer_id IS NULL;

-- 주문항목 라인번호 중복
SELECT order_id, line_no, COUNT(*) cnt
FROM order_item
GROUP BY order_id, line_no
HAVING COUNT(*) > 1;
```

---

## 20. 결론

- **Crow’s Foot**은 직관적·시각적으로 **관계의 최소/최대 참여**를 빠르게 전달한다.  
- **IE**는 **정밀한 수치 표기**로 **요구사항의 엄밀성**을 보완한다.  
- 어떤 표기든 **제약을 DDL/운영 규칙으로 일관 반영**해야 모델이 살아 움직인다.  
- 팀에서는 **표기법·네이밍·DDL Export 규칙**을 **표준화**하고, **ERD↔DDL 동기화**를 자동화하여 품질을 유지하라.