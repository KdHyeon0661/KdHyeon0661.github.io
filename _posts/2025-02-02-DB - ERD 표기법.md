---
layout: post
title: DB - ERD 표기법
date: 2025-02-02 19:20:23 +0900
category: DB
---
# ERD 표기법 (Crow’s Foot, IE Notation)

## 리마인드: 핵심 개념 요약

- **ERD**(Entity Relationship Diagram)는 **엔티티(사각형), 관계(선), 속성(필드)**와 함께 **카디널리티와 옵셔널리티**를 명시하는 **논리적 데이터 모델링** 도구입니다.
- **Crow’s Foot Notation**: `○`(0), `|`(1), `—`(1), `<`(N)의 조합으로 **최소 및 최대 참여 수**를 직관적으로 표현합니다.
- **IE Notation**(Information Engineering): **(최소, 최대)** 형태의 수치 쌍으로 참여 수를 정확히 표현합니다.
- 데이터베이스 설계는 일반적으로 **개념적 → 논리적 → 물리적** 모델의 흐름을 따르며, ERD에 표현된 제약은 최종적으로 **기본키, 외래키, 유니크 제약, 체크 제약, 트리거** 등으로 구현되어야 합니다.

---

## Crow’s Foot Notation: 기호와 의미의 상세 해석

### 기본 기호 (최소 및 최대 참여 수 표현)

- **최소(Minimum) 참여 수**: `○` = 0 (선택적), `|` = 1 (필수적)
- **최대(Maximum) 참여 수**: `—` = 1 (단일), `<` = N (다수)

### 조합 표 (관계선 한쪽 끝의 의미)

| 표기 | 의미 | 해석 (참여 수 범위) |
| :--- | :--- | :--- |
| `○—` | 0..1 | 선택적 단일 (없거나 하나) |
| `|—` | 1..1 | 필수적 단일 (정확히 하나) |
| `○<` | 0..N | 선택적 다수 (없거나 여러 개) |
| `|<` | 1..N | 필수적 다수 (하나 이상 여러 개) |

> **주의**: 관계선의 **양쪽 끝**에 각각 기호가 배치됩니다. 각 끝의 표기는 **반대쪽 엔티티**에 대한 참여 수를 의미합니다. 도구나 문서에 따라 해석 관행이 다를 수 있으므로, 명확한 예시와 함께 설명하는 것이 좋습니다.

### 예시: 고객과 주문 (1:N, 주문은 반드시 고객에 속함)

```text
고객 |—< 주문
```

- **고객 측에서 주문을 바라볼 때**: `|<` 기호는 **한 명의 고객**이 **여러 개의 주문**(최소 1개, 최대 N개)을 가질 수 있음을 의미합니다.
- **주문 측에서 고객을 바라볼 때**: `|—` 기호는 **하나의 주문**이 **정확히 한 명의 고객**에 반드시 속해야 함(0건 불가)을 의미합니다.

### IE 표기법으로 동등하게 표현
- 고객 — 주문 관계에서: 고객 측의 주문 참여 수는 (1, N), 주문 측의 고객 참여 수는 (1, 1)입니다.

---

## IE Notation: (최소, 최대)의 정밀한 표현

- 표기 형식: **(최소 참여 수, 최대 참여 수)**
- 일반적인 값: `(0,1)`, `(1,1)`, `(0,N)`, `(1,N)`

### 예시: 직원과 부서

- **요구사항**: "한 명의 직원은 반드시 하나의 부서에 소속된다. 하나의 부서에는 0명 이상의 직원이 소속될 수 있다."
- **IE 표기**:
    - `직원 —(1,1)— 부서` (직원 측에서 부서 참여)
    - `부서 —(0,N)— 직원` (부서 측에서 직원 참여)
- **Crow’s Foot 표기**: `부서 ○< 직원` & `직원 |— 부서`

---

## Crow’s Foot와 IE 표기법 변환 규칙

| Crow’s Foot | IE (min, max) | 설명 |
| :--- | :--- | :--- |
| `○—` | (0, 1) | 선택적 단일 관계 |
| `|—` | (1, 1) | 필수적 단일 관계 |
| `○<` | (0, N) | 선택적 다수 관계 |
| `|<` | (1, N) | 필수적 다수 관계 |

> 변환 시 핵심은 관계의 방향보다 **각 관계선 끝이 나타내는 참여 수의 의미**를 정확히 이해하는 것입니다. 사용하는 도구에 따라 선과 기호의 배치 방식이 다를 수 있으므로, 문서에 예시를 포함하여 오해를 방지하는 것이 중요합니다.

---

## 식별 관계와 비식별 관계의 표기 및 구현

- **식별 관계**: **부모 테이블의 기본키가 자식 테이블의 기본키의 일부가 되는 관계**입니다. 이는 자식이 부모 없이는 독립적으로 존재할 수 없는 '약한 엔터티'를 의미합니다. Crow’s Foot 도구들에서는 종종 **굵은 실선**으로 표기합니다.
- **비식별 관계**: 자식 테이블이 **독립적인 기본키**를 가지며, 부모 테이블의 기본키는 자식 테이블의 **일반 외래키**로만 존재하는 관계입니다. 이는 **점선**으로 표기하는 경우가 많습니다.

### 예시: 주문과 주문항목 (식별 관계)

**Crow’s Foot 개념 모델**:
```text
주문 |—< 주문항목
```
*(주문항목의 기본키는 주문의 기본키를 포함합니다: PK = (OrderID, LineNo))*

**물리적 SQL 구현**:
```sql
CREATE TABLE "order" (
  order_id   BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE RESTRICT,
  ordered_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE order_item (
  order_id BIGINT NOT NULL,
  line_no  INT    NOT NULL,
  product_id BIGINT NOT NULL REFERENCES product(product_id),
  qty      INT    NOT NULL CHECK (qty > 0),
  price_at NUMERIC(12,2) NOT NULL CHECK (price_at >= 0),
  PRIMARY KEY (order_id, line_no), -- 복합 PK에 부모 PK(order_id) 포함
  FOREIGN KEY (order_id) REFERENCES "order"(order_id) ON DELETE CASCADE
);
```

### 예시: 주문과 결제 (비식별 관계)

결제는 독립적인 기본키를 가지며, 주문을 참조하는 외래키를 가집니다.

```sql
CREATE TABLE payment (
  payment_id BIGSERIAL PRIMARY KEY, -- 독립적인 PK
  order_id   BIGINT NOT NULL UNIQUE REFERENCES "order"(order_id) ON DELETE CASCADE, -- FK
  amount     NUMERIC(12,2) NOT NULL,
  paid_at    timestamptz NOT NULL
);
```

---

## 재귀 관계의 표기 (예: 카테고리 트리)

**Crow’s Foot**:
```text
카테고리  ○—<  카테고리
```
*(하나의 부모 카테고리는 여러 자식 카테고리를 가질 수 있으며, 부모는 선택적입니다.)*

**IE 표기**:
- 부모 카테고리 측에서 자식 카테고리 참여: `(0, N)`
- 자식 카테고리 측에서 부모 카테고리 참여: `(0, 1)` (루트 허용) 또는 `(1, 1)` (루트 불허, 모든 카테고리는 부모가 있어야 함)

**SQL 구현**:
```sql
CREATE TABLE category (
  category_id BIGSERIAL PRIMARY KEY,
  name        text NOT NULL,
  parent_id   BIGINT REFERENCES category(category_id) ON DELETE SET NULL -- 선택적 참조
);
```

---

## N:M 관계와 조인 테이블(엔터티)로의 분해

### 삼항 관계의 예: 의사-환자-진료일

개념적으로 삼항 관계로 그릴 수 있으나, 대부분 **조인 엔터티(진료)**를 도입하여 여러 개의 이항 관계로 분해하는 것이 실용적입니다.

**개념 모델 (조인 엔터티 사용)**:
```text
[진료] 엔티티 = (의사, 환자, 진료일) + 속성(진단코드, 처치내용)
의사 |—< 진료 >—| 환자
진료 —|— 진료일
```

**SQL 구현**:
```sql
CREATE TABLE visit (
  doctor_id BIGINT NOT NULL REFERENCES doctor(doctor_id),
  patient_id BIGINT NOT NULL REFERENCES patient(patient_id),
  visit_date date NOT NULL,
  diagnosis_code text,
  treatment text,
  PRIMARY KEY (doctor_id, patient_id, visit_date) -- 세 요소의 조합이 유일함
);
```

> **중요**: 삼항 관계를 단순히 두 개의 이항 관계로 분해하면, 원치 않는 조합(예: 동일 의사-환자 조합에 대한 여러 진료일 기록)이 허용될 수 있습니다. 업무 규칙이 세 엔터티의 동시 조합에 의존한다면, 조인 엔터티를 사용하고 복합 키로 제약을 구현하는 것이 안전합니다.

---

## 슈퍼타입/서브타입 관계의 표기

Crow’s Foot와 IE 모두 하나의 슈퍼타입에서 여러 서브타입으로의 분기를 표현할 수 있습니다. 이때 **완전성**(모든 슈퍼타입 인스턴스가 서브타입에 속하는지)과 **상호 배타성**(서브타입 간 중복이 허용되는지)을 고려해야 합니다.

### 예시: 결제 (카드결제, 계좌이체)

**개념 모델 (완전且상호배타 가정)**:
```text
       [결제] (슈퍼타입)
          / \
         /   \
[카드결제] [계좌결제] (서브타입)
```

**SQL 구현 (클래스별 테이블 방식)**:
```sql
-- 슈퍼타입 테이블
CREATE TABLE payment (
  payment_id BIGSERIAL PRIMARY KEY,
  order_id   BIGINT NOT NULL UNIQUE REFERENCES "order"(order_id) ON DELETE CASCADE,
  amount     NUMERIC(12,2) NOT NULL,
  paid_at    timestamptz NOT NULL,
  method     text NOT NULL CHECK (method IN ('CARD','BANK')) -- 배타성 및 완전성 구분자
);

-- 서브타입 테이블들
CREATE TABLE card_payment (
  payment_id  BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  card_no_hash text NOT NULL,
  auth_code    text NOT NULL
);

CREATE TABLE bank_payment (
  payment_id BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  bank_code  text NOT NULL,
  account_no text NOT NULL
);
```

> 일부 모델링 도구는 UML의 일반화(Generalization) 표기를 따릅니다. Crow’s Foot와 IE를 혼용할 때는 범례를 명시하여 의사소통 오류를 방지하세요.

---

## Crow’s Foot와 IE로 동일 모델 표현하기 (종합 예제)

### 도메인: 간단한 전자상거래 시스템

**Crow’s Foot (텍스트 다이어그램)**:
```text
고객 |—< 주문 |—< 주문항목 >—| 상품
고객 ○—< 주소
주문 |— 결제
    |— (슈퍼타입) ── 카드결제
        └── 계좌결제
```

**IE 표기 (문장 설명)**:
- 고객 — 주문: 고객 (1,N) 주문, 주문 (1,1) 고객
- 주문 — 주문항목: 주문 (1,N) 주문항목, 주문항목 (1,1) 주문
- 주문항목 — 상품: 주문항목 (1,1) 상품, 상품 (0,N) 주문항목
- 고객 — 주소: 고객 (0,N) 주소, 주소 (1,1) 고객
- 주문 — 결제(슈퍼타입): 주문 (0,1) 결제, 결제 (1,1) 주문
- 결제 — 서브타입: 결제 (0,1) 각 서브타입, 서브타입 (1,1) 결제

---

## 논리적 표기에서 물리적 구현으로의 매핑 규칙

| 논리 모델의 제약 | 물리적 DDL 매핑 |
| :--- | :--- |
| **1:1 관계 (필수/선택)** | 외래키 + `UNIQUE` 제약 (또는 PK 공유) + `NOT NULL`/`NULL` 허용 |
| **1:N 관계** | `N`쪽 테이블에 외래키 정의 (필수 관계면 `NOT NULL`, 선택이면 `NULL`) |
| **N:M 관계** | 조인 테이블 생성 + 외래키 조합에 `PRIMARY KEY` 또는 `UNIQUE` 제약 |
| **식별 관계** | 자식 테이블의 기본키에 부모 테이블의 기본키를 포함 (복합 기본키) |
| **비식별 관계** | 자식 테이블은 독립 기본키 + 부모 테이블을 참조하는 외래키 |
| **필수 참여 (최소=1)** | 외래키 컬럼 `NOT NULL` + 적절한 `ON DELETE` 정책 (예: `RESTRICT`) |
| **선택 참여 (최소=0)** | 외래키 컬럼 `NULL` 허용 + 적절한 `ON DELETE` 정책 (예: `SET NULL`) |
| **기간 겹침 불가** | `CHECK` 제약, 배타 제약(Exclusion Constraint), 또는 트리거로 구현 |
| **상호 배타적 서브타입** | 슈퍼타입 테이블에 구분자 컬럼 + `CHECK` 제약 또는 트리거 |

---

## 모델링 도구별 차이점과 주의사항

- **Visio, Lucidchart, draw.io**: Crow’s Foot 표기법을 기본으로 지원하는 경우가 많습니다. **옵셔널/필수 기호의 배치 방향**에 대한 설정을 확인하세요.
- **ERWin, SAP PowerDesigner**: IE 표기법을 주력으로 합니다. **(min, max)** 표기가 **관계선의 양쪽 끝에 별도로 표시**됩니다.
- **DDL 내보내기 기능**: 도구가 SQL 스크립트를 생성할 때 `NULL`/`NOT NULL`, `UNIQUE`, 자동 증가 속성(`IDENTITY`/`SERIAL`), 인용 부호 규칙 등을 어떻게 처리하는지 반드시 확인하고 문서화하세요.
- **관계선 스타일**: 실선/점선이 **식별/비식별 관계**를 의미하는지 도구별 설정을 이해하고, 프로젝트 문서에 명시하세요.

---

## 실전 시나리오 1: 필수 및 선택 관계의 SQL 구현

**요구사항**:
1. "주문은 **반드시 한 명의 고객**에 속해야 한다." (1:N, 주문 → 고객 필수)
2. "주문은 **배송 주소를 가질 수도 있고, 아닐 수도 있다.**" (0:1 관계)

**Crow’s Foot 표기**:
```text
고객 |—< 주문
주소 ○— 주문  (주문은 주소 0..1)
```

**SQL 구현**:
```sql
-- 부모 테이블들
CREATE TABLE customer (
  customer_id BIGSERIAL PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name  TEXT NOT NULL
);

CREATE TABLE address (
  address_id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE CASCADE,
  line1 TEXT NOT NULL,
  city  TEXT NOT NULL
);

-- 자식 테이블 (주문)
CREATE TABLE "order" (
  order_id BIGSERIAL PRIMARY KEY,
  -- 필수 관계: NOT NULL
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE RESTRICT,
  -- 선택 관계: NULL 허용
  ship_to_address_id BIGINT NULL REFERENCES address(address_id) ON DELETE SET NULL,
  ordered_at timestamptz NOT NULL DEFAULT now()
);
```

**데이터 무결성 검증 쿼리**:
```sql
-- 고객 없는 주문이 존재하는지 확인 (존재하면 설계 또는 데이터 문제)
SELECT o.order_id
FROM "order" o
LEFT JOIN customer c ON c.customer_id = o.customer_id
WHERE c.customer_id IS NULL;
```

---

## 실전 시나리오 2: N:M 관계와 조인 엔티티의 고급 활용

**요구사항**: "학생은 여러 과목을 수강할 수 있고, 과목도 여러 학생을 가질 수 있다(N:M). 또한, **재수강이 가능**하며(동일 학생-과목 조합이 여러 번 발생), 각 수강 시도에는 상태 정보가 있다."

**Crow’s Foot 표기 (조인 엔터티 '수강' 사용)**:
```text
학생 |—< 수강 >—| 과목
(수강은 조인 엔티티이며, attempt_no(시도번호) 속성을 포함)
```

**SQL 구현**:
```sql
CREATE TABLE student (
  student_id BIGSERIAL PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE course (
  course_id BIGSERIAL PRIMARY KEY,
  title TEXT NOT NULL
);

-- 조인 엔티티 (실제 비즈니스 의미를 가짐)
CREATE TABLE enrollment (
  student_id BIGINT NOT NULL REFERENCES student(student_id),
  course_id  BIGINT NOT NULL REFERENCES course(course_id),
  attempt_no INT    NOT NULL DEFAULT 1, -- 재수강 구분
  enroll_date date  NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('ENROLLED','DROPPED','COMPLETED')),
  PRIMARY KEY (student_id, course_id, attempt_no) -- 시도번호까지 포함한 복합키
);
```

---

## 재귀적 계층 구조 모델링 방식 비교

| 모델 방식 | 장점 | 단점 | SQL 쿼리 예시 |
| :--- | :--- | :--- | :--- |
| **인접 리스트** <br> (부모ID) | 구조 단순, 삽입/이동 쉬움 | 계층 조회(특히 하위 전체) 시 재귀 또는 여러 번의 조인 필요 | `WITH RECURSIVE` 구문 사용 |
| **경로 열** <br> (전체 경로 문자열) | 특정 노드의 모든 조상/자손 조회가 빠름 | 경로 업데이트 비용, 경로 길이 제한 | `WHERE path LIKE '1/3/%'` |
| **중첩 집합** <br> (좌/우 값) | 서브트리 조회 매우 빠름 | 노드 삽입, 삭제, 이동 시 대량 업데이트 필요 | `WHERE lft BETWEEN ? AND ?` |
| **클로저 테이블** <br> (조상-자손 관계 테이블) | 매우 유연, 다중 부모/그래프 지원 | 별도 테이블 관리, 관계 삽입/삭제 시 추가 작업 | `JOIN closure_tree` |

---

## ERD와 UML 클래스 다이어그램의 개념 매핑

| ERD 개념 | UML 클래스 다이어그램에서의 대응 |
| :--- | :--- |
| 엔티티(Entity) | 클래스(Class) |
| 속성(Attribute) | 속성(Attribute) 또는 필드(Field) |
| 관계(Relationship) <br> (1:1, 1:N, N:M) | 연관(Association) <br> (다중성: 1, *, 0..1 등으로 표현) |
| 슈퍼타입/서브타입 | 일반화(Generalization) |
| 식별/비식별 관계 | UML에는 직접 대응 개념 없음. <br> 제약 조건(Constraint)이나 스테레오타입(Stereotype)으로 보완 가능. |

> ERD에서 UML로 변환할 때는 **식별자, 키 제약, 참조 무결성 규칙**과 같은 상세 사항이 손실될 수 있습니다. 이를 **OCL(객체 제약 언어) 제약**이나 별도의 문서로 보강해야 합니다.

---

## 데이터 품질 검증을 위한 진단 SQL

ERD에 표현된 관계적 제약이 실제 데이터에서 지켜지고 있는지 주기적으로 점검하는 것이 좋습니다.

```sql
-- 1) 외래키 고아 데이터 검사 (일반적인 패턴)
-- [자식테이블]에 존재하는 [FK]가 [부모테이블]의 [PK]에 없는 경우 탐지
SELECT o.order_id
FROM "order" o
LEFT JOIN customer c ON c.customer_id = o.customer_id
WHERE c.customer_id IS NULL;

-- 2) N:M 조인 테이블의 유일성 제약 위반 탐지
-- 기본키나 유니크 제약이 누락되어 중복 연결이 발생했는지 확인
SELECT student_id, course_id, attempt_no, COUNT(*) as duplicate_count
FROM enrollment
GROUP BY student_id, course_id, attempt_no
HAVING COUNT(*) > 1;

-- 3) 선택적 관계(NULL 허용) 컬럼에 대한 비즈니스 규칙 검증
-- 예: 'ship_to_address_id'가 NULL이면 안 되는 특정 주문 상태가 있는지 확인
SELECT order_id, status, ship_to_address_id
FROM "order"
WHERE status = 'SHIPPED' AND ship_to_address_id IS NULL;
```

---

## 실습 과제: 표기법 적용 및 DDL 생성

### 모델 요구사항
1.  고객과 주문은 1:N 관계. 주문은 반드시 고객에 속함.
2.  주문과 주문항목은 1:N **식별 관계**. 주문항목의 PK는 `(order_id, line_no)`.
3.  주문항목과 상품은 N:1 관계. 주문항목은 상품을 참조하되, 상품 삭제 시 `NULL`로 설정 가능(선택적).
4.  고객과 주소는 1:N 관계. 주소는 반드시 고객에 속함. 한 고객당 **하나의 '기본 주소'** 만 존재할 수 있음.
5.  결제는 슈퍼타입. 카드결제와 계좌결제는 서브타입이며, 상호 배타적 관계.

**Crow’s Foot 텍스트 모델**:
```text
고객 |—< 주문 |—< 주문항목 >—| 상품
고객 |—< 주소
주문 |— 결제(슈퍼) — 카드결제/계좌결제(배타)
```

**핵심 SQL DDL 구현**:
```sql
-- 1. 기본 엔티티
CREATE TABLE customer (
  customer_id BIGSERIAL PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name  TEXT NOT NULL
);

-- 2. 주소 (고객에 필수 속함, 기본 주소 제약)
CREATE TABLE address (
  address_id   BIGSERIAL PRIMARY KEY,
  customer_id  BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE CASCADE,
  line1 TEXT NOT NULL,
  city TEXT NOT NULL,
  is_default BOOLEAN NOT NULL DEFAULT FALSE
);
-- 고객별 기본 주소는 하나만 존재하도록 부분 유니크 인덱스
CREATE UNIQUE INDEX uq_customer_default_addr ON address(customer_id) WHERE is_default;

-- 3. 주문 (고객에 필수 속함)
CREATE TABLE "order" (
  order_id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE RESTRICT,
  ordered_at timestamptz NOT NULL DEFAULT now()
);

-- 4. 상품
CREATE TABLE product (
  product_id BIGSERIAL PRIMARY KEY,
  sku TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  price NUMERIC(12,2) NOT NULL CHECK (price >= 0)
);

-- 5. 주문항목 (주문과 식별 관계, 상품과 선택적 관계)
CREATE TABLE order_item (
  order_id   BIGINT NOT NULL REFERENCES "order"(order_id) ON DELETE CASCADE,
  line_no    INT    NOT NULL,
  product_id BIGINT NULL REFERENCES product(product_id) ON DELETE SET NULL,
  qty        INT    NOT NULL CHECK (qty > 0),
  price_at   NUMERIC(12,2) NOT NULL CHECK (price_at >= 0),
  PRIMARY KEY (order_id, line_no) -- 복합 PK (식별 관계)
);

-- 6. 결제 슈퍼타입 및 서브타입
CREATE TABLE payment (
  payment_id BIGSERIAL PRIMARY KEY,
  order_id   BIGINT NOT NULL UNIQUE REFERENCES "order"(order_id) ON DELETE CASCADE,
  amount     NUMERIC(12,2) NOT NULL,
  paid_at    timestamptz   NOT NULL,
  method     TEXT NOT NULL CHECK (method IN ('CARD','BANK')) -- 배타성 구분자
);

CREATE TABLE card_payment (
  payment_id BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  card_no_hash TEXT NOT NULL,
  auth_code    TEXT NOT NULL
);

CREATE TABLE bank_payment (
  payment_id BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  bank_code TEXT NOT NULL,
  account_no TEXT NOT NULL
);
```

**검증 쿼리**:
```sql
-- 기본 주소 제약 검증
SELECT customer_id
FROM address
WHERE is_default
GROUP BY customer_id
HAVING COUNT(*) > 1;

-- 고아 주문 탐지
SELECT o.order_id
FROM "order" o
LEFT JOIN customer c ON c.customer_id = o.customer_id
WHERE c.customer_id IS NULL;

-- 주문항목 라인번호 중복 검사 (PK 위반 탐지)
SELECT order_id, line_no, COUNT(*) as cnt
FROM order_item
GROUP BY order_id, line_no
HAVING COUNT(*) > 1;
```

---

## 결론: 효과적인 ERD 활용을 위한 원칙

ERD는 단순한 그림을 넘어, 시스템의 데이터 구조에 대한 공통 이해를 형성하고, 최종 데이터베이스 스키마의 청사진 역할을 하는 중요한 설계 산출물입니다.

1.  **표기법의 일관된 사용**: 프로젝트 내에서 하나의 표기법(예: Crow’s Foot)을 표준으로 정하고, 필요 시 IE 표기법을 보조적으로 활용하세요. 모든 다이어그램에 **범례**를 포함시키는 것이 필수입니다.
2.  **의미의 명확한 전달**: 관계선의 각 끝이 무엇을 의미하는지(예: "이쪽에서 본 저쪽의 참여 수")를 텍스트로 보충 설명하면 오해를 크게 줄일 수 있습니다.
3.  **논리적 모델과 물리적 구현의 연결 고리**: ERD에 표현된 모든 제약(카디널리티, 옵셔널리티, 식별성)이 DDL 문에서 어떻게 구현되는지 매핑 규칙을 명확히 하세요. 이는 설계의 정확성을 검증하는 기준이 됩니다.
4.  **도구의 특성을 이해하고 문서화하라**: 사용하는 모델링 도구가 DDL을 생성하는 방식을 이해하고, 생성된 스크립트를 검토하는 과정을 거쳐야 합니다. 네이밍 규칙, 인용 부호 사용, 제약 조건 생성 방식 등을 프로젝트 표준으로 정리하세요.
5.  **지속적인 검증과 동기화**: ERD는 한 번 그리고 끝나는 문서가 아닙니다. 데이터베이스 스키마가 변경될 때마다 ERD를 업데이트하고, 앞서 소개한 진단 SQL을 이용해 모델과 실제 데이터의 무결성을 주기적으로 점검하세요.

궁극적으로 훌륭한 ERD는 복잡한 비즈니스 규칙을 시각적으로 단순화하여 이해를 돕고, 개발자, DBA, 비즈니스 분석가 간의 원활한 소통을 가능하게 하는 강력한 도구입니다.