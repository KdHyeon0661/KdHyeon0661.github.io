---
layout: post
title: ì˜ìƒì²˜ë¦¬ - JPEG ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©
date: 2025-10-09 18:25:23 +0900
category: ì˜ìƒì²˜ë¦¬
---
# A.1 | **JPEG ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©**

---

## JPEG ì••ì¶• ì›ë¦¬ (Baseline/Progressive ê°œìš”)

### íŒŒì´í”„ë¼ì¸ í° ê·¸ë¦¼

1) **ìƒ‰ ê³µê°„ ë³€í™˜**: RGB â†’ YCbCr (ë°ê¸° Y, ìƒ‰ì°¨ Cb/Cr)
2) **í¬ë¡œë§ˆ ì„œë¸Œìƒ˜í”Œë§**: ë³´í†µ **4:2:0 / 4:2:2 / 4:4:4**
3) **ë¸”ë¡í™”**: 8Ã—8 ë¸”ë¡ìœ¼ë¡œ ë¶„í•  (MCU ë‹¨ìœ„ë¡œ íŒ¨í‚¹)
4) **DCT(ì´ì‚° ì½”ì‚¬ì¸ ë³€í™˜)**: ê° 8Ã—8 ë¸”ë¡ì„ ì£¼íŒŒìˆ˜ ì˜ì—­ ê³„ìˆ˜ë¡œ ë³€í™˜
5) **ì–‘ìí™”(Quantization)**: ê°€ì‹œì„± ë‚®ì€ ê³ ì£¼íŒŒë¥¼ í¬ê²Œ ë‚˜ëˆ  0ìœ¼ë¡œ ë§Œë“¦ â†’ ì†ì‹¤
6) **ì§€ê·¸ì¬ê·¸/ëŸ°ë ìŠ¤ + í—ˆí”„ë§Œ ë¶€í˜¸í™”**: 0ì´ ì´ì–´ì§€ëŠ” ê³„ìˆ˜ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì••ì¶•
7) (ì§„í–‰í˜• JPEGëŠ” ì£¼íŒŒìˆ˜ ëŒ€ì—­ì„ ì—¬ëŸ¬ ìŠ¤ìº”ìœ¼ë¡œ ë‚˜ëˆ  ì „ì†¡)

**DCT ì •ì˜(8Ã—8):**
\[
X_{uv} = \frac{1}{4} \, C(u)C(v)\sum_{x=0}^{7}\sum_{y=0}^{7}
f_{xy} \cos\!\left(\frac{(2x+1)u\pi}{16}\right)\cos\!\left(\frac{(2y+1)v\pi}{16}\right)
\]
ì—¬ê¸°ì„œ \(C(0)=\frac{1}{\sqrt{2}},\; C(k)=1 \ (k>0)\), \(f_{xy}\) ëŠ” ì…ë ¥(í‰ê·  \(128\) ì˜¤í”„ì…‹ ë³´ì • í¬í•¨).

**ì–‘ìí™”:**
\[
\hat{X}_{uv} = \operatorname{round}\!\left(\frac{X_{uv}}{Q_{uv}}\right),\quad
X_{uv}\approx \hat{X}_{uv}\cdot Q_{uv}
\]
í’ˆì§ˆ(quality) íŒŒë¼ë¯¸í„°ê°€ ì»¤ì§ˆìˆ˜ë¡ \(Q\) ìš”ì†Œê°€ ì‘ì•„ì ¸ ì†ì‹¤â†“, ìš©ëŸ‰â†‘.

### YCbCr ë³€í™˜ (Rec.601, full-range ê·¼ì‚¬)

\[
\begin{aligned}
Y   &=  0.299R + 0.587G + 0.114B \\
Cb  &= -0.169R - 0.331G + 0.500B + 128 \\
Cr  &=  0.500R - 0.419G - 0.081B + 128
\end{aligned}
\]
ì‹¤ì œ libjpegëŠ” ë‚´ë¶€ì—ì„œ ìƒ‰ ê³µê°„/ì„œë¸Œìƒ˜í”Œë§ì„ ìë™ ì²˜ë¦¬í•  ìˆ˜ ìˆìŒ.

### ì„œë¸Œìƒ˜í”Œë§ & MCU

- **4:4:4**: Y/Cb/Cr ëª¨ë‘ í”½ì…€ 1:1
- **4:2:2**: ìˆ˜í‰ìœ¼ë¡œ Cb/Cr ì ˆë°˜
- **4:2:0**: ê°€ë¡œ/ì„¸ë¡œ ëª¨ë‘ ì ˆë°˜ â†’ **ê°€ì¥ í”í•¨**
- MCU(Minimum Coded Unit): 4:2:0ì´ë©´ Y 16Ã—16 ë¸”ë¡(8Ã—8 Ã— 4ê°œ) + Cb/Cr ê° 8Ã—8 Ã— 1ê°œ

### í—ˆí”„ë§Œ ë¶€í˜¸í™” & ë¦¬ìŠ¤íƒ€íŠ¸ ë§ˆì»¤

- ê³„ìˆ˜ ì§€ê·¸ì¬ê·¸ â†’ **DC ì°¨ë¶„ ë¶€í˜¸í™”** + **AC RLE**
- **DHT/DQT/SOF0/SOS** ë“± ë§ˆì»¤ë¡œ í—¤ë” êµ¬ì„±, ëŒ€ê°œ **JFIF/EXIF** APP ë§ˆì»¤ í¬í•¨
- ë¦¬ìŠ¤íƒ€íŠ¸ ë§ˆì»¤(DRI/DRn)ë¡œ **ë™ê¸° ë³µêµ¬** ìš©ì´(ìŠ¤íŠ¸ë¦¼ ì†ìƒ ëŒ€ì‘)

### ë² ì´ìŠ¤ë¼ì¸ vs í”„ë¡œê·¸ë ˆì‹œë¸Œ

- **Baseline**: í•œ ë²ˆì˜ ìŠ¤ìº”, ë””ì½”ë” í˜¸í™˜ì„± ìµœê³ 
- **Progressive**: ì €ì£¼íŒŒâ†’ê³ ì£¼íŒŒë¡œ ì—¬ëŸ¬ ìŠ¤ìº”, ì‹œê°ì  ì„ ëª…ë„ ì ì§„ í–¥ìƒ(ì›¹ ì‹œëŒ€ì—” ëœ ì¤‘ìš”)

---

## JPEG ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¹Œë“œí•˜ê¸° (Windows)

### ë¬´ì—‡ì„ ì“¸ê¹Œ?

- **libjpeg-turbo (ê¶Œì¥)**: SIMD(DCT/ìƒ‰ë³€í™˜)ë¡œ **2~6Ã— ë¹ ë¦„**. APIëŠ” IJG libjpegê³¼ **í˜¸í™˜**.
- **IJG libjpeg**: ë ˆí¼ëŸ°ìŠ¤. ì†ë„ëŠ” turbo ëŒ€ë¹„ ë‚®ìŒ.

### vcpkgë¡œ ì†ì‰½ê²Œ ì„¤ì¹˜ (VS2022)

```powershell
# vcpkg ì„¤ì¹˜/ì—°ë™(ìµœì´ˆ 1íšŒ)

git clone https://github.com/microsoft/vcpkg
.\vcpkg\bootstrap-vcpkg.bat
.\vcpkg\vcpkg integrate install

# x64-windows tripletë¡œ ì„¤ì¹˜

.\vcpkg\vcpkg install libjpeg-turbo:x64-windows
```
- ì´í›„ Visual Studioì—ì„œ **vcpkg ì‚¬ìš©ì í†µí•©**ì´ ì¼œì ¸ ìˆìœ¼ë©´ ìë™ ë§í‚¹.
- CMakeë¥¼ ì“°ë©´:
```cmake
# CMakeLists.txt

cmake_minimum_required(VERSION 3.25)
project(ImageToolJPEG CXX)

find_package(JPEG REQUIRED) # vcpkgê°€ JPEG::JPEG íƒ€ê²Ÿ ì œê³µ
add_executable(app main.cpp JpegUtil.cpp)
target_link_libraries(app PRIVATE JPEG::JPEG)
```

### í”„ë¡œì íŠ¸ ì„¤ì •

- **C/C++ â†’ ì¶”ê°€ í¬í•¨ ë””ë ‰í„°ë¦¬**: `...\vcpkg\installed\x64-windows\include`
- **ë§ì»¤ â†’ ì¶”ê°€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë””ë ‰í„°ë¦¬**: `...\vcpkg\installed\x64-windows\lib`
- **ì¶”ê°€ ì¢…ì†ì„±**: `jpeg.lib` (libjpeg-turbo), í•„ìš”ì‹œ `turbojpeg.lib`(ê³ ìˆ˜ì¤€ API)
- ëŸ°íƒ€ì„ DLL ë°°í¬ ì‹œ `jpeg62.dll`(ë˜ëŠ” `jpeg-turbo` DLL) í¬í•¨ ì—¬ë¶€ í™•ì¸

---

## JPEG ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©í•˜ê¸° (C API; `jpeglib.h`)

> ì•„ë˜ ì˜ˆì œëŠ” **libjpeg-turbo & IJG** ëª¨ë‘ì—ì„œ ë™ì‘í•˜ëŠ” **í‘œì¤€ jpeglib API** ê¸°ì¤€.
> (turbo ì „ìš© í™•ì¥ì¸ `JCS_EXT_BGRA` ëŠ” ë’¤ì—ì„œ ì˜µì…˜ìœ¼ë¡œ ì†Œê°œ)

### ê³µí†µ: ì—ëŸ¬ í•¸ë“¤ëŸ¬(í•„ìˆ˜)

libjpegì€ ë‚´ë¶€ **`setjmp/longjmp`** ê¸°ë°˜ ì—ëŸ¬ ë³µêµ¬ë¥¼ ìš”êµ¬í•©ë‹ˆë‹¤.

```cpp
// JpegUtil.h
#pragma once
#include <cstdio>
#include <string>
#include <vector>
#include <setjmp.h>
#include <jpeglib.h>
#include "IppDib.h"

struct JpegErrorMgr {
    jpeg_error_mgr pub;
    jmp_buf jb;
    static void onError(j_common_ptr cinfo){
        JpegErrorMgr* err = (JpegErrorMgr*)cinfo->err;
        (*cinfo->err->output_message)(cinfo); // ë””ë²„ê·¸ ì¶œë ¥
        longjmp(err->jb, 1);
    }
};

inline void jpegInitDecompress(j_decompress_ptr cinfo, JpegErrorMgr& jerr){
    cinfo->err = jpeg_std_error(&jerr.pub);
    jerr.pub.error_exit = JpegErrorMgr::onError;
    jpeg_create_decompress(cinfo);
}
inline void jpegInitCompress(j_compress_ptr cinfo, JpegErrorMgr& jerr){
    cinfo->err = jpeg_std_error(&jerr.pub);
    jerr.pub.error_exit = JpegErrorMgr::onError;
    jpeg_create_compress(cinfo);
}
```

---

### **ë””ì½”ë“œ: JPEG â†’ `IppDib(BGRA32, top-down)`**

```cpp
// JpegUtil.cpp (Decode)
#include "JpegUtil.h"
#include <io.h>

bool JpegLoadToIppDib(const std::wstring& path, IppDib& out){
    FILE* fp=nullptr;
    _wfopen_s(&fp, path.c_str(), L"rb");
    if (!fp) return false;

    jpeg_decompress_struct cinfo{};
    JpegErrorMgr jerr{};
    try{
        jpegInitDecompress(&cinfo, jerr);
        if (setjmp(jerr.jb)){ jpeg_destroy_decompress(&cinfo); fclose(fp); return false; }

        jpeg_stdio_src(&cinfo, fp);
        jpeg_read_header(&cinfo, TRUE);

        // ì¶œë ¥ ìƒ‰ê³µê°„: RGB (ê°€ì¥ í˜¸í™˜) â†’ BGRAë¡œ ë³€í™˜
        cinfo.out_color_space = JCS_RGB;

        // ì†ë„/í’ˆì§ˆ ì˜µì…˜ (FAST, ISLOW, FLOAT)
        cinfo.dct_method = JDCT_ISLOW; // í’ˆì§ˆ ìš°ì„  (JDCT_IFASTëŠ” ì†ë„ ìš°ì„ )

        jpeg_start_decompress(&cinfo);

        const int W=cinfo.output_width, H=cinfo.output_height, C=cinfo.output_components; // C=3
        out.create(W, H, 32); // BGRA32 top-down

        // í•œ ì¤„ ë²„í¼
        std::vector<uint8_t> row(W * C);
        while (cinfo.output_scanline < cinfo.output_height){
            JSAMPROW rowptr = row.data();
            jpeg_read_scanlines(&cinfo, &rowptr, 1);

            uint8_t* dst = (uint8_t*)out.bits() + (size_t)(cinfo.output_scanline-1) * out.stride();
            // RGB â†’ BGRA
            for (int x=0; x<W; ++x){
                uint8_t R=row[x*3+0], G=row[x*3+1], B=row[x*3+2];
                dst[x*4+0]=B; dst[x*4+1]=G; dst[x*4+2]=R; dst[x*4+3]=255;
            }
        }

        jpeg_finish_decompress(&cinfo);
        jpeg_destroy_decompress(&cinfo);
        fclose(fp);
        return true;
    }catch(...){
        jpeg_destroy_decompress(&cinfo);
        if (fp) fclose(fp);
        return false;
    }
}
```

> **CMYK/Grayscale ì˜ˆì™¸**
> - ì–´ë–¤ JPEGëŠ” **CMYK**/YCbCrK(ì¸ì‡„ìš©)ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë•Œ `out_color_space=JCS_RGB` ë¡œ ë””ì½”ë”ê°€ ë‚´ë¶€ ë³€í™˜ì„ ì‹œë„í•˜ì§€ë§Œ, ì‹¤íŒ¨ ì‹œì—ëŠ” `JCS_CMYK` ë¡œ ë°›ì•„ ìˆ˜ë™ ë³€í™˜:
>   `R=255âˆ’min(255, C+K)`, `G=255âˆ’min(255, G+K)`, `B=255âˆ’min(255, M+K)`.

---

### **ì¸ì½”ë“œ: `IppDib` â†’ JPEG íŒŒì¼**

- ì…ë ¥: **BGRA32 top-down**
- ì¸ì½”ë” ì…ë ¥: ì¼ë°˜ì ìœ¼ë¡œ **RGB (row-major)**
- í’ˆì§ˆ/ì„œë¸Œìƒ˜í”Œë§/ì§„í–‰í˜•/ì˜µí‹°ë§ˆì´ì¦ˆ ì½”ë”© ì˜µì…˜ ì œê³µ

```cpp
// JpegUtil.cpp (Encode)
#include "JpegUtil.h"

static void SetSubsampling(j_compress_ptr cinfo, const wchar_t* subsampling){
    // subsampling: L"444", L"422", L"420" (ê¸°ë³¸ 420)
    int Hs=2, Vs=2; // 420 ê¸°ë³¸(Y h=2,v=2, CbCr h=1,v=1)
    if (subsampling && wcscmp(subsampling, L"444")==0){ Hs=1; Vs=1; }
    else if (subsampling && wcscmp(subsampling, L"422")==0){ Hs=2; Vs=1; }
    // Y component
    cinfo->comp_info[0].h_samp_factor = Hs;
    cinfo->comp_info[0].v_samp_factor = Vs;
    // Cb/Cr
    for (int i=1;i<3;++i){
        cinfo->comp_info[i].h_samp_factor = 1;
        cinfo->comp_info[i].v_samp_factor = 1;
    }
}

bool IppDibSaveAsJpeg(const IppDib& dib, const std::wstring& path, int quality=90, const wchar_t* subsampling=L"420",
                      bool progressive=false, bool optimize=true, int restartIntervalMCUs=0){
    if (!dib) return false;
    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"wb");
    if (!fp) return false;

    jpeg_compress_struct cinfo{};
    JpegErrorMgr jerr{};
    try{
        jpegInitCompress(&cinfo, jerr);
        if (setjmp(jerr.jb)){ jpeg_destroy_compress(&cinfo); fclose(fp); return false; }

        jpeg_stdio_dest(&cinfo, fp);

        const int W=dib.width(), H=dib.height();
        cinfo.image_width = W;
        cinfo.image_height= H;
        cinfo.input_components = 3;             // RGB
        cinfo.in_color_space = JCS_RGB;

        jpeg_set_defaults(&cinfo);
        jpeg_set_quality(&cinfo, std::clamp(quality,1,100), TRUE /*limit to baseline*/);

        // ìƒ‰ ìƒ˜í”Œë§(ì„œë¸Œìƒ˜í”Œë§)
        jpeg_set_colorspace(&cinfo, JCS_YCbCr); // ì¼ë°˜ì 
        jpeg_start_compress(&cinfo, FALSE);     // comp_info ì ‘ê·¼ ìœ„í•´ start ì´ì „/í›„ ëª¨ë‘ ê°€ëŠ¥ êµ¬í˜„ì— ë”°ë¼ ë‹¤ë¦„
        SetSubsampling(&cinfo, subsampling);

        // ì§„í–‰í˜• JPEG
        if (progressive) jpeg_simple_progression(&cinfo);
        // í—ˆí”„ë§Œ ìµœì í™”(í¬ê¸°â†“, ì†ë„ ì•½ê°„â†“)
        cinfo.optimize_coding = optimize ? TRUE : FALSE;
        // ë¦¬ìŠ¤íƒ€íŠ¸ ë§ˆì»¤(ì „ì†¡ ì˜¤ë¥˜ ê°•ì¸ì„±/ë³‘ë ¬ ë””ì½”ë“œ ë„ì›€)
        if (restartIntervalMCUs>0) cinfo.restart_interval = restartIntervalMCUs;

        // ì‹¤ì œ ì••ì¶• ì‹œì‘
        jpeg_start_compress(&cinfo, TRUE);

        // í•œ ì¤„ì”© RGBë¡œ ë³´ëƒ„
        std::vector<uint8_t> rowRGB(W*3);
        while (cinfo.next_scanline < cinfo.image_height){
            const uint8_t* src = (const uint8_t*)dib.bits() + (size_t)cinfo.next_scanline * dib.stride();
            // BGRA â†’ RGB
            for (int x=0;x<W;++x){
                rowRGB[x*3+0]=src[x*4+2]; // R
                rowRGB[x*3+1]=src[x*4+1]; // G
                rowRGB[x*3+2]=src[x*4+0]; // B
            }
            JSAMPROW rp = rowRGB.data();
            jpeg_write_scanlines(&cinfo, &rp, 1);
        }

        jpeg_finish_compress(&cinfo);
        jpeg_destroy_compress(&cinfo);
        fclose(fp);
        return true;
    }catch(...){
        jpeg_destroy_compress(&cinfo);
        if (fp) fclose(fp);
        return false;
    }
}
```

> **ì°¸ê³ (í„°ë³´ í™•ì¥)**: libjpeg-turbo ëŠ” `cinfo.in_color_space = JCS_EXT_BGRA` ë¥¼ ì§€ì› â†’ **BGRAë¥¼ ê·¸ëŒ€ë¡œ** ì¤„ ìˆ˜ ìˆì–´ ë³€í™˜ ë¹„ìš© 0. (ì¼ë¶€ ë°°í¬ë³¸/ë¹Œë“œ ì˜µì…˜ì— ë”°ë¼ ë¹„í™œì„±ì¼ ìˆ˜ ìˆì–´, ìƒí˜¸ìš´ìš©ì„± ìœ„í•´ ìœ„ì²˜ëŸ¼ **RGB ë³€í™˜**ì„ ê¸°ë³¸ìœ¼ë¡œ ê¶Œì¥)

---

### **ë©”ëª¨ë¦¬ ê¸°ë°˜ API** (ë„¤íŠ¸ì›Œí¬/DB ìš©)

**ì“°ê¸°**: `jpeg_mem_dest` / **ì½ê¸°**: `jpeg_mem_src` ì‚¬ìš©(libjpeg-turbo/ìµœê·¼ IJG ì§€ì›).

```cpp
// JpegMem.cpp
#include "JpegUtil.h"

bool IppDibEncodeJpegToMemory(const IppDib& dib, std::vector<uint8_t>& outBytes,
                              int quality=90, const wchar_t* subsampling=L"420"){
    if (!dib) return false;

    jpeg_compress_struct cinfo{};
    JpegErrorMgr jerr{};
    unsigned char* mem = nullptr; unsigned long memSize = 0;
    try{
        jpegInitCompress(&cinfo, jerr);
        if (setjmp(jerr.jb)){ jpeg_destroy_compress(&cinfo); if(mem) free(mem); return false; }

        jpeg_mem_dest(&cinfo, &mem, &memSize); // ë‚´ë¶€ malloc

        cinfo.image_width = dib.width();
        cinfo.image_height= dib.height();
        cinfo.input_components = 3;
        cinfo.in_color_space = JCS_RGB;

        jpeg_set_defaults(&cinfo);
        jpeg_set_quality(&cinfo, std::clamp(quality,1,100), TRUE);
        jpeg_set_colorspace(&cinfo, JCS_YCbCr);
        jpeg_start_compress(&cinfo, FALSE);
        SetSubsampling(&cinfo, subsampling);
        jpeg_start_compress(&cinfo, TRUE);

        std::vector<uint8_t> rowRGB(dib.width()*3);
        while (cinfo.next_scanline < cinfo.image_height){
            const uint8_t* s=(const uint8_t*)dib.bits() + (size_t)cinfo.next_scanline*dib.stride();
            for(int x=0;x<dib.width();++x){ rowRGB[x*3+0]=s[x*4+2]; rowRGB[x*3+1]=s[x*4+1]; rowRGB[x*3+2]=s[x*4+0]; }
            JSAMPROW rp=rowRGB.data(); jpeg_write_scanlines(&cinfo,&rp,1);
        }
        jpeg_finish_compress(&cinfo);
        outBytes.assign(mem, mem+memSize);
        jpeg_destroy_compress(&cinfo);
        free(mem);
        return true;
    }catch(...){
        jpeg_destroy_compress(&cinfo);
        if (mem) free(mem);
        return false;
    }
}

bool IppDibDecodeJpegFromMemory(const uint8_t* data, size_t size, IppDib& out){
    if (!data || !size) return false;
    jpeg_decompress_struct cinfo{};
    JpegErrorMgr jerr{};
    try{
        jpegInitDecompress(&cinfo, jerr);
        if (setjmp(jerr.jb)){ jpeg_destroy_decompress(&cinfo); return false; }

        jpeg_mem_src(&cinfo, const_cast<unsigned char*>(data), (unsigned long)size);
        jpeg_read_header(&cinfo, TRUE);
        cinfo.out_color_space = JCS_RGB;
        jpeg_start_decompress(&cinfo);

        out.create(cinfo.output_width, cinfo.output_height, 32);
        std::vector<uint8_t> row(out.width()*3);
        while (cinfo.output_scanline < cinfo.output_height){
            JSAMPROW rp = row.data();
            jpeg_read_scanlines(&cinfo, &rp, 1);
            uint8_t* dst=(uint8_t*)out.bits() + (size_t)(cinfo.output_scanline-1)*out.stride();
            for(int x=0;x<out.width();++x){ dst[x*4+0]=row[x*3+2-2]; /*B*/ dst[x*4+1]=row[x*3+1]; dst[x*4+2]=row[x*3+0]; dst[x*4+3]=255; }
            // ìœ„ í•œì¤„ì€ ê°€ë…ì„±ì„ ìœ„í•´ ì•„ë˜ì²˜ëŸ¼ ë‹¤ì‹œ ì”€:
            for(int x=0;x<out.width();++x){
                uint8_t R=row[x*3+0], G=row[x*3+1], B=row[x*3+2];
                dst[x*4+0]=B; dst[x*4+1]=G; dst[x*4+2]=R; dst[x*4+3]=255;
            }
        }
        jpeg_finish_decompress(&cinfo);
        jpeg_destroy_decompress(&cinfo);
        return true;
    }catch(...){
        jpeg_destroy_decompress(&cinfo);
        return false;
    }
}
```

---

## ê³ ê¸‰ ì˜µì…˜ (í’ˆì§ˆ/ìš©ëŸ‰/í˜¸í™˜ì„± íŠœë‹)

- **í’ˆì§ˆ(1~100)**: ì¼ë°˜ ì‚¬ì§„ì€ **85~92** ê¶Œì¥(ìš©ëŸ‰ ëŒ€ë¹„ í™”ì§ˆ ìš°ìˆ˜).
- **ì„œë¸Œìƒ˜í”Œë§**:
  - **4:2:0(ê¸°ë³¸)**: ìì—°ì˜ìƒì— ì í•©(í”¼ë¶€í†¤ ë“±)
  - **4:4:4**: **í…ìŠ¤íŠ¸/UI/ë¼ì¸ ì•„íŠ¸**(í¬ë¡œë§ˆ ì—£ì§€ ë³´ì¡´)
  - **4:2:2**: TV/ë¹„ë””ì˜¤ í˜¸í™˜ íŒ¨ìŠ¤
- **`cinfo.optimize_coding=TRUE`**: í—ˆí”„ë§Œ í…Œì´ë¸” ìµœì í™”(ìš©ëŸ‰â†“, ì¸ì½”ë”© ì•½ê°„ ëŠë¦¼)
- **`jpeg_simple_progression`**: ì§„í–‰í˜• JPEG(ì›¹ì—ì„œ ë¯¸ë¦¬ë³´ê¸° íš¨ê³¼)
- **`cinfo.restart_interval`**: ë¦¬ìŠ¤íƒ€íŠ¸ ë„ì…(ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜/ë³‘ë ¬ ë””ì½”ë”ì— ìœ ë¦¬)
- **ìŠ¤ì¼€ì¼ ë””ì½”ë”©**: `cinfo.scale_num/scale_denom` ìœ¼ë¡œ **1/2, 1/4** í¬ê¸° ë¹ ë¥¸ ì¸ë„¤ì¼
- **í¬ë¡­ ë””ì½”ë”©**(í„°ë³´): `jpeg_skip_scanlines`, `jpeg_crop_scanline` ë¡œ ì¼ë¶€ ì˜ì—­ë§Œ ë””ì½”ë“œ

---

## MFC/Win32 ë„êµ¬ì— í†µí•© (ë©”ë‰´/ëŒ€í™” ìƒì ì˜ˆì‹œ)

### â€œJPEGë¡œ ì €ì¥â€¦â€ ë©”ë‰´

- ë©”ë‰´ ID: `ID_FILE_SAVE_JPEG`
- í’ˆì§ˆ/ì„œë¸Œìƒ˜í”Œë§/í”„ë¡œê·¸ë ˆì‹œë¸Œ ì²´í¬ë¥¼ ë°›ëŠ” ê°„ë‹¨ ëŒ€í™” ìƒì

```cpp
// FileJpegCmd.cpp (ë°œì·Œ)
#include "JpegUtil.h"
#include <commdlg.h>

void Cmd_SaveAsJpeg(HWND hOwner, const IppDib& dib){
    if (!dib){ MessageBoxW(hOwner,L"ì˜ìƒì´ ì—†ìŠµë‹ˆë‹¤.",L"JPEG",MB_ICONWARNING); return; }

    wchar_t path[MAX_PATH]=L"";
    OPENFILENAMEW ofn{sizeof(ofn)};
    ofn.hwndOwner=hOwner;
    ofn.lpstrFilter=L"JPEG Image (*.jpg;*.jpeg)\0*.jpg;*.jpeg\0\0";
    ofn.lpstrFile=path; ofn.nMaxFile=MAX_PATH;
    ofn.lpstrDefExt=L"jpg";
    ofn.Flags=OFN_OVERWRITEPROMPT;
    if (!GetSaveFileNameW(&ofn)) return;

    int quality=90; // TODO: ëŒ€í™” ìƒìì—ì„œ ë°›ê¸°
    const wchar_t* subs=L"420";
    bool progressive=false, optimize=true;

    if (!IppDibSaveAsJpeg(dib, path, quality, subs, progressive, optimize)){
        MessageBoxW(hOwner, L"ì €ì¥ ì‹¤íŒ¨", L"JPEG", MB_ICONERROR);
    }
}
```

### â€œJPEG ì—´ê¸°â€¦â€

```cpp
// FileJpegOpen.cpp (ë°œì·Œ)
void Cmd_OpenJpeg(HWND hOwner){
    wchar_t path[MAX_PATH]=L"";
    OPENFILENAMEW ofn{sizeof(ofn)};
    ofn.hwndOwner=hOwner;
    ofn.lpstrFilter=L"JPEG Image (*.jpg;*.jpeg)\0*.jpg;*.jpeg\0All Files\0*.*\0\0";
    ofn.lpstrFile=path; ofn.nMaxFile=MAX_PATH;
    ofn.Flags=OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST;
    if (!GetOpenFileNameW(&ofn)) return;

    IppDib dib;
    if (!JpegLoadToIppDib(path, dib)){
        MessageBoxW(hOwner, L"ì—´ê¸° ì‹¤íŒ¨", L"JPEG", MB_ICONERROR);
        return;
    }
    CreateDocWindowFromDib(dib, L"JPEG Image");
}
```

---

## í”í•œ ë¬¸ì œì™€ í•´ê²°

- **ìƒ‰ì´ íƒí•¨/ì˜…ìŒ**: sRGB ê°ë§ˆ/í”„ë¡œíŒŒì¼ ì°¨ì´.
  - ICC í”„ë¡œíŒŒì¼(APP2) ì´ í¬í•¨ëœ JPEGëŠ” **ìƒ‰ ê´€ë¦¬**ê°€ í•„ìš”(Windows GDI ê¸°ë³¸ì€ ë‹¨ìˆœ).
  - ì •í™•í•œ ìƒ‰ì´ í•„ìš”í•˜ë©´ **WIC/ColorMgmt** ë˜ëŠ” `lcms2` ë„ì… ê³ ë ¤.
- **ê¸€ì/ì•„ì´ì½˜ì´ ë²ˆì§**: 4:2:0 ì„œë¸Œìƒ˜í”Œë§ â†’ **4:4:4** ë¡œ ì €ì¥.
- **ì¬ì••ì¶• í’ˆì§ˆ ì €í•˜**: JPEGâ†’í¸ì§‘â†’JPEG ë°˜ë³µì€ ì†ì‹¤ ëˆ„ì . ë§ˆìŠ¤í„°ëŠ” **PNG/BMP** ë³´ê´€.
- **CMYK JPEG**: ì¸ì‡„ìš©. ìœ„ì—ì„œ ì–¸ê¸‰í•œ ìˆ˜ì‹ìœ¼ë¡œ RGB ë³€í™˜í•˜ê±°ë‚˜, ë””ì½”ë”ì˜ ë³€í™˜ ê¸°ëŠ¥ ì‚¬ìš©.
- **EXIF íšŒì „**: ìŠ¤ë§ˆíŠ¸í° ì‚¬ì§„ì€ Orientation íƒœê·¸ë§Œ ë°”ê¿” ì €ì¥í•˜ëŠ” ê²½ìš° ë§ìŒ.
  - `JpegLoadToIppDib` í›„ EXIF ì½ì–´ **íšŒì „ ë³´ì •**(ë³„ë„ EXIF íŒŒì„œ í•„ìš”).
- **ëŒ€ìš©ëŸ‰/ê³ í•´ìƒë„ ì„±ëŠ¥**: libjpeg-turboëŠ” ë‚´ë¶€ SIMDë¡œ ë¹ ë¥´ì§€ë§Œ, ë©€í‹°ìŠ¤ë ˆë”©ì€ **í”„ë ˆì„ ë‹¨ìœ„** ë³‘ë ¬í™”ë¡œ ì„¤ê³„(í•œ cinfoëŠ” ë‹¨ì¼ ìŠ¤ë ˆë“œì—ì„œ ì‚¬ìš©).

---

## ë¹ ë¥¸ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] vcpkgë¡œ `libjpeg-turbo:x64-windows` ì„¤ì¹˜, ë§í‚¹ OK
- [ ] **JPEG ì—´ê¸°/ì €ì¥** ë©”ë‰´ ë™ì‘, ë‹¤ì–‘í•œ ìƒ˜í”Œ ì´ë¯¸ì§€ë¡œ í…ŒìŠ¤íŠ¸
- [ ] í’ˆì§ˆ 85 / ì„œë¸Œìƒ˜í”Œë§ 420 ê¸°ë³¸, í…ìŠ¤íŠ¸/ë„ë©´ì€ 444 í™•ì¸
- [ ] ì§„í–‰í˜•/ì˜µí‹°ë§ˆì´ì¦ˆ/ë¦¬ìŠ¤íƒ€íŠ¸ ì˜µì…˜ ì‹¤í—˜
- [ ] CMYK/EXIF íŒŒì¼ ëŒ€ì‘ ì—¬ë¶€ í™•ì¸

---

## ìš”ì•½

- JPEGì€ **YCbCr + ì„œë¸Œìƒ˜í”Œë§ + DCT + ì–‘ìí™” + í—ˆí”„ë§Œ** ìœ¼ë¡œ ìš©ëŸ‰ì„ í¬ê²Œ ì¤„ì…ë‹ˆë‹¤.
- Windows/VS í™˜ê²½ì—ì„œëŠ” **libjpeg-turbo** ë¥¼ vcpkgë¡œ ì†ì‰½ê²Œ ë„ì… ê°€ëŠ¥.
- ë³¸ë¬¸ ì½”ë“œëŠ” `IppDib(BGRA32)` â†” **JPEG íŒŒì¼/ë©”ëª¨ë¦¬** ì–‘ë°©í–¥ì„ ì»¤ë²„í•˜ê³ ,
  **í’ˆì§ˆ/ì„œë¸Œìƒ˜í”Œë§/ì§„í–‰í˜•/ì˜µí‹°ë§ˆì´ì¦ˆ/ë¦¬ìŠ¤íƒ€íŠ¸** ë“± ì‹¤ë¬´ ì˜µì…˜ì„ ë‹´ì•˜ìŠµë‹ˆë‹¤.
- ì£¼ì˜í•  ì ì€ **ìƒ‰ ê´€ë¦¬/ì„œë¸Œìƒ˜í”Œë§/ì¬ì••ì¶• ì†ì‹¤**. ìš©ë„ë³„ í”„ë¦¬ì…‹ì„ ì •í•´ ì¼ê´€ì„± ìˆê²Œ ì“°ë©´ ì¢‹ìŠµë‹ˆë‹¤.
- ë‹¤ìŒ ë‹¨ê³„: **EXIF ì½ê¸° + ìë™ íšŒì „**, **ì¸ë„¤ì¼ ë¹ ë¥¸ ë””ì½”ë”©(scale_denom)**, **ë°°ì¹˜ ì¸ì½”ë”**ë¡œ í™•ì¥í•´ ë³´ì„¸ìš”. ğŸš€






