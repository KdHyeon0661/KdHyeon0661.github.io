---
layout: post
title: Avalonia - 애니메이션 및 전환 효과 구현
date: 2025-03-11 19:20:23 +0900
category: Avalonia
---
# Avalonia에서 애니메이션 및 전환 효과 구현

- `ContentControl` 기반 페이지 전환(Fade/Slide/CrossFade), **재사용 가능한 전환 호스트** 컴포넌트
- `Avalonia.Animation`을 이용한 **키프레임 애니메이션**(Opacity/Transform/Brush 등)
- **트리거(DataTrigger/PointerOver)** 와 **커맨드** 결합(순수 MVVM)
- **코드에서 실행**하는 애니메이션(`Animation.RunAsync`) 및 **서비스 추상화**
- 리스트 항목/다이얼로그/로딩 상태 등 **현실적 시나리오**
- **성능·UX 가이드**, **테스트 전략**(단위/시각 회귀), **디버깅 팁**

---

## 프로젝트 준비

```bash
dotnet add package Avalonia
dotnet add package Avalonia.Animation
# (선택) 트리거/비헤이비어를 쓰고 싶다면

dotnet add package Avalonia.Xaml.Interactions
dotnet add package Avalonia.Xaml.Interactions.Custom
```

> `Avalonia.Animation` 네임스페이스를 XAML에 선언:
>
> ```xml
> xmlns:ani="clr-namespace:Avalonia.Animation;assembly=Avalonia.Animation"
> ```

---

## 페이지 전환: ContentControl + PageSlide/CrossFade

### 기본 구조

```
MainWindow.axaml
├── ContentControl(Content="{Binding CurrentPage}")
       └── Transitions(PageSlide/CrossFade ...)
```

### XAML: Slide 전환

```xml
<!-- MainWindow.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Grid>
    <ContentControl Content="{Binding CurrentPage}">
      <ContentControl.Transitions>
        <Transitions>
          <!-- 좌→우 슬라이드. 필요 시 SlideAxis, SlideDirection 사용 -->
          <PageSlide Duration="0:0:0.35" SlideDirection="Left"/>
        </Transitions>
      </ContentControl.Transitions>
    </ContentControl>

    <StackPanel Orientation="Horizontal" Spacing="6" HorizontalAlignment="Center" VerticalAlignment="Bottom" Margin="0,0,0,16">
      <Button Content="Prev" Command="{Binding PrevCommand}" />
      <Button Content="Next" Command="{Binding NextCommand}" />
    </StackPanel>
  </Grid>
</Window>
```

> `PageSlide`, `CrossFade` 를 가장 안정적으로 사용한다. (일부 플랫폼/테마에서 `PageFade` 명칭이 혼재하므로 **CrossFade** + **Opacity 트랜지션** 조합을 권장)

### VM: CurrentPage 교체

```csharp
public abstract class PageBase : ReactiveUI.ReactiveObject { }

public sealed class Page1ViewModel : PageBase { /* ... */ }
public sealed class Page2ViewModel : PageBase { /* ... */ }

public sealed class MainWindowViewModel : ReactiveUI.ReactiveObject
{
    private PageBase _currentPage = new Page1ViewModel();
    public PageBase CurrentPage
    {
        get => _currentPage;
        set => this.RaiseAndSetIfChanged(ref _currentPage, value);
    }

    public ReactiveUI.ReactiveCommand<Unit, Unit> NextCommand { get; }
    public ReactiveUI.ReactiveCommand<Unit, Unit> PrevCommand { get; }

    public MainWindowViewModel()
    {
        NextCommand = ReactiveUI.ReactiveCommand.Create(() =>
        {
            CurrentPage = CurrentPage is Page1ViewModel ? new Page2ViewModel() : new Page1ViewModel();
        });

        PrevCommand = ReactiveUI.ReactiveCommand.Create(() =>
        {
            CurrentPage = CurrentPage is Page2ViewModel ? new Page1ViewModel() : new Page2ViewModel();
        });
    }
}
```

### CrossFade로 부드러운 전환

```xml
<ContentControl Content="{Binding CurrentPage}">
  <ContentControl.Transitions>
    <Transitions>
      <CrossFade Duration="0:0:0.25"/>
    </Transitions>
  </ContentControl.Transitions>
</ContentControl>
```

---

## 재사용 가능한 전환 호스트(TransitionHost) 컴포넌트

> 팀/프로젝트 규모가 커질수록 **전환 설정을 한 곳**에서 관리하는 것이 중요하다.

### 코드: TransitionHost

```csharp
public sealed class TransitionHost : ContentControl
{
    public static readonly StyledProperty<bool> UseSlideProperty =
        AvaloniaProperty.Register<TransitionHost, bool>(nameof(UseSlide), defaultValue: true);

    public bool UseSlide
    {
        get => GetValue(UseSlideProperty);
        set => SetValue(UseSlideProperty, value);
    }

    protected override void OnApplyTemplate(TemplateAppliedEventArgs e)
    {
        base.OnApplyTemplate(e);

        var list = new Transitions();
        if (UseSlide)
            list.Add(new PageSlide { Duration = TimeSpan.FromMilliseconds(350), SlideDirection = PageSlide.SlideAxis.Left });
        else
            list.Add(new CrossFade { Duration = TimeSpan.FromMilliseconds(250) });

        Transitions = list;
    }
}
```

### 사용

```xml
<local:TransitionHost Content="{Binding CurrentPage}" UseSlide="True" />
```

---

## 개별 컨트롤 애니메이션: Transitions vs Animation(KeyFrame)

### Property Transitions(속성 전환)

**특정 속성 변경** 시 자동으로 보간되는 방식:

```xml
<Button Content="확대 축소">
  <Button.Transitions>
    <Transitions>
      <!-- RenderTransform.ScaleX/Y 변경 시 200ms로 보간 -->
      <DoubleTransition Property="RenderTransform.(ScaleTransform.ScaleX)" Duration="0:0:0.2"/>
      <DoubleTransition Property="RenderTransform.(ScaleTransform.ScaleY)" Duration="0:0:0.2"/>
      <DoubleTransition Property="Opacity" Duration="0:0:0.2"/>
    </Transitions>
  </Button.Transitions>

  <Button.RenderTransform>
    <ScaleTransform ScaleX="1" ScaleY="1"/>
  </Button.RenderTransform>

  <Button.Styles>
    <Style Selector="Button:pointerover">
      <Setter Property="RenderTransform.(ScaleTransform.ScaleX)" Value="1.06"/>
      <Setter Property="RenderTransform.(ScaleTransform.ScaleY)" Value="1.06"/>
      <Setter Property="Opacity" Value="0.95"/>
    </Style>
    <Style Selector="Button:pressed">
      <Setter Property="RenderTransform.(ScaleTransform.ScaleX)" Value="0.98"/>
      <Setter Property="RenderTransform.(ScaleTransform.ScaleY)" Value="0.98"/>
      <Setter Property="Opacity" Value="0.85"/>
    </Style>
  </Button.Styles>
</Button>
```

장점: 선언적/간단, 상태 전환마다 자동 실행.
단점: 복잡한 시퀀싱/지연/키프레임에는 한계.

### 키프레임 애니메이션(고급: `Avalonia.Animation`)

**구간별 값**을 더 세밀하게 제어:

```xml
<!-- Fade + Slide Up 등장 애니메이션 -->
<Grid xmlns="https://github.com/avaloniaui"
      xmlns:ani="clr-namespace:Avalonia.Animation;assembly=Avalonia.Animation"
      x:Name="Root">
  <Grid.Styles>
    <Style>
      <Style.Animations>
        <ani:Animations x:Key="EnterAnim">
          <ani:Animation Duration="0:0:0.40" FillMode="Forward">
            <ani:KeyFrame Cue="0%">
              <Setter Property="Opacity" Value="0"/>
              <Setter Property="RenderTransform.(TranslateTransform.Y)" Value="12"/>
            </ani:KeyFrame>
            <ani:KeyFrame Cue="100%">
              <Setter Property="Opacity" Value="1"/>
              <Setter Property="RenderTransform.(TranslateTransform.Y)" Value="0"/>
            </ani:KeyFrame>
          </ani:Animation>
        </ani:Animations>
      </Style.Animations>
    </Style>
  </Grid.Styles>

  <Grid.RenderTransform>
    <TranslateTransform Y="0"/>
  </Grid.RenderTransform>

  <!-- 로딩 시점에 자동 실행 -->
  <ani:Animation.Animations>
    <StaticResource ResourceKey="EnterAnim"/>
  </ani:Animation.Animations>

  <TextBlock Text="키프레임으로 등장!" FontSize="20"/>
</Grid>
```

> `FillMode="Forward"`를 주면 종료 시점의 값 유지.

---

## 커맨드(뷰모델)와 애니메이션 결합 — 순수 MVVM

애니메이션을 **코드-비하인드 없이** 실행하고 싶다면 **플래그 + DataTrigger** 또는 **서비스 추상화**를 사용한다.

### 플래그 + DataTrigger

#### ViewModel

```csharp
public sealed class CardViewModel : ReactiveUI.ReactiveObject
{
    private bool _isError;
    public bool IsError
    {
        get => _isError;
        set => this.RaiseAndSetIfChanged(ref _isError, value);
    }

    public ReactiveUI.ReactiveCommand<Unit, Unit> ValidateCommand { get; }
    public CardViewModel()
    {
        ValidateCommand = ReactiveUI.ReactiveCommand.Create(() =>
        {
            // 검증 실패 시 에러 플래그
            IsError = true;
            // 잠시 후 false로 내려 애니메이션 재트리거
            RxApp.MainThreadScheduler.Schedule(TimeSpan.FromMilliseconds(400), () => IsError = false);
        });
    }
}
```

#### XAML

```xml
<Border xmlns="https://github.com/avaloniaui"
        xmlns:ani="clr-namespace:Avalonia.Animation;assembly=Avalonia.Animation"
        Background="#1F0000" CornerRadius="8" Padding="12">
  <Border.Styles>
    <Style Selector="Border">
      <Style.Triggers>
        <DataTrigger Binding="{Binding IsError}" Value="True">
          <Setter Property="ani:Animation.Animations">
            <ani:Animations>
              <ani:Animation Duration="0:0:0.30">
                <!-- 흔들림(Shake) -->
                <ani:KeyFrame Cue="0%"><Setter Property="RenderTransform.(TranslateTransform.X)" Value="0"/></ani:KeyFrame>
                <ani:KeyFrame Cue="25%"><Setter Property="RenderTransform.(TranslateTransform.X)" Value="-8"/></ani:KeyFrame>
                <ani:KeyFrame Cue="50%"><Setter Property="RenderTransform.(TranslateTransform.X)" Value="8"/></ani:KeyFrame>
                <ani:KeyFrame Cue="75%"><Setter Property="RenderTransform.(TranslateTransform.X)" Value="-4"/></ani:KeyFrame>
                <ani:KeyFrame Cue="100%"><Setter Property="RenderTransform.(TranslateTransform.X)" Value="0"/></ani:KeyFrame>
              </ani:Animation>
            </ani:Animations>
          </Setter>
        </DataTrigger>
      </Style.Triggers>
    </Style>
  </Border.Styles>

  <Border.RenderTransform>
    <TranslateTransform/>
  </Border.RenderTransform>

  <StackPanel>
    <TextBlock Text="검증 대상 영역"/>
    <Button Content="검증" Command="{Binding ValidateCommand}" />
  </StackPanel>
</Border>
```

### 애니메이션 실행 서비스(테스트 가능한 추상화)

#### 인터페이스/구현

```csharp
public interface IAnimationService
{
    Task RunAsync(Control target, Animation animation, CancellationToken ct = default);
}

public sealed class AnimationService : IAnimationService
{
    public Task RunAsync(Control target, Animation animation, CancellationToken ct = default)
    {
        return animation.RunAsync(target, ct);
    }
}
```

#### VM에서 의존

```csharp
public sealed class ToastViewModel : ReactiveUI.ReactiveObject
{
    private readonly IAnimationService _anim;
    public Control? ViewControl { get; set; }  // View에서 연결(Attached Service로 대체 가능)

    public ReactiveUI.ReactiveCommand<Unit, Unit> ShowToastCommand { get; }

    public ToastViewModel(IAnimationService anim)
    {
        _anim = anim;

        var fade = new Avalonia.Animation.Animation
        {
            Duration = TimeSpan.FromMilliseconds(400),
            FillMode = FillMode.Forward,
            Children =
            {
                new KeyFrame { Cue = new Cue(0d),   Setters = { new Setter(Visual.OpacityProperty, 0d) } },
                new KeyFrame { Cue = new Cue(1.0d), Setters = { new Setter(Visual.OpacityProperty, 1d) } },
            }
        };

        ShowToastCommand = ReactiveUI.ReactiveCommand.CreateFromTask(async () =>
        {
            if (ViewControl is null) return;
            await _anim.RunAsync(ViewControl, fade);
            await Task.Delay(1500);
            // 사라짐
            var outAnim = new Avalonia.Animation.Animation
            {
                Duration = TimeSpan.FromMilliseconds(300),
                Children =
                {
                    new KeyFrame { Cue = new Cue(0d),   Setters = { new Setter(Visual.OpacityProperty, 1d) } },
                    new KeyFrame { Cue = new Cue(1.0d), Setters = { new Setter(Visual.OpacityProperty, 0d) } },
                }
            };
            await _anim.RunAsync(ViewControl, outAnim);
        });
    }
}
```

> 테스트에서는 `IAnimationService`를 **Mock**하여 애니메이션 시간을 스킵하고 로직만 검증 가능.

---

## 리스트 항목 애니메이션(ItemsControl/TreeDataGrid 등)

**항목 추가/제거** 시 미묘한 이동/페이드를 주면 가독성이 크게 좋아진다.

```xml
<ItemsControl Items="{Binding Notifications}">
  <ItemsControl.ItemTemplate>
    <DataTemplate>
      <Border Margin="0,4" Padding="8" Background="#202020" CornerRadius="6">
        <Border.Transitions>
          <Transitions>
            <DoubleTransition Property="Opacity" Duration="0:0:0.25"/>
            <DoubleTransition Property="RenderTransform.(TranslateTransform.Y)" Duration="0:0:0.25"/>
          </Transitions>
        </Border.Transitions>

        <Border.RenderTransform>
          <TranslateTransform Y="10"/>
        </Border.RenderTransform>

        <StackPanel>
          <TextBlock Text="{Binding Title}" FontWeight="Bold"/>
          <TextBlock Text="{Binding Message}" Opacity="0.85"/>
        </StackPanel>
      </Border>
    </DataTemplate>
  </ItemsControl.ItemTemplate>
</ItemsControl>
```

> 항목이 바인딩 컬렉션에 추가되면 기본값(Opacity=1, Y=10 → 0)으로 **부드럽게 자리잡는다**.
> 보다 정밀한 제어가 필요하면 `Avalonia.Animation` 키프레임을 사용.

---

## 다이얼로그/패널: 진입/퇴장 애니메이션

### 오버레이 패널 예시

```xml
<Grid>
  <!-- 본문 -->
  <ContentControl Content="{Binding Body}"/>

  <!-- 오버레이 (IsOverlayVisible에 의해 표시) -->
  <Border Background="#80000000"
          IsVisible="{Binding IsOverlayVisible}">
    <Border.Transitions>
      <Transitions>
        <DoubleTransition Property="Opacity" Duration="0:0:0.2"/>
      </Transitions>
    </Border.Transitions>

    <Border.Styles>
      <Style Selector="Border:visible">
        <Setter Property="Opacity" Value="1"/>
      </Style>
      <Style Selector="Border:not(:visible)">
        <Setter Property="Opacity" Value="0"/>
      </Style>
    </Border.Styles>

    <StackPanel HorizontalAlignment="Center" VerticalAlignment="Center">
      <Border Background="#2E2E2E" CornerRadius="10" Padding="16">
        <StackPanel>
          <TextBlock Text="처리 중..." FontSize="16" Margin="0,0,0,8"/>
          <!-- 단순 회전 애니메이션 -->
          <Path Data="M 0 10 A 10 10 0 1 1 0 9.999" Stroke="White" StrokeThickness="2">
            <Path.RenderTransform>
              <RotateTransform Angle="0" />
            </Path.RenderTransform>
            <Path.Styles>
              <Style Selector="Path">
                <Style.Animations>
                  <ani:Animations>
                    <ani:Animation Duration="0:0:1.0" RepeatCount="Infinity">
                      <ani:KeyFrame Cue="0%"><Setter Property="RenderTransform.(RotateTransform.Angle)" Value="0"/></ani:KeyFrame>
                      <ani:KeyFrame Cue="100%"><Setter Property="RenderTransform.(RotateTransform.Angle)" Value="360"/></ani:KeyFrame>
                    </ani:Animation>
                  </ani:Animations>
                </Style.Animations>
              </Style>
            </Path.Styles>
          </Path>
        </StackPanel>
      </Border>
    </StackPanel>
  </Border>
</Grid>
```

---

## 이징(Easing)·지연(Delay)·시퀀스 구성

키프레임에 `Easing`(가속도 곡선)과 `Delay`(지연)를 넣어 자연스러움을 높인다.

```xml
<ani:Animation Duration="0:0:0.6" FillMode="Forward">
  <ani:KeyFrame Cue="0%">
    <Setter Property="Opacity" Value="0"/>
  </ani:KeyFrame>
  <ani:KeyFrame Cue="100%" Easing="CubicOut">
    <Setter Property="Opacity" Value="1"/>
  </ani:KeyFrame>
</ani:Animation>
```

> 자주 쓰는 이징: `CubicOut`, `QuadraticOut`, `QuintOut`, `BackOut`, `ElasticOut` 등.

---

## 성능·UX 모범 사례

| 주제 | 권장 사항 |
|---|---|
| 지속시간 | 0.2~0.5초가 무난. 0.7초 이상은 **느려짐** 체감 |
| 속성 선택 | **Opacity/Transform**(Translate/Scale/Rotate) 중심. Layout(Width/Height/Margin) 반복 변경은 비용↑ |
| 배치 | 애니메이션 중 레이아웃 변경을 최소화(측정·배치 비용 상승) |
| 저사양 | 애니메이션 빈도/갯수 제한. `Reduce motion` 환경 옵션과 연동 고려 |
| 접근성 | 모션 민감성 사용자 고려(설정으로 모션 끄기/감소) |
| 동시성 | 같은 요소에 **중복 애니메이션** 얹지 않기(겹침/깜빡임 방지) |
| 테스트 | 로직·상태 전환은 단위 테스트, 시각 효과는 스냅샷/비주얼 테스트로 분리 |

---

## 테스트 전략

- **ViewModel 단위 테스트**: 상태 전환(예: `CurrentPage` 변경)만 검증 → 전환/애니메이션은 **별개**
- **애니메이션 서비스 모킹**: `IAnimationService`를 테스트에서 stub/mock → **즉시 완료**
- **시각 회귀 테스트**: 특정 시점의 화면 렌더를 캡처(전환 전/후), threshold 비교

```csharp
[Fact]
public async Task Next_Changes_CurrentPage()
{
    var vm = new MainWindowViewModel();
    var before = vm.CurrentPage;
    vm.NextCommand.Execute().Subscribe(); // 또는 await Execute()
    Assert.NotSame(before, vm.CurrentPage);
}
```

---

## 실전 샘플: “탭 전환 + 항목 등장 + 오류 흔들림” 통합

### ViewModel

```csharp
public sealed class DashboardViewModel : ReactiveUI.ReactiveObject
{
    private object _currentTab = new OverviewTabViewModel();
    public object CurrentTab
    {
        get => _currentTab;
        set => this.RaiseAndSetIfChanged(ref _currentTab, value);
    }

    public ObservableCollection<NotificationItem> Notifications { get; } = new();

    public ReactiveUI.ReactiveCommand<Unit, Unit> GoOverview { get; }
    public ReactiveUI.ReactiveCommand<Unit, Unit> GoReports { get; }
    public ReactiveUI.ReactiveCommand<Unit, Unit> AddNotification { get; }
    public ReactiveUI.ReactiveCommand<Unit, Unit> TriggerError { get; }

    private bool _hasError;
    public bool HasError
    {
        get => _hasError;
        set => this.RaiseAndSetIfChanged(ref _hasError, value);
    }

    public DashboardViewModel()
    {
        GoOverview = ReactiveUI.ReactiveCommand.Create(() => CurrentTab = new OverviewTabViewModel());
        GoReports  = ReactiveUI.ReactiveCommand.Create(() => CurrentTab = new ReportsTabViewModel());

        AddNotification = ReactiveUI.ReactiveCommand.Create(() =>
        {
            Notifications.Insert(0, new NotificationItem
            {
                Title = "새 알림",
                Message = $"시각 {DateTime.Now:T}"
            });
            if (Notifications.Count > 50) Notifications.RemoveAt(Notifications.Count - 1);
        });

        TriggerError = ReactiveUI.ReactiveCommand.Create(() =>
        {
            HasError = true;
            RxApp.MainThreadScheduler.Schedule(TimeSpan.FromMilliseconds(450), () => HasError = false);
        });
    }
}

public sealed class NotificationItem { public string Title { get; set; } = ""; public string Message { get; set; } = ""; }
public sealed class OverviewTabViewModel { }
public sealed class ReportsTabViewModel { }
```

### View

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:ani="clr-namespace:Avalonia.Animation;assembly=Avalonia.Animation">
  <Grid ColumnDefinitions="*,320">
    <!-- 좌측: 탭 + 페이지 전환 -->
    <Grid Grid.Column="0" RowDefinitions="Auto,*" Margin="16">
      <StackPanel Orientation="Horizontal" Spacing="6">
        <Button Content="Overview" Command="{Binding GoOverview}"/>
        <Button Content="Reports"  Command="{Binding GoReports}"/>
      </StackPanel>

      <ContentControl Grid.Row="1" Content="{Binding CurrentTab}" Margin="0,12,0,0">
        <ContentControl.Transitions>
          <Transitions>
            <CrossFade Duration="0:0:0.25"/>
          </Transitions>
        </ContentControl.Transitions>
      </ContentControl>
    </Grid>

    <!-- 우측: 알림 리스트 + 오류 흔들림 -->
    <Grid Grid.Column="1" Margin="16" RowDefinitions="Auto,*" >
      <StackPanel Orientation="Horizontal" Spacing="6">
        <Button Content="Add Notification" Command="{Binding AddNotification}"/>
        <Button Content="Trigger Error" Command="{Binding TriggerError}"/>
      </StackPanel>

      <Border Grid.Row="1" Margin="0,8,0,0" Background="#151515" CornerRadius="8" Padding="8">
        <Border.Transitions>
          <Transitions>
            <DoubleTransition Property="Opacity" Duration="0:0:0.2"/>
            <DoubleTransition Property="RenderTransform.(TranslateTransform.X)" Duration="0:0:0.2"/>
          </Transitions>
        </Border.Transitions>

        <Border.RenderTransform>
          <TranslateTransform X="0"/>
        </Border.RenderTransform>

        <Border.Styles>
          <Style Selector="Border">
            <Style.Triggers>
              <DataTrigger Binding="{Binding HasError}" Value="True">
                <Setter Property="Opacity" Value="1"/>
                <Setter Property="RenderTransform.(TranslateTransform.X)" Value="-6"/>
              </DataTrigger>
            </Style.Triggers>
          </Style>
        </Border.Styles>

        <ScrollViewer>
          <ItemsControl Items="{Binding Notifications}">
            <ItemsControl.ItemTemplate>
              <DataTemplate>
                <Border Margin="0,6" Padding="10" Background="#222" CornerRadius="6">
                  <Border.Transitions>
                    <Transitions>
                      <DoubleTransition Property="Opacity" Duration="0:0:0.25"/>
                      <DoubleTransition Property="RenderTransform.(TranslateTransform.Y)" Duration="0:0:0.25"/>
                    </Transitions>
                  </Border.Transitions>
                  <Border.RenderTransform>
                    <TranslateTransform Y="10"/>
                  </Border.RenderTransform>
                  <StackPanel>
                    <TextBlock Text="{Binding Title}" FontWeight="Bold"/>
                    <TextBlock Text="{Binding Message}" Opacity="0.85"/>
                  </StackPanel>
                </Border>
              </DataTemplate>
            </ItemsControl.ItemTemplate>
          </ItemsControl>
        </ScrollViewer>
      </Border>
    </Grid>
  </Grid>
</Window>
```

---

## 코드에서 애니메이션 직접 실행(시퀀스/취소 지원)

```csharp
using ani = Avalonia.Animation;

public static class AnimSamples
{
    public static async Task PulseAsync(Control target, CancellationToken ct = default)
    {
        var anim = new ani.Animation
        {
            Duration = TimeSpan.FromMilliseconds(300),
            Easing = new QuadraticEaseOut(),
            AutoReverse = true,
            Children =
            {
                new ani.KeyFrame { Cue = new ani.Cue(0), Setters = { new Setter(ScaleTransform.ScaleXProperty, 1d), new Setter(ScaleTransform.ScaleYProperty, 1d) } },
                new ani.KeyFrame { Cue = new ani.Cue(1), Setters = { new Setter(ScaleTransform.ScaleXProperty, 1.1d), new Setter(ScaleTransform.ScaleYProperty, 1.1d) } },
            }
        };

        target.RenderTransform ??= new ScaleTransform();
        await anim.RunAsync(target, ct);
    }
}
```

> 긴 시퀀스는 여러 `Animation`을 이어 붙여 await 체인으로 구성. `CancellationToken`으로 사용자 조작 시 중단 가능.

---

## 흔한 문제와 해결

| 문제 | 원인/해결 |
|---|---|
| 전환이 안 보임 | `Content` 바뀌지 않음(동일 레퍼런스). 새 VM 인스턴스/참조를 보장 |
| 깜빡임/잔상 | 동시에 여러 전환/애니메이션 중첩. **한 번에 하나**로 제한 |
| Transform 적용 안 됨 | 해당 Transform 인스턴스를 미리 할당(예: `TranslateTransform`, `ScaleTransform`) |
| 레이아웃 점프 | 애니메이션 중 Margin/Width/Height 빈번 변경 → 대신 **Translate/Opacity** 사용 |
| 너무 느려 보임 | Duration 과도/이징 과장. 0.2~0.4s 권장 |
| 재로딩시 값 초기화 | `FillMode` 확인. 값 유지 필요하면 `FillMode="Forward"` |

---

## 요약

- **페이지 전환**: `ContentControl.Transitions`에서 `PageSlide`/`CrossFade`를 기본으로. 전역 재사용 컴포넌트(TransitionHost)로 표준화
- **컨트롤 애니메이션**: 단순 변화는 `DoubleTransition`, 복합/시퀀스는 `Avalonia.Animation` 키프레임
- **MVVM 결합**: 플래그 + `DataTrigger` 또는 `IAnimationService` 추상화로 **테스트 가능한 구조**
- **성능/UX**: Transform/Opacity 중심, 지속시간은 짧게, 접근성(모션 축소 옵션) 고려
- **테스트**: 상태 전환과 시각 효과를 분리하여 검증

이 가이드를 바탕으로, **MVVM을 유지하면서도 자연스러운 상호작용**을 갖춘 Avalonia UI를 구현할 수 있다.
