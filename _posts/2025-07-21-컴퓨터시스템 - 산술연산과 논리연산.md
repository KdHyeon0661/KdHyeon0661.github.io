---
layout: post
title: 컴퓨터시스템 - 산술연산과 논리연산
date: 2025-07-21 22:20:23 +0900
category: 컴퓨터시스템
---
# 🔢 산술연산과 논리연산

컴퓨터 시스템에서 데이터를 처리하는 핵심은 연산입니다. 산술연산은 수학적 계산을 수행하고, 논리연산은 비트 수준에서 데이터를 조작합니다. 이 두 연산은 프로그램의 거의 모든 동작의 근간이 됩니다.

---

## 📌 1. 산술연산 (Arithmetic Operations)

산술연산은 정수와 부동소수점 수에 대해 각각 다른 방식으로 수행됩니다.

### 🔸 1.1 정수 산술연산

정수는 보통 2의 보수 표현으로 저장되며, CPU는 이를 기반으로 덧셈, 뺄셈, 곱셈, 나눗셈을 수행합니다.

| 연산자 | 의미      |
|--------|-----------|
| `+`    | 덧셈      |
| `-`    | 뺄셈      |
| `*`    | 곱셈      |
| `/`    | 나눗셈    |
| `%`    | 나머지 연산 |

### 💡 C 예제: 정수 산술

```c
#include <stdio.h>

int main() {
    int a = 15, b = 4;
    printf("a + b = %d\n", a + b);  // 19
    printf("a - b = %d\n", a - b);  // 11
    printf("a * b = %d\n", a * b);  // 60
    printf("a / b = %d\n", a / b);  // 3
    printf("a %% b = %d\n", a % b); // 3
    return 0;
}
```

- `/` 연산은 **정수 나눗셈**으로 소수점 이하는 버려짐.
- `%`는 나머지를 반환.

---

### 🔸 1.2 부호 있는 vs 부호 없는 정수

정수 연산은 부호를 고려해야 결과가 정확합니다.

```c
unsigned int x = 4294967295; // 0xFFFFFFFF
int y = -1;

printf("%d\n", y);          // -1
printf("%u\n", y);          // 4294967295 (같은 비트를 unsigned로 해석)
```

- 동일한 비트 패턴이라도 signed/unsigned에 따라 다르게 해석됨.

---

### 🔸 1.3 오버플로우

- **정수 오버플로우**는 C에서 정의되지 않음(예측 불가).
- **unsigned**의 경우 오버플로우는 **모듈러 연산**으로 처리됨.

```c
unsigned char c = 255;
c = c + 1;  // 0 (오버플로우 발생, 256 → 0)
```

---

### 🔸 1.4 부동소수점 산술

부동소수점 연산은 IEEE 754 표준에 따라 수행됩니다. 정확한 표현을 위해 rounding, overflow, underflow 등이 발생할 수 있습니다.

```c
float a = 1.0f / 3.0f;
double b = 1.0 / 3.0;

printf("float: %.20f\n", a);
printf("double: %.20lf\n", b);
```

- `float`는 23비트, `double`은 52비트 가수로 정밀도 차이가 발생합니다.

---

## ⚙️ 2. 논리연산 (Logical / Bitwise Operations)

논리연산은 **비트 단위**로 데이터를 조작하는 데 사용됩니다.

### 🔸 2.1 비트 연산자

| 연산자 | 의미         | 설명                                  |
|--------|--------------|----------------------------------------|
| `&`    | AND          | 두 비트가 모두 1일 때만 1               |
| `|`    | OR           | 둘 중 하나라도 1이면 1                 |
| `^`    | XOR          | 다를 때 1                              |
| `~`    | NOT          | 비트 반전 (1 ↔ 0)                      |
| `<<`   | Left Shift   | 비트를 왼쪽으로 이동 (곱셈 효과)        |
| `>>`   | Right Shift  | 비트를 오른쪽으로 이동 (나눗셈 효과)    |

---

### 💡 C 예제: 비트 연산

```c
#include <stdio.h>

int main() {
    unsigned char a = 0b10101010;
    unsigned char b = 0b11001100;

    printf("AND: 0x%X\n", a & b);  // 0x88
    printf("OR : 0x%X\n", a | b);  // 0xEE
    printf("XOR: 0x%X\n", a ^ b);  // 0x66
    printf("NOT: 0x%X\n", ~a);     // 0x55 (반전)
    return 0;
}
```

---

### 🔸 2.2 쉬프트 연산의 의미

```c
unsigned char x = 4;     // 00000100

x = x << 1;  // 8 (00001000)
x = x >> 2;  // 2 (00000010)
```

- `x << n`은 `x * 2^n`
- `x >> n`은 `x / 2^n` (정수 나눗셈)

**주의:** signed 값을 오른쪽 shift할 때는 **산술 쉬프트**가 사용될 수도 있음 (부호 유지).

---

## 🧠 3. 논리연산 vs 논리연산자

C 언어에는 **비트 연산자** 외에 **논리 연산자**도 존재합니다:

| 연산자 | 의미   | 예시             |
|--------|--------|------------------|
| `&&`   | AND    | `(a > 0) && (b < 5)` |
| `||`   | OR     | `(x == y) || (z > 0)` |
| `!`    | NOT    | `!(flag)`         |

- 이 연산자들은 `0 == false`, `0이 아닌 값 == true` 로 간주하여 조건문에서 사용됩니다.
- **단락 평가(short-circuit evaluation)**를 수행하여 필요하지 않은 조건은 검사하지 않음.

---

## 🔍 4. 실전 활용

### 🔸 4.1 마스크(mask) 만들기

비트 마스크는 특정 비트만 추출하거나 조작할 때 유용합니다.

```c
unsigned int flags = 0b10101100;

// 하위 4비트 추출
unsigned int lower4 = flags & 0xF;  // 0b00001100

// 3번째 비트 켜기
flags |= (1 << 2);  // OR 마스크

// 7번째 비트 끄기
flags &= ~(1 << 6); // AND 마스크
```

---

## 🧾 5. 정리

- **산술연산**은 정수/부동소수점에 따라 수행 방식이 다르며, overflow, rounding 등을 주의해야 합니다.
- **논리연산**은 비트 단위로 데이터를 조작할 수 있으며, 효율적인 저수준 프로그래밍에 핵심입니다.
- **논리 연산자** (`&&`, `||`, `!`)와 **비트 연산자** (`&`, `|`, `^`, `~`, `<<`, `>>`)는 다릅니다.

---

## 📘 추천 읽을거리

- CS:APP 3rd Edition, Chapter 2 (Data Representations)
- IEEE 754 Floating-Point Standard
- C99 표준 문서: 산술연산 정의

---

이러한 저수준 연산들을 이해하는 것은 컴파일러가 코드를 어떻게 번역하고, 하드웨어가 어떤 방식으로 이를 처리하는지를 파악하는 데 중요한 기초가 됩니다.
