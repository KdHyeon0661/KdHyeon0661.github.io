---
layout: post
title: 컴퓨터시스템 - 산술연산과 논리연산
date: 2025-07-21 22:20:23 +0900
category: 컴퓨터시스템
---
# 산술연산과 논리연산

## 개요 — “덧셈 기호 하나에도 의미가 다르다”

- **정수 산술**: 고정 폭 \(w\)비트에서 수행되는 **모듈러 \(2^w\)** 계산(2의 보수).
- **부동소수점 산술**: IEEE 754 규약(정규/서브노멀/특수값, 반올림).
- **비트 연산**: 비트 수준 마스크/시프트/토글/필드 추출.
- **논리 연산자**(`&&`, `||`, `!`): **단락 평가** 기반의 조건식 제어.

---

## 정수 산술 — 2의 보수·모듈러·나눗셈 규칙

### 2의 보수와 모듈러 \(2^w\)

- \(w\)비트에서 정수 연산은 내부적으로
$$
S = (A \ \text{op}\ B) \bmod 2^w
$$
- **무부호**: 결과를 \(0..2^w-1\)로 해석.
- **부호 있는(2의 보수)**: 결과를 \([-2^{w-1}, 2^{w-1}-1]\)로 해석.

### 덧셈/뺄셈

```c
#include <stdio.h>
#include <stdint.h>

int main(void){
    uint8_t a=5, b=3;
    printf("5+3 = %u\n", (unsigned)(a+b));          // 8

    int8_t p=5, q=-3;
    printf("5+(-3) = %d\n", (int)(p+q));            // 2

    // 뺄셈은 A + (~B + 1)
    int8_t r = 5 + (int8_t)(~3 + 1);
    printf("5-3 = %d\n", (int)r);                   // 2
}
```

**오버플로 판정(부호 있는 덧셈)**:
$$
\text{OF}=\neg(a_{MSB}\oplus b_{MSB})\land(a_{MSB}\oplus s_{MSB})
$$

### 곱셈 — 시프트·가산의 합성

```c
#include <stdint.h>

uint32_t mul_u32_shiftadd(uint32_t a, uint32_t b){
    uint64_t acc=0;
    for(unsigned i=0;i<32;i++)
        if(b&(1u<<i)) acc += (uint64_t)a<<i;
    return (uint32_t)acc; // 하위 32비트(모듈러)
}
```

- 정확한 32×32→64 결과가 필요하면 **64비트 중간**을 사용.

### 나눗셈/나머지 — 부호 규약

C/C++/Java(표준 규약):
- 몫: **0을 향한 절단(truncation)**
- 나머지: \(a = q b + r\), \(|r| < |b|\), 부호는 **피제수(a)**와 동일.

```c
#include <stdio.h>

int main(void){
    printf("%d\n", 7/2);    // 3
    printf("%d\n", 7%2);    // 1
    printf("%d\n", -7/2);   // -3 (0쪽 절단)
    printf("%d\n", -7%2);   // -1
}
```

> 파이썬 `//`는 **바닥(floor)**, `%`는 \(0\le r<|b|\) (규약 차이 주의).

### 오버플로 정책(실무)

- **무부호**: 래핑이 정의됨(모듈러).
- **부호 있는(C/C++)**: 오버플로는 **UB(정의되지 않음)** → 내장 체크 사용을 권장.

```c
#include <stdbool.h>
#include <stdint.h>

bool add_checked_s32(int32_t a, int32_t b, int32_t* out){
#if defined(__has_builtin) && __has_builtin(__builtin_add_overflow)

    return __builtin_add_overflow(a,b,out); // 오버플로 시 true
#else

    int32_t s=a+b; *out=s;
    return ((a^s)&(b^s))<0;                 // 개념용 보조
#endif

}
```

- 필요에 따라 **포화(saturating)** 또는 **래핑(wrapping)** 정책을 명시.

---

## 부동소수점 산술 — 반올림·비결합성·정밀도

- IEEE 754:
  $$x=(-1)^s\cdot M \cdot 2^E$$
- 반올림 기본: **최근접, ties-to-even**.
- 연산은 일반적으로 **비결합적/비교환적**.

```c
#include <stdio.h>

int main(void){
    float  a = 1e20f, b=-1e20f, c=3.0f;
    printf("%.1f vs %.1f\n", (a+b)+c, a+(b+c)); // 3.0 vs 0.0 (소실)
}
```

- 비교는 **허용오차(절대+상대)** 기반:

```c
#include <math.h>

static int nearly_equal(double x, double y, double rel, double abs){
    double d=fabs(x-y);
    if(d<=abs) return 1;
    return d<=rel*fmax(fabs(x),fabs(y));
}
```

---

## 비트 연산 — 마스크·필드·토글·시프트

### 연산자 요약

| 연산자 | 의미 | 진리표 핵심 |
|---|---|---|
| `&` | AND | 둘 다 1일 때 1 |
| `|` | OR  | 둘 중 하나 1이면 1 |
| `^` | XOR | 다르면 1 |
| `~` | NOT | 1↔0 반전 |
| `<<`| 좌시프트 | 하위에 0 주입(무부호), 곱셈 효과 |
| `>>`| 우시프트 | 무부호=논리, 서명=구현정의(대개 산술) |

> **주의**: 서명형 좌시프트로 범위를 넘치게 만들면 UB. 우시프트의 산술/논리 구분도 구현정의.

### 마스크 패턴

```c
unsigned flags = 0b1010'1100u;

// 추출: 하위 4비트
unsigned lower4 = flags & 0xFu;

// 세팅: 비트2 켜기
flags |= (1u<<2);

// 클리어: 비트6 끄기
flags &= ~(1u<<6);

// 토글: 비트0 뒤집기
flags ^= (1u<<0);

// 테스트: 비트3?
int on = (flags>>3)&1u;   // 또는 (flags & (1u<<3)) != 0
```

### 필드 추출/삽입(예: 32비트 레이아웃)

```
[31..28] Opcode | [27..20] R | [19..12] G | [11..0] imm12
```

```c
#define OPC(x)   (((x)>>28)&0xF)
#define R(x)     (((x)>>20)&0xFF)
#define G(x)     (((x)>>12)&0xFF)
#define IMM12(x) ((x)&0xFFF)

static inline unsigned set_OPC(unsigned x, unsigned v){
    x &= ~(0xFu<<28);
    x |= (v&0xF)<<28;
    return x;
}
```

### 흔한 버그: 우선순위·괄호

```c
int x=3;
if (x & 1 == 0) { /* BUG */ }  // == 가 & 보다 우선
if ( (x & 1) == 0 ) { /* OK */ }
```

**우선순위(상대 비교)**:
단항 `~` > 시프트 `<< >>` > 관계 `< <= > >=` > **동등 `== !=`** > **비트 AND `&`** > XOR `^` > OR `|` > **논리 AND `&&`** > **논리 OR `||`**

---

## 논리 연산자 — 단락 평가와 제어 흐름

### 단락 평가(short-circuit)

```c
if (p && *p==42) { /* 안전: p==NULL이면 좌항 false, 우항 평가 안 함 */ }

if (is_ready() || init()) {
    // is_ready()가 true면 init()은 호출되지 않음
}
```

- **비트 연산자** `&`, `|`은 **항상 양쪽 평가**(부수효과 주의).
- 부울 정규화는 `!!x` (0 또는 1로 정규화).

```c
int truth = !!some_value;
```

### 논리와 비트의 구분

- `&&`, `||`, `!`: **부울 논리**(0/비0), **단락**.
- `&`, `|`, `^`, `~`: **비트 논리**(각 비트 조작), **단락 없음**.

---

## 시프트 — 빠른 2의 거듭제곱 연산과 라운딩

### 곱셈/나눗셈 대체

```c
int  mul = 3 << 2;   // 3*4 = 12
int  div = 16 >> 2;  // 16/4 = 4 (정수 나눗셈)
```

### 바닥/올림 몫(2^k로 나누기, 서명형)

- **바닥 몫**: 음수에 바이어스

$$
\left\lfloor \frac{x}{2^k}\right\rfloor = \frac{x + ((x<0)?(2^k-1):0)}{2^k}
$$

```c
int floor_div_pow2(int x, unsigned k){
    int bias = (x>>31) & ((1u<<k)-1);
    return (x + bias) >> k;
}
```

- **가장 가까운 정수** 반올림: `x += (x>=0?1<< (k-1): - (1<< (k-1))) ; x >>= k;`

> 서명형 우시프트는 구현정의. **무부호로 캐스팅**해 논리를 명확히 하거나, 위 바이어스 공식을 사용.

---

## 자주 쓰는 비트 트릭 (안전 버전)

### 2의 거듭제곱 판정

```c
int is_pow2_u32(uint32_t x){ return x && !(x & (x-1)); }
```

### 보정(2^k 배수 올림/내림)

```c
uint32_t align_up(uint32_t x, uint32_t a){ // a: power-of-two
    return (x + (a-1)) & ~(a-1);
}
uint32_t align_down(uint32_t x, uint32_t a){
    return x & ~(a-1);
}
```

### 절댓값(분기 없음, 서명 주의)

```c
int abs_branchless(int x){
    int m = x >> 31;         // 0x00000000 or 0xFFFFFFFF (산술 가정)
    return (x ^ m) - m;
}
```

### 바이트 스왑/회전(인트린식 활용 권장)

```c
#include <stdint.h>

uint32_t bswap32(uint32_t x){
    return ((x&0x000000FFu)<<24) | ((x&0x0000FF00u)<<8)
         | ((x&0x00FF0000u)>>8)  | ((x&0xFF000000u)>>24);
}
#if defined(_MSC_VER)
#  include <intrin.h>

uint32_t rol32(uint32_t x, unsigned r){ return _rotl(x,(int)r); }
#else

uint32_t rol32(uint32_t x, unsigned r){ return (x<<r) | (x>>(32-r)); }
#endif

```

### popcount/clz/ctz (존재하면 내장 사용)

```c
#include <stdint.h>

int pop_u32(uint32_t x){
#if defined(__has_builtin) && __has_builtin(__builtin_popcount)

    return __builtin_popcount(x);
#else

    // Kernighan trick
    int c=0; while(x){ x &= x-1; c++; } return c;
#endif

}
```

---

## 형 변환/승격 — “계산은 넓게, 저장 때 잘림”

### 일반 승격(usual integer promotions)

- `char`, `short` 등은 연산 전에 **int/unsigned int**로 승격.
- 예: `uint8_t a=200,b=100; uint8_t c=a+b;`
  → 계산은 **int**에서 `300`, 저장 시 8비트 **잘림** → `44`.

```c
#include <stdint.h>
#include <stdio.h>

int main(void){
    uint8_t a=200,b=100,c=a+b;
    printf("%u\n", c); // 44
}
```

### 서명/무부호 혼합

- 무부호가 랭크 우위면 **서명형이 무부호로 변환**.
  `(-1 < 1u)`는 보통 **거짓**.

---

## 부동소수점 vs 정수 — 차이 표

| 항목 | 정수 | 부동소수점 |
|---|---|---|
| 표현 | 2의 보수, 모듈러 \(2^w\) | IEEE 754(정규/서브노멀/특수) |
| 정확성 | 비트 정확 | 근사(반올림/ULP) |
| 오버플로 | 래핑(무부호)/UB(서명) | ±∞, NaN, inexact |
| 비교 | 정확한 `==` | 허용오차 기반 권장 |
| 결합성 | 성립 | 미성립(반올림) |

---

## 실전 예제 모음

### 권한 비트 필드

```c
enum { R=0, W=1, X=2 };
unsigned perms = 0;

// rw- 설정
perms |= (1u<<R) | (1u<<W);
perms &= ~(1u<<X);

// 체크
if (perms & (1u<<W)) { /* write 허용 */ }
```

### 고속 “/10” 근사 (정수, 상수곱)

```c
// x/10 ≈ (x * 0xCCCCCCCD) >> 35 (32비트 무부호, truncation)
// 컴파일러가 알아서 상수곱+시프트로 바꿔주기도 함.
```

### 안전한 합산(카한)

```c
double kahan(const double* a, int n){
    double s=0, c=0;
    for(int i=0;i<n;i++){
        double y=a[i]-c, t=s+y;
        c=(t-s)-y; s=t;
    }
    return s;
}
```

---

## 테스트 유틸 — 비트/우선순위/양쪽 평가 관찰

```c
#include <stdio.h>
#include <stdint.h>

static void bits32(uint32_t u){
    for(int i=31;i>=0;i--) putchar((u>>i)&1?'1':'0');
}

int side(const char* tag){ puts(tag); return 1; }

int main(void){
    // 비트 출력
    bits32(0xDEADBEEF); puts("");

    // 단락/양쪽 평가
    if (side("LHS") && side("RHS")) { /* RHS 호출됨 */ }
    if (side("LHS") &  side("RHS")) { /* 항상 둘 다 호출 */ }

    // 우선순위
    int x=3;
    if (x & 1 == 0) puts("BUG!");      // ==가 우선
    if ((x & 1) == 0) puts("OK");
}
```

---

## 요약 표

### 오버플로 판정(덧셈)

| 관점 | 판정 |
|---|---|
| 무부호 | 캐리 아웃(보통 CF) |
| 서명 | \(\neg(a_{MSB}\oplus b_{MSB}) \land (a_{MSB}\oplus s_{MSB})\) |

### 흔한 함정 → 안전 대체

| 함정 | 원인 | 해결 |
|---|---|---|
| `-1 < 1u` | 서명→무부호 변환 | 형 일치 후 비교 |
| `(x & 1 == 0)` | 우선순위 | 괄호 `(x & 1) == 0` |
| 서명 좌시프트 넘침 | UB | 무부호로 변환 후 시프트 |
| 부동 `==` 비교 | 반올림/ULP | 허용오차 비교 |
| 순차 합산 소실 | 비결합성 | 카한/페어와이즈 |

---

## 연습 문제

1) 8비트 서명 정수에서 `127+1`의 2의 보수 결과와 오버플로 여부를 판정하라.
2) `x`를 \(2^k\)로 나누어 **바닥 몫**을 얻는 공식을 코드로 작성하라.
3) 비트 필드 `[11..0]`을 `val`에서 추출하는 매크로를 작성하라.
4) 왜 `(a+b)+c`와 `a+(b+c)`가 부동소수점에서 다를 수 있는지 UL P 관점으로 설명하라.
5) `(-7)/2`와 `(-7)%2`를 C와 Python에서 각각 계산하고 차이를 설명하라.
6) popcount, clz/ctz를 인트린식과 폴백으로 구현하라.

---

## 참고 코드 — 안전/포화/래핑

```c
// A) 포화 덧셈(32비트)
#include <stdint.h>
#include <limits.h>

int32_t sat_add_s32(int32_t a, int32_t b){
    int64_t s=(int64_t)a+(int64_t)b;
    if(s>INT32_MAX) return INT32_MAX;
    if(s<INT32_MIN) return INT32_MIN;
    return (int32_t)s;
}

// B) 래핑(무부호)
static inline uint32_t add_wrap_u32(uint32_t a, uint32_t b){ return a+b; }

// C) 비교 허용오차
#include <math.h>

int nearly_equal_d(double a, double b){ return fabs(a-b) <= 1e-12 * fmax(fabs(a),fabs(b)); }
```

---

## 결론 — 규약을 알면 버그가 사라진다

정수 산술은 **모듈러**이며, 부동소수점은 **반올림**의 세계다.
비트 연산은 **표현/직렬화/제어**의 핵심 도구이고, 논리 연산자는 **평가 순서**로 안전을 보장한다.
**형 변환/우선순위/시프트/단락**의 규칙을 코드로 습관화하면,
성능과 정확성을 함께 얻을 수 있다.

> “정확성은 규칙에서, 견고함은 습관에서 온다.”
