---
layout: post
title: 컴퓨터시스템 - 메모리 매핑
date: 2025-08-30 16:20:23 +0900
category: 컴퓨터시스템
---
# 메모리 매핑(Memory Mapping) 자세히 이해하기

**메모리 매핑**은 파일이나 장치의 내용을 프로세스의 가상 주소 공간에 직접 연결(mapping)하여, 파일 데이터를 디스크 I/O 함수를 거치지 않고 **메모리 접근 방식**으로 읽고 쓸 수 있게 하는 기법입니다. 리눅스, 윈도우 등 대부분의 현대 운영체제는 효율적인 I/O 처리와 메모리 관리 최적화를 위해 이를 지원합니다.

---

## 1. 메모리 매핑의 개념

### 1.1 정의
- 파일의 일부 또는 전체를 **프로세스 가상 메모리**에 매핑
- 매핑된 영역은 일반 메모리처럼 접근 가능 (`*ptr = value;`)
- 페이지 폴트 시 OS가 해당 파일의 데이터를 물리 메모리에 로드

### 1.2 장점
- **고속 접근**: 커널 버퍼를 거치지 않고 유저 공간에서 직접 메모리 접근
- **코드 단순화**: read/write 대신 포인터 연산
- **페이지 캐시 활용**: 동일한 파일을 매핑한 여러 프로세스가 페이지 캐시 공유
- **지연 로딩**: 실제로 접근하는 페이지에 대해서만 I/O 발생(Demand Paging)

---

## 2. 메모리 매핑 방식

### 2.1 익명 매핑(Anonymous Mapping)
- 파일이 아닌 **메모리만 확보**하는 매핑
- 초기값은 0, swap 공간에 저장
- 예: `mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0)`

### 2.2 파일 매핑(File Mapping)
- 특정 파일 디스크립터와 연결
- 파일 내용을 메모리에 매핑 후 읽기/쓰기
- 파일 크기와 매핑 길이를 지정

### 2.3 장치 매핑(Device Mapping)
- `/dev/mem`, `/dev/fb0` 등 **하드웨어 메모리** 영역 매핑
- 디바이스 드라이버 및 OS 커널 모듈 개발에 활용

---

## 3. 매핑 속성

### 3.1 접근 권한
- `PROT_READ`, `PROT_WRITE`, `PROT_EXEC`
- 읽기 전용 매핑 시 쓰기 시그널(SIGSEGV) 발생

### 3.2 공유 여부
- **MAP_SHARED**: 매핑된 메모리 변경 시 파일에도 반영
- **MAP_PRIVATE**: 변경은 해당 프로세스에서만 보이며, Copy-On-Write로 구현

### 3.3 정렬
- 매핑 시작 주소와 길이는 페이지 크기(4KB 등)에 맞춰야 함
- offset은 반드시 페이지 크기의 배수여야 함

---

## 4. 동작 과정

1. `mmap()` 호출 → OS가 가상 주소 영역 예약
2. 매핑 영역 접근 시 **페이지 폴트** 발생
3. OS가 해당 파일 블록을 페이지 캐시에 로드
4. 이후 접근은 캐시에서 즉시 처리
5. **MAP_SHARED**의 경우 dirty 페이지는 주기적으로 디스크에 기록

---

## 5. C 언어 예제

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd = open("test.txt", O_RDWR);
    if (fd == -1) {
        perror("open");
        exit(1);
    }

    struct stat sb;
    fstat(fd, &sb);

    char *map = mmap(NULL, sb.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (map == MAP_FAILED) {
        perror("mmap");
        close(fd);
        exit(1);
    }

    // 파일 내용 출력
    printf("Original: %s\n", map);

    // 파일 내용 수정
    map[0] = 'H';
    map[1] = 'i';

    munmap(map, sb.st_size);
    close(fd);
    return 0;
}
```

---

## 6. 운영체제와 메모리 매핑

### 6.1 리눅스
- `/proc/<pid>/maps`로 프로세스의 매핑 영역 확인 가능
- ELF 실행 파일 로딩 시, 코드/데이터/라이브러리를 mmap 사용
- 페이지 캐시와 매핑 공유

### 6.2 윈도우
- `CreateFileMapping` + `MapViewOfFile` API 사용
- SEC_COMMIT, SEC_RESERVE, SEC_IMAGE 옵션 존재

---

## 7. 활용 사례

- **실행 파일 로드**: ELF, PE 포맷 실행 시 코드·데이터 영역을 mmap
- **공유 메모리 IPC**: 두 프로세스가 동일 파일을 매핑하여 데이터 공유
- **데이터베이스**: DBMS가 데이터 파일을 mmap으로 매핑해 페이지 캐시 이용
- **멀티미디어 처리**: 대용량 영상/이미지 파일을 빠르게 접근

---

## 8. 주의 사항

- 잘못된 포인터 접근 시 SIGSEGV
- 매핑 해제 전 파일 닫기 주의
- 동기화 필요 시 `msync()` 사용
- 파일 크기보다 긴 매핑 시 SIGBUS 발생 가능

---

## 9. 요약

메모리 매핑은 **파일과 메모리를 직접 연결**하여 고속 I/O, 간결한 코드, 페이지 캐시 공유라는 장점을 제공하지만, 동기화·정렬·권한 관리 등 세부 사항을 주의해야 합니다. 커널과 하드웨어의 페이지 관리 메커니즘을 이해하면 더 효율적으로 활용할 수 있습니다.