---
layout: post
title: 컴퓨터시스템 - 프로그램의 인코딩
date: 2025-07-21 19:20:23 +0900
category: 컴퓨터시스템
---
# 프로그램의 인코딩

## 1. 큰 그림: 번역·링크·로딩 파이프라인

C 프로그램이 실행되기까지의 표준 흐름은 다음과 같다.

```
소스(.c/.h)
    │  [전처리: include/매크로/조건컴파일]
    ▼
전처리 결과(.i)
    │  [컴파일: 파싱→IR→최적화→어셈블리 생성]
    ▼
어셈블리(.s)
    │  [어셈블: 기계어/오브젝트 + 재배치/심볼]
    ▼
오브젝트(.o)
    │  [링크: 심볼해결/재배치/합치기]
    ▼
실행파일(ELF/PE)
    │  [로더: 매핑/동적링킹/재배치/초기화]
    ▼
프로세스(메모리 맵에 적재 후 main 진입)
```

역사적으로는 **기계어 → 어셈블리 → 고급언어** 순으로 인간 친화적 표현이 발전했고, 현대에는 이 모든 단계를 **도구 체인(toolchain)** 이 자동화한다.

---

## 2. 전처리(Preprocessing): 텍스트 레벨의 확장

### 2.1 무엇을 하나?
- `#include` 병합, `#define` 매크로 치환, `#if/#ifdef` 조건부 컴파일, 라인 마커/진단 등.
- 결과물은 여전히 **C 문법의 텍스트**다(.i).

```c
// hello.c
#include <stdio.h>
#define MSG "Hello, World!\n"

int main() {
    printf(MSG);
    return 0;
}
```

전처리 출력 살펴보기:

```bash
gcc -E hello.c -o hello.i
```

핵심: 전처리는 **문자열 치환**이므로, 괄호/우선순위/부작용에 주의.

---

## 3. 컴파일(Compile): C → IR → 최적화 → 어셈블리

### 3.1 내부 단계 개요
1) **어휘/구문 분석**: 토큰화→파싱→AST 생성  
2) **의미 분석/타입 체크**  
3) **중간 표현(IR)** 생성(예: LLVM IR, GIMPLE), **SSA** 변환  
4) **최적화**: 상수 전파, Dead Code Elim, 루프 변환, 인라이닝, 별칭 분석, 벡터화  
5) **선택**: 머신 명령 선택(Instruction Selection)  
6) **레지스터 할당**: 선형 스캔/그래프 색칠  
7) **스케줄링**: 파이프라인/의존성 고려

### 3.2 어셈블리 산출 예(x86-64 SysV)

```c
// add.c
int add(int x, int y) { return x + y; }
```

```asm
# gcc -O2 -S add.c -o add.s 산출 예
        .globl  add
        .type   add, @function
add:
        lea     eax, [rdi + rsi]   # eax = x + y
        ret
```

### 3.3 최적화의 효과
- `lea` 로 산술 대체, 분기 제거(조건이동 `cmov`), 루프 언롤링, 벡터화(AVX/SSE).

> 실무 팁: **프로파일 유도 최적화(PGO)** 와 **링크 타임 최적화(LTO)** 를 함께 쓰면 대규모 코드 베이스에서 체감 성능을 얻기 쉽다.

---

## 4. 어셈블(Assemble): 기계어·섹션·재배치·심볼

### 4.1 오브젝트 파일(ELF .o)의 기본 섹션
| 섹션 | 의미 |
|---|---|
| `.text` | 코드 |
| `.rodata` | 상수/리터럴 |
| `.data` | 초기화 전역 |
| `.bss` | 제로 초기화 전역(파일 크기 미차지) |
| `.rela.*`/`.rel.*` | 재배치 엔트리 |
| `.symtab`/`.strtab` | 심볼/문자열 테이블 |
| `.debug_*` | DWARF 디버그 정보(옵션) |

```bash
readelf -S add.o
```

### 4.2 재배치(Relocation) 엔트리
오브젝트는 아직 **절대주소 미정**. 참조 지점에 “여기엔 나중에 이 심볼의 실제 주소를 넣어라” 라는 **재배치** 정보를 둔다.

수식 모델(개념):

$$
\text{최종주소} = \text{베이스} + \text{오프셋} + \text{addend}
$$

ELF는 아키텍처별로 다양한 재배치 타입(`R_X86_64_PC32`, `R_X86_64_GLOB_DAT`, `R_X86_64_JUMP_SLOT`, `R_X86_64_RELATIVE` 등)을 정의한다.

---

## 5. 링크(Link): 심볼 해결과 이미지 구성

### 5.1 정적 링크 vs 동적 링크
- **정적**: 필요한 라이브러리를 실행 파일에 **합쳐 넣음**(`.a`) → 독립적, 크기↑
- **동적**: 실행 시 **공유 라이브러리(.so/.dll)** 를 로딩 → 크기↓, 공유/업데이트 유리

### 5.2 심볼 해석과 중복
링커는 **정의/참조**를 맞추고, 라이브러리 검색 순서에 따라 해석한다.

```bash
# 순서 중요: -lfoo 가 -lbar 앞/뒤에 오느냐에 따라 달라질 수 있음
gcc main.o -lfoo -lbar -o app
```

### 5.3 ELF에서의 PLT/GOT (간접 호출, 지연 바인딩)
- **GOT(Global Offset Table)**: 함수/데이터의 런타임 주소 테이블
- **PLT(Procedure Linkage Table)**: 간접 점프용 스텁

호출 흐름(지연 바인딩):
```
call printf@PLT
 → PLT 스텁이 GOT 엔트리 확인
   (미해결이면) 동적 로더가 심볼 해석→GOT 채움
   이후엔 곧바로 실제 printf로 점프
```

옵션 `-Wl,-z,now` 로 **초기 바인딩**(즉시 해석) 가능.

---

## 6. 로딩(Loading): 실행 시 매핑·재배치·초기화

### 6.1 로더의 역할(ELF/Linux)
1) **프로그램 헤더(PT_*)** 읽고 **세그먼트(.text/.data 등)** 를 가상 주소에 매핑  
2) 필요 `.so` 탐색/매핑(`DT_NEEDED`)  
3) **재배치** 처리(PIE/PIC일수록 다수), 심볼 해석  
4) `.init_array`/C++ 전역 생성자 호출 → `main` 호출

프로세스 시작 진입점:

```asm
# _start → __libc_start_main(main, argc, argv, ... ) → main → exit
```

### 6.2 메모리 맵(개념)
```
[스택]
[힙]
[bss]      (RW, zero-init)
[data]     (RW)
[text]     (RX)
[공유 라이브러리들] (각각 매핑)
[vDSO/ld-linux]
```

ASLR이 활성화되면 각 매핑의 베이스가 매 실행마다 바뀐다.

---

## 7. 위치 독립 코드(PIC)와 실행 파일(PIE), ASLR

### 7.1 PIC의 핵심: 절대주소 회피
RIP(프로그램 카운터) 상대 참조 사용:

```asm
# x86-64 PIC 예
lea     rax, [rip + msg@GOTPCREL]
mov     rdi, [rax]
```

### 7.2 PIE: 실행 파일도 위치 독립
- `-fPIE -pie` 로 빌드 → 실행 파일 자체도 베이스 무작위화 가능
- 보안 기법 **ASLR** 와 결합해 ROP/JOP 난이도 상승

---

## 8. 예제: 정적/동적/공유 라이브러리, PLT/GOT 관찰

### 8.1 프로젝트 구성
```
.
├─ libadd.c          # int add(int,int){ return x+y; }
├─ main.c            # add() 호출 후 printf
```

```c
// libadd.c
int add(int x, int y) { return x + y; }
```

```c
// main.c
#include <stdio.h>
int add(int,int);
int main(){
    printf("sum=%d\n", add(3,5));
    return 0;
}
```

### 8.2 정적 링크
```bash
gcc -c libadd.c -o libadd.o
ar rcs libadd.a libadd.o

gcc main.c libadd.a -o app_static
ls -l app_static   # 크기 큼
ldd app_static     # 보통 libc 등만 동적, 혹은 완전 정적으로도 가능
```

### 8.3 동적 링크(공유 라이브러리)
```bash
gcc -fPIC -c libadd.c -o libadd.pic.o
gcc -shared -o libadd.so libadd.pic.o

gcc main.c ./libadd.so -Wl,-rpath,. -o app_shared
ldd app_shared          # libadd.so 나열됨
objdump -d app_shared | grep PLT -n  # PLT 사용 관찰
```

### 8.4 PLT/GOT 흐름 보기
```bash
objdump -d app_shared | less
readelf -r app_shared | less     # 재배치(R_X86_64_JUMP_SLOT 등)
```

---

## 9. ELF 섹션 vs 세그먼트, 심볼/디버깅

### 9.1 섹션(빌드 관점)과 세그먼트(로딩 관점)
- **섹션**: 링크/재배치/심볼의 조직 단위(`.text/.data/.bss/.rodata/...`)
- **세그먼트**: 로더가 매핑하는 단위(PT_LOAD), 권한(R/X/W)

```bash
readelf -hW app        # 헤더
readelf -SW app        # 섹션
readelf -lW app        # 프로그램 헤더(세그먼트)
```

### 9.2 심볼/디버그 정보
- `.symtab/.strtab` (정적 심볼), `.dynsym/.dynstr` (동적 심볼)
- DWARF: 소스 라인 매핑/변수/프레임 정보 → `gdb`, `addr2line`

```bash
nm -D app_shared       # 동적 심볼 테이블
objdump --dwarf=info app -w
```

---

## 10. 재배치 수학: 왜 필요한가?

정의: 컴파일·어셈블 시점에는 아직 **최종 배치 주소**를 모른다.  
따라서 “나중에” 채워 넣기 위한 **재배치 엔트리**가 필요.

대표적 관계식:

$$
\text{PC상대 즉치} = \text{심볼실주소} - \text{이 지시어의 다음 주소}
$$

$$
\text{GOT 엔트리} = \text{심볼실주소}
\quad\Rightarrow\quad
\text{로드 시 } \text{GOT}[i] \leftarrow \text{resolve}(\text{symbol})
$$

ELF의 `RELATIVE` 는 “베이스 + addend” 만으로 해결 가능해 빠르다(PIE 성능 핵심).

---

## 11. CRT(startup)과 수명 주기: _start → main → 종료

### 11.1 진입과 종료
- 엔트리 `_start` 는 링커 스크립트/CRT 오브젝트에서 제공(`crt1.o`, `crti.o`, `crtn.o`)
- `_start` → 스택에서 `argc/argv/envp/auxv` 준비 → `__libc_start_main(main, ...)`
- `main` 반환 후 `atexit` 등록 함수/`fini_array` 실행

### 11.2 C++ 전역 생성자/소멸자
- `.init_array`/`.fini_array` 의 함수 포인터들이 자동 호출
- 동적 링크 시 **라이브러리 단위**로도 유사 흐름 적용

---

## 12. LTO/PGO와 현대 최적화, 빌드 실전

### 12.1 LTO
링크 타임에 전체 IR을 모아 **전역 최적화** 수행(인라이닝/제거/상수화).

```bash
gcc -O3 -flto main.c libadd.c -o app_lto
```

### 12.2 PGO(프로파일 유도)
실행 프로파일을 수집→그에 맞춰 재컴파일.

```bash
gcc -fprofile-generate -O2 app.c -o app.gen
./app.gen <실제 워크로드>
gcc -fprofile-use -O3 app.c -o app.pgo
```

---

## 13. Windows/PE와의 비교(개요)

| 항목 | ELF/Linux | PE/Windows |
|---|---|---|
| 포맷 | ELF | PE/COFF |
| 동적 테이블 | `DT_*` | Import Table / IAT |
| 간접 호출 | PLT/GOT | IAT(Import Address Table) |
| 호출 규약 | SysV AMD64 | Windows x64 (인자 RCX,RDX,R8,R9) |
| 로더 | ld-linux / rtld | ntdll/Kernel32 로딩 체계 |

지연 로딩(Delay-Load), SxS, UCRT 등 윈도우 생태계 특성도 고려 필요.

---

## 14. 안전과 성능: 보안 하드닝·런타임 비용

| 기법 | 효과 | 코멘트 |
|---|---|---|
| PIE+ASLR | 주소 무작위화 | ROP/JOP 방어에 기여 |
| NX(DEP) | 데이터 실행 금지 | W^X 원칙 강화 |
| RELRO | GOT 보호 | `-Wl,-z,relro,-z,now` |
| Stack Canary | 스택 오버플로 탐지 | `-fstack-protector-strong` |
| CFI | 제어 흐름 무결성 | Clang/LLVM 계열 옵션 |

성능 고려: PLT 지연 바인딩, PIE의 PC상대 참조 등 미세 오버헤드가 있으나 일반적으론 **보안 이점 > 비용**.

---

## 15. 디버깅/리버스 엔지니어링: 도구 맛보기

```bash
# 어셈블리/심볼/섹션/재배치
objdump -d -M intel app
readelf -aW app
nm -D app

# 실행 파일이 의존하는 공유 라이브러리
ldd app

# 주소→소스 라인
addr2line -e app 0x401234
```

런타임 계측: `perf`, `valgrind`(memcheck/cachegrind), `gprof`, `callgrind`.

---

## 16. 실습: 소스→바이너리 전 과정 따라 해보기

### 16.1 소스
```c
// hello.c
#include <stdio.h>
extern int twice(int);
int main(void) {
    printf("%d\n", twice(21));
    return 0;
}
```

```c
// twice.c
int twice(int x){ return x*2; }
```

### 16.2 빌드 단계별 산출물 보기
```bash
# 전처리
gcc -E hello.c -o hello.i

# 컴파일(어셈블리 산출)
gcc -S -O2 twice.c -o twice.s

# 오브젝트
gcc -c hello.c -o hello.o
gcc -c twice.c -o twice.o

# 링크
gcc hello.o twice.o -o hello

# 구조 관찰
readelf -SW hello
readelf -lW hello
nm -D hello
objdump -d hello | less
```

### 16.3 공유 라이브러리로 바꿔보기
```bash
gcc -fPIC -c twice.c -o twice.pic.o
gcc -shared -o libtwice.so twice.pic.o
gcc hello.c -L. -ltwice -Wl,-rpath,. -o hello_so
ldd hello_so
```

---

## 17. 자주 겪는 문제와 해결책

| 증상 | 원인 | 해결 |
|---|---|---|
| `undefined reference to foo` | 심볼 미해결(라이브러리 순서/누락) | 링크 순서 조정, `-l` 추가, `nm` 로 확인 |
| 런타임 `symbol lookup error` | 동적 심볼 해석 실패 | `LD_LIBRARY_PATH`/`rpath` 설정, SONAME 일치 |
| 주소 랜덤으로 재현 불가 | ASLR | `setarch -R` 또는 `/proc/sys/kernel/randomize_va_space`(실험 환경에서만) |
| 성능 급감 | 잘못된 -O/PGO/LTO, PLT 지연비용 | `-Wl,-z,now`, `-fno-plt`, 프로파일 재학습 |
| 크래시: 스택 오염 | 호출 규약 위반/va_args 오용 | 함수 시그니처/정렬/가변인자 처리 재점검 |

---

## 18. 역사적 맥락 한눈에 보기

- **1950s**: 기계어/어셈블리, 초기 컴파일러(FORTRAN)  
- **1970s**: C/UNIX, 포터블 시스템 프로그래밍  
- **1980s**: RISC 운동, ELF 확산(유닉스 계열), 동적 링크 서막  
- **1990s**: OO 언어 보급, OOO CPU, 분기 예측/캐시 아키텍처 고도화  
- **2000s**: x86-64, JIT VM(HotSpot/.NET), SSE/AVX  
- **2010s**: AArch64, PIE/ASLR 기본, LTO/PGO 실무 보편화  
- **2020s**: RISC-V 확산, CFI/하드닝 기본값 강화, 대규모 LTO

---

## 19. 심화: 엔트리/스택 프레임/초기 스택 레이아웃

프로세스 진입 직후 스택에는 다음이 올라온다(플랫폼별 차이 존재):

```
argc
argv[0] ... argv[argc-1]
NULL
envp[0] ... envp[n-1]
NULL
auxv[0].type, auxv[0].val
...
AT_NULL, 0
```

CRT 초기화 코드는 이를 정리해 `main(argc, argv, envp)` 로 전달. `auxv`는 로더/커널이 전달하는 실행 환경(예: 페이지 크기, vDSO 주소 등).

---

## 20. 수학으로 보는 주소/재배치 간단 공식

PIC의 PC상대 참조(ELF/x86-64)에서는:

$$
\text{참조값} = \text{심볼실주소} - \text{(이 지시어의 다음 주소)}
$$

`R_X86_64_RELATIVE` 재배치는:

$$
*\!(\text{reloc.addr}) \leftarrow \text{베이스주소} + \text{addend}
$$

점프 슬롯(`JUMP_SLOT`) 초기 바인딩은:

$$
\text{GOT[func]} \leftarrow \text{해석된 함수 엔트리 주소}
$$

---

## 21. 체크리스트: “소스→실행”을 정확히 이해하기 위해

1) 전처리 결과(.i)를 열어 **매크로/인클루드** 확장을 실제로 본다.  
2) `-S` 로 어셈블리(.s)를 만든 뒤 최적화 패턴을 확인한다.  
3) 오브젝트(.o)의 **재배치/심볼**을 `readelf -r/ -s` 로 본다.  
4) 실행 파일의 **세그먼트/섹션/동적 의존성**을 `readelf -l/-S`, `ldd` 로 확인한다.  
5) PLT/GOT 흐름을 `objdump -d`, `readelf -r` 로 추적한다.  
6) PIC/PIE 빌드와 ASLR 하에서 주소가 **매 실행 달라짐**을 관찰한다.  
7) LTO/PGO 를 적용하고 성능·크기 차이를 측정한다.  

---

## 22. 부록: 작은 실험 모음

### 22.1 `-fno-plt` vs 기본
```bash
gcc -O2 -fno-plt main.c -o a_no_plt
objdump -d a_no_plt | grep plt -n   # 차이 관찰
```

### 22.2 초기 바인딩(지연 바인딩 제거)
```bash
gcc main.c -Wl,-z,now -o a_now
```

### 22.3 LD_PRELOAD 인터포지션
```c
// hook.c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
void* malloc(size_t n){
  void* (*real_malloc)(size_t)=dlsym(RTLD_NEXT,"malloc");
  void* p=real_malloc(n);
  fprintf(stderr,"malloc(%zu) = %p\n", n, p);
  return p;
}
```

```bash
gcc -shared -fPIC hook.c -o hook.so -ldl
LD_PRELOAD=./hook.so ./hello
```

---

## 결론

프로그램의 “인코딩”은 텍스트를 바이트로 바꾸는 단순한 변환이 아니다.  
전처리의 텍스트 확장, 컴파일러의 IR/최적화/명령선택, 어셈블러의 재배치/심볼 생성,  
링커의 심볼 해석과 이미지 구성, 로더의 매핑·동적 링크·초기화까지 **연속된 공정**이다.

이 흐름을 **수직으로** 이해하면,
- 링크 오류나 런타임 심볼 에러를 빠르게 해결하고,  
- 성능 병목(PLT 오버헤드, 잘못된 인라이닝, 비PIC 코드 등)을 제거하며,  
- PIE/ASLR/NX/RELRO/Canary 같은 보안 하드닝을 올바르게 적용할 수 있다.

결국 “컴퓨터가 코드를 이해한다”는 말은,
**정해진 포맷과 규약**에 따라 0과 1을 해석·연결·배치·실행한다는 뜻이다.  
그 규약의 **언어(ELF/ABI/ISA/IR)** 를 익히는 것이, 실무자의 힘이다.