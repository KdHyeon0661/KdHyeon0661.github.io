---
layout: post
title: 컴퓨터시스템 - 프로그램의 인코딩
date: 2025-07-21 19:20:23 +0900
category: 컴퓨터시스템
---
# 📦 프로그램의 인코딩: 소스 코드에서 실행 파일까지

현대의 컴퓨터는 우리가 작성한 C 코드 같은 고급 언어를 직접 이해하지 못합니다. 이 코드들은 일련의 번역 과정을 거쳐 **기계어(binary)**로 변환되어야만 CPU가 실행할 수 있습니다. 이 글에서는 프로그램이 어떻게 기계 수준의 표현으로 인코딩되는지, 그 역사적 맥락과 현재의 구현 방식까지 자세히 다룹니다.

---

## 1. 프로그램 번역의 전체 흐름

C 프로그램이 실행되기까지 다음과 같은 과정을 거칩니다:

1. **전처리기 (Preprocessor)**
2. **컴파일러 (Compiler)**
3. **어셈블러 (Assembler)**
4. **링커 (Linker)**

이를 간단히 도식화하면:

```c
// hello.c
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
```

```
[1] hello.c            // 소스 코드
 |
 | (cpp: 전처리기)
 V
[2] hello.i            // 전처리된 코드
 |
 | (cc1: 컴파일러)
 V
[3] hello.s            // 어셈블리어 코드
 |
 | (as: 어셈블러)
 V
[4] hello.o            // 오브젝트 파일
 |
 | (ld: 링커)
 V
[5] a.out              // 실행 가능한 바이너리
```

---

## 2. 어셈블리어와 기계어

### 🔧 어셈블리어란?
어셈블리어는 CPU에 종속적인 **저수준 언어**입니다. 사람이 읽을 수 있는 심볼로 구성되며, 각 명령어는 고유한 기계어로 대응됩니다.

예시:
```asm
movl $1, %eax       # eax 레지스터에 1 저장
movl $0, %ebx       # ebx 레지스터에 0 저장
int $0x80           # 소프트웨어 인터럽트 - 시스템 호출
```

이것은 다음과 같은 **바이너리**로 인코딩됩니다:
```
b8 01 00 00 00   // movl $1, %eax
bb 00 00 00 00   // movl $0, %ebx
cd 80            // int $0x80
```

---

## 3. ELF 오브젝트 파일 구조

### 📁 ELF: Executable and Linkable Format

리눅스에서는 프로그램, 라이브러리, 커널 모듈 등 거의 모든 바이너리 파일이 **ELF** 포맷을 따릅니다.

ELF 파일은 크게 다음과 같은 **섹션(Section)** 으로 구성됩니다:

| 섹션명        | 설명                            |
|---------------|---------------------------------|
| .text         | 실행 가능한 코드                |
| .data         | 초기화된 전역변수               |
| .bss          | 초기화되지 않은 전역변수        |
| .rodata       | 읽기 전용 데이터 (상수 등)      |
| .symtab       | 심볼 테이블 (디버깅용)          |
| .rel.text     | 텍스트 영역에 대한 재배치 정보  |
| .strtab       | 문자열 테이블                   |

이들은 나중에 링커에 의해 병합되고 재배치되어 하나의 실행 가능한 이미지로 구성됩니다.

---

## 4. 메모리에서의 실행 구조

프로그램이 실행될 때 메모리는 다음처럼 구성됩니다:

```
+-----------------+
|      스택       |
|-----------------|
|      힙         |
|-----------------|
|    .bss         |
|-----------------|
|    .data        |
|-----------------|
|    .text        |
+-----------------+
```

- **.text**: 실행 코드 (읽기 전용)
- **.data**: 초기화된 전역 변수 (읽기/쓰기 가능)
- **.bss**: 초기화되지 않은 전역 변수 (런타임에 0으로 초기화)
- **힙**: 동적 메모리 (malloc 등)
- **스택**: 지역 변수, 함수 호출 프레임

---

## 5. 함수 호출과 레지스터

x86-64 시스템에서의 함수 호출 예:

```c
int add(int x, int y) {
    return x + y;
}

int main() {
    int result = add(3, 5);
    return result;
}
```

어셈블리 변환 예:
```asm
add:
    movl %edi, %eax   # x -> eax
    addl %esi, %eax   # y + eax
    ret

main:
    movl $3, %edi     # x = 3
    movl $5, %esi     # y = 5
    call add
    movl %eax, %ebx   # result -> ebx
    movl %ebx, %eax
    ret
```

레지스터 용도:

| 레지스터 | 용도               |
|----------|--------------------|
| %rdi     | 첫 번째 인자       |
| %rsi     | 두 번째 인자       |
| %rax     | 반환값             |
| %rbp     | 프레임 포인터      |
| %rsp     | 스택 포인터        |

---

## 6. 심볼(Symbol)과 디버깅 정보

컴파일러는 각 함수, 전역 변수 등을 **심볼**로 관리합니다.

### 📌 심볼 테이블 (Symbol Table)

- 오브젝트 파일의 `.symtab`, `.strtab` 섹션에 저장
- 디버깅 정보로 활용 (gdb, objdump 등)
- 링커는 심볼을 기준으로 다른 오브젝트 파일과 결합함

예시:
```bash
$ nm hello.o
0000000000000000 T main
000000000000000a T add
```

---

## 7. 정적 링킹과 동적 링킹

### 🔗 정적 링킹 (Static Linking)

- 필요한 라이브러리를 모두 포함하여 실행 파일 생성
- 실행 파일 크기 증가
- 배포가 쉬움 (라이브러리 필요 없음)

### 🔗 동적 링킹 (Dynamic Linking)

- 실행 시에 필요한 `.so` 공유 라이브러리를 불러옴
- 실행 파일 크기 작음
- 라이브러리 업데이트가 용이

```bash
ldd /bin/ls
```
출력:
```
linux-vdso.so.1 =>  (0x00007ffcefdff000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8d9d5d0000)
```

---

## 8. 위치 독립 코드 (PIC)

공유 라이브러리는 여러 프로세스에서 함께 사용되므로, **절대 주소를 포함하지 않는 코드**가 필요합니다. 이를 **PIC (Position-Independent Code)** 라고 합니다.

```asm
mov rax, qword ptr [rip + offset]   ; RIP-relative addressing
```

이 방식은 ASLR(Address Space Layout Randomization) 같은 보안 기법과도 잘 작동합니다.

---

## 9. 주소 재배치 (Relocation)과 로더

### 📦 링커의 역할

- 오브젝트 파일을 결합하여 심볼을 해결
- 주소를 재배치하여 코드와 데이터 배치

### 🧠 로더의 역할

- 실행 시 바이너리를 메모리에 로드
- 필요한 동적 라이브러리 로딩
- 재배치 테이블을 바탕으로 실제 주소 반영

---

## ✅ 정리

| 단계 | 설명                       | 산출물 |
|------|----------------------------|--------|
| 전처리 | #define, #include 처리     | .i 파일 |
| 컴파일 | 고급 언어 → 어셈블리어     | .s 파일 |
| 어셈블 | 어셈블리어 → 기계어        | .o 파일 |
| 링킹   | 오브젝트 파일 연결         | 실행 파일 |

이러한 과정을 통해 우리가 작성한 고수준 언어 프로그램은 점차 **기계어로 인코딩**되어 실제로 CPU에서 실행 가능한 형태로 변화합니다.

---

## 💬 마무리

"컴퓨터가 코드를 이해한다"는 것은 결국 **0과 1의 나열로 치환된 규약**을 따르는 것입니다. 프로그램의 인코딩 과정을 이해하면, 버그 해결, 성능 최적화, 보안 강화 등 실무적인 문제를 훨씬 더 잘 다룰 수 있습니다.