---
layout: post
title: WPF - 다크모드 테마 적용
date: 2025-09-07 16:25:23 +0900
category: WPF
---
# 🌙 WPF **다크모드 테마 적용** 완전 정복
*(예제 중심 · 누락 없이 최대한 자세하게 · 라이트/다크/고대비 + 자동 동기화/수동 토글/퍼포먼스/트러블슈팅까지)*

> 이 글은 WPF에서 **라이트/다크 테마**를 **안전하고 확장 가능**하게 적용하는 **표준 설계**를 단계별로 안내합니다.  
> 핵심은 **팔레트 키(토큰)** → **컨트롤 스타일** → **테마 스위처(런타임 교체)** → **OS/고대비 동기화** 순서입니다.  
> 코드 조각은 .NET 5+ 기준이며 .NET Framework 4.8에서도 거의 동일하게 동작합니다.

---

## 0) 목표 아키텍처 (요약)

1. **팔레트 키(토큰) 설계**  
   - `Palette.Background`, `Palette.Foreground`, `Palette.Accent`, `Palette.Border` … 같은 **의미 기반 키**를 만든다.
2. **테마별 리소스 사전**  
   - `Themes/Colors.Light.xaml`, `Themes/Colors.Dark.xaml`, (선택) `Themes/Colors.HighContrast.xaml`
3. **컨트롤 스타일은 전부 DynamicResource**  
   - 색·폰트·간격 등 **바뀔 수 있는 값**은 **`{DynamicResource …}`** 로 참조한다.
4. **테마 스위처 서비스**  
   - `Application.Current.Resources.MergedDictionaries` 중 팔레트 사전 **엔트리를 교체**한다.
5. **OS 테마/고대비 동기화 + 수동 토글**  
   - 레지스트리/시스템 이벤트로 **자동 감지**, 메뉴/토글 스위치로 **수동 전환**도 제공.
6. **성능/안정성**  
   - StaticResource 남발 금지(테마 반영 안 됨), Animation·가상화 주의, Brush 공유 주의.

---

## 1) 폴더 구조 & App.xaml 머지

```
YourApp/
  Themes/
    Colors.Light.xaml
    Colors.Dark.xaml
    Controls.xaml
  App.xaml
  MainWindow.xaml
  Services/ThemeService.cs
  Services/OsThemeWatcher.cs
```

**App.xaml**
```xml
<Application x:Class="ThemeDemo.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml">
  <Application.Resources>
    <ResourceDictionary>
      <ResourceDictionary.MergedDictionaries>
        <!-- ⚠️ 팔레트 사전(테마별 교체 대상)은 맨 앞에 두면 관리가 쉽습니다 -->
        <ResourceDictionary Source="Themes/Colors.Light.xaml"/>
        <ResourceDictionary Source="Themes/Controls.xaml"/>
      </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
  </Application.Resources>
</Application>
```

> 팁: **팔레트 사전과 컨트롤 사전은 분리**하세요. 테마 전환 때는 **팔레트 사전만** 교체하면 됩니다.

---

## 2) 팔레트(테마) 정의

### 2.1 Colors.Light.xaml
```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <!-- 기본 바탕/텍스트/포커스/엑센트/경계 -->
  <SolidColorBrush x:Key="Palette.Background"    Color="#FFFFFFFF"/>
  <SolidColorBrush x:Key="Palette.Foreground"    Color="#111827"/> <!-- slate-900 -->
  <SolidColorBrush x:Key="Palette.SubtleText"    Color="#6B7280"/> <!-- gray-500 -->
  <SolidColorBrush x:Key="Palette.Border"        Color="#E5E7EB"/> <!-- gray-200 -->
  <SolidColorBrush x:Key="Palette.Accent"        Color="#2563EB"/> <!-- blue-600 -->
  <SolidColorBrush x:Key="Palette.AccentHover"   Color="#1D4ED8"/> <!-- blue-700 -->
  <SolidColorBrush x:Key="Palette.AccentPressed" Color="#1E40AF"/> <!-- blue-800 -->
  <SolidColorBrush x:Key="Palette.Card"          Color="#FFFFFFFF"/>
  <SolidColorBrush x:Key="Palette.CardBorder"    Color="#E5E7EB"/>
  <SolidColorBrush x:Key="Palette.Danger"        Color="#EF4444"/>
  <SolidColorBrush x:Key="Palette.Success"       Color="#22C55E"/>

  <!-- 표준 치수/코너/두께(필요시 Double/Thickness 등도 토큰화) -->
  <Thickness x:Key="Space.ControlPadding">12,7</Thickness>
  <CornerRadius x:Key="Radius.Control">10</CornerRadius>
</ResourceDictionary>
```

### 2.2 Colors.Dark.xaml
```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <SolidColorBrush x:Key="Palette.Background"    Color="#0B1220"/> <!-- 아주 어두운 블루톤 -->
  <SolidColorBrush x:Key="Palette.Foreground"    Color="#E5E7EB"/>
  <SolidColorBrush x:Key="Palette.SubtleText"    Color="#9CA3AF"/>
  <SolidColorBrush x:Key="Palette.Border"        Color="#1F2937"/>
  <SolidColorBrush x:Key="Palette.Accent"        Color="#3B82F6"/>
  <SolidColorBrush x:Key="Palette.AccentHover"   Color="#2563EB"/>
  <SolidColorBrush x:Key="Palette.AccentPressed" Color="#1D4ED8"/>
  <SolidColorBrush x:Key="Palette.Card"          Color="#111827"/>
  <SolidColorBrush x:Key="Palette.CardBorder"    Color="#1F2937"/>
  <SolidColorBrush x:Key="Palette.Danger"        Color="#F87171"/>
  <SolidColorBrush x:Key="Palette.Success"       Color="#34D399"/>

  <Thickness x:Key="Space.ControlPadding">12,7</Thickness>
  <CornerRadius x:Key="Radius.Control">10</CornerRadius>
</ResourceDictionary>
```

> **키 이름(토큰)을 절대 바꾸지 마세요.** 전환은 **값만 달라지는 것**이 핵심입니다.  
> 나중에 하이콘트라스트 테마를 추가해도 **동일 키**만 채우면 됩니다.

---

## 3) 컨트롤 스타일(Controls.xaml) — **DynamicResource**만 사용

```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

  <!-- Window/페이지 배경 -->
  <Style TargetType="Window">
    <Setter Property="Background" Value="{DynamicResource Palette.Background}"/>
    <Setter Property="Foreground" Value="{DynamicResource Palette.Foreground}"/>
  </Style>

  <!-- 버튼 -->
  <Style TargetType="Button" x:Key="Btn.Accent">
    <Setter Property="Foreground"      Value="{DynamicResource Palette.Background}"/>
    <Setter Property="Background"      Value="{DynamicResource Palette.Accent}"/>
    <Setter Property="BorderBrush"     Value="{DynamicResource Palette.Border}"/>
    <Setter Property="Padding"         Value="{DynamicResource Space.ControlPadding}"/>
    <Setter Property="Cursor"          Value="Hand"/>
    <Setter Property="Template">
      <Setter.Value>
        <ControlTemplate TargetType="Button">
          <Border x:Name="Chrome"
                  Background="{TemplateBinding Background}"
                  BorderBrush="{TemplateBinding BorderBrush}"
                  BorderThickness="1.4"
                  CornerRadius="{DynamicResource Radius.Control}">
            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"
                              Margin="{TemplateBinding Padding}"/>
          </Border>
          <ControlTemplate.Triggers>
            <Trigger Property="IsMouseOver" Value="True">
              <Setter TargetName="Chrome" Property="Background" Value="{DynamicResource Palette.AccentHover}"/>
            </Trigger>
            <Trigger Property="IsPressed" Value="True">
              <Setter TargetName="Chrome" Property="Background" Value="{DynamicResource Palette.AccentPressed}"/>
            </Trigger>
            <Trigger Property="IsEnabled" Value="False">
              <Setter TargetName="Chrome" Property="Opacity" Value="0.6"/>
            </Trigger>
          </ControlTemplate.Triggers>
        </ControlTemplate>
      </Setter.Value>
    </Setter>
  </Style>

  <!-- 카드/컨테이너 -->
  <Style TargetType="ContentControl" x:Key="Card">
    <Setter Property="Template">
      <Setter.Value>
        <ControlTemplate TargetType="ContentControl">
          <Border Background="{DynamicResource Palette.Card}"
                  BorderBrush="{DynamicResource Palette.CardBorder}"
                  BorderThickness="1"
                  CornerRadius="{DynamicResource Radius.Control}"
                  Padding="14">
            <ContentPresenter/>
          </Border>
        </ControlTemplate>
      </Setter.Value>
    </Setter>
  </Style>

  <!-- TextBlock 기본 -->
  <Style TargetType="TextBlock">
    <Setter Property="Foreground" Value="{DynamicResource Palette.Foreground}"/>
  </Style>
</ResourceDictionary>
```

> **중요**: 테마 전환 즉시 반영을 원한다면 **항상 DynamicResource**를 쓰세요. StaticResource는 고정됩니다.

---

## 4) 화면 사용 예 (MainWindow.xaml)

```xml
<Window x:Class="ThemeDemo.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Dark Mode Demo" Width="640" Height="420">
  <Grid>
    <Grid.RowDefinitions>
      <RowDefinition Height="Auto"/>
      <RowDefinition/>
    </Grid.RowDefinitions>

    <StackPanel Orientation="Horizontal" Margin="16" Spacing="8">
      <Button Style="{StaticResource Btn.Accent}" Content="라이트" Click="Light_Click"/>
      <Button Style="{StaticResource Btn.Accent}" Content="다크"   Click="Dark_Click"/>
      <ToggleButton x:Name="SyncToggle" Content="OS 동기화"
                    Checked="SyncToggle_Checked" Unchecked="SyncToggle_Unchecked" Margin="8,0,0,0"/>
    </StackPanel>

    <ContentControl Grid.Row="1" Style="{StaticResource Card}" Margin="16">
      <StackPanel Spacing="6">
        <TextBlock Text="다크모드 데모" FontSize="20" FontWeight="SemiBold"/>
        <TextBlock Text="라이트/다크 버튼으로 전환하거나, OS와 동기화해 보세요."
                   Foreground="{DynamicResource Palette.SubtleText}"/>
        <StackPanel Orientation="Horizontal" Spacing="8" Margin="0,8,0,0">
          <Button Style="{StaticResource Btn.Accent}" Content="확인"/>
          <Button Content="취소"/>
        </StackPanel>
      </StackPanel>
    </ContentControl>
  </Grid>
</Window>
```

---

## 5) 테마 스위처 서비스 (팔레트 사전 교체)

**Services/ThemeService.cs**
```csharp
using System;
using System.Linq;
using System.Windows;

namespace ThemeDemo.Services
{
    public enum AppTheme { Light, Dark }

    public static class ThemeService
    {
        // 팔레트 사전 파일 경로
        private static readonly Uri LightUri = new("Themes/Colors.Light.xaml", UriKind.Relative);
        private static readonly Uri DarkUri  = new("Themes/Colors.Dark.xaml",  UriKind.Relative);

        public static AppTheme Current { get; private set; } = AppTheme.Light;

        /// <summary>팔레트 사전을 라이트/다크로 교체</summary>
        public static void Apply(AppTheme theme)
        {
            var appRes = Application.Current?.Resources;
            if (appRes == null) return;

            var merged = appRes.MergedDictionaries;
            // 팔레트 사전을 "Colors."로 식별 (팀 규칙으로 접두사 고정 권장)
            var idx = merged
                .Select((d, i) => (d, i))
                .FirstOrDefault(t => t.d.Source?.OriginalString.Contains("Colors.") == true).i;

            var newDict = new ResourceDictionary { Source = (theme == AppTheme.Light ? LightUri : DarkUri) };

            if (idx >= 0) merged[idx] = newDict;
            else merged.Insert(0, newDict);

            Current = theme;
        }

        /// <summary>현재 테마와 반대로 토글</summary>
        public static void Toggle() =>
            Apply(Current == AppTheme.Light ? AppTheme.Dark : AppTheme.Light);
    }
}
```

**MainWindow.xaml.cs**
```csharp
using System.Windows;
using ThemeDemo.Services;

public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        // 시작 테마를 OS 설정으로 동기화하려면 아래에서 OsThemeWatcher.GetInitialTheme() 활용 (뒤 섹션 참고)
        ThemeService.Apply(AppTheme.Light);
    }

    private void Light_Click(object sender, RoutedEventArgs e) => ThemeService.Apply(AppTheme.Light);
    private void Dark_Click(object sender, RoutedEventArgs e)  => ThemeService.Apply(AppTheme.Dark);

    private OsThemeWatcher? _watcher;

    private void SyncToggle_Checked(object sender, RoutedEventArgs e)
    {
        _watcher ??= new OsThemeWatcher(theme => Dispatcher.Invoke(() => ThemeService.Apply(theme)));
        _watcher.Start();
    }

    private void SyncToggle_Unchecked(object sender, RoutedEventArgs e) => _watcher?.Stop();
}
```

---

## 6) OS 테마(라이트/다크) 자동 동기화

Windows 10/11에서 **레지스트리**의  
`HKCU\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize`  
- `AppsUseLightTheme` (DWORD, **1**=라이트, **0**=다크)  
- `SystemUsesLightTheme` (DWORD, OS 시스템 UI)

를 보면 **앱 테마 기준**을 알 수 있습니다.

다음은 **레지스트리 변경 감지** + **시작 시 초기값 가져오기** 예제입니다.

**Services/OsThemeWatcher.cs**
```csharp
using System;
using System.Runtime.InteropServices;
using System.Threading;
using Microsoft.Win32;
using ThemeDemo.Services;

public sealed class OsThemeWatcher : IDisposable
{
    // 경로/값 이름
    private const string KeyPath = @"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize";
    private const string ValueName = "AppsUseLightTheme"; // 1 = Light, 0 = Dark

    private readonly Action<AppTheme> _onThemeChanged;
    private Thread? _thread;
    private bool _running;
    private IntPtr _regKey = IntPtr.Zero;

    public OsThemeWatcher(Action<AppTheme> onThemeChanged) => _onThemeChanged = onThemeChanged;

    public static AppTheme GetInitialTheme()
    {
        using var key = Registry.CurrentUser.OpenSubKey(KeyPath, false);
        var value = (int?)key?.GetValue(ValueName, 1) ?? 1;
        return value == 0 ? AppTheme.Dark : AppTheme.Light;
    }

    public void Start()
    {
        if (_running) return;
        _running = true;
        _thread = new Thread(WatchLoop) { IsBackground = true };
        _thread.Start();
    }

    public void Stop()
    {
        _running = false;
        if (_regKey != IntPtr.Zero) RegCloseKey(_regKey);
        _regKey = IntPtr.Zero;
    }

    private void WatchLoop()
    {
        if (RegOpenKeyEx(HKEY_CURRENT_USER, KeyPath, 0, KEY_READ, out _regKey) != 0) return;

        while (_running)
        {
            // 레지스트리 키 변경 통지 대기
            var status = RegNotifyChangeKeyValue(_regKey, false, REG_NOTIFY_CHANGE_LAST_SET, IntPtr.Zero, false);
            if (status != 0) break;
            var theme = GetInitialTheme();
            _onThemeChanged(theme);
        }
    }

    public void Dispose() => Stop();

    #region Win32 P/Invoke
    private static readonly UIntPtr HKEY_CURRENT_USER = (UIntPtr)0x80000001;
    private const int KEY_READ = 0x20019;
    private const int REG_NOTIFY_CHANGE_LAST_SET = 0x00000004;

    [DllImport("advapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern int RegOpenKeyEx(UIntPtr hKey, string subKey, int ulOptions, int samDesired, out IntPtr hkResult);

    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern int RegNotifyChangeKeyValue(IntPtr hKey, bool bWatchSubtree, int dwNotifyFilter, IntPtr hEvent, bool fAsynchronous);

    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern int RegCloseKey(IntPtr hKey);
    #endregion
}
```

> 위 구현은 **RegNotifyChangeKeyValue**로 **실시간 변경**을 받습니다.  
> 더 간단히 하고 싶다면 **타이머로 주기 폴링**하거나, Windows Community Toolkit의 ThemeListener 유틸을 참고하세요.

**시작 테마를 OS에 맞추기**
```csharp
public MainWindow()
{
    InitializeComponent();
    ThemeService.Apply(OsThemeWatcher.GetInitialTheme());
}
```

---

## 7) 고대비(High Contrast) 대응

Windows 고대비 모드는 **일반 라이트/다크와 별개**입니다.  
WPF에서는 `SystemParameters.HighContrast`와 `SystemParameters.StaticPropertyChanged`로 감지합니다.

```csharp
using System.ComponentModel;
using System.Windows;

public partial class App : Application
{
    protected override void OnStartup(StartupEventArgs e)
    {
        base.OnStartup(e);

        // 초기 적용
        ApplyHighContrastIfNeeded();

        // 동적 변경 감시
        SystemParameters.StaticPropertyChanged += OnSysParamsChanged;
    }

    private void OnSysParamsChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(SystemParameters.HighContrast))
            ApplyHighContrastIfNeeded();
    }

    private void ApplyHighContrastIfNeeded()
    {
        if (SystemParameters.HighContrast)
        {
            // (선택) 고대비 팔레트 사전으로 전환
            // Application.Current.Resources.MergedDictionaries[0] = new ResourceDictionary { Source = new Uri("Themes/Colors.HighContrast.xaml", UriKind.Relative) };

            // 또는 시스템 리소스를 직접 사용
            Resources["Palette.Background"] = SystemColors.WindowBrush;
            Resources["Palette.Foreground"] = SystemColors.WindowTextBrush;
            Resources["Palette.Border"]     = SystemColors.WindowFrameBrush;
            // Accent 대체 등 추가 설정
        }
        else
        {
            // 고대비 해제 시, 현재 앱 테마(라이트/다크)로 되돌림
            ThemeDemo.Services.ThemeService.Apply(ThemeDemo.Services.ThemeService.Current);
        }
    }
}
```

> 고대비 모드에서는 **시스템 브러시를 DynamicResource로 참조**하면 OS 변경에 자동 반응합니다:
> ```xml
> Background="{DynamicResource {x:Static SystemColors.WindowBrushKey}}"
> ```

---

## 8) 사용자 설정 보존 (재실행 시 유지)

**Properties/Settings.settings** 에 `UserTheme` (string) 추가(값: `Light`/`Dark`/`OsSync` 등).

```csharp
// 저장
Properties.Settings.Default.UserTheme = "Dark";
Properties.Settings.Default.Save();

// 로드
var pref = Properties.Settings.Default.UserTheme;
switch (pref)
{
    case "Dark": ThemeService.Apply(AppTheme.Dark); break;
    case "Light": ThemeService.Apply(AppTheme.Light); break;
    case "OsSync":
        ThemeService.Apply(OsThemeWatcher.GetInitialTheme());
        // 감시 시작
        break;
}
```

> **기업/엔터프라이즈** 환경에서는 Roaming Profile/레지스트리/로컬 JSON 등 저장소 선택을 표준화하세요.

---

## 9) DataGrid 등 복잡 컨트롤 스타일링 팁

- 복잡 컨트롤은 **리소스 키를 최소 단위(Brush/Thickness)로 토큰화**하고 모두 DynamicResource로.
- 스크롤바, 선택 배경, 헤더 브러시 등 **중첩된 템플릿**까지 팔레트 키를 흘려보내면 전환 품질이 높아집니다.

```xml
<!-- 예: DataGrid 기본 브러시를 토큰으로 재매핑 -->
<SolidColorBrush x:Key="{x:Static SystemColors.HighlightBrushKey}" Color="{Binding Source={DynamicResource Palette.Accent}, Path=Color}"/>
<SolidColorBrush x:Key="{x:Static SystemColors.ControlBrushKey}"   Color="{Binding Source={DynamicResource Palette.Card},   Path=Color}"/>
```

> **주의:** 일부 시스템 키 override는 예상치 못한 영향이 있으니, 가급적 **컨트롤 스타일 안에서** `DynamicResource Palette.*`를 참조하는 방식이 안전합니다.

---

## 10) 이미지/아이콘의 다크모드 대응

- **벡터 아이콘(PathGeometry)** 를 사용하고 **Stroke/Fill을 팔레트 브러시**로 바꿔치기.
- 비트맵 아이콘은 **라이트/다크 버전**을 각각 준비하고 `Trigger`로 교체.

```xml
<Image Width="16" Height="16">
  <Image.Style>
    <Style TargetType="Image">
      <Setter Property="Source" Value="/Assets/Icons/light/close.png"/>
      <Style.Triggers>
        <DataTrigger Binding="{Binding Source={x:Static local:ThemeService.Current}}" Value="Dark">
          <Setter Property="Source" Value="/Assets/Icons/dark/close.png"/>
        </DataTrigger>
      </Style.Triggers>
    </Style>
  </Image.Style>
</Image>
```

> 더 깔끔하게 하려면 **FontIcon(아이콘 폰트)** + Foreground 팔레트 매핑을 추천합니다.

---

## 11) 성능 & 안정성 체크리스트

- [ ] **DynamicResource**는 **필요한 경로에만** 사용 (팔레트/색/폰트/간격).  
- [ ] **TemplateBinding** 우선(템플릿 내부 경량 바인딩).  
- [ ] Brush/Geometry는 **Freezable** → 공유 애니메이션 금지(필요 시 `x:Shared="False"`).  
- [ ] **가상화**(ItemsControl) 유지: `ItemsPresenter`/`VirtualizingStackPanel` 파괴 금지.  
- [ ] **테마 교체 빈도**가 높다면, **재측정(Re-measure) 폭**을 줄이도록 스타일/템플릿 바인딩 최소화.  
- [ ] **StaticResource**로 굳어버린 곳(테마 미반영) 없는지 정기 점검.

---

## 12) 트러블슈팅

**Q1. 테마를 바꿨는데 어떤 요소는 색이 안 바뀌어요.**  
- StaticResource로 참조했을 가능성 ↑ → **DynamicResource로 교체**하세요.  
- 팔레트 사전이 **맨 앞**이 아니거나, **동일 키가 더 가까운 스코프**에 덮였을 수 있음.

**Q2. 브러시 Color만 바꾸면 UI가 안 바뀌네요.**  
- DynamicResource는 **사전 엔트리 교체**에 반응합니다. **새 브러시 인스턴스**로 교체하세요.  
  ```csharp
  Application.Current.Resources["Palette.Accent"] = new SolidColorBrush(Colors.Orange);
  ```

**Q3. 레지스트리 감시가 동작 안 해요.**  
- 권한/경로 오타 확인, `RegOpenKeyEx` 반환값/스레드 실행 여부 확인.  
- 간단히는 **주기 폴링**(타이머)도 실무에서 충분히 안정적입니다.

**Q4. 하이콘트라스트 전환 시 색이 이상해요.**  
- 고대비 모드에서는 **시스템 브러시**를 우선 사용하거나, 별도 `Colors.HighContrast.xaml`을 제공하세요.

---

## 13) 확장: 외부 라이브러리/멀티 어셈블리 테마

다른 어셈블리의 테마 사전을 사용할 때는 **pack URI**를 사용합니다.

```xml
<ResourceDictionary Source="pack://application:,,,/MyLib;component/Themes/Colors.Dark.xaml"/>
```

> 라이브러리(NuGet)로 **CustomControl**을 배포한다면, **Generic.xaml** 기본 템플릿이  
> 팔레트 토큰을 참조하고, **호스트 앱**이 해당 토큰을 재정의(라이트/다크)하는 구조가 가장 유연합니다.

---

## 14) 테스트 전략

- **시각 스냅샷**: 라이트/다크 각각 렌더한 이미지를 픽셀 비교해 회귀 검출.  
- **자동 UI 테스트**: 테마 전환 → 주요 화면 요소의 실제 색/스타일 속성 값 검증.  
- **성능**: 전환 직후 레이아웃/렌더 프레임 드롭 유무를 샘플링.

---

## 15) 미니 레퍼런스

- **라이트/다크 판단 레지스트리**:  
  `HKCU\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize\AppsUseLightTheme`  
- **고대비 감지**: `SystemParameters.HighContrast`  
- **시스템 브러시**: `SystemColors.*Key` → `DynamicResource`로 참조  
- **전환 핵심**: **MergedDictionaries의 팔레트 사전 교체** + **모든 컨트롤은 DynamicResource**

---

## 16) 전체 예제(붙여 넣어 동작)

> 위 섹션 코드만 복사해도 동작합니다.  
> 추가로 원하시면 **샘플 솔루션**(라이트/다크/고대비 + OS 동기화 + 단위 테스트 골격)을 만들어 드릴 수 있어요.

---

### 결론

- **토큰화 → DynamicResource → 사전 교체**가 다크모드의 정석입니다.  
- **OS 동기화**와 **고대비 대응**을 넣으면 엔터프라이즈 품질로 올라갑니다.  
- 성능을 위해 **필요한 경로만 동적화**, 나머지는 `TemplateBinding/StaticResource`로 최적화하세요.
