---
layout: post
title: WPF - 다크모드 테마 적용
date: 2025-09-07 16:25:23 +0900
category: WPF
---
# WPF 다크모드 테마 적용: 완벽한 구현 가이드

WPF 애플리케이션에 다크모드를 구현하는 것은 단순한 색상 변경을 넘어, 체계적인 아키텍처 설계와 일관된 구현 패턴이 필요한 작업입니다. 이 가이드는 실무에서 바로 적용할 수 있는 완전한 다크모드 구현 솔루션을 단계별로 제시합니다.

## 다크모드 아키텍처 설계

효율적인 다크모드 시스템은 세 가지 핵심 계층으로 구성됩니다:

1. **팔레트 토큰 계층**: 의미 기반의 색상 키를 정의 (`Palette.Background`, `Palette.Foreground` 등)
2. **테마 리소스 계층**: 라이트/다크/고대비 테마별 실제 색상 값 제공
3. **컨트롤 스타일 계층**: 모든 UI 컴포넌트가 팔레트 토큰을 참조하도록 구성

이 계층적 접근 방식은 테마 전환을 단순한 리소스 사전 교체로 가능하게 하며, 애플리케이션의 모든 부분이 일관되게 반응할 수 있도록 보장합니다.

## 프로젝트 구조 설계

다음과 같은 폴더 구조로 시작하는 것이 좋습니다:

```
YourApplication/
├── Themes/
│   ├── Colors.Light.xaml      # 라이트 테마 색상 정의
│   ├── Colors.Dark.xaml       # 다크 테마 색상 정의
│   ├── Colors.HighContrast.xaml # 고대비 테마 색상 정의
│   └── Controls.xaml          # 컨트롤 스타일 정의
├── Services/
│   ├── ThemeService.cs        # 테마 관리 서비스
│   └── OsThemeWatcher.cs      # OS 테마 변경 감지
├── App.xaml                   # 애플리케이션 리소스 설정
└── MainWindow.xaml           # 메인 윈도우
```

## 팔레트 토큰 설계

팔레트 토큰은 색상의 의미를 추상화한 키입니다. 이러한 토큰을 사용하면 테마별로 실제 색상 값을 변경하면서도 UI 코드는 동일하게 유지될 수 있습니다.

### Colors.Light.xaml - 라이트 테마

```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    
    <!-- 배경 색상 -->
    <SolidColorBrush x:Key="Palette.Background" Color="#FFFFFFFF"/>
    <SolidColorBrush x:Key="Palette.CardBackground" Color="#FFFFFFFF"/>
    <SolidColorBrush x:Key="Palette.Surface" Color="#F9FAFB"/>
    
    <!-- 텍스트 색상 -->
    <SolidColorBrush x:Key="Palette.Foreground" Color="#111827"/>
    <SolidColorBrush x:Key="Palette.SecondaryText" Color="#6B7280"/>
    <SolidColorBrush x:Key="Palette.DisabledText" Color="#9CA3AF"/>
    
    <!-- 강조 색상 -->
    <SolidColorBrush x:Key="Palette.Primary" Color="#2563EB"/>
    <SolidColorBrush x:Key="Palette.PrimaryHover" Color="#1D4ED8"/>
    <SolidColorBrush x:Key="Palette.PrimaryPressed" Color="#1E40AF"/>
    
    <!-- 상태 색상 -->
    <SolidColorBrush x:Key="Palette.Success" Color="#22C55E"/>
    <SolidColorBrush x:Key="Palette.Warning" Color="#F59E0B"/>
    <SolidColorBrush x:Key="Palette.Error" Color="#EF4444"/>
    
    <!-- 경계선 색상 -->
    <SolidColorBrush x:Key="Palette.Border" Color="#E5E7EB"/>
    <SolidColorBrush x:Key="Palette.Divider" Color="#D1D5DB"/>
    
    <!-- 치수 토큰 -->
    <CornerRadius x:Key="Radius.Small">4</CornerRadius>
    <CornerRadius x:Key="Radius.Medium">8</CornerRadius>
    <CornerRadius x:Key="Radius.Large">12</CornerRadius>
    
    <Thickness x:Key="Spacing.Small">4</Thickness>
    <Thickness x:Key="Spacing.Medium">8</Thickness>
    <Thickness x:Key="Spacing.Large">16</Thickness>
    
</ResourceDictionary>
```

### Colors.Dark.xaml - 다크 테마

```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    
    <!-- 배경 색상 (다크 테마는 더 어두운 색상 사용) -->
    <SolidColorBrush x:Key="Palette.Background" Color="#0F172A"/>
    <SolidColorBrush x:Key="Palette.CardBackground" Color="#1E293B"/>
    <SolidColorBrush x:Key="Palette.Surface" Color="#334155"/>
    
    <!-- 텍스트 색상 (다크 테마는 더 밝은 색상 사용) -->
    <SolidColorBrush x:Key="Palette.Foreground" Color="#F1F5F9"/>
    <SolidColorBrush x:Key="Palette.SecondaryText" Color="#94A3B8"/>
    <SolidColorBrush x:Key="Palette.DisabledText" Color="#64748B"/>
    
    <!-- 강조 색상 (라이트 테마보다 약간 밝은 색상) -->
    <SolidColorBrush x:Key="Palette.Primary" Color="#3B82F6"/>
    <SolidColorBrush x:Key="Palette.PrimaryHover" Color="#2563EB"/>
    <SolidColorBrush x:Key="Palette.PrimaryPressed" Color="#1D4ED8"/>
    
    <!-- 상태 색상 -->
    <SolidColorBrush x:Key="Palette.Success" Color="#34D399"/>
    <SolidColorBrush x:Key="Palette.Warning" Color="#FBBF24"/>
    <SolidColorBrush x:Key="Palette.Error" Color="#F87171"/>
    
    <!-- 경계선 색상 -->
    <SolidColorBrush x:Key="Palette.Border" Color="#475569"/>
    <SolidColorBrush x:Key="Palette.Divider" Color="#64748B"/>
    
    <!-- 치수 토큰 (라이트 테마와 동일) -->
    <CornerRadius x:Key="Radius.Small">4</CornerRadius>
    <CornerRadius x:Key="Radius.Medium">8</CornerRadius>
    <CornerRadius x:Key="Radius.Large">12</CornerRadius>
    
    <Thickness x:Key="Spacing.Small">4</Thickness>
    <Thickness x:Key="Spacing.Medium">8</Thickness>
    <Thickness x:Key="Spacing.Large">16</Thickness>
    
</ResourceDictionary>
```

중요한 점은 **토큰 이름을 변경하지 않는 것**입니다. 라이트와 다크 테마는 동일한 토큰 이름을 사용하지만 다른 색상 값을 가집니다.

## 컨트롤 스타일에서 DynamicResource 사용

테마 전환 시 즉시 반응하려면 모든 컨트롤 스타일이 `DynamicResource`를 사용해야 합니다.

### Controls.xaml - 컨트롤 스타일 정의

```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    
    <!-- 윈도우 기본 스타일 -->
    <Style TargetType="Window">
        <Setter Property="Background" Value="{DynamicResource Palette.Background}"/>
        <Setter Property="Foreground" Value="{DynamicResource Palette.Foreground}"/>
        <Setter Property="FontFamily" Value="Segoe UI"/>
        <Setter Property="FontSize" Value="14"/>
    </Style>
    
    <!-- 기본 버튼 스타일 -->
    <Style TargetType="Button" x:Key="PrimaryButton">
        <Setter Property="Foreground" Value="{DynamicResource Palette.Background}"/>
        <Setter Property="Background" Value="{DynamicResource Palette.Primary}"/>
        <Setter Property="BorderBrush" Value="{DynamicResource Palette.Primary}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Padding" Value="{DynamicResource Spacing.Medium}"/>
        <Setter Property="Margin" Value="{DynamicResource Spacing.Small}"/>
        <Setter Property="Cursor" Value="Hand"/>
        <Setter Property="FontWeight" Value="SemiBold"/>
        
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="Button">
                    <Border x:Name="Border"
                            Background="{TemplateBinding Background}"
                            BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            CornerRadius="{DynamicResource Radius.Medium}">
                        
                        <ContentPresenter HorizontalAlignment="Center"
                                          VerticalAlignment="Center"
                                          Margin="{TemplateBinding Padding}"/>
                    </Border>
                    
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="True">
                            <Setter TargetName="Border" 
                                    Property="Background" 
                                    Value="{DynamicResource Palette.PrimaryHover}"/>
                            <Setter TargetName="Border" 
                                    Property="BorderBrush" 
                                    Value="{DynamicResource Palette.PrimaryHover}"/>
                        </Trigger>
                        
                        <Trigger Property="IsPressed" Value="True">
                            <Setter TargetName="Border" 
                                    Property="Background" 
                                    Value="{DynamicResource Palette.PrimaryPressed}"/>
                            <Setter TargetName="Border" 
                                    Property="BorderBrush" 
                                    Value="{DynamicResource Palette.PrimaryPressed}"/>
                        </Trigger>
                        
                        <Trigger Property="IsEnabled" Value="False">
                            <Setter TargetName="Border" Property="Opacity" Value="0.6"/>
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    
    <!-- 텍스트 박스 스타일 -->
    <Style TargetType="TextBox">
        <Setter Property="Background" Value="{DynamicResource Palette.CardBackground}"/>
        <Setter Property="Foreground" Value="{DynamicResource Palette.Foreground}"/>
        <Setter Property="BorderBrush" Value="{DynamicResource Palette.Border}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Padding" Value="{DynamicResource Spacing.Small}"/>
        <Setter Property="CaretBrush" Value="{DynamicResource Palette.Primary}"/>
        <Setter Property="SelectionBrush" Value="{DynamicResource Palette.Primary}"/>
        <Setter Property="SelectionOpacity" Value="0.3"/>
        
        <Style.Triggers>
            <Trigger Property="IsKeyboardFocused" Value="True">
                <Setter Property="BorderBrush" Value="{DynamicResource Palette.Primary}"/>
                <Setter Property="BorderThickness" Value="2"/>
            </Trigger>
        </Style.Triggers>
    </Style>
    
    <!-- 카드 스타일 -->
    <Style x:Key="CardStyle" TargetType="Border">
        <Setter Property="Background" Value="{DynamicResource Palette.CardBackground}"/>
        <Setter Property="BorderBrush" Value="{DynamicResource Palette.Border}"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="CornerRadius" Value="{DynamicResource Radius.Medium}"/>
        <Setter Property="Padding" Value="{DynamicResource Spacing.Large}"/>
    </Style>
    
    <!-- 구분선 스타일 -->
    <Style x:Key="DividerStyle" TargetType="Separator">
        <Setter Property="Background" Value="{DynamicResource Palette.Divider}"/>
        <Setter Property="Margin" Value="0,{DynamicResource Spacing.Medium}"/>
    </Style>
    
</ResourceDictionary>
```

## 애플리케이션 리소스 설정

App.xaml에서 리소스 사전을 로드합니다:

```xml
<Application x:Class="YourApplication.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml"
             Startup="Application_Startup">
    
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <!-- 팔레트 사전 (테마별로 교체됨) -->
                <ResourceDictionary Source="Themes/Colors.Light.xaml"/>
                
                <!-- 컨트롤 스타일 사전 (고정) -->
                <ResourceDictionary Source="Themes/Controls.xaml"/>
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
    
</Application>
```

## 테마 관리 서비스 구현

테마 전환을 관리하는 서비스 클래스를 구현합니다:

```csharp
using System;
using System.ComponentModel;
using System.Linq;
using System.Windows;

namespace YourApplication.Services
{
    public enum ApplicationTheme
    {
        Light,
        Dark,
        HighContrast
    }
    
    public class ThemeChangedEventArgs : EventArgs
    {
        public ApplicationTheme NewTheme { get; }
        public ApplicationTheme OldTheme { get; }
        
        public ThemeChangedEventArgs(ApplicationTheme newTheme, ApplicationTheme oldTheme)
        {
            NewTheme = newTheme;
            OldTheme = oldTheme;
        }
    }
    
    public static class ThemeManager
    {
        private static ApplicationTheme _currentTheme = ApplicationTheme.Light;
        
        public static ApplicationTheme CurrentTheme
        {
            get => _currentTheme;
            private set
            {
                if (_currentTheme != value)
                {
                    var oldTheme = _currentTheme;
                    _currentTheme = value;
                    OnThemeChanged(new ThemeChangedEventArgs(value, oldTheme));
                }
            }
        }
        
        // 테마 변경 이벤트
        public static event EventHandler<ThemeChangedEventArgs> ThemeChanged;
        
        // 테마별 리소스 사전 URI
        private static readonly Uri LightThemeUri = 
            new Uri("Themes/Colors.Light.xaml", UriKind.Relative);
        
        private static readonly Uri DarkThemeUri = 
            new Uri("Themes/Colors.Dark.xaml", UriKind.Relative);
        
        private static readonly Uri HighContrastThemeUri = 
            new Uri("Themes/Colors.HighContrast.xaml", UriKind.Relative);
        
        /// <summary>
        /// 특정 테마로 전환
        /// </summary>
        public static void ApplyTheme(ApplicationTheme theme)
        {
            var app = Application.Current;
            if (app == null) return;
            
            var dictionaries = app.Resources.MergedDictionaries;
            
            // 팔레트 사전 찾기 (파일명으로 식별)
            var paletteDictionary = dictionaries.FirstOrDefault(d => 
                d.Source?.OriginalString?.Contains("Colors.") == true);
            
            if (paletteDictionary != null)
            {
                dictionaries.Remove(paletteDictionary);
            }
            
            // 새 테마 사전 로드
            var newThemeUri = theme switch
            {
                ApplicationTheme.Dark => DarkThemeUri,
                ApplicationTheme.HighContrast => HighContrastThemeUri,
                _ => LightThemeUri
            };
            
            var newThemeDictionary = new ResourceDictionary { Source = newThemeUri };
            dictionaries.Insert(0, newThemeDictionary);
            
            CurrentTheme = theme;
            
            // 설정 저장
            SaveThemePreference(theme);
        }
        
        /// <summary>
        /// 현재 테마 반전 (라이트 ↔ 다크)
        /// </summary>
        public static void ToggleTheme()
        {
            var newTheme = CurrentTheme switch
            {
                ApplicationTheme.Light => ApplicationTheme.Dark,
                ApplicationTheme.Dark => ApplicationTheme.Light,
                _ => ApplicationTheme.Light
            };
            
            ApplyTheme(newTheme);
        }
        
        /// <summary>
        /// 애플리케이션 시작 시 테마 로드
        /// </summary>
        public static void Initialize()
        {
            // 저장된 테마 설정 로드
            var savedTheme = LoadThemePreference();
            
            // OS 테마 따라가기 옵션이 켜져 있으면 OS 테마 사용
            if (Properties.Settings.Default.FollowSystemTheme)
            {
                var osTheme = SystemThemeWatcher.GetCurrentSystemTheme();
                ApplyTheme(osTheme);
            }
            else
            {
                ApplyTheme(savedTheme);
            }
            
            // 시스템 테마 변경 감지 시작
            SystemThemeWatcher.StartWatching();
            SystemThemeWatcher.SystemThemeChanged += OnSystemThemeChanged;
            
            // 고대비 모드 변경 감지
            SystemParameters.StaticPropertyChanged += OnSystemParametersChanged;
        }
        
        private static void OnSystemThemeChanged(object sender, SystemThemeChangedEventArgs e)
        {
            if (Properties.Settings.Default.FollowSystemTheme)
            {
                ApplyTheme(e.NewTheme);
            }
        }
        
        private static void OnSystemParametersChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(SystemParameters.HighContrast))
            {
                if (SystemParameters.HighContrast)
                {
                    ApplyTheme(ApplicationTheme.HighContrast);
                }
                else if (Properties.Settings.Default.FollowSystemTheme)
                {
                    var osTheme = SystemThemeWatcher.GetCurrentSystemTheme();
                    ApplyTheme(osTheme);
                }
            }
        }
        
        private static ApplicationTheme LoadThemePreference()
        {
            try
            {
                var savedValue = Properties.Settings.Default.Theme;
                if (Enum.TryParse<ApplicationTheme>(savedValue, out var theme))
                {
                    return theme;
                }
            }
            catch
            {
                // 설정 로드 실패 시 기본값 사용
            }
            
            return ApplicationTheme.Light;
        }
        
        private static void SaveThemePreference(ApplicationTheme theme)
        {
            try
            {
                Properties.Settings.Default.Theme = theme.ToString();
                Properties.Settings.Default.Save();
            }
            catch
            {
                // 설정 저장 실패 시 무시
            }
        }
        
        private static void OnThemeChanged(ThemeChangedEventArgs e)
        {
            ThemeChanged?.Invoke(null, e);
        }
    }
}
```

## OS 테마 변경 감지

Windows의 현재 테마를 감지하고 변경을 추적하는 클래스:

```csharp
using System;
using Microsoft.Win32;

namespace YourApplication.Services
{
    public class SystemThemeChangedEventArgs : EventArgs
    {
        public ApplicationTheme NewTheme { get; }
        
        public SystemThemeChangedEventArgs(ApplicationTheme newTheme)
        {
            NewTheme = newTheme;
        }
    }
    
    public static class SystemThemeWatcher
    {
        private const string RegistryKeyPath = 
            @"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize";
        
        private const string AppsUseLightThemeValue = "AppsUseLightTheme";
        
        private static RegistryKey _registryKey;
        private static System.Timers.Timer _pollingTimer;
        
        public static event EventHandler<SystemThemeChangedEventArgs> SystemThemeChanged;
        
        /// <summary>
        /// 현재 시스템 테마 가져오기
        /// </summary>
        public static ApplicationTheme GetCurrentSystemTheme()
        {
            try
            {
                using var key = Registry.CurrentUser.OpenSubKey(RegistryKeyPath, false);
                var value = key?.GetValue(AppsUseLightThemeValue, 1);
                
                if (value is int intValue)
                {
                    return intValue == 1 ? ApplicationTheme.Light : ApplicationTheme.Dark;
                }
            }
            catch
            {
                // 레지스트리 접근 실패 시 기본값 반환
            }
            
            return ApplicationTheme.Light;
        }
        
        /// <summary>
        /// 시스템 테마 변경 감지 시작
        /// </summary>
        public static void StartWatching()
        {
            StopWatching();
            
            // 2초마다 폴링 (더 정교한 구현은 RegNotifyChangeKeyValue 사용)
            _pollingTimer = new System.Timers.Timer(2000);
            _pollingTimer.Elapsed += (sender, e) => CheckForThemeChange();
            _pollingTimer.Start();
        }
        
        /// <summary>
        /// 시스템 테마 변경 감지 중지
        /// </summary>
        public static void StopWatching()
        {
            _pollingTimer?.Stop();
            _pollingTimer?.Dispose();
            _pollingTimer = null;
        }
        
        private static ApplicationTheme _lastTheme = ApplicationTheme.Light;
        
        private static void CheckForThemeChange()
        {
            var currentTheme = GetCurrentSystemTheme();
            
            if (currentTheme != _lastTheme)
            {
                _lastTheme = currentTheme;
                SystemThemeChanged?.Invoke(null, new SystemThemeChangedEventArgs(currentTheme));
            }
        }
    }
}
```

## 메인 윈도우 구현

테마 전환 기능을 포함한 메인 윈도우:

```xml
<Window x:Class="YourApplication.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:services="clr-namespace:YourApplication.Services"
        Title="다크모드 데모 애플리케이션"
        Width="800"
        Height="600"
        WindowStartupLocation="CenterScreen">
    
    <Window.Resources>
        <!-- 테마 전환 애니메이션 -->
        <Storyboard x:Key="ThemeTransitionAnimation" Duration="0:0:0.3">
            <DoubleAnimation Storyboard.TargetProperty="Opacity"
                             From="0.7" To="1.0"
                             Duration="0:0:0.3"/>
        </Storyboard>
    </Window.Resources>
    
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        
        <!-- 헤더 영역 -->
        <Border Grid.Row="0" 
                Background="{DynamicResource Palette.Surface}"
                Padding="{DynamicResource Spacing.Large}">
            <StackPanel Orientation="Horizontal" HorizontalAlignment="Right">
                
                <!-- 테마 전환 토글 버튼 -->
                <ToggleButton x:Name="ThemeToggle"
                              IsChecked="{Binding IsDarkTheme, Mode=TwoWay}"
                              Checked="ThemeToggle_Checked"
                              Unchecked="ThemeToggle_Unchecked"
                              Margin="0,0,12,0">
                    <StackPanel Orientation="Horizontal" Spacing="6">
                        <TextBlock Text="다크 모드" VerticalAlignment="Center"/>
                    </StackPanel>
                </ToggleButton>
                
                <!-- OS 테마 동기화 옵션 -->
                <CheckBox x:Name="SyncWithOsCheckBox"
                          Content="OS 테마와 동기화"
                          IsChecked="{Binding FollowSystemTheme, Mode=TwoWay}"
                          VerticalAlignment="Center"
                          Checked="SyncWithOsCheckBox_Checked"
                          Unchecked="SyncWithOsCheckBox_Unchecked"/>
                
            </StackPanel>
        </Border>
        
        <!-- 메인 콘텐츠 영역 -->
        <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto">
            <StackPanel Margin="{DynamicResource Spacing.Large}" Spacing="{DynamicResource Spacing.Large}">
                
                <!-- 카드 1: 설명 -->
                <Border Style="{StaticResource CardStyle}">
                    <StackPanel>
                        <TextBlock Text="다크모드 데모" 
                                   FontSize="24" 
                                   FontWeight="Bold"
                                   Margin="0,0,0,12"/>
                        
                        <TextBlock Text="이 애플리케이션은 라이트 모드와 다크 모드 간의 전환을 보여줍니다. 상단의 토글 버튼을 사용하여 테마를 변경하거나, OS 테마와 동기화할 수 있습니다."
                                   TextWrapping="Wrap"
                                   Foreground="{DynamicResource Palette.SecondaryText}"/>
                    </StackPanel>
                </Border>
                
                <!-- 카드 2: 컨트롤 데모 -->
                <Border Style="{StaticResource CardStyle}">
                    <StackPanel Spacing="{DynamicResource Spacing.Medium}">
                        <TextBlock Text="컨트롤 데모" 
                                   FontSize="18" 
                                   FontWeight="SemiBold"/>
                        
                        <Separator Style="{StaticResource DividerStyle}"/>
                        
                        <!-- 입력 컨트롤 -->
                        <Grid>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>
                            
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                            </Grid.RowDefinitions>
                            
                            <TextBlock Grid.Row="0" Grid.Column="0" 
                                       Text="이름:" 
                                       VerticalAlignment="Center"
                                       Margin="0,0,12,0"/>
                            
                            <TextBox Grid.Row="0" Grid.Column="1" 
                                     Text="홍길동"
                                     Width="200"/>
                            
                            <TextBlock Grid.Row="1" Grid.Column="0" 
                                       Text="이메일:" 
                                       VerticalAlignment="Center"
                                       Margin="0,12,12,0"/>
                            
                            <TextBox Grid.Row="1" Grid.Column="1" 
                                     Text="example@domain.com"
                                     Width="200"
                                     Margin="0,12,0,0"/>
                            
                            <TextBlock Grid.Row="2" Grid.Column="0" 
                                       Text="설명:" 
                                       VerticalAlignment="Center"
                                       Margin="0,12,12,0"/>
                            
                            <TextBox Grid.Row="2" Grid.Column="1" 
                                     Text="다크모드 테스트를 위한 설명입니다."
                                     Width="200" Height="60"
                                     TextWrapping="Wrap"
                                     AcceptsReturn="True"
                                     Margin="0,12,0,0"/>
                        </Grid>
                        
                        <Separator Style="{StaticResource DividerStyle}" Margin="0,12,0,0"/>
                        
                        <!-- 버튼 컨트롤 -->
                        <StackPanel Orientation="Horizontal" Spacing="{DynamicResource Spacing.Small}">
                            <Button Style="{StaticResource PrimaryButton}" Content="저장"/>
                            <Button Content="취소"/>
                            <Button Content="삭제" 
                                    Background="{DynamicResource Palette.Error}"
                                    BorderBrush="{DynamicResource Palette.Error}"/>
                        </StackPanel>
                    </StackPanel>
                </Border>
                
                <!-- 카드 3: 상태 표시 -->
                <Border Style="{StaticResource CardStyle}">
                    <StackPanel>
                        <TextBlock Text="현재 상태" 
                                   FontSize="18" 
                                   FontWeight="SemiBold"/>
                        
                        <Separator Style="{StaticResource DividerStyle}" Margin="0,0,0,12"/>
                        
                        <StackPanel Orientation="Horizontal" Spacing="12">
                            <Border Background="{DynamicResource Palette.Success}"
                                    CornerRadius="{DynamicResource Radius.Small}"
                                    Padding="8,4">
                                <TextBlock Text="성공" Foreground="White" FontWeight="Bold"/>
                            </Border>
                            
                            <Border Background="{DynamicResource Palette.Warning}"
                                    CornerRadius="{DynamicResource Radius.Small}"
                                    Padding="8,4">
                                <TextBlock Text="경고" Foreground="White" FontWeight="Bold"/>
                            </Border>
                            
                            <Border Background="{DynamicResource Palette.Error}"
                                    CornerRadius="{DynamicResource Radius.Small}"
                                    Padding="8,4">
                                <TextBlock Text="오류" Foreground="White" FontWeight="Bold"/>
                            </Border>
                        </StackPanel>
                        
                        <TextBlock Margin="0,12,0,0"
                                   Text="{Binding CurrentThemeText}"
                                   Foreground="{DynamicResource Palette.SecondaryText}"/>
                    </StackPanel>
                </Border>
                
            </StackPanel>
        </ScrollViewer>
        
        <!-- 푸터 영역 -->
        <Border Grid.Row="2"
                Background="{DynamicResource Palette.Surface}"
                Padding="{DynamicResource Spacing.Medium}">
            <TextBlock Text="© 2024 YourApplication. 모든 권리 보유."
                       HorizontalAlignment="Center"
                       Foreground="{DynamicResource Palette.SecondaryText}"/>
        </Border>
        
    </Grid>
    
</Window>
```

```csharp
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows;
using YourApplication.Services;

namespace YourApplication
{
    public partial class MainWindow : Window, INotifyPropertyChanged
    {
        private bool _isDarkTheme;
        private bool _followSystemTheme;
        private string _currentThemeText;
        
        public MainWindow()
        {
            InitializeComponent();
            DataContext = this;
            
            // 초기값 설정
            IsDarkTheme = ThemeManager.CurrentTheme == ApplicationTheme.Dark;
            FollowSystemTheme = Properties.Settings.Default.FollowSystemTheme;
            UpdateThemeText();
            
            // 테마 변경 이벤트 구독
            ThemeManager.ThemeChanged += OnThemeChanged;
            
            // 시스템 테마 변경 이벤트 구독
            SystemThemeWatcher.SystemThemeChanged += OnSystemThemeChanged;
        }
        
        public bool IsDarkTheme
        {
            get => _isDarkTheme;
            set
            {
                if (_isDarkTheme != value)
                {
                    _isDarkTheme = value;
                    OnPropertyChanged();
                }
            }
        }
        
        public bool FollowSystemTheme
        {
            get => _followSystemTheme;
            set
            {
                if (_followSystemTheme != value)
                {
                    _followSystemTheme = value;
                    OnPropertyChanged();
                    
                    // 설정 저장
                    Properties.Settings.Default.FollowSystemTheme = value;
                    Properties.Settings.Default.Save();
                }
            }
        }
        
        public string CurrentThemeText
        {
            get => _currentThemeText;
            set
            {
                if (_currentThemeText != value)
                {
                    _currentThemeText = value;
                    OnPropertyChanged();
                }
            }
        }
        
        private void OnThemeChanged(object sender, ThemeChangedEventArgs e)
        {
            Dispatcher.Invoke(() =>
            {
                IsDarkTheme = e.NewTheme == ApplicationTheme.Dark;
                UpdateThemeText();
                
                // 부드러운 전환을 위한 애니메이션
                var storyboard = (Storyboard)FindResource("ThemeTransitionAnimation");
                storyboard.Begin(this);
            });
        }
        
        private void OnSystemThemeChanged(object sender, SystemThemeChangedEventArgs e)
        {
            Dispatcher.Invoke(() =>
            {
                if (FollowSystemTheme)
                {
                    ThemeManager.ApplyTheme(e.NewTheme);
                }
            });
        }
        
        private void UpdateThemeText()
        {
            CurrentThemeText = $"현재 테마: {(IsDarkTheme ? "다크 모드" : "라이트 모드")}";
        }
        
        private void ThemeToggle_Checked(object sender, RoutedEventArgs e)
        {
            if (!FollowSystemTheme)
            {
                ThemeManager.ApplyTheme(ApplicationTheme.Dark);
            }
        }
        
        private void ThemeToggle_Unchecked(object sender, RoutedEventArgs e)
        {
            if (!FollowSystemTheme)
            {
                ThemeManager.ApplyTheme(ApplicationTheme.Light);
            }
        }
        
        private void SyncWithOsCheckBox_Checked(object sender, RoutedEventArgs e)
        {
            if (FollowSystemTheme)
            {
                var osTheme = SystemThemeWatcher.GetCurrentSystemTheme();
                ThemeManager.ApplyTheme(osTheme);
            }
        }
        
        private void SyncWithOsCheckBox_Unchecked(object sender, RoutedEventArgs e)
        {
            // OS 동기화 해제 시 현재 선택된 테마 유지
        }
        
        protected override void OnClosing(CancelEventArgs e)
        {
            // 정리 작업
            ThemeManager.ThemeChanged -= OnThemeChanged;
            SystemThemeWatcher.SystemThemeChanged -= OnSystemThemeChanged;
            SystemThemeWatcher.StopWatching();
            
            base.OnClosing(e);
        }
        
        public event PropertyChangedEventHandler PropertyChanged;
        
        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
```

## 애플리케이션 시작 시 테마 초기화

App.xaml.cs에서 테마 시스템을 초기화합니다:

```csharp
using System.Windows;
using YourApplication.Services;

namespace YourApplication
{
    public partial class App : Application
    {
        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            
            // 테마 시스템 초기화
            ThemeManager.Initialize();
            
            // 고대비 모드 감지
            CheckHighContrastMode();
        }
        
        private void CheckHighContrastMode()
        {
            if (SystemParameters.HighContrast)
            {
                ThemeManager.ApplyTheme(ApplicationTheme.HighContrast);
            }
        }
    }
}
```

## 고대비 모드 지원

고대비 모드를 위한 별도의 리소스 사전을 제공할 수 있습니다:

```xml
<!-- Themes/Colors.HighContrast.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    
    <!-- 고대비 모드에서는 시스템 색상 사용 권장 -->
    <SolidColorBrush x:Key="Palette.Background" 
                     Color="{Binding Source={x:Static SystemColors.WindowBrush}, Path=Color}"/>
    
    <SolidColorBrush x:Key="Palette.Foreground" 
                     Color="{Binding Source={x:Static SystemColors.WindowTextBrush}, Path=Color}"/>
    
    <SolidColorBrush x:Key="Palette.CardBackground" 
                     Color="{Binding Source={x:Static SystemColors.ControlBrush}, Path=Color}"/>
    
    <SolidColorBrush x:Key="Palette.Border" 
                     Color="{Binding Source={x:Static SystemColors.WindowFrameBrush}, Path=Color}"/>
    
    <!-- 강조 색상은 고대비 가이드라인에 맞게 선택 -->
    <SolidColorBrush x:Key="Palette.Primary" Color="#0000FF"/> <!-- 파란색 -->
    <SolidColorBrush x:Key="Palette.PrimaryHover" Color="#0000CC"/>
    <SolidColorBrush x:Key="Palette.PrimaryPressed" Color="#000099"/>
    
    <!-- 상태 색상 -->
    <SolidColorBrush x:Key="Palette.Success" Color="#008000"/> <!-- 초록색 -->
    <SolidColorBrush x:Key="Palette.Warning" Color="#FFA500"/> <!-- 주황색 -->
    <SolidColorBrush x:Key="Palette.Error" Color="#FF0000"/>   <!-- 빨간색 -->
    
    <!-- 치수 토큰 -->
    <CornerRadius x:Key="Radius.Small">2</CornerRadius>
    <CornerRadius x:Key="Radius.Medium">4</CornerRadius>
    <CornerRadius x:Key="Radius.Large">6</CornerRadius>
    
    <Thickness x:Key="Spacing.Small">4</Thickness>
    <Thickness x:Key="Spacing.Medium">8</Thickness>
    <Thickness x:Key="Spacing.Large">12</Thickness>
    
</ResourceDictionary>
```

## 성능 최적화 고려사항

1. **DynamicResource 최소화**: 테마 변경이 필요한 속성에만 DynamicResource 사용
2. **리소스 캐싱**: 자주 사용되는 브러시 캐싱
3. **템플릿 재사용**: 컨트롤 템플릿 공유
4. **애니메이션 제한**: 테마 전환 시 불필요한 애니메이션 제거
5. **가상화 유지**: ItemsControl 가상화 설정 유지

```csharp
// 성능 최적화를 위한 리소스 캐싱
public static class ThemeResources
{
    private static readonly Dictionary<string, Brush> _brushCache = new();
    
    public static Brush GetCachedBrush(string resourceKey)
    {
        if (!_brushCache.TryGetValue(resourceKey, out var brush))
        {
            brush = Application.Current.FindResource(resourceKey) as Brush;
            if (brush != null)
            {
                _brushCache[resourceKey] = brush;
            }
        }
        return brush;
    }
    
    public static void ClearCache()
    {
        _brushCache.Clear();
    }
}
```

## 테마 시스템 테스트

테마 시스템의 정확성을 보장하기 위한 테스트:

```csharp
using System.Linq;
using System.Windows;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using YourApplication.Services;

namespace YourApplication.Tests
{
    [TestClass]
    public class ThemeTests
    {
        [TestMethod]
        public void TestThemeSwitching()
        {
            // 테마 전환 테스트
            ThemeManager.ApplyTheme(ApplicationTheme.Light);
            Assert.AreEqual(ApplicationTheme.Light, ThemeManager.CurrentTheme);
            
            ThemeManager.ApplyTheme(ApplicationTheme.Dark);
            Assert.AreEqual(ApplicationTheme.Dark, ThemeManager.CurrentTheme);
            
            ThemeManager.ToggleTheme();
            Assert.AreEqual(ApplicationTheme.Light, ThemeManager.CurrentTheme);
        }
        
        [TestMethod]
        public void TestResourceDictionaryReplacement()
        {
            var app = new Application();
            var dictionaries = app.Resources.MergedDictionaries;
            
            // 초기 상태 확인
            Assert.AreEqual(0, dictionaries.Count);
            
            // 테마 사전 추가
            var lightTheme = new ResourceDictionary 
            { 
                Source = new System.Uri("Themes/Colors.Light.xaml", System.UriKind.Relative) 
            };
            dictionaries.Add(lightTheme);
            
            // 사전 교체
            var darkTheme = new ResourceDictionary 
            { 
                Source = new System.Uri("Themes/Colors.Dark.xaml", System.UriKind.Relative) 
            };
            
            var index = dictionaries.IndexOf(lightTheme);
            dictionaries[index] = darkTheme;
            
            Assert.AreEqual(darkTheme, dictionaries[index]);
        }
        
        [TestMethod]
        public void TestDynamicResourceBinding()
        {
            // DynamicResource 바인딩 테스트
            var textBlock = new TextBlock();
            textBlock.SetResourceReference(TextBlock.ForegroundProperty, "Palette.Foreground");
            
            // 리소스가 설정되었는지 확인
            var binding = textBlock.GetBindingExpression(TextBlock.ForegroundProperty);
            Assert.IsNotNull(binding);
        }
    }
}
```

## 결론

WPF에서 다크모드를 구현하는 것은 단순한 색상 변경이 아닌, 체계적인 아키텍처 설계와 일관된 구현 패턴을 요구하는 작업입니다. 이 가이드에서 제시한 접근 방식은 다음과 같은 핵심 원칙을 기반으로 합니다:

**첫째, 추상화된 팔레트 토큰을 사용하세요.** 색상 값을 하드코딩하지 말고 `Palette.Background`, `Palette.Foreground` 같은 의미 기반의 토큰을 정의하세요. 이렇게 하면 테마별로 다른 색상 값을 쉽게 적용할 수 있습니다.

**둘째, DynamicResource를 적절히 사용하세요.** 테마 변경 시 즉시 반응해야 하는 모든 속성은 DynamicResource로 참조해야 합니다. StaticResource는 테마 전환 후에도 변경되지 않으므로 주의가 필요합니다.

**셋째, 계층적 아키텍처를 설계하세요.** 팔레트 토큰, 테마 리소스, 컨트롤 스타일을 분리하여 관리하면 유지보수성과 확장성이 크게 향상됩니다.

**넷째, 사용자 선택권을 존중하세요.** 자동 OS 동기화와 수동 테마 전환 옵션을 모두 제공하세요. 사용자가 자신의 선호도에 따라 선택할 수 있도록 해야 합니다.

**다섯째, 접근성을 고려하세요.** 고대비 모드 지원은 시각 장애가 있는 사용자를 포함한 모든 사용자에게 더 나은 경험을 제공합니다.

이 가이드에서 제시한 구현 패턴은 소규모 애플리케이션부터 대규모 엔터프라이즈 솔루션까지 다양한 규모의 프로젝트에 적용할 수 있습니다. 각 프로젝트의 요구사항에 맞게 적절히 조정하고 확장하면, 사용자 경험을 크게 향상시키는 전문적인 다크모드 구현을 완성할 수 있을 것입니다.