---
layout: post
title: 영상처리 - 잡음 제거를 위한 비선형 필터
date: 2025-09-23 20:25:23 +0900
category: 영상처리
---
# 잡음 제거를 위한 비선형 필터

## 8.5.1 | 미디언(중값) 필터

### 개념
커널 안의 값들을 **정렬**하여 **중간값**(median)을 픽셀에 할당합니다.  
소금&후추(Salt&Pepper)처럼 **임펄스 잡음**에 특히 강합니다.

커널 크기 \(k\!\times\!k\) (홀수), 윈도우 \(W=\{I(x+i,y+j)\}\) 에서
\[
I'(x,y) = \operatorname{median}(W).
\]
컬러에서의 선택:
- **Per-Channel Median**: B/G/R 각각의 중값 → 간단/빠름.
- **Luma-only**: 휘도 \(Y=0.299R+0.587G+0.114B\) 의 중값을 계산해 **RGB에 동일 델타**를 적용 → 색 유지.

### 구현 (경계 클램프 + nth_element 사용)

```cpp
// Median.h
#pragma once
#include <vector>
#include <algorithm>
#include <cstdint>
#include <cmath>
#include "IppDib.h"

inline int clampi(int v, int lo, int hi){ return (v<lo)?lo:((v>hi)?hi:v); }
inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }

inline const uint8_t* sample_BGRA32_clamp(const IppDib& src, int x, int y){
    x = clampi(x, 0, src.width()-1);
    y = clampi(y, 0, src.height()-1);
    const uint8_t* row = (const uint8_t*)src.bits() + (size_t)y*src.stride();
    return &row[x*4];
}

inline uint8_t median_of(std::vector<uint8_t>& buf){
    auto nth = buf.begin() + (buf.size()/2);
    std::nth_element(buf.begin(), nth, buf.end());
    return *nth;
}

inline int luma601(int R,int G,int B){
    return (int)std::lround(0.299*R + 0.587*G + 0.114*B);
}

// passes: 반복 적용(1~N), perChannel=true면 B/G/R 각각 중값
inline void MedianFilter_BGRA32(const IppDib& src, IppDib& dst, int ksize, bool perChannel=true, int passes=1)
{
    if (!src || ksize<3) { dst = src; return; }
    if ((ksize&1)==0) ++ksize; // 홀수 보정

    IppDib cur=src, tmp;
    for (int pass=0; pass<passes; ++pass) {
        tmp.create(src.width(), src.height(), 32);
        int r = ksize/2;

        std::vector<uint8_t> wb, wg, wr;
        std::vector<uint8_t> wy; // luma 전용

        wb.reserve(ksize*ksize);
        wg.reserve(ksize*ksize);
        wr.reserve(ksize*ksize);
        wy.reserve(ksize*ksize);

        for (int y=0; y<cur.height(); ++y) {
            const uint8_t* srow = (const uint8_t*)cur.bits() + (size_t)y*cur.stride();
            uint8_t* drow       = (uint8_t*)tmp.bits() + (size_t)y*tmp.stride();
            for (int x=0; x<cur.width(); ++x) {
                if (perChannel) {
                    wb.clear(); wg.clear(); wr.clear();
                    for (int j=-r;j<=r;++j){
                        for (int i=-r;i<=r;++i){
                            const uint8_t* p = sample_BGRA32_clamp(cur, x+i, y+j);
                            wb.push_back(p[0]);
                            wg.push_back(p[1]);
                            wr.push_back(p[2]);
                        }
                    }
                    drow[x*4+0] = median_of(wb);
                    drow[x*4+1] = median_of(wg);
                    drow[x*4+2] = median_of(wr);
                    drow[x*4+3] = srow[x*4+3]; // alpha copy
                } else {
                    // Luma-only: Y_median으로 ΔY를 만든 후 RGB에 동일 델타 적용
                    wy.clear();
                    for (int j=-r;j<=r;++j){
                        for (int i=-r;i<=r;++i){
                            const uint8_t* p = sample_BGRA32_clamp(cur, x+i, y+j);
                            wy.push_back((uint8_t)luma601(p[2],p[1],p[0]));
                        }
                    }
                    int Ym = median_of(wy);
                    int B=srow[x*4+0], G=srow[x*4+1], R=srow[x*4+2], A=srow[x*4+3];
                    int Yo = luma601(R,G,B);
                    int dY = Ym - Yo; // 델타를 RGB에 동일 가산
                    drow[x*4+0] = clamp_u8(B + dY);
                    drow[x*4+1] = clamp_u8(G + dY);
                    drow[x*4+2] = clamp_u8(R + dY);
                    drow[x*4+3] = A;
                }
            }
        }
        cur.swap(tmp);
    }
    dst = cur;
}
```

#### 복잡도/성능 메모
- 윈도우 당 `nth_element` \(O(k^2)\), 픽셀 당 \(O(k^2)\), 전체 \(O(WHk^2)\).  
- 8-bit 그레이스케일 경우 **히스토그램 슬라이딩** 최적화로 \(O(WHk)\) 가능(과제로 권장).  
- 임펄스 노이즈가 심할 때 `passes=2` 정도가 실용적.

---

### 미디언 필터 메뉴 만들기

간단히 **고정 크기** 3×3, 5×5, 7×7을 메뉴로 제공합니다.

```cpp
// resource.h (추가)
#define ID_IMAGE_DENOISE_MEDIAN3     54001
#define ID_IMAGE_DENOISE_MEDIAN5     54002
#define ID_IMAGE_DENOISE_MEDIAN7     54003
#define ID_IMAGE_DENOISE_MEDIAN_LUMA3 54004
```

```rc
// ImageTool.rc (추가/일부)
POPUP "&Image"
BEGIN
    POPUP "Denoise (Nonlinear)"
    BEGIN
        MENUITEM "Median 3x3 (per-channel)", ID_IMAGE_DENOISE_MEDIAN3
        MENUITEM "Median 5x5 (per-channel)", ID_IMAGE_DENOISE_MEDIAN5
        MENUITEM "Median 7x7 (per-channel)", ID_IMAGE_DENOISE_MEDIAN7
        MENUITEM "Median 3x3 (luma-only)",   ID_IMAGE_DENOISE_MEDIAN_LUMA3
        MENUITEM SEPARATOR
        MENUITEM "Anisotropic Diffusion...\tCtrl+D", ID_IMAGE_DENOISE_DIFFUSION_DLG
    END
END

IDR_ACCEL ACCELERATORS
BEGIN
    "D", ID_IMAGE_DENOISE_DIFFUSION_DLG, VIRTKEY, CONTROL
END
```

```cpp
// main_multiwin.cpp (발췌)
#include "Median.h"

// ...
case ID_IMAGE_DENOISE_MEDIAN3:
case ID_IMAGE_DENOISE_MEDIAN5:
case ID_IMAGE_DENOISE_MEDIAN7:
case ID_IMAGE_DENOISE_MEDIAN_LUMA3:
    if (st && st->dib) {
        IppDib out;
        if (wParam==ID_IMAGE_DENOISE_MEDIAN_LUMA3)
            MedianFilter_BGRA32(st->dib, out, 3, /*perChannel=*/false, /*passes=*/1);
        else {
            int k = (wParam==ID_IMAGE_DENOISE_MEDIAN3)?3: (wParam==ID_IMAGE_DENOISE_MEDIAN5)?5:7;
            MedianFilter_BGRA32(st->dib, out, k, /*perChannel=*/true, /*passes=*/1);
        }
        st->dib = out;
        InvalidateRect(hWnd, nullptr, FALSE);
        OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
    }
    return 0;
```

---

## 8.5.2 | 비등방성 확산(Anisotropic Diffusion)

### 개념 (Perona–Malik)
선형 확산(가우시안 블러)은 **모든 방향**으로 평활화되어 **에지(경계)** 도 흐려집니다.  
비등방성 확산은 **에지에선 확산을 억제**하고, **균일 영역**에서는 확산을 허용합니다.

연속 PDE:
\[
\frac{\partial I}{\partial t} = \nabla \cdot \left( c\!\left(|\nabla I|\right)\, \nabla I \right)
\]
여기서 **전달 함수** \(c(s)\) 는 에지 억제를 위해
\[
c_1(s)=\exp\!\left(-\left(\frac{s}{\kappa}\right)^2\right),\quad
c_2(s)=\frac{1}{1+\left(\frac{s}{\kappa}\right)^2}.
\]
이산화(4-이웃)하면, 한 스텝 업데이트:
\[
I^{t+1} = I^t + \lambda \left( c_N \nabla_N + c_S \nabla_S + c_E \nabla_E + c_W \nabla_W \right)
\]
- \(\nabla_N = I(x,y-1)-I(x,y)\) 등,  
- \(\lambda\) 는 시간 스텝 (안정성 위해 4-이웃에서 \(0<\lambda\le 0.25\) 권장),  
- \(\kappa\) 는 에지 스레숄드(작을수록 에지 근처 억제 강함).

### 구현 (Luma-only / Per-Channel 옵션, 4·8-이웃 선택)

```cpp
// AnisoDiffusion.h
#pragma once
#include <vector>
#include <cmath>
#include <algorithm>
#include "IppDib.h"

inline float clampf(float v, float a, float b){ return (v<a)?a:((v>b)?b:v); }
inline int   luma601_int(int R,int G,int B){ return (int)std::lround(0.299*R+0.587*G+0.114*B); }

enum class DiffConduct { Exp=0, Reciprocal=1 };

struct DiffParams {
    int   iterations = 10;      // 반복 횟수
    float lambda     = 0.20f;   // 스텝 (4-이웃: <=0.25, 8-이웃: <=0.125 권장)
    float kappa      = 20.0f;   // 에지 스케일
    DiffConduct gfun = DiffConduct::Exp;
    bool  use8       = false;   // 8-이웃 사용
    bool  lumaOnly   = true;    // 휘도만 확산(색 보호)
};

// 4-이웃: NSEW, 8-이웃: 대각 포함(1/sqrt(2) 가중)
inline float conduct(float grad, float kappa, DiffConduct g){
    float s = grad / kappa;
    if (g == DiffConduct::Exp)        return std::exp(-(s*s));
    else /*Reciprocal*/               return 1.0f / (1.0f + s*s);
}

// (Luma-only) 또는 (RGB per-channel) 확산
inline void AnisotropicDiffusion_BGRA32(const IppDib& src, IppDib& dst, const DiffParams& P)
{
    if (!src || P.iterations<=0) { dst=src; return; }
    float lam = P.lambda;
    if (P.use8) lam = std::min(lam, 0.125f); else lam = std::min(lam, 0.25f);

    const int W=src.width(), H=src.height();
    // float 버퍼
    std::vector<float> R(W*H), G(W*H), B(W*H), Y; Y.reserve(W*H);

    // 초기화
    for (int y=0;y<H;++y){
        const uint8_t* row=(const uint8_t*)src.bits()+(size_t)y*src.stride();
        for (int x=0;x<W;++x){
            int idx=y*W+x; B[idx]=row[x*4+0]; G[idx]=row[x*4+1]; R[idx]=row[x*4+2];
        }
    }
    if (P.lumaOnly){ Y.resize(W*H); for (int i=0;i<W*H;++i) Y[i]=0.299f*R[i]+0.587f*G[i]+0.114f*B[i]; }

    auto at = [&](const std::vector<float>& V, int x, int y)->float {
        x = (x<0)?0:((x>=W)?W-1:x);
        y = (y<0)?0:((y>=H)?H-1:y);
        return V[y*W + x];
    };

    // 작업 버퍼
    std::vector<float> Rn(W*H), Gn(W*H), Bn(W*H), Yn;
    if (P.lumaOnly) Yn.resize(W*H);

    for (int t=0; t<P.iterations; ++t){
        if (P.lumaOnly){
            // ── 휘도 확산
            for (int y=0;y<H;++y){
                for (int x=0;x<W;++x){
                    float Ic = at(Y,x,y);
                    float n = at(Y,x,y-1) - Ic;
                    float s = at(Y,x,y+1) - Ic;
                    float e = at(Y,x+1,y) - Ic;
                    float w = at(Y,x-1,y) - Ic;

                    float cN = conduct(std::fabs(n), P.kappa, P.gfun);
                    float cS = conduct(std::fabs(s), P.kappa, P.gfun);
                    float cE = conduct(std::fabs(e), P.kappa, P.gfun);
                    float cW = conduct(std::fabs(w), P.kappa, P.gfun);

                    float update = cN*n + cS*s + cE*e + cW*w;

                    if (P.use8){
                        float ne = at(Y,x+1,y-1) - Ic;
                        float nw = at(Y,x-1,y-1) - Ic;
                        float se = at(Y,x+1,y+1) - Ic;
                        float sw = at(Y,x-1,y+1) - Ic;
                        float w8 = 1.0f/std::sqrt(2.0f); // 대각 가중
                        update += w8 * (
                          conduct(std::fabs(ne),P.kappa,P.gfun)*ne +
                          conduct(std::fabs(nw),P.kappa,P.gfun)*nw +
                          conduct(std::fabs(se),P.kappa,P.gfun)*se +
                          conduct(std::fabs(sw),P.kappa,P.gfun)*sw );
                    }
                    Yn[y*W+x] = Ic + lam * update;
                }
            }
            Y.swap(Yn);
            // 동일 ΔY를 RGB에 적용(색 유지)
            for (int y=0;y<H;++y){
                for (int x=0;x<W;++x){
                    int i=y*W+x;
                    float dY = Y[i] - (0.299f*R[i]+0.587f*G[i]+0.114f*B[i]);
                    Rn[i] = R[i] + dY;
                    Gn[i] = G[i] + dY;
                    Bn[i] = B[i] + dY;
                }
            }
            R.swap(Rn); G.swap(Gn); B.swap(Bn);
        } else {
            // ── RGB 채널별 독립 확산
            auto step = [&](const std::vector<float>& C, std::vector<float>& Cn){
                for (int y=0;y<H;++y){
                    for (int x=0;x<W;++x){
                        float Ic = at(C,x,y);
                        float n = at(C,x,y-1) - Ic;
                        float s = at(C,x,y+1) - Ic;
                        float e = at(C,x+1,y) - Ic;
                        float w = at(C,x-1,y) - Ic;

                        float cN = conduct(std::fabs(n), P.kappa, P.gfun);
                        float cS = conduct(std::fabs(s), P.kappa, P.gfun);
                        float cE = conduct(std::fabs(e), P.kappa, P.gfun);
                        float cW = conduct(std::fabs(w), P.kappa, P.gfun);
                        float update = cN*n + cS*s + cE*e + cW*w;

                        if (P.use8){
                            float ne = at(C,x+1,y-1) - Ic;
                            float nw = at(C,x-1,y-1) - Ic;
                            float se = at(C,x+1,y+1) - Ic;
                            float sw = at(C,x-1,y+1) - Ic;
                            float w8 = 1.0f/std::sqrt(2.0f);
                            update += w8 * (
                              conduct(std::fabs(ne),P.kappa,P.gfun)*ne +
                              conduct(std::fabs(nw),P.kappa,P.gfun)*nw +
                              conduct(std::fabs(se),P.kappa,P.gfun)*se +
                              conduct(std::fabs(sw),P.kappa,P.gfun)*sw );
                        }
                        Cn[y*W+x] = Ic + lam * update;
                    }
                }
            };
            step(R, Rn); step(G, Gn); step(B, Bn);
            R.swap(Rn); G.swap(Gn); B.swap(Bn);
        }
    }

    // 결과 복원
    dst.create(W,H,32);
    for (int y=0;y<H;++y){
        const uint8_t* srow=(const uint8_t*)src.bits()+(size_t)y*src.stride();
        uint8_t* drow = (uint8_t*)dst.bits()+(size_t)y*dst.stride();
        for (int x=0;x<W;++x){
            int i=y*W+x;
            drow[x*4+0] = (uint8_t)clampf(B[i],0,255);
            drow[x*4+1] = (uint8_t)clampf(G[i],0,255);
            drow[x*4+2] = (uint8_t)clampf(R[i],0,255);
            drow[x*4+3] = srow[x*4+3]; // alpha
        }
    }
}
```

---

### 비등방성 확산 대화 상자 만들기

- **Iterations** (1~50): 반복 횟수  
- **Lambda (step)**: 4-이웃은 \(\le 0.25\), 8-이웃은 \(\le 0.125\) 권장  
- **Kappa**: 에지 감도(10~40 실용)  
- **Conduct.**: `exp(-(|∇I|/k)^2)` vs `1/(1+(|∇I|/k)^2)`  
- **Neighborhood**: 4- or 8-이웃  
- **Luma-only**: 색 보호

```cpp
// resource.h (추가)
#define IDD_DIFFUSION_DLG             560
#define IDC_EDIT_DIFF_ITER            1901
#define IDC_EDIT_DIFF_LAMBDA          1902
#define IDC_EDIT_DIFF_KAPPA           1903
#define IDC_RAD_DIFF_EXP              1904
#define IDC_RAD_DIFF_RECIP            1905
#define IDC_RAD_DIFF_4N               1906
#define IDC_RAD_DIFF_8N               1907
#define IDC_CHK_DIFF_LUMA             1908

#define ID_IMAGE_DENOISE_DIFFUSION_DLG 54010
```

```rc
// ImageTool.rc (추가)
IDD_DIFFUSION_DLG DIALOGEX 0,0, 240, 160
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Anisotropic Diffusion"
FONT 9, "Segoe UI"
BEGIN
    LTEXT "Iterations:", -1, 12, 14, 50, 10
    EDITTEXT IDC_EDIT_DIFF_ITER,   70, 12, 30, 14, ES_NUMBER

    LTEXT "Lambda:", -1, 120, 14, 36, 10
    EDITTEXT IDC_EDIT_DIFF_LAMBDA, 160, 12, 30, 14, ES_AUTOHSCROLL

    LTEXT "Kappa:", -1, 12, 36, 36, 10
    EDITTEXT IDC_EDIT_DIFF_KAPPA,  70, 34, 30, 14, ES_AUTOHSCROLL

    GROUPBOX "Conduct.", -1, 12, 56, 86, 32
    AUTORADIOBUTTON "exp",    IDC_RAD_DIFF_EXP,    18, 68, 30, 10, WS_TABSTOP
    AUTORADIOBUTTON "1/(1+s^2)", IDC_RAD_DIFF_RECIP, 18, 80, 60, 10

    GROUPBOX "Neighbor", -1, 104, 56, 86, 32
    AUTORADIOBUTTON "4-neigh", IDC_RAD_DIFF_4N, 110, 68, 54, 10, WS_TABSTOP
    AUTORADIOBUTTON "8-neigh", IDC_RAD_DIFF_8N, 110, 80, 54, 10

    AUTOCHECKBOX "Luma-only", IDC_CHK_DIFF_LUMA, 12, 96, 70, 12

    DEFPUSHBUTTON "OK", IDOK,     126, 126, 46, 14
    PUSHBUTTON    "Cancel", IDCANCEL, 176, 126, 46, 14
END
```

```cpp
// DiffusionDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "AnisoDiffusion.h"

class DiffusionDlg {
public:
    DiffusionDlg(HWND owner, IppDib& dib) : owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND h, UINT m, WPARAM w, LPARAM l);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);

    int   ReadInt(HWND h, int id, int def) const;
    float ReadFloat(HWND h, int id, float def) const;

private:
    HWND owner_ = nullptr;
    IppDib& dib_;
};
```

```cpp
// DiffusionDlg.cpp
#include "DiffusionDlg.h"

INT_PTR DiffusionDlg::DoModal() {
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_DIFFUSION_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK DiffusionDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m==WM_INITDIALOG) {
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(DiffusionDlg*)l; return self->OnInit(h);
    }
    auto* self=(DiffusionDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;

    switch (m){
    case WM_COMMAND: return self->OnCommand(h,w,l);
    default: return FALSE;
    }
}

INT_PTR DiffusionDlg::OnInit(HWND h) {
    SetDlgItemInt(h, IDC_EDIT_DIFF_ITER,   10, FALSE);
    SetDlgItemTextW(h, IDC_EDIT_DIFF_LAMBDA, L"0.20");
    SetDlgItemTextW(h, IDC_EDIT_DIFF_KAPPA,  L"20.0");
    CheckRadioButton(h, IDC_RAD_DIFF_EXP, IDC_RAD_DIFF_RECIP, IDC_RAD_DIFF_EXP);
    CheckRadioButton(h, IDC_RAD_DIFF_4N,  IDC_RAD_DIFF_8N,    IDC_RAD_DIFF_4N);
    CheckDlgButton(h, IDC_CHK_DIFF_LUMA, BST_CHECKED);
    return TRUE;
}

int DiffusionDlg::ReadInt(HWND h, int id, int def) const {
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE);
    if (!ok) return def; return v;
}
float DiffusionDlg::ReadFloat(HWND h, int id, float def) const {
    wchar_t buf[64]; GetDlgItemTextW(h, id, buf, 64);
    wchar_t* e=nullptr; double v=wcstod(buf,&e); if (e==buf) return def; return (float)v;
}

INT_PTR DiffusionDlg::OnCommand(HWND h, WPARAM w, LPARAM) {
    switch (LOWORD(w)){
    case IDOK: {
        DiffParams P;
        P.iterations = std::max(1, ReadInt(h, IDC_EDIT_DIFF_ITER, 10));
        P.lambda     = ReadFloat(h, IDC_EDIT_DIFF_LAMBDA, 0.2f);
        P.kappa      = ReadFloat(h, IDC_EDIT_DIFF_KAPPA,  20.0f);
        P.gfun       = (IsDlgButtonChecked(h, IDC_RAD_DIFF_EXP)==BST_CHECKED)? DiffConduct::Exp : DiffConduct::Reciprocal;
        P.use8       = (IsDlgButtonChecked(h, IDC_RAD_DIFF_8N)==BST_CHECKED);
        P.lumaOnly   = (IsDlgButtonChecked(h, IDC_CHK_DIFF_LUMA)==BST_CHECKED);

        // 안정 스텝 클램프
        if (P.use8 && P.lambda>0.125f) P.lambda=0.125f;
        if (!P.use8 && P.lambda>0.25f) P.lambda=0.25f;

        IppDib out; AnisotropicDiffusion_BGRA32(dib_, out, P);
        dib_ = out;
        EndDialog(h, IDOK);
        return TRUE;
    }
    case IDCANCEL:
        EndDialog(h, IDCANCEL);
        return TRUE;
    }
    return FALSE;
}
```

### 비등방성 확산 필터 메뉴 만들기 (연동)

```cpp
// resource.h (이미 추가됨)
// #define ID_IMAGE_DENOISE_DIFFUSION_DLG 54010
```

```cpp
// main_multiwin.cpp (발췌)
#include "DiffusionDlg.h"

// ...
case ID_IMAGE_DENOISE_DIFFUSION_DLG:
    if (st && st->dib) {
        DiffusionDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK) {
            InvalidateRect(hWnd,nullptr,FALSE);
            OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 8.5.3 | 예제 & 상황

### 상황 A) 소금&후추 잡음 제거 (문서/바코드/QR)
- **입력**: 8.4절에서 S&P density=0.02 로 오염된 흑백 문서.  
- **동작**: `Denoise (Nonlinear) → Median 3x3` → 잔여가 크면 5x5 또는 `passes=2`.  
- **결과**: 임펄스가 효과적으로 제거, 문자 선은 비교적 보존.

### 상황 B) 저조도 사진의 컬러 그레인 완화 + 에지 보호
- **입력**: ISO 6400 실내 사진(가우시안성 잡음).  
- **동작**: `Anisotropic Diffusion…` → Iter=10, λ=0.20, κ=20, exp, **Luma-only**.  
- **결과**: 균일 영역은 매끈, 경계/윤곽은 유지. 컬러 번짐 적음.

### 상황 C) 피부 보정(과샤프 방지)
- **입력**: 인물 사진, 미세 노이즈 & 과샤프 아티팩트.  
- **동작**: Diffusion(8-neigh, λ=0.10, κ=15, iter=12, Luma-only).  
- **결과**: 피부 텍스처가 자연스럽게 정리되면서 눈/입 윤곽은 살아있음.

### 상황 D) 전처리 → 샤프닝 파이프라인
- **입력**: 소프트한 풍경 + 노이즈.  
- **동작**: Diffusion(λ=0.2, κ=20, iter=8) → Sharpen(USM σ=1.0, amount=0.6, thresh=3).  
- **결과**: 노이즈 억제 후 샤프닝으로 **깨끗하고 선명**.

---

## 8.5.4 | 팁 & 주의 사항

- **미디언**: 너무 큰 커널(>7)은 구조 흐림. S&P엔 3~5가 실전적.  
- **Diffusion λ**: 4-이웃 ≤ 0.25, 8-이웃 ≤ 0.125. 초과 시 불안정.  
- **κ (kappa)**: 작을수록 경계에서 확산 억제 → 에지 보호 증가(하지만 노이즈 잔존).  
- **Luma-only**: 컬러 채널 왜곡 방지. 강력 추천.  
- **성능**: 확산은 반복 계산 → 큰 이미지에선 iter를 5~15로 제어.  
- **Undo/Redo**: 본문은 즉시 적용. 프로젝트에 커맨드 스택이 있다면 push 권장.  
- **경계 처리**: 본 구현은 replicate(클램프). 필요 시 reflect로 개선 가능.

---

## 8.5.5 | 확장 아이디어

- **가이드 필터 / Bilateral(양방향) 필터**: 색/거리 결합으로 엣지 보존 스무딩.  
- **TV(총변동) 최소화**: L1 기반 정규화로 날카로운 에지 유지.  
- **가속**: SIMD(NEON/SSE/AVX), 타일링, 멀티스레드(행 스트라이프).  
- **프리뷰**: 대화 상자 내 슬라이더 & 미리보기(저해상도 프레임으로 즉시 적용).

---

## 요약
- **미디언**: 임펄스 잡음에 최적, 메뉴로 즉시 사용 가능.  
- **비등방성 확산**: 에지 보존형 스무딩(Perona–Malik), 파라미터(λ, κ, iter, conduct, 4/8N, Luma-only) 제공 대화 상자 완비.  
- 두 기법은 상호 보완적이며, 실제 사진/문서/의료 영상 등 광범위한 잡음 제거에 적용할 수 있습니다.