---
layout: post
title: 영상처리 - 잡음 제거를 위한 비선형 필터
date: 2025-09-23 20:25:23 +0900
category: 영상처리
---
# 잡음 제거를 위한 비선형 필터 — 미디언, 비등방성 확산, 구현·파라미터

## 1. 선형 vs 비선형 필터 개요

### 1.1 잡음 모델과 선형 필터의 한계

이미지 잡음은 보통 다음과 같이 이상화한다.

- **가우시안 잡음(Gaussian noise)**  
  각 픽셀에 독립적으로 **정규분포**를 갖는 잡음이 더해진 모델:

  $$
  I_{\text{noisy}}(x,y) = I_{\text{true}}(x,y) + n(x,y), \quad
  n \sim \mathcal{N}(0, \sigma^2)
  $$

- **임펄스 잡음(Impulse noise, 소금&후추)**  
  픽셀의 일부가 확률적으로 **0(검은 점)** 또는 **255(하얀 점)** 으로 튀는 모델:

  $$
  I_{\text{noisy}}(x,y)=
  \begin{cases}
  0 & \text{확률 }p_s \\
  255 & \text{확률 }p_p \\
  I_{\text{true}}(x,y) & \text{나머지}
  \end{cases}
  $$

- **스펙클(speckle)**, **포아송(Poisson)** 등도 있지만, 여기서는 위 두 가지를 중심으로 보자.

**선형 필터(평균, 가우시안)** 는

- 가우시안 잡음에 대해선 잘 동작한다(평균을 취함으로써 분산이 줄어든다).
- 하지만 **임펄스 잡음**에 취약하다.  
  소금&후추 픽셀이 커널 안에 섞여 있으면 **평균 값이 크게 왜곡**되고,  
  에지(경계) 근처에서는 구조 자체가 무너진다.

이때 등장하는 것이 **비선형 필터**들이다.

### 1.2 비선형 필터의 역할

비선형 필터란, 출력이 입력의 선형 결합이 아닌 경우를 말한다.

$$
I'(x,y) = F\big(\{I(x+i,y+j)\}_{(i,j)\in\Omega}\big)
$$

여기서 $$F$$ 가 선형이 아니면(예: 중간값, 최대값, 랭크 통계, 비선형 PDE 등) 비선형 필터이다.

- 대표 예:
  - **미디언 필터(Median Filter)**: 순위 통계 기반
  - **비등방성 확산(Anisotropic Diffusion)**: 비선형 PDE 기반
  - **양방향 필터(Bilateral Filter)**: 거리·강도 가중
  - **총 변동(Total Variation) 최소화**, **비국소 평균(Non-Local Means)** 등

이 글에서는 특히 **미디언 필터**와 **비등방성 확산**을  
“실제 도구에 넣어서 돌릴 수 있는 수준”까지 구현하고,  
다른 기법은 연결만 한다.

---

## 2. 미디언 필터(Median Filter)

### 2.1 개념과 수학적 정의

미디언 필터는 커널 안의 픽셀 값을 **정렬**한 뒤, 그 **중간값(median)** 을 결과 픽셀에 할당한다.

- 커널 크기 $$k \times k$$ (홀수)  
- 중심 픽셀 $$I(x,y)$$ 주변의 윈도우:

  $$
  W = \{ I(x+i, y+j) \mid i,j \in \{-r,\dots,r\}\},\quad r = \frac{k-1}{2}
  $$

- 정렬된 값이 $$w_{(1)}\le w_{(2)} \le \dots \le w_{(k^2)}$$ 라면

  $$
  I'(x,y) = \operatorname{median}(W) = w_{\big(\frac{k^2+1}{2}\big)}
  $$

**중요한 특성**

- 임펄스 잡음(극단값)에 매우 강하다.  
  잡음이 커널 내에서 **소수**라면, 정렬했을 때 중간값은 여전히 원래 구조에 가깝다.
- 에지를 어느 정도 보존한다.  
  경계 양쪽 값이 섞이더라도 중간값이 어느 한쪽으로 과하게 쏠리지 않는다.
- 가우시안 잡음에 대해서는 평균필터만큼 효율적이진 않지만, **아웃라이어에 덜 민감**하다.

### 2.2 그레이스케일 vs 컬러

그레이스케일(8-bit)에서는 미디언 정의가 단순하지만,  
컬러(BGR/RGB)에서는 **여러 채널을 어떻게 처리할 것인지**가 이슈다.

1. **Per-Channel Median**

   - B/G/R 각각에 대해 독립적으로 미디언을 취한다.

   $$
   B'=\operatorname{median}(\{B_i\}),\;
   G'=\operatorname{median}(\{G_i\}),\;
   R'=\operatorname{median}(\{R_i\})
   $$

   - 장점: 구현이 단순, 빠르다.
   - 단점: 색 공간에서 **비자연스러운 조합**이 생길 수 있다(하지만 대부분의 실용 상황에서 괜찮다).

2. **Luma-only Median (휘도 기반)**

   - 휘도(예: BT.601)

     $$
     Y = 0.299R + 0.587G + 0.114B
     $$

     의 미디언을 구한 뒤,  
     **기존 픽셀의 Y를 Y의 중간값으로 이동시키는 방식**으로  
     RGB 전체에 동일 델타를 적용한다.

   - 장점:
     - 색조(Chrominance)를 크게 왜곡하지 않는다.
     - 사람 눈은 휘도 변화에 더 민감하므로 시각적으로 자연스럽다.
   - 단점:
     - 구현이 약간 더 복잡하다.
     - 휘도만 조정하므로, 색 잡음(컬러 채널에만 있는 노이즈)은 덜 제거될 수 있다.

3. **Vector Median / Rank-Vector Median (참고)**

   - RGB를 3차원 벡터로 보고,  
     **전체 거리 합이 최소인 벡터**를 선택하는 방식이 “vector median”이다.
   - 이 글에서는 구현 복잡성 대비 이득이 크지 않으므로 **개념만 언급**하고 넘어간다.

---

## 3. 미디언 필터 C++ 구현 (BGRA32, MFC 툴용)

이제 제공했던 코드를 토대로, BGRA32 포맷에서의 미디언 필터 구현을 정리한다.  
핵심 포인트는:

- **경계 처리**: 커널이 이미지 밖으로 나갈 때 **클램프(clamp)**.
- **중간값 계산**: `std::nth_element` 로 $$O(k^2)$$ 의 평균 시간에 중간값을 구한다.
- **컬러 전략**: `perChannel=true` 인 경우 B/G/R 독립 미디언, `false` 인 경우 Luma-only.

### 3.1 핵심 유틸리티 & 미디언 함수

```cpp
// Median.h
#pragma once
#include <vector>
#include <algorithm>
#include <cstdint>
#include <cmath>
#include "IppDib.h"

inline int clampi(int v, int lo, int hi){ return (v<lo)?lo:((v>hi)?hi:v); }
inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }

// BGRA32에서 (x,y)를 샘플링하되, 좌표를 [0, W-1]×[0,H-1]로 클램프
inline const uint8_t* sample_BGRA32_clamp(const IppDib& src, int x, int y){
    x = clampi(x, 0, src.width()-1);
    y = clampi(y, 0, src.height()-1);
    const uint8_t* row = (const uint8_t*)src.bits() + (size_t)y*src.stride();
    return &row[x*4];
}

// 벡터에 채운 값들의 중간값
inline uint8_t median_of(std::vector<uint8_t>& buf){
    auto nth = buf.begin() + (buf.size()/2);
    std::nth_element(buf.begin(), nth, buf.end());
    return *nth;
}

// BT.601 luma
inline int luma601(int R,int G,int B){
    return (int)std::lround(0.299*R + 0.587*G + 0.114*B);
}
```

### 3.2 미디언 필터 본체

```cpp
// passes: 반복 적용(1~N), perChannel=true면 B/G/R 각각 중값
inline void MedianFilter_BGRA32(const IppDib& src, IppDib& dst, int ksize, bool perChannel=true, int passes=1)
{
    if (!src || ksize<3) { dst = src; return; }
    if ((ksize&1)==0) ++ksize; // 홀수 보정

    IppDib cur=src, tmp;
    for (int pass=0; pass<passes; ++pass) {
        tmp.create(src.width(), src.height(), 32);
        int r = ksize/2;

        std::vector<uint8_t> wb, wg, wr;
        std::vector<uint8_t> wy; // luma 전용

        wb.reserve(ksize*ksize);
        wg.reserve(ksize*ksize);
        wr.reserve(ksize*ksize);
        wy.reserve(ksize*ksize);

        for (int y=0; y<cur.height(); ++y) {
            const uint8_t* srow = (const uint8_t*)cur.bits() + (size_t)y*cur.stride();
            uint8_t* drow       = (uint8_t*)tmp.bits() + (size_t)y*tmp.stride();
            for (int x=0; x<cur.width(); ++x) {
                if (perChannel) {
                    wb.clear(); wg.clear(); wr.clear();
                    for (int j=-r;j<=r;++j){
                        for (int i=-r;i<=r;++i){
                            const uint8_t* p = sample_BGRA32_clamp(cur, x+i, y+j);
                            wb.push_back(p[0]);
                            wg.push_back(p[1]);
                            wr.push_back(p[2]);
                        }
                    }
                    drow[x*4+0] = median_of(wb);
                    drow[x*4+1] = median_of(wg);
                    drow[x*4+2] = median_of(wr);
                    drow[x*4+3] = srow[x*4+3]; // alpha copy
                } else {
                    // Luma-only: Y_median으로 ΔY를 만든 후 RGB에 동일 델타 적용
                    wy.clear();
                    for (int j=-r;j<=r;++j){
                        for (int i=-r;i<=r;++i){
                            const uint8_t* p = sample_BGRA32_clamp(cur, x+i, y+j);
                            wy.push_back((uint8_t)luma601(p[2],p[1],p[0]));
                        }
                    }
                    int Ym = median_of(wy);
                    int B=srow[x*4+0], G=srow[x*4+1], R=srow[x*4+2], A=srow[x*4+3];
                    int Yo = luma601(R,G,B);
                    int dY = Ym - Yo; // 델타를 RGB에 동일 가산
                    drow[x*4+0] = clamp_u8(B + dY);
                    drow[x*4+1] = clamp_u8(G + dY);
                    drow[x*4+2] = clamp_u8(R + dY);
                    drow[x*4+3] = A;
                }
            }
        }
        cur.swap(tmp);
    }
    dst = cur;
}
```

### 3.3 복잡도/성능 분석

- 윈도우 크기 $$k \times k$$ 에서 각 픽셀 당:
  - 윈도우 픽셀 수: $$k^2$$
  - `nth_element` 평균 시간: $$O(k^2)$$
- 전체 이미지 크기를 $$W \times H$$ 라 하면:

  $$
  \mathcal{O}(W H k^2)
  $$

- 예:
  - $$W=1920, H=1080, k=3$$ → 약 $$2\times10^6\times9 \approx 1.8\times10^7$$ 원소 처리
  - 충분히 실시간에 가깝게 동작 가능(최적화·멀티스레딩 추가 시).

**최적화 아이디어 (그레이스케일)**

- 8-bit 그레이스케일에서는 **히스토그램 기반 슬라이딩 윈도우**를 쓰면  
  복잡도를 $$\mathcal{O}(W H k)$$ 수준으로 줄일 수 있다.
- 메모리 접근 패턴 캐시 최적화, 타일링, OpenMP 등으로 속도를 올릴 수 있다.

---

## 4. 미디언 필터 메뉴/연동 (MFC 스타일)

이미지 툴에서 **3×3, 5×5, 7×7 미디언 필터** 를 메뉴로 제공한다고 하자.

### 4.1 리소스 ID 정의

```cpp
// resource.h (추가)
#define ID_IMAGE_DENOISE_MEDIAN3      54001
#define ID_IMAGE_DENOISE_MEDIAN5      54002
#define ID_IMAGE_DENOISE_MEDIAN7      54003
#define ID_IMAGE_DENOISE_MEDIAN_LUMA3 54004
```

### 4.2 메뉴 리소스

```rc
// ImageTool.rc (추가/일부)
POPUP "&Image"
BEGIN
    POPUP "Denoise (Nonlinear)"
    BEGIN
        MENUITEM "Median 3x3 (per-channel)", ID_IMAGE_DENOISE_MEDIAN3
        MENUITEM "Median 5x5 (per-channel)", ID_IMAGE_DENOISE_MEDIAN5
        MENUITEM "Median 7x7 (per-channel)", ID_IMAGE_DENOISE_MEDIAN7
        MENUITEM "Median 3x3 (luma-only)",   ID_IMAGE_DENOISE_MEDIAN_LUMA3
        MENUITEM SEPARATOR
        MENUITEM "Anisotropic Diffusion...\tCtrl+D", ID_IMAGE_DENOISE_DIFFUSION_DLG
    END
END

IDR_ACCEL ACCELERATORS
BEGIN
    "D", ID_IMAGE_DENOISE_DIFFUSION_DLG, VIRTKEY, CONTROL
END
```

### 4.3 메시지 핸들러에서 호출

```cpp
// main_multiwin.cpp (발췌)
#include "Median.h"

// ...
case ID_IMAGE_DENOISE_MEDIAN3:
case ID_IMAGE_DENOISE_MEDIAN5:
case ID_IMAGE_DENOISE_MEDIAN7:
case ID_IMAGE_DENOISE_MEDIAN_LUMA3:
    if (st && st->dib) {
        IppDib out;
        if (wParam==ID_IMAGE_DENOISE_MEDIAN_LUMA3)
            MedianFilter_BGRA32(st->dib, out, 3, /*perChannel=*/false, /*passes=*/1);
        else {
            int k = (wParam==ID_IMAGE_DENOISE_MEDIAN3)?3:
                    (wParam==ID_IMAGE_DENOISE_MEDIAN5)?5:7;
            MedianFilter_BGRA32(st->dib, out, k, /*perChannel=*/true, /*passes=*/1);
        }
        st->dib = out;
        InvalidateRect(hWnd, nullptr, FALSE);
        OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
    }
    return 0;
```

이로써 GUI에서 메뉴만 눌러도 BGRA32 이미지를 대상으로  
미디언 필터가 작동하는 완결된 경로가 만들어진다.

---

## 5. 비등방성 확산(Anisotropic Diffusion)

이제 **에지를 보존하면서 가우시안 잡음 등 “연속형” 노이즈를 줄이기 위한 기법**인  
비등방성 확산(Perona–Malik)을 보자.

### 5.1 선형 확산(가우시안 블러) vs 비등방성 확산

선형 확산(heat equation):

$$
\frac{\partial I}{\partial t} = \Delta I = \nabla \cdot \nabla I
$$

- 시간 $$t$$ 가 증가할수록 이미지는 가우시안 블러가 된다고 볼 수 있다.
- 그러나 **모든 방향**으로 확산되므로, 경계·윤곽도 함께 흐려진다.

비등방성 확산은 여기에 **전달 계수(conductance) $$c(|\nabla I|)$$** 를 붙인다.

$$
\frac{\partial I}{\partial t} = \nabla \cdot \big( c(|\nabla I|)\, \nabla I \big)
$$

- 경사가 큰 곳(에지)에서는 $$|\nabla I|$$ 가 커서,  
  $$c(|\nabla I|)$$ 가 작아진다 → **에지 근처에서 확산 억제**.
- 경사가 작은 곳(균일 영역)에서는 $$|\nabla I|$$ 가 작아,  
  $$c(|\nabla I|) \approx 1$$ → **내부는 잘 평활화**.

Perona–Malik 논문에서 제안된 대표적인 두 함수는:

1. 지수형:

   $$
   c_1(s) = \exp\!\left( -\left(\frac{s}{\kappa}\right)^2 \right)
   $$

2. 역비례형:

   $$
   c_2(s) = \frac{1}{1+\left(\frac{s}{\kappa}\right)^2}
   $$

여기서 $$\kappa$$ 는 에지 민감도를 결정하는 파라미터이다.

- $$\kappa$$ 작음 → 작은 경사에도 빠르게 억제 → 에지 보존 강하지만 평활화 약함.
- $$\kappa$$ 큼 → 에지까지 어느 정도 확산 → 노이즈 제거는 강하지만 에지 다소 흐려짐.

### 5.2 이산화(4-이웃, 8-이웃)

4-이웃(상하좌우) 이산화:

- 위치 $$I(x,y)$$ 에서

  - 북쪽:

    $$
    \nabla_N = I(x, y-1) - I(x,y)
    $$

  - 남쪽:

    $$
    \nabla_S = I(x, y+1) - I(x,y)
    $$

  - 동쪽:

    $$
    \nabla_E = I(x+1, y) - I(x,y)
    $$

  - 서쪽:

    $$
    \nabla_W = I(x-1, y) - I(x,y)
    $$

- 각 방향에 대해 전달 계수:

  $$
  c_N = c(|\nabla_N|), \quad c_S = c(|\nabla_S|), \quad c_E = c(|\nabla_E|), \quad c_W = c(|\nabla_W|)
  $$

- 업데이트 식(Explicit Scheme):

  $$
  I^{t+1}(x,y) = I^t(x,y) + \lambda \left(
  c_N \nabla_N + c_S \nabla_S + c_E \nabla_E + c_W \nabla_W
  \right)
  $$

여기서 $$\lambda$$ 는 시간 스텝. 안정성을 위해 4-이웃에서는 보통

$$
0 < \lambda \le 0.25
$$

를 권장한다.

8-이웃(대각선 포함)을 사용할 경우, 대각 방향으로는  
거리 $$\sqrt{2}$$ 를 고려한 가중치를 두어야 하고,  
안정성을 위해 $$\lambda \le 0.125$$ 정도로 줄이는 것이 일반적이다.

### 5.3 Luma-only vs Per-Channel

비등방성 확산은 자체가 **비선형·에지 민감**하다. 컬러에서:

- **Per-Channel 확산**: R/G/B 각각에 대해 독립적으로 확산.  
  → 잡음 제거는 잘 되지만 색 경계가 틀어질 수 있다.
- **Luma-only**:
  - 먼저 Y(휘도)에 대해 확산을 적용해 $$Y^{t+1}$$ 을 구한 뒤,
  - 각 픽셀에서 $$\Delta Y = Y^{t+1} - Y^t$$ 를 계산,
  - RGB 전체에 같은 $$\Delta Y$$ 를 더해 색을 최대한 유지한다.

이 글에서는 두 가지 옵션을 모두 구현하되,  
실전에서는 **Luma-only**를 기본값으로 두는 패턴을 사용한다.

---

## 6. 비등방성 확산 C++ 구현 (BGRA32)

이제 BGRA32 이미지에 대해 비등방성 확산을 구현하는 코드를 정리한다.

### 6.1 파라미터 구조체와 전달 함수

```cpp
// AnisoDiffusion.h
#pragma once
#include <vector>
#include <cmath>
#include <algorithm>
#include "IppDib.h"

inline float clampf(float v, float a, float b){ return (v<a)?a:((v>b)?b:v); }
inline int   luma601_int(int R,int G,int B){ return (int)std::lround(0.299*R+0.587*G+0.114*B); }

enum class DiffConduct { Exp=0, Reciprocal=1 };

struct DiffParams {
    int   iterations = 10;      // 반복 횟수
    float lambda     = 0.20f;   // 스텝 (4-이웃: <=0.25, 8-이웃: <=0.125 권장)
    float kappa      = 20.0f;   // 에지 스케일
    DiffConduct gfun = DiffConduct::Exp;
    bool  use8       = false;   // 8-이웃 사용
    bool  lumaOnly   = true;    // 휘도만 확산(색 보호)
};

// 4-이웃: NSEW, 8-이웃: 대각 포함(1/sqrt(2) 가중)
inline float conduct(float grad, float kappa, DiffConduct g){
    float s = grad / kappa;
    if (g == DiffConduct::Exp)        return std::exp(-(s*s));
    else /*Reciprocal*/               return 1.0f / (1.0f + s*s);
}
```

### 6.2 본체 구현 (Luma-only / Per-Channel 지원)

```cpp
// (Luma-only) 또는 (RGB per-channel) 확산
inline void AnisotropicDiffusion_BGRA32(const IppDib& src, IppDib& dst, const DiffParams& P)
{
    if (!src || P.iterations<=0) { dst=src; return; }
    float lam = P.lambda;
    if (P.use8) lam = std::min(lam, 0.125f); else lam = std::min(lam, 0.25f);

    const int W=src.width(), H=src.height();
    // float 버퍼
    std::vector<float> R(W*H), G(W*H), B(W*H), Y; Y.reserve(W*H);

    // 초기화
    for (int y=0;y<H;++y){
        const uint8_t* row=(const uint8_t*)src.bits()+(size_t)y*src.stride();
        for (int x=0;x<W;++x){
            int idx=y*W+x; B[idx]=row[x*4+0]; G[idx]=row[x*4+1]; R[idx]=row[x*4+2];
        }
    }
    if (P.lumaOnly){ Y.resize(W*H); for (int i=0;i<W*H;++i) Y[i]=0.299f*R[i]+0.587f*G[i]+0.114f*B[i]; }

    auto at = [&](const std::vector<float>& V, int x, int y)->float {
        x = (x<0)?0:((x>=W)?W-1:x);
        y = (y<0)?0:((y>=H)?H-1:y);
        return V[y*W + x];
    };

    // 작업 버퍼
    std::vector<float> Rn(W*H), Gn(W*H), Bn(W*H), Yn;
    if (P.lumaOnly) Yn.resize(W*H);

    for (int t=0; t<P.iterations; ++t){
        if (P.lumaOnly){
            // ── 휘도 확산
            for (int y=0;y<H;++y){
                for (int x=0;x<W;++x){
                    float Ic = at(Y,x,y);
                    float n = at(Y,x,y-1) - Ic;
                    float s = at(Y,x,y+1) - Ic;
                    float e = at(Y,x+1,y) - Ic;
                    float w = at(Y,x-1,y) - Ic;

                    float cN = conduct(std::fabs(n), P.kappa, P.gfun);
                    float cS = conduct(std::fabs(s), P.kappa, P.gfun);
                    float cE = conduct(std::fabs(e), P.kappa, P.gfun);
                    float cW = conduct(std::fabs(w), P.kappa, P.gfun);

                    float update = cN*n + cS*s + cE*e + cW*w;

                    if (P.use8){
                        float ne = at(Y,x+1,y-1) - Ic;
                        float nw = at(Y,x-1,y-1) - Ic;
                        float se = at(Y,x+1,y+1) - Ic;
                        float sw = at(Y,x-1,y+1) - Ic;
                        float w8 = 1.0f/std::sqrt(2.0f); // 대각 가중
                        update += w8 * (
                          conduct(std::fabs(ne),P.kappa,P.gfun)*ne +
                          conduct(std::fabs(nw),P.kappa,P.gfun)*nw +
                          conduct(std::fabs(se),P.kappa,P.gfun)*se +
                          conduct(std::fabs(sw),P.kappa,P.gfun)*sw );
                    }
                    Yn[y*W+x] = Ic + lam * update;
                }
            }
            Y.swap(Yn);
            // 동일 ΔY를 RGB에 적용(색 유지)
            for (int y=0;y<H;++y){
                for (int x=0;x<W;++x){
                    int i=y*W+x;
                    float dY = Y[i] - (0.299f*R[i]+0.587f*G[i]+0.114f*B[i]);
                    Rn[i] = R[i] + dY;
                    Gn[i] = G[i] + dY;
                    Bn[i] = B[i] + dY;
                }
            }
            R.swap(Rn); G.swap(Gn); B.swap(Bn);
        } else {
            // ── RGB 채널별 독립 확산
            auto step = [&](const std::vector<float>& C, std::vector<float>& Cn){
                for (int y=0;y<H;++y){
                    for (int x=0;x<W;++x){
                        float Ic = at(C,x,y);
                        float n = at(C,x,y-1) - Ic;
                        float s = at(C,x,y+1) - Ic;
                        float e = at(C,x+1,y) - Ic;
                        float w = at(C,x-1,y) - Ic;

                        float cN = conduct(std::fabs(n), P.kappa, P.gfun);
                        float cS = conduct(std::fabs(s), P.kappa, P.gfun);
                        float cE = conduct(std::fabs(e), P.kappa, P.gfun);
                        float cW = conduct(std::fabs(w), P.kappa, P.gfun);
                        float update = cN*n + cS*s + cE*e + cW*w;

                        if (P.use8){
                            float ne = at(C,x+1,y-1) - Ic;
                            float nw = at(C,x-1,y-1) - Ic;
                            float se = at(C,x+1,y+1) - Ic;
                            float sw = at(C,x-1,y+1) - Ic;
                            float w8 = 1.0f/std::sqrt(2.0f);
                            update += w8 * (
                              conduct(std::fabs(ne),P.kappa,P.gfun)*ne +
                              conduct(std::fabs(nw),P.kappa,P.gfun)*nw +
                              conduct(std::fabs(se),P.kappa,P.gfun)*se +
                              conduct(std::fabs(sw),P.kappa,P.gfun)*sw );
                        }
                        Cn[y*W+x] = Ic + lam * update;
                    }
                }
            };
            step(R, Rn); step(G, Gn); step(B, Bn);
            R.swap(Rn); G.swap(Gn); B.swap(Bn);
        }
    }

    // 결과 복원
    dst.create(W,H,32);
    for (int y=0;y<H;++y){
        const uint8_t* srow=(const uint8_t*)src.bits()+(size_t)y*src.stride();
        uint8_t* drow = (uint8_t*)dst.bits()+(size_t)y*dst.stride();
        for (int x=0;x<W;++x){
            int i=y*W+x;
            drow[x*4+0] = (uint8_t)clampf(B[i],0,255);
            drow[x*4+1] = (uint8_t)clampf(G[i],0,255);
            drow[x*4+2] = (uint8_t)clampf(R[i],0,255);
            drow[x*4+3] = srow[x*4+3]; // alpha
        }
    }
}
```

### 6.3 파라미터 튜닝 가이드

- `iterations`:
  - 5~15 정도가 보통 실용 구간.
  - 너무 크면 **과도한 평활화 + 에지 손상**.
- `lambda`:
  - 4-이웃: $$0 < \lambda \le 0.25$$,
  - 8-이웃: $$0 < \lambda \le 0.125$$ 권장.
- `kappa`:
  - 10~40 범위가 많이 쓰인다.
  - 노이즈가 심하면 조금 키우고, 에지를 더 보호하고 싶으면 줄인다.
- `gfun`:
  - `Exp`는 에지를 더 강하게 보호(급격히 0으로 수렴).
  - `Reciprocal`은 좀 더 완만한 억제 → 부드러운 결과.

---

## 7. 비등방성 확산 대화 상자 & 메뉴 연동

이제 이 필터를 GUI에서 조정할 수 있도록 대화 상자를 만든다.

### 7.1 리소스 ID

```cpp
// resource.h (추가)
#define IDD_DIFFUSION_DLG             560
#define IDC_EDIT_DIFF_ITER            1901
#define IDC_EDIT_DIFF_LAMBDA          1902
#define IDC_EDIT_DIFF_KAPPA           1903
#define IDC_RAD_DIFF_EXP              1904
#define IDC_RAD_DIFF_RECIP            1905
#define IDC_RAD_DIFF_4N               1906
#define IDC_RAD_DIFF_8N               1907
#define IDC_CHK_DIFF_LUMA             1908

#define ID_IMAGE_DENOISE_DIFFUSION_DLG 54010
```

### 7.2 다이얼로그 리소스

```rc
// ImageTool.rc (추가)
IDD_DIFFUSION_DLG DIALOGEX 0,0, 240, 160
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Anisotropic Diffusion"
FONT 9, "Segoe UI"
BEGIN
    LTEXT "Iterations:", -1, 12, 14, 50, 10
    EDITTEXT IDC_EDIT_DIFF_ITER,   70, 12, 30, 14, ES_NUMBER

    LTEXT "Lambda:", -1, 120, 14, 36, 10
    EDITTEXT IDC_EDIT_DIFF_LAMBDA, 160, 12, 30, 14, ES_AUTOHSCROLL

    LTEXT "Kappa:", -1, 12, 36, 36, 10
    EDITTEXT IDC_EDIT_DIFF_KAPPA,  70, 34, 30, 14, ES_AUTOHSCROLL

    GROUPBOX "Conduct.", -1, 12, 56, 86, 32
    AUTORADIOBUTTON "exp",    IDC_RAD_DIFF_EXP,    18, 68, 30, 10, WS_TABSTOP
    AUTORADIOBUTTON "1/(1+s^2)", IDC_RAD_DIFF_RECIP, 18, 80, 60, 10

    GROUPBOX "Neighbor", -1, 104, 56, 86, 32
    AUTORADIOBUTTON "4-neigh", IDC_RAD_DIFF_4N, 110, 68, 54, 10, WS_TABSTOP
    AUTORADIOBUTTON "8-neigh", IDC_RAD_DIFF_8N, 110, 80, 54, 10

    AUTOCHECKBOX "Luma-only", IDC_CHK_DIFF_LUMA, 12, 96, 70, 12

    DEFPUSHBUTTON "OK", IDOK,     126, 126, 46, 14
    PUSHBUTTON    "Cancel", IDCANCEL, 176, 126, 46, 14
END
```

### 7.3 C++ 다이얼로그 클래스

```cpp
// DiffusionDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "AnisoDiffusion.h"

class DiffusionDlg {
public:
    DiffusionDlg(HWND owner, IppDib& dib) : owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND h, UINT m, WPARAM w, LPARAM l);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);

    int   ReadInt(HWND h, int id, int def) const;
    float ReadFloat(HWND h, int id, float def) const;

private:
    HWND owner_ = nullptr;
    IppDib& dib_;
};
```

```cpp
// DiffusionDlg.cpp
#include "DiffusionDlg.h"

INT_PTR DiffusionDlg::DoModal() {
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_DIFFUSION_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK DiffusionDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m==WM_INITDIALOG) {
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(DiffusionDlg*)l; return self->OnInit(h);
    }
    auto* self=(DiffusionDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;

    switch (m){
    case WM_COMMAND: return self->OnCommand(h,w,l);
    default: return FALSE;
    }
}

INT_PTR DiffusionDlg::OnInit(HWND h) {
    SetDlgItemInt(h, IDC_EDIT_DIFF_ITER,   10, FALSE);
    SetDlgItemTextW(h, IDC_EDIT_DIFF_LAMBDA, L"0.20");
    SetDlgItemTextW(h, IDC_EDIT_DIFF_KAPPA,  L"20.0");
    CheckRadioButton(h, IDC_RAD_DIFF_EXP, IDC_RAD_DIFF_RECIP, IDC_RAD_DIFF_EXP);
    CheckRadioButton(h, IDC_RAD_DIFF_4N,  IDC_RAD_DIFF_8N,    IDC_RAD_DIFF_4N);
    CheckDlgButton(h, IDC_CHK_DIFF_LUMA, BST_CHECKED);
    return TRUE;
}

int DiffusionDlg::ReadInt(HWND h, int id, int def) const {
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE);
    if (!ok) return def; return v;
}
float DiffusionDlg::ReadFloat(HWND h, int id, float def) const {
    wchar_t buf[64]; GetDlgItemTextW(h, id, buf, 64);
    wchar_t* e=nullptr; double v=wcstod(buf,&e); if (e==buf) return def; return (float)v;
}

INT_PTR DiffusionDlg::OnCommand(HWND h, WPARAM w, LPARAM) {
    switch (LOWORD(w)){
    case IDOK: {
        DiffParams P;
        P.iterations = std::max(1, ReadInt(h, IDC_EDIT_DIFF_ITER, 10));
        P.lambda     = ReadFloat(h, IDC_EDIT_DIFF_LAMBDA, 0.2f);
        P.kappa      = ReadFloat(h, IDC_EDIT_DIFF_KAPPA,  20.0f);
        P.gfun       = (IsDlgButtonChecked(h, IDC_RAD_DIFF_EXP)==BST_CHECKED)?
                       DiffConduct::Exp : DiffConduct::Reciprocal;
        P.use8       = (IsDlgButtonChecked(h, IDC_RAD_DIFF_8N)==BST_CHECKED);
        P.lumaOnly   = (IsDlgButtonChecked(h, IDC_CHK_DIFF_LUMA)==BST_CHECKED);

        // 안정 스텝 클램프
        if (P.use8 && P.lambda>0.125f) P.lambda=0.125f;
        if (!P.use8 && P.lambda>0.25f) P.lambda=0.25f;

        IppDib out; AnisotropicDiffusion_BGRA32(dib_, out, P);
        dib_ = out;
        EndDialog(h, IDOK);
        return TRUE;
    }
    case IDCANCEL:
        EndDialog(h, IDCANCEL);
        return TRUE;
    }
    return FALSE;
}
```

### 7.4 메뉴 메시지에서 연결

```cpp
// main_multiwin.cpp (발췌)
#include "DiffusionDlg.h"

// ...
case ID_IMAGE_DENOISE_DIFFUSION_DLG:
    if (st && st->dib) {
        DiffusionDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK) {
            InvalidateRect(hWnd,nullptr,FALSE);
            OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

이제 사용자는:

- **Image → Denoise (Nonlinear) → Anisotropic Diffusion…** 을 클릭하고,
- Iterations, Lambda, Kappa, Conductance 함수, 4/8-이웃, Luma-only 여부를 조절한 뒤
- OK를 눌러 결과를 확인할 수 있다.

---

## 8. 예제 시나리오

이제 위 두 필터를 실제로 언제 어떻게 쓸지 상황별로 정리한다.

### 8.1 소금&후추 잡음이 있는 흑백 문서/바코드/QR

- **입력**
  - 스캔 과정에서 S&P density가 0.02~0.1 수준인 흑백 문서.
  - 흰 배경에 검은 글자, 검은 바코드/QR.

- **처리**
  1. **Median 3×3 (per-channel 또는 그레이)** 적용.
  2. 잔여 잡음이 크면 5×5 또는 `passes=2` 적용.
  3. 그 후 이진화(Threshold) / OCR / 바코드 인식 진행.

- **효과**
  - 임펄스 잡음 픽셀은 주변 값에 비해 극단값이므로  
    정렬 시 양 끝으로 몰린다 → 중간값에서는 자연스럽게 제거.
  - 직선/문자 에지는 최소한만 변형된다.

### 8.2 저조도 컬러 사진의 ISO 노이즈

- **입력**
  - ISO 6400 이상의 실내 사진(가우시안성 잡음 + 컬러 그레인).
- **처리**
  1. Anisotropic Diffusion (Luma-only, 4-이웃)  
     Iter=10, λ=0.20, κ=20, gfun=Exp.
  2. 필요하면 컬러 잡음을 위해 **약한 per-channel 빌터**를 추가(예: 미디언 3×3 per-channel).

- **효과**
  - 평탄한 영역(벽, 하늘, 피부)에서 잡음이 크게 감소.
  - 에지 주변에는 확산이 억제되어 선명도를 유지.
  - Luma-only 옵션 덕분에 색조가 크게 틀어지지 않는다.

### 8.3 인물 사진에서 피부 보정

- **입력**
  - 얼굴에 미세한 노이즈와 과도한 샤프닝 아티팩트가 섞인 사진.
- **처리**
  1. Anisotropic Diffusion (Luma-only, 8-이웃)  
     Iter=12, λ=0.10, κ=15, gfun=Reciprocal.
  2. 필요하면 마스크를 이용해 **피부 영역에만 필터를 적용**.

- **효과**
  - 피부 텍스처가 자연스럽게 부드러워지면서도  
    눈, 입, 머리카락 등 에지는 살아 있는 결과.

### 8.4 Diffusion + Sharpen 파이프라인

- **입력**
  - 가볍게 흐릿하고 노이즈가 있는 풍경 사진.
- **처리**
  1. Diffusion (Iter=8, λ=0.20, κ=20, Exp, Luma-only).
  2. Unsharp Mask(USM)  
     - 블러 σ=1.0  
     - 양(amount)=0.6  
     - 임계(threshold)=3.

- **효과**
  - 먼저 노이즈를 제거한 뒤, USM으로 에지를 강조하므로  
    노이즈가 같이 증폭되는 문제를 줄이면서 **선명하고 깨끗한 결과**를 얻는다.

---

## 9. 팁·주의사항·확장 아이디어

### 9.1 미디언 필터

- **커널 크기**
  - 3×3: 가장 일반적, 구조 보존이 좋고 S&P 제거에도 충분한 경우 많다.
  - 5×5: 노이즈가 많을 때 사용. 작은 디테일이 조금 희생된다.
  - 7×7 이상: 구조가 많이 흐려질 수 있으므로 특별한 경우가 아니면 피한다.
- **반복 적용(passes)**
  - 임펄스 잡음 농도가 매우 높으면 3×3을 2회 반복하는 것이  
    5×5 한 번보다 에지 보존에 유리한 경우도 있다.
- **경계 처리**
  - 현재 구현은 **클램프(Replicate)** 방식을 사용한다.
  - 필요하면 Reflect(거울반사) 방식으로 바꿀 수 있다.

### 9.2 비등방성 확산

- **λ(스텝)**
  - 너무 크면 업데이트가 발산하여 이미지가 깨진다.
  - 코드에서는 안전을 위해 자동으로 클램프한다.
- **κ(에지 스레숄드)**
  - 이미지의 전역 콘트라스트/노이즈 레벨에 따라 조정해야 한다.
  - 경험적으로 10~40 사이에서 테스트 후 결정.
- **반복 횟수**
  - 5~15 범위에서 결과를 비교하며 튜닝.
- **Luma-only 추천**
  - 컬러 사진에서 색 번짐을 막기 위해 기본값을 Luma-only로 두는 것이 좋다.

### 9.3 다른 비선형 필터로의 확장

여기서는 코드까지 구현하지는 않지만,  
실무에서 자주 언급되는 비선형 필터들을 간단히 짚고 넘어가자.

1. **Bilateral Filter (양방향 필터)**

   - 거리 가중 $$w_d$$ 와 강도차 가중 $$w_r$$ 를 곱한 형태:

     $$
     I'(p) = \frac{1}{W_p} \sum_{q \in \Omega}
       \exp\left(-\frac{\|p-q\|^2}{2\sigma_d^2}\right)\,
       \exp\left(-\frac{|I(p)-I(q)|^2}{2\sigma_r^2}\right)\,
       I(q)
     $$

   - 에지를 기준으로 양쪽을 구분해 평활화하므로,  
     에지를 잘 유지하면서 잡음을 줄일 수 있다.

2. **TV(Total Variation) Denoising**

   - 에너지:

     $$
     E(I) = \int |\nabla I|\,dx + \lambda \int (I - I_0)^2\,dx
     $$

   - 에지의 개수/길이를 줄이는 방향으로 작동하는 L1 기반 정규화.
   - 에지를 날카롭게 유지하면서 블록·플랫 영역을 만들어준다.

3. **Non-Local Means (NLM)**

   - 한 픽셀 주변 패치와 다른 위치 패치 사이의 유사성을 사용해  
     “비국소적”으로 평균을 내는 방식.
   - 매우 뛰어난 denoising 성능을 제공하지만 계산량이 크다.

이들 모두 비선형 필터의 일종이며,  
Median + Anisotropic Diffusion과 동일한 철학(에지 보존, 아웃라이어 억제)을 공유한다.

---

## 10. 정리

이 글에서는 **잡음 제거를 위한 비선형 필터** 중에서

- **미디언 필터**:  
  - 임펄스 잡음(소금&후추)에 특히 강하며,  
  - per-channel / Luma-only 두 전략을 비교하고,  
  - BGRA32 이미지에 대한 C++ 구현과 MFC 스타일 메뉴 연동을 전부 포함했다.

- **비등방성 확산(Perona–Malik)**:  
  - 선형 가우시안 확산의 한계를 보완하고,  
  - 에지 근처에서 확산을 억제하는 PDE 기반 필터로서  
  - 전달 함수, λ/κ 안정 조건, 4·8-이웃 이산화,  
  - Luma-only / RGB per-channel 구현,  
  - 파라미터를 조정할 수 있는 대화 상자,  
  - 다양한 실전 시나리오(저조도 사진, 인물, 샤프닝 전처리)를 다루었다.

두 필터는 상호 보완적이다.

- 임펄스 잡음이 지배적이면 **미디언**을 먼저 적용하고,
- 가우시안/ISO 노이즈가 많으면 **비등방성 확산** 또는 그 뒤에 샤프닝을 결합하는 방식이 효과적이다.

여기에 양방향 필터·TV·NLM 등을 더하면  
현대 디지털 이미지 처리에서 쓰이는 주요 비선형 필터 스펙트럼을 거의 다 커버하게 된다.

실제 프로젝트에서는:

1. 이 글의 C++ 코드를 그대로 가져다 붙이고,
2. 파라미터(커널 크기, λ, κ, Iter, Luma-only 여부)를 UI에서 조정·프리뷰해 보고,
3. 작업 대상(문서, 사진, 의료 영상, 위성 이미지 등)에 맞춰 조정해 나가면 된다.

이렇게 하면 단순한 평균/가우시안 블러를 넘어서는,  
**에지 보존형·노이즈 억제형 비선형 필터 파이프라인**을 자연스럽게 구축할 수 있다.