---
layout: post
title: Linux - 프로세스와 서비스 관리
date: 2024-11-05 19:20:23 +0900
category: Linux
---
# 프로세스와 서비스 관리

## 프로세스(Process)란?

프로세스는 실행 중인 프로그램의 인스턴스로, 운영체제로부터 고유한 식별자인 **PID**(Process ID)를 할당받습니다. 단순히 코드가 실행되는 것 이상으로, 각 프로세스는 독립적인 실행 환경을 구성합니다. 이 환경에는 메모리 공간(주소 공간), 열린 파일 목록(파일 디스크립터 테이블), 시그널에 대한 반응 방식(시그널 핸들러), 그리고 하나 이상의 실행 스레드를 포함할 수 있습니다.

또한 프로세스는 보안과 자원 관리를 위한 중요한 속성들을 가지고 있습니다. **UID/GID**는 프로세스를 실행한 사용자와 그룹을 나타내며, 파일 접근 권한을 결정하는 데 사용됩니다. 현대 리눅스 시스템에서는 **cgroup**과 **네임스페이스**를 통해 프로세스의 CPU, 메모리 사용량을 제한하거나, 파일시스템, 네트워크 등의 뷰를 격리하는 컨테이너 기술의 기반을 제공합니다.

### 핵심 용어 정리

- **PID / PPID**: 각 프로세스의 고유 ID와 이를 생성한 부모 프로세스의 ID입니다.
- **UID / EUID (실제/유효 사용자 ID)**: 프로세스의 소유자와 실제 파일 접근 시 사용되는 권한을 결정합니다. setuid 비트가 설정된 프로그램 실행 시 달라질 수 있습니다.
- **GID / EGID (실제/유효 그룹 ID)**: 사용자 ID와 유사한 개념이 그룹에 적용됩니다.
- **TTY**: 프로세스가 연결된 터미널 장치를 가리킵니다. 데몬 프로세스는 보통 `?`로 표시됩니다.
- **스케줄링 우선순위(nice 값)**: CPU 사용 스케줄에 영향을 미치는 값으로, 범위는 -20(가장 높은 우선순위)부터 19(가장 낮은 우선순위)까지입니다.
- **OOM 점수**: 시스템 메모리가 부족할 때(out-of-memory) 커널이 프로세스를 종료시키는 순위를 결정하는 데 참고하는 값입니다.

---

## 프로세스 상태, 생명주기, 그리고 생성

`ps` 명령어로 확인할 수 있는 프로세스 상태는 실행 흐름을 이해하는 데 중요합니다.

| 상태 | 의미 |
|---|---|
| **R (Running)** | 현재 CPU에서 실행 중이거나, 실행 가능한 상태로 런큐에서 스케줄링을 기다리는 중입니다. |
| **S (Sleeping)** | 인터럽트 가능한 대기 상태로, 대개 I/O 작업 완료나 시그널 같은 이벤트를 기다립니다. |
| **D (Uninterruptible sleep)** | 인터럽트 불가능한 대기 상태입니다. 주로 디스크 I/O와 같은 커널 작업을 기다릴 때 발생하며, `kill` 명령으로도 종료할 수 없습니다. |
| **T (Stopped)** | 작업 제어 시그널(`SIGSTOP`, `SIGTSTP`)에 의해 또는 디버거에 의해 중지된 상태입니다. |
| **Z (Zombie)** | 프로세스는 실행을 종료했지만, 부모 프로세스가 `wait()` 시스템 호출로 자식의 종료 상태를 회수하기 전까지 커널 프로세스 테이블에 남아 있는 상태입니다. |

### 생명주기: 포크와 실행

리눅스에서 새로운 프로세스는 일반적으로 `fork()` 시스템 호출로 시작합니다. 이 호출은 호출한 프로세스(부모)를 거의 동일한 복사본(자식)으로 만듭니다. 이후 자식 프로세스는 `execve()` 계열의 시스템 호출을 실행하여 자신의 메모리 공간을 완전히 새로운 프로그램 이미지로 교체합니다. 셸에서 명령을 실행할 때 내부적으로 이 `fork()` → `execve()` 흐름이 진행됩니다.

**좀비 프로세스 처리**
좀비 프로세스는 시스템 리소를 거의 소모하지 않지만, 프로세스 테이블 슬롯을 점유합니다. 장기간 존재한다면 부모 프로세스에 문제가 있을 수 있습니다.
```bash
# 좀비 상태의 프로세스 확인
ps -eo pid,ppid,stat,cmd | awk '$3 ~ /Z/ {print}'
# 해당 PID의 부모(PPID)를 확인하여 부모 프로세스를 재시작하거나 적절히 처리해야 합니다.
```

---

## /proc 파일시스템: 프로세스 내부 들여다보기

`/proc`은 커널과 프로세스 정보에 대한 가상 인터페이스를 제공하는 파일시스템입니다. 각 실행 중인 프로세스는 `/proc/<PID>/` 디렉터리로 표현됩니다.

```bash
# 현재 쉘의 PID 확인
echo $$

# 프로세스의 환경변수 확인 (널 문자로 구분)
cat /proc/$$/environ | tr '\0' '\n'

# 프로세스를 시작한 명령줄 확인
cat /proc/$$/cmdline | tr '\0' ' '

# 프로세스 상태 요약 정보 (메모리, 스레드, 신호 등)
cat /proc/$$/status

# 프로세스가 열고 있는 파일 디스크립터 목록
ls -l /proc/$$/fd
```

---

## 프로세스 정보 조회 도구

### ps – 현재 시스템의 프로세스 스냅샷
가장 기본적이고 강력한 프로세스 상태 확인 도구입니다.

```bash
# 자주 사용하는 형식
ps aux      # BSD 스타일: 모든 사용자의 상세 정보
ps -ef      # UNIX 스타일: 전체 포맷 리스트

# 원하는 컬럼만 지정하여 출력 (트리 형태로 보기)
ps -eo user,pid,ppid,tty,stat,ni,pri,psr,%cpu,%mem,etime,cmd --forest
```
- `--forest` 옵션은 부모-자식 관계를 트리 형태로 시각화해줍니다.
- `-o` 옵션으로 출력할 컬럼을 자유롭게 지정할 수 있습니다.

### top / htop – 실시간 시스템 모니터
`top`은 터미널 기반의 동적 시스템 모니터입니다.
```bash
top
```
주요 인터랙티브 명령어:
- `P`: CPU 사용률 기준 정렬
- `M`: 메모리 사용률 기준 정렬
- `k`: 선택한 프로세스 종료 (시그널 전송)
- `r`: 선택한 프로세스의 nice 값 변경 (renice)
- `1`: 모든 CPU 코어의 사용률을 개별적으로 표시
- `f`: 표시할 필드(컬럼) 선택/해제

**Load Average 해석**
상단에 표시되는 Load Average(1분, 5분, 15분 평균)는 시스템 부하를 나타내는 지표입니다. 이 값은 "실행 대기 중인 프로세스의 평균 개수"를 의미합니다. 단순 숫자보다는 시스템의 CPU 코어 수 대비로 해석하는 것이 중요합니다. 예를 들어 8코어 시스템에서 Load Average가 8이라면 시스템이 포화 상태에 근접했다고 볼 수 있습니다.

**htop**은 `top`의 향상된 버전으로, 컬러 지원, 마우스 조작, 수평/수직 스크롤, 더 직관적인 프로세스 트리 뷰를 제공합니다.
```bash
sudo apt install htop    # Debian/Ubuntu
sudo dnf install htop    # Fedora/RHEL
htop
```

### pstree – 프로세스 관계를 트리로 표현
프로세스의 상속 관계를 한눈에 보기 좋게 표현합니다.
```bash
pstree -p        # PID 함께 표시
pstree -au       # 사용자 이름과 명령어 인자까지 표시
```

---

## 프로세스 검색과 제어

### pgrep / pidof – 이름으로 프로세스 찾기
```bash
# nginx 관련 프로세스의 PID와 전체 명령어 찾기
pgrep -a nginx

# 특정 사용자(www-data)가 실행한 nginx 프로세스 찾기
pgrep -u www-data nginx

# 명령어 라인 전체에서 패턴 매칭 ('python'으로 시작하고 'serve'를 포함)
pgrep -f "python .*serve"

# 특정 실행 파일의 PID만 간단히 얻기
pidof sshd
```

### kill / killall – 프로세스에 시그널 전송
프로세스 종료는 단순히 `kill -9`부터 시작하기보다는 정상 종료 절차를 거치는 것이 좋습니다.

```bash
# 정상 종료 요청 (SIGTERM, 시그널 번호 15) - 프로세스가 정리 작업을 수행할 기회를 줌
kill 1234
# 또는
kill -TERM 1234

# 강제 종료 (SIGKILL, 시그널 번호 9) - 무조건적 즉시 종료. 마지막 수단으로 사용.
kill -9 1234
# 또는
kill -KILL 1234

# 데몬 재로딩 (SIGHUP) - 설정 파일 재읽기 등에 사용 (nginx, Apache 등이 지원)
kill -HUP $(pidof nginx)

# 프로세스 이름으로 일괄 시그널 전송
killall -TERM myworker      # 모든 'myworker' 프로세스에 SIGTERM 전송
killall -9 code             # 모든 'code' 프로세스에 SIGKILL 전송
```

### 시그널(Signal) 주요 종류
시그널은 프로세스 간 통신의 기본 메커니즘입니다.

| 시그널 | 번호 | 의미와 일반적 용도 |
|---|---|---|
| **SIGHUP** | 1 | Hangup. 터미널 연결 끊김 또는 데몬의 설정 재로딩 신호. |
| **SIGINT** | 2 | Interrupt. 터미널에서 Ctrl+C를 누를 때 전송. 대화형 프로그램 종료. |
| **SIGQUIT** | 3 | Quit. 터미널에서 Ctrl+\를 누를 때 전송. 코어 덤프 생성 후 종료. |
| **SIGTERM** | 15 | Terminate. 정상 종료 요청. 기본 `kill` 시그널. |
| **SIGKILL** | 9 | Kill. 강제 종료. 프로세스에서 잡거나 무시할 수 없음. |
| **SIGSTOP** | 19 | Stop. 실행 중지 (일시정지). 프로세스에서 잡거나 무시할 수 없음. |
| **SIGCONT** | 18 | Continue. SIGSTOP 등으로 중지된 프로세스를 재개. |
| **SIGUSR1** | 10 | User Defined 1. 응용 프로그램이 자유롭게 정의하여 사용. |
| **SIGUSR2** | 12 | User Defined 2. 응용 프로그램이 자유롭게 정의하여 사용. |

안전한 종료를 위한 스크립트 패턴:
```bash
# 먼저 정상 종료 요청(SIGTERM)을 보내고, 일정 시간 대기 후에도 살아있으면 강제 종료(SIGKILL)
kill -TERM $PID && sleep 5 && kill -0 $PID 2>/dev/null && kill -KILL $PID
```

---

## 프로세스 우선순위 조정: nice와 renice

`nice` 값은 프로세스의 CPU 스케줄링 우선순위에 영향을 미칩니다. 값이 낮을수록(-20) 우선순위가 높고, 값이 높을수록(+19) 우선순위가 낮아집니다. 일반 사용자는 자신의 프로세스 우선순위를 낮출 수만 있고, 높이려면 `sudo` 권한이 필요합니다.

```bash
# 낮은 우선순위(nice 값 +10)로 새 스크립트 시작
nice -n 10 ./cpu_intensive_script.sh

# 이미 실행 중인 프로세스(PID 1234)의 우선순위를 높이기 (nice 값 -5)
sudo renice -n -5 -p 1234
```

---

## 장기 실행 작업과 세션 관리

터미널에서 시작한 프로세스는 기본적으로 해당 터미널 세션과 연결됩니다. 세션이 끊기면(`SIGHUP` 수신) 프로세스도 종료됩니다. 이를 방지하고 백그라운드에서 작업을 유지하는 방법이 여러 가지 있습니다.

```bash
./long_task.sh &           # 명령 끝에 '&'를 붙여 백그라운드에서 실행
jobs                       # 현재 셸의 백그라운드 작업 목록 확인
fg %1                      # 백그라운드 작업 1번을 포그라운드로 가져오기
bg %1                      # 중지된 작업 1번을 백그라운드에서 재개

nohup ./long_task.sh &     # 터미널 종료 후에도 프로세스 유지 (출력은 nohup.out으로)

# 이미 실행 중인 백그라운드 작업을 disown하여 셸의 작업 테이블에서 제거하고 HUP 시그널 무시
disown -h %1

# 새로운 독립적인 세션에서 프로세스 시작 (부모 셸과의 연결 끊기)
setsid ./server &
```
실무에서는 `tmux`나 `screen`과 같은 터미널 멀티플렉서를 사용하여 세션을 유지하는 것이 가장 강력하고 유연한 방법입니다.
```bash
tmux new -s mysession      # 새 세션 생성
# 세션 내에서 작업 실행 후 Ctrl+b, d 를 눌러 분리(detach)

tmux attach -t mysession   # 기존 세션에 재연결(attach)
```

---

## 고급 진단 도구

### lsof – 열린 파일과 네트워크 소켓 나열
```bash
# 특정 프로세스(PID)가 열고 있는 모든 파일 디스크립터 보기
sudo lsof -p <PID>

# 특정 포트(예: 8080)를 사용하는 프로세스 찾기
sudo lsof -i :8080
```

### strace – 시스템 호출 추적
프로세스가 수행하는 모든 시스템 호출(커널 서비스 요청)을 실시간으로 보여줍니다. 프로그램이 멈추거나 오동작하는 원인을 파악하는 데 매우 유용합니다.
```bash
# 실행 중인 프로세스에 붙어 시스템 호출 추적 시작
sudo strace -p <PID> -o trace.txt

# 새 프로그램을 실행하면서부터 모든 시스템 호출 추적 (자식 프로세스 포함)
sudo strace -f -tt -s 200 -o trace.txt ./troublesome_program
```

### perf – 성능 프로파일링
시스템 전반 또는 특정 프로세스의 성능 병목 지점을 분석하는 도구입니다.
```bash
# 실시간 시스템 전체 성능 프로파일링
sudo perf top
```

---

## 프로세스 리소스 제한

### ulimit – 셸 및 프로세스별 제한 설정
현재 셸 세션과 그 자식 프로세스들에 적용되는 소프트 제한을 설정합니다.
```bash
ulimit -a                    # 현재 모든 제한 값 확인
ulimit -n 1048576            # 프로세스당 최대 열 수 있는 파일 수 상향 조정
ulimit -u 4096               # 사용자당 최대 프로세스 수 설정
```
주의: `ulimit` 명령은 현재 셸 세션에만 적용됩니다. 사용자 전역이나 시스템 전역의 영구 설정을 위해서는 `/etc/security/limits.conf` 파일을 수정하거나, systemd 서비스 유닛 파일에서 `LimitNOFILE=` 등의 지시어를 사용하는 것이 더 일반적입니다.

### cgroups v2 – 시스템 수준의 정교한 리소스 제어
cgroups(control groups)는 프로세스 그룹 단위로 CPU, 메모리, 디스크 I/O, 네트워크 대역폭 등을 세밀하게 제한하고 격리하는 커널 기능입니다. systemd는 각 서비스 유닛을 자동으로 별도의 cgroup으로 관리하며, 유닛 파일 옵션을 통해 리소스 제한을 쉽게 설정할 수 있습니다.

---

## 서비스 관리: systemd

현대 대부분의 리눅스 배포판은 시스템 및 서비스 관리자로 **systemd**를 사용합니다.

### 기본 명령어
```bash
sudo systemctl start nginx      # 서비스 시작
sudo systemctl stop nginx       # 서비스 정지
sudo systemctl restart nginx    # 서비스 재시작 (중지 후 시작)
sudo systemctl reload nginx     # 서비스 재로드 (설정만 다시 읽기)
sudo systemctl status nginx     # 서비스 상태 상세 확인
sudo systemctl enable nginx     # 부팅 시 자동 시작 활성화
sudo systemctl disable nginx    # 부팅 시 자동 시작 비활성화
sudo systemctl is-enabled nginx # 자동 시작 활성화 여부 확인
systemctl list-units --type=service --all # 모든 서비스 유닛 목록
```

### journalctl – systemd 저널(로그) 조회
systemd는 기존의 텍스트 로그 파일(`/var/log/`) 대신 이진 저널에 로그를 저장하며, `journalctl`로 조회합니다.
```bash
journalctl -u nginx                      # nginx 서비스의 모든 로그
journalctl -u nginx --since "2025-11-10 09:00" # 특정 시간 이후 로그
journalctl -u nginx -f                   # 로그 실시간 팔로우 (tail -f 와 유사)
journalctl -p err..emerg                 # 오류(err)부터 긴급(emerg) 수준의 로그만 필터링
journalctl -b -1                         # 직전(-1) 부팅 시의 로그만 조회
journalctl --disk-usage                  # 저널이 사용하는 디스크 공간 확인
```

---

## 실전: 커스텀 systemd 서비스 유닛 작성

서비스를 systemd로 관리하려면 서비스 유닛 파일(`.service`)을 정의해야 합니다. 파일은 일반적으로 `/etc/systemd/system/` 디렉터리에 위치합니다.

### 간단한 Python HTTP 서버 유닛 예제
```ini
# /etc/systemd/system/hello-http.service
[Unit]
Description=Hello HTTP Server
After=network-online.target   # 네트워크 연결 후 시작
Wants=network-online.target   # 네트워크를 필요로 함

[Service]
ExecStart=/usr/bin/python3 -m http.server 8080
WorkingDirectory=/srv/hello   # 작업 디렉터리 설정
User=www-data                 # 저권한 사용자로 실행
Group=www-data
Restart=on-failure            # 비정상 종료 시 재시작
RestartSec=2                  # 재시작 전 대기 시간

# 리소스 제한 (cgroup 기반)
LimitNOFILE=65535             # 최대 파일 디스크립터 수
MemoryMax=256M                # 최대 메모리 사용량
CPUQuota=50%                  # 최대 CPU 시간 비율 (한 코어의 50%)

# 환경 변수 설정
Environment=HELLO_MODE=prod

[Install]
WantedBy=multi-user.target    # 시스템이 multi-user.target에 도달할 때 이 서비스 시작
```

파일을 작성한 후 적용하고 서비스를 시작합니다.
```bash
# 서비스에 필요한 디렉터리와 파일 준비
sudo mkdir -p /srv/hello
echo "Hello from systemd service" | sudo tee /srv/hello/index.html

# systemd에 새 유닛 파일 인지시키기
sudo systemctl daemon-reload

# 서비스 활성화(부팅 시 자동 시작) 및 즉시 시작
sudo systemctl enable --now hello-http.service

# 서비스 상태 확인
systemctl status hello-http

# 서비스가 예상대로 8080 포트를 열었는지 확인
ss -tulpn | grep :8080
```

### 서비스 로그 확인과 안전한 재시작
```bash
# 서비스 재시작
sudo systemctl restart hello-http

# 서비스의 최근 로그 50줄을 역순(가장 최신 먼저)으로 확인
journalctl -u hello-http -n 50 -r
```

---

## 유닛 파일 수정과 오버라이드

기본 제공되는 배포판의 서비스 유닛 파일(`/lib/systemd/system/`)을 직접 수정하는 것은 업데이트 시 변경 사항이 덮어써질 수 있으므로 권장하지 않습니다. 대신 **오버라이드(override)** 기능을 사용합니다.

```bash
# 특정 서비스의 오버라이드 파일을 편집기로 열기
sudo systemctl edit hello-http
```
이 명령은 `/etc/systemd/system/hello-http.service.d/override.conf` 파일을 생성하거나 엽니다. 여기에 기존 설정을 덮어쓰거나 추가할 내용을 작성합니다.
```ini
# /etc/systemd/system/hello-http.service.d/override.conf
[Service]
# 기존 ExecStart를 덮어씀
ExecStart=/usr/bin/python3 -m http.server 9090
# 새로운 환경 변수 추가
Environment=HELLO_GREETING=annyeong
# 재시작 정책 변경
Restart=always
```
변경 후에는 항상 `daemon-reload`를 수행해야 합니다.
```bash
sudo systemctl daemon-reload
sudo systemctl restart hello-http

# 최종적으로 적용된 유닛 설정 전체 보기 (기본 + 오버라이드 병합 결과)
systemctl cat hello-http.service
```

---

## systemd의 고급 구성 요소

### 소켓 활성화(Socket Activation)
서비스가 항상 실행되는 대신, 특정 소켓(포트/유닛 소켓)에 연결 요청이 들어왔을 때만 서비스가 시작되도록 할 수 있습니다. 이는 리소스 사용을 최적화합니다.

**소켓 유닛 파일** (`/etc/systemd/system/echo.socket`):
```ini
[Unit]
Description=Echo Socket

[Socket]
ListenStream=9999   # TCP 9999 포트에서 대기
Accept=no           # 새로운 연결마다 새 인스턴스를 생성하지 않음 (inetd 방식과 다름)

[Install]
WantedBy=sockets.target
```

**서비스 유닛 파일** (`/etc/systemd/system/echo@.service`):
```ini
[Unit]
Description=Echo Server per Connection

[Service]
ExecStart=/usr/bin/socat -v - TCP-LISTEN:9999,fork
StandardInput=socket
```
활성화:
```bash
sudo systemctl enable --now echo.socket
# 이제 9999 포트에 접속하면 systemd가 echo 서비스를 자동으로 시작합니다.
```

### 타이머 유닛(Timer Units): 크론 대체
systemd 타이머는 기존 cron 작업보다 더 정교한 스케줄링(예: 마지막 실행 시간 기준, 시스템 유휴 시 실행)과 통합된 로깅, 의존성 관리 기능을 제공합니다.

**서비스 유닛** (`/etc/systemd/system/backup.service`):
```ini
[Unit]
Description=Nightly Backup
[Service]
Type=oneshot        # 한 번 실행되고 종료되는 작업
ExecStart=/usr/local/bin/backup.sh
```

**타이머 유닛** (`/etc/systemd/system/backup.timer`):
```ini
[Unit]
Description=Nightly Backup Timer
[Timer]
OnCalendar=*-*-* 03:00:00  # 매일 새벽 3시 실행
Persistent=true            # 부팅 시 지난 실행 시간을 기록하여 놓친 실행을 보정
[Install]
WantedBy=timers.target
```
활성화 및 관리:
```bash
sudo systemctl enable --now backup.timer
systemctl list-timers --all  # 모든 활성 타이머와 다음 실행 시간 확인
```

### 타겟(Targets): 런레벨의 진화
systemd 타겟은 전통적인 SysV init의 런레벨과 유사한 개념으로, 특정 상태나 기능 집합을 나타냅니다.
- `multi-user.target`: 텍스트 모드 다중 사용자 환경 (서버 기본값)
- `graphical.target`: 그래픽 로그인 환경 (데스크톱 기본값)
- `reboot.target`, `poweroff.target`: 시스템 재부팅/종료
```bash
systemctl get-default             # 현재 기본 부팅 타겟 확인
sudo systemctl set-default multi-user.target  # 기본 부팅 타겟 변경
```

---

## cgroups를 이용한 서비스별 리소스 제한

systemd 서비스 유닛 파일의 `[Service]` 섹션에서 cgroups 옵션을 직접 지정할 수 있습니다.
```ini
[Service]
...
# CPU 제한
CPUQuota=50%        # 단일 CPU 코어 시간의 50%를 최대 사용 가능
CPUWeight=100       # CPU 시간 배분의 상대적 가중치 (다른 서비스와 비교)

# 메모리 제한
MemoryMax=512M      # 최대 메모리 사용량 (초과 시 프로세스 종료)
MemoryHigh=384M     # '소프트' 제한 (초과 시 커널이 회수 압력 가함)

# I/O 제한 (블록 장치별 설정 가능)
IOWeight=100        # I/O 대역폭 배분의 상대적 가중치
```
설정 적용 후 다음과 같이 cgroup 상태를 모니터링할 수 있습니다.
```bash
systemctl status hello-http      # 서비스 상태에서 리소스 제한 정보 확인
systemd-cgls                     # cgroup 계층 구조 트리로 보기
systemd-cgtop                    # cgroup별 실시간 리소스 사용량 (top과 유사)
```

---

## 트러블슈팅 가이드라인

서비스나 프로세스에 문제가 발생했을 때 체계적으로 접근하는 방법입니다.

### 1. 서비스가 시작되지 않을 때
```bash
# 1단계: 서비스 상태와 마지막 에러 메시지 확인
systemctl status my.service

# 2단계: 서비스의 상세 로그 확인 (이번 부팅 이후)
journalctl -u my.service -b

# 3단계: 최신 로그부터 역순으로 상위 20줄 확인
journalctl -u my.service -r | head -20

# 4단계: ExecStart 명령을 서비스와 동일한 환경에서 수동 실행 테스트
sudo -u serviceuser /path/to/mybin --check

# 5단계: 서비스에 설정된 환경변수 확인
systemctl show -p Environment my.service
```

### 2. 포트 충돌 문제
```bash
# 특정 포트(8080)를 사용 중인 프로세스 찾기
ss -tulpn | grep :8080

# 더 상세한 정보 (열린 파일 포함)
sudo lsof -i :8080
```

### 3. 파일 권한, 경로, SELinux 문제
```bash
# 파일 경로의 각 구성 요소 권한 확인
namei -l /srv/app/config.yaml

# 파일의 SELinux 보안 컨텍스트 확인
ls -lZ /srv/app/config.yaml

# SELinux가 강제 모드인지 확인 및 최근 차단(AVC) 메시지 조회
getenforce
sudo ausearch -m avc -ts recent
```

### 4. CPU/메모리 사용량 과다
```bash
# 시스템 전체 리소스 사용량 확인
top   # 또는 htop

# cgroup별 리소스 사용량 확인
sudo systemd-cgtop

# 특정 프로세스의 메모리와 스레드 정보 확인
cat /proc/<pid>/status | egrep 'VmRSS|VmSize|Threads'

# 문제 프로세스의 우선순위를 낮춰 다른 작업에 영향을 줄이기
sudo renice -n 10 -p <pid>
```

### 5. I/O 대기(D 상태) 프로세스
```bash
# D 상태(Uninterruptible sleep)의 프로세스 찾기
ps -eo pid,stat,cmd | awk '$2 ~ /D/ {print}'

# 디스크 I/O 상태 모니터링 (sysstat 패키지의 iostat)
sudo iostat -xz 1
```

### 6. 파일 디스크립터 부족
```bash
# 특정 프로세스가 열고 있는 파일 디스크립터 수 확인
sudo ls -l /proc/<pid>/fd | wc -l

# 시스템/사용자 전체 제한 확인
ulimit -n
cat /proc/sys/fs/file-max
```

---

## 결론

리눅스에서 프로세스와 서비스를 효과적으로 관리하는 능력은 시스템 관리자와 개발자 모두에게 필수적인 역량입니다. 이 문서는 프로세스의 기본 개념부터 상태 확인, 제어, 그리고 현대 시스템의 핵심인 systemd를 통한 서비스 관리까지의 전반적인 흐름을 다루었습니다.

핵심은 **체계적인 접근**에 있습니다. 프로세스 문제를 마주했을 때는 `ps`, `top`, `strace` 등의 도구로 관찰부터 시작하고, 서비스 문제는 `systemctl status`와 `journalctl`로 로그를 꼼꼼히 확인하는 습관이 중요합니다. 또한, 안정적인 서비스 운영을 위해서는 systemd 유닛 파일을 통해 재시작 정책, 리소스 제한, 보안 강화 옵션들을 적절히 설정하는 것이 좋습니다.

처음에는 명령어와 개념이 많아 보일 수 있지만, 실제로 자주 사용하는 명령어는 한정되어 있습니다. 일상적인 모니터링에는 `htop`과 `journalctl -f`를, 서비스 제어에는 `systemctl` 명령어들을 먼저 익히는 것을 추천합니다. 이를 바탕으로 점차 고급 주제인 소켓 활성화, 타이머, cgroup 리소스 제어 등으로 지식을 확장해 나간다면, 복잡한 리눅스 시스템도 자신 있게 다룰 수 있을 것입니다.