---
layout: post
title: Linux - 프로세스와 서비스 관리
date: 2024-11-05 19:20:23 +0900
category: Linux
---
# 프로세스와 서비스 관리

## 프로세스(Process)란?

- **프로세스**는 실행 중인 프로그램 인스턴스이며, 고유한 **PID**(Process ID)를 가진다.
- 각 프로세스는 **주소 공간**, **파일 디스크립터 테이블**, **시그널 핸들러**, **스레드(선택)**, **크레덴셜(UID/GID/Capabilities)**, **cgroup**과 **네임스페이스** 컨텍스트 등을 보유한다.

### 핵심 용어

- **PID / PPID**: 프로세스 ID / 부모 프로세스 ID
- **UID / EUID**: 실제/유효 사용자 ID (권한 결정에 영향)
- **GID / EGID**: 실제/유효 그룹 ID
- **TTY**: 연결된 터미널
- **스케줄링 우선순위(nice), OOM 점수, cgroup 제약**: 실행·메모리 회수에 영향

---

## 프로세스 상태·생명주기·포크/실행

프로세스 상태는 ps에서 아래처럼 보인다.

| 상태 | 의미 |
|---|---|
| R | Running (실행 중/스케줄 대기) |
| S | Sleeping (대기) |
| D | Uninterruptible sleep (IO 대기) |
| T | Stopped (중지, 트레이스) |
| Z | Zombie (좀비: 종료했으나 부모가 wait 미수행) |

### 개요

- 부모가 `fork()`로 **복제** → 자식이 `execve()`로 **새 프로그램 이미지로 교체**
- 셸에서 새 프로세스를 실행하면 내부적으로 이 흐름을 따른다.

**좀비 처리 예**
```bash
# 좀비 확인

ps -eo pid,ppid,stat,cmd | awk '$3 ~ /Z/ {print}'
# 부모 확인 → 부모 종료 또는 wait 처리 필요

```

---

## /proc로 들여다보기

```bash
# 현재 쉘의 PID

echo $$
# 환경변수/명령줄/상태

cat /proc/$$/environ | tr '\0' '\n'
cat /proc/$$/cmdline | tr '\0' ' '
cat /proc/$$/status
# 열린 파일

ls -l /proc/$$/fd
```

---

## 프로세스 정보 조회: ps / top / htop / pstree
### ps – 현재 프로세스 스냅샷

```bash
ps aux
ps -ef
ps -eo user,pid,ppid,tty,stat,ni,pri,psr,%cpu,%mem,etime,cmd --forest
```
- `--forest`: 트리 형태
- `-o`로 원하는 컬럼 지정

### top – 실시간 모니터

```bash
top
```
주요 단축키:
- `P` CPU 정렬, `M` 메모리 정렬, `k` 종료, `r` renice
- `1` 개별 CPU 표시, `f` 컬럼 선택

**load average 해석**
$$
\text{load} \approx \text{실행 가능한 프로세스 수의 평균}
$$
- 1분/5분/15분 평균을 나타내며, 코어 수 대비 상대적으로 본다(코어 수 ≈ 8일 때 load 8은 꽉 찬 상태에 근접).

### htop – 컬러 인터랙티브 모니터

```bash
htop
```
- 설치: `sudo apt install htop` 또는 `sudo dnf install htop`
- 마우스/펑션키 지원, 트리/필터 UI 편리

### pstree – 프로세스 트리

```bash
pstree -p
pstree -au        # 사용자/인자 표시
```

---

## 빠르게 찾고 죽이기: pgrep / pidof / kill / killall
### pgrep – 이름/사용자/명령줄로 매칭

```bash
pgrep -a nginx            # PID와 커맨드
pgrep -u www-data nginx
pgrep -f "python .*serve" # 전체 커맨드라인 매칭
```

### pidof – 단일 바이너리 PID

```bash
pidof sshd
```

### kill – 시그널 전송

```bash
# 정상 종료 요청 (SIGTERM, 15)

kill 1234
# 강제 종료 (SIGKILL, 9)

kill -9 1234
# HUP 재로딩(데몬이 지원할 때)

kill -HUP $(pidof nginx)
```

### killall – 이름으로 일괄 시그널

```bash
killall -TERM myworker
killall -9 code
```

---

## 시그널 표와 활용

| 시그널 | 번호 | 의미 |
|---|---|---|
| SIGHUP | 1 | 재로딩(전통적), 터미널 끊김 |
| SIGINT | 2 | 인터럽트(Ctrl+C) |
| SIGTERM | 15 | 정상 종료 요청(기본) |
| SIGKILL | 9 | 강제 종료(트랩 불가) |
| SIGQUIT | 3 | 코어덤프 후 종료 |
| SIGSTOP | 19 | 중지 |
| SIGCONT | 18 | 재개 |
| SIGUSR1/2 | 10/12 | 사용자 정의 |

```bash
# → KILL

kill -TERM $PID && sleep 5 && kill -0 $PID || kill -KILL $PID
```

---

## 우선순위 조정: nice / renice

- nice 범위: **-20(가장 높음) ~ +19(가장 낮음)**

```bash
nice -n 10 ./my_script.sh         # 낮은 우선순위로 시작
sudo renice -n -5 -p 1234         # 실행 중인 PID를 더 높게
```

---

## 장기 작업 유지: 백그라운드, nohup, disown, setsid

```bash
./long_task.sh &           # 백그라운드
jobs; fg %1; bg %1         # 잡 제어
nohup ./long_task.sh &     # 로그아웃 후에도 유지 (nohup.out)
disown -h %1               # SIGHUP 무시 등록
setsid ./server &          # 새로운 세션으로 실행
```
- 실무에서는 **tmux/screen**으로 세션을 유지하는 것이 가장 안전.
```bash
tmux new -s work
# Ctrl+b d 로 분리, tmux attach -t work 로 재접속

```

---

## 파일/네트워크 진단: lsof / strace / perf

```bash
# 열려있는 파일/포트

sudo lsof -p <PID>
sudo lsof -i :8080

# 시스템콜 추적(원인 파악)

sudo strace -p <PID> -o trace.txt
sudo strace -f -tt -s 200 -o trace.txt ./suspect

# 성능/샘플링(하이레벨)

sudo perf top
```

---

## 리소스 제한: ulimit / cgroups v2(개요)
### ulimit – 셸/프로세스 레벨 소프트 제한

```bash
ulimit -a
ulimit -n 1048576          # 파일 디스크립터 상향
ulimit -u 4096             # 최대 프로세스 수
```
- 영구 적용은 `/etc/security/limits.conf` 또는 systemd 유닛의 `LimitNOFILE=...` 추천

### cgroups v2 – 시스템 전역 제어(요약)

- **CPU/메모리/IO** 등을 **cgroup 트리**로 제약
- systemd는 유닛 단위로 cgroup을 자동 관리하므로, 서비스에 한정하면 **유닛 옵션으로 설정**하는 편이 간단하다(아래 참조).

---

## 서비스 관리: systemd 기초 명령

```bash
sudo systemctl start nginx
sudo systemctl stop nginx
sudo systemctl restart nginx
sudo systemctl status nginx
sudo systemctl enable nginx     # 부팅 자동 시작
sudo systemctl disable nginx
systemctl list-units --type=service --all
```

### journalctl – 로그

```bash
journalctl -u nginx
journalctl -u nginx --since "2025-11-10 09:00"
journalctl -u nginx -f           # 팔로우
journalctl -p err..emerg         # 심각 로그만
journalctl -b -1                 # 이전 부팅 로그
```

---

## 실전: 나만의 서비스 유닛 작성
### 간단한 웹 서버 유닛

```ini
# /etc/systemd/system/hello-http.service

[Unit]
Description=Hello HTTP
After=network-online.target
Wants=network-online.target

[Service]
ExecStart=/usr/bin/python3 -m http.server 8080
WorkingDirectory=/srv/hello
User=www-data
Group=www-data
Restart=on-failure
RestartSec=2
# 리소스 제한(cgroup)

LimitNOFILE=65535
MemoryMax=256M
CPUQuota=50%
# 환경변수

Environment=HELLO_MODE=prod

[Install]
WantedBy=multi-user.target
```
적용/시작:
```bash
sudo mkdir -p /srv/hello && echo ok | sudo tee /srv/hello/index.html
sudo systemctl daemon-reload
sudo systemctl enable --now hello-http.service
systemctl status hello-http
ss -tulpn | grep :8080
```

### 안전한 재시작 후 로깅

```bash
sudo systemctl restart hello-http
journalctl -u hello-http -n 50 -r
```

---

## 유닛 오버라이드와 드롭인

기존 유닛을 직접 수정하지 말고 **오버라이드** 사용:
```bash
sudo systemctl edit hello-http
```
열리는 드롭인 파일 예:
```ini
[Service]
Environment=HELLO_GREETING=annyeong
Restart=always
```
적용:
```bash
sudo systemctl daemon-reload
sudo systemctl restart hello-http
systemctl cat hello-http.service    # 최종 병합 결과 확인
```

---

## 소켓·타이머·타깃: systemd 확장
### 소켓 활성화(요청 시 스타트)

```ini
# /etc/systemd/system/echo.socket

[Unit]
Description=Echo Socket

[Socket]
ListenStream=9999
Accept=no

[Install]
WantedBy=sockets.target
```
```ini
# /etc/systemd/system/echo.service

[Unit]
Description=Echo Server

[Service]
ExecStart=/usr/bin/socat -v - TCP-LISTEN=9999,fork
```
활성화:
```bash
sudo systemctl enable --now echo.socket
```
접속이 올 때 소켓이 서비스 기동을 트리거한다.

### 타이머(크론 대체)

```ini
# /etc/systemd/system/backup.service

[Unit]
Description=Nightly Backup
[Service]
Type=oneshot
ExecStart=/usr/local/bin/backup.sh
```
```ini
# /etc/systemd/system/backup.timer

[Unit]
Description=Nightly Backup Timer
[Timer]
OnCalendar=*-*-* 03:00:00
Persistent=true
[Install]
WantedBy=timers.target
```
활성화:
```bash
sudo systemctl enable --now backup.timer
systemctl list-timers --all
```

### 타깃(런레벨 유사)

- `multi-user.target`(서버 기본)
- `graphical.target`(GUI)
```bash
systemctl get-default
sudo systemctl set-default multi-user.target
```

---

## cgroup 기반 리소스 제어(서비스 단위)

대표 옵션(서비스의 `[Service]` 섹션):
```ini
# CPU

CPUQuota=50%        # CPU 시간 비율
CPUWeight=100       # 상대 가중치(1..10000)
# 메모리

MemoryMax=512M
MemoryHigh=384M
# IO(장치별 제어는 시스템 구성 의존)

IOWeight=100
```
적용 후:
```bash
systemctl status hello-http
systemd-cgls
systemd-cgtop
```

---

## 서비스·프로세스 트러블슈팅 루틴
### 서비스가 올라오지 않음

```bash
systemctl status my.service        # Active, ExecStart, 최근 로그 요약
journalctl -u my.service -b        # 이번 부팅 로그
journalctl -u my.service -r | head # 최신부터 역순
# ExecStart 바이너리 직접 수동 실행(환경/권한/경로 검증)

sudo -u serviceuser /path/mybin --check
# 환경변수 확인

systemctl show -p Environment my.service
```

### 포트 충돌

```bash
ss -tulpn | grep :8080
sudo lsof -i :8080
```

### 파일 권한/경로/SELinux

```bash
namei -l /srv/app/config.yaml
ls -lZ /srv/app/config.yaml      # SELinux 라벨
getenforce && sudo ausearch -m avc -ts recent
```

### CPU/메모리 폭주

```bash
top / htop
sudo systemd-cgtop
cat /proc/<pid>/status | egrep 'VmRSS|VmSize|Threads'
sudo renice -n 10 -p <pid>
```

### I/O 지연(D 상태)

```bash
ps -eo pid,stat,cmd | awk '$2 ~ /D/ {print}'
sudo iostat -xz 1                 # sysstat 필요
```

### 런어웨이 FD/핸들 부족

```bash
sudo ls -l /proc/<pid>/fd | wc -l
ulimit -n
```

---

## 실전 시나리오 모음
### 시나리오 A: 장기 실행 파이프라인 안전화

```bash
# 안전한 종료 시그널 핸들링을 내장한 스크립트

cat > /usr/local/bin/worker.sh <<'SH'
#!/usr/bin/env bash

set -Eeuo pipefail
trap 'echo "TERM"; exit 0' TERM INT
while true; do
  date
  sleep 2
done
SH
chmod +x /usr/local/bin/worker.sh

# 서비스로 관리

sudo tee /etc/systemd/system/worker.service >/dev/null <<'UNIT'
[Unit]
Description=Safe Worker
After=network.target

[Service]
ExecStart=/usr/local/bin/worker.sh
Restart=on-failure
RestartSec=1
Type=simple

[Install]
WantedBy=multi-user.target
UNIT

sudo systemctl daemon-reload
sudo systemctl enable --now worker.service
```

### 시나리오 B: 저권한 + 저지연 서버 구성

```ini
# /etc/systemd/system/lowlatency.service

[Unit]
Description=Low Latency TCP Server
After=network-online.target
Wants=network-online.target

[Service]
ExecStart=/usr/local/bin/myserver --port 8443
User=app
Group=app
AmbientCapabilities=CAP_NET_BIND_SERVICE
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=full
ProtectHome=true
RestrictSUIDSGID=true
LockPersonality=true
MemoryMax=256M
CPUQuota=80%
Restart=always

[Install]
WantedBy=multi-user.target
```
- `AmbientCapabilities`로 1024 미만 포트 바인딩 권한을 최소 부여(CAP).

### 시나리오 C: 크론 대체로 신뢰성 있는 배치

```ini
# /etc/systemd/system/report.service

[Unit]
Description=Nightly Report
[Service]
Type=oneshot
User=reporter
ExecStart=/usr/local/bin/gen_report.sh

# /etc/systemd/system/report.timer

[Unit]
Description=Nightly Report Timer
[Timer]
OnCalendar=Mon..Fri 02:30
Persistent=true
RandomizedDelaySec=120
[Install]
WantedBy=timers.target
```
- `Persistent=true`: 다운타임 후 부팅 시 놓친 실행 보정
- `RandomizedDelaySec`: 몰림 방지

---

## 참고: 쉘 잡 제어 요령

```bash
sleep 600 &
jobs
kill -STOP %1     # 중지
bg %1             # 백그라운드 재개
fg %1             # 포그라운드
```
- 포그라운드 잡은 **Ctrl+Z**로 중지 → `bg`로 재개 가능

---

## 정리 표

| 작업 | 명령 |
|---|---|
| 현재 프로세스 조회 | `ps aux`, `ps -ef`, `ps -eo ... --forest` |
| 실시간 모니터 | `top`, `htop` |
| 트리 보기 | `pstree -p` |
| 이름→PID | `pgrep`, `pidof` |
| 종료 | `kill`, `killall` |
| 우선순위 | `nice`, `renice` |
| 백그라운드/유지 | `&`, `jobs`, `fg/bg`, `nohup`, `disown`, `tmux` |
| 파일/포트 진단 | `lsof`, `ss`, `strace` |
| 서비스 제어 | `systemctl start/stop/restart/status/enable` |
| 로그 | `journalctl -u svc -f`, `-p err`, `-b` |
| 리소스 제한 | `ulimit`, systemd(`CPUQuota`, `MemoryMax`) |

---

## 체크리스트

- 종료는 **SIGTERM → 대기 → SIGKILL** 순으로 안전하게
- 서비스는 **systemd 유닛**으로 표준화하고, 변경은 **오버라이드** 사용
- 로그는 **journalctl** 필터(유닛/우선순위/시간/팔로우)로 즉시 접근
- 과도 권한(setuid)은 지양, **Capabilities**/`NoNewPrivileges=true`/`Protect*`를 선호
- cgroup 옵션으로 **CPU/메모리**를 서비스 단위 제한
- 트러블슈팅은 **status→journal→포트→권한/SELinux→리소스** 순
