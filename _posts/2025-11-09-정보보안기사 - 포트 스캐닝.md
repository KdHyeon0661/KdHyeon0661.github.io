---
layout: post
title: 정보보안기사 - 포트 스캐닝
date: 2025-11-09 19:25:23 +0900
category: 정보보안기사
---
# SECTION 04 네트워크 기본 학습 — 11. 포트 스캐닝(Port Scanning)

## 1. 개요 — 포트 스캐닝이란?

- **정의**: 대상 호스트/네트워크의 **전송 계층 포트(TCP/UDP/SCTP 등) 상태**와 **서비스 가시성**을 확인하기 위해 **특정 패킷을 전송하고 응답을 관측**하는 절차.
- **목적(합법적 운영)**  
  1) **자산 인벤토리**: 가동 중 서비스, 운영 포트, 버전 추정  
  2) **노출 면 관리**: 외부/내부에서 **열려 있으면 안 되는 포트** 식별  
  3) **변경 검증**: 방화벽/ACL/배포 후 정책 준수 확인  
  4) **탐지 튜닝**: IDS/IPS/EDR 시그니처 검증, 허위 양성(오탐) 줄이기
- **윤리/법적 주의**: 명시적 허가, 범위·기간·출발지 화이트리스트, 속도 제한, 로그/보고 체계.

---

## 2. 네트워크 배경 — TCP·UDP 응답 모델

### 2.1 TCP 3-way 핸드셰이크(요약)
```
클라이언트                        서버
   SYN  -------------------------->
        <---------------------  SYN-ACK
   ACK  -------------------------->
(세션 성립)
```
- **SYN → SYN-ACK → ACK**가 정상.  
- 포트가 **닫힘(closed)**이면 일반적으로 **RST** 응답.  
- 방화벽/필터에 막히면 **무응답(or ICMP type 3 code 13 등)**.

### 2.2 UDP
- **연결성 없음**. 요청 전송 후  
  - **ICMP Port Unreachable**(type 3 code 3)이면 **닫힘**으로 추정,  
  - **응답(payload)** 오면 **열림**,  
  - **무응답**이면 **필터링/열림 추정 불가**(재시도/프로브 필요).

---

## 3. 스캔 유형 — 개념과 응답 해석

### 3.1 TCP 기반

| 유형 | 전송 패킷 | 열림(Open) | 닫힘(Closed) | 필터(Filtered) | 특징/용도 |
|---|---|---|---|---|---|
| **Connect()** | 소켓 연결 시도 | 3-way 성공 | RST | 무응답/ICMP | 정확/로그 남음(애플리케이션 로그 가능) |
| **SYN(half-open)** | SYN | SYN-ACK 관측(ACK 미송) | RST | 무응답/ICMP | 널리 쓰임, 서비스에 비교적 덜 부하 |
| **ACK 프로브** | ACK | RST(비필터) | RST | 무응답/ICMP | 방화벽 존재 감지(필터링 판별 보조) |
| **FIN/NULL/Xmas** | FIN / 플래그 없음 / FIN+PSH+URG | 무응답이면 Open|Filtered 추정 | RST | 무응답/ICMP | 일부 스택 특성 이용(표준적이지 않음) |
| **Maimon** | FIN/ACK | 무응답(Open|Filtered) | RST | 무응답/ICMP | 특정 구현 탐색 |

> 주의: FIN/NULL/Xmas 기반 판정은 운영체제에 따라 달라 **보조 신호**로만 해석.

### 3.2 UDP 기반

| 유형 | 전송 패킷 | 열림 | 닫힘 | 필터 | 비고 |
|---|---|---|---|---|---|
| **UDP 프로브** | 빈/특정 payload | 응답(payload) | ICMP Port Unreachable | 무응답 | DNS/SNMP/NTP 등 서비스별 페이로드 권장 |

### 3.3 서비스/버전 탐색(애플리케이션 계층)

- **Banner grabbing**: 연결 후 서버가 보내는 초깃값(예: `220 smtp.example ESMTP`)을 읽어 버전/제품 추정.  
- **능동 프로빙**: 프로토콜별 **핸드셰이크 일부**를 수행해 버전/기능 추정(예: TLS ClientHello, HTTP `HEAD /`).

---

## 4. 스캔 결과 상태 — 용어 정리

| 용어 | 의미 |
|---|---|
| **open** | 대상 포트가 수신/응답하며(서비스가 대기 중), 접근 가능 |
| **closed** | 포트가 열려 있지 않음(RST/ICMP Port Unreachable 등) |
| **filtered** | 방화벽/ACL 등으로 필터되어 판정 불가(무응답/ICMP administratively prohibited 등) |
| **open\|filtered** | UDP/FIN/NULL/Xmas 등 **응답이 없어** 열림 또는 필터임을 구분 불가 |
| **closed\|filtered** | 드물지만 정책상 분간 어려운 상태 |

---

## 5. 시간·부하 모델(개념) — 스캔 소요 추정

- 포트 수를 \(N\), 재시도 횟수 \(r\), 타임아웃 \(T\), 평균 왕복 \(RTT\), **동시성** \(C\)라 하면 간단 근사:
$$
\text{시간} \approx \frac{N \cdot r \cdot \max(RTT,T)}{C}.
$$
- UDP/필터 구간은 **무응답 타임아웃 지배** → \(T\) 조정·재시도 최소화·서비스 특정 페이로드 사용 권장.

---

## 6. 안전한 랩 구성 — 네임스페이스(자체 트래픽만)

> 한 대의 Linux에서 **두 노드와 라우터**를 네임스페이스로 만들고, **내부 전용** 스캔을 수행한다.

### 6.1 토폴로지
```
scanner(ns:scan) -- vethS ---\
                               \-- (ns:gw, 10.10.0.1) -- vethT -- target(ns:tgt, 10.10.0.20)
```

### 6.2 구성 스크립트

```bash
#!/usr/bin/env bash
set -e
ip netns add scan
ip netns add tgt
ip netns add gw

ip link add vethS type veth peer name vethS_gw
ip link add vethT type veth peer name vethT_gw

ip link set vethS     netns scan
ip link set vethS_gw  netns gw
ip link set vethT     netns tgt
ip link set vethT_gw  netns gw

ip netns exec scan ip addr add 10.10.0.10/24 dev vethS
ip netns exec tgt  ip addr add 10.10.0.20/24 dev vethT
ip netns exec gw   ip addr add 10.10.0.1/24  dev vethS_gw
ip netns exec gw   ip addr add 10.10.0.1/24  dev vethT_gw

ip netns exec scan ip link set vethS up
ip netns exec tgt  ip link set vethT up
ip netns exec gw   ip link set vethS_gw up
ip netns exec gw   ip link set vethT_gw up
ip netns exec gw   sysctl -w net.ipv4.ip_forward=1 >/dev/null

ip netns exec scan ip route add default via 10.10.0.1
ip netns exec tgt  ip route add default via 10.10.0.1

# 대상에 데모 서비스 열기(HTTP/SSH 흉내)
ip netns exec tgt python3 -m http.server 8080 >/dev/null 2>&1 &
ip netns exec tgt ncat -lk 2222 -c 'xargs -n1 echo "ssh-mock:"' >/dev/null 2>&1 &
echo "[OK] lab up"
```

---

## 7. 가장 기초: **직접 TCP connect()** 스캐너(교육용)

> 고성능/회피 기능 없음. **핵심 원리**(성공/실패/타임아웃)만 보여준다. 대상은 **ns:tgt**.

```python
# tcp_connect_scan.py — 교육용 단순 스캐너(본인 랩 전용)
import socket, sys, concurrent.futures, time
target = "10.10.0.20"
ports = [22, 80, 8080, 2222, 443]

def probe(p, timeout=1.0):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(timeout)
    t0 = time.time()
    try:
        s.connect((target, p))
        dt = (time.time()-t0)*1000
        return (p, "open", round(dt,1))
    except socket.timeout:
        return (p, "filtered|timeout", None)
    except Exception as e:
        # ConnectionRefusedError 등 -> closed
        return (p, "closed", None)
    finally:
        s.close()

with concurrent.futures.ThreadPoolExecutor(max_workers=10) as ex:
    for p, state, ms in ex.map(probe, ports):
        print(f"{target}:{p} -> {state} {'' if ms is None else f'({ms} ms)'}")
```

**실행(네임스페이스 scan):**
```bash
ip netns exec scan python3 tcp_connect_scan.py
# 예상 출력(랩):
# 10.10.0.20:22   -> closed
# 10.10.0.20:80   -> closed
# 10.10.0.20:8080 -> open (x ms)
# 10.10.0.20:2222 -> open (x ms)
# 10.10.0.20:443  -> closed
```

---

## 8. UDP 스캔(교육용) — 서비스별 페이로드

> DNS/모의 SNMP 등은 **특정 쿼리**를 보내야 응답을 받기 쉬움. 아래는 **간단 DNS A 쿼리** 예.

```python
# udp_dns_probe.py — UDP 53에 단순 A 쿼리(교육용)
import socket, sys, time, random, struct
target = "10.10.0.20"
port = 53

# 간단 DNS 헤더/쿼리 생성 (example.com A)
def dns_query(host="example.com", qtype=1):
    tid = random.randint(0, 0xffff)
    flags = 0x0100
    qdcount = 1
    header = struct.pack(">HHHHHH", tid, flags, qdcount, 0, 0, 0)
    # QNAME
    qname = b''.join(len(l).to_bytes(1, 'big') + l.encode() for l in host.split('.')) + b'\x00'
    qclass = 1
    question = qname + struct.pack(">HH", qtype, qclass)
    return tid, header + question

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(1.0)
tid, pkt = dns_query()
t0 = time.time()
try:
    sock.sendto(pkt, (target, port))
    data, _ = sock.recvfrom(2048)
    dt = (time.time()-t0)*1000
    print(f"UDP {target}:{port} -> response ({round(dt,1)} ms), len={len(data)}")
except socket.timeout:
    print(f"UDP {target}:{port} -> open|filtered? (no response)")
except Exception as e:
    print(f"UDP {target}:{port} -> error: {e}")
finally:
    sock.close()
```

> 교육 포인트: **무응답=열림이 아님**. UDP는 **ICMP Port Unreachable**이 닫힘 신호. 실제 도구는 재시도·페이로드·시간 제어가 정교함.

---

## 9. 표준 도구로 보기 — (랩 한정) 명령 예시

> 다음 명령은 **랩 네임스페이스에 한정**. 실제 운영망에는 사전 승인 필수.

### 9.1 포트/서비스 개요(느긋한 기본 스캔)
```bash
# TCP 기본 스캔(서비스 판단 포함)
ip netns exec scan nmap -sS -sV -p 1-1024,2222,8080 --reason 10.10.0.20
```

- `-sS`(SYN) 결과: 8080/tcp, 2222/tcp open, 나머지 closed/filtered 판정  
- `-sV`: 배너/프로빙으로 버전/프로토콜 추정(HTTP server, mock ssh 등)

### 9.2 UDP 대표 포트만(서비스 페이로드 동반)
```bash
ip netns exec scan nmap -sU --top-ports 20 --reason 10.10.0.20
```

- `-sU`: UDP. 많은 포트가 **open|filtered**로 나올 수 있음 → 서비스별 스크립트 권장.

> 속도/회피·스푸핑 등 **공격적 옵션**은 본 문서 범위 밖(교육/방어 관점 유지).

---

## 10. 결과 해석 — 흔한 오판 줄이기

1) **“UDP는 무응답=열림”**이 아님 → `open|filtered`. 추가 프로브/서버 로그/방화벽 카운터로 교차확인.  
2) **침묵 방화벽**: TCP SYN이 **타임아웃**이면 대부분 **filtered**. **RST**면 **closed**.  
3) **애플리케이션 거부**(e.g., TLS SNI 미지정, 프록시 인증)로 **연결은 성공했으나 서비스 불가** → open이지만 접근 불가.  
4) **IPS/레이트 리미트**로 간헐 응답 → 재현시 **속도 낮추고 간격 조절**, 동일 경로/시간대 교차 테스트.  
5) **VIP/Anycast/프록시 뒤**: 백엔드와 앞단 포트 개방이 다를 수 있음 → **경계 위치** 명시.

---

## 11. 방어자 관점 — 탐지·조기 경고

### 11.1 패킷/플로우 시그널

- **단시간 다포트 시도**(한 소스→한 대상 IP, 포트 다양)  
- **한 포트 고정, 다수 대상 IP**(수평 스캔)  
- **비표준 플래그 조합**(NULL/Xmas/FIN)  
- **SYN 비율↑, 응답↓** / **ICMP Port Unreachable 급증(UDP 스캔)**

### 11.2 실무 도구/예시

```bash
# Suricata(간단 룰 예; 실제 룰셋 사용 권장)
alert tcp any any -> $HOME_NET any (msg:"TCP Portscan (many SYN)"; flags:S; threshold:type both, track by_src, count 20, seconds 3; sid:100001;)
alert udp any any -> $HOME_NET any (msg:"UDP Portscan (many dst ports)"; detection_filter:track by_src, count 50, seconds 10; sid:100002;)
```

```zeek
# Zeek — 내장 scan 탐지 프레임워크 활용(개념)
@load base/frameworks/notice
@load policy/misc/scan
# 결과: notice.log 에 스캔 의심 기록
```

```bash
# NetFlow/IPFIX 지표: 소스별 dstPort 유니크 카운트 상위
# (도구의 쿼리 예시 개념 — 실제는 nfdump/Elasticsearch 등)
nfdump -r flows.nfd -o "fmt:%ts %te %sa %da %dp" | awk '{print $3,$5}' | sort | uniq | awk '{cnt[$1]++} END{for(i in cnt) print cnt[i],i}' | sort -nr | head
```

---

## 12. 방어자 관점 — 완화/하드닝

### 12.1 네트워크 경계
- **기본 드롭 정책**(deny-by-default) + **허용 목록(allowlist)**  
- **uRPF/BCP38**(소스 스푸핑 완화), **Bogon 필터**  
- **레이트 리미팅**(SYN, ICMP), **SYN 쿠키**  
- **서비스 분리/프런트 도입**(프록시/LB/WAF)

### 12.2 호스트/서비스
- **불필요 서비스 비활성화/언바인딩**(0.0.0.0 → 127.0.0.1)  
- **방화벽**: `nftables`/Windows Firewall 최소 포트만 개방  
- **배너 최소화**(버전 숨김), **TLS 강제**  
- **서비스 디스커버리/자산관리** 자동화로 **드리프트 최소화**

### 12.3 운영 절차
- **승인 기반 스캔 캘린더**(출발지/대상/속도/시간/담당자/연락망), **사전 알림**  
- **스캔 결과→변경 관리→개방/차단 결정** 체계화  
- **오탐/누락** 분석: 방화벽/IPS 로그와 교차 검증

---

## 13. 체크리스트 — 스캔 전·후·대응

- [ ] **허가/범위/속도/시간대** 문서화, 연락망 공유  
- [ ] **출발지 IP 화이트리스트**(경계/호스트 방화벽)  
- [ ] 스캔 **프로파일(포트 범위/프로토콜/재시도/타임아웃/동시성)** 명시  
- [ ] **UDP 서비스**는 프로토콜별 페이로드 사용 계획  
- [ ] 스캔 중 **모니터링/로그**(경계/호스트/플로우) 동시 수집  
- [ ] 결과는 **open/closed/filtered**로 분류, **증거 캡처** 첨부  
- [ ] **불필요 오픈 포트** 즉시 조치(종료/바인딩 변경/ACL)  
- [ ] **정책 준수 리포트**(개방 사유·소유자·만료일/리뷰 주기)  
- [ ] **탐지 룰** 개선(스캔 패턴·속도 범위 반영)  
- [ ] **지속 인벤토리 자동화**(CMDB/ASM 연계)

---

## 14. 운영 스니펫 — 결과를 재현 가능한 리포트로

### 14.1 Bash: 포트 상태 요약(소켓 연결 기반)
```bash
#!/usr/bin/env bash
# scan_summary.sh — 간단 포트 상태 요약(교육용)
TARGET="${1:-10.10.0.20}"
PORTS="22 80 443 8080 2222"
echo "target,port,state,ms"
for p in $PORTS; do
  t0=$(date +%s%3N)
  (echo >/dev/tcp/$TARGET/$p) >/dev/null 2>&1
  rc=$?
  t1=$(date +%s%3N)
  ms=$((t1-t0))
  if [ $rc -eq 0 ]; then st="open"; else st="closed|filtered"; fi
  echo "$TARGET,$p,$st,$ms"
done
```

### 14.2 PowerShell: 간단 TCP 검사
```powershell
param([string]$Target="10.10.0.20",[int[]]$Ports=@(22,80,443,8080,2222))
"target,port,state,ms"
foreach ($p in $Ports) {
  $sw = [System.Diagnostics.Stopwatch]::StartNew()
  $r = Test-NetConnection -ComputerName $Target -Port $p -WarningAction SilentlyContinue
  $sw.Stop()
  $state = $r.TcpTestSucceeded ? "open" : "closed|filtered"
  "{0},{1},{2},{3}" -f $Target,$p,$state,$sw.ElapsedMilliseconds
}
```

---

## 15. 예제: 스캔 결과 해석 표(랩 대상)

| 포트 | 스캔 유형 | 응답 | 판정 | 조치 예 |
|---|---|---|---|---|
| 8080/tcp | SYN | SYN-ACK | open | 내부 서비스? 외부 노출 불필요 시 차단 |
| 2222/tcp | Connect | 연결됨, 배너 `ssh-mock` | open | 운영 SSH는 22만 허용, 2222 종료 |
| 53/udp | UDP | 무응답 | open\|filtered | 서버 기능 여부 확인, 방화벽 로그/ICMP 확인 |
| 443/tcp | SYN | 타임아웃 | filtered | 경계 방화벽 차단 정상인지 정책 검토 |

---

## 16. 예상 문제(필답/실무)

1) **SYN 스캔**에서 `open/closed/filtered`를 구분하는 **응답 패턴**을 서술하라.  
2) **UDP 스캔**에서 `open|filtered` 판정이 많은 이유와, **확정적 닫힘**을 어떻게 식별하는지 쓰라.  
3) 스캔 결과에서 `open`이지만 **서비스 접근 불가**인 사례가 생기는 이유 2가지를 제시하라.  
4) **플로우 기반**(NetFlow/IPFIX)으로 수평/수직 스캔을 구분하는 지표를 설명하라.  
5) **방어 측**에서 스캔을 줄이기 위한 **네트워크/호스트** 3가지 하드닝 조치를 나열하라.

---

## 17. 마무리

- 포트 스캐닝은 **관측 실험**이다. 올바른 **응답 모델 이해**와 **판정의 한계**(특히 UDP)를 인지해야 한다.  
- 스캔 자체보다 **결과를 바탕으로 한 노출 면 축소**가 핵심 가치다.  
- **탐지·대응**은 시그니처(패킷) + 통계(플로우) + 정책(허용 목록) 세 축을 함께 다룬다.

---
```bash
# 부록 — nmap 출력 파서를 이용한 리포트 변환(개념)
# nmap -oG out.gnmap 형태를 CSV로 가공하는 awk 한 줄 예시
awk '/Ports:/{split($0,a,"Ports: "); split(a[2],b,", "); for(i in b){split(b[i],c,"/"); printf "%s,%s,%s\n",$2,c[1],c[2]}}' out.gnmap > ports.csv
```