---
layout: post
title: C++ - RAII
date: 2024-09-20 19:20:23 +0900
category: Cpp
---
# RAII(Resource Acquisition Is Initialization)

## 0. RAII 핵심 한 문장

**객체의 수명과 자원의 수명을 일치**시켜, **생성자에서 획득**하고 **소멸자에서 해제**한다.
예외가 터져도 스택 언와인딩(해제)이 자동으로 발생하므로 **누수 없이** 안전하다.

---

## 1. 동기부여: 예외와 조기 반환 속에서도 안전해야 한다

```cpp
void legacy() {
    FILE* f = std::fopen("data.bin", "wb"); // 획득
    if (!f) throw std::runtime_error("open failed");

    do_something_may_throw();               // 여기서 예외가 나면?

    std::fclose(f);                         // ❌ 도달 못하면 누수
}
```

RAII로 바꾸면:

```cpp
#include <cstdio>
#include <stdexcept>

class File {
    std::FILE* fp{};
public:
    explicit File(const char* path, const char* mode = "wb")
        : fp(std::fopen(path, mode)) {
        if (!fp) throw std::runtime_error("open failed");
    }
    ~File() noexcept {
        if (fp) std::fclose(fp);
    }
    std::FILE* get() const noexcept { return fp; }
};

void modern() {
    File f{"data.bin", "wb"};               // 생성 시 획득
    do_something_may_throw();               // 예외 나도
} // ✅ 소멸자에서 자동 close()
```

---

## 2. 예외 안전성(Exception Safety)과 RAII

예외 안전성은 보통 세 단계로 구분한다:

- **기본 보장(Basic)**: 예외가 나도 **불변식(invariant)** 유지, 누수 없음.
- **강한 보장(Strong)**: 실패 시 **상태 롤백** — 연산 전 상태로 되돌림.
- **예외 없음(No-throw)**: 연산이 절대 예외를 던지지 않음.

RAII는 최소 **기본 보장**을 자동으로 달성한다. **강한 보장**은 보조 기법(복사-후-교체)과 함께 달성:

```cpp
#include <vector>
#include <algorithm>

struct SafeVec {
    std::vector<int> v;

    // 강한 보장: 실패 시 this.v는 바뀌지 않는다
    void append_strong(const std::vector<int>& more) {
        std::vector<int> tmp = v;         // 복사(강한 보장의 비용)
        tmp.insert(tmp.end(), more.begin(), more.end()); // 여기서 예외 가능
        v.swap(tmp);                       // Strong 보장: commit point
    }
};
```

수식으로 요약:

$$
\text{try\_op}() =
\begin{cases}
\text{commit(new)} & \text{if success} \\
\text{preserve(old)} & \text{if throw}
\end{cases}
$$

---

## 3. STL과 표준 RAII: **스마트 포인터** & **락**

### 3.1 스마트 포인터 (요지)
- `std::unique_ptr<T, Deleter>`: **단독 소유**. 가장 가볍고 안전.
- `std::shared_ptr<T>`: **공유 소유** (참조 카운트). 순환 참조 주의 → `std::weak_ptr`.
- **커스텀 삭제자**로 C API, OS 핸들 등에 적용 가능.

```cpp
#include <memory>
#include <cstdio>

struct FileCloser {
    void operator()(std::FILE* f) const noexcept {
        if (f) std::fclose(f);
    }
};

using FilePtr = std::unique_ptr<std::FILE, FileCloser>;

FilePtr open_file(const char* path, const char* mode) {
    std::FILE* f = std::fopen(path, mode);
    if (!f) throw std::runtime_error("open failed");
    return FilePtr{f}; // ✅ 예외든 조기리턴이든 닫힌다
}
```

### 3.2 동기화/락의 RAII
- `std::lock_guard<std::mutex>`: 스코프 기반 락 획득/해제.
- `std::unique_lock<std::mutex>`: 더 유연(지연 잠금, 해제/재잠금, 조건변수).

```cpp
#include <mutex>
#include <thread>
#include <vector>

std::mutex m;
int shared_counter{};

void worker() {
    std::lock_guard<std::mutex> lk(m); // 생성 시 lock, 파괴 시 unlock
    ++shared_counter;
}

int main() {
    std::vector<std::thread> ts;
    for (int i = 0; i < 8; ++i) ts.emplace_back(worker);
    for (auto& t : ts) t.join();
}
```

**데드락 회피**: 다중 락은 `std::scoped_lock l(a, b);` 로 **원자적 락 순서**를 확보.

---

## 4. 스코프 가드(Scope Guard) 패턴

C++23에는 `std::scope_exit`가 표준화(지원 여부는 구현에 따름). C++17에서는 직접 구현해도 된다.

```cpp
#include <utility>
#include <functional>

class scope_exit {
    std::function<void()> f_;
    bool active_ = true;
public:
    template <class F>
    explicit scope_exit(F&& f) : f_(std::forward<F>(f)) {}
    ~scope_exit() noexcept { if (active_) f_(); }
    void release() noexcept { active_ = false; }
};

void demo() {
    FILE* f = std::fopen("tmp.txt", "w");
    if (!f) return;

    scope_exit on_exit{[&](){ std::fclose(f); }}; // 스코프 종료 시 닫힘

    // ... 도중 예외/return이 있어도 안전
    std::fputs("hello", f);
} // ✅ fclose
```

---

## 5. 다양한 자원에 대한 RAII 레시피

### 5.1 파일 스트림
```cpp
#include <fstream>
void log() {
    std::ofstream out("log.txt"); // 생성 시 open
    out << "RAII is powerful\n";
} // ✅ 자동 close
```

### 5.2 POSIX 파일 디스크립터
```cpp
#include <unistd.h>   // ::close
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdexcept>

class fd_guard {
    int fd_ = -1;
public:
    explicit fd_guard(const char* path) {
        fd_ = ::open(path, O_CREAT|O_WRONLY, 0644);
        if (fd_ < 0) throw std::runtime_error("open failed");
    }
    ~fd_guard() noexcept { if (fd_ >= 0) ::close(fd_); }
    int get() const noexcept { return fd_; }
};
```

### 5.3 Windows HANDLE
```cpp
#include <windows.h>
#include <stdexcept>

class handle_guard {
    HANDLE h_ = INVALID_HANDLE_VALUE;
public:
    explicit handle_guard(HANDLE h) : h_(h) {
        if (h_ == INVALID_HANDLE_VALUE) throw std::runtime_error("invalid handle");
    }
    ~handle_guard() noexcept { if (h_ && h_ != INVALID_HANDLE_VALUE) ::CloseHandle(h_); }
    HANDLE get() const noexcept { return h_; }
};
```

### 5.4 OpenGL/DirectX/DB 커넥션 등
각 API의 `create/delete`, `retain/release` 쌍을 **정확히 매핑**하는 RAII 클래스로 감싼다.

---

## 6. 커스텀 삭제자(Deleter)와 타입 크기

`unique_ptr<T, D>`는 `D`의 인스턴스를 **내부에 보관**하므로, 삭제자 타입이 무겁다면 포인터도 커진다.
해결책:
- 무상태(stateless) 삭제자 → `struct Deleter { void operator()(T*) const noexcept; };` (빈 타입은 EBO로 최적화 가능)
- C 함수 포인터 삭제자는 보통 포인터 크기만큼 비용.

```cpp
struct FreeDeleter {
    void operator()(void* p) const noexcept { std::free(p); }
};

using MPtr = std::unique_ptr<void, FreeDeleter>;
```

---

## 7. Rule of Zero / Five & RAII

- **Rule of Zero**: 복사/이동/소멸자를 직접 쓰지 않을 설계(=전부 자동 관리).
  스마트 포인터와 표준 컨테이너를 사용하면 이 이상적 상태에 가까워진다.
- **Rule of Five**: 리소스를 직접 소유하는 타입은
  **소멸자, 복사 생성자, 복사 대입, 이동 생성자, 이동 대입**을 함께 설계.

```cpp
class Socket {
    int fd_ = -1;
public:
    Socket() = default;
    explicit Socket(int fd) : fd_(fd) {}
    ~Socket() { if (fd_ >= 0) ::close(fd_); }

    // 이동만 허용
    Socket(Socket&& other) noexcept : fd_(std::exchange(other.fd_, -1)) {}
    Socket& operator=(Socket&& other) noexcept {
        if (this != &other) {
            if (fd_ >= 0) ::close(fd_);
            fd_ = std::exchange(other.fd_, -1);
        }
        return *this;
    }

    Socket(const Socket&) = delete;
    Socket& operator=(const Socket&) = delete;

    int get() const noexcept { return fd_; }
};
```

---

## 8. 파괴자(소멸자) 예외 정책

- **소멸자는 `noexcept`가 기본**(C++11 이후).
- 소멸자에서 예외를 던지면 **std::terminate**로 이어질 수 있다.
- 실패 상황은 **로그/상태 플래그**로 기록하고 예외는 **전파하지 말 것**.

```cpp
class Safe {
public:
    ~Safe() noexcept {
        try {
            may_throw();
        } catch (...) {
            // log only
        }
    }
};
```

---

## 9. 비동기/코루틴과 RAII

### 9.1 비동기 함수에서 스코프 기반 관리
```cpp
void send_data(Socket& s) {
    // 이 함수 범위 내에서만 필요한 버퍼
    std::unique_ptr<char[]> buf(new char[4096]);
    // ... 예외/조기return에도 자동 해제
}
```

### 9.2 코루틴에서의 RAII
코루틴 프레임 자체가 RAII 대상. `co_await` 중에도 스코프를 적절히 조절:

```cpp
// Pseudocode (의미 전달 목적)
task<void> serve(connection c) {
    // 한 요청 처리 중 살아야 하는 리소스
    Buffer buf(8192);             // await 사이에 유지
    co_await c.read(buf);
    co_await c.write(buf);
} // 코루틴 종료 시 buf 파괴
```

---

## 10. 함수 종료 순서 & 멤버 파괴 순서

- 멤버 파괴 순서는 **선언된 역순**.
- 베이스 → 멤버 → 파생 순서로 **생성**, 파괴는 **역순**.
- 의존성이 있다면 **선언 순서**를 의도적으로 정렬.

```cpp
struct A { ~A(){ /*..*/ } };
struct B { ~B(){ /*..*/ } };

struct X {
    A a;
    B b; // b가 먼저 파괴되고, 그 다음 a 파괴
    ~X() = default;
};
```

---

## 11. RAII와 컨테이너/알고리즘 결합

컨테이너는 요소의 소멸자를 자동 호출한다.
`std::vector<std::unique_ptr<Foo>>`는 스코프 종료 시 모든 `Foo` 자동 파괴.

```cpp
std::vector<std::unique_ptr<File>> files;
files.emplace_back(open_file("a.txt", "w"));
files.emplace_back(open_file("b.txt", "w"));
// ...
// ✅ vector 소멸 시 모두 닫힘
```

---

## 12. RAII vs. GC/Finalizer (다른 언어와의 비교)

- GC 언어의 파이널라이저(finalizer)는 **비결정적 시점**에 실행되어 I/O 리소스 관리에 부적합.
- C++의 RAII는 **결정적 시점(deterministic)** 소멸 보장을 제공 → 파일/락/소켓에 **최적**.

---

## 13. 흔한 함정 & 체크리스트

1. [ ] 소멸자에서 예외 던지기 ❌ → **noexcept** 유지.
2. [ ] `new`/`delete` 직접 사용 ❌ → `unique_ptr/make_unique` 선호.
3. [ ] **shared 소유** 필요 없는데 `shared_ptr` 사용 → **unique_ptr** 우선.
4. [ ] 커스텀 리소스인데 삭제자 설계 누락 → **정확한 Delete 함수를 매핑**.
5. [ ] 다중 락에서 순서 미고려 → `std::scoped_lock` 사용.
6. [ ] 멤버 파괴 순서 의존성 무시 → **선언 순서 재점검**.
7. [ ] 비동기 콜백에서 수명 보장 실패 → **스코프/캡처 전략** 명확화.
8. [ ] PImpl 쓰면서 소멸/이동 규칙 미정의 → **Rule of Five** 반영.

---

## 14. PImpl과 RAII (컴파일 의존성 감소)

```cpp
// Foo.h
#include <memory>
class Foo {
    struct Impl;
    std::unique_ptr<Impl> p_;
public:
    Foo();
    ~Foo();                     // 소멸 구현은 .cpp
    Foo(Foo&&) noexcept;
    Foo& operator=(Foo&&) noexcept;
    Foo(const Foo&) = delete;
    Foo& operator=(const Foo&) = delete;
    void do_work();
};

// Foo.cpp
#include "Foo.h"
#include <vector>

struct Foo::Impl {
    std::vector<int> v; // 무거운 header 포함은 .cpp에
};

Foo::Foo() : p_(std::make_unique<Impl>()) {}
Foo::~Foo() = default;
Foo::Foo(Foo&&) noexcept = default;
Foo& Foo::operator=(Foo&&) noexcept = default;

void Foo::do_work() { p_->v.push_back(42); }
```

- 내부 구현 교체가 쉽고, 빌드 의존성 감소.
- `unique_ptr`가 **자동 파괴**를 보장.

---

## 15. 실전 시나리오: 트랜잭션/락/파일을 한 번에

```cpp
struct Txn {
    bool committed = false;
    ~Txn() noexcept {
        if (!committed) rollback();
    }
    void commit() { committed = true; /* commit to DB */ }
    void rollback() noexcept { /* revert */ }
};

void import_with_all() {
    Txn txn;                        // 트랜잭션 자동 롤백 보장
    std::mutex m; std::unique_lock<std::mutex> lk(m); // 락 RAII
    std::ofstream out("sink.bin", std::ios::binary);   // 파일 RAII

    // ... 작업들 ...
    txn.commit();                   // 명시적 커밋
} // ✅ commit 안되었으면 자동 롤백 + 락 해제 + 파일 close
```

---

## 16. 간단한 성능/안전 팁

- **`reserve()`**: 컨테이너 재할당 최소화 → 소멸자 호출/복사 비용 감소.
- 삭제자는 **`noexcept`**로.
- 지나친 `shared_ptr` 사용은 비용/복잡도 증가 → **소유권을 축소**.
- **소유권 모델 문서화**: “누가 해제 책임을 지는가?” 설계 단계에서 명확히.

---

## 17. 미니 퀴즈
1) 왜 RAII는 예외 안전성의 “기본 보장”을 자동으로 달성할까?
→ **소멸자가 항상 호출**되기 때문(스택 언와인딩).

2) 두 개의 리소스를 잡아야 할 때 강한 보장을 유지하는 패턴은?
→ 각 리소스를 **임시 객체**에 먼저 안전 획득 → 모두 성공 시 **커밋(스왑/이동)**.

3) 파괴자에서 예외가 터지면?
→ 기본적으로 `noexcept` → **terminate** 가능. 예외는 **잡고 삼키라**.

---

## 18. 결론

RAII는 C++의 **철학**이다.
- 생성자에서 **획득**, 소멸자에서 **해제**.
- 예외/조기 반환에도 **누수와 일관성**을 보장.
- 스마트 포인터, 락, 스코프 가드, 커스텀 삭제자, Rule of Zero/Five 등과 결합해 **안전한 시스템**을 만든다.
현대 C++ 코드베이스에서 **RAII 없는 자원 관리**는 **지양**하자.
