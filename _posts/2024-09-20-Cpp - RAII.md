---
layout: post
title: C++ - RAII
date: 2024-09-20 19:20:23 +0900
category: Cpp
---
# RAII: C++ 자원 관리의 철학과 실천

## RAII가 왜 중요한가: 예외 안전성의 기초

C++ 프로그래밍에서 가장 까다로운 문제 중 하나는 예외가 발생하거나 함수가 조기에 반환될 때도 자원을 안전하게 해제하는 것입니다. 전통적인 C 스타일의 자원 관리는 이 문제를 해결하기 어렵게 만듭니다:

```cpp
// C 스타일 - 위험한 자원 관리
void processFile() {
    FILE* file = fopen("data.txt", "r");
    if (!file) {
        return;  // 오류 처리
    }
    
    // ... 작업 수행 중 예외 발생 가능 ...
    
    fclose(file);  // 예외가 발생하면 이 줄에 도달하지 못함!
}
```

RAII(Resource Acquisition Is Initialization)는 이 문제를 근본적으로 해결하는 C++의 핵심 디자인 패턴입니다. 핵심 아이디어는 간단하면서도 강력합니다:

**자원의 수명을 객체의 수명과 동기화하라**

즉, 객체가 생성될 때 자원을 획득하고, 객체가 소멸될 때 자원을 해제합니다. 이렇게 하면 예외가 발생하거나 함수가 조기에 반환되더라도, 객체의 소멸자가 호출되어 자원이 안전하게 해제됩니다.

## RAII의 기본 원리

### 1. 생성자에서 자원 획득

```cpp
class File {
private:
    FILE* file_ptr;
    
public:
    // 생성자: 자원 획득
    File(const char* filename, const char* mode) {
        file_ptr = fopen(filename, mode);
        if (!file_ptr) {
            throw std::runtime_error("파일을 열 수 없습니다");
        }
    }
    
    // 소멸자: 자원 해제
    ~File() {
        if (file_ptr) {
            fclose(file_ptr);
        }
    }
    
    // 파일 작업 메서드들...
    void write(const std::string& data) {
        if (fputs(data.c_str(), file_ptr) == EOF) {
            throw std::runtime_error("파일 쓰기 실패");
        }
    }
};
```

### 2. 안전한 사용

```cpp
void processData() {
    File dataFile("output.txt", "w");  // 생성자에서 파일 열기
    
    // 이 안에서 무슨 일이 일어나도 안전합니다:
    // - 예외가 발생하면?
    // - 조기에 return하면?
    // - 다른 함수 호출이 실패하면?
    
    dataFile.write("Hello, RAII!");
    
    // 함수가 끝나면 dataFile의 소멸자가 자동 호출되어
    // 파일이 안전하게 닫힙니다.
}
```

## RAII와 예외 안전성

RAII는 C++의 예외 안전성 보장을 실현하는 핵심 메커니즘입니다. 예외 안전성은 세 가지 수준으로 구분할 수 있습니다:

### 1. 기본 보장(Basic Guarantee)
- 예외가 발생해도 **자원 누수는 없음**
- 프로그램 상태는 유효하지만 변경될 수 있음

### 2. 강한 보장(Strong Guarantee)
- 예외가 발생하면 **모든 것이 이전 상태로 롤백됨**
- 트랜잭션처럼 동작: 성공하거나 아예 실패

### 3. 예외 없음 보장(No-throw Guarantee)
- 연산이 절대 예외를 던지지 않음

RAII는 **최소한 기본 보장을 자동으로 제공**합니다. 더 나아가, 적절한 설계로 강한 보장도 달성할 수 있습니다:

```cpp
class Transaction {
private:
    std::vector<int> original_state;
    std::vector<int>* target;
    
public:
    Transaction(std::vector<int>& vec) : target(&vec) {
        // 현재 상태 저장 (롤백용)
        original_state = vec;
    }
    
    ~Transaction() {
        // 롤백이 필요한 경우 (예: commit()이 호출되지 않음)
        if (target && target->size() != original_state.size()) {
            *target = original_state;  // 상태 복원
        }
    }
    
    void commit() {
        target = nullptr;  // 커밋 완료: 더 이상 롤백하지 않음
    }
    
    void addValue(int value) {
        if (target) {
            target->push_back(value);
        }
    }
};

void safeOperation() {
    std::vector<int> data = {1, 2, 3};
    
    {
        Transaction txn(data);  // 트랜잭션 시작
        
        txn.addValue(4);
        txn.addValue(5);
        
        // 여기서 예외가 발생하면?
        // Transaction 소멸자가 자동으로 data를 원래 상태로 롤백
        
        txn.commit();  // 성공적으로 완료
    }
    
    // data는 이제 {1, 2, 3, 4, 5} 또는 예외 발생 시 {1, 2, 3}
}
```

## 표준 라이브러리의 RAII 구현체들

C++ 표준 라이브러리는 다양한 RAII 래퍼를 제공합니다:

### 1. 스마트 포인터
```cpp
#include <memory>

// unique_ptr: 단독 소유권
void useUniquePtr() {
    auto ptr = std::make_unique<int>(42);  // 메모리 자동 관리
    // ptr이 소멸될 때 자동으로 delete 호출
}

// shared_ptr: 공유 소유권
void useSharedPtr() {
    auto shared = std::make_shared<std::string>("Hello");
    auto copy = shared;  // 참조 카운트 증가
    // 마지막 shared_ptr이 소멸될 때 메모리 해제
}
```

### 2. 락 관리자 (동기화)
```cpp
#include <mutex>

std::mutex data_mutex;
int shared_data = 0;

void safeIncrement() {
    std::lock_guard<std::mutex> lock(data_mutex);  // 생성 시 락 획득
    ++shared_data;
    // 함수 종료 시 lock 소멸 → 락 자동 해제
}

// 더 유연한 락 관리
void flexibleLocking() {
    std::unique_lock<std::mutex> lock(data_mutex, std::defer_lock);
    
    // 필요할 때 락 획득
    lock.lock();
    // 작업 수행
    lock.unlock();  // 명시적 해제도 가능
    
    // 소멸자에서 아직 락이 걸려 있다면 자동 해제
}
```

### 3. 파일 스트림
```cpp
#include <fstream>

void writeData() {
    std::ofstream file("output.txt");  // 생성자에서 파일 열기
    file << "데이터 기록\n";
    // 소멸자에서 파일 자동 닫기
}
```

## 커스텀 자원의 RAII 구현

표준 라이브러리에 없는 자원도 RAII 패턴으로 래핑할 수 있습니다:

### 1. 데이터베이스 연결
```cpp
class DatabaseConnection {
private:
    sqlite3* db = nullptr;
    
public:
    DatabaseConnection(const std::string& filename) {
        if (sqlite3_open(filename.c_str(), &db) != SQLITE_OK) {
            throw std::runtime_error("데이터베이스 연결 실패");
        }
    }
    
    ~DatabaseConnection() {
        if (db) {
            sqlite3_close(db);
        }
    }
    
    // 복사 방지
    DatabaseConnection(const DatabaseConnection&) = delete;
    DatabaseConnection& operator=(const DatabaseConnection&) = delete;
    
    // 이동 지원
    DatabaseConnection(DatabaseConnection&& other) noexcept 
        : db(std::exchange(other.db, nullptr)) {}
    
    DatabaseConnection& operator=(DatabaseConnection&& other) noexcept {
        if (this != &other) {
            if (db) sqlite3_close(db);
            db = std::exchange(other.db, nullptr);
        }
        return *this;
    }
    
    sqlite3* get() const { return db; }
};
```

### 2. 네트워크 소켓
```cpp
class Socket {
private:
    int socket_fd = -1;
    
public:
    Socket(const std::string& host, int port) {
        socket_fd = socket(AF_INET, SOCK_STREAM, 0);
        if (socket_fd < 0) {
            throw std::runtime_error("소켓 생성 실패");
        }
        
        // 연결 설정...
    }
    
    ~Socket() {
        if (socket_fd >= 0) {
            close(socket_fd);
        }
    }
    
    // 이동 생성자/대입 연산자 구현...
};
```

## RAII와 Rule of Zero/Five

RAII 클래스를 설계할 때는 객체의 수명 주기 규칙을 명확히 해야 합니다:

### Rule of Zero
가능하면 복사/이동 연산과 소멸자를 직접 정의하지 말고, 컴파일러가 생성한 기본 구현을 사용하세요. 이는 클래스가 직접 자원을 소유하지 않을 때 가능합니다.

```cpp
// Rule of Zero의 예: 클래스가 직접 자원을 소유하지 않음
class ConfigManager {
private:
    std::unique_ptr<Config> config;  // 스마트 포인터가 자원 소유
    std::vector<Listener> listeners;  // 표준 컨테이너가 자원 소유
    
public:
    // 복사/이동/소멸자를 명시적으로 정의할 필요 없음
    // 컴파일러가 적절한 기본 구현을 제공
};
```

### Rule of Five
클래스가 직접 자원을 소유한다면, 다음 다섯 가지 멤버 함수를 모두 명시적으로 정의하거나 삭제해야 합니다:
1. 소멸자
2. 복사 생성자
3. 복사 대입 연산자
4. 이동 생성자
5. 이동 대입 연산자

```cpp
class ManagedArray {
private:
    int* data;
    size_t size;
    
public:
    // 생성자
    ManagedArray(size_t n) : size(n), data(new int[n]) {}
    
    // 1. 소멸자
    ~ManagedArray() { delete[] data; }
    
    // 2. 복사 생성자 (깊은 복사)
    ManagedArray(const ManagedArray& other) 
        : size(other.size), data(new int[other.size]) {
        std::copy(other.data, other.data + size, data);
    }
    
    // 3. 복사 대입 연산자
    ManagedArray& operator=(const ManagedArray& other) {
        if (this != &other) {
            delete[] data;
            size = other.size;
            data = new int[size];
            std::copy(other.data, other.data + size, data);
        }
        return *this;
    }
    
    // 4. 이동 생성자
    ManagedArray(ManagedArray&& other) noexcept 
        : data(std::exchange(other.data, nullptr)), 
          size(std::exchange(other.size, 0)) {}
    
    // 5. 이동 대입 연산자
    ManagedArray& operator=(ManagedArray&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = std::exchange(other.data, nullptr);
            size = std::exchange(other.size, 0);
        }
        return *this;
    }
};
```

## 고급 RAII 패턴

### 1. 스코프 가드 (Scope Guard)
특정 스코프를 벗어날 때 특정 작업을 수행하는 일반적인 패턴:

```cpp
class ScopeGuard {
private:
    std::function<void()> cleanup;
    
public:
    template<typename Func>
    ScopeGuard(Func&& f) : cleanup(std::forward<Func>(f)) {}
    
    ~ScopeGuard() {
        if (cleanup) {
            cleanup();
        }
    }
    
    // 이동 생성자 등 구현...
    
    void dismiss() {
        cleanup = nullptr;  // 정리 작업 취소
    }
};

void processWithCleanup() {
    FILE* file = fopen("temp.txt", "w");
    ScopeGuard guard([&]() {
        if (file) fclose(file);
        std::remove("temp.txt");  // 임시 파일 삭제
    });
    
    // 파일 작업...
    
    if (success) {
        guard.dismiss();  // 성공했으므로 정리 작업 취소
    }
    // 실패하면 guard가 자동으로 파일 닫고 삭제
}
```

### 2. PImpl (Pointer to Implementation) 관용구
컴파일 의존성을 줄이면서 RAII의 이점을 유지:

```cpp
// Widget.h
#include <memory>

class Widget {
public:
    Widget();
    ~Widget();
    
    // 복사/이동 연산자들...
    
    void doSomething();
    
private:
    class Impl;
    std::unique_ptr<Impl> pImpl;  // RAII로 구현 세부사항 관리
};

// Widget.cpp
#include "Widget.h"
#include <vector>
#include <string>

class Widget::Impl {
public:
    std::vector<std::string> data;
    // 복잡한 구현 세부사항...
};

Widget::Widget() : pImpl(std::make_unique<Impl>()) {}
Widget::~Widget() = default;  // unique_ptr이 자동 정리

void Widget::doSomething() {
    pImpl->data.push_back("작업 수행");
}
```

## RAII의 실전 적용: 트랜잭션 처리 시스템

```cpp
#include <memory>
#include <vector>
#include <functional>
#include <stdexcept>

class Transaction {
private:
    std::vector<std::function<void()>> rollback_actions;
    bool committed = false;
    
public:
    ~Transaction() {
        if (!committed) {
            // 역순으로 롤백 실행
            for (auto it = rollback_actions.rbegin(); 
                 it != rollback_actions.rend(); ++it) {
                try {
                    (*it)();
                } catch (...) {
                    // 롤백 중 예외는 로그만 기록
                }
            }
        }
    }
    
    template<typename Action, typename Rollback>
    void perform(Action&& action, Rollback&& rollback) {
        // 원래 상태 저장
        rollback_actions.push_back(std::forward<Rollback>(rollback));
        
        // 작업 수행
        std::forward<Action>(action)();
    }
    
    void commit() {
        committed = true;
        rollback_actions.clear();  // 롤백 불필요
    }
};

// 사용 예제
class BankAccount {
private:
    int balance = 1000;
    
public:
    void withdraw(int amount) {
        if (amount > balance) {
            throw std::runtime_error("잔액 부족");
        }
        balance -= amount;
    }
    
    void deposit(int amount) {
        balance += amount;
    }
    
    int getBalance() const { return balance; }
};

void transferMoney(BankAccount& from, BankAccount& to, int amount) {
    Transaction txn;
    
    int from_original = from.getBalance();
    int to_original = to.getBalance();
    
    txn.perform(
        [&]() { from.withdraw(amount); },  // 작업
        [&, from_original]() { 
            // 롤백: 원래 상태로 복원
            from.deposit(amount); 
        }
    );
    
    txn.perform(
        [&]() { to.deposit(amount); },     // 작업
        [&, to_original]() { 
            // 롤백: 원래 상태로 복원
            to.withdraw(amount); 
        }
    );
    
    txn.commit();  // 모든 작업 성공
}
```

## RAII의 한계와 주의사항

### 1. 소멸자에서 예외를 던지지 마세요
```cpp
class SafeResource {
public:
    ~SafeResource() noexcept {  // noexcept 지정
        try {
            cleanup();
        } catch (...) {
            // 로그 기록만 하고 예외 전파 금지
            logError("정리 중 오류 발생");
        }
    }
    
private:
    void cleanup() {
        // 정리 작업 (예외 발생 가능)
    }
};
```

### 2. 순환 참조 주의
```cpp
// 문제: 순환 참조
class Node {
    std::shared_ptr<Node> next;  // 순환 가능
public:
    ~Node() { std::cout << "Node 소멸\n"; }
};

// 해결: weak_ptr 사용
class SafeNode {
    std::weak_ptr<SafeNode> parent;  // 약한 참조
    std::shared_ptr<SafeNode> child;
public:
    ~SafeNode() { std::cout << "SafeNode 소멸\n"; }
};
```

### 3. 성능 고려사항
RAII는 일반적으로 오버헤드가 작지만, 특정 상황에서는 고려가 필요합니다:
- 매우 빈번한 할당/해제가 필요한 경우
- 실시간 시스템에서 결정적 동작이 요구되는 경우
- 매우 작은 객체를 다수 관리할 때

## RAII vs 다른 언어의 자원 관리

### 가비지 컬렉션(GC) 언어와의 비교
```java
// Java: finalize() 메서드 (비결정적 정리)
class FileResource {
    private FileHandle handle;
    
    protected void finalize() throws Throwable {
        if (handle != null) {
            handle.close();  // 언제 호출될지 알 수 없음
        }
        super.finalize();
    }
}
```

### Python의 with 문과의 비교
```python
# Python: context manager (결정적 정리)
with open('file.txt', 'w') as f:
    f.write('Hello')
# 블록을 벗어나면 파일 자동 닫힘
```

C++의 RAII는 Python의 context manager와 유사하게 **결정적 자원 정리**를 제공하지만, 언어 수준에서 통합되어 모든 객체에 자동으로 적용된다는 점에서 더 강력합니다.

## 결론: 현대 C++ 프로그래밍에서 RAII의 위치

RAII는 단순한 기술적 패턴을 넘어 C++ 프로그래밍 철학의 핵심입니다. 이 패턴을 완전히 이해하고 적용하면:

1. **메모리 안전성 향상**: 메모리 누수, 이중 해제, 댕글링 포인터 문제를 근본적으로 해결합니다.

2. **예외 안전성 보장**: 예외가 발생해도 자원이 안전하게 정리되도록 보장합니다.

3. **코드 간소화**: 명시적인 정리 코드를 줄이고, 자원 수명 관리를 컴파일러에 위임합니다.

4. **리소스 관리 일관성**: 파일, 메모리, 락, 네트워크 연결 등 모든 유형의 자원을 일관된 패턴으로 관리합니다.

5. **설계 의도 명확화**: 소유권과 수명 주기를 타입 시스템을 통해 명시적으로 표현합니다.

RAII는 C++이 제공하는 가장 강력한 도구 중 하나입니다. 초기 학습 곡선이 있지만, 일단 익숙해지면 더 안전하고 간결하며 유지보수하기 쉬운 코드를 작성할 수 있습니다. 현대 C++ 프로그래밍에서 RAII는 선택이 아니라 필수입니다. 모든 자원 관리 코드를 RAII 원칙에 따라 설계하고, 표준 라이브러리의 RAII 래퍼를 적극 활용하며, 커스텀 자원에 대해서도 일관된 RAII 패턴을 적용하세요.