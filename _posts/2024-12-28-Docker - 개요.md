---
layout: post
title: Docker - 개요
date: 2024-12-28 19:20:23 +0900
category: Docker
---
# Docker란? 왜 쓰는가?

## Docker란?

Docker는 **컨테이너 기술**을 활용해 애플리케이션을 **이미지로 패키징하고 컨테이너로 실행**하는 오픈소스 플랫폼입니다. 애플리케이션 코드, 런타임, 시스템 도구, 라이브러리 등을 하나의 **불변하는 이미지**로 묶어, 어떤 환경에서도 **동일하게 실행**할 수 있도록 합니다.

### 핵심 구성 요소

- **이미지(Image)**: 애플리케이션 실행에 필요한 모든 것을 포함하는 불변의 템플릿. 여러 읽기 전용 레이어가 겹쳐진 구조이며, 내용 기반 해시로 고유하게 관리됩니다.
- **컨테이너(Container)**: 이미지를 실행한 격리된 프로세스 환경입니다. 이미지 레이어 위에 쓰기 가능한 얇은 레이어를 추가하여 생성됩니다.
- **레지스트리(Registry)**: Docker 이미지를 저장하고 배포하는 서비스입니다. Docker Hub, GitHub Container Registry(GHCR), 사설 레지스트리 등이 있습니다.
- **Docker Engine**: 이미지와 컨테이너의 생명주기를 관리하는 핵심 데몬입니다.

---

## 왜 Docker를 사용할까?

### 환경 일관성

개발자의 로컬 머신, 테스트 서버, 운영 환경까지 모두 **동일한 Docker 이미지**를 사용함으로써 "내 컴퓨터에서는 되는데요"라는 문제를 근본적으로 줄입니다.

### 빠른 배포와 확장

컨테이너는 가상머신에 비해 훨씬 가볍고 빠르게 시작(초 단위) 및 종료됩니다. 새로운 버전 배포나 문제 발생 시 이전 버전으로의 롤백도 이미지 태그만 변경하면 매우 빠르게 수행할 수 있습니다.

### 높은 효율성과 이식성

하나의 호스트 머신에 수십, 수백 개의 컨테이너를 실행할 수 있어 자원 활용도가 뛰어납니다. 또한, 빌드된 이미지는 어떠한 Docker 호스트 환경(리눅스, 윈도우, macOS, 클라우드, 온프레미스)에서도 동일하게 실행될 수 있는 높은 이식성을 제공합니다.

---

## Docker vs VM (가상머신과의 차이)

Docker 컨테이너와 전통적인 가상머신(VM)의 근본적인 차이는 **격리 수준**에 있습니다.

| 항목 | Docker (컨테이너) | VM (가상머신) |
|---|---|---|
| **격리 방식** | **OS 수준 격리** (호스트 OS 커널 공유) | **하드웨어 수준 격리** (하이퍼바이저를 통한 가상화) |
| **시작 속도** | 매우 빠름 (초 단위) | 비교적 느림 (분 단위) |
| **성능 오버헤드** | 매우 낮음 | 비교적 높음 (전체 게스트 OS 실행) |
| **이미지 크기** | 일반적으로 작음 (MB 단위) | 일반적으로 큼 (GB 단위) |
| **보안 격리 강도** | 프로세스 수준 격리 (상대적으로 약함) | 완전한 하드웨어 격리 (매우 강함) |

**간략한 구조 비교:**
```
[ VM 구조 ]
하드웨어 -> 하이퍼바이저 -> 게스트 OS 전체 -> 애플리케이션

[ Docker 구조 ]
하드웨어 -> 호스트 OS -> Docker Engine -> 컨테이너(애플리케이션)
```

---

## Docker의 장점과 단점

### 장점
1.  **일관된 환경:** 개발부터 운영까지 동일한 환경 보장.
2.  **빠른 시작/중지:** 컨테이너 생명주기가 매우 빠릅니다.
3.  **자원 효율성:** VM에 비해 훨씬 적은 자원으로 더 많은 서비스를 실행할 수 있습니다.
4.  **쉬운 배포와 관리:** 이미지를 통해 애플리케이션과 의존성을 함께 배포하고, 버전 관리가 용이합니다.
5.  **확장성:** 마이크로서비스 아키텍처와 클라우드 네이티브 환경에 최적화되어 있습니다.

### 단점 및 고려사항
1.  **보안:** 컨테이너는 호스트의 커널을 공유하기 때문에, 커널 취약점 공격 시 모든 컨테이너가 위협받을 수 있습니다. 적절한 보안 설정(최소 권한 원칙 적용 등)이 필수입니다.
2.  **OS 제한:** Windows 또는 macOS에서는 리눅스 컨테이너를 실행하기 위해 내부적으로 경량 VM을 사용해야 하므로, 순수 리눅스 환경 대비 성능 오버헤드가 발생할 수 있습니다.
3.  **복잡성 증가:** 특히 네트워킹, 저장소 구성이 단일 애플리케이션 실행보다 복잡해질 수 있습니다.
4.  **GUI 애플리케이션:** 데스크탑 GUI 애플리케이션 실행에는 별도의 설정이 필요하며, VM이 더 적합할 수 있습니다.

---

## 내부 동작 원리 이해하기

### 이미지와 레이어
Docker 이미지는 여러 개의 **읽기 전용 레이어**가 쌓여 구성됩니다. Dockerfile의 각 명령어(예: `COPY`, `RUN`)는 새로운 레이어를 생성합니다. 이 레이어 방식은 변경된 부분만 다운로드하고, 여러 이미지 간 공통 레이어를 재사용하여 디스크 공간과 네트워크 대역폭을 절약합니다.

### 컨테이너 실행
컨테이너를 실행하면 해당 이미지의 레이어들 위에 새로운 **쓰기 가능 레이어**가 추가됩니다. 컨테이너 내에서 발생하는 모든 파일 변경사항은 이 레이어에 기록됩니다. 컨테이너가 삭제되면 이 레이어도 함께 사라집니다. 영구적으로 데이터를 저장하려면 `볼륨(Volume)`이나 `바인드 마운트(Bind Mount)`를 사용해야 합니다.

### 격리 기술
컨테이너의 격리는 리눅스 커널의 두 가지 핵심 기술로 구현됩니다.
- **네임스페이스(Namespaces):** 프로세스, 네트워크, 파일시스템 마운트점 등을 격리합니다.
- **cgroups (Control Groups):** CPU, 메모리, 디스크 I/O 등의 자원 사용량을 제한하고 격리합니다.

---

## 실전 예제로 이해하기

### 1. 환경 일관성: 로컬 개발 환경 구성
`docker-compose.yml` 파일 하나로 웹 서버, API 서버, 데이터베이스를 포함한 전체 애플리케이션 스택을 로컬에서 동일하게 띄울 수 있습니다. 이 파일을 버전 관리하면 모든 팀원이 똑같은 환경을 손쉽게 가질 수 있습니다.

```yaml
# docker-compose.yml 예시
services:
  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: example
  api:
    build: ./api
    ports:
      - "8080:8080"
    depends_on:
      - db
```

### 2. 빠른 배포와 롤백
운영 서버에 새 버전을 배포할 때, 단순히 새 이미지 태그로 컨테이너를 교체하기만 하면 됩니다. 문제가 생기면 이전 버전의 이미지 태그로 다시 실행함으로써 즉시 롤백할 수 있습니다.

```bash
# 새 버전(v2) 배포
docker run -d -p 80:80 myapp:2.0

# 문제 발생 시 즉시 이전 버전(v1)으로 롤백
docker stop <container_id>
docker run -d -p 80:80 myapp:1.0
```

### 3. 가벼운 확장
단일 서버에서도 여러 개의 동일한 애플리케이션 인스턴스를 쉽게 띄워 부하 분산을 테스트할 수 있습니다.

```bash
# 같은 앱의 인스턴스를 3개 실행
docker run -d --name app1 myapp:1.0
docker run -d --name app2 myapp:1.0
docker run -d --name app3 myapp:1.0
```

---

## 결론

Docker는 현대 소프트웨어 개발과 운영에 있어 **환경 불일치 문제를 해결**하고, **배포 속도와 효율성을 극적으로 향상**시킨 혁신적인 도구입니다. 애플리케이션을 표준화된 컨테이너 단위로 패키징함으로써 개발, 테스트, 배포의 전체 라이프사이클을 간소화합니다.

가상머신과 비교했을 때 자원 효율성과 속도 면에서 큰 강점을 보이지만, 보안 격리 강도와 호스트 OS 의존성이라는 단점도 함께 고려해야 합니다. 이러한 특성을 이해하고, Docker를 적재적소에 활용한다면 더욱 견고하고 민첩한 소프트웨어 제공 파이프라인을 구축하는 데 결정적인 도움이 될 것입니다.

요컨대, Docker는 개발과 운영의 간극을 줄이고, 클라우드 네이티브 시대에 필수적인 **애플리케이션 패키징 및 실행의 표준**으로 자리 잡았습니다.