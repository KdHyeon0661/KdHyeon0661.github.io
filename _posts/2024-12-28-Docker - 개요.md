---
layout: post
title: Docker - 개요
date: 2024-12-28 19:20:23 +0900
category: Docker
---
# Docker란? 왜 쓰는가?

## 1) Docker란?

Docker는 **컨테이너 기술**을 사용해 애플리케이션을 **패키징(이미지)하고 실행(컨테이너)** 하는 오픈소스 플랫폼입니다. 애플리케이션, 런타임, 시스템 툴, 라이브러리 등을 하나의 **불변 이미지**로 묶어 **어디서나 동일하게** 실행합니다.

### 핵심 구성요소(기존 내용 확장)
- **이미지(Image)**: 불변 템플릿. **레이어(layer)**들의 스택이며, 내용 해시(sha256) 기반의 **Content-Addressable Storage**로 관리됩니다.
- **컨테이너(Container)**: 이미지를 실행한 **격리된 프로세스 환경**. 쓰기 가능한 얇은 레이어가 최상단에 추가됩니다.
- **레지스트리(Registry)**: 이미지를 저장/배포하는 저장소(Docker Hub, GHCR, Harbor 등). **tag**(가변)와 **digest**(불변)로 참조합니다.
- **Docker Engine(=dockerd + containerd + runc)**: 이미지 빌드/pull/push, 네트워크/볼륨 관리, 컨테이너 생성/실행을 담당합니다.

---

## 2) 왜 Docker인가? (장점)

### 2.1 환경 일치(Environment Parity)
개발/테스트/운영에서 **동일 이미지**를 사용하므로 “내 PC에선 되는데…”를 줄입니다.

```bash
# 로컬과 CI/CD, 운영에서 같은 이미지를 사용
docker build -t ghcr.io/acme/app:1.0 .
docker run --rm -p 8080:8080 ghcr.io/acme/app:1.0
```

### 2.2 빠른 배포와 롤백
컨테이너는 **초 단위**로 뜨고 내려갑니다. 이미지 태그/다이제스트 교체만으로 롤백이 단순합니다.

```bash
# 롤백은 이전 태그/다이제스트로 재배포
docker run -d --name web -p 8080:80 ghcr.io/acme/web@sha256:...  # digest 고정
```

### 2.3 가벼움과 효율성
VM보다 **자원 오버헤드가 작고**, 밀도가 높습니다(수십~수백 컨테이너/노드도 가능).

### 2.4 이식성·확장성
동일 이미지가 **온프레미스/클라우드/Kubernetes** 등 어디서나 실행됩니다.

---

## 3) Docker vs VM (가상머신과의 차이)

| 항목 | Docker(컨테이너) | VM(가상머신) |
|---|---|---|
| 가상화 계층 | **OS 수준 격리**(커널 공유) | **하드웨어 가상화**(하이퍼바이저) |
| 부팅/시작 속도 | 초 단위 | 분 단위 |
| 자원 사용 | 적음(게스트 OS 없음) | 큼(게스트 OS 포함) |
| 실행 단위 | 프로세스 | 전체 OS |
| 이식성 | 높음(이미지) | 낮음(디스크 이미지/드라이버) |
| 이미지 크기 | 수~수백 MB | 수 GB 이상 |
| 보안 격리 | 상대적으로 약함(커널 공유) | 강함(독립 커널) |

### 텍스트 다이어그램(요약)

```
[ VM ]
HW ─ Hypervisor ─ GuestOS ─ App

[ Docker ]
HW ─ Host OS ─ Docker Engine ─ Container(App)
```

---

## 4) Docker의 단점(운영 관점까지 보강)

### 4.1 커널 공유로 인한 보안 리스크
컨테이너는 호스트 커널을 공유하므로 **커널 취약점** 악용 시 영향 범위가 큽니다.  
대응: **최소 권한 실행**(capabilities 제거, read-only rootfs), **Rootless/유저 네임스페이스**, **신뢰 이미지** 사용, **정기 패치**.

```bash
docker run --rm \
  --read-only --pids-limit=256 --cpus=0.5 --memory=256m \
  --cap-drop ALL --security-opt no-new-privileges \
  nginx:alpine
```

### 4.2 GUI/전체 OS 필요 시 부적절
데스크탑 GUI나 다중 OS 테스트(드라이버/커널)는 VM이 적합합니다.

### 4.3 자원 격리 강도
cgroups 기반 자원 제한은 강력하지만, **완전한 하드웨어 격리**는 VM이 앞섭니다.

### 4.4 네트워킹 복잡성
브릿지/NAT/포워딩, DNS, 포트 충돌 등으로 **초기 난이도**가 있습니다.

### 4.5 Windows/macOS 제약
리눅스 커널 기반이므로, Windows/macOS는 **내부적으로 VM을 사용**(Hyper-V/WSL2, HyperKit 등). 파일 I/O/네트워킹에서 성능 차가 날 수 있습니다.

---

## 5) Docker Engine vs 하이퍼바이저(개념 정리 보강)

### 5.1 하이퍼바이저
- **Type 1(베어메탈)**: ESXi, Hyper-V, KVM  
- **Type 2(호스트형)**: VirtualBox, VMware Workstation

### 5.2 Docker Engine
- Host OS 위에서 컨테이너 격리를 구성(네임스페이스: pid/net/uts/ipc/mnt/user, cgroups: CPU/메모리/IO).  
- 도커 API(REST)를 통해 **이미지/컨테이너/네트워크/볼륨**을 관리.

---

## 6) 내부 동작 원리(한눈에)

### 6.1 이미지 = 레이어 스택(불변)
- Dockerfile의 각 지시문이 **레이어**를 생성.  
- 내용 해시(CAS)로 **중복 제거** 및 **캐시 재사용**.

```Dockerfile
FROM python:3.12-alpine
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt   # 의존성 캐시 포인트
COPY . .
CMD ["python", "app.py"]
```

```bash
docker build -t demo:1 .
docker history demo:1
```

### 6.2 컨테이너 = 이미지 + 쓰기 레이어 + 격리
- **OverlayFS**로 lowerdir(읽기) + upperdir(쓰기) → merged.
- **네임스페이스**로 프로세스/네트워크/마운트 격리, **cgroups**로 자원 제한.

### 6.3 네트워킹(기초)
- 기본 `bridge`(단일 호스트), 사용자 정의 브릿지로 **컨테이너명 DNS** 제공.
- 포트 매핑 `-p 호스트:컨테이너`.

```bash
docker network create appnet
docker run -d --name web --network appnet -p 8080:80 nginx:alpine
docker run --rm --network appnet curlimages/curl http://web
```

---

## 7) 실전: “왜 쓰는가”를 보여주는 3가지 짧은 예제

### 7.1 환경 일치(로컬=운영)
```Dockerfile
# ./api/Dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json .
RUN npm ci
COPY . .
EXPOSE 8080
CMD ["npm","start"]
```

```yaml
# docker-compose.yaml
services:
  api:
    build: ./api
    ports: ["8080:8080"]
```

```bash
# 로컬
docker compose up -d --build

# 운영(예: 서버)
docker pull ghcr.io/acme/api:1.0
docker run -d -p 8080:8080 ghcr.io/acme/api:1.0
```

### 7.2 빠른 롤백(태그/다이제스트 전환)
```bash
# 새 버전 배포
docker run -d --name web -p 80:80 ghcr.io/acme/web:2.0
# 문제 발생 → 즉시 이전 버전
docker rm -f web
docker run -d --name web -p 80:80 ghcr.io/acme/web:1.9
```

### 7.3 가벼운 확장(프로세스 단위 스케일)
```bash
# 단일 호스트에서 Nginx 3개 띄워 부하 분산 연습(예시)
docker network create lbnet
docker run -d --name web1 --network lbnet nginx:alpine
docker run -d --name web2 --network lbnet nginx:alpine
docker run -d --name web3 --network lbnet nginx:alpine
# 간단한 라운드로빈용 HAProxy/Traefik 등을 같은 네트워크에 두면 LB 실습 가능
```

---

## 8) 성능·보안·운영 베스트 프랙티스(요약)

### 8.1 성능
- 프로젝트 디렉터리는 **(WSL2라면) WSL 내부 FS**에서 빌드/마운트.
- `.dockerignore`로 빌드 컨텍스트 최소화.
- 멀티스테이지/BuildKit 캐시 활용.

```Dockerfile
# syntax=docker/dockerfile:1.7
FROM golang:1.22-alpine AS build
WORKDIR /src
COPY go.mod go.sum ./
RUN --mount=type=cache,target=/go/pkg/mod go mod download
COPY . .
RUN --mount=type=cache,target=/root/.cache/go-build \
    go build -o /out/app ./cmd/app

FROM alpine
COPY --from=build /out/app /app
CMD ["/app"]
```

### 8.2 보안
- 신뢰 레지스트리/이미지 사용, **취약점 스캔**(trivy), **서명/검증**(cosign).
- 실행 시 **권한 최소화**(`--cap-drop ALL`, `--read-only`, `--user`).
- 비밀은 환경변수 대신 **시크릿/외부 비밀 저장소** 사용.

```bash
trivy image ghcr.io/acme/api:1.0
docker run --rm --read-only --cap-drop ALL --user 65532:65532 ghcr.io/acme/api:1.0
```

### 8.3 운영
- 프록시/사설 CA 환경에 맞게 **데몬 프록시/인증서** 설정.
- 로그/메트릭 수집, 이벤트 기반 자동화(`docker events`).
- 디스크 압박 시 레이어/이미지 정리 전략 수립.

---

## 9) Windows·macOS에서의 고려사항(요약)

- 내부적으로 VM(WSL2/Hyper-V/HyperKit)을 사용 → **파일 I/O**는 호스트-게스트 경계에서 느려질 수 있음.  
  해결: **WSL2 내부 경로**에서 빌드/마운트.
- 포트 충돌/방화벽, 회사 네트워크 프록시/사설 CA 문제에 주의.

```powershell
# 포트 충돌 진단(Windows)
netstat -ano | findstr :8080
```

---

## 10) 트러블슈팅 빠른 표

| 증상 | 진단/해결 |
|---|---|
| `permission denied` on docker.sock | 리눅스: `sudo usermod -aG docker $USER` 후 재로그인 |
| `pull` 실패(프록시/사설 CA) | 데몬 프록시/CA 설정, 컨테이너 내부 프록시 환경변수 구분 설정 |
| 포트 바인딩 실패 | 점유 프로세스 확인 후 변경 또는 종료 |
| 파일 변경 반영 지연(Windows) | 코드/마운트를 WSL2 내부 FS로 이동 |
| 디스크 부족 | `docker system df`, `docker system prune -af`(주의) |

---

## 11) 간단한 수학 메모: 캐시 최적화 직관(선택)
레이어별 캐시 적중률을 \(p_i\), 빌드 비용을 \(c_i\) 라고 하면 기대 빌드 시간은 대략
$$
\mathbb{E}[T] \approx \sum_{i=1}^{n} (1-p_i)\,c_i
$$
입니다. **변화가 적은 레이어**(의존성 설치)를 앞쪽에 배치하여 \(p_i\) 를 키우면 전체 빌드 시간이 줄어듭니다.

---

## 12) 통합 실습: “왜 쓰는가”를 체감하는 미니 프로젝트

### 12.1 디렉터리 구조
```
stack/
  web/
    site/index.html
  api/
    app.py
    requirements.txt
    Dockerfile
  docker-compose.yaml
```

### 12.2 파일들

```html
<!-- web/site/index.html -->
<!doctype html>
<html>
  <head><meta charset="utf-8"><title>Docker Demo</title></head>
  <body><h1>OK</h1><p>Static served by nginx.</p></body>
</html>
```

```python
# api/app.py
from flask import Flask, jsonify
app = Flask(__name__)

@app.get("/health")
def health():
    return jsonify(ok=True)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8080)
```

```
# api/requirements.txt
flask==3.0.3
```

```Dockerfile
# api/Dockerfile
FROM python:3.12-alpine
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY app.py .
EXPOSE 8080
CMD ["python","app.py"]
```

```yaml
# docker-compose.yaml
services:
  web:
    image: nginx:alpine
    volumes: ["./web/site:/usr/share/nginx/html:ro"]
    ports: ["8080:80"]
    depends_on: ["api"]

  api:
    build: ./api
    ports: ["8081:8080"]

# 상태 보존(선택): db 추가 가능
```

### 12.3 실행
```bash
docker compose up -d --build
curl http://localhost:8080        # 정적 페이지
curl http://localhost:8081/health # API
docker compose down -v
```

**결과:** 단일 PC에서도 **로컬=운영과 유사한 환경**을 손쉽게 구성, **빠르게 배포/롤백**할 수 있음을 체감합니다.

---

## 13) 요약

- Docker는 **이미지(불변) → 컨테이너(격리 프로세스)** 모델로, **환경 일치·빠른 배포·고밀도·이식성**을 제공합니다.
- 반면 **커널 공유** 특성으로 **보안 격리 강도**는 VM보다 낮고, Windows/macOS에서는 내부 VM 의존으로 **성능/복잡성** 이슈가 있을 수 있습니다.
- 둘은 대체재가 아니라 **보완재**입니다. 실제로 **VM 위에 Docker**를 올리거나, **클라우드 VM+컨테이너 오케스트레이션(Kubernetes)** 조합이 일반적입니다.
- 본문 예제(Dockerfile/Compose/보안·성능 팁/트러블슈팅)를 통해 “왜 Docker인가”를 **실무적으로** 이해하고 재현할 수 있습니다.

---

## 부록 A) 명령 치트시트

```bash
# 상태/정보
docker version
docker info
docker system df

# 이미지
docker build -t app:1 .
docker images
docker history app:1
docker rmi app:1

# 컨테이너
docker run -d --name web -p 8080:80 nginx:alpine
docker logs -f web
docker exec -it web sh
docker rm -f web

# 네트워크/볼륨
docker network create n1
docker volume create v1
docker network ls
docker volume ls

# 정리(주의)
docker system prune -af
```

## 부록 B) 보안 실행 스니펫

```bash
docker run --rm \
  --read-only --tmpfs /tmp --tmpfs /run \
  --cap-drop ALL --security-opt no-new-privileges \
  --pids-limit 128 --cpus 0.5 --memory 256m \
  --user 65532:65532 \
  ghcr.io/acme/app:1.0
```

## 부록 C) 프록시/사설 CA(리눅스 데몬 설정 예)

```bash
sudo mkdir -p /etc/systemd/system/docker.service.d
cat <<'EOF' | sudo tee /etc/systemd/system/docker.service.d/proxy.conf
[Service]
Environment="HTTP_PROXY=http://proxy.local:3128"
Environment="HTTPS_PROXY=http://proxy.local:3128"
Environment="NO_PROXY=localhost,127.0.0.1,.svc,.internal"
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```