---
layout: post
title: Elixir - 제어 구문 (1)
date: 2025-11-17 22:25:23 +0900
category: Elixir
---
# 12장. Elixir 제어 흐름 — if/unless, cond, case 완전 정리

> 목표
> - 엘릭서의 **if / unless / cond / case** 를 “문법”이 아니라 **표현식과 데이터 흐름** 관점에서 이해한다.
> - `truthiness`, 가드, 패턴 매칭, 태그드 튜플, 바이너리 매칭 등을 **실전 예제**와 함께 연결한다.
> - 기존에 정리한 내용을 **그대로 살리되**, 각 절마다 **실무 패턴·함정·리팩토링 기준**을 보강한다.
> - 제어 구문을 “제어문”이 아니라 “값을 계산하는 식”으로 쓰는 감각을 만든다.

---

## _12.1 if와 unless_

### 기본 형태와 truthiness

기본 형태:

```elixir
if condition do
  expr1
else
  expr2
end
```

핵심 규칙:

- **오직** `false` 와 `nil` 만 거짓으로 평가된다.
  - `0`, `""`, `[]`, `%{}`, `:error`, `:ok`, `:false` 등은 모두 **truthy**.
- `if` 는 **식(expression)** 이다.
  - `if` 블록 전체의 값은 **실행된 분기에서 마지막 표현식의 값**.

```elixir
iex> if 0 do :ok else :no end
:ok

iex> if "" do "non-empty? no, but truthy" else "never" end
"non-empty? no, but truthy"

iex> x = if true, do: 1, else: 2
iex> x
1
```

수식으로 쓰면:

$$
\text{truthy}(x) \iff x \notin \{\text{false}, \text{nil}\}.
$$

즉, **“존재함”과 “성공”**은 대부분 “truthy”로 취급하고,
**“없음(nil)”과 “명시적인 거짓(false)”**만 거짓으로 취급하는 모델이다.

#### truthiness 패턴 — 값 자체를 반환하는 if

`if` 가 표현식이라는 점을 활용하면:

```elixir
msg =
  if debug? do
    "[DEBUG] " <> inspect(payload)
  else
    inspect(payload)
  end
```

처럼 **중간 값에 조건부로 태그/가공을 추가**하는 식이 자연스럽다.

숫자/문자열도 마찬가지:

```elixir
result =
  if error_message do
    {:error, error_message}
  else
    {:ok, data}
  end
```

여기서 `error_message` 가 `nil` 이면 false로 취급되어 `{:ok, data}` 절이 실행된다.

---

### `unless` — 조건의 부정

`unless` 는 “if not”를 뒤집어서 쓴 형태:

```elixir
unless File.exists?("out.txt") do
  File.write!("out.txt", "init\n")
end
```

- `unless cond do ... end` 는 **조건이 거짓일 때** 블록을 실행한다.
- `unless cond, do: ..., else: ...` 형태도 가능하다.

```elixir
unless connected? do
  raise "not connected"
end

unless valid?, do: {:error, :invalid}, else: {:ok, :valid}
```

#### 이중 부정 피하기

아래처럼 쓰면 가독성이 크게 떨어진다.

```elixir
# 비추천

unless not ready? do
  do_work()
end
```

이 경우에는 차라리:

```elixir
if ready? do
  do_work()
end
```

또는:

```elixir
ready? && do_work()
```

가 훨씬 읽기 좋다.

규칙:

- **unless 안에는 가급적 부정(`not`)을 다시 쓰지 말자**.
- “~하지 않으면”이 문맥상 더 자연스러울 때만 `unless` 를 쓰는 편이 좋다.

---

### 한 줄 문법과 키워드

짧은 조건식은 키워드 스타일로 자주 쓴다.

```elixir
if ok?, do: :go, else: :stop
unless ok?, do: :stop, else: :go
```

중괄호 없이도 **키워드 인자**를 이용해 간결하게 쓸 수 있다.

실전 예:

```elixir
user =
  if allow_guest? do
    current_user || %Guest{}
  else
    current_user
  end
```

블록이 길어지면 즉시 `do ... end`로 바꾸는 것이 좋다.

```elixir
# 비추천: 한 줄 문법에 너무 많은 로직

if ok?, do: do_something_complex(a, b, c), else: do_other_thing(x, y, z)

# 추천: 블록으로 전환

if ok? do
  do_something_complex(a, b, c)
else
  do_other_thing(x, y, z)
end
```

---

### if/else 대신 **연산자**로 표현 가능한 경우

간단한 선택은 **불리언 연산자**로 충분한 경우가 많다.

- `a || b` :
  - `a`가 truthy면 `a` 반환, 아니면 `b`
- `a && b` :
  - `a`가 truthy면 `b` 반환, 아니면 `a`

```elixir
name = input_name || "anonymous"
token = valid? && compute_token(payload)
```

여기서 주의할 점:

- `&&` / `||` 는 **단축 평가(short-circuit)** 를 한다.
  - `a && b` 에서 `a`가 false/nil이면 `b`는 평가되지 않는다.
  - `a || b` 에서 `a`가 truthy면 `b`는 평가되지 않는다.
- 반환값은 **항상 불리언이 아니다**.
  - 위 예에서 `name` 은 문자열, `token` 은 토큰이나 `false/nil` 이 될 수 있다.

#### 삼항 연산자처럼 쓰고 싶은 유혹

타 언어의 `cond ? a : b` 를 아래처럼 쓰고 싶을 수 있다.

```elixir
# cond? a : b 처럼 쓰려는 패턴

(cond && a) || b
```

하지만 이 패턴은:

- `a` 가 false/nil 일 때 `b`로 떨어지는 등, **의도와 다른 결과**를 낳기 쉽다.
- 코드를 읽는 사람에게도 부담이 된다.

따라서 **2분기 이상**이면 그냥 `if` 를 쓰는 편이 낫다.

---

### 파이프라인과 함께 쓰기

파이프라인 안에서는 `if` 로 흐름을 갈라야 할 일이 발생한다.
이때 **`Kernel.then/2`** 와 함께 쓰면 깔끔해진다.

```elixir
id
|> fetch_user()
|> then(fn
  {:ok, u} ->
    u

  _ ->
    if create_missing? do
      create_user(id)
    else
      raise "no user"
    end
end)
```

또는 조금 단순한 경우:

```elixir
payload
|> normalize()
|> then(fn data ->
  if valid?(data) do
    {:ok, data}
  else
    {:error, :invalid}
  end
end)
```

핵심:

- 파이프라인 안에서 `if` 를 쓰고 싶다면,
  **파이프를 끊지 말고 then/2 안에 집어넣는다**.

---

### 가드와 if

`if` 자체는 “가드 문맥”이 아니다.
하지만 **조건에 가드에 쓰이는 표현식**을 그대로 넣어 쓰는 경우가 많다.

```elixir
if is_integer(n) and n >= 0 do
  :nat
else
  :bad
end
```

여기서 `is_integer/1` 은 **가드에서 허용되는 함수**이지만,
일반 표현식 위치에서도 물론 잘 동작한다.

주의할 점:

- `if` 조건에는 **어떤 표현식이든** 올 수 있지만,
  **함수 헤드/`case` 가드**에는 제한된 함수만 올 수 있다.

---

### 실전 예시: 간단한 피처 플래그

기존 예:

```elixir
defmodule Flags do
  def can?(user, :export_csv) do
    if user.is_admin or Map.get(user.meta, :beta_export) do
      :allowed
    else
      :denied
    end
  end
end
```

이를 조금 더 실전적으로 확장해 보자.

```elixir
defmodule Flags do
  def can?(user, feature) do
    cond do
      user.is_admin ->
        :allowed

      feature in user.blocked_features ->
        :denied

      feature in user.beta_features ->
        if user.email_verified do
          :allowed
        else
          :needs_verification
        end

      true ->
        :denied
    end
  end
end
```

여기서 `if` 는 **작은 2분기** 에만 사용하고,
큰 분기 구조는 `cond` 로 가져간 점을 눈여겨 볼 것.

---

## _12.2 cond_

`cond` 는 “if-else if-else” 체인을 표현식으로 쓴 것과 같다.
**위에서부터 차례로 조건을 검사**하여, **처음으로 참인 절의 결과를 반환**한다.

### 기본 형태

```elixir
cond do
  x < 0      -> :neg
  x == 0     -> :zero
  x > 0      -> :pos
end
```

- 어떤 절도 참이 아니면 `CondClauseError` 가 발생한다.
- 보통 **마지막에 `true -> ...`** 를 두어 “else” 역할을 한다.

```elixir
cond do
  good?() -> :ok
  warn?() -> :warn
  true    -> :fallback   # else 역할
end
```

#### cond의 반환 값

`cond` 도 **표현식**이므로, 반환 값을 변수에 대입할 수 있다.

```elixir
sign =
  cond do
    x > 0  -> 1
    x < 0  -> -1
    true   -> 0
  end
```

이렇게 되면, 이후 로직을 `sign` 값만 보고 처리할 수 있다.

---

### 가드 기반 다중 분기

각 절에는 **가드 표현식**을 조합해 쓰는 게 흔하다.

```elixir
cond do
  is_integer(n) and n >= 0 ->
    {:ok, :nat}

  is_float(n) and n >= 0.0 ->
    {:ok, :nonneg_float}

  is_binary(n) ->
    {:error, :string_not_allowed}

  true ->
    {:error, :bad_number}
end
```

- 타입/범위/패턴에 따라 **서로 다른 태그와 값**을 반환하기 좋다.

#### 구조체/맵 가드와 함께 쓰기

```elixir
cond do
  match?(%User{role: :admin}, user) ->
    :admin

  match?(%User{role: :staff}, user) and user.active ->
    :staff_active

  true ->
    :user
end
```

- `match?/2` 도 가드에서 유용하게 쓰인다.
- 복잡한 구조체 매칭이 필요하면 `case` 로 승급하는 것이 낫다.

---

### `cond` vs `if` 선택 기준

요약:

- 분기가 **2개**만 있으면 → `if` 또는 `unless`.
- 분기가 **3개 이상**, 그리고 분기 기준이 **“조건식”** 위주라면 → `cond`.
- 분기 기준이 숫자/문자열이 아니라 **데이터 형태/태그**라면 → `case`.

```elixir
# 나쁜 예: if로 여러 분기를 억지로 표현

if score >= 90 do
  :s
else
  if score >= 80 do
    :a
  else
    if score >= 70 do
      :b
    else
      :c
    end
  end
end

# 좋은 예: cond로 승급

cond do
  score >= 90 -> :s
  score >= 80 -> :a
  score >= 70 -> :b
  true        -> :c
end
```

---

### `cond` 의 “계산 비용 순서” 주의

`cond` 는 위에서 아래로 조건을 검사한다.
각 조건을 검사하는 비용과 참이 될 확률을 생각하면, **순서**가 의미를 가진다.

간단한 모델:

- 조건이 $$k$$개이고, 그 중 $$i$$번째 조건이 참이 될 확률을 $$p_i$$ 라고 하자.
- 모든 조건 검사 비용이 같다고 하면, 기댓값은 대략:

$$
\mathbb{E}[\text{검사 횟수}] \approx \sum_{i=1}^{k} i \cdot p_i.
$$

여기에 “앞의 조건이 모두 거짓이어야 i번째 조건을 검사한다”는 점까지 고려하면,

$$
\mathbb{E}[\text{검사 횟수}] \approx \sum_{i=1}^{k} i \cdot p_i \cdot \prod_{j=1}^{i-1} (1 - p_j).
$$

실무 팁:

- **자주 걸리는 조건**일수록 **앞쪽에** 둔다.
- 검사 비용이 큰 조건은 **나중**으로 밀어낸다.

예:

```elixir
cond do
  cheap_check?(x)      -> :cheap
  expensive_check?(x)  -> :expensive
  true                 -> :default
end
```

---

### 실전 예시: HTTP 상태 분류

기존 예:

```elixir
def classify(code) when is_integer(code) do
  cond do
    code in 100..199 -> :informational
    code in 200..299 -> :success
    code in 300..399 -> :redirect
    code in 400..499 -> :client_error
    code in 500..599 -> :server_error
    true             -> :unknown
  end
end
```

조금 확장:

```elixir
defmodule HttpClassify do
  def class_and_retry?(code) when is_integer(code) do
    class =
      cond do
        code in 100..199 -> :informational
        code in 200..299 -> :success
        code in 300..399 -> :redirect
        code in 400..499 -> :client_error
        code in 500..599 -> :server_error
        true             -> :unknown
      end

    retry? =
      cond do
        class in [:informational, :success] -> false
        class == :client_error              -> false
        class == :server_error              -> true
        true                                -> false
      end

    {class, retry?}
  end
end
```

- 첫 번째 `cond` 로 **분류**,
- 두 번째 `cond` 로 **재시도 여부 결정**.

---

### `cond` 에서 결과를 **값**으로 사용하는 패턴

기존 예:

```elixir
rank =
  cond do
    score >= 90 -> :s
    score >= 80 -> :a
    score >= 70 -> :b
    true        -> :c
  end

do_award(rank)
```

조금 더 복잡한 구조를 예로 들면:

```elixir
badge =
  cond do
    score >= 95 and streak >= 10 ->
      {:platinum, %{bonus: 100}}

    score >= 90 ->
      {:gold, %{bonus: 50}}

    score >= 80 ->
      {:silver, %{bonus: 20}}

    true ->
      {:bronze, %{bonus: 0}}
  end

assign_badge(user, badge)
```

제어 흐름이 아니라, “조건에 따라 **값을 계산해 내는 함수**”라는 시각을 유지하는 것이 중요하다.

---

## _12.3 case_

`case` 는 **패턴 매칭 기반 분기**다.
값의 **모양**(태그, 튜플 항목, 맵 키, 구조체, 바이너리 헤드, 범위, 가드 등)에 따라 로직을 나눈다.

### 기본 형태

```elixir
case value do
  {:ok, v}    -> v
  {:error, r} -> handle_error(r)
  _           -> :unknown
end
```

- 어떤 절도 매칭하지 못하면 `CaseClauseError` 가 발생한다.
- 마지막 절에 `_` 를 두는 것은 “기본값” 역할.

---

### 태그드 튜플 관용구

엘릭서/Erlang에서 **“성공/실패”를 표현하는 표준 패턴**:

- 성공: `{:ok, value}`
- 실패: `{:error, reason}`

```elixir
def parse(bin) do
  if String.contains?(bin, "="), do: {:ok, %{}}, else: {:error, :invalid}
end

case parse(input) do
  {:ok, map}          -> use(map)
  {:error, :invalid}  -> {:bad_request, 400}
  {:error, reason}    -> {:error, reason}
end
```

장점:

- 모든 경우를 **명시적으로 나열**하기 때문에,
  나중에 패턴이 추가되면 컴파일러가 “누락된 절”을 경고해 줄 수 있다.

---

### 패턴 + 가드

`case` 절에서는 **패턴 매칭 + 가드**를 같이 쓸 수 있다.

```elixir
case term do
  n when is_integer(n) and n >= 0 ->
    {:nat, n}

  n when is_float(n) and n >= 0.0 ->
    {:float, n}

  _ ->
    :bad
end
```

- 먼저 패턴으로 **타입/모양**을 필터링하고,
- 그 다음 가드로 **추가 조건(범위, 속성)** 을 체크하는 구조다.

---

### 맵/구조체 매칭

맵은 키 기반으로 패턴 매칭할 수 있다.

```elixir
case data do
  %User{id: id, email: e} = u
    when is_integer(id) and is_binary(e) ->
    {:user, u}

  %{"id" => id, "email" => e}
    when is_integer(id) and is_binary(e) ->
    {:json_user, %User{id: id, email: e}}

  _ ->
    :bad
end
```

포인트:

- 구조체 `%User{}` 패턴은 **모듈 이름 + 필드 이름**으로 매칭한다.
- `%{"id" => id}` 는 **JSON 디코딩 결과** 같은 맵에서 사용.

---

### 바이너리/비트스트링 매칭

바이너리 패턴 매칭은 **네트워크 패킷/파일 포맷** 파싱에 매우 강력하다.

```elixir
case packet do
  <<len::16, type::8, payload::binary-size(len)>> ->
    {:ok, type, payload}

  <<0xFF, _rest::binary>> ->
    {:error, :reserved}

  _ ->
    {:error, :short}
end
```

명세가 다음과 같다고 하자.

- `[len:16][type:8][payload:len]`
- 또는 `0xFF` 로 시작하면 예약 값

위 코드는 명세를 **정확히 패턴으로 구현**한 형태다.

---

### 범위/컬렉션 패턴

정수 범위를 사용하는 패턴:

```elixir
case score do
  s when s in 90..100 -> :s
  s when s in 80..89  -> :a
  s when s in 70..79  -> :b
  _ -> :c
end
```

리스트 패턴:

```elixir
case list do
  [] ->
    :empty

  [x] ->
    {:single, x}

  [h | t] ->
    {:head_tail, h, t}
end
```

---

### 핀 연산자 `^` — 기존 바인딩과 매칭

`case` 안에서 변수 이름을 쓰면, 기본적으로 **새 변수 바인딩**으로 해석된다.
이미 바깥에서 바인딩된 값을 **그대로 비교**하려면 **핀(`^`) 연산자**가 필요하다.

```elixir
expected = :ok

case result do
  ^expected -> :as_expected
  _         -> :different
end
```

핀을 빼먹으면:

```elixir
# 잘못된 예

expected = :ok

case result do
  expected -> :as_expected   # 여기서 expected는 새로 바인딩된다
  _        -> :different
end
```

- 첫 번째 절은 어떤 값이 와도 매칭되고, `expected` 변수에 그 값이 들어갔다가 `:as_expected`가 반환된다.
- 즉, 의도와 완전히 다른 동작을 하게 된다.

---

### 변수 스코프/바인딩 주의

각 `case` 절은 **자신만의 스코프**를 갖는다.

```elixir
v =
  case xs do
    [h | _] -> h
    []      -> :none
  end
```

- 위 코드에서 `h` 는 첫 번째 절에서만 의미가 있고,
  `case` 바깥에서는 존재하지 않는다.
- 대신 `case` 반환값을 받아 `v` 로 사용하는 식으로 작성해야 한다.

또한, `case` 절 안에서 **바깥 변수 이름을 재사용**하면 혼란을 일으키기 쉽다.
가능하면 다른 이름을 쓰거나, **핀 연산자**로 의도를 명확히 하자.

---

### 함수 헤드 vs case

가능하면 **함수 헤드 자체를 여러 절로** 만드는 편이 더 선언적이고,
컴파일러 최적화도 잘된다.

```elixir
# 권장: 함수 헤드로 패턴 매칭

def head([h | _]), do: {:ok, h}
def head([]), do: :error
```

`case` 로 억지로 표현하면:

```elixir
# 가능은 하지만 굳이 이렇게 쓸 필요는 없다

def head(xs) do
  case xs do
    [h | _] -> {:ok, h}
    []      -> :error
  end
end
```

- “공개 API”의 변형 종류를 표현할 때는 **함수 헤드**를 우선적으로 고려한다.
- “함수 내부의 지역적인 분기”가 필요할 때 `case` 를 사용한다.

---

### 실전: 파일 읽기 + 포맷 분기

기존 예:

```elixir
def load(path) do
  case File.read(path) do
    {:ok, bin} ->
      case Path.extname(path) do
        ".json" -> Jason.decode(bin)
        ".csv"  -> {:ok, parse_csv(bin)}
        _       -> {:error, :unsupported}
      end

    {:error, :enoent} -> {:error, :not_found}
    {:error, reason}  -> {:error, reason}
  end
end
```

여기에 `cond` 와 `if` 를 약간 섞어 확장해 보자.

```elixir
def load_and_log(path, opts \\ []) do
  log? = Keyword.get(opts, :log, true)

  result =
    case File.read(path) do
      {:ok, bin} ->
        decoded =
          case Path.extname(path) do
            ".json" -> Jason.decode(bin)
            ".csv"  -> {:ok, parse_csv(bin)}
            _       -> {:error, :unsupported}
          end

        case decoded do
          {:ok, data} -> {:ok, data}
          {:error, r} -> {:error, r}
        end

      {:error, :enoent} ->
        {:error, :not_found}

      {:error, reason} ->
        {:error, reason}
    end

  if log? do
    Logger.debug("load_and_log(#{inspect(path)}) -> #{inspect(result)}")
  end

  result
end
```

- 최상위는 `case File.read/1`
- 내부 확장은 `case Path.extname/1`
- 로그 여부는 `if` 로 처리하는 구조다.

---

## _12.4 실전 레시피: 제어 구문 선택 가이드_

정리 차원에서, 언제 어떤 제어 구문을 고를지 표로 다시 정리한다.

| 상황 | 권장 구문 | 이유/메모 |
|------|-----------|-----------|
| 참/거짓 2분기 | `if/unless` | 가장 단순한 2분기, 표현식으로 쓰기 좋음 |
| 조건이 3개 이상, 패턴 매칭 중요하지 않음 | `cond` | 위→아래, 첫 참 절 반환, 가독성 좋음 |
| 데이터 모양(태그, 튜플, 맵, 바이너리)에 따라 분기 | `case` | 패턴 매칭+가드로 형태 기반 분기 |
| API 성공/실패 체인 | `with` | 성공 경로만 위에서 아래로 서술, 실패는 자동으로 튀어나감 |
| 라이브러리/모듈의 “공개 계약” | 여러 함수 헤드 | 인풋 패턴 및 타입을 함수 선언으로 명시 |

실제 코드는 이들을 섞어 쓰는 경우가 많다.

예:

- 외부에서 들어오는 메시지의 형태에 따라 `case` 로 1차 분기
- 각 케이스 내부에서 `cond` 로 세부 조건 처리
- 특정 짧은 2분기는 `if` 로 처리
- 상위 레벨에서는 `with` 로 에러 흐름을 제어

---

## _12.5 흔한 함정 → 교정_

기존 정리에서 언급했던 함정들을, 각각 **조금 더 확장된 예시와 함께** 정리한다.

### if로 모든 것을 해결하려 함

문제:

```elixir
if cond1 do
  # ...
else
  if cond2 do
    # ...
  else
    if cond3 do
      # ...
    else
      # ...
    end
  end
end
```

- 읽기 어렵고, 수정 시 버그가 생기기 쉽다.

교정:

```elixir
cond do
  cond1 -> ...
  cond2 -> ...
  cond3 -> ...
  true  -> ...
end
```

또는 **패턴** 위주라면 `case` 로.

---

### truthiness 오해

다른 언어에서 온 개발자는 종종:

- `0` 또는 `""` 를 거짓으로 기대한다.

```elixir
iex> if 0 do :truthy else :falsy end
:truthy

iex> if "" do :truthy else :falsy end
:truthy
```

교정:

- 엘릭서에서는 오직 `false` 와 `nil` 만 거짓이다.
- 나머지는 모두 “존재하는 값”으로서 truthy.

이를 이용해:

```elixir
user = find_user(id) || create_user(id)
```

처럼 “없으면 만든다” 패턴을 간결하게 쓸 수 있다.

---

### case 절 누락

```elixir
case status do
  :ok    -> :ok
  :error -> :error
end
```

여기서 `status` 에 다른 값이 들어오면 `CaseClauseError`.

교정:

```elixir
case status do
  :ok    -> :ok
  :error -> :error
  other  -> {:unknown, other}
end
```

또는 최소한:

```elixir
case status do
  :ok    -> :ok
  :error -> :error
  _      -> :unknown
end
```

---

### 핀 연산자 미사용

잘못된 예:

```elixir
expected = 10

case get() do
  expected -> :same
  _        -> :diff
end
```

- 첫 번째 절은 어떤 값이 와도 매칭된다 → 항상 `:same` 이 반환된다.

교정:

```elixir
expected = 10

case get() do
  ^expected -> :same
  _         -> :diff
end
```

---

### 가드에서 비가드 함수 사용

가드에는 **제한된 함수만** 사용할 수 있다.

```elixir
def foo(x) when complex_check(x), do: ...
```

여기서 `complex_check/1` 이 일반 함수라면 컴파일 에러.

교정:

- 가드에서 쓸 로직은 가드 허용 함수만으로 만들거나,
- 가드는 최소한의 타입/범위 검사만 하고, 본문에서 복잡한 검사를 수행.

```elixir
def foo(x) when is_integer(x) and x >= 0 do
  if complex_check(x) do
    ...
  else
    ...
  end
end
```

---

### case 중첩 과다

```elixir
case f1() do
  {:ok, a} ->
    case f2(a) do
      {:ok, b} ->
        case f3(b) do
          {:ok, c} -> {:ok, c}
          {:error, r} -> {:error, {:f3, r}}
        end

      {:error, r} -> {:error, {:f2, r}}
    end

  {:error, r} -> {:error, {:f1, r}}
end
```

- **들여쓰기 지옥**.

교정: `with` 사용.

```elixir
with {:ok, a} <- f1(),
     {:ok, b} <- f2(a),
     {:ok, c} <- f3(b) do
  {:ok, c}
else
  {:error, r} -> {:error, r}
end
```

---

## _12.6 미니 프로젝트: 로그 라우팅기 (if + cond + case 통합 예제)_

기존 예를 확장해, **타입별 로그 라우팅 + 수준 결정**기를 만들어 보자.

```elixir
defmodule LogRouter do
  # 메시지 형태:
  # {:metric, name :: String.t(), value :: number()}
  # {:event, type :: atom(), meta :: map()}
  # {:line,  raw :: binary()}

  def route(msg) do
    case msg do
      {:metric, name, val} when is_binary(name) and is_number(val) ->
        level =
          cond do
            val < 0 ->
              :invalid

            val < 70 ->
              :normal

            val < 90 ->
              :warn

            true ->
              :critical
          end

        {:metric, name, val, level}

      {:event, :login, %{user: u} = meta} ->
        if u do
          {:event, :login, :ok, meta}
        else
          {:event, :login, :bad, meta}
        end

      {:event, type, meta} ->
        {:event, type, meta}

      {:line, raw} when is_binary(raw) ->
        case raw do
          <<"ERR:", rest::binary>> -> {:err, String.trim(rest)}
          <<"INF:", rest::binary>> -> {:info, String.trim(rest)}
          <<"DBG:", rest::binary>> -> {:debug, String.trim(rest)}
          _                        -> {:plain, raw}
        end

      _ ->
        {:error, :unknown_message}
    end
  end
end
```

이 예제 안에:

- `case` : 메시지 타입/형태에 따라 1차 라우팅
- `cond` : metric 값 범위에 따라 레벨 결정
- `if`   : 로그인 이벤트에서 간단한 2분기
- 바이너리 패턴 매칭 : 로그 라인의 prefix로 레벨 결정

까지 모두 섞여 있다.

---

## _12.7 테스트/문서화(doctest) 예시_

제어 구문은 **doctest** 로 손쉽게 문서+테스트를 동시에 관리할 수 있다.

```elixir
defmodule Score do
  @doc """
  점수로 등급을 반환한다.

      iex> Score.rank(95)
      :s

      iex> Score.rank(0)
      :c
  """
  def rank(score) do
    cond do
      score >= 90 -> :s
      score >= 80 -> :a
      score >= 70 -> :b
      true        -> :c
    end
  end
end
```

- `mix test` 시 이 예제가 실제로 실행되고,
  결과가 문서와 다르면 테스트가 실패한다.
- 제어 구문이 복잡해질수록, **입력/출력 예제**를 doctest 로 박아두는 것이 좋다.

---

## _12.8 연습 문제_

실제로 손으로/에디터에서 풀어볼 만한 연습들.

1) **온도 컨트롤**

   입력 형태:

   - `{:c, float}` : 섭씨
   - `{:f, float}` : 화씨

   요구:

   - 우선 `case` 로 섭씨/화씨를 구분하고, 화씨는 섭씨로 변환한다.
   - 섭씨 온도를 기준으로 `cond` 로
     `:cold | :mild | :hot` 중 하나의 태그를 붙인다.
   - 섭씨가 100도 이상이면 `if` 로 “경고 플래그”를 추가한다.

   결과 형태 예:

   ```elixir
   {:ok, %{celsius: c, label: label, warning?: warn?}}
   {:error, :invalid}
   ```

2) **바이너리 프레이밍**

   패킷 구조:

   ```text
   [ver:3][typ:5][len:16][payload:len]
   ```

   요구:

   - `case` + 바이너리 패턴 매칭으로 파서 작성:

     ```elixir
     parse(<<...>>) :: {:ok, %{ver: ver, type: type, payload: payload}} | {:error, reason}
     ```

   - `cond` 로 `ver`/`type` 허용 여부를 검증해,
     허용되지 않은 조합은 `{:error, :unsupported}` 반환.

3) **폼 유효성 검사**

   입력: 맵 `%{"id" => _, "email" => _}`

   요구:

   - `case` 로 필수 키 존재 여부 검사.
   - `cond` 로 `id` 의 길이, `email` 형식을 간단히 검증.
   - `if` 로 `opts[:strict]` 가 참일 때만 추가 규칙 적용.

   결과는 태그드 튜플로:

   ```elixir
   {:ok, normalized}
   {:error, {:missing, field}}
   {:error, {:invalid, field}}
   ```

4) **게임 명령 파서**

   문자열 명령:

   - `"MOVE x y"`
   - `"FIRE t"`
   - `"QUIT"`

   요구:

   - `case` + 바이너리 매칭으로 명령어와 인자를 파싱.
   - `cond` 로 좌표/시간의 범위를 검증.
   - 결과는 `{:move, x, y} | {:fire, t} | :quit | {:error, reason}`.

5) **핀 연산자 체험**

   - 비밀 코드가 `secret = "1234"` 라고 할 때,
   - 입력값이 비밀 코드와 같은지 `case` 로 검사하는 함수를 작성.
   - 처음에는 `^secret` 을 빼먹고 어떻게 오동작하는지 테스트로 재현하고,
     이후 `^secret` 으로 수정했을 때의 차이를 눈으로 확인해 볼 것.

---

## _12.9 마무리_

- **if / unless**
  - 짧은 2분기에 최적화된 도구.
  - 엘릭서에서는 **오직 `false` 와 `nil` 만 거짓**이라는 truthiness 규칙을 항상 염두에 둘 것.
- **cond**
  - 여러 조건(가드)을 위에서 아래로 평가하여,
    **첫 참 절의 값을 반환하는 표현식**.
  - 분기가 셋 이상이면, 중첩 if 대신 cond로 승급하자.
- **case**
  - 튜플 태그, 맵, 구조체, 리스트, 바이너리 등 **데이터의 모양**에 따라
    분기하는 강력한 도구.
  - 가드와 결합하면 **형태 + 조건**까지 한 번에 필터링 가능.
- **표현식 중심 사고**
  - 이들 제어 구문 모두 **값을 계산하는 식**이다.
  - “제어문”처럼 생각하기보다, “조건에 따라 어떤 값을 만들 것인가”에 초점을 두면
    파이프라인/함수형 스타일과 자연스럽게 연결된다.
- **함수 헤드 / with / 태그드 튜플**
  - 제어 구문만으로 복잡한 로직을 처리하려고 하지 말고,
    **여러 함수 헤드, 태그드 튜플, with** 를 함께 활용하면
    “코드가 곧 명세인” 구조를 만들 수 있다.

이 장에서 다룬 if / unless / cond / case 를,
실제 프로젝트의 **라우팅, 검증, 파싱, 로깅, 피처 플래그** 등에 하나씩 적용해 보면,
엘릭서 제어 흐름의 전체 그림이 자연스럽게 몸에 익을 것이다.
