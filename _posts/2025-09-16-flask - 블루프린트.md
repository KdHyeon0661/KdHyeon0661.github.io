---
layout: post
title: flask - 블루프린트로 모듈화
date: 2025-09-16 17:25:23 +0900
category: flask
---
# 5. 블루프린트로 모듈화

> 이 장은 **Flask 블루프린트(BluePrint)로 애플리케이션을 도메인/기능 단위로 모듈화**하는 방법을, **설계 원칙 → 폴더 구조 → 등록/네임스페이스/버전전략 → 공용 에러 핸들링/로깅/미들웨어(요청 훅) 주입 포인트 → 테스트까지** 단계별로 정리한다.  
> 모든 코드는 ```로 감싸고, 수식이 있으면 반드시 $$...$$로 표기한다(본 장은 수식이 거의 없음).

---

## 5.1 블루프린트란 무엇인가 — 언제/왜 쓰나

- **정의**: Flask 앱에 등록되는 **라우트/템플릿/정적파일/에러핸들러/훅**의 **묶음**. 앱 팩토리에서 여러 개를 **등록/조합**해 최종 애플리케이션을 구성.
- **장점**
  1) **모듈성**: 도메인(예: `users`, `orders`, `billing`) 또는 기능 영역(예: `api`, `admin`, `site`)별 분리
  2) **명시적 네임스페이스**: 엔드포인트 충돌 방지(`users.list`, `orders.list`)
  3) **지연 초기화**: import 사이클 완화, 선택적 등록/비활성화 쉬움
  4) **확장성**: 버전 분리(`/api/v1`, `/api/v2`), 마이크로서비스 전환 시 분할 용이

> 요약: 블루프린트는 “하나의 거대한 `app.py`”를 **도메인 단위로 분해**해 **규모/품질/속도** 모두를 끌어올린다.

---

## 5.2 설계 가이드 — 도메인별 vs 기능별 (그리고 혼합)

### 5.2.1 도메인별
- 예: `users`, `catalog`, `orders`, `payments`, `analytics`
- 장점: 팀/도메인 경계와 맞음. 비즈니스 변경이 모듈 내부로 국한됨.
- 단점: 횡단 관심사(인증/감사/요금제/레이트리밋) 흩어지기 쉬움 → **공용 미들웨어/헬퍼/서비스 계층**으로 보완.

### 5.2.2 기능별
- 예: `api`, `admin`, `site`(SSR), `webhook`
- 장점: 채널/표현 관점 분리 쉬움(어드민/공개/내부), 인증 정책/템플릿/정적 리소스 분기가 명확.
- 단점: 각 기능 하위에 결국 도메인별 라우트를 또 나눠야 함 → **기능 → 도메인** 2단계 구조 권장.

### 5.2.3 추천 혼합 모델
```
app/
├─ blueprints/
│  ├─ site/            # SSR
│  ├─ admin/           # 관리자 UI
│  ├─ api/
│  │  ├─ v1/           # ← 기능(api) + 버전
│  │  │  ├─ users/     # ← 도메인
│  │  │  ├─ orders/
│  │  │  └─ payments/
│  │  └─ v2/
│  └─ webhooks/
```

---

## 5.3 기본 스캐폴딩(앱 팩토리 + 다중 블루프린트)

```python
# app/__init__.py
from flask import Flask
from .config import load_config

def create_app(config_name=None):
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(load_config(config_name))

    # 공용 초기화
    _init_extensions(app)       # db, migrate, cache ...
    _register_blueprints(app)   # 블루프린트 등록
    _register_error_handlers(app)
    _register_cli(app)
    _setup_logging(app)
    return app

def _register_blueprints(app: Flask) -> None:
    from .blueprints.site import site_bp
    from .blueprints.admin import admin_bp
    from .blueprints.api.v1 import api_v1_bp
    from .blueprints.webhooks import webhooks_bp

    app.register_blueprint(site_bp)                  # /
    app.register_blueprint(admin_bp, url_prefix="/admin")
    app.register_blueprint(api_v1_bp, url_prefix="/api/v1")
    app.register_blueprint(webhooks_bp, url_prefix="/webhooks")
```

```python
# app/blueprints/site/__init__.py
from flask import Blueprint
site_bp = Blueprint("site", __name__, template_folder="templates", static_folder="static")
from . import views  # noqa
```

```python
# app/blueprints/site/views.py
from flask import render_template
from . import site_bp

@site_bp.get("/")
def home():
    return render_template("home.html", title="Home")
```

**포인트**
- 블루프린트 파일에서 **라우트 등록은 마지막에 import**(순환 참조 방지).
- 각 블루프린트의 **템플릿/정적 폴더**를 분리할 수 있음.

---

## 5.4 네임스페이스/엔드포인트 이름 규약

- 엔드포인트 이름: **`<blueprint_name>.<function_name>`**  
- `url_for("site.home")`, `url_for("api_v1.users_get", id=1)` 처럼 **명시적** 호출.
- 규약 예:
  - 목록: `<domain>_list`
  - 단건조회: `<domain>_get`
  - 생성: `<domain>_create`
  - 갱신: `<domain>_update`
  - 삭제: `<domain>_delete`

```python
# app/blueprints/api/v1/users/views.py
from flask import Blueprint, jsonify, request

users_bp = Blueprint("api_v1_users", __name__)  # blueprint 이름은 endpoint prefix에 영향
# app.register_blueprint(users_bp, url_prefix="/api/v1/users")

@users_bp.get("/")
def users_list():
    return jsonify(items=[{"id":1,"name":"Alice"}])

@users_bp.get("/<int:user_id>")
def users_get(user_id: int):
    return jsonify(id=user_id, name="Alice")
```

> 블루프린트 이름과 라우트 함수명이 엔드포인트를 구성한다. **가독성/일관성**을 위해 팀 규약을 문서화하라.

---

## 5.5 버전 전략: v1/v2(평행운영), Deprecated 안내

```python
# app/blueprints/api/v1/__init__.py
from flask import Blueprint
api_v1_bp = Blueprint("api_v1", __name__)
from .users.views import users_bp as users_v1_bp  # 하위 도메인 블루프린트
api_v1_bp.register_blueprint(users_v1_bp, url_prefix="/users")
```

```python
# app/blueprints/api/v2/__init__.py
from flask import Blueprint
api_v2_bp = Blueprint("api_v2", __name__)
# v2는 users 스키마/라우트가 바뀌었을 수 있음
```

- **v1/v2를 병행 제공**하고, 응답 헤더로 `Deprecation: true`, `Sunset: <iso-date>` 제공.
- 문서(`/docs`)에 **변경점/마이그레이션 가이드** 포함.

---

## 5.6 공용 에러 핸들링 — 어디에/어떻게 붙이나

### 5.6.1 앱 전역 에러 핸들러(권장)

```python
# app/errors.py
from flask import Blueprint, jsonify, g
from werkzeug.exceptions import HTTPException

errors_bp = Blueprint("errors", __name__)

@errors_bp.app_errorhandler(HTTPException)
def http_error(e: HTTPException):
    payload = {
        "error": {
            "code": e.name.replace(" ", "_").lower(),
            "message": e.description,
            "request_id": getattr(g, "request_id", None)
        }
    }
    return jsonify(payload), e.code

@errors_bp.app_errorhandler(Exception)
def internal_error(e: Exception):
    # 내부 로깅/알림 (Sentry 등) 후 외부엔 덜 자세한 메시지
    payload = {
        "error": {
            "code": "internal_error",
            "message": "서버 오류가 발생했습니다.",
            "request_id": getattr(g, "request_id", None)
        }
    }
    return jsonify(payload), 500
```

```python
# app/__init__.py (등록)
from .errors import errors_bp
app.register_blueprint(errors_bp)
```

### 5.6.2 블루프린트 전용 에러 핸들러(선택)
- 특정 **네임스페이스**에서만 다른 포맷/메시지를 쓰고 싶을 때.

```python
# app/blueprints/webhooks/__init__.py
from flask import Blueprint, jsonify
webhooks_bp = Blueprint("webhooks", __name__)

@webhooks_bp.app_errorhandler(400)
def webhook_bad_request(e):
    return jsonify(status="ng", reason=str(e)), 400
```

> **우선순위**: 블루프린트 핸들러 → 앱 전역 핸들러.  
> 분산 사용 시 **응답 포맷이 서로 달라지지 않도록** 주의(문서화 필수).

---

## 5.7 공용 로깅 — 구조화/상관ID/메트릭 훅

### 5.7.1 구조화 로깅 세팅

```python
# app/logging.py
import logging
from pythonjsonlogger import jsonlogger

def setup_logging(app):
    handler = logging.StreamHandler()
    fmt = jsonlogger.JsonFormatter("%(levelname)s %(name)s %(message)s")
    handler.setFormatter(fmt)
    app.logger.handlers.clear()
    app.logger.addHandler(handler)
    app.logger.setLevel(logging.INFO)
```

```python
# app/__init__.py
from .logging import setup_logging
setup_logging(app)
```

### 5.7.2 요청 단위 상관 ID(Request ID)

```python
# app/middleware.py
import uuid
from flask import g, request

def register_request_hooks(app):
    @app.before_request
    def inject_request_id():
        g.request_id = request.headers.get("X-Request-ID") or uuid.uuid4().hex

    @app.after_request
    def add_common_headers(resp):
        resp.headers["X-Request-ID"] = getattr(g, "request_id", "-")
        return resp
```

모든 블루프린트에서 접근 가능:

```python
from flask import current_app, g

current_app.logger.info("something", extra={"request_id": getattr(g, "request_id", "-")})
```

> **Tip**: OpenTelemetry/Jaeger 연동 시 트레이스 ID/스팬 ID도 함께 로깅.

---

## 5.8 공용 미들웨어(훅) 주입 포인트 — 전역과 지역

### 5.8.1 전역 훅(모든 블루프린트에 적용)

```python
# app/__init__.py
from .middleware import register_request_hooks
register_request_hooks(app)
```

- **before_request**: 인증 프리체크, 로케일 결정, 요청 크기/포맷 선검사
- **after_request**: 보안 헤더, 캐시 헤더, 공용 로깅, CORS 헤더

### 5.8.2 블루프린트 한정 훅

```python
# app/blueprints/api/v1/__init__.py
from flask import Blueprint, request, jsonify
api_v1_bp = Blueprint("api_v1", __name__)

@api_v1_bp.before_request
def api_guard():
    # 예) 모든 /api/v1 요청에 토큰 필수
    if not request.headers.get("Authorization"):
        return jsonify(error={"code":"unauthorized","message":"토큰 필요"}), 401

@api_v1_bp.after_request
def api_headers(resp):
    resp.headers["X-API-Version"] = "v1"
    return resp
```

> **지역 훅**은 해당 블루프린트와 그 **하위 블루프린트**에만 적용.

---

## 5.9 도메인 블루프린트 내부 구조(서비스/스키마/뷰 분리)

```
app/blueprints/api/v1/users/
├─ __init__.py          # users_bp = Blueprint(...)
├─ views.py             # HTTP 라우트
├─ schemas.py           # 입력/출력 스키마 (Marshmallow/Pydantic)
├─ services.py          # 도메인 로직(비즈니스 규칙)
└─ repo.py              # DB 접근/리포지토리
```

```python
# app/blueprints/api/v1/users/services.py
from dataclasses import dataclass

@dataclass
class User:
    id: int
    email: str
    name: str

def create_user(email: str, name: str) -> User:
    # 유효성/중복 검증/DB 저장
    return User(id=123, email=email, name=name)
```

```python
# app/blueprints/api/v1/users/schemas.py (Marshmallow 예시)
from marshmallow import Schema, fields, validate

class UserIn(Schema):
    email = fields.Email(required=True)
    name = fields.String(required=True, validate=validate.Length(max=60))

class UserOut(Schema):
    id = fields.Int(required=True)
    email = fields.Email(required=True)
    name = fields.String(required=True)
```

```python
# app/blueprints/api/v1/users/views.py
from flask import Blueprint, request
from .schemas import UserIn, UserOut
from .services import create_user

users_bp = Blueprint("api_v1_users", __name__)

@users_bp.post("/")
def users_create():
    data = request.get_json(silent=False)
    errors = UserIn().validate(data)
    if errors:
        return {"error":{"code":"validation_failed","details":errors}}, 422
    user = create_user(**data)
    return UserOut().dump(user.__dict__), 201
```

---

## 5.10 블루프린트 간 공용 헬퍼/확장 주입

**패턴**: `app/extensions.py` 에서 확장 지연 초기화 후 `init_app`.

```python
# app/extensions.py
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
db = SQLAlchemy()
migrate = Migrate()

def init_extensions(app):
    db.init_app(app)
    migrate.init_app(app, db)
```

도메인 코드에서:

```python
from app.extensions import db

class UserModel(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False)
```

> 블루프린트는 **애플리케이션 컨텍스트** 안에서 동작하므로 `current_app`, `db.session` 등을 안전하게 사용.

---

## 5.11 CORS/인증/레이트 리미팅 — 블루프린트 단위 적용

```python
# CORS (pip install flask-cors)
from flask_cors import CORS
CORS(api_v1_bp, resources={r"/*": {"origins": ["https://app.example.com"]}})
```

```python
# 레이트 리미트 (pip install flask-limiter)
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(get_remote_address)

def create_app(...):
    app = Flask(__name__)
    limiter.init_app(app)
    app.register_blueprint(api_v1_bp, url_prefix="/api/v1")

@api_v1_bp.route("/auth/login", methods=["POST"])
@limiter.limit("10/minute")
def login():
    ...
```

> **권장**: 인증/인가/리밋 정책은 **API 네임스페이스(블루프린트)** 기준으로 선언해 **일관성** 확보.

---

## 5.12 정적 자산/템플릿 — 블루프린트 별 분리

```python
admin_bp = Blueprint(
    "admin", __name__,
    url_prefix="/admin",
    template_folder="templates",
    static_folder="static",
    static_url_path="/admin-static"
)
```

템플릿에서:

```html
<link rel="stylesheet" href="{{ url_for('admin.static', filename='css/admin.css') }}">
```

> 대규모 앱에서 **기능 단위의 독립된 자산 파이프라인**(빌드/해시/배포)을 운영하기 쉬워진다.

---

## 5.13 Webhook·외부 콜백 전용 블루프린트(서명 검증)

```python
# app/blueprints/webhooks/__init__.py
import hmac, hashlib, os
from flask import Blueprint, request, abort

webhooks_bp = Blueprint("webhooks", __name__)
SECRET = os.getenv("WEBHOOK_SECRET", "dev")

@webhooks_bp.post("/payment")
def payment():
    sig = request.headers.get("X-Signature")
    raw = request.data
    expected = hmac.new(SECRET.encode(), raw, hashlib.sha256).hexdigest()
    if not sig or not hmac.compare_digest(sig, expected):
        abort(401, description="invalid signature")
    # 이벤트 처리...
    return "", 204
```

> CSRF 제외(`@csrf.exempt`) 대신, **서명 검증**을 강제하고 **IP allowlist** 등 2차 방어 권장.

---

## 5.14 Swagger 그룹핑 — OpenAPI 뷰에서 네임스페이스 유지

flask-smorest 사용 시 블루프린트 단위로 **태그/설명**을 주어 문서 그룹을 만든다.

```python
# app/blueprints/api/v1/users/views.py (발췌, smorest)
from flask_smorest import Blueprint
blp = Blueprint("users", "users", description="Users API (v1)")
```

OpenAPI UI에서 `users` 그룹으로 묶여 보임. v1/v2는 각각의 블루프린트에 별도 태그.

---

## 5.15 동적 등록/테넌시 — 특정 조건에서만 활성화

- **환경변수/설정**에 따라 블루프린트 등록 여부 결정
- **멀티테넌시**: 요청 도메인/헤더에 따라 blueprint-like 라우팅 조합(게이트웨이에서 분기 권장)

```python
def _register_blueprints(app):
    if app.config.get("ENABLE_ADMIN"):
        from .blueprints.admin import admin_bp
        app.register_blueprint(admin_bp, url_prefix="/admin")
```

---

## 5.16 요청 훅의 실행 순서와 주의점

**전역 vs 블루프린트** 훅이 섞이는 경우의 순서(요지):

1) 앱 전역 `before_request`  
2) 매칭된 **블루프린트**의 `before_request`  
3) 뷰 함수 실행  
4) 뷰에서 반환된 응답에 대해 **블루프린트** `after_request`  
5) 앱 전역 `after_request`

> **주의**: 동일 키의 헤더/쿠키를 **여러 훅에서 수정**할 때 **순서/덮어쓰기**를 의도대로 설계.

---

## 5.17 테스트 — 블루프린트 단위로 격리

### 5.17.1 앱 팩토리 활용 픽스처

```python
# tests/conftest.py
import pytest
from app import create_app

@pytest.fixture()
def app():
    app = create_app("testing")
    yield app

@pytest.fixture()
def client(app):
    return app.test_client()
```

### 5.17.2 블루프린트 라우트 테스트

```python
def test_users_list(client):
    r = client.get("/api/v1/users/")
    assert r.status_code == 200
    assert "items" in r.get_json()

def test_site_home(client):
    r = client.get("/")
    assert r.status_code == 200
    assert b"Home" in r.data
```

### 5.17.3 훅/헤더/에러 핸들러 테스트

```python
def test_request_id_header(client):
    r = client.get("/", headers={"X-Request-ID": "abc"})
    assert r.headers["X-Request-ID"] == "abc"

def test_unknown_route_404(client):
    r = client.get("/nope")
    assert r.status_code == 404
    data = r.get_json()
    assert data["error"]["code"] in ("not_found", "404_not_found")
```

---

## 5.18 운영 체크리스트

- [ ] **도메인/기능 혼합 설계**: 네임스페이스 계층(v1/users 등) 명확  
- [ ] **엔드포인트 규약**: `list/get/create/update/delete` 네이밍 일관성  
- [ ] **공용 훅**: Request ID/보안 헤더/로케일/CORS/캐시 정책 전역 주입  
- [ ] **블루프린트 훅**: 인증/레이트리밋/버전 헤더 등 네임스페이스 한정 정책  
- [ ] **공용 에러 포맷**: 앱 전역 핸들러로 JSON 규약 보장, 예외 최소화  
- [ ] **로깅**: 구조화(JSON), 상관 ID, 민감정보 마스킹  
- [ ] **문서화**: OpenAPI에서 블루프린트/버전별 태그 유지  
- [ ] **동적 등록/플래그**: 기능 토글/환경별 라우팅 제어  
- [ ] **정적 자산 분리**: 블루프린트 static/템플릿 폴더, CDN/해시 연계  
- [ ] **테스트**: 각 네임스페이스별 라우트/훅/에러 경로 커버리지

---

## 5.19 흔한 안티패턴

- **하나의 거대한 블루프린트**: 네임스페이스 의미 상실 → 도메인/기능 단위로 쪼개라  
- **전역 훅 남용**: 세부 정책(예: 특정 API 인증)을 전역에서 처리 → 블루프린트 훅으로 범위 축소  
- **에러 포맷 혼재**: 일부 블루프린트에서 다른 JSON 스키마 → 전역 핸들러로 통일  
- **엔드포인트 이름 충돌**: 함수명 중복/불규칙 → 접두사/규약 준수  
- **정적 파일 공유 디렉터리**: 관리자/공개 자산 혼재 → blueprint static으로 분리  
- **버전 교차 오염**: v1과 v2 코드가 섞임 → 별도 블루프린트/폴더로 격리

---

## 5.20 미니 레퍼런스 — 자주 쓰는 API

```python
# 생성
bp = Blueprint("name", __name__, template_folder="templates", static_folder="static", url_prefix="/x", static_url_path="/x-static")

# 등록
app.register_blueprint(bp, url_prefix="/x")  # 중첩 prefix 가능

# 훅
@bp.before_request
def _():
    ...

@bp.after_request
def _(resp):
    return resp

# 에러
@bp.app_errorhandler(403)
def forb(e):
    return {"error":"forbidden"}, 403

# 정적 파일 URL
url_for("name.static", filename="css/app.css")

# 엔드포인트 URL
url_for("name.route_fn", id=1)
```

---

## 5.21 마무리

이 장에서는 **블루프린트를 도메인/기능 단위로 설계**하고, **네임스페이스/버전/동적등록**으로 확장하는 법, 그리고 **공용 에러 핸들링/로깅/미들웨어**를 **전역/지역 훅**에 주입하는 패턴을 살펴봤다.