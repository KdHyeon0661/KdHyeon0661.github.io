---
layout: post
title: Elixir - 컬렉션 다루기 (1)
date: 2025-11-17 18:25:23 +0900
category: Elixir
---
# Enum과 Stream — 컬렉션과 스트림 처리의 모든 것

> 목표
> - 엘릭서에서 컬렉션을 다루는 두 축 **Enum(엄격 평가)** 과 **Stream(지연 평가)** 의 개념/구현/성능 차이를 이해한다.
> - 리스트, 맵, MapSet, 파일/IO, 사용자 정의 컬렉션까지 **Enumerable/Stream 파이프라인**으로 일관되게 처리하는 법을 익힌다.
> - `map / filter / reduce` 를 넘어, `chunk_every`, `group_by`, `frequencies`, `transform`, `resource` 등 **실전 함수 패턴**을 체계적으로 정리한다.
> - 성능이 중요한 “핫 루프”에서 **중간 리스트를 줄이는 융합(fusion)** 패턴과, 전체 앱 구조에서 **가독성과 성능의 균형**을 잡는 기준을 세운다.
> - 파일/로그/CSV/네트워크처럼 “끝이 없거나 매우 큰 데이터”를 **Stream 파이프라인**으로 다루는 실전 레시피를 익힌다.

---

## Enum과 Stream 한눈에 비교

먼저 두 모듈의 큰 그림을 표로 정리해 두자.

| 구분 | Enum | Stream |
|---|---|---|
| 평가 방식 | **즉시(엄격)**: 호출 시 바로 끝까지 실행 | **지연**: 변환을 쌓아두고, 마지막 소비자에서 한 번에 실행 |
| 주 대상 | 리스트, 맵, 범위, MapSet, File.stream!, IO.stream! 등 모든 **Enumerable** | Enum과 동일한 “열거 가능한 것 + 생성 규칙” |
| 중간 결과 | 각 단계마다 **새 컬렉션 생성** | 중간 컬렉션 없음, 요소를 **흘려보내며 즉석 처리** |
| 장점 | 단순, 직관적, 디버깅 용이 | 대용량/무한 데이터, IO, 파이프라인 융합에 유리 |
| 단점 | 큰 데이터에서 메모리 사용량 증가 | “소비자”가 없으면 아무 일도 안 일어남, 디버깅 감각 필요 |
| 대표 함수 | `map`, `filter`, `reduce`, `group_by`, `frequencies`, `sort_by`, `chunk_every` | `map`, `filter`, `transform`, `unfold`, `resource`, `each`, `run` |

이제 각 모듈을 차례로 파고들면서, 위 표의 의미를 코드와 함께 해부한다.

---

## _10.1 Enum: 컬렉션 처리하기_

### Enum이 다루는 대상 — Enumerable 프로토콜

`Enum` 모듈은 “**열거 가능한 것**(Enumerable)” 을 다룬다.
엘릭서에서 열거 가능하다는 말은 곧 **Enumerable 프로토콜을 구현했다**는 뜻이다.

기본적으로 다음 타입들이 Enumerable이다.

- 리스트: `[1,2,3]`
- 범위: `1..10`
- 맵: `%{a: 1, b: 2}`
- 구조체 중 일부(내부에 리스트/맵을 갖고, 별도로 Enumerable 구현이 붙은 경우)
- MapSet: `MapSet.new([:a,:b])`
- 파일/IO 스트림: `File.stream!/2`, `IO.stream/2`
- 직접 정의한 타입 + `defimpl Enumerable` 구현

예:

```elixir
Enum.to_list(1..5)
# [1, 2, 3, 4, 5]

Enum.map(%{a: 1, b: 2}, fn {k, v} -> {k, v*10} end)
# [a: 10, b: 20]  (키워드 형태의 튜플 리스트)

Enum.member?(MapSet.new([:a, :b]), :a)
# true

```

여기서 핵심은:

- `Enum.map/2` 는 “**리스트만**” 다루는 함수가 아니다.
- “**Enumerable 프로토콜**을 구현한 모든 것” 을 다룬다.
- 맵을 열거하면 항상 `{key, value}` 튜플로 돌아온다.

> 주의: 맵의 열거 순서는 **의미가 없다.**
> 구현/버전에 따라 “안정적으로 보이는” 것처럼 느껴질 수 있지만,
> **순서에 의존하는 로직**(예: 첫 번째 키가 특정 값이어야 한다)을 작성하면 안 된다.
> 순서가 필요하면 `Enum.sort/2`, `Enum.sort_by/2` 로 명시 정렬하거나,
> 애초에 리스트/키워드 리스트를 사용해야 한다.

#### Enumerable 프로토콜 내부 구조(개념만)

`Enum.*` 함수들은 내부적으로 `Enumerable.reduce/3` 를 이용한다.
직접 구현할 때는 다음 콜백들을 제공해야 한다.

- `reduce/3`
- `count/1`
- `member?/2`
- `slice/1` (선택적)

이 덕분에 `Enum.map/2`, `Enum.filter/2`, `Enum.reduce/3` 등
모든 Enum 계열 함수가 **연속적인 reduce** 로 표현될 수 있다.

이제 이 reduce가 어떤 역할을 하는지 구체적으로 보자.

---

### 핵심 변환 — map / filter / reduce

`Enum`의 거의 모든 함수는 세 개의 원형으로 귀결된다.

1. **map**: 각 원소를 변환
2. **filter**: 조건에 맞지 않는 원소 제거
3. **reduce**: 컬렉션 전체를 하나의 값으로 “접기”

대표 예:

```elixir
Enum.map([1, 2, 3], &(&1 * 2))
# [2, 4, 6]

Enum.filter(1..10, &(rem(&1, 2) == 0))
# [2, 4, 6, 8, 10]

Enum.reduce([1, 2, 3, 4], 0, &+/2)
# 10

```

`reduce/3` 의 시그니처는:

```elixir
@spec reduce(Enum.t(), acc, (element, acc -> acc)) :: acc
```

직관적으로는 다음 수식으로 표현할 수 있다.

$$
\mathrm{reduce}([x_1, x_2, \dots, x_n], a_0, f)
= f(x_n, \dots f(x_2, f(x_1, a_0)) \dots)
$$

예: 리스트의 최대값을 찾는 reduce

```elixir
Enum.reduce([3, 1, 7, 2], fn x, acc -> max(x, acc) end)
# 7

Enum.reduce([3, 1, 7, 2], &max/2)
# 7

```

합계, 개수, 최대/최소, 문자열 join, group, map까지
사실상 모든 집계는 `reduce`로 표현할 수 있다.

---

### 자주 쓰는 “실전” Enum 함수 모음

기본형(map/filter/reduce) 외에도, 실제 코드에서 자주 쓰이는 함수들을 정리해보자.
(원래 제공한 예시를 그대로 포함하고, 각 함수의 실제 쓰임을 확장해서 설명한다.)

```elixir
Enum.flat_map([1,2,3], fn x -> [x, x] end)
# [1,1,2,2,3,3]

Enum.uniq([:a,:a,:b,:b,:b,:c])
# [:a,:b,:c]

Enum.frequencies(~w(a a b c c c))
# %{"a"=>2, "b"=>1, "c"=>3}

Enum.group_by(["kim","kang","lee"], &String.first/1)
# %{"k" => ["kim", "kang"], "l" => ["lee"]}

Enum.sort_by([{:a,2},{:a,1}], fn {_,v} -> v end)
# [{:a,1}, {:a,2}]

Enum.with_index(~w(a b c))
# [{"a",0}, {"b",1}, {"c",2}]

Enum.split(1..10, 3)
# {[1,2,3], [4,5,6,7,8,9,10]}

Enum.chunk_every(1..10, 3, 3, :discard)
# [[1,2,3],[4,5,6],[7,8,9]]

Enum.reduce_while(1..100, 0, fn x, acc ->
  if x < 10, do: {:cont, acc + x}, else: {:halt, acc}
end)
# (1..9의 합)

```

여기서 각 함수의 핵심 포인트:

- `flat_map/2`
  리스트를 반환하는 함수를 적용해 평탄화.
  예: 각 주문에서 라인 아이템 리스트를 평탄화할 때.

- `uniq/1`
  중복 제거. 순서를 유지하면서 첫 등장만 남긴다.

- `frequencies/1`
  값 → 개수 맵을 만들어 준다. 단어 카운트, 상태 카운트 등에 유용.

- `group_by/3`
  특정 기준(함수)에 따라 그룹핑. 예: `user.country` 기준으로 유저를 그룹.

- `sort_by/2`
  구조체/튜플에서 특정 필드로 정렬할 때 편리.

- `with_index/1`
  인덱스를 붙여야 할 때 사용.
  예: UI 리스트 렌더링에서 row number를 붙이기.

- `split/2`
  앞에서 n개와 나머지를 나눈다. 페이지네이션, 헤더/본문 분리 등에 사용.

- `chunk_every/4`
  “배치 처리”의 기본. 일정 크기씩 묶어서 DB insert, API 호출 등에 쓰인다.

- `reduce_while/3`
  조건부 조기 종료. 예를 들면 “처음으로 조건을 만족하는 지점까지의 합” 등의 패턴에 사용.

추가로 자주 쓰이는 함수들을 조금 더 보자.

```elixir
Enum.any?([1, 3, 5], &rem(&1, 2) == 0)   # false
Enum.all?(1..10, &(&1 >= 1))             # true

Enum.find(1..10, fn x -> x > 5 end)      # 6
Enum.find(1..5, fn x -> x > 10 end)      # nil
Enum.find(1..5, :none, fn x -> x > 10 end)  # :none

Enum.max_by(users, & &1.score)
Enum.min_by(users, & &1.inserted_at)
```

- `any?/2`, `all?/2` 로 조건을 빠르게 검사.
- `find/3` 로 첫 일치 원소를 찾되, 없을 때 기본값을 지정.
- `max_by/2`, `min_by/2` 는 특정 필드 기준으로 최대/최소 찾기.

---

### 파이프라인과 “융합” 감각

엘릭서 코드의 미학은 파이프라인에 있다.

```elixir
1..1_000_000
|> Enum.map(&(&1 * &1))
|> Enum.filter(&(rem(&1, 2) == 0))
|> Enum.sum()
```

- 가독성은 좋지만, `map` 결과와 `filter` 결과에서 **중간 리스트**가 각각 한 번씩 생긴다.
- 데이터가 정말 수십/수백만 단위라면, 이 중간 리스트가 꽤 큰 메모리를 차지할 수 있다.

이럴 때 “융합(fusion)” 패턴을 적용할 수 있다.

```elixir
Enum.reduce(1..1_000_000, 0, fn x, acc ->
  y = x * x
  if rem(y, 2) == 0, do: acc + y, else: acc
end)
```

- map + filter + sum 을 **한 번의 reduce** 로 합쳤다.
- 중간 리스트를 만들지 않는다.
- CPU 작업도 줄어든다(반복문이 하나).

성능 제약을 수식으로 보면:

$$
T_{\text{파이프라인}} \approx c_1 n + c_2 n + c_3 n = (c_1 + c_2 + c_3)n
$$

$$
T_{\text{융합 reduce}} \approx c' n
$$

중요한 점:

- 항상 융합할 필요는 없다.
- 대부분의 비핵심 로직은 **가독성 좋은 파이프라인**이 좋다.
- 다만, 프로파일링 결과 **핫 루프**로 확인된 곳은 하나의 reduce/transform으로 융합하는 것이 좋다.

> 규칙: “먼저 **깔끔한 파이프라인**을 쓴다.
> 정말 느리고, 데이터가 크고, 프로파일링이 문제 지점을 가리킬 때
> 그때 **reduce 융합**을 적용한다.”

---

### iodata로 문자열/바이너리 만들기

문자열을 계속 `<>` 로 붙이면, 큰 데이터에서 성능 문제가 생긴다.

```elixir
# 비효율적인 패턴

report =
  Enum.reduce(rows, "", fn row, acc ->
    acc <> "#{row.id}: #{row.value}\n"
  end)
```

각 단계에서 매번 새로운 바이너리를 만든다.
총 길이가 $$n$$ 일 때,
가장 나쁜 경우 전체 시간 복잡도는 대략 $$O(n^2)$$ 까지 올라갈 수 있다.

대신 **iodata** 를 사용한다.

- iodata = “중첩된 리스트 + 바이너리 조각들의 트리 구조”
- 마지막에 `:erlang.iolist_to_binary/1` 로 한 번에 플랫 바이너리로 변환.

```elixir
report =
  rows
  |> Enum.map(fn row -> [row.id, ":", row.value, "\n"] end)
  |> :erlang.iolist_to_binary()
```

이때 복잡도는:

$$
T_{\text{concat}} \approx O(n^2) \quad\text{(나이브 문자열 연결)},\qquad
T_{\text{iodata}} \approx O(n)
$$

실전에서는:

- HTTP 응답 바디, 로그 파일, 대용량 CSV/JSON 생성 시
  iodata 패턴이 사실상 표준이다.

예: HTML 조각 생성

```elixir
html =
  items
  |> Enum.map(fn item ->
    [
      "<li>",
      Phoenix.HTML.html_escape(item.title),
      "</li>\n"
    ]
  end)
  |> :erlang.iolist_to_binary()
```

---

### 맵/MapSet 다루기 — Enumerable로 일관 처리

맵과 MapSet도 모두 Enumerable이다.

```elixir
map = %{a: 1, b: 2, c: 3}

map2 =
  map
  |> Enum.map(fn {k, v} -> {k, v * v} end)
  |> Map.new()

map2
# %{a: 1, b: 4, c: 9}

```

- `Enum.map/2` 로 `{k, v}` 튜플 리스트를 만든 뒤,
- `Map.new/1` 로 다시 맵으로 복원.

MapSet도 동일하다.

```elixir
tags = MapSet.new(~w(api v1)a)

tags_string =
  tags
  |> Enum.sort()
  |> Enum.join(",")

# "api,v1"

```

실전 팁:

- “내부적으로 맵/MapSet을 쓰지만, 그 위에서 Enum으로 대부분 처리”하는 패턴이 많다.
- 컬렉션 종류를 의식하기보다, **“Enum으로 돌릴 수 있는가?”** 를 먼저 생각해보면 설계가 단순해진다.

---

### 파일/IO를 Enum으로 다루기

`File.stream!/2` 는 **Enumerable 스트림**을 돌려준다.

```elixir
"data.txt"
|> File.stream!()
|> Enum.map(&String.trim/1)
|> Enum.reject(&(&1 == ""))
|> Enum.take(10)
```

- `File.stream!/2` 는 기본적으로 “줄 단위” 스트림을 제공한다.
- `Enum.*` 로 처리하면 **파일 전체를 한 번에 메모리로 올리지 않아도** 된다.
- 여기서는 Enum을 사용했기 때문에, 마지막 `Enum.take/2` 에서 **실제로 읽기**가 일어난다.

이 패턴을 약간 변형하면, 간단한 CSV 로더도 금방 만든다.

```elixir
def read_csv(path) do
  path
  |> File.stream!()
  |> Enum.map(&String.trim_trailing/1)
  |> Enum.reject(&(&1 == ""))        # 빈 줄 제거
  |> Enum.map(&String.split(&1, ",")) # 셀 리스트
end
```

큰 파일에서는 `Stream` 쪽으로 넘어가는 것이 더 적절하지만,
작은/중간 크기 파일에서는 Enum만으로도 충분하다.

---

### 에러 처리: 태그드 튜플 일관성

Enum/Stream 파이프라인에서도 에러를 **값**으로 다루는 것이 좋다.
대표 패턴:

```elixir
def run(path) do
  with {:ok, bin} <- File.read(path),
       xs <- String.split(bin, "\n", trim: true),
       true <- length(xs) > 0 or {:error, :empty} do
    {:ok, xs}
  else
    {:error, _} = e -> e
    false -> {:error, :empty}
  end
end
```

- `File.read/1` 의 반환 타입은 `{:ok, binary()} | {:error, reason}` 이다.
- `with` 안에서 태그드 튜플을 그대로 이어가면, 파이프라인과 잘 어울린다.
- Enum 사용 부분(여기서는 `String.split/3`)은 실패 가능성이 거의 없으므로,
  굳이 태그드 튜플로 감싸지 않아도 된다.

이런 스타일은 Stream에서도 그대로 유지된다.

---

### 성능 모델(개략)

엄격 평가 기반 Enum 파이프라인의 시간/메모리 모델을 정리해보자.

파이프라인의 단계가 \(k\) 개,
각 단계의 유효 처리 원소 수가 \(n_i\) 이고,
각 단계의 상수 비용이 \(c_i\) 라고 하면:

$$
T_{\text{Enum pipeline}} \approx \sum_{i=1}^{k} c_i \cdot n_i
$$

각 단계에서 **새로운 컬렉션**을 만들기 때문에,
메모리 사용량은 대략:

$$
M_{\text{Enum}} \approx \sum_{i=1}^{k-1} \text{중간 컬렉션 크기}
$$

따라서:

- 파이프라인이 길수록(**k 증가**)
- 각 단계가 전체 컬렉션을 모두 사용하는 방식일수록(**n_i 가 모두 비슷**)

성능과 메모리 사용량에 부담이 된다.

하지만 이 모델은 어디까지나 **상한선** 정도의 직관일 뿐이고,
실제 성능은 **가독성 + 테스트 가능성 + 튜닝 여지**까지 모두 고려해서 판단해야 한다.

---

### 커스텀 컬렉션을 Enumerable로 만들기

직접 정의한 구조체도 **Enumerable 프로토콜**을 구현하면 `Enum.*`의 대상이 될 수 있다.

예: 간단한 Box 컬렉션

```elixir
defmodule Box do
  defstruct [:items]
end

defimpl Enumerable, for: Box do
  def count(%Box{items: xs}), do: {:ok, length(xs)}

  def member?(%Box{items: xs}, v) do
    {:ok, Enum.member?(xs, v)}
  end

  def slice(_), do: {:error, __MODULE__}

  def reduce(%Box{items: xs}, acc, fun) do
    Enumerable.List.reduce(xs, acc, fun)
  end
end

Enum.map(%Box{items: [1, 2, 3]}, &(&1 * 2))
# [2, 4, 6]

```

핵심은 `reduce/3` 이다.

- `Enumerable.List.reduce/3` 를 그대로 위임하면, 리스트 기반 컬렉션처럼 동작한다.
- `count/1`, `member?/2`, `slice/1` 는 최적화 정보/편의를 제공한다.

추가로 `Collectable` 프로토콜을 구현하면, `Enum.into/2` 로 쉽게 채워넣을 수도 있다.

```elixir
defimpl Collectable, for: Box do
  def into(%Box{items: items}) do
    {items, fn
      acc, {:cont, v} -> [v | acc]
      acc, :done      -> %Box{items: Enum.reverse(acc)}
      _acc, :halt     -> :ok
    end}
  end
end

1..3
|> Enum.into(%Box{items: []})
# %Box{items: [1, 2, 3]}

```

이 패턴을 응용하면:

- 도메인 특화 컬렉션(예: Graph, Tree, RingBuffer 등)을 정의하고,
- `Enum.*` 전체를 **거의 공짜로** 가져올 수 있다.

---

## _10.2 Stream: 지연 계산하기_

`Stream`은 Enum과 달리, “**계산을 나중으로 미루는**” 지연 평가를 기반으로 한다.
이는 다음과 같은 상황에서 특히 유용하다.

- 매우 큰 데이터(대형 로그, DB dump, 대용량 CSV 등)
- 끝이 없는/언제 끝날지 모르는 입력(네트워크 스트림, 무한 시퀀스)
- 변환을 합쳐서 **한 번만 지나가도록** 만들고 싶을 때

---

### 기본 사용 — map/filter는 “계산 식”을 만든다

```elixir
s =
  1..10_000_000
  |> Stream.map(&(&1 * &1))
  |> Stream.filter(&(rem(&1, 2) == 0))

s
# 이 시점까지는 실제 계산이 전혀 수행되지 않는다.

s |> Enum.take(5)
# 이때 비로소, 앞에서 정의한 map/filter가 5개가 나올 때까지 실행된다.

```

- `Stream.map/2`, `Stream.filter/2` 는 **지연 변환자**(transducer)에 해당한다.
- 실제로 값을 만들고 소비하는 쪽은 **마지막의 Enum 함수**다.

이 구조 덕분에:

- 파이프라인에 여러 `Stream.*` 변환이 붙어도,
  실제 실행은 **단일 패스**로 이루어진다.
- 중간 리스트가 생성되지 않는다.

---

### 무한 스트림

지연 평가의 대표적인 응용은 **무한 스트림**이다.

```elixir
Stream.iterate(0, &(&1 + 1)) |> Enum.take(5)
# [0, 1, 2, 3, 4]

Stream.cycle([:a, :b]) |> Enum.take(5)
# [:a, :b, :a, :b, :a]

Stream.repeatedly(fn -> :rand.uniform() end) |> Enum.take(3)
# [0.123..., 0.87..., 0.45...] (매번 달라짐)

```

주의할 점:

- 무한 스트림에 `Enum.to_list/1` 같은 “전체 소비” 함수를 쓰면 **절대 끝나지 않는다.**
- 항상 `Enum.take/1`, `Enum.take_while/2` 등으로 **소비량을 제한**해야 한다.

---

### unfold — 상태 기계로 스트림 만들기

`Stream.unfold/2` 는 “상태 기계”를 스트림으로 만드는 도구다.

```elixir
fibs =
  Stream.unfold({0, 1}, fn {a, b} ->
    {a, {b, a + b}}
  end)

Enum.take(fibs, 6)
# [0, 1, 1, 2, 3, 5]

```

패턴:

```elixir
Stream.unfold(initial_state, fn state ->
  {yield_value, next_state}
end)
```

- 상태를 매 단계 업데이트하면서, 새로운 값을 “흘려보낸다”.
- 더 이상 내보낼 값이 없다면 `nil` 을 반환한다.

예: 페이지네이션 방식 API 결과를 스트림으로

```elixir
defmodule API do
  def fetch(page) do
    cond do
      page <= 3 -> {:ok, Enum.to_list(1..5), page + 1}
      true -> :done
    end
  end
end

items =
  1
  |> Stream.unfold(fn page ->
    case API.fetch(page) do
      {:ok, items, next} -> {items, next}
      :done              -> nil
    end
  end)
  |> Stream.flat_map(& &1)
  |> Enum.to_list()

# items: 1..5 세 번 반복 = 15개

```

---

### transform — map + filter + scan 을 한 번에

`Stream.transform/3` 은 가장 강력한 도구 중 하나다.
각 요소를 보면서:

- 새로운 요소들을 방출할 수도 있고,
- 방출하지 않을 수도 있고,
- 내부 상태를 업데이트할 수도 있다.

예: 누적합이 짝수일 때만 `(x, 누적합)` 을 방출

```elixir
s =
  1..10
  |> Stream.transform(0, fn x, acc ->
    acc2 = acc + x

    if rem(acc2, 2) == 0 do
      {[{x, acc2}], acc2}
    else
      {[], acc2}
    end
  end)

Enum.to_list(s)
# [{1, 1+?}, ...] 이런 식으로 누적합이 짝수인 시점만 나온다

```

형식:

```elixir
Stream.transform(enum, initial_acc, fn element, acc ->
  {emitted_items_list, new_acc}
end)
```

이 한 번의 패턴으로:

- map
- filter
- scan(누적)
- 조기 종료(원한다면 `{:halt, acc}` 패턴을 직접 구현)

까지 한 번에 표현할 수 있다.

---

### resource — 외부 리소스(파일/소켓)를 안전하게

파일/소켓처럼 “열고/사용하고/닫아야 하는 리소스”는
`Stream.resource/3` 에 매우 잘 어울린다.

```elixir
lines =
  Stream.resource(
    fn -> File.open!("big.log", [:read]) end,  # 시작: 리소스 열기
    fn io ->
      case IO.read(io, :line) do
        data when is_binary(data) ->
          {[String.trim_trailing(data)], io}

        :eof ->
          {:halt, io}
      end
    end,
    fn io -> File.close(io) end                 # 종료: 항상 닫기
  )

lines
|> Stream.reject(&(&1 == ""))
|> Stream.take(100)
|> Enum.to_list()
```

특징:

- **예외가 발생해도** `after` 콜백이 호출되어 파일이 닫힌다.
- “열기/사용/닫기” 를 스트림 라이프사이클과 결합할 수 있다.
- 로그 tailing, 대형 파일 처리, 외부 API 스트리밍 등에 매우 유용하다.

---

### chunk_every / chunk_by — 스트림에서도 배치 처리

Enum에 있던 `chunk_every/4`, `chunk_by/2` 는 Stream에도 있다.

예: 1000줄씩 묶어서 처리

```elixir
File.stream!("orders.csv")
|> Stream.drop(1)  # 헤더 제거
|> Stream.map(&String.trim_trailing/1)
|> Stream.map(&String.split(&1, ","))    # 셀 리스트
|> Stream.chunk_every(1000)              # 1000건 배치
|> Stream.each(&process_batch/1)
|> Stream.run()
```

주의할 점:

- `Stream.each/2` 는 사이드 이펙트를 수행하고, 값을 그대로 흘려보낸다.
- `Stream.run/1` 은 “값을 모두 버리되, 파이프라인을 실행만 한다”.
  즉, 소비자 역할이지만 결과는 없다.

배치 처리 패턴:

1. Stream으로 지연 변환을 쌓는다.
2. `chunk_every` 로 원하는 크기씩 묶는다.
3. `Stream.each` 로 각 배치에 대해 DB insert / 외부 API 등 사이드 이펙트를 수행.
4. 마지막에 `Stream.run` 으로 실제 실행.

---

### 파이프라인 예제 — 큰 텍스트에서 상위 단어 20개

이제 Stream을 활용한 실제 레시피를 보자.

```elixir
"war_and_peace.txt"
|> File.stream!()
|> Stream.flat_map(&String.split(&1, ~r/[^a-z0-9]+/i, trim: true))
|> Stream.map(&String.downcase/1)
|> Enum.frequencies()
|> Enum.sort_by(fn {_k, v} -> -v end)
|> Enum.take(20)
```

설명:

1. `File.stream!/1` : 줄 단위 지연 스트림
2. `Stream.flat_map/2` : 각 줄을 단어 리스트로 쪼개고 평탄화
3. `Stream.map/2` : 소문자로 정규화
4. `Enum.frequencies/1` : 단어 → 빈도 맵
5. `Enum.sort_by/2` : 빈도 내림차순 정렬
6. `Enum.take/2` : 상위 20개만 선택

데이터가 수백 MB라도, “줄 단위 + Stream 변환 + Enum 집계” 구조이면
메모리 사용량을 비교적 안정적으로 유지할 수 있다.

---

### Stream vs Enum — 언제 무엇을 쓸까?

두 모듈을 쓰는 기준을 표로 다시 정리해보자.

| 상황 | 권장 선택 |
|---|---|
| 데이터가 작고, 변환이 간단 | **Enum** (가독성, 단순성) |
| 데이터가 매우 크거나, 끝을 모름 | **Stream** (지연 평가, 메모리 절감) |
| 변환 단계가 많고, 중간 리스트가 걱정 | **Stream** 또는 단일 `Enum.reduce` 융합 |
| 무한 시퀀스 | **Stream** (`iterate`, `cycle`, `unfold`, `repeatedly`) |
| IO/파일/소켓을 줄 단위/레코드 단위로 처리 | **Stream.resource/File.stream!** |
| 단발성 계산, 작은 컬렉션 | 그냥 **Enum 파이프라인**으로 충분 |

실전에서는:

1. 먼저 Enum으로 간단하고 명확하게 작성한다.
2. 실제 프로파일링을 해본다.
3. 성능/메모리 문제가 드러난 부분만 Stream/융합 패턴으로 바꾼다.

---

### 디버깅 팁 — “왜 출력이 안 보이지?”

Stream은 지연 평가기 때문에, 아래 코드는 **아무 일도 하지 않는다.**

```elixir
1..5
|> Stream.map(&IO.inspect(&1, label: "dbg"))
# 여기까지는 “계산 식”만 만들어졌을 뿐, 실행되지 않음

```

실제로 보려면 **소비자**가 필요하다.

```elixir
1..5
|> Stream.map(&IO.inspect(&1, label: "dbg"))
|> Enum.to_list()
```

이제 콘솔에 dbg 라벨이 찍힌다.

디버깅 패턴:

- Stream 파이프라인 중간에 `Stream.each(&IO.inspect/1)` 를 끼우고,
  마지막에 `Enum.take/1` 또는 `Stream.run/1` 을 붙인다.

---

### 성능/메모리 모델(개략)

Stream과 Enum의 메모리/시간 관계를 비교해보자.

- Enum(엄격):
  - 각 변환마다 새 컬렉션을 만든다.
  - 메모리: 중간 컬렉션 크기 합.
  - 시간: 각 단계 순회 비용 합.

- Stream(지연):
  - 변환을 쌓아두고, 마지막 소비에서 한 번에 실행.
  - 메모리: 중간 컬렉션 거의 없음.
  - 시간: 각 원소가 파이프라인 전체를 통과하는 비용.

수식으로 요약하면:

$$
M_{\text{Enum}} \gg M_{\text{Stream}}, \qquad
T_{\text{Enum}} \approx T_{\text{Stream}} \pm \varepsilon
$$

여기서 \(\varepsilon\) 은 함수 호출 오버헤드, 캐시 효과 등의 차이이다.

- 작은 데이터에서는 차이가 거의 없다.
- 매우 큰 데이터/IO-heavy 상황에서는 Stream이 **질적으로 우세**하다.

---

## 고급 레시피 모음

이제 Enum/Stream을 섞어서 쓰는 좀 더 복잡한 실전 레시피를 살펴보자.

### — Stream으로

문제: `[1,2,3,4,5,6]` 에서 길이 3의 슬라이딩 윈도우를 만들고 싶다.

```elixir
defmodule Window do
  def windows(enum, k) when k > 0 do
    enum
    |> Stream.transform([], fn x, acc ->
      acc2 = [x | acc] |> Enum.take(k)

      if length(acc2) == k do
        {[Enum.reverse(acc2)], acc2}
      else
        {[], acc2}
      end
    end)
  end
end

1..6 |> Window.windows(3) |> Enum.to_list()
# [[1,2,3],[2,3,4],[3,4,5],[4,5,6]]

```

- 상태는 “최근 본 최대 k개의 요소” 리스트.
- 길이가 k에 도달하면, 그 윈도우를 방출.

조금 더 효율적으로 만들려면 `:queue` 를 써서 길이에 상관없이 O(1)로 관리할 수도 있다.

---

### API 페이지네이션 스트림

앞에서 언급한 `Stream.unfold` 예제를 일반화해 보자.

```elixir
defmodule PagedAPI do
  def stream(fetch_fun, init_page) do
    Stream.unfold(init_page, fn page ->
      case fetch_fun.(page) do
        {:ok, items, next} -> {items, next}
        :done              -> nil
      end
    end)
    |> Stream.flat_map(& &1)
  end
end

fetch = fn page ->
  if page <= 5 do
    {:ok, Enum.to_list(1..3), page + 1}
  else
    :done
  end
end

PagedAPI.stream(fetch, 1)
|> Stream.each(&IO.inspect(&1))
|> Stream.run()
```

- 외부 API가 “페이지 단위”로 결과를 주더라도,
  내부에서는 “무한 리스트처럼 보이는” 스트림으로 다룰 수 있다.
- 필요하면 `Enum.take/1` 로 일부만 소비할 수도 있다.

---

### 대형 로그를 시간대별 그룹 집계

예를 들어, 웹 서버 로그에서 5분 단위 버킷으로 상태 코드별 카운트를 내고 싶다고 하자.

```elixir
defmodule LogAgg do
  def bucket_5m(%DateTime{} = ts) do
    minute = div(ts.minute, 5) * 5
    %{ts | minute: minute, second: 0}
  end

  def parse_line(line) do
    # 여기서는 예시로 단순화
    # 실제로는 정규식/파서로 DateTime과 status를 뽑는다.
    case String.split(line, " ") do
      [time_s, status_s | _] ->
        # time_s -> DateTime.parse 등
        {:ok, %{ts: parse_time(time_s), status: String.to_integer(status_s)}}

      _ ->
        :error
    end
  end

  defp parse_time(_s) do
    # 예시용: 항상 동일 시간이라고 가정
    DateTime.utc_now()
  end

  def agg_by_bucket(path) do
    path
    |> File.stream!()
    |> Stream.map(&String.trim_trailing/1)
    |> Stream.filter(&(&1 != ""))
    |> Stream.map(&parse_line/1)
    |> Stream.filter(&match?({:ok, _}, &1))
    |> Stream.map(fn {:ok, m} -> m end)
    |> Stream.map(fn m -> Map.put(m, :bucket, bucket_5m(m.ts)) end)
    |> Enum.group_by(& &1.bucket, & &1.status)
    |> Enum.map(fn {bucket, statuses} ->
      {bucket, Enum.frequencies(statuses)}
    end)
    |> Enum.sort_by(&elem(&1, 0))
  end
end
```

- IO는 Stream으로, 마지막 집계는 Enum으로.
- 메모리를 크게 쓰지 않고도 전체 로그에 대해 통계를 낼 수 있다.

---

### 테스트 & 문서화 팁 (ExUnit + doctest)

Enum/Stream 파이프라인은 **함수형**이라 테스트하기 쉽다.
도큐먼트와 테스트를 겸하는 doctest를 예로 들면:

```elixir
defmodule Pipelines do
  @doc """
  정수 열에서 짝수의 제곱 합을 구한다.

      iex> Pipelines.sum_even_squares(1..5)
      20

      iex> Pipelines.sum_even_squares([])
      0
  """
  def sum_even_squares(enum) do
    enum
    |> Enum.reduce(0, fn x, acc ->
      y = x * x
      if rem(y, 2) == 0, do: acc + y, else: acc
    end)
  end
end
```

`test/pipelines_test.exs`:

```elixir
defmodule PipelinesTest do
  use ExUnit.Case, async: true
  doctest Pipelines
end
```

- 문서 예제가 실제 테스트로 실행된다.
- 파이프라인 예시를 **살아 있는 스펙**으로 유지할 수 있다.

---

## 흔한 함정 → 교정 요약

1) **맵 열거 순서 신뢰**
   - 증상: 환경/버전에 따라 결과 순서가 뒤죽박죽.
   - 교정: 결과 순서가 중요하다면 `Enum.sort_by/2` 로 명시 정렬하거나, 리스트/키워드를 사용.

2) **`Enum.map |> Enum.map` 과도한 중간 리스트**
   - 증상: CPU/메모리 낭비.
   - 교정: 하나의 `Enum.reduce/3` 또는 `Stream.transform/3` 융합 패턴 사용(핫 루프에 한정).

3) **지연 파이프라인에 소비자 없음**
   - 증상: 코드가 “실행되는 것처럼 보이지만 실제로 아무 일도 안 일어남.”
   - 교정: 마지막에 `Enum.*` 또는 `Stream.run/1` 같은 소비자를 반드시 붙인다.

4) **무한 스트림 전체 소비**
   - 증상: 프로그램이 멈추거나 메모리 폭주.
   - 교정: `Enum.take/2`, `Enum.take_while/2` 등으로 항상 소비량을 제한.

5) **문자열 결합의 누적 복사**
   - 증상: 큰 텍스트/HTML/CSV 생성에서 예기치 않게 느려짐.
   - 교정: iodata 패턴(`Enum.map` → iolist → `iolist_to_binary`)을 사용.

---

## 연습 문제

1) `Stream.transform/3` 만으로 **짝수만의 누적합을 방출**하는 스트림을 구현하라.
   입력: `1..n`
   출력: `[{x, sum}]` 리스트 (sum은 현재까지의 누적합, sum이 짝수일 때만 방출).

2) `File.stream!` 로 큰 CSV를 읽어, 헤더를 키로 하는 맵 리스트로 변환한 뒤,
   특정 컬럼(예: `"country"`) 기준으로 `Enum.group_by/2` 하는 함수를 작성하라.

3) API 페이지네이션(페이지 수 = 1000)을 `Stream.unfold/2` 로 구성한 뒤,
   각 페이지에서 받은 아이템을 `Stream.each/2` 로 “저장(모의)” 하고,
   마지막에 `Stream.run/1` 로 실행하라.

4) `windows(enum, k, step)` 을 구현하라.
   - `step = 1` 이면 완전 슬라이딩 윈도우.
   - `step = k` 이면 비겹치는 윈도우.
   - `step > k` 인 경우, 중간을 건너뛰는 윈도우.

5) 긴 텍스트에서 **상위 20개 2-gram(단어 두 개씩 묶은 n-gram)** 을 Stream으로 계산하라.
   - `File.stream!` → `Stream.flat_map` 으로 단어 스트림 생성
   - `Stream.transform` 으로 `(이전 단어, 현재 단어)` 페어 스트림 생성
   - `Enum.frequencies/1` → `Enum.sort_by/2` → `Enum.take/2`

---

## 마무리

- **Enum** 은 엘릭서의 기본 컬렉션 처리 도구다.
  - 리스트/맵/MapSet/범위/파일 스트림 등, 대부분의 컬렉션을
    **동일한 스타일**로 다룰 수 있게 해준다.
  - `map / filter / reduce` 를 중심으로,
    `group_by / frequencies / chunk_every / reduce_while` 같은 함수로
    흔한 데이터 처리 패턴을 간결하게 표현할 수 있다.

- **Stream** 은 Enum의 “지연 평가 버전” 이자,
  - 무한 시퀀스,
  - 대형 파일/IO,
  - 변환 융합,
  - 리소스 관리
  에 최적화된 도구다.

- 실전에서는:
  - 먼저 **읽기 쉬운 Enum 파이프라인**으로 작성한다.
  - 필요시, 특히 여럿이 공유하는 라이브러리/핵심 경로에서는
    **Stream/transform/resource/unfold** 를 사용해 성능과 메모리를 다듬는다.
  - Enum과 Stream은 서로 배타적인 것이 아니라,
    **입력은 Stream, 마지막 집계는 Enum** 같은 조합으로 함께 쓰는 것이 자연스럽다.

이 장을 바탕으로, 프로젝트 곳곳에 흩어져 있는 반복/루프 로직을
차근차근 Enum/Stream 파이프라인으로 치환해 보면,
코드가 훨씬 더 선언적이고, 테스트 가능하며, 성능 튜닝 포인트도 명확해지는 것을 느낄 수 있을 것이다.
