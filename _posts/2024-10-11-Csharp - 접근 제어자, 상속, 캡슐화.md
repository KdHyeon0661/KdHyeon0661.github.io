---
layout: post
title: C# - 접근 제어자, 상속, 캡슐화
date: 2024-10-11 19:20:23 +0900
category: Csharp
---
# C# 접근 제어자와 클래스 관계: 캡슐화와 설계의 기술

C#에서 접근 제어자와 클래스 간의 관계는 단순한 문법적 기능을 넘어, 소프트웨어 설계의 핵심 원칙을 구현하는 도구입니다. 이들은 코드의 구조를 정의하고, 모듈 간의 의존성을 관리하며, 소프트웨어의 유지보수성과 확장성을 결정합니다.

## 접근 제어자: 가시성의 미세 조정

접근 제어자는 클래스의 멤버(필드, 속성, 메서드)에 대한 접근 권한을 정의합니다. 각 제어자는 특정한 가시성 범위를 가지며, 이를 올바르게 사용하는 것이 견고한 소프트웨어 설계의 첫걸음입니다.

### 다양한 접근 제어자의 실전 적용

```csharp
// 공개 API: 외부에서 자유롭게 접근 가능
public class BankAccount
{
    // 공개 속성: 읽기 전용으로 노출
    public decimal Balance => _balance;
    
    // 내부 필드: 완전히 은닉
    private decimal _balance;
    
    // 어셈블리 내부에서만 접근 가능 (동일 프로젝트)
    internal string InternalId { get; }
    
    // 파생 클래스에서 접근 가능
    protected DateTime CreatedAt { get; }
    
    // 어셈블리 내부 또는 파생 클래스에서 접근 가능
    protected internal string AccountType { get; }
    
    // 동일 어셈블리의 파생 클래스에서만 접근 가능
    private protected string InternalCode { get; }
    
    public BankAccount(string internalId)
    {
        InternalId = internalId;
        CreatedAt = DateTime.UtcNow;
        _balance = 0;
    }
    
    // 공개 메서드: 외부에서 호출 가능
    public void Deposit(decimal amount)
    {
        ValidateAmount(amount);
        _balance += amount;
        RecordTransaction("입금", amount);
    }
    
    // 내부 메서드: 같은 클래스 내에서만 호출 가능
    private void ValidateAmount(decimal amount)
    {
        if (amount <= 0)
            throw new ArgumentException("금액은 0보다 커야 합니다.");
    }
    
    // 보호된 메서드: 파생 클래스에서 재정의 가능
    protected virtual void RecordTransaction(string type, decimal amount)
    {
        // 기본 트랜잭션 기록 로직
        Console.WriteLine($"{DateTime.Now}: {type} {amount:C}");
    }
}
```

각 접근 제어자는 특정한 설계 의도를 표현합니다:
- `public`: 컴포넌트의 공식 인터페이스, 외부 의존성 생성
- `private`: 구현 세부사항, 내부 논리 캡슐화
- `protected`: 확장 포인트, 템플릿 메서드 패턴
- `internal`: 모듈 내부 협력, 공개 API 오염 방지

## 캡슐화: 상태 보호와 불변성 유지

캡슐화는 객체의 내부 상태를 보호하고, 유효한 상태만을 허용하는 메커니즘입니다. 단순히 필드를 숨기는 것을 넘어, 객체의 불변 조건을 보장하는 설계 철학입니다.

### 불변 조건을 보장하는 캡슐화 패턴

```csharp
public class Temperature
{
    // 절대온도 (켈빈) - 내부 표현
    private double _kelvin;
    
    // 공개 인터페이스: 섭씨와 화씨로만 접근 허용
    public double Celsius
    {
        get => _kelvin - 273.15;
        set
        {
            if (value < -273.15)
                throw new ArgumentOutOfRangeException(nameof(value), 
                    "섭씨 -273.15도 이하는 불가능합니다.");
            _kelvin = value + 273.15;
        }
    }
    
    public double Fahrenheit
    {
        get => (_kelvin - 273.15) * 9/5 + 32;
        set
        {
            // 화씨를 통해 설정할 때도 동일한 검증 수행
            Celsius = (value - 32) * 5/9;
        }
    }
    
    // 팩토리 메서드 패턴: 유효한 객체만 생성
    public static Temperature FromCelsius(double celsius)
    {
        var temp = new Temperature();
        temp.Celsius = celsius; // 속성 setter가 검증 수행
        return temp;
    }
    
    public static Temperature FromFahrenheit(double fahrenheit)
    {
        var temp = new Temperature();
        temp.Fahrenheit = fahrenheit; // 속성 setter가 검증 수행
        return temp;
    }
    
    // 비공개 생성자: 직접 생성 제한
    private Temperature()
    {
        _kelvin = 273.15; // 기본값: 0°C
    }
}
```

이 설계의 장점은 명확합니다:
1. **불변 조건 보장**: 절대영도 이하의 온도를 방지
2. **표현력**: 여러 온도 체계를 자연스럽게 지원
3. **유효성**: 팩토리 메서드를 통해서만 객체 생성
4. **변환 로직 중앙화**: 모든 온도 변환이 한 곳에서 관리

## 상속 vs 컴포지션: 재사용의 두 가지 길

코드 재사용은 객체지향 프로그래밍의 주요 목표 중 하나입니다. C#은 상속과 컴포지션이라는 두 가지 접근법을 제공하며, 각각의 적절한 사용 사례를 이해하는 것이 중요합니다.

### 상속: "is-a" 관계와 다형성

```csharp
// 기본 클래스: 공통 인터페이스 정의
public abstract class PaymentMethod
{
    public string Id { get; }
    public decimal Balance { get; protected set; }
    
    protected PaymentMethod(string id)
    {
        Id = id;
    }
    
    // 추상 메서드: 파생 클래스에서 구현 필수
    public abstract bool ProcessPayment(decimal amount);
    
    // 가상 메서드: 기본 구현 제공, 필요시 재정의 가능
    public virtual string GetDescription()
    {
        return $"결제수단 ID: {Id}, 잔액: {Balance:C}";
    }
    
    // 봉인 메서드: 더 이상의 재정의 방지
    public sealed override string ToString()
    {
        return GetDescription();
    }
}

// 구체 클래스: 특화된 구현
public class CreditCard : PaymentMethod
{
    public string CardNumber { get; }
    public DateTime ExpiryDate { get; }
    
    public CreditCard(string id, string cardNumber, DateTime expiryDate) 
        : base(id)
    {
        CardNumber = MaskCardNumber(cardNumber);
        ExpiryDate = expiryDate;
    }
    
    public override bool ProcessPayment(decimal amount)
    {
        if (amount <= 0 || amount > 10000) // 신용카드 제한
            return false;
            
        // 실제 결제 처리 로직 (실제 구현에서는 외부 API 호출)
        Console.WriteLine($"신용카드로 {amount:C} 결제 처리");
        return true;
    }
    
    public override string GetDescription()
    {
        return $"{base.GetDescription()}, 카드: {CardNumber}, 만료: {ExpiryDate:yyyy-MM}";
    }
    
    private static string MaskCardNumber(string cardNumber)
    {
        if (cardNumber.Length < 4)
            return "****";
            
        return new string('*', cardNumber.Length - 4) + cardNumber[^4..];
    }
}

// 또 다른 구체 클래스
public class BankTransfer : PaymentMethod
{
    public string BankName { get; }
    public string AccountNumber { get; }
    
    public BankTransfer(string id, string bankName, string accountNumber)
        : base(id)
    {
        BankName = bankName;
        AccountNumber = accountNumber;
    }
    
    public override bool ProcessPayment(decimal amount)
    {
        if (amount <= 0 || amount > Balance)
            return false;
            
        Balance -= amount;
        Console.WriteLine($"은행이체로 {amount:C} 처리, 잔액: {Balance:C}");
        return true;
    }
}
```

상속은 강력한 도구이지만, 남용하면 취약한 기반 클래스 문제나 다이아몬드 문제를 초래할 수 있습니다. "is-a" 관계가 명확하고, 다형성이 필요한 경우에만 사용해야 합니다.

### 컴포지션: "has-a" 관계와 유연성

```csharp
// 컴포지션을 통한 재사용: 더 유연하고 테스트하기 쉬움
public class OrderProcessor
{
    // 의존성 주입: 외부에서 제공
    private readonly IPaymentGateway _paymentGateway;
    private readonly IInventoryService _inventoryService;
    private readonly INotificationService _notificationService;
    
    public OrderProcessor(
        IPaymentGateway paymentGateway,
        IInventoryService inventoryService,
        INotificationService notificationService)
    {
        _paymentGateway = paymentGateway ?? 
            throw new ArgumentNullException(nameof(paymentGateway));
        _inventoryService = inventoryService ?? 
            throw new ArgumentNullException(nameof(inventoryService));
        _notificationService = notificationService ?? 
            throw new ArgumentNullException(nameof(notificationService));
    }
    
    public async Task<OrderResult> ProcessOrderAsync(Order order)
    {
        // 재고 확인
        if (!await _inventoryService.CheckAvailabilityAsync(order.Items))
        {
            return OrderResult.Failed("일부 상품의 재고가 부족합니다.");
        }
        
        // 결제 처리
        var paymentResult = await _paymentGateway.ProcessPaymentAsync(
            order.TotalAmount, order.PaymentMethod);
            
        if (!paymentResult.Success)
        {
            return OrderResult.Failed($"결제 실패: {paymentResult.ErrorMessage}");
        }
        
        // 주문 확정
        await _inventoryService.ReserveItemsAsync(order.Items);
        
        // 알림 발송
        await _notificationService.SendOrderConfirmationAsync(order);
        
        return OrderResult.Success(paymentResult.TransactionId);
    }
}

// 인터페이스: 느슨한 결합을 위한 계약
public interface IPaymentGateway
{
    Task<PaymentResult> ProcessPaymentAsync(decimal amount, string paymentMethod);
}

public interface IInventoryService
{
    Task<bool> CheckAvailabilityAsync(IEnumerable<OrderItem> items);
    Task ReserveItemsAsync(IEnumerable<OrderItem> items);
}

public interface INotificationService
{
    Task SendOrderConfirmationAsync(Order order);
}
```

컴포지션의 장점:
1. **유연성**: 구성 요소를 쉽게 교체 가능
2. **테스트 용이성**: 모의 객체를 사용한 단위 테스트 가능
3. **단일 책임 원칙**: 각 클래스가 한 가지 일만 담당
4. **의존성 역전**: 추상화에 의존, 구체화에 의존하지 않음

## 어셈블리 경계와 내부 가시성

대규모 프로젝트에서는 여러 어셈블리(프로젝트)로 코드를 분리하는 것이 일반적입니다. 이때 `internal` 접근 제어자는 모듈화를 강화하는 중요한 도구가 됩니다.

### 내부 구현의 보호와 테스트

```csharp
// 라이브러리 프로젝트 (MyLibrary.csproj)
namespace MyLibrary;

// 공개 API: 외부 사용자를 위한 인터페이스
public interface IDataProcessor
{
    Task<ProcessResult> ProcessAsync(string input);
}

// 내부 구현: 라이브러리 내부에서만 사용
internal class DataProcessor : IDataProcessor
{
    private readonly IDataValidator _validator;
    private readonly IDataTransformer _transformer;
    
    internal DataProcessor(IDataValidator validator, IDataTransformer transformer)
    {
        _validator = validator;
        _transformer = transformer;
    }
    
    public async Task<ProcessResult> ProcessAsync(string input)
    {
        var validationResult = await _validator.ValidateAsync(input);
        if (!validationResult.IsValid)
        {
            return ProcessResult.Failed(validationResult.Errors);
        }
        
        var transformed = await _transformer.TransformAsync(input);
        return ProcessResult.Success(transformed);
    }
}

// 내부 도구 클래스
internal static class InternalHelpers
{
    internal static string SanitizeInput(string input)
    {
        // 내부 유틸리티 메서드
        return input.Trim().Replace("\r\n", "\n");
    }
}

// 공개 팩토리: 내부 구현을 숨기면서 인스턴스 생성
public static class DataProcessorFactory
{
    public static IDataProcessor CreateProcessor()
    {
        // 내부 타입을 사용하지만 외부에는 IDataProcessor만 노출
        var validator = new DataValidator();
        var transformer = new DataTransformer();
        return new DataProcessor(validator, transformer);
    }
}
```

```csharp
// 테스트 프로젝트 (MyLibrary.Tests.csproj)
// AssemblyInfo.cs 또는 .csproj에 다음 추가:
// [assembly: InternalsVisibleTo("MyLibrary.Tests")]

namespace MyLibrary.Tests;

[TestClass]
public class DataProcessorTests
{
    [TestMethod]
    public void InternalHelpers_SanitizeInput_RemovesExtraWhitespace()
    {
        // InternalsVisibleTo 덕분에 internal 멤버 테스트 가능
        string input = "  Hello\r\nWorld  ";
        string result = InternalHelpers.SanitizeInput(input);
        
        Assert.AreEqual("Hello\nWorld", result);
    }
    
    [TestMethod]
    public void DataProcessor_ProcessAsync_ValidatesInput()
    {
        // 내부 구현에 대한 단위 테스트
        var validator = new Mock<IDataValidator>();
        var transformer = new Mock<IDataTransformer>();
        
        var processor = new DataProcessor(validator.Object, transformer.Object);
        // 테스트 계속...
    }
}
```

이 접근법의 장점:
1. **깔끔한 공개 API**: 외부 사용자에게 필요한 것만 노출
2. **구현 자유도**: 내부 구현 변경이 외부에 영향 미치지 않음
3. **테스트 가능성**: 내부 로직도 철저히 테스트 가능
4. **보안**: 민감한 로직을 외부로부터 보호

## 실전 설계 패턴과 원칙

### 1. 의도 드러내기 네이밍과 접근 제어

```csharp
public class DocumentManager
{
    // 의도: 이 목록은 내부 구현의 일부이며 직접 수정되면 안 됨
    private readonly List<Document> _documents = new();
    
    // 의도: 읽기 전용 뷰만 제공
    public IReadOnlyList<Document> Documents => _documents.AsReadOnly();
    
    // 의도: 문서 추가는 이 메서드를 통해서만
    public void AddDocument(Document document)
    {
        if (document == null)
            throw new ArgumentNullException(nameof(document));
            
        ValidateDocument(document);
        _documents.Add(document);
        OnDocumentAdded(document);
    }
    
    // 의도: 검증 로직은 내부적으로만 사용
    private void ValidateDocument(Document document)
    {
        if (string.IsNullOrWhiteSpace(document.Title))
            throw new ArgumentException("문서 제목은 필수입니다.");
            
        if (document.Content.Length == 0)
            throw new ArgumentException("문서 내용은 비어 있을 수 없습니다.");
    }
    
    // 의도: 이벤트 처리를 위한 확장 포인트
    protected virtual void OnDocumentAdded(Document document)
    {
        // 기본 구현: 아무 것도 하지 않음
        // 파생 클래스에서 재정의하여 특정 동작 추가 가능
    }
}
```

### 2. 불변 객체 패턴

```csharp
// 불변 객체: 생성 후 상태 변경 불가
public sealed class ImmutablePerson
{
    // 모든 필드는 읽기 전용
    public string FirstName { get; }
    public string LastName { get; }
    public DateTime BirthDate { get; }
    
    // 계산된 속성
    public int Age
    {
        get
        {
            var today = DateTime.Today;
            var age = today.Year - BirthDate.Year;
            
            // 생일이 지나지 않았으면 한 살 덜어줌
            if (BirthDate.Date > today.AddYears(-age))
                age--;
                
            return age;
        }
    }
    
    public string FullName => $"{FirstName} {LastName}";
    
    // 생성자에서 모든 상태 초기화
    public ImmutablePerson(string firstName, string lastName, DateTime birthDate)
    {
        FirstName = firstName ?? throw new ArgumentNullException(nameof(firstName));
        LastName = lastName ?? throw new ArgumentNullException(nameof(lastName));
        
        if (birthDate > DateTime.Today)
            throw new ArgumentOutOfRangeException(nameof(birthDate), 
                "생년월일은 미래일 수 없습니다.");
                
        BirthDate = birthDate;
    }
    
    // With- 메서드 패턴: 새 객체 생성으로 "변경"
    public ImmutablePerson WithFirstName(string newFirstName)
    {
        return new ImmutablePerson(newFirstName, LastName, BirthDate);
    }
    
    public ImmutablePerson WithLastName(string newLastName)
    {
        return new ImmutablePerson(FirstName, newLastName, BirthDate);
    }
    
    // 값 기반 동등성 비교
    public override bool Equals(object? obj)
    {
        return obj is ImmutablePerson other &&
               FirstName == other.FirstName &&
               LastName == other.LastName &&
               BirthDate == other.BirthDate;
    }
    
    public override int GetHashCode()
    {
        return HashCode.Combine(FirstName, LastName, BirthDate);
    }
}
```

### 3. 전략 패턴과 컴포지션

```csharp
// 전략 인터페이스
public interface ISortStrategy<T>
{
    void Sort(List<T> items);
}

// 다양한 정렬 전략
public class QuickSortStrategy<T> : ISortStrategy<T>
    where T : IComparable<T>
{
    public void Sort(List<T> items)
    {
        // 퀵 정렬 구현
        QuickSort(items, 0, items.Count - 1);
    }
    
    private void QuickSort(List<T> items, int left, int right)
    {
        if (left < right)
        {
            int pivotIndex = Partition(items, left, right);
            QuickSort(items, left, pivotIndex - 1);
            QuickSort(items, pivotIndex + 1, right);
        }
    }
    
    private int Partition(List<T> items, int left, int right) { /* 구현 */ }
}

public class MergeSortStrategy<T> : ISortStrategy<T>
    where T : IComparable<T>
{
    public void Sort(List<T> items)
    {
        // 병합 정렬 구현
        if (items.Count <= 1) return;
        
        var sorted = MergeSort(items);
        items.Clear();
        items.AddRange(sorted);
    }
    
    private List<T> MergeSort(List<T> items) { /* 구현 */ }
}

// 컨텍스트: 전략 사용
public class Sorter<T>
{
    private ISortStrategy<T> _strategy;
    
    public Sorter(ISortStrategy<T> strategy)
    {
        _strategy = strategy ?? throw new ArgumentNullException(nameof(strategy));
    }
    
    // 전략 동적 변경
    public void SetStrategy(ISortStrategy<T> newStrategy)
    {
        _strategy = newStrategy ?? throw new ArgumentNullException(nameof(newStrategy));
    }
    
    public void Sort(List<T> items)
    {
        if (items == null)
            throw new ArgumentNullException(nameof(items));
            
        _strategy.Sort(items);
    }
}
```

## 결론

C#의 접근 제어자와 클래스 관계 설계는 단순한 코딩 규칙을 넘어, 소프트웨어 아키텍처의 핵심 요소입니다. 효과적인 캡슐화는 코드의 안정성을 높이고, 적절한 상속과 컴포지션 선택은 시스템의 유연성을 보장합니다.

가장 중요한 원칙은 "필요한 만큼만 공개하라"는 것입니다. 모든 것을 `public`으로 만드는 것은 쉽지만, 이는 결합도를 높이고 유지보수를 어렵게 만듭니다. 대신 신중하게 접근 수준을 설계하고, 인터페이스를 통해 추상화하며, 내부 구현을 보호해야 합니다.

또한 상속보다는 컴포지션을 우선시하는 것이 현대 객체지향 설계의 트렌드입니다. 상속은 강력한 "is-a" 관계가 명확할 때만 사용하고, 그 외의 경우에는 인터페이스와 컴포지션을 통해 더 유연하고 테스트 가능한 설계를 구축해야 합니다.

이러한 원칙들을 실제 프로젝트에 적용할 때, 팀의 코딩 표준과 프로젝트의 특정 요구사항을 고려하는 것이 중요합니다. 기술적 완벽함보다는 실용성과 유지보수성 사이의 균형을 찾는 것이 장기적인 성공의 열쇠입니다.