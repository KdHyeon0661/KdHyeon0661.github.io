---
layout: post
title: C# - 접근 제어자, 상속, 캡슐화
date: 2024-10-11 19:20:23 +0900
category: Csharp
---
# 접근 제어자와 클래스 간 관계

## 0) 큰 그림 — 무엇을 왜 제어하나?

- **캡슐화**: 내부 구현을 숨기고 **의미 있는 계약(Contract)**만 노출.
- **접근 제어자**: 타입/멤버의 **가시성 범위**를 명시.
- **상속**: 코드 재사용 + 다형성. (필요할 때만! 우선 **컴포지션** 고려)
- **어셈블리 경계**: `internal`은 **같은 어셈블리**에서만. 테스트/플러그인에는 `InternalsVisibleTo`.

> 원칙: “**필요한 만큼만 공개(least privilege)**”, “**불변 조건(invariants)**을 깨뜨릴 수 있는 경로를 최소화”.

---

## 1) 접근 제어자 (Access Modifiers)

### 1.1 한눈 요약표

| 키워드 | 타입에 적용 | 멤버에 적용 | 접근 가능 범위 |
|---|---|---|---|
| `public` | O | O | 어디서나 |
| `private` | (중첩 타입에 한해) | O | **동일 타입 내부** |
| `protected` | (중첩 타입에 한해) | O | **해당 타입 + 파생 타입** |
| `internal` | O | O | **동일 어셈블리** |
| `protected internal` | (중첩 타입에 한해) | O | **동일 어셈블리 전체** ∪ **다른 어셈블리의 파생 타입** |
| `private protected` | (중첩 타입에 한해) | O | **동일 어셈블리 내의 파생 타입** |
| `file` | O (C# 11+) | X | **같은 소스 파일 내부**에서만(타입 가시성) |

> **최상위(Top-level) 타입**은 `public`, `internal`, `file`만 허용. `private/protected`는 **중첩 타입**에만 사용.

### 1.2 예시로 감각 잡기

```csharp
// 파일 스코프 네임스페이스(권장)
namespace Demo;

// C# 11+: 같은 파일에서만 보이게 하는 file-로컬 타입
file class FileOnlyHelper
{
    internal static string Banner => "Hi";
}

public class Person
{
    // 외부 노출(읽기만), 내부 수정만 허용
    public string Name { get; private set; }

    // 어셈블리 내부에서만 접근
    internal int InternalId { get; set; }

    // 파생형에서만(다른 어셈블리라도) 접근
    protected string? SecretNote { get; set; }

    // 같은 어셈블리 또는(외부라도) 파생형 → 접근 가능
    protected internal string SharedForFamily { get; set; } = "";

    // 같은 어셈블리의 파생형에서만 접근
    private protected string LocalFamilyOnly { get; set; } = "";

    private int _age; // 완전 비공개

    public Person(string name, int age)
    {
        Name = name;
        _age = age;
    }
}
```

---

## 2) 캡슐화 (Encapsulation)

### 2.1 필드 은닉 + 속성/메서드로 제약

```csharp
class Account
{
    private decimal _balance;

    public decimal Balance => _balance; // 외부는 읽기만

    public void Deposit(decimal amount)
    {
        if (amount <= 0) throw new ArgumentOutOfRangeException(nameof(amount));
        _balance += amount;
    }

    public void Withdraw(decimal amount)
    {
        if (amount <= 0) throw new ArgumentOutOfRangeException(nameof(amount));
        if (amount > _balance) throw new InvalidOperationException("잔액 부족");
        _balance -= amount;
    }
}
```

- 외부에서 **직접** 잔액을 바꿀 수 없고, **불변 조건**을 메서드가 보장.

### 2.2 속성의 접근 제한 분리

```csharp
class Article
{
    public string Title { get; private set; } // 외부 읽기, 내부만 쓰기
    public int    Views { get; private set; }

    public Article(string title) => Title = title;

    public void Rename(string title)
    {
        if (string.IsNullOrWhiteSpace(title)) throw new ArgumentException();
        Title = title;
    }

    public void Hit() => Views++;
}
```

> **핵심**: 쓰기 경로를 최소화 → 상태 공간 축소.

### 2.3 불변/초기화 전용

```csharp
class User
{
    public required string Id { get; init; }     // C# 11: 생성 시 반드시 채워야
    public string Name       { get; init; } = ""; // 생성/초기화 시에만 설정 가능
}
```

---

## 3) 클래스 간 관계 — 상속 vs 컴포지션

### 3.1 기본 상속

```csharp
class Animal
{
    public void Eat() => Console.WriteLine("먹는 중...");
}

class Dog : Animal
{
    public void Bark() => Console.WriteLine("멍멍!");
}
```

사용:

```csharp
var d = new Dog();
d.Eat();  // 부모 기능 재사용
d.Bark(); // 자식 고유 기능
```

### 3.2 언제 상속? 언제 컴포지션?

- **상속**: “진짜 **is-a** 관계”이고, **다형적 대체(LSP)**가 자연스러울 때.
- **컴포지션**: 코드 재사용이 목적일 뿐이면 **has-a**로 위임이 대부분 더 안전.

```csharp
// 컴포지션 예: 로거를 합성해서 사용
class Service
{
    private readonly ILogger _log;
    public Service(ILogger log) => _log = log;
    public void Work() { _log.Info("start"); /*...*/ }
}
```

---

## 4) 메서드 오버라이딩과 숨김(new)

### 4.1 가상/재정의/봉인

```csharp
class Shape
{
    public virtual double Area() => 0.0; // 가상
}

class Circle : Shape
{
    public double R { get; }
    public Circle(double r) => R = r;

    public override double Area() => Math.PI * R * R; // 재정의
}

class NoMoreOverrideCircle : Circle
{
    public NoMoreOverrideCircle(double r) : base(r) { }

    public sealed override double Area() => base.Area(); // 여기서 더 이상 오버라이드 금지
}
```

### 4.2 메서드 숨김(new) — 다형성 아님!

```csharp
class Foo
{
    public void Print() => Console.WriteLine("Foo");
}

class Bar : Foo
{
    public new void Print() => Console.WriteLine("Bar"); // 숨김
}

Foo x = new Bar();
x.Print(); // Foo (정적 바인딩) — 오버라이드가 아니다!
```

> **오버라이드**는 **virtual/override** 조합. **new**는 **시그니처 중복을 의도적으로 감추는 것**.

---

## 5) `base` 키워드 — 부모 생성자/메서드 접근

```csharp
class Animal
{
    public Animal(string name) => Console.WriteLine("Animal: " + name);
    public virtual void Speak() => Console.WriteLine("...");
}

class Dog : Animal
{
    public Dog(string name) : base(name) => Console.WriteLine("Dog: " + name);

    public override void Speak()
    {
        base.Speak(); // 부모 동작 활용
        Console.WriteLine("멍멍");
    }
}
```

---

## 6) 어셈블리 경계와 `internal`

### 6.1 두 어셈블리 가정
- **Lib.dll**: 라이브러리
- **App.exe**: 콘솔 앱

```csharp
// Lib.dll
namespace Lib;
public class Api
{
    internal static string Token => "INTERNAL-LIB";
}
```

```csharp
// App.exe
using Lib;
class Program
{
    static void Main()
    {
        // Console.WriteLine(Api.Token); // ❌ 다른 어셈블리에서는 internal에 접근 불가
    }
}
```

### 6.2 테스트/플러그인을 위해 내부 공개하기 — `InternalsVisibleTo`

```csharp
// Lib/Properties/AssemblyInfo.cs
using System.Runtime.CompilerServices;
[assembly: InternalsVisibleTo("Lib.Tests")] // Lib.Tests 어셈블리에서 internal 접근 허용
```

---

## 7) 중첩 타입의 접근성

중첩 타입은 **바깥 타입의 접근성**에 의해 **상한이 제한**됩니다.

```csharp
public class Outer
{
    private class InnerPrivate { }              // 오직 Outer 내부에서
    protected class InnerProtected { }          // 파생형에서
    internal class InnerInternal { }            // 같은 어셈블리
    protected internal class InnerPI { }        // 어셈블리 전체 ∪ 외부 파생형
    private protected class InnerPP { }         // 어셈블리 내 파생형
}
```

- 바깥 타입이 `internal`이면, 중첩 타입을 `public`로 해도 **결국 internal 상한**에 묶임.

---

## 8) 접근 제어 실전 패턴

### 8.1 팩토리 + 캡슐화

```csharp
public class Order
{
    public string Id { get; }
    public IReadOnlyList<string> Items => _items;
    private readonly List<string> _items = new();

    private Order(string id) { Id = id; }

    public static Order Create(string id, IEnumerable<string> items)
    {
        if (string.IsNullOrWhiteSpace(id)) throw new ArgumentException();
        var o = new Order(id);
        foreach (var it in items)
            o.AddItem(it);
        return o;
    }

    public void AddItem(string item)
    {
        if (string.IsNullOrWhiteSpace(item)) throw new ArgumentException();
        _items.Add(item);
    }
}
```

- **생성 경로 제한**(private ctor) + **정적 팩토리**로 유효상태 보장.

### 8.2 속성 접근자 비대칭

```csharp
public class Config
{
    public string Endpoint { get; private set; }
    public int    Timeout  { get; init; }

    public Config(string endpoint) => Endpoint = endpoint;

    public void ChangeEndpoint(string ep)
    {
        if (!Uri.IsWellFormedUriString(ep, UriKind.Absolute)) throw new ArgumentException();
        Endpoint = ep;
    }
}
```

---

## 9) `abstract`/`sealed`/`virtual` 설계 가이드

- **abstract class**: **인스턴스화 불가**, 일부/전체 메서드 추상.
- **sealed class**: 더 이상 상속 허용하지 않음 → 버전 호환/불변 계약 유지에 유리.
- **virtual/override**: 확장 훅 제공. 단, **불변 조건**이 깨지지 않게 문서화/가이드 필요.

```csharp
public abstract class Repository<T>
{
    public abstract Task SaveAsync(T entity);
    public virtual Task ValidateAsync(T entity) => Task.CompletedTask; // 확장 가능 훅
}

public sealed class SqlRepository<T> : Repository<T>
{
    public override Task SaveAsync(T e) { /*...*/ return Task.CompletedTask; }
    public sealed override Task ValidateAsync(T e) => base.ValidateAsync(e); // 더이상 재정의 불가
}
```

---

## 10) 인터페이스와 기본 구현(디폴트 인터페이스 멤버)

```csharp
public interface IClock
{
    DateTime Now { get; }

    // C# 8+: 기본 구현
    string FormatNow(string fmt = "O") => Now.ToString(fmt);
}

public class SystemClock : IClock
{
    public DateTime Now => DateTime.UtcNow;
}
```

- 인터페이스 **계약 분할**/의존성 주입에 유리.  
- 기본 구현은 버전 호환성에 도움이 되지만 **복잡도↑** → 신중히.

---

## 11) 예제 — 상속/가시성/오버라이드 종합

```csharp
namespace Demo;

public abstract class Animal
{
    public string Name { get; }
    protected Animal(string name) => Name = name;

    public abstract void Speak();

    // 파생형에서만 내부 상태 관찰 허용
    protected internal virtual string Info() => $"<{Name}> Animal";
}

public class Cat : Animal
{
    // 외부에서는 못 바꿈
    public int Lives { get; private set; } = 9;

    public Cat(string name) : base(name) { }

    public override void Speak() => Console.WriteLine("야옹");

    // 어셈블리 안이거나 파생형이면 관찰 가능
    protected internal override string Info() => base.Info() + " (Cat)";
}

public sealed class Tiger : Cat
{
    public Tiger(string name) : base(name) { }
    public override void Speak() => Console.WriteLine("그르르…");
}
```

사용:

```csharp
var a = new Cat("Nabi");
a.Speak();                 // 야옹
// a.Info();              // ❌ protected internal — 외부 어셈블리 일반 코드에선 접근 불가(조건부)
```

---

## 12) 수학적 메모 — 캡슐화로 상태공간 줄이기

클래스의 **가능한 상태공간**이 클수록 검증/테스트 비용이 증가합니다.  
캡슐화로 **쓰기 경로를 제한**하면 유효상태 집합의 크기를 줄여서 신뢰도를 높입니다.

$$
\text{ValidStates} \subseteq \text{AllStates}, \quad
|\text{ValidStates}| \ll |\text{AllStates}|
$$

---

## 13) 자주 하는 실수와 해결책

| 실수 | 문제 | 해결 |
|---|---|---|
| 필드 `public` 공개 | 불변조건 파괴, 버전 호환 위험 | **private 필드 + public/protected 속성/메서드** |
| `protected internal` 남용 | 외부 파생형에도 과도 공개 | 가능한 **private/protected**부터 고려 |
| 오버라이드 전제 없이 상속 허용 | 행동 변경으로 불변조건 붕괴 | **sealed** 기본, 확장 지점만 `virtual` |
| `new`와 `override` 혼동 | 다형성 기대 깨짐 | 오버라이드 의도면 `virtual/override`를 사용 |
| 테스트 위해 모두 `public` | API 오염 | `InternalsVisibleTo("Tests")` 활용 |
| 설정 변경 자유 방치 | 불일치 상태 | `init`/`private set`/전용 변경 메서드로 제약 |

---

## 14) 미니 실습

1) `public class Document`  
   - `Title`은 `get; private set;`, `Content`는 `get; init;`  
   - `Rename(string)`로만 제목 변경 가능(빈 문자열 금지).

2) `abstract class Vehicle` → `Car`, `Bike` 파생  
   - `Start()`는 추상, `Describe()`는 가상.  
   - `Car.Describe()`를 **sealed override**로 고정.

3) `internal class Secrets`와 `public class Facade`  
   - 외부에서는 내부 비밀에 접근 불가.  
   - 단위 테스트 프로젝트에서만 `Secrets` 접근 가능하도록 `InternalsVisibleTo` 설정.

---

## 15) 요약

- **접근 제어자**는 가시성/의존성의 경계를 명확히 하여 **버그 표면적**을 줄인다.  
- **캡슐화**로 상태 변경 경로를 통제, **불변 조건**을 보장한다.  
- **상속**은 신중히: 기본은 **컴포지션**, 필요한 확장 지점만 `virtual`.  
- **어셈블리 경계**를 의식해 `internal`/`InternalsVisibleTo`/`file`를 적절히 사용한다.  
- **new vs override**를 구분하고, **sealed/abstract**로 확장 가능성을 제어한다.