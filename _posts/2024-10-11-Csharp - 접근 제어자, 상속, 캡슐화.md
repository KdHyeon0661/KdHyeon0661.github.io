---
layout: post
title: C# - 접근 제어자, 상속, 캡슐화
date: 2024-10-11 19:20:23 +0900
category: Csharp
---
# C# 접근 제어자와 클래스 관계: 캡슐화와 설계의 기술

C#에서 접근 제어자와 클래스 간의 관계는 단순한 문법적 기능을 넘어, 소프트웨어 설계의 핵심 원칙을 구현하는 도구입니다. 이들은 코드의 구조를 정의하고, 모듈 간의 의존성을 관리하며, 소프트웨어의 유지보수성과 확장성을 결정합니다.

## 접근 제어자: 가시성의 미세 조정

접근 제어자는 클래스의 멤버(필드, 속성, 메서드)에 대한 접근 권한을 정의합니다. 각 제어자는 특정한 가시성 범위를 가지며, 이를 올바르게 사용하는 것이 견고한 소프트웨어 설계의 첫걸음입니다.

### 다양한 접근 제어자의 실전 적용

```csharp
// 공개 API: 외부에서 자유롭게 접근 가능
public class BankAccount
{
    // 공개 속성: 읽기 전용으로 노출
    public decimal Balance => _balance;
    
    // 내부 필드: 완전히 은닉
    private decimal _balance;
    
    // 어셈블리 내부에서만 접근 가능 (동일 프로젝트)
    internal string InternalId { get; }
    
    // 파생 클래스에서 접근 가능
    protected DateTime CreatedAt { get; }
    
    // 어셈블리 내부 또는 파생 클래스에서 접근 가능
    protected internal string AccountType { get; }
    
    // 동일 어셈블리의 파생 클래스에서만 접근 가능
    private protected string InternalCode { get; }
    
    public BankAccount(string internalId)
    {
        InternalId = internalId;
        CreatedAt = DateTime.UtcNow;
        _balance = 0;
    }
    
    // 공개 메서드: 외부에서 호출 가능
    public void Deposit(decimal amount)
    {
        ValidateAmount(amount);
        _balance += amount;
        RecordTransaction("입금", amount);
    }
    
    // 내부 메서드: 같은 클래스 내에서만 호출 가능
    private void ValidateAmount(decimal amount)
    {
        if (amount <= 0)
            throw new ArgumentException("금액은 0보다 커야 합니다.");
    }
    
    // 보호된 메서드: 파생 클래스에서 재정의 가능
    protected virtual void RecordTransaction(string type, decimal amount)
    {
        // 기본 트랜잭션 기록 로직
        Console.WriteLine($"{DateTime.Now}: {type} {amount:C}");
    }
}
```

각 접근 제어자는 특정한 설계 의도를 표현합니다:
- `public`: 컴포넌트의 공식 인터페이스, 외부 의존성 생성
- `private`: 구현 세부사항, 내부 논리 캡슐화
- `protected`: 확장 포인트, 템플릿 메서드 패턴
- `internal`: 모듈 내부 협력, 공개 API 오염 방지

### C# 11의 `file` 접근 제어자

C# 11부터는 `file` 접근 제어자가 추가되었습니다. `file` 키워드를 사용하면 **같은 소스 파일 내에서만** 접근 가능한 타입을 선언할 수 있습니다. 이는 `internal`보다 더 좁은 범위로, 파일 단위의 구현 세부사항을 숨기는 데 유용합니다.

```csharp
// File1.cs
file class FileHelper
{
    public static string Format(string input) => input.Trim();
}

public class PublicClass
{
    public void Process()
    {
        // 같은 파일 내에서는 FileHelper 사용 가능
        var result = FileHelper.Format("  hello  ");
    }
}
```

```csharp
// File2.cs
public class AnotherClass
{
    public void TryUse()
    {
        // 오류: FileHelper는 다른 파일에서 접근 불가
        // var result = FileHelper.Format("test"); // 컴파일 에러
    }
}
```

### `protected internal`과 `private protected` 비교

이 두 접근 제어자는 혼동하기 쉽지만, 범위에 명확한 차이가 있습니다.

| 접근 제어자 | 접근 가능 범위 |
|------------|---------------|
| `protected internal` | **같은 어셈블리**에 있는 모든 코드 **또는** 다른 어셈블리에 있더라도 해당 클래스를 상속받은 파생 클래스 |
| `private protected` | **같은 어셈블리**에 있으면서 동시에 해당 클래스를 상속받은 파생 클래스에서만 접근 가능 |

```csharp
// Assembly A
public class BaseClass
{
    protected internal int Value1 = 10;
    private protected int Value2 = 20;
}

// Assembly A 내의 다른 클래스
public class AnotherClassInSameAssembly
{
    public void Test()
    {
        var baseObj = new BaseClass();
        Console.WriteLine(baseObj.Value1); // OK (같은 어셈블리)
        // Console.WriteLine(baseObj.Value2); // 오류: 파생 클래스가 아님
    }
}

// Assembly B (다른 어셈블리)에서 상속
public class DerivedInOtherAssembly : BaseClass
{
    public void Test()
    {
        Console.WriteLine(Value1); // OK (파생 클래스)
        // Console.WriteLine(Value2); // 오류: 같은 어셈블리가 아님
    }
}
```

## 캡슐화: 상태 보호와 불변성 유지

캡슐화는 객체의 내부 상태를 보호하고, 유효한 상태만을 허용하는 메커니즘입니다. 단순히 필드를 숨기는 것을 넘어, 객체의 불변 조건을 보장하는 설계 철학입니다.

### 불변 조건을 보장하는 캡슐화 패턴

```csharp
public class Temperature
{
    // 절대온도 (켈빈) - 내부 표현
    private double _kelvin;
    
    // 공개 인터페이스: 섭씨와 화씨로만 접근 허용
    public double Celsius
    {
        get => _kelvin - 273.15;
        set
        {
            if (value < -273.15)
                throw new ArgumentOutOfRangeException(nameof(value), 
                    "섭씨 -273.15도 이하는 불가능합니다.");
            _kelvin = value + 273.15;
        }
    }
    
    public double Fahrenheit
    {
        get => (_kelvin - 273.15) * 9/5 + 32;
        set
        {
            // 화씨를 통해 설정할 때도 동일한 검증 수행
            Celsius = (value - 32) * 5/9;
        }
    }
    
    // 팩토리 메서드 패턴: 유효한 객체만 생성
    public static Temperature FromCelsius(double celsius)
    {
        var temp = new Temperature();
        temp.Celsius = celsius; // 속성 setter가 검증 수행
        return temp;
    }
    
    public static Temperature FromFahrenheit(double fahrenheit)
    {
        var temp = new Temperature();
        temp.Fahrenheit = fahrenheit; // 속성 setter가 검증 수행
        return temp;
    }
    
    // 비공개 생성자: 직접 생성 제한
    private Temperature()
    {
        _kelvin = 273.15; // 기본값: 0°C
    }
}
```

이 설계의 장점은 명확합니다:
1. **불변 조건 보장**: 절대영도 이하의 온도를 방지
2. **표현력**: 여러 온도 체계를 자연스럽게 지원
3. **유효성**: 팩토리 메서드를 통해서만 객체 생성
4. **변환 로직 중앙화**: 모든 온도 변환이 한 곳에서 관리

### `init` 접근자를 통한 불변성 강화

C# 9부터 도입된 `init` 접근자는 객체 초기화 시에만 속성 설정을 허용하고, 이후에는 변경을 차단합니다. 이를 통해 불변 객체를 더 간결하게 만들 수 있습니다.

```csharp
public class Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
    public DateTime BirthDate { get; init; }
    
    public Person(string firstName, string lastName, DateTime birthDate)
    {
        FirstName = firstName;
        LastName = lastName;
        BirthDate = birthDate;
    }
    
    // init 접근자 덕분에 with 표현식 사용 가능 (C# 9+)
    public Person WithFirstName(string newFirstName) => 
        this with { FirstName = newFirstName };
}

// 사용
var person = new Person("John", "Doe", new DateTime(1990, 1, 1));
// person.FirstName = "Jane"; // 오류: init-only 속성은 변경 불가
var updated = person with { LastName = "Smith" }; // 새 객체 생성
```

### `record` 타입으로 더 간편한 불변 객체

C# 9의 `record`는 불변 객체를 정의하는 간결한 방법을 제공합니다. 값 기반 동등성, `with` 표현식, 디스트럭처 등을 자동으로 생성해줍니다.

```csharp
// 레코드 선언 (위치 레코드)
public record Person(string FirstName, string LastName, DateTime BirthDate);

// 사용
var person1 = new Person("John", "Doe", new DateTime(1990, 1, 1));
var person2 = person1 with { LastName = "Smith" }; // 새 객체

// 값 기반 동등성 비교
Console.WriteLine(person1 == new Person("John", "Doe", new DateTime(1990, 1, 1))); // True
Console.WriteLine(person1.Equals(person2)); // False

// 디스트럭처
var (first, last, birth) = person1;
Console.WriteLine($"{first} {last} - {birth}");
```

`record`를 사용하면 앞서 `ImmutablePerson` 클래스를 직접 구현할 필요 없이 훨씬 적은 코드로 불변 객체를 만들 수 있습니다. 하지만 복잡한 유효성 검사나 비즈니스 로직이 필요하다면 직접 구현한 클래스가 더 적합할 수 있습니다.

## 상속 vs 컴포지션: 재사용의 두 가지 길

코드 재사용은 객체지향 프로그래밍의 주요 목표 중 하나입니다. C#은 상속과 컴포지션이라는 두 가지 접근법을 제공하며, 각각의 적절한 사용 사례를 이해하는 것이 중요합니다.

### 상속: "is-a" 관계와 다형성

```csharp
// 기본 클래스: 공통 인터페이스 정의
public abstract class PaymentMethod
{
    public string Id { get; }
    public decimal Balance { get; protected set; }
    
    protected PaymentMethod(string id)
    {
        Id = id;
    }
    
    // 추상 메서드: 파생 클래스에서 구현 필수
    public abstract bool ProcessPayment(decimal amount);
    
    // 가상 메서드: 기본 구현 제공, 필요시 재정의 가능
    public virtual string GetDescription()
    {
        return $"결제수단 ID: {Id}, 잔액: {Balance:C}";
    }
    
    // 봉인 메서드: 더 이상의 재정의 방지
    public sealed override string ToString()
    {
        return GetDescription();
    }
}

// 구체 클래스: 특화된 구현
public class CreditCard : PaymentMethod
{
    public string CardNumber { get; }
    public DateTime ExpiryDate { get; }
    
    public CreditCard(string id, string cardNumber, DateTime expiryDate) 
        : base(id)
    {
        CardNumber = MaskCardNumber(cardNumber);
        ExpiryDate = expiryDate;
    }
    
    public override bool ProcessPayment(decimal amount)
    {
        if (amount <= 0 || amount > 10000) // 신용카드 제한
            return false;
            
        // 실제 결제 처리 로직 (실제 구현에서는 외부 API 호출)
        Console.WriteLine($"신용카드로 {amount:C} 결제 처리");
        return true;
    }
    
    public override string GetDescription()
    {
        return $"{base.GetDescription()}, 카드: {CardNumber}, 만료: {ExpiryDate:yyyy-MM}";
    }
    
    private static string MaskCardNumber(string cardNumber)
    {
        if (cardNumber.Length < 4)
            return "****";
            
        return new string('*', cardNumber.Length - 4) + cardNumber[^4..];
    }
}

// 또 다른 구체 클래스
public class BankTransfer : PaymentMethod
{
    public string BankName { get; }
    public string AccountNumber { get; }
    
    public BankTransfer(string id, string bankName, string accountNumber)
        : base(id)
    {
        BankName = bankName;
        AccountNumber = accountNumber;
    }
    
    public override bool ProcessPayment(decimal amount)
    {
        if (amount <= 0 || amount > Balance)
            return false;
            
        Balance -= amount;
        Console.WriteLine($"은행이체로 {amount:C} 처리, 잔액: {Balance:C}");
        return true;
    }
}
```

상속은 강력한 도구이지만, 남용하면 취약한 기반 클래스 문제나 다이아몬드 문제를 초래할 수 있습니다. "is-a" 관계가 명확하고, 다형성이 필요한 경우에만 사용해야 합니다.

### 생성자에서 가상 메서드 호출 시 주의사항

생성자에서 가상 메서드를 호출하면 예상치 못한 동작이 발생할 수 있습니다. 파생 클래스의 생성자가 아직 완전히 초기화되지 않은 상태에서 재정의된 메서드가 호출되기 때문입니다.

```csharp
public class BaseClass
{
    public BaseClass()
    {
        // 위험: 생성자에서 가상 메서드 호출
        VirtualMethod();
    }
    
    protected virtual void VirtualMethod()
    {
        Console.WriteLine("BaseClass.VirtualMethod");
    }
}

public class DerivedClass : BaseClass
{
    private readonly string _value = "Initialized";
    
    public DerivedClass(string value)
    {
        _value = value;
        Console.WriteLine($"DerivedClass constructor: {_value}");
    }
    
    protected override void VirtualMethod()
    {
        // _value가 아직 초기화되지 않았을 수 있음 (null 또는 기본값)
        Console.WriteLine($"DerivedClass.VirtualMethod: {_value}");
    }
}

// 사용
var obj = new DerivedClass("Test");
// 출력:
// DerivedClass.VirtualMethod:           (빈 문자열 또는 null)
// DerivedClass constructor: Test
```

이러한 문제를 피하려면 생성자에서 가상 메서드를 호출하지 않는 것이 원칙입니다. 필요한 경우 팩토리 메서드나 두 단계 초기화 패턴을 고려해야 합니다.

### `sealed` 클래스와 `sealed` 메서드

- **`sealed` 클래스**: 클래스 자체를 상속 불가능하게 만듭니다. 더 이상의 확장을 차단하여 설계를 닫습니다.
- **`sealed` 메서드**: `override`된 메서드를 더 이상 재정의할 수 없게 만듭니다.

```csharp
// sealed 클래스: 상속 불가
public sealed class FinalUtility
{
    public static void Helper() { }
}

// 오류: sealed 클래스 상속 불가
// public class DerivedUtility : FinalUtility { }

public class Base
{
    public virtual void NormalMethod() { }
    public virtual void SealedMethod() { }
}

public class Derived : Base
{
    public sealed override void SealedMethod() // 더 이상 재정의 불가
    {
        base.SealedMethod();
    }
}

public class MoreDerived : Derived
{
    // 오류: SealedMethod는 sealed이므로 재정의 불가
    // public override void SealedMethod() { }
    
    public override void NormalMethod() // OK
    {
        base.NormalMethod();
    }
}
```

`sealed` 클래스는 성능 최적화(가상 메서드 테이블 오버헤드 제거)와 설계 의도(더 이상 확장하지 않음)를 명확히 할 때 사용합니다. 프레임워크 설계에서 자주 사용됩니다.

### 컴포지션: "has-a" 관계와 유연성

```csharp
// 컴포지션을 통한 재사용: 더 유연하고 테스트하기 쉬움
public class OrderProcessor
{
    // 의존성 주입: 외부에서 제공
    private readonly IPaymentGateway _paymentGateway;
    private readonly IInventoryService _inventoryService;
    private readonly INotificationService _notificationService;
    
    public OrderProcessor(
        IPaymentGateway paymentGateway,
        IInventoryService inventoryService,
        INotificationService notificationService)
    {
        _paymentGateway = paymentGateway ?? 
            throw new ArgumentNullException(nameof(paymentGateway));
        _inventoryService = inventoryService ?? 
            throw new ArgumentNullException(nameof(inventoryService));
        _notificationService = notificationService ?? 
            throw new ArgumentNullException(nameof(notificationService));
    }
    
    public async Task<OrderResult> ProcessOrderAsync(Order order)
    {
        // 재고 확인
        if (!await _inventoryService.CheckAvailabilityAsync(order.Items))
        {
            return OrderResult.Failed("일부 상품의 재고가 부족합니다.");
        }
        
        // 결제 처리
        var paymentResult = await _paymentGateway.ProcessPaymentAsync(
            order.TotalAmount, order.PaymentMethod);
            
        if (!paymentResult.Success)
        {
            return OrderResult.Failed($"결제 실패: {paymentResult.ErrorMessage}");
        }
        
        // 주문 확정
        await _inventoryService.ReserveItemsAsync(order.Items);
        
        // 알림 발송
        await _notificationService.SendOrderConfirmationAsync(order);
        
        return OrderResult.Success(paymentResult.TransactionId);
    }
}

// 인터페이스: 느슨한 결합을 위한 계약
public interface IPaymentGateway
{
    Task<PaymentResult> ProcessPaymentAsync(decimal amount, string paymentMethod);
}

public interface IInventoryService
{
    Task<bool> CheckAvailabilityAsync(IEnumerable<OrderItem> items);
    Task ReserveItemsAsync(IEnumerable<OrderItem> items);
}

public interface INotificationService
{
    Task SendOrderConfirmationAsync(Order order);
}
```

컴포지션의 장점:
1. **유연성**: 구성 요소를 쉽게 교체 가능
2. **테스트 용이성**: 모의 객체를 사용한 단위 테스트 가능
3. **단일 책임 원칙**: 각 클래스가 한 가지 일만 담당
4. **의존성 역전**: 추상화에 의존, 구체화에 의존하지 않음

## 어셈블리 경계와 내부 가시성

대규모 프로젝트에서는 여러 어셈블리(프로젝트)로 코드를 분리하는 것이 일반적입니다. 이때 `internal` 접근 제어자는 모듈화를 강화하는 중요한 도구가 됩니다.

### 내부 구현의 보호와 테스트

```csharp
// 라이브러리 프로젝트 (MyLibrary.csproj)
namespace MyLibrary;

// 공개 API: 외부 사용자를 위한 인터페이스
public interface IDataProcessor
{
    Task<ProcessResult> ProcessAsync(string input);
}

// 내부 구현: 라이브러리 내부에서만 사용
internal class DataProcessor : IDataProcessor
{
    private readonly IDataValidator _validator;
    private readonly IDataTransformer _transformer;
    
    internal DataProcessor(IDataValidator validator, IDataTransformer transformer)
    {
        _validator = validator;
        _transformer = transformer;
    }
    
    public async Task<ProcessResult> ProcessAsync(string input)
    {
        var validationResult = await _validator.ValidateAsync(input);
        if (!validationResult.IsValid)
        {
            return ProcessResult.Failed(validationResult.Errors);
        }
        
        var transformed = await _transformer.TransformAsync(input);
        return ProcessResult.Success(transformed);
    }
}

// 내부 도구 클래스
internal static class InternalHelpers
{
    internal static string SanitizeInput(string input)
    {
        // 내부 유틸리티 메서드
        return input.Trim().Replace("\r\n", "\n");
    }
}

// 공개 팩토리: 내부 구현을 숨기면서 인스턴스 생성
public static class DataProcessorFactory
{
    public static IDataProcessor CreateProcessor()
    {
        // 내부 타입을 사용하지만 외부에는 IDataProcessor만 노출
        var validator = new DataValidator();
        var transformer = new DataTransformer();
        return new DataProcessor(validator, transformer);
    }
}
```

```csharp
// 테스트 프로젝트 (MyLibrary.Tests.csproj)
// AssemblyInfo.cs 또는 .csproj에 다음 추가:
// [assembly: InternalsVisibleTo("MyLibrary.Tests")]

namespace MyLibrary.Tests;

[TestClass]
public class DataProcessorTests
{
    [TestMethod]
    public void InternalHelpers_SanitizeInput_RemovesExtraWhitespace()
    {
        // InternalsVisibleTo 덕분에 internal 멤버 테스트 가능
        string input = "  Hello\r\nWorld  ";
        string result = InternalHelpers.SanitizeInput(input);
        
        Assert.AreEqual("Hello\nWorld", result);
    }
    
    [TestMethod]
    public void DataProcessor_ProcessAsync_ValidatesInput()
    {
        // 내부 구현에 대한 단위 테스트
        var validator = new Mock<IDataValidator>();
        var transformer = new Mock<IDataTransformer>();
        
        var processor = new DataProcessor(validator.Object, transformer.Object);
        // 테스트 계속...
    }
}
```

이 접근법의 장점:
1. **깔끔한 공개 API**: 외부 사용자에게 필요한 것만 노출
2. **구현 자유도**: 내부 구현 변경이 외부에 영향 미치지 않음
3. **테스트 가능성**: 내부 로직도 철저히 테스트 가능
4. **보안**: 민감한 로직을 외부로부터 보호

## 실전 설계 패턴과 원칙

### 1. 의도 드러내기 네이밍과 접근 제어

```csharp
public class DocumentManager
{
    // 의도: 이 목록은 내부 구현의 일부이며 직접 수정되면 안 됨
    private readonly List<Document> _documents = new();
    
    // 의도: 읽기 전용 뷰만 제공
    public IReadOnlyList<Document> Documents => _documents.AsReadOnly();
    
    // 의도: 문서 추가는 이 메서드를 통해서만
    public void AddDocument(Document document)
    {
        if (document == null)
            throw new ArgumentNullException(nameof(document));
            
        ValidateDocument(document);
        _documents.Add(document);
        OnDocumentAdded(document);
    }
    
    // 의도: 검증 로직은 내부적으로만 사용
    private void ValidateDocument(Document document)
    {
        if (string.IsNullOrWhiteSpace(document.Title))
            throw new ArgumentException("문서 제목은 필수입니다.");
            
        if (document.Content.Length == 0)
            throw new ArgumentException("문서 내용은 비어 있을 수 없습니다.");
    }
    
    // 의도: 이벤트 처리를 위한 확장 포인트
    protected virtual void OnDocumentAdded(Document document)
    {
        // 기본 구현: 아무 것도 하지 않음
        // 파생 클래스에서 재정의하여 특정 동작 추가 가능
    }
}
```

### 2. 불변 객체 패턴 (레코드와 비교)

앞서 `ImmutablePerson` 클래스를 직접 구현했지만, 현대 C#에서는 `record`를 사용하는 것이 더 간편합니다. 다만 복잡한 도메인 로직이 필요하면 직접 구현한 클래스가 여전히 유효합니다.

```csharp
// 직접 구현한 불변 클래스 (로직 포함)
public sealed class ImmutablePerson
{
    public string FirstName { get; }
    public string LastName { get; }
    public DateTime BirthDate { get; }
    
    public int Age => CalculateAge();
    
    private int CalculateAge()
    {
        var today = DateTime.Today;
        var age = today.Year - BirthDate.Year;
        if (BirthDate.Date > today.AddYears(-age)) age--;
        return age;
    }
    
    public ImmutablePerson(string firstName, string lastName, DateTime birthDate)
    {
        FirstName = firstName ?? throw new ArgumentNullException(nameof(firstName));
        LastName = lastName ?? throw new ArgumentNullException(nameof(lastName));
        
        if (birthDate > DateTime.Today)
            throw new ArgumentOutOfRangeException(nameof(birthDate), 
                "생년월일은 미래일 수 없습니다.");
                
        BirthDate = birthDate;
    }
    
    public ImmutablePerson WithFirstName(string newFirstName) =>
        new ImmutablePerson(newFirstName, LastName, BirthDate);
}

// record를 사용한 간결한 버전 (로직이 단순할 때)
public record Person(string FirstName, string LastName, DateTime BirthDate)
{
    public int Age => CalculateAge(); // 계산된 속성 추가 가능
    
    private int CalculateAge()
    {
        var today = DateTime.Today;
        var age = today.Year - BirthDate.Year;
        if (BirthDate.Date > today.AddYears(-age)) age--;
        return age;
    }
}
```

### 3. 전략 패턴과 컴포지션

```csharp
// 전략 인터페이스
public interface ISortStrategy<T>
{
    void Sort(List<T> items);
}

// 다양한 정렬 전략
public class QuickSortStrategy<T> : ISortStrategy<T>
    where T : IComparable<T>
{
    public void Sort(List<T> items)
    {
        // 퀵 정렬 구현
        QuickSort(items, 0, items.Count - 1);
    }
    
    private void QuickSort(List<T> items, int left, int right)
    {
        if (left < right)
        {
            int pivotIndex = Partition(items, left, right);
            QuickSort(items, left, pivotIndex - 1);
            QuickSort(items, pivotIndex + 1, right);
        }
    }
    
    private int Partition(List<T> items, int left, int right) { /* 구현 */ }
}

public class MergeSortStrategy<T> : ISortStrategy<T>
    where T : IComparable<T>
{
    public void Sort(List<T> items)
    {
        // 병합 정렬 구현
        if (items.Count <= 1) return;
        
        var sorted = MergeSort(items);
        items.Clear();
        items.AddRange(sorted);
    }
    
    private List<T> MergeSort(List<T> items) { /* 구현 */ }
}

// 컨텍스트: 전략 사용
public class Sorter<T>
{
    private ISortStrategy<T> _strategy;
    
    public Sorter(ISortStrategy<T> strategy)
    {
        _strategy = strategy ?? throw new ArgumentNullException(nameof(strategy));
    }
    
    // 전략 동적 변경
    public void SetStrategy(ISortStrategy<T> newStrategy)
    {
        _strategy = newStrategy ?? throw new ArgumentNullException(nameof(newStrategy));
    }
    
    public void Sort(List<T> items)
    {
        if (items == null)
            throw new ArgumentNullException(nameof(items));
            
        _strategy.Sort(items);
    }
}
```

## 결론

C#의 접근 제어자와 클래스 관계 설계는 단순한 코딩 규칙을 넘어, 소프트웨어 아키텍처의 핵심 요소입니다. 효과적인 캡슐화는 코드의 안정성을 높이고, 적절한 상속과 컴포지션 선택은 시스템의 유연성을 보장합니다.

가장 중요한 원칙은 "필요한 만큼만 공개하라"는 것입니다. 모든 것을 `public`으로 만드는 것은 쉽지만, 이는 결합도를 높이고 유지보수를 어렵게 만듭니다. 대신 신중하게 접근 수준을 설계하고, 인터페이스를 통해 추상화하며, 내부 구현을 보호해야 합니다.

또한 상속보다는 컴포지션을 우선시하는 것이 현대 객체지향 설계의 트렌드입니다. 상속은 강력한 "is-a" 관계가 명확할 때만 사용하고, 그 외의 경우에는 인터페이스와 컴포지션을 통해 더 유연하고 테스트 가능한 설계를 구축해야 합니다.

최신 C# 기능(`file`, `init`, `record` 등)을 적극 활용하면 더 적은 코드로 안전하고 표현력 있는 설계를 할 수 있습니다. 하지만 항상 팀의 코딩 표준과 프로젝트의 특정 요구사항을 고려하여 실용적인 선택을 하는 것이 중요합니다. 기술적 완벽함보다는 유지보수성과 확장성 사이의 균형을 찾는 것이 장기적인 성공의 열쇠입니다.