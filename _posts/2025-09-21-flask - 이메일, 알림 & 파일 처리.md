---
layout: post
title: flask - 이메일, 알림 & 파일 처리
date: 2025-09-21 15:25:23 +0900
category: flask
---
# 이메일/알림 & 파일 처리

## 개요

이메일과 알림 시스템은 사용자와의 지속적인 소통 채널로서, 파일 처리 기능은 현대 웹 애플리케이션의 기본적인 요구사항입니다. 이 장에서는 이메일 발송, 다양한 알림 채널 관리, 안전한 파일 업로드 및 다운로드 시스템을 구축하는 방법을 다룹니다.

**핵심 구성 요소**:
- **이메일 시스템**: SMTP 기반 발송, 대량 메일 처리, 템플릿 관리, 보안 설정
- **알림 시스템**: 이메일, 웹푸시, SMS, 인앱 알림 등의 다중 채널 관리
- **파일 처리**: 업로드 제한, 보안 검증, 클라우드 저장소 통합, 대용량 파일 처리

---

## 이메일 시스템 구현

### Flask-Mail을 활용한 기본 이메일 발송

Flask-Mail은 Flask 애플리케이션에 이메일 기능을 추가하는 간단하면서도 효과적인 확장입니다.

#### 설치 및 설정

```bash
pip install Flask-Mail
```

```python
# app/extensions.py

from flask_mail import Mail

mail = Mail()

def init_mail(app):
    """Flask-Mail 초기화"""
    # 기본 설정
    app.config.setdefault("MAIL_SERVER", "smtp.gmail.com")
    app.config.setdefault("MAIL_PORT", 587)
    app.config.setdefault("MAIL_USE_TLS", True)
    app.config.setdefault("MAIL_USERNAME", "your-username")
    app.config.setdefault("MAIL_PASSWORD", "your-password")
    app.config.setdefault("MAIL_DEFAULT_SENDER", ("Your App", "noreply@example.com"))
    app.config.setdefault("MAIL_MAX_EMAILS", 50)  # 단일 연결로 최대 발송 가능 메일 수
    
    # 추가 설정
    app.config.setdefault("MAIL_DEBUG", app.debug)
    app.config.setdefault("MAIL_SUPPRESS_SEND", app.testing)
    
    mail.init_app(app)
```

#### 단일 이메일 발송

```python
# app/emails/core.py

from flask_mail import Message
from flask import render_template, current_app
from app.extensions import mail
import logging

logger = logging.getLogger(__name__)

def send_welcome_email(user):
    """회원 가입 환영 이메일 발송"""
    
    # 이메일 메시지 생성
    msg = Message(
        subject=f"[{current_app.config.get('APP_NAME', 'MyApp')}] 환영합니다, {user.name}님!",
        recipients=[user.email],
        sender=current_app.config.get("MAIL_DEFAULT_SENDER")
    )
    
    # 텍스트 및 HTML 본문
    msg.body = render_template("emails/welcome.txt", user=user)
    msg.html = render_template("emails/welcome.html", user=user)
    
    # 첨부 파일 추가 (선택사항)
    # with current_app.open_resource("static/images/logo.png") as fp:
    #     msg.attach(
    #         "logo.png",
    #         "image/png",
    #         fp.read(),
    #         "inline",
    #         headers=[["Content-ID", "<company_logo>"]]
    #     )
    
    try:
        # 이메일 발송
        mail.send(msg)
        logger.info(f"환영 이메일 발송 완료: {user.email}")
        return True
        
    except Exception as e:
        logger.error(f"이메일 발송 실패: {user.email}, 오류: {str(e)}")
        return False

def send_password_reset_email(user, reset_token):
    """비밀번호 재설정 이메일 발송"""
    
    reset_url = f"{current_app.config.get('APP_URL', '')}/reset-password/{reset_token}"
    
    msg = Message(
        subject="[MyApp] 비밀번호 재설정 요청",
        recipients=[user.email]
    )
    
    msg.body = render_template(
        "emails/password_reset.txt",
        user=user,
        reset_url=reset_url,
        expiry_hours=current_app.config.get("PASSWORD_RESET_EXPIRY", 24)
    )
    
    msg.html = render_template(
        "emails/password_reset.html",
        user=user,
        reset_url=reset_url,
        expiry_hours=current_app.config.get("PASSWORD_RESET_EXPIRY", 24)
    )
    
    try:
        mail.send(msg)
        logger.info(f"비밀번호 재설정 이메일 발송 완료: {user.email}")
        return True
    except Exception as e:
        logger.error(f"비밀번호 재설정 이메일 발송 실패: {user.email}, 오류: {str(e)}")
        return False
```

#### 이메일 템플릿

{% raw %}
```html
<!-- templates/emails/welcome.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>환영합니다</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background-color: #4F46E5;
            color: white;
            padding: 30px 20px;
            text-align: center;
            border-radius: 8px 8px 0 0;
        }
        .content {
            background-color: #f9fafb;
            padding: 30px 20px;
            border-radius: 0 0 8px 8px;
            border: 1px solid #e5e7eb;
            border-top: none;
        }
        .button {
            display: inline-block;
            background-color: #4F46E5;
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-weight: 500;
            margin-top: 20px;
        }
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
            color: #6b7280;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>환영합니다, {{ user.name }}님!</h1>
    </div>
    <div class="content">
        <p>안녕하세요 {{ user.name }}님,</p>
        <p>저희 서비스에 가입해 주셔서 진심으로 감사드립니다.</p>
        
        <p>가입하신 계정 정보:</p>
        <ul>
            <li>이메일: {{ user.email }}</li>
            <li>가입일: {{ user.created_at.strftime('%Y년 %m월 %d일') }}</li>
        </ul>
        
        <p>서비스를 시작하려면 아래 버튼을 클릭해주세요:</p>
        <a href="{{ url_for('site.dashboard', _external=True) }}" class="button">
            대시보드로 이동
        </a>
        
        <p>궁금한 점이 있으시면 언제든지 고객센터로 문의해주세요.</p>
    </div>
    <div class="footer">
        <p>본 이메일은 발신 전용입니다.</p>
        <p>© 2024 MyApp. All rights reserved.</p>
    </div>
</body>
</html>
```
{% endraw %}

{% raw %}
```txt
<!-- templates/emails/welcome.txt -->
환영합니다, {{ user.name }}님!

저희 서비스에 가입해 주셔서 진심으로 감사드립니다.

가입하신 계정 정보:
- 이메일: {{ user.email }}
- 가입일: {{ user.created_at.strftime('%Y년 %m월 %d일') }}

서비스를 시작하려면 다음 링크를 방문해주세요:
{{ url_for('site.dashboard', _external=True) }}

궁금한 점이 있으시면 언제든지 고객센터로 문의해주세요.

본 이메일은 발신 전용입니다.
© 2024 MyApp. All rights reserved.
```
{% endraw %}

### 대량 이메일 발송 및 고급 기능

#### Celery를 활용한 비동기 이메일 처리

대량 이메일 발송이나 시간이 오래 걸리는 작업은 백그라운드에서 처리하는 것이 좋습니다.

```python
# app/tasks/email_tasks.py

from celery import shared_task
from flask import render_template, current_app
from flask_mail import Message
from app.extensions import mail, db
from app.models.user import User
from app.models.email_log import EmailLog
import logging
import time

logger = logging.getLogger(__name__)

@shared_task(
    bind=True,
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_backoff_max=60,
    retry_jitter=True,
    max_retries=3
)
def send_bulk_email_task(self, template_name, user_ids, extra_context=None):
    """대량 이메일 발송 태스크"""
    
    start_time = time.time()
    sent_count = 0
    failed_count = 0
    
    # 추가 컨텍스트
    context = extra_context or {}
    
    # 사용자 조회
    users = User.query.filter(User.id.in_(user_ids)).all()
    
    with mail.connect() as connection:
        for user in users:
            try:
                # 개인화된 컨텍스트
                user_context = {**context, "user": user}
                
                # 이메일 메시지 생성
                msg = Message(
                    subject=render_template(f"emails/{template_name}_subject.txt", **user_context).strip(),
                    recipients=[user.email],
                    sender=current_app.config.get("MAIL_DEFAULT_SENDER")
                )
                
                msg.body = render_template(f"emails/{template_name}.txt", **user_context)
                msg.html = render_template(f"emails/{template_name}.html", **user_context)
                
                # 발송
                connection.send(msg)
                
                # 발송 로그 기록
                email_log = EmailLog(
                    user_id=user.id,
                    email_type=template_name,
                    recipient=user.email,
                    status="sent",
                    subject=msg.subject
                )
                db.session.add(email_log)
                
                sent_count += 1
                
                # 속도 제한 (분당 100통 제한 예시)
                if sent_count % 100 == 0:
                    time.sleep(60)
                
            except Exception as e:
                logger.error(f"이메일 발송 실패: {user.email}, 오류: {str(e)}")
                
                # 실패 로그 기록
                email_log = EmailLog(
                    user_id=user.id,
                    email_type=template_name,
                    recipient=user.email,
                    status="failed",
                    error_message=str(e)
                )
                db.session.add(email_log)
                
                failed_count += 1
    
    # 로그 커밋
    db.session.commit()
    
    elapsed_time = time.time() - start_time
    
    logger.info(
        f"대량 이메일 발송 완료: 총 {len(users)}명, "
        f"성공 {sent_count}건, 실패 {failed_count}건, "
        f"소요시간 {elapsed_time:.2f}초"
    )
    
    return {
        "total": len(users),
        "sent": sent_count,
        "failed": failed_count,
        "elapsed_time": elapsed_time
    }

@shared_task
def send_newsletter_task(newsletter_id):
    """뉴스레터 발송 태스크"""
    
    from app.models.newsletter import Newsletter
    from app.models.subscription import Subscription
    
    newsletter = Newsletter.query.get(newsletter_id)
    if not newsletter:
        logger.error(f"뉴스레터를 찾을 수 없음: {newsletter_id}")
        return
    
    # 구독자 목록 조회 (옵트아웃 제외)
    subscriptions = Subscription.query.filter_by(
        newsletter_id=newsletter_id,
        is_active=True,
        is_opted_out=False
    ).all()
    
    user_ids = [sub.user_id for sub in subscriptions]
    
    # 대량 발송 태스크 호출
    return send_bulk_email_task.delay(
        template_name="newsletter",
        user_ids=user_ids,
        extra_context={
            "newsletter": newsletter,
            "unsubscribe_url": current_app.config.get("APP_URL") + "/unsubscribe"
        }
    )
```

#### 이메일 발송 로그 모델

```python
# app/models/email_log.py

from app.extensions import db
from datetime import datetime, timezone

class EmailLog(db.Model):
    """이메일 발송 로그"""
    __tablename__ = "email_logs"
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"), index=True)
    email_type = db.Column(db.String(50), index=True)  # welcome, password_reset, newsletter 등
    recipient = db.Column(db.String(255), nullable=False)
    subject = db.Column(db.String(255))
    status = db.Column(db.String(20), default="pending")  # pending, sent, failed
    error_message = db.Column(db.Text)
    sent_at = db.Column(db.DateTime(timezone=True))
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    
    # 관계
    user = db.relationship("User", backref="email_logs")
    
    def __repr__(self):
        return f"<EmailLog {self.email_type} to {self.recipient} ({self.status})>"
    
    def mark_sent(self):
        """발송 완료로 표시"""
        self.status = "sent"
        self.sent_at = datetime.now(timezone.utc)
    
    def mark_failed(self, error_message):
        """발송 실패로 표시"""
        self.status = "failed"
        self.error_message = error_message
```

### 이메일 보안 및 전송자 인증

이메일이 스팸으로 분류되지 않도록 하기 위해 중요한 보안 설정들:

#### DNS 레코드 설정

1. **SPF (Sender Policy Framework)**
   ```
   TXT 레코드: "v=spf1 include:_spf.google.com ~all"
   ```

2. **DKIM (DomainKeys Identified Mail)**
   ```
   TXT 레코드: "v=DKIM1; k=rsa; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC..."
   ```

3. **DMARC (Domain-based Message Authentication, Reporting & Conformance)**
   ```
   TXT 레코드: "v=DMARC1; p=quarantine; rua=mailto:dmarc-reports@example.com"
   ```

#### Flask-Mail 고급 설정

```python
# app/config.py

class ProductionConfig:
    # 이메일 보안 설정
    MAIL_USE_TLS = True
    MAIL_USE_SSL = False
    MAIL_SSL_CONTEXT = None
    
    # 발신자 도메인 인증
    MAIL_DEFAULT_SENDER = ("MyApp 공식", "no-reply@myapp.com")
    
    # 연결 설정
    MAIL_MAX_EMAILS = 100
    MAIL_ASCII_ATTACHMENTS = False
    
    # DKIM 서명 (선택사항)
    MAIL_DKIM_DOMAIN = "myapp.com"
    MAIL_DKIM_SELECTOR = "default"
    MAIL_DKIM_PRIVATE_KEY = """
        -----BEGIN RSA PRIVATE KEY-----
        MIIEpQIBAAKCAQEA...
        -----END RSA PRIVATE KEY-----
    """
```

---

## 알림 시스템

### 다중 채널 알림 시스템

현대 애플리케이션은 이메일 외에도 다양한 채널을 통해 사용자에게 알림을 전달합니다.

#### 알림 모델 설계

```python
# app/models/notification.py

from app.extensions import db
from datetime import datetime, timezone
from enum import Enum
import json

class NotificationChannel(Enum):
    """알림 채널 타입"""
    EMAIL = "email"
    PUSH = "push"
    SMS = "sms"
    IN_APP = "in_app"
    SLACK = "slack"

class NotificationStatus(Enum):
    """알림 상태"""
    PENDING = "pending"
    SENT = "sent"
    FAILED = "failed"
    READ = "read"

class Notification(db.Model):
    """알림 시스템 기본 모델"""
    __tablename__ = "notifications"
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False, index=True)
    
    # 알림 정보
    title = db.Column(db.String(255), nullable=False)
    message = db.Column(db.Text, nullable=False)
    notification_type = db.Column(db.String(50), nullable=False, index=True)
    
    # 채널 및 상태
    channels = db.Column(db.JSON, nullable=False)  # [{"channel": "email", "status": "pending"}, ...]
    priority = db.Column(db.Integer, default=1)  # 1: 낮음, 2: 보통, 3: 높음, 4: 긴급
    
    # 링크 및 메타데이터
    action_url = db.Column(db.String(500))
    metadata = db.Column(db.JSON)  # 추가 데이터
    
    # 상태 관리
    status = db.Column(db.String(20), default=NotificationStatus.PENDING.value, index=True)
    is_read = db.Column(db.Boolean, default=False, index=True)
    
    # 타임스탬프
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    sent_at = db.Column(db.DateTime(timezone=True))
    read_at = db.Column(db.DateTime(timezone=True))
    expires_at = db.Column(db.DateTime(timezone=True))  # 만료 시간
    
    # 관계
    user = db.relationship("User", backref="notifications")
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if not self.channels:
            # 기본 채널 설정 (사용자 선호도에 따라 변경 가능)
            self.channels = [
                {"channel": NotificationChannel.IN_APP.value, "status": NotificationStatus.PENDING.value},
                {"channel": NotificationChannel.EMAIL.value, "status": NotificationStatus.PENDING.value}
            ]
    
    def __repr__(self):
        return f"<Notification {self.notification_type} for user {self.user_id}>"
    
    def mark_as_sent(self, channel=None):
        """특정 채널 또는 전체 알림을 발송 완료로 표시"""
        if channel:
            # 특정 채널만 업데이트
            for ch in self.channels:
                if ch["channel"] == channel:
                    ch["status"] = NotificationStatus.SENT.value
                    ch["sent_at"] = datetime.now(timezone.utc).isoformat()
        else:
            # 모든 채널 업데이트
            for ch in self.channels:
                if ch["status"] == NotificationStatus.PENDING.value:
                    ch["status"] = NotificationStatus.SENT.value
                    ch["sent_at"] = datetime.now(timezone.utc).isoformat()
            
            self.status = NotificationStatus.SENT.value
            self.sent_at = datetime.now(timezone.utc)
    
    def mark_as_read(self):
        """알림을 읽음으로 표시"""
        self.is_read = True
        self.read_at = datetime.now(timezone.utc)
        self.status = NotificationStatus.READ.value
    
    def to_dict(self):
        """사전 형태로 변환"""
        return {
            "id": self.id,
            "title": self.title,
            "message": self.message,
            "type": self.notification_type,
            "channels": self.channels,
            "action_url": self.action_url,
            "metadata": self.metadata,
            "is_read": self.is_read,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "read_at": self.read_at.isoformat() if self.read_at else None,
            "priority": self.priority
        }

class UserNotificationPreference(db.Model):
    """사용자 알림 선호도 설정"""
    __tablename__ = "user_notification_preferences"
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"), unique=True, nullable=False)
    
    # 채널별 설정
    email_enabled = db.Column(db.Boolean, default=True)
    push_enabled = db.Column(db.Boolean, default=True)
    sms_enabled = db.Column(db.Boolean, default=False)
    in_app_enabled = db.Column(db.Boolean, default=True)
    
    # 알림 유형별 설정 (JSON 형식)
    type_preferences = db.Column(db.JSON, default={
        "marketing": True,
        "security": True,
        "system": True,
        "social": True
    })
    
    # 사일런스 시간대
    quiet_hours_start = db.Column(db.Time, default=None)  # 22:00
    quiet_hours_end = db.Column(db.Time, default=None)    # 08:00
    
    # 다이제스트 설정
    digest_enabled = db.Column(db.Boolean, default=False)
    digest_frequency = db.Column(db.String(20), default="daily")  # daily, weekly
    digest_time = db.Column(db.Time, default=None)  # 09:00
    
    # 업데이트 시간
    updated_at = db.Column(db.DateTime(timezone=True), 
                          default=lambda: datetime.now(timezone.utc),
                          onupdate=lambda: datetime.now(timezone.utc))
    
    # 관계
    user = db.relationship("User", backref="notification_preference")
    
    def is_channel_enabled(self, channel: NotificationChannel) -> bool:
        """특정 채널이 활성화되었는지 확인"""
        channel_map = {
            NotificationChannel.EMAIL: self.email_enabled,
            NotificationChannel.PUSH: self.push_enabled,
            NotificationChannel.SMS: self.sms_enabled,
            NotificationChannel.IN_APP: self.in_app_enabled
        }
        return channel_map.get(channel, False)
    
    def is_quiet_time(self) -> bool:
        """현재 시간이 사일런스 시간대인지 확인"""
        if not self.quiet_hours_start or not self.quiet_hours_end:
            return False
        
        from datetime import datetime, time
        now = datetime.now().time()
        
        # 사일런스 시간대가 자정을 넘는 경우 처리
        if self.quiet_hours_start > self.quiet_hours_end:
            # 자정을 넘는 시간대 (예: 22:00 ~ 08:00)
            return self.quiet_hours_start <= now or now <= self.quiet_hours_end
        else:
            # 일반 시간대
            return self.quiet_hours_start <= now <= self.quiet_hours_end
```

#### 알림 서비스 구현

```python
# app/services/notification_service.py

from typing import List, Dict, Any, Optional
from datetime import datetime, timezone
from app.models.notification import Notification, UserNotificationPreference, NotificationChannel, NotificationStatus
from app.extensions import db, socketio
from app.tasks.email_tasks import send_notification_email_task
from app.tasks.push_tasks import send_push_notification_task
import logging

logger = logging.getLogger(__name__)

class NotificationService:
    """알림 서비스"""
    
    @staticmethod
    def create_notification(
        user_id: int,
        title: str,
        message: str,
        notification_type: str,
        channels: Optional[List[str]] = None,
        priority: int = 1,
        action_url: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
        expires_hours: int = 168  # 7일
    ) -> Notification:
        """새 알림 생성"""
        
        # 만료 시간 계산
        expires_at = datetime.now(timezone.utc) + timedelta(hours=expires_hours)
        
        # 채널 기본값 설정
        if channels is None:
            channels = [NotificationChannel.IN_APP.value, NotificationChannel.EMAIL.value]
        
        # 알림 생성
        notification = Notification(
            user_id=user_id,
            title=title,
            message=message,
            notification_type=notification_type,
            priority=priority,
            action_url=action_url,
            metadata=metadata or {},
            expires_at=expires_at
        )
        
        # 사용자 선호도에 따라 채널 조정
        notification.channels = NotificationService._filter_channels_by_preference(
            user_id, channels
        )
        
        db.session.add(notification)
        db.session.commit()
        
        # 비동기 발송 처리
        NotificationService._dispatch_notification(notification)
        
        return notification
    
    @staticmethod
    def _filter_channels_by_preference(user_id: int, requested_channels: List[str]) -> List[Dict]:
        """사용자 선호도에 따라 채널 필터링"""
        
        preference = UserNotificationPreference.query.filter_by(user_id=user_id).first()
        if not preference:
            # 기본 선호도 생성
            preference = UserNotificationPreference(user_id=user_id)
            db.session.add(preference)
            db.session.commit()
        
        filtered_channels = []
        
        for channel in requested_channels:
            # 채널 매핑
            channel_enum = NotificationChannel(channel)
            is_enabled = preference.is_channel_enabled(channel_enum)
            
            # 사일런스 시간대 확인 (푸시/이메일만 적용)
            if channel in [NotificationChannel.EMAIL.value, NotificationChannel.PUSH.value]:
                if preference.is_quiet_time():
                    logger.info(f"사일런스 시간대: {channel} 채널 알림 지연")
                    continue
            
            if is_enabled:
                filtered_channels.append({
                    "channel": channel,
                    "status": NotificationStatus.PENDING.value,
                    "scheduled_at": datetime.now(timezone.utc).isoformat()
                })
        
        return filtered_channels
    
    @staticmethod
    def _dispatch_notification(notification: Notification):
        """알림을 적절한 채널로 발송"""
        
        for channel_info in notification.channels:
            channel = channel_info["channel"]
            status = channel_info["status"]
            
            if status != NotificationStatus.PENDING.value:
                continue
            
            try:
                if channel == NotificationChannel.EMAIL.value:
                    # 이메일 발송 (비동기)
                    send_notification_email_task.delay(
                        notification_id=notification.id,
                        channel_info=channel_info
                    )
                    
                elif channel == NotificationChannel.PUSH.value:
                    # 푸시 알림 발송 (비동기)
                    send_push_notification_task.delay(
                        notification_id=notification.id,
                        channel_info=channel_info
                    )
                    
                elif channel == NotificationChannel.IN_APP.value:
                    # 인앱 알림 (실시간)
                    NotificationService._send_in_app_notification(notification)
                    
                elif channel == NotificationChannel.SMS.value:
                    # SMS 발송 (비동기)
                    from app.tasks.sms_tasks import send_sms_notification_task
                    send_sms_notification_task.delay(
                        notification_id=notification.id,
                        channel_info=channel_info
                    )
                    
                # 채널 상태 업데이트
                channel_info["status"] = NotificationStatus.SENT.value
                channel_info["sent_at"] = datetime.now(timezone.utc).isoformat()
                
            except Exception as e:
                logger.error(f"알림 발송 실패: 채널={channel}, 오류={str(e)}")
                channel_info["status"] = NotificationStatus.FAILED.value
                channel_info["error"] = str(e)
        
        # 알림 상태 업데이트
        notification.status = NotificationStatus.SENT.value
        notification.sent_at = datetime.now(timezone.utc)
        db.session.commit()
    
    @staticmethod
    def _send_in_app_notification(notification: Notification):
        """인앱 알림 전송 (WebSocket)"""
        
        try:
            socketio.emit(
                "notification:new",
                notification.to_dict(),
                room=f"user_{notification.user_id}",
                namespace="/notifications"
            )
            logger.info(f"인앱 알림 전송 완료: user_id={notification.user_id}")
        except Exception as e:
            logger.error(f"인앱 알림 전송 실패: {str(e)}")
    
    @staticmethod
    def get_user_notifications(user_id: int, limit: int = 50, unread_only: bool = False):
        """사용자 알림 목록 조회"""
        
        query = Notification.query.filter_by(user_id=user_id)
        
        if unread_only:
            query = query.filter_by(is_read=False)
        
        notifications = query.order_by(
            Notification.priority.desc(),
            Notification.created_at.desc()
        ).limit(limit).all()
        
        return [n.to_dict() for n in notifications]
    
    @staticmethod
    def mark_as_read(notification_id: int, user_id: int) -> bool:
        """알림을 읽음으로 표시"""
        
        notification = Notification.query.filter_by(
            id=notification_id,
            user_id=user_id
        ).first()
        
        if not notification:
            return False
        
        notification.mark_as_read()
        db.session.commit()
        
        return True
    
    @staticmethod
    def mark_all_as_read(user_id: int) -> int:
        """모든 알림을 읽음으로 표시"""
        
        result = Notification.query.filter_by(
            user_id=user_id,
            is_read=False
        ).update({"is_read": True, "read_at": datetime.now(timezone.utc)})
        
        db.session.commit()
        
        return result
```

#### 다이제스트 알림 서비스

```python
# app/services/digest_service.py

from celery import shared_task
from datetime import datetime, timezone, timedelta
from app.models.notification import Notification, UserNotificationPreference
from app.extensions import db
from app.services.notification_service import NotificationService
import logging

logger = logging.getLogger(__name__)

@shared_task
def generate_daily_digests():
    """일일 다이제스트 생성"""
    
    current_time = datetime.now(timezone.utc)
    start_time = current_time - timedelta(days=1)
    
    # 다이제스트 설정이 활성화된 사용자 조회
    users_with_digest = UserNotificationPreference.query.filter_by(
        digest_enabled=True,
        digest_frequency="daily"
    ).all()
    
    for preference in users_with_digest:
        try:
            # 지난 24시간 동안의 미확인 알림 조회
            notifications = Notification.query.filter(
                Notification.user_id == preference.user_id,
                Notification.created_at >= start_time,
                Notification.is_read == False
            ).order_by(Notification.created_at.desc()).all()
            
            if not notifications:
                continue
            
            # 다이제스트 알림 생성
            NotificationService.create_notification(
                user_id=preference.user_id,
                title="오늘의 알림 요약",
                message=f"지난 24시간 동안 {len(notifications)}개의 새로운 알림이 있습니다.",
                notification_type="digest",
                channels=["in_app", "email"],
                metadata={
                    "digest_period": "daily",
                    "notification_count": len(notifications),
                    "notifications": [n.to_dict() for n in notifications[:10]]  # 최근 10개만
                }
            )
            
            logger.info(f"다이제스트 생성 완료: user_id={preference.user_id}, count={len(notifications)}")
            
        except Exception as e:
            logger.error(f"다이제스트 생성 실패: user_id={preference.user_id}, 오류={str(e)}")

@shared_task
def generate_weekly_digests():
    """주간 다이제스트 생성"""
    
    current_time = datetime.now(timezone.utc)
    start_time = current_time - timedelta(weeks=1)
    
    users_with_digest = UserNotificationPreference.query.filter_by(
        digest_enabled=True,
        digest_frequency="weekly"
    ).all()
    
    for preference in users_with_digest:
        try:
            # 지난 일주일 동안의 알림 조회
            notifications = Notification.query.filter(
                Notification.user_id == preference.user_id,
                Notification.created_at >= start_time,
                Notification.is_read == False
            ).order_by(Notification.created_at.desc()).all()
            
            if len(notifications) < 3:  # 3개 미만이면 다이제스트 생성 안 함
                continue
            
            # 주간 다이제스트 생성
            NotificationService.create_notification(
                user_id=preference.user_id,
                title="이번 주 알림 요약",
                message=f"지난 주 동안 {len(notifications)}개의 새로운 알림이 있습니다.",
                notification_type="digest",
                channels=["in_app", "email"],
                metadata={
                    "digest_period": "weekly",
                    "notification_count": len(notifications),
                    "notifications": [n.to_dict() for n in notifications[:20]]  # 최근 20개만
                }
            )
            
            logger.info(f"주간 다이제스트 생성 완료: user_id={preference.user_id}, count={len(notifications)}")
            
        except Exception as e:
            logger.error(f"주간 다이제스트 생성 실패: user_id={preference.user_id}, 오류={str(e)}")
```

---

## 파일 처리 시스템

### 기본 파일 업로드 처리

안전하고 효율적인 파일 업로드 시스템을 구현하기 위한 핵심 요소들을 살펴보겠습니다.

#### 파일 업로드 설정

```python
# app/config.py

class Config:
    # 파일 업로드 설정
    MAX_CONTENT_LENGTH = 50 * 1024 * 1024  # 50MB
    UPLOAD_FOLDER = "/var/uploads"
    ALLOWED_EXTENSIONS = {
        "images": {"png", "jpg", "jpeg", "gif", "webp"},
        "documents": {"pdf", "doc", "docx", "xls", "xlsx", "ppt", "pptx"},
        "archives": {"zip", "rar", "7z"},
        "media": {"mp3", "mp4", "wav", "avi", "mov"}
    }
    
    # 보안 설정
    SECURE_FILENAME = True
    REQUIRE_MIME_VALIDATION = True
    SCAN_FOR_VIRUSES = True
    
    # 임시 파일 설정
    UPLOAD_TEMP_FOLDER = "/tmp/uploads"
    TEMP_FILE_EXPIRY = 3600  # 1시간

class DevelopmentConfig(Config):
    MAX_CONTENT_LENGTH = 10 * 1024 * 1024  # 10MB (개발 환경에서는 작게)
    UPLOAD_FOLDER = "./uploads"
    UPLOAD_TEMP_FOLDER = "./tmp/uploads"

class ProductionConfig(Config):
    MAX_CONTENT_LENGTH = 100 * 1024 * 1024  # 100MB
    UPLOAD_FOLDER = "/data/uploads"
    SCAN_FOR_VIRUSES = True  # 프로덕션에서는 항상 활성화
```

#### 파일 유틸리티 함수

```python
# app/utils/file_utils.py

import os
import uuid
import magic
import imghdr
from pathlib import Path
from werkzeug.utils import secure_filename
from typing import Optional, Tuple
from flask import current_app

class FileValidationError(Exception):
    """파일 검증 오류"""
    pass

class FileUtils:
    """파일 처리 유틸리티"""
    
    @staticmethod
    def generate_unique_filename(original_filename: str) -> str:
        """고유한 파일명 생성"""
        secure_name = secure_filename(original_filename)
        name, ext = os.path.splitext(secure_name)
        unique_id = uuid.uuid4().hex[:8]
        return f"{name}_{unique_id}{ext}"
    
    @staticmethod
    def get_allowed_extensions() -> set:
        """허용된 모든 확장자 집합 반환"""
        allowed = set()
        for category in current_app.config.get("ALLOWED_EXTENSIONS", {}).values():
            allowed.update(category)
        return allowed
    
    @staticmethod
    def is_extension_allowed(filename: str) -> bool:
        """확장자 허용 여부 확인"""
        ext = filename.rsplit(".", 1)[-1].lower() if "." in filename else ""
        return ext in FileUtils.get_allowed_extensions()
    
    @staticmethod
    def get_file_category(filename: str) -> Optional[str]:
        """파일 카테고리 확인"""
        ext = filename.rsplit(".", 1)[-1].lower() if "." in filename else ""
        
        for category, extensions in current_app.config.get("ALLOWED_EXTENSIONS", {}).items():
            if ext in extensions:
                return category
        
        return None
    
    @staticmethod
    def validate_file_mime(file_path: str, expected_category: str = None) -> Tuple[bool, str]:
        """
        파일 MIME 타입 검증
        
        Returns:
            (검증 결과, 실제 MIME 타입)
        """
        try:
            # libmagic을 사용한 MIME 타입 확인
            mime = magic.from_file(file_path, mime=True)
            
            # 카테고리별 허용 MIME 타입 매핑
            allowed_mimes = {
                "images": {"image/jpeg", "image/png", "image/gif", "image/webp"},
                "documents": {
                    "application/pdf",
                    "application/msword",
                    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                    "application/vnd.ms-excel",
                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    "application/vnd.ms-powerpoint",
                    "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                },
                "archives": {"application/zip", "application/x-rar-compressed", "application/x-7z-compressed"},
                "media": {"audio/mpeg", "video/mp4", "audio/wav", "video/x-msvideo", "video/quicktime"}
            }
            
            # 카테고리 제한이 있는 경우
            if expected_category:
                allowed = allowed_mimes.get(expected_category, set())
                if mime not in allowed:
                    return False, mime
            
            # 추가적인 이미지 헤더 검증
            if mime.startswith("image/"):
                # imghdr를 사용한 실제 이미지 형식 확인
                image_type = imghdr.what(file_path)
                if not image_type:
                    return False, mime
                
                # MIME 타입과 실제 이미지 형식 일치 확인
                expected_types = {
                    "jpeg": "image/jpeg",
                    "png": "image/png",
                    "gif": "image/gif",
                    "webp": "image/webp"
                }
                
                if image_type in expected_types and expected_types[image_type] != mime:
                    return False, mime
            
            return True, mime
            
        except Exception as e:
            current_app.logger.error(f"MIME 검증 실패: {file_path}, 오류: {str(e)}")
            return False, "unknown"
    
    @staticmethod
    def strip_exif_metadata(image_path: str, output_path: str = None) -> str:
        """
        이미지에서 EXIF 메타데이터 제거
        
        Args:
            image_path: 원본 이미지 경로
            output_path: 출력 경로 (None인 경우 원본 덮어쓰기)
            
        Returns:
            처리된 이미지 경로
        """
        try:
            from PIL import Image
            
            with Image.open(image_path) as img:
                # 이미지 데이터만 추출 (메타데이터 제외)
                data = list(img.getdata())
                
                # 새로운 이미지 생성
                clean_img = Image.new(img.mode, img.size)
                clean_img.putdata(data)
                
                # 저장
                output = output_path or image_path
                clean_img.save(output, format=img.format)
                
                return output
                
        except Exception as e:
            current_app.logger.error(f"EXIF 제거 실패: {image_path}, 오류: {str(e)}")
            raise FileValidationError(f"EXIF 메타데이터 제거 실패: {str(e)}")
    
    @staticmethod
    def create_thumbnail(
        image_path: str,
        output_path: str,
        max_size: Tuple[int, int] = (800, 800),
        quality: int = 85
    ) -> str:
        """
        썸네일 이미지 생성
        
        Args:
            image_path: 원본 이미지 경로
            output_path: 썸네일 저장 경로
            max_size: 최대 크기 (가로, 세로)
            quality: JPEG 품질 (1-100)
            
        Returns:
            썸네일 경로
        """
        try:
            from PIL import Image
            
            with Image.open(image_path) as img:
                # 비율 유지하며 리사이즈
                img.thumbnail(max_size, Image.Resampling.LANCZOS)
                
                # 저장
                img.save(output_path, optimize=True, quality=quality)
                
                return output_path
                
        except Exception as e:
            current_app.logger.error(f"썸네일 생성 실패: {image_path}, 오류: {str(e)}")
            raise FileValidationError(f"썸네일 생성 실패: {str(e)}")
```

#### 파일 업로드 엔드포인트

```python
# app/blueprints/files.py

import os
import tempfile
from flask import Blueprint, request, jsonify, current_app
from werkzeug.utils import secure_filename
from app.utils.file_utils import FileUtils, FileValidationError
from app.extensions import db
from app.models.file import FileUpload
from app.tasks.file_tasks import process_uploaded_file
import logging

logger = logging.getLogger(__name__)
bp = Blueprint("files", __name__, url_prefix="/api/files")

@bp.route("/upload", methods=["POST"])
def upload_file():
    """파일 업로드 엔드포인트"""
    
    # 파일 확인
    if "file" not in request.files:
        return jsonify({"error": "파일이 없습니다"}), 400
    
    file = request.files["file"]
    
    if file.filename == "":
        return jsonify({"error": "파일명이 없습니다"}), 400
    
    # 확장자 검증
    if not FileUtils.is_extension_allowed(file.filename):
        return jsonify({"error": "허용되지 않은 파일 형식입니다"}), 400
    
    # 파일 카테고리 확인
    file_category = FileUtils.get_file_category(file.filename)
    if not file_category:
        return jsonify({"error": "지원하지 않는 파일 형식입니다"}), 400
    
    try:
        # 임시 파일 저장
        temp_dir = current_app.config.get("UPLOAD_TEMP_FOLDER", "/tmp/uploads")
        os.makedirs(temp_dir, exist_ok=True)
        
        # 고유한 파일명 생성
        unique_filename = FileUtils.generate_unique_filename(file.filename)
        temp_path = os.path.join(temp_dir, unique_filename)
        
        # 임시 저장
        file.save(temp_path)
        
        # MIME 타입 검증
        if current_app.config.get("REQUIRE_MIME_VALIDATION", True):
            is_valid, actual_mime = FileUtils.validate_file_mime(temp_path, file_category)
            if not is_valid:
                os.remove(temp_path)
                return jsonify({
                    "error": f"파일 형식이 일치하지 않습니다 (예상: {file_category}, 실제: {actual_mime})"
                }), 400
        
        # 이미지 파일인 경우 EXIF 메타데이터 제거
        if file_category == "images":
            try:
                FileUtils.strip_exif_metadata(temp_path)
            except FileValidationError as e:
                logger.warning(f"EXIF 제거 실패 (계속 진행): {str(e)}")
        
        # 파일 업로드 기록 생성
        user_id = get_current_user_id()  # 인증된 사용자 ID 가져오기
        file_upload = FileUpload(
            user_id=user_id,
            original_filename=file.filename,
            stored_filename=unique_filename,
            file_size=os.path.getsize(temp_path),
            file_category=file_category,
            status="uploaded"
        )
        
        db.session.add(file_upload)
        db.session.flush()  # ID 생성
        
        # 비동기 처리 태스크 실행
        process_uploaded_file.delay(
            temp_path=temp_path,
            upload_id=file_upload.id,
            user_id=user_id,
            file_category=file_category
        )
        
        db.session.commit()
        
        return jsonify({
            "upload_id": file_upload.id,
            "filename": file.filename,
            "size": file_upload.file_size,
            "status": "processing"
        }), 202
        
    except Exception as e:
        logger.error(f"파일 업로드 실패: {str(e)}")
        return jsonify({"error": "파일 업로드 중 오류가 발생했습니다"}), 500

@bp.route("/uploads/<int:upload_id>/status", methods=["GET"])
def get_upload_status(upload_id):
    """업로드 상태 조회"""
    
    file_upload = FileUpload.query.get_or_404(upload_id)
    
    # 권한 확인 (자신의 파일만 조회 가능)
    user_id = get_current_user_id()
    if file_upload.user_id != user_id:
        return jsonify({"error": "접근 권한이 없습니다"}), 403
    
    return jsonify({
        "upload_id": file_upload.id,
        "filename": file_upload.original_filename,
        "size": file_upload.file_size,
        "status": file_upload.status,
        "message": file_upload.processing_message,
        "url": file_upload.public_url,
        "created_at": file_upload.created_at.isoformat() if file_upload.created_at else None,
        "processed_at": file_upload.processed_at.isoformat() if file_upload.processed_at else None
    })

def get_current_user_id():
    """현재 인증된 사용자 ID 가져오기 (구현 필요)"""
    # 실제 구현에서는 Flask-Login, JWT 등 인증 시스템과 통합
    return 1  # 예시 값
```

### 파일 모델

```python
# app/models/file.py

from app.extensions import db
from datetime import datetime, timezone

class FileUpload(db.Model):
    """파일 업로드 기록"""
    __tablename__ = "file_uploads"
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False, index=True)
    
    # 파일 정보
    original_filename = db.Column(db.String(500), nullable=False)
    stored_filename = db.Column(db.String(500), nullable=False, unique=True)
    file_size = db.Column(db.BigInteger, nullable=False)  # 바이트 단위
    file_category = db.Column(db.String(50), nullable=False)  # images, documents 등
    
    # 저장 정보
    storage_provider = db.Column(db.String(50), default="local")  # local, s3, gcs 등
    storage_path = db.Column(db.String(1000))  # 저장 경로 또는 키
    public_url = db.Column(db.String(1000))  # 공개 접근 URL
    
    # 메타데이터
    mime_type = db.Column(db.String(100))
    width = db.Column(db.Integer)  # 이미지인 경우
    height = db.Column(db.Integer)  # 이미지인 경우
    duration = db.Column(db.Integer)  # 미디어인 경우 (초)
    
    # 상태 관리
    status = db.Column(db.String(20), default="pending", index=True)  # pending, uploaded, processing, completed, failed
    processing_message = db.Column(db.Text)
    virus_scan_result = db.Column(db.String(50))  # clean, infected, error
    
    # 보안 정보
    md5_hash = db.Column(db.String(32))
    sha256_hash = db.Column(db.String(64))
    
    # 타임스탬프
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    uploaded_at = db.Column(db.DateTime(timezone=True))
    processed_at = db.Column(db.DateTime(timezone=True))
    expires_at = db.Column(db.DateTime(timezone=True))  # 임시 파일 만료 시간
    
    # 관계
    user = db.relationship("User", backref="file_uploads")
    
    # 색인
    __table_args__ = (
        db.Index("ix_file_uploads_user_status", "user_id", "status"),
        db.Index("ix_file_uploads_created_at", "created_at"),
    )
    
    def __repr__(self):
        return f"<FileUpload {self.original_filename} ({self.status})>"
    
    def mark_as_uploaded(self):
        """업로드 완료로 표시"""
        self.status = "uploaded"
        self.uploaded_at = datetime.now(timezone.utc)
    
    def mark_as_processing(self, message=None):
        """처리 중으로 표시"""
        self.status = "processing"
        self.processing_message = message
    
    def mark_as_completed(self, public_url=None, message=None):
        """처리 완료로 표시"""
        self.status = "completed"
        self.processed_at = datetime.now(timezone.utc)
        self.processing_message = message
        
        if public_url:
            self.public_url = public_url
    
    def mark_as_failed(self, message):
        """처리 실패로 표시"""
        self.status = "failed"
        self.processed_at = datetime.now(timezone.utc)
        self.processing_message = message
    
    def get_file_extension(self):
        """파일 확장자 추출"""
        return self.original_filename.rsplit(".", 1)[-1].lower() if "." in self.original_filename else ""
    
    def get_human_readable_size(self):
        """사람이 읽기 쉬운 파일 크기 형식으로 변환"""
        if self.file_size < 1024:
            return f"{self.file_size} B"
        elif self.file_size < 1024 * 1024:
            return f"{self.file_size / 1024:.1f} KB"
        elif self.file_size < 1024 * 1024 * 1024:
            return f"{self.file_size / (1024 * 1024):.1f} MB"
        else:
            return f"{self.file_size / (1024 * 1024 * 1024):.1f} GB"
```

### 바이러스 스캔 및 파일 처리

```python
# app/services/virus_scanner.py

import os
import subprocess
import tempfile
from typing import Tuple, Optional
import logging

logger = logging.getLogger(__name__)

class VirusScanner:
    """바이러스 스캐너"""
    
    def __init__(self, clamav_host="localhost", clamav_port=3310, timeout=30):
        self.clamav_host = clamav_host
        self.clamav_port = clamav_port
        self.timeout = timeout
    
    def scan_file(self, file_path: str) -> Tuple[bool, Optional[str]]:
        """
        파일 바이러스 스캔
        
        Returns:
            (스캔 결과, 발견된 바이러스 이름 또는 오류 메시지)
            스캔 결과: True=안전, False=감염 또는 오류
        """
        
        if not os.path.exists(file_path):
            return False, "파일이 존재하지 않습니다"
        
        try:
            # ClamAV 네트워크 스캔
            import clamd
            
            cd = clamd.ClamdNetworkSocket(
                host=self.clamav_host,
                port=self.clamav_port,
                timeout=self.timeout
            )
            
            # 핑 테스트
            try:
                cd.ping()
            except Exception as e:
                logger.warning(f"ClamAV 연결 실패: {str(e)}")
                return False, f"ClamAV 연결 실패: {str(e)}"
            
            # 파일 스캔
            scan_result = cd.scan(file_path)
            
            # 결과 파싱
            for path, result in scan_result.items():
                status, virus_name = result
                
                if status == "FOUND":
                    logger.warning(f"바이러스 발견: {file_path}, 바이러스: {virus_name}")
                    return False, virus_name
                elif status == "ERROR":
                    logger.error(f"스캔 오류: {file_path}, 오류: {virus_name}")
                    return False, f"스캔 오류: {virus_name}"
                elif status == "OK":
                    return True, None
            
            return True, None
            
        except ImportError:
            # ClamAV 라이브러리가 없을 경우 대체 방법
            logger.warning("clamd 모듈을 사용할 수 없어 대체 스캔 방법 사용")
            return self._scan_with_clamdscan(file_path)
            
        except Exception as e:
            logger.error(f"바이러스 스캔 중 오류: {str(e)}")
            return False, f"스캔 중 오류 발생: {str(e)}"
    
    def _scan_with_clamdscan(self, file_path: str) -> Tuple[bool, Optional[str]]:
        """clamdscan 명령어를 사용한 스캔"""
        
        try:
            # 명령어 실행
            result = subprocess.run(
                ["clamdscan", "--stdout", file_path],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            # 결과 분석
            if result.returncode == 0:
                # 스캔 완료, 바이러스 없음
                return True, None
            elif result.returncode == 1:
                # 바이러스 발견
                # 출력 형식: "/path/to/file: VirusName FOUND"
                lines = result.stdout.strip().split("\n")
                for line in lines:
                    if "FOUND" in line:
                        virus_name = line.split(":")[1].strip().replace(" FOUND", "")
                        return False, virus_name
                return False, "바이러스 발견 (이름 확인 불가)"
            else:
                # 오류
                return False, f"스캔 오류: {result.stderr}"
                
        except subprocess.TimeoutExpired:
            return False, "스캔 시간 초과"
        except FileNotFoundError:
            return False, "clamdscan 명령어를 찾을 수 없습니다"
        except Exception as e:
            return False, f"스캔 중 오류: {str(e)}"
    
    def scan_with_quarantine(self, file_path: str, quarantine_dir: str) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        격리 폴더를 사용한 안전한 스캔
        
        Returns:
            (스캔 결과, 바이러스 이름, 격리 경로)
        """
        
        # 격리 폴더 생성
        os.makedirs(quarantine_dir, exist_ok=True)
        
        # 임시 복사본 생성
        import shutil
        import uuid
        
        temp_copy = os.path.join(quarantine_dir, f"scan_{uuid.uuid4().hex}")
        shutil.copy2(file_path, temp_copy)
        
        try:
            # 복사본 스캔
            is_clean, virus_name = self.scan_file(temp_copy)
            
            if is_clean:
                # 안전한 파일: 원본 사용, 임시 복사본 삭제
                os.remove(temp_copy)
                return True, None, None
            else:
                # 감염된 파일: 격리
                quarantine_path = os.path.join(
                    quarantine_dir,
                    f"infected_{os.path.basename(file_path)}_{uuid.uuid4().hex}"
                )
                os.rename(temp_copy, quarantine_path)
                
                logger.warning(f"파일 격리: {file_path} -> {quarantine_path}, 바이러스: {virus_name}")
                return False, virus_name, quarantine_path
                
        except Exception as e:
            # 오류 발생 시 정리
            if os.path.exists(temp_copy):
                os.remove(temp_copy)
            raise

# 싱글톤 인스턴스
virus_scanner = VirusScanner()
```

#### 파일 처리 태스크

```python
# app/tasks/file_tasks.py

import os
import hashlib
from celery import shared_task
from flask import current_app
from app.extensions import db
from app.models.file import FileUpload
from app.services.virus_scanner import virus_scanner
from app.utils.file_utils import FileUtils
from app.services.storage import StorageService
import logging

logger = logging.getLogger(__name__)

@shared_task(
    bind=True,
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_backoff_max=300,  # 최대 5분
    retry_jitter=True,
    max_retries=3
)
def process_uploaded_file(
    self,
    temp_path: str,
    upload_id: int,
    user_id: int,
    file_category: str
):
    """업로드된 파일 처리 태스크"""
    
    file_upload = FileUpload.query.get(upload_id)
    if not file_upload:
        logger.error(f"파일 업로드 기록을 찾을 수 없음: {upload_id}")
        return
    
    try:
        # 상태 업데이트
        file_upload.mark_as_processing("파일 처리 중...")
        db.session.commit()
        
        # 1. 바이러스 스캔
        if current_app.config.get("SCAN_FOR_VIRUSES", False):
            file_upload.mark_as_processing("바이러스 검사 중...")
            db.session.commit()
            
            is_clean, virus_name = virus_scanner.scan_file(temp_path)
            
            if not is_clean:
                file_upload.virus_scan_result = "infected"
                file_upload.mark_as_failed(f"바이러스 발견: {virus_name}")
                db.session.commit()
                
                # 임시 파일 삭제
                if os.path.exists(temp_path):
                    os.remove(temp_path)
                
                logger.warning(f"바이러스 파일 차단: {temp_path}, 바이러스: {virus_name}")
                return
        
        file_upload.virus_scan_result = "clean"
        
        # 2. 해시 계산
        file_upload.mark_as_processing("무결성 검사 중...")
        db.session.commit()
        
        md5_hash, sha256_hash = calculate_file_hashes(temp_path)
        file_upload.md5_hash = md5_hash
        file_upload.sha256_hash = sha256_hash
        
        # 3. 파일 메타데이터 추출
        if file_category == "images":
            file_upload.mark_as_processing("이미지 메타데이터 추출 중...")
            db.session.commit()
            
            from PIL import Image
            try:
                with Image.open(temp_path) as img:
                    file_upload.width, file_upload.height = img.size
                    file_upload.mime_type = f"image/{img.format.lower()}" if img.format else "image/jpeg"
            except Exception as e:
                logger.warning(f"이미지 메타데이터 추출 실패: {str(e)}")
        
        # 4. 영구 저장소에 업로드
        file_upload.mark_as_processing("저장소에 업로드 중...")
        db.session.commit()
        
        storage_service = StorageService()
        storage_info = storage_service.upload_file(
            temp_path=temp_path,
            original_filename=file_upload.original_filename,
            file_category=file_category,
            user_id=user_id
        )
        
        # 5. 썸네일 생성 (이미지인 경우)
        if file_category == "images":
            try:
                thumbnail_path = temp_path + "_thumb"
                FileUtils.create_thumbnail(
                    temp_path,
                    thumbnail_path,
                    max_size=(400, 400),
                    quality=75
                )
                
                thumbnail_info = storage_service.upload_file(
                    temp_path=thumbnail_path,
                    original_filename=f"thumb_{file_upload.original_filename}",
                    file_category="images",
                    user_id=user_id,
                    is_thumbnail=True
                )
                
                # 썸네일 정보 저장
                file_upload.thumbnail_url = thumbnail_info["public_url"]
                
                # 임시 썸네일 삭제
                if os.path.exists(thumbnail_path):
                    os.remove(thumbnail_path)
                    
            except Exception as e:
                logger.warning(f"썸네일 생성 실패: {str(e)}")
        
        # 6. 완료 처리
        file_upload.storage_provider = storage_info["provider"]
        file_upload.storage_path = storage_info["storage_path"]
        file_upload.public_url = storage_info["public_url"]
        file_upload.mark_as_completed(
            public_url=storage_info["public_url"],
            message="파일 처리 완료"
        )
        
        db.session.commit()
        
        logger.info(f"파일 처리 완료: {file_upload.original_filename}, URL: {file_upload.public_url}")
        
        # 7. 임시 파일 정리
        if os.path.exists(temp_path):
            os.remove(temp_path)
        
        return {
            "upload_id": upload_id,
            "public_url": file_upload.public_url,
            "file_size": file_upload.file_size,
            "status": "completed"
        }
        
    except Exception as e:
        logger.error(f"파일 처리 실패: {str(e)}")
        
        # 실패 처리
        file_upload.mark_as_failed(f"처리 실패: {str(e)}")
        db.session.commit()
        
        # 임시 파일 정리
        if os.path.exists(temp_path):
            try:
                os.remove(temp_path)
            except:
                pass
        
        raise

def calculate_file_hashes(file_path: str) -> Tuple[str, str]:
    """파일 해시 계산"""
    
    md5 = hashlib.md5()
    sha256 = hashlib.sha256()
    
    with open(file_path, "rb") as f:
        # 대용량 파일을 위해 청크 단위로 읽기
        for chunk in iter(lambda: f.read(4096), b""):
            md5.update(chunk)
            sha256.update(chunk)
    
    return md5.hexdigest(), sha256.hexdigest()
```

### 클라우드 저장소 통합

```python
# app/services/storage.py

import os
import boto3
from botocore.exceptions import ClientError
from datetime import datetime, timedelta
from typing import Dict, Any, Optional
from flask import current_app
import uuid

class StorageService:
    """저장소 서비스 (다중 클라우드 지원)"""
    
    def __init__(self, provider=None):
        self.provider = provider or current_app.config.get("DEFAULT_STORAGE_PROVIDER", "s3")
        
        if self.provider == "s3":
            self.client = self._init_s3_client()
        elif self.provider == "gcs":
            self.client = self._init_gcs_client()
        elif self.provider == "azure":
            self.client = self._init_azure_client()
        else:
            self.client = None  # 로컬 저장소
    
    def _init_s3_client(self):
        """AWS S3 클라이언트 초기화"""
        return boto3.client(
            "s3",
            aws_access_key_id=current_app.config.get("AWS_ACCESS_KEY_ID"),
            aws_secret_access_key=current_app.config.get("AWS_SECRET_ACCESS_KEY"),
            region_name=current_app.config.get("AWS_REGION", "ap-northeast-2")
        )
    
    def _init_gcs_client(self):
        """Google Cloud Storage 클라이언트 초기화"""
        # GCS 클라이언트 초기화 로직
        pass
    
    def _init_azure_client(self):
        """Azure Blob Storage 클라이언트 초기화"""
        # Azure 클라이언트 초기화 로직
        pass
    
    def upload_file(
        self,
        temp_path: str,
        original_filename: str,
        file_category: str,
        user_id: int,
        is_thumbnail: bool = False
    ) -> Dict[str, Any]:
        """파일을 저장소에 업로드"""
        
        if self.provider == "s3":
            return self._upload_to_s3(temp_path, original_filename, file_category, user_id, is_thumbnail)
        elif self.provider == "local":
            return self._upload_to_local(temp_path, original_filename, file_category, user_id, is_thumbnail)
        else:
            raise ValueError(f"지원하지 않는 저장소 제공자: {self.provider}")
    
    def _upload_to_s3(
        self,
        temp_path: str,
        original_filename: str,
        file_category: str,
        user_id: int,
        is_thumbnail: bool
    ) -> Dict[str, Any]:
        """S3에 파일 업로드"""
        
        bucket = current_app.config.get("S3_BUCKET")
        if not bucket:
            raise ValueError("S3_BUCKET 설정이 필요합니다")
        
        # 저장 경로 생성
        date_str = datetime.now().strftime("%Y/%m/%d")
        unique_id = uuid.uuid4().hex[:8]
        file_ext = os.path.splitext(original_filename)[1]
        
        if is_thumbnail:
            key = f"thumbnails/{date_str}/{user_id}/{unique_id}{file_ext}"
        else:
            key = f"{file_category}/{date_str}/{user_id}/{unique_id}{file_ext}"
        
        # MIME 타입 확인
        import mimetypes
        content_type = mimetypes.guess_type(original_filename)[0] or "application/octet-stream"
        
        # 업로드
        try:
            self.client.upload_file(
                temp_path,
                bucket,
                key,
                ExtraArgs={
                    "ContentType": content_type,
                    "Metadata": {
                        "original-filename": original_filename,
                        "user-id": str(user_id),
                        "uploaded-at": datetime.now().isoformat()
                    }
                }
            )
            
            # 공개 URL 생성 (CloudFront가 있다면 CloudFront URL 사용)
            cdn_url = current_app.config.get("CDN_URL")
            if cdn_url:
                public_url = f"{cdn_url}/{key}"
            else:
                public_url = f"https://{bucket}.s3.amazonaws.com/{key}"
            
            return {
                "provider": "s3",
                "bucket": bucket,
                "key": key,
                "public_url": public_url,
                "storage_path": key
            }
            
        except ClientError as e:
            raise Exception(f"S3 업로드 실패: {str(e)}")
    
    def _upload_to_local(
        self,
        temp_path: str,
        original_filename: str,
        file_category: str,
        user_id: int,
        is_thumbnail: bool
    ) -> Dict[str, Any]:
        """로컬 저장소에 파일 업로드"""
        
        upload_dir = current_app.config.get("UPLOAD_FOLDER", "./uploads")
        
        # 저장 경로 생성
        date_str = datetime.now().strftime("%Y/%m/%d")
        unique_id = uuid.uuid4().hex[:8]
        file_ext = os.path.splitext(original_filename)[1]
        
        if is_thumbnail:
            relative_path = f"thumbnails/{date_str}/{user_id}/{unique_id}{file_ext}"
        else:
            relative_path = f"{file_category}/{date_str}/{user_id}/{unique_id}{file_ext}"
        
        full_path = os.path.join(upload_dir, relative_path)
        
        # 디렉토리 생성
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        # 파일 복사
        import shutil
        shutil.copy2(temp_path, full_path)
        
        # 공개 URL 생성
        public_url = f"/uploads/{relative_path}"
        
        return {
            "provider": "local",
            "path": full_path,
            "public_url": public_url,
            "storage_path": relative_path
        }
    
    def generate_presigned_url(
        self,
        key: str,
        expiration: int = 3600,
        filename: Optional[str] = None,
        content_type: Optional[str] = None
    ) -> str:
        """서명된 URL 생성 (다운로드용)"""
        
        if self.provider != "s3":
            raise ValueError("서명된 URL은 S3에서만 지원합니다")
        
        params = {
            "Bucket": current_app.config.get("S3_BUCKET"),
            "Key": key
        }
        
        # 추가 파라미터
        extra_args = {}
        
        if filename:
            extra_args["ResponseContentDisposition"] = f'attachment; filename="{filename}"'
        
        if content_type:
            extra_args["ResponseContentType"] = content_type
        
        if extra_args:
            params.update(extra_args)
        
        try:
            url = self.client.generate_presigned_url(
                "get_object",
                Params=params,
                ExpiresIn=expiration
            )
            return url
            
        except ClientError as e:
            raise Exception(f"서명된 URL 생성 실패: {str(e)}")
    
    def generate_upload_url(
        self,
        key: str,
        content_type: str,
        expiration: int = 3600,
        max_size: Optional[int] = None
    ) -> str:
        """업로드용 서명된 URL 생성"""
        
        if self.provider != "s3":
            raise ValueError("업로드용 서명된 URL은 S3에서만 지원합니다")
        
        params = {
            "Bucket": current_app.config.get("S3_BUCKET"),
            "Key": key,
            "ContentType": content_type
        }
        
        # 조건 추가 (선택사항)
        conditions = []
        
        if max_size:
            conditions.append(["content-length-range", 1, max_size])
        
        if conditions:
            params["Conditions"] = conditions
        
        try:
            url = self.client.generate_presigned_url(
                "put_object",
                Params=params,
                ExpiresIn=expiration
            )
            return url
            
        except ClientError as e:
            raise Exception(f"업로드 URL 생성 실패: {str(e)}")
```

---

## 결론

이메일, 알림, 파일 처리 시스템은 현대적인 웹 애플리케이션의 핵심 기능입니다. 이러한 시스템을 효과적으로 구현하고 운영하기 위해서는 몇 가지 중요한 원칙을 준수해야 합니다.

**첫째, 보안을 최우선으로 고려해야 합니다.** 파일 업로드 시스템에서는 확장자 검증, MIME 타입 확인, 바이러스 스캔을 필수적으로 구현해야 합니다. 이메일 시스템에서는 SPF, DKIM, DMARC와 같은 도메인 인증 설정이 스팸 필터링을 방지하는 데 중요합니다.

**둘째, 사용자 경험을 고려한 설계가 필요합니다.** 알림 시스템은 사용자의 선호도에 따라 다양한 채널(이메일, 푸시, 인앱 등)을 지원해야 하며, 사일런스 시간대 설정과 같은 기능을 통해 사용자가 방해받지 않도록 해야 합니다. 파일 업로드 시에는 진행률 표시와 실시간 상태 업데이트가 사용자 경험을 크게 향상시킵니다.

**셋째, 시스템의 견고성과 확장성을 보장해야 합니다.** 대량 이메일 발송이나 대용량 파일 처리는 백그라운드 작업으로 처리하고, 재시도 메커니즘과 회로 차단기 패턴을 적용하여 시스템의 안정성을 높여야 합니다. 클라우드 저장소와의 통합은 시스템의 확장성과 비용 효율성을 개선합니다.

**넷째, 모니터링과 관측 가능성을 확보해야 합니다.** 모든 이메일 발송, 알림 전송, 파일 업로드는 상세한 로깅과 메트릭 수집이 필요합니다. 이를 통해 문제 발생 시 빠르게 진단하고, 시스템 성능을 지속적으로 개선할 수 있습니다.

**다섯째, 법적 및 규제 요구사항을 준수해야 합니다.** 개인정보 보호 규정(GDPR, CCPA 등)에 따라 사용자 데이터를 적절히 관리하고, 파일 보존 정책을 수립하며, 사용자 동의를 기반으로 한 마케팅 커뮤니케이션을 구현해야 합니다.

이러한 원칙들을 바탕으로 체계적인 이메일, 알림, 파일 처리 시스템을 구축하면, 사용자에게 풍부한 기능을 제공하면서도 안정적이고 확장 가능한 애플리케이션을 운영할 수 있을 것입니다. 각 기능은 독립적으로도 유용하지만, 통합적으로 구현할 때 시너지 효과를 발휘하여 전반적인 사용자 경험을 크게 향상시킬 수 있습니다.