---
layout: post
title: flask - 이메일, 알림 & 파일 처리
date: 2025-09-21 15:25:23 +0900
category: flask
---
# 13. 이메일/알림 & 파일 처리

> 이 장은 **Flask에서 이메일/알림(Flask-Mail/SMTP, 대량 발송 시 큐 연계)** 와 **파일 업로드/다운로드(대용량 처리, 바이러스 스캔, 서명 URL)** 을 “운영 실전” 기준으로 정리한다.  
> 모든 코드는 ``` 로 감싸고, 수식이 필요하면 반드시 $$...$$ 로 표기한다(본 장은 수식이 거의 없다).

---

## 13.1 큰그림

- **이메일**
  - SMTP(Flask-Mail), 템플릿/Jinja, 첨부/인라인 이미지, 재시도/타임아웃, 실패 감지
  - **대량 발송**: 큐(Celery/RQ) + 속도 제한(rate limit) + 멱등성 + 옵트아웃
  - 프로덕션: **SPF/DKIM/DMARC**, 바운스/스팸 트래핑, 발송 로그, 사용자 선호 설정
- **알림**
  - 채널: 이메일, 웹푸시/모바일 푸시, SMS, 인앱(실시간 SocketIO)
  - 선호/사일런스 윈도, 데일리 다이제스트, 중복 억제, 템플릿 버저닝
- **파일 처리**
  - 업로드 제한/화이트리스트, MIME 스니핑, 임시 저장, **바이러스 스캔(ClamAV)**, 메타데이터 보정
  - 대용량 업로드(청크/멀티파트), 대용량 다운로드(스트리밍/Range/**X-Accel-Redirect**)
  - **서명 URL(S3/GCS/Azure)**, 권한/만료/Content-Disposition, 감사 로깅
  - 보관/삭제 정책(수명 주기), 암호화(전송/정지), 개인정보(PII) 규정 준수

---

## 13.2 Flask-Mail + SMTP 기본

### 13.2.1 설치/초기화

```bash
pip install Flask-Mail
```

```python
# app/extensions.py
from flask_mail import Mail

mail = Mail()

def init_mail(app):
    app.config.setdefault("MAIL_SERVER", "smtp.gmail.com")
    app.config.setdefault("MAIL_PORT", 587)
    app.config.setdefault("MAIL_USE_TLS", True)
    app.config.setdefault("MAIL_USERNAME", "username")
    app.config.setdefault("MAIL_PASSWORD", "password")
    app.config.setdefault("MAIL_DEFAULT_SENDER", ("Example", "noreply@example.com"))
    app.config.setdefault("MAIL_MAX_EMAILS", 50)   # 연결 유지 중 최대 발송 수
    mail.init_app(app)
```

### 13.2.2 싱글 메일 발송(템플릿, 첨부)

```python
# app/emails/send.py
from flask_mail import Message
from flask import render_template, current_app
from app.extensions import mail

def send_welcome(user):
    msg = Message(
        subject=f"[{current_app.config.get('APP_NAME','App')}] Welcome, {user.name}",
        recipients=[user.email],
    )
    msg.body = render_template("emails/welcome.txt", user=user)
    msg.html = render_template("emails/welcome.html", user=user)
    # 첨부(Optional)
    # with current_app.open_resource("static/logo.png") as fp:
    #     msg.attach("logo.png", "image/png", fp.read(), "inline", headers=[["Content-ID", "<logo>"]])
    mail.send(msg)
```

템플릿 예:

```html
<!-- templates/emails/welcome.html -->
<!doctype html>
<html><body>
  <h1>{{ _("Welcome, %(name)s!", name=user.name) }}</h1>
  <p>{{ _("Thanks for joining us.") }}</p>
  <!-- <img src="cid:logo" alt="logo"> -->
</body></html>
```

```txt
# templates/emails/welcome.txt
{{ _("Welcome, %(name)s!", name=user.name) }}
{{ _("Thanks for joining us.") }}
```

### 13.2.3 타임아웃/재시도/예외 처리

```python
# app/emails/utils.py
import socket
from smtplib import SMTPException
from flask import current_app
from app.emails.send import mail, Message

def safe_send(msg: Message, attempts=3, timeout=10):
    # Flask-Mail은 내부 smtplib 사용. 글로벌 소켓 타임아웃 설정(옵션).
    socket.setdefaulttimeout(timeout)
    for i in range(attempts):
        try:
            mail.send(msg)
            return True
        except (SMTPException, OSError) as e:
            current_app.logger.warning("email.send_error[%s/%s]: %s", i+1, attempts, e)
    return False
```

---

## 13.3 대량 발송(큐 연계, 속도 제한, 옵트아웃)

### 13.3.1 큐(Celery)로 오프로딩

```python
# app/tasks/mailer.py
from celery import shared_task
from flask import render_template
from flask_mail import Message
from app.extensions import mail

@shared_task(bind=True, autoretry_for=(Exception,), retry_backoff=2, max_retries=5)
def send_bulk_email(self, subject: str, recipients: list[str], template: str, context: dict):
    # 대량은 수신자 당 개별 메시지(개인화, BCC 금지 권장)
    sent = 0
    with mail.connect() as conn:
        for rcpt in recipients:
            msg = Message(subject=subject, recipients=[rcpt])
            msg.body = render_template(f"emails/{template}.txt", **context, email=rcpt)
            msg.html = render_template(f"emails/{template}.html", **context, email=rcpt)
            conn.send(msg)
            sent += 1
    return {"sent": sent, "total": len(recipients)}
```

API에서 큐잉:

```python
# app/blueprints/admin/newsletter.py
from flask import Blueprint, request
from app.tasks.mailer import send_bulk_email

bp = Blueprint("newsletter", __name__, url_prefix="/admin/newsletter")

@bp.post("/send")
def send():
    payload = request.get_json()
    job = send_bulk_email.delay(
        subject=payload["subject"],
        recipients=payload["recipients"],   # 최대 1k/배치 권장
        template=payload["template"],
        context=payload.get("context", {}),
    )
    return {"task_id": job.id}, 202
```

### 13.3.2 속도 제한/메시지 간격

- SMTP 벤더(SES, SendGrid 등) **1초당/분당 제한** 존재 → 큐에서 **sleep 또는 토큰 버킷**.

```python
import time, threading
from collections import deque

class TokenBucket:
    def __init__(self, rate_per_sec, burst=1):
        self.rate = rate_per_sec; self.capacity = burst; self.tokens = burst
        self.ts = time.monotonic(); self.lock = threading.Lock()
    def take(self, n=1):
        with self.lock:
            now = time.monotonic()
            self.tokens = min(self.capacity, self.tokens + (now - self.ts) * self.rate)
            self.ts = now
            if self.tokens >= n:
                self.tokens -= n
                return True
            return False

bucket = TokenBucket(rate_per_sec=10, burst=20)  # 초당 10통, 버스트 20

def throttle_send(conn, msg):
    while not bucket.take():
        time.sleep(0.05)
    conn.send(msg)
```

### 13.3.3 옵트아웃/바운스/멱등성

- **옵트아웃 테이블**(email, reason, at) 관리 → 빌드 시 **제외**.
- **멱등성**: 캠페인 ID + 수신자 email로 **unique key** → 중복 발송 방지.
- **바운스 처리**: 벤더 webhook → 비유효 주소 **블랙리스트** 업데이트.
- **SPF/DKIM/DMARC** 설정: 발신 도메인 신뢰성, 스팸함 방지(운영 DNS).

---

## 13.4 알림 시스템(채널, 선호, 다이제스트, 인앱)

### 13.4.1 모델링

```python
# app/models/notification.py
from app.extensions import db
from datetime import datetime, timezone

class Notification(db.Model):
    __tablename__ = "notifications"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, index=True, nullable=False)
    type = db.Column(db.String(50), index=True)      # 'comment', 'payment', ...
    payload = db.Column(db.JSON, nullable=False)
    is_read = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))

class NotifyPreference(db.Model):
    __tablename__ = "notify_prefs"
    user_id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.Boolean, default=True)
    push = db.Column(db.Boolean, default=False)
    inapp = db.Column(db.Boolean, default=True)
    quiet_from = db.Column(db.Time, nullable=True)   # 사일런스 윈도
    quiet_to = db.Column(db.Time, nullable=True)
```

### 13.4.2 인앱(실시간) + 다이제스트

- **인앱**: 저장 후 SocketIO로 푸시
- **다이제스트**: 시간별 배치(예: 매일 9시 미리 요약)

```python
# app/notifications/service.py
from app.models.notification import Notification, NotifyPreference
from app.extensions import db
from app.realtime import socketio

def emit_inapp(user_id: int, notif: dict):
    socketio.emit("notify:new", notif, to=f"user_{user_id}", namespace="/notify")

def create_notification(user_id: int, type: str, payload: dict):
    n = Notification(user_id=user_id, type=type, payload=payload)
    db.session.add(n); db.session.commit()
    # 인앱 설정인 경우만 푸시
    pref = NotifyPreference.query.get(user_id)
    if not pref or pref.inapp:
        emit_inapp(user_id, {"id": n.id, "type": n.type, "payload": n.payload})
```

다이제스트 작업(Celery 스케줄링):

```python
# app/tasks/digest.py
from celery import shared_task
from app.models.notification import Notification, NotifyPreference
from app.extensions import db
from flask_mail import Message
from app.extensions import mail
from flask import render_template

@shared_task
def daily_digest():
    # 새벽 시간대에 전일 알림 묶어서 발송
    users = NotifyPreference.query.filter_by(email=True).all()
    for pref in users:
        items = Notification.query.filter_by(user_id=pref.user_id, is_read=False).all()
        if not items:
            continue
        msg = Message(subject="[App] Your daily digest", recipients=[_email(pref.user_id)])
        msg.html = render_template("emails/digest.html", items=items)
        mail.send(msg)
```

---

## 13.5 파일 업로드(제한/검증/저장)

### 13.5.1 Flask 설정 & HTML 폼

```python
# app/config.py (예)
MAX_CONTENT_LENGTH = 50 * 1024 * 1024   # 50MB
UPLOAD_EXT_WHITELIST = {"png","jpg","jpeg","pdf","csv"}
```

```html
<!-- templates/upload.html -->
<form action="{{ url_for('files.upload') }}" method="post" enctype="multipart/form-data">
  <input type="file" name="file" />
  <button type="submit">Upload</button>
</form>
```

### 13.5.2 서버 핸들러(화이트리스트, secure_filename, MIME 스니핑)

```python
# app/blueprints/files.py
import os, uuid, imghdr, magic
from werkzeug.utils import secure_filename
from flask import Blueprint, request, abort, current_app, jsonify

bp = Blueprint("files", __name__, url_prefix="/files")

def _allowed_ext(fn: str) -> bool:
    ext = fn.rsplit(".",1)[-1].lower()
    return ext in current_app.config["UPLOAD_EXT_WHITELIST"]

@bp.post("/upload")
def upload():
    f = request.files.get("file")
    if not f or f.filename == "":
        abort(400, "no file")
    if not _allowed_ext(f.filename):
        abort(400, "bad extension")

    # 임시 저장
    tmpdir = current_app.config.get("UPLOAD_TMP", "/tmp/uploads")
    os.makedirs(tmpdir, exist_ok=True)
    filename = secure_filename(f.filename)
    rid = uuid.uuid4().hex
    path = os.path.join(tmpdir, f"{rid}_{filename}")
    f.save(path)

    # MIME 스니핑(libmagic)
    mime = magic.from_file(path, mime=True)
    if not _mime_allowed(mime):
        os.remove(path); abort(400, f"bad mime: {mime}")

    # 이미지면 추가 검사(헤더)
    if filename.lower().endswith(("png","jpg","jpeg")):
        if imghdr.what(path) not in ("png","jpeg"):
            os.remove(path); abort(400, "bad image")

    # 여기서부터 비동기 스캔/영구 저장 파이프라인으로 넘김
    return jsonify({"temp_path": path, "rid": rid})
```

```python
def _mime_allowed(mime: str) -> bool:
    allowed = {"image/png","image/jpeg","application/pdf","text/csv","application/vnd.ms-excel"}
    return mime in allowed
```

### 13.5.3 업로드 후 파이프라인(바이러스 스캔 → 리사이즈/메타 → 영구 저장)

```python
# app/tasks/files.py
import os, shutil
from celery import shared_task
from app.av.scan import scan_path
from app.storage.s3 import upload_file_s3

@shared_task(bind=True, autoretry_for=(Exception,), retry_backoff=2, max_retries=3)
def process_upload(self, temp_path: str, dst_key: str):
    # 1) 바이러스 스캔
    ok, sig = scan_path(temp_path)
    if not ok:
        os.remove(temp_path)
        raise ValueError(f"virus detected: {sig}")
    # 2) (선택) 썸네일/메타 처리
    # 3) 영구 저장(S3 등)
    s3_url = upload_file_s3(temp_path, dst_key)
    # 4) 임시 파일 삭제
    os.remove(temp_path)
    return {"url": s3_url}
```

업로드 엔드포인트에서 큐잉:

```python
@bp.post("/upload/commit")
def commit():
    data = request.get_json()
    temp_path = data["temp_path"]
    dst_key = f"uploads/{data['rid']}/{os.path.basename(temp_path)}"
    job = process_upload.delay(temp_path, dst_key)
    return {"task_id": job.id}, 202
```

---

## 13.6 바이러스 스캔(ClamAV/clamd) 통합

### 13.6.1 Docker로 클램AV 데몬 띄우기(예)

```yaml
# docker-compose.yml (발췌)
services:
  clamd:
    image: clamav/clamav:latest
    ports: ["3310:3310"]
    environment:
      - CLAMD_LOG=yes
```

### 13.6.2 파이썬 클라이언트

```python
# app/av/scan.py
import clamd

def scan_path(path: str) -> tuple[bool, str | None]:
    cd = clamd.ClamdNetworkSocket(host="127.0.0.1", port=3310, timeout=5)
    try:
        res = cd.scan(path)
        # {'/path/file': ('FOUND', 'Win.Test.EICAR_HDB-1')}
        status, sig = res[path]
        if status == "FOUND":
            return (False, sig)
        return (True, None)
    except Exception as e:
        # 실패 시 정책 결정: 거부(보안 엄격) 또는 허용(가용성 우선)
        return (False, f"scan_error:{e}")
```

> **운영 팁**: 스캔 실패는 **보수적으로 거부** 권장(위험 파일 업로드 차단). 대량 처리 시 **비동기 스캔 + 격리(quarantine) 폴더** 전략.

---

## 13.7 대용량 업로드 — 청크/멀티파트/직접 업로드

### 13.7.1 서버 직접 업로드(단순) 한계
- 프록시/앱 **본체로 트래픽 집중**, 커넥션 길게 점유, 확장성 ↓
- **권장**: 브라우저 → **클라우드 저장소 직접 업로드**(서명 URL, multipart) + 서버는 권한/메타만 관리

### 13.7.2 S3 사전서명 URL로 **직접 업로드**

```python
# app/storage/s3.py
import boto3, mimetypes, datetime as dt
from flask import current_app

s3 = boto3.client("s3", region_name="ap-northeast-2")

def presign_put_url(key: str, content_type: str, expires=600):
    return s3.generate_presigned_url(
        "put_object",
        Params={"Bucket": current_app.config["S3_BUCKET"], "Key": key, "ContentType": content_type},
        ExpiresIn=expires,
        HttpMethod="PUT",
    )
```

API:

```python
@bp.post("/upload/presign")
def presign():
    body = request.get_json()
    key = f"uploads/{uuid.uuid4().hex}/{secure_filename(body['name'])}"
    url = presign_put_url(key, body.get("content_type","application/octet-stream"))
    return {"url": url, "key": key}
```

프론트(JS):

```javascript
async function upload(file) {
  const r = await fetch("/files/upload/presign", {
    method: "POST", headers: {"Content-Type":"application/json"},
    body: JSON.stringify({name: file.name, content_type: file.type})
  });
  const {url, key} = await r.json();
  const put = await fetch(url, {method: "PUT", headers: {"Content-Type": file.type}, body: file});
  if (!put.ok) throw new Error("upload failed");
  // 서버에 'key' 알려주고 백그라운드 스캔/인덱싱 요청
}
```

### 13.7.3 멀티파트 업로드(S3, 대용량 > 100MB)

```python
# app/storage/s3_multipart.py
def create_multipart(key: str, content_type: str):
    r = s3.create_multipart_upload(Bucket=bucket, Key=key, ContentType=content_type)
    return r["UploadId"]

def presign_part(key: str, upload_id: str, part_number: int, expires=600):
    return s3.generate_presigned_url(
        "upload_part",
        Params={"Bucket": bucket, "Key": key, "UploadId": upload_id, "PartNumber": part_number},
        ExpiresIn=expires,
        HttpMethod="PUT",
    )

def complete_multipart(key: str, upload_id: str, etags: list[dict]):
    s3.complete_multipart_upload(
        Bucket=bucket, Key=key, MultipartUpload={"Parts": etags}, UploadId=upload_id
    )
```

> 프론트는 각 파트를 **병렬 PUT** 하고, ETag 수집 후 `complete` 호출. 실패시 **abort_multipart_upload**.

---

## 13.8 대용량 다운로드 — 스트리밍/Range/X-Accel-Redirect/서명 URL

### 13.8.1 Flask 스트리밍

```python
# app/blueprints/files.py (추가)
from flask import Response

def iter_file(path, chunk=1024*256):
    with open(path, "rb") as f:
        while True:
            b = f.read(chunk)
            if not b: break
            yield b

@bp.get("/download/<path:name>")
def download(name):
    # 권한 검사 후
    path = f"/var/app/files/{name}"
    resp = Response(iter_file(path), mimetype="application/octet-stream")
    resp.headers["Content-Disposition"] = f'attachment; filename="{name}"'
    return resp
```

### 13.8.2 Nginx로 오프로딩(X-Accel-Redirect)

```python
# 권한 검사만 하고 내부 경로 위임
from flask import make_response
@bp.get("/fast/<path:name>")
def fast(name):
    resp = make_response("", 200)
    resp.headers["X-Accel-Redirect"] = f"/protected/{name}"
    resp.headers["Content-Type"] = "application/octet-stream"
    resp.headers["Content-Disposition"] = f'attachment; filename="{name}"'
    return resp
```

Nginx:

```
location /protected/ {
  internal;
  alias /var/app/files/;
}
```

### 13.8.3 S3 **서명 URL**로 직접 다운로드

```python
def presign_get_url(key: str, expires=600, filename=None):
    params = {"Bucket": bucket, "Key": key}
    if filename:
        # Content-Disposition 제어
        params["ResponseContentDisposition"] = f'attachment; filename="{filename}"'
    return s3.generate_presigned_url("get_object", Params=params, ExpiresIn=expires)
```

API:

```python
@bp.get("/download/presign")
def presign_download():
    key = request.args["key"]
    filename = request.args.get("filename")
    # 권한 검사/감사 로그
    url = presign_get_url(key, filename=filename)
    return {"url": url}
```

---

## 13.9 파일 보안/품질: MIME 스니핑, EXIF/메타, 이미지 리사이즈

### 13.9.1 MIME/매직넘버 스니핑
- 업로더 제공 `Content-Type` 신뢰 금지 → **libmagic** 로 판별.
- 확장자/매직/헤더 모두 일치할 때만 통과.

### 13.9.2 EXIF 제거(개인정보)

```python
# app/media/image.py
from PIL import Image

def strip_exif(src: str, dst: str | None = None):
    img = Image.open(src)
    data = list(img.getdata())
    clean = Image.new(img.mode, img.size)
    clean.putdata(data)
    (clean if dst is None else clean).save(dst or src)
```

### 13.9.3 안전한 썸네일

```python
def thumbnail(src: str, dst: str, size=(1024,1024)):
    img = Image.open(src)
    img.thumbnail(size)
    img.save(dst, optimize=True, quality=85)
```

---

## 13.10 저장/보관/삭제 정책(수명 주기), 암호화

- **수명 주기(Lifecycle)**: 임시 업로드(N일 후 삭제), 영구 보관, 보안 분류별 버킷/폴더 분리
- **암호화**: 전송 TLS, 정지 **서버측 암호화(SSE-S3/KMS)**, 민감 파일은 **클라이언트측 암호화** 고려
- **접근 제어**: 키 프리픽스별 IAM 정책, 최소 권한
- **감사**: 누가 언제 어떤 파일에 접근/다운로드/삭제했는지 로깅
- **PII**: 지역/규제에 따라 저장 위치/보존 기간 준수(GDPR 등)

---

## 13.11 테스트 전략

### 13.11.1 이메일
- **단위 테스트**: Flask-Mail `record_messages()` 컨텍스트로 캡처

```python
def test_email(client, app):
    from flask_mail import Message
    from app.extensions import mail
    with mail.record_messages() as outbox:
        msg = Message("Hi", recipients=["t@example.com"], body="hello")
        mail.send(msg)
        assert len(outbox) == 1
        assert outbox[0].subject == "Hi"
```

### 13.11.2 파일
- 임시 디렉터리 사용, 악성 시그니처(EICAR)로 스캔 동작 검증
- 업로드 제한/확장자/매직넘버/헤더 케이스별 테스트

```python
def test_upload_reject_bad_ext(client, tmp_path):
    p = tmp_path/"bad.exe"; p.write_bytes(b"dummy")
    with open(p, "rb") as f:
        r = client.post("/files/upload", data={"file": (f, "bad.exe")}, content_type="multipart/form-data")
        assert r.status_code == 400
```

---

## 13.12 체크리스트

- [ ] **SMTP**: TLS/인증/발신 도메인/포트, 타임아웃/재시도
- [ ] **대량 발송**: 큐/속도 제한/멱등성/옵트아웃/바운스
- [ ] **SPF/DKIM/DMARC**: DNS 설정/정기 점검
- [ ] **템플릿**: i18n, 인라인 이미지 CID, 다크모드/모바일 뷰
- [ ] **알림 선호**: 채널/사일런스/다이제스트
- [ ] **업로드**: 크기 제한/화이트리스트/MIME 스니핑/임시 저장
- [ ] **바이러스 스캔**: ClamAV/ICAP, 실패 정책, 격리 폴더
- [ ] **대용량**: 청크/멀티파트, 직접 업로드(Presigned), X-Accel-Redirect
- [ ] **서명 URL**: 만료/권한/Content-Disposition
- [ ] **보안**: 암호화(KMS), IAM 최소 권한, 감사 로깅
- [ ] **삭제/보관**: 수명 주기/자동 정리/법적 보존
- [ ] **테스트/모니터링**: 실패율/전송시간/큐 지연/다운로드 속도

---

## 13.13 흔한 안티패턴

- **BCC로 대량 발송**: 스팸 필터/개인화 불가/노출 위험 → 개별 발송
- **Content-Type 신뢰**: 클라가 보낸 MIME 사용 → **반드시 스니핑**
- **확장자만 검사**: `payload.pdf.exe` 통과 위험
- **스캔 실패시 무조건 허용**: 보수적 정책 권장(거부)
- **서명 URL 무한 만료**: 재사용/유출 위험 → 짧은 만료 + 스코프 제한
- **서버를 파일 프록시로 전부 전송**: egress 폭탄 → 가능하면 **직접 URL**
- **이메일 링크에 PII 노출**: 토큰/ID 그대로 → **단명 토큰/서명 파라미터**
- **옵트아웃 없는 캠페인**: 법적 문제(스팸 규정)

---

## 13.14 빠른 스타터(붙여넣기)

### 13.14.1 메일 스타터

```python
# send_single.py
from flask_mail import Message
from app.extensions import mail
def send_single(to, subject, html, txt=None):
    m = Message(subject=subject, recipients=[to])
    m.html = html
    if txt: m.body = txt
    mail.send(m)
```

### 13.14.2 업로드 → 스캔 → S3

```python
# flow snippet
@bp.post("/upload")
def upload():
    f = request.files["file"]
    tmp = save_temp(f)  # secure + tmp path
    job = process_upload.delay(tmp, dst_key_for(f.filename))
    return {"task_id": job.id}, 202
```

### 13.14.3 다운로드(서명 URL)

```python
@bp.get("/download/url")
def dl_url():
    key = request.args["key"]; filename = request.args.get("filename")
    # 권한 체크...
    return {"url": presign_get_url(key, filename=filename)}
```