---
layout: post
title: 운영체제 - 파일 시스템 내부 (3)
date: 2025-10-29 21:25:23 +0900
category: 운영체제
---
# Chapter 15 — Consistency & NFS
*(15.7 Consistency Semantics • 15.8 NFS — “생략 없이” 개념→모델→운영 패턴→성능/장애→실습 코드. 모든 코드는 ```…```, 수식은 반드시 $$…$$로 표기)*

---

## 15.7 Consistency Semantics

### 15.7.1 왜 “일관성 시맨틱”이 중요한가
동일 파일·디렉터리를 **여러 프로세스/호스트**가 사용할 때 “**언제/어떤 순서로**” 업데이트가 **보이느냐**가 정확성·성능·복구성에 직결된다.
운영체제/파일시스템/네트워크 FS는 **캐시/지연 쓰기/락**을 활용하므로, 사용자/개발자는 **모델**을 이해하고 **패턴**을 선택해야 한다.

---

### 15.7.2 일관성 모델 지도

#### (1) 선형화 가능성(Linearizability)
모든 연산이 어떤 **전역 시점**에 **즉시** 적용된 것처럼 보임(진짜 시간 순서 보존).
엄밀히는, 각 연산 \(op_i\) 에 시작 \(s_i\), 종료 \(e_i\) 가 있고, **존재하는 전역순서** \(<\) 에 대해:
$$
\forall i,j:\ e_i < s_j \Rightarrow op_i < op_j
$$
→ 강력하나 분산/원격에서 비용이 크다.

#### (2) 순차 일관성(Sequential Consistency)
모든 쓰기가 어떤 **일관된 순서**로 보이되, 실제 시간과 꼭 일치할 필요는 없다.
단일 머신의 페이지 캐시 + `fsync()` 없는 접근은 대체로 **순차 ~ 정도**로 생각하면 안전하다.

#### (3) 인과 일관성(Causal)
원인-결과 관계가 보장된다(메시지·락를 통해 순서 유도). 독립 연산은 순서 미정.

#### (4) 최종 일관성(Eventual)
충분히 시간이 지나면 모든 복제본이 **동일 상태**로 수렴. 오브젝트 스토리지/동기화 툴에 흔함.

#### (5) 관찰 기반 하위 속성
- **Read-your-writes**: 같은 클라이언트는 **자신이 쓴 값**을 즉시 본다.
- **Monotonic reads**: 더 **오래된 값으로 되돌아보지 않음**.
- **Monotonic writes**: 같은 작성자의 쓰기 순서 유지.
- **Writes-follow-reads**: 어떤 버전을 읽은 뒤 그 문맥에서의 쓰기는 적어도 그 버전 위에서 이뤄짐.

> **요점**: 로컬 POSIX FS(저널링) + `fsync()`/원자 `rename()` 패턴은 애플리케이션 관점에서 **선형화에 매우 근접**. 원격 FS(NFS/SMB)는 일반적으로 **약한 모델**이 기본이며, 락/델리게이션/옵션으로 강화한다.

---

### 15.7.3 로컬(단일 호스트) POSIX 시맨틱

- **페이지 캐시 쓰기 지연**: `write()`가 성공해도 디스크엔 나중에 내려갈 수 있음.
- **`fsync(fd)`**: 파일 **데이터+메타데이터**의 내구성 보장(저널 모드에 따라 다름).
- **`fdatasync(fd)`**: 데이터 중심(메타 일부 제외).
- **디렉터리 내구성**: 새 파일/`rename()` 후 **부모 디렉터리 FD**로 `fsync(dirfd)` 필요.
- **`rename(old,new)` 원자성**: 같은 파일시스템 내에서 **원자 교체**.
- **링크/하드링크**: 하드링크는 **동일 inode** → 일관성은 inode 단위.

#### 권장 원자 업데이트 패턴 (재확인)
1) `open("X.tmp", O_CREAT|O_TRUNC|O_WRONLY)`
2) **전체 내용**을 쓰고 `fsync(tmpFd)`
3) `rename("X.tmp","X")` (원자)
4) `fsync(dirfd)` (디렉터리 엔트리 내구성)

```c
// atomic_write.c (재제시) — 안전한 파일 교체
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
int main(){
  int fd=open("conf.json.tmp",O_CREAT|O_TRUNC|O_WRONLY,0644);
  dprintf(fd,"{\"v\":1,\"ts\":123}\n");
  fsync(fd); close(fd);
  rename("conf.json.tmp","conf.json");
  int dfd=open(".",O_DIRECTORY|O_RDONLY);
  fsync(dfd); close(dfd);
  return 0;
}
```

---

### 15.7.4 `mmap`과 `msync`
`MAP_SHARED` 로 매핑하면 페이지 캐시를 **공유**한다.
- 쓰기 → `msync(MS_SYNC)`/`msync(MS_ASYNC)`/파일 닫기 시 플러시 시맨틱.
- 충돌 방지는 별도 **락(레인지 락/세마포어)** 로 구현.

```c
// mmap_shared.c — 공유 매핑에서의 안전 쓰기
#include <sys/mman.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
int main(){
  int fd=open("mmap.dat",O_CREAT|O_RDWR,0644);
  ftruncate(fd,4096);
  char* p=mmap(NULL,4096,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
  memcpy(p,"hello mmap",10);
  msync(p,4096,MS_SYNC);   // 내구성 보장
  munmap(p,4096); close(fd);
}
```

---

### 15.7.5 원격 FS의 대표 시맨틱: **close-to-open**
NFS 등에서 전통적으로 쓰이는 근사:
- 작성자 클라이언트는 `close()` 시 **서버에 쓰기를 밀어넣고 속성 갱신**.
- 다른 클라이언트는 `open()` 시 **속성(ctime/mtime/size) 재검증**으로 갱신 감지.
- 속성 캐시 TTL \(T\) 동안은 **stale** 을 볼 수 있다.

**단순 근사로 본 정체(오래된 뷰) 확률**
쓰기 발생률 \(\lambda\) (초당), TTL \(T\) 일 때,
$$
P(\text{stale}) \approx 1 - e^{-\lambda T}
$$
→ 트래픽이 높거나 \(T\) 가 크면 오래된 뷰를 볼 가능성↑. 해법: TTL 축소, 락/델리게이션 사용.

---

### 15.7.6 락과 임대(lease), 그리고 캐시 무효화
- **Advisory POSIX 레인지 락(fcntl)**: 협조적인 경쟁 방지(원격 FS는 이를 서버 락으로 **전달**).
- **Lease/Delegation**(SMB lease, NFSv4 delegation): 서버가 **캐시 권한**을 위임, **변경 시 브레이크/리콜**로 무효화.
- **Mandatory 락**: 리눅스에 존재하나 호환성 문제, 일반적으로 사용 권장 X.

---

### 15.7.7 애플리케이션 패턴

1) **구성 파일/스냅샷형 데이터**
   - 임시 파일 전체 쓰기 → `fsync(tmp)` → **원자 `rename`** → `fsync(dir)`.
   - 원격이면 `close-to-open` 보정 위해 **리더는 open 전 `fstat`**/TTL 조정.

2) **동시 append 로그**
   - `O_APPEND` + **레인지 락**(충돌 구간 최소화) 또는 **전용 집계 데몬**.
   - NFSv3에선 `sync`/`noac` 옵션이 필요할 수 있으나 성능/부하 주의.

3) **읽기 많은 캐시**
   - SMB lease/NFS delegation 허용 시 대규모 **클라이언트 캐시** 성능↑.
   - 쓰기 경쟁 가능 시 **브레이크 비용** 고려.

---

### 15.7.8 미니 시뮬: close-to-open 과 stale 관찰률
```python
# cto_sim.py — close-to-open TTL이 stale에 미치는 영향(학습용)
import random, math

def stale_prob(lmbda, T, trials=100000):
    stale=0
    for _ in range(trials):
        # TTL 윈도 내 쓰기 발생 여부: 포아송
        if random.random() < 1-math.exp(-lmbda*T):
            stale+=1
    return stale/trials

for T in [0.1, 0.5, 1, 2, 5]:
    print(f"T={T}s, lambda=2/s → stale≈{stale_prob(2.0,T):.3f}")
```

---

## 15.8 NFS (Network File System)

### 15.8.1 버전별 개관
- **v2**: 초창기(32bit 제한 등).
- **v3**: 널리 사용, 거의 **stateless**. 잠금은 **NLM**(별도 데몬). 클라이언트 캐시는 **close-to-open**.
- **v4/4.1/4.2**: **stateful 세션**, **통합 락**(NLM 불필요), **delegation(위임)**, **ACL**, **compund ops**, **pNFS**(4.1)로 **데이터 경로 스케일아웃**.

> **핵심 차이**: v4는 **서버가 상태를 소유**하고, **락/임대/세션 회복**을 프로토콜로 제공한다.

---

### 15.8.2 핵심 개념: 파일 핸들·특성·RPC
- **파일 핸들**(opaque): 서버가 객체를 식별하는 불투명 식별자(재부팅 후에도 유효하도록 설계).
- **속성**: `ctime/mtime/size` 등으로 캐시 검증.
- **RPC**: `READ/WRITE/GETATTR/SETATTR/OPEN/CLOSE/LOCK/RENEW` 등.

---

### 15.8.3 캐시와 속성(AC) 옵션
리눅스 마운트 옵션(대표):
- `ac/noac` : 속성 캐시 사용/비활성(성능↔일관성).
- `acregmin`, `acregmax`, `acdirmin`, `acdirmax` : 파일/디렉터리 속성 캐시 TTL.
- `actimeo=N` : 모든 AC TTL을 N초로.

```bash
# 예1: 일반 워크로드(일관성↑, 성능도 적절)
mount -t nfs -o vers=4.1,rsize=1048576,wsize=1048576,acregmin=1,acdirmin=1 server:/export /mnt

# 예2: 매우 강한 최신성(성능↓)
mount -t nfs -o vers=4.1,noac server:/export /mnt
```

---

### 15.8.4 close-to-open 상세
- 작성자: `close()` 시 **서버에 데이터를 밀어 넣고 메타 업데이트**.
- 독자: `open()` 시 `GETATTR` 또는 `LOOKUP` 단계에서 **속성 비교**로 캐시 무효화 결정.
- TTL 내 **두 번째 open** 은 로컬 캐시를 사용할 수 있음 → **stale** 가능.

**관찰:**
- “**파일 교체**”는 NFS에서도 `rename()` 원자성을 유지(동일 FS 내).
- 단, **디렉터리 엔트리의 가시화 타이밍**은 캐시·TTL에 좌우.

---

### 15.8.5 락과 위임(Delegation) — v3 vs v4
- **v3 + NLM**: 별도 락 데몬(RPC.statd/rquotad 등). 네트워크 장애시 락 회복 복잡.
- **v4**: `OPEN`과 연계된 **stateid**, **byte-range `LOCK`**, **`DELEGATION`**(클라 캐시 위임).
  - 서버는 파일이 단독 접근일 때 **read/write delegation**을 부여
  - 타 클라이언트 접근 시 **callback** 으로 **리콜**(클라가 flush/반납)

```c
// pseudo — 애플리케이션 코드는 일반 POSIX fcntl 사용.
// v4에서 커널 NFS 클라이언트가 서버와 LOCK/UNLOCK 교섭을 수행.
```

---

### 15.8.6 pNFS (parallel NFS, v4.1+)
- **MDS**(메타데이터 서버)와 **DS**(데이터 서버) 분리.
- 클라이언트는 레이아웃을 받아 **데이터는 DS로 직접 I/O** → 대역폭·확장성↑.
- 레이아웃 캐시/회수 시맨틱을 이해하고, 장애 시 **레이아웃 회복** 경로 필요.

---

### 15.8.7 보안: 인증·무결성·암호화
- **sec=sys**: UNIX uid/gid 기반(신뢰 네트워크 전제).
- **sec=krb5**: 인증(Kerberos).
- **sec=krb5i**: 인증 + **무결성 보호**.
- **sec=krb5p**: 인증 + 무결성 + **암호화**(성능 비용).

```bash
mount -t nfs4 -o sec=krb5p,vers=4.2 server:/secure /mnt/secure
```

---

### 15.8.8 장애/재연결/내구성
- **hard/soft**:
  - *hard*(기본): 서버 응답까지 **무한 재시도**(데이터 안전).
  - *soft*: **에러 반환**(응답성↑, 데이터 무결성 위험).
- `timeo/retrans`: RPC 타임아웃/재시도.
- v4 **세션**: 재연결 시 **replay 보호**, 락 회복 절차.
- **stale file handle**: 서버 리부팅 후 핸들 무효 → 앱은 재열기 필요.

```bash
# fail-safe 지향(기본)
mount -t nfs -o hard,timeo=600,retrans=3 server:/exp /mnt
# 응답성 지향(일부 워크로드)
mount -t nfs -o soft,timeo=50,retrans=1 server:/exp /mnt
```

---

### 15.8.9 성능 튜닝 체크리스트
- **I/O 크기**: `rsize/wsize` 256KiB~1MiB.
- **nconnect**(리눅스): NFSv4.1에서 **다중 TCP 커넥션** → 멀티큐 NIC/경로 활용.
  ```bash
  mount -t nfs -o vers=4.1,nconnect=4 server:/export /mnt
  ```
- **리드어헤드/라이트백**: 순차 접근 최적화.
- **속성 캐시 TTL**: 읽기 위주면 ↑, 쓰기 경쟁 잦으면 ↓.
- **네트워크**: MTU/Jumbo, RTT, 혼잡 제어, 멀티패스.
- **서버**: 바탕 FS(ext4/XFS/ZFS) 파라미터, RAID/SSD 정렬, `no_subtree_check`(exports), 쓰기 모드(sync/async).

---

### 15.8.10 운영 패턴(예시)

#### (A) NFS에서의 원자적 구성 배포
배포 노드(작성자):
```c
// nfs_atomic_publish.c — 임시→rename→부모 fsync
#include <fcntl.h>
#include <unistd.h>
int main(){
  int fd=open("site.tar.tmp",O_CREAT|O_TRUNC|O_WRONLY,0644);
  // ... write all bytes ...
  fsync(fd); close(fd);
  rename("site.tar.tmp","site.tar");
  int dfd=open(".",O_DIRECTORY|O_RDONLY); fsync(dfd); close(dfd);
}
```
소비자 노드(독자):
- `open()` 시 `GETATTR` 검사로 최신 버전을 받게 됨(단, TTL이 짧아야 즉시 관찰).
- 보수적으로는 open 전 `stat()` 를 강제 호출(커널이 알아서 하지만, TTL 옵션 확인).

#### (B) 동시 쓰기 경쟁 방지: 레인지 락
```c
// nfs_counter.c — 파일 일부(0..7바이트)에 쓰기 락을 잡고 증가
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

static int lock_range(int fd, short type){
  struct flock lk={.l_type=type,.l_whence=SEEK_SET,.l_start=0,.l_len=8};
  return fcntl(fd,F_SETLKW,&lk);
}
int main(){
  int fd=open("counter.bin",O_RDWR|O_CREAT,0644);
  lock_range(fd,F_WRLCK);
  long v=0; pread(fd,&v,sizeof(v),0);
  v++; pwrite(fd,&v,sizeof(v),0);
  fsync(fd);
  lock_range(fd,F_UNLCK);
  printf("new=%ld\n",v);
}
```
> v4에서는 **서버 측 락 상태**로 **강제**되므로 여러 호스트에서도 충돌 방지.

---

### 15.8.11 NFS 마운트·내보내기 예시

**서버(예시 `/etc/exports`)**
```exports
/export/data 10.0.0.0/24(rw,sync,no_root_squash,sec=krb5p)
```

**클라이언트**
```bash
mount -t nfs4 -o vers=4.1,sec=krb5p,rsize=1048576,wsize=1048576,acregmin=1,acdirmin=1 server:/export/data /mnt/data
```

---

### 15.8.12 close-to-open 체감 실험(시뮬 코드)

두 “클라이언트”를 스레드로 흉내내고, **속성 캐시 TTL** 을 바꿔 stale 비율을 측정:

```python
# nfs_cto_demo.py — TTL이 큰 경우 오래된 값 관찰 가능성↑
import time, threading

store={"file":"v0","mtime":time.time()}
lock=threading.Lock()
TTL=1.5

def writer():
  for i in range(5):
    time.sleep(0.7)  # 주기적으로 쓰기
    with lock:
      store["file"]=f"v{i+1}"
      store["mtime"]=time.time()  # close 시 갱신된다고 가정

def reader():
  cache_val=None; cache_mtime=0; cache_ts=0
  stale=0; total=0
  start=time.time()
  while time.time()-start<5:
    # open: 속성 검증 (TTL 내면 skip)
    now=time.time()
    if now-cache_ts>TTL:
      with lock: m=store["mtime"]; v=store["file"]
      if m!=cache_mtime:
        cache_val=v; cache_mtime=m
      cache_ts=now
    # read
    total+=1
    with lock:
      if cache_val!=store["file"]: stale+=1
    time.sleep(0.2)
  print("stale ratio:", stale/total)

t1=threading.Thread(target=writer); t2=threading.Thread(target=reader)
t1.start(); t2.start(); t1.join(); t2.join()
```

---

### 15.8.13 트러블슈팅 노트

- **텍스트 파일 일부만 보임**: 작성자가 부분 쓰기+`fsync` 누락. → **임시파일→rename** 적용.
- **간헐적 “안 보임”**: 속성 캐시 TTL 과 충돌. → `ac*` 조정 또는 `noac`(성능 비용).
- **`ESTALE`**: 서버 재부팅/스냅샷 롤백 등. → **재열기** 로 복구.
- **느린 쓰기**: `sync` 모드/작은 I/O/RAID 미정렬. → `wsize` 확대, 배치, 정렬 점검.
- **락이 안 걸림**: v3+NLM 환경에서 데몬 불능/방화벽. → v4 사용 또는 NLM 포트 열기.
- **권한 오류**: `sec=sys` 에서 uid/gid 매핑 문제. → idmapd 설정/krb5 전환.

---

## 요약 정리

- **15.7 Consistency Semantics**: 선형화/순차/인과/최종 등 **모델**을 이해하고, 로컬 FS에서는 `fsync + rename`/디렉터리 `fsync`로 **강한 시맨틱**을 얻는다. 원격 FS는 **close-to-open**이 기본이며, **TTL/락/임대** 로 보강한다.
- **15.8 NFS**: v3(stateless)↔v4(stateful)의 **철학 차이**가 크다. **속성 캐시**, **락/델리게이션**, **pNFS**, **보안(sec=krb5p)**, **마운트 옵션**을 워크로드에 맞춰 조정하라. 장애 시 **hard/soft**, 세션 회복, `ESTALE` 재열기 패턴을 숙지할 것.
