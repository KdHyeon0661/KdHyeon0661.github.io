---
layout: post
title: 컴퓨터시스템 - 라이브러리 삽입
date: 2025-08-11 21:20:23 +0900
category: 컴퓨터시스템
---
# 라이브러리 삽입(Library Injection)

## 0. 한눈에 보는 요약 (TL;DR)

- **정의**: 실행 중 프로세스 주소공간에 **새 .so/.dll**을 올려 **행동을 관찰·변경·확장**하는 행위.
- **합법적 활용**: 플러그인 시스템(`dlopen/LoadLibrary`), 동적 링커 **감사 인터페이스**(예: `LD_AUDIT`), 성능 계측(eBPF/uprobes).
- **주요 위험**: 권한 오남용, 무결성 파괴, 정보탈취.
- **방어 기본기**: 코드서명·하든드 런타임/RELRO·ASLR/DEP·권한 경계·SELinux/AppArmor·정책 기반 차단(AppLocker/공급망 검증).
- **실무 원칙**: **승인된 대상만**, **재현 가능한 경로만**(공식 API/플러그인), **탐지/감사 로그** 남기기, **자동 검사**(CI) 포함.

---

## 1. 개념과 시스템 구성요소

### 1.1 라이브러리 삽입이란
- **목표**: 실행 중인 프로세스가 호출하는 함수/데이터 흐름에 **관찰 포인트**를 두거나, **동작을 교체/확장**.
- **핵심 원리**: OS는 **동적 링커/로더**가 **공유 라이브러리**(ELF `.so`, PE `.dll`)를 **런타임**에 적재·결합하도록 설계됨.

### 1.2 동작에 관여하는 구조(ELF 중심)
- **ELF 동적 섹션**(`.dynamic`): 의존 `.so`, 재배치 종류/테이블, 런패스(RUNPATH) 등.
- **PLT/GOT**: 외부 함수 호출을 간접화(PIE/PIC 지원), **Lazy/Eager 바인딩** 지점.
- **재배치(Reloc)**: 로드 시 실제 주소로 패치.
- **보안 하드닝**: RELRO(읽기전용 GOT), BIND_NOW(즉시 바인딩) 등.

> 윈도우(PE/COFF)는 IAT(Import Address Table)/EAT, CFG(Control Flow Guard), 서명/무결성 정책, ACG(Arbitrary Code Guard) 등으로 동작/방어가 유사 개념으로 전개된다.

---

## 2. 삽입 기법 — 위험도별 개념 정리 (코드/절차 생략)

> 아래는 **행동 원리**와 **합법적 활용 범주**를 설명한다.
> **무단 대상**에 대한 **원격 삽입·우회 절차/코드**는 제공하지 않는다.

기법 | 핵심 아이디어 | 합법적 활용 예 | 비고(제약/차단)
---|---|---|---
환경변수 주입 (예: `LD_PRELOAD`) | 동적 링커가 **가장 먼저** 지정 .so를 로드 → **이름 동일 심볼**이 우선 | 내부 테스트/계측, 샌드박스에서 API 로깅 | setuid/보안 모드에서 **무시**. 운영 배포에 **비권장**
런타임 로딩 (`dlopen/LoadLibrary`) | **자체 프로세스**에서 플러그인 적재 | 확장 포인트, 샌드박스 플러그인 | 권장 루트. 서명/버전·권한 검증 추가
감사/후킹 인터페이스 (예: `LD_AUDIT`) | 동적 링커의 **합법적 훅**으로 로딩/바인딩 이벤트 관찰 | 로딩 순서 추적, 진단 | 시스템 정책·하든드 런타임에서 제한적
코드 패치/테이블 변조 (PLT/GOT/IAT) | 간접 테이블을 **새 주소**로 바꿈 | 연구/디버그 전용 | RELRO/서명검증/CFG로 차단 가능
원격 삽입(프로세스 간) | 타 프로세스에 문자열/코드 쓰고 **원격 스레드**로 적재 호출 | **불허**(무단 대상) | OS 정책·권한·보안제품에 의해 탐지/차단

---

## 3. 안전한 확장: “내 프로그램 안에서” 플러그인/계측 설계

> **원칙**: **자기 프로세스**에서 **명시적 플러그인 로딩**으로 동일 목적을 달성하라.

### 3.1 안전 플러그인 로딩의 체크리스트
- [ ] 로드 전 **서명/해시** 검증(배포 체인 무결성).
- [ ] **심볼 버전/ABI** 호환 확인(SONAME, 버전 스크립트).
- [ ] **권한 축소**(샌드박스/`seccomp`/Windows Job/Token).
- [ ] **RTLD_LOCAL/LOAD_LIBRARY_SEARCH_*`**로 심볼/검색 범위를 최소화.
- [ ] 실패 시 **격리/회수**(타임아웃, watchdog, `dlclose/FreeLibrary`).
- [ ] 로딩/언로딩 로그/메트릭 수집.

### 3.2 (안전 예시) 플러그인 API 뼈대
```c
/* plugin_api.h — 플러그인과 호스트 간의 최소 ABI */
#pragma once
#ifdef __cplusplus
extern "C" {
#endif
typedef struct {
  int  (*init)(void);
  int  (*process)(const void* in, void* out, int n);
  void (*shutdown)(void);
} plugin_v1;
#ifdef __cplusplus
}
#endif
```

```c
/* host.c — 자기 프로세스 내에서의 안전한 로딩(요지) */
#include <dlfcn.h>
#include <stdio.h>
#include "plugin_api.h"

int main() {
  const char* so = "./plugins/libexample.so";
  void* h = dlopen(so, RTLD_NOW | RTLD_LOCAL);
  if (!h) { fprintf(stderr, "dlopen: %s\n", dlerror()); return 1; }

  plugin_v1* (*get_api)(void) = dlsym(h, "plugin_get_v1");
  if (!get_api) { fprintf(stderr, "dlsym: %s\n", dlerror()); return 1; }

  plugin_v1* api = get_api();
  if (api->init && api->init() != 0) { fprintf(stderr, "init fail\n"); return 1; }

  /* ... 안전한 데이터만 전달, 예외 처리/타임아웃 ... */

  if (api->shutdown) api->shutdown();
  /* 필요 시 dlclose(h); */
  return 0;
}
```

> **노트**: 외부 .so는 **서명/경로·권한**을 반드시 점검. `$ORIGIN` 기반 RUNPATH, Full RELRO(`-Wl,-z,relro,-z,now`)를 기본값으로.

---

## 4. 탐지·관찰: “삽입을 쓰지 않고” 보는 방법

- **eBPF uprobes/kprobes (Linux)**: 바이너리/커널 함수에 **비침습적 계측**. 루트/정책 필요.
- **ptrace 기반 디버깅**: 중단·스텝·메모리 읽기(주입 아님).
- **동적 링커 디버그**: `LD_DEBUG=libs,bindings`(학습/자체 프로그램 확인), `readelf/objdump`로 내부 확인.
- **윈도우 ETW/ProcMon/AMSI**: 로딩 이벤트/행위 로깅.

> 운영환경에서는 eBPF 같은 **비삽입** 계측이 선호된다(안정성·보안 정책 친화).

---

## 5. 보안 관점 — 위협과 방어

### 5.1 대표 위협
- **권한 도용**: 서명된 정상 프로세스에서 민감 API 프록시.
- **무결성 저하**: 코드/데이터 경로 변조(결제/인증/암호화).
- **은폐**: Lazy 바인딩·환경변수·전이 의존을 이용한 로딩 경로 오염.

### 5.2 방어 전략(플랫폼 공통)
범주 | 권장 설정/습관
---|---
**바이너리 하드닝** | PIE/PIC, **Full RELRO**(`-Wl,-z,relro,-z,now`), NX/DEP, STRIP(불필요 심볼 제거), 가시성 축소(`-fvisibility=hidden`)
**로더 정책** | `$ORIGIN` 기반 **RUNPATH**만 허용, `LD_LIBRARY_PATH` 의존 제거, 서명/해시 검증
**권한/경계** | Linux: **SELinux/AppArmor/seccomp**, Yama `ptrace_scope`; Windows: **AppLocker**, **Code Integrity/Device Guard**, **CFG/ACG/PPL**
**감사/탐지** | 로딩 이벤트/재배치카운트 모니터링, ETW/eBPF, 무결성 주기 검증
**공급망** | 라이브러리 서명·빌드 체인 재현성, 해시 고정, 취약성 DB(SBOM) 통합
**설계** | 플러그인만 허용(사전 등록/서명), 동적 로딩은 샌드박스 내에서 수행

> **Linux setuid/보안 모드**: `LD_PRELOAD`, `LD_AUDIT`, 다수 `LD_*` 변수가 무시.
> **glibc 2.34+ 동향**: 스레딩/저수준 일부가 `libc`로 통합되어 링크 구성이 단순해졌으나 **보안 정책**의 본질은 동일(서명·하드닝·정책).

---

## 6. 사례 연구 (합법/보안 중심)

### 6.1 성능 계측(합법)
- **목표**: IO/DB 호출 지연, 메모리 할당 패턴 가시화.
- **방법**: eBPF uprobes로 대상 함수(예: `write`, `malloc`) 레이턴시 히스토그램 수집.
- **장점**: 대상 바이너리 무수정, 커널 정책 하에서 통제.

### 6.2 플러그인 아키텍처(합법)
- **목표**: 코어와 확장 기능 분리, 런타임 추가/제거.
- **방법**: `dlopen(..., RTLD_LOCAL)` + **서명 검증** + **권한 축소**.
- **장점**: 추적/회수 용이, 표준 API/ABI 유지.

### 6.3 방어·감사
- **목표**: 의심스러운 로딩 탐지/차단.
- **방법**:
  - Linux: `auditd` 규칙, eBPF로 `security_bprm_*`/`mmap`/`openat` 트레이스.
  - Windows: AppLocker/WDAC 정책, ETW에서 `ImageLoad` 구독.
- **조치**: 비서명 .so/.dll 로딩 시 차단/격리, 인시던트 대응.

---

## 7. 운영 가이드 — “안전하게 쓰는” 체크리스트

- [ ] **무단 대상** 주입 금지(법·정책·윤리 준수).
- [ ] 가능하면 **주입 없이**(eBPF/공식 훅) 문제 해결.
- [ ] 불가피한 로딩은 **자기 프로세스 + 서명/버전 검사 + 권한 축소**.
- [ ] 빌드 기본값: **PIE/PIC + Full RELRO + 가시성 축소**.
- [ ] 배포: **RUNPATH `$ORIGIN`**, `LD_LIBRARY_PATH` 사용 금지.
- [ ] 모니터링: **로딩 이벤트/바인딩 지연** 수치화, 베이스라인 이탈 경보.
- [ ] 정기 검토: **SBOM/취약성 스캔**, 서명/인증서/정책 재점검.

---

## 8. 자주 묻는 질문(개념)

**Q. Lazy 바인딩을 끄면 무엇이 달라지나?**
A. 시작 시 모든 외부 심볼을 즉시 해석(**BIND_NOW**). 시작 시간이 늘지만 **GOT가 즉시 고정**되어 런타임 변조 위험이 줄고(RELRO 효과 극대화) 성능 변동이 작아진다.

**Q. 플러그인에서 전역 심볼 충돌이 난다.**
A. `-fvisibility=hidden`으로 **내부 심볼 비공개**, 필요 API만 `visibility("default")`. 로딩은 `RTLD_LOCAL`을 우선 사용.

**Q. 운영환경에서 LD_PRELOAD를 써도 되나?**
A. 권장하지 않는다. 보안·재현성·오류 원인분석 측면에서 취약하다. 플러그인/공식 훅/정책 통제 경로로 대체하라.

---

## 9. 숫자로 보는(개념) 바인딩·재배치 비용

> 개념 근사(정확 수치는 플랫폼/워크로드 의존)

- 총 시작 지연:
  $$
  T_{\text{start}} \approx \underbrace{T_{\text{mmap}}}_{\text{파일 매핑}} +
  \underbrace{\sum_{r \in \text{Reloc}} c_r}_{\text{재배치}} +
  \underbrace{\sum_{f \in \text{해석 함수}} P_f}_{\text{바인딩}}
  $$
- Lazy vs Eager:
  - Lazy: **첫 호출 시** \(P_f\) 지연이 발생(지연 분산·체감 가능).
  - Eager(BIND_NOW): 시작 때 일괄 비용, 런타임 변동성↓, 보안성↑.

---

## 10. 도구 모음(안전/진단 중심)

분류 | 도구 | 용도
---|---|---
ELF 내부 | `readelf -d/-l`, `objdump -T`, `nm` | DT_NEEDED/RUNPATH/심볼 확인
로더 추적 | `LD_DEBUG=libs,bindings` | 로딩/바인딩 경로 학습(자체 프로그램)
계측 | **eBPF(bcc/bpftrace)**, perf | 함수 지연/스택 샘플링(비삽입)
정책/캐시 | `ldconfig -p`, AppLocker/WDAC | 캐시/정책 상태 확인
윈도우 진단 | ProcMon, ETW(Event Tracing) | 라이브러리 로드 이벤트 추적

---

## 11. 표로 정리 — 기법 vs 방어

기법 | 대표 표면(징후) | 방어/탐지 포인트
---|---|---
환경변수 주입 | 비표준 경로 로딩, 초기 바인딩 지연 | 보안 모드에서 무시, 런패스 고정, 시작 이벤트 모니터링
무단 원격 삽입 | 비정상 스레드 생성/권한 상승 | 권한 정책 강화, EDR/ETW/eBPF로 `CreateRemoteThread`/`ptrace` 탐지
테이블 변조 | GOT/IAT 변형 | RELRO/서명·CFG, 무결성 검사
인라인 후킹 | 코드 섹션 변경 | W^X 정책(NX/DEP), 코드 서명, 페이지 무결성 확인

---

## 12. 결론

- 라이브러리 삽입의 **메커니즘 이해**는 성능·품질·보안의 **세 축**에서 모두 중요하다.
- 그러나 운영에서의 답은 **무단 주입 회피**와 **합법적 확장(플러그인/감사 인터페이스/비삽입 계측)** 이다.
- 빌드·배포는 **하드닝(PIE/PIC, Full RELRO, 가시성 축소)** 과 **정책 기반 경로(RUNPATH `$ORIGIN`)** 를 표준으로 삼고,
  **모니터링/감사/자동화 검사**를 루틴화하라.
- 항상 **승인·범위·책임**을 명확히 한 환경에서만 실험하라.

---

## 부록 A) 안전한 컴파일/링크 플래그 템플릿(ELF)

```bash
# 공유 라이브러리
CFLAGS="-O2 -fPIC -fvisibility=hidden"
LDFLAGS="-Wl,-z,relro,-z,now -Wl,--as-needed -Wl,--enable-new-dtags"
gcc $CFLAGS -c plugin.c
gcc -shared $LDFLAGS -Wl,-soname,libplugin.so.1 -o libplugin.so.1.0.0 plugin.o

# 실행 파일 (ASLR 친화)
gcc -fpie -pie -Wl,-z,relro,-z,now -o app app.c \
  -Wl,--enable-new-dtags -Wl,-rpath,'$ORIGIN/plugins'
```

> 목적: **Full RELRO**, **가시성 축소**, **RUNPATH 고정**으로 임의 주입·변조 표면 축소.

---

## 부록 B) 안전한 플러그인 스켈레톤(요약)

```c
/* plugin.c */
#include "plugin_api.h"
__attribute__((visibility("default")))
plugin_v1* plugin_get_v1(void) {
  static plugin_v1 api = { .init=NULL, .process=NULL, .shutdown=NULL };
  /* 필요한 함수 포인터 채워 반환 */
  return &api;
}
```

> 호스트 측에서 **서명 검증 → dlopen(RTLD_LOCAL) → dlsym("plugin_get_v1")** 순으로만 사용.

---

### 윤리·정책 메모
- 본 문서는 **교육·방어·합법적 엔지니어링** 목적이다.
- 타인의 시스템/프로세스에 대한 **무단 행위**는 법·정책·윤리에 반한다.
- 요청이 **보안 우회/무단 주입 절차·코드**로 이어질 경우, 나는 제공하지 않는다.
- 대신 **방어·탐지·안전 대안**을 최대한 구체적으로 지원한다.
