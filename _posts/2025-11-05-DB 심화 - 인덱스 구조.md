---
layout: post
title: DB 심화 - 인덱스 구조
date: 2025-11-05 23:25:23 +0900
category: DB 심화
---
# Oracle 인덱스 구조 깊이 탐구  

## 0. 실습 데이터 준비

```sql
-- 클린업
DROP TABLE ix_demo PURGE;

-- 샘플 테이블: 고객 ID, 가입일, 등급, 이름
CREATE TABLE ix_demo (
  cust_id     NUMBER        NOT NULL,
  created_at  DATE          NOT NULL,
  grade       VARCHAR2(10)  NOT NULL,
  name        VARCHAR2(60)  NOT NULL,
  CONSTRAINT pk_ix_demo PRIMARY KEY (cust_id)
);

-- 10만 건 삽입 (등급/날짜에 분포 부여)
BEGIN
  FOR i IN 1..100000 LOOP
    INSERT INTO ix_demo
    VALUES (
      i,
      DATE '2025-01-01' + MOD(i, 365),
      CASE MOD(i,5)
        WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILV' WHEN 3 THEN 'BRNZ' ELSE 'BASIC' END,
      'NAME_'||TO_CHAR(i)
    );
  END LOOP;
  COMMIT;
END;
/

-- 보조 인덱스 (복합키: grade, created_at, cust_id)
CREATE INDEX ix_demo_g_dt ON ix_demo(grade, created_at, cust_id);

-- 통계
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'IX_DEMO', cascade => TRUE, method_opt => 'for all columns size skewonly');
END;
/
```

---

## 1. 인덱스 **기본 구조** (B-tree)

### 1.1 B-tree의 3계층
- **Root 블록**: 최상단. 아주 작고 드묾(대개 1블록).  
- **Branch 블록**: 중간 노드. **키 범위** → **하위 블록 주소**(포인터)만 가짐.  
- **Leaf 블록**: 말단 노드. **정렬된 키** + **ROWID** 페어 **실제 엔트리** 저장.  
  - **Leaf 블록들은 양방향으로 연결**(doubly-linked). 따라서 **범위 스캔** 시 **연속 Leaf 체인**을 타고 감.

```
[ROOT]
  ├─ key<='GOLD'  → BRANCH#1
  └─ key>'GOLD'   → BRANCH#2
         ├─ ... → LEAF#101  <->  LEAF#102  <->  LEAF#103  ...
```

> **핵심 직관**: “**찾을 때**는 Root→Branch→Leaf 로 **단 한 경로**를 타고 내려가서, **범위를 걸을 때**는 Leaf를 **좌→우로 줄줄이** 읽는다.”

### 1.2 Leaf 엔트리의 정렬 규칙
- **단일 컬럼 인덱스**: `(key ASC, rowid ASC)` 정렬.  
- **복합 인덱스**: **사전식 정렬** `(col1, col2, ..., rowid)`  
- **Rowid가 정렬 키의 일부**이므로 **동일 키 다건**도 Leaf 내에서 **ROWID 순서**가 안정적.

### 1.3 기타 구조적 특징
- **인덱스 압축(Advanced Compression/Prefix Compression)**: 공통 prefix 저장 최적화(특히 복합키 첫 컬럼 분포가 낮을 때 효과).  
- **Descending 인덱스**: `CREATE INDEX ... (col DESC)` → 정렬 방향 반전.  
- **Reverse Key 인덱스**: key 바이트를 뒤집어 insert hotspot 완화(범위 스캔에는 부적합).  
- **Function-based Index(FBI)**: `ON (LOWER(name))` 같은 표현식 위 인덱스.

---

## 2. 인덱스 **탐색(Probe) 루틴** — “한 번 내려가고, 필요하면 옆으로 걷는다”

### 2.1 단일 값 탐색 (Unique Probe)
```sql
-- 고유키 탐색: PK(cust_id)
SELECT /* Unique Probe → Single ROWID → Single Block Random Access */
       name, created_at
FROM   ix_demo
WHERE  cust_id = :id;  -- (= 유니크 인덱스 탐색)
```
- 실행계획 핵심 단계
  - `INDEX UNIQUE SCAN (PK_IX_DEMO)` → **ROWID 한 개** 획득  
  - `TABLE ACCESS BY INDEX ROWID (IX_DEMO)`

### 2.2 범위 탐색 (Start Key → Leaf 체인 → Stop Key)
```sql
-- 복합 인덱스 (grade, created_at, cust_id)로 “VIP의 3월 한 달”
SELECT /* Range Scan (Start: 'VIP', 2025-03-01) → Stop: ('VIP', 2025-04-01) */
       cust_id, created_at, name
FROM   ix_demo
WHERE  grade = 'VIP'
AND    created_at >= DATE '2025-03-01'
AND    created_at <  DATE '2025-04-01'
ORDER  BY created_at, cust_id; -- 인덱스 정렬과 일치
```
- 내부 동작  
  1) **Root**에서 `(grade='VIP')` 범위가 속한 **Branch**로.  
  2) Branch에서 **시작 Leaf** 블록으로 **binary search**.  
  3) 시작 지점에서 **Stop Key**에 도달할 때까지 **Leaf 체인** **좌→우** 순회.  
  4) 각 엔트리의 **ROWID**로 테이블 **BY ROWID 랜덤 I/O** 수행(커버링이면 테이블 무방문).

> **정렬 일치**(`ORDER BY created_at, cust_id`)이므로 옵티마이저는 **SORT 생략** 가능. Stopkey/Top-N과 결합하면 **앞부분만 읽고 멈춤**.

### 2.3 Skip Scan (선행 컬럼이 상수가 아닐 때)
```sql
-- grade가 조건에 없지만, grade 값의 도메인이 작다면 Skip Scan 고려
SELECT /* 인덱스 Skip Scan 후보 */ cust_id
FROM   ix_demo
WHERE  created_at >= SYSDATE - 7;
```
- **원리**: 복합 인덱스의 **선행 컬럼(grade)**의 **가능한 값**을 **가상으로 대입**해 여러 작은 범위 스캔을 합친 것처럼 동작.  
- **주의**: 선행컬럼 도메인이 **작을수록** 이득. 도메인이 크면 **Full Scan**이 낫다.

### 2.4 Index Fast Full Scan (IFFS)
```sql
-- 정렬/범위 고려 없이 “인덱스 전체를 멀티블록 I/O로 훑음”
SELECT /*+ index_ffs(ix_demo ix_demo_g_dt) */ COUNT(*)
FROM   ix_demo
WHERE  grade IN ('VIP','GOLD');
```
- **Leaf 순서 보장 X** / **다중 블록 읽기** / **병렬과 찰떡**.  
- “**인덱스만 읽으면 되는** 집계”에 좋다(커버링).

---

## 3. **범위 스캔**을 빠르게 만드는 설계 포인트

### 3.1 선행 컬럼의 선택도
- `WHERE grade = :g` 가 고정이면 `(grade, created_at)` 순서는 **필수**.  
- 날짜 범위가 넓고 grade가 **고정**이라면 `(grade, created_at)`이 `(created_at, grade)`보다 **범위가 좁다**.

### 3.2 **정렬 일치** & **Stopkey**
- 정렬이 필요하면 인덱스 **정렬 순서**와 **ORDER BY**를 맞추자.  
- `FETCH FIRST N ROWS ONLY` 와 함께 쓰면 **앞부분만** 읽고 **즉시 종료**.

```sql
SELECT /*+ index(ix_demo ix_demo_g_dt) */
       cust_id, created_at
FROM   ix_demo
WHERE  grade = :g
ORDER  BY created_at, cust_id
FETCH FIRST 50 ROWS ONLY;  -- Stopkey
```

### 3.3 **커버링 인덱스**
- SELECT-LIST에 필요한 컬럼을 **인덱스에 포함**하면 테이블 방문을 **0**으로.  
- (Oracle은 INCLUDE 구문이 없지만, 복합키 말미에 컬럼을 추가하여 달성 가능. 단, 키 폭·CF 고려)

---

## 4. 인덱스 **탐색 비용과 I/O 패턴**

- **Probe 단계**(Root/Branch/Leaf 진입): **단몇 블록**의 **싱글블록 I/O**.  
- **Range 단계**(Leaf 체인 걷기): **연속 Leaf**면 캐시/리드어헤드 혜택, **테이블 BY ROWID**는 **랜덤 I/O**.  
- **커버링**이면 테이블 접근 **불필요** → **랜덤 I/O 제거**.  
- **IFFS**는 **멀티블록 I/O**로 **대량 병렬 처리**에 유리.

---

## 5. **ROWID 포맷** — 테이블 블록의 “좌표”

### 5.1 개념
- ROWID는 **해당 행이 물리적으로 위치한 곳**을 가리키는 **좌표**.  
- **확장 ROWID(Extended ROWID)**가 기본(현대 Oracle):  
  - 구성요소 **(Data Object Number, Relative File Number, Block Number, Row Slot)**  
  - 18자짜리 인코딩 문자열로 표기되지만, 실체는 내부 바이너리 구조.  
- ROWID로 테이블을 직접 찌르는 **BY ROWID** 접근이 가능.

### 5.2 ROWID 확인/분해
```sql
-- 임의 한 행의 ROWID 확인
SELECT rowid, cust_id, name FROM ix_demo WHERE cust_id = 12345;

-- DBMS_ROWID로 구성요소 추출
SELECT rowid,
       DBMS_ROWID.ROWID_OBJECT( rowid )   AS obj#,     -- 데이터 오브젝트 번호
       DBMS_ROWID.ROWID_RELATIVE_FNO(rowid) AS file#,  -- 파일 번호
       DBMS_ROWID.ROWID_BLOCK_NUMBER(rowid) AS block#, -- 블록 번호
       DBMS_ROWID.ROWID_ROW_NUMBER(rowid)   AS slot#   -- 블록 내 슬록(행 슬롯)
FROM   ix_demo
WHERE  cust_id = 12345;

-- DUMP로 내부 바이트 확인 (학습용)
SELECT DUMP(rowid,16) AS rid_hex FROM ix_demo WHERE cust_id = 12345;
```

### 5.3 ROWID를 이용한 고속 접근
```sql
-- 1단계: 인덱스로 ROWID 목록만 수집 (필요 시 Stopkey/필터)
WITH r AS (
  SELECT /*+ index(ix_demo ix_demo_g_dt) */
         rowid rid
  FROM   ix_demo
  WHERE  grade='VIP'
  AND    created_at >= DATE '2025-03-01'
  AND    created_at <  DATE '2025-04-01'
)
-- 2단계: ROWID로 본문 튕김
SELECT /*+ ROWID */
       /* 테이블 랜덤 I/O지만, 필요한 ROWID만 정확히 */
       t.*
FROM   ix_demo t
JOIN   r ON r.rid = t.rowid;
```

> **주의**: ROWID는 **행 이동(예: shrink, move, 재구성)** 시 바뀔 수 있음. 논리적으로는 **PK**가 신뢰 근거다.

---

## 6. 실행계획으로 확인하기

```sql
ALTER SESSION SET statistics_level = ALL;

-- 범위 스캔 (grade='VIP' and created_at between ...)
SELECT cust_id, created_at, name
FROM   ix_demo
WHERE  grade='VIP'
AND    created_at BETWEEN DATE '2025-03-01' AND DATE '2025-03-31'
ORDER  BY created_at, cust_id;

SELECT * 
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS +ALIAS'));
```

- **주요 오퍼레이터 해석**
  - `INDEX RANGE SCAN IX_DEMO_G_DT` … `A-Rows`가 예상 범위에 맞는지, `Buffers/Reads`가 적절한지 확인.  
  - `TABLE ACCESS BY INDEX ROWID IX_DEMO` … LIO/PIO가 높다면 **커버링/CF 개선** 고려.

---

## 7. 범위 스캔 **튜닝 시나리오** (실례)

### 7.1 “정렬 때문에 느린 리스트 API”
**나쁜 쿼리**
```sql
SELECT cust_id, created_at, name
FROM   ix_demo
WHERE  grade=:g
ORDER  BY created_at, cust_id
OFFSET :skip ROWS FETCH NEXT :take ROWS ONLY;
```
- **문제**: OFFSET은 **앞쪽을 버리기 위해** 많은 범위를 읽고 정렬까지 수행.

**개선 — Keyset 페이징**
```sql
-- 마지막 본 키(:last_dt, :last_id) 저장 → 다음 페이지는 그 다음부터
SELECT /*+ index(ix_demo ix_demo_g_dt) */
       cust_id, created_at, name
FROM   ix_demo
WHERE  grade=:g
  AND (created_at > :last_dt
       OR (created_at = :last_dt AND cust_id > :last_id))
ORDER  BY created_at, cust_id
FETCH FIRST :take ROWS ONLY;
```
- **효과**: Leaf 체인을 “정렬된 상태 그대로” **앞부분만** 읽고 종료. 정렬/스캔 비용 급감.

### 7.2 “날짜 조건에서 TRUNC 사용”
**나쁜**
```sql
SELECT COUNT(*) FROM ix_demo
WHERE grade='VIP'
AND   TRUNC(created_at) = DATE '2025-03-01';
```
**좋은**
```sql
SELECT COUNT(*) FROM ix_demo
WHERE grade='VIP'
AND   created_at >= DATE '2025-03-01'
AND   created_at <  DATE '2025-03-02';
```
- **SARGable**로 바꿔 **범위 스캔**을 촉진.

---

## 8. 복합 인덱스와 **범위의 모양**

- `(grade, created_at, cust_id)`:
  - `grade='VIP'` **고정 + created_at 범위** → **좁고 긴** 범위(이상적).  
  - `created_at between ...` 만 있고 grade 조건이 없으면 **Skip Scan** 또는 비용에 따라 **Full/IFS**가 나을 수 있음.  
- **선행 컬럼의 선택도**가 낮으면 인덱스 스캔 범위가 **짧아져** 테이블 랜덤 I/O도 줄어든다.

---

## 9. 클러스터링 팩터(CF)와 범위 스캔

- **정의**: 인덱스 키 순서가 테이블 물리 저장 순서와 **얼마나 맞는지**를 나타내는 수치.  
- **좋은 CF**(작을수록 좋음): 인덱스 순서대로 읽을 때 테이블 블록 **재사용률↑** → 랜덤 I/O 감소.  
- **개선 방법**: 테이블을 인덱스 키 순서로 **CTAS 재적재** 후 인덱스 재생성.

```sql
CREATE TABLE ix_demo_sorted NOLOGGING AS
SELECT * FROM ix_demo ORDER BY grade, created_at, cust_id;

ALTER TABLE ix_demo RENAME TO ix_demo_old;
ALTER TABLE ix_demo_sorted RENAME TO ix_demo;

DROP INDEX ix_demo_g_dt;
CREATE INDEX ix_demo_g_dt ON ix_demo(grade, created_at, cust_id);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'IX_DEMO', cascade=>TRUE);
END;
/
```

---

## 10. 인덱스 **유지/관리** 관점 요약

- **분포/쿼리 패턴**에 맞춘 **컬럼 순서**(선택도 높은 것 → 범위 컬럼 → tie-breaker).  
- **정렬 일치** + **Stopkey**(Top-N/Keyset)로 **앞부분만 읽기**.  
- **커버링 인덱스** 설계(필요 컬럼 포함).  
- **CF 개선**(물리 정렬/재적재).  
- **Skip Scan**은 선행 컬럼 도메인이 **작을 때만** 유효.  
- **Reverse Key**는 삽입 경합 완화용이지 **범위 스캔에는 부적합**.  
- **FBI**는 결정성/함수 안전성(Deterministic) 확인 후 사용.

---

## 11. 학습 점검(미니 실험)

```sql
-- A) VIP + 3월 범위 (정렬 일치)
SELECT /*A*/ cust_id, created_at
FROM   ix_demo
WHERE  grade='VIP'
AND    created_at >= DATE '2025-03-01'
AND    created_at <  DATE '2025-04-01'
ORDER  BY created_at, cust_id;

-- B) grade 조건 제거(범위 급증) → 계획 비교
SELECT /*B*/ cust_id, created_at
FROM   ix_demo
WHERE  created_at >= DATE '2025-03-01'
AND    created_at <  DATE '2025-04-01'
ORDER  BY created_at, cust_id;

-- C) OFFSET vs Keyset → Buffers/Reads 비교
SELECT /*C1 OFFSET*/ cust_id, created_at
FROM ix_demo WHERE grade='VIP'
ORDER BY created_at, cust_id
OFFSET 10000 ROWS FETCH NEXT 50 ROWS ONLY;

VAR d DATE; VAR i NUMBER;
EXEC :d := DATE '2025-03-15'; EXEC :i := 55555;
SELECT /*C2 KEYSET*/ cust_id, created_at
FROM ix_demo
WHERE grade='VIP'
  AND (created_at > :d OR (created_at=:d AND cust_id > :i))
ORDER BY created_at, cust_id
FETCH FIRST 50 ROWS ONLY;

-- 실행 후 실제 수행 통계 확인
ALTER SESSION SET statistics_level = ALL;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS'));
```

---

## 12. 수학적 감각(아주 짧게)

- 총 블록 접근은 대략  
  $$ \text{Blocks} \approx \text{Probe}(O(\log N)) + \text{LeafSpan} + \text{TableRandom} $$
- **커버링**이면 `TableRandom ≈ 0`.  
- 선행 컬럼 선택도가 높고, CF가 좋을수록 `LeafSpan`·`TableRandom`이 **작아진다**.

---

## 13. 결론

- B-tree 인덱스는 **한 번 내려가고(Probe)**, **필요한 만큼만 옆으로 걷는(Leaf chain)** 구조다.  
- **범위 스캔을 잘 쓰고 싶다면**: (1) **선행 컬럼 선택도**와 **정렬 일치**를 맞추고, (2) **커버링**으로 테이블 랜덤 I/O를 지우며, (3) **Keyset/Stopkey**로 앞부분만 읽어라.  
- 마지막으로 **ROWID는 좌표**다. 인덱스는 그 좌표를 **가장 빠르게** 찾아주는 지도다.  

위 실습 SQL을 그대로 돌려 **Buffers/Reads/Rows**가 어떻게 변하는지 확인하면, 설계가 **숫자**로 증명된다.