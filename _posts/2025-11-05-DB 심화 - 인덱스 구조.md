---
layout: post
title: DB 심화 - 인덱스 구조
date: 2025-11-05 23:25:23 +0900
category: DB 심화
---
# Oracle 인덱스 구조 심층 분석

> **핵심 원리**
> Oracle 인덱스는 대부분 B-tree 구조를 기반으로 하며, 데이터 접근 패턴에 최적화된 설계가 성능에 결정적인 영향을 미칩니다. 효과적인 인덱스 설계는 쿼리 패턴, 데이터 분포, 정렬 요구사항을 종합적으로 고려해야 합니다.

---

## 실습 환경 구성

```sql
-- 테스트 테이블 생성
DROP TABLE ix_demo PURGE;

-- 고객 정보 테이블 생성
CREATE TABLE ix_demo (
  cust_id     NUMBER        NOT NULL,
  created_at  DATE          NOT NULL,
  grade       VARCHAR2(10)  NOT NULL,
  name        VARCHAR2(60)  NOT NULL,
  CONSTRAINT pk_ix_demo PRIMARY KEY (cust_id)
);

-- 샘플 데이터 삽입 (10만 건)
BEGIN
  FOR i IN 1..100000 LOOP
    INSERT INTO ix_demo
    VALUES (
      i,
      DATE '2025-01-01' + MOD(i, 365),
      CASE MOD(i,5)
        WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILV' WHEN 3 THEN 'BRNZ' ELSE 'BASIC' END,
      'NAME_'||TO_CHAR(i)
    );
  END LOOP;
  COMMIT;
END;
/

-- 복합 인덱스 생성 (등급, 생성일, 고객ID)
CREATE INDEX ix_demo_g_dt ON ix_demo(grade, created_at, cust_id);

-- 통계 정보 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    USER, 
    'IX_DEMO', 
    cascade => TRUE, 
    method_opt => 'for all columns size skewonly'
  );
END;
/
```

---

## B-tree 인덱스의 기본 구조

### 계층적 구조 이해
Oracle의 B-tree 인덱스는 세 가지 주요 계층으로 구성됩니다:

1. **Root 블록**: 인덱스의 최상위 노드, 일반적으로 하나의 블록으로 구성
2. **Branch 블록**: 중간 노드, 키 범위에 따라 하위 블록으로의 포인터 보유
3. **Leaf 블록**: 최하위 노드, 실제 키 값과 ROWID 쌍 저장

### Leaf 블록의 특성
- Leaf 블록은 양방향 연결 리스트 구조를 가집니다
- 범위 스캔 시 연속된 Leaf 블록을 순차적으로 접근합니다
- 각 엔트리는 정렬된 키 값과 해당 행의 ROWID를 포함합니다

---

## 인덱스 접근 패턴 분석

### 고유 키 탐색 (Unique Probe)
```sql
-- 기본 키를 통한 단일 행 접근
SELECT name, created_at
FROM ix_demo
WHERE cust_id = :id;
```

**실행 계획 특성**:
- `INDEX UNIQUE SCAN` 연산자 사용
- Root에서 Leaf까지 단일 경로 탐색
- 하나의 ROWID 획득 후 테이블 접근

### 범위 스캔 (Range Scan)
```sql
-- 복합 인덱스를 활용한 범위 쿼리
SELECT cust_id, created_at, name
FROM ix_demo
WHERE grade = 'VIP'
  AND created_at >= DATE '2025-03-01'
  AND created_at < DATE '2025-04-01'
ORDER BY created_at, cust_id;
```

**실행 계획 특성**:
- `INDEX RANGE SCAN` 연산자 사용
- 시작 키에서 중지 키까지 Leaf 블록 순차적 접근
- 정렬 순서와 인덱스 순서 일치 시 정렬 작업 생략 가능

### Skip Scan 기법
```sql
-- 선행 컬럼이 조건에 없을 때의 최적화
SELECT cust_id
FROM ix_demo
WHERE created_at >= SYSDATE - 7;
```

**동작 원리**:
- 복합 인덱스의 선행 컬럼(grade)에 대한 가능한 값 추정
- 각 값에 대해 별도의 범위 스캔 수행
- 선행 컬럼의 카디널리티가 낮을 때 효과적

### 인덱스 Fast Full Scan
```sql
-- 인덱스 전체 스캔 (정렬 보장 없음)
SELECT /*+ index_ffs(ix_demo ix_demo_g_dt) */ COUNT(*)
FROM ix_demo
WHERE grade IN ('VIP','GOLD');
```

**특징**:
- 다중 블록 읽기 사용
- 병렬 처리와 효율적 결합
- 정렬 순서 보장되지 않음

---

## 효율적인 범위 스캔 설계 원칙

### 선행 컬럼 선택 기준
인덱스의 첫 번째 컬럼은 가장 높은 선택도를 가져야 합니다:
```sql
-- 효율적인 인덱스 설계 예시
CREATE INDEX idx_efficient ON orders(
  customer_id,     -- 높은 선택도
  order_date,      -- 범위 조건
  order_id         -- 정렬 보조
);
```

### 정렬 요구사항 반영
쿼리의 정렬 순서를 인덱스 설계에 반영하세요:
```sql
-- 정렬 순서가 인덱스와 일치하는 쿼리
SELECT order_id, order_date, amount
FROM orders
WHERE customer_id = :cust_id
ORDER BY order_date DESC, order_id DESC
FETCH FIRST 100 ROWS ONLY;
```

### 커버링 인덱스 활용
자주 접근하는 컬럼을 인덱스에 포함시켜 테이블 접근을 최소화하세요:
```sql
-- 커버링 인덱스 설계
CREATE INDEX ix_orders_covering ON orders(
  customer_id,
  order_date DESC,
  order_id DESC,
  total_amount,
  status
);
```

---

## ROWID의 이해와 활용

### ROWID 구조 분석
ROWID는 데이터베이스 객체 내 행의 물리적 위치를 식별합니다:

```sql
-- ROWID 구성 요소 분석
SELECT rowid,
       DBMS_ROWID.ROWID_OBJECT(rowid) AS object_id,
       DBMS_ROWID.ROWID_RELATIVE_FNO(rowid) AS file_number,
       DBMS_ROWID.ROWID_BLOCK_NUMBER(rowid) AS block_number,
       DBMS_ROWID.ROWID_ROW_NUMBER(rowid) AS row_number
FROM ix_demo
WHERE cust_id = 12345;
```

### ROWID 기반 최적화
```sql
-- ROWID를 활용한 효율적 데이터 접근
WITH rowid_list AS (
  SELECT /*+ index(ix_demo ix_demo_g_dt) */
         rowid as target_rowid
  FROM ix_demo
  WHERE grade = 'VIP'
    AND created_at >= DATE '2025-03-01'
    AND created_at < DATE '2025-04-01'
)
SELECT t.*
FROM ix_demo t
JOIN rowid_list r ON t.rowid = r.target_rowid;
```

---

## 클러스터링 팩터 최적화

### 개념 이해
클러스터링 팩터는 인덱스 키 순서와 테이블의 물리적 저장 순서 간의 일치도를 나타냅니다. 좋은 클러스터링 팩터는 인덱스 범위 스캔 시 테이블 블록 재사용률을 높여 I/O 효율성을 개선합니다.

### 개선 방법
```sql
-- 클러스터링 팩터 개선을 위한 테이블 재구성
-- 1. 정렬된 순서로 새 테이블 생성
CREATE TABLE ix_demo_reorganized AS
SELECT * FROM ix_demo
ORDER BY grade, created_at, cust_id;

-- 2. 원본 테이블 교체
ALTER TABLE ix_demo RENAME TO ix_demo_old;
ALTER TABLE ix_demo_reorganized RENAME TO ix_demo;

-- 3. 인덱스 재생성
CREATE INDEX ix_demo_g_dt ON ix_demo(grade, created_at, cust_id);

-- 4. 통계 재수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'IX_DEMO', cascade => TRUE);
END;
/
```

---

## 실전 최적화 시나리오

### 시나리오 1: 페이지네이션 성능 개선

**문제점 (OFFSET 방식)**:
```sql
-- 비효율적인 OFFSET 페이지네이션
SELECT cust_id, created_at, name
FROM ix_demo
WHERE grade = :grade
ORDER BY created_at, cust_id
OFFSET 10000 ROWS FETCH NEXT 50 ROWS ONLY;
```

**해결책 (Keyset 페이지네이션)**:
```sql
-- 효율적인 Keyset 페이지네이션
SELECT cust_id, created_at, name
FROM ix_demo
WHERE grade = :grade
  AND (created_at > :last_date 
       OR (created_at = :last_date AND cust_id > :last_id))
ORDER BY created_at, cust_id
FETCH FIRST 50 ROWS ONLY;
```

### 시나리오 2: 날짜 범위 쿼리 최적화

**문제점 (함수 사용)**:
```sql
-- 비효율적인 함수 기반 조건
SELECT COUNT(*) 
FROM ix_demo
WHERE grade = 'VIP'
  AND TRUNC(created_at) = DATE '2025-03-01';
```

**해결책 (범위 조건 사용)**:
```sql
-- SARGable 범위 조건
SELECT COUNT(*) 
FROM ix_demo
WHERE grade = 'VIP'
  AND created_at >= DATE '2025-03-01'
  AND created_at < DATE '2025-03-02';
```

---

## 성능 측정과 분석 방법

### 실행 계획 분석
```sql
-- 상세한 실행 계획 확인
ALTER SESSION SET statistics_level = ALL;

-- 테스트 쿼리 실행
SELECT cust_id, created_at, name
FROM ix_demo
WHERE grade = 'VIP'
  AND created_at BETWEEN DATE '2025-03-01' AND DATE '2025-03-31'
ORDER BY created_at, cust_id;

-- 실행 계획 확인
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL, 'ALLSTATS LAST +PEEKED_BINDS +ALIAS'
));
```

### 인덱스 사용 통계 분석
```sql
-- 인덱스 사용 통계 조회
SELECT index_name,
       blevel,        -- B-tree 레벨 (루트부터 리프까지 깊이)
       leaf_blocks,   -- 리프 블록 수
       distinct_keys, -- 고유 키 수
       clustering_factor, -- 클러스터링 팩터
       num_rows       -- 인덱스 엔트리 수
FROM user_indexes
WHERE table_name = 'IX_DEMO';
```

---

## 고급 인덱스 기법

### 함수 기반 인덱스 (Function-Based Index)
대소문자 구분 없이 검색해야 할 때 유용합니다:
```sql
-- 함수 기반 인덱스 생성
CREATE INDEX ix_demo_name_upper ON ix_demo(UPPER(name));

-- 함수 기반 인덱스 활용 쿼리
SELECT cust_id, name
FROM ix_demo
WHERE UPPER(name) = UPPER(:search_name);
```

### 역키 인덱스 (Reverse Key Index)
INSERT 병목 현상을 완화할 때 사용합니다:
```sql
-- 역키 인덱스 생성
CREATE INDEX ix_demo_reverse ON ix_demo(cust_id) REVERSE;

-- 특징: 범위 스캔에는 부적합, INSERT 경합 완화에 효과적
```

### 비트맵 인덱스 (Bitmap Index)
낮은 카디널리티 컬럼에 적합합니다:
```sql
-- 비트맵 인덱스 생성
CREATE BITMAP INDEX ix_demo_grade_bm ON ix_demo(grade);

-- 특징: DW 환경에서 효율적, 동시 DML 작업 시 주의 필요
```

---

## 일반적인 문제와 해결책

### 문제 1: 인덱스가 사용되지 않는 경우

**원인 분석**:
```sql
-- 인덱스 사용 여부 확인
EXPLAIN PLAN FOR
SELECT * FROM ix_demo WHERE grade = 'VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**해결책**:
1. 통계 정보 갱신
2. 인덱스 재생성
3. 힌트를 통한 강제 인덱스 사용
4. 인덱스 설계 재검토

### 문제 2: 인덱스 범위 스캔이 비효율적인 경우

**증상**: 높은 논리적 읽기 수, 느린 응답 시간

**해결책**:
1. 클러스터링 팩터 개선
2. 커버링 인덱스 도입
3. 인덱스 컬럼 순서 최적화
4. 파티셔닝 고려

---

## 성능 테스트 프레임워크

### A/B 테스트 구현
```sql
-- 성능 비교를 위한 테스트 프레임워크
ALTER SESSION SET statistics_level = ALL;

-- 방법 A 테스트 (기존 방식)
SELECT /*+ METHOD_A */ cust_id, created_at
FROM ix_demo
WHERE grade = 'VIP'
  AND created_at >= DATE '2025-03-01'
  AND created_at < DATE '2025-04-01'
ORDER BY created_at, cust_id;

-- 방법 B 테스트 (개선된 방식)
SELECT /*+ METHOD_B index(ix_demo ix_demo_g_dt) */ 
       cust_id, created_at
FROM ix_demo
WHERE grade = 'VIP'
  AND created_at >= DATE '2025-03-01'
  AND created_at < DATE '2025-04-01'
ORDER BY created_at, cust_id;

-- 결과 비교
SELECT sql_id, 
       plan_hash_value,
       executions,
       buffer_gets,
       disk_reads,
       elapsed_time/1000000 as elapsed_seconds
FROM v$sql
WHERE sql_text LIKE '%METHOD_%'
ORDER BY sql_id;
```

---

## 결론: 효과적인 인덱스 설계와 관리의 종합적 접근

인덱스 최적화는 데이터베이스 성능 관리의 핵심 요소입니다. 효과적인 인덱스 설계를 위해 다음 원칙을 준수하세요:

### 1. 설계 단계에서의 고려사항
- **데이터 접근 패턴 분석**: 가장 빈번하게 실행되는 쿼리 식별
- **컬럼 선택도 평가**: 높은 선택도를 가진 컬럼을 선두에 배치
- **정렬 요구사항 반영**: ORDER BY, GROUP BY에 사용되는 컬럼 포함
- **조인 패턴 고려**: 자주 조인되는 컬럼 인덱스 설계

### 2. 구현 단계의 최적화 기법
- **커버링 인덱스 활용**: 자주 접근하는 컬럼을 인덱스에 포함
- **적절한 인덱스 유형 선택**: B-tree, 비트맵, 함수 기반 등 상황에 맞는 선택
- **파티셔닝과의 통합**: 대용량 테이블에서 파티션 인덱스 활용
- **인덱스 압축 적용**: 저장 공간 효율성과 성능 균형

### 3. 성능 모니터링과 유지보수
- **정기적 통계 갱신**: 데이터 분포 변화 반영
- **인덱스 사용률 모니터링**: 사용되지 않는 인덱스 제거
- **재구성 시기 판단**: 높은 클러스터링 팩터, 단편화 수준 기준
- **AWR/ASH 리포트 분석**: 인덱스 관련 성능 문제 조기 발견

### 4. 조직적 접근과 협업
- **개발자 교육**: 인덱스 설계 원칙과 최적 쿼리 작성법 교육
- **코드 리뷰 프로세스**: 인덱스 사용 패턴 검토
- **성능 기준선 설정**: 변경 전후 성능 비교를 위한 기준 확립
- **문서화와 지식 공유**: 인덱스 설계 결정과 성과 문서화

### 5. 지속적인 개선 사이클
1. **측정**: 현재 인덱스 성능과 사용 패턴 분석
2. **분석**: 문제점과 개선 기회 식별
3. **실험**: 제한된 환경에서 변경 사항 테스트
4. **적용**: 검증된 개선사항 운영 환경 배포
5. **검증**: 변경 효과 지속적 모니터링

인덱스 최적화는 단순한 기술적 작업을 넘어 데이터 접근 패턴 이해, 비즈니스 요구사항 분석, 시스템 성능 목표 설정이 통합된 종합적인 접근이 필요합니다. 효과적인 인덱스 설계는 더 빠른 응답 시간, 더 높은 처리량, 더 낮은 자원 사용률이라는 가시적인 성과로 이어집니다.

모든 인덱스 관련 결정은 실제 성능 측정 데이터에 기반해야 하며, 비즈니스 가치 창출이라는 궁극적 목표를 향해 진행되어야 합니다. 지속적인 모니터링, 측정, 개선을 통해 안정적이고 효율적인 데이터베이스 환경을 구축할 수 있습니다.