---
layout: post
title: 이산수학 - 관계의 표현과 폐쇄
date: 2025-06-25 20:20:23 +0900
category: 이산수학
---
# 관계의 표현과 폐쇄 (Relation Representation and Closure)

## 0) 개요 — 왜 ‘표현’과 ‘폐쇄’가 중요한가?

관계 \(R\subseteq A\times A\)는 **데이터/상태/객체 사이의 연결**을 수학적으로 다루는 기본 도구다.  
현업/연구에서 우리는
1) **표현(Representation)**: 쌍 집합, 디그래프, 0–1 행렬 등으로 바꿔 **시각화/연산**을 쉽게 하고,  
2) **폐쇄(Closure)**: 반사/대칭/추이 같은 **원하는 성질을 가장 작게 추가**(= 최소 확장)하여 문제를 해결한다.

이 글은 세부 표현법, 각 폐쇄의 정의·성질, 알고리즘(워셜/DFS/비트셋 최적화), 실전 예제, 주의점까지 **생략 없이** 정리한다.

---

## 1) 관계의 표현 (Representations)

### 1.1 쌍의 집합 (Set of Ordered Pairs)
정의 그 자체:
$$
R\subseteq A\times A,\qquad (a,b)\in R\ \Leftrightarrow\ a\ R\ b.
$$

- **장점**: 가장 직관적.  
- **단점**: 큰 관계에서 연산(합성/폐쇄) 구현이 번거로움.

> **예**: \(A=\{1,2,3\},\; R=\{(1,2),(2,3)\}\).

---

### 1.2 디그래프 (Directed Graph)
정점 \(V=A\), 간선 \(E=R\) 로 보는 관점.

- **시각화**에 뛰어남(경로/사이클/구성 요소 파악).
- **경로 길이 \(k\)** ↔ **관계의 \(k\)회 합성 \(R^k\)**.

> **예**: \(R=\{(1,2),(2,3),(3,1)\}\) 은 1→2→3→1 **사이클**.

---

### 1.3 0–1 행렬 (Boolean Matrix)
\(A=\{a_1,\dots,a_n\}\)일 때,
$$
(M_R)_{ij}=\begin{cases}
1,&(a_i,a_j)\in R\\
0,&\text{otherwise.}
\end{cases}
$$

- **불(Boole) 연산**으로 합성/폐쇄를 계산:
  - 합성: \(M_{R\circ S}=M_S\ \textbf{·}\ M_R\) (곱은 AND, 합은 OR)
  - 경로 길이 \(k\): \(M_R^k\) (불-멱)
- **규모가 클 때** 워셜/비트셋 최적화 등 구현이 간결.

> **예**: \(A=\{1,2,3\}, R=\{(1,2),(2,3)\}\)
> $$
> M_R=\begin{bmatrix}
> 0&1&0\\
> 0&0&1\\
> 0&0&0
> \end{bmatrix}
> $$
> \(M_R^2\)의 \((1,3)=1\) ⇒ 1→3 길이 2 경로 존재.

---

## 2) 관계의 폐쇄 (Closures) — “원하는 성질을 최소로 덧붙이기”

어떤 성질 \(P\)에 대해, **\(R\)을 포함하면서 \(P\)를 만족하는 관계 중 최소**를 \(P\)-폐쇄라 한다(“최소”= 포함관계로 가장 작음).

### 2.1 반사적 폐쇄 (Reflexive Closure)
모든 \(a\in A\)에 대해 \((a,a)\)를 추가:
$$
R^{r}=R\cup\{(a,a)\mid a\in A\}.
$$

- **최소 반사적 상위관계**.  
- 행렬 관점: 대각을 1로 설정.

> **예**: \(R=\{(1,2),(2,3)\}\Rightarrow R^r=\{(1,1),(2,2),(3,3),(1,2),(2,3)\}\)

---

### 2.2 대칭적 폐쇄 (Symmetric Closure)
\((a,b)\in R\Rightarrow (b,a)\)도 포함:
$$
R^{s}=R\cup R^{-1}.
$$

- **최소 대칭 상위관계**.
- 행렬 관점: \(M\leftarrow M\lor M^\top\).

---

### 2.3 추이적 폐쇄 (Transitive Closure)
경로가 있으면 한 번에 연결:
$$
R^{+}=\bigcup_{k\ge 1}R^k.
$$

- **최소 추이 상위관계**.
- 행렬 관점: \(M^{+}=M\lor M^2\lor \cdots \lor M^n\) (불-연산)  
- 알고리즘: **워셜( \(O(n^3)\) )**, 또는 정점마다 **DFS/BFS**로 도달성 합치기(희소 그래프 실용).

---

### 2.4 반사적-추이적 폐쇄 (Reflexive-Transitive Closure)
보통 \(R^{*}\)로 표기:
$$
R^{*}=R^{+}\cup \{(a,a)\mid a\in A\}.
$$

- 그래프 이론에서는 **reachability**(길이 \(\ge 0\) 경로 존재)를 의미.

---

### 2.5 “동치”/“부분순서”로 가고 싶을 때의 주의
- **동치관계 폐쇄**(반사·대칭·추이)를 한 번에 만들고 싶다면  
  \(R\)에 대해 먼저 대칭폐쇄 \(R\leftarrow R\cup R^{-1}\), 그 다음 추이폐쇄, 마지막 반사 추가 → **연결요소(무향)**가 동치류.
- **부분순서(반사·반대칭·추이)**는 **간선 추가만**으로는 일반에 불가(반대칭은 **제거/축약**이 필요).  
  순환이 있는 그래프는 **SCC(강연결요소) 축약**으로 DAG를 만들고, 그 DAG에 반사를 더하고 추이폐쇄를 고려해야 한다.  
  ⇒ “부분순서 **폐쇄**” 대신 “**전주문(preorder) 폐쇄** + 동치류로 몫(poset)”이 일반적 절차.

---

## 3) 알고리즘 — 워셜, DFS, 비트셋, 불-행렬

### 3.1 워셜 알고리즘(Transitive Closure)
```python
def warshall_bool(M):
    """M: 0/1 정방행렬(list of lists). 변형된 M을 반환(추이폐쇄)."""
    n = len(M)
    C = [row[:] for row in M]  # copy
    for k in range(n):
        for i in range(n):
            if C[i][k]:  # 가지치기
                rowk = C[k]
                rowi = C[i]
                for j in range(n):
                    # 불-합성 (OR over (i,k) AND (k,j))
                    rowi[j] = rowi[j] or rowk[j]
    return C  # C == M^+
```
- **시간** \(O(n^3)\), **공간** \(O(n^2)\).  
- 반사추이폐쇄 \(R^*\)는 결과에서 대각을 True로 설정.

---

### 3.2 정점별 DFS/BFS(희소 그래프 실용)
```python
from collections import deque

def transitive_closure_dfs(adj):
    """
    adj: dict[u] = iterable of v (유향 그래프 인접 리스트)
    반환: reach[u] = set of 노드 (u가 도달 가능한 정점)
    """
    reach = {}
    for s in adj:
        seen = set([s])
        stack = list(adj[s])
        while stack:
            v = stack.pop()
            if v in seen: 
                continue
            seen.add(v)
            for w in adj.get(v, ()):
                if w not in seen:
                    stack.append(w)
        seen.remove(s)  # R^+만 원하면 자기 자신 제거
        reach[s] = seen
    return reach
```
- **시간** \(O(n(n+m))\) 수준(정점마다 DFS), **희소 그래프**면 효율적.

---

### 3.3 비트셋 최적화(대형/밀집 그래프)
- 각 행을 **비트셋(정수/bitarray)**로 들고,  
  $$\text{row}_i \leftarrow \text{row}_i\ \text{OR}\ \big(\text{row}_i[k]\ ?\ \text{row}_k:\ 0\big)$$  
- 파이썬에서는 `int` 비트 연산자로 수천~수만 정점까지도 실용적(언어/라이브러리 따라 상이).

---

### 3.4 불-행렬 멱과 반복 제곱(이론/실험용)
- \(M^+=M\lor M^2\lor \cdots\lor M^{2^{\lceil \log n\rceil}}\) 에서 **반복 제곱**으로 가속.  
- 실제 구현은 워셜/DFS가 더 간단·안전.

---

## 4) 폐쇄의 “최소성”과 증명 스케치

- **반사폐쇄** \(R^r\): \(R\subseteq R^r\), 반사적이다. 임의의 반사적 \(S\supseteq R\)에 대해 \((a,a)\in S\)이므로 \(R^r\subseteq S\) ⇒ 최소.  
- **대칭폐쇄** \(R^s\): 같은 논리(역쌍 모두 있어야 하므로).  
- **추이폐쇄** \(R^+\): 모든 길이 경로를 한 번에 담아야 추이. 임의 추이 \(S\supseteq R\)는 길이 \(k\) 경로를 귀납으로 모두 포함 ⇒ \(R^+\subseteq S\).

---

## 5) 워크드 예제

### 5.1 데이터
- \(A=\{1,2,3,4\}\)  
- \(R=\{(1,2),(2,3),(3,1),(3,4)\}\)  (3-사이클 + 3→4 꼬리)

### 5.2 행렬 표현
$$
M_R=
\begin{bmatrix}
0&1&0&0\\
0&0&1&0\\
1&0&0&1\\
0&0&0&0
\end{bmatrix}
$$

### 5.3 폐쇄의 해석
- **대칭폐쇄**: 모든 간선의 역방향 추가 ⇒ 1↔2↔3↔1, 또한 4↔3 추가.  
- **추이폐쇄 \(R^+\)**:  
  - 1↔2↔3 **강연결** ⇒ 1,2,3 사이 모든 쌍 포함.  
  - 1,2,3에서 4로 도달 가능 ⇒ (1,4),(2,4),(3,4) 포함.  
  - 4에서 타 노드로는 경로 없음.  
- **반사추이폐쇄 \(R^*\)**: 위에 \((1,1),(2,2),(3,3),(4,4)\) 더하기.

### 5.4 코드로 검증
```python
A = [1,2,3,4]
R = {(1,2),(2,3),(3,1),(3,4)}

# 인접 리스트
adj = {a:set() for a in A}
for a,b in R: adj[a].add(b)

reach = transitive_closure_dfs(adj)  # 3.2 절 코드 사용
print(reach[1])  # {2,3,4}
print(reach[2])  # {1,3,4}
print(reach[3])  # {1,2,4}
print(reach[4])  # ∅
```

---

## 6) “동치관계 폐쇄”와 “poset(부분순서) 만들기”

### 6.1 동치관계 폐쇄(최소 동치관계 포함)
절차(간선 **추가만**으로 가능):
1) **대칭폐쇄**: \(R\leftarrow R\cup R^{-1}\)  
2) **추이폐쇄**: \(R\leftarrow R^{+}\)  
3) **반사추가**: 모든 \((a,a)\) 추가  
→ 결과는 **동치관계**. 동치류는 **무향 연결요소**와 동일.

```python
def equivalence_closure(A, pairs):
    R = set(pairs) | {(b,a) for (a,b) in pairs}  # symmetric
    # transitive closure via Warshall on index map
    idx = {a:i for i,a in enumerate(A)}
    n = len(A)
    M = [[0]*n for _ in range(n)]
    for a,b in R: M[idx[a]][idx[b]] = 1
    M = warshall_bool(M)  # 3.1 절
    # add reflexive
    for i in range(n): M[i][i] = 1
    # 역변환
    out = set()
    for i,a in enumerate(A):
        for j,b in enumerate(A):
            if M[i][j]: out.add((a,b))
    return out
```

---

### 6.2 부분순서 만들기(일반 절차)
반대칭은 **간선 제거/축약**이 필요 ⇒ **전주문(반사·추이) + SCC 축약**이 표준.

1) \(R'\leftarrow R\)에 반사 추가, 추이폐쇄(전주문).  
2) \(R'\)의 **강연결요소(SCC)**를 하나의 정점으로 **축약**(서로 도달 가능한 원소는 “같다”로 본다).  
3) 얻어진 **축약 DAG**에서 반사/추이 성질 유지 ⇒ **poset**.

```python
def scc_kosaraju(A, pairs):
    # Kosaraju: O(n+m)
    G = {a:set() for a in A}; GR = {a:set() for a in A}
    for a,b in pairs:
        G[a].add(b); GR[b].add(a)
    seen, order = set(), []
    def dfs1(u):
        seen.add(u)
        for v in G[u]:
            if v not in seen: dfs1(v)
        order.append(u)
    for a in A:
        if a not in seen: dfs1(a)
    comp_id = {}
    def dfs2(u, cid):
        comp_id[u] = cid
        for v in GR[u]:
            if v not in comp_id: dfs2(v, cid)
    cid = 0
    for u in reversed(order):
        if u not in comp_id:
            dfs2(u, cid); cid += 1
    # comp_id: node -> component index
    return comp_id, cid  # cid: #components

def poset_condensation(A, pairs):
    comp, C = scc_kosaraju(A, pairs)
    # 축약 DAG 간선
    E = set()
    for a,b in pairs:
        ca, cb = comp[a], comp[b]
        if ca != cb:
            E.add((ca, cb))
    # 반사 추가(각 컴포넌트의 자기 대각)
    nodes = list(range(C))
    E |= {(c,c) for c in nodes}  # 필요시 제거 가능(보통 poset은 반사 허용)
    return nodes, E, comp  # nodes: 0..C-1
```

> **해석**: 같은 SCC에 있는 원소들은 “서로 도달 가능” → 같다고 본다. 축약 DAG의 \(\le\)는 반사/반대칭/추이 모두 만족 ⇒ **부분순서**.

---

## 7) 보충: 트랜지티브 리덕션 vs 폐쇄

- **추이폐쇄**: 도달성을 **모두 추가**(간선 ↑).  
- **추이리덕션**: 도달성을 **유지하는 최소 간선 집합**(간선 ↓).  
  DAG에서 정의/계산(일반 그래프는 모호).  
  실전에서는 **Hasse 다이어그램**이 추이리덕션의 전형(부분순서에서 **커버 관계**만 남김).

---

## 8) 성질 검사/폐쇄/도구 — 파이썬 유틸 모음

```python
# --- 성질 검사 ---
def is_reflexive(A, R): return all((a,a) in R for a in A)
def is_irreflexive(A, R): return all((a,a) not in R for a in A)
def is_symmetric(R): return all((b,a) in R for (a,b) in R)
def is_antisymmetric(R): return all(a==b or (b,a) not in R for (a,b) in R)

def is_transitive(A, R):
    Rset = set(R)
    nxt = {}
    for a,b in R: nxt.setdefault(a,set()).add(b)
    for a, Bs in nxt.items():
        for b in Bs:
            for c in nxt.get(b, ()):
                if (a,c) not in Rset: return False
    return True

# --- 폐쇄 연산 ---
def reflexive_closure(A, R): return set(R) | {(a,a) for a in A}
def symmetric_closure(R): return set(R) | {(b,a) for (a,b) in R}

def transitive_closure(A, R):
    idx = {a:i for i,a in enumerate(A)}
    n = len(A)
    M = [[0]*n for _ in range(n)]
    for a,b in R: M[idx[a]][idx[b]] = 1
    C = warshall_bool(M)
    out = set()
    for i,a in enumerate(A):
        for j,b in enumerate(A):
            if C[i][j]: out.add((a,b))
    return out

def reflexive_transitive_closure(A, R):
    T = transitive_closure(A, R)
    return T | {(a,a) for a in A}
```

---

## 9) 실습 시나리오 (끝까지 따라하기)

**문제**: “직속 신고 체계” \(R\)가 주어진 조직도에서,  
1) **모든 상하위 관계**(간접 포함)를 한 번에 보고 싶다.  
2) “같은 레벨 묶음”(서로 왕복 가능한, 순환 보고)들을 하나의 그룹으로 압축하고 레벨 간 선후관계를 정렬하고 싶다.

**해결**:
1) \(R^+=\) `transitive_closure` 로 **모든 간접 보고**를 얻는다.  
2) `poset_condensation` 으로 SCC를 그룹핑(동치류) → 축약 DAG(부분순서)를 계산한다.  
   - 이 DAG의 위상정렬 = **레벨링**.  
   - Hasse(커버 간선만)로 그리면 **중복/추이 간선 제거된 깔끔한 계층도**.

---

## 10) 흔한 오해/주의

1) **“반대칭 폐쇄”**라는 것을 **간선 추가만**으로 만들 수는 없음. 반대칭은 보통 **간선 제거 또는 축약(SCC)** 이 필요.  
2) **대칭**과 **반대칭**은 상충 개념이 아님. 동일관계 \(=\)는 둘 다 만족.  
3) **비대칭 ⇒ 비반사성**(자기루프가 있으면 즉시 모순).  
4) **워셜**은 간단/안전하지만 \(O(n^3)\). **희소 그래프**는 DFS/BFS가 실용.  
5) **행렬 곱**은 실수대수곱이 아니라 **불-반군(OR/AND)** 를 사용해야 관계 합성이 맞다.

---

## 11) 미니 과제

1) 임의의 \(n\le 2000\) 정점 그래프에서 **비트셋 워셜**을 구현해 \(R^*\)를 만들어라(파이썬 `int` 비트).  
2) 부분집합 격자 \((\mathcal{P}(S),\subseteq)\)의 **Hasse 간선**을 코드로 생성하고, Graphviz로 시각화해라.  
3) 문자열 길이 동치( \(|s|=|t|\) )의 동치류를 실제 데이터셋(문장 리스트)에 적용해 **클러스터**를 뽑아라.

---

## 12) 요약

- **표현**: 쌍 집합(정의형), 디그래프(시각), 0–1 행렬(연산형).  
- **폐쇄**:  
  - 반사 \(R^r\) — 대각 추가,  
  - 대칭 \(R^s\) — 역쌍 추가,  
  - 추이 \(R^+\) — 모든 경로 압축,  
  - 반사추이 \(R^*\) — reachability(길이 0 포함).  
- **동치/부분순서**:  
  - 동치 폐쇄는 **추가만**으로 가능(대칭→추이→반사).  
  - 부분순서는 보통 **전주문 + SCC 축약**으로 만든다.  
- **알고리즘**: 워셜 \(O(n^3)\), 정점별 DFS/BFS(희소 그래프), 비트셋 최적화(대규모).  
- **실전**: 도달성, 계층화, 정렬, 군집화(동치류), Hasse(추이간선 제거) 등으로 직결.
