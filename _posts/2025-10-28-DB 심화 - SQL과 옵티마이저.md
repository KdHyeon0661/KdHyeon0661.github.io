---
layout: post
title: DB 심화 - SQL과 옵티마이저
date: 2025-10-28 15:25:23 +0900
category: DB 심화
---
# SQL과 옵티마이저(Oracle 중심)

> 목표
> - **SQL이 실행되기까지**(파싱·바인딩·최적화·생성·실행)의 내부 흐름을 정확히 이해한다.
> - **비용기반 옵티마이저(CBO)** 가 **카디널리티(선택도)** 와 **비용**을 어떻게 계산하는지, 왜 틀리는지, 어떻게 바로잡는지 학습한다.
> - **접근 경로/조인순서/조인방법/정렬·해시/파티션 프루닝** 등 핵심 의사결정 포인트를 **실제 실행계획 라인**과 연결한다.
> - **Adaptive Cursor Sharing / Adaptive Plans / Dynamic Sampling / Statistics Feedback** 등 **적응형 기능**을 올바르게 사용하고, **플랜 안정화**(SQL Plan Baseline/Outline/Profile) 방법을 손에 익힌다.
> - 각 섹션에 **실행 가능한 예제**와 **문제→원인→해법** 절차를 제공한다.

---

## 큰 그림: SQL → 실행까지

### 생명주기(요약)

1. **하드 파싱**(텍스트 해시→구문 분석→语义 검사→**최적화**→실행계획 생성→커서 캐시 탑재)
2. **소프트 파싱**(커서 재사용, 필요 시 바인드 피킹/ACS 반영)
3. **실행**(행원(Row Source) 트리 실행, CR/Current 블록 접근, 정렬/해시/조인 수행)
4. **페치**(결과 집계/반환)

### 관찰 포인트(뷰/패키지)

- **실행계획/라인 통계**: `DBMS_XPLAN.DISPLAY_CURSOR('SQL_ID', child, 'ALLSTATS LAST +PEEKED_BINDS +PREDICATE +PROJECTION +NOTE')`
- **커서/통계**: `V$SQL`, `V$SQL_PLAN`, `V$SQL_SHARED_CURSOR`, `V$SQL_BIND_CAPTURE`
- **적응형**: `IS_BIND_SENSITIVE/AWARE`, `V$SQL_CS_*` (버전 의존)
- **플랜 안정화**: `DBA_SQL_PLAN_BASELINES`, `DBMS_SPM`
- **카디널리티/비용 디버깅**: XPLAN의 `E-Rows`(예상 행수) vs `A-Rows`(실측 행수), `Cost`, `Cardinality`, `Note`

---

## 핵심

### 최적화 목표

- 기본 목표: **최소 비용(cost)** 계획. 비용은 대체로 **I/O 비용 + CPU 비용**.
- **통계(Statistics)** 를 입력으로 **카디널리티**(선택도) 추정 → 비용 계산 → 후보 플랜 중 최솟값 선택.

### 선택도/카디널리티 추정(간단 수학)

- 단일 컬럼 **평균 선택도**:
  $$ \text{Sel}(A=v) \approx \frac{1}{\text{NDV}(A)} $$
- 카디널리티(행수):
  $$ \text{Card} = \text{Sel} \times \text{RowCount(table)} $$
- 독립성 가정에서 다중 조건:
  $$ \text{Sel}(A=v \land B=w) \approx \text{Sel}(A=v)\times\text{Sel}(B=w) $$
- 조인 카디널리티(등가 조인):
  $$ \text{Card}(A \bowtie B) \approx \frac{|A|\cdot|B|}{\max(\text{NDV(key}_A), \text{NDV(key}_B))} $$

> 실제 옵티마이저는 **히스토그램**, **코릴레이션**(ColGroup), **동적 샘플링**, **통계 피드백** 등을 통해 위 단순 모델을 보정한다.

### 비용(대략)

- **I/O 비용**: 시퀀셜/랜덤 블록 I/O 예상 횟수 × 가중치
- **CPU 비용**: 연산 수(조인/정렬/해시/필터) × 가중치
- **병렬**/스토리지 특성/파티션·인메모리·압축 등에 따라 보정

---

## 통계(Statistics)와 히스토그램

### 통계 수집(테이블/인덱스/컬럼)

```sql
-- 기본: 최신화 + 인덱스까지
EXEC DBMS_STATS.GATHER_TABLE_STATS(
  ownname    => USER,
  tabname    => 'ORDERS',
  cascade    => TRUE,
  estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE
);

-- 스큐 컬럼 히스토그램(도수분포)
EXEC DBMS_STATS.GATHER_TABLE_STATS(
  ownname => USER, tabname => 'ORDERS', cascade => TRUE,
  method_opt => 'FOR COLUMNS SIZE 75 region SIZE 75 status SIZE 75 order_date'
);
```
- **스큐(불균형)** 컬럼(지역, 상태, 카테고리)은 **히스토그램**으로 정확도↑.
- **NDV**(고유값 수), **NUM_ROWS**, **BLOCKS**, **CLUSTERING_FACTOR**(인덱스 일치성) 등 확인.

```sql
-- 확인
SELECT column_name, histogram, num_distinct, density
FROM   user_tab_col_statistics
WHERE  table_name='ORDERS';
```

### 표현식/함수로 통계 무력화 **금지**

```sql
-- 나쁜 예: TRUNC(컬럼)
WHERE TRUNC(order_date) = DATE '2025-11-01'
-- 좋은 예: 범위로 전개
WHERE order_date >= DATE '2025-11-01' AND order_date < DATE '2025-11-02'
```

### 통계 피드백(Statistics Feedback, 12c+)

- 실행 후 **실측(A-Rows)** 과 **예상(E-Rows)** 괴리가 크면 다음 실행에 **카디널리티 보정** 피드백.
- `Note`에 **"cardinality feedback used"** 유무 확인.

---

## 파싱과 바인드 피킹, Adaptive Cursor Sharing(ACS)

### 바인드 피킹(Bind Peeking)

- 첫 실행 시 바인드 값으로 **선택도 추정** → 플랜 고정.
- 값 분포 스큐가 크면 **잘못된 첫 플랜**이 지속될 수 있음.

### ACS(Adaptive Cursor Sharing)

- 바인드 값 범위를 구간화하여 **여러 Child**로 최적 플랜 유지.
- 확인:
```sql
SELECT sql_id, child_number, is_bind_sensitive, is_bind_aware
FROM   v$sql
WHERE  sql_id='&&SQL_ID'
ORDER  BY child_number;
```
- `V$SQL_SHARED_CURSOR`의 분기 이유(`BIND_MISMATCH`, `OPTIMIZER_MISMATCH` 등) 확인.

### 바인드-스큐 대응 전략

1) **히스토그램**으로 카디널리티 정확화
2) **ACS** 활성(기본) 확인
3) 심각하면 **SQL을 분기**(값대별 다른 힌트/강제 플랜), **SQL Plan Baseline** 사용

---

## 옵티마이저 변환(Transformation)

### 대표 변환 목록

- **Predicate Pushdown**(선행 필터링)
- **OR Expansion**(OR을 UNION ALL로 분해)
- **Subquery Unnesting**(스칼라/인/EXISTS 서브쿼리를 조인 형태로 승격)
- **View Merging / No-Merge**
- **Join Predicate Pushdown**
- **Group-By Placement**(선행 집계)
- **Star Transformation**(스타 스키마)
- **Join Factorization**(공통 부분인 조인 팩터링)

### Unnesting 예제

```sql
-- 원본: 스칼라 서브쿼리
SELECT o.order_id, (
  SELECT SUM(od.qty*od.price)
  FROM   order_detail od
  WHERE  od.order_id = o.order_id
) total_amount
FROM   orders o
WHERE  o.order_date BETWEEN :d1 AND :d2;

-- 변환(의도): 조인 + 그룹
SELECT o.order_id, SUM(od.qty*od.price) total_amount
FROM   orders o LEFT JOIN order_detail od ON od.order_id=o.order_id
WHERE  o.order_date BETWEEN :d1 AND :d2
GROUP  BY o.order_id;
```
- 옵티마이저가 자동 전개하는 경우가 많음. 라인에서 `HASH JOIN`/`GROUP BY` 구조 확인.
- **NO_UNNEST**, **NO_MERGE**, **USE_NL/USE_HASH** 등으로 교정 가능.

---

## 접근 경로(Access Path)와 조인 전략

### 접근 경로

- **INDEX UNIQUE/RANGE/FAST FULL/SCAN DESCENDING**
- **TABLE ACCESS BY ROWID**(인덱스 후 테이블 접근)
- **FULL TABLE SCAN**(멀티블록 I/O, 큰 범위에 유리)
- **SAMPLE**(동적 샘플링)
- **PARTITION PRUNING**(RANGE/LIST/HASH, SUBPARTITION 포함)
- **INMEMORY ACCESS**, **BLOOM FILTER**(병렬/스타)

### 조인 방법

- **Nested Loops(NL)**: 드라이빙 소량 + 인덱스 존재 시 최강(랜덤 I/O)
- **Hash Join**: 대량/병렬/균일 분포에 유리(메모리 부족 시 **Temp 스필**)
- **Sort Merge Join**: 정렬 비용 vs 이미 정렬/인덱스 스캔 순서 활용 시 고려

### 조인 순서

- 일반적으로 **선택도 높은(소량)** 집합을 먼저.
- 힌트: `LEADING`, `ORDERED`, `USE_NL`, `USE_HASH`, `DRIVING_SITE`(분산)
- 예제:
```sql
SELECT /*+ LEADING(c o) USE_NL(o) INDEX(o ix_orders_cust_date) */
       c.cust_id, SUM(o.amount)
FROM   customers c JOIN orders o ON o.cust_id=c.cust_id
WHERE  c.segment=:seg AND o.order_date BETWEEN :d1 AND :d2
GROUP  BY c.cust_id;
```

---

## 정렬/해시와 Temp 스필(스택 제거의 기술)

### 증상

- 대기: `direct path read temp`, `direct path write temp`
- 라인: `SORT GROUP BY/ORDER BY`, `HASH JOIN/AGGREGATE` 의 **TempSpc/Time** ↑

```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&&SQL_ID', NULL,
 'ALLSTATS LAST +PREDICATE +PROJECTION +NOTE'));
```

### 해법

1) **카디널리티 정확화**로 입력량 축소(히스토그램/필터 푸시/재작성)
2) **정렬 회피 인덱스**(ORDER BY와 동일한 인덱스 순서)
3) 해시→NL(소량 우선), 또는 **선행 집계**
4) **PGA** 및 **workarea** 정책 점검

---

## 파티션/스타 변환/병렬

### 파티션 프루닝

- DDL:
```sql
CREATE TABLE sales (
  dt DATE, region VARCHAR2(10), prod_id NUMBER, amount NUMBER
)
PARTITION BY RANGE (dt) (
  PARTITION p2025_10 VALUES LESS THAN (DATE '2025-11-01'),
  PARTITION p2025_11 VALUES LESS THAN (DATE '2025-12-01')
);
```
- 쿼리:
```sql
SELECT /*+ USE_NL(f) */ SUM(amount)
FROM   sales s JOIN fact f ON f.sale_id=sale_id
WHERE  s.dt BETWEEN :d1 AND :d2 AND s.region=:r;
```
- 계획에서 `PARTITION RANGE SINGLE/ITERATOR` 확인 → **I/O 질적 감소**.

### 스타 변환(Star Transformation)

- 팩트 + 다수 차원 **비트맵 인덱스** → 차원 필터를 **팩트로 Bloom Filter** 적용
- 대용량 **OLAP** 질의에서 효과적
- 힌트: `STAR_TRANSFORMATION ENABLE`

### 병렬(Parallel)

- `/*+ PARALLEL(table N) */`, `PQ_DISTRIBUTE`(분배 전략)
- 주의: **Temp/I/O** 급증 위험 → 통계/카디널리티 정확화 후 사용

---

## 적응형 플랜(Adaptive Plans)과 동적 샘플링

### Adaptive Plans(12c+)

- 실행 중 관측에 따라 **NL↔Hash** 선택을 바꾸거나, 분기에 따른 플랜 경로를 **런타임 선택**.
- `Note`에서 **"adaptive plan"** 표시 확인.

### Dynamic Sampling/Automatic Degree

- 통계 부정확/미존재 시 런타임 **샘플링**으로 선택도 보정.
- 지나친 의존은 **불안정**을 유발 → **정상 통계** 우선.

---

## 실행계획 읽기(필수 습관)

### XPLAN 포맷

```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  sql_id => '&&SQL_ID',
  child_number => NULL,
  format => 'ALLSTATS LAST +PEEKED_BINDS +PREDICATE +PROJECTION +OUTLINE +NOTE'
));
```
- **E-Rows** vs **A-Rows** 차이를 먼저 본다 → **카디널리티 오류** 여부.
- **Time/TempSpc/Buffers** 큰 라인이 병목.
- **Predicate 정보**로 프루닝/인덱스 적용 여부 확인.

### 라인-이벤트 상관(ASH)

```sql
SELECT sql_plan_line_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sql_id='&&SQL_ID'
  AND  sample_time > SYSTIMESTAMP - INTERVAL '15' MINUTE
GROUP  BY sql_plan_line_id
ORDER  BY samples DESC;
```
- 라인 집중 + 이벤트(`direct path read temp`/`db file sequential read`/`enq: TX ...`)를 매핑.

---

## 플랜 안정화: SPM / Outline / Profile

### SQL Plan Baseline(SPM)

```sql
-- 현재 좋은 플랜을 베이스라인으로 캡처
BEGIN
  DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE(sql_id => '&&SQL_ID');
END;
/
SELECT sql_handle, plan_name, enabled, accepted
FROM   dba_sql_plan_baselines
WHERE  sql_handle LIKE 'SQL_%';
```
- 통계 변경/환경 변동에도 **좋은 플랜 유지**.

### SQL Profile(튜닝팩)

- 옵티마이저에 **카디널리티 보정 힌트** 주입(자동 SQL Tuning)
- 라이선스/운영정책 고려.

### Outline

- 힌트 집합으로 플랜 형태 고정(레거시 호환/임시 대응)

---

## 실전 시나리오: 문제→원인→해법

### 보고서가 느리다(정렬 스필)

**증상**: ASH Top Event `direct path read temp`, XPLAN에서 `SORT GROUP BY` 라인 `TempSpc↑`
**원인**: 카디널리티 과대 → 입력 과다, 정렬 인덱스 부재
**해법**:
1) 스큐 컬럼 히스토그램
```sql
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',
     method_opt=>'FOR COLUMNS SIZE 75 region size 75 order_date');
```
2) 정렬 회피 커버링 인덱스
```sql
CREATE INDEX ix_orders_r_dt_amt ON orders(region, order_date, amount);
```
3) 필요 시 PGA 조정/해시→NL
**검증**: `ALLSTATS LAST` TempSpc↓, `awrdiff.sql` Temp I/O↓, p95↓.

---

### 특정 값에서만 느림(바인드 스큐)

**증상**: 어떤 `region='APAC'`일 때만 느림, 다른 값은 정상.
**원인**: 최초 바인드 피킹으로 **잘못된 플랜 고정**, 또는 ACS 미적용.
**해법**:
1) 히스토그램 → 선택도 정확화
2) ACS 확인(`IS_BIND_SENSITIVE/AWARE='Y'`)
3) 필요 시 값대 분기 SQL/힌트(혹은 Baseline 두 개 수용)
**검증**: Child 커서 2~3개로 안정, 각 범위에 맞는 플랜.

---

### 조인 순서 오류로 대량 해시 스필

**증상**: `HASH JOIN` 상위, TempSpc↑, `A-Rows`가 예상보다 큼.
**원인**: 드라이빙을 대량 테이블로 선택.
**해법**: `LEADING(소량→대량)`, `USE_NL(대상)` 혹은 통계 보정으로 자동선택 유도.
**검증**: 라인 시간↓, TempSpc↓.

---

### 파티션 프루닝 미적용

**증상**: 월 범위 조건인데도 Full Scan 비용 큼, 계획에 `PARTITION RANGE` 없음.
**원인**: 함수로 감싼 날짜, 데이터 타입 불일치, 통계/경계 미스.
**해법**: 함수 제거/범위식, 바인드 타입 일치, 파티션 키 포함 인덱스.
**검증**: `PARTITION RANGE SINGLE/ITERATOR`, 물리 I/O↓.

---

## 튜닝 체크리스트(암기 카드)

1) **E-Rows vs A-Rows**: 큰 괴리 = 카디널리티 오류 → 통계/히스토그램/표현식 제거
2) **접근경로**: 인덱스 적용/커버링/클러스터링 팩터/프루닝 → 랜덤 vs 대량 판단
3) **조인**: 소량→대량(드라이빙), NL vs Hash 선택 근거 확인
4) **정렬/해시**: TempSpc 라인 제거(정렬 회피 인덱스/선행 집계/PGA)
5) **바인드 스큐**: 히스토그램/ACS/값대 분기
6) **적응형/동적 샘플링**: 도움되지만 **안정성**은 통계가 핵심
7) **플랜 안정화**: Baseline/Profile/Outline로 “좋을 때” 고정
8) **증명**: `DBMS_XPLAN(ALLSTATS LAST)` + ASH 타임라인 + 전/후 p95/AWR Diff

---

## 실습: 처음부터 끝까지

### 데이터 준비(간단)

```sql
CREATE TABLE orders (
  order_id    NUMBER PRIMARY KEY,
  customer_id NUMBER,
  region      VARCHAR2(10),
  status      VARCHAR2(10),
  order_date  DATE,
  amount      NUMBER
);
CREATE INDEX ix_orders_region_date ON orders(region, order_date);

-- 샘플 로드(생략 가능): 지역/날짜에 스큐를 주되, APAC 비중 60% 등
```

### 통계 + 히스토그램

```sql
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS', cascade=>TRUE,
     method_opt=>'FOR COLUMNS SIZE 75 region SIZE 75 status SIZE 75 order_date');
```

### 문제 쿼리

```sql
VAR d1 DATE; VAR d2 DATE; VAR r VARCHAR2(10);
EXEC :d1 := DATE '2025-10-01'; EXEC :d2 := DATE '2025-11-01'; EXEC :r := 'APAC';

SELECT region, order_date, SUM(amount) amt
FROM   orders
WHERE  region=:r
AND    order_date BETWEEN :d1 AND :d2
GROUP  BY region, order_date
ORDER  BY region, order_date;
```

### 계획/라인 확인

```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
 'ALLSTATS LAST +PREDICATE +PROJECTION +PEEKED_BINDS +NOTE'));
```
- `SORT GROUP BY` 라인 `TempSpc`↑라면 정렬 회피를 검토.

### 해법 적용

```sql
-- 정렬 회피 커버링 인덱스(그룹/정렬 컬럼 포함)
CREATE INDEX ix_orders_r_dt_amt ON orders(region, order_date, amount);

-- 또는 선행 집계 물질화 뷰(보고서 용도)
CREATE MATERIALIZED VIEW mv_orders_daily
BUILD IMMEDIATE REFRESH FAST ON COMMIT AS
SELECT region, TRUNC(order_date) d, SUM(amount) amt
FROM   orders
GROUP  BY region, TRUNC(order_date);
```

### 재검증

- **XPLAN**: `SORT` 사라지거나 `TempSpc`≈0
- **ASH**: `direct path read temp` 샘플↓
- **V$SQL**: `sec/exec` 낮아짐

---

## 점검/진단 스크립트 모음

### 평균 단가(누적 기준)

```sql
SELECT sql_id, plan_hash_value, executions,
       ROUND(elapsed_time/1e6/NULLIF(executions,0),3) s_per_exec,
       ROUND(buffer_gets/NULLIF(rows_processed,0),1) gets_per_row
FROM   v$sql
WHERE  executions >= 10
ORDER  BY s_per_exec DESC
FETCH FIRST 20 ROWS;
```

### 최근 15분 라인 집중(ASH)

```sql
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '15' MINUTE; EXEC :t2 := SYSTIMESTAMP;

SELECT sql_id, sql_plan_line_id, event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
GROUP  BY sql_id, sql_plan_line_id, event
ORDER  BY samples DESC FETCH FIRST 20 ROWS;
```

### Child 폭증 원인

```sql
-- Child 수
SELECT sql_id, COUNT(*) children FROM v$sql GROUP BY sql_id
HAVING COUNT(*)>5 ORDER BY children DESC;

-- 공유 실패 이유
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_id='&&SQL_ID' AND reason IS NOT NULL AND reason <> 'N';
```

### 플랜 변동 감시

```sql
SELECT sql_id, COUNT(DISTINCT plan_hash_value) plans, SUM(executions) execs
FROM   v$sql
WHERE  last_active_time > SYSDATE - 1
GROUP  BY sql_id
HAVING COUNT(DISTINCT plan_hash_value) > 1
ORDER  BY plans DESC;
```

---

## 자주 쓰는 힌트(요약·주의)

- **접근/조인**: `INDEX(t idx)`, `FULL(t)`, `USE_NL(t)`, `USE_HASH(t)`, `LEADING(a b ...)`, `ORDERED`
- **변환 제어**: `NO_MERGE(v)`, `NO_UNNEST`, `PUSH_PRED`
- **파티션**: `PQ_DISTRIBUTE`, `PARTITION(hash/range ...)`(상황별)
- **스타/병렬**: `STAR_TRANSFORMATION`, `PARALLEL(t N)`
- **주의**: 힌트는 **정확한 문맥/별칭** 필요, 과다 사용은 **가독성·이식성** 저하. 가능하면 **통계/모델**로 자연스런 선택 유도.

---

## 성능 철학(마무리)

- **옵티마이저는 “사실(통계)”에 기초해 “가설(플랜)”을 세운다.**
- 가설이 빗나갔다면 **카디널리티**(선택도)부터 바로 잡아라. 그러면 다수의 문제는 **저절로 해결**된다.
- 남는 것은 **업무적 의도**(정렬·집계·조인 흐름)를 **쿼리 구조/인덱스/파티션**으로 명확히 표현하는 일.
- 불확실성을 줄이기 위해 **Adaptive 기능**과 **플랜 안정화**를 도구로 사용하되, **관측과 재검증**(XPLAN+ASH+AWR Diff)으로 닫아라.

> 한 줄 정리
> **SQL과 옵티마이저의 싸움은 ‘숫자(카디널리티)’를 누가 더 잘 알리느냐의 싸움이다.**
> 숫자를 바로 세우고(통계/히스토그램), 의도를 명확히 표현(인덱스/구조/힌트 최소)하면, 플랜은 당신 편이 된다.
