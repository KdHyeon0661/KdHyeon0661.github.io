---
layout: post
title: 형식언어와 오토마타 - 정규 언어에 대한 기본적인 문제들
date: 2025-07-04 23:20:23 +0900
category: 형식언어와 오토마타
---
# 정규 언어에 대한 기본적인 문제들 (Decision Problems for Regular Languages)

> 목표  
> - **핵심 결정 문제**(수용·공허성·유한성·보편성·동치·포함·분리·접두/접미 관련)의 정의, 직관, **정확한 알고리즘과 복잡도**  
> - DFA/NFA 모델에서 **항상 작동하는 표준 절차**(BFS/ε-closure/SCC/곱구성/보완·교차)  
> - **실행 가능한 Python 레퍼런스 코드**(DFA/NFA, 결정 문제 함수, 반례(구분 문자열) 생성기)  
> - 증명 스케치(올바름·완전성·복잡도), 자주 생기는 **함정 & 체크리스트**

---

## 0. 배경과 표기

정규 언어 클래스는 **유한 오토마타**(DFA/NFA/ε-NFA)와 정규표현식, 정규 문법(Type-3)로 **동등**하게 기술된다.  
이 때문에 많은 결정 문제가 **선형~다항 시간**에 해결 가능하다.

- 알파벳: $$\Sigma$$, 문자열 집합: $$\Sigma^\*$$, 공백 문자열: $$\varepsilon$$  
- DFA: $$M=(Q,\Sigma,\delta,q_0,F)$$ (불완전해도 무방, 필요 시 sink로 완전화)  
- NFA/ε-NFA: $$\delta:Q\times(\Sigma\cup\{\varepsilon\})\to \mathcal P(Q)$$  
- 곱구성(product): 두 DFA $$A,B$$로부터 상태 공간 $$Q_A\times Q_B$$인 기계를 만드는 표준 조합

---

## 1. 핵심 결정 문제 — 개념, 알고리즘, 복잡도

### 1. 수용성(Membership)
> 입력 문자열 $$w$$가 주어진 오토마타 $$A$$의 언어에 속하는가? 즉 $$w\in L(A)$$?

- **DFA**: 시작상태에서 $$w$$를 따라 상태를 갱신하여 **한 번** 통과 → $$O(|w|)$$  
- **NFA/ε-NFA**: 매 단계 **ε-closure** 후 입력 기호에 대한 **상태 집합 이동** → $$O(|w|\cdot(|Q|+|E|))$$ 내외

---

### 2. 공허성(Emptiness)
> $$L(A)=\varnothing$$ ?

- **아이디어**: 시작상태에서 **(ε 포함) 도달 가능한** 상태 중 수용상태가 있는지 **BFS/DFS**로 점검  
- **복잡도**: $$O(|Q|+|E|)$$

---

### 3. 보편성(Universality)
> $$L(A)=\Sigma^\*$$ ?

- **아이디어**: DFA를 **완전화**(모든 전이 정의) → **보완**(수용/비수용 뒤집기) → **공허성** 검사  
- **복잡도**: 완전화/보완 선형 + 공허성선형 ⇒ 전체 $$O(|Q|+|E|)$$

---

### 4. 유한성(Finiteness)
> $$|L(A)|<\infty$$ ?

- **정리**(DFA): 시작상태에서 **도달 가능한 순환(SCC, cycle)**이 있고, 그 순환에서 **수용상태로 도달 가능**하면 **무한**.  
  그렇지 않으면 **유한**.
- **알고리즘**: 도달성 체크 → **SCC 분해**(Tarjan/Kosaraju) → 각 SCC에 cycle 존재 여부(size>1 또는 self-loop) +
  수용상태 가도달성 검사
- **복잡도**: $$O(|Q|+|E|)$$

---

### 5. 동치성(Equivalence)
> $$L(A)=L(B)$$ ?

- **아이디어**: **대칭차** $$L(A)\triangle L(B) = (L(A)\setminus L(B)) \cup (L(B)\setminus L(A))$$  
  = **교집합**(A, **보완 B**) ∪ **교집합**(보완 A, B).  
  또는 **곱구성 DFA**로 한 번에 처리: “두 기계에서 수용/비수용 판정이 **서로 다른**” 조합을 수용상태로 하여 **공허성** 검사.
- **복잡도**: 곱구성 선형, 공허성 선형 ⇒ $$O(|Q_A||Q_B| + |E_A||E_B|)$$

---

### 6. 포함성(Inclusion)·분리성(Disjointness)
> 포함: $$L(A)\subseteq L(B)$$ ?  
> 분리: $$L(A)\cap L(B)=\varnothing$$ ?

- **포함**: $$L(A)\setminus L(B)=\varnothing \Leftrightarrow L(A)\cap \overline{L(B)}=\varnothing$$  
  ⇒ 곱구성으로 교집합 공허성 검사
- **분리**: 곱구성 후 교집합 **수용상태 도달** 여부로 판단  
- **복잡도**: 동치와 동일한 차수

---

### 7. 접두사/접미사 관련(Prefix/Suffix/Substring)
> $$\mathrm{Pref}(L)=\{u\mid \exists v: uv\in L\}$$  
> $$\mathrm{Suff}(L)=\{v\mid \exists u: uv\in L\}$$  
> $$\mathrm{Substr}(L)=\{x\mid \exists u,v: uxv\in L\}$$

- **접두사**: DFA에서 “**수용에 도달 가능한** 모든 상태”를 **수용상태로 승격** → 동일 전이로 DFA 얻음.  
  (역방향 그래프에서 수용까지 **co-reach** 가능한 상태 표식)
- **접미사**: DFA에서 “**도달 가능한 모든 상태를 시작상태로**” 하는 **NFA** 만들면 됨.  
  (원래 시작에서 도달 가능한 상태 집합을 초기상태 집합으로 채택)
- **부분문자열**(substring): “모든 상태를 시작상태, 모든 상태를(혹은 수용 도달 가능한 상태를) 수용상태”로 하는 변형 NFA 등으로 가능.  
  (목적 언어에 따라 정확 정식화 다름: 예컨대 ‘원래 L의 **어떤 경로 중간**에서부터 읽을 수 있는 모든 꼬리’ 등)

모두 **정규성 보존**(닫힘성) + 위 구성은 선형 시간.

---

## 2. 파이썬 레퍼런스 코드 — DFA/NFA 및 결정 문제 도구

> 교육·블로그용으로 간결하게 작성. 실무에선 입력검증/최소화(Hopcroft)/비트셋 최적화 권장.

```python
from collections import defaultdict, deque
from typing import Dict, Set, Tuple, Iterable, Optional, List

Sym = str
State = str

# -------------------- ε-NFA --------------------
class ENFA:
    def __init__(self,
                 Q: Iterable[State],
                 Sigma: Iterable[Sym],
                 delta: Dict[Tuple[State, Sym], Set[State]],
                 q0: State,
                 F: Iterable[State],
                 eps: Sym = 'ε'):
        self.Q: Set[State] = set(Q)
        self.Sigma: Set[Sym] = set(Sigma)
        self.delta: Dict[Tuple[State, Sym], Set[State]] = defaultdict(set)
        for (q, a), dests in delta.items():
            self.delta[(q, a)] |= set(dests)
        self.q0: State = q0
        self.F: Set[State] = set(F)
        self.eps: Sym = eps

    # ε-closure of a set of states
    def eclosure(self, S: Iterable[State]) -> Set[State]:
        stack = list(S)
        seen = set(S)
        while stack:
            q = stack.pop()
            for r in self.delta.get((q, self.eps), set()):
                if r not in seen:
                    seen.add(r); stack.append(r)
        return seen

    # Membership: O(|w| * (|Q|+|E|)) in practice
    def accepts(self, w: str) -> bool:
        curr = self.eclosure({self.q0})
        for ch in w:
            if ch not in self.Sigma: return False
            nxt = set()
            for q in curr:
                nxt |= self.delta.get((q, ch), set())
            curr = self.eclosure(nxt)
            if not curr: return False
        return len(curr & self.F) > 0

# -------------------- DFA --------------------
class DFA:
    def __init__(self,
                 Q: Iterable[State],
                 Sigma: Iterable[Sym],
                 delta: Dict[Tuple[State, Sym], State],
                 q0: State,
                 F: Iterable[State]):
        self.Q: Set[State] = set(Q)
        self.Sigma: Set[Sym] = set(Sigma)
        self.delta: Dict[Tuple[State, Sym], Optional[State]] = dict(delta)
        self.q0: State = q0
        self.F: Set[State] = set(F)

    # Membership in O(|w|)
    def run(self, w: str) -> bool:
        q = self.q0
        for ch in w:
            q = self.delta.get((q, ch))
            if q is None:  # 불완전 DFA: 정의 안 된 전이는 거부
                return False
        return q in self.F

    # 완전화(필요 시) - sink 추가
    def complete(self, sink="__SINK__") -> "DFA":
        if sink in self.Q:
            sink = sink + "_0"
        Q = set(self.Q)
        delta = dict(self.delta)
        need_sink = False
        for q in Q:
            for a in self.Sigma:
                if (q,a) not in delta:
                    need_sink = True
        if need_sink:
            Q.add(sink)
            for a in self.Sigma:
                delta[(sink,a)] = sink
            for q in list(Q):
                for a in self.Sigma:
                    delta.setdefault((q,a), sink)
        return DFA(Q, self.Sigma, delta, self.q0, self.F)

    # 도달 가능한 상태 집합
    def reachable(self) -> Set[State]:
        fwd = defaultdict(list)
        for (q,a),p in self.delta.items():
            if p is not None:
                fwd[q].append(p)
        seen, dq = {self.q0}, deque([self.q0])
        while dq:
            u = dq.popleft()
            for v in fwd[u]:
                if v not in seen:
                    seen.add(v); dq.append(v)
        return seen

# -------------------- 기본 결정 문제 --------------------

# Emptiness (DFA): 시작->수용 도달 여부
def is_empty_dfa(D: DFA) -> bool:
    reach = D.reachable()
    return len(reach & D.F) == 0

# Universality (DFA): Σ* 여부 = 보완의 공허성
def is_universal_dfa(D: DFA) -> bool:
    C = D.complete()
    compF = C.Q - C.F
    # 공허성: compF에 도달 가능한가?
    # 시작에서 compF가 전혀 도달되지 않으면 보완이 공허 → 원래 보편
    fwd = defaultdict(list)
    for (q,a),p in C.delta.items():
        fwd[q].append(p)
    seen, dq = set([C.q0]), deque([C.q0])
    while dq:
        u = dq.popleft()
        if u in compF:
            return False  # 보완이 공허가 아님 → 원래 보편 아님
        for v in fwd[u]:
            if v not in seen:
                seen.add(v); dq.append(v)
    return True

# Finiteness (DFA) via SCC + accept reachability
def is_finite_dfa(D: DFA) -> bool:
    # 1) 도달 가능한 부분만 추림
    R = D.reachable()
    # 2) 역방향 그래프 & 정방향 그래프
    fwd = defaultdict(list)
    rev = defaultdict(list)
    for (q,a),p in D.delta.items():
        if q in R and p in R:
            fwd[q].append(p)
            rev[p].append(q)
    # 3) 수용상태로의 가도달성(co-reach): 역BFS from F
    can_reach_F = set()
    dq = deque(D.F & R)
    can_reach_F |= (D.F & R)
    while dq:
        u = dq.popleft()
        for v in rev[u]:
            if v not in can_reach_F:
                can_reach_F.add(v); dq.append(v)
    # 4) R∩can_reach_F 서브그래프에 사이클 존재?
    #    사이클 판정: (i) self-loop or (ii) SCC 크기 > 1
    # Kosaraju (간단 구현)
    order: List[State] = []
    seen = set()
    def dfs1(u):
        seen.add(u)
        for v in fwd[u]:
            if v in R and v in can_reach_F and v not in seen:
                dfs1(v)
        order.append(u)
    for q in R:
        if q in can_reach_F and q not in seen:
            dfs1(q)
    comp = {}
    def dfs2(u, root):
        comp[u] = root
        for v in rev[u]:
            if v in R and v in can_reach_F and v not in comp:
                dfs2(v, root)
    for u in reversed(order):
        if u in can_reach_F and u not in comp:
            dfs2(u, u)
    # 집합별 크기와 self-loop 검사
    groups = defaultdict(set)
    for u,r in comp.items(): groups[r].add(u)
    for r,vs in groups.items():
        if len(vs) >= 2:
            return False  # 무한
        # self-loop?
        v = next(iter(vs))
        for x in fwd[v]:
            if x == v:
                return False
    return True  # 유한

# Equivalence / Inclusion / Disjointness via product
def equivalent_dfa(A: DFA, B: DFA) -> bool:
    assert A.Sigma == B.Sigma
    # 대칭차 공허성 검사
    # 상태: (p,q). 수용: (p in F_A) XOR (q in F_B)
    from collections import deque
    Sigma = A.Sigma
    A = A.complete(); B = B.complete()
    start = (A.q0, B.q0)
    seen = set([start]); dq = deque([start])
    while dq:
        p,q = dq.popleft()
        if (p in A.F) ^ (q in B.F):
            return False  # 반례 존재
        for a in Sigma:
            np = A.delta[(p,a)]; nq = B.delta[(q,a)]
            s = (np,nq)
            if s not in seen:
                seen.add(s); dq.append(s)
    return True

def included_dfa(A: DFA, B: DFA) -> bool:
    # L(A) ⊆ L(B) ?  <=>  L(A) ∩ complement(B) = ∅
    assert A.Sigma == B.Sigma
    Sigma = A.Sigma
    A = A.complete(); B = B.complete()
    start = (A.q0, B.q0)
    seen = set([start]); dq = deque([start])
    while dq:
        p,q = dq.popleft()
        if (p in A.F) and (q not in B.F):  # A는 수용, B는 비수용 → 증거
            return False
        for a in Sigma:
            np = A.delta[(p,a)]; nq = B.delta[(q,a)]
            s = (np,nq)
            if s not in seen:
                seen.add(s); dq.append(s)
    return True

def disjoint_dfa(A: DFA, B: DFA) -> bool:
    # L(A) ∩ L(B) = ∅ ?
    assert A.Sigma == B.Sigma
    Sigma = A.Sigma
    A = A.complete(); B = B.complete()
    start = (A.q0, B.q0)
    seen = set([start]); dq = deque([start])
    while dq:
        p,q = dq.popleft()
        if (p in A.F) and (q in B.F):
            return False
        for a in Sigma:
            np = A.delta[(p,a)]; nq = B.delta[(q,a)]
            s = (np,nq)
            if s not in seen:
                seen.add(s); dq.append(s)
    return True

# Prefix(L) DFA: “수용에 도달 가능”한 모든 상태를 수용으로
def prefix_closure_dfa(D: DFA) -> DFA:
    # 역그래프로 F까지 co-reach 구함
    R = D.reachable()
    rev = defaultdict(list)
    for (q,a),p in D.delta.items():
        if q in R and p in R:
            rev[p].append(q)
    can_reach_F = set(D.F) & R
    dq = deque(can_reach_F)
    while dq:
        u = dq.popleft()
        for v in rev[u]:
            if v not in can_reach_F:
                can_reach_F.add(v); dq.append(v)
    # 같은 전이, 수용만 can_reach_F로 교체
    new_delta = {(q,a):p for (q,a),p in D.delta.items() if q in R and p in R}
    return DFA(R, D.Sigma, new_delta, D.q0, can_reach_F)

# Suffix(L) NFA: “도달 가능한 모든 상태를 시작상태”로 하는 NFA
def suffix_closure_nfa_from_dfa(D: DFA) -> ENFA:
    R = D.reachable()
    # 초기상태를 하나로 합치고 ε로 R의 각 상태로 분기 (혹은 초기집합을 R로 두는 다중시작 NFA)
    q0 = "__INIT__"
    Q = set(R) | {q0}
    delta = defaultdict(set)
    for (q,a),p in D.delta.items():
        if q in R and p in R:
            delta[(q,a)].add(p)
    # ε로 R의 모든 상태로 분기
    for s in R:
        delta[(q0,'ε')].add(s)
    return ENFA(Q, D.Sigma, delta, q0, D.F)
```

---

## 3. 예제 시나리오 — 테스트와 직관

### 3.1 짝수 개의 `0` DFA (Membership/Universality/Prefix)

```python
D_even0 = DFA(
    Q={'q0','q1'}, Sigma={'0','1'},
    delta={
        ('q0','0'):'q1', ('q0','1'):'q0',
        ('q1','0'):'q0', ('q1','1'):'q1',
    },
    q0='q0', F={'q0'}
)

print("Membership:")
for w in ["", "0", "00", "10100", "111"]:
    print(w, "=>", D_even0.run(w))

print("Empty? ", is_empty_dfa(D_even0))
print("Universal? ", is_universal_dfa(D_even0))  # 당연히 False

# 접두사 언어: Pref(L) 구성
Pref_even0 = prefix_closure_dfa(D_even0)
print("Pref even-0 examples:")
for w in ["", "0", "1", "10", "101", "10100"]:
    print(w, "=>", Pref_even0.run(w))
# 직관: 어떤 w가 확장되어 수용될 수 있으면(뒤에 꼬리를 붙이면) Pref에서 True
```

**해설**  
- 원 DFA는 `0`의 개수가 짝수인 문자열만 수용  
- **접두사 언어**는 “**뒤에 뭔가를 붙이면** 짝수 개가 될 수 있는” 모든 접두사를 수용 ⇒ 실제로 많은 접두사가 True가 된다.

---

### 3.2 유한성 검사 예 (순환 유무)

```python
# 끝에 정확히 '01'로 끝나는 언어 (무한)
D_ends01 = DFA(
    Q={'A','B','C'},
    Sigma={'0','1'},
    delta={
        ('A','0'):'B', ('A','1'):'A',
        ('B','0'):'B', ('B','1'):'C',
        ('C','0'):'B', ('C','1'):'A',
    },
    q0='A', F={'C'}
)
print("Finite? (ends with 01)", is_finite_dfa(D_ends01))  # False

# 유한 언어 DFA 예: {ε, '0', '1'}만 수용하도록 만든 작은 기계
D_finite = DFA(
    Q={'S','A','B','DEAD'},
    Sigma={'0','1'},
    delta={
        ('S','0'):'A', ('S','1'):'B',
        ('A','0'):'DEAD', ('A','1'):'DEAD',
        ('B','0'):'DEAD', ('B','1'):'DEAD',
        ('DEAD','0'):'DEAD', ('DEAD','1'):'DEAD',
    },
    q0='S', F={'S','A','B'}
)
print("Finite? (finite set)", is_finite_dfa(D_finite))  # True
```

- 첫 번째 DFA는 어떤 문자열에든 적절히 이어 붙이면 `...01`을 만들 수 있고, 내부에 **순환**이 있어 무한  
- 두 번째 DFA는 DEAD(비수용 흡수)로 빨려 들어가면서 더 이상 수용상태로 돌아오지 못함 ⇒ 유한

---

### 3.3 동치·포함·분리 + 반례 찾기 직관

```python
# D1: '1'의 개수 짝수
D_even1 = DFA(
    Q={'p0','p1'}, Sigma={'0','1'},
    delta={
        ('p0','0'):'p0', ('p0','1'):'p1',
        ('p1','0'):'p1', ('p1','1'):'p0',
    },
    q0='p0', F={'p0'}
)

# D2: 모든 문자열 (보편) -- 간단 구현(완전수용)
D_all = DFA(
    Q={'s'}, Sigma={'0','1'},
    delta={('s','0'):'s', ('s','1'):'s'},
    q0='s', F={'s'}
)

print("Equiv(D_even1, D_all)?", equivalent_dfa(D_even1, D_all))   # False
print("Included(D_even1 ⊆ D_all)?", included_dfa(D_even1, D_all)) # True
print("Disjoint(D_even1, D_all)?", disjoint_dfa(D_even1, D_all))  # False
```

- 짝수-1 DFA는 보편 DFA와 **동치 아님**, **포함성은 참**, **분리성은 거짓**

> **반례(구분 문자열)**를 실제로 **찾아 출력**하고 싶다면, 위 product-BFS에서 “처음 수용 조건 충족” 시 그까지의 **경로 라벨**을 함께 저장하면 된다(아래 부록 코드 참고).

---

### 3.4 접미사 언어(DF A → NFA) 예

```python
# '...01' 언어의 접미사들의 집합 (Suffix(L))
Suff_ends01 = suffix_closure_nfa_from_dfa(D_ends01)

for w in ["01","1","001","101","10","0",""]:
    print("suffix contains", w, "?", Suff_ends01.accepts(w))
# 직관: 어떤 w가 원래 DFA의 “어떤 도달 상태”에서 읽으면 수용에 도달할 수 있으면 True
```

---

## 4. 올바름 스케치 & 복잡도 표

### 4.1 올바름(핵심 아이디어)
- **공허성**: 시작에서 (ε 포함) **수용 상태 도달** 가능 iff 언어가 비공허  
- **보편성**: 보완의 공허성과 동치(정규어는 보완에 닫힘, DFA 보완은 상태 라벨 반전)  
- **유한성**: 수용에 도달 가능한 영역에 **순환**이 있으면 그 순환을 **반복**해 무한히 많은 길이를 만들 수 있음  
- **동치/포함/분리**: 곱구성에서 조건(대칭차/교집합)을 **수용 여부**로 바꿔 **공허성**으로 환원  
- **접두사**: “수용에 도달 가능한 상태”를 수용으로 만들면, 어떤 접두사든 적절한 꼬리로 완성 가능 ⇔ 수용  
- **접미사**: 시작을 전체 도달상태로 확장하면, 원 오토마타에서 **어떤 지점에서 읽기 시작**한 꼬리 전부를 수용

### 4.2 복잡도 요약

| 문제 | DFA 복잡도(상수 Σ 가정) | 메모 |
|---|---:|---|
| Membership | $$O(|w|)$$ | NFA는 ε-closure 포함해 선형·준선형 |
| Emptiness | $$O(|Q|+|E|)$$ | BFS/DFS |
| Universality | $$O(|Q|+|E|)$$ | 완전화 + 보완 + 공허성 |
| Finiteness | $$O(|Q|+|E|)$$ | 도달성 + SCC |
| Equivalence | $$O(|Q_A||Q_B|+|E_A||E_B|)$$ | 곱구성 + 공허성 |
| Inclusion | 동등 | 곱구성 + 보완 |
| Disjointness | 동등 | 곱구성 |
| Prefix/Suffix 구성 | 선형 | 역·도달성 + 간단 구성 |

---

## 5. 실무 팁 & 함정 체크리스트

- **불완전 DFA**: 보완/집합연산 전엔 **완전화**(sink 추가) 필수  
- **NFA 공허성**: ε-closure를 **항상 포함**해서 도달성 판단  
- **유한성**: “순환이 있는가?”만이 아니라, 그 순환이 **수용으로 도달 가능**해야 무한  
- **접미사 구성**: 초기상태를 **모든 도달 가능한 상태**(임의 상태 전부 X)로 — 비도달 상태는 원래 시작에서 **출발 불가**  
- **동치 반례**: 제품 자동자 BFS에 **경로 라벨**을 저장하면 가장 짧은 구분 문자열 자동 획득  
- **최소화**: 동치 검사 전에 두 DFA를 **최소화**하면 상태 폭 감소·반례 더 짧음(Hopcroft)

---

## 6. (부록) 반례(구분 문자열) 생성기 & 간단 Hopcroft 연결

```python
def distinguishing_word(A: DFA, B: DFA) -> Optional[str]:
    """A,B가 동치가 아니면 가장 짧은 구분 문자열 w를 반환. 동치면 None."""
    assert A.Sigma == B.Sigma
    Sigma = sorted(A.Sigma)
    A = A.complete(); B = B.complete()
    from collections import deque
    start = (A.q0, B.q0)
    parent = {start: (None, '')}  # (prev_state, symbol)
    dq = deque([start])
    while dq:
        p,q = dq.popleft()
        if (p in A.F) ^ (q in B.F):
            # reconstruct
            path = []
            cur = (p,q)
            while parent[cur][0] is not None:
                prev, ch = parent[cur]
                path.append(ch)
                cur = prev
            return "".join(reversed(path))
        for a in Sigma:
            np = A.delta[(p,a)]; nq = B.delta[(q,a)]
            s = (np,nq)
            if s not in parent:
                parent[s] = ((p,q), a)
                dq.append(s)
    return None  # 동치

# 예시:
w = distinguishing_word(D_even1, D_all)
print("distinguishing word:", w)  # 예: "" 또는 "0" 등 (보편과의 차이라 빈문자열이 반례인 경우도)
```

> Hopcroft 최소화 전체 구현은 본 문서 분량상 생략(앞서 별도 글에서 제공).  
> 동치 판정을 더 빠르게 하려면 **최소화 후** 상태·전이를 직접 비교하는 것도 실무 팁.

---

## 7. 연습문제 (해설 힌트)

1) **유한성 변형**  
   입력 DFA에서 “길이 **정확히** $$k$$ 인 문자열만” 수용하는 DFA를 구성하고, 그 **유한성**을 증명하라.  
   *힌트*: 길이 카운터(상태) $$k+1$$ 개, 수용은 길이 $$k$$ 도달상태.

2) **보편성의 대체 특징**  
   DFA가 보편이면 **모든 상태가 수용**일 필요는 없다. 반례를 구성하라.  
   *힌트*: 시작에서 절대로 가지 못하는 비수용 상태가 있어도 보편일 수 있다.

3) **접두사 DFA의 최소화**  
   §3.1에 만든 Pref(L) DFA를 최소화하고, 원 DFA와의 관계(상태 수 증가/감소)를 예로 분석하라.

4) **NFA 동치**  
   두 NFA의 동치를 직접 검사하는 대신, 각각을 **부분집합구성(DFA화)→최소화→동치**로 판정하는 파이프라인을 코드로 작성하라.

---

## 8. 요약

- 정규 언어는 **결정 문제** 다수가 **선형~다항 시간**에 해결: 공허성·보편성·유한성·동치·포함·분리·접두/접미 등.  
- **도구상자**: 완전화/보완, 곱구성, ε-closure, BFS/DFS, **SCC**(유한성), (옵션) **최소화**.  
- **반례 생성**은 제품 자동자 BFS에서 **경로 라벨 추적**으로 자동화 가능.  
- **닫힘성**(합·교·차·보완·접두/접미 등) 덕에 “결정 문제 ↔ 공허성” 환원이 광범위하게 통한다.

> 실무 감각으로는:  
> “**공허성 검사** 하나만 제대로 구현하면, **동치·포함·보편**은 **한두 줄의 래핑**으로 끝난다.” — 곱구성과 보완이 전부다.