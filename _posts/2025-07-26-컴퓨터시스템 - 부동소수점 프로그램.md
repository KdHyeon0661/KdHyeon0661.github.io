---
layout: post
title: 컴퓨터시스템 - 부동소수점 프로그램
date: 2025-07-26 18:20:23 +0900
category: 컴퓨터시스템
---
# 💡 부동소수점 프로그램: 정확성과 이식성, 연산의 함정

부동소수점(floating point) 수치는 실수를 근사하여 표현하는 방식으로, 과학 계산, 컴퓨터 그래픽, 머신러닝, 물리 시뮬레이션 등 다양한 분야에서 핵심적으로 사용됩니다. 하지만 이 수치는 **정확한 실수 표현이 아니며**, **근사값**이라는 본질 때문에 다루는 데 주의가 필요합니다.

---

## 1. 부동소수점의 개요

부동소수점 수는 다음과 같은 형식으로 표현됩니다.

\[
x = (-1)^s \times M \times 2^E
\]

여기서,

- \( s \): 부호 비트 (0: 양수, 1: 음수)
- \( M \): 가수(Mantissa) 혹은 유효숫자(Significand)
- \( E \): 지수(Exponent)

IEEE 754 표준에서는 다음과 같은 형식을 사용합니다.

### 📌 단정도(float, 32비트)

| 비트수 | 의미                |
|--------|---------------------|
| 1비트  | 부호 \( s \)         |
| 8비트  | 지수 \( e \) (bias 127) |
| 23비트 | 소수 가수 \( frac \)  |

\[
\text{값} = (-1)^s \times (1 + frac) \times 2^{e - 127}
\]

### 📌 배정도(double, 64비트)

| 비트수 | 의미                |
|--------|---------------------|
| 1비트  | 부호 \( s \)         |
| 11비트 | 지수 \( e \) (bias 1023) |
| 52비트 | 소수 가수 \( frac \)  |

\[
\text{값} = (-1)^s \times (1 + frac) \times 2^{e - 1023}
\]

---

## 2. 값의 유형

IEEE 754에서 부동소수점 값은 크게 다음의 세 가지로 분류됩니다:

### ✅ Normalized Values

- 지수 \( e \in (1, 2^k - 2) \)
- 실제 지수 \( E = e - bias \)
- 가수는 암묵적으로 '1'이 포함됨 → \( 1 + frac \)
- 정규화되어 있어 **정확한 비트 수의 정밀도**를 갖음

### ✅ Denormalized Values

- 지수 \( e = 0 \)
- 실제 지수 \( E = 1 - bias \)
- 가수는 \( 0 + frac \), 즉 암묵적인 1 없음
- **아주 작은 수**를 표현할 때 사용됨
- 정밀도 손실 있음

### ✅ Special Values

- \( e = 2^k - 1 \)
  - \( frac = 0 \): ±∞ (Infinity)
  - \( frac ≠ 0 \): NaN (Not a Number)
- 연산 에러, 무한 루프, 정의되지 않은 결과 등에서 나타남

---

## 3. 실수 저장 예제

### 예: `1.0` (float)

- 수학적 표현: \( 1.0 = 1.0 \times 2^0 \)
- 부호: 0
- 지수: 127 → `01111111`
- 가수: 0 → `00000000000000000000000`

```
IEEE 754: 0 01111111 00000000000000000000000  
16진수:   0x3F800000
```

### 예: `-0.75` (float)

- 이진 표현: `-1 × (1.1) × 2^-1 = -0.75`
- 부호: 1
- 지수: \( -1 + 127 = 126 \) → `01111110`
- 가수: `10000000000000000000000`

```
IEEE 754: 1 01111110 10000000000000000000000  
16진수:   0xBF400000
```

---

## 4. 부동소수점 연산의 함정

부동소수점은 수학적으로 정확한 연산이 아닙니다. 몇 가지 함정은 다음과 같습니다:

### ❗정밀도 손실

```c
#include <stdio.h>

int main() {
    float a = 1.0f;
    float b = 1e-8f;
    float c = a + b - a;
    printf("Result: %.10f\n", c); // 예상: 1e-8
    return 0;
}
```

**결과:** 0.0000000000

- `a + b`에서 `b`는 정밀도 한계로 인해 무시될 수 있음
- 소수점 이하 7자리 이상의 정밀도는 보장되지 않음

---

### ❗교환법칙이 성립하지 않음

```c
float a = 1e20, b = -1e20, c = 3.14f;

float r1 = (a + b) + c;  // 0 + 3.14 = 3.14
float r2 = a + (b + c);  // a + (-1e20 + 3.14) ≈ a + (-1e20) = 0

// r1 ≠ r2
```

→ 부동소수점에서는 수학적 법칙이 항상 성립하지 않음

---

### ❗비교 연산의 문제

```c
float x = 0.1f;
if (x == 0.1f) {
    printf("Equal\n");
} else {
    printf("Not Equal\n"); // 이게 출력될 수도 있음
}
```

- `0.1`은 정확히 표현 불가능
- **비교는 반드시 오차 허용 범위 안에서 해야 함**

```c
#include <math.h>
if (fabs(x - 0.1f) < 1e-6f) { ... }
```

---

## 5. C에서의 활용과 안전한 처리

### ✅ 정밀도 확보

- `float`보다 `double`, `double`보다 `long double` 사용
- 연산에 따라 **타입 승격(promote)** 주의

```c
double a = 1e-10;
float b = 1e-10f;
printf("%e %e\n", a, b); // 차이 확인 가능
```

### ✅ 비교 방식

```c
float a = 1.0f;
float b = 1.0f + 1e-8f;
if (fabs(a - b) < 1e-6f) {
    // 실질적으로 같음으로 처리
}
```

---

## 6. 실용적 예제: 수치 적분

```c
double f(double x) {
    return x * x;
}

double integrate(double a, double b, int n) {
    double h = (b - a) / n;
    double sum = 0.0;
    for (int i = 0; i < n; ++i) {
        sum += f(a + i * h) * h;
    }
    return sum;
}
```

- `double` 사용하여 정밀도 확보
- 구간 분할 수가 크면 오차 감소

---

## 7. IEEE 754 연산 규칙

IEEE 754는 다음과 같은 규칙을 따릅니다:

- 덧셈, 곱셈, 나눗셈, 제곱근 등에 대해 **반올림 오차 최소화** 전략 적용
- **4가지 반올림 모드** 존재:
  - 가장 가까운 값 (기본)
  - 0쪽으로 절삭
  - +∞쪽 반올림
  - -∞쪽 반올림

- 예외 처리 방식:
  - 오버플로우 → ±∞
  - 0으로 나눔 → ±∞ 또는 NaN
  - 정의되지 않은 결과 → NaN

---

## 8. 결론 및 프로그래밍 팁

- 부동소수점은 **정확하지 않다**는 전제로 프로그래밍
- **정밀한 비교 대신 오차 범위 내 비교**
- 반복되는 연산에서 **오차 누적 주의**
- **정수 ↔ 부동소수점 변환 시 손실** 존재