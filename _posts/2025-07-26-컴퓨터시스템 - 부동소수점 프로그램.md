---
layout: post
title: 컴퓨터시스템 - 부동소수점 프로그램
date: 2025-07-26 18:20:23 +0900
category: 컴퓨터시스템
---
# 부동소수점 프로그램: 정확성과 이식성, 연산의 함정

## 0. 한눈에 보기 — 핵심 요약

| 주제 | 실무 핵심 |
|---|---|
| **표준** | IEEE 754: 형식(float/double/long double), 반올림 모드, 예외/플래그 |
| **정밀도** | `float`≈7자릿수, `double`≈16자릿수. “실수”가 아닌 **근사치** |
| **연산법칙 불성립** | (a+b)+c ≠ a+(b+c), 비교는 **에psilon** 또는 **ULP**로 |
| **특수값** | ±0, ±∞, NaN(quiet/signaling), **서브노멀(subnormal)** |
| **이식성** | `long double` 크기/형식 상이, x87(80비트) vs SSE2/NEON, FTZ/DAZ |
| **성능·안정성** | Kahan/Neumaier/Pairwise, FMA(`fma`), `hypot/log1p/expm1` 등 안정형 API |
| **재현성** | 컴파일러 플래그·라운딩·FMA 여부 고정, 병렬 합산 순서 고정 |
| **금융/소수** | 이진 부동소수점 대신 **정수 스케일 고정소수점**·십진부동(필요시) |

---

## 1. IEEE 754 형식과 값의 체계

### 1.1 일반 형식

$$
x = (-1)^s \times M \times 2^E,\quad M \in [1,2)\ \text{(정규)},\ M\in[0,1)\ \text{(서브노멀)}
$$

#### 단정도(`float`, 32비트)
- 비트: `s:1 | e:8 | frac:23`, bias=127  
- 정규: $$x = (-1)^s (1+\text{frac})2^{e-127}$$  
- 서브노멀: $$x = (-1)^s (\text{frac})2^{1-127}$$

#### 배정도(`double`, 64비트)
- 비트: `s:1 | e:11 | frac:52`, bias=1023  
- 정규/서브노멀은 위와 동일 구조, bias만 1023

#### 특수값
- `e = all-ones` & `frac=0` → **±∞**  
- `e = all-ones` & `frac≠0` → **NaN** (quiet/signaling: 최상위 frac 비트로 구분하는 구현 多)  
- **서명있는 0**: +0, -0 (부호비트만 다름)

### 1.2 예: 비트/16진 덤프

```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>

static void dump_float(float f){
    uint32_t u; memcpy(&u, &f, sizeof u);
    printf("float=%.9g hex=0x%08X\n", f, u);
}
static void dump_double(double d){
    uint64_t u; memcpy(&u, &d, sizeof u);
    printf("double=%.17g hex=0x%016llX\n", d, (unsigned long long)u);
}
int main(void){
    dump_float(1.0f);    // 0x3F800000
    dump_float(-0.75f);  // 0xBF400000
    dump_double(0.1);    // 0x3FB999999999999A (표현 불가의 대표)
}
```

---

## 2. 라운딩과 연산 규칙

### 2.1 기본 반올림 모드
- **Nearest, ties-to-even** (기본)
- Toward zero, Toward +∞, Toward -∞

가드/라운드/스티키 비트로 내부 반올림을 결정. 대부분의 연산은 “가장 가까운 값”으로 반올림되어 **불가피한 오차**가 생긴다.

### 2.2 IEEE 예외 플래그와 `fenv.h`
- 예외: `FE_INVALID`, `FE_DIVBYZERO`, `FE_OVERFLOW`, `FE_UNDERFLOW`, `FE_INEXACT`
- 라운딩 제어: `fesetround(FE_TONEAREST /*...*/)`  
- 예외 상태 접근: `feclearexcept`, `fetestexcept`

```c
#pragma STDC FENV_ACCESS ON
#include <fenv.h>
#include <math.h>
#include <stdio.h>
int main(void){
    fesetround(FE_TONEAREST);
    feclearexcept(FE_ALL_EXCEPT);
    volatile double x = 1.0, y = 1e-310, z = x + y;
    if (fetestexcept(FE_INEXACT)) puts("inexact!");
    printf("%.17g\n", z);
}
```

> 이식성: 일부 플랫폼/옵션에서 FENV 최적화를 제한해야 정확히 작동(`-frounding-math`, `-ffp-model=strict` 등, 컴파일러별 상이).

---

## 3. 함정 1 — 정밀도 손실과 법칙 불성립

### 3.1 작은 값 더하기 “소실”

```c
#include <stdio.h>
int main(void){
    float a = 1.0f, b = 1e-8f;
    float c = (a + b) - a;
    printf("expect~1e-8, got=%.10f\n", c); // 0 또는 극소
}
```

- `float` 유효자릿수 한계(≈7자리)로 **b가 반올림되어 사라짐**.

### 3.2 결합법칙 실패

```c
float a=1e20f, b=-1e20f, c=3.14f;
float r1 = (a+b)+c;   // 0 + 3.14 = 3.14
float r2 = a+(b+c);   // (-1e20 + 3.14) ≈ -1e20, → a + (-1e20) = 0
// r1 != r2
```

- 부동소수점은 **실수체가 아니므로** 결합법칙·교환법칙·분배법칙이 일반적으로 성립하지 않는다.

### 3.3 비교는 **에psilon/ULP 기반**으로

```c
#include <math.h>
#include <stdbool.h>
bool approx_eq_rel(double x, double y, double rel){
    double m = fmax(fabs(x), fabs(y));
    return fabs(x-y) <= rel * (m > 1 ? m : 1.0);
}
```

**ULP 기반**(이진 인접값 거리) 비교도 유용:

```c
#include <stdint.h>
#include <string.h>
#include <math.h>
static int64_t ulp_dist(double x, double y){
    uint64_t a,b; memcpy(&a,&x,8); memcpy(&b,&y,8);
    // 부호를 고려한 정렬(토털오더 근사)
    if ( (int64_t)a < 0 ) a = 0x8000000000000000ULL - a;
    if ( (int64_t)b < 0 ) b = 0x8000000000000000ULL - b;
    return (int64_t)(a>b? a-b : b-a);
}
```

---

## 4. 함정 2 — 소멸적 상쇄와 안정 알고리즘

### 4.1 카타스트로픽 캔슬레이션
- 거의 같은 수의 **차**를 계산하면 유효자릿수가 급감.  
- 예: \( \sqrt{x+1}-\sqrt{x} \)는 변형 \( \dfrac{1}{\sqrt{x+1}+\sqrt{x}} \)이 안정.

### 4.2 합계는 **보정합** 또는 **분할합**

**(1) Kahan 보정합**:

```c
double kahan_sum(const double *a, int n){
    double s=0.0, c=0.0;
    for(int i=0;i<n;++i){
        double y = a[i] - c;
        double t = s + y;
        c = (t - s) - y;
        s = t;
    }
    return s;
}
```

**(2) Neumaier**(큰 수/작은 수 뒤섞임에 강함):

```c
double neumaier_sum(const double *a, int n){
    double s=0.0, c=0.0;
    for(int i=0;i<n;++i){
        double t = s + a[i];
        if (fabs(s) >= fabs(a[i])) c += (s - t) + a[i];
        else                       c += (a[i] - t) + s;
        s = t;
    }
    return s + c;
}
```

**(3) Pairwise(분할-정복)**: 재귀/병렬에 유리, 재현성 높이기 쉬움.

---

## 5. 함정 3 — 특수값(±0, ±∞, NaN)과 분기

### 5.1 ±0의 영향
- \( \frac{1}{+0} = +\infty,\ \frac{1}{-0} = -\infty \)
- 비교/부호 복사:

```c
#include <math.h>
double sgn_zero(double x){ return copysign(0.0, x); }
```

### 5.2 NaN
- **모든 비교가 false** (`x==x`도 false)  
- `isnan(x)`로 판별, `fmin/fmax`는 NaN 처리 정의 있음(표준 함수 사용 권장).  
- Quiet/Signaling 차이는 플랫폼·컴파일러에 따라 신호 처리/트랩이 다름.

### 5.3 분기 안정 API
- `hypot(x,y)` 는 \( \sqrt{x^2+y^2} \)의 오/언더플로 방지
- `log1p(x)` 는 \( \log(1+x) \), `expm1(x)` 는 \( e^x-1 \)의 소수 근방 안정
- `fma(a,b,c)` 는 **단일 반올림**으로 \( a\cdot b + c \) 계산

```c
#include <math.h>
double d = fma(a, b, c);     // 정확도/성능 득
double r = hypot(x, y);
double t = log1p(u), s = expm1(v);
```

---

## 6. 함정 4 — 서브노멀, FTZ/DAZ, 성능

- 매우 작은 정규 범위 밖(서브노멀)은 **정밀도 낮고 느릴 수 있음**(마이크로아키텍처 의존).  
- 일부 플랫폼/플래그(**FTZ**, **DAZ**)는 서브노멀을 0으로 취급해 **성능 향상**(정밀도 손실 대가).

> 이식/재현성이 중요하면 FTZ/DAZ 여부를 **고정**하고 문서화.

---

## 7. 이식성 포인트 — 아키텍처와 컴파일러

### 7.1 `long double`의 함정
- x86 GCC/Clang: 80비트(x87) 또는 128비트(quad, 일부), MSVC: 64비트와 동일 취급 등 **플랫폼 차** 큼.
- 바이너리 I/O/네트워크 전송 시 **명시적 형식 변환** 권장.

### 7.2 x87(80비트) vs SSE2/AVX
- x87은 **레지스터 확장 정밀도(80b)** 로 “과잉 정밀” → 중간 결과가 더 정확/다름.
- 재현성 요구 시:
  - GCC/Clang: `-mfpmath=sse -msse2` 로 SSE2 강제,  
  - `-fexcess-precision=standard`(GCC), `-ffp-model=strict`(Clang/ICX/MSVC 유사 옵션) 등.

### 7.3 “빠른 수학” 옵션의 위험
- `-ffast-math`(GCC/Clang), `/fp:fast`(MSVC): 재배열·역수 근사·NaN 무시 등 **수학적 등가성 가정** → 정확성/NaN/±0/예외 무시.
- **기본**은 엄격 모드 유지, 필요 구역에만 제한적 사용 권장.

### 7.4 GPU/ARM/Power 이슈
- FMA 기본 활성, 라운딩·Flush 규칙 차, 서브노멀 처리 차.  
- 크로스 타깃 재현성 목표라면 **FMA on/off, 라운딩, FTZ**를 일관 고정.

---

## 8. 신뢰할 수 있는 비교·출력·파싱

### 8.1 라운드트립 출력
- `double` → 텍스트 → `double` 왕복은 `%.17g` 권장(충분한 유효숫자).
- `float`는 `%.9g` 정도.

```c
printf("%.17g\n", x);
```

### 8.2 안전 비교 패턴
- **절대+상대 혼합**:

```c
#include <math.h>
int eq_eps(double x, double y, double abs_eps, double rel_eps){
    double d = fabs(x-y);
    if (d <= abs_eps) return 1;
    return d <= rel_eps * fmax(fabs(x), fabs(y));
}
```

---

## 9. 정확도 향상: 수치 안정 변형 레시피

| 원식 | 문제 | 안정형 |
|---|---|---|
| \( \sqrt{x^2+y^2} \) | 오/언더플로 | `hypot(x,y)` |
| \( e^x-1 \) | x≈0 상쇄 | `expm1(x)` |
| \( \log(1+x) \) | x≈0 상쇄 | `log1p(x)` |
| \( \sin x - x \) | x≈0 상쇄 | 급수/`expm1` 유사 기법 |
| \( 1-\cos x \) | x≈0 상쇄 | \(2\sin^2(x/2)\) |
| \( \sqrt{a}-\sqrt{b} \) | a≈b 상쇄 | \( \frac{a-b}{\sqrt{a}+\sqrt{b}} \) |

---

## 10. 합산·평균·분산의 안정 계산

### 10.1 평균(온라인)

```c
typedef struct { double mean; long n; } online_mean_t;
void om_add(online_mean_t *s, double x){
    s->n++;
    s->mean += (x - s->mean)/s->n;
}
```

### 10.2 분산(Welford)

```c
typedef struct { long n; double mean, M2; } welford_t;
void wf_add(welford_t *s, double x){
    s->n++;
    double d = x - s->mean;
    s->mean += d / s->n;
    double d2 = x - s->mean;
    s->M2 += d * d2;
}
double wf_var(const welford_t *s){ return s->n>1 ? s->M2/(s->n-1) : NAN; }
```

- **수치 안정** + 단일 패스.

---

## 11. 병렬/분산 합산과 재현성

- 병렬 감소(reduction)는 **순서가 비결정** → 합산 결과 변동.  
- 재현성 필요:
  - **Pairwise 고정 트리**(입력 분할 순서 고정)  
  - Kahan/Neumaier를 블록 단위로 적용 후 상위에서 병합  
  - FMA/라운딩/FTZ/플래그 **고정** 및 문서화

---

## 12. 금융/화폐/소수 — 부동소수점 대신 무엇을?

- 이진 부동소수점은 `0.1`을 정확히 표현 **불가**.  
- 대안:
  - **정수 스케일 고정소수점**(예: “원”/“전”을 `int64_t`로)
  - 십진 부동(플랫폼·라이브러리 필요)
  - 문자열 기반 정밀(빅데시멀) — 성능 대가

```c
#include <stdint.h>
typedef int64_t won;        // 1원 단위
typedef __int128 big;       // 필요시 128-bit 중간합
won add_won(won a, won b){ return a + b; }
```

---

## 13. 사례 연구

### 13.1 0.1 누적 vs 곱셈

```c
#include <stdio.h>
int main(void){
    double s = 0;
    for (int i=0;i<10;++i) s += 0.1;      // 누적 오차
    printf("sum=%.17g, 10*0.1=%.17g\n", s, 10*0.1);
}
```

- 둘 다 “정확히 1.0”이 아님. 출력은 0.999999999999... or 1.000000000000... 근방.  
- 비교는 **epsilon/ULP**로.

### 13.2 Kahan vs naive

```c
#include <stdio.h>
#include <math.h>
double naive_sum(int n){
    double s=0;
    for(int i=1;i<=n;++i) s += 1.0/i;
    return s;
}
double kahan_sum_harm(int n){
    double s=0,c=0;
    for(int i=1;i<=n;++i){
        double y = 1.0/i - c;
        double t = s + y;
        c = (t - s) - y;
        s = t;
    }
    return s;
}
int main(void){
    int n=10000000;
    printf("naive=%.15g\n", naive_sum(n));
    printf("kahan=%.15g\n", kahan_sum_harm(n));
}
```

- 큰 \(n\)에서 차이 뚜렷.

---

## 14. 포팅 가이드라인(체크리스트)

1. **형식 고정**: `float`/`double`/`long double` 의미 문서화 (플랫폼별 차 주의).  
2. **컴파일러 옵션**:  
   - 정확성/재현성: `-fno-fast-math`, `-fexcess-precision=standard`(GCC), `-ffp-model=strict`(Clang/ICX/MSVC 유사), `-mfpmath=sse -msse2`(x86).  
   - 라운딩/예외 사용 시: `-frounding-math`, `#pragma STDC FENV_ACCESS ON`.  
3. **FMA 정책**: `fma` 사용/금지 정책 고정(플랫폼 FMA 존재 시 결과 달라짐).  
4. **FTZ/DAZ 정책**: 켜기/끄기 일관성 유지, 문서화.  
5. **병렬 합산**: Pairwise 고정 트리/보상합 채택.  
6. **비교**: epsilon/ULP 도입, 절대+상대 혼합 기준 정의.  
7. **API**: `hypot/log1p/expm1/fma` 등 안정 API 우선.  
8. **I/O**: 라운드트립 포맷(`%.17g`) 규정.  
9. **금융**: 고정소수점/십진 부동으로 설계.  
10. **테스트**: 다양한 라운딩 모드·서브노멀·NaN/∞ 경계 케이스 포함.

---

## 15. 수학적 보조: 머신 엡실론과 ULP

### 15.1 머신 엡실론
- 가장 작은 \( \epsilon > 0 \) s.t. \( 1 \oplus \epsilon > 1 \) (여기서 ⊕는 반올림 포함 덧셈).  
- `float`≈\(2^{-23}\)≈\(1.19\times10^{-7}\), `double`≈\(2^{-52}\)≈\(2.22\times10^{-16}\).

### 15.2 ULP(Unit in the Last Place)
- 어떤 실수 근방에서 **인접 representable 값 간 간격**.  
- 상대 오차 척도로 유용. `nextafter(x, +∞)`로 ULP 크기 관찰 가능.

```c
#include <math.h>
double ulp(double x){
    double nx = nextafter(x, INFINITY);
    return fabs(nx - x);
}
```

---

## 16. 안정 다항식 평가: Horner + FMA

다항식 \( p(x)=a_0 + a_1 x + \cdots + a_n x^n \)

```c
#include <math.h>
double poly(double x, const double *a, int n){
    double y = a[n];
    for(int i=n-1;i>=0;--i) y = fma(y, x, a[i]); // Horner + FMA
    return y;
}
```

- 재배열 최소화 + 단일 반올림로 오차 축소.

---

## 17. 라운딩 모드 민감 계산의 통제

특정 알고리즘은 라운딩 모드 의존. 재현성 필요 시 **모드 고정**:

```c
#pragma STDC FENV_ACCESS ON
#include <fenv.h>
#include <stdio.h>
int main(void){
    fesetround(FE_TOWARDZERO);
    // ... 계산 ...
    fesetround(FE_TONEAREST); // 원복
}
```

> 주: 최적화에 의해 무시되지 않도록 컴파일러 옵션으로 **엄격 FP**를 강제.

---

## 18. 디버깅 팁

- **경계 케이스**: 0, ±0, 최솟/최댓 정규, 서브노멀, NaN, ±∞  
- **트랩 설정**(플랫폼/라이브러리): invalid/divbyzero/overflow 발생 시 중단  
- **언더플로 성능**: 입력 규모 조정/스케일링, FTZ 사용 여부 검토  
- **정밀 로그**: 중간 결과를 `%.17g`로 기록하여 오차 누적 추적

---

## 19. 연습문제

1) `double`에서 `1.0 + 2^-54 > 1.0`인지, `1.0 + 2^-53 > 1.0`인지 실험하고 이유를 설명하라.  
2) `x≈0` 범위에서 `sin x`와 `(exp(i x)-exp(-i x))/(2i)`의 수치 안정성을 비교하라.  
3) `sum(1..n)`을 큰수→작은수, 작은수→큰수, Kahan, Pairwise로 각각 구현하고 오차/시간을 표로 비교하라.  
4) `double`과 `long double`(해당 플랫폼 정의)에 대해 `hypot`/`log1p` 사용 유무가 결과에 미치는 차이를 측정하라.

---

## 20. 결론

부동소수점은 **근사 계산의 규약**이다. 정확성·이식성·재현성을 얻으려면:
- 표준(IEEE 754)의 **형식/반올림/예외**를 이해하고,
- **안정 알고리즘**과 **적절한 API**를 선택하며,
- **컴파일러·아키텍처 설정**을 고정/문서화하고,
- 비교·I/O·경계 처리를 **정책화**해야 한다.

같은 수학이라도 **구현 선택**에 따라 결과·성능·재현성이 크게 달라진다. 위 가이드라인을 체크리스트로 삼아, 프로젝트 초기에 **FP 정책**을 확정해두는 것이 가장 높은 ROI를 준다.

---

## 부록 A) 실전 스니펫 모음

### A.1 결과 ULP 차이 출력

```c
#include <stdio.h>
#include <math.h>
#include <stdint.h>
#include <string.h>

static long long ulp_dist(double a, double b){
    uint64_t ua, ub; memcpy(&ua,&a,8); memcpy(&ub,&b,8);
    if ((int64_t)ua < 0) ua = 0x8000000000000000ULL - ua;
    if ((int64_t)ub < 0) ub = 0x8000000000000000ULL - ub;
    return (long long)(ua>ub? ua-ub : ub-ua);
}
int main(void){
    double s=0; for(int i=0;i<10;++i) s+=0.1;
    double t=10*0.1;
    printf("s=%.17g t=%.17g ulp=%lld\n", s, t, ulp_dist(s,t));
}
```

### A.2 서브노멀 감지

```c
#include <math.h>
#include <stdio.h>
int main(void){
    double x = ldexp(1.0, -1075); // double 최소 서브노멀 근방
    if (fpclassify(x) == FP_SUBNORMAL) puts("subnormal");
}
```

### A.3 FTZ/DAZ 정책(플랫폼 의존, 예: x86 SSE)

> 참고: 실제 제어는 컴파일러/OS별 intrinsics 필요. 생산 코드에서는 정책을 문서화하고 런타임 검증 루틴을 제공할 것.

```c
// 의사코드(개념): _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);
//                 _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
```

---

## 부록 B) 수식 리마인더

- 머신 엡실론:
$$
\varepsilon_{\mathrm{float}} = 2^{-23},\quad \varepsilon_{\mathrm{double}} = 2^{-52}
$$

- Horner:
$$
a_0 + a_1 x + \cdots + a_n x^n
= a_0 + x(a_1 + x(\cdots + x a_n))
$$

- 안정 변형(예):
$$
\sqrt{a}-\sqrt{b} = \frac{a-b}{\sqrt{a}+\sqrt{b}}
$$

---

## 참고 링크를 대신하는 키워드(검색 가이드)
- “IEEE 754 2008/2019”, “machine epsilon”, “ULP comparison”, “Kahan summation”, “Welford variance”, “pairwise summation reproducibility”, “fenv.h rounding exceptions”, “flush-to-zero denormals”, “-ffast-math pitfalls”, “fma accuracy”.