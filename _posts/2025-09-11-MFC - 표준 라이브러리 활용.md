---
layout: post
title: MFC - 표준 라이브러리 활용
date: 2025-09-11 19:25:23 +0900
category: MFC
---
# 표준 라이브러리(컨테이너 / 파일시스템 / 스레드) 활용 전략 — C++17/20/23 실전 총정리

**대상**: 네이티브 앱(Win32/MFC 포함), 서버·도구·라이브러리  
**목표**:  
- 올바른 **컨테이너 선택/튜닝**으로 성능·가독성·안정성 균형 잡기  
- `std::filesystem`로 **경로/파일 I/O/원자적 저장/권한**을 이식성 있게 다루기  
- `std::thread / std::jthread / stop_token / condition_variable / barrier`로 **안전한 동시성** 구현  
- `ranges / string_view / span / optional / expected`와 **알고리즘**을 조합해 “루프를 코드에서 지우는” 습관 만들기

---

## 0) 대원칙: “표준으로 충분하게, 필요한 만큼만”

1) **컨테이너 기본값은 `std::vector`** — 캐시 친화·단순·강력.  
2) **파일은 `std::filesystem`** — 경로/권한/원자적 교체/임시파일.  
3) **스레드는 `std::jthread + stop_token`** — 취소/정리의 표준.  
4) **알고리즘 + ranges** — for-루프를 줄이고 예외 안전을 얻자.  
5) **뷰 타입(string_view/span)** — 소유와 관찰을 분리하자(수명 주의).

---

## 1) 컨테이너 전략 — 선택·튜닝·패턴

### 1-1. 컨테이너 선택 표

| 요구 | 추천 | 비고 |
|---|---|---|
| 대부분 | `std::vector<T>` | 연속 메모리, 캐시 히트, 소량/대량 모두 우수 |
| 큐(앞/뒤) | `std::deque<T>` | 대량 push_front/back, 중간 삽입 거의 없음 |
| 정렬+범위 탐색 | `std::map<K,V>` | 레드-블랙 트리, O(logN) |
| 해시 조회 | `std::unordered_map<K,V>` | 평균 O(1), 키가 해시 가능한 경우 |
| 고정 크기 | `std::array<T,N>` | 스택/구조체 멤버 최적 |
| “평평한 맵” | `vector<pair<K,V>>` + 정렬 | 적은 N/일괄 빌드+다회 조회 |

> **안티패턴**: `std::list`는 대부분 필요 없다. 캐시 비우호·알로케이션 비용↑. “이터레이터 안정성”같은 특수한 이유 있을 때만.

---

### 1-2. `vector`를 빠르게 쓰는 7가지

```cpp
std::vector<Item> v;
v.reserve(10'000);                               // (1) 재할당 최소화
std::sort(v.begin(), v.end(), cmp);              // (2) 정렬/이진탐색
auto it = std::lower_bound(v.begin(), v.end(), key, cmp);
v.erase(std::remove_if(v.begin(), v.end(), pred), v.end()); // (3) erase-remove
v.shrink_to_fit();                               // (4) 메모리 회수(옵션)
v.emplace_back(args...);                         // (5) in-place 생성
v.insert(v.end(), std::make_move_iterator(a.begin()),
                  std::make_move_iterator(a.end()));        // (6) 대량 move
if (v.capacity() < need) v.reserve(need);        // (7) API 전 capacity 관리
```

- 값 타입 `T`는 **이동(noexcept)** 지원을 권장. 컨테이너 재배치 시 큰 이득.

```cpp
struct Blob {
  std::vector<std::byte> buf;
  Blob(Blob&&) noexcept = default;         // 이동이 예외 없음
  Blob& operator=(Blob&&) noexcept = default;
  Blob(const Blob&) = delete;              // 복사 금지(선택)
};
```

---

### 1-3. `unordered_map` 튜닝

```cpp
std::unordered_map<std::string, User> m;
m.reserve(4096);                        // 초기 버킷 수
m.max_load_factor(0.7f);                // 리해시(확장) 임계
auto [it, inserted] = m.emplace(k, v);  // 중복 방지
if (!inserted) it->second = merge(it->second, v);
```

- **키는 소유? 관찰?** — 긴 문자열 키면 `string_view` + 별도 소유 저장을 고려(수명 주의).

---

### 1-4. “평평한 맵(flat-map)” — 작을 때 더 빠르다

```cpp
// K가 작은 집합, 빌드 후 조회 다회
std::vector<std::pair<std::string, int>> fm;
std::sort(fm.begin(), fm.end(), [](auto& a, auto& b){ return a.first < b.first; });

int* Find(const std::string& k) {
  auto it = std::lower_bound(fm.begin(), fm.end(), k,
     [](auto& a, const std::string& kk){ return a.first < kk; });
  return (it != fm.end() && it->first == k) ? &it->second : nullptr;
}
```

- 추가/삭제가 드물고 조회가 잦을 때 뛰어난 캐시 효율.

---

### 1-5. 뷰 타입: `string_view / span`

```cpp
void Parse(std::string_view s);        // 소유 X, 복사비용 0
void Fill(std::span<std::byte> out);   // 연속 메모리 뷰

std::string str = "hello";
Parse(str);                            // OK
Parse(str.substr(0,3));                // OK (C++20 string_view 변환)
```

> **주의**: 뷰는 **원본 수명에 종속**. 컨테이너 재할당/소멸 후 사용 금지.

---

### 1-6. `optional / expected`로 오류와 값 분리

```cpp
#include <optional>
std::optional<User> LoadUser(Id id);

#include <expected> // C++23
std::expected<User, Error> LoadUserEx(Id id);

auto u = LoadUserEx(id);
if (!u) { Log(u.error()); return; }
Use(*u);
```

- 예외 대신 **결과/에러를 값으로** 다루는 전략. API 명확.

---

### 1-7. ranges로 “루프 지우기”

```cpp
#include <ranges>
#include <algorithm>

auto total =
  users
  | std::views::filter([](auto& u){ return u.active; })
  | std::views::transform([](auto& u){ return u.points; })
  | std::ranges::to<std::vector<int>>()              // C++23 or range-v3
  ;

int sum = std::accumulate(total.begin(), total.end(), 0);
```

> VS/MSVC에선 `ranges::to`가 없을 수 있으니, `std::vector<int> vec(total.begin(), total.end());`로 대체.

---

## 2) 파일시스템 전략 — 경로/트래버스/원자적 저장/임시파일/권한

### 2-1. 경로·기본 작업

```cpp
namespace fs = std::filesystem;

fs::path base = fs::path(GetUserRoamingDir()) / "Vendor" / "App";
fs::create_directories(base);

fs::path config = base / "settings.json";
if (fs::exists(config) && fs::file_size(config) < 10*1024*1024) {
  std::ifstream f(config, std::ios::binary);
  std::string s((std::istreambuf_iterator<char>(f)), {});
}
```

- 경로 결합은 `/` 연산자. 구분자 자동 처리.

---

### 2-2. 안전 저장(원자적 교체 패턴)

```cpp
bool AtomicWrite(const fs::path& dst, std::string_view data) {
  fs::path tmp = dst; tmp += ".tmp";
  {
    std::ofstream o(tmp, std::ios::binary);
    if (!o) return false;
    o.write(data.data(), (std::streamsize)data.size());
  }
  std::error_code ec;
  fs::rename(tmp, dst, ec);         // 같은 볼륨이면 거의 원자적
  if (ec) { fs::remove(tmp, ec); return false; }
  return true;
}
```

- **전원 차단/크래시**에도 파일 손상 최소화.  
- 실패 시 tmp 제거(에러 코드는 무시해도 안전).

---

### 2-3. 임시 파일/디렉터리

```cpp
fs::path TempDir() {
  auto t = fs::temp_directory_path() / fs::path("app-") += std::to_string(::GetCurrentProcessId());
  fs::create_directories(t);
  return t;
}

fs::path UniqueTemp(const fs::path& dir, std::string_view stem, std::string_view ext) {
  for (int i=0; i<1000; ++i) {
    fs::path p = dir / (std::string(stem) + "-" + std::to_string(i) + std::string(ext));
    std::error_code ec; fs::file_status st = fs::status(p, ec);
    if (!fs::exists(st)) return p;
  }
  throw std::runtime_error("cannot allocate temp name");
}
```

- 윈도우/리눅스 공통으로 잘 동작.  
- **스코프 종료 시 정리**: RAII 클래스로 임시 폴더 삭제를 묶어도 좋다.

---

### 2-4. 디렉터리 순회·필터

```cpp
for (auto& e : fs::recursive_directory_iterator(root, fs::directory_options::skip_permission_denied)) {
  if (!e.is_regular_file()) continue;
  if (e.path().extension() == ".png") {
    // ...
  }
}
```

- 권한 오류는 `skip_permission_denied`로 무시.

---

### 2-5. 심볼릭 링크/정규화/동일 파일 확인

```cpp
fs::path p = fs::weakly_canonical(path);   // 최대한 정규화
bool same = fs::equivalent(p, another, ec); // 같은 파일인지(하드링크 등)
```

---

### 2-6. 권한(플랫폼 주의)

- Windows는 ACL, `std::filesystem::permissions`의 의미가 제한적.  
- **실무**: 파일 생성 시 기본 ACL 그대로 두고, 필요한 경우 OS 별 API로 처리.

---

## 3) 스레드/동시성 — `jthread`, 취소, 큐, 동기화

### 3-1. `std::jthread + stop_token` — 취소 가능한 스레드

```cpp
class Worker {
  std::jthread th_;
public:
  void start() {
    th_ = std::jthread([this](std::stop_token st){
      while (!st.stop_requested()) {
        Task t;
        if (!pop(t, st)) break;
        process(t);
      }
    });
  }
  void stop() { th_.request_stop(); }  // 소멸 시 자동 join
private:
  struct Task { int id; };

  // 취소 가능한 대기
  std::mutex mx_; std::condition_variable_any cv_;
  std::deque<Task> q_;
  bool pop(Task& out, std::stop_token st) {
    std::unique_lock lk(mx_);
    cv_.wait(lk, st, [&]{ return !q_.empty(); });
    if (st.stop_requested()) return false;
    out = std::move(q_.front()); q_.pop_front();
    return true;
  }
public:
  void push(Task t) { { std::scoped_lock lk(mx_); q_.push_back(std::move(t)); } cv_.notify_one(); }
};
```

- **항상** 종료 경로를 고려: `request_stop()` → 대기 해제 → 루프 종료.

---

### 3-2. 생산자–소비자(멀티 생산자/소비자)

```cpp
struct MPMC {
  std::mutex mx; std::condition_variable cv;
  std::queue<Job> q; bool done=false;

  void push(Job j) { { std::lock_guard lk(mx); q.push(std::move(j)); } cv.notify_one(); }
  bool pop(Job& out) {
    std::unique_lock lk(mx);
    cv.wait(lk, [&]{ return done || !q.empty(); });
    if (q.empty()) return false;
    out = std::move(q.front()); q.pop();
    return true;
  }
  void close() { std::lock_guard lk(mx); done=true; cv.notify_all(); }
};
```

- **종료 시그널**(done)을 꼭 제공.  
- GUI 스레드엔 블로킹 금지 → 워커에서 결과를 `PostMessage` 등으로 전달.

---

### 3-3. `std::barrier / latch` (단계 동기화)

```cpp
std::barrier sync(4, []{ /* phase completion hook */ });

void stage_worker() {
  // stage 1
  sync.arrive_and_wait();  // 4개 스레드 모두 왔을 때 진입
  // stage 2
  sync.arrive_and_wait();
}
```

---

### 3-4. 타임아웃/백오프/재시도

```cpp
auto ok = cv_.wait_for(lk, 200ms, [&]{ return !q_.empty(); });
if (!ok) {
  // 타임아웃: 지수 백오프 or 상태 보고
}
```

- **네트워크/디스크**: `std::chrono` 단위를 명시적으로.

---

### 3-5. `std::async` 주의

- 구현에 따라 **스레드 풀 보장 없음**, 지연 실행/동기 실행일 수 있음.  
- 지속 워커가 필요한 경우 **직접 thread/queue**가 명확.

---

### 3-6. Lock & 교착방지

```cpp
std::mutex a, b;
void swap_safe() {
  std::scoped_lock lk(a, b);   // 교착 방지
  // ...
}
```

- 여러 락을 잡을 땐 **`scoped_lock`** 또는 **락 순서 규칙** 문서화.

---

## 4) 시간/타이머/스케줄링

### 4-1. 경과 시간 측정

```cpp
auto t0 = std::chrono::steady_clock::now();
// work ...
auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now()-t0).count();
```

- UI에 표시할 때는 `system_clock` 포맷, 성능 측정엔 **steady_clock**.

---

### 4-2. 주기 작업(워커 스레드 내부 타이머)

```cpp
std::jthread th([&](std::stop_token st){
  using namespace std::chrono;
  auto next = steady_clock::now();
  while (!st.stop_requested()) {
    next += 1s;
    do_heartbeat();
    std::this_thread::sleep_until(next);
  }
});
```

---

## 5) 알고리즘/범위 — 성능 + 가독성

### 5-1. accumulate/transform/partition

```cpp
int sum = std::accumulate(v.begin(), v.end(), 0, [](int s, const Item& x){
  return s + (x.active ? x.value : 0);
});

std::transform(v.begin(), v.end(), out.begin(), [](auto& x){ return x.value * 2; });

auto mid = std::partition(v.begin(), v.end(), [](auto& x){ return x.active; });
// [begin, mid) 활성 / [mid, end) 비활성
```

### 5-2. ranges: filter + transform + to

```cpp
auto names =
  v | std::views::filter([](auto& x){ return x.active; })
    | std::views::transform([](auto& x){ return x.name; });

std::vector<std::string> out(names.begin(), names.end());
```

---

## 6) 직렬화/텍스트/이진 I/O (표준 스트림)

```cpp
// 이진 쓰기
std::ofstream o(path, std::ios::binary);
o.write(reinterpret_cast<const char*>(buf.data()), (std::streamsize)buf.size());

// 라인 텍스트 읽기
std::ifstream f(path);
for (std::string line; std::getline(f, line); ) {
  // ...
}
```

- 대용량은 고정 버퍼 read 루프로 전환.  
- “원자적 저장”은 **tmp → rename**(2-2절).

---

## 7) 로깅/측정: RAII 타이머, 스코프 카운터

```cpp
struct ScopeTimer {
  const char* tag;
  std::chrono::steady_clock::time_point t0 = std::chrono::steady_clock::now();
  ~ScopeTimer() {
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now()-t0).count();
    fprintf(stderr, "[%s] %lld ms\n", tag, (long long)ms);
  }
};

void foo() { ScopeTimer t{"foo"}; /* ... */ } // 스코프 종료에 자동 출력
```

---

## 8) 패턴 모음 — 현장에서 바로 쓰는 조합

### 8-1. “스캔 → 큐 → 워커 → UI”

```cpp
struct Job { std::filesystem::path p; };
MPMC q;

std::jthread scan([&](std::stop_token st){
  for (auto& e : fs::recursive_directory_iterator(root)) {
    if (st.stop_requested()) break;
    if (e.is_regular_file()) q.push(Job{e.path()});
  }
  q.close();
});

std::jthread worker([&](std::stop_token st){
  Job j;
  while (q.pop(j)) {
    auto meta = ReadMeta(j.p);         // I/O
    PostToUI(meta);                    // 메시지/락 최소화
  }
});
```

- 스캔과 처리 분리, 큐로 decouple.  
- 종료는 `stop_token` + `q.close()`.

---

### 8-2. 캐시 with `weak_ptr`

```cpp
struct Image { /* ... */ };
std::mutex mx;
std::unordered_map<std::string, std::weak_ptr<Image>> cache;

std::shared_ptr<Image> GetImage(const std::string& key) {
  if (auto it = cache.find(key); it != cache.end())
    if (auto sp = it->second.lock()) return sp;

  auto sp = std::make_shared<Image>(Load(key));
  { std::scoped_lock lk(mx); cache[key] = sp; }
  return sp;
}
```

- **수명 자동 청소**: 마지막 참조가 사라지면 캐시도 비워짐.

---

### 8-3. 구성 교체(강한 예외 보장)

```cpp
Config Load(const fs::path& p);
void Replace(Config& dst, const fs::path& p) {
  Config next = Load(p);   // 실패하면 예외 → dst는 안전
  dst.swap(next);
}
```

---

## 9) 체크리스트 — 실무 품질을 위한 20가지

- [ ] 컨테이너는 **vector 기본**, 필요시 map/unordered_map  
- [ ] `reserve` / `erase-remove` / `emplace_back`  
- [ ] 키/값 소유 vs 관찰 구분(`string` vs `string_view`)  
- [ ] `filesystem`로 경로 결합/존재/크기/순회  
- [ ] **원자적 저장**(tmp→rename) 필수  
- [ ] 임시 폴더/파일은 RAII 정리  
- [ ] 순회는 `recursive_directory_iterator` + 옵션  
- [ ] 스레드는 **`jthread + stop_token`**  
- [ ] 생산자–소비자: 큐 + 조건변수 + 종료 시그널  
- [ ] 다중 락은 `scoped_lock`  
- [ ] 타임아웃·백오프 설계  
- [ ] `async` 남용 금지(전용 워커/풀)  
- [ ] steady_clock로 성능 측정  
- [ ] ranges/알고리즘으로 루프 치환  
- [ ] optional/expected로 오류 값을 모델링  
- [ ] 이동 `noexcept` 제공  
- [ ] I/O는 고정버퍼/스트리밍 전략  
- [ ] 로그/측정 RAII 스코프 타이머  
- [ ] UI 스레드 블로킹 금지(메시지로 결과 전달)

---

## 10) 부록: 실전 유틸(복붙용)

### 10-1. 원자적 파일 쓰기

```cpp
inline bool write_atomic(const std::filesystem::path& dst, std::string_view bytes) {
  namespace fs = std::filesystem;
  fs::path tmp = dst; tmp += ".tmp";
  {
    std::ofstream o(tmp, std::ios::binary);
    if (!o) return false;
    o.write(bytes.data(), (std::streamsize)bytes.size());
  }
  std::error_code ec; fs::rename(tmp, dst, ec);
  if (ec) { fs::remove(tmp, ec); return false; }
  return true;
}
```

### 10-2. 스코프 타이머

```cpp
struct scope_timer {
  const char* tag; std::chrono::steady_clock::time_point t0 = std::chrono::steady_clock::now();
  ~scope_timer(){ auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now()-t0).count();
                  fprintf(stderr,"[%s] %lld ms\n", tag,(long long)ms); }
};
```

### 10-3. 취소 가능한 sleep

```cpp
inline bool sleep_until(std::stop_token st, std::chrono::steady_clock::time_point tp) {
  while (!st.stop_requested()) {
    auto now = std::chrono::steady_clock::now();
    if (now >= tp) return true;
    auto dt = std::min(tp - now, std::chrono::milliseconds(50));
    std::this_thread::sleep_for(dt);
  }
  return false;
}
```

---

### 마무리

표준 라이브러리를 “제대로” 쓰면 **의존성 없이도** 대다수 문제를 깔끔하게 풀 수 있습니다.  
- 컨테이너는 **데이터 모델**을,  
- 파일시스템은 **안전한 I/O**를,  
- 스레드는 **정리 가능한 동시성**을 제공합니다.