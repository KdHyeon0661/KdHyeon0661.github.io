---
layout: post
title: JavaScript - 클로저와 렉시컬 환경
date: 2025-05-04 19:20:23 +0900
category: JavaScript
---
# 클로저(Closure)와 렉시컬 환경(Lexical Environment

## 렉시컬 환경(Lexical Environment)

### 정의와 구성요소

- **렉시컬 스코프**: *코드가 작성된 위치*에 의해 유효 범위가 결정.
- **Lexical Environment(LE)**: `Environment Record(변수 바인딩 테이블) + Outer(상위 LE 참조)`의 쌍.
- **Environment Record** 종류
  - *Declarative Record*: `let/const/class/함수 매개변수/함수 선언` 등
  - *Object Record*: `with`/전역 객체 바인딩 등
- **스코프 체인**: 현재 LE → Outer → … → (전역) → `null`로 이어지는 탐색 링크.

```js
function outer() {
  const x = 10;            // outer의 Declarative Record에 저장
  function inner() {       // inner는 [[Environment]]로 outer의 LE를 캡처
    console.log(x);
  }
  inner();
}
outer(); // 10
```

**탐색 규칙**: 식별자 해석 시, 현재 LE에서 찾고 없으면 **Outer**로 거슬러 올라갑니다.

---

### 실행 컨텍스트와 LE 스냅샷

- **실행 컨텍스트(EC)**: 함수/모듈/스크립트가 실행될 때 생성되는 “실행 프레임”.
- EC는 생성 시 **LexicalEnvironment**/ **VariableEnvironment**를 갖고, 함수는 자신이 선언된 순간의 **Outer(상위 LE 참조)**를 함수의 내부 슬롯 `[[Environment]]`로 **저장**합니다.
  → 이 저장된 참조가 **클로저의 토대**가 됩니다.

---

### TDZ(Temporal Dead Zone)와 let/const

`let/const` 바인딩은 **선언 이전 접근 시 TDZ 에러**가 납니다. 클로저 캡처 시에도 TDZ 규칙이 그대로 적용됩니다.

```js
function f() {
  console.log(x); // ReferenceError (TDZ)
  let x = 1;
}
```

---

## 클로저(Closure)

### 정의(정확 버전)

> **클로저**는 함수가 생성될 당시의 **$$[[Environment]]$$(상위 렉시컬 환경 참조)**를 **함수 객체 내부에 저장**하고, 그 결과 **함수 실행 시점에 상위 스코프의 바인딩에 접근할 수 있는 현상/구조**입니다.

```js
function makeCounter() {
  let count = 0;                 // 캡처 대상
  return function () {           // 클로저
    count += 1;                  // 외부(상위) 스코프 변수 접근
    return count;
  };
}
const inc = makeCounter();
console.log(inc()); // 1
console.log(inc()); // 2
```

- `inc`는 `count`가 사라진 뒤에도 접근합니다(외부 `makeCounter` 종료 후에도 **LE가 살아있음**).

---

### 값 vs 참조: 캡처의 본질

- 자바스크립트 엔진은 **식별자 바인딩**(환경 레코드의 셀)을 참조로 연결합니다.
- 즉, “값 복사”가 아니라 **바인딩에 대한 참조**를 기억합니다.
- 그래서 외부 변수가 **변경되면 클로저도 그 변경을 보게** 됩니다.

```js
function box() {
  let v = 0;
  return {
    get: () => v,
    set: (x) => (v = x),
  };
}
const b = box();
console.log(b.get()); // 0
b.set(7);
console.log(b.get()); // 7   ← 같은 바인딩에 접근
```

---

## 실전 패턴: 클로저로 만드는 유용한 구조

### 프라이빗 상태(캡슐화)

```js
function createCounter(init = 0) {
  let n = init;
  return {
    inc: () => ++n,
    dec: () => --n,
    value: () => n,
  };
}
const c = createCounter(10);
c.inc(); c.inc();
console.log(c.value()); // 12  (n은 외부에서 직접 접근 불가)
```

---

### 팩토리 + 정책 주입(전략 패턴 흉내)

```js
function createLimiter(limit, policy = (n) => n + 1) {
  let n = 0;
  return () => {
    if (n >= limit) return n;
    n = policy(n);
    return n;
  };
}
const lim = createLimiter(3);
console.log(lim(), lim(), lim(), lim()); // 1 2 3 3
```

---

### 캐싱/메모이제이션

```js
function memoize(fn) {
  const cache = new Map();  // 클로저 상태
  return (key) => {
    if (cache.has(key)) return cache.get(key);
    const val = fn(key);
    cache.set(key, val);
    return val;
  };
}
const slowSquare = (x) => { for (let i=0;i<1e7;i++); return x*x; };
const fastSquare = memoize(slowSquare);
console.time("1"); console.log(fastSquare(12)); console.timeEnd("1"); // 느림
console.time("2"); console.log(fastSquare(12)); console.timeEnd("2"); // 빠름(캐시)
```

---

### 함수 데코레이터

```js
function withLog(fn) {
  return (...args) => {
    console.log("call:", fn.name, args);
    const r = fn(...args);
    console.log("ret :", r);
    return r;
  };
}
const sum = (a,b)=>a+b;
const loggedSum = withLog(sum);
loggedSum(3,4);
```

---

### 커링/부분 적용

```js
const add = (a) => (b) => a + b;      // a를 캡처
console.log(add(2)(5));               // 7

function partial(fn, ...head) {
  return (...tail) => fn(...head, ...tail);
}
const add3 = (a,b,c)=>a+b+c;
const add1_2 = partial(add3, 1, 2);
console.log(add1_2(9));               // 12
```

---

## 반복문/이벤트/비동기에서의 클로저 함정과 해법

### var 반복문 + 비동기 콜백

```js
const fns = [];
for (var i=0; i<3; i++) {
  fns.push(() => console.log(i));
}
fns[0](); fns[1](); fns[2](); // 3, 3, 3  (같은 i 바인딩)
```

**해법 1 — let(블록 스코프) 사용**

```js
const fns2 = [];
for (let i=0; i<3; i++) {
  fns2.push(() => console.log(i));
}
fns2[0](); fns2[1](); fns2[2](); // 0, 1, 2
```

**해법 2 — IIFE로 바인딩 고정**

```js
const fns3 = [];
for (var i=0; i<3; i++) {
  ((j)=>fns3.push(()=>console.log(j)))(i);
}
fns3[0](); fns3[1](); fns3[2](); // 0, 1, 2
```

---

### 이벤트 핸들러에서의 누수

```js
function mount() {
  const div = document.getElementById('panel');
  const big = new Array(1e6).fill("x");    // 큰 캡처
  function onClick() { console.log(big[0]); }
  div.addEventListener('click', onClick);
  return () => div.removeEventListener('click', onClick); // 언마운트 훅
}
const unmount = mount();
// 나중에
unmount(); // 반드시 정리
```

- **핸들러가 큰 객체를 캡처**하면 DOM이 제거돼도 참조가 남을 수 있습니다.
- 언마운트 시 **리스너 해제**가 필수.

---

### setInterval/Timer 해제

```js
function start() {
  let ticks = 0;
  const id = setInterval(()=> {
    // ... 작업 ...
    if (++ticks > 100) clearInterval(id); // 반드시 종료조건/정리
  }, 100);
}
```

---

### 비동기 재시도(백오프)와 상태 캡처

```js
function retry(fn, { times=3, delay=200 } = {}) {
  return async (...args) => {
    let attempt = 0;
    while (true) {
      try { return await fn(...args); }
      catch (e) { if (++attempt >= times) throw e; }
      await new Promise(r => setTimeout(r, delay));
    }
  };
}
```

- `attempt`, `delay` 등 **상태를 클로저로 캡처**하여 로직을 간결하게 유지.

---

## 메모리/성능/디버깅

### 클로저로 인한 메모리 보존

- **원인**: 클로저가 **환경 레코드(바인딩 셀)**를 참조 → 상위 함수 종료 후에도 **해당 바인딩**은 살아있습니다.
- **대응**:
  - 더 이상 필요 없는 큰 데이터는 **참조 끊기**(`big = null`)
  - 핸들러/인터벌 **정리**
  - **WeakMap**으로 외부 메타데이터 보관(객체 수명에 따라 자동 해제)

```js
const meta = new WeakMap();
function track(obj) {
  meta.set(obj, { created: Date.now() });
}
```

---

### 성능 팁

- 클로저 자체가 느린 건 아니지만, **큰 캡처**/**과도한 중첩**은 GC·메모리 압박을 유발.
- 핫패스에서는 **필요한 최소 상태만 캡처**(특히 대형 배열/DOM/Map).
- 가능하면 **순수함수**/**불변 데이터** 조합 → 디버깅과 테스트 용이.

---

### DevTools로 추적(브라우저 기준)

1. **Memory** 탭 → *Heap snapshot* 두 번 이상 찍고 **Retainers**로 누수 체인 확인
2. **Performance** 탭 → 장시간 시나리오 기록, 메모리 선이 계속 증가하면 의심
3. **Allocation instrumentation** → 어느 코드 경로에서 객체가 살아남는지 확인
4. **Detached DOM tree**가 남아있다면, **리스너/클로저가 DOM을 붙잡는지** 점검

---

## this/모듈/GC와의 관계

### 클로저 vs this

- **클로저**: 변수 **스코프**(렉시컬) 기반
- **this**: **호출 방식** 기반(런타임 바인딩), 화살표 함수는 **상위 this를 캡처**
- 서로 **독립 개념**이지만 동시에 등장 가능

```js
function outer() {
  const name = "JS";
  return {
    getName: () => name, // 클로저
    whoAmI() { return this; } // 호출 주체
  };
}
```

---

### 모듈 스코프와 클로저

ES 모듈 파일은 자체 스코프를 가지므로, **모듈 레벨 상수/상태** 또한 다른 모듈에 의해 (import된 함수가) 클로저처럼 참조됩니다. **모듈은 한 번만 평가**되므로, 간단한 싱글톤/캐시로 활용 가능합니다.

```js
// store.js (ESM)
let id = 0;
export const nextId = () => ++id;   // 모듈 스코프 상태를 캡처
```

---

### 가비지 컬렉션(GC)

- 클로저가 특정 바인딩을 참조하는 동안, 그 바인딩은 **도달 가능**하므로 GC 대상이 아닙니다.
- **모든** 클로저 참조가 끊기면, 해당 바인딩은 수거됩니다.
- 외부에서 클로저를 저장해두면(예: 전역/싱글톤), 그 바인딩은 오래 살아남을 수 있으므로 주의.

---

## 고급 주제: 안전한 캡처와 패턴

### 캡처 최소화 & 안전한 해제

```js
function makeHandler(resource) {
  // 큰 자원 직접 캡처 대신 필요한 키/값만 분해
  const { id } = resource;
  return () => { /* id만 사용 */ };
}
// 더 이상 필요 없을 때 참조 해제
resource = null;
```

---

### 커스텀 훅 스타일(프런트엔드)

```js
function createToggle(initial=false) {
  let on = initial;
  const listeners = new Set();
  return {
    get: () => on,
    set: (v) => { on = v; listeners.forEach(fn => fn(on)); },
    subscribe: (fn) => (listeners.add(fn), () => listeners.delete(fn)),
  };
}
const toggle = createToggle();
const unsub = toggle.subscribe(v => console.log("changed:", v));
toggle.set(true);  // changed: true
unsub();           // 구독 해제(누수 방지)
```

---

### 디바운스/스로틀

```js
function debounce(fn, ms=200) {
  let id = null;
  return (...args) => {
    clearTimeout(id);
    id = setTimeout(()=>fn(...args), ms);
  };
}
```

- `id`는 디바운서 클로저가 가진 **프라이빗 상태**.

---

## 테스트 가능한 클로저 설계

- **입력/출력** 경계 명확히(의존성 주입)
- **가짜 타이머**(`jest.useFakeTimers()`)로 타이밍 제어
- 클로저 내부 상태는 **간접 인터페이스**(getter/setter/메서드)로만 접근

---

## 자주 하는 실수와 대처

### “값 복사” 오해

- 캡처는 **바인딩 참조**입니다. 외부 값 변경이 **반영**됩니다.

### 거대한 객체 캡처

- 필요한 **프로퍼티만 분해**해 캡처하세요.

### var + 비동기

- `let`/IIFE로 바인딩을 고정해 주세요.

### 이벤트/인터벌 해제 누락

- 컴포넌트 언마운트/페이지 이동에서 **반드시 정리**하세요.

---

## 실전 예제 모음

### 요청 합치기(batch) — N회/ΔT 내 호출 묶기

```js
function createBatcher(send, { windowMs=50 } = {}) {
  let q = [];
  let id = null;
  function flush() {
    const items = q; q = []; id = null;
    if (items.length) send(items);
  }
  return (item) => {
    q.push(item);
    if (id == null) id = setTimeout(flush, windowMs);
  };
}

// 사용
const postBatch = (items) => fetch('/api', {
  method: 'POST', body: JSON.stringify(items),
});
const enqueue = createBatcher(postBatch, { windowMs: 30 });
enqueue({ id: 1 }); enqueue({ id: 2 }); // 30ms 내 묶여서 1회 요청
```

---

### 접근 제어(토큰 자동 갱신)

```js
function createTokenClient(fetchToken, refreshToken) {
  let token = null;
  let refreshing = null;
  return {
    async get() {
      if (token) return token;
      token = await fetchToken();
      return token;
    },
    async withRefresh(fn) {
      try { return await fn(await this.get()); }
      catch (e) {
        if (!refreshing) refreshing = refreshToken().then(t => (token = t)).finally(()=>refreshing=null);
        await refreshing;
        return fn(await this.get());
      }
    }
  };
}
```

- `token`, `refreshing`이 **클로저 상태**로 관리되어 재진입/경쟁 상태를 제어.

---

### LRU 캐시(간단판)

```js
function createLRU(limit=100) {
  const map = new Map();
  return {
    get(k) {
      if (!map.has(k)) return;
      const v = map.get(k);
      map.delete(k); map.set(k, v);
      return v;
    },
    set(k, v) {
      if (map.has(k)) map.delete(k);
      map.set(k, v);
      if (map.size > limit) map.delete(map.keys().next().value);
    },
    size: () => map.size
  };
}
```

- `map`도 **클로저 은닉 상태**.

---

## 체크리스트

- [ ] 캡처 범위가 **최소**인가? (큰 객체/DOM 통째로 캡처 금지)
- [ ] **리스너/타이머**는 언마운트/종료 시 **해제**하는가?
- [ ] 반복문 비동기에는 **let/IIFE**를 썼는가?
- [ ] 모듈/싱글톤이 **무한히 상태 누적**하지 않는가?
- [ ] DevTools로 **Retainers/Detached DOM**를 확인했는가?

---

## 미니 퀴즈

```js
// Q1: 아래 출력은?
function a() {
  let x = 1;
  return () => console.log(++x);
}
const f = a();
f(); f();                 // ?

// Q2: var 반복문 해결책 2가지는?
// (힌트: 블록 스코프, IIFE)

// Q3: 아래 코드의 문제는?
function mount() {
  const div = document.getElementById('p');
  const big = new Array(1e6).fill(0);
  div.addEventListener('click', () => console.log(big.length));
}
// (힌트: 언마운트 시 big/리스너)

// Q4: 클로저와 this 차이는 한 줄로?
// (힌트: 스코프 vs 호출 주체)

// Q5: 모듈 스코프 상태를 캡처하는 예 하나 작성.
```

**정답 힌트**
- Q1: `2`, `3` (바인딩 참조)
- Q2: `let` 사용, IIFE로 j 캡처
- Q3: 리스너 해제 누락으로 big 참조 유지 → 누수
- Q4: 클로저=렉시컬 스코프 바인딩, this=호출 시점 바인딩
- Q5: 모듈 파일 상단의 `let` 상태를 export 함수가 참조

---

## 결론

- **렉시컬 환경**은 “선언 위치”에 기초한 스코프 체인으로, **클로저**는 그 환경을 **함수 내부 슬롯에 보존**함으로써 외부 변수에 지속 접근합니다.
- 프라이빗 상태, 캐시, 디바운스/스로틀, 재시도/배치 등 **실전 패턴의 핵심 도구**입니다.
- 하지만 **큰 데이터/DOM 캡처**, **해제 누락**은 **누수와 성능 저하**를 부릅니다. 캡처를 최소화하고, 생명주기 이벤트에서 **정리**를 철저히 하세요.
