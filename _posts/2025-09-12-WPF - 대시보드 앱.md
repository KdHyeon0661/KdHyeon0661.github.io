---
layout: post
title: WPF - 대시보드 앱
date: 2025-09-12 18:25:23 +0900
category: WPF
---
# 📊 WPF **대시보드 앱** (MVVM + OxyPlot) 완전 가이드
*(프로젝트 구조 → NuGet/설정 → 기본 차트(Line/Bar/Pie) → 라이브 업데이트(실시간) → 복수 축/혼합 시리즈 → 툴팁/줌/팬/선택 → 주석/알람 → 데이터 소스(파일/REST) → 성능 최적화 → 다크 테마 → 내보내기(PNG/PDF/SVG) → 테스트/배포까지 “누락 없이”)*

> 대상: **.NET 6~8 WPF**.  
> 차트 엔진: **OxyPlot** (`OxyPlot.Core`, `OxyPlot.Wpf`).  
> 패턴: **MVVM** (CommunityToolkit.Mvvm).  
> 글 끝까지 따라 하면 “프로급” 대시보드가 완성됩니다.

---

## 0) 완성 화면 개요

- 좌측 상단: **KPI 카드**(오늘 매출, 전일 대비 %, 주문 수, 오류 수)  
- 중앙: **시간 시계열(Line/Area)** — 당일/전일 매출 비교, 마우스 트래커(툴팁)  
- 우측: **범주 별 매출(Bar)** + **제품 Top N(Pie/Donut)**  
- 하단: **실시간 지표**(CPU/요청/sec) — 1초 간격 업데이트, 스크롤 없는 부드러운 애니메이션  
- 인터랙션: 범례 토글, 줌/팬, 클릭 시 상세 영역 드릴다운(Annotation)

---

## 1) 새 프로젝트 & 패키지

```bash
dotnet new wpf -n Dashboard.App
cd Dashboard.App
dotnet add package CommunityToolkit.Mvvm
dotnet add package OxyPlot.Core
dotnet add package OxyPlot.Wpf
dotnet add package Microsoft.Extensions.Hosting
dotnet add package Microsoft.Extensions.DependencyInjection
```

`csproj` 기본:
```xml
<Project Sdk="Microsoft.NET.Sdk.WindowsDesktop">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <UseWPF>true</UseWPF>
  </PropertyGroup>
</Project>
```

---

## 2) 솔루션 구조(간단)

```
Dashboard.App/
  Views/ MainWindow.xaml
  ViewModels/ MainViewModel.cs, CardsViewModel.cs, SalesChartViewModel.cs ...
  Models/ Kpi.cs, SalesPoint.cs, CategorySales.cs ...
  Services/ IDataService.cs, MockDataService.cs, LiveTicker.cs
  Themes/ Colors.xaml, OxyTheme.cs
  Utils/ Debounce.cs, ObservableRangeCollection.cs
  App.xaml, App.xaml.cs
```

---

## 3) 모델 & 가짜 데이터 서비스

### 3.1 모델
```csharp
// Models/Kpi.cs
public sealed record Kpi(string Name, double Value, string Unit, double DeltaPercent);

// Models/SalesPoint.cs
public sealed record SalesPoint(DateTime Time, double Amount);

// Models/CategorySales.cs
public sealed record CategorySales(string Category, double Amount);

// Models/ProductShare.cs
public sealed record ProductShare(string Product, double Share);
```

### 3.2 데이터 서비스 인터페이스
```csharp
// Services/IDataService.cs
public interface IDataService
{
    Task<IReadOnlyList<Kpi>> GetKpisAsync(DateTime date, CancellationToken ct = default);
    Task<IReadOnlyList<SalesPoint>> GetSalesSeriesAsync(DateTime date, CancellationToken ct = default);
    Task<IReadOnlyList<CategorySales>> GetCategorySalesAsync(DateTime date, CancellationToken ct = default);
    Task<IReadOnlyList<ProductShare>> GetTopProductsAsync(DateTime date, int topN, CancellationToken ct = default);

    // 실시간: 초당 요청 수 같은 메트릭
    IAsyncEnumerable<(DateTime t, double value)> SubscribeRealtimeAsync(string metric, CancellationToken ct = default);
}
```

### 3.3 목(Mock) 서비스
```csharp
// Services/MockDataService.cs
public sealed class MockDataService : IDataService
{
    private static readonly string[] Cats = ["Food", "Electronics", "Books", "Clothes", "Beauty", "Sports"];
    private static readonly string[] Products = Enumerable.Range(1, 12).Select(i => $"P{i:00}").ToArray();
    private readonly Random _rand = new(1234);

    public Task<IReadOnlyList<Kpi>> GetKpisAsync(DateTime date, CancellationToken ct = default)
    {
        var kpis = new[]
        {
            new Kpi("매출", Next(80_000, 120_000), "₩", Next(-5, 12)),
            new Kpi("주문", Next(900, 1500), "건", Next(-8, 10)),
            new Kpi("고객", Next(600, 1000), "명", Next(-6, 9)),
            new Kpi("환불", Next(10, 40), "건", Next(-3, 6))
        };
        return Task.FromResult<IReadOnlyList<Kpi>>(kpis);
    }

    public Task<IReadOnlyList<SalesPoint>> GetSalesSeriesAsync(DateTime date, CancellationToken ct = default)
    {
        var open = date.Date; // 00:00
        var list = new List<SalesPoint>(24);
        double baseVal = Next(1500, 4000);
        for (int h = 0; h < 24; h++)
        {
            var noise = Math.Sin(h * Math.PI / 12) * 1500 + _rand.Next(-300, 300);
            list.Add(new SalesPoint(open.AddHours(h), Math.Max(0, baseVal + noise)));
        }
        return Task.FromResult<IReadOnlyList<SalesPoint>>(list);
    }

    public Task<IReadOnlyList<CategorySales>> GetCategorySalesAsync(DateTime date, CancellationToken ct = default)
    {
        var list = Cats.Select(c => new CategorySales(c, Next(5000, 25000))).ToList();
        return Task.FromResult<IReadOnlyList<CategorySales>>(list);
    }

    public Task<IReadOnlyList<ProductShare>> GetTopProductsAsync(DateTime date, int topN, CancellationToken ct = default)
    {
        var samples = Products.Select(p => new ProductShare(p, Next(1, 10))).OrderByDescending(x => x.Share).Take(topN).ToList();
        var total = samples.Sum(x => x.Share);
        return Task.FromResult<IReadOnlyList<ProductShare>>(samples.Select(x => x with { Share = x.Share / total }).ToList());
    }

    public async IAsyncEnumerable<(DateTime t, double value)> SubscribeRealtimeAsync(string metric, [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct = default)
    {
        double val = 100;
        while (!ct.IsCancellationRequested)
        {
            await Task.Delay(1000, ct);
            val = Math.Clamp(val + _rand.NextDouble() * 20 - 10, 30, 200);
            yield return (DateTime.Now, val);
        }
    }

    private double Next(int a, int b) => _rand.Next(a, b);
}
```

---

## 4) MVVM 뼈대

### 4.1 App 부트스트랩
```csharp
// App.xaml.cs
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

public partial class App : Application
{
    public static IHost HostApp { get; } = Host.CreateDefaultBuilder()
        .ConfigureServices(s =>
        {
            s.AddSingleton<IDataService, MockDataService>();
            s.AddSingleton<MainViewModel>();
        })
        .Build();

    protected override async void OnStartup(StartupEventArgs e)
    {
        await HostApp.StartAsync();
        var vm = HostApp.Services.GetRequiredService<MainViewModel>();
        new MainWindow { DataContext = vm }.Show();
        base.OnStartup(e);
    }

    protected override async void OnExit(ExitEventArgs e)
    {
        await HostApp.StopAsync();
        HostApp.Dispose();
        base.OnExit(e);
    }
}
```

### 4.2 공용 컬렉션
```csharp
// Utils/ObservableRangeCollection.cs
public class ObservableRangeCollection<T> : ObservableCollection<T>
{
    public void ReplaceRange(IEnumerable<T> items)
    {
        this.Items.Clear();
        foreach (var it in items) this.Items.Add(it);
        this.OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
    }
}
```

---

## 5) 뷰모델: KPI + 차트(시계열/막대/파이) + 실시간

> OxyPlot은 MVVM에 잘 맞습니다. 핵심: **`PlotModel`을 ViewModel에서 조립**하고 XAML에서 `PlotView.Model`에 바인딩.

```csharp
// ViewModels/MainViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using OxyPlot;
using OxyPlot.Axes;
using OxyPlot.Series;

public partial class MainViewModel : ObservableObject
{
    private readonly IDataService _data;
    private readonly CancellationTokenSource _cts = new();

    // KPI
    public ObservableRangeCollection<Kpi> Kpis { get; } = new();

    // PlotModels
    [ObservableProperty] private PlotModel? salesModel;      // 시계열
    [ObservableProperty] private PlotModel? categoryModel;   // 막대
    [ObservableProperty] private PlotModel? productModel;    // 파이/도넛
    [ObservableProperty] private PlotModel? realtimeModel;   // 실시간

    public DateTime SelectedDate { get; set; } = DateTime.Today;

    public MainViewModel(IDataService data) => _data = data;

    [RelayCommand]
    public async Task LoadAsync()
    {
        await LoadKpisAsync();
        await BuildSalesChartAsync();
        await BuildCategoryChartAsync();
        await BuildProductChartAsync();
        await BuildRealtimeChartAsync(); // 구독 시작
    }

    private async Task LoadKpisAsync()
    {
        var k = await _data.GetKpisAsync(SelectedDate);
        Kpis.ReplaceRange(k);
    }

    // 5.1 시계열: 오늘 vs 전일, 트래커 + 영역 채우기
    private async Task BuildSalesChartAsync()
    {
        var today = await _data.GetSalesSeriesAsync(SelectedDate);
        var yesterday = await _data.GetSalesSeriesAsync(SelectedDate.AddDays(-1));

        var pm = new PlotModel { Title = "시간대별 매출 (오늘 vs 전일)" };
        pm.Axes.Add(new DateTimeAxis
        {
            Position = AxisPosition.Bottom,
            StringFormat = "HH:mm",
            IntervalType = DateTimeIntervalType.Hours,
            MinorIntervalType = DateTimeIntervalType.Minutes,
            Title = "시각"
        });
        pm.Axes.Add(new LinearAxis
        {
            Position = AxisPosition.Left,
            Title = "₩",
            StringFormat = "#,0"
        });

        // 전일: 점선
        var s1 = new AreaSeries
        {
            Title = "전일",
            Color = OxyColors.SkyBlue.ChangeAlpha(120),
            StrokeThickness = 2,
            LineStyle = LineStyle.Dot
        };
        foreach (var p in yesterday)
            s1.Points.Add(DateTimeAxis.CreateDataPoint(p.Time, p.Amount));

        // 오늘: 실선
        var s2 = new AreaSeries
        {
            Title = "오늘",
            Color = OxyColor.FromRgb(37, 99, 235).ChangeAlpha(100),
            StrokeThickness = 2
        };
        foreach (var p in today)
            s2.Points.Add(DateTimeAxis.CreateDataPoint(p.Time, p.Amount));

        // 트래커(툴팁)
        s2.TrackerFormatString = "시간: {2:HH:mm}\n매출: {4:#,0} ₩";
        s1.TrackerFormatString = "시간: {2:HH:mm}\n매출: {4:#,0} ₩";

        pm.Series.Add(s1);
        pm.Series.Add(s2);
        pm.IsLegendVisible = true;
        SalesModel = pm;
    }

    // 5.2 범주 막대: 데이터 레이블
    private async Task BuildCategoryChartAsync()
    {
        var cats = await _data.GetCategorySalesAsync(SelectedDate);
        var pm = new PlotModel { Title = "카테고리별 매출" };

        var catAxis = new CategoryAxis { Position = AxisPosition.Left }; // 가로형 바
        catAxis.Labels.AddRange(cats.Select(c => c.Category));
        pm.Axes.Add(catAxis);

        var valAxis = new LinearAxis
        {
            Position = AxisPosition.Bottom,
            StringFormat = "#,0",
            Title = "₩"
        };
        pm.Axes.Add(valAxis);

        var bar = new BarSeries
        {
            LabelPlacement = LabelPlacement.Outside,
            LabelFormatString = "{0:#,0}"
        };
        foreach (var c in cats)
            bar.Items.Add(new BarItem(c.Amount));

        pm.Series.Add(bar);
        CategoryModel = pm;
    }

    // 5.3 파이/도넛: Top-N
    private async Task BuildProductChartAsync()
    {
        var top = await _data.GetTopProductsAsync(SelectedDate, 6);
        var pm = new PlotModel { Title = "Top 제품 점유율" };
        var pie = new OxyPlot.Series.PieSeries
        {
            StrokeThickness = 0.5,
            AngleSpan = 360,
            StartAngle = 0,
            InsideLabelPosition = 0.7, // 도넛 효과
            InnerDiameter = 0.4
        };
        foreach (var p in top)
            pie.Slices.Add(new OxyPlot.Series.PieSlice(p.Product, p.Share) { Label = $"{p.Product} ({p.Share:P0})" });

        pm.Series.Add(pie);
        ProductModel = pm;
    }

    // 5.4 실시간: 1초 간격, 최대 포인트 제한 + 스크롤
    private async Task BuildRealtimeChartAsync()
    {
        var pm = new PlotModel { Title = "요청/초 (실시간)" };
        var x = new DateTimeAxis { Position = AxisPosition.Bottom, StringFormat = "HH:mm:ss" };
        var y = new LinearAxis { Position = AxisPosition.Left, Title = "RPS" };
        pm.Axes.Add(x); pm.Axes.Add(y);

        var line = new LineSeries { Title = "RPS", StrokeThickness = 2 };
        pm.Series.Add(line);

        RealtimeModel = pm;

        _ = Task.Run(async () =>
        {
            const int MaxPoints = 120; // 2분
            await foreach (var (t, v) in _data.SubscribeRealtimeAsync("rps", _cts.Token))
            {
                // OxyPlot은 UI 스레드 상호작용이 안전. VM에서 동기화 필요 시 Dispatcher 사용.
                Application.Current.Dispatcher.Invoke(() =>
                {
                    line.Points.Add(DateTimeAxis.CreateDataPoint(t, v));
                    if (line.Points.Count > MaxPoints) line.Points.RemoveAt(0);

                    // X축 시야를 최근으로
                    if (RealtimeModel is { } m && m.Axes[0] is DateTimeAxis dx)
                    {
                        var max = DateTimeAxis.ToDouble(t);
                        dx.Zoom(max - 0.02, max); // 최근 수 초 범위
                    }
                    RealtimeModel?.InvalidatePlot(true);
                });
            }
        });
    }
}
```

---

## 6) View (XAML): 그리드 배치 + PlotView 바인딩

`MainWindow.xaml`
```xml
<Window x:Class="Dashboard.App.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:oxy="http://oxyplot.org/wpf"
        Title="Dashboard" Width="1200" Height="800"
        Loaded="{Binding LoadCommand}">
    <Grid Margin="12" >
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="1.2*"/>
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="2*"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>

        <!-- KPI 카드 영역 -->
        <ItemsControl Grid.Row="0" Grid.ColumnSpan="2" ItemsSource="{Binding Kpis}">
            <ItemsControl.ItemsPanel>
                <ItemsPanelTemplate>
                    <UniformGrid Rows="1"/>
                </ItemsPanelTemplate>
            </ItemsControl.ItemsPanel>
            <ItemsControl.ItemTemplate>
                <DataTemplate DataType="{x:Type m:Kpi}">
                    <Border Margin="6" Padding="12" Background="#0F172A" CornerRadius="10">
                        <StackPanel>
                            <TextBlock Text="{Binding Name}" Foreground="#A3A3A3"/>
                            <TextBlock Text="{Binding Value, StringFormat={}{0:#,0}}" FontSize="28" FontWeight="SemiBold" Foreground="White"/>
                            <TextBlock Text="{Binding DeltaPercent, StringFormat={}{0:+0.0%;-0.0%}}" Foreground="#60D38B"/>
                        </StackPanel>
                    </Border>
                </DataTemplate>
            </ItemsControl.ItemTemplate>
        </ItemsControl>

        <!-- 시간 시계열 -->
        <oxy:PlotView Grid.Row="1" Grid.Column="0" Margin="6"
                      Model="{Binding SalesModel}" />

        <!-- 막대 + 파이 스택 -->
        <Grid Grid.Row="1" Grid.Column="1">
            <Grid.RowDefinitions>
                <RowDefinition Height="*"/>
                <RowDefinition Height="*"/>
            </Grid.RowDefinitions>
            <oxy:PlotView Grid.Row="0" Margin="6" Model="{Binding CategoryModel}" />
            <oxy:PlotView Grid.Row="1" Margin="6" Model="{Binding ProductModel}" />
        </Grid>

        <!-- 실시간 -->
        <oxy:PlotView Grid.Row="2" Grid.ColumnSpan="2" Margin="6"
                      Model="{Binding RealtimeModel}" />
    </Grid>
</Window>
```

> `oxy:PlotView` 바인딩은 **`PlotModel`** 참조만 있으면 MVVM으로 깔끔합니다.  
> 테마/색상/폰트는 PlotModel/Series/Axes에서 제어하거나 전체 테마 클래스로 일괄 적용 가능합니다(아래 §10).

---

## 7) 고급 주제 ① — **상호작용/트래커/줌/팬/범례/선택/드릴다운**

### 7.1 트래커(툴팁) 커스터마이즈
```csharp
lineSeries.TrackerFormatString = "시각: {2:HH:mm}\n값: {4:0.##}";
```

### 7.2 줌/팬 동작
- 마우스 휠: 줌  
- 마우스 드래그: 팬  
- Shift + 드래그: 사각형 줌  
- 더블클릭: 리셋(기본 동작)  
- 축별 마우스 제스처는 축 속성으로 세밀 조정 가능(`IsZoomEnabled`, `IsPanEnabled`)

### 7.3 범례 토글
```csharp
plotModel.IsLegendVisible = true;
plotModel.LegendPlacement = LegendPlacement.Outside;
plotModel.LegendPosition = LegendPosition.RightTop;
```
사용자 정의 “시리즈 ON/OFF” 버튼을 View에 두고 시리즈의 `IsVisible`을 토글 후 `InvalidatePlot(true)` 호출.

### 7.4 데이터 포인트 클릭 → 주석 표시(드릴다운)
```csharp
pm.MouseDown += (s, e) =>
{
    var series = pm.Series.OfType<LineSeries>().FirstOrDefault();
    if (series is null) return;
    var hit = series.GetNearestPoint(e.Position, false);
    if (hit != null)
    {
        pm.Annotations.Clear();
        pm.Annotations.Add(new LineAnnotation
        {
            Type = LineAnnotationType.Vertical,
            X = hit.DataPoint.X,
            Color = OxyColors.OrangeRed,
            Text = DateTimeAxis.ToDateTime(hit.DataPoint.X).ToString("HH:mm")
        });
        pm.InvalidatePlot(false);
        e.Handled = true;
    }
};
```

---

## 8) 고급 주제 ② — **복수 축/혼합 시리즈/보조 Y축**

예: 매출(₩) + 주문수(건)를 하나의 차트에 표현 (서로 단위가 다름 → 보조축 이용)

```csharp
var pm = new PlotModel { Title = "매출 & 주문수(보조축)" };
var x = new DateTimeAxis { Position = AxisPosition.Bottom, StringFormat = "HH:mm" };
var yLeft = new LinearAxis { Position = AxisPosition.Left, Title = "₩", Key = "LeftY" };
var yRight = new LinearAxis { Position = AxisPosition.Right, Title = "건수", Key = "RightY" };
pm.Axes.Add(x); pm.Axes.Add(yLeft); pm.Axes.Add(yRight);

var sales = new LineSeries { Title = "매출", YAxisKey = "LeftY", Color = OxyColors.SteelBlue };
var orders = new ColumnSeries { Title = "주문", YAxisKey = "RightY", FillColor = OxyColors.Orange.ChangeAlpha(160) };

// 데이터 채움
// sales.Points.Add(DateTimeAxis.CreateDataPoint(...));
// orders.Items.Add(new ColumnItem(value, categoryIndex));
pm.Series.Add(sales);
pm.Series.Add(orders);
```

> 막대/선 혼합 시 **`ColumnSeries`는 카테고리 축**이 기본인데, 시간축과 혼용하려면 `LinearBarSeries`/`StemSeries` 등을 고려하거나, 주문을 `LineSeries`로 변환하여 겹치는 방식을 택합니다(간단/가독성 ↑).

---

## 9) 데이터 소스 연동(파일/REST) + **비동기·배치 업데이트**

### 9.1 CSV/JSON 파일 로딩
```csharp
var lines = await File.ReadAllLinesAsync(path, ct);
var points = lines.Skip(1)
                  .Select(l => l.Split(','))
                  .Select(a => new SalesPoint(DateTime.Parse(a[0]), double.Parse(a[1])))
                  .ToList();
```

### 9.2 REST API
```csharp
using var http = new HttpClient();
var json = await http.GetStringAsync("https://api.example.com/sales?date=2025-10-25", ct);
var series = JsonSerializer.Deserialize<List<SalesPoint>>(json, new JsonSerializerOptions{ PropertyNamingPolicy = JsonNamingPolicy.CamelCase });
```

> I/O는 **순수 비동기**로, **시리즈 채우기/`InvalidatePlot`** 는 **UI 스레드에서 한 번에**.  
> 항목별 `BeginInvoke` 남발 금지 → `Task.WhenAll()`로 데이터를 모아 **배치 반영**하세요.

---

## 10) 테마/색상 — **다크 모드** & 컬러 팔레트

### 10.1 다크 테마 유틸
```csharp
public static class OxyTheme
{
    public static void ApplyDark(PlotModel m)
    {
        m.TextColor = OxyColors.White;
        m.PlotAreaBorderColor = OxyColor.FromRgb(55,55,55);
        m.LegendTextColor = OxyColors.White;
        m.LegendBackground = OxyColor.FromAColor(220, OxyColors.Black);
        foreach (var axis in m.Axes)
        {
            axis.AxislineColor = OxyColors.Gray;
            axis.MajorGridlineColor = OxyColor.FromRgb(45,45,45);
            axis.MinorGridlineColor = OxyColor.FromRgb(35,35,35);
            axis.TitleColor = OxyColors.White;
            axis.TextColor = OxyColors.White;
        }
    }
}
```

사용:
```csharp
var pm = new PlotModel { Title = "..." };
OxyTheme.ApplyDark(pm);
```

### 10.2 팔레트
```csharp
var palette = OxyPalettes.Hot(20); // 내장 팔레트(Heatmap 등)
```

---

## 11) 내보내기(Export): PNG/PDF/SVG

```csharp
// PNG
using OxyPlot.ImageSharp;
await using var s = File.Create("chart.png");
PngExporter.Export(SalesModel, s, 1200, 600, OxyColors.Transparent);

// PDF
using OxyPlot.SkiaSharp;
await using var sp = File.Create("chart.pdf");
var pdf = new PdfExporter { Width = 1200, Height = 600 };
pdf.Export(SalesModel, sp);

// SVG
await using var ss = File.Create("chart.svg");
var svg = new SvgExporter { Width = 1200, Height = 600, IsDocument = true };
svg.Export(SalesModel, ss);
```

> **팁**: 리포트/메일 자동 생성에 유용. Export 전 **배경/폰트**를 문서용으로 살짝 조정.

---

## 12) 성능 최적화

1) **포인트 제한**  
   - 실시간: `MaximumPoints` 유사 처리(직접 `RemoveAt(0)`), 최근 N개만 유지  
   - 대용량 시 `Decimator` 패턴(간격마다 최대/최소만 표시) 적용  
2) **InvalidatePlot 빈도** 최소화  
   - 여러 시리즈 업데이트 후 **한 번만 호출**  
3) **툴팁/트래커** 계산 비용  
   - 매우 많은 포인트에서는 트래커 꺼두거나 단순 형식  
4) **축 자동 스케일** → 필요 시 명시적 범위/줌으로 불필요한 재계산 방지  
5) **히트테스트**  
   - 선택 기능이 과하면 비용 ↑. 필요한 시리즈에만 켜기  
6) **UI 가상화**  
   - 차트 외 리스트/테이블은 `VirtualizingStackPanel` 필수  
7) **이미지/브러시**는 Freezable `Freeze()` (WPF 렌더 최적화)

샘플(배치 갱신):
```csharp
SalesModel?.SuspendUpdates();
try
{
    // 여러 시리즈/포인트 갱신
}
finally
{
    SalesModel?.InvalidatePlot(true); // 한 번만
}
```

---

## 13) QA/테스트

- **단위 테스트**:  
  - ViewModel에서 `PlotModel.Series.Count`, `Axes.Count`, `Title`, 시리즈 포인트 개수 검증  
  - 실시간 구독은 **가짜 IAsyncEnumerable**로 3~5샘플만 주고 Invalidate 호출 여부 확인
- **스냅샷 테스트**: Export → 파일 해시 비교(픽셀 테스트는 환경 영향으로 느슨하게)

예:
```csharp
[Fact]
public async Task SalesModel_Should_Have_TwoSeries()
{
    var vm = new MainViewModel(new MockDataService());
    await vm.LoadAsync();
    vm.SalesModel.Series.Should().HaveCount(2);
    vm.SalesModel.Axes.Should().HaveCount(2);
}
```

---

## 14) 사용자 경험(UX) 향상 포인트

- 툴바: **날짜 범위 프리셋(오늘/7일/30일)**, Export 버튼  
- 범례 클릭으로 **시리즈 On/Off** (IsVisible 토글)  
- **Annotation**으로 임계치/목표치 표시(LineAnnotation/RectangleAnnotation)  
- **Drilldown**: 특정 구간 드래그 후 컨텍스트 창(상세 리스트/로그 연결)  
- 스크롤 중 **`BitmapScalingMode=LowQuality`** → 정지 시 High

---

## 15) 배포/환경

- **Self-contained**(win-x64/arm64)로 배포하면 런타임 설치 없이 동작  
- **ReadyToRun**로 첫 실행 성능 개선  
- ClickOnce/MSIX로 자동 업데이트 채널 운영 가능(사내망 권장)

`csproj` 발췌:
```xml
<PropertyGroup>
  <SelfContained>true</SelfContained>
  <RuntimeIdentifier>win-x64</RuntimeIdentifier>
  <PublishSingleFile>true</PublishSingleFile>
  <PublishReadyToRun>true</PublishReadyToRun>
</PropertyGroup>
```

---

## 16) 문제 해결(FAQ)

| 이슈 | 원인 | 해결 |
|---|---|---|
| 트래커가 느림 | 포인트 과다 | 포인트 제한/디시메이션, 단순 TrackerFormat |
| 실시간에서 프레임 드랍 | Invalidate 호출 남발 | **SuspendUpdates → Invalidate 1회** |
| 막대/시간축 혼합 깨짐 | Series/Axis 호환 | `ColumnSeries` 대신 `LineSeries/StemSeries` 고려, 카테고리축 분리 |
| Export 폰트/배경 다름 | Exporter 기본값 | Export 전 색상/폰트 명시, 배경 투명/흰색 결정 |
| 다크 모드 글씨 흐림 | 축/격자/텍스트 대비 부족 | `TextColor/Axisline/Gridlines` 명시, 팔레트 재정의 |

---

## 17) 확장 아이디어

- **HeatMapSeries** 로 시간×카테고리 밀도  
- **CandleStickSeries** 로 시세형 대시보드  
- 여러 탭/레이아웃 프리셋(세그먼트별 KPI)  
- **알림**: 임계값 초과 시 토스트/이메일  
- **데이터 소스**: gRPC/SignalR 실시간 스트림

---

## 전체 요약

- **MVVM + OxyPlot**으로 대시보드를 만들 때 핵심은:  
  1) **PlotModel**을 ViewModel에서 조립하고,  
  2) 데이터는 **비동기 병렬 + 배치 반영**,  
  3) 실시간은 **포인트 제한 + 자동 스크롤**,  
  4) 테마/UX/내보내기로 **운영 품질**을 완성.  
