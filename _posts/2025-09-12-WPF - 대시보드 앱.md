---
layout: post
title: WPF - 대시보드 앱
date: 2025-09-12 18:25:23 +0900
category: WPF
---
# OxyPlot 기반 WPF 대시보드 구현 핵심 가이드

## 실제 구현의 핵심 요소

### 1. OxyPlot과 MVVM 통합의 본질

**PlotModel을 ViewModel에서 직접 생성하고 관리**하는 것이 핵심입니다. OxyPlot은 MVVM 패턴에 잘 어울리도록 설계되었습니다:

```csharp
// ViewModel에서 PlotModel 생성
[ObservableProperty]
private PlotModel? salesChartModel;

private void BuildSalesChart()
{
    var model = new PlotModel { Title = "매출 추이" };
    
    // X축 (시간축)
    model.Axes.Add(new DateTimeAxis
    {
        Position = AxisPosition.Bottom,
        StringFormat = "HH:mm",
        Title = "시간"
    });
    
    // Y축 (값축)
    model.Axes.Add(new LinearAxis
    {
        Position = AxisPosition.Left,
        Title = "매출액",
        StringFormat = "#,0"
    });
    
    // 데이터 시리즈 추가
    var series = new LineSeries
    {
        Title = "오늘 매출",
        StrokeThickness = 2,
        Color = OxyColors.Blue
    };
    
    // 데이터 포인트 추가
    foreach (var point in salesData)
    {
        series.Points.Add(DateTimeAxis.CreateDataPoint(point.Time, point.Value));
    }
    
    model.Series.Add(series);
    SalesChartModel = model;
}
```

XAML에서는 간단히 바인딩만 하면 됩니다:
```xml
<oxy:PlotView Model="{Binding SalesChartModel}" />
```

### 2. 실시간 데이터 업데이트의 실제 구현

실시간 차트의 성능을 보장하는 핵심 기술:

```csharp
public class RealTimeChartViewModel
{
    private readonly LineSeries _realTimeSeries;
    private const int MAX_POINTS = 100; // 메모리 제한
    
    public PlotModel RealTimeModel { get; }
    
    public RealTimeChartViewModel()
    {
        RealTimeModel = new PlotModel();
        _realTimeSeries = new LineSeries { StrokeThickness = 1.5 };
        RealTimeModel.Series.Add(_realTimeSeries);
        
        // 실시간 업데이트 시작
        StartRealTimeUpdates();
    }
    
    private async void StartRealTimeUpdates()
    {
        while (true)
        {
            await Task.Delay(1000); // 1초 간격
            
            var newValue = GetNewDataPoint();
            var now = DateTime.Now;
            
            Application.Current.Dispatcher.Invoke(() =>
            {
                // 새로운 포인트 추가
                _realTimeSeries.Points.Add(
                    DateTimeAxis.CreateDataPoint(now, newValue));
                
                // 오래된 포인트 제거
                if (_realTimeSeries.Points.Count > MAX_POINTS)
                {
                    _realTimeSeries.Points.RemoveAt(0);
                }
                
                // X축 자동 스크롤
                var timeAxis = RealTimeModel.Axes.FirstOrDefault(a => a is DateTimeAxis) as DateTimeAxis;
                if (timeAxis != null)
                {
                    var maxTime = DateTimeAxis.ToDouble(now);
                    timeAxis.Zoom(maxTime - 0.001, maxTime);
                }
                
                RealTimeModel.InvalidatePlot(true);
            });
        }
    }
}
```

### 3. 다양한 차트 유형의 실제 구현 예제

**막대 차트 (Bar Chart):**
```csharp
private PlotModel CreateBarChart(IEnumerable<CategoryData> data)
{
    var model = new PlotModel { Title = "카테고리별 매출" };
    
    // 카테고리 축 (세로 막대의 경우 왼쪽)
    var categoryAxis = new CategoryAxis
    {
        Position = AxisPosition.Left,
        ItemsSource = data.Select(d => d.CategoryName)
    };
    
    // 값 축
    var valueAxis = new LinearAxis
    {
        Position = AxisPosition.Bottom,
        Minimum = 0,
        Title = "매출액"
    };
    
    model.Axes.Add(categoryAxis);
    model.Axes.Add(valueAxis);
    
    // 막대 시리즈
    var barSeries = new BarSeries
    {
        LabelPlacement = LabelPlacement.Outside,
        LabelFormatString = "{0:#,0}",
        FillColor = OxyColors.SteelBlue
    };
    
    foreach (var item in data)
    {
        barSeries.Items.Add(new BarItem(item.Value));
    }
    
    model.Series.Add(barSeries);
    return model;
}
```

**파이 차트 (Pie/Donut Chart):**
```csharp
private PlotModel CreatePieChart(IEnumerable<ProductShare> products)
{
    var model = new PlotModel { Title = "제품 점유율" };
    
    var pieSeries = new PieSeries
    {
        StrokeThickness = 1,
        InsideLabelPosition = 0.6, // 도넛 효과 (1.0이면 중앙, 0.0이면 가장자리)
        InnerDiameter = 0.4, // 내부 직경 (도넛 두께)
        ExplodedDistance = 0.1 // 강조된 조각의 이동 거리
    };
    
    foreach (var product in products)
    {
        var slice = new PieSlice(product.Name, product.Share)
        {
            Label = $"{product.Name}\n{product.Share:P1}"
        };
        pieSeries.Slices.Add(slice);
    }
    
    model.Series.Add(pieSeries);
    return model;
}
```

### 4. 고급 상호작용 기능

**데이터 포인트 클릭 이벤트 처리:**
```csharp
private void SetupChartInteractions(PlotModel model)
{
    // 마우스 클릭 이벤트 처리
    model.MouseDown += (sender, args) =>
    {
        if (args.ChangedButton == OxyMouseButton.Left)
        {
            // 가장 가까운 데이터 포인트 찾기
            foreach (var series in model.Series.OfType<LineSeries>())
            {
                var nearest = series.GetNearestPoint(args.Position, false);
                if (nearest != null)
                {
                    // 주석 추가 (수직선 표시)
                    model.Annotations.Clear();
                    model.Annotations.Add(new LineAnnotation
                    {
                        Type = LineAnnotationType.Vertical,
                        X = nearest.DataPoint.X,
                        Color = OxyColors.Red,
                        LineStyle = LineStyle.Dash,
                        Text = $"선택: {nearest.DataPoint.Y:#,0}"
                    });
                    
                    // 선택한 데이터에 대한 추가 작업
                    OnDataPointSelected(nearest.DataPoint);
                    model.InvalidatePlot(false);
                    args.Handled = true;
                    break;
                }
            }
        }
    };
    
    // 트래커 포맷 설정
    foreach (var series in model.Series.OfType<LineSeries>())
    {
        series.TrackerFormatString = 
            "시간: {2:yyyy-MM-dd HH:mm}\n값: {4:#,0}\n변화율: {5:P2}";
    }
}
```

### 5. 실제 성능 최적화 기법

```csharp
public class OptimizedChartViewModel
{
    private readonly Debouncer _updateDebouncer = new Debouncer(TimeSpan.FromMilliseconds(100));
    
    public void AddDataPoint(DateTime time, double value)
    {
        // 디바운싱으로 업데이트 빈도 제한
        _updateDebouncer.Debounce(() =>
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                // 배치 업데이트 시작
                PlotModel.SuspendUpdates();
                try
                {
                    // 여러 시리즈 동시 업데이트
                    foreach (var series in PlotModel.Series)
                    {
                        // 데이터 추가/업데이트 로직
                    }
                }
                finally
                {
                    // 한 번만 화면 갱신
                    PlotModel.InvalidatePlot(true);
                }
            });
        });
    }
    
    // 대용량 데이터를 위한 다운샘플링
    private List<DataPoint> DownsampleData(List<DataPoint> originalData, int targetCount)
    {
        if (originalData.Count <= targetCount) return originalData;
        
        var result = new List<DataPoint>();
        var bucketSize = originalData.Count / (double)targetCount;
        
        for (int i = 0; i < targetCount; i++)
        {
            var startIdx = (int)(i * bucketSize);
            var endIdx = (int)((i + 1) * bucketSize);
            var bucket = originalData.Skip(startIdx).Take(endIdx - startIdx);
            
            if (bucket.Any())
            {
                // 버킷 내 최대값 사용 (데이터 특성에 따라 평균, 최소 등 선택)
                var maxPoint = bucket.OrderByDescending(p => p.Y).First();
                result.Add(maxPoint);
            }
        }
        
        return result;
    }
}
```

### 6. 테마와 스타일 관리

```csharp
public static class ChartThemes
{
    public static void ApplyDarkTheme(PlotModel model)
    {
        model.Background = OxyColor.FromRgb(30, 30, 40);
        model.PlotAreaBackground = OxyColor.FromRgb(40, 40, 50);
        model.TextColor = OxyColors.White;
        model.PlotAreaBorderColor = OxyColors.Gray;
        
        foreach (var axis in model.Axes)
        {
            axis.AxislineColor = OxyColors.LightGray;
            axis.TextColor = OxyColors.White;
            axis.TitleColor = OxyColors.White;
            axis.TicklineColor = OxyColors.Gray;
            
            if (axis is LinearAxis linearAxis)
            {
                linearAxis.MajorGridlineColor = OxyColor.FromRgb(60, 60, 70);
                linearAxis.MinorGridlineColor = OxyColor.FromRgb(50, 50, 60);
            }
        }
        
        // 시리즈 색상 팔레트 적용
        var palette = OxyPalettes.Vibrant(model.Series.Count);
        for (int i = 0; i < model.Series.Count; i++)
        {
            if (model.Series[i] is OxyPlot.Series.BarSeries barSeries)
            {
                barSeries.FillColor = palette.Colors[i];
            }
            else if (model.Series[i] is LineSeries lineSeries)
            {
                lineSeries.Color = palette.Colors[i];
            }
        }
    }
}
```

### 7. 실제 데이터 소스 연동

**REST API에서 데이터 로딩:**
```csharp
public class ApiDataService : IDataService
{
    private readonly HttpClient _httpClient;
    
    public async Task<List<TimeSeriesData>> LoadTimeSeriesAsync(DateTime from, DateTime to)
    {
        var url = $"https://api.example.com/data?" +
                  $"from={from:yyyy-MM-dd}&to={to:yyyy-MM-dd}";
        
        var response = await _httpClient.GetAsync(url);
        response.EnsureSuccessStatusCode();
        
        var json = await response.Content.ReadAsStringAsync();
        var data = JsonSerializer.Deserialize<ApiResponse>(json);
        
        return data.Points.Select(p => new TimeSeriesData
        {
            Time = p.Timestamp,
            Value = p.Value,
            Category = p.Category
        }).ToList();
    }
}
```

**데이터베이스 연동:**
```csharp
public class DatabaseDataService : IDataService
{
    private readonly ApplicationDbContext _context;
    
    public async Task<List<KpiData>> GetKpisAsync(DateTime date)
    {
        return await _context.SalesData
            .Where(s => s.Date.Date == date.Date)
            .GroupBy(s => s.Category)
            .Select(g => new KpiData
            {
                Category = g.Key,
                TotalSales = g.Sum(s => s.Amount),
                TransactionCount = g.Count(),
                AverageValue = g.Average(s => s.Amount)
            })
            .ToListAsync();
    }
}
```

### 8. 실제 배치 업데이트 패턴

```csharp
public class BatchUpdateViewModel
{
    private readonly List<DataPoint> _pendingUpdates = new();
    private readonly object _syncLock = new();
    private readonly Timer _batchTimer;
    
    public BatchUpdateViewModel()
    {
        // 200ms마다 배치 업데이트 실행
        _batchTimer = new Timer(200);
        _batchTimer.Elapsed += ProcessBatchUpdates;
        _batchTimer.Start();
    }
    
    public void QueueUpdate(DataPoint point)
    {
        lock (_syncLock)
        {
            _pendingUpdates.Add(point);
        }
    }
    
    private void ProcessBatchUpdates(object sender, ElapsedEventArgs e)
    {
        List<DataPoint> batch;
        lock (_syncLock)
        {
            if (_pendingUpdates.Count == 0) return;
            batch = _pendingUpdates.ToList();
            _pendingUpdates.Clear();
        }
        
        Application.Current.Dispatcher.Invoke(() =>
        {
            PlotModel.SuspendUpdates();
            try
            {
                foreach (var point in batch)
                {
                    // 차트 업데이트 로직
                    AddPointToSeries(point);
                }
            }
            finally
            {
                PlotModel.InvalidatePlot(true);
            }
        });
    }
}
```

## 결론

OxyPlot 기반 WPF 대시보드 구현의 핵심은 다음과 같습니다:

1. **ViewModel 중심 설계**: PlotModel을 ViewModel에서 직접 생성 및 관리
2. **실시간 처리 최적화**: 디바운싱, 배치 업데이트, 다운샘플링 적용
3. **다양한 차트 유형**: 선형, 막대, 파이, 영역 차트 등 상황에 맞는 시각화 선택
4. **상호작용 강화**: 트래커, 줌/팬, 데이터 포인트 선택 등 사용자 참여 유도
5. **성능 고려사항**: 대용량 데이터 처리를 위한 전략적 접근
6. **확장성**: 다양한 데이터 소스와의 연동 가능성

이러한 요소들을 실제 코드와 함께 구현하면 전문적인 수준의 대시보드 애플리케이션을 개발할 수 있습니다. 각 구성 요소는 모듈화되어 있어 필요에 따라 추가, 제거 또는 교체가 가능하며, 테스트와 유지보수가 용이한 구조를 가집니다.