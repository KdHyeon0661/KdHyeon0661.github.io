---
layout: post
title: 정보보안기사 - GNU Bash 취약점
date: 2025-11-13 23:25:26 +0900
category: 정보보안기사
---
# SECTION 16 주요 취약점 — 01. GNU Bash 취약점(ShellShock)

## ShellShock 한눈에 보기(요약)

| 항목 | 내용 |
|---|---|
| 취약 대상 | **GNU Bash**(4.x/3.x/2.x의 다수 구버전). BusyBox/sh/zsh 자체는 별개. |
| 핵심 원리 | **Bash 함수의 환경변수(export) 구문 파싱 시, 함수 정의 뒤에 이어진 문자열을 명령으로 실행**해버리는 결함. |
| 전파/공격면 | **CGI/FCGI/WSGI 전통 웹서버**, DHCP 클라이언트 훅, OpenSSH `ForceCommand`/`AcceptEnv` 조합, 일부 나쁜 래퍼 스크립트. |
| 대표 CVE | CVE-2014-6271(원본) → 7169(보완), 7186/7187(파서 우회), 6277(스택), 7543 등 후속. |
| 영향 | 원격 RCE(웹서버·IoT), 권한상승·명령주입(서비스 훅), Wormable 스캔. |
| 근본 대책 | **Bash 패치/업그레이드**(배포판의 보안 업데이트), CGI 노출 축소, **WAF/프록시에서 `() {` 시그니처 차단**, 로깅 강화. |
| 2025년 현황 | 메이저 배포판은 오래전 패치. **장기 미패치 OT/내장형 리눅스/폐쇄망 장비**, **EoL 제품**, **낙오 컨테이너 이미지**에서 간헐 검출. |

---

## 내부 원리 — 왜 문제가 되었나

### Bash의 “함수 export” 메커니즘

Bash는 **함수도 환경변수로 내보내기(export)** 할 수 있게 설계되어, 하위 셸/프로세스가 그 함수를 재구성할 수 있다.

```
# 개념

export -f myfunc
# 환경변수에 함수 소스 코드가 담김 → 하위 Bash가 시작될 때 이를 재해석

```

그 표현은 대략 다음과 같이 **환경변수에 함수 정의**와 유사한 문자열이 들어간다.

```
MYFUNC=() { echo "hello"; }
```

### 파서 버그의 본질

구버전 Bash는 위와 같은 **함수 정의 종료(‘}’) 뒤에 이어진 임의 문자열**을 **추가 명령으로 실행**했다. 즉:

```
() { 함수정의 } ; <이어진_임의_명령...>
```

서버가 **환경변수를 신뢰할 수 없는 입력에서 구성**(예: CGI가 `User-Agent`, `Cookie` 등을 환경변수로 승격)하면, **함수 정의 모양을 한 입력 + 뒤따른 명령**이 곧장 실행되어 **RCE**가 된다.

> 핵심: *“Bash가 환경변수에서 함수 정의를 재해석한다”* + *“함수 뒤 잉여 문자열을 실행해버렸다”* → **명령 주입**.

---

## 위협 모델과 전형적 경로(방어 관점)

### 전통 웹(특히 CGI)

- CGI 스펙은 HTTP 헤더를 `HTTP_*` 환경변수로 넘겨준다.
- 구버전 Bash로 쓰인 CGI 스크립트(또는 Bash를 호출하는 스크립트 래퍼)가 있다면, **특정 헤더 값이 Bash 파서에 닿는 순간** 취약.

```
[Client] -> [Web/Proxy] -> [CGI(헤더→ENV)] -> [Bash 해석] -> (명령 실행 위험)
```

### 기타 벡터(간략)

- **DHCP 클라이언트 스크립트**(네트워크 훅): 악성 DHCP 옵션이 환경변수로 들어갈 수 있음.
- **OpenSSH**: `AcceptEnv`/`ForceCommand` 환경 전달과 Bash 호출이 비안전하게 결합된 경우.
- **서드파티 어플라이언스/IoT**: BusyBox가 아닌 **GNU Bash 내장** 장비 + CGI UI.

---

## 안전한 진단/검증

> **중요**: 허가된 자산·격리 환경에서만. 아래 로컬 테스트는 **악성 행위 없이** 취약성 여부를 확인하도록 구성.

### 내 시스템의 Bash 버전/패치 여부

```bash
# 배포판에서 제공하는 보안 백포트가 있어 "버전 숫자만"으로 판단 금지

bash --version
# patchlevel, release string, distro changelog 확인

rpm -q --changelog bash 2>/dev/null | head -n 20
dpkg -l bash 2>/dev/null | awk '/^ii/{print $0}'
```

### “무해한” 로컬 파서 동작 확인

아래 검사는 **임의 명령을 실행하지 않고**, **표준 출력에 특정 토큰을 남기는지**만 봐서 파서 결함 여부를 가늠한다.

```bash
# 안전판 확인 스니펫(출력만 확인)

__SHELLSHOCK_TEST='() { echo test; } harmless' bash -c 'printf "OK\n"'
# 기대 동작(패치됨): "OK"만 출력되어야 함.
# 취약 구현에서는 "test"가 불필요하게 출력되거나, 잉여 부분이 실행될 수 있었음(구버전).

```

```bash
# 함수 export 복원 동작 자체 확인(무해)

export TESTFUNC='() { echo ONLY_FUNC; }'
bash -c 'TESTFUNC'   # 패치/비패치와 무관하게 함수 실행은 정상
```

> **주의**: 인터넷에서 떠도는 “리모트 HTTP 헤더로 명령 실행” 예제는 본 문서에 포함하지 않는다. 원격 테스트는 **WAF/프록시 룰 검증** 수준에서 **비실행 페이로드**로만 접근해야 한다.

---

## 로그·네트워크 관점 탐지(헌팅)

### 시그니처(문자열/정규식)

- 공통 가시 문자열: **`() {`** (함수 export 시그니처)
- HTTP 헤더 필드(Proxy/WAF/웹서버 액세스 로그): `User-Agent`, `Referer`, `Cookie`, `X-Forwarded-For`, 기타 커스텀 헤더

#### 간단 정규식(예: Elastic/grep 등)

```
\(\)\s*\{
```

#### Nginx/Apache Access 로그에서 조사(모의 예)

```bash
# {' 탐지

grep -E '\(\)\s*\{' /var/log/nginx/access.log
```

### KQL 예시

```text
(http.request.headers.user_agent: "*() {*")
OR (http.request.headers.referer: "*() {*")
OR (http.request.headers.cookie: "*() {*")
```

### Splunk SPL 예시

```spl
index=web sourcetype=access_combined
| eval sig=coalesce(cs_user_agent, cs_referer, cookie)
| search sig="*() {*"
| stats count by clientip, cs_uri_stem, cs_user_agent
```

### WAF/프록시 룰 컨셉

```pseudo
IF any(HEADER_VALUES) matches /\(\)\s*\{/
THEN block + log "Possible Bash function export attempt"
```

---

## 완화/대응(단계별)

### 1차 — 패치/업그레이드

- **OS 패키지 업데이트**(Bash 백포트 포함): `yum update bash`, `apt-get install --only-upgrade bash`, `zypper up bash` 등.
- **컨테이너**: 베이스 이미지 갱신(`FROM` 라인 재빌드), **CVE 스캐너**(Trivy/Grype)로 Bash 패키지 확인.

```bash
# RHEL/CentOS/Alma/Rocky

sudo yum update -y bash

# Debian/Ubuntu

sudo apt-get update && sudo apt-get install --only-upgrade -y bash

# SUSE

sudo zypper refresh && sudo zypper update -y bash
```

### 2차 — 공격면 축소

- **CGI 사용 축소**: 가능한 FastCGI/uwsgi/gRPC 백엔드로 전환, **Bash 기반 CGI 제거**.
- 웹앱 경계: **서버 측 환경변수로 사용자 입력 승격 금지**(프레임워크에서 헤더→ENV 차단/화이트리스트화).
- **OpenSSH**: `AcceptEnv` 제한, `ForceCommand`에서 Bash 호출 시 환경 검증 래퍼 적용.

### 3차 — 탐지/차단 방어

- **WAF/Reverse Proxy**: `() {` 시그니처 차단(특히 헤더).
- **ModSecurity(개념 룰)**:
```apache
SecRule REQUEST_HEADERS_NAMES|REQUEST_HEADERS ":\s*\(\)\s*\{" \
 "id:100001,phase:1,deny,status:403,msg:'Possible Bash function export'"
SecRule REQUEST_HEADERS "@rx \(\)\s*\{" \
 "id:100002,phase:1,deny,status:403,msg:'Bash function export in header'"
```

- **Nginx 맵/if(개념)**
```nginx
map $http_user_agent $block_shellshock {
    default 0;
    ~*\(\)\s*\{ 1;
}
server {
    if ($block_shellshock) { return 403; }
    # ...
}
```

### 4차 — 포렌식/사후 검증

- 사고 창구 기간 액세스 로그에서 **`() {`** 검색·IP 집계, 동일 `UA`·`Referer` 패턴 상관.
- 서버 측 **프로세스·감사 로그**(auditd, syslog, Sysmon for Linux)에서 **비정상 Bash 호출** 여부 확인.
- 아티팩트 파일 해시(웹루트·스크립트) **Baseline 대비 변화** 확인.

```bash
# 간단 Baseline/변조 비교(웹루트 예)

find /var/www/html -type f -exec sha256sum {} \; | sort -k2 > /tmp/hash_now.txt
diff -u /opt/baseline/hash_web_2025Q1.txt /tmp/hash_now.txt
```

---

## 안전 실습: 방어 규칙/헌팅 자동화

### HTTP 로그에서 의심 헤더 추출(파이썬; 무해)

```python
import re, sys
pat = re.compile(r"\(\)\s*\{")
for line in sys.stdin:
    if pat.search(line):
        print("[ALERT]", line.strip())
```

### 컨테이너 이미지 점검(Trivy/Grype 등 활용 가이드)

```bash
# Trivy 예시(이미지의 bash CVE 확인)

trivy image --ignore-unfixed --severity HIGH,CRITICAL yourrepo/app:latest | grep -i bash -n
```

### HAProxy에서 헤더 차단(개념)

```haproxy
acl bash_func_export req.hdr_reg(User-Agent) -m reg "\(\)\s*\{"
http-request deny if bash_func_export
```

---

## 운영체크리스트(2025)

- [ ] **Bash 패치 상태** 전수 조사(서버/컨테이너/어플라이언스). EoL 디바이스 목록화와 보완대책(격리/대체).
- [ ] **CGI 노출 제거/대체** 진행 여부, Bash 기반 스크립트 퇴출 계획.
- [ ] 프록시/WAF에 **`() {` 헤더 시그니처 룰** 적용 및 오탐 모니터링.
- [ ] **로그 수집 루트**(웹/프록시/IDS/호스트)에서 정규식 `\(\)\s*\{` **대시보드화**.
- [ ] 배포 파이프라인에 **베이스 이미지 CVE 게이트** 삽입(정책 미준수 빌드 차단).
- [ ] SSH `AcceptEnv` 제한 정책 검토, Bash 호출 래퍼 도입.
- [ ] 사고 시나리오 플레이북: **격리→근절→복구→사후학습** 문서화 및 모의훈련.

---

## 교육·FAQ

**Q1. `bash --version`이 낮으면 무조건 취약한가?**
A. 아닙니다. 배포판은 **백포트 패치**를 제공하므로, 버전 숫자만으로 단정 금지. 패키지 체인지로그·CVE 패치 적용 여부를 확인하세요.

**Q2. BusyBox `ash`면 안전한가?**
A. **ShellShock의 직접 영향은 GNU Bash 파서 버그**입니다. 다만 스크립트가 Bash를 명시적으로 호출한다면 영향 받을 수 있으니 **스크립트 shebang** 확인이 필요.

**Q3. WAF 룰만으로 충분한가?**
A. 아닙니다. 우회 패턴이 가능하고, **근본 해결은 패치**입니다. WAF는 **보조 방어**입니다.

---

## 보고서 템플릿(실무)

- **요약**: 특정 기간 `() {` 시그니처 기반 **워드리스트 스캔/차단** 동향, 탐지 IP/ASN·URI 통계.
- **자산 영향도**: Bash 버전/패치 매핑 결과(서버/컨테이너/어플라이언스).
- **위험평가**: CGI 노출 유무, SSH AcceptEnv 사용 조직, OT/레거시 장비 존재.
- **완화 현황**: 패치 완료율, 프록시/WAF 룰·SIEM 탐지 현행화.
- **잔여위험/계획**: EoL 장비 교체, CI/CD CVE 게이트 강제화, 정기 점검 주기.

---

## 부록 A: CVE 계보(요지)

- **CVE-2014-6271**: 원본 취약점(함수 export 파서가 잉여 문자열 실행).
- **CVE-2014-7169**: 1차 패치 우회 이슈 보완.
- **CVE-2014-6277 / 7186 / 7187 / 7543**: 파서 방어 강화, 추가 경계조건·스택 이슈 등 보완.

> 실무 포인트: “6271만 패치”는 불충분. **후속 CVE까지 포함한 보안 업데이트**가 필요.

---

## 부록 B: 정책 샘플(서버 보안 기준 일부)

```yaml
policy:
  shellshock:
    requirement:
      - All GNU Bash packages must be security-updated per vendor advisory covering CVE-2014-6271,7169,6277,7186,7187,7543.
      - No CGI endpoint may invoke /bin/bash directly.
      - Reverse proxies must block request headers matching /\(\)\s*\{/
    audit:
      - Weekly CVE scan on images and hosts
      - Monthly proxy log hunt for "() {"
```

---

## 부록 C: 안전한 내부 점검 스크립트(종합)

```bash
#!/usr/bin/env bash
# shellshock_safe_audit.sh - 무해한 점검: 버전/패키지/간단 파서 동작/로그 시그니처

set -euo pipefail

echo "[1] Bash 버전/패키지"
bash --version | head -n1 || true
if command -v rpm >/dev/null 2>&1; then
  rpm -q bash || true
elif command -v dpkg >/dev/null 2>&1; then
  dpkg -l bash | awk '/^ii/{print $0}'
fi
echo

echo "[2] 무해 파서 테스트(출력만 확인: OK만 나와야 안전)"
__SHELLSHOCK_TEST='() { echo SHOULD_NOT_PRINT; } harmless' bash -c 'echo OK'
echo

echo "[3] 웹/프록시 로그 시그니처 검사(있을 때만)"
for f in /var/log/nginx/access.log /var/log/httpd/access_log /var/log/haproxy.log; do
  [ -f "$f" ] || continue
  echo " -> scanning $f"
  grep -E '\(\)\s*\{' "$f" | sed -e 's/^/SUSPECT: /' | head -n 20 || true
done
echo

echo "[4] 요약: 패치 최신화/CGI 사용 여부/프록시 룰 점검 필요"
```

> *실행은 관리자 승인·점검 창구 내에서만. 실제 서비스에 영향 없는 안전 동작.*

---

## 결론

- ShellShock는 2014년에 공개된 **역사적 취약점**이지만, 2025년 현재도 **레거시 자산/오래된 컨테이너/OT 장비**에서 재발견된다.
- **근본 해결은 패치**이며, **CGI 축소·환경변수 경계 최소화·프록시/WAF 차단·로그 기반 헌팅**이 재발 방지의 4대 축이다.
- 보안팀은 **패치 준수 게이트(이미지/호스트)**와 **지속 모니터링**을 병행해 **장기 잔여위험**을 관리해야 한다.
