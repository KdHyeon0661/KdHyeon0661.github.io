---
layout: post
title: DB 심화 - 블록 클린아웃
date: 2025-10-19 14:25:23 +0900
category: DB 심화
---
# Oracle **블록 클린아웃(Block Cleanout)** 완전 가이드  
— **Delayed Cleanout / Commit Cleanout / ITL과의 관계**, 내부 동작·증상·실습·튜닝 (19c 기준)

> 목표  
> - **블록 클린아웃**이 무엇이며, 왜 필요한지(ACID 관점)와 **언제/어디서** 일어나는지 정확히 정리  
> - **Commit Cleanout**(커밋 시도 중/직후의 클린아웃) vs **Delayed Cleanout**(추후 읽는 세션이 대신 수행) **차이점**을 내부 구조와 함께 설명  
> - **ITL(Interested Transaction List)** 과 **Row Lock Byte** 가 클린아웃과 어떻게 맞물리는지, 실제 **대기 이벤트/통계**에 어떤 상관이 있는지 실무 시나리오로 제시  
> - **재현 가능한 실습**(세션 A/B), **블록 덤프**, **진단 SQL**과 **튜닝 체크리스트** 제공

---

## 0) 한눈 개요 — “왜 클린아웃이 필요한가?”

오라클은 **행을 변경**하면 해당 **데이터 블록 헤더의 ITL 슬롯**과 **행 헤더(Row Lock Byte)** 에 **“이 블록의 어느 행을 어떤 트랜잭션(XID)이 잠갔는지”** 를 기록합니다.  
**커밋**이 끝났다면 이후의 읽기는 “이미 커밋됐음”을 **빠르게 판정**해야 하고, 가능하면 **Undo를 더 이상 뒤지지 않게** 만들고 싶습니다.  
이 목적을 위해 **블록/ITL에 커밋 정보를 반영(= 클린아웃, cleanout)** 합니다.

- **Commit Cleanout**: **커밋 직전/직후**(보통 커밋 Path에서) 클린아웃을 **즉시** 시도  
- **Delayed Cleanout**: 커밋 당시 못 했던 클린아웃을 **이후에 블록을 읽는 세션**이 **대신** 수행

> 효과: 클린아웃이 되면 다음 읽기에서는 **Undo 추적 없이** ITL만 보고 “커밋됨”을 판정 → **CR 비용 감소**, **일관 읽기 속도 개선**.

---

## 1) 관련 구조 복습 — ITL · Row Lock Byte · XID(Undo 슬롯)

- **ITL(블록 헤더)**: “**이 블록을 변경한 트랜잭션**” 들의 슬롯 리스트  
  - **XID (usn.slot.sqn)**, **Undo 포인터**, **플래그**, **커밋 SCN**(클린아웃 후) 저장
- **Row Lock Byte(행 헤더)**: “**나를 잠근 ITL 슬롯 번호**” 저장  
  ⇒ 행 → ITL 슬롯 → XID → Undo 슬롯(트랜잭션 테이블)로 연결
- **트랜잭션 테이블 슬롯(Undo 세그먼트)**: XID가 가리키는 집(현재 상태, 커밋 SCN, Undo 체인 헤드)

**클린아웃의 본질**은:  
- **ITL 엔트리에 “커밋 SCN”을 써 넣고, 락/상태 플래그를 정리**  
- 필요시 **Row Lock Byte** 를 “잠금 해제 상태”로 정돈(블록 버전/포맷에 따라 표현)

---

## 2) Commit Cleanout vs Delayed Cleanout — 차이와 발생 조건

### 2.1 Commit Cleanout (커밋 클린아웃)
- **언제**: 트랜잭션 **커밋 Path**에서 **해당 트랜잭션이 건드린 일부/대상 블록**에 대해 즉시 클린아웃을 **시도**  
- **목표**: **ITL에 커밋 SCN**을 박고 **락 흔적 정리** → 이후 읽기가 Undo 없이 빠르게 “커밋됨” 판정  
- **특성**: 모든 블록에 **항상** 100% 다 해주는 것은 **아님**. 작업량이 크면 일부는 **나중(Delayed)** 으로 미룰 수 있음(성능/부담 고려).

### 2.2 Delayed Cleanout (지연 클린아웃)
- **언제**: **커밋 이후**, 해당 블록을 **다음에 읽는 세션**이 **ITL을 확인**하다가 **커밋 SCN이 비어 있거나 불명확**하면,  
  **트랜잭션 테이블 슬롯을 조회**해 커밋 사실/SCN을 확인한 뒤 **ITL에 기록**(= 지연 클린아웃 수행).  
- **특성/영향**:
  - **읽기 세션**이 **일시적으로 더 많은 작업**(Undo/트랜잭션 슬롯 조회)과 **작은 쓰기**(ITL 갱신)를 하게 됨  
  - 대량 갱신 직후 **보고서/조회**가 같은 블록들을 **우르르** 읽으면, **지연 클린아웃 비용**으로 **지연/경합**이 보일 수 있음

---

## 3) 클린아웃이 일으키는 “보이는 현상”

- **지연 클린아웃 시점**의 읽기는 **잠깐 더 느릴 수 있음**(Undo/슬롯 조회 + ITL 갱신)  
- 세그먼트/블록 단위로 **`buffer busy waits`** 나 **`read by other session`** 가 약간 더 보일 수 있음(패턴에 따라)  
- RAC 환경에선 인스턴스 간 **gc 관련 대기**(예: `gc cr request`)와 결합해 **클린아웃 트래픽**이 늘 수 있음  
- 그러나 **장기적으로**는 **ITL에 커밋 SCN이 채워져** 이후 읽기에서 **Undo 추적이 줄어들어** 전체 **CR 비용은 감소**

> 즉, 클린아웃은 **조금의 비용을 선지불/지불**해 **이후 읽기를 싸게** 만드는 **캐싱 효과**로 이해할 수 있습니다.

---

## 4) 실습 — Commit/Delayed Cleanout 체감하기

> 주의: **테스트 전용** 환경에서 실행하세요.

### 4.1 준비

```sql
DROP TABLE t_clean PURGE;

CREATE TABLE t_clean (
  id   NUMBER PRIMARY KEY,
  g    NUMBER NOT NULL,
  v    NUMBER NOT NULL
);

BEGIN
  FOR i IN 1..20000 LOOP
    INSERT INTO t_clean VALUES (i, MOD(i,10), 0);
    IF MOD(i,1000)=0 THEN COMMIT; END IF;
  END LOOP;
  COMMIT;
END;
/
CREATE INDEX ix_clean_g ON t_clean(g);
```

### 4.2 세션 A — 대량 UPDATE 후 커밋 (Commit Cleanout 일부 수행)

```sql
-- 세션 A
UPDATE t_clean
   SET v = v + 1
 WHERE g IN (0,1,2,3,4);
COMMIT;
```

- 내부적으로 **커밋 Path에서** 클린아웃을 **가능한 범위**에서 **시도**  
- 하지만 모든 블록이 즉시 클린아웃된다고 보장할 수는 없음(작업량/버퍼 상태 등에 따름)

### 4.3 세션 B — 이어서 동일 범위 조회(Delayed Cleanout 유발)

```sql
-- 세션 B
-- 커밋 직후, 같은 블록들을 즉시/대량으로 읽기
SELECT /*+ FULL(t_clean) */ SUM(v) FROM t_clean WHERE g IN (0,1,2,3,4);
```

**관찰 포인트**
- 첫 조회에서는 일부 블록에서 **지연 클린아웃**이 일어나 **ITL에 커밋 SCN**을 채우는 비용이 드러날 수 있음  
- **같은 조회를 곧이어 다시** 실행하면(같은 블록 재접근) **Undo 추적 없이** 빠르게 완료되는 경향

> 동일 워크로드를 여러 번 반복하며 AWR/ASH의 **`consistent gets` vs `db block gets`**, **대기 이벤트** 패턴 변화를 관찰하면 클린아웃 효과를 체감할 수 있습니다.

---

## 5) 블록/ITL 관점의 “클린아웃” 절차(개념 단계)

1. **행 변경(UPDATE/DELETE/INSERT)**  
   - **Row Lock Byte**: 잠근 **ITL 슬롯 번호** 기록  
   - **ITL 슬롯**: XID/Undo 포인터/플래그 등 갱신
2. **커밋 시도**  
   - LGWR가 Redo에 커밋 기록 flush(내구성 보장)  
   - 가능하면 **해당 블록들의 ITL에 커밋 SCN**을 **즉시 기록(Commit Cleanout)**  
3. **이후 읽기(Delayed Cleanout)**  
   - 읽는 세션이 **ITL에 커밋 SCN 미기록**을 보고 → **트랜잭션 슬롯 조회**로 **커밋 확인** → **ITL에 커밋 SCN 기입**  
   - 이후 동일 블록의 읽기는 Undo 없이 “커밋됨” 판정

> ITL에 커밋 SCN이 있으면, **Row Lock Byte** 가 지시하는 ITL만 보면 **끝**.  
> **Undo 접근(트랜잭션 슬롯 탐색)** 없이 **문장 수준 일관성** 판정이 빨라집니다.

---

## 6) 클린아웃과 ITL(Interested Transaction List)

### 6.1 ITL 엔트리의 역할
- **“이 블록을 변경한 트랜잭션”** 의 자리표  
- **클린아웃 결과**: ITL에 **커밋 SCN** 을 박음  
- 이후 읽기는 **ITL.commit_scn ≤ 쿼리 SCN** 판정만으로 “이미 커밋된 변경”임을 확인

### 6.2 ITL 부족과의 상호작용
- 동시에 여러 트랜잭션이 같은 블록을 갱신하면 **ITL 부족** (`enq: TX - allocate ITL entry`) 이 발생  
- ITL 부족·버퍼 경합이 심한 환경에서 **지연 클린아웃**이 겹치면, 일시적으로 **`buffer busy waits`** 가 더 튈 수 있음  
- **INITRANS/PCTFREE 확장**, **핫 블록 분산**(파티셔닝, 키 설계)로 **ITL/경합**을 낮추면 **클린아웃 부담**도 자연히 완화

---

## 7) 실제 증상·대기와의 연결고리

클린아웃 자체는 **전용 대기 이벤트**로 찍히지 않는 경우가 많지만, 상황에 따라 다음이 동반 관측될 수 있습니다.

- **`read by other session`**  
  - 동일 블록을 여러 세션이 동시에 미스 → 한 세션이 읽는 동안 나머지는 기다림  
  - 커밋 직후 대량 조회가 몰릴 때, **지연 클린아웃**과 함께 보일 수 있음
- **`buffer busy waits`**  
  - 같은 블록을 여러 세션이 경쟁 → ITL/헤더/체인 접근 경합  
  - 지연 클린아웃으로 **ITL 갱신(작은 쓰기)** 이 들어가며 경합이 올라갈 여지
- **`latch: cache buffers chains`**  
  - **핫 버킷/핫 블록** 집중 시 CBC 래치 미스/슬립 증가(클린아웃 자체 때문이라기보다 **패턴**의 결과)
- RAC:
  - **`gc cr request` / `gc buffer busy`**  
  - 여러 인스턴스가 같은 블록을 번갈아 읽고 클린아웃하면 **GC 메시지/전송**이 늘 수 있음

---

## 8) 진단/관측 SQL 모음

```sql
-- 시스템 전반 일관/현재/물리 I/O
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('consistent gets','db block gets','physical reads','user commits','redo size')
ORDER  BY name;

-- 세션 대기 (읽기/버퍼/락)
SELECT sid, event, wait_class, state, seconds_in_wait
FROM   v$session
WHERE  state <> 'WAITED SHORT TIME'
AND    (event LIKE 'read by other session'
    OR  event LIKE 'buffer busy waits'
    OR  event LIKE 'enq: TX%')
ORDER  BY seconds_in_wait DESC;

-- 세그먼트 통계로 "어디가 핫한지"
SELECT o.owner, o.object_name, o.object_type,
       SUM(CASE WHEN s.statistic_name='buffer busy waits' THEN s.value ELSE 0 END) AS buf_busy,
       SUM(CASE WHEN s.statistic_name='physical reads'    THEN s.value ELSE 0 END) AS phys_reads,
       SUM(CASE WHEN s.statistic_name='logical reads'     THEN s.value ELSE 0 END) AS log_reads
FROM   v$segment_statistics s
JOIN   dba_objects o ON o.owner=s.owner AND o.object_name=s.object_name
GROUP  BY o.owner, o.object_name, o.object_type
ORDER  BY buf_busy DESC FETCH FIRST 20 ROWS ONLY;

-- Undo 보존/지연 클린아웃 영향 파악(ORA-01555 동반 여부 등)
SELECT begin_time, undoblks, txncount, ssolderrcnt, tuned_undoretention
FROM   v$undostat
ORDER  BY begin_time DESC FETCH FIRST 24 ROWS ONLY;
```

---

## 9) 블록 덤프(선택) — ITL에 커밋 SCN이 박히는지 보기

> SYS 권한 필요. 운영에서 과한 덤프는 지양.

```sql
-- 특정 행의 파일/블록 번호 획득
SELECT rowid,
       DBMS_ROWID.ROWID_RELATIVE_FNO(rowid) AS file#,
       DBMS_ROWID.ROWID_BLOCK_NUMBER(rowid) AS block#
FROM   t_clean
WHERE  id BETWEEN 1 AND 5;

-- 덤프
ALTER SYSTEM DUMP DATAFILE <file#> BLOCK <block#>;
```

덤프에서 볼 것(개략):

- **ITL 리스트**: 슬롯별 **XID**, **UBA(Undo 주소)**, **플래그**, **scn**  
  - **Commit Cleanout 전**: `scn`(커밋 SCN)이 비었거나 미기록  
  - **Delayed Cleanout 후**: 해당 ITL에 **커밋 SCN** 기록 확인  
- **Row Directory/Row Header**: **row lock byte** 상태 변화(버전/포맷에 따라 표현)

---

## 10) 실전 시나리오 3가지

### 10.1 “대량 DML → 즉시 보고서” (Delayed Cleanout 비용 체감)
- **상황**: ETL이 막 끝났고, 바로 요약 보고서 SELECT들이 같은 테이블을 **풀스캔**  
- **현상**: 첫 몇 분간 보고서들이 **조금 더 느림**. AWR에 **`read by other session`/`buffer busy`** 가 약간 상승  
- **해설**: 일부 블록은 **커밋 클린아웃** 못 받은 상태 → **지연 클린아웃**이 보고서 세션에서 수행  
- **대응**:  
  - 가능하면 ETL 직후 **짧은 워밍업 SELECT** 로 **핫셋 사전 클린아웃**  
  - 파티션 단위로 **작업/조회 분리**, **KEEP 풀** 사용 검토

### 10.2 “핫 블록 + 지연 클린아웃 + ITL 부족”
- **상황**: 여러 세션이 특정 키 범위를 집중 UPDATE → 동일 블록에 **ITL 경쟁** 심함  
- **현상**: `enq: TX - allocate ITL entry` + `buffer busy waits` 증가, 이후 SELECT가 몰리며 지연 클린아웃까지 겹쳐 잠시 난조  
- **대응**:  
  - **INITRANS/PCTFREE** 확대(ITL 확장 여지), **키 분산(Reverse/Hash)**, **파티셔닝**  
  - **배치 시간**과 **조회 시간** 분리

### 10.3 RAC에서의 “클린아웃 트래픽”
- **상황**: 여러 인스턴스가 같은 파티션/블록에 접근  
- **현상**: `gc cr request`/`gc buffer busy` 증가(클린아웃 자체 + CR 이미지 공유 트래픽)  
- **대응**:  
  - **서비스/파티션**으로 워크로드 로컬리티 확보  
  - **시퀀스 캐시/증가폭**, **키 균등화**, **파티션 프루닝** 촉진

---

## 11) 튜닝/운영 체크리스트

1. **커밋 직후 대량 조회** 패턴인가?  
   - 최초 조회가 느린 건 **지연 클린아웃** 때문일 수 있음 → **워밍업 쿼리/파티션 순회**로 사전 클린  
2. **ITL/헤더 여유**  
   - **INITRANS** 늘리고 **PCTFREE** 로 헤더 여유 확보 → ITL 경쟁/클린아웃 경합 완화  
3. **핫 블록 분산**  
   - **Reverse Key**, **Hash 파티셔닝**, **샤딩 카운터** 등  
4. **Undo 보존/용량**(ORA-01555 동반 여부 확인)  
   - 클린아웃 자체는 Undo를 재구성하는 작업은 아니지만, **커밋 여부 확인** 과정에서 Undo/슬롯 접근 패턴과 결합  
5. **RAC 로컬리티**  
   - 동일 파티션/키에 대한 **인스턴스 고정**(서비스/파티션 맵핑)  
6. **AWR/ASH**  
   - 클린아웃만으로 판단하지 말고 **상위 대기/세그먼트 통계**로 **전체 흐름** 파악

---

## 12) 추가 실습 — “워밍업으로 클린아웃 비용 앞당기기”

```sql
-- 1) 대량 갱신 후 커밋
UPDATE t_clean SET v = v + 5 WHERE g IN (0,1,2,3,4);
COMMIT;

-- 2) 워밍업: 대상 범위를 빠르게 한 번 훑어 클린아웃을 유도
SELECT /*+ FULL(t_clean) */ COUNT(*) 
FROM   t_clean 
WHERE  g IN (0,1,2,3,4);

-- 3) 실제 리포트
SELECT /*+ FULL(t_clean) */ SUM(v), AVG(v), MIN(v), MAX(v)
FROM   t_clean
WHERE  g IN (0,1,2,3,4);
```

- **의도**: 2)에서 **지연 클린아웃** 비용을 선지불 → 3)에서 **보다 안정된 응답시간** 기대

---

## 13) 수학적 감각(개념식)

- **읽기 비용 모델(개념)**  
  $$ \text{Cost(First Read)} \approx \text{Base Scan} + \text{Delayed Cleanout Overhead} $$
  $$ \text{Cost(Next Reads)} \approx \text{Base Scan} $$
- **지연 클린아웃의 기대 이득**(같은 블록 재활용이 클수록)  
  $$ \Delta \text{CR Cost} \downarrow \quad \text{as} \quad \text{Cleanout Coverage} \uparrow $$

---

## 14) FAQ

**Q1. 왜 커밋 때 모든 블록을 100% 클린아웃하지 않나요?**  
A. 커밋 Path에서 **과도한 작업**을 강제하면 **커밋 지연**(=`log file sync` 증가)로 전체 OLTP 응답성이 나빠질 수 있습니다. 따라서 오라클은 **균형**을 취합니다. “중요 블록은 즉시, 나머지는 추후(Delayed)” 방식.

**Q2. 클린아웃은 데이터 무결성에 영향 없나요?**  
A. **없습니다.** 무결성은 **Redo/Undo/트랜잭션 슬롯**으로 보장됩니다. 클린아웃은 **성능 최적화**(빠른 커밋 판정) 성격.

**Q3. 지연 클린아웃 때문에 ORA-01555가 늘 수 있나요?**  
A. 직접적 인과는 아닙니다. 다만 **대량 DML + 장시간 조회 + Undo 부족** 환경에서 여러 현상이 **동시에** 나타날 수 있으므로 **Undo 보존/용량**은 항상 점검하세요.

**Q4. 클린아웃이 많으면 위험 신호인가요?**  
A. 자체가 “문제”는 아닙니다. 다만 **커밋 직후 동일 블록 대량 조회**가 반복되는 패턴이면 **워밍업/파티셔닝/인덱스/캐시** 전략으로 **피크를 분산**할 가치가 있습니다.

---

## 15) 요약

- **블록 클린아웃**은 **ITL에 커밋 SCN을 채워 넣어** 이후 읽기에서 **Undo 없이 빠르게 커밋 판정**을 가능케 하는 최적화입니다.  
- **Commit Cleanout**은 **커밋 시도/직후**에 **가능한 범위**로 수행되고, **Delayed Cleanout**은 **다음 읽는 세션**이 **대신** 수행합니다.  
- **ITL/Row Lock Byte/XID** 구조가 클린아웃의 토대이며, **핫 블록/ITL 부족/동시성 패턴**과 결합해 **일시적 경합/대기**가 보일 수 있습니다.  
- **대응**: **INITRANS/PCTFREE 조정**, **키 분산/파티셔닝**, **워밍업 조회**, **RAC 로컬리티**, **Undo 보존/용량** 점검, **AWR/ASH로 상위 원인** 파악.

> 한 줄 정리:  
> **클린아웃은 커밋을 “알려두기”다. 지금 조금 써서, 다음엔 빠르게 읽으려는 똑똑한 메모.**
