---
layout: post
title: WPF - 스타일, 리소스, 데이터 바인딩
date: 2025-08-27 23:25:23 +0900
category: WPF
---
# 스타일, 리소스, 데이터 바인딩

WPF의 **스타일(Style)**, **리소스(Resource)**, **데이터 바인딩(Data Binding)**은 “디자인 ⇄ 로직”을 느슨하게 결합시켜 **테마 교체**, **재사용**, **유지보수**를 극적으로 개선합니다.  
이 글은 세 요소의 **역할/상호작용/고급 활용/주의점**을 예제 중심으로 정리합니다.

---

## 1) 리소스(Resource)

### 1.1 리소스 사전(ResourceDictionary)와 범위
- **리소스**: 브러시, 스타일, 템플릿, 문자열, 컨버터, 이미지 등 **XAML 객체**를 키-값으로 저장
- **검색 범위**: **요소 → 부모 트리 → 해당 Window/Page → Application(Resources) → 테마/시스템** 순
- **중첩/병합**: `MergedDictionaries`로 파일 분리/모듈화

```xml
<Application.Resources>
  <ResourceDictionary>
    <ResourceDictionary.MergedDictionaries>
      <ResourceDictionary Source="Themes/Colors.xaml"/>
      <ResourceDictionary Source="Themes/Styles.xaml"/>
      <ResourceDictionary Source="Themes/DataTemplates.xaml"/>
    </ResourceDictionary.MergedDictionaries>

    <!-- 전역 컨버터/브러시 -->
    <SolidColorBrush x:Key="PrimaryBrush" Color="#4F46E5"/>
    <local:NullToVisibilityConverter x:Key="NullToVisibility"/>
  </ResourceDictionary>
</Application.Resources>
```

> **리소스 조회 순서**를 이해하면 “리소스 키 없음” 오류와 우선순위 충돌을 빠르게 해결할 수 있습니다.

### 1.2 StaticResource vs DynamicResource
- **`{StaticResource}`**: 로드(파싱) 시점에 한 번만 찾음 → **빠름**, 변경 **미반영**
- **`{DynamicResource}`**: 런타임에 참조 유지 → 값이 바뀌면 **자동 갱신**, **오버헤드** 증가  
  → **테마 전환**/런타임 색상 변경에 적합

```xml
<TextBlock Foreground="{StaticResource PrimaryBrush}"/>
<TextBlock Foreground="{DynamicResource PrimaryBrush}"/> <!-- 런타임 테마 전환 -->
```

### 1.3 암시적(Implicit) 리소스 & x:Shared
- **암시적 스타일**: `x:Key` 미지정 + `TargetType`만 설정 시 자동 적용
- **`x:Shared="False"`**: 리소스를 참조할 때마다 **새 인스턴스** 생성 (기본은 `True` = 싱글턴)

```xml
<Window.Resources>
  <!-- 모든 TextBlock에 자동 적용 -->
  <Style TargetType="TextBlock">
    <Setter Property="Margin" Value="4"/>
  </Style>

  <!-- 매번 새 Geometry 생성 -->
  <Geometry x:Key="Ring" x:Shared="False">M 0 0 L 10 0 ...</Geometry>
</Window.Resources>
```

### 1.4 외부 어셈블리/컴포넌트 리소스
- **Pack URI**
  - 같은 어셈블리: `pack://application:,,,/Themes/Styles.xaml`
  - 다른 어셈블리 `MyLib`: `pack://application:,,,/MyLib;component/Themes/Styles.xaml`
- **ComponentResourceKey**: 라이브러리에서 **강한 이름의 키**를 노출할 때 사용

```xml
<SolidColorBrush x:Key="{ComponentResourceKey TypeInTargetAssembly={x:Type ext:ThemeKeys},
                                       ResourceId=PrimaryBrush}" Color="#4F46E5"/>
```

### 1.5 커스텀 컨트롤 테마
- **`Themes/Generic.xaml`**에 기본 스타일/템플릿 배치
- 어셈블리 `ThemeInfo` 특성으로 테마 검색 위치 지정(최근 SDK 프로젝트는 자동)

---

## 2) 스타일(Style)

### 2.1 기본 구조
- **대상 타입(TargetType)**과 **Setter** 목록으로 구성
- **명시적 스타일**: `x:Key`로 참조  
- **암시적 스타일**: `x:Key` 생략 → 해당 타입 전체에 적용(범위는 리소스 사전 스코프)

```xml
<Style x:Key="PrimaryButton" TargetType="Button" BasedOn="{StaticResource {x:Type Button}}">
  <Setter Property="Padding" Value="10,6"/>
  <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
  <Setter Property="Foreground" Value="White"/>
</Style>
```

> **BasedOn**으로 중복을 줄이고 테마 계층을 만든다.

### 2.2 트리거(Trigger)
- **Property Trigger**: 속성 값에 따른 스타일 변경
- **DataTrigger**: 바인딩 데이터 상태에 따른 변경
- **MultiTrigger/MultiDataTrigger**: 조건 복합

```xml
<Style TargetType="Button" x:Key="HoverButton" BasedOn="{StaticResource PrimaryButton}">
  <Style.Triggers>
    <Trigger Property="IsMouseOver" Value="True">
      <Setter Property="Opacity" Value="0.9"/>
    </Trigger>
    <DataTrigger Binding="{Binding IsBusy}" Value="True">
      <Setter Property="IsEnabled" Value="False"/>
      <Setter Property="Content" Value="처리중..."/>
    </DataTrigger>
  </Style.Triggers>
</Style>
```

### 2.3 EventSetter / 스타일 변경 불가 규칙
- **EventSetter**: XAML에서 이벤트 핸들러 연결 (MVVM이면 `EventToCommand`/Behavior 권장)
- **스타일은 한 번 “Sealed”되면 런타임에 수정 불가** → 스타일 재적용/교체 필요
- **Setter.Value에는 `{Binding}` 직접 사용 불가**  
  - 대안: **ControlTemplate 내부 바인딩**, **Attached Freezable(바인딩 프록시)**, **Behaviors**, 코드 등

```xml
<Style TargetType="ListBoxItem">
  <EventSetter Event="MouseDoubleClick" Handler="OnItemDoubleClick"/>
</Style>
```

### 2.4 ControlTemplate / DataTemplate와의 관계(요약)
- **Style**는 외형/동작의 “규칙” 묶음  
- **ControlTemplate**는 **컨트롤의 시각 트리 자체**를 교체  
- **DataTemplate**는 **데이터 타입→표현** 매핑  
→ 셋을 조합해 테마/스킨을 전면 교체할 수 있음

---

## 3) 데이터 바인딩(Data Binding)

### 3.1 바인딩 기본
- 바인딩 방향: `Mode=OneWay|TwoWay|OneTime|OneWayToSource`
- 변경 통지: **`INotifyPropertyChanged`** / 컬렉션은 **`ObservableCollection<T>`**
- 업데이트: `UpdateSourceTrigger=PropertyChanged|LostFocus|Explicit`

```xml
<TextBox Text="{Binding UserName, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>
<TextBlock Text="{Binding Total, StringFormat='총액: {0:C}'}"/>
```

### 3.2 DataContext & 경계
- **DataContext는 트리로 상속**(자식 요소로 전파)  
- **`DataTemplate` 내부, `Style` 트리거 내부** 등은 **새 컨텍스트**가 될 수 있으므로 `RelativeSource`/`ElementName`로 경계 넘나듦

```xml
<!-- 형제 요소 바인딩 -->
<TextBox x:Name="Input"/>
<TextBlock Text="{Binding Text, ElementName=Input}"/>

<!-- 조상 탐색 -->
<TextBlock Text="{Binding DataContext.Title, RelativeSource={RelativeSource AncestorType=Window}}"/>
```

### 3.3 RelativeSource / TemplatedParent / x:Reference
```xml
<!-- 자기 자신 -->
<TextBlock Text="{Binding ActualWidth, RelativeSource={RelativeSource Self}}"/>

<!-- 템플릿의 소유자(컨트롤) -->
<ControlTemplate TargetType="Button">
  <Border Background="{TemplateBinding Background}">
    <ContentPresenter/>
  </Border>
</ControlTemplate>

<!-- 이름 참조 -->
<Grid x:Name="Root">
  <TextBlock Text="{Binding Source={x:Reference Root}, Path=ActualHeight}"/>
</Grid>
```

### 3.4 컨버터(IValueConverter / IMultiValueConverter)
```csharp
public class BoolToVisibilityConverter : IValueConverter
{
    public object Convert(object v, Type t, object p, CultureInfo c)
        => (v is bool b && b) ? Visibility.Visible : Visibility.Collapsed;
    public object ConvertBack(object v, Type t, object p, CultureInfo c) => Binding.DoNothing;
}
```

```xml
<Window.Resources>
  <local:BoolToVisibilityConverter x:Key="BoolToVisibility"/>
</Window.Resources>

<TextBlock Text="완료" Visibility="{Binding IsDone, Converter={StaticResource BoolToVisibility}}"/>
```

**MultiBinding** 예:
```xml
<TextBlock>
  <TextBlock.Text>
    <MultiBinding StringFormat="{}{0} / {1}">
      <Binding Path="DoneCount"/>
      <Binding Path="TotalCount"/>
    </MultiBinding>
  </TextBlock.Text>
</TextBlock>
```

### 3.5 Validation & 오류 표시
- **`IDataErrorInfo`** 또는 **`INotifyDataErrorInfo`**로 검증 에러 노출
- XAML: `ValidatesOnDataErrors=True`, `NotifyOnValidationError=True`, `Validation.ErrorTemplate`로 시각화

```xml
<TextBox Text="{Binding Age, UpdateSourceTrigger=PropertyChanged, ValidatesOnDataErrors=True}">
  <TextBox.Style>
    <Style TargetType="TextBox">
      <Style.Triggers>
        <Trigger Property="Validation.HasError" Value="True">
          <Setter Property="ToolTip" Value="{Binding RelativeSource={RelativeSource Self},
                                   Path=(Validation.Errors)[0].ErrorContent}"/>
          <Setter Property="BorderBrush" Value="Red"/>
        </Trigger>
      </Style.Triggers>
    </Style>
  </TextBox.Style>
</TextBox>
```

### 3.6 CollectionView(정렬/그룹/필터)
- **모든 ItemsSource 컬렉션에는 뷰(CollectionView)가 존재**
- XAML에서 `CollectionViewSource`로 **정렬/그룹/필터** 정의 가능

```xml
<Window.Resources>
  <CollectionViewSource x:Key="UsersView" Source="{Binding Users}">
    <CollectionViewSource.GroupDescriptions>
      <PropertyGroupDescription PropertyName="Department"/>
    </CollectionViewSource.GroupDescriptions>
    <CollectionViewSource.SortDescriptions>
      <scm:SortDescription PropertyName="Name" Direction="Ascending"/>
    </CollectionViewSource.SortDescriptions>
  </CollectionViewSource>
</Window.Resources>

<ListView ItemsSource="{Binding Source={StaticResource UsersView}}">
  <ListView.GroupStyle>
    <GroupStyle>
      <GroupStyle.HeaderTemplate>
        <DataTemplate>
          <TextBlock Text="{Binding Name}" FontWeight="Bold"/>
        </DataTemplate>
      </GroupStyle.HeaderTemplate>
    </GroupStyle>
  </ListView.GroupStyle>
</ListView>
```

> 필터는 코드에서:  
> `((CollectionView)UsersView.View).Filter = item => ((User)item).IsActive;`

### 3.7 FallbackValue / TargetNullValue / PriorityBinding
- **FallbackValue**: 바인딩 실패(경로 없음)시 대체값  
- **TargetNullValue**: 결과가 **null**일 때만 대체
- **PriorityBinding**: 여러 바인딩 중 **가장 먼저 해결되는 것** 사용

```xml
<TextBlock Text="{Binding Title, TargetNullValue='(제목 없음)', FallbackValue='(로드 중)'}"/>
```

### 3.8 바인딩 진단
- 출력 창/디버그: `PresentationTraceSources.TraceLevel=High`
```xml
<TextBlock Text="{Binding Title, PresentationTraceSources.TraceLevel=High}"/>
```
- **Live Visual Tree / Live Property Explorer**로 런타임 바인딩/리소스 확인

---

## 4) 세 요소의 협업: 패턴 예시

### 4.1 스타일 + 리소스 + 바인딩 결합
```xml
<Window.Resources>
  <SolidColorBrush x:Key="Accent" Color="#10B981"/>
  <Style x:Key="Card" TargetType="Border">
    <Setter Property="CornerRadius" Value="12"/>
    <Setter Property="Padding" Value="16"/>
    <Setter Property="Background" Value="{StaticResource Accent}"/>
    <Setter Property="Effect">
      <Setter.Value>
        <DropShadowEffect ShadowDepth="0" BlurRadius="12" Opacity="0.35"/>
      </Setter.Value>
    </Setter>
    <Style.Triggers>
      <DataTrigger Binding="{Binding IsSelected}" Value="True">
        <Setter Property="Background" Value="#34D399"/>
      </DataTrigger>
    </Style.Triggers>
  </Style>
</Window.Resources>

<Border Style="{StaticResource Card}">
  <StackPanel>
    <TextBlock Text="{Binding Name}" FontSize="16" FontWeight="Bold"/>
    <TextBlock Text="{Binding Description}" TextWrapping="Wrap"/>
  </StackPanel>
</Border>
```

### 4.2 MVVM과 DataTemplate로 뷰 자동 매핑
```xml
<!-- App.xaml -->
<DataTemplate DataType="{x:Type vm:DashboardViewModel}">
  <views:DashboardView/>
</DataTemplate>

<!-- 어디서든 -->
<ContentControl Content="{Binding CurrentViewModel}"/>
```
> 뷰모델만 바꾸면 **알맞은 뷰가 자동으로 렌더링** → 결합도 낮아짐

---

## 5) 베스트 프랙티스 & 주의사항

- **리소스 구조화**: 전역(App) vs 로컬(View) 리소스 분리, `MergedDictionaries`로 주제별 파일화  
- **StaticResource 우선**, 런타임 테마 전환 등 필요 시에만 **DynamicResource**  
- **Style 재사용**: `BasedOn` 적극 활용, 중복 제거  
- **Setter.Binding 불가**: 템플릿 내부 바인딩/프록시/Behavior로 우회  
- **바인딩 성능**: 불필요한 TwoWay/PropertyChanged 남발 지양, 변경 폭이 큰 바인딩은 가볍게  
- **검증/오류 표시**: `INotifyDataErrorInfo` + `Validation.HasError` 트리거로 UX 확보  
- **CollectionView**: 정렬/필터/그룹은 **컬렉션이 아닌 뷰**에서 처리  
- **디버깅 습관**: TraceLevel, Live Visual Tree, 출력 창 바인딩 오류 확인

---

## 6) 간단한 뷰모델 샘플(참조용)

```csharp
public class MainViewModel : INotifyPropertyChanged
{
    private string _userName = "";
    private bool _isBusy;
    public string UserName
    {
        get => _userName;
        set { _userName = value; OnPropertyChanged(); }
    }
    public bool IsBusy
    {
        get => _isBusy;
        set { _isBusy = value; OnPropertyChanged(); }
    }

    public ObservableCollection<User> Users { get; } = new();

    public event PropertyChangedEventHandler? PropertyChanged;
    protected void OnPropertyChanged([CallerMemberName] string? name = null)
        => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
}

public class User { public string Name { get; set; } = ""; public string Department { get; set; } = ""; }
```

---

### 결론
- **리소스**는 재사용과 테마의 기반,  
- **스타일**은 외형/상태 규칙의 집합,  
- **데이터 바인딩**은 뷰와 뷰모델의 다리입니다.  
세 가지를 체계적으로 결합하면 **테마 교체가 쉬운, 데이터 주도형, 테스트 가능한** WPF UI를 구현할 수 있습니다.