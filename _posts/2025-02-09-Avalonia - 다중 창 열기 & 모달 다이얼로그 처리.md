---
layout: post
title: Avalonia - 다중 창 열기 및 모달 다이얼로그 처리
date: 2025-02-09 19:20:23 +0900
category: Avalonia
---
# Avalonia 다중 창(Window) 열기 및 모달 다이얼로그 처리

## 0. 목표 요약

| 기능 | 핵심 포인트 |
|---|---|
| 새 창 열기 | ViewLocator/서비스를 통해 ViewModel→Window 연결 |
| 모달 다이얼로그 | `ShowDialog<T>()` + `Close(T)` 로 **강 타입 결과** |
| 결과 반환 | `Task<TResult>`로 await; 취소/ESC/닫기 X도 반영 |
| 데이터 전달 | ViewModel 생성자 파라미터/DTO/상태 주입 |
| ViewModel 분리 | `IWindowService`/`IDialogService`/ReactiveUI `Interaction<TIn,TOut>` |
| UX 보완 | 창 위치/크기 복원, Topmost, Owner 지정, 닫기 방지(유효성) |

---

## 1. 예제 프로젝트 구조

```
MyApp/
├── App.axaml / App.axaml.cs
├── Infrastructure/
│   ├── ViewLocator.cs
│   ├── WindowPersistence.cs
│   └── CloseGuardBehavior.cs
├── Services/
│   ├── IWindowService.cs
│   ├── IDialogService.cs
│   ├── WindowService.cs
│   └── DialogService.cs
├── Views/
│   ├── MainView.axaml / .cs
│   ├── DetailWindow.axaml / .cs
│   ├── ConfirmDialog.axaml / .cs
│   └── EditProductDialog.axaml / .cs
├── ViewModels/
│   ├── MainViewModel.cs
│   ├── DetailViewModel.cs
│   ├── ConfirmDialogViewModel.cs
│   └── EditProductDialogViewModel.cs
└── Models/
    └── Product.cs
```

---

## 2. 가장 단순한 방법(학습용): 코드비하인드에서 여는 창

> 실무에서는 직접 호출을 **서비스/Interaction**로 감싸는 편이 낫다. 여기는 개념 디딤돌.

### Views/DetailWindow.axaml
```xml
<Window xmlns="https://github.com/avaloniaui"
        x:Class="MyApp.Views.DetailWindow"
        Width="420" Height="300"
        WindowStartupLocation="CenterOwner">
  <StackPanel Margin="20" Spacing="8">
    <TextBlock Text="{Binding Title}" FontSize="18"/>
    <TextBlock Text="{Binding Description}" TextWrapping="Wrap"/>
    <Button Content="닫기" HorizontalAlignment="Right" Click="OnCloseClick"/>
  </StackPanel>
</Window>
```

### Views/DetailWindow.axaml.cs
```csharp
public partial class DetailWindow : Window
{
    public DetailWindow() => InitializeComponent();

    private void OnCloseClick(object? sender, RoutedEventArgs e) => Close();
}
```

### ViewModels/DetailViewModel.cs
```csharp
public sealed class DetailViewModel : ReactiveObject
{
    public DetailViewModel(string title, string description)
    {
        Title = title;
        Description = description;
    }

    public string Title { get; }
    public string Description { get; }
}
```

### ViewModels/MainViewModel.cs (학습용 직접 호출)
```csharp
public sealed class MainViewModel : ReactiveObject
{
    public ReactiveCommand<Unit, Unit> OpenDetailCommand { get; }

    public MainViewModel()
    {
        OpenDetailCommand = ReactiveCommand.Create(OpenDetailWindow);
    }

    private void OpenDetailWindow()
    {
        var vm = new DetailViewModel("상세", "여기에 상세 설명");
        var win = new DetailWindow { DataContext = vm };

        var life = (IClassicDesktopStyleApplicationLifetime)Application.Current!.ApplicationLifetime!;
        win.Show(life.MainWindow); // Owner 설정
    }
}
```

**Owner 지정**: `Show(owner)`/`ShowDialog(owner)` 사용 시, 포커스 관리·작업 표시줄 그룹화가 자연스러워진다.

---

## 3. 모달 다이얼로그 — 강 타입 결과(Task<TResult>)

Avalonia `Window`는 **제네릭 모달 API**를 제공한다:

- `Task<TResult> ShowDialog<TResult>(Window owner)`  
- `void Close(TResult dialogResult)`

### Views/ConfirmDialog.axaml
```xml
<Window xmlns="https://github.com/avaloniaui"
        x:Class="MyApp.Views.ConfirmDialog"
        Width="300" Height="150"
        CanResize="False"
        WindowStartupLocation="CenterOwner">
  <StackPanel Margin="20" Spacing="10">
    <TextBlock Text="{Binding Message}"/>
    <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" Spacing="10">
      <Button Content="예" Click="YesClick"/>
      <Button Content="아니오" Click="NoClick"/>
    </StackPanel>
  </StackPanel>
</Window>
```

### Views/ConfirmDialog.axaml.cs
```csharp
public partial class ConfirmDialog : Window
{
    public ConfirmDialog() => InitializeComponent();
    private void YesClick(object? s, RoutedEventArgs e) => Close(true);
    private void NoClick(object? s, RoutedEventArgs e)  => Close(false);
}
```

### ViewModels/ConfirmDialogViewModel.cs
```csharp
public sealed class ConfirmDialogViewModel : ReactiveObject
{
    public ConfirmDialogViewModel(string message) => Message = message;
    public string Message { get; }
}
```

### 모달 호출(강 타입)
```csharp
private async Task<bool> ShowConfirmAsync(string msg)
{
    var vm = new ConfirmDialogViewModel(msg);
    var dlg = new ConfirmDialog { DataContext = vm };

    var life = (IClassicDesktopStyleApplicationLifetime)Application.Current!.ApplicationLifetime!;
    bool result = await dlg.ShowDialog<bool>(life.MainWindow!);
    return result;
}
```

> 닫기(X)/ESC 시 `default(bool)`(즉 `false`)가 반환된다. 다른 타입일 경우 `default(T)`에 주의.

---

## 4. MVVM 친화: 창/다이얼로그 호출 **서비스 추상화**

ViewModel이 Window를 직접 생성하지 않도록 **서비스 인터페이스**로 추상화한다.

### Services/IWindowService.cs
```csharp
public interface IWindowService
{
    void ShowWindow(object viewModel, Window? owner = null);
}
```

### Services/IDialogService.cs
```csharp
public interface IDialogService
{
    Task<TResult> ShowDialogAsync<TResult>(object viewModel, Window? owner = null);
}
```

### Infrastructure/ViewLocator.cs — ViewModel→View 매핑
```csharp
public sealed class ViewLocator : IDataTemplate
{
    public Control Build(object? data)
    {
        return data switch
        {
            ConfirmDialogViewModel => new ConfirmDialog { DataContext = data },
            DetailViewModel       => new DetailWindow { DataContext = data },
            EditProductDialogViewModel => new EditProductDialog { DataContext = data },
            _ => new TextBlock { Text = "View not found" }
        };
    }
    public bool Match(object? data) => data is not null;
}
```

> App.axaml에 DataTemplates로 등록하여 Avalonia가 자동으로 템플릿을 찾도록 할 수도 있다. 여기서는 **직접 생성**해 명확히 보여준다.

### Services/WindowService.cs
```csharp
public sealed class WindowService : IWindowService
{
    public void ShowWindow(object viewModel, Window? owner = null)
    {
        var view = new ViewLocator().Build(viewModel);
        if (view is not Window window)
            throw new InvalidOperationException("View must be a Window for ShowWindow.");

        if (owner is null)
        {
            var life = (IClassicDesktopStyleApplicationLifetime)Application.Current!.ApplicationLifetime!;
            owner = life.MainWindow!;
        }
        window.Show(owner);
    }
}
```

### Services/DialogService.cs
```csharp
public sealed class DialogService : IDialogService
{
    public async Task<TResult> ShowDialogAsync<TResult>(object viewModel, Window? owner = null)
    {
        var view = new ViewLocator().Build(viewModel);
        if (view is not Window window)
            throw new InvalidOperationException("View must be a Window for ShowDialog.");

        if (owner is null)
        {
            var life = (IClassicDesktopStyleApplicationLifetime)Application.Current!.ApplicationLifetime!;
            owner = life.MainWindow!;
        }
        return await window.ShowDialog<TResult>(owner);
    }
}
```

### MainViewModel — 서비스 사용
```csharp
public sealed class MainViewModel : ReactiveObject
{
    private readonly IWindowService _windowService;
    private readonly IDialogService _dialogService;

    public MainViewModel(IWindowService ws, IDialogService ds)
    {
        _windowService = ws;
        _dialogService = ds;

        OpenDetailCommand = ReactiveCommand.Create(OpenDetail);
        DeleteCommand     = ReactiveCommand.CreateFromTask(DeleteAsync);
    }

    public ReactiveCommand<Unit, Unit> OpenDetailCommand { get; }
    public ReactiveCommand<Unit, Unit> DeleteCommand { get; }

    private void OpenDetail()
    {
        var vm = new DetailViewModel("상세", "MVVM/DI로 띄운 창");
        _windowService.ShowWindow(vm);
    }

    private async Task DeleteAsync()
    {
        var confirm = new ConfirmDialogViewModel("정말 삭제하시겠습니까?");
        bool ok = await _dialogService.ShowDialogAsync<bool>(confirm);
        if (!ok) return;

        // 삭제 로직...
    }
}
```

**이점**: ViewModel 테스트 시 Window/Dialog 호출을 **Mock**으로 대체 가능.

---

## 5. ReactiveUI Interaction<TIn, TOut> — 완전 분리 패턴

ViewModel은 **대화 요청**만 발행하고, View 측에서 구독해 UI를 띄운다.

### ViewModel
```csharp
public sealed class EditProductDialogViewModel : ReactiveObject
{
    public EditProductDialogViewModel(Product product) => Product = product;
    public Product Product { get; }
}

public sealed class MainViewModel : ReactiveObject
{
    public Interaction<EditProductDialogViewModel, Product?> EditProductInteraction { get; } = new();
    public ReactiveCommand<Product, Unit> EditCommand { get; }

    public MainViewModel()
    {
        EditCommand = ReactiveCommand.CreateFromTask<Product>(async p =>
        {
            var editorVm = new EditProductDialogViewModel(p);
            var result = await EditProductInteraction.Handle(editorVm);
            if (result is not null)
            {
                // 저장/후속 처리
            }
        });
    }
}
```

### View(MainView.axaml.cs) — 구독
```csharp
public partial class MainView : UserControl
{
    public MainView() => InitializeComponent();

    protected override void OnDataContextChanged(EventArgs e)
    {
        base.OnDataContextChanged(e);

        if (DataContext is MainViewModel vm)
        {
            vm.EditProductInteraction.RegisterHandler(async ctx =>
            {
                var dlg = new EditProductDialog { DataContext = ctx.Input };
                var life = (IClassicDesktopStyleApplicationLifetime)Application.Current!.ApplicationLifetime!;
                var result = await dlg.ShowDialog<Product?>(life.MainWindow!);
                ctx.SetOutput(result);
            });
        }
    }
}
```

**장점**: VM은 UI를 모르고 “상호 작용 요청”만 발행 → 테스트/유지보수 최적.

---

## 6. 결과 반환 패턴: `Close(T)` vs `TaskCompletionSource`

- Avalonia의 `ShowDialog<T>()`/`Close(T)` 조합을 **우선** 사용 (강 타입/간단).
- 커스텀 조건/여러 경로의 결과 필요 시 TCS를 써도 되지만, 대부분은 `Close(T)`로 충분.

---

## 7. 창 UX 고급: 위치/크기 복원, 닫기 차단, Topmost 등

### 7.1 위치/크기 복원

#### Infrastructure/WindowPersistence.cs
```csharp
public static class WindowPersistence
{
    private static readonly string Path = System.IO.Path.Combine(
        Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
        "MyApp", "window.json");

    private sealed record WinState(double W, double H, double X, double Y, WindowState S);

    public static void Restore(Window win)
    {
        try
        {
            if (!File.Exists(Path)) return;
            var json = File.ReadAllText(Path);
            var s = System.Text.Json.JsonSerializer.Deserialize<WinState>(json);
            if (s is null) return;

            win.Width  = s.W;
            win.Height = s.H;
            if (!double.IsNaN(s.X) && !double.IsNaN(s.Y))
            {
                win.WindowStartupLocation = WindowStartupLocation.Manual;
                win.Position = new PixelPoint((int)s.X, (int)s.Y);
            }
            win.WindowState = s.S;
        }
        catch { /* 무시 */ }
    }

    public static void Save(Window win)
    {
        try
        {
            Directory.CreateDirectory(System.IO.Path.GetDirectoryName(Path)!);
            var s = new WinState(win.Width, win.Height, win.Position.X, win.Position.Y, win.WindowState);
            var json = System.Text.Json.JsonSerializer.Serialize(s);
            File.WriteAllText(Path, json);
        }
        catch { /* 무시 */ }
    }
}
```

#### DetailWindow.axaml.cs에서 사용
```csharp
public partial class DetailWindow : Window
{
    public DetailWindow()
    {
        InitializeComponent();
        Opened += (_, _) => WindowPersistence.Restore(this);
        Closing += (_, _) => WindowPersistence.Save(this);
    }
}
```

### 7.2 닫기 차단(필드 유효성/미저장 변경)

#### Infrastructure/CloseGuardBehavior.cs
```csharp
public interface ICloseGuard
{
    bool CanClose(); // false면 닫기 차단
}

public sealed class CloseGuardBehavior
{
    public static void Attach(Window win)
    {
        win.Closing += (s, e) =>
        {
            if (win.DataContext is ICloseGuard guard && !guard.CanClose())
            {
                e.Cancel = true;
            }
        };
    }
}
```

#### EditProductDialogViewModel.cs
```csharp
public sealed class EditProductDialogViewModel : ReactiveObject, ICloseGuard
{
    public Product Product { get; }
    private bool _dirty;
    public bool Dirty { get => _dirty; set => this.RaiseAndSetIfChanged(ref _dirty, value); }

    public EditProductDialogViewModel(Product p)
    {
        Product = p;
        // 속성 변경 추적 등으로 Dirty=true 설정
    }

    public bool CanClose()
    {
        if (!Dirty) return true;
        // 여기서는 간단히 막기; 실제론 Confirm Dialog 띄워도 됨(서비스 호출)
        return false;
    }
}
```

#### EditProductDialog.axaml.cs
```csharp
public partial class EditProductDialog : Window
{
    public EditProductDialog()
    {
        InitializeComponent();
        CloseGuardBehavior.Attach(this);
    }
}
```

### 7.3 Topmost/크기 자동/아이콘/작업표시줄
```xml
<Window ... Topmost="False" SizeToContent="WidthAndHeight">
  <!-- SizeToContent은 다이얼로그에 유용 -->
</Window>
```
```csharp
this.Icon = new WindowIcon(AssetLoader.Open(new Uri("avares://MyApp/Assets/app.ico")));
this.CanResize = false; // 간단한 모달
```

---

## 8. 파일/폴더/메시지 다이얼로그(보너스)

### 파일 열기
```csharp
var ofd = new OpenFileDialog
{
    AllowMultiple = false,
    Filters = { new FileDialogFilter() { Name = "Images", Extensions = { "png", "jpg" } } }
};
var life = (IClassicDesktopStyleApplicationLifetime)Application.Current!.ApplicationLifetime!;
var result = await ofd.ShowAsync(life.MainWindow!);
if (result is { Length: >0 }) { /* result[0] */ }
```

### 폴더 선택
```csharp
var fbd = new OpenFolderDialog { Title = "폴더 선택" };
var folder = await fbd.ShowAsync(life.MainWindow!);
```

### 메시지 박스(간단 구현 예)
```csharp
public static async Task<bool> ShowMessageAsync(string message)
{
    var vm = new ConfirmDialogViewModel(message);
    var dlg = new ConfirmDialog { DataContext = vm };
    var life = (IClassicDesktopStyleApplicationLifetime)Application.Current!.ApplicationLifetime!;
    return await dlg.ShowDialog<bool>(life.MainWindow!);
}
```

---

## 9. DI 등록(App.axaml.cs)

```csharp
public override void OnFrameworkInitializationCompleted()
{
    var sc = new ServiceCollection();

    // Services
    sc.AddSingleton<IWindowService, WindowService>();
    sc.AddSingleton<IDialogService, DialogService>();

    // ViewModels
    sc.AddSingleton<MainViewModel>();
    sc.AddTransient<DetailViewModel>();
    sc.AddTransient<ConfirmDialogViewModel>();
    sc.AddTransient<EditProductDialogViewModel>();

    var sp = sc.BuildServiceProvider();

    var life = (IClassicDesktopStyleApplicationLifetime)Application.Current!.ApplicationLifetime!;
    life.MainWindow = new Window
    {
        Content = new Views.MainView(),
        DataContext = sp.GetRequiredService<MainViewModel>()
    };

    life.MainWindow.Show();
    base.OnFrameworkInitializationCompleted();
}
```

> DI를 쓰면 ViewModel에서 `IWindowService`/`IDialogService`를 주입받아 **테스트 시 Mock**으로 교체하기 쉽다.

---

## 10. 테스트 전략

| 대상 | 방법 |
|---|---|
| ViewModel 분기 | `IDialogService` Mock → `ShowDialogAsync<bool>` 결과에 따라 로직 검증 |
| 창 닫기 차단 | `ICloseGuard.CanClose()` 반환값에 따른 `Closing.Cancel` 확인(윈도우 인스턴스 통합 테스트) |
| 크기/위치 복원 | `WindowPersistence`를 파일 스텁 경로에 연결해 Read/Write 확인 |
| Interaction 패턴 | `RegisterHandler` 대신 테스트에서 `Handle`을 직접 완료시켜 시나리오 검증 |

예) `DeleteAsync` 동작 검증
```csharp
var dialog = new Mock<IDialogService>();
dialog.Setup(d => d.ShowDialogAsync<bool>(It.IsAny<object>(), It.IsAny<Window?>()))
      .ReturnsAsync(true);

var ws = new Mock<IWindowService>();
var vm = new MainViewModel(ws.Object, dialog.Object);

await vm.DeleteCommand.Execute();
dialog.Verify(d => d.ShowDialogAsync<bool>(It.IsAny<object>(), It.IsAny<Window?>()), Times.Once);
```

---

## 11. 성능·안정성 팁

- **Owner** 반드시 지정(모달/비모달 모두) → 포커스/Alt+Tab/작업표시줄 UX 개선.
- **모달 중 중복 호출 방지**: `IsDialogOpen` 플래그나 `SemaphoreSlim(1,1)` 사용.
- **ESC/Enter 키 바인딩**: 다이얼로그에 `IsDefault`, `IsCancel` 버튼 지정.
- **비정상 종료 대비**: 창 상태 저장 시 try/catch, 유효 범위 검사(음수 좌표 등) 필수.
- **다중 모니터**: 복원 좌표가 실제 스크린 내부인지 체크 후 보정.

---

## 12. 정리 표

| 주제 | 권장 패턴 |
|---|---|
| 다중 창/모달 | `IWindowService`/`IDialogService` 또는 ReactiveUI `Interaction` |
| 결과 반환 | `ShowDialog<T>()` + `Close(T)` (강 타입) |
| 데이터 전달 | VM 생성자 파라미터/DTO/DI 주입 |
| 닫힘 제어 | `ICloseGuard` + `Window.Closing` |
| 상태 복원 | `Opened`/`Closing` 시 파일로 Size/Position 저장/복원 |
| 테스트 | 서비스 Mock/Interaction 핸들러 대체 |

---

## 13. 부록: 간단한 편집 다이얼로그 전체 예

### Models/Product.cs
```csharp
public sealed class Product
{
    public int Id { get; init; }
    public string Name { get; set; } = "";
    public decimal Price { get; set; }
}
```

### ViewModels/EditProductDialogViewModel.cs
```csharp
public sealed class EditProductDialogViewModel : ReactiveObject, ICloseGuard
{
    private string _name = "";
    private decimal _price;
    private bool _dirty;

    public EditProductDialogViewModel(Product p)
    {
        Id = p.Id;
        Name = p.Name;
        Price = p.Price;

        this.WhenAnyValue(x => x.Name, x => x.Price)
            .Subscribe(_ => Dirty = true);

        SaveCommand = ReactiveCommand.Create(Save);
        CancelCommand = ReactiveCommand.Create(Cancel);
    }

    public int Id { get; }
    public string Name { get => _name; set => this.RaiseAndSetIfChanged(ref _name, value); }
    public decimal Price { get => _price; set => this.RaiseAndSetIfChanged(ref _price, value); }
    public bool Dirty { get => _dirty; set => this.RaiseAndSetIfChanged(ref _dirty, value); }

    public ReactiveCommand<Unit, Product?> SaveCommand { get; }
    public ReactiveCommand<Unit, Product?> CancelCommand { get; }

    private Product? Save() => new() { Id = Id, Name = Name, Price = Price };
    private Product? Cancel() => null;

    public bool CanClose() => !Dirty; // Dirty면 차단(실전은 Confirm 띄워 처리)
}
```

### Views/EditProductDialog.axaml
```xml
<Window xmlns="https://github.com/avaloniaui"
        x:Class="MyApp.Views.EditProductDialog"
        Width="360" Height="200"
        CanResize="False" WindowStartupLocation="CenterOwner">
  <StackPanel Margin="16" Spacing="8">
    <TextBlock Text="상품 편집" FontSize="18"/>
    <Grid ColumnDefinitions="auto,*" RowDefinitions="auto,auto" Margin="0,6">
      <TextBlock Text="이름:" Grid.Row="0" Grid.Column="0" Margin="0,0,8,0"/>
      <TextBox Text="{Binding Name}" Grid.Row="0" Grid.Column="1"/>

      <TextBlock Text="가격:" Grid.Row="1" Grid.Column="0" Margin="0,4,8,0"/>
      <TextBox Text="{Binding Price}" Grid.Row="1" Grid.Column="1"/>
    </Grid>
    <StackPanel Orientation="Horizontal" HorizontalAlignment="Right" Spacing="8">
      <Button Content="저장" IsDefault="True" Click="OnSaveClick"/>
      <Button Content="취소" IsCancel="True" Click="OnCancelClick"/>
    </StackPanel>
  </StackPanel>
</Window>
```

### Views/EditProductDialog.axaml.cs
```csharp
public partial class EditProductDialog : Window
{
    public EditProductDialog()
    {
        InitializeComponent();
        CloseGuardBehavior.Attach(this);
    }

    private void OnSaveClick(object? s, RoutedEventArgs e)
    {
        if (DataContext is EditProductDialogViewModel vm)
            Close(vm.SaveCommand.Execute().FirstAsync().Wait());
    }

    private void OnCancelClick(object? s, RoutedEventArgs e)
    {
        if (DataContext is EditProductDialogViewModel vm)
            Close(vm.CancelCommand.Execute().FirstAsync().Wait());
    }
}
```

> 실전에서는 `Click` 대신 **Interactions/Commands**로 더 MVVM스럽게 만들 수 있다.  
> 여기서는 `Close(T)` 흐름을 명시적으로 보여주기 위해 간단히 처리.

---

## 결론

- Avalonia의 **제네릭 모달 API**(`ShowDialog<T>()` / `Close(T)`)와 **Owner 지정**을 올바르게 사용하면 다중 창/다이얼로그 UX가 안정적이다.
- ViewModel은 **Window/Dialog 생성 로직을 몰라야** 하며, `IWindowService`/`IDialogService` 또는 **ReactiveUI Interaction**으로 완전 분리하자.
- 운영 품질을 위해 **크기/위치 복원**, **닫기 차단(Dirty/검증)**, **파일/폴더 다이얼로그** 등을 체계화하자.
- 모든 흐름은 `Task<TResult>`로 귀결되므로, **await 가능**하고 **단위 테스트가 쉬운** 구조를 만들 수 있다.