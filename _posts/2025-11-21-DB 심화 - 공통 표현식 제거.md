---
layout: post
title: DB 심화 - 공통 표현식 제거
date: 2025-11-21 14:25:23 +0900
category: DB 심화
---
# 공통 표현식 제거(Common Subexpression Elimination, CSE)

## 왜 CSE인가? (동기와 직관)

- 동일한 연산/서브쿼리/조인을 반복하면 **CPU**·**논리 읽기**·**래치 경합**이 증가하고, **캐시 지역성**이 나빠진다.
- CSE는 **중복된 계산을 식별→한 번만 수행→결과 재사용**하여 비용을 줄인다.

**간단 수식(직관)**
$$
\text{원래비용} \approx N \cdot \text{cost}(\text{공통식}) \quad\rightarrow\quad
\text{CSE} \approx \text{cost}(\text{1회평가}) + N \cdot \text{cost}(\text{재사용})
$$

---

## Oracle에서의 CSE 구현 레버

1. **서브쿼리 팩터링**: `WITH`(CTE)로 공통 블록을 만들고 **여러 번 참조**
   - 옵티마이저는 상황에 따라 이 CTE를 **INLINE(병합)** 또는 **MATERIALIZE(1회 실행 후 재사용)** 함.
   - 힌트: `/*+ INLINE */`, `/*+ MATERIALIZE */`, `/*+ NO_MERGE */`, `/*+ MERGE */`, `QB_NAME` 등.
2. **조인 팩터링**(Join Factorization): `UNION ALL` 분기들이 **같은 조인/필터**를 공유할 때, 공통 부분을 **바깥**으로 끌어내 재사용.
3. **스칼라 서브쿼리 캐시**: 같은 입력 키의 스칼라 서브쿼리는 **실행 시점 캐시**로 중복 평가를 줄임(하지만 **키 다양성**이 크면 여전히 비용↑).
4. **함수 결과 캐시/결정성**: `DETERMINISTIC` 함수 + `RESULT_CACHE`(또는 서버 결과 캐시 힌트)로 **비용 큰 함수/서브쿼리** 결과를 캐싱.
5. **뷰 머징(View Merging)**: 동일 인라인 뷰를 여러 번 조인하는 경우, **한 번만 계산**하도록 병합/팩터링.

---

## 스칼라 “표현식” 레벨 CSE

### 동일 함수/표현식 반복 평가 줄이기

```sql
-- (안티패턴) 같은 표현식을 여러 번 계산
SELECT
  TO_CHAR(s.sales_dt, 'YYYYMM') AS yyyymm,
  SUM(CASE WHEN TO_CHAR(s.sales_dt,'YYYYMM') = :p_mm THEN s.amount END) AS sum_this_mm
FROM f_sales s
GROUP BY TO_CHAR(s.sales_dt,'YYYYMM')
ORDER BY TO_CHAR(s.sales_dt,'YYYYMM');  -- 3번 반복

-- (개선) 공통식 1회 계산 → 재사용
WITH x AS (
  SELECT s.*,
         TO_CHAR(s.sales_dt,'YYYYMM') AS yyyymm
  FROM f_sales s
)
SELECT
  x.yyyymm,
  SUM(CASE WHEN x.yyyymm = :p_mm THEN x.amount END) AS sum_this_mm
FROM x
GROUP BY x.yyyymm
ORDER BY x.yyyymm;
```

- **효과**: `TO_CHAR` 3회→1회.
- **추가 최적화**: 자주 쓰는 표현식이라면 **함수기반 인덱스** 생성 고려
  ```sql
  CREATE INDEX ix_fs_mm ON f_sales(TO_CHAR(sales_dt,'YYYYMM'));
  ```

### 윈도 함수·정렬 중복 제거

```sql
-- (안티패턴) 같은 윈도 정의 두 번
SELECT
  s.*,
  SUM(s.amount) OVER (PARTITION BY s.cust_id ORDER BY s.sales_dt) AS run_sum,
  AVG(s.amount) OVER (PARTITION BY s.cust_id ORDER BY s.sales_dt) AS run_avg
FROM f_sales s;

-- (개선) 공통 ORDER/PARTITION을 한번만 만들고 재사용(엔진이 내부 CSE 수행 가능)
-- 또는 중간 뷰로 정렬/파티션을 고정하고 추가 집계를 바깥에서 계산
WITH base AS (
  SELECT s.*,
         SUM(s.amount) OVER (PARTITION BY s.cust_id ORDER BY s.sales_dt
                             ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS run_sum
  FROM f_sales s
)
SELECT b.*,
       CASE WHEN ROW_NUMBER() OVER (PARTITION BY b.cust_id ORDER BY b.sales_dt) = 1
            THEN b.amount ELSE (b.run_sum / NULLIF(
                ROW_NUMBER() OVER (PARTITION BY b.cust_id ORDER BY b.sales_dt),0))
        END AS run_avg_approx
FROM base b;
```

> 주의: 윈도 함수를 외부에서 “수식으로 재조합”하면 **정확성**이 달라질 수 있다.
> 가장 안전한 CSE는 **같은 윈도 함수를 한번만 기술**하고 **SELECT 리스트에서 재사용(별칭)** 하는 것.

---

## 스칼라 **서브쿼리** CSE

### 동일 스칼라 서브쿼리 다중 사용

```sql
-- (안티패턴) 같은 스칼라 서브쿼리 2회
SELECT
  c.cust_id,
  (SELECT SUM(s.amount) FROM f_sales s
   WHERE s.cust_id = c.cust_id
     AND s.sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12)) AS amt_12m,
  CASE WHEN (SELECT SUM(s.amount) FROM f_sales s
             WHERE s.cust_id = c.cust_id
               AND s.sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12)) > 100000
       THEN 'VIP' ELSE 'STD' END AS tier_new
FROM d_customer c;

-- (개선) 한번만 계산해서 재사용(코릴레이션 유지)
WITH sales_12m AS (
  SELECT s.cust_id, SUM(s.amount) AS amt_12m
  FROM   f_sales s
  WHERE  s.sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12)
  GROUP  BY s.cust_id
)
SELECT c.cust_id, x.amt_12m,
       CASE WHEN x.amt_12m > 100000 THEN 'VIP' ELSE 'STD' END AS tier_new
FROM   d_customer c
LEFT JOIN sales_12m x ON x.cust_id = c.cust_id;
```

- **효과**: 동일 서브쿼리 2회 → **집계 1회 + 조인 1회**.
- 스칼라 서브쿼리는 **실행시 캐시**가 있지만, **키가 다양**하면 여전히 수천·수만 회 평가가 일어난다.

### `CROSS APPLY`(LATERAL)로 로우별 1회 평가

```sql
-- 로우마다 값이 달라지는 코릴레이티드 계산을 '한번만' 수행하고 재사용
SELECT c.cust_id, a.amt_12m, CASE WHEN a.amt_12m > 1e5 THEN 'VIP' END AS tag
FROM d_customer c
CROSS APPLY (
  SELECT SUM(s.amount) AS amt_12m
  FROM   f_sales s
  WHERE  s.cust_id = c.cust_id
    AND  s.sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12)
) a;
```

- 스칼라 서브쿼리를 **두 번** 쓰는 대신, **한 번 계산한 결과를 옆에서 재사용**.

---

## **집계/정렬** 공통 블록 CSE

### 동일 집계 재사용

```sql
-- (안티패턴) 같은 집계를 두 번
WITH m AS (
  SELECT prod_id, TRUNC(sales_dt,'MM') AS mm, SUM(amount) sum_amt
  FROM f_sales
  GROUP BY prod_id, TRUNC(sales_dt,'MM')
)
SELECT
  (SELECT SUM(sum_amt) FROM m WHERE mm = DATE '2025-01-01') AS jan_amt,
  (SELECT SUM(sum_amt) FROM m WHERE mm = DATE '2025-02-01') AS feb_amt
FROM dual;

-- (개선) 한번 계산 후 피벗/조건으로 재사용
WITH m AS (
  SELECT prod_id, TRUNC(sales_dt,'MM') AS mm, SUM(amount) sum_amt
  FROM f_sales
  GROUP BY prod_id, TRUNC(sales_dt,'MM')
)
SELECT
  SUM(CASE WHEN mm = DATE '2025-01-01' THEN sum_amt END) AS jan_amt,
  SUM(CASE WHEN mm = DATE '2025-02-01' THEN sum_amt END) AS feb_amt
FROM m;
```

### 공통화

```sql
-- (안티패턴) 같은 정렬을 뷰마다 반복
WITH a AS (SELECT * FROM f_sales ORDER BY sales_dt),
     b AS (SELECT * FROM f_sales ORDER BY sales_dt)
SELECT /* ... */ FROM a JOIN b ON a.prod_id = b.prod_id;

-- (개선) 한번 정렬한 결과를 여러 용도로 사용하도록 작성(가능하면 윈도/인덱스로 대체)
WITH sorted AS (
  SELECT * FROM f_sales ORDER BY sales_dt
)
SELECT /* ... */ FROM sorted s1
JOIN sorted s2 ON s1.prod_id = s2.prod_id;
```

> 실제로 옵티마이저가 **정렬을 공유**하진 않을 수 있으나, 동일한 정렬을 **두 번 유발하는 패턴을 회피**하는 것이 핵심.

---

## **조인** 공통 부분 CSE (Join Factorization)

### `UNION ALL` 분기들의 공통 조인/필터 뽑아내기

```sql
-- (안티패턴) 두 분기 모두 d_product와 같은 조건으로 조인
SELECT s.sales_id
FROM f_sales s
JOIN d_product p ON p.prod_id = s.prod_id
WHERE p.category='ELEC' AND s.sales_dt >= DATE '2025-02-01'
UNION ALL
SELECT s.sales_id
FROM f_sales s
JOIN d_product p ON p.prod_id = s.prod_id
WHERE p.category='ELEC' AND s.sales_dt < DATE '2025-02-01';

-- (개선) 공통 부분(제품 ELEC)을 먼저 추려서 재사용
WITH elec AS (
  SELECT p.prod_id
  FROM   d_product p
  WHERE  p.category='ELEC'
)
SELECT s.sales_id
FROM   f_sales s
JOIN   elec e ON e.prod_id = s.prod_id
WHERE  s.sales_dt >= DATE '2025-02-01'
UNION ALL
SELECT s.sales_id
FROM   f_sales s
JOIN   elec e ON e.prod_id = s.prod_id
WHERE  s.sales_dt < DATE '2025-02-01';
```

- **효과**: `d_product` 접근/필터를 **1회**로 줄이고, **프로브 대상**을 일찍 축소.
- 옵티마이저가 자동으로 **Join Factorization**을 하기도 하지만, **명시적 팩터링**이 더 예측 가능.

### 차원 조인 다중 사용

```sql
-- (안티패턴) 사실 s1, s2 각각 d_date와 같은 조인조건 반복
WITH s1 AS (SELECT * FROM f_sales WHERE qty > 0),
     s2 AS (SELECT * FROM f_sales WHERE amount > 0)
SELECT /* ... */
FROM s1 JOIN d_date d1 ON d1.dt = s1.sales_dt AND d1.yyyymm='202502'
JOIN s2 JOIN d_date d2 ON d2.dt = s2.sales_dt AND d2.yyyymm='202502';

-- (개선) 2월 날짜를 미리 팩터링
WITH d_202502 AS (
  SELECT dt FROM d_date WHERE yyyymm='202502'
)
SELECT /* ... */
FROM s1 JOIN d_202502 d1 ON d1.dt = s1.sales_dt
JOIN s2 JOIN d_202502 d2 ON d2.dt = s2.sales_dt;
```

- 공통 차원 필터를 **한 군데**에서 적용해 **캐시/프루닝**에 유리.

---

## OR Expansion과의 시너지: 공통 부분을 밖으로

OR 확장(분기화) 뒤, **분기마다 반복되는 공통식**을 **한 번만** 수행하도록 팩터링.

```sql
-- OR 확장 + 공통 팩터링
WITH elec AS ( SELECT prod_id FROM d_product WHERE category='ELEC' )
SELECT /* 분기1 */ COUNT(*)
FROM   f_sales s JOIN elec e ON e.prod_id = s.prod_id
WHERE  s.sales_dt BETWEEN DATE '2025-02-01' AND DATE '2025-02-28'
UNION ALL
SELECT /* 분기2 */ COUNT(*)
FROM   f_sales s JOIN elec e ON e.prod_id = s.prod_id
WHERE  s.sales_dt BETWEEN DATE '2025-01-01' AND DATE '2025-01-31';
```

- `elec` 팩터는 **두 분기 공통**이므로 **1회** 평가(머터리얼라이즈되면 재사용).
- 필요 시 힌트로 제어:
  ```sql
  WITH /*+ QB_NAME(eqb) */ elec AS (SELECT /*+ MATERIALIZE */ prod_id FROM d_product WHERE category='ELEC')
  ...
  ```

---

## `WITH`(CTE) — **INLINE vs MATERIALIZE** 전략

- 기본적으로 Oracle은 CTE를 **병합(INLINE)** 하거나 **머터리얼라이즈**를 선택한다.
- **병합(INLINE)**: 공통식을 **각 사용처로 흩뿌려** 더 많은 변환(뷰 머징/푸시다운)이 가능.
  - 장점: 추가 최적화 여지 ↑
  - 단점: **중복 평가**가 다시 생길 수 있음
- **머터리얼라이즈**: CTE를 **한 번 실행→TEMP/메모리에 저장→재사용**
  - 장점: **중복 제거 확실**, 큰 조인·정렬의 **1회화**
  - 단점: **스풀/Temp I/O**가 추가될 수 있음

**힌트 예시**

```sql
WITH /*+ QB_NAME(dq) */
elec AS (
  SELECT /*+ MATERIALIZE */ prod_id
  FROM   d_product
  WHERE  category='ELEC'
)
SELECT /*+ NO_MERGE(elec) */ s.*
FROM   f_sales s JOIN elec e ON e.prod_id = s.prod_id;
```

또는 반대로:
```sql
WITH x AS (SELECT ... )
SELECT /*+ INLINE */ ... FROM x;
```

> **가이드**: 공통식이 **무겁고** 사용처가 **다수**면 `MATERIALIZE` 쪽이 유리.
> 가벼운 공통식·추가 변환 이득이 크면 `INLINE`.

---

## RESULT CACHE / 결정성 함수와 조합

### 비상수 무거운 스칼라 함수

```sql
CREATE OR REPLACE FUNCTION fx_rate(p_ccy VARCHAR2)
RETURN NUMBER
RESULT_CACHE RELIES_ON (fx_table)  -- 레이트 변경 테이블에 의존
IS
  v NUMBER;
BEGIN
  SELECT rate INTO v FROM fx_table WHERE ccy = p_ccy;
  RETURN v;
END;
/

-- (재사용) 같은 통화코드는 결과캐시 히트
SELECT amount * fx_rate('USD') AS amt_usd FROM f_sales WHERE ...;
```

- **주의**: `DETERMINISTIC`는 **함수의 입력만**으로 결과가 결정된다는 개발자 **서약**이다. 잘못 쓰면 **데이터 불일치**.

### 비상관 서브쿼리 결과 캐시

```sql
-- (안티패턴) 비용 큰 비상관 서브쿼리 반복
SELECT (SELECT COUNT(*) FROM f_sales WHERE sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'),-12)) AS c12m
FROM   dual CONNECT BY LEVEL <= 1000;

-- (개선) WITH + MATERIALIZE (1회계산)
WITH cnt AS (
  SELECT /*+ MATERIALIZE */ COUNT(*) AS c12m
  FROM f_sales
  WHERE sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'),-12)
)
SELECT c.c12m FROM cnt c CONNECT BY LEVEL <= 1000;
```

---

## 관찰/검증: “정말 한 번만?”을 확인하는 방법

1) **실측 실행계획**
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL, 'ALLSTATS LAST +ALIAS +PREDICATE +NOTE'));
```
- 공통 블록이 **한 번만 스캔/정렬/집계**되는지, `TEMP`/`VIEW` 노드, `PX` 사용 등 확인.

2) **세션 통계**
```sql
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN (
  'session logical reads','consistent gets','physical reads','sorts (memory)','sorts (disk)'
);
```
- CSE 전/후 **논리/물리 읽기, 정렬 횟수** 비교.

3) **시간/대기 이벤트**
- `SQL Monitor`/`ASH`로 소트/해시/Temp I/O 감소 여부 확인.

---

## 상황별 예제 모음

### **같은 컬럼 가공**을 반복 사용하는 리포트

```sql
-- Before
SELECT
  SUBSTR(p.brand,1,3) AS brand3,
  COUNT(CASE WHEN SUBSTR(p.brand,1,3)='SAMS' THEN 1 END) AS cnt_sams,
  COUNT(CASE WHEN SUBSTR(p.brand,1,3)='APPL' THEN 1 END) AS cnt_appl
FROM d_product p
GROUP BY SUBSTR(p.brand,1,3);

-- After (공통화)
WITH b AS (
  SELECT SUBSTR(p.brand,1,3) AS brand3 FROM d_product p
)
SELECT
  b.brand3,
  COUNT(CASE WHEN b.brand3='SAMS' THEN 1 END) AS cnt_sams,
  COUNT(CASE WHEN b.brand3='APPL' THEN 1 END) AS cnt_appl
FROM b
GROUP BY b.brand3;
```

### **스칼라 서브쿼리** 2회→1회

```sql
-- Before
SELECT c.cust_id,
       (SELECT MAX(s.sales_dt) FROM f_sales s WHERE s.cust_id=c.cust_id) AS last_dt,
       CASE WHEN (SELECT MAX(s.sales_dt) FROM f_sales s WHERE s.cust_id=c.cust_id) >= ADD_MONTHS(TRUNC(SYSDATE,'MM'),-1)
            THEN 'ACTIVE' ELSE 'DORMANT' END AS status
FROM d_customer c;

-- After
WITH last_sale AS (
  SELECT cust_id, MAX(sales_dt) AS last_dt
  FROM f_sales
  GROUP BY cust_id
)
SELECT c.cust_id, l.last_dt,
       CASE WHEN l.last_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'),-1) THEN 'ACTIVE' ELSE 'DORMANT' END AS status
FROM d_customer c
LEFT JOIN last_sale l ON l.cust_id = c.cust_id;
```

### **UNION ALL 분기**의 공통 조인 팩터링

```sql
-- Before
SELECT s.sales_id
FROM f_sales s JOIN d_customer c ON c.cust_id=s.cust_id
WHERE c.region='KOR' AND s.amount>10000
UNION ALL
SELECT s.sales_id
FROM f_sales s JOIN d_customer c ON c.cust_id=s.cust_id
WHERE c.region='KOR' AND s.qty>=3;

-- After (공통 region='KOR' 먼저)
WITH kor AS (
  SELECT cust_id FROM d_customer WHERE region='KOR'
)
SELECT s.sales_id
FROM f_sales s JOIN kor k ON k.cust_id=s.cust_id
WHERE s.amount>10000
UNION ALL
SELECT s.sales_id
FROM f_sales s JOIN kor k ON k.cust_id=s.cust_id
WHERE s.qty>=3;
```

### **선택적 파라미터** + CSE (NVL/DECODE 제거와 병행)

```sql
-- Before (SARGABLE 깨짐 + 중복 계산)
WHERE (NVL(:p_brand, p.brand) = p.brand)
  AND ( :lo IS NULL OR s.sales_dt >= :lo )
  AND ( :hi IS NULL OR s.sales_dt <  :hi )

-- After (분기 + 공통 날짜 팩터)
WITH rng AS (
  SELECT :lo AS lo, :hi AS hi FROM dual
)
SELECT /*+ USE_CONCAT */
  ...
FROM f_sales s
JOIN d_product p ON p.prod_id=s.prod_id
JOIN rng
WHERE (:p_brand IS NULL)      AND s.sales_dt >= NVL(rng.lo, DATE '1900-01-01')
                              AND s.sales_dt <  NVL(rng.hi, DATE '9999-12-31')
UNION ALL
SELECT ...
FROM f_sales s
JOIN d_product p ON p.prod_id=s.prod_id
JOIN rng
WHERE (:p_brand IS NOT NULL)  AND p.brand=:p_brand
                              AND s.sales_dt >= NVL(rng.lo, DATE '1900-01-01')
                              AND s.sales_dt <  NVL(rng.hi, DATE '9999-12-31');
```

- 날짜 범위 `rng`는 **두 분기 공통** → CTE로 **1회 관리**.

---

## 주의 사항(함정과 한계)

1. **머터리얼라이즈 오버헤드**: 공통식이 **작고 가벼운데** 강제로 `MATERIALIZE`하면 **스풀/Temp I/O**만 늘 수 있다.
2. **뷰 머징과의 상호작용**: CTE를 너무 많이 쪼개면 옵티마이저가 **머징/푸시다운**을 못해 **카디널리티**가 악화.
3. **외부조인 의미 보존**: 공통식을 밖으로 끌어낼 때 **NULL 보존**이 깨질 수 있다(LEFT/RIGHT/FULL OUTER).
4. **중복/Distinct 비용**: `UNION ALL`로 분기 중복이 생기면 `UNION`으로 바꿔 중복 제거해야 하는데, 이 경우 **정렬/해시** 비용이 발생.
5. **DETERMINISTIC 남용 금지**: 입력 외부의 숨은 상태에 의존하는 함수를 결정성으로 표시하면 **데이터 불일치** 위험.
6. **스칼라 서브쿼리 캐시 과신 금지**: 키 다양성이 큰 데이터에서는 캐시 히트율이 낮아 **CSE 수동화**가 더 낫다.

---

## 체크리스트

- [ ] 같은 함수/표현식이 **반복**되는가? → **별칭/CTE**로 1회 계산
- [ ] 같은 **스칼라 서브쿼리**를 여러 번 호출하는가? → CTE/`CROSS APPLY`로 1회
- [ ] `UNION ALL` 분기들에 **공통 조인/필터**가 있는가? → **조인 팩터링**
- [ ] CTE는 **INLINE vs MATERIALIZE** 중 어느 쪽이 유리한가? (힌트로 제어)
- [ ] NVL/DECODE로 **선택적 조건**을 만들었는가? → OR 분기화 + 공통식 CTE
- [ ] 실행계획/세션 통계로 **정말 1회**인지 확인했는가?
- [ ] 외부조인/중복/정렬 등 **의미 보존**을 검토했는가?

---

## 미니 벤치 루틴 (전/후 비교)

```sql
-- 1) 통계 스냅샷
SELECT sn.name, ms.value
FROM v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE sn.name IN ('session logical reads','physical reads','sorts (memory)','sorts (disk)');

-- 2) Before 쿼리 실행

-- 3) After(CSE 적용) 쿼리 실행

-- 4) 실행계획
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +ALIAS +NOTE'));
```

**목표**: 논리/물리 읽기·정렬 감소, 공통 블록의 **1회 수행** 확인.

---

### 맺음말

- CSE는 “**중복 제거**”라는 가장 단순한 원칙으로 **현실 성능을 크게 바꾸는** 실전 무기다.
- **CTE/조인 팩터링/OR 확장**을 적절히 결합하고, `INLINE/MATERIALIZE`를 **상황에 맞게** 사용하라.
- 마지막은 항상 **증거 기반**: 실행계획과 세션 통계로 **정말 한 번만 했는지** 확인하자.
