---
layout: post
title: DB 심화 - 공통 표현식 제거
date: 2025-11-21 14:25:23 +0900
category: DB 심화
---
# 공통 표현식 제거 (Common Subexpression Elimination, CSE)

## 왜 CSE인가? 동기와 직관

반복적으로 수행되는 동일한 연산, 서브쿼리, 조인은 불필요한 CPU 사용량, 논리적 읽기, 그리고 래치 경합을 증가시키고 캐시 지역성을 저하시킵니다. CSE는 이러한 비효율을 해결하기 위해 중복된 계산을 식별하고, 단 한 번만 수행하여 그 결과를 재사용하는 최적화 기법입니다.

**직관적 이해**
원래의 비용은 공통 표현식을 반복 평가하는 횟수에 비례합니다. CSE를 적용하면 비싼 평가를 한 번만 수행하고, 그 후에는 상대적으로 저렴한 재사용 과정만 거치게 됩니다.
$$
\text{원래 비용} \approx N \cdot \text{cost}(\text{공통식}) \quad\rightarrow\quad
\text{CSE 적용 비용} \approx \text{cost}(\text{1회 평가}) + N \cdot \text{cost}(\text{재사용})
$$

---

## Oracle에서 CSE를 구현하는 주요 방법

Oracle에서는 여러 레버를 조합하여 CSE를 달성할 수 있습니다.

1.  **서브쿼리 팩터링 (WITH 절, CTE)**: `WITH` 절을 사용해 공통된 계산 블록을 정의하고 여러 곳에서 참조합니다. 옵티마이저는 이 CTE를 상황에 따라 인라인 병합(`INLINE`)하거나, 물리적으로 한 번 실행하여 결과를 임시 저장한 후 재사용(`MATERIALIZE`)합니다. `/*+ MATERIALIZE */`, `/*+ INLINE */` 등의 힌트로 제어할 수 있습니다.

2.  **조인 팩터링 (Join Factorization)**: `UNION ALL`로 연결된 여러 분기 쿼리가 동일한 조인이나 필터 조건을 공유할 때, 이 공통 부분을 바깥으로 끌어내어 한 번만 실행하도록 재구성합니다.

3.  **스칼라 서브쿼리 캐싱**: 동일한 입력값(키)에 대한 스칼라 서브쿼리 결과를 실행 시점에 캐싱하여 반복 평가를 줄입니다. 단, 입력 키의 다양성이 매우 높으면 캐시 효율이 떨어질 수 있습니다.

4.  **함수 결과 캐싱**: 비용이 큰 함수 호출을 최적화하기 위해 `DETERMINISTIC` 키워드나 `RESULT_CACHE` 기능을 활용해 결과를 캐싱할 수 있습니다.

5.  **뷰 병합 (View Merging)**: 쿼리 내에서 동일한 인라인 뷰나 서브쿼리가 여러 번 사용될 경우, 옵티마이저가 이를 한 번만 계산하도록 병합할 수 있습니다.

---

## 표현식 수준의 CSE 적용

### 반복되는 함수/표현식 계산 줄이기

동일한 열 변환 또는 계산식을 SELECT 절, WHERE 절, GROUP BY 절 등에서 반복 사용하는 경우가 많습니다. 이를 공통 표현식으로 추출하면 평가 횟수를 획기적으로 줄일 수 있습니다.

```sql
-- (개선 전) TO_CHAR 함수가 3번 반복 평가됩니다.
SELECT
  TO_CHAR(s.sales_dt, 'YYYYMM') AS yyyymm,
  SUM(CASE WHEN TO_CHAR(s.sales_dt,'YYYYMM') = :p_mm THEN s.amount END) AS sum_this_mm
FROM f_sales s
GROUP BY TO_CHAR(s.sales_dt,'YYYYMM')
ORDER BY TO_CHAR(s.sales_dt,'YYYYMM');

-- (개선 후) CTE를 사용해 TO_CHAR 함수를 1번만 평가하고 그 결과를 재사용합니다.
WITH sales_with_mm AS (
  SELECT s.*,
         TO_CHAR(s.sales_dt,'YYYYMM') AS yyyymm -- 공통 표현식 1회 계산
  FROM f_sales s
)
SELECT
  yyyymm,
  SUM(CASE WHEN yyyymm = :p_mm THEN amount END) AS sum_this_mm
FROM sales_with_mm
GROUP BY yyyymm
ORDER BY yyyymm;
```
**추가 팁**: 이 `yyyymm` 표현식이 자주 조회 조건으로 사용된다면, 함수 기반 인덱스(`CREATE INDEX ix_fs_mm ON f_sales(TO_CHAR(sales_dt,'YYYYMM'))`)를 생성하는 것도 고려해보세요.

### 윈도우 함수의 공통 정렬/파티션 제거

동일한 `PARTITION BY`와 `ORDER BY` 절을 가진 여러 윈도우 함수가 있다면, 이를 공통화하여 불필요한 정렬 연산을 방지할 수 있습니다.

```sql
-- (개선 전) cust_id와 sales_dt 기준으로 두 번 정렬이 발생할 수 있습니다.
SELECT
  s.*,
  SUM(s.amount) OVER (PARTITION BY s.cust_id ORDER BY s.sales_dt) AS run_sum,
  AVG(s.amount) OVER (PARTITION BY s.cust_id ORDER BY s.sales_dt) AS run_avg
FROM f_sales s;

-- (개선 후) 공통 윈도우 프레임을 가진 하나의 계산을 먼저 수행하고,
-- 이를 바탕으로 다른 집계를 (근사치로) 유도할 수 있습니다.
WITH base_window AS (
  SELECT s.*,
         SUM(s.amount) OVER (PARTITION BY s.cust_id ORDER BY s.sales_dt) AS run_sum,
         COUNT(s.amount) OVER (PARTITION BY s.cust_id ORDER BY s.sales_dt) AS run_cnt
  FROM f_sales s
)
SELECT *,
       run_sum / NULLIF(run_cnt, 0) AS run_avg_approx -- AVG 대신 SUM/COUNT 사용
FROM base_window;
```
**주의**: 정확한 `AVG`를 구하는 것과 `SUM/COUNT`로 계산하는 것은 NULL 처리 등에서 미묘한 차이가 있을 수 있습니다. 가장 안전한 CSE는 동일한 윈도우 명세를 가진 함수를 SELECT 리스트에서 별칭으로 재사용하는 것입니다. (e.g., `run_sum`을 두 번 참조)

---

## 스칼라 서브쿼리의 CSE

### 중복된 코릴레이티드 스칼라 서브쿼리 제거

로우마다 실행되는 코릴레이티드 스칼라 서브쿼리는 성능 병목의 주범이 될 수 있습니다. 특히 동일한 서브쿼리가 하나의 로우에서 두 번 이상 호출된다면, 그 비용은 두 배가 됩니다.

```sql
-- (개선 전) 12개월 매출 합계를 구하는 동일한 서브쿼리가 2번 수행됩니다.
SELECT
  c.cust_id,
  (SELECT SUM(s.amount) FROM f_sales s
   WHERE s.cust_id = c.cust_id
     AND s.sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12)) AS amt_12m,
  CASE WHEN (SELECT SUM(s.amount) FROM f_sales s
             WHERE s.cust_id = c.cust_id
               AND s.sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12)) > 100000
       THEN 'VIP' ELSE 'STD' END AS tier
FROM d_customer c;

-- (개선 후) 서브쿼리를 CTE로 분리하여 각 고객별로 1번만 집계한 후 조인합니다.
WITH sales_last_12m AS (
  SELECT s.cust_id, SUM(s.amount) AS amt_12m
  FROM   f_sales s
  WHERE  s.sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12)
  GROUP  BY s.cust_id
)
SELECT c.cust_id,
       sl.amt_12m,
       CASE WHEN sl.amt_12m > 100000 THEN 'VIP' ELSE 'STD' END AS tier
FROM   d_customer c
LEFT JOIN sales_last_12m sl ON sl.cust_id = c.cust_id; -- 1회 조인으로 해결
```

### LATERAL 조인(CROSS APPLY)을 활용한 CSE

Oracle 12c부터 지원하는 `LATERAL` 조인(또는 `CROSS APPLY`)은 로우별 연관된 서브쿼리 결과를 안전하게 추출하고 재사용하는 데 유용합니다.

```sql
-- 동일한 코릴레이티드 서브쿼리 로직을 LATERAL 블록 내에서 1번만 정의하고,
-- 그 결과(amt_12m)를 메인 쿼리에서 여러 번 참조합니다.
SELECT c.cust_id,
       lat.amt_12m,
       CASE WHEN lat.amt_12m > 100000 THEN 'VIP' END AS tag
FROM d_customer c
CROSS APPLY (
  SELECT SUM(s.amount) AS amt_12m
  FROM   f_sales s
  WHERE  s.cust_id = c.cust_id
    AND  s.sales_dt >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12)
) lat;
```

---

## 조인 공통 부분의 CSE (조인 팩터링)

### UNION ALL 분기 간의 공통 조인 추출

여러 `UNION ALL` 분기가 정확히 동일한 테이블과 동일한 조건으로 조인을 수행한다면, 이 공통 조인 부분을 바깥으로 빼내어 한 번만 실행하게 할 수 있습니다.

```sql
-- (개선 전) d_product와의 'ELEC' 카테고리 조인이 두 분기 모두에 중복됩니다.
SELECT s.sales_id
FROM f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE p.category='ELEC' AND s.sales_dt >= DATE '2025-02-01'
UNION ALL
SELECT s.sales_id
FROM f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE p.category='ELEC' AND s.sales_dt < DATE '2025-02-01';

-- (개선 후) 'ELEC' 제품 목록을 미리 추출(팩터링)하여 두 분기에서 재사용합니다.
WITH elec_products AS (
  SELECT prod_id
  FROM   d_product
  WHERE  category='ELEC' -- 공통 필터 조건 1회 적용
)
SELECT s.sales_id
FROM   f_sales s JOIN elec_products ep ON ep.prod_id = s.prod_id
WHERE  s.sales_dt >= DATE '2025-02-01'
UNION ALL
SELECT s.sales_id
FROM   f_sales s JOIN elec_products ep ON ep.prod_id = s.prod_id
WHERE  s.sales_dt < DATE '2025-02-01';
```
이 방법은 특히 공통 조인 대상 테이블이 크거나, 조인 조건이 복잡할 때 큰 성능 향상을 가져옵니다. 옵티마이저가 자동으로 이 변환(조인 팩터링)을 수행하기도 하지만, 명시적으로 쿼리를 작성하는 것이 더 예측 가능한 결과를 보장합니다.

---

## WITH 절(CTE)의 인라인 vs. 머티리얼라이즈 전략

CTE는 CSE의 핵심 도구이지만, 그 동작 방식(`INLINE` 또는 `MATERIALIZE`)에 따라 성능이 크게 달라질 수 있습니다. 옵티마이저가 자동으로 선택하지만, 개발자는 힌트를 통해 이를 유도할 수 있습니다.

*   **인라인(`INLINE`)**: CTE 본문을 각 참조 위치에 "붙여넣기" 합니다.
    *   **장점**: 참조 위치별로 최적화(조인 순서 변경, 조건 푸시다운 등)의 기회가 더 많아집니다.
    *   **단점**: CTE 본문이 여러 번 평가되어 중복 계산이 발생할 수 있습니다.
    *   **사용 힌트**: `/*+ INLINE */`

*   **머티리얼라이즈(`MATERIALIZE`)**: CTE를 독립적으로 한 번 실행하고 그 결과를 임시 세그먼트(주로 TEMP 테이블스페이스)에 저장한 후 재사용합니다.
    *   **장점**: 정말로 한 번만 실행되므로 중복 계산이 완전히 제거됩니다. 대규모 정렬이나 집계에 유리합니다.
    *   **단점**: 임시 저장 공간 사용과 I/O 오버헤드가 발생할 수 있습니다. 인라인 시 가능했던 개별 최적화 기회를 잃을 수 있습니다.
    *   **사용 힌트**: `/*+ MATERIALIZE */`

**적용 가이드라인**:
*   **CTE가 가볍고(소량 데이터), 여러 번 참조되더라도** -> `INLINE`이 일반적으로 유리합니다.
*   **CTE가 무겁고(대규모 조인/집계/정렬), 2회 이상 참조된다면** -> `MATERIALIZE`를 시도해보세요.
*   CTE 결과가 매우 작아 메모리에 캐시되면 `MATERIALIZE`의 I/O 오버헤드는 무시할 수 있습니다.

```sql
-- 머티리얼라이즈 힌트 사용 예시
WITH /*+ MATERIALIZE */ heavy_computation AS (
  SELECT ... -- 대용량 데이터의 복잡한 집계
)
SELECT ... FROM heavy_computation hc1
UNION ALL
SELECT ... FROM heavy_computation hc2;
```

---

## 주의사항 및 검증 방법

### 잠재적인 함정

1.  **과도한 머티리얼라이즈**: 작은 결과셋을 가진 간단한 CTE를 강제로 머티리얼라이즈하면 임시 공간 I/O 오버헤드만 추가될 수 있습니다.
2.  **의미 변경**: 공통 부분을 추출할 때, 특히 외부 조인(`OUTER JOIN`)이 관련된 경우 원래 쿼리의 논리적 의미가 손상되지 않았는지 꼼꼼히 검증해야 합니다.
3.  **옵티마이저 제한**: CTE를 사용함으로써 옵티마이저가 원본 테이블의 통계 정보를 직접 활용하거나 조인 순서를 유연하게 변경하는 데 제약이 생길 수 있습니다.
4.  **함수 결정성 오용**: `DETERMINISTIC` 함수는 동일 입력에 대해 항상 동일 출력을 반환해야 합니다. 시스템 상태나 다른 테이블 데이터에 의존하는 함수에 이 키워드를 사용하면 심각한 데이터 불일치를 초래합니다.

### 성능 개선 효과 검증

CSE 최적화가 실제로 효과가 있었는지 확인하는 것은 필수입니다.

1.  **실행 계획 분석**:
    ```sql
    SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL, 'ALLSTATS LAST +NOTE +ALIAS'));
    ```
    *   `VIEW` 또는 `TEMPORARY TABLE` 연산자가 나타나는지 확인 (CTE 머티리얼라이즈 증거).
    *   동일한 `VIEW`나 `TABLE` 접근이 **한 번만** 스캔(`Starts` 컬럼 값이 1)되는지 확인.

2.  **세션 통계 비교**:
    ```sql
    -- 최적화 전후로 아래 쿼리를 실행하여 값 차이를 비교합니다.
    SELECT sn.name, ms.value
    FROM   v$mystat ms
    JOIN   v$statname sn ON sn.stat# = ms.stat#
    WHERE  sn.name IN ('session logical reads', 'physical reads', 'sorts (memory)', 'sorts (disk)');
    ```
    *   `session logical reads`(논리적 읽기)와 `sorts`(정렬 횟수)의 감소를 중점적으로 확인합니다.

---

## 결론

공통 표현식 제거(CSE)는 "반복되는 일은 한 번만 하라"는 단순하지만 강력한 원칙을 기반으로 합니다. Oracle 환경에서는 `WITH` 절(CTE)을 활용한 서브쿼리 팩터링이 가장 실용적이고 효과적인 접근법입니다. 이때, CTE의 평가 전략(`INLINE` vs `MATERIALIZE`)을 쿼리의 특성(데이터 양, 참조 횟수, 연산 비용)에 맞게 선택하는 것이 핵심입니다.

또한, 조인 팩터링을 통한 `UNION ALL` 최적화, `LATERAL` 조인 활용, 함수 결과 캐싱 등 다른 기법들과 조합하면 성능 최적화의 시너지를 낼 수 있습니다. 모든 최적화는 **가정이 아닌 측정**을 바탕으로 해야 합니다. 변경된 쿼리의 실행 계획과 시스템 통계를 꼼꼼히 비교하여, CSE가 예상대로 중복 작업을 제거하고 전체 실행 비용을 낮췄음을 입증하는 것이 마지막이자 가장 중요한 단계입니다.