---
layout: post
title: MFC - 테스트/CI
date: 2025-09-22 21:25:23 +0900
category: MFC
---
# 테스트/CI 완전 가이드  
**gtest + WinAppDriver(UI 자동화)·Appium, CMake+vcpkg 표준화, GitHub Actions/Dev Drive(유사) 캐시 최적화**

> 목표: **단위 → 통합 → UI(엔드투엔드)** 계층 테스트를 CMake 기반으로 표준화하고,  
> Windows CI(특히 GitHub Actions)에서 **빠르고 재현 가능한** 빌드·테스트 파이프라인을 구축한다.

---

## 0. 큰 그림(아키텍처)

```
[코어 라이브러리] — gtest 단위 테스트 (빠름)
      │
      ├─ [네이티브 서비스/모듈] — gtest + 통합 테스트 (파일/네트워크/DB)
      │
      └─ [GUI(MFC/Win32/WPF 등)] — WinAppDriver/Appium UI 자동화 (느리지만 가치 큼)

[도구 체인] CMake + vcpkg(manifest) 표준화
[CI] GitHub Actions (Windows 최신 이미지) + 캐시( vcpkg/binary caching + 빌드 캐시(sccache) + CMake ccache-like )
```

핵심 원칙  
- **테스트 피라미드**: 단위(다수, 수초) → 통합(중간) → UI(E2E, 소수·가치 큰 시나리오)  
- **동일한 CMake 엔트리**로 **개발자 PC/CI**의 명령이 같아야 유지보수 쉬움  
- **캐시 전략**: 패키지(vcpkg), 컴파일(sccache), CMake 생성물, 테스트 아티팩트(로그/스크린샷)  
- **플레이키(Flaky) 방지**: UI 테스트는 **격리/재시도/타임아웃/진단 수집** 필수

---

# 1. gtest: 단위·통합 테스트 표준 템플릿

## 1.1 CMake + vcpkg(Manifest)로 gtest 가져오기

프로젝트 루트 `vcpkg.json`:
```json
{
  "name": "myapp",
  "version-string": "1.0.0",
  "builtin-baseline": "6f8f2a7b... (vcpkg-commit)",
  "dependencies": [
    "gtest",
    "fmt",
    "spdlog"
  ]
}
```

루트 `CMakeLists.txt` (핵심만):
```cmake
cmake_minimum_required(VERSION 3.24)
project(MyApp LANGUAGES CXX)

# vcpkg(manifest) 자동: CMake가 VCPKG_ROOT 또는 toolchain을 감지
# (CI에서는 -DCMAKE_TOOLCHAIN_FILE=%VCPKG_ROOT%/scripts/buildsystems/vcpkg.cmake 권장)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 코어 라이브러리
add_library(core STATIC
    src/core/math.cpp
    src/core/io.cpp
    include/core/math.hpp
    include/core/io.hpp)
target_include_directories(core PUBLIC include)
target_link_libraries(core PUBLIC fmt::fmt spdlog::spdlog)

# gtest 테스트
enable_testing()
add_executable(core_tests
    tests/core_math_tests.cpp
    tests/core_io_tests.cpp)
target_link_libraries(core_tests PRIVATE core GTest::gtest GTest::gtest_main)
gtest_discover_tests(core_tests) # CTest와 자동 연동
```

로컬 빌드:
```powershell
# PowerShell
$env:VCPKG_ROOT="C:\dev\vcpkg"   # 로컬 설치 경로
cmake -S . -B build -DCMAKE_TOOLCHAIN_FILE="$env:VCPKG_ROOT\scripts\buildsystems\vcpkg.cmake" -DCMAKE_BUILD_TYPE=Release
cmake --build build --config Release --parallel
ctest --test-dir build --output-on-failure -C Release
```

## 1.2 기본 테스트 예제

`tests/core_math_tests.cpp`
```cpp
#include <gtest/gtest.h>
#include "core/math.hpp"

TEST(Math, Add) {
    EXPECT_EQ(add(2,3), 5);
    EXPECT_NE(add(-1,1), 3);
}

TEST(Math, DivZeroThrows) {
    EXPECT_THROW(div(10,0), std::runtime_error);
}
```

`src/core/math.cpp`
```cpp
#include "core/math.hpp"
#include <stdexcept>
int add(int a,int b){ return a+b; }
int div(int a,int b){ if(!b) throw std::runtime_error("div0"); return a/b; }
```

## 1.3 통합 테스트(파일/네트워크)

- **임시 디렉터리**: 테스트마다 고유 폴더 생성/삭제  
- **환경 가드**: 네트워크 의존은 **연결 가능 여부** 먼저 검사 → **GTEST_SKIP()**로 조건부 스킵

샘플:
```cpp
#include <gtest/gtest.h>
#include <filesystem>
#include "core/io.hpp"

class FileFixture : public ::testing::Test {
protected:
    std::filesystem::path dir;
    void SetUp() override {
        dir = std::filesystem::temp_directory_path() / std::filesystem::path("myapp_test_") / std::to_wstring(::GetCurrentProcessId());
        std::filesystem::create_directories(dir);
    }
    void TearDown() override {
        std::error_code ec; std::filesystem::remove_all(dir, ec);
    }
};

TEST_F(FileFixture, WriteReadRoundtrip) {
    auto p = dir / "data.bin";
    std::vector<uint8_t> src(1024, 0xAB);
    ASSERT_TRUE(write_binary(p, src));
    auto round = read_binary(p);
    ASSERT_EQ(round.size(), src.size());
    EXPECT_EQ(round, src);
}
```

---

# 2. WinAppDriver + Appium: Windows UI 자동화(E2E)

## 2.1 무엇을 언제 쓰나?

- **WinAppDriver(Windows Application Driver)**:  
  - Windows 10+의 **UI Automation**을 WebDriver 프로토콜로 노출.  
  - (2025 기준) **Appium**과 함께 쓰는 것이 일반적(세션 라이프사이클/리트라이/리포팅 등 편리).

- **Appium**: 멀티 플랫폼(Web/Android/iOS/Windows) 자동화 허브.  
  - `appium-windows-driver`가 WinAppDriver에 의존하거나 통합된 드라이버를 사용.

**권장 구조**
- 로컬/CI에서 **Appium Server** 실행 → **Windows Driver** 활성화  
- 테스트는 **WebDriver 클라이언트(C#·Java·Python·JS 중 하나)** 로 작성  
  - 아래는 **C#** 예시(Windows 환경과 궁합이 좋고, UIA Locator가 풍부)

## 2.2 Appium + Windows Driver 설치

Node 기반(Appium v2):
```powershell
npm i -g appium
appium driver install windows
appium --drivers
# -> windows 드라이버가 보이면 OK
```

Appium 서버 기동:
```powershell
appium --use-plugins=element-wait
# or 특정 포트: appium -p 4723
```

> WinAppDriver 단독 실행 방식도 있으나, **Appium v2 + windows-driver** 조합이 관리가 수월합니다.

## 2.3 테스트 대상 앱 가이드(MFC/Win32)

- **AutomationProperties.Name** / **AutomationId** 역할을 하는 **컨트롤 식별자**가 필요  
  - MFC라면 **컨트롤 텍스트/리소스 ID**를 적절히 노출  
  - 복잡한 커스텀 컨트롤은 **UIA Tree** 상에서 `Name`, `ClassName`, `ControlType` 로 구분 가능  
- **의존 서비스/파일 경로**는 테스트 시작 시 **인메모리/임시 폴더**로 설정  
- **첫 실행 마법사/업데이트 팝업** 같은 **비결정 요소 제거 플래그** 제공

## 2.4 C# 샘플 (Appium.Windows)

`dotnet add package Appium.WebDriver`
```csharp
using System;
using OpenQA.Selenium.Appium;
using OpenQA.Selenium.Appium.Windows;
using OpenQA.Selenium.Support.UI;

class UiSmoke
{
    static void Main()
    {
        var opts = new AppiumOptions();
        opts.PlatformName = "Windows";
        // 앱 실행: app: exe 경로, 또는 기존 프로세스에 연결: appTopLevelWindow
        opts.AddAdditionalCapability("app", @"C:\build\bin\MyApp.exe");
        // 옵션: newCommandTimeout, ms: 최대 대기
        opts.AddAdditionalCapability("newCommandTimeout", 120);

        using var drv = new WindowsDriver<WindowsElement>(new Uri("http://127.0.0.1:4723"), opts);
        drv.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(2);

        var wait = new WebDriverWait(drv, TimeSpan.FromSeconds(10));

        // 예: 메뉴 → 파일 열기 → 텍스트 입력 → 버튼 클릭 → 결과 레이블 검증
        var btnOpen = wait.Until(d => d.FindElementByName("열기(&O)...")); // 메뉴/버튼 이름
        btnOpen.Click();

        var dlg = drv.SwitchTo().Window(drv.WindowHandles[0]); // 최신 창
        var editPath = drv.FindElementByAccessibilityId("1148"); // 공용 파일 대화상자 에디트 AutomationId 예시
        editPath.Clear();
        editPath.SendKeys(@"C:\test\data.txt");

        drv.FindElementByName("열기").Click();

        var resultLabel = wait.Until(d => d.FindElementByAccessibilityId("IDC_STATIC_RESULT"));
        Console.WriteLine("Result: " + resultLabel.Text);

        // 스크린샷 저장
        var ss = drv.GetScreenshot();
        ss.SaveAsFile(@"C:\temp\ui_smoke.png", OpenQA.Selenium.ScreenshotImageFormat.Png);
    }
}
```

### 안정성(플레이키) 팁
- **명시적 대기**(WebDriverWait + 조건), **ImplicitWait**는 짧게  
- **재시도 래퍼**: 동일 테스트 1회 재시도 허용  
- 실패 시 **스크린샷/페이지소스(UIA 트리)** 저장  
- CI에서는 **전용 VM**(동시성 1)으로 UI 테스트 실행

---

# 3. CMake + vcpkg 표준화 심화

## 3.1 Manifest 모드 + 버전 고정
- `vcpkg.json`에 `builtin-baseline`(or `vcpkg-configuration.json`의 registry baseline) 고정  
- 팀 전체/CI가 **동일한 포트 버전** 사용 → “우리 PC에서만 안 되는” 상황 감소

`vcpkg-configuration.json` (선택):
```json
{
  "default-registry": {
    "kind": "git",
    "baseline": "6f8f2a7b...",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "baseurl": "https://example.cdn/artifacts",
      "packages": [ "tool:sccache" ]
    }
  ]
}
```

## 3.2 툴체인 일관화
CI/로컬 공통 인자:
```powershell
cmake -S . -B build `
  -DCMAKE_TOOLCHAIN_FILE="$env:VCPKG_ROOT\scripts\buildsystems\vcpkg.cmake" `
  -DVCPKG_FEATURE_FLAGS="manifests" `
  -DVCPKG_OVERLAY_TRIPLETS="%GITHUB_WORKSPACE%\.vcpkg-triplets"  # 필요 시
```

## 3.3 vcpkg Binary Caching
- vcpkg는 **자체 바이너리 캐시** 기능 제공(로컬 디렉터리/HTTP/Azure Blob 등)  
- GitHub Actions의 **cache** 액션과 결합하면 **대부분의 서드파티 빌드 시간 제로에 근접**

로컬 디렉터리 캐시:
```powershell
$env:VCPKG_BINARY_SOURCES="clear;default,readwrite;files,C:\.vcpkg_cache,readwrite"
```

GitHub Actions에서는 `C:\Users\runneradmin\AppData\Local\vcpkg\archives` 경로를 캐시 타깃으로.

---

# 4. GitHub Actions: Windows CI 파이프라인

## 4.1 기본 워크플로(yaml)

`.github/workflows/ci.yml`
{% raw %}
```yaml
name: CI

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  build-test:
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        config: [Release, Debug]
        arch: [x64] # 필요시 x86, arm64 추가
    env:
      VCPKG_ROOT: C:\vcpkg
      VCPKG_DEFAULT_TRIPLET: ${{ matrix.arch }}-windows
      VCPKG_FEATURE_FLAGS: "manifests"
      # vcpkg binary cache (로컬 디렉터리)
      VCPKG_BINARY_SOURCES: "clear;default,readwrite;files,C:\\vcpkg-cache,readwrite"

    steps:
    - uses: actions/checkout@v4

    - name: Setup vcpkg (cache)
      uses: actions/cache@v4
      with:
        path: |
          C:\vcpkg
          C:\vcpkg-cache
        key: vcpkg-${{ runner.os }}-${{ matrix.arch }}-${{ hashFiles('vcpkg.json') }}
    - name: Bootstrap vcpkg if needed
      run: |
        if (!(Test-Path C:\vcpkg)) { git clone https://github.com/microsoft/vcpkg C:\vcpkg }
        if (!(Test-Path C:\vcpkg\vcpkg.exe)) { C:\vcpkg\bootstrap-vcpkg.bat }

    - name: CMake configure
      run: >
        cmake -S . -B build
        -DCMAKE_TOOLCHAIN_FILE=${{ env.VCPKG_ROOT }}\scripts\buildsystems\vcpkg.cmake
        -DCMAKE_BUILD_TYPE=${{ matrix.config }}

    - name: Build
      run: cmake --build build --config ${{ matrix.config }} --parallel

    - name: Test (ctest)
      run: ctest --test-dir build -C ${{ matrix.config }} --output-on-failure
```
{% endraw %}

### 포인트
- **vcpkg + vcpkg-cache** 를 **같은 캐시 키**에 묶으면 재부팅 간에도 유지  
- 키는 `hashFiles('vcpkg.json')`(또는 `**/vcpkg.json`) 로 패키지 변경에만 무효화

## 4.2 sccache(또는 clcache)로 컴파일 캐시

Windows에서 sccache:
```yaml
    - name: Setup sccache
      uses: mozilla-actions/sccache-action@v0.0.3
    - name: Enable sccache (MSVC)
      shell: pwsh
      run: |
        echo "CMAKE_C_COMPILER_LAUNCHER=sccache" >> $env:GITHUB_ENV
        echo "CMAKE_CXX_COMPILER_LAUNCHER=sccache" >> $env:GITHUB_ENV
```

CMake configure에 launcher 반영:
{% raw %}
```yaml
    - name: CMake configure
      run: >
        cmake -S . -B build
        -DCMAKE_TOOLCHAIN_FILE=${{ env.VCPKG_ROOT }}\scripts\buildsystems\vcpkg.cmake
        -DCMAKE_BUILD_TYPE=${{ matrix.config }}
        -DCMAKE_C_COMPILER_LAUNCHER=sccache
        -DCMAKE_CXX_COMPILER_LAUNCHER=sccache
```
{% endraw %}

> **효과**: 동일 코드/옵션 컴파일의 **캐시 적중**으로 빌드 시간 대폭 단축(특히 템플릿 많은 C++).

## 4.3 UI 자동화(WinAppDriver/Appium) 잡

UI 테스트는 별도 잡(동시성 1, 타임아웃 여유)로:
```yaml
  ui-e2e:
    runs-on: windows-latest
    needs: build-test
    timeout-minutes: 30
    steps:
    - uses: actions/checkout@v4

    - name: Restore artifacts (앱 바이너리)
      uses: actions/download-artifact@v4
      with:
        name: app-binaries
        path: app-bin

    - name: Install Node/Appium Windows Driver
      run: |
        npm i -g appium
        appium driver install windows

    - name: Start Appium (background)
      run: Start-Process -FilePath "appium" -ArgumentList "-p 4723" -NoNewWindow

    - name: Run UI tests (dotnet)
      run: |
        dotnet restore ui-tests/UiTests.csproj
        dotnet test ui-tests/UiTests.csproj --logger "trx;LogFileName=ui.trx" -- TestRunParameters.Parameter(name=\"AppPath\",value=\"$(Resolve-Path app-bin/MyApp.exe)\")
      shell: pwsh

    - name: Publish Test Results
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: UI Test Results
        path: "**/*.trx"
        reporter: dotnet-trx

    - name: Upload screenshots on failure
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: ui-screenshots
        path: ui-tests/screenshots
```

> **팁**  
> - `actions/upload-artifact` 로 **스크린샷/로그**를 남겨 디버깅  
> - UI 테스트는 **병렬 1** 권장. 가상 화면 크기(예: 1920x1080) 고정.

---

# 5. “Dev Drive 느낌”의 캐시 최적화

> GitHub Actions의 `windows-latest`는 실제 Dev Drive 기능을 제공하지 않습니다.  
> 하지만 **전용 경로 + 캐시 + sccache + vcpkg binary caching**으로 **유사한 효과**를 얻을 수 있습니다.

전략:
1) **vcpkg**: 바이너리 캐시 디렉터리(`C:\vcpkg-cache`)를 **영속 캐시**  
2) **sccache**: 원격/디스크 캐시 활성(액션 플러그인)  
3) **빌드 아티팩트**: `actions/cache` 대신 **`upload/download-artifact`** 로 **의도적 스냅샷**(빌드 산출물)  
4) CMake **빌드 폴더 재사용**은 **주의**(환경 차이/경로 민감). 대부분은 **클린**이 안전

**추가 최적화**
- MSBuild의 **/m** 병렬, CMake의 `--parallel`  
- 의존 프로젝트는 **Unity/Jumbo build**(가능하면)  
- 큰 리소스 생성(코드 생성기)은 **분리 캐시**(키에 입력 파일 해시 포함)

---

# 6. 품질 게이트/리포팅

- **ctest** 결과를 **JUnit** 등으로 변환(CTest `--output-junit`는 3.29+)  
- **코드 커버리지**(Windows + MSVC는 어려움 → clang-cl + llvm-cov, 또는 OpenCppCoverage)  
- **정적 분석**: `clang-tidy`(CMake preset), `cppcorecheck`(MSVC)  
- **변경 영향 테스트**(Test Impact Analysis)는 자체 스크립트로 “변경된 경로 ↔ 테스트 태그” 매핑

샘플(cmake presets):
```json
{
  "version": 4,
  "configurePresets": [
    {
      "name": "win-clangcl-rel",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/build/rel",
      "cacheVariables": {
        "CMAKE_C_COMPILER": "clang-cl",
        "CMAKE_CXX_COMPILER": "clang-cl",
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_TOOLCHAIN_FILE": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake"
      }
    }
  ]
}
```

---

# 7. 로컬 개발 워크플로

1) 1회:
```powershell
git clone https://github.com/microsoft/vcpkg C:\vcpkg
C:\vcpkg\bootstrap-vcpkg.bat
```

2) 반복:
```powershell
$env:VCPKG_ROOT="C:\vcpkg"
cmake -S . -B build -DCMAKE_TOOLCHAIN_FILE="$env:VCPKG_ROOT\scripts\buildsystems\vcpkg.cmake" -DCMAKE_BUILD_TYPE=Debug
cmake --build build --config Debug --parallel
ctest --test-dir build -C Debug --output-on-failure
```

3) UI 테스트(로컬 Appium):
```powershell
npm i -g appium
appium driver install windows
appium -p 4723
# 다른 콘솔에서:
dotnet test ui-tests/UiTests.csproj
```

---

# 8. 실패를 줄이는 실무 팁 모음

- **테스트 고립**: 임시 폴더/포트/레지스트리 키 **충돌 금지**  
- **시간 의존 제거**: 가짜 시계/고정 타임스탬프  
- **랜덤성**: 시드 고정 + 실패 시 재출력  
- **파일 잠금**: Windows 특성상 핸들 누수 → gtest `--gtest_repeat=2` 로 **두 번 돌려** 잠금 회수 확인  
- **UI 동기화**: UIA의 `IsOffscreen` 플래그, 컨트롤 `Enabled/Visible` 체크 후 액션  
- **리소스 해제**: UI 테스트 종료 시 **프로세스 강제 종료**(좀비 방지)

---

# 9. 예제 리포 구조(추천)

```
/ (repo)
 ├─ CMakeLists.txt
 ├─ vcpkg.json
 ├─ include/core/...
 ├─ src/core/...
 ├─ app/ (GUI 실행파일)
 │   ├─ CMakeLists.txt
 │   └─ src/...
 ├─ tests/
 │   ├─ CMakeLists.txt  # gtest discover
 │   └─ *.cpp
 ├─ ui-tests/
 │   ├─ UiTests.csproj
 │   ├─ Smoke.cs
 │   └─ screenshots/ (출력)
 └─ .github/workflows/ci.yml
```

---

# 10. 트러블슈팅

| 증상 | 원인 | 해결 |
|---|---|---|
| Actions에서 vcpkg가 매번 재빌드 | cache 키 미스 | `hashFiles('**/vcpkg.json')` 로 범위 확대, baseline/lockfile 포함 |
| sccache 미적중 | 컴파일 옵션/경로 다름 | 동일 컴파일러·옵션 유지, 경로 캐노니컬라이즈, PDB 옵션 일치 |
| UI 테스트 불안정 | 대기 부족/포커스 문제 | 명시적 대기, 창 활성화, 해상도 고정, 재시도 래퍼 |
| App 실행이 CI에서 실패 | MSVC 재배포물/VC++런타임 의존 | `actions/setup-msbuild` 또는 Merge Modules, 또는 앱 zip에 `vcruntime` 포함(권장 X) |
| 파일 대화상자 자동화 안됨 | 보안/권한/세션 분리 | 동일 세션에서 실행, 관리자 권장 금지, UAC 팝업 비활성 모드로 테스트 |

---

## 11. 보너스: 재현성 높은 빌드 옵션 팁

- **/Deterministic**(MSVC), **/Z7** + PDB 경로 표준화  
- 경로 절대값 제거: `CMAKE_[C|CXX]_FLAGS`에 `-fdebug-prefix-map`(clang-cl)  
- **CMakePresets.json** 으로 모든 옵션 시전

---

# 마무리

이 가이드를 베이스로 하면:

- gtest를 통한 **빠른 단위/통합 테스트**가 안정적으로 돌아가고,  
- Appium+Windows Driver로 **가치 높은 UI 시나리오**를 소수지만 **확실히** 검증하며,  
- CMake+vcpkg 표준화 및 **캐시 최적화**로 CI 시간을 **현실적인 수준**으로 줄일 수 있습니다.