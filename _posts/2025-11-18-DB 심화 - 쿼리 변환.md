---
layout: post
title: DB 심화 - 쿼리 변환
date: 2025-11-18 15:25:23 +0900
category: DB 심화
---
# 오라클 쿼리 변환 완전 정복 가이드

## 쿼리 변환의 본질과 중요성

### 정의와 목적
**쿼리 변환(Query Transformation)**은 Oracle 옵티마이저가 최종 실행 계획을 생성하기 전에, 원본 SQL을 **논리적으로 동일한 결과를 보장하면서 더 효율적인 형태로 재작성하는 핵심 프로세스**입니다. 이는 단순한 최적화를 넘어, SQL 자체를 재창조하는 옵티마이저의 창의적 능력입니다.

### 왜 쿼리 변환이 중요한가?
1. **탐색 공간의 기하급수적 확장**: 동일한 결과를 생성하는 10가지 다른 SQL 형태를 만들면, 그중 하나는 기존보다 100배 빠를 수 있습니다.
2. **카디널리티 추정의 정확성 향상**: 복잡한 서브쿼리를 단순한 조인으로 변환하면 통계 기반의 행 수 추정이 훨씬 정확해집니다.
3. **새로운 최적화 기회 창출**: 뷰를 병합하거나 조건을 재배치함으로써 파티션 프루닝, 인덱스 활용 등 새로운 최적화 경로가 열립니다.

### 옵티마이저 처리 파이프라인
```
SQL 파싱 → 쿼리 변환(동치 SQL 생성) → 비용 기반 탐색/선택 → 실행 계획 생성
```
쿼리 변환은 비용 계산 전단계에서 **실행 계획 후보군 자체를 근본적으로 변화시키는** 결정적 역할을 합니다.

---

## Query Block: 변환의 기본 단위와 정밀 제어

### Query Block(QB)의 이해
SELECT문, 서브쿼리, 인라인뷰, CTE 등 각 논리적 단위를 **Query Block**으로 취급합니다. 대부분의 변환은 SQL 전체가 아니라 특정 QB를 대상으로 적용됩니다.

### QB_NAME 힌트를 통한 정밀 제어
```sql
SELECT /*+ qb_name(main) */ 
       c.cust_name, s.amount
FROM   (SELECT /*+ qb_name(v_cust) */ cust_id, cust_name 
        FROM d_customer WHERE region = 'ASIA') c
JOIN   (SELECT /*+ qb_name(v_sales) */ cust_id, amount
        FROM f_sales WHERE sales_dt >= DATE '2024-01-01') s
ON     c.cust_id = s.cust_id;
```

**실무 원칙**: `NO_QUERY_TRANSFORMATION`처럼 전체 변환을 차단하는 것은 위험합니다. `NO_MERGE(@v_cust)`와 같이 **문제를 일으키는 특정 QB의 특정 변환만 정밀하게 제어**하는 것이 안전한 운영 방식입니다.

---

## 주요 쿼리 변환 12선: 원리, 사례, 통제법

### 1. 조건절 이동 (Predicate Move-Around)
**원리**: 필터 조건을 가능한 한 데이터 소스에 가까운 아래쪽으로 밀어넣어(Pushdown) 불필요한 I/O를 조기에 차단합니다. 조인 조건의 동등성을 이용한 **전이성(Transitivity)** 최적화도 포함됩니다.

**예시**:
```sql
-- 옵티마이저는 p.category='ELEC' 조건을 s 인라인뷰 내부로 푸시다운 시도
SELECT s.sales_id, s.amount
FROM   (SELECT * FROM f_sales 
        WHERE sales_dt BETWEEN '2024-03-01' AND '2024-03-31') s
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'ELEC';
```

**주의점**: 외부 조인에서는 NULL 보존 의미가 훼손될 수 있어 제한적으로 적용됩니다.

### 2. 뷰 병합 (View Merging)
**원리**: 인라인뷰를 상위 Query Block에 통합하여 조인 순서 재배치, 인덱스 선택, 파티션 프루닝 등의 최적화 기회를 확대합니다.

**Simple vs Complex**:
- **Simple**: SPJ(Select-Project-Join) 뷰는 대부분 병합 가능
- **Complex**: `GROUP BY`, `DISTINCT`, 윈도우 함수가 포함된 뷰는 병합이 제한됨

**제어**:
```sql
SELECT /*+ NO_MERGE(@vs) */ ... -- 특정 뷰 병합 차단
FROM   (SELECT /*+ qb_name(vs) */ ... ) vs
```

### 3. 서브쿼리 언네스팅 (Subquery Unnesting)
**원리**: 상관 서브쿼리를 일반 조인으로 변환하여 해시 조인, 머지 조인 등 다양한 조인 전략을 적용할 수 있게 합니다.

**변환 패턴**:
- `EXISTS` → **SEMI JOIN** (첫 매칭 발견 시 종료)
- `NOT EXISTS` → **ANTI JOIN** (매칭 없는 행만 선택)
- 스칼라 서브쿼리 → **사전 집계 후 조인**

**실전 사례**:
```sql
-- 비효율적인 스칼라 서브쿼리 패턴
SELECT p.prod_name,
       (SELECT SUM(amount) 
        FROM f_sales s 
        WHERE s.prod_id = p.prod_id) total_sales
FROM d_product p;

-- 언네스팅을 통한 최적화 (옵티마이저 자동 변환)
-- 내부적으로 사전 집계 후 LEFT JOIN으로 처리
```

### 4. OR 확장 (OR Expansion / USE_CONCAT)
**원리**: 복잡한 OR 조건을 `UNION ALL` 분기로 분리하여 각 분기별 최적의 인덱스를 활용하도록 합니다.

**적용 예시**:
```sql
SELECT /*+ USE_CONCAT */ *
FROM f_sales s
WHERE (s.prod_id = 100 AND s.sales_dt >= DATE '2024-01-01')
   OR (s.cust_id = 500 AND s.amount > 1000);
```

**내부 변환 구조**:
```sql
SELECT * FROM f_sales WHERE prod_id = 100 AND sales_dt >= DATE '2024-01-01'
UNION ALL
SELECT * FROM f_sales WHERE cust_id = 500 AND amount > 1000;
```

**주의**: OR 조건이 너무 많으면 분기 수가 폭발할 수 있어 `NO_EXPAND`로 차단 필요

### 5. 조인 제거 (Join Elimination)
**원리**: PK-FK 관계나 UNIQUE, NOT NULL 제약이 신뢰될 때, 결과에 영향을 주지 않는 조인을 실행 계획에서 완전히 제거합니다.

**동작 조건**:
1. 조인된 테이블의 컬럼이 SELECT 절에 사용되지 않음
2. 조인 조건이 PK-FK 관계를 기반으로 함
3. 필요시 NOT NULL 제약이 존재

**확인 방법**: 실행 계획의 `NOTE` 섹션에서 `'view' elimination` 메시지 확인

### 6. 집계 푸시다운 (Group-By Pushdown)
**원리**: 대규모 사실(Fact) 테이블을 먼저 집계하여 행 수를 축소한 후, 차원(Dimension) 테이블과 조인합니다.

**적합한 상황**:
- 사실 테이블이 매우 큼 (수억 행 이상)
- 집계 키(예: `prod_id`)의 카디널리티가 사실 테이블 행 수보다 훨씬 작음
- 스타 스키마 환경

**비교 예시**:
```sql
-- 원본: 조인 후 집계 (비효율적)
SELECT p.category, SUM(s.amount)
FROM f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE s.sales_dt BETWEEN :d1 AND :d2
GROUP BY p.category;

-- 변환 후: 집계 후 조인 (효율적)
SELECT p.category, agg.sum_amt
FROM (SELECT prod_id, SUM(amount) sum_amt
      FROM f_sales
      WHERE sales_dt BETWEEN :d1 AND :d2
      GROUP BY prod_id) agg
JOIN d_product p ON p.prod_id = agg.prod_id;
```

### 7. WITH 절 (CTE) 처리 전략
**두 가지 처리 방식**:

| 방식 | 특징 | 적합한 상황 |
|------|------|------------|
| **INLINE** | CTE 내용을 각 참조점에 복사 삽입 | CTE가 1회 참조, 내용이 가벼움 |
| **MATERIALIZE** | CTE 결과를 TEMP에 저장 후 재사용 | CTE가 다회 참조, 내용이 무거움 |

**제어 힌트**:
```sql
WITH cte AS (SELECT /*+ MATERIALIZE */ ... ) -- 임시 저장 강제
WITH cte AS (SELECT /*+ INLINE */ ... )     -- 인라인 처리 강제
```

### 8. 스타 변환 (Star Transformation)
**원리**: 스타 스키마에서 여러 차원 테이블의 선택도 높은 필터를 이용해 사실 테이블의 비트맵 인덱스를 결합, ROWID 리스트를 생성한 후 사실 테이블에 효율적으로 접근합니다.

**활성화 조건**:
```sql
ALTER SESSION SET star_transformation_enabled = TRUE;
-- 또는
SELECT /*+ STAR_TRANSFORMATION */ ... FROM fact JOIN dim1 JOIN dim2 ...;
```

### 9. 파티션 관련 최적화
**파티션 프루닝**: 조건을 파티션 키 컬럼으로 푸시다운하여 불필요한 파티션 접근을 제거
```sql
-- 월별 파티션 테이블에서
SELECT * FROM sales_partitioned
WHERE sales_month = '2024-03';  -- 3월 파티션만 스캔
```

**파티션 와이즈 조인**: 동일 파티션 키를 가진 두 테이블을 파티션 단위로 조인

### 10. Top-N 쿼리 최적화 (STOPKEY)
**원리**: `FETCH FIRST N ROWS`나 `ROWNUM <= N` 조건에서 전체 정렬을 피하고 상위 N개 행만 확보하는 즉시 처리 중단

**실행 계획 신호**: `SORT ORDER BY STOPKEY` 연산자 확인

### 11. 표현식 최적화
- **상수 폴딩**: `amount > 10*2` → `amount > 20`
- **조건 정규화**: 복잡한 표현을 표준 형태로 통일
- **함수 기반 인덱스 활용**: `UPPER(name)` 조건에 대한 인덱스 사용

### 12. Materialized View 리라이트
**원리**: 기반 테이블 쿼리를 Materialized View로 자동 대체

**필수 조건**:
```sql
-- MV 생성 시
CREATE MATERIALIZED VIEW mv_sales_summary
ENABLE QUERY REWRITE  -- 리라이트 활성화
AS SELECT ...;

-- 세션/시스템 설정
ALTER SESSION SET query_rewrite_enabled = TRUE;
ALTER SESSION SET query_rewrite_integrity = STALE_TOLERATED;
```

---

## 변환의 위험 요소와 안전 조치

### 1. 외부 조인과 NULL 의미 훼손
외부 조인에서 조건을 잘못 푸시다운하면 NULL 행이 필터링되어 결과가 변경될 수 있습니다. 옵티마이저는 자동으로 방지하지만 복잡한 경우 수동 검증이 필요합니다.

### 2. NOT IN의 함정
```sql
-- 위험: 서브쿼리에 NULL이 있으면 항상 공집합 반환
SELECT * FROM t1 WHERE col NOT IN (SELECT col FROM t2);

-- 안전: NOT EXISTS 사용 권장
SELECT * FROM t1 WHERE NOT EXISTS (SELECT 1 FROM t2 WHERE t2.col = t1.col);
```

### 3. 집계/중복 의미 변경
뷰 병합이나 집계 푸시다운이 집계 시점이나 중복 제거 범위를 변경하여 결과가 달라질 수 있습니다.

### 4. 보안 권한 문제
뷰는 기본 테이블 접근 권한을 제어하는 수단입니다. `optimizer_secure_view_merging` 파라미터로 보안 모드에서의 병합을 제어합니다.

---

## 변환 진단과 분석 실전 기법

### 1. 실행 계획 상세 분석
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL, 
  'ALLSTATS LAST +NOTE +PREDICATE +ALIAS +PROJECTION'
));
```

**분석 포인트**:
- `NOTE` 섹션: `view MERGED`, `OR-EXPANSION` 등 변환 적용 여부
- `Predicate Information`: 조건절 이동 추적
- `E-Rows vs A-Rows`: 추정 정확도 평가

### 2. 10053 트레이스 (고급 진단)
옵티마이저의 비용 계산과 변환 결정 상세 내역을 파일로 기록합니다.

```sql
ALTER SESSION SET events '10053 trace name context forever, level 1';
-- 쿼리 실행
ALTER SESSION SET events '10053 trace name context off';
```

**사용 시기**: 변환 관련 심층 문제 분석, 옵티마이저 동작 이해 교육용

### 3. 통계 정보의 결정적 중요성
**변환의 모든 결정은 통계 정확성에 기반합니다**:

| 통계 유형 | 변환 영향도 | 관리 방안 |
|-----------|------------|-----------|
| 기본 통계 | 모든 변환 | 정기적 갱신 |
| 히스토그램 | 조건절 푸시다운, 선택도 추정 | 스큐 컬럼에 집중 |
| 확장 통계 | 조인 카디널리티 추정 | 상관관계 높은 컬럼 그룹 |
| 시스템 통계 | 비용 계산 기준 | 하드웨어 변경 시 갱신 |

---

## 실전 트러블슈팅 시나리오

### 시나리오 1: 갑작스런 성능 저하
**증상**: 특정 SQL의 실행 시간이 몇 배로 증가
**진단 단계**:
1. 현재 vs 과거 실행 계획 비교
2. 변환 적용 여부 확인 (`NOTE` 섹션)
3. 통계 갱신 시점과 성능 변화 시점 대조
4. `E-Rows vs A-Rows` 편차 분석

### 시나리오 2: 변환 과잉으로 인한 불안정성
**증상**: 동일 SQL이 서로 다른 실행 계획으로 번갈아 실행
**해결**:
```sql
-- 불안정한 변환만 국소적 차단
SELECT /*+ NO_MERGE(@problem_view) */ ...
FROM (SELECT /*+ qb_name(problem_view) */ ...) v
```

### 시나리오 3: 외부 조인 결과 오류
**증상**: LEFT JOIN 결과가 INNER JOIN처럼 동작
**해결**: 내부 테이블 조건을 WHERE 대신 ON 절로 이동
```sql
-- 오류 가능성
SELECT c.*, s.amount
FROM customers c LEFT JOIN sales s ON c.id = s.cust_id
WHERE s.sales_date > SYSDATE - 30;

-- 수정안
SELECT c.*, s.amount
FROM customers c 
LEFT JOIN sales s ON c.id = s.cust_id AND s.sales_date > SYSDATE - 30;
```

---

## 변환 활용을 위한 실무 체크리스트

### 변환을 적극 활용해야 할 때
- ✅ 대규모 스칼라 서브쿼리 반복 실행 → `UNNEST` 유도
- ✅ 복합 OR 조건으로 풀 스캔 발생 → `USE_CONCAT` 적용
- ✅ 동일 CTE 다회 참조 → `MATERIALIZE` 고려
- ✅ 스타 스키마 고선택도 조회 → 스타 변환 활성화
- ✅ 대용량 집계 쿼리 → 집계 푸시다운 확인

### 변환을 제한해야 할 때
- ⚠️ 외부 조인 NULL 의미 보존이 중요한 경우
- ⚠️ 뷰 내 집계/윈도우 함수의 정확한 동작이 필수적인 경우
- ⚠️ OR 조건이 너무 많아 분기 폭발 우려 시
- ⚠️ 보안 뷰의 권한 체계 유지 필요 시

### 지속적 모니터링 항목
- 🔍 주기적 통계 갱신 상태 점검
- 🔍 `E-Rows vs A-Rows` 편차 모니터링
- 🔍 변환 관련 새로운 실행 계획 출현 추적
- 🔍 시스템 부하 패턴과 변환 동향 상관관계 분석

---

## 변환별 핵심 레퍼런스

| 변환 | 주요 이점 | 활성화 조건 | 제어 힌트 |
|------|----------|------------|----------|
| 조건절 이동 | I/O 감소, 인덱스 활용도 ↑ | NOT NULL 안전성 확보 | (자동) |
| 뷰 병합 | 조인 재배치 자유도 ↑ | 뷰 내 집계/윈도우 없음 | `MERGE` / `NO_MERGE` |
| 서브쿼리 언네스팅 | 조인 전략 다양화 | 상관관계 명확 | `UNNEST` / `NO_UNNEST` |
| OR 확장 | 분기별 최적 인덱스 활용 | 분기 수 적절 | `USE_CONCAT` / `NO_EXPAND` |
| 조인 제거 | 불필요 연산 제거 | PK-FK 관계 신뢰 | (자동) |
| 집계 푸시다운 | 중간 결과 집합 축소 | 그룹 키 카디널리티 적음 | (자동) |
| CTE 처리 | 중복 계산 방지 | 참조 횟수 ≥ 2 | `MATERIALIZE` / `INLINE` |
| 스타 변환 | 사실 테이블 접근 최적화 | 비트맵 인덱스 존재 | `STAR_TRANSFORMATION` |
| 파티션 프루닝 | 파티션 I/O 절감 | 파티션 키 조건 명확 | (자동) |
| Top-N 최적화 | 조기 종료로 리소스 절약 | ORDER BY 조건 존재 | (자동) |

---

## 최종 결론: 변환 마스터하기 위한 3대 원칙

쿼리 변환은 Oracle 옵티마이저의 가장 강력한 능력이자 가장 복잡한 영역입니다. 효과적으로 활용하기 위한 세 가지 핵심 원칙은 다음과 같습니다.

### 원칙 1: "옵티마이저의 눈으로 보라"
변환을 이해하려면 옵티마이저의 관점에서 생각해야 합니다. 옵티마이저는 **통계 정보를 바탕으로 비용을 계산하고, 동일한 결과를 더 저렴하게 생성할 수 있는 방법을 찾습니다**. 변환이 적용되지 않았다면 "옵티마이저가 위험하거나 비효율적이라고 판단한 것"으로 이해하세요.

### 원칙 2: "통계의 정확성이 변환의 품질을 결정한다"
모든 변환 결정의 근간은 통계 정보입니다. 히스토그램이 왜곡되었거나 확장 통계가 부재하다면, 아무리 훌륭한 변환 로직도 잘못된 방향으로 적용될 수 있습니다. **변환 문제의 80%는 근본적으로 통계 문제**입니다.

### 원칙 3: "정밀한 제어가 전문가의 핵심 능력이다"
`NO_QUERY_TRANSFORMATION`처럼 무차별적 차단은 미숙한 해결책입니다. 진정한 전문가는 `qb_name()`과 함께 `NO_MERGE(@problem_view)`처럼 **문제의 근원을 정확히 겨냥한 외과적 수술**을 수행합니다. 이는 옵티마이저가 제공하는 실행 계획 정보를 꼼꼼히 읽고 해석할 수 있는 능력에서 비롯됩니다.

쿼리 변환의 세계는 복잡하지만, 위 세 원칙을 따르고 체계적으로 접근한다면, 이는 단순한 문제 해결 도구를 넘어 **데이터베이스 성능을 예측 가능하고 최적화된 상태로 유도하는 예술**이 될 것입니다. 변환을 마스터하는 여정은 궁극적으로 옵티마이저와의 대화를 배우는 과정이며, 이는 어떤 튜닝 기술보다 가치 있는 투자입니다.