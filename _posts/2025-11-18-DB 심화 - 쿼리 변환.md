---
layout: post
title: DB 심화 - 쿼리 변환
date: 2025-11-18 15:25:23 +0900
category: DB 심화
---
# 오라클 **쿼리 변환(Query Transformation)** 완전 가이드

## 쿼리 변환이란? (What & Why)

- **정의:** 옵티마이저가 **실행계획 생성 전**에 논리적으로 **동치**(결과 동일)인 다른 형태의 SQL로 **자동 재작성**하는 단계.
- **목적:** **카디널리티 추정**을 쉽게/정확하게 하고 **더 저렴한(비용 낮은)** 실행전략을 탐색하기 위함.
- **흔한 예:** `EXISTS/IN → SEMI JOIN`, `NOT EXISTS → ANTI JOIN`, `뷰 머지(View Merge)`, `서브쿼리 풀기(Unnest)`, `OR-EXPAND(UNION ALL)`, `집계 푸시다운`, `스타 변환`, `파티션 프루닝`, `조인 제거(Join Elimination)`, `스칼라 서브쿼리 → 조인`, `WITH 물질화(Materialize)` 등.

> 변환은 **비용 기반(CBO)** 판단이므로 **통계/히스토그램/시스템 통계**가 정확할수록 더 과감하고 유리한 변환이 적용된다.

---

## 큰 흐름: 파싱 → 최적화(쿼리 변환 포함) → Row Source 생성

1. **파싱(Parsing)**: 문법/객체 확인, 바인드/정규화.
2. **최적화(Optimization)**:
   - **쿼리 변환**(Query Transformation) ⇢ 수많은 대안을 **동치 변환**으로 만들어 후보군 확장
   - **비용평가/탐색** ⇢ 통계로 비용 산정, 최저 비용 플랜 채택
3. **Row-Source 생성**: 선택된 플랜을 실행 프레임워크 표현(트리)로 내림.

---

## 핵심 도구: Query Block 네이밍 & 힌트로 제어

- **QB 이름 붙이기**
```sql
SELECT /*+ qb_name(main) */ ...
FROM   (SELECT /*+ qb_name(v_cust) */ ... FROM D_CUSTOMER) c
JOIN   (SELECT /*+ qb_name(v_sales)*/ ... FROM F_SALES)   s ON ...
```
- **변환 제어 힌트(대표)**
  - **뷰 머지**: `MERGE`, `NO_MERGE([@QB])`
  - **서브쿼리 언네스트**: `UNNEST`, `NO_UNNEST`
  - **OR-EXPAND**: `USE_CONCAT`, `NO_EXPAND`
  - **머티리얼라이즈/인라인**: `MATERIALIZE`, `INLINE` (WITH/서브쿼리)
  - **쿼리 변환 전반**: `NO_QUERY_TRANSFORMATION` (특정 QB에만 권장)

---

# 파트 A. 대표 변환 12가지 + 실전 예제

## **프레디킷 푸시다운 & 이동(Predicate Pushdown/Move-Around) + 전이성(Transitivity)**

### 원리

- 가능한 한 **일찍**(뷰/서브쿼리 내부, 파티션 키 등) 필터를 내려 **입력량 축소**.
- 등치 조인으로 **전이 프레디킷** 생성: `A=B, B=10 ⇒ A=10`.
- 외부조인(LEFT/RIGHT)에서는 **널 보존** 때문에 무작정 전이/푸시가 안 될 수 있음(**NOT NULL 제약**이 안전장치).

### 예제

```sql
-- 전이성 생성 & 푸시다운
SELECT /*+ qb_name(main) */
       s.sales_id, s.amount
FROM   (SELECT /*+ qb_name(v) */ *
        FROM F_SALES
        WHERE sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31') s
JOIN   D_PRODUCT p
  ON   p.prod_id = s.prod_id
WHERE  p.category = 'ELEC';
```
- 옵티마이저는 `p.category='ELEC'`를 **조인 전** `F_SALES`에 푸시 못 한다. (키가 `p.prod_id`)
- 하지만 `p.prod_id = s.prod_id` + `p.category='ELEC'` ⇒ **인덱스(IX_PROD_CAT_BRAND)** 활용 가능.
- **전이 프레디킷**으로 `s.prod_id` 후보가 좁혀져 **s → p 순** NL이 유리해질 수도.

**제어 포인트**
- 외부조인 쿼리에서 무리한 푸시로 결과 바뀔 위험 시 `NO_PUSH_PRED` 계열 힌트(버전별) 혹은 `NO_QUERY_TRANSFORMATION`로 해당 QB 보호.

---

## **뷰 머지(View Merging) — Simple/Complex**

### 원리

- 뷰/인라인 뷰를 **해체**해 상위로 끌어올려 **조인 재배치/인덱스 사용/프루닝** 기회 확대.
- **Simple View Merge**: 집계/윈도우/집합 연산 없는 단순 뷰.
- **Complex View Merge**: 일부 집계/윈도우 포함도 상황 따라 시도(버전/옵션 영향).

### 예제 (머지 유리)

```sql
SELECT /*+ qb_name(main) */
       s.sales_id, p.brand
FROM   (SELECT /*+ qb_name(vs) */ prod_id, sales_id
        FROM F_SALES
        WHERE sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31') s
JOIN   D_PRODUCT p
  ON   p.prod_id = s.prod_id
WHERE  p.brand = 'B0';
```
- **머지 결과**: 상위 WHERE의 `p.brand='B0'`가 조인 재배치에 도움 → `IX_PROD_CAT_BRAND` 활용.
- **머지 차단**(문제 재현/비교): `SELECT /*+ NO_MERGE(@vs) */ ...`

**주의**
- 뷰 내부 **집계/윈도우**가 있으면 머지가 **불가능**하거나 **다른 변환**(집계 푸시다운)과 충돌할 수 있음.

---

## **서브쿼리 언네스트(Subquery Unnesting) — EXISTS/IN/NOT EXISTS/Scalar**

### 원리

- 상관 서브쿼리를 **조인**으로 바꿔 **선택적 인덱스/해시/소트-머지** 등 더 많은 계획 탐색.

### `EXISTS → SEMI JOIN`

```sql
-- 원형
SELECT /*+ qb_name(main) */
       c.cust_id
FROM   D_CUSTOMER c
WHERE  EXISTS ( SELECT 1
                FROM F_SALES s
                WHERE s.cust_id = c.cust_id
                  AND s.sales_dt >= DATE '2024-03-01' );

-- 언네스트 힌트(필요 시)
SELECT /*+ UNNEST */ c.cust_id
FROM   D_CUSTOMER c
WHERE  EXISTS (SELECT 1 FROM F_SALES s
               WHERE s.cust_id = c.cust_id
                 AND s.sales_dt >= DATE '2024-03-01');
```
- 보통 자동 언네스트되어 **SEMI JOIN**(매칭 1개만 찾으면 OK)으로 변환.

### `NOT EXISTS → ANTI JOIN`

```sql
SELECT /*+ UNNEST */ c.cust_id
FROM   D_CUSTOMER c
WHERE  NOT EXISTS (SELECT 1 FROM F_SALES s
                   WHERE s.cust_id = c.cust_id
                     AND s.sales_dt >= DATE '2024-03-01');
```
- **ANTI JOIN**으로 변환되어 HJ/SMJ/NL 중 비용 최소 선택.

### **스칼라 서브쿼리 → 조인**

```sql
-- 각 상품의 3월 매출 합
SELECT p.prod_id,
       (SELECT SUM(s.amount)
        FROM   F_SALES s
        WHERE  s.prod_id = p.prod_id
        AND    s.sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31') AS m_sum
FROM   D_PRODUCT p;

-- 언네스트(가능하면 조인 + GROUP BY)
SELECT /*+ UNNEST */ p.prod_id, ss.m_sum
FROM   D_PRODUCT p
LEFT JOIN (
  SELECT s.prod_id, SUM(s.amount) m_sum
  FROM   F_SALES s
  WHERE  s.sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
  GROUP  BY s.prod_id
) ss
ON ss.prod_id = p.prod_id;
```
- **스칼라 캐시**가 있어도 대량일 땐 조인/집계가 유리.

**제어**: `NO_UNNEST`로 원형 유지 (상관관계/NULL 의미 유지가 필요할 때).

---

## **OR-EXPAND (USE_CONCAT) / INLIST ITERATOR**

### 원리

- `OR` 조건을 **`UNION ALL`**(또는 **USE_CONCAT**)로 쪼개면 각 분기마다 **전용 인덱스 경로** 선택 가능.
- `IN (:b1,:b2,...)`는 **INLIST ITERATOR**로 하나의 플랜 내에서 반복 인덱스 탐색.

### 예제

```sql
-- OR-EXPAND 후보
SELECT /*+ USE_CONCAT */ *
FROM   F_SALES s
WHERE  (s.prod_id = :p1 AND s.sales_dt >= :d1)
    OR (s.cust_id = :c1 AND s.sales_dt >= :d2);

-- 옵티마이저가 내부적으로
SELECT * FROM F_SALES s
WHERE  s.prod_id = :p1 AND s.sales_dt >= :d1
UNION ALL
SELECT * FROM F_SALES s
WHERE  s.cust_id = :c1 AND s.sales_dt >= :d2;
```
- 각 분기에서 **다른 인덱스**(PROD_DT, CUST_DT)를 사용 가능 → 랜덤 I/O 감소.

**제어**: 폭발적 플랜 분기가 우려되면 `NO_EXPAND`로 차단.

---

## **조인 제거(Join Elimination)**

### 원리

- **외래키(FK)** + **유니크/프라이머리** + **NOT NULL** 등 제약이 있으면
  결과에 영향 없는 조인을 제거해 **입력 축소**.

### 예제

```sql
-- 제품 브랜드를 조건으로만 쓰고, 실제 SELECT 컬럼은 F_SALES 것뿐
SELECT s.sales_id
FROM   F_SALES s
JOIN   D_PRODUCT p
  ON   p.prod_id = s.prod_id
WHERE  p.brand = 'B0';
```
- `p.brand='B0'` 프레디킷은 **푸시**되어 `s.prod_id` 필터로 쓰이고,
  SELECT에 `p.*`가 없고 **중복/NULL 위험이 없으면** 조인을 **제거**할 수 있다.
- 제약/통계 조건이 모호하면 제거하지 않음.

---

## **집계 푸시다운(Group-By Pushdown) & 조인-그룹 변환**

### 원리

- 조인 전에 **그룹핑/집계**를 밀어 넣어 **입력량 감소**.
- 스타/스노우플레이크 모델에서 효과 큼.

### 예제

```sql
-- 원형(조인 후 그룹)
SELECT p.category, SUM(s.amount)
FROM   F_SALES s JOIN D_PRODUCT p ON p.prod_id=s.prod_id
WHERE  s.sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
GROUP  BY p.category;

-- 변환(집계 먼저)
-- (내부적으로 s를 prod_id 기준 집계 후 p와 조인)
```
- `p.category`가 적은 도메인일수록 이득.

---

## **WITH(Subquery Factoring) → INLINE vs MATERIALIZE (Temp Table Transformation)**

### 원리

- `WITH t AS (...) SELECT ... FROM t ...`
  - **`INLINE`**: 각 사용 지점에 **삽입**(복제) → 각 지점 최적화 기회↑
  - **`MATERIALIZE`**: **한 번만 계산**해 TEMP에 저장, **여러 번 재사용** → 중복 계산↓, I/O/Temp 고려

### 예제

```sql
WITH sales_m AS (
  SELECT /*+ qb_name(w_sales) */
         prod_id, SUM(amount) sum_amt
  FROM   F_SALES
  WHERE  sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
  GROUP  BY prod_id
)
SELECT /*+ MATERIALIZE */ p.category, SUM(m.sum_amt)
FROM   sales_m m JOIN D_PRODUCT p ON p.prod_id = m.prod_id
GROUP  BY p.category;
```
- 동일 CTE를 **여러 번** 참조한다면 `MATERIALIZE` 이득.
- 1회/간단이면 `INLINE`이 유리.

---

## **스타 변환(Star Transformation)**

### 원리

- **사실 테이블 + 여러 차원** 구조에서, 차원 인덱스(주로 **비트맵** 또는 고선택도 b-tree)로 **필터 집합**을 만든 뒤
  사실 테이블로 **한 번에** 진입.
- 파라미터/힌트: `STAR_TRANSFORMATION_ENABLED=TRUE`, 힌트 `STAR_TRANSFORMATION`, `STAR`.

### 예제(개념)

```sql
-- 차원: D_PRODUCT(CATEGORY, BRAND), D_CUSTOMER(REGION, TIER)
-- 사실: F_SALES(prod_id, cust_id, ...)

SELECT /*+ STAR_TRANSFORMATION */ SUM(s.amount)
FROM   F_SALES s
JOIN   D_PRODUCT  p ON p.prod_id  = s.prod_id
JOIN   D_CUSTOMER c ON c.cust_id  = s.cust_id
WHERE  p.category='ELEC'
AND    p.brand   ='B0'
AND    c.region  ='KOR'
AND    c.tier    ='VIP';
```
- 차원 필터로 **비트맵** 결합(AND) → 사실의 rowid 후보 소수만 접근.
- 차원 인덱스/선택도/통계 정확도가 관건.

---

## **파티션 프루닝 & 파티션-와이즈 조인(Partition Pruning / Pwise Join)**

### 원리

- **파티션 키 조건**을 최대한 **푸시**하여 읽을 파티션을 줄임(프루닝).
- 동일 파티션 키로 조인 시 **파티션-와이즈 조인**으로 각 파티션끼리 **병렬/지역 처리**.

### 예제

```sql
-- Range 파티션: SALES_DT
SELECT SUM(amount)
FROM   F_SALES
WHERE  sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
```
- 변환으로 **파티션 리스트**가 미리 확정되어 필요 파티션만 스캔.
- 조인에서도 두 테이블이 같은 Range 파티션 구성이면 **Pwise Join** 후보.

---

## **Rownum/Top-N 최적화 — Stopkey Pushdown**

### 원리

- `ROWNUM <= N`, `FETCH FIRST N ROWS ONLY` 등 **상위 N** 제한을 **일찍** 적용하여
  인덱스 **Top-N Range Scan**이나 `COUNT STOPKEY`로 **조기 종료**.

### 예제

```sql
SELECT *
FROM   F_SALES
WHERE  sales_dt >= DATE '2024-03-01'
ORDER  BY amount DESC
FETCH FIRST 10 ROWS ONLY;
```
- 인덱스(AMOUNT DESC) 있으면 **정렬 없이** Top-N Range Scan.
- 없으면 **STOPKEY**가 소트 단계와 결합되어 **조기 종료**.

---

## **정규화/상수 폴딩/식 단순화(Constant Folding / Simplification)**

### 원리

- `WHERE amount > 10*2` → `> 20`
- `NVL(col,'X') = 'X'` → `col IS NULL` (타입/세션 설정 주의)
- 표현식 간단히 만들어 인덱스 사용률↑.

### 예제

```sql
SELECT * FROM D_PRODUCT
WHERE NVL(brand,'?') = 'B0';
-- 변환이 막히면 함수기반 인덱스 고려:
-- CREATE INDEX fx_brand ON D_PRODUCT(NVL(brand,'?'));
```

---

## **Materialized View(MV) Query Rewrite**

### 원리

- `QUERY_REWRITE_ENABLED=TRUE`에서 MV가 기반 테이블 쿼리를 **대체**.
- **JOIN/AGG MV**로 대형 집계/조인을 즉시 응답.
- 무결성(신선도/정합) 규칙: `QUERY_REWRITE_INTEGRITY`(ENFORCED/TRUSTED/STALE_TOLERATED).

### 예제(개념)

```sql
-- 월별 상품 카테고리 집계 MV
CREATE MATERIALIZED VIEW MV_SALES_CAT
BUILD IMMEDIATE
REFRESH FAST ON COMMIT
ENABLE QUERY REWRITE
AS
SELECT p.category, TRUNC(s.sales_dt,'MM') AS mon, SUM(s.amount) amt
FROM   F_SALES s JOIN D_PRODUCT p ON p.prod_id=s.prod_id
GROUP  BY p.category, TRUNC(s.sales_dt,'MM');

-- 동일 질의가 MV로 리라이트
SELECT p.category, TRUNC(s.sales_dt,'MM'), SUM(s.amount)
FROM   F_SALES s JOIN D_PRODUCT p ON p.prod_id=s.prod_id
GROUP  BY p.category, TRUNC(s.sales_dt,'MM');
```

---

# 파트 B. 변환이 결과/성능에 미치는 영향과 **제어/진단**

## 변환이 결과에 미치는 주의점

- **외부조인**과 **NULL 보존**: 프레디킷 전이/푸시가 **결과를 바꿀 수 있음**
- **중복/집계 의미**: 집계 푸시/뷰 머지 시 **중복 제거** 타이밍 변화 주의
- **3값 논리(UNKNOWN)**: `NOT IN`의 NULL 문제 vs `NOT EXISTS`

> 결과 보장이 애매하면 **QB 단위**로 `NO_*` 힌트로 범위를 제한하고 실측으로 검증.

## 힌트로 세밀 제어

| 목적 | 힌트 |
|---|---|
| 뷰 머지 금지 | `NO_MERGE[@QB]` |
| 서브쿼리 언네스트 금지 | `NO_UNNEST` |
| OR-EXPAND 강제/금지 | `USE_CONCAT`, `NO_EXPAND` |
| WITH 물질화/인라인 | `MATERIALIZE`, `INLINE` |
| 쿼리변환 전반 금지 | `NO_QUERY_TRANSFORMATION` |
| QB 대상 지정 | `QB_NAME(qb)` |

**예시**
```sql
WITH F AS (SELECT /*+ qb_name(fx) */ * FROM F_SALES WHERE sales_dt>=DATE '2024-03-01')
SELECT /*+ NO_MERGE(@fx) */ *
FROM   F
WHERE  prod_id = :p;
```

## 진단: 변환이 적용되었는가?

```sql
-- 실측 실행계획 + 변환 노트
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +NOTE +ALIAS'));
```
- **Notes** 영역에 `query block name`, `view merging`, `predicate push-down`, `star transformation`, `join elimination` 등의 메시지가 뜨는 버전이 많다.
- **Predicate Information**에서 `access/filter`의 **이동/전이** 확인.
- (고급) 10053 trace는 교육용/진단용으로만, 운영에선 신중.

---

# 파트 C. 상황별 케이스 스터디

## 스칼라 서브쿼리 과다 호출 → 언네스트로 해결

```sql
-- 느린 패턴(대량 스칼라)
SELECT p.prod_id,
       (SELECT SUM(amount) FROM F_SALES s
        WHERE s.prod_id=p.prod_id AND s.sales_dt BETWEEN :d1 AND :d2) m_sum
FROM   D_PRODUCT p
WHERE  p.category='ELEC';

-- 해결(조인+사전 집계)
SELECT p.prod_id, ss.m_sum
FROM   D_PRODUCT p
LEFT JOIN (
  SELECT prod_id, SUM(amount) m_sum
  FROM   F_SALES
  WHERE  sales_dt BETWEEN :d1 AND :d2
  GROUP  BY prod_id
) ss
ON ss.prod_id = p.prod_id
WHERE p.category='ELEC';
```
- **변환 기대:** 스칼라 언네스트 → 조인+집계.
- **효과:** 스칼라 캐시 초과/랜덤 호출 ↓, 해시 집계/조인이 효율적.

## OR 조건으로 인덱스 못 탈 때 → OR-EXPAND

```sql
-- 원형
SELECT *
FROM   F_SALES
WHERE  (prod_id=:p1 AND sales_dt>=:d1)
    OR (cust_id=:c1 AND sales_dt>=:d2);

-- USE_CONCAT(= OR-EXPAND)
SELECT /*+ USE_CONCAT */ *
FROM   F_SALES
WHERE  (prod_id=:p1 AND sales_dt>=:d1)
UNION ALL
SELECT *
FROM   F_SALES
WHERE  (cust_id=:c1 AND sales_dt>=:d2);
```
- 각 분기에서 **다른 인덱스**를 활용 → **랜덤 I/O** 최소화.

## 뷰 머지 실패 시 NO_MERGE? MATERIALIZE?

- **뷰 내부 집계/윈도우** 때문에 머지가 안 되는 경우가 있다.
  - 같은 CTE를 여러 번 사용한다면 `MATERIALIZE`로 **한 번 계산 후 재사용**이 유리.
  - 한 번만 사용되며 내부 집계가 가볍다면 `INLINE`이 더 좋을 수 있음.

## 스타 변환 vs 일반 조인

- 차원 필터가 **높은 선택도**일 때 스타 변환이 압승.
- 차원 인덱스/통계 조건이 불량하면 **비용 오판** → **히스토그램/NDV** 보정 필수.

## 파티션 프루닝 실패 원인

- 프레디킷이 **함수 래핑**(예: `TRUNC(sales_dt) = :d`) 되어 있으면 **키 인식 실패**
  - 해결: **함수기반 인덱스** 또는 **식 동치 변환** 유도 (`sales_dt >= :d AND < :d+1`)
- 조인/서브쿼리로 파티션 키가 감춰진 경우 **뷰 머지/언네스트**가 선행되어야 프루닝.

---

# 파트 D. 실전 체크리스트

### 통계 & 히스토그램

- [ ] 스큐 컬럼 히스토그램(Top-Frequency/Hybrid) 적용
- [ ] 확장 통계(컬럼 그룹)로 결합 선택도 보정
- [ ] 파티션 테이블은 **증분 통계**

### 변환을 **활용**해야 할 때

- [ ] 서브쿼리 대량 호출 → **UNNEST**
- [ ] 복잡한 OR → **USE_CONCAT / OR-EXPAND**
- [ ] 반복 참조 CTE/서브쿼리 → **MATERIALIZE**
- [ ] 스타/DM 모델 대량 필터 → **STAR_TRANSFORMATION**

### 변환을 **막아야** 할 때

- [ ] 외부조인 NULL 보존 등 **의미 손상** 우려 → `NO_QUERY_TRANSFORMATION` or 대상별 `NO_*`
- [ ] 특정 뷰 내부의 집계/윈도우 순서 보장 필요 → `NO_MERGE(@qb)`
- [ ] OR-EXPAND 플랜 폭발 → `NO_EXPAND`

### 진단

- [ ] `DBMS_XPLAN.DISPLAY_CURSOR('ALLSTATS LAST +NOTE +ALIAS +PREDICATE')`
- [ ] 변환 노트/프레디킷 이동/조인 방식 확인
- [ ] (고급) 10053 trace는 비상시에만

---

# 부록 1. 변환별 **미니 레퍼런스**

| 변환 | 핵심 이득 | 관건 통계/구조 | 대표 힌트 |
|---|---|---|---|
| 프레디킷 푸시/전이 | 입력 축소/인덱스 활용 | NOT NULL, 히스토그램 | (버전별 push 관련), NO_QUERY_TRANSFORMATION |
| 뷰 머지 | 조인 재배치/프루닝 | 뷰 내부 연산, 키/인덱스 | MERGE / NO_MERGE |
| 언네스트(Exists/In/Scalar) | JOIN 전략 선택 | 상관관계/중복 | UNNEST / NO_UNNEST |
| OR-EXPAND | 분기별 최적 경로 | 분기 선택도/인덱스 | USE_CONCAT / NO_EXPAND |
| 조인 제거 | 불필요 조인 삭제 | FK/PK/Unique/NN | (자동) |
| 집계 푸시 | 조인 전 입력 축소 | GROUP 키 카디널리티 | (자동) |
| WITH 물질화 | 중복 계산 제거 | 재사용 횟수/Temp | MATERIALIZE / INLINE |
| 스타 변환 | 차원 필터 결합 | 차원 인덱스/스큐 | STAR_TRANSFORMATION |
| 파티션 프루닝 | 파티션 I/O 절감 | 키 인식/표현식 | (자동), 함수기반 인덱스 |
| Pwise Join | 병렬/지역 처리 | 동일 파티션 키 | (자동/병렬) |
| Stopkey | Top-N 조기 종료 | 인덱스 정렬 | (자동) |
| MV Rewrite | 즉시 응답 | MV 신선도 | QUERY_REWRITE |

---

# 부록 2. 실습 스니펫 모음

```sql
-- 1) 실행계획(실측)과 변환 노트 보기
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +NOTE +PREDICATE +ALIAS'));

-- 2) QB 이름 붙여 일부 변환만 제어
SELECT /*+ qb_name(main) */
       *
FROM   (SELECT /*+ qb_name(v) */ * FROM F_SALES WHERE sales_dt>=DATE '2024-03-01') s
JOIN   D_PRODUCT p
  ON   p.prod_id = s.prod_id
WHERE  p.brand='B0';

-- 3) 뷰 머지 금지
SELECT /*+ NO_MERGE(@v) */ ...

-- 4) 서브쿼리 언네스트 유도/금지
SELECT /*+ UNNEST */ ...
SELECT /*+ NO_UNNEST */ ...

-- 5) OR-EXPAND 강제/금지
SELECT /*+ USE_CONCAT */ ...
SELECT /*+ NO_EXPAND  */ ...

-- 6) WITH 물질화/인라인
WITH X AS (SELECT ... FROM ... WHERE ...)
SELECT /*+ MATERIALIZE */ ... FROM X ...;
WITH Y AS (SELECT ... FROM ... WHERE ...)
SELECT /*+ INLINE */ ... FROM Y ...;

-- 7) 스타 변환(환경 필요)
ALTER SESSION SET star_transformation_enabled = TRUE;
SELECT /*+ STAR_TRANSFORMATION */ ...
```

---

## 마무리: **정확한 통계 + 올바른 변환 = 저비용 플랜**

- 쿼리 변환은 **“쪼개고, 밀어 넣고, 합치고, 대체”**하는 일련의 동치 재작성 기술.
- **히스토그램/확장 통계/파티션 통계**가 받쳐줘야 **과감한 변환**이 안전하게 작동.
- 성능 문제 시 **변환을 의심/관찰**하고, 필요하면 **QB 힌트로 국지 제어**하라.
- 언제나 **E-Rows vs A-Rows**와 **실측 플랜**으로 결과와 성능을 **팩트 체크**하는 습관이 정답이다.
