---
layout: post
title: DB 심화 - 쿼리 변환
date: 2025-11-18 15:25:23 +0900
category: DB 심화
---
# 오라클 **쿼리 변환(Query Transformation)**

## 쿼리 변환이란? (What & Why)

### 정의

**쿼리 변환(Query Transformation)** 은 옵티마이저가 **실행계획을 만들기 전에** SQL을 **논리적으로 동치(결과 동일)** 인 다른 형태로 자동 재작성하는 단계다. 변환된 SQL 위에서 조인 순서/접근 경로/조인 방식 등 비용 탐색이 이뤄진다.

### 목적

1) **카디널리티 추정(행 수, 선택도)과 비용 산정을 쉽게/정확하게** 만들고
2) **더 저렴한 대안 플랜을 탐색할 수 있도록 후보군을 확장**하기 위함이다.
즉, “같은 결과”를 내는 SQL을 여러 형태로 만들어 놓고 **CBO가 그중 최저 비용을 고르는 구조**다.

### 큰 그림에서의 위치

옵티마이저는 대체로
**파싱 → (동치 SQL 생성) 쿼리 변환 → 비용 기반 탐색/선택 → Row Source Tree 생성**
순으로 움직이며, 변환은 **조인 순서 탐색보다 앞단에서 후보 SQL을 증가**시키는 역할을 한다.

---

## 옵티마이저 내부 흐름과 Query Block

### Query Block(QB)란

SELECT / 서브쿼리 / 인라인뷰 / WITH(CTE) 등 **각 논리 단위**를 옵티마이저는 Query Block으로 취급한다.
변환은 “SQL 전체”가 아니라 **QB 단위로 적용/차단/강제**되는 경우가 대부분이다. 그래서 **QB 네이밍이 제어의 출발점**이다.

### QB_NAME으로 이름 붙이기

```sql
SELECT /*+ qb_name(main) */ ...
FROM   (SELECT /*+ qb_name(v_cust) */ ... FROM D_CUSTOMER) c
JOIN   (SELECT /*+ qb_name(v_sales)*/ ... FROM F_SALES)   s
  ON   ...
```
- 같은 SQL이라도 **QB 이름이 있으면** 특정 변환만 **정밀하게 ON/OFF** 할 수 있다.
- 운영에서 “전체 변환 금지”는 위험하고, **문제 QB만 국지 제어**하는 게 표준적이다.

---

## 변환 제어의 기본 도구: 힌트/파라미터/보안 모드

### 변환 제어 힌트 패밀리

오라클은 변환을 **힌트로 강제/차단** 할 수 있게 한다. 대표군은 다음과 같다.

| 변환 | 강제 힌트 | 차단 힌트 |
|---|---|---|
| View Merge | `MERGE` | `NO_MERGE(@qb)` |
| Subquery Unnest | `UNNEST` | `NO_UNNEST(@qb)` |
| OR Expansion | `USE_CONCAT` (=OR-EXPAND) | `NO_EXPAND` |
| Temp Table / CTE 물질화 | `MATERIALIZE` | `INLINE` |
| Star Transformation | `STAR_TRANSFORMATION` | (환경/버전별 `NO_STAR_TRANSFORMATION`) |
| 전체 변환 차단 | — | `NO_QUERY_TRANSFORMATION(@qb)` |

> **실무 원칙**
> - **NO_QUERY_TRANSFORMATION은 최후의 수단**.
> - 대부분은 `NO_MERGE`, `NO_UNNEST`, `NO_EXPAND`처럼 **정확히 목표 변환만 끊는 게 안전**하다.

### Secure View Merging(권한 안전 뷰 머지)

뷰 머지는 **권한/보안 의미가 바뀔 수 있기 때문에**, 오라클은 “보안 안전 모드”에서만 머지를 허용한다.
`optimizer_secure_view_merging` 파라미터가 이 동작을 제어한다.

---

## 대표 쿼리 변환들 — 원리/예제/주의점/제어

여기서는 **당신이 이미 정리한 12개 변환**을 중심으로, 오라클 공식 변환 분류(추가 변환 포함)와 맞물리게 확장한다.

---

### 프레디킷 푸시다운 & 이동 (Predicate Pushdown / Move-Around / Transitivity)

#### 원리

- “필터는 가능한 한 **가장 아래로 내린다.**”
- 조인 조건에서 **전이 프레디킷(Transitive Predicate)** 이 만들어질 수 있다.
  예: `A=B` and `B=10` ⇒ `A=10` 을 추가해서 **접근 범위를 더 줄임**.

#### 외부조인(OUTER JOIN) 주의

외부조인에서는 NULL 보존 때문에 **전이/푸시가 결과를 바꿀 수 있어 제한된다.**
NOT NULL 제약이 있거나 옵티마이저가 안전하다고 판단할 때만 이동한다.

#### 예제

```sql
SELECT /*+ qb_name(main) */
       s.sales_id, s.amount
FROM   (SELECT /*+ qb_name(v) */ *
        FROM F_SALES
        WHERE sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31') s
JOIN   D_PRODUCT p
  ON   p.prod_id = s.prod_id
WHERE  p.category = 'ELEC';
```

#### 실전 팁

- 차원 테이블(D_PRODUCT)에서의 필터가 사실 테이블(F_SALES)로 내려가면
  **사실 테이블 인덱스 접근의 후보가 급감**한다.
- 반대로, 푸시가 **의미를 깨는 상황(외부조인·NULL·비결정 함수)** 이면
  해당 QB에 `NO_QUERY_TRANSFORMATION` 또는 버전별 `NO_PUSH_PRED` 계열로 보호.

---

### 뷰 머지 (View Merging — Simple / Complex)

#### 원리

뷰/인라인뷰를 **해체해 상위 QB로 끌어올려**
- 조인 재배치
- 인덱스 접근
- 파티션 프루닝
- 스타 변환 적용
기회를 늘린다.
오라클은 뷰 머지를 “단순(Simple) / 복합(Complex)”로 나누며,
복합 머지는 **집계/분석/집합연산이 껴 있으면 제한**된다.

#### Simple View Merge 예

```sql
SELECT /*+ qb_name(main) */
       s.sales_id, p.brand
FROM   (SELECT /*+ qb_name(vs) */ prod_id, sales_id
        FROM F_SALES
        WHERE sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31') s
JOIN   D_PRODUCT p
  ON   p.prod_id = s.prod_id
WHERE  p.brand = 'B0';
```

#### Complex View Merge가 막히는 대표 조건

- 뷰 내부에 `GROUP BY`, `DISTINCT`, 윈도우 함수, `CONNECT BY`, `ROWNUM` 등이 있어
  **상위로 끌어올리면 결과가 달라질 가능성**이 있으면 머지는 금지된다.

#### 제어

- 머지 유도: `MERGE(@vs)`
- 머지 차단: `NO_MERGE(@vs)`
- 보안 이슈 시: `optimizer_secure_view_merging` 확인.

---

### 서브쿼리 언네스트 (Subquery Unnesting)

오라클은 언네스트를 통해 “서브쿼리 기반 논리”를 **조인 기반 논리로 환원**해
더 많은 조인 전략(HJ/SMJ/NL/Bitmap/Star 등)을 열어준다.

#### EXISTS / IN → SEMI JOIN

```sql
SELECT c.cust_id
FROM   D_CUSTOMER c
WHERE  EXISTS (
  SELECT 1
  FROM   F_SALES s
  WHERE  s.cust_id = c.cust_id
  AND    s.sales_dt >= DATE '2024-03-01'
);
```

- 언네스트되면 **SEMI JOIN**(매칭 1개만 찾으면 종료)으로 변환.
- SEMI JOIN은 **중복을 만들지 않는 조인**이므로, 원래 EXISTS 의미와 동치다.

#### NOT EXISTS → ANTI JOIN

```sql
SELECT c.cust_id
FROM   D_CUSTOMER c
WHERE  NOT EXISTS (
  SELECT 1 FROM F_SALES s
  WHERE  s.cust_id = c.cust_id
  AND    s.sales_dt >= DATE '2024-03-01'
);
```
- **ANTI JOIN**은 “매칭이 없을 때만 유지”하는 조인으로 NOT EXISTS와 동치.

#### Scalar Subquery → 조인(+집계)

```sql
SELECT p.prod_id,
       (SELECT SUM(s.amount)
        FROM   F_SALES s
        WHERE  s.prod_id = p.prod_id
        AND    s.sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31') AS m_sum
FROM   D_PRODUCT p;
```

- 언네스트되면 내부적으로 **사전 집계 후 조인** 플랜을 후보로 올린다.
- 스칼라 캐시가 있어도, **외부 로우 수가 커지면** 조인+집계가 더 싸다.

#### 제어

- 강제: `UNNEST(@qb)`
- 차단: `NO_UNNEST(@qb)`
- 특히 NULL 의미(3값 논리)나 상관관계가 민감할 때는 차단이 필요.

---

### OR-EXPAND (USE_CONCAT) / INLIST ITERATOR

#### OR-EXPAND 원리

`OR` 조건은 한 번의 인덱스 경로로 커버하기 어렵다.
옵티마이저는 이를 **`UNION ALL`로 분기**해 각 분기별 최적 경로(다른 인덱스)를 탐색한다.
오라클에서 이 변환이 **OR Expansion**이며 힌트가 `USE_CONCAT`다.

```sql
SELECT /*+ USE_CONCAT */ *
FROM   F_SALES s
WHERE  (s.prod_id = :p1 AND s.sales_dt >= :d1)
    OR (s.cust_id = :c1 AND s.sales_dt >= :d2);
```

내부적으로는

```sql
SELECT * FROM F_SALES s
WHERE  s.prod_id = :p1 AND s.sales_dt >= :d1
UNION ALL
SELECT * FROM F_SALES s
WHERE  s.cust_id = :c1 AND s.sales_dt >= :d2;
```

#### OR-EXPAND가 특히 좋은 상황

- 각 OR 분기에 **서로 다른 인덱스가 명확히 존재**하고
- 분기 선택도가 높아 **각 분기에서 소량 인덱스 탐색**으로 끝나는 경우.

#### 주의: 분기 폭발

OR 조건 개수가 많으면 UNION ALL 분기가 기하급수로 늘어
플랜 후보 탐색/실행이 폭발할 수 있다 → `NO_EXPAND`로 차단.

#### INLIST ITERATOR

`col IN (a,b,c,...)` 는 **한 플랜에서 인덱스 반복 탐색**하는 INLIST ITERATOR로 처리될 수 있다.
OR로 풀지 않아도 비슷한 이득을 본다.

---

### 조인 제거 (Join Elimination / Join Back Elimination)

#### 원리

PK/FK/UNIQUE/NOT NULL 제약과 통계가 충분히 신뢰되면
**결과에 영향을 주지 않는 조인을 삭제**해 입력을 줄인다.

#### 예

```sql
SELECT s.sales_id
FROM   F_SALES s
JOIN   D_PRODUCT p
  ON   p.prod_id = s.prod_id
WHERE  p.brand = 'B0';
```
- `p.brand='B0'`가 사실 테이블로 전이되거나
- 차원 조인이 결과 컬럼에 참여하지 않는다면
  **차원 테이블 조인 자체가 제거**될 수 있다.

#### 실전 관찰 포인트

- 실행계획 Note에 “Join Elimination”이 남는다.
- 제약이 부정확하거나 FK가 비활성화면 **제거하지 않는다**.

---

### 집계 푸시다운 (Group-By Pushdown / Join-Group Transformation)

#### 원리

조인 후 집계를 하는 대신
**사실 테이블에서 먼저 그룹핑/집계 → 축소된 결과를 차원과 조인**하도록 재작성한다.
특히 스타/스노우플레이크에서 입력 폭을 급감시키는 핵심 변환이다.

#### 예(개념)

```sql
SELECT p.category, SUM(s.amount)
FROM   F_SALES s
JOIN   D_PRODUCT p ON p.prod_id = s.prod_id
WHERE  s.sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
GROUP  BY p.category;
```

내부적으로
1) `F_SALES`를 `prod_id`로 먼저 집계
2) 집계 결과(훨씬 적은 행)와 `D_PRODUCT` 조인
형태로 푸시될 수 있다.

#### 언제 유리한가

- 사실 테이블이 매우 크고
- 그룹 키 카디널리티(예: prod_id)가 사실 행 수보다 훨씬 작을 때.

---

### WITH(Subquery Factoring) 변환 — INLINE vs MATERIALIZE (Temp Table Transformation)

#### 원리

CTE는 두 가지 방식으로 처리된다.

- **INLINE**: CTE를 참조 지점에 **복제 삽입**
  - 개별 최적화/프루닝/인덱스 전략이 열릴 수 있음
- **MATERIALIZE(Temp Table Transformation)**: CTE를 **한 번 계산해 TEMP에 저장 후 재사용**
  - 중복 계산 방지
  - 대신 TEMP I/O 비용 발생

#### 예

```sql
WITH sales_m AS (
  SELECT /*+ qb_name(w_sales) */
         prod_id, SUM(amount) sum_amt
  FROM   F_SALES
  WHERE  sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
  GROUP  BY prod_id
)
SELECT /*+ MATERIALIZE */ p.category, SUM(m.sum_amt)
FROM   sales_m m
JOIN   D_PRODUCT p ON p.prod_id = m.prod_id
GROUP  BY p.category;
```

#### 선택 기준

- **CTE 재사용 횟수 ≥ 2** 이거나 내부가 무거우면 `MATERIALIZE`가 대체로 유리
- 1회 참조/가벼운 CTE면 `INLINE`이 유리한 경우가 많다.

---

### 스타 변환 (Star Transformation)

#### 원리

스타 스키마에서
1) 여러 차원 테이블 조건으로 **ROWID 후보 집합**(보통 비트맵/선택도 높은 인덱스)을 만든 뒤
2) 사실 테이블에 **한 번에 진입**하는 변환.
차원 필터 선택도가 높을수록 압도적으로 유리하다.

#### 환경/힌트

- 파라미터: `star_transformation_enabled = TRUE`
- 힌트: `STAR_TRANSFORMATION`

#### 예(개념)

```sql
SELECT /*+ STAR_TRANSFORMATION */ SUM(s.amount)
FROM   F_SALES s
JOIN   D_PRODUCT  p ON p.prod_id = s.prod_id
JOIN   D_CUSTOMER c ON c.cust_id = s.cust_id
WHERE  p.category='ELEC'
AND    p.brand   ='B0'
AND    c.region  ='US-W'
AND    c.tier    ='VIP';
```

---

### 파티션 프루닝 & 파티션-와이즈 조인 (Partition Pruning / Pwise Join)

#### 프루닝 원리

파티션 키 조건을 가능한 한 아래로 내려
**읽을 파티션 목록을 사전에 확정**하고 나머지는 건너뛴다.
프레디킷 푸시/뷰 머지/언네스트와 결합되어 프루닝이 완성되는 경우가 많다.

#### 예

```sql
SELECT SUM(amount)
FROM   F_SALES
WHERE  sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
```

#### Pwise Join 원리

두 테이블이 같은 파티션 키로 분할돼 있으면
**파티션끼리만 조인하도록 계획을 분해**해 로컬/병렬 효율을 높인다.

---

### Top-N 최적화 — STOPKEY Pushdown

#### 원리

상위 N건만 필요하면 **전체 정렬/스캔을 하지 않고**
소트와 카운트에서 **조기 종료(STOPKEY)** 한다.
실행계획 연산자로 `SORT ORDER BY STOPKEY`, `COUNT STOPKEY`가 나타난다.

#### 예

```sql
SELECT *
FROM   F_SALES
WHERE  sales_dt >= DATE '2024-03-01'
ORDER  BY amount DESC
FETCH FIRST 10 ROWS ONLY;
```

- `amount DESC` 인덱스가 있으면 **정렬 없이 Top-N Range Scan**
- 인덱스가 없으면 소트 단계가 `STOPKEY`와 결합되어 **N개 찾는 순간 멈춘다.**

---

### 표현식 단순화 / 상수 폴딩 / 조건 정규화

#### 원리

- 상수 계산을 선행: `amount > 10*2` → `amount > 20`
- 동치 변환으로 인덱스 활용 가능성 확대
- 서로 다른 표현을 “같은 형태”로 맞춰 **카디널리티 추정 오차를 줄임**

#### 예

```sql
SELECT * FROM D_PRODUCT
WHERE NVL(brand,'?') = 'B0';

-- 함수기반 인덱스가 필요하면:
-- CREATE INDEX fx_brand ON D_PRODUCT(NVL(brand,'?'));
```

---

### Materialized View(MV) Query Rewrite

#### 원리

MV가 기반 테이블 질의를 **동치로 대체**해 훨씬 작은 데이터에서 조회하도록 재작성한다.
세션/시스템 파라미터와 MV 속성이 맞아야 하며, 무결성 모드는 다음이 핵심이다:
`QUERY_REWRITE_ENABLED`, `QUERY_REWRITE_INTEGRITY`.

#### 예

```sql
CREATE MATERIALIZED VIEW MV_SALES_CAT
BUILD IMMEDIATE
REFRESH FAST ON COMMIT
ENABLE QUERY REWRITE
AS
SELECT p.category, TRUNC(s.sales_dt,'MM') AS mon, SUM(s.amount) amt
FROM   F_SALES s
JOIN   D_PRODUCT p ON p.prod_id=s.prod_id
GROUP  BY p.category, TRUNC(s.sales_dt,'MM');
```
동일 패턴의 원본 질의는 MV로 자동 리라이트될 수 있다.

---

## 변환이 **결과/의미를 바꿀 수 있는** 위험 지점

### 외부조인과 NULL 보존

- 외부조인에서 프레디킷 전이/푸시는 **NULL 생성 위치가 달라져 결과가 바뀔 수 있다.**
- NOT NULL 제약이 있거나 옵티마이저가 안전하다고 입증할 때만 이동.

### NOT IN vs NOT EXISTS

`NOT IN (subq)` 는 subq에 NULL이 포함되면 전체가 UNKNOWN이 되고,
언네스트/ANTI JOIN으로 단순 치환하면 **의미가 달라질 수 있다.**
실무에서는 **NOT EXISTS가 더 안전**한 패턴이다.

### 집계/중복 의미 변화

- 뷰 머지나 집계 푸시다운은
  **중복 제거/집계 타이밍이 바뀌어 결과가 달라질 가능성**이 있는 구조에서는 제한된다.

### 보안/권한 의미

- 뷰 머지는 보안상 안전하지 않으면 제한되며,
  secure view merging 모드에서만 일어난다.

---

## 변환 진단/관찰/팩트체크

### DISPLAY_CURSOR로 변환 노트 확인

```sql
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, NULL, 'ALLSTATS LAST +NOTE +PREDICATE +ALIAS'
  )
);
```

- **NOTE 영역**: OR Expansion, View Merging, Star Transformation, Join Elimination 등 변환 적용 흔적이 찍힌다.
- **Predicate Information**: `access`/`filter`가 원래 위치에서 이동했는지 확인.

### E-Rows vs A-Rows

변환의 성패는 “이론”이 아니라
**E-Rows(추정)와 A-Rows(실측)가 근접하는지**로 판단해야 한다.
추정이 틀리면 변환도 틀린다.

### Trace

10053 trace는 **교육/최후 진단용**이다. 운영에서는 부하/보안/노이즈 때문에 필요 구간만 제한적으로 쓴다.

---

## 실전 케이스 스터디

### 스칼라 서브쿼리 과다 호출 → 언네스트로 해결

```sql
-- 느린 패턴
SELECT p.prod_id,
       (SELECT SUM(amount)
        FROM   F_SALES s
        WHERE  s.prod_id=p.prod_id
        AND    s.sales_dt BETWEEN :d1 AND :d2) m_sum
FROM   D_PRODUCT p
WHERE  p.category='ELEC';

-- 해결(조인+사전집계)
SELECT p.prod_id, ss.m_sum
FROM   D_PRODUCT p
LEFT JOIN (
  SELECT prod_id, SUM(amount) m_sum
  FROM   F_SALES
  WHERE  sales_dt BETWEEN :d1 AND :d2
  GROUP  BY prod_id
) ss
ON ss.prod_id = p.prod_id
WHERE p.category='ELEC';
```
- 기대 변환: **Scalar Unnest + Group-By Pushdown**
- 효과: 외부 로우 수만큼 반복 호출되는 스칼라 실행을 제거.

### OR 조건으로 인덱스 못 탐 → OR-EXPAND

```sql
SELECT /*+ USE_CONCAT */ *
FROM   F_SALES
WHERE  (prod_id=:p1 AND sales_dt>=:d1)
    OR (cust_id=:c1 AND sales_dt>=:d2);
```
- 분기별 인덱스 경로가 열리면 **랜덤 I/O가 급감**.

### 뷰 머지가 안 되는 경우

- 뷰 내부에 집계/윈도우/ROWNUM이 있으면 Complex View Merge가 막힐 수 있다.
- 이때 CTE를 여러 번 쓰면 `MATERIALIZE`가 오히려 더 싸다.

### 파티션 프루닝 실패 원인

- 파티션 키가 함수로 감싸지면 프루닝이 약해진다.
  예: `TRUNC(sales_dt)=:d`
  → `sales_dt>=:d AND sales_dt<:d+1` 로 정규화 유도.
- 키가 뷰/서브쿼리 안에 숨으면
  **뷰 머지/언네스트가 선행되어야 프루닝이 활성화**될 수 있다.

### Top-N이 느릴 때

- `SORT ORDER BY STOPKEY`가 보이면
  Top-N 조기 종료가 작동 중.
- 없다면
  - 인덱스 정렬 경로가 없거나
  - ORDER BY 표현이 인덱스 정렬을 깨고 있거나
  - 변환이 차단된 상태일 수 있다.

---

## 운영 체크리스트

### 통계/히스토그램/확장 통계

- 변환은 CBO가 “안전하고 이득”하다고 믿을 때만 일어난다.
- 스큐 컬럼은 히스토그램(Top-Frequency/Hybrid)
- 컬럼 그룹은 확장 통계로 결합 선택도를 보정.

### 변환을 활용해야 할 때

- 대량 스칼라 서브쿼리 → `UNNEST`
- 복잡 OR, 분기별 인덱스 → `USE_CONCAT`
- 다회 재사용 CTE → `MATERIALIZE`
- 고선택도 차원 필터 → `STAR_TRANSFORMATION`

### 변환을 막아야 할 때

- 외부조인 NULL 의미 손상 우려
- 뷰 내부 집계/윈도우의 결과 순서/중복 의미가 중요한 경우
- OR-EXPAND 플랜 분기 폭발
→ 대상 QB에 정확히 `NO_MERGE`, `NO_UNNEST`, `NO_EXPAND`로 **국지 차단**.

---

## 부록 — 변환별 “한 줄 요약” 미니 레퍼런스

| 변환 | 핵심 이득 | 성립 관건 | 대표 힌트/파라미터 |
|---|---|---|---|
| 프레디킷 푸시/전이 | 입력 축소, 인덱스 활성 | NOT NULL 안전성, 스큐 통계 | (자동), 필요 시 `NO_QUERY_TRANSFORMATION` |
| 뷰 머지 | 조인 재배치/프루닝 확대 | 뷰 내부 연산(집계/윈도우) | `MERGE` / `NO_MERGE` |
| 언네스트(EXISTS/IN/Scalar) | SEMI/ANTI/조인 후보 확대 | 상관관계/NULL/중복 | `UNNEST` / `NO_UNNEST` |
| OR-EXPAND | 분기별 최적 인덱스 | 분기 선택도, 분기 수 | `USE_CONCAT` / `NO_EXPAND` |
| 조인 제거 | 불필요 조인 삭제 | PK/FK/UNIQUE/NN | (자동) |
| 집계 푸시다운 | 조인 전 축소 | GROUP 키 카디널리티 | (자동) |
| CTE 물질화 | 중복 계산 제거 | 참조 횟수, TEMP 비용 | `MATERIALIZE` / `INLINE` |
| 스타 변환 | 차원 필터 결합 후 사실 접근 | 차원 선택도/인덱스 | `STAR_TRANSFORMATION`, `star_transformation_enabled` |
| 파티션 프루닝 | 파티션 I/O 절감 | 키 표현식 정규화 | (자동) |
| Pwise Join | 파티션 로컬/병렬 | 동일 파티션 키 | (자동/병렬) |
| Stopkey | Top-N 조기 종료 | ORDER BY-인덱스 정렬 | (자동), 연산자 STOPKEY |
| MV Rewrite | MV로 즉시 응답 | MV 신선도/무결성 | `QUERY_REWRITE_*` |



---

## 결론

- 쿼리 변환은 **“같은 결과를 내는 SQL을 더 좋은 모양으로 바꿔서 CBO가 싸게 실행하도록 하는 단계”**다.
- 변환은 **통계가 정확할수록 과감해지고**, 통계가 틀리면 변환도 틀린다.
- 성능 문제를 만나면
  1) **변환 적용 여부를 Note/Predicate로 확인**하고
  2) **E-Rows vs A-Rows로 추정 품질을 검증**하며
  3) 필요하면 **QB 단위로 국지 힌트 제어**하라.
