---
layout: post
title: C - 파일 입출력
date: 2024-08-27 19:20:23 +0900
category: C
---
# 파일 입출력 (File I/O)

## 한 화면 요약 (필수 10줄)

```c
FILE *fp = fopen("data.bin","rb");           // 1) 열기
if (!fp) { perror("fopen"); return 1; }      // 2) 오류 확인

unsigned char buf[8192];                     // 3) 버퍼
size_t n;
while ((n = fread(buf, 1, sizeof buf, fp)) > 0) {
    /* 처리 or fwrite(...) */
}
if (ferror(fp)) { perror("fread"); }         // 4) 상태 확인
fclose(fp);                                  // 5) 닫기

// 텍스트 줄 읽기
char line[1024];
while (fgets(line, sizeof line, fp)) { /* line 처리 */ }
```

---

## 파일 I/O 기본 개념

```c
#include <stdio.h>

FILE *fp;   // FILE: 구현체의 파일 제어 블록(버퍼/상태 포함)
```

- `FILE*`는 **스트림**(버퍼+상태)의 핸들입니다.
- C의 표준 스트림: `stdin`, `stdout`, `stderr`.

### 텍스트와 바이너리 모드

- **Windows**: 텍스트 모드에서 `\n` ↔ 파일의 `\r\n` 변환. 이진 데이터는 반드시 `"b"` 사용.
- **POSIX**: `"b"` 유무가 실질적으로 동일하지만 **이식성** 위해 명시 권장.

---

## 파일 열기 `fopen()`

```c
FILE *fopen(const char *filename, const char *mode);
```

| 모드    | 의미(텍스트)                       | 이진 모드 예 |
|---------|-------------------------------------|--------------|
| `"r"`   | 읽기 전용(없으면 실패)              | `"rb"`       |
| `"w"`   | 쓰기 전용(새로 생성, 기존 삭제)     | `"wb"`       |
| `"a"`   | 추가 전용(항상 끝에 덧붙임)         | `"ab"`       |
| `"r+"`  | 읽기/쓰기(기존 유지)                | `"r+b"`      |
| `"w+"`  | 읽기/쓰기(기존 삭제)                | `"w+b"`      |
| `"a+"`  | 읽기/추가(읽기+끝에만 쓰기)         | `"a+b"`      |
| `"wx"`  | C11: **배타적 생성**(이미 있으면 실패)| `"wbx"`     |

```c
FILE *fp = fopen("data.txt","w");
if (!fp) { perror("fopen"); /* errno 기반 복구 */ }
```

> **윈도우에서 UTF-8 파일명**: MSVC에선 `_wfopen(L"파일명", L"rb")` + UTF-16 경로가 보편적입니다.

---

## 쓰기 (텍스트)

### `fprintf` / `fputs` / `fputc`

```c
fprintf(fp, "이름:%s 나이:%d\n", name, age);
fputs("Hello\n", fp);
fputc('A', fp);
```

### 출력 버퍼 플러시 `fflush`

```c
fprintf(fp, "중간 저장...\n");
fflush(fp);  // 디스크로 밀어넣기(출력 스트림에만 의미적)
```

- **쓰기→읽기**를 같은 스트림에서 이어서 할 때는 `fflush` 또는 위치이동(`fseek/rewind`)이 **필수**입니다(표준 규칙, 10.1절 참고).

---

## 읽기 (텍스트)

### `fscanf` — 폭 제한 필수

```c
char name[20]; int age;
if (fscanf(fp, "%19s %d", name, &age) == 2) { /* ok */ }
```
- `%s`는 공백에서 멈춤. **반드시 너비 지정**(`%19s`)로 오버런 방지.
- 복잡한 포맷은 `fgets` + `strtok/strtol` 조합이 안전·유연합니다.

### 줄 단위 `fgets`

```c
char line[256];
while (fgets(line, sizeof line, fp)) {
    // line 끝의 '\n'은 있을 수도/없을 수도
}
```

### 문자 단위 `fgetc`

```c
int ch;
while ((ch = fgetc(fp)) != EOF) { /* ch는 int */ }
```

> **루프 조건에 `feof()` 쓰지 마세요.** `feof`는 실패/EOF **발생 후**에만 참이 됩니다.

---

## 닫기 `fclose()`

```c
if (fclose(fp) == EOF) { perror("fclose"); }
```
- 닫을 때 버퍼의 **마지막 flush**가 일어납니다. 실패 시 데이터 유실 가능.

---

## — 구조체 목록 저장/로드

```c
#include <stdio.h>
#include <string.h>

typedef struct { char name[20]; int age; } Person;

int save_people(const char *path, const Person *a, size_t n){
    FILE *fp = fopen(path,"w");
    if (!fp) { perror("fopen"); return -1; }
    for (size_t i=0;i<n;i++)
        if (fprintf(fp, "%s %d\n", a[i].name, a[i].age) < 0) {
            perror("fprintf"); fclose(fp); return -1;
        }
    if (fclose(fp)==EOF) { perror("fclose"); return -1; }
    return 0;
}

int load_people(const char *path){
    FILE *fp = fopen(path,"r");
    if (!fp) { perror("fopen"); return -1; }
    Person p;
    while (fscanf(fp, "%19s %d", p.name, &p.age) == 2) {
        printf("%s(%d)\n", p.name, p.age);
    }
    if (ferror(fp)) { perror("fscanf"); }
    fclose(fp);
    return 0;
}
```

---

## — `fwrite`/`fread`

```c
size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);
size_t fread(void *ptr, size_t size, size_t count, FILE *stream);
```

### 바이트 기반 안전 루프(권장)

```c
unsigned char buf[4096];
size_t n;
while ((n = fread(buf, 1, sizeof buf, fp)) > 0) {
    if (fwrite(buf, 1, n, out) != n) { perror("fwrite"); break; }
}
if (ferror(fp)) perror("fread");
```

### **구조체 통째쓰기 주의**

- **패딩/정렬/엔디안/크기** 차이로 **이식성 없음**.
- 장기 보관/교환 포맷은 **필드별 직렬화**를 사용하세요(11장).

---

## 파일 위치 이동 — `fseek/ftell/rewind`

```c
int fseek(FILE *stream, long offset, int origin); // 작은 파일 전제
long ftell(FILE *stream);
void rewind(FILE *stream);
```

- `origin`: `SEEK_SET`(처음), `SEEK_CUR`(현재), `SEEK_END`(끝).
- **Windows/대용량(>2GB)**: MSVC `_fseeki64/_ftelli64`.
  **POSIX**: `fseeko/ftello`(오프셋 `off_t`).

```c
// POSIX 대용량 예
#include <stdio.h>

int main(void){
    FILE *fp = fopen("big.bin","rb");
    if(!fp) return 1;
    if (fseeko(fp, (off_t)5*1024*1024*1024, SEEK_SET) != 0) { /* 이동 실패 */ }
    off_t pos = ftello(fp);
    fclose(fp);
}
```

> **동일 스트림에서 읽기↔쓰기 전환** 시:
> **반드시** `fflush`(쓰기 후) 또는 **파일 위치 이동 호출**(둘 중 하나)을 수행해야 합니다.

---

## 파일 상태 — `feof`, `ferror`, `clearerr`

```c
if (feof(fp))   puts("EOF 도달");
if (ferror(fp)) perror("스트림 오류");
clearerr(fp);   // 상태 플래그 클리어
```

- 루프 조건은 **반환값 기반**:
  - 텍스트: `while (fgets(...))`
  - 바이너리: `while ((n=fread(...))>0)`

---

## / `tmpnam()`(지양)

```c
FILE *tmp = tmpfile(); // 닫히면 자동 삭제(일부 OS는 프로세스 종료 시)
fputs("temp\n", tmp);
rewind(tmp);
char buf[16]; fgets(buf, sizeof buf, tmp);
fclose(tmp);
```

- 파일명이 필요하면 **플랫폼 안전 API** 사용(예: POSIX `mkstemp`), `tmpnam`은 **경쟁 상태** 위험.

---

## — 패딩·엔디안·부동소수

문제점:
- **패딩/정렬**: 구현별 상이.
- **엔디안**: 리틀/빅.
- **`float/double`**: IEEE754 가정 필요, 그대로 쓰기 금지.

### 안전한 바이너리 인코딩 예

```c
#include <stdint.h>
#include <string.h>

// 호스트→리틀엔디안으로 쓰기
static void put_u32_le(uint32_t x, FILE *fp){
    unsigned char b[4] = { x&0xFF, (x>>8)&0xFF, (x>>16)&0xFF, (x>>24)&0xFF };
    fwrite(b,1,4,fp);
}

typedef struct { char name[20]; int32_t age; float height; } Person;

// float는 바이트 복사
static void put_f32_le(float f, FILE *fp){
    uint32_t u=0; memcpy(&u,&f,4); put_u32_le(u,fp);
}

int write_person_le(const Person *p, FILE *fp){
    fwrite(p->name,1,20,fp);                 // 고정 길이
    put_u32_le((uint32_t)p->age, fp);
    put_f32_le(p->height, fp);
    return ferror(fp) ? -1 : 0;
}
```

> 텍스트 포맷(JSON/CSV 등)은 사람이 읽기 좋지만 크기↑.
> 바이너리는 필드별 명시적 인코딩으로 **포맷 문서화**가 필수입니다.

---

## 안전한 읽기/쓰기 패턴 모음

### 텍스트 파일 줄 반복

```c
char line[4096];
while (fgets(line, sizeof line, fp)) {
    // 파싱
}
if (ferror(fp)) perror("fgets");
```

### 바이너리 전체 복사(파이프형)

```c
unsigned char b[16384];
size_t n;
while ((n=fread(b,1,sizeof b,in)) > 0) {
    size_t off=0;
    while (off<n) {
        size_t m = fwrite(b+off,1,n-off,out);
        if (m==0) { perror("fwrite"); goto FAIL; }
        off += m;
    }
}
if (ferror(in)) perror("fread");
FAIL: ;
```

### CSV 안전 파싱(간단형)

```c
char *tok, *save=NULL;
for (tok=strtok_r(line, ",\r\n", &save); tok; tok=strtok_r(NULL,",\r\n",&save)){
    /* tok 사용 */
}
```

---

## 성능·버퍼링 — `setvbuf`/`setbuf`

```c
// 열린 직후에 버퍼 설정(그 이후 변경 불가)
char bigbuf[1<<16];
setvbuf(fp, bigbuf, _IOFBF, sizeof bigbuf);  // 전버퍼링(full)
```

- 모드: `_IONBF`(무버퍼), `_IOLBF`(줄버퍼; 텍스트 콘솔), `_IOFBF`(전버퍼).
- `stderr`는 보통 **무버퍼/줄버퍼**(즉시 출력 성격).

> **병목이 I/O일 때** 큰 버퍼는 체감 향상을 줍니다. 다만 **충돌/크래시 시 손실**을 줄이려면 적절한 flush 전략 필요.

---

## 동시 읽기/쓰기 전환 규칙(중요)

같은 스트림에서 **읽기와 쓰기를 번갈아** 할 때:

- **쓰기 후 읽기**: `fflush(fp)` **또는** 파일 위치 함수(`fseek/rewind/fsetpos`).
- **읽기 후 쓰기**: 반드시 **파일 위치 함수 호출**이 필요(표준 규정).

```c
fprintf(fp,"header\n");
fflush(fp);               // 또는 fseek(fp,0,SEEK_CUR);
char line[64];
fgets(line,sizeof line,fp);
```

---

## 에러 처리와 복구

- 언제나 **반환값 검사**: `NULL`/`EOF`/카운트/음수.
- 상세 원인: `errno` + `perror`/`strerror`.
- 실패 시 **부분 쓰기/손상 파일** 가능 → **임시 파일에 쓰고 `rename`** 전략.

```c
FILE *tmp = fopen("data.tmp","wb");
if (!tmp) return -1;
/* 쓰기 */
if (fclose(tmp)==EOF) { remove("data.tmp"); return -1; }
if (rename("data.tmp","data.bin") != 0) { perror("rename"); }
```

---

## 라인엔딩/인코딩/로케일

- CRLF(`\r\n`) vs LF(`\n`): 텍스트 모드 변환/혼합 주의.
- 소스/데이터 인코딩(UTF-8 vs EUC-KR 등): **입출력 시 변환은 별도 처리**(아이콘브이, Win32 Wide API 등).
- `setlocale(LC_ALL, "")`로 지역화 영향(숫자 소수점 등) 주의.

---

## 수식으로 보는 I/O 처리량(대략)

버퍼 크기 $$B$$, 파일 크기 $$N$$ 일 때,
IO 호출 횟수는
$$
\left\lceil \frac{N}{B} \right\rceil
$$
이며, 호출 오버헤드 $$O\!\left(\frac{N}{B}\right)$$, 총 복사 비용은 $$O(N)$$.
**큰 버퍼**는 호출 횟수를 줄여 효율↑.

---

## 미니 프로젝트 1 — 안전한 파일 복사기

```c
#include <stdio.h>
#include <errno.h>

int copy_file(const char *src, const char *dst){
    FILE *in = fopen(src,"rb");
    if(!in){ perror("fopen src"); return -1; }
    FILE *out = fopen(dst,"wb");
    if(!out){ perror("fopen dst"); fclose(in); return -1; }

    unsigned char b[1<<16];
    size_t n;
    while ((n=fread(b,1,sizeof b,in)) > 0) {
        size_t w=0;
        while (w<n) {
            size_t m=fwrite(b+w,1,n-w,out);
            if (m==0){ perror("fwrite"); fclose(in); fclose(out); return -1; }
            w+=m;
        }
    }
    if (ferror(in)) { perror("fread"); }

    if (fclose(in)==EOF) perror("fclose in");
    if (fclose(out)==EOF) { perror("fclose out"); return -1; }
    return 0;
}
```

---

## 미니 프로젝트 2 — 구조체의 안전 직렬화(LE)

```c
#include <stdio.h>
#include <stdint.h>
#include <string.h>

typedef struct { char name[20]; int32_t age; float height; } Person;

static void put_u32_le(uint32_t x, FILE *fp){
    unsigned char b[4]={x&0xFF,(x>>8)&0xFF,(x>>16)&0xFF,(x>>24)&0xFF};
    fwrite(b,1,4,fp);
}
static void put_f32_le(float f, FILE *fp){
    uint32_t u; memcpy(&u,&f,4); put_u32_le(u,fp);
}
static int write_person(const Person *p, FILE *fp){
    if (fwrite(p->name,1,20,fp)!=20) return -1;
    put_u32_le((uint32_t)p->age,fp);
    put_f32_le(p->height,fp);
    return ferror(fp)?-1:0;
}
```

---

## 고급 팁

- **표준 스트림 재지정**: `freopen(NULL,"wb", stdout)` 등으로 바이너리 전환(윈도우).
- **파일 디스크립터 연동**: POSIX `fileno(fp)` / `fdopen(fd,"rb")`.
- **스레드**: 대부분의 구현에서 `FILE*` 연산은 내부 잠금이 있으나, **동일 스트림 동시 접근**은 조심. 필요 시 `flockfile/funlockfile`.

---

## 체크리스트

- [ ] `fopen` 결과 `NULL` 체크, `perror` 로깅.
- [ ] 텍스트는 **줄 읽기는 `fgets`**, 토큰은 **너비 제한 `fscanf`** 또는 파서.
- [ ] 바이너리는 **바이트 단위 루프** + 반환값 검사.
- [ ] **`feof`로 루프 돌리지 않기**(반환값 기반).
- [ ] **읽기↔쓰기 전환 시 `fflush`/`fseek` 규칙** 지키기.
- [ ] 이식성 저장: **필드별 직렬화 + 엔디안 명시**.
- [ ] 대용량: **`fseeko/ftello`(POSIX) / `_fseeki64`(Win)**.
- [ ] 성능: `setvbuf`로 **버퍼 최적화**.
- [ ] 임시파일: **`tmpfile` 또는 `mkstemp` 계열**, `tmpnam` 지양.
- [ ] 종료 경로: **항상 `fclose`**, 오류 시 **임시→원자적 `rename`**.

---

## 요약

| 주제 | 핵심 |
|---|---|
| 열기/모드 | `"r/w/a"` + `"b"` 이진, C11 `"x"` 배타적 생성 |
| 텍스트 | `fprintf/fgets/fscanf(폭제한)` |
| 바이너리 | `fread/fwrite` + **바이트 루프** |
| 위치 | `fseek/ftell/rewind`, 대용량은 `fseeko/ftello` |
| 상태 | `feof/ferror/clearerr` |
| 전환 규칙 | 쓰기→읽기: `fflush`/seek, 읽기→쓰기: seek 필요 |
| 직렬화 | 구조체 통짜쓰기 금지, **필드별·엔디안** |
| 버퍼/성능 | `setvbuf`로 조절, 큰 버퍼 유효 |
| 임시파일 | `tmpfile`(권장), 안전한 rename 커밋 |
