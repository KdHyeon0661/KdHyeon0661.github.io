---
layout: post
title: C - 파일 입출력
date: 2024-08-27 19:20:23 +0900
category: C
---
# 파일 입출력 (File I/O): C 언어에서 데이터 영속성 다루기

## 파일 입출력이란?

파일 입출력은 프로그램이 데이터를 디스크에 저장하거나 디스크에서 읽어오는 과정입니다. 이는 프로그램의 실행이 종료된 후에도 데이터를 보존할 수 있게 해주며, 대용량 데이터를 처리할 때 메모리 제한을 극복하는 데 필수적입니다.

### 기본 개념 이해하기

```c
#include <stdio.h>

int main(void) {
    // 파일 입출력의 5가지 기본 단계
    // 1. 파일 열기
    FILE *file = fopen("data.txt", "r");
    
    // 2. 오류 확인
    if (file == NULL) {
        perror("파일 열기 실패");
        return 1;
    }
    
    // 3. 파일 작업 수행
    char buffer[100];
    while (fgets(buffer, sizeof(buffer), file) != NULL) {
        printf("%s", buffer);
    }
    
    // 4. 상태 확인
    if (ferror(file)) {
        perror("파일 읽기 중 오류 발생");
    }
    
    // 5. 파일 닫기
    fclose(file);
    
    return 0;
}
```

## 파일 열기: 다양한 모드 이해하기

파일을 열 때는 어떻게 사용할지에 따라 적절한 모드를 선택해야 합니다:

```c
#include <stdio.h>

int main(void) {
    // 다양한 파일 열기 모드 예제
    
    // 1. 읽기 모드 (파일이 없으면 실패)
    FILE *read_file = fopen("input.txt", "r");
    if (read_file == NULL) {
        printf("input.txt 파일을 찾을 수 없습니다.\n");
    } else {
        fclose(read_file);
    }
    
    // 2. 쓰기 모드 (파일이 있으면 덮어쓰기, 없으면 새로 생성)
    FILE *write_file = fopen("output.txt", "w");
    if (write_file != NULL) {
        fprintf(write_file, "이것은 새 파일입니다.\n");
        fclose(write_file);
    }
    
    // 3. 추가 모드 (파일 끝에 내용 추가)
    FILE *append_file = fopen("log.txt", "a");
    if (append_file != NULL) {
        fprintf(append_file, "로그 항목 추가\n");
        fclose(append_file);
    }
    
    // 4. 읽기/쓰기 모드 (파일을 읽고 쓸 수 있음)
    FILE *rw_file = fopen("data.bin", "r+b");  // 바이너리 모드
    if (rw_file != NULL) {
        // 파일 작업...
        fclose(rw_file);
    }
    
    return 0;
}
```

### 주요 파일 모드 정리

| 모드 | 설명 | 파일 존재 시 | 파일 없을 시 |
|------|------|--------------|--------------|
| `"r"` | 읽기 전용 | 정상 열림 | 실패 |
| `"w"` | 쓰기 전용 | 내용 삭제 후 열림 | 새 파일 생성 |
| `"a"` | 추가 모드 | 파일 끝에 쓰기 | 새 파일 생성 |
| `"r+"` | 읽기/쓰기 | 정상 열림 | 실패 |
| `"w+"` | 읽기/쓰기 | 내용 삭제 후 열림 | 새 파일 생성 |
| `"a+"` | 읽기/추가 | 파일 끝에 쓰기, 읽기는 임의 위치 | 새 파일 생성 |
| `"rb"` | 바이너리 읽기 | 정상 열림 | 실패 |
| `"wb"` | 바이너리 쓰기 | 내용 삭제 후 열림 | 새 파일 생성 |

**중요**: 텍스트 파일과 바이너리 파일의 차이를 이해해야 합니다. 윈도우에서는 텍스트 모드에서 줄바꿈 문자(`\n`)가 `\r\n`으로 변환됩니다. 이미지나 압축 파일 같은 바이너리 데이터는 반드시 `"b"` 모드로 열어야 합니다.

## 텍스트 파일 입출력

### 텍스트 파일 쓰기

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    // 학생 정보를 파일에 저장
    FILE *file = fopen("students.txt", "w");
    
    if (file == NULL) {
        printf("파일을 생성할 수 없습니다.\n");
        return 1;
    }
    
    // 다양한 방법으로 텍스트 쓰기
    fprintf(file, "=== 학생 명단 ===\n\n");
    
    // fputs 사용
    fputs("이름: 홍길동\n", file);
    fprintf(file, "나이: %d\n", 20);
    fprintf(file, "학점: %.2f\n\n", 3.85);
    
    // fputc 사용 (문자 단위 쓰기)
    fputs("이름: 김철수\n", file);
    fputs("나이: ", file);
    
    // 숫자를 문자로 변환하여 쓰기
    int age = 22;
    char age_str[10];
    sprintf(age_str, "%d", age);
    for (int i = 0; age_str[i] != '\0'; i++) {
        fputc(age_str[i], file);
    }
    fputc('\n', file);
    
    fprintf(file, "학점: %.2f\n", 3.72);
    
    // 버퍼 플러시 (데이터를 즉시 디스크에 쓰기)
    fflush(file);
    
    printf("파일 쓰기 완료. 총 %ld바이트 기록됨.\n", ftell(file));
    
    fclose(file);
    return 0;
}
```

### 텍스트 파일 읽기

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 256

int main(void) {
    FILE *file = fopen("students.txt", "r");
    
    if (file == NULL) {
        printf("파일을 열 수 없습니다.\n");
        return 1;
    }
    
    printf("=== 파일 내용 읽기 ===\n\n");
    
    // 방법 1: fgets를 사용한 줄 단위 읽기 (가장 안전한 방법)
    char line[MAX_LINE_LENGTH];
    int line_number = 1;
    
    printf("fgets를 사용한 읽기:\n");
    while (fgets(line, sizeof(line), file) != NULL) {
        // 개행 문자 제거 (선택사항)
        size_t len = strlen(line);
        if (len > 0 && line[len - 1] == '\n') {
            line[len - 1] = '\0';
        }
        
        printf("%3d: %s\n", line_number++, line);
    }
    
    // 파일 끝까지 읽었는지 확인
    if (feof(file)) {
        printf("\n파일 끝에 도달했습니다.\n");
    }
    
    // 오류 확인
    if (ferror(file)) {
        printf("파일 읽기 중 오류가 발생했습니다.\n");
    }
    
    // 파일 포인터를 처음으로 이동
    rewind(file);
    
    printf("\n\n=== fscanf를 사용한 읽기 ===\n");
    
    // 방법 2: fscanf를 사용한 형식화된 읽기
    char name1[50], name2[50];
    int age1, age2;
    float gpa1, gpa2;
    
    // 헤더 줄 건너뛰기
    fgets(line, sizeof(line), file);  // "=== 학생 명단 ==="
    fgets(line, sizeof(line), file);  // 빈 줄
    
    // 형식에 맞는 데이터 읽기
    if (fscanf(file, "이름: %49s\n", name1) == 1) {
        printf("이름: %s\n", name1);
    }
    
    if (fscanf(file, "나이: %d\n", &age1) == 1) {
        printf("나이: %d\n", age1);
    }
    
    if (fscanf(file, "학점: %f\n", &gpa1) == 1) {
        printf("학점: %.2f\n\n", gpa1);
    }
    
    fclose(file);
    return 0;
}
```

### 안전한 텍스트 파일 입력 처리

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 안전한 문자열 입력 함수
void safe_input(char *prompt, char *buffer, size_t buffer_size) {
    printf("%s", prompt);
    
    if (fgets(buffer, buffer_size, stdin) == NULL) {
        buffer[0] = '\0';
        return;
    }
    
    // 개행 문자 제거
    size_t len = strlen(buffer);
    if (len > 0 && buffer[len - 1] == '\n') {
        buffer[len - 1] = '\0';
    }
}

// CSV 형식으로 데이터 저장
void save_to_csv(const char *filename) {
    FILE *file = fopen(filename, "a");  // 추가 모드
    
    if (file == NULL) {
        printf("파일을 열 수 없습니다.\n");
        return;
    }
    
    char name[100];
    char age_str[20];
    char gpa_str[20];
    
    safe_input("이름: ", name, sizeof(name));
    safe_input("나이: ", age_str, sizeof(age_str));
    safe_input("학점: ", gpa_str, sizeof(gpa_str));
    
    // CSV 형식으로 저장 (쉼표로 구분)
    fprintf(file, "%s,%s,%s\n", name, age_str, gpa_str);
    
    fclose(file);
    printf("데이터가 저장되었습니다.\n");
}

// CSV 파일 읽기
void read_csv(const char *filename) {
    FILE *file = fopen(filename, "r");
    
    if (file == NULL) {
        printf("파일을 열 수 없습니다.\n");
        return;
    }
    
    printf("\n=== CSV 파일 내용 ===\n");
    printf("%-20s %-10s %-10s\n", "이름", "나이", "학점");
    printf("----------------------------------------\n");
    
    char line[256];
    int record_count = 0;
    
    while (fgets(line, sizeof(line), file) != NULL) {
        // 개행 문자 제거
        line[strcspn(line, "\n")] = '\0';
        
        // 쉼표로 토큰 분리
        char *name = strtok(line, ",");
        char *age_str = strtok(NULL, ",");
        char *gpa_str = strtok(NULL, ",");
        
        if (name != NULL && age_str != NULL && gpa_str != NULL) {
            printf("%-20s %-10s %-10s\n", name, age_str, gpa_str);
            record_count++;
        }
    }
    
    fclose(file);
    printf("\n총 %d개의 레코드를 읽었습니다.\n", record_count);
}

int main(void) {
    // 데이터 추가
    save_to_csv("students.csv");
    save_to_csv("students.csv");
    
    // 데이터 읽기
    read_csv("students.csv");
    
    return 0;
}
```

## 바이너리 파일 입출력

바이너리 파일은 텍스트가 아닌 이진 데이터를 저장하는 데 사용됩니다. 이미지, 오디오, 비디오 파일이나 데이터베이스 파일 등이 이에 해당합니다.

### 기본 바이너리 입출력

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUFFER_SIZE 1024

// 파일 복사 함수 (바이너리 모드)
int copy_file_binary(const char *source_path, const char *dest_path) {
    FILE *source = fopen(source_path, "rb");  // 바이너리 읽기 모드
    FILE *dest = fopen(dest_path, "wb");      // 바이너리 쓰기 모드
    
    if (source == NULL) {
        printf("원본 파일을 열 수 없습니다: %s\n", source_path);
        return 0;
    }
    
    if (dest == NULL) {
        printf("대상 파일을 생성할 수 없습니다: %s\n", dest_path);
        fclose(source);
        return 0;
    }
    
    unsigned char buffer[BUFFER_SIZE];
    size_t bytes_read;
    size_t total_bytes = 0;
    
    // 버퍼를 사용하여 효율적으로 복사
    while ((bytes_read = fread(buffer, 1, BUFFER_SIZE, source)) > 0) {
        size_t bytes_written = fwrite(buffer, 1, bytes_read, dest);
        
        if (bytes_written != bytes_read) {
            printf("파일 쓰기 오류\n");
            fclose(source);
            fclose(dest);
            return 0;
        }
        
        total_bytes += bytes_written;
    }
    
    // 오류 확인
    if (ferror(source)) {
        printf("파일 읽기 오류\n");
    }
    
    printf("파일 복사 완료: %s -> %s (%zu 바이트)\n", 
           source_path, dest_path, total_bytes);
    
    fclose(source);
    fclose(dest);
    
    return 1;
}

// 간단한 데이터 구조체 정의
typedef struct {
    int id;
    char name[50];
    float score;
} Student;

// 구조체 배열을 바이너리 파일로 저장
int save_students_binary(const char *filename, Student students[], int count) {
    FILE *file = fopen(filename, "wb");
    
    if (file == NULL) {
        printf("파일을 생성할 수 없습니다.\n");
        return 0;
    }
    
    // 구조체 배열 전체를 한 번에 쓰기
    size_t written = fwrite(students, sizeof(Student), count, file);
    
    if (written != count) {
        printf("데이터 쓰기 실패 (예상: %d, 실제: %zu)\n", count, written);
        fclose(file);
        return 0;
    }
    
    fclose(file);
    printf("%d명의 학생 데이터를 저장했습니다.\n", count);
    
    return 1;
}

// 바이너리 파일에서 구조체 배열 읽기
int load_students_binary(const char *filename, Student students[], int max_count) {
    FILE *file = fopen(filename, "rb");
    
    if (file == NULL) {
        printf("파일을 열 수 없습니다.\n");
        return 0;
    }
    
    // 파일 크기 확인
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    rewind(file);
    
    // 파일에 저장된 구조체 수 계산
    int count = file_size / sizeof(Student);
    
    if (count > max_count) {
        printf("경고: 파일에 %d개의 레코드가 있지만 %d개만 읽습니다.\n", count, max_count);
        count = max_count;
    }
    
    // 구조체 배열 읽기
    size_t read = fread(students, sizeof(Student), count, file);
    
    if (read != count) {
        printf("데이터 읽기 실패 (예상: %d, 실제: %zu)\n", count, read);
        fclose(file);
        return 0;
    }
    
    fclose(file);
    
    // 읽은 데이터 출력
    printf("\n=== 읽은 학생 데이터 ===\n");
    for (int i = 0; i < count; i++) {
        printf("학생 %d: ID=%d, 이름=%s, 점수=%.2f\n", 
               i + 1, students[i].id, students[i].name, students[i].score);
    }
    
    return count;
}

int main(void) {
    // 파일 복사 테스트
    copy_file_binary("source.jpg", "copy.jpg");
    
    // 구조체 배열 준비
    Student students[3] = {
        {1, "홍길동", 85.5},
        {2, "김철수", 92.0},
        {3, "이영희", 78.5}
    };
    
    // 구조체 배열 저장
    save_students_binary("students.dat", students, 3);
    
    // 구조체 배열 읽기
    Student loaded_students[10];
    int count = load_students_binary("students.dat", loaded_students, 10);
    
    printf("\n총 %d명의 학생 데이터를 읽었습니다.\n", count);
    
    return 0;
}
```

### 바이너리 파일에서 임의 접근하기

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int id;
    char name[30];
    double salary;
} Employee;

// 직원 정보를 파일에 추가
void add_employee(FILE *file) {
    Employee emp;
    
    printf("\n=== 새 직원 추가 ===\n");
    printf("ID: ");
    scanf("%d", &emp.id);
    getchar();  // 개행 문자 처리
    
    printf("이름: ");
    fgets(emp.name, sizeof(emp.name), stdin);
    // 개행 문자 제거
    emp.name[strcspn(emp.name, "\n")] = '\0';
    
    printf("급여: ");
    scanf("%lf", &emp.salary);
    
    // 파일 끝으로 이동하여 추가
    fseek(file, 0, SEEK_END);
    
    // 구조체 쓰기
    fwrite(&emp, sizeof(Employee), 1, file);
    
    printf("직원 정보가 저장되었습니다.\n");
}

// 특정 ID의 직원 정보 검색
void find_employee(FILE *file, int id) {
    Employee emp;
    
    // 파일 처음으로 이동
    rewind(file);
    
    printf("\n=== ID %d 검색 ===\n", id);
    
    while (fread(&emp, sizeof(Employee), 1, file) == 1) {
        if (emp.id == id) {
            printf("찾았습니다!\n");
            printf("ID: %d\n", emp.id);
            printf("이름: %s\n", emp.name);
            printf("급여: %.2lf\n", emp.salary);
            return;
        }
    }
    
    printf("ID %d에 해당하는 직원을 찾을 수 없습니다.\n", id);
}

// 모든 직원 정보 출력
void list_all_employees(FILE *file) {
    Employee emp;
    int count = 0;
    
    // 파일 처음으로 이동
    rewind(file);
    
    printf("\n=== 모든 직원 목록 ===\n");
    
    while (fread(&emp, sizeof(Employee), 1, file) == 1) {
        printf("\n직원 #%d:\n", ++count);
        printf("  ID: %d\n", emp.id);
        printf("  이름: %s\n", emp.name);
        printf("  급여: %.2lf\n", emp.salary);
    }
    
    if (count == 0) {
        printf("저장된 직원 정보가 없습니다.\n");
    } else {
        printf("\n총 %d명의 직원이 있습니다.\n", count);
    }
}

// 특정 ID의 직원 정보 업데이트
void update_employee(FILE *file, int id) {
    Employee emp;
    long position;
    
    // 파일 처음으로 이동
    rewind(file);
    
    while (1) {
        // 현재 위치 저장
        position = ftell(file);
        
        // 레코드 읽기 시도
        if (fread(&emp, sizeof(Employee), 1, file) != 1) {
            break;  // 파일 끝
        }
        
        if (emp.id == id) {
            printf("\n=== 직원 정보 수정 (ID: %d) ===\n", id);
            printf("현재 이름: %s\n", emp.name);
            printf("새 이름: ");
            getchar();  // 개행 문자 처리
            fgets(emp.name, sizeof(emp.name), stdin);
            emp.name[strcspn(emp.name, "\n")] = '\0';
            
            printf("현재 급여: %.2lf\n", emp.salary);
            printf("새 급여: ");
            scanf("%lf", &emp.salary);
            
            // 이전 위치로 이동
            fseek(file, position, SEEK_SET);
            
            // 수정된 레코드 쓰기
            fwrite(&emp, sizeof(Employee), 1, file);
            
            printf("직원 정보가 수정되었습니다.\n");
            return;
        }
    }
    
    printf("ID %d에 해당하는 직원을 찾을 수 없습니다.\n", id);
}

int main(void) {
    FILE *file = fopen("employees.dat", "r+b");  // 읽기/쓰기, 바이너리
    
    if (file == NULL) {
        // 파일이 없으면 새로 생성
        file = fopen("employees.dat", "w+b");
        if (file == NULL) {
            printf("파일을 생성할 수 없습니다.\n");
            return 1;
        }
        printf("새 데이터 파일을 생성했습니다.\n");
    } else {
        printf("기존 데이터 파일을 열었습니다.\n");
    }
    
    int choice;
    
    do {
        printf("\n=== 직원 관리 시스템 ===\n");
        printf("1. 직원 추가\n");
        printf("2. 직원 검색\n");
        printf("3. 모든 직원 조회\n");
        printf("4. 직원 정보 수정\n");
        printf("5. 종료\n");
        printf("선택: ");
        scanf("%d", &choice);
        
        switch (choice) {
            case 1:
                add_employee(file);
                break;
            case 2: {
                int id;
                printf("검색할 ID: ");
                scanf("%d", &id);
                find_employee(file, id);
                break;
            }
            case 3:
                list_all_employees(file);
                break;
            case 4: {
                int id;
                printf("수정할 ID: ");
                scanf("%d", &id);
                update_employee(file, id);
                break;
            }
            case 5:
                printf("프로그램을 종료합니다.\n");
                break;
            default:
                printf("잘못된 선택입니다.\n");
        }
    } while (choice != 5);
    
    fclose(file);
    return 0;
}
```

## 고급 파일 입출력 기법

### 파일 위치 제어와 임의 접근

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    FILE *file = fopen("test.dat", "w+b");  // 읽기/쓰기, 바이너리
    
    if (file == NULL) {
        printf("파일을 생성할 수 없습니다.\n");
        return 1;
    }
    
    // 0부터 99까지의 숫자를 파일에 쓰기
    for (int i = 0; i < 100; i++) {
        fwrite(&i, sizeof(int), 1, file);
    }
    
    printf("100개의 정수를 파일에 기록했습니다.\n");
    
    // 다양한 파일 위치 이동 방법
    printf("\n=== 파일 위치 제어 ===\n");
    
    // 1. 파일 처음으로 이동
    rewind(file);
    printf("rewind() 후 위치: %ld\n", ftell(file));
    
    // 2. 10번째 레코드로 이동 (0-based)
    fseek(file, 10 * sizeof(int), SEEK_SET);
    int value;
    fread(&value, sizeof(int), 1, file);
    printf("10번째 레코드: %d (위치: %ld)\n", value, ftell(file));
    
    // 3. 현재 위치에서 5레코드 앞으로 이동
    fseek(file, 5 * sizeof(int), SEEK_CUR);
    fread(&value, sizeof(int), 1, file);
    printf("현재 위치 + 5: %d (위치: %ld)\n", value, ftell(file));
    
    // 4. 파일 끝에서 10레코드 앞으로 이동
    fseek(file, -10 * sizeof(int), SEEK_END);
    fread(&value, sizeof(int), 1, file);
    printf("끝에서 10번째: %d (위치: %ld)\n", value, ftell(file));
    
    // 5. 파일 크기 확인
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    printf("파일 크기: %ld 바이트\n", file_size);
    printf("레코드 수: %ld\n", file_size / sizeof(int));
    
    // 6. 특정 위치의 레코드 수정
    int new_value = 999;
    fseek(file, 50 * sizeof(int), SEEK_SET);  // 51번째 레코드 (0-based 50)
    fwrite(&new_value, sizeof(int), 1, file);
    
    // 확인
    fseek(file, 50 * sizeof(int), SEEK_SET);
    fread(&value, sizeof(int), 1, file);
    printf("수정된 51번째 레코드: %d\n", value);
    
    // 파일 처음부터 모든 레코드 출력 (짝수 위치만)
    printf("\n=== 짝수 위치의 레코드 ===\n");
    rewind(file);
    
    for (int i = 0; i < 100; i++) {
        fread(&value, sizeof(int), 1, file);
        if (i % 2 == 0) {
            printf("%3d: %d\n", i, value);
        }
    }
    
    fclose(file);
    return 0;
}
```

### 버퍼링과 성능 최적화

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define BUFFER_SIZE 8192  // 8KB 버퍼

// 버퍼링을 사용한 파일 복사 (고성능)
void buffered_copy(const char *source, const char *dest) {
    FILE *src_file, *dest_file;
    clock_t start, end;
    double elapsed;
    
    start = clock();
    
    src_file = fopen(source, "rb");
    if (src_file == NULL) {
        printf("원본 파일을 열 수 없습니다.\n");
        return;
    }
    
    dest_file = fopen(dest, "wb");
    if (dest_file == NULL) {
        printf("대상 파일을 생성할 수 없습니다.\n");
        fclose(src_file);
        return;
    }
    
    // 버퍼 설정 (선택사항, 기본 버퍼도 충분할 수 있음)
    char *buffer = malloc(BUFFER_SIZE);
    if (buffer == NULL) {
        printf("버퍼 할당 실패\n");
        fclose(src_file);
        fclose(dest_file);
        return;
    }
    
    // setvbuf를 사용한 명시적 버퍼 설정
    // _IOFBF: 완전 버퍼링, _IOLBF: 줄 버퍼링, _IONBF: 버퍼링 없음
    setvbuf(src_file, buffer, _IOFBF, BUFFER_SIZE);
    setvbuf(dest_file, NULL, _IOFBF, BUFFER_SIZE);  // 자동 할당
    
    size_t bytes_copied = 0;
    size_t bytes_read;
    char read_buffer[BUFFER_SIZE];
    
    while ((bytes_read = fread(read_buffer, 1, BUFFER_SIZE, src_file)) > 0) {
        fwrite(read_buffer, 1, bytes_read, dest_file);
        bytes_copied += bytes_read;
    }
    
    free(buffer);
    fclose(src_file);
    fclose(dest_file);
    
    end = clock();
    elapsed = (double)(end - start) / CLOCKS_PER_SEC;
    
    printf("버퍼링 복사 완료: %zu 바이트, %.3f 초, %.2f MB/초\n",
           bytes_copied, elapsed, 
           (bytes_copied / (1024.0 * 1024.0)) / elapsed);
}

// 버퍼링 없이 파일 복사 (느림, 비교용)
void unbuffered_copy(const char *source, const char *dest) {
    FILE *src_file, *dest_file;
    clock_t start, end;
    double elapsed;
    
    start = clock();
    
    src_file = fopen(source, "rb");
    if (src_file == NULL) {
        printf("원본 파일을 열 수 없습니다.\n");
        return;
    }
    
    dest_file = fopen(dest, "wb");
    if (dest_file == NULL) {
        printf("대상 파일을 생성할 수 없습니다.\n");
        fclose(src_file);
        return;
    }
    
    // 버퍼링 비활성화
    setvbuf(src_file, NULL, _IONBF, 0);
    setvbuf(dest_file, NULL, _IONBF, 0);
    
    size_t bytes_copied = 0;
    int byte;
    
    // 바이트 단위로 읽고 쓰기 (매우 느림)
    while ((byte = fgetc(src_file)) != EOF) {
        fputc(byte, dest_file);
        bytes_copied++;
    }
    
    fclose(src_file);
    fclose(dest_file);
    
    end = clock();
    elapsed = (double)(end - start) / CLOCKS_PER_SEC;
    
    printf("비버퍼링 복사 완료: %zu 바이트, %.3f 초, %.2f KB/초\n",
           bytes_copied, elapsed, 
           (bytes_copied / 1024.0) / elapsed);
}

int main(void) {
    // 테스트용 대용량 파일 생성 (1MB)
    printf("테스트 파일 생성 중...\n");
    FILE *test_file = fopen("test_large.bin", "wb");
    
    if (test_file != NULL) {
        // 1MB 데이터 생성 (0-255 반복)
        unsigned char data[1024];  // 1KB
        for (int i = 0; i < 1024; i++) {
            data[i] = i % 256;
        }
        
        // 1024번 쓰기 = 1MB
        for (int i = 0; i < 1024; i++) {
            fwrite(data, 1, 1024, test_file);
        }
        
        fclose(test_file);
        printf("1MB 테스트 파일 생성 완료.\n");
    }
    
    // 성능 비교
    printf("\n=== 버퍼링 성능 비교 ===\n");
    buffered_copy("test_large.bin", "copy_buffered.bin");
    unbuffered_copy("test_large.bin", "copy_unbuffered.bin");
    
    return 0;
}
```

## 실전 프로젝트: 간단한 데이터베이스 시스템

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_TITLE_LENGTH 100
#define MAX_AUTHOR_LENGTH 50
#define MAX_BOOKS 1000

typedef struct {
    int id;
    char title[MAX_TITLE_LENGTH];
    char author[MAX_AUTHOR_LENGTH];
    int year;
    float price;
    time_t added_date;
} Book;

typedef struct {
    Book books[MAX_BOOKS];
    int count;
    int next_id;
} Library;

// 라이브러리 초기화
void init_library(Library *lib) {
    lib->count = 0;
    lib->next_id = 1;
}

// 책 추가
int add_book(Library *lib, const char *title, const char *author, 
             int year, float price) {
    if (lib->count >= MAX_BOOKS) {
        printf("도서관이 가득 찼습니다.\n");
        return 0;
    }
    
    Book *book = &lib->books[lib->count];
    
    book->id = lib->next_id++;
    strncpy(book->title, title, MAX_TITLE_LENGTH - 1);
    book->title[MAX_TITLE_LENGTH - 1] = '\0';
    
    strncpy(book->author, author, MAX_AUTHOR_LENGTH - 1);
    book->author[MAX_AUTHOR_LENGTH - 1] = '\0';
    
    book->year = year;
    book->price = price;
    book->added_date = time(NULL);
    
    lib->count++;
    return book->id;
}

// 책 검색 (제목으로)
void search_by_title(Library *lib, const char *keyword) {
    printf("\n=== '%s' 검색 결과 ===\n", keyword);
    int found = 0;
    
    for (int i = 0; i < lib->count; i++) {
        if (strstr(lib->books[i].title, keyword) != NULL) {
            printf("ID: %d, 제목: %s, 저자: %s\n", 
                   lib->books[i].id, lib->books[i].title, lib->books[i].author);
            found = 1;
        }
    }
    
    if (!found) {
        printf("검색 결과가 없습니다.\n");
    }
}

// 모든 책 목록 출력
void list_books(Library *lib) {
    printf("\n=== 도서 목록 (총 %d권) ===\n", lib->count);
    
    for (int i = 0; i < lib->count; i++) {
        Book *book = &lib->books[i];
        printf("%4d. [%d] %s - %s (%d년, %.2f원)\n", 
               i + 1, book->id, book->title, book->author, 
               book->year, book->price);
    }
}

// 라이브러리 파일에 저장
int save_library(Library *lib, const char *filename) {
    FILE *file = fopen(filename, "wb");
    
    if (file == NULL) {
        printf("파일을 생성할 수 없습니다.\n");
        return 0;
    }
    
    // 먼저 라이브러리 메타데이터 저장
    fwrite(&lib->count, sizeof(int), 1, file);
    fwrite(&lib->next_id, sizeof(int), 1, file);
    
    // 책 데이터 저장
    fwrite(lib->books, sizeof(Book), lib->count, file);
    
    fclose(file);
    
    printf("도서관 데이터가 저장되었습니다: %s (%d권)\n", 
           filename, lib->count);
    return 1;
}

// 파일에서 라이브러리 로드
int load_library(Library *lib, const char *filename) {
    FILE *file = fopen(filename, "rb");
    
    if (file == NULL) {
        printf("파일을 열 수 없습니다. 새 도서관을 생성합니다.\n");
        init_library(lib);
        return 0;
    }
    
    // 메타데이터 읽기
    if (fread(&lib->count, sizeof(int), 1, file) != 1) {
        printf("파일 읽기 오류.\n");
        fclose(file);
        return 0;
    }
    
    if (fread(&lib->next_id, sizeof(int), 1, file) != 1) {
        printf("파일 읽기 오류.\n");
        fclose(file);
        return 0;
    }
    
    // 책 데이터 읽기
    if (lib->count > MAX_BOOKS) {
        printf("경고: 파일에 너무 많은 책이 있습니다.\n");
        lib->count = MAX_BOOKS;
    }
    
    if (fread(lib->books, sizeof(Book), lib->count, file) != lib->count) {
        printf("파일 읽기 오류.\n");
        fclose(file);
        return 0;
    }
    
    fclose(file);
    
    printf("도서관 데이터를 불러왔습니다: %s (%d권)\n", 
           filename, lib->count);
    return 1;
}

// 메뉴 시스템
void display_menu() {
    printf("\n=== 도서관 관리 시스템 ===\n");
    printf("1. 새 책 추가\n");
    printf("2. 책 검색\n");
    printf("3. 모든 책 목록\n");
    printf("4. 데이터 저장\n");
    printf("5. 데이터 불러오기\n");
    printf("6. 종료\n");
    printf("선택: ");
}

int main(void) {
    Library my_library;
    char filename[] = "library.dat";
    
    // 프로그램 시작 시 파일에서 데이터 로드
    load_library(&my_library, filename);
    
    int choice;
    char title[MAX_TITLE_LENGTH];
    char author[MAX_AUTHOR_LENGTH];
    int year;
    float price;
    
    do {
        display_menu();
        scanf("%d", &choice);
        getchar();  // 개행 문자 처리
        
        switch (choice) {
            case 1:  // 새 책 추가
                printf("\n=== 새 책 추가 ===\n");
                printf("제목: ");
                fgets(title, sizeof(title), stdin);
                title[strcspn(title, "\n")] = '\0';
                
                printf("저자: ");
                fgets(author, sizeof(author), stdin);
                author[strcspn(author, "\n")] = '\0';
                
                printf("출판년도: ");
                scanf("%d", &year);
                
                printf("가격: ");
                scanf("%f", &price);
                
                {
                    int id = add_book(&my_library, title, author, year, price);
                    printf("책이 추가되었습니다. ID: %d\n", id);
                }
                break;
                
            case 2:  // 책 검색
                printf("\n검색할 제목 키워드: ");
                fgets(title, sizeof(title), stdin);
                title[strcspn(title, "\n")] = '\0';
                search_by_title(&my_library, title);
                break;
                
            case 3:  // 모든 책 목록
                list_books(&my_library);
                break;
                
            case 4:  // 데이터 저장
                save_library(&my_library, filename);
                break;
                
            case 5:  // 데이터 불러오기
                load_library(&my_library, filename);
                break;
                
            case 6:  // 종료
                printf("프로그램을 종료합니다.\n");
                // 종료 전 자동 저장
                save_library(&my_library, filename);
                break;
                
            default:
                printf("잘못된 선택입니다.\n");
        }
    } while (choice != 6);
    
    return 0;
}
```

## 주의사항과 모범 사례

### 1. 항상 오류 검사하기

```c
#include <stdio.h>
#include <stdlib.h>

int safe_file_operations() {
    FILE *file = fopen("important.dat", "wb");
    
    // 1. 파일 열기 실패 검사
    if (file == NULL) {
        perror("fopen 실패");
        return 1;
    }
    
    int data = 42;
    
    // 2. 쓰기 작업 실패 검사
    if (fwrite(&data, sizeof(int), 1, file) != 1) {
        perror("fwrite 실패");
        fclose(file);
        return 1;
    }
    
    // 3. 버퍼 플러시 실패 검사
    if (fflush(file) != 0) {
        perror("fflush 실패");
        // 계속 진행
    }
    
    // 4. 파일 닫기 실패 검사
    if (fclose(file) != 0) {
        perror("fclose 실패");
        return 1;
    }
    
    printf("파일 작업 성공\n");
    return 0;
}
```

### 2. 임시 파일 패턴 사용하기

```c
#include <stdio.h>
#include <stdlib.h>

// 안전한 파일 업데이트 (임시 파일 사용)
int safe_file_update(const char *filename) {
    char temp_filename[256];
    
    // 임시 파일명 생성
    snprintf(temp_filename, sizeof(temp_filename), "%s.tmp", filename);
    
    // 원본 파일 열기 (읽기)
    FILE *src = fopen(filename, "rb");
    if (src == NULL) {
        // 파일이 없으면 새로 생성
        src = fopen(filename, "wb");
        if (src == NULL) {
            perror("원본 파일 생성 실패");
            return 0;
        }
        fclose(src);
        src = fopen(filename, "rb");
    }
    
    // 임시 파일 열기 (쓰기)
    FILE *temp = fopen(temp_filename, "wb");
    if (temp == NULL) {
        perror("임시 파일 생성 실패");
        fclose(src);
        return 0;
    }
    
    // 데이터 처리 (예: 모든 바이트에 1 더하기)
    int byte;
    while ((byte = fgetc(src)) != EOF) {
        fputc(byte + 1, temp);  // 간단한 변환 예제
    }
    
    fclose(src);
    
    // 임시 파일 닫기 확인
    if (fclose(temp) != 0) {
        perror("임시 파일 닫기 실패");
        remove(temp_filename);  // 임시 파일 삭제
        return 0;
    }
    
    // 원본 파일 삭제
    if (remove(filename) != 0) {
        perror("원본 파일 삭제 실패");
        remove(temp_filename);  // 임시 파일 삭제
        return 0;
    }
    
    // 임시 파일을 원본 파일명으로 변경
    if (rename(temp_filename, filename) != 0) {
        perror("파일 이름 변경 실패");
        // 임시 파일은 그대로 남아있음
        return 0;
    }
    
    printf("파일 안전하게 업데이트 완료\n");
    return 1;
}
```

## 마무리

파일 입출력은 C 프로그래밍에서 데이터 영속성을 보장하는 핵심 기술입니다. 주요 포인트를 정리하면:

1. **적절한 모드 선택**: 텍스트 vs 바이너리, 읽기 vs 쓰기를 구분하세요
2. **오류 검사 필수**: 모든 파일 연산 후 오류를 검사하세요
3. **리소스 관리**: 파일을 열면 반드시 닫아야 합니다
4. **버퍼링 이해**: 대용량 파일 처리 시 버퍼링이 성능을 결정합니다
5. **안전한 패턴 사용**: 임시 파일 패턴으로 데이터 손실을 방지하세요
6. **이식성 고려**: 바이너리 파일은 플랫폼 차이(엔디안, 정렬)를 고려하세요

파일 입출력을 마스터하면 데이터베이스, 로깅 시스템, 설정 파일 관리 등 다양한 응용 프로그램을 개발할 수 있는 기반을 마련하게 됩니다.