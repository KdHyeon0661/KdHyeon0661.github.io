---
layout: post
title: 영상처리 - C# 개발 환경과 WPF 기초 (C#)
date: 2025-12-10 15:30:23 +0900
category: 영상처리
---
# C# 개발 환경과 WPF 기초

## 개발 환경 구성

본 프로젝트는 C#과 WPF를 사용한 영상 처리 프로그램 개발을 위한 환경을 설정합니다.

### 필수 구성 요소

| 항목 | 권장 설정 | 비고 |
|---|---|---|
| IDE | Visual Studio 2022 | Community 버전 무료 |
| .NET 버전 | .NET 6 이상 | LTS(Long Term Support) |
| UI 프레임워크 | WPF | 데스크톱 윈도우 애플리케이션 |
| 영상 처리 라이브러리 | OpenCvSharp4 | OpenCV의 .NET 래퍼 |

### 프로젝트 생성과 설정

```xml
<!-- .csproj 파일의 핵심 설정 -->
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net6.0-windows</TargetFramework>
    <UseWPF>true</UseWPF>
    <Nullable>enable</Nullable>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="OpenCvSharp4" Version="4.8.0" />
    <PackageReference Include="OpenCvSharp4.runtime.win" Version="4.8.0" />
  </ItemGroup>
</Project>
```

## WPF MVVM 패턴

WPF(Windows Presentation Foundation)는 현대적인 개발 패러다임을 제공합니다. MVVM(Model-View-ViewModel) 패턴은 데이터와 UI의 분리를 가능하게 합니다.

### MVVM 패턴의 구조

```
┌─────────────────────────────────────────────────────┐
│                    View (XAML)                       │
│  ┌──────────────────────────────────────────────┐  │
│  │  <Image Source="{Binding ImageSource}"/>     │  │
│  │  <Button Command="{Binding LoadCommand}"/>   │  │
│  └──────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────┤
│              ViewModel (C# 클래스)                  │
│  ┌──────────────────────────────────────────────┐  │
│  │  public ImageSource ImageSource { get; set; }│  │
│  │  public ICommand LoadCommand { get; set; }   │  │
│  │  private void LoadImage() { ... }            │  │
│  └──────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────┤
│                    Model (데이터)                   │
│  ┌──────────────────────────────────────────────┐  │
│  │  public class ImageData {                    │  │
│  │      public byte[] Buffer { get; set; }      │  │
│  │      public int Width { get; set; }          │  │
│  │      public int Height { get; set; }         │  │
│  │  }                                           │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

## OpenCvSharp을 이용한 고수준 영상 처리

OpenCvSharp은 OpenCV의 .NET 래퍼로, 고수준 영상 처리 API를 제공합니다.

### 기본 영상 로드와 처리

```csharp
using OpenCvSharp;
using System.Windows.Media.Imaging;

public class ImageProcessor
{
    // 고수준 API: OpenCvSharp으로 영상 로드
    public Mat LoadImage(string filePath)
    {
        // OpenCvSharp으로 영상 로드
        Mat image = Cv2.ImRead(filePath, ImreadModes.Color);
        
        // 영상 정보 출력
        Console.WriteLine($"영상 크기: {image.Width} x {image.Height}");
        Console.WriteLine($"채널 수: {image.Channels()}");
        Console.WriteLine($"데이터 타입: {image.Type()}");
        
        return image;
    }
    
    // 고수준 API: 다양한 영상 처리 연산
    public Mat ProcessImage(Mat inputImage)
    {
        Mat result = new Mat();
        
        // 1. 그레이스케일 변환
        Mat gray = new Mat();
        if (inputImage.Channels() == 3)
        {
            Cv2.CvtColor(inputImage, gray, ColorConversionCodes.BGR2GRAY);
        }
        else
        {
            gray = inputImage.Clone();
        }
        
        // 2. 가우시안 블러 (노이즈 제거)
        Mat blurred = new Mat();
        Cv2.GaussianBlur(gray, blurred, new Size(5, 5), 1.5);
        
        // 3. 캐니 에지 검출
        Mat edges = new Mat();
        Cv2.Canny(blurred, edges, 50, 150);
        
        // 4. 컬러 영상으로 변환 (시각화용)
        Cv2.CvtColor(edges, result, ColorConversionCodes.GRAY2BGR);
        
        return result;
    }
    
    // 고수준 API: Mat을 WPF BitmapSource로 변환
    public BitmapSource ConvertMatToBitmapSource(Mat mat)
    {
        // OpenCvSharp Mat을 byte 배열로 변환
        byte[] imageData = new byte[mat.Total() * mat.ElemSize()];
        Marshal.Copy(mat.Data, imageData, 0, imageData.Length);
        
        // 픽셀 형식 결정
        PixelFormat pixelFormat;
        if (mat.Channels() == 1)
            pixelFormat = PixelFormats.Gray8;
        else if (mat.Channels() == 3)
            pixelFormat = PixelFormats.Bgr24;
        else if (mat.Channels() == 4)
            pixelFormat = PixelFormats.Bgra32;
        else
            throw new ArgumentException("지원되지 않는 채널 수");
        
        // BitmapSource 생성
        BitmapSource bitmap = BitmapSource.Create(
            mat.Width, mat.Height,
            96, 96, pixelFormat, null,
            imageData, mat.Width * mat.Channels());
        
        return bitmap;
    }
}
```

### OpenCvSharp의 내부 동작 원리

OpenCvSharp의 `ImRead` 함수는 내부적으로 다음과 같은 과정을 거칩니다:

```csharp
// 의사 코드: OpenCvSharp의 ImRead 내부 구조
public static Mat ImRead(string filename, ImreadModes flags = ImreadModes.Color)
{
    // 1. 파일 존재 여부 확인
    if (!File.Exists(filename))
        throw new FileNotFoundException();
    
    // 2. 네이티브 OpenCV 함수 호출
    IntPtr ptr = NativeMethods.imgcodecs_imread(filename, (int)flags);
    
    if (ptr == IntPtr.Zero)
        throw new OpenCvSharpException("Failed to load image");
    
    // 3. Mat 객체 생성 (네이티브 포인터 래핑)
    Mat mat = new Mat(ptr);
    
    return mat;
}
```

## WriteableBitmap과 저수준 영상 처리

WPF에서 실시간 영상 처리를 위해서는 `WriteableBitmap`이 필수적입니다.

### WriteableBitmap 생성과 초기화

```csharp
public class ImageRenderer
{
    private WriteableBitmap _bitmap;
    private int _width;
    private int _height;
    private int _channels;
    private int _stride;
    
    // WriteableBitmap 생성
    public void InitializeBitmap(int width, int height, int channels = 3)
    {
        _width = width;
        _height = height;
        _channels = channels;
        _stride = width * channels;
        
        // 픽셀 형식 결정
        PixelFormat format;
        if (channels == 1)
            format = PixelFormats.Gray8;
        else if (channels == 3)
            format = PixelFormats.Bgr24;
        else if (channels == 4)
            format = PixelFormats.Bgra32;
        else
            throw new ArgumentException("지원되지 않는 채널 수");
        
        // WriteableBitmap 생성
        _bitmap = new WriteableBitmap(
            width, height,  // 너비, 높이
            96, 96,         // DPI (가로, 세로)
            format,         // 픽셀 형식
            null            // 팔레트 (색상 맵)
        );
    }
    
    // 고수준 API: 영상 데이터 업데이트
    public void UpdateImage(byte[] imageData)
    {
        // 입력 데이터 검증
        if (imageData.Length != _height * _stride)
            throw new ArgumentException("영상 데이터 크기가 일치하지 않습니다");
        
        // WritePixels를 사용한 고수준 업데이트
        Int32Rect rect = new Int32Rect(0, 0, _width, _height);
        _bitmap.WritePixels(rect, imageData, _stride, 0);
    }
}
```

### WritePixels의 내부 동작 원리

`WritePixels` 메서드는 내부적으로 다음과 같은 작업을 수행합니다:

```csharp
// 의사 코드: WritePixels의 내부 구현
public void WritePixels(Int32Rect sourceRect, Array sourceBuffer, 
                       int sourceBufferStride, int destinationX, int destinationY)
{
    // 1. 매개변수 검증
    ValidateParameters(sourceRect, sourceBuffer, sourceBufferStride);
    
    // 2. 메모리 잠금 (다중 스레드 접근 방지)
    Lock();
    
    try
    {
        // 3. 백버퍼 포인터 획득
        IntPtr pBackBuffer = BackBuffer;
        int backBufferStride = BackBufferStride;
        
        // 4. 행 단위 복사
        for (int y = 0; y < sourceRect.Height; y++)
        {
            // 소스 행의 시작 인덱스
            int sourceIndex = y * sourceBufferStride + sourceRect.X;
            
            // 대상 행의 시작 주소
            IntPtr destPtr = pBackBuffer + 
                           ((destinationY + y) * backBufferStride) + 
                           (destinationX * Format.BitsPerPixel / 8);
            
            // 메모리 복사
            Marshal.Copy(sourceBuffer, sourceIndex, destPtr, sourceRect.Width);
        }
        
        // 5. 더티 영역 등록
        AddDirtyRect(new Int32Rect(destinationX, destinationY, 
                                  sourceRect.Width, sourceRect.Height));
    }
    finally
    {
        // 6. 메모리 잠금 해제
        Unlock();
    }
}
```

## 저수준 메모리 접근과 최적화

고성능 영상 처리를 위해서는 저수준 메모리 접근이 필요합니다.

### Lock 방식을 이용한 직접 메모리 접근

```csharp
public unsafe class DirectBitmapAccess
{
    private WriteableBitmap _bitmap;
    private byte* _backBuffer;
    private int _backBufferStride;
    
    // 메모리 잠금 및 포인터 획득
    public byte* LockBitmap()
    {
        _bitmap.Lock();
        _backBuffer = (byte*)_bitmap.BackBuffer;
        _backBufferStride = _bitmap.BackBufferStride;
        return _backBuffer;
    }
    
    // 메모리 잠금 해제
    public void UnlockBitmap()
    {
        _bitmap.AddDirtyRect(new Int32Rect(0, 0, 
                                          _bitmap.PixelWidth, 
                                          _bitmap.PixelHeight));
        _bitmap.Unlock();
    }
    
    // 저수준 픽셀 접근
    public void ProcessPixelsDirectly()
    {
        byte* buffer = LockBitmap();
        
        try
        {
            int width = _bitmap.PixelWidth;
            int height = _bitmap.PixelHeight;
            int channels = _bitmap.Format.BitsPerPixel / 8;
            
            for (int y = 0; y < height; y++)
            {
                byte* row = buffer + (y * _backBufferStride);
                
                for (int x = 0; x < width; x++)
                {
                    int pixelIndex = x * channels;
                    
                    // BGR 형식 (OpenCV 기본)
                    byte b = row[pixelIndex];
                    byte g = row[pixelIndex + 1];
                    byte r = row[pixelIndex + 2];
                    
                    // 그레이스케일 변환
                    byte gray = (byte)((r * 0.299 + g * 0.587 + b * 0.114));
                    
                    row[pixelIndex] = gray;
                    row[pixelIndex + 1] = gray;
                    row[pixelIndex + 2] = gray;
                }
            }
        }
        finally
        {
            UnlockBitmap();
        }
    }
}
```

## MVVM 패턴에서의 완전한 구현 예제

### Model: 영상 데이터 클래스

```csharp
public class ImageModel : INotifyPropertyChanged
{
    private byte[] _buffer;
    private int _width;
    private int _height;
    
    public byte[] Buffer
    {
        get => _buffer;
        set
        {
            _buffer = value;
            OnPropertyChanged();
        }
    }
    
    public int Width
    {
        get => _width;
        set
        {
            _width = value;
            OnPropertyChanged();
        }
    }
    
    public int Height
    {
        get => _height;
        set
        {
            _height = value;
            OnPropertyChanged();
        }
    }
    
    public event PropertyChangedEventHandler PropertyChanged;
    
    protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

### ViewModel: 영상 처리 로직

```csharp
public class ImageViewModel : INotifyPropertyChanged
{
    private ImageModel _imageModel;
    private WriteableBitmap _displayBitmap;
    private ICommand _loadImageCommand;
    
    public ImageViewModel()
    {
        _imageModel = new ImageModel();
        _loadImageCommand = new RelayCommand(LoadImage);
    }
    
    public ImageSource DisplayImage
    {
        get => _displayBitmap;
        set
        {
            _displayBitmap = (WriteableBitmap)value;
            OnPropertyChanged();
        }
    }
    
    public ICommand LoadImageCommand => _loadImageCommand;
    
    private void LoadImage()
    {
        var dialog = new Microsoft.Win32.OpenFileDialog();
        dialog.Filter = "Image files (*.jpg;*.png;*.bmp)|*.jpg;*.png;*.bmp";
        
        if (dialog.ShowDialog() == true)
        {
            using (Mat mat = Cv2.ImRead(dialog.FileName, ImreadModes.Color))
            {
                _imageModel.Width = mat.Width;
                _imageModel.Height = mat.Height;
                
                _imageModel.Buffer = new byte[mat.Total() * mat.ElemSize()];
                Marshal.Copy(mat.Data, _imageModel.Buffer, 0, _imageModel.Buffer.Length);
                
                UpdateDisplay();
            }
        }
    }
    
    private void UpdateDisplay()
    {
        if (_displayBitmap == null || 
            _displayBitmap.PixelWidth != _imageModel.Width ||
            _displayBitmap.PixelHeight != _imageModel.Height)
        {
            _displayBitmap = new WriteableBitmap(
                _imageModel.Width, _imageModel.Height,
                96, 96, PixelFormats.Bgr24, null);
        }
        
        _displayBitmap.Lock();
        try
        {
            unsafe
            {
                byte* pBackBuffer = (byte*)_displayBitmap.BackBuffer;
                fixed (byte* pSource = _imageModel.Buffer)
                {
                    Buffer.MemoryCopy(pSource, pBackBuffer,
                                     _imageModel.Buffer.Length,
                                     _imageModel.Buffer.Length);
                }
            }
            
            _displayBitmap.AddDirtyRect(new Int32Rect(0, 0, 
                                                     _imageModel.Width, 
                                                     _imageModel.Height));
        }
        finally
        {
            _displayBitmap.Unlock();
        }
        
        OnPropertyChanged(nameof(DisplayImage));
    }
    
    public event PropertyChangedEventHandler PropertyChanged;
    
    protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

### View: XAML UI 정의

```xml
<Window x:Class="ImageProcessingApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="영상 처리 프로그램" Height="600" Width="800">
    
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        
        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="10">
            <Button Content="영상 열기" 
                    Command="{Binding LoadImageCommand}"
                    Width="100" Height="30" Margin="5"/>
        </StackPanel>
        
        <ScrollViewer Grid.Row="1" HorizontalScrollBarVisibility="Auto" 
                     VerticalScrollBarVisibility="Auto">
            <Image Source="{Binding DisplayImage}" 
                   Stretch="None"
                   HorizontalAlignment="Left"
                   VerticalAlignment="Top"/>
        </ScrollViewer>
    </Grid>
</Window>
```

## 전체 데이터 흐름

```
OpenCvSharp (고수준 처리)
        ↓
Mat 객체 (영상 데이터)
        ↓
byte[] 버퍼 (Model)
        ↓
INotifyPropertyChanged
        ↓
ViewModel.UpdateDisplay()
        ↓
WriteableBitmap (Lock/Unlock)
        ↓
BackBuffer 직접 접근
        ↓
화면 갱신 (View)
```

## 결론

C#과 WPF를 사용한 영상 처리 프로그램 개발의 핵심은:

1. **OpenCvSharp**: 고수준 영상 처리 알고리즘
2. **WriteableBitmap**: 실시간 영상 출력
3. **MVVM 패턴**: 데이터와 UI의 분리
4. **Unsafe 코드**: 고성능 픽셀 접근

이 구조는 확장 가능한 영상 처리 애플리케이션의 기반을 제공합니다.