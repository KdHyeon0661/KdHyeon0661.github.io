---
layout: post
title: Svelte - 트러블슈팅 모음
date: 2025-10-08 19:30:23 +0900
category: Svelte
---
# 트러블슈팅 모음 — **현장에서 자주 맞닥뜨리는 함정과 해법 총정리**

> 실전에서 가장 많이 질문받는 **네 가지** 이슈를 “원인 → 재현 → 잘못된 코드 → 올바른 코드 → 진단 체크리스트” 순서로 정리했다.
> - **반응성 갱신이 안 되는 경우**: 할당 기반, 구조분해/변이, 루프 캡처
> - **`load` 실행 타이밍/캐시 함정**: 서버/클라 경계, `depends`/`maxage`, CSR 네비 동작
> - **SSR에서 브라우저 전용 API 오류**: `onMount`/dynamic import, 가드 패턴
> - **폼 액션/리다이렉트 흔한 실수**: 멱등성, 303/302 차이, 필드 검증/상태 전달

---

## 반응성 갱신이 안 되는 경우(할당/구조분해 주의)

Svelte(특히 v4)는 **“할당이 곧 업데이트 트리거”**다. 아래 상황에서 *업데이트가 일어나지 않거나* 기대와 다르게 동작한다.

### 객체/배열 **부분 변이**만 하고 **할당을 안 한** 경우

#### ❌ 잘못된 예 (Svelte 4)

```svelte
<script>
  let user = { name: 'A', tags: ['x'] };

  function addTag(t) {
    user.tags.push(t);     // 부분 변이
    // user = user;        // ❌ 무의미, 컴파일 최적화로 무시될 수 있음
  }
</script>

<button on:click={() => addTag('y')}>추가</button>
<p>{user.tags.join(', ')}</p>
```

> `user.tags.push()`는 내부 변이이며 **최상위 변수 `user`에 대한 “할당”이 없으므로** 반응성이 트리거되지 않는다.

#### ✅ 해결 1 — 새 객체로 **재할당**

```svelte
<script>
  let user = { name: 'A', tags: ['x'] };

  function addTag(t) {
    user = { ...user, tags: [...user.tags, t] }; // 할당!
  }
</script>
```

#### ✅ 해결 2 — 특정 속성 갱신을 **분리 변수**로

```svelte
<script>
  let tags = ['x'];
  function addTag(t){ tags = [...tags, t]; }   // top-level에 할당
</script>
```

#### ✅ (Svelte 5) Runes 사용 시 — **변이 허용**

```svelte
<script>
  const user = $state({ name: 'A', tags: ['x'] });
  function addTag(t) { user.tags.push(t); }    // 변이 자체가 반응
</script>
```

---

### 구조분해 후 **원본과 단절**된 변수에만 변경한 경우

#### ❌ 문제 예

```svelte
<script>
  let obj = { count: 0 };
  let { count } = obj;        // 구조분해 (by value)

  function inc() {
    count += 1;               // count만 바뀜, obj.count는 그대로
  }
</script>

<button on:click={inc}>{count}</button>
<p>obj.count: {obj.count}</p>
```

> `count`는 **복사된 값**이라 `obj`와 연결이 끊어짐.

#### ✅ 해결

```svelte
<script>
  let obj = { count: 0 };
  function inc(){ obj = { ...obj, count: obj.count + 1 }; }  // obj에 할당
</script>
```

또는 **파생 값은 `$:`로 유지**:
```svelte
<script>
  let obj = { count: 0 };
  $: count = obj.count;  // 표시용 파생
  function inc(){ obj = { ...obj, count: obj.count + 1 }; }
</script>
```

(Svelte 5)
```svelte
<script>
  const obj = $state({ count: 0 });
  const count = $derived(obj.count);
  function inc(){ obj.count++; }
</script>
```

---

### 루프 캡처/클로저로 인한 **최신 값 미반영**

#### ❌ 문제 예

```svelte
<script>
  let i = 0;
  function start() {
    setTimeout(() => {
      i = i + 1; // OK지만, 더 복잡한 경우 옛 값 캡처가 문제
    }, 1000);
  }
</script>
```

> 콜백 내에서 **옛 스냅샷**을 사용하면 문제가 발생할 수 있다(예: 일정 간격으로 상태 누적 시).

#### ✅ 패턴

- 가능한 **현재 값을 함수 인자로 전달**
- Svelte 5에서는 `$effect` 내 의존을 명확히

```svelte
<script>
  let n = 0;
  function addLater(delta){
    const prev = n; // 스냅샷 캡처
    setTimeout(() => {
      // prev 사용 대신 최신 n으로 재연산을 권장
      n = n + delta;
    }, 300);
  }
</script>
```

---

### `$:` 반응 구문에서 **사이드 이펙트/비동기** 혼합

#### ❌ 문제 예

```svelte
<script>
  let q = '';
  let items = [];
  $: if (q) {
    fetch(`/api/search?q=${q}`)
      .then(r=>r.json())
      .then(d => items = d);    // 경쟁상태, 취소 불가
  }
</script>
```

> 빠르게 타이핑하면 **이전 요청 결과가 뒤늦게 덮어쓰는** 문제.

#### ✅ 해결 — 태스크 취소/토큰

```svelte
<script>
  let q = '';
  let items = [];
  let ctrl;
  $: (async () => {
    if (!q) { items = []; return; }
    ctrl?.abort();
    ctrl = new AbortController();
    const res = await fetch(`/api/search?q=${encodeURIComponent(q)}`, { signal: ctrl.signal });
    if (!res.ok) return;
    items = await res.json();
  })();
</script>
```

(Svelte 5) `$effect`로 의존 관리:
```svelte
<script>
  const q = $state('');
  const items = $state([]);
  $effect(async () => {
    if (!q) { items.splice(0); return; }
    const res = await fetch(`/api/search?q=${encodeURIComponent(q)}`);
    if (res.ok) items.splice(0, items.length, ...(await res.json()));
  });
</script>
```

---

### `bind:this`로 DOM/컴포넌트 참조 후 **타이밍** 문제

#### ❌ 문제

```svelte
<script>
  let el;
  el?.focus();   // 아직 마운트 전
</script>
<input bind:this={el} />
```

#### ✅ 해결

```svelte
<script>
  import { onMount } from 'svelte';
  let el;
  onMount(()=> el?.focus());
</script>
```

---

### 진단 체크리스트

- [ ] **최상위 변수에 “할당”**이 있었는가? (`x = {...x}`)
- [ ] 구조분해로 **연결이 끊기지** 않았는가?
- [ ] 비동기 요청의 **경쟁 상태/취소**를 처리했는가?
- [ ] DOM 참조/측정은 **`onMount` 이후**인가?
- [ ] Svelte 5라면 `$state`/`$derived`/`$effect` 의존이 **명시적**인가?

---

## `load`의 실행 타이밍/캐시 관련 함정

SvelteKit의 `load`는 **서버/클라이언트 어디서 실행되는지, 언제 다시 실행되는지**를 명확히 이해해야 한다.

### 서버 `load` vs 클라이언트 `load`

- `+page.server.ts` → **항상 서버에서** 실행
- `+page.ts` → **첫 요청은 SSR** 시 서버에서, 그 뒤 **클라이언트 네비게이션에서 CSR** 실행될 수 있음
- 레이아웃의 `load`는 **하위 페이지 네비게이션**에서도 **재사용/재실행**이 달라짐

#### 흔한 실수

1) **서버 전용 값**을 `+page.ts`에서 접근
```ts
// ❌ +page.ts
export const load = async ({ request }) => {  // 브라우저 네비에서는 request 없음
  const ip = request.headers.get('x-forwarded-for');
  return { ip };
};
```

✅ **서버에서 계산**하고 내려보내기:
```ts
// ✅ +page.server.ts
export const load = async ({ request }) => {
  const ip = request.headers.get('x-forwarded-for') ?? 'unknown';
  return { ip };
};
```

2) **브라우저 API**를 `+page.server.ts`에서 사용
→ 19.3에서 다룸.

---

### CSR 네비게이션에서 `load`가 **재실행되지 않음** (캐시/`depends` 누락)

SvelteKit은 **동일한 입력(라우트, params, URLSearchParams)**에 대한 `load` 결과를 **캐시**할 수 있다.
데이터 의존이 있는 **리소스 URL**을 알리지 않으면, 값이 바뀌어도 **재실행되지 않을** 수 있다.

#### ❌ 문제 예

```ts
// +page.ts
export const load = async ({ fetch }) => {
  const res = await fetch('/api/todos');  // 서버 내부 캐시
  return { todos: await res.json() };
};
```
서브 액션에서 `/api/todos`가 갱신되어도, **CSR 전환 중 재로드가 생략**될 수 있다.

#### ✅ 해결 — `depends`로 **의존성 추가**

```ts
// +page.ts
export const load = async ({ fetch, depends }) => {
  depends('app:todos'); // 임의 키
  const res = await fetch('/api/todos');
  return { todos: await res.json() };
};
```
그리고 **수정 액션/서버에서**:
```ts
// +page.server.ts (액션 내부 등)
import { invalidate } from '$app/navigation'; // 클라에서
// 서버 액션 후 클라 측에서:
await invalidate('app:todos'); // 해당 키 무효화 → 다음 네비에서 load 재실행
```

또는 **리소스 URL**을 직접 의존:
```ts
depends('/api/todos'); // 해당 URL이 바뀌면 무효화
```

---

### `maxage` / 캐시 헤더와의 상호작용

API 응답에서 **`cache-control: max-age=...`** 를 설정하면, 클라이언트 `fetch`가 **브라우저 캐시**를 사용할 수 있다.
SvelteKit `load` 캐시와는 별개로, 네트워크 레벨 캐싱이 끼어들 수 있음.

#### ✅ 권장

- 데이터가 **자주 바뀌면** `no-store` 또는 짧은 `max-age`
- **CSR 중 최신성 보장**이 필요하면 **`invalidate()`**와 `depends()` 병행
- SEO 크롤링 페이지는 **SSR**에서 최신 데이터 보장(헤더·revalidation 설계)

---

### `rerun` 포인트: 파라미터/쿼리/`hash`

- **라우트 파라미터**가 바뀌면 `load`는 **재실행**
- **쿼리스트링**(URLSearchParams) 변경도 재실행
- **`#hash`** 변경은 **재실행되지 않음** (앵커 스크롤만)

---

### 진단 체크리스트

- [ ] 서버에서만 가능한 값은 **`+page.server.ts`** 에서 계산
- [ ] 데이터 최신성 필요 지점에 **`depends` / `invalidate`** 사용
- [ ] API 응답 헤더의 **캐시 정책**을 의도에 맞게 설정
- [ ] CSR 네비에서 **쿼리 변경**이 load 입력에 반영되는지 확인

---

## SSR에서 브라우저 전용 API 사용 오류

SSR(서버 렌더링)에서는 **`window`/`document`/`localStorage`** 등 브라우저 API가 없다.

### 즉시 평가되는 상단 코드에서 사용

#### ❌ 문제 예

```svelte
<script>
  const theme = localStorage.getItem('theme'); // SSR에서 ReferenceError
</script>
```

#### ✅ 해결 — `onMount`/가드

```svelte
<script>
  import { onMount } from 'svelte';
  let theme = 'light';
  onMount(() => {
    theme = localStorage.getItem('theme') ?? 'light';
  });
</script>
```

또는 **가드**:
```svelte
<script>
  const isBrowser = typeof window !== 'undefined';
  let theme = 'light';
  if (isBrowser) {
    theme = localStorage.getItem('theme') ?? 'light';
  }
</script>
```

---

### 모듈 임포트 자체가 브라우저 전용인 경우 (예: `maplibre-gl`, `three`)

#### ❌ 문제

```svelte
<script>
  import maplibregl from 'maplibre-gl'; // SSR 시 require/import 에서 실패
</script>
```

#### ✅ 해결 — **동적 import + `onMount`**

```svelte
<script>
  import { onMount } from 'svelte';
  let ready = false;
  let maplibregl;
  onMount(async () => {
    maplibregl = await import('maplibre-gl');
    ready = true;
  });
</script>

{#if ready}
  <!-- map 생성 코드 -->
{/if}
```

---

### `+page.server.ts`에서 클라이언트 API 사용

#### ❌ 문제

```ts
// +page.server.ts
export const load = () => {
  const lang = navigator.language;  // ❌ 존재하지 않음
  return { lang };
};
```

#### ✅ 해결

- 서버 헤더/쿠키로 파생: `accept-language` 등
```ts
export const load = ({ request }) => {
  const lang = request.headers.get('accept-language')?.split(',')[0] ?? 'en';
  return { lang };
};
```
- 클라이언트에서 보완: `+page.ts` 또는 컴포넌트 `onMount`에서 `navigator.language` 사용

---

### `document` 측정/레이아웃 계산

#### ✅ 패턴

- **마운트 후** 계산: `onMount`
- 리사이즈/가시성 옵저버 활용
- SSR 중에는 **대체 값**(예: skeleton, placeholder) 반환

---

### 진단 체크리스트

- [ ] 상단 스코프에서 **브라우저 API 호출 금지**
- [ ] 브라우저 전용 라이브러리는 **동적 import**
- [ ] 서버 `load`는 **Node API/요청 헤더/쿠키**만 사용
- [ ] 레이아웃 측정/포커스/스크롤은 **`onMount` 이후**

---

## 폼 액션/리다이렉트에서 흔한 실수

SvelteKit **폼 액션**은 **점진적 향상**이 핵심이다. 비동기/유효성 검증/리다이렉트에서 자주 실수한다.

### 멱등성 없는 POST로 **중복 제출** 문제

#### ❌ 문제 예

```ts
// +page.server.ts
export const actions = {
  create: async ({ request }) => {
    const fd = await request.formData();
    const title = String(fd.get('title') || '');
    // DB insert (중복 방지 없음)
    await db.insert({ title });
    return { ok: true };
  }
};
```

> 사용자가 **더블 클릭**하거나 **네트워크 재시도**가 발생하면 **중복 레코드** 생성.

#### ✅ 해결 — **서버에서 멱등 보장**

- **서버 생성 토큰/nonce**(hidden field로 내려주고 1회성 확인)
- **고유 제약 조건**(DB unique key) + 에러 처리

```ts
// create 액션
import { fail, redirect } from '@sveltejs/kit';
export const actions = {
  create: async ({ request, locals }) => {
    const fd = await request.formData();
    const title = String(fd.get('title') ?? '').trim();
    if (!title) return fail(400, { message: 'title required' });

    try {
      await db.insertUnique('todos', { title }); // unique index
    } catch (e) {
      return fail(409, { message: 'duplicated' });
    }

    throw redirect(303, '/todos'); // PRG 패턴
  }
};
```

> **PRG(Post/Redirect/Get)**: 303 리다이렉트로 새로고침 중복 제출 방지.

---

### 302/303/307 리다이렉트 혼동

- **303 See Other**: 폼 제출 후 **GET**으로 리다이렉트 (권장: PRG)
- **302/307**: 메서드 보존 차이. 대부분 **303**가 UX에 안전

#### ✅ 권장

```ts
import { redirect } from '@sveltejs/kit';
throw redirect(303, '/done');
```

---

### `fail()`과 **상태 전달** 누락

#### ❌ 문제 예 — 검증 실패 시 메시지가 안 보임

```ts
// +page.server.ts
export const actions = {
  login: async ({ request }) => {
    const fd = await request.formData();
    const email = String(fd.get('email') || '');
    const pass = String(fd.get('password') || '');
    if (!email || !pass) return { error: 'required' };  // ❌
  }
};
```

#### ✅ 해결 — `fail(status, data)` 사용

```ts
import { fail } from '@sveltejs/kit';
export const actions = {
  login: async ({ request }) => {
    const fd = await request.formData();
    const email = String(fd.get('email') || '');
    const pass = String(fd.get('password') || '');
    if (!email || !pass) return fail(400, { message: '필수 입력', fields: { email, passPresent: !!pass } });
    // ...
    return { success: true };
  }
};
```

```svelte
<!-- +page.svelte -->
<script>
  export let form; // load에서 제공됨(점진적 향상)
</script>

{#if form?.message}<p class="err">{form.message}</p>{/if}
<input name="email" value={form?.fields?.email || ''} />
```

---

### 서버 액션에서 **예외를 그냥 던짐** → HTML 응답 깨짐/CSR 전용에서 곤란

#### ✅ 권장

- 예상 가능한 오류는 **`fail(status, data)`**
- 인증/권한 없으면 **`error(401|403)`** 또는 **리다이렉트**
- 진짜 예외는 **로그** 후 500

```ts
import { error, fail } from '@sveltejs/kit';
export const actions = {
  secure: async ({ locals }) => {
    if (!locals.user) throw error(401, '로그인 필요');
    try {
      // ...
    } catch (e) {
      return fail(500, { message: '서버 오류' });
    }
  }
};
```

---

### 액션 후 **폼 상태 초기화/유지** 충돌

- **성공 시**: **303 리다이렉트**로 새 페이지에서 **깨끗한 상태**
- **실패 시**: `fail()`로 **기존 입력 유지**(위 예처럼 `fields`로 돌려주기)

---

### 파일 업로드에서 **`enctype` 누락**

#### ❌ 문제

```svelte
<form method="post">
  <input type="file" name="photo" />
</form>
```

> 파일이 전송되지 않거나 비어 있는 FormData.

#### ✅ 해결

```svelte
<form method="post" enctype="multipart/form-data">
  <input type="file" name="photo" />
</form>
```

서버:
```ts
export const actions = {
  upload: async ({ request }) => {
    const fd = await request.formData();
    const file = fd.get('photo');
    // file instanceof File 확인
  }
};
```

---

### CSRF 토큰 누락/검증 실패

- **서버 렌더 폼**에서는 **hidden CSRF 토큰**을 포함하고, 서버에서 **검증**
- **서드파티 오리진**에서 POST가 들어오지 않게 **CSRF 보호**(Origin/Referer 검사, samesite 쿠키)

```svelte
<!-- 서버에서 token 값 주입 -->
<input type="hidden" name="csrf" value={data.csrf} />
```

```ts
// 서버 액션
export const actions = {
  submit: async ({ request, locals }) => {
    const fd = await request.formData();
    const token = String(fd.get('csrf') || '');
    if (!locals.csrf || token !== locals.csrf) return fail(403, { message: 'CSRF' });
    // ...
  }
};
```

---

### 진단 체크리스트

- [ ] **PRG**: 성공 후 `redirect(303, ...)`
- [ ] 검증 실패는 **`fail(status, data)`**
- [ ] **중복 제출 방지**: 서버 멱등성(토큰/unique)
- [ ] 파일 업로드 **`enctype` 설정**
- [ ] **CSRF 토큰**/Origin 검증
- [ ] 클라 상태 유지 필요 시 **fields**를 다시 내려 표시

---

## 부록: 빠른 레시피

### “리스트 항목 토글이 안 바뀜”

```svelte
<script>
  let items = [{ id:1, done:false }, { id:2, done:false }];
  function toggle(id){
    items = items.map(x => x.id===id ? { ...x, done: !x.done } : x); // 재할당
  }
</script>
```

(Svelte 5)
```svelte
<script>
  const items = $state([{ id:1, done:false }, { id:2, done:false }]);
  function toggle(id){
    const x = items.find(x=>x.id===id);
    if (x) x.done = !x.done; // 변이 허용
  }
</script>
```

---

### “레이아웃에서 세션을 못 받아요”

- 세션/사용자 정보는 **`handle` 훅**에서 `event.locals`에 저장 → **`+layout.server.ts`** 에서 읽어 내려보내기
```ts
// hooks.server.ts
export const handle = async ({ event, resolve }) => {
  const token = event.cookies.get('session');
  event.locals.user = token ? await getUser(token) : null;
  return resolve(event);
};
```

```ts
// +layout.server.ts
export const load = async ({ locals }) => ({ user: locals.user });
```

---

### “`fetch`가 서버/클라에서 달라요”

- 서버 `load`의 `fetch`는 **내부 프록시** (쿠키/세션 전파, 로컬 요청 최적화)
- 클라 `load`의 `fetch`는 **브라우저 fetch** (CORS/캐시 영향)
- **쿠키 필요한 API**는 가능하면 **서버 `load`**에서 호출해 값을 컴포넌트로 전달

---

### “스크롤 유지/복원 안 됨”

- **`+layout.svelte`**에서 `afterNavigate`로 스크롤 정책 구현
- 또는 **라우팅 옵션**에서 `noScroll`/`keepfocus` 제어

```ts
import { afterNavigate } from '$app/navigation';
afterNavigate(() => {
  // hash 있으면 해당 앵커, 아니면 top
  if (!location.hash) scrollTo({ top:0, behavior:'auto' });
});
```

---

## 수식 코너(반응 경로 직관)

Svelte의 업데이트 비용은 **더럽혀진(변경된) 경로 수**에 선형:
$$
T_{\text{update}} \approx \sum_{i \in \text{dirty}} c_i
$$
- 컴파일러가 **어떤 구문이 어떤 노드를 갱신하는지**를 미리 계산
- **불필요한 재랜더**를 줄이는 핵심은 **정확한 할당/의존**이다.

---

## 종합 체크리스트

### 반응성

- [ ] 부분 변이 후 **재할당** 또는 Svelte 5의 `$state` 사용
- [ ] 구조분해로 **참조 단절** 여부 확인
- [ ] `$:` 내 비동기는 **취소/경쟁** 관리

### `load`/캐시

- [ ] 서버/클라 **실행 위치** 구분
- [ ] `depends`/`invalidate`로 **무효화 경로** 명시
- [ ] API 캐시 헤더 확인(브라우저 캐시 간섭)

### SSR/브라우저 API

- [ ] 상단 스코프/서버 코드에서 **브라우저 API 금지**
- [ ] 동적 import + `onMount` 패턴 확립

### 폼/리다이렉트

- [ ] **PRG(303)**
- [ ] `fail(status, data)`로 오류 전달
- [ ] 멱등성·CSRF·`enctype` 점검

---

## 결론

- Svelte의 반응성은 **“할당”**과 **명확한 의존**으로 성립한다.
- `load`는 **경계(서버/클라)**와 **무효화 규칙**을 정확히 알아야 한다.
- SSR 환경에서는 **브라우저 API**를 **마운트 이후**로 미루고,
- 폼 액션은 **PRG + fail()**을 기본기로 가져가면 대부분의 함정을 피해갈 수 있다.

> 이 장을 기준으로 **자주 반복되는 버그를 빠르게 식별/교정**할 수 있을 것이다. 팀 온보딩에 체크리스트로 붙여 두자.
