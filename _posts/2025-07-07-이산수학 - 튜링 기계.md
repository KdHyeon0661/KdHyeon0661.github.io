---
layout: post
title: 이산수학 - 튜링 기계
date: 2025-07-03 22:20:23 +0900
category: 이산수학
---
# 튜링 기계(Turing Machine)

## 튜링 기계의 정식 정의

튜링 기계(TM)는 다음 7튜플로 정의합니다.
$$
M=(Q,\Sigma,\Gamma,\delta,q_0,q_{\text{accept}},q_{\text{reject}})
$$

- \(Q\): **유한** 상태 집합
- \(\Sigma\): **입력 알파벳**(빈칸 기호 제외)
- \(\Gamma\): **테이프 알파벳**(\(\Sigma \subseteq \Gamma\), 빈칸(□) 포함)
- \(\delta: Q\times \Gamma \rightarrow Q\times \Gamma \times \{L,R\}\): 전이 함수
- \(q_0\): 시작 상태
- \(q_{\text{accept}}\): 수용 상태
- \(q_{\text{reject}}\): 거부 상태(\(q_{\text{reject}}\neq q_{\text{accept}}\))

**동작:**
현재 상태 \(q\)와 읽은 기호 \(a\)에 대해 \(\delta(q,a)=(q',b,D)\) 이면,
- 현재 칸에 \(b\)를 **쓴 뒤**,
- 헤드를 \(D\in\{L,R\}\) 방향으로 **한 칸 이동**,
- 상태를 \(q'\)로 변경합니다.

**종료:** \(q_{\text{accept}}\) 또는 \(q_{\text{reject}}\)에 **진입하면 즉시 정지**합니다.

---

## 구성요소·기본 개념 디테일

### 테이프, 헤드, 빈칸

- 테이프는 **무한 길이**(보통 한 방향 또는 양방향)
- 입력은 테이프에 왼쪽부터 한 칸씩 기록, 나머지는 □(blank)
- 헤드는 한 번에 **한 칸**만 이동(L 또는 R)

### 구성(Instantaneous Description, ID)

한 순간의 기계 상태를
$$
u\,q\,a\,v \quad (u,v\in\Gamma^*,\,a\in\Gamma,\,q\in Q)
$$
처럼 표기하기도 합니다. (헤드가 \(a\) 위에 있고 상태가 \(q\)이며 테이프가 \(uav\))

### 수용 방식

- **최종 상태 수용**: \(q_{\text{accept}}\)에 들어가면 수용
- **거부**: \(q_{\text{reject}}\)에 들어가면 거부
- 일부 정의는 “단순 정지(halt)”를 수용으로 보기도 하나, **본 문서에서는 accept/reject를 구분**합니다.

---

## 예제 ①: 1의 개수가 짝수인지 결정하는 TM

**언어**
$$
L=\{\,w\in\{0,1\}^* \mid \#1(w)\ \text{가 짝수}\,\}
$$

**아이디어**
- 상태 \(q_0\): 지금까지 1의 개수가 짝수
- 상태 \(q_1\): 지금까지 1의 개수가 홀수
- 입력을 오른쪽으로 훑으며 1을 만날 때마다 \(q_0 \leftrightarrow q_1\) 전환
- 빈칸(□)을 만났을 때 \(q_0\)면 **accept**, \(q_1\)면 **reject**

**전이표(일부)**
| 현재 | 읽음 | 씀 | 이동 | 다음 |
|---|---|---|---|---|
| \(q_0\) | 1 | 1 | R | \(q_1\) |
| \(q_0\) | 0 | 0 | R | \(q_0\) |
| \(q_0\) | □ | □ | R | \(q_{\text{accept}}\) |
| \(q_1\) | 1 | 1 | R | \(q_0\) |
| \(q_1\) | 0 | 0 | R | \(q_1\) |
| \(q_1\) | □ | □ | R | \(q_{\text{reject}}\) |

---

## 인식기 vs 결정기, 언어 클래스

| 클래스 | 정의 | TM 동작 |
|---|---|---|
| **RE**(재귀적으로 열거 가능, Turing-recognizable) | 어떤 TM이 **해당 언어의 모든 원소를 수용**(언어 밖이면 **무한 루프** 가능) | 수용/무반응(비정지) |
| **Recursive**(결정 가능, Decidable) | 어떤 TM(결정기)이 **모든 입력에서 반드시 정지**하며 수용/거부를 말해줌 | 항상 정지(수용/거부) |

- 모든 Recursive 언어는 RE지만, RE 중에는 결정 불가능(비정지 케이스 존재) 언어가 있습니다.

---

## 변형 모델과 계산 능력

| 모델 | 설명 | 계산 능력 |
|---|---|---|
| **다중 테이프 TM** | 여러 테이프/헤드 | 단일테이프 TM와 **동등** (시간만 다를 수 있음) |
| **양방향 무한 테이프** | 좌/우 무한 | 동등 |
| **다중 트랙** | 한 칸에 여러 트랙(기호 묶음) | 동등 |
| **비결정 TM(NTM)** | 분기적 연산 | 인식 능력은 동등(RE/Recursive 차원), **시간복잡도** 이슈에서 NP 정의에 사용 |
| **RAM/λ-계산** | 다른 계산 모델 | 모두 **튜링 등가** |

> **중요:** 모델에 상관없이 “계산 가능성(무엇을 풀 수 있는가)”은 동일합니다(Church–Turing 논제).

---

## & 인코딩

**보편 TM(UTM)**: 입력으로 “기계 \(M\)의 기술 \(\langle M\rangle\)”와 “입력 \(w\)”를 받아 **\(M\)이 \(w\)에서 수행하는 계산을 시뮬레이션**하는 단일 TM.

- 전이 함수를 코드화: \(\langle \delta\rangle\)
- 테이프 초기화: \(\langle M\rangle \# w\) 등
- 시뮬레이션 루프: \((q,a)\mapsto(q',b,D)\)를 따라 테이프를 갱신

> 이로써 “**모든 프로그램을 입력으로 받아 실행하는 하나의 기계**”가 가능함을 보입니다.

---

## 결정 불가능성: 정지 문제(Halting), Rice의 정리, 대각선

### 정지 문제(HALTING PROBLEM)

> 임의의 프로그램 \(P\)와 입력 \(x\)에 대해, \(P(x)\)가 **정지하는지** 일반적으로 **결정할 수 없다**.

**대략 증명(대각선/귀류)**
“정지 여부를 결정하는 결정기 \(H(P,x)\)”가 있다고 가정하고,
그 \(H\)를 **역설적**으로 호출하는 \(D(P)\)를 구성하면 모순에 도달 → **불가능**.

### \(A_{TM}=\{\langle M,w\rangle\mid M \text{이 } w \text{를 수용}\}\)은 결정 불가능

- 인식은 가능(RE)하지만, **모든 입력에서 정지**하는 결정기는 존재하지 않음.

### Rice의 정리

> **의미적(ssemantic) 비자명 속성**(TM이 인식하는 언어에 대한 속성)은 **결정 불가능**.
예: “이 TM이 공집합을 인식하는가?”, “유한 언어를 인식하는가?” 등.

---

## 복잡도 이론 스냅샷

- **시간/공간 자원**을 함수로 제한:
  - \( \mathrm{TIME}(f(n)), \mathrm{SPACE}(f(n)) \)
- 대표 클래스
  - **P**: 다항시간 결정 가능
  - **NP**: 비결정 다항시간에서 수용(증명 검증 다항)
  - **PSPACE**: 다항공간
  - **EXP**: 지수시간
- 포함 관계(알려진 사실)
  - \( \text{P} \subseteq \text{NP} \subseteq \text{PSPACE} \subseteq \text{EXP} \)
  - \( \text{P}\overset{?}{=}\text{NP} \) 미해결
- **다중테이프→단일테이프** 시뮬: 시간 \(t(n)\)이 **\(O(t(n)^2)\)** 정도로 악화(고전적 결과)

---

## 판정 TM (개념 → 단계)

**언어**
$$
\text{PAL}=\{\,w\in\{0,1\}^*\mid w=w^R\,\}
$$

**아이디어(마킹 방식)**
1. 왼쪽 끝에서 **첫 미표식 기호**를 골라 \(X\)로 치환(마킹)
2. 오른쪽 끝으로 이동해 **대칭 위치 기호**를 확인
   - 동일 기호면 그 자리도 \(X\)로 치환
   - 다르면 **reject**
3. 테이프를 왼쪽으로 돌아와 다음 미표식 기호를 반복
4. 모든 기호가 \(X\)가 되면 **accept**

**상태 스케치**
- \(q_{\text{scanL}}\): 왼쪽에서 미표식(0/1)을 찾음
- \(q_{\text{goR0}},q_{\text{goR1}}\): 0/1을 기억하며 오른쪽 끝으로 전진
- \(q_{\text{check0}},q_{\text{check1}}\): 끝 기호 검사 후 \(X\)로 치환
- \(q_{\text{backL}}\): 다시 왼쪽으로 복귀

> 이 방식은 “읽고-표시-맞짝검사-복귀”의 **선형 반복**으로 작동합니다.

---

## 예제 ③: 단항 덧셈 \(1^m\#1^n \mapsto 1^{m+n}\)

**입력 형식**: `111#1111` (1의 개수가 피연산자)
**출력 목표**: `1111111` (구분자 제거 + 합치기)

**전략**
- `#`를 지우지 않고 오른쪽 피연산자의 1을 하나씩 왼쪽으로 옮겨 붙여도 되고,
- 더 간단히는 `#`를 `1`로 덮어쓰고 오른쪽 1들은 그대로 두면 자동으로 합쳐짐:
  - 시작 상태에서 `#`를 만나면 `1`로 바꾸고 **accept**(이미 붙었음)
  - 단, 입력 검증(형식 위반) 등 로직을 추가할 수 있음

---

## 파이썬으로 **단일테이프 결정적 TM 시뮬레이터**

> **전이 사전**: `delta[(state, read_symbol)] = (next_state, write_symbol, move)`
> `move`는 `'L'` 또는 `'R'`.
> 빈칸 기호는 `'_'`로 표기합니다(코드 내부 관례).

```python
from collections import defaultdict

BLANK = '_'  # 테이프 빈칸 기호

class Tape:
    def __init__(self, s=''):
        # tape는 양방향 무한을 딕셔너리로 느슨하게 흉내
        self.cells = defaultdict(lambda: BLANK)
        for i, ch in enumerate(s):
            self.cells[i] = ch
        self.min_i = 0
        self.max_i = max(0, len(s)-1)
        self.head = 0

    def read(self):
        return self.cells[self.head]

    def write(self, ch):
        self.cells[self.head] = ch
        self.min_i = min(self.min_i, self.head)
        self.max_i = max(self.max_i, self.head)

    def move(self, dirc):
        if dirc == 'L':
            self.head -= 1
        elif dirc == 'R':
            self.head += 1
        else:
            raise ValueError("move must be 'L' or 'R'")

    def snapshot(self, window=40):
        lo = min(self.min_i, self.head - window//2)
        hi = max(self.max_i, self.head + window//2)
        s = []
        for i in range(lo, hi+1):
            c = self.cells[i]
            if i == self.head:
                s.append(f'[{c}]')
            else:
                s.append(f' {c} ')
        return ''.join(s)

class TuringMachine:
    def __init__(self, Q, Sigma, Gamma, delta, q0, q_accept, q_reject):
        self.Q = set(Q)
        self.Sigma = set(Sigma)
        self.Gamma = set(Gamma)
        self.delta = dict(delta)          # {(q,a):(q',b,dir)}
        self.q0 = q0
        self.q_accept = q_accept
        self.q_reject = q_reject

    def run(self, input_str, step_limit=10_000, trace=False):
        tape = Tape(input_str)
        q = self.q0
        for step in range(step_limit):
            if trace:
                print(f"step={step:05d}  q={q:>8s}  tape: {tape.snapshot(30)}")
            if q == self.q_accept:
                return True, tape
            if q == self.q_reject:
                return False, tape
            a = tape.read()
            key = (q, a)
            if key not in self.delta:
                # 정의되지 않은 전이 => 거부(or 정지)로 처리
                return False, tape
            q2, b, d = self.delta[key]
            tape.write(b)
            tape.move(d)
            q = q2
        # step limit에 걸리면 비정지로 간주
        return None, tape  # None = 미정지(무한 루프 가능)
```

---

## 시뮬레이터 테스트 ①: 짝수 개의 ‘1’ 인식 TM

아래 TM은 §3의 논리를 그대로 구현합니다.
입력 알파벳은 `{'0','1'}`, 테이프 알파벳에 빈칸 `'_'` 추가.

```python
# 상태/알파벳 정의

Q = {'q0','q1','qa','qr'}
Sigma = {'0','1'}
Gamma = {'0','1',BLANK}
q0, qa, qr = 'q0', 'qa', 'qr'

delta = {
    ('q0','1'): ('q1','1','R'),
    ('q0','0'): ('q0','0','R'),
    ('q0',BLANK): ('qa',BLANK,'R'),

    ('q1','1'): ('q0','1','R'),
    ('q1','0'): ('q1','0','R'),
    ('q1',BLANK): ('qr',BLANK,'R'),
}

tm_even_ones = TuringMachine(Q, Sigma, Gamma, delta, q0, qa, qr)

for s in ["", "1", "10", "1010", "1110", "0100"]:
    ok, tape = tm_even_ones.run(s, trace=False)
    print(f"input={s!r} => accept={ok}")
```

**예상 결과**
- `""`(빈 입력): 1의 개수 0(짝수) → True
- `"1"`: 1개(홀수) → False
- `"10"`: 1개(홀수) → False
- `"1010"`: 2개(짝수) → True
- … 등

---

## 시뮬레이터 테스트 ②: 팰린드롬 인식 TM(개념 버전)

“마킹 방식”의 대략적인 전이를 간단화해 시연용으로 구성합니다.
(학습 목적상 상태 수를 줄여 설명하며, 실제 완비 전이는 더 길 수 있습니다.)

```python
Q = {'scanL','goR0','goR1','check0','check1','backL','qa','qr'}
Sigma = {'0','1'}
Gamma = {'0','1','X',BLANK}
q0, qa, qr = 'scanL', 'qa', 'qr'

delta = {}
# 수용.

delta.update({
    ('scanL','X'): ('scanL','X','R'),
    ('scanL','0'): ('goR0','X','R'),  # 0을 X로 마킹하고 오른쪽 끝 매칭 찾으러
    ('scanL','1'): ('goR1','X','R'),
    ('scanL',BLANK): ('qa',BLANK,'R'), # 전부 마킹 완료 => accept
})

# goR0/goR1: 오른쪽 끝으로 간다(가장 오른쪽 미표식 찾기 위해)

delta.update({
    ('goR0','0'): ('goR0','0','R'),
    ('goR0','1'): ('goR0','1','R'),
    ('goR0','X'): ('goR0','X','R'),
    ('goR0',BLANK): ('check0',BLANK,'L'),  # 끝 도달 후 한 칸 왼쪽에서 검사

    ('goR1','0'): ('goR1','0','R'),
    ('goR1','1'): ('goR1','1','R'),
    ('goR1','X'): ('goR1','X','R'),
    ('goR1',BLANK): ('check1',BLANK,'L'),
})

# check0/check1: 오른쪽에서 첫 미표식이 기대 기호인지 검사하고 X로 마킹

delta.update({
    ('check0','X'): ('check0','X','L'),
    ('check0','0'): ('backL','X','L'),
    ('check0','1'): ('qr','1','L'),    # 불일치 => reject
    ('check0',BLANK): ('qa',BLANK,'R'),# 길이 1 남은 케이스도 통과

    ('check1','X'): ('check1','X','L'),
    ('check1','1'): ('backL','X','L'),
    ('check1','0'): ('qr','0','L'),
    ('check1',BLANK): ('qa',BLANK,'R'),
})

# backL: 왼쪽으로 돌아가 다음 라운드

delta.update({
    ('backL','0'): ('backL','0','L'),
    ('backL','1'): ('backL','1','L'),
    ('backL','X'): ('backL','X','L'),
    ('backL',BLANK): ('scanL',BLANK,'R'),  # 왼쪽 끝에서 다시 scanL로
})

tm_pal = TuringMachine(Q, Sigma, Gamma, delta, q0, qa, qr)

for s in ["", "0", "1", "00", "0110", "010", "01110", "0101"]:
    ok, tape = tm_pal.run(s, step_limit=5000, trace=False)
    print(f"PAL? input={s!r} => {ok}")
```

> 이 구성은 교육용 최소 스케치라 모든 경계 상황(예: 홀수 길이 처리)을 간결히 처리했습니다.
> 실제 과제에서는 **정확한 전이 완성**과 **테이프 헤드 귀환**을 더 엄밀히 작성하세요.

---

## TM

**전략(간단화)**: `#`를 만나면 이를 `1`로 덮어쓰고 곧장 **수용**하면, 테이프에는 `1^{m} 1 1^{n} = 1^{m+n+1}`가 되어 버립니다.
→ 원하는 출력 `1^{m+n}`을 정확히 얻으려면, `#`을 지우고 오른쪽의 첫 1 하나를 지우는 식으로 **정확히 1개 감소**를 동시에 수행하거나,
애초에 입력을 `1^m 0 1^n`으로 두고 `0`을 `ε`로 삭제하는 식의 설계를 택하세요.

아래는 “`#`를 지우고 오른쪽 블록의 1 하나를 지우고 종료” 스케치:

```python
Q = {'scan', 'steal', 'back', 'qa','qr'}
Sigma = {'1','#'}
Gamma = {'1','#','X',BLANK}
q0, qa, qr = 'scan', 'qa', 'qr'

delta = {}
# scan: 왼쪽 블록을 지나 # 찾기

delta.update({
    ('scan','1'): ('scan','1','R'),
    ('scan','#'): ('steal',BLANK,'R'),  # # 삭제
})
# steal: 오른쪽 블록에서 1 하나를 'X'로 지우고 back

delta.update({
    ('steal','1'): ('back',BLANK,'L'),  # 하나 지우기
    ('steal',BLANK): ('qa',BLANK,'R'),  # 오른쪽이 비어있다면 m+n = m (n=0) => 그냥 수용
})
# back: 왼쪽으로 돌아가 시작점 확인 후 수용

delta.update({
    ('back','1'): ('back','1','L'),
    ('back',BLANK): ('qa',BLANK,'R'),
})

tm_add = TuringMachine(Q, Sigma, Gamma, delta, q0, qa, qr)

for s in ["#","1#","11#","1#1","11#111"]:
    ok, tape = tm_add.run(s, step_limit=1000, trace=False)
    # 결과 테이프 프린트(간이): 남아있는 1의 개수를 세어봄
    ones = sum(1 for i in range(tape.min_i, tape.max_i+1) if tape.cells[i]=='1')
    print(f"input={s!r} accept={ok}  ones_remaining={ones}  tape={tape.snapshot(20)}")
```

> 연습 문제: 위 설계를 **정확한 출력 규격**(예: 공백 없이 \(1^{m+n}\)만 남기기)으로 다듬어 보세요.
> (마지막 정리 단계에서 남은 `X`를 모두 `1` 또는 BLANK로 바꾸는 루프가 필요)

---

## 열거기(Enumerator)와 RE 언어

**열거기**는 **쓰기 전용 출력**을 갖는 TM으로, 무한히 실행되며 해당 언어의 **모든 문자열을 (중복 가능하되) 언젠가 출력**합니다.
- 어떤 언어가 **RE**라면, 그 언어를 **열거하는 열거기**가 존재합니다.
- 반대로, 어떤 언어를 열거하는 열거기가 있으면 그 언어는 RE입니다.

**아이디어**: 입력 없이 사전순으로 모든 문자열을 생성 → 가설 증명 절차와 교차 실행 → 조건을 만족하면 출력.

---

## 환원(Reduction)과 부정결정성 증명 스케치

- **감소환원( many-one reduction )**: \(A \le_m B\)는 결정문제 \(A\)를 \(B\)로 **계산 가능한 함수** \(f\)를 통해 변환하여,
  \(x\in A \iff f(x)\in B\)가 되게 함.
  결정 가능성/불가능성, RE/REC 성질을 **전달**하는 데 씁니다.

**예:** \(A_{TM}\)이 결정 불가능임을 알고 있을 때, 어떤 문제 \(B\)가 주어지면 \(A_{TM} \le_m B\)를 보이면 \(B\)도 결정 불가능.

---

## 실무 모델과의 연결

- **프로그래밍 언어**: Python/C/Java는 모두 튜링 완전 → TM을 쉽게 **시뮬레이션** 가능
- **컴파일러 이론**: 정규/문맥자유는 FA/PDA로 다루고, 그 이상은 TM 수준의 계산 필요
- **정적 분석/검증**: Rice의 정리로 “모든 프로그램의 비자명 의미 속성”은 일반해가 없음 → 제한/근사/도구가 필요

---

## 연습 문제

1. **짝수 길이** 문자열(알파벳 \(\{0,1\}\))만 수용하는 TM을 설계하고 시뮬레이터에 올려보세요.
2. 언어 \( \{\, 0^n 1^n \mid n\ge 0 \,\} \) **결정기 TM**을 설계(마킹/카운팅)하고 시뮬레이터로 디버깅하세요.
3. \(A_{TM}\)에서 **정지 문제**로의 환원 스케치를 작성해 보세요.
4. 다중테이프 TM을 단일테이프로 시뮬하는 방법을 설명하고 \(t(n)\to O(t(n)^2)\) 근거를 정리하세요.

---

## 핵심 요약

- **튜링 기계**: 무한 테이프 + 상태 + 읽기/쓰기/이동 + 수용/거부
- **RE vs Recursive**: 인식 가능/결정 가능의 차이(정지 보장 유무)
- **보편 TM**: “프로그램+입력”을 받아 시뮬레이션하는 하나의 기계
- **정지 문제/라이스 정리**: 일반적 프로그램 속성 판정은 **결정 불가능**
- **복잡도**: P, NP, PSPACE, EXP 등 자원 제약 관점
- **실전**: 파서/도구/프로토타입에서 TM 모델은 **최종 이론적 기준점**

---

## 부록: 시뮬레이터 사용 팁

- **trace=True**로 단계별 테이프 스냅샷을 관찰하면 전이 디버깅에 유용합니다.
- 전이가 정의되지 않으면 본 구현은 **거부(False)** 처리합니다(정책에 따라 함정 상태로 전개해도 됨).
- 무한 루프 판단은 **`step_limit`**를 이용해 **None** 반환으로 구분했습니다.

```python
# 예: 트레이스 실행

ok, tape = tm_pal.run("0110", trace=True, step_limit=200)
print("ACCEPT?" , ok)
```

> TM 설계는 “**테이프 정리 단계**(마킹 복원/정리)”를 빼먹기 쉽습니다.
> 수용 직전/직후의 최종 테이프 형태도 **명세**로 정해 두고 전이를 채우면 오류를 줄일 수 있습니다.
