---
layout: post
title: Spring - 리액티브 스택
date: 2025-10-16 20:25:23 +0900
category: Spring
---
# 14. 리액티브 스택(WebFlux) — 개념·핸즈온·R2DBC·선택 기준

> 목표: **리액티브 스트림/Mono/Flux**의 개념을 정확히 잡고, **WebFlux 라우팅/핸들러**를 코드로 익히며, **R2DBC**로 DB까지 논블로킹으로 이어붙인다. 마지막으로 **언제 WebFlux를 선택할지** 실무 기준(장단점/성능 특성/주의점)을 정리한다.
> 전제: Spring Boot 3.3+, Java 21, Spring WebFlux, Project Reactor, R2DBC(PostgreSQL) 기준.

---

## A. 리액티브 스트림/Mono/Flux 개념

### A-1. 핵심 정의
- **Reactive Streams 표준**: `Publisher`(발행)–`Subscriber`(구독)–`Subscription`(요청/취소)–`Processor`(중간 처리). **역압(backpressure)**로 “얼마나 받을지”를 하류가 상류에 요청.
- **Project Reactor**: 표준 구현체. 스프링 리액티브의 기반.
  - **`Mono<T>`**: 0~1개 신호(성공 1개 or 빈/에러/완료).
  - **`Flux<T>`**: 0~N개 신호(스트림).
- **시그널**: `onNext`(데이터), `onComplete`(정상 완료), `onError`(에러).

### A-2. 콜드 vs 핫
- **콜드**: 구독마다 새로 데이터를 생성(HTTP 호출/DB 조회/파일 읽기). `WebClient.get().retrieve().bodyToMono(Foo)` 등.
- **핫**: 생성이 이미 진행 중(브로드캐스트/센서/토픽). 여러 구독자에 동일한 이벤트를 푸시. (예: `Sinks.many().multicast()`)

### A-3. 간단 실습
```java
Mono<String> m = Mono.just("hello").map(String::toUpperCase);    // HELLO
Flux<Integer> f = Flux.range(1, 5).filter(n -> n % 2 == 1);       // 1,3,5
```

### A-4. 변환/결합 오퍼레이터
- **map**(동기 1:1 변환), **flatMap**(비동기/내부 Publisher 펼치기), **concatMap**(순서 보장), **switchIfEmpty**, **zip**, **merge**, **buffer/window** …
```java
Flux<String> names = Flux.just("a","bb","ccc");
Flux<Integer> lengths = names.map(String::length);                // 1,2,3
Mono<User> u = Mono.just("alice").flatMap(userRepo::findById);    // 비동기 체인
```

### A-5. 에러/리트라이
```java
webClient.get().retrieve().bodyToMono(Foo.class)
  .retryWhen(Retry.backoff(3, Duration.ofMillis(200)).jitter(0.2))
  .onErrorResume(ex -> Mono.just(Foo.empty()));
```

### A-6. 스케줄러/스레딩
- Reactor는 기본 **싱글 스레드 이벤트 루프(Netty)** 상에서 동작.
- **블로킹 호출 금지**: JDBC, 파일 큰 읽기, 외부 SDK 블로킹 등은 **`boundedElastic()`**에 격리.
```java
Mono.fromCallable(() -> blockingCall())
    .subscribeOn(Schedulers.boundedElastic());
```

### A-7. 역압(backpressure) 맛보기
```java
Flux.interval(Duration.ofMillis(1))   // 1ms마다 값 발행
    .onBackpressureBuffer(10_000)     // 버퍼(주의: 메모리)
    .sample(Duration.ofMillis(100))   // 샘플링
    .subscribe(System.out::println);
```
- 기본: Subscriber가 `request(n)`으로 수요를 제어. Reactor는 오퍼레이터가 적절히 변환/버퍼링.

---

## B. WebFlux 라우팅/핸들러(함수형) & 애노테이션 스타일

### B-1. 의존성 요약
```kotlin
dependencies {
  implementation("org.springframework.boot:spring-boot-starter-webflux")
  implementation("org.springframework.boot:spring-boot-starter-validation")
  testImplementation("org.springframework.boot:spring-boot-starter-test")
  testImplementation("io.projectreactor:reactor-test")
}
```

### B-2. 함수형 라우팅 API(실전 선호 예)
#### 1. 도메인/DTO
```java
public record CreateOrderRequest(@NotBlank String userId, @Positive long total) {}
public record OrderView(Long id, String userId, long total) {}
```

#### 2. 핸들러
```java
@Component
@RequiredArgsConstructor
public class OrderHandler {

  private final OrderService service;

  public Mono<ServerResponse> create(ServerRequest req) {
    return req.bodyToMono(CreateOrderRequest.class)
      .flatMap(service::create)                                        // Mono<OrderView>
      .flatMap(v -> ServerResponse.created(URI.create("/orders/"+v.id()))
                                    .contentType(MediaType.APPLICATION_JSON)
                                    .bodyValue(v))
      .onErrorResume(WebFluxErrors::toProblemResponse);
  }

  public Mono<ServerResponse> get(ServerRequest req) {
    long id = Long.parseLong(req.pathVariable("id"));
    return service.get(id)
      .flatMap(v -> ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).bodyValue(v))
      .switchIfEmpty(ServerResponse.notFound().build());
  }
}
```

#### 3. 라우터
```java
@Configuration
public class OrderRoutes {
  @Bean
  RouterFunction<ServerResponse> routes(OrderHandler h) {
    return RouterFunctions.route()
      .POST("/orders", RequestPredicates.accept(MediaType.APPLICATION_JSON), h::create)
      .GET("/orders/{id}", h::get)
      .build();
  }
}
```

> 장점: **고성능**(핸들러 시그니처가 바로 Mono), **필터 체인** 구성 간결.
> 애노테이션 스타일도 동일하게 가능(`@RestController` + `@GetMapping`), 반환 타입만 `Mono`/`Flux`.

### B-3. 필터(HandlerFilterFunction)와 글로벌 예외
```java
@Bean
RouterFunction<ServerResponse> routes(OrderHandler h) {
  return RouterFunctions.route()
    .POST("/orders", h::create)
    .GET("/orders/{id}", h::get)
    .filter((req, next) -> {
      long start = System.currentTimeMillis();
      return next.handle(req)
        .doFinally(sig -> System.out.println("took="+(System.currentTimeMillis()-start)+"ms"));
    })
    .build();
}
```

글로벌 예외/문제응답(간단 예):
```java
@Component
public class WebFluxErrors {

  static Mono<ServerResponse> toProblemResponse(Throwable ex) {
    var body = Map.of("title","Bad Request","detail", ex.getMessage());
    return ServerResponse.status(HttpStatus.BAD_REQUEST)
      .contentType(MediaType.APPLICATION_JSON)
      .bodyValue(body);
  }
}
```

### B-4. 유효성 검증(WebFlux + Bean Validation)
```java
public Mono<CreateOrderRequest> readAndValidate(ServerRequest req, Validator validator) {
  return req.bodyToMono(CreateOrderRequest.class)
    .flatMap(body -> {
      var errors = new BeanPropertyBindingResult(body, "createOrderRequest");
      validator.validate(body, errors);
      if (errors.hasErrors()) return Mono.error(new IllegalArgumentException(errors.toString()));
      return Mono.just(body);
    });
}
```
> 팁: `spring-boot-starter-validation` 추가하면 `LocalValidatorFactoryBean` 자동 주입.

### B-5. SSE/스트리밍 응답
```java
@GetMapping(value="/ticks", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<ServerSentEvent<Long>> ticks() {
  return Flux.interval(Duration.ofSeconds(1))
             .map(seq -> ServerSentEvent.builder(seq).event("tick").build());
}
```

---

## C. WebClient(논블로킹 HTTP 클라이언트)

### C-1. 기본 사용
```java
@Bean WebClient webClient() {
  return WebClient.builder()
    .baseUrl("https://api.example.com")
    .clientConnector(new ReactorClientHttpConnector(HttpClient.create().compress(true)))
    .build();
}

Mono<Foo> foo = webClient.get().uri("/foos/{id}", id)
    .accept(MediaType.APPLICATION_JSON)
    .retrieve()
    .onStatus(s -> s.is4xxClientError(), resp -> resp.bodyToMono(String.class).map(RuntimeException::new))
    .bodyToMono(Foo.class);
```

### C-2. 타임아웃/재시도/회로차단(간단)
```java
HttpClient http = HttpClient.create()
  .responseTimeout(Duration.ofSeconds(3))
  .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 2000);

WebClient wc = WebClient.builder()
  .clientConnector(new ReactorClientHttpConnector(http))
  .build();

wc.get().uri("/foo")
  .retrieve().bodyToMono(Foo.class)
  .timeout(Duration.ofSeconds(5))
  .retryWhen(Retry.backoff(3, Duration.ofMillis(200)).jitter(0.2));
```

---

## D. R2DBC 개요 — 논블로킹 DB 접근

### D-1. 왜 R2DBC?
- JDBC는 **블로킹**(스레드 점유). 대량 동시 I/O 환경에서 비효율적.
- **R2DBC**는 논블로킹 드라이버로 DB I/O를 리액티브하게 수행. WebFlux와 **일관된 스레드 모델**.

### D-2. 의존성
```kotlin
dependencies {
  implementation("org.springframework.boot:spring-boot-starter-data-r2dbc")
  runtimeOnly("org.postgresql:r2dbc-postgresql")
  // 마이그레이션은 JDBC로 수행(권장) → 별도 프로필/툴(Flyway)로 스키마 관리
  runtimeOnly("org.postgresql:postgresql")
  implementation("org.flywaydb:flyway-core")
}
```

> 일반 패턴: **스키마 마이그레이션은 JDBC(Flyway)**, 런타임 쿼리는 **R2DBC**.

### D-3. 설정
```yaml
spring:
  r2dbc:
    url: r2dbc:postgresql://localhost:5432/acme
    username: acme
    password: acme
  flyway:
    url: jdbc:postgresql://localhost:5432/acme
    user: acme
    password: acme
```

### D-4. Spring Data R2DBC — 엔티티/리포지토리
```java
@Table("orders")
public record OrderEntity(@Id Long id, String userId, long total) {}

public interface OrderR2dbcRepository extends ReactiveCrudRepository<OrderEntity, Long> {
  Flux<OrderEntity> findByUserId(String userId);
}
```

서비스:
```java
@Service
@RequiredArgsConstructor
public class OrderService {
  private final OrderR2dbcRepository repo;

  public Mono<OrderView> create(CreateOrderRequest req) {
    return repo.save(new OrderEntity(null, req.userId(), req.total()))
      .map(e -> new OrderView(e.id(), e.userId(), e.total()));
  }

  public Mono<OrderView> get(long id) {
    return repo.findById(id)
      .map(e -> new OrderView(e.id(), e.userId(), e.total()));
  }
}
```

### D-5. 트랜잭션 (R2DBC Transactional)
```java
@Configuration
class TxConfig {
  @Bean
  ReactiveTransactionManager rtm(ConnectionFactory cf) {
    return new R2dbcTransactionManager(cf);
  }
}

@Service
@RequiredArgsConstructor
public class TxOrderService {
  private final OrderR2dbcRepository repo;

  @Transactional
  public Mono<OrderView> createAndMaybeFail(CreateOrderRequest req) {
    return repo.save(new OrderEntity(null, req.userId(), req.total()))
      .flatMap(e -> {
        if (req.total() > 1_000_000) return Mono.error(new IllegalStateException("too big"));
        return Mono.just(new OrderView(e.id(), e.userId(), e.total()));
      });
  }
}
```

> 주의: 리액티브 트랜잭션 경계 안에서 **블로킹 호출 금지**. (JDBC·파일 IO는 `boundedElastic`로 격리하거나 아예 분리)

### D-6. DatabaseClient(플레인 SQL)
```java
@Service
@RequiredArgsConstructor
public class OrderQueries {
  private final DatabaseClient db;

  public Flux<OrderView> recent(int limit) {
    return db.sql("select id, user_id, total from orders order by id desc limit :limit")
      .bind("limit", limit)
      .map((row, meta) -> new OrderView(row.get("id", Long.class),
                                        row.get("user_id", String.class),
                                        row.get("total", Long.class)))
      .all();
  }
}
```

### D-7. 커넥션 풀/타임아웃
- R2DBC 드라이버별 풀 옵션 확인(예: `r2dbc-pool`).
- 커넥션/쿼리 타임아웃 설정으로 **고착 방지**.

---

## E. WebFlux 테스트 — StepVerifier & WebTestClient

### E-1. StepVerifier (Reactor 테스트)
```java
@Test
void mono_basic() {
  Mono<Integer> m = Mono.just(10).map(x -> x * 2);
  StepVerifier.create(m)
    .expectNext(20)
    .expectComplete()
    .verify();
}
```

### E-2. WebTestClient (컨트롤러/라우터)
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class OrderApiTest {

  @Autowired WebTestClient client;

  @Test
  void create_and_get() {
    var created = client.post().uri("/orders")
      .contentType(MediaType.APPLICATION_JSON)
      .bodyValue(Map.of("userId","alice","total",100))
      .exchange()
      .expectStatus().isCreated()
      .expectBody(OrderView.class)
      .returnResult().getResponseBody();

    client.get().uri("/orders/{id}", created.id())
      .exchange()
      .expectStatus().isOk()
      .expectBody()
      .jsonPath("$.userId").isEqualTo("alice");
  }
}
```

---

## F. 운영 포인트 — 성능/관측/보안

### F-1. 성능 특성
- **I/O 바운드 동시성**에 강함: 외부 API, DB, 캐시, 파일 등 “대기”가 많은 워크로드.
- **CPU 바운드**는 리액티브 장점이 적음(스레드/컨텍스트 전환 오버헤드).
- **블로킹 혼입**은 치명적: 이벤트 루프가 막혀 **전체 처리량 급락**.

### F-2. 반드시 지킬 것(핵심 체크리스트)
- [ ] JDBC/블로킹 SDK 사용 금지(필요 시 **별도 서비스**로 격리).
- [ ] 파일/암호화/이미지 처리 등 CPU 작업은 `boundedElastic()` 사용.
- [ ] **타임아웃**과 **재시도/백오프** 기본 탑재(WebClient, DB).
- [ ] **연결 풀**/큐 크기/힙 사용량 모니터링.
- [ ] 백프레셔 전략(버퍼 제한/샘플링/드롭) 명시.
- [ ] **Metrics**: 요청 레이턴시, event-loop 큐(부하), DB 대기 시간. Micrometer + Prometheus.

### F-3. 보안(리액티브 Security)
```kotlin
dependencies { implementation("org.springframework.boot:spring-boot-starter-oauth2-resource-server") }
```
```java
@EnableWebFluxSecurity
public class SecurityConfig {
  @Bean
  SecurityWebFilterChain chain(ServerHttpSecurity http) {
    return http
      .csrf(ServerHttpSecurity.CsrfSpec::disable)
      .authorizeExchange(ex -> ex
        .pathMatchers("/_health").permitAll()
        .pathMatchers(HttpMethod.GET, "/orders/**").hasAuthority("SCOPE_order:read")
        .anyExchange().authenticated())
      .oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::jwt)
      .build();
  }
}
```

---

## G. WebFlux 선택 가이드 — 언제 쓰고, 언제 피하나

### G-1. 선택하면 좋은 경우
1) **대량 동시 연결**(채팅/알림/SSE/장기 스트림).
2) **외부 API 팬아웃**(N개 호출 묶기)로 **총 지연 단축**.
3) **논블로킹 DB/캐시/메시징** 스택을 이미 보유(R2DBC/Reactive Redis/Kafka).
4) **리소스 절약**이 중요한 멀티테넌트/게이트웨이.

### G-2. 지양/신중할 경우
1) **JDBC 중심**(레거시 SQL/ORM) → WebFlux의 이점이 상쇄.
2) 팀이 리액티브 패턴/디버깅에 익숙하지 않음(학습곡선).
3) **CPU 바운드**(영상 인코딩/ML 추론) → 리액티브 장점 약함.
4) 많은 **블로킹 3rd SDK** 사용(클라우드 클라이언트 일부, 구버전 라이브러리).

### G-3. MVC vs WebFlux 의사결정 요약
| 항목 | Spring MVC | Spring WebFlux |
|---|---|---|
| 모델 | 스레드/요청당 블로킹 | 이벤트루프/논블로킹 |
| 적합 | DB/JDBC 중심, 단순 API | 외부 I/O 팬아웃, SSE/스트림 |
| 장점 | 디버깅/학습 쉬움 | 고동시성/리소스 효율 |
| 위험 | 스레드 많이 필요 | 블로킹 혼입 시 전반 영향 |
| DB | JDBC/하이버네이트 | R2DBC(드라이버 생태 확인) |

---

## H. 부가 주제(필수 팁)

### H-1. 핫 소스 / 브로드캐스트
```java
Sinks.Many<String> bus = Sinks.many().multicast().onBackpressureBuffer();
Flux<String> stream = bus.asFlux();  // 여러 구독자에 브로드캐스트

// 발행
bus.tryEmitNext("event-1");
```

### H-2. 요청-응답 매핑과 타임아웃
```java
Mono<OrderView> call = webClient.post().uri("/pay")
  .bodyValue(Map.of("orderId",1))
  .retrieve().bodyToMono(OrderView.class)
  .timeout(Duration.ofSeconds(2))
  .onErrorResume(TimeoutException.class, e -> fallback());
```

### H-3. 캐싱/공유
```java
Mono<Foo> shared = Mono.defer(() -> expensive())  // 구독 때마다 수행
  .cache(Duration.ofMinutes(5));                  // 5분 캐시
```

### H-4. 로깅 & 훅
```java
Flux.range(1,3)
  .log("range")            // 디버그 로깅(개발 시)
  .doOnNext(v -> audit(v)) // 사이드 이펙트는 doOn*
  .subscribe();
```

---

## I. 실전 템플릿: “WebFlux + R2DBC + Router/Handler” 한 장 요약

1) 의존성: `webflux`, `spring-data-r2dbc`, `r2dbc-postgresql`, `validation`, `reactor-test`.
2) 라우터/핸들러로 HTTP 끝점 설계(함수형) + 글로벌 필터/예외.
3) 서비스는 **Mono/Flux**로 비즈니스 조립, **블로킹 금지**.
4) 데이터 접근은 **R2DBC Repository/DatabaseClient**.
5) 테스트는 **StepVerifier**와 **WebTestClient**.
6) 운영은 **타임아웃/재시도/메트릭** 필수, **event-loop 막지 않기**.
7) 선택 기준: **I/O 동시성** & **논블로킹 스택**이면 WebFlux, 아니면 MVC.

---

## J. 한 페이지 요약
- **Mono/Flux**는 데이터를 “약속”으로 다룬다. 체이닝·에러·백프레셔를 연산자로 제어.
- **WebFlux**는 **함수형 라우터/핸들러**와 **WebClient**로 논블로킹 엔드투엔드를 만든다.
- **R2DBC**로 DB까지 비동기화하되, **마이그레이션은 JDBC(Flyway)**가 여전히 현실적.
- **성능**은 “블로킹 금지”에 달려 있다. 타임아웃/재시도/풀/메트릭을 기본 탑재.
- 선택은 **워크로드**가 답: I/O 바운드·팬아웃·스트리밍이면 **WebFlux**, 그렇지 않으면 **MVC**.
