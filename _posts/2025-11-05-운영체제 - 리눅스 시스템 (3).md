---
layout: post
title: 운영체제 - 리눅스 시스템 (1)
date: 2025-11-05 16:25:23 +0900
category: 운영체제
---
# Chapter 20 — The Linux System (3)

## 20.9 Interprocess Communication (IPC)

리눅스는 **프로세스 간 통신**을 위해 매우 다양한 원시(primitive)를 제공한다. 선택 기준은 **데이터 크기/지연/복잡도/신뢰성/보안/이식성**이다.

### 20.9.1 IPC 지도 한눈에 보기

| 분류 | 대표 기능 | 장점 | 주의점/용도 |
|---|---|---|---|
| 파일 디스크립터 스트림 | **파이프**, **FIFO** | 매우 단순, 부모-자식에 적합 | 동일 호스트, 바이너리 프레이밍 필요 |
| 공유 메모리 | **POSIX shm**/SysV shm, **memfd** | 초저지연/고대역, 복사 없음 | 동기화(락/세마포어) 필수 |
| 메일박스/큐 | **POSIX mqueue**, SysV msg | 메시지 경계 유지 | 커널 리소스 한정, 튜닝 필요 |
| 소켓 | **Unix 도메인**, **TCP/UDP** | 범용/표준, fd 전달(SCM_RIGHTS) | 프레이밍/리트라이 설계 |
| 동기화 fd | **eventfd**, **timerfd**, **signalfd** | epoll과 자연 통합 | 커널 버전/플래그 이해 필요 |
| 대기/다중화 | **select/poll/epoll**, **io_uring** | 많은 fd를 효율 처리 | 에지/레벨 트리거 차이 주의 |
| 기타 | **pidfd**, **fanotify/inotify** | 프로세스/FS 이벤트 제어 | 커널 버전 의존 |

---

### 20.9.2 파이프/익명 파이프: 부모-자식의 기본기

```c
// pipe_demo.c — 부모가 자식에 텍스트 보내기(익명 파이프)
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <sys/wait.h>

int main(void){
    int p[2]; pipe(p);           // p[1]로 쓰고 p[0]으로 읽는다
    pid_t pid=fork();
    if(pid==0){ // child: read
        close(p[1]);
        char buf[128]={0}; read(p[0], buf, sizeof(buf)-1);
        printf("child got: %s\n", buf);
    }else{
        close(p[0]);
        const char* msg="hello via pipe\n";
        write(p[1], msg, strlen(msg));
        close(p[1]); wait(NULL);
    }
}
```

- 익명 파이프는 **부모-자식** 관계에서 가장 간단. 서로 다른 프로세스 사이에 파일 디스크립터를 공유해야 한다면 **Unix 도메인 소켓 + fd 전달**을 고려.

---

### 20.9.3 FIFO(네임드 파이프): 서로 무관한 프로세스 간

```bash
mkfifo /tmp/myfifo
# 터미널 A
cat /tmp/myfifo
# 터미널 B
printf "hello fifo\n" > /tmp/myfifo
```

- 파이프와 동일한 스트림 성질. **경계가 없는 바이트 스트림**이므로, 애플리케이션 레벨에서 길이-프리픽스 등 **프레이밍**을 설계해야 한다.

---

### 20.9.4 Unix 도메인 소켓 + fd 전달(SCM_RIGHTS)

- **장점**: 동일 호스트에서 **파일 디스크립터를 다른 프로세스에 넘김** (예: 프록시가 listen FD를 워커에 전달).
- **유스케이스**: 프리포킹 서버, 최소 권한 분리(권한 가진 로더가 FD만 전달).

```c
// uds_passfd.c — SO_PASSCRED/SCM_RIGHTS로 FD 전달(간단화)
#define _GNU_SOURCE
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <fcntl.h>

int send_fd(int sock, int fd){
    struct msghdr msg={0}; char buf[CMSG_SPACE(sizeof(fd))];
    struct iovec io = { .iov_base="F", .iov_len=1 };
    msg.msg_iov = &io; msg.msg_iovlen=1;
    msg.msg_control = buf; msg.msg_controllen = sizeof(buf);
    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET; cmsg->cmsg_type = SCM_RIGHTS; cmsg->cmsg_len = CMSG_LEN(sizeof(fd));
    memcpy(CMSG_DATA(cmsg), &fd, sizeof(fd));
    return sendmsg(sock, &msg, 0);
}

int recv_fd(int sock){
    struct msghdr msg={0}; char m[1]; struct iovec io={.iov_base=m,.iov_len=1};
    char buf[CMSG_SPACE(sizeof(int))]; msg.msg_iov=&io; msg.msg_iovlen=1;
    msg.msg_control=buf; msg.msg_controllen=sizeof(buf);
    recvmsg(sock,&msg,0);
    struct cmsghdr* cmsg=CMSG_FIRSTHDR(&msg);
    int fd; memcpy(&fd,CMSG_DATA(cmsg),sizeof(fd)); return fd;
}

int main(){
    int sv[2]; socketpair(AF_UNIX, SOCK_DGRAM, 0, sv);
    if(fork()==0){ // child: receiver
        close(sv[0]);
        int fd = recv_fd(sv[1]);
        dprintf(fd, "written by child via received FD\n");
        close(fd);
    }else{
        close(sv[1]);
        int fd=open("shared.txt", O_CREAT|O_WRONLY|O_TRUNC, 0644);
        send_fd(sv[0], fd); close(fd); wait(NULL);
    }
}
```

---

### 20.9.5 POSIX 공유 메모리 + 세마포어: 고속 링버퍼

> **개요**: `/dev/shm` 상의 POSIX shm + `sem_open()` 으로 **lock-free에 가까운** 생산자/소비자 구조를 구현.

```c
// shm_ring.c — 단일 생산자/소비자 링버퍼(간단화)
#define _GNU_SOURCE
#include <fcntl.h>
#include <sys/mman.h>
#include <semaphore.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdatomic.h>

#define N 1024
typedef struct { atomic_uint head, tail; char buf[N][64]; } ring;

int main(int argc, char**argv){
    int creator = (argc>1 && strcmp(argv[1],"create")==0);
    int fd = shm_open("/myring", O_CREAT|O_RDWR, 0666);
    ftruncate(fd, sizeof(ring));
    ring* r = mmap(NULL,sizeof(ring),PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
    sem_t* sem_items = sem_open("/sem_items", O_CREAT, 0666, 0);
    sem_t* sem_slots = sem_open("/sem_slots", O_CREAT, 0666, N);
    if(creator){ r->head=0; r->tail=0; }

    if(creator){ // producer
        for(int i=0;i<10;i++){
            sem_wait(sem_slots);
            unsigned t = atomic_fetch_add(&r->head,1)%N;
            snprintf(r->buf[t], 64, "msg-%d", i);
            sem_post(sem_items);
        }
    }else{ // consumer
        for(int i=0;i<10;i++){
            sem_wait(sem_items);
            unsigned t = atomic_fetch_add(&r->tail,1)%N;
            printf("got: %s\n", r->buf[t]);
            sem_post(sem_slots);
        }
    }
}
```

- **성능**: 메시지 경계 보장, 복사 1회(생산자가 쓰고 소비자가 읽음). 다중 생산자/소비자는 원자 연산으로 조정하거나 **per-producer 큐**로 스케일.

---

### 20.9.6 POSIX 메시지 큐(mqueue)

```c
// mqueue_demo.c — mq_open/mq_send/mq_receive
#include <mqueue.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
int main(int argc, char**argv){
    struct mq_attr attr = {.mq_maxmsg=10, .mq_msgsize=64};
    mqd_t q = mq_open("/demoq", O_CREAT|O_RDWR, 0644, &attr);
    if(argc>1){ mq_send(q, argv[1], strlen(argv[1])+1, 0); }
    else{ char buf[64]; unsigned prio; mq_receive(q, buf, sizeof(buf), &prio); printf("rx: %s\n", buf); }
}
```

- 파일 시스템 **`/dev/mqueue`** 에 나타난다. **ulimit/커널 설정**(최대 메시지/크기)에 영향받음.

---

### 20.9.7 eventfd/signalfd/timerfd + epoll 결합

{% raw %}
```c
// epoll_mix.c — eventfd와 timerfd를 한 epoll에서 처리
#include <sys/epoll.h>
#include <sys/timerfd.h>
#include <sys/eventfd.h>
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>

int main(){
    int e=epoll_create1(0);
    int t=timerfd_create(CLOCK_MONOTONIC,0);
    struct itimerspec its={{1,0},{1,0}}; timerfd_settime(t,0,&its,NULL);
    int ev=eventfd(0,0);

    struct epoll_event x={.events=EPOLLIN,.data.fd=t}; epoll_ctl(e,EPOLL_CTL_ADD,t,&x);
    x=(struct epoll_event){.events=EPOLLIN,.data.fd=ev}; epoll_ctl(e,EPOLL_CTL_ADD,ev,&x);

    if(fork()==0){ uint64_t one=1; for(int i=0;i<3;i++){ write(ev,&one,8); sleep(2);} return 0; }

    for(int i=0;i<5;i++){
        struct epoll_event out[4]; int n=epoll_wait(e,out,4,-1);
        for(int j=0;j<n;j++){
            if(out[j].data.fd==t){ uint64_t ex; read(t,&ex,8); puts("TIMER"); }
            else{ uint64_t v; read(ev,&v,8); printf("EVENTFD=%lu\n", v); }
        }
    }
}
```
{% endraw %}

- **패턴**: 다양한 이벤트 소스(타이머/신호/사용자 이벤트/소켓)를 **epoll 단일 루프**에 통합 → CPU 캐시 친화, 컨텍스트 스위치 감소.

---

### 20.9.8 Netlink/udev와 커널 이벤트

- **Netlink**: 커널↔유저 공간 구성(라우팅, ip rule, link 상태 등).  
- `ip`(iproute2)는 내부적으로 **netlink** 사용. Python이라면 `pyroute2` 같은 라이브러리로 접근.

---

### 20.9.9 설계 체크리스트

1) **스트림/메시지 경계** 요구 여부(스트림=소켓/파이프, 경계=큐/프레이밍).  
2) **성능**: 대역폭↑ → 공유메모리/zero-copy, 지연↓ → eventfd/epoll.  
3) **에러 모델**: 재시도/멱등/백오프, 부분쓰기/부분읽기, 신호 안전.  
4) **보안**: Unix dgram + **SO_PEERCRED**로 peer 인증, fd 전달 최소화.  
5) **관측**: `strace`, `perf`, eBPF로 syscall/큐 길이 추적.

---

## 20.10 Network Structure (Linux)

리눅스 네트워크 스택은 **소켓 API ↔ 프로토콜(TCP/UDP/QUIC/RAW) ↔ IP ↔ 링크(L2)** 레이어로 구성되며, **네임스페이스/브리지/라우팅/방화벽(nftables)** 로 **가상 네트워크**를 구성한다. **XDP/eBPF**, **RSS/TSO/GSO/GRO** 같은 오프로딩으로 성능을 최적화한다.

### 20.10.1 핵심 구성요소

- **네트워크 네임스페이스**: 네트워크 스택 격리(인터페이스, 라우팅, iptables 모두 별개).  
- **veth pair**: 가상 이더넷 케이블(한쪽 패킷이 다른쪽으로).  
- **bridge**: L2 스위치 역할, 컨테이너를 같은 브리지에 붙이면 같은 L2 세그먼트.  
- **tun/tap**: 사용자 공간 ↔ 커널 프레임/패킷 송수신.  
- **VRF/VLAN/VXLAN**: 라우팅 테이블 격리, L2 분할, L2-over-L3 오버레이.  
- **nftables/conntrack**: 필터링/NAT, 연결 추적.  
- **tc(qdisc)**: QoS/트래픽 제어(CAKE/FQ, HTB).  
- **RSS/RPS/RFS**: NIC/커널 수신 분배, 멀티큐.  
- **XDP/AF_XDP**: 매우 저지연 패킷 처리(커널 우회 경로).

---

### 20.10.2 네임스페이스 + 브리지 빠르게 만들기

```bash
# 브리지 생성
sudo ip link add br0 type bridge
sudo ip addr add 10.10.0.1/24 dev br0
sudo ip link set br0 up

# 네임스페이스 둘 생성
sudo ip netns add ns1
sudo ip netns add ns2

# veth 쌍 두 개, 각각 한쪽을 ns로 옮기고 다른쪽은 br0에 붙임
sudo ip link add veth1 type veth peer name veth1p
sudo ip link set veth1 netns ns1
sudo ip link set veth1p master br0

sudo ip link add veth2 type veth peer name veth2p
sudo ip link set veth2 netns ns2
sudo ip link set veth2p master br0

sudo ip link set veth1p up
sudo ip link set veth2p up

# ns 내부 인터페이스 셋업
sudo ip -n ns1 addr add 10.10.0.11/24 dev veth1
sudo ip -n ns1 link set veth1 up
sudo ip -n ns2 addr add 10.10.0.12/24 dev veth2
sudo ip -n ns2 link set veth2 up

# 통신 시험
sudo ip netns exec ns1 ping -c1 10.10.0.12
```

---

### 20.10.3 간단 TCP 에코 서버 — epoll(에지 트리거)

```c
// tcp_epoll_echo.c — 단일 스레드 epoll ET 에코 서버
#define _GNU_SOURCE
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int set_nb(int fd){ int f=fcntl(fd,F_GETFL,0); return fcntl(fd,F_SETFL,f|O_NONBLOCK); }

int main(){
    int s=socket(AF_INET,SOCK_STREAM,0);
    int opt=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(opt));
    struct sockaddr_in a={.sin_family=AF_INET,.sin_port=htons(9000),.sin_addr={0}};
    bind(s,(void*)&a,sizeof(a)); listen(s,512); set_nb(s);

    int ep=epoll_create1(0);
    struct epoll_event ev={.events=EPOLLIN,.data.fd=s}; epoll_ctl(ep,EPOLL_CTL_ADD,s,&ev);

    char buf[1<<16];
    for(;;){
        struct epoll_event out[128];
        int n=epoll_wait(ep,out,128,-1);
        for(int i=0;i<n;i++){
            int fd=out[i].data.fd;
            if(fd==s){
                for(;;){ // accept many
                    int c=accept4(s,NULL,NULL,SOCK_NONBLOCK);
                    if(c<0) break;
                    struct epoll_event evc={.events=EPOLLIN|EPOLLET,.data.fd=c};
                    epoll_ctl(ep,EPOLL_CTL_ADD,c,&evc);
                }
            } else {
                for(;;){
                    ssize_t r=read(fd,buf,sizeof(buf));
                    if(r>0) write(fd,buf,r);
                    else break;
                }
            }
        }
    }
}
```

- **팁**: 에지 트리거(EPOLLET)는 **읽을 수 없을 때까지 read 루프**를 돌려야 **이벤트 손실**이 없다.

---

### 20.10.4 UDP 멀티캐스트 가입

```c
// udp_mc.c — 239.1.1.1:5000 멀티캐스트 listen
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <stdio.h>
int main(){
    int s=socket(AF_INET,SOCK_DGRAM,0);
    struct sockaddr_in a={.sin_family=AF_INET,.sin_port=htons(5000),.sin_addr={INADDR_ANY}};
    bind(s,(void*)&a,sizeof(a));
    struct ip_mreqn m={.imr_multiaddr.s_addr=inet_addr("239.1.1.1"), .imr_address.s_addr=htonl(INADDR_ANY), .imr_ifindex=0};
    setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, &m, sizeof(m));
    char b[1500]; for(;;){ int n=recv(s,b,sizeof(b),0); write(1,b,n); }
}
```

---

### 20.10.5 nftables로 최소 방화벽/NAT

```bash
sudo nft add table inet filter
sudo nft add chain inet filter input '{ type filter hook input priority 0; policy drop; }'
sudo nft add rule  inet filter input ct state established,related accept
sudo nft add rule  inet filter input iif lo accept
sudo nft add rule  inet filter input tcp dport {22,80,443} accept
sudo nft add rule  inet filter input counter drop

# SNAT/MASQUERADE 예(라우터 역할)
sudo nft add table ip nat
sudo nft add chain ip nat postrouting '{ type nat hook postrouting priority 100; }'
sudo nft add rule  ip nat postrouting oifname "eth0" masquerade
```

---

### 20.10.6 NIC/큐/오프로딩 요점

- **RSS(하드웨어 수신 분산)**: CPU코어별 큐로 분배.  
- **GRO/TSO/GSO/LRO**: 패킷 병합/분할로 per-packet 오버헤드 감소.  
- **irq affinity**: 인터럽트를 코어에 분산.  
- **XDP/AF_XDP**: 사용자 공간 초저지연 패킷 처리(전용 라이브러리 필요).

---

### 20.10.7 지연/큐잉 직관

- **리틀의 법칙**: $$L = \lambda \cdot W$$ (평균 시스템내 개수 = 도착률 × 체류시간)  
- 에지/서버 큐가 포화되면 **p99 지연이 급증** → 큐 길이/traffic shaping으로 tail 줄이기.

---

## 20.11 Security (Linux)

리눅스 보안은 **권한 모델(DAC/Capabilities)**, **MAC(SELinux/AppArmor)**, **격리(Namespaces/cgroups)**, **시스템콜 필터(seccomp)**, **방화벽/conntrack**, **감사(audit)** 로 층층이 구성된다.

### 20.11.1 기본: DAC와 권한/소유/모드/umask

- **DAC(Discretionary Access Control)**: 소유자(owner)가 권한을 제어(Unix 퍼미션 비트, POSIX ACL).  
- **umask**: 새 파일의 기본 권한 마스크.  
- **setuid/setgid**: 실행 파일이 소유자/그룹 권한으로 실행(주의!).

```bash
# ACL: setfacl/getfacl
setfacl -m u:alice:rwx /srv/data
getfacl /srv/data
```

---

### 20.11.2 Capabilities: root 권한의 세분화

- 예: **CAP_NET_BIND_SERVICE** 로 1024 미만 포트 바인드 허용.

```bash
# 바이너리에 특정 capability 부여
sudo setcap 'cap_net_bind_service=+ep' ./web
getcap ./web
```

- **원칙**: “필요 최소 권한(least privilege)”를 **바이너리/서비스 단위**로 적용.

---

### 20.11.3 Namespaces + cgroups: 격리와 제한

- **UTS/IPC/NET/MNT/PID/USER/CGROUP** 네임스페이스.  
- **rootless**: userns로 비특권 컨테이너.

```bash
# 간단 네임스페이스 셸
sudo unshare -r -n -p -m --mount-proc bash
# (새 netns, PID ns, 마운트 ns에서 root로 보이지만 진짜 root는 아님)
```

- **cgroups v2**: CPU/MEM/IO/프로세스 수 제한.

---

### 20.11.4 LSM(SELinux/AppArmor)

- **SELinux**: 라벨 기반 MAC, 정책이 허용하지 않으면 DAC가 허용하더라도 **거부**.  
- **AppArmor**: 경로 기반 프로파일(쉬운 도입).  
- **상태 확인**
```bash
sestatus                # SELinux
aa-status               # AppArmor
```

---

### 20.11.5 seccomp-bpf: 시스템콜 화이트리스트

> **목표**: 프로세스가 호출 가능한 시스템콜을 최소화(공격면 축소).

#### libseccomp 사용 예
```c
// scmp_min.c — read/write/_exit 만 허용
#include <seccomp.h>
#include <unistd.h>
#include <stdio.h>
int main(){
    scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL);  // 기본: kill
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);
    seccomp_load(ctx);
    write(1,"hello\n",6);  // OK
    getpid();              // 금지 → SIGSYS 로 종료
}
```

- 배포 시 **필요 syscall만 단계적으로 열기**. 동적 로더/쓰레드/네트워크 등은 추가 허용 필요.

---

### 20.11.6 파일시스템/저장암호화

- **dm-crypt/LUKS**: 블록 장치 전면 암호화.  
- **fscrypt**(ext4/f2fs): **파일/디렉토리 단위** 암호화(모바일/사용자 홈).  
- **키 관리**: **커널 keyring**, Vault/KMS 와 연동.

```bash
# LUKS 장치 초기화(파괴적 작업! 데모용 명령)
sudo cryptsetup luksFormat /dev/nvme1n1
sudo cryptsetup open /dev/nvme1n1 secure_disk
mkfs.ext4 /dev/mapper/secure_disk
```

---

### 20.11.7 PAM/Audit/로그 무결성

- **PAM**: 모듈식 인증 체인(비밀번호, 2FA, 잠금 정책).  
- **auditd**: 보안 이벤트 감사, LSM 결합.

```bash
# audit — /etc/shadow 접근을 감사
sudo auditctl -w /etc/shadow -p rwxa -k shadow_watch
sudo ausearch -k shadow_watch
```

---

### 20.11.8 방화벽/conntrack/포워딩 최소화

- **기본 차단 + 필요한 포트만 허용**.  
- **stateful**(established/related) 우선 허용.  
- 관리 단순화를 위해 **nftables** 로 일원화.

---

### 20.11.9 안전한 서비스 작성 실무 체크리스트

1) **권한 분리**: `setcap`/user drop/Chroot 또는 `User=/ProtectSystem=`(systemd).  
2) **fd hygiene**: `O_CLOEXEC` 기본, 비밀 fd 상속 금지.  
3) **seccomp/lsm**: 최소 syscall + AppArmor/SELinux 프로파일.  
4) **네트워크**: mTLS(서비스-서비스), 최소 오픈 포트, DoS 방지(accept 큐/백프레셔).  
5) **입출력**: 임시파일은 `O_TMPFILE` 또는 `mkstemp` 사용(경로 추측 공격 차단).  
6) **로그/비밀**: 토큰/키는 로그에 남지 않도록 필터링, `mlock` 해제 잔존 방지.  
7) **업데이트**: 정기 패치, 재현 가능한 빌드/서명 검증.  
8) **관측**: 보안 이벤트 대시보드(p99 실패율, 거부 로그, SELinux deny).

---

### 20.11.10 예제 — 비특권 포트 바인딩 + seccomp + chroot

```bash
# 1) 바이너리에 cap_net_bind_service 부여
sudo setcap 'cap_net_bind_service=+ep' ./tiny
```

```c
// tiny.c — 80/TCP 바인드(비root), chroot + seccomp(허용 최소)
#define _GNU_SOURCE
#include <seccomp.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int harden(){
    chroot("/var/empty"); chdir("/");
    scmp_filter_ctx ctx=seccomp_init(SCMP_ACT_KILL);
    int ok[]={SCMP_SYS(read),SCMP_SYS(write),SCMP_SYS(exit),SCMP_SYS(exit_group),
              SCMP_SYS(accept4),SCMP_SYS(epoll_wait),SCMP_SYS(epoll_ctl),SCMP_SYS(epoll_create1),
              SCMP_SYS(close),SCMP_SYS(getsockopt),SCMP_SYS(setsockopt),SCMP_SYS(recvfrom),
              SCMP_SYS(sendto),SCMP_SYS(brk),SCMP_SYS(mmap),SCMP_SYS(munmap)};
    for(size_t i=0;i<sizeof(ok)/sizeof(ok[0]);i++) seccomp_rule_add(ctx,SCMP_ACT_ALLOW,ok[i],0);
    return seccomp_load(ctx);
}

int main(){
    int s=socket(AF_INET,SOCK_STREAM,0);
    int opt=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(opt));
    struct sockaddr_in a={.sin_family=AF_INET,.sin_port=htons(80),.sin_addr={0}};
    bind(s,(void*)&a,sizeof(a)); listen(s,256);
    harden(); // chroot + seccomp 적용
    for(;;){
        int c=accept4(s,NULL,NULL,SOCK_CLOEXEC);
        dprintf(c,"HTTP/1.1 200 OK\r\nContent-Length:2\r\n\r\nOK");
        close(c);
    }
}
```

> **요점**: root 없이 80 포트를 바인드(capabilities), **chroot로 FS 축소**, **seccomp로 syscall 최소화** — “필요 기능만 허용” 원칙.

---

## 마무리 요약

- **20.9 IPC**: 파이프/FIFO로 시작해 Unix 도메인 소켓(fd 전달), POSIX shm+세마포어(고속), mqueue(메시지 경계), eventfd/timerfd/signalfd+epoll(단일 이벤트 루프)까지. 선택은 **경계/지연/대역폭/개발 난이도**의 트레이드오프다.  
- **20.10 Network Structure**: 네임스페이스/브리지/veth로 가상 네트워크를 구성하고, epoll 서버·멀티캐스트·nftables로 실전 토폴로지를 만든다. NIC 오프로딩/RSS와 큐잉 모델을 이해하면 **p99 지연**을 줄일 수 있다.  
- **20.11 Security**: DAC→Capabilities→Namespaces/cgroups→LSM→seccomp로 **다층 방어**. 키/암호화/감사/방화벽을 연계하고, 서비스는 **least privilege + O_CLOEXEC + seccomp + 프로파일**로 경량 하드닝한다.