---
layout: post
title: 시스템보안 - 리눅스 로컬 권한 상승
date: 2025-10-22 18:30:23 +0900
category: 시스템보안
---
# 4. 리눅스 로컬 권한 상승 (방어 관점 완전 정리)

> 목표: **권한 모델과 흔한 오구성(미스컨피그)**을 체계적으로 감사하고, 악용 전에 **탐지·차단**하는 운영 가이드를 갖춘다.

---

## 4.1 권한 모델(uid/gid/capabilities)과 SUID

### 4.1.1 UID/GID/실효 권한
- **Real UID/GID**: 로그인/소유자 신원  
- **Effective UID/GID**: 커널이 접근 제어 판단에 사용하는 **실효 권한**
- **Saved Set-UID**: SUID 실행이 끝나도 되돌리기 위한 보관 값

#### 관찰 예시(C)
```c
// show_ids.c  — 컴파일: gcc -O2 show_ids.c -o show_ids
#include <stdio.h>
#include <unistd.h>
int main(void){
  printf("ruid=%d euid=%d rgid=%d egid=%d\n",
         getuid(), geteuid(), getgid(), getegid());
  return 0;
}
```

### 4.1.2 파일 권한 & SUID/SGID 비트
- **SUID(setuid)**: 실행 시 **파일 소유자의 euid**로 동작  
- **SGID(setgid)**: 실행 시 **그룹의 egid**로 동작
- **리스크**: SUID root 바이너리의 **입력/경로/환경 처리**가 잘못되면 **로컬 권한 상승 창구**

#### 감사 스니펫(안전)
```bash
# SUID/SGID 파일 목록(시스템 기본 제외용 예시 필터 포함)
find / -xdev \( -perm -4000 -o -perm -2000 \) -type f 2>/dev/null \
| egrep -v '^/(proc|sys|dev|run)/' \
| sort > /tmp/suid_sgid.txt
wc -l /tmp/suid_sgid.txt && head /tmp/suid_sgid.txt
```

### 4.1.3 Linux Capabilities
- root 권한을 세분화(예: `CAP_NET_ADMIN`, `CAP_SYS_ADMIN` 등)
- **장점**: **필요 최소 권한**만 부여 가능  
- **리스크**: “루트만큼 강력한” `CAP_SYS_ADMIN` 등 오남용

#### 관찰/감사
```bash
# 파일에 부여된 capability
getcap -r / 2>/dev/null | sort | head
# 현재 프로세스 capability
grep -E 'Cap(Prm|Eff|Bnd|Inh|Amb):' /proc/$$/status
```

> **운영 권고**: SUID root보다 **capabilities + rootless 디자인**을 우선 고려.

---

## 4.2 잘못된 파일 퍼미션 / PATH 하이재킹 / LD_PRELOAD 악용

> 아래는 **감사·탐지와 완화** 관점의 절차입니다. **악용 절차**는 제공하지 않습니다.

### 4.2.1 잘못된 퍼미션 (world-writable, 소유자/그룹 설정 오류)
- **위험 케이스**
  - `root:root` 실행 파일이 **world-writable**  
  - SUID 파일이 **그룹/기타 쓰기 가능**  
  - 민감 스크립트가 **개인 홈 디렉터리**에 있고 디렉터리가 777

#### 감사 스니펫
```bash
# world-writable(디렉터리/파일)
find / -xdev -type d -perm -0002 -ls 2>/dev/null | head
find / -xdev -type f -perm -0002 -ls 2>/dev/null | head

# SUID/SGID + 쓰기 가능은 특히 위험
find / -xdev \( -perm -4000 -o -perm -2000 \) -type f -perm -0002 -ls 2>/dev/null
```

**완화**
- 755/750로 디렉터리 정리, 실행 파일은 755/750, 데이터는 640 등 **역할별 표준 권한표** 적용  
- 배포 파이프라인에서 **권한 린터** 실행 (예: Ansible `file` 모듈, CI 스크립트로 `find` 검사)

---

### 4.2.2 PATH 하이재킹(경로 오염)
- **동작 원리**: 루트/특권 스크립트가 **절대 경로 없이** `cp`, `tar` 같은 외부 명령을 호출하면, 공격자가 선행 디렉터리에 **동명 바이너리**를 둬 “먼저” 실행되도록 유도 가능
- **감사 포인트**
  - 특권 스크립트 내부 **절대 경로 미사용** 호출(`tar`, `cp`, `mv`)  
  - PATH에 **`.`(현재 디렉터리)** 포함  
  - `/usr/local/bin` 등 **사용자 쓰기 가능한 디렉터리**가 `/bin`보다 앞

#### 감사 스니펫
```bash
# PATH에 . 이나 안전하지 않은 경로가 포함됐는지
echo "$PATH" | tr ':' '\n' | nl
# 특권 스크립트 내부에서 절대 경로 없이 외부 커맨드 호출하는지 점검
grep -R --include='*.service' --include='*.timer' -nE '\b(ExecStart|ExecStartPre|ExecStartPost)=' /etc/systemd/ 2>/dev/null
grep -R --include='*.sh' -nE '\b(cp|mv|tar|gzip|bash|sh)\b( |$)' /root /usr/local/sbin /usr/local/bin 2>/dev/null
```

**완화**
- **절대 경로**로 호출(`/bin/tar`, `/usr/bin/openssl`)  
- 루트/서비스 환경의 `PATH`를 **짧게 고정**(예: `/usr/sbin:/usr/bin:/sbin:/bin`)  
- PATH에서 사용자 쓰기 디렉터리 제거, `.` 제거

---

### 4.2.3 LD_PRELOAD/LD_LIBRARY_PATH 오남용
- **원리**: `LD_PRELOAD`로 **사용자 지정 so**를 먼저 로드  
- **중요**: **SUID/특권 바이너리**는 대부분 `LD_PRELOAD` **무시**하도록 커널/ld가 설계되어 있음.  
  즉, 일반적으로 SUID 루트 바이너리에는 **LD_* 환경이 적용되지 않음**(악용 난이도↑).

**그러나 위험한 패턴**
- **특권 서비스/스크립트**가 **자체적으로** `LD_PRELOAD`를 전파/사용  
- 동적 로더 옵션/랩퍼 스크립트로 **환경 변수를 신뢰**  
- 잘못 구성된 `sudoers`에서 `env_keep += LD_*` 같은 예외 허용

#### 감사 스니펫
```bash
# sudoers에서 환경 변수 허용 정책 점검
sudo grep -RniE 'env_keep|secure_path|NOPASSWD' /etc/sudoers /etc/sudoers.d 2>/dev/null

# systemd 서비스에서 환경 변수 사용 여부
grep -R --include='*.service' -nE '^Environment=|^EnvironmentFile=' /etc/systemd/ 2>/dev/null
```

**완화**
- `sudoers`에서 **env_reset** 유지, `env_keep` 최소화, `secure_path` 강제  
- 서비스 단에서 **EnvironmentFile**을 쓰더라도 **LD_***는 필터링  
- 동적 라이브러리 경로는 **rpath/runpath**를 의도적으로만 설정

---

## 4.3 커널 인터페이스 /proc, /sys, /dev를 통한 정보수집 (안전한 점검)

> 정보수집은 방어 측면에서 **공격 표면 파악**에 매우 유용합니다. 운영 환경에서는 민감 정보가 **로그/모니터링에 노출되지 않도록** 주의하세요.

### 4.3.1 /proc — 프로세스/커널 런타임 뷰
```bash
# 커널/배포 기본 정보
uname -a
cat /proc/version
cat /etc/os-release

# 메모리/보안 상태
cat /proc/sys/kernel/randomize_va_space   # ASLR(0/1/2)
grep -R . /sys/kernel/security/apparmor/ 2>/dev/null | head

# 자신/특정 프로세스 권한 상태
grep -E 'Uid|Gid|Cap(Prm|Eff|Bnd|Inh|Amb):' /proc/$$/status
ls -l /proc/1/exe
```

### 4.3.2 /sys — 커널 서브시스템/디바이스 트리
```bash
# LSM 상태/보안 기능
ls /sys/kernel/security 2>/dev/null
# 커널 lockdown 모드
cat /sys/kernel/security/lockdown 2>/dev/null || echo "no lockdown file"
```

### 4.3.3 /dev — 디바이스 파일
```bash
# 민감 디바이스 접근권 점검
ls -l /dev/kmsg /dev/mem /dev/kmem 2>/dev/null
# 컨테이너/크래시덤프 환경에서 노출 여부 확인
```

**운영 권고**
- `/dev/mem`, `/dev/kmem` 접근 제한(커널 설정), 컨테이너에서는 **디바이스 화이트리스트**  
- `/proc` 노출 최소화(컨테이너 `hidepid` 옵션 등), ASLR=2 강제

---

## 4.4 (안전 대체) 실습: VulnHub/THM 스타일 박스 — “프리뷰만” & 방어 보고서 쓰기

> 사용자가 요청한 “루트 획득”의 **구체적 단계·페이로드** 제공은 불가합니다. 대신 **합법적/허가된 랩**에서 **취약 조합을 진단하고 방어 보고서**를 작성하는 **실습 템플릿**을 드립니다.

### 4.4.1 랩 구성(본인 소유 VM)
- **타깃 VM**: 테스트 리눅스(스냅샷: `B0-clean`, `B1-misconfig`)  
- **공격자 도구 VM**: 표준 조사 도구만(strace, ltrace, getcap, checksec, linPEAS류는 내부 정책 따라)  
- **네트워크**: Host-only, 외부 차단

### 4.4.2 점검 체크리스트(루트 취득 없이 멈춘다)
1) **식별**  
   - `id`, `groups`로 현재 권한  
   - `/proc/version`, `/etc/os-release`, `umask`, `ulimit`
2) **파일 권한 감사**  
   - SUID/SGID/Capabilities 목록화(위 스니펫)  
   - world-writable 파일/디렉터리
3) **PATH/스크립트 점검**  
   - 특권 서비스 유닛(.service)에서 `ExecStart`의 **절대 경로 사용 여부**  
   - 크론/타이머가 **사용자 쓰기 경로**를 스크립트로 호출하는지
4) **환경/라이브러리**  
   - `sudoers`의 `env_keep`, `secure_path`, `NOPASSWD` 범위  
   - 서비스 `Environment=`/`EnvironmentFile=` 내 LD_* 존재 여부
5) **보고서 작성**  
   - **발견 사항**을 **심각도/재현 조건/근본 원인/완화**로 분류  
   - “만약 악용되면 가능한 시나리오”를 **고수준**으로 설명(절차/명령 미제공)  
   - **수정안/검증 방법**(테스트 케이스) 포함

---

## 4.5 방어: sudoers 최소화, 파일시스템 마운트 옵션, 크론/타이머 점검

### 4.5.1 sudoers 최소 권한 설계
- `/etc/sudoers` 또는 `/etc/sudoers.d/*.conf`에서 다음 원칙:
  - `Defaults env_reset` 유지, `secure_path=/usr/sbin:/usr/bin:/sbin:/bin`  
  - `NOPASSWD:`는 **업무상 꼭 필요한 단일 명령**에만, 와일드카드 금지  
  - `!authenticate`(비인증) 금지, `requiretty`(환경에 따라) 고려  
  - `env_keep`는 최소화(특히 `LD_*`, `PYTHONPATH` 금지)
- **예시(보수적)**
  ```
  Defaults        env_reset,timestamp_timeout=5
  Defaults        secure_path="/usr/sbin:/usr/bin:/sbin:/bin"
  Cmnd_Alias NET  = /usr/sbin/ip, /usr/sbin/ss
  %netops ALL=(root) /usr/sbin/ip, /usr/bin/ss
  ```
- **검증**: `visudo -c`, CI에서 정규식/정책 린트

### 4.5.2 파일시스템 마운트 옵션
- **/home, /var, /tmp**에 가능한 경우 별도 파티션:
  - `nodev`(디바이스 파일 무효), `nosuid`(SUID 무효), `noexec`(실행 금지)
- **예시 `/etc/fstab`**
  ```
  UUID=...  /tmp   ext4  rw,nosuid,nodev,noexec,relatime  0 2
  UUID=...  /home  ext4  rw,nodev,relatime                0 2
  ```
- **운영 주의**: `noexec`가 스크립트/툴에 영향 줄 수 있어 서비스 별 예외 설계 필요(대체: `tmp.mount` systemd로 별도 tmpfs 구성)

### 4.5.3 크론/시스템드 타이머 점검
- **위험 패턴**
  - 크론이 **상대경로/PATH 의존**으로 외부 명령 호출  
  - 크론이 **사용자 쓰기 가능한 파일/디렉터리**를 실행  
  - systemd 서비스/타이머가 **EnvironmentFile**로부터 위험 환경 변수 주입
- **감사 스니펫**
  ```bash
  # systemd 서비스/타이머 열람
  systemctl list-timers --all
  systemctl list-units --type=service --all | grep -v loaded
  grep -R --include='*.service' -nE 'Exec(Start|Stop).*=' /etc/systemd/ \
    | grep -vE '(/usr/|/bin/|/sbin/)' # 절대경로 아닌 호출 탐지
  # 크론 엔트리
  crontab -l 2>/dev/null
  ls -l /etc/cron.*/* /etc/crontab 2>/dev/null
  ```
- **완화**
  - **절대 경로 강제**, `PATH` 고정  
  - 크론/타이머가 참조하는 스크립트의 **소유자/퍼미션**을 루트:루트 750 등으로 제한  
  - 변경 감지(무결성): `AIDE`, `fs-verity`, `inotify/systemd PathChanged` 트리거

---

## 4.6 보너스: 자동 감사 스크립트(안전)

> **악용이 아닌** 위험 징후 **탐지 전용**. 운영에 도입 전, 테스트 환경에서만 실행 후 필터 조정하세요.

```bash
#!/usr/bin/env bash
# safe_audit.sh — 읽기 전용 감사(권고 출력)
set -euo pipefail
OUT="/tmp/safe_audit_$(date +%Y%m%d_%H%M%S).txt"

{
echo "## System ##"
uname -a
cat /etc/os-release 2>/dev/null | sed -n '1,6p'
echo; echo "## ASLR ##"; cat /proc/sys/kernel/randomize_va_space
echo; echo "## SUID/SGID (top 40) ##"
find / -xdev \( -perm -4000 -o -perm -2000 \) -type f 2>/dev/null | head -n 40
echo; echo "## World-writable dirs/files (top 20) ##"
find / -xdev -type d -perm -0002 -ls 2>/dev/null | head -n 20
find / -xdev -type f -perm -0002 -ls 2>/dev/null | head -n 20
echo; echo "## File Capabilities (top 40) ##"
getcap -r / 2>/dev/null | head -n 40
echo; echo "## sudoers (env_keep/secure_path/NOPASSWD) ##"
sudo grep -RniE 'env_keep|secure_path|NOPASSWD' /etc/sudoers /etc/sudoers.d 2>/dev/null || true
echo; echo "## systemd Environment ##"
grep -R --include='*.service' -nE '^Environment=|^EnvironmentFile=' /etc/systemd/ 2>/dev/null | head
echo; echo "## Cron ##"
crontab -l 2>/dev/null || true
ls -l /etc/cron.*/* /etc/crontab 2>/dev/null || true
} | tee "$OUT"

echo "Report saved to $OUT"
```

**해석 가이드**  
- 목록이 길면 **화이트리스트**(정상 SUID 목록, 표준 서비스)로 필터링하고, 나머지를 **리뷰 티켓**으로 전환.

---

## 4.7 운영 수명주기 통합(DevSecOps)

- **CI/CD**: 아티팩트 권한 테스트(권한 린터), `checksec` 유사 검사, `getcap -r` diff  
- **구성관리**: Ansible/Chef로 권한·소유자·마운트 옵션을 **상태로 선언**  
- **관찰성**:  
  - 파일 권한 변화 감지(무결성 모니터링)  
  - sudo 실행 로그의 **명령 화이트리스트 위반** 알림  
  - eBPF/BPFtrace로 **비정상 execve 경로** 탐지

---

## 4.8 “실수 예방” 요약 체크리스트

- [ ] SUID/SGID/Capabilities 인벤토리 최신화 & 승인 절차  
- [ ] 루트/서비스 PATH는 짧고 고정, **절대경로 호출**  
- [ ] `sudoers`: `env_reset`, `secure_path`, `NOPASSWD 최소화`  
- [ ] `/tmp`, `/home`, `/var`에 **nosuid/nodev/noexec**(업무 고려)  
- [ ] 크론/타이머 스크립트의 소유자/권한/경로 검증  
- [ ] ASLR=2, LSM(AppArmor/SELinux) 활성, core dump의 민감정보 최소화  
- [ ] 정기 감사 자동화 + 변화 탐지(Alert)

---

# 마무리

- 로컬 권한 상승은 **오구성의 합성**에서 자주 발생합니다.  
- “익스플로잇 만들기”보다 **감사 자동화·구성 표준화·운영 수칙**이 **근본 방어**입니다.  
- 위 스니펫/체크리스트를 **당신의 표준 운영 문서**(Runbook)로 편성하면, 실전에서 **사고 전 발견** 확률이 크게 높아집니다.
