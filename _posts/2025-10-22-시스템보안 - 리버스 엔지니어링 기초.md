---
layout: post
title: 시스템보안 - 리버스 엔지니어링 기초
date: 2025-10-22 15:30:23 +0900
category: 시스템보안
---
# 리버스 엔지니어링 기초 — 포맷·정적/동적 분석·패킹·크랙미 실습

> 목적: PE/ELF/Mach-O **포맷 구조**를 정확히 짚고, **정적/동적 분석** 루틴을 체득한 뒤, 간단한 **패킹/난독화 개념**과 **크랙미(교육용 라이선스 체크)** 분석을 완주한다.
> 원칙: **교육·연구용**. 상용 소프트웨어 불법 크랙/우회는 다루지 않는다. 모든 실습은 **로컬 랩(Host-only, 스냅샷)**에서 진행한다.

---

## 포맷 구조 개요 — PE / ELF / Mach-O

### 공통적인 큰 그림

- **헤더**: 파일의 “지도” (엔트리포인트, 아키텍처, 섹션/세그먼트 위치)
- **코드/데이터**: .text(코드), .rdata/.data(상수/변수)
- **링킹/로딩 정보**: 임포트(외부 함수 표), 재배치/기호표, TLS 콜백 등
- **디버깅·보안 메타**: 심볼, 서명/하드닝 정보(ASLR/PIE, NX 등)

---

### PE(Windows) 핵심

- **DOS 헤더**(MZ) → `e_lfanew` → **NT 헤더**(PE\0\0)
- **File Header**: 머신(AMD64=0x8664), 섹션 수, 타임스탬프
- **Optional Header**: EntryPoint(RVA), ImageBase, 섹션정렬, 데이터 디렉터리(Import/Export/Resource/TLS/Reloc/Debug/CLR …)
- **Section Table**: `.text/.rdata/.data/.pdata/.reloc/...`
- **IAT/ILT**: Import Address/Lookup Table → LoadLibrary/GetProcAddress로 채워짐
- **특이 포인트**:
  - **TLS Callbacks**: `DllMain` 보다 먼저/후에 호출 가능 → 안티분석/초기화 훅 포인트
  - **/GS(스택 카나리)**, **/DYNAMICBASE(ASLR)**, **/NXCOMPAT(NX)** 플래그로 보호 수준 판단

#### PE 관찰(도구 & 스크립트)

```bash
# Detect It Easy(die), CFF Explorer, PE-bear, pefile(python) 등 사용

pip install pefile
python - <<'PY'
import pefile, sys
pe = pefile.PE(sys.argv[1] if len(sys.argv)>1 else r"C:\Windows\System32\notepad.exe")
print(hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint), hex(pe.OPTIONAL_HEADER.ImageBase))
for s in pe.sections[:5]:
    print(s.Name.strip(b'\x00').decode(), hex(s.VirtualAddress), s.Characteristics)
PY
```

---

### ELF(Linux) 핵심

- **ELF Header**: 클래스(32/64), 엔디안, 머신(x86-64=EM_X86_64)
- **Program Header(실행용)**: **PT_LOAD** 세그먼트(런타임 매핑), **PT_DYNAMIC(동적 링크 정보)**, **PT_INTERP(동적 링커 경로)**
- **Section Header(링킹용)**: .text/.data/.bss/.symtab/.strtab/.rel[a].plt/.got 등
- **PLT/GOT**: 지연결합(PLT 스텁 → GOT 엔트리 → 실제 libc 함수)
- **PIE**: 실행 파일 자체가 공유 라이브러리처럼 재배치 가능 → ASLR의 핵심

#### ELF 관찰 기본 루틴

```bash
file ./a.out
readelf -h ./a.out
readelf -l ./a.out      # Program Header(메모리 맵핑)
readelf -S ./a.out      # Section Header
objdump -d ./a.out | sed -n '1,80p'   # 코드 확인
```

---

### Mach-O(macOS) 핵심

- **Mach-O Header**(magic, CPU type, filetype)
- **Load Commands**: **LC_SEGMENT(_64)**(섹션 포함), **LC_MAIN**(엔트리), **LC_LOAD_DYLIB**, **LC_CODE_SIGNATURE**, **LC_FUNCTION_STARTS**
- **dyld**: 동적 로더. `__TEXT/__DATA` 세그먼트, `__LINKEDIT`에 심볼/문자열
- **codesign/entitlements**: 서명/권한(샌드박스) 정보가 리버스/우회에 큰 영향

#### 관찰

```bash
otool -hV ./bin
otool -l  ./bin | sed -n '1,120p'
codesign -dv --verbose=4 ./bin
```

---

## 정적 분석 — 심볼/문자열/CFG/시그니처

### 빠른 1분 점검(룰)

1) **파일 타입**/아키텍처/PIE/ASLR/NX/서명 여부
2) **문자열(strings)**: 메세지·오류·포맷·URL·키워드(“serial”, “license”, “Registered”)
3) **임포트 테이블**: `strcmp/strncmp/memcmp`, `Reg*`, `Crypt*`, `GetTickCount`, `Sleep`(안티디버깅 패턴)
4) **엔트리/WinMain/main** 경로, **TLS 콜백** 존재여부
5) **난독화/패킹 지표**: 비정상 섹션명, 엔트리와 .text 길이 불일치, 섹션 엔트로피↑

#### strings/objdump/ghidra 조합(예)

```bash
strings -a -n 6 sample.bin | grep -i -E "license|serial|key|user|check|error"
objdump -D -Mintel sample.bin | sed -n '1,120p'
# Ghidra: File→Import→Analyze→Functions/Strings/Decompile에서 흐름 태깅

```

---

### 제어흐름 그래프(CFG) & 콜그래프(Callgraph)

- **목적**: 주요 분기(성공/실패), 루프, 체크 포인트, API 호출 지점 식별
- **Ghidra/IDA**: 기본 뷰(리스트→그래프). 조건 분기(je/jne, jz/jnz), 스위치(jmp tbl) 탐색
- **패턴**:
  - 입력 파싱 → 해시/체크섬 → 비교 → OK/NG 메시지
  - 암호화 루틴 앞뒤로 `memset`, `malloc/free`, `memcmp` 등장

---

### 함수 시그니처/패턴 인식

- **FLIRT(IDA), Ghidra Function ID**: 라이브러리 함수 판별
- **핸드메이드 시그니처**: 바이트 시그니처/명령 시퀀스 패턴화
- **C++**: name-mangling 해독, 가상함수 테이블 탐색(가상 호출의 실제 대상 찾기)

---

## 동적 분석 — 브레이크포인트/메모리·레지스터/API 모니터

### gdb/LLDB/WinDbg/x64dbg 공통 루틴

- **BP**: 함수/주소/조건 브레이크 (`break *0x... if rax==0`, `ba e 1 addr` 등)
- **메모리**: `x/16xb addr`, `db/dd/dq`(Windows)
- **레지스터**: `info reg`, `r`
- **스택 프레임**: `bt`, `k`
- **단계 실행**: `si/ni`(gdb), `t/pt`(x64dbg step/step over)

#### (Linux) gdb 예시

```bash
gdb -q ./crackme
(gdb) set disassemble-next-line on
(gdb) break *0x401234          # memcmp 직전 주소
(gdb) run
(gdb) x/s $rdi                 # arg1
(gdb) x/s $rsi                 # arg2
(gdb) ni; info reg rax
```

#### (Windows) x64dbg 예시

- `Ctrl+G`로 EntryPoint 이동 → `Search for | All intermodular calls` → `strcmp/memcmp` 근처 BP.
- `Hardware breakpoint on access`로 **입력 버퍼**가 참조될 때 멈춤.

---

### API 모니터링

- **Windows**: **Process Monitor(ProcMon)**로 `RegOpenKey`, 파일 접근, 네트워크 접근 모니터. **API Monitor**(RaptorLab)로 함수별 인자 캡처.
- **Linux**: `strace -f`, `ltrace`로 시스템콜/라이브러리 호출 확인.

```bash
# Linux

strace -o sys.log -f ./crackme good-serial
ltrace -o lib.log  ./crackme bad-serial
grep -E "open|read|write" sys.log | head
grep -i "strcmp\|memcmp"  lib.log | head
```

---

## 난독화·패킹 개요 — UPX / VMProtect 개념

### 패킹(Packing)

- **아이디어**: 원본 섹션을 압축/암호화 → 런타임에 언팩(스텁 코드) → IAT 재구성
- **지표**: `.text`가 짧고 엔트로피↑, **진입점이 스텁**(짧은 루프/메모리 복원 루틴), Import가 비정상(적거나 kernel32만)
- **UPX**: 오픈소스 패커.
  - 탐지: `strings`에 `UPX!`, 섹션명 `UPX0/UPX1`
  - 해제: `upx -d sample.exe` (옵션에 따라 실패 가능)

```bash
upx -9 hello.exe         # 패킹
upx -d hello.exe         # 언패킹
```

### 난독화(Obfuscation)

- **제어 흐름 평탄화**, **가짜 분기**, **가상화(바이트코드/VM)**
- **VMProtect**: 사용자 정의 VM 바이트코드로 핵심 루틴 보호 → 정적 디컴파일 어려움
- **대응**: 동적 추적(실행 흐름 캡처), **트레이싱 기반 복원**, **에뮬레이션**(angr/Unicorn) 등을 병행

> 실무 팁: “패킹 여부 판단 → 언패킹 가능하면 언패킹 후 분석 → 안되면 동적 추적/기록” 순서.

---

## 실습 — “간단한 라이선스 체크” 크랙미 분석

> 완전히 **교육용** 크랙미. 자신이 **직접 만든** 실행파일만 실습 대상으로 한다.
> 목표: 문자열/임포트/CFG로 정적 단서 → 런타임에서 비교 지점/입력 버퍼 관찰 → 알고리즘 이해.
> (우회/패치가 아닌 **동작 원리 분석**이 목적)

### 크랙미(작성자=본인) — 소스 코드(Windows/리눅스 공용 C)

```c
// crackme.c  (교육용)
// 빌드(리눅스): gcc -O2 crackme.c -o crackme
// 빌드(윈도우): cl /O2 crackme.c
#include <stdio.h>
#include <string.h>
#include <stdint.h>

static uint32_t rol(uint32_t x, int r){ return (x<<r)|(x>>(32-r)); }

static void derive(const char* name, char out[17]){
    // 아주 단순한 교육용 "해시 흉내"
    uint32_t a=0x12345678, b=0x9e3779b9;
    for(const unsigned char* p=(const unsigned char*)name; *p; ++p){
        a = rol(a ^ *p, 5) + b;
        b = rol(b + *p, 7) ^ a;
    }
    // hex 16자(8+8)
    sprintf(out, "%08X%08X", a, b);
}

int main(int argc, char** argv){
    if(argc!=3){ puts("Usage: crackme <name> <serial>"); return 1; }
    char expect[17]={0};
    derive(argv[1], expect);

    // 대소문자 구분 비교
    if(strcmp(expect, argv[2])==0){
        printf("Registered to %s\n", argv[1]);
        return 0;
    }else{
        puts("Invalid license");
        return 2;
    }
}
```

#### 실행 예시

```bash
./crackme alice 0000000000000000     # -> Invalid license
./crackme alice $(./gen alice)       # -> Registered to alice (gen은 아래에서 제작)
```

> 포인트:
> - “**이름 → serial**”로 결정적 매핑(라이선스 생성 로직)
> - 핵심 루틴: `derive()` → `sprintf`로 16자리 HEX

---

### 정적 분석(ELF/PE 동일 개념)

1) **파일 정보/보호**
   ```bash
   file crackme
   checksec --file=crackme || true
   strings -n 6 crackme | grep -i "license\|Registered"
   ```
   - 출력 문자열 “Registered”, “Invalid license” → 성공/실패 분기 존재

2) **임포트 / 심볼**
   - Linux: `readelf -s crackme | grep -E 'strcmp|sprintf'`
   - Windows(PE): PE-bear/pefile로 IAT에서 `strcmp/sprintf`(MSVCRT) 확인

3) **흐름 보기(Ghidra/IDA)**
   - `main` → `derive` → `sprintf` → `strcmp(expect, argv[2])`
   - **분기점**: `strcmp == 0` → OK, else → NG

4) **시그니처/의미부여**
   - `rol` 패턴(rotate left)이 보임 → 간단한 회전/혼합 해시

---

### 동적 분석(브레이크포인트/메모리 관찰)

#### (Linux) gdb로 `strcmp` 직전 관찰

```bash
gdb -q ./crackme
(gdb) set disassemble-next-line on
(gdb) run alice 1234
(gdb) break strcmp
(gdb) cont
# strcmp(a=expect, b=argv[2])

(gdb) x/s $rdi        # expect: 내부 계산된 정답
(gdb) x/s $rsi        # argv[2]: 내가 넣은 serial
(gdb) bt
```
- **핵심**: 내부에서 만든 정답(`expect`)을 **직접 확인** → 알고리즘이 무엇을 출력하는지 바로 알 수 있음

#### (Windows) x64dbg

- `strcmp` / `memcmp` API에 BP → 실행 → 스택/레지스터로 인자 관찰
- 인자1/2 버퍼를 `Follow in Dump`로 열어 비교

---

### 알고리즘 역이해 → 키젠(교육용) 작성

> 실제 상용 소프트웨어에 대한 키젠은 **불법**이다. **본인이 작성한 크랙미**에 대해서만 연습한다.

```python
# gen.py — 교육용 키젠(내가 만든 crackme에만)

def rol(x, r): return ((x << r) & 0xffffffff) | (x >> (32 - r))
def derive(name: str) -> str:
    a = 0x12345678
    b = 0x9e3779b9
    for ch in name.encode():
        a = (rol(a ^ ch, 5) + b) & 0xffffffff
        b = (rol(b + ch, 7) ^ a) & 0xffffffff
    return f"{a:08X}{b:08X}"

if __name__ == "__main__":
    import sys
    print(derive(sys.argv[1] if len(sys.argv)>1 else "alice"))
```

```bash
python3 gen.py alice
./crackme alice $(python3 gen.py alice)   # Registered to alice
```

- 학습 포인트:
  - “**정적 분석**”으로 알고리즘 구조 파악
  - “**동적 분석**”으로 내부 결과(정답 버퍼) 신속 검증
  - **키/시리얼은 이름에 종속**(키 생성 로직 드러남)

---

### API 모니터 & 안티 디버깅 징후

- **정상 크랙미**라도 상용에서는 다음이 흔하다:
  - `IsDebuggerPresent`, `CheckRemoteDebuggerPresent`, `NtQueryInformationProcess(ProcessDebugPort/Flags)`
  - `GetTickCount/Sleep`으로 타이밍/싱글스텝 탐지, `RDTSC` 측정
  - **TLS 콜백**에서 안티디버깅/무결성 검사

```bash
# Linux ltrace로 strcmp/sprintf 경로 재확인

ltrace -o lib.log ./crackme alice ABC
grep -i -E "strcmp|sprintf" lib.log
```

- **Windows**에서는 API Monitor로 C-런타임/WinAPI 호출 인자 관찰,
  **ProcMon**으로 레지스트리/파일 접근 유무 체크(라이선스 파일 읽는지 등).

---

### 패킹/난독화 버전 간단 체험(UPX)

> 같은 크랙미를 UPX로 감싸 본다. (교육용: 자신이 빌드한 바이너리만)
```bash
upx -9 crackme -o crackme.upx
file crackme.upx
strings crackme.upx | head    # 문자열이 크게 줄어듦(패킹 효과)
upx -d crackme.upx -o crackme.unpacked
diff <(strings crackme) <(strings crackme.unpacked) | sed -n '1,40p'
```
- 배움: 패킹되면 **정적 문자열/임포트**로 못 찾는 정보가 증가 → **동적 분석/메모리덤프/언패킹** 필요

---

## 실무형 체크리스트 & 분석 템플릿

### “5분 컷” 프리플라이트

- [ ] 파일/아키/보호(ASLR/PIE/NX)
- [ ] 문자열 스캔(성공/실패 메시지, URL, 포맷 문자열)
- [ ] 임포트 테이블 (strcmp/memcmp/Reg*/Crypt*)
- [ ] Entry/TLS 콜백 존재
- [ ] 패킹/엔트로피/비정상 섹션명

### 정적·동적 융합 루틴

- 정적: `main → check/derive → 비교 → OK/NG` 경로 표시(주석/도표)
- 동적: 비교 직전 BP → 인자/버퍼 확인 → 내부 “정답” 스냅샷
- 문서화: **함수명 리네임, 호출그래프 캡처, 의사코드 주석**(Ghidra/IDA)

### 보고서(블로그) 템플릿

- 샘플 소개/환경(도구/버전/스냅샷)
- 정적 탐색(문자열/임포트/CFG 스크린샷)
- 동적 관찰(BP 지점/레지스터/메모리)
- 알고리즘 요약(입력→출력 수식/의사코드)
- (교육용) 재현 코드/테스트 케이스
- 보안 관점: **우회 불가 설계 힌트**(서버 검증, HSM, 도메인 바인딩, 안티디버깅 튜닝)

---

## “더 단단한” 라이선스 설계 힌트(방어자 관점)

- **서버 검증**: 이름→키 로직을 클라이언트가 아는 구조 자체가 취약
- **바인딩**: 장치/계정/서버 세션과 결합(서명·토큰, 짧은 TTL)
- **무결성**: 코드/데이터 영역 보호(코드 서명, Control-Flow 보호, Anti-Debug/VM)
- **감사/탐지**: 비정상 시도는 서버에 이벤트(속도 제한/락)

---

# 부록 A — 툴별 미니 치트시트

### Ghidra

- `P`(함수 프로토타입), `L`(라벨), `Y`(데이터 유형), `R`(레퍼런스 보기)
- `Search → For Strings/For Instructions`로 패턴 탐색
- `Decompile` 창 주석(/** … */) 적극 활용

### IDA

- `F5` 의사코드, `N` 리네임, `;` 주석
- `Shift+F12` 문자열, `Imports` 탭에서 API 호출점 더블클릭
- FLIRT 시그니처로 라이브러리 식별

### x64dbg

- `Ctrl+G` Go to Address, `Ctrl+F` 검색, `Plugins → ScyllaHide`(반디버깅 완화)
- `Trace into/over`로 루프 빠르게 훑기
- Dump/Stack/Graph 뷰 동기화

### gdb

- `disassemble /m func`, `pi import gdb; ...`로 파이썬 확장
- `catch syscall open` 등 **catchpoint**
- `awatch rwatch` 하드웨어 감시(읽기/쓰기 트랩)

---

# 부록 B — 안티분석 흔한 테크닉 & 단서

- **Anti-Debug**: `IsDebuggerPresent`, `NtQueryInformationProcess`, `ptrace` 실패 체크
- **Anti-Dump**: IAT/CODE 복호화 지연, 메모리 스냅샷 무력화
- **Timing**: `RDTSC/GetTickCount`로 스텝 탐지
- **환경체크**: 프로세스 목록/드라이버(EDR/VM) 이름 스캔
- **대응**: API 후킹/패칭(연구용 랩), 가상시간/티커 조작, 언패킹 후 분석

---

# 마무리

이 장의 핵심은 **정적(구조/단서) → 동적(사실 확인) → 문서화(재현)**의 루프다.
- 포맷 구조(PE/ELF/Mach-O)를 **읽을 줄 알면**: 어디를 봐야 할지 속도가 붙는다.
- 브레이크포인트는 **비교 지점**에, 메모리 덤프는 **정답 버퍼**에.
- 패킹/난독화는 **언패킹/동적추적**으로 대응한다.
