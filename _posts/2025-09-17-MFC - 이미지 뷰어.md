---
layout: post
title: MFC - 이미지 뷰어
date: 2025-09-17 19:25:23 +0900
category: MFC
---
# 이미지 뷰어 (줌/팬/회전, GDI+ 더블버퍼) — MFC 실전 가이드

> 목표: **부드러운 줌/팬/회전**, **픽셀 정확도**, **고해상도에서도 깜빡임 없는 렌더링**.  
> 기술 스택: **MFC + GDI+** / **더블버퍼링** / **마우스 제스처(휠·드래그)** / **EXIF 회전** / **Fit/FIll/1:1** 모드.

---

## 0) 완성 UX 한 장 요약

- **마우스 휠**: 커서 기준 **줌 인/아웃** (Ctrl+휠 = 더 세밀)  
- **좌클릭 드래그**: 팬(손도구)  
- **R / L**: 시계/반시계 **90° 회전**  
- **F**: 화면에 맞게(Fit), **Shift+F**: 짧은 변 맞춤(Fill)  
- **1**: 100% (1:1) / **2**: 200% …  
- **스페이스**: 원본/화면맞춤 **토글**  
- **고품질 스무딩**: 축소 시 **고품질**, 확대시 **저품질**로 전환(가독성↑, 성능↑)  
- **더블버퍼**: 해상도 큰 모니터에서도 **무(無) 깜빡임**

---

## 1) 프로젝트 뼈대

- **MFC App** → **SDI** + **공유 MFC(/MD)** + **유니코드**  
- **GDI+ 초기화**: `CWinApp::InitInstance`에서 `GdiplusStartup` / `ExitInstance`에서 `GdiplusShutdown`  
- **View**는 `CWnd` 파생(직접 스크롤 관리) 또는 `CScrollView` 파생(간단 스크롤 자동화).  
  여기서는 **직접 스크롤/변환**을 다루기 위해 **`CWnd` 파생**을 사용.

### 1-1. GDI+ 스타트업(앱 수명과 동일)

```cpp
// GdiPlusInit.h
#include <gdiplus.h>
#pragma comment(lib, "gdiplus.lib")
class CGdiPlusInit {
    ULONG_PTR m_token{};
public:
    CGdiPlusInit()  { Gdiplus::GdiplusStartupInput in; Gdiplus::GdiplusStartup(&m_token, &in, nullptr); }
    ~CGdiPlusInit() { if (m_token) Gdiplus::GdiplusShutdown(m_token); }
};
```

```cpp
// App.cpp
CGdiPlusInit g_gdiplus;
```

---

## 2) 뷰 클래스 설계(상태 + 변환)

핵심은 **하나의 변환(월드 변환)** 으로 **스케일(zoom)** + **회전(rotation)** + **팬(translation)** 을 처리하는 것.

```cpp
// ImageView.h
class CImageView : public CWnd {
public:
    DECLARE_DYNAMIC(CImageView)
    BOOL LoadFile(const CStringW& path);  // GDI+ Bitmap 로드
    void SetZoom(double z, CPoint anchorInClient = CPoint(-1,-1));
    void ZoomBy(double factor, CPoint anchor);
    void Rotate90(bool cw);               // 90° 회전(시계/반시계)
    void FitToWindow();                   // 화면 맞춤(Fit)
    void FillShortSide();                 // 짧은 변 맞춤(Fill)
    void ResetView();                     // 원본 1:1 + 원점
protected:
    Gdiplus::Bitmap* m_bmp = nullptr;     // 원본 이미지
    double m_zoom = 1.0;                  // 배율(1=100%)
    double m_angle = 0.0;                 // 도 단위(90의 배수 권장)
    CPoint m_pan{0,0};                    // 팬 오프셋(클라이언트 좌표)
    CPoint m_lastDrag{}; bool m_dragging=false;

    // 더블버퍼
    CBitmap m_backBmp; CSize m_backSize{};
    void EnsureBackBuffer(CDC& dc, CSize need);
    void DrawScene(CDC& memDC, const CRect& rcClient);

    // 좌표 변환 도우미
    Gdiplus::Matrix BuildWorld(const CRect& rcClient) const;
    CPointF ClientToImage(CPoint client) const; // 역변환(히트테스트 용)
    // EXIF
    void ApplyExifOrientationIfAny(Gdiplus::Bitmap* bmp);

    afx_msg int  OnCreate(LPCREATESTRUCT cs);
    afx_msg void OnDestroy();
    afx_msg void OnPaint();
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnSize(UINT type, int cx, int cy);
    afx_msg void OnLButtonDown(UINT, CPoint);
    afx_msg void OnLButtonUp(UINT, CPoint);
    afx_msg void OnMouseMove(UINT, CPoint);
    afx_msg BOOL OnMouseWheel(UINT, short zDelta, CPoint ptScreen);
    afx_msg void OnKeyDown(UINT ch, UINT, UINT);
    DECLARE_MESSAGE_MAP()
};
```

---

## 3) 이미지 로드와 EXIF 방향 보정

카메라/스마트폰 이미지는 **EXIF Orientation**을 내장합니다. 불러올 때 **한 번 보정**해두면 이후 회전/줌이 단순해집니다.

```cpp
// ImageView.cpp (핵심만)
BOOL CImageView::LoadFile(const CStringW& path) {
    std::unique_ptr<Gdiplus::Bitmap> tmp(new Gdiplus::Bitmap(path));
    if (tmp->GetLastStatus() != Gdiplus::Ok) return FALSE;
    ApplyExifOrientationIfAny(tmp.get());          // 필요 시 회전/뒤집기
    delete m_bmp; m_bmp = tmp.release();
    m_zoom = 1.0; m_angle = 0.0; m_pan = {0,0};
    Invalidate();
    return TRUE;
}
```

```cpp
void CImageView::ApplyExifOrientationIfAny(Gdiplus::Bitmap* bmp) {
    UINT size = bmp->GetPropertyItemSize(Gdiplus::PropertyTagOrientation);
    if (size == 0) return;
    std::vector<BYTE> buf(size);
    if (bmp->GetPropertyItem(Gdiplus::PropertyTagOrientation, size, (Gdiplus::PropertyItem*)buf.data()) != Gdiplus::Ok) return;
    auto* pi = (Gdiplus::PropertyItem*)buf.data();
    USHORT val = *reinterpret_cast<USHORT*>(pi->value);
    using RF = Gdiplus::RotateFlipType;
    RF rf = RF::RotateNoneFlipNone;
    switch (val) {
        case 2: rf = RF::RotateNoneFlipX; break;
        case 3: rf = RF::Rotate180FlipNone; break;
        case 4: rf = RF::Rotate180FlipX; break;
        case 5: rf = RF::Rotate90FlipX; break;
        case 6: rf = RF::Rotate90FlipNone; break;
        case 7: rf = RF::Rotate270FlipX; break;
        case 8: rf = RF::Rotate270FlipNone; break;
        default: return;
    }
    bmp->RotateFlip(rf); // 원본을 바꿔 두면 이후가 간단
    // (옵션) Orientation 태그 제거
}
```

---

## 4) 더블버퍼링(깜빡임 0)

- **메모리 DC + 화면과 동일 크기 비트맵** 준비  
- **모든 그리기(GDI+)는 메모리 DC 기반 Graphics**에 수행  
- 마지막에 **`BitBlt`** 로 한 번에 전송

```cpp
void CImageView::EnsureBackBuffer(CDC& dc, CSize need) {
    if (m_backSize == need && m_backBmp.m_hObject) return;
    m_backBmp.DeleteObject();
    m_backBmp.CreateCompatibleBitmap(&dc, need.cx, need.cy);
    m_backSize = need;
}

void CImageView::OnPaint() {
    CPaintDC dc(this);
    CRect rc; GetClientRect(&rc);
    EnsureBackBuffer(dc, rc.Size());
    CDC mem; mem.CreateCompatibleDC(&dc);
    auto old = mem.SelectObject(&m_backBmp);

    // 배경
    mem.FillSolidRect(rc, RGB(32,32,32));
    DrawScene(mem, rc);

    dc.BitBlt(0,0, rc.Width(), rc.Height(), &mem, 0,0, SRCCOPY);
    mem.SelectObject(old);
}
BOOL CImageView::OnEraseBkgnd(CDC*) { return TRUE; } // 깜빡임 방지
```

---

## 5) 월드 변환(줌/팬/회전)을 한 번에: Matrix

이미지 중심으로 회전/확대 후, 화면 중앙 또는 팬 오프셋에 맞춰 위치.  
**커서 기준 줌**을 위해 `anchorInClient` 기준점 보정 포함.

```cpp
Gdiplus::Matrix CImageView::BuildWorld(const CRect& rc) const {
    using namespace Gdiplus;
    Matrix mx; // 순서 중요: 변환은 "오른쪽에서 왼쪽"으로 적용

    // 1) 화면 중심으로 이동(기저)
    const float cx = rc.Width() * 0.5f;
    const float cy = rc.Height() * 0.5f;
    mx.Translate(cx, cy, MatrixOrderAppend);

    // 2) 팬(사용자 드래그)
    mx.Translate((Gdiplus::REAL)m_pan.x, (Gdiplus::REAL)m_pan.y, MatrixOrderAppend);

    // 3) 회전(도 단위)
    mx.Rotate((Gdiplus::REAL)m_angle, MatrixOrderAppend);

    // 4) 줌
    mx.Scale((Gdiplus::REAL)m_zoom, (Gdiplus::REAL)m_zoom, MatrixOrderAppend);

    // 5) 이미지 중심을 원점으로(이미지 공간 → 화면)
    if (m_bmp) {
        Gdiplus::REAL iw = (Gdiplus::REAL)m_bmp->GetWidth();
        Gdiplus::REAL ih = (Gdiplus::REAL)m_bmp->GetHeight();
        mx.Translate(-iw*0.5f, -ih*0.5f, MatrixOrderAppend);
    }
    return mx;
}
```

---

## 6) 장면 그리기(보간 품질 스위칭)

- 축소(zoom < 1): **HighQualityBicubic**  
- 확대(zoom ≥ 1): **NearestNeighbor** 또는 **Default** (픽셀 농도 유지, 선명)

```cpp
void CImageView::DrawScene(CDC& memDC, const CRect& rcClient) {
    using namespace Gdiplus;
    Graphics g(memDC);
    g.SetSmoothingMode(SmoothingModeNone);
    g.SetPixelOffsetMode(PixelOffsetModeHalf);
    g.SetCompositingMode(CompositingModeSourceCopy);

    if (!m_bmp) {
        // 안내 텍스트
        memDC.SetTextColor(RGB(200,200,200)); memDC.SetBkMode(TRANSPARENT);
        memDC.DrawText(L"이미지를 열어 주세요", -1, (LPRECT)&rcClient, DT_CENTER|DT_VCENTER|DT_SINGLELINE);
        return;
    }

    auto mx = BuildWorld(rcClient);
    g.SetTransform(&mx);

    // 보간 모드
    if (m_zoom < 1.0) g.SetInterpolationMode(InterpolationModeHighQualityBicubic);
    else              g.SetInterpolationMode(InterpolationModeNearestNeighbor);

    // 이미지 그리기(이미지 좌표에 맞춰 0,0에서 원본 크기)
    g.DrawImage(m_bmp, 0, 0, m_bmp->GetWidth(), m_bmp->GetHeight());
}
```

---

## 7) 입력: 팬/휠 줌/키보드 회전

### 7-1. 팬(드래그)

```cpp
void CImageView::OnLButtonDown(UINT, CPoint pt) { SetCapture(); m_dragging=true; m_lastDrag=pt; }
void CImageView::OnLButtonUp(UINT, CPoint)      { if (m_dragging) { ReleaseCapture(); m_dragging=false; } }
void CImageView::OnMouseMove(UINT, CPoint pt) {
    if (!m_dragging) return;
    CPoint d = pt - m_lastDrag; m_lastDrag = pt;
    m_pan += d; Invalidate(FALSE);
}
```

### 7-2. 커서 기준 휠 줌

- 줌 전후의 **이미지-좌표(anchor)** 가 **화면 커서 자리**에 머물도록 **팬 보정**.

```cpp
BOOL CImageView::OnMouseWheel(UINT, short zDelta, CPoint ptScreen) {
    CPoint pt; ScreenToClient(&pt);
    double factor = (GetKeyState(VK_CONTROL)<0) ? 1.05 : 1.15;
    if (zDelta < 0) factor = 1.0 / factor;
    ZoomBy(factor, pt);
    return TRUE;
}

void CImageView::ZoomBy(double factor, CPoint anchor) {
    if (!m_bmp) return;
    // anchor(클라이언트) → 이미지 좌표
    CPointF imgBefore = ClientToImage(anchor);
    m_zoom = std::clamp(m_zoom * factor, 0.01, 64.0);
    // 보정: 줌 이후에도 같은 이미지 점이 같은 화면 위치에 있도록 팬 이동
    CPointF imgAfter = ClientToImage(anchor);
    CPointF diff = { imgAfter.X - imgBefore.X, imgAfter.Y - imgBefore.Y };

    // diff(이미지 공간)를 화면 팬으로 변환하려면 현재 변환에서 스케일/회전 반영 필요
    // 간단하게는 "줌만 바뀌었다"고 가정하고 화면 오프셋 ≈ (diff * zoom) 회전 반영
    // 정확히 하려면 world matrix의 선형부를 이용해 변환.
    Gdiplus::Matrix mx = BuildWorld(CRect(CPoint(0,0), CSize(1,1)));
    // 선형부 추출해서 diff(이미지)->screen delta (2x2 곱)
    Gdiplus::REAL m[6]; mx.GetElements(m); // [m11 m12 m21 m22 dx dy]
    CPointF scrDelta = { diff.X*m[0] + diff.Y*m[2], diff.X*m[1] + diff.Y*m[3] };

    m_pan.x -= (int)std::lround(scrDelta.X);
    m_pan.y -= (int)std::lround(scrDelta.Y);
    Invalidate(FALSE);
}
```

```cpp
// Client → Image 역변환
CPointF CImageView::ClientToImage(CPoint client) const {
    if (!m_bmp) return {0,0};
    using namespace Gdiplus;
    CRect rc; GetClientRect(&rc);
    Matrix mx = BuildWorld(rc);
    Matrix inv = mx; inv.Invert();
    PointF p((Gdiplus::REAL)client.x, (Gdiplus::REAL)client.y);
    inv.TransformPoints(&p, 1);
    return p;
}
```

### 7-3. 회전/핏/토글 키

```cpp
void CImageView::OnKeyDown(UINT ch, UINT, UINT) {
    switch (ch) {
    case 'R': Rotate90(true);  break;
    case 'L': Rotate90(false); break;
    case 'F': if (GetKeyState(VK_SHIFT)<0) FillShortSide(); else FitToWindow(); break;
    case '1': SetZoom(1.0); break;
    case VK_SPACE:
        if (fabs(m_zoom-1.0)<1e-6) FitToWindow(); else SetZoom(1.0);
        break;
    default: CWnd::OnKeyDown(ch,0,0);
    }
}

void CImageView::Rotate90(bool cw) { m_angle += cw? 90.0 : -90.0; if (m_angle<=-180) m_angle+=360; if (m_angle>180) m_angle-=360; Invalidate(FALSE); }

void CImageView::SetZoom(double z, CPoint anchor) {
    if (!m_bmp) return;
    if (anchor.x<0) { CRect rc; GetClientRect(&rc); anchor = rc.CenterPoint(); }
    ZoomBy(z / m_zoom, anchor);
}
```

---

## 8) Fit/Flll 계산

이미지(w,h)와 클라이언트(W,H). 회전 각도가 90/270이면 **가로/세로 교체** 후 계산.  
- **Fit**: `scale = min(W/w, H/h)`  
- **Fill(short side)**: `scale = max(W/w, H/h)` (짧은 변 맞춤 → 일부 잘림)  
- 팬은 중앙 정렬.

```cpp
void CImageView::FitToWindow() {
    if (!m_bmp) return;
    CRect rc; GetClientRect(&rc);
    int iw = (int)m_bmp->GetWidth(), ih = (int)m_bmp->GetHeight();
    bool rot90 = ((int)fabs(fmod(m_angle,180.0)) != 0);
    int rw = rot90 ? ih : iw, rh = rot90 ? iw : ih;

    double sx = (double)rc.Width()  / rw;
    double sy = (double)rc.Height() / rh;
    m_zoom = std::max(0.01, std::min(sx, sy));
    m_pan = {0,0};
    Invalidate(FALSE);
}

void CImageView::FillShortSide() {
    if (!m_bmp) return;
    CRect rc; GetClientRect(&rc);
    int iw = (int)m_bmp->GetWidth(), ih = (int)m_bmp->GetHeight();
    bool rot90 = ((int)fabs(fmod(m_angle,180.0)) != 0);
    int rw = rot90 ? ih : iw, rh = rot90 ? iw : ih;

    double sx = (double)rc.Width()  / rw;
    double sy = (double)rc.Height() / rh;
    m_zoom = std::max(0.01, std::max(sx, sy));
    m_pan = {0,0};
    Invalidate(FALSE);
}
```

---

## 9) 대용량/초고해상도 대응 팁

1) **보간 품질 스위칭**: 축소 시 HQBicubic, 확대 시 Nearest로 **CPU 절약**  
2) **비가시 영역 스킵**: `Graphics::SetClip`으로 화면 밖 렌더 생략  
3) **타일링(고급)**: 아주 큰 이미지(TIFF 등)는 **타일 단위 디코딩**(WIC) → 현재 뷰 포트만 그리기  
4) **멀티스레드 디코딩**: 파일 로드는 워커 스레드, **UI는 로딩 중 프리뷰/로더 스피너**  
5) **색관리**: GDI+는 단순 sRGB 가정. 컬러 정확도가 중요하면 WIC + ICM 또는 Direct2D/ColorContext 고려

---

## 10) 고DPI/Per-Monitor-V2 지원

- 매니페스트: PerMonitorV2  
- 폰트/패딩은 DPI 기준 재계산(뷰는 주로 캔버스이므로 영향 적음)  
- 휠/드래그는 물리 픽셀 기반이더라도 UX상 문제 없음  
- 다중 모니터에서 DPI 변경 시 `WM_DPICHANGED` → `EnsureBackBuffer` 재생성

---

## 11) 인쇄/프린트 프리뷰(선택)

- `OnBeginPrinting`에서 **페이지 크기→이미지 스케일** 계산  
- `OnPrint`에서 **GDI+ Graphics**에 동일한 world transform 적용  
- 보간은 **HighQualityBicubic** 권장(축소)

---

## 12) 파일 형식/저장(회전 반영)

- 회전/줌/팬은 뷰 **표시 상태**일 뿐.  
- **파일 저장 시** 회전만 반영하려면 `Bitmap::RotateFlip` 후 `Save`  
- JPEG 품질 설정: `EncoderParameters` 로 `EncoderQuality`

---

## 13) 전체 코드(요약 버전)

> 아래는 핵심 메서드만 발췌한 **동작 가능한 축약본**입니다. 리소스/프레임 연결, 메뉴/단축키는 프로젝트에 맞게 추가하세요.

```cpp
BEGIN_MESSAGE_MAP(CImageView, CWnd)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_WM_PAINT()
    ON_WM_ERASEBKGND()
    ON_WM_SIZE()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_WM_MOUSEWHEEL()
    ON_WM_KEYDOWN()
END_MESSAGE_MAP()

int CImageView::OnCreate(LPCREATESTRUCT cs) {
    if (CWnd::OnCreate(cs)==-1) return -1;
    return 0;
}
void CImageView::OnDestroy() {
    delete m_bmp; m_bmp=nullptr;
    CWnd::OnDestroy();
}
void CImageView::OnSize(UINT t, int cx, int cy) { Invalidate(FALSE); CWnd::OnSize(t,cx,cy); }
```

나머지는 위 섹션의 함수 그대로 사용.

---

## 14) QA 체크리스트

- [ ] PNG/JPEG/WEBP(확장 코덱)/TIFF(멀티프레임) 로드  
- [ ] 축소/확대 품질 전환(문자 가장자리 확인)  
- [ ] 커서 기준 줌: 흰 점을 콕 찍고 줌인/아웃 시 **그 점이 자리를 유지**  
- [ ] 90/180/270 회전 + Fit/Fill 정확성  
- [ ] 초고해상도(예: 12,000×8,000)에서 드래그 프레임 유지(60fps가 이상적)  
- [ ] 다중 모니터, 125%/150%/200% DPI에서 깔끔  
- [ ] EXIF 회전 사진의 초깃값 올바름

---

## 15) 확장 아이디어

- **멀티 탭**(여러 이미지) / **폴더 탐색(다음/이전)**  
- **측정자/자**: 이미지 좌표 거리 측정  
- **오버레이**: 그리드/중심선/히스토그램 미니뷰  
- **컬러 선택기**: 커서 픽셀 RGBA/HSV  
- **Annotaion**: 벡터 레이어(Undo/Redo)

---

## 16) 마무리

핵심은 **하나의 월드 변환**으로 **줌·팬·회전을 일관 처리**하고, **더블버퍼링으로 깜빡임을 제거**하는 것입니다.  
여기에 **커서 중심 줌**과 **보간 품질 스위칭**만 더하면 **매끄럽고 가벼운 이미지 뷰어**를 완성할 수 있습니다.
