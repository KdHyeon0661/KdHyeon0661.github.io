---
layout: post
title: 컴퓨터시스템 - 다른 동시성의 이슈
date: 2025-09-10 23:20:23 +0900
category: 컴퓨터시스템
---
# 다른 동시성의 이슈(문제군) — 정확성·성능·신뢰성 관점의 총정리

---

## 1) 정확성(Correctness) 이슈

### 1.1 데이터 레이스(Data Race)
- 동기화 없이 **같은 메모리**에 두 쓰레드가 동시 접근(최소 하나는 쓰기) → **UB(정의되지 않은 동작)**.
- 해결: **뮤텍스/원자(atomic)/메시지 패싱** 중 하나로 보호.

```c
// BAD: 경쟁 증가/손실 갱신
int x=0;
void* t(void*){ for(int i=0;i<1e6;i++) x++; return NULL; }

// GOOD: 락 또는 원자
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
void* t(void*){ for(int i=0;i<1e6;i++){ pthread_mutex_lock(&m); x++; pthread_mutex_unlock(&m);} return NULL; }
// 또는
#include <stdatomic.h>
atomic_int x=0;
void* t(void*){ for(int i=0;i<1e6;i++) atomic_fetch_add_explicit(&x,1,memory_order_relaxed); return NULL; }
```

### 1.2 원자성 위반(Atomicity Violation)
- “읽기→수정→쓰기”가 **한 덩어리**가 아니어서 깨지는 경우. (예: check-then-act)

```c
// BAD
if (!in_use[id]) { in_use[id]=1; /* ... */ }   // 사이에 끼어들면 중복 할당
// GOOD: 같은 임계구역으로 묶기
pthread_mutex_lock(&m);
if (!in_use[id]) { in_use[id]=1; /* ... */ }
pthread_mutex_unlock(&m);
```

### 1.3 순서 위반(Order Violation) & 가시성(Visibility)
- 컴파일러/CPU 재배치로 **발행(publish)** 순서가 깨짐.
- 해결: C11 원자 **acquire/release** 또는 락을 통해 **happens-before**를 만든다.

```c
typedef struct { atomic_int ready; int data; } slot;
// producer
s->data = 42;
atomic_store_explicit(&s->ready, 1, memory_order_release);
// consumer
while(!atomic_load_explicit(&s->ready, memory_order_acquire)) {}
printf("%d\n", s->data);
```

### 1.4 초기화/발행 안전성(Safe Publication)
- 객체를 **완전히 초기화**하기 전에 포인터를 공개하면 다른 쓰레드가 **반쯤 초기화된 상태**를 볼 수 있음.
- 해결: 초기화 후 **release-store**로 포인터 교체, 소비자는 **acquire-load**.

### 1.5 조건변수의 **유실 신호(Lost Wakeup)** & **스퍼리어스 웨이크업**
- `signal()`이 먼저 와도 **상태(predicate)**가 맞지 않으면 다시 자야 한다.
- **항상 `while (!조건) wait()`**가 정석.

```c
pthread_mutex_lock(&m);
while (!ready) pthread_cond_wait(&cv,&m);
pthread_mutex_unlock(&m);
```

### 1.6 교착상태(Deadlock)
- 네 조건: 상호배제, 점유-대기, 비선점, 환형대기.
- **대응 전략**
  - **전역 락 순서** 규약(예: A→B→C 순으로만 획득)
  - `trylock + backoff`, **타임아웃 잠금**
  - 큰 락을 작게 쪼개되 **순서**는 유지

```c
// BAD: 순서 역전
// T1: lock(A)->lock(B) , T2: lock(B)->lock(A)
```

### 1.7 라이브락(Livelock) / 기아(Starvation)
- 라이브락: 서로 비켜주다 **진전 없음**.
- 기아: 낮은 우선순위가 **영원히 기회 없음**.
- 해결: 랜덤 백오프, 공정 락, 스케줄·우선순위 재설계.

### 1.8 우선순위 역전(Priority Inversion)
- 낮은 우선순위가 잡은 락 때문에 높은 우선순위가 대기.
- 해결: **우선순위 상속/천장**(뮤텍스 속성), **긴 임계구역 금지**.

### 1.9 TOCTTOU(Check-Use 간 경합)
- 상태를 확인하고 쓰는 사이에 상태가 바뀌는 버그. (파일/권한/맵 상태 등)
- 해결: **동일 락으로 확인+사용을 원자화**.

### 1.10 락-프리에서의 **ABA 문제**
- CAS에서 A→B→A로 바뀌면 “변화 없음”으로 오인.
- 해결: **태그/스탬프 포인터**, **Hazard Pointer / Epoch GC**로 메모리 재활용 안전화.

### 1.11 재진입성(Reentrancy) & 스레드 안정성(Thread-Safety)
- 시그널 핸들러/콜백이 **동일 함수**를 다시 호출할 때 안전한가?
- **async-signal-safe** 목록 외 호출 금지, 전역 상태가 있으면 락 또는 재진입 설계.

---

## 2) 성능(Performance/Scalability) 이슈

### 2.1 락 경합·컨보이(lock convoy)·스래싱
- 많은 쓰레드가 한 락을 두드려 **컨텍스트 스위치 폭증**.
- 대응: **미세락**, **샤딩(분할)**, **읽기-쓰기 락**, **per-thread 로컬 후 reduction**.

### 2.2 거짓 공유(False Sharing) & 캐시라인 핑퐁
- 서로 다른 변수가 **같은 캐시라인(보통 64B)** 에 있어 **무효화 폭주**.
- 해결: **패딩/정렬**, per-core 구조.

```c
#include <stdalign.h>
#define CL 64
typedef struct { alignas(CL) long v; } padded_long;
```

### 2.3 NUMA 함정
- 원격 노드 메모리 접근이 느림, 페이지가 노드 사이 **바운스**.
- 해결: **first-touch** 초기화, 코어 고정(affinity), NUMA 정책/바인딩.

### 2.4 메모리 할당기 경합
- 전역 락 기반 malloc은 병목.
- 해결: **jemalloc/tcmalloc** 등 스레드 캐시 지원 할당기, **per-thread pool**.

### 2.5 과다 스레드(Over-subscription) & 코어 마이그레이션
- 스레드가 코어 수보다 과하면 **스위치 비용**·캐시 미스 증가.
- 대응: **스레드 수=물리 코어 수±α**, 긴 작업은 **코어 고정**.

### 2.6 I/O계 병목
- **thundering herd**, 비효율적 **EPOLLOUT 상시 등록**, **부분 I/O 미처리**.
- 대응: 이벤트 루프에서 **EAGAIN까지 drain/fill**, **EPOLLOUT 토글**, **백프레셔**.

### 2.7 TLB Shootdown/페이지 스로싱
- 거대한 공유 자료구조의 잦은 쓰기 → TLB/페이지 테이블 갱신 비용.
- 해결: **데이터 분할**, 적절한 **hugepage**(상황 한정), 쓰기 지역성 확보.

---

## 3) 신뢰성/운영(Operational) 이슈

### 3.1 취소 안전(Cancellation Safety)
- `pthread_cancel`은 보통 **지연 취소**. `wait/cond_wait/read` 등에서만 반응.
- 정리 핸들러로 **락/세마포어 반납 보장**.

```c
void cleanup(void* p){ pthread_mutex_unlock((pthread_mutex_t*)p); }
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
void* worker(void*){
  pthread_mutex_lock(&m);
  pthread_cleanup_push(cleanup,&m);
  /* ... (중간에 취소돼도 m 해제) */
  pthread_cleanup_pop(1);
  return NULL;
}
```

### 3.2 신호 + 멀티스레딩
- 신호는 **프로세스 전체**. 전용 스레드에서 `sigwait()`로 **동기 처리** 권장.
- 비동기 시그널 핸들러는 **async-signal-safe 함수만**.

### 3.3 `fork()`와 스레드
- 멀티스레드 프로세스에서 `fork()` 후 자식은 **한 스레드만** 존재 → **락이 잠겨 있으면 교착**.
- 해결: **`posix_spawn()`** 우선, 불가피하면 `pthread_atfork`로 정리.

### 3.4 시간/타임아웃의 함정
- `sem_timedwait`는 기본 **절대시간(CLOCK_REALTIME)** → 시스템 시간 변경의 영향을 받음.
- 선호: **`CLOCK_MONOTONIC` 기반** 타임아웃 계산.

### 3.5 자원 한계/한도
- FD/스레드/스택 크기 제한(ulimit), 포트 고갈, 커널 큐 길이.
- 운영 전 **한도 상향** 및 **에러 경로 로깅** 필수.

---

## 4) I/O·이벤트 기반 추가 이슈

### 4.1 헤드-오브-라인(HoL) 블로킹
- 한 커넥션의 큰 응답이 이벤트 루프를 **길게 점유** → 전체 지연 증가.
- 해결: **분할 전송**, **타임 슬라이싱**, 필요 시 **스레드풀로 오프로딩**.

### 4.2 백프레셔(Backpressure) 설계
- 무한 큐는 메모리 폭주.  
- 해결: **유한 큐 + 드롭/지연 + 상위 레이어에 신호**(윈도우 크기, 429/리트라이 등).

### 4.3 재진입/콜백 지옥
- 콜백에서 **동일 루프를 재진입**해 상태 기계가 꼬임.
- 해결: **상태 기계 명시화**, 큐잉하여 **루프 틱**에서만 진행.

---

## 5) 설계 패턴으로 회피하기

1) **불변(Immutable) 데이터**: 초기화 후 변경 금지 → 락 불필요  
2) **메시지 패싱/Actor/CSP**: 공유 대신 **전달**. 경계 사이에 **유한 큐**로 역압  
3) **per-thread/per-core 샤딩**: 공유 쓰기를 분산하고 마지막에 **reduction**  
4) **RCU/Copy-on-Write**: 읽기 경합 0, 쓰기 시 사본 교체  
5) **Idempotency & Retry**: 재시도 가능한 연산으로 장애/취소에도 안전  
6) **구조적 동시성(Structured Concurrency)**: 생성된 작업은 **스코프에서 합류/정리**

---

## 6) 진단/검증 도구

- **ThreadSanitizer(TSan)**: 레이스·락 순서 문제 탐지 (`-fsanitize=thread`)
- **Helgrind/DRD(Valgrind)**: 락/데이터 레이스 분석
- **rr(Record/Replay)**: 비결정 실행 재현
- **perf / eBPF / flamegraph**: 락 경합·스케줄링 비용 가시화
- **stress/fuzz**: 난수 스케줄·장시간 부하로 희소 버그 표면화
- **락 순서 체커**: 커스텀 assert로 **획득 순서** 강제

---

## 7) 대표 함정 → 올바른 코드 스니펫

### 7.1 조건변수
```c
// BAD
pthread_mutex_lock(&m);
if (!ready) pthread_cond_wait(&cv,&m);  // if 는 틀림
pthread_mutex_unlock(&m);

// GOOD
pthread_mutex_lock(&m);
while (!ready) pthread_cond_wait(&cv,&m);
pthread_mutex_unlock(&m);
```

### 7.2 더블체크 초기화(올바른 버전)
```c
#include <stdatomic.h>
typedef struct cfg cfg_t;
_Atomic(cfg_t*) g=NULL; pthread_mutex_t m=PTHREAD_MUTEX_INITIALIZER;

cfg_t* get(){
  cfg_t* p = atomic_load_explicit(&g, memory_order_acquire);
  if(!p){
    pthread_mutex_lock(&m);
    p = atomic_load_explicit(&g, memory_order_acquire);
    if(!p){ cfg_t* n = /* init */; atomic_store_explicit(&g,n, memory_order_release); p=n; }
    pthread_mutex_unlock(&m);
  }
  return p;
}
```

### 7.3 락 순서 규약
```c
// 규약: 항상 lock(A) -> lock(B)
pthread_mutex_lock(&A);
pthread_mutex_lock(&B);
/* ... */
pthread_mutex_unlock(&B);
pthread_mutex_unlock(&A);
```

---

## 8) 체크리스트(현업용)

- [ ] **레이스 없음**: 락/원자/메시지로 보호, `volatile`로 동기화하지 말 것  
- [ ] **happens-before**를 명시(acq/rel, 락 해제↔획득, cond wait)  
- [ ] **락 순서** 규약 문서화 & 코드 리뷰로 강제  
- [ ] **while-wait** 패턴 준수(조건변수)  
- [ ] **거짓 공유** 방지(패딩/샤딩), 락 경합 측정  
- [ ] **NUMA/first-touch**, 코어 고정 검토, 스레드 수 튜닝  
- [ ] **유한 큐 + 백프레셔** 설계, 타임아웃/재시도 정책  
- [ ] **취소/에러 경로**에서 리소스 반납 보장(cleanup)  
- [ ] **fork 대신 posix_spawn**, 신호는 `sigwait` 전용 스레드  
- [ ] TSan/Helgrind/rr/perf로 **정확성+성능**을 함께 검증

---

## 9) 한 줄 결론
동시성의 “다른 이슈”들은 대부분 **공유상태의 정확성**(레이스·순서·발행), **스케일링**(락·캐시·NUMA), **운영 안정성**(취소·신호·자원한도)에서 발생합니다.  
정확성 원칙(happens-before)과 성능 패턴(샤딩·reduction·불변), 운영 수칙(타임아웃·백프레셔·도구)을 **체계적으로 결합**하면, 복잡한 동시성 시스템도 예측 가능하고 빠르게 유지할 수 있습니다.