---
layout: post
title: 형식언어와 오토마타 - 비정규 언어의 식별
date: 2025-07-08 19:20:23 +0900
category: 형식언어와 오토마타
---
# 비정규 언어의 식별 — 펌핑 보조정리, Myhill–Nerode, 폐포성

문서 목표
- **언제** 언어가 정규가 *아닌지* 빠르게 감지하는 체크리스트 제공
- **세 가지 핵심 도구**: 펌핑 보조정리(regular), **Myhill–Nerode 정리**, **폐포성/호모모피즘**으로 “증명 패턴” 손에 익히기
- **실전 예제**와 **코드(교육용 시뮬레이터)**로 감각 고정

---

## 0. 큰 그림: “정규가 아닌 이유”는 보통 ‘메모리’ 때문이다

정규 언어(=DFA/NFA/정규식)는 **유한 상태**만 갖습니다.
따라서 “균형/대칭/상호의존/거울”처럼 **무한히 많은 경우를 기억해야 하는 관계**는 다룰 수 없습니다.

대표 비정규 패턴
- **균형/카운트 동등**: \( \{a^n b^n\} \), \( \{a^n b^n c^n\} \)
- **거울/반복**: \( \{ww \mid w\in \Sigma^*\} \), Palindrome \( \{w w^R\} \)
- **복잡한 산술 관계**: \( \{ a^{p} \mid p \text{는 소수}\} \), \( \{ a^{n^2}\} \)

---

## 1. 도구 #1 — 펌핑 보조정리(Pumping Lemma for Regular Languages)

### 정리(요지)
정규 언어 \(L\)이면, 어떤 \(p>0\)이 존재하여 **모든** \(w\in L\) (단, \(|w|\ge p\))에 대해
\( w = xyz \)로 분해가 가능하며 다음을 만족:
1. \( |xy|\le p \)
2. \( |y|\ge 1 \)
3. \( \forall i\ge 0: xy^i z \in L \)

핵심 감각: **초반부**에 있는 짧은 루프 \(y\)를 늘려도 언어에서 벗어나지 않아야 정규.

### 사용법(실전 절차)
1) **정규라고 가정**(귀류) → 펌핑 길이 \(p\) 존재
2) 전략적으로 **증거 문자열** \( w \) 선택 (\(|w|\ge p\), 보통 구조가 잘 드러나는 형태)
3) **모든 분해** \( w=xyz \), \(|xy|\le p, |y|\ge 1\)에 대해 공통으로 깨질 **i**를 설계
4) \(xy^i z \notin L\) 을 유도 → 모순 → 비정규

> 주의: 펌핑 정리는 “정규 ⇒ 펌핑됨”의 **필요조건**.
> “펌핑 가능”하다고 **정규가 되는 건 아니다**(충분조건 아님).

---

## 2. 도구 #2 — Myhill–Nerode 정리(가장 강력, 깔끔, 보편)

### 정리(요지)
언어 \(L\)이 정규 ⇔ **동치류 개수**가 유한.
여기서 동치 관계는 다음과 같이 정의:
- \( x \equiv_L y \iff \forall z\in \Sigma^*: (xz \in L) \Leftrightarrow (yz \in L) \)

**아이디어**: 서로 **구별될 수 있는 접미사(continuation)**가 무한히 많으면 비정규.

### 실전 사용법
- 무한 집합 \(S=\{s_0,s_1,\dots\}\)를 골라 **임의의 서로 다른 두 원소** \(s_i\neq s_j\)를 어떤 접미사 \(t\)로 **언어 membership**에서 구별:
  - \(s_i t\in L\) 이지만 \(s_j t\notin L\) (또는 반대)
- 이렇게 **무한히 많은** 서로 다른 동치류가 있음을 보이면 끝.

장점
- **짧고 명료**한 증명 패턴
- 펌핑보다 실패 케이스 적음(특히 \(ww\), Palindrome 류)

---

## 3. 도구 #3 — 폐포성/호모모피즘으로 “감소(리덕션)”하기

정규 언어 계층은 많은 연산에 대해 닫혀 있습니다(합/교/차/여/역상 등).
이를 이용해 **알려진 비정규 언어**로 문제를 “축소”합니다.

자주 쓰는 패턴
- **교집합**: \( L' = L \cap R \) (여기서 \(R\)은 정규) → \(L'\)이 비정규면 \(L\)도 비정규
- **호모모피즘 \(h\)**: \(h(L)\)이 비정규면 \(L\)도 비정규
- **역호모모피즘 \(h^{-1}\)**: \(h^{-1}(L)\) 비정규면 \(L\)도 비정규

---

## 4. 증명 패턴 요약표

| 상황/패턴 | 추천 도구 | 한 줄 요령 |
|---|---|---|
| \(a^n b^n\), 균형/동등 카운트 | 펌핑 or Myhill–Nerode | 초반 루프 늘리면 불균형, 또는 \(a^i\)로 구별 |
| \(ww\), Palindrome | **Myhill–Nerode** 강추 | 접미사로 좌/우 절반을 강제로 비교 |
| 복잡한 수열 길이(\(n^2\), 소수 등) | Myhill–Nerode / 리덕션 | 길이 기반 접미사로 구별, 또는 정규 집합과 교집합 |
| 구조가 보이면 리덕션 가능 | 폐포성/호모모피즘 | 정규 언어와 교집합해 \(a^n b^n\) 등으로 떨어뜨리기 |

---

## 5. 대표 예제 — 정석 해설

### 5.1 \( L=\{a^n b^n \mid n\ge 0\} \) 비정규

**펌핑 보조정리**
- 가정: 정규, 펌핑 길이 \(p\)
- \(w=a^p b^p\) 선택
- \(|xy|\le p\) → \(x,y\)는 **전부 \(a\)**
- \(y=a^m (m\ge 1)\)를 0번 펌핑: \(xy^0z=a^{p-m} b^p\notin L\)
- 모순 ⇒ 비정규

**Myhill–Nerode** (더 짧고 강력)
- \(S=\{a^i \mid i\ge 0\}\)
- \(i\neq j\)에 대해 접미사 \(z=b^i\)를 붙이면 \(a^i b^i\in L\), \(a^j b^i\notin L\)
- 무한히 많은 서로 다른 동치류 ⇒ 비정규

---

### 5.2 \( L=\{ ww \mid w\in\{a,b\}^*\} \) 비정규

**펌핑 보조정리(가능하나 번거로움)**
- \(w=a^p a^p\) 같은 길이로 잡아도 분해 케이스별로 까다로움

**Myhill–Nerode(권장)**
- \(S=\{ a^n \mid n\ge 0\}\)
- \(i\neq j\)에 대해 접미사 \(z = a^i\)를 붙이면
  - \(s_i z = a^i a^i \in L\)
  - \(s_j z = a^j a^i \notin L\) (좌/우 길이 다름)
- 무한 동치류 ⇒ 비정규

---

### 5.3 Palindrome \( L=\{ w w^R \} \) 비정규(알파벳 ≥ 2)

**Myhill–Nerode**
- \(s_n=a^n\) 집합을 잡고 접미사로 \(b a^n\) 등을 붙여 구별
- 또는 정규언어 \(R=(a+b)^* b (a+b)^*\)과 교집합/호모모피즘으로
  중간에 \(b\)가 반드시 위치하도록 만든 뒤 좌우 대칭성으로 구별
- 동일 전략으로 무한 동치류 ⇒ 비정규

---

### 5.4 \( L=\{ a^p \mid p \text{는 소수}\} \) 비정규 스케치

- 정규 언어와의 **교집합**/**모듈러 주기성** 논변, 또는 Myhill–Nerode로
  길이 기반 구별 접미사(또는 곱셈적 구조) 설계
- 정규라면 길이에 대해 **유한 주기성**(Ultimately periodic)이 성립해야 하나, 소수 집합은 이 패턴과 충돌

---

## 6. 자주 하는 실수 & 팁

- **펌핑 문자열 \(w\)를 너무 짧게** 잡음 → \(|w|\ge p\) 필수, 구조 강조 필요
- “**존재하는 분해**” 착각: 펌핑 정리는 **모든** 합법 분해에 대해 성립해야 →
  **모든** \((x,y,z)\)을 상대가 고른다고 생각하고 **하나의 i**로 깨기
- 펌핑으로 애매하면 **Myhill–Nerode**로 전환(특히 \(ww\)/Palindrome 계열)

---

## 7. 퀵 체크리스트(현업 감각)

- **양쪽을 비교**해야 하는가? (동일 개수, 거울) → **비정규 후보**
- **먼 과거 정보**가 필요? (임의 길이 뒤에서 조건 확인) → **비정규 후보**
- 정규 \(R\)과 교집합/호모모피즘으로 **\(a^n b^n\)** 류로 떨어뜨릴 수 있는가? → **Done**
- 펌핑이 복잡? → **Myhill–Nerode** 시도

---

## 8. 실전 예제 모음(간단 증명 스케치 포함)

1) \( \{ a^n b^n c^n \} \): 세 구간 동등 카운트 → PDA(스택 1개)로도 불가(비CFL), 당연히 비정규
2) \( \{ w\in\{a,b\}^* \mid \#a(w)=\#b(w) \} \): 전역 동등 → 펌핑 또는 Myhill–Nerode
3) \( \{ a^{n^2} \} \): 길이 제약 비주기 → Myhill–Nerode/리덕션
4) \( \{ ww^R \} \): palindrome → Myhill–Nerode로 무한 동치류

---

## 9. 교육용 코드 — 펌핑 분해 시뮬레이터 & Myhill–Nerode 구별 힌트

> 목적: **정규/비정규를 자동 판정**하려는 게 아니라,
> 학생이 선택한 \(p,w\)에 대해 **분해 케이스를 체계적으로 훑어보며**
> “깨지는 i”를 찾는 **훈련/시연용**.

### 9.1 펌핑 시뮬레이터 (언어 함수를 넣어 실험)

```python
# pumping_simulator.py
# 교육용: 펌핑 정리의 분해(x,y,z)와 i값을 실험해보며 "깨지는" 예를 찾는다.
# 주의: 정규성 판정기가 아님. 특정 언어 predicate를 사용자가 정의.

from typing import Callable, List, Tuple

def all_splits(w: str, p: int):
    # 모든 (x,y,z) with |xy|<=p, |y|>=1
    n = len(w)
    for i in range(0, min(p, n)+1):     # i = |x|
        for j in range(1, min(p - i, n - i) + 1):  # j = |y| >= 1
            x = w[:i]
            y = w[i:i+j]
            z = w[i+j:]
            yield (x, y, z)

def pump(x: str, y: str, z: str, i: int) -> str:
    return x + (y * i) + z

def witness_breaks_language(
    w: str, p: int, lang_pred: Callable[[str], bool],
    i_candidates = [0,2,3,5]
) -> List[Tuple[Tuple[str,str,str], int, str]]:
    """
    w, p가 주어졌을 때 가능한 (x,y,z) 분해와 i 후보들 중
    lang_pred를 깨뜨리는(언어 밖으로 나가는) 예시들을 나열
    """
    out = []
    for xyz in all_splits(w, p):
        x,y,z = xyz
        for i in i_candidates:
            pumped = pump(x,y,z,i)
            if not lang_pred(pumped):
                out.append((xyz, i, pumped))
    return out

# ===== 예시 언어 =====

def L_anbn(s: str) -> bool:
    # L = {a^n b^n}
    # 간단 체크: a* b* 형태이며 a/b 개수 같음
    n = len(s)
    i = 0
    while i < n and s[i] == 'a': i += 1
    j = i
    while j < n and s[j] == 'b': j += 1
    # a* b*여야 함
    if j != n:
        return False
    a_cnt = i
    b_cnt = n - i
    return a_cnt == b_cnt

def L_ww(s: str) -> bool:
    # L = { ww | w in {a,b}* }
    n = len(s)
    if n % 2: return False
    half = n // 2
    return s[:half] == s[half:]

if __name__ == "__main__":
    # 펌핑 길이 p를 가정하고 w를 골라 실험
    p = 5
    w1 = 'a' * p + 'b' * p          # a^p b^p
    w2 = 'a' * p + 'a' * p          # a^(2p) in {ww}

    print("== L = {a^n b^n} ==")
    bads1 = witness_breaks_language(w1, p, L_anbn)
    for (x,y,z), i, pumped in bads1[:5]:
        print(f"split x={x!r}, y={y!r}, z={z!r}, i={i} -> {pumped!r} in L? {L_anbn(pumped)}")

    print("\n== L = {ww} ==")
    bads2 = witness_breaks_language(w2, p, L_ww)
    for (x,y,z), i, pumped in bads2[:5]:
        print(f"split x={x!r}, y={y!r}, z={z!r}, i={i} -> {pumped!r} in L? {L_ww(pumped)}")
```

**어떻게 쓰나?**
- 내가 선택한 \(p,w\)에 대해 **가능한 모든 분해**와 몇 개의 \(i\) 후보(0,2,3,5…)를 훑습니다.
- “언어 밖”으로 튀는 경우를 출력해 **감각적으로 확인**합니다.
- 교육용: *모든* \(i\)를 검사하는 게 아니라 *대표* \(i\) 후보로 시연합니다.

---

### 9.2 Myhill–Nerode “구별자” 힌트 도우미(유한 깊이 버전)

> 무한 동치류를 **완전히** 증명하는 도구는 될 수 없지만,
> 작은 길이에서 **구별 접미사**를 자동으로 찾아 **직관**을 제공.

```python
# mn_distinguish_hints.py
# 주어진 언어 predicate과 표본 문자열 집합 S에 대해,
# 길이 제한 K까지의 접미사 t를 시도하여 서로 구별되는 쌍을 찾아준다.

from itertools import product
from typing import Callable, List, Tuple

def distinguish_pairs(S: List[str], alphabet: List[str], lang_pred: Callable[[str], bool], K: int = 4):
    """
    반환: (s_i, s_j, t) 리스트
      - t는 길이<=K인 접미사
      - lang_pred(s_i + t) != lang_pred(s_j + t)
    """
    Ts = ['']
    for k in range(1, K+1):
        for tup in product(alphabet, repeat=k):
            Ts.append(''.join(tup))
    out = []
    for i in range(len(S)):
        for j in range(i+1, len(S)):
            si, sj = S[i], S[j]
            for t in Ts:
                if lang_pred(si + t) != lang_pred(sj + t):
                    out.append((si, sj, t))
                    break
    return out

# ===== 예시 언어 =====

def L_anbn(s: str) -> bool:
    n = len(s)
    i = 0
    while i < n and s[i] == 'a': i += 1
    j = i
    while j < n and s[j] == 'b': j += 1
    if j != n:
        return False
    a_cnt = i
    b_cnt = n - i
    return a_cnt == b_cnt

if __name__ == "__main__":
    S = [ 'a'*k for k in range(6) ]   # {ε, a, aa, ...}
    alphabet = ['a','b']
    hints = distinguish_pairs(S, alphabet, L_anbn, K=4)
    for si, sj, t in hints[:6]:
        print(f"distinguish: {si!r} vs {sj!r} with t={t!r} -> {L_anbn(si+t)} vs {L_anbn(sj+t)}")
```

**사용 팁**
- \(S\)를 점점 늘리면 **구별되는 쌍이 계속** 나타나는 경향을 관찰
- 이 직관을 바탕으로 **수학적 일반화**(모든 \(i\neq j\)에 대해 …)를 작성 → 정식 증명 완성

---

## 10. 케이스 스터디 — 폐포성/호모모피즘 리덕션

### 10.1 교집합으로 \(a^n b^n\)로 떨어뜨리기
언어 \( L=\{ x\in \{a,b,c\}^* \mid \#a(x)=\#b(x)\} \)가 정규라고 가정.
정규 \(R=a^* b^* \)와 교집합 \(L\cap R = \{a^n b^n\}\)은 **비정규**.
정규 계층은 교집합에 닫혀 있으므로 모순 ⇒ \(L\) 비정규.

### 10.2 호모모피즘으로 단순화
\(h:\{0,1\}^* \to \{a,b\}^*\) 를 \(h(0)=a, h(1)=b\)라 두고
\(L'=\{ww\}\)가 정규라면 \(h(L')=\{ww\}\) (알파벳만 바뀜)도 정규여야 하지만 비정규와 충돌.

---

## 11. 연습 문제(스스로 증명 써보기)

1) \( \{ a^i b^j \mid i=j \text{ 또는 } i=2j \} \) 가 비정규임을 보이기
   - 힌트: 정규 \(a^* b^*\)와 교집합으로 \(a^n b^n \cup a^{2n} b^n\)로 만든 뒤,
     더 정규와의 연산/역상/호모모피즘으로 **\(a^n b^n\)**을 꺼내기

2) \( \{ w\in\{a,b\}^* \mid w=w^R \} \) (짝 palindrome) 비정규
   - Myhill–Nerode: \(a^i, a^j\)를 접미사로 구별

3) \( \{ a^{n^2} \} \) 비정규
   - 길이 기반 주기성 불가 논변(Myhill–Nerode) 스케치

---

## 12. 마무리 요약

- **펌핑 보조정리**: 초반 루프 **늘려도** 언어 내부여야 → 늘리면 깨지면 비정규
- **Myhill–Nerode**: **무한 구별류**를 보여라 → 가장 깔끔, \(ww\)/Palindrome에 강력
- **폐포성/호모모피즘**: 이미 아는 비정규 언어로 **감소**하라
- 실무 감각: **대칭/균형/거울/전역 의존** → **비정규 신호**.
  펌핑이 꼬이면 **Myhill–Nerode**로 갈아타기.

---

### 참고: 수식 모음

- 펌핑 정리 조건
  $$
  \exists p>0,\ \forall w\in L\ (|w|\ge p)\Rightarrow \exists x,y,z:\
  \begin{cases}
  w=xyz\\
  |xy|\le p,\ |y|\ge 1\\
  \forall i\ge 0:\ xy^i z \in L
  \end{cases}
  $$
- Myhill–Nerode 동치
  $$
  x \equiv_L y \iff \forall z\in \Sigma^\*:\ (xz\in L)\Leftrightarrow (yz\in L)
  $$
  \(L\) 정규 ⇔ \(\Sigma^\*/\!\equiv_L\) 의 동치류가 **유한**.
