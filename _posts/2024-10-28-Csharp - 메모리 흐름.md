---
layout: post
title: C# - 메모리 흐름
date: 2024-10-28 19:20:23 +0900
category: Csharp
---
# C# 메서드 호출 시 메모리 흐름과 성능 최적화 키워드

## 0) 한 장 요약

- **스택 프레임**: 호출 시 매개변수/지역/리턴주소/저장 레지스터가 스택에 쌓이고 **LIFO**로 해제.
- **값 전달**: 기본은 **값 복사**. **큰 struct**는 비용↑ → `in`(읽기 전용 참조) 사용 고려.
- **참조 전달**: `ref`(읽기/쓰기), `out`(메서드에서 반드시 할당), `in`(읽기 전용, 복사 방지).
- **Span 계열**: `Span<T>`(읽기/쓰기), `ReadOnlySpan<T>`(읽기), **스택/힙/네이티브** 어느 메모리든 **슬라이스로 뷰**.  
  문자열/배열/네이티브 버퍼를 **할당 없이** 다루기.
- **stackalloc**: 스택에 연속 버퍼를 즉석 할당. **빠르고 0 GC**, 수명은 **현재 스코프**.
- **ref struct**: 힙 금지, 스택/스팬 안전성 모델(예: `Span<T>`). **비동기/iterator**와 섞을 수 없음.
- **ref return / ref locals**: 호출자에게 **원본 참조**를 돌려 복사 제거 (수명 안전성 주의).
- **scoped**(C# 11+): **수명 제한**을 컴파일러로 표기하여 “스택에서만 유효”를 보장.

---

## 1) 메서드 호출 시 “스택 프레임” 해부

### 1.1 스택 프레임 구성

| 구성 | 설명 |
|---|---|
| **매개변수** | 호출자가 전달한 값/참조(혹은 ref 슬롯) |
| **지역 변수** | 메서드 내부 `T x;` 등 |
| **저장 레지스터/프롤로그/에필로그** | 호출 규약에 따른 보존 |
| **리턴 주소** | 호출 완료 후 되돌아갈 위치 |

간단 도식:
```
High addr
┌───────────────────────────────┐
│ Caller Frame …                │
├───────────────────────────────┤
│ Return Address                │ ← callee가 완료되면 여기로 복귀
│ Saved Registers               │
│ Parameters (by value / by ref)│
│ Locals                        │
└───────────────────────────────┘
Low addr
```

**특징**  
- 프레임은 호출 시 **푸시**, 종료 시 **팝**.  
- 스택은 **스레드별**로 존재. 스택 크기 초과 시 **StackOverflowException**.

---

## 2) 값 전달과 참조 전달: `ref / in / out`

### 2.1 비교 표

| 키워드 | 의미 | 읽기 | 쓰기 | 호출 전 초기화 | 메서드 내 요구 |
|---|---|---|---|---|---|
| *(기본)* | 값 복사 | 가능 | 변경은 **로컬 복사본** | 필요 없음 | 없음 |
| `ref` | 참조로 전달 | 가능 | 가능(원본 수정) | **필수** | 없음 |
| `out` | 출력 전용 참조 | (쓰려면 읽을 수 있어야 하므로) 읽기는 **의미 없음** | **필수 할당** | 불필요 | **반드시 할당** |
| `in` | 읽기 전용 참조 | 가능 | **불가** | **필수** | 내부 수정 불가(컴파일 검증) |

### 2.2 예제: 복사 비용 줄이기 (`in`)

```csharp
public readonly struct Matrix4
{
    public readonly double M11, M12, M13, M14;
    public readonly double M21, M22, M23, M24;
    public readonly double M31, M32, M33, M34;
    public readonly double M41, M42, M43, M44;
    public Matrix4(double v) =>
        (M11, M12, M13, M14,
         M21, M22, M23, M24,
         M31, M32, M33, M34,
         M41, M42, M43, M44) = (v,v,v,v, v,v,v,v, v,v,v,v, v,v,v,v);
}

// 기본: 값 복사(64바이트 이상이면 비용↑)
double Trace(Matrix4 m) => m.M11 + m.M22 + m.M33 + m.M44;

// 최적화: 읽기전용 참조 전달 → 복사 방지
double Trace(in Matrix4 m) => m.M11 + m.M22 + m.M33 + m.M44;
```

> `in`은 **읽기-only**라 내부에서 필드 변경이 불가능. **크고 불변**인 struct에 적합.

### 2.3 예제: 원본 수정 (`ref` / `out`)

```csharp
void AddOne(ref int x) => x += 1;

bool TryParseHex(ReadOnlySpan<char> s, out int value)
{
    value = 0;
    foreach (var c in s)
    {
        int v = c switch
        {
            >= '0' and <= '9' => c - '0',
            >= 'A' and <= 'F' => c - 'A' + 10,
            >= 'a' and <= 'f' => c - 'a' + 10,
            _ => -1
        };
        if (v < 0) return false;
        value = (value << 4) | v;
    }
    return true;
}
```

---

## 3) `stackalloc` + `Span<T>`: 스택 버퍼, 0 할당

### 3.1 기본 사용

```csharp
Span<int> tmp = stackalloc int[8]; // 스택 프레임에 8개 int 버퍼
for (int i = 0; i < tmp.Length; i++) tmp[i] = i * i;
Console.WriteLine(tmp[3]); // 9
```

- **장점**: 힙 할당 없음(GC 압박 0), 매우 빠름
- **수명**: 현재 메서드 프레임까지만. 반환/비동기에서 **보낼 수 없음**

### 3.2 초기화 문법/슬라이싱

```csharp
Span<byte> buf = stackalloc byte[] { 1, 2, 3, 4, 5 };
var head = buf[..2];     // 1,2
var tail = buf[2..];     // 3,4,5
```

### 3.3 문자열 파싱/직렬화에 응용

```csharp
ReadOnlySpan<char> line = "42,100,7".AsSpan();
int firstComma = line.IndexOf(',');
int secondComma = line[(firstComma+1)..].IndexOf(',') + firstComma + 1;

int a = int.Parse(line[..firstComma]);
int b = int.Parse(line[(firstComma+1)..secondComma]);
int c = int.Parse(line[(secondComma+1)..]);
```

- **임시 문자열**을 만들지 않고 **슬라이스**만으로 파싱 → **할당 제거**.

---

## 4) `Span<T>` / `ReadOnlySpan<T>` 제대로 쓰기

### 4.1 특징 요약

| 타입 | 읽기 | 쓰기 | 힙 필드 | 비동기/iterator | 변환 |
|---|---|---|---|---|---|
| `Span<T>` | O | O | **불가(ref struct)** | **불가** | 배열/문자열/네이티브 |
| `ReadOnlySpan<T>` | O | X | **불가** | **불가** | 문자열/읽기 전용 뷰 |

**중요 제약**: `ref struct`이므로 **필드/클래스 멤버 불가**, 비동기 상태머신/iterator에 **포획 금지**.

### 4.2 문자열 & 배열 & 네이티브 변환

```csharp
ReadOnlySpan<char> s1 = "Hello".AsSpan(); // 문자열 → ROSpan<char>
Span<int> s2 = new int[10];               // 배열 → Span<int>

unsafe
{
    int* p = stackalloc int[4];
    Span<int> s3 = new Span<int>(p, 4);   // 네이티브 포인터 → Span
}
```

### 4.3 `Span<T>` 기반 API 디자인

```csharp
// 입력을 RO-Span으로, 출력 버퍼를 Span으로 받는 Try 패턴
public static bool TryWriteUtf8(ReadOnlySpan<char> src, Span<byte> dst, out int written)
{
    written = 0;
    foreach (char ch in src)
    {
        if (written >= dst.Length) return false;
        dst[written++] = (byte)(ch <= 0xFF ? ch : '?');
    }
    return true;
}
```

- 호출자에게 **출력 버퍼 소유권**을 맡겨 **할당 제로**.
- 실패 시 **false**로 알려 **예외 비용** 회피(핫패스 최적화 관용구).

---

## 5) `ref struct`와 수명 규칙

### 5.1 정의

```csharp
ref struct Cursor
{
    private ReadOnlySpan<char> _s;
    private int _i;
    public Cursor(ReadOnlySpan<char> s) => (_s, _i) = (s, 0);
    public bool TryRead(out char c)
    {
        if (_i >= _s.Length) { c = default; return false; }
        c = _s[_i++]; return true;
    }
}
```

**제약**  
- 힙에 둘 수 없음(필드 불가)  
- `async`/`yield`와 함께 사용 불가  
- 박싱 불가/인터페이스 구현 불가(원칙적으로)

> 이유: `Span<T>`/`ref struct`의 **스택 수명 보장** 모델을 깨면 **Use-After-Free** 위험.

---

## 6) `readonly struct`와 불변 설계

```csharp
public readonly struct Point2D(int x, int y)
{
    public int X { get; } = x;
    public int Y { get; } = y;
    public override string ToString() => $"({X},{Y})";
}
```

- **필드 불변** → 컴파일러가 **방어적 복사**를 줄임  
- 값 타입의 **의미/추론 안정성**이 커져 **JIT 최적화** 유리

---

## 7) `ref locals` / `ref return`: 복사 제거

### 7.1 원소 참조 반환

```csharp
ref int FindOrAdd(ref int[] arr, int value)
{
    for (int i = 0; i < arr.Length; i++)
        if (arr[i] == value) return ref arr[i];

    // 못 찾으면 끝 원소를 반환(데모용)
    return ref arr[^1];
}

var a = new[] { 1, 2, 3, 4 };
ref int slot = ref FindOrAdd(ref a, 2);
slot = 20;               // 원본 배열 수정
Console.WriteLine(a[1]); // 20
```

- **주의**: 반환된 `ref`가 **유효 수명**을 갖는지(원본 컬렉션이 살아있는지) 보장 필요.

### 7.2 `scoped`로 수명 제한 (C# 11+)

```csharp
public static scoped ref T Head<T>(Span<T> s) => ref s[0];
```

- 호출자 쪽으로 **힙 수명으로 확장**되는 것을 **컴파일러가 차단**.  
- “스택 범위에서만” 사용하도록 **정적 보장**.

---

## 8) 고성능 문자열/버퍼 처리 레시피

### 8.1 CSV 라인 파싱 (무할당)

```csharp
public static bool TryParse3(ReadOnlySpan<char> line, out int a, out int b, out int c)
{
    a = b = c = 0;
    int i1 = line.IndexOf(',');
    if (i1 < 0) return false;
    int i2 = line[(i1+1)..].IndexOf(',');
    if (i2 < 0) return false;
    i2 += i1 + 1;

    return int.TryParse(line[..i1], out a)
        && int.TryParse(line[(i1+1)..i2], out b)
        && int.TryParse(line[(i2+1)..], out c);
}
```

- **임시 substring 할당 없음**  
- `ReadOnlySpan<char>`로 **입력 슬라이스**만 이동

### 8.2 Base64 디코드 (버퍼 사전 크기 계산)

```csharp
public static bool TryBase64Decode(ReadOnlySpan<char> src, Span<byte> dst, out int written)
{
    written = 0;
    int needed = (src.Length / 4) * 3;
    if (dst.Length < needed) return false;

    // 실제 디코드 루프(간략화)
    foreach (char ch in src)
    {
        // 변환 로직 …(생략)…
    }
    written = needed;
    return true;
}
```

- **예상 출력 크기를 미리 계산**해, 호출자가 적절한 버퍼를 준비 → **예외/할당 제로** 패턴.

---

## 9) JIT/런타임 관점의 미세 최적화 팁

### 9.1 인라이닝 힌트
```csharp
[MethodImpl(MethodImplOptions.AggressiveInlining)]
static int FastAdd(int a, int b) => a + b;
```
- 짧은 메서드/핫패스에 유리. (항상 보장되진 않음)

### 9.2 제로 초기화 생략(고급/주의)
```csharp
[SkipLocalsInit] // .NET 5+; 로컬 제로화 생략(보안/안정성 주의)
static void HotLoop() { Span<byte> tmp = stackalloc byte[256]; /* … */ }
```
- **안전성/보안 트레이드오프**. 반드시 성능 이득과 위험을 평가.

### 9.3 예외 vs Try 패턴
- **핫 루프에서는** 예외 대신 `TryXxx`로 실패를 bool로 리턴.  
- 예외는 **비용 높고 스택 트레이스 생성**.

### 9.4 박싱/언박싱 제거
- 비제네릭 컬렉션, `IComparable` 박싱 경로 제거 → **제네릭**/`Comparer<T>` 사용.

---

## 10) 함정과 금지 패턴

1) **`Span<T>`를 필드에 보관**: ❌ (ref struct → 힙 금지)  
2) **`Span<T>` 포획해서 `async`로 넘기기**: ❌ (상태머신 힙 전환)  
3) **`stackalloc` 버퍼를 return/ref return**: ❌ (프레임 종료 후 무효)  
4) **큰 struct 반복 복사**: ❌ (`in`/`ref` 고려, `readonly struct` 활용)  
5) **출력 버퍼 부족 시 예외 던지기**: ❌ (핫패스에서는 `Try` + `bool` 반환)

---

## 11) 벤치 힌트: 복사 비용 모델

복사 대상이 값 타입(struct)이고 크기가 \( S \) 바이트, 호출 빈도 \( N \)이라면 **이상화된 총 복사량**은
$$
\text{TotalCopy} \approx N \cdot S
$$

- \(S\)가 수십~수백 바이트면 루프에서 **눈에 띄는 차이**가 발생.  
- `in`/`ref` 전달, `ref return`로 **복사량을 0에 가깝게** 만들 수 있다.  
- 단, **가독성/안전성**과의 균형을 잡을 것.

---

## 12) 종합 예제: 무할당 소문자 변환 + 숫자 파싱

```csharp
using System;
using System.Runtime.CompilerServices;

public static class Fast
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static char ToLowerAscii(char c)
        => (c is >= 'A' and <= 'Z') ? (char)(c + 32) : c;

    // 입력: ReadOnlySpan<char>, 출력: 호출자 버퍼(Span<char>)
    public static bool TryLowerAndParse(ReadOnlySpan<char> src, Span<char> lowerOut, out int number)
    {
        number = 0;
        if (lowerOut.Length < src.Length) return false;

        for (int i = 0; i < src.Length; i++)
            lowerOut[i] = ToLowerAscii(src[i]);

        // 쉼표로 분리된 마지막 토큰을 숫자로 파싱
        int lastComma = lowerOut[..src.Length].LastIndexOf(',');
        ReadOnlySpan<char> token =
            lastComma >= 0 ? lowerOut[(lastComma+1)..src.Length] : lowerOut[..src.Length];

        return int.TryParse(token, out number);
    }
}

public class Demo
{
    public static void Main()
    {
        ReadOnlySpan<char> input = "HELLO,123".AsSpan();
        Span<char> tmp = stackalloc char[input.Length];
        if (Fast.TryLowerAndParse(input, tmp, out int n))
        {
            Console.WriteLine(tmp.ToString()); // hello,123
            Console.WriteLine(n);              // 123
        }
    }
}
```

- 입력은 `ReadOnlySpan<char>`로 **무할당**  
- 출력 버퍼는 호출자가 제공(스택 `stackalloc` 가능)  
- 최종 문자열이 꼭 필요하면 **마지막 한 번만** `ToString()` (필요 없으면 끝까지 무할당)

---

## 13) 체크리스트 (실전 적용)

- [ ] **큰 struct**를 자주 전달하나? → `in`/`ref` 고려, `readonly struct` 설계  
- [ ] 문자열/바이트 처리에 **Span/ReadOnlySpan** 사용 가능한가?  
- [ ] **임시 substring/ToArray** 남발하지 않는가? → 슬라이싱/`Try` 패턴  
- [ ] **stackalloc**으로 작은 일시 버퍼를 만들 수 있는 지점은? (수백~수천 바이트 이내)  
- [ ] `ref return`/`ref locals`로 **복사 제거** 가능한가? (수명 안전성 확인)  
- [ ] `AggressiveInlining`/`Try`-style로 **핫패스 잡음** 줄이기  
- [ ] `scoped` 키워드로 **수명 누수**를 컴파일 타임에 차단 가능한가?

---

## 14) 부록: 고급 문법 & API 스니펫

### 14.1 `scoped` 매개변수로 수명 제약
```csharp
public static void UseBuffer(scoped Span<byte> buf)
{
    // buf는 호출자 스택 범위 안에서만 유효
}
```

### 14.2 `ref readonly` 반환 (읽기 전용 참조)
```csharp
public static ref readonly T First<T>(ReadOnlySpan<T> s) => ref s[0];
```

### 14.3 `Unsafe` 유틸(고급/주의)
```csharp
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

ref byte FirstByte<T>(ref T value) where T : unmanaged
    => ref Unsafe.As<T, byte>(ref value);

Span<byte> AsBytes<T>(ref T value) where T : unmanaged
    => MemoryMarshal.AsBytes(MemoryMarshal.CreateSpan(ref value, 1));
```
> 안전성 검증이 약하므로 **철저한 테스트/검토** 필수.

---

## 15) 마무리

- 메서드 호출의 **메모리 흐름**을 이해하면 “왜 `ref/in/out`/`Span`이 빠른지”가 보인다.  
- “무조건 빠른 문법”은 없다. **데이터 크기/호출 빈도/안전성/가독성**을 함께 고려하자.  
- 성능은 **측정**으로만 증명된다. `BenchmarkDotNet`이나 `dotnet-counters`로 **근거**를 확보하고 적용하라.
