---
layout: post
title: MFC - 전력·스케줄링
date: 2025-09-22 23:25:23 +0900
category: MFC
---
# 전력·스케줄링 심화  
**백그라운드 작업의 Energy-Aware Scheduling, Connected/Modern Standby 고려 가이드 (Win32/MFC 중심, UWP/패키지앱 병행 팁)**

> 목표: **배터리 수명·발열·성능**의 균형을 무너뜨리지 않으면서, 백그라운드 동기화/다운로드/색인 같은 작업을 **에너지 친화적(Energy-Aware)** 으로 설계·구현하는 법을 끝까지 정리.  
> 대상: 전통 Win32/MFC 앱 + (있다면) **MSIX 패키징/데스크톱 브릿지** 환경. UWP Background Task/WinRT API는 “옵션”으로 병행 설명.

---

## 0. 큰 그림: 전력 모델과 우리가 만질 수 있는 레버(레시피 먼저)

### 핵심 원칙 10가지
1) **타이머 분할/합치기**: 낮은 해상도(기본 15.6ms) 유지, **coalescable timers** 사용. `timeBeginPeriod(1)` 금지.  
2) **우선순위·백그라운드 모드**: CPU/메모리/디스크 **백그라운드 우선순위**로 내려서 OS가 병합/지연 스케줄링하도록.  
3) **I/O는 ‘천천히, 크게’**: 작은 랜덤 I/O 폭탄 대신 **배치·순차·큰 청크**. **Background I/O 힌트** 설정.  
4) **네트워크는 BITS/DO**: 직접 `WinInet/WinHTTP`로 폴링하지 말고 **BITS**(Background Intelligent Transfer Service)로 전송/다운로드를 맡김.  
5) **Power Throttling** 준수: 기본은 **스로틀 허용**. 정말 필요한 짧은 구간만 **해제**.  
6) **Battery Saver/Costed Network 감지**: 배터리 절약 모드·유료 네트워크에서 자동으로 더 느슨하게/연기.  
7) **Connected/Modern Standby**: **장시간 CPU 유지 금지**. 필요 시 **Push(푸시)**, **백그라운드 트리거**(패키지앱), **짧은 유지 요청(PowerSetRequest)**.  
8) **절전/재개 알림 처리**: Suspend/Resume 알림에서 안전 저장·타이머 취소·재스케줄.  
9) **ETW로 실제 측정**: E3(에너지 추정)·Kernel-Power·Timer 해상도 등 **WPA 분석**으로 수치 확인.  
10) **사용자 제어**: “배터리일 때 느리게 동기화”, “절전 중 백그라운드 금지” 같은 옵션 제공.

---

## 1. 타이머·스케줄링: “덜 자주, 뭉쳐서, 동기화해서”

### 1.1 타이머 해상도: timeBeginPeriod(1) 금지
- 시스템 타이머 해상도를 1ms로 내리면 **모든 프로세스가** 더 자주 깨어나 배터리가 급격히 줄어듭니다.  
- 가능한 **기본 해상도(≈ 15.6ms)** 를 유지하고, 오디오/실시간 필수 구간만 **MMCSS** 또는 하이레졸루션 API 사용.

### 1.2 Coalescable Timer 사용
- **SetWaitableTimerEx**(Win32), **ThreadPool Timer**(SetThreadpoolTimer)에서 **허용 윈도우**를 주면 OS가 **인접 타이머와 합쳐서** 깨어남(웨이크업 횟수 저감).

```cpp
// (Win32) 저전력 친화적 주기 타이머: SetWaitableTimerEx + TolerableDelay
HANDLE hTimer = CreateWaitableTimerEx(nullptr, L"bg_coalesced", CREATE_WAITABLE_TIMER_HIGH_RESOLUTION, TIMER_ALL_ACCESS);
// 만약 고해상도 불필요하면 HIGH_RESOLUTION 빼세요.

LARGE_INTEGER due = {};           // 처음 5초 뒤
due.QuadPart = -5 * 10'000'000LL; // 100ns 단위, 음수는 상대시간
LONG periodMs = 60'000;           // 60초 주기
REASON_CONTEXT rc = {};
rc.Version = POWER_REQUEST_CONTEXT_VERSION;
rc.Flags = POWER_REQUEST_CONTEXT_SIMPLE_STRING;
rc.SimpleReasonString = L"Background sync timer";

BOOL ok = SetWaitableTimerEx(
    hTimer,
    &due,
    periodMs,
    nullptr, nullptr,
    &rc,
    5000 /* tolerable delay (ms): 최대 5초까지 OS가 합쳐 깨어나도 됨 */
);

while (WaitForSingleObject(hTimer, INFINITE) == WAIT_OBJECT_0) {
    // 배치 동기화 작업 수행 (짧고 굵게)
    RunBatchSync();
    // 절대 오래 점유하지 말 것!
}
```

```cpp
// (ThreadPool Timer) 윈도우(슬랙) 부여 — 깨어남 합치기
PTP_TIMER t = CreateThreadpoolTimer([](PTP_CALLBACK_INSTANCE, PVOID ctx, PTP_TIMER) {
    static_cast<MyScheduler*>(ctx)->RunBatchSync();
}, this, nullptr);

FILETIME ftDue = {}; // 5초 뒤
ULONGLONG now100ns = GetTickCount64() * 10'000ULL;
ULONGLONG due100ns = now100ns + 5*10'000'000ULL;
ftDue.dwLowDateTime  = (DWORD)due100ns;
ftDue.dwHighDateTime = (DWORD)(due100ns >> 32);

// SetThreadpoolTimer는 '윈도우'를 ms로 받을 수 있음(Windows 8.1+)
SetThreadpoolTimer(t, &ftDue, 60'000 /*주기*/, 5000 /*tolerable delay*/);
```

### 1.3 작업 배치(Work Batching)
- 타이머·네트워크·디스크 작업을 **동일 시점 근처**로 모읍니다.  
- 주기적 작업은 **Minute 단위** 정렬(예: 12:00, 12:05, 12:10 …), 스케줄러가 많은 프로세스의 웨이크업을 정렬해 줌.

---

## 2. 백그라운드 모드·우선순위·Power Throttling

### 2.1 백그라운드 프로세스/스레드 모드
- **PROCESS_MODE_BACKGROUND_BEGIN/END**(SetPriorityClass)로 프로세스를 배경으로 전환하면  
  **CPU/메모리/디스크/네트워크 우선순위**가 내려가 OS가 적절히 완화합니다.

```cpp
// 프로세스 전체를 백그라운드 모드로 (작업 시작~끝 구간만)
SetPriorityClass(GetCurrentProcess(), PROCESS_MODE_BACKGROUND_BEGIN);
// ... 백그라운드 작업 수행 ...
SetPriorityClass(GetCurrentProcess(), PROCESS_MODE_BACKGROUND_END);
```

- 부분적으로는 **스레드·I/O 우선순위**를 내립니다.

```cpp
// 스레드 우선순위 낮추기
SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);

// I/O 우선 힌트(핸들 단위) — 매우 낮은 우선순위로
FILE_IO_PRIORITY_HINT_INFO info{};
info.PriorityHint = IoPriorityHintVeryLow;
SetFileInformationByHandle(hFile, FileIoPriorityHintInfo, &info, sizeof(info));
```

### 2.2 Power Throttling API
- Windows 10+는 백그라운드 스레드에 **Power Throttling(실행 속도 제한)** 을 적용.  
- 기본은 **허용**이 이롭습니다. **짧은 성능 구간**만 선택적으로 해제.

```cpp
// 프로세스 Power Throttling 비활성(아주 짧은 크리티컬 섹션에서만!)
PROCESS_POWER_THROTTLING_STATE s = {};
s.Version = PROCESS_POWER_THROTTLING_CURRENT_VERSION;
s.ControlMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
s.StateMask   = 0; // 0 = disable throttling of execution speed
SetProcessInformation(GetCurrentProcess(),
                      ProcessPowerThrottling,
                      &s, sizeof(s));

// 스레드 단위도 유사 (ThreadPowerThrottling)
THREAD_POWER_THROTTLING_STATE ts{};
ts.Version = THREAD_POWER_THROTTLING_CURRENT_VERSION;
ts.ControlMask = THREAD_POWER_THROTTLING_EXECUTION_SPEED;
ts.StateMask   = 0;
SetThreadInformation(GetCurrentThread(),
                     ThreadPowerThrottling,
                     &ts, sizeof(ts));
```

> **주의**: Throttling 해제는 “아주 짧게” — 다운로드 병합·압축 계산 등 꼭 필요한 스파이크만.

### 2.3 MMCSS(미디어/시간민감)와의 경계
- 오디오/비디오 렌더링은 **MMCSS** 클래스로 스케줄받아 전력 대비 품질을 최적화.  
- 백그라운드 유틸은 **MMCSS 남용 금지**. 필요 시 **전용 스레드**만 한시적으로 올렸다가 내려놓기.

---

## 3. 네트워크: BITS/DO, 비용인지, 푸시/폴링과 웨이크

### 3.1 BITS(Background Intelligent Transfer Service)
- 네트워크 전송을 BITS에 맡기면 **전력/네트워크 상태/사용자 활동**을 고려한 **절전 친화** 스케줄링이 자동.  
- 배터리 세이버/유료(비용형) 네트워크에서 **제한**을 자동 준수.

```cpp
// (C++) 간단 BITS 업로드/다운로드 예시(요약)
// 1) IBackgroundCopyManager 생성 → Job 만들고 파일 추가
// 2) SetNoProgressTimeout, SetPriority(BG_JOB_PRIORITY_LOW)
// 3) Resume(); 4) 주기적으로 상태 조회 또는 Completion 콜백

CComPtr<IBackgroundCopyManager> mgr;
mgr.CoCreateInstance(__uuidof(BackgroundCopyManager));
GUID jobId{};
CComPtr<IBackgroundCopyJob> job;
mgr->CreateJob(L"MyAppSync", BG_JOB_TYPE_DOWNLOAD, &jobId, &job);

job->AddFile(L"https://cdn.example.com/bundle.dat", L"C:\\Users\\...\\bundle.dat");
job->SetPriority(BG_JOB_PRIORITY_LOW);
job->SetNoProgressTimeout(6*3600); // 6시간 정체면 취소
job->Resume();
// 상태는 별도 스레드/타이머에서 job->GetState()로 폴링 또는 콜백 등록
```

### 3.2 Delivery Optimization(대용량/조직환경)
- 대규모/기업 환경에선 **DO(Delivery Optimization)** 로 대역폭 정책·P2P 등을 활용.  
- 순수 앱 내 구현보다 OS에 맡기는 것이 에너지·네트워크 모두 이득.

### 3.3 비용형 네트워크/배터리 세이버 감지
- Power/네트워크 상태 변화를 **PowerSettingRegisterNotification + Network List Manager**로 구독.  
- **GUID_POWER_SAVING_STATUS**, **GUID_BATTERY_PERCENTAGE_REMAINING** 등을 수신하여 **작업 연기**.

```cpp
// 전력 상태 알림 등록 (GUID_POWER_SAVING_STATUS 등)
HPOWERNOTIFY ghPwr = nullptr;
DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS p = {};
p.Callback = [](PVOID, PVOID ctx) -> ULONG {
    auto* e = reinterpret_cast<PPOWERBROADCAST_SETTING>(ctx);
    if (e->PowerSetting == GUID_POWER_SAVING_STATUS) {
        DWORD on = *(DWORD*)e->Data; // 1=배터리 절약 모드
        g_scheduler->OnBatterySaver(on != 0);
    }
    return 0;
};
PowerRegisterSuspendResumeNotification(DEVICE_NOTIFY_CALLBACK, &p, &ghPwr); // Suspend/Resume
// PowerSettingRegisterNotification은 RegisterPowerSettingNotification(윈도우) 방식도 가능
```

> 네트워크 비용형 여부는 **INetworkCostManager**/NLM API로 확인. 비싼 네트워크면 **미루기**.

### 3.4 푸시 vs 폴링, Connected Standby에서의 웨이크
- **폴링**은 에너지에 치명적. 가능하면 **푸시(Push, WNS/SignalR/WebSocket)** 로 전환.  
- Connected(Modern) Standby에서는 **푸시가 유지**될 수 있고, 이벤트가 올 때만 짧게 깬 뒤 다시 잠듦.

---

## 4. 디스크·메모리: 백그라운드 I/O, 배치, 압축

### 4.1 Background I/O 힌트
- 핸들/스레드에 **낮은 I/O 우선**을 지정 → 적극적인 읽기/쓰기 시에도 사용자 작업을 방해하지 않음(전력에도 유리).

```cpp
// 스레드 I/O 우선 낮추기
THREAD_POWER_THROTTLING_STATE tis = {};
SetThreadInformation(GetCurrentThread(), ThreadPowerThrottling, &tis, sizeof(tis)); // (스레드 실행 스로틀 외)
// 별개로 I/O 우선 힌트는 핸들 기반(위 SetFileInformationByHandle)으로 지정
```

### 4.2 배치·압축·청크 전략
- **작은 파일 다수** 대신 **압축/아카이브**로 묶어 **순차 I/O** 유도.  
- 청크 단위 512 KB 이상으로 읽기/쓰기 → HDD/네트워크 모두 효율적.  
- 캐시가 허용되면 **메모리 맵** + **큰 스트라이드**로 순차 처리, CPU는 **벡터화**로 짧게 끝내기.

---

## 5. 절전/재개: Modern Standby(S0ix) 알림, 유지 요청, 사용 금지 패턴

### 5.1 Modern Standby 개념
- 화면 Off 이후에도 시스템은 **S0 저전력** 상태를 유지(과거 S3 Sleep과 다름).  
- **DRIPS**(Deepest Runtime Idle Platform State)로 깊은 절전, **간헐적 깨어남**(알림/네트워크 유지)만 허용.  
- 길고 무거운 백그라운드 루프는 **금지**: OS가 **BAM(Background Activity Moderator)** 로 제한.

### 5.2 Suspend/Resume 알림 처리
- **PowerRegisterSuspendResumeNotification**(powrprof.h) 또는 `WM_POWERBROADCAST` 로  
  **PBT_APMSUSPEND / PBT_APMRESUMEAUTOMATIC** 등을 받아 **작업 중단/예약 재개**.

```cpp
// 대화상자/프레임의 메시지 맵
ON_MESSAGE(WM_POWERBROADCAST, OnPowerBroadcast)

LRESULT CMainFrame::OnPowerBroadcast(WPARAM wp, LPARAM lp)
{
    switch (wp) {
    case PBT_APMSUSPEND:
        m_scheduler.Pause();        // 타이머/스레드 중단, 상태 플러시
        break;
    case PBT_APMRESUMEAUTOMATIC:
        m_scheduler.ResumeDeferred();// 일정 랜덤 지연 후 재개(스파이크 방지)
        break;
    }
    return TRUE;
}
```

### 5.3 유지 요청(PowerSetRequest) — 필요할 때만, 짧게
- 특정 작업(예: **트랜잭션 커밋/암호화/펌웨어 업데이트**)을 **수십 초** 동안만 **절전 방지**.

```cpp
HANDLE hReq = PowerCreateRequest(&rc); // REASON_CONTEXT 위 예시 재사용
PowerSetRequest(hReq, PowerRequestSystemRequired);

// --- 짧은 크리티컬 섹션 ---
DoCriticalCommit();
// ------------------------

PowerClearRequest(hReq, PowerRequestSystemRequired);
CloseHandle(hReq);
```

> **지양**: “백그라운드 동기화 내내” 유지 요청. 사용자는 절전·배터리 절약을 기대합니다.

### 5.4 패키지(UWP/브릿지)일 때: 백그라운드 태스크
- **Time/Maintenance/Push/SystemTrigger** 를 써서 **OS가 허용하는 시점**에 백그라운드 실행.  
- 연결 대기(Connected Standby) 중에도 **Push/Socket Activity** 등 일부 트리거는 짧은 실행 허용.

```csharp
// (UWP) MaintenanceTrigger 예시 — 전력/리소스 여유 시 실행
var builder = new BackgroundTaskBuilder {
    Name = "Acme.Maintenance",
    TaskEntryPoint = "AcmeTasks.MaintenanceTask"
};
builder.SetTrigger(new MaintenanceTrigger(60 /*분*/, false /*oneShot?*/));
BackgroundTaskRegistration reg = builder.Register();
```

---

## 6. 배터리 세이버/디스플레이 상태/사용자 입력 인지

### 6.1 배터리 세이버: 즉시 더 보수적으로
- 배터리 세이버가 켜지면 **주기 길게**, **네트워크/디스크 배치**만 남기고 **불필요 작업 취소**.

```cpp
// RegisterPowerSettingNotification: GUID_BATTERY_SAVER_OVERRIDE, GUID_POWER_SAVING_STATUS 등
```

### 6.2 화면 Off, 사용자 입력 없음
- **GUID_CONSOLE_DISPLAY_STATE** 로 화면 상태 감지. 화면 Off면 **UI 업데이트/애니메이션 중단**.  
- **마우스/키보드 유휴** 30초 이상일 때만 백그라운드 I/O 시작(사용자 지연 최소화).

---

## 7. 스케줄링 정책 설계(샘플)

### 7.1 동기화 서비스 정책 테이블
| 조건 | 행동 |
|---|---|
| AC 전원 + 화면 On | 1분 주기 폴링, 백그라운드 모드, BITS 우선 |
| 배터리 + 화면 On | 5~10분 주기, 트래픽 50% 제한, 작은 변경만 가져오기 |
| 배터리 세이버 | 폴링 금지, **푸시만** 반응 / 수동 새로고침 권장 |
| 화면 Off(Modern Standby 진입) | 폴링 금지, 푸시/타스크 트리거만 허용 |
| 재개 후 2분 | 지수 백오프(랜덤)로 스파이크 방지, 한 번만 빠른 동기화 |

### 7.2 구현 스니펫: 정책 적용
```cpp
void PowerPolicy::Apply(PowerState s) {
    switch (s) {
    case PowerState::AC_DisplayOn:
        timer->SetPeriod(60'000, slackMs: 5000);
        mode.SetBackground(true);
        net.LimitMbps(0); // 무제한
        break;
    case PowerState::Battery_DisplayOn:
        timer->SetPeriod(6*60'000, slackMs: 10'000);
        mode.SetBackground(true);
        net.LimitMbps(2); // 예: 2Mbps 제한
        break;
    case PowerState::BatterySaver:
        timer->Suspend(); // 폴링 금지
        break;
    case PowerState::DisplayOff_ModernStandby:
        timer->Suspend(); // 폴링 금지
        // Push 이벤트/백그라운드 태스크만
        break;
    }
}
```

---

## 8. ETW/측정: “좋아 보이지만 실제로는 배터리 먹는” 함정을 찾자

### 8.1 주요 프로바이더
- **Microsoft-Windows-Kernel-Power**: 전력 상태/타이머 해상도/클럭 변경  
- **Energy Estimation Engine(E3)**: 프로세스/컴포넌트별 에너지 추정(그래프)  
- **Wininet/WinHTTP/BITS**: 네트워크 패턴 확인  
- **Disk I/O**: 랜덤 vs 순차, 큐 길이, 병합율

### 8.2 워크플로
1) **WPR**(Windows Performance Recorder) 템플릿: “Power”  
2) 사용자 시나리오 5~10분 실행  
3) **WPA** 로 열어 **Wakeups/sec**, **Timer Resolution**, **CPU C-states residency**, **E3 Per-Process Energy** 확인  
4) **웨이크업 레이트 < 50/s**, **타이머 15.6ms**, **E3 상위 소비**의 “이유”를 코드로 추적

---

## 9. Modern Standby에서의 “깨우기” 올바른 패턴

- **WNS/푸시**: 서버가 이벤트 발생 시 **푸시** → OS가 짧게 깨움 → **빠른 처리** → 즉시 종료  
- **타깃 파일 다운로드**: **BITS 작업**(제약 준수)으로 예약, 플랫폼이 허용 시점에 진행  
- **Extended Execution**(UWP): 제한적으로 허용되는 확장 실행. Win32는 **PowerSetRequest**로 아주 짧게만.

**반패턴**
- 1분 폴링(네트워크/CPU 깨어남)  
- 긴 루프 + 유지 요청 고정  
- 타이머 해상도 상시 1ms

---

## 10. 예제: 에너지 친화 동기화 스케줄러(Win32)

```cpp
class EnergyAwareScheduler {
public:
    void Start() {
        enterBackgroundMode_ = true;
        SetPriorityClass(GetCurrentProcess(), PROCESS_MODE_BACKGROUND_BEGIN);
        InstallPowerNotifications();
        StartCoalescedTimer(5*60'000 /*ms*/, 10'000 /*slack*/);
    }
    void Stop() {
        StopTimer();
        RemovePowerNotifications();
        SetPriorityClass(GetCurrentProcess(), PROCESS_MODE_BACKGROUND_END);
    }
    void OnTimer() {
        if (batterySaver_) return; // 절약 모드면 Skip
        if (displayOff_)   return; // Modern Standby 시 Skip
        // 네트워크 비용형이면 Skip or 최소 동기화
        RunBatchSyncBITS();
    }
    void OnBatterySaver(bool on) { batterySaver_ = on; Recalc(); }
    void OnDisplayOff(bool off)  { displayOff_  = off; Recalc(); }
private:
    void Recalc() {
        if (batterySaver_ || displayOff_) StopTimer();
        else StartCoalescedTimer(6*60'000, 10'000);
    }
    // ... (위의 타이머/Power 알림 구현)
    std::atomic<bool> batterySaver_{false}, displayOff_{false};
    bool enterBackgroundMode_{false};
};
```

---

## 11. 패키지앱(UWP/브릿지) 백그라운드 태스크 레시피

### 11.1 푸시 트리거(서버 푸시 기반)
```csharp
var builder = new BackgroundTaskBuilder { Name = "PushSync", TaskEntryPoint = "Tasks.PushSyncTask" };
builder.SetTrigger(new PushNotificationTrigger()); // WNS 채널 필요
BackgroundTaskRegistration reg = builder.Register();
```
- 태스크에서 **아주 짧게** 서버 이벤트 반영, **긴 다운로드는 BITS** 로 전가.

### 11.2 Maintenance/Time Trigger
- **OS가 에너지 여유** 있을 때 실행. 주기 보장은 약하지만 배터리에 가장 친화.

---

## 12. 사용자 옵션/UX

- 설정:
  - [ ] **배터리 모드에서 동기화 속도 줄이기**  
  - [ ] **절전 중 백그라운드 동기화 금지**(권장 기본 On)  
  - [ ] **Wi-Fi 전용 동기화**(비용형/모바일 네트워크 차단)  
  - [ ] **대용량 항목은 충전 중에만**

- UI:
  - 진행률/예상 소요 시간 대신 **“배터리 절약을 위해 나중에 자동 실행됩니다”** 안내  
  - 사용자가 **지금 실행**을 강제할 수 있게(일회성 유지 요청 + 경고)

---

## 13. 체크리스트(출시 전 최종)

- [ ] 타이머 해상도 15.6ms 유지 (WPA로 확인)  
- [ ] Coalescable Timer/ThreadPool Timer 윈도우 지정  
- [ ] 백그라운드 모드/낮은 우선순위/Background I/O 힌트 적용  
- [ ] BITS로 다운로드/업로드 전환 (재시도·중단 내장)  
- [ ] Battery Saver/비용형 네트워크에서 작업 연기  
- [ ] Suspend/Resume 처리 + 아주 짧은 유지 요청만 사용  
- [ ] Modern Standby 시 폴링 없음(푸시/트리거만)  
- [ ] ETW(파워 템플릿)로 웨이크업/에너지 추정 확인  
- [ ] “사용자 제어” 옵션 제공

---

## 14. 트러블슈팅

| 증상 | 원인 | 해결 |
|---|---|---|
| 배터리 급감, 팬 소음 | 타이머 해상도 1ms, 초단위 폴링 | 해상도 복구, 폴링 제거/푸시 전환, 타이머 윈도우 부여 |
| Modern Standby 중 배터리 손실 | 유지 요청 상시 on, 긴 루프 | 유지 요청 제거, 태스크/푸시 기반, 배치 처리 |
| UI 렉/지연 | 백그라운드 I/O 우선 미적용 | Process/Thread/Handle 우선순위 하향, BITS 사용 |
| 다운로드 멈춤/느림 | 비용형 네트워크 제한 | 정책 감지 후 UI 안내/수동 허용 옵션 |
| 재개 후 폭주 | 동시에 모두 동기화 | 랜덤 지연 + 지수 백오프, 배치 나눔 |

---

## 15. 참고 구현 조각(한 화면 요약)

```cpp
// 1) 백그라운드 모드 진입
SetPriorityClass(GetCurrentProcess(), PROCESS_MODE_BACKGROUND_BEGIN);

// 2) Coalescable 주기 타이머
StartCoalescedTimer(/*periodMs*/ 300000, /*slack*/ 10000);

// 3) I/O Background 힌트
FILE_IO_PRIORITY_HINT_INFO p{ IoPriorityHintVeryLow };
SetFileInformationByHandle(hFile, FileIoPriorityHintInfo, &p, sizeof(p));

// 4) Power Throttling: 기본 허용, 필요 구간에만 짧게 해제
THREAD_POWER_THROTTLING_STATE t{};
t.Version=THREAD_POWER_THROTTLING_CURRENT_VERSION;
t.ControlMask = THREAD_POWER_THROTTLING_EXECUTION_SPEED;
t.StateMask   = THREAD_POWER_THROTTLING_EXECUTION_SPEED; // 1=enable throttling
SetThreadInformation(GetCurrentThread(), ThreadPowerThrottling, &t, sizeof(t));

// 5) Suspend/Resume 이벤트
//  -> WM_POWERBROADCAST: PBT_APMSUSPEND/PBT_APMRESUMEAUTOMATIC 처리

// 6) 다운로드는 BITS
//  -> BG_JOB_PRIORITY_LOW, Resume(), 상태는 콜백/폴링

// 7) Modern Standby 중 폴링 금지
//  -> Power notifications로 화면 오프 인지, 타이머 중단
```

---

### 마무리

“**짧고 굵게, 드물게, OS에게 맡기자**”가 에너지 친화 스케줄링의 본질입니다.  
타이머·우선순위·I/O 힌트만 올바르게 써도 배터리/발열이 눈에 띄게 개선되고, Connected(Modern) Standby에서도 “조용히, 필요할 때만 깨어나는” 앱이 됩니다.  
