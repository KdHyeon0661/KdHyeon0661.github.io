---
layout: post
title: Svelte - 애니메이션 & 모션
date: 2025-09-28 21:25:23 +0900
category: Svelte
---
# 5. 애니메이션 & 모션
**트랜지션(transition) · 애니메이션(animation/animate 지시자) · `svelte/motion`(spring/tweened) · 스크롤/가시성 트리거 · 접근성(모션 감소) 고려**

> 이 장은 Svelte에서 **움직임**을 설계하는 모든 핵심 도구를 예제로 정리한다.  
> - **트랜지션(transition:)**: 요소의 **등장/퇴장**을 부드럽게  
> - **애니메이션(animate:) & 키프레임**: **리스트 재배치/상태 변화**를 자연스럽게  
> - **`svelte/motion`**: 물리 기반 **spring**과 시간 기반 **tweened** 상태  
> - **스크롤/가시성 트리거**: IntersectionObserver·액션·지연 로딩  
> - **A11y**: `prefers-reduced-motion`, 포커스/읽기 흐름 보호

---

## 5.1 트랜지션(transition:) — “등장/퇴장”의 미학

Svelte의 `transition:` 지시자는 **조건부 렌더링**(`{#if}`, `{#each}`)에서 **DOM에 들어오고 나가는 순간**에 애니메이션을 부여한다.

### 5.1.1 내장 트랜지션(기본)
내장 모듈 `svelte/transition`에는 `fade`, `fly`, `scale`, `slide`, `blur`, `draw`, `crossfade` 등이 있다.

{% raw %}
```svelte
<script>
  import { fade, fly, scale, slide, blur } from 'svelte/transition';
  let open = false;
</script>

<button on:click={() => open = !open}>
  {open ? 'Hide' : 'Show'}
</button>

{#if open}
  <p transition:fade>단순 페이드</p>
  <p transition:fly={{ y: 20, duration: 250, opacity: 0.3 }}>아래에서 슬쩍</p>
  <p transition:scale={{ start: 0.9, duration: 180 }}>조심스런 확대</p>
  <p transition:slide>슬라이드 인/아웃</p>
  <p transition:blur={{ amount: 6, duration: 220 }}>블러로 등장</p>
{/if}
```
{% endraw %}

- `transition:name={{ 옵션 }}` 형태로 **등장/퇴장** 모두에 적용된다.  
- 특정 방향에만 적용하려면 `in:fade`/`out:fade`처럼 분리 가능.

{% raw %}
```svelte
{#if open}
  <p in:fly={{ x: -30 }} out:fade>들어올 때만 fly, 나갈 때는 fade</p>
{/if}
```
{% endraw %}

### 5.1.2 `easing`으로 감속·탄성 느낌 더하기
`import * as easing from 'svelte/easing'` 후 옵션에 `easing: easing.cubicOut` 등 지정.

{% raw %}
```svelte
<script>
  import { fly } from 'svelte/transition';
  import { cubicOut, backOut } from 'svelte/easing';
  let show = true;
</script>

<label><input type="checkbox" bind:checked={show}/> show</label>

{#if show}
  <div transition:fly={{ y: 24, duration: 300, easing: cubicOut }}>
    부드러운 감속
  </div>
  <div transition:fly={{ y: -24, duration: 300, easing: backOut }}>
    탄성 있는 리바운드
  </div>
{/if}
```
{% endraw %}

### 5.1.3 사용자 정의 트랜지션(커브 제어)
트랜지션 함수는 `({ node, params }) => { delay, duration, easing, css, tick }` 형태를 반환한다.

```svelte
<script>
  // src/lib/transitions/pop.js
  export function pop(node, { y = 12, opacity = 0.3, duration = 220 } = {}) {
    return {
      duration,
      css: (t) => {
        const o = opacity + (1 - opacity) * t;      // 0.3 → 1
        const translate = y * (1 - t);               // y → 0
        return `
          transform: translateY(${translate}px) scale(${0.98 + 0.02 * t});
          opacity: ${o};
        `;
      }
    };
  }
</script>
```

{% raw %}
```svelte
<script>
  import { pop } from '$lib/transitions/pop.js';
  let on = false;
</script>

<button on:click={() => on = !on}>Toggle</button>
{#if on}
  <div transition:pop={{ y: 18, opacity: 0.25 }}>팝!</div>
{/if}
```
{% endraw %}

- `css(t)`에서 `t∈[0,1]`로 보간한다. `tick(t, u)`(u=1−t)로 JS 기반 측정/레이아웃도 가능.

### 5.1.4 리스트의 등장/퇴장
`{#each}`에서 아이템 추가/삭제 시 트랜지션이 자동 적용된다(키드 권장).

```svelte
<script>
  import { slide } from 'svelte/transition';
  let items = ['A','B','C'];
  const add = () => items = [...items, String.fromCharCode(65 + items.length)];
  const remove = (i) => items = items.filter((_,idx) => idx!==i);
</script>

<button on:click={add}>Add</button>
<ul>
  {#each items as it, i (it)}
    <li transition:slide>
      {it} <button on:click={() => remove(i)}>x</button>
    </li>
  {/each}
</ul>
```

---

## 5.2 애니메이션(animate:) & FLIP — “재배치”를 자연스럽게

트랜지션은 **삽입/삭제**에, `animate:`는 **동일 요소의 위치/크기 변경**(정렬/필터/정렬 변경 등)에 쓰인다.  
Svelte의 `animate:flip`은 **FLIP(First-Last-Invert-Play)** 기법으로 레이아웃 변화를 보간한다.

### 5.2.1 `animate:flip` 기본
```svelte
<script>
  import { flip } from 'svelte/animate';
  let items = Array.from({ length: 6 }, (_,i) => ({ id: i+1, n: Math.random() }));

  function shuffle() {
    items = [...items].sort((a,b) => a.n - b.n);
  }
  function reverse() {
    items = [...items].reverse();
  }
</script>

<div class="grid">
  {#each items as it (it.id)}
    <div class="cell" animate:flip>{it.id}</div>
  {/each}
</div>
<div class="mt">
  <button on:click={shuffle}>Shuffle by n</button>
  <button on:click={reverse}>Reverse</button>
</div>

<style>
  .grid { display: grid; grid-template-columns: repeat(3, 64px); gap: 8px; }
  .cell { display: grid; place-items: center; height: 64px; background: #0ea5e933; border: 1px solid #0ea5e9; border-radius: 10px; }
  .mt { margin-top: .5rem; }
</style>
```

- 아이템 순서가 바뀌어도 **자리 이동**이 자연스럽다.
- `animate:flip={{ duration: f => Math.sqrt(f) * 400 }}`처럼 **인자**로 duration/easing 제어 가능(`f`는 거리 비율).

### 5.2.2 상태 변화 애니메이션(키프레임·CSS 변수)
**클래스 토글** + CSS `transition`/`@keyframes`로 값 변화를 부드럽게.

```svelte
<script>
  let on = false;
</script>

<button class:on={on} on:click={() => on = !on}>
  Toggle
</button>

<style>
  button {
    --bg: #111827; --fg: #e5e7eb;
    background: var(--bg);
    color: var(--fg);
    border: none; border-radius: 12px;
    padding: .5rem .8rem;
    transition: transform .08s, background .25s, color .25s;
  }
  button:on {
    --bg: #0ea5e9; --fg: #ffffff;
    transform: translateY(1px) scale(.99);
  }
</style>
```

- **토큰/변수**를 전환하면 전체 테마·컴포넌트 상태도 쉽게 보간된다.

---

## 5.3 `svelte/transition` 고급 — crossfade로 두 리스트간 이동

두 컬렉션 사이에서 **아이템이 이동**할 때 자연스러운 페이드+이동을 제공한다.

```svelte
<script>
  import { crossfade } from 'svelte/transition';
  const [send, receive] = crossfade({
    duration: (d) => Math.sqrt(d) * 200
  });

  let inbox = ['A','B','C'];
  let done = [];

  function toDone(i) {
    done = [inbox[i], ...done];
    inbox = inbox.filter((_, idx) => idx !== i);
  }
  function toInbox(i) {
    inbox = [done[i], ...inbox];
    done = done.filter((_, idx) => idx !== i);
  }
</script>

<section class="cols">
  <ul>
    {#each inbox as it (it)}
      <li out:send>{it} <button on:click={() => toDone(inbox.indexOf(it))}>→</button></li>
    {/each}
  </ul>

  <ul>
    {#each done as it (it)}
      <li in:receive>{it} <button on:click={() => toInbox(done.indexOf(it))}>←</button></li>
    {/each}
  </ul>
</section>

<style>
  .cols { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
  li { background: #f8fafc; border: 1px solid #e5e7eb; border-radius: 10px; padding: .45rem .6rem; margin: .25rem 0; }
</style>
```

---

## 5.4 `svelte/motion` — 상태를 **부드럽게** 보간(spring/tweened)

View가 아닌 **값 자체**를 애니메이션하는 방법.  
- **`spring(initial, opts)`**: 물리 기반(질량/감쇠) → **자연스러운 스프링**   
- **`tweened(initial, opts)`**: 시간 기반(지속시간/이징) → **정밀한 타이밍**

### 5.4.1 `tweened` — 수치/색/객체 보간
```svelte
<script>
  import { tweened } from 'svelte/motion';
  import { cubicOut } from 'svelte/easing';

  const x = tweened(0, { duration: 300, easing: cubicOut });
  let target = 200;

  function move(to) {
    target = to;
    x.set(to); // 현재값 → to 로 보간
  }
</script>

<div style="position:relative;height:50px;background:#f1f5f9;">
  <div style="position:absolute;top:12px;height:26px;width:26px;border-radius:13px;background:#0ea5e9;transform: translateX({$x}px);"></div>
</div>

<button on:click={() => move(0)}>0</button>
<button on:click={() => move(120)}>120</button>
<button on:click={() => move(200)}>200</button>
```

- `$x`는 **현재 보간 중인 값**. 템플릿에 자연스럽게 바인딩된다.

#### 5.4.1.1 색/객체 보간(부분 보간)
`tweened`는 **숫자·색·단순 객체**까지 지원. 객체는 **동형 키**만 보간.

```svelte
<script>
  import { tweened } from 'svelte/motion';
  const color = tweened('#0ea5e9', { duration: 400 });
</script>

<div style="height:40px;width:100%;background: {$color};"></div>
<button on:click={() => color.set('#22c55e')}>Green</button>
<button on:click={() => color.set('#ef4444')}>Red</button>
```

### 5.4.2 `spring` — 물리적 감쇠로 자연스런 이동
```svelte
<script>
  import { spring } from 'svelte/motion';
  let pos = spring({ x: 0, y: 0 }, { stiffness: 0.1, damping: 0.25 });

  function drag(e) {
    pos.set({ x: e.clientX - 25, y: e.clientY - 25 });
  }
</script>

<div on:mousemove={drag} style="height:220px;border:1px dashed #cbd5e1; position:relative;">
  <div style="position:absolute; left:{$pos.x}px; top:{$pos.y}px; width:50px; height:50px; border-radius:25px; background:#0ea5e9;">
  </div>
</div>
```

- `spring`은 목표를 바꿀 때 **과도 응답(overshoot)**이 자연스럽다. `stiffness/damping`으로 탄성 조절.

### 5.4.3 `set`, `update`, `subscribe` 패턴
`svelte/store`와 동일한 인터페이스 → `derived`와도 합성 가능.

```svelte
<script>
  import { spring } from 'svelte/motion';
  import { derived } from 'svelte/store';

  const width = spring(10);
  const height = spring(10);

  // 면적은 즉시 계산(보간 값 기반)
  const area = derived([width, height], ([$w, $h]) => Math.round($w * $h));
</script>

<input type="range" min="10" max="300" on:input={(e)=>width.set(+e.target.value)} />
<input type="range" min="10" max="300" on:input={(e)=>height.set(+e.target.value)} />

<div style="width:{$width}px;height:{$height}px;background:#e0f2fe;border:1px solid #7dd3fc;"></div>
<p>Area: {$area}</p>
```

---

## 5.5 스크롤/가시성 트리거 — IntersectionObserver·액션

스크롤 위치에 따라 **지연 등장**, **카운터 가동**, **이미지 로딩** 등을 제어할 수 있다.  
Svelte에서는 **액션(use:)**이 가장 깔끔하다.

### 5.5.1 `intersect` 액션(한 번만 실행)
```svelte
<!-- src/lib/actions/intersect.js -->
export function intersect(node, { once = true, threshold = 0.2, onEnter = () => {}, onLeave } = {}) {
  const io = new IntersectionObserver((entries) => {
    entries.forEach((e) => {
      if (e.isIntersecting) {
        onEnter(e);
        if (once) io.unobserve(node);
      } else {
        onLeave?.(e);
      }
    });
  }, { threshold });
  io.observe(node);
  return { destroy() { io.disconnect(); } };
}
```

{% raw %}
```svelte
<script>
  import { intersect } from '$lib/actions/intersect.js';
  let visible = false;
</script>

<div style="height:60vh;"></div>

<section
  class:show={visible}
  use:intersect={{ once: true, onEnter: () => (visible = true) }}>
  <h2>스크롤 진입 시 페이드업</h2>
  <p>한 번만 실행</p>
</section>

<style>
  section { opacity: 0; transform: translateY(10px); transition: opacity .35s, transform .35s; }
  section.show { opacity: 1; transform: none; }
</style>
```
{% endraw %}

### 5.5.2 무한 스크롤(센티넬)
{% raw %}
```svelte
<script>
  import { intersect } from '$lib/actions/intersect.js';
  let items = Array.from({ length: 20 }, (_,i) => `row-${i+1}`);

  async function loadMore() {
    await new Promise(r => setTimeout(r, 300));
    const n = items.length;
    items = [...items, ...Array.from({ length: 20 }, (_,i) => `row-${n+i+1}`)];
  }
</script>

<ul>
  {#each items as it (it)} <li>{it}</li> {/each}
</ul>
<div use:intersect={{ once: false, onEnter: loadMore }} style="height:1px"></div>
```
{% endraw %}

---

## 5.6 접근성(A11y) 고려 — 모션 감소·포커스 보호·시간 제한

### 5.6.1 `prefers-reduced-motion`: 모션 축소
사용자가 OS에서 **모션 최소화**를 설정했을 수 있다. 트랜지션/애니메이션/오토플레이를 줄이자.

```css
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 1ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 1ms !important;
    scroll-behavior: auto !important;
  }
}
```

Svelte의 `transition:`에도 조건을 걸 수 있다.

{% raw %}
```svelte
<script>
  import { fade } from 'svelte/transition';
  let reduce = window?.matchMedia?.('(prefers-reduced-motion: reduce)').matches;
</script>

{#if show}
  <div transition:fade={{ duration: reduce ? 0 : 200 }}>내용</div>
{/if}
```
{% endraw %}

### 5.6.2 포커스·읽기 흐름 보호
- 모달/토스트 애니메이션이 **포커스 이동**을 방해하지 않도록 `focus()`/`tabindex`/ARIA 속성으로 제어.  
- 자동 슬라이드/카러셀은 **사용자 제어(멈춤/다음)** 제공.

### 5.6.3 깜빡임/강한 플래시 금지
- **고대비 깜빡임**(3번/초 이상)은 광과민 반응 유발 가능 → 금지.  
- 색상 대비를 유지하면서 **알파**/**이동** 위주로 전달.

---

## 5.7 종합 실습 — “카드 그리드: 필터/재배치 + 스크롤 등장 + 상세 모션”

요구사항  
1) 그리드 카드가 **스크롤 인** 시 페이드업  
2) 정렬 변경 시 **`animate:flip`**  
3) 상세 모달 **트랜지션**  
4) **모션 감소** 설정 지원

{% raw %}
```svelte
<script>
  import { flip } from 'svelte/animate';
  import { fly, fade } from 'svelte/transition';
  import { intersect } from '$lib/actions/intersect.js';

  let sort = 'name'; // 'name' | 'price'
  let items = [
    { id: 1, name: 'Alpha', price: 10, seen: false },
    { id: 2, name: 'Bravo', price: 5, seen: false },
    { id: 3, name: 'Charlie', price: 18, seen: false },
    { id: 4, name: 'Delta', price: 12, seen: false }
  ];
  let modal = null; // 상세 대상

  function sortBy(key) {
    items = [...items].sort((a,b) => a[key] > b[key] ? 1 : -1);
  }
</script>

<header class="toolbar">
  <button class:active={sort==='name'} on:click={() => (sort='name', sortBy('name'))}>Name</button>
  <button class:active={sort==='price'} on:click={() => (sort='price', sortBy('price'))}>Price</button>
</header>

<section class="grid">
  {#each items as it (it.id)}
    <article
      class="card {it.seen ? 'seen' : ''}"
      on:click={() => (modal = it)}
      animate:flip
      use:intersect={{ once: true, onEnter: () => (it.seen = true) }}>
      <h3>{it.name}</h3>
      <p class="muted">${it.price}</p>
    </article>
  {/each}
</section>

{#if modal}
  <div class="overlay" transition:fade>
    <div class="sheet" in:fly={{ y: 24, duration: 200 }} out:fly={{ y: 12, duration: 140 }}>
      <h3>{modal.name}</h3>
      <p class="muted">${modal.price}</p>
      <button on:click={() => (modal = null)}>Close</button>
    </div>
  </div>
{/if}

<style>
  .toolbar { display:flex; gap:.5rem; margin-bottom: .75rem; }
  .toolbar > button { padding:.35rem .7rem; border:1px solid #e5e7eb; border-radius:10px; background:#f8fafc; }
  .toolbar > button.active { background:#0ea5e9; color:#fff; border-color:#0ea5e9; }

  .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap:12px; }
  .card { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:.75rem; box-shadow:0 1px 2px rgba(0,0,0,.04);
          opacity:0; transform:translateY(8px); transition: opacity .35s, transform .35s; cursor:pointer; }
  .card.seen { opacity:1; transform:none; }
  .muted { color:#6b7280; }

  .overlay { position:fixed; inset:0; background:rgba(15,23,42,.35); display:grid; place-items:center; }
  .sheet { background:#fff; border-radius:14px; padding:1rem; width:min(420px, 90vw); box-shadow:0 10px 30px rgba(0,0,0,.25); }
</style>
```
{% endraw %}

- **스크롤 인**: `use:intersect`로 `seen=true` → 카드의 CSS 트랜지션 발동  
- **재배치**: 정렬 변경 시 `animate:flip`  
- **모달**: `transition:fade/fly`로 등장/퇴장  
- **모션 감소**는 전역 CSS의 `prefers-reduced-motion` 가드로 자동 반영 가능

---

## 5.8 디버깅 팁 & 성능

1) **레이아웃 스래싱** 방지: `animate:flip`·트랜지션에서 **강제 리플로우**(예: `offsetWidth` 접근) 자제.  
2) **큰 리스트**: 가상 스크롤과 부분 렌더링 도입; 트랜지션 duration을 짧게.  
3) **조합 순서**: `transition:` → `animation:`(CSS) → `animate:`는 상황에 맞게 혼용.  
4) **GPU 가속**: `transform/opacity` 중심으로, `box-shadow`·`filter` 남용 주의.  
5) **테스트**: Storybook/Playwright에서 **모션 속성**을 환경 변수로 끄고 스냅샷 일관성 확보.

---

## 5.9 요약 체크리스트

- [ ] **등장/퇴장**은 `transition:`(fade/fly/slide/scale/blur/draw/crossfade)  
- [ ] **재배치/정렬 변화**는 `animate:flip`(FLIP)  
- [ ] 값 그 자체를 부드럽게: **`tweened`**(시간), **`spring`**(물리)  
- [ ] **스크롤 트리거**는 `use:intersect`(액션)로 캡슐화  
- [ ] **접근성**: `prefers-reduced-motion` 존중, 포커스·읽기 흐름 보호  
- [ ] **성능**: transform/opacity 우선, 큰 리스트는 가상화 고려

---

### 부록 A. `draw`(SVG 획 애니메이션) 한 줄 예시
{% raw %}
```svelte
<script>
  import { draw } from 'svelte/transition';
  let show = true;
</script>

<label><input type="checkbox" bind:checked={show}/> show</label>
<svg viewBox="0 0 100 10" width="300">
  {#if show}
    <path d="M 0 5 H 100" stroke="#0ea5e9" stroke-width="2" fill="none" transition:draw={{ duration: 800 }}/>
  {/if}
</svg>
```
{% endraw %}

### 부록 B. `tweened`로 숫자 카운터
```svelte
<script>
  import { tweened } from 'svelte/motion';
  const n = tweened(0, { duration: 400 });
  let i = 0;
</script>

<p class="big">{Math.round($n)}</p>
<button on:click={() => n.set((i += 100))}>+100</button>

<style>.big{ font: 700 48px/1 system-ui; }</style>
```

### 부록 C. `spring`으로 드래그 추적(터치 대응)
```svelte
<script>
  import { spring } from 'svelte/motion';
  let pos = spring({ x: 0, y: 0 }, { stiffness: .12, damping: .3 });

  function pointerMove(e) {
    const p = e.touches?.[0] ?? e;
    pos.set({ x: p.clientX - 25, y: p.clientY - 25 });
  }
</script>

<div on:mousemove={pointerMove} on:touchmove|passive={pointerMove}
     style="height:40vh; border:1px dashed #cbd5e1; position:relative;">
  <div style="position:absolute; left:{$pos.x}px; top:{$pos.y}px; width:50px; height:50px;
              border-radius:25px; background:radial-gradient(circle at 30% 30%, #38bdf8, #0ea5e9);">
  </div>
</div>
```