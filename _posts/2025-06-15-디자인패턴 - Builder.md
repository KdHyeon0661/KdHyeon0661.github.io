---
layout: post
title: 디자인패턴 - Builder
date: 2025-06-15 20:20:23 +0900
category: 디자인패턴
---
# Builder(빌더 패턴) — 구조 그림 유지, 테레스코핑 생성자 대체, 불변 객체·검증·체이닝·스텝빌더·DI/IoC 연동까지 실전 완전 정리

본 문서는 사용자가 제공한 초안의 **핵심(정의/의도/구조/예제/장단점/비교 표)**와 **구조 그림**을 그대로 살리면서, 실무에서 바로 쓰기 위한 **문제 맥락 → 구조 해설 → 언어별 구현(Python/C#/Java) → 변형(Fluent/Step/Staged/DSL/Director 선택적) → 검증·불변성·스레드 안전성 → 테스트 전략 → 성능/복잡도 분석 → 리팩토링 절차 → 다른 생성 패턴과의 비교**로 확장한다. 모든 코드는 코드블록으로, 수식은 $$...$$로 표기한다. 표·그림은 가능한 한 유지/보강한다.

---

## 정의

**빌더 패턴(Builder Pattern)**은 복잡한 객체를 **단계적으로 구성**할 수 있도록 도와주는 **생성 패턴(Creational Pattern)**이다.
객체의 생성 과정을 분리하여 **동일한 생성 절차로 서로 다른 표현 결과**를 만들 수 있게 한다.

> "복잡한 객체의 생성 과정을 캡슐화"
> "메서드 체이닝 방식으로 유연하게 설정"

---

## 의도 (Intent)

- 객체의 생성 과정을 **분리**하여 동일 절차로 **다양한 구성**의 객체를 만든다.
- **테레스코핑 생성자(인자 폭증)** 문제를 제거하고 가독성을 높인다.
- 중간 상태를 조절하며 객체를 **단계별로 설정**하고, **최종 시점에 일괄 검증/불변화**한다.

---

## 구조 (Structure)

아래 구조 그림은 **그대로 유지**한다.

```
        ┌─────────────────────┐
        │   Director          │
        └─────────────────────┘
                 │
                 ▼
        ┌─────────────────────┐
        │   Builder (인터페이스) │◄──────────────┐
        └─────────────────────┘               │
           ▲                  ▲               │
           │                  │               │
┌────────────────────┐  ┌────────────────────┐
│ConcreteBuilderA     │  │ConcreteBuilderB     │
└────────────────────┘  └────────────────────┘
           │
           ▼
    ┌──────────────┐
    │ Product       │
    └──────────────┘
```

- **Director**: 빌더를 이용해 **조립 순서**를 캡슐화(필요 시만 사용; 생략 가능)
- **Builder**: 조립 단계를 정의하는 인터페이스(메서드 체이닝/유효성 규약)
- **ConcreteBuilder**: 실제 조립 로직과 **검증/기본값/변환**
- **Product**: 최종 산출물(가능하면 **불변 객체**로 확정)

---

## 구현 예시 1 (Python) — 기본/체이닝/검증/불변화

### 1. 기본 예제(사용자 초안을 확장: 체이닝 + 검증 + Director 선택)

```python
from __future__ import annotations
from dataclasses import dataclass, field
from typing import List, Optional

# Product: 불변 데이터 모델(생성 이후 변경 불가)
@dataclass(frozen=True)
class Meal:
    items: tuple[str, ...] = field(default_factory=tuple)
    calories: int = 0

class MealBuilder:
    def __init__(self) -> None:
        self._items: List[str] = []
        self._calories = 0

    # 체이닝(Builder 자신을 반환)
    def add_burger(self, veg: bool = True) -> MealBuilder:
        self._items.append("Veggie Burger" if veg else "Chicken Burger")
        self._calories += 450 if veg else 550
        return self

    def add_drink(self, name: str = "Water", cal: int = 0) -> MealBuilder:
        self._items.append(name)
        self._calories += cal
        return self

    def add_side(self, name: str, cal: int) -> MealBuilder:
        self._items.append(name)
        self._calories += cal
        return self

    # 최종 단계: 일괄 검증 + 불변화
    def build(self) -> Meal:
        # 예: 최소 하나의 메인 아이템 필요
        if not any("Burger" in it for it in self._items):
            raise ValueError("메인(버거) 없이 Meal을 만들 수 없습니다.")
        # 불변 Product로 확정
        return Meal(items=tuple(self._items), calories=self._calories)

# Director: 조립 순서 캡슐화(선택 사항)
class MealDirector:
    def __init__(self, healthy: bool = True) -> None:
        self.healthy = healthy

    def construct(self, b: MealBuilder) -> Meal:
        if self.healthy:
            return b.add_burger(veg=True).add_side("Salad", 150).add_drink("Orange Juice", 110).build()
        else:
            return b.add_burger(veg=False).add_side("Fries", 300).add_drink("Coke", 140).build()

# 사용
veg_meal = MealDirector(True).construct(MealBuilder())
nonveg_meal = MealDirector(False).construct(MealBuilder())

print(veg_meal)
print(nonveg_meal)
```

포인트
- **체이닝**으로 가독성↑
- **build()** 시 **일괄 검증**(불완전/모순 방지)
- **불변 Product**로 확정 → 스레드 안정성·예측 가능성↑
- **Director는 선택**: 절차가 중요할 때만 채택(간단할 때는 생략)

---

## 구현 예시 2 (C#) — 불변 Config, 필수/선택, 검증, 체이닝

```csharp
public sealed class AppConfig
{
    public string Env { get; }
    public string Endpoint { get; }
    public int Port { get; }
    public TimeSpan Timeout { get; }

    private AppConfig(string env, string endpoint, int port, TimeSpan timeout)
    {
        Env = env; Endpoint = endpoint; Port = port; Timeout = timeout;
    }

    public sealed class Builder
    {
        private string _env;                  // 필수
        private string _endpoint = "localhost"; // 선택(기본)
        private int _port = 8080;             // 선택(기본)
        private TimeSpan _timeout = TimeSpan.FromSeconds(5);

        public Builder(string env) // 필수 인자 강제(컴파일 타임)
        {
            if (string.IsNullOrWhiteSpace(env))
                throw new ArgumentException("env is required");
            _env = env;
        }

        public Builder Endpoint(string v) { _endpoint = v; return this; }
        public Builder Port(int v) { _port = v; return this; }
        public Builder TimeoutSeconds(int s) { _timeout = TimeSpan.FromSeconds(s); return this; }

        public AppConfig Build()
        {
            if (_port <= 0 || _port > 65535) throw new InvalidOperationException("invalid port");
            return new AppConfig(_env, _endpoint, _port, _timeout);
        }
    }
}

// 사용 예
var cfg = new AppConfig.Builder("prod")
    .Endpoint("api.example.com")
    .Port(8443)
    .TimeoutSeconds(2)
    .Build();
```

포인트
- **필수 인자**는 `Builder` 생성자에서 강제
- **선택 인자**는 체이닝으로 설정, 기본값 제공
- **불변 Product**로 확정

---

## 구현 예시 3 (Java) — Effective Java 스타일 + Staged(순서 강제) 변형

### A) 일반 Fluent Builder

```java
public final class Report {
    private final String title;   // required
    private final String author;  // required
    private final boolean charts; // optional
    private final int pageLimit;  // optional

    private Report(Builder b) {
        this.title = b.title;
        this.author = b.author;
        this.charts = b.charts;
        this.pageLimit = b.pageLimit;
    }

    public static class Builder {
        private final String title;
        private final String author;
        private boolean charts = false;
        private int pageLimit = 0;

        public Builder(String title, String author) {
            if (title == null || author == null) throw new IllegalArgumentException();
            this.title = title; this.author = author;
        }
        public Builder charts(boolean v) { this.charts = v; return this; }
        public Builder pageLimit(int v) { this.pageLimit = v; return this; }

        public Report build() {
            if (pageLimit < 0) throw new IllegalStateException("pageLimit >= 0");
            return new Report(this);
        }
    }
}
```

### B) **Staged/Step Builder** — 순서 강제(필드 누락 방지)

```java
// 1단계 인터페이스들로 단계적 빌더를 강제
interface TitleStage { AuthorStage title(String t); }
interface AuthorStage { OptionStage author(String a); }
interface OptionStage {
    OptionStage charts(boolean v);
    OptionStage pageLimit(int v);
    Report build();
}

public final class ReportSteps {
    private static class Impl implements TitleStage, AuthorStage, OptionStage {
        String title, author; boolean charts; int pageLimit;

        public AuthorStage title(String t) { this.title = t; return this; }
        public OptionStage author(String a) { this.author = a; return this; }

        public OptionStage charts(boolean v) { this.charts = v; return this; }
        public OptionStage pageLimit(int v) { this.pageLimit = v; return this; }

        public Report build() {
            if (title == null || author == null) throw new IllegalStateException();
            return new Report.Builder(title, author).charts(charts).pageLimit(pageLimit).build();
        }
    }
    public static TitleStage builder() { return new Impl(); }
}

// 사용
Report r = ReportSteps.builder()
    .title("Design Patterns")
    .author("GoF")
    .charts(true)
    .pageLimit(200)
    .build();
```

포인트
- **필수 단계의 순서**를 컴파일 타임에 강제
- 학습·보일러플레이트 비용은 증가하지만 **실수 방지** 효과가 큼

---

## 왜 빌더인가? — 테레스코핑 생성자 / 점층적 설정의 한계

- 생성자 다중 오버로드:
  - `new Report(title)` / `new Report(title, charts)` / `new Report(title, charts, pageLimit)` …
  - **인자의 의미 파악 어려움(순서 의존)**, 조합 증가에 따른 **유지보수 폭증**
- 세터 나열:
  - 불완전 상태로 오랜 기간 존재(**불변성 위배**, 스레드 경쟁·일관성 문제)
- 빌더:
  - **선택 인자**를 선언적으로 나열, **최종 시점**에 **일괄 검증**하고 **불변 객체**로 확정

선택 옵션의 개수가 \(k\)개라면, 가능한 조합은
$$ 2^k $$
이다(서로 독립 가정). 빌더는 이 조합 폭발을 **가독성·검증** 관점에서 통제한다(제약식이 있으면 유효 조합은 감소).

---

## 사용 사례(확장)

| 사용 사례                 | 설명 |
|--------------------------|------|
| 복잡한 설정 객체         | Config/Options/Feature Flags(기본값·검증·환경 주입) |
| UI/문서 조립             | HTML/GUI/문서(섹션/위젯/스타일) |
| SQL 쿼리 생성기          | `SELECT/FROM/WHERE/GROUP/...` 체이닝 |
| 네트워크 요청 조립       | HTTP/gRPC(헤더/쿼리/바디/리트라이 정책) |
| 게임 캐릭터/레벨 설계    | 템플릿 + 파라미터 튜닝(Builder ↔ Prototype 조합) |
| JSON/XML 빌더            | 계층 데이터(필수 키 검증, 스키마 변환 포함) |

---

## SQL/HTML DSL 예시 — 빌더로 DSL 구현

### SQL Builder (Python)

```python
class SqlBuilder:
    def __init__(self) -> None:
        self._select, self._from, self._where, self._order = [], None, [], None

    def select(self, *cols: str) -> "SqlBuilder":
        self._select.extend(cols); return self

    def from_(self, table: str) -> "SqlBuilder":
        self._from = table; return self

    def where(self, cond: str) -> "SqlBuilder":
        self._where.append(cond); return self

    def order_by(self, col: str, desc: bool=False) -> "SqlBuilder":
        self._order = f"{col} DESC" if desc else f"{col} ASC"; return self

    def build(self) -> str:
        if not self._select or not self._from:
            raise ValueError("SELECT/FROM은 필수")
        q = f"SELECT {', '.join(self._select)} FROM {self._from}"
        if self._where: q += " WHERE " + " AND ".join(self._where)
        if self._order: q += " ORDER BY " + self._order
        return q

sql = (SqlBuilder()
       .select("id","name","age")
       .from_("users")
       .where("age >= 18")
       .order_by("name")
       .build())
```

### HTML Builder (C#)

```csharp
public sealed class HtmlBuilder {
    private readonly StringBuilder _sb = new();
    public HtmlBuilder Div(string cls, Action<HtmlBuilder> inner) {
        _sb.Append($"<div class=\"{cls}\">");
        inner(this);
        _sb.Append("</div>");
        return this;
    }
    public HtmlBuilder P(string text) { _sb.Append($"<p>{text}</p>"); return this; }
    public override string ToString() => _sb.ToString();
}

// 사용
var html = new HtmlBuilder()
    .Div("container", b => b.P("Hello").Div("row", r => r.P("World")))
    .ToString();
```

---

## 장점(보강)

- 복잡 객체의 **단계적 구성**과 **의미 있는 이름** 제공
- **생성과 표현 분리**, 빌더 내부에 **기본값/검증/변환/로깅/측정** 넣기 용이
- **불변 Product**로 확정 → 스레드 안전·디버깅 용이
- **메서드 체이닝**으로 가독성↑, **Staged/Step**으로 필수 순서 강제 가능
- 테스트: **빌더 입력**만으로 다양한 케이스 구성, **계약 테스트** 재사용 쉬움

---

## 단점(보강)

- 클래스/보일러플레이트 증가(특히 Step Builder)
- 단순 객체에 적용 시 **오버엔지니어링**
- 빌더는 보통 **스레드 안전하지 않음**(필요하면 외부 동기화/불변 중간 스냅샷)

---

## 빌더 vs 생성자 vs 팩토리 메서드(확장 표)

| 항목                | 생성자(Constructor)        | 팩토리 메서드                   | 빌더 패턴                                  |
|--------------------|----------------------------|----------------------------------|--------------------------------------------|
| 유연성             | 낮음                       | 중                               | 높음(체이닝/옵션/검증)                     |
| 복잡 객체          | 불편                       | 일부 지원                        | 최적(단계/검증/기본값)                     |
| 중간 단계 설정     | 불가                       | 제한적                           | 가능(순서 강제도 가능)                     |
| 불변 Product       | 구현 난이도 높음           | 중                               | 쉬움(빌드 시점에 확정)                     |
| 학습/보일러         | 낮음                       | 낮음~중                          | 중~높음(특히 Step/Staged)                  |

---

## DI/IoC와의 연동

- **조립은 Builder, 라이프사이클/의존 해소는 DI**.
- 예: ASP.NET Core에서 `IOptions<T>`를 구성하는 내부 구현에 Builder 사용(검증 포함).
- 환경별 프로필/피처 플래그에 따라 Builder가 **기본값/전략**을 달리 주입.

---

## 테스트 전략(계약·페일패스·프로퍼티 기반)

- **계약 테스트**: 빌더가 생성하는 Product의 **불변·불변식**(invariants)을 공통 테스트로 정의
- **페일 패스**: 필수 필드 누락/모순 제약 위반 시 **명시적 예외** 검증
- **프로퍼티 기반**: 랜덤 옵션 조합으로 **일관성/경계값** 자동 탐색(예: Hypothesis/QuickCheck류 도구)

예시(PyTest 스니펫)

```python
import pytest

def test_meal_requires_main():
    b = MealBuilder().add_drink("Water", 0)
    with pytest.raises(ValueError):
        b.build()

def test_meal_calories_positive():
    m = MealBuilder().add_burger().add_side("Salad", 150).build()
    assert m.calories > 0
```

---

## 성능·복잡도·메모리 고려

- **시간 복잡도**: 빌더 자체는 일반적으로 **O(n)**(추가한 단계 수)
- **공간 복잡도**: 중간 버퍼/리스트 → **O(n)**, 최종 Product가 불변 튜플/배열로 **압축** 가능
- 오버헤드 모델(단순화):
  $$ T_{\text{build}} = \sum_{i=1}^{n} (T_{\text{step}_i}) + T_{\text{validate}} + T_{\text{freeze}} $$
  대부분의 실무에서는 검증/동기화보다 **I/O/직렬화 비용**이 지배적

---

## 리팩토링 절차 — 테레스코핑/세터 → 빌더

**냄새**
- `new X(a,b,c,d,e,f,g,h)` 생성자 남발
- 세터 기반 초기화(불완전 상태·순서 의존)
- 옵션/기본값/검증 로직이 **여러 곳**에 흩어짐

**절차**
1) Product의 **불변식/필수·선택·기본값** 정의
2) Builder 도입: 메서드 체이닝 + 기본값 부여 + **build()에서 일괄 검증**
3) 기존 생성자/세터 진입점을 점진적으로 **Builder로 대체**
4) 필요하면 **Staged/Step**으로 필수 순서 강제
5) 테스트: 계약/페일 패스 완비

---

## 변형(Variants)

- **Fluent Builder**: 메서드 체이닝 중심(대다수 사례)
- **Staged/Step Builder**: 필수 단계/순서를 **컴파일 타임**에 강제
- **Directorless**: 간단한 경우 Director 생략(빌더가 모든 책임)
- **Functional Builder**: 순수 함수 조합(람다로 스텝 누적)
- **Builder + Prototype**: 템플릿을 **clone** 후 빌더로 덮어쓰기(성능/재사용↑)
- **Thread-safe Builder**: 드묾. 필요 시 외부 락/불변 중간 스냅샷/카피-온-라이트

---

## 다른 생성 패턴과의 관계

| 비교 대상          | 차이점/함께 쓰는 법 |
|-------------------|---------------------|
| Factory Method     | “**무엇을 만들지 선택**”에 초점. 빌더는 “**어떻게 조립**”에 초점. 함께 쓰면 **선택(팩토리) → 조립(빌더)** |
| Abstract Factory   | **제품군** 일관 생성. 제품군의 각 구성품을 **빌더로 정밀 조립** 가능 |
| Prototype          | **복제(템플릿)** 기반 빠른 생성. 복제 후 빌더로 미세 조정 |
| Singleton          | 빌더와 직접적 연관은 적음. 단, **싱글턴 설정 빌더**처럼 조합 가능 |

---

## 마무리 요약

- 빌더는 **복잡한 객체 생성**의 표준 해법: **체이닝**, **일괄 검증**, **불변 Product**.
- **간단한 경우는 생략**하되, 인자/옵션/순서/검증이 복잡해질수록 빌더의 가치가 커진다.
- 실무에서는 **Fluent + 불변 Product**를 기본으로, 필요 시 **Staged**로 필수 순서/완전성을 **컴파일 타임**에 보장하라.
- DI/IoC와 결합해 **전략/기본값/환경**을 주입하고, 테스트에서는 **계약/페일 패스/프로퍼티 기반**을 적용해 품질을 담보하라.
