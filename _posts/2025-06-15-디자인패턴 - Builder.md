---
layout: post
title: 디자인패턴 - Builder
date: 2025-06-15 20:20:23 +0900
category: 디자인패턴
---
# Builder (빌더 패턴)

## ✅ 정의

**빌더 패턴(Builder Pattern)**은 복잡한 객체를 **단계적으로 구성**할 수 있도록 도와주는 **생성 패턴(Creational Pattern)**입니다.  
즉, 객체의 생성 과정을 분리하여 **동일한 생성 절차로 서로 다른 표현 결과를 만들 수 있게** 합니다.

> **"복잡한 객체의 생성 과정을 캡슐화"**  
> **"메서드 체이닝 방식으로 유연하게 설정"**

---

## 🎯 의도 (Intent)

- 객체의 생성 과정을 **분리**하여, 동일한 생성 절차로 **다양한 구성의 객체**를 만들 수 있도록 한다.
- 생성자의 인자가 많거나 복잡할 때 가독성과 유지보수성을 높인다.
- 중간 상태를 조절하며 객체를 **단계별로 설정 가능**하게 한다.

---

## 📦 구조 (Structure)

```
        ┌─────────────────────┐
        │   Director          │
        └─────────────────────┘
                 │
                 ▼
        ┌─────────────────────┐
        │   Builder (인터페이스) │◄──────────────┐
        └─────────────────────┘               │
           ▲                  ▲               │
           │                  │               │
┌────────────────────┐  ┌────────────────────┐
│ConcreteBuilderA     │  │ConcreteBuilderB     │
└────────────────────┘  └────────────────────┘
           │
           ▼
    ┌──────────────┐
    │ Product       │
    └──────────────┘
```

- **Director**: 빌더를 이용하여 객체를 조립하는 책임
- **Builder**: 객체 생성의 각 단계 정의
- **ConcreteBuilder**: 실제 조립 로직 구현
- **Product**: 최종 생성되는 객체

---

## 🧑‍💻 구현 예시 (Python)

```python
# Product
class Meal:
    def __init__(self):
        self.items = []

    def add_item(self, item):
        self.items.append(item)

    def show_items(self):
        for item in self.items:
            print(f"- {item}")

# Builder
class MealBuilder:
    def add_burger(self): pass
    def add_drink(self): pass
    def get_result(self): pass

# Concrete Builder
class VegMealBuilder(MealBuilder):
    def __init__(self):
        self.meal = Meal()

    def add_burger(self):
        self.meal.add_item("Veggie Burger")

    def add_drink(self):
        self.meal.add_item("Orange Juice")

    def get_result(self):
        return self.meal

class NonVegMealBuilder(MealBuilder):
    def __init__(self):
        self.meal = Meal()

    def add_burger(self):
        self.meal.add_item("Chicken Burger")

    def add_drink(self):
        self.meal.add_item("Coke")

    def get_result(self):
        return self.meal

# Director
class MealDirector:
    def construct(self, builder: MealBuilder):
        builder.add_burger()
        builder.add_drink()

# 사용 예
director = MealDirector()

veg_builder = VegMealBuilder()
director.construct(veg_builder)
veg_meal = veg_builder.get_result()
veg_meal.show_items()

# 출력:
# - Veggie Burger
# - Orange Juice
```

---

## ✅ 장점

- 복잡한 객체를 **단계별로 생성** 가능
- 객체 생성 코드와 표현 분리를 통해 **재사용성 향상**
- **메서드 체이닝 방식**으로 직관적인 구성 가능
- 필드 누락 없이 **안전하게 객체 생성**

---

## ⚠️ 단점

- 구조가 복잡해져 클래스 수가 늘어날 수 있음
- 단순한 객체에는 오히려 **오버엔지니어링**

---

## 📌 사용 사례

| 사용 사례               | 설명 |
|------------------------|------|
| 복잡한 설정 객체 생성   | 설정값이 많은 Config, Options 객체 |
| UI 요소 조립            | HTML/GUI 구성 요소 조합 |
| SQL 쿼리 생성기         | `QueryBuilder`, `ORM` |
| 게임 캐릭터 생성        | 다양한 무기, 속성 조합을 가진 캐릭터 생성 |
| JSON/XML 빌더 도구      | 계층적 데이터 구조 작성 |

---

## 🧠 빌더 패턴 vs 생성자 vs 팩토리 메서드

| 항목            | 생성자(Constructor) | 팩토리 메서드        | 빌더 패턴           |
|------------------|---------------------|------------------------|----------------------|
| 유연성           | 낮음                | 중간                   | 매우 높음            |
| 복잡한 객체 생성 | 불편                | 일부 지원              | 완벽히 지원          |
| 중간 단계 설정   | 불가능              | 제한적                 | 가능 (단계별 설정)   |
| 메서드 체이닝    | 불가능              | 불편                   | 가능                 |

---

## 🧠 마무리

**빌더 패턴**은 객체 생성이 복잡하고 다양한 조합이 가능할 때 매우 유용한 설계 방식입니다.  
**"생성과 표현의 분리"**라는 핵심 철학 아래, 객체 구성 과정을 세밀하게 제어할 수 있습니다.

하지만, 단순한 구조에는 적용을 피하고, **객체가 복잡해질 때 전략적으로 도입**하는 것이 이상적입니다.
