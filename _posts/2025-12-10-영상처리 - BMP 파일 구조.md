---
layout: post
title: 영상처리 - BMP 파일 구조 (C#)
date: 2025-12-10 16:30:23 +0900
category: 영상처리
---
# BMP 파일 구조의 심층 분석과 실제 활용

## **BMP 포맷의 역사적 의미와 현재적 가치**

BMP는 Windows의 핵심 이미지 형식으로 **압축이 없는 원본 데이터**를 보존한다는 점에서 중요합니다. 이는 각 픽셀이 수학적 변환 없이 직접 저장됨을 의미하며, 연구 및 실시간 처리 분야에서 여전히 사용됩니다. 예를 들어, 의료 영상(DICOM의 raw 데이터), 실시간 비디오 프레임 버퍼, 임베디드 시스템 디스플레이 등에서 활용됩니다.

---

## **비트맵 파일 헤더의 실제 의미와 코드 구현**

### **bfType (2바이트): 파일 형식 식별**
```csharp
public bool IsValidBmpFile(byte[] header)
{
    // BMP 파일은 항상 'BM'으로 시작 (리틀 엔디언: 0x42 0x4D)
    // 0x42 = 'B', 0x4D = 'M'
    return header[0] == 0x42 && header[1] == 0x4D;
}

// 실제 파일에서 확인하는 방법
using (var stream = new FileStream(path, FileMode.Open))
{
    byte[] header = new byte[2];
    stream.Read(header, 0, 2);
    
    if (!IsValidBmpFile(header))
    {
        throw new FormatException("유효한 BMP 파일이 아닙니다");
    }
}
```

### **bfOffBits의 실제 활용: 효율적인 데이터 접근**
```csharp
public class EfficientBmpReader
{
    private int _pixelDataOffset;
    private int _stride;
    private int _width;
    private int _height;
    
    public void Preprocess(string path)
    {
        using (var br = new BinaryReader(File.OpenRead(path)))
        {
            // 파일 헤더 읽기
            br.BaseStream.Seek(10, SeekOrigin.Begin); // bfOffBits 위치
            _pixelDataOffset = br.ReadInt32();
            
            // 정보 헤더 읽기
            br.BaseStream.Seek(18, SeekOrigin.Begin); // biWidth 위치
            _width = br.ReadInt32();
            _height = Math.Abs(br.ReadInt32()); // 높이는 절대값 사용
            
            // Stride 계산
            int bitsPerPixel = br.ReadInt16(); // biBitCount
            _stride = ((_width * bitsPerPixel + 31) / 32) * 4;
        }
    }
    
    // 특정 픽셀 영역만 읽기
    public byte[] ReadRegion(int startX, int startY, int regionWidth, int regionHeight)
    {
        // 계산: 시작 위치 = 데이터 오프셋 + (y * stride) + (x * bytesPerPixel)
        // 패딩을 건너뛰면서 필요한 부분만 읽음
    }
}
```

---

## **Stride와 패딩의 물리적 의미**

### **왜 4바이트 정렬인가?**
CPU는 32비트(4바이트) 또는 64비트(8바이트) 단위로 메모리에 접근할 때 가장 효율적입니다. BMP의 4바이트 정렬은 이 CPU 특성을 활용한 설계입니다.

### **Stride 계산의 실제 예제**
```csharp
public class StrideCalculator
{
    public static (int stride, int padding) CalculateStride(int width, int bitsPerPixel)
    {
        int bytesPerPixel = bitsPerPixel / 8;
        int unpaddedRowSize = width * bytesPerPixel;
        
        // 4바이트 정렬 계산
        int stride = ((unpaddedRowSize + 3) / 4) * 4;
        int padding = stride - unpaddedRowSize;
        
        return (stride, padding);
    }
    
    // 테스트: 다양한 크기에서의 Stride
    public void TestStrideCalculation()
    {
        Console.WriteLine($"100x100 24비트: {CalculateStride(100, 24)}");
        // 출력: stride=300, padding=0 (300은 4의 배수)
        
        Console.WriteLine($"101x101 24비트: {CalculateStride(101, 24)}");
        // 출력: stride=304, padding=1 (303 → 304로 올림)
        
        Console.WriteLine($"513x513 24비트: {CalculateStride(513, 24)}");
        // 출력: stride=1540, padding=1 (513*3=1539 → 1540)
    }
}
```

### **패딩 처리를 포함한 실제 픽셀 읽기**
```csharp
public byte[] ReadPixelDataWithPadding(BinaryReader br, BmpInfo info)
{
    br.BaseStream.Seek(info.DataOffset, SeekOrigin.Begin);
    
    int bytesPerPixel = info.BitCount / 8;
    byte[] imageData = new byte[info.Width * info.Height * bytesPerPixel];
    
    for (int y = 0; y < info.Height; y++)
    {
        // 실제 파일에서 한 줄 읽기 (패딩 포함)
        byte[] rawRow = br.ReadBytes(info.Stride);
        
        // 패딩 제거하고 유효한 픽셀 데이터만 복사
        int validRowSize = info.Width * bytesPerPixel;
        Buffer.BlockCopy(rawRow, 0, imageData, y * validRowSize, validRowSize);
        
        // 참고: br.ReadBytes가 자동으로 패딩 바이트를 건너뜀
        // (Stride 크기만큼 읽으므로 파일 포인터가 자동으로 이동)
    }
    
    return imageData;
}
```

---

## **24비트 BMP의 실제 처리 (가장 일반적인 형식)**

```csharp
public class TrueColorBmpProcessor
{
    // BMP는 BGR 순서로 저장, RGB가 아님!
    public struct BgrPixel
    {
        public byte B;
        public byte G;
        public byte R;
    }
    
    public BgrPixel[] Load24BitBmp(string path)
    {
        using (var br = new BinaryReader(File.OpenRead(path)))
        {
            // 헤더 읽기
            var info = ReadBmpInfo(br);
            
            if (info.BitCount != 24)
                throw new NotSupportedException("24비트 BMP만 지원");
            
            br.BaseStream.Seek(info.DataOffset, SeekOrigin.Begin);
            
            BgrPixel[] pixels = new BgrPixel[info.Width * info.Height];
            
            // 하단부터 위로 읽기 (BMP 특성)
            for (int fileY = 0; fileY < info.Height; fileY++)
            {
                int memoryY = info.Height - 1 - fileY; // Y축 반전
                byte[] row = br.ReadBytes(info.Stride);
                
                for (int x = 0; x < info.Width; x++)
                {
                    int srcIndex = x * 3;
                    int dstIndex = memoryY * info.Width + x;
                    
                    // BGR 순서로 저장
                    pixels[dstIndex] = new BgrPixel
                    {
                        B = row[srcIndex],
                        G = row[srcIndex + 1],
                        R = row[srcIndex + 2]
                    };
                }
            }
            
            return pixels;
        }
    }
    
    // BGR → RGB 변환 (다른 라이브러리와 호환 위해)
    public byte[] ConvertBgrToRgb(BgrPixel[] bgrPixels)
    {
        byte[] rgb = new byte[bgrPixels.Length * 3];
        
        for (int i = 0; i < bgrPixels.Length; i++)
        {
            rgb[i * 3] = bgrPixels[i].R;     // R
            rgb[i * 3 + 1] = bgrPixels[i].G; // G
            rgb[i * 3 + 2] = bgrPixels[i].B; // B
        }
        
        return rgb;
    }
}
```

---

## **성능 최적화를 위한 저수준 접근법**

### **unsafe 코드와 포인터 활용**
```csharp
public unsafe class FastBmpProcessor
{
    public void ApplyGrayscaleInPlace(byte[] imageData, int width, int height)
    {
        // 고정하여 가비지 컬렉터가 이동하지 않도록 함
        fixed (byte* ptr = imageData)
        {
            int totalPixels = width * height;
            
            // SIMD처럼 작동하는 루프 언롤링
            int i = 0;
            for (; i <= totalPixels - 4; i += 4)
            {
                // 4픽셀씩 처리 (CPU 파이프라이닝 활용)
                ProcessPixelGroup(ptr + i * 3);
            }
            
            // 남은 픽셀 처리
            for (; i < totalPixels; i++)
            {
                ProcessSinglePixel(ptr + i * 3);
            }
        }
    }
    
    private unsafe void ProcessPixelGroup(byte* ptr)
    {
        // 한 번에 4픽셀 처리 로직
        // 실제 구현에서는 SIMD 명령어 사용 가능
    }
}
```

### **메모리 맵 파일을 이용한 대용량 BMP 처리**
```csharp
public class MemoryMappedBmpReader
{
    public byte[] ReadLargeBmp(string path, Rectangle region)
    {
        using (var mmf = MemoryMappedFile.CreateFromFile(path, FileMode.Open))
        using (var accessor = mmf.CreateViewAccessor())
        {
            // 헤더만 먼저 읽기
            BmpInfo info = ReadHeaderFromMemory(accessor);
            
            // 필요한 영역만 계산
            long startOffset = info.DataOffset + 
                region.Y * info.Stride + 
                region.X * (info.BitCount / 8);
            
            byte[] regionData = new byte[region.Width * region.Height * (info.BitCount / 8)];
            
            // 디스크 I/O 최소화하면서 부분 읽기
            for (int y = 0; y < region.Height; y++)
            {
                accessor.ReadArray(startOffset + y * info.Stride, 
                    regionData, y * region.Width, region.Width);
            }
            
            return regionData;
        }
    }
}
```

---

## **실제 응용 예제: 이미지 에디터 기능 구현**

### **밝기 조절**
```csharp
public class ImageEditor
{
    public void AdjustBrightness(byte[] pixels, float factor)
    {
        // factor: 0.5 = 50% 어둡게, 2.0 = 200% 밝게
        for (int i = 0; i < pixels.Length; i++)
        {
            float adjusted = pixels[i] * factor;
            pixels[i] = (byte)Math.Clamp(adjusted, 0, 255);
        }
    }
    
    // 감마 보정 (비선형 밝기 조절)
    public void ApplyGammaCorrection(byte[] pixels, double gamma)
    {
        // 미리 계산된 룩업 테이블 사용
        byte[] lut = new byte[256];
        for (int i = 0; i < 256; i++)
        {
            lut[i] = (byte)(255 * Math.Pow(i / 255.0, 1.0 / gamma));
        }
        
        // 빠른 변환
        for (int i = 0; i < pixels.Length; i++)
        {
            pixels[i] = lut[pixels[i]];
        }
    }
}
```

### **이미지 회전 (90도)**
```csharp
public byte[] Rotate90Degrees(byte[] source, int width, int height, int bytesPerPixel)
{
    int newWidth = height;
    int newHeight = width;
    byte[] rotated = new byte[newWidth * newHeight * bytesPerPixel];
    
    for (int y = 0; y < height; y++)
    {
        for (int x = 0; x < width; x++)
        {
            int srcIndex = (y * width + x) * bytesPerPixel;
            int dstIndex = (x * newWidth + (height - 1 - y)) * bytesPerPixel;
            
            // 픽셀 데이터 복사 (RGB 또는 BGR)
            Buffer.BlockCopy(source, srcIndex, rotated, dstIndex, bytesPerPixel);
        }
    }
    
    return rotated;
}
```

---

## **에러 처리와 안정성**

```csharp
public class RobustBmpLoader
{
    public ImageData LoadWithValidation(string path)
    {
        try
        {
            FileInfo fileInfo = new FileInfo(path);
            
            // 1. 기본 검증
            if (!fileInfo.Exists)
                throw new FileNotFoundException($"파일을 찾을 수 없습니다: {path}");
                
            if (fileInfo.Length < 54)
                throw new CorruptedImageException("파일이 너무 짧습니다");
            
            // 2. 헤더 검증
            using (var br = new BinaryReader(File.OpenRead(path)))
            {
                var info = ValidateAndReadHeaders(br);
                
                // 3. 메모리 요구사항 검증
                ValidateMemoryRequirements(info);
                
                // 4. 데이터 무결성 검증
                if (info.DataOffset + info.Height * info.Stride > fileInfo.Length)
                    throw new CorruptedImageException("파일 크기가 일치하지 않습니다");
                
                // 5. 실제 데이터 로드
                return LoadPixelData(br, info);
            }
        }
        catch (IOException ex)
        {
            LogError($"I/O 오류: {ex.Message}");
            throw;
        }
        catch (UnauthorizedAccessException)
        {
            throw new AccessDeniedException("파일 접근 권한이 없습니다");
        }
    }
    
    private void ValidateMemoryRequirements(BmpInfo info)
    {
        long requiredMemory = (long)info.Width * info.Height * (info.BitCount / 8);
        
        if (requiredMemory > int.MaxValue)
            throw new OutOfMemoryException("이미지가 너무 큽니다");
            
        if (requiredMemory > GetAvailableMemory() * 0.7)
            throw new InsufficientMemoryException("메모리가 부족합니다");
    }
}
```

---

## **실제 프로젝트에서의 활용**

### **게임 개발: 텍스처 아틀라스 생성**
```csharp
public class TextureAtlasBuilder
{
    public Bitmap CreateAtlas(List<string> texturePaths, int tileSize)
    {
        // 각 BMP를 저수준으로 읽어서 하나의 큰 이미지로 합치기
        // 게임 성능을 위해 모든 텍스처를 한 번에 로드
    }
}

// 사용 예:
var atlasBuilder = new TextureAtlasBuilder();
var atlas = atlasBuilder.CreateAtlas(new List<string> 
{ 
    "characters/hero.bmp",
    "characters/enemy.bmp",
    "items/weapon.bmp"
}, 128);
```

### **과학 연구: 데이터 시각화**
```csharp
public class ScientificDataVisualizer
{
    public void SaveHeatmapAsBmp(double[,] data, string outputPath)
    {
        // 과학 데이터를 BMP로 시각화
        // 1. 데이터 정규화 (0-255)
        // 2. 컬러 맵 적용
        // 3. BMP 형식으로 직접 저장
    }
}
```

---

## **정리: BMP 파싱의 핵심 개념**

1. **엔디안(Endian) 이해**: BMP는 리틀 엔디언
2. **정렬(Alignment)**: 4바이트 경계 정렬이 성능 핵심
3. **저장 순서**: 하단→상단 (Y축 반전 필요)
4. **색상 순서**: BGR (일반 RGB와 다름)
5. **메모리 관리**: Stride 계산으로 정확한 메모리 접근

## **학습의 중요성**

BMP 파싱은 이미지 처리의 기초입니다. System.Drawing과 같은 고수준 라이브러리를 사용하는 것도 좋지만, 저수준에서 어떻게 동작하는지 이해하면:

1. **문제 해결 능력 향상**: 버그 발생 시 근본 원인 파악 가능
2. **성능 최적화**: 불필요한 오버헤드 제거
3. **플랫폼 독립성**: 어떤 환경에서도 이미지 처리 가능
4. **확장성**: 새로운 이미지 형식도 쉽게 이해
