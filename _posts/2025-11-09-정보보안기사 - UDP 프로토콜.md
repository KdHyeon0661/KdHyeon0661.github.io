---
layout: post
title: 정보보안기사 - UDP 프로토콜
date: 2025-11-09 15:25:23 +0900
category: 정보보안기사
---
# SECTION 04 네트워크 기본 학습 — 07. UDP 프로토콜

## UDP의 역할과 특성

- **연결 비지향(Connectionless)**: 핸드셰이크 없음(3-way X).
- **비신뢰적(Best-effort)**: 재전송/순서보장/흐름·혼잡제어 없음 → **애플리케이션 계층**이 필요 시 직접 구현해야 함(RTP/QUIC 등).
- **헤더가 짧다(8B)**: 지연·오버헤드가 작아 **실시간/스트리밍**에 유리.
- **메시지 지향(Message-oriented)**: 보낸 데이터그램 단위가 수신에도 **경계가 유지**됨(“한 번 보낸 datagram = 한 번 읽을 수 있는 메시지”).
- **일반적 사용 예**: DNS(53), NTP(123), DHCP(67/68), SNMP(161/162), Syslog(514/UDP), RTP/VoIP, QUIC(HTTP/3, UDP/443), 게임/미디어.

---

## UDP 헤더 구조(8바이트)와 포트

### ASCII 다이어그램

```
0      7 8     15 16    23 24    31
+--------+--------+--------+--------+
| Source | Dest   | Length | Check- |
| Port   | Port   |        | sum    |
+--------+--------+--------+--------+
|          Payload (Application Data)...
+---------------------------------------
```

### 필드 요약

| 필드 | 크기 | 의미/운영 포인트 |
|---|---:|---|
| Source Port | 16b | 송신 프로세스(에페멀 포트 일반) |
| Dest Port | 16b | 서비스 포트(예: 53, 123, 161…) |
| Length | 16b | **헤더+페이로드 총길이**(최소 8) |
| Checksum | 16b | IPv4에선 **선택적(0=미사용)**, IPv6에선 **필수** |

> **에페멀 포트**: 일반적으로 49152–65535(OS별 상이). 포트 랜덤화는 스푸핑/캐시 포이즈닝 완화에 중요(DNS 등).

---

## 체크섬과 의무 여부(IPv4 vs IPv6)

### Pseudo-header를 포함하는 1의 보수 합

UDP 체크섬은 **UDP 헤더·페이로드 + IP Pseudo-header**(출/목 IP, 프로토콜, UDP 길이)를 1의 보수 합으로 계산한 뒤 보수(~)를 취한다.

수식(개념):
$$
\text{Checksum}=\neg \left(\sum_{i=1}^{n} w_i \right)_{\text{1's complement}}
$$
- \(w_i\): 16비트 워드(홀수 길이면 패딩).
- **IPv4**: 체크섬 **0**은 “체크섬 미사용” 의미(합법).
- **IPv6**: 체크섬 **필수**(0 불가). 네트워크에서 손상 검출·폐기되지 않으면 상위는 손실을 모를 수 있음.

**보안 메모**: IPv4에서 UDP 체크섬 0은 **데이터 손상 미검출 위험**. 가능하면 사용(=0이 아닌 값) 권장.

---

## MTU·분절·안전 페이로드 크기

UDP 자체엔 분절 개념이 없다. **IP 계층**이 MTU 초과 시 **분절(fragmentation)** 할 수 있으며, 중간 장비가 분절을 드롭하는 경우가 많아 **애플리케이션 레벨에서 MTU 이하로 쪼개기**가 권장된다.

- 안전 페이로드(IPv4, MTU=1500):
  $$
  \text{max\_payload} = 1500 - 20(\text{IP}) - 8(\text{UDP}) = 1472\ \text{B}
  $$
- IPv6(헤더 40B, MTU=1500):
  $$
  1500 - 40 - 8 = 1452\ \text{B}
  $$

**실전 팁**
- QUIC/HTTP/3는 **1200B**를 권장 상한으로 사용(경로 전반의 안정성 확보).
- 대용량 스트림은 애플리케이션에서 **분할 + 순서/재전송/플로우** 전략을 갖추기.

---

## 브로드캐스트·멀티캐스트(UDP 친화 기능)

- **브로드캐스트(IPv4)**: 255.255.255.255(제한) 또는 디렉티드 브로드캐스트(현대 장비 기본 차단).
- **멀티캐스트(224.0.0.0/4)**: UDP와 자주 사용(RTP/멀티미디어, 서비스 디스커버리).

### Python 브로드캐스트 송신 예

```python
import socket, time
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
for i in range(5):
    s.sendto(f"hello #{i}".encode(), ("255.255.255.255", 9999))
    time.sleep(0.2)
```

### Python 멀티캐스트 수신/송신 예

```python
# recv_multicast.py

import socket, struct
MCAST_GRP = "239.1.2.3"; MCAST_PORT = 5000
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind(("", MCAST_PORT))
mreq = struct.pack("=4sl", socket.inet_aton(MCAST_GRP), socket.INADDR_ANY)
s.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
while True:
    data, addr = s.recvfrom(2048)
    print(addr, data.decode(errors="ignore"))
```

```python
# send_multicast.py

import socket, struct, time
MCAST_GRP = "239.1.2.3"; MCAST_PORT = 5000
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
ttl = struct.pack("b", 1)   # 라우터 1홉
s.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, ttl)
for i in range(5):
    s.sendto(f"mcast {i}".encode(), (MCAST_GRP, MCAST_PORT))
    time.sleep(0.2)
```

**운영 주의**: 멀티캐스트는 **IGMP/MLD, PIM** 등 L3 설정이 필요. 브로드캐스트 남용은 스톰 유발 가능.

---

## NAT·타임아웃·홀 펀칭

- UDP는 연결 상태가 없어 **NAT가 매핑 유지**를 위해 **유휴 타임아웃**을 짧게 둔다(수십 초~수분).
- 애플리케이션은 **주기적 keepalive**(예: STUN Binding Indication, 빈 UDP 패킷)로 매핑 유지.
- **NAT 홀 펀칭**: STUN/TURN/ICE로 양단이 서로의 외부 매핑을 학습해 직접 통신 시도(실패 시 릴레이).

**Linux conntrack 확인**
```bash
sudo conntrack -L -p udp | head
```

**Windows**: NAT/방화벽 구성은 `Get-NetFirewallProfile`, `netstat -anu`(WSL/Linux) 또는 `Get-NetUDPEndpoint` 등으로 상태 파악.

---

## 성능·튜닝(커널·소켓 옵션)

### 커널 버퍼/큐

```bash
# Linux

sysctl -w net.core.rmem_max=268435456
sysctl -w net.core.wmem_max=268435456
sysctl -w net.core.netdev_max_backlog=250000
sysctl -w net.ipv4.udp_rmem_min=16384
sysctl -w net.ipv4.udp_wmem_min=16384
```

- **GRO/GSO/USO**(커널·NIC 하드웨어에 따라): UDP 대량 트래픽 처리에 이점(버전/드라이버 확인).
- 애플리케이션에서 `SO_RCVBUF`, `SO_SNDBUF` 확대.

```python
# Python: 버퍼 확대

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 4*1024*1024)
s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 4*1024*1024)
```

### 지연/손실 환경에서의 애플리케이션 전략

- **레이팅/페이싱**: 송신 속도 제어(버스트 억제).
- **FEC/재전송**: 중요 패킷 보호(RTP/FEC, QUIC의 하위 계층 구현).
- **순서/중복 처리**: 시퀀스 번호·타임스탬프로 정렬/중복 제거.
- **MTU 안전 크기**(§4) 준수.

### 측정 도구(UDP 손실/지연)

```bash
# 서버

iperf3 -s
# 클라이언트, UDP 모드 -u, 목표 대역폭 -b, 패킷 크기 -l

iperf3 -c <server> -u -b 50M -l 1200
```

출력에서 **전송률·손실률·지터**를 확인.

---

## 보안: 증폭·리플렉션·스푸핑·스캔

### 증폭/리플렉션 공격(대표 프로토콜)

| 프로토콜 | 포트 | 증폭 벡터 | 완화 |
|---|---:|---|---|
| **DNS** | 53/UDP | 큰 응답(ANY/대형 RR, EDNS0) | **BCP38**, **권한 없는 오픈 리졸버 금지**, **RRL**, 응답 크기 제한 |
| **NTP** | 123/UDP | 과거 `monlist`(심각) | `monlist` 비활성/업데이트, rate-limit |
| **SSDP** | 1900/UDP | UPnP 응답 | 외부 노출 금지, 차단/필터 |
| **CLDAP** | 389/UDP | AD 질의 응답 증폭 | 외부 차단 |
| **Memcached** | 11211/UDP | 대형 키/값 증폭 | UDP 비활성, 내부 전용 |
| **TFTP** | 69/UDP | 파일 전송 | 외부 차단 |
| **Chargen** | 19/UDP | 무의미한 문자열 | 비활성/차단 |

**핵심 대책**
- **소스 스푸핑 차단(BCP38/uRPF)**: 출발지 위조 방지.
- **서비스 자체 하드닝**: 오픈 리졸버 금지, NTP 최신화, Memcached UDP 끄기.
- **경계 레이트 리밋**: UDP 특정 포트/패턴 제한, Anycast·스크러빙.

### UDP 스캐닝/진단

- **닫힘(Closed)**: 일반적으로 **ICMP Port Unreachable(Type 3 Code 3)** 반환.
- **열림(Open)**: 응답 없음(프로토콜에 따라 다름)도 흔함 → `open|filtered` 판정.
- **Nmap**: `nmap -sU -p 53,123,161 <target>`

**방화벽 예시(nftables)**

```bash
nft add table inet filter
nft add chain inet filter input { type filter hook input priority 0; policy drop; }
# 상태 기반 허용

nft add rule inet filter input ct state established,related accept
# 필요한 UDP만 허용(DNS/NTP 예시)

nft add rule inet filter input udp dport {53,123} accept
# SSDP 외부 차단

nft add rule inet filter input udp dport 1900 drop
```

---

## 운영 가시성: tcpdump/Wireshark/ss

**tcpdump**
```bash
sudo tcpdump -nni any udp
sudo tcpdump -nni eth0 "udp and port 53"
sudo tcpdump -nni any "icmp and icmp[0]==3 and icmp[1]==3"   # Port Unreachable
```

**Wireshark**
```
udp
udp.port == 53
icmp.type == 3 && icmp.code == 3   # UDP Port Unreachable
```

**소켓/포트 확인**
```bash
ss -uapn
# 혹은

netstat -anu
```

---

## 코드 예제 — UDP 에코/타임아웃/청크 분할

### Python UDP 에코 서버/클라이언트

```python
# udp_echo_server.py

import socket
HOST, PORT = "0.0.0.0", 5001
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((HOST, PORT))
print(f"UDP echo on {HOST}:{PORT}")
while True:
    data, addr = sock.recvfrom(4096)
    if not data:
        continue
    sock.sendto(data, addr)
```

```python
# udp_echo_client.py

import socket, sys, time
HOST, PORT = sys.argv[1], int(sys.argv[2])
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(2.0)  # UDP는 응답 보장 없음 → 타임아웃 필수
for i in range(5):
    msg = f"hello {i}".encode()
    sock.sendto(msg, (HOST, PORT))
    try:
        data, _ = sock.recvfrom(4096)
        print("recv:", data.decode())
    except socket.timeout:
        print("timeout")
    time.sleep(0.2)
```

### 전송

```python
# udp_chunk_send.py — IPv4 MTU=1500 가정 → payload ≤ 1472

import socket, sys, math
HOST, PORT = sys.argv[1], int(sys.argv[2])
MTU = 1500; IP=20; UDP=8
MAX_PAYLOAD = MTU - IP - UDP  # 1472
data = b"A" * (5000)          # 큰 데이터

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
for off in range(0, len(data), MAX_PAYLOAD):
    chunk = data[off:off+MAX_PAYLOAD]
    sock.sendto(chunk, (HOST, PORT))
```

> 실제 애플리케이션은 **시퀀스 번호/총 청크**를 붙여 **순서/재조립**을 구현해야 한다.

---

## 실전 시나리오

### 시나리오 A — “DNS 오픈 리졸버 차단”

증상: 외부에서 `dig @our-ip example.com ANY +edns=0` 요청에 큰 응답 → **증폭 리플렉터**로 오용.

조치:
```bash
# 외부에서 인바운드 53/UDP를 허용하지 않거나, 내부/권한 네트워크만 허용

nft add rule inet filter input udp dport 53 ip saddr { 10.0.0.0/8, 192.168.0.0/16 } accept
nft add rule inet filter input udp dport 53 drop
```
DNS 서버 설정에서 **재귀 질의 비활성** 또는 **ACL** 적용, **RRL** 활성.

### 시나리오 B — “UDP 세션 끊김(게임/미디어)”

증상: 수 분 간격으로 끊김. NAT 타임아웃 의심.

조치: **keepalive 패킷** 15–30초 간격 전송(수 바이트), 혹은 **TURN 릴레이** 사용. 경계 NAT에서 **UDP 타임아웃 연장** 검토.

### 시나리오 C — “대용량 UDP 전송 손실 심함”

원인: MTU 초과로 IP 분절 → 중간 방화벽 드롭.

해결: 애플리케이션 **청크 ≤ 1200–1400B**로 제한, **페이싱**(sleep/토큰 버킷)으로 버스트 억제.

---

## 점검 체크리스트

- [ ] **필요 포트만 화이트리스트**(DNS/NTP/SNMP 등). 불필요 UDP 인바운드 드롭.
- [ ] **오픈 리졸버 금지**, NTP `monlist` 비활성, Memcached UDP 끄기.
- [ ] **BCP38/uRPF**로 소스 스푸핑 차단.
- [ ] **레이트 리밋**(nftables/장비)으로 증폭 트래픽 억제.
- [ ] **MTU 안전 페이로드** 준수(분절 회피).
- [ ] **NAT 타임아웃/Keepalive** 간격 점검(분 단위 끊김 대응).
- [ ] **가시성**: NetFlow/IPFIX, `tcpdump`, `ss -uapn`, DNS RRL 로깅.
- [ ] **모듈화된 신뢰성**: 필요한 서비스는 **응용 레벨**에서 재전송/순서/혼잡 제어 구현(RTP/QUIC 참고).

---

## 예상 문제(필기/실무)

1) UDP 체크섬 계산 시 **Pseudo-header**가 필요한 이유와 IPv4/IPv6의 **의무 차이**를 설명하라.
2) MTU=1500인 IPv4 네트워크에서 UDP 페이로드 **최대 안전 크기**는? IPv6에서는?
3) UDP가 **메시지 지향**임을 증명하는 API/동작 특성을 서술하라.
4) **DNS/NTP/SSDP/CLDAP/Memcached** 증폭 공격의 원리와 각각의 완화책을 2가지 이상 제시하라.
5) NAT 환경에서 **UDP 홀 펀칭**의 개념과 실패 시 대안(TURN)을 설명하라.
6) `nmap -sU`로 스캔 시 **open|filtered** 판정이 자주 나오는 이유는?
7) 대용량 UDP 스트림이 **중간 방화벽에서 드롭**되는 이유와 애플리케이션 레벨의 해결책을 쓰라.

---

## 부록 — 운영 스니펫 모음

```bash
# nftables: UDP 필수 서비스만 허용 + 레이트 리밋

nft add table inet filter
nft add chain inet filter input { type filter hook input priority 0; policy drop; }
nft add rule inet filter input ct state established,related accept
nft add rule inet filter input udp dport {53,123} accept
nft add rule inet filter input udp dport 1900 drop
# 모든 UDP 신생 연결에 소프트 레이트 제한(예시)

nft add rule inet filter input udp limit rate 200/second accept
nft add rule inet filter input udp drop
```

```bash
# tcpdump: UDP/ICMP Port Unreachable 관찰

sudo tcpdump -nni any udp
sudo tcpdump -nni any "icmp and icmp[0]==3 and icmp[1]==3"
```

```bash
# iperf3: UDP 손실/지터 측정

iperf3 -s
iperf3 -c <server> -u -b 100M -l 1200 -t 10
```

```powershell
# Windows: 열려 있는 UDP 엔드포인트

Get-NetUDPEndpoint | Sort-Object -Property LocalPort | Select-Object -First 20
```

---

## 결론

- UDP는 **단순함**(8B 헤더)으로 **지연/오버헤드 최소화**라는 장점을 제공하지만, **신뢰성·흐름/혼잡 제어 부재**의 대가를 요구한다.
- 안전하고 빠른 UDP 시스템의 핵심은 **애플리케이션 레벨**에서의 **MTU 인지(청크 ≤ 1200–1472B), 재전송/순서/페이싱, NAT 타임아웃/Keepalive**, 그리고 **증폭 벡터 차단(서비스 하드닝+BCP38)** 이다.
- 본 장의 표·수식·스니펫·실습 시나리오를 토대로 환경별 점검/튜닝을 수행하면, **실시간/스트리밍/게임/QUIC** 등 UDP 기반 워크로드를 안정적으로 운영할 수 있다.
