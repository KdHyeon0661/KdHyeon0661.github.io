---
layout: post
title: MFC - IPC
date: 2025-09-06 14:25:23 +0900
category: MFC
---
# IPC: Named Pipe, Memory-Mapped File, 윈도우 메시지 기반 간단 IPC (Win32/MFC C++ 실전 총정리 + 예제 다수)

이 글은 Windows 데스크톱 앱(MFC/Win32)에서 **프로세스 간 통신(IPC)** 을 구축할 때 가장 자주 쓰는 3가지 축을
- **Named Pipe** (로컬/원격 가능, 듀플렉스, 메시지/바이트 모드, 보안/권한/가상 계정)
- **Memory-Mapped File(공유 메모리)** (초고속, 동기화 원리/패턴, 파일/페이지파일 백킹)
- **윈도우 메시지 기반 간단 IPC** (`WM_COPYDATA`, `RegisterWindowMessage`, HWND 디스커버리, UIPI)

로 나누어 **개념 → 표준 패턴 → 예제 코드** 순서로 “빠짐없이” 정리합니다.  
모든 코드는 ``` 로 감싸 두었고, 그대로 빌드/실험할 수 있게 구성했습니다.

> 환경 가정: Windows 10/11, x64, Unicode, MSVC, /W4 권장.  
> 네임스페이스/에러 체크/로깅은 예제 가독성을 위해 최소화했지만, 실전 팁을 각 절 끝에 제공합니다.

---

## 0) 어떤 IPC를 고를까? — 선택표

| 항목 | Named Pipe | Memory-Mapped File | 윈도우 메시지 |
|---|---|---|---|
| 방향성 | **Duplex**(양방향), 서버/클라이언트 | 공유 버퍼(양방향은 보통 2개 버퍼) | 단방향(보통), 응답 가능(동기) |
| 속도 | 중 | **매우 빠름**(유저모드 복사 최소) | 중(복사/커널 전환) |
| 범위 | **로컬 + 원격(네트워크)** | 로컬(세션/스테이션/핸들 상속 제약) | 로컬 데스크톱/세션 |
| 복잡도 | 중(오버랩드 I/O 권장) | 중(동기화 설계 필요) | **낮음** |
| 보안/권한 | **ACL/SDDL/Impersonation** | ACL/핸들계승/마커 | UIPI/Integrity Level |
| 전형적 용도 | 서비스↔UI, 다중 클라, 원격 제어 | 고속 생산자-소비자, 대용량 공유 | 간단 통지/작은 데이터(수KB) |

**요약**  
- **가볍고 단순**: `WM_COPYDATA`  
- **고속/대용량**: Memory-Mapped File(+Event/Mutex)  
- **표준 RPC 스타일/다수 클라/원격**: Named Pipe

---

## 1) Named Pipe — 기본/보안/비동기/프레이밍

### 1-1. 핵심 개념
- 파이프 이름: `\\.\pipe\<명칭>` (로컬), 원격은 `\\ServerName\pipe\<명칭>`.
- **메시지 모드**(단위 보존) vs **바이트 모드**(스트림). `CreateNamedPipe`의 `PIPE_TYPE_MESSAGE`/`PIPE_READMODE_MESSAGE`.
- **동기** vs **오버랩드(비동기)**. UI 앱에선 **오버랩드 + 워커** 권장.
- 서버는 **다중 인스턴스**(보통 `MAX_INSTANCES` 또는 동적으로 여러 핸들)로 여러 클라이언트 동시 처리.

### 1-2. 서버(동기, 단일 클라이언트) — 최소 예제

```cpp
// PipeServer_Sync.cpp
#include <windows.h>
#include <string>
#include <vector>
#include <cstdio>

int wmain() {
    const wchar_t* name = L"\\\\.\\pipe\\DemoPipe";

    SECURITY_ATTRIBUTES sa{ sizeof(sa) };
    sa.bInheritHandle = FALSE; // 기본
    sa.lpSecurityDescriptor = nullptr; // Everyone 허용 필요 시 SDDL 사용(아래 고급 참고)

    HANDLE hPipe = CreateNamedPipeW(
        name,
        PIPE_ACCESS_DUPLEX,                                // 읽기/쓰기
        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, // 메시지 모드, Blocking
        1,                                                // 인스턴스 1개(단순)
        64 * 1024, 64 * 1024,                             // Out/In buffer
        5000,                                             // default timeout
        &sa);

    if (hPipe == INVALID_HANDLE_VALUE) {
        wprintf(L"CreateNamedPipe failed: %u\n", GetLastError());
        return 1;
    }

    wprintf(L"Waiting for client...\n");
    if (!ConnectNamedPipe(hPipe, nullptr)) {
        if (GetLastError() != ERROR_PIPE_CONNECTED) {
            wprintf(L"ConnectNamedPipe failed: %u\n", GetLastError());
            CloseHandle(hPipe);
            return 1;
        }
    }

    // 간단 에코 루프(프레이밍: 메시지 모드라 1:1)
    for (;;) {
        DWORD cbRead = 0; wchar_t buf[1024] = {};
        BOOL ok = ReadFile(hPipe, buf, sizeof(buf) - sizeof(wchar_t), &cbRead, nullptr);
        if (!ok) {
            DWORD e = GetLastError();
            if (e == ERROR_BROKEN_PIPE) { wprintf(L"Client disconnected.\n"); break; }
            wprintf(L"ReadFile failed: %u\n", e); break;
        }
        wprintf(L"Recv: %.*s\n", cbRead / 2, buf);

        DWORD cbWritten = 0;
        ok = WriteFile(hPipe, buf, cbRead, &cbWritten, nullptr);
        if (!ok) { wprintf(L"WriteFile failed: %u\n", GetLastError()); break; }
    }

    FlushFileBuffers(hPipe);
    DisconnectNamedPipe(hPipe);
    CloseHandle(hPipe);
    return 0;
}
```

### 1-3. 클라이언트(동기)

```cpp
// PipeClient_Sync.cpp
#include <windows.h>
#include <string>
#include <cstdio>

int wmain(int argc, wchar_t** argv) {
    const wchar_t* name = L"\\\\.\\pipe\\DemoPipe";

    wprintf(L"Connecting...\n");
    HANDLE h = CreateFileW(name, GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (h == INVALID_HANDLE_VALUE) {
        wprintf(L"CreateFile pipe failed: %u\n", GetLastError());
        return 1;
    }

    DWORD mode = PIPE_READMODE_MESSAGE;
    SetNamedPipeHandleState(h, &mode, nullptr, nullptr);

    const wchar_t* msg = argc > 1 ? argv[1] : L"Hello Pipe!";
    DWORD cbWritten = 0;
    WriteFile(h, msg, (DWORD)((wcslen(msg)+1)*2), &cbWritten, nullptr);

    wchar_t buf[1024] = {};
    DWORD cbRead = 0;
    BOOL ok = ReadFile(h, buf, sizeof(buf) - sizeof(wchar_t), &cbRead, nullptr);
    if (ok) { wprintf(L"Echo: %s\n", buf); }

    CloseHandle(h);
    return 0;
}
```

> **실무 팁**  
> - 메시지 모드면 **메시지 경계**가 보장되어 간편.  
> - 바이트 모드면 **길이 프리픽스(4byte)** 를 **반드시 직접 구현**.  
> - 동기 서버는 연결 대기/IO 동안 **블록** → UI 스레드 금지. 실제 앱은 **오버랩드** 사용.

---

### 1-4. 서버(오버랩드) — 다중 인스턴스 + IOCP 없이 처리 스케치

```cpp
// PipeServer_Overlapped.cpp (핵심만)
// - 인스턴스 구조체에 {HANDLE pipe, OVERLAPPED ov, enum State{Connecting, Reading, Writing}, buffers...}
// - WaitForMultipleObjects로 OVERLAPPED 완료(이벤트) 다루는 간단 패턴

struct PipeInst {
    HANDLE hPipe = INVALID_HANDLE_VALUE;
    OVERLAPPED ov{}; // ov.hEvent = CreateEvent
    enum class State { Connecting, Reading, Writing } state = State::Connecting;
    std::vector<BYTE> inBuf, outBuf;
    DWORD transferred = 0;
};

HANDLE CreateInstance(PipeInst& inst, const wchar_t* name) {
    inst.hPipe = CreateNamedPipeW(
        name, PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, 
        16, 64*1024, 64*1024, 0, nullptr);
    inst.ov = {};
    inst.ov.hEvent = CreateEventW(nullptr, TRUE, FALSE, nullptr);
    inst.state = PipeInst::State::Connecting;
    BOOL ok = ConnectNamedPipe(inst.hPipe, &inst.ov);
    if (!ok && GetLastError() == ERROR_IO_PENDING) return inst.ov.hEvent;
    if (!ok && GetLastError() == ERROR_PIPE_CONNECTED) {
        // 동기 연결됨
        SetEvent(inst.ov.hEvent);
        return inst.ov.hEvent;
    }
    // 실패
    return nullptr;
}

void ServerLoop() {
    const wchar_t* name = L"\\\\.\\pipe\\DemoPipe";
    std::vector<std::unique_ptr<PipeInst>> list(4);
    std::vector<HANDLE> events;

    for (auto& u : list) {
        u = std::make_unique<PipeInst>();
        HANDLE ev = CreateInstance(*u, name);
        events.push_back(ev);
    }

    for (;;) {
        DWORD i = WaitForMultipleObjects((DWORD)events.size(), events.data(), FALSE, INFINITE);
        if (i >= WAIT_OBJECT_0 && i < WAIT_OBJECT_0 + events.size()) {
            size_t idx = i - WAIT_OBJECT_0;
            auto& inst = *list[idx];
            ResetEvent(inst.ov.hEvent);

            DWORD bytes = 0;
            BOOL ok = GetOverlappedResult(inst.hPipe, &inst.ov, &bytes, FALSE);
            if (!ok && GetLastError()!=ERROR_PIPE_CONNECTED) {
                // 오류/끊김 → 인스턴스 재생성
                CloseHandle(inst.hPipe); CloseHandle(inst.ov.hEvent);
                list[idx] = std::make_unique<PipeInst>();
                events[idx] = CreateInstance(*list[idx], name);
                continue;
            }

            if (inst.state == PipeInst::State::Connecting) {
                // 첫 Read 시작
                inst.inBuf.resize(4096);
                inst.state = PipeInst::State::Reading;
                inst.ov = {}; inst.ov.hEvent = events[idx];
                DWORD dummy;
                BOOL r = ReadFile(inst.hPipe, inst.inBuf.data(), (DWORD)inst.inBuf.size(), &dummy, &inst.ov);
                if (!r && GetLastError()!=ERROR_IO_PENDING) {
                    // 클라이언트 종료 등 → 재생성
                    CloseHandle(inst.hPipe); CloseHandle(inst.ov.hEvent);
                    list[idx] = std::make_unique<PipeInst>();
                    events[idx] = CreateInstance(*list[idx], name);
                }
            } else if (inst.state == PipeInst::State::Reading) {
                // 에코 응답 준비
                inst.outBuf.assign(inst.inBuf.begin(), inst.inBuf.begin() + bytes);
                inst.state = PipeInst::State::Writing;
                inst.ov = {}; inst.ov.hEvent = events[idx];
                DWORD dummy;
                BOOL w = WriteFile(inst.hPipe, inst.outBuf.data(), (DWORD)inst.outBuf.size(), &dummy, &inst.ov);
                if (!w && GetLastError()!=ERROR_IO_PENDING) {
                    CloseHandle(inst.hPipe); CloseHandle(inst.ov.hEvent);
                    list[idx] = std::make_unique<PipeInst>();
                    events[idx] = CreateInstance(*list[idx], name);
                }
            } else { // Writing 완료 → 다시 Reading
                inst.state = PipeInst::State::Reading;
                inst.ov = {}; inst.ov.hEvent = events[idx];
                DWORD dummy;
                BOOL r = ReadFile(inst.hPipe, inst.inBuf.data(), (DWORD)inst.inBuf.size(), &dummy, &inst.ov);
                if (!r && GetLastError()!=ERROR_IO_PENDING) {
                    CloseHandle(inst.hPipe); CloseHandle(inst.ov.hEvent);
                    list[idx] = std::make_unique<PipeInst>();
                    events[idx] = CreateInstance(*list[idx], name);
                }
            }
        }
    }
}
```

> **포인트**  
> - **각 인스턴스**는 **자기 이벤트**(ov.hEvent)를 갖고, 완료 시 **상태 머신**으로 다음 I/O를 건다.  
> - 실제 서비스는 **IOCP**로 스케일(수백/수천 클라이언트). 위 코드는 **개념**/소규모용.

### 1-5. 프레이밍 — 길이 프리픽스(바이트 모드용)

```cpp
// 송신: [uint32_be length][payload...]
void PipeSendFramed(HANDLE h, const std::vector<BYTE>& payload) {
    uint32_t len = _byteswap_ulong((uint32_t)payload.size());
    DWORD w;
    WriteFile(h, &len, 4, &w, nullptr);
    WriteFile(h, payload.data(), (DWORD)payload.size(), &w, nullptr);
}

// 수신: 누적 버퍼에서 길이만큼 잘라 메시지 완성
bool PipeRecvFramed(HANDLE h, std::vector<BYTE>& accumulator, std::vector<std::vector<BYTE>>& outMsgs) {
    BYTE buf[4096]; DWORD r=0;
    BOOL ok = ReadFile(h, buf, sizeof(buf), &r, nullptr);
    if (!ok) return false;
    accumulator.insert(accumulator.end(), buf, buf+r);
    size_t pos=0;
    while (accumulator.size()-pos >= 4) {
        uint32_t len; memcpy(&len, &accumulator[pos], 4); len = _byteswap_ulong(len);
        if (accumulator.size()-pos < 4 + len) break;
        outMsgs.emplace_back(&accumulator[pos+4], &accumulator[pos+4+len]);
        pos += 4 + len;
    }
    if (pos > 0) accumulator.erase(accumulator.begin(), accumulator.begin()+pos);
    return true;
}
```

### 1-6. 보안 — SDDL/ACL & Impersonation

```cpp
// Everyone 읽기/쓰기 허용 파이프(데모용), 실전은 최소 권한으로!
// SDDL: D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GRGW;;;BU)
#include <sddl.h>
SECURITY_ATTRIBUTES MakePipeSA() {
    SECURITY_ATTRIBUTES sa{ sizeof(sa) };
    PSECURITY_DESCRIPTOR psd = nullptr;
    LPCWSTR sddl = L"D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GRGW;;;BU)";
    if (ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl, SDDL_REVISION_1, &psd, nullptr)) {
        sa.lpSecurityDescriptor = psd;
    }
    return sa; // 해제는 LocalFree(psd) 필요(핸들 생성 후)
}

// 서버에서 클라이언트 권한으로 파일 액세스가 필요할 때
// 1) ImpersonateNamedPipeClient(hPipe)
// 2) 작업 수행(클라이언트 토큰으로)
// 3) RevertToSelf()
```

> **주의**  
> - UWP/서비스/세션 간 권한 제한, AppContainer 등 고려.  
> - 네트워크 파이프는 **인증/암호화**가 필요하면 **SMB/도메인/네고**를 이해해야 함(범위 밖).

---

## 2) Memory-Mapped File(공유 메모리) — 초고속 IPC

### 2-1. 핵심 개념
- `CreateFileMapping` + `MapViewOfFile` 로 **커널 오브젝트**를 만들고 여러 프로세스에서 **동일한 이름**으로 열어 같은 물리 페이지를 공유.
- **파일 백킹**(대용량 파일 I/O) vs **페이지파일 백킹**(이름만 있는 공유 메모리, `INVALID_HANDLE_VALUE`).
- 동기화는 **별도 오브젝트(Event/Mutex/Semaphore/Section)** 가 필요. (메모리는 lock-free가 아님)

### 2-2. 간단 공유 메모리(문자열) + 이벤트 동기화

```cpp
// SharedMemWriter.cpp
#include <windows.h>
#include <cstdio>

int wmain() {
    const wchar_t* MAP_NAME = L"Local\\DemoSharedMem";
    const wchar_t* EVT_NAME = L"Local\\DemoSharedMemEvt";

    HANDLE hMap = CreateFileMappingW(INVALID_HANDLE_VALUE, nullptr, PAGE_READWRITE, 0, 4096, MAP_NAME);
    if (!hMap) { wprintf(L"CFM failed: %u\n", GetLastError()); return 1; }
    LPVOID p = MapViewOfFile(hMap, FILE_MAP_ALL_ACCESS, 0,0,0);
    if (!p) { wprintf(L"Map failed\n"); return 1; }

    HANDLE hEvt = CreateEventW(nullptr, FALSE, FALSE, EVT_NAME); // auto-reset
    if (!hEvt) { wprintf(L"Event failed\n"); return 1; }

    const wchar_t* msg = L"Hello Shared Memory!";
    wcscpy_s((wchar_t*)p, 2048, msg);

    SetEvent(hEvt);
    wprintf(L"Written & signaled.\n");
    Sleep(3000);

    UnmapViewOfFile(p);
    CloseHandle(hMap);
    CloseHandle(hEvt);
}
```

```cpp
// SharedMemReader.cpp
#include <windows.h>
#include <cstdio>

int wmain() {
    const wchar_t* MAP_NAME = L"Local\\DemoSharedMem";
    const wchar_t* EVT_NAME = L"Local\\DemoSharedMemEvt";

    HANDLE hMap = OpenFileMappingW(FILE_MAP_READ, FALSE, MAP_NAME);
    if (!hMap) { wprintf(L"OpenFileMapping failed: %u\n", GetLastError()); return 1; }
    LPCVOID p = MapViewOfFile(hMap, FILE_MAP_READ, 0,0,0);

    HANDLE hEvt = OpenEventW(SYNCHRONIZE, FALSE, EVT_NAME);
    if (!hEvt) { wprintf(L"OpenEvent failed\n"); return 1; }

    wprintf(L"Waiting...\n");
    WaitForSingleObject(hEvt, INFINITE);
    wprintf(L"Read: %s\n", (const wchar_t*)p);

    UnmapViewOfFile(p);
    CloseHandle(hMap);
    CloseHandle(hEvt);
}
```

### 2-3. 생산자-소비자(고속 큐) — 링버퍼 패턴

- 공유 메모리에 **헤더(원형 인덱스)** + **바디(바이트 배열)**.
- 멀티프로듀서/멀티컨슈머는 **Interlocked/Mutex** 로 보호. 단일-단일이면 **lock-free**도 가능.
- 프레이밍: `uint32 len + payload` 를 링 공간에 기록(랩핑 시 분할/패딩 처리).

```cpp
#pragma pack(push,1)
struct RingHeader {
    volatile LONG head; // write pos
    volatile LONG tail; // read pos
    LONG capacity;
};
#pragma pack(pop)

// 생산자: head/tail 읽어 공백 확인 → 데이터/len 기록 → head advancing (InterlockedExchangeAdd)
// 소비자: tail/head 읽어 데이터 유무 → len 읽고 payload 읽기 → tail advancing
// 동기화: Event (data-available), Event (space-available)로 블로킹/웨이크업
```

> **실무 팁**  
> - 크로스-아키텍처(32/64비트) 공유 시 **패킹/정렬/엔디언** 고정.  
> - 세션/데스크톱 경계를 넘어 공유할 때 **네임프리픽스(Local/Global)** 와 권한(UAC/IL) 확인.  
> - 대용량 파일 매핑은 **대량 I/O** 최적화(대페이지/시스템 캐시 영향) 고려.

---

## 3) 윈도우 메시지 기반 IPC — `WM_COPYDATA`/브로드캐스트

### 3-1. `WM_COPYDATA` 기본

- **동기** `SendMessage` 로 작은 버퍼(수 KB~수십 KB 권장)를 **복사**하여 전달.  
- 받는 쪽 윈도우 프로시저에서 `wParam`(보낸 HWND), `lParam`→`COPYDATASTRUCT*`.

```cpp
// Sender.cpp
#include <windows.h>
#include <string>

BOOL SendToWindow(HWND hTarget, UINT dwType, const void* data, SIZE_T cb) {
    COPYDATASTRUCT cds{ dwType, (DWORD)cb, (PVOID)data };
    LRESULT r = SendMessageW(hTarget, WM_COPYDATA, (WPARAM)GetConsoleWindow(), (LPARAM)&cds);
    return (r != 0);
}

// Receiver WndProc
LRESULT CALLBACK WndProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m == WM_COPYDATA) {
        auto* cds = (COPYDATASTRUCT*)l;
        if (cds->dwData == 1001) {
            // 예: UTF-16 문자열
            MessageBoxW(h, (LPCWSTR)cds->lpData, L"Recv", MB_OK);
            return TRUE; // 보내는 쪽 성공 신호
        }
    }
    return DefWindowProcW(h, m, w, l);
}
```

> **제한/주의**  
> - **UIPI**(사용자 인터페이스 접근 권한)로 인해 **높은 IL → 낮은 IL** 메시지는 차단될 수 있음. 동일 IL 권장.  
> - 너무 큰 버퍼는 지양(수십 KB 이상이면 공유 메모리 + HWND 로케이터가 낫다).  
> - 교착 방지: 상대가 `SendMessage`로 다시 나를 부르면 **락** → `PostMessage`/`SendNotifyMessage`/타임아웃 사용.

### 3-2. HWND 디스커버리 / 등록 메시지

```cpp
// 서로 합의한 클래스로 FindWindowW
HWND hTarget = FindWindowW(L"MyIpcWindowClass", nullptr);

// 혹은 RegisterWindowMessage로 채널 식별
UINT g_msgIpc = RegisterWindowMessageW(L"com.vendor.app.ipc.v1");
```

- `RegisterWindowMessage` 는 시스템 전역의 **유일한 ID** 를 부여 → 양측이 **같은 문자열**로 등록하면 **같은 ID**.
- `WM_COPYDATA` 대신 **커스텀 Registered Message** + **공유 메모리 핸들 전달** 조합도 흔함:
  - Sender: `CreateFileMapping` + `Map` + 채우기 → `DuplicateHandle` 로 Receiver에 넘길 수단(핸들 상속/ALPC/파이프/밸런스에 따라)  
  - 간단히는 **이름**을 메시지로 보낸 뒤 Receiver가 `OpenFileMapping` 으로 여는 패턴.

### 3-3. `SendMessageTimeout` 으로 방어

```cpp
DWORD_PTR result=0;
BOOL ok = SendMessageTimeoutW(hTarget, WM_COPYDATA, (WPARAM)hSelf, (LPARAM)&cds,
                              SMTO_ABORTIFHUNG | SMTO_BLOCK, 3000, &result);
if (!ok) { /* 타임아웃/Hung 방어 */ }
```

---

## 4) 프로토콜/프레이밍/계약(공통)

- **길이 프리픽스** + **버전/메시지 타입** 필수.  
- 구조체 공유 시 **`#pragma pack(push,1)`** 로 패킹 고정 또는 **직렬화(JSON/CBOR/Protobuf)** 권장.  
- **엔디언**은 little-endian 고정(Windows). 네트워크/크로스플랫폼 필요 시 big-endian 변환.

```cpp
#pragma pack(push,1)
struct MsgHeader {
    uint32_t magic;      // 'IPCH'
    uint16_t ver;        // 1
    uint16_t type;       // 1001:Ping, 1002:Data...
    uint32_t length;     // payload bytes
};
#pragma pack(pop)
```

---

## 5) 장애/취소/타임아웃/재시도(3 방식 공통 베스트 프랙티스)

1. **타임아웃 항상 부여**  
   - 파이프: `WaitForSingleObject`/오버랩드 완료 대기 시간 제한.  
   - 공유 메모리: 이벤트 대기 타임아웃.  
   - 메시지: `SendMessageTimeout`.

2. **재시도 정책**  
   - 대상 프로세스가 아직 안 떴을 수 있음 → 지수 백오프 + 최대 시한.  
   - 파이프 `WaitNamedPipeW` 로 서버 준비 대기.

3. **정리/취소**  
   - 핸들 누수 금지: 실패 경로에서 Close.  
   - 종료 시 신호(Event/Named Mutex)로 상대 루프 탈출.

4. **로깅/관측**  
   - 채널 이름, 상대 PID/TID(가능 시), 바이트 수, 지연, 실패코드.

---

## 6) Named Pipe — 요청/응답(RPC) 미니 프레임워크

### 6-1. 요청/응답: 헤더 + JSON/PB

```cpp
// PipeRpc.h — 공용 헤더
#pragma pack(push,1)
struct RpcHeader {
    uint32_t magic;      // 'PRPC'
    uint16_t ver;        // 1
    uint16_t cmd;        // 1:Sum, 2:Echo...
    uint32_t reqId;      // 매칭용
    uint32_t length;     // payload
};
#pragma pack(pop)

inline bool PipeSend(HANDLE h, const void* buf, DWORD cb) {
    DWORD w; return WriteFile(h, buf, cb, &w, nullptr) && w==cb;
}
inline bool PipeRecvExact(HANDLE h, void* buf, DWORD cb) {
    DWORD rTotal=0; BYTE* p=(BYTE*)buf;
    while (rTotal<cb) {
        DWORD r=0; if (!ReadFile(h, p+rTotal, cb-rTotal, &r, nullptr)) return false;
        if (r==0) return false; rTotal+=r;
    }
    return true;
}
```

### 6-2. 서버 핸들러 스케치

```cpp
// PipeRpcServer.cpp — 동기, 단일 클라 예시(개념)
void Serve(HANDLE h) {
    for (;;) {
        RpcHeader hdr{};
        if (!PipeRecvExact(h, &hdr, sizeof(hdr))) break;
        if (hdr.magic != 'PRPC') break;

        std::vector<BYTE> payload(hdr.length);
        if (hdr.length && !PipeRecvExact(h, payload.data(), hdr.length)) break;

        // 처리
        std::vector<BYTE> reply;
        uint16_t status = 0; // 0=OK
        if (hdr.cmd == 1 /*Sum*/) {
            // payload: {int32 a, int32 b}
            if (payload.size() < 8) status=1;
            else {
                int32_t a, b; memcpy(&a, &payload[0], 4); memcpy(&b, &payload[4], 4);
                int32_t sum = a + b;
                reply.resize(4); memcpy(reply.data(), &sum, 4);
            }
        } else status=404;

        // 응답 헤더
        RpcHeader rh{ 'PRPC', 1, (uint16_t)(0x8000 | status), hdr.reqId, (uint32_t)reply.size() };
        PipeSend(h, &rh, sizeof(rh));
        if (!reply.empty()) PipeSend(h, reply.data(), (DWORD)reply.size());
    }
}
```

### 6-3. 클라이언트 호출

```cpp
bool RpcSum(HANDLE h, uint32_t reqId, int32_t a, int32_t b, int32_t& out) {
    RpcHeader hdr{ 'PRPC', 1, 1, reqId, 8 };
    int32_t args[2] = { a, b };
    if (!PipeSend(h, &hdr, sizeof(hdr))) return false;
    if (!PipeSend(h, &args[0], 8)) return false;

    RpcHeader rh{};
    if (!PipeRecvExact(h, &rh, sizeof(rh))) return false;
    if (rh.magic!='PRPC' || rh.reqId!=reqId || (rh.cmd&0x8000)==0) return false;
    if (rh.length!=4) return false;
    if (!PipeRecvExact(h, &out, 4)) return false;
    return true;
}
```

> **확장**  
> - 오버랩드 + I/O 큐 → 동시 다중 요청.  
> - PB/CBOR/JSON으로 페이로드 인코딩.  
> - 인증/권한: `ImpersonateNamedPipeClient` 후 ACL 검사.

---

## 7) Memory-Mapped File — 대용량 전달(파일 없이)

### 7-1. “핸들 이름 전달 + 공유 보기” 패턴

- Sender가 `CreateFileMapping(INVALID_HANDLE_VALUE, …, size, L"Local\\DataX")`  
- Receiver는 **이름만** 받아 `OpenFileMapping`→`MapViewOfFile` 로 같은 페이지에 접속.  
- 이름 전달은 **WM_COPYDATA**(작은 문자열)로도 충분.

```cpp
// Sender: 이름을 메시지로 보내고, receiver가 OpenFileMapping
```

> **대안**: 보안적으로 더 엄격하려면 `DuplicateHandle` 로 정확한 핸들을 넘김(핸들 브로커 필요: 파이프/ALPC).

### 7-2. 세션/IL 이슈
- **Global\\** prefix는 관리자 권한/서비스 상호작용에서만.  
- 동일 사용자/세션/무결성 수준에서 가장 간단히 동작.

---

## 8) 윈도우 메시지 IPC — 고급

### 8-1. 브로드캐스트/탐색
- `EnumWindows` 로 특정 속성/클래스명을 가진 윈도우 탐색.  
- `RegisterWindowMessage(L"Vendor.App.Ipc")` 로 이벤트형 브로드캐스트 → 모든 상주 앱이 핸들러를 두면 응답.

### 8-2. 안전/위생
- 입력 검증: 길이/포맷/버전.  
- 비신뢰 발신자 차단: `GetWindowThreadProcessId` 로 PID 가져와 화이트리스트/사인 검사 가능(심화).

---

## 9) 오류/디버깅/테스트

- **PipeTest**: `pipelist`(Sysinternals), `PowerShell: Get-ChildItem \\.\pipe\*`.  
- **공유 메모리**: `Process Explorer` → Handles 보기.  
- 메시지: Spy++ 로 `WM_COPYDATA` 페이로드 확인(길이만).  
- 타임아웃 케이스: 상대 지연/죽음/세션 전환(Lock)/UIPI.

---

## 10) 성능/최적화

- 파이프 버퍼: `CreateNamedPipe` 의 in/out 버퍼 크기 조정.  
- 오버랩드: **동시 outstanding I/O** 수를 2~4 이상 유지(파이프라인).  
- 공유 메모리: 캐시 친화 구조체/연속 배치, false sharing 최소화.  
- 메시지: 대량이면 **공유 메모리 + 메시지 알림** 조합이 더 낫다.

---

## 11) 보안/권한 총정리

- 파이프/맵핑/이벤트 모두 **SDDL** 로 최소 권한 부여.  
- 세션 격리: 다른 세션 프로세스와는 기본적으로 직접 통신 어려움(서비스/세션0).  
- UIPI: 고무결성(High)→저무결성(Low) `SendMessage` 제한. 동일 IL 사용 또는 **공유 메모리 + 네임드 동기화**.

---

## 12) 통합 예: “빠른 대용량은 공유 메모리, 제어 채널은 파이프” 하이브리드

1) 파이프 RPC로 **세션 초기화/권한/핸드셰이크**  
2) 서버가 **공유 메모리 이름**(+ 이벤트 이름들) 제공  
3) 이후 대량 데이터는 공유 메모리로 밀고, 제어/에러/재협상은 파이프로 처리  
4) 종료 시 양쪽이 이벤트/파이프 Close로 정리

---

## 13) 체크리스트 (요약)

- [ ] **프레이밍**(길이/버전/타입) 일관  
- [ ] **타임아웃/재시도** + 지수 백오프  
- [ ] **동기화**(Event/Mutex/Semaphore) & 경쟁조건 제거  
- [ ] **SDDL/ACL/Impersonation** 로 최소 권한  
- [ ] **UIPI/세션/IL** 고려(메시지/Global 네임)  
- [ ] **리소스 정리/에러 경로** 철저  
- [ ] **로깅/관측성**: 바이트 수, 지연, 실패율  
- [ ] **부하 테스트/결함 주입**(상대 프로세스 다운/지연/대량 전송/세션 전환)

---

## 부록 A) 유틸 — 실패시 문자열

```cpp
std::wstring LastErr() {
    DWORD e = GetLastError();
    LPWSTR p=nullptr; FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
                                     nullptr,e,0,(LPWSTR)&p,0,nullptr);
    std::wstring s = p ? p : L"(unknown)";
    if (p) LocalFree(p);
    return s;
}
```

## 부록 B) 예제: WM_COPYDATA + 공유 메모리 조합

```cpp
// Sender: 공유 메모리 이름을 WM_COPYDATA로 보냄
struct MemInfo { wchar_t name[64]; DWORD size; };
MemInfo mi{}; wcscpy_s(mi.name, L"Local\\BulkBuf"); mi.size = 8*1024*1024;
COPYDATASTRUCT cds{ 0xBEEF, sizeof(mi), &mi };
SendMessageTimeoutW(hTarget, WM_COPYDATA, (WPARAM)hSelf, (LPARAM)&cds, SMTO_BLOCK, 2000, &res);

// Receiver: OpenFileMapping + MapViewOfFile → 데이터 읽기
```

## 부록 C) 빌드 스위치/Manifest

- `/DUNICODE /D_UNICODE`, `/permissive-` 추천  
- DPI/UIPI 관련 매니페스트는 **메시지 IPC** 접근에 영향 가능  
- 관리자 권한/High-IL 필요 시 매니페스트 `<requestedExecutionLevel level="requireAdministrator"/>` (신중)

---

### 마무리

- **Named Pipe**: 표준적, 탄탄한 RPC 채널(원격 가능). **오버랩드 + 상태머신**을 배우면 대부분의 니즈 해결.  
- **Memory-Mapped File**: **최고 성능**. 핵심은 **올바른 동기화/프레이밍**.  
- **윈도우 메시지**: **작고 단순한 신호/데이터** 전달에 최고. 한계를 넘어서면 **공유 메모리와 결합**.