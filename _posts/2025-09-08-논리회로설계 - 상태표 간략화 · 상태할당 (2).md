---
layout: post
title: 논리회로설계 - 상태표 간략화 · 상태할당 (2)
date: 2025-09-08 21:25:23 +0900
category: 논리회로설계
---
# 상태표 간략화·상태할당 — **등가 순서회로**, **불완전 명세 상태표(ISM) 간략화**, **플립플롭 입력식 유도**

> 표기: 입력 \(x\in\{0,1\}\), 출력 \(y\), 상태(벡터) \(\mathbf{Q}\), 다음상태 \(\mathbf{Q}^+\).  
> 모델: **클럭형 순서회로**(Mealy/Moore). 합성과 검증을 염두에 둔 **실무 절차** 중심.

---

## 1. 등가 순서회로 (Equivalent Sequential Circuits)

### 1.1 정의 — 행동 등가성과 상태 대응
- **Moore 등가**: 모든 입력열 \(x[0:\infty)\)에 대해 두 기계 \(\mathcal{M}_1,\mathcal{M}_2\)의 출력열 \(y[0:\infty)\)가 동일.  
- **Mealy 등가**: 각 시점 \(k\)에서 \(\lambda_1(s_1[k],x[k])=\lambda_2(s_2[k],x[k])\) 이고, 전이도 **상태 대응 관계** \(R\subseteq S_1\times S_2\)를 따라 보존됨.
- **바이시뮬레이션(bisimulation)** 관점:  
  \[
  (p,q)\in R \Rightarrow 
  \begin{cases}
  \text{Moore: } y_1(p)=y_2(q)\\
  \forall x:\ (\delta_1(p,x),\,\delta_2(q,x))\in R
  \end{cases}
  \]
  (Mealy는 출력 비교에 \(x\) 포함)

### 1.2 등가 판정 기법(현장에서 쓰는 3가지)
1) **직접 곱(Product) 관찰자**:  
   두 FSM의 병렬 조합 \(S_1\times S_2\)에서 “출력 불일치”를 **에러 상태 \(E\)** 로 전이시키는 FSM을 만들고, 리셋에서 \(E\) 도달 여부를 확인.
2) **최소화 후 비교**:  
   각 FSM을 최소화(§3·§4) → **동형성** 검사(상태 재명명만 다른지).
3) **구별 입력열 찾기**(테스팅 이론):  
   **Distinguishing Sequence** 또는 \(W\)-method로 두 FSM을 분리시키는 짧은 입력열을 탐색.

### 1.3 등가 변환들(안전 변형, 기능 동일)
- **상태 재명명/상태할당 변경**: 인코딩만 바뀜.  
- **조합식 대수 간략화/인수화**: 논리 동일 변환.  
- **레지스터 재타이밍**: 기능 보존, 타이밍만 변화.  
- **Mealy 출력 레지스터링**: 1클럭 지연을 명세에 포함하면 외부 관측 상 등가.

---

## 2. 불완전 명세 상태표(ISM) — **don’t-care로 더 크게 줄이기**

> 목표: **미정(–)** 을 don’t-care로 활용해 **상태 수/로직**을 줄이되, **Self-start/Lockout 방지**가 최우선.

### 2.1 미정의 유형
- **불가능 입력 조합**(프로토콜 제약), **출력 don’t-care**, **다음상태 미지정**, **불법 상태 코드**.

### 2.2 핵심 개념 — **호환(Compatibility)**와 **닫힌 커버(Closed Cover)**
- 두 상태 \(P,Q\)가 **호환**:  
  정의된 입력에서 출력이 같고, 전이의 다음상태 쌍이 **재귀적으로 호환**. (미정은 제약 없음)
- **최대 호환집합**을 만들고, 그 중 전이가 집합 내부로 닫히는 **닫힌 커버**를 선택 → 병합.

### 2.3 도구 A — **함의(임플리케이션) 차트**
- 셀 = 상태쌍 \((P,Q)\) (정렬).  
- **초기 ×**: (Moore) 노드 출력 다르면 ×, (Mealy) **어느 입력에서든** 간선 출력 다르면 ×.  
- 각 셀에 모든 입력 \(x\)에 대해  
  \[
  (P,Q)\Rightarrow\big(\delta(P,x),\delta(Q,x)\big)
  \]
  를 기록. **참조 셀**이 ×이면 **자기도 ×**(귀류) — 변화 없을 때까지 반복.  
- 남은(× 아닌) 셀 = **호환** → 병합 후보.

### 2.4 도구 B — **호환 그래프/클릭·닫힘**
- 정점=상태, 간선=호환.  
- **클릭(완전 부분그래프)** 가 호환집합, 이들 중에 전이가 집합 내로만 향하는 **닫힌 커버**를 선택.

### 2.5 Worked Example — Moore ISM을 5→3상태로

**부분 명세**(출력: \(y(A)=y(B)=y(C)=y(E)=0,\ y(D)=1\))

| 현재 | x=0 → | x=1 → |
|:--:|:--:|:--:|
| A | B | – |
| B | – | D |
| C | B | – |
| D | D | – |
| E | – | A |

1) **도달성**: 리셋=A. A→B, B→D, D→D. 또한 E—1→A로 수렴 경로. **모두 유지**.  
2) **초기 ×**: D vs (A,B,C,E) (출력 불일치) 전부 ×.  
3) 차트 전파 결과 **호환**: (A,C), (A,E), (C,E).  
4) **닫힌 커버**: \(\{ACE\},\{B\},\{D\}\).  
5) **미정 채움(안전)**: A,1→A / B,0→A / C,1→A / E,0→A / D,1→D.

**축약 FSM(3상태)**

| 현재 | x=0 → | x=1 → | 출력 |
|:--:|:--:|:--:|:--:|
| \(S_0=ACE\) | \(S_1\) | \(S_0\) | 0 |
| \(S_1=B\)   | \(S_0\) | \(S_2\) | 0 |
| \(S_2=D\)   | \(S_2\) | \(S_2\) | 1 |

→ **상태 5→3**, 미정 채움으로 **닫힘·Self-start** 확보.

---

## 3. 연쇄 분할(Partition Refinement) — **Moore 최소화 표준**

### 3.1 절차 요약
1) **출력으로 1차 분할**: \(P_0=\{\text{동일 출력 상태 묶음}\}\).  
2) **세분화 반복**: 같은 묶음의 \(p,q\)가 모든 입력 \(x\)에 대해 \(\delta(p,x)\)와 \(\delta(q,x)\)가 **동일 묶음**으로 향하지 않으면 분리.  
3) 고정점 도달 시 각 묶음이 등가 클래스.

### 3.2 소형 예(요지)
- \(A,B,C:0;\ D:1\).  
- 전이: \(A:0\to B,1\to C\), \(B:0\to B,1\to D\), \(C:0\to B,1\to C\), \(D:0\to B,1\to D\).  
- 결과: \(\{A,C\}\mid\{B\}\mid\{D\}\) → \(A\equiv C\).

---

## 4. 상태할당(State Assignment) — **조합로직을 줄이는 코딩**

### 4.1 선택지와 지침
- **원-핫(One-hot)**: 상태수 \(N\)개의 FF. 다음상태식 단순, FPGA 고속.  
- **이진(Binary)**: \(\lceil\log_2N\rceil\) FF. ASIC·면적 절약.  
- **그레이(Gray)**: 인접 전이 해밍거리 1 → 해저드/EMI 감소.  
- **Moore 출력 비트화**: 상태코드의 MSB 등으로 **출력을 직접 표현**해 출력 로직 제거.

### 4.2 인접(휴프만) 휴리스틱
1) **인접 그래프**: 전이가 잦은 상태쌍에 **가중치**.  
2) **하이퍼큐브 배치**: 가중치 큰 쌍을 **해밍거리 1**로.  
3) **검증**: 후보 인코딩별 합성(팬인/지연/셀 수) 비교.

**예(§2 축약 FSM)**: \(S_0=00,\ S_1=01,\ S_2=10\) — \(S_0\leftrightarrow S_1\), \(S_1\leftrightarrow S_2\)가 해밍거리 1.

---

## 5. 플립플롭 입력식 유도 — **암기 공식 + 완전 전개 예시**

### 5.1 암기 공식
상태코드 \(\mathbf{Q}=(Q_{n-1}\dots Q_0)\), 다음상태 \(\mathbf{Q}^+=(Q_{n-1}^+\dots Q_0^+)\).

\[
\boxed{
\begin{aligned}
&\textbf{D:}\ \ D_i = Q_i^+\\
&\textbf{T:}\ \ T_i = Q_i \oplus Q_i^+\\
&\textbf{JK:}\ \ J_i=\overline{Q_i}\,Q_i^+,\quad K_i=Q_i\,\overline{Q_i^+}\\
&\textbf{SR:}\ \ S_i=\overline{Q_i}\,Q_i^+,\quad R_i=Q_i\,\overline{Q_i^+}\ \ (\text{금지 }S=R=1\ \text{없어야})
\end{aligned}}
\]

### 5.2 Worked Example — §2의 3상태 Moore(이진 인코딩)

**할당**: \(S_0=00,\ S_1=01,\ S_2=10\), 입력 \(x\).

| 현재 \(Q_1Q_0\) | x | 다음 \(Q_1^+Q_0^+\) |
|:--:|:--:|:--:|
| 00 | 0 | 01 |
| 00 | 1 | 00 |
| 01 | 0 | 00 |
| 01 | 1 | 10 |
| 10 | 0 | 10 |
| 10 | 1 | 10 |

- **\(Q_1^+\)**: \(01,x=1\) 또는 \(10, *\) →  
  \(Q_1^+ = \overline{Q_1}Q_0x + Q_1\overline{Q_0}\)
- **\(Q_0^+\)**: \(00,x=0\) →  
  \(Q_0^+ = \overline{Q_1}\,\overline{Q_0}\,\overline{x}\)

**D-FF 입력**
\[
\boxed{
D_1 = Q_1\overline{Q_0} + \overline{Q_1}Q_0x,\quad
D_0 = \overline{Q_1}\,\overline{Q_0}\,\overline{x}}
\]

**JK-FF 입력** (직접 변환)
\[
\boxed{
\begin{aligned}
J_1&=\overline{Q_1}\,Q_1^+ = \overline{Q_1}Q_0x,\quad
K_1=Q_1\,\overline{Q_1^+}\ \Rightarrow\ K_1=Q_1Q_0\ (\text{K-맵 정리})\\
J_0&=\overline{Q_0}\,Q_0^+ = \overline{Q_0}\,\overline{Q_1}\,\overline{x},\quad
K_0=Q_0\,\overline{Q_0^+} = Q_0
\end{aligned}}
\]

**T-FF 입력** (토글 조건 관점이 단순)
\[
T_1 = Q_1 \oplus (Q_1\overline{Q_0} + \overline{Q_1}Q_0x),\quad
T_0 = Q_0 \oplus (\overline{Q_1}\,\overline{Q_0}\,\overline{x})
\]
> 실무에선 T식은 **K-맵**으로 정리해 팬인을 낮춘다.

### 5.3 원-핫 인코딩일 때(자주 쓰는 형태)
상태 FF가 곧 \(S_j\) 이고,
\[
S_j^+ = \bigvee_{(i,x):\,\delta(S_i,x)=S_j}\big(S_i\cdot \chi_x\big),
\quad D_{S_j}=S_j^+
\]
Moore 출력은 \(y=\sum S_j c_j\). 대부분 항이 팬인 2~3으로 끝난다.

---

## 6. 구현 스니펫 — 합성 친화 코드

### 6.1 VHDL (3상태 Moore, 이진 인코딩 고정)

```vhdl
library ieee; use ieee.std_logic_1164.all;
entity fsm_moore_bin is
  port (clk, rst, x: in std_logic; y: out std_logic);
end;
architecture rtl of fsm_moore_bin is
  signal q1,q0, d1,d0: std_logic := '0';
begin
  -- D 입력(§5.2)
  d1 <= (q1 and (not q0)) or ((not q1) and q0 and x);
  d0 <= (not q1) and (not q0) and (not x);

  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then q1 <= '0'; q0 <= '0';
      else            q1 <= d1;  q0 <= d0;
      end if;
    end if;
  end process;

  -- Moore 출력: S2=10
  y <= '1' when (q1='1' and q0='0') else '0';
end;
```

### 6.2 VHDL (원-핫, ISM 안전 기본값 포함)

```vhdl
library ieee; use ieee.std_logic_1164.all;
entity fsm_onehot is
  port (clk,rst,x: in std_logic; y: out std_logic);
end;
architecture rtl of fsm_onehot is
  signal S0,S1,S2: std_logic := '1','0','0'; -- S0=ACE, S1=B, S2=D
  signal nS0,nS1,nS2: std_logic;
begin
  -- next state (원-핫: AND/OR 조합)
  nS0 <= (S0 and x) or (S1 and (not x));  -- S0<-S0(1) or S1(0)
  nS1 <= (S0 and (not x));                -- S1<-S0(0)
  nS2 <= (S1 and x) or S2;                -- S2<-S1(1) or hold

  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then S0<='1'; S1<='0'; S2<='0';
      else            S0<=nS0; S1<=nS1; S2<=nS2;
      end if;
    end if;
  end process;

  y <= S2; -- Moore 출력
end;
```

### 6.3 SystemVerilog — **Product 관찰자**로 등가 검증 스텁

```systemverilog
module fsm_equiv_checker(input logic clk, rst, x);
  // DUT 1
  logic y1; logic [1:0] s1;
  // DUT 2
  logic y2; logic [1:0] s2;

  dut_impl1 u1(.clk, .rst, .x, .y(y1), .state(s1));
  dut_impl2 u2(.clk, .rst, .x, .y(y2), .state(s2));

  // 관찰자: 출력 불일치 시 에러 플래그
  logic err;
  always_ff @(posedge clk) begin
    if (rst) err <= 1'b0;
    else     err <= err | (y1 ^ y2);
  end

  // 단순 SVA
  // 리셋 이후 언제나 y1==y2 여야 함
  property outputs_match; @(posedge clk) disable iff (rst) (y1==y2); endproperty
  assert property(outputs_match);
endmodule
```

---

## 7. 실무 체크리스트

- [ ] **도달성**으로 죽은 상태 삭제(최소화 1단계).  
- [ ] ISM이면 **함의 차트/호환 그래프**로 최대 호환집합→**닫힌 커버** 선택.  
- [ ] **Self-start/Lockout 방지**: 불법 상태·미정 입력도 **안전 귀결**(IDLE/ERR)로 채움.  
- [ ] 상태할당: 잦은 전이는 **해밍거리 1**, Moore는 **출력 비트 내장** 고려.  
- [ ] FF 입력 유도: 먼저 \(Q_i^+\)를 K-맵으로 최소화 → \(D/T/JK/SR\) 공식 적용.  
- [ ] Mealy 출력은 외부로 나갈 때 **등록**(글리치/타이밍 여유).  
- [ ] 합성 결과(셀 수/팬인/지연) 비교로 인코딩 선택 검증.

---

## 8. 연습 문제(원하면 해설 제공)

1) **Mealy ISM** 6상태 FSM에 대해 함의 차트로 호환쌍을 찾고 최소화하라.  
2) §2 예제를 **원-핫**과 **이진** 인코딩으로 각각 합성했을 때 LUT/FF/최대 주파수를 비교하라.  
3) §5의 JK-FF 유도를 그대로 따라가 \(K_1\)을 **K-맵**으로 단 1항으로 줄이는 과정을 전개하라.  
4) **Product 관찰자**에 “전이 불일치” 감지도 추가해, 두 FSM의 **전이 구조**까지 등가인지 검증하라.  
5) ISM에서 **닫힌 커버**를 고르지 않았을 때 발생 가능한 **락아웃** 시나리오를 설계하고 시뮬레이션으로 재현하라.

---

### 포켓 요약
- **등가 FSM**: 출력·전이 보존(바이시뮬레이션) 관점. 최소화 후 동형이면 동일.  
- **ISM 최소화**: 호환/닫힌 커버로 병합, 미정은 안전 귀결로 채워 **Self-start**.  
- **상태할당**: 원-핫(단순/FPGA), 이진(FF 절약/ASIC), 그레이(해저드↓).  
- **FF 입력식**: \(\;D=Q^+\), \(\;T=Q\oplus Q^+\), \(\;J=\overline{Q}Q^+\), \(\;K=Q\overline{Q^+}\), \(\;S=\overline{Q}Q^+\), \(\;R=Q\overline{Q^+}\;\).  
- **Mealy 출력 등록**, **불법 상태 복구**, **도달성→등가 병합→상태할당** 순으로 진행하면 안전하고 작다.