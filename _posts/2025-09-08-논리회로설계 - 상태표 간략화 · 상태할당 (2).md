---
layout: post
title: 논리회로설계 - 상태표 간략화 · 상태할당 (2)
date: 2025-09-08 21:25:23 +0900
category: 논리회로설계
---
# 상태표 간략화·상태할당 — **등가 순서회로**, **불완전 명세 상태표의 간략화(ISM)**, **플립플롭 입력식 유도**

> 표기: 입력 \(x\in\{0,1\}\), 출력 \(y\), 상태(벡터) \(\mathbf{Q}\), 다음상태 \(\mathbf{Q}^+\).  
> 모델: **클럭형 순서회로**(Mealy/Moore). 합성과 검증을 염두에 둔 **실무 절차** 중심으로 설명합니다.

---

## 1) 등가 순서회로 (Equivalent Sequential Circuits)

### 1.1 정의(행동 등가성)
- **Moore 등가**: 두 기계 \(\mathcal{M}_1,\mathcal{M}_2\)가 모든 입력열 \(x[0:\infty)\)에 대해 **동일 출력열** \(y[0:\infty)\)을 내면 **등가**.  
- **Mealy 등가**: 모든 시점 \(k\)에서 \(\lambda_1(s_1[k],x[k])=\lambda_2(s_2[k],x[k])\)이면서 다음상태 전이도 일치하도록 **상태 대응 관계** \(R\subseteq S_1\times S_2\)가 존재.

> 실무적으로는 “**출력·전이 보존하는 상태 대응(바이시뮬레이션)**”이 있으면 등가.

### 1.2 등가 증명 기법
1) **직접 곱(Product machine)**: 두 기계의 차이를 **에러 상태**로 보내는 관찰자 FSM을 만들어 **도달 가능 여부**로 판정.  
2) **상태 최소화 후 비교**: 두 FSM을 각각 최소화 → **정규형**의 동형 여부로 판단.  
3) **검증 패턴**: 구별 입력열(“**distinguishing sequence**”) 존재 여부로 판정(테스팅 이론의 \(W\)-method 등).

### 1.3 등가 변환(안전 변형)
- **상태 재명명/상태할당 변경**: 인코딩만 바꿀 뿐 행동은 불변.  
- **조합 로직 대수 간략화/인수화**: 기능 보존.  
- **레지스터 재타이밍**: 조합/레지스터 경계 이동(동작은 동일, 타이밍만 변화).  
- **출력 레지스터링(Mealy→등록)**: 외부 관측 시 한 클럭 지연을 **명세에 포함**하면 등가.

---

## 2) 불완전 명세 상태표의 간략화 (Incompletely Specified Machines, ISM)

> **미정(–)** 항목을 **don’t-care**로 활용해 **상태 최소화**와 **로직 축소**를 노립니다. 단, **Self-start/Lockout 방지**가 우선.

### 2.1 미정의 유형
- **불가능 입력 조합**(환경 제약), **출력 don’t-care**, **다음상태 미지정**, **불법 상태 코드**.

### 2.2 핵심 개념 — **호환(Compatibility)** 과 **닫힌 커버(Closed Cover)**
- 두 상태 \(P,Q\)가 **호환**: 정의된 입력에 대해 **출력이 같고**, 전이의 다음상태 쌍이 **재귀적으로 호환**이면 OK. (미정 입력은 제약 없음)  
- **최대 호환집합(Maximal compatibles)** 을 찾고, 그 중 **닫힌 커버**(커버 내부 전이가 다시 커버 안으로 돌아오는 집합)를 선택해 **병합**.

### 2.3 도구 ① — **함의(임플리케이션) 차트**
- 삼각표의 셀을 상태쌍 \((P,Q)\)로 채움.  
- **초기 ×**: (Moore) 출력이 다르면 ×, (Mealy) 어떤 입력에서든 간선 출력이 다르면 ×.  
- 각 셀에 “\((P,Q)\Rightarrow(\delta(P,x),\delta(Q,x))\)” **함의 목록**을 적고, 참조 셀에 ×가 생기면 **전파**.  
- 남은(× 아닌) 쌍은 **호환** → 병합 후보.

### 2.4 도구 ② — **호환 그래프/폐포**
- 정점=상태, 간선=호환.  
- **클릭(완전 부분그래프)** 가 호환집합 후보, 이 중 **닫힌 커버**를 선택.

### 2.5 Worked Example (Moore, ISM)

초기 **부분 명세** (상태 \(A,B,C,D,E\), 입력 \(x\in\{0,1\}\), 출력 \(y()\)):

- 출력: \(y(A)=0, y(B)=0, y(C)=0, y(D)=1, y(E)=0\)

| 현재 | x=0 → | x=1 → |
|:--:|:--:|:--:|
| A | B | – |
| B | – | D |
| C | B | – |
| D | D | – |
| E | – | A |

1) **도달성**: 리셋=A. A→B, (x=1 미정), B→D( x=1 ), D→D, C/E는 아직 불명이나 **E—x=1→A**로 루프에 들어옴 → **모두 유지** (Self-start 설계 관점에서 복귀 가능).  
2) **함의 차트 초기 ×**: D(출력 1) vs (A,B,C,E)(출력 0) 쌍은 모두 ×.  
3) **함의 기록·전파**로 남는 쌍: \((A,C)\), \((A,E)\), \((C,E)\) **호환**.  
4) **닫힌 커버 선택**: \(\{ACE\},\{B\},\{D\}\) (모든 전이가 이 세 집합 내부로 닫히도록 미정 채움).  
5) **미정 채우기(안전 규칙)**:
   - \(A, x=1\Rightarrow A\) (IDLE 루프)  
   - \(B, x=0\Rightarrow ACE\) 중 \(A\) (가장 안전)  
   - \(C, x=1\Rightarrow A\), \(E, x=0\Rightarrow A\)  
   - \(D, x=1\Rightarrow D\) (닫힘)

축약 결과(3상태 Moore): \(\{S_0=ACE, S_1=B, S_2=D\}\)

| 현재 | x=0 → | x=1 → | 출력 |
|:--:|:--:|:--:|:--:|
| \(S_0\) | \(S_1\) | \(S_0\) | 0 |
| \(S_1\) | \(S_0\) | \(S_2\) | 0 |
| \(S_2\) | \(S_2\) | \(S_2\) | 1 |

→ **상태 5→3으로 최소화**, 미정 채움으로 **닫힘·Self-start** 확보.

> **Mealy ISM**도 동일하되 “출력 비교”가 **간선 라벨** 기준이라는 점만 다릅니다.

---

## 3) 상태할당(State Assignment) — 간략 요령

- **원-핫**(FPGA 친화): 각 상태=1 FF. 다음상태식이 단순(SOP 한두 항).  
- **이진**(ASIC·FF 절약): \(\lceil\log_2 N\rceil\) FF. **인접 전이=해밍거리 1** 되도록 배치(해저드/팬인 감소).  
- **그레이**: 순환/시퀀스형에서 인접 전이 1비트 변화 보장.  
- **출력 지향(Moore)**: 출력 비트를 **상태코드에 포함**해 출력 로직 제거.

> 위 예(3상태 Moore)에 **이진 2비트** 할당: \(S_2(출력1)=10\), \(S_1=01\), \(S_0=00\) (그레이스러운 배치: \(S_0\leftrightarrow S_1\), \(S_1\leftrightarrow S_2\)가 해밍거리 1)

---

## 4) 플립플롭 입력식의 유도 (FF Input Equation Derivation)

### 4.1 일반 레시피 (암기 공식)
상태코드 \(\mathbf{Q}=(Q_{n-1}\dots Q_0)\), 다음상태 \(\mathbf{Q}^+=(Q_{n-1}^+\dots Q_0^+)\).

- **D-FF**: \(\boxed{D_i = Q_i^+}\)  
- **T-FF**: \(\boxed{T_i = Q_i \oplus Q_i^+}\)  
- **JK-FF**: \(\boxed{J_i = \overline{Q_i}\,Q_i^+, \quad K_i = Q_i\,\overline{Q_i^+}}\)  
- **SR-FF**(금지 \(S=R=1\)): \(\boxed{S_i = \overline{Q_i}\,Q_i^+, \quad R_i = Q_i\,\overline{Q_i^+}}\)

> 이후 \(Q_i^+\)를 \(Q\)와 입력 \(x\)의 부울식으로 표현해 **K-맵** 또는 대수 간략화.

### 4.2 Worked Example — §2의 축약 FSM(이진 인코딩)

할당: \(S_0=00, S_1=01, S_2=10\). 입력 \(x\).

상태표를 **비트 전이**로 전개:

| 현재 \(Q_1Q_0\) | x | 다음 \(Q_1^+Q_0^+\) |
|:--:|:--:|:--:|
| 00 | 0 | 01 |
| 00 | 1 | 00 |
| 01 | 0 | 00 |
| 01 | 1 | 10 |
| 10 | 0 | 10 |
| 10 | 1 | 10 |

#### (1) \(Q_1^+\) 식
1이 되는 케이스: \(01,x=1\) 또는 \(10, x=0/1\) → 집합적으로  
\[
Q_1^+ = \underbrace{(\overline{Q_1}Q_0x)}_{\text{01,1}} \;+\; \underbrace{Q_1\overline{Q_0}}_{\text{10,*}}
\]
간략화 여지: \(Q_1\overline{Q_0}\) 항이 **우세**.

#### (2) \(Q_0^+\) 식
1이 되는 케이스: \(00,x=0\) →  
\[
Q_0^+ = \overline{Q_1}\,\overline{Q_0}\,\overline{x}
\]

#### (3) **D-FF** 입력
\[
\boxed{
\begin{aligned}
D_1 &= Q_1\overline{Q_0} + \overline{Q_1}Q_0x\\
D_0 &= \overline{Q_1}\,\overline{Q_0}\,\overline{x}
\end{aligned}}
\]

#### (4) **T-FF** 입력
\[
\begin{aligned}
T_1 &= Q_1 \oplus D_1
    = Q_1 \oplus (Q_1\overline{Q_0} + \overline{Q_1}Q_0x) \\
    &\Rightarrow \text{K-맵으로 정리 권장(직접 전개 시 항 증가)}\\[4pt]
T_0 &= Q_0 \oplus D_0
    = Q_0 \oplus (\overline{Q_1}\,\overline{Q_0}\,\overline{x})
\end{aligned}
\]
> **팁**: T식은 **변해야 할 때만 1**이므로 “토글 조건” 관점으로 K-맵을 다시 그리면 간단해집니다.

#### (5) **JK-FF** 입력
\[
\boxed{
\begin{aligned}
J_1 &= \overline{Q_1}\,Q_1^+ = \overline{Q_1}(Q_1\overline{Q_0} + \overline{Q_1}Q_0x) = \overline{Q_1}Q_0x\\
K_1 &= Q_1\,\overline{Q_1^+} = Q_1\,\overline{Q_1\overline{Q_0} + \overline{Q_1}Q_0x}
    = Q_1(\overline{\overline{Q_0}} \cdot \overline{\overline{Q_1}Q_0x})
    = Q_1(Q_0 + \overline{Q_0 + x}) \\
    &\Rightarrow \text{K-맵으로 }K_1 = Q_1Q_0 \;\;(\text{간단})\\[6pt]
J_0 &= \overline{Q_0}\,Q_0^+ = \overline{Q_0}\,\overline{Q_1}\,\overline{x}\\
K_0 &= Q_0\,\overline{Q_0^+} = Q_0\,(Q_1 + Q_0 + x) = Q_0
\end{aligned}}
\]
해석:  
- \(K_0=Q_0\): \(Q_0=1\)이면 **리셋 필요**(다음이 0)라는 의미와 일치(표에서 \(Q_0=1\)인 상태는 \(10\)뿐이며 거기서 계속 0 유지).  
- \(J_1=\overline{Q_1}Q_0x\): \(01\)에서 \(x=1\)일 때만 세트.  
- \(K_1=Q_1Q_0\): \(11\)는 **불법**이나 self-start 설계 시에도 안정(강제 리셋)됨.

#### (6) **SR-FF** 입력
\[
S_i=\overline{Q_i}Q_i^+,\quad R_i=Q_i\overline{Q_i^+}
\]
→ JK 결과와 동일 형태가 나오며, **금지(S=R=1)**가 **어느 조합에서도 발생하지 않는지** 반드시 확인.

### 4.3 K-맵 절차 요약(이진 인코딩)
1) **축:** 상태비트(\(Q_1,Q_0\))와 입력(\(x\)).  
2) 각 \(Q_i^+\)에 대해 1/0을 채우고, **불법/미정**은 **don’t-care \(d\)** 로.  
3) **최소 커버**(큰 묶음)로 SOP/POS 도출 → D/T/JK/SR로 변환.

### 4.4 원-핫 인코딩일 때
- 상태 \(S_j\in\{0,1\}\)가 **그대로 FF**. 다음상태:
\[
S_j^+ = \bigvee_{(i,x):\delta(S_i,x)=S_j} (S_i\cdot \chi_x)
\]
- **D-FF**: \(D_{S_j}=S_j^+\).  
- **출력(Moore)**: \(y=\sum S_j\cdot c_j\) (상태별 상수).  
- **장점**: 대부분 항이 **팬인 2~3**로 끝나 **합성에 유리**.

---

## 5) VHDL 스니펫 (상태할당 명시 & FF 입력 자동 유도)

```vhdl
-- Moore FSM (3-state), binary assignment: S0=00, S1=01, S2=10
library ieee; use ieee.std_logic_1164.all;
entity fsm_moore_bin is
  port (clk, rst, x: in std_logic; y: out std_logic);
end;
architecture rtl of fsm_moore_bin is
  signal q1,q0, d1,d0: std_logic := '0';
begin
  -- next-state (D inputs) from §4.2
  d1 <= (q1 and (not q0)) or ((not q1) and q0 and x);
  d0 <= (not q1) and (not q0) and (not x);

  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then q1 <= '0'; q0 <= '0';
      else            q1 <= d1;  q0 <= d0;
      end if;
    end if;
  end process;

  y <= '1' when (q1='1' and q0='0') else '0'; -- S2=10
end;
```

> **합성기 힌트**로 상태코드를 지정하려면 enum 타입+`attribute enum_encoding`을 사용하세요(도구별 문법 상이).

---

## 6) 체크리스트

- [ ] **도달성** 먼저 정리(죽은 상태 제거).  
- [ ] ISM이면 **함의 차트/호환 그래프**로 **최대 호환집합**→**닫힌 커버** 선택.  
- [ ] **Self-start/Lockout 방지**: 모든 상태에서 합법 루프로 수렴하도록 미정 채움.  
- [ ] 상태할당은 **인접 전이=해밍거리 1** 우선, Moore는 **출력 비트 내장** 고려.  
- [ ] FF 입력 유도는 **\(Q_i^+\)** 를 중심으로: \(D=Q^+\), \(T=Q\oplus Q^+\), \(J/K\)·\(S/R\) 공식 적용.  
- [ ] **K-맵**에서 불법/미정은 **don’t-care**로 적극 활용하되 안전성 우선.  
- [ ] Mealy 출력은 외부로 내보낼 때 **등록**(글리치/타이밍).

---

### 포켓 요약
- **등가 FSM**: 행동이 같으면 등가. 상태 재명명·인코딩 변화는 **기능 불변**.  
- **ISM 최소화**: 호환/닫힌 커버로 병합, 미정은 **안전하게 채워** Self-start 보장.  
- **FF 입력식**: \(\;D=Q^+,\;T=Q\oplus Q^+,\;J=\overline{Q}Q^+,\;K=Q\overline{Q^+},\;S=\overline{Q}Q^+,\;R=Q\overline{Q^+}\;\).  
- **상태할당**: 원-핫(단순), 이진(FF 절약), 그레이(해저드↓) — **전이 구조**를 반영해 로직 최소화.
