---
layout: post
title: 정보보안기사 - 웹 취약점 총정리
date: 2025-11-09 19:25:23 +0900
category: 정보보안기사
---
# 웹 취약점 총정리 — OWASP Top 10 중심(인젝션·인증·권한오류·XSS·CSRF·RCE 등)

## 0) 로드맵(한눈 정리)
- **A01 Broken Access Control(권한오류/IDOR)**  
- **A02 Cryptographic Failures(암호화 실패)**  
- **A03 Injection(SQL/NoSQL/LDAP/OS/Template/XXE)**  
- **A04 Insecure Design(설계 취약)**  
- **A05 Security Misconfiguration(보안설정오류/CORS 등)**  
- **A06 Vulnerable & Outdated Components(취약 라이브러리)**  
- **A07 Identification & Authentication Failures(인증/세션)**  
- **A08 Software & Data Integrity Failures(공급망/서명/무결성)**  
- **A09 Security Logging & Monitoring Failures(로깅/탐지)**  
- **A10 SSRF(Server-Side Request Forgery)**  
- (별도 상세) **XSS(Reflected/Stored/DOM)**, **CSRF**, **RCE**

---

# A03 Injection (인젝션)

## 1) SQL Injection
### ❌ 반패턴
```python
# Flask + psycopg2 (취약)
cursor.execute(f"SELECT * FROM users WHERE email = '{request.args['email']}'")
```
- 문제: 문자열 연결로 쿼리 구성 → 인젝션.

### ✅ 안전 패턴
```python
# Flask + SQLAlchemy Text
from sqlalchemy import text
stmt = text("SELECT id,email,role FROM users WHERE email = :email")
row = db.session.execute(stmt, {"email": request.args.get("email")}).first()
```
- **원칙**: 파라미터 바인딩(프리페어드), 저장프로시저도 “동적 SQL” 지양.

### 테스트 포인트
- 입력 필드 길이/형식 화이트리스트(이메일 형식).  
- 오류메시지/스택 트레이스 사용자 노출 금지(표준 에러 응답).

---

## 2) NoSQL Injection(MongoDB)
### ❌ 반패턴
```javascript
// Node + MongoDB (취약): 사용자가 JSON을 그대로 전달
const user = await col.findOne(JSON.parse(req.query.filter));
```
### ✅ 안전 패턴
```javascript
// 허용된 키만 매핑, 값 검증
const email = String(req.query.email || '');
const user  = await col.findOne({ email: email.toLowerCase() });
```
- **원칙**: 쿼리 오브젝트를 **직렬화된 사용자 입력**으로 만들지 말 것.

---

## 3) LDAP Injection
### ❌ 반패턴
```python
# 필터 문자열 결합
f = f"(uid={request.args['uid']})"
```
### ✅ 안전 패턴
```python
import ldap3
from ldap3.utils.conv import escape_filter_chars
f = f"(uid={escape_filter_chars(request.args.get('uid',''))})"
```

---

## 4) OS Command Injection
### ❌ 반패턴
```python
import os
os.system("ls " + request.args['dir'])
```
### ✅ 안전 패턴
```python
import subprocess
subprocess.run(["/bin/ls", "--", request.args.get('dir','.')], check=True)
```
- **원칙**: `shell=True` 회피, 인자 분리, 허용리스트(경로/명령 제한).

---

## 5) Server-Side Template Injection(SSTI) → RCE 유발
### ❌ 반패턴
```python
# Jinja2에서 사용자의 문자열을 템플릿으로 렌더링(금지)
render_template_string(request.args['tpl'])
```
### ✅ 안전 패턴
```python
# 미리 정의된 템플릿만 사용, 사용자 입력은 변수로만 주입(오토이스케이프)
return render_template("profile.html", name=safe_name)  # 문자열 값으로만
```
- 템플릿 엔진 **오토이스케이프** 활성, “템플릿 자체”를 입력으로 받지 않기.

---

## 6) XXE(XML External Entity)
### ❌ 반패턴
```java
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();
Document doc = db.parse(uploadedXml); // 외부 엔티티 기본 허용일 수 있음
```
### ✅ 안전 패턴
```java
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
String FEATURE = null;
FEATURE = "http://apache.org/xml/features/disallow-doctype-decl";
dbf.setFeature(FEATURE, true);
dbf.setXIncludeAware(false);
dbf.setExpandEntityReferences(false);
DocumentBuilder db = dbf.newDocumentBuilder();
Document doc = db.parse(uploadedXml);
```
- **원칙**: DTD/외부엔티티 비활성, XML 대신 JSON 권장.

---

# A07 Identification & Authentication Failures(인증 실패)

## 1) 비밀번호 저장/검증
### ✅ 안전 패턴(Argon2)
```python
from argon2 import PasswordHasher
ph = PasswordHasher()  # 메모리/시간 파라미터 기본 안전값
hash_ = ph.hash(plain_password)        # 저장값
ph.verify(hash_, login_password)       # 검증
```
- **추가**: 비밀번호 정책(길이/사전어 금지), 2FA, 브루트포스 방어(레이트리밋).

## 2) 세션 관리
- 세션 쿠키: `Secure; HttpOnly; SameSite=Lax|Strict`.  
- 로그인/권한변경 시 **세션 재발급**(fixation 방지).  
- Remember-me/Refresh 토큰 **회전**(1회용).

### Nginx 최소 헤더
```nginx
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
```

---

# A01 Broken Access Control(권한오류/IDOR)

## 1) 오브젝트 레벨 권한(수평 권한)
### ❌ 반패턴
```javascript
// /orders/:id  (id만 검사 → IDOR)
const order = await db('orders').where({ id: req.params.id }).first();
```
### ✅ 안전 패턴
```javascript
const order = await db('orders')
  .where({ id: req.params.id, owner_id: req.user.sub }).first();
if(!order) return res.status(404).end();
```

## 2) 기능 레벨 권한(수직 권한)
```javascript
// 미들웨어로 역할 검사
function requireRole(role){
  return (req,res,next)=> req.user.roles.includes(role) ? next() : res.sendStatus(403);
}
app.post('/admin/users', requireRole('admin'), createUser);
```

## 3) 목록/검색에서도 필터 필수
```javascript
// 리스트도 항상 owner_id로 스코프링
return db('orders').where({ owner_id: req.user.sub }).limit(100);
```

---

# XSS(Cross-Site Scripting)

## 1) Reflected/Stored/DOM XSS
- **원인**: 출력 컨텍스트 별 인코딩 미흡(HTML/Attr/JS/URL).  
- **대응**: 템플릿 **기본 이스케이프**, CSP(Content-Security-Policy), 입력 형식/길이 제한.

### 템플릿(예: Pug) — 자동 이스케이프
```javascript
// res.render('greet', { name });  // greet.pug: h1 Hello #{name}
```

### React(자동 이스케이프)
```jsx
export default function Hello({name}) {
  return <h1>Hello {name}</h1>; // JSX는 기본 이스케이프
}
```

### CSP 도입 예
```nginx
add_header Content-Security-Policy "default-src 'self'; object-src 'none'; base-uri 'self'; frame-ancestors 'none'" always;
```
- **주의**: `unsafe-inline` 지양, 필요한 스크립트는 nonce/sha256 해시 사용.

---

# CSRF(Cross-Site Request Forgery)

## 1) 원리
- 브라우저의 **자동 쿠키 전송**을 악용하여 **상태변경 요청**을 타 사이트에서 발생.

## 2) 방어
- 상태변경은 **POST/PUT/DELETE**, **CSRF 토큰** 검증.  
- 쿠키 `SameSite=Lax/Strict`.  
- API는 **쿠키 대신 Bearer Token** 권장.

### Flask CSRF
```python
from flask_wtf.csrf import CSRFProtect
csrf = CSRFProtect(app)  # 폼 기반 라우트 자동 보호
```

---

# RCE(Remote Code Execution)

## 1) 경로
- OS Command Injection, Template Injection(SSTI), unsafe eval/deserialize.

## 2) 방어 원칙
- **템플릿은 데이터만** 주입, 코드/식 평가 금지.  
- 역직렬화: 신뢰 입력만, **화이트리스트 타입**(Jackson)·픽클 금지.  
- 명령 실행: `shell=False`, 인자 분리, 허용리스트.

---

# A10 SSRF(Server-Side Request Forgery)

## 1) 원리
- 서버가 외부 URL을 가져오는 기능을 악용해 **내부망/메타데이터** 접근.

## 2) 방어
```python
import ipaddress, socket, requests
PRIVATE = (ipaddress.ip_network('10.0.0.0/8'),
           ipaddress.ip_network('172.16.0.0/12'),
           ipaddress.ip_network('192.168.0.0/16'),
           ipaddress.ip_network('127.0.0.0/8'))

def resolve_host(host):
    ip = ipaddress.ip_address(socket.gethostbyname(host))
    if any(ip in n for n in PRIVATE): raise ValueError("private blocked")
    return ip

def safe_fetch(url):
    host = url.split("/")[2].split(":")[0]
    resolve_host(host)
    return requests.get(url, timeout=2, allow_redirects=False)
```
- **원칙**: 허용리스트 도메인, 사설/루프백/링크로컬 차단, 리다이렉트/스킴 제한.

---

# A05 Security Misconfiguration(설정오류)

## 1) 공통
- 디버그 모드/스택트레이스 노출 금지.  
- **CORS**: 필요한 오리진만, `*` + `credentials` 금지.  
- 디렉터리 리스팅/기본 계정/샘플 앱 제거.

### Express 보안 헤더
```javascript
const helmet = require('helmet');
app.use(helmet());
```

### CORS 예(최소허용)
```javascript
const cors = require('cors');
app.use(cors({ origin: ['https://app.example.com'], credentials: true }));
```

---

# A02 Cryptographic Failures(암호화 실패)

## 1) 전송/저장
- **TLS 1.2+**, 안전 스위트(AES-GCM/ChaCha20-Poly1305).  
- 민감데이터 저장 시 **암호화/KMS**, 키 분리·회전·권한 최소.

## 2) 암호/토큰
- 비밀번호는 **해시(Argon2/bcrypt)**.  
- 토큰은 **짧은 수명 + 회전**, **서명 검증(iss/aud/exp/alg/kid)**.

### AES-GCM 예
```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
key = AESGCM.generate_key(256)
aes = AESGCM(key); nonce = os.urandom(12)
ct = aes.encrypt(nonce, b"data", b"aad")
```

---

# A06 Vulnerable & Outdated Components(취약 라이브러리)

## 1) SCA/SBOM
```bash
# Node
npm audit --production
# Python
pip install pip-audit && pip-audit --strict
# SBOM
pip install cyclonedx-bom && cyclonedx-py --format json --outfile sbom.json
```
- **정책**: High/Critical 발견 시 **빌드 실패**(가드레일).

---

# A08 Software & Data Integrity Failures(무결성/공급망)

## 1) 서명/프로비넌스
- 릴리즈 아티팩트 **서명(Cosign)**, 빌드 출처(SLSA).  
- 프론트엔드 스크립트 **Subresource Integrity(SRI)**.

```html
<script src="..." integrity="sha384-abc..." crossorigin="anonymous"></script>
```

---

# A09 Security Logging & Monitoring Failures(로깅/모니터링)

## 1) 원칙
- **구조화 로그(JSON)**, **PII 마스킹**, **Trace/Request ID** 포함, **NTP 동기화**.  
- 4xx/5xx, 인증 실패 폭증, 관리자 경로 접근을 **알람**.

```json
{"ts":"2025-11-04T01:20:00+09:00","sev":"WARN","actor":"user:55","path":"/orders/102","result":"deny","reason":"ownership"}
```

---

# A04 Insecure Design(설계 취약)

## 1) 위협모델링/DFD/경계
- 신뢰경계 표시(인터넷↔DMZ↔내부), **오남용 스토리** 작성.  
- **서버측 검증/계산**(가격/소유권), **레이트리밋/서킷브레이커**.

---

# 별도 상세 모음

## X) 파일 업로드
- 크기 제한, 확장자/시그니처(Magic Number) 검사, **격리 저장**(실행 금지), 다운로드 시 **Content-Disposition**.

```java
// Spring: Path Traversal 방지
Path base = Paths.get("/var/app/files").toAbsolutePath().normalize();
Path p = base.resolve(name).normalize();
if(!p.startsWith(base)) return badRequest();
```

## Y) CORS
- `Access-Control-Allow-Origin`은 **정확한 오리진만**, `credentials` 사용 시 `*` 금지.

## Z) GraphQL 보안(요약)
- **쿼리 복잡도/깊이 제한**, 허용리스트 스키마, 레이트리밋, 권한 디렉티브.

---

# DevSecOps 파이프라인(예시)

```yaml
name: ci-sec
on: [push, pull_request]
jobs:
  build-test-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '20' }
      - run: npm ci && npm test --silent
      - name: SAST
        uses: returntocorp/semgrep-action@v1
        with: { config: p/owasp-top-ten }
      - name: Secrets
        uses: zricethezav/gitleaks-action@v2
      - name: SCA
        run: npm audit --production --audit-level=high
```
- **게이트**: High/Critical → **빌드 실패**.

---

# 운영 체크리스트

- [ ] 모든 **상태변경** 엔드포인트: **CSRF 보호** 또는 **Bearer Token**  
- [ ] 템플릿/프론트엔드: **기본 이스케이프** + **CSP**  
- [ ] DB 접근: **파라미터 바인딩**, 동적 SQL 지양  
- [ ] 파일/명령: **허용리스트**, `shell=False`  
- [ ] 인증: Argon2/bcrypt, 2FA, 세션 재발급, 짧은 수명 토큰  
- [ ] 권한: **오브젝트/기능 레벨 검사**(IDOR 방지)  
- [ ] 로그: 구조화/마스킹/TraceID, **NTP 동기화**  
- [ ] 라이브러리: **SCA+SBOM**, High 발견 시 릴리즈 차단  
- [ ] 구성: CORS 최소, 디버그 Off, 디렉터리 리스팅 금지  
- [ ] 외부 호출: **SSRF 방어(허용도메인, 사설대역 차단)**

---

# 진단/실습 과제(요약)

1) **IDOR 진단**: `/orders/:id` 접근 시 소유권 로그 캡처(deny 케이스).  
2) **XSS 방어 검증**: HTML 컨텍스트/Attr/URL/JS 각각 인코딩 테스트.  
3) **SQLi 방어 검증**: 바인딩 미사용 코드 검색(Semgrep 룰 적용).  
4) **CSRF 검증**: 토큰 미포함 요청 차단 로그 확인.  
5) **SSRF 검증**: 사설 대역/메타데이터 IP 차단 로직 유닛테스트.

---

## 부록: 간단 수식/평가
- **리스크**:  
  $$
  \text{Risk} = \text{Likelihood} \times \text{Impact}
  $$
- **패스워드 엔트로피 근사**:  
  $$
  H \approx L \cdot \log_2 |\Sigma|
  $$

---

## 마무리
- 취약점의 80%는 **입력 신뢰 금지**, **서버측 검증**, **최소권한/기본거부**, **보안설정 기본값**으로 줄일 수 있습니다.  
- 오늘 당장: (1) **파라미터 바인딩 전수 확인** (2) **IDOR 차단 미들웨어 공통화** (3) **CSP/CSRF 적용** (4) **SCA+Secrets 스캔을 CI 게이트** 에 넣으세요.