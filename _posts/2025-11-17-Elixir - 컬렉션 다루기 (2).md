---
layout: post
title: Elixir - 컬렉션 다루기 (2)
date: 2025-11-17 19:25:23 +0900
category: Elixir
---
# 10.3 Collectable와 컴프리헨션 — 수집과 생성의 끝판 정리

> 목표  
> - **Collectable 프로토콜**이 무엇을 일반화하는지, `Enum.into/2`, `Stream.into/2`, `for ... into:` 가 어떻게 하나의 계약을 공유하는지 정리한다.  
> - 직접 **Collectable** 을 구현해 보고, Enum/Stream/컴프리헨션과의 상호작용을 코드 레벨에서 이해한다.  
> - **컴프리헨션(for)** 문법을 “생성기(generator) + 필터 + 변환 + 수집” 관점에서 재정리하고,  
>   리스트/맵/MapSet/바이너리/비트스트링/IO까지 폭넓게 사용한다.  
> - 마지막으로, 고전적인 “리스트/바이너리 컴프리헨션”과 현대적인 “Enum/Stream/Collectable 파이프라인”을 어떻게 조합할지 **설계 원칙**을 세운다.

---

## 10.3 Collectable 프로토콜 — ‘모이는 쪽 끝’을 규정한다

### 10.3.1 왜 Collectable인가?

`Enum` 과 `Stream` 은 “**꺼내는 쪽**” 이다.  
- `Enum.map/2` 는 내부적으로 `Enumerable.reduce/3` 를 사용해 **원소를 하나씩 꺼내면서** 변환한다.  
- `Stream.map/2` 는 “꺼내는 규칙을 지연” 해서 나중에 한 번에 꺼낸다.

하지만, 꺼낸 값을 **어디에 모을 것인지**는 별도의 문제다.

```elixir
1..5
|> Enum.map(&(&1 * 2))
|> Enum.into([])

1..5
|> Enum.map(&(&1 * 2))
|> Enum.into(%{})

1..5
|> Enum.map(&Integer.to_string/1)
|> Enum.into("")
```

위 세 코드는 **같은 값을 생성**하지만,  
- 첫 번째는 리스트  
- 두 번째는 맵  
- 세 번째는 문자열(바이너리)  

로 수집한다.

이 “**수집하는 쪽 인터페이스**”를 일반화한 것이 **Collectable 프로토콜**이다.

- **Enumerable**: “꺼내는 쪽 인터페이스”  
- **Collectable**: “담는 쪽 인터페이스”

다시 말해:

> Enum/Stream은 “데이터 흐름의 **왼쪽**”, Collectable은 그 흐름이 “도착하는 **오른쪽**” 을 추상화한다.

표준 라이브러리에서 Collectable 구현이 있는 대표 타입들:

- `List` (`[]`)
- `Map` (`%{}`)
- `MapSet`
- `BitString` (문자열 포함, `""`)
- `IO` 장치 (`IO.stream`, `File.stream!` 의 “sink” 방향)
- 일부 구조체들(내부적으로 리스트/맵/iodata를 누적하는 형태)

이 덕분에 `Enum.into/2`, `Stream.into/2`, `for ... into:` 모두  
**같은 프로토콜** 위에서 돌아간다.

---

### 10.3.2 Collectable의 핵심 계약

프로토콜 요약:

```elixir
defprotocol Collectable do
  @spec into(t) :: {acc, (term, command -> acc)}
  def into(collectable)
end
```

여기서 중요한 점:

1. `into/1` 는 **두 가지를 묶은 튜플**을 반환한다.
   - `acc` : 누적기(initial accumulator)
   - `collector_fun` : `fn (acc, command) -> acc end` 형태의 함수

2. `collector_fun` 이 받는 `command` 는 세 가지:
   - `{:cont, x}` : “원소 `x` 를 계속 넣어라”
   - `:done` : “이제 더 이상 원소가 없으니, **최종 결과**를 만들어라”
   - `:halt` : “중간에 수집을 중단해야 한다(에러/조기 종료 등)”

이 구조를 좀 더 직관적으로 풀어보면:

- `into/1` 는 “수집을 시작하기 위한 초기 상태 + 값을 넣는 방법” 을 제공한다.
- `Enum.into/2`, `Stream.into/2`, `for ... into:` 는  
  이 정보를 사용해서 **각 원소마다 `{:cont, x}` 를 호출**하고,  
  마지막에 `:done` 을 보내 최종 결과를 얻는다.

이제 실제 구현 예제를 보자.

---

### 10.3.3 직접 Collectable 구현하기 — Box 예제

먼저 가장 기본적인 예제인 `Box` 구조체를 사용해보자.  
기존에 사용했던 예제를 가져오되, 조금 더 설명을 덧붙인다.

```elixir
defmodule Box do
  defstruct items: []
end

defimpl Collectable, for: Box do
  def into(%Box{} = _box) do
    # acc: 내부 누적 상태. 여기서는 단순 리스트로 관리한다.
    collector = fn
      acc, {:cont, x} ->
        # 원소가 들어올 때마다 앞에 붙인다 (O(1)).
        [x | acc]

      acc, :done ->
        # 모든 수집이 끝났을 때, Box 구조체로 감싼다.
        %Box{items: Enum.reverse(acc)}

      _acc, :halt ->
        # 조기 종료. 여기서는 별도 정리는 필요 없으니 :ok 반환.
        :ok
    end

    {[], collector}
  end
end

Enum.into(1..5, %Box{})
# %Box{items: [1, 2, 3, 4, 5]}
```

여기서 주목할 점:

- `{:cont, x}` 을 받을 때마다 리스트 앞에 붙인다 → O(1)  
- `:done` 에서 한 번 `Enum.reverse/1` → 전체 O(n)  
- 따라서 전체 수집은 **O(n)** 에서 안정적으로 동작한다.

만약 실수로 append (`acc ++ [x]`) 를 사용하면 어떻게 될까?

```elixir
collector = fn
  acc, {:cont, x} -> acc ++ [x]    # O(n)
  ...
end
```

이 경우, n개의 요소를 수집할 때 총 복잡도는:

$$
T(n) = 1 + 2 + \cdots + n \approx \frac{n(n+1)}{2} = O(n^2)
$$

따라서 Collectable 구현 시에는 항상:

- **prepend + 마지막에 reverse** 패턴을 기본값으로 생각하는 것이 안전하다.

---

### 10.3.4 표준 타입들의 Collectable 구현 감각

표준 라이브러리에서 Collectable이 구현된 타입들이  
어떻게 동작하는지 직관적으로 살펴보자.

#### 리스트(List)

```elixir
Enum.into(1..5, [])
# [1, 2, 3, 4, 5]
```

- 내부적으로는 `Box` 예제와 거의 동일하게  
  `acc` 를 리스트로 두고, `{:cont, x}` 때마다 prepend 후 reverse.

#### 맵(Map)

```elixir
Enum.into([{:a, 1}, {:b, 2}], %{})
# %{a: 1, b: 2}
```

- `{:cont, {k, v}}` 를 받으면 `Map.put(acc, k, v)` 를 호출하는 식으로 구현된다.
- 즉, key가 중복되면 **마지막 값이 덮어쓴다**.

#### 문자열(바이너리)

```elixir
Enum.into(~w(a b c), "")
# "abc"
```

- 내부적으로는 iodata 누적 → 최종에 `iolist_to_binary/1` 방식으로 구현되어 있다.
- 따라서 `<>` 로 계속 붙이는 것보다 효율적이다.

#### MapSet

```elixir
Enum.into([1, 1, 2, 3], MapSet.new())
# #MapSet<[1, 2, 3]>
```

- `MapSet.put/2` 를 사용해 원소 유일성을 보장한다.

#### IO 장치 (파일/소켓 sink)

`File.stream!/3` 는 보통 “읽기” 스트림으로 알려져 있지만,  
`Stream.into/2` 로 쓰기 방향 sink로도 사용할 수 있다.

```elixir
File.stream!("out.txt")
|> is_struct(File.Stream)
# true
```

실제로는 `Stream.into/2` 가 IO device Collectable 구현을 활용해  
라인 단위/조각 단위로 출력할 수 있게 해준다.

---

### 10.3.5 Stream.into/2 — ‘지연 변환 → 지연 수집’

Collectable은 Stream과 만나면서 진가를 발휘한다.

```elixir
File.stream!("input.txt")
|> Stream.map(&String.upcase/1)
|> Stream.into(File.stream!("output.txt"))
|> Stream.run()
```

흐름을 단계별로 풀면:

1. `File.stream!("input.txt")`  
   - 줄 단위로 “읽기 스트림”을 만든다.

2. `Stream.map/2`  
   - “한 줄을 대문자로 바꾸겠다” 라는 **지연된 변환 규칙**을 쌓는다.

3. `Stream.into(File.stream!("output.txt"))`  
   - “변환된 결과를 어디에 쓸 것인가?” 를 지정.  
   - 여기서는 “다른 파일 스트림에 **Collectable 방식으로** 쓴다” 라는 의미다.
   - 이 시점에서도 실제 IO는 일어나지 않는다(지연).

4. `Stream.run/1`  
   - 이 함수를 호출하는 순간 **실제 실행**이 시작된다.
   - input.txt 에서 한 줄씩 읽고 → 대문자로 변환 → output.txt 에 한 줄씩 쓴다.
   - 이 모든 과정에서 중간 리스트/문자열은 **거의 생성되지 않는다**.

핵심 포인트:

- `Stream.map` : 지연된 변환
- `Stream.into` : 지연된 수집(Collectable)
- `Stream.run` : 전체 파이프라인을 한 번의 패스로 실행

이 패턴은 대용량 IO/네트워크/로그 처리에서 매우 강력하다.

---

### 10.3.6 into 대상의 선택 — 문자열, 맵, 집합, IO

기존에 예로 든 코드를 한 번 더 정리하면서,  
각 수집 대상의 특징을 추가 설명한다.

```elixir
# 1) 문자열(바이너리)로 수집
1..5
|> Stream.map(&Integer.to_string/1)
|> Enum.into("")
# "12345"

# 2) 맵으로 수집
~w(a b c)
|> Enum.with_index()
|> Enum.into(%{})
# %{"a" => 0, "b" => 1, "c" => 2}

# 3) 집합으로 수집
1..10
|> Enum.filter(&(rem(&1, 2) == 0))
|> Enum.into(MapSet.new())
# #MapSet<[2, 4, 6, 8, 10]>

# 4) IO 리스트(iodata)를 모아 최종 문자열로
iodata =
  for i <- 1..3, into: [] do
    ["row:", Integer.to_string(i), "\n"]
  end

:erlang.iolist_to_binary(iodata)
# "row:1\nrow:2\nrow:3\n"
```

- 문자열 누적: `Enum.into("", ...)` 를 쓰면 Collectable 구현 덕분에  
  iodata 기반 효율을 얻는다.
- 맵: `[k, v]` 또는 `{k, v}` 형태를 into `%{}` 로 날리면  
  자동으로 키/값 맵이 된다.
- 집합: 리스트 → MapSet 변환 패턴 (`Enum.into(MapSet.new())`) 은 유일성 보장에 좋다.
- IO 리스트: 컴프리헨션 + `into: []` 로 iodata 트리를 만든 뒤,  
  마지막에 `iolist_to_binary/1` 로 한 방에 평탄화.

> 문자열을 매 단계 `<>` 로 붙이면,  
> 전체 길이를 $$n$$ 이라 할 때 시간 복잡도가 $$O(n^2)$$ 로 악화될 수 있다.  
> Collectable(문자열) + iodata 패턴은 이를 $$O(n)$$ 수준으로 줄여준다.

---

### 10.3.7 Collectable 성능 직관

Collectable을 성능 관점에서 요약해 보면:

- 파이프라인 길이: \(k\)  
- 각 단계가 방출하는 평균 요소 수: \(n\)

이라 할 때, 전체 수집 시간은 대략:

$$
T_{\text{collect}} \approx \sum_{i=1}^k c_i \cdot n
$$

메모리 모델은:

$$
M_{\text{collect}} \approx \text{최종 컨테이너 크기} + \epsilon
$$

여기서 \(\epsilon\) 은 내부 버퍼/일시적인 iodata 조각 정도의 오버헤드다.

중요한 결론:

- `Enum.into/2` 는 이미 모든 변환이 끝난 **리스트/열거 가능한 것**을  
  최종 컨테이너에 수집하는 역할이라,  
  **중간 컬렉션**이 있는 상태에서 **최종 한 번의 수집**만 담당한다.

- `Stream.into/2` 는 변환/수집까지 모두 지연시키므로,  
  **중간 컬렉션 없이** 바로 최종 컨테이너에 흘려보낼 수 있다.

커스텀 Collectable 구현에서:

- `{:cont, x}` 시 `acc ++ [x]` 같은 구현은 피하고  
- 가능하면 **prepend + reverse** 패턴을 사용해 상수 계수를 낮춰라.

---

### 10.3.8 Collectable + Enum.into/3 — 변환과 수집을 한 번에

`Enum.into/3` 를 사용하면 “수집하면서 변환” 도 가능하다.

```elixir
Enum.into(1..5, [], fn x -> x * x end)
# [1, 4, 9, 16, 25]
```

- `Enum.into(enum, collectable, transform_fun)` 형태.
- 내부적으로는 `enum |> Enum.map(transform_fun) |> Enum.into(collectable)` 와 비슷하지만,  
  중간 리스트 없이 한 번의 패스로 처리된다.

이를 활용한 예: 로그 레코드를 바로 MapSet에 수집하면서 필요한 필드만 추출.

```elixir
logs = [
  %{ip: "1.1.1.1", status: 200},
  %{ip: "2.2.2.2", status: 500},
  %{ip: "1.1.1.1", status: 404}
]

Enum.into(logs, MapSet.new(), fn %{ip: ip} -> ip end)
# #MapSet<["1.1.1.1", "2.2.2.2"]>
```

---

### 10.3.9 Collectable 에러/중단 패턴

`Collectable.into/1` 의 `collector_fun` 은 `:halt` 도 받을 수 있다.

```elixir
collector = fn
  acc, {:cont, x} ->
    if x == :stop do
      # 여기서 특별한 정리 필요 시 수행
      acc
    else
      [x | acc]
    end

  acc, :done ->
    Enum.reverse(acc)

  _acc, :halt ->
    # 조기 종료 시 리소스 정리 등
    :ok
end
```

일반적으로:

- Enum/Stream에서의 조기 종료(`Enum.reduce_while`) 등으로 인해  
  Collectable 쪽에 `:halt` 가 전달될 수 있다.
- 파일/소켓/외부 리소스를 감싸는 Collectable을 구현한다면,  
  `:halt` 와 `:done` 에서 각각 리소스 정리/닫기 처리를 적절히 넣어야 한다.

---

## 10.4 컴프리헨션 문 — for로 생성·필터·변환·수집까지

이제 “수집의 반대편”에 있는 **생성 쪽 문법**을 보자.  
엘릭서의 `for` 컴프리헨션은 얼랭 전통의 리스트/비트스트링 컴프리헨션을 계승하면서  
Collectable까지 아우르는 현대식 문법이다.

### 10.4.1 기본 문법: 생성기(generator) + 필터 + 변환

가장 단순한 형태:

```elixir
for x <- 1..5, do: x * x
# [1, 4, 9, 16, 25]

for x <- 1..10, rem(x, 2) == 0, do: x
# [2, 4, 6, 8, 10]
```

구성 요소:

- `x <- enum` : **생성기(generator)**  
  - `Enum.into/2` 에서 `enum` 을 꺼낼 때 사용한 것과 유사한 의미.
- `rem(x, 2) == 0` : **필터(가드)**  
  - true 인 값만 통과, false 는 버려진다.
- `do: expr` : **변환 결과**  
  - 최종적으로 수집되는 값.

복수 생성기:

```elixir
for x <- 1..3, y <- ~w(a b), do: {x, y}
# [{1,"a"},{1,"b"},{2,"a"},{2,"b"},{3,"a"},{3,"b"}]
```

- 카테시안 곱(Cartesian product)을 만든다.
- 내부적으로는 중첩 루프와 같다고 보면 된다.

---

### 10.4.2 패턴 매칭 생성기

컴프리헨션의 가장 강력한 부분 중 하나는  
“**패턴 매칭이 곧 필터**” 역할을 한다는 점이다.

```elixir
pairs = [{:a, 1}, {:b, 2}, :oops]

for {k, v} <- pairs, do: {k, v * 10}
# [{:a, 10}, {:b, 20}]
```

- `:oops` 항목은 `{k, v}` 패턴에 맞지 않으므로 자동으로 건너뛰어진다.

맵 열거 역시 동일:

```elixir
m = %{a: 1, b: 2}

for {k, v} <- m, do: {k, v * v}
# [a: 1, b: 4]  (키워드 리스트 형태)
```

여기에 가드를 추가할 수도 있다.

```elixir
pairs = [{:a, 1}, {:b, 2}, {:c, 3}]

for {k, v} <- pairs, v > 1, do: {k, v}
# [b: 2, c: 3]
```

---

### 10.4.3 다중 생성기와 순회 순서

컴프리헨션의 다중 생성기는 **중첩 루프** 와 같다.  
다음 두 코드는 의미가 완전히 같다.

```elixir
for x <- 1..2, y <- 1..3, do: {x, y}

# 명시적 중첩 루프
Enum.flat_map(1..2, fn x ->
  Enum.map(1..3, fn y -> {x, y} end)
end)
```

순회 순서를 그림으로 나타내면:

| x | y 순회 | 결과 |
|---|--------|------|
| 1 | 1,2,3  | {1,1}, {1,2}, {1,3} |
| 2 | 1,2,3  | {2,1}, {2,2}, {2,3} |

생성기 사이에 필터를 둘 수도 있다.

```elixir
for x <- 1..5,
    y <- 1..5,
    x <= y,
    rem(x + y, 3) == 0,
    do: {x, y}
```

- 왼쪽부터 오른쪽으로 차례로 평가되며,
- 각 생성/필터 단계에서 탈락한 조합은 이후 단계로 넘어가지 않는다.

성능 관점에서는:

- 필터 중 **가장 많이 “걸러낼 것 같은 조건”** 을 가능한한 앞쪽에 배치하면  
  전체 계산량을 줄일 수 있다.

---

### 10.4.4 `:into` — 수집 대상을 바꾼다(Collectable 연동)

컴프리헨션 결과는 기본적으로 **리스트**다.

```elixir
for x <- 1..5, do: x * 2
# [2, 4, 6, 8, 10]
```

하지만 `:into` 옵션을 주면 Collectable 구현을 사용하는 수집이 된다.

```elixir
for x <- 1..5, into: "", do: Integer.to_string(x)
# "12345"

for {k, v} <- [a: 1, b: 2], into: %{}, do: {k, v * 2}
# %{a: 2, b: 4}

for x <- ~w(a a b c c), into: MapSet.new(), do: x
# #MapSet<["a", "b", "c"]>
```

따라서 `:into` 를 잘 활용하면:

- `for` ≒ `Enum.flat_map + Enum.into`  
  를 한 문장으로 정리할 수 있다.

또한 직접 구현한 Collectable도 그대로 사용할 수 있다.

```elixir
# 앞에서 정의한 Box
for x <- 1..5, into: %Box{}, do: x * 3
# %Box{items: [3,6,9,12,15]}
```

---

### 10.4.5 비트스트링(바이너리) 컴프리헨션 심화

비트스트링 컴프리헨션은, 바이너리 데이터 처리에서 **중간 복사 없이**  
필드 추출/변환을 할 수 있게 해준다.

#### 바이트 단위 추출

```elixir
bin = <<0x01, 0xFF, 0x2A>>

for <<byte <- bin>>, into: [], do: byte
# [1, 255, 42]

for <<byte <- bin>>, into: "", do: Integer.to_string(byte, 16)
# "1ff2a"
```

#### UTF-8 코드포인트 추출

```elixir
text = "가나"

for <<cp::utf8 <- text>>, into: [], do: cp
# [44032, 45208]
```

#### 비트필드 재조합

```elixir
# 8비트 두 개에서 상위 4비트씩만 추출
bin = <<0b1011_0011, 0b1111_0000>>

for <<high::4, _low::4 <- bin>>, into: [], do: high
# [11, 15]
```

#### 패킷 파서의 기본 뼈대

```elixir
defmodule Packet do
  def parse(bin) do
    for <<type::8, len::16, payload::binary-size(len), _rest::binary <- bin>>,
      into: [],
      do: %{type: type, len: len, payload: payload}
  end
end
```

- 실제 프로토콜 파서에서는 더 정교한 검증/에러 처리가 필요하지만,  
  컴프리헨션 + 패턴 매칭만으로도 상당히 많은 작업을 표현할 수 있다.

---

### 10.4.6 `:reduce` — 컴프리헨션으로도 누적 가능

컴프리헨션은 기본적으로 “**수집**”이지만,  
`:reduce` 옵션을 사용하면 **누적기 기반 계산**을 표현할 수 있다.

```elixir
# 1..10 사이에서 짝수의 제곱 합
for x <- 1..10,
    rem(x, 2) == 0,
    reduce: 0 do
  acc -> acc + x * x
end
# 220
```

문법:

```elixir
for pattern <- enum, filters..., reduce: acc0 do
  acc -> new_acc
end
```

- `pattern <- enum` : 생성기
- `filters` : 가드/조건
- `acc0` : 초기 누적값
- `acc -> new_acc` : 각 단계의 누적 갱신 함수

`Enum.reduce/3` 와 기능적으로 비슷하지만:

- 여러 생성기/필터를 한 문에 넣기 편하다.
- 코드가 “리스트 내포” 느낌으로 시각적으로 한 번에 들어온다.

둘 중 어느 쪽이 나은지는 **팀 스타일** 과 **가독성**에 따라 선택하면 된다.

---

### 10.4.7 컴프리헨션 vs Enum/Stream — 선택 기준

정리해 보자.

| 요구 사항 | 권장 선택 |
|---|---|
| “생성기 + 필터 + 변환 + 수집” 이 한눈에 들어와야 함 | `for` 컴프리헨션 |
| 복잡한 분기, 에러 흐름, 로깅이 섞임 | `Enum.reduce` / `with` / 패턴 매칭 함수 |
| 무한 시퀀스, IO 지연, 리소스 관리 | `Stream` + `Stream.resource/3` |
| DSL 스타일 옵션/튜닝에 따라 수집 대상이 바뀜 | `Enum.into/2,3` + Collectable |
| 바이너리/비트 필드 파싱 | 비트스트링 컴프리헨션 + 패턴 매칭 |

실전 팁:

- 간단히 생성/필터/변환/수집만 필요하면 → `for`  
- 조금이라도 예외/에러/로깅/타입 계약이 복잡하면 → Enum/Stream/함수 조합으로 내려오는 편이 좋다.

---

## 10.5 과거의 신성함으로부터 돌아오기 — 고전 문법을 현대적으로 쓰기

이제 Enum/Stream/Collectable/컴프리헨션을 **조합해서 설계**할 때의  
실전 원칙들을 정리해 보자.

### 10.5.1 원칙 1 — “핫 루프만 현대적으로 최적화”

- 작은 컬렉션, 간단한 변환:  
  → `for` 문 + `into` 로 간단하게 쓰는 것이 가독성과 성능 모두 적당하다.

- 거대한 데이터/IO/무한 시퀀스:  
  → `Stream` 계열 + `Stream.into(File.stream! ...)`  
  → 필요하면 `Stream.transform/3` 으로 map/filter/scan 을 융합.

- 복잡한 에러/분기/로깅:  
  → `Enum.reduce` + 태그드 튜플(`{:ok, v}`, `{:error, r}`) 계약으로 작성.

핵심은:

> 먼저 **읽기 좋은 코드**를 작성한다.  
> 그다음에 **프로파일링**을 통해 문제 구간만 Stream/융합 패턴으로 바꾼다.

---

### 10.5.2 원칙 2 — 문자열·바이너리는 컴프리헨션과 Collectable이 강하다

텍스트/바이너리 처리에서의 패턴:

1. 읽기: `File.stream!/2` → Stream  
2. 토큰화/파싱: `Stream.flat_map`, 비트스트링/문자열 컴프리헨션  
3. 출력: `Stream.into(File.stream!...)` 또는 `Enum.into("")`

예: 로그에서 일부 필드만 추출하여 CSV 생성

```elixir
File.stream!("access.log")
|> Stream.map(&parse_line/1)  # {:ok, %{ip:..., path:..., code:...}} | :error
|> Stream.filter(&match?({:ok, _}, &1))
|> Stream.map(fn {:ok, m} -> m end)
|> Stream.map(fn m ->
  [
    "\"", m.ip, "\"",
    ",",
    "\"", m.path, "\"",
    ",",
    Integer.to_string(m.code),
    "\n"
  ]
end)
|> Stream.into(File.stream!("out.csv"))
|> Stream.run()
```

- 중간 문자열을 만들지 않고 iodata로 바로 파일에 쓴다.
- “파이프 + iodata + Collectable” 조합이 텍스트 생성에 최적이다.

---

### 10.5.3 원칙 3 — DSL/옵션 처리에서 Collectable을 ‘양 끝’으로

입력 쪽은 **Enumerable**, 출력 쪽은 **Collectable** 로 설계하면 유연성이 높다.

```elixir
# 입력: anywhere (리스트든 스트림이든)
# 출력: 원하는 구조로 수집
def filter_and_collect(enum, predicate, into) do
  enum
  |> Enum.filter(predicate)
  |> Enum.into(into)
end

# 사용 예
filter_and_collect(1..10, &(rem(&1, 2) == 0), [])
# [2,4,6,8,10]

filter_and_collect(1..10, &(rem(&1, 2) == 0), MapSet.new())
# #MapSet<[2,4,6,8,10]>
```

심지어 `into` 를 동적으로 선택하면 간단한 DSL도 만들 수 있다.

```elixir
def collect_as(enum, :list), do: Enum.into(enum, [])
def collect_as(enum, :set),  do: Enum.into(enum, MapSet.new())
def collect_as(enum, :map),  do: Enum.into(enum, %{})
def collect_as(enum, {:file, path}) do
  enum
  |> Stream.map(&[inspect(&1), "\n"])
  |> Stream.into(File.stream!(path))
  |> Stream.run()
end
```

---

### 10.5.4 원칙 4 — 계산·수집 비용 모델을 의식

직관적으로:

- Enum 파이프라인:
  $$M_{\text{Enum}} \approx \sum \text{중간 리스트/맵 크기}$$

- for 컴프리헨션:
  $$M_{\text{for}} \approx \text{:into 대상 크기}$$

- Stream.into:
  $$M_{\text{Stream.into}} \approx \text{거의 0(버퍼 정도)}$$

따라서:

- 작은 데이터/복잡하지 않은 변환: 그냥 Enum/for.
- 데이터가 크고 메모리 압력이 걱정되면: Stream + Stream.into.
- 문자열/바이너리 누적: 반드시 iodata + Collectable 패턴을 고려.

---

## 10.6 실전 레시피 모음

기존에 정리한 예제들에 살을 붙여, 실제로 곧바로 가져다 쓸 수 있는 형태로 정리한다.

### 10.6.1 토큰화 + 2그램 상위 10개 (컴프리헨션 + frequencies)

```elixir
text_stream =
  File.stream!("large.txt")
  |> Stream.flat_map(&String.split(&1, ~r/[^a-z0-9]+/i, trim: true))
  |> Stream.map(&String.downcase/1)

bigrams =
  text_stream
  |> Stream.transform(nil, fn word, prev ->
    case prev do
      nil  -> {[], word}
      prev -> {[{prev, word}], word}
    end
  end)
  |> Enum.frequencies()
  |> Enum.sort_by(fn {_bg, c} -> -c end)
  |> Enum.take(10)
```

- `Stream.transform/3` 으로 “이전 단어 상태”를 유지하면서 현재 단어와 페어링.
- 마지막에 `Enum.frequencies/1` 로 2그램 카운트.
- 상위 10개만 출력.

### 10.6.2 바이너리에서 짝수 바이트만 추출해 새 바이너리 생성

```elixir
bin = <<1, 2, 3, 4, 5, 6, 7, 8>>

res =
  for <<x, _skip <- bin>>, into: <<>> do
    <<x>>
  end

# res == <<1,3,5,7>>
```

- `<<x, _skip <- bin>>` : 두 바이트씩 읽어 첫 바이트만 사용.
- `into: <<>>` : 새 바이너리로 수집.

### 10.6.3 API 페이지네이션 → JSON 라인 파일로

```elixir
defmodule API do
  def fetch(page) do
    if page <= 100 do
      items = for i <- 1..100, do: %{id: (page - 1) * 100 + i, v: :rand.uniform()}
      {:ok, items, page + 1}
    else
      :done
    end
  end
end

pages =
  Stream.unfold(1, fn page ->
    case API.fetch(page) do
      {:ok, items, next} -> {items, next}
      :done              -> nil
    end
  end)
  |> Stream.flat_map(& &1)
  |> Stream.map(&[Jason.encode!(&1), "\n"])

pages
|> Stream.into(File.stream!("out.jsonl"))
|> Stream.run()
```

- `Stream.unfold/2` 로 페이지네이션 → 전체 아이템 스트림 생성.
- 각 아이템을 JSON 문자열 + 개행으로 변환.
- `Stream.into(File.stream!...)` 로 직접 파일에 쓴다.

### 10.6.4 Collectable로 iodata 기반 Lines 수집기

```elixir
defmodule Lines do
  defstruct buf: []

  def to_binary(%Lines{buf: buf}) do
    :erlang.iolist_to_binary(Enum.reverse(buf))
  end
end

defimpl Collectable, for: Lines do
  def into(%Lines{} = _lines) do
    collector = fn
      acc, {:cont, line} ->
        # 줄 끝에 개행을 붙여 iodata로 누적
        [[line, "\n"] | acc]

      acc, :done ->
        %Lines{buf: acc}

      _acc, :halt ->
        :ok
    end

    {[], collector}
  end
end

lines =
  1..3
  |> Enum.map(&"line #{&1}")
  |> Enum.into(%Lines{})

Lines.to_binary(lines)
# "line 1\nline 2\nline 3\n"
```

- Collectable을 이용해 iodata 기반 “라인 버퍼”를 만들고,
- 마지막에 `to_binary/1` 로 한 번에 문자열로 변환.

---

## 10.7 연습 문제

연습 문제는 그대로 두되, 힌트를 조금씩 덧붙인다.

1) 커스텀 수집기: `%Lines{acc :: iodata}` 구조체에 대해 **Collectable** 을 구현하고,  
   `Enum.into(["a","b","c"], %Lines{})` 결과가 iodata 기반으로 누적되도록 하라(마지막에 바이너리화 함수 제공).  
   - 힌트: `{:cont, line}` 에서 `[line, "\n"]` 을 prepend, `:done` 에서 `%Lines{acc: acc}`.

2) `for` 와 `:reduce` 를 이용해, 1..n 자연수 중 **피보나치 수**의 합을 구하라.  
   - 힌트: 미리 `fib_set = MapSet.new([...])` 를 만들고,  
     `for x <- 1..n, x in fib_set, reduce: 0 do acc -> acc + x end`.

3) 바이너리 컴프리헨션으로, PNG(Signature + chunks)에서 **IHDR/IDAT 길이 합**을 계산하라.  
   - 힌트: PNG chunk는 `[len(4), type(4), data(len), crc(4)]` 구조.  
     `for <<len::32, type::binary-4, _data::binary-size(len), _crc::32 <- bin>>, ...` 패턴에서  
     type이 `"IHDR"` 또는 `"IDAT"` 일 때만 len을 더한다.

4) `Stream.unfold/2` + `Stream.into/2` 조합으로 API 페이지들을 **CSV 파일**에 직접 쓴 뒤,  
   첫 10줄만 프린트하는 파이프라인을 작성하라.  
   - 힌트: `Stream.unfold` 로 아이템 스트림,  
     각 아이템을 `["col1,", "col2", "\n"]` 형태로 변환 후,  
     `Stream.into(File.stream!("out.csv"))`.

5) `for` 의 다중 생성기에서 **중첩 필터**의 순서를 바꾸어 성능 차이를 수치화하라.  
   작업 수 \(N\) 과 필터 통과율 \(p\) 에 대해,  
   기대 연산 수를 $$N \cdot p_1 + N \cdot p_1 p_2 + \cdots$$ 로 근사할 수 있음을 보이라.  
   - 힌트: 각 필터는 “앞에서 살아남은 항목에 대해만 평가”된다는 사실을 이용해서,  
     조건을 걸러내는 비율이 높은 필터를 앞쪽에 둘수록 전체 연산 수가 줄어든다.

---

## 10.8 마무리

- **Collectable** 은 “어디에 모을지”를 추상화하는 프로토콜이다.  
  - `Enum.into`, `Stream.into`, `for ... into` 는 모두 Collectable 위에서 동작한다.
  - 리스트/맵/문자열/MapSet/IO/커스텀 구조체 등,  
    다양한 컨테이너를 같은 스타일로 수집 대상으로 사용할 수 있다.

- **컴프리헨션(for)** 은  
  - “생성기 + 필터 + 변환 + 수집” 을 한 줄로 표현하는 강력한 문법이며,  
  - 비트스트링/바이너리/문자열 처리에도 최적화된 구문을 제공한다.

- **Enum/Stream/Collectable/컴프리헨션** 을 함께 바라보면,
  - 입력(Enumerable) → 변환(Enum/Stream) → 출력(Collectable)  
    이라는 **데이터 흐름 관점**으로 코드를 관리할 수 있고,
  - 설계 단계에서부터 **가독성**, **성능**, **메모리**, **테스트 용이성**을 함께 고려할 수 있다.

이 장의 내용을 기반으로,  
- 프로젝트의 곳곳에서 반복되는 루프/배치/파서/문자열 생성 코드를  
  차근차근 Enum/Stream/Collectable/컴프리헨션 패턴으로 치환해 보면,  
- 코드가 훨씬 더 **선언적이고, 짧고, 예측 가능**해지는 것을 느낄 수 있을 것이다.