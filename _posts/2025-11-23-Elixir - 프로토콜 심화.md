---
layout: post
title: Elixir - 프로토콜 심화
date: 2025-11-23 20:25:23 +0900
category: Elixir
---
# Elixir 프로토콜(Protocol) 심화

## _24.3 사용 가능한 자료형_

Elixir 프로토콜은 **“첫 번째 인자의 타입”** 으로 디스패치한다.
이 디스패치 축을 정확히 이해하는 것이 프로토콜 설계의 출발점이다.

`defimpl` 의 `for:` 옵션으로 **타겟 타입**을 지정하며, 다음과 같은 범주를 지원한다.

---

### 기본(내장) 타입들

다음 **비-구조체** 타입에 대해 직접 구현할 수 있다.

- `Atom`
- `BitString` (문자열 바이너리 포함)
- `Float`
- `Function`
- `Integer`
- `List`
- `Map` (plain map: `%{}`)
- `PID`
- `Port`
- `Reference`
- `Tuple`

그리고 **모든 타입**을 커버하는 `Any` (폴백) 도 지정할 수 있다.

기본 예제를 그대로 두고, 아래에서 동작/주의점까지 확장한다.

```elixir
defprotocol Printable do
  @doc "값을 보기 좋은 문자열로"
  def print(x)
end

defimpl Printable, for: Integer do
  def print(i), do: Integer.to_string(i)
end

defimpl Printable, for: Float do
  def print(f), do: :io_lib.format("~.2f", [f]) |> IO.iodata_to_binary()
end

defimpl Printable, for: BitString do
  def print(<<>>), do: "<empty>"
  def print(bin) when is_binary(bin), do: bin
  def print(bitstring), do: "<<#{bit_size(bitstring)} bits>>"
end

defimpl Printable, for: List do
  def print(list), do: "[" <> (list |> Enum.map(&Printable.print/1) |> Enum.join(", ")) <> "]"
end

defimpl Printable, for: Tuple do
  def print(t), do: "{" <> (t |> Tuple.to_list() |> Enum.map(&Printable.print/1) |> Enum.join(", ")) <> "}"
end

defimpl Printable, for: Any do
  def print(x), do: inspect(x)
end
```

사용:

```elixir
Printable.print(42)             # "42"
Printable.print(3.14159)        # "3.14"
Printable.print("hi")           # "hi"
Printable.print(<<1::3>>)       # "<<3 bits>>"
Printable.print([1, 2.0, "x"])  # "[1, 2.00, x]"
Printable.print({:ok, 10})      # "{ok, 10}"
Printable.print(self())         # "#PID<...>"
```

#### (1) “내장 타입”이란 정확히 무엇인가?

Elixir의 값은 BEAM 관점에서 **“태그가 붙은 런타임 타입”** 으로 분류된다.
프로토콜 디스패치도 이 태그(=기본 타입)를 기준으로 한다.

대표적인 분류는 다음과 같다.

| Elixir 표현 | 런타임 기본 타입 | `for:` 지정 |
|---|---|---|
| `:foo` | Atom | `Atom` |
| `123` | Integer | `Integer` |
| `3.14` | Float | `Float` |
| `"abc"` | BitString(바이너리) | `BitString` |
| `<<1::1>>` | BitString(비트스트링) | `BitString` |
| `[1,2]` | List | `List` |
| `{1,2}` | Tuple | `Tuple` |
| `%{a: 1}` | Map(plain map) | `Map` |
| `self()` | PID | `PID` |
| `make_ref()` | Reference | `Reference` |
| `port = Port.open(...)` | Port | `Port` |
| `fn x -> x end` | Function | `Function` |

즉, “내장 타입용 `defimpl`” 은 **BEAM이 구분하는 타입 태그**에 대응한다.

#### (2) `BitString` 하나로 “바이너리와 비트스트링” 모두를 잡는 이유

Elixir의 문자열은 **바이너리(Binary)** 다.
바이너리는 **비트스트링의 특수한 경우**(8비트 정렬된 비트스트링)다.

그래서 `BitString` 구현은 다음을 동시에 커버한다.

- `"abc"` 같은 일반 문자열
- `<<1,2,3>>` 같은 바이트 바이너리
- `<<1::3>>` 같은 정렬되지 않은 비트스트링

따라서 `BitString` 구현에서 `is_binary/1` 체크로 분기하는 게 실전 패턴이다.

#### (3) `Map` 구현이 plain map에만 적용되는 이유(중요)

plain map `%{}` 은 기본 타입이 `Map` 이다.
하지만 구조체 `%Mod{}` 는 **기본 타입이 Map이 아니라 “Mod(구조체 식별자)”** 로 취급된다.

즉,

```elixir
defimpl Printable, for: Map do
  def print(m), do: "map(size=#{map_size(m)})"
end

defmodule Box do
  defstruct [:value]
end

Printable.print(%{})              # "map(size=0)"
Printable.print(%Box{value: 1})   # Protocol.UndefinedError
```

이 차이는 24.4에서 다시 **스코프/충돌/구현 위치** 이야기로 이어진다.

#### (4) `Any` 폴백의 위험과 안전한 대안

`Any` 폴백은 “**정의되지 않은 타입도 실행은 되게**” 해준다.
하지만 도메인에서는 **버그를 숨길 수 있다.**

예시: “Size 프로토콜”이 실제로는 “컬렉션 크기”만 의도했는데,
미구현 타입이 1로 넘어가면 테스트가 조용히 통과할 수 있다.

따라서 “의도된 도메인만” 다루려면 다음처럼 한다.

- `@fallback_to_any false` 로 폴백을 끈다.
- 혹은 `Any` 구현에서 적극적으로 오류를 낸다.

```elixir
defprotocol StrictSize do
  @fallback_to_any false
  def size(x)
end
```

혹은

```elixir
defimpl Printable, for: Any do
  def print(x) do
    raise Protocol.UndefinedError,
      protocol: Printable,
      value: x,
      description: "Printable not implemented for this type"
  end
end
```

도메인에 따라 **폴백 vs 엄격성**을 명시적으로 선택하는 습관이 중요하다.

---

### 구조체(Struct)

- `%Mod{}` 형태의 **구조체**는 **독립적인 디스패치 대상**이다.
- `defimpl Proto, for: Mod` 처럼 **모듈 이름**을 바로 `for:` 에 지정한다.

초안 예제를 유지하고 구조체 디스패치 감각을 더해보자.

```elixir
defmodule Point do
  defstruct [:x, :y]
end

defimpl Printable, for: Point do
  def print(%Point{x: x, y: y}), do: "Point(#{x}, #{y})"
end
```

사용:

```elixir
Printable.print(%Point{x: 3, y: 7})  # "Point(3, 7)"
```

#### (1) 구조체는 “Map + 타입 태그”다

구조체는 내부적으로 plain map에 `:__struct__` 필드가 붙은 형태다.

```elixir
%Point{x: 1, y: 2}
# 내부적으로는 %{__struct__: Point, x: 1, y: 2}

```

하지만 **프로토콜은 이 태그를 “타입”으로 취급**하므로
`for: Map` 구현이 구조체에 **자동 적용되지 않는다.**

#### (2) 구조체 디스패치는 “정확한 모듈”로만 된다

`for: Point` 구현은:

- `%Point{}` 에만 적용됨.
- `%OtherPoint{}` 또는 plain map에는 적용되지 않음.

즉, 구조체는 “구조체 모듈별로 디스패치 대상이 분리”된다.

---

### `Range`, `Date/Time` 등은?

- `%Range{}` / `%Date{}` / `%NaiveDateTime{}` / `%DateTime{}` 처럼
  표준 라이브러리 타입들도 전부 **구조체**다.
- 필요한 프로토콜을 직접 구현할 수 있다.

예: `Printable`에 Range 표현을 추가한다면

```elixir
defimpl Printable, for: Range do
  def print(%Range{first: f, last: l, step: s}) do
    "Range(#{f}..#{l}//#{s})"
  end
end

Printable.print(1..10//2)  # "Range(1..10//2)"
```

여기서도 “남의 구조체 + 우리 프로토콜” 조합이므로
**충돌 가능성**이 낮은 방향이지만,
대형 라이브러리 생태계에서는 24.4의 “구현 위치 전략”을 항상 적용해야 한다.

---

## _24.4 프로토콜과 구조체_

구조체는 “**태그가 달린 맵**”이다.
프로토콜 관점에서 중요한 점은:

---

### 구현 위치 전략(충돌 방지)

- **원칙**: **프로토콜**이나 **구조체** 중 **하나의 ‘소유’ 앱**에서 구현을 제공한다.

케이스를 명확히 정리하면:

| 케이스 | 구현 위치 | 위험도 |
|---|---|---|
| 우리 프로토콜 × 우리 구조체 | 우리 앱 | 낮음 |
| 남의 프로토콜 × 우리 구조체 | 우리 앱(권장) | 낮음 |
| 우리 프로토콜 × 남의 구조체 | 우리 앱(가능) | 보통 |
| 남의 프로토콜 × 남의 구조체 | 피하거나 래퍼 | 높음 |

이유:

- 프로토콜 컨솔리데이션(consolidation)은
  **빌드 시점에 존재하는 구현**으로 디스패치 테이블을 만든다.
- 서로 다른 환경/릴리즈에서 “중복 구현”이 생기면
  **경합/경고/예측 불가**가 될 수 있다.

#### (A) “고아 구현(orphan impl)”이 실제로 터지는 시나리오

- 라이브러리 A: 프로토콜 `P`
- 라이브러리 B: 구조체 `T`
- 우리 앱 C: `P for T` 구현
- 라이브러리 D가 우연히 같은 구현을 추가

이때

- 컴파일은 “이론상 둘 다 존재”
- 컨솔리데이션 결과는 “어느 것이 선택될지 빌드 순서에 의존”
- 런타임에 경고 또는 충돌

따라서 “남+남 조합”은 정말 필요할 때만
**래퍼 타입**으로 우회하는 게 실전 답이다.

---

### `@derive`를 활용한 빠른 통합

대표적으로 `Inspect`, `Jason.Encoder`(외부) 등은 **파생(derive)** 를 지원한다.

```elixir
defmodule User do
  @derive {Inspect, only: [:id, :name]}
  defstruct [:id, :name, :password_hash, :role]
end
```

derive는

- 반복되는 `defimpl` 보일러를 줄이고
- 컨벤션을 강제하고
- 문서/표현 품질을 올린다.

#### (A) derive는 “컴파일 타임 구현 생성”이다

구조체 컴파일 과정에서:

1) `@derive` 목록 확인
2) 프로토콜의 `__deriving__/3` 훅 실행
3) `defimpl` AST를 자동 생성

따라서 `@derive`가 많을수록 컴파일 타임은 늘 수 있으나
실무에서는 생산성 이득이 훨씬 크다.

---

### 구조체는 Map과 다르게 취급된다 (초안 유지 + 경계 사례)

- `%{}` (plain map) 에 대해 `for: Map`으로 구현한 것은 **구조체에 적용되지 않는다.**
- 구조체도 맵이지만 **자체 타입 태그**를 가지므로
  **별도의 `for: MyStruct` 구현**이 필요하다.

예:

```elixir
defimpl Printable, for: Map do
  def print(m), do: "map(size=#{map_size(m)})"
end

defmodule Box do
  defstruct [:value]
end

Printable.print(%{})         # "map(size=0)"
Printable.print(%Box{value: 1})
# ** Protocol.UndefinedError (Printable not implemented for %Box{...})

```

#### (A) 그럼 “구조체를 Map처럼” 다루고 싶다면?

두 방법이 있다.

1) 구조체에 `for: Box` 구현 작성
2) 또는 구조체를 plain map으로 변환해서 Map 구현을 타게 함

```elixir
defimpl Printable, for: Box do
  def print(%Box{} = b) do
    Printable.print(Map.from_struct(b))
  end
end
```

이런 식으로 “내장 Map 구현을 재사용”하는 게 자주 쓰이는 요령이다.

---

## _24.5 기본 내장 프로토콜_

Elixir 표준 라이브러리에는 핵심 내장 프로토콜들이 있고,
이것들을 정확히 구현하면 우리의 구조체가 **언어 레벨 확장**처럼 자연스럽게 통합된다.

---

### `Enumerable` — 컬렉션 순회 규약

`Enum.*` 함수들이 기대하는 **순회 계약**이다.

필수 콜백(요약):

- `reduce(t, acc, fun)`
- `member?(t, item)`
- `count(t)`
- `slice(t)`

#### (A) reduce의 세 가지 제어 신호

`reduce/3`은 단순히 `fun.(elem, acc)`만 호출하는 함수가 아니다.
`Enum`의 중단/재개/지연을 지원하기 위해 다음 신호를 사용한다.

- `{:cont, acc}` : 계속 진행
- `{:halt, acc}` : 즉시 중단
- `{:suspend, acc}` : 중단 후 재개 가능 상태로 반환

실무에서 직접 만들 때는 **리스트 reduce를 위임**하는 패턴이 가장 안전하다.

```elixir
defmodule Bag do
  defstruct items: []
end

defimpl Enumerable, for: Bag do
  def count(%Bag{items: items}), do: {:ok, length(items)}
  def member?(%Bag{items: items}, x), do: {:ok, Enum.member?(items, x)}
  def slice(_), do: {:error, __MODULE__}
  def reduce(%Bag{items: items}, acc, fun),
    do: Enumerable.List.reduce(items, acc, fun)
end
```

이제 Enum이 전부 동작한다.

```elixir
Enum.map(%Bag{items: [1,2,3]}, &(&1 * 2))
Enum.reduce(%Bag{items: [1,2,3]}, 0, &+/2)
Enum.take(%Bag{items: [1,2,3]}, 2)
```

#### (B) slice를 구현하면 무엇이 좋아지나?

`Enum.slice/2`, `Enum.take/2` 같은 연산이
**중간 리스트 생성 없이 최적화**될 수 있다.

하지만 slice는 구조가 복잡할 때 구현 부담이 크므로
불가하면 `{:error, __MODULE__}`로 돌려도 된다.

---

### `Collectable` — “넣기” 규약

`Enum.into/2`, `Stream.into/2` 등의 **수집 대상** 규약이다.

기본 패턴:

```elixir
defimpl Collectable, for: Bag do
  def into(%Bag{items: items}) do
    {items, fn
      list, {:cont, elem} -> [elem | list]
      list, :done -> %Bag{items: Enum.reverse(list)}
      _list, :halt -> :ok
    end}
  end
end
```

#### (A) Collectable 구현에서 흔히 하는 실수

1) `:done`에서 “최종 타입 반환”을 안 함
2) `:halt`을 무시
3) 누적 방향 때문에 순서가 뒤집힘 → `Enum.reverse/1`로 복구 필요

이 세 줄을 반드시 점검한다.

---

### `Inspect` — 보기 좋은 출력

IEx/로깅에서 **사람 친화적 문자열**로 표현한다.
`Inspect.Algebra`는 “예쁜 줄바꿈/들여쓰기”를 제공한다.

```elixir
defimpl Inspect, for: Bag do
  import Inspect.Algebra
  def inspect(%Bag{items: items}, opts) do
    concat(["#Bag<", to_doc(items, opts), ">"])
  end
end
```

Inspect는 디버깅 체감에 직결되므로
상태가 큰 구조체일수록 “좋은 Inspect”는 프로젝트 생산성을 올린다.

---

### `String.Chars` — 문자열로 변환

`to_string/1` 호출 시 사용된다.

```elixir
defimpl String.Chars, for: Bag do
  def to_string(%Bag{items: items}) do
    "Bag(" <> Enum.join(Enum.map(items, &Kernel.to_string/1), ",") <> ")"
  end
end
```

#### (A) `Inspect`와 `String.Chars`의 차이

- `Inspect`는 **디버깅용 표현**
- `String.Chars`는 **도메인 의미를 가진 문자열 표현**

예:
- Inspect는 “개발자가 보기 좋게”
- String.Chars는 “사용자/도메인 로직에서 의미 있게”

따라서 대부분의 구조체는
**Inspect는 요약**, **String.Chars는 의미 표현**으로 분리 설계한다.

---

## _24.6 프로토콜과 다형성_

프로토콜의 가치는 **다형성(polymorphism)** 이다.
“어떤 타입이 오더라도 **같은 이름의 연산**을 호출할 수 있다”는 약속이다.

---

### 패턴매칭 vs 프로토콜 — 선택 기준

- **패턴매칭**
  - 장점: 정적이고 빠르며, 인라인 최적화 유리
  - 단점: 타입이 늘수록 분기 케이스가 커지고 중앙화됨

- **프로토콜**
  - 장점: 타입이 늘어도 구현을 각 타입에 분산할 수 있어 확장성↑
  - 단점: 첫 번째 인자 기준만 디스패치, 컨솔리데이션/충돌 관리 필요

따라서

- 고정된 소수 타입 핫패스 → 패턴매칭
- 타입 확장이 잦고 의미 기반 API가 필요한 곳 → 프로토콜

이 원칙을 먼저 세운다.

---

### 다형적 API 설계 예 — `Renderable`

여러 도메인 객체를 “HTML 조각”으로 통일 렌더링.

```elixir
defprotocol Renderable do
  @doc "HTML 문자열로 렌더링"
  def to_html(x)
end

defimpl Renderable, for: Integer do
  def to_html(i), do: "<span class=\"int\">#{i}</span>"
end

defimpl Renderable, for: BitString do
  def to_html(s) when is_binary(s) do
    esc = s |> String.replace("<", "&lt;") |> String.replace(">", "&gt;")
    "<span class=\"str\">#{esc}</span>"
  end
end

defmodule User do
  defstruct [:id, :name]
end

defimpl Renderable, for: User do
  def to_html(%User{id: id, name: n}),
    do: "<div class=\"user\"><b>#{n}</b> (##{id})</div>"
end

defimpl Renderable, for: List do
  def to_html(xs),
    do: xs |> Enum.map(&Renderable.to_html/1) |> Enum.join("\n")
end

defimpl Renderable, for: Any do
  def to_html(x), do: "<pre>#{inspect(x)}</pre>"
end
```

사용:

```elixir
Renderable.to_html([1, "hi", %User{id: 7, name: "Dana"}])
```

여기서 핵심은:

- 렌더링의 공통 이름은 `to_html/1`
- 의미는 타입별 구현에서 보장
- 호출부는 타입을 몰라도 된다

---

### 프로토콜 합성 — 다른 프로토콜을 구현에 사용하기

프로토콜 구현 안에서 다른 프로토콜을 호출하는 것은 자연스럽다.

```elixir
defimpl Renderable, for: Tuple do
  def to_html(t),
    do: "<code>" <> Printable.print(t) <> "</code>"
end
```

이런 합성은

- “표현(Printable)”
- “렌더(Renderable)”

식으로 관심사를 분리한다.

---

### 복잡도와 성능 — 간단 모델

프로토콜 디스패치가 컨솔리데이션되어 있다면
디스패치 비용은 거의 상수로 볼 수 있다.

$$
T \approx \sum_{i=1}^{N}\big(c_{\text{dispatch}} + t_{\text{impl}(type_i)}\big)
$$

- 실제 비용의 대부분은 **구체 구현의 연산**에서 난다.
- 핫스팟에서는 **벤치마크**로 확인 후 결정해야 한다.

---

### 프로토콜 테스트 전략

1) **타입별 행동 테스트**
   - 대표/엣지 값(빈/큰/이상치)
   - 미구현 타입이 폴백을 타는지/오류를 내는지

2) **내장과의 통합 테스트**
   - `Enum.*`, `Enum.into/2`, `inspect/1`, `to_string/1`이 잘 붙는지

예시:

```elixir
defmodule BagProtoTest do
  use ExUnit.Case

  test "bag is enumerable" do
    b = %Bag{items: [1,2,3]}
    assert Enum.map(b, &(&1*2)) == [2,4,6]
  end

  test "bag is collectable" do
    assert Enum.into(1..3, %Bag{}) == %Bag{items: [1,2,3]}
  end

  test "bag string conversion" do
    assert to_string(%Bag{items: [1,2]}) == "Bag(1,2)"
  end
end
```

---

### 실전에서 자주 쓰는 프로토콜 패턴

1) **도메인 객체의 표준 변환**
   - `Encodable`, `Reportable`, `Renderable`
   - “여러 도메인 타입을 한 API로 통일”

2) **프레임워크 표준과의 결합**
   - `Enumerable/Collectable`로 표준 파이프라인에 녹임
   - `Inspect/String.Chars`로 DX 향상

3) **단일 인자 다형 DSL**
   - 첫 인자 타입이 자연스러운 DSL이라면
     프로토콜이 “거의 언어 문법”처럼 읽힌다.

---

## 마무리 요약

- **24.3**: 프로토콜은 `Atom/Integer/List/.../Map/BitString/Tuple/Function/PID/Port/Reference + Any` 등 **내장 타입**과
  `%Mod{}` **구조체 타입**을 대상으로 구현할 수 있다.
  구조체는 Map 구현을 상속하지 않으며 **독립 디스패치** 대상이다.

- **24.4**: 충돌을 막기 위해서는
  “프로토콜 또는 구조체 중 하나의 소유 앱에서 구현”하는 규율이 필요하다.
  `@derive`와 `__deriving__/3` 훅은 반복 defimpl을 자동화하는 핵심 장치다.

- **24.5**: 내장 프로토콜(Enumerable/Collectable/Inspect/String.Chars)을 잘 구현하면
  **우리 타입이 Elixir 표준 생태계와 자연스럽게 통합**된다.

- **24.6**: 프로토콜은 타입 기반 다형성을 제공한다.
  패턴매칭과의 트레이드오프(성능 vs 확장성)를 이해하고,
  테스트/벤치마크/컨솔리데이션 규율을 함께 가져가야 실전에서 안전하다.
