---
layout: post
title: 정보보안기사 - DoS 공격
date: 2025-11-09 20:25:23 +0900
category: 정보보안기사
---
# SECTION 04 네트워크 기본 학습 — 12. 서비스 거부(DoS: Denial of Service) 공격

## DoS 개요 — 무엇이며 왜 방어가 어려운가

- **정의**: 네트워크/시스템/애플리케이션의 **자원(대역폭, 커널 상태, 소켓, CPU, 메모리, 스레드, DB 커넥션, 디스크/큐 등)**을 고갈·혼잡시켜 **정상 요청을 처리하지 못하게** 만드는 행위.
- **단일 vs 분산**:
  - **DoS**: 단일 또는 소수 발신지.
  - **DDoS**: 봇넷/리플렉터 다수 발신지로 **동시 압박** → 차단·추적 난이도↑.
- **3분류(실무 기준)**
  1) **Volumetric(대역폭·PPS)**: 회선/장비 큐 포화(예: UDP 대량 트래픽, 반사/증폭).
  2) **Protocol/State Exhaustion(L3/4)**: **TCP SYN backlog**, **conntrack**, **로드밸런서 세션 테이블** 고갈.
  3) **Application(L7)**: HTTP 요청/헤더/핸드셰이크/CPU·DB 부하 유도(예: 긴 응답 지연, 느린 클라이언트, 특정 엔드포인트 집중).

---

## 공격 기법 분류 — 위협 모델과 방어 포인트

### Volumetric/반사·증폭(Reflection/Amplification)

| 유형 | 개념 | 전형적 표적 | 탐지 시그널 | 주요 대응 |
|---|---|---|---|---|
| **UDP 대량 트래픽** | 고PPS·고bps로 링크 포화 | 코어/엣지 회선 | PPS/bps 급증, 드롭↑ | **스크러빙/블랙홀/레이트리밋** |
| **반사(Reflection)** | 소스 주소 스푸핑 → 제3자 응답이 피해자에게 | DNS/NTP/SSDP/CLDAP/Memcached 등 | 한 방향 대용량 응답 | **uRPF/BCP38, 오픈 리졸버 제거** |
| **증폭(Amplification)** | 작은 요청→큰 응답 | 일부 UDP 서비스 | 응답/요청 바이트 비율↑ | **서비스 하드닝·ACL** |

- **증폭 계수(개념 수식)**
  $$ \text{Amplification Factor} = \frac{\text{원격 응답 크기(바이트)}}{\text{공격 요청 크기(바이트)}}. $$
  계수↑일수록 소량 요청으로 대량 트래픽 유도 가능 → **오픈 리졸버/잘못된 서비스 구성 제거**가 핵심.

### Protocol/State Exhaustion (L3/4)

| 유형 | 개념 | 징후 | 대응 |
|---|---|---|---|
| **SYN Flood** | SYN 대량 → 서버는 **SYN-RECV** 상태 유지 | `SYN-RECV`↑, 재전송↑ | **SYN Cookies/SYN Proxy**, 백로그 튜닝 |
| **ACK/RST/ICMP Flood** | 특정 플래그/유형으로 장비/회선 부하 | 특정 플래그 편향 | **레이어별 Rate/ACL** |
| **Fragmentation/옵션 악용** | 재조립/옵션 처리 비용 증가 | 재조립 큐↑ | **Reassembly 제한, 비표준 드롭** |
| **Conntrack 고갈** | L4 상태 추적 테이블 만료 지연 | `nf_conntrack` 사용률↑ | **Bypass/분리**, 용량·타임아웃 튜닝 |

### Application Layer (L7)

| 유형 | 개념 | 징후 | 대응 |
|---|---|---|---|
| **HTTP Request Flood** | 정식 요청 다량 | RPS↑, 2xx/5xx 패턴 | **CDN 캐시/챌린지/Rate Limit** |
| **Slow Client/Slowloris** | 느린 헤더/바디 전송 → 워커 고갈 | 연결시간↑, 대기열↑ | **타임아웃/최소 전송율**, 이벤트 기반 서버 |
| **핸드셰이크 남용(TLS/HTTP/2)** | 비용 큰 초기 절차 집중 | Handshake 실패↑ | **재협상 차단/리밋**, 최신 서버 설정 |
| **DB/검색 엔드포인트 집중** | 비싼 쿼리/조인/집계 반복 | DB CPU/IO↑ | **쿼리 캐시/읽기 전용 복제/큐잉** |

---

## 운영 지표 — 무엇이 먼저 비상등을 켜는가

- **네트워크**: bps(링크 대역폭), **pps**(패킷/초), **cps**(연결/초), 드롭률, 큐(버퍼) 점유율.
- **L4/커널**: `SYN-RECV`/`ESTAB` 세션 수, `TIME_WAIT` 쇄도, `nf_conntrack` 사용률, 소켓 backlog/큐 길이, 재전송률.
- **L7**: RPS, 동시 접속, 평균/백분위 응답시간, 에러율(4xx/5xx), 워커/스레드/코루틴 사용률, DB 풀 사용률.
- **대시보드 지표 예**
  - `rate(node_network_receive_packets_total[1m])`
  - `sum by(state)(node_netstat_Tcp_CurrEstab)`
  - `sum(rate(nginx_http_requests_total[1m]))`
  - `nf_conntrack_count / nf_conntrack_max`.

**용량 근사**: 포화 시간 추정
$$
\text{포화까지 시간} \approx \frac{\text{버퍼 용량}}{\text{도착률}-\text{처리율}}.
$$
처리율(서버)의 **QPS/세션 처리능력**보다 도착률이 커지는 순간 지연·드롭이 기하급수적으로 증가.

---

## 탐지 — 패킷/플로우/애플리케이션의 3단 병행

### 패킷 기반(상시 룰)

```bash
# Suricata 간단 임계 룰 예(실전은 공인 룰셋 사용 권장)

alert tcp any any -> $HOME_NET any (msg:"Possible SYN flood"; flags:S; threshold:type both, track by_dst, count 1000, seconds 1; sid:200001;)
alert icmp any any -> $HOME_NET any (msg:"ICMP rate abnormal"; detection_filter:track by_dst, count 2000, seconds 1; sid:200002;)
alert udp any any -> $HOME_NET [53,123,1900] (msg:"UDP reflection target ports"; detection_filter:track by_dst, count 2000, seconds 1; sid:200003;)
```

```zeek
# Zeek 예(개념): 연결 실패/시도 비율 기반 Notice

@load base/frameworks/notice
@load policy/misc/scan
# DDoS/스캔 패턴은 notice.log로 수집(실전은 커스텀 히스테리시스 사용)

```

### 플로우(NetFlow/IPFIX) 기반(스케일 탐지)

```bash
# 수평/수직 지표(개념): dstPort 유니크 카운트, pps 상위, 바이트 비율

nfdump -r flows.nfd -o "fmt:%ts %te %sa %da %dp %pr %pkt %byt" | head
# 플랫폼(ELK/ClickHouse/Prometheus)로 상시 집계하여 "분/초" 스파이크 경보

```

### 애플리케이션 계층

- **Nginx/HAProxy**: 초당 요청, 4xx/5xx 비중, 대기열 길이, 동시 커넥션, 백엔드 리트라이↑.
- **로그 이상**: 동일 IP/ASN/리퍼러 패턴, 비정상 User-Agent, 특정 엔드포인트 집중.

---

## 네트워크 계층 완화 — 엣지부터 줄인다

### 라우팅/엣지

- **uRPF/BCP38**: 소스 스푸핑 트래픽 차단(업스트림과 협력).
- **RTBH/Flowspec**: 표적 프리픽스/특정 5튜플로 **임시 블랙홀**.
- **Anycast + 스크러빙센터**: 전 세계로 부하 분산 후 **정상 트래픽만 정제하여 원점 전달**.
- **Carpet Bombing 대응**: 개별 호스트 아닌 **프리픽스 단위** 임계·차단(분산 저강도 공격 대응).

### 방화벽/라우터 레이트 제한(예시: nftables)

```bash
# 기본 수립: 상태 기반 허용, ICMP는 PMTUD에 필요한 유형 허용

nft add table inet filter
nft add chain inet filter input { type filter hook input priority 0; policy drop; }
nft add rule inet filter input ct state established,related accept
nft add rule inet filter input iifname "lo" accept
nft add rule inet filter input icmp type { destination-unreachable, time-exceeded, echo-request, echo-reply } limit rate 50/second accept

# SYN rate 제한 + 버스트

nft add rule inet filter input tcp flags syn / syn,rst limit rate 200/second burst 100 packets accept
nft add rule inet filter input tcp flags syn drop

# UDP 특정 포트(예: 1900 SSDP) 제한

nft add rule inet filter input udp dport 1900 limit rate 100/second burst 200 packets accept
nft add rule inet filter input udp dport 1900 drop
```

> **주의**: 너무 낮은 한계는 정상 스파이크를 잘못 차단할 수 있다. **사업 트래픽 프로파일**에 맞춘 값으로 튜닝.

### SYN Cookies/SYN Proxy/커널 튜닝

```bash
# /etc/sysctl.d/99-ddos.conf

net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_syn_backlog = 8192
net.core.somaxconn = 8192
net.ipv4.tcp_synack_retries = 3
net.ipv4.tcp_fin_timeout = 30
net.netfilter.nf_conntrack_max = 1048576
net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 30
```

```bash
# 적용

sysctl --system
```

> **의미**: Cookies로 **백로그 메모리 고갈 방지**, 백로그/큐 확장, SYN-ACK 재시도 축소, conntrack 용량·타임아웃 조정.

### 큐·스케줄러/트래픽 제어(tc)

```bash
# 지연 친화: FQ-CoDel

tc qdisc replace dev eth0 root fq_codel

# 특정 UDP 포트에 폴리싱(과잉 드롭)

tc qdisc replace dev eth0 handle 1: root htb default 10
tc class add dev eth0 parent 1: classid 1:10 htb rate 1gbit ceil 1gbit
tc filter add dev eth0 protocol ip parent 1: prio 1 u32 match ip protocol 17 0xff match ip dport 1900 0xffff police rate 5mbit burst 100k drop
```

---

## 애플리케이션 계층 완화

### Nginx — Rate/Conn/Timeout

```nginx
# nginx.conf (발췌)
# IP별 요청 속도 제한(토큰 버킷)

limit_req_zone $binary_remote_addr zone=perip:10m rate=10r/s;

# IP별 동시 연결 제한

limit_conn_zone $binary_remote_addr zone=connip:10m;

http {
  sendfile on;
  keepalive_timeout  15;
  client_body_timeout 15;
  client_header_timeout 10;
  reset_timedout_connection on;
  large_client_header_buffers 4 8k;

  server {
    listen 443 ssl http2;

    # L7 Rate Limiting
    limit_req zone=perip burst=20 nodelay;
    limit_conn connip 50;

    # 헤더/바디 크기 제한
    client_max_body_size 8m;

    # 특정 엔드포인트별 강화(예: /search)
    location /search {
      limit_req zone=perip burst=10;
      proxy_pass http://app;
    }
  }
}
```

### HAProxy — Stick-table 기반

```haproxy
# haproxy.cfg (발췌)

frontend fe_https
  bind :443 ssl crt /etc/ssl/haproxy.pem alpn h2,http/1.1
  mode http
  # IP별 요청/세션 추적
  stick-table type ip size 1m expire 10m store http_req_rate(10s),conn_cur
  http-request track-sc0 src
  acl abuse sc0_http_req_rate gt 100
  acl many_conn sc0_conn_cur gt 100
  http-request deny if abuse or many_conn
  default_backend be_app
```

### 애플리케이션(Flask 예) — 간단 토큰 버킷

```python
# flask_rate_limit.py — 교육용 간단 레이트리밋(프로덕션 WAF/리버스 프록시 병행 권장)

from flask import Flask, request, abort
import time, collections

app = Flask(__name__)
WINDOW, LIMIT = 1.0, 10  # 초, 초당 허용 요청 수
buckets = collections.defaultdict(list)

def allow(ip):
    now = time.time()
    q = buckets[ip]
    while q and q[0] <= now - WINDOW:
        q.pop(0)
    if len(q) < LIMIT:
        q.append(now)
        return True
    return False

@app.before_request
def guard():
    ip = request.headers.get('X-Forwarded-For', request.remote_addr)
    if not allow(ip):
        abort(429, "Too Many Requests")

@app.route("/health")
def health():
    return "ok"

# app.run(ssl_context='adhoc')  # 테스트 전용

```

> **포인트**: L7 Rate Limit은 **프런트(프록시/WAF)**에서 1차로, 애플리케이션에서 2차로 **중첩 방어**.

---

## 클라우드/경계 설계 패턴

- **CDN 앞단 배치**: 정적/캐시 가능 응답은 **엣지에서 종결**하여 원점 트래픽 최소화.
- **WAF + Bot 관리**: 시그니처/행위/평판/챌린지(자바스크립트/쿠키/문제풀이) 조합.
- **오리진 셰일딩(Origin Shield)**: 다중 캐시 계층으로 원점 동시 접속 급증 방지.
- **오토스케일링**: CPU/큐 길이 기준 스케일아웃, **연결 대기열/DB 풀** 한계 고려.
- **멀티 리전/Anycast**: 트래픽 지리적 분산.
- **RPS 기반 규칙**: **IP/ASN/국가/URI/메서드** 별 상한.
- **관제**: 엣지/오리진 모두 **메트릭·로그** 수집(초 단위) + 런북 자동화.

---

## 안전 실습(공격 재현 없이 방어·관찰만)

> 하나의 Linux에서 네임스페이스로 **원점(app)**–**프록시(nginx)**–**관찰자** 구성. `tc`로 **앱 처리율을 일부러 낮춰 병목**을 만들고, **정상 부하 도구로 저강도 요청**을 보내 **관찰/완화 동작**을 확인한다.

### 토폴로지(개념)

```
[client(ns:c)] --(veth)--> [nginx(ns:edge)] --(veth)--> [app(ns:app)]
                                     |
                                  monitors
```

### 구성 스니펫

```bash
# (개요만) 네임스페이스/링크/주소 설정 → Nginx 프록시 → Flask 앱
# app 측에 tc tbf로 처리율 제한(예: 10Mbps)하여 병목 시나리오 형성

tc qdisc replace dev veth_app root tbf rate 10mbit burst 32kbit latency 400ms

# Nginx limit_req/limit_conn 설정(§6.1) 적용 후
# client에서 wrk/ab로 "합리적" 수준(예: 100 rps 미만)으로 부하 → 429/대기열 동작 관찰

```

> 이 시나리오의 목적은 **정상 트래픽 상황에서 방어 메커니즘이 어떻게 동작하는지**를 검증하는 것이다. **공격 도구/재현 금지**.

---

## 운영 플레이북 — “감지→분석→격리→근절→복구”

1) **감지**: 네트워크 bps/PPS 급증, L4 SYN-RECV↑, L7 RPS·에러율↑, conntrack 사용률↑.
2) **분석**: 5튜플/ASN/지역/URI 분포, 편향(특정 포트/엔드포인트), **정상 대비 비정상 비율**.
3) **격리**: 엣지 Rate/ACL 조정, 오픈 리졸버/서비스 임시 차단, **업스트림 스크러빙/RTBH 요청**.
4) **근절**: 원인 서비스 제거(오픈 리졸버/증폭 매개), 방화벽 정책/한계 상향, 앱 타임아웃/리밋 강화.
5) **복구**: 캐시 재가온(warm-up), 큐/DB 풀 정상화, 재시도 정책 점검.
6) **사후**: **관제 룰/대시보드** 튜닝, **훈련/런북** 개선, **연습 주기화**.

---

## 표 — 공격 유형별 징후·대응 요약

| 레이어 | 예시 | 대표 징후 | 1차 대응 | 2차 대응 |
|---|---|---|---|---|
| Volumetric | UDP/Reflection | bps/PPS 급증, 한 방향 대용량 | 업스트림 스크러빙/RTBH | Anycast/용량 확장 |
| L3/4 | SYN Flood | SYN-RECV↑, 재전송↑ | SYN Cookies/Proxy, 백로그↑ | conntrack 튜닝/Bypass |
| L3/4 | ACK/RST Flood | 특정 플래그 편향 | ACL/Rate | DPI/필터 |
| L7 | HTTP Flood | RPS↑, 2xx/5xx 패턴 변동 | CDN/WAF Rate | 앱 타임아웃·큐/DB 최적화 |
| L7 | Slow Client | 연결시간↑, 워커 점유 | 최소 전송율/타임아웃 | 이벤트 루프형 서버 |

---

## 현장 명령(리눅스) — 즉시 진단

```bash
# 네트워크

sar -n DEV 1 5
sar -n TCP,ETCP 1 5
nstat | egrep 'Tcp|Udp|Ip'

# 소켓/세션

ss -s
ss -ant state syn-recv | wc -l
conntrack -S 2>/dev/null || true

# 커널 큐/백로그

cat /proc/sys/net/ipv4/tcp_max_syn_backlog
cat /proc/sys/net/core/somaxconn

# iptables/nftables 카운터

nft list ruleset | grep -A2 'limit'
```

---

## 시험/실무 포인트(예상 문제)

1) **SYN Flood**에 대한 서버/네트워크 측 **복합 대응**(Cookies/Proxy/Backlog/conntrack/엣지 Rate)을 서술하라.
2) **Reflection/Amplification**이 성립하려면 서비스가 어떤 상태여야 하는가? **오픈 리졸버 제거**가 중요한 이유를 쓰라.
3) **Slow Client**류 DoS를 막기 위한 **웹 서버 타임아웃/최소 전송률/워커 모델**의 관계를 설명하라.
4) **Carpet Bombing** 유형이 왜 **호스트 기반 임계**만으로 탐지/차단이 어려운지, **프리픽스 단위 탐지**의 필요성을 논하라.
5) PMTUD에 필요한 **ICMP 유형**을 모두 차단했을 때 나타나는 **부작용**을 설명하라.

---

## 체크리스트 — 사전·실시간·사후

### 사전(Prevention)

- [ ] **BCP38/uRPF** 적용, 보행(보곤) 필터
- [ ] **오픈 리졸버/증폭원** 제거, 관리 포트 외부 비노출
- [ ] **CDN/WAF/스크러빙** 계약 및 런북
- [ ] **SYN Cookies/Proxy**, 커널/conntrack/큐 튜닝
- [ ] **레이트/커넥션 리밋**(Nginx/HAProxy) + 타임아웃
- [ ] **캐시/오리진 셰일드/읽기 전용 복제**로 L7 내성
- [ ] **대시보드/경보**(초 단위), **연습**(분기 1회 이상)

### 실시간(Response)

- [ ] 지표 스냅샷 저장(bps/PPS/RPS/큐/백로그)
- [ ] 엣지 한계 조정(Rate/ACL), 업스트림 RTBH/스크러빙 호출
- [ ] 표적 엔드포인트 임시 **프로텍션 룰** 강화
- [ ] 로그/플로우 샘플링 1분 단위 아카이브

### 사후(Post)

- [ ] 공격 특성 문서화(ASN/포트/URI/시간대)
- [ ] 방어 룰/용량 재설정, **런북 교정**
- [ ] **근본원인**(오픈 서비스/구성) 제거, 교육 반복

---

## 부록 — 방어 설정 스니펫 모음

### iptables (레거시 환경)

```bash
# SYN rate-limit(예시)

iptables -A INPUT -p tcp --syn -m hashlimit --hashlimit 100/second --hashlimit-burst 50 --hashlimit-mode srcip --hashlimit-name synlimit -j ACCEPT
iptables -A INPUT -p tcp --syn -j DROP

# 기본 정책/필요 ICMP 허용

iptables -A INPUT -p icmp --icmp-type fragmentation-needed -j ACCEPT
iptables -A INPUT -p icmp --icmp-type time-exceeded -j ACCEPT
```

### Windows 방화벽(간단 예)

```powershell
# Inbound 80/443만 허용, 나머지 차단(환경에 맞춰 신중 적용)

New-NetFirewallRule -DisplayName "Web Inbound" -Direction Inbound -LocalPort 80,443 -Protocol TCP -Action Allow
Set-NetFirewallProfile -Profile Public -DefaultInboundAction Block
```

### Prometheus 경보 규칙(개념)

{% raw %}
```yaml
groups:
- name: ddos.rules
  rules:
  - alert: SYN_Flood_Suspected
    expr: rate(node_netstat_Tcp_InSegs[1m]) > 200000 and (sum by(instance)(node_netstat_Tcp_InSegs) - sum by(instance)(node_netstat_Tcp_OutSegs)) > 100000
    for: 1m
    labels: {severity: critical}
    annotations:
      summary: "SYN-like spike on {{ $labels.instance }}"
```
{% endraw %}

---

## 결론

- DoS/DDoS는 **복합전**이다. **엣지(네트워크) → 호스트(L4) → 애플리케이션(L7)** 각 계층에서 **동시** 대응해야 효과가 있다.
- **탐지**는 패킷·플로우·앱 로그의 **다중 신호 융합**이 핵심이며, **운영 프로파일** 기반의 임계·룰이 필요하다.
- **설계 단계**에서의 **캐시/분산/리밋/타임아웃/용량**이야말로 최고의 방어다. **훈련과 런북**으로 조직의 대응 체력을 길러라.
