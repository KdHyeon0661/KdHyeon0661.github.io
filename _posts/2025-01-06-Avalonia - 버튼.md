---
layout: post
title: Avalonia - 버튼
date: 2025-01-06 19:20:23 +0900
category: Avalonia
---
# Avalonia MVVM에서 버튼 기능 추가하기

## 목표와 사용 기술

### 목표

- ReactiveCommand로 버튼 이벤트를 MVVM 방식으로 처리
- `CanExecute` 조건에 따른 버튼 활성/비활성
- `async/await` 비동기 처리
- 버튼 클릭 이후 ViewModel 상태 변화가 **자동으로 UI에 반영**

### 사용 기술 요약

| 기술 | 설명 |
|------|------|
| `ReactiveCommand` | MVVM 방식의 커맨드(동기/비동기 모두) |
| `WhenAnyValue`, `CombineLatest` | `CanExecute` 조건을 Observable로 선언 |
| `IsExecuting` | 실행 중 상태(스피너/비활성화)에 활용 |
| `ThrownExceptions` | 예외 스트림 구독으로 중앙 처리 |
| `CommandParameter` | 항목/값 전달 |
| `Unit` | 매개변수/결과 없음 의미(Reactive 확장형 타입) |

---

## 예제 구조

```
MyAvaloniaApp/
├── ViewModels/
│   └── ButtonViewModel.cs
└── Views/
    └── ButtonView.axaml
```

---

## ViewModel 기본형: 동기/비동기 + CanExecute

초안의 코드를 ReactiveUI 권장 패턴으로 다듬고, 실행 중 상태·예외 처리·취소까지 확장 가능한 형태로 제시한다.

```csharp
// ViewModels/ButtonViewModel.cs
using ReactiveUI;
using System;
using System.Reactive;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;

public class ButtonViewModel : ReactiveObject
{
    private string _status = "대기 중...";
    public string Status
    {
        get => _status;
        set => this.RaiseAndSetIfChanged(ref _status, value);
    }

    // 화면에서 토글할 수 있는 조건(버튼 활성화 기준)
    private bool _canClick = true;
    public bool CanClick
    {
        get => _canClick;
        set => this.RaiseAndSetIfChanged(ref _canClick, value);
    }

    // 추가 조건 예: 입력 텍스트가 있어야 실행 가능
    private string _input = "";
    public string Input
    {
        get => _input;
        set => this.RaiseAndSetIfChanged(ref _input, value);
    }

    // 취소 토큰 (비동기 작업 취소 예시)
    private CancellationTokenSource? _cts;

    // 커맨드들
    public ReactiveCommand<Unit, Unit> ClickCommand { get; }
    public ReactiveCommand<Unit, Unit> AsyncCommand { get; }
    public ReactiveCommand<Unit, Unit> CancelCommand { get; }

    // 실행 중 상태를 편하게 바인딩하기 위한 OAPH
    private readonly ObservableAsPropertyHelper<bool> _isBusy;
    public bool IsBusy => _isBusy.Value;

    public ButtonViewModel()
    {
        // CanExecute: CanClick == true && Input이 공백이 아님
        var canExecute =
            this.WhenAnyValue(vm => vm.CanClick, vm => vm.Input,
                (can, text) => can && !string.IsNullOrWhiteSpace(text));

        // 동기 커맨드
        ClickCommand = ReactiveCommand.Create(OnClick, canExecute);

        // 비동기 커맨드
        AsyncCommand = ReactiveCommand.CreateFromTask(OnAsyncClick, canExecute);

        // 취소 커맨드: 실행 중일 때만 가능
        CancelCommand = ReactiveCommand.Create(OnCancel,
            AsyncCommand.IsExecuting); // IsExecuting을 CanExecute로 직접 사용

        // IsBusy(= 실행 중) 바인딩 소스
        _isBusy = AsyncCommand.IsExecuting
            .StartWith(false)
            .ToProperty(this, vm => vm.IsBusy, scheduler: RxApp.MainThreadScheduler);

        // 예외 스트림 중앙 처리(로그/다이얼로그 등)
        AsyncCommand.ThrownExceptions.Subscribe(ex =>
        {
            Status = $"오류: {ex.Message}";
        });
    }

    private void OnClick()
    {
        Status = $"[{DateTime.Now:T}] 동기 버튼 클릭: 입력 = '{Input}'";
    }

    private async Task OnAsyncClick()
    {
        _cts?.Cancel();
        _cts = new CancellationTokenSource();

        Status = "처리 중...";
        // 실제 I/O/CPU 바운드 작업 대체
        await Task.Delay(2000, _cts.Token);

        // 예: 단순 변환/저장/전송 이후 상태 업데이트
        Status = $"[{DateTime.Now:T}] 비동기 완료: 입력 길이 = {Input.Length}";
    }

    private void OnCancel()
    {
        _cts?.Cancel();
        Status = "취소 요청됨";
    }
}
```

**핵심 포인트**
- ReactiveUI는 WPF의 `RaiseCanExecuteChanged()` 대신 **Observable로 CanExecute를 선언**한다.
  `WhenAnyValue`/`CombineLatest` 등을 사용하면 **상태 변화 → 즉시 CanExecute 재평가**가 이뤄진다.
- `IsExecuting`은 `ReactiveCommand`가 제공하는 **실행 상태 스트림**이다. UI 바인딩에 곧바로 활용 가능.
- 예외는 `ThrownExceptions`로 흘러오므로, **구독하여 중앙 처리**하면 뷰모델이 단순해진다.
- 취소는 `CancellationTokenSource`를 관리해 `Task.Delay(..., token)` 등으로 구현한다.

---

## View(XAML): 상태/버튼/입력/스피너 바인딩

```xml
<!-- Views/ButtonView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:MyAvaloniaApp.ViewModels"
             x:Class="MyAvaloniaApp.Views.ButtonView"
             Width="460" Height="240">

  <UserControl.DataContext>
    <vm:ButtonViewModel/>
  </UserControl.DataContext>

  <Grid RowDefinitions="Auto,Auto,Auto,Auto,*" Margin="16" RowSpacing="8">

    <!-- 상태 텍스트 -->
    <TextBlock Grid.Row="0"
               Text="{Binding Status}"
               FontSize="16"
               TextWrapping="Wrap" />

    <!-- 입력 -->
    <StackPanel Grid.Row="1" Orientation="Horizontal" Spacing="8">
      <TextBlock Text="입력:" VerticalAlignment="Center"/>
      <TextBox Width="260"
               Text="{Binding Input, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
               Watermark="아무 텍스트나 입력"/>
      <CheckBox Content="버튼 활성화"
                IsChecked="{Binding CanClick, Mode=TwoWay}"/>
    </StackPanel>

    <!-- 버튼들 -->
    <StackPanel Grid.Row="2" Orientation="Horizontal" Spacing="8">
      <Button Content="동기 버튼 클릭"
              Command="{Binding ClickCommand}"/>
      <Button Content="비동기 버튼 클릭 (2초)"
              Command="{Binding AsyncCommand}"/>
      <Button Content="취소"
              Command="{Binding CancelCommand}"/>
    </StackPanel>

    <!-- 실행 중 표시 (IsExecuting 연계) -->
    <StackPanel Grid.Row="3" Orientation="Horizontal" Spacing="8" VerticalAlignment="Center">
      <ProgressBar IsIndeterminate="True" Width="160" Height="6"
                   IsVisible="{Binding IsBusy}"/>
      <TextBlock Text="실행 중"
                 IsVisible="{Binding IsBusy}" />
    </StackPanel>

    <!-- 도움말 -->
    <TextBlock Grid.Row="4" Opacity="0.75" TextWrapping="Wrap">
      ReactiveCommand의 CanExecute는 Observable로 선언합니다.
      입력과 체크박스 상태에 따라 버튼이 자동으로 활성/비활성화됩니다.
      비동기 실행 중 Cancel로 취소할 수 있으며, IsExecuting을 스피너/텍스트에 바인딩했습니다.
    </TextBlock>

  </Grid>
</UserControl>
```

**포인트**
- `UpdateSourceTrigger=PropertyChanged`로 텍스트가 바뀔 때마다 CanExecute 재평가 트리거.
- `IsBusy`에 스피너/텍스트를 바인딩해 **실행 중 시각화**.
- `CancelCommand`는 `AsyncCommand.IsExecuting`을 CanExecute로 사용했기 때문에 실행 중에만 활성화.

---

## CommandParameter: 항목/값을 커맨드로 전달

리스트 항목의 삭제 버튼 등에서 **CommandParameter**를 자주 사용한다.

### ViewModel

```csharp
using ReactiveUI;
using System.Collections.ObjectModel;
using System.Reactive;

public sealed class ItemsViewModel : ReactiveObject
{
    public ObservableCollection<string> Items { get; } = new();

    public ReactiveCommand<string, Unit> RemoveCommand { get; }

    public ItemsViewModel()
    {
        Items.Add("Alpha");
        Items.Add("Beta");
        Items.Add("Gamma");

        // Command<TParam, TResult>
        RemoveCommand = ReactiveCommand.Create<string>(item =>
        {
            if (Items.Contains(item))
                Items.Remove(item);
        });
    }
}
```

### XAML

```xml
<ListBox Items="{Binding Items}">
  <ListBox.ItemTemplate>
    <DataTemplate>
      <Grid ColumnDefinitions="*,Auto" Margin="0,2">
        <TextBlock Text="{Binding .}"/>
        <Button Grid.Column="1" Content="삭제"
                Command="{Binding DataContext.RemoveCommand, RelativeSource={RelativeSource AncestorType=UserControl}}"
                CommandParameter="{Binding .}"/>
      </Grid>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
```

**포인트**
- `RelativeSource`로 상위 `UserControl`의 DataContext(ItemsViewModel)에 접근.
- `CommandParameter="{Binding .}"`는 현재 항목(문자열)을 그대로 전달.

---

## 결과를 반환하는 비동기 커맨드

커맨드가 작업 결과를 내보내면 **다른 바인딩**이나 **체이닝**이 쉬워진다.

```csharp
using ReactiveUI;
using System;
using System.Reactive.Linq;
using System.Threading.Tasks;

public sealed class ResultViewModel : ReactiveObject
{
    // async → string 결과
    public ReactiveCommand<Unit, string> GenerateCommand { get; }

    private string _last;
    public string Last
    {
        get => _last;
        private set => this.RaiseAndSetIfChanged(ref _last, value);
    }

    public ResultViewModel()
    {
        GenerateCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            await Task.Delay(500);
            return $"[{DateTime.Now:T}] 토큰";
        });

        // 커맨드의 결과 스트림을 구독해 상태 업데이트
        GenerateCommand.Subscribe(token => Last = token);
    }
}
```

XAML:

```xml
<StackPanel Spacing="8">
  <Button Content="토큰 생성"
          Command="{Binding GenerateCommand}"/>
  <TextBlock Text="{Binding Last}"/>
</StackPanel>
```

---

## 여러 조건을 결합한 CanExecute

여러 입력 조건을 동시에 검사할 때는 `CombineLatest`가 유용하다.

```csharp
var canExecute =
    Observable.CombineLatest(
        this.WhenAnyValue(vm => vm.CanClick),
        this.WhenAnyValue(vm => vm.Input).Select(s => !string.IsNullOrWhiteSpace(s)),
        this.WhenAnyValue(vm => vm.IsNetworkConnected), // 예: 네트워크 연결 상태
        (can, hasInput, net) => can && hasInput && net
    );

SaveCommand = ReactiveCommand.CreateFromTask(SaveAsync, canExecute);
```

**포인트**
- ReactiveUI에서는 `RaiseCanExecuteChanged()` 대신, **CanExecute 소스 Observable**이 갱신되면 자동으로 반영된다.
- `IsNetworkConnected` 같은 외부 상태도 `WhenAnyValue`로 묶어 반영 가능.

---

## 스타일/상태 트리거로 버튼 UI 개선

실행 중이면 버튼 텍스트를 바꾸거나 비활성화 스타일을 강조할 수 있다.

```xml
<Button Content="전송" Command="{Binding SendCommand}">
  <Button.Styles>
    <Style Selector="Button">
      <Style.Triggers>
        <DataTrigger Binding="{Binding SendCommand.IsExecuting}" Value="True">
          <Setter Property="Content" Value="전송 중..."/>
          <Setter Property="IsEnabled" Value="False"/>
        </DataTrigger>
      </Style.Triggers>
    </Style>
  </Button.Styles>
</Button>
```

**포인트**
- Avalonia의 `DataTrigger`로 **명시적인 상태 기반 스타일 변경**.
- 이미 `CanExecute`로 버튼이 비활성화될 수 있지만, 컨텐츠 텍스트 등 **추가 시각화**가 가능하다.

---

## 예외 처리 패턴

`ThrownExceptions`를 구독하여 공통 처리(로그/다이얼로그)를 수행한다.

```csharp
SaveCommand.ThrownExceptions
    .ObserveOn(RxApp.MainThreadScheduler)
    .Subscribe(ex =>
    {
        // TODO: 로그 기록 / IDialogService로 사용자 알림
        Status = $"저장 실패: {ex.Message}";
    });
```

비동기 메서드 내부에서 예외를 던지면 `ThrownExceptions`로 흘러 들어간다.
별도의 `try/catch`가 필요할 때는 메서드 내부에서 처리한 뒤 적절한 메시지를 설정하자.

---

## 키 바인딩으로 커맨드 실행(선택)

버튼뿐 아니라 키 입력으로도 커맨드를 호출할 수 있다.

```xml
<UserControl>
  <UserControl.KeyBindings>
    <KeyBinding Gesture="Enter" Command="{Binding AsyncCommand}"/>
    <KeyBinding Gesture="Ctrl+S" Command="{Binding SaveCommand}"/>
  </UserControl.KeyBindings>
  <!-- 본문 UI -->
</UserControl>
```

---

## 테스트: CanExecute/실행/예외

뷰모델 단위 테스트는 `Button` 없이도 가능하다.

```csharp
using Xunit;
using System.Threading.Tasks;

public class ButtonViewModelTests
{
    [Fact]
    public async Task AsyncCommand_Disabled_When_InputEmpty()
    {
        var vm = new ButtonViewModel();
        vm.CanClick = true;
        vm.Input = ""; // 빈 입력

        Assert.False(await vm.AsyncCommand.CanExecute.FirstAsync());
    }

    [Fact]
    public async Task AsyncCommand_UpdatesStatus()
    {
        var vm = new ButtonViewModel { CanClick = true, Input = "abc" };
        await vm.AsyncCommand.Execute();
        Assert.Contains("비동기 완료", vm.Status);
    }
}
```

**포인트**
- ReactiveCommand의 `CanExecute`는 `IObservable<bool>`이다. 테스트에서 `FirstAsync()`로 현재 값을 확인할 수 있다.
- UI 없이 로직만 검증 가능 → MVVM의 장점.

---

## 확장 가이드

- **진행률 보고**가 필요하다면 `IProgress<T>`를 사용하거나 커맨드 결과 타입을 `Progress<double>` 스트림으로 만들고 `Subscribe`로 바인딩한다.
- **중복 실행 방지**: `AsyncCommand.IsExecuting`을 다른 커맨드의 `CanExecute`에 결합해, 하나 실행 중에는 다른 커맨드를 잠그는 구조를 만들 수 있다.
- **다이얼로그 연계**: `Interaction<TInput, TOutput>`(ReactiveUI) 또는 `IDialogService`를 사용해 사용자 확인/입력을 받고 결과로 다음 커맨드를 연결한다.
- **서비스 경계**: 파일/네트워크/DB 접근은 서비스 인터페이스로 추상화하여 테스트/대체 가능하게 유지.

---

## 결론

- Avalonia에서 버튼을 MVVM답게 다루려면 **ReactiveCommand**를 표준으로 삼는 것이 가장 깔끔하다.
- `CanExecute`는 **Observable 기반 선언형**으로 구성하고, `IsExecuting`·`ThrownExceptions`로 **상태/오류**를 일관되게 관리한다.
- `CommandParameter`, **결과 반환형 커맨드**, **취소/진행률** 등 확장 포인트를 조합하면 UI와 로직이 분리된 **유지보수성 높은 구조**를 만들 수 있다.

이 글의 패턴을 시작점으로, 실제 앱 요구사항(다이얼로그, 파일 I/O, 네트워크, 폼 검증, 네비게이션)과 자연스럽게 결합해 나가면 된다.
