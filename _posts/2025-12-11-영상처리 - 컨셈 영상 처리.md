---
layout: post
title: 영상처리 - 컨셈 영상 처리 (C#)
date: 2025-12-11 15:30:23 +0900
category: 영상처리
---
# 컨셈 영상 처리

## 컨셈 영상 처리의 개요

컬러 영상 처리는 단일 밝기 정보만을 다루는 그레이스케일 처리와 달리, 색상(Hue), 명도(Intensity/Value/Lightness), 채도(Saturation)와 같은 다차원 정보를 다룬다. 인간의 시각 시스템은 약 700만 개의 원뿔세포(cone cells)를 통해 컬러를 인지하므로, 컬러 정보를 활용하면 객체 인식, 감정 분석, 의료 영상 등 다양한 분야에서 더 풍부한 정보를 추출할 수 있다.

### 주요 색상 모델 비교

| 모델 | 구성 요소 | 주요 용도 | 장점 | 단점 |
|------|-----------|-----------|------|------|
| **RGB** | Red, Green, Blue | 디스플레이, 카메라 센서 | 구현 간단, 하드웨어 친화적 | 색상과 밝기 분리 어려움 |
| **HSI/HSV** | Hue, Saturation, Intensity/Value | 컴퓨터 비전, 이미지 편집 | 직관적 색상 제어, 인간 지각 유사 | 변환 계산량多, 수치적 불안정성 |
| **YUV/YIQ** | Luma(Y), Chrominance(U,V) | 비디오 압축(MPEG, JPEG) | 압축 효율高, 호환성 좋음 | RGB 변환 필요 |
| **CMYK** | Cyan, Magenta, Yellow, Key | 인쇄, 출판 | 잉크 기반 표현 최적화 | 디스플레이 부적합 |

---

## 색상 모델과 변환 이론

### RGB 색상 모델
RGB는 가산혼합(Additive Color) 모델로, 빛의 삼원색을 조합하여 색상을 표현한다. 대부분의 디지털 이미지 센서와 디스플레이가 이 모델을 사용한다.

```
픽셀 표현 계층 구조:
┌─────────────────────────────┐
│        Pixel(x,y)           │
├───────────┬────────┬────────┤
│ R 채널    │ G 채널 │ B 채널 │
│ 0-255     │ 0-255  │ 0-255  │
└───────────┴────────┴────────┘
```

**수학적 표현:**
$$
C_{RGB} = [R, G, B]^T, \quad R,G,B \in [0,255]
$$

**특징:**
- 채널 간 상관관계 높음(예: 밝기 변화시 모든 채널 변화)
- 인간의 색 지각과 비직관적
- 밝기 조절 시 색상 왜곡 발생 가능

---

### HSI/HSV 색상 모델
HSI(Hue, Saturation, Intensity)와 HSV(Hue, Saturation, Value)는 인간의 색 지각 방식에 더 가까운 모델이다.

```
색상 원형 다이어그램:
          0°(Red)
          ↑
   60°(Yellow)   300°(Magenta)
          ↘     ↙
    120°(Green)─240°(Blue)
```

#### RGB → HSI 변환 (상세)

**1단계: 정규화**
$$
r = \frac{R}{R+G+B}, \quad g = \frac{G}{R+G+B}, \quad b = \frac{B}{R+G+B}
$$

**2단계: 색상(Hue) 계산**
$$
\theta = \cos^{-1}\left(\frac{\frac{1}{2}[(r-g)+(r-b)]}{\sqrt{(r-g)^2 + (r-b)(g-b)} + \epsilon}\right)
$$
$$
H = \begin{cases}
\theta & \text{if } b \le g \\
360^\circ - \theta & \text{if } b > g
\end{cases}
$$
*여기서 $\epsilon$은 0으로 나누기 오류 방지를 위한 작은 값*

**3단계: 채도(Saturation)**
$$
S = 1 - 3 \cdot \min(r, g, b)
$$

**4단계: 명도(Intensity)**
$$
I = \frac{R + G + B}{3}
$$

**수치적 안정성을 위한 고려사항:**
- 분모가 0에 가까울 때의 처리
- RGB 값이 모두 동일할 때(Hue 정의 불가)
- 삼각함수 계산의 정밀도 문제

---

### YUV/YIQ 색상 모델
TV 방송 시스템을 위해 개발되었으며, 인간 시각이 밝기에 더 민감하다는 특성을 활용한다.

#### 변환 행렬 (RGB ↔ YUV)

**RGB에서 YUV로:**
$$
\begin{bmatrix}
Y \\ U \\ V
\end{bmatrix}
=
\begin{bmatrix}
0.299 & 0.587 & 0.114 \\
-0.147 & -0.289 & 0.436 \\
0.615 & -0.515 & -0.100
\end{bmatrix}
\begin{bmatrix}
R \\ G \\ B
\end{bmatrix}
$$

**YUV에서 RGB로:**
$$
\begin{bmatrix}
R \\ G \\ B
\end{bmatrix}
=
\begin{bmatrix}
1 & 0 & 1.140 \\
1 & -0.395 & -0.581 \\
1 & 2.032 & 0
\end{bmatrix}
\begin{bmatrix}
Y \\ U \\ V
\end{bmatrix}
$$

**적용 분야:**
- JPEG, MPEG 압축
- TV 방송(NTSC, PAL)
- 컬러 서브샘플링(4:2:0, 4:2:2)

---

## RGB 채널 단위 처리 구현

### 고성능 픽셀 처리 아키텍처

```csharp
public class ColorImageProcessor
{
    // 메모리 효율적인 LockBits 방식 구현
    public unsafe Bitmap ProcessRgbChannels(Bitmap src, Func<Color, Color> pixelProcessor)
    {
        Bitmap dst = new Bitmap(src.Width, src.Height);
        Rectangle rect = new Rectangle(0, 0, src.Width, src.Height);
        
        BitmapData srcData = src.LockBits(rect, 
            ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
        BitmapData dstData = dst.LockBits(rect,
            ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
        
        int bytesPerPixel = 4; // ARGB
        int heightInPixels = srcData.Height;
        int widthInBytes = srcData.Width * bytesPerPixel;
        
        byte* srcPtr = (byte*)srcData.Scan0;
        byte* dstPtr = (byte*)dstData.Scan0;
        
        for (int y = 0; y < heightInPixels; y++)
        {
            byte* srcRow = srcPtr + (y * srcData.Stride);
            byte* dstRow = dstPtr + (y * dstData.Stride);
            
            for (int x = 0; x < widthInBytes; x += bytesPerPixel)
            {
                // 픽셀 데이터 읽기 (BGRA 순서)
                byte b = srcRow[x];
                byte g = srcRow[x + 1];
                byte r = srcRow[x + 2];
                byte a = srcRow[x + 3];
                
                Color srcColor = Color.FromArgb(a, r, g, b);
                Color dstColor = pixelProcessor(srcColor);
                
                // 처리 결과 쓰기
                dstRow[x] = dstColor.B;     // Blue
                dstRow[x + 1] = dstColor.G; // Green
                dstRow[x + 2] = dstColor.R; // Red
                dstRow[x + 3] = dstColor.A; // Alpha
            }
        }
        
        src.UnlockBits(srcData);
        dst.UnlockBits(dstData);
        
        return dst;
    }
    
    // 채널별 밝기 조절 예제
    public Color AdjustChannelBrightness(Color c, int rDelta, int gDelta, int bDelta)
    {
        int r = Clamp(c.R + rDelta);
        int g = Clamp(c.G + gDelta);
        int b = Clamp(c.B + bDelta);
        
        return Color.FromArgb(c.A, r, g, b);
    }
    
    private int Clamp(int value, int min = 0, int max = 255)
    {
        return Math.Max(min, Math.Min(max, value));
    }
}
```

### RGB 채널 분리 및 병합

```csharp
public (Bitmap R, Bitmap G, Bitmap B) SplitChannels(Bitmap src)
{
    Bitmap rChannel = new Bitmap(src.Width, src.Height);
    Bitmap gChannel = new Bitmap(src.Width, src.Height);
    Bitmap bChannel = new Bitmap(src.Width, src.Height);
    
    for (int y = 0; y < src.Height; y++)
    {
        for (int x = 0; x < src.Width; x++)
        {
            Color c = src.GetPixel(x, y);
            
            // 각 채널을 그레이스케일로 표현
            rChannel.SetPixel(x, y, Color.FromArgb(c.R, c.R, c.R));
            gChannel.SetPixel(x, y, Color.FromArgb(c.G, c.G, c.G));
            bChannel.SetPixel(x, y, Color.FromArgb(c.B, c.B, c.B));
        }
    }
    
    return (rChannel, gChannel, bChannel);
}
```

---

## HSI 모델 기반 고급 컬러 처리

### 색상 보존 명도 조절 시스템

```
처리 파이프라인:
┌─────┐    ┌──────────┐    ┌─────────────┐    ┌──────────┐    ┌─────┐
│ RGB │ →  │ RGB→HSI  │ →  │ I 조절     │ →  │ HSI→RGB  │ →  │ RGB │
└─────┘    └──────────┘    └─────────────┘    └──────────┘    └─────┘
                 ↓                  ↓                  ↓
            Hue 유지        Saturation 유지      색상 왜곡 최소화
```

### 향상된 RGB ↔ HSI 변환 구현

```csharp
public class HsiConverter
{
    private const double EPSILON = 1e-10;
    private const double TWO_PI = 2 * Math.PI;
    private const double TWO_PI_OVER_3 = 2 * Math.PI / 3;
    private const double FOUR_PI_OVER_3 = 4 * Math.PI / 3;
    
    // RGB to HSI with error handling
    public (double H, double S, double I) RgbToHsi(Color c)
    {
        // 정규화 [0, 1]
        double r = c.R / 255.0;
        double g = c.G / 255.0;
        double b = c.B / 255.0;
        
        double sum = r + g + b;
        
        // 회색(무채색) 처리
        if (Math.Abs(r - g) < EPSILON && Math.Abs(g - b) < EPSILON)
        {
            return (0, 0, sum / 3.0); // Hue 정의되지 않음
        }
        
        // 명도(Intensity)
        double I = sum / 3.0;
        
        // 채도(Saturation)
        double min = Math.Min(r, Math.Min(g, b));
        double S = 1 - (3 * min / sum);
        
        // 색상(Hue)
        double numerator = 0.5 * ((r - g) + (r - b));
        double denominator = Math.Sqrt(
            (r - g) * (r - g) + 
            (r - b) * (g - b)
        );
        
        double theta = Math.Acos(numerator / (denominator + EPSILON));
        
        double H;
        if (b <= g)
        {
            H = theta;
        }
        else
        {
            H = TWO_PI - theta;
        }
        
        // 도(degree) 단위로 변환 (선택사항)
        // H = H * 180 / Math.PI;
        
        return (H, S, I);
    }
    
    // HSI to RGB with sector-based calculation
    public Color HsiToRgb(double H, double S, double I)
    {
        // Hue를 [0, 2π) 범위로 정규화
        H = H % TWO_PI;
        if (H < 0) H += TWO_PI;
        
        double r, g, b;
        
        // 섹터 1: 0° ≤ H < 120°
        if (H < TWO_PI_OVER_3)
        {
            b = I * (1 - S);
            r = I * (1 + (S * Math.Cos(H)) / Math.Cos(Math.PI/3 - H));
            g = 3 * I - (r + b);
        }
        // 섹터 2: 120° ≤ H < 240°
        else if (H < FOUR_PI_OVER_3)
        {
            H -= TWO_PI_OVER_3;
            r = I * (1 - S);
            g = I * (1 + (S * Math.Cos(H)) / Math.Cos(Math.PI/3 - H));
            b = 3 * I - (r + g);
        }
        // 섹터 3: 240° ≤ H < 360°
        else
        {
            H -= FOUR_PI_OVER_3;
            g = I * (1 - S);
            b = I * (1 + (S * Math.Cos(H)) / Math.Cos(Math.PI/3 - H));
            r = 3 * I - (g + b);
        }
        
        // 클리핑 및 변환
        r = Math.Max(0, Math.Min(1, r));
        g = Math.Max(0, Math.Min(1, g));
        b = Math.Max(0, Math.Min(1, b));
        
        return Color.FromArgb(
            (int)(r * 255),
            (int)(g * 255),
            (int)(b * 255)
        );
    }
    
    // 색상 보존 명도 조절
    public Bitmap AdjustIntensityPreserveHue(Bitmap src, double intensityFactor)
    {
        return ProcessRgbChannels(src, c =>
        {
            var (H, S, I) = RgbToHsi(c);
            I = Math.Max(0, Math.Min(1, I * intensityFactor));
            return HsiToRgb(H, S, I);
        });
    }
}
```

---

## 컬러 엣지 검출 고급 기법

### 컬러 공간에서의 엣지 검출 이론

그레이스케일 엣지 검출은 단일 채널의 밝기 변화만 고려하지만, 컬러 엣지 검출은 다차원 색상 공간에서의 변화를 고려한다.

#### 벡터 기반 그래디언트

컬러 픽셀을 3D 벡터로 표현:
$$
\vec{C}(x,y) = [R(x,y), G(x,y), B(x,y)]^T
$$

총 그래디언트 크기:
$$
G(x,y) = \sqrt{ \|\nabla R\|^2 + \|\nabla G\|^2 + \|\nabla B\|^2 }
$$

또는 색상 차이 기반:
$$
G(x,y) = \max(\|\nabla R\|, \|\nabla G\|, \|\nabla B\|)
$$

### 다중 채널 소벨 연산자 구현

```csharp
public class ColorEdgeDetector
{
    public enum GradientMethod
    {
        VectorSum,      // 벡터 합 크기
        MaximumChannel, // 최대 채널 그래디언트
        ColorDifference // 색상 차이 기반
    }
    
    public Bitmap DetectEdges(Bitmap src, GradientMethod method = GradientMethod.VectorSum)
    {
        int width = src.Width;
        int height = src.Height;
        Bitmap dst = new Bitmap(width, height);
        
        // 소벨 마스크
        int[,] sobelX = { { -1, 0, 1 }, { -2, 0, 2 }, { -1, 0, 1 } };
        int[,] sobelY = { { -1, -2, -1 }, { 0, 0, 0 }, { 1, 2, 1 } };
        
        // 경계 픽셀 제외 처리
        for (int y = 1; y < height - 1; y++)
        {
            for (int x = 1; x < width - 1; x++)
            {
                double gradR_x = 0, gradR_y = 0;
                double gradG_x = 0, gradG_y = 0;
                double gradB_x = 0, gradB_y = 0;
                
                // 3x3 윈도우 컨볼루션
                for (int j = -1; j <= 1; j++)
                {
                    for (int i = -1; i <= 1; i++)
                    {
                        Color c = src.GetPixel(x + i, y + j);
                        int weightX = sobelX[j + 1, i + 1];
                        int weightY = sobelY[j + 1, i + 1];
                        
                        gradR_x += weightX * c.R;
                        gradR_y += weightY * c.R;
                        gradG_x += weightX * c.G;
                        gradG_y += weightY * c.G;
                        gradB_x += weightX * c.B;
                        gradB_y += weightY * c.B;
                    }
                }
                
                // 그래디언트 크기 계산
                double gradientMagnitude = 0;
                
                switch (method)
                {
                    case GradientMethod.VectorSum:
                        gradientMagnitude = Math.Sqrt(
                            gradR_x * gradR_x + gradR_y * gradR_y +
                            gradG_x * gradG_x + gradG_y * gradG_y +
                            gradB_x * gradB_x + gradB_y * gradB_y
                        );
                        break;
                        
                    case GradientMethod.MaximumChannel:
                        double gradR = Math.Sqrt(gradR_x * gradR_x + gradR_y * gradR_y);
                        double gradG = Math.Sqrt(gradG_x * gradG_x + gradG_y * gradG_y);
                        double gradB = Math.Sqrt(gradB_x * gradB_x + gradB_y * gradB_y);
                        gradientMagnitude = Math.Max(gradR, Math.Max(gradG, gradB));
                        break;
                        
                    case GradientMethod.ColorDifference:
                        // 색상 차이 기반 엣지 (HSI 공간 활용)
                        gradientMagnitude = CalculateColorDifferenceGradient(src, x, y);
                        break;
                }
                
                // 결과 정규화 (0-255)
                int intensity = Clamp((int)gradientMagnitude / 3); // 경험적 스케일링
                dst.SetPixel(x, y, Color.FromArgb(intensity, intensity, intensity));
            }
        }
        
        return dst;
    }
    
    private double CalculateColorDifferenceGradient(Bitmap src, int x, int y)
    {
        // 중앙 픽셀과 주변 픽셀의 색상 차이 계산
        Color center = src.GetPixel(x, y);
        var centerHsi = RgbToHsi(center);
        
        double maxDiff = 0;
        
        // 8-방향 이웃과의 색상 차이 계산
        for (int j = -1; j <= 1; j++)
        {
            for (int i = -1; i <= 1; i++)
            {
                if (i == 0 && j == 0) continue;
                
                Color neighbor = src.GetPixel(x + i, y + j);
                var neighborHsi = RgbToHsi(neighbor);
                
                // Hue 차이 (원형 거리)
                double hueDiff = Math.Abs(centerHsi.H - neighborHsi.H);
                hueDiff = Math.Min(hueDiff, TWO_PI - hueDiff);
                
                // 채도와 명도 차이
                double satDiff = Math.Abs(centerHsi.S - neighborHsi.S);
                double intDiff = Math.Abs(centerHsi.I - neighborHsi.I);
                
                // 가중 합 (Hue에 더 높은 가중치)
                double totalDiff = hueDiff * 0.5 + satDiff * 0.3 + intDiff * 0.2;
                maxDiff = Math.Max(maxDiff, totalDiff);
            }
        }
        
        return maxDiff * 255; // 스케일 조정
    }
}
```

---

## 실제 응용 사례

### 1. 자동 화이트 밸런스 (AWB)
```csharp
public Bitmap AutoWhiteBalance(Bitmap src)
{
    // 회색 세계 가정(Gray World Assumption) 기반
    double avgR = 0, avgG = 0, avgB = 0;
    
    // 전체 이미지 평균 계산
    for (int y = 0; y < src.Height; y++)
    {
        for (int x = 0; x < src.Width; x++)
        {
            Color c = src.GetPixel(x, y);
            avgR += c.R;
            avgG += c.G;
            avgB += c.B;
        }
    }
    
    int totalPixels = src.Width * src.Height;
    avgR /= totalPixels;
    avgG /= totalPixels;
    avgB /= totalPixels;
    
    double avgGray = (avgR + avgG + avgB) / 3;
    
    // 보정 계수
    double scaleR = avgGray / avgR;
    double scaleG = avgGray / avgG;
    double scaleB = avgGray / avgB;
    
    // 적용
    Bitmap dst = new Bitmap(src.Width, src.Height);
    for (int y = 0; y < src.Height; y++)
    {
        for (int x = 0; x < src.Width; x++)
        {
            Color c = src.GetPixel(x, y);
            int r = Clamp((int)(c.R * scaleR));
            int g = Clamp((int)(c.G * scaleG));
            int b = Clamp((int)(c.B * scaleB));
            dst.SetPixel(x, y, Color.FromArgb(r, g, b));
        }
    }
    
    return dst;
}
```

### 2. 피부 색상 검출 (Skin Detection)
```csharp
public Bitmap DetectSkinRegions(Bitmap src)
{
    Bitmap dst = new Bitmap(src.Width, src.Height);
    
    // RGB 기반 피부 색상 범위 (경험적 값)
    for (int y = 0; y < src.Height; y++)
    {
        for (int x = 0; x < src.Width; x++)
        {
            Color c = src.GetPixel(x, y);
            
            // 정규화된 RGB
            int sum = c.R + c.G + c.B;
            if (sum == 0) continue;
            
            double r = c.R / (double)sum;
            double g = c.G / (double)sum;
            
            // 피부 색상 조건 (연구에 따라 다양)
            bool isSkin = (r > 0.36 && r < 0.47) && 
                         (g > 0.28 && g < 0.38) &&
                         (c.R > c.G && c.R > c.B) &&
                         (Math.Abs(c.R - c.G) > 15);
            
            if (isSkin)
            {
                dst.SetPixel(x, y, Color.White);
            }
            else
            {
                dst.SetPixel(x, y, Color.Black);
            }
        }
    }
    
    return dst;
}
```

---

## 성능 최적화 고려사항

### 1. 룩업 테이블(LUT) 활용
```csharp
public class LookupTableProcessor
{
    private byte[] _rLut = new byte[256];
    private byte[] _gLut = new byte[256];
    private byte[] _bLut = new byte[256];
    
    public void BuildGammaLut(double gamma)
    {
        for (int i = 0; i < 256; i++)
        {
            double normalized = i / 255.0;
            double corrected = Math.Pow(normalized, gamma);
            _rLut[i] = _gLut[i] = _bLut[i] = (byte)(corrected * 255);
        }
    }
    
    public Bitmap ApplyLut(Bitmap src)
    {
        // 빠른 픽셀 처리
        // ... 구현 생략
        return src;
    }
}
```

### 2. 병렬 처리 활용
```csharp
public Bitmap ProcessInParallel(Bitmap src)
{
    Bitmap dst = new Bitmap(src.Width, src.Height);
    
    Parallel.For(0, src.Height, y =>
    {
        for (int x = 0; x < src.Width; x++)
        {
            // 픽셀 처리 (스레드 안전하게)
            // ... 구현 생략
        }
    });
    
    return dst;
}
```

---

## 정리

컬러 영상 처리는 단순히 3개의 그레이스케일 채널을 처리하는 것을 넘어서, 색상 모델 변환을 통해 인간의 시각 특성을 반영한 고급 처리가 가능하다.

### 핵심 요약:
1. **RGB 모델**은 하드웨어 친화적이지만 색상과 밝기 분리가 어려움
2. **HSI/HSV 모델**은 직관적인 색상 조작이 가능하나 변환 오버헤드 존재
3. **YUV 모델**은 압축 효율이 뛰어나 방송 및 비디오 처리에 적합
4. **컬러 엣지 검출**은 다채널 정보를 종합하여 단색 엣지보다 강건한 결과 제공
5. **실제 응용**에서는 화이트 밸런스, 피부 검출, 색상 보정 등 다양한 기법 활용

### 최신 동향:
- 딥러닝 기반 컬러 보정(Colorization)
- 다중 스펙트럼(Multispectral) 영상 처리
- HDR(High Dynamic Range) 컬러 매핑
- 색상 대조(Contrast) 최적화 알고리즘

컬러 영상 처리는 컴퓨터 비전, 의료 영상, 콘텐츠 제작 등 다양한 분야에서 핵심 기술로 자리잡고 있으며, 하드웨어 발전과 함께 더욱 정교하고 실시간 처리가 가능해지고 있다.