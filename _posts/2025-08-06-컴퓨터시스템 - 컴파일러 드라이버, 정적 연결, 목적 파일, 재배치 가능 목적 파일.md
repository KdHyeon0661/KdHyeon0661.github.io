---
layout: post
title: 컴퓨터시스템 - 컴파일러 드라이버, 정적 연결, 목적 파일, 재배치 가능 목적 파일
date: 2025-08-06 23:20:23 +0900
category: 컴퓨터시스템
---
# 컴파일러 드라이버, 정적 연결, 목적 파일, 재배치 가능 목적 파일 — CS:APP 스타일로 깊게 이해하기

> 이 글은 C 기반 툴체인(GCC/Clang)을 기준으로, **컴파일러 드라이버 → 목적 파일(ELF) → 재배치 → 정적 연결**의 흐름을 한 번에 정리합니다.  
> 실습 가능한 **C/셸 명령**과 **심볼‧재배치 개념**을 함께 담았습니다.

---

## 1) 컴파일러 드라이버(compiler driver)

### 1.1 정체와 역할
- **컴파일러 드라이버**는 `gcc`, `clang` 처럼 “**한 명령으로 전체 빌드 파이프라인을 오케스트레이션**” 하는 실행 파일입니다.
- 내부 단계:
  1) **전처리(preprocessor)**: `cpp` — `#include`, `#define` 처리, 조건부 컴파일  
  2) **컴파일(compiler)**: `cc1/clang -cc1` — C를 **어셈블리**로 변환  
  3) **어셈블(assembler)**: `as` — 어셈블리를 **목적 파일(.o)** 로 변환  
  4) **링크(linker)**: `ld`(또는 `lld`, `gold`) — 여러 `.o`와 라이브러리를 묶어 **실행 파일/공유 라이브러리** 생성

### 1.2 주요 옵션 요약
- `-E` : 전처리까지만 (표준출력)  
- `-S` : 어셈블리(.s)까지  
- `-c` : 목적 파일(.o)까지  
- (없음) : 링크까지 수행 → 실행 파일 생성  
- `-o out` : 출력 파일 이름  
- `-I` / `-L` / `-lfoo` : 헤더 포함 경로 / 라이브러리 검색 경로 / `libfoo.a` 또는 `libfoo.so` 사용  
- `-static` : **정적 링크** 강제  
- `-shared -fPIC` : 공유 라이브러리 빌드(동적 링크용)  
- `-Wl,option` : 링커 옵션 전달(예: `-Wl,--gc-sections`)

### 1.3 단계를 개별 실행해 보기
```bash
# 1) 전처리만
gcc -E main.c -o main.i

# 2) 컴파일(어셈블리까지)
gcc -S main.i -o main.s

# 3) 어셈블(목적 파일)
gcc -c main.s -o main.o    # 또는 as main.s -o main.o

# 4) 링크(실행 파일)
gcc main.o -o app
```

---

## 2) 목적 파일(Object File) — 포맷과 섹션

### 2.1 종류(ELF 기준; Mach-O/COFF도 유사한 개념)
- **재배치 가능 목적 파일(Relocatable, ET_REL)**: `.o`  
- **실행 파일(ET_EXEC)**: 배치 주소가 고정(PIE 아닐 때)  
- **공유 객체(ET_DYN)**: `.so` (PIE/DSO)

### 2.2 주요 섹션들
| 섹션 | 내용 |
|---|---|
| `.text` | 기계어 코드(실행) |
| `.rodata` | 읽기 전용 상수(문자열 리터럴 등) |
| `.data` | 초기화된 전역/정적 변수 |
| `.bss` | **0으로 초기화되는** 전역/정적 변수(파일 크기에는 미반영) |
| `.symtab` / `.dynsym` | 심볼 테이블(정적/동적) |
| `.strtab` | 심볼/섹션 이름 문자열 테이블 |
| `.rel.*` / `.rela.*` | 재배치 정보(오프셋·타입·대상 심볼) |
| `.comment` | 컴파일러 정보 등 |

### 2.3 도구로 들여다보기
```bash
# 섹션/헤더 개요
readelf -S main.o
objdump -h main.o

# 심볼 테이블(정적)
readelf -s main.o
nm -C main.o

# 재배치 항목
readelf -r main.o
```

---

## 3) 재배치 가능 목적 파일(Relocatable Object) — 왜 필요한가?

### 3.1 문제 배경
- 각 `.o` 파일의 코드/데이터는 **링크 시** 최종 실행 파일 안에서 **어느 주소에 놓일지 아직 모릅니다.**  
- 따라서 컴파일러/어셈블러는 **“주소가 정해지지 않은 자리”** 에 **재배치 항목(Relocation Entry)** 를 남겨 둡니다.

### 3.2 재배치 항목(개념)
- 항목은 보통 **(수정할 위치, 대상 심볼, 연산/타입)** 으로 구성됩니다.  
- **절대 주소(Absolute)** 를 채워야 하는지, **PC상대(PC-relative)** 인지에 따라 타입이 다릅니다.  
- 예: x86-64의 대표 타입(개념)  
  - `R_X86_64_32/64` : 절대 주소/상수 채움  
  - `R_X86_64_PC32` : 현재 명령 주소(PC) 기준 상대 오프셋  
- 링커는 **심볼 해석**으로 심볼의 최종 주소를 결정한 뒤, 이 항목들을 **패치**합니다.

### 3.3 간단 예시

```c
// foo.c
int g = 7;
int foo(int x) { return x + g; }

// bar.c
extern int foo(int);
int main(){ return foo(35); }
```

빌드 단계:
```bash
gcc -c foo.c -o foo.o         # ET_REL
gcc -c bar.c -o bar.o         # ET_REL
readelf -s foo.o | grep ' g ' # g 심볼(정의)
readelf -r bar.o              # foo 참조에 대한 재배치 항목
gcc foo.o bar.o -o app        # 링크: 심볼 해석 + 재배치 → 실행 파일
```

`bar.o`에는 `foo` 호출 지점에 대해 **R_X86_64_PC32** 류의 재배치가 남고, 링커가 `foo`의 최종 주소를 알게 되면 그 차이를 **패치**합니다.

---

## 4) 심볼(Symbol) — 강/약, 정의/선언, 가시성

### 4.1 심볼의 상태
- **정의(Defined)**: 이 오브젝트 파일 안에 실체가 있음(코드/데이터가 배치).  
- **선언(Undefined)**: 이 파일에는 없음(외부에 있음). 링크 시 다른 파일에서 찾아야 함.

### 4.2 강(Strong) vs 약(Weak)
- 전역 함수/변수의 보통 정의는 **Strong**.  
- **약(Weak) 심볼**은 동일 이름 강 심볼이 있으면 **강이 우선**. 유연한 대체/디폴트 구현에 쓰임.
  ```c
  // weak 기본 구현
  __attribute__((weak)) void hook(void) {}
  ```

### 4.3 다중 정의 에러
- **같은 강 심볼**이 여러 `.o`에서 정의되면 **링크 에러**.  
- `static` 내부 연결(translation unit 한정)로 충돌을 피할 수 있음.

---

## 5) 정적 라이브러리(.a)와 정적 연결(static linking)

### 5.1 정적 라이브러리 구조
- `.a`는 단순히 **여러 개의 .o를 묶은 아카이브**입니다.
```bash
ar rcs libmylib.a a.o b.o c.o  # 만들기
ar t libmylib.a                 # 내부 리스트
```

### 5.2 정적 링크의 심볼 해석 규칙(핵심)
- 링커는 **왼쪽에서 오른쪽**으로 입력을 스캔합니다.
- **목적 파일(.o)** 는 **무조건** 포함.  
- **정적 라이브러리(.a)** 는 **필요한 심볼이 있을 때만** 그 멤버(.o)를 꺼내 포함합니다.
- **따라서 라이브러리의 순서가 중요**합니다:
  ```bash
  # OK: 참조(bar) 다음에 libfoo를 둬서 해석 가능
  gcc main.o -L. -lfoo -o app

  # NG: libfoo가 먼저 오면 main.o를 보기 전엔 심볼 필요성을 모름
  gcc -L. -lfoo main.o -o app    # 때로는 undefined reference 에러
  ```

### 5.3 정적 링크의 장단점
- **장점**: 단일 실행 파일에 코드가 모두 포함 → 배포 간편, 로드 시 외부 의존 ↓, 인터포지션 부작용 ↓  
- **단점**: 바이너리 크기 ↑, 보안 업데이트/패치 반영 어려움, 동일 코드가 여러 프로세스에 중복 상주

### 5.4 Dead Code 제거와 섹션 GC
- `-ffunction-sections -fdata-sections` 로 함수/데이터를 섹션 단위로 분리  
- `-Wl,--gc-sections` 로 **도달 불가능한 섹션** 제거 → 크기 ↓, I-캐시 압박 ↓

---

## 6) 재배치(Relocation)의 실제 — 주소 패치와 오프셋

### 6.1 절대 vs PC상대
- **절대 재배치**: “여기에 심볼의 64비트 주소 값을 써 넣어라”  
- **PC상대 재배치**: “분기/호출 대상까지의 **상대 오프셋**을 써 넣어라”
  - x86-64 `call`/`jmp` 등은 보통 **PC상대 32비트** 오프셋을 사용
  - 장점: **위치 독립**에 유리, 코드 재배치(ASLR/PIE) 친화

### 6.2 오버플로와 범위
- 32비트 상대 오프셋에 **도달 불가**한 거리(아주 큰 바이너리/특수 링크 배치)면 링크 에러나 **thunk** 삽입이 필요.

### 6.3 데이터/상수의 재배치
- 문자열 리터럴, 전역 포인터 초기값 등에도 재배치가 남는다(PIE/비PIE 여부에 따라 처리 다름).

---

## 7) 작은 예제로 보는 전→후

### 7.1 코드
```c
// a.c
#include <stdio.h>
int g = 42;
void hello(void) { printf("g=%d\n", g); }

// b.c
void hello(void);
int main(){ hello(); return 0; }
```

### 7.2 단계
```bash
gcc -c a.c -o a.o
gcc -c b.c -o b.o
nm a.o        # g, hello 정의 확인 (T: .text, D: .data)
nm b.o        # hello는 U(Undefined), main은 T

readelf -r b.o  # hello 호출 위치에 재배치 항목 존재

ar rcs libhello.a a.o   # 정적 라이브러리 생성
gcc b.o -L. -lhello -o app    # 정적 링크
./app
```

- 링크 시 `b.o`의 `hello` **미정의 심볼**을 `libhello.a`에서 찾아 **a.o**를 꺼내고,  
  `hello`의 최종 주소로 **재배치**가 수행됩니다.

---

## 8) 정적 vs 동적(간단 비교)

| 항목 | 정적 링크 | 동적 링크(공유 라이브러리) |
|---|---|---|
| 배포 | 단일 바이너리 | 런타임에 `.so` 필요 |
| 업데이트 | 재배포 필요 | 라이브러리 교체로 반영 |
| 로딩/메모리 | 로더 비용↓, 중복 상주 | 로더/재배치 비용↑, 페이지 공유 |
| 인터포지션 | 사실상 없음 | 가능(심볼 오버라이드, LD_PRELOAD 등) |
| 최적화 | LTO로 전역 최적화 용이 | DSO 경계로 제한 |

> **참고**: 현대 배포/보안 요구로 **동적 링크**가 일반적이지만, **임베디드/컨테이너/단일 실행 파일 선호** 상황에서 정적 링크가 채택됩니다.

---

## 9) 빌드 팁(문제 회피)

- **라이브러리 순서**: 참조 대상 **뒤쪽**에 둔다. 필요 시 `--start-group/--end-group` 사용.  
- **중복 정의**: 동일 전역 심볼 중복을 피하고, 내부 전용은 `static`/익명 네임스페이스로.  
- **가시성**: `-fvisibility=hidden` 기본 + 외부 API만 `__attribute__((visibility("default")))`  
- **PIC/PIE**: 공유 라이브러리/PIE에서 필수(`-fPIC`, `-fpie -pie`)  
- **LTO/ThinLTO**: 전역 인라이닝/죽은 코드 제거로 성능·크기 개선  
- **디버그**: `-g` + `objdump -d`, `readelf -a`, `nm`, `ldd`로 진단

---

## 10) 미니 랩: “수동”으로 한 단계씩

```bash
# (1) 전처리/컴파일/어셈블/링크 분리
gcc -E main.c -o main.i
gcc -S main.i -o main.s
gcc -c main.s -o main.o
gcc main.o -o app

# (2) 정적 라이브러리 만들어 연결
gcc -c libx.c -o libx.o
ar rcs libx.a libx.o
gcc main.o -L. -lx -o app_static

# (3) 내부 확인
readelf -S main.o
readelf -s main.o
readelf -r main.o
nm app_static
objdump -d app_static | less
```

---

## 11) 용어 요약(짤막 정리)

- **Compiler Driver**: 빌드 파이프라인 지휘자(`gcc`, `clang`).  
- **Object File(.o)**: 섹션/심볼/재배치 정보를 담은 **중간 산물**(ELF ET_REL).  
- **Relocation**: 링크 시 미정 주소를 최종 주소/오프셋으로 **패치**하는 과정.  
- **Static Library(.a)**: `.o` 묶음 아카이브. 필요한 심볼의 멤버만 끌어다 씀.  
- **Static Linking**: 모든 코드가 실행 파일에 **정적으로 포함**되는 링크 방식.  
- **Symbol Resolution**: 미정(Undefined) 심볼을 어딘가의 **정의(Defined)** 로 매칭하는 절차.  
- **Weak/Strong**: 같은 이름이면 강(Strong)이 약(Weak)을 이김.  
- **PIC/PIE**: 위치 독립 코드/실행 파일; ASLR 친화.

---

## 12) 마무리

- **컴파일러 드라이버**는 전처리→컴파일→어셈블→링크를 한 번에 수행합니다.  
- **목적 파일**은 코드/데이터와 함께 **심볼/재배치 정보**를 담는 컨테이너이고,  
- **재배치 가능 목적 파일(ET_REL)** 은 링크 시 **주소가 정해지지 않은 자리**를 나중에 패치할 **표식**을 포함합니다.  
- **정적 연결**은 필요한 `.o`를 라이브러리에서 꺼내 **심볼 해석 + 재배치**를 마쳐 하나의 실행 파일을 만듭니다.
