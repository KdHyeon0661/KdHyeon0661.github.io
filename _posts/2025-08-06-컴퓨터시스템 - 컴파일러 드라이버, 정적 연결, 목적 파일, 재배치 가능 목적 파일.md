---
layout: post
title: 컴퓨터시스템 - 컴파일러 드라이버, 정적 연결, 목적 파일, 재배치 가능 목적 파일
date: 2025-08-06 23:20:23 +0900
category: 컴퓨터시스템
---
# 컴파일러 드라이버, 정적 연결, 목적 파일, 재배치 가능 목적 파일

## 큰 그림 — 드라이버가 오케스트레이션하는 4단계

```
hello.c ──(cpp)──▶ hello.i ──(cc1/clang -cc1)──▶ hello.s
          전처리                      컴파일(ISA 어셈블리)
hello.s ──(as)──▶ hello.o (ELF ET_REL, 섹션/심볼/재배치)
[a.o b.o … libX.a] ──(ld/lld)──▶ a.out (ET_EXEC/ET_DYN, 재배치 적용)
```

핵심 명령/옵션:

```bash
# 한 단계씩

gcc -E hello.c -o hello.i        # 전처리만
gcc -S hello.i -o hello.s        # 어셈블리까지
gcc -c hello.s -o hello.o        # 목적 파일(ET_REL)
gcc hello.o -o app               # 링크(실행 파일)
```

```
옵션 요약: -E(전처리) -S(어셈) -c(.o) -o out -I/-L/-lfoo -static -shared -fPIC -fpie -pie
링커 옵션 전달: -Wl,option  (예: -Wl,--gc-sections -Wl,-Map=link.map)
드라이버 내부 보기: gcc -v, clang -###    의존성 파일: -MMD -MP -MF deps.d
```

---

## 컴파일러 드라이버(compiler driver)

### 역할

- `gcc`, `clang`은 **단일 명령으로 전체 파이프라인**을 실행한다(전처리→컴파일→어셈블→링크).
- 내부적으로 `cc1/clang -cc1`, `as`, `collect2 + ld/lld`를 호출한다.

### 헤더/라이브러리 탐색 규칙(요약)

- `-Ipath`: 사용자 헤더 우선 탐색(시스템 헤더는 보통 뒤).
- `-Lpath`: 라이브러리 탐색 경로에 추가.
- `-lfoo`: `libfoo.so` 또는 `libfoo.a`를 찾는다(링커 정책/옵션에 따름).

### 드라이버 팁

```bash
# 연결 단계로 넘기는 옵션

gcc main.o -Wl,--gc-sections -Wl,-Map=link.map -o app

# 헤더/라이브러리 탐색 디버깅

gcc -v main.c -o app
```

---

## ELF 목적 파일(Object; ET_REL) — 섹션/심볼/재배치

### ELF 종류

- **ET_REL**: 재배치 필요 목적 파일(.o)
- **ET_EXEC**: 전통적 실행 파일(PIE 아닐 때)
- **ET_DYN**: 공유 객체(.so) 및 PIE 실행 파일 (동적 로더가 재배치)

### 대표 섹션

| 섹션       | 내용/의미 |
|------------|-----------|
| `.text`    | 기계어 코드 |
| `.rodata`  | 상수/문자열 |
| `.data`    | 초기화된 전역/정적 |
| `.bss`     | 제로 초기화 전역/정적(파일 크기 반영 X) |
| `.symtab`  | 정적 심볼 테이블(개발/링크용) |
| `.dynsym`  | 동적 심볼 테이블(런타임 로더용) |
| `.rel.*`/`.rela.*` | 재배치 항목(REL=addend 별도, RELA=addend 포함) |
| `.strtab`/`.dynstr` | 심볼/섹션 이름 문자열 테이블 |

도구로 확인:

```bash
readelf -h -S hello.o         # 헤더/섹션
readelf -s hello.o | less     # 심볼
readelf -r hello.o            # 재배치
objdump -drwC hello.o | less  # 디스어셈+재배치 주석
nm -C hello.o                 # 간단 심볼 목록
```

### 심볼 구조(요점)

- `st_info`: BIND(LOCAL/GLOBAL/WEAK) + TYPE(FUNC/OBJECT/SECTION/FILE…)
- `st_other`: visibility(DEFAULT/HIDDEN 등)
- `st_shndx`: 정의된 섹션 인덱스(또는 UND=미정)
- `st_value`: 섹션 상대 오프셋(ET_REL 기준), `st_size`: 엔티티 크기

---

## 재배치(Relocation) — “주소 미정”을 링크 시 패치

### 왜 필요한가

컴파일 단계에서 각 `.o`는 **최종 배치 주소를 모른다**.
따라서 “여기엔 나중에 심볼 S의 주소/오프셋을 채워 넣어라”는 **재배치 항목**을 남긴다.

### 일반식(ISA/타입에 의존)

재배치 결과는 보통 다음 형식을 취한다:

- **절대**:
  $$
  \text{값} \leftarrow S + A
  $$
- **PC 상대**(분기/호출):
  $$
  \text{값} \leftarrow S + A - P
  $$
  \(S\): 대상 심볼 주소, \(A\): addend, \(P\): “이 값을 쓰는 자리”의 주소

- **GOT/PLT 관련(동적)**: `GOT[S] + A - P`, `PLT[S] + A - P` 류

x86-64 예(대표 타입의 의도):
- `R_X86_64_64`: 64비트 절대(데이터/포인터)
- `R_X86_64_PC32`: 32비트 PC상대 (call/jmp 대상)
- `R_X86_64_GOTPCREL`: RIP상대 + GOT 엔트리
- `R_X86_64_PLT32`: PLT 엔트리 참조(동적 호출)

### 작은 예시(두 파일)

```c
// foo.c
int g = 7;
int foo(int x) { return x + g; }

// bar.c
extern int foo(int);
int main(){ return foo(35); }
```

```bash
gcc -c foo.c -o foo.o         # foo, g 정의
gcc -c bar.c -o bar.o         # foo 참조(미정)

readelf -s foo.o | egrep ' g | foo '
readelf -r bar.o              # foo 호출 지점 재배치(R_X86_64_PC32/PLT32 등)
gcc foo.o bar.o -o app        # 링크: 심볼 해석 → 재배치 적용 → 실행 파일
```

---

## 심볼: 정의/미정, 강/약, 가시성

### 정의/미정

- **Defined**: 이 .o 내부에 실체가 있음(코드/데이터)
- **Undefined(UND)**: 외부에 있음 → 링크 시 해석 필요

### 강(Strong) vs 약(Weak)

- 기본 전역 정의는 **Strong**
- **Weak**는 같은 이름 Strong이 있으면 **Strong 우선**

```c
// weak 기본 구현을 앱이 재정의 가능하게
__attribute__((weak)) void hook(void) {}
```

### 내부 연결/가시성

- `static`(C) 또는 익명 네임스페이스(C++)로 **TU 내부 전용**
- `-fvisibility=hidden` 기본 + 공개 API만 `__attribute__((visibility("default")))`

---

## 정적 라이브러리(.a)와 정적 링크 규칙

### .a 구조

- 단순히 여러 **.o의 아카이브**:
```bash
ar rcs libmylib.a a.o b.o c.o
ar t libmylib.a
```

### 심볼 해석 순서(중요)

- 링커는 **좌→우**로 입력을 스캔
- **일반 .o**: 항상 포함
- **.a**: 그 시점에 **필요한 심볼**이 발견될 때만 해당 멤버 .o를 꺼내 포함
- **순서가 중요**:
```bash
# OK: 참조 이후에 라이브러리

gcc main.o -L. -lfoo -o app

# NG 가능: 라이브러리를 먼저 두면 main.o를 보기 전까지 필요성을 모름

gcc -L. -lfoo main.o -o app

# 복잡한 상호 의존 라이브러리: 그룹 처리

gcc main.o -Wl,--start-group -lA -lB -Wl,--end-group -o app
```

### Dead Code 제거(GC)와 LTO

```bash
# 함수/데이터를 개별 섹션으로 쪼개기

gcc -ffunction-sections -fdata-sections -c x.c -o x.o
# 도달 불가능 섹션 제거

gcc x.o -Wl,--gc-sections -o app
# 전역 최적화(LTO)

gcc -O3 -flto main.c lib.c -o app
```

---

## 링크 내부 동작(개요) — 배치·해석·재배치

1) **섹션 배치 계획**: 입력 섹션을 **출력 섹션(.text/.rodata/.data/.bss…)**으로 병합, 정렬/패딩
2) **주소 할당**: 각 출력 섹션의 VA(가상주소)와 오프셋 결정
3) **심볼 해석**: 미정(UND) → 정의 매칭(순서 규칙/강약 규칙 고려)
4) **재배치 적용**: 각 `REL/RELA` 항목을 실제 **값/오프셋**으로 패치
5) **프로그램 헤더**(ET_EXEC/ET_DYN): 로더가 매핑할 **세그먼트(PT_LOAD…)** 생성

---

## 코드로 보는 재배치: 절대 vs PC-relative

```c
// a.c
extern int ext;
int *p = &ext;         // 데이터 절대 참조 (R_X86_64_64 등)

// b.c
extern void f(void);
void g(){ f(); }       // 호출은 보통 PC상대 (R_X86_64_PC32/PLT32)
```

`readelf -r a.o` 에선 `p` 초기화에 **절대 재배치**가,
`readelf -r b.o` 에선 `f` 호출 지점에 **PC상대 재배치**가 남는다.

수식:
$$
\text{absolute: } \boxed{\text{값} \leftarrow S + A}
\qquad
\text{PC-relative: } \boxed{\text{값} \leftarrow S + A - P}
$$

---

## 정적 vs 동적(간단 비교)

| 항목 | 정적 링크 | 동적 링크(.so) |
|---|---|---|
| 배포 | 단일 바이너리 | 런타임에 공유객체 필요 |
| 업데이트 | 재배포 필요 | 라이브러리 교체로 반영 |
| 메모리 | 코드 중복 상주 가능 | 페이지 공유(프로세스 간) |
| 인터포지션 | 사실상 없음 | 가능(LD_PRELOAD 등) |
| 최적화 | LTO/GC로 전체 최적화 | DSO 경계가 최적화에 제약 |

> 실무: **임베디드/단일 배포**는 정적, **데스크톱/서버**는 동적이 일반적.

---

## PIE/PIC·RIP-relative — 위치 독립과 재배치

- x86-64 컴파일러는 기본적으로 **RIP-relative** 로드/상수 참조를 선호(PIE 친화)
- PIE(`-fpie -pie`) 실행 파일은 **ET_DYN**으로 생성되어 ASLR 하에서 재배치 용이
- 정적 링크 + PIE 조합은 환경에 따라 제약/경고가 있을 수 있으니 툴체인/표준 라이브러리 문서를 확인

어셈 예시(개념):
```asm
# RIP 상대 상수 로드 (PLT/GOT 없이 상수/로컬심볼 접근)

lea rdi, [rip + .LC0]
```

---

## 문제해결 패턴(링커 에러/경고)

### undefined reference to `X`

- 원인: X 정의를 포함한 .o/.a가 **링커 입력 순서상 뒤에 없음**
- 해결: `… main.o -lX` 순서로, 또는 `--start-group/--end-group`

### multiple definition of `X`

- 원인: 같은 강(Strong) 심볼을 여러 곳에서 정의
- 해결: 내부 전용은 `static`, 외부 API는 하나만 노출(또는 weak 사용 정책화)

### relocation … against ‘.rodata’ can not be used when making a PIE

- 원인: PIE 규칙에 맞지 않는 **절대 재배치**
- 해결: `-fPIC/-fpie`로 재컴파일, 상수 접근 방식을 RIP-relative로 유도

---

## 미니 랩 — 재배치/정적 라이브러리/순서의 함정

### 재배치 확인

```c
// lib.c
#include <stdio.h>

int G = 42;
void hello(void){ printf("G=%d\n", G); }

// main.c
void hello(void);
int main(){ hello(); }
```

```bash
gcc -c lib.c -o lib.o
gcc -c main.c -o main.o
readelf -s lib.o | egrep ' G | hello '
readelf -r main.o                # hello 호출의 재배치 확인
ar rcs libhello.a lib.o
gcc main.o -L. -lhello -o app    # OK (순서 중요)
./app
```

### 순서 문제/그룹

```bash
gcc -L. -lhello main.o -o app    # NG 가능
gcc main.o -Wl,--start-group -lA -lB -Wl,--end-group -o app
```

### 섹션 GC + LTO

```bash
gcc -O3 -ffunction-sections -fdata-sections -flto main.c lib.c \
    -Wl,--gc-sections -o slim_app
```

### 링크 맵으로 흐름 보기

```bash
gcc main.o -Wl,-Map=link.map -o app
less link.map   # 어떤 심볼/섹션이 포함됐는지 추적
```

---

## `readelf`/`objdump`로 목적 파일 해부

```bash
readelf -S a.o
#  [Nr] Name      Type     Addr Off  Size ES Flg Lk Inf Al
#  [ 1] .text     PROGBITS 0000 0040 0030 00  AX  0  0 16
#  [ 2] .rela.text RELA     ...  ...  ...
#  [ 3] .data     PROGBITS ...
#  [ 4] .bss      NOBITS   ...
#  [ 5] .rodata   PROGBITS ...
#  [ 6] .symtab   SYMTAB   ...
#  [ 7] .strtab   STRTAB   ...

readelf -s a.o | sed -n '1,40p'     # 심볼 bind/type/size/vis/shndx 관찰
readelf -r a.o                       # 재배치 엔트리(Offset, Info, Type, Sym, Addend)
objdump -drwC a.o | less             # 디스어셈+재배치 주석
```

---

## (선택) ld 직접 다루기 & 링크 스크립트 맛보기

최소 링크 스크립트(개념):

```ld
ENTRY(_start)
SECTIONS {
  . = 0x400000;
  .text : { *(.text .text.*) }
  .rodata : { *(.rodata .rodata.*) }
  .data : { *(.data .data.*) }
  .bss  : { *(.bss .bss.*) *(COMMON) }
}
```

주의: 실제 시스템/런타임 초기화(`crt1.o`, `crti/crtn.o`)와 ABI를 이해하고 시도할 것.

---

## 수식으로 다시 정리 — 재배치·AMAT

- **재배치의 핵심식**
  $$
  \begin{aligned}
  &\text{Absolute:}\quad \boxed{V \leftarrow S + A} \\
  &\text{PC-relative:}\quad \boxed{V \leftarrow S + A - P}
  \end{aligned}
  $$
- **평균 메모리 접근 시간(AMAT)** — 캐시 친화 코드가 왜 중요한지:
  $$
  \text{AMAT} = T_{L1} + m_1\Big(T_{L2} + m_2\big(T_{L3} + m_3 T_\text{Mem}\big)\Big)
  $$

---

## 체크리스트 — 빌드·링크·진단

- [ ] 드라이버 단계별 실행 결과를 **파일로 확인**했는가? (`-E/-S/-c`)
- [ ] `.o` 안의 **섹션/심볼/재배치**를 `readelf -S/-s/-r`로 이해했는가?
- [ ] 정적 라이브러리 **순서**/그룹 옵션을 알고 있는가?
- [ ] **강/약 심볼**, 내부 연결(`static`)과 가시성 정책을 정했는가?
- [ ] **섹션 GC**와 **LTO**로 크기/성능 향상을 검토했는가?
- [ ] PIE/PIC 요구사항을 위배하는 **절대 재배치**를 제거했는가?
- [ ] `-Wl,-Map=…`과 `objdump -drwC`로 **최종 바이너리 경로**를 추적했는가?

---

## 요약

- **컴파일러 드라이버**는 전처리→컴파일→어셈블→링크를 지휘한다.
- **ELF 목적 파일(ET_REL)** 은 코드/데이터와 함께 **심볼·재배치**를 담는 **중간 산물**이다.
- 링크는 **심볼 해석**으로 주소를 정하고, **재배치 항목**을 절대/PC상대로 **패치**한다.
- **정적 라이브러리(.a)** 는 **필요 심볼이 있을 때만** 멤버 .o를 꺼내며, **입력 순서**가 결과를 좌우한다.
- **섹션 GC/LTO/PIE** 등 현대적 옵션을 이해하면 **작고 빠르고 안전한** 바이너리를 만들 수 있다.

---

## 부록 A) 추가 실습 스니펫

### A.1 weak/strong 충돌 확인

```c
// def.c
#include <stdio.h>

__attribute__((weak)) void hook(void){ puts("weak"); }
void run(void){ hook(); }

// app.c
void run(void);
void hook(void){ /* strong */ }
int main(){ run(); }
```

```bash
gcc -c def.c -o def.o
gcc -c app.c -o app.o
gcc def.o app.o -o app && ./app   # hook()의 strong이 weak를 대체
nm app | grep hook                 # W/ T 구분
```

### A.2 `--gc-sections` 효과 보기

```c
// lib.c
void used(void){}
void unused(void){}
```

```bash
gcc -ffunction-sections -fdata-sections -c lib.c -o lib.o
gcc -Wl,--gc-sections lib.o -o app -Wl,-Map=map.txt
grep unused map.txt || echo "unused dropped"
```

---

## 부록 B) 도구 치트시트

```
readelf -h/-l/-S/-s/-r  # ELF 헤더/프로그램헤더/섹션/심볼/재배치
objdump -drwC           # 디스어셈+재배치+심볼 demangle
nm -C                   # 심볼 목록(정렬/필터)
ar rcs/t/x              # 정적 라이브러리 생성/목록/추출
ldd                     # 동적 의존(정적 링크 바이너리는 보통 'not a dynamic executable')
gcc -v / clang -###     # 드라이버 내부 호출 로그
```

이제, **도구로 관찰**하고 **수식으로 해석**하며 **작은 예제**로 확인하라.
CS:APP의 정신대로, **바이너리 내부가 보이면 두려움이 사라지고** 디버깅과 최적화의 속도가 붙는다.
