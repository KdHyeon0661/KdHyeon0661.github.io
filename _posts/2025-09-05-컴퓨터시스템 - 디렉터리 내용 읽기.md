---
layout: post
title: 컴퓨터시스템 - 디렉터리 내용 읽기
date: 2025-09-05 16:20:23 +0900
category: 컴퓨터시스템
---
# 디렉터리 **내용 읽기**

## 0. 큰 그림 — 디렉터리는 “이름 → inode” 레코드의 모음

- **디렉터리 파일**은 여러 **엔트리(record)**로 구성되며 각 엔트리는  
  **이름(`d_name`)**과 **inode 번호(`d_ino`)**를 갖습니다.  
- 사용자 공간에서는 **`opendir` → `readdir` 반복 → `closedir`**로 내용 열람.  
- **순서 보장 없음**: 필요하면 **모아 정렬**하거나 **`scandir`** 사용.  
- **핵심 안전 원칙**: 경로 문자열 조립 대신 **부모 FD 기준 상대 접근**(`dirfd` + `*at`)으로 **레이스·심링크 공격**을 줄인다.

---

## 1. 핵심 API & 자료구조

### 1.1 기본 함수군
```c
#include <dirent.h>

DIR* opendir(const char* path);       // 디렉터리 스트림 열기
struct dirent* readdir(DIR* dirp);    // 다음 엔트리(동일 DIR*에 대해 비재진입적)
int closedir(DIR* dirp);              // 닫기

void rewinddir(DIR* dirp);            // 스트림 시작으로
long telldir(DIR* dirp);              // 위치 질의(플랫폼 의존)
void seekdir(DIR* dirp, long loc);    // 위치 이동(이식성/안정성 제한)
```
- `readdir`는 **DIR*당 정적 버퍼**를 갱신 → **같은 `DIR*`를 다중 스레드에서 공유 금지**.  
  스레드별로 **자기 `DIR*`** 를 쓰면 안전.  
- **`readdir_r`는 폐기**(버퍼 크기·오버플로 문제). 현대 리눅스/글리벡에서는 `readdir` 권장.

### 1.2 `struct dirent` (요약)
```c
struct dirent {
    ino_t          d_ino;     // inode 번호
    off_t          d_off;     // 다음 레코드 오프셋(플랫폼 의존)
    unsigned short d_reclen;  // 이 레코드 길이
    unsigned char  d_type;    // DT_REG/DT_DIR/DT_LNK/DT_UNKNOWN...
    char           d_name[];  // NUL 종단 파일명
};
```
- **`d_type`는 힌트**이며 FS/NFS/커널 옵션에 따라 **`DT_UNKNOWN`** 가능.  
  → 타입이 필요하면 **`fstatat(..., AT_SYMLINK_NOFOLLOW)`** 또는 **`lstat`** 로 확정.

### 1.3 `stat` vs `lstat` vs `fstatat`
- `stat`: 심링크 **따라감**(대상 조사).  
- `lstat`: 심링크 **자체** 조사.  
- `fstatat(dfd, name, &st, AT_SYMLINK_NOFOLLOW)`: **부모 FD 기준** + 링크 미추적 → **TOCTTOU 완화**.

---

## 2. 최소 예제 — 이름 나열(+ 올바른 EOF/에러 판별)

```c
#include <dirent.h>
#include <stdio.h>
#include <errno.h>

int main(int argc, char** argv) {
    const char* path = (argc > 1) ? argv[1] : ".";
    DIR* dp = opendir(path);
    if (!dp) { perror("opendir"); return 1; }

    errno = 0; // NULL 반환 시 EOF/에러 판별용
    for (;;) {
        struct dirent* ent = readdir(dp);
        if (!ent) {
            if (errno != 0) perror("readdir");  // 에러
            break;                              // EOF
        }
        // "."와 ".." 포함됨 → 보통 건너뜀
        puts(ent->d_name);
        errno = 0; // 플랫폼에 따라 다음 루프 전 0으로
    }
    if (closedir(dp) < 0) perror("closedir");
    return 0;
}
```

**포인트**
- `readdir`이 **NULL**이면 **EOF 또는 에러**. 루프 전 **`errno=0`**으로 초기화 후 판정.  
- `closedir` 반환값도 확인(네트워크 FS에서 **지연 오류**가 보고될 수 있음).

---

## 3. 타입·크기 출력 — `d_type` + `fstatat` 폴백

```c
#include <dirent.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

static const char* type_char(unsigned char t) {
    switch (t) {
        case DT_DIR:  return "d";
        case DT_REG:  return "-";
        case DT_LNK:  return "l";
        case DT_FIFO: return "p";
        case DT_SOCK: return "s";
        case DT_CHR:  return "c";
        case DT_BLK:  return "b";
        default:      return "?";
    }
}

int main(int argc, char** argv) {
    const char* path = (argc>1)?argv[1]:".";
    DIR* dp = opendir(path);
    if (!dp) { perror("opendir"); return 1; }

    int dfd = dirfd(dp); // 디렉터리의 FD
    if (dfd < 0) { perror("dirfd"); closedir(dp); return 1; }

    errno = 0;
    for (;;) {
        struct dirent* de = readdir(dp);
        if (!de) { if (errno) perror("readdir"); break; }

        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, "..")) continue;

        unsigned char t = de->d_type;
        struct stat st;

        // 크기/퍼미션 등 메타가 필요하면 어차피 stat이 필요
        if (fstatat(dfd, de->d_name, &st, AT_SYMLINK_NOFOLLOW) != 0) {
            perror("fstatat"); continue;
        }
        if (t == DT_UNKNOWN) {
            t = S_ISDIR(st.st_mode) ? DT_DIR :
                S_ISLNK(st.st_mode) ? DT_LNK :
                S_ISREG(st.st_mode) ? DT_REG : DT_UNKNOWN;
        }

        printf("%s %10lld  %s\n", type_char(t), (long long)st.st_size, de->d_name);
        errno = 0;
    }

    if (closedir(dp) < 0) perror("closedir");
    return 0;
}
```

**왜 `fstatat`인가?**
- 경로 문자열(부모/자식 결합) 없이 **부모 FD 기준**으로 안전 접근.  
- 마지막 요소에 대해 `AT_SYMLINK_NOFOLLOW`로 **링크 미추적** → **TOCTTOU**와 심링크 공격 완화.

---

## 4. 재귀 순회(디렉터리 트리 걷기) — 안전 DFS (openat 기반)

```c
#include <dirent.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

static void handle_file(const char* name, const struct stat* st){
    printf("%s  size=%lld\n", name, (long long)st->st_size);
}

static int walk_dirfd(int dfd) {
    DIR* dp = fdopendir(dfd);    // FD→DIR*, dp가 닫히면 FD도 닫힘
    if (!dp) { perror("fdopendir"); close(dfd); return -1; }

    errno = 0;
    for (;;) {
        struct dirent* de = readdir(dp);
        if (!de) { if (errno) perror("readdir"); break; }

        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, "..")) { errno = 0; continue; }

        struct stat st;
        // 링크는 따라가지 않음
        if (fstatat(dirfd(dp), de->d_name, &st, AT_SYMLINK_NOFOLLOW) < 0) {
            perror("fstatat"); errno = 0; continue;
        }

        if (S_ISDIR(st.st_mode)) {
            // 하위 디렉터리를 O_DIRECTORY로 연 후 재귀
            int cfd = openat(dirfd(dp), de->d_name, O_RDONLY|O_DIRECTORY|O_CLOEXEC
#ifdef O_NOFOLLOW
                             | O_NOFOLLOW // 마지막 요소가 심링크면 실패
#endif
                            );
            if (cfd < 0) { perror("openat(dir)"); errno = 0; continue; }
            if (walk_dirfd(cfd) < 0) { /* 계속 진행 */ }
        } else {
            handle_file(de->d_name, &st);
        }
        errno = 0;
    }
    if (closedir(dp) < 0) { perror("closedir"); return -1; }
    return 0;
}

int main(int argc, char** argv){
    const char* root = (argc>1)?argv[1]:".";
    int dfd = open(root, O_RDONLY|O_DIRECTORY|O_CLOEXEC);
    if (dfd < 0) { perror("open root"); return 1; }
    return walk_dirfd(dfd);
}
```

**장점**
- **문자열 경로 결합 제거** → 길이·인코딩·경쟁 문제 감소.  
- **`O_DIRECTORY`**, (가능하면) **`O_NOFOLLOW`**로 마지막 요소 보호.  
- 하위 부품 접근은 **항상 부모 FD 기준** → 심링크/경로 바꿔치기 대비.

> (Linux 5.6+) **`openat2`** + `RESOLVE_…` 플래그로 **심링크/마직링크/교차 마운트** 차단 정책을 더 강력하게 적용 가능(보안 샌드박스에 유용).

---

## 5. 심볼릭 링크·루프·하드링크 — 무엇을 따라갈 것인가?

- **심링크 루프**: 위 DFS는 `AT_SYMLINK_NOFOLLOW`로 링크를 **따라가지 않아 루프 없음**.  
  만약 **링크를 따라가야 한다면**, `(st_dev, st_ino)`의 방문 집합을 유지해 **루프 차단**:
```c
// 의사코드: 방문 디렉터리 set<dev,ino> 관리
// if pair already in set → skip, else insert and descend
```
- **하드링크**: 파일은 여러 경로에 존재 가능. **중복 처리**를 피하려면 `(st_dev, st_ino)` 기준으로 **이미 본 파일**을 건너뛴다.  
- **마운트 경계**: 다른 FS로 넘어가고 싶지 않다면, 루트의 `st_dev`를 기억하고 **자식의 `st_dev`가 달라지면 skip**(find의 `-xdev`와 유사).

---

## 6. 정렬·필터링 — `scandir`, `alphasort/versionsort`, 스트리밍 정렬

### 6.1 간단히(점파일 숨김 + 알파 정렬)
```c
#define _DEFAULT_SOURCE
#include <dirent.h>
#include <stdlib.h>
#include <stdio.h>

static int hide_dot(const struct dirent* d) {
    return d->d_name[0] != '.'; // 점파일 제외
}

int main(int argc, char** argv) {
    const char* path = (argc>1)?argv[1]:".";
    struct dirent** namelist = NULL;
    int n = scandir(path, &namelist, hide_dot, alphasort);
    if (n < 0) { perror("scandir"); return 1; }
    for (int i = 0; i < n; i++) {
        puts(namelist[i]->d_name);
        free(namelist[i]);
    }
    free(namelist);
    return 0;
}
```
- GNU에는 **`versionsort`**(자연수 감안 정렬)도 있다.  
- **주의**: `scandir`는 **모든 엔트리를 메모리에 모음** → 수십만/수백만 엔트리면 **메모리 폭증**.  
  → 대용량은 **스트리밍 + 외부정렬(or 페이지네이션)** 전략.

### 6.2 대용량 스트리밍 정렬(개념)
- `readdir`로 **청크 단위(예: 100k)** 수집 → 청크별 정렬 후 임시파일에 씀 → 마지막에 **외부 병합 정렬**.  
- 또는 **서버는 스트리밍 출력**하고 **클라이언트(UI)**에서 정렬·필터링.

---

## 7. 성능·대용량 디렉터리 — 시스템콜·stat 최소화

- `readdir`는 내부적으로 **벌크 호출**(`getdents64`) → 자체는 빠름.  
  비용의 대부분은 **(1) `stat` 남발**, **(2) 문자열 가공/정렬/출력**, **(3) 캐시 미스**.  
- **원칙**:  
  1) **필터 먼저**, 필요한 엔트리만 `stat`.  
  2) **이름 패턴/접두**로 1차 거르기.  
  3) 정렬이 꼭 필요할 때만 수행(필요한 키 최소화).  
  4) 하위 디렉터리 탐색은 **작업 큐 + 스레드풀**(동일 디스크의 랜덤 I/O 경쟁은 주의).  
- HDD 대비 SSD/NVMe가 메타데이터 랜덤 접근에 유리하지만, **시스템콜/캐시/브랜치** 비용은 여전히 지배적.

**대략적 비용 모델**
$$
T \approx C_{\text{readdir}}\cdot N \;+\; C_{\text{stat}}\cdot K \;+\; O(N\log N)
$$
- \(N\): 엔트리 수, \(K\le N\): 실제 `stat`를 수행한 엔트리 수.

---

## 8. 보안 — TOCTTOU, 심링크, 경로 길이/인코딩, FD 유출

- **TOCTTOU**: 경로를 문자열로 조립해 `open/stat`을 반복하면,  
  그 사이 **심링크/바인드마운트/교체**로 **대상 변경** 가능.  
  → **부모 FD + `openat/fstatat`**로 항상 **부모 디렉터리 컨텍스트**에서 자식 접근.  
- **`O_NOFOLLOW`/`AT_SYMLINK_NOFOLLOW`**: 마지막 요소 심링크 미추적.  
  (중간 경로 보호는 (Linux) **`openat2` + `RESOLVE_*`** 가 유리)
- **FD 유출 방지**: `O_CLOEXEC`/`FD_CLOEXEC`로 **`exec` 시 자동 닫힘**.  
- **이름 인코딩**: 리눅스 파일명은 바이트 시퀀스(널 제외). UTF-8 가정은 환경에 따라 깨질 수 있음.  
  출력 시 `setlocale(LC_CTYPE, "")` 또는 **바이트 안전 출력** 고려.

---

## 9. 에러 처리·이식성 — 체크리스트

- [ ] `readdir` **NULL** 시 `errno`로 EOF/에러 구분  
- [ ] `readdir_r` **사용 금지**(폐기)  
- [ ] `d_type==DT_UNKNOWN`이면 **`fstatat` 폴백**  
- [ ] **`dirfd` + `openat/fstatat`**로 자식 접근(문자열 결합 최소화)  
- [ ] `closedir` **반환값 확인**(지연 오류 전파)  
- [ ] **`.`/`..` 필터링**  
- [ ] **방문 집합**으로 루프/중복 방지(링크 따라갈 때)  
- [ ] `seekdir/telldir`은 수정되는 디렉터리에서 **불안정/비이식적**임을 인지  
- [ ] (32bit/특정 FS) `EOVERFLOW` 가능성: `ino_t`/`off_t` 크기 주의(`-D_FILE_OFFSET_BITS=64`)  

---

## 10. 고급: Linux `openat2(2)`로 경로 정책 고정 (보안 샌드박스)

> Linux 5.6+: `openat2`는 경로 해석 정책을 구조체로 지정.  
> 예) **심링크 금지**, **부모 밖으로 탈출 금지**(RESOLVE_BENEATH), **매직링크 금지** 등.

```c
// 간략 예시(에러처리 생략). <linux/openat2.h>, <sys/syscall.h> 필요
#include <linux/openat2.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

static int open_safely(int dfd, const char* name) {
    struct open_how how = {
        .flags = O_RDONLY | O_DIRECTORY | O_CLOEXEC,
        .resolve = RESOLVE_BENEATH | RESOLVE_NO_SYMLINKS | RESOLVE_NO_MAGICLINKS
    };
    return syscall(SYS_openat2, dfd, name, &how, sizeof(how));
}
```
- **효과**: 디렉터리 트래버설 동안 **상대경로가 주어진 부모 디렉터리 트리 바깥으로 절대 못 나감**.

---

## 11. 대용량: 반복(비재귀) BFS 패턴 + 방문 집합

```c
#include <dirent.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

// 간단한 FD 큐
typedef struct { int *a; size_t n, cap; } fdq_t;
static void qpush(fdq_t* q, int fd){ if(q->n==q->cap){ q->cap=q->cap?2*q->cap:64; q->a=realloc(q->a,q->cap*sizeof(int)); } q->a[q->n++]=fd; }
static int  qpop (fdq_t* q){ return (q->n? q->a[--q->n] : -1); }

static void visit_dir_fd(int dfd){
    DIR* dp = fdopendir(dfd); if(!dp){ perror("fdopendir"); close(dfd); return; }
    errno = 0;
    for(;;){
        struct dirent* de = readdir(dp);
        if(!de){ if(errno) perror("readdir"); break; }
        if(!strcmp(de->d_name,".") || !strcmp(de->d_name,"..")) { errno=0; continue; }

        struct stat st;
        if (fstatat(dirfd(dp), de->d_name, &st, AT_SYMLINK_NOFOLLOW) < 0) { perror("fstatat"); errno=0; continue; }

        if (S_ISDIR(st.st_mode)) {
            int cfd = openat(dirfd(dp), de->d_name, O_RDONLY|O_DIRECTORY|O_CLOEXEC
#ifdef O_NOFOLLOW
                             | O_NOFOLLOW
#endif
            );
            if (cfd < 0) { perror("openat"); errno=0; continue; }
            // 여기선 BFS 말고 상위에서 큐에 넣도록 반환 설계 가능
            // 데모: 일단 파일 출력
            printf("[DIR] %s\n", de->d_name);
            close(cfd); // 실제 BFS라면 close하지 말고 큐에 보관
        } else {
            printf("      %s\n", de->d_name);
        }
        errno=0;
    }
    closedir(dp);
}
```
- 실제 BFS라면 **하위 디렉터리 FD를 큐에 저장**하고, 루프에서 `qpop`하여 처리.  
- **깊은 트리**에서 **스택 오버플로**를 피하는 데 유리.

---

## 12. 출력·로케일·표시 안전

- 파일명은 **임의 바이트열**일 수 있음(로케일과 불일치).  
  터미널이 UTF-8이 아니면 깨질 수 있다.  
- 안전 출력: `write(1, name, len)` 같은 **바이트 기반** 출력(표시는 깨질 수 있어도 크래시는 방지).  
- 또는 `setlocale(LC_ALL, "")`로 시스템 로케일을 따르되, 여전히 **디코딩 실패 대비**.

---

## 13. `d_type` 값 표 (요약)

| 상수 | 의미 |
|---|---|
| `DT_REG` | 보통 파일 |
| `DT_DIR` | 디렉터리 |
| `DT_LNK` | 심링크 |
| `DT_FIFO` | FIFO |
| `DT_SOCK` | 소켓 |
| `DT_CHR` | 문자 디바이스 |
| `DT_BLK` | 블록 디바이스 |
| `DT_UNKNOWN` | 미상(확정 필요: `fstatat/lstat`) |

> NFS/일부 FS/마운트 옵션에서 **항상 `DT_UNKNOWN`** 일 수 있음. 코드가 **폴백 없이는 깨지지 않도록**.

---

## 14. `scandir` vs 스트리밍 — 언제 무엇을 쓰나?

- **목록이 작고 정렬 필요**: `scandir` + `alphasort/versionsort` 간단·빠름.  
- **목록이 매우 큼**(수십만+): **`readdir` 스트리밍**으로 내보내거나, **외부정렬**.  
- **메타데이터가 많이 필요**: `stat` 비용이 크므로 **필드 최소화** + **필요할 때만**.

---

## 15. C++ 대안 — `std::filesystem` (C++17+)

> 표준이지만, 성능/세부 제어(예: `*at` 보안 패턴)에서는 C 저수준이 더 유리.

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main(int argc, char** argv){
    fs::path root = (argc>1)?argv[1]:".";

    for (auto& p : fs::directory_iterator(root)) {
        auto f = p.path().filename().string();
        auto s = fs::symlink_status(p.path());
        if (fs::is_directory(s)) std::cout << "d " << f << "\n";
        else if (fs::is_symlink(s)) std::cout << "l " << f << "\n";
        else std::cout << "- " << f << "\n";
    }
}
```

- 장점: **가독성**·**이식성**  
- 단점: 링크 정책/부모 FD 기준 접근 같은 **보안 세밀 제어가 어려움**.

---

## 16. 실무 팁(요약)

1. **`readdir` 종료 판정**: `errno=0`→NULL→`errno` 확인.  
2. **`d_type` 맹신 금지**: `DT_UNKNOWN` 폴백 준비.  
3. **`dirfd + openat/fstatat`** 중심으로 설계해 **TOCTTOU**를 완화.  
4. **정렬/필터**는 **먼저 이름 기준**, `stat`는 나중에 필요한 것만.  
5. **대용량**: `scandir` 지양, 스트리밍·외부정렬, 스레드풀 시 I/O 경쟁 주의.  
6. (Linux) **`openat2`**로 경로 정책 고정(샌드박스/CLI 도구 보안성↑).  
7. **`closedir` 오류 확인**(지연 에러).  
8. **로케일/출력 안전**: 이름은 바이트열일 수 있다.

---

## 17. 부록 — 한 화면 도구 만들기: `ls-lite` (정렬+필터+크기)

```c
// ls-lite.c : 점파일 제외, 이름 정렬, 타입/크기(링크 미추적) 출력
#define _DEFAULT_SOURCE
#include <dirent.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

typedef struct Item {
    char* name;
    unsigned char d_type;
    off_t size;
    mode_t mode;
} Item;

static int cmp_name(const void* a, const void* b){
    const Item* x = (const Item*)a, *y=(const Item*)b;
    return strcmp(x->name, y->name);
}

static const char* tch(unsigned char t) {
    switch (t) { case DT_DIR: return "d"; case DT_LNK: return "l"; case DT_REG: return "-"; default: return "?"; }
}

int main(int argc, char** argv){
    const char* path = (argc>1)?argv[1]:".";
    DIR* dp = opendir(path); if(!dp){ perror("opendir"); return 1; }
    int dfd = dirfd(dp); if(dfd<0){ perror("dirfd"); closedir(dp); return 1; }

    size_t cap=1024, n=0; Item* a = malloc(cap*sizeof(Item));
    if(!a){ perror("malloc"); closedir(dp); return 1; }

    errno=0;
    for(;;){
        struct dirent* de = readdir(dp);
        if(!de){ if(errno) perror("readdir"); break; }
        if(de->d_name[0]=='.'){ errno=0; continue; }        // 점파일 제외

        if(n==cap){ cap*=2; a=realloc(a,cap*sizeof(Item)); if(!a){ perror("realloc"); closedir(dp); return 1; } }
        a[n].name = strdup(de->d_name);
        a[n].d_type = de->d_type;

        struct stat st;
        if (fstatat(dfd, de->d_name, &st, AT_SYMLINK_NOFOLLOW)==0) {
            a[n].size = st.st_size;
            a[n].mode = st.st_mode;
            if (a[n].d_type==DT_UNKNOWN) {
                a[n].d_type = S_ISDIR(st.st_mode)?DT_DIR : S_ISLNK(st.st_mode)?DT_LNK : S_ISREG(st.st_mode)?DT_REG : DT_UNKNOWN;
            }
        } else {
            a[n].size = -1; a[n].mode = 0;
        }
        n++; errno=0;
    }
    closedir(dp);

    qsort(a, n, sizeof(Item), cmp_name);
    for(size_t i=0;i<n;i++){
        printf("%s %10lld %s\n", tch(a[i].d_type), (long long)a[i].size, a[i].name);
        free(a[i].name);
    }
    free(a);
    return 0;
}
```

---

## 18. 마무리 — 한 줄 결론

디렉터리 열람은 단순해 보이지만, **정확한 EOF/에러 판정**, **`d_type`의 한계 인지**,  
**`dirfd + openat/fstatat`** 중심의 **경로 레이스 방지**, **대용량에서의 `stat` 최소화/정렬 전략**이 핵심입니다.  
이 원칙만 지키면 `ls`부터 백업/인덱서/검색기까지 **견고하고 빠른 스캐너**를 만들 수 있습니다.