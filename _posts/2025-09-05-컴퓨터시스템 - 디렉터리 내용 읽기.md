---
layout: post
title: 컴퓨터시스템 - 디렉터리 내용 읽기
date: 2025-09-05 16:20:23 +0900
category: 컴퓨터시스템
---
# 디렉터리 **내용 읽기** — UNIX/Linux 심층 가이드

> 목표: **opendir/readdir/closedir**의 정확한 사용법부터  
> `struct dirent`, `d_type` 신뢰성, `lstat/fstatat` 연계,  
> **재귀/반복 순회**, **보안(TOCTTOU/심링크)**, **정렬/필터링**, **성능/대용량 디렉터리**까지.

---

## 1) 큰 그림: 디렉터리는 “파일 이름 → inode”의 테이블

- **디렉터리 파일**은 *엔트리(record)*들의 모음이며, 각 엔트리는  
  **이름(d_name)** 과 **해당 파일의 inode 번호(d_ino)** 를 담습니다.
- 사용자 공간에서는 **`opendir` → `readdir` 반복 → `closedir`** 로 순회합니다.
- **이름 순서는 보장되지 않음**. 정렬이 필요하면 직접 모아 정렬하거나 **`scandir`** 사용.

---

## 2) 핵심 API와 자료구조

### 2.1 기본 함수군
```c
#include <dirent.h>

DIR* opendir(const char* path);      // 디렉터리 스트림 열기
struct dirent* readdir(DIR* dirp);   // 다음 엔트리 포인터(정적 버퍼, 스레드-안전: dirp가 다르면 OK)
int closedir(DIR* dirp);             // 닫기
void rewinddir(DIR* dirp);           // 스트림 위치를 처음으로
long telldir(DIR* dirp);             // 현재 위치 오프셋 조회
void seekdir(DIR* dirp, long loc);   // 오프셋으로 이동(이식성 제한)
```

### 2.2 `struct dirent` (핵심 필드)
```c
struct dirent {
    ino_t          d_ino;    // inode 번호
    off_t          d_off;    // 다음 엔트리까지의 오프셋(플랫폼 의존)
    unsigned short d_reclen; // 레코드 길이
    unsigned char  d_type;   // 파일 타입 힌트(DT_REG/DT_DIR/DT_LNK/DT_UNKNOWN...)
    char           d_name[]; // 널 종단 파일 이름
};
```
- **`d_type`는 힌트**일 뿐입니다. 일부 FS/NFS에서는 **`DT_UNKNOWN`** 이 올 수 있으므로  
  타입이 필요하면 **`fstatat`(또는 `lstat`)** 로 확정하세요.

### 2.3 심볼릭 링크와 메타데이터
- **`stat`** : 링크를 따라감(대상을 조사)  
- **`lstat` / `fstatat(..., AT_SYMLINK_NOFOLLOW)`** : 링크 자체 조사

---

## 3) 최소 예제: 파일 이름 나열

```c
#include <dirent.h>
#include <stdio.h>
#include <errno.h>

int main(int argc, char** argv) {
    const char* path = (argc > 1) ? argv[1] : ".";
    DIR* dp = opendir(path);
    if (!dp) { perror("opendir"); return 1; }

    errno = 0; // readdir가 NULL을 반환했을 때, 에러/EOF 구분을 위해 초기화
    for (;;) {
        struct dirent* ent = readdir(dp);
        if (!ent) {
            if (errno != 0) perror("readdir"); // 에러
            break;                              // EOF
        }
        // "."와 ".." 포함됨 → 필요 시 건너뛰기
        printf("%s\n", ent->d_name);
    }

    if (closedir(dp) < 0) { perror("closedir"); return 1; }
    return 0;
}
```

**포인트**
- `readdir`가 `NULL`을 반환하면 **EOF 또는 에러**입니다.  
  루프 전 `errno=0`으로 초기화하고, `NULL`일 때 `errno`를 보세요.

---

## 4) 타입·크기까지 표시: `d_type` + `fstatat` 폴백

```c
#include <dirent.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

static const char* type_char(unsigned char t) {
    switch (t) {
        case DT_DIR: return "d";
        case DT_REG: return "-";
        case DT_LNK: return "l";
        case DT_FIFO: return "p";
        case DT_SOCK: return "s";
        case DT_CHR: return "c";
        case DT_BLK: return "b";
        default: return "?";
    }
}

int main(int argc, char** argv) {
    const char* path = (argc>1)?argv[1]:".";
    DIR* dp = opendir(path);
    if (!dp) { perror("opendir"); return 1; }

    int dfd = dirfd(dp); // 디렉터리의 FD (open file description)
    if (dfd < 0) { perror("dirfd"); closedir(dp); return 1; }

    errno = 0;
    for (;;) {
        struct dirent* de = readdir(dp);
        if (!de) { if (errno) perror("readdir"); break; }

        // "." ".." 건너뛰기(보통 원함)
        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, "..")) continue;

        unsigned char t = de->d_type;
        struct stat st;

        if (t == DT_UNKNOWN) {
            // 어떤 FS는 타입을 모름 → fstatat으로 확정
            if (fstatat(dfd, de->d_name, &st, AT_SYMLINK_NOFOLLOW) == 0) {
                t = S_ISDIR(st.st_mode) ? DT_DIR :
                    S_ISLNK(st.st_mode) ? DT_LNK :
                    S_ISREG(st.st_mode) ? DT_REG : DT_UNKNOWN;
            } else {
                perror("fstatat");
                continue;
            }
        } else {
            // 크기 등 메타데이터가 필요하면 여전히 stat 필요
            if (fstatat(dfd, de->d_name, &st, AT_SYMLINK_NOFOLLOW) != 0) {
                perror("fstatat");
                continue;
            }
        }

        printf("%s %10lld  %s\n", type_char(t), (long long)st.st_size, de->d_name);
    }

    if (closedir(dp) < 0) perror("closedir");
    return 0;
}
```

**포인트**
- **`dirfd(dp)` + `fstatat`** 조합은 **문자열 경로 결합 없이** 자식을 안전하게 참조합니다.  
  (심볼릭 링크/공격에 대한 **TOCTTOU** 완화)

---

## 5) 재귀 순회(디렉터리 트리 걷기)

### 5.1 안전한 `openat` 기반 DFS (심링크 루프 주의)

```c
#include <dirent.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

static int walk_dirfd(int dfd);

static int handle_entry(int dfd, const char* name, const struct stat* st) {
    // 여기에서 파일 처리(출력/집계 등)
    printf("%s  size=%lld\n", name, (long long)st->st_size);
    return 0;
}

static int walk_dirfd(int dfd) {
    DIR* dp = fdopendir(dfd);    // FD → DIR*
    if (!dp) { perror("fdopendir"); close(dfd); return -1; }

    struct dirent* de;
    errno = 0;
    while ((de = readdir(dp)) != NULL) {
        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, "..")) continue;

        struct stat st;
        // 링크 따라가지 않음 (심링크 루프 방지)
        if (fstatat(dfd, de->d_name, &st, AT_SYMLINK_NOFOLLOW) < 0) {
            perror("fstatat"); continue;
        }

        if (S_ISDIR(st.st_mode)) {
            // 하위 디렉터리를 O_DIRECTORY로 연 후 재귀
            int cfd = openat(dfd, de->d_name, O_RDONLY|O_DIRECTORY|O_CLOEXEC);
            if (cfd < 0) { perror("openat(dir)"); continue; }
            walk_dirfd(cfd);
        } else {
            handle_entry(dfd, de->d_name, &st);
        }
    }
    if (errno != 0) perror("readdir");

    if (closedir(dp) < 0) { perror("closedir"); return -1; }
    return 0;
}

int main(int argc, char** argv){
    const char* root = (argc>1)?argv[1]:".";
    int dfd = open(root, O_RDONLY|O_DIRECTORY|O_CLOEXEC);
    if (dfd < 0) { perror("open root"); return 1; }
    return walk_dirfd(dfd);
}
```

**장점**
- 경로 문자열 조합을 최소화 → **길이/인코딩/레이스** 문제 감소.
- 디렉터리는 **`O_DIRECTORY`** 로만 오픈 → 파일과 구분 명확.

> 참고: POSIX `nftw(3)`/BSD `FTS(3)` 같은 고수준 트리 워커도 있습니다.  
> 직접 구현 시 **심볼릭 링크 루프**(예: `a/b`가 `../a`를 다시 가리킴)에 주의하세요.  
> 루프 방지는 `(st_dev, st_ino)` 집합을 **방문 집합**으로 유지하는 방식이 일반적입니다.

---

## 6) `scandir`로 정렬·필터링 한 번에

```c
#define _DEFAULT_SOURCE
#include <dirent.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

static int hide_dot(const struct dirent* d) {
    return d->d_name[0] != '.'; // 점파일 제외
}

int main(int argc, char** argv) {
    const char* path = (argc>1)?argv[1]:".";
    struct dirent** namelist = NULL;
    int n = scandir(path, &namelist, hide_dot, alphasort);
    if (n < 0) { perror("scandir"); return 1; }

    for (int i = 0; i < n; i++) {
        printf("%s\n", namelist[i]->d_name);
        free(namelist[i]); // 개별 엔트리 해제
    }
    free(namelist);         // 리스트 해제
    return 0;
}
```

**주의**
- `scandir`는 **모든 엔트리 메모리 할당** → 매우 큰 디렉터리에는 비효율일 수 있음.  
  (그럴 땐 스트리밍 방식의 `readdir` + 자체 정렬 전략을 고려)

---

## 7) 에러 처리·보안·이식성 포인트

1. **`readdir` 종료 판정**: 루프마다 `errno=0` → `NULL` 반환 후 `errno` 확인.  
2. **`readdir_r`는 폐기**: 버퍼 크기 문제로 권장되지 않습니다. 그냥 `readdir`를 쓰세요(스레드별 `DIR*` 사용 시 안전).
3. **TOCTTOU 방지**: `dirfd` + `fstatat/openat`로 **부모 FD 기준 상대경로**를 쓰세요.  
   심링크 공격은 `O_NOFOLLOW`/`AT_SYMLINK_NOFOLLOW`로 방어.
4. **경로 조합 최소화**: `snprintf`로 결합하는 대신 **`*at` 계열** 사용.
5. **이름 인코딩**: 리눅스 파일명은 **바이트 시퀀스**(널 제외)입니다. UTF-8 가정은 환경에 따라 틀릴 수 있음(로케일 주의).
6. **`d_type` 신뢰 금물**: `DT_UNKNOWN` 시 항상 `stat`로 확정.
7. **대용량 디렉터리**: 모든 항목에 `stat`를 걸면 매우 느립니다.  
   필요한 엔트리에만 메타데이터를 조회하고, **필터 → 최소한의 `stat`** 순으로.
8. **정렬/페이지네이션**: 수십만 엔트리 정렬 시 메모리·시간 폭증.  
   *외부 정렬*, *스트리밍 출력 + 클라이언트 측 정렬* 같은 아키텍처 고려.

---

## 8) 성능 최적화 힌트

- **I/O 패턴**: 순차 `readdir` 자체는 커널이 내부적으로 **`getdents64`** 로 벌크 읽기.  
  빈번한 `stat`만 줄여도 큰 이득.
- **병렬화**: 하위 디렉터리를 **작업 큐**로 만들어 스레드 풀에서 처리(단, 동일 디스크에서 랜덤 I/O 경쟁에 유의).
- **필터 우선**: 이름 패턴/접두로 *먼저* 거른 뒤 `stat`.
- **SSD/NVMe** 환경**:** 랜덤 메타데이터 조회 비용이 HDD 대비 낮지만 여전히 캐시/TLB/시스템콜 오버헤드가 지배.

---

## 9) 흔한 함정 체크리스트

- [ ] `.`/`..` 엔트리 필터링 했는가?  
- [ ] `readdir(NULL)` 반환 시 **`errno` 확인**했는가?  
- [ ] `d_type`이 `DT_UNKNOWN`일 때 **`stat` 폴백** 적용했는가?  
- [ ] 경로 레이스 방지를 위해 **`openat/fstatat`** 를 사용했는가?  
- [ ] 매우 큰 디렉터리에서 **메모리 폭주(scandir)** 를 피했는가?  
- [ ] **심링크 루프** 방지(방문 집합) 했는가?  
- [ ] `closedir` 반환값도 확인했는가? (네트워크 FS 등에서 오류가 뒤늦게 보고될 수 있음)

---

## 10) 한 줄 결론

디렉터리 열람은 단순해 보이지만, **정확한 종료 판정**, **타입 확정(`stat`)**,  
**`*at` 계열을 통한 레이스 방지**, **대용량에서의 비용 최소화**가 핵심입니다.  
이 원칙만 지키면, `ls`부터 백업/인덱서까지 **견고하고 빠른** 디렉터리 스캐너를 구현할 수 있습니다.