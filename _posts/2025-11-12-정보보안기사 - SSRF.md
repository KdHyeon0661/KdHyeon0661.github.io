---
layout: post
title: 정보보안기사 - SSRF
date: 2025-11-12 23:25:23 +0900
category: 정보보안기사
---
# SECTION 08 웹 애플리케이션 취약점 — 04. 서버 사이드 요청 위조(SSRF: Server-Side Request Forgery) 완전 정리 (원리·공격 벡터·클라우드/내부망 악용·우회기법·실무 방어전략·프레임워크별 안전코드·테스트/모니터링·체크리스트·예상문제)

## 개요 — “내 서버가 내부망 해커가 되는 순간”
**SSRF**는 애플리케이션이 **서버 측에서 외부 자원(URL 등)을 가져오는 기능**을 제공할 때, 공격자가 **임의의 대상**(내부망·클라우드 메타데이터·관리 포트 등)으로 **서버가 직접 요청**하도록 유도하는 취약점이다.  
특징은 다음과 같다.

- 공격 트래픽의 **발원지 IP가 서버**이므로 WAF/ACL을 **우회**하기 쉽다.
- **내부망(127.0.0.1, 10/8, 172.16/12, 192.168/16, fc00::/7, fe80::/10)**, **클라우드 메타데이터(169.254.169.254)**, **관리 포트(2375, 2379, 6443, 11211, 8500, 6379 …)** 등 **외부에서 닿지 않는 자산**에 접근 가능하다.
- URL 파서/리다이렉트/DNS 리바인딩/스킴 우회 등 **해석기의 모호성**을 악용한다.

---

## 위협 모델 — 구성 요소와 데이터 흐름
```
[공격자] --(유도 입력: URL)--> [웹앱] --(서버측 요청)--> [내부망/메타데이터/관리포트]
                                         ^(출처·대상 검증 실패)
```
수식 직관:
\[
\text{SSRF 성공} \iff \text{ServerFetch}(\text{DangerousURL}) \land \neg \text{PolicyAllow}(\text{DangerousURL})
\]
즉, 서버가 **정책상 금지된 목적지**에 대해 **요청을 수행**할 때 성공한다.

---

## 대표 공격 벡터(요약 표)

| 벡터 | 설명 | 예시 |
|---|---|---|
| 내부망 스캔/접근 | 127.0.0.1, RFC1918, RFC4193 등 | `http://127.0.0.1:8080/admin` |
| 메타데이터 탈취 | 169.254.169.254(멀티클라우드) | `http://169.254.169.254/latest/meta-data/iam/security-credentials/` |
| 관리 포트 | Docker/K8s/Consul/Redis/Memcached 등 | `http://127.0.0.1:2375/containers/json` |
| 스킴 우회 | `file://`, `gopher://`, `dict://`, `ftp://` 등 | `gopher://127.0.0.1:11211/_stats` |
| 리다이렉트 체인 | 화이트리스트 도메인 → 외부/내부로 리다이렉트 | `https://good.com/redirect?next=http://169.254.169.254` |
| DNS 리바인딩 | 처음엔 공인 IP, 이후 사설 IP로 변환 | `http://a.attacker-cname.example` |
| IP 인코딩 | 127.0.0.1을 10진/16진/8진/IPv6-mapped | `http://2130706433/`, `http://0x7f000001/`, `[::ffff:127.0.0.1]` |
| 프록시 악용 | 환경변수/프록시 설정을 통한 내부 라우팅 | `HTTP_PROXY` 오염, SSRF→프록시 차단 우회 |

---

## 실제 악용 시나리오

### 1. 이미지 미리보기/URL 링크 미리보기 기능
사용자 입력 `url`로 서버가 이미지를 `GET` 후 썸네일 생성:
```python
# ❌ 취약(교육용): 입력 URL을 그대로 요청
import requests
def fetch_image(url):
    r = requests.get(url, timeout=3)
    return r.content
```
공격 입력:
```
url=http://169.254.169.254/latest/meta-data/  # AWS/GCP/Azure 메타데이터 접근 유도
```
→ 자격증명/토큰/인스턴스 정보 노출 위험.

### 2. 웹훅 검증 없는 콜백 호출기
지정된 `callback_url`로 서버가 데이터를 POST:
```js
// ❌ 취약(교육용)
await fetch(callback_url, { method:'POST', body: JSON.stringify(data) });
```
공격자는 `callback_url`을 내부망 관리 포트로 지정:
```
callback_url=http://127.0.0.1:8500/v1/kv/config?raw=true
```
→ 내부 키/설정 탈취·변조.

### 3. 리다이렉트 체인 + 화이트리스트 우회
화이트리스트 `*.trusted.example`만 허용하나, 그 도메인에 **오픈 리다이렉트**가 존재:
```
https://img.trusted.example/redirect?next=http://169.254.169.254/
```
→ 1차 검증 통과, 실제 요청은 내부/메타데이터로 이동.

---

## 클라우드 메타데이터(핵심 타깃)
- **AWS**: `http://169.254.169.254/latest/meta-data/` (IMDSv1/v2)
- **GCP**: `http://169.254.169.254/computeMetadata/v1/` (`Metadata-Flavor: Google` 헤더 필요)
- **Azure**: `http://169.254.169.254/metadata/instance?api-version=...` (`Metadata:true` 헤더 필요)

> **IMDSv2(AWS)**는 **세션 토큰(프리플라이트 PUT)** 없이는 접근 불가하도록 강화. 그래도 **네트워크 레벨 차단** 병행 권장.

---

## 우회/고급 기법

1) **DNS 리바인딩**: 짧은 TTL/서브도메인으로 초기 해석은 공인 IP → 후속 접속 시 사설 IP로.  
   방어: **연결 시점(remoteAddress) 재검증**, **DNS 핀닝**, **캐시된 IP 재사용 금지**.

2) **인코딩 변형**: `127.0.0.1`을 십진수(2130706433), 16진(`0x7f000001`), 8진, 혼합표기, IPv6-mapped(`::ffff:127.0.0.1`) 등으로 우회.  
   방어: **문자열→정규화→IP 객체 검사**.

3) **리다이렉트 악용**: 화이트리스트 통과 후 내부로 점프.  
   방어: **리다이렉트 금지** 또는 **매 hop 재검증**.

4) **스킴 트릭**: `file://`로 로컬 파일 읽기, `gopher://`로 TCP 원시 페이로드 전송(예: Memcached, Redis 명령).  
   방어: **스킴 화이트리스트(https/http만)**.

5) **프록시 강제**: 환경변수 `HTTP_PROXY`, `NO_PROXY` 악용.  
   방어: **라이브러리의 프록시자동 설정 비활성**, **고정 트러스트 프록시만 허용**.

---

## 안전 설계 원칙(우선순위)

1) **가능하면 “사용자 URL 받지 않기”**  
   - 링크 미리보기/콘텐츠 페치가 꼭 필요하면 **사전 검증된 대상만(allowlist)**.

2) **네트워크 레벨 차단(가장 강력)**  
   - **애플리케이션 서버 → 내부망/메타데이터로의 egress**를 보안그룹/라우팅/방화벽/프록시 정책으로 **차단**.  
   - 쿠버네티스: **NetworkPolicy**로 Pod egress 제한, **169.254.169.254** 차단.

3) **어플리케이션 레벨 방어(다층)**  
   - **스킴/포트/리다이렉트/크기/타임아웃** 제한  
   - **DNS → IP 정규화** 후 **사설/루프백/링크로컬** **완전 차단**  
   - **리다이렉트 매 hop 재검증**  
   - **응답 크기 상한/콘텐츠타입 화이트리스트**  
   - **프록시/환경변수 무시**  
   - **요청 메서드 제한(GET만)**, **헤더 제한**(쿠키/인증 불허)

4) **클라우드 하드닝**  
   - AWS: **IMDSv2 강제(HttpTokens=required)**, 역할 최소권한, 인스턴스 프로필 점검  
   - GCP/Azure: 메타데이터 헤더 요구, VPC 방화벽/라우팅으로 차단  
   - **169.254.169.254**로의 접근을 **보안그룹/라우팅 테이블**에서 원천 봉쇄

---

## “취약 vs 안전” 코드 스니펫

### A. Python (Requests) — 보안 래퍼
```python
# safe_fetch.py
import ipaddress, socket, requests
from urllib.parse import urlparse

PRIVATE_NETS = [
    ipaddress.ip_network("127.0.0.0/8"),
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("169.254.0.0/16"),
    ipaddress.ip_network("0.0.0.0/8"),
    ipaddress.ip_network("100.64.0.0/10"),   # CGNAT
    ipaddress.ip_network("192.0.0.0/24"),
    ipaddress.ip_network("192.0.2.0/24"),
    ipaddress.ip_network("198.18.0.0/15"),
    ipaddress.ip_network("198.51.100.0/24"),
    ipaddress.ip_network("203.0.113.0/24"),
    ipaddress.ip_network("224.0.0.0/4"),
    ipaddress.ip_network("240.0.0.0/4"),
    ipaddress.ip_network("::1/128"),
    ipaddress.ip_network("fc00::/7"),
    ipaddress.ip_network("fe80::/10")
]
ALLOWED_SCHEMES = {"http", "https"}
MAX_BYTES = 2 * 1024 * 1024

def is_private_ip(ip: str) -> bool:
    ip_obj = ipaddress.ip_address(ip)
    return any(ip_obj in n for n in PRIVATE_NETS)

def resolve_all(host):
    # verbatim=True는 OS에 따라 원형 순서를 유지
    infos = socket.getaddrinfo(host, None, proto=socket.IPPROTO_TCP)
    ips = set()
    for family, _, _, _, sockaddr in infos:
        ip = sockaddr[0]
        ips.add(ip)
    return ips

def safe_fetch(url: str, timeout=3):
    u = urlparse(url)
    if u.scheme not in ALLOWED_SCHEMES:
        raise ValueError("scheme not allowed")
    if u.username or u.password:
        raise ValueError("userinfo not allowed")
    if not u.hostname:
        raise ValueError("host required")

    # DNS: 모든 후보를 확인하고 private/loopback 차단
    for ip in resolve_all(u.hostname):
        if is_private_ip(ip):
            raise ValueError("private/loopback address blocked")

    # requests는 redirect 시 호스트가 바뀔 수 있다 → 매 hop 재검증용 hook
    class Guard(requests.sessions.SessionRedirectMixin):
        pass

    with requests.Session() as s:
        s.trust_env = False  # HTTP(S)_PROXY 무시
        def check_resp(r, *args, **kwargs):
            parsed = urlparse(r.url)
            # 리다이렉트 최종 목적지 재검증
            for ip in resolve_all(parsed.hostname):
                if is_private_ip(ip):
                    raise ValueError("redirected to private address")
        s.hooks['response'] = [check_resp]
        r = s.get(url, timeout=timeout, allow_redirects=True, stream=True)
        r.raise_for_status()

        # 응답 크기 제한
        data = b''
        for chunk in r.iter_content(64 * 1024):
            data += chunk
            if len(data) > MAX_BYTES:
                raise ValueError("response too large")
        return r.headers.get('content-type','application/octet-stream'), data
```

### B. Node.js — URL 검증 + 리다이렉트 재검증
```js
// safe-fetch.js
import dns from 'node:dns/promises';
import http from 'node:http';
import https from 'node:https';
import { URL } from 'node:url';
import net from 'node:net';
const ALLOWED = new Set(['http:', 'https:']);

function isPrivate(ip) {
  if (net.isIPv4(ip)) {
    const n = ip.split('.').map(Number);
    const v = (n[0]<<24)|(n[1]<<16)|(n[2]<<8)|n[3];
    const r = (a,b)=> (v>=a && v<=b);
    return r(0x0a000000,0x0affffff)    // 10.0.0.0/8
        || r(0xac100000,0xac1fffff)    // 172.16/12
        || r(0xc0a80000,0xc0a8ffff)    // 192.168/16
        || r(0x7f000000,0x7fffffff)    // 127/8
        || r(0xa9fe0000,0xa9feffff)    // 169.254/16
        || r(0x64000000,0x64ffffff);   // 100.64/10
  }
  // IPv6: loopback, unique-local, link-local
  if (net.isIPv6(ip)) {
    if (ip === '::1') return true;
    if (ip.startsWith('fe80:') || ip.startsWith('fc') || ip.startsWith('fd')) return true;
  }
  return false;
}

async function resolveAll(host) {
  const set = new Set();
  try { (await dns.resolve4(host, { ttl: true })).forEach(a=>set.add(a.address)); } catch {}
  try { (await dns.resolve6(host, { ttl: true })).forEach(a=>set.add(a.address)); } catch {}
  if (!set.size) throw new Error('DNS resolution failed');
  for (const ip of set) if (isPrivate(ip)) throw new Error('private/loopback blocked');
  return true;
}

export async function safeFetch(input, depth=0) {
  if (depth > 3) throw new Error('too many redirects');
  const u = new URL(input);
  if (!ALLOWED.has(u.protocol)) throw new Error('scheme not allowed');
  if (u.username || u.password) throw new Error('userinfo not allowed');
  await resolveAll(u.hostname);

  const mod = u.protocol === 'https:' ? https : http;
  return new Promise((res, rej) => {
    const req = mod.request({
      method: 'GET', hostname: u.hostname, path: u.pathname + u.search,
      port: u.port || (u.protocol==='https:'?443:80),
      timeout: 3000, headers: { 'Accept': 'image/*,text/plain' }
    }, async (r) => {
      if (r.statusCode >= 300 && r.statusCode < 400 && r.headers.location) {
        const loc = new URL(r.headers.location, u);
        try { const out = await safeFetch(loc.toString(), depth+1); res(out); }
        catch(e){ rej(e); }
        return;
      }
      if (r.statusCode >= 400) { rej(new Error('bad status')); return; }
      const chunks = [];
      let size = 0; const MAX = 2*1024*1024;
      r.on('data', d => { size += d.length; if (size > MAX) { req.destroy(); rej(new Error('too big')); } chunks.push(d); });
      r.on('end', () => res(Buffer.concat(chunks)));
    });
    req.on('error', rej);
    req.end();
  });
}
```

### C. Go — Dial 시점 IP 검사(가장 견고)
```go
// safeclient/safeclient.go
package safeclient

import (
  "context"
  "errors"
  "net"
  "net/http"
  "time"
)

func isPrivate(ip net.IP) bool {
  // RFC1918, loopback, link-local, unique-local 등 체크 (간략)
  return ip.IsLoopback() || ip.IsLinkLocalUnicast() || ip.IsPrivate()
}

func Client() *http.Client {
  d := &net.Dialer{ Timeout: 3 * time.Second }
  tr := &http.Transport{
    DialContext: func(ctx context.Context, network, address string) (net.Conn, error) {
      host, port, err := net.SplitHostPort(address)
      if err != nil { return nil, err }
      ips, err := net.LookupIP(host)
      if err != nil || len(ips)==0 { return nil, errors.New("DNS fail") }
      for _, ip := range ips {
        if isPrivate(ip) { return nil, errors.New("private/loopback blocked") }
      }
      return d.DialContext(ctx, network, net.JoinHostPort(host, port))
    },
    DisableCompression: true,
  }
  return &http.Client{ Transport: tr, Timeout: 5 * time.Second }
}
```

---

## 리다이렉트/콘텐츠 제한 정책(필수 체크)

- **리다이렉트 금지** 또는 **hop마다 재검증**  
- **다운로드 크기 상한**(예: ≤ 2MB), **시간 제한**(연결/전체)  
- **Content-Type 화이트리스트**(이미지 처리면 `image/*`만)  
- **쿠키/인증 헤더 제거**(서버가 외부로 토큰 유출 금지)  
- **메서드 제한**: GET만 허용, PUT/POST/DELETE 금지

---

## 네트워크 레벨 차단(운영환경 필수)

### 리눅스(iptables) 예시
```bash
# 서버에서 메타데이터 차단 (Linux)
sudo iptables -A OUTPUT -d 169.254.169.254 -j REJECT
# RFC1918로의 egress 제한(필요 시 특정 자산만 허용)
sudo iptables -A OUTPUT -d 10.0.0.0/8 -j REJECT
sudo iptables -A OUTPUT -d 172.16.0.0/12 -j REJECT
sudo iptables -A OUTPUT -d 192.168.0.0/16 -j REJECT
```

### AWS(EC2) — IMDSv2 강제
```bash
aws ec2 modify-instance-metadata-options \
  --instance-id i-xxxx \
  --http-tokens required \
  --http-endpoint enabled
```

### Kubernetes — NetworkPolicy
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-metadata-egress
spec:
  podSelector: {}   # 모든 Pod 또는 라벨로 선택
  policyTypes: ["Egress"]
  egress:
  - to:
    - ipBlock:
        cidr: 0.0.0.0/0
        except:
        - 169.254.169.254/32
        - 10.0.0.0/8
        - 172.16.0.0/12
        - 192.168.0.0/16
```

---

## 테스트/검증(합법적·사내 승인 환경에서만)

### 1. 간이 취약 서버
```python
# app.py (교육 전용)
from flask import Flask, request
import requests
app = Flask(__name__)

@app.get("/fetch")
def fetch():
    url = request.args.get("url","")
    # ❌ 취약: 아무 검증 없이 서버 사이드 요청
    r = requests.get(url, timeout=3)
    return (r.content, r.status_code, {"Content-Type": r.headers.get('Content-Type','text/plain')})

# 안전 버전은 위 safe_fetch.py 참조
```

### 2. 블라인드 SSRF 관찰
- **응답이 없어도**(방화벽으로 DROP) **응답 지연**/타임아웃 차이를 측정해 포트 스캔 가능:
```text
http://victim/fetch?url=http://10.0.0.1:2379
# 열린 포트는 빠른 RST/응답, 닫힌 포트는 타임아웃 → 시간 기반 내부 스캔
```

### 3. 리다이렉트 우회 검증
- 화이트리스트 도메인에서 `Location:`을 내부로 보내도록 설정한 테스트 페이지로 재현.

---

## 로깅/모니터링 포인트

- **외향 트래픽 패턴**: 웹앱 서버에서 **사설/링크로컬**로 향하는 egress 시도
- **특정 IP/포트**: `169.254.169.254`, `2375`, `2379`, `6443`, `8500`, `11211`, `6379` …
- **HTTP Host 분포**: `localhost`, `127.0.0.1`, `*.cluster.local` 등
- **차단 로그**: “private/loopback blocked”, “redirected to private address”, “response too large”
- **클라우드 감사**: IMDSv2 미적용 인스턴스, SG/라우팅 테이블 변경 이력

---

## 도구/스캐너 활용 팁(테스트 전용)

- DAST(동적)에서 `/fetch?url=` 패턴 탐지 → 내부 주소/메타데이터 시도
- 커스텀 페이로드: IPv6-mapped, 십진·16진 IP, 리다이렉트 체인, `gopher://` 시그니처
- 쿠버네티스/컨테이너 환경: ClusterIP(DNS `*.svc.cluster.local`) 접근 가능성 확인

---

## 개발 파이프라인 체크(코드리뷰 항목)

- [ ] 사용자 입력 URL을 **그대로** 서버가 요청하는 코드가 있는가?
- [ ] **스킴 화이트리스트(http/https)**만 허용하는가?
- [ ] **DNS→IP 정규화** 및 **사설/루프백/링크로컬 차단**을 구현했는가?
- [ ] **리다이렉트 hop마다 재검증**하는가? (혹은 리다이렉트 금지)
- [ ] **프록시/환경변수 무시** 설정을 했는가?
- [ ] **응답 크기/시간 제한**, **Content-Type 화이트리스트** 있는가?
- [ ] **네트워크 레벨 차단**(보안그룹/NetworkPolicy/라우팅)과 **IMDS 보호**가 적용되었는가?

---

## 예상문제(실기 중심)

1) **문항**: SSRF의 주 표적 3가지를 쓰고 각각의 대표 IP/포트를 예시하라.  
   **예시 답**: (1) 클라우드 메타데이터(169.254.169.254), (2) 내부 관리 포트(Docker 2375, K8s API 6443, Consul 8500, Redis 6379, Memcached 11211), (3) 내부 대시보드/패널(127.0.0.1:8080 등)

2) **문항**: 화이트리스트 도메인을 통과하는 리다이렉트 우회를 방지하기 위한 서버측 로직 2가지를 쓰시오.  
   **예시 답**: (1) 리다이렉트 금지 또는 hop마다 목적지 호스트/IP 재검증, (2) 화이트리스트를 **최종 목적지** 기준으로 엄격 적용

3) **문항**: 다음 URL이 내부 주소 우회를 시도하는지 판별하라.  
   a) `http://2130706433/` b) `http://0x7f000001/` c) `http://[::ffff:127.0.0.1]/`  
   **정답**: 모두 127.0.0.1 표현 → 차단

4) **문항**: AWS에서 메타데이터 SSRF를 방어하는 인스턴스 레벨 설정과 네트워크 레벨 설정을 각각 1가지씩 쓰시오.  
   **예시 답**: (인스턴스) IMDSv2 HttpTokens=required, (네트워크) 169.254.169.254로의 egress 차단(보안그룹/라우팅)

5) **문항**: 다음 코드의 취약점을 짚고 안전화 방법을 쓰시오.
```python
r = requests.get(request.args['url'])
```
   **모범답안 요지**: 사용자 URL을 무검증으로 요청(SSRF). 스킴/리다이렉트/크기/타임아웃 제한, DNS→IP 정규화 후 사설/루프백 차단, 프록시 무시, 콘텐츠타입 화이트리스트, 네트워크 레벨 차단 병행.

---

## 리스크 직관(간단 수식)
\[
R = L \times I
\]
- \(L\) (발생확률) ↓: **네트워크 차단 × 앱 레벨 검증 × 리다이렉트/스킴 제한 × 프록시 무시**
- \(I\) (영향도) ↓: **클라우드 메타데이터 보호(IMDSv2), 내부 서비스 인증/ACL, 최소권한**

---

## 결론
- SSRF는 **서버를 프록시 삼아** 내부망/메타데이터/관리포트로 침투한다.  
- 가장 강력한 방어는 **네트워크 레벨 egress 차단**과 **IMDS 보호**이며, 반드시 **애플리케이션 레벨(스킴·DNS·IP·리다이렉트·크기/시간·프록시) 다층 방어**를 결합해야 한다.  
- 프레임워크에 **안전 래퍼**를 표준화해 재사용하고, CI/CD에서 **정적/동적 검증**을 자동화하라.  
- 운영 중에는 **사설/링크로컬로 향하는 egress**를 지속 모니터링하고, 이상 징후를 조기 차단하라.

---
## 부록: 참고 체크리스트(요약)

- [ ] 사용자 URL 대신 **사전 승인 대상(allowlist)**만
- [ ] **http/https만 허용**, `file/gopher/ftp/dict/data` 금지
- [ ] **DNS→IP 정규화**, 사설/루프백/링크로컬 **완전 차단**
- [ ] **리다이렉트 hop마다 재검증** 또는 금지
- [ ] **응답 크기/시간 상한**, **콘텐츠타입 화이트리스트**
- [ ] **프록시/환경변수 무시**
- [ ] **네트워크 레벨 차단**(보안그룹/NetworkPolicy/iptables)
- [ ] **IMDSv2 강제**(AWS), GCP/Azure 메타데이터 헤더 및 네트워크 차단
- [ ] 로그·SIEM에서 **169.254/사설대역 egress** 탐지 룰
- [ ] 보안 점검/리뷰/회귀 테스트 자동화