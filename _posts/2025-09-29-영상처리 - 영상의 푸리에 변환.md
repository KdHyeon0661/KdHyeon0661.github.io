---
layout: post
title: 영상처리 - 영상의 푸리에 변환
date: 2025-09-29 16:25:23 +0900
category: 영상처리
---
# 영상의 푸리에 변환 (2D DFT)

## 2차원 영상의 푸리에 변환 — 이론

### 정의

크기 \(W\times H\) 실수 영상 \(f(x,y)\) (여기서 \(x=0\ldots W-1, y=0\ldots H-1\))에 대한 2D **이산 푸리에 변환(DFT)**:

\[
F(u,v) = \sum_{y=0}^{H-1}\sum_{x=0}^{W-1} f(x,y)\; e^{-j2\pi\left(\frac{ux}{W}+\frac{vy}{H}\right)},\quad
u=0\ldots W-1,\ v=0\ldots H-1
\]

역변환:

\[
f(x,y) = \frac{1}{WH}\sum_{v=0}^{H-1}\sum_{u=0}^{W-1} F(u,v)\; e^{+j2\pi\left(\frac{ux}{W}+\frac{vy}{H}\right)}.
\]

- **크기** \( |F| \), **위상** \( \angle F \) 로 스펙트럼을 해석합니다.
- 실수 영상이면 **켤레 대칭**: \(F(W-u,H-v)=\overline{F(u,v)}\) (인덱스 모드 연산).

### 분리 가능성과 Row–Column 알고리즘

지수 항이 \(x\)-항과 \(y\)-항으로 **분리 가능**하므로,
1D-DFT를 **행마다** → **열마다** 한 번씩 수행해 2D-DFT를 얻을 수 있습니다.
이를 **Row–Column(DFTRC)** 이라고 부르며,
복잡도는 \(O(W^2H + WH^2)\) (직접식 \(O(W^2H^2)\) 대비 대폭 감소).

### 센터링(중심 정렬)

시각화에서 DC(저주파)를 중앙에 두기 위해, 원본에
\[
g(x,y)=f(x,y)\cdot(-1)^{x+y}
\]
를 곱하고 DFT를 수행하면, 별도 **사분면 교환(fftshift)** 없이 중앙에 DC가 옵니다.

### 창(Window), 제로패딩(Zero-padding)

- **창**: 경계 불연속으로 인한 누설을 줄이려면 Hann/Hamming 등 창 곱을 권장.
- **제로패딩**: 패딩 후 DFT 길이를 늘리면 주파수 격자 간격이 촘촘해져 **피크 위치 파악**이 쉬워집니다.

---

## 2차원 DFT — C++ 구현

아래는 교육용 **직접식(Direct)** 과 **개선형(DFTRC)** 을 모두 제공합니다.
실무/대형 영상은 반드시 **FFT**(예: Cooley–Tukey) 사용을 고려하세요.

### 공통 유틸 (그레이스케일, 창, 센터링, 패딩, 시각화)

```cpp
// dft2d.hpp
#pragma once
#include <vector>
#include <complex>
#include <cmath>
#include <cstdint>
#include <algorithm>
#include <stdexcept>
#include "IppDib.h"

using cd = std::complex<double>;
constexpr double PI = 3.14159265358979323846;

// ---------------------- 그레이스케일 변환 ----------------------
inline void DibToGrayDouble(const IppDib& src, std::vector<double>& G, int& W, int& H)
{
    if (!src) { W=H=0; G.clear(); return; }
    W = src.width(); H = src.height();
    G.assign((size_t)W*H, 0.0);
    for (int y=0; y<H; ++y){
        const uint8_t* row = (const uint8_t*)src.bits() + (size_t)y*src.stride();
        for (int x=0; x<W; ++x){
            int B=row[x*4+0], Gc=row[x*4+1], R=row[x*4+2];
            double Y = 0.114*B + 0.587*Gc + 0.299*R; // ITU-R BT.601
            G[(size_t)y*W + x] = Y;
        }
    }
}

// ---------------------- 창(Window) ----------------------
inline std::vector<double> window_hann(int N){
    std::vector<double> w(N,1.0);
    if (N<=1) return w;
    for (int n=0;n<N;++n) w[n]=0.5*(1.0 - std::cos(2.0*PI*n/(N-1)));
    return w;
}
inline void apply_2d_window_inplace(std::vector<double>& G, int W, int H,
                                    const std::vector<double>& wx,
                                    const std::vector<double>& wy)
{
    if ((int)wx.size()!=W || (int)wy.size()!=H) throw std::runtime_error("window size mismatch");
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            G[(size_t)y*W+x] *= wx[x]*wy[y];
        }
    }
}

// ---------------------- 센터링 (-1)^(x+y) ----------------------
inline void multiply_centering_inplace(std::vector<double>& G, int W, int H)
{
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            if ( ((x^y)&1) ) G[(size_t)y*W+x] = -G[(size_t)y*W+x];
        }
    }
}

// ---------------------- 제로패딩 ----------------------
inline void pad2d(const std::vector<double>& G, int W, int H,
                  std::vector<double>& P, int PW, int PH)
{
    P.assign((size_t)PW*PH, 0.0);
    for (int y=0;y<std::min(H,PH);++y){
        const double* s = &G[(size_t)y*W];
        double*       d = &P[(size_t)y*PW];
        std::copy(s, s+std::min(W,PW), d);
    }
}

// ---------------------- 스펙트럼 → IppDib (시각화) ----------------------
// mag = log(1+|F|) 정규화하여 0~255로 매핑. (centered=true면 DC가 중앙)
inline IppDib MakeSpectrumImage(const std::vector<cd>& F, int W, int H, bool centered=true)
{
    // |F| 계산 + log
    std::vector<double> M((size_t)W*H);
    double maxv=1e-12;
    for (size_t i=0;i<M.size();++i){
        double m = std::abs(F[i]);
        double lm = std::log(1.0 + m);
        M[i]=lm; if (lm>maxv) maxv=lm;
    }
    double inv = (maxv>0)? (255.0/maxv) : 1.0;

    IppDib out; out.create(W,H,32);
    auto put = [&](int x,int y, uint8_t v){
        uint8_t* p=(uint8_t*)out.bits() + (size_t)y*out.stride() + x*4;
        p[0]=p[1]=p[2]=v; p[3]=255;
    };

    if (centered){
        // DC가 중앙에 오도록 그리기(이미 입력 F가 센터링되어 있다면 그대로 배치)
        // 여기서는 추가 fftshift 없이 그대로 배열을 '사분면 교환'해 시각화
        int hx=W/2, hy=H/2;
        auto at=[&](int x,int y)->double{ return M[(size_t)y*W+x]; };
        for (int y=0;y<H;++y){
            for (int x=0;x<W;++x){
                int sx = (x+hx)%W; // shift
                int sy = (y+hy)%H;
                uint8_t v = (uint8_t)std::lround( std::min(255.0, at(sx,sy)*inv) );
                put(x,y, v);
            }
        }
    } else {
        for (int y=0;y<H;++y){
            for (int x=0;x<W;++x){
                uint8_t v = (uint8_t)std::lround( std::min(255.0, M[(size_t)y*W+x]*inv) );
                put(x,y, v);
            }
        }
    }
    return out;
}
```

### **직접식(Direct)** 2D DFT — \(O(W^2H^2)\)

학습/검증용. 작은 타일(예: 64×64, 128×128)에만 권장.

```cpp
// dft2d_direct.hpp
#pragma once
#include <vector>
#include <complex>
#include <cmath>
#include "dft2d.hpp"

inline std::vector<cd> DFT2D_Direct(const std::vector<double>& G, int W, int H)
{
    std::vector<cd> F((size_t)W*H);
    for (int v=0; v<H; ++v){
        for (int u=0; u<W; ++u){
            cd acc=0.0;
            for (int y=0;y<H;++y){
                double ay = -2.0*PI*double(v*y)/double(H);
                for (int x=0;x<W;++x){
                    double ax = -2.0*PI*double(u*x)/double(W);
                    double ang = ax + ay;
                    double re = std::cos(ang), im = std::sin(ang);
                    acc += G[(size_t)y*W + x] * cd(re, im);
                }
            }
            F[(size_t)v*W + u] = acc;
        }
    }
    return F;
}
```

### **개선형(DFTRC)** — Row–Column (분리 계산)

행/열 1D-DFT를 재사용하여 **크게 빠른** 2D-DFT를 얻습니다.

```cpp
// dft2d_rc.hpp
#pragma once
#include <vector>
#include <complex>
#include <cmath>
#include "dft2d.hpp"

// 1D DFT (전방) : X[k] = sum_n x[n] e^{-j2πkn/N}
inline void DFT1D(const cd* x, cd* X, int N)
{
    for (int k=0;k<N;++k){
        cd acc=0.0;
        double angk = -2.0*PI*double(k)/double(N);
        for (int n=0;n<N;++n){
            double ang = angk * double(n);
            acc += x[n] * cd(std::cos(ang), std::sin(ang));
        }
        X[k]=acc;
    }
}

// Row–Column 2D DFT : 먼저 행, 그 다음 열
inline std::vector<cd> DFT2D_RowColumn(const std::vector<double>& G, int W, int H)
{
    // 1) 행 DFT: (H × W) real → (H × W) complex
    std::vector<cd> tmp((size_t)W*H), F((size_t)W*H);
    std::vector<cd> buf_in(W), buf_out(W);

    for (int y=0;y<H;++y){
        // real -> complex 승격
        for (int x=0;x<W;++x) buf_in[x] = cd(G[(size_t)y*W+x], 0.0);
        DFT1D(buf_in.data(), buf_out.data(), W);
        for (int u=0;u<W;++u) tmp[(size_t)y*W + u] = buf_out[u];
    }

    // 2) 열 DFT: (H × W) complex → (H × W) complex
    std::vector<cd> col_in(H), col_out(H);
    for (int u=0;u<W;++u){
        for (int y=0;y<H;++y) col_in[y] = tmp[(size_t)y*W + u];
        // 열 방향 1D DFT
        for (int v=0; v<H; ++v){
            cd acc=0.0;
            double angv = -2.0*PI*double(v)/double(H);
            for (int y=0;y<H;++y){
                double ang = angv * double(y);
                acc += col_in[y] * cd(std::cos(ang), std::sin(ang));
            }
            col_out[v]=acc;
        }
        for (int v=0; v<H; ++v) F[(size_t)v*W + u] = col_out[v];
    }
    return F;
}
```

> **속도 팁**
> - 위 1D-DFT는 cos/sin를 매 호출마다 계산합니다. N이 고정이면 **twiddle table**(미리 cos/sin)을 만들어 재사용하면 2~3배 개선됩니다.
> - 더 큰 개선이 필요하면 **FFT** 로 전환하세요.

---

## 개선된 2차원 영상의 푸리에 변환 — 실전 파이프라인

아래는 실전에서 쓰는 절차를 모두 포함합니다:

1) **그레이스케일 변환**
2) (옵션) **창** 곱(Hann)
3) (옵션) **센터링** \((-1)^{x+y}\)
4) (옵션) **제로패딩**(출력 분석 그리드 촘촘화)
5) **DFTRC** 수행
6) **스펙트럼 시각화** (log 스케일, DC 중앙)

```cpp
// dft2d_pipeline.hpp
#pragma once
#include "dft2d.hpp"
#include "dft2d_rc.hpp"
#include "dft2d_direct.hpp" // 학습용(작은 크기만)

// 고수준 파이프라인
struct Dft2dOptions {
    bool useRowColumn = true; // false면 Direct (작은 크기만!)
    bool useHann = true;
    bool useCentering = true; // (-1)^(x+y)
    int  padW = 0;            // 0이면 원본 W, 그 외는 지정
    int  padH = 0;            // 0이면 원본 H
};

inline bool Run2DDFT(const IppDib& src, IppDib& spectrumOut, Dft2dOptions opt)
{
    int W,H; std::vector<double> G;
    DibToGrayDouble(src, G, W, H);
    if (W<=0 || H<=0) return false;

    // 1) 창(옵션)
    if (opt.useHann){
        auto wx=window_hann(W), wy=window_hann(H);
        apply_2d_window_inplace(G, W, H, wx, wy);
    }

    // 2) 센터링(옵션)
    if (opt.useCentering) multiply_centering_inplace(G, W, H);

    // 3) 패딩
    int PW = (opt.padW>0? opt.padW : W);
    int PH = (opt.padH>0? opt.padH : H);
    std::vector<double> P;
    pad2d(G, W, H, P, PW, PH);

    // 4) DFT
    std::vector<cd> F = opt.useRowColumn ? DFT2D_RowColumn(P, PW, PH)
                                         : DFT2D_Direct(P, PW, PH);

    // 5) 스펙트럼 이미지 (log, 중앙 DC)
    spectrumOut = MakeSpectrumImage(F, PW, PH, /*centered=*/true);
    return true;
}
```

---

## **대화 상자(UI)** — DFT/DFTRC 옵션

### 리소스 ID

```cpp
// resource.h (추가)
#define IDD_DFT2D_DLG               3100
#define IDC_RAD_DFT_DIRECT          3101
#define IDC_RAD_DFT_RC              3102
#define IDC_CHK_DFT_HANN            3103
#define IDC_CHK_DFT_CENTER          3104
#define IDC_EDIT_DFT_PADW           3105
#define IDC_EDIT_DFT_PADH           3106

// 메뉴
#define ID_FREQ_DFT                 70010
#define ID_FREQ_DFTRC               70011

```

### RC 파일

```rc
// ImageTool.rc (추가)
IDD_DFT2D_DLG DIALOGEX 0,0, 220, 130
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "2D DFT Options"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Algorithm", -1, 10, 10, 100, 42
    AUTORADIOBUTTON "Direct (slow)", IDC_RAD_DFT_DIRECT, 18, 24, 80, 10, WS_TABSTOP
    AUTORADIOBUTTON "Row-Column (fast)", IDC_RAD_DFT_RC, 18, 36, 100, 10

    AUTOCHECKBOX "Hann window",  IDC_CHK_DFT_HANN,   120, 16, 80, 10
    AUTOCHECKBOX "Centering (-1)^(x+y)", IDC_CHK_DFT_CENTER, 120, 28, 90, 18

    LTEXT "Pad W:", -1, 20, 60, 30, 10
    EDITTEXT IDC_EDIT_DFT_PADW, 50, 58, 40, 14, ES_NUMBER
    LTEXT "Pad H:", -1, 20, 78, 30, 10
    EDITTEXT IDC_EDIT_DFT_PADH, 50, 76, 40, 14, ES_NUMBER

    DEFPUSHBUTTON "OK", IDOK,  78, 104, 48, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 130, 104, 48, 16
END

// 메뉴
POPUP "&Frequency"
BEGIN
    MENUITEM "DFT (Direct/RC)...", ID_FREQ_DFT
    MENUITEM "DFTRC (Quick)...",   ID_FREQ_DFTRC
END
```

### 대화 상자 코드

```cpp
// Dft2dDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "dft2d_pipeline.hpp"

class Dft2dDlg {
public:
    Dft2dDlg(HWND owner, IppDib& dib) : owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);

    int ReadInt(HWND h, int id, int def) const;
    bool IsChecked(HWND h, int id) const { return IsDlgButtonChecked(h,id)==BST_CHECKED; }

private:
    HWND owner_=nullptr;
    IppDib& dib_;
};

```

```cpp
// Dft2dDlg.cpp
#include "Dft2dDlg.h"

INT_PTR Dft2dDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_DFT2D_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK Dft2dDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(Dft2dDlg*)l; return self->OnInit(h);
    }
    auto* self=(Dft2dDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w,l);
    return FALSE;
}
INT_PTR Dft2dDlg::OnInit(HWND h){
    CheckRadioButton(h, IDC_RAD_DFT_DIRECT, IDC_RAD_DFT_RC, IDC_RAD_DFT_RC);
    CheckDlgButton(h, IDC_CHK_DFT_HANN,   BST_CHECKED);
    CheckDlgButton(h, IDC_CHK_DFT_CENTER, BST_CHECKED);
    SetDlgItemInt(h, IDC_EDIT_DFT_PADW, 0, FALSE);
    SetDlgItemInt(h, IDC_EDIT_DFT_PADH, 0, FALSE);
    return TRUE;
}
int Dft2dDlg::ReadInt(HWND h, int id, int def) const {
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE);
    if (!ok) return def; return v;
}
INT_PTR Dft2dDlg::OnCommand(HWND h, WPARAM w, LPARAM){
    switch (LOWORD(w)){
    case IDOK: {
        Dft2dOptions opt;
        opt.useRowColumn = (IsDlgButtonChecked(h, IDC_RAD_DFT_RC)==BST_CHECKED);
        opt.useHann      = IsChecked(h, IDC_CHK_DFT_HANN);
        opt.useCentering = IsChecked(h, IDC_CHK_DFT_CENTER);
        opt.padW         = ReadInt(h, IDC_EDIT_DFT_PADW, 0);
        opt.padH         = ReadInt(h, IDC_EDIT_DFT_PADH, 0);

        IppDib spec;
        if (Run2DDFT(dib_, spec, opt)) {
            // 스펙트럼을 새 창으로 띄우기(프로젝트의 '새 도큐먼트 만들기' 유틸을 사용)
            // 예: NewDocumentFromDib(spec, L"Spectrum");
            // 여기서는 간단히 현재 문서 교체:
            dib_ = spec;
        }
        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL: EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

---

## **DFT & DFTRC 메뉴** — 메시지 처리

```cpp
// main_multiwin.cpp (발췌)
#include "Dft2dDlg.h"

case ID_FREQ_DFT:
case ID_FREQ_DFTRC:
    if (st && st->dib) {
        Dft2dDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK) {
            InvalidateRect(hWnd, nullptr, FALSE);
            OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

> 두 메뉴 모두 같은 대화 상자를 띄우지만, 단축키에 따라 **Direct/RC 기본값**을 다르게 주고 싶다면
> `Dlg::OnInit`에서 `LOWORD(wParam)` 을 확인해 라디오 버튼 초기 선택을 분기하면 됩니다.

---

## 예제 & 상황

### 예제 A) **체커보드(Checkerboard)** 스펙트럼

- **상황**: 8×8 주기 타일의 흑백 체커보드(명암 0/255).
- **절차**: Hann **OFF** (정수 주기라서 누설 적음), Centering **ON**, 패딩(예: 512×512) → **DFTRC**.
- **결과**: 중앙(DC) 주위에 **격자형 고주파 피크**가 규칙적으로 나타납니다. 주기(칸 크기)가 작을수록 피크가 **더 멀리** 퍼집니다.

### 예제 B) **줄무늬(Striping)** 주기 검출

- **상황**: 스캐너 줄무늬 노이즈가 수평 방향 반복.
- **절차**: Hann **ON**, Centering **ON**, DFTRC.
- **결과**: 수직축(주파수 \(u=0\)) 주변에 피크가 관찰됩니다. 피크 위치로 **주기(픽셀)** 를 역산 → Notch 필터 설계의 근거가 됩니다.

### 예제 C) **제로패딩**으로 피크 위치 정밀화

- **상황**: 기계 부품 사진의 미세 주기 분석, 원본 640×480.
- **절차**: Hann **ON**, Centering **ON**, **Pad 2048×2048**, DFTRC.
- **결과**: 피크 위치를 더 촘촘한 격자에서 관찰 → 주기 추정 오차 감소(분해능 향상이 아닌 **보간** 효과임을 기억).

### 예제 D) **Direct vs DFTRC** 성능 비교(학습)

- **상황**: 128×128 패턴 타일.
- **절차**: Direct와 DFTRC 둘 다 실행 → 시간 비교.
- **결과**: Direct는 체감상 매우 느림, DFTRC는 즉시(특히 256×256 이상에서 차이가 큼).
- **메시지**: 실전은 **FFT** 로 가야 한다는 교훈.

---

## 정확성/품질 팁

- **센터링 규약**:
  - \((-1)^{x+y}\) 를 곱하면 **계산 전**에 데이터를 교번 부호화하여 **DC가 중앙**에 위치합니다.
  - 시각화에서 추가 **fftshift** 를 수행할 필요가 없어 UX가 단순해집니다.

- **창의 선택**:
  - 주기성이 **격자**와 딱 맞으면 창이 없어도 누설이 적지만, 대부분의 자연 영상은 **Hann** 을 권장.
  - 창은 **부엽을 낮추는** 대신 **주엽 폭을 늘리는** 트레이드오프가 있습니다.

- **스펙트럼 스케일**:
  - 시각화는 보통 **log(1+|F|)** 를 씁니다. 선형 스케일은 밝은 영역만 하이라이트되고 나머지가 암부에 묻히므로 비권장.

- **정규화**:
  - 역DFT에서 \(1/(WH)\) 를 곱해야 원상복구가 됩니다(본 장은 **전방 변환**과 시각화에 집중).

- **알파**:
  - 입력은 **그레이스케일**(휘도)로 변환한 뒤 DFT. 스펙트럼 이미지의 알파는 255(불투명)로 통일.

---

## (보너스) Twiddle 캐시 & 열/행 공용

아래 간단 캐시로 **cos/sin 재계산**을 줄일 수 있습니다.

```cpp
// twiddle_cache.hpp
#pragma once
#include <vector>
#include <complex>
#include <unordered_map>
#include <cmath>

using cd = std::complex<double>;
constexpr double PI = 3.14159265358979323846;

struct TwiddleCache {
    std::unordered_map<int, std::vector<cd>> tbl_fwd; // e^{-j2πk/N}
    const std::vector<cd>& getFwd(int N){
        auto it=tbl_fwd.find(N);
        if (it!=tbl_fwd.end()) return it->second;
        std::vector<cd> w(N);
        for (int k=0;k<N;++k){
            double ang=-2.0*PI*double(k)/double(N);
            w[k]=cd(std::cos(ang), std::sin(ang));
        }
        return tbl_fwd.emplace(N, std::move(w)).first->second;
    }
};

// w: e^{-j2πk/N} 테이블
inline void DFT1D_cached(const cd* x, cd* X, int N, const std::vector<cd>& w){
    for (int k=0;k<N;++k){
        cd acc=0.0;
        for (int n=0;n<N;++n){
            // x[n] * w[(k*n) mod N]
            int idx = (int)((1LL*k*n)%N);
            acc += x[n]*w[idx];
        }
        X[k]=acc;
    }
}
```

이 캐시를 `DFT2D_RowColumn` 의 행/열 변환에 적용하면 **재활용**되어 속도가 향상됩니다(특히 반복 호출 시).

---

## 요약

- 2D-DFT는 **분리 가능**하여 Row–Column(DFTRC)로 효율적으로 계산할 수 있습니다.
- **창·센터링·제로패딩**을 조합하면 실전에서 더 유용한 스펙트럼을 얻습니다.
- 본문 코드는 **Direct**(학습/작은 타일)와 **DFTRC**(실용)에 모두 대응하며, 스펙트럼을 **log/중앙 정렬**로 시각화합니다.
- 대형 영상/실시간 처리는 **FFT** 로 전환하세요.
