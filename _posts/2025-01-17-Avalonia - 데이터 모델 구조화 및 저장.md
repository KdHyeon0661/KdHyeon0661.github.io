---
layout: post
title: Avalonia - 데이터 모델 구조화 및 저장
date: 2025-01-17 21:20:23 +0900
category: Avalonia
---
# Avalonia MVVM: 데이터 모델 구조화 및 저장

## 프로젝트 구조(확장형)

```
MyAvaloniaApp/
├── Models/
│   ├── UserProfile.cs            # Aggregate Root
│   ├── Address.cs                # Value Object
│   ├── AppData.cs                # 루트 저장 단위(버전 포함)
│   └── Validation/
│       └── Rules.cs              # 커스텀 검증기(선택)
├── Services/
│   ├── Abstractions/
│   │   ├── IDataService.cs
│   │   └── IJsonStorage.cs
│   ├── Storage/
│   │   ├── JsonStorage.cs        # 파일 IO + 안전 저장(원자적)
│   │   └── AppPaths.cs           # OS별 경로
│   ├── DataService.cs            # 버전/마이그레이션/검증·직렬화 옵션
│   ├── Converters/
│   │   └── DateOnlyConverter.cs  # 예시 컨버터
│   └── Migration/
│       └── AppDataMigrator.cs    # 버전별 마이그레이션
├── ViewModels/
│   └── UserViewModel.cs
├── Views/
│   └── UserView.axaml
├── Models.Tests/                 # 단위 테스트 프로젝트(예)
└── Program.cs, App.axaml
```

---

## 모델 설계 — Aggregate/Value Object, 불변/가변 전략

**권장 설계**
- **Aggregate Root**: 저장의 최소 단위. 예: `AppData`, 혹은 사용자별 `UserProfile`.
- **Value Object**: 동등성은 내용으로 판단, 별도 식별자(ID) 없이 **불변**으로 두는 편이 안전. 예: `Address`.
- 뷰 바인딩 편의를 위해 ViewModel이 `UserProfile`을 소유하고, 모델은 **가능하면 불변(record)** 로 유지, 변경 시 **새 인스턴스 생성**(함수형 스타일) 또는 **가변 POCO + 얕은 복사/깊은 복사** 중 선택.

여기서는 **AppData(버전 포함) → UserProfile(가변)** + `Address`(불변 Value Object) 조합을 사용한다.

### Value Object: `Address` (불변)

```csharp
// Models/Address.cs
public readonly record struct Address(string City, string Street)
{
    public static Address Empty => new("", "");
    public bool IsEmpty => string.IsNullOrWhiteSpace(City) && string.IsNullOrWhiteSpace(Street);
}
```

### Aggregate: `UserProfile` (가변 POCO + 단순 유효성)

```csharp
// Models/UserProfile.cs
using System.ComponentModel.DataAnnotations;

public class UserProfile
{
    [Required, MinLength(1, ErrorMessage = "이름은 최소 1자 이상이어야 합니다.")]
    public string Name { get; set; } = "";

    [Range(0, 150, ErrorMessage = "나이는 0~150 사이여야 합니다.")]
    public int Age { get; set; }

    public Address Address { get; set; } = Address.Empty;

    // 도메인 편의 메서드
    public void UpdateAddress(string city, string street) => Address = new Address(city, street);
}
```

### 루트 저장 단위: `AppData` + 버전

```csharp
// Models/AppData.cs
public class AppData
{
    public int Version { get; set; } = 2; // 현재 스키마 버전
    public UserProfile Profile { get; set; } = new();
}
```

> 버전 필드는 **마이그레이션**(파일 포맷 진화)에 필수. 과거 파일을 읽을 때 `Version`을 확인 후 변환한다.

---

## JSON 저장/불러오기 서비스 — 추상화와 안전 저장

### 인터페이스

```csharp
// Services/Abstractions/IDataService.cs
using System.Threading;
using System.Threading.Tasks;

public interface IDataService<T>
{
    Task SaveAsync(T data, CancellationToken ct = default);
    Task<T> LoadOrDefaultAsync(CancellationToken ct = default);
}
```

```csharp
// Services/Abstractions/IJsonStorage.cs
using System.Threading;
using System.Threading.Tasks;

public interface IJsonStorage
{
    Task WriteAsync<T>(string path, T data, JsonSerializerOptions options, CancellationToken ct = default);
    Task<T?> ReadAsync<T>(string path, JsonSerializerOptions options, CancellationToken ct = default);
}
```

### 경로 규칙(OS별 AppData 위치)

```csharp
// Services/Storage/AppPaths.cs
using System;
using System.IO;

public static class AppPaths
{
    public static string GetAppDataDirectory(string appName)
    {
        string baseDir;
        if (OperatingSystem.IsWindows())
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        else if (OperatingSystem.IsMacOS())
            baseDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Personal), "Library", "Application Support");
        else // Linux/Unix
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

        var dir = Path.Combine(baseDir, appName);
        Directory.CreateDirectory(dir);
        return dir;
    }

    public static string Combine(string dir, string file) => Path.Combine(dir, file);
}
```

### 안전 저장(원자적 저장 + 백업/롤백)

```csharp
// Services/Storage/JsonStorage.cs
using System.IO;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

public sealed class JsonStorage : IJsonStorage
{
    public async Task WriteAsync<T>(string path, T data, JsonSerializerOptions options, CancellationToken ct = default)
    {
        var dir = Path.GetDirectoryName(path)!;
        Directory.CreateDirectory(dir);

        var tmp = path + ".tmp";
        var bak = path + ".bak";

        // 1) 임시 파일에 먼저 씀
        await using (var fs = new FileStream(tmp, FileMode.Create, FileAccess.Write, FileShare.None, 4096, useAsync: true))
        {
            await JsonSerializer.SerializeAsync(fs, data, options, ct);
            await fs.FlushAsync(ct);
        }

        // 2) 기존 파일 백업
        if (File.Exists(path))
        {
            File.Copy(path, bak, overwrite: true);
        }

        // 3) 임시 파일을 목표 파일로 원자적 교체(가능한 범위 내)
        File.Copy(tmp, path, overwrite: true);
        File.Delete(tmp);

        // 4) 성공 시 백업은 선택적으로 유지/삭제
        // File.Delete(bak);
    }

    public async Task<T?> ReadAsync<T>(string path, JsonSerializerOptions options, CancellationToken ct = default)
    {
        if (!File.Exists(path)) return default;

        await using var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, useAsync: true);
        return await JsonSerializer.DeserializeAsync<T>(fs, options, ct);
    }
}
```

> 포인트
> - **tmp → bak → live** 순으로 교체하면, 쓰기 도중 전원이 꺼져도 **bak**로 복구 가능.
> - 파일 잠금/충돌에 주의. 단일 프로세스 기준이면 충분하지만, 멀티 인스턴스는 OS 수준 락 전략을 추가 고려.

---

## 직렬화 옵션 + 컨버터 + 널 처리

### 컨버터 예시: `DateOnly`

```csharp
// Services/Converters/DateOnlyConverter.cs
using System;
using System.Text.Json;
using System.Text.Json.Serialization;

public sealed class DateOnlyConverter : JsonConverter<DateOnly>
{
    private const string Format = "yyyy-MM-dd";
    public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        => DateOnly.ParseExact(reader.GetString()!, Format);

    public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
        => writer.WriteStringValue(value.ToString(Format));
}
```

### DataService — 옵션, 마이그레이터, 검증 포함

```csharp
// Services/DataService.cs
using System.ComponentModel.DataAnnotations;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;

public sealed class DataService : IDataService<AppData>
{
    private readonly IJsonStorage _storage;
    private readonly string _filePath;
    private readonly JsonSerializerOptions _options;
    private readonly AppDataMigrator _migrator = new();
    private readonly AsyncLock _lock = new(); // Nito.AsyncEx 또는 간단 구현

    public DataService(IJsonStorage storage, string appName, string fileName = "appdata.json")
    {
        _storage = storage;
        var dir = AppPaths.GetAppDataDirectory(appName);
        _filePath = AppPaths.Combine(dir, fileName);

        _options = new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNameCaseInsensitive = true,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
            ReadCommentHandling = JsonCommentHandling.Skip,
            AllowTrailingCommas = true
        };
        _options.Converters.Add(new DateOnlyConverter());
        // 필요 시 TimeSpan, Guid, Polymorphic 등 추가 컨버터 등록
    }

    public async Task SaveAsync(AppData data, CancellationToken ct = default)
    {
        Validate(data);
        using (await _lock.LockAsync(ct))
        {
            await _storage.WriteAsync(_filePath, data, _options, ct);
        }
    }

    public async Task<AppData> LoadOrDefaultAsync(CancellationToken ct = default)
    {
        using (await _lock.LockAsync(ct))
        {
            var loaded = await _storage.ReadAsync<AppData>(_filePath, _options, ct);
            if (loaded is null)
                return new AppData(); // 최초 실행

            // 버전 확인 → 마이그레이션
            var migrated = _migrator.MigrateToCurrent(loaded);
            return migrated;
        }
    }

    private static void Validate(AppData data)
    {
        var ctx = new ValidationContext(data);
        Validator.ValidateObject(data, ctx, validateAllProperties: true);

        // 중첩 객체 수동 검증
        var ctxProfile = new ValidationContext(data.Profile);
        Validator.ValidateObject(data.Profile, ctxProfile, validateAllProperties: true);
    }
}
```

> `AsyncLock`은 단순 `SemaphoreSlim` 래핑으로 대체 가능.

---

## 마이그레이션 — 스키마 진화 대응

```csharp
// Services/Migration/AppDataMigrator.cs
public sealed class AppDataMigrator
{
    private const int Current = 2;

    public AppData MigrateToCurrent(AppData data)
    {
        var version = data.Version;

        if (version < 1)
        {
            // 예시: 0 → 1 변환 로직
            // (필드 추가/이름 변경/단위 변경 등)
            version = 1;
        }
        if (version < 2)
        {
            // 예: v2에서 Address를 Value Object로 통일, 공백이면 Empty 대체
            data.Profile.Address = data.Profile.Address.IsEmpty
                ? Address.Empty
                : data.Profile.Address;
            version = 2;
        }

        data.Version = Current;
        return data;
    }
}
```

> 실전에서는 마이그레이션 단계를 **테스트**로 보장하고, **백업 파일**(.bak)에서 **롤백 경로**를 유지한다.

---

## ViewModel — 저장/불러오기 + 자동 저장(디바운스) + 검증

### 기본 ViewModel

```csharp
// ViewModels/UserViewModel.cs
using ReactiveUI;
using System.Reactive;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;

public sealed class UserViewModel : ReactiveObject, IActivatableViewModel
{
    private readonly IDataService<AppData> _dataService;
    private AppData _appData = new();
    private string _status = "";
    private readonly CancellationTokenSource _cts = new();

    public ViewModelActivator Activator { get; } = new();

    public UserProfile Profile
    {
        get => _appData.Profile;
        private set
        {
            _appData.Profile = value;
            this.RaisePropertyChanged();
        }
    }

    public string Status
    {
        get => _status;
        private set => this.RaiseAndSetIfChanged(ref _status, value);
    }

    public ReactiveCommand<Unit, Unit> LoadCommand { get; }
    public ReactiveCommand<Unit, Unit> SaveCommand { get; }

    public UserViewModel()
        : this(new DataService(new JsonStorage(), "MyAvaloniaApp"))
    {
    }

    public UserViewModel(IDataService<AppData> dataService)
    {
        _dataService = dataService;

        LoadCommand = ReactiveCommand.CreateFromTask(LoadAsync);
        SaveCommand = ReactiveCommand.CreateFromTask(SaveAsync);

        // 활성화 시 자동 로드
        this.WhenActivated(disposables =>
        {
            LoadCommand.Execute().Subscribe();
        });

        // 변경 감지 → 디바운스 자동 저장(0.8초)
        this.WhenAnyValue(vm => vm.Profile.Name, vm => vm.Profile.Age, vm => vm.Profile.Address)
            .Throttle(TimeSpan.FromMilliseconds(800), RxApp.TaskpoolScheduler)
            .ObserveOn(RxApp.MainThreadScheduler)
            .Select(_ => Unit.Default)
            .InvokeCommand(SaveCommand);
    }

    private async Task LoadAsync()
    {
        Status = "불러오는 중...";
        _appData = await _dataService.LoadOrDefaultAsync(_cts.Token);
        this.RaisePropertyChanged(nameof(Profile));
        Status = "불러오기 완료";
    }

    private async Task SaveAsync()
    {
        try
        {
            await _dataService.SaveAsync(_appData, _cts.Token);
            Status = "저장 완료";
        }
        catch (ValidationException vex)
        {
            Status = $"검증 오류: {vex.Message}";
        }
        catch (Exception ex)
        {
            Status = $"저장 실패: {ex.Message}";
        }
    }

    // UI 편의 메서드
    public void UpdateAddress(string city, string street)
    {
        Profile.UpdateAddress(city, street);
        this.RaisePropertyChanged(nameof(Profile));
    }
}
```

> 포인트
> - `WhenActivated`로 수명 관리(뷰 닫히면 구독 해제)
> - **디바운스 자동 저장**으로 UX 향상
> - `ValidationException` 분기 처리

---

## 뷰 — 중첩 바인딩 + 검증 메시지 표출

```xml
<!-- Views/UserView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:MyAvaloniaApp.ViewModels"
             x:Class="MyAvaloniaApp.Views.UserView"
             Width="420" Height="320">
  <UserControl.DataContext>
    <vm:UserViewModel/>
  </UserControl.DataContext>

  <StackPanel Margin="16" Spacing="8">
    <TextBlock Text="사용자 프로필" FontSize="18"/>

    <TextBox Text="{Binding Profile.Name}" Watermark="이름" />
    <TextBox Text="{Binding Profile.Age}" Watermark="나이" />
    <TextBox Text="{Binding Profile.Address.City}" Watermark="도시" />
    <TextBox Text="{Binding Profile.Address.Street}" Watermark="거리" />

    <StackPanel Orientation="Horizontal" Spacing="8">
      <Button Content="불러오기" Command="{Binding LoadCommand}"/>
      <Button Content="저장하기" Command="{Binding SaveCommand}"/>
    </StackPanel>

    <Border BorderThickness="1" Padding="8" CornerRadius="4"
            BorderBrush="Gray">
      <TextBlock Text="{Binding Status}" TextWrapping="Wrap"/>
    </Border>
  </StackPanel>
</UserControl>
```

> Avalonia의 기본 검증 템플릿을 활용하려면 `INotifyDataErrorInfo`를 VM에서 구현하거나, DataAnnotations 기반으로 **바인딩 파이프라인에서 검증**을 호출해 결과를 `Status` 등에 반영하는 방식을 사용한다. (고급: Behaviors/Attached Property로 Validation Template 구현)

---

## 외부 변경 감지(파일 Watcher)와 즉시 반영(선택)

프로세스 외부(다른 인스턴스/에디터)에서 파일이 변경되면 **자동 재로딩**하도록 `FileSystemWatcher`를 사용할 수 있다.

```csharp
// 간단 예시: DataService 생성자에서 Watcher 구성(생략 가능)
```

실전에서는 **사용자에게 충돌 알림** 및 **재로딩/유지 선택** UI를 제공하자.

---

## 저장 포맷·성능·안정성 팁

- **큰 컬렉션**: 페이지네이션/스트리밍 저장(분할 파일) 고려
- **원자적 저장**: tmp → bak → live 순서 유지
- **압축**: 데이터가 큰 경우 `GZipStream` 레이어 추가(읽기/쓰기 모두)
- **암호화(선택)**: 민감한 데이터일 경우 `AesGcm` 또는 OS 저장소(Windows DPAPI, macOS Keychain 등) 활용
- **일관성**: 저장 직전 모델 검증 + 저장 후 **해시** 기록(데이터 손상 탐지)

---

## DI 구성(간단)

```csharp
// Program.cs (예: Minimal DI)
using Microsoft.Extensions.DependencyInjection;

var services = new ServiceCollection();

services.AddSingleton<IJsonStorage, JsonStorage>();
services.AddSingleton<IDataService<AppData>>(sp =>
    new DataService(sp.GetRequiredService<IJsonStorage>(), "MyAvaloniaApp"));

var provider = services.BuildServiceProvider();
// 이후 App 생성자에서 provider 전달, ViewModel 팩토리로 사용할 수 있다.
```

---

## 단위 테스트 — 직렬화/마이그레이션/검증

```csharp
// Models.Tests/AppDataTests.cs
using Xunit;

public class AppDataTests
{
    [Fact]
    public void Validate_Profile_MinNameLength()
    {
        var data = new AppData { Profile = new UserProfile { Name = "", Age = 20 } };
        Assert.Throws<ValidationException>(() =>
        {
            var ctx = new ValidationContext(data.Profile);
            Validator.ValidateObject(data.Profile, ctx, true);
        });
    }

    [Fact]
    public void Migration_To_Current_Version()
    {
        var old = new AppData { Version = 1, Profile = new UserProfile { Name = "A", Age = 10 } };
        var mig = new AppDataMigrator().MigrateToCurrent(old);
        Assert.Equal(2, mig.Version);
    }
}
```

---

## 확장 아이디어

- **여러 사용자 프로필 목록**(컬렉션) + **검색/정렬** + **필터 저장**
- **Undo/Redo** 히스토리(명령 스택)와 저장 시점 스냅샷
- **Import/Export** (CSV/JSON) + Schema Version 포함
- **클라우드 동기화**(예: WebDAV/REST API) — `IDataService` 구현 교체

---

## 요약 표

| 요소 | 권장 사항 |
|------|-----------|
| 모델 | Aggregate/Value Object 구분, 불변 VO, 가변/불변 전략 명시 |
| 검증 | DataAnnotations + 필요 시 INotifyDataErrorInfo, 저장 전 검증 |
| 저장 | JsonSerializerOptions 표준화, 컨버터 등록, tmp/bak 원자적 저장 |
| 경로 | OS별 AppData 폴더 사용, 앱 전용 디렉터리 생성 |
| 동시성 | `AsyncLock`/`SemaphoreSlim`, CancellationToken, 단일 프로세스 기준 |
| 마이그레이션 | Version 필드 필수, 단계별 변환 + 테스트 |
| 자동 저장 | `WhenAnyValue` + `Throttle` + `SaveCommand` |
| DI/테스트 | 인터페이스로 경계 정의, 단위 테스트로 검증 시나리오 커버 |

---

## 최종 샘플(핵심 모듈 요약)

### 모델/저장/VM/뷰 간 최소 연결

```csharp
// 조립(요지)
var storage = new JsonStorage();
var dataSvc = new DataService(storage, "MyAvaloniaApp");
var vm = new UserViewModel(dataSvc);
// View.DataContext = vm;
```

> 이 구조를 기반으로 **AppData**에 다른 Aggregate(예: Settings, Projects, Library 등)를 추가하고, 각 화면 VM이 **같은 IDataService<AppData>** 를 공유하면서 필요한 부분만 바인딩/수정 → 저장하도록 확장하면, 대형 앱도 **일관된 저장 모델**로 관리할 수 있다.

---

## 부록 A) 간단한 AsyncLock(대체 구현)

```csharp
public sealed class AsyncLock
{
    private readonly SemaphoreSlim _sem = new(1, 1);
    public async Task<IDisposable> LockAsync(CancellationToken ct = default)
    {
        await _sem.WaitAsync(ct);
        return new Releaser(_sem);
    }
    private sealed class Releaser : IDisposable
    {
        private readonly SemaphoreSlim _s;
        public Releaser(SemaphoreSlim s) => _s = s;
        public void Dispose() => _s.Release();
    }
}
```

---

## 부록 B) 저장 경로 예시

| OS | 예시 경로 |
|----|-----------|
| Windows | `%AppData%\MyAvaloniaApp\appdata.json` |
| macOS | `~/Library/Application Support/MyAvaloniaApp/appdata.json` |
| Linux | `~/.config/MyAvaloniaApp/appdata.json` |

---

# 마무리

- **모델을 UI와 분리**하고, **버전/마이그레이션/검증/안전 저장**을 체계화하면 앱이 커져도 안정적으로 진화할 수 있다.
- 본문 예제를 **템플릿**처럼 가져가, 도메인 엔티티만 교체해도 즉시 동작하는 저장 파이프라인을 구성하라.
- 이후에는 **암호화/동기화/분할 저장/인덱싱** 등을 단계적으로 추가하면 된다.
