---
layout: post
title: 암호학 - 데이터 보호 & 규정 준수
date: 2025-10-17 15:30:23 +0900
category: 암호학
---
# 17. 데이터 보호 & 규정 준수

> 이 장은 **데이터 보호의 전 영역**을 “설계→구현→운영→감사”의 수명주기로 정리합니다.  
> **저장/전송 암호화(E@R/E@T)** → **필드/레코드 단위 암호화 & 토크나이제이션** → **키 관리와 규정(GDPR/PCI DSS)** → **로깅·감사·접근 통제 설계** 순서이며, 각 섹션은 **실무 체크리스트/코드 스니펫/구성 예시/플레이북**을 포함합니다.  
> 원칙: **최소 수집, 최소 보유, 최소 권한**, 그리고 **암호화는 실패 전제(assume breach) 하에**.

---

## ✅ 17.1 데이터 보호 큰 그림

### 17.1.1 보호 목표(“CIA + AA + P”)
- **기밀성(Confidentiality)**: 접근 통제 + 암호화  
- **무결성(Integrity)**: 검증 가능한 변경 추적(AEAD/서명/감사로그)  
- **가용성(Availability)**: 백업·DR·키 가용성  
- **인증(Authentication) & 권한(Authorization)**: 11장 참고  
- **프라이버시(Privacy)**: 목적 제한, 최소화, 데이터 주체 권리

### 17.1.2 데이터 수명주기
```
[수집/생성] → [전송] → [저장/처리] → [공유] → [보존/파기]
```
각 단계에 **위협/통제**(암호화·토큰·접근·감사·보존정책)를 명시하고 **증거(문서+로그)**를 남긴다.

---

## ✅ 17.2 저장 데이터 암호화(E@R: Encryption at Rest)

### 17.2.1 층별 접근
- **미디어/디스크**: OS/클라우드 디스크 암호화(LUKS/BitLocker/EBS/EFS/PD 등)  
- **DB 레벨(TDE)**: RDBMS TDE(MS SQL/Oracle/MySQL/Aurora 등) – **투명**, 키는 KMS/HSM  
- **애플리케이션 레벨**: **필드/레코드 단위**(pgcrypto/Mongo FLE/앱 AES-GCM/ChaCha20-Poly1305)  
- **파일/객체**: S3 SSE-KMS/Client-side envelope, GCS/Azure 대응

> **계층 혼합**: 디스크/TDE는 기본값, **민감 필드**는 **앱 레벨 AEAD**로 2차 보호.

### 17.2.2 봉투 암호화(Envelope) 핵심
- **데이터 키(DEK)**로 데이터(AEAD) → **EDK**(DEK을 KMS로 래핑)와 함께 저장  
- **장점**: 회전/권한분리/감사 용이, 대용량 효율  
- **주의**: 평문 DEK는 **메모리에서만**, 캐시 TTL·소거(12장 참고)

### 17.2.3 레코드 암호화 설계(앱 레벨)
- **키 스코프**: `tenant`/`dataset`/`purpose` 별 CMK → **키 격리**  
- **메타데이터**: `v=키버전|alg|aad|nonce|edk` 를 레코드에 포함  
- **검색성**: 동형암호/인덱스 토큰/해시 보조(아래 §17.4) 고려

**PostgreSQL 예(pgcrypto)**
```sql
-- 고객 테이블 일부 필드 AEAD (간단 예)
SELECT pgp_sym_encrypt_iv(
  '4111-1111-1111-1111', 'app-derv-key', '0123456789abcdef'
);

-- 실제 운영은 앱에서 KMS로 DEK를 얻고 AES-GCM/ChaCha20-Poly1305 사용을 권장
```

**MongoDB Client-Side FLE 개념**
```js
// 키-벨트(kms) → data key 생성 → 필드별 스키마 암호화
{
  "bsonType": "object",
  "properties": {
    "ssn": { "encrypt": { "bsonType": "string", "algorithm": "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic" }},
    "card":{ "encrypt": { "bsonType": "string", "algorithm": "AEAD_AES_256_CBC_HMAC_SHA_512-Random" }}
  }
}
```
- **Deterministic**: 동등 비교 검색 가능(패턴 누설 주의)  
- **Randomized**: 안전성↑, 검색 불가

### 17.2.4 백업/스냅샷/로그 암호화
- **백업**: **백업 암호화 키는 운영 키와 분리**, 임계 복호(t-of-n)  
- **스냅샷**: DB 스냅샷도 E@R 적용, **전송 시 E@T**  
- **로그**: 민감 데이터는 **기본 비출력** + 필요시 **보안 저장소 암호화**

---

## ✅ 17.3 전송 데이터 암호화(E@T: Encryption in Transit)

### 17.3.1 TLS 기본
- **TLS 1.3** + **AEAD 스위트**(AES-GCM/ChaCha20-Poly1305)  
- **서버 인증서**: 공신 CA/내부 CA, 자동화(ACME), **만료/회전 모니터**  
- **HSTS**, OCSP 스테이플링

**Nginx 스니펫**
```nginx
ssl_protocols TLSv1.3;
ssl_ciphers TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256;
ssl_prefer_server_ciphers on;
ssl_early_data off;  # 0-RTT 기본 비활성
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
```

### 17.3.2 mTLS/서비스 메시
- **남-남 트래픽**: 서비스 메시(Istio/Linkerd) 또는 **mTLS**로 **상호 인증**  
- **키/증명서**: SPIFFE/SPIRE, 단기 수명(≤24h)  
- **내부 DNS/라벨 기반 정책**(L7/Intent 기반)과 병행

### 17.3.3 이메일/파일 전송
- SMTP MTA-STS/STARTTLS, S/MIME/PGP(10장 참고)  
- 파일 전송: 일회성 링크 + 만료/다운로드 제한 + **전송 중 TLS** + **서버 측 암호화**

---

## ✅ 17.4 필드·레코드 단위 암호화 & 토크나이제이션

### 17.4.1 토크나이제이션 vs 암호화
- **토큰화(Tokenization)**: 원본 데이터 ↔ 토큰 **1:1 매핑**, 보통 **볼트(vault)** 저장  
- **암호화**: 키로 복호 가능, **암호문 그 자체**로 존재  
- **선택 기준**
  - **PCI PAN/민감 PII** → 토큰화로 **시스템 경계 축소**(PCI 범위 축소 효과 큼)  
  - **연산 필요**(정렬/범위/수치) → 앱 암호화나 보조 인덱스 병행

### 17.4.2 토큰화 아키텍처
```
[App] --(PAN)--> [Token Vault(API+KMS)] --> (Token)
                     |--> DB: {token, format, hash, vaultKeyVer, aad, metadata}
                 (역조회/폐기/감사)
```
- **포맷 보존 토큰(FPE-like)**: BIN/길이 유지 → 레거시 시스템 호환  
- **감사**: 발급/역조회/폐기 모든 호출 **감사 로그** + 위험 탐지

**해시/탐색 보조**
- **동등 검색**: SHA-256(고유 Salt/pepper)로 **보조 컬럼** 생성(역상 방지 주의)  
- **부분 검색**: 불가(또는 위험). 필요 시 **인덱스 토큰**(N-gram 해시) 사용 – 재식별 위험 분석 필수.

### 17.4.3 FPE(Format-Preserving Encryption) 주의
- FF1/FF3-1(NIST) 사용 가능.  
- **키/도메인/튜닝** 잘못되면 **통계 누설** 가능 → **가능하면 토큰화** 우선, FPE는 제한 부위에만.

### 17.4.4 레코드 단위 AEAD 설계 팁
- **AAD**: `tenant|table|field|version` 등을 AAD에 포함 → **맥락 고정/혼동 방지**  
- **Nonce**: 키별 고유, prefix+카운터 권장(13장)  
- **에러 처리**: 태그 실패/포맷 실패 **동일 에러**(오라클 방지)

**파이썬 개념 코드 (AES-GCM)**
```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os, base64

def encrypt_field(key: bytes, plaintext: bytes, aad: bytes):
    nonce = os.urandom(12)
    ct = AESGCM(key).encrypt(nonce, plaintext, aad)
    return {
      "v":1, "alg":"AES-GCM", "nonce":base64.b64encode(nonce).decode(),
      "aad":aad.decode(), "ct":base64.b64encode(ct).decode()
    }
```

---

## ✅ 17.5 키 관리 & 규정(요약: 12장 심화 + 규정 매핑)

### 17.5.1 공통 원칙
- **KMS/HSM 중심**: CMK/KEK는 HSM 경계, 데이터는 **봉투 암호화**  
- **키 수명주기**: 생성→배포→사용→회전→폐기(대기기간)  
- **권한 최소화**: Encrypt/Decrypt/Sign 분리, 조건부 정책(태그/시간/리전/IP)  
- **감사**: 모든 KMS 호출 로그, **상관 ID**로 트랜잭션 결합  
- **DR**: 리전 복제/임계 복호, 재현 테스트

### 17.5.2 GDPR 매핑(핵심 조항 관점)
- **자료 최소화(Art.5(1)(c))**: 수집 항목·보존 기간을 명세, **암호화/토큰화로 범위 축소**  
- **가명처리(Art.4(5))**: 토큰화/해시로 **가명 데이터** 만들고 **역연결 정보 분리**  
- **무결성·기밀성(Art.5(1)(f), 32)**: E@R/E@T, 키 관리, 접근 통제, 테스트/평가  
- **권리 행사(Art.15~22)**: 삭제/정정/열람을 **토큰/키/인덱스**로 구현 가능하게 **데이터 맵** 유지  
- **DPIA(Art.35)**: 고위험 처리(대규모 민감정보) 시 **영향평가** + 완화대책(암호화/토큰화/DP) 문서화  
- **국외 이전(Ch.V)**: 전송 경로 E@T, 저장지 E@R, **계약/보충적 조치**(키 유럽 유지 등)

> **주의**: 법률 해석은 조직의 법무/컴플라이언스와 확정. 본 장은 **기술적 통제 매핑** 가이드.

### 17.5.3 PCI DSS 매핑(대표 요구)
- **카드 데이터 범위 축소**: PAN을 **토큰화**하여 **CDE(범위)**에서 비핵심 시스템을 제외  
- **보관 데이터 보호**: **강한 암호화**(AES-256), **키 관리(키 분리/이중 통제)**  
- **전송 보호**: **TLS 1.2+ / 1.3**, 내부 세그먼트도 보호  
- **접근 통제**: 역할 기반, **JIT 접근(시간 제한)**, 기본 비밀번호 금지  
- **로깅/모니터링**: 모든 접근/설정 변경/암호화 키 접근 **중앙 수집 + 보존**  
- **취약점/펜테스트**: 정기 스캔/패치, 세그먼트 별도 테스트

**PCI 토큰화 템플릿**
- Vault 는 **CDE 내부**  
- App ↔ Vault: **mTLS**, Vault ↔ KMS: **제한 IAM**  
- 토큰은 **비감사 데이터베이스**로 이동 가능(형식 보존)  
- **PAN 비출력**: UI/로그/리포트는 **마스킹(마지막 4자리)**

---

## ✅ 17.6 로깅·감사·키 접근 통제 설계

### 17.6.1 로그 정책
- **민감 데이터 로그 금지**: PAN/SSN/비번/토큰 역조회 결과  
- **마스킹**: 마지막 4자리만, 이메일은 `u***@d***.com`  
- **정형 이벤트 스키마**: `who/what/when/where/correlation_id/tenant/key_version/audit_result`  
- **보존 정책**: 법적 보존 기간, 파기 절차(불변 스토리지+수명 정책)

### 17.6.2 감사로그 불변성
- **WORM/Append-only** 스토리지(Object Lock), **서명된 로그**(MAC/체인)  
- **SIEM**: 중앙 수집, **경보 룰**(비정상 Decrypt/Sign, 야간 활동, 지역 급변)  
- **샘플링/PII 최소화**: 개인정보 최소화, Pseudonymous ID 사용

### 17.6.3 키 접근·운영 통제
- **분리(SoD)**: 키 관리자 ≠ 시스템 운영자 ≠ 감사자  
- **2인 통제/승인**: 키 내보내기/폐기/정책 변경  
- **Break-glass**: 비상 접근은 **사전 승인 규정 + 전체 녹화/감사**  
- **JIT 접근**: 임시 크리덴셜(단기 TTL), 역할 자동 회수

**KMS 정책 예시(개념)**
- `role:encrypt-only`: `kms:Encrypt`만  
- `role:decrypt-audited`: `kms:Decrypt` + **조건**(`aws:PrincipalTag=service=billing`, 시간 09:00–18:00)  
- **CloudTrail**로 모든 호출 수집 + “Decrypt 실패/성공 비율” 경보

---

## ✅ 17.7 데이터 분류·발견·보존·파기

### 17.7.1 분류 체계
- `Public / Internal / Confidential / Restricted(PHI/PCI)`  
- **태깅**: 테이블/필드/스트림에 `classification`, `retention`, `purpose` 메타데이터

### 17.7.2 데이터 발견 & 맵
- **스캐너**(정규식/ML)로 PII/PCI 위치 파악  
- **데이터 맵**: 시스템/흐름/보관지/키 스코프/토큰 밸트 경로를 다이어그램으로 문서화  
- **권리 행사 경로**: 삭제/정정/열람 요청이 **어떤 키/토큰/인덱스**로 처리되는지 절차화

### 17.7.3 보존·파기
- **보존 정책**: 목적 달성/법정기간 종료 시 **자동 파기**(데이터+키 동시)  
- **키 파기**: `disable → schedule destroy(대기) → destroy`, 백업/테이프 파기 증적  
- **논리적 삭제 + 암호화 삭제**: 키 폐기로 **암호화 삭제** 효과

---

## ✅ 17.8 데이터 가명화·익명화·차등프라이버시(DP)

### 17.8.1 용어
- **가명화(Pseudonymization)**: 토큰/해시로 식별자 대체(역연결 수단 존재)  
- **익명화(Anonymization)**: 역연결 정보 제거(재식별 위험 분석 필요)  
- **차등프라이버시**: 통계 결과에 **노이즈** 주입해 개별 기여 은닉(\(\epsilon\), \(\delta\) 관리)

### 17.8.2 실전 팁
- **링크가능성/유일성** 분석(k-익명, l-다양성, t-근접)  
- **출력 최소화**: 집계 최소 그룹 크기, 노이즈 추가, 쿼리 레이트 제한  
- **데이터 조인**: PSI(16장)로 교집합만 노출

---

## ✅ 17.9 운영 체크리스트(핵심 요약)

- **암호화**
  - [ ] 디스크/TDE 기본 + **민감 필드 AEAD**  
  - [ ] 봉투 암호화(EDK 헤더), 키 버전/회전 문서화  
  - [ ] E@T: TLS1.3, HSTS, mTLS(내부)

- **토큰/식별자**
  - [ ] 토큰 볼트 CDE 내부, 포맷 보존 필요 시 제한 적용  
  - [ ] 검색용 보조 해시/인덱스 설계(역상 위험 평가)  
  - [ ] 마스킹 정책(UI/로그/리포트)

- **키 관리**
  - [ ] KMS/HSM, SoD, 2인 통제, JIT 접근  
  - [ ] 모든 Encrypt/Decrypt/Sign 로그, 경보 룰  
  - [ ] 회전/폐기/DR 절차 테스트

- **규정 매핑**
  - [ ] GDPR: 최소화/가명화/DPIA/권리 절차  
  - [ ] PCI: 토큰화로 범위 축소, 강한 암호화/접근/로깅  
  - [ ] 문서/증거: 정책, 다이어그램, 절차, 보고서

- **로그/감사**
  - [ ] PII 로그 금지/마스킹, 불변 스토리지, SIEM 룰  
  - [ ] 키 접근/정책 변경/역조회 전부 감사

- **보존/파기**
  - [ ] 보존 정책 자동화, 키/데이터 동시 삭제  
  - [ ] 백업/스냅샷 암호화+파기 증적

---

## ✅ 17.10 레퍼런스 아키텍처(개념 다이어그램)

```
[Client/App]
   | TLS 1.3
   v
[API Gateway/mTLS] ---[WAF/Rate]---+
   |                                |
   |                                v
   |                           [Token Vault + KMS/HSM]
   |                                |
   v                                |
[App Service]----(EDK header)----->[DB/Storage (TDE/EBS E@R)]
   |                                 ^
   |--SIEM(audit/metrics)------------+
   |
   +--> [Secrets Store] (JIT, rotation)
   +--> [DLP/Scanner] (data discovery)
```

---

## ✅ 17.11 미니 플레이북

### 17.11.1 “신규 테이블에 PAN 저장 필요” 대응
1) **가능하면 토큰화**로 대체, 원본 PAN은 Vault 내부에만  
2) 레거시 호환 필요 시 **FPE 토큰** 제공(실제 PAN 아님)  
3) UI/로그/리포트는 **마스킹**, 검색은 **보조 해시**  
4) Vault ↔ KMS는 **mTLS + 최소 권한**, 모든 역조회 **2인 승인**  
5) PCI 범위 문서화 & 세그먼트 격리

### 17.11.2 “민감 필드 앱 레벨 암호화 도입”
1) 키 스코프/버전 설계 → KMS CMK 생성  
2) 앱에 **AEAD 래퍼** 추가(AAD=테이블·필드·버전)  
3) 점진 마이그레이션: 읽기 시 미암호 → 암호화 저장  
4) 백업/ETL 파이프라인 수정(평문 노출 금지)  
5) 대시보드/알람: Decrypt 실패율/비정상 패턴

### 17.11.3 “데이터 주체의 삭제 요청”
1) **식별자→토큰/해시 인덱스**로 레코드 조회  
2) 비식별화된 레이크/로그에서 **연결자 제거**  
3) 백업은 **스케줄**에 따라 암호화 삭제(키 회전/폐기)  
4) 처리 기록/증빙 유지(비식별)

---

## ✅ 17.12 자주 하는 실수(안티-패턴)

1) **암호화만 믿고 과수집/과보존**  
2) **Deterministic 암호화로 광범위 검색/분석**(패턴 누설)  
3) **토큰 역조회 남발**(감사/승인 없이)  
4) **키 관리자와 DBA 겸임**(SoD 위반)  
5) **로그에 PII 유출**(디버그/에러)  
6) **테스트 데이터**에 실데이터 사용(마스킹·합성 데이터 권장)  
7) **권리 행사 경로 미설계**(삭제/정정에 실패)

---

## ✅ 17.13 예제 스니펫 모음

### 17.13.1 Node.js — 봉투 암호화 래퍼(개념)
```js
import crypto from 'crypto';
function encRecord(kekWrapFn, plaintext, aadStr){
  const dek = crypto.randomBytes(32);
  const nonce = crypto.randomBytes(12);
  const aead = crypto.createCipheriv('chacha20-poly1305', dek, nonce, {authTagLength:16});
  aead.setAAD(Buffer.from(aadStr));
  const ct = Buffer.concat([aead.update(plaintext), aead.final()]);
  const tag = aead.getAuthTag();
  const edk = kekWrapFn(dek); // KMS로 래핑
  dek.fill(0);
  return {v:1, alg:'CHACHA20-POLY1305', nonce:nonce.toString('base64'),
          aad:aadStr, edk:edk.toString('base64'),
          ct:Buffer.concat([ct,tag]).toString('base64')};
}
```

### 17.13.2 SQL — 마스킹 뷰
```sql
CREATE VIEW customer_masked AS
SELECT id,
       CONCAT('****-****-****-', RIGHT(card_last4,4)) AS pan_masked,
       REGEXP_REPLACE(email, '(^.).*(@.).*(\..+$)', '\\1***\\2***\\3') AS email_masked
FROM customer_secure;
```

### 17.13.3 SIEM 탐지 규칙(개념)
```
IF kms:Decrypt.count(principal=X) > baseline*3 within 10m
AND geoip change == true
THEN alert "Abnormal KMS usage"
```

---

## ✅ 17.14 감사 준비 서류(샘플 목록)

- **정책**: 암호화, 토큰화, 키 관리, 접근 통제, 로그/보존, 권리 행사  
- **아키텍처**: 데이터 흐름/시스템 경계/세그먼트/키 경로  
- **절차**: 키 회전/폐기, 비상 접근, 침해 대응, DPIA/위험평가  
- **증적**: KMS 로그, Vault 감사, 세션 기록, 취약점 스캔·펜테스트 리포트  
- **교육**: 보안·개인정보 교육 이수 기록

---

## ✅ 17.15 요약 카드

- **저장/전송 암호화**는 기본, **민감 필드**는 **앱 레벨 AEAD**로 이중 보호.  
- **토크나이제이션**으로 **규정 범위 축소/리스크 분리**; 역조회는 엄격하게.  
- **키 관리**는 **KMS/HSM + SoD + 감사 + 회전/폐기**.  
- **GDPR/PCI** 요구를 **기술 통제**로 매핑, **증거 가능한 운영**이 핵심.  
- **로깅/감사/접근 통제**는 설계의 일부이며, **민감 데이터는 로그 금지 + 불변 저장**.  
- **보존/파기/권리 행사**를 위한 **데이터 맵**과 자동화가 승부처.

---

## ✅ 17.16 연습문제

1) 토큰화 아키텍처에서 **CDE 범위 축소**가 이루어지는 경계를 그림으로 그리고, 역조회 경로의 **2인 통제/감사** 설계를 제시하라.  
2) AEAD 기반 레코드 암호화에서 **AAD**에 포함할 항목을 정의하고, **재암호화(회전)** 절차를 의사코드로 작성하라.  
3) Deterministic 암호화/보조 해시를 이용한 **동등 검색**의 **프라이버시 위험**을 사례와 함께 분석하고 완화 전략을 써라.  
4) GDPR의 **데이터 최소화·보존 제한** 원칙을 **키·보존정책·암호화 삭제**로 구현하는 설계안을 제시하라.  
5) SIEM에서 **비정상 KMS 사용 탐지**를 위한 지표/임계/알람 룰을 구체화하라.  
6) 테스트 환경에서 **실데이터 금지** 원칙을 지키기 위한 **합성 데이터·마스킹** 파이프라인을 설계하라.
