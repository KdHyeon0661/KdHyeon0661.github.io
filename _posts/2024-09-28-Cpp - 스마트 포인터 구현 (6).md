---
layout: post
title: C++ - 스마트 포인터 적용 예제
date: 2024-09-28 19:20:23 +0900
category: Cpp
---
# C++ 스마트 포인터 구현 6/6 — **테스트 스위트 & 품질 게이트**

> 목표: 1~5편에서 만든 `MyUniquePtr / MySharedPtr / MyWeakPtr / MyEnableSharedFromThis` + 배열/커스텀 deleter/aliasing/pointer_cast 를 **지속적으로 신뢰**할 수 있게
> - 단위/통합/부하/스레드/퍼즈 테스트 **풀세트** 제공
> - ASan/TSan/UBSan/LSan **Sanitizer 연동**
> - CMake/CI(매트릭스)/커버리지/린트 **품질 게이트** 구축
> - **출고 기준(Exit Criteria)** 수립

---

## 0. 프로젝트 배치 & 전제

```
/smartptr/
 ├─ include/
 │   ├─ my_smart_ptr.hpp                // 1~3편 핵심: Unique/Shared/Weak, enable_shared_from_this
 │   ├─ my_shared_array.hpp             // 4편: T[] 전용, 커스텀 deleter, pointer_cast
 │   ├─ my_sp_debug.hpp                 // 5편: 디버그/누수 리포트 훅(선택)
 │   └─ mysp_all.hpp                    // 통합 include (아래 제공)
 ├─ tests/
 │   ├─ test_basic_catch.cpp            // Catch2: 기본/배열/deleter/aliasing
 │   ├─ test_enable_and_weak.cpp        // enable_shared_from_this/weak 사용
 │   ├─ test_thread_stress.cpp          // 스레드 스트레스/락-언락 경합
 │   ├─ test_fuzz_linear.cpp            // 선형 퍼즈(랜덤 시퀀스)
 │   └─ test_gtest_equiv.cpp            // GoogleTest 대등 스모크
 ├─ cmake/
 │   └─ Sanitizers.cmake                // ASan/TSan/UBSan 옵션 헬퍼
 ├─ CMakeLists.txt
 └─ .github/workflows/ci.yml            // GitHub Actions (선택)
```

> **가정**: `my_*` 헤더는 앞선 편들에서 구현한 것을 그대로 둔다.
> 다른 파일명이라면 include 경로만 맞추면 된다.

---

## 1. 통합 헤더 (`include/mysp_all.hpp`)

```cpp
// include/mysp_all.hpp
#pragma once

#include "my_smart_ptr.hpp"      // MyUniquePtr, MySharedPtr, MyWeakPtr, MyEnableSharedFromThis, my_make_shared
#include "my_shared_array.hpp"   // MySharedPtr<T[]>, my_make_shared_array, pointer_cast
#ifdef MYSP_ENABLE_DEBUG
#  include "my_sp_debug.hpp"     // 5편: on_create/on_destroy/report (선택)
#endif
```

---

## 2. Catch2 단위 테스트 — 기본 기능 (파일: `tests/test_basic_catch.cpp`)

> **핵심 불변식**
> $$S=\text{shared\_count},\; W=\text{weak\_count}$$
> 객체 파괴: $$S \to 0$$ / 컨트롤 블록 파괴: $$S=0 \land W=0$$
> `weak.lock()` 성공 조건: $$S>0 \Rightarrow S \gets S+1$$

```cpp
// tests/test_basic_catch.cpp
#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>
#include <atomic>
#include <cstring>
#include "mysp_all.hpp"

struct Probe {
    static std::atomic<int> live;
    int id=0;
    Probe(){ ++live; }
    ~Probe(){ --live; }
};
std::atomic<int> Probe::live{0};

TEST_CASE("MyUniquePtr: move-only semantics") {
    MyUniquePtr<int> p(new int(7));
    REQUIRE(*p == 7);

    auto q = std::move(p);
    REQUIRE(p.get() == nullptr);
    REQUIRE(q.get() != nullptr);
    REQUIRE(*q == 7);

    q.reset(new int(42));
    REQUIRE(*q == 42);
}

TEST_CASE("MySharedPtr: refcount basics") {
    REQUIRE(Probe::live.load() == 0);
    auto a = my_make_shared<Probe>();
    REQUIRE(Probe::live.load() == 1);
    REQUIRE(a.use_count() == 1);

    {
        auto b = a;
        REQUIRE(a.use_count() == 2);
        REQUIRE(b.use_count() == 2);
    }
    REQUIRE(a.use_count() == 1);
    a.reset();
    REQUIRE(Probe::live.load() == 0);
}

TEST_CASE("MySharedPtr<T[]>: array semantics + memset") {
    constexpr std::size_t N=1024;
    auto buf = my_make_shared_array<unsigned char>(N);
    std::memset(buf.get(), 0xAB, N);
    for (std::size_t i=0;i<16;++i) REQUIRE(buf[i]==0xAB);
}

TEST_CASE("Custom deleter: FILE* or int* with counter") {
    struct CntDel {
        static std::atomic<int> dcnt;
        void operator()(int* p) const noexcept { dcnt.fetch_add(1); delete p; }
    };
    std::atomic<int> &dcnt = CntDel::dcnt;
    dcnt = 0;

    {
        MySharedPtr<int> p(new int(5), CntDel{});
        REQUIRE(p.use_count() == 1);
    }
    REQUIRE(dcnt.load() == 1);
}
std::atomic<int> CntDel::dcnt{0};

TEST_CASE("Aliasing constructor: expose subobject, share lifetime") {
    struct Whole { int a=1; int b=2; };
    auto w = my_make_shared<Whole>();
    // aliasing: Whole의 수명 공유, int*만 공개
    MySharedPtr<int> pa(w, &w->b);
    REQUIRE(pa.use_count() == 2); // w + pa
    REQUIRE(*pa == 2);
    w.reset(); // Whole 객체 참조는 pa만 남음
    REQUIRE(pa.use_count() == 1);
    REQUIRE(*pa == 2); // 여전히 유효
}
```

---

## 3. `enable_shared_from_this` / `weak` (파일: `tests/test_enable_and_weak.cpp`)

```cpp
// tests/test_enable_and_weak.cpp
#include <catch2/catch.hpp>
#include <functional>
#include "mysp_all.hpp"

static void fake_async(std::function<void(int)> cb) { cb(123); }

struct Session : MyEnableSharedFromThis<Session> {
    int last=0;
    void start() {
        auto self = shared_from_this();
        fake_async([self](int v){ self->last = v; });
    }
};

TEST_CASE("enable_shared_from_this: safe self capture") {
    auto s = my_make_shared<Session>();
    s->start();
    REQUIRE(s->last == 123);
}

TEST_CASE("weak: cache/registry pattern") {
    struct Foo { int v=7; };
    MyWeakPtr<Foo> wk;
    {
        auto sp = my_make_shared<Foo>();
        wk = sp; // observe only
        auto sp2 = wk.lock();
        REQUIRE(sp2);
        REQUIRE(sp2->v == 7);
    }
    REQUIRE(wk.expired()); // 원본 파괴되면 weak도 만료
}
```

---

## 4. 스레드 스트레스 (파일: `tests/test_thread_stress.cpp`)

```cpp
// tests/test_thread_stress.cpp
#include <catch2/catch.hpp>
#include <thread>
#include <vector>
#include <atomic>
#include "mysp_all.hpp"

struct Blob { std::atomic<int> sum{0}; };

TEST_CASE("Shared copy/reset race (TSan clean)") {
    auto root = my_make_shared<Blob>();
    constexpr int N=8, R=50000;
    std::vector<std::thread> th;
    std::atomic<int> count{0};

    for (int t=0;t<N;++t) {
        th.emplace_back([&,t]{
            for (int i=0;i<R;++i) {
                MySharedPtr<Blob> c = root;  // copy (inc S)
                if (c) {
                    c->sum.fetch_add(1, std::memory_order_relaxed);
                    ++count;
                }
                if ((i+t)%11==0) c.reset();   // dec S
            }
        });
    }
    for (auto& x: th) x.join();

    REQUIRE(root.use_count() >= 1);
    REQUIRE(count.load() == N*R);
}
```

**권장**: 이 테스트는 `-fsanitize=thread`(**TSan**)으로도 깨끗해야 한다. (데이터 레이스는 사용자 코드에서 해결해야 함—여기선 `sum`을 원자화했다.)

---

## 5. 선형 퍼즈(랜덤 시퀀스) (파일: `tests/test_fuzz_linear.cpp`)

```cpp
// tests/test_fuzz_linear.cpp
#include <catch2/catch.hpp>
#include <random>
#include "mysp_all.hpp"

struct Node { int x=0; };

TEST_CASE("Linear fuzz: random copy/reset/alias") {
    std::mt19937_64 rng(12345);
    constexpr int STEPS=100000;

    auto base = my_make_shared<Node>();
    std::vector<MySharedPtr<Node>> pool;

    for (int i=0;i<STEPS;++i) {
        int op = int(rng()%6);
        switch (op) {
            case 0: pool.push_back(base); break;                    // copy
            case 1: if (!pool.empty()) pool.pop_back(); break;
            case 2: if (!pool.empty()) pool[rng()%pool.size()].reset(); break;
            case 3: { // alias subobject (same Node*, lifetime via base)
                int* sub = &base->x;
                pool.emplace_back(base, sub);
                } break;
            case 4: { // new shared and mix
                auto n = my_make_shared<Node>();
                if (!pool.empty()) pool[rng()%pool.size()] = n;
                } break;
            case 5: { // swap two entries
                if (pool.size() > 1) std::swap(pool[rng()%pool.size()], pool[rng()%pool.size()]);
                } break;
        }
    }

    // base 는 최소 1개 참조로 살아 있어야 한다
    REQUIRE(base.use_count() >= 1);
}
```

> **의도**: 다양한 상태 전이를 수행하며 참조 카운팅/aliasing 경계에서 UB가 없어야 한다.
> Sanitizer(ASan/UBSan/TSan) ON 상태에서 장시간 돌려도 무결해야 한다.

---

## 6. GoogleTest 스모크 (파일: `tests/test_gtest_equiv.cpp`)

```cpp
// tests/test_gtest_equiv.cpp
#include <gtest/gtest.h>
#include "mysp_all.hpp"

TEST(GSmoke, UniqueMove) {
    MyUniquePtr<int> p(new int(99));
    auto q = std::move(p);
    EXPECT_EQ(p.get(), nullptr);
    EXPECT_EQ(*q, 99);
}
```

> 동일 리포지토리에서 Catch2와 GTest를 **선택적으로** 돌릴 수 있게 했다. (CI 매트릭스에 둘 다 포함 가능)

---

## 7. CMake & Sanitizer 헬퍼

### `cmake/Sanitizers.cmake`

```cmake
# cmake/Sanitizers.cmake
function(enable_sanitizers target)
  if (MSVC)
    message(STATUS "Sanitizers: limited on MSVC (ASan only in recent MSVC).")
    target_compile_options(${target} PRIVATE /fsanitize=address)
    target_link_options(${target} PRIVATE /fsanitize=address)
  else()
    option(ENABLE_ASAN "Enable AddressSanitizer" ON)
    option(ENABLE_UBSAN "Enable UBSanitizer" ON)
    option(ENABLE_TSAN "Enable ThreadSanitizer" OFF) # TSan은 단일 스레드 런으로 별도 실행 추천

    if (ENABLE_ASAN)
      target_compile_options(${target} PRIVATE -fsanitize=address -fno-omit-frame-pointer)
      target_link_options(${target} PRIVATE -fsanitize=address)
    endif()
    if (ENABLE_UBSAN)
      target_compile_options(${target} PRIVATE -fsanitize=undefined)
      target_link_options(${target} PRIVATE -fsanitize=undefined)
    endif()
    if (ENABLE_TSAN)
      target_compile_options(${target} PRIVATE -fsanitize=thread)
      target_link_options(${target} PRIVATE -fsanitize=thread)
    endif()
  endif()
endfunction()
```

### `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.20)
project(smartptr LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_library(mysp INTERFACE)
target_include_directories(mysp INTERFACE ${CMAKE_SOURCE_DIR}/include)

# Catch2 (vendored single-header or FetchContent 가능)
# 여기선 사용자가 Catch2 헤더를 tests 옆에 둔다고 가정
include(cmake/Sanitizers.cmake)

# Catch2 테스트들
file(GLOB CATCH_TESTS CONFIGURE_DEPENDS tests/test_*catch*.cpp)
add_executable(tests_catch ${CATCH_TESTS})
target_link_libraries(tests_catch PRIVATE mysp)
enable_sanitizers(tests_catch)

# GTest (옵션)
find_package(GTest QUIET)
if (GTest_FOUND)
  add_executable(tests_gtest tests/test_gtest_equiv.cpp)
  target_link_libraries(tests_gtest PRIVATE mysp GTest::gtest GTest::gtest_main)
  enable_sanitizers(tests_gtest)
endif()

# 빌드 타입 기본값
if (NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE RelWithDebInfo CACHE STRING "" FORCE)
endif()

# 커버리지 (GCC/Clang)
option(ENABLE_COVERAGE "Enable coverage" OFF)
if (ENABLE_COVERAGE AND NOT MSVC)
  add_compile_options(--coverage)
  add_link_options(--coverage)
endif()
```

빌드 & 실행:

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=RelWithDebInfo -DENABLE_COVERAGE=ON
cmake --build build -j
./build/tests_catch

# (선택) GTest:
./build/tests_gtest
```

커버리지(예: gcovr):

```bash
gcovr -r . --xml -o coverage.xml --html --html-details -o coverage.html
```

---

## 8. CI 매트릭스 (GitHub Actions 예시: `.github/workflows/ci.yml`)

{% raw %}
```yaml
name: smartptr-ci

on: [push, pull_request]

jobs:
  build-test:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        compiler: [gcc, clang, msvc]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - name: Setup compiler
        if: matrix.compiler == 'gcc' || matrix.compiler == 'clang'
        run: |
          echo "Using default ${ { matrix.compiler } } on $RUNNER_OS"
      - name: Configure
        run: |
          cmake -S . -B build -DCMAKE_BUILD_TYPE=RelWithDebInfo -DENABLE_COVERAGE=ON
      - name: Build
        run: cmake --build build -j
      - name: Run Catch2 tests
        run: ./build/tests_catch
        shell: bash
      - name: Run GTest (if exists)
        run: if [ -f ./build/tests_gtest ]; then ./build/tests_gtest; fi
        shell: bash
      - name: Coverage (Linux only)
        if: matrix.os == 'ubuntu-latest'
        run: |
          pipx install gcovr || pip install gcovr
          gcovr -r . --xml -o coverage.xml
      - name: Upload coverage
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-xml
          path: coverage.xml
```
{% endraw %}

> **팁**
> - Sanitizer 매트릭스는 **별 잡(Job)** 로 분리: `ASAN+UBSAN`(Linux/Clang), `TSAN`(별도).
> - Windows/MSVC는 ASan 일부 지원, TSAN 미지원 → 워크플로우에서 분기.

---

## 9. 린트 & 형식: clang-tidy / clang-format

- **clang-tidy** 룰 추천:
  - `modernize-use-nullptr`, `modernize-use-override`, `modernize-pass-by-value`
  - `performance-inefficient-vector-operation`
  - `hicpp-*`, `cppcoreguidelines-*` (필요에 따라 whitelist)
- **금지 룰**(우리 프로젝트 관례):
  - **`new/delete` 직접 사용 금지**: 테스트 코드에서도 RAII 래핑
  - `shared_ptr<T>` 간 순환 참조 금지 → 한쪽 **항상** `weak_ptr`
  - 배열에 `MySharedPtr<T>` 금지 → `MySharedPtr<T[]>`만 허용

`.clang-tidy` 예시:

```yaml
Checks: >
  -*,
  modernize-*,
  performance-*,
  cppcoreguidelines-*,
  hicpp-*
WarningsAsErrors: '*'
HeaderFilterRegex: 'include/|tests/'
```

---

## 10. **Exit Criteria (출고 기준)**

1) **정적 규칙**
   - `new/delete` 직접 호출 0건
   - 순환 참조(코드 리뷰 규칙) 위반 0건(필요 시 구조적 스캐너 적용)

2) **단위 테스트**
   - Catch2/GTest **전 케이스 PASS**

3) **Sanitizer**
   - ASan/UBSan **0 에러**
   - TSan **0 데이터 레이스**(스트레스/퍼즈 포함)

4) **커버리지**
   - 라인/브랜치 커버리지 **≥ 85%** (핵심 경로: 컨트롤 블록, aliasing, weak, 배열, 커스텀 deleter)

5) **성능 회귀**
   - 5편 벤치마크 대비 **±5% 이내** (환경 허용치 설정)

---

## 11. 부가: 디버그 리포터 훅 (선택)

`my_sp_debug.hpp` 를 켠 빌드에서, 테스트 실행 진입점에:

```cpp
// tests/main_with_report.cpp (Catch2 대체 진입점으로 사용할 때)
#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>
#include "my_sp_debug.hpp"

struct ReporterAtExit {
    ~ReporterAtExit(){ mysp_debug::report(); }
} g_reporter;
```

> 청크 유출 시 **컨트롤 블록 id/type** 목록을 끝에 찍어준다.
> CI에서 이 로그를 **하드 게이트**로 삼아도 된다.

---

## 12. 자주 묻는 질문(FAQ)

- **Q. `MySharedPtr<T>`로 배열을 관리하면 안 되나요?**
  A. 안 된다. 배열은 `delete[]`가 필요하므로 `MySharedPtr<T[]>` 또는 **커스텀 deleter**로 `delete[]`를 지정해야 한다.

- **Q. 콜백이 길게 살아서 객체가 안 꺼집니다.**
  A. 콜백 체인이 서로 `shared_from_this()`를 캡처했다. **한쪽을 `weak_ptr`** 로 바꾸고 `lock()`해서 쓰라.

- **Q. TSan이 레이스를 경고합니다.**
  A. 카운팅 로직 자체는 원자적이어야 하며, **객체 내부 상태 접근**은 별개다. 필요한 곳에 `mutex`/원자 연산을 추가하라.

---

## 13. 수식으로 다시 보는 참조 카운팅 검증 관찰치

- `lock()` 성공률은 $$ S>0 $$ 구간에서만 비영(非零)
- 스트레스 N스레드, R반복에서 **성공 횟수** $$C$$ 는 대략 $$ 0 < C \le N\times R $$
- 종료 시점 **불변식**:
  - 루트만 남기면 $$ S \ge 1, W \ge 0 $$
  - 전체 해제 후 $$ S=0 \land W=0 $$ 이어야 컨트롤 블록 제거

이 값들을 **테스트 어서션**으로 구속하면 회귀 검출력이 커진다.

---

## 14. 마무리 — “제품화 가능한 상태”

- **테스트 스위트**: 기능/스레드/퍼즈 모두 포괄
- **Sanitizer & CI**: 플랫폼-컴파일러 매트릭스로 반복 검증
- **품질 게이트**: 커버리지·성능·린트·유출 0
- 위 기준을 통과하면, 1~5편에서 만든 커스텀 스마트 포인터 패밀리는 **현업 코드베이스**에 투입가능한 수준의 **지속 가능 품질체계**를 갖추게 된다.

> 이제 리포지토리에 올리고 CI를 돌려라. **빨간불이 한 번이라도 켜지면 원인-재현-픽스-회귀 테스트 추가**가 루틴이 된다.
> 이것이 현대 C++에서 **RAII/스마트 포인터 기반 메모리 안전성**을 “조직의 표준”으로 만드는 가장 빠른 길이다.
