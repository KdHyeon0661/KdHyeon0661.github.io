---
layout: post
title: C++ - 스마트 포인터 적용 예제
date: 2024-09-28 19:20:23 +0900
category: Cpp
---
# C++ 스마트 포인터 테스트와 품질 보증: 제품화를 위한 완성도

지난 5편에 걸쳐 우리는 `MyUniquePtr`, `MySharedPtr`, `MyWeakPtr`, 그리고 `enable_shared_from_this`를 완전히 구현했습니다. 배열 지원, 커스텀 삭제자, 다형성 캐스팅, 불완전형 처리 등 현실적인 요구사항을 모두 충족시켰습니다. 이제 마지막 단계는 이 모든 것이 실제 프로젝트에서 신뢰할 수 있도록 검증 체계를 구축하는 것입니다.

## 테스트의 철학: 단순한 검증을 넘어 신뢰 구축하기

좋은 테스트 스위트는 단순히 기능이 동작하는지 확인하는 것을 넘어 시스템의 근본적인 속성을 검증해야 합니다. 우리가 구현한 스마트 포인터 시스템은 메모리 안전성, 스레드 안전성, 예외 안전성이라는 세 가지 핵심 원칙 위에 구축되었습니다. 이 원칙들이 실제로 지켜지고 있는지 확인하는 것이 테스트의 목표입니다.

### 핵심 불변식: 참조 카운팅의 수학적 기초

참조 카운팅 시스템의 모든 동작은 몇 가지 간단하지만 강력한 수학적 불변식에 기반합니다. 이러한 불변식들을 코드로 표현하고 검증하는 것은 시스템의 정확성을 보장하는 가장 확실한 방법입니다.

```cpp
TEST_CASE("Reference counting fundamental invariants") {
    // 불변식 1: 객체는 shared_count가 0이 될 때 파괴된다
    {
        auto tracker = std::make_shared<DestructionTracker>();
        REQUIRE_FALSE(tracker->destroyed);
        
        auto sp1 = my_make_shared<DestructionTracker>();
        auto sp2 = sp1;
        auto sp3 = sp2;
        
        // 3개의 참조가 존재
        REQUIRE(sp1.use_count() == 3);
        
        sp1.reset();  // 참조 2개 남음
        sp2.reset();  // 참조 1개 남음
        
        // 아직 객체는 살아있음
        REQUIRE_FALSE(sp3->destroyed);
        
        sp3.reset();  // 마지막 참조 해제
        // 객체는 여기서 파괴되어야 하지만, 테스트에서 직접 확인할 수는 없음
    }
    
    // 불변식 2: weak_count는 컨트롤 블록의 수명을 관리한다
    {
        MyWeakPtr<int> weak_ref;
        
        {
            auto shared = my_make_shared<int>(42);
            weak_ref = shared;
            
            REQUIRE_FALSE(weak_ref.expired());
            REQUIRE(weak_ref.use_count() == 1);
        }
        
        // 객체는 파괴되었지만 컨트롤 블록은 weak_ref 때문에 살아있음
        REQUIRE(weak_ref.expired());
        
        // weak_ref가 소멸되면 컨트롤 블록도 파괴됨
    }
}
```

이러한 수학적 불변식은 단순히 특정 동작을 테스트하는 것을 넘어, 시스템이 근본적으로 올바르게 설계되었음을 증명합니다.

## 포괄적인 테스트 계층 구조

단일 테스트 유형으로는 복잡한 시스템의 모든 측면을 검증할 수 없습니다. 우리는 네 가지 서로 다른 테스트 계층을 구축합니다:

### 1. 단위 테스트: 기본 기능 검증

각 컴포넌트의 고립된 동작을 검증합니다. `MyUniquePtr`의 이동 의미론, `MySharedPtr`의 참조 카운팅, `MyWeakPtr`의 lock 메커니즘 등이 여기에 해당합니다.

```cpp
TEST_CASE("MyUniquePtr basic semantics") {
    // 이동만 가능하고 복사는 불가능해야 함
    auto p1 = my_make_unique<int>(42);
    
    // 복사 시도 (컴파일 에러가 발생해야 하지만, 테스트에서는 다른 방법으로 확인)
    // MyUniquePtr<int> p2 = p1;  // 컴파일되지 않음
    
    // 이동은 가능
    auto p2 = std::move(p1);
    REQUIRE(p1.get() == nullptr);
    REQUIRE(p2.get() != nullptr);
    REQUIRE(*p2 == 42);
    
    // 소유권 이전 후 원본은 더 이상 소유권이 없음
    int* raw = p2.release();
    REQUIRE(p2.get() == nullptr);
    REQUIRE(*raw == 42);
    delete raw;  // 수동 해제
}
```

### 2. 통합 테스트: 컴포넌트 간 상호작용

여러 컴포넌트가 함께 동작할 때의 상호작용을 검증합니다. 특히 `enable_shared_from_this`와의 통합이나 배열 특수화와의 호환성 등이 중요합니다.

```cpp
TEST_CASE("Integration: enable_shared_from_this with aliasing") {
    class Resource : public MyEnableSharedFromThis<Resource> {
    public:
        struct Metadata {
            int version = 1;
            std::string creator;
        } metadata;
        
        std::vector<int> data;
    };
    
    auto resource = my_make_shared<Resource>();
    resource->data.resize(100);
    
    // aliasing 생성자를 통한 메타데이터 접근
    auto metadata_ptr = MySharedPtr<Resource::Metadata>(
        resource, &resource->metadata);
    
    // shared_from_this와의 혼합 사용
    auto self_ptr = resource->shared_from_this();
    
    REQUIRE(resource.use_count() == 3);  // resource + metadata_ptr + self_ptr
    REQUIRE(metadata_ptr.use_count() == 3);
    
    // 모든 참조가 같은 컨트롤 블록을 공유하는지 확인
    resource->metadata.creator = "Test System";
    REQUIRE(metadata_ptr->creator == "Test System");
}
```

### 3. 성능 테스트: 예측 가능한 실행 시간

스마트 포인터는 성능이 중요한 코드에서 자주 사용됩니다. 따라서 성능 특성을 이해하고 예측할 수 있어야 합니다.

```cpp
TEST_CASE("Performance characteristics under load") {
    constexpr size_t iterations = 1000000;
    
    // 참조 카운팅 오버헤드 측정
    auto start = std::chrono::high_resolution_clock::now();
    
    auto base = my_make_shared<LargeObject>();
    for (size_t i = 0; i < iterations; ++i) {
        auto copy = base;  // 참조 카운트 증가
        // copy는 스코프를 벗어나며 참조 카운트 감소
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    // 참조 카운트 증가/감소에 소요된 평균 시간
    double avg_time_per_op = duration.count() / double(iterations);
    
    // 성능 기준치: 참조 카운트 연산은 매우 가벼워야 함
    REQUIRE(avg_time_per_op < 10.0);  // 10마이크로초 이하
}
```

### 4. 스트레스 테스트: 극한 조건에서의 안정성

실제 프로덕션 환경에서는 예상치 못한 부하나 경쟁 조건이 발생할 수 있습니다. 스트레스 테스트는 이러한 상황에서 시스템이 어떻게 동작하는지 확인합니다.

```cpp
TEST_CASE("Stress test: concurrent access patterns") {
    constexpr int num_threads = 16;
    constexpr int operations_per_thread = 50000;
    
    std::atomic<bool> running{true};
    std::vector<std::thread> threads;
    
    // 공유 자원
    auto shared_data = my_make_shared<ThreadSafeData>();
    
    // 통계 수집
    std::atomic<long> total_successful_locks{0};
    std::atomic<long> total_failed_locks{0};
    std::atomic<long> total_operations{0};
    
    for (int i = 0; i < num_threads; ++i) {
        threads.emplace_back([&, thread_id = i]() {
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> dist(0, 100);
            
            while (running.load(std::memory_order_relaxed)) {
                int operation = dist(gen);
                
                if (operation < 30) {
                    // 단순 참조 획득/해제
                    auto local_ref = shared_data;
                    total_operations++;
                }
                else if (operation < 60) {
                    // 약한 참조 테스트
                    MyWeakPtr<ThreadSafeData> weak = shared_data;
                    if (auto strong = weak.lock()) {
                        strong->increment_counter();
                        total_successful_locks++;
                    } else {
                        total_failed_locks++;
                    }
                    total_operations++;
                }
                else if (operation < 90) {
                    // 복잡한 소유권 패턴
                    std::vector<MySharedPtr<ThreadSafeData>> local_pool;
                    local_pool.reserve(10);
                    
                    for (int j = 0; j < 10; ++j) {
                        local_pool.push_back(shared_data);
                    }
                    
                    // 순환 섞기
                    std::shuffle(local_pool.begin(), local_pool.end(), gen);
                    total_operations += 10;
                }
                else {
                    // 컨트롤 블록 재할당 (드물게)
                    if (thread_id == 0) {  // 한 스레드만 실행
                        shared_data.reset(new ThreadSafeData());
                    }
                    total_operations++;
                }
                
                // 일정 횟수 후 종료
                if (total_operations.load() > num_threads * operations_per_thread) {
                    running.store(false, std::memory_order_relaxed);
                }
            }
        });
    }
    
    // 실행 시간 제한
    std::this_thread::sleep_for(std::chrono::seconds(10));
    running.store(false, std::memory_order_relaxed);
    
    // 모든 스레드 정리
    for (auto& t : threads) {
        if (t.joinable()) t.join();
    }
    
    // 결과 검증
    REQUIRE(shared_data.use_count() >= 1);
    REQUIRE(total_successful_locks.load() > 0);
    
    // 데이터 일관성 검사
    REQUIRE(shared_data->counter_consistent());
}
```

## CI/CD 파이프라인: 자동화된 품질 보증

개발자의 로컬 환경에서만 테스트하는 것은 충분하지 않습니다. 지속적 통합(CI) 시스템은 모든 변경 사항이 다양한 환경에서 일관되게 검증되도록 보장합니다.

### 다중 플랫폼 검증

실제 프로젝트는 다양한 환경에서 실행됩니다. 우리의 CI 파이프라인은 이 다양성을 반영해야 합니다.

{% raw %}
```yaml
# .github/workflows/ci.yml
name: SmartPtr CI

on: [push, pull_request]

jobs:
  build-and-test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        compiler: [gcc, clang, msvc]
        build-type: [Debug, Release]
        sanitizer: [none, asan, ubsan]
      
      # 비호환 조합 제외
      exclude:
        - os: windows-latest
          sanitizer: ubsan  # Windows에서는 UBSan 미지원
        - compiler: msvc
          sanitizer: asan   # MSVC ASan은 별도 설정 필요
    
    runs-on: ${{ matrix.os }}
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup compiler
      run: |
        if [ "${{ matrix.compiler }}" = "gcc" ]; then
          sudo apt-get update
          sudo apt-get install g++-11
        elif [ "${{ matrix.compiler }}" = "clang" ]; then
          sudo apt-get update
          sudo apt-get install clang-14
        fi
    
    - name: Configure CMake
      run: |
        cmake -S . -B build \
          -DCMAKE_BUILD_TYPE=${{ matrix.build-type }} \
          -DMYSP_ENABLE_SANITIZER=${{ matrix.sanitizer }} \
          -DMYSP_ENABLE_COVERAGE=${{ matrix.build-type == 'Debug' }}
    
    - name: Build
      run: cmake --build build --config ${{ matrix.build-type }} --parallel 4
    
    - name: Run tests
      run: |
        cd build
        ctest --build-config ${{ matrix.build-type }} \
              --output-on-failure \
              --parallel 4
    
    - name: Collect coverage (Linux/Debug only)
      if: matrix.os == 'ubuntu-latest' && matrix.build-type == 'Debug'
      run: |
        gcovr --xml coverage.xml \
              --html coverage.html \
              --print-summary \
              --exclude-unreachable-branches \
              --fail-under-line 85.0
      
    - name: Upload coverage
      uses: actions/upload-artifact@v3
      if: matrix.os == 'ubuntu-latest' && matrix.build-type == 'Debug'
      with:
        name: coverage-${{ matrix.compiler }}
        path: coverage.xml
```
{% endraw %}

이 CI 설정은 다음과 같은 중요한 기능을 제공합니다:
1. **크로스 플랫폼 검증**: Linux, Windows, macOS에서의 동작 확인
2. **컴파일러 호환성**: GCC, Clang, MSVC 모두 지원
3. **Sanitizer 통합**: 메모리 오류와 정의되지 않은 동작 감지
4. **코드 커버리지**: 테스트 완전성 측정

## 정적 분석과 코드 품질

동적 테스트만으로는 충분하지 않습니다. 정적 분석 도구는 코드를 실행하지 않고도 잠재적 문제를 발견할 수 있습니다.

### Clang-Tidy 규칙 세트

```yaml
# .clang-tidy
Checks: >
  -*,
  bugprone-*,
  clang-analyzer-*,
  cppcoreguidelines-*,
  google-*,
  hicpp-*,
  modernize-*,
  performance-*,
  portability-*,
  readability-*
  
WarningsAsErrors: '*'
HeaderFilterRegex: 'include/.*|src/.*'
CheckOptions:
  - key: cppcoreguidelines-owning-memory.OwningPointerTypes
    value: 'MyUniquePtr;MySharedPtr'
  - key: cppcoreguidelines-pro-bounds-array-to-pointer-decay.Whitelist
    value: 'assert'
  - key: modernize-use-nodiscard.Macros
    value: 'MY_NODISCARD'
```

이 규칙 세트는 다음과 같은 문제를 감지합니다:
1. **메모리 관리 오류**: 소유권 이전 실수, 누수 가능성
2. **성능 문제**: 불필요한 복사, 비효율적인 알고리즘
3. **가독성 문제**: 복잡한 표현식, 모호한 네이밍
4. **이식성 문제**: 플랫폼 의존적 코드

## 품질 게이트: 출시를 위한 기준

코드가 프로덕션에 배포되기 전에 충족해야 할 최소 기준을 명확히 정의해야 합니다.

### 1. 기능적 완전성

모든 설계 요구사항이 구현되고 검증되었는지 확인합니다:
- [x] 단독 소유권(`MyUniquePtr`)의 이동 의미론
- [x] 공유 소유권(`MySharedPtr`)의 참조 카운팅
- [x] 약한 참조(`MyWeakPtr`)와 순환 참조 해결
- [x] `enable_shared_from_this` 지원
- [x] 배열 특수화(`T[]`)
- [x] 커스텀 삭제자
- [x] 다형성 캐스팅(`static_pointer_cast` 등)
- [x] 불완전형 지원

### 2. 안전성 보장

메모리 안전성이 검증 가능한 불변식으로 보장됩니다:
- [x] 참조 카운트 언더플로우/오버플로우 방지
- [x] 더블 프리(double-free) 방지
- [x] 댕글링 포인터(dangling pointer) 방지
- [x] 스레드 안전한 참조 카운팅
- [x] 예외 안전성 보장

### 3. 성능 예측 가능성

주요 사용 사례에서의 성능이 기준치를 충족합니다:
- [x] `MyUniquePtr` 오버헤드: RAW 포인터 대비 5% 이내
- [x] `MySharedPtr` 참조 카운트 연산: 10ns 이하
- [x] `weak_ptr::lock()` 성공 시: 15ns 이하
- [x] 메모리 사용량: 표준 구현 대비 10% 이내

### 4. 플랫폼 호환성

대상 플랫폼 전반에서 일관된 동작이 보장됩니다:
- [x] x86_64 Linux (GCC/Clang)
- [x] ARM64 Linux (GCC/Clang)
- [x] x64 Windows (MSVC)
- [x] macOS (Apple Clang)

## 지속 가능한 개발 문화 구축

테스트와 CI 시스템은 단순히 기술적 도구가 아닙니다. 이들은 개발 조직의 문화를 형성합니다.

### 버그 발견부터 수정까지의 흐름

1. **자동 감지**: CI 파이프라인이 실패하면 즉시 알림
2. **신속한 진단**: 실패한 테스트와 관련 코드를 명확히 연결
3. **회귀 방지**: 버그 수정 후 새로운 테스트 케이스 추가
4. **지식 공유**: 실패 원인과 해결책을 팀과 공유

### 품질 지표의 진화

초기에는 기본적인 기능 테스트만으로 충분할 수 있습니다. 하지만 시스템이 성장함에 따라 품질 기준도 진화해야 합니다:

```cpp
// 품질 기준의 진화적 발전
class QualityMetrics {
public:
    // Phase 1: 기본 기능 (초기 개발)
    bool allUnitTestsPass() const;
    
    // Phase 2: 안정성 (알파 테스트)
    bool noMemoryErrors() const;      // ASan/Valgrind
    bool noDataRaces() const;         // TSan
    bool noUndefinedBehavior() const; // UBSan
    
    // Phase 3: 성능 (베타 테스트)
    bool meetsPerformanceTargets() const;
    bool memoryUsageWithinBounds() const;
    
    // Phase 4: 프로덕션 준비
    bool crossPlatformCompatible() const;
    bool backwardCompatible() const;
    bool apiStable() const;
};
```

## 마무리: 신뢰성에서 우수성으로

이 6편에 걸친 여정을 통해 우리는 단순한 스마트 포인터 구현을 넘어 현대 C++ 소프트웨어 개발의 완전한 생태계를 구축했습니다. 각 단계는 단순히 기능을 추가하는 것이 아니라, 시스템의 신뢰성을 한 단계씩 높여왔습니다.

가장 중요한 통찰은 **테스트와 검증이 사후 조치가 아니라 설계의 일부**라는 점입니다. 우리가 구현한 각 기능은 그 자체로 검증 가능한 속성을 가지고 있으며, 이러한 속성들은 자동화된 테스트로 표현되고 CI 시스템으로 지속적으로 검증됩니다.

이 시리즈가 보여준 것은 단순히 스마트 포인터를 구현하는 방법이 아닙니다. 그것은 **견고한 소프트웨어를 구축하는 철학과 방법론**입니다. 수학적 불변식에서 시작하여 점진적으로 복잡성을 추가하고, 각 단계에서 검증을 강화하며, 마지막으로 완전한 품질 보증 시스템으로 완성하는 이 접근 방식은 어떤 소프트웨어 프로젝트에도 적용될 수 있습니다.

여러분이 이 지식을 바탕으로 자신만의 라이브러리를 만들거나, 기존 프로젝트에 이 철학을 적용하거나, 단순히 C++의 내부 동작을 더 깊이 이해하는 데 도움이 되었기를 바랍니다. 기술적 완성도와 실용적 적용 사이의 균형을 유지하며, 계속해서 배우고 개선해 나가는 여정이 계속되기를 바랍니다.