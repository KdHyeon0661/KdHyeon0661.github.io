---
layout: post
title: 영상처리 - 성능 계측
date: 2025-10-14 21:25:23 +0900
category: 영상처리
---
# **성능 계측**: 해상도·Quality·샘플링별 **인코더/디코더 시간·메모리** 로그
> 목표: **TurboJPEG**(또는 jpeglib) 기반 파이프라인에서, 해상도/품질(Q)/샘플링(4:2:0/4:4:4)·스케일 디코드(1/1, 1/2, 1/4)·옵션(Optimize/Progressive/Restart) 조합에 대해
> **디코드/인코드 시간(ms)**, **출력 크기(bytes)**, **메모리 사용(Working Set, Private Bytes)** 을 **CSV**로 기록.
> - 코드 블록은 ` ```cpp ` **한 번만** 사용.
> - 수학은 **MathJax** 활용.

---

## 0. 계측 설계 개요

### 어떤 지표를 남길까?
- **시간**: 디코드(ms), 전처리(ms), 인코드(ms), 총합(ms)
- **메모리**: Working Set(MB), Private Bytes(MB) — *Windows API*, Linux라면 `/proc/self/status` 기반
- **출력**: JPEG 바이트 수, 샘플링(420/444), Q(1~100), Progressive/Optimize/Restart 설정
- **입력 특징**: 파일명, 원본 WxH, 디코드 스케일(1/1, 1/2, 1/4, 1/8), 컬러공간(참고)

### 측정 원칙
- **워밍업**: 첫 1회는 JIT/페이지 인/파일 캐시에 의해 지표가 요동 → **버림** 또는 별도 마킹
- **반복**: 각 조합 **N회(예: 5회)** 평균·표준편차 산출(로그는 개별 row로 남긴 뒤 통계는 후처리)
- **백프레셔**: 대량 벤치마크 시 **유한 큐**로 메모리 폭주 방지(멀티스레드 시 유효)
- **고정 인자**: CPU 주파수/Turbo 상태, 전원 옵션, 방해 프로세스 등을 고정

> **Tip**: 가능한 한 **단일 머신**에서, **동일 프로세스** 내에서만 비교하세요. 다른 도구와 혼합하면 잡음↑.

---

## 1. 테스트 매트릭스(예시)

- **해상도**: 원본 그대로 + 디코드 스케일 `{1/1, 1/2, 1/4}`
- **Q**: `{75, 85, 90, 95}`
- **샘플링**: `{420, 444}` (사진 vs UI 프리셋 비교 용도)
- **옵션**: Optimize={On/Off}, Progressive={On/Off}, Restart rows={0, 4} (선택)
- **반복 횟수**: `repeat = 5`

---

## 2. 수식: 평균/표준편차, 스케일 이득
반복 계측값이 \( t_1, t_2, \dots, t_n \) 일 때,
\[
\bar{t} = \frac{1}{n}\sum_{i=1}^{n} t_i,\quad
s = \sqrt{\frac{1}{n-1}\sum_{i=1}^{n}(t_i - \bar{t})^2}
\]
스케일 디코드(예: 1/2) 대비 1/1의 시간 이득율은
\[
\text{Gain} = 100 \times \left(1 - \frac{\bar{t}_{1/2}}{\bar{t}_{1/1}}\right)\%
\]

---

## 3. 벤치마크 도구: **mtjpeg_bench** (CLI)
- 입력 폴더의 이미지들(JPEG/PNG/BMP)을 순회
- TurboJPEG로 **BGRA 디코드** → (선택) 간단 전처리 → **JPEG 인코드**
- 각 조합을 **반복 N회** 수행 후 CSV로 append

> Windows 기준 **메모리**: `GetProcessMemoryInfo` 사용
> Linux/Mac도 지원하려면 `/proc/self/status` 또는 `mach_task_basic_info` 분기 추가

---

## 4. 구현 코드

### 4.1 유틸: 타이머/메모리/CSV/옵션 파서
```cpp
#include <windows.h>
#include <psapi.h>
#include <cstdio>
#include <string>
#include <vector>
#include <chrono>
#include <filesystem>
#include <algorithm>

// ---- Timer ----
struct HiTimer {
    using clock = std::chrono::high_resolution_clock;
    clock::time_point t;
    void start(){ t = clock::now(); }
    double ms() const {
        auto d = clock::now() - t;
        return std::chrono::duration<double, std::milli>(d).count();
    }
};

// ---- Memory snapshot (Windows) ----
struct MemSnap {
    double workingSetMB=0.0;
    double privateMB=0.0;
};
inline MemSnap read_mem(){
    PROCESS_MEMORY_COUNTERS_EX pmc{};
    MemSnap m{};
    if (GetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*)&pmc, sizeof(pmc))){
        m.workingSetMB = pmc.WorkingSetSize / (1024.0*1024.0);
        m.privateMB    = pmc.PrivateUsage   / (1024.0*1024.0);
    }
    return m;
}

// ---- CSV ----
struct Csv {
    FILE* fp=nullptr;
    bool open(const std::wstring& path){
        return _wfopen_s(&fp, path.c_str(), L"ab") == 0; // append
    }
    void header(){
        static const char* H =
            "ts,file,w,h,scale,phase,quality,sampling,progressive,optimize,restart_rows,"
            "decode_ms,process_ms,encode_ms,total_ms,ws_mb,priv_mb,out_bytes\n";
        // 헤더 중복 방지를 위해 파일이 비어 있을 때만 쓰고 싶다면 ftell 체크
        long pos = ftell(fp);
        if (pos==0) fwrite(H,1,strlen(H),fp);
    }
    void row(const std::string& line){
        fwrite(line.c_str(),1,line.size(),fp);
        fputc('\n', fp);
        fflush(fp);
    }
    ~Csv(){ if (fp) fclose(fp); }
};

// ---- CLI options ----
struct BenchOpt {
    std::wstring inDir, outDir, csvPath;
    int repeat = 3;
    std::vector<int> qualities {75,85,90,95};
    std::vector<int> samplings {420,444}; // TurboJPEG enum과 매핑 예정
    std::vector<double> scales {1.0, 0.5, 0.25};
    bool progressive = true;
    bool optimize    = true;
    int  restartRows = 0; // 0=off
};
```

### 4.2 TurboJPEG 래퍼 & 간단 IppDib
```cpp
#include <turbojpeg.h>

struct Dib {
    int w=0,h=0,stride=0,bpp=32;
    std::vector<unsigned char> buf;
    bool create(int W, int H){
        w=W; h=H; bpp=32; stride = ((w*4 + 3)/4)*4;
        buf.assign((size_t)stride*h, 0);
        return true;
    }
    unsigned char* bits(){ return buf.data(); }
    const unsigned char* bits() const { return buf.data(); }
    bool valid() const { return !buf.empty(); }
};

static bool tj_decode_bgra(const std::wstring& path, double scale, Dib& out, std::string& err){
    err.clear();
    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"rb");
    if(!fp){ err="open"; return false; }
    fseek(fp,0,SEEK_END); long sz=ftell(fp); fseek(fp,0,SEEK_SET);
    std::vector<unsigned char> data(sz);
    fread(data.data(),1,sz,fp); fclose(fp);

    tjhandle td = tjInitDecompress(); if(!td){ err="td init"; return false; }

    int W=0,H=0,subs=0,cs=0;
    if (tjDecompressHeader3(td, data.data(), (unsigned long)data.size(), &W,&H,&subs,&cs)!=0){
        err=tjGetErrorStr2(td); tjDestroy(td); return false;
    }

    // scale 인자에 가장 근접한 factor 선택
    int ns=0; tjscalingfactor* sfs = tjGetScalingFactors(&ns);
    int outW=W, outH=H;
    double best=0.0;
    for (int i=0;i<ns;++i){
        int sw=TJSCALED(W,sfs[i]), sh=TJSCALED(H,sfs[i]);
        double sc = (double)sw/W;
        if (sc<=scale+1e-9 && sc>best){ best=sc; outW=sw; outH=sh; }
    }
    if (!out.create(outW,outH)){ tjDestroy(td); err="alloc"; return false; }

    int flags = TJFLAG_FASTUPSAMPLE | TJFLAG_LIMITSCANS | TJFLAG_FASTDCT;
    if (tjDecompress2(td, data.data(), (unsigned long)data.size(),
                      out.bits(), outW, out.stride, outH,
                      TJPF_BGRA, flags)!=0){
        err=tjGetErrorStr2(td); tjDestroy(td); return false;
    }

    tjDestroy(td);
    return true;
}

static int to_tjsamp(int s){ return (s==444)? TJSAMP_444 : TJSAMP_420; }

static bool tj_encode_bgra(const Dib& in, int quality, int sampling,
                           bool progressive, bool optimize,
                           std::vector<unsigned char>& jpeg, std::string& err)
{
    err.clear(); jpeg.clear();
    tjhandle tc = tjInitCompress(); if(!tc){ err="tc init"; return false; }
    int flags=0;
    if (progressive) flags |= TJFLAG_PROGRESSIVE;
    if (optimize)    flags |= TJFLAG_OPTIMIZE_CODING;
    flags |= TJFLAG_FASTDCT;

    unsigned char* out=nullptr; unsigned long outSize=0;
    if (tjCompress2(tc, (unsigned char*)in.bits(), in.w, in.stride, in.h,
                    TJPF_BGRA, &out, &outSize,
                    to_tjsamp(sampling), quality, flags)!=0){
        err=tjGetErrorStr2(tc); tjDestroy(tc); return false;
    }
    jpeg.assign(out, out+outSize);
    tjFree(out); tjDestroy(tc);
    return true;
}
```

### 4.3 벤치마크 핵심 루프
```cpp
#include <ctime>

static std::string now_iso8601(){
    std::time_t t = std::time(nullptr);
    char buf[64]; std::strftime(buf,sizeof(buf),"%Y-%m-%dT%H:%M:%SZ", std::gmtime(&t));
    return buf;
}

static std::string csv_escape(const std::wstring& ws){
    std::string s(ws.begin(), ws.end());
    // 단순 치환: 콤마/따옴표 포함 시 따옴표로 감싸기
    bool need = s.find(',')!=std::string::npos || s.find('"')!=std::string::npos;
    std::string out; out.reserve(s.size()+4);
    if (!need) return s;
    out.push_back('"');
    for (char c: s){ if (c=='"') out.push_back('"'); out.push_back(c); }
    out.push_back('"');
    return out;
}

static void bench_one_file(const BenchOpt& opt, const std::filesystem::path& p, Csv& csv)
{
    // 입력 확장자 필터
    auto ext = p.extension().wstring(); std::transform(ext.begin(), ext.end(), ext.begin(), ::towlower);
    if (ext!=L".jpg" && ext!=L".jpeg" && ext!=L".png" && ext!=L".bmp") return;

    // 파일명/경로
    std::wstring inPath = p.wstring();
    // 원본 크기 파악을 위해 1/1 디코드 헤더만 보기 → 여기선 실제 디코드에서 얻음

    for (double scale : opt.scales){
        for (int quality : opt.qualities){
            for (int samp : opt.samplings){
                for (int r=0; r<opt.repeat; ++r){
                    // ---- Decode ----
                    Dib dib;
                    HiTimer td; td.start();
                    std::string err;
                    MemSnap m0 = read_mem();
                    bool okD = tj_decode_bgra(inPath, scale, dib, err);
                    double tDecode = td.ms();
                    if (!okD){
                        std::string row = now_iso8601()+"," + csv_escape(inPath) + ",,,"
                            + std::to_string(scale) + ",decode_err," + std::to_string(quality) + ","
                            + std::to_string(samp) + "," + (opt.progressive?"1":"0") + "," + (opt.optimize?"1":"0") + ","
                            + std::to_string(opt.restartRows) + ",,,,"
                            + std::to_string(m0.workingSetMB) + "," + std::to_string(m0.privateMB) + ",\n";
                        csv.row(row);
                        continue;
                    }
                    MemSnap m1 = read_mem();

                    // ---- (Optional) Process ----
                    HiTimer tp; tp.start();
                    // NO-OP (필요 시 리사이즈/필터)
                    double tProcess = tp.ms();

                    // ---- Encode ----
                    std::vector<unsigned char> jpg;
                    HiTimer te; te.start();
                    bool okE = tj_encode_bgra(dib, quality, samp, opt.progressive, opt.optimize, jpg, err);
                    double tEncode = te.ms();
                    MemSnap m2 = read_mem();
                    if (!okE){
                        std::string row = now_iso8601()+"," + csv_escape(inPath) + ","
                            + std::to_string(dib.w) + "," + std::to_string(dib.h) + ","
                            + std::to_string(scale) + ",encode_err," + std::to_string(quality) + ","
                            + std::to_string(samp) + "," + (opt.progressive?"1":"0") + "," + (opt.optimize?"1":"0") + ","
                            + std::to_string(opt.restartRows) + ","
                            + std::to_string(tDecode) + "," + std::to_string(tProcess) + ",,"
                            + std::to_string(m2.workingSetMB) + "," + std::to_string(m2.privateMB) + ",\n";
                        csv.row(row);
                        continue;
                    }

                    double tTotal = tDecode + tProcess + tEncode;

                    // ---- CSV 기록 ----
                    std::string row = now_iso8601()+"," + csv_escape(inPath) + ","
                        + std::to_string(dib.w) + "," + std::to_string(dib.h) + ","
                        + std::to_string(scale) + ",ok," + std::to_string(quality) + ","
                        + std::to_string(samp) + "," + (opt.progressive?"1":"0") + "," + (opt.optimize?"1":"0") + ","
                        + std::to_string(opt.restartRows) + ","
                        + std::to_string(tDecode) + "," + std::to_string(tProcess) + ","
                        + std::to_string(tEncode) + "," + std::to_string(tTotal) + ","
                        + std::to_string(m2.workingSetMB) + "," + std::to_string(m2.privateMB) + ","
                        + std::to_string(jpg.size());
                    csv.row(row);

                    // ---- (선택) 결과 샘플 저장 ----
                    if (r==0){ // 첫 반복만 저장
                        std::filesystem::create_directories(opt.outDir);
                        auto outName = opt.outDir / (p.stem().wstring() + L"_"
                            + std::to_wstring(dib.w) + L"x" + std::to_wstring(dib.h) + L"_"
                            + std::to_wstring(quality) + L"_"
                            + (samp==444?L"444":L"420") + L".jpg");
                        FILE* ofp=nullptr; _wfopen_s(&ofp, outName.c_str(), L"wb");
                        if (ofp){ fwrite(jpg.data(),1,jpg.size(),ofp); fclose(ofp); }
                    }
                }
            }
        }
    }
}
```

### 4.4 `main()`: 인자 처리 & 드라이브
```cpp
int wmain(int argc, wchar_t** argv){
    if (argc < 4){
        wprintf(L"usage: mtjpeg_bench <inDir> <outDir> <csvPath> [repeat]\n");
        return 0;
    }
    BenchOpt opt;
    opt.inDir  = argv[1];
    opt.outDir = argv[2];
    opt.csvPath= argv[3];
    if (argc >= 5) opt.repeat = _wtoi(argv[4]);

    Csv csv;
    if (!csv.open(opt.csvPath)){
        wprintf(L"CSV open failed\n"); return 1;
    }
    csv.header();

    // 입력 폴더 순회
    for (auto& it : std::filesystem::recursive_directory_iterator(opt.inDir)){
        if (!it.is_regular_file()) continue;
        bench_one_file(opt, it.path(), csv);
    }
    return 0;
}
```

> **확장 포인트(간단)**
> - `opt.progressive/optimize/restartRows` 를 커맨드라인 플래그로 노출
> - **jpeglib 경로**로 스위치(Progressive 스캔 수 제어, Restart rows 지정 등 세밀 설정 필요 시)

---

## 5. 실행 예시 & CSV 샘플

### 실행
```text
mtjpeg_bench C:\images C:\bench_out C:\bench_log\jpeg_bench.csv 5
```

### CSV(일부)
```text
ts,file,w,h,scale,phase,quality,sampling,progressive,optimize,restart_rows,decode_ms,process_ms,encode_ms,total_ms,ws_mb,priv_mb,out_bytes
2025-10-28T10:05:12Z,C:\images\photo1.jpg,4032,3024,1.000000,ok,90,420,1,1,0,18.12,0.03,22.45,40.60,312.4,290.7,1458932
2025-10-28T10:05:13Z,C:\images\photo1.jpg,2016,1512,0.500000,ok,90,420,1,1,0,7.92,0.02,10.84,18.80,314.1,291.0,512834
2025-10-28T10:05:15Z,C:\images\ui_dark.png,2560,1440,1.000000,ok,92,444,1,1,0,9.66,0.01,31.22,40.89,316.3,291.8,1032841
```

---

## 6. **결과 해석 가이드**

1. **해상도 vs 디코드**
   - 1/2, 1/4 스케일 디코드에서 **시간 대폭↓**가 정상. 썸네일/프리뷰 경로에 적용.
2. **샘플링 vs 인코드**
   - 4:4:4는 **시간↑·용량↑**, 경계(텍스트) 선명도 이득.
   - 4:2:0은 **시간↓·용량↓**, 사진에 적합.
3. **Quality(Q)**
   - Q↑ → 용량↑·인코딩 시간↑가 일반적. Q=90 주변이 실무 밸런스.
4. **Optimize/Progressive**
   - Optimize ON → 용량 **2–10%↓**, 인코딩 **수 ms–수십 ms↑**
   - Progressive ON → 파일 크기 ±(씬 의존), **전송 중 시각적 체감** 개선 가능
5. **메모리**
   - WorkingSet/PrivateBytes 변화 추이로 **스케일 디코드**·**멀티스레딩**이 미치는 영향 관찰.
   - 대형 이미지 반복 시 **피크 메모리** 감시.

---

## 7. 멀티스레드 계측(선택)

- 위 단일 스레드 루프를 **워크 큐 + 워커 풀**로 바꾸면 스루풋 비교 가능
- CSV에 `thread_id`/`worker_idx`/`queue_depth` 도 함께 기록
- **주의**: 한 `tjhandle`/`cinfo`는 **스레드당 전용**(공유 금지)

---

## 8. 리눅스/맥 메모리 계측(요약)
- **Linux**: `/proc/self/status` 의 `VmRSS`, `VmHWM`, `VmSize` 파싱
- **macOS**: `task_info(mach_task_self(), MACH_TASK_BASIC_INFO, …)`

(프로젝트에서 OS 분기 전처리 후 `read_mem()` 구현을 교체)

---

## 9. 통계 요약(후처리 팁)

- CSV를 스프레드시트/파이썬으로 피벗:
  - 행: `file or group`, 열: `{scale, sampling, quality}`
  - 값: `avg(encode_ms)`, `avg(decode_ms)`, `avg(out_bytes)`
- 품질/용량 곡선을 그려서 팀 합의 프리셋(사진=420,Q=90 / UI=444,Q=92) 검증

---

## 10. 안정성 노트
- **에러 행**: `phase=decode_err / encode_err` 로 남겨 나중에 필터링
- **워밍업**: 동일 조합 첫 행은 `phase=warmup` 으로 따로 기록하는 것도 방법
- **파일 캐시 영향**: 폴더 순회를 **랜덤 셔플**해 I/O 편향 완화

---

## 11. 확장 아이디어
- **Restart rows** 를 jpeglib 경로로 주어 네트워크 견고성 모드의 시간/오버헤드 비교
- **ICC/EXIF 재주입** 케이스의 추가 오버헤드 측정
- **무손실 변환(tjTransform)** 과 재인코드의 시간/품질/용량 비교

---

## 12. 결론
- 이 벤치마크 도구로 **해상도·Q·샘플링·옵션** 조합에 대한 **객관적 수치**를 얻고,
  팀/프로젝트의 **표준 프리셋**과 **썸네일/프리뷰 경로**를 **데이터 기반**으로 정할 수 있습니다.
- 필요하시면 위 CLI를 **ImageTool**에 통합해 “**성능 프로파일러**” 창(실시간 그래프/요약 통계)을 만들어 드릴게요.
