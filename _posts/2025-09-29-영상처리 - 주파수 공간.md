---
layout: post
title: 영상처리 - 주파수 공간
date: 2025-09-29 15:25:23 +0900
category: 영상처리
---
# 주파수 공간(Frequency Domain)의 이해

## 1) 왜 주파수 공간인가?

시간 영역(time domain) 신호 \(x[n]\) 은 **시간에 따른 진폭 변화**를 보여주지만,  
주파수 공간(frequency domain)에서는 **어떤 주파수 성분**이 **얼마나**(크기/위상) 존재하는지를 드러냅니다.

- **잡음 진단**: 50/60 Hz 험(hum), 팬 노이즈, 기계 진동 주파수 탐지  
- **특징 추출**: 반복 패턴(라인스캔, 진동수)  
- **필터링 설계**: 저역/대역/고역 통과 필터 설계·검증

---

## 2) 1차원 **이산 푸리에 변환(DFT)** 이론

### 2.1 표기와 기호
- 입력: 길이 \(N\) 의 복소수 시퀀스 \(x[n]\), \(n=0,\dots,N-1\)  
- 출력: 복소수 스펙트럼 \(X[k]\), \(k=0,\dots,N-1\)  
- 표준 **비정규화(공학자 관례)**:
\[
X[k] = \sum_{n=0}^{N-1} x[n]\; e^{-j 2\pi \frac{kn}{N}},\quad k=0,\dots,N-1
\]
역변환(IDFT):
\[
x[n] = \frac{1}{N}\sum_{k=0}^{N-1} X[k]\; e^{+j 2\pi \frac{kn}{N}},\quad n=0,\dots,N-1
\]
> 위상 \( \angle X[k] = \arg(X[k])\), 크기 \( |X[k]| = \sqrt{\Re(X)^2 + \Im(X)^2} \).

### 2.2 샘플링 주파수와 실제 Hz
샘플링 주파수 \(f_s\) [Hz], 샘플 수 \(N\) 일 때 **주파수 해상도**:
\[
\Delta f = \frac{f_s}{N},\qquad f[k] = k\cdot \Delta f.
\]
- 실수(real) 입력이면 스펙트럼은 **짝대칭**: \(X[N-k]=\overline{X[k]}\).  
- **양의 주파수** 범위는 \(k=0 \ldots \lfloor N/2\rfloor\) 가 핵심(나머지는 공액 대칭).

### 2.3 스펙트럼 누설(Leakage)과 윈도(Window)
관측 길이가 유한하므로, 사실상 **문턱(사각 윈도)** 을 곱한 것과 같습니다. 사각 윈도는 **사인카(sinc)** 주엽/부엽을 만들어 **누설**을 유발합니다.  
해결책: 해밍(Hamming), 한(Hann) 등 **완만한 윈도**로 경계 불연속을 줄임.

- **Hann 창**:
\[
w[n] = 0.5\left(1-\cos\frac{2\pi n}{N-1}\right)
\]
- **Hamming 창**:
\[
w[n] = 0.54-0.46\cos\frac{2\pi n}{N-1}
\]

윈도 적용 후 \(x_w[n]=x[n]\,w[n]\) 로 DFT 수행. (크기 보정은 응용 맥락에 맞춰 선택)

### 2.4 제로패딩(Zero-padding)
데이터 뒤에 0을 붙여 \(N\) 을 키우면 주파수 격자 \(\Delta f\) 가 더 **촘촘**해져 **스펙트럼 보간** 효과(피크 주파수 파악에 유리).  
단, **해상도(분해능)** 이 늘어난 것이 아니라 **표본 간격**만 촘촘해진 점에 유의.

### 2.5 에너지/파서발( Parseval )
\[
\sum_{n=0}^{N-1} |x[n]|^2 = \frac{1}{N}\sum_{k=0}^{N-1} |X[k]|^2
\]
스케일링(정규화) 선택에 따라 상수는 달라질 수 있습니다. 본문은 **공학자 관례**(IDFT에 \(1/N\)).

---

## 3) 1차원 DFT — C++ 구현

아래는 교육/검증 용도의 **순진 DFT \(O(N^2)\)** 구현입니다.  
필요 기능:
- 순전한 **DFT/IDFT**  
- **실수 입력** 최적화(크기·위상만 보려면 실수 컨테이너로 입력 받아 복소로 승격)  
- **윈도/제로패딩** 지원 유틸  
- **주파수 축** 생성, **파워 스펙트럼**(dB) 계산

> 실전 제품에서는 반드시 **FFT**( \(O(N\log N)\) ) 를 사용하세요. 그러나 DFT는  
> (1) 참조 구현, (2) 작은 N, (3) FFT 검증에 매우 유용합니다.

```cpp
// dft1d.hpp
#pragma once
#include <vector>
#include <complex>
#include <cmath>
#include <cstdint>
#include <algorithm>
#include <stdexcept>
#include <string>

using cd = std::complex<double>;
constexpr double PI = 3.141592653589793238462643383279502884;

// ================================
// 윈도 함수들
// ================================
inline std::vector<double> window_hann(size_t N){
    std::vector<double> w(N, 1.0);
    if (N<=1) return w;
    for (size_t n=0; n<N; ++n)
        w[n] = 0.5 * (1.0 - std::cos(2.0*PI*n/(N-1)));
    return w;
}
inline std::vector<double> window_hamming(size_t N){
    std::vector<double> w(N, 1.0);
    if (N<=1) return w;
    for (size_t n=0; n<N; ++n)
        w[n] = 0.54 - 0.46*std::cos(2.0*PI*n/(N-1));
    return w;
}
inline void apply_window_inplace(std::vector<double>& x, const std::vector<double>& w){
    if (x.size()!=w.size()) throw std::runtime_error("window size mismatch");
    for (size_t n=0;n<x.size();++n) x[n]*=w[n];
}

// ================================
// 제로패딩 유틸
// ================================
inline std::vector<double> zeropad(const std::vector<double>& x, size_t Npad){
    std::vector<double> y(Npad, 0.0);
    std::copy(x.begin(), x.begin()+std::min(x.size(), Npad), y.begin());
    return y;
}

// ================================
// 주파수 축(Hz) 생성
// fs: sampling rate [Hz], N: DFT length
// halfOnly=true면 0..N/2 까지만 반환(실수 입력 분석에 유용)
// ================================
inline std::vector<double> freq_axis(size_t N, double fs, bool halfOnly=true){
    size_t K = halfOnly ? (N/2 + 1) : N;
    std::vector<double> f(K);
    double df = fs / double(N);
    for (size_t k=0;k<K;++k) f[k]=k*df;
    return f;
}

// ================================
// DFT / IDFT (공학자 스케일: IFFT에 1/N)
// 입력: 복소수 벡터 x (size N)
// 출력: 복소수 벡터 X (size N)
// ================================
inline std::vector<cd> dft(const std::vector<cd>& x){
    const size_t N = x.size();
    std::vector<cd> X(N);
    for (size_t k=0;k<N;++k){
        cd acc = 0.0;
        double angk = -2.0*PI*double(k)/double(N);
        for (size_t n=0;n<N;++n){
            double ang = angk * double(n);
            acc += x[n] * cd(std::cos(ang), std::sin(ang));
        }
        X[k] = acc;
    }
    return X;
}

inline std::vector<cd> idft(const std::vector<cd>& X){
    const size_t N = X.size();
    std::vector<cd> x(N);
    for (size_t n=0;n<N;++n){
        cd acc = 0.0;
        double angn = +2.0*PI*double(n)/double(N);
        for (size_t k=0;k<N;++k){
            double ang = angn * double(k);
            acc += X[k] * cd(std::cos(ang), std::sin(ang));
        }
        x[n] = acc / double(N);
    }
    return x;
}

// ================================
// 실수 입력용 헬퍼 (double -> complex 승격)
// ================================
inline std::vector<cd> promote_real(const std::vector<double>& xr){
    std::vector<cd> xc(xr.size());
    for (size_t i=0;i<xr.size();++i) xc[i]=cd(xr[i], 0.0);
    return xc;
}

// ================================
// 크기/전력 스펙트럼
// power=true면 |X|^2, false면 |X|
// halfOnly=true면 0..N/2 반환(실수 입력 전제)
// scaleAmp는 원하는 스케일(예: 2/N) 지정 가능(진폭 보정)
// ================================
inline std::vector<double> spectrum_mag(const std::vector<cd>& X,
                                        bool halfOnly=true,
                                        bool power=false,
                                        double scaleAmp=1.0)
{
    const size_t N = X.size();
    size_t K = halfOnly ? (N/2 + 1) : N;
    std::vector<double> M(K);
    for (size_t k=0;k<K;++k){
        double mag = std::abs(X[k]);
        if (power) mag = mag*mag;
        M[k] = scaleAmp * mag;
    }
    return M;
}
inline std::vector<double> spectrum_db(const std::vector<double>& mag, double ref=1.0){
    std::vector<double> db(mag.size());
    for (size_t i=0;i<mag.size();++i){
        double v = mag[i] / ref;
        if (v<=0) db[i] = -120.0; // floor
        else      db[i] = 20.0*std::log10(v);
    }
    return db;
}

// ================================
// FFT-Shift(중심정렬)가 필요한 경우(교육용)
// 여기서는 halfOnly 분석을 권장하므로 옵션용으로 제공
// ================================
inline void fftshift_inplace(std::vector<cd>& X){
    size_t N = X.size();
    size_t h = N/2;
    if (N%2==0){
        for (size_t i=0;i<h;++i) std::swap(X[i], X[i+h]);
    } else {
        // odd: rotate by (h+1)
        std::rotate(X.begin(), X.begin()+h+1, X.end());
    }
}
```

---

## 4) 예제 ①: **두 개의 정현파** + DC 오프셋

### 4.1 신호 구성
- 샘플링: \(f_s = 16\,\text{kHz}\)  
- 길이: \(N=1024\) (약 64 ms)  
- 성분:  
  - \(x_1[n]=0.8\sin(2\pi\cdot1000\,n/f_s)\)  
  - \(x_2[n]=0.4\cos(2\pi\cdot2500\,n/f_s)\)  
  - DC \(= 0.2\)

### 4.2 구현 및 분석

```cpp
// example1_sine_mix.cpp
#include <iostream>
#include "dft1d.hpp"

int main(){
    const double fs = 16000.0;
    const size_t N  = 1024;

    // 1) 신호 생성
    std::vector<double> x(N, 0.0);
    for (size_t n=0;n<N;++n){
        double t = double(n)/fs;
        x[n]  = 0.8*std::sin(2.0*PI*1000.0*t);
        x[n] += 0.4*std::cos(2.0*PI*2500.0*t);
        x[n] += 0.2; // DC offset
    }

    // 2) (옵션) 창: Hann → 누설 완화
    auto w = window_hann(N);
    auto xw = x; apply_window_inplace(xw, w);

    // 3) DFT
    auto X  = dft(promote_real(xw));

    // 4) 양의 주파수 크기 스펙트럼
    // 윈도를 썼으므로 절대 진폭 해석엔 창 보정이 필요하지만 여기선 예시 스케일만.
    // 진폭을 직관적으로 보기 위해 2/N 스케일(단, DC/나이퀴스트는 제외)이 흔히 쓰임.
    double scale = 2.0 / double(N);
    auto mag = spectrum_mag(X, /*halfOnly=*/true, /*power=*/false, scale);

    // 5) 주파수 축
    auto f = freq_axis(N, fs, /*halfOnly=*/true);

    // 6) 간단 출력: 상위 피크 몇 개
    struct Peak{ double f; double a; size_t k; };
    std::vector<Peak> peaks;
    for (size_t k=1;k<mag.size()-1;++k){
        if (mag[k]>mag[k-1] && mag[k]>mag[k+1])
            peaks.push_back({f[k], mag[k], k});
    }
    std::sort(peaks.begin(), peaks.end(), [](auto& a, auto& b){return a.a>b.a;});

    std::cout << "Top peaks (Hz, amplitude, bin):\n";
    for (size_t i=0;i<std::min<size_t>(peaks.size(), 5); ++i){
        std::cout << i+1 << ") " << peaks[i].f << " Hz, " << peaks[i].a
                  << ", k=" << peaks[i].k << "\n";
    }
    // 기대값: 약 1000 Hz, 2500 Hz, 그리고 DC 성분(0 Hz)
}
```

#### 해석 포인트
- **DC** 성분은 \(k=0\) (0 Hz) 부근에서 크기가 큼.  
- **1000 Hz** 는 \(k \approx 1000\cdot N/f_s = 64\)  
- **2500 Hz** 는 \(k \approx 160\)  
- 정수 bin에 정확히 맞지 않으면 **누설**로 피크가 퍼집니다(윈도로 완화).

---

## 5) 예제 ②: **직사각(펄스) 신호** — sinc 스펙트럼

폭 \(T_p\) 인 직사각 파형은 주파수에서 **sinc** 패턴의 **주엽·부엽**을 보입니다.

\[
x(t) = \begin{cases}
1, & 0\le t < T_p \\
0, & \text{else}
\end{cases}
\quad\Rightarrow\quad
|X(f)| \propto T_p\,\left|\frac{\sin(\pi f T_p)}{\pi f T_p}\right|.
\]

샘플 도메인에서는 유사하게 sinc 형태가 관찰되며, 관측 길이 \(N\) 과 정렬 여부에 따라 누설이 달라집니다.

```cpp
// example2_rect_pulse.cpp
#include <iostream>
#include "dft1d.hpp"

int main(){
    const double fs = 8000.0;
    const size_t N  = 512;

    // 1) 폭 10 ms 펄스 (80샘플)
    size_t width = size_t(0.010 * fs);
    std::vector<double> x(N, 0.0);
    for (size_t n=0; n<std::min(width,N); ++n) x[n]=1.0;

    // 2) 윈도: 여기선 사각 그대로(누설 현상 관찰 목적)
    // 3) 제로패딩으로 스펙트럼 표본 간격을 촘촘히 (보간 관찰)
    size_t Npad = 2048;
    auto xp = zeropad(x, Npad);

    // 4) DFT
    auto X = dft(promote_real(xp));
    auto mag = spectrum_mag(X, /*halfOnly=*/true, /*power=*/false, /*scaleAmp=*/1.0);

    auto f = freq_axis(Npad, fs, /*halfOnly=*/true);

    // 5) 일부 샘플 출력
    std::cout<<"f(Hz), |X|\n";
    for (size_t k=0; k<mag.size(); k+=32){
        std::cout << f[k] << "," << mag[k] << "\n";
    }
    // 그래프에 그리면 중앙 주엽과 좌우 sinc 부엽이 관찰됩니다.
}
```

---

## 6) 스펙트럼 스케일링 & 해석 팁

- **진폭 보정**: 실수 신호의 양의 주파수만 볼 때, 일반적으로 `2/N` 스케일을 곱해 **단일 톤의 실효 진폭**을 직관적으로 보정합니다.  
  단, \(k=0\)(DC) 와 \(k=N/2\) (짝수 N의 나이퀴스트) 에는 **2배를 적용하지 않는** 관례가 많습니다.

- **파워 스펙트럼(PSD)**:  \( |X[k]|^2 \) 를 사용하고 필요시 \(1/N\) 또는 \(1/N^2\) 등의 정규화(파서발과 일관되게)를 적용합니다.

- **윈도 영향**: 창에 따라 부엽 레벨(다이내믹 레인지)과 주엽 폭(분해능)이 trade-off.  
  - Hann: 누설 억제 좋음(부엽 낮음), 주엽 폭은 약간 넓음.  
  - Rect(사각): 분해능은 좋지만 누설 큼.

- **제로패딩**: peak 주파수 위치를 더 세밀하게 **추정**하는 데 유용하지만, **실제 분해능** 향상은 아님.

---

## 7) (보너스) 실수 입력의 **대칭성** 활용과 최적화

실수 \(x[n]\) 에 대해
\[
X[N-k] = \overline{X[k]}
\]
이므로, \(k=0..N/2\) 만 계산하고 나머지를 채우는 **절반 계산** 최적화가 가능합니다.  
순진 DFT에서는 간단히 구현하기 어렵지 않지만, 실무에서는 FFT 라이브러리(예: real-FFT) 사용을 권장합니다.

---

## 8) (보너스) FFT에 대한 간단한 언급

- **DFT**: \(O(N^2)\)  
- **FFT**: 대표적으로 Cooley–Tukey, \(O(N\log N)\)  
- 큰 \(N\) 또는 실시간 처리(오디오, 센서)에서는 **필수**.  
- 본문 DFT는 **참조/검증**·**작은 N 교육**에 적합.

---

## 9) 실전 시나리오

### 시나리오 A) 오디오에서 **전원 험(50/60 Hz)** 검출
- 입력: 오디오 버퍼(48 kHz), 길이 4096 샘플  
- 처리: Hamming 윈도 → DFT → 50/60Hz±Δf 근처 피크 탐지  
- 대응: notch 필터 설계 또는 해당 주파수 대역 감쇠

### 시나리오 B) 공정 설비의 **진동 진단**
- 입력: 가속도 센서(10 kHz), 길이 8192 샘플  
- 처리: Hann → 제로패딩(32k) → DFT → 회전 부품의 정수 배 하모닉 탐지  
- 결과: 특정 rpm(Hz) 및 베어링 결함 주파수 추정

### 시나리오 C) 라인스캔 영상의 **주기 패턴** 추출
- 1차원화된 라인 프로파일 \(x[n]\) 의 DFT → **주기 길이** \(P = f_s / f_\text{peak}\) 추정  
- 격자 스크래치/모아레 분석에 유용

---

## 10) 단위/정렬 관련 자주 하는 실수 (FAQ)

1) **주파수 인덱스 → Hz**: \(f[k]=k\cdot f_s/N\). halfOnly를 쓰면 \(k=0..N/2\) 가 양의 주파수.  
2) **픽셀 중심? 필요없음**: 1D DFT는 이산 표본 인덱스 기반이라 픽셀 센터 보정이 없습니다.  
3) **위상 반전**: 콤플렉스 지수의 부호(전방 -, 역방 +)를 뒤바꾸거나, 스케일(1/N) 위치를 바꾸면 위상이 뒤틀릴 수 있습니다.  
4) **윈도 보정**: 진폭을 절대값으로 해석할 때는 창의 **등가 잡음 대역폭(ENBW)** 나 합계 보정이 필요할 수 있습니다(응용에 따라 선택).

---

## 11) 마무리

- 본 절에서는 1차원 **DFT/IDFT** 를 **직접 구현**하고, 스펙트럼 해석의 **핵심 개념**(누설·윈도·제로패딩·대칭)을 다뤘습니다.  
- 실제 시스템에서는 **FFT**를 쓰되, DFT 구현은 **정확성 검증 기준**으로 중요합니다.

---

## 부록 A | 간단한 유닛 테스트 스니펫

```cpp
// test_dft_basic.cpp
#include <cassert>
#include <iostream>
#include "dft1d.hpp"

int main(){
    // 1) 역변환 정확도: dft -> idft == 원본
    size_t N=16;
    std::vector<cd> x(N);
    for (size_t n=0;n<N;++n) x[n]=cd(std::sin(2*PI*n/N), std::cos(2*PI*3*n/N));

    auto X = dft(x);
    auto xr= idft(X);

    double err=0;
    for (size_t n=0;n<N;++n) err = std::max(err, std::abs(x[n]-xr[n]));
    std::cout<<"max recon error="<<err<<"\n";
    assert(err < 1e-10);

    // 2) 단일 톤 위치 테스트
    const double fs=8000.0; N=64;
    std::vector<double> s(N);
    for (size_t n=0;n<N;++n){
        s[n]=std::sin(2*PI*1000.0*(double)n/fs); // k= N*1000/fs = 8
    }
    auto SX = dft(promote_real(s));
    auto mag = spectrum_mag(SX,true,false,2.0/double(N));
    size_t kpeak = std::max_element(mag.begin(), mag.end()) - mag.begin();
    std::cout<<"peak bin="<<kpeak<<" (expect 8)\n";
    assert(kpeak==8);
}
```

---

## 부록 B | 수학 요약(참고)

- **DFT 행렬** \( \mathbf{F} \in \mathbb{C}^{N\times N} \):
\[
F_{k,n} = e^{-j 2\pi \frac{kn}{N}}, \quad
\mathbf{X} = \mathbf{F}\mathbf{x}, \quad
\mathbf{x} = \frac{1}{N}\mathbf{F}^{\!*}\mathbf{X},
\]
여기서 \( \mathbf{F}^{\!*} \) 는 켤레 전치.

- **윈도 후 DFT**:
\[
X_w[k] = \sum_{n=0}^{N-1} x[n]\,w[n]\;e^{-j2\pi kn/N}.
\]

- **파서발**:
\[
\sum_n |x[n]|^2 = \frac{1}{N}\sum_k |X[k]|^2.
\]

---

### 요약
- DFT는 “**시간 → 주파수**” 로의 기초적인 창입니다.  
- **누설, 윈도, 제로패딩, 스케일링** 을 이해하면 실전 해석력이 급상승합니다.  
- 본문의 C++ 구현은 **검증·교육**·**소규모 데이터**에 적합하며, 실제 제품에서는 FFT로 확장하세요.