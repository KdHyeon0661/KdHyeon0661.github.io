---
layout: post
title: 컴퓨터시스템 - 배열의 할당과 접근
date: 2025-07-26 15:20:23 +0900
category: 컴퓨터시스템
---
# 배열의 할당과 접근 (Array Allocation and Access)

## 한눈에 보는 핵심

| 주제 | 요약 |
|---|---|
| **연속성** | 배열은 **동일 타입** 요소가 **연속적**(contiguous)으로 배치 |
| **주소계산** | $$ \text{addr}(a[i]) = \text{base}(a) + i \cdot \mathrm{sizeof}(T) $$ |
| **포인터 등가** | `a[i] ≡ *(a + i)` (단, 배열명은 **포인터가 아님**; 표현·전달에서 “감소(decay)”됨) |
| **다차원** | C는 **row-major**: $$\text{addr}(a[i][j]) = \text{base} + (i \cdot N + j)\cdot s$$ |
| **함수 인자** | `T arr[]` 파라미터 ≡ `T* arr` (크기 정보 소실 → 길이를 추가로 전달) |
| **스택/힙/정적** | 자동(스택), 동적(힙), 정적(.data/.bss) 저장기간 별 특성·수명·초기화 차이 |
| **경계검사** | C는 **경계검사 미실시** → UB/보안 취약점 위험 |
| **성능** | 연속성 = **공간 지역성(spatial locality)** → 캐시 친화, SoA/AoS, 정렬·벡터화가 관건 |

---

## 선언·저장기간·초기화

### 선언과 크기

```c
int a[5];          // 5개 int, 연속 20바이트 (LP64에서 int=4)
double v[3] = {1.0, 2.0}; // [1.0, 2.0, 0.0]으로 자동 0 초기화
```

- **정적 저장기간**(파일/함수-스코프 `static`)은 **0 초기화**:
```c
static int b[4]; // 모두 0으로 초기화(.bss)
```

- **자동 저장기간**(스택)은 **초기화되지 않음**:
```c
void f(void){ int x[4]; /* indeterminate */ }
```

### `sizeof`의 의미(배열 vs 포인터)

```c
int a[3];
int *p = a;

printf("%zu %zu\n", sizeof(a), sizeof(p)); // 12, 8 (LP64)
```

- `sizeof(배열식)` = **배열 전체 바이트 수**
- `sizeof(포인터)` = **포인터 크기** (LP64에서 8)

---

## 주소계산과 포인터 연산 (정의와 수식)

### 1차원

배열 원소 타입 크기를 \(s=\mathrm{sizeof}(T)\), 시작주소를 \(B\)라 하면
$$
\text{addr}(a[i]) = B + i\cdot s \quad (0 \le i < N).
$$

C 표현:
```c
a[i]      /* == * (a + i) */
*(a + i)  /* == *(i + a) (교환법칙 성립) */
```

### 다차원 (row-major)

열 수 \(N\), 원소 크기 \(s\):
$$
\text{addr}(a[i][j]) = B + (i\cdot N + j)\cdot s.
$$

C의 포인터 등가:
```c
a[i][j]        /* == *(*(a + i) + j) */
```

> 주의: `int **`는 `int [][N]`과 **동일하지 않다**(2단계 포인터 트리 vs 연속 블록).

---

## 어셈블리 관점: 주소지정 모드와 예제

### x86-64 AT&T 예

```c
// C
void set2(int *a) { a[2] = 10; }
```

가능한 컴파일 결과(개념):

```asm
# %rdi = a

set2:
    movl    $10, 8(%rdi)     # 2 * sizeof(int) = 8 바이트 오프셋
    ret
```

스케일링 주소지정:
```asm
movl    %edx, (%rdi,%rsi,4)  # a[rsi] = edx (int: 4배 스케일)
```

### 인덱스 계산(2D)

```c
int get(int (*m)[5], int i, int j){ return m[i][j]; }
```

어셈블리(개념):
```asm
# rdi = m, esi = i, edx = j

leaq    (%rsi, %rsi, 4), %rax   # rax = i*5 (i + i*4)
leaq    (%rdi, %rax, 4), %rcx   # rcx = base + i*5*4
movl    (%rcx,%rdx,4), %eax     # eax = *(rcx + j*4)
ret
```

---

## 배열과 포인터: “감소(decay)”와 차이

### 함수 인자로의 **감소**

```c
void f(int a[]);     // == void f(int *a);
void g(int (*a)[5]); // "행 포인터": 한 행 단위로 점프
```

- `int a[]` 파라미터는 **크기 정보 소실** → 길이를 따로 전달
- 다차원 전달 시, **두 번째 차원부터는 반드시 명시**:
```c
void h(int m[][5], int rows);   // OK
void wrong(int **m);            // 2D 연속배열과 의미 다름
```

### 포인터 vs 배열 포인터

```c
int  (*p)[5]; // "int[5]"를 가리키는 포인터
int  *q;      // int 원소를 가리키는 포인터

p++; // 5개 int(20바이트) 만큼 전진
q++; // 1개 int(4바이트) 만큼 전진
```

---

## 스택/힙/정적: 저장기간·수명·초기화

### 스택(자동)

```c
void foo(void){
    int a[100]; // 약 400B, 함수 종료 시 파괴
}
```

- 빠르지만 크기 제한, **주소 반환 금지**(댕글링 방지)

### 힙(동적)

```c
int *a = malloc(sizeof *a * 100);
if (!a) { /* handle */ }
/* ... */
free(a);
```

- **수동 해제** 필요, 실패 처리 필수
- **오버플로 방지**: 크기 계산 시 곱셈 overflow 점검:
```c
size_t n = /* ... */;
if (n > SIZE_MAX / sizeof *a) fail();
int *a = malloc(n * sizeof *a);
```

- **`calloc`**: 0 초기화 + overflow 검사에 유리

### 정적(파일/블록 `static`)

```c
static int a[1000]; // .bss (0 초기화), 프로그램 전체 수명
```

---

## 다차원과 동적 할당의 바른 방법

### 연속 2D 블록 (권장)

```c
int rows = 3, cols = 4;
int (*m)[4] = malloc(rows * sizeof *m); // rows x 4 연속블록
m[2][3] = 7;
/* ... */
free(m);
```

- **장점**: 진짜 2D 연속 → 캐시 친화·단일 free
- **단점**: 열 크기 `4`가 형에 고정

### — “단일 블록” 패턴

```c
int rows = R, cols = C;
int *blk = malloc((size_t)rows * cols * sizeof *blk);
int **ptr = malloc(rows * sizeof *ptr);
for (int i = 0; i < rows; ++i) ptr[i] = blk + (size_t)i * cols;

ptr[2][3] = 7;
/* ... */
free(ptr);
free(blk);
```

- **주의**: `ptr`은 포인터 배열(행 포인터), 실제 데이터는 `blk`(연속)

### 잘못된 “`int**`만 할당” 패턴

```c
// 흔한 오해: 아래는 "연속 2D"가 아님(행마다 제각각 할당)
int **bad = malloc(R * sizeof *bad);
for (int i=0;i<R;++i)
    bad[i] = malloc(C * sizeof *bad[i]);
```

- **단점**: 비연속, 할당/해제 비용↑, 캐시 비우호

---

## VLA(Variable Length Array)와 제약

- C99 도입, C11부터 **옵션**. 일부 컴파일러/옵션에서 비활성.
- **스택**에 런타임 크기의 배열을 구성:
```c
void f(int n){
    int a[n];    // VLA
    /* ... */
}
```

- 장단점: 간결/자동해제 vs 스택폭탄 위험, 이식성/옵션 의존
- 함수 파라미터로도 가능:
```c
void g(int r, int c, int m[r][c]);
```

---

## 유연 배열 멤버(FAM)와 레이아웃

```c
struct buf {
    size_t len;
    unsigned char data[]; // FAM (마지막 멤버)
};

struct buf *b = malloc(sizeof *b + payload);
b->len = payload;
/* ... b->data[0..payload-1] ... */
free(b);
```

- **마지막 멤버만** 허용, `sizeof(struct buf)`에는 `data` 크기 불포함

---

## vs 배열 분할(SoA)과 캐시

### AoS

```c
typedef struct { float x,y,z; } P;
P pts[N];
```

- 서로 다른 필드에 간헐적 접근 시 **낭비** 가능

### SoA

```c
typedef struct { float *x, *y, *z; } Psoa;
Psoa a = { malloc(N*sizeof* a.x),
           malloc(N*sizeof* a.y),
           malloc(N*sizeof* a.z) };
```

- 특정 필드 집약 연산(예: `x[i]+=...`)에 **캐시 우호**
- 단점: 관리 비용↑, 포인터 3개

### 정렬과 패딩, stride

```c
typedef struct { char c; int x; } S; // 패딩 발생 (정렬=4)
S arr[100]; // stride=sizeof(S)
```

- 연속 배열의 **stride**(요소 간 간격)는 `sizeof(T)`
- 불필요한 패딩은 **메모리 대역/캐시** 낭비 → 필드 재배치로 최소화

---

## 성능: 캐시·지역성·프리패치·벡터화

### 지역성

- **공간 지역성**: 연속 접근이 유리(배열의 핵심 강점)
- **시간 지역성**: 자주 쓰는 데이터는 레지스터/캐시에 유지

### 순회 패턴의 중요성 (행 우선)

```c
// 올바름(행 우선)
for (int i=0;i<R;++i)
  for (int j=0;j<C;++j)
    sum += a[i][j];

// 비우호(열 우선)
for (int j=0;j<C;++j)
  for (int i=0;i<R;++i)
    sum += a[i][j];
```

- 같은 데이터라도 **접근 순서**가 성능을 좌우

### 벡터화·정렬

- 컴파일러는 `-O3 -march=native` 등으로 **SIMD 벡터화**
- **정렬된 시작 주소**가 유리: `aligned_alloc(64, n*64)` 등
- `restrict`로 **비별칭** 보장 시 최적화 향상:
```c
void axpy(size_t n, float a, float *restrict x, float *restrict y){
    for(size_t i=0;i<n;++i) y[i]+=a*x[i];
}
```

---

## 안전성: 경계·UB·진단

### 경계검사 없음 → UB

```c
int a[5];
a[10] = 123; // UB: 런타임/보안 취약점
```

- 완화책: **사전 검사**, 테스트 시 **ASan/UBSan**, 배포 시 **canary/stack protector**
- 라이브러리 함수 사용 시 길이 인자 철저 관리

### 유효 포인터 범위

- 포인터 연산은 **같은 배열 객체 안**(또는 **한 칸 뒤**)에서만 정의
- 다른 배열 사이 산술은 UB

---

## 문자열과 배열

```c
char s1[6] = "hello"; // {'h','e','l','l','o','\0'}
char *s2 = "hello";   // 읽기전용(리터럴) 메모리 가리킴(수정 금지)
```

- 문자열 처리 시 **널 종료**(`'\0'`) 필수
- **버퍼 길이 기반 API** 우선

---

## 실전: 알고리즘과 배열

### 정렬·탐색

- **퀵/머지/힙** 등: 연속 배열의 **캐시 우위**
- 인덱스 기반 접근의 상수 계수 작은 장점

### 슬라이딩 윈도우(연속 접근)

```c
int sumk(const int *a, int n, int k){
    int s=0; for(int i=0;i<k;++i) s+=a[i];
    int best=s;
    for(int i=k;i<n;++i){ s+=a[i]-a[i-k]; if(s>best) best=s; }
    return best;
}
```

---

## 컴파일러가 만드는 주소계산: 공식 재확인

- 1D:
  $$ \text{addr}(a[i]) = B + i\cdot s $$
- 2D(row-major, 열수 \(N\)):
  $$ \text{addr}(a[i][j]) = B + (i\cdot N + j)\cdot s $$
- 포인터 등가:
  $$ a[i] \equiv * (a + i),\quad a[i][j] \equiv * ( *(a+i) + j ) $$

---

## 종합 예제

### 안정적 2D 합계 (연속 블록 + 행 우선)

```c
#include <stdio.h>
#include <stdlib.h>

long sum2d(size_t rows, size_t cols){
    long (*m)[/* cols */] = malloc(rows * sizeof *m); // 컴파일 타임 cols 필요 시 VLA 사용
    if(!m) return -1;

    // 예: 초기화
    for(size_t i=0;i<rows;++i)
        for(size_t j=0;j<cols;++j)
            m[i][j] = (long)(i*cols + j);

    long s=0;
    for(size_t i=0;i<rows;++i)
        for(size_t j=0;j<cols;++j)
            s += m[i][j];

    free(m);
    return s;
}

int main(void){
    size_t R=2, C=3;
    printf("%ld\n", sum2d(R,C)); // 0+1+2+3+4+5 = 15
    return 0;
}
```

> 컴파일러/옵션 따라 VLA 지원 여부가 다르므로, **런타임 cols**라면 §6.2 패턴(단일 블록 + 행 포인터) 추천.

### SoA 가속 예시(한 축만 집약 접근)

```c
#include <stdlib.h>
#include <stddef.h>

typedef struct { float *x, *y, *z; } V3soa;

void saxpy(size_t n, float a, const V3soa *v, float *restrict out){
    for(size_t i=0;i<n;++i)
        out[i] = a*v->x[i] + v->y[i]; // z는 이번 단계 미사용 → SoA 유리
}
```

---

## 체크리스트(실무 지향)

- [ ] 배열/포인터 혼동 금지: `sizeof`, 함수 파라미터 의미 점검
- [ ] 2D는 **연속 블록** 또는 **행 포인터 + 단일 블록** 채택
- [ ] 경계·오버플로 검사: 길이 기반 루프, `calloc`, 곱셈 overflow 점검
- [ ] 캐시·접근 순서 고려: **행 우선**, stride 최소화
- [ ] 정렬·벡터화: 정렬된 할당, `restrict` 사용, `-O3 -march=native`
- [ ] 저장기간에 맞는 수명 관리: 스택(자동), 힙(해제), 정적(0 초기화)
- [ ] ASan/UBSan, `-fstack-protector-strong`로 테스트

---

## 연습문제

1) `int a[5];`에서 `a`의 타입과 `&a`의 타입을 각각 설명하고, `a+1`과 `&a+1`의 주소 차이를 구하라.
2) `int m[3][4];`일 때 `&m[1][2]` 주소를 **기저주소 B**와 **원소 크기 s**로 표현하라.
3) “연속 2D”와 “`int**` 행-별 할당”의 장단점을 캐시 관점에서 비교하라.
4) VLA를 사용하는 함수 시그니처 `void f(int r, int c, int m[r][c])`를 이용해 행 우선 합계를 구현하라.

---

## 결론

배열은 C에서 “가장 단순하지만 가장 빠른” 자료구조다.
**연속성** 덕분에 주소계산이 단순하고 캐시 효율이 뛰어나며, 어셈블리 차원에서 명확하게 **스케일 주소지정**으로 매핑된다. 반면 경계검사 부재로 인해 안전성에는 각별한 주의가 필요하다. 스택/힙/정적·VLA/FAM·AoS/SoA 등 **문맥별 올바른 설계 선택**과 **접근 순서/정렬/벡터화** 최적화를 결합하면, 동일한 알고리즘도 **몇 배**의 성능 차이를 낼 수 있다.

---

```c
/* 부록: 안전한 realloc 패턴 */
void *xrealloc(void *p, size_t n, size_t sz){
    if (sz && n > SIZE_MAX / sz) return NULL; // overflow
    void *q = realloc(p, n*sz);
    return q; // 실패 시 원본 p 유지(호출자가 보유)
}
```

```asm
# - rdi=a, esi=i, edx=v
# a[i] = v

leal    0(,%rsi,4), %ecx   # ecx = i*4
movl    %edx, (%rdi,%rcx)  # *(a + i) = v
```

$$
\text{addr}(a[i]) = B + i \cdot \mathrm{sizeof}(\text{int})
$$
