---
layout: post
title: 컴퓨터시스템 - 배열의 할당과 접근
date: 2025-07-26 15:20:23 +0900
category: 컴퓨터시스템
---
# 🧠 배열의 할당과 접근 (Array Allocation and Access)

배열(array)은 메모리에서 연속된 공간에 데이터를 저장하는 대표적인 자료구조이다. 컴퓨터 시스템은 배열을 매우 단순하게 취급하지만, 고급 언어에서 추상화된 배열 접근은 컴파일러에 의해 기계 수준에서 특정 주소로 변환되어 동작한다.

본 문서에서는 C 언어 기준으로 배열의 선언, 메모리 할당, 접근, 포인터 연산, 다차원 배열 등에 대해 CS:APP 관점에서 매우 자세히 다룬다.

---

## 1. 배열의 기본 개념

배열은 동일한 타입의 데이터를 일정한 순서로 저장하기 위한 **연속적인 메모리 공간**이다.

### 📌 C에서의 배열 선언

```c
int a[5]; // 정수형 배열 5개 요소
```

해당 선언은 `int` 타입의 메모리 공간 4바이트 × 5 = 20바이트를 연속적으로 할당한다.

---

## 2. 배열과 메모리 주소

### 📌 주소 계산 방식

컴파일러는 배열 접근 시 아래의 계산을 수행하여 실제 메모리 주소를 계산한다.

```text
a[i] = *(a + i)
```

배열 이름 `a`는 배열의 시작 주소를 가리킨다. `a[i]`는 `*(a + i)`로 해석되며, `i`는 **타입 크기를 고려한 오프셋**이다.

### 📌 예제

```c
int a[5];
a[2] = 10;
```

- 배열 `a`의 시작 주소가 `0x1000`이라면:
- `a[2]`는 `0x1000 + (2 * 4) = 0x1008` 위치를 의미함.

---

## 3. 배열과 포인터

### 📌 배열 이름은 포인터처럼 사용된다

배열 이름 `a`는 사실상 `int*` 타입으로 해석될 수 있으며, 컴파일러는 이를 배열 첫 요소의 주소로 간주한다.

```c
int a[3] = {1, 2, 3};
printf("%d\n", *(a + 1)); // 2 출력
```

### 📌 차이점: 배열 vs 포인터

```c
int a[3];
int *p = a;

sizeof(a);  // 12 (배열 전체 크기)
sizeof(p);  // 8  (포인터 크기, 64비트 기준)
```

배열은 메모리 공간을 포함하지만, 포인터는 해당 공간을 가리킬 뿐이다.

---

## 4. 다차원 배열

### 📌 선언

```c
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

이 배열은 총 2 × 3 = 6개의 `int` 값(24바이트)을 연속적으로 저장한다.

### 📌 메모리 구조

```
row-major 방식:
[1][2][3][4][5][6]
```

즉, `matrix[1][2]`는 메모리 상에서 5번째 요소이다.

### 📌 주소 계산

```
matrix[i][j] = *(matrix[0] + i * 3 + j)
```

혹은 2차 포인터 `*(*(matrix + i) + j)` 형태로 접근할 수도 있다.

---

## 5. 함수 인자와 배열

### 📌 배열을 함수 인자로 넘기기

```c
void print_arr(int arr[], int n) {
    for (int i = 0; i < n; ++i)
        printf("%d ", arr[i]);
}
```

- `int arr[]`는 사실상 `int* arr`로 전달됨
- 배열 크기 정보는 전달되지 않음 → 반드시 크기를 따로 전달해야 함

---

## 6. 배열과 스택 / 힙

### 📌 스택에 할당된 배열

```c
void foo() {
    int a[100]; // 스택에 400바이트 할당
}
```

함수 호출 시 스택 프레임에 배열이 생성되고, 함수 종료 시 소멸된다.

### 📌 힙에 할당된 배열

```c
int* a = malloc(sizeof(int) * 100);
```

- 런타임 시 동적으로 400바이트 할당
- `free(a);`를 호출해야 메모리 누수 방지

---

## 7. 배열 인덱싱의 기계수준 표현

### 📌 어셈블리 관점의 배열 접근

```c
int a[5];
a[2] = 10;
```

- `a`의 주소를 `rdi`에 담았다고 가정
- `a[2]` → `movl $10, 8(%rdi)` (32비트 정수, 오프셋 8바이트)

---

## 8. 경계 검사 미지원

C에서는 배열 접근 시 경계 검사를 하지 않는다.

```c
int a[5];
a[10] = 100; // 컴파일 에러 없음 → 런타임 오류 또는 undefined behavior
```

따라서 `buffer overflow`와 같은 보안 취약점이 발생할 수 있다.

---

## 9. 문자열과 배열

```c
char str[6] = "hello";
```

- 문자열은 `char` 배열로 구현됨
- 마지막에는 null 문자 `'\0'`이 들어가야 함 → `6`바이트 필요

### 📌 문자열은 포인터로도 표현됨

```c
char *msg = "hello";
```

- `"hello"`는 읽기 전용 메모리 영역(텍스트 섹션)에 저장됨
- `msg`는 해당 위치를 가리킴

---

## 10. 배열과 구조체의 차이

### 📌 배열

- 메모리상에 **동일한 타입**을 **연속적으로** 저장
- 인덱스로 접근

### 📌 구조체

- **서로 다른 타입**을 포함 가능
- 필드 이름으로 접근

```c
struct Point {
    int x;
    int y;
};

struct Point p;
p.x = 10;
```

---

## 11. 다차원 배열과 포인터 연산

```c
int matrix[4][5];
matrix[2][3] = 7;
```

- 주소 계산: `matrix + 2` → 세 번째 행의 시작 주소
- `*(matrix + 2) + 3` → 세 번째 행의 네 번째 요소

---

## 12. 배열 파라미터와 포인터 파라미터

```c
void print_matrix(int m[4][5]);     // OK
void print_matrix(int (*m)[5]);     // 동일한 의미
```

→ 배열 크기는 고정이어야 하며, 다차원 배열일 경우 **두 번째 크기부터 명시**해야 주소 계산이 가능함.

---

## 13. 다차원 배열의 메모리 레이아웃

```c
int a[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

### 📌 메모리:

```
[1][2][3][4][5][6] (row-major order)
```

---

## 14. 배열과 함수 호출 시의 포인터 연산

```c
void fill(int* a, int n) {
    for (int i = 0; i < n; i++)
        a[i] = i;
}
```

→ `a[i]`는 `*(a + i)`로 컴파일됨.

---

## 15. 배열 초기화

```c
int a[5] = {1, 2}; // 나머지는 0으로 초기화됨
```

- `{1, 2, 0, 0, 0}`

---

## 16. 배열과 정렬, 탐색 등 알고리즘

배열은 다양한 알고리즘(정렬, 탐색, 슬라이딩 윈도우 등)에서 핵심 자료구조로 사용된다. 배열은 인덱스 기반 접근이 빠르므로 CPU 캐시와 함께 성능 최적화에 유리하다.

---

## ✅ 정리

| 항목 | 설명 |
|------|------|
| 배열 이름 | 시작 주소를 가리키는 포인터 |
| 배열 접근 | 포인터 연산과 동일 |
| 다차원 배열 | row-major 방식 |
| 함수 전달 | 포인터로 전달됨 |
| 주소 계산 | `a + i * sizeof(type)` |
| 스택/힙 할당 | 지역/동적 할당 |
| 경계 검사 | 없음 (주의!) |

---

## 📘 참고 예제: 포인터로 2차원 배열 처리

```c
#include <stdio.h>

void print_matrix(int (*a)[3], int rows) {
    for (int i = 0; i < rows; ++i)
        for (int j = 0; j < 3; ++j)
            printf("a[%d][%d] = %d\n", i, j, a[i][j]);
}

int main() {
    int mat[2][3] = { {1, 2, 3}, {4, 5, 6} };
    print_matrix(mat, 2);
    return 0;
}
```

---

## 📚 결론

- 배열은 메모리 상에서 **연속적인 공간**을 활용하므로, 주소 계산이 단순하고 빠르다.
- C에서는 배열과 포인터가 밀접한 관계를 가지며, 다차원 배열은 실질적으로 일차원 배열과 다르지 않다.
- 경계 검사 미지원으로 인한 **보안 취약점**이 존재하며, 동적 배열 사용 시 메모리 해제를 잊지 않아야 한다.

컴퓨터 시스템을 이해하기 위해 배열의 메모리 표현을 명확히 이해하는 것은 필수적이다.