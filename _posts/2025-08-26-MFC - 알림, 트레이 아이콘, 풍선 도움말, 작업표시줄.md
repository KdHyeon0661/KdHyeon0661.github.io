---
layout: post
title: MFC - 알림, 트레이 아이콘, 풍선 도움말, 작업표시줄
date: 2025-08-26 23:25:23 +0900
category: MFC
---
# 알림 / 트레이 아이콘 / 풍선 도움말, 작업표시줄

이 글은 **MFC** 기반 데스크톱 앱에서 다음 기능을 **처음 붙이는 단계부터** 실전 팁까지 생략 없이 정리합니다.

- **트레이 아이콘**(System Tray, `Shell_NotifyIcon`)
- **풍선 알림**(트레이 풍선 / 토스트 대체 전략)
- **도구 설명(툴팁)** — 표준/풍선형 `CToolTipCtrl`
- **작업 표시줄 통합** — **점프 리스트**(`ICustomDestinationList`) / **진행률/오버레이/썸네일 버튼**(`ITaskbarList3`)

> 대상: MFC SDI/MDI/대화상자 앱, Windows 10/11, Unicode / x64 권장

---

## 0. 선택 가이드 (무엇을 언제 쓰나)

| 시나리오 | 추천 기능 |
|---|---|
| 앱이 **백그라운드**로 돌아가며, **상태/메뉴**를 항상 노출하고 싶다 | **트레이 아이콘**(+ 우클릭 컨텍스트 메뉴) |
| 간단한 **상태 알림**을 사용자에게 잠깐 보여주고 싶다 | **트레이 풍선 알림**(호환) / **Windows 토스트**(현대식, 권장) |
| 버튼/입력 필드 위에 **힌트**를 보여주고 싶다 | **CToolTipCtrl**(풍선 스타일 가능) |
| 작업 표시줄에서 **최근/자주/작업** 바로가기를 제공 | **점프 리스트** |
| 작업 표시줄 버튼에 **진행률/에러/일시정지** 상태를 표시 | **ITaskbarList3::SetProgress…** |
| 작업 표시줄 썸네일에 **재생/정지 버튼** 제공 | **ThumbBarAddButtons** |
| 아이콘 오른쪽 아래에 **오버레이 아이콘**(상태점) | **SetOverlayIcon** |

> **토스트**: 진짜 “Windows 10/11 알림 센터”에 노출하려면 **UWP/WinRT 알림 API**가 필요합니다. MFC에서도 사용할 수 있으나 설정이 많습니다. 본문에 **간단 접근(라이브러리/WinRT)**도 소개합니다. **빠른 호환**이 목적이면 **트레이 풍선**으로도 충분합니다.

---

## 1. 트레이 아이콘 (Shell_NotifyIcon) — 추가/수정/제거/클릭/컨텍스트 메뉴/풍선

### 1-1. 핵심 구조체/함수

- `NOTIFYICONDATA` (v2/v3/v4)
  필드: `hWnd`, `uID`, `uFlags`, `hIcon`, `szTip`, `uCallbackMessage`, `guidItem` 등
- `Shell_NotifyIcon(NIM_ADD / NIM_MODIFY / NIM_DELETE / NIM_SETVERSION)`

**권장 옵션**
- `cbSize = sizeof(NOTIFYICONDATA)` (최신 크기)
- `NOTIFYICON_VERSION_4` 로 `NIM_SETVERSION` 호출(Windows 7+ 고급 동작)
- `NIF_GUID` 를 사용해 **고유 GUID** 기반 관리(아이콘 재등록/Explorer 재시작에도 안정)

### 1-2. 메시지 라우팅

- 콜백 메시지: 보통 `WM_APP + 1` 같은 사용자 메시지 지정
- L/R 클릭/더블클릭: `lParam`으로 `WM_LBUTTONUP/WM_RBUTTONUP/WM_LBUTTONDBLCLK` 등 전달

### 1-3. 헬퍼 클래스 (복붙용)

```cpp
// TrayIcon.h
#pragma once
class CTrayIcon {
public:
    BOOL Create(HWND hNotify, UINT uMsg, HICON hIcon, const CString& tip, const GUID& guid, UINT uID = 1) {
        ZeroMemory(&m_nid, sizeof(m_nid));
        m_nid.cbSize = sizeof(m_nid);
        m_nid.hWnd = hNotify;
        m_nid.uID = uID;
        m_nid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP | NIF_GUID;
        m_nid.uCallbackMessage = uMsg;
        m_nid.hIcon = hIcon;
        m_nid.guidItem = guid;
        _tcsncpy_s(m_nid.szTip, tip, _TRUNCATE);

        BOOL ok = Shell_NotifyIcon(NIM_ADD, &m_nid);
        if (ok) {
            m_nid.uVersion = NOTIFYICON_VERSION_4;
            Shell_NotifyIcon(NIM_SETVERSION, &m_nid);
        }
        return ok;
    }

    BOOL ChangeIcon(HICON hIcon) {
        m_nid.uFlags = NIF_ICON | NIF_GUID;
        m_nid.hIcon = hIcon;
        return Shell_NotifyIcon(NIM_MODIFY, &m_nid);
    }

    BOOL ChangeTooltip(const CString& tip) {
        m_nid.uFlags = NIF_TIP | NIF_GUID;
        _tcsncpy_s(m_nid.szTip, tip, _TRUNCATE);
        return Shell_NotifyIcon(NIM_MODIFY, &m_nid);
    }

    BOOL ShowBalloon(const CString& title, const CString& text, DWORD infoFlags = NIIF_INFO, UINT timeoutMs = 3000) {
        m_nid.uFlags = NIF_INFO | NIF_GUID;
        _tcsncpy_s(m_nid.szInfoTitle, title, _TRUNCATE);
        _tcsncpy_s(m_nid.szInfo, text, _TRUNCATE);
        m_nid.uTimeout = timeoutMs;          // Windows 7+에서는 무시될 수 있음
        m_nid.dwInfoFlags = infoFlags;       // NIIF_INFO/NIIF_WARNING/NIIF_ERROR/NIIF_NOSOUND/NIIF_LARGE_ICON
        return Shell_NotifyIcon(NIM_MODIFY, &m_nid);
    }

    BOOL Remove() {
        m_nid.uFlags = NIF_GUID;
        return Shell_NotifyIcon(NIM_DELETE, &m_nid);
    }

    const NOTIFYICONDATA& GetNID() const { return m_nid; }

private:
    NOTIFYICONDATA m_nid{};
};
```

**사용 예 (대화상자나 프레임에서)**

```cpp
// MainDlg.h
class CMainDlg : public CDialogEx {
public:
    enum { WM_TRAY = WM_APP + 1 };
    CTrayIcon m_tray;
    GUID m_trayGuid{ /* 생성한 GUID 넣기 */ };
protected:
    afx_msg LRESULT OnTrayNotify(WPARAM wParam, LPARAM lParam);
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};

// MainDlg.cpp
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_MESSAGE(WM_TRAY, &CMainDlg::OnTrayNotify)
    ON_WM_SYSCOMMAND()
END_MESSAGE_MAP()

BOOL CMainDlg::OnInitDialog(){
    CDialogEx::OnInitDialog();
    HICON hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    m_tray.Create(m_hWnd, WM_TRAY, hIcon, L"내 앱 준비됨", m_trayGuid, 1);
    // 최소화 시 트레이로 숨기기 등
    return TRUE;
}

LRESULT CMainDlg::OnTrayNotify(WPARAM wParam, LPARAM lParam){
    if (wParam != 1) return 0;
    switch (lParam){
    case WM_LBUTTONDBLCLK:
        ShowWindow(SW_RESTORE); SetForegroundWindow();
        break;
    case WM_RBUTTONUP: {
        // 컨텍스트 메뉴
        CPoint pt; GetCursorPos(&pt);
        CMenu menu; menu.LoadMenu(IDR_TRAYMENU);
        CMenu* p = menu.GetSubMenu(0);
        SetForegroundWindow(); // TrackPopupMenu 전에!
        p->TrackPopupMenu(TPM_RIGHTBUTTON | TPM_LEFTALIGN, pt.x, pt.y, this);
        PostMessage(WM_NULL);  // 메뉴 닫힘 안정화 트릭
        break; }
    }
    return 0;
}

void CMainDlg::OnSysCommand(UINT nID, LPARAM lParam){
    if ((nID & 0xFFF0) == SC_MINIMIZE){
        // 최소화 → 트레이로 숨기기 패턴
        ShowWindow(SW_HIDE);
        m_tray.ShowBalloon(L"백그라운드 실행", L"트레이에서 계속 실행됩니다.", NIIF_INFO, 1500);
        return;
    }
    CDialogEx::OnSysCommand(nID, lParam);
}
```

> **풍선 알림 팁**
> - `NIIF_LARGE_ICON`(Win7+)으로 큰 아이콘 풍선
> - Windows 10/11에서는 풍선이 **토스트로 대체 표시**될 수 있음 (정책/설정에 영향).
> - 더 “정식”인 **알림 센터** 표시는 **토스트 API**를 검토(아래 §4-4).

---

## 2. 트레이 알림 심화 — 상태표시(오버레이), 다중 인스턴스, Explorer 재시작

- **GUID 사용**: `NIF_GUID`로 등록하면 Explorer 재시작 후에도 **동일 아이콘**으로 복원 더 잘됨
- **Explorer 재시작 감지**: `TaskbarCreated` 브로드캐스트 메시지(`RegisterWindowMessage(L"TaskbarCreated")`) 수신 시 **재등록**
- **다중 인스턴스**: `uID`만 다르게 주면 한 프로세스에서 여러 아이콘 운영 가능(추천은 **GUID로 구분**)

```cpp
UINT g_uTaskbarCreated = ::RegisterWindowMessage(L"TaskbarCreated");

BOOL CMainDlg::OnWndMsg(UINT msg, WPARAM w, LPARAM l, LRESULT* p){
    if (msg == g_uTaskbarCreated) {
        // Explorer 재시작 → 다시 등록
        HICON hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
        m_tray.Create(m_hWnd, WM_TRAY, hIcon, L"내 앱", m_trayGuid, 1);
        return TRUE;
    }
    return CDialogEx::OnWndMsg(msg, w, l, p);
}
```

---

## 3. CToolTipCtrl — 표준/풍선(말풍선) 툴팁

### 3-1. 컨트롤 자동 툴팁 (리소스의 “Tooltip” 속성)

MFC 대화상자 컨트롤은 `WS_EX_TRANSPARENT` 툴팁이 아니라, **Ctrl의 “Tooltip”(TTN_NEEDTEXT)** 속성을 켜면 **자동**이지만 제한적.
**정교한 제어**는 `CToolTipCtrl` 직접 생성이 안전합니다.

### 3-2. 풍선 툴팁 (TTS_BALLOON)

```cpp
class CMainDlg : public CDialogEx {
    CToolTipCtrl m_tip;
    BOOL PreTranslateMessage(MSG* pMsg) override {
        if (m_tip.m_hWnd) m_tip.RelayEvent(pMsg); // 필수
        return CDialogEx::PreTranslateMessage(pMsg);
    }
    BOOL OnInitDialog() override {
        CDialogEx::OnInitDialog();
        m_tip.Create(this, TTS_ALWAYSTIP | TTS_BALLOON); // 풍선
        m_tip.SetMaxTipWidth(400); // 줄바꿈 허용 폭
        m_tip.AddTool(GetDlgItem(IDC_EDIT_NAME), L"여기에 이름을 입력하세요.\r\n(필수)");
        m_tip.AddTool(GetDlgItem(IDC_BTN_SAVE), L"변경 내용을 저장합니다.");
        m_tip.Activate(TRUE);
        return TRUE;
    }
};
```

> 포커스 없는 컨트롤에도 뜨게 하려면 **ALWAYSTIP** + `RelayEvent` 가 중요.
> 고빈도 메시지에서 **RelayEvent 남발**로 느려지지 않게 기본 `PreTranslateMessage` 경로에서만 호출.

### 3-3. 동적 텍스트 (TTN_NEEDTEXT)

```cpp
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_NOTIFY_EX(TTN_NEEDTEXT, 0, &CMainDlg::OnTTNeedText)
END_MESSAGE_MAP()

BOOL CMainDlg::OnTTNeedText(UINT id, NMHDR* pNMHDR, LRESULT* pResult){
    TOOLTIPTEXT* pTTT = (TOOLTIPTEXT*)pNMHDR;
    if (pTTT->uFlags & TTF_IDISHWND) {
        UINT idCtrl = ::GetDlgCtrlID((HWND)pNMHDR->idFrom);
        if (idCtrl == IDC_PROGRESS) {
            pTTT->lpszText = _T("작업 진행 중입니다…");
            return TRUE;
        }
    }
    return FALSE;
}
```

---

## 4. 작업 표시줄 통합 (Windows 7+) — 점프 리스트, 진행률, 오버레이, 썸네일 버튼

> **COM 초기화**: `CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED)` (App 시작)
> **AppUserModelID**: 작업 표시줄 통합 기능은 **AppID**가 중요합니다.
> `SetCurrentProcessExplicitAppUserModelID(L"Vendor.Product.App")` 또는 매니페스트에 설정.

### 4-1. AppUserModelID 설정

```cpp
typedef HRESULT (WINAPI *PFN_SetAppID)(PCWSTR);
void EnsureAppID(){
    // 매니페스트로 지정하는 편이 권장. 예시는 런타임 설정.
    SetCurrentProcessExplicitAppUserModelID(L"MyCompany.MyApp.1");
}
```

### 4-2. 진행률/상태/오버레이 (`ITaskbarList3`)

```cpp
#include <ShObjIdl.h>

class CTaskbar {
public:
    CTaskbar() { CoCreateInstance(CLSID_TaskbarList, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&m_sp)); if (m_sp) m_sp->HrInit(); }
    void SetProgress(HWND hwnd, ULONGLONG value, ULONGLONG total){
        if (m_sp) m_sp->SetProgressValue(hwnd, value, total); // TBPF_NORMAL 자동
    }
    void SetState(HWND hwnd, TBPFLAG st){ if (m_sp) m_sp->SetProgressState(hwnd, st); } // TBPF_NOPROGRESS/INDETERMINATE/ERROR/PAUSED/NORMAL
    void SetOverlay(HWND hwnd, HICON hIcon, LPCWSTR desc){ if (m_sp) m_sp->SetOverlayIcon(hwnd, hIcon, desc); }
private:
    CComPtr<ITaskbarList3> m_sp;
};
```

**사용 예**

```cpp
CTaskbar g_tb;
void CMainFrame::OnStartWork(){
    g_tb.SetState(m_hWnd, TBPF_NORMAL);
    g_tb.SetProgress(m_hWnd, 0, 100);
}
void CMainFrame::OnTick(int progress){
    g_tb.SetProgress(m_hWnd, progress, 100);
    if (progress == 100) g_tb.SetState(m_hWnd, TBPF_NOPROGRESS);
}
void CMainFrame::OnError(){
    g_tb.SetState(m_hWnd, TBPF_ERROR);
    HICON hWarn = AfxGetApp()->LoadIcon(IDI_WARNING);
    g_tb.SetOverlay(m_hWnd, hWarn, L"오류");
}
```

### 4-3. 점프 리스트 (`ICustomDestinationList`)

**개념**
- **Recent/Frequent** 카테고리(Windows가 자동 생성)
- **Tasks**: 앱이 제공하는 **사용자 작업**(예: “새 캡처”, “빠른 변환”, “최근 작업 여는 배치”)
- **Custom Category**: 앱 전용 그룹(예: “프로젝트”)에 **IShellLink** 항목 나열

**헬퍼**

```cpp
#include <ShObjIdl.h> // ICustomDestinationList, IObjectCollection, IShellLink
#include <propvarutil.h>

class CJumpList {
public:
    HRESULT Build(){
        CComPtr<ICustomDestinationList> spList;
        HR(CoCreateInstance(CLSID_DestinationList, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&spList)));
        UINT slots = 0; CComPtr<IObjectArray> spRemoved;
        HR(spList->BeginList(&slots, IID_PPV_ARGS(&spRemoved)));

        // 1) Tasks
        CComPtr<IObjectCollection> spTasks; HR(CoCreateInstance(CLSID_EnumerableObjectCollection, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&spTasks)));
        // a) 명령행 링크 예시
        CComPtr<IShellLink> slNew; HR(CoCreateInstance(CLSID_ShellLink, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&slNew)));
        HR(slNew->SetPath(GetModulePath().c_str())); // exe 경로
        HR(slNew->SetArguments(L"/new"));            // 커맨드라인
        HR(slNew->SetDescription(L"새 문서"));
        HR(spTasks->AddObject(slNew));

        CComPtr<IShellLink> slOpen; HR(CoCreateInstance(CLSID_ShellLink, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&slOpen)));
        HR(slOpen->SetPath(GetModulePath().c_str()));
        HR(slOpen->SetArguments(L"/open"));
        HR(slOpen->SetDescription(L"열기 대화상자"));
        HR(spTasks->AddObject(slOpen));

        CComPtr<IObjectArray> spTasksArray; HR(spTasks->QueryInterface(IID_PPV_ARGS(&spTasksArray)));
        HR(spList->AddUserTasks(spTasksArray));

        // 2) Custom Category "프로젝트"
        CComPtr<IObjectCollection> spCat; HR(CoCreateInstance(CLSID_EnumerableObjectCollection, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&spCat)));
        // 임의 파일 바로가기 2개 추가 예시
        HR(spCat->AddObject(CreateShellLinkToFile(L"C:\\Work\\ProjA\\doc.mydoc", L"프로젝트 A 문서")));
        HR(spCat->AddObject(CreateShellLinkToFile(L"D:\\Data\\ProjB\\doc.mydoc", L"프로젝트 B 문서")));
        CComPtr<IObjectArray> spCatArray; HR(spCat->QueryInterface(IID_PPV_ARGS(&spCatArray)));
        HR(spList->AppendCategory(L"프로젝트", spCatArray));

        // 3) Recent/Frequent(자동) 추가 원하면 AppendKnownCategory 호출
        // HR(spList->AppendKnownCategory(KDC_RECENT)); // 또는 KDC_FREQUENT

        HR(spList->CommitList());
        return S_OK;
    }

private:
    static HRESULT HR(HRESULT hr){ return hr; } // 예제 간소화
    static std::wstring GetModulePath(){
        wchar_t path[MAX_PATH]{}; GetModuleFileNameW(nullptr, path, MAX_PATH); return path;
    }
    static IShellLink* CreateShellLinkToFile(PCWSTR path, PCWSTR title){
        CComPtr<IShellLink> sl; CoCreateInstance(CLSID_ShellLink, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&sl));
        sl->SetPath(path);
        sl->SetDescription(title);
        // (선택) IPropertyStore로 앱ID/타이틀 보강
        return sl.Detach();
    }
};
```

**App 시작 시**

```cpp
EnsureAppID(); // AppUserModelID
CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);
CJumpList jl; jl.Build();
```

> **주의**
> - 점프 리스트는 **AppID**가 달라지면 다른 앱으로 간주 → 반드시 고정
> - 바로가기 항목은 **실존 경로/실행 가능 커맨드**여야 표시됨
> - 최근/자주 항목은 **파일 형식 등록** 및 `SHAddToRecentDocs` 호출로 풍성해짐

### 4-4. 썸네일 툴팁/버튼 (미디어 컨트롤 등)

```cpp
// ITaskbarList3::ThumbBarAddButtons
THUMBBUTTON btns[3]{};
btns[0].dwMask = THB_FLAGS|THB_TOOLTIP|THB_ICON;
btns[0].iId = 1001; btns[0].dwFlags = THBF_ENABLED; btns[0].hIcon = hPlay; wcscpy_s(btns[0].szTip, L"재생");
btns[1].dwMask = THB_FLAGS|THB_TOOLTIP|THB_ICON;
btns[1].iId = 1002; btns[1].hIcon = hPause; wcscpy_s(btns[1].szTip, L"일시정지");
btns[2].dwMask = THB_FLAGS|THB_TOOLTIP|THB_ICON;
btns[2].iId = 1003; btns[2].hIcon = hStop; wcscpy_s(btns[2].szTip, L"정지");

g_tbAddButtons(hwndMain, btns, 3); // 래퍼에서 TaskbarList3 호출

// 버튼 클릭은 WM_COMMAND(1001/1002/1003)로 라우팅됨
```

**썸네일 툴팁/클립**
`ITaskbarList3::SetThumbnailTooltip(hwnd, L"현재: 03:21 / 12:34")`
`SetThumbnailClip(hwnd, &rc)` 로 썸네일에 **클립 영역** 지정

---

## 5. Windows 토스트 알림 (현대식 알림 센터) — 개요와 간단 경로

### 5-1. 왜 토스트인가?

- Windows 10/11의 **알림 센터**(Action Center)에 **일관된 UX**
- 클릭 시 **딥링크**(명령행/프로토콜)로 앱 기능 연결
- **배지/헤더 이미지/입력/버튼** 등 고급 구성

### 5-2. MFC에서 토스트 쓰는 3가지 길

1) **WinRT API 직접 호출**(C++/WinRT)
   - 앱에 **AppUserModelID** / **토스트 AUMID 등록** 필요
   - **app manifest**(ToastCapable) 또는 **Desktop Bridge** 사용 시 가장 정석
2) **경량 라이브러리 사용**(예: *WinToastLib*)
   - 순수 Win32/MFC에서 **간단**하게 토스트 발송 (내부에서 AUMID/COM 처리)
3) **트레이 풍선**을 사용해 **간단 대체** (알림 센터 통합은 없음)

> 여기서는 **간단 경로**로 WinToastLib 스타일의 코드 느낌만 소개 (실제 라이브러리 추가 필요).

```cpp
// (개념) WinToastLib 유사
WinToast::instance()->setAppName(L"MyApp");
WinToast::instance()->setAppUserModelId(L"MyCompany.MyApp.1");
if (!WinToast::instance()->initialize()) { /* 실패 처리 */ }

WinToastTemplate tpl(WinToastTemplate::Text02);
tpl.setTextField(L"처리가 완료되었습니다.", WinToastTemplate::FirstLine);
tpl.setTextField(L"결과를 확인하려면 클릭하세요.", WinToastTemplate::SecondLine);
tpl.setDuration(WinToastTemplate::Duration::Short);
INT64 id; WinToast::instance()->showToast(tpl, new MyHandler());
```

> **핵심**: AUMID(=AppUserModelID) 일치, 앱이 포그라운드가 아니어도 토스트가 뜸.
> 복잡한 WinRT 직접 구현은 별도 글 분량이라 여기서는 라이브러리 접근을 권장합니다.

---

## 6. UX/안정성/보안/배포 체크리스트

1. **아이콘 포맷**: 256×256 포함된 **ICO(멀티 사이즈)**를 리소스에 포함. 트레이/오버레이/썸네일에 깨끗하게 보임.
2. **GUID 고정**: 트레이 아이콘 `guidItem`은 **하드코딩**(앱 고유) — 업데이트/재시작에도 유지.
3. **메시지 루프**: `TrackPopupMenu` 전 **SetForegroundWindow** + **PostMessage(WM_NULL)** 패턴으로 메뉴 포커스 버그 방지.
4. **CoInitialize**: 작업표시줄/점프리스트 COM 사용 전 **COM STA 초기화**. 종료 시 `CoUninitialize`.
5. **AppID**: 점프리스트/토스트/최근 문서 등 **모두 AppID 일관성** 필요. 매니페스트 권장.
6. **권한**: 관리자/일반 실행이 섞이면 **작업표시줄 버튼/점프리스트가 달라** 보일 수 있음(다른 토큰=다른 인스턴스).
7. **다중 모니터**: 트레이 컨텍스트 메뉴 좌표는 **GetCursorPos** 사용. DPI 차이 큰 환경에서 팝업 위치 확인.
8. **하이 콘트라스트/다크**: 툴팁/풍선 텍스트 대비, 작업표시줄 오버레이는 **알파 채널** 적절.
9. **국제화**: 툴팁/풍선/토스트 텍스트 길이 → 말줄임/줄바꿈 확인.
10. **복구**: Explorer 재시작 감지(`TaskbarCreated`) 후 **트레이 아이콘 재등록**.
11. **최근 문서**: 점프리스트 풍성하게 하려면 `SHAddToRecentDocs()` 호출(문서 열기 시).
12. **클린업**: 종료 시 `NIM_DELETE`, `SetOverlayIcon(hwnd, nullptr, nullptr)`, 진행률 `TBPF_NOPROGRESS`.

---

## 7. 통합 데모 스니펫 — “작업 앱” (트레이 + 풍선 + 진행률 + 점프리스트)

```cpp
// App.cpp
BOOL CMyApp::InitInstance(){
    CWinAppEx::InitInstance();
    EnsureAppID();
    CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);
    // JumpList 구축
    CJumpList jl; jl.Build();
    return TRUE;
}
int CMyApp::ExitInstance(){
    CoUninitialize();
    return CWinAppEx::ExitInstance();
}

// MainDlg.cpp
BOOL CMainDlg::OnInitDialog(){
    CDialogEx::OnInitDialog();
    // Tray
    HICON hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    m_trayGuid = /* {YOUR-GUID-HERE} */;
    m_tray.Create(m_hWnd, WM_TRAY, hIcon, L"작업 앱 대기 중", m_trayGuid, 1);

    // Tooltip(풍선)
    m_tip.Create(this, TTS_ALWAYSTIP | TTS_BALLOON);
    m_tip.AddTool(GetDlgItem(IDC_BTN_START), L"작업을 시작합니다.");
    m_tip.AddTool(GetDlgItem(IDC_BTN_STOP),  L"작업을 중지합니다.");
    m_tip.Activate(TRUE);
    return TRUE;
}

void CMainDlg::OnBnClickedStart(){
    g_tb.SetState(m_hWnd, TBPF_NORMAL);
    g_tb.SetProgress(m_hWnd, 0, 100);
    m_tray.ShowBalloon(L"작업 시작", L"작업을 시작했습니다.", NIIF_INFO);
    // 타이머로 진행률 업데이트…
}

void CMainDlg::OnProgress(int pct){
    g_tb.SetProgress(m_hWnd, pct, 100);
    if (pct == 100){
        g_tb.SetState(m_hWnd, TBPF_NOPROGRESS);
        g_tb.SetOverlay(m_hWnd, nullptr, nullptr);
        m_tray.ShowBalloon(L"완료", L"작업이 완료되었습니다.", NIIF_INFO);
    } else if (pct == 50){
        HICON hOv = AfxGetApp()->LoadIcon(IDI_INFO);
        g_tb.SetOverlay(m_hWnd, hOv, L"중간지점");
    }
}

void CMainDlg::OnBnClickedError(){
    g_tb.SetState(m_hWnd, TBPF_ERROR);
    HICON hWarn = AfxGetApp()->LoadIcon(IDI_WARNING);
    g_tb.SetOverlay(m_hWnd, hWarn, L"오류 발생");
    m_tray.ShowBalloon(L"오류", L"네트워크 오류가 발생했습니다.", NIIF_ERROR);
}
```

---

## 8. 문제 해결 가이드

| 증상 | 원인 | 해결 |
|---|---|---|
| 트레이 메뉴가 즉시 닫힘 | 포그라운드 윈도우 아님 | `SetForegroundWindow()` 후 `TrackPopupMenu` |
| 풍선이 안 뜬다 | 알림 설정/포커스/정책 | `NIIF_NOSOUND`/`NIIF_LARGE_ICON` 조합 시험, 토스트로 전환 검토 |
| 점프 리스트가 비어있다 | AppUserModelID 없음/불일치 | `SetCurrentProcessExplicitAppUserModelID`(매니페스트 권장) |
| 진행률이 안 보임 | 다른 토큰의 창에 SetProgress | **주 창 핸들** 정확히 전달, 관리자/일반 혼용 주의 |
| 오버레이가 흐릿 | 작은 아이콘/알파 없음 | 24/32px 투명 PNG → HICON 변환, 더 큰 원본 사용 |
| Explorer 재시작 후 사라짐 | 재등록 미구현 | `TaskbarCreated` 메시지 받아 `NIM_ADD` 재실행 |
| 툴팁 안 뜸 | RelayEvent 누락 | `PreTranslateMessage`에서 `m_tip.RelayEvent(pMsg)` 호출 |

---

## 9. 부록 — 안전한 리소스/아이콘 파이프라인

- **ICO**: 16/20/24/32/48/64/128/256 포함(최소 16/32/256)
- **PNG → ICO**: 빌드 스크립트에서 변환(안티앨리어싱/알파 유지)
- **DPI 테스트**: 100/125/150/200/300%에서 트레이/오버레이/썸네일 모두 육안 확인

---

## 10. 요약

- **트레이 아이콘**은 **백그라운드 UX**의 핵심: **GUID + NIM_SETVERSION** + **컨텍스트 메뉴** + **풍선**
- **툴팁**은 `CToolTipCtrl`로 **풍선형/동적 텍스트**까지 깔끔하게
- **작업표시줄 통합**은 **AppID**가 생명: **진행률/오버레이/썸네일 버튼/점프리스트**로 현대 UX 완성
- **토스트**는 가능하면 라이브러리를 통해 **간단**하게 시작 → 필요 시 **WinRT 정식 통합**으로 확장

필요하시면 **토스트(WinRT) 정식 구현 템플릿**(AUMID/매니페스트/컴팩트 래퍼 포함)도 이어서 만들어 드릴게요.
