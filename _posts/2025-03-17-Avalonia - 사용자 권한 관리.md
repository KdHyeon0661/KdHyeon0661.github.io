---
layout: post
title: Avalonia - 사용자 권한 관리
date: 2025-03-17 20:20:23 +0900
category: Avalonia
---
# Avalonia에서 사용자 권한 관리(Admin vs 일반 사용자)

## 1. 요구사항 재정의(확장)
- **권한 기반 UI 구성**: Admin만 보이는 메뉴/버튼, 일반 사용자(User)는 제한 UI
- **ViewModel 로직 분리**: 동일 액션이라도 역할에 따라 다른 동작/비활성화
- **동적 권한 변경**: 로그인/로그아웃/토큰 갱신 시 UI가 자동 반영
- **보안 원칙**: 클라이언트 측은 UX 편의일 뿐, **실제 권한 검증은 서버**에서 수행
- **테스트 용이성**: Service/State를 Mock 가능하게, VM/Command 단위 테스트

---

## 2. 도메인 모델: 역할과 권한

### 2.1 역할(Role) 열거형
```csharp
public enum UserRole
{
    Guest,
    User,
    Admin
}
```

### 2.2 권한(Policy) 모델(선택)
역할은 “사람에게 부여”, 권한은 “행위(리소스+액션)”에 대응한다.

```csharp
public static class AppPolicies
{
    public const string CanDeleteData = "policy:can_delete_data";
    public const string CanViewAudit  = "policy:can_view_audit";
    public const string CanManageUser = "policy:can_manage_user";

    public static readonly IReadOnlyDictionary<UserRole, string[]> RoleToPolicies =
        new Dictionary<UserRole, string[]>
        {
            [UserRole.Guest] = Array.Empty<string>(),
            [UserRole.User]  = new[] { /* 읽기 등 기본 정책 */ },
            [UserRole.Admin] = new[] { CanDeleteData, CanViewAudit, CanManageUser }
        };
}
```

> 역할만으로 충분한 경우도 있지만, **세분화된 행위 제어**가 필요하면 정책이 유용하다.

---

## 3. 전역 인증 상태(AppAuthState)와 알림
권한 변경을 UI에 즉시 반영하려면, 전역 상태가 **변경 알림**을 발행해야 한다.

```csharp
using System.ComponentModel;
using System.Runtime.CompilerServices;

public sealed class AppAuthState : INotifyPropertyChanged
{
    private UserRole _currentRole = UserRole.Guest;
    private string? _accessToken;
    private DateTimeOffset _tokenExpiresAt;

    public event PropertyChangedEventHandler? PropertyChanged;

    public UserRole CurrentRole
    {
        get => _currentRole;
        set { if (_currentRole != value) { _currentRole = value; OnPropertyChanged(); } }
    }

    public string? AccessToken
    {
        get => _accessToken;
        set { if (_accessToken != value) { _accessToken = value; OnPropertyChanged(); } }
    }

    public DateTimeOffset TokenExpiresAt
    {
        get => _tokenExpiresAt;
        set { if (_tokenExpiresAt != value) { _tokenExpiresAt = value; OnPropertyChanged(); } }
    }

    public bool IsAuthenticated => !string.IsNullOrWhiteSpace(AccessToken);
    public bool IsAdmin => CurrentRole == UserRole.Admin;
    public bool IsUser  => CurrentRole == UserRole.User;

    private void OnPropertyChanged([CallerMemberName] string? name = null)
        => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
}
```

> `INotifyPropertyChanged`로 ViewModel 바인딩이 자동 업데이트된다.
> ReactiveUI를 쓰는 경우 `ReactiveObject`/`ObservableAsPropertyHelper`로 더 간결하게 표현 가능.

---

## 4. 인증 서비스(AuthService)와 역할 확정
로그인/로그아웃/토큰 갱신 시 전역 상태를 갱신한다.
JWT에서 `role` 클레임을 파싱하는 예시도 포함한다.

```csharp
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text.Json;

public interface IAuthService
{
    Task<bool> LoginAsync(string username, string password);
    Task LogoutAsync();
    Task<bool> RefreshAsync();
}

public sealed class AuthService : IAuthService
{
    private readonly HttpClient _http;
    private readonly AppAuthState _state;

    public AuthService(HttpClient http, AppAuthState state)
    {
        _http = http;
        _state = state;
    }

    public async Task<bool> LoginAsync(string username, string password)
    {
        var payload = JsonSerializer.Serialize(new { username, password });
        using var content = new StringContent(payload, System.Text.Encoding.UTF8, "application/json");

        var res = await _http.PostAsync("/api/auth/login", content);
        if (!res.IsSuccessStatusCode) return false;

        var body = await res.Content.ReadAsStringAsync();
        var dto  = JsonSerializer.Deserialize<AuthResponse>(body);
        if (dto is null || string.IsNullOrWhiteSpace(dto.access_token)) return false;

        ApplyTokens(dto);
        return true;
    }

    public async Task<bool> RefreshAsync()
    {
        // refresh_token 기반 재발급 호출(생략 가능)
        return false;
    }

    public async Task LogoutAsync()
    {
        _state.AccessToken = null;
        _state.CurrentRole = UserRole.Guest;
        _state.TokenExpiresAt = DateTimeOffset.MinValue;
        await Task.CompletedTask;
    }

    private void ApplyTokens(AuthResponse dto)
    {
        _state.AccessToken = dto.access_token;
        _state.TokenExpiresAt = DateTimeOffset.UtcNow.AddSeconds(dto.expires_in);

        // 1) 응답 JSON에 role 필드가 명시된 경우
        if (!string.IsNullOrWhiteSpace(dto.role))
        {
            _state.CurrentRole = Enum.TryParse<UserRole>(dto.role, true, out var r) ? r : UserRole.User;
            return;
        }

        // 2) JWT 클레임으로부터 role 파싱
        var handler = new JwtSecurityTokenHandler();
        var jwt = handler.ReadJwtToken(dto.access_token);
        var roleClaim = jwt.Claims.FirstOrDefault(c => c.Type is ClaimTypes.Role or "role");
        if (roleClaim is not null &&
            Enum.TryParse<UserRole>(roleClaim.Value, true, out var role))
        {
            _state.CurrentRole = role;
        }
        else
        {
            _state.CurrentRole = UserRole.User;
        }
    }

    private sealed class AuthResponse
    {
        public string access_token { get; set; } = "";
        public string? role { get; set; }
        public int expires_in { get; set; }
    }
}
```

---

## 5. 권한 서비스(Authorization)로 정책 평가
UI/커맨드/네비게이션에서 공통으로 사용할 **정책 평가기**를 둔다.

```csharp
public interface IAuthorizationService
{
    bool IsInRole(UserRole role);
    bool HasPolicy(string policy);
}

public sealed class AuthorizationService : IAuthorizationService
{
    private readonly AppAuthState _state;
    public AuthorizationService(AppAuthState state) => _state = state;

    public bool IsInRole(UserRole role) => _state.CurrentRole == role;

    public bool HasPolicy(string policy)
    {
        if (!AppPolicies.RoleToPolicies.TryGetValue(_state.CurrentRole, out var ps)) return false;
        return ps.Contains(policy);
    }
}
```

---

## 6. DI 등록(예: App.xaml.cs/부트스트랩)
```csharp
using Microsoft.Extensions.DependencyInjection;

var services = new ServiceCollection();

// 전역 상태/서비스
services.AddSingleton<AppAuthState>();
services.AddSingleton<IAuthService, AuthService>();
services.AddSingleton<IAuthorizationService, AuthorizationService>();

// HttpClient (토큰 삽입 핸들러 등 필요 시 체인)
services.AddSingleton(new HttpClient { BaseAddress = new Uri("https://api.example.com") });

// ViewModel
services.AddTransient<MainViewModel>();
services.AddTransient<LoginViewModel>();

var provider = services.BuildServiceProvider();
```

---

## 7. ViewModel: 권한 기반 바인딩/커맨드

### 7.1 메인 VM에서 권한 속성 노출
권한 변경 시 UI가 즉시 반응하도록, 전역 상태의 `PropertyChanged`를 구독한다.

```csharp
using System;
using System.ComponentModel;

public sealed class MainViewModel : ViewModelBase
{
    private readonly AppAuthState _authState;
    private readonly IAuthorizationService _authz;

    public bool IsAdmin => _authState.IsAdmin;
    public bool IsUser  => _authState.IsUser;

    public ReactiveCommand<Unit, Unit> DeleteCommand { get; }

    public MainViewModel(AppAuthState authState, IAuthorizationService authz)
    {
        _authState = authState;
        _authz = authz;

        // 권한 변화 → UI 반영
        _authState.PropertyChanged += OnAuthChanged;

        // 권한 기반 커맨드
        DeleteCommand = ReactiveCommand.Create(Delete,
            this.WhenAnyValue(_ => _authState.CurrentRole, role => role == UserRole.Admin));
    }

    private void OnAuthChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(AppAuthState.CurrentRole) ||
            e.PropertyName == nameof(AppAuthState.AccessToken))
        {
            this.RaisePropertyChanged(nameof(IsAdmin));
            this.RaisePropertyChanged(nameof(IsUser));
            // 필요 시 다른 속성도 Raise
        }
    }

    private void Delete()
    {
        if (!_authz.HasPolicy(AppPolicies.CanDeleteData))
        {
            ShowMessage("삭제 권한이 없습니다.");
            return;
        }
        // 삭제 로직
    }

    private void ShowMessage(string message)
    {
        // Dialog/Toast 등
    }
}
```

---

## 8. XAML: 가시성/활성화/스타일 제어

### 8.1 기본 바인딩
```xml
<Button Content="관리자 설정" IsVisible="{Binding IsAdmin}" />
<Button Content="일반 사용자 기능" IsVisible="{Binding IsUser}" />
<Button Content="데이터 삭제" Command="{Binding DeleteCommand}" />
```

### 8.2 DataTrigger/Style로 제어(복잡 UI)
```xml
<StackPanel>
  <StackPanel.Styles>
    <Style Selector="Button#AuditButton">
      <Style.Triggers>
        <DataTrigger Binding="{Binding IsAdmin}" Value="True">
          <Setter Property="IsVisible" Value="True"/>
        </DataTrigger>
        <DataTrigger Binding="{Binding IsAdmin}" Value="False">
          <Setter Property="IsVisible" Value="False"/>
        </DataTrigger>
      </Style.Triggers>
    </Style>
  </StackPanel.Styles>

  <Button x:Name="AuditButton" Content="감사 로그 보기"/>
</StackPanel>
```

### 8.3 컨버터 기반(멀티 역할 지원)
```csharp
using Avalonia.Data.Converters;
using System;
using System.Globalization;

public sealed class RoleToVisibilityConverter : IValueConverter
{
    public UserRole RequiredRole { get; set; } = UserRole.Admin;

    public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is UserRole role)
            return role >= RequiredRole; // 예: Admin만 true
        return false;
    }

    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
        => throw new NotSupportedException();
}
```

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:conv="clr-namespace:MyApp.Converters">
  <UserControl.Resources>
    <conv:RoleToVisibilityConverter x:Key="RoleToVisible" RequiredRole="Admin"/>
  </UserControl.Resources>

  <Button Content="관리자" IsVisible="{Binding Path=_authState.CurrentRole, Converter={StaticResource RoleToVisible}}"/>
</UserControl>
```

> 컨버터 대신 **Behavior/AttachedProperty**로도 구현 가능하다.

---

## 9. 네비게이션 가드(페이지 접근 제한)
역할에 따라 라우팅을 차단한다.

```csharp
public interface INavigationService
{
    void Navigate(object viewModel);
    void NavigateIfAdmin(Func<object> factory);
}

public sealed class NavigationService : INavigationService
{
    private readonly AppAuthState _state;
    private readonly Action<object> _show;

    public NavigationService(AppAuthState state, Action<object> show)
    {
        _state = state;
        _show = show;
    }

    public void Navigate(object viewModel) => _show(viewModel);

    public void NavigateIfAdmin(Func<object> factory)
    {
        if (_state.CurrentRole != UserRole.Admin)
        {
            // 메시지 또는 403 View로 대체
            _show(new ForbiddenViewModel());
            return;
        }
        _show(factory());
    }
}
```

사용:
```csharp
public sealed class ShellViewModel : ViewModelBase
{
    private readonly INavigationService _nav;

    public ShellViewModel(INavigationService nav) => _nav = nav;

    public void OpenAdminDashboard()
        => _nav.NavigateIfAdmin(() => new AdminDashboardViewModel());
}
```

---

## 10. 동적 권한 변경 흐름
로그인/로그아웃/토큰 재발급 시 UI가 자동 반응하도록 연결.

```csharp
public sealed class LoginViewModel : ViewModelBase
{
    private readonly IAuthService _auth;
    private readonly INavigationService _nav;

    public string Username { get; set; } = "";
    public string Password { get; set; } = "";

    public ReactiveCommand<Unit, Unit> LoginCommand { get; }

    public LoginViewModel(IAuthService auth, INavigationService nav)
    {
        _auth = auth;
        _nav  = nav;

        LoginCommand = ReactiveCommand.CreateFromTask(LoginAsync);
    }

    private async Task LoginAsync()
    {
        var ok = await _auth.LoginAsync(Username, Password);
        if (!ok)
        {
            // 실패 메시지
            return;
        }
        _nav.Navigate(new MainViewModel(
            Services.GetRequiredService<AppAuthState>(),
            Services.GetRequiredService<IAuthorizationService>()));
    }
}
```

> `AppAuthState`가 PropertyChanged를 발행하므로, Main VM 바인딩이 자동 갱신된다.

---

## 11. 고급: 커맨드 필터/Attribute 기반 요구사항
권한 요구사항을 속성(Attribute)로 명시하고 공통 필터에서 검사할 수 있다.

```csharp
[AttributeUsage(AttributeTargets.Method)]
public sealed class RequiresRoleAttribute : Attribute
{
    public UserRole Role { get; }
    public RequiresRoleAttribute(UserRole role) => Role = role;
}

// 실행 진입점에서 리플렉션으로 검사 (간단 예시)
public static class CommandGuard
{
    public static bool Check(object target, string methodName, IAuthorizationService authz)
    {
        var method = target.GetType().GetMethod(methodName);
        if (method is null) return true;

        var req = method.GetCustomAttributes(typeof(RequiresRoleAttribute), true)
                        .OfType<RequiresRoleAttribute>()
                        .FirstOrDefault();

        return req is null || authz.IsInRole(req.Role);
    }
}
```

---

## 12. 보안 팁(핵심 요약)
- **클라이언트 제어는 UX용**: 실제 권한 검증은 **서버**가 수행해야 한다(엔드포인트 401/403 처리).
- 토큰 갱신 시 **역할 변경 반영**: 서버에서 역할이 바뀌면, 새 토큰/응답으로 클라이언트 상태 업데이트.
- 민감 작업은 **서버 서브미션 전에도** 로컬 차단(UX) + **서버에서도** 다시 검증.
- 토큰 저장은 OS 보호 스토리지/암호화 사용(Windows DPAPI, macOS Keychain, Linux SecretService 등).

---

## 13. 디자인타임·테스트 데이터
권한에 따라 UI를 미리 확인하기 위해 **디자인타임 ViewModel**을 준비한다.

```csharp
public sealed class MainViewModelDesign : MainViewModel
{
    public MainViewModelDesign() : base(new AppAuthState { CurrentRole = UserRole.Admin }, new AuthorizationService(new AppAuthState{CurrentRole = UserRole.Admin}))
    {
        // 데모 데이터
    }
}
```

`d:DataContext`로 Previewer에서 Admin/Guest 모드를 스위칭하며 레이아웃 검증.

---

## 14. 단위 테스트 예시(xUnit + Moq)
권한에 따른 커맨드 활성/비활성과 가드 동작을 검증한다.

```csharp
using Xunit;
using Moq;

public sealed class AuthTests
{
    [Fact]
    public void DeleteCommand_Enabled_For_Admin_Only()
    {
        var state = new AppAuthState { CurrentRole = UserRole.Admin };
        var authz = new AuthorizationService(state);
        var vm = new MainViewModel(state, authz);

        Assert.True(vm.DeleteCommand.CanExecute().Value);

        state.CurrentRole = UserRole.User;
        // ReactiveCommand의 CanExecute는 Observe를 통해 갱신되므로,
        // 테스트 프레임워크에 따라 스케줄러 펌프가 필요할 수 있음.

        Assert.False(vm.DeleteCommand.CanExecute().Value);
    }

    [Fact]
    public void Navigation_Guard_Blocks_NonAdmin()
    {
        var state = new AppAuthState { CurrentRole = UserRole.User };
        var navMock = new Mock<INavigationService>();
        navMock.Setup(n => n.NavigateIfAdmin(It.IsAny<Func<object>>())).Callback<Func<object>>(f =>
        {
            Assert.True(state.CurrentRole != UserRole.Admin);
        });

        var svc = navMock.Object;
        svc.NavigateIfAdmin(() => new object());
    }
}
```

---

## 15. 메뉴/탭을 동적으로 생성
역할별로 보여줄 항목을 **데이터로 선언**하면 확장성이 높다.

```csharp
public sealed record AppMenu(string Title, Func<object> Factory, string? RequiredPolicy = null);

public sealed class MenuProvider
{
    public IReadOnlyList<AppMenu> GetMenusFor(UserRole role)
    {
        var all = new List<AppMenu>
        {
            new("대시보드", () => new DashboardViewModel()),
            new("사용자 관리", () => new UserAdminViewModel(), AppPolicies.CanManageUser),
            new("감사 로그", () => new AuditViewModel(), AppPolicies.CanViewAudit)
        };

        if (!AppPolicies.RoleToPolicies.TryGetValue(role, out var policies))
            return all.Where(m => m.RequiredPolicy is null).ToList();

        return all.Where(m => m.RequiredPolicy is null || policies.Contains(m.RequiredPolicy)).ToList();
    }
}
```

XAML에서는 `ItemsControl`/`ListBox`로 메뉴를 바인딩하고 선택 시 `Factory()`를 호출해 네비게이션.

---

## 16. 서버 연동 시 주의(요약)
- 모든 API 호출에 `Authorization: Bearer <token>`
- 401/403 응답 시, **로컬 UX 차단** + **로그아웃/재인증** 유도
- “권한 없음”은 UI에서 숨김 처리하되, **직접 URI/핫키 진입도 서버에서 거절**되어야 한다.

---

## 17. 성능·UX 최적화
- 자주 안 보이는 Admin 뷰는 **지연 로드**(Lazy/Factory)
- 대량 UI에서 `IsVisible` 남발 대신, **탭/페이지 자체를 제거**하여 렌더링 부하 감소
- Role/Policy 계산 결과를 **메모이제이션**(상태 변경 시만 갱신)

---

## 18. 최종 체크리스트
- [x] `AppAuthState`는 바인딩 알림 발행
- [x] `IAuthService`가 로그인/토큰 파싱/역할 확정
- [x] `IAuthorizationService`가 역할/정책 평가
- [x] VM은 `IsAdmin/IsUser` 노출 + 커맨드 가드
- [x] XAML은 `IsVisible/IsEnabled`/Trigger/스타일로 표시 제어
- [x] 네비게이션 가드는 비관리자 접근 차단
- [x] 단위 테스트로 역할 전환/커맨드/가드 검증
- [x] 서버 측에서도 **권한 검증 필수**

---

## 결론
- **역할(Role) → 정책(Policy) → UI/네비/커맨드 가드**의 3단 구성을 채택하면, 권한 관리를 **명확·재사용·테스트 가능**하게 만들 수 있다.
- `AppAuthState`의 변경 알림을 중심에 두고, ViewModel/뷰/네비게이션이 유기적으로 반응하도록 설계하라.
- 클라이언트의 제어는 어디까지나 **UX**이며, **보안은 서버**가 책임진다. 이 이중 검증 구조를 지키면, 권한 시스템은 견고해진다.
