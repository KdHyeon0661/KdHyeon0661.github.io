---
layout: post
title: 영상처리 - 영상의 크기 변환
date: 2025-09-23 22:25:23 +0900
category: 영상처리
---
# 영상의 크기 변환 (Resizing / Resampling)
_개념 → 좌표 매핑(픽셀 센터 정렬) → 최근접/양선형/3차 회선(바이큐빅) 보간 → 안전한 경계 처리 → 대화 상자(UI) → 초기화/동작 제어 → 메뉴 연동 → 실전 예제_

> 전제  
> - Win32(비-MFC) **ImageTool** 프로젝트, 영상은 `IppDib` (Top-Down **BGRA32**).  
> - 알파 채널(A)은 **보존**하며, 보간 시 B/G/R/A 모두 동일 방식으로 샘플링합니다.  
> - 수식은 **MathJax**, 코드는 **한 번만** ``` 로 감쌉니다.

---

## 1) 크기 변환과 보간법

### 1.1 스케일링의 수학적 모델
원본 해상도 \(W \times H\) 를 **새 해상도** \(W' \times H'\) 로 변환합니다.  
출력 픽셀 \((x,y)\) 의 **원본 좌표**(역방향 매핑)는 “픽셀 센터 정렬(centered)” 규약으로:

\[
\begin{aligned}
s_x &= \frac{W}{W'},\qquad s_y = \frac{H}{H'} \\
x_s &= (x+0.5)\,s_x - 0.5, \\
y_s &= (y+0.5)\,s_y - 0.5.
\end{aligned}
\]

- 이 정렬은 **확대/축소 모두**에서 일관된 샘플링 품질을 보장합니다.  
- \((x_s,y_s)\) 는 일반적으로 정수가 아니므로, **보간(interpolation)** 으로 값을 얻습니다.

### 1.2 보간법 요약
- **최근접(Nearest)**: 가장 가까운 픽셀을 그대로 선택. 빠르지만 **계단/블록** 현상.  
- **양선형(Bilinear)**: 4 이웃 선형 보간. 빠르고 자연스럽지만 **살짝 블러**.  
- **3차 회선(바이큐빅, Bicubic)**: 16 이웃 3차 커널. 더 선명하고 자연스럽지만 **연산량↑**.  

> **다운스케일에서의 앨리어싱**: Bilinear/Bicubic도 고주파가 많은 이미지에서 **앨리어싱/모아레**가 남을 수 있습니다.  
> 매우 큰 축소에는 **박스/에어리어/랜초스** 같은 **평균형** 또는 **보다 넓은 커널**이 유리합니다. (본 장에서는 **바이큐빅**까지 구현)

---

## 2) 크기 변환 구현 (안전한 경계 처리 포함)

아래 헤더는 최근접/양선형/바이큐빅을 지원합니다. 경계는 **Constant/Replicate/Wrap** 3종.

```
// Resize.h
#pragma once
#include <cstdint>
#include <vector>
#include <cmath>
#include <algorithm>
#include "IppDib.h"

// ---------------- 공통 ----------------
enum class ScaleFilter { Nearest, Bilinear, Bicubic };
enum class BorderMode { Constant, Replicate, Wrap };

struct ResizeParams {
    int   outW = 0;
    int   outH = 0;
    ScaleFilter filter = ScaleFilter::Bicubic;
    BorderMode  border = BorderMode::Replicate;
    uint8_t fillB=0, fillG=0, fillR=0, fillA=255; // Constant 채움 색
};

inline uint8_t clamp_u8(float v){ if(v<0) v=0; else if(v>255) v=255; return (uint8_t)std::lround(v); }
inline int mod_pos(int a, int m){ int r=a % m; return (r<0)? r+m : r; }

// (x,y)가 영상 밖일 때 Border에 맞게 보정/샘플 허용 여부 반환
inline bool map_coord_border(int sx, int sy, int W, int H, BorderMode bm, int& ox, int& oy) {
    if (bm==BorderMode::Replicate) {
        ox = (sx<0)?0:((sx>=W)?W-1:sx);
        oy = (sy<0)?0:((sy>=H)?H-1:sy);
        return true;
    } else if (bm==BorderMode::Wrap) {
        ox = mod_pos(sx, W);
        oy = mod_pos(sy, H);
        return true;
    } else { // Constant
        if (sx<0 || sx>=W || sy<0 || sy>=H) return false;
        ox=sx; oy=sy; return true;
    }
}

// ---------------- 최근접 ----------------
inline void sample_nearest_BGRA32(const IppDib& src, float xs, float ys,
                                  BorderMode bm, const uint8_t* fill, uint8_t* out4)
{
    int sx=(int)std::lround(xs), sy=(int)std::lround(ys);
    int ox,oy;
    if (map_coord_border(sx,sy,src.width(),src.height(),bm,ox,oy)) {
        const uint8_t* row=(const uint8_t*)src.bits()+(size_t)oy*src.stride();
        const uint8_t* p=&row[ox*4];
        out4[0]=p[0]; out4[1]=p[1]; out4[2]=p[2]; out4[3]=p[3];
    } else {
        out4[0]=fill[0]; out4[1]=fill[1]; out4[2]=fill[2]; out4[3]=fill[3];
    }
}

// ---------------- 양선형 ----------------
inline void sample_bilinear_BGRA32(const IppDib& src, float xs, float ys,
                                   BorderMode bm, const uint8_t* fill, uint8_t* out4)
{
    int x0=(int)std::floor(xs), y0=(int)std::floor(ys);
    float ax = xs - x0, ay = ys - y0;
    int x1=x0+1, y1=y0+1;

    const uint8_t *p00,*p10,*p01,*p11;
    uint8_t f00[4],f10[4],f01[4],f11[4];

    auto get=[&](int sx,int sy,uint8_t* fbuf)->const uint8_t*{
        int ox,oy;
        if (map_coord_border(sx,sy,src.width(),src.height(),bm,ox,oy)) {
            const uint8_t* row=(const uint8_t*)src.bits()+(size_t)oy*src.stride();
            return &row[ox*4];
        } else { fbuf[0]=fill[0]; fbuf[1]=fill[1]; fbuf[2]=fill[2]; fbuf[3]=fill[3]; return fbuf; }
    };
    p00=get(x0,y0,f00); p10=get(x1,y0,f10); p01=get(x0,y1,f01); p11=get(x1,y1,f11);

    for (int c=0;c<4;++c){
        float v0 = p00[c]*(1.f-ax) + p10[c]*ax;
        float v1 = p01[c]*(1.f-ax) + p11[c]*ax;
        out4[c]  = clamp_u8( v0*(1.f-ay) + v1*ay );
    }
}

// ---------------- 3차 회선(바이큐빅) ----------------
// Keys cubic: a = -0.5 (Catmull-Rom) 권장. a=-0.75(Mitchell-Netravali 일부 형태)도 가능.
inline float cubic_kernel(float x, float a){
    x = std::fabs(x);
    if (x < 1.f) return (a+2.f)*x*x*x - (a+3.f)*x*x + 1.f;
    if (x < 2.f) return a*x*x*x - 5.f*a*x*x + 8.f*a*x - 4.f*a;
    return 0.f;
}
inline void weights_cubic(float t, float a, float w[4]){
    // 이웃 위치: x0-1, x0, x0+1, x0+2, 여기서 t = xs - x0
    w[0]=cubic_kernel(1.f+t, a);
    w[1]=cubic_kernel(t,     a);
    w[2]=cubic_kernel(1.f-t, a);
    w[3]=cubic_kernel(2.f-t, a);
}
inline void sample_bicubic_BGRA32(const IppDib& src, float xs, float ys,
                                  BorderMode bm, const uint8_t* fill, uint8_t* out4,
                                  float a/*=-0.5*/)
{
    int x0=(int)std::floor(xs);
    int y0=(int)std::floor(ys);
    float tx = xs - x0;
    float ty = ys - y0;
    float wx[4], wy[4];
    weights_cubic(tx, a, wx);
    weights_cubic(ty, a, wy);

    float sumB=0, sumG=0, sumR=0, sumA=0;
    float Wsum=0;

    // 4x4 누적
    for (int j=-1;j<=2;++j){
        for (int i=-1;i<=2;++i){
            int sx = x0 + i;
            int sy = y0 + j;
            int ox,oy;
            uint8_t pbuf[4];
            const uint8_t* p=nullptr;
            if (map_coord_border(sx,sy,src.width(),src.height(),bm,ox,oy)) {
                const uint8_t* row=(const uint8_t*)src.bits()+(size_t)oy*src.stride();
                p=&row[ox*4];
            } else {
                pbuf[0]=fill[0]; pbuf[1]=fill[1]; pbuf[2]=fill[2]; pbuf[3]=fill[3];
                p=pbuf;
            }
            float w = wx[i+1]*wy[j+1];
            sumB += w * p[0]; sumG += w * p[1]; sumR += w * p[2]; sumA += w * p[3];
            Wsum += w;
        }
    }
    if (std::fabs(Wsum) < 1e-8f) Wsum = 1.f;
    out4[0]=clamp_u8(sumB/Wsum);
    out4[1]=clamp_u8(sumG/Wsum);
    out4[2]=clamp_u8(sumR/Wsum);
    out4[3]=clamp_u8(sumA/Wsum);
}

// ---------------- 메인: 리사이즈 ----------------
inline void Resize_BGRA32(const IppDib& src, IppDib& dst, const ResizeParams& P, float cubicA=-0.5f)
{
    if (!src || P.outW<=0 || P.outH<=0) { dst = src; return; }

    dst.create(P.outW, P.outH, 32);

    float sx = (float)src.width()  / (float)P.outW;
    float sy = (float)src.height() / (float)P.outH;

    uint8_t fill[4] = {P.fillB, P.fillG, P.fillR, P.fillA};

    for (int y=0;y<P.outH;++y){
        uint8_t* drow = (uint8_t*)dst.bits() + (size_t)y*dst.stride();
        float ys = ( (float)y + 0.5f ) * sy - 0.5f;
        for (int x=0;x<P.outW;++x){
            float xs = ( (float)x + 0.5f ) * sx - 0.5f;
            uint8_t* pd = &drow[x*4];

            switch (P.filter){
            case ScaleFilter::Nearest:
                sample_nearest_BGRA32(src, xs, ys, P.border, fill, pd);
                break;
            case ScaleFilter::Bilinear:
                sample_bilinear_BGRA32(src, xs, ys, P.border, fill, pd);
                break;
            case ScaleFilter::Bicubic:
            default:
                sample_bicubic_BGRA32(src, xs, ys, P.border, fill, pd, cubicA);
                break;
            }
        }
    }
}

// 배율 기반 래퍼 (aspect 유지/무시 선택은 UI에서 계산)
inline void ResizeByScale_BGRA32(const IppDib& src, IppDib& dst, float fx, float fy,
                                 ScaleFilter filt=ScaleFilter::Bicubic, BorderMode bm=BorderMode::Replicate)
{
    ResizeParams P;
    P.outW = std::max(1, (int)std::lround(src.width()  * fx));
    P.outH = std::max(1, (int)std::lround(src.height() * fy));
    P.filter=filt; P.border=bm;
    Resize_BGRA32(src, dst, P, -0.5f);
}
```

**구현 포인트**  
- 좌표는 **픽셀 센터 정렬**: \((x+0.5)s - 0.5\).  
- 바이큐빅은 **Keys 커널**(a=-0.5, Catmull-Rom)로 구현. 더 부드럽게 하고 싶다면 a=-0.75 정도로 조정 가능.  
- 경계는 Constant/Replicate/Wrap. (Reflect/미러는 필요 시 확장)

---

## 3) 크기 변환 대화 상자 만들기

**기능 요건**  
- **출력 크기**: 폭/높이(px) 입력  
- **배율**: 폭/높이(%) 입력  
- **가로세로비 유지** 체크(Keep Aspect)  
- **필터** 선택: Nearest / Bilinear / Bicubic  
- **경계**: Constant/Replicate/Wrap, Constant일 때 **Fill RGB** 입력  
- **동기화 규칙**:  
  - 퍼센트 변경 → 픽셀 즉시 갱신  
  - 픽셀 변경 → 퍼센트 즉시 갱신  
  - Keep Aspect ON → 한 쪽 변경 시 다른 쪽 자동 반영  
  - 재입력 루프 방지(가드 플래그)

### 3.1 리소스 추가

```
// resource.h (추가)
#define IDD_RESIZE_DLG                 1000
#define IDC_EDIT_RS_W_PIX              2201
#define IDC_EDIT_RS_H_PIX              2202
#define IDC_EDIT_RS_W_PCT              2203
#define IDC_EDIT_RS_H_PCT              2204
#define IDC_CHK_RS_KEEP                2205
#define IDC_RAD_RS_NEAREST             2206
#define IDC_RAD_RS_BILINEAR            2207
#define IDC_RAD_RS_BICUBIC             2208
#define IDC_RAD_RS_BORDER_CONST        2209
#define IDC_RAD_RS_BORDER_REPL         2210
#define IDC_RAD_RS_BORDER_WRAP         2211
#define IDC_EDIT_RS_R                  2212
#define IDC_EDIT_RS_G                  2213
#define IDC_EDIT_RS_B                  2214

// 메뉴
#define ID_TRANSFORM_RESIZE_DLG        62020
```

```
// ImageTool.rc (추가)
IDD_RESIZE_DLG DIALOGEX 0,0, 280, 178
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Resize (Scale)"
FONT 9, "Segoe UI"
BEGIN
    LTEXT "Size (px):", -1, 12, 14, 50, 10
    LTEXT "W", -1, 70, 14, 8, 10
    EDITTEXT IDC_EDIT_RS_W_PIX, 80, 12, 46, 14, ES_NUMBER | WS_TABSTOP
    LTEXT "H", -1, 132, 14, 8, 10
    EDITTEXT IDC_EDIT_RS_H_PIX, 142, 12, 46, 14, ES_NUMBER | WS_TABSTOP
    AUTOCHECKBOX "Keep aspect", IDC_CHK_RS_KEEP, 200, 14, 70, 10

    LTEXT "Scale (%):", -1, 12, 36, 50, 10
    LTEXT "W%", -1, 70, 36, 12, 10
    EDITTEXT IDC_EDIT_RS_W_PCT, 84, 34, 42, 14, ES_AUTOHSCROLL | WS_TABSTOP
    LTEXT "H%", -1, 132, 36, 12, 10
    EDITTEXT IDC_EDIT_RS_H_PCT, 146, 34, 42, 14, ES_AUTOHSCROLL | WS_TABSTOP

    GROUPBOX "Filter", -1, 12, 56, 110, 42
    AUTORADIOBUTTON "Nearest",  IDC_RAD_RS_NEAREST, 20, 70, 60, 10, WS_TABSTOP
    AUTORADIOBUTTON "Bilinear", IDC_RAD_RS_BILINEAR,20, 82, 60, 10
    AUTORADIOBUTTON "Bicubic",  IDC_RAD_RS_BICUBIC, 20, 94, 60, 10

    GROUPBOX "Border", -1, 130, 56, 70, 42
    AUTORADIOBUTTON "Const",    IDC_RAD_RS_BORDER_CONST, 136, 70, 40, 10, WS_TABSTOP
    AUTORADIOBUTTON "Repl",     IDC_RAD_RS_BORDER_REPL,  136, 82, 40, 10
    AUTORADIOBUTTON "Wrap",     IDC_RAD_RS_BORDER_WRAP,  136, 94, 40, 10

    LTEXT "Fill RGB:", -1, 210, 60, 50, 10
    EDITTEXT IDC_EDIT_RS_R, 210, 72, 20, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_RS_G, 234, 72, 20, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_RS_B, 258, 72, 20, 14, ES_NUMBER

    DEFPUSHBUTTON "OK", IDOK,  160, 146, 50, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 214, 146, 50, 16
END

// 메뉴 (일부)
POPUP "&Transform"
BEGIN
    MENUITEM "Resize...\tCtrl+R", ID_TRANSFORM_RESIZE_DLG
END

IDR_ACCEL ACCELERATORS
BEGIN
    "R", ID_TRANSFORM_RESIZE_DLG, VIRTKEY, CONTROL
END
```

### 3.2 대화 상자 로직 (초기화 & 컨트롤 동작 제어)

```
/* ResizeDlg.h */
#pragma once
#include <windows.h>
#include "resource.h"
#include "Resize.h"

class ResizeDlg {
public:
    ResizeDlg(HWND owner, IppDib& dib): owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);

    void SyncFromPixel(HWND h, bool fromW);  // keep aspect 고려하여 % 업데이트
    void SyncFromPercent(HWND h, bool fromW); // % → 픽셀
    int  ClampPos(int v, int lo, int hi) const { return (v<lo)?lo:((v>hi)?hi:v); }
    float ReadFloat(HWND h, int id, float def=100.f) const;
    int   ReadInt  (HWND h, int id, int def) const;

private:
    HWND   owner_=nullptr;
    IppDib& dib_;
    int W0=0, H0=0;         // 원본 크기
    bool changing_=false;   // 재진입 방지
};
```

```
/* ResizeDlg.cpp */
#include "ResizeDlg.h"

INT_PTR ResizeDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_RESIZE_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK ResizeDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(ResizeDlg*)l; return self->OnInit(h); }
    auto* self=(ResizeDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w,l);
    return FALSE;
}
INT_PTR ResizeDlg::OnInit(HWND h){
    W0 = dib_.width(); H0 = dib_.height();

    SetDlgItemInt(h, IDC_EDIT_RS_W_PIX, W0, FALSE);
    SetDlgItemInt(h, IDC_EDIT_RS_H_PIX, H0, FALSE);
    SetDlgItemTextW(h, IDC_EDIT_RS_W_PCT, L"100");
    SetDlgItemTextW(h, IDC_EDIT_RS_H_PCT, L"100");

    CheckDlgButton(h, IDC_CHK_RS_KEEP, BST_CHECKED);

    CheckRadioButton(h, IDC_RAD_RS_NEAREST, IDC_RAD_RS_BICUBIC, IDC_RAD_RS_BICUBIC);
    CheckRadioButton(h, IDC_RAD_RS_BORDER_CONST, IDC_RAD_RS_BORDER_WRAP, IDC_RAD_RS_BORDER_REPL);

    SetDlgItemInt(h, IDC_EDIT_RS_R, 0, FALSE);
    SetDlgItemInt(h, IDC_EDIT_RS_G, 0, FALSE);
    SetDlgItemInt(h, IDC_EDIT_RS_B, 0, FALSE);
    return TRUE;
}
float ResizeDlg::ReadFloat(HWND h, int id, float def) const {
    wchar_t buf[64]; GetDlgItemTextW(h,id,buf,64);
    wchar_t* e=nullptr; double v=wcstod(buf,&e);
    if (e==buf) return def; return (float)v;
}
int ResizeDlg::ReadInt(HWND h, int id, int def) const {
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE);
    if (!ok) return def; return v;
}

void ResizeDlg::SyncFromPixel(HWND h, bool fromW){
    if (changing_) return; changing_=true;
    int W = ReadInt(h, IDC_EDIT_RS_W_PIX, W0);
    int H = ReadInt(h, IDC_EDIT_RS_H_PIX, H0);
    bool keep = (IsDlgButtonChecked(h, IDC_CHK_RS_KEEP)==BST_CHECKED);

    W = ClampPos(W, 1, 1<<15);
    H = ClampPos(H, 1, 1<<15);

    if (keep){
        if (fromW) H = std::max(1, (int)std::lround((double)W * (double)H0 / (double)W0));
        else       W = std::max(1, (int)std::lround((double)H * (double)W0 / (double)H0));
        SetDlgItemInt(h, IDC_EDIT_RS_W_PIX, W, FALSE);
        SetDlgItemInt(h, IDC_EDIT_RS_H_PIX, H, FALSE);
    }
    int wPct = (int)std::lround(100.0 * (double)W / (double)W0);
    int hPct = (int)std::lround(100.0 * (double)H / (double)H0);
    wchar_t bw[16], bh[16]; swprintf(bw,16,L"%d",wPct); swprintf(bh,16,L"%d",hPct);
    SetDlgItemTextW(h, IDC_EDIT_RS_W_PCT, bw);
    SetDlgItemTextW(h, IDC_EDIT_RS_H_PCT, bh);
    changing_=false;
}
void ResizeDlg::SyncFromPercent(HWND h, bool fromW){
    if (changing_) return; changing_=true;
    float wPct = ReadFloat(h, IDC_EDIT_RS_W_PCT, 100.f);
    float hPct = ReadFloat(h, IDC_EDIT_RS_H_PCT, 100.f);
    bool keep = (IsDlgButtonChecked(h, IDC_CHK_RS_KEEP)==BST_CHECKED);

    if (keep){ if (fromW) hPct = wPct; else wPct = hPct; }

    int W = std::max(1, (int)std::lround((double)W0 * (double)wPct / 100.0));
    int H = std::max(1, (int)std::lround((double)H0 * (double)hPct / 100.0));

    SetDlgItemInt(h, IDC_EDIT_RS_W_PIX, W, FALSE);
    SetDlgItemInt(h, IDC_EDIT_RS_H_PIX, H, FALSE);
    changing_=false;
}

INT_PTR ResizeDlg::OnCommand(HWND h, WPARAM w, LPARAM){
    switch (LOWORD(w)){
    // 픽셀 입력 변경
    case IDC_EDIT_RS_W_PIX: if (HIWORD(w)==EN_CHANGE) { SyncFromPixel(h, /*fromW=*/true);  return TRUE; } break;
    case IDC_EDIT_RS_H_PIX: if (HIWORD(w)==EN_CHANGE) { SyncFromPixel(h, /*fromW=*/false); return TRUE; } break;
    // 퍼센트 입력 변경
    case IDC_EDIT_RS_W_PCT: if (HIWORD(w)==EN_CHANGE) { SyncFromPercent(h, /*fromW=*/true);  return TRUE; } break;
    case IDC_EDIT_RS_H_PCT: if (HIWORD(w)==EN_CHANGE) { SyncFromPercent(h, /*fromW=*/false); return TRUE; } break;

    case IDOK: {
        int outW = ReadInt(h, IDC_EDIT_RS_W_PIX, W0);
        int outH = ReadInt(h, IDC_EDIT_RS_H_PIX, H0);
        outW = ClampPos(outW, 1, 1<<15);
        outH = ClampPos(outH, 1, 1<<15);

        ResizeParams P; P.outW=outW; P.outH=outH;

        if (IsDlgButtonChecked(h, IDC_RAD_RS_NEAREST)==BST_CHECKED) P.filter=ScaleFilter::Nearest;
        else if (IsDlgButtonChecked(h, IDC_RAD_RS_BILINEAR)==BST_CHECKED) P.filter=ScaleFilter::Bilinear;
        else P.filter=ScaleFilter::Bicubic;

        if (IsDlgButtonChecked(h, IDC_RAD_RS_BORDER_REPL)==BST_CHECKED) P.border=BorderMode::Replicate;
        else if (IsDlgButtonChecked(h, IDC_RAD_RS_BORDER_WRAP)==BST_CHECKED) P.border=BorderMode::Wrap;
        else P.border=BorderMode::Constant;

        P.fillR=(uint8_t)ReadInt(h, IDC_EDIT_RS_R, 0);
        P.fillG=(uint8_t)ReadInt(h, IDC_EDIT_RS_G, 0);
        P.fillB=(uint8_t)ReadInt(h, IDC_EDIT_RS_B, 0);
        P.fillA=255;

        IppDib out; Resize_BGRA32(dib_, out, P, -0.5f);
        dib_ = out;
        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL:
        EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

---

## 4) 크기 변환 메뉴 만들기 (연동)

```
/* main_multiwin.cpp (발췌) */
#include "ResizeDlg.h"

// ...
case ID_TRANSFORM_RESIZE_DLG:
    if (st && st->dib) {
        ResizeDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK) {
            InvalidateRect(hWnd, nullptr, FALSE);
            OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 5) 실전 예제 & 상황

### 예제 A) 썸네일 생성 (축소)
- **상황**: 4000×3000 사진을 800×600 썸네일로.  
- **동작**: `Transform → Resize…`에서 **W=800, Keep aspect ON** → H 자동 600.  
  필터 **Bicubic**, Border **Replicate**.  
- **결과**: 자연스러운 축소. 세부 무늬가 많은 사진에서는 약간의 앨리어싱이 남을 수 있는데, 그럴 땐 한 번 더 **Gaussian σ≈0.6** 후 축소하거나, 단계적 축소(2배씩)로 개선.

### 예제 B) UI 스프라이트 확대 (픽셀 아트)
- **상황**: 64×64 아이콘을 256×256으로 확대, **계단/블러 방지**.  
- **동작**: 필터 **Nearest**, Border **Constant(0,0,0)**.  
- **결과**: 픽셀이 “뚜렷”하게 확대되어 레트로 감성 유지.

### 예제 C) 사진 경미한 업스케일
- **상황**: 1920×1080 → 2560×1440(1.333×).  
- **동작**: 필터 **Bicubic**(a=-0.5), Border **Replicate**.  
- **결과**: Bilinear 대비 선명하며 링잉은 적당히 제어. 너무 소프트하면 **Sharpen(USM σ=1.0, amount=0.4)** 를 후행으로 살짝.

### 예제 D) 배경 타일 제작 (Wrap 검사)
- **상황**: 텍스처 타일링 확인용으로 1024→1200×1200 비정수 확대.  
- **동작**: Border **Wrap**, 필터 **Bilinear**.  
- **결과**: 가장자리 샘플이 반대편에서 채워져 **심(Seam) 검사**에 유용.

---

## 6) 구현/품질 팁

1) **픽셀 센터 정렬**  
   - \((x+0.5)s-0.5\) 는 확대/축소 전후의 **정합성**을 높입니다.  
   - 다른 툴(예: OpenCV/Photoshop)의 모드와 혼용 시 위치 오프셋이 생길 수 있으니 규약을 문서화하세요.

2) **바이큐빅 파라미터 a**  
   - \(a=-0.5\) (Catmull-Rom): 선명/살짝 링잉 가능.  
   - \(a\in[-0.75,-0.3]\): 더 부드럽거나 더 또렷하게 조절.

3) **다운스케일 고품질**  
   - 큰 축소 비율에서는 **평균형(Area/Box)** 나 **Lanczos** 가 더 안정적.  
   - 간단 대안: 축소 전 **소량 Gaussian**(σ≈0.5~1.0)로 에일리어싱 억제.

4) **경계 모드**  
   - 사진/자연영상: **Replicate** 가 자연스러움.  
   - 텍스처 타일링: **Wrap**.  
   - 로고/합성: **Constant**(배경색 지정).

5) **성능**  
   - 멀티스레딩(행 분할) / SIMD(SSE/AVX/NEON)로 속도 개선.  
   - Bicubic은 16 샘플/픽셀 → 두 패스(수평→수직) 분리로 캐시 효율을 올릴 수 있음(고급 최적화).

6) **알파**  
   - 본 구현은 A도 동일 보간. (프리멀티플라이를 사용한다면 보간 전에 선형공간에서 처리 필요)

---

## 7) 수학 메모

- **양선형**:  
\[
\begin{aligned}
I(x_s,y_s) &\approx (1-a_x)(1-a_y)I(x_0,y_0) + a_x(1-a_y)I(x_1,y_0) \\
&\quad + (1-a_x)a_y I(x_0,y_1) + a_x a_y I(x_1,y_1),\\
a_x&=x_s-\lfloor x_s\rfloor,\quad a_y=y_s-\lfloor y_s\rfloor.
\end{aligned}
\]

- **바이큐빅(분리형 3차)**:  
\[
I(x_s,y_s)\approx \sum_{j=-1}^{2}\sum_{i=-1}^{2} I(x_0+i,y_0+j)\,w_x(i)\,w_y(j),
\]
\[
w_x(i)=\phi(i-t_x),\quad t_x=x_s-x_0,
\]
\(\phi(\cdot)\) 는 Keys cubic 커널(매개변수 \(a\)).

---

## 8) 요약
- 좌표 매핑은 **픽셀 센터 정렬**을 채택.  
- **최근접/양선형/바이큐빅**을 구현하고, **경계 3종**(Constant/Replicate/Wrap) 지원.  
- **크기 변환 대화 상자**에서 픽셀/퍼센트/가로세로비/필터/경계를 직관적으로 제어.  
- 실전 예제로 썸네일/픽셀아트/사진 업스케일/타일 검사를 다룸.  
- 더 높은 축소 품질이 필요하면 **평균형/랜초스** 또는 **사전 블러**를 고려하세요.