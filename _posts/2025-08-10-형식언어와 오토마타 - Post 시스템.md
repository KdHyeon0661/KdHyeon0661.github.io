---
layout: post
title: 형식언어와 오토마타 - Post 시스템
date: 2025-08-10 17:20:23 +0900
category: 형식언어와 오토마타
---
# 총정리

**Post canonical system / Post production system / Post normal system / Post tag system**

포스트(Post) 시스템은 **재작성(rewriting)** 기반의 보편 계산 모델 계열이다.
문법·오토마타와 나란히 **형식 언어**를 생성/인식하고, 그 변형들 중 상당수가 **튜링 기계와 동등**한 표현력을 가진다.
이 글은 넓은 의미의 “Post 시스템”을 다음 네 축으로 정리한다.

- **Post canonical system (PCS)** = Post 생산/재작성 시스템(가장 일반적 형태)
- **semi-Thue / Thue 시스템**(재작성 규칙형)
- **Post normal system**(제약된 정규형)
- **Post tag system**(삭제 수 \(m\)을 갖는 태그 시스템)

---

## 큰 그림 요약

- **표현력**
  - PCS(및 동치 모델인 semi-Thue)는 **RE(=c.e.) 언어 전체**를 생성한다.
    $$\boxed{\text{PCS 언어} = \text{Type-0(무제한) 문법 언어} = \text{TM 수용 언어(RE)}}$$
  - Post **normal** system, **tag** system(\(m\ge 2\))도 **튜링 완전**(TM과 상호 시뮬 가능).
- **결정 성질**
  - 멤버십은 일반적으로 **반결정 가능(RE)**, 전반적 **결정 불가능**.
  - 공백성/보편성/포함/동치 등 전역 속성은 대부분 **결정 불가능**(Rice/감소).
- **감소(변형) 레시피**
  - **정지 문제/PCP**를 **문맥 국소 제약**(접두/접미, 경계 마커, 구분자 `#`)로 암호화하고,
    **시작/종료 가젯**으로 올바른 계산만이 “해”가 되게 만든다.

---

## Post canonical system (PCS)

### 형식 정의(대표적 버전)

알파벳 \(\Sigma\)와 **단 하나의 변수 기호** `\$`를 쓴다.
PCS는 4튜플 \((\Sigma, \$, A, P)\).

- **공리(axioms)** \(A \subseteq \Sigma^*\) — 시작 문자열 집합(변수 없음)
- **규칙 집합** \(P\): 두 스키마
  1) **정상(문자열-보존)**
     $$g\,\$\,h \;\to\; k\,\$\,\ell \qquad (g,h,k,\ell\in\Sigma^*)$$
     의미: 임의의 \(u\in\Sigma^*\)에 대해
     $$g\,u\,h \Rightarrow k\,u\,\ell$$
  2) **종결(변수 소거)**
     $$\$ \;\to\; w \qquad (w\in\Sigma^*)$$

- **유도(derivation)**: \(x\Rightarrow y\)는 규칙 1회 적용, \(\Rightarrow^*\)는 그 반사추이적 폐포
- **생성 언어**
  $$L(\text{PCS})=\{\,w\in\Sigma^* \mid \exists a\in A: a\Rightarrow^* w\,\}$$

> 포인트: 규칙에는 **변수 `\$`가 정확히 한 번** 등장하며, 좌·우 **문맥**을 바꾸면서 변수 자리에 임의 문자열을 **보존/이동**한다.

---

### 미니 예시 — \(L=\{a^n b^n\mid n\ge 1\}\)

```text
Alphabet Σ = {a, b}
Axioms A = { $ }
Rules P:
  $  -> a $ b     # 반복(문맥 첨가)
  $  -> ab        # 종결(변수 제거)
```

유도:
```
$ ⇒ a $ b ⇒ a a $ b b ⇒ ⋯ ⇒ a^k $ b^k ⇒ a^{k+1} b^{k+1}
```
모든 \(n\ge1\)에 대해 \(a^n b^n\) 생성.

---

### 멤버십(반결정)과 열거기

PCS는 RE이므로 **열거기**가 존재한다. 아래는 “공리에서 유도 길이를 도베일링”하여 문자열을 **열거**하고, 목표 \(w\)를 만나면 **accept**하는 반결정 절차다.

```text
# 입력: w
# 출력: 'YES'면 w∈L(PCS). 'NO'는 반환되지 않을 수 있음(무한루프).

Membership_SEMI_DECIDE(PCS, w):
  for d = 0,1,2,3,...:                 # 도베일링: 유도 깊이 상한
    for each axiom a in A:
      for each derivation a ⇒* x with ≤ d steps:
        if x == w: return YES
  # w∉L이면 종료하지 않을 수 있음
```

---

### 성질(핵심만)

- **표현력**: RE 전체 (= TM 수용 언어)
- **닫힘**: 합/연접/Kleene★/역순/역호모 등에 **닫힘**(RE 표준 폐포)
- **결정 불가능**: 공백성/보편성/포함/동치/유도가능성(Word Problem) 등

---

## semi-Thue / Thue 시스템

### semi-Thue (단방향 재작성)

- **정의**: 규칙 집합 \(R\subseteq\Sigma^*\times\Sigma^*\) (각 규칙 \(\alpha\to\beta\))
- **스텝**: 임의의 문맥에서 부분문자열 \(\alpha\)를 \(\beta\)로 치환
  $$x = s\alpha t \Rightarrow y = s\beta t$$

```text
Σ = {a,b,X}
A = {X}
R:
  X  -> a X b
  X  -> ab
```

- **언어**: \(L=\{y \mid \exists a\in A: a\Rightarrow^* y\}\)

### Thue (쌍방향 재작성)

- 규칙이 **대칭**(\(\alpha \leftrightarrow \beta\))
- **Word Problem**(문자열 동치 여부)은 일반적으로 **결정 불가능**

### semi-Thue ↔ PCS 변환 스케치

- **semi-Thue → PCS**: 규칙 \(\alpha\to\beta\)를 “문맥 포착 + 변수 보존”으로 분해
  - 아이디어: \(\alpha\)의 내부에 `\$`를 배치, 좌우 문맥을 \(g,h\)로, 결과를 \(k,\ell\)로 나눠 **한 변수 PCS 규칙**에 적합화
- **PCS → semi-Thue**: \(g\$h\to k\$\ell\) 를 모든 \(u\)에 대해 \(guh\to kuh\)로 해석하는 **치환 스킴**을 도입

> 결론: **동치**(효과적 변환). 따라서 **표현력(RE)** 이 동일.

---

## Post **normal system**(정규형)

### 정의(대표 스키마)

변수 \(X\)가 한 번 등장하고, 규칙이 다음 꼴로 **단조화**:
$$
g\,X \to X\,h \qquad\text{(+ 종결 } X\to w)
$$

- 의도: \(X\)가 문자열 내부를 **미끄러지듯 이동**하며, 좌/우 문맥을 **축적/재배열**한다.
- **정규형 정리**: 이러한 제약만으로도 **RE 전체**를 생성 가능(튜링 완전).

### 소규모 예시

```text
Σ = {a,b}, 변수 X
Rules:
  a X -> X a     # a들을 오른쪽으로 밀어내기
  X b -> b X     # b들과 재배열
  X   -> ε       # 종결
Axioms: { X a b }
```

- \(X\)가 이동하며 구조를 정리한 뒤, 마지막에 제거.

### 왜 유용한가?

- 감수(감소)에서 **규칙 형태를 표준화**하여
  “복잡한 전이”를 “단조로운 패턴(좌측 고정, 우측 축적)”으로 바꾸면 **로컬 제약 설계**가 쉬워진다.

---

## Post **tag system**(태그 시스템)

### 작동 규칙

- 파라미터: **삭제 수** \(m\ge1\), **생성 규칙** \(a\mapsto w_a\) (각 \(a\in\Sigma\))
- 현재 문자열이 \(a_1 a_2 \cdots a_k\) (\(k\ge m\))이면:
  1) **앞에서 \(m\)** 글자 **삭제**
  2) **첫 글자 \(a_1\)** 에 대응하는 꼬리 \(w_{a_1}\)를 **뒤에 덧붙임**
- 길이가 \(<m\)이 되면 **정지**

```text
# 예시

Σ = {a, b}
Rules: a -> ab,  b -> a
start = a a b a

step1: a a b a    → delete 'a a' → [b a], append 'ab' → b a a b
step2: b a a b    → delete 'b a' → [a b], append 'a'  → a b a
...
```

### 표현력과 결정 성질

- \(m\ge 2\)인 **tag** 시스템은 **튜링 완전**
- **정지 여부**(특정 시작어에서 유한 단계 후 멈추는가?)는 **결정 불가능**
  → 정지 문제에서의 표준 **감소**로 입증 가능

---

## TM ↔ PCS / semi-Thue **상호 시뮬레이션**

### TM → PCS (전이 한 스텝의 로컬화)

- **구성 인코딩**
  - 테이프를 좌/우로 나눠 구분자 `#`로 묶고, 헤드 위치와 상태를 중앙에 표기:
    $$
    \underbrace{a_i\cdots a_2 a_1}_{\text{좌측(역순)}}\ \#\ \underbrace{q\,b_0}_{\text{상태/헤드}}\ \underbrace{b_1 b_2\cdots}_{\text{우측}}
    $$
- **전이 모사**
  - TM 전이 \((q,x)\mapsto(p,y,\mathrm{L/R})\) 마다, 변수 `\$`를 포함한 **문맥 규칙** \(g\$h\to k\$\ell\) 설계
  - 예: **오른쪽 이동**의 경우, 헤드 오른쪽 문자를 변수로 잡아 교환/기록을 로컬하게 적용
- **수용/거절**
  - 수용 상태에 도달하면 `\$→w_{\text{ACC}}` 같은 **종결 규칙**으로 산출을 종결

```text
# 개념 스니펫(구체 기호화는 설계에 따라 다름)

... L # q x R ...   ⇒   ... L y # p R ...     (R-이동; y를 기록, 상태 p로)
```

> 핵심: **단 한 번 등장하는 변수**로 “관심 구간”을 잡고, 전이를 **국소 치환**으로 캡슐화.

### PCS → TM (규칙 매칭 시뮬레이션)

- TM은 “모든 규칙에 대해, 모든 위치의 **패턴 매칭**을 탐색”하고, 매칭되면 **치환**을 수행
- 한 스텝이 유한 시간에 모사되므로 전체 유도를 **TM이 재현** 가능

> 결론: **PCS ≡ semi-Thue ≡ TM(Type-0 문법)** — **RE 언어** 생성/인식에서 동치

---

## 결정 문제 & 복잡도 표

| 문제 | PCS / semi-Thue / Normal / Tag |
|---|---|
| **멤버십** \(w\in L?\) | **RE(반결정)** — 유도 탐색으로 예면 언젠가 수용 |
| **공백성** \(L=\varnothing?\) | **결정 불가능** |
| **보편성** \(L=\Sigma^*?\) | **결정 불가능** |
| **포함/동치** | **결정 불가능** (높은 산술 계층에 속하는 경우 다수) |
| **유도가능성** \(\alpha\Rightarrow^*\beta?\) | 일반적으로 **결정 불가능**(Word Problem) |
| **Tag 정지 여부**(m≥2) | **결정 불가능** |

---

## 예시 모음(설계 패턴 포함)

### semi-Thue로 \(L=\{a^n b^n\mid n\ge1\}\)

```text
Σ = {a, b, X}
A = { X }
R:
  X   -> a X b      # 균형 생성
  X   -> ab         # 종결
# 유도: X ⇒ a X b ⇒ ⋯ ⇒ a^k X b^k ⇒ a^{k+1} b^{k+1}

```

### (스케치)

아래 설계는 **마킹 + 동기화** 패턴을 PCS로 캡슐화한다(핵심 아이디어만).

- 기호 확장: \(\Sigma=\{a,b,c,\bar a,\bar b,\bar c,\#\}\)
- 규칙 아이디어
  1) `\$ → a $ b c` : 세 구간을 **동시에 1씩 증가**
  2) `\$ → abc` : 종결
  3) **안정화 규칙**: 중간 상태(마킹)를 정상 기호로 되돌리는 로컬 정규화
- 유도:
  ```
  $ ⇒ a $ b c ⇒ a a $ b b c c ⇒ ⋯ ⇒ a^n $ b^n c^n ⇒ a^n b^n c^n
  ```

> 실제 완전한 규칙군은 “마킹의 유일성”과 “엣지 정렬”을 위해 몇 줄 더 필요하지만,
> **변수 한 개**로도 세 구간 동기 증가를 **문맥 첨가**로 구현 가능하다는 점이 핵심.

### Post **normal** system 맛보기(변수 이동)

```text
Σ = {a,b}, 변수 X
A = { a a X b }
Rules:
  a X -> X a
  X b -> b X
  X   -> ε
# 해석: a a X b ⇒ a X a b ⇒ X a a b ⇒ b X a a ⇒ b a a
# X가 좌측 a를 우측으로 넘기며 b와 재배열, 마지막에 제거

```

### 시뮬(정지/주기적 패턴)

```text
m = 2
Σ = {a,b,c}
Rules:
  a -> bc
  b -> a
  c -> ε
start = a a b c

# step1: a a b c  → delete 'a a' → [b c], append 'bc' → b c b c
# step2: b c b c  → delete 'b c' → [b c], append 'a'  → b c a
# step3: b c a    → delete 'b c' → [a],   append 'a'  → a a
# step4: a a      → delete 'a a' → [ ],   append 'bc' → b c   (길이 2 유지)
# step5: b c      → delete 'b c' → [ ],   append 'a'  → a
# step6: a        → length < m   → 정지

```

- 같은 규칙이라도 **초기어**에 따라 **정지/주기/혼돈**이 달라진다.
- “주어진 규칙·시작어가 **정지**하는가?”는 \(m\ge2\)에서 **결정 불가능**.

---

## **레시피** — Post 계열로 “불가능” 들이밀기

1) **상태·헤드·테이프**를 **문맥**(접두 \(g\), 접미 \(h\))에 부호화
2) **변수 한 개**로 “관심 구간(헤드 근처)”을 가리키고, 우변에서 재사용해 **정보 보존**
3) **시작/종료 가젯**: 공리를 초기 구성으로 고정, 수용 시 전용 마커로 닫기
4) **구분자 `#`/마커**: 행·열 정렬, 경계 표시, 로컬 검사를 글로벌 일관성으로 끌어올리기
5) **양방향 정직성**:
   - (⇒) 원문제가 YES면 유도 규칙으로 **해 구성 가능**
   - (⇐) 해가 나오면 규칙의 **로컬 제약상** 반드시 올바른 수용 계산에 대응

---

## 알고리즘 스니펫 모음

### 언어 **열거기**(PCS → RE 열거)

```text
Enumerate_L(PCS):
  # 공리에서 시작하여 유도 깊이를 키워가며 모든 결과를 출력
  S := queue()
  for a in A: enqueue(S, a)
  seen := ∅
  while true:
    x := dequeue(S)
    if x not in seen:
      output(x)             # 언어의 한 원소를 방출
      seen := seen ∪ {x}
      for each rule in P:
        for each match position of rule in x:
          y := apply(rule at position, x)
          enqueue(S, y)
```

- **정규화**(중복 방지)·**도베일링**(깊이 균형)을 섞으면 공정한 열거가 가능.

### 멤버십 **반결정**(열거기 기반)

```text
SemiDecide(PCS, w):
  for x in Enumerate_L(PCS):
    if x == w: return YES
  # NO는 보장 없음(무한)
```

### TM → PCS **규칙 생성기**(개념적)

```text
Build_PCS_from_TM(TM):
  Σ' := TapeAlphabet ∪ {#, markers}
  A  := { EncodeInitial(TM) }              # <u># q0 a0 v 형태 등
  P  := ∅
  for each transition (q, x) -> (p, y, dir) in TM.Δ:
     rule := make_local_rule(q, x, p, y, dir)   # g $ h -> k $ ℓ
     P := P ∪ { rule }
  P := P ∪ { $ -> w_ACC, $ -> w_REJ }      # 종결 규칙(선택적)
  return PCS(Σ', $, A, P)
```

---

## 문법·오토마타·논리와의 연계

- **PCS ↔ Type-0 문법**: 무제한 문법의 임의 규칙을 **한 변수 재작성**으로 표준화 가능
- **RE/Recursive**: PCS가 생성하는 언어는 **RE**. 보수까지 다루는 **결정기**는 일반적으로 **불가능**(Rice)
- **결정 가능한 구역**을 원할 때
  - **정규/문맥 자유** 등 **제한 문법**으로 문제를 재정의
  - 정규 제약과의 **교집합**으로 파서를 얹어 **P-시간** 영역으로 끌어내기

---

## FAQ(자주 묻는 질문)

**Q1. PCS는 왜 변수 `\$`를 하나만 쓰나요?**
A. 두 개 이상 변수도 가능하지만, **한 변수만으로도** RE 전체를 생성할 수 있어 **정규형으로 충분**하다.

**Q2. PCS와 semi-Thue 중 무엇을 쓰면 좋나요?**
A. **로컬 부분문자열 치환**을 직접 다루려면 semi-Thue, **문맥 기반** 설계를 선호하면 PCS가 깔끔하다. 서로 변환 가능.

**Q3. Tag 시스템은 왜 정지 여부가 어려운가요?**
A. **삭제+추가**의 간단한 로컬 규칙이지만, 전역 동작은 TM의 계산을 그대로 **암호화**할 수 있다(튜링 완전).

**Q4. normal system은 제약이 있는데도 왜 튜링 완전인가요?**
A. 변수 이동과 문맥 축적만으로 임의의 계산의 **전이 테이블**을 시뮬할 수 있다(정규형 정리).

---

## 한 페이지 요약

- **PCS / semi-Thue / normal / tag(≥2)**: 모두 **보편 계산**의 다른 얼굴
- **PCS 언어 = RE 언어**: Type-0(무제한) 문법, TM 수용 언어와 동치
- **전역 성질**: 공백/보편/포함/동치/정지류는 대체로 **결정 불가능**
- **감소 실전술**: **문맥 규칙 + 시작/종료 가젯 + 구분자**로 TM/PCP를 암호화

---

### 부록 A — 미니 BNF/재작성 스니펫

```bnf
# PCS 스타일: { a^n b^n | n≥1 }

Σ = {a,b}, A = { $ }
$   -> a $ b
$   -> ab
```

```text
# semi-Thue: { a^n b^n | n≥1 }

Σ = {a,b,X}
A = { X }
R:
  X  -> a X b
  X  -> ab
```

```text
# normal system(개념): 변수 이동으로 재배열 후 종결

Axioms: { a a X b }
Rules:
  a X -> X a
  X b -> b X
  X   -> ε
```

```text
# 규칙 예

m = 2
Σ = {a,b,c}
a -> bc
b -> a
c -> ε
start = a a b c
```

---

### 부록 B — 용어 미니 사전

- **PCS**: 한 변수 `\$`가 든 문맥 재작성 스키마
- **semi-Thue/Thue**: 단방향/양방향 부분문자열 치환 시스템
- **normal system**: \(gX\to Xh\) 꼴로 표준화된 PCS
- **tag system**: 앞 \(m\)글자 삭제 + 규칙에 따른 꼬리 추가
- **RE(c.e.)**: 반결정 가능. 열거기는 있으나 보수에 닫히지 않음
- **Type-0 문법**: 무제한 생산 규칙(촘스키 최상위)
- **Word Problem**: 재작성 동치/유도가능성 판정 문제
