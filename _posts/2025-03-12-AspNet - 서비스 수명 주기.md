---
layout: post
title: AspNet - 서비스 수명 주기
date: 2025-03-12 19:20:23 +0900
category: AspNet
---
# ASP.NET Core의 서비스 수명 주기(Scoped, Transient, Singleton)

## 한눈에 보는 DI와 Lifetime

### DI 등록 위치

- `.NET 6+` 템플릿 기준 `Program.cs`가 **컴포지션 루트(Composition Root)**.
- 여기에 서비스 등록(수명 주기 지정) → **프레임워크가 생성/주입/수거**를 책임.

```csharp
var builder = WebApplication.CreateBuilder(args);

// 수명 주기별 등록
builder.Services.AddTransient<ITransient, TransientImpl>();
builder.Services.AddScoped<IScoped, ScopedImpl>();
builder.Services.AddSingleton<ISingleton, SingletonImpl>();
```

### 수명 주기 요약

| Lifetime     | 생성 시점                              | 공유 범위                          | 대표 용도                                   |
|--------------|----------------------------------------|------------------------------------|---------------------------------------------|
| Transient    | **요청 시마다** 새 인스턴스             | 없음                                | 경량/무상태 서비스, 순수 계산, 헬퍼         |
| Scoped       | **HTTP 요청 당 1개**                    | 요청 범위                           | 비즈니스 로직, `DbContext`, 유스케이스      |
| Singleton    | **앱 시작~종료까지 1개**                | 애플리케이션 전체                    | 캐시, 구성/카탈로그, 공유 리소스(스레드안전)|

시각화:

```text
요청1: Transient A / Scoped A / Singleton A
요청2: Transient B / Scoped B / Singleton A
요청3: Transient C / Scoped C / Singleton A
```

---

## Transient — 매번 신선한 인스턴스

### 특징

- 호출 때마다 새 객체. **상태를 보존하지 말 것**.
- 가볍고, 생성 비용이 낮은 컴포넌트에 적합.

### 예제: GUID로 관찰

```csharp
public interface IGuidService { Guid GetId(); }

public class TransientGuidService : IGuidService
{
    private readonly Guid _id = Guid.NewGuid();
    public Guid GetId() => _id;
}

// Program.cs
builder.Services.AddTransient<IGuidService, TransientGuidService>();
```

요청마다/주입할 때마다 **다른 Guid**가 확인된다.

### 주의

- 생성 비용이 크다면 캐싱/싱글턴 전환 고려(단, 스레드 안전성 확보 필요).

---

## Scoped — 요청 단위로 동일 인스턴스

### 특징

- **HTTP 요청 경계**로 생명주기 관리.
- EF Core `DbContext`의 권장 수명 주기.
- 하나의 요청 안에서 여러 컴포넌트가 **같은 인스턴스** 공유.

```csharp
builder.Services.AddScoped<IMyService, MyService>();
```

동일 요청 내에서 `MyService`는 항상 동일하다.

### 주의

- Scoped는 **동시에 여러 스레드**에서 접근하지 않는 것이 원칙.
- `DbContext`는 스레드-세이프가 아니므로 **병렬 작업에 공유 금지**.

---

## Singleton — 앱 전체에서 하나

### 특징

- 시작 시 1회 생성, 종료 시 해제.
- **스레드 안전** 설계가 필수: 불변(Immutable) 설계, 락, Concurrent 컬렉션 등을 고려.

```csharp
builder.Services.AddSingleton<ITimeProvider, TimeProvider>();
```

### 대표 용례

- 메타데이터/구성 캐시, Reference 데이터, `IHttpClientFactory`로 생성되는 **Typed Client(자체는 Transient이나 내부 핸들러 풀은 싱글턴적 수명)** 등.

---

## Lifetime 혼용 시 발생하는 대표 함정과 솔루션

### Singleton이 Scoped/Transient를 **직접 주입**(Constructor Injection)하면?

- ASP.NET Core 컨테이너는 **런타임에 예외**를 던진다:
  - “Cannot consume scoped service 'X' from singleton 'Y'”
- 이유: 수명이 더 짧은 객체를 더 긴 객체가 붙잡으면 **스코프 밖 사용**으로 누수/스레드 오류.

#### 해결책 A: 지연 해결(Lazy Resolve) — `IServiceScopeFactory`

```csharp
public class MySingleton
{
    private readonly IServiceScopeFactory _scopeFactory;
    public MySingleton(IServiceScopeFactory scopeFactory) => _scopeFactory = scopeFactory;

    public void DoWork()
    {
        using var scope = _scopeFactory.CreateScope();
        var scoped = scope.ServiceProvider.GetRequiredService<IScopedService>();
        scoped.Run();
    }
}
```

#### 해결책 B: 메시지/커맨드 큐로 경계 분리

- 싱글턴은 작업 요청만 큐에 넣고,
- 요청-스코프에서 소비(Consume)하며 Scoped 의존성 활용.

#### 해결책 C: 구성 재설계

- 싱글턴이 참조할 필요가 없도록 책임/경계를 재분배.

### Captive Dependency(포획된 의존성)

- **Scoped가 Transient을 캡처**하는 건 OK.
- **Singleton이 Scoped를 간접 보유**해 스코프 종료 후에도 살아있게 만드는 구조는 문제.
- “지연 해결 + 짧은 범위에서만 사용 + 즉시 폐기” 원칙으로 교정.

---

## 해제(Dispose)와 수명 주기 — 누수 방지 핵심

DI 컨테이너가 **자신이 생성한 IDisposable/IAsyncDisposable** 서비스의 수명에 맞춰 해제한다.

- **Transient**: 요청 스코프에서 생성되면 스코프 종료 시 해제.
- **Scoped**: 요청 종료 시 해제.
- **Singleton**: 앱 종료 시 해제.

### 주의 지점

- 컨테이너 밖에서 `new`로 직접 만든 IDisposable은 **직접 해제**해야 한다.
- `IAsyncDisposable`은 비동기 해제가 필요. 백그라운드에서 `await using` 활용.

```csharp
public class UsesStream : IAsyncDisposable
{
    private readonly Stream _s = new MemoryStream();
    public ValueTask DisposeAsync() => _s.DisposeAsync();
}
```

---

## 미들웨어, 컨트롤러/페이지, 최소 API에서의 Lifetime 규칙

### 컨트롤러/페이지/핸들러

- 기본적으로 **스코프**에서 만들어진다.
- 페이지/컨트롤러는 **Scoped 서비스 안전**.

### 전통 미들웨어(델리게이트 기반)

```csharp
app.Use(async (ctx, next) => {
    var scoped = ctx.RequestServices.GetRequiredService<IMyScoped>();
    await scoped.DoAsync();
    await next();
});
```
- 미들웨어 델리게이트는 앱 시작 때 등록되지만, **서비스는 요청 스코프에서 꺼내 사용**.

### 클래스형 미들웨어(IMiddleware)

```csharp
public class MyMiddleware : IMiddleware
{
    private readonly IMyScoped _svc;
    public MyMiddleware(IMyScoped svc) => _svc = svc; // 안전: 스코프 주입
    public async Task InvokeAsync(HttpContext ctx, RequestDelegate next) { ... }
}
// Program.cs
builder.Services.AddScoped<IMyScoped, MyScoped>();
builder.Services.AddTransient<MyMiddleware>(); // IMiddleware 구현체는 보통 Transient
app.UseMiddleware<MyMiddleware>();
```

### 최소 API(Endpoint 핸들러)

```csharp
app.MapPost("/do", async (IMyScoped svc) => await svc.Run());
```
- 파라미터로 받은 서비스는 **요청 스코프에서 자동 해결**.

---

## EF Core `DbContext`와 Lifetime

- 기본: `AddDbContext<TContext>()`는 **Scoped** 등록.
- **동일 요청** 내에서 같은 컨텍스트 공유(체크/트래킹 일관성).
- 병렬 작업 시 컨텍스트 공유 금지 → 각각의 스코프/컨텍스트를 만들 것.

```csharp
builder.Services.AddDbContext<AppDb>(opt =>
    opt.UseSqlServer(builder.Configuration.GetConnectionString("Default")));
```

---

## `HttpClientFactory`와 Lifetime

- **절대** `new HttpClient()`를 매번 직접 만들지 말 것(소켓 핸들 누수, 포트 소진).
- `AddHttpClient` 사용: 핸들러 풀 관리, DNS 업데이트, 폴리(Polly) 정책 등.

```csharp
builder.Services.AddHttpClient<IMyApi, MyApi>(client =>
{
    client.BaseAddress = new Uri("https://api.example.com");
});
```

- Typed Client `IMyApi`는 보통 **Transient**. 내부 핸들러/소켓은 팩토리가 **장기 관리**.

---

## 옵션 패턴과 Lifetime (`IOptions*`)

| 타입                 | Lifetime 성격  | 설명                                      |
|---------------------|----------------|-------------------------------------------|
| `IOptions<T>`       | Singleton-like | 앱 시작 시 바인딩, 고정값 접근            |
| `IOptionsSnapshot<T>` | Scoped       | **요청당** 스냅샷(웹 요청에서 권장)       |
| `IOptionsMonitor<T>`  | Singleton    | 변경 감지 및 콜백(OnChange)               |

```csharp
builder.Services.Configure<MyOptions>(builder.Configuration.GetSection("MyOpt"));

// 요청마다 최신값 필요 → 스냅샷
public class MyPageModel : PageModel
{
    private readonly IOptionsSnapshot<MyOptions> _opt;
    public MyPageModel(IOptionsSnapshot<MyOptions> opt) => _opt = opt;
}
```

---

## 백그라운드 서비스(HostedService/BackgroundService)와 Scoped 사용

- `BackgroundService`는 **싱글턴**. 여기서 스코프 서비스 필요 시 **매 루프마다 스코프 생성**.

```csharp
public class Worker : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    public Worker(IServiceScopeFactory f) => _scopeFactory = f;

    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            using var scope = _scopeFactory.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<AppDb>();
            await ProcessAsync(db, ct);

            await Task.Delay(TimeSpan.FromSeconds(10), ct);
        }
    }
}
```

---

## Keyed Services(.NET 8) — 같은 인터페이스, 다른 구현 구분

```csharp
// 등록
builder.Services.AddKeyedSingleton<INotifier, SmsNotifier>("sms");
builder.Services.AddKeyedSingleton<INotifier, EmailNotifier>("email");

// 사용
public class NotifyController(INotifierFactory factory) : ControllerBase
{
    private readonly INotifier _sms = factory.GetRequiredKeyedService<INotifier>("sms");
    private readonly INotifier _email = factory.GetRequiredKeyedService<INotifier>("email");
}
```

- 또는 생성자 파라미터에서 직접:
  `public MySvc([FromKeyedServices("sms")] INotifier sms) { ... }`

**활용**: A/B 구현 교체, 다테넌트, 외부 채널 구분.

---

## 오픈 제네릭, 데코레이터, 스캐닝(Scrutor)

### 오픈 제네릭 등록

```csharp
builder.Services.AddScoped(typeof(IRepository<>), typeof(EfRepository<>));
```

### 데코레이터(Scrutor)

```csharp
builder.Services.Scan(s => s
    .FromAssembliesOf(typeof(ICalc))
    .AddClasses(c => c.AssignableTo<ICalc>())
        .AsImplementedInterfaces()
        .WithTransientLifetime()
    .Decorate<ICalc, LoggingCalcDecorator>()
);
```

---

## `TryAdd*`, `Replace`, `RemoveAll` — 등록 제어

```csharp
using Microsoft.Extensions.DependencyInjection.Extensions;

builder.Services.TryAddScoped<IMy, MyImpl>();     // 없을 때만 추가
builder.Services.Replace(ServiceDescriptor.Singleton<IMy, MyAlt>()); // 교체
builder.Services.RemoveAll<IMy>();                // 모두 제거
```

---

## 테스트 전략 — WebApplicationFactory/TestServer

### 통합 테스트에서 DI 오버라이드

```csharp
public class MyAppFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureServices(svcs =>
        {
            // 기존 등록 교체
            svcs.RemoveAll<IMyService>();
            svcs.AddSingleton<IMyService, FakeMyService>();
        });
    }
}
```

### Lifetime 관찰(초간단)

```csharp
public class IdService
{
    public Guid Id { get; } = Guid.NewGuid();
}
```
- Transient/Scoped/Singleton으로 등록 후 **요청별/요청 내** 비교.

---

## 실제 시나리오 조합 레시피

### 전자상거래 예

- `DbContext`: Scoped
- 결제 게이트웨이 클라이언트(typed HttpClient): Transient
- 환율/카탈로그 캐시: Singleton(불변 구조/락)
- 주문 유스케이스 서비스: Scoped
- 결제 웹훅 수신 미들웨어: 요청 스코프에서 처리

### 실시간 알림

- 커넥션 레지스트리(ConcurrentDictionary): Singleton(스레드-세이프)
- 알림 유즈케이스: Scoped
- 외부 푸시 클라이언트: Transient(typed HttpClient)

---

## 진단/디버깅 팁

- **GUID 필드**로 인스턴스 추적
- DI 그래프 보기(데코레이터/대체 구현 의도치 않은 중복 등록 확인)
- “Cannot consume scoped service from singleton” 예외 → **경계 재점검**

---

## 코드 모음 — 핵심 패턴 스니펫

### Program.cs 템플릿(요약)

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();
builder.Services.AddRazorPages();

// Lifetimes
builder.Services.AddTransient<ITransient, TransientImpl>();
builder.Services.AddScoped<IScoped, ScopedImpl>();
builder.Services.AddSingleton<ISingleton, SingletonImpl>();

// DbContext
builder.Services.AddDbContext<AppDb>(o => o.UseNpgsql(builder.Configuration.GetConnectionString("Default")));

// HttpClientFactory
builder.Services.AddHttpClient<IMyApi, MyApi>(c => c.BaseAddress = new Uri("https://api.example.com"));

// Options
builder.Services.Configure<MyOptions>(builder.Configuration.GetSection("MyOptions"));

// HostedService
builder.Services.AddHostedService<Worker>();

var app = builder.Build();

app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.MapRazorPages();
app.MapControllers();

app.Run();
```

### Singleton에서 Scoped 사용 — 안전 패턴

```csharp
public class ReportScheduler : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    public ReportScheduler(IServiceScopeFactory sf) => _scopeFactory = sf;

    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            using var scope = _scopeFactory.CreateScope();
            var job = scope.ServiceProvider.GetRequiredService<IReportJob>();
            await job.RunAsync(ct);

            await Task.Delay(TimeSpan.FromMinutes(5), ct);
        }
    }
}
```

### Options Snapshot/Monitor 비교

```csharp
public class UseOptions(
    IOptions<MyOptions> opt,
    IOptionsSnapshot<MyOptions> snap,
    IOptionsMonitor<MyOptions> mon)
{
    // opt.Value: 앱 시작 기준 고정
    // snap.Value: 요청 단위 최신값
    // mon.CurrentValue / OnChange: 실시간 변경 감시
}
```

---

## 자주 나오는 Q&A

**Q1. Singleton에 `HttpContext`를 주입해도 되나?**
A. 안 된다. `HttpContext`는 요청 스코프. 필요 시 메서드 파라미터로 받거나, 지연 스코프 생성으로 범위 안에서만 접근.

**Q2. Transient이면서 IDisposable이면 누가 해제하나?**
A. **컨테이너가 생성한** 인스턴스는 **해당 스코프 종료 시** 해제된다.

**Q3. 성능이 느려 `Singleton`으로 바꾸면 해결될까?**
A. 대부분은 **스레드 안전성/상태 일관성 문제**가 생긴다. 병목 원인(예: I/O, DB, 동시성 제어)을 우선 찾고, 캐시/배치/비동기로 개선.

---

## 요약 표(확대판)

| 항목 | Transient | Scoped | Singleton |
|---|---|---|---|
| 생성/해제 | 요청 시/스코프 끝 | 요청 시작/요청 끝 | 앱 시작/앱 종료 |
| 상태 보존 | 권장 안 함 | 요청 범위 | 앱 전체(스레드 안전 필요) |
| 대표 사례 | 헬퍼, 변환기, Typed HttpClient | 유스케이스, `DbContext` | 캐시, 카탈로그, 레지스트리 |
| 주의 | 생성비용 과다 | 병렬 공유 금지 | Captive/스레드안전/짧은 스코프 참조 금지 |
| 문제 해결 | 캐시·풀링 | 스코프 분리 | `CreateScope()`, 경계 재설계 |

---

## 마무리

- **올바른 Lifetime 선택**은 성능/안정성/유지보수성에 직접적 영향을 준다.
- 원칙은 간단하다:
  1) **Transient**는 가볍게,
  2) **Scoped**는 요청 단위의 비즈니스 작업에,
  3) **Singleton**은 스레드 안전한 공유 리소스에.
- 경계를 넘나드는 의존성은 **지연 스코프 생성**으로 해결하고, 해제/스레드 안전/오버포스팅 등 **운영 이슈**를 항상 염두에 둘 것.

---

## 부록 A) GUID로 수명 주기 눈으로 보기(미니 데모)

```csharp
public interface IProbe { Guid Id { get; } string Lifetime { get; } }

public class TransientProbe : IProbe { public Guid Id { get; } = Guid.NewGuid(); public string Lifetime => "Transient"; }
public class ScopedProbe    : IProbe { public Guid Id { get; } = Guid.NewGuid(); public string Lifetime => "Scoped"; }
public class SingletonProbe : IProbe { public Guid Id { get; } = Guid.NewGuid(); public string Lifetime => "Singleton"; }

// Program.cs
builder.Services.AddTransient<TransientProbe>();
builder.Services.AddScoped<ScopedProbe>();
builder.Services.AddSingleton<SingletonProbe>();

app.MapGet("/probe", (TransientProbe t, ScopedProbe s, SingletonProbe g) =>
    Results.Json(new { t = t.Id, s = s.Id, g = g.Id }));
```

- 여러 번 `/probe` 호출하면:
  - `t`는 매 호출 바뀜,
  - `s`는 같은 요청 내 고정(동일 요청에서 여러 번 주입 시에도 동일),
  - `g`는 앱 동안 고정.

---

## 부록 B) 체크리스트

- [ ] DB/외부 API 접근 로직은 **Scoped**
- [ ] Typed `HttpClient`는 `AddHttpClient` 사용
- [ ] Singleton은 **스레드 안전** + **짧은 스코프 참조 금지**
- [ ] 백그라운드 작업에서 **`CreateScope()`** 사용
- [ ] 옵션은 요구사항에 맞춰 `IOptions`/`Snapshot`/`Monitor` 선택
- [ ] 테스트 시 `RemoveAll`/`Replace`로 DI 오버라이드
- [ ] IDisposable/AsyncDisposable이 컨테이너 경계에서 **올바르게 해제**되는지 검증

이 원칙들을 팀 표준으로 채택하면, ASP.NET Core 애플리케이션의 **성능과 신뢰성**, 그리고 **테스트 용이성**이 자연스럽게 향상된다.
