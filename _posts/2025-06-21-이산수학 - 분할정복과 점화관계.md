---
layout: post
title: 이산수학 - 분할정복과 점화관계
date: 2025-06-21 21:20:23 +0900
category: 이산수학
---
# 분할정복 알고리즘과 점화관계 (Divide & Conquer + Recurrences)

## 0) 개요

- **Divide**: 크기 $$n$$ 문제 → 여러 하위문제(보통 크기 $$n/b$$)  
- **Conquer**: 재귀로 하위문제 해결  
- **Combine**: 해를 병합/결합  
- 자연스럽게 **점화식**:
  $$
  T(n)=\sum_{i=1}^a T\!\left(\frac{n}{b_i}\right)+f(n)
  $$
  (균등분할이면 보통 $$a\cdot T(n/b)+f(n)$$)

- 복잡도 해석 3대 도구
  1) **마스터 정리**(Master Theorem) — 균등 분할 + 다항·폴리로그 결합  
  2) **재귀트리/반복 전개법** — 레벨별 비용 합  
  3) **아크라–바지 정리**(Akra–Bazzi) — 비균등/복잡 결합 일반해

---

## 1) 분할정복의 기본 골격

### 1.1 설계 3단계
1. **Divide**: 입력을 하위 인스턴스로 분할
2. **Conquer**: 재귀 호출로 각 하위문제 해결
3. **Combine**: 결과를 합쳐 최종 해 산출

### 1.2 대표 예시

| 알고리즘 | 분할 | 정복 | 결합 | 점화식(전형) |
|---|---|---|---|---|
| Merge Sort | 반씩 분할 | 재귀 정렬 | 선형 병합 | $$T(n)=2T(n/2)+\Theta(n)$$ |
| Quick Sort | 피벗 분할 | 두 부분 재귀 | 없음(파티션 결과) | 평균 $$\Theta(n\log n)$$, 최악 $$\Theta(n^2)$$ |
| Binary Search | 반으로 줄이기 | 1개 탐색 | 없음 | $$T(n)=T(n/2)+\Theta(1)$$ |
| Karatsuba | 3개 부분곱 | 재귀 곱셈 | 선형 결합 | $$T(n)=3T(n/2)+\Theta(n)$$ |
| Strassen | 7개 부분곱 | 재귀 곱셈 | $$\Theta(n^2)$$ | $$T(n)=7T(n/2)+\Theta(n^2)$$ |
| FFT | 반-분할 | 재귀 DFT | 나비 연산 $$\Theta(n)$$ | $$T(n)=2T(n/2)+\Theta(n)$$ |

---

## 2) 점화식 표준형과 마스터 정리

### 2.1 표준형
$$
T(n)=a\,T\!\left(\frac{n}{b}\right)+f(n),\quad a\ge 1,\ b>1
$$

### 2.2 마스터 정리(확장형 개관)

- $$f(n)=\Theta\!\big(n^d \log^k n\big)$$, $$d\ge 0$$, $$k\in\mathbb{R}$$
- $$n^{\log_b a}$$ 와 비교

| 케이스 | 조건 | 해석 |
|---|---|---|
| **Case 1** | $$a<b^d$$ | $$T(n)=\Theta(n^d \log^k n)$$ |
| **Case 2** | $$a=b^d$$ | $$T(n)=\Theta(n^d \log^{k+1} n)$$ *(단, 보통 \(k\ge 0\) 가정)* |
| **Case 3** | $$a>b^d$$ + 정규성(regularity) $$a f(n/b)\le c f(n)$$ | $$T(n)=\Theta\!\big(n^{\log_b a}\big)$$ |

> ⚠️ **주의**: \(k<0\) (예: \(f(n)=n/\log n\))는 Case 2의 단순 공식에 그대로 대입하면 틀릴 수 있음 → 재귀트리 또는 Akra–Bazzi로 처리(§4.2 예시).

---

## 3) 재귀트리/반복 전개법

### 3.1 예: Merge Sort
$$
T(n)=2T(n/2)+n
$$
- 레벨 $$i$$ 비용: 하위문제 수 $$2^i$$ × 각 비용 $$n/2^i$$ → 합이 항상 $$n$$
- 높이 $$\log_2 n$$ → 전체 $$\Theta(n\log n)$$

### 3.2 예: $$T(n)=aT(n/b)+n^d$$
- 레벨별 비용: $$a^i \left(n/b^i\right)^d=n^d\left(\frac{a}{b^d}\right)^i$$
- 비율이 1보다 작/같/크냐에 따라 상·중·하 레벨 우세 → 마스터 정리의 3케이스로 귀결

---

## 4) Akra–Bazzi 정리(일반해)

### 4.1 정리(요지)
$$
T(x)=\sum_{i=1}^a a_i\,T(b_i x)+g(x),\quad 0<b_i<1
$$
- **p**를 다음 방정식으로 결정: $$\sum_{i=1}^a a_i b_i^p=1$$
- 그러면
$$
T(x)=\Theta\!\Big(x^p\big(1+\int_1^x \frac{g(u)}{u^{p+1}}\,du\big)\Big)
$$

### 4.2 왜 필요한가? (마스터로 안 되는 대표들)
- **Median-of-Medians 선택**: $$T(n)=T(\lceil n/5\rceil)+T(\lceil 7n/10\rceil)+\Theta(n)$$ → **\(O(n)\)**  
- **비균등 분할**: $$T(n)=T(n/2)+T(n/3)+\Theta(n)$$  
  - \(p\) s.t. \((1/2)^p+(1/3)^p=1\) → \(p\approx 0.787\)  
  - \(\int_1^n u/u^{p+1}\,du=\Theta(n^{1-p})\) → **\(\Theta(n)\)**
- **미묘한 결합**: $$T(n)=2T(n/2)+\frac{n}{\log n}$$  
  - 재귀트리로 레벨합 \(\sum_{i=0}^{\log n} \frac{n}{\log(n/2^i)}\approx n\sum_{j=1}^{\log n}\frac{1}{j}= \Theta(n\log\log n)\)  
  - **정답: \(\Theta(n\log\log n)\)** (마스터 확장 공식을 기계적으로 대입하면 실수!)

---

## 5) 대표 알고리즘 사례 분석

### 5.1 Merge Sort (안정정렬, 외부정렬 친화)
- 점화: $$T(n)=2T(n/2)+\Theta(n) \Rightarrow \Theta(n\log n)$$
- 공간: 병합에 보조 배열 \(O(n)\) (링크드 리스트면 \(O(1)\) 보조도 가능)
- 외부정렬: 블록 단위 병합으로 디스크 I/O 최적화

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    m = len(arr) // 2
    L = merge_sort(arr[:m])
    R = merge_sort(arr[m:])
    return merge(L, R)

def merge(L, R):
    i = j = 0
    out = []
    while i < len(L) and j < len(R):
        if L[i] <= R[j]:
            out.append(L[i]); i += 1
        else:
            out.append(R[j]); j += 1
    return out + L[i:] + R[j:]
```

---

### 5.2 Quick Sort (평균 최강, 최악주의)
- 평균 점화(균등 피벗 가정):  
  $$T(n)=\frac{1}{n}\sum_{q=0}^{n-1}\big(T(q)+T(n-1-q)\big)+\Theta(n)$$  
  → **\(\Theta(n\log n)\)**
- 최악(매번 한쪽으로 치우침): \(T(n)=T(n-1)+\Theta(n)=\Theta(n^2)\)
- 실전: **무작위 피벗**(Randomized)로 평균 성능 보장, **median-of-3** 등 휴리스틱

```python
import random
def quicksort(a):
    if len(a) <= 1: return a
    p = random.choice(a)
    L = [x for x in a if x < p]
    E = [x for x in a if x == p]
    G = [x for x in a if x > p]
    return quicksort(L) + E + quicksort(G)
```

---

### 5.3 Karatsuba 큰수 곱셈
- 분할: 각 수를 절반으로 나눠 3개 부분곱으로 결합
- 점화: $$T(n)=3T(n/2)+\Theta(n)\Rightarrow \Theta(n^{\log_2 3})\approx \Theta(n^{1.585})$$

```python
def karatsuba(x, y):
    sx, sy = str(x), str(y)
    n = max(len(sx), len(sy))
    if n <= 18:  # 작은 경우 직접 곱
        return x * y
    m = n // 2
    a, b = divmod(x, 10**m)
    c, d = divmod(y, 10**m)
    ac = karatsuba(a, c)
    bd = karatsuba(b, d)
    ad_bc = karatsuba(a + b, c + d) - ac - bd
    return ac * 10**(2*m) + ad_bc * 10**m + bd
```

---

### 5.4 Strassen 행렬 곱셈
- 7개의 부분곱으로 결합 → $$T(n)=7T(n/2)+\Theta(n^2)$$  
- 복잡도: $$\Theta(n^{\log_2 7})\approx\Theta(n^{2.807})$$  
- 수치안정성/상수 커짐 → 실전은 임계 크기까진 클래식 \(n^3\) 후 Strassen 혼용

---

### 5.5 FFT(고속 푸리에 변환)
- 점화: $$T(n)=2T(n/2)+\Theta(n) \Rightarrow \Theta(n\log n)$$  
- 다항식 곱셈 \(O(n\log n)\) 달성 (계수 패딩/원시근 필요)

---

### 5.6 선택 알고리즘(최소 k번째, Median-of-Medians)
- 점화(보장형 선택):  
  $$T(n)=T(\lceil n/5\rceil)+T(\lceil 7n/10\rceil)+\Theta(n)\Rightarrow O(n)\quad(\text{Akra–Bazzi})$$
- 퀵선택(무작위): 평균 \(O(n)\), 최악 \(O(n^2)\)

---

### 5.7 기하: 볼록 껍질(분할정복)
- 좌/우 분할 → 두 껍질 병합(상하 공통접선 찾기)
- 점화: $$T(n)=2T(n/2)+\Theta(n)\Rightarrow \Theta(n\log n)$$

---

## 6) 케이스 스터디: 섬세한 결합항

### 6.1 \(T(n)=2T(n/2)+\dfrac{n}{\log n}\)
- 레벨 \(i\) 비용: \(\dfrac{n}{\log(n/2^i)}=\dfrac{n}{\log n - i\log 2}\)
- 총합: \(\sum_{i=0}^{\log n} \dfrac{n}{\log n - i\log 2}\sim n \sum_{j=1}^{\log n} \frac{1}{j}=\Theta(n\log\log n)\)

### 6.2 \(T(n)=2T(n/2)+n\log n\)
- 레벨 \(i\): \(2^i \cdot \big(\frac{n}{2^i}\log\frac{n}{2^i}\big)=n(\log n - i)\)
- 합: \(\sum_{i=0}^{\log n} [n\log n - n i]=\Theta(n(\log n)^2)\)

### 6.3 \(T(n)=2T(n/2)+n^\alpha\) (일반 \(0<\alpha<1\))
- 비율 \((a/b^d)=(2/2^\alpha)=2^{1-\alpha}>1\) → 리프 우세 전에 중간레벨이 커짐  
- 결과: \(\Theta(n^{\log_2 2} \cdot \log n^{?})\)가 아니라 **\(\Theta(n)\)**에 로그 보정 없음 (자세한 유도는 재귀트리 적분)

---

## 7) 대입법(Substitution)으로 엄밀 증명

### 7.1 Merge Sort 상한 증명 스케치
가정: \(T(n)\le c\,n\log n - d n\) 성립을 유도  
\[
\begin{aligned}
T(n)&=2T(n/2)+cn\\
&\le 2\big(c\frac{n}{2}\log\frac{n}{2}-d\frac{n}{2}\big)+cn\\
&= cn\log n - cn + cn - dn\\
&= cn\log n - dn
\end{aligned}
\]
\(d>0\) 적절히 두면 성립(기저 \(n\le n_0\)로 고정).

### 7.2 비균등 분할 대입 예시
\(T(n)=T(\alpha n)+T((1-\alpha)n)+cn\)  
가정 \(T(n)\le C n\log n\):  
\[
T(n)\le C\alpha n\log(\alpha n)+C(1-\alpha)n\log((1-\alpha)n)+cn
= Cn\log n + Cn(\alpha\log\alpha+(1-\alpha)\log(1-\alpha)) + cn
\]
괄호 값은 음수 → 상수 \(c\)로 보정 가능 → \(O(n\log n)\).

---

## 8) 실무 성능 포인트

### 8.1 스택 깊이/테일 리커전
- 깊이: 균등분할은 \(\Theta(\log n)\), 편향(퀵정렬 최악)은 \(\Theta(n)\)
- 파이썬은 재귀깊이 제한(약 1000) → **반복/명시 스택** 변환 고려

### 8.2 캐시-친화성(Cache Oblivious)
- 재귀적 분할은 지역성을 자연히 확보 → 외부메모리/캐시 미지식에도 좋은 I/O 복잡도
- 예: 캐시-오블리비어스 머지소트/행렬곱

### 8.3 병렬화(Work–Span 모델)
- **Work** \(W(n)\): 전체 연산량 (순차 복잡도와 동일)  
- **Span** \(S(n)\): 가장 긴 의존 경로 길이  
  - 머지소트: \(W(n)=\Theta(n\log n)\), 병렬 분할/병합하면 \(S(n)=\tilde O(\log^2 n)\) 또는 \(O(\log n)\) (병렬 병합 사용)  
- 이상적 시간: \(T_P \approx W(n)/P + S(n)\)

---

## 9) “패턴 라이브러리”: 점화식 → 해

| 점화식 | 해석(요지) |
|---|---|
| \(T(n)=aT(n/b)+\Theta(n^d)\) | 마스터 3케이스 |
| \(T(n)=T(n-1)+\Theta(1)\) | \(\Theta(n)\) |
| \(T(n)=T(n-1)+\Theta(n)\) | \(\Theta(n^2)\) |
| \(T(n)=2T(n/2)+\Theta(n\log^k n)\) | \(k\ge 0\) → \(\Theta(n\log^{k+1}n)\) |
| \(T(n)=2T(n/2)+\frac{n}{\log n}\) | \(\Theta(n\log\log n)\) |
| \(T(n)=T(\alpha n)+T((1-\alpha)n)+\Theta(n)\) | \(\Theta(n\log n)\) |
| \(T(n)=T(n/5)+T(7n/10)+\Theta(n)\) | \(O(n)\) (Akra–Bazzi) |
| \(T(n)=T(n/2)+\Theta(1)\) | \(\Theta(\log n)\) |
| \(T(n)=3T(n/2)+\Theta(n)\) | \(\Theta(n^{\log_2 3})\) |

---

## 10) 코드로 보는 D&C 구현과 타이밍

### 10.1 퀵정렬 vs 머지소트 간단 비교(학습용)
```python
import random, time

def mergesort(a):
    if len(a)<=1: return a
    m=len(a)//2
    L=mergesort(a[:m]); R=mergesort(a[m:])
    i=j=0; out=[]
    while i<len(L) and j<len(R):
        if L[i]<=R[j]: out.append(L[i]); i+=1
        else: out.append(R[j]); j+=1
    return out+L[i:]+R[j:]

def quicksort(a):
    if len(a)<=1: return a
    p=a[len(a)//2]
    L=[x for x in a if x<p]; E=[x for x in a if x==p]; G=[x for x in a if x>p]
    return quicksort(L)+E+quicksort(G)

for n in [10_000, 50_000]:
    arr=[random.randint(0, 10**9) for _ in range(n)]
    for name,fn in [("merge", mergesort),("quick", quicksort)]:
        b=arr[:] ; t=time.time(); fn(b); dt=time.time()-t
        print(name, n, round(dt,3), "sec")
```
> 실전: 표준 라이브러리 `sort`(팀소트 등)는 분할정복 + 런 감지·삽입 정렬 하이브리드로 상수/캐시까지 최적화.

### 10.2 Karatsuba 임계 혼합
```python
def mul_school(x,y): return x*y

def karatsuba_mixed(x,y, cutoff=1<<32):
    # cutoff 이하면 표준 곱(하드웨어/CPython bigint 최적화 수혜)
    if x<cutoff or y<cutoff:
        return x*y
    sx, sy = str(x), str(y)
    n = max(len(sx), len(sy))
    m = n//2
    a, b = divmod(x, 10**m)
    c, d = divmod(y, 10**m)
    ac = karatsuba_mixed(a, c, cutoff)
    bd = karatsuba_mixed(b, d, cutoff)
    adbc = karatsuba_mixed(a+b, c+d, cutoff) - ac - bd
    return ac*10**(2*m) + adbc*10**m + bd
```

---

## 11) 자주 묻는 함정/FAQ

- **바닥/천장**: \(T(\lfloor n/2\rfloor)\) 등은 상수 계수에만 영향 → 보통 \(\Theta(\cdot)\) 불변
- **정규성(regularity)**: Case 3에 필요. \(a f(n/b)\le c f(n)\) 같은 조건을 확인해야 함
- **\(k<0\) 폴리로그**: \(f(n)=n/\log n\) 류는 마스터 확장 공식 무비판 적용 금지 → 재귀트리/아크라–바지
- **편향 분할**: 퀵정렬 최악을 막으려면 랜덤 피벗/균형화 전략
- **기저 비용**: \(T(1)=\Theta(1)\) 가정이 무조건 안전한가? 실전에서는 작은 \(n\)에서 다른 알고리즘으로 스위치(하이브리드)

---

## 12) 연습문제(풀이 스케치 포함)

1) \(T(n)=2T(n/2)+n\log n\) ⇒ **\(\Theta(n(\log n)^2)\)** (레벨 합)  
2) \(T(n)=T(n/3)+T(2n/3)+n\) ⇒ **\(\Theta(n\log n)\)** (비균등지만 케이크 절단 합)  
3) \(T(n)=4T(n/2)+n^2\) ⇒ \(a=4,b=2,d=2\Rightarrow a=b^d\) → **\(\Theta(n^2\log n)\)**  
4) \(T(n)=T(n-1)+\log n\) ⇒ 망원경 합 → **\(\Theta(n\log n)\)**  
5) \(T(n)=T(n/2)+T(n/4)+n\)  
   - \(p\) s.t. \((1/2)^p+(1/4)^p=1\). \(p=1\)이면 \(1/2+1/4=3/4\ne1\). \(p=0\)이면 2 ≠ 1. 수치해 찾으면 \(p\approx 0.694\).  
   - \(\int u/u^{p+1}=\Theta(u^{1-p})\) → \(T(n)=\Theta(n)\).

---

## 13) 미세 최적화·현대 이슈

- **분기 예측·캐시**: 재귀보다 반복이 유리할 때가 있음(예: 소형 배열 구간 삽입정렬)
- **SIMD**: 병합/파티션 단계에 벡터화 적용(언어/라이브러리 의존)
- **메모리 할당**: 재귀 중간 결과의 임시 버퍼 재사용/풀링
- **분할 임계값 튜닝**: \(n<n_0\)에서 다른 알고리즘(삽입/선형)로 스위치

---

## 14) 요약 챠트

| 축 | 포인트 |
|---|---|
| 설계 | Divide–Conquer–Combine |
| 점화식 | \(aT(n/b)+f(n)\), 비균등은 \( \sum a_i T(b_i n)+g(n) \) |
| 해석 | 마스터(균등), 재귀트리(레벨합), Akra–Bazzi(일반) |
| 대표해 | 머지/FFT \(n\log n\), 카라추바 \(n^{1.585}\), 스트라센 \(n^{2.807}\), 선택 \(n\) |
| 함정 | \(f(n)=n/\log n\), 편향 분할, 정규성 조건 |
| 실전 | 하이브리드/랜덤화/캐시·병렬 고려 |

---

## 15) 추가 파이썬 실험: 재귀트리 비용 합 근사

```python
import math

def cost_2Tn2_plus(n, g):
    """
    레벨 i에서 비용 n / g(n/2^i)를 합산.
    g(x)=log x, log^2 x 등 다양한 함수 전달.
    """
    L = int(math.log2(n))
    s = 0.0
    for i in range(L+1):
        x = max(2, n/(2**i))
        s += n / g(x)
    return s

print("n/log n 케이스 n=2^20:", round(cost_2Tn2_plus(1<<20, lambda x: math.log(x)), 2), "~ n log log n 규모")
print("n 케이스 n=2^20:", round(cost_2Tn2_plus(1<<20, lambda x: 1.0), 2), "~ n log n 규모")
```

---

## 16) 보너스: Divide & Conquer DP Optimization (한 줄 메모)
- 전형 DP \(dp[i]=\min_{j<i}\{dp[j]+C(j,i)\}\)에서 \(C\)가 사분할/콰드러틱 구조를 만족하면  
  **분할정복 최적화**로 전이 구간의 최적 인덱스 단조성을 이용해 \(O(n\log n)\) 혹은 \(O(n\alpha)\)로 개선(전통 DP와는 다르지만 이름은 D&C).

---

### 마무리

분할정복은 **설계 패턴**이자 **수학적 분석 루틴**입니다.  
- 문제를 어떻게 쪼개고(분할),  
- 어떤 비용으로 결합하며(결합항 \(f(n)\)),  
- 분할 비율이 균등/편향/확률적인지(분할 형태)에 따라  
점화식이 달라지고, 해석 도구 선택이 달라집니다.  
**마스터–재귀트리–Akra–Bazzi** 3종 세트를 자유롭게 넘나드는 습관을 들이면, 어떤 분할정복도 겁낼 필요가 없습니다.