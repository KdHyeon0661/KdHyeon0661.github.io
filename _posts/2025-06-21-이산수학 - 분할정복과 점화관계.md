---
layout: post
title: 이산수학 - 분할정복과 점화관계
date: 2025-06-21 21:20:23 +0900
category: 이산수학
---
# ⚔️ 분할정복 알고리즘과 점화관계

## 📌 개요

**분할정복(Divide and Conquer)**은 복잡한 문제를 **작은 하위 문제로 나누고**, 이를 **재귀적으로 해결**한 뒤, 결과를 **결합하여 최종 해답**을 얻는 알고리즘 전략입니다.

이런 구조는 자연스럽게 **점화식(Recurrence Relation)**을 형성하며, 이 점화식을 분석함으로써 **알고리즘의 시간 복잡도**를 평가할 수 있습니다.

---

## 🧠 1. 분할정복의 기본 구조

### 🔹 3단계 전략

1. **분할 (Divide)**: 문제를 더 작은 하위 문제로 나눔  
2. **정복 (Conquer)**: 하위 문제를 재귀적으로 해결  
3. **결합 (Combine)**: 하위 문제의 해를 조합해 원래 문제 해결

---

### 🎯 대표 예시

| 알고리즘 | 설명 |
|----------|------|
| Merge Sort | 배열을 반으로 나눈 뒤 정렬 결과를 병합 |
| Quick Sort | 피벗 기준으로 분할 후 정렬 |
| 이진 탐색 | 절반씩 탐색 |
| Karatsuba 곱셈 | 큰 수 곱셈을 작은 수 곱셈으로 분할 |
| Strassen 알고리즘 | 행렬 곱셈을 7개의 작은 곱셈으로 대체 |

---

## 📐 2. 분할정복 알고리즘의 점화식

분할정복의 시간복잡도는 다음과 같은 **일반적인 점화식** 형태로 나타납니다:

\[
T(n) = a \cdot T\left(\frac{n}{b}\right) + f(n)
\]

- \( a \): 하위 문제의 개수  
- \( \frac{n}{b} \): 하위 문제의 크기  
- \( f(n) \): 나누고 합치는 데 드는 비용

---

## 🔍 3. 마스터 정리 (Master Theorem)

이 점화식을 해석하기 위한 핵심 도구가 바로 **마스터 정리**입니다.

### ✅ 일반형

\[
T(n) = a \cdot T\left(\frac{n}{b}\right) + \Theta(n^d)
\]

### 📌 해법

| 조건 | 해 |
|------|----|
| \( a < b^d \) | \( T(n) = \Theta(n^d) \) |
| \( a = b^d \) | \( T(n) = \Theta(n^d \log n) \) |
| \( a > b^d \) | \( T(n) = \Theta(n^{\log_b a}) \) |

---

### 🎯 예제: Merge Sort

\[
T(n) = 2T\left(\frac{n}{2}\right) + cn
\]

- \( a = 2,\ b = 2,\ d = 1 \Rightarrow a = b^d \)

\[
\Rightarrow T(n) = \Theta(n \log n)
\]

---

### 🎯 예제: Binary Search

\[
T(n) = T\left(\frac{n}{2}\right) + 1
\]

- \( a = 1,\ b = 2,\ d = 0 \Rightarrow a > b^d \)

\[
\Rightarrow T(n) = \Theta(\log n)
\]

---

### 🎯 예제: Karatsuba 곱셈

\[
T(n) = 3T\left(\frac{n}{2}\right) + cn
\]

- \( a = 3,\ b = 2,\ d = 1 \Rightarrow a > b^d \)

\[
\Rightarrow T(n) = \Theta(n^{\log_2 3}) \approx \Theta(n^{1.585})
\]

---

## 🔎 4. 분할정복을 점화식으로 해석하는 흐름

### 🔹 1. 문제 분석

> 문제를 재귀적으로 어떻게 나누는가?

### 🔹 2. 점화식 유도

> 하위 문제 수와 크기, 분할/결합 비용을 고려한 점화식 수립

### 🔹 3. 마스터 정리 또는 반복 전개로 해석

---

## 🧮 5. 반복 전개법 (확장용)

마스터 정리를 쓰기 어려운 경우 **반복 전개 방식**으로 해를 추론할 수 있습니다.

### 🎯 예제

\[
T(n) = 2T(n/2) + n
\]

- 단계별 전개:

\[
\begin{align*}
T(n) &= 2T(n/2) + n \\
     &= 2[2T(n/4) + n/2] + n = 4T(n/4) + n + n = 4T(n/4) + 2n \\
     &= 8T(n/8) + 3n \\
     &= \cdots \\
     &= 2^k T(n/2^k) + kn
\end{align*}
\]

- 종료 조건: \( n/2^k = 1 \Rightarrow k = \log n \)

\[
T(n) = nT(1) + n \log n = \Theta(n \log n)
\]

---

## 🤖 6. Python 실전 코드 예시

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(L, R):
    result = []
    i = j = 0
    while i < len(L) and j < len(R):
        if L[i] < R[j]:
            result.append(L[i])
            i += 1
        else:
            result.append(R[j])
            j += 1
    return result + L[i:] + R[j:]
```

- 시간복잡도 점화식:  
\[
T(n) = 2T(n/2) + cn \Rightarrow T(n) = \Theta(n \log n)
\]

---

## 📚 요약

| 개념 | 설명 |
|------|------|
| 분할정복 | 문제를 하위 문제로 나누어 푸는 전략 |
| 점화식 | 분할정복 알고리즘의 시간복잡도를 수식화 |
| 마스터 정리 | 점화식 해석의 대표 도구 |
| 반복 전개법 | 직접 전개로 일반항 도출 |
| 실전 예 | Merge Sort, Quick Sort, Karatsuba 등 |