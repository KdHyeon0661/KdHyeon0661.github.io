---
layout: post
title: 이산수학 - 언어와 문법
date: 2025-07-07 19:20:23 +0900
category: 이산수학
---
# 언어와 문법: 형식 언어 이론의 기초

## 0) 형식 언어의 핵심 개념

### 0.1 알파벳, 문자열, 언어
- **알파벳(Σ)**: 유한한 기호 집합. 예:  
  $$\Sigma=\{a,b\},\quad \Sigma=\{0,1\}$$
- **문자열(String)**: Σ의 기호를 유한 개 나열한 것. 길이 $$|w|$$, 빈문자열 $$\varepsilon$$.
- **연결(Concatenation)**: 문자열 $$x,y$$에 대해 $$xy$$. 길이 $$|xy|=|x|+|y|$$.
- **Kleene 닫힘**:  
  $$\Sigma^*=\bigcup_{n\ge 0}\Sigma^n,\quad \Sigma^+=\Sigma^*\setminus\{\varepsilon\}$$
- **언어(Language)**: 문자열들의 집합 $$L\subseteq \Sigma^*$$.

**예시**
- $$L_1=\{a^n b^n\mid n\ge 0\}=\{\varepsilon,ab,aabb,aaabbb,\dots\}$$
- $$L_2=\{0^m1^n\mid m,n\ge 0\}=\{\,\varepsilon,0,1,01,0011,\dots\}$$

### 0.2 언어 연산
- 합집합 $$L\_1\cup L\_2$$, 교집합 $$L\_1\cap L\_2$$, 차집합, 여집합.
- 연결 $$L\_1L\_2=\{xy\mid x\in L\_1,y\in L\_2\}$$.
- Kleene-스타 $$L^*=\bigcup_{n\ge 0}L^n$$, 플러스 $$L^+$$.

---

## 1) 문법(Grammar)의 정식 정의와 작동

### 1.1 4-튜플 정의
문법 $$G=(V,\Sigma,R,S)$$:
- **V**: 비단말(Nonterminal) 집합
- **Σ**: 단말(Terminal) 집합 (알파벳)
- **R**: 생성 규칙(Production) 집합
- **S**: 시작 기호(Start symbol)

**예시** — $$L=\{a^n b^n\}$$ 을 생성하는 CFG:
```
V={S}, Σ={a,b}, S=S
R:
  S → a S b | ε
```

### 1.2 파생(Derivation) & 파스 트리(Parse Tree)
- **좌파생/우파생**: 적용 순서만 다르고 생성 언어는 동일.
- **예: `aabb`**
  $$
  S \Rightarrow aSb \Rightarrow aaSbb \Rightarrow aa\varepsilon bb = aabb
  $$

**간단 파스 트리 스케치**
```
    S
  a   S   b
     a S b
       ε
```

---

## 2) Chomsky 계층 — 언어와 인식기 요약

| 유형 | 생성 규칙 형태(대표) | 전형 인식기 | 예시 언어 |
|---|---|---|---|
| **Type 3 (정규)** | A→aB, A→a, A→ε | **FA (DFA/NFA)** | 정규식 언어, $$a^*b^*$$ |
| **Type 2 (문맥자유)** | A→γ | **PDA(스택)** | $$a^n b^n$$, 괄호균형 |
| **Type 1 (문맥민감)** | αAβ→αγβ (γ≠ε) | **LBA** | $$a^n b^n c^n$$ |
| **Type 0 (무제한)** | α→β | **튜링기계** | 일반 계산가능 언어 |

> 인식기: DFA/NFA(정규), PDA(CFL), LBA(CSL), TM(RE/Recursive).

---

## 3) 정규 언어(Regular) — 정규식, FA, 최소 DFA

### 3.1 정규식(Regex) ↔ NFA ↔ DFA
- **Thompson 구성**: 정규식을 **ε-NFA**로.
- **부분집합 구성**: NFA → DFA.
- **Hopcroft**: DFA 최소화 (상태 수 최적).

### 3.2 예제: 짝수 개의 `a`를 포함하는 언어
- 상태 2개(DFA): 짝수/홀수 패리티.
- 입력 `a`가 오면 상태 토글, `b`는 루프.

```python
def dfa_accepts(trans, start, finals, s):
    q = start
    for ch in s:
        if ch not in trans[q]:
            return False
        q = trans[q][ch]
    return q in finals

# DFA 전이(짝수/홀수 a)
trans = {
    'E': {'a':'O','b':'E'},
    'O': {'a':'E','b':'O'},
}
print(dfa_accepts(trans, 'E', {'E'}, "aba"))   # True
print(dfa_accepts(trans, 'E', {'E'}, "abaa"))  # False
```

### 3.3 Myhill–Nerode 정리 (핵심 직관)
- 문자열 접미사에 대한 **구별 불가능 동치류**가 **유한** ⇔ 언어가 **정규**.
- 최소 DFA 상태 수 = 동치류 수.

---

## 4) 문맥자유 언어(CFL) — CFG와 PDA, 문법 설계 기법

### 4.1 대표 CFG
- 괄호균형:  
  ```
  S → S S | ( S ) | ε
  ```
- $$\{a^n b^n\}$$:  
  ```
  S → a S b | ε
  ```

### 4.2 모호성(Ambiguity)
- 문법이 동일 문자열에 대해 **서로 다른 파스 트리**를 허용하면 **모호**.
- 전형 예: 산술식의 모호한 문법
  ```
  E → E + E | E * E | (E) | id
  ```
  → `id+id*id`의 두 해석(연산자 우선순위 충돌).

**해결(우선순위/결합성 부여)**
```
E → E + T | T         # + 가 낮은 우선순위, 좌결합
T → T * F | F         # * 가 높은 우선순위, 좌결합
F → (E) | id
```

### 4.3 좌재귀 제거(LL 파서 대비)
- 직접 좌재귀: $$A\to A\alpha \mid \beta$$  
  →  
  ```
  A → β A'
  A'→ α A' | ε
  ```

### 4.4 좌인수분해(Left Factoring)
- 공통 접두를 묶어 **LL(1)** 예측 충돌 회피.
- 예:  
  ```
  S → if E then S else S | if E then S
  ```
  →  
  ```
  S → if E then S S'
  S'→ else S | ε
  ```

### 4.5 FIRST/FOLLOW & LL(1) 테이블
- **FIRST**: 어떤 비단말에서 시작해 **먼저 나올 수 있는 단말** 집합.
- **FOLLOW**: 비단말 바로 뒤에 **나올 수 있는 단말** 집합.
- 예측 파싱 표를 구축해 **충돌 없으면 LL(1)**.

---

## 5) 파싱 알고리즘 — LL(1) (재귀하강) & CYK (CNF)

### 5.1 재귀 하강(LL(1)) 파서 — 산술식 예제
문법(우선순위/좌결합):
```
E → T ( + T )*
T → F ( * F )*
F → ( E ) | num
```
**토크나이저 + 파서 + 평가기 (간결 구현)**

```python
import re

# 1) Lexer
TOKENS = [
    ('NUM',  r'\d+'),
    ('PLUS', r'\+'),
    ('MUL',  r'\*'),
    ('LP',   r'\('),
    ('RP',   r'\)'),
    ('WS',   r'\s+'),
]
master = re.compile('|'.join(f'(?P<{n}>{p})' for n,p in TOKENS))

def lex(s):
    for m in master.finditer(s):
        kind = m.lastgroup
        if kind == 'WS': 
            continue
        yield (kind, m.group())
    yield ('EOF','')

# 2) Parser (E,T,F) with recursive descent + evaluator
class Parser:
    def __init__(self, tokens):
        self.tokens = iter(tokens)
        self.cur = next(self.tokens)

    def eat(self, kind):
        if self.cur[0] == kind:
            self.cur = next(self.tokens)
        else:
            raise SyntaxError(f'expected {kind}, got {self.cur}')

    def parse(self):
        val = self.E()
        if self.cur[0] != 'EOF': 
            raise SyntaxError('extra input')
        return val

    def E(self):
        # E → T ( + T )*
        val = self.T()
        while self.cur[0]=='PLUS':
            self.eat('PLUS')
            val = val + self.T()
        return val

    def T(self):
        # T → F ( * F )*
        val = self.F()
        while self.cur[0]=='MUL':
            self.eat('MUL')
            val = val * self.F()
        return val

    def F(self):
        # F → ( E ) | num
        if self.cur[0]=='LP':
            self.eat('LP')
            val = self.E()
            self.eat('RP')
            return val
        elif self.cur[0]=='NUM':
            v = int(self.cur[1]); self.eat('NUM'); return v
        else:
            raise SyntaxError(f'unexpected token {self.cur}')

def eval_expr(s):
    return Parser(lex(s)).parse()

print(eval_expr("2+3*4"))   # 14 (우선순위 적용)
print(eval_expr("(2+3)*4")) # 20
```

### 5.2 CYK 알고리즘(CNF) — 멤버십 판정
- **CNF**: $$A\to BC \ \text{or}\ A\to a \ (\text{또는 } S\to\varepsilon)$$
- **시간복잡도**: $$O(n^3\cdot|P|)$$
- **적용**: 일반 CFG 멤버십(파싱) 판정, 문법이 CNF로 변환되어 있어야 함.

```python
from collections import defaultdict

def cyk_accepts(grammar, start, w):
    """
    grammar: dict[str, list[tuple]] with CNF rules
    start: start symbol
    w: input string (str)
    """
    if isinstance(w, str): w = list(w)
    n = len(w)
    if n == 0:
        # CNF에서 ε 허용 여부는 별도 규칙(S->ε)로 처리
        return any(rule == ('',) for rule in grammar.get(start, []))
    # P[i][l] = set of nonterminals that derive substring w[i:i+l]
    P = [[set() for _ in range(n+1)] for _ in range(n)]
    # length = 1
    for i, a in enumerate(w):
        for A, rules in grammar.items():
            for rhs in rules:
                if len(rhs)==1 and rhs[0]==a:
                    P[i][1].add(A)
    # length = 2..n
    for l in range(2, n+1):
        for i in range(n-l+1):
            for s in range(1, l):
                lefts  = P[i][s]
                rights = P[i+s][l-s]
                if not lefts or not rights:
                    continue
                for A, rules in grammar.items():
                    for rhs in rules:
                        if len(rhs)==2:
                            B,C = rhs
                            if B in lefts and C in rights:
                                P[i][l].add(A)
    return start in P[0][n]

# 예: 균형 괄호의 단순 CNF 근사(교육용)
G = {
  'S': [('S','S'), ('B',)],
  'B': [('(', 'C')],
  'C': [('S',')'), (')',)]
}
print(cyk_accepts(G, 'S', "()()"))  # True (스케치용 문법)
print(cyk_accepts(G, 'S', "(()"))   # False
```

> **실무 Tip**: 복잡 문법은 **Earley/GLR** 같은 보편 파서를 쓰면 CNF 변환 없이도 처리 가능.

---

## 6) 정규 vs 문맥자유 — 폐쇄성, 결정문제, 펌핑 보조정리

### 6.1 폐쇄성(Closure)
- **정규 언어**: 합/교/여/차/연결/Kleene-스타/역상 등 **대부분 닫힘**.
- **CFL**: 합/연결/Kleene-스타에는 닫힘.  
  교/여/차는 일반적으로 **닫혀있지 않음**.  
  (단, CFL ∩ 정규는 CFL)

### 6.2 결정문제(결정가능/불가능)
| 문제 | 정규 | CFL |
|---|---|---|
| 공집합성 | 결정가능 | 결정가능 |
| 유한성 | 결정가능 | 결정가능 |
| 포함성/동치성/보편성 | 결정가능 | **일반적으로 불가능** |

### 6.3 펌핑 보조정리(정규/CFL)
- **정규 펌핑**: 충분히 긴 $$w=xyz$$, $$|y|>0, |xy|\le p, \ \forall i\ge 0: xy^iz\in L$$
- **CFL 펌핑(Bar-Hillel)**: $$w=uvxyz,\ |vxy|\le p,\ |vy|>0,\ \forall i\ge 0: uv^ixy^iz\in L$$  
→ **반례 구성**으로 비정규성/비CFL 판정.

---

## 7) 실전 문법 설계 — JSON-Lite/미니 언어/조건문

### 7.1 JSON-Lite (문자열·정수·배열·객체)
```
Value   → String | Int | Array | Object
Array   → [ Elements ] | []
Elements→ Value ( , Value )*
Object  → { Pairs } | {}
Pairs   → Pair ( , Pair )*
Pair    → String : Value
String  → " chars "
Int     → digit+
```
- **렉서**: 토큰(중괄호/대괄호/콜론/컴마/문자열/정수/공백)으로 분리
- **파서**: LL(1) 재귀하강으로 충분(좌인수·좌재귀 없음)

### 7.2 Dangling-Else 문제
```
S → if E then S | if E then S else S | other
```
- 모호. **우선순위 규칙 / 좌인수분해**로 해결:
```
S  → if E then S S' | other
S' → else S | ε
```

### 7.3 간단 DSL(수식+할당)
```
Stmt   → id = Expr | print ( Expr )
Expr   → Term ( + Term )*
Term   → Factor ( * Factor )*
Factor → ( Expr ) | id | num
```
- **심볼 테이블**을 두고 **해석기** 구현 가능.

---

## 8) 엔드-투-엔드 파이프라인(렉서→파서→AST→평가)

아래는 “할당/print”가 있는 **미니 스크립트**의 **렉서+파서+평가기** 예시입니다.

```python
import re

# ---------- Lexer ----------
TOK = [
    ('PRINT', r'print'),
    ('ID',    r'[A-Za-z_]\w*'),
    ('NUM',   r'\d+'),
    ('EQ',    r'='),
    ('PLUS',  r'\+'),
    ('MUL',   r'\*'),
    ('LP',    r'\('),
    ('RP',    r'\)'),
    ('SC',    r';'),
    ('WS',    r'\s+'),
]
lex_re = re.compile('|'.join(f'(?P<{n}>{p})' for n,p in TOK))
def tokenize(code):
    for m in lex_re.finditer(code):
        k = m.lastgroup
        if k == 'WS':
            continue
        yield (k, m.group())
    yield ('EOF','')

# ---------- Parser to AST ----------
class AST: pass
class StmtList(AST):
    def __init__(self, stmts): self.stmts = stmts
class Assign(AST):
    def __init__(self, name, expr): self.name, self.expr = name, expr
class Print(AST):
    def __init__(self, expr): self.expr = expr
class BinOp(AST):
    def __init__(self, op, l, r): self.op, self.l, self.r = op, l, r
class Num(AST):
    def __init__(self, v): self.v = v
class Var(AST):
    def __init__(self, name): self.name = name

class Parser:
    def __init__(self, toks):
        self.toks = iter(toks)
        self.cur = next(self.toks)

    def eat(self, k):
        if self.cur[0]==k:
            self.cur = next(self.toks)
        else: raise SyntaxError(f'expected {k}, got {self.cur}')

    def parse(self):
        stmts=[]
        while self.cur[0] != 'EOF':
            stmts.append(self.stmt())
            if self.cur[0]=='SC': self.eat('SC')
            elif self.cur[0]!='EOF': raise SyntaxError('missing ;')
        return StmtList(stmts)

    def stmt(self):
        if self.cur[0]=='PRINT':
            self.eat('PRINT'); self.eat('LP')
            e=self.expr(); self.eat('RP')
            return Print(e)
        elif self.cur[0]=='ID':
            name=self.cur[1]; self.eat('ID'); self.eat('EQ')
            e=self.expr(); return Assign(name,e)
        else:
            raise SyntaxError('invalid statement')

    def expr(self):
        # Expr → Term ( + Term )*
        v=self.term()
        while self.cur[0]=='PLUS':
            self.eat('PLUS')
            v=BinOp('+', v, self.term())
        return v

    def term(self):
        # Term → Factor ( * Factor )*
        v=self.factor()
        while self.cur[0]=='MUL':
            self.eat('MUL')
            v=BinOp('*', v, self.factor())
        return v

    def factor(self):
        if self.cur[0]=='LP':
            self.eat('LP'); v=self.expr(); self.eat('RP'); return v
        elif self.cur[0]=='NUM':
            n=int(self.cur[1]); self.eat('NUM'); return Num(n)
        elif self.cur[0]=='ID':
            name=self.cur[1]; self.eat('ID'); return Var(name)
        else:
            raise SyntaxError('expected factor')

# ---------- Evaluator ----------
def eval_program(ast):
    env={}
    out=[]
    def eval_expr(e):
        if isinstance(e, Num): return e.v
        if isinstance(e, Var):
            if e.name not in env: raise NameError(e.name)
            return env[e.name]
        if isinstance(e, BinOp):
            l=eval_expr(e.l); r=eval_expr(e.r)
            return l+r if e.op=='+' else l*r
        raise TypeError('expr?')

    for s in ast.stmts:
        if isinstance(s, Assign):
            env[s.name]=eval_expr(s.expr)
        elif isinstance(s, Print):
            out.append(eval_expr(s.expr))
        else:
            raise TypeError('stmt?')
    return out, env

code = """
x = 2 + 3 * 4;
y = (x + 1) * 2;
print(y)
"""
ast = Parser(tokenize(code)).parse()
result, env = eval_program(ast)
print(result, env)  # [30] {'x':14, 'y':30}
```

> **해설**  
> - “정규식 기반 렉싱(DFA)” → “CFG 기반 파싱(PDA 모델)” → “AST 해석/코드생성”의 전형적인 컴파일러 프론트엔드 흐름을 축약 구현.

---

## 9) 수학적 보강: 형태/정규형/수식

### 9.1 문맥자유문법의 CNF/GNF
- **CNF**(Chomsky Normal Form): $$A\to BC \ \text{or}\ A\to a \ \text{(또는 }S\to\varepsilon)$$  
  CYK에 적합.
- **GNF**(Greibach Normal Form): $$A\to a\alpha$$ (우선단말 시작).  
  LL 파싱 분석에 유리한 정규형.

### 9.2 정규식의 귀납적 정의
- $$\emptyset,\ \varepsilon,\ a\in\Sigma$$ 는 정규식.
- $$r,s$$ 정규식이면  
  $$r|s,\ rs,\ r^*$$ 도 정규식.

### 9.3 파싱의 수학적 판정
- DFA 멤버십:  
  $$\delta^*(q_0,w)\in F \Rightarrow w\in L(M)$$
- PDA 멤버십(빈스택 수용):  
  입력 종료 & 스택 빈 상태 ⇒ 수용.

---

## 10) 실무 포인트 & 안전성

- **정규식 안전성**: 백트래킹 엔진의 **Catastrophic backtracking** 회피  
  (겹치는 가변 길이 수량자 중첩 지양; 선형시간 엔진/컴파일된 DFA 선호).
- **문법 모듈화**: EBNF(반복/옵션)로 가독성, 구현은 BNF로 내림.
- **오류 복구**: 파서에서 **Panic-mode** 또는 **에러 비단말**로 재동기화.
- **국제화**: 입력 알파벳(Σ) 명확화(유니코드 클래스), 정규화(NFC).

---

## 11) 연습 & 과제

1) $$L=\{w\in\{0,1\}^* \mid w \text{에서 }1\text{의 개수가 }3\text{의 배수}\}$$ 의 **최소 DFA**를 설계하고 코드로 시뮬레이터 작성.  
2) 모호한 산술 문법을 **우선순위/결합성**이 반영된 비모호 문법으로 바꾸고, 재귀하강 파서로 평가기 구현.  
3) 균형괄호 언어의 **CNF 변환**을 수행하고 CYK로 멤버십 판정 테스트(샘플 10개).  
4) $$L=\{a^n b^n c^n\}$$ 가 **CFL이 아님**을 펌핑 보조정리(바루–힐) 스케치로 정리.  
5) JSON-Lite 문법에 문자열 이스케이프/부호있는 정수/공백 규칙을 추가하여 **LL(1)** 유지되도록 FIRST/FOLLOW로 검증.

---

## 12) 핵심 요약

- **언어**는 문자열 집합, **문법**은 언어를 생성하는 규칙.  
- **정규 언어**는 DFA/NFA/정규식으로 인식/표현(선형시간).  
- **문맥자유 언어**는 PDA로 인식, 실무는 LL/LR/Earley/GLR 파서.  
- **문법 설계**는 모호성 제거, 좌재귀 제거, 좌인수분해, FIRST/FOLLOW 가 핵심.  
- **파이프라인**: Regex(렉싱) → CFG(파싱) → AST(해석/코드생성).  
- **안전성/품질**: 정규식 안전, 오류 복구, 국제화, 테스트(커버리지)!