---
layout: post
title: JavaScript - 무한 스크롤 구현하기
date: 2025-05-18 23:20:23 +0900
category: JavaScript
---
# 자바스크립트로 무한 스크롤 구현하기 (Infinite Scroll)

## 1. 기본 구현 (window scroll)

아래는 더미 API(JSONPlaceholder)로 글을 10개씩 불러오는 가장 단순한 형태입니다.

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>무한 스크롤 — 기본</title>
  <link rel="stylesheet" href="./style.css" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>
<body>
  <main class="wrap">
    <h1>무한 스크롤 예제</h1>
    <section id="list"></section>
    <div id="loading" role="status" aria-live="polite" class="loading">로딩 중...</div>
  </main>
  <script src="./app.basic.js" defer></script>
</body>
</html>
```

```css
/* style.css */
*{box-sizing:border-box}
body{font-family:system-ui,sans-serif;margin:24px}
.wrap{max-width:720px;margin:0 auto}
.card{border-bottom:1px solid #ddd;padding:12px 0}
.card h3{margin:.25rem 0}
.loading{text-align:center;padding:12px;color:#666;display:none}
.end{color:#888;text-align:center;padding:12px}
```

```js
// app.basic.js
const list = document.getElementById("list");
const loading = document.getElementById("loading");

let page = 1;
const limit = 10;
let isLoading = false;
let hasMore = true;

async function loadMore() {
  if (isLoading || !hasMore) return;
  isLoading = true;
  loading.style.display = "block";

  try {
    const res = await fetch(`https://jsonplaceholder.typicode.com/posts?_page=${page}&_limit=${limit}`);
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();

    data.forEach(renderItem);

    // 리스트가 비거나, 마지막 페이지 추정
    if (data.length < limit) {
      hasMore = false;
      const end = document.createElement("div");
      end.className = "end";
      end.textContent = "모든 콘텐츠를 불러왔습니다.";
      list.appendChild(end);
    } else {
      page++;
    }
  } catch (e) {
    console.error(e);
  } finally {
    isLoading = false;
    loading.style.display = "none";
  }
}

function renderItem(post) {
  const div = document.createElement("article");
  div.className = "card";
  div.innerHTML = `<h3>${post.id}. ${escapeHtml(post.title)}</h3>
                   <p>${escapeHtml(post.body)}</p>`;
  list.appendChild(div);
}

// XSS 방지 간단 유틸
function escapeHtml(s="") {
  return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

// 바닥 근접 시 로드
window.addEventListener("scroll", () => {
  const {scrollTop, scrollHeight, clientHeight} = document.documentElement;
  if (scrollTop + clientHeight >= scrollHeight - 200) {
    loadMore();
  }
});

// 초기 로드
loadMore();
```

핵심 로직:
- **임계값(200px)** 이전에 선제 로드 → 사용자 체감 지연 감소
- `isLoading`, `hasMore`로 **중복 호출/끝 감지** 방지

---

## 2. 개선: 중복요청/임계값/로딩 상태

현업에서는 다음이 기본 요구됩니다.

- **isLoading**: 한 번에 한 요청만
- **hasMore**: 더 이상 데이터 없음 표시
- **로딩 표현(ARIA)**: 스크린리더 공지
- **오류 표시/재시도**: 네트워크 실패 가시화

위 기본 코드에 모두 반영되어 있습니다. 이어서 **Observer** 버전을 권장합니다.

---

## 3. IntersectionObserver 버전 (권장)

스크롤 이벤트 대신 **감시용 센티넬** 요소가 뷰포트에 들어오면 로드합니다.
이 접근은 스크롤 핸들러 연산/빈도 문제를 줄이고 모바일에서 특히 안정적입니다.

```html
<!-- index.html 내 list 하단에 센티넬 -->
<section id="list"></section>
<div id="sentinel" aria-hidden="true"></div>
<div id="loading" class="loading" role="status" aria-live="polite"></div>
```

```js
// app.observer.js
const list = document.getElementById("list");
const sentinel = document.getElementById("sentinel");
const loading = document.getElementById("loading");

let page = 1, limit = 10;
let isLoading = false, hasMore = true;

const io = new IntersectionObserver(async (entries) => {
  const entry = entries[0];
  if (entry.isIntersecting && !isLoading && hasMore) {
    await loadMore();
  }
}, { root: null, threshold: 0 });

io.observe(sentinel);

async function loadMore() {
  isLoading = true;
  loading.style.display = "block";
  try {
    const res = await fetch(`https://jsonplaceholder.typicode.com/posts?_page=${page}&_limit=${limit}`);
    if (!res.ok) throw new Error("HTTP " + res.status);
    const arr = await res.json();
    arr.forEach(renderItem);

    if (arr.length < limit) {
      hasMore = false;
      io.unobserve(sentinel);
      sentinel.remove();
      const end = document.createElement("div");
      end.className = "end";
      end.textContent = "모든 콘텐츠를 불러왔습니다.";
      list.appendChild(end);
    } else {
      page++;
    }
  } catch (e) {
    console.error(e);
    showRetry();
  } finally {
    isLoading = false;
    loading.style.display = "none";
  }
}

function renderItem(post) {
  const a = document.createElement("article");
  a.className = "card";
  a.innerHTML = `<h3>${post.id}. ${escapeHtml(post.title)}</h3>
                 <p>${escapeHtml(post.body)}</p>`;
  list.appendChild(a);
}

function showRetry() {
  const box = document.createElement("div");
  box.className = "end";
  box.innerHTML = `불러오기 실패 <button id="retry">재시도</button>`;
  list.appendChild(box);
  document.getElementById("retry").addEventListener("click", () => {
    box.remove();
    loadMore();
  }, { once: true });
}

function escapeHtml(s=""){return s.replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]))}

// 초기 프리페치
loadMore();
```

포인트:
- `io.observe(sentinel)`가 **자동 트리거** 역할
- 마지막 페이지에서 `unobserve`로 **감지 해제**

---

## 4. 네트워크 안정성: 취소/디바운스·스로틀/레이스 방지

### AbortController — 오래 걸리는 이전 요청 취소

검색어 변경 등으로 **이전 요청 결과가 뒤늦게 도착**하는 레이스를 막아야 합니다.

```js
let aborter = null;

async function fetchJson(url) {
  if (aborter) aborter.abort();
  aborter = new AbortController();
  try {
    const res = await fetch(url, { signal: aborter.signal });
    if (!res.ok) throw new Error("HTTP " + res.status);
    return await res.json();
  } finally {
    aborter = null;
  }
}
```

### 디바운스/스로틀

- **디바운스**: 사용자가 멈춘 뒤 N ms 후 1회 (검색 입력)
- **스로틀**: N ms마다 최대 1회 (빈번 스크롤 핸들러)

```js
function debounce(fn, ms=300){
  let t=0; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); };
}
function throttle(fn, ms=200){
  let last=0; return (...args)=>{ const now=Date.now(); if (now-last>=ms){ last=now; fn(...args); } };
}
```

### 레이스 방지 — 응답 세대(version) 체크

요청마다 증가하는 **버전 번호**를 두고, **가장 최신** 응답만 반영합니다.

```js
let version = 0;

async function loadMoreSafe() {
  const myv = ++version;
  const data = await fetchJson(buildUrl());
  if (myv !== version) return; // 더 최신 요청이 존재 → 무시
  render(data);
}
```

---

## 5. 페이지네이션 설계: 페이지 기반 vs 커서 기반

### 페이지 기반(page/limit)
- 구현 쉬움, SEO 친화(`/list?page=3`)
- 단점: **중간 삽입/삭제**로 페이지 내용이 변할 수 있어 스크롤 위치가 흔들림

### 커서 기반(cursor/limit)
- `next_cursor`를 응답으로 받아 다음 요청에 전달
- **중간 변경에 강함**, 무한스크롤에 적합

**응답 예시(커서 기반):**
```json
{
  "items": [{...}, {...}],
  "next_cursor": "78f2a...==",
  "has_next": true
}
```

**클라이언트:**
```js
let cursor = null;
let hasNext = true;

async function loadCursorPage() {
  if (!hasNext) return;
  const url = new URL("/api/feed", location.origin);
  url.searchParams.set("limit", "20");
  if (cursor) url.searchParams.set("cursor", cursor);

  const data = await fetchJson(url.toString());
  data.items.forEach(renderItem);
  cursor = data.next_cursor || null;
  hasNext = !!data.has_next;
}
```

---

## 6. 끝 감지/에러·재시도/스켈레톤 UI

### “끝” 처리
- `hasNext === false`이면 센티넬를 **해제**하고 “끝” 메시지
- 데이터가 매우 적을 경우 초기 로딩에서 **즉시 끝**

### 에러/재시도
- 네트워크·서버 에러를 사용자에게 명확히 표시
- **재시도 버튼** 또는 자동 **지수 백오프**(400→800→1600ms)

```js
async function fetchWithBackoff(url, {retries=3, base=400}={}) {
  for (let i=0; i<=retries; i++){
    try {
      const r = await fetch(url);
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } catch (e) {
      if (i === retries) throw e;
      await new Promise(r => setTimeout(r, base * 2 ** i));
    }
  }
}
```

### 스켈레톤 UI
- 로딩 시 카드 형태의 **회색 블럭**을 먼저 렌더링
- 데이터 도착 후 **교체**: **레이아웃 점프** 감소, 체감 반응성↑

```css
.skeleton{background:linear-gradient(90deg,#eee 25%,#f5f5f5 37%,#eee 63%);background-size:400% 100%;animation:shine 1.4s ease infinite;height:86px;margin:12px 0;border-radius:8px}
@keyframes shine{0%{background-position:200% 0}100%{background-position:-200% 0}}
```

---

## 7. 스크롤 컨테이너, iOS bounce, 고정 헤더

### 스크롤 컨테이너 내부 무한 스크롤

윈도우가 아닌 **특정 컨테이너**가 스크롤을 담당할 수 있습니다.

```html
<div id="scrollBox" class="box">
  <section id="list"></section>
  <div id="sentinel"></div>
</div>
```

```css
.box{height:60vh; overflow:auto; border:1px solid #ddd; padding:8px}
```

```js
const box = document.getElementById("scrollBox");
const observer = new IntersectionObserver(cb, { root: box, threshold: 0.1 });
observer.observe(document.getElementById("sentinel"));
```

### iOS bounce/주소창 수축
- iOS Safari는 상하 바운스/주소창 수축으로 `innerHeight`가 흔들립니다.
- **IntersectionObserver**는 이런 환경 변화에 더 강합니다.
- 필요시 컨테이너에 `overscroll-behavior: contain;`로 상위 스크롤 전파 억제.

```css
html,body{overscroll-behavior-y:none}
.box{overscroll-behavior:contain}
```

### 고정 헤더/푸터
- 센티넬은 **실제 컨텐츠 끝**의 **보이는 영역**에 있어야 합니다.
- 헤더가 fixed면 **센티넬 하단 마진**을 넉넉히 두세요.

---

## 8. 성능 최적화

### 가상 스크롤(virtualization)
- 항목이 수천 개 이상이면 **DOM 노드 재사용**이 필수
- 뷰포트 근처 아이템만 렌더링 → 스크롤 위치 기반 계산

간단 아이디어:
- 아이템 높이가 고정이라면 **인덱스→픽셀** 매핑으로 윈도우 렌더
- 상단/하단 **placeholder** div로 총 높이 확보

```js
// 개념 스케치: 실제 프로덕션은 라이브러리(react-window/virtual-scroller) 권장
const viewport = document.getElementById("viewport");
const spacerTop = document.createElement("div");
const spacerBottom = document.createElement("div");
const pool = document.createElement("div");
viewport.append(spacerTop, pool, spacerBottom);

const ROW_H = 80;
let items = []; // 전체 배열
function renderWindow(scrollTop) {
  const start = Math.max(0, Math.floor(scrollTop / ROW_H) - 5);
  const end = Math.min(items.length, start + 30);
  spacerTop.style.height = (start * ROW_H) + "px";
  spacerBottom.style.height = ((items.length - end) * ROW_H) + "px";
  pool.innerHTML = "";
  for (let i=start; i<end; i++){
    const el = document.createElement("div");
    el.className = "card"; el.style.height = ROW_H+"px";
    el.textContent = items[i].title;
    pool.appendChild(el);
  }
}
viewport.addEventListener("scroll", e=>renderWindow(e.target.scrollTop));
```

### 이미지 지연 로딩
- `<img loading="lazy">` 또는 IntersectionObserver로 **프리로딩**
- **LQIP**(낮은 해상도) → 교체

```html
<img data-src="big.jpg" alt="thumb" width="320" height="180" />
```

```js
const imgs = document.querySelectorAll("img[data-src]");
const imgObserver = new IntersectionObserver((ents)=>{
  ents.forEach(ent=>{
    if(ent.isIntersecting){
      const img = ent.target;
      img.src = img.dataset.src;
      img.removeAttribute("data-src");
      imgObserver.unobserve(img);
    }
  });
});
imgs.forEach(img=>imgObserver.observe(img));
```

### 캐싱/프리패치
- 페이지별 응답을 **Map(url→data)** 로 메모리 캐싱
- 사용자가 바닥 근처면 **다음 페이지 미리 요청**(백그라운드 프리패치)

---

## 9. 접근성/SEO 폴백

무한 스크롤은 **페이지 구조가 사라져 SEO가 불리**할 수 있습니다. 권장:

- **“더보기” 버튼** 제공(키보드/스크린리더 접근성 ↑)
- URL에 `?page=` 동기화: 새로고침/공유 시 동일 위치
- `<noscript>`에 페이지네이션 링크 제공
- 중요한 페이지는 **서버 렌더링/정적 페이지**로 인덱싱

```html
<button id="loadMoreBtn">더보기</button>
<script>
  const btn = document.getElementById("loadMoreBtn");
  btn.addEventListener("click", loadMore);
</script>
```

---

## 10. 모듈 구조/테스트/체크리스트

### 모듈 추천 구조

```
/src
  api.js          // fetchJson, backoff, abort 관리
  paginator.js    // page/cursor 상태, hasMore
  renderer.js     // renderCard, renderSkeleton
  infinite.js     // IO 생성/해제, sentinel 관리
  index.js        // 초기화 glue
```

### 테스트 포인트
- 작은 화면/큰 화면/고해상도
- 느린 네트워크(Throttle)와 끊김(Offline/Online)
- 에러/429 제한/재시도 동작
- 첫 페이지가 limit보다 작을 때 즉시 “끝”
- 스크롤 컨테이너/윈도우 전환
- 가상 키보드(모바일)로 viewport 변형

### 체크리스트
- [ ] isLoading/hasMore 철저
- [ ] 취소/레이스 방지 (Abort/버전)
- [ ] 스켈레톤/에러/재시도
- [ ] Observer root/threshold 적절
- [ ] 이미지 lazy
- [ ] SEO 폴백(더보기/링크)
- [ ] 메모리 릭 방지: unobserve/removeEventListener

---

## 11. 부록 — React + IntersectionObserver 훅 예시

```jsx
// useIntersection.js
import { useEffect, useRef, useState } from "react";

export function useIntersection({ root=null, rootMargin="0px", threshold=0 } = {}) {
  const ref = useRef(null);
  const [intersecting, setInter] = useState(false);

  useEffect(() => {
    if (!ref.current) return;
    const io = new IntersectionObserver(([entry]) => {
      setInter(entry.isIntersecting);
    }, { root, rootMargin, threshold });
    io.observe(ref.current);
    return () => io.disconnect();
  }, [root, rootMargin, threshold]);

  return [ref, intersecting];
}
```

{% raw %}
```jsx
// Feed.jsx
import { useEffect, useRef, useState } from "react";
import { useIntersection } from "./useIntersection";

async function fetchPage({ cursor, limit=20 }) {
  const url = new URL("/api/feed", location.origin);
  url.searchParams.set("limit", limit);
  if (cursor) url.searchParams.set("cursor", cursor);
  const r = await fetch(url); if (!r.ok) throw new Error("HTTP "+r.status);
  return r.json();
}

export default function Feed() {
  const [items, setItems] = useState([]);
  const [cursor, setCursor] = useState(null);
  const [hasNext, setHasNext] = useState(true);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [sentinelRef, inView] = useIntersection({ threshold: 0 });
  const aborter = useRef(null);
  const version = useRef(0);

  useEffect(() => {
    if (inView && !loading && hasNext) loadMore();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [inView]);

  async function loadMore() {
    setLoading(true); setError("");
    if (aborter.current) aborter.current.abort();
    aborter.current = new AbortController();
    const myv = ++version.current;

    try {
      const data = await fetchPage({ cursor });
      if (myv !== version.current) return; // stale
      setItems(prev => [...prev, ...data.items]);
      setCursor(data.next_cursor || null);
      setHasNext(!!data.has_next);
    } catch (e) {
      if (e.name !== "AbortError") setError("불러오기 실패");
    } finally {
      setLoading(false);
    }
  }

  return (
    <main>
      <ul>
        {items.map(x => <li key={x.id}>{x.title}</li>)}
      </ul>
      {error && <div role="alert">{error} <button onClick={loadMore}>재시도</button></div>}
      {loading && <div aria-live="polite">로딩 중...</div>}
      {hasNext ? <div ref={sentinelRef} style={{height:1}} /> : <div className="end">끝</div>}
    </main>
  );
}
```
{% endraw %}

---

## 결론

- **IntersectionObserver + 커서 기반 페이지네이션**이 무한 스크롤의 표준적인 해법입니다.
- 실무 핵심은 **요청 중복·레이스 방지**, **취소/재시도**, **끝 감지**, **스켈레톤/에러 UI**, **가상 스크롤**, **접근성·SEO 폴백**입니다.
- 위 예제들을 조합하면 SNS 피드/뉴스/상품 목록 등 대부분의 무한 스크롤 요구사항을 안정적으로 충족할 수 있습니다.
