---
layout: post
title: 형식언어와 오토마타 - 다항식 시간 변형
date: 2025-08-15 14:20:23 +0900
category: 형식언어와 오토마타
---
# 다항식 시간 변형(Polynomial-time Reductions)

**핵심 요지**
- “변형(reduction)”은 **문제 A를 문제 B로 자동 번역**해, B를 풀 줄 알면 A도 풀게 만드는 절차다.
- **다항식 시간 변형**은 번역기 \(f\)가 **입력 크기에 대해 다항시간**에 계산되면 충분하다.
- NP-완전성 증명에선 보통 **Karp(=many-one) 변형**을 쓴다.
  Turing(=oracle) 변형, **logspace** 변형, **근사 보존(AP/L)** 변형, **계수(parsimonious)** 변형, **FPT/미세 복잡도** 변형 등 **맥락별 변형**도 많다.

---

## 기본 정의와 성질

### Karp(=many-one) 다항식 시간 변형

언어(결정 문제) \(A,B \subseteq \Sigma^*\)에 대해
$$
A \le^{p}_{m} B
\iff
\exists f:\Sigma^*\!\to\!\Sigma^*,\ \text{poly-time},\ \forall x,\ x\in A \Leftrightarrow f(x)\in B.
$$
- 한 번의 **직접 번역** \(x\mapsto f(x)\) (오라클 질의 없음).
- **성질**: 전이성(Transitivity), 반사성(Reflexivity).
  \(A \le^{p}_{m} B\)이고 \(B\in\mathbf{P}\)면 \(A\in\mathbf{P}\).

### Turing(=oracle) 다항식 시간 변형

\(A \le^{p}_{T} B\): 다항시간 알고리즘이 **\(B\) 오라클을 여러 번 질의**해 \(A\)를 푼다.
- Karp보다 **약한 제약(더 강한 도움)**.
- **NP-완전성 표준은 Karp 변형**(쿡/카프 전통). Turing 변형만으로는 “NP-완전” 주장이 **약**하다.

### “어려움의 방향”

$$
A \le B \ \Rightarrow\ B\ \text{는 최소한}\ A\ \text{만큼 어렵다}.
$$
그래서 **어려운 문제에서 쉬운 문제로** 화살표를 그린다. (예: \(3\text{-SAT} \to \text{CLIQUE}\))

---

## 왜 중요한가 — NP-완전성의 도구

- \(C\in\mathbf{NP}\)이고, **NP의 모든 문제**가 \(C\)로 Karp 변형되면 \(C\)는 **NP-완전**.
- 실무 해석: **P≠NP 가정**하에 NP-완전 문제는 일반적으로 **다항시간 해법이 기대되기 어렵다**.

---

## 변형의 **종류 지도(Overview)**

### 고전

- **Karp(many-one)**: NP-완전성 표준.
- **Turing(oracle)**: 복잡도 계층(예: \(\mathbf{P}^{\mathbf{NP}}\)) 논의에 유용.

### 자원 제약 보존

- **Logspace 변형(≤\_L)**: \(O(\log n)\) 공간으로 \(f\) 계산.
  P-완전/NL-완전/L-완전 논의의 표준(예: STCON은 NL-완전(≤\_L)).
- **NC/AC 변형**: 병렬 회로 깊이/크기 제약을 보존.

### 목적 특화

- **Parsimonious 변형**: **해의 개수**까지 보존 → **#P**(계수)에서 핵심. (#SAT → #CSP 등)
- **근사 보존 변형**:
  - **L-변형**(Lenstra–Trevisan류): 최적값 왜곡을 선형계수로 묶어 **근사 비율 전파**.
  - **AP-변형 / PTAS-변형**: \((1+\varepsilon)\)-근사 가능성 보존.
- **Levin 변형(탐색)**: 결정↔탐색 다항 동등성(self-reduction) 논의.
- **FPT 변형**: 파라미터화 복잡도에서 \((x,k)\mapsto(x',k')\)를 \(f(k)\cdot n^{O(1)}\)에 계산, \(k'\le g(k)\) 보장.
- **Fine-grained 변형**: “만약 \(A\)가 \(O(n^{2-\varepsilon})\)면 \(B\)도 \(O(n^{2-\varepsilon'})\)” 같은 **지수/차수 개선** 전파.
- **무작위/평균-사례 변형**: RP/BPP-성질 또는 분포 보존(average-case) 변형.

---

## 변형 **설계 체크리스트**

1) **다항시간**: \(f\) 계산시간/출력 크기 **다항 상계** 확인(길이 blow-up 금지).
2) **정확성(iff)**:
   $$x\in A \iff f(x)\in B$$
   (⇒: **완성도**, ⇐: **정직성** 두 방향 모두 증명).
3) **증인 대응**: NP 맥락이면 **증명서**(해) 대응을 명시(길이 다항 제한).
4) **가젯 재사용**: 변수·절·일관성·선택 강제, at-most-one/정확히-하나 제약, 가중치 스케일링.
5) **약속 문제(promise)** 주의: 이미지가 약속을 지키는지 보장.
6) **목표 보존**: 근사/파라미터/공간 등 **목적 제약**을 보존하는 변형 선택.

---

## 대표 예시 ① — **3-SAT → CLIQUE** (Karp 변형, 풀 스케치)

입력: 3-CNF \(\phi=\bigwedge_{j=1}^m(\ell_{j1}\vee\ell_{j2}\vee\ell_{j3})\).

**그래프 구성**
- 각 절의 각 리터럴을 정점으로(총 \(3m\)).
- **같은 절** 안 정점들끼리는 간선 없음.
- **모순 쌍**(\(x\) vs \(\lnot x\)) 사이도 간선 없음.
- 그 외 모든 쌍엔 간선. 목표 \(k=m\).

**정확성**
- (⇒) 만족 대입이 있으면 각 절에서 **참 리터럴** 하나를 뽑아 \(m\)개 정점 → 모순 간선이 없으니 완전 그래프.
- (⇐) 크기 \(m\) 클리크는 절마다 하나씩 뽑힌 것이고, 모순 간선 부재 규칙상 **일관 대입**이 존재.

**복잡도**: 시간/크기 \(O(m^2)\).

**미니 구현(파이썬, 생성+검증)**

```python
from itertools import combinations

def three_sat_to_clique(clauses, num_vars):
    V = [(j, i) for j in range(len(clauses)) for i in range(3)]
    E = set()
    def conflict(l1, l2):
        return l1[0]==l2[0] and l1[1]!=l2[1]  # (var, is_neg)
    for (j1,i1),(j2,i2) in combinations(V, 2):
        if j1 == j2:
            continue
        l1, l2 = clauses[j1][i1], clauses[j2][i2]
        if not conflict(l1,l2):
            E.add(((j1,i1),(j2,i2))); E.add(((j2,i2),(j1,i1)))
    return V, E, len(clauses)

def is_k_clique(V,E,k,subset):
    return len(subset)==k and all(((u,v) in E) for u,v in combinations(subset,2))
```

---

## 대표 예시 ② — **3-SAT → VERTEX COVER** (연쇄 변형)

CLIQUE 변형 후 보완 그래프 \(\overline{G}\)에서
$$
\text{CLIQUE}(G,k) \iff \text{VERTEX-COVER}(\overline{G},\ |V(G)|-k).
$$
따라서 \(3\text{-SAT}\to\text{CLIQUE}\to\text{VC}\)로 Karp 변형 연결.

---

## 대표 예시 ③ — **3-SAT → 3-COLORING** (색칠 가젯)

**색**: \(\{T, F, B\}\) (Base) 3색을 고정.
- **변수 가젯**: 각 변수 \(x\)에 대해 노드 \(x\), \(\lnot x\)를 만들고, \(B\)-고정 삼각형과 연결해 \(x\)와 \(\lnot x\)가 서로 다른 색(=참/거짓)을 강제.
- **절 가젯**: \((u\vee v\vee w)\) 절에 대해, 세 리터럴 중 **하나 이상**이 \(T\)가 아니면 색칠 불가가 되도록 연결(고전 가젯).

**정확성**: 3-색칠 가능 ⇔ \(\phi\) 만족.

**구성 골격(의사코드)**

```text
build_base_triangle(T,F,B)  # 세 색 고정
for each variable x:
  make nodes X, notX; connect to base so that X,F,B form triangle and notX,F,B form triangle
  connect X--notX
for each clause (ℓ1 ∨ ℓ2 ∨ ℓ3):
  attach clause gadget that forces at least one of ℓi to be colored T
```

---

## 대표 예시 ④ — **3-SAT → SUBSET-SUM** (수치 가젯, 스케치)

**핵심 기법**: 자릿수별(열) 합을 맞추는 **열-코딩**.
- 각 변수에 대해 “\(x_i\)를 선택하면 해당 열에 1, 절 충족 열엔 1을 더하는” **아이템 쌍**을 만든다.
- 각 절마다 “충족 시 carry 없는 정확 합”이 되도록 **목표 합(타겟)**을 설계.
- **정확성**: 타겟을 정확히 만들 수 있으면 각 절마다 최소 한 리터럴이 선택됨.

> 주의: 숫자 크기(비트 길이)가 **다항**인지 확인(지수 크기 금지). 3-PARTITION → BIN PACKING 같은 **strongly NP-hard** 변형과는 대비.

---

## 결정·탐색·최적화: **자기감소(Self-reduction)**

결정판 \(\Rightarrow\) 탐색판(해 복원) 예시(SAT):

```python
def find_sat_with_oracle(phi, oracle_sat):
    assign = {}
    cur = phi
    for x in sorted(phi.vars()):
        if oracle_sat(cur.fix(x, False)):
            assign[x]=False; cur=cur.fix(x, False)
        else:
            assign[x]=True;  cur=cur.fix(x, True)
    return assign
```

최적화판도 **결정 오라클**로 이분탐색·증분 검증해 최적값을 회복(근사 보존 여부는 별도).

---

## **근사 보존** 변형: L-변형 / AP-변형

### L-변형(선형 바운드 보존)

최적값의 차이를 선형계수로 묶어 **근사 비율을 전파**:
- 정의(최대화형 예): 함수 \(f,g\)에 대해
  $$
  \alpha\cdot \big(OPT_A(x)-val_A(y)\big) \le OPT_B(f(x))-val_B(g(x,y)) \le \beta\cdot \big(OPT_A(x)-val_A(y)\big)
  $$
  같은 형태로 **오차 선형 연동**.

**예**: **MAX-3SAT → MAX-CUT**(고전 상수 L-변형).
- 3SAT 절을 작은 그래프로 치환해 “절 만족 수 ↔ 컷 크기”가 선형 연동되도록 가젯 구성.

### AP-변형

\((1+\varepsilon)\)-근사 **가능성 자체**를 보존.
- PTAS 존재/부재를 **전파**하는 데 유용.
- 예: 일부 기하 문제들 간 AP-변형.

---

## **Parsimonious** 변형(계수 보존, #P)

- 정의: 해의 **개수**를 정확히 보존하는 변형(예: #SAT → #CSP).
- 용도: **#P-완전성** 증명, 영점·영수 조건의 세밀 분석.
- 주의: 일반 Karp 변형은 해 개수를 보존하지 않는다(계수 문제에 부적합).

**미니 예(골격)**: **#3SAT → #CSP(arity=3)**
- 각 절을 3-항 제약으로 두고, 변수에 동일성 제약만 추가 → **해 개수 동일**.

---

## **FPT(파라미터화)** 변형 & 커널화

- **FPT-감소**: \((x,k)\mapsto(x',k')\)를 \(f(k)\cdot n^{O(1)}\) 시간에 계산, \(k'\le g(k)\).
- **W[1]-완전**: CLIQUE(\(k\)) 등.
- **커널화**: 다항 커널 존재/부존재는 **OR-합성(cross-composition)** 같은 메타-감소로 분석.

**예**: **CLIQUE(k) → k-Independent-Set(k)**(보완 그래프) — 파라미터 보존.

---

## **Fine-grained** 변형(정밀 시간 하한 전파)

- **SETH 기반**: \(k\)-SAT가 \(2^{(1-\varepsilon)n}\) 불가라면, **Orthogonal Vectors/EDIT/LCS** 등도 \(n^{2-\varepsilon}\) 불가.
- **3SUM-하드**: 많은 기하/데이터 구조 문제가 **아래 차수 개선 불가**(3SUM → 문제)로 알려짐.

**골격 예(설계 관점)**:
```text
if Fast_B on size n exists with O(n^{2-ε}),
then reduce 3SUM of size n to B of size ~n^{1+o(1)},
contradicting known lower bound assumptions.
```

---

## **무작위/평균-사례** 변형

- **Randomized**: RP/BPP 특성 보존.
- **Average-case**(Levin 의미): 입력 분포도 함께 변환 → 평균 난이도 전파.
- 암호학/학습 이론에서 사용(예: worst→average, average→average).

---

## 변형 **증명 템플릿(요약판)**

```text
입력: A-인스턴스 x
1) 목표 B를 정하고, x의 지역 제약과 전역 목표를 분해한다.
2) 가젯 카탈로그에서 조합: 선택 강제, 모순 금지, at-most-one/정확히-하나, 연결·흐름·용량.
3) f(x) 구성: 그래프/식/집합/수치 인코딩(자릿수·가중치 스케일 다항 상계 확인).
4) (⇒) 방향: A의 예-증인 → B의 예-증인(구성과 불변량 설명).
5) (⇐) 방향: B의 예-증인 → A의 예-증인(충돌 없음, 역구성 가능성).
6) 시간·크기 분석: |f(x)| ≤ poly(|x|).
7) (선택) 근사/AP/L·FPT·logspace 등 목적 보존 검증.
```

---

## **가젯 라이브러리**(현장에서 자주 쓰는 조각)

- **Exactly-one**: 3-색칠/일치 그래프에서 “정확히 하나 선택”을 강제(삼각형/팬 구조).
- **At-most-one**: 쌍별 제약( \(O(n^2)\) 간선 ) 또는 **순차 카운터**(선형 크기)로 강제.
- **선택-일관성**: \(x\)와 \(\lnot x\)가 동시에 참/거짓이 되지 않게 하는 간선/제약.
- **수치 합 일치**: SUBSET-SUM/KNAPSACK에서 열 코딩(캐리 없는 자릿수 설계), 가중치 스케일.
- **경로/사이클**: HAMILTONIAN PATH/CYCLE 가젯(턴스타일/도미노형)으로 “정확히 한 번 방문” 강제.
- **플래너 제약**: **Planar-3SAT** 등에서 교차 제거 가젯(와이어 크로스).

---

## **함정과 주의점**

- **Turing 변형 남용**: NP-완전성 **표준은 Karp**. Turing만이면 주장이 약해진다.
- **약속 문제**: 이미지가 약속 영역을 **벗어나지 않음**을 증명할 것.
- **크기 폭증**: \(f(x)\)가 지수 크기면 **다항식 시간 변형 아님**.
- **증인 길이**: NP 검증 프레임에선 증인이 **다항 길이**인지 점검.
- **근사/계수 혼용**: Karp 변형은 **근사 비율**이나 **해 개수**를 보존하지 않는다—전용(AP/L/parsimonious) 변형 사용.
- **의사다항 vs 다항**: \(O(nW)\) 같은 **의사다항** DP는 입력 인코딩(이진 vs 단항)에 민감. **Strongly NP-hard** 여부를 구분.
- **가중치 스케일**: 근사/수치 변형에서 스케일링으로 **다항 비트 길이** 보장 필수.

---

## **코드 예시 모음**

### 3-SAT → CLIQUE 파이프라인 스니펫

```python
def sat_to_clique_and_check(clauses, num_vars):
    V,E,k = three_sat_to_clique(clauses, num_vars)
    # 작은 m에 대해 브루트 포스
    from itertools import combinations
    for subset in combinations(V, k):
        if is_k_clique(V,E,k,subset):
            # 복원: 절마다 선택된 리터럴을 참으로
            assign = {}
            for (j,i) in subset:
                v,neg = clauses[j][i]
                val = not neg
                if v in assign and assign[v]!=val:
                    break
                assign[v]=val
            else:
                return True, assign
    return False, None
```

### **Vertex Cover 2-근사**(최대 매칭 라운딩)

```python
def two_approx_vertex_cover(n, edges):
    used = [False]*n
    cover = set()
    for u,v in edges:
        if not used[u] and not used[v]:
            used[u]=used[v]=True
            cover.add(u); cover.add(v)
    return cover  # |C| ≤ 2·OPT
```

### **L-변형** 검증용 틀(개념 스켈레톤)

```python
def L_reduce_MAX3SAT_to_MAXCUT(phi):
    # 각 절을 작은 그래프로 치환하고, cut-value가 만족 절 수에 선형 비례하도록 구성.
    # 반환: 그래프 G, 상수 alpha,beta (오차 선형 연동 계수)
    G = build_cut_gadgets(phi)  # 가젯 조립
    alpha, beta = 1.0, 1.0      # 실제 값은 가젯 설계에 의존
    return G, alpha, beta
```

---

## **실전 레시피(짧은 체크리스트)**

- (1) **타깃**을 고르고, (2) **가젯**을 조립해, (3) 양방향 정확성, (4) **크기/시간 다항 상계**,
  (5) 목적(근사/FPT/logspace 등) **보존**을 확인하라.

---

## **한 페이지 요약**

- **정의**: \(A \le^{p}_{m} B\) ⇔ 다항시간 \(f\)로 \(x\in A \Leftrightarrow f(x)\in B\).
- **용도**: 완전성 전파(“A가 어렵다 ⇒ B도 어렵다”).
- **종류**: Karp / Turing / logspace / AP·L(근사 보존) / parsimonious(계수) / FPT / Fine-grained / random/average-case.
- **예시**: \(3\text{-SAT}\to\text{CLIQUE}\) → \(\text{VERTEX-COVER}\), \(3\text{-SAT}\to 3\text{-COLORING}\), \(3\text{-SAT}\to\text{SUBSET-SUM}\).
- **체크리스트**: 다항시간·iff·증인 대응·약속 준수·크기 상계·맥락 보존.
- **함정**: Turing 남용, 의사다항 착시, 근사/계수 혼동, 가중치 스케일 누락.

---

## **연습/실험 과제**

1) 임의 3-CNF를 생성해 §5의 **CLIQUE 변형**을 구현하고, 작은 인스턴스에서 브루트포스로 \(k\)-clique를 찾아 **대입 복원**을 검증하라.
2) §7의 3-색칠 가젯을 실제 그래프로 만들어 **색칠 가능성 ⇔ 만족 가능성**을 실험적으로 확인하라.
3) SUBSET-SUM 변형(§8)을 작은 스케일에서 구현해 **자릿수/캐리** 설계를 눈으로 확인하라.
4) MAX-3SAT → MAX-CUT **L-변형** 가젯을 구현하고, 랜덤 인스턴스에서 **근사 오차의 선형 연동**을 수치로 확인하라.
5) **FPT 변형**: CLIQUE(\(k\)) ↔ Independent-Set(\(k\))를 보완 그래프로 연결하고, **작은 \(k\)**에 대해 분기형 알고리즘을 돌려보라.

---

## 부록 A. **정확히-하나**(Exactly-one) 제약 가젯 미니 도감

- **삼각형 가젯**: 세 선택지 중 정확히 하나만 \(T\)가 되게 하는 3-색칠 구조.
- **순차 카운터**: CNF에서 \( \sum x_i = 1 \)을 선형 수의 보조변수로 인코딩(근사/수치 변형에서 유용).
- **모순 금지 간선**: \((x,\lnot x)\) 동시 선택 금지(클리크/독립집합 변형 기본).

---

## 부록 B. **Strongly NP-hard** vs **Pseudo-polynomial** 포인트

- **의사다항**: 값 파라미터 \(W\)에 다항인 \(O(nW)\) 알고리즘은 **이진 인코딩**에서 다항이 아닐 수 있음.
- **Strongly NP-hard** 문제(예: 3-PARTITION)는 **단항 인코딩**이어도 어려움 → FPTAS 불가(표준 가정하).

---

## 부록 C. 미세 복잡도 변형의 정형 정의(스케치)

- \(A \le^{\text{fine}} B\): 임의 \(\varepsilon>0\)에 대해 \(T_B(n)=O(n^{c-\varepsilon})\)가 존재하면 \(T_A(n)=O(n^{d-\varepsilon'})\)가 따라옴.
- 예: **SETH** 하 **Orthogonal Vectors** \(\notin O(n^{2-\varepsilon})\) → LCS/EDIT도 동일 차수 하한 추정.

---

### 마무리

다항식 시간 변형은 **난이도 지도**를 그리는 펜이다.
올바른 변형을 설계·검증·분석하는 습관은 **새로운 문제를 만났을 때의 최단 항로**를 제공한다.
가젯을 정확히 조립하고, 양방향 정확성과 다항 상계를 꼼꼼히 확인하라.
필요하다면 **근사/FPT/logspace/미세 복잡도/계수** 등 맥락에 맞는 변형으로 **맞춤형 주장**을 세우면 된다.
