---
layout: post
title: TCPIP - UDP
date: 2025-08-29 22:25:23 +0900
category: TCPIP
---
# UDP

## 1. 왜 UDP인가

### 1.1 UDP의 핵심 성격

- **비연결(Connectionless)**  
  - TCP처럼 `SYN → SYN/ACK → ACK` 3-way 핸드셰이크가 없다.  
  - 송신자는 **바로** 첫 패킷을 전송할 수 있다.
- **경량(8바이트 고정 헤더)**  
  - TCP(20B 이상)에 비해 헤더가 짧다.  
  - 작은 패킷, 높은 패킷 레이트 환경에서 오버헤드가 적다.
- **비신뢰·순서 미보장**  
  - 패킷 손실/중복/재정렬(순서 꼬임) 발생 가능.  
  - **흐름제어·혼잡제어**가 없다.
- **응용이 전송을 직접 설계**  
  - 신뢰성, 재전송, 혼잡 반응, 암호화, 다중화 등은 **상위 계층/애플리케이션 프로토콜이 책임**.
- 오늘날 **QUIC(HTTP/3)**, **WebRTC**, **게임·미디어 스트리밍** 등 많은 실시간 프로토콜이 UDP 위에서 동작한다.

### 1.2 TCP vs UDP, 언제 어느 쪽인가

| 관점 | TCP | UDP |
|------|-----|-----|
| 연결 | 연결 지향 (3-way handshake) | 비연결, 상태 없음 |
| 신뢰성 | 재전송, 순서 보장, 흐름·혼잡제어 | 없음 (애플리케이션 책임) |
| 지연 | 핸드셰이크·혼잡제어·재전송으로 지연 증가 가능 | 최소한의 오버헤드, 지연 최소화에 유리 |
| 사용 예 | HTTP/1.1/2, SMTP, IMAP, 파일 전송, DB | DNS, RTP, VoIP, 게임, QUIC(HTTP/3 내부), 일부 텔레메트리 |
| 장점 | 안정적, 프로그래밍 단순 | 유연, 저지연, 커스텀 전송 설계 가능 |
| 단점 | 헤더 크고, 커널 내부 구현에 종속 | 신뢰성·혼잡제어를 직접 구현해야 함 |

---

## 2. UDP 헤더 구조와 체크섬

### 2.1 헤더 구조(8바이트 고정)

```text
0               15 16              31 (bit)
+----------------+------------------+
| Source Port    | Destination Port |
+----------------+------------------+
| Length         | Checksum         |
+----------------+------------------+
|            (Payload …)           |
```

- **Source Port (16bit)**  
  - 송신 측 포트. 0일 수 있으나 일반적으로 사용하지 않는다.
- **Destination Port (16bit)**  
  - 수신 측 포트. 애플리케이션별로 정해진 well-known 포트 또는 동적 포트 사용.
- **Length (16bit)**  
  - **UDP 헤더(8B) + 페이로드 전체 길이**(바이트).
- **Checksum (16bit)**  
  - 1의 보수 합으로 계산되는 오류 검출 필드.  
  - IPv4에서는 0이면 “체크섬 미사용” 의미 허용, IPv6에서는 **필수**.

### 2.2 의사 헤더(pseudo-header)와 체크섬 계산

UDP 체크섬은 **단순히 UDP 헤더+데이터만이 아니라, 상위의 IP 정보까지 포함하는 의사 헤더**를 더해 계산한다. 이로 인해 **종단 간 주소/프로토콜까지 포함한 오류 검출**이 가능하다.

#### IPv4 의사 헤더

```text
0               15 16              31 (bit)
+----------------+------------------+
|        Source Address             |
+----------------+------------------+
|      Destination Address          |
+----------------+------------------+
|  zero | Protocol | UDP Length     |
+----------------+------------------+
```

- Source Address: 32비트 IPv4 주소
- Destination Address: 32비트 IPv4 주소
- Protocol: 17(UDP)
- UDP Length: UDP 헤더+데이터 길이

#### IPv6 의사 헤더

```text
0               31 32              63
+----------------+------------------+
|         Source Address (128bit)   |
|                ...                |
+----------------+------------------+
|      Destination Address (128bit) |
|                ...                |
+----------------+------------------+
|        UDP Length (32bit)        |
+----------------+------------------+
| zeroes (24bit)| Next Header(8bit)|
+----------------+------------------+
```

- Source/Destination: 128비트 IPv6 주소
- UDP Length: 32비트
- Next Header: 17(UDP)

#### 체크섬 계산 개요

1. 의사 헤더 + UDP 헤더 + 페이로드를 **16비트 단위 word 배열**로 본다.
2. 길이가 홀수이면 마지막에 1바이트 0 패딩.
3. 모든 word를 **1의 보수 덧셈**으로 더한다.
4. 최종 합을 1의 보수로 뒤집은 값이 체크섬이다.

수식으로 쓰면:

$$
\text{Checksum} = \neg \left( \sum_{i} w_i \right)_{\text{1's complement}}
$$

- 수신 측은 같은 방식으로 모든 word를 더했을 때 **`0xFFFF`(모든 비트 1)**이면 오류가 없는 것으로 간주한다.

#### C 스타일 의사코드 예제

```c
#include <stdint.h>
#include <stddef.h>

static uint16_t ones_complement_add(uint32_t sum, uint16_t val) {
    sum += val;
    if (sum > 0xFFFF)
        sum = (sum & 0xFFFF) + 1; // carry around
    return (uint16_t)sum;
}

uint16_t udp_checksum_ipv4(const uint8_t *src_ip,
                           const uint8_t *dst_ip,
                           uint8_t protocol,
                           const uint8_t *udp_segment,
                           size_t udp_len) {
    uint32_t sum = 0;
    // IPv4 src/dst (4바이트씩 → 16비트 word 두 개)
    for (int i=0;i<4;i+=2) {
        uint16_t w = (src_ip[i] << 8) | src_ip[i+1];
        sum = ones_complement_add(sum, w);
    }
    for (int i=0;i<4;i+=2) {
        uint16_t w = (dst_ip[i] << 8) | dst_ip[i+1];
        sum = ones_complement_add(sum, w);
    }
    // zero + protocol
    sum = ones_complement_add(sum, (uint16_t)protocol);
    // UDP length
    sum = ones_complement_add(sum, (uint16_t)udp_len);

    // UDP header + data
    size_t i;
    for (i = 0; i + 1 < udp_len; i += 2) {
        uint16_t w = (udp_segment[i] << 8) | udp_segment[i+1];
        sum = ones_complement_add(sum, w);
    }
    if (i < udp_len) { // 홀수 길이일 때 마지막 바이트 패딩
        uint16_t w = (udp_segment[i] << 8);
        sum = ones_complement_add(sum, w);
    }

    return ~((uint16_t)sum);
}
```

---

## 3. 비연결·비신뢰 특성

### 3.1 연결 수립·종료 없음

- UDP에는 TCP의 **연결 상태** 개념이 없다.
- 소켓 API에서 `connect()`를 호출하더라도, 커널 내부에서 목적지 주소/포트를 캐시할 뿐, 네트워크에 실제 패킷이 나가지 않는다.
- 따라서:
  - 첫 패킷부터 바로 데이터를 보낼 수 있다.
  - 반대로 말하면, 어떤 노드가 UDP 패킷을 받았다고 해서 “연결이 수립되었다”고 볼 수는 없다.

### 3.2 신뢰성·순서·흐름/혼잡제어 부재

- **손실 가능**: 네트워크에서 패킷이 드롭되어도, UDP 계층에서는 자동 재전송을 하지 않는다.
- **중복 가능**: 동일 패킷이 여러 번 도착할 수 있다.
- **순서 꼬임 가능**: 경로에 따라 패킷이 재정렬되어 도착할 수 있다.
- **흐름제어 없음**: 송신자가 너무 빠르게 보내도 수신 버퍼를 넘기기 전에 막아 주지 않는다.
- **혼잡제어 없음**: 네트워크가 혼잡해도 자동으로 전송률을 줄여 주지 않는다.

결론적으로, **“신뢰성 있는 스트림”이 필요하면 TCP나 QUIC 같은 프로토콜을 쓰거나, UDP 위에 직접 ARQ/혼잡제어 계층을 올려야 한다.**

### 3.3 IP 단에서의 분할/재조립 의존

- 큰 UDP 페이로드는 IP 레이어에서 **프래그먼테이션**될 수 있다.
- 조각 중 하나라도 손실되면 전체 UDP 데이터그램을 잃게 된다.
- 인터넷 환경에서는 **대형 UDP + 프래그먼트 의존 설계는 강하게 비추천**이다.
  - 일부 방화벽/라우터는 프래그먼트 처리를 제대로 하지 않는다.
  - PMTUD(경로 MTU 탐지) 실패시, 큰 UDP 패킷이 계속 드롭될 수 있다.

### 3.4 NAT/방화벽과 UDP

- UDP는 이론상 상태가 없는 프로토콜이지만, 실제로 **NAT/방화벽은 상태를 유지**한다.
  - 소스 IP/포트, 목적지 IP/포트, 사용 시간 등을 기준으로 “세션”을 추적한다.
- 일반적으로 **UDP 세션 타임아웃이 TCP보다 훨씬 짧다**(수 초~수십 초 레벨).
  - 따라서 WebRTC나 실시간 스트리밍은 **주기적인 keepalive(예: STUN Binding Request)**로 매핑을 유지한다.
- UDP 홀 펀칭, TURN 릴레이 같은 NAT 우회 기술은 이 타임아웃·상태 관리 방식에 의존한다.

---

## 4. 실사용 예: DNS, RTP/RTCP, WebRTC, QUIC, 기타

### 4.1 DNS

- **기본 전송: UDP/53**
  - 일반적인 쿼리/응답은 수백 바이트 수준으로 UDP 하나로 충분하다.
- **EDNS(0)와 UDP 응답 크기**
  - DNSSEC, 많은 레코드를 포함한 응답으로 인해 UDP 응답이 커지고 있다.
  - 실제 운영에서는 **UDP 페이로드 1200~1232바이트** 정도로 제한하여 **프래그먼트 위험을 줄이고**, 그 이상은 TCP로 폴백하는 구성이 널리 쓰인다.
- **TC(Truncation) 비트**
  - UDP 응답이 너무 커서 잘려야 할 경우 **TC=1**로 응답하고, 클라이언트는 **TCP 재질의**를 수행한다.
- **보안/운영 포인트**
  - **오픈 리졸버**(누구나 질의 가능한 재귀 DNS)는 강한 악용 위험(증폭 DDoS).
  - **RRL(rate limiting)**, **쿼리 이름 최소화(QNAME minimization)**, DNSSEC 검증, 캐시 정책 등을 적절히 조합해야 한다.

#### 간단한 Python DNS UDP 쿼리 예제

```python
import socket

def simple_dns_query(server="8.8.8.8", qname="example.com"):
    # 매우 단순화된 A 레코드 질의 (실서비스에서는 dnspython 등 라이브러리 권장)
    tid = b'\x12\x34'           # Transaction ID
    flags = b'\x01\x00'         # 표준 쿼리
    qdcount = b'\x00\x01'       # 질문 1개
    ancount = b'\x00\x00'
    nscount = b'\x00\x00'
    arcount = b'\x00\x00'

    # 도메인 이름을 QNAME 형식으로 변환
    parts = qname.split(".")
    qname_bytes = b"".join(len(p).to_bytes(1,"big") + p.encode() for p in parts) + b"\x00"

    qtype = b'\x00\x01'         # A
    qclass = b'\x00\x01'        # IN

    msg = tid + flags + qdcount + ancount + nscount + arcount + qname_bytes + qtype + qclass

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(2.0)
    sock.sendto(msg, (server, 53))
    data, _ = sock.recvfrom(2048)
    print("Response length:", len(data))
    # 상세 파싱은 생략
    sock.close()

if __name__ == "__main__":
    simple_dns_query()
```

---

### 4.2 RTP/RTCP: 실시간 음성·영상

- **RTP (Real-time Transport Protocol)**  
  - **음성/영상 프레임**을 실시간으로 전송하는 프로토콜.
  - 헤더에 시퀀스 넘버, 타임스탬프, SSRC(동기화 소스) 등이 포함.
- **RTCP (RTP Control Protocol)**  
  - 주기적으로 통계를 보고: 패킷 손실률, 지터(jitter), RTT 등.
  - 송신 측은 이를 바탕으로 **비트레이트 조정(ABR)**, **코덱 전환**, **FEC/재전송 정책 조정**을 수행 가능.

#### 간단한 RTP 헤더 예시

```text
0               15 16              31 (bit)
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|V=2|P|X|  CC   |M|     PT          | seq number |
+-----------------------------------------------+
|                       timestamp               |
+-----------------------------------------------+
|               synchronization source (SSRC)   |
+-----------------------------------------------+
|            contributing source (CSRC) list    |
+-----------------------------------------------+
```

- V: 버전(2)
- PT: Payload Type (코덱 유형)
- seq number: 손실/재정렬 탐지에 사용
- timestamp: 재생 시점 계산·지터 추정에 사용

#### 지터(jitter) 추정식(표준 근사)

수신 측에서 패킷 간 상대 지연 변화를 이용해 지터를 추정할 때, 흔히 다음과 같은 1차 IIR 필터를 사용한다.

$$
J \leftarrow J + \frac{\left| D_i - D_{i-1} \right| - J}{16}
$$

- \(D_i\): i번째 패킷의 **상대 도착 간격**(보정된 시간 차이)
- J: 지터 추정값

---

### 4.3 WebRTC: 브라우저 실시간 P2P

- **SRTP(Secure RTP)** + **DTLS** 기반 암호화.
- **STUN/TURN/ICE**를 통한 NAT 트래버설:
  - host(사설) / srflx(공인) / relay(TURN) 후보를 수집.
  - ICE 연결성 체크를 거쳐 **최적 경로를 선택**.
- **콘텐츠 적응**:
  - 네트워크 품질에 따라 **비트레이트, 해상도, 프레임레이트, FEC/NACK 전략**을 실시간 조절.
- **UDP 위에서 동작**하면서도, 상위 계층에서 신뢰·보안을 구현해 TCP 기반 프로토콜과 경쟁한다.

---

### 4.4 QUIC/HTTP3

- UDP 기반 **사용자 공간 전송 프로토콜**.
- 특징:
  - **TLS 1.3 암호화**가 전송 계층에 통합 → 모든 패킷 암호화.
  - **스트림 멀티플렉싱**: 하나의 연결에서 여러 스트림을 동시에 전송, TCP의 **헤드오브라인 블로킹 완화**.
  - **0-RTT / 1-RTT 핸드셰이크**: 재연결 시 매우 빠른 세션 수립.
  - 자체적인 **혼잡제어(CUBIC, BBR 등)**와 손실 복구 메커니즘을 구현.
- 운영 관점:
  - UDP 기반이라 방화벽/미들박스 정책에 민감하다.
  - 하지만 웹 트래픽이 QUIC로 빠르게 이동하면서, 대형 사업자 인프라에서는 QUIC 최적화가 중요해지고 있다.

---

### 4.5 기타 프로토콜

- **NTP(Network Time Protocol)**: UDP/123, 시간 동기화.
- **DHCP**: 클라이언트-서버 간 IP 할당/갱신.
- **SNMP, Syslog(UDP 514)**: 네트워크 관리/로그.
- **TFTP**: 단순 파일 전송.
- **게임·IoT 텔레메트리**:
  - 위치/상태 업데이트 패턴에 적합(일부 손실 허용, 최신 정보가 더 중요).

---

## 5. 손실·지연·지터 환경 설계 포인트

UDP를 쓰는 순간, **“손실·지연·변동”을 어떻게 처리할지**는 전적으로 **애플리케이션 설계의 문제**가 된다.

### 5.1 MTU와 프래그먼트 회피

#### 5.1.1 원칙: 프래그먼테이션 피하기

- 인터넷에서 안전한 UDP 패킷 크기는 대략:

  - **IPv6 기준 1200바이트 주변** 페이로드를 많이 사용한다.  
  - 이는 **경로 MTU가 충분히 큰 대부분의 환경에서 프래그먼트 없이 전달될 수 있는 보수적인 값**이다.

- 오버레이 터널링(VXLAN, GRE 등)을 사용한다면, 외부 헤더를 고려해 이 값보다 더 줄여야 한다.

#### 5.1.2 패킷 크기 설계 예시

- RTP/Opus 음성: 패킷당 20ms, 1ch, 24kbps라면 페이로드는 수십 바이트 수준 → MTU 걱정 거의 없음.
- RTP/영상: 1080p/30fps H.264 스트림이라면, NAL 단위로 나누되 각 RTP 패킷이 대략 1200바이트를 넘지 않도록 설계.
- DNS/EDNS: EDNS0에서 **UDP 버퍼 크기를 ~1200~1232** 정도로 설정하고, 초과 시 TCP 폴백.

---

### 5.2 전송 속도·페이싱·혼잡 친화성

#### 5.2.1 버스트 전송 금지, 페이싱

- 대량 데이터를 UDP로 보낼 때, `send()`를 매우 빠르게 연속 호출하면:
  - 스위치/라우터 큐에 **버스트**가 생기고,
  - 순간적인 혼잡과 대규모 드롭이 발생할 수 있다.
- 해결책:
  - **페이싱(pacing)**: 패킷 사이에 짧은 간격을 두고 균등하게 펼쳐 보내기.
  - 커널/라이브러리 수준에서의 타이머·타임스탬프 큐를 이용해 구현할 수 있다.

#### 5.2.2 혼잡 친화성: 손실/ECN에 반응

- TCP처럼 자동 혼잡제어는 없지만, UDP 기반 애플리케이션도 **네트워크를 과도하게 사용하지 않도록** 설계해야 한다.
- 손실률 \(p\), RTT \(\tau\), 지터 \(\sigma\)를 지속적으로 추정해:
  - 손실률이 특정 임계치를 넘으면 전송률 감소.
  - ECN 마킹이 관찰되면 전송률 감소.
  - RTT 급증 시 큐 빌드업 가설을 두고 비트레이트 조정.

---

### 5.3 손실 복구 전략: 재전송·FEC·하이브리드

#### 5.3.1 ARQ(재전송 기반) – NACK 중심

- 실시간 스트리밍에서는 **모든 패킷을 재전송하는 것은 비현실적**일 수 있다.
- 흔한 패턴:
  - 수신 측이 **중요 패킷(키프레임 등)** 손실 시에만 NACK을 보내 재전송 요청.
  - NACK를 여러 개 모아 보낼 수 있도록 일정 시간 누적.

재전송의 효과는 **왕복 지연보다 짧은 재생 기한**을 가질 때만 의미 있다:

- 재생 기한을 \(\tau_{\text{deadline}}\), RTT를 \(\tau_{\text{RTT}}\)라 하면
  - \(\tau_{\text{RTT}} > \tau_{\text{deadline}}\)일 때 재전송 패킷은 도착하더라도 이미 재생 시점을 놓친다.
- 따라서 대화형 VoIP에서는 재전송을 거의 안 쓰고, **에러 은닉(PLC)** 위주로 처리하는 경우가 많다.

#### 5.3.2 FEC(Forward Error Correction)

- \(k\)개의 원본 패킷마다 \(r\)개의 보호 패킷을 추가로 송신.
- 충분히 랜덤하게 분산된 손실이라 가정하면, 대략 다음 손실률까지 복원 가능:

$$
\text{복원 가능 손실률} \approx \frac{r}{k + r}
$$

- 예: \(k=10, r=2\) → 약 16% 이내 손실에서 대부분의 묶음을 복구할 수 있음.
- 장단점:
  - 장점: 재전송 없이도 일부 손실을 복구해 **지연 증가 없이 품질 개선**.
  - 단점: 대역폭 오버헤드 \(\frac{r}{k}\)가 증가, CPU 비용(인코딩/디코딩) 추가.

#### 5.3.3 하이브리드(H-ARQ)

- **얕은 FEC + 제한적 재전송** 조합:
  - FEC로 대부분의 단일/소량 손실을 잡고,
  - 여전히 남는 중요한 손실에 대해 NACK 기반 재전송.
- 실시간 회의/스트리밍에서 많이 쓰이는 절충안.

---

### 5.4 지터 버퍼와 재생 지연

#### 5.4.1 지터 버퍼 개념

- 패킷 도착 간격이 일정하지 않기 때문에, 수신 측은 **재생 전에 약간의 버퍼를 쌓아 지터를 흡수**한다.
- 초기 재생 지연(예: 60ms, 150ms)을 두고, 이후 지터 상황에 따라 버퍼 길이를 동적으로 조절할 수 있다.

#### 5.4.2 재생 버퍼 지연 근사

재생 파이프라인 지연은 대략:

$$
\text{Startup Latency} \approx \text{초기 버퍼 깊이} + \text{디코더 파이프라인 지연}
$$

- 라이브 방송(TV, 스포츠 등):
  - 수 초 이상 버퍼링을 허용하여 안정적인 재생을 목표.
- 대화형 음성/영상 회의:
  - **총 지연 150~300ms** 수준을 목표로, 지터 버퍼는 30~150ms 사이에서 동적 조절.
  - 지연이 조금 늘어도 품질이 나은 쪽 vs 지연을 줄여 상호작용성을 조금 더 확보하는 쪽을 서비스 성격에 맞게 선택.

---

### 5.5 순서/중복/경로

- **시퀀스 번호**:
  - 각 패킷에 시퀀스 번호를 부여해 **재정렬 버퍼**에서 순서를 맞춘다.
  - 재정렬 버퍼 크기를 수십 패킷 정도로 유지(환경에 따라 조절).
- **중복 전송(dupe)**:
  - 중요한 패킷(키프레임, 제어 메시지)은 **두 번 송신**해 손실 확률을 제곱 수준으로 낮춘다.
  - 수신 측은 최근 몇 개 seq를 캐시하여 중복을 제거한다.
- **다중 경로**:
  - Wi-Fi + LTE와 같이 다중 인터페이스를 가진 단말에서, 중요 패킷을 두 경로 모두로 보내거나, 경로별로 트래픽을 분산할 수 있다.
  - 상위 프로토콜(QUIC, WebRTC 등)이 이를 추상화해 제공하기도 한다.

---

### 5.6 시간 동기화와 타임스탬프

- 실시간 미디어에서는 **음성/영상 동기**와 **서버-클라이언트 간 클록 드리프트 보정**이 중요하다.
- 방법:
  - **NTP/PTP**로 시스템 클록을 동기화.
  - RTP 타임스탬프 + RTCP Sender Report를 통해 **송신 시각과 수신 시각의 관계**를 지속적으로 추정.
  - 플레이어는 이를 바탕으로 재생 스케줄을 조정하고, 클록 드리프트를 보정한다.

---

### 5.7 보안·증폭·오용 방지

- **DTLS/SRTP**:
  - UDP 기반 통신을 TLS와 유사한 보안 수준으로 보호.
  - 도청/위조/재전송 공격을 방지.
- **증폭 공격 방지**:
  - “작은 요청 → 큰 응답” 패턴은 증폭 DDoS의 전형적 형태이다.
  - 설계 시:
    - 주소 검증 전에는 응답 크기를 작게 제한.
    - 쿠키/토큰을 통해 **요청자가 실제 그 주소를 소유한지 확인한 후**에 큰 응답을 허용.
    - Rate limiting, RRL, 응답 축약 등을 함께 사용.
- **포트 스캔/반사 공격**:
  - 잘 알려진 포트에 대한 공격을 고려해, 레이트 리밋·로그·알림 체계를 갖추고, 필요하다면 접근 제어 목록(ACL)을 적용한다.

---

## 6. 예제 시나리오 정리

### 6.1 DNS: UDP → TCP 폴백 & EDNS 크기

```text
1) 클라이언트 → 재귀 리졸버: example.com A? (UDP, EDNS bufsize=1232)
2) 권한 서버 응답 크기 > 1232 → TC=1 설정 후 잘린 응답 전송
3) 클라이언트: 동일 질의를 TCP로 재전송 → 완전 응답 수신
운영: EDNS bufsize를 1200~1232 바이트 수준으로 보수적으로 설정해
      프래그먼트 위험을 줄이고, 필요 시 TCP 폴백으로 보완
```

### 6.2 RTP/RTCP: 지터·손실 대응

```text
- 송신:
  · 20ms 프레임(VoIP), 코덱: Opus
  · 패킷당 약 20ms 오디오 데이터 전송 (RTP seq/timestamp 포함)

- 수신:
  · 지터 버퍼 60ms에서 시작, 네트워크 상황에 따라 40~120ms 범위에서 자동 조절
  · 손실 ~2% 수준:
      - 짧은 손실: PLC(이전 샘플 보간·노이즈 삽입)로 은닉
      - 연속 손실: 낮은 오버헤드의 FEC(예: 1/10) 적용

- RTCP:
  · 5초 간격 리포트: 누적 손실률, 지터, RTT 보고
  · 송신자는 이를 바탕으로:
      - 비트레이트/코덱 모드 조정 (예: 32kbps → 24kbps)
      - FEC 비율 상향/하향
      - 재생 버퍼 기본값 조정
```

### 6.3 WebRTC: ICE/NAT 우회

```text
- ICE 후보 수집:
  · host(사설 IP), srflx(STUN으로 얻은 공인 IP), relay(TURN 서버)
- 연결성 체크:
  · 각 후보 쌍에 대해 STUN Binding Request 발송
  · 응답이 빨리 오고 안정적인 경로를 "최우선"으로 선택
- 대칭 NAT/CGNAT에서 직결 실패:
  · TURN 릴레이를 통해 서버-릴레이-피어 경로로 우회
- Keepalive:
  · 15~30초 간격으로 STUN Binding keepalive → NAT 매핑 유지
```

### 6.4 게임: 상태 업데이트 & 보정

```text
- 서버 틱: 60Hz
- UDP 업데이트: 20~30Hz (필요 이상 높은 레이트는 네트워크·CPU 낭비)
- 각 업데이트에는:
  · 플레이어 위치/속도
  · 입력 시퀀스 번호
  · 서버 시퀀스 번호 포함

- 클라이언트:
  · 입력을 즉시 로컬에 반영(프레딕션)
  · 서버 스냅샷 도착 시, 과거 입력 기록을 재적용해 리콘실리에이션
- 손실:
  · 동일 스냅샷을 2회 얕게 중복 송신
  · 클라이언트는 최근 seq 캐시로 중복 제거
- 지연:
  · 보정 윈도우 100ms 정도에서 위치 보간/보정
  · 중요 이벤트(총알 명중, 스킬 발동 등)는 별도 채널에서
    더 강한 신뢰성과 확인(ACK)를 사용하기도 함
```

---

## 7. 운영·진단 체크리스트

### 7.1 송신 측 체크

```text
[패킷 크기]
- 패킷당 UDP 페이로드를 1000~1200B 부근으로 설계했는가?
- 오버레이/터널 헤더를 고려해 실제 MTU를 초과하지 않는지?

[페이싱]
- 최대 비트레이트에서 send() 호출 간격이 충분히 분산되는가?
- 타이머/큐를 이용한 소프트웨어 페이싱 또는 커널 레벨 페이싱을 사용하는가?

[레이트 제어]
- 손실률·RTT·지터를 관측해 비트레이트를 조정하는 로직이 있는가?
- 실시간 서비스에서 최대 허용 지연/손실을 정책으로 명시했는가?

[FEC/재전송]
- FEC 비율(k,r)과 재전송 마감기한을 명시적으로 설정했는가?
- 서비스별 프로파일(대화용/방송용/게임용)을 분리했는가?

[QoS]
- DSCP 마킹 정책을 정의했는가?
- 도메인 경계에서 재마킹되는 것을 고려했는가?
```

### 7.2 경로/네트워크 체크

```text
[NAT/방화벽]
- UDP 타임아웃은 어느 정도인가?(예: 30~60초)
- 애플리케이션의 keepalive 주기와 일치하는가?
- 대칭 NAT/CGNAT 비율은 얼마나 되는가? (TURN 용량 계획에 반영)

[MTU/PMTUD]
- ICMP "Fragmentation Needed"/"Packet Too Big" 메시지가 제대로 전달되는가?
- 특정 경로에서 큰 UDP 패킷이 지속적으로 손실되는지 모니터링하는가?

[Wi-Fi/무선 환경]
- 무선 링크 레벨 재전송/레이트 제어로 인한 지연·지터를 고려했는가?
- AP/기지국 QoS 설정과 DSCP 매핑은 일관적인가?

[혼잡·큐 관리]
- AQM(RED, CoDel 등) 혹은 fq계열 큐디스크를 사용해 긴 큐를 예방하는가?
- ECN 마킹 정책을 사용한다면, 상위 애플리케이션이 반응하도록 설계했는가?
```

### 7.3 수신 측 체크

```text
[지터 버퍼]
- 초기 버퍼 깊이, 최소/최대 버퍼 길이를 서비스별로 설정했는가?
- 지터·손실 상황에 따라 버퍼를 동적으로 조정하는가?

[재정렬 버퍼]
- 시퀀스 번호 기반 재정렬 윈도우 크기는 얼마인가?
- 짧은 재정렬 지연과 손실 판정 사이에 균형을 맞췄는가?

[NACK/FEC 로직]
- NACK 윈도우·최대 빈도·재전송 마감기한을 명시했는가?
- FEC 사용 시, 실제 손실 패턴과 부합하도록 k, r을 튜닝했는가?

[텔레메트리]
- loss/RTT/jitter(P50/P95/P99), playout buffer level, FEC hit rate, NACK hit rate 등을 기록하는가?
- QoE(예: MOS, 프레임 드랍률)와 네트워크 지표를 함께 분석하는가?
```

---

## 8. 수식·감각 메모

### 8.1 유효 처리량(Goodput) 근사

UDP 기반 실시간 전송에서, 실제 유효 페이로드 비율은 대략 다음과 같이 볼 수 있다.

$$
\text{Goodput} \approx
\frac{\text{Payload}}{\text{Payload} + \text{L2/3/4 Overheads}}
\times \text{Rate}
$$

- 이더넷:
  - L2: 14B 헤더 + 4B FCS (+ 8B preamble/SFD와 간격까지 보면 더 큼)
- IPv4: 20B, IPv6: 40B
- UDP: 8B
- RTP: 12B

예를 들어 IPv4 + UDP + RTP + 이더넷을 가정하면, 페이로드 1000바이트에 오버헤드가 대략 60바이트 이상이므로 **오버헤드 비율은 5% 이상**이 될 수 있다.

### 8.2 손실·FEC 트레이드오프

FEC를 사용할 때:

$$
\text{Overhead} = \frac{r}{k}
$$

- 손실률이 낮으면 r을 줄여 오버헤드를 줄이고,
- 손실률이 높으면 r을 늘려 복원율을 높이되 지연과 오버헤드 증가를 감수해야 한다.

### 8.3 지연·버퍼 관점 정리

- 총 지연은 대략:
  - **인코딩 지연 + 네트워크 지연(왕복 또는 단방향) + 디코딩 지연 + 재생 버퍼 지연**.
- UDP를 쓰더라도, 너무 공격적으로 버퍼를 줄이면 지터와 손실로 인한 품질이 크게 나빠질 수 있다.
- 대화형 서비스는 **지연과 품질 사이의 타협점**을 잡는 것이 핵심이다.

---

## 9. 미니 랩: netem, NAT, FEC 튜닝

### 9.1 `tc netem`으로 손실/지연 재현

```bash
# 50ms 평균 지연, 5ms 지터, 2% 손실, 0.1% 듀플리케이트

sudo tc qdisc add dev eth0 root netem delay 50ms 5ms loss 2% duplicate 0.1%

# 테스트 종료 후 복원

sudo tc qdisc del dev eth0 root
```

- 실험 시:
  - RTCP 통계 또는 애플리케이션 로그에서 **손실률, 지터, RTT** 변화를 관찰.
  - 재생 버퍼 수준, 프레임 드랍률, 음성 끊김 등 QoE를 함께 기록.

### 9.2 MTU 안전 크기 검증 아이디어

```text
1) 특정 페이로드 크기에서 UDP 패킷을 주기적으로 전송
2) 수신 측에서 손실률과 ICMP "Packet Too Big"/"Frag Needed"를 기록
3) 크기를 변화시키면서 손실이 급증하는 구간을 확인
4) 해당 값보다 여유 있게 작은 크기를 안전 페이로드로 선택
```

### 9.3 FEC 비율 스윕

```text
환경: 평균 손실 5~15% 네트워크 (netem으로 재현)

1) (k=10, r=1)
2) (k=10, r=2)
3) (k=10, r=3)

각각에 대해:
- 복원 후 유효 손실률
- 오버헤드(k+r 대비 k)
- 재생 지연 변화
- 주관적 품질(MOS) 평가

결과를 기반으로 실제 서비스 목표 손실률(예: <8%)에서 적절한 r 선택
```

### 9.4 NAT Keepalive 최적화

```text
가정: UDP NAT timeout ≈ 30초

1) keepalive = 5초
   - NAT 매핑은 잘 유지되지만, 배터리/트래픽 낭비가 크다.

2) keepalive = 15초
   - NAT 매핑 안정 유지, 불필요한 트래픽은 상대적으로 적음.

3) keepalive = 25초
   - 일부 NAT 장비에서 20~30초 사이에 타임아웃 → 매핑 소실 사례 발생.

실험을 통해:
- 다양한 CPE/게이트웨이에서의 실제 timeout 통계를 수집하고,
- 가장 보수적인 값보다 충분히 작은 keepalive 주기 선택
```

---

## 10. 보안·건전성 설계 체크리스트

```text
[암호화/인증]
- DTLS 또는 SRTP 적용 여부
- 키 교환·재키(키 롤링) 주기와 구현 상태

[증폭/반사 공격]
- 작은 요청으로 큰 응답을 생성하는 API를 제한했는가?
- 주소 검증(쿠키/토큰 등) 없이 큰 응답을 보내지 않는가?
- UDP 기반 서비스에 대해 레이트 리밋/RRL을 적용했는가?

[서비스 노출 범위]
- DNS/기타 UDP 서비스가 공용 인터넷에 열려 있는지?
- 관리자용 포트는 ACL 또는 VPN으로 보호되는지?

[DDoS 대응]
- Anycast 인프라 또는 에지 분산 구성 여부
- 관측 지표:
  · 초당 요청 수, 드롭률, CPU/메모리 사용량
  · 공격 패턴(특정 qname/qtype, 특정 포트 등)
- 비상시 대응 프로시저:
  · Rate limit 강화, 블럭 리스트 업데이트, 특정 기능 임시 비활성화
```

---

## 11. 종합 체크리스트(요약 카드)

- **헤더/체크섬**
  - UDP 헤더는 8바이트, IPv6에서는 체크섬 필수.
  - 의사 헤더를 포함해 1의 보수 합으로 계산.

- **MTU**
  - IP 프래그먼트 의존 설계는 피한다.
  - 인터넷 대상 서비스라면 UDP 페이로드를 대략 **1200B 근처**로 설계.

- **혼잡 친화성**
  - 페이싱으로 버스트를 줄이고, 손실/ECN/RTT 변화에 반응해 전송률 조정.
  - 장기적으로는 QUIC 등 검증된 전송 계층 활용을 고려.

- **복구 전략**
  - 실시간 서비스: **얕은 FEC + 제한적 재전송(NACK)**, PLC·인터리빙으로 품질 보완.
  - 비실시간/저지연 중요도가 낮은 서비스: 더 강한 FEC·재전송 허용.

- **버퍼·지연**
  - 지터 버퍼를 통해 도착 변동을 흡수하되, 서비스 특성에 맞는 지연 상한을 정책으로 정의.
  - 대화 vs 방송 vs 게임용 프로파일을 분리.

- **NAT/방화벽**
  - UDP 세션 타임아웃, NAT 타입(대칭/포트 보존 등)을 파악하고,
    이에 맞는 keepalive·ICE/TURN 전략을 세운다.

- **보안**
  - DTLS/SRTP/QUIC 등으로 암호화·무결성·인증을 확보.
  - 증폭/반사 공격을 막기 위한 응답 정책·레이트 리밋·로그 분석 체계 구축.

- **측정·운영**
  - 손실/RTT/jitter(P50/P95/P99), playout buffer level, FEC/NACK 효율,
    QoE 지표를 계속 수집해 설계 가정을 검증하고 개선.

---

## 12. 한 장 요약(포스터)

- **UDP**는 **단순·경량**이지만, 그만큼 **신뢰·혼잡·순서·보안** 책임이 **애플리케이션에게 있다.**
- **DNS·RTP/RTCP·WebRTC·QUIC·게임** 등에서 널리 사용되며,
  **실시간·저지연**이 중요한 분야에서 핵심 역할을 한다.
- **설계 키워드**:
  - 작은 패킷, 프래그먼트 회피
  - 페이싱과 혼잡 친화적 레이트 제어
  - FEC + NACK 절충
  - 지터 버퍼와 재생 지연 관리
  - NAT 우회(ICE/TURN)와 keepalive
  - DTLS/SRTP, 증폭 방지, 레이트 리밋
- 결국, **“낮은 지연 vs 높은 복원력”**의 트레이드오프를
  서비스 특성(대화/방송/게임/텔레메트리)에 맞게 정교하게 조절하는 것이 UDP 설계의 핵심이다.

---

### 부록 A — UDP 기반 스택 한눈 그림

```text
[Application]
   ├─ 코덱/ABR/ARQ/FEC/암호화/멀티플렉스
   ↓
[UDP]
   ↓
[IP (ECN/DSCP/PMTUD)]
   ↓
[L2 (Ethernet/Wi-Fi/...)]
```

- 필요 시:
  - RTCP, STUN/TURN/ICE 같은 제어 채널을 측면에 배치.
  - 예:
    · 미디어: RTP(SRTP)
    · 제어: RTCP, STUN, DTLS handshake

---

### 부록 B — 텔레메트리 필드 제안

```text
ts, flow_id(ssrc), seq, marker, size,
send_ts, recv_ts, oneway_ms, rtt_ms, jitter_ms,
loss_run_len, fec_used, fec_recovered,
nack_req, nack_hit,
abr_bitrate_kbps,
playout_buf_ms,
dscp, ecn_ce
```

- 이 정도 정보만 있어도:
  - 손실 패턴(연속 손실 vs 고르게 분산)
  - FEC/NACK의 실제 효과
  - 지연·지터·버퍼 상호 관계
  - QoS 정책(DSCP/ECN)의 효과  
  를 정밀하게 분석할 수 있다.

---

### 부록 C — 운영 템플릿

```text
[환경]
- 액세스: Wi-Fi / 셀룰러 / 유선
- NAT: 타입, 타임아웃, CGNAT 여부
- MTU: 추정 값, AQM/ECN 정책

[목표]
- 종단 지연 상한
- 허용 손실률, 안정적인 품질 구간
- 스타트업 지연(초기 버퍼링)
- 평균/최대 비트레이트

[설계]
- 패킷 크기, 페이싱 전략
- FEC (k,r) 및 재전송 마감기한
- 지터/재정렬 버퍼 범위
- QoS(DSCP) 및 ECN 사용 여부

[보안]
- DTLS/SRTP/QUIC 적용 여부
- 증폭·반사 공격 한도(anti-amplification) 정책
- Rate limiting/RRL 설정

[관측]
- loss/RTT/jitter (P50/P95/P99)
- nack/fec 통계, 버퍼 언더런
- QoE: MOS, 프레임 드랍률, 사용자 불만 신고

[실험]
- netem 시나리오별 A/B 테스트
- 경로/시간대별 성능 차이 분석
- 릴리스 게이팅 기준(허용 손실·지연·QoE)
```