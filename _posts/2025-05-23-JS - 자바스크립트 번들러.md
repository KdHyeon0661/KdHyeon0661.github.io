---
layout: post
title: JavaScript - 자바스크립트 번들러
date: 2025-05-23 20:20:23 +0900
category: JavaScript
---
# Webpack / Vite 등 자바스크립트 번들러

## 0. 번들러가 해결하는 문제들 — “왜 쓰는가?”

- **모듈 결합**: ESM/CommonJS/TS/SASS/이미지 등 **이질 리소스**를 하나의 **모듈 그래프**로 수집
- **호환성 확보**: Babel/SWC/TypeScript/targets로 **구형 브라우저** 지원
- **성능 최적화**: **코드 스플리팅**, **트리 셰이킹**, **압축**, **중복 제거**, **이미지 최적화**
- **개발 편의**: **개발 서버**, **HMR(Hot Module Replacement)**, **소스맵**, 빠른 피드백
- **배포 안정성**: **콘텐츠 해시**, **캐시 용이성**, **환경 변수 주입**, **CI/CD와의 결합**

> 핵심은 “**여러 리소스를 일관된 파이프라인으로 통합**하고, **사용자에게 빠르게(성능)**, **개발자에겐 빠른 반복(개발 경험)**을 주는 것”.

---

## 1. 모듈 그래프와 트리 셰이킹 개념

### 1.1 모듈 그래프
엔트리에서 `import`를 따라가며 **의존성 그래프**를 구축합니다.

```js
// src/main.js
import { sum } from './math.js';
import './styles.css';
import avatar from './assets/user.png';

console.log(sum(2, 3));
document.querySelector('#app').innerHTML = `<img src="${avatar}">`;
```

### 1.2 트리 셰이킹(Tree Shaking)
**정적 분석**으로 사용되지 않는 export를 제거합니다(ESM에서 최적).

```js
// src/math.js
export const sum = (a, b) => a + b;
export const heavy = () => { /* 미사용, 제거 대상 */ };
```

번들링 후 `heavy`가 참조되지 않으면 제거됩니다(빌드 설정/모드/sideEffects 플래그에 영향).

---

## 2. 코드 스플리팅과 지연 로드(라우팅·피드·관리자 페이지 분할)

**코드 스플리팅**은 초기 번들 크기를 줄이고, 특정 경로/행위에서 **필요한 모듈만 지연 로드**합니다.

```js
// src/routes/admin.js - 동적 import
export async function mountAdmin() {
  const { default: AdminPage } = await import('./pages/AdminPage.js');
  new AdminPage().render();
}
```

라우터 또는 이벤트 기반으로 `mountAdmin()`을 호출하면, 해당 청크가 **그 시점**에만 네트워크로 로드됩니다.

> **경험칙**: “초기(LCP)에 꼭 필요한 코드만 메인 번들로, 나머지는 **route-level** 또는 **component-level** chunk로 분할”.

---

## 3. 소스맵(Source Map)과 디버깅

빌드 시 소스가 변형되므로 **원본 위치**를 알기 위해 소스맵이 필요합니다.

- 개발: `cheap-module-source-map`(Webpack), `server.sourcemap: true`(Vite) 등 빠른 옵션
- 제품: `hidden-source-map`(오류 수집용), `nosources-source-map`(코드 노출 최소화)

```js
// 예: Vite
export default {
  build: { sourcemap: true }
};
```

---

## 4. 해시·캐시 전략 — 롱 캐시(immutable)와 캐시 무효화

**콘텐츠 해시 파일명**을 사용하면 브라우저가 파일을 오래 캐시합니다. 파일 내용이 바뀌면 해시가 변해 자동 무효화됩니다.

- 파일명: `app.[contenthash].js` (Webpack), `assets/[name].[hash].js` (Vite)
- HTTP 캐시 헤더: `cache-control: public, max-age=31536000, immutable`

**정량 모델(개념)**:
다운로드 비용을 **\(B\)**, 캐시 히트율을 **\(h\)**라 할 때, 평균 전송 비용 **\(C\)**는:

$$
C = (1 - h) \cdot B
$$

**h**를 올리는 핵심은 **해시 기반 캐시**와 **자주 변하는 런타임 데이터는 API로 분리**하는 것.

---

## 5. 환경 변수와 주입

### 5.1 Vite
- `.env`, `.env.production` 등에서 `VITE_` 접두사만 클라이언트에 주입

```bash
# .env
VITE_API_URL=https://api.example.com
```

```js
// src/config.js
export const API_URL = import.meta.env.VITE_API_URL;
```

### 5.2 Webpack
- `DefinePlugin`으로 문자열 치환

```js
// webpack.config.js
const webpack = require('webpack');
module.exports = {
  plugins: [
    new webpack.DefinePlugin({
      __API_URL__: JSON.stringify(process.env.API_URL || 'http://localhost:3000')
    })
  ]
};
```

```js
// src/config.js
export const API_URL = __API_URL__;
```

---

## 6. CSS 파이프라인 — CSS/SCSS/PostCSS, 모듈, 추출

### 6.1 Webpack 예시
```js
// webpack.config.js
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
  module: {
    rules: [
      { test: /\.css$/i, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'] },
      { test: /\.s[ac]ss$/i, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'] },
    ]
  },
  plugins: [ new MiniCssExtractPlugin({ filename: 'styles.[contenthash].css' }) ]
};
```

### 6.2 Vite 예시
- 기본적으로 CSS/SCSS/PostCSS를 **자동 파이프라인**으로 처리
- CSS 모듈: `import styles from './Button.module.css'`

```css
/* Button.module.css */
.root { padding: .5rem 1rem; border-radius: 8px; }
```

```js
import styles from './Button.module.css';
button.className = styles.root;
```

---

## 7. 에셋(이미지/폰트/SVG) 처리

### 7.1 Vite
- `import logo from './logo.svg'` → 자동 번들/URL 처리
- SVG를 컴포넌트로 사용(React)은 `vite-plugin-svgr` 활용

```js
// vite.config.js
import svgr from 'vite-plugin-svgr';
export default { plugins: [svgr()] };
```

```jsx
// React
import { ReactComponent as Logo } from './logo.svg?react';
export default () => <Logo width={120} />;
```

### 7.2 Webpack
- `asset/resource`, `asset/inline`, `asset`(자동 판단) 규칙 사용

```js
// webpack.config.js
module.exports = {
  module: {
    rules: [
      { test: /\.(png|jpe?g|gif|svg)$/i, type: 'asset', parser: { dataUrlCondition: { maxSize: 8 * 1024 }}},
      { test: /\.(woff2?|ttf|otf)$/i, type: 'asset/resource' }
    ]
  }
};
```

---

## 8. 개발 서버 & HMR(Hot Module Replacement)

- **Vite**: Native ESM 기반 **초고속** 서버, 모듈 단위 HMR
- **Webpack Dev Server**: 번들 메모리 보관 + HMR 플러그인

```js
// Webpack
module.exports = {
  devServer: { static: './dist', hot: true, port: 3000 }
};
```

**HMR 시 주의**: 전역 상태/싱글톤 스토어가 중복 생성되지 않도록 모듈 경계 관리 필요.

---

## 9. 압축·최적화(Terser/ESBuild/SWC, 이미지 최적화)

- **JS 압축**: Webpack은 `TerserPlugin`(기본 포함), Vite는 **esbuild 기반** 미니파이(매우 빠름)
- **CSS 압축**: cssnano 또는 빌드 내장 옵션
- **이미지**: `imagemin`, `sharp` 기반 사전 최적화 파이프라인 권장(빌드 시간/CI 단계에서)

```js
// Webpack terser example (커스텀)
const TerserPlugin = require('terser-webpack-plugin');
module.exports = {
  optimization: { minimize: true, minimizer: [new TerserPlugin({ extractComments: false })] }
};
```

---

## 10. 코드 예제 — Webpack 최소 구성 → 확장

### 10.1 최소 구성
```js
// webpack.config.js
const path = require('path');

module.exports = {
  mode: 'production',                // development/production
  entry: './src/main.js',            // 진입점
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'app.[contenthash].js',
    clean: true,                     // dist 정리
  },
  module: {
    rules: [
      { test: /\.js$/, exclude: /node_modules/, use: 'babel-loader' },
      { test: /\.css$/, use: ['style-loader', 'css-loader'] },
      { test: /\.(png|svg|jpg|gif)$/i, type: 'asset' }
    ]
  },
  devtool: 'source-map',             // 소스맵
};
```

```json
// .browserslist
> 0.5%
last 2 versions
not dead
```

### 10.2 개발 서버 + HTML 템플릿 + CSS 추출
```js
// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCss = require('mini-css-extract-plugin');

module.exports = {
  mode: 'development',
  entry: './src/main.js',
  output: { path: path.resolve(__dirname, 'dist'), filename: 'app.[fullhash].js', clean: true },
  devtool: 'cheap-module-source-map',
  devServer: { static: './dist', port: 3000, hot: true, open: true },
  module: {
    rules: [
      { test: /\.js$/, exclude: /node_modules/, use: { loader: 'babel-loader' } },
      { test: /\.css$/, use: [MiniCss.loader, 'css-loader', 'postcss-loader'] },
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({ template: './public/index.html' }),
    new MiniCss({ filename: 'styles.[contenthash].css' }),
  ],
  optimization: { runtimeChunk: 'single', splitChunks: { chunks: 'all' } } // 코드 스플리팅
};
```

---

## 11. 코드 예제 — Vite 최소 구성 → 확장

### 11.1 최소 구성
```bash
npm create vite@latest my-app -- --template vanilla
cd my-app
npm i
npm run dev
```

```js
// vite.config.js
import { defineConfig } from 'vite';

export default defineConfig({
  server: { port: 3000, open: true },
  build: {
    outDir: 'dist',
    sourcemap: true,
    rollupOptions: {
      output: { manualChunks: { vendor: ['lodash'] } }, // 예: 수동 청크 제어
    }
  }
});
```

### 11.2 React + SVGR + 환경변수
```bash
npm create vite@latest my-react-app -- --template react
cd my-react-app
npm i
```

```js
// vite.config.js
import { defineConfig } from 'vite';
import svgr from 'vite-plugin-svgr';

export default defineConfig({
  plugins: [svgr()],
  define: { __BUILD_TIME__: JSON.stringify(new Date().toISOString()) }
});
```

```jsx
// src/App.jsx
import { ReactComponent as Logo } from './logo.svg?react';
export default function App() {
  return (
    <div>
      <Logo width={120}/>
      <p>API: {import.meta.env.VITE_API_URL}</p>
      <p>Build: {__BUILD_TIME__}</p>
    </div>
  );
}
```

---

## 12. 테스트 환경과 번들러 — Vitest/Jest/Playwright 연계

- **Vite**: Vitest가 **esbuild** 트랜스파일로 빠른 유닛 테스트 제공
- **Webpack**: Jest + Babel 설정으로 유닛 테스트
- **E2E**: Playwright/Cypress로 빌드 산출물 검증

```js
// vitest.config.ts
import { defineConfig } from 'vitest/config';
export default defineConfig({
  test: { environment: 'jsdom' }
});
```

---

## 13. 대규모 프로젝트 구조화 — 모듈 경계·러닝 커브 관리

- **폴더링**: `src/pages`, `src/widgets`, `src/entities`, `src/shared` 등 계층화
- **러닝 커브**: Webpack은 **학습비용↑, 유연성↑** / Vite는 **학습비용↓, DX↑**
- **모노레포**: pnpm workspace + Vite/TS/ESBuild로 **패키지 대수 확장**

---

## 14. 번들러 선택 가이드(실전)

| 목적/상황 | 권장 선택 | 이유 |
|---|---|---|
| 빠른 프로토타입·SPA | **Vite** | 개발 서버 압도적 속도/간결함 |
| 라이브러리 번들 | **Rollup** or Vite(lib) | Tree-shaking/출력 포맷(esm/cjs/umd) 용이 |
| 레거시·엔터프라이즈 커스터마이징 | **Webpack** | 방대한 플러그인/로더, 미세 제어 |
| 초고속 빌드 파이프라인 | **esbuild** | TS/JS 변환 속도 최강, 보조 번들러로 |
| “설정 거의 없이 시작” | **Parcel** | 제로컨피그, 자동화 강점(복잡화 시 제약 존재) |

> 최근엔 **Vite(개발) + Rollup(배포)** 조합, 또는 **Vite 단독**이 실무 기본값으로 자리잡는 추세.

---

## 15. 성능 체크리스트(배포 전)

- [ ] **코드 스플리팅**: 라우트/기능 단위 청크 분리
- [ ] **트리 셰이킹**: ESM 사용, `sideEffects` 검토, dead-code 제거
- [ ] **이미지 최적화**: WebP/AVIF 변환, responsive sizes
- [ ] **압축**: gzip/br 압축(서버/CI에서 처리)
- [ ] **캐시**: 해시 파일명 + 강한 캐시 헤더
- [ ] **소스맵**: 운영용은 hidden/nosources 선택
- [ ] **환경변수**: 클라이언트 노출 위험 변수 분리
- [ ] **Lighthouse / Web Vitals**: LCP/CLS/FID 확인

---

## 16. 실전 미니 샘플 — “상품 목록” 페이지 성능 개선

### 문제 상황
- 초기 JS 1.5MB (벤더+앱 통합)
- 이미지 원본(>500KB) 다수
- 느린 3G에서 LCP>4s

### 개선 단계
1) **동적 import**로 관리자/상세/통계 코드를 분할
2) 이미지 사전 최적화 + `<img srcset>` 활용
3) Vite `build.rollupOptions.output.manualChunks`로 vendor 분리
4) gzip/브로틀리 압축 + CDN 캐시

```js
// src/pages/Home.js
document.getElementById('admin-link').addEventListener('click', async () => {
  const { mountAdmin } = await import('../routes/admin.js');
  mountAdmin();
});
```

**성과**
- 초기 번들 400KB로 축소, 이미지 평균 80KB
- LCP 2.1s (느린 3G), 재방문 캐시 히트율↑

---

## 17. 흔한 오류와 디버깅 포인트

- **HMR이 갱신 안 됨**: 모듈 사이드 이펙트(전역 상태), 핫 경계 설정 확인
- **Tree Shaking 안 됨**: CJS 의존성, `sideEffects` 누락, dev 모드 빌드
- **CORS / 환경변수**: dev 서버 프록시 설정, `VITE_` 접두사/DefinePlugin 확인
- **소스맵 노출**: 운영에선 `hidden-source-map` 또는 비노출 정책

---

## 18. “한눈에 비교” — Webpack vs Vite 요약표(실전 관점)

| 항목 | Webpack | Vite |
|---|---|---|
| 개발 서버 속도 | 번들 생성 후 제공 → 상대적으로 느림 | ESM 기반 즉시 시작, HMR 매우 빠름 |
| 설정 난이도 | 유연하지만 복잡 | 기본값 우수, 필요 시 플러그인 |
| 플러그인 생태계 | 매우 풍부(역사 길음) | 빠르게 성장 중(대부분 충분) |
| 빌드 | Terser/최적화 옵션 매우 세밀 | Rollup 베이스, 합리적 기본값 |
| 레거시 대응 | 커스터마이즈 쉬움 | 필요 시 `@vitejs/plugin-legacy` |
| 적합 사례 | 대규모 커스텀, 레거시 통합 | 모던 SPA/일반적 제품 개발 |

---

## 19. 마무리

- **번들링**은 모듈 그래프를 **브라우저 최적 산출물**로 만드는 일련의 공정입니다.
- **Vite**는 개발 경험(DX)과 기본 성능 최적화에서 뛰어나며, **Webpack**은 세밀한 제어와 생태계가 강점입니다.
- **Tree Shaking, Code Splitting, Cache, 이미지 최적화**만 잘해도 **LCP/TTI**가 극적으로 개선됩니다.
- 팀/프로젝트 상황(레거시, 요구 확장성, 출시 일정)에 맞춰 적절한 번들러를 선택하세요.

---

## 부록 A) 실습용 템플릿(간단)

```bash
# Vite(React)
npm create vite@latest vite-react -- --template react
cd vite-react && npm i && npm run dev
```

```bash
# Webpack(바닐라)
mkdir wp-vanilla && cd wp-vanilla
npm init -y
npm i -D webpack webpack-cli webpack-dev-server html-webpack-plugin mini-css-extract-plugin css-loader style-loader babel-loader @babel/core @babel/preset-env
```

```js
// wp-vanilla/webpack.config.js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCss = require('mini-css-extract-plugin');

module.exports = {
  mode: 'development',
  entry: './src/main.js',
  devServer: { port: 3000, hot: true, open: true },
  module: {
    rules: [
      { test: /\.js$/, exclude: /node_modules/, use: { loader: 'babel-loader', options: { presets: [['@babel/preset-env']] } } },
      { test: /\.css$/, use: [MiniCss.loader, 'css-loader'] },
    ]
  },
  plugins: [ new HtmlWebpackPlugin({ template: './public/index.html' }), new MiniCss() ]
};
```

---

## 참고 링크

- Webpack: https://webpack.js.org/
- Vite: https://vitejs.dev/
- Rollup: https://rollupjs.org/
- Parcel: https://parceljs.org/
- esbuild: https://esbuild.github.io/
- SWC: https://swc.rs/
- 이미지 최적화: https://web.dev/fast/
