---
layout: post
title: DB 심화 - 대기 이벤트별 발생 원인
date: 2025-10-24 19:25:23 +0900
category: DB 심화
---
# Oracle **대기 이벤트별 발생 원인 → 실행 계획 분석**
## 0) 준비: 샘플 스키마·지표

### 0.1 샘플 테이블/인덱스
```sql
DROP TABLE customers PURGE;
DROP TABLE orders PURGE;

CREATE TABLE customers(
  id      NUMBER PRIMARY KEY,
  region  VARCHAR2(10),
  grade   NUMBER,
  name    VARCHAR2(100)
);

CREATE TABLE orders(
  order_id    NUMBER PRIMARY KEY,
  customer_id NUMBER NOT NULL REFERENCES customers(id),
  order_date  DATE   NOT NULL,
  amount      NUMBER NOT NULL
);

CREATE INDEX ix_orders_cust_date  ON orders(customer_id, order_date);
CREATE INDEX ix_cust_region_grade ON customers(region, grade);

BEGIN
  FOR i IN 1..100000 LOOP
    INSERT INTO customers VALUES(
      i,
      CASE MOD(i,10) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END,
      MOD(i,5),
      'C'||i
    );
  END LOOP; COMMIT;

  FOR i IN 1..2000000 LOOP
    INSERT INTO orders VALUES(
      i,
      MOD(i,100000)+1,
      DATE '2024-01-01' + MOD(i,365),
      MOD(i,500)+1
    );
    IF MOD(i,100000)=0 THEN COMMIT; END IF;
  END LOOP; COMMIT;
END;
/
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS',cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE AUTO');
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE AUTO');
```

### 0.2 “대기 ↔ 라인” 공통 진단 템플릿
1) **느린 구간 고정**: `:t1 ~ :t2`  
2) **ASH로 Top Wait / Top SQL**:
```sql
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '10' MINUTE; EXEC :t2 := SYSTIMESTAMP;

SELECT wait_class, event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY wait_class, event
ORDER  BY samples DESC FETCH FIRST 10 ROWS ONLY;

SELECT sql_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY sql_id
ORDER  BY samples DESC FETCH FIRST 10 ROWS ONLY;
```
3) **해당 SQL_ID 실행계획(실제)**:
```sql
-- 마지막 실행(또는 원하면 SQL_ID/child 지정)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&&SQL_ID', NULL,
  'ALLSTATS LAST +PREDICATE +PROJECTION +OUTLINE +PEEKED_BINDS +NOTE'));
```
4) **Plan Line에서 Time/Temp/Buffers/A-Rows**가 큰 라인 = 병목 라인  
5) 라인의 **연산자/접근방식/프루닝/조인전략/정렬·해시 사용**을 보고 원인과 **수정 포인트**를 도출

---

# 1. User I/O 계열

## 1.1 `db file sequential read` (랜덤 블록 읽기: 인덱스→ROWID)
- **주 원인**:  
  - 인덱스 범위/유니크 스캔 후 **ROWID 랜덤 접근**이 많음(OLTP 흔함).  
  - 선택성 낮은 조건으로 **많은 ROWID**를 따라가거나, **커버링 미흡**.  
  - **클러스터링 팩터**가 나빠 테이블 랜덤 I/O 심화.  
- **Plan 라인 패턴**:  
  - `INDEX RANGE/UNIQUE SCAN` + `TABLE ACCESS BY ROWID` 라인의 **Buffers/Time**↑  
- **예제**
```sql
VAR cid NUMBER; EXEC :cid := 12345;
SELECT /* seq read demo */ *
FROM   orders
WHERE  customer_id=:cid
AND    order_date BETWEEN DATE '2024-06-01' AND DATE '2024-06-30';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
  'ALLSTATS LAST +PREDICATE +PROJECTION'));
```
- **진단 포인트**:  
  - `TABLE ACCESS BY ROWID` 라인 **A-Rows**가 크고 Time↑ → **ROWID 랜덤 I/O 집중**  
  - 인덱스선택성/히스토그램/클러스터링 팩터 확인  
- **개선 전략**:  
  1) **커버링 인덱스**(select list/where 포함)로 **BY ROWID 단계 제거**  
  2) **선택성 개선**(범위 좁히기, 복합 인덱스 선두컬럼 재구성)  
  3) 파티션 프루닝 및 조인순서 조정(소량 먼저)  

---

## 1.2 `db file scattered read` (멀티블록 읽기: FTS/범위 스캔)
- **주 원인**:  
  - **Full Table Scan/Index Fast Full Scan** 또는 큰 범위 스캔, **MBRC** 단위 I/O.  
- **Plan 라인 패턴**:  
  - `TABLE ACCESS FULL` / `INDEX FAST FULL SCAN` 라인 Time/Buffers↑  
- **예제**
```sql
SELECT /* FTS demo */ COUNT(*)
FROM   orders
WHERE  amount > 250;  -- 선택성 낮고 히스토그램 부재 시 FTS 유도

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +NOTE +PREDICATE'));
```
- **개선 전략**:  
  1) **필요 컬럼 커버링 인덱스**로 FTS 회피  
  2) **파티션 프루닝**(날짜 등 범위)  
  3) **카디널리티 보정**(히스토그램/함수제거)로 인덱스 유도  

---

## 1.3 `direct path read temp` / `direct path write temp` (TEMP 스필)
- **주 원인**:  
  - 정렬/해시(그룹, 조인) 작업이 **PGA 용량**을 넘어 TEMP로 **스필**.  
  - **카디널리티 오판**으로 과대 데이터가 정렬/해시 단계에 유입.  
- **Plan 라인 패턴**:  
  - `SORT GROUP BY / SORT ORDER BY / HASH JOIN` 라인의 **TempSpc/Time**↑  
- **예제**
```sql
VAR d1 DATE; VAR d2 DATE;
EXEC :d1 := DATE '2024-06-01'; EXEC :d2 := DATE '2024-06-30';
SELECT /* temp spill demo */ c.region, SUM(o.amount) amt
FROM   orders o JOIN customers c ON c.id=o.customer_id
WHERE  o.order_date BETWEEN :d1 AND :d2
GROUP  BY c.region
ORDER  BY amt DESC;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
  'ALLSTATS LAST +PROJECTION +NOTE'));
```
- **개선 전략**:  
  1) **카디널리티 정확화**(히스토그램, 조인순서/필터 푸시)  
  2) **정렬 회피 인덱스**(예: `… ORDER BY amt` 대신 미리 정렬된 접근)  
  3) **PGA 증가** 및 **workarea policy** 점검  
  4) 해시→NL 전환(소량 드라이빙)  

---

# 2. Concurrency(동시성) 계열

## 2.1 `enq: TX - row lock contention` (행 잠금 충돌)
- **주 원인**:  
  - 동일 로우/범위 갱신 충돌, **외래키 미인덱스**(부모 갱신/삭제 시 자식 스캔), **긴 트랜잭션**.  
- **Plan 라인 패턴**:  
  - 갱신 타겟을 식별하는 **인덱스/ROWID 접근** 라인 자체는 가벼워 보일 수 있음(락 대기는 별개) → **ASH에서 블로킹 세션** 확인  
- **예제 재현**
```sql
-- 세션1
UPDATE customers SET grade=grade+1 WHERE id=100; -- COMMIT 하지 않음

-- 세션2 (같은 로우/자식 FK 갱신 등)
UPDATE orders SET amount=amount*1.1 WHERE customer_id=100; -- TX 대기

-- ASH로 블로커 확인
SELECT * FROM v$session WHERE sid IN (SELECT blocking_session FROM v$session WHERE event LIKE 'enq: TX%');
```
- **개선 전략**:  
  1) **FK 인덱스 필수**  
  2) **트랜잭션 단축/커밋 주기 개선**  
  3) **업무 순서 정렬**(충돌 줄이기), **ITL/INITRANS** 조정(블록 내 경합 시)

---

## 2.2 `buffer busy waits` / `read by other session` (핫블록/블록 경합)
- **주 원인**:  
  - 특정 블록(헤더/인덱스 리프)에 **집중 접근**(치우친 키 분포, 증가키 집중).  
- **Plan 라인 패턴**:  
  - 편향 키를 통해 같은 리프/블록을 반복 접근하는 인덱스/ROWID 라인  
- **예제**
```sql
-- 증가 키에 트래픽 집중(가정)
SELECT /* skew */ COUNT(*) FROM orders WHERE order_id BETWEEN 1999000 AND 2000000;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```
- **개선 전략**:  
  1) **키 분산**(Reverse Key, 해시·서로 다른 시퀀스, 샤딩키)  
  2) **PCTFREE/분산**으로 블록 충돌 완화  
  3) 파티션/로컬 인덱스로 분산

---

# 3. Commit 클래스

## 3.1 `log file sync` (커밋 대기)
- **주 원인**:  
  - **커밋 빈번**(행 단위 커밋), **LGWR I/O 지연**, 네트워크 왕복.  
- **Plan 라인 패턴**:  
  - Plan과 직접 매핑되기보단 **세션 종료 시점 대기**. 그러나 DML 규모/빈도는 Plan에서 유도됨(불필요 대량 DML).  
- **진단**
```sql
SELECT event, total_waits, round(time_waited_micro/1e6,1) sec
FROM   v$system_event
WHERE  event='log file sync';

-- ASH 타임라인에서 해당 이벤트/세션 매칭
```
- **개선 전략**:  
  1) **배치 커밋**(업무 허용시)  
  2) 로그 저장소 성능 개선/IO 경로 단축  
  3) 대량 DML은 **배치 처리**(MERGE/도움되는 인덱스 최소화 후 일괄 재생성)

---

# 4. Library Cache / Row Cache

## 4.1 `library cache: lock/pin` (커서/오브젝트 정의 경합)
- **주 원인**:  
  - **하드 파싱 과다**, 동시 DDL/플랜 무효화, 공유커서 조건 미일치(child 폭증).  
- **Plan 라인 패턴**:  
  - Plan 자체보단 **파싱 단계** 이슈 → 그러나 **자주 변하는 플랜/뷰 머지 실패**가 실행 라인을 불리하게 만듦.  
- **진단/개선**
```sql
-- child 폭증 확인
SELECT sql_id, COUNT(*) child_cnt
FROM   v$sql
GROUP  BY sql_id
HAVING COUNT(*) > 5
ORDER  BY child_cnt DESC;

-- 개선: 바인드 사용, 문장 표준화, session_cached_cursors, DDL 배치
```

## 4.2 `row cache lock` (딕셔너리 캐시 경합)
- **주 원인**: 빈번한 DDL, 시퀀스/동적 객체 생성·삭제.  
- **개선**: DDL 배치, 시퀀스/임시 객체 정책 재점검.

---

# 5. Cluster(RAC)

## 5.1 `gc cr block busy` / `gc current block busy` (글로벌 캐시 경합)
- **주 원인**:  
  - 데이터가 **인터리빙**된 상태에서 여러 인스턴스가 **같은 블록**을 교차로 요구.  
  - 증가키/한 파티션 집중, **ORDER 시퀀스**.  
- **Plan 라인 패턴**:  
  - 해당 블록을 자주 만지는 인덱스/ROWID/해시 조인 라인 Time↑ (SQL Monitor가 특히 유용)  
- **개선 전략**:  
  1) **서비스 로컬리티**(서비스 단위로 파티션/데이터 로컬 배치)  
  2) **시퀀스 NOORDER CACHE**, Reverse Key, 키 분산  
  3) 핫 파티션 분해/재배치

---

# 6. Network

## 6.1 `SQL*Net more data to client/from client`
- **주 원인**:  
  - 결과셋/LOB 대량 전송, 작은 fetch size, 채널 지연.  
- **Plan 라인 패턴**:  
  - `SELECT` 결과가 많게 만드는 **소팅/조인 라인**에서 A-Rows↑.  
- **개선 전략**:  
  1) **필요 컬럼/행만** 조회, **서머리 테이블**  
  2) **배열 페치 크기** 조정  
  3) 네트워크 MTU/RTT 확인

---

# 7. CPU(On CPU)

## 7.1 `ON CPU` (대기 아님, CPU 경합 또는 긴 CPU 작업)
- **주 원인**:  
  - 대량 연산(정렬/해시/함수), 과도 카디널리티로 계획 잘못 선택, CPU 포화.  
- **Plan 라인 패턴**:  
  - `HASH JOIN`, `FILTER`, `PROJECTION` 라인 **Time**↑, `TempSpc`는 낮을 수 있음(메모리 내 처리)  
- **개선 전략**:  
  1) **카디널리티 정확화**로 가벼운 경로 선택  
  2) **필요 연산 최소화**(불필요 함수/표현식 제거, 부분 집계/서브쿼리 물질화)  
  3) CPU 용량/병렬 활용(스필 없이 병렬이 이득일 때)  

---

# 8. 대기 이벤트 → 실행계획 분석: **케이스 스터디**

## 8.1 [User I/O] `direct path read temp`가 1위
**증상**: 리포트 화면 7~10초 / 피크에만 급증  
**분석**
```sql
-- Top Wait/Event/SQL
SELECT event, sql_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY event, sql_id
ORDER  BY samples DESC FETCH FIRST 5 ROWS ONLY;

-- 해당 SQL 실행계획(라인 통계)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&&SQL_ID', NULL,
  'ALLSTATS LAST +PREDICATE +PROJECTION +OUTLINE +NOTE'));
```
**관찰**: `SORT GROUP BY` 라인 `TempSpc` 수 GB, Time↑  
**원인**: `region` 선택도 오판 → 해시/정렬 데이터 과다 유입  
**조치**:  
- `DBMS_STATS` 히스토그램 생성(`FOR COLUMNS SIZE 75 region`) → 조인순서/필터 선행  
- 커버링 인덱스(`(region, order_date, amount)` 일부 조합)로 정렬 회피  
- `pga_aggregate_target` 상향  
**결과**: TempSpc 6GB → 0, Elapsed 8.2s → 1.1s

---

## 8.2 [Concurrency] `enq: TX - row lock contention`
**증상**: 오후 2시 배치 갱신 시 사용자 전체 지연  
**분석**
```sql
-- ASH로 블로커/블로키
SELECT session_id, blocking_session, event, count(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event LIKE 'enq: TX%'
GROUP  BY session_id, blocking_session, event
ORDER  BY samples DESC;

-- FK 인덱스 검사
SELECT a.table_name, a.constraint_name, a.status
FROM   user_constraints a
WHERE  a.constraint_type='R'
  AND NOT EXISTS (
    SELECT 1 FROM user_ind_columns i
    WHERE  i.table_name=a.table_name
      AND  i.column_name IN (
           SELECT column_name FROM user_cons_columns
           WHERE constraint_name=a.constraint_name)
  );
```
**원인**: 자식 테이블 FK 미인덱스로 부모 갱신/삭제 시 테이블 스캔 + 락 확산  
**조치**: FK 컬럼 인덱스 생성 → 즉시 대기 사라짐

---

## 8.3 [Commit] `log file sync`
**증상**: TPS 증가와 함께 1~2초 지연 급증(피크타임)  
**분석**: Top Wait = `log file sync`, ASH 타임라인에 이벤트 치솟음  
**원인**: 매 행 커밋 + 스토리지 지연  
**조치**: 배치 커밋(업무 허용 시), 앱 드라이버/네트워크 RTT 점검, 로그 디스크 향상  
**결과**: p95 응답 2.4s → 0.7s

---

## 8.4 [RAC] `gc current block busy`
**증상**: 2노드 RAC, 특정 파티션 핫  
**분석**
```sql
SELECT sql_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  wait_class='Cluster'
GROUP  BY sql_id
ORDER  BY samples DESC;

-- 해당 SQL 라인 통계
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&&SQL_ID', NULL,
  'ALLSTATS LAST +PARALLEL +NOTE'));
```
**원인**: 증가키 집중, 한 파티션으로 동시 업데이트 → 글로벌 캐시 핫  
**조치**: 서비스 로컬리티, 파티션 분리, 시퀀스 NOORDER CACHE, Reverse Key  
**결과**: Cluster 대기 80% → 5%

---

# 9. “대기 → 라인” 매핑 체크리스트(암기 리스트)

| 대기 이벤트 | 실행계획 라인에서 찾을 것 | 흔한 원인 | 대표 처방 |
|---|---|---|---|
| db file sequential read | `INDEX SCAN`→`BY ROWID` Time/Buffers | 랜덤 I/O/커버링 미비/선택성 낮음 | 커버링, 히스토그램, 조인순서, 파티션 |
| db file scattered read | `TABLE ACCESS FULL` Time↑ | FTS/범위 넓음 | 인덱스/프루닝/통계 보정 |
| direct path read/write temp | `SORT/HASH` 라인 TempSpc↑ | PGA 부족/카디널리티 오판 | PGA↑, 정렬 회피, 해시→NL |
| enq: TX - row lock | Plan 라인 가볍고 ASH에 락 | FK 미인덱스/긴 트랜잭션 | FK 인덱스, 커밋·순서 개선 |
| buffer busy waits | 인덱스/ROWID 라인 반복 접근 | 핫블록/키 편향 | Reverse Key, 분산/파티션 |
| log file sync | - | 커밋 과다/LGWR 지연 | 배치 커밋, 로그 I/O 개선 |
| library cache lock/pin | 파싱 단계 | 하드파싱/DDL | 바인드, 커서 캐시, DDL 배치 |
| gc current/cr block busy | 핫블록 라인 | RAC 로컬리티 부재/키 집중 | 서비스 로컬, NOORDER, 분산 |
| SQL*Net more data | 결과 과다 | 과다 SELECT/작은 Fetch | 컬럼/행 절제, Fetch 크기, 요약 |

---

# 10. 자동 보고 스크립트(붙여 쓰기)

## 10.1 최근 15분 **Wait Class/Event → Top SQL**
```sql
WITH base AS (
  SELECT sample_time, wait_class, event, sql_id
  FROM   v$active_session_history
  WHERE  sample_time > SYSTIMESTAMP - INTERVAL '15' MINUTE
  AND    session_type='FOREGROUND'
)
SELECT wait_class, event, sql_id, COUNT(*) samples
FROM   base
GROUP  BY wait_class, event, sql_id
ORDER  BY samples DESC FETCH FIRST 20 ROWS ONLY;
```

## 10.2 **SQL_ID별 라인 통계** 일괄 출력(최근 실행)
```sql
-- SQL_ID 리스트를 바인딩 받거나, 위 결과에서 하나씩 투입
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&&SQL_ID', NULL,
  'ALLSTATS LAST +PREDICATE +PROJECTION +OUTLINE +NOTE'));
```

## 10.3 **Temp 사용 상위 라인** 빠르게 찾기 (SQL Monitor가 없을 때)
```sql
-- A-Rows/TempSpc 순으로 오래 걸리는 라인 찾기
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&&SQL_ID', NULL,
  'ALLSTATS LAST +PROJECTION +NOTE')); -- 출력에서 TempSpc 큰 라인 확인
```

---

# 11. 수학 한 줄(개념 리마인드)
- **응답시간 분해**:  
  $$ T_{\text{elapsed}} = T_{\text{CPU}} + \sum_k T_{\text{wait}_k} $$
- **AAS(평균 활성 세션)**:  
  $$ \text{AAS} \approx \frac{\text{DB Time}}{\text{벽시계 시간}} $$

> 해석 팁: **Top Wait**는 “현상의 이름”, **Plan Line**은 “원인의 좌표”.  
> 두 개를 **항상 함께** 보아야 정확한 처방이 가능하다.

---

# 12. 결론(현장 루틴 요약)
1) **ASH로 Top Wait/Event/SQL**을 뽑는다.  
2) **해당 SQL의 `DISPLAY_CURSOR('ALLSTATS LAST')`**를 켜서 **시간/버퍼/Temp**가 큰 **라인**을 식별한다.  
3) 라인의 **연산자/접근경로/정렬·해시/조인전략/프루닝**을 읽고 **원인 가설**을 세운다.  
4) **작고 정확한 변경**(인덱스/통계/조인순서/키분산/PGA/커밋정책/서비스 로컬리티)을 적용한다.  
5) 같은 구간·부하로 **Before/After**를 재측정해 효과를 **수치**로 증명한다.

> 한 줄 정리  
> **대기 이벤트 이름**은 출발점이고, **실행계획 라인**이 결승선이다.  
> 이름표에서 출발해 **라인**으로 달려가라. 거기에 튜닝의 답이 있다.