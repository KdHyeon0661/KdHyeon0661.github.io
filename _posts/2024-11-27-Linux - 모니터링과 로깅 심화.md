---
layout: post
title: Linux - SELinux & AppArmor 보안 모듈
date: 2024-11-27 19:20:23 +0900
category: Linux
---
# SELinux & AppArmor 보안 모듈

## 1. 왜 MAC 인가? DAC → MAC으로 올라타는 이유

- **DAC(Discretionary Access Control)**: 소유자/퍼미션/그룹 기반(예: `rwx`, `chmod`, `setuid`).  
  루트 프로세스가 뚫리면 **시스템 전역**으로 확장될 위험.
- **MAC(Mandatory Access Control)**: *“허용된 것만 된다(deny by default)”* 정책.  
  프로세스/파일/포트/IPC/네임스페이스 등 **라벨(정책)**을 기준으로 **루트도 제약**.

핵심 철학:
- 최소 권한(Least Privilege)
- 허용 목록(Allow-listing)
- 정책과 로깅을 통한 **가시성 + 재발 방지**

---

## 2. SELinux 핵심 개념 단숨에 잡기 (정책 타입·컨텍스트·booleans)

### 2.1 동작 모드와 시스템 전역 상태

```bash
getenforce            # Enforcing | Permissive | Disabled
sestatus              # 상세 상태/정책 유형/현재 모드
setenforce 0          # 일시 Permissive (재부팅 시 원복)
setenforce 1          # Enforcing 복귀
# 영구 설정
sudo sed -i 's/^SELINUX=.*/SELINUX=enforcing/' /etc/selinux/config
```

- **Enforcing**: 정책 위반 차단 + 로그
- **Permissive**: 차단하지 않고 위반만 로그(튜닝 단계에 유리)
- **Disabled**: 비활성(권장하지 않음)

### 2.2 보안 컨텍스트 형식

```bash
ls -Z /var/www/html/index.html
```

예시 출력:
```
-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0
```

- 형식: `user:role:type:level`  
  - **type**: Type Enforcement(TE) 정책의 핵심(예: `httpd_t`, `httpd_sys_content_t`)  
  - **level**: MLS/MCS 레벨 (일반적 운영에선 `s0`/카테고리 활용)

### 2.3 정책 유형

- **Targeted**(기본): 네트워크 서비스 등 주요 데몬만 강제
- **Strict**: 시스템 전체 강제(학습/연구용)
- **MLS**: 다단계 보안, 등급/카테고리로 흐름 제어(특수 환경)

현재 정책 확인:
```bash
sestatus | grep "Loaded policy name"
```

### 2.4 SELinux Booleans(상황별 완화 스위치)

```bash
getsebool -a | grep httpd
setsebool -P httpd_can_network_connect on
setsebool -P nis_enabled off
```

- **`-P`**: 영구 반영(`/etc/selinux/targeted/modules/active/` 아래에 저장)
- 보안성 유지 + 운영 편의의 트레이드오프를 **제어 가능한 스위치**로 분리

---

## 3. SELinux 파일/포트 라벨링: semanage·restorecon·chcon

### 3.1 파일 컨텍스트 지정 (영구 vs 일시)

**영구 규칙 등록 → 실제 파일 라벨 복원**이 정석입니다.

```bash
# 1. fcontext 규칙 정의(영구)
sudo semanage fcontext -a -t httpd_sys_content_t '/srv/www(/.*)?'

# 2. 실제 파일에 라벨 적용(restorecon)
sudo restorecon -Rv /srv/www

# (일시적 변경은 chcon, 재라벨링 시 사라질 수 있음)
sudo chcon -t httpd_sys_content_t /srv/www/index.html
```

확인:
```bash
ls -Z /srv/www/index.html
```

### 3.2 포트 컨텍스트 (서비스 포트 확장)

```bash
# HTTP 데몬이 8081/tcp도 사용하도록
sudo semanage port -a -t http_port_t -p tcp 8081
sudo semanage port -l | grep http_port_t
```

- **잘못된 타입**에 포트를 추가하면 허용되지 않음.
- RHEL/Fedora/CentOS: `policycoreutils-python(-utils)` 패키지 필요할 수 있음.

---

## 4. SELinux 로그 해석 루틴: ausearch → audit2why → audit2allow

### 4.1 거부(AVC Denial) 로그 모으기

```bash
# 최근 차단 위주
sudo ausearch -m avc -ts recent

# systemd 환경(도우미 데몬)
sudo journalctl -t setroubleshoot
```

### 4.2 “왜 거부되었나?” 빠른 해석

```bash
sudo cat /var/log/audit/audit.log | audit2why
```

출력 예시(의미 요약):
- 잘못된 타입으로 접근
- boolean 활성 필요(`httpd_can_network_connect`)
- fcontext 규칙 누락 → `restorecon` 또는 `semanage fcontext` 필요

### 4.3 최소 허용 룰 생성(정책 모듈)

테스트/임시적 정책 보완 시:

```bash
# audit 로그를 기반으로 candidate 정책 생성
sudo grep denied /var/log/audit/audit.log | audit2allow -M my_httpd

# 로딩
sudo semodule -i my_httpd.pp
# 정책 목록/상태
sudo semodule -l | grep my_httpd
```

> **원칙**: 허용 룰은 **최소화**. 라벨링/boolean으로 해결 가능한지 먼저 확인하고,  
> 정말 필요한 경우에만 policy 모듈을 추가.

---

## 5. 서비스별 SELinux 튜닝 예시(현업 빈도 높은 것만)

### 5.1 NGINX/Apache: 웹 루트 변경 + 외부 네트워크 연결

```bash
# 새로운 루트 /srv/www
sudo semanage fcontext -a -t httpd_sys_content_t '/srv/www(/.*)?'
sudo restorecon -Rv /srv/www

# 외부 네트워크 연결 허용(백엔드 API 호출 등)
sudo setsebool -P httpd_can_network_connect on
# 소켓/프록시, 메일 등은 추가 boolean 검토
getsebool -a | egrep 'httpd.*(network|sendmail|mysql)'
```

### 5.2 MariaDB/MySQL: 데이터 디렉토리 이동

```bash
sudo semanage fcontext -a -t mysqld_db_t '/data/mysql(/.*)?'
sudo restorecon -Rv /data/mysql
# systemctl 재시작 후 에러 시 audit 로그→audit2why
```

### 5.3 Docker/Podman: 컨테이너 볼륨 마운트 라벨

- RHEL/Fedora/Alma/Rocky 계열 컨테이너 런타임은 SELinux 연동이 강력함.
- **볼륨 마운트에 `:Z`(Private) 또는 `:z`(Shared)** 옵션 사용:

```bash
podman run -v /data/app:/app:Z -p 8080:8080 myimage
# 또는
docker run -v /data/app:/app:Z -p 8080:8080 myimage
```

라벨이 자동으로 컨테이너 도메인(`container_t`)에 맞춰져 **호스트-컨테이너 간 경계**가 확보됨.

---

## 6. SELinux 트러블슈팅 체크리스트(현장용)

1. **상태 확인**: `getenforce`, `sestatus`
2. **로그 수집**: `ausearch -m avc -ts recent` / `journalctl -t setroubleshoot`
3. **대상 확인**: 접근한 **프로세스 도메인(type)**, 대상 파일/포트의 **타입**
4. **라벨 보정**: `semanage fcontext` → `restorecon -Rv`
5. **boolean 검토**: `getsebool -a | grep <서비스>`
6. **정말 필요할 때만** `audit2allow`로 최소 룰 생성 → `semodule -i`
7. **재현/회귀 테스트**: Permissive → Enforcing 복귀 전 검증

---

## 7. AppArmor: 경로 기반 프로파일로 빠르게 감싸기

### 7.1 전역 상태/프로파일 관리

```bash
aa-status                        # 전체 요약
sudo aa-enforce /etc/apparmor.d/usr.sbin.nginx
sudo aa-complain /etc/apparmor.d/usr.sbin.nginx
sudo aa-disable  /etc/apparmor.d/usr.sbin.nginx
```

- **enforce**: 차단 + 로그
- **complain**: 차단 X + 로그 (튜닝 단계)
- Ubuntu 기본 활성, Debian은 선택적

### 7.2 프로파일 파일 배치와 include

- 경로: `/etc/apparmor.d/`
- 기본 추상화/공통 룰: `/etc/apparmor.d/abstractions/*`

예: `/etc/apparmor.d/usr.bin.curl` (샘플)
```text
#include <tunables/global>

/usr/bin/curl {
  # 읽기 허용(인증서, resolv 등)
  /etc/resolv.conf r,
  /etc/ssl/** r,
  /usr/share/ca-certificates/** r,

  # 네트워크 사용
  network inet stream,
  network inet6 stream,
  network inet dgram,
  network inet6 dgram,

  # 실행 허용(제한적)
  /bin/ping Pix,        # P: profile, i: inherit, x: execute, 등
  deny /etc/shadow r,   # 명시 거부

  # capability(특권) 제어
  capability net_raw,

  # ptrace/signal 제어 가능 (필요시)
  # ptrace read peer=someprofile,
}
```

적용/파서:
```bash
sudo apparmor_parser -r /etc/apparmor.d/usr.bin.curl
# 또는 시스템 서비스 재시작 시 자동 로드
```

### 7.3 로그 기반 보정(반복 학습 루프)

```bash
sudo aa-logprof
# /var/log/syslog, /var/log/kern.log, journal에서 거부 이벤트 수집하여
# 허용/거부/정교화 질문 → 프로파일 자동 보완
```

### 7.4 빠른 프로파일 생성

```bash
sudo aa-genprof /usr/sbin/mydaemon
# 대화형으로 실행 경로/접근경로를 학습하여 초안 생성
```

---

## 8. SELinux vs AppArmor — 선택 가이드

| 축 | SELinux | AppArmor |
|---|---|---|
| 정책 모델 | **Type Enforcement(TE)** 라벨 기반 | **경로 기반** 프로파일 |
| 학습 난이도 | 높음(강력/정교) | 낮음(직관/신속) |
| 운영 배포판 | RHEL/Fedora/Alma/Rocky 등 | Ubuntu/Debian 등 |
| 컨테이너 연동 | 매우 강력(라벨 기반 격리) | 무난(경로/네임스페이스 연동) |
| 튜닝 워크플로 | `semanage`/`restorecon`/`audit2allow` | `aa-logprof`/`aa-genprof` |

**실무 권장**  
- RHEL/Alma/Rocky/Fedora: **SELinux 고수준 활용**(컨테이너/서버 적합)  
- Ubuntu LTS 데스크톱/경량 서버: **AppArmor 시작** → 필요 시 SELinux 전환 검토

---

## 9. 운영 필수 시나리오

### 9.1 “HTTP 403/502? SELinux 때문 아닐까?”
```bash
# 1. 로그
ausearch -m avc -ts recent
# 2. 웹 루트 라벨
semanage fcontext -l | grep /srv/www
restorecon -Rv /srv/www
# 3. 외부 접근 필요?
setsebool -P httpd_can_network_connect on
# 4. 여전히 거부? 최소 정책 생성
grep denied /var/log/audit/audit.log | audit2allow -M my_http_fix
semodule -i my_http_fix.pp
```

### 9.2 “MySQL 데이터 디렉토리 이동 후 기동 실패”
```bash
semanage fcontext -a -t mysqld_db_t '/data/mysql(/.*)?'
restorecon -Rv /data/mysql
systemctl restart mysqld
```

### 9.3 “Ubuntu에서 특정 데몬을 빨리 감싸기”
```bash
sudo aa-genprof /usr/sbin/mydaemon
# complain으로 학습 → aa-logprof로 보정 → aa-enforce로 전환
```

---

## 10. 정책 검증/회귀 방지: Dev → Stage → Prod

1. **Permissive/complain**으로 학습 + 로그 수집  
2. **자동 보정 도구**(audit2allow/aa-logprof)로 초안 생성  
3. 수동 리뷰(최소 권한/경로 제한/와일드카드 최소화)  
4. **테스트 배포**: 새로운 라벨/포트/boolean/정책 모듈 포함  
5. **Enforcing 전환** + 모니터링 대기  
6. **재현 테스트/회귀 테스트**로 안정화

---

## 11. 시스템 전환/복구 요령

- SELinux Enforcing에서 서비스가 급하게 막히면:  
  1) 일시 완화: `setenforce 0` → 원인 진단 후 복귀 `setenforce 1`  
  2) 라벨 재설정: `restorecon -Rv <경로>`  
  3) 부팅 실패/무한 대기: **GRUB에서** `enforcing=0` 또는 `selinux=0` 임시로

- AppArmor에서 막히면:  
  1) 일시 완화: `aa-complain <프로파일>`  
  2) `aa-logprof`로 보정  
  3) `aa-enforce`로 복귀

---

## 12. 예제 모음(복붙 가능)

### 12.1 SELinux — NGINX가 `/opt/site`를 루트로 쓰고 8443 포트로 서비스
```bash
# 파일 라벨 영구 지정
sudo semanage fcontext -a -t httpd_sys_content_t '/opt/site(/.*)?'
sudo restorecon -Rv /opt/site

# 비표준 포트 허용
sudo semanage port -a -t http_port_t -p tcp 8443

# 외부 연결 필요 시(백엔드 API)
sudo setsebool -P httpd_can_network_connect on

# 점검
sestatus
ls -Zd /opt/site
semanage port -l | grep http_port_t
```

### 12.2 AppArmor — `/usr/local/bin/api`를 빠르게 감싸기
```bash
# 1. 프로파일 틀 생성(complain)
sudo aa-genprof /usr/local/bin/api
# api를 실제로 호출/기능 수행 → 로그 축적
# 2. 로그 기반 보정
sudo aa-logprof
# 3. 강제 모드 전환
sudo aa-enforce /etc/apparmor.d/usr.local.bin.api
```

### 12.3 SELinux — 컨테이너 볼륨 마운트 라벨링
```bash
# 호스트 디렉토리를 컨테이너 전용 라벨로
podman run -v /srv/app:/app:Z -p 8080:8080 myimage
# 또는 Docker
docker run -v /srv/app:/app:Z -p 8080:8080 myimage
```

---

## 13. 자주 쓰는 명령 요약표

### SELinux
| 목적 | 명령 |
|---|---|
| 상태/모드 | `getenforce`, `sestatus`, `setenforce 0|1` |
| 라벨 보기 | `ls -Z`, `ps -eZ`, `id -Z` |
| fcontext | `semanage fcontext -a/-d ...`, `restorecon -Rv <path>` |
| 포트 라벨 | `semanage port -a/-d -t <type> -p tcp|udp <port>` |
| boolean | `getsebool -a`, `setsebool -P <bool> on|off` |
| 로그 해석 | `ausearch -m avc`, `audit2why`, `audit2allow -M`, `semodule -i` |

### AppArmor
| 목적 | 명령 |
|---|---|
| 상태/모드 | `aa-status`, `aa-enforce`, `aa-complain`, `aa-disable` |
| 프로파일 생성 | `aa-genprof <path>`, `apparmor_parser -r <profile>` |
| 로그 기반 보정 | `aa-logprof` |

---

## 14. 실무 팁: “정책이 아니라 라벨 문제”라는 사실

운영에서 막히는 8할은 **정책 자체의 결함**보다 **라벨 불일치**입니다.  
- SELinux: **`semanage fcontext` → `restorecon`** 루틴을 체화  
- AppArmor: 배포/업그레이드로 **바이너리 경로가 바뀌면 프로파일 경로도 수정**

---

## 15. 미니 퀴즈(자기점검)

1. SELinux에서 **외부 네트워크 연결**이 필요한 httpd를 허용하는 가장 안전하고 간단한 방법은?  
   → `setsebool -P httpd_can_network_connect on`

2. `/srv/www`를 웹 루트로 쓰려면?  
   → `semanage fcontext -a -t httpd_sys_content_t '/srv/www(/.*)?' && restorecon -Rv /srv/www`

3. Ubuntu에서 커스텀 데몬을 빠르게 감싸려면?  
   → `aa-genprof /usr/sbin/mydaemon` → `aa-logprof` → `aa-enforce`

---

## 16. 결론 — 로그로 시작해 라벨과 보일러플레이트로 끝낸다

- **SELinux**는 강력하지만 라벨/boolean/정책 모듈의 **정합성**이 핵심.
- **AppArmor**는 빠르게 감싸서 **가시성**을 만들고, 필요한 만큼만 허용.
- 공통 원칙: **로그 해석 → 최소 보완 → 재검증 → 강제 모드**  
  (Permissive/complain은 *과渡기*, Enforcing이 *목표 상태*)

이제 *“무조건 끄자”*에서 *“운영 루틴에 얹자”*로.  
정책을 **코드처럼 버전 관리**하고, **테스트 파이프라인**에 넣어 **안전한 운영**을 완성하세요.