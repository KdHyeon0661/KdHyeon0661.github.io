---
layout: post
title: HTML - SVG
date: 2025-04-09 20:20:23 +0900
category: HTML
---
# SVG 완전 정복: 벡터 그래픽의 핵심, Canvas와의 차이, 실전 예제 총정리

**SVG(Scalable Vector Graphics)**는 **XML 기반 벡터 그래픽 표준**입니다. 확대해도 깨지지 않는 고해상도, DOM 통합으로 인한 접근성/상호작용/스타일링, 선언적 애니메이션과 필터·마스크 등 강력한 기능을 제공합니다.
이 글은 당신이 정리한 초안을 **확장**하여, 좌표계·반응형·애니메이션·효과·접근성·보안·성능·툴링까지 실무에서 꼭 쓰는 내용을 예제와 함께 **빠짐없이** 담았습니다.

---

## 1. SVG의 기본 구조와 좌표계

### 1.1 최소 예제

```html
<svg width="200" height="200">
  <circle cx="100" cy="100" r="80" stroke="green" stroke-width="4" fill="yellow" />
</svg>
```

- `<svg>`: 루트 요소
- `width`/`height`: 렌더링 크기(CSS 픽셀)
- `<circle>`: 원, `cx`/`cy`는 중심 좌표, `r`는 반지름

### 1.2 `viewBox`와 내부 좌표계

`viewBox="minX minY width height"`는 **내부 논리 좌표계**를 정의하고, 실제 렌더링 영역에 **비율 유지/확대축소**를 적용합니다.

```html
<svg viewBox="0 0 200 200" width="200" height="200">
  <rect x="0" y="0" width="200" height="200" fill="#f7f7f7" />
  <circle cx="100" cy="100" r="80" fill="gold" />
</svg>
```

- 내부 좌표: (0,0)~(200,200)
- 외부 크기: `200x200`(CSS 픽셀). 확대/축소해도 선명.

### 1.3 `preserveAspectRatio`

**뷰박스 비율과 렌더링 박스의 비율이 다를 때** 배치 방식을 제어합니다.

```html
<svg viewBox="0 0 200 100" width="300" height="200" preserveAspectRatio="xMidYMid meet">
  <!-- meet: 전부 보되 여백 생김 / slice: 빈공간 없이 잘라냄 -->
  <rect width="200" height="100" fill="lightblue"/>
  <text x="100" y="55" text-anchor="middle" dominant-baseline="middle" font-size="24">Aspect</text>
</svg>
```

- `xMin|xMid|xMax` + `YMin|YMid|YMax` + `meet|slice|none`

---

## 2. 반응형 SVG

### 2.1 CSS로 크기 제어

```html
<svg viewBox="0 0 600 300" style="width:100%;height:auto;display:block">
  <rect width="600" height="300" fill="#eee"/>
  <circle cx="300" cy="150" r="120" fill="#ccf"/>
</svg>
```

- `width: 100%`, `height: auto`: 컨테이너 폭에 맞추어 스케일
- 스크롤/모바일에 자연스러운 반응형

### 2.2 `<picture>`/`<img>`로 SVG 사용 시 주의

- **인라인 `<svg>`**: DOM 접근/스타일/애니메이션 가능
- **파일로 `<img src="a.svg">`**: 내용이 별 문서로 취급되어 **내부 DOM 제어 어려움**
- 상호작용/동적 스타일링이 필요하면 **인라인**이 유리

---

## 3. 주요 도형 요소 빠르게 훑기

```html
<svg viewBox="0 0 240 120" width="480" height="240" style="border:1px solid #ddd">
  <rect x="10" y="10" width="60" height="40" rx="8" fill="#ffd" stroke="#333"/>
  <circle cx="120" cy="30" r="20" fill="#def" stroke="#246"/>
  <ellipse cx="200" cy="30" rx="25" ry="15" fill="#efe" stroke="#383"/>

  <line x1="10" y1="80" x2="70" y2="110" stroke="#b33" stroke-width="3"/>
  <polyline points="90,80 110,90 130,80 150,90 170,80" fill="none" stroke="#07a" />
  <polygon points="190,80 210,110 170,110" fill="#fa6" stroke="#a53"/>

  <text x="120" y="110" text-anchor="middle" font-size="14">기본 도형</text>
</svg>
```

---

## 4. Path 명령 정리와 예제

**Path는 SVG의 핵심**. 자유 곡선과 복합 도형을 표현합니다.

| 명령 | 의미 | 예 |
|---|---|---|
| `M x y` | 이동(Moveto) | `M10 10` |
| `L x y` | 직선(Lineto) | `L50 10` |
| `H x`, `V y` | 수평/수직 | `H90` |
| `C x1 y1 x2 y2 x y` | 3차 베지어 | `C 20 20 40 0 60 10` |
| `Q x1 y1 x y` | 2차 베지어 | `Q 30 30 60 10` |
| `A rx ry xrot laf sf x y` | 호/타원 | `A 30 30 0 0 1 90 60` |
| `Z` | 폐합 | `Z` |

소문자는 **상대좌표**.

```html
<svg viewBox="0 0 120 60" width="360" height="180" style="border:1px solid #ddd">
  <path d="M10 50 C 30 10, 60 10, 90 50" fill="none" stroke="#e55" stroke-width="3"/>
  <path d="M10 10 L 50 10 A 10 10 0 0 1 60 20 L 60 40 Z" fill="#9cf" stroke="#246"/>
</svg>
```

---

## 5. 스타일링: CSS, 변수, 클래스

```html
<style>
  .node { fill: var(--node-fill, #fff); stroke:#222; stroke-width:1.5; }
  .node:hover { fill:#ffe; cursor:pointer; }
</style>

<svg viewBox="0 0 200 80" width="400">
  <g style="--node-fill:#def">
    <rect class="node" x="10" y="10" width="60" height="30" rx="6"/>
  </g>
  <g style="--node-fill:#fde">
    <rect class="node" x="90" y="10" width="60" height="30" rx="6"/>
  </g>
</svg>
```

- CSS 커스텀 프로퍼티(변수)로 테마 변경 용이
- `currentColor` 활용 시 부모 텍스트 색과 연동 가능

---

## 6. 트랜스폼(이동/회전/스케일)

```html
<svg viewBox="0 0 200 100" width="380" style="border:1px solid #ddd">
  <rect x="20" y="20" width="50" height="30" fill="#ccc"/>
  <rect x="20" y="20" width="50" height="30" fill="#8ef" transform="translate(80,0) rotate(20,45,35) scale(1.2)"/>
</svg>
```

- `transform="translate(tx,ty) rotate(angle,cx,cy) scale(s) skewX(sk) ..."`

---

## 7. 그라디언트·패턴·마커

```html
<svg viewBox="0 0 220 120" width="460">
  <defs>
    <linearGradient id="g1" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0%" stop-color="#7dd"/>
      <stop offset="100%" stop-color="#059"/>
    </linearGradient>

    <pattern id="p1" width="8" height="8" patternUnits="userSpaceOnUse">
      <rect width="8" height="8" fill="#fff"/>
      <path d="M0 0 L8 8 M8 0 L0 8" stroke="#eee"/>
    </pattern>

    <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
      <path d="M0 0 L10 5 L0 10 z" fill="#333"/>
    </marker>
  </defs>

  <rect x="10" y="10" width="90" height="40" fill="url(#g1)"/>
  <rect x="120" y="10" width="90" height="40" fill="url(#p1)"/>

  <line x1="20" y1="80" x2="200" y2="80" stroke="#333" stroke-width="3" marker-end="url(#arrow)"/>
</svg>
```

---

## 8. 마스크·클리핑·필터

```html
<svg viewBox="0 0 240 120" width="480">
  <defs>
    <clipPath id="clipCircle"><circle cx="60" cy="60" r="40"/></clipPath>

    <mask id="maskFade">
      <linearGradient id="fadeG" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0%" stop-color="black"/>
        <stop offset="100%" stop-color="white"/>
      </linearGradient>
      <rect width="240" height="120" fill="url(#fadeG)"/>
    </mask>

    <filter id="f1" x="-20%" y="-20%" width="140%" height="140%">
      <feGaussianBlur stdDeviation="3"/>
      <feDropShadow dx="3" dy="3" stdDeviation="2" flood-color="#000" flood-opacity="0.4"/>
    </filter>
  </defs>

  <image href="https://picsum.photos/240/120" width="240" height="120" clip-path="url(#clipCircle)"/>
  <rect x="120" y="10" width="110" height="100" fill="#fdd" mask="url(#maskFade)" filter="url(#f1)"/>
</svg>
```

- `clipPath`: 보여줄 영역 잘라내기
- `mask`: 밝기 기반 마스킹(부드러운 페이드 가능)
- `filter`: 블러, 그림자, 색상 매트릭스 등

---

## 9. 아이콘 재사용: `<symbol>` + `<use>` + 스프라이트

```html
<svg style="display:none">
  <symbol id="icon-star" viewBox="0 0 24 24">
    <path d="M12 2l3.3 6.7 7.4 1.1-5.3 5.2 1.2 7.3L12 18l-6.6 3.5 1.2-7.3L1.4 9.8l7.4-1.1z"/>
  </symbol>
</svg>

<svg width="48" height="48" fill="gold"><use href="#icon-star"/></svg>
<svg width="24" height="24" fill="#999"><use href="#icon-star"/></svg>
```

- 한 번 정의 후 **여러 크기/색으로 재사용**.
- 외부 스프라이트 파일에서 `<use href="sprite.svg#icon-id">` 로도 활용 가능(CORS/동일 출처 주의).

---

## 10. 텍스트와 경로 따르기

```html
<svg viewBox="0 0 300 120" width="600">
  <defs>
    <path id="curve" d="M10 100 C 80 10, 220 10, 290 100"/>
  </defs>
  <text font-size="18" fill="#333">
    <textPath href="#curve" startOffset="50%" text-anchor="middle">
      곡선을 따라 흐르는 텍스트
    </textPath>
  </text>
</svg>
```

- `textLength`, `lengthAdjust` 등으로 텍스트 길이 제어 가능

---

## 11. 상호작용과 이벤트

### 11.1 기본 이벤트

```html
<svg viewBox="0 0 120 60" width="360">
  <circle id="dot" cx="30" cy="30" r="20" fill="#69f"/>
  <rect id="btn" x="70" y="15" width="40" height="30" rx="6" fill="#ddd" stroke="#333"/>
</svg>

<script>
document.getElementById('dot').addEventListener('click', () => alert('circle'));
document.getElementById('btn').addEventListener('mouseenter', e => e.target.setAttribute('fill', '#eee'));
document.getElementById('btn').addEventListener('mouseleave', e => e.target.setAttribute('fill', '#ddd'));
</script>
```

### 11.2 `pointer-events`와 히트 테스트

- 투명한 부분을 클릭 가능/불가 제어: `pointer-events="none|auto|visiblePainted|..."`

```html
<rect width="100" height="40" fill="none" stroke="#333" pointer-events="stroke"/>
```

---

## 12. 애니메이션: CSS / JS / SMIL

### 12.1 CSS 애니메이션(간단/상태 기반)

```html
<style>
  .pulse { animation: pulse 2s infinite; transform-origin: 50% 50%; }
  @keyframes pulse {
    0% { transform: scale(1); fill:#58a; }
    50% { transform: scale(1.15); fill:#8bd; }
    100% { transform: scale(1); fill:#58a; }
  }
</style>

<svg viewBox="0 0 100 100" width="200">
  <circle class="pulse" cx="50" cy="50" r="20"/>
</svg>
```

### 12.2 JS로 프레임 제어(`requestAnimationFrame`)

```html
<svg id="stage" viewBox="0 0 200 60" width="480">
  <rect id="bar" x="10" y="20" width="10" height="20" fill="#4a8"/>
</svg>
<script>
const bar = document.getElementById('bar');
let w = 10, dir = 1;
function tick() {
  w += dir*0.6;
  if (w > 180 || w < 10) dir *= -1;
  bar.setAttribute('width', w);
  requestAnimationFrame(tick);
}
tick();
</script>
```

### 12.3 선 그리기 애니메이션(대시 활용)

```html
<svg viewBox="0 0 220 60" width="480">
  <path id="path" d="M10 30 C 60 0, 160 60, 210 30" fill="none" stroke="#e55" stroke-width="3"/>
</svg>
<script>
const p = document.getElementById('path');
const len = p.getTotalLength();
p.style.strokeDasharray = len;
p.style.strokeDashoffset = len;
p.getBoundingClientRect(); // reflow
p.style.transition = 'stroke-dashoffset 2s ease';
p.style.strokeDashoffset = '0';
</script>
```

> SMIL 애니메이션(`<animate>`, `<animateTransform>`)도 가능하지만 브라우저 지원/정책에 따라 CSS/JS가 더 일관적입니다.

---

## 13. 외부 콘텐츠: `<image>`와 `<foreignObject>`

```html
<svg viewBox="0 0 320 160" width="640">
  <image href="https://picsum.photos/200/120" x="10" y="10" width="200" height="120" clip-path="inset(0 round 8)"/>
  <foreignObject x="220" y="10" width="90" height="120">
    <div xmlns="http://www.w3.org/1999/xhtml" style="font:14px sans-serif;border:1px solid #ccc;padding:8px;border-radius:6px">
      HTML을 SVG 안에 삽입해 레이아웃/스타일 사용
    </div>
  </foreignObject>
</svg>
```

- `<foreignObject>`는 강력하지만 이메일/일부 뷰어에서 제한될 수 있음.

---

## 14. 접근성(ARIA)과 구조화

- 시맨틱: `role="img"` + `aria-labelledby`/`aria-describedby`
- `<title>`과 `<desc>`로 스크린리더 설명 제공

```html
<svg viewBox="0 0 100 100" role="img" aria-labelledby="t d">
  <title id="t">성장 지표 차트 아이콘</title>
  <desc id="d">오른쪽 위 방향 화살표</desc>
  <path d="M10 80 L40 50 60 60 90 20" fill="none" stroke="#333" stroke-width="4"/>
</svg>
```

- 포커스 가능 요소는 `tabindex="0"`로 키보드 접근 제공
- 색 대비, 포커스 링, 기호만 전달하지 않는 대체 텍스트 필요

---

## 15. 성능·최적화

- **DOM 노드 수 최소화**: 수천 개 이상의 요소는 성능 저하. 복잡한 점·라인은 **Canvas**로 레이어링.
- **공통 도형은 `<symbol>`/`<use>`로 재사용**
- **SVGO**로 불필요한 속성/소수점/공백 제거
- **Path 단순화**: 포인트 수 감소
- **CSS 애니메이션→GPU 친화 속성**(opacity/transform) 우선
- **큰 이미지/필터/블러**는 성능 비용 큼

---

## 16. 보안·신뢰 경계

- SVG는 XML이므로 **스크립트 삽입 가능**. 외부에서 받은 SVG는 반드시 **정적 서빙**하거나 **서버 측 Sanitization**(예: DOMPurify + SVG 허용 리스트) 수행.
- **CSP(Content-Security-Policy)**로 인라인 스크립트 차단, `img-src/object-src` 제어.
- 교차 출처 `<use>`/`<image>`는 **CORS 정책** 영향.

---

## 17. SVG vs Canvas — 실무 선택 가이드

| 항목 | SVG | Canvas |
|---|---|---|
| 렌더링 | 벡터(도형) | 비트맵(픽셀) |
| 확대 품질 | 선명 | 픽셀화 |
| 접근성 | DOM/ARIA 가능 | 직접 구현 필요 |
| 이벤트 | 요소 단위 | 좌표 기반 수작업 |
| 애니메이션 | CSS/JS/SMIL | JS 프레임 루프 |
| 대량 오브젝트 | DOM 부담 큼 | 강함 |
| 대표 용도 | 아이콘, 다이어그램, 지도 오버레이, 인포그래픽, 인터랙티브 UI | 게임, 페인팅, 대량 산점도, 이미지 처리 |

**하이브리드**: 바탕은 Canvas, 레이블/상호작용 요소는 SVG로 오버레이.

---

## 18. 실전 예제 1 — 네트워크 그래프(노드 강조/마커/툴팁)

```html
<style>
  .node { fill:#fff; stroke:#333; stroke-width:1; }
  .node.active { fill:#ffd; stroke:#c80; }
  .edge { stroke:#999; stroke-width:2; marker-end:url(#arrow); }
  .label { font:12px/1.2 sans-serif; pointer-events:none; }
  #tip { position:absolute; padding:6px 8px; background:#333; color:#fff; font:12px sans-serif; border-radius:4px; display:none; }
</style>

<div style="position:relative">
  <div id="tip"></div>
  <svg id="graph" viewBox="0 0 600 360" width="100%" height="360">
    <defs>
      <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto">
        <path d="M0 0 L10 5 L0 10 z" fill="#999"/>
      </marker>
    </defs>

    <g id="edges">
      <line class="edge" x1="120" y1="100" x2="300" y2="160"/>
      <line class="edge" x1="300" y1="160" x2="480" y2="90"/>
      <line class="edge" x1="120" y1="100" x2="200" y2="260"/>
      <line class="edge" x1="200" y1="260" x2="480" y2="90"/>
    </g>

    <g id="nodes">
      <g class="n" data-name="A" transform="translate(120,100)">
        <circle class="node" r="18"/><text class="label" text-anchor="middle" y="4">A</text>
      </g>
      <g class="n" data-name="B" transform="translate(300,160)">
        <circle class="node" r="18"/><text class="label" text-anchor="middle" y="4">B</text>
      </g>
      <g class="n" data-name="C" transform="translate(480,90)">
        <circle class="node" r="18"/><text class="label" text-anchor="middle" y="4">C</text>
      </g>
      <g class="n" data-name="D" transform="translate(200,260)">
        <circle class="node" r="18"/><text class="label" text-anchor="middle" y="4">D</text>
      </g>
    </g>
  </svg>
</div>

<script>
const tip = document.getElementById('tip');
const svg = document.getElementById('graph');

svg.addEventListener('mousemove', e => {
  const t = e.target.closest('.n');
  document.querySelectorAll('.n .node').forEach(el => el.classList.remove('active'));
  if (t) {
    t.querySelector('.node').classList.add('active');
    tip.style.display = 'block';
    tip.textContent = '노드: ' + t.dataset.name;
    tip.style.left = e.clientX + 12 + 'px';
    tip.style.top  = e.clientY + 12 + 'px';
  } else {
    tip.style.display = 'none';
  }
});
</script>
```

- 이벤트 위임으로 노드 활성화/툴팁 표시
- 화살표 마커 재사용

---

## 19. 실전 예제 2 — 동적 게이지(대시 애니메이션 + 그라디언트)

```html
<svg viewBox="0 0 200 120" width="360">
  <defs>
    <linearGradient id="g" x1="0" y1="1" x2="1" y2="0">
      <stop offset="0%" stop-color="#4caf50"/>
      <stop offset="100%" stop-color="#f44336"/>
    </linearGradient>
  </defs>
  <path id="arc" d="M20 100 A80 80 0 0 1 180 100" fill="none" stroke="#eee" stroke-width="14" stroke-linecap="round"/>
  <path id="val" d="M20 100 A80 80 0 0 1 180 100" fill="none" stroke="url(#g)" stroke-width="14" stroke-linecap="round"/>
  <text id="tx" x="100" y="90" text-anchor="middle" font-size="18" font-family="system-ui">0%</text>
</svg>

<script>
const val = document.getElementById('val');
const tx  = document.getElementById('tx');
const len = val.getTotalLength();
val.style.strokeDasharray = len;
val.style.strokeDashoffset = len;

function update(pct){ // 0..100
  const off = len * (1 - pct/100);
  val.style.transition = 'stroke-dashoffset 800ms ease';
  val.style.strokeDashoffset = off;
  tx.textContent = Math.round(pct) + '%';
}
update(72);
</script>
```

---

## 20. Canvas와의 연동(하이브리드)

SVG를 **Canvas로 래스터화**해 성능을 확보하거나 다운로드 이미지로 변환합니다.

```html
<svg id="chart" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 120" width="300">
  <circle cx="100" cy="60" r="50" fill="#aef"/>
</svg>
<canvas id="cv" width="300" height="180" style="border:1px solid #ddd"></canvas>
<script>
const svg = document.getElementById('chart');
const can = document.getElementById('cv');
const ctx = can.getContext('2d');

const svgBlob = new Blob([svg.outerHTML], { type: 'image/svg+xml;charset=utf-8' });
const url = URL.createObjectURL(svgBlob);
const img = new Image();
img.onload = () => { ctx.drawImage(img, 0, 0, can.width, can.height); URL.revokeObjectURL(url); };
img.src = url;
</script>
```

---

## 21. 빌드·툴링·배포 체크리스트

- **SVGO**: path 단순화, 불필요 속성 제거, 정규화
- **스프라이트**: 다수 아이콘을 하나의 스프라이트로 묶기
- **압축**: SVG는 텍스트라 **Gzip/Brotli**로 훌륭히 압축됨
- **CSP**: `img-src`/`object-src`/`script-src` 정책 점검
- **동일 출처**: `<use>` 외부 참조, `<image>` CORS 정책 확인
- **이메일/앱 내 WebView**: `<foreignObject>`/필터/SMIL 지원 제약

---

## 22. 디버깅·테스트 팁

- 경로 시각화: `stroke-dasharray`, `marker-mid`로 제어점/방향 표시
- `getBBox()` vs `getBoundingClientRect()`: 좌표계 차이 인지
- 뷰박스 확인: 경계 사각형을 임시로 그려 보정
- 접근성: 스크린리더 확인, 키보드 포커스 이동, 색 대비 검사

---

## 결론

- **SVG**는 아이콘, 로고, 다이어그램, 지도 오버레이, 데이터 시각화 등 **의미 있는 그래픽**과 **상호작용**에 최적입니다.
- **Canvas**는 대량 픽셀 연산, 게임, 페인팅 등 **고빈도 갱신**에 적합합니다.
- 실무에서는 **SVG와 Canvas를 혼합**하여 각 장점(접근성·상호작용 vs 성능·대량 처리)을 취하는 설계가 가장 강력합니다.
