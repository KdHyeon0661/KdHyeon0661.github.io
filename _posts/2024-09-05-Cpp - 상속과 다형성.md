---
layout: post
title: C++ - 상속과 다형성
date: 2024-09-05 19:20:23 +0900
category: Cpp
---
# C++ 상속과 다형성

## 한눈에 보는 핵심

- **상속**: 기존 클래스의 특성을 이어받아 새로운 클래스를 정의하는 방법으로, 코드 재사용과 계층적 구조를 만듭니다.
- **다형성**: 하나의 인터페이스로 여러 형태의 객체를 처리할 수 있는 능력으로, 런타임에 실제 객체 타입에 맞는 동작을 실행합니다.
- **핵심 도구**: 가상 함수(`virtual`), 가상 소멸자, `override`와 `final` 지정자
- **안전한 사용**: 원시 포인터 대신 스마트 포인터 사용, 객체 슬라이싱 방지, 명확한 인터페이스 설계

---

## 상속(Inheritance): 문법과 의미

### 상속의 기본 구조

```cpp
class Animal {
public:
    void breathe() { std::cout << "숨을 쉰다\n"; }
};

class Dog : public Animal {  // public 상속: Dog IS-A Animal
public:
    void bark() { std::cout << "멍멍!\n"; }
};

int main() {
    Dog d;
    d.breathe();  // 상속받은 메서드
    d.bark();     // 자신의 메서드
}
```

**상속 접근 제어자**:
- `public`: IS-A 관계 모델링 (가장 일반적)
- `protected`/`private`: 구현 재사용 목적 (드물게 사용)

### 접근 제어의 의미

| 접근 지정자 | 접근 가능 범위 |
|------------|---------------|
| `public` | 모든 곳에서 접근 가능 (외부 인터페이스) |
| `protected` | 파생 클래스와 친구 클래스에서만 접근 |
| `private` | 해당 클래스 내부에서만 접근 (캡슐화) |

---

## 다형성(Polymorphism): 가상 함수의 힘

### 동적 바인딩 구현

```cpp
class Shape {
public:
    virtual void draw() const { std::cout << "기본 도형\n"; }
    virtual ~Shape() = default;  // 반드시 필요!
};

class Circle : public Shape {
public:
    void draw() const override { std::cout << "원 그리기\n"; }
};

class Square : public Shape {
public:
    void draw() const override { std::cout << "사각형 그리기\n"; }
};

void render(const Shape& shape) {
    shape.draw();  // 실제 객체 타입에 따라 동작
}

int main() {
    Circle c;
    Square s;
    render(c);  // "원 그리기"
    render(s);  // "사각형 그리기"
}
```

**핵심 메커니즘**:
- 가상 함수 테이블(vtable)을 통해 런타임에 함수 호출 결정
- 가상 소멸자가 없으면 파생 클래스의 소멸자가 호출되지 않아 메모리 누수 발생

### 안전성을 높이는 `override`와 `final`

```cpp
class Base {
public:
    virtual void process(int value) {}
    virtual void essential() final {}  // 더 이상 재정의 불가
};

class Derived : public Base {
public:
    void process(int value) override {}  // 의도 명시, 실수 방지
    // void essential() override {}  // 컴파일 오류!
};
```

---

## 추상 클래스와 순수 가상 함수

```cpp
class DatabaseConnector {
public:
    virtual void connect() = 0;      // 순수 가상 함수
    virtual void disconnect() = 0;   // 인터페이스 정의
    virtual ~DatabaseConnector() = default;
};

class MySQLConnector : public DatabaseConnector {
public:
    void connect() override { /* MySQL 연결 구현 */ }
    void disconnect() override { /* 연결 해제 구현 */ }
};
```

**특징**:
- 순수 가상 함수가 하나라도 있으면 추상 클래스
- 직접 인스턴스화 불가능, 파생 클래스에서 반드시 구현해야 함
- 인터페이스 계약을 명확히 정의하는 역할

---

## 다형성 사용 패턴과 주의사항

### 올바른 객체 전달 방식

```cpp
class Base { /* ... */ };
class Derived : public Base { /* ... */ };

// ❌ 잘못된 사용: 객체 슬라이싱 발생
void processByValue(Base obj) {
    // Derived의 정보 손실!
}

// ✅ 올바른 사용: 참조나 포인터 사용
void processByReference(Base& obj) {
    // 다형성 유지
}

void processByPointer(Base* obj) {
    if (obj) obj->doSomething();  // 널 체크 필수
}
```

### 스마트 포인터와 소유권 관리

```cpp
#include <memory>
#include <vector>

class Document {
public:
    virtual void save() const = 0;
    virtual std::unique_ptr<Document> clone() const = 0;
    virtual ~Document() = default;
};

class TextDocument : public Document {
public:
    std::unique_ptr<Document> clone() const override {
        return std::make_unique<TextDocument>(*this);
    }
};

class DocumentManager {
    std::vector<std::unique_ptr<Document>> documents;
public:
    void addDocument(std::unique_ptr<Document> doc) {
        documents.push_back(std::move(doc));
    }
};
```

---

## NVI 패턴: 안정적인 재정의 지점 제공

```cpp
class DataProcessor {
public:
    // 공개 인터페이스: 비가상 함수
    void process() {
        validate();      // 전처리 (공통 로직)
        doProcess();     // 가상 함수 (파생 클래스 구현)
        cleanup();       // 후처리 (공통 로직)
    }
    
    virtual ~DataProcessor() = default;

private:
    virtual void doProcess() = 0;  // 실제 작업 (파생 클래스 구현)
    
    void validate() { /* 공통 검증 로직 */ }
    void cleanup() { /* 공통 정리 로직 */ }
};
```

**장점**: 파생 클래스가 특정 부분만 재정의하면서도 전체 흐름은 통제 가능

---

## 다중 상속과 가상 상속

### 인터페이스 다중 상속

```cpp
class Drawable {
public:
    virtual void draw() const = 0;
    virtual ~Drawable() = default;
};

class Serializable {
public:
    virtual std::string serialize() const = 0;
    virtual ~Serializable() = default;
};

class Widget : public Drawable, public Serializable {
    // 두 인터페이스 모두 구현
};
```

### 다이아몬드 문제와 가상 상속

```cpp
class CommonBase {
public:
    int sharedData;
};

class MiddleA : virtual public CommonBase {};
class MiddleB : virtual public CommonBase {};

class FinalClass : public MiddleA, public MiddleB {
    // CommonBase는 한 번만 상속됨
};
```

**주의**: 가상 상속은 복잡성 증가 → 꼭 필요한 경우에만 사용

---

## 설계 원칙과 모던 C++ 접근법

### LSP (리스코프 치환 원칙)

파생 클래스는 기반 클래스를 완전히 대체할 수 있어야 합니다. 기반 클래스의 계약(예외 사양, 전제조건, 사후조건)을 약화시키지 않아야 합니다.

### 조합(Composition) 우선 원칙

```cpp
// 상속보다 조합을 우선
class Engine {
public:
    void start() { /* 엔진 시작 */ }
};

class Car {
private:
    Engine engine;  // 조합
public:
    void start() { engine.start(); }
};
```

**장점**: 더 유연하고 테스트하기 쉬우며, 클래스 간 결합도가 낮음

---

## 성능 고려사항과 대안

### 가상 함수의 비용

가상 함수 호출은 간접 호출(indirect call)로, 일반 함수 호출보다 약간의 오버헤드가 있습니다. 매우 성능에 민감한 루프에서는 고려해야 합니다.

### 정적 다형성: CRTP

```cpp
template<typename Derived>
class BaseCRTP {
public:
    void interface() {
        static_cast<Derived*>(this)->implementation();
    }
};

class Concrete : public BaseCRTP<Concrete> {
public:
    void implementation() {
        // 구체적 구현
    }
};
```

**장점**: 가상 함수 오버헤드 없이 다형성 구현, 인라인 최적화 가능

---

## 실전 예제: 그래픽 시스템 설계

```cpp
#include <memory>
#include <vector>
#include <iostream>

// 인터페이스
class Graphic {
public:
    virtual void render() const = 0;
    virtual std::unique_ptr<Graphic> clone() const = 0;
    virtual ~Graphic() = default;
};

// 구체 클래스
class Circle : public Graphic {
    double radius;
public:
    explicit Circle(double r) : radius(r) {}
    
    void render() const override {
        std::cout << "원 렌더링 (반지름: " << radius << ")\n";
    }
    
    std::unique_ptr<Graphic> clone() const override {
        return std::make_unique<Circle>(*this);
    }
};

// 컴포지트 패턴
class CompositeGraphic : public Graphic {
    std::vector<std::unique_ptr<Graphic>> children;
public:
    void add(std::unique_ptr<Graphic> graphic) {
        children.push_back(std::move(graphic));
    }
    
    void render() const override {
        for (const auto& child : children) {
            child->render();
        }
    }
    
    std::unique_ptr<Graphic> clone() const override {
        auto clone = std::make_unique<CompositeGraphic>();
        for (const auto& child : children) {
            clone->add(child->clone());
        }
        return clone;
    }
};
```

---

## 방문자 패턴: 확장 가능한 연산 추가

```cpp
class Circle;
class Rectangle;

class ShapeVisitor {
public:
    virtual void visit(Circle&) = 0;
    virtual void visit(Rectangle&) = 0;
    virtual ~ShapeVisitor() = default;
};

class Shape {
public:
    virtual void accept(ShapeVisitor& visitor) = 0;
    virtual ~Shape() = default;
};

class Circle : public Shape {
public:
    void accept(ShapeVisitor& visitor) override {
        visitor.visit(*this);
    }
};

class AreaCalculator : public ShapeVisitor {
public:
    void visit(Circle& c) override {
        std::cout << "원 면적 계산\n";
    }
    void visit(Rectangle& r) override {
        std::cout << "사각형 면적 계산\n";
    }
};
```

---

## 주의사항과 모범 사례

### 자주 발생하는 실수들

1. **가상 소멸자 누락**: 다형적 기반 클래스에는 반드시 가상 소멸자를 선언하세요.
2. **객체 슬라이싱**: 다형적 객체는 값으로 전달하지 말고 참조나 포인터로 전달하세요.
3. **불필요한 다중 상속**: 인터페이스 상속이 목적이 아니라면 조합을 고려하세요.
4. **`override` 지정자 생략**: 재정의 의도를 명확히 하고 실수를 방지하기 위해 항상 사용하세요.
5. **원시 포인터 사용**: 메모리 관리는 `std::unique_ptr`이나 `std::shared_ptr`에 맡기세요.

### 디버깅과 테스트 팁

- 가상 함수 재정의 실수는 `-Winconsistent-missing-override` 플래그로 검출
- 메모리 문제는 AddressSanitizer(`-fsanitize=address`)로 검증
- 다형성 테스트는 모의 객체(Mock)를 활용한 단위 테스트로 진행

---

## 결론: 현명한 상속과 다형성 사용법

C++에서 상속과 다형성은 강력한 도구이지만, 신중하게 사용해야 합니다. 다음과 같은 원칙을 기억하세요:

1. **목적에 맞게 사용**: IS-A 관계가 명확할 때만 상속을 사용하고, 구현 재사용만 필요하다면 조합을 선택하세요.
2. **인터페이스 설계에 집중**: 추상 클래스로 명확한 계약을 정의하고, 구현 세부사항은 숨기세요.
3. **안전성 우선**: 가상 소멸자, `override`, 스마트 포인터를 통해 리소스 관리와 타입 안전성을 보장하세요.
4. **성능 고려**: 성능이 중요한 부분에서는 CRTP나 템플릿 기반 정적 다형성을 고려하세요.
5. **테스트 용이성**: 다형적 코드는 모의 객체를 활용해 쉽게 테스트할 수 있도록 설계하세요.

올바르게 사용된 상속과 다형성은 코드의 유연성, 재사용성, 유지보수성을 크게 향상시킵니다. 하지만 이러한 이점은 신중한 설계와 원칙 준수에서 비롯됨을 명심하세요. 모던 C++의 기능들을 활용하여 안전하고 효율적인 객체지향 설계를 구현해 보시기 바랍니다.