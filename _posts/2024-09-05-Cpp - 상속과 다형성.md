---
layout: post
title: C++ - 상속과 다형성
date: 2024-09-05 19:20:23 +0900
category: Cpp
---
# C++ 상속과 다형성

## 0. 한눈에 보는 핵심

- **상속**: 기존 타입(기반 클래스)의 인터페이스/구현을 **재사용/확장**.
- **다형성(동적 바인딩)**: **기반 클래스 포인터/참조**로 파생 클래스의 **재정의된 동작**을 호출.  
- **요건**: 가상 함수(`virtual`), **가상 소멸자**, `override`·`final`로 의도 명시.  
- **소유/수명**: 원시 포인터 대신 **`std::unique_ptr<Base>`** 사용(누수/이중 해제 방지).  
- **설계 원칙**: LSP, NVI, 조합(Composition) 우선, 다중 상속 최소화(필요시 **가상 상속**).

---

## 1. 상속(Inheritance)의 문법과 의미

### 1.1 상속 기본형

```cpp
class Base {
public:
    void eat() { std::cout << "먹는 중...\n"; } // 비가상 함수
};

class Dog : public Base { // public 상속: IS-A 관계
public:
    void bark() { std::cout << "멍멍!\n"; }
};

int main(){
    Dog d;
    d.eat();  // Base의 공개 멤버 사용
    d.bark(); // Dog 고유 기능
}
```

> **상속 방식**: `public` / `protected` / `private`  
> 대부분 **`public` 상속**(IS-A 모델링)에 한정해 사용. 나머지는 구현 세부화 용도로 드물게 사용.

### 1.2 접근 제어 요약

| 멤버 접근자 | 의미 |
|---|---|
| `public` | 어디서나 접근 가능 (인터페이스) |
| `protected` | 파생/친구에서만 접근 (확장 지점) |
| `private` | 클래스 내부에서만 (캡슐화) |

> **규칙**: 공개 API는 `public`, 확장을 의도한 내부 구현 훅은 `protected`, 나머지는 `private`.

---

## 2. 다형성(Polymorphism)과 가상 함수

### 2.1 가상 함수로 동적 바인딩

```cpp
#include <iostream>
struct Animal {
    virtual void sound() { std::cout << "동물 소리\n"; } // 가상
    virtual ~Animal() = default; // 가상 소멸자 (매우 중요)
};
struct Dog : Animal {
    void sound() override { std::cout << "멍멍!\n"; }
};
struct Cat : Animal {
    void sound() override { std::cout << "야옹~\n"; }
};
int main(){
    Animal* a1 = new Dog;
    Animal* a2 = new Cat;
    a1->sound(); // 멍멍!
    a2->sound(); // 야옹~
    delete a1;   // 가상 소멸자로 올바른 소멸
    delete a2;
}
```

- **런타임**에 실제 객체 타입의 **vtable**을 따라 호출(동적 디스패치).
- **가상 소멸자** 없이는 `delete Base*`가 파생 소멸자를 호출하지 않아 **자원 누수**.

> 시간 복잡도는 보통 $$\mathcal{O}(1)$$ 디스패치(간접 호출 1회).

### 2.2 `override` / `final`로 안전성 강화

```cpp
struct Base {
    virtual void f(int){}
    virtual void g() final {} // 더 이상 파생에서 재정의 금지
};
struct Derived : Base {
    void f(int) override {}   // 시그니처 불일치시 컴파일 에러
    // void g() override {}    // 에러: final
};
```

---

## 3. 순수 가상 함수와 추상 클래스(Interface)

```cpp
struct Shape {
    virtual void draw() = 0; // 순수 가상 → 추상 클래스
    virtual ~Shape() = default;
};
struct Circle : Shape {
    void draw() override { std::cout<<"원을 그립니다.\n"; }
};
```

- **추상 클래스**는 **직접 인스턴스화 불가**. **공통 인터페이스**를 정의.
- 파생에서 **반드시 구현**해야 하는 계약을 명확히 표현.

---

## 4. 다형성 사용 패턴 — 포인터/참조/스마트 포인터

### 4.1 함수 인자/반환

```cpp
void render(Shape& s) { s.draw(); }              // 참조 기반
void render_ptr(const Shape* s){ if(s) s->draw(); } // 널 허용

#include <memory>
void add(std::unique_ptr<Shape> shp); // 소유권 이전
std::unique_ptr<Shape> make_circle(); // 소유권 반환
```

- **비소유 호출**: `Shape&`(널 불가) / `Shape*`(널 가능, 널 체크 필수)  
- **소유권 경계**: `std::unique_ptr<Shape>`로 명확히.

### 4.2 객체 슬라이싱(Object Slicing) 회피

```cpp
struct B { virtual ~B()=default; };
struct D : B { int x=42; };

void bad(B b) {}            // ❌ 복사 시 B 부분만 남아 D 정보 "슬라이스"
void good(B& b) {}          // ✅ 참조/포인터로 다형성 유지
```

---

## 5. 복사·이동·복제 — 다형성에서의 규약

### 5.1 복제(clone) 가상 함수 관용구

```cpp
#include <memory>
struct Base {
    virtual ~Base() = default;
    virtual std::unique_ptr<Base> clone() const = 0;
};
struct Derived : Base {
    int value{};
    std::unique_ptr<Base> clone() const override {
        return std::make_unique<Derived>(*this); // 복사 기반
    }
};
```

- 다형 객체를 **값처럼 복제**해야 한다면 `clone()`을 제공(복사 생성자의 다형 대용).
- 복사/이동 연산은 **기반에서 삭제**하고 `clone`만 허용하는 것도 방법.

---

## 6. NVI(Non-Virtual Interface) — 안정적인 재정의 지점

```cpp
struct Algo {
    void run(){ // public 비가상, 호출 규약/검증/락 처리 등 공통 로직
        pre(); step(); post();
    }
private:
    void pre(){ /*검증/로깅*/ }
    virtual void step() = 0; // 파생이 구현
    void post(){ /*정리*/ }
};
```

- 외부는 **비가상 public**만 호출 → 내부 계약/검증을 **강제**하고 재정의 지점을 **통제**.

---

## 7. RTTI: `dynamic_cast` / `typeid` (필요 최소한으로)

```cpp
struct B{ virtual ~B()=default; };
struct D: B { void only_in_d(){} };

void f(B* pb){
    if(auto pd = dynamic_cast<D*>(pb)){
        pd->only_in_d(); // 안전 다운캐스트
    }
}
```

- 다운캐스트는 **LSP 위반 가능성**. 설계상 **가상 함수**로 다형 행위를 노출하는 편이 바람직.
- 성능/복잡성 고려해 최소화.

---

## 8. 다중 상속과 가상 상속

### 8.1 다중 상속 기본

```cpp
struct Printable { virtual void print() const = 0; virtual ~Printable()=default; };
struct Serializable { virtual std::string save() const = 0; virtual ~Serializable()=default; };

struct User : Printable, Serializable {
    void print() const override { std::cout << "user\n"; }
    std::string save() const override { return "data"; }
};
```

- **순수 인터페이스의 다중 상속**은 비교적 안전(데이터 멤버가 없는 경우).

### 8.2 다이아몬드 문제 & 가상 상속

```cpp
struct Base { int id{0}; };
struct L : virtual Base {}; // 가상 상속
struct R : virtual Base {};
struct X : L, R { void set(int v){ id = v; } }; // Base가 한 번만 존재
```

- 가상 상속으로 **공통 기반의 중복**을 제거.  
- 단, **복잡성/비용**이 증가 → 꼭 필요할 때만.

---

## 9. 설계 원칙과 조합(Composition)

- **LSP (리스코프 치환 원칙)**: 파생은 항상 기반처럼 행동해야 한다.  
  위반 사례: 기반 계약을 약화시키거나 예외 사양/전제조건을 바꾸는 재정의.
- **조합 우선(Composition over Inheritance)**:  
  구현 재사용만이 목적이라면 **상속 대신 멤버로 합성**.

```cpp
struct Engine { void step(); };
struct Car {
    Engine eng;          // 조합
    void run(){ eng.step(); }
};
```

---

## 10. 성능/메모리/스레드 — 다형성의 비용과 관리

- 가상 호출은 **간접 분기 1회 + 예측 미스 가능** → **핫 루프**에서는 비용 고려.  
  대안: **CRTP(정적 다형성)**, **전략 객체를 템플릿 파라미터화**.
- **객체 크기**: vptr(가상 테이블 포인터) 오버헤드(플랫폼 의존) 존재.
- **동시성**: 공유 파생 객체에 **불변성** 적용 또는 **락/원자성** 고려.

---

## 11. 정적 다형성: CRTP (Curiously Recurring Template Pattern)

```cpp
template <typename Derived>
struct BaseCRTP {
    void run(){ static_cast<Derived*>(this)->step(); } // 정적 디스패치
};
struct Impl : BaseCRTP<Impl> {
    void step(){ std::cout<<"CRTP\n"; }
};
int main(){ Impl{}.run(); } // 가상 비용 없이 최적화 가능
```

- **컴파일 타임 바인딩**, 인라이닝 기대.  
- 런타임 교체 가능성이 없을 때 유리.

---

## 12. 공변 반환형(Covariant Return)과 `final` 클래스

```cpp
struct B { virtual B* clone() const = 0; virtual ~B()=default; };
struct D : B {
    D* clone() const override { return new D(*this); } // 반환형 공변 허용
};
```

- 파생에서 **더 구체적 타입으로 반환** 가능(포인터/참조에 한함).  
- **`final` 클래스**: 더 이상 파생 불가 → 가상 디스패치 제거 최적화가 가능할 때도.

---

## 13. 예외/소멸/이동 — 안전한 베이스 설계

- **항상 가상 소멸자**(폴리모픽 베이스).  
- 베이스에서 **복사/이동 금지**하고 `clone` 제공, 또는 **Rule of Zero**(자원은 스마트 포인터/컨테이너에게).
- **noexcept** 지정: 소멸자/이동 생성자 등에 명시해 강한 예외 보증 달성.

```cpp
struct Poly {
    virtual ~Poly() noexcept = default; // noexcept
    Poly(const Poly&)            = delete;
    Poly& operator=(const Poly&) = delete;
    Poly(Poly&&)                 = default;
    Poly& operator=(Poly&&)      = default;
};
```

---

## 14. 실전 예제 — 렌더러 파이프라인 (전략 + 다형성 + NVI)

> 요구: `Renderer`가 다양한 `Shape`를 받아 그리는 파이프라인.  
> 포인트: **추상 인터페이스**, **스마트 포인터**, **NVI**, **전략 바꿔 끼우기**.

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <string>

struct Shape {
    virtual void draw() const = 0;
    virtual std::unique_ptr<Shape> clone() const = 0;
    virtual ~Shape() = default;
};

struct Circle : Shape {
    int r;
    explicit Circle(int rr): r(rr){}
    void draw() const override { std::cout << "Circle r="<<r<<"\n"; }
    std::unique_ptr<Shape> clone() const override {
        return std::make_unique<Circle>(*this);
    }
};

struct Rect : Shape {
    int w,h;
    Rect(int w_,int h_): w(w_),h(h_){}
    void draw() const override { std::cout << "Rect "<<w<<"x"<<h<<"\n"; }
    std::unique_ptr<Shape> clone() const override {
        return std::make_unique<Rect>(*this);
    }
};

struct DrawStrategy {
    virtual ~DrawStrategy() = default;
private:
    // NVI: 외부는 draw_all만 호출
    friend struct Renderer;
    virtual void draw_impl(const std::vector<std::unique_ptr<Shape>>& v) = 0;
};

struct ConsoleStrategy : DrawStrategy {
private:
    void draw_impl(const std::vector<std::unique_ptr<Shape>>& v) override {
        for (auto& s : v) s->draw();
    }
};

struct Renderer {
    std::vector<std::unique_ptr<Shape>> shapes;
    std::unique_ptr<DrawStrategy> strat;

    explicit Renderer(std::unique_ptr<DrawStrategy> ds)
        : strat(std::move(ds)) {}

    void add(const Shape& s){ shapes.emplace_back(s.clone()); } // 다형 복제
    void draw_all(){ strat->draw_impl(shapes); }                // NVI 외부 표면
};

int main(){
    Renderer r{ std::make_unique<ConsoleStrategy>() };
    r.add(Circle{5});
    r.add(Rect{2,3});
    r.draw_all();
}
```

- **소유권 모델**: `Renderer`가 `Shape`들을 **소유**(`unique_ptr`), 외부는 값처럼 추가(`clone`).
- **전략 변경 가능**: `DrawStrategy` 교체로 출력/백엔드 분리.

---

## 15. 방문자(Visitor) — 런타임 다형성과 더블 디스패치

```cpp
#include <iostream>
#include <memory>
#include <vector>

struct Circle; struct Rect;

struct Visitor {
    virtual void visit(const Circle&) = 0;
    virtual void visit(const Rect&)   = 0;
    virtual ~Visitor() = default;
};

struct Shape {
    virtual void accept(Visitor&) const = 0;
    virtual ~Shape() = default;
};

struct Circle : Shape {
    int r{};
    void accept(Visitor& v) const override { v.visit(*this); }
};
struct Rect : Shape {
    int w{}, h{};
    void accept(Visitor& v) const override { v.visit(*this); }
};

struct AreaCalc : Visitor {
    void visit(const Circle& c) override {
        double area = 3.14159 * c.r * c.r;
        std::cout << "Circle area=" << area << "\n";
    }
    void visit(const Rect& r) override {
        std::cout << "Rect area=" << (r.w * r.h) << "\n";
    }
};

int main(){
    std::vector<std::unique_ptr<Shape>> v;
    v.emplace_back(std::make_unique<Circle>(Circle{5}));
    v.emplace_back(std::make_unique<Rect>(Rect{2,3}));

    AreaCalc calc;
    for(auto& s : v) s->accept(calc);
}
```

- 새로운 연산(방문자) 추가가 쉬움. 새로운 도형 타입 추가는 모든 방문자 수정 필요(트레이드오프).

---

## 16. 테스트·디버깅·툴링

- **가상 호출 경로 확인**: `override` 누락/시그니처 오타를 컴파일 타임에 잡기.
- **Sanitizer**: ASan/UBSan/TSan으로 수명/경합 검출.
- **정적 분석**: clang-tidy(“virtual-call-in-ctor”, “modernize-use-override” 등).

---

## 17. 자주 하는 실수 & 예방 체크리스트

- [ ] 폴리모픽 베이스에 **가상 소멸자 누락** → `delete Base*` UB/누수  
- [ ] **객체 슬라이싱**: 다형 대상은 **참조/포인터**로 전달  
- [ ] `override` 누락 → 오타/시그니처 불일치가 **새 함수 추가**로 바인딩  
- [ ] **스마트 포인터 미사용** → 예외/조기 리턴에서 누수  
- [ ] **RTTI 남발** → 다운캐스트 없이 **가상 함수로 행위를 추상화**  
- [ ] **다중 상속 남용** → 인터페이스 상속에 한정, 공통 베이스는 **가상 상속** 고려  
- [ ] **스레드 안전성 무시** → 공유 상태 캡슐화/불변성 또는 동기화  
- [ ] **성능 민감 구간**에서 가상 호출 과다 → CRTP/전략을 템플릿화

---

## 18. 수학으로 보는 다형 호출의 비용(개념적)

가상 호출의 기대 비용을 단순화해 보면,
$$
T_{\text{virtual}} \approx T_{\text{indirect\_branch}} + T_{\text{icache/predict\_miss}} + T_{\text{func}}
$$
- **핫 경로**에서 예측 미스가 반복되면 성능 저하 → **정적 다형성/인라인** 대안 고려.

---

## 19. 미니 퀴즈 (빠른 자가 점검)

1) 왜 **가상 소멸자**가 필요한가?  
2) `override`의 이점은?  
3) **객체 슬라이싱**은 어떻게 발생하며 어떻게 막나?  
4) **방문자 패턴**의 장단점은?  
5) **CRTP**는 언제 유리한가?

---

## 20. 요약

- **상속**은 인터페이스 공유, **다형성**은 행위 교체.  
- **가상 함수 + 가상 소멸자 + override/final**은 안전하고 의도가 분명한 다형성의 기본.  
- 소유권과 수명은 **스마트 포인터**로, 값 의미의 복제는 **`clone()` 가상화**로.  
- 복잡한 계층보다 **조합/전략/NVI/CRTP** 등으로 단순하고 테스트 가능한 설계를 지향.

---

# 부록 A) 비교 표 — 상속/조합/전략

| 기법 | 장점 | 단점 | 사용 가이드 |
|---|---|---|---|
| 상속 + 가상 | 런타임 교체/플러그 가능 | 가상 비용, 결합도↑ | 공개 인터페이스/플러그인 |
| 조합 | 결합↓, 테스트 쉬움 | 위임 코드 필요 | 구현 재사용 위주 |
| 전략(런타임) | 정책 분리·교체 쉬움 | 간접 호출 비용 | 동적 교체 필요 시 |
| 전략(템플릿) | 인라인/제로오버헤드 | 바이너리 팽창 | 성능 최우선 시 |
| CRTP | 정적 다형성 | 문법 난이도 | 핫루프/고성능 |

---

# 부록 B) 컴파일 스니펫

```bash
g++ -std=c++20 -O2 -Wall -Wextra -Werror -pedantic main.cpp -o app
```

---

# 부록 C) 한 장 체크리스트

- [ ] 베이스 **가상 소멸자** / 파생 `override`  
- [ ] **소유는 unique_ptr**, 인터페이스는 참조/포인터  
- [ ] **슬라이싱 금지**(참조/포인터 전달)  
- [ ] **NVI**로 재정의 지점 통제, **LSP** 점검  
- [ ] 다운캐스트 대신 **가상 함수 확장**  
- [ ] 다중 상속은 **인터페이스 한정** + 필요시 **가상 상속**  
- [ ] 성능 고려: **CRTP/템플릿 전략** 검토  
- [ ] 정적 분석/샌리/테스트로 회귀 방지