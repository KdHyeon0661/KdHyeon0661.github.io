---
layout: post
title: JavaScript - 브라우저 저장소
date: 2025-05-13 21:20:23 +0900
category: JavaScript
---
# 브라우저 저장소 완전 정리: localStorage, sessionStorage, cookie

## 1. 핵심 요약 & 선택 가이드

### 1.1 언제 무엇을 쓰나?

| 목적/상황 | 권장 저장소 | 비고 |
|---|---|---|
| 테마/뷰 모드/간단 환경설정 | **localStorage** | 영구(사용자 삭제 전까지), HTTP 전송 없음 |
| 탭 단위 임시 상태(위저드 진행률 등) | **sessionStorage** | 탭·창 닫으면 소멸 |
| 인증 세션(세션 ID/리프레시 토큰) | **쿠키(HttpOnly+Secure+SameSite)** | 서버 설정, 자동 전송 |
| 액세스 토큰(짧은 수명) | **메모리(변수)** | XSS 완화, 새로고침 취약성은 리프레시 토큰로 해결 |
| 대용량/오프라인 캐시 | *(참고)* IndexedDB | 구조화 데이터/파일 |

### 1.2 공통 주의점

- **XSS에 노출**되는 스토리지(local/sessionStorage, JS로 접근 가능한 쿠키)에 **민감 정보(토큰/키)** 저장 금지.
- 쿠키는 **도메인 규칙 + 자동 전송** 특성 때문에 CSRF 고려 필수(→ SameSite·CSRF 토큰).
- `localStorage/sessionStorage`는 **동기 API**라서 **핫패스에서 과도하게 호출하지 말 것**.

---

## 2. localStorage — 영구 키/값 저장

### 2.1 특성

| 항목 | 값 |
|---|---|
| 수명 | 사용자/스크립트가 지우기 전까지 |
| 범위 | **원본(Origin)** 단위 공유(프로토콜+호스트+포트) |
| 용량 | 브라우저별 대략 **5–10MB** |
| 동기/비동기 | **동기** |
| 전송 | HTTP 요청에 **자동 전송 안 됨** |

### 2.2 기본 API

```js
// 저장 (문자열만 저장됨)
localStorage.setItem("user", "Alice");

// 조회
const user = localStorage.getItem("user"); // "Alice" | null

// 존재 확인
const exists = localStorage.getItem("user") !== null;

// 삭제/비우기
localStorage.removeItem("user");
localStorage.clear();
```

> 문자열만 저장되므로 객체는 `JSON.stringify`, `JSON.parse`로 직렬화/역직렬화합니다.

```js
const prefs = { theme: "dark", lang: "ko" };
localStorage.setItem("prefs", JSON.stringify(prefs));

const parsed = JSON.parse(localStorage.getItem("prefs") ?? "{}");
```

### 2.3 에러/성능 팁

- **용량 초과** 시 `QuotaExceededError` 발생 → `try/catch`로 처리.

```js
try {
  localStorage.setItem("heavy", "x".repeat(1024 * 1024 * 6));
} catch (e) {
  if (e?.name === "QuotaExceededError") {
    // LRU 정책으로 일부 키 제거 등
    localStorage.removeItem("cache:old");
  }
}
```

- **동기 블로킹**이라 렌더·핫루프에서 반복 호출 자제. 값이 자주 필요하면 **한 번 읽어 메모리 캐시**.

### 2.4 탭 간 동기화: `storage` 이벤트

```js
// 다른 탭에서 localStorage 변경 시 브로드캐스트됨(같은 origin)
window.addEventListener("storage", (e) => {
  if (e.key === "prefs") {
    const next = JSON.parse(e.newValue ?? "{}");
    applyPrefs(next);
  }
});
```

---

## 3. sessionStorage — 탭/창 생애주기 연동

### 3.1 특성

| 항목 | 값 |
|---|---|
| 수명 | **탭/창 단위**(닫으면 소멸) |
| 범위 | 각 탭의 브라우징 컨텍스트 |
| 용량 | localStorage와 근사 |
| 동기/비동기 | **동기** |
| 전송 | HTTP에 자동 전송 **안 됨** |

### 3.2 사용 예

```js
sessionStorage.setItem("wizardStep", "2");
const step = Number(sessionStorage.getItem("wizardStep") ?? "1");
sessionStorage.removeItem("wizardStep");
```

> 새로고침에는 유지되지만, **탭을 닫거나 새 탭**을 열면 사라집니다.

---

## 4. 쿠키 — 서버와 자동 교환되는 작은 메모

### 4.1 특성

| 항목 | 값 |
|---|---|
| 수명 | `Expires`/`Max-Age`로 제어(세션 쿠키는 브라우저 종료 시) |
| 용량 | **도메인당 수천 바이트(한 쿠키 ~4KB)** |
| 전송 | **같은 도메인/경로/보안 규칙**에 맞으면 **매 요청 자동 전송** |
| 접근 | `document.cookie`(JS, HttpOnly면 접근 불가) / 서버의 `Cookie` 헤더 |

### 4.2 클라이언트에서 설정/읽기(기본)

```js
// 1일 유효, 전체 경로에서 유효
document.cookie = "username=Alice; Max-Age=86400; Path=/";

// 모든 쿠키 문자열(세미콜론 구분)
console.log(document.cookie); // "username=Alice; theme=dark"
```

> `document.cookie`는 파싱이 필요합니다. 헬퍼를 쓰면 편합니다.

```js
const Cookie = {
  set(name, value, { maxAge, expires, path = "/", domain, secure, sameSite } = {}) {
    let c = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
    if (typeof maxAge === "number") c += `; Max-Age=${maxAge}`;
    if (expires instanceof Date) c += `; Expires=${expires.toUTCString()}`;
    if (path) c += `; Path=${path}`;
    if (domain) c += `; Domain=${domain}`;
    if (secure) c += `; Secure`;
    if (sameSite) c += `; SameSite=${sameSite}`; // "Lax" | "Strict" | "None"
    document.cookie = c;
  },
  get(name) {
    const m = document.cookie.match(new RegExp(`(?:^|; )${encodeURIComponent(name)}=([^;]*)`));
    return m ? decodeURIComponent(m[1]) : null;
  },
  del(name, { path = "/", domain } = {}) {
    this.set(name, "", { expires: new Date(0), path, domain });
  },
};
```

### 4.3 서버에서 보안 쿠키 설정(권장)

> **인증 세션/리프레시 토큰**은 **서버가 Set-Cookie로 내려주고**, **HttpOnly + Secure + SameSite**를 사용하세요.

#### (Node/Express 예시)

```js
res.cookie("session", sessionId, {
  httpOnly: true,        // JS에서 접근 불가 → XSS로 탈취 어려움
  secure: true,          // HTTPS에서만 전송
  sameSite: "Lax",       // CSRF 완화(외부 내비게이션/GET은 대부분 차단)
  maxAge: 1000 * 60 * 60 * 24 * 7, // 7일
  path: "/",
});
```

- 크로스 사이트에서도 쿠키 전송이 반드시 필요하면 `SameSite=None; Secure` 조합.
- **CSRF 토큰**(쿠키+헤더 이중제출 방식 등)을 함께 사용하면 더 안전.

### 4.4 쿠키와 경로/도메인 매칭

- `Domain=.example.com` → `shop.example.com`, `api.example.com` 등 서브도메인 공유.  
- `Path=/app` → `/app/...` 경로에만 전송.

---

## 5. 보안: XSS/CSRF/프라이버시 체크리스트

### 5.1 XSS 관점

| 저장소 | XSS 접근 가능성 |
|---|---|
| **localStorage** | **가능**(JS 접근 완전 가능) |
| **sessionStorage** | **가능** |
| **쿠키** | **HttpOnly=false**면 가능, **HttpOnly=true**면 **불가능** |

- 민감 정보는 **local/sessionStorage 금지**.
- 토큰 전략 예:
  - **리프레시 토큰**: HttpOnly+Secure 쿠키.
  - **액세스 토큰**: **메모리**(전역 변수/상태) 보관. 새로고침 시 서버로 재발급.

### 5.2 CSRF 관점(쿠키는 자동 전송)

- **SameSite**:  
  - `Lax`(기본): 외부 사이트에서 대부분의 요청 차단(단, top-level GET 등 제한적 허용).  
  - `Strict`: 더 엄격(외부 컨텍스트에서 전송 거의 금지).  
  - `None`: **반드시 Secure와 함께**, 크로스 사이트 전송 허용.
- **CSRF 토큰**: 임의의 난수(token)를 쿠키와 헤더로 이중 제출 → 서버에서 일치 확인.

### 5.3 기타

- **Secure**: HTTPS에서만 전송.  
- **HttpOnly**: JS 접근 불가(클라이언트 스크립트 탈취 방지).
- 제3자 쿠키 제한/ITP 등 프라이버시 기능으로 **서드파티 쿠키**는 제약될 수 있음.

---

## 6. 실전 패턴 모음

### 6.1 다크 모드 토글(localStorage)

```html
<body class="light">
  <button id="toggle">모드 전환</button>
</body>
<script>
  const $b = document.body;
  const saved = localStorage.getItem("theme");
  if (saved) $b.className = saved;

  document.getElementById("toggle").addEventListener("click", () => {
    const next = $b.className === "light" ? "dark" : "light";
    $b.className = next;
    localStorage.setItem("theme", next);
  });
</script>
```

### 6.2 온보딩 위저드 진행률(sessionStorage)

```js
function saveStep(step) {
  sessionStorage.setItem("onboarding:step", String(step));
}
function loadStep() {
  return Number(sessionStorage.getItem("onboarding:step") ?? "1");
}
```

### 6.3 Remember-me 체크박스(쿠키 + localStorage 혼합)

- **아이디**만 쿠키/로컬 저장(민감도 낮음).  
- **세션/토큰**은 서버 쿠키(HttpOnly)로.

```js
// 아이디 기억(30일)
Cookie.set("rememberId", "alice", { maxAge: 60 * 60 * 24 * 30, path: "/" });
// 로그인 폼 초기화
document.getElementById("id").value = Cookie.get("rememberId") ?? "";
```

### 6.4 최근 본 상품 목록(최신 N개, localStorage/JSON)

```js
const KEY = "recent:items";
function pushRecent(id, limit = 20) {
  const arr = JSON.parse(localStorage.getItem(KEY) ?? "[]");
  const next = [id, ...arr.filter(x => x !== id)].slice(0, limit);
  localStorage.setItem(KEY, JSON.stringify(next));
}
```

### 6.5 키 네임스페이스/버저닝

```js
const NS = "myapp:v2"; // 버저닝으로 하위 호환/마이그레이션
const k = (name) => `${NS}:${name}`;
localStorage.setItem(k("prefs"), JSON.stringify({ theme: "dark" }));
```

---

## 7. 성능·신뢰성·호환성 노트

### 7.1 동기 스토리지 최적화

- 다량 읽기/쓰기 → **배치/버퍼링**.  
- 반복 루프에서 `localStorage.getItem` 다중 호출 대신 **한 번 읽고 변수에 보관**.

### 7.2 저장 가능 여부 감지(프라이빗 모드/정책)

```js
function storageAvailable(type) {
  try {
    const s = window[type];
    const x = "__test__";
    s.setItem(x, x);
    s.removeItem(x);
    return true;
  } catch {
    return false;
  }
}

const canLocal = storageAvailable("localStorage");
```

### 7.3 쿠키 제한/서드파티 차단

- 서드파티 컨텍스트에서 쿠키 전송이 차단될 수 있음 → 백엔드 설계 시 **토큰 헤더 + CORS** 전략 검토.

---

## 8. 보안 안티패턴 & 올바른 대안

| 안티패턴 | 문제 | 대안 |
|---|---|---|
| `localStorage.setItem("token", jwt)` | XSS로 쉽게 탈취 | 리프레시=HttpOnly 쿠키, 액세스=메모리 |
| `SameSite=None`만 설정 | CSRF에 취약 | `SameSite=None; Secure` + CSRF 토큰 |
| 쿠키에 PII 평문 저장 | 프라이버시/규정 위반 | 세션 키만 보관, 서버 저장소에 PII |
| 스토리지 대용량 JSON 매번 동기화 | 렌더 지연 | 델타 저장, 스로틀/디바운스 |

---

## 9. 테스팅/디버깅

- **Application 탭**: Storage → Local/Session Storage, Cookies 확인/수정.  
- **Network 탭**: Request/Response Cookie/Set-Cookie 헤더, SameSite/Path/Domain 검증.  
- 쿠키 삭제 이슈 시 **Path/Domain 옵션**이 정확히 매칭되는지 확인(지울 때도 동일 옵션 필요).

---

## 10. 자주 쓰는 헬퍼 모음

```js
// (1) JSON 스토리지 래퍼
const JStore = (store) => ({
  get(k, fallback = null) {
    try { return JSON.parse(store.getItem(k)) ?? fallback; }
    catch { return fallback; }
  },
  set(k, v) { store.setItem(k, JSON.stringify(v)); },
  del(k) { store.removeItem(k); },
});
const LJS = JStore(localStorage);
const SJS = JStore(sessionStorage);

// (2) 안전 set (용량 초과 대비)
function safeSet(store, key, value) {
  try { store.setItem(key, value); return true; }
  catch (e) { console.warn("Storage set 실패:", e); return false; }
}

// (3) 쿠키 필수 옵션 보장
function setSecureCookie(name, value, days = 7) {
  Cookie.set(name, value, {
    maxAge: days * 86400,
    path: "/",
    secure: true,
    sameSite: "Lax",
  });
}
```

---

## 11. 미니 실습: 로그인 흐름(보안 설계)

### 11.1 서버 응답(로그인 성공 시)

- `Set-Cookie: refresh=...; HttpOnly; Secure; SameSite=Strict; Path=/auth`
- 응답 본문에는 **민감 정보 없음**.

### 11.2 클라이언트 동작(액세스 토큰 메모리 보관)

```js
let accessToken = null;

async function login(id, pw) {
  // 쿠키는 서버가 심음(HttpOnly), 여기선 액세스 토큰만 받거나 /auth/refresh로 교환
  const res = await fetch("/auth/login", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    credentials: "include", // 쿠키 수신/전송
    body: JSON.stringify({ id, pw }),
  });
  if (!res.ok) throw new Error("login 실패");
  const { access } = await res.json();
  accessToken = access; // 메모리 보관
}

async function api(url, init = {}) {
  const headers = new Headers(init.headers || {});
  if (accessToken) headers.set("Authorization", `Bearer ${accessToken}`);
  const res = await fetch(url, { ...init, headers, credentials: "include" });
  if (res.status === 401) {
    // 만료 → 리프레시 시도(쿠키 기반)
    const r = await fetch("/auth/refresh", { method: "POST", credentials: "include" });
    if (!r.ok) throw new Error("refresh 실패");
    accessToken = (await r.json()).access;
    headers.set("Authorization", `Bearer ${accessToken}`);
    return fetch(url, { ...init, headers, credentials: "include" });
  }
  return res;
}
```

> 요약: **리프레시 토큰=HttpOnly 쿠키**, **액세스 토큰=메모리** → XSS·CSRF 리스크 균형화.

---

## 12. FAQ

**Q1. localStorage를 지웠는데 쿠키는 왜 남나요?**  
A. 저장 위치/메커니즘이 완전히 다릅니다. 개발자 도구에서 **각각 별도로** 지워야 합니다.

**Q2. 서브도메인 간 localStorage 공유 가능한가요?**  
A. 불가합니다(원본 정책). 쿠키는 `Domain=.example.com`으로 일부 공유 가능.

**Q3. 인프라에서 캐시/프락시를 쓰면 쿠키가 누출되나요?**  
A. 프락시가 TLS 종단이면 가능성 존재. **End-to-End TLS**, **쿠키 보안 옵션**을 지키세요.

**Q4. sessionStorage를 새 탭으로 복제하고 싶어요.**  
A. 직접적 복제는 안 됩니다. **`localStorage` + `storage` 이벤트**, 혹은 **URL 파라미터/POST 메시지**로 전달하세요.

---

## 13. 결론

- **상태/환경설정**: localStorage  
- **탭 한정 임시 상태**: sessionStorage  
- **인증·세션**: 쿠키(HttpOnly+Secure+SameSite)  
- 보안(특히 XSS/CSRF)을 항상 우선 고려하고, **스토리지 특성(동기/용량/전송)**에 맞춰 설계하세요.  
- 자주 쓰는 데이터는 **메모리 캐시**, 대용량·오프라인은 **IndexedDB**까지 확장하는 것이 모범 사례입니다.