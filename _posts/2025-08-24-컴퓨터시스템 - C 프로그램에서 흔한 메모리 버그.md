---
layout: post
title: 컴퓨터시스템 - C 프로그램에서 흔한 메모리 버그
date: 2025-08-24 19:20:23 +0900
category: 컴퓨터시스템
---
# C 프로그램에서 흔한 메모리 버그

## 큰 지도 — 메모리 버그의 분류와 전형적 결과

유형 | 핵심 원인 | 전형적 증상/결과
---|---|---
경계 오류(OOB) | 버퍼 크기 착오, 오프바이원 | 스택/힙 파손, 예측불가 크래시, 정보 유출
수명/소유권 | 해제 후 사용(UAF), 스택 주소 반환 | 간헐 크래시, 힙 메타데이터 오염
해제 오류 | double/invalid free | 즉시 abort 또는 지연 크래시
초기화 누락 | 미초기화 값 사용 | 비결정적 동작, 데이터 유출
정수/크기 | 오버/언더플로, `sizeof` 오용 | 과소 할당 → OOB
문자열/API | 널 종단 없음, 위험 API | OOB·정보 유출·크래시
동시성 | 해제 경쟁, 데이터 레이스 | UAF/double free
별칭/정렬 | 엄격 별칭 위반, 미정렬 접근 | UB, SIGBUS
`realloc`/복사 | 실패 누수, 겹침 `memcpy` | 누수/데이터 파손
`mmap` 특수 | 파일 크기 초과, 권한 불일치 | SIGBUS/SIGSEGV
포맷 문자열 | 포맷 인젝션 | 메모리 쓰기(`%n`), 유출
대형 스택 | 재귀 폭주/VLA/alloca 남용 | 스택 오버플로
NULL 미검사 | 실패값/경계 미검사 | 즉시 크래시

> **핵심 관점 4가지**: **경계(bound)**, **수명(lifetime)**, **소유권(ownership)**, **동시성(concurrency)**.
> 대부분의 결함은 이 네 축을 벗어날 때 발생합니다.

---

## 경계 오류(Out-of-Bounds, OOB)

### 스택 오버플로/언더플로

**원인**: 길이 미검증, 오프바이원(특히 널 포함 길이)

```c
#include <string.h>

void bad() {
    char buf[8];
    strcpy(buf, "12345678"); // 널까지 9바이트 → OOB(스택 파손)
}
```

**예방**
- 길이 제한 함수 사용: `snprintf`, `strnlen`, `memcpy`는 **정확 길이**로.
- 컴파일러 보호: `-fstack-protector-strong`, `-D_FORTIFY_SOURCE=2`(+O2 이상).
- 테스트로 경계 상수 고정: `for (i=0; i<n; ++i)` 패턴, 오프바이원 유닛테스트 포함.

**진단**
- **ASan**: `-fsanitize=address -fno-omit-frame-pointer -g`
- **Valgrind**: `valgrind --tool=memcheck`

### 힙 오버/언더플로

```c
char *p = malloc(8);
memset(p, 'A', 9);   // 1바이트 초과 → OOB(힙 가드 파손)
free(p);
```

**예방**
- **길이·계수 곱 전 오버플로 체크**(아래 §5).
- **가드 페이지**를 이용한 재현: 페이지 단위 `mmap` + 양끝 `mprotect(PROT_NONE)`.

---

## 수명과 소유권(Lifetime/Ownership)

### 해제 후 사용(UAF)

```c
char *p = malloc(16);
free(p);
p[0] = 'X'; // UAF
```

**예방**
- 해제 즉시 **NULL** 대입: `free(p); p = NULL;`
- 소유권 규약(“누가 free?”) 문서화. API 이름에도 `take_`(소유권 이전)/`borrow_`(차용) 반영.

**진단**
- **ASan**이 UAF를 강하게 잡아줌(`detect_use_after_free=1` 기본).
- **TSan**(동시성 UAF 상황에서 레이스도 함께 탐지).

### 스택 주소 반환(댕글링)

```c
char* f(void){ char b[16]; return b; } // UB
```

**예방**: 결과를 **힙에 복사**해 반환하거나, 호출자가 버퍼를 제공하도록 설계.

---

## 해제 오류(Invalid/Double Free)

```c
char *p = malloc(8);
free(p);
free(p); // double free
```

```c
char *p = malloc(32);
char *q = p + 8;
free(q); // invalid free → 힙 메타데이터 오염
```

**예방**
- **단일 소유권**: 동일 포인터의 중복 별칭을 공유 구조체에 저장하지 않기.
- “**한 곳에서만 free**” 규약. 컨테이너 정리 루틴을 단일 출구로.

**진단**
- ASan/Valgrind 모두 정확히 보고.

---

## 초기화 누락/더티 데이터

```c
typedef struct { int a; int b; } P;
P x;               // 미초기화
if (x.a == 7) { /* UB */ }
```

**예방**
- `P x = {0};` 또는 생성 함수에서 명시 초기화.
- 필요할 때만 `calloc`(의미 없는 필드를 0으로 가정 금지).
- **MSan/Valgrind**로 미초기화 읽기 탐지.

---

## 정수/크기 계산 오류

### 곱셈 오버플로 → 과소 할당

```c
size_t n = SIZE_MAX/2 + 10;
char *p = malloc(n * 2); // wrap-around → 작은 버퍼
```

**예방(안전 곱)**:
```c
#include <stdbool.h>
#include <stddef.h>

bool mul_overflow_size(size_t a, size_t b, size_t *out) {
    if (a && b > SIZE_MAX / a) return true;
    *out = a * b; return false;
}
```
> GCC/Clang: `__builtin_mul_overflow` 사용 가능.

### `sizeof` 오용

```c
int *a = malloc(10 * sizeof(a));    // BUG: ptr 크기
int *b = malloc(10 * sizeof *b);    // OK
```

### 부호/형 변환

```c
int len = -5;           // 외부 입력
malloc(len);            // size_t로 변환되어 거대 값 → 실패/UB
```

**정책**
- 크기·인덱스는 **size_t** 일관, 모든 외부 값은 **범위 검증**.

---

## 문자열/위험 API

문제 함수 | 위험 이유 | 대안/주의
---|---|---
`gets`(폐지) | 경계 없음 | `fgets`
`strcpy/strcat` | 경계 없음 | `snprintf`,(가능 시) `strlcpy/strlcat`
`scanf("%s")` | 폭발 | `"%Ns"` 폭 너비 지정
`strncpy` | 널 종단 미보장 | `dst[n-1]=0` 수동 종단

```c
char dst[8];
snprintf(dst, sizeof dst, "%s", src);
```

---

## 동시성: 레이스가 메모리를 망친다

### 해제 경쟁

```c
// 두 스레드가 같은 p를 free → double free/UAF
```

**예방**
- 소유권 전송은 **원자적**(`atomic_exchange`).
- 레퍼런스 카운팅 시 **ABA** 방지(태깅·epoch).
- 메시지 큐/작업 스레드 모델로 “free는 한 스레드만”.

**진단**
- **TSan**: `-fsanitize=thread`

---

## 별칭/정렬/엄격 별칭(Strict Aliasing)

```c
float *fp = (float*)buf;
int   *ip = (int*)buf; // 동일 메모리에 이종 타입 접근 → UB
```
- **예외**: `char*`는 모든 객체 별칭 가능.
- 미정렬 접근은 일부 아키텍처에서 **SIGBUS**.

**예방**: 타입 안전 접근, 필요 시 `memcpy`로 변환.
**임시 회피**: `-fno-strict-aliasing`(권장 아님).

---

## `realloc`/메모리 복사 오용

### `realloc` 실패로 누수

```c
p = realloc(p, newsz); // 실패→NULL 반환, 원본 유지. p를 잃으면 누수
```

**안전 패턴**
```c
void *tmp = realloc(p, newsz);
if (!tmp) { /* 로그/복구 */ }
else p = tmp;
```

### 겹침 복사

```c
char s[] = "abcdef";
memcpy(s+2, s, 3); // 겹침 → UB
memmove(s+2, s, 3); // OK
```

### `realloc` 후 내부 포인터 무효화

```c
struct V { size_t n; int a[]; };
struct V *v = malloc(sizeof *v + 10*sizeof(int));
int *inner = v->a;
v = realloc(v, sizeof *v + 20*sizeof(int));
// inner는 더 이상 유효하다고 가정 금지(재할당 시 이동)
```

---

## 잘못된 포인터 연산

- 서로 다른 배열 객체 사이 포인터 뺄셈/합산 → UB
- 경계 밖 한 칸(`end = base + n`)은 **비역참조 비교용**만 합법

---

## 대형 스택·재귀·VLA/`alloca`

```c
char big[8<<20]; // 8MB 스택 → 오버플로
```
**예방**: 힙 사용, 점진 처리. `alloca`는 에러 경로에서 정리가 어려워 신중히.

---

## NULL/반환값 미검사

```c
char *p = malloc(n);
strcpy(p, "hi"); // 실패 시 NULL 역참조
```
**정책**: 모든 리소스 획득 실패는 즉시 검사, **단일 정리 경로**로 처리(§17).

---

## 직렬화/패딩/미초기화 바이트 유출

```c
typedef struct { int a; char b; } P; // 패딩 존재 가능
write(fd, &p, sizeof p); // 패딩의 쓰레기 바이트 유출
```

**예방**: 필드 단위 I/O, 또는 `memset(&p,0,sizeof p)` 후 채움.

---

## `mmap` 특수 버그

- 파일 길이보다 **크게 매핑 후 접근** → **SIGBUS**
- 권한 불일치(`PROT_WRITE` 없이 쓰기) → **SIGSEGV**
- `msync`/`munmap` 실패 무시 → 데이터 손실

```c
void* map = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
if (map == MAP_FAILED) { perror("mmap"); }
```

---

## 포맷 문자열 취약점

```c
printf(user);           // 공격 입력에 %n/%p 포함 가능
printf("%s", user);     // 항상 포맷 분리
```

---

## “위험 API 치트시트”

분야 | 지양 | 권장
---|---|---
입력 | `gets` | `fgets`
문자열 | `strcpy/strcat/sprintf` | `snprintf`, `strlcpy/strlcat`(플랫폼)
스캔 | `scanf("%s")` | 폭 너비 지정(`%Ns`), `getline` 활용
숫자파싱 | `atoi` | `strtol/strtoul`(오류/범위 확인)
복사 | 겹침 가능 `memcpy` | `memmove`

---

## 안전한 패턴 템플릿

### 실패 경로 단일화(goto cleanup)

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int do_work(const char *path){
    int rc = -1, fd = -1; void *buf = NULL;

    fd = open(path, O_RDONLY);
    if (fd < 0) goto out;

    buf = malloc(4096);
    if (!buf) goto out;

    // ... 작업 ...
    rc = 0;
out:
    free(buf);
    if (fd >= 0) close(fd); // close의 EINTR는 재시도하지 않음
    return rc;
}
```

### 길이 안전 문자열 복사

```c
#include <string.h>

int safe_copy(char *dst, size_t cap, const char *src){
    if (cap == 0) return -1;
    size_t n = strnlen(src, cap-1);
    memcpy(dst, src, n);
    dst[n] = '\0';
    return (n < cap-1) ? 0 : 1; // 1: 잘림
}
```

### 안전 `realloc` 래퍼

```c
void *xrealloc(void *p, size_t n){
    void *q = realloc(p, n);
    return q ? q : p; // 정책에 맞게 실패 시 원본 유지(호출자가 구분)
}
```

### 안전 곱셈 + 할당

```c
void *xmalloc_array(size_t count, size_t esize){
    size_t bytes;
    if (count && esize > SIZE_MAX / count) return NULL;
    bytes = count * esize;
    return malloc(bytes);
}
```

---

## 재현·학습용 미니 테스트 스위트

`bugs.c` — 각 버그를 선택적으로 재현
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

void oob_stack(){ char b[8]; strcpy(b,"12345678"); }
void oob_heap(){ char *p=malloc(8); memset(p,'A',9); free(p); }
void uaf(){ char *p=malloc(4); free(p); p[0]=1; }
void dbl_free(){ char *p=malloc(4); free(p); free(p); }
void uninit(){ int x; if (x==42) puts("hit"); }
void overlap(){ char s[]="abcdef"; memcpy(s+2,s,3); puts(s); }

int main(int argc,char**argv){
    if (argc<2){ puts("pick: oob_stack|oob_heap|uaf|dbl|uninit|overlap"); return 0; }
    if (!strcmp(argv[1],"oob_stack")) oob_stack();
    else if (!strcmp(argv[1],"oob_heap")) oob_heap();
    else if (!strcmp(argv[1],"uaf")) uaf();
    else if (!strcmp(argv[1],"dbl")) dbl_free();
    else if (!strcmp(argv[1],"uninit")) uninit();
    else if (!strcmp(argv[1],"overlap")) overlap();
    return 0;
}
```

**ASan로 빌드/실행**
```bash
cc -O1 -g -fsanitize=address -fno-omit-frame-pointer bugs.c -o bugs
ASAN_OPTIONS=halt_on_error=1:detect_leaks=1 ./bugs oob_heap
```

**Valgrind**
```bash
cc -O1 -g bugs.c -o bugs && valgrind --leak-check=full ./bugs uaf
```

---

## 퍼징(fuzzing)으로 경계·파싱 결함 찾기

### libFuzzer 예시

```c
// fuzz_target.c
#include <stdint.h>
#include <stddef.h>

int parse(const uint8_t*, size_t); // 대상 함수
int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size){
    parse(Data, Size);
    return 0;
}
```

**빌드/실행**
```bash
clang -g -O1 -fsanitize=address,fuzzer fuzz_target.c parse.c -o fuzz
./fuzz -max_total_time=60
```
- 충돌 입력이 `crash-*`로 저장 → 회귀 테스트에 포함.

---

## 하드닝(Hardening) 플래그·정책

영역 | 권장 설정 | 설명
---|---|---
스택 보호 | `-fstack-protector-strong` | 카나리로 스택 smashing 탐지
FORTIFY | `-D_FORTIFY_SOURCE=2 -O2` | 경계체크 내장(glibc)
RELRO/GOT | `-Wl,-z,relro -Wl,-z,now` | GOT 고정(지연바인딩 금지)
PIE | `-fPIE -pie` | ASLR 효과 극대화
W^X | 코드/데이터 권한 분리 | NX + JIT은 W→X 단계 전환
링커 금지 | `-Wl,--no-undefined` | 미해결 심볼 방지
산티라이저 | ASan/UBSan/MSan/TSan | 개발·테스트 빌드에 상시 적용
정적분석 | clang-tidy/scan-build | PR마다 실행
기타 | `-fno-omit-frame-pointer` | 프로파일/디버깅 용이

> ARM64 환경에선 **HWASan**(하드웨어 지원 주소 태깅) 또는 **MTE**(메모리 태깅 확장) 사용 가능(플랫폼 종속).

---

## 운영체제 보호 및 런타임 가드

- **NX 비트**, **ASLR**, **stack/heap guard**, **malloc 검증기**(glibc의 일부 점검 기능)
- 파일/네트워크 경계에서는 **seccomp**로 시스템 콜 표면 축소
- 컨테이너/샌드박스로 프로세스 권한·자원 격리(cgroup, namespace)

---

## 실무 체크리스트

- [ ] 모든 할당/열기/매핑 **반환값 검사**
- [ ] 크기 계산은 **오버플로 체크**(곱/합)
- [ ] `sizeof(*ptr)` 패턴, 정렬 보장
- [ ] 해제는 **단일 경로**, 해제 후 `NULL`
- [ ] 문자열 **널 종단/폭 너비** 보장
- [ ] `realloc`은 **임시 포인터**로 받기
- [ ] 겹침 가능성 있으면 **memmove**
- [ ] 스택은 **작게**, 대형은 힙
- [ ] **ASan/UBSan/TSan/MSan**을 CI에 통합
- [ ] 퍼징으로 파서/프로토콜 입력 방어선 강화
- [ ] 릴리스에도 **심볼(-g)** 과 **프레임포인터** 유지(운영 환경 디버깅 대비)

---

## 부록 A) 정수 안전 유틸(헤더)

```c
// safe_arith.h
#ifndef SAFE_ARITH_H
#define SAFE_ARITH_H
#include <stdbool.h>
#include <stddef.h>

static inline bool add_overflow_size(size_t a, size_t b, size_t* out){
    if (a > SIZE_MAX - b) return true; *out = a + b; return false;
}
static inline bool mul_overflow_size(size_t a, size_t b, size_t* out){
    if (a && b > SIZE_MAX / a) return true; *out = a * b; return false;
}
#endif

```

---

## 부록 B) 가드 페이지 할당(재현/디버깅)

```c
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

typedef struct { void *base; size_t usable; } guard_buf;

guard_buf alloc_guard(size_t n){
    size_t ps = sysconf(_SC_PAGESIZE);
    size_t need = (n + ps - 1)/ps * ps;
    void *p = mmap(NULL, need + 2*ps, PROT_READ|PROT_WRITE,
                   MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    mprotect(p, ps, PROT_NONE);                // 앞 가드
    mprotect((char*)p + ps + need, ps, PROT_NONE); // 뒤 가드
    return (guard_buf){ .base=(char*)p + ps, .usable=need };
}
```
경계 초과 시 즉시 **SIGSEGV**로 재현되어 디버깅이 쉬워집니다.

---

## 부록 C) 동시성 UAF 재현(간단)

```c
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdatomic.h>

typedef struct { int v; } Obj;
_Atomic(Obj*) G;

void* t1(void*){
    Obj* o = atomic_load(&G);
    free(o);               // 해제
    atomic_store(&G, NULL);
    return NULL;
}
void* t2(void*){
    Obj* o = atomic_load(&G);
    if (o) o->v = 42;      // 레이스 → UAF 가능
    return NULL;
}
int main(){
    Obj* o = malloc(sizeof *o);
    o->v = 0; atomic_store(&G, o);
    pthread_t a,b; pthread_create(&a,NULL,t1,NULL); pthread_create(&b,NULL,t2,NULL);
    pthread_join(a,NULL); pthread_join(b,NULL);
    return 0;
}
```
**TSan**으로 실행: `-fsanitize=thread`

---

## 한 줄 결론

C 메모리 버그는 **경계·수명·소유권·동시성** 네 축의 규율을 어길 때 나타납니다.
**안전 패턴(경계 체크·단일 정리 경로·소유권 명시) + 산티라이저/퍼징 + 하드닝 플래그**를 표준화하면,
대부분의 치명적 결함을 **개발 단계에서** 재현·차단·퇴치할 수 있습니다.
