---
layout: post
title: 컴퓨터시스템 - C 프로그램에서 흔한 메모리 버그
date: 2025-08-24 19:20:23 +0900
category: 컴퓨터시스템
---
# C 프로그램에서 흔한 메모리 버그 — 유형별 정리, 재현 코드, 예방/진단 팁

아래는 C에서 자주 발생하는 메모리 관련 결함을 **유형별로 구조화**해 정리한 것입니다.  
각 항목은 **증상 → 원인 → 재현 코드 → 예방/점검 포인트** 순으로 빠르게 이해할 수 있도록 구성했습니다.

---

## 0) 큰 지도: 무엇이 어떻게 망가지는가

유형 | 핵심 원인 | 전형적 결과
---|---|---
경계 오류(OOB) | 버퍼 크기 초과/미만 접근 | 스택/힙 파손, 무작위 크래시
수명/소유권 | 해제 후 사용, 스택 주소 반환 등 | UAF, 댕글링 포인터
해제 오류 | double free, 잘못된 free | 힙 메타데이터 오염 → 즉시/지연 크래시
초기화 누락 | 쓰레기 값 사용 | 비결정적 동작, 정보 노출
정수/크기 계산 | 오버/언더플로, sizeof 오용 | 잘못된 할당, OOB
문자열/위험 API | NULL 종단 없음, gets/strcpy | OOB, 정보 유출
동시성 | 데이터 레이스, 해제 경쟁 | UAF, double free
별칭/정렬 | strict aliasing, 미정렬 접근 | UB, 시그널(SIGBUS 등)
`realloc`/`memcpy` 오용 | 실패 처리, 겹침 복사 | 누수, 데이터 파손
`mmap` 특수 | 파일 크기 초과 접근, 권한 불일치 | SIGBUS, SIGSEGV

---

## 1) 경계 오류(Out-of-Bounds, OOB)

### 1.1 버퍼 오버플로/언더플로(스택/힙)
**원인**: 길이 미검증, 오프바이원, 잘못된 루프 조건.

```c
char buf[8];
strcpy(buf, "12345678");  // 널 포함 9바이트 → OOB (스택 파손)
```

**예방**
- **항상 길이 기반 함수 + 상한**: `snprintf`, `strnlen`, `memcpy`는 **정확한 길이**로.
- 루프 조건은 `i < n`(오프바이원 주의), 경계는 **테스트로 고정**.
- 컴파일러 보호: `-fstack-protector-strong`, `-D_FORTIFY_SOURCE=2`.

---

## 2) 수명과 소유권(Lifetime/Ownership)

### 2.1 해제 후 사용(Use-After-Free, UAF)
```c
char *p = malloc(16);
free(p);
p[0] = 'X';          // UAF
```

**예방**
- **해제 즉시 NULL 할당**: `free(p); p = NULL;`
- 소유권 규약 문서화(“누가 free 하는가”), 함수명에 표현(`take_`, `borrow_` 패턴).

### 2.2 스택 주소 반환
```c
char* f(void){ char buf[16]; return buf; }  // 댕글링 포인터
```

**예방**: 힙/정적 저장기간으로 복사하여 반환.

---

## 3) 해제 오류(Invalid/Double Free)

### 3.1 Double Free
```c
char *p = malloc(8);
free(p);
free(p);   // double free
```

### 3.2 다른 포인터로 free (중간 주소/별칭)
```c
char *p = malloc(32);
char *q = p + 8;
free(q);            // 잘못된 포인터로 free → 힙 메타데이터 파손
```

**예방**
- 포인터 **단일 소유권** 보장(복수 별칭 금지 또는 약한 참조만).
- 컨테이너는 **소멸자-like** 정리 루틴 한 곳에서만 free.

---

## 4) 초기화 누락/더티 데이터

```c
typedef struct { int a; int b; } P;
P x;              // 초기화 안 됨
if (x.a == 7) ... // UB
```

**예방**
- **정적/복합 리터럴 초기화**: `P x = {0};`
- `calloc`로 0 초기화가 의미 있는 곳에서만 사용(의미 없는 필드까지 0으로 가정 금지).
- **ASan/Valgrind**로 미초기화 읽기 탐지.

---

## 5) 정수/크기 계산 오류

### 5.1 오버플로로 잘못된 할당
```c
size_t n = SIZE_MAX / 2 + 10;
char *p = malloc(n * 2);  // wrap-around → 매우 작은 버퍼
```

**예방**
- 곱셈 전 **오버플로 체크**:
```c
size_t bytes;
if (__builtin_mul_overflow(n, elem, &bytes)) return NULL;
```

### 5.2 `sizeof` 오용
```c
int *a = malloc(10 * sizeof(a));   // BUG: sizeof(ptr) → 8/4
int *b = malloc(10 * sizeof(*b));  // OK
```

### 5.3 부호/형 변환
```c
int len = -5;
malloc(len);        // 음수 → size_t로 변환되어 거대 값
```

**예방**
- 모든 크기/인덱스는 **size_t**로 일관, 외부에서 들어오면 범위 검증.

---

## 6) 문자열/위험 API

### 6.1 널 종단 누락, 폭발하는 API
문제 함수 | 왜 위험한가 | 대안/주의
---|---|---
`gets`(삭제됨) | 경계 없음 | `fgets`
`strcpy/strcat` | 경계 없음 | `snprintf`, `strlcpy/strlcat`(있다면)
`scanf("%s")` | 폭발 | `"%Ns"`처럼 **폭 너비 지정**
`strncpy` | 널 보장 X | 사용 시 수동 종단: `dst[n-1]=0`

```c
char dst[8];
snprintf(dst, sizeof dst, "%s", src);  // 길이 안전
```

---

## 7) 동시성: 데이터 레이스 → 메모리 파손

### 7.1 해제 경쟁
두 스레드가 같은 포인터를 **경쟁 free** → double free/UAF.

**예방**
- 소유권 전송은 **원자적**으로(`atomic_exchange`), 레퍼런스 카운팅 시 **ABA** 주의.
- 락/RC/메시지 패싱으로 “한 번만 free” 보장.

---

## 8) 별칭/정렬/엄격 별칭 규칙(Strict Aliasing)

### 8.1 Strict Aliasing 위반
```c
float *fp = (float*)buf;
int   *ip = (int*)buf;   // 같은 메모리를 다른 정수형으로 접근 → UB
```
**예외**: `char*`는 모든 객체를 별칭 가능.

**예방**
- 타입 안전한 접근, 필요 시 `memcpy` 통한 변환.
- 컴파일러 옵션 임시회피: `-fno-strict-aliasing`(근본 해결 아님).

### 8.2 미정렬 접근
```c
#pragma pack(1)
struct P { char c; int x; }; // x가 미정렬 → 일부 아키텍처에서 SIGBUS
```
**예방**: 정렬 보장되는 복사로 접근하거나 `memcpy` 사용.

---

## 9) `realloc`/`memcpy` 오용

### 9.1 `realloc` 실패로 누수
```c
p = realloc(p, newsz);  // 실패 시 NULL 반환 + 원본은 그대로인데 포인터 잃음 → 누수
```

**안전 패턴**
```c
void *tmp = realloc(p, newsz);
if (!tmp) { /* 복구/로그 */ }
else p = tmp;
```

### 9.2 겹치는 영역에 `memcpy`
```c
char s[] = "abcdef";
memcpy(s+2, s, 3);   // 겹침 → UB, 결과 불명
// 올바름:
memmove(s+2, s, 3);
```

---

## 10) 잘못된 포인터 연산

- 서로 다른 배열 객체 사이 포인터 차이/합산 → UB
- 경계 밖 한 칸(`p+n`)은 **비교/포인터 산술**만 허용, 역참조 금지

---

## 11) 대형 스택/재귀, VLA/`alloca`

```c
char big[8<<20];   // 8MB 스택 → 스택 오버플로(Segfault)
```

**예방**: 힙 사용 또는 점진적 처리. `alloca`는 함수 리턴 시 자동 해제지만 **수명/에러 경로**가 불안정.

---

## 12) 널 포인터/반환값 미검사

```c
char *p = malloc(n);
strcpy(p, "hi");      // malloc 실패 시 NULL 역참조
```

**예방**: 모든 할당/매핑/열기 결과는 즉시 검사, 실패 경로를 **한 곳으로 goto** 정리.

---

## 13) 구조체 직렬화/패딩/미초기화 바이트 유출

```c
typedef struct { int a; char b; } P; // 패딩 존재 가능
write(fd, &p, sizeof p);             // 패딩의 미초기화 데이터 유출
```

**예방**: 명시적 필드 단위 I/O, `memset(&p,0,sizeof p)` 후 채우기.

---

## 14) `mmap` 관련 특수 버그

- **파일 크기보다 크게 매핑 후 접근** → `SIGBUS`
- 권한 불일치(`PROT_WRITE` 없이 쓰기) → `SIGSEGV`
- `msync`/`munmap` 오류 미검사 → 데이터 손실

```c
void* map = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
if (map == MAP_FAILED) { perror("mmap"); }
```

---

## 15) 포맷 문자열 취약점(메모리 파손 유발)

```c
printf(user_input);      // 공격자 제어 포맷 → %n 등으로 메모리 손상
printf("%s", user_input); // 항상 포맷 분리
```

---

## 16) “위험 API 치트시트”

- 입력: `gets`(X) → `fgets`, `scanf("%Ns", ...)`
- 문자열: `strcpy/strcat`(주의) → `snprintf`, `strlcpy/strlcat`(플랫폼 의존)
- 숫자 파싱: `atoi`(오류 구분 X) → `strtol/strtoul`(범위/에러 코드 확인)
- 바이너리 복사: 겹침 가능성 있으면 **항상 `memmove`**

---

## 17) 안전한 패턴 모음

### 17.1 실패 경로 단일화(goto cleanup)
```c
int do_work(const char *path){
    int rc = -1, fd = -1; void *buf = NULL;
    fd = open(path, O_RDONLY);
    if (fd < 0) goto out;
    buf = malloc(4096);
    if (!buf) goto out;
    // ... 작업 ...
    rc = 0;
out:
    free(buf);
    if (fd >= 0) close(fd);
    return rc;
}
```

### 17.2 길이 안전 문자열 복사
```c
static int safe_copy(char *dst, size_t cap, const char *src){
    size_t n = strnlen(src, cap-1);
    memcpy(dst, src, n);
    dst[n] = '\0';
    return (n < cap-1) ? 0 : -1; // 잘림 여부
}
```

### 17.3 `realloc` 안전 래퍼
```c
void *xrealloc(void *p, size_t n){
    void *q = realloc(p, n);
    if (!q && n) { /* 로그/정리 */ }
    return q ? q : p; // 정책에 맞게 선택
}
```

---

## 18) 자동/도구 기반 탐지

도구 | 용도 | 사용법 예
---|---|---
**AddressSanitizer (ASan)** | OOB, UAF, double free | `-fsanitize=address -fno-omit-frame-pointer -g`
**LeakSanitizer (LSan)** | 누수 | `-fsanitize=leak`
**UBSan** | 미정의 동작(오버플로 등) | `-fsanitize=undefined`
**Valgrind** | 누수/미초기화/힙 오류 | `valgrind --leak-check=full ./a.out`
**clang-tidy / cppcheck** | 정적 분석 | 규칙셋 활성화
**fuzzing (libFuzzer/AFL)** | 경계/파싱 결함 탐색 | `-fsanitize=address,fuzzer`

**팁**
- 릴리스 빌드도 **심볼/프레임포인터 유지**: `-g -fno-omit-frame-pointer`
- CI에 **ASan/UBSan 조합** 테스트 포함.

---

## 19) 운영체제 레벨 보호

- 스택/힙 가드, **NX 비트**, **ASLR**, **W^X** 정책
- 링크 타임 보호: `-Wl,-z,relro,-z,now` (GOT 보호), PIE: `-fPIE -pie`

---

## 20) 점검 체크리스트

- [ ] 모든 할당/열기/매핑 **반환값 검사**
- [ ] 크기 계산 시 **오버플로 체크**(곱/합)
- [ ] `sizeof(*ptr)` 패턴 사용, **정렬 보장**
- [ ] 해제는 **한 곳**, 해제 후 **NULL**
- [ ] 문자열은 **널 종단/길이 제한** 보장
- [ ] `realloc`은 **임시 포인터**로 받기
- [ ] 겹침 가능성 있으면 **memmove**
- [ ] 스택 메모리는 **작게**, 대형은 힙
- [ ] 정적/동적 분석/퍼징을 CI에 통합

---

## 21) 한 줄 결론
C의 메모리 버그는 **크기**, **수명**, **경계**, **동시성**의 네 축을 벗어날 때 생깁니다.  
**안전한 코딩 습관 + 빌드 플래그 + 런타임/정적 도구**를 체계적으로 적용하면,  
대부분의 치명적 결함을 **개발 단계에서** 잡아낼 수 있습니다.