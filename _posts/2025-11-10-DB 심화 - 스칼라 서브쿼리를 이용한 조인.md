---
layout: post
title: DB 심화 - 스칼라 서브쿼리를 이용한 조인
date: 2025-11-10 22:25:23 +0900
category: DB 심화
---
# 스칼라 서브쿼리를 이용한 조인

> 목표
> - 스칼라 서브쿼리(Scalar Subquery)를 **조인 대체/보완 수단**으로 사용할 때의 개념, 변환 메커니즘, 성능 특성, 그리고 실전 패턴을 종합적으로 정리합니다.
> - 특히 **스칼라 서브쿼리 캐싱 효과**, **서브쿼리 언네스팅(조인화) 변환**, **LATERAL/APPLY로 다중 컬럼을 한 번에 가져오는 방식**, **다중 스칼라 서브쿼리의 위험과 대안**을 재현 가능한 실습을 통해 확인합니다.

실행 후에는 반드시 아래 명령으로 **실측 플랜과 통계**를 확인하세요.

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
         'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'
       ));
```

---

## 왜 스칼라 서브쿼리를 "조인처럼" 사용하는가?

스칼라 서브쿼리는 SQL에서 **표현식 자리에 들어가는 단일 값**을 반환하기 위한 도구입니다. 그러나 실무에서는 다음과 같은 이유로 "조인 대체" 또는 "조인 보완" 목적으로 빈번히 사용됩니다.

1. **가독성 향상**  
   "왼쪽 행 하나를 보고, 오른쪽 테이블에서 필요한 값 하나만 붙인다"는 의도가 직관적으로 드러납니다. 복잡한 `LEFT JOIN + GROUP BY` 구문을 간결하게 표현할 수 있습니다.

2. **Top-N/최근 1건 조회에 특화**  
   `ORDER BY ... FETCH FIRST 1 ROW` 구문과 인덱스 역순 스캔을 결합하면 **OLTP 환경에서 폭발적으로 빠른 패턴**이 구현됩니다.

3. **CBO의 조인 재작성 능력**  
   Oracle 옵티마이저는 스칼라 서브쿼리를 **조인으로 풀어 최적화하는 변환(Unnesting/Decorrelate)**을 수행할 수 있습니다. 따라서 표현식으로 작성했더라도 내부적으로는 조인처럼 최적화되는 경우가 많습니다.

4. **스칼라 서브쿼리 캐싱 효과**  
   상관 스칼라 서브쿼리가 **같은 입력 키를 반복**해서 받을 때, Oracle 실행 엔진이 결과를 캐시하여 재사용합니다. 반복 키가 많은 조회(예: 차원 룩업, 요약 테이블 참조)에서 **NL 조인보다 더 효율적**일 수 있습니다.

이러한 장점들이 항상 자동으로 발휘되는 것은 아닙니다. **단일 행 보장 실패**, **NDV 과대 추정**, **비결정적 표현식**, **통계 오판**, **다중 컬럼 요구** 같은 현실 문제를 정확히 이해하고 대응해야 합니다.

---

## 실습 환경 준비

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;
ALTER SESSION SET workarea_size_policy = AUTO;
```

---

## 실습 스키마와 데이터 구성

아래 DDL과 데이터는 바로 실행 가능하며, 캐싱, Top-N, 조인화 변환, LATERAL 데모를 위해 **고객 1만 명**, **주문 20만 건**, **요약 테이블**을 구성합니다.

```sql
-- 기존 테이블 정리
DROP TABLE CUST   PURGE;
DROP TABLE ORD    PURGE;
DROP TABLE OSTAT  PURGE;

-- 고객 테이블
CREATE TABLE CUST(
  CUST_ID  NUMBER       PRIMARY KEY,
  NAME     VARCHAR2(30) NOT NULL,
  REGION   VARCHAR2(8)  NOT NULL,
  TIER     VARCHAR2(8)  NOT NULL
);

-- 주문 헤더 테이블
CREATE TABLE ORD(
  ORDER_ID NUMBER       PRIMARY KEY,
  CUST_ID  NUMBER       NOT NULL,
  ORDER_DT DATE         NOT NULL,
  STATUS   VARCHAR2(8)  NOT NULL,
  AMOUNT   NUMBER(10,2) NOT NULL
);

-- 고객별 주문 요약 테이블(데모용)
CREATE TABLE OSTAT(
  CUST_ID     NUMBER PRIMARY KEY,
  LAST_DT     DATE,
  CNT_90D     NUMBER,
  SUM_90D     NUMBER(12,2)
);

-- 인덱스: 고객별 최근 주문 Top-1 조회를 위해 (CUST_ID, ORDER_DT) 구성
CREATE INDEX IX_ORD_CUST ON ORD(CUST_ID, ORDER_DT);

-- 데이터 생성
BEGIN
  -- 1만 명 고객
  FOR c IN 1..10000 LOOP
    INSERT INTO CUST VALUES(
      c,
      'CUST_'||TO_CHAR(c,'FM00000'),
      CASE MOD(c,5)
        WHEN 0 THEN 'APAC'
        WHEN 1 THEN 'EMEA'
        WHEN 2 THEN 'AMER'
        WHEN 3 THEN 'JPN'
        ELSE 'KOR'
      END,
      CASE MOD(c,4)
        WHEN 0 THEN 'VIP'
        WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER'
        ELSE 'GEN'
      END
    );
  END LOOP;

  -- 20만 건 주문
  FOR o IN 1..200000 LOOP
    INSERT INTO ORD VALUES(
      o,
      MOD(o,10000)+1,
      DATE '2024-01-01' + MOD(o,365),
      CASE MOD(o,4)
        WHEN 0 THEN 'NEW'
        WHEN 1 THEN 'PAID'
        WHEN 2 THEN 'SHIP'
        ELSE 'DONE'
      END,
      ROUND(DBMS_RANDOM.VALUE(10,2000),2)
    );
  END LOOP;

  COMMIT;
END;
/

-- OSTAT 테이블 채우기(최근 90일 기준)
BEGIN
  INSERT /*+ APPEND */ INTO OSTAT
  SELECT c.cust_id,
         MAX(CASE WHEN o.order_dt >= SYSDATE-90 THEN o.order_dt END) AS last_dt,
         COUNT(CASE WHEN o.order_dt >= SYSDATE-90 THEN 1 END)       AS cnt_90d,
         SUM(CASE WHEN o.order_dt >= SYSDATE-90 THEN o.amount END)  AS sum_90d
  FROM   CUST c
  LEFT   JOIN ORD o ON o.cust_id = c.cust_id
  GROUP  BY c.cust_id;

  COMMIT;

  -- 통계 수집
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OSTAT',cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

## 스칼라 서브쿼리의 정의와 제약 조건

### 정의

- **정확히 1개의 컬럼**만 반환하는 서브쿼리입니다.
- 반환 행 수는 **0행 또는 1행**이어야 합니다.
  - 0행 → NULL 반환
  - 2행 이상 → ORA-01427 에러 발생

### 단일 행 보장 패턴

1. **집계 함수로 단일화**
   ```sql
   (SELECT MAX(o.order_dt) FROM ORD o WHERE o.cust_id = c.cust_id)
   ```

2. **Top-1로 단일화**
   ```sql
   (SELECT o.amount
    FROM   ORD o
    WHERE  o.cust_id = c.cust_id
    ORDER  BY o.order_dt DESC
    FETCH FIRST 1 ROWS ONLY)
   ```

3. **유니크 키/PK 기반 조회**
   ```sql
   (SELECT name FROM CUST c2 WHERE c2.cust_id = o.cust_id)
   ```

---

## "조인처럼" 사용하는 핵심 패턴

### SELECT 리스트에서의 룩업(단일 값 추가)

고객 목록에 각 고객의 "최근 주문일"을 추가하는 예제입니다.

```sql
SELECT /* scalar lookup */
       c.cust_id, c.name, c.region, c.tier,
       ( SELECT MAX(o.order_dt)
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
       ) AS last_order_dt
FROM   CUST c
WHERE  c.region = 'KOR'
FETCH FIRST 20 ROWS ONLY;
```

의미상으로는 `LEFT JOIN (GROUP BY)`와 동일합니다. Oracle은 이를 **조인으로 언네스팅**하여 최적화할 수 있습니다.

#### 동등한 조인 표현(비교용)

```sql
SELECT c.cust_id, c.name, c.region, c.tier, x.last_order_dt
FROM   CUST c
LEFT   JOIN (
         SELECT o.cust_id, MAX(o.order_dt) AS last_order_dt
         FROM   ORD o
         GROUP  BY o.cust_id
       ) x
       ON x.cust_id = c.cust_id
WHERE  c.region='KOR'
FETCH FIRST 20 ROWS ONLY;
```

**실전 통찰**  
"스칼라가 더 낫다/조인이 더 낫다"는 고정된 답이 없습니다. 옵티마이저가 언네스팅하면 거의 같은 실행계획이 나올 수 있고, 언네스팅하지 않으면 **상관 서브쿼리 실행 + 캐싱** 방식으로 처리될 수도 있습니다.

### WHERE 절에서의 필터링(세미 조인 대체)

최근 90일 내에 주문이 있는 고객만 조회하는 예제입니다.

```sql
SELECT /* scalar filter */
       c.cust_id, c.name
FROM   CUST c
WHERE  ( SELECT MAX(o.order_dt)
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
       ) >= SYSDATE - 90;
```

논리적으로는 "최근 주문일이 90일 내에 존재한다"는 의미로, EXISTS와 동등합니다. Oracle은 이 패턴을 **SEMI JOIN/ANTI JOIN으로 재작성**할 수 있습니다.

#### EXISTS로 직접 표현

```sql
SELECT c.cust_id, c.name
FROM   CUST c
WHERE  EXISTS (
         SELECT 1
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
         AND    o.order_dt >= SYSDATE-90
       );
```

**언제 스칼라 서브쿼리가 유리한가?**  
필터 조건이 집계 결과(예: MAX, SUM)로 자연스럽게 정의될 때 가독성이 향상되고, 언네스팅을 통한 최적화 기회도 확보할 수 있습니다.

### Top-1/최근 1건 추가(OLTP 최적화 패턴)

VIP 고객에게 "가장 최근 주문 1건의 날짜, 금액, 상태"를 추가하는 예제입니다.

```sql
SELECT c.cust_id, c.name,
       ( SELECT o.order_dt
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
         ORDER  BY o.order_dt DESC
         FETCH FIRST 1 ROWS ONLY
       ) AS last_dt,
       ( SELECT o.amount
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
         ORDER  BY o.order_dt DESC
         FETCH FIRST 1 ROWS ONLY
       ) AS last_amt
FROM   CUST c
WHERE  c.tier = 'VIP'
FETCH FIRST 50 ROWS ONLY;
```

`(cust_id, order_dt)` 인덱스가 존재하면 내부적으로 **Index Range Scan Desc + Stopkey** 실행계획이 생성되어야 합니다. 다중 스칼라 서브쿼리가 **조인으로 재작성**될 수도 있지만, 이에만 의존하면 실행계획 안정성이 떨어질 수 있습니다.

### UPDATE/INSERT에서의 스칼라 룩업

ORD 테이블의 STATUS를 "고객 등급 기준"으로 업데이트하는 예제입니다.

```sql
UPDATE ORD o
SET    o.status =
       ( SELECT CASE c.tier
                  WHEN 'VIP'  THEN 'VIP_NEW'
                  WHEN 'GOLD' THEN 'G_NEW'
                  ELSE 'NEW'
                END
         FROM   CUST c
         WHERE  c.cust_id = o.cust_id
       )
WHERE  o.order_dt >= DATE '2024-07-01';
```

**행당 단일 값 룩업**이 필요한 경우 스칼라 서브쿼리의 전형적인 사용 사례입니다. 내부적으로는 조인이나 머지 조인으로 재작성될 수 있습니다.

---

## 옵티마이저 관점: 스칼라 서브쿼리 변환 메커니즘

### Scalar Subquery Unnesting(조인화 변환)

Oracle의 서브쿼리 변환 중 하나가 **UNNEST**입니다. 스칼라 서브쿼리를 **외부 쿼리 블록과 합쳐 조인으로 변환**하여 조인 순서, 조인 방식, 액세스 경로 탐색 공간을 확장합니다.

#### 전형적인 변환 예시

원본 쿼리:
```sql
SELECT c.cust_id,
       (SELECT MAX(o.amount) FROM ORD o WHERE o.cust_id=c.cust_id) AS max_amt
FROM   CUST c;
```

CBO 내부 변환(개념적):
```sql
SELECT c.cust_id, x.max_amt
FROM   CUST c
LEFT JOIN (
  SELECT cust_id, MAX(amount) max_amt
  FROM   ORD
  GROUP  BY cust_id
) x ON x.cust_id=c.cust_id;
```

### 변환이 제한되는 조건

- 서브쿼리가 **비결정적 함수나 부수 효과 함수**를 포함하는 경우
  (예: `DBMS_RANDOM`, `SYSTIMESTAMP` 직접 사용)
- 서브쿼리에 **ROWNUM/수평 스캔 의존** 패턴이 있고, 조인화 시 의미가 변경되는 경우
- 옵티마이저가 비용 계산상 "상관 실행 + 캐싱"이 더 낫다고 판단한 경우
- 힌트로 변환을 명시적으로 제한한 경우

### 변환 제어 힌트

- `UNNEST` / `NO_UNNEST`  
  서브쿼리를 조인으로 풀지 말지 제어합니다.
- `PUSH_SUBQ` / `NO_PUSH_SUBQ`  
  언네스팅되지 않은 서브쿼리를 **언제 평가할지(상위/하위 단계)** 제어합니다. 일반적으로 `NO_UNNEST`와 함께 사용됩니다.

예시(언네스팅 억제):
```sql
SELECT c.cust_id,
       (SELECT /*+ NO_UNNEST */ MAX(o.amount)
        FROM   ORD o
        WHERE  o.cust_id=c.cust_id) AS max_amt
FROM   CUST c;
```

예시(푸시 강제):
```sql
SELECT /*+ NO_UNNEST PUSH_SUBQ */
       c.cust_id
FROM   CUST c
WHERE  c.cust_id IN (
         SELECT /*+ qb_name(sq) */ o.cust_id
         FROM   ORD o
         WHERE  o.order_dt >= SYSDATE-30
       );
```

---

## 스칼라 서브쿼리 캐싱(Scalar Subquery Caching)

### 캐싱 메커니즘

Oracle 실행 엔진은 **상관 스칼라 서브쿼리의 입력 값(상관 키)**이 반복될 때 결과를 **쿼리 실행 컨텍스트 내 캐시**에 저장하여 재사용합니다.

- 캐시는 기본적으로 "입력 키 조합 → 결과 값"의 해시 맵처럼 동작합니다.
- **같은 키가 반복될수록** 실제 서브쿼리 실행 횟수가 줄어듭니다.

### 캐싱 효과가 극대화되는 상황

- 상관 키의 **NDV(고유 값 수)가 낮은 경우**
- 외부 Row Source에서 **같은 키가 다수 반복되는 경우**
- 서브쿼리 내부 작업이 **가볍고 결정적인 경우** (lookup/집계/Top-1)

### 캐싱 효과가 약화되는 조건

- NDV가 **거의 외부 행 수와 동일한 경우** (매번 새로운 키)
- 서브쿼리가 **비결정적 표현식**을 포함하는 경우
- 원격 테이블, LOB, 복잡한 사용자 함수로 **비용 대비 적중률이 낮은** 경우
  (버전 및 상황에 따라 정책이 다를 수 있습니다)

### 캐싱 효과 실습(함수 호출 카운터)

스칼라 캐싱이 실제로 발생하는지 확인하는 가장 확실한 방법입니다.

```sql
-- 호출 카운터 패키지 생성
CREATE OR REPLACE PACKAGE call_cnt_pkg AS
  g_cnt NUMBER := 0;
  FUNCTION f(p NUMBER) RETURN NUMBER;
END;
/

CREATE OR REPLACE PACKAGE BODY call_cnt_pkg AS
  FUNCTION f(p NUMBER) RETURN NUMBER IS
  BEGIN
    g_cnt := g_cnt + 1;
    RETURN p;
  END;
END;
/

-- 캐시 가능한 상황(상관키 반복)
BEGIN call_cnt_pkg.g_cnt := 0; END;
/

SELECT c.region,
       (SELECT call_cnt_pkg.f(MAX(o.amount))
        FROM   ORD o
        WHERE  o.cust_id=c.cust_id) AS max_amt
FROM   CUST c
WHERE  c.region IN ('KOR','JPN','APAC');  -- 특정 리전만: cust_id 반복↑

SELECT call_cnt_pkg.g_cnt AS func_calls FROM dual;
```

**func_calls** 값이 외부 행 수보다 훨씬 작다면 캐시 적중의 간접 증거입니다.

> **주의사항**  
> - 캐싱은 항상 100% 보장되지 않습니다.
> - 언네스팅이 발생하여 조인으로 변환되면, 이 실험의 해석이 달라집니다.
> - 이 실습은 "캐시가 **가능한 구조인지** 확인"하는 용도로 이해하세요.

---

## "두 개 이상의 값을 한 번에" 가져오는 패턴

스칼라 서브쿼리는 **1개의 컬럼만 반환** 가능합니다. 따라서 여러 값을 가져오려면 **구조를 변경**해야 합니다.

### 상관 인라인 뷰 + 조인(가장 안정적인 방법)

```sql
WITH LAST_ORDER AS (
  SELECT o.cust_id,
         MAX(o.order_dt) KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_dt,
         MAX(o.amount)   KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_amt,
         MAX(o.status)   KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_status
  FROM   ORD o
  GROUP  BY o.cust_id
)
SELECT c.cust_id, c.name,
       lo.last_dt, lo.last_amt, lo.last_status,
       s.cnt_90d, s.sum_90d
FROM   CUST c
LEFT   JOIN LAST_ORDER lo ON lo.cust_id=c.cust_id
LEFT   JOIN OSTAT      s  ON s.cust_id=c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 100 ROWS ONLY;
```

**장점**  
- 한 번의 조인으로 다중 컬럼 획득 가능
- 조인 방식과 순서를 CBO가 자유롭게 최적화
- 실행계획 예측성이 가장 높음

### LATERAL / CROSS APPLY / OUTER APPLY (Oracle 12c+)

Oracle 12c부터 지원되는 **LATERAL 인라인 뷰**, `CROSS APPLY`, `OUTER APPLY`는 "왼쪽 행 1건당 오른쪽에서 여러 컬럼을 **동시에 계산**"하는 데 최적입니다.

#### CROSS APPLY: 매칭 없으면 왼쪽 행 제외

```sql
SELECT c.cust_id, c.name,
       v.last_dt, v.last_amt, v.last_status
FROM   CUST c
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(o IX_ORD_CUST) */
         o.order_dt AS last_dt,
         o.amount   AS last_amt,
         o.status   AS last_status
  FROM   ORD o
  WHERE  o.cust_id = c.cust_id
  ORDER  BY o.order_dt DESC
  FETCH FIRST 1 ROWS ONLY
) v
WHERE  c.tier='VIP'
FETCH FIRST 50 ROWS ONLY;
```

**장점**  
- "최근 1건"을 **Stopkey로 매우 효율적**으로 조회
- 스칼라 서브쿼리를 여러 개로 분리하지 않아도 되어 **가독성, 성능, 안정성**이 모두 우수

#### OUTER APPLY: 매칭 없으면 NULL로 보존

```sql
SELECT c.cust_id, c.name,
       v.last_dt, v.last_amt, v.last_status
FROM   CUST c
OUTER APPLY (
  SELECT /*+ INDEX_DESC(o IX_ORD_CUST) */
         o.order_dt AS last_dt,
         o.amount   AS last_amt,
         o.status   AS last_status
  FROM   ORD o
  WHERE  o.cust_id = c.cust_id
  ORDER  BY o.order_dt DESC
  FETCH FIRST 1 ROWS ONLY
) v
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 50 ROWS ONLY;
```

LEFT JOIN과 동일한 의미로, "매칭되는 행이 없으면 NULL"로 처리됩니다.

### JSON/오브젝트 집약으로 스칼라화(응용, 권장도 낮음)

여러 값을 JSON 하나로 묶어 반환한 후 바깥에서 파싱하는 방법입니다.

```sql
SELECT c.cust_id,
       JSON_VALUE(j.doc, '$.last_dt'   RETURNING DATE)   AS last_dt,
       JSON_VALUE(j.doc, '$.last_amt'  RETURNING NUMBER) AS last_amt,
       JSON_VALUE(j.doc, '$.last_status')                AS last_status
FROM   CUST c
CROSS  APPLY (
  SELECT JSON_OBJECT(
           'last_dt'     VALUE o.order_dt,
           'last_amt'    VALUE o.amount,
           'last_status' VALUE o.status
         ) AS doc
  FROM   ORD o
  WHERE  o.cust_id = c.cust_id
  ORDER  BY o.order_dt DESC
  FETCH FIRST 1 ROWS ONLY
) j
WHERE  c.cust_id IN (1,2,3);
```

**단점**  
스칼라 제약은 우회하지만 **JSON 파싱 비용**과 **가독성 저하** 문제가 있습니다. LATERAL/APPLY나 인라인 뷰 조인이 일반적으로 더 나은 선택입니다.

---

## 다중 스칼라 서브쿼리 vs 단일 조인: 위험 요소 분석

### 다중 스칼라 서브쿼리가 위험해지는 조건

1. **NDV가 높아 캐싱이 거의 발생하지 않는 경우**  
   → 스칼라 서브쿼리 3개는 사실상 "서브쿼리 실행 3배"와 동일합니다.

2. **언네스팅이 부분적으로만 발생하여 실행 경로가 혼합되는 경우**  
   → 실행계획 변동성이 증가하고 예측성이 떨어집니다.

3. **동일한 Top-1 조회를 여러 스칼라로 반복하는 경우**  
   → 같은 정렬/인덱스 역순 스캔을 중복 수행합니다.

### 자동 재작성에 의존하지 말아야 할 이유

- Oracle이 다중 스칼라 서브쿼리를 **항상 하나의 조인으로 합쳐주지 않습니다**.
- 통계 정보, 데이터베이스 버전, 힌트, 쿼리 블록 구조에 따라 동작이 달라집니다.

**실전 원칙**  
**"여러 컬럼이 필요하면 스칼라 서브쿼리를 늘리지 말고 구조를 변경하라"**

---

## 실전 성능 최적화 포인트

### 단일 행 보장 확보

스칼라 서브쿼리가 2행 이상 반환할 가능성이 있다면 반드시 다음 중 하나로 단일화를 강제하세요.

- `MAX`/`MIN` 집계 함수 사용
- `FETCH FIRST 1 ROW` 제한
- `KEEP (DENSE_RANK ...)` 분석 함수 활용

### Top-1 조회는 "Stopkey + 인덱스 역순"으로 최적화

`(key, order_dt)` 인덱스가 있을 때:
- `ORDER BY order_dt DESC FETCH FIRST 1 ROW` 패턴을 사용하면 일반적으로 최적의 성능을 얻을 수 있습니다.

### NDV가 높은 경우 조인/적재 구조로 변경

캐싱 적중률이 낮으면 스칼라 서브쿼리는 O(N) 반복 실행이 됩니다. 인라인 뷰나 조인으로 "한 번에" 해결하는 구조로 변경하세요.

### 변환 제어는 최소한으로 사용

`NO_UNNEST`를 남용하면 옵티마이저의 최적화 공간이 제한됩니다. 정말 필요할 때만, 그리고 **특정 쿼리 블록(qb_name)에 한정**하여 사용하세요.

### ALLSTATS로 실제 측정

실행 전후로 E-Rows/A-Rows, Gets, TempSpc, MEMSTATS를 비교하여 "진정한 성능 개선"이 이루어졌는지 확인하세요.

---

## 종합 시나리오: VIP·GOLD 100명에 "최근 주문 + 90일 요약" 추가하기

### LATERAL/APPLY 권장 해법

```sql
SELECT /*+ ORDERED */
       c.cust_id, c.name, c.region, c.tier,
       v.last_dt, v.last_amt, v.last_status,
       s.cnt_90d, s.sum_90d
FROM   CUST c
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(o IX_ORD_CUST) */
         o.order_dt AS last_dt,
         o.amount   AS last_amt,
         o.status   AS last_status
  FROM   ORD o
  WHERE  o.cust_id = c.cust_id
  ORDER  BY o.order_dt DESC
  FETCH FIRST 1 ROWS ONLY
) v
LEFT  JOIN OSTAT s ON s.cust_id = c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 100 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS'
));
```

### 인라인 뷰 조인 해법

```sql
WITH LAST_ORDER AS (
  SELECT o.cust_id,
         MAX(o.order_dt) KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_dt,
         MAX(o.amount)   KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_amt,
         MAX(o.status)   KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_status
  FROM   ORD o
  GROUP  BY o.cust_id
)
SELECT c.cust_id, c.name, lo.last_dt, lo.last_amt, lo.last_status, s.cnt_90d, s.sum_90d
FROM   CUST c
LEFT   JOIN LAST_ORDER lo ON lo.cust_id = c.cust_id
LEFT   JOIN OSTAT      s  ON s.cust_id  = c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 100 ROWS ONLY;
```

### 다중 스칼라 서브쿼리 해법(가독성은 좋지만 의존성 높음)

```sql
SELECT c.cust_id, c.name,
       (SELECT o.order_dt FROM ORD o WHERE o.cust_id = c.cust_id
        ORDER BY o.order_dt DESC FETCH FIRST 1 ROWS ONLY) AS last_dt,
       (SELECT o.amount   FROM ORD o WHERE o.cust_id = c.cust_id
        ORDER BY o.order_dt DESC FETCH FIRST 1 ROWS ONLY) AS last_amt,
       (SELECT o.status   FROM ORD o WHERE o.cust_id = c.cust_id
        ORDER BY o.order_dt DESC FETCH FIRST 1 ROWS ONLY) AS last_status,
       (SELECT s.cnt_90d  FROM OSTAT s WHERE s.cust_id = c.cust_id) AS cnt_90d,
       (SELECT s.sum_90d  FROM OSTAT s WHERE s.cust_id = c.cust_id) AS sum_90d
FROM   CUST c
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 100 ROWS ONLY;
```

**실무 권장 순위**  
LATERAL/APPLY 또는 인라인 뷰 조인 > 다중 스칼라 서브쿼리

---

## 자주 묻는 질문

### Q1. 스칼라 서브쿼리를 여러 번 사용해도 괜찮은가요?

같은 키가 반복되고 캐싱 적중률이 높으면 괜찮을 수 있습니다. 하지만 NDV가 크면 캐싱 효과가 약화되어 **성능이 급격히 저하**될 수 있습니다. 이 경우 인라인 뷰 조인이나 APPLY로 구조를 변경하세요.

### Q2. 캐싱이 발생하지 않는 것 같습니다. 이유가 무엇일까요?

NDV가 높거나, 서브쿼리 내에 비결정적 표현식이 포함되었을 가능성이 높습니다. 또한 언네스팅(조인화)이 발생하여 "캐싱이 필요한 구조 자체가 사라진" 경우도 있습니다.

### Q3. 여러 컬럼을 스칼라 서브쿼리로 가져올 수 없나요?

표준 스칼라 서브쿼리는 불가능합니다. **APPLY/LATERAL 또는 인라인 뷰 조인**으로 설계를 변경하세요.

### Q4. 언네스팅을 강제로 막아야 하는 경우는 언제인가요?

조인화가 오히려 비용을 증가시킨다는 것이 **실측으로 확인된 특수한 경우**에만 고려하세요. 이때는 `NO_UNNEST`를 **해당 서브쿼리에만 국소적으로 적용**하세요.

---

## 결론

스칼라 서브쿼리는 "행당 단일 값"을 추가하는 강력한 표현식입니다. Oracle은 이를 **조인으로 언네스팅**하여 최적화하거나, **반복 키에 대한 캐싱**으로 성능을 향상시킵니다.

**핵심 포인트**  
1. **Top-1/최근 1건 조회**는 `ORDER BY ... DESC FETCH FIRST 1 ROW` + 인덱스 역순 스캔(Stopkey) 패턴이 OLTP 환경에서 최적의 성능을 제공합니다.
2. **여러 값을 한 번에 추가**해야 한다면 **LATERAL/CROSS|OUTER APPLY**나 **상관 인라인 뷰 조인**이 성능과 실행계획 안정성 면에서 가장 안전한 선택입니다.
3. **다중 스칼라 서브쿼리**에 자동 재작성과 캐싱을 맡기면 실행계획이 예측하기 어려워질 수 있습니다. **"다중 값 필요 → 조인/APPLY 구조로 변경"**이 실전에서의 안전한 원칙입니다.
4. 최종 판단은 항상 실측 데이터로: `DBMS_XPLAN ... ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS`를 사용하여 예측 행 수(E-Rows)와 실제 행 수(A-Rows), I/O 비용을 확인하세요.

스칼라 서브쿼리는 적절히 사용할 때 강력한 도구가 되지만, 그 한계와 동작 메커니즘을 이해하고 상황에 맞는 최적의 패턴을 선택하는 것이 전문가의 역량입니다.