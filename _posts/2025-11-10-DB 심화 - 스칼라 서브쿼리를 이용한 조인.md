---
layout: post
title: DB 심화 - 스칼라 서브쿼리를 이용한 조인
date: 2025-11-10 22:25:23 +0900
category: DB 심화
---
# 스칼라 서브쿼리를 이용한 조인 (Oracle 기준)

— **스칼라 서브쿼리 개념** → **조인 대체 패턴** → **스칼라 서브쿼리 캐싱 효과(성능 특성)** → **두 개 이상 값을 “한 번에” 가져오고 싶을 때의 패턴(LATERAL/APPLY, 인라인 뷰, 오브젝트·JSON 집약, 다중 스칼라 서브쿼리 비교)**
모든 예제는 바로 실행 가능한 **DDL/데이터/SQL**을 포함합니다. 실행 후에는
`DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')`
로 실제 실행 통계를 확인하세요.

---

## 실습 환경 준비

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;       -- DBMS_XPLAN ALLSTATS LAST
ALTER SESSION SET workarea_size_policy = AUTO;  -- (정렬/해시 워크에어리어 자동)
```

---

# 스칼라 서브쿼리란?

- **정의**: **단일 스칼라 값**을 반환하는 서브쿼리.
- **사용 위치**: `SELECT` 리스트, `WHERE`, `ORDER BY`, `GROUP BY`(제약 有) 등 **표현식**이 들어갈 수 있는 곳이라면 대부분 가능.
- **반드시** 0개 또는 1개의 **행** *그리고* 정확히 1개의 **컬럼**을 반환해야 함.
  - 행이 없으면 **NULL**로 간주
  - 행이 2개 이상이면 **ORA-01427: single-row subquery returns more than one row**

> 직관
> - “왼쪽 행 하나를 보고 → 오른쪽에서 **필요한 단일 값을 조회**해 붙인다”는 점에서 **조인 대체**로 자주 쓰인다.
> - 옵티마이저는 스칼라 서브쿼리를 **필요시 조인으로 변환**하거나 **결과 캐시**를 통해 반복 계산을 줄이기도 한다(자세한 건 §4).

---

# 실습 스키마

```sql
-- 초기화
DROP TABLE CUST   PURGE;
DROP TABLE ORD    PURGE;
DROP TABLE OSTAT  PURGE;

-- 고객
CREATE TABLE CUST(
  CUST_ID  NUMBER       PRIMARY KEY,
  NAME     VARCHAR2(30) NOT NULL,
  REGION   VARCHAR2(8)  NOT NULL,
  TIER     VARCHAR2(8)  NOT NULL
);

-- 주문 헤더 (고객별 여러 건)
CREATE TABLE ORD(
  ORDER_ID NUMBER       PRIMARY KEY,
  CUST_ID  NUMBER       NOT NULL,
  ORDER_DT DATE         NOT NULL,
  STATUS   VARCHAR2(8)  NOT NULL,
  AMOUNT   NUMBER(10,2) NOT NULL
);

-- 고객별 주문 통계(요약) — 데모용 (없어도 되지만 캐싱 데모에 유용)
CREATE TABLE OSTAT(
  CUST_ID     NUMBER PRIMARY KEY,
  LAST_DT     DATE,
  CNT_90D     NUMBER,
  SUM_90D     NUMBER(12,2)
);

-- 인덱스
CREATE INDEX IX_ORD_CUST ON ORD(CUST_ID, ORDER_DT);

-- 데이터
BEGIN
  FOR c IN 1..10000 LOOP
    INSERT INTO CUST VALUES(
      c,
      'CUST_'||TO_CHAR(c,'FM00000'),
      CASE MOD(c,5) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' WHEN 2 THEN 'AMER' WHEN 3 THEN 'JPN' ELSE 'KOR' END,
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR o IN 1..200000 LOOP
    INSERT INTO ORD VALUES(
      o,
      MOD(o,10000)+1,
      DATE '2024-01-01' + MOD(o,365),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP' ELSE 'DONE' END,
      ROUND(DBMS_RANDOM.VALUE(10,2000),2)
    );
  END LOOP;

  COMMIT;
END;
/

-- 간단 통계 테이블(최근 90일 기준) 채우기: 캐싱 실험용
BEGIN
  INSERT /*+ APPEND */ INTO OSTAT
  SELECT c.cust_id,
         MAX(CASE WHEN o.order_dt >= SYSDATE-90 THEN o.order_dt END) AS last_dt,
         COUNT(CASE WHEN o.order_dt >= SYSDATE-90 THEN 1 END)       AS cnt_90d,
         SUM(CASE WHEN o.order_dt >= SYSDATE-90 THEN o.amount END)  AS sum_90d
  FROM   CUST c
  LEFT   JOIN ORD o ON o.cust_id = c.cust_id
  GROUP  BY c.cust_id;
  COMMIT;

  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OSTAT',cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

# 스칼라 서브쿼리로 “조인처럼” 쓰기

## SELECT 리스트에서의 사용 (가장 흔함)

> “각 고객에 대해 최근 주문일(단일 값)을 붙이고 싶다.”

### 스칼라 서브쿼리

```sql
SELECT /*+ ORDERED */
       c.cust_id, c.name, c.region, c.tier,
       ( SELECT MAX(o.order_dt)
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
       ) AS last_order_dt
FROM   CUST c
WHERE  c.region = 'KOR'
FETCH FIRST 20 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE'));
```

- 서브쿼리는 **고객별** `MAX(order_dt)` → **단일 값**이므로 스칼라로 적합.
- 옵티마이저는 이를 **`GROUP BY` + `LEFT JOIN`** 형태로 변환하거나 **NL/해시로 상응 조인**을 택할 수 있다.

### 조인으로 직접 표현(동등 의미)

```sql
SELECT c.cust_id, c.name, c.region, c.tier, x.last_order_dt
FROM   CUST c
LEFT   JOIN (
         SELECT o.cust_id, MAX(o.order_dt) AS last_order_dt
         FROM   ORD o
         GROUP  BY o.cust_id
       ) x
       ON x.cust_id = c.cust_id
WHERE  c.region = 'KOR'
FETCH FIRST 20 ROWS ONLY;
```

> 어느 쪽이 더 빠르냐는 **데이터 분포/인덱스/통계**에 따라 다름.
> **스칼라 서브쿼리**는 **가독성**이 좋아지고, **옵티마이저가 조인으로 재작성**할 여지가 많다.

---

## WHERE 절에서의 사용 (필터로 활용)

> “최근 90일 이내 주문이 있는 고객만”

```sql
SELECT c.cust_id, c.name
FROM   CUST c
WHERE  ( SELECT MAX(o.order_dt)
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
       ) >= SYSDATE - 90;
```

- 해당 스칼라 서브쿼리는 고객마다 한 번씩 실행되는 **상관 서브쿼리**처럼 보이지만,
  옵티마이저가 **세미 조인**(EXISTS)으로 재작성할 수 있다.

---

# 스칼라 서브쿼리 **캐싱 효과**(Scalar Subquery Caching)

## 개념

- **상관 스칼라 서브쿼리**의 **입력 키**(여기서는 `cust_id`)가 **반복**되면,
  실행 엔진은 **이전 계산 결과를 캐시에 저장**했다가 **같은 입력**에 대해 **재계산을 생략**할 수 있다.
- 캐시는 **쿼리 실행 컨텍스트 내**에서 동작하며, **입력 값 조합 → 결과 값**을 **해시 맵**처럼 보관.

## 캐싱이 잘 작동하는 패턴

- **입력 값의 종류(NDV)**가 **상대적으로 적고** 반복 출현이 많을 때
- 서브쿼리가 **실제로 같은 값**을 반복 반환할 때(참조 테이블이 작거나, 서브쿼리가 요약 테이블/디멘전 룩업)

## 캐싱이 약하거나 비활성화되는 경우(일반적 경향)

- 입력의 **NDV가 매우 큼**(거의 매번 새로운 키)
- 서브쿼리 내부가 **비결정적**(예: `DBMS_RANDOM`, `SYSDATE` 직접 사용, `ROWNUM`, 현재 SCN 의존 등)
- LOB, 복잡한 함수/원격 액세스 등 **비용이 크고 캐시 적중률이 낮은** 형태
- **DML 동시 발생**으로 결과 안정성 보장이 어려운 경우(상황과 버전에 따라 다름)

## 캐싱 체감 예시

> OSTAT(요약 테이블)을 스칼라 서브쿼리로 참조: **같은 고객 키**가 반복되면 캐시 히트↑

```sql
-- 지역/등급별 고객을 많이 읽으며, 각 고객에 대해 OSTAT에서 단일 값들 조회
SELECT /*+ ORDERED */
       c.cust_id, c.name, c.region, c.tier,
       (SELECT s.last_dt FROM OSTAT s WHERE s.cust_id = c.cust_id) AS last_dt,
       (SELECT s.cnt_90d FROM OSTAT s WHERE s.cust_id = c.cust_id) AS cnt_90d,
       (SELECT s.sum_90d FROM OSTAT s WHERE s.cust_id = c.cust_id) AS sum_90d
FROM   CUST c
WHERE  c.region IN ('APAC','KOR','JPN')
FETCH FIRST 2000 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS'));
```

- 위처럼 **동일 키에 대해 여러 스칼라 서브쿼리**를 쓰면, 옵티마이저가 **조인으로 재작성**하기도 한다.
- 또, **같은 스칼라 서브쿼리**가 **반복 호출**되더라도 **캐시**가 적용돼 **실제 탐색 횟수**를 줄일 수 있다.
  (실제 히트율은 환경·버전별로 다르므로 **플랜/통계**로 확인)

> **실무 팁**
> - **가능하면 하나의 스칼라 서브쿼리로 여러 값을 동시에** 가져오고 싶지만(§5에서 다룸)
>   SQL 표준 스칼라 서브쿼리는 **오직 한 컬럼**만 반환 가능 → **조인/인라인 뷰/LATERAL**로 구조화하는 편이 예측 가능.

---

# “두 개 이상 값을 한 번에” 가져오고 싶을 때

스칼라 서브쿼리는 **1컬럼**만 반환 가능하므로, **여러 컬럼**을 붙이려면 다음 중 하나를 선택합니다.

## **인라인 뷰(코릴레이티드)** + 조인 (권장, 가장 직관)

```sql
SELECT c.cust_id, c.name, x.last_dt, x.cnt_90d, x.sum_90d
FROM   CUST c
LEFT   JOIN (
         SELECT s.cust_id, s.last_dt, s.cnt_90d, s.sum_90d
         FROM   OSTAT s
       ) x
       ON x.cust_id = c.cust_id
WHERE  c.region = 'APAC'
FETCH FIRST 100 ROWS ONLY;
```
- **한 번의 조인**으로 **여러 컬럼**을 가져옴.
- 옵티마이저가 **해시/NL/SMJ** 중 최적을 선택.
- **가장 일반적이고 안정적인 패턴**.

## **LATERAL / CROSS APPLY / OUTER APPLY** (Oracle 12c+)

- 오른쪽 인라인 뷰가 **왼쪽 테이블 컬럼을 참조**할 수 있는 **상관 인라인 뷰**.
- “왼쪽 행 1건당 오른쪽에서 여러 값을 **동시에 계산**해서 붙이기”에 적합.

```sql
-- 고객별 '최근 주문일·최근 주문금액·최근 상태'를 한 번에
SELECT c.cust_id, c.name, v.last_dt, v.last_amt, v.last_status
FROM   CUST c
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(o IX_ORD_CUST) */        -- (cust_id, order_dt) 역순 인덱스 스캔으로 최근 1건
         o.order_dt   AS last_dt,
         o.amount     AS last_amt,
         o.status     AS last_status
  FROM   ORD o
  WHERE  o.cust_id = c.cust_id
  FETCH FIRST 1 ROWS ONLY
) v
WHERE  c.tier = 'VIP'
FETCH FIRST 50 ROWS ONLY;
```

- `CROSS APPLY`: 매칭이 없으면 해당 왼쪽 행은 **제외**(세미 조인 성격).
- `OUTER APPLY`: 매칭이 없으면 **NULL** 채워 보존(LEFT OUTER 성격).
- **장점**: **여러 컬럼**을 **한 번에** 계산/반환, **Top-N/부분범위**(인덱스 역순)와 결합해 **아주 효율적**.

```sql
-- 배송이 없어도 보존(LEFT OUTER 성격) — 최근 배송 정보 1건
SELECT o.order_id, v.ship_dt, v.carrier
FROM   ORD o
OUTER  APPLY (
  SELECT /*+ INDEX_DESC(s IX_SHP_ORD) */
         s.ship_dt, s.carrier
  FROM   SHP s
  WHERE  s.order_id = o.order_id
  FETCH FIRST 1 ROWS ONLY
) v
WHERE  o.cust_id = 10
ORDER  BY o.order_dt DESC
FETCH FIRST 10 ROWS ONLY;
```

## **JSON/집계(Function)로 묶어서 한 컬럼로 반환 후 파싱** (응용)

- 여러 값을 **하나의 문자열/JSON**으로 만들어 **스칼라**로 반환 → **외부에서 분해**.
- 장점: “스칼라 제약”을 회피. 단점: **파싱 비용/가독성 저하**.

```sql
-- JSON_OBJECT로 합쳐서 스칼라 반환 후 외부에서 JSON_VALUE로 분해 가능
SELECT c.cust_id,
       JSON_VALUE(j.doc, '$.last_dt'   RETURNING DATE)   AS last_dt,
       JSON_VALUE(j.doc, '$.cnt_90d'   RETURNING NUMBER) AS cnt_90d,
       JSON_VALUE(j.doc, '$.sum_90d'   RETURNING NUMBER) AS sum_90d
FROM   CUST c
CROSS  APPLY (
  SELECT JSON_OBJECT(
           'last_dt' VALUE s.last_dt,
           'cnt_90d' VALUE s.cnt_90d,
           'sum_90d' VALUE s.sum_90d
         ) AS doc
  FROM   OSTAT s
  WHERE  s.cust_id = c.cust_id
) j
WHERE  c.cust_id IN (1,2,3);
```

> 실무에서는 **LATERAL/APPLY** 또는 **인라인 뷰 조인**을 더 많이 권장.

## **다중 스칼라 서브쿼리 vs 한 번의 조인**

- 같은 키로 **스칼라 서브쿼리를 3개** 호출하는 것과, **한 번 조인**으로 3컬럼을 받는 것은
  옵티마이저가 **재작성**해 동등 플랜을 만들 때도 있지만, **항상** 그러진 않음.
- **일관된 성능/예측성**이 중요하면 **한 번의 조인**(또는 LATERAL/APPLY)로 **여러 값**을 받는 편이 안전.

---

# 스칼라 서브쿼리 성능 체크·튜닝 포인트

1) **유일성 보장**
   - 스칼라 서브쿼리는 **단일 행**만 반환해야 함.
   - `MAX`, `MIN`, `FETCH FIRST 1 ROW`(정렬/인덱스와 함께)로 **단일화** 보장.
   - **유니크 인덱스**가 있으면 옵티마이저가 **빠른 유일 검색**을 선택.

2) **카디널리티/NDV와 캐시 적중률**
   - 같은 입력 키가 반복될수록 **캐시 적중**으로 이득.
   - NDV가 매우 크면 **조인으로 재작성**하는 편이 예측 가능.

3) **인덱스/정렬 흡수 + Stopkey**
   - 최근 1건/Top-1 패턴이면 **역순 인덱스 + `FETCH FIRST 1 ROW`**로 **랜덤 I/O 최소화**.

4) **옵티마이저 재작성 이해**
   - 스칼라 서브쿼리는 종종 **조인**으로 바뀐다. 플랜에서 `HASH JOIN`/`NESTED LOOPS`가 보이면 그 신호.
   - `DBMS_XPLAN ... +PREDICATE`로 전개된 조건을 확인.

5) **동시성/변경 가능성**
   - 실행 중 **참조 테이블이 변경**되어도 읽기 일관성 하에 정상 동작하나,
     캐시된 결과의 **일시적 차이**는 옵티마이저/버전별 내부 정책에 좌우(보통 쿼리 단위 일관성 유지).

6) **비결정적 표현은 피하기**
   - `DBMS_RANDOM`, `SYSTIMESTAMP` 직접 호출 등은 **캐싱 이점**을 약화.
   - 필요하면 값들을 미리 구해 바인드로 전달하거나, 해당 표현을 **바깥쪽에서 한 번만** 계산.

---

# 종합 예제 시나리오

## “VIP·GOLD 고객 100명에 대해: 최근 주문일, 최근 주문금액, 90일 주문수·합계”를 붙여라

### LATERAL/APPLY (권장)

```sql
SELECT /*+ ORDERED */
       c.cust_id, c.name, c.region, c.tier,
       v.last_dt, v.last_amt, v.last_status,
       s.cnt_90d, s.sum_90d
FROM   CUST c
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(o IX_ORD_CUST) */
         o.order_dt AS last_dt,
         o.amount   AS last_amt,
         o.status   AS last_status
  FROM   ORD o
  WHERE  o.cust_id = c.cust_id
  FETCH FIRST 1 ROWS ONLY
) v
LEFT  JOIN OSTAT s
       ON s.cust_id = c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 100 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS'));
```

### 인라인 뷰 조인

```sql
WITH LAST_ORDER AS (
  SELECT o.cust_id,
         MAX(o.order_dt) KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_dt,
         MAX(o.amount) KEEP (DENSE_RANK LAST ORDER BY o.order_dt)   AS last_amt,
         MAX(o.status) KEEP (DENSE_RANK LAST ORDER BY o.order_dt)   AS last_status
  FROM   ORD o
  GROUP  BY o.cust_id
)
SELECT c.cust_id, c.name, lo.last_dt, lo.last_amt, lo.last_status, s.cnt_90d, s.sum_90d
FROM   CUST c
LEFT   JOIN LAST_ORDER lo ON lo.cust_id = c.cust_id
LEFT   JOIN OSTAT      s  ON s.cust_id  = c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 100 ROWS ONLY;
```

### 다중 스칼라 서브쿼리(가독성 좋지만, 재작성/캐시 의존)

```sql
SELECT c.cust_id, c.name,
       (SELECT o.order_dt FROM ORD o WHERE o.cust_id = c.cust_id ORDER BY o.order_dt DESC FETCH FIRST 1 ROWS ONLY) AS last_dt,
       (SELECT o.amount   FROM ORD o WHERE o.cust_id = c.cust_id ORDER BY o.order_dt DESC FETCH FIRST 1 ROWS ONLY) AS last_amt,
       (SELECT o.status   FROM ORD o WHERE o.cust_id = c.cust_id ORDER BY o.order_dt DESC FETCH FIRST 1 ROWS ONLY) AS last_status,
       (SELECT s.cnt_90d  FROM OSTAT s  WHERE s.cust_id = c.cust_id) AS cnt_90d,
       (SELECT s.sum_90d  FROM OSTAT s  WHERE s.cust_id = c.cust_id) AS sum_90d
FROM   CUST c
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 100 ROWS ONLY;
```

> **실무 권장 순위**: LATERAL/APPLY 또는 인라인 뷰 조인 ＞ 다중 스칼라 서브쿼리.
> 이유: **예측 가능성/플랜 안정성**과 **한 번에 여러 컬럼**을 붙이는 구조 때문.

---

# 자주 하는 질문(FAQ)

**Q1. 스칼라 서브쿼리를 여러 번 써도 성능 괜찮나요?**
A. **입력 키가 반복**되고 서브쿼리 결과가 **캐시**되면 괜찮은 경우가 많습니다. 그러나 **NDV가 매우 크면** 캐시 적중률이 떨어져 **조인화**가 더 안정적입니다.

**Q2. 스칼라 서브쿼리 내부에서 `ROWNUM=1` vs `FETCH FIRST 1 ROW` 차이는?**
A. 현대 버전에선 `FETCH FIRST 1 ROWS ONLY`가 더 **의도 명확**하고 옵티마이저도 잘 이해합니다. 인덱스 역순 스캔과 결합하십시오.

**Q3. “두 값 이상”을 스칼라로 받으려면?**
A. 스칼라 제약 때문에 표준 SQL에서는 **불가**. 대신
- **LATERAL/APPLY**(가장 깔끔),
- **인라인 뷰 조인**,
- JSON/문자열로 묶었다가 파싱(권장 X) 중 하나를 쓰세요.

**Q4. 캐싱이 안 되는 것 같아요.**
A. 입력 NDV가 크거나 비결정성 표현이 섞였을 수 있습니다. **인라인 뷰 조인**으로 구조 변경해 보세요.

---

# 체크리스트 (현장용)

- [ ] 스칼라 서브쿼리가 **단일 값**을 반환함이 보장되는가? (유니크/집계/Top-1)
- [ ] 입력 **NDV**는 낮고 반복 출현이 많은가? (캐시 적합)
- [ ] **역순 인덱스 + Stopkey**로 Top-1을 빠르게 구했는가?
- [ ] 여러 컬럼을 붙여야 한다면 **LATERAL/APPLY** 또는 **인라인 뷰 조인**으로 바꿨는가?
- [ ] 옵티마이저가 **조인으로 재작성**했는지 `DBMS_XPLAN +PREDICATE`로 확인했는가?
- [ ] **ALLSTATS LAST +IOSTATS**로 전/후 I/O 비교했는가?
- [ ] 플랜 안정성을 위해 필요 시 **LEADING/USE_NL/USE_HASH** 등을 검토했는가?

---

## 확인 스니펫

```sql
-- 현재 SQL의 플랜/통계
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')
);

-- 스칼라 서브쿼리로 보였던 것이 실제 조인으로 재작성되었는지 확인
SELECT sql_id, child_number, id, operation, options, object_name
FROM   v$sql_plan
WHERE  sql_id = :sql_id
ORDER  BY id;
```

---

### 요약

- **스칼라 서브쿼리**는 “행당 단일 값”을 붙이는 매우 **표현력 좋은 도구**다.
- **캐싱 효과** 덕분에 **반복 키**에서는 비용이 낮지만, **NDV가 큰 경우**엔 **조인 구조**가 예측 가능하고 빠르다.
- **여러 컬럼**을 한번에 가져오고 싶다면 **LATERAL/CROSS|OUTER APPLY**나 **인라인 뷰 조인**을 활용하라.
- 항상 `DBMS_XPLAN`으로 **플랜/통계**를 확인해 실제 성능을 검증할 것.
