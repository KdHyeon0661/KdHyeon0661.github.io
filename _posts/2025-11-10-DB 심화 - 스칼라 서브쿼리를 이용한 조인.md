---
layout: post
title: DB 심화 - 스칼라 서브쿼리를 이용한 조인
date: 2025-11-10 22:25:23 +0900
category: DB 심화
---
# 스칼라 서브쿼리를 이용한 조인

> 목표  
> - 스칼라 서브쿼리(Scalar Subquery)를 **조인 대체/보완 수단**으로 쓸 때의 **개념·변환·성능 특성·실전 패턴**을 “한 번에” 정리한다.
> - 특히 **스칼라 서브쿼리 캐싱 효과**, **서브쿼리 언네스팅(조인화) 변환**, **LATERAL/APPLY로 다중 컬럼을 한 번에 가져오는 방식**, **다중 스칼라 서브쿼리의 위험과 대안**을 재현 가능한 실습으로 확인한다.  
>
> 실행 후에는 반드시 아래로 **실측 플랜/통계**를 확인하자.
```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'
));
```

---

## 0) 왜 스칼라 서브쿼리를 “조인처럼” 쓰는가

스칼라 서브쿼리는 SQL에서 **표현식 자리에 들어가는 단일 값**을 만들기 위한 도구다.  
하지만 실무에서는 다음 이유로 “조인 대체” 또는 “조인 보완”으로 매우 자주 쓰인다.

1) **가독성**  
   - “왼쪽 행 하나를 보고, 오른쪽에서 필요한 값 **하나만** 붙인다”는 의도가 직관적이다.  
   - 복잡한 `LEFT JOIN + GROUP BY`를 한 줄로 줄일 수 있다.

2) **Top-N/최근 1건 조회**에 강함  
   - `ORDER BY ... FETCH FIRST 1 ROW`(Stopkey) + 인덱스 역순 스캔과 붙이면 **OLTP에서 폭발적으로 빠른 패턴**이 된다.

3) **CBO가 조인으로 재작성(Scalar Subquery Unnesting/Decorrelate)**  
   - Oracle 옵티마이저는 스칼라 서브쿼리를 **조인으로 풀어 최적화 공간을 넓히는 변환**을 수행할 수 있다. :contentReference[oaicite:0]{index=0}  
   - 따라서 “표현식”으로 쓰되, 내부적으로는 조인처럼 최적화되는 경우가 많다.

4) **Scalar Subquery Caching**  
   - 상관 스칼라 서브쿼리가 **같은 입력 키를 반복**해서 받을 때, Oracle 실행 엔진이 결과를 캐시해 재사용한다. :contentReference[oaicite:1]{index=1}  
   - 반복 키가 많은 조회(예: 차원 룩업, 요약 테이블 참조)에서 **NL 조인보다 더 싸게** 느껴질 때가 있다.

단, 이 장점들이 항상 자동으로 발휘되는 건 아니다.  
**단일 행 보장 실패**, **NDV 과대**, **비결정적 표현**, **스큐/통계 오판**, **다중 컬럼 요구** 같은 현실 문제를 정확히 다뤄야 한다.

---

## 1) 실습 환경 준비

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;
ALTER SESSION SET workarea_size_policy = AUTO;
```

---

## 2) 실습 스키마/데이터

> 아래 DDL/데이터는 그대로 복붙 실행 가능.  
> 캐싱/Top-N/조인화 변환/LATERAL 데모를 위해 **고객 1만**, **주문 20만**, **요약(OSTAT)** 테이블을 만든다.

```sql
-- 초기화
DROP TABLE CUST   PURGE;
DROP TABLE ORD    PURGE;
DROP TABLE OSTAT  PURGE;

-- 고객
CREATE TABLE CUST(
  CUST_ID  NUMBER       PRIMARY KEY,
  NAME     VARCHAR2(30) NOT NULL,
  REGION   VARCHAR2(8)  NOT NULL,
  TIER     VARCHAR2(8)  NOT NULL
);

-- 주문 헤더
CREATE TABLE ORD(
  ORDER_ID NUMBER       PRIMARY KEY,
  CUST_ID  NUMBER       NOT NULL,
  ORDER_DT DATE         NOT NULL,
  STATUS   VARCHAR2(8)  NOT NULL,
  AMOUNT   NUMBER(10,2) NOT NULL
);

-- 고객별 주문 요약(데모용)
CREATE TABLE OSTAT(
  CUST_ID     NUMBER PRIMARY KEY,
  LAST_DT     DATE,
  CNT_90D     NUMBER,
  SUM_90D     NUMBER(12,2)
);

-- 인덱스: 고객별 최근 주문 Top-1을 위해 (CUST_ID, ORDER_DT) 필요
CREATE INDEX IX_ORD_CUST ON ORD(CUST_ID, ORDER_DT);

-- 데이터
BEGIN
  FOR c IN 1..10000 LOOP
    INSERT INTO CUST VALUES(
      c,
      'CUST_'||TO_CHAR(c,'FM00000'),
      CASE MOD(c,5)
        WHEN 0 THEN 'APAC'
        WHEN 1 THEN 'EMEA'
        WHEN 2 THEN 'AMER'
        WHEN 3 THEN 'JPN'
        ELSE 'KOR'
      END,
      CASE MOD(c,4)
        WHEN 0 THEN 'VIP'
        WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER'
        ELSE 'GEN'
      END
    );
  END LOOP;

  FOR o IN 1..200000 LOOP
    INSERT INTO ORD VALUES(
      o,
      MOD(o,10000)+1,
      DATE '2024-01-01' + MOD(o,365),
      CASE MOD(o,4)
        WHEN 0 THEN 'NEW'
        WHEN 1 THEN 'PAID'
        WHEN 2 THEN 'SHIP'
        ELSE 'DONE'
      END,
      ROUND(DBMS_RANDOM.VALUE(10,2000),2)
    );
  END LOOP;

  COMMIT;
END;
/

-- OSTAT 채우기(최근 90일)
BEGIN
  INSERT /*+ APPEND */ INTO OSTAT
  SELECT c.cust_id,
         MAX(CASE WHEN o.order_dt >= SYSDATE-90 THEN o.order_dt END) AS last_dt,
         COUNT(CASE WHEN o.order_dt >= SYSDATE-90 THEN 1 END)       AS cnt_90d,
         SUM(CASE WHEN o.order_dt >= SYSDATE-90 THEN o.amount END)  AS sum_90d
  FROM   CUST c
  LEFT   JOIN ORD o ON o.cust_id = c.cust_id
  GROUP  BY c.cust_id;

  COMMIT;

  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OSTAT',cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

## 3) 스칼라 서브쿼리의 정의와 제약

### 3.1 정의
- **정확히 1컬럼**을 반환하는 서브쿼리.
- 반환 행수는 **0 또는 1행**이어야 한다.
  - 0행 → NULL
  - 2행 이상 → ORA-01427 발생

### 3.2 단일 행 보장 패턴

1) **집계로 단일화**
```sql
(SELECT MAX(o.order_dt) FROM ORD o WHERE o.cust_id = c.cust_id)
```

2) **Top-1로 단일화**
```sql
(SELECT o.amount
 FROM   ORD o
 WHERE  o.cust_id = c.cust_id
 ORDER  BY o.order_dt DESC
 FETCH FIRST 1 ROWS ONLY)
```

3) **유니크/PK 기반**
```sql
(SELECT name FROM CUST c2 WHERE c2.cust_id = o.cust_id)
```

---

## 4) “조인처럼” 쓰는 핵심 패턴들

### 4.1 SELECT 리스트 룩업(단일 값 붙이기)

> 고객 목록에 “최근 주문일”을 붙인다.

```sql
SELECT /* scalar lookup */
       c.cust_id, c.name, c.region, c.tier,
       ( SELECT MAX(o.order_dt)
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
       ) AS last_order_dt
FROM   CUST c
WHERE  c.region = 'KOR'
FETCH FIRST 20 ROWS ONLY;
```

- 의미상 `LEFT JOIN (GROUP BY)`와 동일.
- Oracle은 이를 **조인으로 언네스팅**해 최적화할 수 있다. :contentReference[oaicite:2]{index=2}

#### 동등 조인 표현(비교용)

```sql
SELECT c.cust_id, c.name, c.region, c.tier, x.last_order_dt
FROM   CUST c
LEFT   JOIN (
         SELECT o.cust_id, MAX(o.order_dt) AS last_order_dt
         FROM   ORD o
         GROUP  BY o.cust_id
       ) x
       ON x.cust_id = c.cust_id
WHERE  c.region='KOR'
FETCH FIRST 20 ROWS ONLY;
```

**실전 해석**  
- “스칼라가 더 낫다/조인이 더 낫다”는 고정 답이 없다.  
- 옵티마이저가 언네스팅하면 **거의 같은 플랜**이 나올 수 있고,  
  언네스팅하지 않으면 **상관 서브쿼리 실행 + 캐싱** 루트로 갈 수도 있다.

---

### 4.2 WHERE 절 필터(세미 조인 대체)

> 최근 90일 주문이 있는 고객만.

```sql
SELECT /* scalar filter */
       c.cust_id, c.name
FROM   CUST c
WHERE  ( SELECT MAX(o.order_dt)
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
       ) >= SYSDATE - 90;
```

- 논리적으로는 “최근 주문일이 90일 내에 존재” → EXISTS와 동치.
- Oracle은 이 패턴을 **SEMI JOIN/ANTI JOIN으로 재작성**할 수 있다. :contentReference[oaicite:3]{index=3}

#### EXISTS로 직접 표현

```sql
SELECT c.cust_id, c.name
FROM   CUST c
WHERE  EXISTS (
         SELECT 1
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
         AND    o.order_dt >= SYSDATE-90
       );
```

**언제 스칼라가 유리한가**  
- “필터 조건이 집계 결과(예: MAX, SUM)”처럼 자연스럽게 정의될 때.
- 가독성 개선 + 언네스팅 여지 확보.

---

### 4.3 Top-1/최근 1건 추가(OLTP 킬러 패턴)

> VIP 고객에게 “가장 최근 주문 1건의 날짜/금액/상태”를 붙인다.

```sql
SELECT c.cust_id, c.name,
       ( SELECT o.order_dt
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
         ORDER  BY o.order_dt DESC
         FETCH FIRST 1 ROWS ONLY
       ) AS last_dt,
       ( SELECT o.amount
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
         ORDER  BY o.order_dt DESC
         FETCH FIRST 1 ROWS ONLY
       ) AS last_amt
FROM   CUST c
WHERE  c.tier = 'VIP'
FETCH FIRST 50 ROWS ONLY;
```

- 인덱스가 `(cust_id, order_dt)`면 내부적으로 **Index Range Scan Desc + Stopkey**가 나와야 한다.
- 다중 스칼라가 **조인으로 재작성되기도** 하지만, 재작성에 의존하면 플랜 안정성이 떨어질 수 있으니 §7에서 대안 제시.

---

### 4.4 UPDATE/INSERT에서의 스칼라 룩업

> ORD의 STATUS를 “고객 등급 기준”으로 보정한다고 가정.

```sql
UPDATE ORD o
SET    o.status =
       ( SELECT CASE c.tier
                  WHEN 'VIP'  THEN 'VIP_NEW'
                  WHEN 'GOLD' THEN 'G_NEW'
                  ELSE 'NEW'
                END
         FROM   CUST c
         WHERE  c.cust_id = o.cust_id
       )
WHERE  o.order_dt >= DATE '2024-07-01';
```

- **행당 단일 값 룩업** → 스칼라 서브쿼리의 전형적인 사용 위치.
- 내부적으로는 조인/머지로 재작성될 수 있음.

---

## 5) 옵티마이저 관점: 스칼라 서브쿼리 변환

### 5.1 Scalar Subquery Unnesting(조인화 변환)

Oracle의 서브쿼리 변환 중 하나가 **UNNEST**다.  
스칼라 서브쿼리를 **외부 쿼리블록과 합쳐 조인으로 변환**해  
조인순서/조인방식/액세스 경로 탐색 공간을 넓힌다. :contentReference[oaicite:4]{index=4}

#### 전형적 변환 예

원형:
```sql
SELECT c.cust_id,
       (SELECT MAX(o.amount) FROM ORD o WHERE o.cust_id=c.cust_id) AS max_amt
FROM   CUST c;
```

CBO 내부 변환(개념):
```sql
SELECT c.cust_id, x.max_amt
FROM   CUST c
LEFT JOIN (
  SELECT cust_id, MAX(amount) max_amt
  FROM   ORD
  GROUP  BY cust_id
) x ON x.cust_id=c.cust_id;
```

### 5.2 변환이 “안 되는/안 하는” 대표 조건

- 서브쿼리가 **비결정적/부수효과 함수**를 포함  
  (예: `DBMS_RANDOM`, `SYSTIMESTAMP` 직접 사용 등)
- 서브쿼리에 **ROWNUM/수평 스캔 의존** 패턴이 있고, 조인화가 의미가 달라지는 경우
- 옵티마이저가 비용상 “그냥 상관 실행 + 캐시”가 더 낫다고 판단한 경우
- 힌트로 막았을 때

### 5.3 변환 제어 힌트

- `UNNEST` / `NO_UNNEST`  
  - 서브쿼리를 조인으로 풀지/말지 제어. :contentReference[oaicite:5]{index=5}
- `PUSH_SUBQ` / `NO_PUSH_SUBQ`  
  - 언네스팅되지 않은 서브쿼리를 **언제 평가할지(상위/하위 단계)** 제어.  
  - `PUSH_SUBQ`는 보통 `NO_UNNEST`와 세트로 쓰인다. :contentReference[oaicite:6]{index=6}

예시(언네스팅 억제):

```sql
SELECT c.cust_id,
       (SELECT /*+ NO_UNNEST */ MAX(o.amount)
        FROM   ORD o
        WHERE  o.cust_id=c.cust_id) AS max_amt
FROM   CUST c;
```

예시(푸시 강제):

```sql
SELECT /*+ NO_UNNEST PUSH_SUBQ */
       c.cust_id
FROM   CUST c
WHERE  c.cust_id IN (
         SELECT /*+ qb_name(sq) */ o.cust_id
         FROM   ORD o
         WHERE  o.order_dt >= SYSDATE-30
       );
```

---

## 6) Scalar Subquery Caching(스칼라 서브쿼리 캐싱)

### 6.1 캐싱 메커니즘

Oracle 실행 엔진은 **상관 스칼라 서브쿼리의 입력 값(상관 키)**이 반복될 때  
결과를 **쿼리 실행 컨텍스트 내 캐시**에 저장해 재사용한다. :contentReference[oaicite:7]{index=7}

- 캐시는 대략 “입력 키 조합 → 결과 값”의 해시 맵처럼 행동한다.
- **같은 키가 반복될수록** 서브쿼리 실제 실행 횟수가 줄어든다.

### 6.2 캐싱이 잘 먹는 상황

- 상관 키의 **NDV가 낮음**
- 외부 Row Source에서 **같은 키가 다수 반복**
- 서브쿼리 내부 작업이 **짧고 결정적**(lookup/집계/Top-1)

### 6.3 캐싱이 약한/비활성화되는 경향

- NDV가 **거의 외부 행수와 동일**(매번 새로운 키)
- 서브쿼리가 **비결정적 표현** 포함
- 원격/LOB/복잡한 사용자 함수로 **적중률 대비 비용이 큰** 경우  
  (버전/상황별로 정책이 달라질 수 있음)

### 6.4 캐싱 체감 실습(함수 호출 카운터)

> 스칼라 캐싱이 되는지 **눈으로 확인**하는 가장 확실한 방법.

```sql
-- 호출 카운터 패키지
CREATE OR REPLACE PACKAGE call_cnt_pkg AS
  g_cnt NUMBER := 0;
  FUNCTION f(p NUMBER) RETURN NUMBER;
END;
/

CREATE OR REPLACE PACKAGE BODY call_cnt_pkg AS
  FUNCTION f(p NUMBER) RETURN NUMBER IS
  BEGIN
    g_cnt := g_cnt + 1;
    RETURN p;
  END;
END;
/

-- 캐시 가능(상관키 반복) 시나리오
BEGIN call_cnt_pkg.g_cnt := 0; END;
/

SELECT c.region,
       (SELECT call_cnt_pkg.f(MAX(o.amount))
        FROM   ORD o
        WHERE  o.cust_id=c.cust_id) AS max_amt
FROM   CUST c
WHERE  c.region IN ('KOR','JPN','APAC');  -- 특정 리전만: cust_id 반복↑

SELECT call_cnt_pkg.g_cnt AS func_calls FROM dual;
```

- **func_calls**가 “외부 행수보다 훨씬 작다면” 캐시 적중의 간접 증거다.

> 주의  
> - 캐싱은 “항상 100%”가 아니다.  
> - 언네스팅이 일어나 조인으로 바뀌면, 이런 카운터 실험의 해석은 달라진다.  
> - 따라서 이 실습은 “캐시가 **가능한 구조인지** 확인”하는 용도로 이해하자.

---

## 7) “두 개 이상 값을 한 번에” 가져오는 패턴

스칼라 서브쿼리는 **1컬럼만 반환** 가능하다.  
따라서 여러 값을 붙이려면 **구조를 바꿔야** 한다.

### 7.1 상관 인라인 뷰 + 조인(가장 안정적)

```sql
WITH LAST_ORDER AS (
  SELECT o.cust_id,
         MAX(o.order_dt) KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_dt,
         MAX(o.amount)   KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_amt,
         MAX(o.status)   KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_status
  FROM   ORD o
  GROUP  BY o.cust_id
)
SELECT c.cust_id, c.name,
       lo.last_dt, lo.last_amt, lo.last_status,
       s.cnt_90d, s.sum_90d
FROM   CUST c
LEFT   JOIN LAST_ORDER lo ON lo.cust_id=c.cust_id
LEFT   JOIN OSTAT      s  ON s.cust_id=c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 100 ROWS ONLY;
```

- **한 번의 조인으로 다중 컬럼 획득**
- 조인 방식/순서를 CBO가 자유롭게 탐색.
- 플랜 예측성 최고.

### 7.2 LATERAL / CROSS APPLY / OUTER APPLY(Oracle 12c+)

Oracle 12c부터 **LATERAL 인라인 뷰**, `CROSS APPLY`, `OUTER APPLY`가 지원된다. :contentReference[oaicite:8]{index=8}  
이는 “왼쪽 행 1건당 오른쪽에서 여러 컬럼을 **동시에 계산**”하는 데 최적이다.

#### 7.2.1 CROSS APPLY: 매칭 없으면 왼쪽 제거

```sql
SELECT c.cust_id, c.name,
       v.last_dt, v.last_amt, v.last_status
FROM   CUST c
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(o IX_ORD_CUST) */
         o.order_dt AS last_dt,
         o.amount   AS last_amt,
         o.status   AS last_status
  FROM   ORD o
  WHERE  o.cust_id = c.cust_id
  ORDER  BY o.order_dt DESC
  FETCH FIRST 1 ROWS ONLY
) v
WHERE  c.tier='VIP'
FETCH FIRST 50 ROWS ONLY;
```

- “최근 1건”을 **Stopkey로 아주 싸게** 얻는다.
- 조인을 스칼라 3개로 쪼개지 않아도 되므로, **가독성·성능·안정성**이 모두 좋다.

#### 7.2.2 OUTER APPLY: 매칭 없으면 NULL로 보존

```sql
SELECT c.cust_id, c.name,
       v.last_dt, v.last_amt, v.last_status
FROM   CUST c
OUTER APPLY (
  SELECT /*+ INDEX_DESC(o IX_ORD_CUST) */
         o.order_dt AS last_dt,
         o.amount   AS last_amt,
         o.status   AS last_status
  FROM   ORD o
  WHERE  o.cust_id = c.cust_id
  ORDER  BY o.order_dt DESC
  FETCH FIRST 1 ROWS ONLY
) v
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 50 ROWS ONLY;
```

- LEFT JOIN과 같은 의미.
- “없으면 NULL”이 자연스럽다.

### 7.3 JSON/오브젝트 집약으로 스칼라화(응용, 권장도 낮음)

여러 값을 JSON 하나로 묶어 반환 → 바깥에서 파싱.

```sql
SELECT c.cust_id,
       JSON_VALUE(j.doc, '$.last_dt'   RETURNING DATE)   AS last_dt,
       JSON_VALUE(j.doc, '$.last_amt'  RETURNING NUMBER) AS last_amt,
       JSON_VALUE(j.doc, '$.last_status')                AS last_status
FROM   CUST c
CROSS  APPLY (
  SELECT JSON_OBJECT(
           'last_dt'     VALUE o.order_dt,
           'last_amt'    VALUE o.amount,
           'last_status' VALUE o.status
         ) AS doc
  FROM   ORD o
  WHERE  o.cust_id = c.cust_id
  ORDER  BY o.order_dt DESC
  FETCH FIRST 1 ROWS ONLY
) j
WHERE  c.cust_id IN (1,2,3);
```

- 스칼라 제약은 우회하지만 **파싱 비용/가독성 비용**이 크다.
- LATERAL/APPLY나 인라인 뷰 조인이 대체로 더 낫다.

---

## 8) 다중 스칼라 서브쿼리 vs 한 번의 조인: 언제 위험한가

### 8.1 다중 스칼라가 위험해지는 조건

1) **NDV가 높아 캐싱이 거의 안 되는 경우**  
   → 스칼라 3개면 사실상 “서브쿼리 3배 실행”.

2) **언네스팅이 부분적으로만 발생**해  
   서로 다른 실행 경로가 섞이는 경우  
   → 플랜 변동/예측성 하락.

3) **Top-1 스칼라를 여러 번 반복**할 때  
   → 같은 정렬/인덱스 역순 스캔을 중복 수행.

### 8.2 자동 재작성에 의존하지 말아야 하는 이유

- Oracle이 다중 스칼라를 **항상 조인으로 합쳐주지** 않는다.
- 통계/버전/힌트/쿼리 블록 구조에 따라 달라진다. :contentReference[oaicite:9]{index=9}

따라서  
**“여러 컬럼이 필요하면 스칼라를 늘리지 말고 구조를 바꿔라”**  
가 실전의 안전 규칙이다.

---

## 9) 실전 성능 포인트(체크리스트 형태)

### 9.1 단일 행 보장
- 스칼라가 2행 이상 나올 가능성이 있으면 반드시
  - `MAX/MIN`
  - `FETCH FIRST 1 ROW`
  - `KEEP (DENSE_RANK ...)`
  로 단일화를 강제.

### 9.2 Top-1은 “Stopkey + 인덱스 역순”으로
- `(key, order_dt)` 인덱스에서
  - `ORDER BY order_dt DESC FETCH FIRST 1 ROW`
  를 쓰면 대개 최적이다.

### 9.3 NDV가 큰 경우는 조인/적재로 구조 변경
- 캐싱 적중률이 낮으면 스칼라는 O(N) 반복 실행이 된다.
- 인라인 뷰/조인으로 “한 번에” 해결.

### 9.4 변환 제어는 최소로
- `NO_UNNEST` 남발은 최적화 공간을 죽일 수 있다.
- 진짜 필요할 때만, 그리고 **특정 쿼리 블록(qb_name)**에 한정해 사용. :contentReference[oaicite:10]{index=10}

### 9.5 측정은 ALLSTATS로
- E-Rows/A-Rows, Gets, TempSpc, MEMSTATS를  
  전/후로 비교해 “진짜 이득인지” 확인.

---

## 10) 종합 시나리오: VIP·GOLD 100명에 “최근 주문 + 90일 요약” 붙이기

### 10.1 LATERAL/APPLY 권장 해법

```sql
SELECT /*+ ORDERED */
       c.cust_id, c.name, c.region, c.tier,
       v.last_dt, v.last_amt, v.last_status,
       s.cnt_90d, s.sum_90d
FROM   CUST c
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(o IX_ORD_CUST) */
         o.order_dt AS last_dt,
         o.amount   AS last_amt,
         o.status   AS last_status
  FROM   ORD o
  WHERE  o.cust_id = c.cust_id
  ORDER  BY o.order_dt DESC
  FETCH FIRST 1 ROWS ONLY
) v
LEFT  JOIN OSTAT s ON s.cust_id = c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 100 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS'
));
```

### 10.2 인라인 뷰 조인 해법

```sql
WITH LAST_ORDER AS (
  SELECT o.cust_id,
         MAX(o.order_dt) KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_dt,
         MAX(o.amount)   KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_amt,
         MAX(o.status)   KEEP (DENSE_RANK LAST ORDER BY o.order_dt) AS last_status
  FROM   ORD o
  GROUP  BY o.cust_id
)
SELECT c.cust_id, c.name, lo.last_dt, lo.last_amt, lo.last_status, s.cnt_90d, s.sum_90d
FROM   CUST c
LEFT   JOIN LAST_ORDER lo ON lo.cust_id = c.cust_id
LEFT   JOIN OSTAT      s  ON s.cust_id  = c.cust_id
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 100 ROWS ONLY;
```

### 10.3 다중 스칼라(가독성은 좋지만 의존성 큼)

```sql
SELECT c.cust_id, c.name,
       (SELECT o.order_dt FROM ORD o WHERE o.cust_id = c.cust_id
        ORDER BY o.order_dt DESC FETCH FIRST 1 ROWS ONLY) AS last_dt,
       (SELECT o.amount   FROM ORD o WHERE o.cust_id = c.cust_id
        ORDER BY o.order_dt DESC FETCH FIRST 1 ROWS ONLY) AS last_amt,
       (SELECT o.status   FROM ORD o WHERE o.cust_id = c.cust_id
        ORDER BY o.order_dt DESC FETCH FIRST 1 ROWS ONLY) AS last_status,
       (SELECT s.cnt_90d  FROM OSTAT s WHERE s.cust_id = c.cust_id) AS cnt_90d,
       (SELECT s.sum_90d  FROM OSTAT s WHERE s.cust_id = c.cust_id) AS sum_90d
FROM   CUST c
WHERE  c.tier IN ('VIP','GOLD')
FETCH FIRST 100 ROWS ONLY;
```

- 실무 권장 순위는  
  **LATERAL/APPLY 또는 인라인 뷰 조인 > 다중 스칼라**  
  이다.

---

## 11) FAQ

### Q1. 스칼라 서브쿼리를 여러 번 써도 괜찮나?
- 같은 키 반복 + 캐싱 적중이면 괜찮을 수 있다. :contentReference[oaicite:11]{index=11}  
- 하지만 NDV가 크면 캐싱이 약해져 **성능이 급격히 나빠질 수 있다**.  
  그때는 인라인 뷰 조인/APPLY로 구조화하자.

### Q2. 캐싱이 안 되는 것 같은데?
- NDV가 크거나, 서브쿼리 안에 비결정적 표현이 섞였을 가능성이 높다.
- 언네스팅(조인화)이 발생해 “캐싱이 필요한 구조 자체가 사라진” 경우도 있다. :contentReference[oaicite:12]{index=12}

### Q3. 다중 컬럼을 스칼라로 못 받나?
- 표준 스칼라 서브쿼리는 불가.
- **APPLY/LATERAL 또는 인라인 뷰 조인으로 설계를 바꿔라.** :contentReference[oaicite:13]{index=13}

### Q4. 언네스팅을 강제로 막아야 할 때는?
- 조인화가 오히려 비용을 키운다는 것이 **실측으로 확인된 특수 케이스**에서만.  
- 그때는 `NO_UNNEST`를 **해당 서브쿼리에만 국지 적용**하라. :contentReference[oaicite:14]{index=14}

---

## 12) 요약

- 스칼라 서브쿼리는 “행당 단일 값”을 붙이는 강력한 표현식이며,  
  Oracle은 이를 **조인으로 언네스팅**해 최적화하기도 하고,  
  **반복 키**에서는 **Scalar Subquery Caching**으로 반복 실행을 줄이기도 한다. :contentReference[oaicite:15]{index=15}
- **Top-1/최근 1건**은  
  `ORDER BY ... DESC FETCH FIRST 1 ROW` + 인덱스 역순 스캔(Stopkey)으로 OLTP에서 최강 패턴이다.
- 여러 값을 한 번에 붙여야 한다면  
  **LATERAL/CROSS|OUTER APPLY**나 **상관 인라인 뷰 조인**이 성능·플랜 안정성에서 가장 안전하다. :contentReference[oaicite:16]{index=16}
- 다중 스칼라를 자동 재작성/캐싱에 맡기면 플랜이 흔들릴 수 있으니,  
  **“다중 값 필요 → 구조를 조인/APPLY로 바꾼다”**가 실전 원칙이다.
- 마지막은 항상 실측으로:  
  `DBMS_XPLAN ... ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS`로 E-Rows/A-Rows와 I/O를 확인하자.