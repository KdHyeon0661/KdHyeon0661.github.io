---
layout: post
title: 웹해킹 - HTML 인젝션
date: 2025-09-24 23:25:23 +0900
category: 웹해킹
---
# HTML 인젝션(HTML Injection)

## 0) HTML 인젝션이란 무엇인가?

**HTML 인젝션**은 *신뢰할 수 없는 입력*이 서버/클라이언트 렌더링 단계에서 **HTML 마크업**으로 해석되어 UI를 변조·오도하게 되는 취약점입니다.  
- **핵심 차이**  
  - **HTML 인젝션**: `<b>`, `<a>`, `<img>`, `<form>` 등의 **마크업 삽입**으로 **콘텐츠 조작·피싱 UI/오도**가 가능. 스크립트 실행이 *직접* 목적은 아님.  
  - **XSS**: `<script>`, 이벤트 핸들러, `javascript:` URL 등으로 **JS 코드 실행**이 목적.  
- 실전에서는 **HTML 인젝션 → XSS 상승**으로 이어질 수 있습니다. 예: 허술한 필터가 `<img onerror=...>`나 `javascript:` URL을 허용하면 **즉시 XSS**.

**발생 지점**
- 서버 렌더 템플릿에서 **자동 이스케이프를 끈 영역**  
- SPA에서 `innerHTML`/`insertAdjacentHTML`/jQuery `.html()` 사용  
- 마크다운/위지윅(HTML) **렌더러**의 “안전 모드” 미적용  
- CMS/게시판/프로필 서명/댓글 등 **사용자 콘텐츠 영역**

---

## 1) 위협 모델: “코드가 아니어도 위험한 이유”

HTML만으로도:
- **브랜드 오도·피싱 UI**: 가짜 공지/로그인 폼 삽입 → 사용자가 **민감 정보를 제출**  
- **시각적 권한 상승**: 관리자 뱃지/배너/상단 공지처럼 보이게 꾸며 **행위 유도**  
- **오토 네비게이션/리다이렉트**: `<meta http-equiv="refresh">` 허용 시 **피싱/광고 유도**  
- **데이터 출처 오인**: `<base>` 삽입으로 **상대 링크 해석 변경**(오리진 혼동, Open Redirect 연계)  
- **콘텐츠 하이재킹**: `<style>`/인라인 스타일 허용 시 **UI 가리기/클릭 유도**(CSS 기반 UI 레드ressing)

> 결론: **HTML 인젝션만 허용**한다는 발상 자체가 위험합니다. “정말 사용자에 의한 제한적 서식(굵게/기울임/리스트/링크)**만** 필요”한지 점검 후, **강력한 화이트리스트 기반 Sanitization**을 적용해야 합니다.

---

## 2) 렌더링 컨텍스트 이해(방어의 절반)

HTML은 **컨텍스트**에 따라 방어 방법이 달라집니다.

| 컨텍스트 | 예 | 위험 | 안전 원칙 |
|---|---|---|---|
| **텍스트 노드** | `<p>여기</p>` | `<` `>` 해석로 태그 삽입 | **HTML 엔티티 인코딩**(템플릿 autoescape, textContent) |
| **HTML 속성 값** | `<a title="여기">` | `"` `'` 탈출, 이벤트 속성 | **속성 컨텍스트 인코딩** + 이벤트 속성 **비허용** |
| **URL 속성** | `<a href="...">`, `<img src="...">` | `javascript:`/`data:`/`file:` | **스킴 화이트리스트**(https/http만) + 정규화 |
| **CSS/스타일** | `<div style="...">` | UI 레드ressing/피싱 | **인라인 스타일 금지**(정 필요 시 CSS Sanitizer) |
| **DOM API** | `innerHTML` | DOM/XSS로 확대 | **textContent/setAttribute** 우선, 필요 시 Sanitizer |

---

## 3) “취약 → 수정” 빠른 감정(언어별)

### 3.1 Node/Express (서버 렌더)
**❌ 취약**
```javascript
// 댓글을 HTML 문자열로 합쳐 응답 (이스케이프 없음)
app.get("/comments", async (req, res) => {
  const list = await db.findAll();
  let html = "<ul>";
  for (const c of list) {
    html += `<li><b>${c.author}</b>: ${c.body}</li>`; // HTML 인젝션
  }
  html += "</ul>";
  res.send(html);
});
```

**✅ 안전(템플릿 엔진 autoescape)**
```javascript
// Pug/Nunjucks/Handlebars 등: {{ }}는 기본 이스케이프
app.get("/comments", async (req, res) => {
  const list = await db.findAll();
  res.render("comments", { list }); // 템플릿에서 {{c.body}} 사용
});
```

**✅ 제한적 HTML 허용(클라이언트 DOMPurify + 서버 보조)**
```html
<div id="viewer"></div>
<script type="module">
  import DOMPurify from "https://cdn.skypack.dev/dompurify";
  const ALLOWED = {
    ALLOWED_TAGS: ["b","i","em","strong","u","p","ul","ol","li","a","br"],
    ALLOWED_ATTR: ["href","title"],
    ALLOW_UNKNOWN_PROTOCOLS: false
  };
  const raw = getUserHtml(); // 서버에서 내려준 사용자 입력(신뢰 X)
  const safe = DOMPurify.sanitize(raw, ALLOWED);
  document.getElementById("viewer").innerHTML = safe; // sanitize 이후 제한 주입
</script>
```

> **팁**: 링크는 반드시 **프로토콜 화이트리스트**(http/https) 검사를 추가하고, `rel="noopener noreferrer"` 부여를 고려하세요.

---

### 3.2 Python/Flask (서버 렌더)
**❌ 취약**
```python
@app.get("/profile")
def profile():
    bio = request.args.get("bio","")
    # 문자열 포맷으로 직접 끼워넣기 → 태그 삽입/변조
    return f"<h1>Bio</h1><div>{bio}</div>"
```

**✅ 안전(Jinja2 autoescape)**
```python
@app.get("/profile")
def profile():
    bio = request.args.get("bio","")
    return render_template("profile.html", bio=bio)  # {{ bio }} 그대로 안전
```

**✅ 제한 HTML 허용(Bleach)**
```python
import bleach
ALLOWED_TAGS = ["b","i","em","strong","a","ul","ol","li","p","br"]
ALLOWED_ATTRS = {"a": ["href","title"]}
@app.post("/profile/bio")
def save_bio():
    raw = request.form.get("bio","")
    safe = bleach.clean(raw, tags=ALLOWED_TAGS, attributes=ALLOWED_ATTRS, protocols=["http","https"], strip=True)
    save_to_db(safe)         # 정화본 저장(원본은 별도 비공개 저장/모더레이션 용도)
    return "ok"
```

---

### 3.3 PHP
**❌ 취약**
```php
<?php
$bio = $_GET["bio"] ?? "";
echo "<div>$bio</div>"; // 그대로 렌더 → HTML 인젝션
```

**✅ 안전**
```php
<?php
$bio = $_GET["bio"] ?? "";
echo "<div>" . htmlspecialchars($bio, ENT_QUOTES, 'UTF-8') . "</div>";
```

**✅ 제한 HTML 허용(서버측 Sanitizer)**
- PHP에서는 **HTML Purifier** 등 검증된 Sanitizer 사용을 권장합니다(화이트리스트 정책 필수).

---

### 3.4 Java/Spring MVC
**❌ 취약**
```java
@GetMapping("/note")
@ResponseBody
public String note(@RequestParam String text) {
  return "<p>" + text + "</p>"; // 인젝션
}
```

**✅ 안전(Thymeleaf)**
```java
@GetMapping("/note")
public String note(@RequestParam(required=false) String text, Model m) {
  m.addAttribute("text", text);
  return "note"; // 템플릿: <p th:text="${text}"></p> ← 자동 이스케이프
}
```

**✅ 제한 HTML 허용(OWASP Java HTML Sanitizer)**
```java
PolicyFactory policy = Sanitizers.FORMATTING.and(Sanitizers.LINKS);
String safe = policy.sanitize(userHtml);
```

---

## 4) 프런트엔드 프레임워크 주의점

### 4.1 React
- `{value}` 바인딩은 **자동 이스케이프** → 안전.  
- **`dangerouslySetInnerHTML`**는 **반드시 사전 Sanitization** 필요.
```jsx
import DOMPurify from 'dompurify';
function Post({ userHtml }) {
  const safe = DOMPurify.sanitize(userHtml, {ALLOWED_TAGS:['b','i','a','p','ul','li','br'], ALLOWED_ATTR:['href']});
  return <div dangerouslySetInnerHTML={{ __html: safe }} />;
}
```

### 4.2 Vue
- `{{ }}` 보간은 자동 이스케이프.  
- **`v-html`** 사용 시 **Sanitizer 필수**. ESLint `vue/no-v-html` 규칙으로 경고/금지 가능.

### 4.3 Angular
- 템플릿 바인딩은 컨텍스트별 보안이 내장(보통 안전).  
- `innerHTML` 바인딩 시 **DomSanitizer** 사용 + **검증된 Sanitizer** 결합.  
- `bypassSecurityTrustHtml` **남용 금지**(실무에서 흔한 실수).

---

## 5) “제한적 HTML 허용” 설계 체크리스트

1) **목표 명확화**: 진짜로 필요한 태그만(굵게, 기울임, 리스트, 링크 정도).  
2) **화이트리스트 정책**:  
   - **허용 태그**: `b,i,strong,em,u,p,ul,ol,li,br,a` 정도로 최소화  
   - **허용 속성**: `a[href|title]` 정도만  
   - **URL 스킴**: `https`, `http`만(메일/전화 등도 필요 시 별도 처리)  
   - **금지**: `style`, `on*` 이벤트, `script`, `iframe`, `object`, `embed`, `svg`(가능하면), `math`  
3) **링크 강화**: `rel="noopener noreferrer"` + 필요 시 `target="_blank"`  
4) **서버/클라 양측 Sanitization**: 동일 정책(서버 **최종 심사** 권장)  
5) **저장 전략**: “원본”은 **비공개 저장(모더레이션/감사)**, “정화본”만 표시  
6) **CSP 보조**: `Content-Security-Policy`로 **스크립트/오브젝트/기타 실행**을 강하게 제한  
7) **Trusted Types(지원 브라우저)**: DOM-XSS성 API에 문자열 주입 자체 금지

**샘플 CSP (보수적 시작점)**
```http
Content-Security-Policy:
  default-src 'none';
  base-uri 'none';
  object-src 'none';
  frame-ancestors 'self';
  img-src 'self' data: https:;
  style-src 'self';              /* 인라인 스타일 미허용 */
  script-src 'self';             /* 인라인/eval 미허용 */
  form-action 'self';
```

---

## 6) 시나리오별 “공격 → 방어” 사례

### 6.1 공지 영역 변조(피싱)
**공격**: 사용자가 공지 댓글에  
```html
<div class="banner">[긴급] 계정 인증 필요 – <a href="https://phish.tld">클릭</a></div>
```
을 넣어 방문자를 속임.

**방어**
- 공지/관리자 전용 영역은 **사용자 주입 불가**(권한 모델)
- 사용자 콘텐츠는 **정화본만 표시** + 링크 **스킴 화이트리스트** + `rel="noopener noreferrer"`

---

### 6.2 `<base>` 인젝션으로 링크 의미 왜곡
**공격**:  
```html
<base href="https://evil.tld/">
<a href="/reset">비밀번호 재설정</a>
```
→ 상대 링크가 공격자 도메인으로 향함.

**방어**
- `<base>` **금지**
- 응답 최상단에 `<base>`를 **고정**(필요한 앱에서) + 사용자 영역에는 **절대 금지**

---

### 6.3 마크다운 경유 HTML 인젝션
**공격**: 마크다운 렌더러가 HTML 패스를 허용하면  
```markdown
**굵게**  
<div onclick="alert(1)">클릭</div>
```
이 그대로 HTML로 들어감.

**방어**
- 마크다운 라이브러리의 **safe/가드 모드** 사용  
- **HTML 블록 금지** 옵션 + 링크/이미지의 **스킴 화이트리스트**  
- 필요 시 **서버측 Sanitization** (예: Python `bleach`, Java Sanitizer)

---

## 7) 테스트 페이로드(개발/QA 전용)

> 목적: “막혀야 정상”임을 확인. 운영환경에 직접 사용하지 마세요.

- 태그 삽입: `<h1>내가 만든 배너</h1>` → **텍스트로 보이거나 제거**  
- 링크: `<a href="javascript:alert(1)">x</a>` → **URL 스킴 검사로 제거**  
- 이벤트: `<img src=x onerror=alert(1)>` → **속성/태그 필터로 제거**  
- 메타 리다이렉트: `<meta http-equiv=refresh content="0;url=https://phish.tld">` → **태그 금지로 제거**  
- base: `<base href="https://evil.tld/">` → **금지**  
- 스타일: `<div style="position:fixed;...">` → **금지(또는 CSS Sanitizer)**

---

## 8) 운영/플랫폼 하드닝

- **템플릿 엔진 기본 이스케이프 유지**: `{% autoescape %}`/`{{ }}`/`th:text`/`<%= h() %>` 등  
- **서버에서 렌더할 때는 “텍스트” 기본**: HTML은 예외이며 **화이트리스트 정책** 필수  
- **정적/미디어 서빙 분리**: 사용자 업로드는 **다운로드 전용 헤더**(`Content-Disposition: attachment`, `X-Content-Type-Options: nosniff`)  
- **로깅·탐지**: `"<", ">"`, `<meta http-equiv>`, `<base>`, `javascript:` 등장률 알림  
- **보안 헤더**: CSP(위), `Referrer-Policy`, `X-Frame-Options`/`frame-ancestors`, `Permissions-Policy`

---

## 9) 자동화 테스트 예(간단 스모크)

### 9.1 Node(Jest + Supertest)
```javascript
import request from "supertest";
import app from "./app";

test("HTML injection is neutralized in comments", async () => {
  await request(app).post("/comments").send({ body: '<img src=x onerror="alert(1)">' }).expect(200);
  const res = await request(app).get("/comments").expect(200);
  expect(res.text).not.toMatch(/onerror|<script|javascript:/i);
});
```

### 9.2 Python(Pytest)
```python
def test_profile_bio_sanitized(client):
    client.post("/profile/bio", data={"bio": "<meta http-equiv=refresh content=0;url=//evil>"})
    r = client.get("/profile")
    assert "http-equiv" not in r.data.decode().lower()
```

---

## 10) 실수 모음 ↔ 바른 대안

| 흔한 실수 | 왜 위험한가 | 바른 대안 |
|---|---|---|
| `innerHTML = userHtml` | 즉시 HTML/XSS 표면 | `textContent`, 또는 **Sanitizer 후 제한 주입** |
| “스크립트만 막으면 됨” | `<meta>`, `<base>`, 스타일/링크 스킴으로도 위험 | **화이트리스트 기반 정책** |
| 마크다운에서 HTML 허용 | 렌더러마다 보안옵션 다름 | **안전 모드/필터** + 서버측 Sanitizer |
| 클라측 필터만 믿음 | 우회/변조 쉬움 | **서버가 최종 심사** |
| Sanitizer 자체 작성 | 파서/표준/우회가 복잡 | **검증된 라이브러리** 사용 |

---

## 11) 실전 스니펫 모음(재사용용)

### 11.1 URL 스킴 화이트리스트
```javascript
export function isSafeHref(href) {
  try {
    const u = new URL(href, "https://example.com"); // base로 상대경로 처리
    return u.protocol === "https:" || u.protocol === "http:";
  } catch { return false; }
}
```

### 11.2 문자열을 “텍스트”로만 넣기(브라우저)
```javascript
function renderText(el, s) {
  while (el.firstChild) el.removeChild(el.firstChild);
  el.appendChild(document.createTextNode(s ?? ""));
}
```

### 11.3 React에서 제한 HTML
```jsx
import DOMPurify from "dompurify";
const POLICY = { ALLOWED_TAGS: ["b","i","a","p","ul","li","br"], ALLOWED_ATTR: ["href","title"] };
export function SafeHtml({ html }) {
  const safe = DOMPurify.sanitize(html || "", POLICY);
  return <div dangerouslySetInnerHTML={{ __html: safe }} />;
}
```

### 11.4 Spring + Sanitizer
```java
import org.owasp.html.PolicyFactory;
import static org.owasp.html.Sanitizers.*;

PolicyFactory POLICY = FORMATTING.and(LINKS);
String safe = POLICY.sanitize(userHtml);
model.addAttribute("body", safe); // 템플릿은 th:utext 사용 가능(정화본만)
```

### 11.5 Flask + Bleach
```python
import bleach
POLICY = dict(tags=["b","i","em","strong","a","p","ul","ol","li","br"],
              attributes={"a": ["href","title"]},
              protocols=["http","https"])
def sanitize_html(raw): return bleach.clean(raw or "", **POLICY, strip=True)
```

---

## 12) 요약

- **HTML 인젝션 = 마크업 주입** → **UI/브랜드 오도, 피싱, 링크 왜곡** 등 **실질 피해**.  
- **원칙**: 텍스트 기본, **화이트리스트 기반 Sanitization**, **URL 스킴 제한**, **이벤트/스크립트/스타일 금지**.  
- **프레임워크 가드**(autoescape)를 **끄지 말고**, 꼭 HTML이 필요하면 **검증된 Sanitizer**만 사용.  
- **CSP/Trusted Types** 등 **보조 안전망**으로 실수 비용을 줄이세요.  
- 자동화 테스트로 **“막혀야 정상”** 케이스를 꾸준히 검증하는 것이 실무의 승부처입니다.