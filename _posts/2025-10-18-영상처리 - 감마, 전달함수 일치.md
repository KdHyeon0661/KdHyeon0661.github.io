---
layout: post
title: ì˜ìƒì²˜ë¦¬ - ê°ë§ˆ/ì „ë‹¬í•¨ìˆ˜ ì¼ì¹˜
date: 2025-10-18 15:25:23 +0900
category: ì˜ìƒì²˜ë¦¬
---
# ê°ë§ˆ/ì „ë‹¬í•¨ìˆ˜ ì¼ì¹˜ (sRGB í™•ì •, ë””ìŠ¤í”Œë ˆì´ ë³€í™˜)

> **í•µì‹¬ ëª©í‘œ**
> 1) **í”½ì…€ ì—°ì‚°(ë¸”ë Œë”©/ë¦¬ì‚¬ì´ì¦ˆ/ì»¨ë³¼ë£¨ì…˜/í•©ì„±)** ì€ **ì„ í˜•ê´‘(Linear Light)** ê³µê°„ì—ì„œ ìˆ˜í–‰í•œë‹¤.  
> 2) ë””ìŠ¤í¬ íŒŒì¼(JPEG/PNG ë“±)ê³¼ **ë””ìŠ¤í”Œë ˆì´** ê°„ì˜ **ì „ë‹¬í•¨ìˆ˜(Transfer Function)** ë¥¼ **ì •í™•íˆ ë§¤ì¹­**í•œë‹¤.  
> 3) ì…ë ¥ì´ **sRGB**ë¼ê³  ê°€ì •/í™•ì¸í–ˆì„ ë•Œ: `sRGB(ì½”ë“œê°’) â‡„ ì„ í˜•ê´‘(ë¬¼ë¦¬ì  íœ˜ë„)` ë³€í™˜ì„ ì •í™•íˆ ìˆ˜í–‰í•˜ê³ , í•„ìš” ì‹œ **ëª¨ë‹ˆí„° ICC**ë¡œ ìµœì¢… ë””ìŠ¤í”Œë ˆì´ ë³€í™˜ì„ í•œë‹¤.

---

## 1) ì™œ ê°ë§ˆ/ì „ë‹¬í•¨ìˆ˜ê°€ ì¤‘ìš”í•œê°€?

- **sRGB**ëŠ” ì¸ê°„ ì‹œê° íŠ¹ì„±/ë””ìŠ¤í”Œë ˆì´ ì‘ë‹µì„ ê³ ë ¤í•œ **ë¹„ì„ í˜• ì½”ë“œê°’ ê³µê°„**ì´ë‹¤.  
  - ì½”ë“œê°’(0..255)ì— ì§ì ‘ í‰ê· /ë³´ê°„/í•©ì„±í•˜ë©´, **ì‹¤ì œ ë¹›(ì„ í˜•ê´‘)ì—ì„œì˜ ì—°ì‚°ê³¼ ì–´ê¸‹ë‚¨** â†’  
    **ì–´ë‘ìš´ ìª½ì´ ë­‰ê°œì§€ê±°ë‚˜, ì—£ì§€/ê·¸ë¼ë””ì–¸íŠ¸ê°€ ì´ìƒí•˜ê²Œ ë­‰ê°œì§, ë§ì‰/í—¤ì¼ë¡œ** ì¦ê°€.
- **ì˜¬ë°”ë¥¸ ì ˆì°¨**  
  1) íŒŒì¼/ë©”ëª¨ë¦¬ì˜ **sRGB ì½”ë“œê°’ â†’ ì„ í˜•ê´‘**(EOTF)  
  2) ëª¨ë“  ì—°ì‚°ì„ **ì„ í˜• ê³µê°„**ì—ì„œ ìˆ˜í–‰  
  3) ì¶œë ¥ ì „ **ì„ í˜•ê´‘ â†’ sRGB**(OETF)  
  4) ì‹¤ì œ ë””ìŠ¤í”Œë ˆì´ê°€ sRGBê°€ ì•„ë‹ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, í•„ìš” ì‹œ **ICC ë³€í™˜(ì„ í˜• ë˜ëŠ” sRGB ê¸°ì¤€)** í›„ ì¶œë ¥

---

## 2) sRGB ì „ë‹¬í•¨ìˆ˜(Transfer Function) ê³µì‹

sRGBëŠ” **ì¡°ê°ë³„(piecewise)** ì§€ìˆ˜ í•¨ìˆ˜ë¡œ ì •ì˜ëœë‹¤. ë³´í†µ 8ë¹„íŠ¸ ì½”ë“œê°’ì„ 0..1ë¡œ ì •ê·œí™”í•˜ì—¬ ì‚¬ìš©í•œë‹¤.

### 2.1 EOTF (Electro-Optical Transfer Function): **sRGB â†’ ì„ í˜•ê´‘**

ì½”ë“œê°’ \(V \in [0,1]\) ì— ëŒ€í•´ ì„ í˜•ê´‘ \(L \in [0,1]\):

\[
L =
\begin{cases}
\dfrac{V}{12.92}, & V \le 0.04045 \\
\left(\dfrac{V + 0.055}{1.055}\right)^{2.4}, & V > 0.04045
\end{cases}
\]

### 2.2 OETF (Opto-Electrical Transfer Function): **ì„ í˜•ê´‘ â†’ sRGB**

ì„ í˜•ê´‘ \(L \in [0,1]\) ì— ëŒ€í•´ ì½”ë“œê°’ \(V \in [0,1]\):

\[
V =
\begin{cases}
12.92 \, L, & L \le 0.0031308 \\
1.055 \, L^{1/2.4} - 0.055, & L > 0.0031308
\end{cases}
\]

> ğŸ” **ê°ë§ˆ 2.2 vs sRGB**  
> sRGBëŠ” ë‹¨ìˆœ \(V = L^{1/2.2}\) ì´ ì•„ë‹ˆë‹¤. **ì €ì¡°ë„ êµ¬ê°„ì˜ ì„ í˜• ì„¸ê·¸ë¨¼íŠ¸**(0.0031308/0.04045)ê°€ ì¡´ì¬í•œë‹¤.  
> â€œê°ë§ˆ 2.2 ê·¼ì‚¬â€ëŠ” ëŒ€ëµ ë§ì§€ë§Œ, **ì •í™•í•œ sRGB**ë¥¼ ì‚¬ìš©í•´ì•¼ ì €ëª…ì•”ë¶€/ë°´ë”© ë¬¸ì œë¥¼ ìµœì†Œí™”í•œë‹¤.

---

## 3) C++ ìœ í‹¸: sRGB â‡„ ì„ í˜• ë³€í™˜ í•¨ìˆ˜

ì•„ë˜ëŠ” **ë‹¨ì¼ ì±„ë„**ê³¼ **ë²¡í„°(BGRA)**ì— ëŒ€í•œ ë³€í™˜ ì˜ˆì œë‹¤. (8ë¹„íŠ¸ ì •ìˆ˜ â†’ float[0..1] â†’ 8ë¹„íŠ¸ íšŒê·€)

```cpp
// sRGB <-> Linear utility
#include <algorithm>
#include <cmath>
#include <cstdint>

inline float srgb_to_linear(float v) {
    // v in [0,1]
    if (v <= 0.04045f) return v / 12.92f;
    return std::pow((v + 0.055f) / 1.055f, 2.4f);
}

inline float linear_to_srgb(float l) {
    l = std::max(0.0f, std::min(1.0f, l));
    if (l <= 0.0031308f) return 12.92f * l;
    return 1.055f * std::pow(l, 1.0f/2.4f) - 0.055f;
}

inline uint8_t to_u8(float v01) {
    float v = std::max(0.0f, std::min(1.0f, v01));
    int iv = (int)std::floor(v * 255.0f + 0.5f);
    return (uint8_t)std::min(255, std::max(0, iv));
}

// BGRA(8bpc) â†’ ì„ í˜• float4, ë‹¤ì‹œ sRGBë¡œ ë˜ëŒë¦¬ëŠ” ì˜ˆ
struct F4 { float b,g,r,a; };

inline F4 bgra8_to_linearF4(const uint8_t* px) {
    F4 o;
    o.b = srgb_to_linear(px[0] / 255.0f);
    o.g = srgb_to_linear(px[1] / 255.0f);
    o.r = srgb_to_linear(px[2] / 255.0f);
    o.a = (px[3] / 255.0f); // ì•ŒíŒŒëŠ” ë³´í†µ ì„ í˜•
    return o;
}

inline void linearF4_to_bgra8(const F4& f, uint8_t* px) {
    px[0] = to_u8(linear_to_srgb(f.b));
    px[1] = to_u8(linear_to_srgb(f.g));
    px[2] = to_u8(linear_to_srgb(f.r));
    px[3] = to_u8(std::max(0.0f, std::min(1.0f, f.a)));
}
```

---

## 4) **ê°ë§ˆ ë³´ì • ë¦¬ì‚¬ì´ì¦ˆ(ì–‘ì„ í˜• ë³´ê°„) ì˜ˆì œ**

> **ìƒí™©**: sRGB 8ë¹„íŠ¸ BGRA ì´ë¯¸ì§€ë¥¼ **ë‹¤ìš´/ì—…ìƒ˜í”Œë§**í•  ë•Œ, **ì„ í˜•ê´‘ì—ì„œ ë³´ê°„**í•´ì•¼ ê³„ì¡°ê°€ ì •í™•í•˜ë‹¤.

### 4.1 ì˜ëª»ëœ(ë¹„ê¶Œì¥) ë°©ì‹
- ì½”ë“œê°’(=sRGB) ê·¸ëŒ€ë¡œ `uint8`ì—ì„œ bilinear â†’ **ì–´ë‘ìš´ ìª½ì´ ê³¼ë„í•˜ê²Œ ì–´ë‘ì›Œì§**, í…ìŠ¤íŠ¸ ê°€ì¥ìë¦¬ íë¦¼/í—¤ì¼ë¡œ

### 4.2 ê¶Œì¥ êµ¬í˜„ (ì„ í˜• ë³€í™˜ í›„ ë³´ê°„)

```cpp
// Gamma-aware bilinear resize (BGRA8 -> BGRA8), no filtering kernel beyond bilinear
#include <vector>
#include <cstdint>
#include <cmath>

void ResizeBilinear_GammaAware(const uint8_t* src, int sw, int sh, int sstride,
                               uint8_t* dst, int dw, int dh, int dstride)
{
    const float sx = (float)sw / (float)dw;
    const float sy = (float)sh / (float)dh;

    for (int y = 0; y < dh; ++y) {
        float srcY = (y + 0.5f) * sy - 0.5f;
        int y0 = (int)std::floor(srcY);
        int y1 = std::min(y0 + 1, sh - 1);
        float fy = srcY - y0;
        if (y0 < 0) { y0 = 0; fy = 0.0f; }

        uint8_t* drow = dst + (size_t)dstride * y;

        for (int x = 0; x < dw; ++x) {
            float srcX = (x + 0.5f) * sx - 0.5f;
            int x0 = (int)std::floor(srcX);
            int x1 = std::min(x0 + 1, sw - 1);
            float fx = srcX - x0;
            if (x0 < 0) { x0 = 0; fx = 0.0f; }

            const uint8_t* p00 = src + (size_t)sstride * y0 + x0 * 4;
            const uint8_t* p10 = src + (size_t)sstride * y0 + x1 * 4;
            const uint8_t* p01 = src + (size_t)sstride * y1 + x0 * 4;
            const uint8_t* p11 = src + (size_t)sstride * y1 + x1 * 4;

            // sRGB->Linear ë³€í™˜ í›„ ë³´ê°„
            F4 c00 = bgra8_to_linearF4(p00);
            F4 c10 = bgra8_to_linearF4(p10);
            F4 c01 = bgra8_to_linearF4(p01);
            F4 c11 = bgra8_to_linearF4(p11);

            F4 cx0 = { // top row
                c00.b*(1-fx) + c10.b*fx,
                c00.g*(1-fx) + c10.g*fx,
                c00.r*(1-fx) + c10.r*fx,
                c00.a*(1-fx) + c10.a*fx
            };
            F4 cx1 = { // bottom row
                c01.b*(1-fx) + c11.b*fx,
                c01.g*(1-fx) + c11.g*fx,
                c01.r*(1-fx) + c11.r*fx,
                c01.a*(1-fx) + c11.a*fx
            };
            F4 c = {
                cx0.b*(1-fy) + cx1.b*fy,
                cx0.g*(1-fy) + cx1.g*fy,
                cx0.r*(1-fy) + cx1.r*fy,
                cx0.a*(1-fy) + cx1.a*fy
            };

            linearF4_to_bgra8(c, drow + x * 4);
        }
    }
}
```

> âœ… **íš¨ê³¼**: ê·¸ë¼ë””ì–¸íŠ¸ê°€ ë§¤ëˆí•´ì§€ê³ , ì‘ì€ ê¸€ê¼´/ì•„ì´ì½˜ì˜ ì—£ì§€ ì½˜íŠ¸ë¼ìŠ¤íŠ¸ê°€ **ë” ìì—°ìŠ¤ëŸ½ê²Œ** ìœ ì§€ëœë‹¤.

---

## 5) **ì•ŒíŒŒ ë¸”ë Œë”©**ì€ ë°˜ë“œì‹œ **ì„ í˜•**ì—ì„œ!

sRGB ì½”ë“œê°’ì—ì„œ ì§ì ‘ ë¸”ë Œë”©í•˜ë©´ í…Œë‘ë¦¬ê°€ ì–´ë‘¡ê²Œ ë³€í•œë‹¤(**premultiplied alpha** ë” ì‹¬ê°).  
**ì„ í˜•ê´‘ì—ì„œ í”„ë¦¬ë©€í‹°í”Œë¼ì´ â†’ í•©ì„± â†’ sRGB ë³µê·€**ê°€ ì •ì„.

```cpp
// Linear-light premultiplied alpha compositing: out = src + dst*(1 - src.a)
// src, dst : BGRA8(sRGB code). out: BGRA8(sRGB code).
void AlphaComposite_LinearPM(const uint8_t* src, uint8_t* dst) {
    F4 s = bgra8_to_linearF4(src);
    F4 d = bgra8_to_linearF4(dst);

    // Premultiply
    float srb = s.r * s.a, sgb = s.g * s.a, sbb = s.b * s.a;
    float drb = d.r * d.a, dgb = d.g * d.a, dbb = d.b * d.a;

    float oa = s.a + d.a * (1.0f - s.a);
    float or_, og, ob;
    if (oa > 1e-6f) {
        or_ = (srb + drb * (1.0f - s.a)) / oa;
        og  = (sgb + dgb * (1.0f - s.a)) / oa;
        ob  = (sbb + dbb * (1.0f - s.a)) / oa;
    } else {
        or_ = og = ob = 0.0f;
    }

    F4 o{ob, og, or_, oa};
    linearF4_to_bgra8(o, dst);
}
```

---

## 6) ë””ìŠ¤í”Œë ˆì´ **ìƒ‰ê´€ë¦¬(ICC/WCS)**: sRGB ê°€ì • vs í”„ë¡œíŒŒì¼ ë³€í™˜

ëŒ€ë¶€ë¶„ì˜ ì¼ë°˜ ëª¨ë‹ˆí„°ëŠ” **sRGB ê·¼ì‚¬**ì§€ë§Œ, **ê´‘ìƒ‰ì—­(DCI-P3, AdobeRGB)** ëª¨ë‹ˆí„°/ë…¸íŠ¸ë¶/í°ì—ì„œëŠ” **sRGB ì½”ë“œê°’ì„ ê·¸ëŒ€ë¡œ í™”ë©´ì— ë•Œë¦¬ë©´ ê³¼í¬í™”** ëœë‹¤.  
**ì •í™•í•œ í‘œì‹œ**ê°€ í•„ìš”í•˜ë©´ **ëª¨ë‹ˆí„° ICC í”„ë¡œíŒŒì¼**ì„ ì½ì–´ **sRGBâ†’ëª¨ë‹ˆí„°** ë³€í™˜ì„ ìˆ˜í–‰í•œë‹¤.

### 6.1 Windowsì—ì„œ ëª¨ë‹ˆí„° í”„ë¡œíŒŒì¼ ê²½ë¡œ ì–»ê¸° (WCS/ICM)

```cpp
#include <windows.h>
#include <icm.h>    // GetICMProfileW
#include <string>

std::wstring GetDefaultMonitorIccPath(HDC hdc) {
    DWORD size = 0;
    GetICMProfileW(hdc, &size, nullptr); // size ì§ˆì˜
    std::wstring path; path.resize(size/sizeof(wchar_t));
    if (GetICMProfileW(hdc, &size, path.data())) {
        // pathëŠ” ë„ í¬í•¨. ì •ë¦¬:
        if (!path.empty() && path.back() == L'\0') path.pop_back();
        return path;
    }
    return L""; // ì‹¤íŒ¨ ì‹œ ë¹ˆ ë¬¸ìì—´
}
```

> ì°¸ê³ : ìµœì‹  Windowsì—ì„œëŠ” `WcsGetDefaultColorProfile` ì‚¬ìš©ë„ ê°€ëŠ¥. ìœ„ëŠ” ì „í†µì ì¸ ICM API ì˜ˆì‹œ.

### 6.2 **lcms2**ë¡œ sRGBâ†’ëª¨ë‹ˆí„° ë³€í™˜

```cpp
// lcms2 í•„ìš”: vcpkg install lcms
#include <lcms2.h>
#include <vector>

bool Convert_sRGB_to_MonitorBGRA(uint8_t* bgra, int w, int h, int strideBytes, const wchar_t* monitorIccPath)
{
    cmsHPROFILE hIn  = cmsCreate_sRGBProfile();
    cmsHPROFILE hOut = cmsOpenProfileFromFileW(monitorIccPath, L"r");
    if (!hIn || !hOut) { if(hIn) cmsCloseProfile(hIn); if(hOut) cmsCloseProfile(hOut); return false; }

    // BGRA 8ë¹„íŠ¸ íƒ€ì… ì§€ì • (lcms2 íƒ€ì… ë§¤í¬ë¡œ)
    cmsHTRANSFORM xform = cmsCreateTransform(hIn, TYPE_BGRA_8, hOut, TYPE_BGRA_8,
                                             INTENT_RELATIVE_COLORIMETRIC,
                                             cmsFLAGS_BLACKPOINTCOMPENSATION | cmsFLAGS_HIGHRESPRECALC);
    if (!xform) { cmsCloseProfile(hIn); cmsCloseProfile(hOut); return false; }

    for (int y=0; y<h; ++y) {
        uint8_t* row = bgra + (size_t)strideBytes * y;
        cmsDoTransform(xform, row, row, w); // ì œìë¦¬(in-place) ë³€í™˜
    }

    cmsDeleteTransform(xform);
    cmsCloseProfile(hIn);
    cmsCloseProfile(hOut);
    return true;
}
```

> **ì–¸ì œ ì ìš©?**  
> - ì•± ë‚´ **ì •í™•í•œ ìƒ‰ ì¬í˜„**, í”„ë£¨í•‘(Proof), ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ëª¨ë‹ˆí„° ì§€ì›ì´ í•„ìš”í•  ë•Œ.  
> - ë‹¨ìˆœ ë·°ì–´/íˆ´ë°” í‘œì‹œëŠ” sRGB ê°€ì •ìœ¼ë¡œ ì¶©ë¶„í•  ìˆ˜ ìˆìœ¼ë‚˜, **ë¸Œëœë“œ ì»¬ëŸ¬/ì¸ì‡„ í”„ë¦¬ë·°**ëŠ” ë°˜ë“œì‹œ ICC ê²½ë¡œë¥¼ ë°ŸëŠ”ë‹¤.

---

## 7) JPEG/PNG **ì…ì¶œë ¥ ì‹œ ë©”íƒ€ë°ì´í„°ì™€ sRGB í™•ì •**

- **JPEG**: ë³´í†µ **YCbCr(sRGB)** ë¡œ ê°€ì •. **ICC(sRGB) ë˜ëŠ” JFIF** ë©”íƒ€ë¥¼ ì˜¬ë°”ë¥´ê²Œ ìœ ì§€/ì‚½ì…í•˜ë©´ ë‹¤ë¥¸ ì•±ê³¼ **ìƒ‰ ì¼ì¹˜**.  
- **PNG**: `sRGB` ì²­í¬ ë˜ëŠ” `gAMA`/`cHRM` ì¡°í•©ìœ¼ë¡œ **ì „ë‹¬í•¨ìˆ˜/í™”ì´íŠ¸í¬ì¸íŠ¸**ê°€ ëª…ì‹œë  ìˆ˜ ìˆë‹¤. ê°€ëŠ¥í•˜ë©´ sRGB ì²­í¬ë¥¼ ë„£ì–´ ëª…í™•íˆ í•˜ì.
- **EXIF Orientation/ICC** ëŠ” ì• ì ˆì—ì„œ ë‹¤ë£¬ ëŒ€ë¡œ **ë³´ì¡´/ê°±ì‹ **.

**ì‹¤ë¬´ íŒ**  
- **íŒŒì´í”„ë¼ì¸ í‘œì¤€**: ë‚´ë¶€ ë²„í¼ëŠ” **ì„ í˜•(ë¶€ë™ì†Œìˆ˜ì )**, íŒŒì¼ ì €ì¥ ì§ì „ **sRGB OETF â†’ 8ë¹„íŠ¸ ì •ìˆ˜** + **ICC(sRGB) ë¶€ì°©**.  
- **UI ìº¡ì²˜/ë¬¸ì„œ**ë„ sRGB ê°€ì •ì´ ì•ˆì „(íŠ¹ìˆ˜í•œ ì»¬ëŸ¬ í”„ë¡œí•„ì´ë©´ ICCë¥¼ ë¶™ì—¬ êµ¬ë¶„).

---

## 8) â€œì—°ì‚°ì€ ì„ í˜•ì—ì„œâ€ â€” ì»¨ë³¼ë£¨ì…˜/ì–¸ìƒ¤í”„/ë¸”ë Œë“œ

ìƒ¤í”ˆ/ë¸”ëŸ¬/ê°€ìš°ì‹œì•ˆ/ë¼í”Œë¼ì‹œì•ˆ ë“± **ì»¨ë³¼ë£¨ì…˜**ì€ **ì„ í˜• ì—°ì‚°**ì´ë‹¤.  
ì½”ë“œê°’(sRGB)ì—ì„œ ìˆ˜í–‰í•˜ë©´ **ë°ê¸° ì™œê³¡**ì´ ëˆ„ì ëœë‹¤. ì•„ë˜ëŠ” **ì„ í˜•ì—ì„œ ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬**ë¥¼ ìˆ˜í–‰í•˜ëŠ” í‹€ì´ë‹¤.

```cpp
// Linear-space separable Gaussian blur (BGRA8 in/out)
#include <vector>

static std::vector<float> makeGaussianKernel(float sigma) {
    int radius = (int)std::ceil(3.0f * sigma);
    int size = radius*2 + 1;
    std::vector<float> k(size);
    float s2 = 2.0f * sigma * sigma, sum=0.f;
    for (int i=0;i<size;++i) {
        int x = i - radius;
        float v = std::exp(-(x*x)/s2);
        k[i] = v; sum += v;
    }
    for (float& v : k) v /= sum;
    return k;
}

void GaussianBlur_LinearBGRA(uint8_t* img, int w, int h, int stride, float sigma)
{
    auto k = makeGaussianKernel(sigma);
    int r = (int)k.size()/2;

    std::vector<F4> tmpRow(w), tmpCol(h);

    // Horizontal
    for (int y=0;y<h;++y) {
        uint8_t* row = img + (size_t)stride * y;
        for (int x=0;x<w;++x) {
            F4 acc{0,0,0,0};
            for (int i=-r;i<=r;++i) {
                int xx = std::min(w-1, std::max(0, x+i));
                F4 c = bgra8_to_linearF4(row + xx*4);
                float wv = k[i+r];
                acc.b += c.b * wv;
                acc.g += c.g * wv;
                acc.r += c.r * wv;
                acc.a += c.a * wv; // ì•ŒíŒŒë„ í•„í„°ë§ í•„ìš” ì‹œ
            }
            tmpRow[x] = acc;
        }
        for (int x=0;x<w;++x) linearF4_to_bgra8(tmpRow[x], row + x*4);
    }

    // Vertical
    std::vector<uint8_t> colbuf((size_t)h*4);
    for (int x=0;x<w;++x) {
        for (int y=0;y<h;++y) {
            const uint8_t* p = img + (size_t)stride*y + x*4;
            ((uint8_t*)&colbuf[y*4])[0] = p[0];
            ((uint8_t*)&colbuf[y*4])[1] = p[1];
            ((uint8_t*)&colbuf[y*4])[2] = p[2];
            ((uint8_t*)&colbuf[y*4])[3] = p[3];
        }
        for (int y=0;y<h;++y) {
            F4 acc{0,0,0,0};
            for (int j=-r;j<=r;++j) {
                int yy = std::min(h-1, std::max(0, y+j));
                F4 c = bgra8_to_linearF4(&colbuf[yy*4]);
                float wv = k[j+r];
                acc.b += c.b * wv;
                acc.g += c.g * wv;
                acc.r += c.r * wv;
                acc.a += c.a * wv;
            }
            uint8_t* pd = img + (size_t)stride*y + x*4;
            linearF4_to_bgra8(acc, pd);
        }
    }
}
```

---

## 9) ë””ìŠ¤í”Œë ˆì´ ì¶œë ¥ ê²½ë¡œâ€”GDI/GDI+/Direct2D/WIC ë©”ëª¨

- **GDI (StretchDIBits/SetDIBitsToDevice)**: ê¸°ë³¸ì ìœ¼ë¡œ **ìƒ‰ê´€ë¦¬ ì—†ìŒ**.  
  - `SetICMMode(hdc, ICM_ON)` í›„ `SetICMProfile`ë¡œ í”„ë¡œíŒŒì¼ì„ ì ìš©í•  ìˆ˜ ìˆìœ¼ë‚˜, ì‹¤ì œ ë¼ìŠ¤í„° ë³€í™˜ì€ ì œí•œì .  
  - **ì•ˆì „í•œ ë°©ë²•**: **lcms2ë¡œ ë¯¸ë¦¬ sRGBâ†’ëª¨ë‹ˆí„° ë³€í™˜**í•œ BGRAë¥¼ ë¿Œë¦¬ê¸°.
- **GDI+**: ì´ë¯¸ì§€ ì† í”„ë¡œíŒŒì¼ì„ ì¸ì‹/ë³€í™˜í•  ìˆ˜ ìˆìœ¼ë‚˜, ì„±ëŠ¥/ì œì•½ ê³ ë ¤ í•„ìš”.  
- **WIC + Direct2D**: WIC `IWICColorContext` + D2D Color Managementë¡œ ê²½ë¡œ êµ¬ì„± ê°€ëŠ¥(ê³ ê¸‰).  
- **ê²°ë¡ **: **ì¼ê´€ì„±ê³¼ ì œì–´**ê°€ í•„ìš”í•˜ë©´ **lcms2 ì„ ë³€í™˜**ì´ ê°€ì¥ ì˜ˆì¸¡ ê°€ëŠ¥.

---

## 10) ì‹œë‚˜ë¦¬ì˜¤ë³„ ì²´í¬ë¦¬ìŠ¤íŠ¸

1) **UI ìŠ¤ì¼€ì¼ëŸ¬/ì¸ë„¤ì¼ëŸ¬**  
   - ì…ë ¥: PNG/JPEG(sRGB)  
   - ì²˜ë¦¬: **sRGBâ†’ì„ í˜• â†’ ë¦¬ì‚¬ì´ì¦ˆ/ë¸”ë Œë“œ/ìƒ¤í”ˆ â†’ ì„ í˜•â†’sRGB**  
   - ì¶œë ¥: JPEG/PNGì— **sRGB ICC** ë˜ëŠ” `sRGB`/`gAMA` ì²­í¬ ë¶€ì°©  
   - í™”ë©´: **lcms2ë¡œ ëª¨ë‹ˆí„° ë³€í™˜ í›„** GDI ì¶œë ¥(ì •í™• ëª¨ë“œ) ë˜ëŠ” sRGB ê°€ì • ì¶œë ¥(ê°„í¸ ëª¨ë“œ)

2) **ì‚¬ì§„ ì—ë””í„°(ë¸Œëœë“œ ìƒ‰ ì¤‘ìš”)**  
   - ëª¨ë‹ˆí„° ICC í•„ìˆ˜ ì ìš©, **ìƒëŒ€ ì»¬ëŸ¬ë©”íŠ¸ë¦­ + BPC** ê¶Œì¥  
   - í”„ë¦°íŠ¸ í”„ë£¨í•‘ ì‹œ ì¶œë ¥ìš© í”„ë¡œíŒŒì¼ë¡œë„ ë³€í™˜(ë³„ë„ì˜ soft-proof)

3) **ì´ë¯¸ì§€ í•©ì„±/ì•ŒíŒŒ**  
   - **í•­ìƒ ì„ í˜• í”„ë¦¬ë©€í‹° í•©ì„±**  
   - ì™¸ë¶€ì—ì„œ ì˜¨ PNGê°€ `sRGB` ì²­í¬ë¥¼ ê°€ì§„ë‹¤ë©´ **ë°˜ë“œì‹œ sRGB ë³€í™˜ í›„** ì‘ì—…

---

## 11) ë‹¨ìœ„ í…ŒìŠ¤íŠ¸/ê²€ì¦ ì§€í‘œ

- **ìˆ˜ì¹˜**: PSNR, SSIM. (ê°ë§ˆ-ë¬´ì‹œ vs ê°ë§ˆ-ì •í•© ë¦¬ì‚¬ì´ì¦ˆ ë¹„êµ)  
- **ì‹œê°**:  
  - ê²€ì€ ë°”íƒ• ìœ„ í° í…ìŠ¤íŠ¸ ë‹¤ìš´ìŠ¤ì¼€ì¼ â†’ **ê°€ì¥ìë¦¬ ì–´ë‘¡ê²Œ/ê°ˆë¼ì§** ì—¬ë¶€  
  - ê·¸ë¼ë””ì–¸íŠ¸(0â†’255) ë‹¤ìš´ìŠ¤ì¼€ì¼ â†’ **ë°´ë”©/í†¤ ì™œê³¡** ì—¬ë¶€  
- **ë””ìŠ¤í”Œë ˆì´**: sRGB vs P3 ëª¨ë‹ˆí„°ì—ì„œ **ë¡œê³  ìƒ‰ ì°¨ì´** í™•ì¸(ICC ì ìš© ìœ ë¬´ ë¹„êµ)

---

## 12) ì„±ëŠ¥ ìµœì í™” íŒíŠ¸

- ì„ í˜• ë³€í™˜ì€ **LUT(256â†’float)** ë¡œ ê°€ì† ê°€ëŠ¥  
  - `float srgb2linLUT[256];` / `uint8 lin2srgbLUT[4096]`(ê³ ì •ë°€)  
- SIMD (SSE/AVX/NEON)ë¡œ `srgb_to_linear` ëŒ€ëŸ‰ ì²˜ë¦¬  
- ë¦¬ì‚¬ì´ì¦ˆ/ì»¨ë³¼ë£¨ì…˜ì€ **ë¶„ë¦¬í•©ì„±(Separable)** + íƒ€ì¼ë§ìœ¼ë¡œ ìºì‹œ íš¨ìœ¨ ê°œì„ 

---

## 13) í”í•œ ì‹¤ìˆ˜ vs í•´ê²°

| ì‹¤ìˆ˜ | ì¦ìƒ | í•´ê²° |
|---|---|---|
| sRGB ì½”ë“œê°’ì—ì„œ ë¸”ë Œë”©/ë¦¬ì‚¬ì´ì¦ˆ | ì–´ë‘¡ê²Œ/ë°´ë”©/ë§ì‰ | **ì„ í˜•**ì—ì„œ ì—°ì‚° í›„ sRGBë¡œ ë³µê·€ |
| ëª¨ë‹ˆí„°ê°€ P3ì¸ë° sRGBë¡œ ì¶œë ¥ | ìƒ‰ ê³¼í¬í™” | **ICC ë³€í™˜**(sRGBâ†’ëª¨ë‹ˆí„°) |
| ê°ë§ˆ 2.2 ê·¼ì‚¬ ì‚¬ìš© | ê·¹ì €ëª…ì•”ë¶€ ìƒ‰ í‹€ì–´ì§ | **ì •í™•í•œ sRGB ì‹** ì‚¬ìš© |
| ì•ŒíŒŒ í•©ì„± ë¹„ì„ í˜• | í…Œë‘ë¦¬ í•˜ì¼ë¡œ | **ì„ í˜• í”„ë¦¬ë©€í‹°** í•©ì„± |
| JPEG ì €ì¥ ì‹œ ICC ë¯¸ì²¨ë¶€ | ë‹¤ë¥¸ ì•±/ê¸°ê¸°ì—ì„œ ìƒ‰ í‹€ì–´ì§ | **sRGB ICC** ì²¨ë¶€ |

---

## 14) í•œ ë²ˆì— ì ìš©í•˜ëŠ” â€œíŒŒì´í”„ë¼ì¸ ìŠ¤ë‹ˆí«â€

```cpp
// 1) ë””ì½”ë“œ (JPEG/PNG) â†’ BGRA8(sRGB ê°€ì •) + ë©”íƒ€(ICC/EXIF) í™•ë³´
// 2) sRGBâ†’Linear ë³€í™˜ í›„ ëª¨ë“  í¸ì§‘/ë¦¬ì‚¬ì´ì¦ˆ/í•©ì„± ìˆ˜í–‰
// 3) ì €ì¥ ì „ Linearâ†’sRGB ë³€í™˜ + sRGB ICC ë¶€ì°©(JPEG: APP2 ICC, PNG: sRGB ì²­í¬)
// 4) í™”ë©´ í‘œì‹œ: (ì •ë°€ ëª¨ë“œ) lcms2ë¡œ sRGBâ†’Monitor ICC ë³€í™˜ í›„ GDI ì¶œë ¥

void ProcessAndDisplay(uint8_t* bgra, int w, int h, int stride, HDC hdc) {
    // ì˜ˆ: ì„ í˜• ë¦¬ì‚¬ì´ì¦ˆ í›„ ìƒ¤í”ˆ, ì•ŒíŒŒ í•©ì„± ë“±...
    // ì—¬ê¸°ì„  ê°„ë‹¨íˆ ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ë§Œ ìˆ˜í–‰:
    GaussianBlur_LinearBGRA(bgra, w, h, stride, 1.2f);

    // ë””ìŠ¤í”Œë ˆì´ ICC ì ìš© (ì •í™• ëª¨ë“œ)
    std::wstring icc = GetDefaultMonitorIccPath(hdc);
    if (!icc.empty()) {
        Convert_sRGB_to_MonitorBGRA(bgra, w, h, stride, icc.c_str());
    }
    // ì´ì œ bgraëŠ” ëª¨ë‹ˆí„° ìƒ‰ê³µê°„ì— ë§ì¶°ì¡Œìœ¼ë¯€ë¡œ ê·¸ëŒ€ë¡œ GDIë¡œ ì¶œë ¥
    // StretchDIBits(...) ë“±
}
```

---

## 15) ìš”ì•½

- **ì „ë‹¬í•¨ìˆ˜ ì¼ì¹˜**ëŠ” **í’ˆì§ˆê³¼ ì •í™•ì„±ì˜ í•µì‹¬**:  
  **sRGB ì½”ë“œê°’ â†” ì„ í˜•ê´‘** ë³€í™˜ì„ ì—„ë°€íˆ ìˆ˜í–‰í•˜ê³ , **ì„ í˜•ì—ì„œ ëª¨ë“  í”½ì…€ ì—°ì‚°**ì„ í•˜ë¼.  
- ë””ìŠ¤í”Œë ˆì´ê°€ sRGBê°€ ì•„ë‹Œ ê²½ìš°(ê´‘ìƒ‰ì—­ ë“±)ì—ëŠ” **ICC ë³€í™˜**ìœ¼ë¡œ ì‹¤ì œ í™”ë©´ì— ë§ì¶˜ë‹¤.  
- ì €ì¥ ì‹œ **sRGB ë©”íƒ€(ICC/ì²­í¬) ìœ ì§€**ë¡œ **êµì°¨ í”Œë«í¼ ìƒ‰ ì¼ì¹˜**ë¥¼ ë³´ì¥í•œë‹¤.  
- ìœ„ C++ ìœ í‹¸ê³¼ ì˜ˆì œ(ë¦¬ì‚¬ì´ì¦ˆ/ë¸”ë Œë”©/ì»¨ë³¼ë£¨ì…˜/ICC ë³€í™˜)ë¥¼ **ImageTool** ì½”ë“œë² ì´ìŠ¤ì— ê·¸ëŒ€ë¡œ ì´ì‹í•˜ë©´,  
  â€œ**ì¼ê´€ í’ˆì§ˆÂ·ì •í™• í‘œì‹œ**â€ê°€ ê°€ëŠ¥í•œ **ì „ë‹¬í•¨ìˆ˜ ì •í•© íŒŒì´í”„ë¼ì¸**ì„ ë°”ë¡œ ì–»ì„ ìˆ˜ ìˆë‹¤.
