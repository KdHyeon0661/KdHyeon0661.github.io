---
layout: post
title: JavaScript - 연산자
date: 2025-04-12 19:20:23 +0900
category: JavaScript
---
# 자바스크립트 연산자

## 0. 미리 알아두면 좋은 규칙

- **암묵 변환(ToPrimitive/ToNumber/ToString)**: 비교·산술에서 자주 개입한다.
- **`===` 권장**: `==`는 복잡한 강제 변환 규칙(특례: `null == undefined`만 `true`).
- **단축 평가**: `a && b`는 `a`가 **falsy**면 `a` 즉시 반환, `a || b`는 `a`가 **truthy**면 `a` 반환.
- **우선순위와 결합성**: `**`는 **우결합성**, 대입은 **우결합성**, 대부분은 **좌결합성**.

---

## 1. 산술 연산자 (Arithmetic)

| 연산자 | 설명 | 특징/주의 |
|---|---|---|
| `+` | 덧셈 **또는** 문자열 연결 | 피연산자 중 하나가 문자열이면 **문자열 연결** |
| `-` | 뺄셈 | 문자열·불리언 등은 `ToNumber` 후 연산 |
| `*` | 곱셈 | `NaN` 전파 |
| `/` | 나눗셈 | 정수/실수 구분 없음, `1/0 === Infinity` |
| `%` | 나머지 | 피제수가 음수면 부호는 피제수 따름 |
| `**` | 거듭제곱 | **우결합성**: `2 ** 3 ** 2 === 2 ** (3 ** 2)` |

```js
console.log(1 + 2);         // 3
console.log("a" + 2);       // "a2"  (연결)
console.log("6" - 1);       // 5     (ToNumber)
console.log(true * 3);      // 3     (true -> 1)
console.log(1 / 0);         // Infinity
console.log(2 ** 3 ** 2);   // 512 (2 ** 9)
```

### 전위/후위 증감

```js
let x = 5;
console.log(x++); // 5  (후위: 반환 후 증가)
console.log(++x); // 7  (전위: 증가 후 반환)
```

---

## 2. 대입 및 **논리 대입** (Assignment / Logical Assignment)

| 연산자 | 의미 |
|---|---|
| `=` | 단순 대입 (우결합성) |
| `+=`, `-=`, `*=`, `/=`, `%=` , `**=` | 산술+대입 |
| `&&=`, `||=`, `??=` | **논리 대입** (단축 평가 규칙 + 대입) |

```js
let a = 10;
a += 5;         // 15
a **= 2;        // 225

let title = "";
title ||= "Untitled";   // ''는 falsy → "Untitled"
let port = 0;
port ??= 8080;          // 0은 null/undefined가 아님 → 그대로 0
let token = "abc";
token &&= token.toUpperCase(); // "ABC" (truthy면 변환)
```

---

## 3. 비교 연산자 (Comparison)

### 3.1 기본 비교

| 연산자 | 의미 |
|---|---|
| `==`, `!=` | **느슨한** 동등/부등 (암묵 변환 O) |
| `===`, `!==` | **엄격한** 동등/부등 (타입까지) |
| `<`, `<=`, `>`, `>=` | 대소 비교(숫자/문자열) |

```js
console.log(1 == "1");          // true
console.log(1 === "1");         // false
console.log(null == undefined); // true  (특례)
console.log(false == 0);        // true
console.log(false === 0);       // false
```

### 3.2 문자열 비교(사전식)

```js
console.log("Z" > "a"); // false (유니코드 코드포인트 비교)
console.log("2" > "10"); // true ("2"가 "1"보다 큼)
```

### 3.3 객체 비교(참조)

```js
const o1 = {a:1}, o2 = {a:1};
console.log(o1 === o2); // false (참조 다름)
console.log(o1 == o2);  // false
```

### 3.4 `Object.is` vs `===`

```js
console.log(+0 === -0);            // true
console.log(Object.is(+0, -0));    // false
console.log(NaN === NaN);          // false
console.log(Object.is(NaN, NaN));  // true
```

> **요령**: 값 동등 비교는 대부분 `===`, **NaN/-0** 구분 필요 시 `Object.is`.

---

## 4. 논리 연산자 (Logical) + 단축 평가

| 연산자 | 의미 | 반환 |
|---|---|---|
| `&&` | AND | 첫 falsy 또는 마지막 값 |
| `||` | OR | 첫 truthy 또는 마지막 값 |
| `!` | NOT | 불리언으로 반전 |
| `??` | Nullish 병합 | 좌항이 `null`/`undefined`면 우항 |

```js
console.log("A" && 0 && "B"); // 0
console.log("" || 0 || "X");  // "X"
console.log(null ?? "fallback"); // "fallback"
console.log(0 ?? 42);         // 0 (null/undefined만 대체)
```

**짧은 가드 패턴**

```js
user && doSomething(user);
config.port ??= 8080;  // 포트가 null/undefined일 때만 대입
```

---

## 5. 타입·멤버·생성 관련 연산자

### 5.1 `typeof` — 런타임 타입 문자열

```js
typeof 123;        // "number"
typeof 'x';        // "string"
typeof undefined;  // "undefined"
typeof null;       // "object"  // 역사적 특성
typeof [];         // "object"
typeof (()=>{});   // "function"
```

### 5.2 `in` — 프로퍼티 존재(원형 체인 포함)

```js
const obj = { a:1 };
console.log('a' in obj);      // true
console.log('toString' in obj); // true (원형 체인)
```

### 5.3 `instanceof` — 프로토타입 체인 검사

```js
[] instanceof Array;      // true
new Date() instanceof Date; // true
```

**주의**: iframe·리얼름 경계를 넘으면 다른 `Array` 생성자 → `instanceof` 실패 가능. **대안**: `Object.prototype.toString.call(v) === "[object Array]"` 또는 `Array.isArray(v)`.

### 5.4 `new` — 생성자 호출

```js
function Person(n){ this.name = n; }
const p = new Person("Lee");
```

### 5.5 `delete` — 프로퍼티 제거

```js
const o = { a:1 };
delete o.a;   // true
// delete 선언된 변수/함수는 불가(엄격 모드 에러)
```

### 5.6 `void` — 표현식 평가 후 `undefined` 반환

```js
void 0;           // undefined
void (console.log("side-effect")); // 로그 찍고 undefined
```

---

## 6. 비트 연산자 (Bitwise) — 32비트 정수 변환 주의

| 연산자 | 설명 |
|---|---|
| `&`, `|`, `^` | AND/OR/XOR |
| `~` | NOT (비트 반전) |
| `<<`, `>>` | 왼/오른쪽 쉬프트 (부호 유지) |
| `>>>` | 부호 없는 오른쪽 쉬프트 |

```js
console.log(5 & 3);   // 1 (0101 & 0011)
console.log(~1);      // -2 (~0001 -> ...1110)
console.log(-1 >>> 0); // 4294967295 (부호 없는 변환 트릭)
```

> **주의**: 비트 연산자는 **Number를 32비트 정수**로 강제 변환한다. `BigInt`에는 별도 비트 연산자 사용 불가(혼합 금지).

---

## 7. 단항 연산자 (Unary)

| 연산자 | 설명 |
|---|---|
| `+x` | `ToNumber(x)` (빠른 숫자화) |
| `-x` | 부호 반전 (`ToNumber`) |
| `!x` | 불리언 반전 (`ToBoolean`) |
| `~x` | 비트 반전(32비트) |
| `typeof`, `void`, `delete` | 위 섹션 참조 |

```js
console.log(+"42");    // 42
console.log(-"8.5");   // -8.5
console.log(!"");      // true (''은 falsy)
```

---

## 8. **암묵 변환(Coercion)**와 ToPrimitive

### 8.1 덧셈 vs 문자열 연결

```js
console.log(1 + "2");   // "12" (문자열 우세)
console.log("2" - 1);   // 1    (ToNumber)
console.log([1,2] + 3); // "1,23" ([1,2].toString() -> "1,2")
```

### 8.2 사용자 정의 변환

```js
const price = {
  amount: 1000,
  [Symbol.toPrimitive](hint) {
    return hint === "string" ? `$${this.amount}` : this.amount;
  }
};
console.log(String(price)); // "$1000"
console.log(price + 500);   // 1500
```

---

## 9. BigInt와 산술

```js
const big = 10n ** 30n;
console.log(big + 1n);   // OK
// console.log(big + 1); // TypeError: 혼합 불가
```

> 필요 시 명시적 변환: `BigInt(42)` 또는 `Number(1n)` (정밀도 손실 주의)

---

## 10. 삼항·쉼표·옵셔널 체이닝(참고)

### 10.1 삼항 (조건 ? A : B)

```js
const age = 20;
const tag = (age >= 18) ? "성인" : "미성년자";
```

### 10.2 쉼표 연산자 `,` — 마지막 값 반환

```js
let x = (console.log("a"), 3 + 4, 7);
console.log(x); // 7
```

### 10.3 **옵셔널 체이닝 `?.`** (연산자 아님에 가깝지만 함께 쓰이는 패턴)

```js
const city = user?.address?.city ?? "unknown";
```

---

## 11. 연산자 우선순위 & 결합성 (요약)

우선순위가 **높을수록 먼저** 계산된다.

1. `()`  
2. 단항: `!`, `~`, `+x`, `-x`, `typeof`, `void`, `delete`  
3. 거듭제곱 `**` (**우결합성**)  
4. 곱셈·나눗셈·나머지 `* / %`  
5. 덧셈·뺄셈 `+ -`  
6. 시프트 `<< >> >>>`  
7. 관계 `< <= > >= in instanceof`  
8. 동등 `== != === !==`  
9. **Nullish 병합 `??`**  
10. **논리 AND `&&`**  
11. **논리 OR `||`**  
12. 삼항 `?:`  
13. 대입 `= += -= ... &&= ||= ??=` (**우결합성**)  
14. 쉼표 `,`

> **주의**: `??`는 `&&`/`||`와 **혼용 시 괄호 필수**(문법 에러 방지)

```js
// SyntaxError: `??`는 `||`/`&&`와 직접 혼용 불가
// a ?? b || c

// 올바른 예:
(a ?? b) || c;
```

---

## 12. **실전 패턴** — 단축 평가로 가독성 높이기

### 12.1 옵션 병합

```js
function init(cfg = {}) {
  const host = cfg.host ?? "localhost";
  const port = cfg.port ?? 8080;    // 0 허용
  const verbose = !!cfg.verbose;    // 불리언화
  return { host, port, verbose };
}
```

### 12.2 안전 접근과 기본값

```js
const city = user?.address?.city ?? "N/A";
```

### 12.3 게으른 계산

```js
const expensive = () => { /* heavy */ return 42; };
const val = cache || (cache = expensive()); // 좌항 falsy면 우항 실행
```

---

## 13. **함정 모음** (빠른 점검)

```js
console.log([] == 0);        // true    (ToPrimitive -> "" -> 0)
console.log([0] == 0);       // true    ("0" -> 0)
console.log('' == 0);        // true
console.log(false == '0');   // true
console.log(null == 0);      // false   (특례) 
console.log(null >= 0);      // true?  (관계 연산은 ToNumber로 비교) 
```

> **전략**: 동등성은 `===`, 정렬/검색은 **명시적 변환**(`Number(x)`, `String(x)`) 후 수행.

---

## 14. **테스트 가능 스니펫** (작동 원리 체감)

### 14.1 우선순위 체험

```js
console.log(1 + 2 * 3);          // 7
console.log((1 + 2) * 3);        // 9
console.log(2 ** 3 ** 2);        // 512
console.log((2 ** 3) ** 2);      // 64
```

### 14.2 논리 대입 3총사

```js
let a = 0, b = "", c = null;
a ||= 7;   // 7 (0은 falsy)
b &&= 9;   // "" (falsy라 대입 안 함)
c ??= 1;   // 1 (null/undefined만 대입)
console.log(a, b, c);
```

### 14.3 `Object.is` 비교

```js
const vals = [+0, -0, NaN, 1];
for (const v of vals) {
  console.log(v, v === v, Object.is(v, v));
}
// +0 true true; -0 true true; NaN false true (자기 자신과 비교)
```

---

## 15. **퀵 레퍼런스 표**

### 15.1 Truthy/Falsy (자주 쓰는 값)

- **falsy**: `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`, `NaN`  
- 위 이외는 대부분 **truthy** (예: `[]`, `{}`, `"0"`, `"false"`)

### 15.2 자주 섞는 조합과 결과

| 표현식 | 결과 |
|---|---|
| `a || b` | `a`가 truthy면 `a`, 아니면 `b` |
| `a && b` | `a`가 falsy면 `a`, 아니면 `b` |
| `a ?? b` | `a`가 `null/undefined`면 `b`, 아니면 `a` |
| `a ||= b` | `a`가 falsy면 `a=b` |
| `a &&= b` | `a`가 truthy면 `a=b` |
| `a ??= b` | `a`가 `null/undefined`면 `a=b` |

---

## 16. **실전 문제(스스로 점검)**

```js
// Q1: 아래의 출력?
console.log(0 || "A" && "B");      

// Q2: 아래 결과?
console.log(null ?? 0 || "X");     

// Q3: 아래 비교 결과?
console.log([] == ![]);            

// Q4: 괄호 없으면 문법 에러인 식?
// a ?? b || c

// Q5: 안전한 합수 만들기
function add(a, b) {
  // number/BigInt 혼합 금지, 문자열은 연결
}
```

**해설 힌트**

- Q1: `&&`가 `||`보다 먼저. `"A" && "B"` → `"B"`, `0 || "B"` → `"B"`.
- Q2: `null ?? 0` → `0`, `0 || "X"` → `"X"`.
- Q3: `![]`는 `false` → `[] == false` → `ToPrimitive([]) -> ""`, `"" == 0`, `0 == 0` → `true`.  
  (이래서 `==`는 지양!)
- Q4: `(a ?? b) || c`처럼 괄호 필요.
- Q5: 타입별 분기(`number`+`number`, `bigint`+`bigint`, 문자열 포함 시 연결, 그 외 오류).

예시 구현:

```js
function add(a, b) {
  const ta = typeof a, tb = typeof b;
  if (ta === "number" && tb === "number") return a + b;
  if (ta === "bigint" && tb === "bigint") return a + b;
  if (ta === "string" || tb === "string") return String(a) + String(b);
  throw new TypeError("Unsupported types");
}
```

---

## 17. 결론 & 체크리스트

- [ ] **동등성**: 기본은 `===`, 특수값 비교는 `Object.is`.
- [ ] **단축 평가**를 “흐름 제어”처럼 활용: `||`, `&&`, `??`, 그리고 `||=`, `&&=`, `??=`.
- [ ] **암묵 변환**은 명확히: 연산 전 `Number()`, `String()` 등 **명시 변환** 습관화.
- [ ] **우선순위/결합성** 기억: `**`/대입은 **우결합**, `??`와 `||/&&` 혼용 시 괄호.
- [ ] **BigInt**는 Number와 **혼합 금지**. 필요 시 **명시 변환**.
- [ ] **비트 연산**은 32비트 정수 강제 변환 → 대형 정밀 정수에는 부적합.