---
layout: post
title: 소켓프로그래밍 - 프레이밍
date: 2025-09-14 19:25:23 +0900
category: 소켓프로그래밍
---
## 5. 프레이밍(메시지 경계) 설계론

> 핵심: TCP는 **바이트 스트림**이므로, **메시지 경계**는 애플리케이션이 직접 **프레이밍**으로 정의해야 한다.  
> 대표 방식: **길이-프리픽스(4B 빅엔디안)**, **구분자 기반(Delimiter)**, **TLV 헤더(타입-길이-값)**.  
> 또한 **큰 메시지**와 **조각내기(Chunking)**, **최대 프레임(cap) 정책**으로 **안전성**을 확보해야 한다.

---

### 5.1 왜 프레이밍인가 — 문제 정의

- TCP는 다음을 **보장하지 않는다**:
  1) 메시지 경계(어디서 한 메시지가 끝나는가?)  
  2) 한 번의 `send()` == 한 번의 `recv()` (아니다!)  
- 따라서 **수신 파서**는 반드시:
  - **헤더/구분자**로 경계를 식별,
  - **부분 입출력**을 고려한 **상태 머신**,
  - **길이 상한(cap)** 으로 **자원 공격 방지**를 해야 한다.

> 설계 목표: **정확성(경계/순서)**, **효율(복사 최소화)**, **보안(상한/검증)**, **확장성(버전/옵션)**.

---

## 5.2 프레이밍 3대 방식 개관

| 방식 | 핵심 아이디어 | 장점 | 단점 | 적합 사례 |
|---|---|---|---|---|
| 길이-프리픽스(4B, big-endian) | 앞에 고정 길이 헤더(길이)를 붙인다 | 파싱 단순, 고성능, 이진 안전 | 헤더 손상 시 동기화 난이도 | 대부분의 **이진 프로토콜** |
| 구분자 기반(Delimiter) | 메시지 끝에 구분자(`\n`, `\r\n`, `\0`) | 가독성, 사람이 읽기 쉬움 | 바이너리 포함 시 이스케이프 필요, 스캔 비용 | **텍스트 프로토콜**(라인 기반) |
| TLV 헤더 | (Type, Length, Value) 튜플들의 연속 | 버전/옵션에 유연, 확장성 | 구현 복잡도, 헤더 검증 필요 | **확장 가능한 이진 프로토콜** |

---

## 5.3 길이-프리픽스(빅엔디안 4바이트)

### 5.3.1 포맷 정의(기본)
- 헤더: **4바이트 길이**(네트워크 바이트 오더 = **빅엔디안**)
- 페이로드: 길이만큼의 **원시 바이트**
- 최대 길이(CAP): 설계 시 반드시 설정(예: `16MiB`)

수식:
$$
\text{Frame} = \text{len}_{(4\ \text{bytes, BE})} \ \Vert\ \text{payload}[\text{len}]
$$

### 5.3.2 C++23 송수신 예제(안전 루틴 포함)

```cpp
// framing_lenprefix.hpp
#pragma once
#include <vector>
#include <span>
#include <expected>
#include <system_error>
#include <cstddef>
#include <cstring>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>

inline std::error_code last_errno(){ return {errno, std::generic_category()}; }

inline std::expected<std::size_t, std::error_code>
send_all(int fd, std::span<const std::byte> buf) {
    std::size_t sent = 0;
    while (sent < buf.size()) {
        ssize_t n = ::send(fd, buf.data()+sent, buf.size()-sent, 0);
        if (n > 0) { sent += (std::size_t)n; continue; }
        if (n == 0) break;
        if (errno == EINTR) continue;
        return std::unexpected(last_errno());
    }
    return sent;
}

inline std::expected<std::size_t, std::error_code>
recv_exact(int fd, std::span<std::byte> buf) {
    std::size_t got = 0;
    while (got < buf.size()) {
        ssize_t n = ::recv(fd, buf.data()+got, buf.size()-got, 0);
        if (n > 0) { got += (std::size_t)n; continue; }
        if (n == 0) return std::unexpected(std::make_error_code(std::errc::connection_reset));
        if (errno == EINTR) continue;
        return std::unexpected(last_errno());
    }
    return got;
}

inline std::expected<void, std::error_code>
send_frame_lp(int fd, std::span<const std::byte> payload) {
    uint32_t len = static_cast<uint32_t>(payload.size());
    uint32_t be = ::htonl(len);
    auto h = send_all(fd, std::as_bytes(std::span{&be,1}));
    if (!h) return std::unexpected(h.error());
    auto b = send_all(fd, payload);
    if (!b) return std::unexpected(b.error());
    return {};
}

inline std::expected<std::vector<std::byte>, std::error_code>
recv_frame_lp(int fd, std::size_t cap=(1u<<20)) {
    uint32_t be{};
    auto h = recv_exact(fd, std::as_writable_bytes(std::span{&be,1}));
    if (!h) return std::unexpected(h.error());
    uint32_t len = ::ntohl(be);
    if (len > cap) return std::unexpected(std::make_error_code(std::errc::message_size));
    std::vector<std::byte> buf(len);
    auto b = recv_exact(fd, std::span<std::byte>(buf.data(), buf.size()));
    if (!b) return std::unexpected(b.error());
    return buf;
}
```

### 5.3.3 장점/단점 심층
- **장점**
  - 수신 측은 **단 2단계**(헤더 4B → payload N바이트)로 명료.
  - **바이너리 안전**(임의 바이트 포함 가능).
  - 길이가 확실해 **버퍼 할당**/IO 계획 수립이 용이.
- **단점**
  - 헤더가 **깨지면** 동기화 복구가 필요(재동기화 전략 필요).
  - 큰 길이가 오면 **메모리 압박** → CAP로 방어.

### 5.3.4 재동기화 전략(헤더 손상 대비)
- **마법값(Magic)** + **버전**을 헤더 앞에 추가(예: 2바이트 ‘MG’) 후 탐색.
- **옵션**: 헤더에 **CRC-16/32** 를 두어 손상 탐지 → 실패 시 **스트림 폐기** 또는 **마커 재탐색**.

---

## 5.4 구분자 기반(Delimiter)

### 5.4.1 포맷 정의
- 메시지 끝에 **구분자** 삽입. 예: `\n`(LF), `\r\n`(CRLF), `\0`(NUL)
- 텍스트 프로토콜(HTTP/1.x 헤더, SMTP, Redis RESP-라인 등)에 흔함

$$
\text{Frame} = \text{bytes until delimiter} \ \Vert\ \text{DELIM}
$$

### 5.4.2 구현 핵심 — **스캔 버퍼** + **상태 머신**
- 수신 버퍼(예: `std::vector<char>`)에 데이터를 누적
- **구분자 위치**를 찾을 때까지 `recv()` 반복
- 찾으면 그 앞까지를 **완성 프레임**으로 반환, 나머지 버퍼는 유지

```cpp
// framing_delim.hpp
#pragma once
#include <vector>
#include <string>
#include <span>
#include <expected>
#include <system_error>
#include <algorithm>

inline std::expected<std::size_t, std::error_code>
recv_some(int fd, std::span<char> buf) {
    ssize_t n = ::recv(fd, buf.data(), buf.size(), 0);
    if (n > 0) return (std::size_t)n;
    if (n == 0) return std::unexpected(std::make_error_code(std::errc::connection_reset));
    if (errno == EINTR) return recv_some(fd, buf);
    return std::unexpected(std::error_code(errno, std::generic_category()));
}

struct DelimReader {
    std::vector<char> buf;
    char delim = '\n';
    std::size_t cap = 1<<20; // 1MiB

    std::expected<std::string, std::error_code> next_line(int fd) {
        for (;;) {
            // 1) 구분자 검색
            auto it = std::find(buf.begin(), buf.end(), delim);
            if (it != buf.end()) {
                std::string line(buf.begin(), it);
                buf.erase(buf.begin(), it+1); // delim까지 제거
                return line;
            }
            // 2) cap 방어
            if (buf.size() >= cap) return std::unexpected(std::make_error_code(std::errc::message_size));
            // 3) 더 받기
            std::array<char, 4096> tmp{};
            auto r = recv_some(fd, std::span<char>(tmp.data(), tmp.size()));
            if (!r) return std::unexpected(r.error());
            buf.insert(buf.end(), tmp.data(), tmp.data()+*r);
        }
    }
};
```

### 5.4.3 장점/단점 심층
- **장점**
  - 구현이 간단(텍스트 기준).
  - 디버깅/수동 테스트가 쉬움(사람이 읽음).
- **단점**
  - **바이너리 안전 X**: 구분자 바이트가 페이로드에 나타나면 **이스케이프** 필요(`\n` → `\\n` 등) → 복잡.
  - **스캔 비용**: 긴 라인/큰 버퍼에서 **선형 검색 비용**.
  - **멀티라인 규약** 필요(예: HTTP: 빈 줄이 헤더 끝).

### 5.4.4 바이너리 안전을 위해 — **길이+구분자** 혼합
- 헤더로 **길이**를 보내고, 끝에 **구분자**를 추가해 **재동기화 힌트**로 사용.
- 또는 텍스트만 구분자, 바이너리는 **Base64/Hex**로 인코딩(비용 증가).

---

## 5.5 TLV 헤더 (Type-Length-Value)

### 5.5.1 포맷 정의(예시: 1B Type, 3B Length, N Byte Value)
- **Type(1B)**: 메시지 종류(예: 0x01=PING, 0x02=DATA, 0x10=AUTH…)  
- **Length(3B, BE)**: 값의 길이(최대 16,777,215)  
- **Value(NB)**: 실제 데이터

수식:
$$
\text{TLV} = \text{Type}_{(1B)} \ \Vert\ \text{Len}_{(24\text{bits, BE})} \ \Vert\ \text{Value}[\text{Len}]
$$

- 연속된 TLV들의 스트림: `TLV TLV TLV ...`

### 5.5.2 C++23 구현(부분)

```cpp
// framing_tlv.hpp
#pragma once
#include <vector>
#include <span>
#include <expected>
#include <cstdint>
#include <system_error>
#include <cstring>

inline uint32_t be24_to_u32(const unsigned char b[3]) {
    return (uint32_t(b[0])<<16) | (uint32_t(b[1])<<8) | uint32_t(b[2]);
}
inline void u32_to_be24(uint32_t n, unsigned char b[3]) {
    b[0] = (n >> 16) & 0xFF;
    b[1] = (n >> 8) & 0xFF;
    b[2] = n & 0xFF;
}

struct TLV {
    uint8_t type{};
    std::vector<std::byte> value;
};

inline std::expected<void, std::error_code>
send_tlv(int fd, uint8_t type, std::span<const std::byte> value) {
    unsigned char hdr[4];
    hdr[0] = type;
    if (value.size() > 0xFFFFFFu)
        return std::unexpected(std::make_error_code(std::errc::message_size));
    u32_to_be24((uint32_t)value.size(), &hdr[1]);
    // 헤더 + 값
    auto h = send_all(fd, std::as_bytes(std::span{hdr, sizeof(hdr)}));
    if (!h) return std::unexpected(h.error());
    auto b = send_all(fd, value);
    if (!b) return std::unexpected(b.error());
    return {};
}

inline std::expected<TLV, std::error_code>
recv_tlv(int fd, std::size_t cap=(1u<<20)) {
    unsigned char hdr[4];
    auto h = recv_exact(fd, std::as_writable_bytes(std::span{hdr, sizeof(hdr)}));
    if (!h) return std::unexpected(h.error());
    uint8_t type = hdr[0];
    uint32_t len = be24_to_u32(&hdr[1]);
    if (len > cap) return std::unexpected(std::make_error_code(std::errc::message_size));
    TLV t; t.type = type; t.value.resize(len);
    auto b = recv_exact(fd, std::span<std::byte>(t.value.data(), t.value.size()));
    if (!b) return std::unexpected(b.error());
    return t;
}
```

### 5.5.3 장점/단점 심층
- **장점**
  - 다형성/확장성: 타입별로 **다른 구조**를 담아도 통일된 파서.
  - **옵션/버전** 호환에 유리(새 타입 추가).
- **단점**
  - 구현·테스트 복잡도 ↑.
  - **헤더 검증** 부실 시 파서가 **동기화 상실**.

---

## 5.6 큰 메시지, 조각내기(Chunking), 최대 프레임(cap) 정책

### 5.6.1 왜 필요한가?
- **메모리 고갈 방지**: 길이 4GiB 등 비정상 입력으로 **벡터 할당 폭탄**.  
- **지연 완화**: 큰 덩어리를 쪼개 **스트리밍 처리**(즉시 소비/가공).  
- **전송 재시도/재개**: Chunk 단위로 재전송/검증.

### 5.6.2 정책의 3요소
1) **CAP(최대 프레임)**: 단일 메시지/프레임의 상한(예: 16MiB). 초과 시 **즉시 거절**.  
2) **Chunk Size**: 큰 페이로드를 **고정 크기 조각**으로 나누기(예: 64KiB).  
3) **Windowing**: 수신 확인/흐름 제어(프레임 수 N개 혹은 바이트 합계 M바이트까지 동시 인플라이트 제한).

### 5.6.3 길이-프리픽스와 Chunking 혼합 설계
- 상위 수준 메시지를 **청크들의 시퀀스**로 정의:
  - `MSG_START(len_total)` → `CHUNK(data_i)` … → `MSG_END(checksum)`  
- 각 프레임은 **작은 길이**만 갖고, 전체 길이는 `MSG_START`에 포함.  
- 수신 측은 **스트리밍 처리**: 청크 도착 즉시 쌓거나 바로 처리.

```cpp
// chunked.hpp (요지)
#pragma once
#include <cstdint>
#include <vector>
#include <span>
#include <expected>

// MSG_START: type=0x01, length=8B(총 길이, BE)
inline std::expected<void, std::error_code>
send_msg_start(int fd, uint64_t total_len) {
    std::vector<std::byte> payload(8);
    uint64_t be = htobe64(total_len); // 플랫폼별 구현 필요(혹은 byteswap)
    std::memcpy(payload.data(), &be, 8);
    return send_tlv(fd, 0x01, payload);
}

// CHUNK: type=0x02, value=데이터 조각
inline std::expected<void, std::error_code>
send_chunk(int fd, std::span<const std::byte> chunk) {
    return send_tlv(fd, 0x02, chunk);
}

// MSG_END: type=0x03, value=optional checksum
inline std::expected<void, std::error_code>
send_msg_end(int fd, uint32_t crc32) {
    uint32_t be = htonl(crc32);
    return send_tlv(fd, 0x03, std::as_bytes(std::span{&be, 1}));
}
```

> **참고**: `htobe64` 는 표준 C에 없음. C++23에선 `std::byteswap` + `std::endian`으로 구현 가능. (이전 답변 참조)

### 5.6.4 CAP 계산 직관
- 메모리 여유 `M` (예: 프로세스 제한 512MiB)  
- 동시 연결 수 `C` (예: 1,000)  
- 연결당 최대 프레임 `cap` 은 **보수적으로**:
  $$
  \text{cap} \le \frac{M}{C \times \alpha}
  $$
  여기서 $$\alpha$$ 는 **오버헤드 계수**(버퍼/파서/메타데이터), 보통 2~4.  
- 예: `M=512 MiB, C=1000, α=4` → `cap ≤ 128 KiB`. (실무에선 **조절** 필요. 파일 전송 등은 Chunking으로 해결)

### 5.6.5 Chunk 크기 선택
- 네트워크/메모리/복사 비용 트레이드오프:
  - 너무 작으면 헤더 오버헤드 증가, syscalls 증가.
  - 너무 크면 레이턴시↑, 버퍼 압박.
- 경험칙: **32~128 KiB** 사이에서 시작해 **측정 기반**으로 튜닝.

---

## 5.7 재전송/무결성: 체크섬/해시 선택

- **TCP**는 **전송 중 오류 검출**(TCP checksum)을 제공하지만, **응용 레벨 무결성**은 별도일 수 있다.
- 옵션:
  - **CRC32**(빠르고 간단)  
  - **SHA-256**(보안 무결성)  
- TLV의 `MSG_END` 에 체크섬/해시 포함 → 수신에서 **검증** 후 승인.

```cpp
// 예시: CRC32 (의사코드)
uint32_t crc32(std::span<const std::byte> data);
```

---

## 5.8 파서의 상태 머신 설계(길이-프리픽스 예)

### 5.8.1 상태 정의
- `READ_LEN(4B)` → `READ_PAYLOAD(NB)` → `EMIT_FRAME` 반복
- 부분 입출력/버퍼 경계에서 **부분만 도착**해도 상태 유지

```cpp
// parser_lenprefix.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <expected>
#include <system_error>
#include <cstring>

struct LPParser {
    enum class State { READ_LEN, READ_PAYLOAD };
    State st = State::READ_LEN;
    uint32_t be_len{};
    uint32_t len{};
    std::vector<std::byte> payload;
    std::size_t cap = 1<<20;

    // 입력 바이트를 공급하면, 완성 프레임이 있으면 반환
    std::expected<std::vector<std::byte>, std::error_code>
    feed(std::span<const std::byte> in) {
        std::size_t off=0;
        while (off < in.size()) {
            if (st == State::READ_LEN) {
                std::size_t need = 4 - have_len();
                std::size_t take = std::min(need, in.size()-off);
                std::memcpy(((char*)&be_len) + have_len(), in.data()+off, take);
                off += take;
                if (have_len() == 4) {
                    len = ntohl(be_len);
                    if (len > cap) return std::unexpected(std::make_error_code(std::errc::message_size));
                    payload.clear();
                    payload.resize(len);
                    set_have_len(0); // reset temp tracking
                    st = State::READ_PAYLOAD;
                }
            } else {
                std::size_t have = have_payload();
                std::size_t need = len - have;
                std::size_t take = std::min(need, in.size()-off);
                std::memcpy(payload.data()+have, in.data()+off, take);
                off += take;
                set_have_payload(have+take);
                if (have_payload() == len) {
                    st = State::READ_LEN;
                    // 완성 프레임 반환
                    return payload;
                }
            }
        }
        return std::unexpected(std::make_error_code(std::errc::operation_would_block));
    }

    // 내부 진행 추적용(간단히 union처럼 쓰기 위한 헬퍼)
    std::size_t tmp_len_bytes = 0;
    std::size_t have_len() const { return tmp_len_bytes; }
    void set_have_len(std::size_t v){ tmp_len_bytes = v; }
    std::size_t tmp_payload_bytes = 0;
    std::size_t have_payload() const { return tmp_payload_bytes; }
    void set_have_payload(std::size_t v){ tmp_payload_bytes = v; }
};
```

> 실제 구현에서는 버퍼/인덱스 추적을 더 세련되게 만들고, **반복적으로 여러 프레임**을 뽑아낼 수 있게 한다.

---

## 5.9 텍스트 라인 파서(구분자)의 상태 머신

- **라인 길이 상한(line cap)** 을 반드시 둔다(예: 64KiB).
- \r\n, \n 둘 다 허용 시 처리를 명확히.

```cpp
// parser_line.hpp
#pragma once
#include <vector>
#include <string>
#include <expected>
#include <system_error>
#include <algorithm>

struct LineParser {
    std::vector<char> buf;
    char delim = '\n';
    std::size_t cap = 64*1024;

    std::expected<std::string, std::error_code>
    feed(std::span<const char> in) {
        if (buf.size() + in.size() > cap) return std::unexpected(std::make_error_code(std::errc::message_size));
        buf.insert(buf.end(), in.begin(), in.end());
        auto it = std::find(buf.begin(), buf.end(), delim);
        if (it == buf.end())
            return std::unexpected(std::make_error_code(std::errc::operation_would_block));
        std::string line(buf.begin(), it);
        buf.erase(buf.begin(), it+1);
        return line;
    }
};
```

---

## 5.10 실전 체크리스트

- [ ] **프레이밍 방식 선택**: 바이너리/텍스트/확장성 요구 분석  
- [ ] **엔디안**: 네트워크 바이트 오더(**빅엔디안**)로 규정  
- [ ] **CAP**: 단일 프레임/라인/청크 상한(DoS 방지)  
- [ ] **상태 머신**: 부분 입출력/재진입 안전  
- [ ] **재동기화 전략**: 마커/CRC/버전  
- [ ] **Chunking**: 대형 페이로드 스트리밍 + 검증  
- [ ] **무결성**: CRC32/SHA-256 등 필요 시 채용  
- [ ] **관측**: hexdump/log로 프레임 경계 확인

---

## 5.11 비교 예제: 세 가지 프레이밍으로 같은 메시지 전송

### 5.11.1 공통 메시지
- 문자열: `"The quick brown fox jumps over the lazy dog."` (44B)

### 5.11.2 길이-프리픽스(4B)
- 헤더: `00 00 00 2C` (44)  
- 페이로드: 44바이트 그대로

### 5.11.3 구분자 기반(`\n`)
- 메시지: 44바이트 + `\n`  
- 수신은 라인 스캐너로 `\n` 직전까지를 메시지로

### 5.11.4 TLV (Type=0x02, Len=44)
- 헤더: `02 00 00 2C`  
- 값: 44바이트

---

## 5.12 성능 팁과 수식 몇 가지

- **Nagle / Delayed ACK** 고려: 작은 메시지를 **coalescing**(배치) 또는 `TCP_NODELAY` 조합으로 측정 기반 최적화.
- **Zero-copy**: 큰 메시지는 `sendfile` / `writev` / `sendmsg` 고려.
- **헤더-바디 분리**: `iovec` 2개로 한 번의 `sendmsg`:
  - $$ \text{syscalls} \downarrow \Rightarrow \text{context switch} \downarrow $$

---

## 5.13 미니 프로젝트 — 파일 스트리밍 프로토콜(Chunked TLV)

### 5.13.1 프로토콜 요약
- `0x10 FILE_START`: 파일명/총 길이/해시 알고리즘  
- `0x11 FILE_CHUNK`: 데이터 조각  
- `0x12 FILE_END`: 최종 해시

### 5.13.2 서버 스케치(수신자)
```cpp
// file_server.cpp (요지)
for (;;) {
    auto tlv = recv_tlv(fd, 1<<20);
    if (!tlv) break;
    if (tlv->type == 0x10) {
        // 파싱: filename, total_len, algo
        // 파일 열기, 누적 해시 init
    } else if (tlv->type == 0x11) {
        // chunk write + hash update
    } else if (tlv->type == 0x12) {
        // 수신 해시 == 계산 해시 ? OK : ERROR
    }
}
```

### 5.13.3 클라이언트 스케치(송신자)
```cpp
// file_client.cpp (요지)
send_tlv(fd, 0x10, meta_payload);
while (auto n = fread(buf,1,CHUNK,fp)) {
    send_tlv(fd, 0x11, std::as_bytes(std::span{buf, n}));
}
send_tlv(fd, 0x12, std::as_bytes(std::span{&crc,1}));
```

- **정확성**: TLV 덕분에 **다중 파일**/추가 메타데이터에 유연.

---

## 5.14 디버깅과 관측

- **hexdump** 로 프레임 경계 확인:
```cpp
#include <print>
inline void hexdump(std::span<const std::byte> s) {
    std::size_t i=0;
    for (auto b : s) {
        if (i%16==0) std::print("{:08X}  ", (unsigned)i);
        std::print("{:02X} ", (unsigned)std::to_integer<unsigned char>(b));
        if (++i%16==0) std::print("\n");
    }
    if (i%16) std::print("\n");
}
```

- **Wireshark**: TCP 스트림 팔로우(바이트 화면에서 헤더와 페이로드 경계를 눈으로 검증).
- **`strace -e trace=network`**: `send/recv` 호출 길이(부분 입출력) 확인.

---

## 5.15 마무리

- **프레이밍은 TCP 위의 생명줄**: 경계가 없는 스트림을 **의미 있는 메시지**로 만든다.  
- **길이-프리픽스**는 기본값으로 훌륭하고, **구분자**는 텍스트에 적합, **TLV**는 확장성이 뛰어나다.  
- 어떤 방식을 택하든 **CAP/Chunking/상태 머신/무결성**을 *함께* 설계해야 실전에서 **안전하고 튼튼**하다.  
- 이후 단계: **에러 주입 테스트**(헤더 깨짐/길이 과대/청크 누락)와 **부하 측정**으로 파서와 전송 경로를 단단히 만든다.
