---
layout: post
title: 소켓프로그래밍 - 프레이밍
date: 2025-09-14 19:25:23 +0900
category: 소켓프로그래밍
---
# TCP 프레이밍 설계론 - 길이-프리픽스, 구분자, TLV, Chunking

## 1. 문제 정의: 왜 프레이밍이 반드시 필요한가

### 1.1 TCP는 “메시지 프로토콜”이 아니다

TCP는 다음을 보장한다.

- **순서 보장**: 송신한 바이트 순서대로 수신.
- **손실 복구**: 손실된 세그먼트 재전송, 스트림 상에서 재조립.
- **중복 제거**: 중복 수신 세그먼트는 제거.

하지만 TCP는 절대 보장하지 않는 게 있다.

1. **메시지 경계(message boundary)**  
   - “여기까지가 한 메시지”라는 구분이 없다.
   - 오직 **바이트의 연속**(스트림)만 있을 뿐이다.

2. “한 번의 `send()` == 한 번의 `recv()`”  
   - 송신 측에서 `send(fd, buf, 1000, ...)` 를 한 번 호출해도,
   - 수신 측에서는 `recv` 3번에 `300+300+400` 으로 쪼개서 도착할 수 있다.
   - 반대로, 송신 측에서 `send` 3번(300, 300, 400)을 호출했는데  
     수신 측에서는 `recv` 한 번에 1000바이트가 한꺼번에 올 수도 있다.

그래서 **“메시지 단위”는 전적으로 애플리케이션의 책임**이다.

### 1.2 부분 입출력(Partial I/O)과 상태 머신

TCP 소켓에서 `send`/`recv`는 항상 **부분 입출력**을 가정해야 한다.

- 송신: `send`가 요청한 만큼보다 **적게** 보낼 수 있다.
- 수신: `recv`가 버퍼 크기보다 **적게** 읽을 수 있다.
- 신호(EINTR)나 비블로킹 모드(EAGAIN)에서는 **아무 것도 못 읽고** 돌아올 수도 있다.

따라서 수신 루틴은 단순히

```cpp
recv(fd, buf, sizeof(buf), 0);
```

한 번으로 끝나는 것이 아니라,

- **지금까지 얼마나 읽었는지를 기억**하고,
- **다음에 들어오는 바이트를 앞의 부족분에 합쳐서**,
- **메시지 경계에 도달하면 비로소 “한 메시지 완성”으로 처리**하는

**상태 머신(state machine)** 으로 설계해야 한다.

### 1.3 CAP(최대 프레임 크기)와 공격 방어

프레이밍에 길이 필드가 들어가는 순간, 입력이 다음처럼 될 수 있다.

- 길이: `0xFFFFFFFF` (약 4GiB)
- 실제 페이로드: 매우 적은 양 또는 악의적 데이터

만약 애플리케이션이 길이 필드를 **그대로 신뢰하고** `std::vector<std::byte>` 를 4GiB 할당하려고 하면:

- 메모리 고갈,
- 성능 저하,
- 전체 프로세스 장애

로 이어질 수 있다.

따라서 프레이밍 설계의 필수 요소는:

- **프레임 당 최대 길이(cap)**: 예를 들어 `16 MiB`, `64 KiB` 등.
- cap을 넘는 입력은 **즉시 오류 처리 + 연결 종료**.

이 글 전체에서 “CAP / Chunking / 상태 머신 / 무결성”은 항상 세트로 다룬다.

---

## 2. TCP 바이트 스트림 모델과 I/O 현실

### 2.1 송신 측 관점: `send`의 의미

송신 측의 `send`는

- 커널 소켓 버퍼에 **최대한 밀어 넣으려는 시도**일 뿐,
- “이 호출이 메시지를 하나 보냈다”는 의미는 아니다.

한 번의 호출로:

- 모든 바이트를 성공적으로 보낼 수도 있고,
- 일부만 보내고 돌아올 수도 있고,
- 블로킹 모드에서 네트워크/버퍼 상태 때문에 **대기 후** 일부/전체를 보낼 수도 있다.

그래서 “**메시지 N개를 보냈다**”는 추상화는 애플리케이션에서 따로 만들어야 한다.

### 2.2 수신 측 관점: `recv`의 의미

수신 측의 `recv`는

- “현재 커널이 받은 데이터 중, 최대 N바이트를 유저 버퍼로 복사”할 뿐이다.
- 메시지 경계를 인식하지 않는다.
- 애플리케이션이 어떤 방식으로든 “여기까지가 한 메시지”라는 규약을 만들어야 한다.

즉, **프레이밍**은 TCP 위에서 구현하는 **애플리케이션 계층 프로토콜**의 한 부분이다.

---

## 3. 프레이밍 3대 방식 개관

먼저 전체 숲을 보고, 이후 각 나무를 살핀다.

| 방식 | 핵심 아이디어 | 장점 | 단점 | 적합 사례 |
|---|---|---|---|---|
| 길이-프리픽스(4B, BE) | 앞에 고정 길이 헤더(메시지 길이)를 붙인다 | 파싱 단순, 고성능, 이진 안전 | 헤더 손상 시 동기화 복구 필요 | 대부분의 **이진 프로토콜** |
| 구분자 기반(Delimiter) | 메시지 끝에 구분자(`\n`, `\r\n`, `\0` 등) 삽입 | 사람이 읽기 쉬움, 개발 편리 | 바이너리 포함 시 이스케이프 필요, 스캔 비용 | **텍스트 프로토콜**(라인 기반) |
| TLV 헤더 | (Type, Length, Value)의 연속 | 옵션/버전에 유연, 확장성 ↑ | 구현 복잡, 헤더 검증 필수 | **확장 가능한 이진 프로토콜**(RPC, 메타데이터 풍부한 프로토콜) |

이제 각 방식에 대해:

1. 포맷 정의(수식/도식),
2. C++23 기준 송수신 예제,
3. 장단점/주의점,
4. 설계 시 정책(CAP/Chunking/무결성)

을 순서대로 보겠다.

---

## 4. 길이-프리픽스(4바이트, 빅엔디안)

### 4.1 포맷 정의

기본적인 길이-프리픽스 포맷은 다음과 같다.

- 헤더: 4바이트(32비트) 길이, 네트워크 바이트 오더(빅엔디안)
- 페이로드: 길이만큼의 **임의 바이트**
- 최대 길이(CAP): 설계 시 반드시 정해 둔다(예: `16 MiB`).

수식으로 표현하면:

$$
\text{Frame} = \text{len}_{(4\ \text{bytes, BE})} \ \Vert\ \text{payload}[\text{len}]
$$

여기서:

- \(\text{len}\) 은 0 이상 CAP 이하의 정수,
- `||` (Vert)는 “바이트 연결(concatenation)”을 뜻한다.

예:

- 길이 = 44 (`0x0000002C`)
- 페이로드 = `"The quick brown fox jumps over the lazy dog."` (44 bytes)

프레임은 다음과 같다.

```text
00 00 00 2C  54 68 65 20 71 75 69 63 6B 20 62 72 6F 77 ...
```

### 4.2 C++23 송수신 예제 (안전 루틴 포함)

아래는 길이-프리픽스 프레이밍을 위한 **송신/수신 유틸리티**를 C++23 스타일로 정리한 것이다.

```cpp
// framing_lenprefix.hpp
#pragma once
#include <vector>
#include <span>
#include <expected>
#include <system_error>
#include <cstddef>
#include <cstring>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cerrno>

// errno -> std::error_code
inline std::error_code last_errno() {
    return {errno, std::generic_category()};
}

// 부분 송신 처리: buf 전체를 보내려고 시도
inline std::expected<std::size_t, std::error_code>
send_all(int fd, std::span<const std::byte> buf) {
    std::size_t sent = 0;
    while (sent < buf.size()) {
        ssize_t n = ::send(fd,
                           buf.data() + sent,
                           buf.size() - sent,
                           0);
        if (n > 0) {
            sent += static_cast<std::size_t>(n);
            continue;
        }
        if (n == 0) {
            // TCP에서는 거의 없지만, 끊긴 상황으로 간주 가능
            break;
        }
        if (errno == EINTR) {
            continue;
        }
        return std::unexpected(last_errno());
    }
    return sent;
}

// 정확히 buf.size()만큼 수신 (끊기거나 오류 시 error)
inline std::expected<std::size_t, std::error_code>
recv_exact(int fd, std::span<std::byte> buf) {
    std::size_t got = 0;
    while (got < buf.size()) {
        ssize_t n = ::recv(fd,
                           buf.data() + got,
                           buf.size() - got,
                           0);
        if (n > 0) {
            got += static_cast<std::size_t>(n);
            continue;
        }
        if (n == 0) {
            // 원격 종료
            return std::unexpected(
                std::make_error_code(std::errc::connection_reset));
        }
        if (errno == EINTR) {
            continue;
        }
        return std::unexpected(last_errno());
    }
    return got;
}

// 길이-프리픽스 프레임 송신
inline std::expected<void, std::error_code>
send_frame_lp(int fd, std::span<const std::byte> payload) {
    if (payload.size() > std::numeric_limits<std::uint32_t>::max()) {
        return std::unexpected(
            std::make_error_code(std::errc::message_size));
    }

    std::uint32_t len = static_cast<std::uint32_t>(payload.size());
    std::uint32_t be  = ::htonl(len);

    // 헤더 송신
    auto h = send_all(fd, std::as_bytes(std::span{&be, 1}));
    if (!h) {
        return std::unexpected(h.error());
    }

    // 페이로드 송신
    auto b = send_all(fd, payload);
    if (!b) {
        return std::unexpected(b.error());
    }

    return {};
}

// 길이-프리픽스 프레임 수신
inline std::expected<std::vector<std::byte>, std::error_code>
recv_frame_lp(int fd, std::size_t cap = (1u << 20)) { // 기본 CAP: 1MiB
    std::uint32_t be{};
    auto h = recv_exact(fd,
                        std::as_writable_bytes(
                            std::span{&be, static_cast<std::size_t>(1)}));
    if (!h) {
        return std::unexpected(h.error());
    }

    std::uint32_t len = ::ntohl(be);
    if (len > cap) {
        return std::unexpected(
            std::make_error_code(std::errc::message_size));
    }

    std::vector<std::byte> buf(len);
    if (len == 0) {
        return buf; // 빈 메시지
    }

    auto b = recv_exact(fd,
                        std::span<std::byte>(buf.data(), buf.size()));
    if (!b) {
        return std::unexpected(b.error());
    }

    return buf;
}
```

여기서 중요한 포인트는:

- **CAP**: `cap` 기본값이 있으며, 이를 넘는 길이는 즉시 `message_size` 오류.
- **부분 입출력**: `send_all`, `recv_exact` 가 반복 호출 기반으로 구현되어 있음.
- **`std::expected`**: 성공 시 프레임(벡터), 실패 시 `std::error_code` 를 반환.

### 4.3 길이-프리픽스의 장점/단점 심층

**장점**

- **파싱 단순성**: 수신 측은 항상

  1. 4바이트 길이 읽기,
  2. 해당 길이만큼 페이로드 읽기

  두 단계를 반복하면 된다.

- **바이너리 안전**: 페이로드에 임의의 바이트(0x00, 0xFF, `\n`, `\r`)가 들어가도 문제 없다.
- **버퍼 관리 용이**: 길이를 먼저 알 수 있으므로, 필요한 만큼 버퍼를 한 번에 준비할 수 있다.

**단점**

- **헤더 손상 시 동기화 문제**:
  - 어떤 이유로든 길이 필드가 손상되면, 이후의 파서는 잘못된 길이를 기준으로 움직이게 된다.
  - 이를 방치하면 스트림 전체를 망가뜨릴 수 있다.
- **큰 길이 공격**:
  - 길이가 비현실적으로 크면, 수신 측이 비효율적/위험한 행동(큰 벡터 할당)을 하게 될 수 있다.
  - CAP + Chunking으로 방어해야 한다.

### 4.4 재동기화 전략 (헤더 손상 대비)

헤더가 손상될 가능성을 고려하면, **재동기화 전략**을 만들어야 한다.

대표적인 전략:

1. **마법값(Magic) + 버전 필드 추가**  
   프레임 앞에 2~4바이트의 고정 시그니처를 넣는다.

   $$ 
   \text{Frame} = \text{Magic}_{(2B)} \Vert \text{Ver}_{(1B)} \Vert \text{len}_{(4B)} \Vert \text{payload}
   $$

   - Magic 예: `"MG"` → `0x4D 0x47`
   - 손상 시, Magic 바이트 패턴을 **스트림 내에서 검색**해 재동기화 시도.

2. **헤더 CRC 추가**  
   - 헤더(또는 헤더+일부 페이로드)에 대해 **CRC16/CRC32**를 붙여, 손상 여부를 빠르게 판단.
   - CRC가 맞지 않으면 해당 프레임을 폐기하거나, Magic 패턴을 다시 찾는다.

실전에서는 “**손상된 스트림은 가급적 전체 연결을 닫는 방향**”이 유지보수에 유리하다.  
프로토콜 신뢰성이 매우 중요할 경우, 재동기화는 신중하게 설계해야 한다.

---

## 5. 구분자 기반(Delimiter) 프레이밍

### 5.1 포맷 정의

구분자 기반 프레이밍은 다음과 같은 매우 직관적인 아이디어에서 출발한다.

- 메시지 끝에 **특정 바이트 시퀀스**를 붙인다.
  - 예: `\n`, `\r\n`, `\0`, `"END\r\n"` 등
- 수신 측은 “구분자가 발견될 때까지 읽고 누적 → 구분자 이전까지를 한 메시지로 본다.”

수식:

$$
\text{Frame} = \text{bytes until delimiter} \ \Vert\ \text{DELIM}
$$

대표적인 예:

- SMTP/POP/IMAP: 라인 기반 + CRLF
- 많은 텍스트 프로토콜이 **라인 단위**를 기본 단위로 삼는다.

### 5.2 스캔 버퍼 + 상태 머신

구분자 기반의 핵심은 다음 구조이다.

1. 내부에 `std::vector<char>` 또는 `std::string` 버퍼를 하나 유지.
2. `recv`로 읽은 바이트를 이 버퍼에 누적.
3. 버퍼 전체에서 구분자(`\n` 등)를 **검색**.
4. 구분자가 발견되면, 그 앞까지를 떼서 “완성된 프레임”으로 반환.

이 과정을 구현한 예:

```cpp
// framing_delim.hpp
#pragma once
#include <vector>
#include <string>
#include <span>
#include <expected>
#include <system_error>
#include <algorithm>
#include <array>
#include <sys/socket.h>
#include <cerrno>

// 일부 수신 (최대 buf.size())
inline std::expected<std::size_t, std::error_code>
recv_some(int fd, std::span<char> buf) {
    ssize_t n = ::recv(fd, buf.data(), buf.size(), 0);
    if (n > 0)
        return static_cast<std::size_t>(n);
    if (n == 0)
        return std::unexpected(
            std::make_error_code(std::errc::connection_reset));
    if (errno == EINTR)
        return recv_some(fd, buf); // 재시도
    return std::unexpected(
        std::error_code(errno, std::generic_category()));
}

// 개행 기반 라인 리더
struct DelimReader {
    std::vector<char> buf;
    char delim = '\n';
    std::size_t cap = 1 << 20; // 1MiB

    std::expected<std::string, std::error_code>
    next_line(int fd) {
        for (;;) {
            // 1) 구분자 검색
            auto it = std::find(buf.begin(), buf.end(), delim);
            if (it != buf.end()) {
                std::string line(buf.begin(), it);
                buf.erase(buf.begin(), it + 1); // delim까지 제거
                return line;
            }

            // 2) cap 방어
            if (buf.size() >= cap) {
                return std::unexpected(
                    std::make_error_code(std::errc::message_size));
            }

            // 3) 더 받기
            std::array<char, 4096> tmp{};
            auto r = recv_some(fd, std::span<char>(tmp.data(), tmp.size()));
            if (!r) {
                return std::unexpected(r.error());
            }

            buf.insert(buf.end(), tmp.data(), tmp.data() + *r);
        }
    }
};
```

- `next_line` 은 구분자를 찾을 때까지 계속 `recv`를 호출한다.
- CAP를 넘어가는 순간 `message_size` 오류로 연결을 끊을 수 있다.

### 5.3 구분자 방식의 장점/단점 심층

**장점**

- 구현이 직관적이고, **텍스트 프로토콜**에 잘 맞는다.
- 사람이 직접 패킷/로그를 볼 때 **가독성**이 좋다.
- `telnet`이나 간단한 테스트 클라이언트로 직접 프로토콜을 실험하기 쉽다.

**단점**

- **바이너리 안전 X**:
  - 구분자 바이트(예: `\n`)가 페이로드 내부에 등장하면, 이를 구분자로 오해할 수 있다.
  - 이를 해결하려면 **이스케이프 규칙**(예: `\n` → `\\n`)을 정의해야 한다.
- **스캔 비용**:
  - 긴 라인/큰 입력에서 매번 `std::find` 로 전체를 훑으면 시간 비용이 커진다.
  - 필요하면 더 효율적인 **패턴 검색 알고리즘**(KMP, Boyer-Moore, Rabin-Karp 등)을 사용할 수 있다.
- **멀티라인 규약**:
  - HTTP/1.x 헤더처럼, “빈 줄이 헤더의 끝”이라는 규칙이 있다.
  - 이런 경우, 단순히 한 줄 = 한 메시지가 아니라,
    - 여러 줄을 읽어서 합쳐야 하고,
    - 중간에 “헤더 길이 상한” 정책도 필요하다.

### 5.4 바이너리 안전을 위한 변형: 길이 + 구분자

구분자 기반과 길이-프리픽스를 **혼합**하는 방식도 있다.

- 헤더에 메시지 길이를 넣고,
- 끝에는 구분자를 추가한다.

이렇게 하면:

- 길이로 페이로드를 읽고,
- 구분자로 **재동기화 힌트**를 얻을 수 있다.

또는 텍스트 부분에만 구분자, 바이너리 데이터는 **Base64**나 **hex 인코딩**으로 처리하는 방법도 있다.

---

## 6. TLV(Type-Length-Value) 기반 헤더

### 6.1 포맷 정의

TLV는 말 그대로,

- **Type**: 메시지/필드의 종류
- **Length**: 값의 길이
- **Value**: 실제 바이트 데이터

를 의미한다. 예를 들어:

- Type(1B)
- Length(3B, BE) — 최대 \(2^{24}-1 = 16{,}777{,}215\) 바이트
- Value(NB)

수식:

$$
\text{TLV} = \text{Type}_{(1B)} \ \Vert\ \text{Len}_{(24\text{bits, BE})} \ \Vert\ \text{Value}[\text{Len}]
$$

그리고 여러 TLV가 스트림 상에 연속해서 나타난다.

### 6.2 C++23 구현 예: TLV 구조체 + 송수신

```cpp
// framing_tlv.hpp
#pragma once
#include <vector>
#include <span>
#include <expected>
#include <cstdint>
#include <system_error>
#include <cstring>
#include <limits>
#include <sys/socket.h>

// send_all / recv_exact / last_errno는 앞에서 정의한 것과 동일

inline std::uint32_t be24_to_u32(const unsigned char b[3]) {
    return (std::uint32_t(b[0]) << 16) |
           (std::uint32_t(b[1]) << 8)  |
           std::uint32_t(b[2]);
}

inline void u32_to_be24(std::uint32_t n, unsigned char b[3]) {
    b[0] = static_cast<unsigned char>((n >> 16) & 0xFF);
    b[1] = static_cast<unsigned char>((n >> 8) & 0xFF);
    b[2] = static_cast<unsigned char>(n & 0xFF);
}

struct TLV {
    std::uint8_t type{};
    std::vector<std::byte> value;
};

inline std::expected<void, std::_error_code>
send_tlv(int fd, std::uint8_t type, std::span<const std::byte> value) {
    unsigned char hdr[4];
    hdr[0] = type;

    if (value.size() > 0xFFFFFFu) {
        return std::unexpected(
            std::make_error_code(std::errc::message_size));
    }

    u32_to_be24(static_cast<std::uint32_t>(value.size()), &hdr[1]);

    // 헤더 + 값
    auto h = send_all(fd, std::as_bytes(std::span{hdr, sizeof(hdr)}));
    if (!h) {
        return std::unexpected(h.error());
    }

    auto b = send_all(fd, value);
    if (!b) {
        return std::unexpected(b.error());
    }

    return {};
}

inline std::expected<TLV, std::error_code>
recv_tlv(int fd, std::size_t cap = (1u << 20)) {
    unsigned char hdr[4];
    auto h = recv_exact(fd,
                        std::as_writable_bytes(
                            std::span{hdr, sizeof(hdr)}));
    if (!h) {
        return std::unexpected(h.error());
    }

    std::uint8_t type = hdr[0];
    std::uint32_t len = be24_to_u32(&hdr[1]);
    if (len > cap) {
        return std::unexpected(
            std::make_error_code(std::errc::message_size));
    }

    TLV t;
    t.type = type;
    t.value.resize(len);

    auto b = recv_exact(fd,
                        std::span<std::byte>(t.value.data(), t.value.size()));
    if (!b) {
        return std::unexpected(b.error());
    }

    return t;
}
```

### 6.3 TLV의 장점/단점

**장점**

- **확장성**:
  - 새로운 타입을 추가해도 기존 타입에 영향을 주지 않는다.
  - 선택적 필드(옵션) 추가에 매우 유리.
- **명확한 구조**:
  - Type별로 서로 다른 구조를 매핑할 수 있다.
  - 파서가 타입을 기반으로 다양한 행동을 수행 가능.

**단점**

- 길이-프리픽스보다 파서/테스트가 복잡하다.
- 헤더 검증이 부실하면, 길이 손상으로 전체 스트림 동기화가 깨질 수 있다.
- 타입 간의 관계(예: “이후에는 반드시 어떤 타입이 따라와야 한다”)를 **명세 수준에서 잘 정의**해야 한다.

---

## 7. 정책: CAP, Chunking, Windowing

### 7.1 왜 정책이 필요한가

프레이밍 자체만 정의하면 “멋진 프로토콜”이 된 것처럼 보이지만,  
실제 서비스에서는 다음 문제가 발생한다.

- 특정 클라이언트가 **매우 큰 메시지**를 보낼 수 있다.
- 동시에 수백/수천 개 연결이 있다.
- 각 연결이 큰 메시지를 하나씩 보낸다면, 전체 메모리가 금방 고갈된다.

이를 방지하기 위해서는 다음 세 가지 정책이 필요하다.

1. **CAP (Max Frame Size)**  
   - 단일 메시지/프레임/라인에 허용할 최대 크기.
2. **Chunk Size**  
   - 큰 메시지를 조각(chunks)으로 나누는 크기.
3. **Windowing (In-flight 제한)**  
   - 동시에 처리 중인 메시지/바이트 수에 대한 상한.

### 7.2 CAP 계산 직관

전체적으로 사용할 수 있는 메모리가 \(M\),  
동시 연결 수가 \(C\),  
각 연결에서 동시에 처리될 수 있는 프레임 수가 평균 \(k\)라고 하면,

$$
\text{cap} \le \frac{M}{C \times k \times \alpha}
$$

여기서 \(\alpha\)는 버퍼/메타데이터/복수 계층의 여유분을 고려한 계수 (보통 2~4)이다.

예를 들어,

- 전체 프로세스 메모리를 512 MiB로 제한,
- 동시 연결 수 \(C = 1000\),
- 연결당 동시에 처리되는 프레임 수 \(k = 1\),
- \(\alpha = 4\) 로 잡으면,

$$
\text{cap} \le \frac{512 \text{ MiB}}{1000 \times 4} \approx 128 \text{ KiB}
$$

실전에서는 용도에 따라 cap을 다르게 잡는다.

- 채팅/제어 메시지 → 수 KiB ~ 수십 KiB
- 파일 전송/대형 데이터 → Chunking + 스트리밍

### 7.3 Chunk Size 선택

Chunk Size는 다음 요소의 타협이다.

- 너무 작으면:
  - 헤더 오버헤드 ↑
  - `send`/`recv` 호출 횟수가 많아져 **syscall 비용**↑
- 너무 크면:
  - 개별 메시지 지연(latency)↑
  - 메모리 버퍼 압박

일반적인 시작점(경험치):

- **32 KiB ~ 128 KiB** 사이에서 시작해, 실제 측정 기반으로 조정.

### 7.4 Windowing

Chunking을 하더라도, 동시에 너무 많은 메시지를 인플라이트로 두면:

- 큐에 쌓이는 데이터가 너무 많아지고,
- 수신 측 버퍼/메모리가 다시 문제.

따라서:

- 연결당 최대 인플라이트 메시지 수,
- 연결당 인플라이트 바이트 총량,

을 제한하는 **Windowing 정책**을 두어야 한다.

---

## 8. Chunking을 이용한 대형 메시지 전송 프로토콜

### 8.1 프로토콜 구조 개요

예를 들어, 아주 큰 파일(수백 MB~수GB)을 TCP로 보내고 싶다고 하자.  
단일 프레임 크기를 cap으로 제한했기 때문에, 파일 전체를 한 프레임으로 보낼 수는 없다.

이때 다음과 같은 **Chunked 프로토콜**을 설계할 수 있다.

- `MSG_START`: 전체 파일(또는 메시지)에 대한 메타데이터
  - 파일 이름
  - 전체 길이
  - 해시 알고리즘(예: CRC32, SHA-256)
- `MSG_CHUNK`: 실제 데이터 청크
- `MSG_END`: 최종 해시 값(또는 기타 종료 메타데이터)

이를 TLV 형태로 구현:

- Type=0x10: FILE_START
- Type=0x11: FILE_CHUNK
- Type=0x12: FILE_END

### 8.2 C++23 송신자 스케치

```cpp
// file_chunked_send.hpp
#pragma once
#include "framing_tlv.hpp"
#include <cstdio>
#include <string>
#include <span>
#include <expected>
#include <system_error>

// CRC32, SHA-256 등은 별도 라이브러리/구현 가정

inline std::expected<void, std::error_code>
send_file_chunked(int fd, const std::string& filename) {
    std::FILE* f = std::fopen(filename.c_str(), "rb");
    if (!f) {
        return std::unexpected(
            std::make_error_code(std::errc::no_such_file_or_directory));
    }

    // 파일 크기 계산
    std::fseek(f, 0, SEEK_END);
    long sz = std::ftell(f);
    std::fseek(f, 0, SEEK_SET);
    if (sz < 0) {
        std::fclose(f);
        return std::unexpected(
            std::make_error_code(std::errc::io_error));
    }

    std::uint64_t total_len = static_cast<std::uint64_t>(sz);

    // 1) FILE_START 전송
    // 예: [8B total_len][파일명 N바이트][0x00 terminator]
    std::vector<std::byte> meta;
    meta.resize(8 + filename.size() + 1);
    std::uint64_t be_len = /* htobe64 구현 필요 */;
    std::memcpy(meta.data(), &be_len, 8);
    std::memcpy(meta.data() + 8, filename.data(), filename.size());
    meta[8 + filename.size()] = std::byte{0};

    auto r = send_tlv(fd, 0x10,
                      std::span<const std::byte>(meta.data(),
                                                 meta.size()));
    if (!r) {
        std::fclose(f);
        return std::unexpected(r.error());
    }

    // 2) FILE_CHUNK 반복 전송
    constexpr std::size_t CHUNK = 64 * 1024;
    std::vector<std::byte> buf(CHUNK);

    std::uint32_t crc = 0; // CRC 계산용, 실제 구현 필요

    while (true) {
        std::size_t n = std::fread(buf.data(), 1, buf.size(), f);
        if (n == 0) {
            if (std::ferror(f)) {
                std::fclose(f);
                return std::unexpected(
                    std::make_error_code(std::errc::io_error));
            }
            break; // EOF
        }

        // CRC 업데이트 (의사코드)
        // crc = crc32_update(crc, std::span(buf.data(), n));

        auto sr = send_tlv(fd, 0x11,
                           std::span<const std::byte>(buf.data(), n));
        if (!sr) {
            std::fclose(f);
            return std::unexpected(sr.error());
        }
    }

    std::fclose(f);

    // 3) FILE_END 전송 (CRC32)
    std::uint32_t be_crc = htonl(crc);
    auto er = send_tlv(fd, 0x12,
                       std::as_bytes(std::span{&be_crc, 1}));
    if (!er) {
        return std::unexpected(er.error());
    }

    return {};
}
```

### 8.3 서버(수신자) 스케치

```cpp
// file_chunked_recv.hpp
#pragma once
#include "framing_tlv.hpp"
#include <string>
#include <cstdio>
#include <expected>
#include <system_error>

inline std::expected<void, std::error_code>
recv_file_chunked(int fd, const std::string& dir) {
    std::string filename;
    std::uint64_t total_len = 0;
    std::uint64_t received  = 0;
    std::uint32_t crc       = 0;

    std::FILE* out = nullptr;

    for (;;) {
        auto tlv = recv_tlv(fd, 1 << 20);
        if (!tlv) {
            if (tlv.error() == std::errc::connection_reset) {
                // 중간에 끊긴 경우
            }
            return std::unexpected(tlv.error());
        }

        if (tlv->type == 0x10) {
            // FILE_START
            if (tlv->value.size() < 8) {
                return std::unexpected(
                    std::make_error_code(std::errc::protocol_error));
            }
            std::uint64_t be_len = 0;
            std::memcpy(&be_len, tlv->value.data(), 8);
            total_len = /* be64toh(be_len) 구현 필요 */;

            // 파일명 파싱
            const char* name = reinterpret_cast<const char*>(tlv->value.data() + 8);
            filename = name;

            std::string fullpath = dir + "/" + filename;
            out = std::fopen(fullpath.c_str(), "wb");
            if (!out) {
                return std::unexpected(
                    std::make_error_code(std::errc::io_error));
            }
        } else if (tlv->type == 0x11) {
            // FILE_CHUNK
            if (!out) {
                return std::unexpected(
                    std::make_error_code(std::errc::protocol_error));
            }
            if (std::fwrite(tlv->value.data(), 1, tlv->value.size(), out)
                != tlv->value.size()) {
                std::fclose(out);
                return std::unexpected(
                    std::make_error_code(std::errc::io_error));
            }
            received += tlv->value.size();
            // CRC 업데이트 (의사코드)
        } else if (tlv->type == 0x12) {
            // FILE_END
            if (!out) {
                return std::unexpected(
                    std::make_error_code(std::errc::protocol_error));
            }
            std::fclose(out);
            out = nullptr;

            // CRC 검증
            if (tlv->value.size() != 4) {
                return std::unexpected(
                    std::make_error_code(std::errc::protocol_error));
            }
            std::uint32_t be_crc = 0;
            std::memcpy(&be_crc, tlv->value.data(), 4);
            std::uint32_t remote_crc = ntohl(be_crc);

            if (received != total_len /* || remote_crc != crc */) {
                return std::unexpected(
                    std::make_error_code(std::errc::io_error));
            }
            // 성공적으로 파일 수신 완료
            return {};
        } else {
            // 알려지지 않은 타입: 정책에 따라 무시 또는 오류
        }
    }
}
```

이 정도의 구조만 되어도:

- 큰 파일을 **Chunking**으로 안전하게 전송,
- 총 길이/CRC 검사로 **무결성** 확보,
- 타입 필드로 **프로토콜 확장** 가능.

---

## 9. 파서 상태 머신 설계

### 9.1 길이-프리픽스 파서 상태 머신

길이-프리픽스 기반 파서는 기본적으로 두 상태를 가지면 된다.

1. `READ_LEN` (길이 헤더 읽는 중)
2. `READ_PAYLOAD` (페이로드 읽는 중)

각 상태에서 “얼마나 읽었는지”를 기억하면서, 입력 바이트 스트림을 차례로 처리한다.

```cpp
// parser_lenprefix.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <expected>
#include <system_error>
#include <cstring>
#include <arpa/inet.h>

struct LPParser {
    enum class State { READ_LEN, READ_PAYLOAD };

    State st = State::READ_LEN;

    std::uint32_t be_len{};
    std::uint32_t len{};
    std::vector<std::byte> payload;

    std::size_t cap = 1 << 20;

    // 내부 진행 상태
    std::size_t len_bytes_read   = 0;
    std::size_t payload_bytes_read = 0;

    // 입력 바이트를 공급하면, 완성된 프레임이 있으면 반환.
    // 없으면 operation_would_block 를 error로 준다.
    std::expected<std::vector<std::byte>, std::error_code>
    feed(std::span<const std::byte> in) {
        std::size_t off = 0;

        while (off < in.size()) {
            if (st == State::READ_LEN) {
                std::size_t need = 4 - len_bytes_read;
                std::size_t take =
                    std::min(need, in.size() - off);

                std::memcpy(
                    reinterpret_cast<char*>(&be_len) + len_bytes_read,
                    in.data() + off,
                    take
                );

                len_bytes_read += take;
                off            += take;

                if (len_bytes_read == 4) {
                    len = ::ntohl(be_len);
                    if (len > cap) {
                        return std::unexpected(
                            std::make_error_code(std::errc::message_size));
                    }
                    payload.clear();
                    payload.resize(len);
                    payload_bytes_read = 0;
                    len_bytes_read     = 0;
                    st = State::READ_PAYLOAD;
                }
            } else { // READ_PAYLOAD
                std::size_t need = len - payload_bytes_read;
                std::size_t take =
                    std::min(need, in.size() - off);

                std::memcpy(payload.data() + payload_bytes_read,
                            in.data() + off,
                            take);
                payload_bytes_read += take;
                off                += take;

                if (payload_bytes_read == len) {
                    st = State::READ_LEN;
                    return payload; // 완성
                }
            }
        }

        // 이 호출만으로는 완성된 프레임 없음
        return std::unexpected(
            std::make_error_code(std::errc::operation_would_block));
    }
};
```

- `feed` 함수는 **입력 조각**을 받아 상태를 진행시키고,
- 프레임 하나가 완성되면 **즉시 반환**,
- 아직 부족하면 `operation_would_block` 오류를 반환하도록 설계했다.

실전에서는 `feed`가 “한 번에 여러 개의 프레임”을 뱉을 수 있도록 설계하거나,  
`std::optional`을 조합해서 “완성된 프레임이 없을 때는 `nullopt`”를 반환하게 만들기도 한다.

### 9.2 라인 파서(구분자)의 상태 머신

라인 파서의 상태는 심플하다.

- 내부 버퍼 `buf`에 바이트들을 계속 추가
- 그 안에서 `delim`의 위치를 찾는다.
- 발견되면 delim 이전까지를 잘라서 반환.

아래는 “입력 조각마다 한 줄이 만들어질 수도, 안 만들어질 수도 있는” 형태:

```cpp
// parser_line.hpp
#pragma once
#include <vector>
#include <string>
#include <expected>
#include <system_error>
#include <algorithm>

struct LineParser {
    std::vector<char> buf;
    char delim = '\n';
    std::size_t cap = 64 * 1024;

    std::expected<std::string, std::error_code>
    feed(std::span<const char> in) {
        if (buf.size() + in.size() > cap) {
            return std::unexpected(
                std::make_error_code(std::errc::message_size));
        }

        buf.insert(buf.end(), in.begin(), in.end());

        auto it = std::find(buf.begin(), buf.end(), delim);
        if (it == buf.end()) {
            return std::unexpected(
                std::make_error_code(std::errc::operation_would_block));
        }

        std::string line(buf.begin(), it);
        buf.erase(buf.begin(), it + 1);
        return line;
    }
};
```

---

## 10. 실전 체크리스트 (프레이밍 설계 시)

### 10.1 프레이밍 방식 선택

- [ ] **바이너리 중심인가, 텍스트 중심인가?**
  - 바이너리 → 길이-프리픽스, TLV
  - 텍스트 → 구분자 기반
- [ ] **향후 확장성과 옵션이 중요한가?**
  - 중요하다 → TLV + 길이-프리픽스 혼합 고려
- [ ] **사람이 직접 읽어야 하는가?**
  - 로그/테스트 단계에서 텍스트 프로토콜이 편할 수 있다.

### 10.2 엔디안 및 숫자 표현

- [ ] 모든 다중 바이트 정수는 **네트워크 바이트 오더(빅엔디안)** 로 정의.
- [ ] `htonl`, `htons` 또는 C++23에서 `std::byteswap` + `std::endian` 조합으로 구현.
- [ ] 정수 범위/오버플로우를 명확히 처리.

### 10.3 CAP/Chunking/무결성

- [ ] 단일 프레임/라인/청크에 대한 **CAP** 정의.
- [ ] CAP 초과 입력은 **즉시 오류 + 연결 종료**.
- [ ] 대형 메시지는 **Chunking + 스트리밍**으로 처리.
- [ ] 필요 시 CRC32/SHA-256 등으로 **무결성 검증**.

### 10.4 상태 머신 및 오류 복구

- [ ] 부분 입출력을 가정한 **상태 머신** 설계.
- [ ] 헤더 손상/길이 손상에 대해 **재동기화 전략** 또는 **연결 종료** 정책 명시.
- [ ] 파서가 “예상치 못한 타입/필드”를 만났을 때의 행동 정의.

### 10.5 관측/디버깅

- [ ] hexdump 유틸과 일관된 로그 포맷으로 프레임 단위 기록.
- [ ] Wireshark/TCP 스트림 팔로우로 캡처 검증.
- [ ] `strace` 또는 OS 별 네트워크 추적 도구로 `send/recv` 호출 길이 확인.

---

## 11. 성능 관점에서의 프레이밍

### 11.1 syscalls, context switch, batch 처리

프레이밍 전략은 **syscall 횟수**에도 영향을 미친다.

- 작은 프레임을 많이 보내면:
  - `send` 호출 횟수 ↑
  - 컨텍스트 스위치 및 커널 오버헤드 ↑
- 가능한 경우, 여러 프레임을 한 번의 `writev`/`sendmsg`로 묶어 보내는 것도 고려할 수 있다.

수식적인 직관:

- 총 전송 바이트 수를 \(B\), 프레임당 평균 크기를 \(L\) 이라 하면,
  - 프레임 수는 \(N \approx B / L\).
  - syscalls 수 역시 대략 \(N\).
- syscalls당 오버헤드를 \(\tau\)라 할 때,
  - **syscall 오버헤드에 의한 시간**은 대략 \(\tau N\).

메시지가 너무 잘게 쪼개져 있으면 \(L\)이 작아져 \(N\)이 증가하고,  
반대로 너무 크게 묶으면 개별 메시지의 레이턴시와 메모리 사용량이 증가한다.  
따라서 프레이밍/Chunking 설계에서 **적절한 크기**를 찾는 것이 중요하다.

### 11.2 대역폭-지연곱(BDP)와 버퍼 크기

대역폭을 \(BW\), 왕복 지연 시간을 \(RTT\)라고 하면,  
대역폭-지연곱(BDP)은

$$
\text{BDP} = BW \times RTT
$$

이다.

- 예를 들어 \(BW = 100\,\mathrm{Mbit/s}\), \(RTT = 100\,\mathrm{ms} = 0.1\,\mathrm{s}\) 라면,
  $$ \text{BDP} = 100 \times 10^6 \times 0.1 = 10 \times 10^6 \,\mathrm{bit} \approx 1.25 \,\mathrm{MiB}. $$

즉, 이 링크를 완전히 채우려면 송신 측/수신 측의 버퍼/윈도우가 **적어도 BDP 만큼**은 되어야 한다.  
프레이밍/Chunking 크기는 이런 BDP와도 관련이 있다.

### 11.3 손실 환경에서의 처리량 근사

전통적인 TCP Reno 모델에서는 손실 확률 \(p\)에 대해 대략적인 처리량을

$$
\text{Throughput} \approx \frac{\text{MSS}}{\text{RTT}\sqrt{p}}
$$

로 근사하기도 한다.

- MSS(Maximum Segment Size)는 TCP 세그먼트의 데이터 부분 크기.
- 손실 확률이 증가하면 \(\sqrt{p}\)가 증가하여 처리량이 감소한다.

이런 관점에서, 너무 작은 메시지를 잦게 보내면

- 헤더 오버헤드와 ACK 빈도 증가,
- 작은 윈도우/Queueing으로 인한 효율 저하,

등이 복합적으로 작용할 수 있다.  
그래서 **프레이밍/Chunking을 적절한 크기로 배치**하는 것이 성능에도 영향을 준다.

---

## 12. 비교 예제: 세 가지 프레이밍으로 같은 메시지 전송

### 12.1 공통 메시지

문자열:

```text
"The quick brown fox jumps over the lazy dog."
```

길이는 44바이트라고 하자.

### 12.2 길이-프리픽스(4B, BE)

- 길이: 44 (0x0000002C)
- 프레임:

```text
00 00 00 2C  54 68 65 20 71 75 69 63 ...
```

### 12.3 구분자 기반(`\n`)

- 메시지: 44바이트 텍스트 + `\n`
- 프레임:

```text
54 68 65 20 71 75 69 63 ... 2E 0A   // '.' '\n'
```

수신 측은 버퍼를 누적하며 `0A`(LF)를 만날 때까지 읽는다.

### 12.4 TLV (Type=0x02, Len=44)

- 헤더:

```text
02 00 00 2C   // type=0x02, len=0x00002C
```

- 값:

```text
54 68 65 20 71 75 69 63 ... (44 bytes)
```

전체:

```text
02 00 00 2C  54 68 65 20 71 75 69 63 ...
```

---

## 13. 디버깅과 관측: hexdump, Wireshark, strace

### 13.1 hexdump 유틸

프레임 경계와 내용이 **정말로** 의도한 대로 전송되는지 확인하려면,  
소켓 코드 내부에서 hexdump를 찍어보는 것이 매우 유용하다.

```cpp
#include <print>
#include <span>
#include <cstddef>

inline void hexdump(std::span<const std::byte> s) {
    std::size_t i = 0;
    for (auto b : s) {
        if (i % 16 == 0) {
            std::print("{:08X}  ", static_cast<unsigned>(i));
        }
        auto v = static_cast<unsigned>(
            std::to_integer<unsigned char>(b));
        std::print("{:02X} ", v);
        if (++i % 16 == 0) {
            std::print("\n");
        }
    }
    if (i % 16 != 0) {
        std::print("\n");
    }
}
```

이 함수를 활용해:

- 송신 전/후로 프레임 내용 덤프,
- 수신한 프레임 덤프,

를 남기면 프로토콜 디버깅에 큰 도움이 된다.

### 13.2 Wireshark로 스트림 보기

네트워크 트래픽을 캡처한 후:

- 특정 TCP 스트림을 따라가면,
- 길이-프리픽스/구분자/TLV 구조가 **실제 바이트 수준에서 어떻게 보이는지** 확인할 수 있다.
- 특히 헤더/페이로드 경계를 눈으로 한번 확인해 보는 과정이 프레이밍 설계 검증에 유용하다.

### 13.3 `strace`로 `send/recv` 호출 길이 확인

UNIX 계열에서 `strace -e trace=network` 로 프로세스를 감싸면,

- 각 `send`, `recv` 호출의 길이,
- 어느 타이밍에 블로킹/오류가 발생하는지,

를 볼 수 있다.

이를 통해:

- 프레이밍 설계대로 `send_all`, `recv_exact`가 잘 동작하는지,
- 예상 외의 부분 입출력이 발생하고 있는지,

를 확인할 수 있다.

---

## 14. 미니 프로젝트 예시: 프레이밍 기반 채팅 서버/클라이언트

### 14.1 요구사항

- TCP 기반 채팅 서버.
- 클라이언트는 텍스트 메시지를 전송.
- 메시지는 **길이-프리픽스** + UTF-8 문자열.
- 서버는 받은 메시지를 모든 클라이언트에게 브로드캐스트.

### 14.2 메시지 포맷

- 길이: 4B (BE)
- 페이로드: UTF-8 텍스트 (최대 4KiB)
- CAP: 4096

### 14.3 클라이언트 송신 코드 (요지)

```cpp
std::expected<void, std::error_code>
send_chat_message(int fd, std::string_view msg) {
    if (msg.size() > 4096) {
        return std::unexpected(
            std::make_error_code(std::errc::message_size));
    }

    std::vector<std::byte> buf(msg.size());
    std::memcpy(buf.data(), msg.data(), msg.size());

    return send_frame_lp(fd, std::span<const std::byte>(buf.data(), buf.size()));
}
```

### 14.4 서버 수신 코드 (요지)

```cpp
void handle_client(int fd) {
    while (true) {
        auto frame = recv_frame_lp(fd, 4096);
        if (!frame) {
            // 에러/연결 종료 처리
            break;
        }

        std::string text(reinterpret_cast<const char*>(frame->data()),
                         frame->size());

        // 브로드캐스트 로직...
    }
}
```

이렇게 프레이밍이 정해져 있으면, 채팅 서버 로직 자체는 프레이밍 위에 **깔끔하게 올라가는 레이어**가 된다.

---

## 15. 마무리

이 글 전체에서 다룬 핵심을 다시 정리하면 다음과 같다.

1. **TCP는 바이트 스트림**이다.  
   메시지 경계는 **프레이밍**으로 애플리케이션이 스스로 정의해야 한다.

2. 대표적인 프레이밍 방식:
   - **길이-프리픽스(4B, BE)**: 이진 프로토콜의 기본형. 파싱 단순, 성능 좋음.
   - **구분자 기반(Delimiter)**: 라인/텍스트 프로토콜에 적합.
   - **TLV(Type-Length-Value)**: 타입/옵션/버전을 유연하게 다루는 확장 가능한 방식.

3. 어떤 방식을 택하든 반드시 함께 설계해야 할 요소:
   - **CAP**: 단일 메시지/라인/청크의 최대 크기.
   - **Chunking**: 대형 메시지를 조각으로 나눠 스트리밍/검증.
   - **상태 머신**: 부분 입출력을 전제로 한 수신 파서 구조.
   - **무결성**: 필요 시 CRC32/SHA-256 등으로 응용 계층 수준의 무결성 확보.

4. C++23에서는:
   - `std::expected<T, std::error_code>`로 **오류 흐름을 명시적**으로 표현하고,
   - `std::span<std::byte>` / `std::string_view`로 **바이트/문자열 경계를 명확히** 하며,
   - RAII(`unique_fd` 등)로 **FD/소켓 수명**을 안전하게 관리하고,
   - `std::print`로 **타입 안전한 로그**를 남길 수 있다.

5. 마지막으로, 프레이밍 설계는 **한 번 잘 해두면** 그 위의 모든 애플리케이션 로직(채팅, 파일 전송, RPC, 스트리밍 등)이  
   일관된 구조와 안전성을 얻게 된다. 반대로, 프레이밍을 대충 설계하면 문제는 항상 **가장 깊은 곳(네트워크 경계)**에서 터지게 된다.

이 글에서 다룬 코드와 설계 패턴을 기반으로, 실제 프로젝트에서 사용하는 프로토콜을 **구체적인 요구사항**에 맞춰 변형/확장하면 된다.  
우선은 이 세 가지 프레이밍 방식을 확실하게 이해하고, CAP/Chunking/상태 머신/무결성까지 세트로 떠올리는 것이 출발점이다.
