---
layout: post
title: 시스템보안 - 윈도우 내부 & 권한 상승
date: 2025-10-22 19:30:23 +0900
category: 시스템보안
---
# 윈도우 내부 & 권한 상승 — 아키텍처/점검/방어 중심 완전 정리

> 목적: **Windows 보안 모델(토큰/무결성/UAC)**의 동작을 정확히 이해하고, 실무에서 사고를 부르는 **전형적 로컬 권한 상승(Local Privilege Escalation, LPE) 취약 구성**을 **감사·탐지·차단** 관점으로 정리합니다.
> 주의: 아래 내용은 **방어/교육 목적**입니다. **악용을 재현하는 단계별 익스플로잇**은 제공하지 않으며, 실습 코드는 **점검/가시성 향상**에 초점을 둡니다. 모든 실습은 **본인 소유의 랩 VM**에서만 진행하세요.

---

## 보안 모델: SID / 토큰 / Integrity Level / UAC

### SID(보안 식별자)와 ACL

- **SID(Security Identifier)**: 사용자/그룹/로그온 세션을 식별하는 문자열(ID). 예:
  - `S-1-5-18`(LOCAL SYSTEM), `S-1-5-19`(LOCAL SERVICE), `S-1-5-20`(NETWORK SERVICE), `S-1-5-32-544`(Administrators)
- **ACL**: DACL(허용/거부) + SACL(감사). 객체(파일/서비스/레지스트리/파이프…)의 접근을 **ACE(Access Control Entry)** 목록으로 통제.
- **권한 상승의 본질**: 잘못된 DACL(쓰기 권한 노출)이나 신뢰 경계(서비스/스케줄러/경로 검색/COM 바인딩)의 **간접 쓰기**를 통해 **SYSTEM 컨텍스트로 코드가 실행되는 현상**.

### 액세스 토큰(Access Token)

- **구성**: 사용자 SID, 그룹 SID, 권한(Privileges; Se*), 로그인 세션(LUID), **무결성 수준(Integrity Level)**, 제한(SAFER/LPAC) 등.
- **유형**:
  - **Primary Token**(프로세스에 부착, 새 프로세스 생성 시 사용)
  - **Impersonation Token**(스레드에 부착, “가짜로” 다른 보안 컨텍스트로 행동)
- **토큰 필드의 의미**를 보면 “왜 접근이 되고/안 되는지”를 이해할 수 있음.

#### (예제) PowerShell로 현재 토큰 핵심 필드 보기

```powershell
# 현재 프로세스 토큰의 SID/그룹/권한/무결성 수준 요약

whoami /all
# 무결성 레이블만 간단히

Get-Item -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" `
  | Out-Null  # (UAC 레지스트리 접근 예열)
$sid = (Get-Acl $env:windir).AccessToString | Out-Null
# 실제 무결성 레벨은 아래처럼 WMI/Win32 API로 확인하는 게 정확

```

#### (예제) C#으로 무결성 수준(Integrity Level) 읽기

```csharp
// dotnet build 후 실행: 현재 프로세스의 무결성 레벨 표시 (Low/Medium/High/System)
using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
class ILvl {
  const int TokenIntegrityLevel = 25;
  [DllImport("advapi32.dll", SetLastError=true)]
  static extern bool OpenProcessToken(IntPtr h, int acc, out IntPtr tok);
  [DllImport("kernel32.dll")] static extern IntPtr GetCurrentProcess();
  [DllImport("advapi32.dll", SetLastError=true)]
  static extern bool GetTokenInformation(IntPtr tok, int cls, IntPtr buf, int len, out int ret);
  [DllImport("advapi32.dll", SetLastError=true)]
  static extern bool GetSidSubAuthorityCount(IntPtr pSid, out IntPtr cnt);
  [DllImport("advapi32.dll", SetLastError=true)]
  static extern IntPtr GetSidSubAuthority(IntPtr pSid, int n);
  static void Main(){
    if(!OpenProcessToken(GetCurrentProcess(), 0x0008 /*TOKEN_QUERY*/, out var tok))
      throw new Win32Exception();
    GetTokenInformation(tok, TokenIntegrityLevel, IntPtr.Zero, 0, out var len);
    IntPtr buf = Marshal.AllocHGlobal(len);
    if(!GetTokenInformation(tok, TokenIntegrityLevel, buf, len, out len))
      throw new Win32Exception();
    // TOKEN_MANDATORY_LABEL 구조: SID의 마지막 SubAuth가 IL 값
    IntPtr pSid = Marshal.ReadIntPtr(buf);              // pTml->Label.Sid
    GetSidSubAuthorityCount(pSid, out var pCnt);
    int cnt = Marshal.ReadByte(pCnt);
    int il = Marshal.ReadInt32(GetSidSubAuthority(pSid, cnt-1));
    string name = il switch {
      0x00001000 => "Low",
      0x00002000 => "Medium",
      0x00003000 => "High",
      0x00004000 => "System",
      _          => $"Unknown(0x{il:X})"
    };
    Console.WriteLine($"Integrity Level: {name}");
  }
}
```

### 무결성 수준(Integrity Level) & UIPI

- **Low / Medium / High / System** 레벨로, **쓰기 보호의 추가 축**.
  예: **Medium(일반 사용자)** → **High(관리자 상승 프로세스)**로 **UI 메시지/창 후킹 등**이 제한(UIPI).
- **업무 팁**: 브라우저/Office를 Low/Medium 격리, 민감 앱은 High/System에 두고 **상호 쓰기 제한**.

### UAC(User Account Control) & Split Token

- 관리자는 로그온 시 **표준/관리자** 두 개의 토큰(“Split”)을 얻고, 평상시에는 **표준 토큰**으로 동작.
- **권한 상승**이 필요한 작업에서 **승인**(보안 데스크톱) 후 High 무결성 토큰으로 실행.
- **방어 포인트**:
  - **관리자 없이도 돌아가게 설계**(표준 사용자 호환성)
  - 상승 필요 시 **서명/경로/정책**을 통해 **허용 목록만** 승격

---

## LSASS / 크리덴셜 하이재킹 (개념 & 방어)

> “크리덴셜 하이재킹”은 **비밀번호/해시/티켓** 등 인증 자료를 탈취해 세션을 가로채는 행위. 이 절은 **개념과 방어**만 다룹니다. 공격 도구/명령 예시는 제공하지 않습니다.

### LSASS(Local Security Authority Subsystem Service)

- **역할**: 인증/SSO/SSPI/키링(storage) 중심 서비스.
- 공격자는 **메모리 덤프/핸들 오남용/드라이버**를 통해 자격 증명에 접근하려 시도.
- **현대 윈도우 방어 스택**:
  - **LSA 보호모드(PPL; Protected Process Light)**: 비보호 프로세스의 LSASS 접근 차단
  - **Credential Guard**(가상화 기반, VSM): NTLM/커리버스 비밀 분리 저장
  - **WDAC/AppLocker/ASR**: 비신뢰 모듈/도구 로딩 차단
  - **EDR/ETW**: 의심스러운 핸들/메모리 접근 탐지

### 방어 체크(운영 옵션)

```powershell
# LSA 보호모드(Protected Process Light) 적용 여부 확인

Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" `
  -Name "RunAsPPL","RunAsPPLBoot" -ErrorAction SilentlyContinue

# Credential Guard 상태(Windows 10+)

systeminfo | findstr /i "Virtualization"
# 또는 Device Guard / Credential Guard 배포 정책 PowerShell 모듈 활용(기업 환경)

# LSASS 덤프/핸들 남용 탐지: 보안/응용 로그의 이벤트 구독 (EDR 권장)
# 예: Sysmon이 있다면 Rule에서 lsass.exe에 대한 PROCESS_ACCESS 모니터링

```

### 운영 수칙

- **RunAsPPL** 활성(서명된 드라이버/특권 없이 LSASS 메모리 접근 불가)
- **Credential Guard**(가능한 SKU/하드웨어에서) 활성
- **WDAC/AppLocker**로 **서명·경로 기반** 실행 통제
- **LSASS 원격 복구/백업 도구** 등 **합법적 접근**도 화이트리스트/서명 강제
- **메모리 덤프** 권한 제한 & 저장 경로/전송 **암호화**

> 핵심 메시지: **자격 증명은 메모리에 남는다** → **분리/격리/서명/감사**로 접근 자체를 어렵게 만들 것.

---

## 서비스 / 스케줄러 / 레지스트리 기반 LPE 패턴 (탐지·완화)

> 아래는 “**어디를 보면 위험 구성이 보이는가**”에 대한 **감사 스크립트 & 운영 가이드**입니다. **악용 절차**는 포함하지 않습니다.

### 서비스(Services) — 잘못된 권한/경로/구성

**위험 신호**
- **서비스 바이너리 경로**(ImagePath)가 **절대경로 미사용** 또는 **따옴표 없는 공백 포함(“Unquoted Service Path”)**
- 서비스 실행 계정이 **LocalSystem**인데, **해당 경로/폴더에 일반 사용자가 쓰기 가능**
- **서비스 객체 DACL**이 느슨(Everyone에 WRITE/START STOP…)
- 서비스가 외부 실행 시 **PATH 의존**(절대경로 미사용)

#### (감사) PowerShell: 서비스 경로/권한 한 번에 훑어보기

```powershell
$svc = Get-WmiObject Win32_Service
foreach($s in $svc){
  $img = $s.PathName
  $name = $s.Name
  # 따옴표 없는 경로 + 공백 → 경로 파싱 모호
  $unquoted = ($img -notmatch '^".*"$') -and ($img -match '\s')
  # 실행 파일/디렉터리 ACL(쓰기 가능 여부)
  $exe = ($img -replace '^"','' -replace '"$','').Split(' ')[0]
  if(Test-Path $exe){
    $dir = Split-Path $exe -Parent
    try {
      $wExe = (Get-Acl $exe).Access | Where-Object {
        ($_.FileSystemRights.ToString() -match 'Write|Modify|FullControl') -and
        ($_.IdentityReference -match 'Everyone|Users|Authenticated Users')
      }
      $wDir = (Get-Acl $dir).Access | Where-Object {
        ($_.FileSystemRights.ToString() -match 'Write|Modify|FullControl') -and
        ($_.IdentityReference -match 'Everyone|Users|Authenticated Users')
      }
      if($unquoted -or $wExe -or $wDir){
        [PSCustomObject]@{
          Service = $name
          UnquotedPath = $unquoted
          WritableExe  = [bool]$wExe
          WritableDir  = [bool]$wDir
          PathName     = $img
        } | Format-Table -AutoSize
      }
    } catch {}
  }
}
```

**완화**
- **항상 따옴표**로 감싼 **절대 경로** 사용: `"C:\Program Files\Vendor\App\app.exe"`
- 서비스 실행 파일/디렉터리 **소유자/권한을 SYSTEM/Administrators에 제한**(일반 사용자 쓰기 금지)
- 서비스 객체 DACL 검토(권한: START/STOP/CONFIG WRITE 최소화)
- 서비스 재시작 트리거는 **관리 채널**로만(이벤트/타이머 악용 방지)

---

### 스케줄러(작업 스케줄러)

**위험 신호**
- **SYSTEM** 혹은 관리자 계정으로 **높은 권한** 실행되는데, **작업 Action의 실행 파일/스크립트 경로에 사용자 쓰기 가능**
- **경로가 상대/환경 변수 의존** & PATH 오염 가능
- 스케줄 등록 파일(`%SystemRoot%\System32\Tasks\*`)의 DACL이 느슨

#### (감사) PowerShell: SYSTEM 작업 + 쓰기 가능 경로 탐지

```powershell
$tasks = Get-ScheduledTask | ForEach-Object { $_, (Get-ScheduledTaskInfo $_) }
Get-ScheduledTask | ForEach-Object {
  $d = $_.Principal.UserId
  $sys = $d -match 'SYSTEM'
  $_.Actions | ForEach-Object {
    if($_.Execute){
      $exe = $_.Execute
      if(Test-Path $exe){
        $dir = Split-Path $exe -Parent
        try {
          $wDir = (Get-Acl $dir).Access | Where-Object {
            ($_.FileSystemRights.ToString() -match 'Write|Modify|FullControl') -and
            ($_.IdentityReference -match 'Everyone|Users|Authenticated Users')
          }
          if($sys -and $wDir){
            [PSCustomObject]@{
              Task = $_.PSParentPath
              RunAsSystem = $true
              WritableDir = $true
              ExecPath = $exe
            } | Format-Table -AutoSize
          }
        } catch {}
      }
    }
  }
}
```

**완화**
- SYSTEM/관리자 작업의 실행 파일·스크립트는 **보호 디렉터리(관리자만 쓰기 가능)** 에 위치
- 작업 정의 XML(등록 파일)의 ACL을 **Administrators/System 전용**으로 강화
- 변수/상대 경로 대신 **절대 경로** 사용

---

### 레지스트리 — AlwaysInstallElevated / 서비스 ImagePath / Run 키

**위험 신호**
- `AlwaysInstallElevated`가 잘못 활성화(사용자 MSI가 관리자 권한으로 설치)
- 서비스 키(HKLM\SYSTEM\CurrentControlSet\Services\<Name>)의 **ImagePath**에 대해 **일반 사용자 쓰기 가능**
- 자동 실행( Run / RunOnce / StartupApproved ) 경로가 쓰기 가능

#### (감사) PowerShell: 대표 키 빠르게 확인

```powershell
# AlwaysInstallElevated: 사용자/컴퓨터 둘 다 1이면 위험

$keys = @(
  "HKCU:\Software\Policies\Microsoft\Windows\Installer",
  "HKLM:\Software\Policies\Microsoft\Windows\Installer"
)
foreach($k in $keys){
  try {
    $v = Get-ItemProperty -Path $k -Name "AlwaysInstallElevated" -ErrorAction SilentlyContinue
    if($v.AlwaysInstallElevated -eq 1){
      Write-Host "[!] AlwaysInstallElevated=1 at $k"
    }
  } catch {}
}

# 서비스 ImagePath의 키/값 권한 점검(간단)

$svcs = "HKLM:\SYSTEM\CurrentControlSet\Services"
Get-ChildItem $svcs | ForEach-Object {
  $p = Join-Path $_.PsPath "ImagePath"
  try {
    $acl = Get-Acl $_.PsPath
    $weak = $acl.Access | Where-Object {
      ($_.IdentityReference -match 'Users|Everyone|Authenticated Users') -and
      ($_.RegistryRights.ToString() -match 'SetValue|FullControl|WriteKey')
    }
    if($weak){
      Write-Host "[!] Weak ACL: $($_.PsChildName)"
    }
  } catch {}
}
```

**완화**
- `AlwaysInstallElevated` **비활성**(HKLM/HKCU 모두 0 또는 미설정)
- 서비스 키/Run 키의 **DACL 강화**(일반 사용자 쓰기 금지)
- GPO/보안 기준서에 **레지스트리 취약 정책 금지 조항** 명문화

---

## COM / WMI / DLL Search Order 하이재킹 — 설계 이해 & 방어 코드

> 이 절에서는 **개념/점검/안전한 코딩**을 다룹니다. COM/WMI/DLL 로딩 순서를 악용하는 **구체적 절차**는 제공하지 않습니다.

### COM (Component Object Model)

- **개념**: CLSID/ProgID로 등록된 COM 서버(DLL/EXE)를 CoCreateInstance로 활성화.
- **위험 신호**:
  - COM 서버 DLL **검색 경로에 사용자 쓰기 가능한 디렉터리 포함**
  - **Auto-elevate** 클래스가 존재하고, 로딩 경로가 **서명/정책으로 제한되지 않음**
- **점검**
  - CLSID/InprocServer32/LocalServer32의 **경로가 보호 디렉터리**인지
  - **AppLocker/WDAC**로 COM 서버 **서명 강제**
- **완화**
  - 배포 시 **서명된 DLL/EXE**만 허용
  - COM 서버 경로는 **Program Files** 등 보호 위치로 고정, DACL 강화

### WMI (Windows Management Instrumentation)

- **개념**: CIM 저장소(네임스페이스/클래스/인스턴스) + 공급자(Provider).
- **위험 신호**:
  - **영구 구독(Permanent Event Subscription)**를 통한 **은닉 실행**(악성 유지)
- **점검(읽기 전용)**
```powershell
# 영구 구독 나열(관리자 권장)

Get-WmiObject -Namespace root\subscription -Class __EventFilter
Get-WmiObject -Namespace root\subscription -Class __EventConsumer
Get-WmiObject -Namespace root\subscription -Class __FilterToConsumerBinding
```
- **완화**
  - 변경은 **감사/SACL** 켜고, 불필요 구독 **정기 점검**
  - AppLocker/WDAC로 **스크립트/해석기** 실행 제한

### DLL Search Order (DLL 검색 순서) & 하이재킹 방지

- **기본 순서(요약)**: 애플리케이션 디렉터리 → 시스템 디렉터리 → 시스템32 → 현재 디렉터리 → PATH… (정책/플래그에 따라 다름)
- **위험 신호**: 실행 프로세스가 **자체 디렉터리** 또는 **현재 디렉터리**에서 DLL을 우선 로드하고, 그 위치가 **사용자 쓰기 가능**.
- **방어 코딩 패턴**
  1) **Safe DLL Search Mode** + **KnownDLLs 우선**
  2) `SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS)`
  3) `LoadLibraryEx` 사용 시 **검색 플래그 명시**, 경로는 **절대경로**

#### (예제) C/C++: 안전한 DLL 로딩

```c
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdio.h>

// 빌드: cl /O2 /W4 safe_load.c
int main(){
  // 1) 기본 검색 디렉터리 제한
  if(!SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS)){
    printf("SetDefaultDllDirectories failed: %lu\n", GetLastError());
  }
  // 2) 시스템32에서만 로드
  HMODULE h = LoadLibraryExA("version.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
  if(!h){ printf("LoadLibraryEx failed: %lu\n", GetLastError()); return 1; }
  FARPROC p = GetProcAddress(h, "GetFileVersionInfoSizeW");
  printf("GetProcAddress = %p\n", p);
  FreeLibrary(h);
  return 0;
}
```

**운영 권고**
- 레거시 코드에는 `SetDefaultDllDirectories`를 **프로세스 초기화 시점**에 강제
- **매니페스트**에서 `unsafeLoadLibrary` 방지, **서명 검증/WDAC**로 비서명 DLL 차단
- 앱 디렉터리/업데이트 경로는 **관리자만 쓰기**(일반 사용자 쓰기 금지)

---

## 5.x 통합: 로컬 LPE **사전 차단** 자동 점검 스크립트(안전)

> 아래 스크립트는 **악용이 아닌, 취약 구성 “징후” 탐지** 목적입니다. 결과는 사람 리뷰/화이트리스트 반영이 필요합니다.

```powershell
# win_lpe_safe_audit.ps1 — 로컬 점검(읽기 전용)
# 서비스/작업의 실행 경로 쓰기 가능 여부 2) Unquoted Path 3) 레지스트리 위험 정책

$rep = New-Object System.Collections.ArrayList

function Add-Row($Cat,$Name,$Detail){
  $null = $rep.Add([PSCustomObject]@{ Category=$Cat; Name=$Name; Detail=$Detail })
}

# Services

Get-WmiObject Win32_Service | ForEach-Object {
  $img = $_.PathName; $name = $_.Name
  $unquoted = ($img -notmatch '^".*"$') -and ($img -match '\s')
  $exe = ($img -replace '^"','' -replace '"$','').Split(' ')[0]
  if(Test-Path $exe){
    $dir = Split-Path $exe -Parent
    try {
      $wExe = (Get-Acl $exe).Access | Where-Object {
        ($_.FileSystemRights.ToString() -match 'Write|Modify|FullControl') -and
        ($_.IdentityReference -match 'Everyone|Users|Authenticated Users')
      }
      $wDir = (Get-Acl $dir).Access | Where-Object {
        ($_.FileSystemRights.ToString() -match 'Write|Modify|FullControl') -and
        ($_.IdentityReference -match 'Everyone|Users|Authenticated Users')
      }
      if($unquoted){ Add-Row "Service-Unquoted" $name $img }
      if($wExe){ Add-Row "Service-WritableExe" $name $exe }
      if($wDir){ Add-Row "Service-WritableDir" $name $dir }
    } catch {}
  }
}

# Scheduled Tasks

Get-ScheduledTask | ForEach-Object {
  $runAsSystem = $_.Principal.UserId -match 'SYSTEM'
  $_.Actions | ForEach-Object {
    if($_.Execute -and (Test-Path $_.Execute)){
      $d = Split-Path $_.Execute -Parent
      try{
        $wDir = (Get-Acl $d).Access | Where-Object {
          ($_.FileSystemRights.ToString() -match 'Write|Modify|FullControl') -and
          ($_.IdentityReference -match 'Everyone|Users|Authenticated Users')
        }
        if($runAsSystem -and $wDir){ Add-Row "Task-System-WritableDir" $_.Id $d }
      }catch{}
    }
  }
}

# Registry: AlwaysInstallElevated

$keys = @(
 "HKCU:\Software\Policies\Microsoft\Windows\Installer",
 "HKLM:\Software\Policies\Microsoft\Windows\Installer"
)
foreach($k in $keys){
  try{
    $v = Get-ItemProperty -Path $k -Name "AlwaysInstallElevated" -ErrorAction SilentlyContinue
    if($v.AlwaysInstallElevated -eq 1){ Add-Row "Registry-Policy" "AlwaysInstallElevated" $k }
  }catch{}
}

# LSA Protection / Credential Guard 힌트(간단 표기)

try{
  $ppl = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" `
         -Name "RunAsPPL","RunAsPPLBoot" -ErrorAction SilentlyContinue
  $ppl.PSObject.Properties | ForEach-Object {
    Add-Row "LSA" $_.Name (($_.Value -eq 1) ? "Enabled" : "DisabledOrMissing")
  }
}catch{}

$rep | Sort-Object Category,Name | Format-Table -AutoSize
```

**해석/조치 가이드**
- `Service-*`/`Task-*` 발견 시: **절대 경로+따옴표**로 수정, 경로/파일 **쓰기 권한 제거**, 실행 계정/객체 DACL 정비
- `Registry-Policy: AlwaysInstallElevated`: **즉시 비활성** 및 정책 배포
- `LSA`: 가능한 환경에서 **RunAsPPL/CG 활성** 방향으로

---

## 5.y 운영 체크리스트(요약)

- **UAC**: AlwaysNotify(강), Split Token 기본, 승인 로그 감사
- **무결성/UIPI**: 낮은 무결성 프로세스가 높은 무결성 프로세스에 **쓰지 못하도록** 설계
- **LSASS/자격**: RunAsPPL + Credential Guard + WDAC/AppLocker + 최소 관리자 세션
- **서비스/작업/레지스트리**:
  - 실행 경로는 **절대경로+따옴표**, 경로/파일/키 **쓰기 권한 최소화**
  - Scheduled Task(특히 SYSTEM)의 **Action 경로** 점검
  - 위험 정책(AlwaysInstallElevated 등) **금지**
- **DLL 로딩**: `SetDefaultDllDirectories`/`LoadLibraryEx` 검색 경로 제한 + **서명 요구**
- **관찰성**: Sysmon/EDR로 **lsass 접근, 서비스 변경, 작업/레지스트리 변경** 추적
- **배포 파이프라인**: 설치 프로그램이 **권한/ACL/서비스/작업/레지스트리**를 표준대로 설정하는지 **CI에서 테스트**

---

# 부록 A. 이벤트 & 로그 모니터링 힌트

- **보안 로그**
  - 4611(드라이버 로드), 4672(특권 사용), 4688(프로세스 생성), 4697(서비스 설치), 4719(감사 정책 변경)
- **Sysmon(권장)**
  - Event ID 1(Process Create), 7(Image Load), 10(Process Access; lsass.exe 접근 모니터), 13(Registry), 19(WmiEventFilter), 20(WmiEventConsumer), 21(WmiBinding)
- **작업 스케줄러**
  - Microsoft-Windows-TaskScheduler/Operational 채널 활성, SYSTEM 작업 변경/실행 감시

---

# 부록 B. 개발자를 위한 “안전 로더” 체크리스트

- [ ] `SetDefaultDllDirectories` 호출
- [ ] `LoadLibraryEx(..., LOAD_LIBRARY_SEARCH_SYSTEM32 | ...)`
- [ ] 상대 경로/현재 디렉터리 의존 금지
- [ ] 모든 바이너리/드라이버 **서명**
- [ ] 인스톨러가 **서비스/작업/레지스트리** 권한을 표준으로 배치(테스트 포함)

---

# 마무리

- 윈도우 LPE는 대개 **오구성의 합성**에서 발생합니다.
- **SID/토큰/무결성/UAC**를 이해하면 “왜 이 경로가 위험한지”를 명확히 설명하고 바로잡을 수 있습니다.
- **LSASS 보호/자격 격리**와 **경로/권한 표준화**만으로도 실무 리스크가 크게 줄어듭니다.
- 위 스크립트/코드를 **사내 표준 점검 도구**로 래핑하고, CI·EDR·GPO와 **연동**하면 지속적인 방어력이 생깁니다.
