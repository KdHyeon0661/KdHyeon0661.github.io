---
layout: post
title: 형식언어와 오토마타 - 파싱과 모호성, 파싱과 소속성, 문법과 언어의 모호성
date: 2025-07-08 22:20:23 +0900
category: 형식언어와 오토마타
---
# 파싱과 모호성, 파싱과 소속성, 문법과 언어의 모호성

## 0. 빠른 로드맵

- **파싱**: 문자열 `w`가 문법 `G`로부터 생성되는가(소속성), 그리고 **어떻게** 생성되는가(유도 트리/AST)를 구함.  
- **모호성(ambiguity)**: 같은 문자열에 대해 **서로 다른 파스 트리**가 2개 이상 → **문법 모호**.  
- **언어 모호성**: 그 언어를 생성하는 **어떤 문법을 써도** 모호함을 피할 수 없음(= 본질적으로 모호).  
- **소속성(membership)**: \( w \in L(G) \)인지 판정. CFG는 일반적으로 **다항식 시간**에 가능(CYK/Earley), LL/LR 등 **제약된 문법**은 선형시간.

---

## 1. 파싱(Parsing) 개요

> **정의**: 파싱은 문자열 \( w \)가 문법 \( G=(V,\Sigma,R,S) \)로부터 생성되는지 확인하고, 생성된다면 그 **구조(파스 트리/유도 트리)**를 구성하는 과정.

### 1.1 패러다임과 대표 알고리즘

| 분류 | 아이디어 | 대표 알고리즘 | 시간복잡도(보통/최악) | 장점 |
|---|---|---|---|---|
| Top-Down | \(S\)에서 시작해 **예측적**으로 파생 | LL(1), Recursive Descent | \(O(n)\) / 문법 제약 | 단순, 직관, 핸드파싱 용이 |
| Bottom-Up | 입력에서 시작, **축약(감소)** | LR(0)/SLR/LALR/LR(1) | \(O(n)\) / 문법 제약 | 강력, 산업표준(Yacc/Bison) |
| General | 모든 CFG 대상 | CYK, Earley | \(O(n^3)\) / \(O(n^3)\) | 어떤 CFG에도 적용 가능 |

- 실용 언어(컴파일러)에서는 보통 **LL(k)/LR(k)** 계열(선형시간)을 선호.
- **모호한 문법**은 LR/LL 테이블 생성 시 **shift/reduce, reduce/reduce 충돌**을 흔히 유발.

---

## 2. 소속성(Membership)과 결정 가능성

> **문제**: 주어진 문자열 \( w \)가 \( L(G) \)에 속하는가? 즉 \( w \in L(G) \)?

- **정규언어**: DFA 시뮬레이션으로 \(O(n)\).
- **CFG(일반)**: **CYK**(CNF 필요), **Earley**(CNF 불필요) 등으로 **다항 시간**에 판정.

### 2.1 CYK(Chomsky Normal Form) 핵심

- CNF: 모든 규칙이 \( A \to BC \) (두 비터미널) 또는 \( A \to a \) (단말) 또는 \( S\to\varepsilon \).
- DP 테이블 \(T[i][\ell]\): 길이 \(\ell\)의 구간(시작 \(i\))을 만들 수 있는 비터미널 집합.
- 점화식:
  $$
  A\in T[i,\ell]\iff 
  \exists k\in[1,\ell-1],\exists B,C:
  (A\to BC)\wedge (B\in T[i,k])\wedge (C\in T[i+k,\ell-k])
  $$
- 시작기호 \(S\in T[0,n]\)이면 **수용**.

#### ▶ 미니 CYK 파이썬(입력 문법은 CNF로 가정)

```python
# cyk.py — CNF 전용 간단 Membership 체크

from collections import defaultdict

def cyk_membership(cnf_rules, s, start='S'):
    """
    cnf_rules: dict with two keys:
      'bin': list of (A, B, C) for A->BC
      'term': list of (A, a)   for A->a
      (S->ε 허용 시 별도 플래그 필요)
    s: input string (list of terminals), e.g., ['a','a','b','b']
    """
    n = len(s)
    if n == 0:
        # S->ε 규칙이 있는지 검사
        return any(A == start for (A,a) in cnf_rules.get('term',[]) if a == 'ε')

    # 역인덱스 구축
    A_from_BC = defaultdict(list) # (B,C) -> [A...]
    A_from_a  = defaultdict(list) # a -> [A...]
    for A,B,C in cnf_rules.get('bin', []):
        A_from_BC[(B,C)].append(A)
    for A,a in cnf_rules.get('term', []):
        A_from_a[a].append(A)

    # T[i][l]: 길이 l, 시작 i 구간에서 가능한 변수들 set
    T = [[set() for _ in range(n+1)] for __ in range(n)]

    # 길이 1
    for i, a in enumerate(s):
        for A in A_from_a.get(a, []):
            T[i][1].add(A)

    # 길이 >= 2
    for l in range(2, n+1):
        for i in range(0, n-l+1):
            for k in range(1, l):
                lefts  = T[i][k]
                rights = T[i+k][l-k]
                for B in lefts:
                    for C in rights:
                        for A in A_from_BC.get((B, C), []):
                            T[i][l].add(A)

    return (start in T[0][n])

# 예: S -> a S b | ε 의 CNF 변형
# S -> a S b 를
#   A->a, B->b, S->A D, D->S B 로 쪼갠 뒤, S->ε 허용(여기서는 ε 입력 미고려)
cnf = {
  'term': [('A','a'), ('B','b')],
  'bin' : [('S','A','D'), ('D','S','B')]
}

print(cyk_membership(cnf, list("aabb"), start='S'))  # True
print(cyk_membership(cnf, list("ab"), start='S'))    # True
print(cyk_membership(cnf, list("aaabbb"), start='S'))# True
print(cyk_membership(cnf, list("aab"), start='S'))   # False
```

> 팁: 실전에서는 CNF 변환기(ε/단위/쓸모없는 기호 제거, 이항화)를 먼저 구현해두면 활용성이 커집니다.

### 2.2 Earley(개요)

- **CNF 불필요**, 모든 CFG 적용 가능.  
- 상태 아이템 \((A\to\alpha \bullet \beta, i)\) 를 사용, **예측/스캔/완성** 3단계로 진행.  
- 최악 \(O(n^3)\), 많은 실용 문법에서 우수.

---

## 3. 파싱과 **문법 모호성**

> **정의**: 하나의 CFG에서 어떤 문자열 \(w\)가 **둘 이상**의 상이한 파스 트리(또는 좌/우 유도)를 갖는다면 **문법이 모호**.

### 3.1 고전 예: 연산자 우선순위 미명시

```
E → E + E | E * E | (E) | id
```

- `id + id * id`의 해석:  
  1) `(id + id) * id`  
  2) `id + (id * id)`  
- **서로 다른 트리** → **모호한 문법**.

### 3.2 모호성 해소(비모호 문법)

```
E → E + T | T
T → T * F | F
F → (E) | id
```

- `*`가 `+`보다 **우선**, 둘 다 **좌결합**.  
- 위와 같은 설계(또는 우재귀/반복형)로 LL/LR 테이블 생성이 쉬워지며, 파싱 충돌 감소.

### 3.3 LL(1) 판정: FIRST/FOLLOW & Parse Table 충돌 체크

**규칙**(요지):  
- 한 비터미널 \(A\)에서 나가는 여러 규칙 \(A\to \alpha_1,\alpha_2,\dots\)의 **FIRST** 집합이 **서로 교집합 없음**.  
- \(\alpha_i \Rightarrow^* \varepsilon\) 가능하면 **FIRST(\(\alpha_i\))**와 **FOLLOW(A)**도 교집합 없음.

#### ▶ FIRST/FOLLOW 계산 & LL(1) 테이블 제작(미니 코드)

```python
# ll1_check.py — FIRST/FOLLOW와 LL(1) 테이블 충돌 검사 (간단형)

from collections import defaultdict

def compute_first(grammar, terminals, start):
    FIRST = {A:set() for A in grammar}
    changed = True
    while changed:
        changed = False
        for A, rhss in grammar.items():
            for rhs in rhss:
                # rhs: list of symbols
                nullable = True
                for X in rhs:
                    if X in terminals:
                        if X not in FIRST[A]:
                            FIRST[A].add(X); changed = True
                        nullable = False
                        break
                    else:
                        before = len(FIRST[A])
                        FIRST[A].update(sym for sym in FIRST[X] if sym!='ε')
                        changed |= (len(FIRST[A]) > before)
                        if 'ε' not in FIRST[X]:
                            nullable = False
                            break
                if nullable:
                    if 'ε' not in FIRST[A]:
                        FIRST[A].add('ε'); changed = True
    return FIRST

def compute_follow(grammar, terminals, start, FIRST):
    FOLLOW = {A:set() for A in grammar}
    FOLLOW[start].add('$')
    changed = True
    while changed:
        changed = False
        for A, rhss in grammar.items():
            for rhs in rhss:
                for i, X in enumerate(rhs):
                    if X in grammar:  # nonterminal
                        beta = rhs[i+1:]
                        if beta:
                            # FIRST(beta) - {ε} ⊆ FOLLOW(X)
                            first_beta = first_of_string(beta, FIRST, terminals)
                            before = len(FOLLOW[X])
                            FOLLOW[X].update(s for s in first_beta if s!='ε')
                            changed |= (len(FOLLOW[X]) > before)
                            # if ε in FIRST(beta): FOLLOW(A) ⊆ FOLLOW(X)
                            if 'ε' in first_beta:
                                before = len(FOLLOW[X])
                                FOLLOW[X].update(FOLLOW[A])
                                changed |= (len(FOLLOW[X]) > before)
                        else:
                            # FOLLOW(A) ⊆ FOLLOW(X)
                            before = len(FOLLOW[X])
                            FOLLOW[X].update(FOLLOW[A])
                            changed |= (len(FOLLOW[X]) > before)
    return FOLLOW

def first_of_string(seq, FIRST, terminals):
    out = set()
    nullable = True
    for X in seq:
        if X in terminals:
            out.add(X); nullable = False; break
        else:
            out.update(s for s in FIRST[X] if s!='ε')
            if 'ε' not in FIRST[X]:
                nullable = False; break
    if nullable:
        out.add('ε')
    return out

def build_ll1_table(grammar, terminals, start):
    FIRST = compute_first(grammar, terminals, start)
    FOLLOW = compute_follow(grammar, terminals, start, FIRST)
    table = defaultdict(dict)
    conflicts = []
    for A, rhss in grammar.items():
        for rhs in rhss:
            f = first_of_string(rhs, FIRST, terminals)
            for a in (f - {'ε'}):
                if a in table[A]:
                    conflicts.append((A, a, table[A][a], rhs))
                table[A][a] = rhs
            if 'ε' in f:
                for b in FOLLOW[A]:
                    if b in table[A]:
                        conflicts.append((A, b, table[A][b], rhs))
                    table[A][b] = rhs
    return table, conflicts, FIRST, FOLLOW

# 테스트: 비모호 수식 (우선순위 반영)
grammar = {
  'E': [['E','+','T'], ['T']],
  'T': [['T','*','F'], ['F']],
  'F': [['(','E',')'], ['id']]
}
terminals = {'+','*','(',')','id','$'}
table, conflicts, FIRST, FOLLOW = build_ll1_table(grammar, terminals, 'E')
print("LL(1) conflicts:", conflicts)  # 보통 빈 리스트면 OK

# 모호 문법(우선순위 미명시)
amb = {
  'E': [['E','+','E'], ['E','*','E'], ['id']]
}
table2, conflicts2, _, _ = build_ll1_table(amb, terminals, 'E')
print("LL(1) conflicts (amb):", conflicts2)  # 충돌 다수
```

- **충돌(conflict)**이 없으면 **LL(1)** 가능 → **예측파싱 가능** → 파싱 결정이 **모호하지 않음**.  
- 충돌이 난다고 **반드시** 언어가 모호한 것은 아니지만, **문법을 리팩터** 해야 함(좌재귀 제거/좌공통인자 제거/우선순위 도입 등).

### 3.4 LR 계열과 모호성(충돌)

- LR 테이블에서 **shift/reduce** 또는 **reduce/reduce** 충돌이 생기면 (보통) **문법 모호** 또는 우선순위/결합법칙 미정.  
- 실무 툴(Yacc/Bison)은 `%left`, `%right`, `%precedence` 등으로 **해결 규칙을 주입**해 모호성을 **해소**.

---

## 4. **언어**의 모호성과 예

> **문법이 모호**하다고 해서 **언어가 모호**한 것은 아니다.  
> 반대로 **언어 자체가 모호**인 경우(= **본질적으로 모호**), 어떤 문법으로도 비모호하게 표현 불가.

### 4.1 본질적으로 모호한 CFL(고전 예)

다음 언어는 **본질적으로 모호**임이 알려져 있다(증명은 표준 교재 참고).

- \(L = \{ a^i b^j c^k \mid i=j \text{ 또는 } j=k \}\)

문자열 \(a^n b^n c^n\)은  
- \(i=j\)로도,  
- \(j=k\)로도  
파생될 수 있어(두 “의미상 다른” 생성 경로), 언어 차원에서 모호성이 제거되지 않는다.

> 요지: “언어의 모호성”은 개별 문법 리팩터링으로 해결할 수 **없는** 성질.

---

## 5. 파싱과 모호성/소속성 — 실전 체크리스트

- **소속성만** 빠르게:  
  - 정규 → DFA 시뮬, \(O(n)\)  
  - CFG → CYK/Earley, \(O(n^3)\)  
- **구조(트리)까지** 필요:  
  - LL/LR 계열(선형시간) 문법 설계 권장.  
  - 모호하면 우선순위/결합/괄호화 규칙으로 **비모호화**.
- **LL(1) 검증**: FIRST/FOLLOW, 테이블 충돌 유무 확인.  
- **LR 충돌**: 모호/미정 우선순위의 신호 → 선언으로 해소 가능.  
- **언어 자체 모호?**: 표준 **본질적 모호 언어** 판정 예시/정리를 확인.

---

## 6. 작은 워크플로우(예제)

### 6.1 “`a^n b^n`”에 대한 소속성(CYK)

- 문법 \(S\to aSb\mid \varepsilon\)을 **CNF**로 쪼개어(예: \(A\to a, B\to b, S\to A D, D\to S B, S\to\varepsilon\))  
- `aabb`, `aaabbb` 등 입력에 대해 **위 CYK 코드**로 membership → `True/False`.

### 6.2 수식 파싱에서 모호성 제거

- 모호 문법: `E→E+E|E*E|id` → **LL(1) 충돌**.  
- 비모호 문법:  
  ```
  E → T ( + T )*
  T → F ( * F )*
  F → ( E ) | id
  ```
  - **FIRST/FOLLOW**로 LL(1) 테이블 생성 → 충돌 없음.  
  - **예측 파싱**/재귀하강으로 선형시간 파싱.

---

## 7. 이론 스냅샷

- **Membership (CFG)**: 결정 가능, 일반적으로 \(O(n^3)\).  
- **Ambiguity 결정 문제(문법 모호성 판정)**: CFG에 대해 **결정 불가능**(일반문제).  
- **Equivalence(두 CFG 동치?)**: 일반적으로 **결정 불가능**.  
- **정규 언어**: 합·교·차·여·연접·Kleene*, 역순 등 **폐포성** 우수, 결정 문제 다수 **효율적**.

---

## 8. 실전 팁

- **문법 설계** 때부터:  
  - **좌재귀 제거**, **좌공통인자 제거**, **우선순위/결합법칙**을 **규칙으로 코드화**.  
  - 테스트 문자열 세트로 **FIRST/FOLLOW 충돌, LR 충돌** 자동 점검.  
- **도구**: ANTLR(LL), Bison(Yacc, LALR), Menhir(OCaml, LR), tree-sitter 등.  
- **모호성 대응**:  
  - 언어 설계 차원에서 **의미를 하나로 고정**(예: 산술 연산 우선순위 표).  
  - 파서 생성기 **우선순위/결합 선언** 사용.

---

## 9. 부록: 수식(정의/공식)

- **소속성**: 문자열 \(w\)가 \(L(G)\)에 속하는가?  
- **문법 모호성**: \(\exists w\in L(G)\) s.t. \(w\)의 파스 트리가 \(\ge 2\).  
- **언어 모호성**: \(L\)을 생성하는 모든 문법이 모호.

- CYK 테이블 점화:
  $$
  A\in T[i,\ell] \iff \bigvee_{k=1}^{\ell-1}\bigvee_{A\to BC}\big( B\in T[i,k]\wedge C\in T[i+k,\ell-k]\big)
  $$

---

## 10. 마무리 요약

| 주제 | 핵심 |
|---|---|
| 파싱 | \(w\in L(G)\) 판정 + 구조(트리) 구성 |
| 소속성 | CFG: CYK/Earley로 다항식 시간 (LL/LR는 선형) |
| 문법 모호성 | 같은 \(w\)에 대해 트리 ≥ 2개면 모호 |
| 언어 모호성 | 어떤 문법으로도 비모호 불가(본질적 모호) |
| 실무 대응 | 문법 리팩토링(우선순위/결합/팩토링), LL/LR로 테이블 무충돌화 |