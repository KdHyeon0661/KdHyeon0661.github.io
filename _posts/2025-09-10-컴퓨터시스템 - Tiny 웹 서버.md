---
layout: post
title: 컴퓨터시스템 - Tiny 웹 서버
date: 2025-09-10 16:20:23 +0900
category: 컴퓨터시스템
---
# Tiny 웹 서버 (CS:APP 스타일) — 설계·구현·확장까지 한 번에

> 목표: 교육용 **Tiny Web Server**를 **처음부터 구현**하고, 정적/동적 콘텐츠 처리, HTTP/1.0~1.1, RIO(Robust I/O) 사용법, 보안·성능 포인트까지 **실전 품질**로 확장합니다.  
> 형식: 전체는 `~~~markdown`으로 감싸고, **코드는 모두 ``` 코드펜스**로 제공합니다.

---

## 0) 개요

Tiny 웹 서버는 **HTTP 요청을 읽어** 정적 파일(HTML/이미지/JS 등)을 돌려주거나, **동적 요청을 외부 프로그램(CGI 등)** 에 위임해 그 결과를 응답하는 **아주 작은 학습용 서버**입니다.

핵심 구성:
- **메인 루프**: `socket → bind → listen → accept` 반복
- **요청 처리**: 요청줄/헤더 파싱 → 정적/동적 판별 → 응답 생성
- **I/O**: **RIO** 로 안전하게 읽기/쓰기 (`EINTR`, 부분 I/O, 라인 읽기)
- **보안 최소한**: 경로 정규화, 디렉터리 트래버설 차단, MIME 판정, 오류 응답

---

## 1) 빌드·실행 미리보기

```bash
# 빌드
cc -O2 -Wall -Wextra -o tiny tiny.c rio.c

# 실행 (문서 루트: ./www, 포트 8080)
mkdir -p www
echo "<h1>Hello Tiny</h1>" > www/index.html
./tiny 8080 www

# 테스트
curl -v http://127.0.0.1:8080/
curl -v "http://127.0.0.1:8080/cgi-bin/adder?x=7&y=35"
```

---

## 2) 디렉터리 구성

```
project/
 ├─ tiny.c          # 서버 본체
 ├─ rio.c, rio.h    # Robust I/O (라인/정확히 N 바이트)
 └─ www/            # 문서 루트(정적)
     ├─ index.html
     └─ cgi-bin/    # 동적(CGI) 실행 위치
         └─ adder   # 예시 CGI 실행 파일
```

CGI 예시(아래 §7.2 코드) 빌드 후 `www/cgi-bin/adder`에 두세요.

---

## 3) 핵심 설계 개념

### 3.1 요청 처리 파이프라인
1. **Accept**로 연결 수락
2. **요청줄**: `METHOD URI VERSION` 파싱 (예: `GET /path HTTP/1.1`)
3. **헤더** 스캔(Host, Connection, Content-Length 등)
4. **URI 해석** → **정적**(파일 경로) / **동적**(cgi-bin 및 쿼리) 판별
5. **정적**: 파일 열기 → MIME 판정 → 헤더 전송 → 파일 전송(`sendfile`/`mmap`/`read` 루프)
6. **동적**: 환경변수·stdin으로 입력 전달 → **`fork`+`execve`**로 실행 → 표준출력 스트리밍
7. **연결 종료**(HTTP/1.0) 또는 **keep-alive**(HTTP/1.1)

### 3.2 보안·안정성 최소 수칙
- 문서 루트 **밖으로 탈출 금지**: `..` 제거, 심볼릭 링크 노출 금지(학습 목적이면 최소 `..` 거르기)
- **메서드 화이트리스트**: `GET`, (옵션) `HEAD`만 처리
- **타임아웃/크기 상한**: 요청 헤더/라인 길이 제한
- **에러 응답**: 400/403/404/500/501 템플릿

---

## 4) MIME 타입 테이블(간단 버전)

```c
/* 확장자 → Content-Type */
static const struct { const char* ext; const char* type; } k_mime[] = {
  { "html", "text/html; charset=utf-8" },
  { "htm",  "text/html; charset=utf-8" },
  { "css",  "text/css; charset=utf-8" },
  { "js",   "application/javascript" },
  { "png",  "image/png" },
  { "jpg",  "image/jpeg" },
  { "jpeg", "image/jpeg" },
  { "gif",  "image/gif" },
  { "svg",  "image/svg+xml" },
  { "json", "application/json; charset=utf-8" },
  { "txt",  "text/plain; charset=utf-8" },
  { NULL,   "application/octet-stream" }
};
```

---

## 5) Tiny 서버 전체 코드(학습용 단일-프로세스, GET 지원)

> 설명 주석이 많은 **깨끗한 단일 파일**입니다. (실무 확장은 §8 참조)

```c
/* tiny.c : 교육용 Tiny Web Server (GET/HEAD + 정적/CGI) */
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/sendfile.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include "rio.h"  /* RIO: rio_readinitb, rio_readlineb, rio_readn, rio_writen */

#define MAXLINE 8192
#define MAXPATH 4096
#define MAXHDR  100

static const char* mime_from_path(const char* path);
static void client_error(int fd, int code, const char* shortmsg, const char* fmt, ...);
static void serve_static(int fd, const char* path, bool head_only);
static void serve_dynamic(int fd, const char* cgi_prog, const char* cgi_query, const char* method, rio_t* rio, ssize_t content_length);
static void url_decode(char* s);
static void sanitize_path(char* path);
static int  open_listen(int port);

static const char* g_docroot = "./www";

/* --- MIME table --- */
static const struct { const char* ext; const char* type; } k_mime[] = {
  { "html", "text/html; charset=utf-8" },
  { "htm",  "text/html; charset=utf-8" },
  { "css",  "text/css; charset=utf-8" },
  { "js",   "application/javascript" },
  { "png",  "image/png" },
  { "jpg",  "image/jpeg" },
  { "jpeg", "image/jpeg" },
  { "gif",  "image/gif" },
  { "svg",  "image/svg+xml" },
  { "json", "application/json; charset=utf-8" },
  { "txt",  "text/plain; charset=utf-8" },
  { NULL,   "application/octet-stream" }
};

static const char* mime_from_path(const char* path) {
    const char* dot = strrchr(path, '.');
    if (!dot || dot == path) return "application/octet-stream";
    const char* ext = dot + 1;
    for (int i=0; k_mime[i].ext; i++)
        if (strcasecmp(ext, k_mime[i].ext) == 0) return k_mime[i].type;
    return "application/octet-stream";
}

static void http_date(char* buf, size_t n) {
    time_t t = time(NULL);
    struct tm g; gmtime_r(&t, &g);
    strftime(buf, n, "%a, %d %b %Y %H:%M:%S GMT", &g);
}

static void client_error(int fd, int code, const char* shortmsg, const char* fmt, ...) {
    char body[MAXLINE], hdr[MAXLINE]; va_list ap;
    va_start(ap, fmt);
    char detail[MAXLINE]; vsnprintf(detail, sizeof(detail), fmt, ap);
    va_end(ap);

    snprintf(body, sizeof(body),
        "<html><head><title>%d %s</title></head>"
        "<body><h1>%d %s</h1><p>%s</p></body></html>\n",
        code, shortmsg, code, shortmsg, detail);

    char date[128]; http_date(date, sizeof(date));
    int len = (int)strlen(body);
    snprintf(hdr, sizeof(hdr),
        "HTTP/1.1 %d %s\r\n"
        "Date: %s\r\n"
        "Content-Type: text/html; charset=utf-8\r\n"
        "Content-Length: %d\r\n"
        "Connection: close\r\n\r\n",
        code, shortmsg, date, len);
    rio_writen(fd, hdr, strlen(hdr));
    rio_writen(fd, body, len);
}

static void sanitize_path(char* path) {
    /* 아주 단순한 정규화: // → / , "/../" 제거 시도 (학습용) */
    char tmp[MAXPATH]; size_t j=0;
    for (size_t i=0; path[i] && j+1<sizeof(tmp); ) {
        if (path[i]=='/' && path[i+1]=='/') { i++; continue; }
        tmp[j++] = path[i++];
    }
    tmp[j]='\0';
    /* ".." 차단 */
    if (strstr(tmp, "..")) { strcpy(path, "/"); return; }
    strcpy(path, tmp);
}

static void url_decode(char* s) {
    /* 퍼센트 디코딩 (간단 버전) */
    char *o = s;
    for (; *s; s++, o++) {
        if (*s=='%' && s[1] && s[2]) {
            int v; sscanf(s+1, "%2x", &v);
            *o = (char)v; s += 2;
        } else if (*s=='+') *o = ' ';
        else *o = *s;
    }
    *o = '\0';
}

static void serve_static(int fd, const char* path, bool head_only) {
    int f = open(path, O_RDONLY);
    if (f < 0) { client_error(fd, 404, "Not Found", "Cannot open %s", path); return; }

    struct stat st; fstat(f, &st);
    if (!S_ISREG(st.st_mode) || !(st.st_mode & S_IROTH)) {
        close(f); client_error(fd, 403, "Forbidden", "Permission denied"); return; }

    char date[128]; http_date(date, sizeof(date));
    char hdr[MAXLINE];
    snprintf(hdr, sizeof(hdr),
        "HTTP/1.1 200 OK\r\n"
        "Date: %s\r\n"
        "Content-Type: %s\r\n"
        "Content-Length: %lld\r\n"
        "Connection: close\r\n\r\n",
        date, mime_from_path(path), (long long)st.st_size);
    rio_writen(fd, hdr, strlen(hdr));

    if (!head_only) {
#ifdef __linux__
        /* 효율적: 커널 제로카피 전송 */
        off_t off = 0; ssize_t left = st.st_size;
        while (left > 0) {
            ssize_t n = sendfile(fd, f, &off, (size_t)left);
            if (n <= 0) { if (errno==EINTR) continue; break; }
            left -= n;
        }
#else
        /* 범용: mmap + write */
        void* p = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, f, 0);
        if (p != MAP_FAILED) {
            rio_writen(fd, p, st.st_size);
            munmap(p, st.st_size);
        } else {
            char buf[1<<16]; ssize_t n;
            while ((n = read(f, buf, sizeof buf)) > 0) rio_writen(fd, buf, n);
        }
#endif
    }
    close(f);
}

static void serve_dynamic(int fd, const char* cgi_prog, const char* cgi_query,
                          const char* method, rio_t* rio, ssize_t content_length) {
    int p[2]; if (pipe(p) < 0) { client_error(fd,500,"Internal","pipe()"); return; }

    pid_t pid = fork();
    if (pid < 0) { client_error(fd,500,"Internal","fork()"); close(p[0]); close(p[1]); return; }

    if (pid == 0) {
        /* 자식: CGI 실행. stdout → 소켓 */
        dup2(fd, STDOUT_FILENO);
        if (strcasecmp(method,"POST")==0) dup2(p[0], STDIN_FILENO);
        close(p[0]); close(p[1]);

        /* CGI 환경 변수 */
        setenv("REQUEST_METHOD", method, 1);
        setenv("QUERY_STRING", cgi_query?cgi_query:"", 1);
        setenv("CONTENT_LENGTH", content_length>0 ? ({ static char tmp[32]; snprintf(tmp,32,"%zd",content_length), tmp; }) : "", 1);
        setenv("CONTENT_TYPE", "application/x-www-form-urlencoded", 0);

        execl(cgi_prog, cgi_prog, (char*)NULL);
        /* 실패 */
        fprintf(stderr, "exec %s failed: %s\n", cgi_prog, strerror(errno));
        _exit(1);
    } else {
        /* 부모: POST 바디를 자식 stdin으로 릴레이 */
        close(p[0]);
        if (strcasecmp(method,"POST")==0 && content_length>0) {
            char buf[8192]; ssize_t left = content_length;
            while (left > 0) {
                ssize_t r = rio_readn(rio->rio_fd, buf, (size_t)((left>sizeof buf)?sizeof buf:left));
                if (r <= 0) break;
                if (rio_writen(p[1], buf, r) < 0) break;
                left -= r;
            }
        }
        close(p[1]);
        /* 자식 종료 대기(간단화) */
        int st; waitpid(pid, &st, 0);
    }
}

static int open_listen(int port) {
    int s = socket(AF_INET6, SOCK_STREAM, 0);
    if (s < 0) return -1;
    int on=1; setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
    int v6only=0; setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
    struct sockaddr_in6 addr; bzero(&addr, sizeof(addr));
    addr.sin6_family = AF_INET6;
    addr.sin6_addr   = in6addr_any;
    addr.sin6_port   = htons((uint16_t)port);
    if (bind(s, (struct sockaddr*)&addr, sizeof(addr)) < 0) { close(s); return -1; }
    if (listen(s, 128) < 0) { close(s); return -1; }
    return s;
}

int main(int argc, char** argv) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <port> <docroot>\n", argv[0]);
        return 1;
    }
    int port = atoi(argv[1]);
    g_docroot = argv[2];

    signal(SIGPIPE, SIG_IGN); /* 쓰기 중단 보호 */

    int listenfd = open_listen(port);
    if (listenfd < 0) { perror("listen"); return 1; }
    fprintf(stderr, "Tiny listening on :%d docroot=%s\n", port, g_docroot);

    for (;;) {
        struct sockaddr_storage ss; socklen_t slen = sizeof(ss);
        int connfd = accept(listenfd, (struct sockaddr*)&ss, &slen);
        if (connfd < 0) { if (errno==EINTR) continue; perror("accept"); continue; }

        rio_t rio; rio_readinitb(&rio, connfd);

        /* --- 요청줄 파싱 --- */
        char buf[MAXLINE], method[16], uri[MAXLINE], version[32];
        if (rio_readlineb(&rio, buf, sizeof(buf)) <= 0) { close(connfd); continue; }
        if (sscanf(buf, "%15s %4095s %31s", method, uri, version) < 2) {
            client_error(connfd, 400, "Bad Request", "Malformed request line"); close(connfd); continue;
        }

        bool head_only = false;
        if (strcasecmp(method,"GET") && strcasecmp(method,"HEAD") && strcasecmp(method,"POST")) {
            client_error(connfd, 501, "Not Implemented", "Method %s not supported", method); close(connfd); continue;
        }
        if (strcasecmp(method,"HEAD")==0) head_only = true;

        /* --- 헤더 읽기 --- */
        ssize_t content_length = 0;
        bool keep_alive = false;
        while (1) {
            ssize_t n = rio_readlineb(&rio, buf, sizeof(buf));
            if (n <= 0) break;
            if (!strcmp(buf, "\r\n")) break;
            /* 최소 파싱 */
            if (!strncasecmp(buf,"Content-Length:",15))
                content_length = atoll(buf+15);
            else if (!strncasecmp(buf,"Connection:",11)) {
                if (strstr(buf,"keep-alive") || strstr(buf,"Keep-Alive")) keep_alive = true;
            }
        }

        /* --- URI 해석: 정적/동적 --- */
        char path[MAXPATH]; char cgi_prog[MAXPATH]; char query[MAXLINE];
        query[0]='\0';
        if (strncasecmp(uri, "/cgi-bin/", 9)==0) {
            /* 동적 */
            const char* q = strchr(uri,'?');
            if (q) { size_t L = (size_t)(q - uri); memcpy(cgi_prog, uri, L); cgi_prog[L]='\0'; strncpy(query, q+1, sizeof(query)-1); }
            else   { strncpy(cgi_prog, uri, sizeof(cgi_prog)-1); }
            url_decode(query);

            /* docroot + cgi_prog */
            snprintf(path, sizeof(path), "%s%s", g_docroot, cgi_prog);
            sanitize_path(path);

            struct stat st;
            if (stat(path, &st)<0 || !S_ISREG(st.st_mode) || access(path, X_OK)!=0) {
                client_error(connfd, 404, "Not Found", "CGI not found or not executable");
            } else {
                /* CGI는 스스로 헤더를 출력해야 함 */
                serve_dynamic(connfd, path, query, method, &rio, content_length);
            }
        } else {
            /* 정적 */
            char resource[MAXPATH];
            strncpy(resource, uri, sizeof(resource)-1);
            url_decode(resource);
            sanitize_path(resource);

            if (resource[strlen(resource)-1] == '/') strncat(resource, "index.html", sizeof(resource)-strlen(resource)-1);

            snprintf(path, sizeof(path), "%s%s", g_docroot, resource);
            struct stat st;
            if (stat(path, &st)<0) {
                client_error(connfd, 404, "Not Found", "No such resource");
            } else if (S_ISDIR(st.st_mode)) {
                /* 디렉터리면 index.html */
                strncat(path, "/index.html", sizeof(path)-strlen(path)-1);
                if (stat(path,&st)<0) { client_error(connfd, 403,"Forbidden","No index"); }
                else serve_static(connfd, path, head_only);
            } else {
                serve_static(connfd, path, head_only);
            }
        }

        /* 간단 모드: 매 요청 후 종료(keep-alive 미지원) */
        (void)keep_alive; /* 학습용: 무시 */
        close(connfd);
    }
    return 0;
}
```

> 참고: 위 코드는 학습 편의를 위해 **에러 처리, 헤더 파싱, 보안**을 최소화 버전으로 유지했습니다.  
> 실무 품질 포인트는 §8에서 단계적으로 추가합니다.

---

## 6) RIO(견고한 I/O) 헤더 스케치

프로젝트에 이미 `rio.h/rio.c`가 있다면 그대로 쓰세요. (이전에 설명한 버전과 동일)

```c
/* rio.h */
#ifndef RIO_H
#define RIO_H
#include <sys/types.h>
#define RIO_BUFSIZE 8192
typedef struct {
  int   rio_fd;
  int   rio_cnt;
  char* rio_bufptr;
  char  rio_buf[RIO_BUFSIZE];
} rio_t;
ssize_t rio_readn (int fd, void *usrbuf, size_t n);
ssize_t rio_writen(int fd, const void *usrbuf, size_t n);
void    rio_readinitb(rio_t *rp, int fd);
ssize_t rio_readnb  (rio_t *rp, void *usrbuf, size_t n);
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);
#endif
```

---

## 7) 동적 컨텐츠(CGI) 예시

### 7.1 개념
- Tiny는 **`/cgi-bin/...`** 경로를 **실행 파일**로 취급합니다.
- **GET**: 쿼리스트링(`QUERY_STRING`) 환경변수로 전달  
- **POST**: 본문 길이(`CONTENT_LENGTH`)만큼 **stdin**으로 전달  
- CGI 프로그램은 **stdout으로 HTTP 헤더+본문**을 출력해야 합니다.

### 7.2 예제 CGI: **adder** (C)

```c
/* adder.c : /cgi-bin/adder?x=7&y=35 → HTML로 합 출력 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static int get_kv(const char* qs, const char* key) {
    if (!qs) return 0;
    char *dup = strdup(qs), *p = dup, *tok; int val=0;
    while ((tok = strsep(&p, "&"))) {
        char *eq = strchr(tok, '=');
        if (!eq) continue;
        *eq='\0'; if (strcmp(tok,key)==0) { val = atoi(eq+1); break; }
    }
    free(dup); return val;
}

int main(void){
    const char* method = getenv("REQUEST_METHOD");
    const char* qs = getenv("QUERY_STRING");
    int x=0,y=0;

    if (method && strcasecmp(method,"POST")==0) {
        int len = atoi(getenv("CONTENT_LENGTH")?:"0");
        char *buf = (char*)malloc(len+1); fread(buf,1,len,stdin); buf[len]='\0';
        qs = buf; /* 폼-인코딩 가정(단순) */
        x=get_kv(qs,"x"); y=get_kv(qs,"y");
        free(buf);
    } else {
        x=get_kv(qs,"x"); y=get_kv(qs,"y");
    }

    /* CGI는 응답 헤더를 직접 출력 */
    printf("Content-Type: text/html; charset=utf-8\r\n\r\n");
    printf("<html><body><h1>%d + %d = %d</h1></body></html>\n", x, y, x+y);
    return 0;
}
```

빌드:
```bash
cc -O2 -o www/cgi-bin/adder adder.c
```

---

## 8) 단계적 확장(실무에 가까운 개선 포인트)

1) **keep-alive 지원(HTTP/1.1)**  
   - `Connection: keep-alive` 해석 → `while` 루프로 한 소켓에서 여러 요청 처리  
   - **타임아웃**(SO_RCVTIMEO/epoll)과 **최대 요청 수** 제한

2) **헤더 파서 강화**  
   - 대소문자 무시, 공백/접속 줄(line folding) 처리, `Host` 필수(HTTP/1.1)  
   - `Range`/`If-None-Match`/`If-Modified-Since` 등 선택 지원

3) **보안**  
   - 경로 정규화 강화(실제 FS 기반 canonicalize: `realpath` + docroot prefix 검사)  
   - 심볼릭 링크/장치 파일 차단, 인덱스 리스팅 금지  
   - CGI 환경 변수 화이트리스트, 사용자 입력 크기 제한

4) **성능**  
   - 정적 파일: `sendfile`/`mmap` + `TCP_CORK`/`MSG_MORE`로 헤더+바디 결합  
   - 스레드 풀 / 프록세스 풀 / 이벤트 루프(epoll)  
   - 간단 캐시(파일 stat 결과, 작은 파일 메모리 캐시)

5) **로그/관찰성**  
   - 접속 로그(공통 로그 포맷), 에러 로그 분리  
   - 응답 시간/바이트/상태코드 메트릭

6) **HTTPS/TLS**  
   - Tiny 자체에 TLS까지 얹는 대신, **리버스 프록시(Nginx, Caddy)** 앞단 배치 권장

---

## 9) 테스트 시나리오

```bash
# 정적
curl -v http://127.0.0.1:8080/
curl -v http://127.0.0.1:8080/style.css

# 동적 (GET/POST)
curl -v "http://127.0.0.1:8080/cgi-bin/adder?x=10&y=20"
curl -v -X POST -d "x=7&y=8" http://127.0.0.1:8080/cgi-bin/adder

# 잘못된 경로/권한
curl -v http://127.0.0.1:8080/../../etc/passwd
```

---

## 10) 자주 묻는 질문(FAQ)

- **Q. 왜 RIO를 쓰나요?**  
  A. `read`/`write`는 **부분 I/O**와 `EINTR` 문제가 있습니다. RIO 래퍼는 이를 숨겨 **견고성**을 높입니다.

- **Q. sendfile vs mmap vs read/write?**  
  A. Linux에선 정적 전송에 **`sendfile`**이 가장 간단·효율적(제로카피). 이식성 필요하면 `mmap` 또는 큰 버퍼로 `read/write`.

- **Q. CGI 대신 현대적 방법?**  
  A. 학습용은 CGI가 좋습니다. 실무는 **FastCGI/SCGI/WSGI/Rack/ASGI** 혹은 **리버스 프록시+애플리케이션 서버** 조합이 일반적.

---

## 11) 마무리

이 Tiny 서버는 **파일 I/O, 소켓, 프로세스, 환경 변수, 보안/캐시 기본**을 모두 훑는 **시스템 프로그래밍 종합 연습**입니다.  
여기에 **keep-alive, 스레드 풀, epoll**을 더하면 학습용에서 **실전형 마이크로 서버**로 성장시킬 수 있습니다.
