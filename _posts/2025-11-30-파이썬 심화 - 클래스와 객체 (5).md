---
layout: post
title: 파이썬 심화 - 클래스와 객체 (5)
date: 2025-11-30 19:25:23 +0900
category: 파이썬 심화
---
# 클래스와 객체 (5)

파이썬에서 클래스를 설계할 때 여러 고급 기법을 활용하면 더 유연하고 강력한 코드를 작성할 수 있습니다. 생성자 오버로딩부터 믹스인, 상태 패턴에 이르기까지 다양한 기법들을 실제 사용 예시와 함께 상세히 알아보겠습니다.

## 1. 다양한 생성자 정의 방법

파이썬은 다른 언어와 달리 공식적으로 생성자 오버로딩을 지원하지 않지만, 클래스 메서드와 타입 힌트를 활용하여 여러 방식으로 객체를 생성할 수 있습니다.

### 1.1 `@classmethod`를 활용한 대체 생성자

```python
class Vector:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y
    
    @classmethod
    def from_polar(cls, radius: float, angle: float) -> 'Vector':
        """극좌표(r, θ)에서 직교좌표(x, y)로 변환하여 인스턴스 생성"""
        import math
        x = radius * math.cos(angle)
        y = radius * math.sin(angle)
        return cls(x, y)
    
    @classmethod
    def from_single_value(cls, value: float) -> 'Vector':
        """동일한 값으로 x, y를 설정하여 인스턴스 생성"""
        return cls(value, value)

# 다양한 방식으로 인스턴스 생성
v1 = Vector(3, 4)                    # 기본 생성자
v2 = Vector.from_polar(5, 0.6435)    # 극좌표를 이용한 생성
v3 = Vector.from_single_value(10)    # 단일 값으로 생성
```

### 1.2 `__new__` 메서드를 활용한 유연한 인스턴스 생성

`__init__`을 호출하지 않고도 인스턴스를 생성할 수 있으며, 이는 불변 객체나 싱글톤 패턴 구현 시 유용합니다.

```python
class DatabaseConnection:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """싱글톤 패턴 구현 - 이미 인스턴스가 있으면 새로 생성하지 않고 반환"""
        if cls._instance is None:
            print("새로운 데이터베이스 연결 생성")
            cls._instance = super().__new__(cls)
            # 여기서 초기화를 수행할 수 있지만 __init__은 호출되지 않음
            cls._instance.initialized = False
        return cls._instance
    
    def __init__(self, connection_string: str):
        """__new__에서 인스턴스가 반환된 후 호출됨"""
        if not self.initialized:
            self.connection_string = connection_string
            self.initialized = True
            print(f"데이터베이스 연결 초기화: {connection_string}")

# 동일한 인스턴스가 반환됨
db1 = DatabaseConnection("mysql://localhost:3306/mydb")
db2 = DatabaseConnection("mysql://localhost:3306/otherdb")
print(f"db1 is db2: {db1 is db2}")  # True
```

### 1.3 데이터 클래스를 활용한 간결한 생성자

Python 3.7부터 도입된 `dataclass` 데코레이터를 사용하면 보일러플레이트 코드를 줄이면서 다양한 생성 옵션을 제공할 수 있습니다.

```python
from dataclasses import dataclass, field
from typing import List, Optional
import json

@dataclass
class UserProfile:
    username: str
    email: str
    age: Optional[int] = None
    tags: List[str] = field(default_factory=list)
    
    @classmethod
    def from_json(cls, json_str: str) -> 'UserProfile':
        """JSON 문자열에서 UserProfile 인스턴스 생성"""
        data = json.loads(json_str)
        return cls(**data)
    
    @classmethod
    def create_guest(cls) -> 'UserProfile':
        """게스트 사용자 프로필 생성"""
        return cls(username="guest", email="guest@example.com")

# 사용 예시
user1 = UserProfile("john_doe", "john@example.com", 30, ["python", "webdev"])
user2 = UserProfile.from_json('{"username": "jane", "email": "jane@example.com"}')
guest = UserProfile.create_guest()
```

## 2. 믹스인(Mixin)을 활용한 클래스 확장

믹스인은 작은 기능 단위를 독립적으로 정의하여 여러 클래스에서 재사용할 수 있게 해주는 디자인 패턴입니다. 상속과는 달리 "포함"의 개념에 가깝습니다.

### 2.1 기본 믹스인 패턴

```python
class JSONSerializableMixin:
    """JSON 직렬화 기능을 제공하는 믹스인"""
    
    def to_json(self) -> str:
        import json
        return json.dumps(self.__dict__, default=str, indent=2)
    
    @classmethod
    def from_json(cls, json_str: str):
        data = json.loads(json_str)
        return cls(**data)


class LoggableMixin:
    """로깅 기능을 제공하는 믹스인"""
    
    def log(self, message: str):
        import logging
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(self.__class__.__name__)
        logger.info(f"{self.__class__.__name__}: {message}")


class TimestampMixin:
    """생성 및 수정 시간 추적 기능을 제공하는 믹스인"""
    
    def __init__(self, *args, **kwargs):
        import datetime
        super().__init__(*args, **kwargs)
        self.created_at = datetime.datetime.now()
        self.updated_at = datetime.datetime.now()
    
    def update_timestamp(self):
        self.updated_at = datetime.datetime.now()
```

### 2.2 믹스인 조합을 통한 클래스 생성

```python
class Product(JSONSerializableMixin, LoggableMixin):
    def __init__(self, name: str, price: float, category: str):
        self.name = name
        self.price = price
        self.category = category
        self.log(f"제품 '{name}' 생성됨")
    
    def apply_discount(self, percentage: float):
        self.price *= (1 - percentage / 100)
        self.log(f"할인 적용: {percentage}% -> 새 가격: {self.price}")
        self.update_timestamp() if hasattr(self, 'update_timestamp') else None


class User(JSONSerializableMixin, TimestampMixin):
    def __init__(self, username: str, email: str):
        super().__init__()  # TimestampMixin의 __init__ 호출
        self.username = username
        self.email = email


# 사용 예시
product = Product("노트북", 1500000, "전자기기")
print(product.to_json())

user = User("홍길동", "gildong@example.com")
print(f"생성 시간: {user.created_at}")
```

### 2.3 다중 상속과 메서드 결정 순서(MRO)

믹스인을 사용할 때는 Python의 MRO(Method Resolution Order)를 이해하는 것이 중요합니다.

```python
class Base:
    def method(self):
        print("Base.method")

class MixinA:
    def method(self):
        print("MixinA.method")
        super().method()

class MixinB:
    def method(self):
        print("MixinB.method")
        super().method()

class MyClass(MixinA, MixinB, Base):
    pass

obj = MyClass()
obj.method()
# 출력:
# MixinA.method
# MixinB.method
# Base.method

print(MyClass.__mro__)
# (<class '__main__.MyClass'>, <class '__main__.MixinA'>, 
#  <class '__main__.MixinB'>, <class '__main__.Base'>, <class 'object'>)
```

## 3. 상태 패턴 구현

상태 패턴은 객체의 내부 상태가 변경될 때 객체의 행동이 변화하도록 하는 디자인 패턴입니다. 복잡한 조건문을 제거하고 상태 전이를 명확하게 표현할 수 있습니다.

### 3.1 기본 상태 패턴 구현

```python
from abc import ABC, abstractmethod
from typing import Optional


class OrderState(ABC):
    """상태 인터페이스"""
    
    @abstractmethod
    def add_item(self, order: 'Order', item: str) -> None:
        pass
    
    @abstractmethod
    def remove_item(self, order: 'Order', item: str) -> None:
        pass
    
    @abstractmethod
    def checkout(self, order: 'Order') -> None:
        pass
    
    @abstractmethod
    def pay(self, order: 'Order') -> None:
        pass
    
    @abstractmethod
    def cancel(self, order: 'Order') -> None:
        pass


class ShoppingState(OrderState):
    """쇼핑 중 상태"""
    
    def add_item(self, order: 'Order', item: str) -> None:
        order.items.append(item)
        print(f"상품 추가: {item}. 현재 {len(order.items)}개 상품")
    
    def remove_item(self, order: 'Order', item: str) -> None:
        if item in order.items:
            order.items.remove(item)
            print(f"상품 제거: {item}. 남은 {len(order.items)}개 상품")
    
    def checkout(self, order: 'Order') -> None:
        if order.items:
            order.set_state(CheckedOutState())
            print("주문이 체크아웃 상태로 변경되었습니다.")
        else:
            print("상품이 없습니다. 상품을 추가해주세요.")
    
    def pay(self, order: 'Order') -> None:
        print("체크아웃 후 결제가 가능합니다.")
    
    def cancel(self, order: 'Order') -> None:
        order.items.clear()
        print("쇼핑이 취소되었습니다.")


class CheckedOutState(OrderState):
    """체크아웃 완료 상태"""
    
    def add_item(self, order: 'Order', item: str) -> None:
        print("체크아웃 후 상품 추가가 불가능합니다. 주문을 취소하고 다시 시작하세요.")
    
    def remove_item(self, order: 'Order', item: str) -> None:
        print("체크아웃 후 상품 제거가 불가능합니다. 주문을 취소하고 다시 시작하세요.")
    
    def checkout(self, order: 'Order') -> None:
        print("이미 체크아웃 되었습니다.")
    
    def pay(self, order: 'Order') -> None:
        order.set_state(PaidState())
        print("결제가 완료되었습니다. 주문이 처리 중입니다.")
    
    def cancel(self, order: 'Order') -> None:
        order.set_state(CancelledState())
        order.items.clear()
        print("주문이 취소되었습니다.")


class PaidState(OrderState):
    """결제 완료 상태"""
    
    def add_item(self, order: 'Order', item: str) -> None:
        print("결제 후 상품 추가가 불가능합니다.")
    
    def remove_item(self, order: 'Order', item: str) -> None:
        print("결제 후 상품 제거가 불가능합니다.")
    
    def checkout(self, order: 'Order') -> None:
        print("이미 결제가 완료되었습니다.")
    
    def pay(self, order: 'Order') -> None:
        print("이미 결제가 완료되었습니다.")
    
    def cancel(self, order: 'Order') -> None:
        order.set_state(CancelledState())
        print("주문이 취소되었습니다. 환불 절차를 시작합니다.")


class CancelledState(OrderState):
    """취소 상태"""
    
    def add_item(self, order: 'Order', item: str) -> None:
        print("취소된 주문입니다. 새 주문을 시작해주세요.")
    
    def remove_item(self, order: 'Order', item: str) -> None:
        print("취소된 주문입니다.")
    
    def checkout(self, order: 'Order') -> None:
        print("취소된 주문입니다.")
    
    def pay(self, order: 'Order') -> None:
        print("취소된 주문입니다.")
    
    def cancel(self, order: 'Order') -> None:
        print("이미 취소된 주문입니다.")
```

### 3.2 컨텍스트 클래스 구현

```python
class Order:
    """주문 컨텍스트 클래스"""
    
    def __init__(self):
        self.items = []
        self._state: Optional[OrderState] = ShoppingState()
        self.order_id = id(self)
    
    def set_state(self, state: OrderState) -> None:
        """상태 변경 메서드"""
        self._state = state
    
    def add_item(self, item: str) -> None:
        if self._state:
            self._state.add_item(self, item)
    
    def remove_item(self, item: str) -> None:
        if self._state:
            self._state.remove_item(self, item)
    
    def checkout(self) -> None:
        if self._state:
            self._state.checkout(self)
    
    def pay(self) -> None:
        if self._state:
            self._state.pay(self)
    
    def cancel(self) -> None:
        if self._state:
            self._state.cancel(self)
    
    def get_status(self) -> str:
        return self._state.__class__.__name__ if self._state else "Unknown"
```

### 3.3 상태 패턴 사용 예시

```python
def demonstrate_state_pattern():
    """상태 패턴 데모"""
    order = Order()
    
    print("=== 쇼핑 시작 ===")
    order.add_item("노트북")
    order.add_item("마우스")
    order.remove_item("마우스")
    
    print(f"\n현재 상태: {order.get_status()}")
    
    print("\n=== 체크아웃 시도 (상품 없음) ===")
    temp_order = Order()
    temp_order.checkout()  # 실패: 상품 없음
    
    print("\n=== 정상 주문 흐름 ===")
    order.checkout()  # 성공
    print(f"현재 상태: {order.get_status()}")
    
    print("\n=== 결제 ===")
    order.pay()
    print(f"현재 상태: {order.get_status()}")
    
    print("\n=== 취소 시도 ===")
    order.cancel()
    print(f"현재 상태: {order.get_status()}")

# 실행
demonstrate_state_pattern()
```

## 4. 상태 기계 구현

상태 기계는 유한한 상태들 사이의 전이를 체계적으로 관리하는 모델입니다. 복잡한 비즈니스 로직을 명확하게 표현할 수 있습니다.

### 4.1 유한 상태 기계 구현

```python
from enum import Enum
from typing import Dict, Callable, Optional, Any


class State(Enum):
    IDLE = "대기"
    PROCESSING = "처리 중"
    PAUSED = "일시 정지"
    COMPLETED = "완료"
    ERROR = "오류"


class Transition:
    """상태 전이 정보 클래스"""
    
    def __init__(self, from_state: State, to_state: State, condition: Optional[Callable] = None):
        self.from_state = from_state
        self.to_state = to_state
        self.condition = condition or (lambda: True)
    
    def is_valid(self, context: Any) -> bool:
        """전이 조건 검증"""
        return self.condition(context)


class FiniteStateMachine:
    """유한 상태 기계"""
    
    def __init__(self, initial_state: State = State.IDLE):
        self.current_state = initial_state
        self.transitions: Dict[State, Dict[str, Transition]] = {}
        self.state_handlers: Dict[State, Callable] = {}
        self.context = {}
    
    def add_transition(self, transition: Transition, trigger: str) -> None:
        """전이 추가"""
        if transition.from_state not in self.transitions:
            self.transitions[transition.from_state] = {}
        self.transitions[transition.from_state][trigger] = transition
    
    def add_state_handler(self, state: State, handler: Callable) -> None:
        """상태 진입 핸들러 추가"""
        self.state_handlers[state] = handler
    
    def trigger(self, trigger: str) -> bool:
        """전이 트리거"""
        if self.current_state not in self.transitions:
            return False
        
        if trigger not in self.transitions[self.current_state]:
            print(f"현재 상태 {self.current_state.value}에서 {trigger} 전이가 불가능합니다.")
            return False
        
        transition = self.transitions[self.current_state][trigger]
        
        if not transition.is_valid(self.context):
            print(f"전이 조건을 만족하지 않습니다.")
            return False
        
        # 상태 전이
        old_state = self.current_state
        self.current_state = transition.to_state
        
        print(f"상태 전이: {old_state.value} -> {self.current_state.value} (트리거: {trigger})")
        
        # 상태 진입 핸들러 실행
        if self.current_state in self.state_handlers:
            self.state_handlers[self.current_state](self.context)
        
        return True
    
    def get_current_state(self) -> State:
        return self.current_state
```

### 4.2 상태 기계 사용 예시: 문서 처리 시스템

```python
def create_document_processor_fsm():
    """문서 처리 상태 기계 생성"""
    fsm = FiniteStateMachine(initial_state=State.IDLE)
    
    # 상태 핸들러 정의
    def on_idle(context):
        print("시스템이 대기 상태입니다. 문서를 업로드하세요.")
    
    def on_processing(context):
        print("문서를 처리 중입니다...")
        # 실제 처리 로직이 여기에 위치
    
    def on_paused(context):
        print("처리가 일시 정지되었습니다.")
    
    def on_completed(context):
        print(f"문서 처리가 완료되었습니다. 결과: {context.get('result', 'N/A')}")
    
    def on_error(context):
        print(f"오류 발생: {context.get('error', '알 수 없는 오류')}")
    
    # 핸들러 등록
    fsm.add_state_handler(State.IDLE, on_idle)
    fsm.add_state_handler(State.PROCESSING, on_processing)
    fsm.add_state_handler(State.PAUSED, on_paused)
    fsm.add_state_handler(State.COMPLETED, on_completed)
    fsm.add_state_handler(State.ERROR, on_error)
    
    # 전이 정의
    fsm.add_transition(Transition(State.IDLE, State.PROCESSING, 
                                 lambda ctx: 'document' in ctx), 'upload')
    fsm.add_transition(Transition(State.PROCESSING, State.PAUSED), 'pause')
    fsm.add_transition(Transition(State.PROCESSING, State.COMPLETED,
                                 lambda ctx: ctx.get('processing_success', False)), 'complete')
    fsm.add_transition(Transition(State.PROCESSING, State.ERROR,
                                 lambda ctx: ctx.get('has_error', False)), 'error')
    fsm.add_transition(Transition(State.PAUSED, State.PROCESSING), 'resume')
    fsm.add_transition(Transition(State.PAUSED, State.IDLE), 'cancel')
    fsm.add_transition(Transition(State.ERROR, State.IDLE), 'reset')
    fsm.add_transition(Transition(State.COMPLETED, State.IDLE), 'reset')
    
    return fsm


def demonstrate_state_machine():
    """상태 기계 데모"""
    fsm = create_document_processor_fsm()
    
    # 초기 상태 실행
    fsm.state_handlers[fsm.get_current_state()](fsm.context)
    
    print("\n=== 문서 업로드 ===")
    fsm.context['document'] = 'sample.pdf'
    fsm.trigger('upload')
    
    print("\n=== 일시 정지 ===")
    fsm.trigger('pause')
    
    print("\n=== 재개 ===")
    fsm.trigger('resume')
    
    print("\n=== 처리 완료 ===")
    fsm.context['processing_success'] = True
    fsm.context['result'] = '변환 완료'
    fsm.trigger('complete')
    
    print("\n=== 시스템 초기화 ===")
    fsm.trigger('reset')

# 실행
demonstrate_state_machine()
```

## 결론

파이썬에서 클래스를 설계할 때 다양한 고급 기법을 활용하면 코드의 재사용성, 유지보수성, 확장성을 크게 향상시킬 수 있습니다. 클래스 메서드를 통한 다양한 생성자 패턴, 믹스인을 활용한 기능의 모듈화, 상태 패턴을 통한 복잡한 상태 관리 등은 현실적인 문제를 해결하는 데 효과적입니다. 이러한 패턴들을 적절히 조합하고 상황에 맞게 적용함으로써 더 깔끔하고 효율적인 객체지향 코드를 작성할 수 있습니다. 실제 프로젝트에서는 이러한 패턴들을 상황에 맞게 변형하고 조합하여 최적의 솔루션을 구현하는 것이 중요합니다.