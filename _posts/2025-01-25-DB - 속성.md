---
layout: post
title: DB - 속성
date: 2025-01-25 21:20:23 +0900
category: DB
---
# 속성(Attribute)

## 리마인드(핵심 요약)

- **속성(Attribute)**은 엔터티의 성질을 나타내는 **최소 단위**이며, **단일값·원자성**을 충족해야 한다.
- 속성은 **도메인(자료형/범위/제약/기본값/컬레이션)**으로 관리하며, **주식별자에 함수적으로 종속**되어야 한다.
- **다중값·복합값**은 테이블/하위 속성으로 분해하고, **코드성 값**은 **참조 테이블(코드 테이블)**로 관리한다.
- **파생속성**은 가급적 **계산**으로 처리하고 저장을 최소화한다(정합성).
- 명명 규칙·NULL 철학·제약 일관성·국제화·감사/템포럴까지 포함해 **전주기 품질**을 설계한다.

---

## 속성의 정의와 수학적 기반 (FD로 보는 정합성)

**정의**: 엔터티의 특정한 특징을 표현하는 최소 단위.
**단일값**: 하나의 속성에 하나의 값만.
**원자성**: 더 이상 분해할 수 없을 때까지 쪼개기.

**함수적 종속(Functional Dependency)** 관점에서, 모든 비주요 속성 \(A\)는 기본키 \(K\)에만 종속되어야 한다:
$$
K \to A \quad\text{and}\quad \nexists\, B \not\subseteq K \text{ s.t. } B \to A
$$
이를 어기면 **이행 종속/부분 종속**이 발생하며, 갱신 이상이 생긴다.

---

## 요구사항에서 속성 뽑아내기(현업-친화 절차)

1) **업무 용어 사전** 만들기: “고객명/대표자명/수신자명”을 혼용하지 않도록 정의.
2) **폼·화면·보고서**에서 입력/출력 항목을 수집(실제 사용되는 속성 목록).
3) 항목을 **원자화/정규화**: “주소(전체)” → “국가/우편번호/시/구/도로/상세”.
4) **다중값 탐지**: “전화1/전화2” → `customer_phone` 테이블로 분리.
5) **코드성 값** 분리: 국가/통화/직급 등은 코드 테이블 참조.
6) **파생/설계 속성** 태깅: “나이(파생)”, “일련번호(설계)”.

---

## 분류의 확장판: 존재·값·역할·생애주기

### 존재 유형

- **기본속성**: 업무 입력(이름, 생년월일).
- **파생속성**: 계산 가능(나이=오늘-생년월일).
- **설계속성**: 시스템 제약을 위한 기술적 속성(내부 ID, 정렬 키, 해시).

### 값 유형

- **단일값**: 이메일, 주민등록번호.
- **다중값**: 전화번호(여러 개) → 별도 엔터티 분해.
- **복합**: 주소 → 하위 속성으로 분해(원자화).

### 역할

- **식별자**: PK 후보, 유일성 제공(주문번호).
- **일반**: 설명적(이름, 금액).
- **코드**: 표준 코드값(국가코드, 통화코드).
- **상태**: 진행/활성여부/단계.

### 생애주기 메타

- **생성자/생성시각/수정자/수정시각**
- **유효기간(시작/종료)**: 템포럴/정책 적용.

---

## 도메인(Domain) 설계: 타입·제약·컬레이션

도메인은 **자료형/길이/NULL/UNIQUE/CHECK/DEFAULT/컬레이션/코멘트**를 포함한 속성의 계약이다.

### 예시: 고객 이메일 도메인

- 타입: `TEXT` 또는 `VARCHAR(320)`
- 컬레이션: 이메일 로컬파트의 대소문자 처리 정책 결정(서버/비즈니스 합의)
- 제약: NOT NULL, UNIQUE, 포맷 체크(엄격한 RFC 정합성은 애플리케이션/정규식/라이브러리로)

```sql
CREATE DOMAIN email_text AS TEXT
  CHECK (value ~ '^[^@\s]+@[^@\s]+\.[^@\s]+$'); -- 단순 예시, 실제 RFC는 훨씬 복잡
```

### 금액/통화 도메인

```sql
CREATE DOMAIN money_amount AS NUMERIC(12,2) CHECK (VALUE >= 0);
CREATE TABLE currency_code (
  code CHAR(3) PRIMARY KEY, -- ISO 4217
  name TEXT NOT NULL
);
```

### 전화번호 도메인(E.164)

```sql
CREATE DOMAIN phone_e164 AS TEXT
  CHECK (value ~ '^\+[1-9]\d{6,14}$'); -- + country + NSN
```

### 날짜/시간

- 저장은 가급적 **UTC**(TIMESTAMPTZ). 표시 시 사용자 타임존 변환.
- **기간 속성**은 `start_at < end_at` 체크.

```sql
ALTER TABLE subscription
  ADD CONSTRAINT ck_period CHECK (end_at IS NULL OR end_at > start_at);
```

---

## 명명 규칙과 NULL 철학

- **단수형** 명사 사용(`customer`, `order_item`), 팀 표준을 문서화.
- 단위 명시(`price_cents`, `weight_kg`).
- **NULL 철학**: “미정/불명/적용불가” 의미를 분리. “값 없음”과 “0/빈 문자열”을 혼동하지 않기.

---

## 속성 설계 안티패턴 → 개선

| 안티패턴 | 문제 | 개선 |
|---|---|---|
| `phone1`, `phone2` | 다중값을 열로 표현, 무제한 확장 불가 | `customer_phone` 엔터티 |
| `address` 단일 문자열 | 원자성 위배, 검색/통계 불능 | 시/구/도로/우편번호 분해 |
| `age` 저장 | 날짜 경과로 오염 | `birth_date` 저장, 계산으로 제공 |
| 하드코딩 코드값 | 변경/다국어 미대응 | 코드 테이블 참조 |
| `status` 자유 텍스트 | 값 오염, 오타 | ENUM 또는 코드 테이블 + CHECK |

---

## 실무 예제: 고객/전화/주소/이메일/코드

```sql
-- 코드성 값: 국가/통화/언어
CREATE TABLE country_code (
  code CHAR(2) PRIMARY KEY, -- ISO 3166-1 alpha-2
  name TEXT NOT NULL
);

CREATE TABLE currency_code (
  code CHAR(3) PRIMARY KEY, -- ISO 4217
  name TEXT NOT NULL
);

CREATE TABLE language_code (
  code TEXT PRIMARY KEY, -- e.g., 'ko-KR', 'en-US'
  name TEXT NOT NULL
);

-- 고객
CREATE TABLE customer (
  customer_id   BIGSERIAL PRIMARY KEY,
  email         TEXT NOT NULL UNIQUE,
  name          TEXT NOT NULL,
  birth_date    DATE,
  preferred_lang TEXT REFERENCES language_code(code),
  created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 고객 전화(다중값)
CREATE TABLE customer_phone (
  phone_id     BIGSERIAL PRIMARY KEY,
  customer_id  BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE CASCADE,
  phone        TEXT NOT NULL,  -- E.164 도메인 적용 가능
  is_primary   BOOLEAN NOT NULL DEFAULT FALSE,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (customer_id, phone)
);
CREATE UNIQUE INDEX uq_customer_primary_phone
  ON customer_phone(customer_id)
  WHERE is_primary;

-- 고객 주소(복합 → 원자화)
CREATE TABLE customer_address (
  address_id    BIGSERIAL PRIMARY KEY,
  customer_id   BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE CASCADE,
  country_code  CHAR(2) NOT NULL REFERENCES country_code(code),
  postal_code   TEXT NOT NULL,
  region        TEXT,       -- 시/도
  city          TEXT,       -- 시/군/구
  street_line1  TEXT NOT NULL,
  street_line2  TEXT,
  is_default    BOOLEAN NOT NULL DEFAULT FALSE,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE UNIQUE INDEX uq_customer_default_addr
  ON customer_address(customer_id) WHERE is_default;
```

---

## 속성의 선택도(Cardinality)와 인덱싱

**속성 카디널리티(서로 다른 값의 수)**는 인덱스 효율과 직결된다.
- **고카디널리티**(이메일, 주민번호): 인덱스 효율 좋음.
- **저카디널리티**(Y/N 상태): 단독 인덱스 이점 낮음 → **부분 인덱스/복합 인덱스** 고려.

```sql
-- 상태=ACTIVE만 자주 조회
CREATE INDEX idx_user_active
  ON app_user(user_id) WHERE status = 'ACTIVE';

-- 날짜+상태 복합 (필터 후 정렬)
CREATE INDEX idx_order_status_dt
  ON "order"(status, ordered_at DESC);
```

히스토그램(통계) 갱신이 중요하다. 오래된 통계는 잘못된 계획을 유발한다.

---

## 컬레이션/정렬/대소문자

- 이름/주소 정렬은 **로케일 컬레이션**에 영향.
- 이메일 유니크는 **대소문자 정책**을 명확히(일반적으로 도메인 부분은 case-insensitive).
- DB별로 컬레이션/`CITEXT`(대소문자 구분 없는 텍스트) 타입을 검토.

```sql
-- 예: PostgreSQL CITEXT 활용(확장 필요)
-- CREATE EXTENSION citext;
ALTER TABLE customer ALTER COLUMN email TYPE citext;
```

---

## 파생속성의 설계: 저장 vs 계산

- **기본 원칙**: 계산 가능·저비용 → **계산**으로 제공(뷰/계산식/가상 컬럼).
- **예외**: 성능상 이득이 크거나 외부 요건(스냅샷/감사)이 있으면 저장 + 동기화.

```sql
-- 뷰로 파생 제공: 나이(러프)
CREATE VIEW v_customer_age AS
SELECT customer_id, name,
       DATE_PART('year', AGE(CURRENT_DATE, birth_date)) AS age_years
FROM customer;

-- 가상/생성 컬럼(엔진별 상이) 예시
-- age_years GENERATED ALWAYS AS (...) STORED/VIRTUAL
```

---

## 템포럴 속성/유효기간/배타 제약

기간 속성 \( [s, e) \) 겹침 금지 조건:
$$
e_1 \le s_2 \ \lor\ e_2 \le s_1
$$

```sql
-- 직원-부서 배치(기간 겹침 금지)
CREATE TABLE employee_dept (
  emp_id     BIGINT NOT NULL,
  dept_id    BIGINT NOT NULL,
  start_at   DATE   NOT NULL,
  end_at     DATE,
  PRIMARY KEY (emp_id, dept_id, start_at),
  CHECK (end_at IS NULL OR end_at > start_at),
  FOREIGN KEY (emp_id) REFERENCES employee(emp_id),
  FOREIGN KEY (dept_id) REFERENCES department(dept_id)
);

/* DB 지원 시 Exclusion Constraint로 겹침 차단(예: PostgreSQL)
   EXCLUDE USING gist (
     emp_id WITH =,
     daterange(start_at, COALESCE(end_at,'infinity'::date)) WITH &&
   );
*/
```

---

## 상태/코드 속성: ENUM vs 코드 테이블

| 방식 | 장점 | 단점 | 권장 |
|---|---|---|---|
| ENUM | 빠르고 간결 | 변경·다국어·메타 열람 불편 | 작은 폐쇄 집합 |
| 코드 테이블 | 확장·다국어 용이 | 조인 필요 | 일반적 권장 |

```sql
CREATE TABLE order_status_code (
  code TEXT PRIMARY KEY,     -- 'PENDING','PAID','CANCELLED',...
  label TEXT NOT NULL,
  sort_order INT NOT NULL
);
ALTER TABLE "order"
  ADD CONSTRAINT fk_status
  FOREIGN KEY (status) REFERENCES order_status_code(code);
```

---

## 국제화 속성 가이드(주소/전화/이름)

- **주소**: 국가별 포맷 상이. 하드 포맷 강제보다 **원자화 + 자유 텍스트 보조 필드** 병행.
- **전화**: E.164 저장(+821012345678) + 표시 포맷은 애플리케이션에서.
- **이름**: 성/이름 분리 여부를 국가에 맞게 설계(필요하면 `full_name` 보조).

---

## JSON/반정규화 속성의 사용 기준

- **빈번한 스키마 변경/희소 필드/로그형 데이터**에 유리.
- 조인/조건/인덱싱 필요 여부가 높아지면 **정규 열**로 승격.
- **하이브리드**: 핵심 질의 필드는 정규화, 드물게 쓰는 확장 필드는 JSON.

```sql
CREATE TABLE product (
  product_id BIGSERIAL PRIMARY KEY,
  sku TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  price NUMERIC(12,2) NOT NULL,
  attributes JSONB, -- 희소/확장 속성
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 흔히 조회하는 키에 GIN 인덱스/경로 인덱스를 둘 수 있음(DB별 기능 상이)
-- CREATE INDEX ON product USING GIN (attributes);
```

---

## 품질 점검 SQL(진단/회귀 테스트)

```sql
-- 1) 고아 속성(부모 없는 FK) 탐지
SELECT a.address_id
FROM customer_address a
LEFT JOIN customer c ON c.customer_id = a.customer_id
WHERE c.customer_id IS NULL;

-- 2) 다중값 중복(전화번호 중복 등록) 탐지
SELECT customer_id, phone, COUNT(*) cnt
FROM customer_phone
GROUP BY customer_id, phone
HAVING COUNT(*) > 1;

-- 3) 값 범위 위반 후보(금액 음수)
SELECT *
FROM invoice
WHERE amount < 0;

-- 4) 이메일 포맷(단순) 위반
SELECT customer_id, email
FROM customer
WHERE email !~ '^[^@\s]+@[^@\s]+\.[^@\s]+$';

-- 5) 기간 겹침 후보
SELECT a.emp_id, a.dept_id, a.start_at, a.end_at,
       b.start_at AS start2, b.end_at AS end2
FROM employee_dept a
JOIN employee_dept b
  ON a.emp_id = b.emp_id AND a.dept_id = b.dept_id
 AND a.start_at < COALESCE(b.end_at, '9999-12-31')
 AND b.start_at < COALESCE(a.end_at, '9999-12-31')
 AND (a.emp_id, a.dept_id, a.start_at) <> (b.emp_id, b.dept_id, b.start_at);
```

---

## 성능을 위한 속성 설계 디테일

- **가변 길이** 텍스트는 너무 작은 길이 제한으로 잘리지 않게 하고, 필요 시 **길이 체크**를 애플리케이션에서.
- **숫자 스케일/정밀도** 미스매치 방지(NUMERIC vs BIGINT 센트 단위).
- **인덱스 선정**: 선택도 높은 속성부터, WHERE/ORDER/GROUP 사용 패턴 기준으로 복합 인덱스 구성.
- **통계 갱신/실행계획 회귀 모니터링**을 자동화.

---

## SCD/템포럴: 속성 변경 이력 추적

### SCD Type 2(차원 이력)

```sql
CREATE TABLE dim_customer (
  sk_customer    BIGSERIAL PRIMARY KEY,
  customer_id    BIGINT NOT NULL,
  name           TEXT NOT NULL,
  email          TEXT NOT NULL,
  effective_from DATE NOT NULL,
  effective_to   DATE,
  is_current     BOOLEAN NOT NULL,
  UNIQUE(customer_id, effective_from)
);

-- 시점 질의: 2025-11-01 당시 이메일
SELECT email
FROM dim_customer
WHERE customer_id = 100
  AND effective_from <= DATE '2025-11-01'
  AND (effective_to IS NULL OR effective_to > DATE '2025-11-01');
```

### 시스템 버전(엔진 제공 기능)

- 일부 DB는 시스템 버전 테이블을 제공(자동 이력).
- 감사/복구/회계 도메인에 유용.

---

## 마이그레이션: 속성 변경의 안전 절차

1) **새 속성 추가**(NULL 허용/기본값), 데이터 백필 백그라운드 작업.
2) 애플리케이션 **읽기→쓰기** 순으로 새 속성 사용 전환.
3) 구 속성 사용 중지/드롭(락·다운타임 최소화).
4) 롤백 경로 문서화(트랜잭션/스냅샷).

```sql
-- 예: address 단일 문자열 → 원자화 컬럼 전환
ALTER TABLE customer_address ADD COLUMN postal_code TEXT;
ALTER TABLE customer_address ADD COLUMN region TEXT;
ALTER TABLE customer_address ADD COLUMN city TEXT;
ALTER TABLE customer_address ADD COLUMN street_line1 TEXT;
-- 백필 스크립트(애플리케이션/ETL에서 파싱), 이후 단일 문자열 제거
```

---

## 애플리케이션·ORM 연동

- **Lazy 기본** + 전용 조회(페치 조인)로 N+1 방지.
- **값 객체(Value Object)** 개념으로 주소/전화/금액을 캡슐화(검증·포맷 일원화).
- **입력 검증**: DB 제약 전 단계에서 포맷/도메인 검증으로 오류/락 비용 절감.

---

## 실습 세트(손에 잡히는 연습)

1) 연락수단 모델링: 이메일(단일), 전화(다중), 메신저 ID(선택).
2) 주소 파싱/원자화 vs 단일 문자열 성능 비교(검색/통계).
3) 상태/코드: ENUM vs 코드 테이블 AB 테스트(변경 빈도/다국어).
4) JSON 확장 필드 적용 → 조회 패턴 증가 시 정규화 승격.

---

## 종합 예제: 고객 도메인 확장 스키마 + 대표 질의

```sql
-- 고객 선호/동의 속성(상태/템포럴 조합)
CREATE TABLE customer_consent (
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE CASCADE,
  consent_type TEXT NOT NULL,       -- 'EMAIL_MARKETING','SMS_ALERT' 등 코드 테이블도 가능
  granted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  revoked_at TIMESTAMPTZ,
  PRIMARY KEY (customer_id, consent_type, granted_at),
  CHECK (revoked_at IS NULL OR revoked_at > granted_at)
);

-- 대표 질의 1: 기본 연락처(이메일 + 대표 전화 + 기본 주소)
WITH primary_phone AS (
  SELECT DISTINCT ON (customer_id)
    customer_id, phone
  FROM customer_phone
  WHERE is_primary
  ORDER BY customer_id, phone
),
default_addr AS (
  SELECT DISTINCT ON (customer_id)
    customer_id, country_code, postal_code, region, city, street_line1
  FROM customer_address
  WHERE is_default
  ORDER BY customer_id, address_id DESC
)
SELECT c.customer_id, c.name, c.email, p.phone,
       a.country_code, a.postal_code, a.region, a.city, a.street_line1
FROM customer c
LEFT JOIN primary_phone p ON p.customer_id = c.customer_id
LEFT JOIN default_addr a  ON a.customer_id = c.customer_id
ORDER BY c.customer_id
LIMIT 100;

-- 대표 질의 2: 특정 기간 유효 동의자(템포럴)
SELECT DISTINCT customer_id
FROM customer_consent
WHERE consent_type = 'EMAIL_MARKETING'
  AND granted_at <= NOW()
  AND (revoked_at IS NULL OR revoked_at > NOW();

-- 대표 질의 3: 전화번호 국가 분포(선택도/인덱싱 지표)
SELECT SUBSTRING(phone FROM 2 FOR 2) AS country_prefix, COUNT(*) cnt
FROM customer_phone
GROUP BY 1
ORDER BY cnt DESC;
```

---

## 결론

- **속성 설계**는 데이터 모델링의 가장 작은 단위이지만, **정합성·성능·운영·보안**의 출발점이다.
- **원자성/단일값/도메인/FD/제약**으로 의미를 고정하고, **국제화·템포럴·코드 테이블·JSON**을 맥락에 맞게 적용하라.
- 선택도/컬레이션/인덱스/통계까지 고려해 **현실 쿼리 패턴**에 최적화하라.
- 모델은 **살아있는 계약**이다. 마이그레이션·테스트·모니터링으로 지속 개선하라.
