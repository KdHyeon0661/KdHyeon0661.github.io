---
layout: post
title: DB - 속성
date: 2025-01-25 21:20:23 +0900
category: DB
---
# 🧩 속성(Attribute) – 엔터티를 구성하는 데이터의 최소 단위

**속성**은 엔터티(Entity)를 구성하는 가장 작은 정보 단위로,  
**업무상 관리할 필요가 있는 더 이상 분해되지 않는 단일한 데이터 요소**를 의미합니다.

예: 고객이라는 엔터티는 이름, 이메일, 전화번호 등의 속성으로 구성됩니다.

---

## 📌 1. 속성의 정의와 기본 원칙

| 항목 | 설명 |
|------|------|
| **정의** | 엔터티의 특정한 특징이나 성질을 나타내는 정보 단위 |
| **단일값 원칙(Single Value Rule)** | 하나의 속성에는 반드시 **하나의 값만** 존재해야 함 |
| **불가분성(Atomicity)** | 속성은 **더 이상 나눌 수 없는 최소 단위**여야 함 |

> 예: "주소" 속성을 "시/군/구, 도로명, 우편번호"로 분리 가능하면 개별 속성으로 정의해야 함  
> 예: "전화번호1, 전화번호2"로 속성을 구성하지 말고, 고객-전화번호 관계로 별도 테이블 분리해야 함

---

## 🧠 2. 속성, 인스턴스, 속성값 예시

| 개념 | 예시 |
|------|------|
| **엔터티(Entity)** | 고객(Customer) |
| **인스턴스(Instance)** | 고객 중 '홍길동' |
| **속성(Attribute)** | 이메일 |
| **속성값(Value)** | `hong@naver.com` |

→ 즉, **속성은 “어떤 인스턴스를 구성하는 요소의 명칭”이며, 그 값은 속성값입니다.**

---

## 🧱 3. 속성의 분류

### 📌 (1) 속성의 존재 유형 기준

| 유형 | 설명 | 예시 |
|------|------|------|
| **기본속성** | 업무적으로 존재하며 직접 입력되는 속성 | 이름, 생년월일 |
| **파생속성** | 다른 속성으로부터 계산되는 속성 | 나이 = 현재연도 - 생년월일 |
| **설계속성** | 업무에는 없지만 모델링 목적상 설계된 속성 | 일련번호, 시스템ID |

> 📌 파생속성은 중복성과 정합성 문제로 가능하면 계산으로 처리하고 **DB에 저장하지 않는 것을 권장**합니다.

---

### 📌 (2) 속성의 값 유형 기준

| 유형 | 설명 | 예시 |
|------|------|------|
| **단일값 속성** | 하나의 값만 가짐 | 이메일, 주민번호 |
| **다중값 속성** | 여러 개의 값을 가질 수 있음 (→ 별도 테이블 분리 필요) | 복수 전화번호 |
| **복합 속성** | 내부적으로 여러 하위 속성을 포함 | 주소 = (시, 구, 도로명, 우편번호) |

---

### 📌 (3) 속성의 역할 기준

| 역할 | 설명 | 예시 |
|------|------|------|
| **식별자 속성** | 엔터티의 유일성 보장을 위한 속성 | 사원ID, 주문번호 |
| **일반 속성** | 엔터티의 특성을 설명하는 보조 속성 | 이름, 부서, 금액 |
| **코드 속성** | 값을 코드화해서 관리하는 속성 | 국가코드, 부서코드 |
| **상태 속성** | 상태, 여부 등을 나타내는 속성 | 사용여부(Y/N), 진행상태 |

---

## 📘 4. 도메인(Domain)의 개념

**도메인**은 속성이 가질 수 있는 **값의 타입, 길이, 제약 조건의 집합**입니다.

- 자료형 (예: VARCHAR, INT, DATE 등)
- 제약조건 (예: NOT NULL, UNIQUE, CHECK 등)
- 유효 범위 (예: 0 ~ 100 사이의 값만 허용)
- 기본값 (Default Value)

> 📌 속성이 도메인을 통해 제어됨으로써, 데이터 무결성과 일관성이 보장됩니다.

---

## 🎯 5. 속성 설계 시 고려사항

| 항목 | 설명 |
|------|------|
| **함수적 종속(FD)** | 모든 속성은 반드시 **주식별자에 종속**되어야 함 |
| **중복 방지** | 같은 정보는 하나의 속성에서만 유지해야 함 (정규화) |
| **명확한 의미 부여** | 추상적 용어나 중복된 이름 사용 금지 |
| **명명 규칙** | 단수형 명사 사용, 약어 지양, 테이블 간 유일성 확보 |
| **코드 값 관리** | 코드성 속성은 반드시 **도메인 테이블(참조 엔터티)**로 관리 |
| **서술형 금지** | 긴 문장형 설명 대신 항목별 속성으로 세분화 |
| **파생속성 최소화** | 정합성 유지 어려움, 가급적 계산으로 처리 |

---

## 🧾 6. 실무에서의 코드성 속성 관리

- **국가코드, 직급코드, 통화코드** 등은 **Code Table**로 별도 관리
- 하드코딩 금지: 프런트/백엔드에서 직접 값을 넣지 말고 참조하도록 설계
- 코드 값은 설명 속성과 함께 관리: `('KR', '대한민국')`

```sql
CREATE TABLE CountryCode (
  Code CHAR(2) PRIMARY KEY,
  Name VARCHAR(100)
);
```

---

## 🔍 7. 잘못된 속성 설계 예시

| 잘못된 설계 | 개선 방향 |
|-------------|-----------|
| 하나의 속성에 여러 전화번호 입력 | → 고객-전화번호 엔터티 분리 |
| 속성 이름 중복 (모든 테이블에 'Name') | → 고객명, 제품명 등 구체화 |
| ‘주소’라는 속성에 전체 주소 문자열 | → 시/구/도로/우편번호 등으로 분리 |
| 파생속성 '나이'를 저장 | → 생년월일에서 계산으로 처리 |

---

## ✅ 정리

- 속성은 엔터티의 **구체적인 속성을 표현하는 최소 정보 단위**
- 항상 **단일값**, **함수적 종속**, **도메인 기반** 설계를 따라야 함
- 설계속성과 파생속성은 실무적으로 구분하여 사용하며, 코드값은 별도 관리
- 명명 규칙, 중복 방지, 무결성 유지 등은 속성 설계의 핵심 원칙

> 📌 속성 설계는 단순한 데이터 나열이 아니라, **정합성, 재사용성, 무결성**을 모두 만족해야 하는 **모델링의 기본기**입니다.