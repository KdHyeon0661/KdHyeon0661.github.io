---
layout: post
title: DB - 속성
date: 2025-01-25 21:20:23 +0900
category: DB
---
# 데이터베이스 속성 설계의 원리와 실무

## 핵심 개념 요약

**속성**은 데이터 모델에서 엔터티의 특성을 표현하는 가장 작은 단위입니다. 각 속성은 단일 값과 원자성을 가져야 하며, 정의된 도메인(데이터 타입, 범위, 제약 조건) 내에서 존재합니다. 모든 속성은 기본키에 함수적으로 종속되어야 하며, 이를 통해 데이터의 정합성과 무결성을 보장할 수 있습니다. 다중값이나 복합값은 적절히 분해하고, 코드성 값은 별도의 참조 테이블로 관리하는 것이 좋습니다. 파생 속성은 가능한 한 계산을 통해 제공하며, 명명 규칙, NULL 처리 정책, 국제화 요구사항까지 고려하여 전주기적 품질을 설계해야 합니다.

---

## 속성의 본질: 정의와 수학적 기반

속성은 엔터티를 구성하는 개별적인 특징이나 성질을 나타냅니다. 데이터 모델링에서의 핵심 원칙은 **단일값성**(하나의 속성에는 하나의 값만 저장)과 **원자성**(더 이상 의미 있는 단위로 분해할 수 없음)입니다.

이 개념은 **함수적 종속성**이라는 수학적 개념으로 엄격히 정의될 수 있습니다. 모든 비주요 속성(A)는 반드시 기본키(K)에만 종속되어야 합니다:
$$K \to A \quad\text{and}\quad \nexists\, B \not\subseteq K \text{ s.t. } B \to A$$

이 규칙을 위반하면 부분 종속이나 이행 종속이 발생하며, 이는 데이터 갱신 이상 현상(삽입, 삭제, 수정 시 불일치)을 초래합니다. 따라서 속성 설계의 첫걸음은 이러한 함수적 종속 관계를 명확히 이해하는 데서 시작합니다.

---

## 실무 속성 도출 방법론

요구사항에서 속성을 체계적으로 추출하는 과정은 다음과 같습니다:

1.  **업무 용어 사전 구축**: 동일한 개념에 대해 '고객명', '대표자명', '수신자명'과 같은 다양한 용어가 혼용되지 않도록 표준화된 용어를 정의합니다.
2.  **실제 산출물 분석**: 입력 폼, 화면 디자인, 보고서 등에서 실제로 사용되는 데이터 항목을 수집합니다. 이는 문서화된 요구사항보다 더 현실적인 속성 목록을 제공합니다.
3.  **항목의 원자화**: '주소(전체)'와 같은 복합 데이터는 '국가', '우편번호', '시', '구', '도로명', '상세주소'와 같이 검색과 통계에 활용 가능한 최소 단위로 분해합니다.
4.  **다중값 속성 식별**: '전화1', '전화2'와 같은 열 방식의 다중값은 별도의 `customer_phone` 테이블로 분리하여 무제한 확장과 체계적 관리를 가능하게 합니다.
5.  **코드성 값 분리**: 국가, 통화, 직급 등 제한된 집합의 값은 참조 테이블을 생성하여 유지보수성과 다국어 지원을 용이하게 합니다.
6.  **속성 유형 분류**: 각 속성이 '기본속성'(업무 입력), '파생속성'(계산 값), '설계속성'(시스템 필요) 중 어디에 해당하는지 태깅합니다.

---

## 속성의 다차원적 분류 체계

속성은 다양한 관점에서 분류되어 이해될 수 있으며, 이는 설계 결정에 중요한 통찰을 제공합니다.

*   **존재 유형에 따라**: 업무에서 직접 입력되는 **기본속성**(이름, 생년월일), 다른 값으로부터 계산되는 **파생속성**(나이), 시스템 운영을 위해 도입된 **설계속성**(내부 ID, 정렬 키)으로 구분됩니다.
*   **값의 특성에 따라**: 하나의 값만 가지는 **단일값 속성**, 여러 값을 가질 수 있어 별도 엔터티로 분해해야 하는 **다중값 속성**, 그리고 하위 구성 요소로 분해 가능한 **복합 속성**이 있습니다.
*   **역할에 따라**: 엔터티를 유일하게 식별하는 **식별자**, 업무적 의미를 설명하는 **일반 속성**, 표준화된 분류를 위한 **코드 속성**, 그리고 프로세스 진행 상황을 나타내는 **상태 속성**이 있습니다.
*   **생애주기 관리에 따라**: 데이터 생성 및 변경 이력을 추적하기 위한 `생성자`, `생성시각`, `수정자`, `수정시각`과 같은 메타 속성, 그리고 특정 정책이나 버전 관리를 위한 **유효기간**(시작일, 종료일) 속성이 포함됩니다.

---

## 체계적인 도메인 설계

도메인은 속성의 '계약'으로, 자료형, 길이, NULL 허용 여부, 유일성, 값 범위, 기본값, 정렬 규칙(컬레이션), 설명을 포괄적으로 정의합니다.

**금액과 통화의 도메인 설계 예시**
```sql
-- 금액은 음수가 될 수 없으며, 통화 코드는 표준을 따름
CREATE DOMAIN money_amount AS NUMERIC(12,2) CHECK (VALUE >= 0);
CREATE TABLE currency_code (
  code CHAR(3) PRIMARY KEY, -- ISO 4217 표준
  name TEXT NOT NULL
);
```

**전화번호(E.164)와 날짜/시간 도메인**
```sql
-- 국제 표준 전화번호 형식
CREATE DOMAIN phone_e164 AS TEXT
  CHECK (value ~ '^\+[1-9]\d{6,14}$');

-- 기간 데이터의 무결성 보장
ALTER TABLE subscription
  ADD CONSTRAINT ck_period CHECK (end_at IS NULL OR end_at > start_at);
```

도메인 설계는 데이터 품질의 첫 번째 방어선입니다. 명확한 명명 규칙(예: `price_cents`, `weight_kg`)과 일관된 NULL 처리 철학('미정', '불명', '적용불가'를 구분)을 확립하는 것도 이 단계에서 중요합니다.

---

## 실무에서 흔히 접하는 설계 문제와 해결책

초보 설계자들이 자주 빠지는 함정과 그 개선 방안을 알아봅니다.

*   **다중값의 잘못된 표현**: `phone1`, `phone2`와 같은 열을 추가하는 방식은 확장성에 한계가 있습니다. `customer_phone`이라는 별도 테이블을 생성하여 무제한 전화번호를 체계적으로 관리할 수 있습니다.
*   **복합 데이터의 원자성 위반**: `address`를 단일 문자열로 저장하면 주소 기반 검색이나 지역별 통계 분석이 불가능해집니다. 국가, 우편번호, 시, 구, 도로명, 상세주소로 분해해야 합니다.
*   **파생 데이터의 직접 저장**: `age`를 저장하면 매일 값이 오래되어 정확성을 잃습니다. 대신 `birth_date`를 저장하고 애플리케이션 또는 뷰에서 필요할 때 계산하여 제공하는 것이 올바른 방법입니다.
*   **하드코딩된 코드값**: 상태 값을 `'진행중'`, `'완료'`와 같은 자유 텍스트로 저장하면 오타와 불일치가 발생하기 쉽습니다. ENUM 타입이나 별도의 코드 테이블을 참조하여 유효성을 보장해야 합니다.

---

## 속성과 성능: 카디널리티와 인덱스 전략

속성의 **카디널리티**(서로 다른 값의 수)는 인덱스 설계에 직접적인 영향을 미칩니다. 이메일이나 주민등록번호와 같이 고유한 값이 많은 **고카디널리티 속성**은 단독 인덱스로도 뛰어난 필터링 성능을 제공합니다. 반면, '활성화됨(Y)/비활성화됨(N)'과 같은 **저카디널리티 속성**은 단독 인덱스의 효용이 낮아, 다른 속성과 결합한 복합 인덱스나 특정 값을 대상으로 한 부분 인덱스를 고려해야 합니다.

```sql
-- 'ACTIVE' 상태인 사용자 조회가 빈번한 경우
CREATE INDEX idx_user_active
  ON app_user(user_id) WHERE status = 'ACTIVE';

-- 상태별로 최근 주문을 빠르게 조회
CREATE INDEX idx_order_status_dt
  ON "order"(status, ordered_at DESC);
```

데이터베이스 옵티마이저가 정확한 실행 계획을 수립하려면 최신의 통계 정보가 필수적입니다. 오래된 통계는 성능을 급격히 저하시킬 수 있으므로 정기적인 갱신이 필요합니다.

---

## 국제화와 특수 데이터 유형 처리

글로벌 서비스를 설계할 때는 문화적 차이를 고려한 속성 설계가 중요합니다.

*   **주소**: 국가별로 구조가 크게 다르므로, 고정된 포맷을 강제하기보다는 핵심 필드를 원자화하고 추가 설명을 위한 자유 텍스트 필드를 병행하는 접근법이 유연합니다.
*   **전화번호**: 저장은 국제 표준인 E.164 형식(`+821012345678`)으로 통일하고, 표시할 때만 국가별 관습에 맞게 변환합니다.
*   **이름**: 성과 이름을 구분하는 문화와 그렇지 않은 문화가 있습니다. `full_name` 필드를 기본으로 하되, 필요한 경우 `family_name`과 `given_name`을 보조 필드로 추가하는 하이브리드 방식을 고려할 수 있습니다.
*   **정렬(컬레이션)**: 이름이나 주소의 알파벳 정렬 순서는 로케일에 따라 다릅니다. 데이터베이스의 컬레이션 설정이 검색과 정렬 결과에 미치는 영향을 이해해야 합니다.

---

## 현대적 도전: JSON과 반정규화의 적절한 활용

빠르게 변화하는 요구사항이나 희소한 특성을 가진 데이터의 경우, 엄격한 정규화보다 유연한 구조가 더 적합할 수 있습니다.

```sql
CREATE TABLE product (
  product_id BIGSERIAL PRIMARY KEY,
  sku TEXT NOT NULL UNIQUE,        -- 핵심 조회 조건
  name TEXT NOT NULL,              -- 핵심 정보
  price NUMERIC(12,2) NOT NULL,    -- 핵심 정보
  attributes JSONB,                -- 변동 가능한 확장 속성
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**JSON/반정규화 속성의 사용 기준**
*   **적합한 경우**: 스키마가 빈번히 변경되거나, 필드가 많지만 대부분의 레코드에서 NULL인 경우(희소성), 또는 구조화된 로그 데이터를 저장할 때.
*   **주의할 점**: JSON 필드 내부의 값으로 조인, 필터링, 집계를 자주 해야 한다면, 이는 정규 열로 '승격'시켜야 할 신호입니다.
*   **하이브리드 접근법**: 가장 일반적인 질의 패턴에 사용되는 핵심 필드는 정규 열로 정의하고, 드물게 사용되거나 선택적인 확장 데이터만 JSON으로 관리하는 것이 성능과 유연성의 균형을 잡는 방법입니다.

---

## 데이터 품질을 지키는 진단 쿼리

설계한 속성과 제약 조건이 실제 데이터에서 어떻게 지켜지고 있는지 주기적으로 점검해야 합니다. 다음 진단 쿼리들은 일반적인 데이터 품질 문제를 발견하는 데 도움을 줍니다.

```sql
-- 1. 고아 데이터 탐지: 부모 레코드가 삭제된 자식 데이터
SELECT a.address_id
FROM customer_address a
LEFT JOIN customer c ON c.customer_id = a.customer_id
WHERE c.customer_id IS NULL;

-- 2. 다중값 중복: 한 고객에게 동일한 전화번호가 중복 등록됐는지 확인
SELECT customer_id, phone, COUNT(*) cnt
FROM customer_phone
GROUP BY customer_id, phone
HAVING COUNT(*) > 1;

-- 3. 비즈니스 규칙 위반: 금액이 음수가 되지 않아야 함
SELECT * FROM invoice WHERE amount < 0;

-- 4. 기간 데이터의 논리적 오류: 시작일이 종료일보다 뒤인 경우
SELECT * FROM subscription WHERE end_at IS NOT NULL AND end_at <= start_at;
```

---

## 결론: 속성 설계, 데이터 품질의 출발점

속성 설계는 데이터 모델링의 가장 작은 단위이지만, 그 영향력은 시스템 전체의 정합성, 성능, 유지보수성, 보안에까지 미칩니다. 원자성과 함수적 종속성 같은 근본 원리를 충실히 지키는 동시에, 현실의 복잡성—국제화, 변경 이력 관리, 유연한 스키마 요구—을 수용할 수 있는 실용적인 해법을 찾아야 합니다.

훌륭한 속성 설계는 단순한 타입 정의를 넘어, 데이터의 의미를 명확히 고정하고, 비즈니스 규칙을 명시적 제약으로 표현하며, 미래의 질의 패턴을 예측하여 인덱스와 저장 전략을 수립하는 종합적인 사고 과정입니다. 이렇게 설계된 데이터 모델은 단단한 기반이 되어 애플리케이션의 신뢰성과 확장성을 뒷받침할 것입니다. 데이터 모델은 한번 작성되면 끝나는 문서가 아니라, 비즈니스와 함께 진화하는 살아있는 계약입니다. 지속적인 테스트, 모니터링, 그리고 필요에 따른 정제 과정을 통해 그 가치를 유지해 나가야 합니다.