---
layout: post
title: 컴퓨터시스템 - 프로그램 예제
date: 2025-08-01 16:20:23 +0900
category: 컴퓨터시스템
---
# 프로그램 예제에 대해 자세하게 다루기

## 읽는 법 & 실험 환경

- **대상 아키텍처**: x86-64, System V AMD64 ABI(리눅스/유닉스 계열). 필요 시 ARM64(AArch64/AAPCS64) 비교를 덧붙인다.
- **툴체인**: `gcc/clang`, `objdump/readelf/nm/size/ldd`, `perf/gdb/strace`.
- **컴파일 플래그 예시**:
  - 디버그 관찰: `-O0 -g -fno-omit-frame-pointer`
  - 최적화 관찰: `-O3 -march=native -fno-exceptions -fno-rtti`(C++일 때)
  - 어셈 출력: `-S -masm=intel` 또는 `objdump -dC`
- **측정**: 짧은 루틴은 워밍업 후 여러 번 반복, `perf stat`으로 카운터, `perf record`로 샘플링.

---

## 프로그램 예제의 의미와 중요성

- **학습 도구**: 고수준 추상(언어 문법/라이브러리)과 저수준 현실(ABI/어셈블리/메모리 모델)을 잇는다.
- **성능 분석**: 코드 한 줄이 가져오는 **파이프라인·캐시·분기예측·메모리 대역** 영향을 정량화한다.
- **디버깅/최적화 연습**: 최적화는 의미 보존 하에서만 가능. 의미(언어 규격/UB/메모리 모델)를 이해해야 성능과 안전을 동시에 잡는다.
- **컴파일러·OS·μarch 이해**: 호출 규약, 스택 프레임, 레지스터 할당, PLT/GOT, 시스템 콜, 페이지/캐시/브랜치 등 핵심 개념을 코드로 체득.

---

## 예제 프로그램 유형별 분류(확장판)

### 제어 흐름(조건/반복) 예제

- if/else, switch(점프 테이블), for/while(분기/역분기), 조건 이동(`cmov`)·분기 없는 선택.

### 메모리 모델 및 주소 예제

- 스택/힙/데이터/텍스트 섹션, 포인터 산술, 배열 주소 계산(행/열 우선, 다차원 인덱스→선형 오프셋).

### 프로시저 호출과 스택 프레임

- 호출 규약(인자 전달 레지스터·스택, 반환 레지스터), 프롤로그/에필로그, 캘리-세이브/콜러-세이브.

### 기계어와 어셈블리

- 정수/부동 연산, 로드/스토어, 분기, 호출, 호출 간 약정(ABI), 정렬/패딩.

### 캐시·TLB·프리패처 체감

- 행/열 접근, 블로킹/타일링, 구조체(SoA vs AoS) 레이아웃에 따른 성능 차이.

### I/O와 시스템 콜

- `write/read` 시스템 콜 vs stdio 버퍼링, `strace`로 인터페이스 관찰.

---

## 소스→오브젝트→실행파일: 툴체인 빠른 투어

```bash
# 전처리/컴파일/어셈블/링크

gcc -O0 -g -fno-omit-frame-pointer -c main.c -o main.o
gcc -o app main.o

# 심볼/섹션/의존 보기

nm -C app | head
readelf -hSW app
size app
ldd app

# 어셈블리 보기

objdump -dC -Mintel app | less
```

핵심 포인트
- **섹션**: `.text`(코드), `.rodata`(리터럴), `.data/.bss`(전역/정적), `.eh_frame` 등.
- **PLT/GOT**: 동적 링킹 시 외부 함수 호출 경유.
- **심볼 가시성**: 최적화/LTO/ICF/GC에 영향.

---

## 호출 규약(System V AMD64) 한 장 요약

| 항목 | 규칙(요지) |
|---|---|
| 인자 전달 | 정수/포인터: `RDI, RSI, RDX, RCX, R8, R9` 순, 이후 스택(16B 정렬 유지) |
| 반환 값 | 정수/포인터: `RAX`(및 `RDX` 추가 사용 가능) |
| 콜러-세이브 | `RAX, RCX, RDX, RSI, RDI, R8–R11` |
| 캘리-세이브 | `RBX, RBP, R12–R15` |
| 프레임 포인터 | 최적화 시 생략 가능(`-fno-omit-frame-pointer`로 유지) |
| 스택 정렬 | 호출 시점에 **16B 정렬** 보장(시뮬레이션 시 주의) |

---

## 재귀 팩토리얼: 스택 프레임을 해부

### C 코드

```c
// fact.c
#include <stdio.h>

int fact(int n){
    if(n<=1) return 1;
    return n * fact(n-1);
}
int main(){
    printf("%d\n", fact(5));
    return 0;
}
```

### 어셈블리(전형적, Intel 문법; 컴파일러/옵션에 따라 다를 수 있음)

```asm
fact:
  push  rbp
  mov   rbp, rsp
  cmp   edi, 1
  jle   .Lbase
  mov   eax, edi        ; eax <- n
  lea   edi, [rdi-1]    ; edi <- n-1 (인자)
  call  fact
  imul  eax, DWORD PTR [rbp+16] ; 또는 레지스터 재사용(컴파일러마다 상이)
  pop   rbp
  ret
.Lbase:
  mov   eax, 1
  pop   rbp
  ret
```

### 스택 프레임 그림(개념)

```
           높은 주소
           +------------------+
rbp+16 ->  |  (caller의 n)   |  ← 일부 컴파일러는 레지스터만 사용
           +------------------+
rbp+8  ->  |  return address |
           +------------------+
rbp     -> |  old RBP        |
           +------------------+
rbp-...    |  locals, spills |
           +------------------+  낮은 주소
rsp
```

포인트
- **프롤로그/에필로그**: `push rbp; mov rbp,rsp` / `pop rbp; ret`
- **인자 재전달**: `edi`로 다음 호출에 인자 넣고 `call`
- **곱셈**: `imul` 사용. 최적화 시 레지스터 재사용/테일 콜 변형 가능.

---

## 제어 흐름: if/조건 이동/분기 없는 선택

### if/else → 분기

```c
int max2(int a, int b){
    if(a>b) return a;
    else    return b;
}
```

전형적 어셈
```asm
cmp   edi, esi
cmovg eax, edi      ; 조건 이동(cmov)로 분기 없는 선택
cmovle eax, esi
ret
```
- **분기 없는 선택**은 분기 예측 실패 비용을 회피할 수 있다(데이터 의존/μop 수는 늘 수 있음).

### switch → 점프 테이블

```c
int f(int x){
    switch(x){
      case 0: return 10;
      case 1: return 20;
      case 2: return 30;
      default: return -1;
    }
}
```

전형적 어셈(개념)
```asm
cmp  edi, 2
ja   .Ldefault
jmp  QWORD PTR [rel .LJumptab + rdi*8]
.Lcase0: mov eax,10; ret
.Lcase1: mov eax,20; ret
.Lcase2: mov eax,30; ret
.Ldefault: mov eax,-1; ret
```

---

## 배열과 포인터: 주소 계산을 눈으로 보기

### 1차원 배열

$$
\text{addr}(a[i]) = \text{base}(a) + i \times \mathrm{sizeof}(a[0])
$$

```c
int sum(const int *a, int n){
    int s=0;
    for(int i=0;i<n;i++) s += a[i];    // *(a+i)
    return s;
}
```

전형적 어셈
```asm
xor   eax, eax
xor   edx, edx            ; i=0
.L:
add   eax, DWORD PTR [rdi+rdx*4] ; rdi=base(a), edx=i
inc   edx
cmp   edx, esi            ; n
jl    .L
ret
```

### 2차원 배열(행 우선, C)

$$
\text{addr}(A[i][j]) = \text{base}(A) + \big(i\cdot N + j\big)\cdot \mathrm{sizeof}(A[0][0])
$$

행 먼저 접근이 **공간 지역성**에 유리하다.

---

## 구조체 레이아웃·패딩·정렬

```c
#include <stdio.h>
#include <stddef.h>

struct S {
    char   c;   // 1B
    int    x;   // 4B (패딩!)
    short  h;   // 2B
    double d;   // 8B (정렬)
};

int main(){
    printf("sizeof(S)=%zu\n", sizeof(struct S));
    printf("off(c)=%zu off(x)=%zu off(h)=%zu off(d)=%zu\n",
           offsetof(struct S,c), offsetof(struct S,x),
           offsetof(struct S,h), offsetof(struct S,d));
}
```

정렬 규칙 때문에 필드 배치 순서가 **공간 효율·캐시 효율**에 영향을 준다(예: 큰 타입을 앞으로 배치, 같은 크기끼리 묶기).

---

## 별칭(alias)과 `restrict`로 벡터화 돕기

```c
void saxpy(int n, float a, float *restrict x, float *restrict y){
    for(int i=0;i<n;i++) y[i] += a * x[i];
}
```

- `restrict`는 **x와 y가 겹치지 않음**을 약속 → 컴파일러가 재배치·벡터화를 과감히 적용.
- 벡터화 힌트
```c
#pragma omp simd

for(int i=0;i<n;i++) y[i] += a*x[i];
```

---

## `volatile`/MMIO와 최적화 불가 영역

```c
volatile unsigned * const UART_DR = (unsigned*)0x4000'1000;
void putc(char c){
    *UART_DR = (unsigned)c; // 제거/재배치 금지
}
```

- `volatile`은 **메모리 접근 자체가 의미**임을 명시.
- 남용 금지(최적화 기회 박탈).

---

## 원자성/메모리 순서: C11 `stdatomic`

```c
#include <stdatomic.h>

atomic_int g;

void t1(){ atomic_fetch_add_explicit(&g, 1, memory_order_relaxed); }
void t2(){ while(atomic_load_explicit(&g, memory_order_acquire)==0){} }
```

- x86-64는 TSO이지만, C의 메모리 모델을 존중해야 이식성과 의미 보존이 가능.
- `lock xadd`/`mfence` 등으로 컴파일.

---

## 함수 포인터/가상 호출: 탈가상화 어려움

```c
int (*fp)(int);
int call(int x){ return fp(x); } // 정적 해석 불가 시 인라인/특화 어려움
```

PGO/JIT 없이는 정적 컴파일 단계에서 **정확한 대상**을 모를 수 있다.

---

## 시스템 콜: 라이브러리 vs 직접 호출

### `write(1, "hi\n", 3)`을 C로

```c
#include <unistd.h>

int main(){
    const char msg[] = "hi\n";
    write(1, msg, 3); // libc -> syscall 경유
    return 0;
}
```

`strace ./a.out`로 보면:
```
write(1, "hi\n", 3) = 3
```

### 어셈블리로 직접 호출(x86-64, 리눅스)

- 시스템 콜 인자: `RDI, RSI, RDX, R10, R8, R9`
- 번호: `RAX`
- 트랩: `syscall`

```asm
; rax=1(write), rdi=1(fd), rsi=buf, rdx=len
mov  rax, 1
mov  rdi, 1
lea  rsi, [rel msg]
mov  rdx, 3
syscall
ret
msg: db 'h','i',10
```

---

## 표준 I/O 버퍼링 vs 시스템 콜

```c
#include <stdio.h>

int main(){
    fputs("hello", stdout); // 버퍼에 쌓임
    fflush(stdout);         // write 호출 유도
}
```

- `stdio`는 **버퍼링**으로 시스템 콜 횟수를 줄여 성능 향상.
- 지연이 문제이면 `setvbuf`/`O_SYNC` 등 정책 조정.

---

## 라이브러리 호출(PLT/GOT)와 동적 링킹

```c
#include <math.h>

double g(double x){ return sin(x) + cos(x); }
```

- 동적 링킹 시 `sin@plt`→GOT→`libm` 실제 구현으로 연결.
- `ldd a.out`로 의존 공유 객체 확인.

---

## 스택 보호/ASLR/정렬

- **스택 카나리**: `-fstack-protector-strong`
- **ASLR**: 프로세스 주소 무작위화로 익스플로잇 난이도 상승.
- **정렬**: 16B 정렬을 지키지 않으면 SSE/AVX 경로에서 패널티 또는 예외.

---

## `setjmp/longjmp`와 최적화 제약

```c
#include <setjmp.h>

jmp_buf env;
void f(){ longjmp(env, 1); }
```

- 비지역적 제어 전이로 인해 **로컬 변수 값 유지/재배치**에 제약.
- 컴파일러는 보수적으로 접근(옵션/경고 확인).

---

## O0 vs O3: 인라인·루프 변환·벡터화

```c
int dot(const int* a, const int* b, int n){
    int s=0;
    for(int i=0;i<n;i++) s += a[i]*b[i];
    return s;
}
```

- `-O0`: 단순 루프, 각 반복마다 로드/곱/가산.
- `-O3 -march=native`: **언롤+벡터화**(AVX2/AVX-512), 누산 레지스터 다중화, 경계 처리(peeling).
- `perf stat`에서 **instructions 감소, IPC 상승**, L1/L2 미스 변화로 효과 확인.

---

## 캐시 효과: 행 vs 열, 블로킹

```c
#include <stdio.h>
#ifndef N
#define N 1024
#endif

int A[N][N];
int sum_row(){
    long s=0;
    for(int i=0;i<N;i++)
      for(int j=0;j<N;j++)
        s += A[i][j];
    return (int)s;
}
int sum_col(){
    long s=0;
    for(int j=0;j<N;j++)
      for(int i=0;i<N;i++)
        s += A[i][j];
    return (int)s;
}
```

- **행 우선(row-major)**에서 `sum_row`가 **공간 지역성**으로 유리.
- `perf stat -e cache-references,cache-misses`로 미스율 차이를 확인.
- 대형 N에서는 **블로킹(타일링)** 으로 L1/L2/L3 적중률 개선.

---

## 분기 예측: 브랜치 vs 브랜치리스

```c
int count_pos(const int* a, int n){
    int c=0;
    for(int i=0;i<n;i++) c += (a[i]>0)?1:0;           // 분기
    return c;
}
int count_pos_branchless(const int* a, int n){
    int c=0;
    for(int i=0;i<n;i++){
        unsigned m = (unsigned)(a[i] > 0);            // 0 또는 1
        c += (int)m;
    }
    return c;
}
```

- 데이터가 **랜덤**이면 분기 예측 실패↑ → 브랜치리스가 유리.
- 데이터가 **편향**되면 분기 버전이 더 빠를 수도 있다(예측 성공).

---

## 소프트웨어 프리패치(워크로드 의존)

```c
#include <xmmintrin.h> // _mm_prefetch

void sum_prefetch(const int* a, int n){
    long s=0;
    for(int i=0;i<n;i++){
        if(i+64 < n) _mm_prefetch((const char*)&a[i+64], _MM_HINT_T0);
        s += a[i];
    }
}
```

- 프리패치는 **하드웨어 프리패처가 놓치는 패턴**에서만 효과. 과하면 오히려 방해.

---

## 디버깅/관찰 도구: gdb/objdump/perf/strace

```bash
# 심볼/섹션/사이즈

nm -C app | head
readelf -SW app
size app

# 어셈블리

objdump -dC -Mintel app | less

# 런타임 카운터

perf stat -e cycles,instructions,branch-misses,LLC-load-misses ./app

# 시스템 콜 추적

strace -f -o trace.txt ./app
```

`gdb` 기본
```gdb
gdb ./app
(gdb) layout asm
(gdb) b fact
(gdb) si           # step instruction
(gdb) info reg
(gdb) x/16gx $rsp
```

---

## 실험 스캐폴딩: 마이크로벤치 해치(중앙값/p95)

```c
// bench.c
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

static double now_s(){ struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
  return t.tv_sec + t.tv_nsec*1e-9; }

static int cmpd(const void* a,const void* b){
  double x=*(const double*)a, y=*(const double*)b;
  return (x<y)?-1:(x>y);
}
static double percentile(double* a,int n,double p){
  qsort(a,n,sizeof(double),cmpd);
  double r=(p/100.0)*(n-1);
  int lo=(int)r, hi=lo+1; if(hi>=n) return a[lo];
  double f=r-lo; return a[lo]*(1.0-f)+a[hi]*f;
}

// 측정 대상
extern int sum_row(void);
extern int sum_col(void);

int main(){
  const int runs=21, warm=3;
  double t_row[runs], t_col[runs];

  for(int i=0;i<warm;i++) { sum_row(); sum_col(); }

  for(int i=0;i<runs;i++){
    double t0=now_s(); sum_row(); double t1=now_s();
    t_row[i]=t1-t0;
    t0=now_s(); sum_col(); t1=now_s();
    t_col[i]=t1-t0;
  }

  double p50r=percentile(t_row,runs,50), p95r=percentile(t_row,runs,95);
  double p50c=percentile(t_col,runs,50), p95c=percentile(t_col,runs,95);
  printf("row: p50=%.6f p95=%.6f\n", p50r, p95r);
  printf("col: p50=%.6f p95=%.6f\n", p50c, p95c);
}
```

---

## 수학으로 보는 성능 해석(요약)

### CPU 시간

$$
T_\mathrm{CPU}=\frac{N_\mathrm{inst}\cdot \mathrm{CPI}}{f}
$$
- `N_inst`를 줄이거나, CPI를 낮추거나, 클럭을 올려야 한다.
- CPI가 높은 이유: **메모리 스톨, 분기 미스, 자원 충돌**.

### Roofline

$$
\text{Perf}=\min(\text{Peak FLOPS},\ \text{AI}\times\text{Peak BW})
$$
- **AI(연산/바이트)**를 **데이터 재사용(블로킹, 캐시 적합)**으로 끌어올리면 성능 상한이 올라간다.

---

## ARM64(AArch64) 간단 비교(선택)

- 인자: `x0–x7`, 반환: `x0`, 프레임: `x29=FP`, `x30=LR`.
- 스택 16B 정렬 동일, 분기/조건 이동/체커(예: `cbz/cbnz`, `csel`) 풍부.
- SVE/SVE2 벡터 길이 가변 → **벡터 길이 불변 가정 금지**(휴대성 위해 루프 작성 주의).

---

## 체크리스트(실전 적용)

- [ ] 어셈블리로 **호출 규약/스택**을 확인했는가?
- [ ] **배열/구조체 레이아웃**이 의도한 정렬/캐시 친화인가(SoA vs AoS)?
- [ ] **별칭**을 제거(`restrict`/const)해 벡터화가 잘 걸리게 했는가?
- [ ] `volatile`을 필요한 곳에만 썼는가(최소화)?
- [ ] **시스템 콜/버퍼링** 차이를 이해하고 적절히 사용했는가?
- [ ] O0 vs O3 어셈블리/카운터 차이를 **수치로** 확인했는가(IPC/CPI/miss)?
- [ ] **Roofline**으로 메모리 vs 컴퓨트 병목을 구분했는가?
- [ ] **gdb/objdump/perf/strace**로 내부 동작을 관찰했고, 보고서에 재현 정보(플래그/환경)를 남겼는가?

---

## 연습 과제(권장)

1) `max2`를 **분기/조건이동/브랜치리스** 3가지로 작성하고 데이터 분포에 따라 어떤 구현이 빠른지 `perf`로 비교하라.
2) 2D 합산을 **블로킹**으로 바꾸고 블록 크기(예: 32/64/128) 별 성능을 측정하라.
3) `saxpy`를 `restrict`·정렬된 할당(`aligned_alloc(64, ...)`)과 함께 벡터화하고, 경계 처리(나머지 요소) 코드를 작성하라.
4) `write`를 **반복 1바이트** vs **버퍼 후 일괄** 두 방식으로 구현해 시스템 콜 횟수와 시간을 비교하라(`strace`로 검증).
5) ARM64에서 같은 코드를 빌드·실행하고 호출 규약/어셈블리 차이를 표로 정리하라.

---

## 요약

- **프로그램 예제**는 소스 코드와 실행 사이의 **모든 계층**(컴파일러/링커/ABI/어셈블리/OS/μarch)을 엮어 보여 주는 창이다.
- 동일 기능의 코드라도 **주소 계산·데이터 레이아웃·분기 패턴**에 따라 캐시·분기예측·파이프라인 상태가 달라져 **성능·에너지·지연**이 크게 변한다.
- 어셈블리를 **읽고**, `perf/gdb/objdump/strace`로 **관찰**하고, Roofline·CPI/IPC로 **해석**하여, `restrict/타일링/벡터화/버퍼링/시스템 콜 정책** 등 **실천적 변경**으로 이어가라.
- 최적화는 **의미 보존**이 전제다. 언어 규격(UB/메모리 모델)과 ABI를 준수하면서, 측정과 증거로 설득하라 — 예제는 그 모든 걸 **작게, 정확하게** 보여 준다.
