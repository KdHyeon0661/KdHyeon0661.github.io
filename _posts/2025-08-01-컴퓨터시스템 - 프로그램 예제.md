---
layout: post
title: 컴퓨터시스템 - 프로그램 예제
date: 2025-08-01 16:20:23 +0900
category: 컴퓨터시스템
---
# 프로그램 예제에 대해 자세하게 다루기

컴퓨터 시스템 관점에서 프로그램 예제는 단순한 코드가 아니라, 하드웨어와 소프트웨어가 어떻게 상호작용하는지, 그리고 각종 추상화 계층에서 프로그램이 어떻게 표현·동작하는지를 이해하는 데 핵심이다. Bryant & O’Hallaron의 『컴퓨터 시스템: 핵심 개념과 원리』 스타일로, **기계 수준 프로그램 예제**를 중심으로 자세히 설명한다.

---

## 1. 프로그램 예제의 의미와 중요성

- **학습 도구**: 이론적 개념을 실제 동작과 연결해준다.  
- **성능 분석**: CPU, 메모리, 캐시 등 하드웨어 특성을 프로그래밍으로 체감.  
- **디버깅/최적화 연습**: 프로그램이 어떻게 동작하는지 구체적 이해 필수.  
- **컴파일러, 운영체제, 아키텍처 이해**: 기계어, 레지스터, 스택, 함수 호출 등 핵심 개념 적용.  

---

## 2. 예제 프로그램 유형별 분류

### 2.1 기초 문법과 제어 흐름 예제

- 변수 할당, 조건문, 반복문  
- 함수 호출 및 반환  
- 예: C로 작성한 팩토리얼 계산, 배열 합계 등

### 2.2 메모리 모델 및 주소 예제

- 배열, 포인터, 스택 프레임 이해  
- 포인터 산술, 배열 인덱싱  
- 예: 배열의 주소 계산, 문자열 처리

### 2.3 프로시저 호출과 스택 프레임

- 함수 호출 시 스택 메모리 구조  
- 호출 규약(calling convention) 이해  
- 재귀 함수 예제

### 2.4 저수준 기계어와 어셈블리 예제

- 간단한 어셈블리 언어 명령어  
- 명령어 흐름과 제어 흐름(분기, 점프)  
- 예: Y86-64 나 x86-64 어셈블리로 작성된 코드 조각

### 2.5 메모리 접근 및 캐시 효과 예제

- 데이터 배열 크기에 따른 성능 차이  
- 공간 지역성, 시간 지역성  
- 예: 행 우선 vs 열 우선 배열 접근 비교

### 2.6 입출력 및 시스템 콜 예제

- OS와의 인터페이스  
- 파일 읽기/쓰기, 프로세스 제어

---

## 3. 구체적인 프로그램 예제: C 언어 중심

### 3.1 간단한 함수 호출 예제

```c
#include <stdio.h>

// 재귀로 n! 계산
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

int main() {
    int val = 5;
    printf("Factorial of %d is %d\n", val, factorial(val));
    return 0;
}
```

- 함수 호출 시 스택 프레임이 어떻게 만들어지고 파괴되는지 관찰 가능  
- 컴파일 후 어셈블리 코드를 보면 호출 규약과 레지스터 사용 확인 가능

---

### 3.2 배열과 포인터를 통한 메모리 접근

```c
#include <stdio.h>

void print_array(int *arr, int size) {
    for(int i=0; i<size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int numbers[5] = {10, 20, 30, 40, 50};
    print_array(numbers, 5);
    return 0;
}
```

- 배열 이름은 포인터로 해석됨  
- 메모리 주소가 어떻게 계산되는지 이해 가능  
- 포인터 산술: `arr[i] == *(arr + i)`

---

### 3.3 스택 프레임 상세 이해를 위한 어셈블리 출력 예시

아래는 gcc로 컴파일한 `factorial` 함수 일부 어셈블리 (x86-64, 간략화):

```asm
factorial:
    push   %rbp
    mov    %rsp,%rbp
    cmp    $1,%edi       # n <= 1 검사
    jle    .Lbase_case
    mov    %edi,%eax
    sub    $1,%edi
    call   factorial
    imul   %eax,%edi     # n * factorial(n-1)
    mov    %edi,%eax
    pop    %rbp
    ret
.Lbase_case:
    mov    $1,%eax
    pop    %rbp
    ret
```

- `push %rbp` : 이전 베이스 포인터 저장 → 스택 프레임 시작  
- `mov %rsp, %rbp` : 현재 스택 포인터를 베이스 포인터로 설정  
- `cmp` 와 `jle` : 조건 분기  
- `call factorial` : 재귀 호출  
- `imul` : 곱셈 연산

---

## 4. 메모리 모델과 배열 접근

### 4.1 메모리 배치

- 지역 변수, 매개변수, 리턴 주소가 스택에 저장  
- 전역 변수와 static 변수는 데이터 섹션에 저장  
- 동적 할당은 힙 영역 사용

### 4.2 배열 인덱스 계산

- 배열 요소 주소 = 배열 시작 주소 + (요소 인덱스 × 요소 크기)  
- 예: `int arr[5];` 에서 `arr[3]`의 주소는 `arr + 3*sizeof(int)`

---

## 5. 프로그램 예제를 통한 캐시 효과 체험

```c
#include <stdio.h>
#define N 1024

int main() {
    int matrix[N][N];
    int sum = 0;

    // 행 우선 접근
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            sum += matrix[i][j];

    printf("Sum (row-major): %d\n", sum);

    sum = 0;

    // 열 우선 접근
    for (int j = 0; j < N; j++)
        for (int i = 0; i < N; i++)
            sum += matrix[i][j];

    printf("Sum (column-major): %d\n", sum);
    return 0;
}
```

- 행 우선 접근이 캐시 지역성 때문에 훨씬 빠름  
- 실행시간 비교 → 메모리 접근 패턴의 중요성 체감

---

## 6. 프로그램 예제와 최적화

- 컴파일러 최적화가 어떻게 코드 실행 속도를 바꾸는지 예제 통해 학습 가능  
- 예: `-O0` vs `-O3` 컴파일 결과 비교  
- 인라인 함수, 루프 전개, 벡터화 예제 등

---

## 7. 요약 및 활용 팁

- 프로그램 예제를 작성·분석하며 하드웨어 동작 원리와 소프트웨어 추상화 사이 연결 이해  
- 코드를 직접 실행하고, 어셈블리와 프로파일링 도구로 내부 동작 관찰  
- 다양한 데이터 입력과 크기로 성능·동작 차이 체험  
- 컴파일러 옵션과 병렬화 도입 후 코드 비교로 최적화 이해
