---
layout: post
title: 운영체제 - 보호 (4)
date: 2025-11-02 17:25:23 +0900
category: 운영체제
---
# Chapter 17 — Protection (4)

## Capability-Based Systems

### 핵심 개념 정리

- **Capability(능력)**: “특정 **객체**에 대해 수행 가능한 **연산 권한**을 담은 **위조 불가 토큰**”.
  - 보통 *(객체 식별자, 권한 집합, 무결성 보호)* 로 구성.
  - 소유 = 권한. **토큰을 가진 자만** 해당 객체를 조작할 수 있음.
- **ACL(객체 중심)** 과 대비
  - **ACL**: *객체*가 “누가 무엇을 할 수 있는가”를 기억.
  - **Capability**: *주체*가 “무엇을 할 수 있는가”를 보유.
- **강점**: 최소권한(Least Privilege)·권한 위임(Delegation)·권한 감쇠(Attenuation)가 자연스럽다.
- **약점**: 이미 배포된 토큰의 **일괄 철회(revocation)** 가 어렵다 → **간접화/버전/리스/키회전** 패턴으로 보완.

수학적 정식화:
- 객체 집합 $$O$$, 권한 집합 $$R$$. Capability는
  $$\mathrm{cap} = (o \in O,\, A \subseteq R,\, \mathrm{mac})$$
  여기서 $$\mathrm{mac}$$ 은 위조 방지 메커니즘(커널 핸들, 암호학적 태그 등).

---

### “FD=능력” — 유닉스 세계의 보편적 예

- **파일 디스크립터(FD)** 는 커널이 보증하는 *unforgeable* 핸들.
- `open()` 시점의 **정책 결정** 이후에는 **경로가 아닌 FD** 로 접근 → TOCTOU 완화.
- `sendmsg(SCM_RIGHTS)` 로 **프로세스 간 위임** 가능.

#### 예: FD 위임 + 경로 고정(`openat`)

```python
# fd_cap_demo.py — 서버가 디렉터리 FD(능력)를 전송하면, 클라이언트는 그 "범위" 내에서만 파일 작업 가능

import os, socket, struct

def send_fd(sock, fd):
    sock.sendmsg([b"."], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, struct.pack("i", fd))])

def recv_fd(sock):
    _, anc, *_ = sock.recvmsg(1, 256)
    for lev, ctyp, data in anc:
        if lev == socket.SOL_SOCKET and ctyp == socket.SCM_RIGHTS:
            return struct.unpack("i", data[:4])[0]

# server

srv = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
addr = "/tmp/fd.sock"
try: os.unlink(addr)
except FileNotFoundError: pass
srv.bind(addr); srv.listen(1)
dirfd = os.open("/srv/data", os.O_RDONLY | os.O_DIRECTORY)
cli,_ = srv.accept()
send_fd(cli, dirfd)
```

```python
# client

import os, socket, struct
def recv_fd(sock):
    _, anc, *_ = sock.recvmsg(1, 256)
    for lev, ctyp, data in anc:
        if lev == socket.SOL_SOCKET and ctyp == socket.SCM_RIGHTS:
            return struct.unpack("i", data[:4])[0]
c = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
c.connect("/tmp/fd.sock")
dirfd = recv_fd(c)
fd = os.openat(dirfd, "hello.txt", os.O_RDONLY | os.O_NOFOLLOW)
print(os.read(fd, 1024))
```
> **핵심**: 클라이언트는 디렉터리 능력(**FD**)의 **상대경로**로만 접근 가능 → 경로 탈출 차단.

---

### 권한 감쇠(Attenuation) & 위임(Delegation)

- **감쇠**: 더 적은 권한을 가지는 **래퍼 능력**을 만들어 전달.
- **위임**: 자신이 가진 능력의 부분집합(또는 조건付き)을 타인에게 전달.

```python
# attenuate.py — "쓰기 불가"로 감쇠된 래퍼 능력을 발급

class Writer:
    def __init__(self, store): self.store = store
    def write(self, data:bytes): self.store.append(data)

class ReadOnly:
    def __init__(self, store): self.store = store
    def read(self): return b"".join(self.store)  # write 없음!

store=[]
rw = Writer(store)          # full 권한
ro = ReadOnly(store)        # attenuated cap
rw.write(b"A")
print(ro.read())
# ro에게는 append 권한이 없으므로 최소권한 원칙 달성

```

---

### 선택적 철회 패턴(Recap)

- **간접화/버전**: 객체 버전↑ ⇒ 구버전 cap 무효.
- **리스/TTL**: 만료 시 cap 자동 무효.
- **키 회전**: Lock-Key에서 키 교체로 그룹 철회.
- **콜백 리콜**: 서버가 클라이언트 캐시를 회수(예: NFSv4 delegation recall).

```python
# versioned_caps.py — 객체별 version으로 "전체 cap" 일괄 철회

import os
class Caps:
    def __init__(self): self.obj={}, self.cap={}
    def newobj(self, data=b""):
        oid=os.urandom(6).hex(); self.obj[oid]={"v":1,"d":data}; return oid
    def issue(self, oid, rights):
        cid=os.urandom(6).hex(); self.cap[cid]=(oid,self.obj[oid]["v"],set(rights)); return cid
    def revoke_obj(self, oid): self.obj[oid]["v"]+=1
```

---

### 커널/OS 차원의 사례

#### (A) FreeBSD Capsicum — “Capability mode”

- `cap_enter()` 로 **capability mode** 진입 후 **경로 해석 금지**.
- `cap_rights_limit(fd, rights)` 로 FD의 권한을 **축소**.

```c
// capsicum_demo.c — 열어둔 FD만으로 동작하며, cap_enter() 이후 경로 접근 불가
#include <sys/capability.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <err.h>

int main() {
  int dfd = open("/srv/data", O_DIRECTORY|O_RDONLY);
  if (dfd<0) err(1,"open");

  cap_rights_t rights;
  cap_rights_init(&rights, CAP_READ, CAP_LOOKUP);
  if (cap_rights_limit(dfd, &rights) < 0) err(1,"cap_rights_limit");

  if (cap_enter() < 0) err(1,"cap_enter");   // 이제 경로 해석 금지

  int fd = openat(dfd, "foo.txt", O_RDONLY); // OK
  char b[32]={0}; read(fd,b,31); write(1,b,31);
  return 0;
}
```

#### (B) OpenBSD pledge/unveil — 고수준 제한 API

```c
// unveil_pledge.c — 파일 계층(경로)과 시스템콜 집합을 선제 약속
#include <unistd.h>
#include <err.h>

int main(){
  if (unveil("/srv/data", "r") < 0) err(1,"unveil");
  if (unveil(NULL,NULL) < 0) err(1,"unveil lock");  // 더 이상 unveil 불가
  if (pledge("stdio rpath", NULL) < 0) err(1,"pledge");
  // ... 여기서 /srv/data 하위 읽기만 가능, 지정된 syscalls만 허용
  return 0;
}
```

---

### 분산/웹 세계의 능력

- **Macaroons**: 서명된 베어러 토큰 + **caveat(제약)** 체인 → 자연스러운 감쇠/위임.
- **WASI(WebAssembly System Interface)**: **사전-열린(preopened) 디렉터리**가 능력.
- **Object-capability 스타일**: 모듈이 필요한 능력만 **의존성 주입(DI)** 으로 받게 설계.

```javascript
// ocap_node.mjs — Node.js에서 "권한 주입"으로 능력 최소화
export function makeFileReader(fsCap){  // fsCap은 제한된 fs 래퍼
  return async (relPath) => await fsCap.readText(relPath);
}
// 호출자만이 특정 디렉터리 하위로 제한된 fsCap을 만들어 주입
```

---

## Other Protection Improvement Methods

> “능력/ACL”을 넘어서 **실무에서 보호 강도를 끌어올리는** 기법들을 정리. 커널/하드웨어/런타임/운영 레이어 전반을 아우른다.

### 샌드박싱 & 격리

- **seccomp-BPF**: 허용된 시스템콜만 통과.
- **LSM(SELinux/AppArmor)**: 라벨/프로파일 기반 MAC.
- **네임스페이스/컨테이너**: pid/net/mount/user 분리, rootless.
- **가상화/하이퍼바이저**: VM 격리, VBS/VT-x/AMD-V.

#### 예: libseccomp — read/write/exit만 허용

```c
// seccomp_min.c — libseccomp로 미니 허용목록 필터
#include <seccomp.h>
#include <unistd.h>
#include <stdio.h>

int main(){
  scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); // 기본 거부
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);
  seccomp_load(ctx);
  write(1, "ok\n", 3);
  return 0;
}
```

---

### 메모리 안전 & 실행 완화

- **W^X**(Write xor Execute), **NX** 비트, **ASLR**, **RELRO**, **CFI**, **CET**, **Stack Protector**.
- **메모리 보호키(MPK, pkeys)**: 스레드별 권한으로 **페이지 집합** 접근 통제.
- **ARM MTE**: 태그 기반 use-after-free 탐지.

#### 예: Linux pkeys — 스레드 로컬 접근 권한 토글

```c
// pkeys_demo.c — pkey로 특정 버퍼에 대한 쓰기 금지/허용 전환
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/types.h>
#include <linux/mman.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <x86intrin.h>   // pkey 함수는 glibc <sys/pkey.h> (환경에 따라 상이)

int main(){
  int pkey = pkey_alloc(0,0);           // 새 보호키
  size_t sz = 4096;
  void* buf = mmap(NULL, sz, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);
  pkey_mprotect(buf, sz, PROT_READ|PROT_WRITE, pkey);   // 버퍼에 pkey 부여

  // 쓰기 금지
  pkey_set(pkey, PKEY_DISABLE_WRITE);
  // *(volatile char*)buf = 'X'; // 여기서 SIGSEGV 기대 (주석 해제 시)

  // 쓰기 허용
  pkey_set(pkey, 0);
  strcpy((char*)buf, "hello");
  puts((char*)buf);
  return 0;
}
```
> **아이디어**: 스레드가 **권한 상태**만 바꿔도 메모리 영역 접근성이 전환됨(컨텍스트 스위치 無).

---

### I/O 격리 & DMA 방어

- **IOMMU/VT-d**: 디바이스가 임의 메모리를 DMA로 침범하지 못하도록 **DMA 맵핑**을 강제.
- **VFIO**: 사용자 공간 드라이버/가상화에서 안전한 패스스루.

---

### 저장/키 관리 & 무결성

- **전면 암호화**(BitLocker/LUKS/ZFS native).
- **Envelope 암호화** + **KMS/HSM** + **KID 회전**.
- **무결성 로그**: 해시 체인/서명/HMAC, 원격 증적(Notary-style).

---

### 소프트웨어 격리(SFI)·WASM

- **SFI**(Software Fault Isolation): 코드 삽입으로 메모리/제어 흐름 한정(NaCl).
- **WebAssembly**: 선형 메모리/모듈 경계, **WASI 능력**(preopen dir)로 OS 자원 접근을 명시화.

```wat
;; tiny.wat — WASM 모듈의 선형 메모리 사용(개념). OS 접근은 런타임에서 능력 주입으로만.
(module
  (memory (export "memory") 1)
  (func (export "put") (param $i i32) (param $v i32)
    (i32.store (local.get $i) (local.get $v))
  )
)
```

---

### 운영 가이드(실전 체크리스트)

- **기본 거부**: 방화벽/LSM/WDAC/AppLocker.
- **최소권한**: Linux capabilities·ACL·RBAC·Folder permission.
- **참조 모니터 관통**: 모든 경로가 커널/정책을 통과하도록 설계(캐시 재검증).
- **TCB 축소**: 마이크로커널·유저모드 드라이버·격리된 워커 프로세스.
- **관측성**: 권한 부여/철회/우회 시그널에 대한 중앙 로깅·경보.
- **원자적 저장**: 임시→`fsync`→`rename`→부모 `fsync` 패턴으로 권한/무결성 유지.

---

## Language-Based Protection

> **언어/타입/런타임** 자체가 보호 정책을 **명세·검증·강제**하도록 설계. 메모리 안전, 정보 흐름 제어, 객체-능력 패턴, 모듈/효과 시스템 등을 활용.

### 구성 요소

- **타입 시스템**: 잘못된 연산 배제(정적).
- **소유권·차용(Ownership/Borrowing)**: **에일리어싱 + 가변성**을 제어(Rust).
- **효과 시스템/권한 타입**: “이 함수는 **파일 읽기만** 가능” 같은 제약을 타입으로 부여.
- **객체-능력(Object-Capability, OCAP)**: **참조 자체**가 권한. 전역 가변 상태 금지, **의존성 주입**으로 권한 전달.
- **안전 런타임**: 바이트코드 검증(JVM/CLR), 모듈 경계, 샌드박스.

---

### Rust로 표현하는 능력-기반 API

- “파일 읽기 전용 능력”과 “쓰기 능력”을 **구분 타입**으로 모델링 → **컴파일 타임**에 오용 차단.

```rust
// Cargo.toml: [dependencies] anyhow="*"
use std::fs::{File, OpenOptions};
use std::io::{Read, Write};
use anyhow::Result;

pub struct ReadCap(File);
pub struct WriteCap(File);

impl ReadCap {
    pub fn open_read_only(path: &str) -> Result<Self> {
        let f = OpenOptions::new().read(true).open(path)?;
        Ok(ReadCap(f))
    }
    pub fn read_all(&mut self) -> Result<Vec<u8>> {
        let mut buf = vec![];
        self.0.read_to_end(&mut buf)?;
        Ok(buf)
    }
}

impl WriteCap {
    pub fn create_write_only(path: &str) -> Result<Self> {
        let f = OpenOptions::new().write(true).create(true).truncate(true).open(path)?;
        Ok(WriteCap(f))
    }
    pub fn append_line(&mut self, line: &str) -> Result<()> {
        writeln!(self.0, "{}", line)?;
        Ok(())
    }
}

// "감쇠": ReadWrite → ReadCap/WriteCap로 분리하여 필요한 것만 의존성 주입
pub struct ReadWrite(File);
impl ReadWrite {
    pub fn split(self) -> (ReadCap, WriteCap) {
        let fd = self.0;
        // 실제로는 dup로 분리할 수 있으나 개념 데모
        (ReadCap(fd.try_clone().unwrap()), WriteCap(fd))
    }
}
```
> **효과**: 함수 시그니처에 **권한 타입**이 드러나므로, 실수로 쓰기를 호출하려면 **컴파일이 거부**된다.

---

### OCAP 스타일 모듈 디자인(언어 불문 공통 패턴)

- **규칙**
  1) 전역 권한 금지(파일/네트워크/시계는 호출자 주입).
  2) 참조=권한. 건네받지 않은 객체에는 접근 불가.
  3) 감쇠/위임은 **새 래퍼**를 만들어 전달.
- **Node.js 예**
```javascript
// storage.js — 호출자가 주입한 "제한된 fs"로만 동작
export function makeStorage(fsCap, base) {
  return {
    async read(rel){ return await fsCap.readText(`${base}/${rel}`) },
    async write(rel, data){ return await fsCap.writeText(`${base}/${rel}`, data) } // fsCap이 write를 안 주입하면 컴파일/런타임에서 막힘
  }
}
```

---

### 정보 흐름 제어(IFC)·라벨 타입

- **정적 IFC**: 값에 보안 라벨을 부여, **타입 규칙**으로 부적절한 흐름을 거부.
- 표현: $$\Gamma \vdash e : \tau^\ell$$ (라벨 $$\ell$$ 이 부착된 타입).
- 규칙 예:
  $$\ell_1 \sqsubseteq \ell_2 \Rightarrow \tau^{\ell_1} \to \tau^{\ell_2}$$ 만 허용(저→고만).

---

### WebAssembly + WASI: 언어 기반 샌드박스

- **WASM** 모듈은 시스템콜에 직접 접근하지 않으며, **WASI** 런타임이 **사전-열린 디렉터리** 등 능력을 **주입**.
- 결과: 모듈은 받은 능력 범위 밖을 볼 수 없다.

```rust
// wasi_demo.rs — (개념) preopen된 /data 만 읽을 수 있는 프로그램
use std::fs::read_to_string;
fn main(){
    // 런타임이 /data 를 preopen하지 않으면 이 호출은 실패
    if let Ok(t) = read_to_string("/data/info.txt") {
        println!("{t}");
    } else {
        eprintln!("no capability");
    }
}
```

---

### Java/CLR의 과거·현재(개념)

- **ClassLoader + SecurityManager(Java)**: 바이트코드 검증/퍼미션 모델(현대 JDK에선 SecurityManager가 사실상 폐기 수순, 자체 샌드박싱 필요).
- **.NET CAS**(과거): 현재는 OS 레벨 격리/컨테이너 권장.
- **교훈**: 언어 차원의 보호만으로는 부족 → **OS/하드웨어 격리**와 **조합**해야 한다.

---

### 테스트 가능한 정책 — “권한이 없으면 컴파일이 깨져야”

- 함수 시그니처/타입 매개변수에 권한을 반영.
- “권한을 더 주지 않으면 못 빌드”가 **정책의 자동 검증**이 됨.

```rust
pub trait Clock { fn now(&self) -> u64; } // 테스트에선 가짜 Clock 주입
pub trait Net   { fn get(&self, url:&str) -> String; }

pub fn fetch_with_deadline<C:Clock,N:Net>(clk:&C, net:&N, url:&str, deadline:u64)->Option<String>{
    if clk.now() > deadline { return None; }
    Some(net.get(url))
}
```
> **의미**: 이 함수는 **시간/네트워크 능력**이 **둘 다** 주입되지 않으면 사용할 수 없다(능력 명시).

---

## 종합 사례 — “안전한 로그 수집기” 설계

**요구**
- 에이전트는 `/var/log/app` **읽기만**, `/var/secure/outbox` 에 **append만**.
- 정책은 **컴파일/런타임** 모두에서 강제.
- 사고 시 **즉시 철회** 가능.

**구성**
1) **OS 격리**: `seccomp` + `openat` + 디렉터리 FD 능력 주입.
2) **능력 모델**: Append-only 래퍼로 **감쇠**.
3) **언어 보호**: Rust 권한 타입(읽기/쓰기 분리)로 API 설계.
4) **철회**: outbox를 **버전 프록시**로 노출 → 사고 시 버전↑, 구 cap 무효.

---

## 핵심 요약

- **17.10 Capability**: “참조=권한”. FD·Capsicum·WASI 등으로 **최소권한·위임·감쇠**를 자연스럽게 모델링하라. 철회는 **간접화/버전/리스/키 회전**으로.
- **17.11 개선 기법**: **seccomp/LSM/네임스페이스/MPK/W^X/ASLR/IOMMU** 등 다층 방어로 TCB와 공격면을 축소. 저장/키관리/무결성, SFI/WASM도 실무 무기.
- **17.12 언어 기반 보호**: 타입/소유권/OCAP/IFC/WASM으로 **정책을 코드에 새겨** 컴파일·런타임에서 자동 강제. OS/하드웨어 격리와 **조합**이 정답.
