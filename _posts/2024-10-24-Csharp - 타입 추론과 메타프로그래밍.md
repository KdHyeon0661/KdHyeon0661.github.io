---
layout: post
title: C# - 타입 추론과 메타프로그래밍
date: 2024-10-24 19:20:23 +0900
category: Csharp
---
# C# 타입 추론과 메타프로그래밍 기초 (var, dynamic, reflection, attributes 등)

## 전체 지도 — 언제 무엇을 쓰나

- **`var`**: “타입은 정적” + “문법 단축” → **익명 타입/LINQ/타입이 자명한 곳**에 최적.
- **`dynamic`**: “타입은 런타임” + “검사는 실행 시” → **COM/스크립트 언어/형태가 유동적인 데이터**에 한정해서 사용.
- **Reflection**: “타입 메타정보 열람/호출/생성” → **플러그인/DI/ORM/테스트 프레임워크**의 기반. 성능/안전 고려 필수.
- **Attribute**: “코드에 의미/정책 주석” → **검증/매핑/라우팅/문서화**에 폭넓게 사용.

> 요약: *가능하면 정적(컴파일 타임)으로*, 불가피할 때만 동적(런타임)으로.

---

## `var` — 컴파일 타임 타입 추론, 하지만 **정적 타입**

```csharp
var n = 42;                 // int
var text = "Hello";         // string
var list = new List<int>(); // List<int>
```

### 실전 포인트

- **익명 타입** 반환/캡처:
  ```csharp
  var proj = new { Name = "Alice", Age = 30 }; // 익명 타입 → var 필수
  ```
- **LINQ**와 궁합:
  ```csharp
  var names = users.Where(u => u.Age > 20).Select(u => u.Name);
  ```
- **타입이 명확한 곳에만**: `var` 남용은 가독성 저하. 다음은 **지양**:
  ```csharp
  var a = Get(); // Get()의 타입이 바로 보이지 않으면 명시형이 더 낫다.
  ```

### 제약/주의

- `var x = null;` **불가**(타입 추론 실패).
- **Target-typed new**(C# 9+):
  ```csharp
  List<int> xs = new(); // 좌변에서 타입을 유추
  var ys = new List<int>(); // var와 new의 비교: 둘 다 정적 타입
  ```
- `var`은 **컴파일 타임 고정**: 이후 다른 타입 대입 불가.

---

## `dynamic` — 런타임 바인딩, **안전 대신 유연성**

```csharp
dynamic v = "Hello";
Console.WriteLine(v.Length); // 런타임에 string.Length 확인

v = 123;
Console.WriteLine(v + 10);   // 이제 int 연산
```

### 언제 쓰나

- **COM 상호운용**(Office 자동화), **IronPython 등 DLR** 기반 언어, **JSON 형태가 유동적**일 때 임시 처리.
- 단, **정적 모델**이 가능하면 그쪽이 더 안전/빠름.

### 오버로드 해석/확장 메서드 주의

```csharp
void F(int x) { }
void F(string s) { }

// 정적: 컴파일 시 결정
F(10);       // F(int)
F("hello");  // F(string)

// 동적: 런타임에 결정, 모호성/실패 시 RuntimeBinderException
dynamic d = 10;
F(d);        // 런타임에 F(int) 시도
```

확장 메서드는 **정적 바인딩**을 전제로 한다. `dynamic`으로 호출 시 **확장 메서드가 보이지 않거나** 바인더가 실패할 수 있다.

### 제약

- **제네릭 제약/패턴 매칭**과 상호작용이 제한적.
- 성능 비용(런타임 바인더), IDE 리팩터링 불리.
- 예외는 **런타임**까지 늦춰짐 → 테스트 필수.

---

## `object` vs `var` vs `dynamic`

| 키워드 | 타입 결정 시점 | 캐스팅 | 안전성 | 용례 |
|---|---|---|---|---|
| `var` | 컴파일 | 불필요 | 높음 | 익명 타입/LINQ/가독성 |
| `object` | 컴파일 (`object`) | 필요 | 중간 | 박싱/다운캐스트 필요 |
| `dynamic` | 런타임 | 불필요(런타임 바인딩) | 낮음 | COM/스크립트/유동 구조 |

---

## Reflection — 타입 메타정보/호출/생성

```csharp
using System.Reflection;

Type t = typeof(string);
MethodInfo[] methods = t.GetMethods(BindingFlags.Public | BindingFlags.Instance);

foreach (var m in methods)
{
    Console.WriteLine(m.Name);
}
```

### 멤버/생성/호출

```csharp
// 인스턴스 생성
Type pt = typeof(Person);
object person = Activator.CreateInstance(pt, args: new object?[] { "Alice", 30 });

// 메서드 호출
var mi = pt.GetMethod("Introduce");
mi!.Invoke(person, parameters: null);
```

> **성능 주의**: Reflection 호출은 느리다. **캐싱** + **Delegate 바인딩**으로 가속하자.

### 속성/필드 접근

```csharp
var prop = pt.GetProperty("Name");
prop!.SetValue(person, "Bob");
var val = prop!.GetValue(person); // "Bob"
```

### 생성자/제네릭/비공개

```csharp
// 특정 생성자 선택
var ctor = pt.GetConstructor(new[] { typeof(string), typeof(int) });
var p2 = ctor!.Invoke(new object?[] { "Chris", 25 });

// 제네릭 타입 구성
Type genList = typeof(List<>).MakeGenericType(typeof(Guid));
object list = Activator.CreateInstance(genList)!;

// 비공개 멤버 접근(테스트/도구에서만)
var hidden = pt.GetMethod("Secret", BindingFlags.NonPublic | BindingFlags.Instance);
hidden!.Invoke(person, null);
```

### 성능 최적화: `Delegate.CreateDelegate` / Expression Tree

```csharp
// MethodInfo → 강타입 델리게이트로 캐싱
var sayMethod = pt.GetMethod("Say", new[] { typeof(string) })!;
var del = (Action<Person, string>)Delegate.CreateDelegate(typeof(Action<Person, string>), null, sayMethod);
del((Person)person, "Hi"); // Invoke보다 빠름
```

Expression Tree로 Setter/Getter 컴파일(초기 한 번, 이후 초고속):

```csharp
using System.Linq.Expressions;

Func<T, object?> BuildGetter<T>(PropertyInfo prop)
{
    var inst = Expression.Parameter(typeof(T), "obj");
    var access = Expression.Property(inst, prop);
    var box = Expression.Convert(access, typeof(object));
    var lambda = Expression.Lambda<Func<T, object?>>(box, inst);
    return lambda.Compile();
}
```

---

## Attribute — 코드에 정책/메타데이터 부여

### 기본 사용

```csharp
[Obsolete("Use NewMethod instead")]
public void OldMethod() { }

[Serializable]
public class MyData { }
```

### 사용자 정의 Attribute

```csharp
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
public sealed class MyTagAttribute : Attribute
{
    public string Info { get; }
    public int Level { get; init; } // C# 9+ init-only
    public MyTagAttribute(string info) => Info = info;
}

[MyTag("핵심", Level = 3)]
public class MyClass { }
```

### Attribute 읽기

```csharp
var attr = typeof(MyClass).GetCustomAttribute<MyTagAttribute>();
Console.WriteLine($"{attr!.Info}, L={attr.Level}");

var all = typeof(MyClass).GetCustomAttributes<MyTagAttribute>(inherit: true);
```

> **값 기록 형태**: 생성자 인수(필수) + **Named Arguments**(옵션 프로퍼티/필드 할당).

---

## 실전 패턴

### 플러그인/핸들러 자동 등록

```csharp
[AttributeUsage(AttributeTargets.Class)]
public sealed class HandlerAttribute : Attribute
{
    public string Key { get; }
    public HandlerAttribute(string key) => Key = key;
}

public interface IHandler { void Handle(); }

[Handler("csv")]
public sealed class CsvHandler : IHandler { public void Handle() => Console.WriteLine("CSV"); }

[Handler("json")]
public sealed class JsonHandler : IHandler { public void Handle() => Console.WriteLine("JSON"); }

public static class HandlerRegistry
{
    private static readonly Dictionary<string, Type> _map;

    static HandlerRegistry()
    {
        _map = AppDomain.CurrentDomain.GetAssemblies()
            .SelectMany(a => a.GetTypes())
            .Where(t => typeof(IHandler).IsAssignableFrom(t) && !t.IsAbstract)
            .Select(t => (Type: t, Attr: t.GetCustomAttribute<HandlerAttribute>()))
            .Where(x => x.Attr is not null)
            .ToDictionary(x => x.Attr!.Key, x => x.Type, StringComparer.OrdinalIgnoreCase);
    }

    public static IHandler Create(string key)
    {
        if (!_map.TryGetValue(key, out var t))
            throw new InvalidOperationException($"No handler for {key}");
        return (IHandler)Activator.CreateInstance(t)!;
    }
}
```

사용:
```csharp
HandlerRegistry.Create("json").Handle(); // "JSON"
```

### 기반

```csharp
[AttributeUsage(AttributeTargets.Property)]
public sealed class RequiredAttribute : Attribute { }

public sealed class User
{
    [Required] public string Name { get; init; } = "";
    public int Age { get; init; }
}

public static class Validator
{
    public static IEnumerable<string> Validate(object obj)
    {
        foreach (var p in obj.GetType().GetProperties())
        {
            if (p.GetCustomAttribute<RequiredAttribute>() is not null)
            {
                var v = p.GetValue(obj);
                if (v is null || (v is string s && string.IsNullOrWhiteSpace(s)))
                    yield return $"{p.Name} is required";
            }
        }
    }
}
```

---

## Reflection + 제네릭 — 런타임 타입으로 `MakeGenericType`

```csharp
Type repoOpen = typeof(Repository<>);
Type closed = repoOpen.MakeGenericType(typeof(Product));
object repo = Activator.CreateInstance(closed)!;
```

메서드가 제네릭이면 `MakeGenericMethod`:

```csharp
var mi = typeof(Factory).GetMethod("Create")!;
var closedMethod = mi.MakeGenericMethod(typeof(Product));
object product = closedMethod.Invoke(null, null)!;
```

---

## `nameof`, 패턴 매칭, `var` 패턴의 시너지

```csharp
void LogArgNull(string? s)
{
    if (s is null) throw new ArgumentNullException(nameof(s));
}

object o = 3;
if (o is int value) // 패턴 매칭 + var 캡처
{
    Console.WriteLine(value + 1);
}
```

---

## 동적 객체: `ExpandoObject`, `IDynamicMetaObjectProvider`

```csharp
dynamic bag = new System.Dynamic.ExpandoObject();
bag.Name = "Alice";
bag.Age = 30;
Console.WriteLine($"{bag.Name} ({bag.Age})");
```

커스텀 동적 객체를 만들려면 `DynamicObject` 상속 또는 `IDynamicMetaObjectProvider` 구현.

---

## 성능 모델과 튜닝

### 비용 직관

- **정적 호출** < **Delegate** 바운드 호출 << **MethodInfo.Invoke**
- **동적 바인딩**(dynamic)은 매 호출 시 바인딩/캐시 비용 발생.

간이 모델:
$$
T_{\text{reflect}} \approx T_{\text{call}} + T_{\text{lookup}} + T_{\text{boxing}}
$$
성능 민감 구간에서는
1) **MethodInfo/PropertyInfo 캐싱**
2) **Delegate.CreateDelegate/Expression.Compile**로 바운딩
3) **반복 루프** 안에서 Reflection 호출 금지

### 안전 가이드

- 외부 입력으로 **Type/멤버 이름**을 직접 받아 반사 호출하는 경우 **허용 목록(whitelist)** 필수.
- **비공개 멤버 접근**은 테스트/도구용으로만. 운영 코드에 넣지 말 것.

---

## 테스트 친화적 설계 포인트

- **시간/난수/시스템 의존성**은 인터페이스로 추상화 → 정적 타입 유지 + 목킹 용이.
- 동적/리플렉션 코드는 **좁은 경계**로 감싸서 유닛 테스트는 정적 API로 검증.
- 어트리뷰트 규칙은 **검증 유닛 테스트**로 회귀 방지.

---

## 종합 예제 — “정적 우선, 동적 보조”

### 모델+속성

```csharp
public sealed class Person
{
    [MyTag("PII", Level = 2)]
    public string Name { get; set; } = "";

    public int Age { get; set; }

    public void Introduce() => Console.WriteLine($"I'm {Name}, {Age}");
    private void Secret() => Console.WriteLine("secret...");
}
```

### 리플렉션 유틸(캐싱 + 델리게이트)

```csharp
public static class Reflect<T>
{
    private static readonly Dictionary<string, Func<T, object?>> _getters = new();

    public static Func<T, object?> Getter(string prop)
    {
        if (_getters.TryGetValue(prop, out var g)) return g;

        var p = typeof(T).GetProperty(prop)!;
        var prm = System.Linq.Expressions.Expression.Parameter(typeof(T), "x");
        var body = System.Linq.Expressions.Expression.Convert(
            System.Linq.Expressions.Expression.Property(prm, p),
            typeof(object));
        var lam = System.Linq.Expressions.Expression.Lambda<Func<T, object?>>(body, prm);
        g = lam.Compile();
        _getters[prop] = g;
        return g;
    }
}

// 사용
var alice = new Person { Name = "Alice", Age = 30 };
var getName = Reflect<Person>.Getter("Name");
Console.WriteLine(getName(alice)); // "Alice"
```

### 속성 스캔 + 규칙 적용

```csharp
foreach (var p in typeof(Person).GetProperties())
{
    if (p.GetCustomAttribute<MyTagAttribute>() is { } tag && tag.Info == "PII")
    {
        Console.WriteLine($"PII Field: {p.Name}, Level={tag.Level}");
    }
}
```

---

## FAQ — 자주 틀리는 포인트

- **Q. `var`와 `dynamic`의 차이?**
  **A.** `var`는 **정적 타입 추론**(컴파일 고정), `dynamic`은 **런타임 바인딩**. 가능하면 `var`.

- **Q. Reflection이 느리다는데 얼마나?**
  **A.** 상황에 따라 10~100배도 가능. 루프 내 호출 금지, 캐싱/델리게이트 바인딩 필수.

- **Q. Attribute를 많이 달면 느려지나?**
  **A.** 조회할 때만 비용. AppDomain/시작 시 캐싱하면 실무에서 크게 문제 되지 않는다.

- **Q. `dynamic`으로 확장 메서드가 안 먹어요**
  **A.** 확장 메서드는 정적 바인딩이다. 필요하면 **정적 호출 경로**를 사용하거나 정상 타입으로 캐스팅.

---

## 체크리스트

- [ ] 타입이 자명한가? → `var`, 아니면 **명시형**으로 가독성 유지
- [ ] `dynamic`은 정말 필요한가? → COM/스크립트/유동 구조 이외 금지
- [ ] Reflection 호출은 **캐싱**했는가? **Delegate**로 바운딩했는가?
- [ ] Attribute는 **명확한 정책/검증 로직**과 함께 쓰는가?
- [ ] 외부 입력 기반의 반사는 **허용 목록/검증**이 있는가?

---

## 마무리

- **정적 모델**을 최우선으로: `var`는 **짧고 안전**한 문법 설탕이다.
- 불가피할 때만 **동적/리플렉션**을 쓰되, **캐싱/검증/경계 설정**으로 안정성과 성능을 확보하라.
- Attribute와 Reflection의 조합은 **플러그인/DI/ORM/검증/라우팅** 등 현대 .NET 아키텍처의 **핵심 기반**이다.
