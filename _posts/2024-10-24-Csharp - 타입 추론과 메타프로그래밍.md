---
layout: post
title: C# - 타입 추론과 메타프로그래밍
date: 2024-10-24 19:20:23 +0900
category: Csharp
---
# C# 타입 추론과 메타프로그래밍: 정적과 동적의 조화로운 공존

## 타입 시스템의 스펙트럼 이해하기

C#은 강력한 정적 타입 시스템을 기반으로 하면서도, 필요에 따라 동적 타입 처리와 메타프로그래밍을 지원하는 다재다능한 언어입니다. 이는 개발자가 정적 타입의 안전성과 동적 타입의 유연성 사이에서 최적의 균형점을 찾을 수 있게 해줍니다.

```csharp
// 정적 타입의 안전성
string name = "Alice";  // 컴파일 타임에 타입 검증
int length = name.Length; // 안전한 접근

// 타입 추론의 편리성
var inferredName = "Bob"; // 컴파일러가 string으로 추론
var numbers = new List<int> { 1, 2, 3 };

// 동적 타입의 유연성
dynamic dynamicValue = "Hello";
dynamicValue = 42; // 런타임에 타입 변경 가능
```

## var: 컴파일 타임 타입 추론의 편리함

`var` 키워드는 C#의 타입 추론 시스템을 활용하여 변수 선언을 간결하게 만들어줍니다. 이는 코드를 더 읽기 쉽게 만들면서도 컴파일 타임 타입 안전성을 완전히 유지합니다.

### 적절한 사용 사례
```csharp
// 1. 복잡한 제네릭 타입 선언 간소화
var dictionary = new Dictionary<string, List<Tuple<int, DateTime>>>();

// 2. LINQ 쿼리 결과 처리
var results = from person in people
              where person.Age > 18
              select new { person.Name, person.Email };

// 3. 익명 타입 사용 (var 필수)
var anonymous = new { Name = "Charlie", Score = 95.5 };

// 4. 생성자 호출과 함께 사용
var person = new Person("David", 30);
```

### 주의해야 할 상황
```csharp
// 나쁜 예: 타입이 명확하지 않은 경우
var data = GetData(); // GetData()의 반환 타입이 무엇일까?

// 좋은 예: 타입을 명시적으로 표시
Person person = GetPerson(); // 가독성이 훨씬 좋음
IEnumerable<string> names = GetNames();

// 컴파일 오류: null은 타입 추론 불가
// var value = null; // ❌ 컴파일 오류
var value = (string?)null; // ✅ 명시적 타입 지정 필요
```

**핵심 원칙**: `var`는 코드를 더 간결하게 만들 때 사용하되, 가독성을 해치지 않는 범위 내에서 사용해야 합니다. 변수의 실제 타입이 명확히 드러나지 않는다면 명시적 타입 선언이 더 나은 선택입니다.

## dynamic: 런타임 유연성의 양날의 검

`dynamic` 키워드는 C#에 동적 타입 시스템을 도입하여, 컴파일 타임 타입 검사를 우회하고 런타임에 타입을 결정할 수 있게 해줍니다. 이는 강력한 기능이지만 신중하게 사용해야 합니다.

### 적합한 사용 시나리오
```csharp
// 1. COM 상호 운용 (예: Microsoft Office 자동화)
dynamic excel = Activator.CreateInstance(Type.GetTypeFromProgID("Excel.Application"));
excel.Visible = true;
dynamic workbook = excel.Workbooks.Add();

// 2. 동적 언어 런타임(DLR)과의 통합
// IronPython, IronRuby 등의 스크립트 언어 호출

// 3. 유연한 JSON 데이터 처리
dynamic jsonData = JsonConvert.DeserializeObject(jsonString);
string name = jsonData.user.profile.name;

// 4. 리플렉션 대체 (더 간결한 구문)
dynamic instance = Activator.CreateInstance(someType);
string result = instance.SomeMethod(param1, param2);
```

### 주의사항과 한계
```csharp
dynamic calculator = new Calculator();

// 런타임 오류 위험
try
{
    var result = calculator.Add(5, 10); // Add 메서드가 존재한다고 가정
}
catch (Microsoft.CSharp.RuntimeBinder.RuntimeBinderException ex)
{
    // 메서드가 존재하지 않으면 런타임 예외 발생
    Console.WriteLine($"메서드 호출 실패: {ex.Message}");
}

// 성능 고려사항
// dynamic 호출은 정적 호출보다 약 10-100배 느림
for (int i = 0; i < 1000000; i++)
{
    // 이 루프 내에서 dynamic 사용은 성능 저하를 초래할 수 있음
    dynamic value = i;
    // ...
}

// IDE 지원 제한
// dynamic 변수에 대한 코드 완성, 리팩토링, 오류 검사가 제한적임
```

**핵심 원칙**: `dynamic`은 정적 타입 시스템으로 표현하기 어려운 시나리오에만 제한적으로 사용하세요. 가능한 한 정적 타입을 우선시하고, `dynamic`의 사용 범위를 최소화하여 유지보수성과 안정성을 확보하세요.

## Reflection: 런타임 타입 탐색의 강력한 도구

리플렉션은 .NET의 메타데이터 시스템을 통해 타입 정보를 런타임에 검사하고 조작할 수 있는 기능입니다. 이는 플러그인 아키텍처, 의존성 주입, ORM, 테스트 프레임워크 등 다양한 고급 시나리오의 기반이 됩니다.

### 기본 사용법
```csharp
using System.Reflection;

public class TypeExplorer
{
    public static void InspectType<T>()
    {
        Type type = typeof(T);
        
        Console.WriteLine($"타입: {type.FullName}");
        Console.WriteLine($"어셈블리: {type.Assembly.GetName().Name}");
        
        // 생성자 정보
        Console.WriteLine("\n생성자:");
        foreach (var constructor in type.GetConstructors())
        {
            Console.WriteLine($"  {constructor}");
        }
        
        // 속성 정보
        Console.WriteLine("\n속성:");
        foreach (var property in type.GetProperties())
        {
            Console.WriteLine($"  {property.PropertyType.Name} {property.Name}");
        }
        
        // 메서드 정보
        Console.WriteLine("\n메서드:");
        foreach (var method in type.GetMethods(BindingFlags.Public | BindingFlags.Instance))
        {
            if (!method.IsSpecialName) // 속성 접근자 등 제외
            {
                Console.WriteLine($"  {method.ReturnType.Name} {method.Name}()");
            }
        }
    }
}

// 사용 예
TypeExplorer.InspectType<Person>();
```

### 실전 패턴: 플러그인 시스템
```csharp
public interface IPlugin
{
    string Name { get; }
    void Execute();
}

[PluginMetadata("csv-processor", Version = "1.0", Author = "DevTeam")]
public class CsvProcessor : IPlugin
{
    public string Name => "CSV Processor";
    
    public void Execute()
    {
        Console.WriteLine("Processing CSV files...");
    }
}

public class PluginLoader
{
    private readonly Dictionary<string, IPlugin> _plugins = new();
    
    public void LoadPlugins(string directoryPath)
    {
        foreach (var dllFile in Directory.GetFiles(directoryPath, "*.dll"))
        {
            try
            {
                Assembly assembly = Assembly.LoadFrom(dllFile);
                
                foreach (var type in assembly.GetTypes())
                {
                    if (typeof(IPlugin).IsAssignableFrom(type) && !type.IsAbstract)
                    {
                        // 플러그인 인스턴스 생성
                        IPlugin plugin = (IPlugin)Activator.CreateInstance(type);
                        
                        // 메타데이터 추출
                        var metadata = type.GetCustomAttribute<PluginMetadataAttribute>();
                        if (metadata != null)
                        {
                            Console.WriteLine($"Loaded plugin: {metadata.Id} v{metadata.Version}");
                        }
                        
                        _plugins[plugin.Name] = plugin;
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load assembly {dllFile}: {ex.Message}");
            }
        }
    }
    
    public IPlugin GetPlugin(string name) => _plugins.GetValueOrDefault(name);
}
```

### 성능 최적화 전략
```csharp
public class OptimizedReflection
{
    // 1. MethodInfo 캐싱
    private static readonly Dictionary<string, MethodInfo> _methodCache = new();
    
    public static MethodInfo GetCachedMethod(Type type, string methodName)
    {
        string key = $"{type.FullName}.{methodName}";
        
        if (!_methodCache.TryGetValue(key, out var methodInfo))
        {
            methodInfo = type.GetMethod(methodName);
            _methodCache[key] = methodInfo;
        }
        
        return methodInfo;
    }
    
    // 2. 델리게이트를 통한 성능 개선
    private delegate object PropertyGetter(object instance);
    private delegate void PropertySetter(object instance, object value);
    
    private static readonly Dictionary<string, PropertyGetter> _getterCache = new();
    private static readonly Dictionary<string, PropertySetter> _setterCache = new();
    
    public static PropertyGetter CreatePropertyGetter(PropertyInfo property)
    {
        string key = $"{property.DeclaringType!.FullName}.{property.Name}.Getter";
        
        if (!_getterCache.TryGetValue(key, out var getter))
        {
            // Expression Tree를 사용한 고성능 델리게이트 생성
            var instance = Expression.Parameter(typeof(object), "instance");
            var castInstance = Expression.Convert(instance, property.DeclaringType);
            var propertyAccess = Expression.Property(castInstance, property);
            var castResult = Expression.Convert(propertyAccess, typeof(object));
            
            getter = Expression.Lambda<PropertyGetter>(castResult, instance).Compile();
            _getterCache[key] = getter;
        }
        
        return getter;
    }
    
    // 3. 제네릭 메서드를 통한 박싱 최소화
    public static T GetPropertyValue<T>(object instance, string propertyName)
    {
        var property = instance.GetType().GetProperty(propertyName);
        if (property == null)
            throw new ArgumentException($"Property {propertyName} not found");
        
        return (T)property.GetValue(instance);
    }
}
```

**핵심 원칙**: 리플렉션은 강력하지만 비용이 큰 도구입니다. 가능한 한 캐싱, 델리게이트 컴파일, 제네릭 활용 등의 최적화 기법을 적용하여 성능 저하를 최소화하세요.

## Attributes: 코드에 의미 부여하기

어트리뷰트는 코드 요소에 메타데이터를 첨부하는 강력한 방법으로, 컴파일러, 런타임, 또는 다른 도구들이 추가 정보를 활용할 수 있게 합니다.

### 사용자 정의 어트리뷰트 만들기
```csharp
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | 
                AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
public class ValidationAttribute : Attribute
{
    public bool Required { get; set; }
    public int MinLength { get; set; } = 0;
    public int MaxLength { get; set; } = int.MaxValue;
    public string RegexPattern { get; set; } = "";
    
    public ValidationAttribute(bool required = false)
    {
        Required = required;
    }
}

[AttributeUsage(AttributeTargets.Method)]
public class LogExecutionAttribute : Attribute
{
    public LogLevel Level { get; set; } = LogLevel.Info;
}

public enum LogLevel
{
    Debug,
    Info,
    Warning,
    Error
}
```

### 실전 적용: 데이터 검증 시스템
```csharp
public class UserDto
{
    [Validation(Required = true, MinLength = 2, MaxLength = 50)]
    public string Username { get; set; } = "";
    
    [Validation(Required = true, MinLength = 8)]
    [RegularExpression(@"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$")]
    public string Password { get; set; } = "";
    
    [Validation(Required = true)]
    [EmailAddress]
    public string Email { get; set; } = "";
    
    [Range(18, 120)]
    public int Age { get; set; }
}

public class Validator
{
    public static ValidationResult Validate(object model)
    {
        var result = new ValidationResult();
        var properties = model.GetType().GetProperties();
        
        foreach (var property in properties)
        {
            // ValidationAttribute 검사
            var validationAttr = property.GetCustomAttribute<ValidationAttribute>();
            if (validationAttr != null)
            {
                var value = property.GetValue(model);
                
                if (validationAttr.Required && (value == null || 
                    (value is string str && string.IsNullOrWhiteSpace(str))))
                {
                    result.AddError(property.Name, $"{property.Name}은(는) 필수 항목입니다.");
                }
                
                if (value is string stringValue)
                {
                    if (stringValue.Length < validationAttr.MinLength)
                    {
                        result.AddError(property.Name, 
                            $"{property.Name}은(는) 최소 {validationAttr.MinLength}자 이상이어야 합니다.");
                    }
                    
                    if (stringValue.Length > validationAttr.MaxLength)
                    {
                        result.AddError(property.Name, 
                            $"{property.Name}은(는) 최대 {validationAttr.MaxLength}자 이하여야 합니다.");
                    }
                    
                    if (!string.IsNullOrEmpty(validationAttr.RegexPattern) &&
                        !Regex.IsMatch(stringValue, validationAttr.RegexPattern))
                    {
                        result.AddError(property.Name, 
                            $"{property.Name} 형식이 올바르지 않습니다.");
                    }
                }
            }
            
            // 다른 어트리뷰트들도 비슷하게 처리...
        }
        
        return result;
    }
}

public class ValidationResult
{
    public bool IsValid => !Errors.Any();
    public List<ValidationError> Errors { get; } = new();
    
    public void AddError(string propertyName, string message)
    {
        Errors.Add(new ValidationError(propertyName, message));
    }
}

public record ValidationError(string PropertyName, string Message);
```

### AOP(Aspect-Oriented Programming) 패턴
```csharp
public class ServiceInterceptor : DispatchProxy
{
    private object? _target;
    private IServiceProvider _serviceProvider;
    
    public static T Create<T>(T target, IServiceProvider serviceProvider) where T : class
    {
        object proxy = Create<T, ServiceInterceptor>();
        ((ServiceInterceptor)proxy)._target = target;
        ((ServiceInterceptor)proxy)._serviceProvider = serviceProvider;
        
        return (T)proxy;
    }
    
    protected override object? Invoke(MethodInfo? targetMethod, object?[]? args)
    {
        if (targetMethod == null || _target == null)
            return null;
        
        // 메서드 어트리뷰트 검사
        var logAttr = targetMethod.GetCustomAttribute<LogExecutionAttribute>();
        var timerAttr = targetMethod.GetCustomAttribute<TimedOperationAttribute>();
        
        // 실행 전 로직
        if (logAttr != null)
        {
            var logger = _serviceProvider.GetService<ILogger>();
            logger?.Log(logAttr.Level, 
                $"Executing {targetMethod.Name} on {_target.GetType().Name}");
        }
        
        Stopwatch? stopwatch = null;
        if (timerAttr != null)
        {
            stopwatch = Stopwatch.StartNew();
        }
        
        try
        {
            // 실제 메서드 실행
            var result = targetMethod.Invoke(_target, args);
            
            // 실행 후 로직
            if (stopwatch != null)
            {
                stopwatch.Stop();
                Console.WriteLine($"{targetMethod.Name} executed in {stopwatch.ElapsedMilliseconds}ms");
            }
            
            return result;
        }
        catch (Exception ex)
        {
            // 예외 처리
            var logger = _serviceProvider.GetService<ILogger>();
            logger?.LogError(ex, $"Error executing {targetMethod.Name}");
            throw;
        }
    }
}

// 사용 예
public interface IDataService
{
    [LogExecution(Level = LogLevel.Info)]
    [TimedOperation]
    Task<List<string>> GetDataAsync();
}

var service = new DataService();
var interceptedService = ServiceInterceptor.Create<IDataService>(service, serviceProvider);
await interceptedService.GetDataAsync(); // 로깅과 타이밍이 자동 적용됨
```

## 메타프로그래밍의 현실적 적용

### 코드 제너레이터와 소스 생성기
```csharp
// C# 9.0+ 소스 생성기 예시 (간략화)
[Generator]
public class DtoGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // 구문 분석기 등록
        context.RegisterForSyntaxNotifications(() => new DtoSyntaxReceiver());
    }
    
    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not DtoSyntaxReceiver receiver)
            return;
        
        foreach (var classDeclaration in receiver.CandidateClasses)
        {
            // 클래스 분석 및 코드 생성
            string className = classDeclaration.Identifier.Text;
            string sourceCode = GenerateDtoCode(className, classDeclaration);
            
            context.AddSource($"{className}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
        }
    }
    
    private string GenerateDtoCode(string className, ClassDeclarationSyntax classSyntax)
    {
        return $$"""
            // <auto-generated/>
            #nullable enable
            
            namespace GeneratedDtos
            {
                public partial class {{className}}Dto
                {
                    {{GenerateProperties(classSyntax)}}
                    
                    public {{className}}Dto({{className}} entity)
                    {
                        {{GenerateMappingLogic(classSyntax)}}
                    }
                }
            }
            """;
    }
}
```

### 동적 프로퍼티와 ExpandoObject
```csharp
public class DynamicModelBinder
{
    public static dynamic CreateDynamicModel(Dictionary<string, object> properties)
    {
        dynamic model = new ExpandoObject();
        var dict = (IDictionary<string, object>)model;
        
        foreach (var kvp in properties)
        {
            dict[kvp.Key] = kvp.Value;
        }
        
        // 동적 메서드 추가
        ((IDictionary<string, object>)model)["ToString"] = (Func<string>)(() =>
        {
            return string.Join(", ", dict.Select(kvp => $"{kvp.Key}: {kvp.Value}"));
        });
        
        return model;
    }
    
    public static T BindToType<T>(dynamic source) where T : class, new()
    {
        var target = new T();
        var targetType = typeof(T);
        
        foreach (var property in targetType.GetProperties())
        {
            if (((IDictionary<string, object>)source).TryGetValue(property.Name, out var value))
            {
                if (value != null && property.PropertyType.IsAssignableFrom(value.GetType()))
                {
                    property.SetValue(target, value);
                }
                else if (value != null)
                {
                    // 타입 변환 시도
                    var converted = Convert.ChangeType(value, property.PropertyType);
                    property.SetValue(target, converted);
                }
            }
        }
        
        return target;
    }
}

// 사용 예
var dynamicData = DynamicModelBinder.CreateDynamicModel(new Dictionary<string, object>
{
    ["Id"] = 1,
    ["Name"] = "Test",
    ["CreatedAt"] = DateTime.Now
});

Console.WriteLine(dynamicData.ToString()); // 동적 메서드 호출
Console.WriteLine(dynamicData.Name); // 동적 프로퍼티 접근

var typedData = DynamicModelBinder.BindToType<Product>(dynamicData);
```

## 결론: 현명한 타입 시스템 활용의 철학

C#의 타입 시스템과 메타프로그래밍 기능들은 서로 상호보완적인 관계에 있습니다. 효과적인 소프트웨어 개발은 이들 사이에서 적절한 균형점을 찾는 과정입니다.

### 핵심 원칙 정리

1. **정적 타입의 안전성을 최우선으로**
   - 컴파일 타임에 발견할 수 있는 오류는 가장 저렴한 오류입니다.
   - `var`는 타입이 명확할 때만 사용하여 가독성과 안전성을 동시에 확보하세요.
   - 가능한 한 모든 타입 정보를 컴파일 타임에 알 수 있도록 설계하세요.

2. **동적 기능은 제한된 범위에서만**
   - `dynamic`은 특수한 시나리오(COM, DLR, 매우 유연한 데이터 구조)에만 사용하세요.
   - 동적 코드의 범위를 최소화하고, 정적 타입과의 경계를 명확히 정의하세요.
   - 성능 영향과 런타임 오류 가능성을 항상 염두에 두세요.

3. **리플렉션은 신중하게, 최적화 필수**
   - 리플렉션은 강력한 도구이지만 비용이 큽니다.
   - 캐싱, 델리게이트 컴파일, 제네릭 활용 등 최적화 기법을 반드시 적용하세요.
   - 보안 측면을 고려하여 신뢰할 수 없는 입력에 대한 리플렉션 사용을 제한하세요.

4. **어트리뷰트는 선언적 프로그래밍의 도구로**
   - 어트리뷰트는 코드에 의미를 부여하는 강력한 방법입니다.
   - 검증, 매핑, 로깅, 권한 부여 등 다양한 관심사를 분리하는 데 활용하세요.
   - 과도한 사용은 코드의 복잡성을 증가시킬 수 있으므로 적정선을 유지하세요.

5. **메타프로그래밍은 아키텍처 의사결정**
   - 소스 생성기, AOP, 동적 코드 생성 등은 아키텍처 수준의 결정입니다.
   - 팀의 기술 수준과 유지보수성을 고려하여 도입하세요.
   - 문서화와 표준화를 통해 복잡성을 관리하세요.

### 실전 가이드라인

- **80/20 법칙 적용**: 80%의 코드는 정적 타입으로 작성하고, 20%의 특수한 경우에만 동적 기능을 사용하세요.
- **계층화 아키텍처**: 동적 코드와 리플렉션을 특정 계층(인프라, 플러그인, 바인딩)으로 격리하세요.
- **점진적 개선**: 처음부터 완벽한 메타프로그래밍 솔루션을 만들기보다, 점진적으로 개선해 나가세요.
- **팀 협업**: 메타프로그래밍 코드는 팀 전체가 이해하고 유지보수할 수 있어야 합니다.

C#의 진정한 힘은 이 다양한 타입 시스템 기능들이 조화롭게 공존할 수 있다는 점에 있습니다. 정적 타입의 안전성, 동적 타입의 유연성, 메타프로그래밍의 확장성을 상황에 맞게 적절히 조합할 때, 우리는 더 견고하고 유지보수하기 쉬우며 확장 가능한 소프트웨어를 만들 수 있습니다.

기술은 도구일 뿐입니다. 중요한 것은 어떤 도구를, 언제, 어떻게 사용할지 판단하는 개발자의 안목입니다. C#의 풍부한 타입 시스템 기능들을 현명하게 활용하여 문제를 해결하고 가치를 창출하는 것이 진정한 전문가의 길입니다.