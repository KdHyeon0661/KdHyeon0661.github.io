---
layout: post
title: DB - JOIN
date: 2025-02-28 20:20:23 +0900
category: DB
---
# 표준 조인(ANSI Standard Join)

## 0) 왜 ‘표준 조인’인가?

- **가독성/유지보수**: 조인 조건을 `ON`에, 행 필터를 `WHERE`에 **명확히 분리** → 읽기·리뷰·수정이 쉬움
- **정확성**: OUTER JOIN에서 `WHERE`의 부주의로 **NULL 보존이 깨지는 사고**를 예방
- **호환성**: Oracle / PostgreSQL / MySQL / SQL Server 등 **RDBMS 전반**에서 일관된 문법
- **표현력**: `INNER | LEFT | RIGHT | FULL | CROSS | SELF`를 **구문으로 명시** → 의도가 코드에 드러남

---

## 1) 기본 구조와 비교 — 표준 vs 전통

### 1.1 표준(ANSI-92+) 조인

```sql
SELECT e.emp_id, e.name, d.dept_name
FROM Employee  AS e
INNER JOIN Department AS d
  ON d.dept_id = e.dept_id
WHERE e.active = 1
ORDER BY d.dept_name, e.name;
```

### 1.2 전통(쉼표 + WHERE) — 지양

```sql
SELECT e.emp_id, e.name, d.dept_name
FROM Employee e, Department d
WHERE d.dept_id = e.dept_id        -- 조인 조건이 WHERE에 섞여 있음
  AND e.active = 1;
```

**핵심 차이**  
- 표준은 “조인 자체의 정의(ON)”와 “최종 필터(WHERE)”가 분리되어 **실수를 줄인다**.  
- 전통 방식은 OUTER JOIN 로직과 섞이면 **버그**를 유발하기 쉽다.

---

## 2) 표준 조인의 종류와 정확한 용도

| 종류 | 의미 | 전형적 사용 |
|---|---|---|
| `INNER JOIN` | 양쪽 모두 매칭되는 행 | 가장 빈번, 정규화 복원 |
| `LEFT OUTER JOIN` | 왼쪽을 보존, 오른쪽 없으면 NULL | 기준 목록 보존, “누락 탐지” |
| `RIGHT OUTER JOIN` | 오른쪽을 보존 | 좌→우 읽기를 선호하면 드묾 |
| `FULL OUTER JOIN` | 양쪽 모두 보존 | 재무 조정·대사, 차이 탐지 |
| `CROSS JOIN` | 데카르트 곱 | 조합 생성, 캘린더 결합 |
| `SELF JOIN` | 자기 자신과 조인 | 상사-직원, 계층 구조, 이전 상태 비교 |

> **MySQL**: `FULL OUTER JOIN` 미지원 → 아래 **에뮬레이션** 참고.

---

## 3) ON vs WHERE — OUTER JOIN에서의 ‘생존선’

OUTER JOIN에서 **오른쪽(또는 왼쪽) 테이블의 조건을 WHERE에 두면** 보존된 NULL 행이 제거되어 **사실상 INNER JOIN처럼 동작**한다.

### 3.1 잘못된 예

```sql
SELECT d.dept_id, e.emp_id
FROM Department d
LEFT JOIN Employee e
  ON e.dept_id = d.dept_id
WHERE e.status = 'ACTIVE';           -- NULL 제거 → LEFT 의미 상실
```

### 3.2 올바른 예

```sql
SELECT d.dept_id, e.emp_id
FROM Department d
LEFT JOIN Employee e
  ON e.dept_id = d.dept_id
 AND e.status  = 'ACTIVE'            -- 조건을 ON으로 옮겨 NULL 보존 유지
WHERE d.region = 'APAC';             -- 왼쪽 필터는 WHERE에 안전
```

> **규칙**: OUTER JOIN의 “보존될 쪽”이 아닌 테이블의 필터는 **가능한 ON**에 둔다.

---

## 4) USING / NATURAL — 써도 되지만, 써야 할까?

- `USING(col)` : 두 테이블에 **동일 이름의 컬럼**이 있을 때 축약 표기
- `NATURAL JOIN` : 공통 컬럼을 **자동** 매칭 → 스키마 변경에 **매우 취약**(실무 비권장)

```sql
-- USING: 축약은 되지만, 명시성은 ON이 더 낫다.
SELECT *
FROM A
JOIN B USING (id);

-- 권장: ON으로 명시
SELECT *
FROM A
JOIN B ON B.id = A.id;
```

---

## 5) FULL OUTER JOIN — MySQL 등에서의 안전한 에뮬레이션

```sql
-- FULL OUTER JOIN 대체: LEFT + RIGHT ... WHERE left is null
SELECT A.id, A.col AS a_col, B.col AS b_col
FROM A
LEFT JOIN B ON B.id = A.id

UNION ALL

SELECT B.id, NULL AS a_col, B.col AS b_col
FROM B
LEFT JOIN A ON A.id = B.id
WHERE A.id IS NULL;
```

- `UNION ALL`을 쓰고 **중복을 발생시키지 않는 조건**(`WHERE A.id IS NULL`)으로 결합  
- 필요하다면 `UNION`으로 중복 제거(성능 비용↑)

---

## 6) 세미/안티 조인 — EXISTS / NOT EXISTS 패턴

“오른쪽 값을 가져오지 않고 **존재 여부만**으로 필터링” = **세미 조인**  
“존재하지 않는 것만” = **안티 조인**

```sql
-- 주문이 1건 이상 있는 고객 (세미 조인)
SELECT c.customer_id
FROM Customer c
WHERE EXISTS (
  SELECT 1 FROM Orders o
  WHERE o.customer_id = c.customer_id
);

-- 주문이 전혀 없는 고객 (안티 조인)
SELECT c.customer_id
FROM Customer c
WHERE NOT EXISTS (
  SELECT 1 FROM Orders o
  WHERE o.customer_id = c.customer_id
);
```

> `NOT IN`은 NULL이 섞이면 **빈 결과**가 될 수 있으니, `NOT EXISTS`를 선호.

---

## 7) N:M 조인과 중복 곱 — 집계/Distinct 선행으로 ‘폭발’ 방지

N:M 조인에 **또 다른 축**이 붙으면 집계가 **과다** 계산된다.

```sql
-- 위험: 매출 합계가 곱셈으로 부풀 수 있음
SELECT SUM(oi.amount)
FROM Orders o
JOIN OrderItem oi ON oi.order_id = o.order_id
JOIN Campaign  c  ON c.product_id = oi.product_id;  -- 또 다른 축

-- 방어: 먼저 축소 (집계 또는 DISTINCT) 후 결합
WITH item AS (
  SELECT order_id, SUM(amount) AS amt
  FROM OrderItem
  GROUP BY order_id
)
SELECT SUM(i.amt)
FROM Orders o
JOIN item i ON i.order_id = o.order_id;
```

---

## 8) 데이터 타입/정렬 방식/Collation/암묵적 캐스팅 — ‘묵시적 함정’ 제거

- **타입 불일치**(예: `VARCHAR` vs `INT`)는 **인덱스 무력화**·불필요 정렬을 유발  
- **Collation/대소문자 민감성** 차이로 조인 시 **미세 불일치** 발생  
- **암묵적 캐스팅**은 표현식 조인을 만들어 **비-SARGable**(인덱스 미사용)해질 수 있다.

```sql
-- 나쁜 예: 캐스팅이 오른쪽(인덱스 컬럼)에 걸리면 인덱스 사용 불가
JOIN B ON CAST(B.key AS VARCHAR(50)) = A.key

-- 좋은 예: 키 표준화(계산열/저장열)로 양쪽 타입/길이 일치
JOIN B ON B.key = A.key
```

---

## 9) 조인 알고리즘과 선택 — NL / Hash / Merge

- **Nested Loops (NL)**: 작은 외측 + 인덱스 탐색에 유리  
- **Hash Join**: 대량 동등조인, 인덱스 불필요(메모리/스필 주의)  
- **Merge Join**: 양쪽이 정렬(또는 인덱스-정렬) 상태면 매우 효율

```sql
-- 인덱스 기반 NL의 전형
SELECT ...
FROM Customer c                    -- 외측(작음)
JOIN Orders   o
  ON o.customer_id = c.customer_id -- o.customer_id 인덱스
WHERE c.region = 'KR';
```

**요령**  
- “**입력 크기를 줄여라**”: 선택도 높은 WHERE/ON, 집계/Distinct 선행  
- “**정렬 재사용**”: 인덱스 순서/방향을 ORDER BY와 맞춰 Merge/정렬 비용 절감

---

## 10) 인덱싱 전략 — FK/복합/커버링

- **외래키(FK) 측 인덱스**는 **필수**  
- 함께 자주 쓰는 필터/정렬 컬럼은 **복합 인덱스 선두**에  
- **커버링 인덱스**로 테이블 랜덤 I/O 제거

```sql
-- 자주 쓰는 패턴: 고객별 최근 주문
CREATE INDEX ix_orders_cust_dt ON Orders(customer_id, order_dt DESC);

SELECT o.order_id, o.order_dt
FROM Customer c
JOIN Orders   o
  ON o.customer_id = c.customer_id
WHERE c.customer_id = :id
ORDER BY o.order_dt DESC
FETCH FIRST 10 ROWS ONLY;
```

---

## 11) 파티셔닝과 조인 — 프루닝이 전부다

- 파티션 키가 **조인/필터**에 반영되어야 **프루닝**이 작동  
- 월 단위 로그·매출 등에서 **동월 조인**은 파티션 동명 키로 묶어 I/O를 절감

```sql
SELECT *
FROM Sales_2025 s
JOIN Refund_2025 r
  ON r.order_id = s.order_id
WHERE s.sales_month = '2025-10'   -- 프루닝 후보
  AND r.sales_month = '2025-10';
```

---

## 12) 키셋 페이징 — OFFSET을 조인에 들이밀지 말라

대형 테이블 조인 + `ORDER BY` + `OFFSET 100000` → **매우 느림**.  
**키셋 페이징**(상태ful 커서)로 치환.

```sql
-- (o.order_dt, o.order_id)가 결정적 정렬 키
SELECT o.order_id, o.order_dt, c.name
FROM Orders o
JOIN Customer c ON c.customer_id = o.customer_id
WHERE (o.order_dt, o.order_id) < (:last_dt, :last_id)
ORDER BY o.order_dt DESC, o.order_id DESC
LIMIT 50;
```

---

## 13) 창 함수(윈도 함수)와 조인 — 리포팅 최적 패턴

```sql
WITH sales_30 AS (
  SELECT s.product_id, s.amount, s.order_dt::date AS d
  FROM Sales s
  WHERE s.order_dt >= CURRENT_DATE - INTERVAL '30 DAY'
),
agg AS (
  SELECT product_id,
         SUM(amount) AS total,
         ROW_NUMBER() OVER (ORDER BY SUM(amount) DESC) AS rn
  FROM sales_30
  GROUP BY product_id
)
SELECT a.product_id, a.total, p.product_name
FROM agg a
JOIN Product p ON p.product_id = a.product_id
WHERE a.rn <= 20
ORDER BY a.total DESC;
```

- **집계→조인 순서**로 중간 데이터 축소  
- 윈도 함수는 `GROUP BY`와 달리 **그룹을 깨지 않고** 순위·누계를 제공

---

## 14) 달력/시계열과 CROSS JOIN — 분석의 골격 만들기

```sql
-- 날짜 축을 먼저 만들고 LEFT JOIN으로 결손일을 0으로 채우는 전형
WITH calendar AS (
  SELECT d::date AS d
  FROM generate_series(date '2025-10-01', date '2025-10-31', interval '1 day') AS g(d)
)
SELECT c.d,
       COALESCE(SUM(s.amount), 0) AS daily_sales
FROM calendar c
LEFT JOIN Sales s
  ON s.order_dt::date = c.d
GROUP BY c.d
ORDER BY c.d;
```

---

## 15) SELF JOIN — 이전 상태 비교/계층

```sql
-- 전일 대비 증감
SELECT t.today_dt, t.value AS today, y.value AS yesterday
FROM Metric t
LEFT JOIN Metric y
  ON y.metric_id = t.metric_id
 AND y.today_dt  = t.today_dt - INTERVAL '1 day'
WHERE t.metric_id = :id
ORDER BY t.today_dt;

-- 조직 계층(간단)
SELECT e.emp_id, e.name, m.name AS manager
FROM Employee e
LEFT JOIN Employee m
  ON m.emp_id = e.manager_id;
```

---

## 16) 집합 연산(UNION/INTERSECT/EXCEPT) vs JOIN — 언제 무엇을?

- **JOIN**: 열을 **가로**로 붙임(관계 복원)  
- **UNION**: 행을 **세로**로 합침(유사 스키마 집계/합병)  
- **INTERSECT/EXCEPT**: 공통/차집합 → **존재 비교**에는 `EXISTS`가 더 자연스러울 때도 많다.

```sql
-- “양쪽 모두 존재”는 INNER JOIN 또는 INTERSECT로 표현 가능
SELECT id FROM A
INTERSECT
SELECT id FROM B;  -- 키만 필요하면 간결
```

---

## 17) 실행 계획 읽기(요점)

- **조인 순서**: 드라이빙 테이블(외측) → 프로브(내측)  
- **조인 방식**: NL/Hash/Merge 선택 이유(인덱스, 정렬, 통계)  
- **필터 푸시다운**: WHERE/ON의 조건이 **얼마나 초기에** 적용되는가  
- **인덱스 사용**: Range/Seek(좋음) vs Full Scan(비용↑)

> 통계 최신화(`ANALYZE`, `DBMS_STATS`)는 계획 품질의 전제.

---

## 18) 실전 시나리오 ① — “최근 30일, 카테고리별 매출 Top-5”

```sql
WITH fact AS (  -- 1) 기간으로 사실 축소
  SELECT s.product_id, s.customer_id, s.order_dt::date AS d, s.amount
  FROM Sales s
  WHERE s.order_dt >= CURRENT_DATE - INTERVAL '30 DAY'
),
prod_cat AS (   -- 2) 브리지 중복 제거
  SELECT DISTINCT pc.product_id, pc.category_id
  FROM ProductCategory pc
),
agg_prod AS (   -- 3) 상품 단위 집계 선행
  SELECT product_id,
         COUNT(DISTINCT customer_id) AS customers,
         SUM(amount) AS sales,
         MIN(d) AS first_date,
         MAX(d) AS last_date
  FROM fact
  GROUP BY product_id
),
cat_prod AS (   -- 4) 집계→조인으로 입력 축소
  SELECT pc.category_id, a.*
  FROM agg_prod a
  JOIN prod_cat pc ON pc.product_id = a.product_id
),
ranked AS (     -- 5) 카테고리별 순위
  SELECT category_id, product_id, customers, sales, first_date, last_date,
         ROW_NUMBER() OVER (PARTITION BY category_id ORDER BY sales DESC, product_id) AS rn
  FROM cat_prod
)
SELECT category_id, product_id, sales, customers, first_date, last_date
FROM ranked
WHERE rn <= 5
ORDER BY category_id, sales DESC;
```

**포인트**: **집계 선행**, **중복 제거**, **윈도 함수**.

---

## 19) 실전 시나리오 ② — “왼쪽 보존 + 상태 조건”의 안전 처리

```sql
SELECT d.dept_id, d.dept_name, e.emp_id
FROM Department d
LEFT JOIN Employee e
  ON e.dept_id = d.dept_id
 AND e.status  = 'ACTIVE'    -- ON으로
WHERE d.region = 'APAC';
```

- 오른쪽 조건을 WHERE로 내리면 NULL이 사라져 **INNER처럼** 된다.

---

## 20) 체크리스트 — 정확성·성능·유지보수

### 정확성
- [ ] 1:1 / 1:N / N:M **카디널리티 파악**  
- [ ] OUTER JOIN의 조건은 **ON**에  
- [ ] N:M 곱 주의 → **집계/Distinct 선행**  
- [ ] 타입/Collation **정렬·대소문자** 일치  
- [ ] 테스트 데이터에 **경계값/NULL** 포함

### 성능
- [ ] **조인 키 인덱스**(특히 FK 측)  
- [ ] **선택도 높은 필터**를 **조기에**  
- [ ] NL/Hash/Merge **상황별 선택**  
- [ ] **파티셔닝 프루닝** 유도  
- [ ] **키셋 페이징**(OFFSET 지양)  
- [ ] 통계 최신화 + 실행 계획 점검

### 유지보수
- [ ] **명시적 JOIN ... ON**만 사용  
- [ ] **필요 컬럼만** 투영 (`SELECT *` 지양)  
- [ ] 테이블 **별칭** 일관 사용  
- [ ] `USING/NATURAL` 남용 금지(스키마 변화 취약)

---

## 21) 추가 패턴 — LATERAL / APPLY(심화)

- PostgreSQL `LATERAL`, SQL Server `CROSS/OUTER APPLY`로 “행별 상위 N” 등 **상관 서브쿼리의 튜닝**이 가능

```sql
-- SQL Server: 고객별 최근 주문 1건
SELECT c.customer_id, o.order_id, o.order_dt
FROM Customer c
OUTER APPLY (
  SELECT TOP (1) order_id, order_dt
  FROM Orders o
  WHERE o.customer_id = c.customer_id
  ORDER BY order_dt DESC
) AS o;
```

> 표준 조인 개념을 그대로 유지하되, **행별 하위 셋 결합**에 유용.

---

## 22) 재현용 미니 스키마 & 시드

```sql
-- 공통 스키마(ANSI 호환)
CREATE TABLE Department (
  dept_id   INT PRIMARY KEY,
  dept_name VARCHAR(100),
  region    VARCHAR(10)
);

CREATE TABLE Employee (
  emp_id    INT PRIMARY KEY,
  name      VARCHAR(100),
  dept_id   INT,
  status    VARCHAR(10),
  active    BOOLEAN,
  FOREIGN KEY (dept_id) REFERENCES Department(dept_id)
);

INSERT INTO Department(dept_id, dept_name, region) VALUES
(10, 'Sales', 'APAC'), (20, 'R&D', 'APAC'), (30, 'HR', 'EMEA');

INSERT INTO Employee(emp_id, name, dept_id, status, active) VALUES
(1, 'Kim', 10, 'ACTIVE', TRUE),
(2, 'Lee', 10, 'INACTIVE', FALSE),
(3, 'Park', 20, 'ACTIVE', TRUE);
```

이 스키마로 본문 모든 예제를 **즉시 실험**할 수 있다.

---

## 23) 자주 하는 실수 — 7선 요약

| 실수 | 결과 | 대안 |
|---|---|---|
| OUTER JOIN 후 WHERE에서 오른쪽 필터 | NULL 보존 상실 | 오른쪽 필터는 `ON` |
| N:M에서 곱 고려 없음 | 집계 과대계상 | 집계/Distinct 선행 |
| 타입/Collation 불일치 | 인덱스 미사용/불일치 | 키 표준화(계산열/타입 통일) |
| 조인 키 인덱스 누락 | 풀스캔/랜덤I/O | FK/조인 키 인덱스 |
| NATURAL/USING 남용 | 스키마 변경 취약 | `JOIN ... ON` 명시 |
| OFFSET 대용량 페이징 | 후반 페이지 급격히 느림 | 키셋 페이징 |
| SELECT * | I/O/네트워크 낭비 | 필요한 컬럼만 |

---

## 결론

- **표준 조인(ANSI)**은 “정확성(ON vs WHERE)·성능(NL/Hash/Merge+인덱스)·유지보수(명시성)”를 **동시에** 잡는 최선의 습관이다.  
- 대형/복잡 조인일수록 **입력 축소(필터/집계/프루닝) → 적합 알고리즘 → 정렬/인덱스 재사용**을 체화하라.  
- 항상 **명시적 `JOIN ... ON`**, **필요 컬럼만 투영**, **실행계획 확인**으로 사고를 줄이고 속도를 얻는다.
