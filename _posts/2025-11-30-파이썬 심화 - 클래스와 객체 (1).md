---
layout: post
title: 파이썬 심화 - 클래스와 객체 (1)
date: 2025-11-30 15:25:23 +0900
category: 파이썬 심화
---
# 클래스와 객체 (1)

## 인스턴스의 문자열 표현식 변형

파이썬 객체는 `__str__()`과 `__repr__()` 메서드를 통해 사용자 정의 문자열 표현을 제공할 수 있습니다. 이는 디버깅, 로깅, 사용자 인터페이스 등에서 객체를 이해하기 쉽게 표현하는 데 필수적입니다.

### 기본적인 문자열 표현 메서드

```python
def basic_string_representation():
    """기본적인 문자열 표현 메서드 구현"""
    
    print("=== 기본 문자열 표현 메서드 ===")
    
    class Product:
        """상품 클래스 - 문자열 표현 구현"""
        
        def __init__(self, name: str, price: float, category: str = "일반"):
            self.name = name
            self.price = price
            self.category = category
            self.created_at = "2024-01-03"
        
        def __str__(self) -> str:
            """사용자를 위한 읽기 쉬운 문자열 표현"""
            return f"{self.name} - ₩{self.price:,.0f} ({self.category})"
        
        def __repr__(self) -> str:
            """개발자를 위한 명확한 문자열 표현 (디버깅용)"""
            return f"Product(name={repr(self.name)}, price={self.price}, category={repr(self.category)})"
        
        def __format__(self, format_spec: str) -> str:
            """format() 함수와 f-string을 위한 포맷팅 지원"""
            if format_spec == "short":
                return f"{self.name[:10]}... - ₩{self.price:,.0f}"
            elif format_spec == "detail":
                return f"상품명: {self.name}\n가격: ₩{self.price:,.0f}\n카테고리: {self.category}"
            else:
                # 기본 포맷
                return str(self)
    
    print("1. 기본 문자열 표현:")
    product = Product("애플 맥북 프로 16인치", 3290000, "전자제품")
    
    print(f"  str(): {str(product)}")
    print(f"  repr(): {repr(product)}")
    print(f"  print(): ", end="")
    print(product)  # 자동으로 __str__() 호출
    
    print("\n2. 다양한 포맷팅:")
    print(f"  format(product): {format(product)}")
    print(f"  format(product, 'short'): {format(product, 'short')}")
    print(f"  format(product, 'detail'):\n{format(product, 'detail')}")
    print(f"  f-string: {product}")
    
    print("\n3. 컬렉션에서의 표현:")
    products = [
        Product("아이폰 15 프로", 1550000, "스마트폰"),
        Product("갤럭시 북3 프로", 2190000, "노트북"),
        Product("소니 헤드폰", 349000, "음향기기")
    ]
    
    print(f"  리스트 str: {products}")  # __repr__() 사용
    print(f"  리스트 내용:")
    for p in products:
        print(f"    - {p}")  # 각 요소의 __str__() 사용
    
    # 4. __repr__의 중요성
    print("\n4. __repr__의 중요성 (eval()로 재생성 가능):")
    
    class Point:
        """간단한 좌표 클래스"""
        
        def __init__(self, x: float, y: float):
            self.x = x
            self.y = y
        
        def __repr__(self):
            return f"Point({self.x}, {self.y})"
        
        def __str__(self):
            return f"({self.x}, {self.y})"
    
    point = Point(3.5, 4.2)
    print(f"  원본: {point}")
    print(f"  repr: {repr(point)}")
    
    # repr 출력을 eval로 재생성
    point_repr = repr(point)
    print(f"  repr 문자열: {point_repr}")
    
    try:
        recreated_point = eval(point_repr)
        print(f"  재생성된 객체: {recreated_point}")
        print(f"  동일한가? {point.x == recreated_point.x and point.y == recreated_point.y}")
    except:
        print("  보안상의 이유로 eval 실행을 생략합니다.")

basic_string_representation()
```

### 고급 문자열 표현 기법

```python
def advanced_string_representation():
    """고급 문자열 표현 기법"""
    
    print("\n=== 고급 문자열 표현 기법 ===")
    
    # 1. 다국어 문자열 표현
    class MultilingualProduct:
        """다국어 지원 상품 클래스"""
        
        def __init__(self, name_ko: str, name_en: str, price: float):
            self.name_ko = name_ko
            self.name_en = name_en
            self.price = price
            self._language = "ko"  # 기본 언어
        
        def set_language(self, lang: str):
            """표현 언어 설정"""
            if lang in ["ko", "en"]:
                self._language = lang
            else:
                raise ValueError("지원 언어: 'ko' 또는 'en'")
        
        def __str__(self) -> str:
            """현재 언어 설정에 따른 문자열 표현"""
            if self._language == "ko":
                return f"{self.name_ko} - ₩{self.price:,.0f}"
            else:
                return f"{self.name_en} - ${self.price:,.2f}"
        
        def __repr__(self) -> str:
            """개발자용 표현 (언어 무관)"""
            return f"MultilingualProduct(name_ko={repr(self.name_ko)}, name_en={repr(self.name_en)}, price={self.price})"
        
        def __format__(self, format_spec: str) -> str:
            """확장된 포맷팅 지원"""
            if format_spec == "both":
                return f"{self.name_ko} / {self.name_en} - ₩{self.price:,.0f}"
            elif format_spec == "json":
                import json
                return json.dumps({
                    "name_ko": self.name_ko,
                    "name_en": self.name_en,
                    "price": self.price
                }, ensure_ascii=False)
            else:
                return str(self)
    
    print("1. 다국어 문자열 표현:")
    product = MultilingualProduct("스마트폰", "Smartphone", 999.99)
    
    print(f"  기본(한국어): {product}")
    product.set_language("en")
    print(f"  영어 설정: {product}")
    product.set_language("ko")
    print(f"  한국어로 복원: {product}")
    
    print(f"  포맷 'both': {format(product, 'both')}")
    print(f"  포맷 'json': {format(product, 'json')}")
    
    # 2. 동적 문자열 생성을 위한 __str__ 구현
    class DynamicStringObject:
        """실행 시점에 동적으로 문자열 생성"""
        
        def __init__(self, data: dict):
            self.data = data
            self._cache = {}  # 문자열 캐시
        
        def __str__(self) -> str:
            """동적 문자열 생성"""
            cache_key = "str_" + str(id(self.data))
            
            if cache_key not in self._cache:
                # 복잡한 문자열 생성 로직
                parts = []
                for key, value in self.data.items():
                    if isinstance(value, (int, float)):
                        parts.append(f"{key}: {value:,}")
                    elif isinstance(value, str):
                        parts.append(f"{key}: '{value}'")
                    else:
                        parts.append(f"{key}: {value}")
                
                self._cache[cache_key] = " | ".join(parts)
            
            return self._cache[cache_key]
        
        def __repr__(self) -> str:
            """더 간단한 repr"""
            return f"DynamicStringObject(data_keys={list(self.data.keys())})"
        
        def clear_cache(self):
            """캐시 초기화"""
            self._cache.clear()
    
    print("\n2. 동적 문자열 생성:")
    data_obj = DynamicStringObject({
        "id": 12345,
        "name": "테스트 객체",
        "value": 987654.321,
        "count": 1000,
        "active": True
    })
    
    print(f"  동적 문자열: {data_obj}")
    # 같은 객체에 대해 __str__이 여러 번 호출되어도 캐시 사용
    print(f"  다시 호출: {data_obj}")
    
    # 3. 계층적 객체의 문자열 표현
    class TreeNode:
        """트리 구조의 노드 - 계층적 문자열 표현"""
        
        def __init__(self, value, children=None):
            self.value = value
            self.children = children or []
        
        def __str__(self, level=0, prefix="") -> str:
            """계층적 문자열 표현"""
            result = []
            
            # 현재 노드
            indent = "  " * level
            node_str = f"{indent}{prefix}{self.value}"
            result.append(node_str)
            
            # 자식 노드들
            for i, child in enumerate(self.children):
                is_last = (i == len(self.children) - 1)
                child_prefix = "└── " if is_last else "├── "
                result.append(child.__str__(level + 1, child_prefix))
            
            return "\n".join(result)
        
        def __repr__(self) -> str:
            return f"TreeNode(value={repr(self.value)}, children_count={len(self.children)})"
    
    print("\n3. 계층적 객체 표현:")
    # 트리 구조 생성
    root = TreeNode("Root")
    child1 = TreeNode("Child 1")
    child2 = TreeNode("Child 2")
    grandchild1 = TreeNode("Grandchild 1.1")
    grandchild2 = TreeNode("Grandchild 1.2")
    grandchild3 = TreeNode("Grandchild 2.1")
    
    child1.children = [grandchild1, grandchild2]
    child2.children = [grandchild3]
    root.children = [child1, child2]
    
    print(f"  트리 구조:\n{root}")
    print(f"  repr: {repr(root)}")
    
    # 4. 다양한 출력 형식 지원
    class ConfigurableFormatter:
        """출력 형식을 구성 가능한 객체"""
        
        def __init__(self, data, formatter=None):
            self.data = data
            self.formatter = formatter or self._default_formatter
        
        def _default_formatter(self, data):
            """기본 포맷터"""
            return str(data)
        
        def __str__(self):
            return self.formatter(self.data)
        
        def set_formatter(self, formatter_func):
            """포맷터 함수 설정"""
            self.formatter = formatter_func
        
        @staticmethod
        def create_table_formatter(headers):
            """테이블 형식 포맷터 생성"""
            def formatter(data_list):
                if not data_list:
                    return "데이터 없음"
                
                # 컬럼 너비 계산
                col_widths = []
                for i in range(len(headers)):
                    max_len = len(headers[i])
                    for row in data_list:
                        if i < len(row):
                            max_len = max(max_len, len(str(row[i])))
                    col_widths.append(max_len + 2)  # 여백 추가
                
                # 헤더 생성
                header_parts = []
                for i, header in enumerate(headers):
                    header_parts.append(f"{header:<{col_widths[i]}}")
                result = ["".join(header_parts), "-" * sum(col_widths)]
                
                # 데이터 행 생성
                for row in data_list:
                    row_parts = []
                    for i, cell in enumerate(row):
                        row_parts.append(f"{str(cell):<{col_widths[i]}}")
                    result.append("".join(row_parts))
                
                return "\n".join(result)
            
            return formatter
    
    print("\n4. 구성 가능한 포맷터:")
    
    # 테스트 데이터
    sales_data = [
        ["2024-01-01", "노트북", 3, 4500000],
        ["2024-01-02", "스마트폰", 5, 7750000],
        ["2024-01-03", "태블릿", 2, 1800000]
    ]
    
    # 테이블 포맷터 생성
    table_formatter = ConfigurableFormatter.create_table_formatter(
        ["날짜", "제품", "수량", "매출"]
    )
    
    formatter_obj = ConfigurableFormatter(sales_data, table_formatter)
    print(f"  테이블 형식:\n{formatter_obj}")
    
    # CSV 형식 포맷터
    csv_formatter = lambda data: "\n".join([",".join(map(str, row)) for row in data])
    formatter_obj.set_formatter(csv_formatter)
    print(f"\n  CSV 형식:\n{formatter_obj}")

advanced_string_representation()
```

## 문자열 서식화 조절

`__format__()` 메서드를 통해 객체가 `format()` 함수와 f-string에서 어떻게 포맷팅될지 완전히 제어할 수 있습니다.

### 커스텀 포맷팅 구현

```python
def custom_formatting_control():
    """커스텀 문자열 포맷팅 구현"""
    
    print("\n=== 커스텀 문자열 포맷팅 ===")
    
    # 1. 기본적인 __format__ 구현
    class FormattableNumber:
        """사용자 정의 숫자 포맷팅"""
        
        def __init__(self, value):
            self.value = value
        
        def __format__(self, format_spec):
            """format() 함수와 f-string 지원"""
            if not format_spec:
                # 기본 포맷
                return str(self.value)
            
            # 사용자 정의 포맷 지정자 처리
            if format_spec.startswith("bin"):
                # 이진수 포맷
                width = int(format_spec[3:]) if len(format_spec) > 3 else 8
                return format(self.value, f'0{width}b')
            elif format_spec.startswith("hex"):
                # 16진수 포맷
                width = int(format_spec[3:]) if len(format_spec) > 3 else 4
                return format(self.value, f'0{width}X')
            elif format_spec.startswith("money"):
                # 통화 포맷
                currency = format_spec[5:] if len(format_spec) > 5 else "KRW"
                if currency == "KRW":
                    return f"₩{self.value:,.0f}"
                elif currency == "USD":
                    return f"${self.value:,.2f}"
                elif currency == "EUR":
                    return f"€{self.value:,.2f}"
                else:
                    return f"{self.value:,.2f} {currency}"
            elif format_spec.startswith("si"):
                # SI 단위 접두사
                value = self.value
                prefixes = ["", "K", "M", "G", "T"]
                prefix_index = 0
                
                while value >= 1000 and prefix_index < len(prefixes) - 1:
                    value /= 1000
                    prefix_index += 1
                
                precision = int(format_spec[2:]) if len(format_spec) > 2 else 1
                return f"{value:.{precision}f}{prefixes[prefix_index]}"
            else:
                # 표준 숫자 포맷팅으로 폴백
                try:
                    return format(self.value, format_spec)
                except:
                    return str(self.value)
        
        def __str__(self):
            return str(self.value)
    
    print("1. 커스텀 숫자 포맷팅:")
    num = FormattableNumber(1234567.89)
    
    print(f"  기본: {num}")
    print(f"  format(num): {format(num)}")
    print(f"  format(num, '.2f'): {format(num, '.2f')}")
    print(f"  format(num, 'bin'): {format(num, 'bin')}")
    print(f"  format(num, 'bin16'): {format(num, 'bin16')}")
    print(f"  format(num, 'hex'): {format(num, 'hex')}")
    print(f"  format(num, 'money'): {format(num, 'money')}")
    print(f"  format(num, 'moneyUSD'): {format(num, 'moneyUSD')}")
    print(f"  format(num, 'si'): {format(num, 'si')}")
    print(f"  format(num, 'si2'): {format(num, 'si2')}")
    
    # f-string에서도 동작
    print(f"  f-string: {num:moneyEUR}")
    
    # 2. 날짜/시간 커스텀 포맷팅
    class SmartDateTime:
        """지능형 날짜/시간 포맷팅"""
        
        def __init__(self, year, month, day, hour=0, minute=0, second=0):
            self.year = year
            self.month = month
            self.day = day
            self.hour = hour
            self.minute = minute
            self.second = second
        
        def __format__(self, format_spec):
            """다양한 날짜 포맷 지원"""
            from datetime import datetime
            
            dt = datetime(self.year, self.month, self.day, 
                         self.hour, self.minute, self.second)
            
            # 커스텀 포맷 지정자
            if format_spec == "iso":
                return dt.isoformat()
            elif format_spec == "human":
                # 사람이 읽기 쉬운 형식
                month_names = ["1월", "2월", "3월", "4월", "5월", "6월",
                              "7월", "8월", "9월", "10월", "11월", "12월"]
                return f"{self.year}년 {month_names[self.month-1]} {self.day}일"
            elif format_spec == "short":
                return dt.strftime("%y-%m-%d")
            elif format_spec == "time":
                return dt.strftime("%H:%M:%S")
            elif format_spec == "full":
                return dt.strftime("%Y년 %m월 %d일 %A %H시 %M분 %S초")
            elif format_spec == "relative":
                # 상대적 시간 표시 (간단한 버전)
                from datetime import datetime as dt_now
                now = dt_now.now()
                diff = now - dt
                
                if diff.days > 365:
                    years = diff.days // 365
                    return f"{years}년 전"
                elif diff.days > 30:
                    months = diff.days // 30
                    return f"{months}개월 전"
                elif diff.days > 0:
                    return f"{diff.days}일 전"
                elif diff.seconds > 3600:
                    hours = diff.seconds // 3600
                    return f"{hours}시간 전"
                elif diff.seconds > 60:
                    minutes = diff.seconds // 60
                    return f"{minutes}분 전"
                else:
                    return "방금 전"
            elif format_spec:
                # 표준 strftime 형식으로 폴백
                try:
                    return dt.strftime(format_spec)
                except:
                    return str(dt)
            else:
                # 기본 포맷
                return dt.strftime("%Y-%m-%d %H:%M:%S")
        
        def __str__(self):
            return format(self, "")
    
    print("\n2. 지능형 날짜 포맷팅:")
    dt = SmartDateTime(2024, 1, 3, 14, 30, 45)
    
    print(f"  기본: {dt}")
    print(f"  iso: {format(dt, 'iso')}")
    print(f"  human: {format(dt, 'human')}")
    print(f"  short: {format(dt, 'short')}")
    print(f"  time: {format(dt, 'time')}")
    print(f"  full: {format(dt, 'full')}")
    print(f"  relative: {format(dt, 'relative')}")
    print(f"  커스텀 형식: {format(dt, '%Y/%m/%d')}")
    
    # 3. 데이터 테이블 포맷팅
    class DataTable:
        """데이터 테이블 포맷팅 클래스"""
        
        def __init__(self, headers, rows):
            self.headers = headers
            self.rows = rows
            self.styles = {
                "border": True,
                "padding": 1,
                "alignment": "left"
            }
        
        def __format__(self, format_spec):
            """다양한 테이블 포맷 지원"""
            if format_spec == "markdown":
                return self._to_markdown()
            elif format_spec == "csv":
                return self._to_csv()
            elif format_spec == "html":
                return self._to_html()
            elif format_spec == "json":
                return self._to_json()
            elif format_spec.startswith("style="):
                # 스타일 지정
                style_params = format_spec[6:].split(",")
                for param in style_params:
                    if "=" in param:
                        key, value = param.split("=")
                        self.styles[key] = value
                return self._to_ascii_table()
            else:
                return self._to_ascii_table()
        
        def _to_ascii_table(self):
            """ASCII 테이블 생성"""
            # 컬럼 너비 계산
            col_widths = []
            for i, header in enumerate(self.headers):
                max_width = len(str(header))
                for row in self.rows:
                    if i < len(row):
                        max_width = max(max_width, len(str(row[i])))
                col_widths.append(max_width + self.styles["padding"] * 2)
            
            # 테이블 생성
            lines = []
            
            # 상단 경계선
            if self.styles.get("border", True):
                line_parts = []
                for width in col_widths:
                    line_parts.append("─" * width)
                lines.append("┌" + "┬".join(line_parts) + "┐")
            
            # 헤더 행
            cells = []
            for i, header in enumerate(self.headers):
                align = "<" if self.styles["alignment"] == "left" else "^" if self.styles["alignment"] == "center" else ">"
                cells.append(f"{str(header):{align}{col_widths[i] - self.styles['padding'] * 2}}")
            
            if self.styles.get("border", True):
                lines.append("│" + "│".join(cells) + "│")
            else:
                lines.append(" ".join(cells))
            
            # 헤더-데이터 구분선
            if self.styles.get("border", True):
                line_parts = []
                for width in col_widths:
                    line_parts.append("─" * width)
                lines.append("├" + "┼".join(line_parts) + "┤")
            
            # 데이터 행
            for row in self.rows:
                cells = []
                for i, cell in enumerate(row):
                    align = "<" if self.styles["alignment"] == "left" else "^" if self.styles["alignment"] == "center" else ">"
                    cells.append(f"{str(cell):{align}{col_widths[i] - self.styles['padding'] * 2}}")
                
                if self.styles.get("border", True):
                    lines.append("│" + "│".join(cells) + "│")
                else:
                    lines.append(" ".join(cells))
            
            # 하단 경계선
            if self.styles.get("border", True):
                line_parts = []
                for width in col_widths:
                    line_parts.append("─" * width)
                lines.append("└" + "┴".join(line_parts) + "┘")
            
            return "\n".join(lines)
        
        def _to_markdown(self):
            """마크다운 테이블 생성"""
            # 헤더
            header = "| " + " | ".join(self.headers) + " |"
            separator = "|" + "|".join(["---" for _ in self.headers]) + "|"
            
            # 데이터 행
            rows = []
            for row in self.rows:
                rows.append("| " + " | ".join(str(cell) for cell in row) + " |")
            
            return "\n".join([header, separator] + rows)
        
        def _to_csv(self):
            """CSV 형식 생성"""
            import csv
            import io
            
            output = io.StringIO()
            writer = csv.writer(output)
            writer.writerow(self.headers)
            writer.writerows(self.rows)
            
            return output.getvalue().strip()
        
        def _to_html(self):
            """HTML 테이블 생성"""
            html = ["<table border='1'>"]
            
            # 헤더
            html.append("  <thead>")
            html.append("    <tr>")
            for header in self.headers:
                html.append(f"      <th>{header}</th>")
            html.append("    </tr>")
            html.append("  </thead>")
            
            # 본문
            html.append("  <tbody>")
            for row in self.rows:
                html.append("    <tr>")
                for cell in row:
                    html.append(f"      <td>{cell}</td>")
                html.append("    </tr>")
            html.append("  </tbody>")
            html.append("</table>")
            
            return "\n".join(html)
        
        def _to_json(self):
            """JSON 형식 생성"""
            import json
            data = {
                "headers": self.headers,
                "rows": self.rows
            }
            return json.dumps(data, indent=2, ensure_ascii=False)
    
    print("\n3. 데이터 테이블 포맷팅:")
    
    # 테스트 데이터
    table = DataTable(
        ["이름", "나이", "직업", "급여"],
        [
            ["김철수", 30, "개발자", 50000000],
            ["이영희", 28, "디자이너", 45000000],
            ["박지원", 35, "매니저", 65000000]
        ]
    )
    
    print("  ASCII 테이블:")
    print(format(table))
    
    print("\n  마크다운:")
    print(format(table, "markdown"))
    
    print("\n  CSV:")
    print(format(table, "csv"))
    
    print("\n  스타일 변경:")
    print(format(table, "style=border=false,alignment=center"))

custom_formatting_control()
```

## 객체의 콘텍스트 관리 프로토콜 지원

`__enter__()`과 `__exit__()` 메서드를 구현하면 객체를 컨텍스트 관리자로 사용할 수 있습니다. 이는 리소스 관리, 트랜잭션 처리, 설정 변경 등에 유용합니다.

### 기본적인 컨텍스트 관리자

```python
def context_manager_protocol():
    """컨텍스트 관리자 프로토콜 구현"""
    
    print("\n=== 컨텍스트 관리자 프로토콜 ===")
    
    # 1. 기본적인 컨텍스트 관리자
    class Timer:
        """실행 시간 측정을 위한 컨텍스트 관리자"""
        
        def __init__(self, name="작업"):
            self.name = name
            self.start_time = None
            self.end_time = None
        
        def __enter__(self):
            """컨텍스트 진입 시 호출"""
            self.start_time = time.time()
            print(f"[{self.name}] 시작")
            return self  # as 절에 전달될 객체
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            """컨텍스트 탈출 시 호출"""
            self.end_time = time.time()
            elapsed = self.end_time - self.start_time
            
            print(f"[{self.name}] 종료 - 소요시간: {elapsed:.4f}초")
            
            # 예외 처리 (예외를 전파하지 않으려면 True 반환)
            if exc_type is not None:
                print(f"[{self.name}] 예외 발생: {exc_type.__name__}: {exc_val}")
                # True를 반환하면 예외가 전파되지 않음
                # return True
            
            # False 반환 (기본값) 또는 아무것도 반환하지 않으면 예외 전파
        
        def get_elapsed(self):
            """경과 시간 반환"""
            if self.start_time and self.end_time:
                return self.end_time - self.start_time
            elif self.start_time:
                return time.time() - self.start_time
            else:
                return 0.0
    
    print("1. 실행 시간 측정 타이머:")
    
    with Timer("데이터 처리") as timer:
        # 시뮬레이션: 시간이 걸리는 작업
        time.sleep(0.5)
        print("  데이터 처리 중...")
    
    print(f"  측정된 시간: {timer.get_elapsed():.4f}초")
    
    # 2. 예외가 발생하는 경우
    print("\n2. 예외 처리 테스트:")
    
    try:
        with Timer("위험한 작업") as timer2:
            print("  작업 시작...")
            raise ValueError("의도된 오류 발생!")
            print("  이 부분은 실행되지 않음")
    except ValueError as e:
        print(f"  예외 캐치: {e}")
    
    # 3. 파일 자동 관리 컨텍스트 관리자
    class ManagedFile:
        """파일 자동 관리를 위한 컨텍스트 관리자"""
        
        def __init__(self, filename, mode='r', encoding='utf-8'):
            self.filename = filename
            self.mode = mode
            self.encoding = encoding
            self.file = None
        
        def __enter__(self):
            """파일 열기"""
            print(f"  파일 열기: {self.filename}")
            self.file = open(self.filename, self.mode, encoding=self.encoding)
            return self.file
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            """파일 닫기"""
            if self.file:
                print(f"  파일 닫기: {self.filename}")
                self.file.close()
            
            # 예외가 발생했는지 로깅
            if exc_type is not None:
                print(f"  파일 작업 중 예외 발생: {exc_type.__name__}")
                # 예외 전파 (기본 동작)
    
    print("\n3. 파일 자동 관리:")
    
    # 테스트용 파일 생성
    test_content = "테스트 파일 내용\n두 번째 줄\n세 번째 줄"
    with open('test_context.txt', 'w', encoding='utf-8') as f:
        f.write(test_content)
    
    # 컨텍스트 관리자 사용
    with ManagedFile('test_context.txt', 'r') as f:
        content = f.read()
        print(f"  파일 내용:\n{content}")
    
    print("  컨텍스트를 벗어나면 파일이 자동으로 닫힘")
    
    # 4. 데이터베이스 트랜잭션 컨텍스트 관리자
    class DatabaseTransaction:
        """데이터베이스 트랜잭션 관리를 위한 컨텍스트 관리자"""
        
        def __init__(self, db_name="test.db"):
            self.db_name = db_name
            self.connection = None
            self.in_transaction = False
        
        def __enter__(self):
            """트랜잭션 시작"""
            print(f"[DB] 연결 시작: {self.db_name}")
            # 실제 구현에서는 데이터베이스 연결 생성
            self.connection = {"name": self.db_name, "connected": True}
            
            print("[DB] 트랜잭션 시작")
            self.in_transaction = True
            
            return self
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            """트랜잭션 종료 (커밋 또는 롤백)"""
            if exc_type is None:
                # 예외 없음 -> 커밋
                print("[DB] 트랜잭션 커밋")
                # 실제 구현: connection.commit()
            else:
                # 예외 발생 -> 롤백
                print(f"[DB] 트랜잭션 롤백 (예외: {exc_type.__name__})")
                # 실제 구현: connection.rollback()
            
            print("[DB] 연결 종료")
            self.connection["connected"] = False
            self.in_transaction = False
            
            # 예외 전파 (기본 동작)
        
        def execute(self, query, params=None):
            """쿼리 실행"""
            if not self.in_transaction:
                raise RuntimeError("트랜잭션이 시작되지 않았습니다")
            
            print(f"[DB] 쿼리 실행: {query}")
            if params:
                print(f"[DB] 파라미터: {params}")
            
            # 실제 구현: cursor.execute(query, params or ())
            return {"affected_rows": 1, "lastrowid": 100}
    
    print("\n4. 데이터베이스 트랜잭션:")
    
    # 성공적인 트랜잭션
    with DatabaseTransaction("app.db") as db:
        result = db.execute("INSERT INTO users (name, email) VALUES (?, ?)", 
                           ("김철수", "chulsoo@example.com"))
        print(f"  삽입 결과: {result}")
    
    # 예외 발생 시 롤백되는 트랜잭션
    try:
        with DatabaseTransaction("app.db") as db:
            result = db.execute("INSERT INTO products (name, price) VALUES (?, ?)", 
                               ("노트북", 1500000))
            print(f"  삽입 결과: {result}")
            
            # 의도적으로 예외 발생
            raise RuntimeError("시스템 오류 발생")
            
            # 이 부분은 실행되지 않음
            db.execute("UPDATE inventory SET quantity = quantity - 1 WHERE product_id = ?", 
                      (result["lastrowid"],))
    except RuntimeError as e:
        print(f"  예외 처리됨: {e}")

context_manager_protocol()
```

### 고급 컨텍스트 관리자 패턴

```python
def advanced_context_manager_patterns():
    """고급 컨텍스트 관리자 패턴"""
    
    print("\n=== 고급 컨텍스트 관리자 패턴 ===")
    
    # 1. 상태 변경 컨텍스트 관리자
    class SystemConfig:
        """시스템 설정을 임시 변경하는 컨텍스트 관리자"""
        
        def __init__(self, **config_changes):
            self.config_changes = config_changes
            self.original_config = {}
        
        def __enter__(self):
            """원래 설정 저장 후 새 설정 적용"""
            print("[시스템] 설정 변경 시작")
            
            # 현재 설정 저장 (시뮬레이션)
            self.original_config = {
                "log_level": "INFO",
                "timeout": 30,
                "max_connections": 100,
                "debug_mode": False
            }
            
            # 설정 변경 적용
            for key, value in self.config_changes.items():
                if key in self.original_config:
                    print(f"  {key}: {self.original_config[key]} -> {value}")
                else:
                    print(f"  {key}: (새 설정) -> {value}")
            
            # 실제 시스템 설정 변경 로직 (시뮬레이션)
            self.current_config = {**self.original_config, **self.config_changes}
            
            return self.current_config
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            """원래 설정 복원"""
            print("[시스템] 설정 복원")
            
            for key, value in self.original_config.items():
                print(f"  {key}: {self.current_config.get(key)} -> {value}")
            
            # 예외 처리
            if exc_type is not None:
                print(f"[시스템] 설정 변경 중 예외 발생: {exc_type.__name__}")
    
    print("1. 시스템 설정 임시 변경:")
    
    with SystemConfig(log_level="DEBUG", timeout=60, debug_mode=True) as config:
        print(f"  현재 설정: {config}")
        print("  디버그 모드에서 작업 수행 중...")
        # 설정이 변경된 상태에서 작업 수행
    
    print("  컨텍스트를 벗어나면 설정이 자동 복원됨")
    
    # 2. 중첩 컨텍스트 관리자
    class IndentedOutput:
        """들여쓰기 출력 컨텍스트 관리자"""
        
        def __init__(self, indent_level=0, prefix=""):
            self.indent_level = indent_level
            self.prefix = prefix
            self.original_print = print
        
        def __enter__(self):
            """들여쓰기 시작"""
            import builtins
            
            # print 함수 오버라이드
            def indented_print(*args, **kwargs):
                indent = "  " * self.indent_level
                self.original_print(indent + self.prefix, *args, **kwargs)
            
            # 현재 모듈의 print 함수 대체
            import sys
            self.module = sys.modules[__name__]
            self.original_module_print = getattr(self.module, 'print', None)
            setattr(self.module, 'print', indented_print)
            
            # builtins.print도 대체 (전역적 영향)
            self.original_builtins_print = builtins.print
            builtins.print = indented_print
            
            return self
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            """들여쓰기 종료"""
            import builtins
            
            # 원래 print 함수 복원
            if self.original_module_print:
                setattr(self.module, 'print', self.original_module_print)
            else:
                delattr(self.module, 'print')
            
            builtins.print = self.original_builtins_print
    
    print("\n2. 들여쓰기 출력 컨텍스트:")
    
    print("일반 출력")
    
    with IndentedOutput(indent_level=1, prefix=">>>"):
        print("들여쓰기 출력 1")
        print("들여쓰기 출력 2")
        
        with IndentedOutput(indent_level=2, prefix="---"):
            print("더 깊은 들여쓰기")
    
    print("일반 출력으로 복원")
    
    # 3. 리소스 풀 컨텍스트 관리자
    class ConnectionPool:
        """데이터베이스 연결 풀 관리"""
        
        def __init__(self, pool_size=5):
            self.pool_size = pool_size
            self.connections = []
            self.in_use = set()
        
        def __enter__(self):
            """연결 풀 초기화"""
            print(f"[풀] 연결 풀 초기화 (크기: {self.pool_size})")
            
            # 연결 생성 (시뮬레이션)
            for i in range(self.pool_size):
                conn_id = f"conn_{i+1}"
                self.connections.append({
                    "id": conn_id,
                    "status": "idle",
                    "created": time.time()
                })
            
            return self
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            """연결 풀 정리"""
            print("[풀] 연결 풀 정리")
            
            for conn in self.connections:
                if conn["status"] != "idle":
                    print(f"  연결 {conn['id']} 아직 사용 중")
            
            # 실제 구현: 모든 연결 종료
            self.connections.clear()
        
        def get_connection(self):
            """사용 가능한 연결 가져오기"""
            for conn in self.connections:
                if conn["status"] == "idle":
                    conn["status"] = "in_use"
                    conn["acquired"] = time.time()
                    self.in_use.add(conn["id"])
                    
                    print(f"[풀] 연결 획득: {conn['id']}")
                    return ManagedConnection(conn, self)
            
            raise RuntimeError("사용 가능한 연결이 없습니다")
        
        def release_connection(self, conn_id):
            """연결 반환"""
            for conn in self.connections:
                if conn["id"] == conn_id:
                    conn["status"] = "idle"
                    conn["released"] = time.time()
                    self.in_use.remove(conn_id)
                    
                    print(f"[풀] 연결 반환: {conn_id}")
                    break
    
    class ManagedConnection:
        """관리되는 단일 연결"""
        
        def __init__(self, connection_info, pool):
            self.conn_info = connection_info
            self.pool = pool
        
        def __enter__(self):
            """컨텍스트 진입"""
            return self
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            """컨텍스트 탈출 시 자동 반환"""
            self.pool.release_connection(self.conn_info["id"])
        
        def execute(self, query):
            """쿼리 실행"""
            print(f"[연결 {self.conn_info['id']}] 쿼리 실행: {query}")
            return {"success": True, "connection": self.conn_info["id"]}
    
    print("\n3. 연결 풀 관리:")
    
    with ConnectionPool(pool_size=3) as pool:
        # 여러 연결 사용
        with pool.get_connection() as conn1:
            result1 = conn1.execute("SELECT * FROM users")
            print(f"  결과1: {result1}")
        
        with pool.get_connection() as conn2:
            result2 = conn2.execute("INSERT INTO logs (message) VALUES ('테스트')")
            print(f"  결과2: {result2}")
            
            # 중첩 사용 (같은 연결을 다시 요청)
            with pool.get_connection() as conn3:
                result3 = conn3.execute("UPDATE counters SET value = value + 1")
                print(f"  결과3: {result3}")
    
    print("  풀 컨텍스트 종료, 모든 연결 정리됨")
    
    # 4. 조건부 컨텍스트 실행
    class ConditionalContext:
        """조건에 따라 실행되는 컨텍스트 관리자"""
        
        def __init__(self, condition, context_manager, else_context_manager=None):
            self.condition = condition
            self.context_manager = context_manager
            self.else_context_manager = else_context_manager
            self.active_manager = None
        
        def __enter__(self):
            """조건에 따라 적절한 컨텍스트 관리자 실행"""
            if self.condition:
                self.active_manager = self.context_manager
            elif self.else_context_manager:
                self.active_manager = self.else_context_manager
            else:
                # 대체 컨텍스트가 없으면 빈 컨텍스트
                class EmptyContext:
                    def __enter__(self): return self
                    def __exit__(self, *args): pass
                self.active_manager = EmptyContext()
            
            return self.active_manager.__enter__()
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            """활성 컨텍스트 관리자 종료"""
            if self.active_manager:
                return self.active_manager.__exit__(exc_type, exc_val, exc_tb)
    
    print("\n4. 조건부 컨텍스트 실행:")
    
    # 디버그 모드에 따라 다른 로깅 레벨 사용
    debug_mode = True
    
    class DebugLogger:
        def __enter__(self):
            print("[디버그] 상세 로깅 시작")
            return self
        def __exit__(self, *args):
            print("[디버그] 상세 로깅 종료")
    
    class ProductionLogger:
        def __enter__(self):
            print("[프로덕션] 간략 로깅 시작")
            return self
        def __exit__(self, *args):
            print("[프로덕션] 간략 로깅 종료")
    
    with ConditionalContext(debug_mode, DebugLogger(), ProductionLogger()) as logger:
        print("  작업 수행 중...")
    
    # 조건 변경
    debug_mode = False
    with ConditionalContext(debug_mode, DebugLogger(), ProductionLogger()) as logger:
        print("  작업 수행 중...")

advanced_context_manager_patterns()
```

## 인스턴스를 많이 생성할 때 메모리 절약

대량의 객체를 생성할 때 메모리 사용량을 줄이기 위해 `__slots__`, `__dict__` 최적화, 약한 참조 등을 사용할 수 있습니다.

### `__slots__`를 이용한 메모리 최적화

```python
def memory_optimization_with_slots():
    """__slots__를 이용한 메모리 최적화"""
    
    print("\n=== __slots__ 메모리 최적화 ===")
    
    import sys
    import tracemalloc
    
    # 1. 일반 클래스 vs __slots__ 클래스 비교
    class RegularUser:
        """일반적인 클래스 정의"""
        
        def __init__(self, user_id, name, email, age):
            self.user_id = user_id
            self.name = name
            self.email = email
            self.age = age
        
        def display(self):
            return f"{self.name} ({self.email})"
    
    class SlotUser:
        """__slots__를 사용한 클래스 정의"""
        
        __slots__ = ['user_id', 'name', 'email', 'age']
        
        def __init__(self, user_id, name, email, age):
            self.user_id = user_id
            self.name = name
            self.email = email
            self.age = age
        
        def display(self):
            return f"{self.name} ({self.email})"
    
    print("1. 개별 객체 메모리 사용량 비교:")
    
    # 객체 생성
    regular_user = RegularUser(1, "김철수", "chulsoo@example.com", 30)
    slot_user = SlotUser(1, "김철수", "chulsoo@example.com", 30)
    
    print(f"  RegularUser 객체 크기: {sys.getsizeof(regular_user):,} 바이트")
    print(f"  SlotUser 객체 크기: {sys.getsizeof(slot_user):,} 바이트")
    
    # __dict__ 유무 확인
    print(f"  RegularUser.__dict__ 크기: {sys.getsizeof(regular_user.__dict__):,} 바이트")
    
    try:
        print(f"  SlotUser.__dict__: {slot_user.__dict__}")
    except AttributeError:
        print("  SlotUser에는 __dict__가 없습니다")
    
    # 2. 대량 객체 생성 시 메모리 비교
    print("\n2. 대량 객체 생성 메모리 비교:")
    
    def create_many_objects(cls, count=10000):
        """많은 객체 생성 및 메모리 사용량 측정"""
        objects = []
        for i in range(count):
            obj = cls(i, f"User{i}", f"user{i}@example.com", 20 + (i % 50))
            objects.append(obj)
        return objects
    
    # 메모리 사용량 측정
    tracemalloc.start()
    
    # RegularUser 객체 생성
    regular_objects = create_many_objects(RegularUser, 10000)
    current1, peak1 = tracemalloc.get_traced_memory()
    
    # SlotUser 객체 생성
    slot_objects = create_many_objects(SlotUser, 10000)
    current2, peak2 = tracemalloc.get_traced_memory()
    
    tracemalloc.stop()
    
    print(f"  RegularUser 10,000개: {current1 / 1024 / 1024:.2f} MB 사용")
    print(f"  SlotUser 10,000개: {current2 / 1024 / 1024:.2f} MB 사용")
    print(f"  절약된 메모리: {(current1 - current2) / 1024 / 1024:.2f} MB ({(current1 - current2)/current1*100:.1f}%)")
    
    # 3. __slots__의 제한사항과 대안
    print("\n3. __slots__의 제한사항:")
    
    class SlotWithProperties:
        """__slots__와 프로퍼티 함께 사용"""
        
        __slots__ = ['_x', '_y']
        
        def __init__(self, x, y):
            self._x = x
            self._y = y
        
        @property
        def x(self):
            return self._x
        
        @x.setter
        def x(self, value):
            if value < 0:
                raise ValueError("x는 0 이상이어야 합니다")
            self._x = value
        
        @property
        def y(self):
            return self._y
        
        @y.setter
        def y(self, value):
            if value < 0:
                raise ValueError("y는 0 이상이어야 합니다")
            self._y = value
        
        @property
        def magnitude(self):
            """계산된 속성"""
            return (self._x ** 2 + self._y ** 2) ** 0.5
        
        # 클래스 변수는 __slots__에 영향을 받지 않음
        version = "1.0.0"
    
    point = SlotWithProperties(3, 4)
    print(f"  객체 생성: x={point.x}, y={point.y}")
    print(f"  계산된 속성: magnitude={point.magnitude}")
    print(f"  클래스 변수: version={point.version}")
    
    # 동적 속성 추가 시도
    try:
        point.z = 5  # __slots__ 클래스는 동적 속성 추가 불가
    except AttributeError as e:
        print(f"  동적 속성 추가 실패: {e}")
    
    # 4. 계층 구조에서의 __slots__
    print("\n4. 상속과 __slots__:")
    
    class BaseWithSlots:
        __slots__ = ['base_field']
        
        def __init__(self):
            self.base_field = "base"
    
    class DerivedWithSlots(BaseWithSlots):
        __slots__ = ['derived_field']
        
        def __init__(self):
            super().__init__()
            self.derived_field = "derived"
    
    class DerivedWithoutSlots(BaseWithSlots):
        """__slots__를 재정의하지 않음 -> __dict__ 생성됨"""
        
        def __init__(self):
            super().__init__()
            self.extra_field = "extra"
    
    base_obj = BaseWithSlots()
    derived_slots_obj = DerivedWithSlots()
    derived_no_slots_obj = DerivedWithoutSlots()
    
    print(f"  Base 객체 크기: {sys.getsizeof(base_obj):,} 바이트")
    print(f"  DerivedWithSlots 객체 크기: {sys.getsizeof(derived_slots_obj):,} 바이트")
    print(f"  DerivedWithoutSlots 객체 크기: {sys.getsizeof(derived_no_slots_obj):,} 바이트")
    
    # DerivedWithoutSlots는 __dict__를 가짐
    print(f"  DerivedWithoutSlots.__dict__ 크기: {sys.getsizeof(derived_no_slots_obj.__dict__):,} 바이트")

memory_optimization_with_slots()
```

### 튜플과 네임드튜플을 활용한 메모리 최적화

```python
def tuple_based_memory_optimization():
    """튜플 기반 메모리 최적화"""
    
    print("\n=== 튜플 기반 메모리 최적화 ===")
    
    import sys
    from collections import namedtuple
    from typing import NamedTuple
    from dataclasses import dataclass
    
    # 1. 다양한 데이터 클래스 비교
    print("1. 다양한 데이터 저장 방식 비교:")
    
    # 일반 클래스
    class RegularPoint:
        def __init__(self, x, y, z):
            self.x = x
            self.y = y
            self.z = z
    
    # __slots__ 클래스
    class SlotPoint:
        __slots__ = ['x', 'y', 'z']
        def __init__(self, x, y, z):
            self.x = x
            self.y = y
            self.z = z
    
    # 네임드튜플 (collections)
    NamedTuplePoint = namedtuple('NamedTuplePoint', ['x', 'y', 'z'])
    
    # 네임드튜플 (typing)
    class TypedNamedPoint(NamedTuple):
        x: float
        y: float
        z: float
    
    # 데이터클래스
    @dataclass
    class DataClassPoint:
        x: float
        y: float
        z: float
    
    # 튜플
    TuplePoint = tuple  # (x, y, z)
    
    # 객체 생성
    regular = RegularPoint(1.0, 2.0, 3.0)
    slot = SlotPoint(1.0, 2.0, 3.0)
    namedtuple_pt = NamedTuplePoint(1.0, 2.0, 3.0)
    typed_named = TypedNamedPoint(1.0, 2.0, 3.0)
    dataclass_pt = DataClassPoint(1.0, 2.0, 3.0)
    tuple_pt = (1.0, 2.0, 3.0)
    
    # 메모리 사용량 비교
    print(f"  RegularPoint: {sys.getsizeof(regular):,} 바이트")
    print(f"  SlotPoint: {sys.getsizeof(slot):,} 바이트")
    print(f"  NamedTuple: {sys.getsizeof(namedtuple_pt):,} 바이트")
    print(f"  TypedNamedTuple: {sys.getsizeof(typed_named):,} 바이트")
    print(f"  DataClass: {sys.getsizeof(dataclass_pt):,} 바이트")
    print(f"  Tuple: {sys.getsizeof(tuple_pt):,} 바이트")
    
    # 2. 대량 데이터 처리 비교
    print("\n2. 대량 데이터 처리 성능:")
    
    import time
    import random
    
    def benchmark_data_structure(cls, num_points=100000):
        """데이터 구조 성능 벤치마크"""
        start_time = time.time()
        points = []
        
        for i in range(num_points):
            x = random.uniform(-100, 100)
            y = random.uniform(-100, 100)
            z = random.uniform(-100, 100)
            
            if cls == tuple:
                point = (x, y, z)
            else:
                point = cls(x, y, z)
            
            points.append(point)
        
        creation_time = time.time() - start_time
        
        # 데이터 접근 테스트
        start_time = time.time()
        total = 0.0
        for point in points:
            if cls == tuple:
                total += point[0] + point[1] + point[2]
            else:
                total += point.x + point.y + point.z
        
        access_time = time.time() - start_time
        
        return len(points), creation_time, access_time, total
    
    print("  성능 비교 (100,000개 점):")
    
    structures = [
        ("Tuple", tuple),
        ("NamedTuple", NamedTuplePoint),
        ("TypedNamedTuple", TypedNamedPoint),
        ("SlotPoint", SlotPoint),
        ("DataClass", DataClassPoint),
        ("RegularPoint", RegularPoint)
    ]
    
    results = []
    for name, cls in structures:
        count, create_time, access_time, total = benchmark_data_structure(cls, 50000)
        results.append((name, create_time, access_time, total))
        print(f"    {name}: 생성={create_time:.3f}s, 접근={access_time:.3f}s")
    
    # 3. 실전 예제: 게임 엔티티 시스템
    print("\n3. 실전 예제: 게임 엔티티 시스템")
    
    # 메모리 효율적인 엔티티 표현
    class EntitySystem:
        """메모리 효율적인 게임 엔티티 시스템"""
        
        def __init__(self):
            # 각 속성을 별도의 배열로 저장 (Structure of Arrays)
            self.positions_x = []
            self.positions_y = []
            self.velocities_x = []
            self.velocities_y = []
            self.health = []
            self.entity_ids = []
            self.entity_types = []
            
            self.next_id = 0
        
        def create_entity(self, x, y, vx=0.0, vy=0.0, health=100, entity_type="enemy"):
            """새 엔티티 생성"""
            entity_id = self.next_id
            self.next_id += 1
            
            self.positions_x.append(x)
            self.positions_y.append(y)
            self.velocities_x.append(vx)
            self.velocities_y.append(vy)
            self.health.append(health)
            self.entity_ids.append(entity_id)
            self.entity_types.append(entity_type)
            
            return entity_id
        
        def update(self, dt):
            """모든 엔티티 업데이트"""
            for i in range(len(self.entity_ids)):
                # 위치 업데이트
                self.positions_x[i] += self.velocities_x[i] * dt
                self.positions_y[i] += self.velocities_y[i] * dt
                
                # 체력 감소 (예시)
                self.health[i] *= 0.999
        
        def get_entity_info(self, index):
            """특정 인덱스의 엔티티 정보 가져오기"""
            return {
                "id": self.entity_ids[index],
                "x": self.positions_x[index],
                "y": self.positions_y[index],
                "health": self.health[index],
                "type": self.entity_types[index]
            }
        
        def get_memory_usage(self):
            """메모리 사용량 추정"""
            import struct
            
            # 각 배열의 메모리 사용량 추정
            total = 0
            total += len(self.positions_x) * struct.calcsize('d')  # double
            total += len(self.positions_y) * struct.calcsize('d')
            total += len(self.velocities_x) * struct.calcsize('d')
            total += len(self.velocities_y) * struct.calcsize('d')
            total += len(self.health) * struct.calcsize('f')  # float
            total += len(self.entity_ids) * struct.calcsize('i')  # int
            total += sum(len(t) for t in self.entity_types)  # 문자열
            
            return total
    
    # AoS (Array of Structures) 방식
    class AoS_EntitySystem:
        """전통적인 객체 배열 방식"""
        
        class Entity:
            def __init__(self, eid, x, y, vx, vy, health, etype):
                self.id = eid
                self.x = x
                self.y = y
                self.vx = vx
                self.vy = vy
                self.health = health
                self.type = etype
        
        def __init__(self):
            self.entities = []
            self.next_id = 0
        
        def create_entity(self, x, y, vx=0.0, vy=0.0, health=100, entity_type="enemy"):
            eid = self.next_id
            self.next_id += 1
            entity = self.Entity(eid, x, y, vx, vy, health, entity_type)
            self.entities.append(entity)
            return eid
        
        def get_memory_usage(self):
            """메모리 사용량 추정"""
            return sum(sys.getsizeof(e) for e in self.entities)
    
    print("  SoA vs AoS 메모리 비교:")
    
    # SoA 방식
    soa_system = EntitySystem()
    for i in range(10000):
        soa_system.create_entity(i*10, i*5, 1.0, -1.0, 100, "enemy")
    
    # AoS 방식
    aos_system = AoS_EntitySystem()
    for i in range(10000):
        aos_system.create_entity(i*10, i*5, 1.0, -1.0, 100, "enemy")
    
    soa_memory = soa_system.get_memory_usage()
    aos_memory = aos_system.get_memory_usage()
    
    print(f"    SoA 방식: {soa_memory / 1024:.1f} KB")
    print(f"    AoS 방식: {aos_memory / 1024:.1f} KB")
    print(f"    메모리 절약: {(aos_memory - soa_memory) / aos_memory * 100:.1f}%")
    
    # 4. 약한 참조를 활용한 메모리 관리
    print("\n4. 약한 참조를 활용한 메모리 관리:")
    
    import weakref
    
    class LargeData:
        """대용량 데이터를 가지는 클래스"""
        
        def __init__(self, data_id, size=1000):
            self.data_id = data_id
            # 대용량 데이터 시뮬레이션
            self.data = [i for i in range(size)]
            print(f"  LargeData 객체 생성: {data_id}")
        
        def __del__(self):
            print(f"  LargeData 객체 소멸: {self.data_id}")
    
    class DataManager:
        """약한 참조를 사용한 데이터 관리자"""
        
        def __init__(self):
            self._cache = weakref.WeakValueDictionary()
        
        def get_data(self, data_id):
            """데이터 가져오기 (캐시 활용)"""
            if data_id in self._cache:
                print(f"  캐시 히트: {data_id}")
                return self._cache[data_id]
            else:
                print(f"  캐시 미스: {data_id}, 새로 생성")
                data = LargeData(data_id)
                self._cache[data_id] = data
                return data
        
        def cache_size(self):
            return len(self._cache)
    
    print("  약한 참조 캐시 테스트:")
    
    manager = DataManager()
    
    # 데이터 사용
    data1 = manager.get_data("data1")
    data2 = manager.get_data("data2")
    
    print(f"  캐시 크기: {manager.cache_size()}")
    
    # 참조 제거
    del data1
    del data2
    
    # 가비지 컬렉션 강제 실행 (일반적으로는 필요 없음)
    import gc
    gc.collect()
    
    print(f"  참조 제거 후 캐시 크기: {manager.cache_size()}")

tuple_based_memory_optimization()
```

## 클래스 이름의 캡슐화

파이썬에서 이름 캡슐화는 주로 네이밍 컨벤션(`_`와 `__` 접두사)을 통해 구현됩니다. 이는 모듈 내부의 구현 세부사항을 숨기고 공개 API를 명확히 하는 데 도움이 됩니다.

### 접근 제어와 이름 맹글링

```python
def name_encapsulation_and_mangling():
    """이름 캡슐화와 맹글링"""
    
    print("\n=== 이름 캡슐화와 맹글링 ===")
    
    # 1. 다양한 접근 제어 수준
    class BankAccount:
        """은행 계좌 클래스 - 다양한 접근 제어 수준 보여주기"""
        
        # 공개 속성 (public)
        bank_name = "파이썬 은행"  # 클래스 변수, 공개
        
        def __init__(self, account_holder, initial_balance=0):
            # 보호된 속성 (protected) - 하위 클래스에서 접근 가능
            self._account_holder = account_holder
            self._account_number = self._generate_account_number()
            
            # 비공개 속성 (private) - 이름 맹글링 발생
            self.__balance = initial_balance
            self.__transaction_history = []
            
            # 내부 사용 속성 (single underscore)
            self._last_updated = time.time()
            
            # 공개 속성
            self.is_active = True
        
        def _generate_account_number(self):
            """보호된 메서드 - 내부 구현, 하위 클래스에서 오버라이드 가능"""
            return f"ACCT{int(time.time()) % 1000000:06d}"
        
        def __update_timestamp(self):
            """비공개 메서드 - 클래스 내부에서만 사용"""
            self._last_updated = time.time()
        
        def deposit(self, amount):
            """공개 메서드 - 외부에서 호출 가능"""
            if amount <= 0:
                raise ValueError("입금액은 0보다 커야 합니다")
            
            self.__balance += amount
            self.__transaction_history.append({
                'type': 'deposit',
                'amount': amount,
                'timestamp': time.time()
            })
            self.__update_timestamp()
            
            print(f"  {amount:,}원 입금 완료. 새로운 잔고: {self.__balance:,}원")
            return self.__balance
        
        def withdraw(self, amount):
            """공개 메서드"""
            if amount <= 0:
                raise ValueError("출금액은 0보다 커야 합니다")
            if amount > self.__balance:
                raise ValueError("잔고가 부족합니다")
            
            self.__balance -= amount
            self.__transaction_history.append({
                'type': 'withdrawal',
                'amount': amount,
                'timestamp': time.time()
            })
            self.__update_timestamp()
            
            print(f"  {amount:,}원 출금 완료. 남은 잔고: {self.__balance:,}원")
            return self.__balance
        
        def get_balance(self):
            """잔고 조회 메서드 (읽기 전용)"""
            return self.__balance
        
        def _get_transaction_count(self):
            """보호된 메서드 - 거래 횟수 조회"""
            return len(self.__transaction_history)
        
        def __str__(self):
            return f"계좌번호: {self._account_number}, 소유자: {self._account_holder}"
    
    print("1. 다양한 접근 제어 수준:")
    
    account = BankAccount("김철수", 1000000)
    
    print(f"  공개 속성 접근:")
    print(f"    bank_name: {account.bank_name}")
    print(f"    is_active: {account.is_active}")
    
    print(f"\n  보호된 속성 접근 (가능하지만 권장하지 않음):")
    print(f"    _account_holder: {account._account_holder}")
    print(f"    _account_number: {account._account_number}")
    
    print(f"\n  비공개 속성 접근 시도:")
    try:
        print(f"    __balance 접근: {account.__balance}")
    except AttributeError as e:
        print(f"    접근 실패: {e}")
    
    print(f"\n  이름 맹글링 확인:")
    print(f"    실제 속성명: {account._BankAccount__balance}")
    print(f"    거래내역: {account._BankAccount__transaction_history[:2]}...")
    
    print(f"\n  공개 메서드 사용:")
    account.deposit(500000)
    account.withdraw(200000)
    print(f"    최종 잔고: {account.get_balance():,}원")
    
    # 2. 상속에서의 접근 제어
    print("\n2. 상속에서의 접근 제어:")
    
    class SavingsAccount(BankAccount):
        """저축 계좌 클래스 - BankAccount 상속"""
        
        def __init__(self, account_holder, initial_balance=0, interest_rate=0.02):
            super().__init__(account_holder, initial_balance)
            # 보호된 속성 접근
            self._interest_rate = interest_rate
        
        def add_interest(self):
            """이자 추가"""
            interest = self.get_balance() * self._interest_rate
            self.deposit(interest)
            print(f"  이자 {interest:,.0f}원 추가. 이자율: {self._interest_rate*100}%")
        
        # 부모의 보호된 메서드 오버라이드
        def _generate_account_number(self):
            return f"SAV{int(time.time()) % 1000000:06d}"
        
        # 부모의 비공개 메서드 접근 시도
        def try_access_private(self):
            """비공개 멤버 접근 시도"""
            print(f"  부모의 비공개 속성 접근 시도:")
            
            # 보호된 속성은 접근 가능
            print(f"    _account_holder: {self._account_holder}")
            
            # 비공개 속성은 직접 접근 불가
            try:
                print(f"    __balance: {self.__balance}")
            except AttributeError:
                print(f"    __balance: 직접 접근 불가")
            
            # 맹글링된 이름으로는 접근 가능
            print(f"    _BankAccount__balance: {self._BankAccount__balance}")
    
    savings = SavingsAccount("이영희", 5000000, 0.03)
    print(f"  {savings}")
    savings.add_interest()
    savings.try_access_private()
    
    # 3. 프로퍼티를 활용한 캡슐화
    print("\n3. 프로퍼티를 활용한 캡슐화:")
    
    class SecurePerson:
        """프로퍼티를 사용한 안전한 데이터 캡슐화"""
        
        def __init__(self, name, age):
            self._name = name  # 내부 저장소
            self._age = age    # 내부 저장소
        
        @property
        def name(self):
            """읽기 전용 프로퍼티"""
            return self._name
        
        @property
        def age(self):
            """읽기 전용 프로퍼티"""
            return self._age
        
        @age.setter
        def age(self, value):
            """세터를 통한 유효성 검사"""
            if not isinstance(value, int):
                raise TypeError("나이는 정수여야 합니다")
            if value < 0:
                raise ValueError("나이는 0 이상이어야 합니다")
            if value > 150:
                raise ValueError("나이는 150 이하여야 합니다")
            
            self._age = value
            print(f"  나이 업데이트: {value}세")
        
        @property
        def birth_year(self):
            """계산된 프로퍼티"""
            import datetime
            current_year = datetime.datetime.now().year
            return current_year - self._age + 1  # 한국식 나이
        
        @birth_year.setter
        def birth_year(self, year):
            """계산된 프로퍼티의 세터"""
            import datetime
            current_year = datetime.datetime.now().year
            self._age = current_year - year + 1
        
        def __str__(self):
            return f"{self.name} ({self.age}세, {self.birth_year}년생)"
    
    person = SecurePerson("박지원", 25)
    print(f"  초기 상태: {person}")
    
    # 프로퍼티 사용
    print(f"  이름(읽기 전용): {person.name}")
    
    # 나이 변경 (세터 호출)
    person.age = 26
    print(f"  변경 후: {person}")
    
    # 계산된 프로퍼티
    print(f"  생년: {person.birth_year}")
    person.birth_year = 1995
    print(f"  생년 변경 후: {person}")
    
    # 잘못된 값 설정 시도
    try:
        person.age = -5
    except ValueError as e:
        print(f"  유효성 검사 실패: {e}")
    
    # 4. 모듈 수준의 캡슐화
    print("\n4. 모듈 수준의 캡슐화:")
    
    # _single_leading_underscore: 모듈 내에서만 사용
    def _internal_helper():
        """내부 헬퍼 함수 - 모듈 외부에서 import되지 않음"""
        return "내부 도우미"
    
    # __double_leading_underscore: 클래스 내 이름 맹글링
    class ModuleClass:
        def __private_method(self):
            return "비공개 메서드"
        
        def public_method(self):
            return self.__private_method()
    
    # _single_trailing_underscore_: 파이썬 키워드와의 충돌 방지
    class_ = ModuleClass  # 'class'는 키워드이므로
    
    # __double_leading_and_trailing_underscore__: 매직 메서드
    class MagicClass:
        def __init__(self):
            self.data = []
        
        def __len__(self):
            return len(self.data)
        
        def __getitem__(self, index):
            return self.data[index]
    
    print("  모듈 캡슐화 예시:")
    print(f"    내부 헬퍼: {_internal_helper()}")
    
    obj = ModuleClass()
    print(f"    공개 메서드: {obj.public_method()}")
    
    try:
        print(f"    비공개 메서드 직접 호출: {obj.__private_method()}")
    except AttributeError:
        print(f"    비공개 메서드 직접 호출 불가")
    
    # 5. 디스크립터를 활용한 고급 캡슐화
    print("\n5. 디스크립터를 활용한 고급 캡슐화:")
    
    class ValidatedAttribute:
        """유효성 검사 디스크립터"""
        
        def __init__(self, validator=None, default=None):
            self.validator = validator
            self.default = default
            self.data = {}  # 인스턴스별 데이터 저장
        
        def __get__(self, instance, owner):
            if instance is None:
                return self
            return self.data.get(id(instance), self.default)
        
        def __set__(self, instance, value):
            if self.validator and not self.validator(value):
                raise ValueError(f"유효성 검사 실패: {value}")
            self.data[id(instance)] = value
        
        def __delete__(self, instance):
            if id(instance) in self.data:
                del self.data[id(instance)]
    
    class Employee:
        """디스크립터를 사용한 직원 클래스"""
        
        # 디스크립터 정의
        name = ValidatedAttribute(
            validator=lambda x: isinstance(x, str) and len(x) >= 2
        )
        
        age = ValidatedAttribute(
            validator=lambda x: isinstance(x, int) and 18 <= x <= 70
        )
        
        salary = ValidatedAttribute(
            validator=lambda x: isinstance(x, (int, float)) and x >= 0
        )
        
        def __init__(self, name, age, salary):
            self.name = name  # 디스크립터의 __set__ 호출
            self.age = age
            self.salary = salary
        
        def __str__(self):
            return f"{self.name}, {self.age}세, ₩{self.salary:,.0f}"
    
    print("  디스크립터를 통한 유효성 검사:")
    
    # 올바른 값
    emp1 = Employee("김철수", 30, 50000000)
    print(f"    직원1: {emp1}")
    
    # 잘못된 값 시도
    try:
        emp2 = Employee("A", 15, -1000)  # 이름 너무 짧음, 나이 미성년, 음수 급여
    except ValueError as e:
        print(f"    생성 실패: {e}")
    
    # 속성 변경도 검사
    try:
        emp1.age = 200  # 나이 제한 초과
    except ValueError as e:
        print(f"    나이 변경 실패: {e}")

name_encapsulation_and_mangling()
```

### 실전: 완전한 캡슐화 구현

```python
def complete_encapsulation_example():
    """완전한 캡슐화 구현 예제"""
    
    print("\n=== 완전한 캡슐화 구현 ===")
    
    # 1. 완전히 캡슐화된 데이터 클래스
    class ImmutablePoint:
        """불변(immutable) 점 클래스 - 완전한 캡슐화"""
        
        __slots__ = ['_x', '_y', '_z']
        
        def __init__(self, x, y, z):
            self._x = float(x)
            self._y = float(y)
            self._z = float(z)
        
        @property
        def x(self):
            """x 좌표 (읽기 전용)"""
            return self._x
        
        @property
        def y(self):
            """y 좌표 (읽기 전용)"""
            return self._y
        
        @property
        def z(self):
            """z 좌표 (읽기 전용)"""
            return self._z
        
        def distance_to(self, other):
            """다른 점까지의 거리 계산"""
            if not isinstance(other, ImmutablePoint):
                raise TypeError("ImmutablePoint 객체만 가능합니다")
            
            dx = self._x - other._x
            dy = self._y - other._y
            dz = self._z - other._z
            
            return (dx**2 + dy**2 + dz**2) ** 0.5
        
        def translate(self, dx, dy, dz):
            """이동된 새 점 반환 (불변성 유지)"""
            return ImmutablePoint(
                self._x + dx,
                self._y + dy,
                self._z + dz
            )
        
        def __eq__(self, other):
            """등가 비교"""
            if not isinstance(other, ImmutablePoint):
                return False
            return (self._x == other._x and 
                    self._y == other._y and 
                    self._z == other._z)
        
        def __hash__(self):
            """해시 가능하게 만듦"""
            return hash((self._x, self._y, self._z))
        
        def __repr__(self):
            return f"ImmutablePoint({self._x}, {self._y}, {self._z})"
        
        def __str__(self):
            return f"({self._x}, {self._y}, {self._z})"
    
    print("1. 불변 점 클래스:")
    
    p1 = ImmutablePoint(1, 2, 3)
    p2 = ImmutablePoint(4, 5, 6)
    
    print(f"  점1: {p1}")
    print(f"  점2: {p2}")
    print(f"  거리: {p1.distance_to(p2):.2f}")
    
    # 불변성 확인
    p3 = p1.translate(1, 1, 1)
    print(f"  이동 후 점1: {p1} (변하지 않음)")
    print(f"  새 점: {p3}")
    
    # 해시 가능 확인
    points_set = {p1, p2, p3}
    print(f"  집합에 저장된 점 수: {len(points_set)}")
    
    # 2. 팩토리 패턴과 캡슐화
    print("\n2. 팩토리 패턴과 캡슐화:")
    
    class DatabaseConnectionPool:
        """데이터베이스 연결 풀 - 팩토리 패턴 적용"""
        
        class _DatabaseConnection:
            """내부 연결 클래스 - 외부에서 직접 생성 불가"""
            
            def __init__(self, connection_id, pool):
                self._id = connection_id
                self._pool = pool
                self._in_use = False
                print(f"    내부 연결 생성: {connection_id}")
            
            def execute(self, query):
                """쿼리 실행"""
                if not self._in_use:
                    raise RuntimeError("연결이 활성화되지 않았습니다")
                
                print(f"    연결 {self._id}에서 쿼리 실행: {query}")
                return {"affected_rows": 1}
            
            def _activate(self):
                """내부 활성화 메서드"""
                self._in_use = True
            
            def _release(self):
                """내부 해제 메서드"""
                self._in_use = False
        
        _instance = None  # 싱글톤 인스턴스
        _initialized = False
        
        def __new__(cls):
            """싱글톤 패턴"""
            if cls._instance is None:
                cls._instance = super().__new__(cls)
            return cls._instance
        
        def __init__(self):
            """초기화 (싱글톤)"""
            if not self._initialized:
                self._connections = []
                self._max_size = 5
                self._initialized = True
                print("  데이터베이스 연결 풀 초기화")
        
        def get_connection(self):
            """연결 획득 (팩토리 메서드)"""
            # 재사용 가능한 연결 찾기
            for conn in self._connections:
                if not conn._in_use:
                    conn._activate()
                    print(f"  기존 연결 재사용: {conn._id}")
                    return conn
            
            # 새 연결 생성
            if len(self._connections) < self._max_size:
                conn_id = f"conn_{len(self._connections) + 1}"
                conn = self._DatabaseConnection(conn_id, self)
                conn._activate()
                self._connections.append(conn)
                print(f"  새 연결 생성: {conn_id}")
                return conn
            
            raise RuntimeError("최대 연결 수에 도달했습니다")
        
        def release_connection(self, connection):
            """연결 반환"""
            if isinstance(connection, self._DatabaseConnection):
                connection._release()
                print(f"  연결 반환: {connection._id}")
            else:
                raise TypeError("잘못된 연결 객체입니다")
    
    print("  데이터베이스 연결 풀 사용:")
    
    pool = DatabaseConnectionPool()
    
    # 연결 사용
    conn1 = pool.get_connection()
    conn1.execute("SELECT * FROM users")
    pool.release_connection(conn1)
    
    # 같은 풀 인스턴스 확인 (싱글톤)
    pool2 = DatabaseConnectionPool()
    print(f"  같은 인스턴스인가? {pool is pool2}")
    
    # 내부 클래스 직접 생성 시도
    try:
        internal_conn = pool._DatabaseConnection("test", pool)
    except Exception as e:
        print(f"  내부 클래스 직접 생성 실패: {type(e).__name__}")
    
    # 3. 추상 베이스 클래스를 통한 인터페이스 정의
    print("\n3. 추상 베이스 클래스를 통한 인터페이스 캡슐화:")
    
    from abc import ABC, abstractmethod
    from typing import List
    
    class DataRepository(ABC):
        """데이터 저장소 추상 인터페이스"""
        
        @abstractmethod
        def save(self, data: dict) -> str:
            """데이터 저장"""
            pass
        
        @abstractmethod
        def find_by_id(self, data_id: str) -> dict:
            """ID로 데이터 조회"""
            pass
        
        @abstractmethod
        def find_all(self) -> List[dict]:
            """모든 데이터 조회"""
            pass
        
        @abstractmethod
        def delete(self, data_id: str) -> bool:
            """데이터 삭제"""
            pass
    
    class InMemoryRepository(DataRepository):
        """메모리 기반 저장소 구현"""
        
        def __init__(self):
            self._storage = {}
            self._next_id = 1
        
        def save(self, data: dict) -> str:
            data_id = str(self._next_id)
            self._next_id += 1
            
            data_with_meta = {
                **data,
                'id': data_id,
                'created_at': time.strftime("%Y-%m-%d %H:%M:%S")
            }
            
            self._storage[data_id] = data_with_meta
            return data_id
        
        def find_by_id(self, data_id: str) -> dict:
            return self._storage.get(data_id)
        
        def find_all(self) -> List[dict]:
            return list(self._storage.values())
        
        def delete(self, data_id: str) -> bool:
            if data_id in self._storage:
                del self._storage[data_id]
                return True
            return False
        
        # 내부 메서드 (인터페이스에 없음)
        def _clear(self):
            """내부 저장소 비우기"""
            self._storage.clear()
            self._next_id = 1
    
    class FileRepository(DataRepository):
        """파일 기반 저장소 구현"""
        
        def __init__(self, filename):
            self.filename = filename
            self._data = self._load_data()
        
        def _load_data(self):
            """데이터 로드"""
            try:
                import json
                with open(self.filename, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except FileNotFoundError:
                return {}
        
        def _save_data(self):
            """데이터 저장"""
            import json
            with open(self.filename, 'w', encoding='utf-8') as f:
                json.dump(self._data, f, indent=2, ensure_ascii=False)
        
        def save(self, data: dict) -> str:
            data_id = str(int(time.time()))
            data['id'] = data_id
            data['created_at'] = time.strftime("%Y-%m-%d %H:%M:%S")
            
            self._data[data_id] = data
            self._save_data()
            return data_id
        
        def find_by_id(self, data_id: str) -> dict:
            return self._data.get(data_id)
        
        def find_all(self) -> List[dict]:
            return list(self._data.values())
        
        def delete(self, data_id: str) -> bool:
            if data_id in self._data:
                del self._data[data_id]
                self._save_data()
                return True
            return False
    
    print("  추상 인터페이스 사용:")
    
    # 인터페이스를 통한 사용 (구현 세부사항 숨김)
    def use_repository(repo: DataRepository):
        """저장소 사용 함수"""
        print(f"  저장소 사용 시작: {type(repo).__name__}")
        
        # 데이터 저장
        data_id = repo.save({"name": "테스트 데이터", "value": 123})
        print(f"    데이터 저장 완료: ID={data_id}")
        
        # 데이터 조회
        data = repo.find_by_id(data_id)
        print(f"    데이터 조회: {data.get('name')}")
        
        # 모든 데이터 조회
        all_data = repo.find_all()
        print(f"    총 데이터 수: {len(all_data)}")
        
        # 데이터 삭제
        success = repo.delete(data_id)
        print(f"    데이터 삭제: {'성공' if success else '실패'}")
    
    # 메모리 저장소 사용
    mem_repo = InMemoryRepository()
    use_repository(mem_repo)
    
    # 파일 저장소 사용 (인터페이스는 동일)
    file_repo = FileRepository("test_data.json")
    use_repository(file_repo)
    
    # 4. 모듈의 공개 API 제어
    print("\n4. 모듈의 공개 API 제어:")
    
    # __all__을 사용한 공개 제어
    class _InternalClass:
        """내부 전용 클래스"""
        pass
    
    class PublicClass:
        """공개 클래스"""
        pass
    
    def _internal_function():
        """내부 전용 함수"""
        return "내부"
    
    def public_function():
        """공개 함수"""
        return "공개"
    
    # 모듈의 __all__ 정의 (가상)
    __all__ = ['PublicClass', 'public_function']
    
    print("  모듈 공개 제어:")
    print(f"    공개 클래스: {PublicClass.__name__}")
    print(f"    내부 클래스: {_InternalClass.__name__} (import *에서 제외됨)")
    print(f"    공개 함수: {public_function()}")
    print(f"    내부 함수: {_internal_function()} (사용 가능하지만 권장하지 않음)")

complete_encapsulation_example()
```

## 결론

파이썬에서 객체의 문자열 표현을 효과적으로 제어하는 것은 디버깅, 로깅, 사용자 인터페이스 등 다양한 상황에서 중요합니다. `__str__()`은 사용자 친화적인 표현을, `__repr__()`은 개발자용 명확한 표현을 제공하며, `__format__()`을 구현하면 `format()` 함수와 f-string에서 객체의 포맷팅을 완전히 제어할 수 있습니다.

컨텍스트 관리자 프로토콜(`__enter__()`, `__exit__()`)은 리소스 관리, 트랜잭션 처리, 설정 변경 등에 매우 유용한 패턴입니다. `with` 문과 함께 사용하면 리소스 누수를 방지하고 코드의 가독성을 크게 향상시킬 수 있습니다.

대량의 객체를 생성할 때는 메모리 사용량을 최적화하는 것이 중요합니다. `__slots__`를 사용하면 객체의 메모리 사용량을 크게 줄일 수 있지만, 동적 속성 추가가 불가능해지는 제약이 있습니다. 튜플, 네임드튜플, 데이터클래스 등 상황에 맞는 데이터 구조를 선택하고, Structure of Arrays(SoA) 패턴을 적용하면 대규모 데이터 처리를 효율적으로 수행할 수 있습니다.

이름 캡슐화는 파이썬의 철학인 "우리는 모두 동의하는 성인이다"를 반영합니다. `_`와 `__` 접두사를 사용하여 접근 제어 수준을 나타내고, 프로퍼티를 통해 데이터 유효성 검사와 캡슐화를 구현하며, 추상 베이스 클래스를 사용하여 인터페이스를 정의할 수 있습니다. `__all__`을 통해 모듈의 공개 API를 명시적으로 제어하면 사용자가 내부 구현에 의존하는 것을 방지할 수 있습니다.

이러한 기법들을 조합하여 적용하면 더욱 강력하고 유지보수하기 쉬운 파이썬 코드를 작성할 수 있습니다. 각 상황에 맞는 적절한 패턴을 선택하고, 일관된 컨벤션을 따르는 것이 중요합니다.