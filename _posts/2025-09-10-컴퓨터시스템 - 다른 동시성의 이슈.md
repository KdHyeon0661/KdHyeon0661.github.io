---
layout: post
title: 컴퓨터시스템 - 다른 동시성의 이슈
date: 2025-09-10 23:20:23 +0900
category: 컴퓨터시스템
---
# 다른 동시성의 이슈(문제군)

## 이슈 — 메모리 모델과 동기화의 본질

### 데이터 레이스(Data Race)

- 정의: **같은 메모리**에 **동시에** 두 스레드가 접근(최소 1개는 쓰기), **동기화 없음** → C/C++에선 **UB(Undefined Behavior)**.
- 해법: (1) **뮤텍스**로 임계구역 보호, (2) **원자(atomic)** 로 읽기/쓰기, (3) **메시지 패싱**으로 공유 제거.

```c
// BAD: 경쟁 + 손실 갱신
int x=0;
void* t(void*) { for (int i=0;i<1000000;i++) x++; return NULL; }

// GOOD #1: 락
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
int x2=0;
void* t_lock(void*) {
  for (int i=0;i<1000000;i++) { pthread_mutex_lock(&m); x2++; pthread_mutex_unlock(&m); }
  return NULL;
}

// GOOD #2: 원자
#include <stdatomic.h>

atomic_int x3 = 0;
void* t_atomic(void*) {
  for (int i=0;i<1000000;i++) atomic_fetch_add_explicit(&x3, 1, memory_order_relaxed);
  return NULL;
}
```

### — check-then-act

- **읽기→검사→수정**이 한 덩어리가 아니면 중간에 끼어들어 **중복 할당**/**이중 해제** 등 발생.

```c
// BAD
if (!in_use[id]) { in_use[id]=1; /* ... */ }

// GOOD
pthread_mutex_lock(&m);
if (!in_use[id]) { in_use[id]=1; /* ... */ }
pthread_mutex_unlock(&m);
```

### — **happens-before** 만들기

- 컴파일러/CPU는 메모리 접근을 재배치한다. **acquire/release** 또는 **락**으로 **happens-before**를 구축해야 소비자가 올바른 값을 본다.

```c
typedef struct { atomic_int ready; int data; } slot_t;
// producer
s->data = 42;
atomic_store_explicit(&s->ready, 1, memory_order_release);
// consumer
while (!atomic_load_explicit(&s->ready, memory_order_acquire)) { /* spin */ }
printf("%d\n", s->data); // 반드시 42 보장
```

> **Tip**: `memory_order_seq_cst`는 가장 강력하지만 비용↑. 데이터 경합이 심하지 않다면 **release/acquire**가 실무 기본.

### 안전한 발행(Safe Publication)·초기화 순서

- **완전 초기화 전 포인터**를 공개하면 반쯤 초기화된 객체를 볼 수 있다.
- 패턴: 모든 필드를 세팅 → **release-store**로 전역 포인터 교체 → 독자는 **acquire-load**.

### 조건변수 — **유실 신호(Lost Wakeup)** & **스퍼리어스 웨이크업**

- 항상 **`while (!predicate) cond_wait`**. `if`는 금지.

```c
pthread_mutex_lock(&m);
while (!ready) pthread_cond_wait(&cv, &m);
pthread_mutex_unlock(&m);
```

### 교착상태(Deadlock)

- 필요조건: **상호배제·점유대기·비선점·환형대기**.
- 해법: **글로벌 락 순서 규약**, `trylock+backoff`, **타임아웃 잠금**, 락 쪼개기(순서 유지).

```c
// 규약: 항상 A → B 순서
pthread_mutex_lock(&A);
pthread_mutex_lock(&B);
/* ... */
pthread_mutex_unlock(&B);
pthread_mutex_unlock(&A);
```

### 라이브락(Livelock)·기아(Starvation)

- 서로 양보하다 **진전 없음** / 낮은 우선순위가 **영구 대기**.
- 해법: **랜덤 백오프**·공정한 락·스케줄링 정책 조정.

### 우선순위 역전(Priority Inversion)

- 저우선 스레드가 락 보유 → 고우선이 대기.
- 해법: **우선순위 상속/천장**(PTHREAD_PRIO_INHERIT 등), 임계구역 **짧게**.

### TOCTTOU(Check-Use 경합)

- 확인과 사용 사이에 상태가 바뀜(파일 권한/존재 등).
- 해법: **동일 락 안에서 확인+사용** 또는 **`*at` 계열 + 디렉터리 FD**로 원자화.

### **ABA 문제**(Lock-Free)

- A→B→A로 회귀하면 “변화 없음”으로 오인.
- 해법: **태그(세대 카운터) 덧붙인 포인터**, **Hazard Pointers / Epoch-GC**로 안전 해제.

```c
typedef struct { uint64_t ptr; uint64_t tag; } tagged_ptr;
// CAS 시 tag++ 병행
```

### 재진입성(Reentrancy)·스레드 안전성(Thread-Safety)

- 시그널 핸들러/콜백이 같은 함수를 **중첩 호출**해도 안전?
- **async-signal-safe** 외 호출 금지, 전역 상태는 락 또는 재진입 설계.

---

## 이슈 — 락·캐시·스케줄러

### 락 경합·컨보이(Convoy)·스래싱

- 다수 스레드가 한 락에 몰려 **컨텍스트 스위치 폭증**.
- 해법: **미세락**, **샤딩(분할)**, **읽기-쓰기 락**, **per-thread 로컬 후 reduction**, **flat-combining**.

### 거짓 공유(False Sharing)

- 서로 다른 변수가 **같은 캐시라인(보통 64B)** → **무효화 폭주**.

```c
#include <stdalign.h>
#define CL 64

typedef struct { alignas(CL) long v; } padded_long; // 라인 단위 패딩
```

### NUMA 함정

- 원격 노드 메모리 접근이 **느림**. 페이지가 노드 간 **핑퐁**.
- 해법: **first-touch** 초기화, **코어 고정(affinity)**, 작업을 **노드별 샤딩**.

### 메모리 할당기 경합

- 전역 락 malloc → 병목.
- 해법: **tcmalloc/jemalloc** 등 스레드 캐시형, **per-thread pool**.

### 과다 스레드(Over-subscription)·코어 마이그레이션

- 스레드 수 ≫ 코어 수 → 스위치·캐시 미스↑.
- 권장: **스레드 수 ≈ 물리 코어 수 ± α**. 긴 작업은 **고정**.

### I/O 병목 — 이벤트 루프 규율 위반

- **EPOLLOUT 상시 등록**·**부분 I/O 미처리**·**accept 루프 미비** → CPU 낭비·정체.
- 해법: **EAGAIN까지 drain/fill**, **EPOLLOUT 토글**, **accept 대기열 비우기**.

### TLB Shootdown·페이지 스로싱

- 거대한 공유 자료 구조에 **빈번한 쓰기** → TLB 무효화·페이지 테이블 갱신 비용↑.
- 해법: **데이터 분할**, 쓰기 지역성 확보, (적절할 때) **hugepage**.

---

## 이슈 — 취소·시그널·시간·자원

### 취소 안전(Cancellation Safety)

- `pthread_cancel`은 기본 **지연 취소**. 블로킹 지점에서만 반응.
- 반드시 **정리 핸들러**로 락/세마포어 반납 보장.

```c
void cleanup(void* p){ pthread_mutex_unlock((pthread_mutex_t*)p); }

pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
void* worker(void*) {
  pthread_mutex_lock(&m);
  pthread_cleanup_push(cleanup, &m);
  /* ... 임계구역/블로킹 작업 ... */
  pthread_cleanup_pop(1); // 1=언락 실행
  return NULL;
}
```

### 시그널 + 멀티스레딩

- 시그널은 **프로세스 전체**.
- 전용 스레드에서 **`sigwait()`** 로 동기 처리 권장.
- 비동기 핸들러는 **async-signal-safe** 함수만 호출.

### `fork()`와 스레드

- 멀티스레드에서 `fork()` 후 자식은 **한 스레드만** 살아남음 → 잠긴 락으로 교착 가능.
- 권장: **`posix_spawn()`**. 부득이하면 `pthread_atfork`로 정리.

### 시간/타임아웃 — **단조시계(CLOCK_MONOTONIC)**

- `CLOCK_REALTIME`은 시간 변경의 영향.
- 타임아웃/데드라인은 **단조시계 기반**으로 계산.

```c
#include <time.h>

static inline int64_t now_ns() {
  struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts);
  return (int64_t)ts.tv_sec*1000000000LL + ts.tv_nsec;
}
```

### 자원 한계/OS 한도

- FD/스레드/스택 크기(**ulimit**), 포트 고갈, 커널 큐(somaxconn) 등.
- 운영 전 **상향**·**에러 경로 로깅**·**알림** 구성.

---

## I/O·이벤트 기반 추가 이슈 — 리액터와 함께

### 블로킹

- 한 연결의 큰 응답이 루프를 오래 점유 → **지연 꼬리(p95/p99)** 증가.
- 해법: **분할 전송**, **타임 슬라이싱**, **스레드풀 오프로딩**.

### 백프레셔(Backpressure)

- 무한 큐는 **메모리 폭주**.
- 해법: **유한 큐 + 드롭/지연** + 상위 레이어(클라이언트)에 **신호**(윈도우/429/Retry-After).

### 재진입/콜백 지옥

- 콜백에서 동일 루프 재진입 → 상태 꼬임.
- 해법: **상태기계 명시화**, **큐잉 후 루프 틱에서만 진행**.

---

## 설계 패턴(회피 전략)

1) **불변(Immutable)**: 초기화 후 변경 금지 → 락 제거.
2) **메시지 패싱/Actor/CSP**: 공유 대신 **전달**. 경계마다 **유한 큐**로 역압.
3) **per-thread/per-core 샤딩**: 쓰기 경합 분산 → 마지막에 **reduction**.
4) **RCU / Copy-on-Write**: 읽기 경합 0, 쓰기 시 사본 교체.
5) **Idempotency & Retry**: 재시도 안전 연산으로 실패·취소에도 견고.
6) **구조적 동시성(Structured Concurrency)**: 생성된 작업은 **스코프 안에서 합류/정리**.

---

## 진단·검증 도구(실무 필수)

- **ThreadSanitizer(TSan)**: 레이스/락 순서 (`-fsanitize=thread`).
- **Helgrind/DRD(Valgrind)**: 락/데이터 경쟁.
- **rr(Record/Replay)**: 비결정 실행 재현.
- **perf / eBPF / flamegraph**: 락 경합, 스케줄링 비용, 핫패스.
- **stress/fuzz**: 난수 스케줄·장시간 부하로 희귀 버그 표면화.
- **락 순서 체커**: 코드 내 **획득 순서** assert로 강제.

---

## 대표 함정 → 올바른 코드 스니펫

### 조건변수 — **while-wait** 패턴

```c
// BAD
pthread_mutex_lock(&m);
if (!ready) pthread_cond_wait(&cv, &m);
pthread_mutex_unlock(&m);

// GOOD
pthread_mutex_lock(&m);
while (!ready) pthread_cond_wait(&cv, &m);
pthread_mutex_unlock(&m);
```

### 더블-체크 초기화(정석)

```c
#include <stdatomic.h>

typedef struct cfg cfg_t;
_Atomic(cfg_t*) g = NULL;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

cfg_t* get_cfg(){
  cfg_t* p = atomic_load_explicit(&g, memory_order_acquire);
  if (!p) {
    pthread_mutex_lock(&m);
    p = atomic_load_explicit(&g, memory_order_acquire);
    if (!p) {
      cfg_t* n = /* allocate+init */;
      atomic_store_explicit(&g, n, memory_order_release);
      p = n;
    }
    pthread_mutex_unlock(&m);
  }
  return p;
}
```

### 태그 포인터로 **ABA** 완화(개념 스켈레톤)

```c
typedef struct { _Atomic(unsigned __int128) pack; } tagptr; // [tag:64 | ptr:64]

bool cas(tagptr* a, void* oldp, void* newp, uint64_t oldtag){
  __uint128_t old = ((__uint128_t)oldtag<<64) | (uintptr_t)oldp;
  __uint128_t neu = ((__uint128_t)(oldtag+1)<<64) | (uintptr_t)newp;
  return atomic_compare_exchange_strong(&a->pack, &old, neu);
}
```

---

## 구조적 동시성 + 취소 안전(현대 C/POSIX 버전)

- **요구**: 스코프를 벗어날 때 **모든 작업 합류(join)**, **자원 해제**, **타임아웃·취소**.

```c
// 개념적 스케치: 스레드 그룹을 스코프 객체로
typedef struct { pthread_t* t; int n; } thread_group;

void tg_join_and_destroy(thread_group* g, int cancel){
  if (cancel) for (int i=0;i<g->n;i++) pthread_cancel(g->t[i]);
  for (int i=0;i<g->n;i++) pthread_join(g->t[i], NULL);
  free(g->t);
}
```

---

## 수학으로 보는 직관 — Amdahl · Little · 큐잉

### Amdahl’s Law (병렬 가속 한계)

$$
S(N) = \frac{1}{(1-P) + \frac{P}{N}}
$$
- \(P\): 병렬 가능한 비율, \(N\): 코어 수.
- 공유 자원(락/캐시/TLB) 병목은 \(1-P\)를 **증가**시킨다 → **락 제거/샤딩**이 본질.

### Little’s Law (대기열 직관)

$$
L = \lambda W
$$
- \(L\): 시스템 평균 체류 작업 수, \(\lambda\): 도착률, \(W\): 평균 지연.
- **지연(p99)**을 줄이려면: arrival(입력) 줄이거나, 처리량/서비스율을 올리거나, **큐를 유한**으로.

### 락 대기시간 근사

$$
T_\text{op} \approx T_\text{work} + C_\text{lock}\cdot C - T_\text{overlap}
$$
- \(C\): 동시 경쟁자 수, \(C_\text{lock}\): 경쟁당 비용. → **경쟁자 수/임계구역 길이**를 줄이는 설계가 최우선.

---

## 사례 ① — **경계 안전** 유한 큐(조건변수, 타임아웃, MONOTONIC)

> 목표: **유실 신호 방지**, **타임아웃**, **취소 안전**을 만족하는 Bounded Queue.

```c
// bqueue.c : 생산자-소비자 안전 큐 (pthread + condvar)
#include <pthread.h>
#include <stdlib.h>
#include <errno.h>
#include <time.h>
#define N 1024

typedef struct {
  void* q[N]; size_t h,t,cnt;
  pthread_mutex_t m;
  pthread_cond_t not_full, not_empty;
} bq;

static void ts_add_ms(struct timespec* ts, long ms){
  ts->tv_sec  += ms/1000;
  ts->tv_nsec += (ms%1000)*1000000L;
  if (ts->tv_nsec >= 1000000000L){ ts->tv_sec++; ts->tv_nsec-=1000000000L; }
}

void bq_init(bq* b){
  *b = (bq){0};
  pthread_mutex_init(&b->m, NULL);
  pthread_condattr_t ca; pthread_condattr_init(&ca);
  pthread_condattr_setclock(&ca, CLOCK_MONOTONIC);
  pthread_cond_init(&b->not_full, &ca);
  pthread_cond_init(&b->not_empty, &ca);
  pthread_condattr_destroy(&ca);
}

int bq_push_wait(bq* b, void* x, long timeout_ms){
  int rc=0; pthread_mutex_lock(&b->m);
  struct timespec dl; clock_gettime(CLOCK_MONOTONIC, &dl); ts_add_ms(&dl, timeout_ms);
  while (b->cnt==N) {
    rc = pthread_cond_timedwait(&b->not_full, &b->m, &dl);
    if (rc==ETIMEDOUT) { pthread_mutex_unlock(&b->m); return ETIMEDOUT; }
  }
  b->q[b->t] = x; b->t = (b->t+1)%N; b->cnt++;
  pthread_cond_signal(&b->not_empty);
  pthread_mutex_unlock(&b->m); return 0;
}

int bq_pop_wait(bq* b, void** out, long timeout_ms){
  int rc=0; pthread_mutex_lock(&b->m);
  struct timespec dl; clock_gettime(CLOCK_MONOTONIC, &dl); ts_add_ms(&dl, timeout_ms);
  while (b->cnt==0) {
    rc = pthread_cond_timedwait(&b->not_empty, &b->m, &dl);
    if (rc==ETIMEDOUT) { pthread_mutex_unlock(&b->m); return ETIMEDOUT; }
  }
  *out = b->q[b->h]; b->h = (b->h+1)%N; b->cnt--;
  pthread_cond_signal(&b->not_full);
  pthread_mutex_unlock(&b->m); return 0;
}
```

**포인트**
- 조건변수는 **`while` 루프**.
- 타임아웃은 **`CLOCK_MONOTONIC`** 기반(시계 변경 무영향).
- **유한 큐**로 **백프레셔** 자연스럽게 구현.

---

## 사례 ② — Lock-Free 스택 + **Hazard Pointer** 스케치

> 목표: ABA·use-after-free 방지. (학습용 스켈레톤)

```c
// 핵심 아이디어: pop 대상 노드를 "Hazard" 슬롯에 먼저 등록하여
// 다른 스레드가 free하지 못하게 보류. 안전 시 비우고 해제.
typedef struct Node { struct Node* next; int v; } Node;
_Atomic(Node*) head = NULL;

#define HZ_MAX 128

_Atomic(Node*) hazard[HZ_MAX];

void* hp_acquire(Node* p, int i){
  atomic_store_explicit(&hazard[i], p, memory_order_release);
  atomic_thread_fence(memory_order_seq_cst);
  return (void*)p;
}
void hp_clear(int i){ atomic_store_explicit(&hazard[i], NULL, memory_order_release); }

// pop (개념)
Node* pop(int slot){
  for (;;) {
    Node* h = atomic_load_explicit(&head, memory_order_acquire);
    if (!h) return NULL;
    hp_acquire(h, slot);                 // 내가 다룰 노드 보호
    if (h != atomic_load_explicit(&head, memory_order_acquire)) continue; // 변동 재확인
    Node* nx = atomic_load_explicit(&h->next, memory_order_relaxed);
    if (atomic_compare_exchange_weak_explicit(&head, &h, nx,
        memory_order_acq_rel, memory_order_acquire)) {
      hp_clear(slot);                    // 보호 해제
      // retire(h): 안전 시점에 free (모든 hazard 검사 후)
      return h;
    }
  }
}
```

**포인트**
- Hazard/epoch 기법은 **메모리 재활용의 순서 문제**를 체계적으로 해결.
- 실제 구현은 **retire list**·**scan**·**batch free**가 필요.

---

## 운영 체크리스트(현업용)

- [ ] **레이스 없음**: 락/원자/메시지로 보호. `volatile`로 동기화하지 말 것.
- [ ] **happens-before** 명시(acquire/release, 락 언락↔락 획득, cond wait).
- [ ] **락 순서 규약** 문서화·리뷰로 강제.
- [ ] **while-wait**(조건변수), **타임아웃**(MONOTONIC).
- [ ] **거짓 공유** 방지(패딩/샤딩), 락 경합 측정.
- [ ] **NUMA first-touch**, 코어 고정·스레드 수 튜닝.
- [ ] **유한 큐 + 백프레셔** 설계, **드롭/재시도** 정책.
- [ ] **취소/에러 경로**에서 자원 반납(cleanup) 보장.
- [ ] **fork 대신 posix_spawn**, 시그널은 `sigwait` 스레드.
- [ ] TSan/Helgrind/rr/perf/eBPF로 **정확성+성능** 동시 검증.
- [ ] 로깅·지표: **p95/p99 지연**, 큐 길이, 에러율, 스레드 상태.

---

## 의사결정 트리(요약)

```
정확성 문제? ──► 공유를 줄일 수 있나(불변/메시지/샤딩)?
   │             ├─ 가능 ► 공유 제거
   │             └─ 불가 ► 락 or 원자 선택:
   │                           ├─ 복합 불변식 유지 ► 락
   │                           └─ 단순 카운터/플래그 ► atomic(acq/rel)
성능 병목? ──► 경합 지점 찾기(perf/eBPF) ► 샤딩/미세락/RCU/배치/zero-copy
운영 이슈? ──► 취소 안전/타임아웃/자원한도/백프레셔/관측 추가
```

---

## 마무리 — 한 줄 결론

동시성의 “다른 이슈”는 크게 **공유 상태의 정확성**(레이스·순서·발행), **스케일링**(락·캐시·NUMA), **운영 안정성**(취소·시그널·시간·자원한계)에서 발생한다.
핵심은 **happens-before**를 명확히 만들고, **공유를 줄이며(불변/메시지/샤딩)**, **운영 규율(타임아웃·백프레셔·관측)**을 체계화하는 것이다.
이 3축을 지키면, 복잡한 동시성 시스템도 **예측 가능하고 빠르며 안정적**으로 유지된다.
