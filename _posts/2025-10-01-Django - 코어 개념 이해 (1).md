---
layout: post
title: Django - 코어 개념 이해 (1)
date: 2025-10-01 15:25:23 +0900
category: Django
---
# 코어 개념 이해 (1) - URL 라우팅, View(함수형/CBV/믹스인/제네릭), Template(DTL/Jinja2 비교)

## A. URL 라우팅 깊게 보기 — `path()`, `re_path()`, `include()`, 네임드 URL, 리버스

Django의 URLconf는 **“URL 문자열 → Python callable(View)”** 매핑이다.  
여기에서 **“문자열을 하드코딩하지 않고, 이름 기반으로 역참조(reverse)”** 하는 습관이 **유지보수성과 안정성의 핵심**이다.

### A-1. 프로젝트 레벨 URLconf 구조

최상위 `config/urls.py` 예시:

```python
# config/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path("admin/", admin.site.urls),
    path("", include("apps.core.urls")),          # 루트로 core 앱 연결
    path("shop/", include("apps.shop.urls")),     # /shop/* 는 shop 앱으로 분기
]
```

- `admin/`:
  - Django 기본 관리자.
- `include()`:
  - **앱별 URLconf**를 분리해 **모듈화**.
  - “루트 URL prefix + 앱 내부 패턴” 구조를 만든다.

**프로젝트 구조 예시:**

```text
config/
  __init__.py
  settings.py
  urls.py
  asgi.py
  wsgi.py
apps/
  core/
    urls.py
    views.py
  shop/
    urls.py
    views.py
```

이렇게 프로젝트 레벨은 **“대분기만 담당”** 하고, 실제 라우팅은 앱 내부로 위임하는 것이 일반적인 패턴이다.

---

### A-2. 앱 레벨 URLconf — `path()` 와 네임스페이스

```python
# apps/core/urls.py

from django.urls import path
from . import views

app_name = "core"  # 네임스페이스: reverse('core:home') 등에서 사용

urlpatterns = [
    path("", views.home, name="home"),
    path("hello/<str:name>/", views.hello, name="hello"),            # 동적 세그먼트
    path("articles/<int:pk>/", views.article_detail, name="article"),# int 컨버터
]
```

#### URL 컨버터

- `<int:pk>`
- `<str:slug>`
- `<slug:slug>`
- `<uuid:uid>`
- `<path:subpath>` (슬래시 포함 전체 경로를 한 번에 받음)

컨버터에 따라 뷰 인자의 타입이 결정된다. 예를 들어:

```python
def article_detail(request, pk: int):
    ...
```

`pk` 는 이미 `int` 로 변환된 상태다.

#### `app_name` 과 `name`

- `app_name`:
  - `reverse("core:home")` 처럼 **네임스페이스**의 루트.
- 개별 패턴의 `name`:
  - `reverse("core:article", kwargs={"pk": 10})`
  - 템플릿에서 {% raw %}`{% url 'core:article' pk=10 %}`{% endraw %}

---

### A-3. "URL 하드코딩 금지" 원칙 — 리버스 사용

#### 파이썬 코드에서

```python
# apps/core/views.py

from django.shortcuts import redirect
from django.urls import reverse

def created(request, pk):
    # 생성 후 해당 상세 페이지로 리디렉트
    url = reverse("core:article", kwargs={"pk": pk})
    return redirect(url)
```

#### 템플릿에서

{% raw %}
```html
<a href="{% url 'core:article' pk=object.pk %}">{{ object.title }}</a>
```
{% endraw %}

**이점:**

- URL 패턴이 `/articles/<int:pk>/` → `/posts/<int:pk>/` 로 바뀌어도
  - **뷰/템플릿 코드를 손대지 않아도 된다.**
- 테스트 코드에서 `reverse()` 로 URL을 얻으므로, **라우팅 버그를 빨리 발견**할 수 있다.

---

### A-4. `re_path()` — 정규식 라우팅이 필요한 경우

가능하면 `path()` 컨버터로 충분히 해결하는 것이 가독성이 좋지만,  
때로는 **복잡한 규칙(예: 접두·접미가 섞인 연도/월)** 을 정규식으로 잡고 싶을 수 있다.

```python
# apps/core/urls.py

from django.urls import re_path
from . import views

urlpatterns = [
    re_path(
        r"^y(?P<year>\d{4})/m(?P<month>\d{2})/$",
        views.archive,
        name="archive",
    ),
]
```

```python
# apps/core/views.py

from django.http import HttpResponse

def archive(request, year, month):
    return HttpResponse(f"{year}-{month} archive")
```

- 정규식 그룹: `(?P<year>\d{4})` → 뷰 인자 `year` 로 전달.
- 유지보수가 어렵기 때문에, **규칙이 아주 특이한 경우에만** 사용하는 것이 좋다.

---

### A-5. 두 단계 네임스페이스 — 앱 네임스페이스 + 인스턴스 네임스페이스

**하나의 앱을 여러 번 마운트**해야 할 수도 있다. 예: `shop` 앱을 “A몰” / “B몰” 로 두 번 붙이고 싶을 때.

```python
# config/urls.py

from django.urls import include, path
from apps.shop import urls as shop_urls

urlpatterns = [
    path("shop-a/", include((shop_urls.urlpatterns, "shop"), namespace="shop_a")),
    path("shop-b/", include((shop_urls.urlpatterns, "shop"), namespace="shop_b")),
]
```

템플릿에서:

{% raw %}
```html
<a href="{% url 'shop_a:product_detail' pk=1 %}">A몰 상품1</a>
<a href="{% url 'shop_b:product_detail' pk=1 %}">B몰 상품1</a>
```
{% endraw %}

- `shop_urls` 안의 `app_name = "shop"` 이 **앱 네임스페이스**.
- `namespace="shop_a"` / `"shop_b"` 가 **인스턴스 네임스페이스**.

---

### A-6. 국제화 URL, trailing slash, 리다이렉트 정책

#### `APPEND_SLASH` 정책

`settings.py`:

```python
APPEND_SLASH = True
```

- `/shop` 으로 요청 시 → `/shop/` 로 **301 리다이렉트**.
- URLconf 에서는 **일관되게 `/` 로 끝나도록** 작성하는 것이 좋다.

#### i18n URL (`i18n_patterns`)

다국어 사이트에서 URL에 언어코드를 포함하고 싶다면:

```python
# config/urls.py

from django.conf.urls.i18n import i18n_patterns
from django.urls import path, include

urlpatterns = [
    path("admin/", admin.site.urls),
]

urlpatterns += i18n_patterns(
    path("", include("apps.core.urls")),
    path("shop/", include("apps.shop.urls")),
)
```

- `/en/shop/`, `/de/shop/` 같은 형태로 라우팅.
- 슬러그/경로의 다국어 문제는 별도의 slugify 전략으로 관리.

---

### A-7. 커스텀 Path Converter

예: 32자리 hex 토큰만 허용하는 URL:

```python
# apps/common/converters.py

class HexConverter:
    regex = "[0-9a-f]{32}"

    def to_python(self, value):
        return value  # 필요하다면 여기서 검증/변환
    def to_url(self, value):
        return value
```

```python
# config/urls.py

from django.urls import register_converter, path
from apps.common.converters import HexConverter
from apps.core import views as core_views

register_converter(HexConverter, "hex")

urlpatterns = [
    path("t/<hex:token>/", core_views.token_view, name="token"),
]
```

---

### A-8. URLconf 테스트 — `reverse` / `resolve`

```python
# apps/shop/tests/test_urls.py

import pytest
from django.urls import reverse, resolve

def test_reverse_and_resolve():
    url = reverse("shop:list")
    assert url == "/shop/"

    resolver = resolve("/shop/")
    assert resolver.namespace == "shop"
    assert resolver.url_name == "list"
```

- **URL 문자열 변경** 시 테스트가 깨지므로, **실제 라우팅 변경이 의도대로 동작하는지** 검증할 수 있다.

---

### A-9. URLconf 체크리스트

- [ ] `app_name` 설정(네임스페이스).
- [ ] 모든 링크/리디렉트에서 `reverse` / {% raw %}`{% url %}`{% endraw %} 사용.
- [ ] `include()` 로 앱 모듈 분리.
- [ ] 가급적 `path()` 컨버터 우선, `re_path()` 최소화.
- [ ] trailing slash 정책 일관성.
- [ ] 국제화(i18n) URL이 필요한지 여부.

---

## B. View — 함수형(FBV) vs 클래스형(CBV), 믹스인, 제네릭, async

View는 “**요청을 받아 응답을 반환하는 callable**” 이다.

- **FBV(Function-Based View)**: 단순, 명시적.
- **CBV(Class-Based View)**: 구조화, 재사용, 제네릭 뷰 이용 가능.
- **Async View**: I/O 바운드 처리에 유리(ASGI 환경에서).

---

### B-1. 함수형 뷰(FBV) 기초

```python
# apps/core/views.py

from django.http import HttpResponse, JsonResponse
from django.shortcuts import render

def home(request):
    return render(request, "core/home.html", {"title": "Home"})

def ping(request):
    return JsonResponse({"pong": True})

def hello(request, name):
    return HttpResponse(f"Hello, {name}")
```

- `render(request, template_name, context)`:
  - 템플릿 렌더링 + `HttpResponse` 생성.
- `JsonResponse`:
  - `Content-Type: application/json` 자동 설정.

**장점**

- 단순하고 읽기 쉽다.
- 엔드포인트가 적고 로직이 단순한 서비스, 웹훅, 헬스체크, 임시 유틸에 적합.

---

### B-2. 클래스형 뷰(CBV) 기초 — `View`

```python
# apps/core/views.py

from django.views import View
from django.http import HttpResponse

class EchoView(View):
    def get(self, request):
        return HttpResponse("GET OK")

    def post(self, request):
        return HttpResponse("POST OK")
```

```python
# apps/core/urls.py

from django.urls import path
from .views import EchoView

urlpatterns = [
    path("echo/", EchoView.as_view(), name="echo"),
]
```

- `as_view()`:
  - 클래스 → 실제 callable view 로 변환.
  - `dispatch()` → HTTP method (`get`, `post`, ...) 에 따라 분배.

**장점**

- 상속/믹스인 구조를 이용해 **권한/로그/공통 패턴**을 캡슐화.
- 제네릭 뷰를 통해 CRUD, 폼 처리, 리스트/상세를 빠르게 구성.

---

### B-3. CBV의 라이프사이클 / MRO

Django 문서 기준 `View` 의 흐름은 대략 다음과 같다. :contentReference[oaicite:1]{index=1}

1. `as_view()` 가 호출되어 내부 `view` 함수를 반환.
2. 요청이 들어오면:
   - `setup(request, *args, **kwargs)` 호출
   - `dispatch(request, *args, **kwargs)` 호출
   - HTTP 메서드(`get/post/...`)로 분기
3. 메서드가 없으면 `http_method_not_allowed()`.

`Mixin` 을 여러 개 상속할 때는 **MRO(Method Resolution Order)** 를 의식해야 한다.

```python
class MyBaseView(LoginRequiredMixin, TimestampContextMixin, View):
    ...
```

- `LoginRequiredMixin` → `TimestampContextMixin` → `View` 순으로 `super()` 가 호출된다.

---

### B-4. 믹스인으로 공통 관심사 캡슐화

```python
# apps/common/mixins.py

from django.contrib.auth.mixins import LoginRequiredMixin
from django.utils.timezone import now

class TimestampContextMixin:
    """템플릿 컨텍스트에 공통 값 추가"""
    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        ctx["now"] = now()
        ctx["project_name"] = "MyService"
        return ctx

class MyBaseView(LoginRequiredMixin, TimestampContextMixin):
    login_url = "accounts:login"
    redirect_field_name = "next"
```

```python
# apps/core/views.py

from django.views.generic import TemplateView
from apps.common.mixins import MyBaseView

class DashboardView(MyBaseView, TemplateView):
    template_name = "core/dashboard.html"
```

- 인증, 공통 컨텍스트, 로깅, 추적 ID, A/B 테스트 그룹 등 **횡단 관심사**를 믹스인으로.

---

### B-5. 제네릭 뷰로 CRUD 구성

#### 모델/폼 정의

```python
# apps/blog/models.py

from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=150)
    slug = models.SlugField(unique=True)
    body = models.TextField()
    is_public = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
```

```python
# apps/blog/forms.py

from django import forms
from .models import Post

class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = ["title", "slug", "body", "is_public"]
```

#### 목록/상세 — `ListView`, `DetailView`

```python
# apps/blog/views.py

from django.views.generic import ListView, DetailView
from .models import Post

class PostListView(ListView):
    model = Post
    queryset = Post.objects.filter(is_public=True).order_by("-created_at")
    template_name = "blog/post_list.html"
    context_object_name = "posts"
    paginate_by = 10

class PostDetailView(DetailView):
    model = Post
    slug_field = "slug"
    slug_url_kwarg = "slug"   # URL: /blog/<slug>/
    template_name = "blog/post_detail.html"
    context_object_name = "post"
```

URL:

```python
# apps/blog/urls.py

from django.urls import path
from .views import PostListView, PostDetailView

app_name = "blog"
urlpatterns = [
    path("", PostListView.as_view(), name="list"),
    path("<slug:slug>/", PostDetailView.as_view(), name="detail"),
]
```

템플릿:

{% raw %}
```html
{# templates/blog/post_list.html #}
{% extends "base.html" %}
{% block content %}
 <h1>Posts</h1>
 <ul>
   {% for p in posts %}
     <li><a href="{% url 'blog:detail' slug=p.slug %}">{{ p.title }}</a></li>
   {% empty %}
     <li>No posts.</li>
   {% endfor %}
 </ul>

 {% if is_paginated %}
   <div>
     {% if page_obj.has_previous %}
       <a href="?page={{ page_obj.previous_page_number }}">Prev</a>
     {% endif %}
     Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}
     {% if page_obj.has_next %}
       <a href="?page={{ page_obj.next_page_number }}">Next</a>
     {% endif %}
   </div>
 {% endif %}
{% endblock %}
```
{% endraw %}

#### 생성/수정/삭제 — `CreateView`, `UpdateView`, `DeleteView`

```python
# apps/blog/views.py

from django.urls import reverse_lazy
from django.views.generic import CreateView, UpdateView, DeleteView
from .forms import PostForm
from .models import Post

class PostCreateView(CreateView):
    model = Post
    form_class = PostForm
    template_name = "blog/post_form.html"
    success_url = reverse_lazy("blog:list")

class PostUpdateView(UpdateView):
    model = Post
    form_class = PostForm
    slug_field = "slug"
    slug_url_kwarg = "slug"
    template_name = "blog/post_form.html"
    success_url = reverse_lazy("blog:list")

class PostDeleteView(DeleteView):
    model = Post
    slug_field = "slug"
    slug_url_kwarg = "slug"
    template_name = "blog/post_confirm_delete.html"
    success_url = reverse_lazy("blog:list")
```

URL 추가:

```python
# apps/blog/urls.py

from .views import PostCreateView, PostUpdateView, PostDeleteView

urlpatterns += [
    path("new/", PostCreateView.as_view(), name="create"),
    path("<slug:slug>/edit/", PostUpdateView.as_view(), name="update"),
    path("<slug:slug>/delete/", PostDeleteView.as_view(), name="delete"),
]
```

폼 템플릿:

{% raw %}
```html
{# templates/blog/post_form.html #}
{% extends "base.html" %}
{% block content %}
  <h1>{% if view.object %}Edit: {{ view.object.title }}{% else %}New Post{% endif %}</h1>
  <form method="post">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Save</button>
  </form>
{% endblock %}
```
{% endraw %}

#### 권한 믹스인 결합

```python
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin

class StaffRequiredMixin(UserPassesTestMixin):
    def test_func(self):
        return self.request.user.is_staff

class PostCreateView(LoginRequiredMixin, StaffRequiredMixin, CreateView):
    ...
```

---

### B-6. FBV vs CBV 선택 가이드

| 관점              | FBV                                             | CBV / 제네릭                                                   |
|-------------------|-------------------------------------------------|-----------------------------------------------------------------|
| 난이도            | 낮음                                            | 중간 (MRO / 상속 이해 필요)                                    |
| 가독성(짧은 뷰)   | 매우 좋음                                       | 단순한 엔드포인트에는 다소 과한 구조                           |
| 재사용성          | 함수 재사용 또는 데코레이터 수준               | 믹스인/상속으로 패턴 캡슐화에 강함                             |
| CRUD/폼           | 직접 작성 필요                                  | 제네릭 뷰로 대부분 자동 구성                                   |
| 팀 컨벤션         | 섞어 쓰기 쉬움                                  | “서비스 전체 CBV 기반” 등 컨벤션 정하기 쉬움                   |
| 디버깅            | 함수 호출 스택이 단순                           | 상속 계층에 따라 다소 복잡할 수 있음                           |

실무에서는:

- **간단한 헬스체크/웹훅/API 엔드포인트** → FBV
- **도메인 CRUD / 페이지 렌더링** → CBV + 제네릭
- 같은 기능군 내에서는 **일관성**을 유지하는 것이 좋다.

---

### B-7. Async View (함수형/클래스형)

Django 5.x 는 **ASGI 기반**에서 **async view** 를 본격적으로 지원한다. :contentReference[oaicite:2]{index=2}

#### 함수형 async view

```python
# apps/api/views.py

from django.http import JsonResponse
import httpx

async def async_ping(request):
    return JsonResponse({"pong": True})

async def fetch_external(request):
    async with httpx.AsyncClient(timeout=5.0) as client:
        r = await client.get("https://httpbin.org/get")
    return JsonResponse(r.json())
```

- ASGI 서버(Uvicorn, Daphne 등)에서 **실제 비동기 I/O 성능**을 발휘한다.
- WSGI 서버에서도 동작은 하지만, 내부에서 컨텍스트 스위칭이 발생해 성능 이점은 거의 없다.

#### 클래스형 async view

```python
import asyncio
from django.http import HttpResponse
from django.views import View

class AsyncEchoView(View):
    async def get(self, request, *args, **kwargs):
        await asyncio.sleep(0.5)
        return HttpResponse("Hello async world")
```

> 하나의 CBV 안에서는 `get/post/...` 등 **모든 핸들러를 async 또는 sync 중 하나로 통일**해야 한다. 혼합하면 `ImproperlyConfigured` 예외가 발생한다. :contentReference[oaicite:3]{index=3}

#### ORM과 async

- Django 5.2는 많은 ORM 메서드에 대해 `a` 접두어 버전(`aget`, `acreate`, `afirst`, `aall` 등)을 제공한다. :contentReference[oaicite:4]{index=4}
- 트랜잭션/일부 기능은 아직 완전 async 가 아니므로, **중요한 트랜잭션 블록**은 여전히 **sync 함수 + `sync_to_async`** 로 래핑하는 패턴이 권장된다.

---

### B-8. View 에서의 보안/성능 포인트

- **CSRF 보호**:
  - HTML 폼 POST → `{% csrf_token %}` + `CsrfViewMiddleware` 유지.
  - API 의 경우 토큰/헤더 기반 인증 + `@csrf_exempt` 고려(무분별 사용 금지).
- **권한/인증**:
  - FBV: `@login_required`, `@permission_required`.
  - CBV: `LoginRequiredMixin`, `PermissionRequiredMixin`.
- **쿼리 최적화**:
  - `select_related()` / `prefetch_related()` 로 N+1 쿼리 방지.
- **PRG(Post-Redirect-Get)**:
  - POST 처리 후 `redirect()` 로 리다이렉트, 새로고침 시 중복 제출 방지.
- **메시지 프레임워크**:
  - `django.contrib.messages` 로 성공/오류 메시지를 일관되게 처리.

---

## C. Template — DTL, 상속/블록, 필터/태그, 컨텍스트 프로세서, Jinja2 비교

Django 템플릿 시스템은 크게 두 가지 층:

1. **템플릿 엔진**: DTL(Django Template Language), Jinja2 등
2. **컨텍스트 데이터 공급**: view / 컨텍스트 프로세서 / 템플릿 태그

---

### C-1. DTL 기본 문법 정리

#### 변수 출력

{% raw %}
```html
<p>{{ user.username }}</p>
```
{% endraw %}

#### 필터

{% raw %}
```html
{{ title|upper }}
{{ created_at|date:"Y-m-d" }}
{{ text|linebreaks }}
```
{% endraw %}

#### 제어 태그

{% raw %}
```html
{% if user.is_authenticated %}
  Hello, {{ user.username }}
{% else %}
  Please login.
{% endif %}

{% for obj in objects %}
  <li>{{ forloop.counter }}. {{ obj }}</li>
{% empty %}
  <li>No data.</li>
{% endfor %}
```
{% endraw %}

#### 주석

```html
{# 이것은 템플릿 주석 #}
```

#### 자동 escaping

- DTL은 기본적으로 **HTML escape** 를 자동 적용한다.

{% raw %}
```html
{{ html_snippet }}        {# HTML 태그가 글자로 보임 #}
{{ html_snippet|safe }}  {# 실제 태그로 렌더링 #}
```
{% endraw %}

> 사용자 입력에 `|safe` 를 절대 붙이지 말 것.  
> WYSIWYG/마크다운 등은 서버에서 신뢰할 수 있는 파서로 처리한 후에 제한적으로 `safe` 사용.

---

### C-2. 템플릿 상속/블록으로 레이아웃 통일

#### 기본 레이아웃

{% raw %}
```html
{# templates/base.html #}
<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <title>{% block title %}MySite{% endblock %}</title>
  </head>
  <body>
    <nav>
      <a href="{% url 'core:home' %}">Home</a>
      <a href="{% url 'shop:list' %}">Shop</a>
    </nav>
    <hr>
    {% block content %}{% endblock %}
  </body>
</html>
```
{% endraw %}

#### 상세 페이지에서 상속

{% raw %}
```html
{# templates/blog/post_detail.html #}
{% extends "base.html" %}

{% block title %}{{ post.title }} | MySite{% endblock %}

{% block content %}
  <h1>{{ post.title }}</h1>
  <p>{{ post.body|linebreaks }}</p>
{% endblock %}
```
{% endraw %}

- 전체 사이트의 헤더/푸터/내비게이션을 한 곳에 모아 두고,
- 개별 페이지는 **콘텐츠 블록만 정의**하면 된다.

---

### C-3. 템플릿 디렉터리 / 네임스페이스 전략

프로젝트 루트:

```text
templates/
├─ base.html
├─ core/
│  └─ home.html
└─ blog/
   ├─ post_list.html
   └─ post_detail.html
```

`settings.py`:

```python
TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "apps.common.context_processors.global_settings",
            ],
        },
    },
]
```

또는 앱 내부:

```text
apps/blog/templates/blog/post_list.html
apps/blog/templates/blog/post_detail.html
```

- 전역 `templates/` 와 앱 내부 템플릿을 **혼합**해 사용해도 된다.
- 템플릿 이름이 겹치지 않도록 `blog/`, `core/` 폴더로 네임스페이스를 구분.

---

### C-4. 커스텀 필터/태그 — 재사용 가능한 템플릿 함수 만들기

#### 구조

```text
apps/common/templatetags/
├─ __init__.py
└─ common_tags.py
```

#### 필터 정의

```python
# apps/common/templatetags/common_tags.py

from django import template

register = template.Library()

@register.filter
def cut(value: str, arg: str):
    """문자열에서 arg를 삭제"""
    return value.replace(arg, "")
```

#### simple_tag

```python
@register.simple_tag
def copyright(year=None):
    from django.utils.timezone import now
    y = year or now().year
    return f"© {y} MyCompany"
```

#### inclusion_tag — 부분 템플릿 렌더링

```python
@register.inclusion_tag("common/_badge.html")
def badge(text, state="info"):
    return {"text": text, "state": state}
```

부분 템플릿:

{% raw %}
```html
{# templates/common/_badge.html #}
<span class="badge badge-{{ state }}">{{ text }}</span>
```
{% endraw %}

사용:

{% raw %}
```html
{% load common_tags %}

<p>{{ "hello world"|cut:" " }}</p>
<footer>{% copyright 2025 %}</footer>
<p>{% badge "New" "success" %}</p>
```
{% endraw %}

---

### C-5. 컨텍스트 프로세서 — 모든 템플릿에 공통 값 공급

```python
# apps/common/context_processors.py

def global_settings(request):
    return {
        "SITE_NAME": "MySite",
        "SUPPORT_EMAIL": "support@example.com",
    }
```

`settings.py` 의 `context_processors` 에 추가하면,  
**모든 템플릿에서 자동으로 `SITE_NAME`, `SUPPORT_EMAIL` 에 접근**할 수 있다.

{% raw %}
```html
<footer>
  {{ SITE_NAME }} — <a href="mailto:{{ SUPPORT_EMAIL }}">Contact</a>
</footer>
```
{% endraw %}

> 무거운 쿼리/계산을 컨텍스트 프로세서에 넣으면 **모든 요청마다 실행**되므로,  
> 반드시 **가벼운 정보만** 넣어야 한다.

---

### C-6. 정적 파일/미디어와 템플릿

`settings.py`:

```python
STATIC_URL = "static/"
STATICFILES_DIRS = [BASE_DIR / "static"]

MEDIA_URL = "media/"
MEDIA_ROOT = BASE_DIR / "media"
```

템플릿:

{% raw %}
```html
{% load static %}
<link rel="stylesheet" href="{% static 'css/site.css' %}">
<img src="{{ post.image.url }}" alt="">
```
{% endraw %}

운영환경에서는:

- `collectstatic` 로 모든 정적 파일을 모으고
- 웹 서버(Nginx 등)나 CDN에서 직접 서빙하는 것이 일반적이다.

---

### C-7. DTL vs Jinja2 비교

| 항목              | DTL (Django Template Language)           | Jinja2                                |
|-------------------|------------------------------------------|----------------------------------------|
| 기본 엔진         | Django 기본                              | 선택적(추가 설정 필요)                 |
| 문법              | Django 고유 문법, 약간 제약적            | Python 스타일에 가까운 표현력           |
| 자동 escaping     | 기본 on                                   | 기본 on (동작은 비슷하지만 설정 가능)   |
| Admin/3rd party   | 대부분 DTL 전제                          | 일부는 Jinja2 지원, 전반적으론 DTL 위주 |
| 매크로            | 템플릿 태그/인클루전 중심                | `macro` 등 강력한 매크로 기능           |
| 타 프레임워크와 공유 | Django 전용                              | Flask 등과 템플릿 공유하기 좋음         |

#### Jinja2 엔진 설정 예시

```python
# settings.py

from pathlib import Path
BASE_DIR = Path(__file__).resolve().parent.parent

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.jinja2.Jinja2",
        "DIRS": [BASE_DIR / "jinja2"],       # Jinja2 전용 디렉터리
        "APP_DIRS": False,
        "OPTIONS": {
            "environment": "config.jinja2_env.environment",
        },
    },
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {"context_processors": [
            "django.template.context_processors.request",
            "django.contrib.auth.context_processors.auth",
        ]},
    },
]
```

환경 팩토리:

```python
# config/jinja2_env.py

from jinja2 import Environment
from django.contrib.staticfiles.storage import staticfiles_storage
from django.urls import reverse

def environment(**options):
    env = Environment(**options)
    env.globals.update({
        "static": staticfiles_storage.url,
        "url": reverse,
    })
    return env
```

Jinja2 템플릿:

{% raw %}
```jinja2
{# jinja2/blog/detail.html #}
<!doctype html>
<title>{{ post.title }} | MySite</title>
<h1>{{ post.title }}</h1>
<p>{{ post.body | safe }}</p>
<a href="{{ url('blog:list') }}">Back</a>
```
{% endraw %}

**의사결정 가이드**

- DTL:
  - Django 프로젝트 대부분에 기본 선택.
  - Admin 및 서드파티 패키지 예제/문서가 모두 DTL 기준.
- Jinja2:
  - Flask 등과 템플릿 공유가 필요하거나,
  - 템플릿 매크로/고급 Jinja2 기능을 많이 쓰는 팀이라면 고려.

**혼용 전략**

- DTL: 웹 UI 전체
- Jinja2: 이메일 템플릿, 특정 기능만 별도 디렉터리에서 운영  
같이 섞을 수 있지만, 장기 유지보수 관점에서는 **한쪽으로 통일**하는 것이 낫다.

---

## D. 예제: “상품 목록/상세 + 즐겨찾기 토글” — URL·View·Template 전체 흐름

이제 앞의 요소들을 실제 **미니 도메인**에 적용해 보자.

### D-1. 모델

```python
# apps/shop/models.py

from django.conf import settings
from django.db import models

class Product(models.Model):
    name = models.CharField(max_length=120)
    slug = models.SlugField(unique=True)
    price = models.PositiveIntegerField()
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.name

class Favorite(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    product = models.ForeignKey(
        Product,
        on_delete=models.CASCADE,
        related_name="favorites",
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("user", "product")
```

마이그레이션:

```bash
python manage.py makemigrations
python manage.py migrate
```

---

### D-2. URLconf

```python
# apps/shop/urls.py

from django.urls import path
from . import views

app_name = "shop"
urlpatterns = [
    path("", views.ProductListView.as_view(), name="list"),
    path("<slug:slug>/", views.ProductDetailView.as_view(), name="detail"),
    path("<slug:slug>/fav/", views.toggle_favorite, name="toggle_favorite"),
]
```

---

### D-3. CBV — 목록/상세

```python
# apps/shop/views.py

from django.views.generic import ListView, DetailView
from django.contrib.auth.decorators import login_required
from django.shortcuts import get_object_or_404, redirect
from .models import Product, Favorite

class ProductListView(ListView):
    model = Product
    queryset = Product.objects.filter(is_active=True).order_by("-created_at")
    template_name = "shop/product_list.html"
    context_object_name = "products"
    paginate_by = 20

class ProductDetailView(DetailView):
    model = Product
    slug_field = "slug"
    slug_url_kwarg = "slug"
    template_name = "shop/product_detail.html"
    context_object_name = "product"

    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        if self.request.user.is_authenticated:
            ctx["is_favorited"] = Favorite.objects.filter(
                user=self.request.user, product=self.object
            ).exists()
        else:
            ctx["is_favorited"] = False
        return ctx
```

---

### D-4. FBV — 즐겨찾기 토글

```python
# apps/shop/views.py (계속)

from django.contrib import messages
from django.urls import reverse
from django.contrib.auth.decorators import login_required

@login_required
def toggle_favorite(request, slug):
    product = get_object_or_404(Product, slug=slug, is_active=True)
    fav, created = Favorite.objects.get_or_create(user=request.user, product=product)
    if not created:
        fav.delete()
        messages.success(request, "즐겨찾기에서 제거했습니다.")
    else:
        messages.success(request, "즐겨찾기에 추가했습니다.")
    return redirect(reverse("shop:detail", kwargs={"slug": slug}))
```

- POST 요청을 처리한 후, `redirect()` 로 PRG 패턴을 적용한다.
- 로그인하지 않은 사용자는 `@login_required` 데코레이터에 의해 로그인 페이지로 리다이렉트.

---

### D-5. 템플릿

#### 목록

{% raw %}
```html
{# templates/shop/product_list.html #}
{% extends "base.html" %}
{% block content %}
  <h1>Products</h1>
  <ul>
    {% for p in products %}
      <li>
        <a href="{% url 'shop:detail' slug=p.slug %}">{{ p.name }}</a> — {{ p.price }}원
      </li>
    {% empty %}
      <li>상품이 없습니다.</li>
    {% endfor %}
  </ul>

  {% if is_paginated %}
    <div>
      {% if page_obj.has_previous %}
        <a href="?page={{ page_obj.previous_page_number }}">Prev</a>
      {% endif %}
      {{ page_obj.number }} / {{ page_obj.paginator.num_pages }}
      {% if page_obj.has_next %}
        <a href="?page={{ page_obj.next_page_number }}">Next</a>
      {% endif %}
    </div>
  {% endif %}
{% endblock %}
```
{% endraw %}

#### 상세 + 즐겨찾기

{% raw %}
```html
{# templates/shop/product_detail.html #}
{% extends "base.html" %}
{% block content %}
  <h1>{{ product.name }}</h1>
  <p>가격: {{ product.price }}원</p>

  {% if user.is_authenticated %}
    <form method="post" action="{% url 'shop:toggle_favorite' slug=product.slug %}">
      {% csrf_token %}
      {% if is_favorited %}
        <button type="submit">즐겨찾기 제거</button>
      {% else %}
        <button type="submit">즐겨찾기 추가</button>
      {% endif %}
    </form>
  {% else %}
    <p><a href="{% url 'accounts:login' %}?next={{ request.path }}">로그인</a> 후 즐겨찾기 사용 가능</p>
  {% endif %}

  <p><a href="{% url 'shop:list' %}">목록으로</a></p>
{% endblock %}
```
{% endraw %}

---

## E. 테스트 — URL·View·Template 흐름 통합 검증

Django 5.x 에서는 `pytest-django` 를 사용해도, 기본 `unittest` 를 사용해도 된다. 여기서는 pytest 스타일 예시.

### E-1. URL 리버스/리졸브 테스트

```python
# apps/shop/tests/test_urls.py

import pytest
from django.urls import reverse, resolve

def test_reverse_and_resolve():
    url = reverse("shop:list")
    assert url == "/shop/"

    match = resolve("/shop/")
    assert match.namespace == "shop"
    assert match.url_name == "list"
```

---

### E-2. 뷰 테스트 — 목록/상세

```python
# apps/shop/tests/test_views.py

import pytest
from django.urls import reverse
from apps.shop.models import Product

@pytest.mark.django_db
def test_product_list(client):
    Product.objects.create(name="A", slug="a", price=1000, is_active=True)
    resp = client.get(reverse("shop:list"))
    assert resp.status_code == 200
    assert b"A" in resp.content

@pytest.mark.django_db
def test_product_detail(client):
    Product.objects.create(name="A", slug="a", price=1000, is_active=True)
    resp = client.get(reverse("shop:detail", kwargs={"slug": "a"}))
    assert resp.status_code == 200
    assert b"A" in resp.content
```

---

### E-3. 즐겨찾기 토글 테스트

```python
# apps/shop/tests/test_favorite.py

import pytest
from django.urls import reverse
from django.contrib.auth import get_user_model
from apps.shop.models import Product, Favorite

User = get_user_model()

@pytest.mark.django_db
def test_toggle_favorite_requires_login(client):
    Product.objects.create(name="A", slug="a", price=1000, is_active=True)
    resp = client.post(reverse("shop:toggle_favorite", kwargs={"slug": "a"}))
    # 로그인 페이지로 리다이렉트
    assert resp.status_code == 302

@pytest.mark.django_db
def test_toggle_favorite_auth(client):
    user = User.objects.create_user(username="u", password="p")
    client.login(username="u", password="p")

    p = Product.objects.create(name="A", slug="a", price=1000, is_active=True)
    url = reverse("shop:toggle_favorite", kwargs={"slug": "a"})
    # add
    r1 = client.post(url, follow=True)
    assert Favorite.objects.filter(user=user, product=p).exists()
    # remove
    r2 = client.post(url, follow=True)
    assert not Favorite.objects.filter(user=user, product=p).exists()
```

---

### E-4. RequestFactory 로 CBV 직접 테스트

좀 더 세밀하게 CBV를 테스트하고 싶은 경우:

```python
# apps/shop/tests/test_cbv_internal.py

import pytest
from django.test import RequestFactory
from apps.shop.views import ProductListView
from apps.shop.models import Product

@pytest.mark.django_db
def test_product_list_view_context():
    rf = RequestFactory()
    request = rf.get("/shop/")
    Product.objects.create(name="A", slug="a", price=1000, is_active=True)

    view = ProductListView.as_view()
    response = view(request)
    assert response.status_code == 200
```

`Django 5.x` 문서에는 CBV를 직접 인스턴스화해서 `setup()` 을 호출하는 고급 패턴도 소개되어 있다. :contentReference[oaicite:5]{index=5}

---

## F. 성능/보안/유지보수 팁 — 라우팅·뷰·템플릿 관점

### F-1. 라우팅

- 네임드 URL / 네임스페이스를 **기본값**으로 사용.
- URL에 의미를 담되, **DB PK** 를 숨겨야 할 경우 슬러그/해시/UUID 컨버터 사용.
- `re_path` 남용 금지(정규식 디버깅 비용이 큼).
- i18n URL이 필요하다면 초기 설계 단계에서 `i18n_patterns` + slug 전략을 함께 잡을 것.

### F-2. 뷰

- DB 접근이 많은 리스트/상세 뷰에는 `select_related()` / `prefetch_related()` 필수 고려.
- `get_object_or_404` 로 404 응답을 일관되게 처리.
- 예외 상황에서는 적절한 403/404/500 템플릿을 사용해 사용자 경험 유지.
- async view 도입 시:
  - 외부 HTTP API 호출, 대기시간이 긴 I/O에 우선 적용.
  - ORM 트랜잭션 로직은 여전히 sync + `sync_to_async` 패턴 고려.

### F-3. 템플릿

- 상속/블록/부분 템플릿으로 **반복되는 레이아웃 제거**.
- 컨텍스트 프로세서는 “가벼운 전역 정보” 전용.
- 템플릿에서 복잡한 비즈니스 로직 구현 금지:
  - 로직은 view/service 계층.
  - 템플릿은 표현만 담당.

---

## G. 실무용 스니펫 모음

### G-1. Queryset 필터 믹스인

```python
class PublishedQuerysetMixin:
    def get_queryset(self):
        qs = super().get_queryset()
        return qs.filter(is_public=True)

class PublicPostList(PublishedQuerysetMixin, ListView):
    model = Post
    template_name = "blog/public_post_list.html"
```

---

### G-2. FormView + 메시지 패턴

```python
from django.views.generic import FormView
from django.contrib import messages
from django.urls import reverse_lazy

class ContactFormView(FormView):
    form_class = ContactForm
    template_name = "contact.html"
    success_url = reverse_lazy("core:home")

    def form_valid(self, form):
        form.send_mail()
        messages.success(self.request, "메시지를 보냈습니다.")
        return super().form_valid(form)
```

---

### G-3. 템플릿 부분 렌더링

{% raw %}
```html
{# templates/includes/_product_card.html #}
<div class="card">
  <a href="{% url 'shop:detail' slug=product.slug %}">{{ product.name }}</a>
  <span>{{ product.price }}원</span>
</div>
```
{% endraw %}

{% raw %}
```html
{# templates/shop/product_list.html #}
{% extends "base.html" %}
{% block content %}
  <h1>Products</h1>
  {% for p in products %}
    {% include "includes/_product_card.html" with product=p %}
  {% endfor %}
{% endblock %}
```
{% endraw %}

---

## H. 한눈에 보는 체크리스트

### URL

- [ ] `app_name` 정의 및 네임스페이스 사용
- [ ] 모든 링크/리디렉트에서 `reverse` / {% raw %}`{% url %}`{% endraw %} 사용
- [ ] `include()` 로 앱별 URLconf 모듈화
- [ ] `path()` 컨버터 우선, `re_path()` 최소화
- [ ] trailing slash, i18n URL 정책 일관성

### View

- [ ] 같은 기능군 내에서 FBV/CBV 스타일 일관성 유지
- [ ] CRUD/폼/목록은 제네릭 뷰 적극 활용
- [ ] 믹스인으로 권한/공통 컨텍스트/쿼리 패턴 캡슐화
- [ ] PRG 패턴, 메시지 프레임워크 사용
- [ ] `select_related`/`prefetch_related` 로 N+1 방지
- [ ] 필요 시 async view 도입(외부 I/O 중심)

### Template

- [ ] 상속/블록 구조로 레이아웃 통일
- [ ] 부분 템플릿/인클루전 태그로 중복 제거
- [ ] 자동 escaping 유지, `safe` 최소화
- [ ] 컨텍스트 프로세서는 가벼운 정보만
- [ ] 정적/미디어 경로 및 배포 전략(collectstatic, CDN 등) 정의

---

이 글에서 다룬 URLconf → View(FBV/CBV/제네릭/async) → Template(DTL/Jinja2) 흐름은  
Django 프로젝트의 **“코어 골격”** 이다.  

이 골격 위에, 이후 글에서 다룰

- ORM/모델/마이그레이션
- 인증/권한/세션
- DRF(API), 캐시, 시그널/비동기 작업

등을 덧붙이면, 실제 프로덕션에서 쓸 수 있는 Django 서비스의 흔한 패턴을 거의 모두 만들 수 있다.