---
layout: post
title: Django - 코어 개념 이해 (1)
date: 2025-10-01 15:25:23 +0900
category: Django
---
# 1. 코어 개념 이해 (1) — URL 라우팅, View(함수형/CBV/믹스인/제네릭), Template(DTL/Jinja2 비교) — Django 5.x 기준

## A. URL 라우팅(Core URLconf) — `path()`, `re_path()`, `include()`, 네임드 URL, 리버스

Django의 라우팅은 **URLconf(= URL configuration)** 라는 **파이썬 모듈**로 정의합니다. 가장 바깥 라우터는 **프로젝트 레벨 `config/urls.py`** 이고, 앱별로 **`apps/<app>/urls.py`** 를 둡니다.

### A-1. 프로젝트 레벨 URLconf 기본

```python
# config/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path("admin/", admin.site.urls),
    path("", include("apps.core.urls")),          # 루트로 core 앱 연결
    path("shop/", include("apps.shop.urls")),     # /shop/* 는 shop 앱으로 분기
]
```

- `include()` 로 **URL 네임스페이스 분리** 및 **앱 모듈화**.
- `admin/` 는 관리자 URL.

### A-2. 앱 레벨 URLconf — `path()` 기본, 네임스페이스

```python
# apps/core/urls.py
from django.urls import path
from . import views

app_name = "core"  # 네임스페이스: reverse('core:home') 등에서 사용

urlpatterns = [
    path("", views.home, name="home"),
    path("hello/<str:name>/", views.hello, name="hello"),            # 동적 세그먼트
    path("articles/<int:pk>/", views.article_detail, name="article"),# int 컨버터
]
```

- **URL 컨버터**: `<int:pk>`, `<str:slug>`, `<slug:slug>`, `<uuid:uid>`, `<path:subpath>` …
- `name` 파라미터로 **네임드 URL**을 만들고, **리버스(reverse)** 에서 사용.

### A-3. 리버스(Reverse) — 코드 곳곳에서 “URL 하드코딩 금지”

- **리버스 함수**: `django.urls.reverse("namespace:name", args=..., kwargs=...)`
- **템플릿 태그**: `{% url 'namespace:name' arg1 arg2 %}` 또는 `{% url 'namespace:name' key=value %}`

예시(뷰/서비스/리디렉트에서 사용):

```python
# apps/core/views.py
from django.shortcuts import redirect
from django.urls import reverse

def created(request, pk):
    # 생성 후 해당 상세 페이지로 리디렉트
    url = reverse("core:article", kwargs={"pk": pk})
    return redirect(url)
```

템플릿에서:

```html
<a href="{% url 'core:article' pk=object.pk %}">{{ object.title }}</a>
```

> **이점**: URL 변경에도 **코드 수정 최소화** (라우터만 수정하면 됨), **테스트 안정성** 향상.

### A-4. `re_path()` — 정규식 기반 라우팅

정규식이 필요한 복잡한 패턴에 사용합니다(가능하면 `path()` 컨버터로 충분히 처리).

```python
# apps/core/urls.py
from django.urls import re_path
from . import views

urlpatterns = [
    re_path(r"^y(?P<year>\d{4})/m(?P<month>\d{2})/$", views.archive, name="archive"),
]
```

뷰에서 파라미터:

```python
def archive(request, year, month):
    return HttpResponse(f"{year}-{month} archive")
```

- 정규식 그룹명 사용 시 `(?P<name>pattern)` 형태.
- 유지보수/가독성 측면에서 **필요할 때만** 사용.

### A-5. URL 네임스페이스 2단계 — 앱 네임스페이스 + 인스턴스 네임스페이스

- `app_name = "core"` 로 앱 네임스페이스 설정.
- `include((patterns, app_name), namespace="instance")` 방식으로 **인스턴스 네임스페이스**를 추가할 수 있음.

```python
# config/urls.py
from django.urls import include, path
from apps.shop import urls as shop_urls

urlpatterns = [
    path("shop-a/", include((shop_urls.urlpatterns, "shop"), namespace="shop_a")),
    path("shop-b/", include((shop_urls.urlpatterns, "shop"), namespace="shop_b")),
]
```

템플릿/뷰에서:

```html
{# shop-a 인스턴스의 product detail #}
<a href="{% url 'shop_a:product_detail' pk=1 %}">A 상품1</a>
```

### A-6. 라우팅에서 흔한 실수 & 체크리스트

- [ ] 네임드 URL 사용(하드코딩 금지).
- [ ] 네임스페이스(`app_name`) 설정.
- [ ] `include()` 로 앱 모듈 분리.
- [ ] 컨버터/정규식 혼용 주의(가능하면 컨버터 우선).
- [ ] trailing slash 정책 일관성(예: 모든 패스 끝에 `/` 붙이기).
- [ ] 국제화 URL, 다국어 슬래그 시 slugify 전략 별도 설계.

---

## B. View — 함수형 vs 클래스형(CBV), 믹스인, 제네릭 뷰 패턴

Django의 **View** 는 요청을 받아 응답을 돌려주는 **핵심 진입점**입니다.  
두 가지 큰 스타일:

1) **함수형 뷰(FBV)** — 간단/명시적, 소량의 로직에 좋음  
2) **클래스형 뷰(CBV)** — 재사용/확장성/구조화, **제네릭 뷰**로 CRUD 빠르게 구성

### B-1. 함수형 뷰(FBV) 기본

```python
# apps/core/views.py
from django.http import HttpResponse, JsonResponse
from django.shortcuts import render

def home(request):
    return render(request, "core/home.html", {"title": "Home"})

def ping(request):
    return JsonResponse({"pong": True})  # 간단 JSON 응답

def hello(request, name):
    return HttpResponse(f"Hello, {name}")
```

장점:
- 진입 장벽 낮음, 디버깅 쉬움
- 단순한 엔드포인트, 웹훅, 헬스체크 등에 적합

### B-2. 클래스형 뷰(CBV) 기본

CBV는 `View` 또는 제네릭 뷰를 상속하여, HTTP 메서드별 메서드(`get/post/...`)를 오버라이드합니다.

```python
# apps/core/views.py
from django.views import View
from django.http import HttpResponse

class EchoView(View):
    def get(self, request):
        return HttpResponse("GET OK")
    def post(self, request):
        return HttpResponse("POST OK")
```

URL 매핑:

```python
# apps/core/urls.py
from django.urls import path
from .views import EchoView

urlpatterns = [
    path("echo/", EchoView.as_view(), name="echo"),
]
```

장점:
- **상속/믹스인**으로 재사용성 우수
- **제네릭 뷰**로 CRUD/리스트/폼 처리 등 표준 패턴을 빠르게 구성

### B-3. 믹스인(Mixin) — 횡단 관심사 캡슐화

**권한/로그/공통 컨텍스트** 등을 믹스인으로 재사용합니다.

```python
# apps/common/mixins.py
from django.contrib.auth.mixins import LoginRequiredMixin
from django.utils.timezone import now

class TimestampContextMixin:
    """템플릿 컨텍스트에 공통 값 추가"""
    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        ctx["now"] = now()
        ctx["project_name"] = "MyService"
        return ctx

# 예: 로그인 필수 + 공통 컨텍스트
class MyBaseView(LoginRequiredMixin, TimestampContextMixin):
    login_url = "accounts:login"
    redirect_field_name = "next"
```

사용:

```python
# apps/core/views.py
from django.views.generic import TemplateView
from apps.common.mixins import MyBaseView

class DashboardView(MyBaseView, TemplateView):
    template_name = "core/dashboard.html"
```

> **주의**: **MRO(Method Resolution Order)** 상에서 `Mixin` 은 **왼쪽에 가까울수록 먼저 탐색**됩니다.  
> `class X(A, B, C):` — `A` → `B` → `C` 순으로 `super()`가 호출되도록 설계합니다.

### B-4. 제네릭 뷰(Generic Views) — CRUD 풀 코스

대표적인 제네릭 뷰:

- `ListView` — 목록
- `DetailView` — 상세
- `CreateView` — 생성
- `UpdateView` — 수정
- `DeleteView` — 삭제
- `FormView` — 임의 폼 처리
- `TemplateView` — 단순 템플릿 렌더

#### (1) 모델/폼 준비

```python
# apps/blog/models.py
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=150)
    slug = models.SlugField(unique=True)
    body = models.TextField()
    is_public = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
```

```python
# apps/blog/forms.py
from django import forms
from .models import Post

class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = ["title", "slug", "body", "is_public"]
```

#### (2) 목록/상세

```python
# apps/blog/views.py
from django.views.generic import ListView, DetailView
from .models import Post

class PostListView(ListView):
    model = Post
    queryset = Post.objects.filter(is_public=True).order_by("-created_at")
    template_name = "blog/post_list.html"
    context_object_name = "posts"
    paginate_by = 10

class PostDetailView(DetailView):
    model = Post
    slug_field = "slug"
    slug_url_kwarg = "slug"     # URL: /blog/<slug>/
    template_name = "blog/post_detail.html"
    context_object_name = "post"
```

URL:

```python
# apps/blog/urls.py
from django.urls import path
from .views import PostListView, PostDetailView

app_name = "blog"
urlpatterns = [
    path("", PostListView.as_view(), name="list"),
    path("<slug:slug>/", PostDetailView.as_view(), name="detail"),
]
```

템플릿:

```html
{# templates/blog/post_list.html #}
{% extends "base.html" %}
{% block content %}
 <h1>Posts</h1>
 <ul>
   {% for p in posts %}
     <li><a href="{% url 'blog:detail' slug=p.slug %}">{{ p.title }}</a></li>
   {% empty %}
     <li>No posts.</li>
   {% endfor %}
 </ul>

 {# 페이지네이션 #}
 {% if is_paginated %}
   <div>
     {% if page_obj.has_previous %}
       <a href="?page={{ page_obj.previous_page_number }}">Prev</a>
     {% endif %}
     Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}
     {% if page_obj.has_next %}
       <a href="?page={{ page_obj.next_page_number }}">Next</a>
     {% endif %}
   </div>
 {% endif %}
{% endblock %}
```

#### (3) 생성/수정/삭제 — 폼 처리

```python
# apps/blog/views.py
from django.urls import reverse_lazy
from django.views.generic import CreateView, UpdateView, DeleteView
from .forms import PostForm
from .models import Post

class PostCreateView(CreateView):
    model = Post
    form_class = PostForm
    template_name = "blog/post_form.html"
    success_url = reverse_lazy("blog:list")

class PostUpdateView(UpdateView):
    model = Post
    form_class = PostForm
    slug_field = "slug"
    slug_url_kwarg = "slug"
    template_name = "blog/post_form.html"
    success_url = reverse_lazy("blog:list")

class PostDeleteView(DeleteView):
    model = Post
    slug_field = "slug"
    slug_url_kwarg = "slug"
    template_name = "blog/post_confirm_delete.html"
    success_url = reverse_lazy("blog:list")
```

URL:

```python
# apps/blog/urls.py
from django.urls import path
from .views import PostCreateView, PostUpdateView, PostDeleteView

urlpatterns += [
    path("new/", PostCreateView.as_view(), name="create"),
    path("<slug:slug>/edit/", PostUpdateView.as_view(), name="update"),
    path("<slug:slug>/delete/", PostDeleteView.as_view(), name="delete"),
]
```

템플릿:

```html
{# templates/blog/post_form.html #}
{% extends "base.html" %}
{% block content %}
  <h1>{{ view.object|default:'New Post' }}</h1>
  <form method="post">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Save</button>
  </form>
{% endblock %}
```

권한 보호(믹스인 결합):

```python
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin

class StaffRequiredMixin(UserPassesTestMixin):
    def test_func(self):
        return self.request.user.is_staff

class PostCreateView(LoginRequiredMixin, StaffRequiredMixin, CreateView):
    ...
```

### B-5. FBV vs CBV 선택 가이드

- **FBV**: 엔드포인트가 단순, 로직이 짧음, 빠른 구현/읽기 쉬움
- **CBV**: **CRUD/폼 처리/목록/페이지네이션** 같은 **반복 패턴**을 재사용, 규모가 커질수록 유리
- **팀 컨벤션**: 혼용해도 되지만, 같은 기능군에서는 일관성 유지 권장

### B-6. 비동기 뷰(5.x, ASGI) 기초

```python
# apps/api/views.py
from django.http import JsonResponse

async def async_ping(request):
    return JsonResponse({"pong": True})
```

- **주의**: ORM은 완전한 async 전환이 아니므로 **스레드 풀 오프로딩**을 이용하거나, I/O 바인딩 작업에 한정해 async 활용.
- 복잡한 비동기 워크플로우는 **Channels/WebSocket** 또는 **Celery(작업 큐)** 와 조합.

---

## C. Template — DTL(템플릿 언어), 상속/블록, 필터/태그, 커스텀 태그/필터, 컨텍스트 프로세서, Jinja2 비교

### C-1. DTL 기본 문법

**변수 출력**:

```html
<p>{{ user.username }}</p>
```

**필터**:

```html
{{ title|upper }}
{{ created_at|date:"Y-m-d" }}
{{ text|linebreaks }}
```

**태그**:

```html
{% if user.is_authenticated %}
  Hello, {{ user.username }}
{% else %}
  Please login.
{% endif %}

{% for obj in objects %}
  <li>{{ forloop.counter }}. {{ obj }}</li>
{% empty %}
  <li>No data.</li>
{% endfor %}
```

**주석**:

```html
{# 이것은 템플릿 주석 #}
```

**안전성**:

- DTL은 **자동 escaping** (XSS 방지). 신뢰 가능한 HTML만 `|safe` 사용:

```html
{{ html_snippet|safe }}
```

> **주의**: 사용자 입력에 `safe` 사용 금지. 서버에서 정규화/화이트리스트/마크다운 렌더러 사용 등으로 통제.

### C-2. 템플릿 상속 & 블록

**베이스 템플릿**:

```html
{# templates/base.html #}
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>{% block title %}MySite{% endblock %}</title>
  </head>
  <body>
    <nav>
      <a href="{% url 'core:home' %}">Home</a>
    </nav>
    <hr>
    {% block content %}{% endblock %}
  </body>
</html>
```

**상속**:

```html
{# templates/blog/post_detail.html #}
{% extends "base.html" %}
{% block title %}{{ post.title }} | MySite{% endblock %}

{% block content %}
  <h1>{{ post.title }}</h1>
  <p>{{ post.body|linebreaks }}</p>
{% endblock %}
```

- **장점**: 공통 레이아웃/헤더/푸터 재사용, 유지보수 쉬움.

### C-3. 템플릿 네임스페이스/경로 전략

- 전역 `templates/` + 앱별 네임스페이스 폴더 추천:
```
templates/
├─ base.html
├─ core/
│  └─ home.html
└─ blog/
   ├─ post_list.html
   └─ post_detail.html
```

- `TEMPLATES['DIRS']` 에 `BASE_DIR / "templates"` 추가.
- 앱 내부 템플릿(`app/templates/appname/*.html`)을 함께 사용할 수 있음.

### C-4. 커스텀 필터/태그 — 템플릿 태그 라이브러리

**구조**:

```
apps/common/templatetags/
├─ __init__.py
└─ common_tags.py
```

**필터 정의**:

```python
# apps/common/templatetags/common_tags.py
from django import template

register = template.Library()

@register.filter
def cut(value: str, arg: str):
    """문자열에서 arg를 삭제"""
    return value.replace(arg, "")
```

**간단 태그**:

```python
@register.simple_tag
def copyright(year=None):
    from django.utils.timezone import now
    y = year or now().year
    return f"© {y} MyCompany"
```

**인클루전 태그**(부분 템플릿 렌더링):

```python
@register.inclusion_tag("common/_badge.html")
def badge(text, state="info"):
    return {"text": text, "state": state}
```

부분 템플릿:

```html
{# templates/common/_badge.html #}
<span class="badge badge-{{ state }}">{{ text }}</span>
```

**템플릿 사용**:

```html
{% load common_tags %}

<p>{{ "hello world"|cut:" " }}</p>
<footer>{% copyright 2025 %}</footer>
<p>{% badge "New" "success" %}</p>
```

### C-5. 컨텍스트 프로세서 — 모든 템플릿에 공통 데이터 주입

**컨텍스트 프로세서**는 템플릿 렌더링 시 **자동으로 컨텍스트에 값을 추가**합니다.

```python
# apps/common/context_processors.py
def global_settings(request):
    return {
        "SITE_NAME": "MySite",
        "SUPPORT_EMAIL": "support@example.com",
    }
```

`settings.py`:

```python
TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "apps.common.context_processors.global_settings",  # 추가
            ],
        },
    },
]
```

템플릿 어디서든:

```html
<footer>
  {{ SITE_NAME }} — <a href="mailto:{{ SUPPORT_EMAIL }}">Contact</a>
</footer>
```

> **주의**: **무거운 쿼리/계산**은 컨텍스트 프로세서에 넣지 말 것(모든 요청에 실행됨).

### C-6. 정적 파일/미디어와 템플릿

```python
# settings
STATIC_URL = "static/"
STATICFILES_DIRS = [BASE_DIR / "static"]
MEDIA_URL = "media/"
MEDIA_ROOT = BASE_DIR / "media"
```

템플릿:

```html
{% load static %}
<link rel="stylesheet" href="{% static 'css/site.css' %}">
<img src="{{ post.image.url }}" alt="">
```

> 운영에서는 `collectstatic` 후 Nginx/CloudFront 등에서 정적/미디어를 서빙.

### C-7. Jinja2 비교 — 언제 DTL 대신 Jinja2?

Django는 기본 **DTL** 이외에도 **Jinja2** 를 백엔드로 사용할 수 있습니다.

**선호 포인트(Jinja2)**:
- 파이썬 문법과 유사한 **표현력** (필터/매크로/제어구조가 강력)
- **다른 프레임워크(Flask)** 와 호환되는 템플릿을 재사용 가능

**설정 예시**:

```python
# settings.py
from pathlib import Path
BASE_DIR = Path(__file__).resolve().parent.parent

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.jinja2.Jinja2",
        "DIRS": [BASE_DIR / "jinja2"],       # Jinja2 전용 디렉터리
        "APP_DIRS": False,
        "OPTIONS": {
            "environment": "config.jinja2_env.environment",
        },
    },
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],    # DTL 전용 디렉터리
        "APP_DIRS": True,
        "OPTIONS": {"context_processors": [
            "django.template.context_processors.request",
            "django.contrib.auth.context_processors.auth",
        ]},
    },
]
```

환경 팩토리:

```python
# config/jinja2_env.py
from jinja2 import Environment
from django.contrib.staticfiles.storage import staticfiles_storage
from django.urls import reverse

def environment(**options):
    env = Environment(**options)
    # Django 도우미 주입
    env.globals.update({
        "static": staticfiles_storage.url,
        "url": reverse,
    })
    return env
```

Jinja2 템플릿:

```jinja2
{# jinja2/blog/detail.html #}
<!doctype html>
<title>{{ post.title }} | MySite</title>
<h1>{{ post.title }}</h1>
<p>{{ post.body | safe }}</p>
<a href="{{ url('blog:list') }}">Back</a>
```

**DTL vs Jinja2 의사결정**:

- DTL: Django 기본, 자동 escaping 안전성, **프로젝트 표준/문서/예시가 풍부**, 관리자/서드파티와 자연스러운 궁합
- Jinja2: **표현력/퍼포먼스**(상황에 따라), Flask 등과 공유 자산, 템플릿 매크로를 적극 활용하는 팀

**혼용 전략**: Jinja2와 DTL을 **분리된 디렉터리**에 두고, 페이지/앱 특성에 따라 선택.  
단, **팀 컨벤션**과 **템플릿 태그/필터 재사용성**을 고려해 **하나로 통일**하는 것이 유지보수에 유리합니다.

---

## D. 예제: “상품 목록/상세 + 즐겨찾기 토글” — FBV/CBV/제네릭/템플릿 총집합

### D-1. 모델

```python
# apps/shop/models.py
from django.conf import settings
from django.db import models

class Product(models.Model):
    name = models.CharField(max_length=120)
    slug = models.SlugField(unique=True)
    price = models.PositiveIntegerField()
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)

class Favorite(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name="favorites")
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("user", "product")
```

마이그레이션:

```bash
python manage.py makemigrations
python manage.py migrate
```

### D-2. URLconf

```python
# apps/shop/urls.py
from django.urls import path
from . import views

app_name = "shop"
urlpatterns = [
    path("", views.ProductListView.as_view(), name="list"),
    path("<slug:slug>/", views.ProductDetailView.as_view(), name="detail"),
    path("<slug:slug>/fav/", views.toggle_favorite, name="toggle_favorite"),
]
```

### D-3. CBV — 목록/상세

```python
# apps/shop/views.py
from django.views.generic import ListView, DetailView
from django.contrib.auth.decorators import login_required
from django.shortcuts import get_object_or_404, redirect
from .models import Product, Favorite

class ProductListView(ListView):
    model = Product
    queryset = Product.objects.filter(is_active=True).order_by("-created_at")
    template_name = "shop/product_list.html"
    context_object_name = "products"
    paginate_by = 20

class ProductDetailView(DetailView):
    model = Product
    slug_field = "slug"
    slug_url_kwarg = "slug"
    template_name = "shop/product_detail.html"
    context_object_name = "product"

    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        if self.request.user.is_authenticated:
            ctx["is_favorited"] = Favorite.objects.filter(
                user=self.request.user, product=self.object
            ).exists()
        else:
            ctx["is_favorited"] = False
        return ctx
```

### D-4. FBV — 즐겨찾기 토글

```python
# apps/shop/views.py (계속)
from django.contrib import messages
from django.urls import reverse

@login_required
def toggle_favorite(request, slug):
    product = get_object_or_404(Product, slug=slug, is_active=True)
    fav, created = Favorite.objects.get_or_create(user=request.user, product=product)
    if not created:
        fav.delete()
        messages.success(request, "즐겨찾기에서 제거했습니다.")
    else:
        messages.success(request, "즐겨찾기에 추가했습니다.")
    return redirect(reverse("shop:detail", kwargs={"slug": slug}))
```

### D-5. 템플릿

```html
{# templates/shop/product_list.html #}
{% extends "base.html" %}
{% block content %}
  <h1>Products</h1>
  <ul>
    {% for p in products %}
      <li>
        <a href="{% url 'shop:detail' slug=p.slug %}">{{ p.name }}</a> — {{ p.price }}원
      </li>
    {% empty %}
      <li>상품이 없습니다.</li>
    {% endfor %}
  </ul>

  {% if is_paginated %}
    <div>
      {% if page_obj.has_previous %}
        <a href="?page={{ page_obj.previous_page_number }}">Prev</a>
      {% endif %}
      {{ page_obj.number }} / {{ page_obj.paginator.num_pages }}
      {% if page_obj.has_next %}
        <a href="?page={{ page_obj.next_page_number }}">Next</a>
      {% endif %}
    </div>
  {% endif %}
{% endblock %}
```

```html
{# templates/shop/product_detail.html #}
{% extends "base.html" %}
{% block content %}
  <h1>{{ product.name }}</h1>
  <p>가격: {{ product.price }}원</p>

  {% if user.is_authenticated %}
    <form method="post" action="{% url 'shop:toggle_favorite' slug=product.slug %}">
      {% csrf_token %}
      {% if is_favorited %}
        <button type="submit">즐겨찾기 제거</button>
      {% else %}
        <button type="submit">즐겨찾기 추가</button>
      {% endif %}
    </form>
  {% else %}
    <p><a href="{% url 'accounts:login' %}?next={{ request.path }}">로그인</a> 후 즐겨찾기 사용 가능</p>
  {% endif %}

  <p><a href="{% url 'shop:list' %}">목록으로</a></p>
{% endblock %}
```

---

## E. 테스트 — URL 리버스/뷰/템플릿 흐름 검증

### E-1. URL 리버스/리졸브

```python
# apps/shop/tests/test_urls.py
import pytest
from django.urls import reverse, resolve

def test_reverse_and_resolve():
    url = reverse("shop:list")
    assert url == "/shop/"
    resolver = resolve("/shop/")
    assert resolver.namespace == "shop"
    assert resolver.url_name == "list"
```

### E-2. 뷰 테스트(목록/상세)

```python
# apps/shop/tests/test_views.py
import pytest
from django.urls import reverse
from apps.shop.models import Product

@pytest.mark.django_db
def test_product_list(client):
    Product.objects.create(name="A", slug="a", price=1000, is_active=True)
    resp = client.get(reverse("shop:list"))
    assert resp.status_code == 200
    assert b"A" in resp.content

@pytest.mark.django_db
def test_product_detail(client):
    Product.objects.create(name="A", slug="a", price=1000, is_active=True)
    resp = client.get(reverse("shop:detail", kwargs={"slug": "a"}))
    assert resp.status_code == 200
    assert b"A" in resp.content
```

### E-3. 토글(로그인 필요) 테스트

```python
# apps/shop/tests/test_favorite.py
import pytest
from django.urls import reverse
from django.contrib.auth import get_user_model
from apps.shop.models import Product, Favorite

User = get_user_model()

@pytest.mark.django_db
def test_toggle_favorite_requires_login(client):
    Product.objects.create(name="A", slug="a", price=1000, is_active=True)
    resp = client.post(reverse("shop:toggle_favorite", kwargs={"slug": "a"}))
    assert resp.status_code in (302,)  # login redirect

@pytest.mark.django_db
def test_toggle_favorite_auth(client):
    user = User.objects.create_user(username="u", password="p")
    client.login(username="u", password="p")

    p = Product.objects.create(name="A", slug="a", price=1000, is_active=True)
    url = reverse("shop:toggle_favorite", kwargs={"slug": "a"})
    # add
    r1 = client.post(url, follow=True)
    assert Favorite.objects.filter(user=user, product=p).exists()
    # remove
    r2 = client.post(url, follow=True)
    assert not Favorite.objects.filter(user=user, product=p).exists()
```

---

## F. 성능/보안/유지보수 팁 — 라우팅·뷰·템플릿 관점

### F-1. 라우팅
- **리버스 필수**: 하드코딩 금지
- **네임스페이스** 습관화: 앱/인스턴스 네임스페이스
- **정규식 최소화**: `path()` 컨버터 우선
- **국제화 URL** 고려 시 `i18n_patterns` 활용

### F-2. 뷰
- **쿼리 최적화**: `select_related()`/`prefetch_related()`  
- **권한/인증**: 믹스인/데코레이터로 표준화  
- **예외 처리**: `get_object_or_404` / 404/403 응답  
- **POST-Redirect-GET** 패턴: 중복 제출 방지  
- **메시지 프레임워크**: 사용자 피드백 일관화  
- **비동기**: DB I/O 병목 주의, 필요 시 작업 큐/실시간 채널

### F-3. 템플릿
- **상속 구조**로 공통 레이아웃 정리
- **부분 템플릿**(`include` / 인클루전 태그)로 중복 제거
- **자동 escaping**을 기본으로, `safe` 최소화
- **컨텍스트 프로세서 남용 금지**(무거운 계산/쿼리 X)
- **정적 파일 버전 전략**(캐시 무효화)과 CDN 고려

---

## G. 실무용 스니펫 모음

### G-1. URL Path Converter 커스텀

```python
# apps/common/converters.py
class HexConverter:
    regex = "[0-9a-f]{32}"

    def to_python(self, value):
        return value  # 필요시 변환
    def to_url(self, value):
        return value

# config/urls.py
from django.urls import register_converter
from apps.common.converters import HexConverter
register_converter(HexConverter, "hex")

urlpatterns = [
    path("t/<hex:token>/", views.token_view, name="token"),
]
```

### G-2. CBV에서 공통 쿼리셋 훅

```python
class PublishedQuerysetMixin:
    def get_queryset(self):
        qs = super().get_queryset()
        return qs.filter(is_public=True)

class PublicPostList(PublishedQuerysetMixin, ListView):
    model = Post
```

### G-3. FormView + 메시지 패턴

```python
from django.views.generic import FormView
from django.contrib import messages
from django.urls import reverse_lazy

class ContactFormView(FormView):
    form_class = ContactForm
    template_name = "contact.html"
    success_url = reverse_lazy("core:home")

    def form_valid(self, form):
        form.send_mail()
        messages.success(self.request, "메시지를 보냈습니다.")
        return super().form_valid(form)
```

### G-4. 템플릿에서 부분 렌더링

```html
{# templates/includes/_product_card.html #}
<div class="card">
  <a href="{% url 'shop:detail' slug=product.slug %}">{{ product.name }}</a>
  <span>{{ product.price }}원</span>
</div>
```

```html
{# templates/shop/product_list.html #}
{% extends "base.html" %}
{% block content %}
  <h1>Products</h1>
  {% for p in products %}
    {% include "includes/_product_card.html" with product=p %}
  {% endfor %}
{% endblock %}
```

---

## H. 마무리 — 한눈에 보는 체크리스트

- **URL**
  - [ ] `app_name`/네임스페이스
  - [ ] `include()` 모듈화
  - [ ] 컨버터 우선, `re_path` 최소화
  - [ ] 모든 링크/리디렉트는 **reverse**/`{% url %}` 사용
- **View**
  - [ ] FBV/CBV 일관성(기능군 기준)
  - [ ] 제네릭 뷰 적극 활용(CRUD/목록/폼)
  - [ ] 믹스인으로 권한/공통 컨텍스트/쿼리 패턴 캡슐화
  - [ ] PRG(Post-Redirect-Get), 메시지 프레임워크
  - [ ] `select_related`/`prefetch_related` 로 N+1 방지
- **Template**
  - [ ] 상속/블록/부분 템플릿 구조화
  - [ ] 자동 escaping 유지, `safe` 최소화
  - [ ] 커스텀 태그/필터는 **templatetags** 로 공유
  - [ ] 컨텍스트 프로세서는 가볍게
  - [ ] 정적/미디어 경로 및 배포 전략(collectstatic/CDN)
