---
layout: post
title: 파이썬 심화 - 네트워크와 웹 프로그래밍 (1)
date: 2025-12-03 21:30:23 +0900
category: 파이썬 심화
---
# 네트워크와 웹 프로그래밍 (1)

## HTTP 클라이언트 구현과 서비스 통신

파이썬에서 HTTP 서비스와 통신하는 방법은 여러 가지가 있지만, `requests` 라이브러리가 가장 널리 사용됩니다. 고급 사용을 위한 다양한 패턴을 알아봅니다.

### 고급 HTTP 클라이언트 구현

```python
import requests
import aiohttp
import asyncio
from typing import Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import json
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

@dataclass
class HTTPClientConfig:
    """HTTP 클라이언트 설정 클래스"""
    timeout: int = 30
    max_retries: int = 3
    backoff_factor: float = 0.5
    user_agent: str = "PythonHTTPClient/1.0"
    default_headers: Dict[str, str] = None
    
    def __post_init__(self):
        if self.default_headers is None:
            self.default_headers = {
                "User-Agent": self.user_agent,
                "Accept": "application/json",
                "Content-Type": "application/json"
            }

class ResilientHTTPClient:
    """복원력 있는 HTTP 클라이언트"""
    
    def __init__(self, config: HTTPClientConfig = None):
        self.config = config or HTTPClientConfig()
        self.session = self._create_session()
        self.cache = {}  # 간단한 캐시 구현
    
    def _create_session(self) -> requests.Session:
        """재시도 로직이 포함된 세션 생성"""
        session = requests.Session()
        
        # 재시도 전략 구성
        retry_strategy = Retry(
            total=self.config.max_retries,
            backoff_factor=self.config.backoff_factor,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST", "PUT", "DELETE"]
        )
        
        # 어댑터 설정
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        
        # 기본 헤더 설정
        session.headers.update(self.config.default_headers)
        
        return session
    
    def request(self, method: str, url: str, **kwargs) -> requests.Response:
        """HTTP 요청 실행 (캐싱 지원)"""
        # 캐시 키 생성 (GET 요청에만 캐시 적용)
        cache_key = None
        if method.upper() == "GET":
            cache_key = f"{method}:{url}:{str(kwargs.get('params', ''))}"
            if cache_key in self.cache:
                cached_response = self.cache[cache_key]
                # 캐시 유효성 검사 (예: 5분)
                if (datetime.now() - cached_response['timestamp']).seconds < 300:
                    print(f"캐시에서 응답 반환: {url}")
                    return cached_response['response']
        
        # 실제 요청 실행
        kwargs.setdefault('timeout', self.config.timeout)
        response = self.session.request(method, url, **kwargs)
        
        # 응답 검증
        response.raise_for_status()
        
        # 캐시 저장 (GET 요청만)
        if cache_key and response.status_code == 200:
            self.cache[cache_key] = {
                'response': response,
                'timestamp': datetime.now()
            }
        
        return response
    
    def get_json(self, url: str, **kwargs) -> Any:
        """JSON 응답을 파싱하여 반환"""
        response = self.request('GET', url, **kwargs)
        return response.json()
    
    def post_json(self, url: str, data: Dict, **kwargs) -> Any:
        """JSON 데이터를 POST로 전송"""
        kwargs.setdefault('json', data)
        response = self.request('POST', url, **kwargs)
        return response.json()
    
    def close(self):
        """세션 정리"""
        self.session.close()
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

# 비동기 HTTP 클라이언트
class AsyncHTTPClient:
    """비동기 HTTP 클라이언트"""
    
    def __init__(self, timeout: int = 30):
        self.timeout = aiohttp.ClientTimeout(total=timeout)
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(timeout=self.timeout)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def fetch_json(self, url: str, method: str = "GET", **kwargs) -> Any:
        """비동기 JSON 요청"""
        async with self.session.request(method, url, **kwargs) as response:
            response.raise_for_status()
            return await response.json()
    
    async def concurrent_requests(self, requests_list):
        """여러 요청을 동시에 실행"""
        tasks = []
        for req in requests_list:
            task = self.fetch_json(req['url'], req.get('method', 'GET'), **req.get('kwargs', {}))
            tasks.append(task)
        
        return await asyncio.gather(*tasks, return_exceptions=True)

# 사용 예시
if __name__ == "__main__":
    # 동기 클라이언트 사용
    with ResilientHTTPClient() as client:
        # API 호출
        data = client.get_json("https://api.example.com/data")
        print(f"API 응답: {data}")
        
        # POST 요청
        result = client.post_json("https://api.example.com/create", 
                                 {"name": "테스트", "value": 123})
        print(f"생성 결과: {result}")
```

## TCP 서버 구현 패턴

TCP 서버는 신뢰성 있는 연결 지향 통신을 제공합니다. 파이썬의 `socket`과 `asyncio`를 활용한 다양한 구현 패턴을 살펴봅니다.

### 멀티스레드 TCP 서버

```python
import socket
import threading
import json
from typing import Callable, Optional
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TCPServer:
    """멀티스레드 TCP 서버"""
    
    def __init__(self, host: str = '127.0.0.1', port: int = 8888,
                 max_connections: int = 10,
                 handler: Optional[Callable] = None):
        self.host = host
        self.port = port
        self.max_connections = max_connections
        self.handler = handler or self.default_handler
        self.server_socket = None
        self.is_running = False
        self.client_threads = []
    
    def default_handler(self, client_socket: socket.socket, client_address: tuple):
        """기본 요청 처리기"""
        try:
            logger.info(f"클라이언트 연결: {client_address}")
            
            # 데이터 수신
            data = client_socket.recv(1024)
            if not data:
                return
            
            message = data.decode('utf-8')
            logger.info(f"수신된 데이터: {message}")
            
            # 응답 생성
            response = {
                "status": "success",
                "message": f"수신됨: {message}",
                "client": client_address
            }
            
            # JSON 응답 전송
            client_socket.sendall(json.dumps(response).encode('utf-8'))
            
        except Exception as e:
            logger.error(f"요청 처리 중 오류: {e}")
        finally:
            client_socket.close()
    
    def handle_client(self, client_socket: socket.socket, client_address: tuple):
        """클라이언트 연결 처리"""
        try:
            self.handler(client_socket, client_address)
        except Exception as e:
            logger.error(f"클라이언트 처리 중 오류: {e}")
    
    def start(self):
        """서버 시작"""
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server_socket.bind((self.host, self.port))
        self.server_socket.listen(self.max_connections)
        
        self.is_running = True
        logger.info(f"TCP 서버 시작됨: {self.host}:{self.port}")
        
        try:
            while self.is_running:
                client_socket, client_address = self.server_socket.accept()
                
                # 새 스레드에서 클라이언트 처리
                client_thread = threading.Thread(
                    target=self.handle_client,
                    args=(client_socket, client_address),
                    daemon=True
                )
                client_thread.start()
                self.client_threads.append(client_thread)
                
        except KeyboardInterrupt:
            logger.info("서버 종료 요청 수신")
        except Exception as e:
            logger.error(f"서버 실행 중 오류: {e}")
        finally:
            self.stop()
    
    def stop(self):
        """서버 정지"""
        self.is_running = False
        if self.server_socket:
            self.server_socket.close()
        logger.info("TCP 서버 종료됨")

# 고급 TCP 핸들러 예시
class ProtocolHandler:
    """프로토콜 처리기"""
    
    def __init__(self):
        self.commands = {
            "ECHO": self.handle_echo,
            "TIME": self.handle_time,
            "STATS": self.handle_stats
        }
        self.message_count = 0
    
    def handle_echo(self, args):
        """ECHO 명령 처리"""
        return {"command": "ECHO", "result": " ".join(args)}
    
    def handle_time(self, args):
        """TIME 명령 처리"""
        from datetime import datetime
        return {"command": "TIME", "result": datetime.now().isoformat()}
    
    def handle_stats(self, args):
        """STATS 명령 처리"""
        return {"command": "STATS", "message_count": self.message_count}
    
    def process(self, message: str):
        """메시지 처리"""
        self.message_count += 1
        
        parts = message.strip().split()
        if not parts:
            return {"error": "빈 메시지"}
        
        command = parts[0].upper()
        args = parts[1:] if len(parts) > 1 else []
        
        if command in self.commands:
            return self.commands[command](args)
        else:
            return {"error": f"알 수 없는 명령: {command}"}
```

### 비동기 TCP 서버

```python
import asyncio
import json
from typing import Dict, Any

class AsyncTCPServer:
    """비동기 TCP 서버 (asyncio 기반)"""
    
    def __init__(self, host: str = '127.0.0.1', port: int = 8889):
        self.host = host
        self.port = port
        self.clients = {}  # client_id -> writer 매핑
        self.protocol_handler = ProtocolHandler()
    
    async def handle_client(self, reader: asyncio.StreamReader, 
                           writer: asyncio.StreamWriter):
        """클라이언트 연결 비동기 처리"""
        client_addr = writer.get_extra_info('peername')
        client_id = f"{client_addr[0]}:{client_addr[1]}"
        
        self.clients[client_id] = writer
        print(f"새 클라이언트 연결: {client_id}")
        
        try:
            while True:
                # 데이터 수신 대기
                data = await reader.read(1024)
                if not data:
                    break
                
                # 메시지 처리
                message = data.decode('utf-8').strip()
                print(f"[{client_id}] 수신: {message}")
                
                # 프로토콜 처리
                response = self.protocol_handler.process(message)
                
                # 응답 전송
                response_json = json.dumps(response)
                writer.write(response_json.encode('utf-8'))
                await writer.drain()
                
        except asyncio.CancelledError:
            print(f"클라이언트 연결 취소: {client_id}")
        except Exception as e:
            print(f"클라이언트 처리 오류 ({client_id}): {e}")
        finally:
            # 연결 정리
            del self.clients[client_id]
            writer.close()
            await writer.wait_closed()
            print(f"클라이언트 연결 종료: {client_id}")
    
    async def broadcast(self, message: str):
        """모든 클라이언트에 메시지 브로드캐스트"""
        for client_id, writer in self.clients.items():
            try:
                writer.write(message.encode('utf-8'))
                await writer.drain()
            except Exception as e:
                print(f"브로드캐스트 실패 ({client_id}): {e}")
    
    async def start_server(self):
        """서버 시작"""
        server = await asyncio.start_server(
            self.handle_client,
            self.host,
            self.port
        )
        
        addr = server.sockets[0].getsockname()
        print(f'비동기 TCP 서버 시작됨: {addr}')
        
        async with server:
            await server.serve_forever()
    
    def run(self):
        """서버 실행"""
        asyncio.run(self.start_server())
```

## UDP 서버 구현

UDP는 비연결형 프로토콜로, 빠른 데이터 전송이 필요한 경우에 적합합니다.

```python
import socket
import threading
import struct
from datetime import datetime
from typing import Tuple, Optional
import json

class UDPServer:
    """고급 UDP 서버"""
    
    def __init__(self, host: str = '127.0.0.1', port: int = 9999,
                 buffer_size: int = 4096):
        self.host = host
        self.port = port
        self.buffer_size = buffer_size
        self.server_socket = None
        self.is_running = False
        self.clients = {}  # 간단한 클라이언트 상태 추적
        self.packet_counter = 0
    
    def start(self):
        """UDP 서버 시작"""
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server_socket.bind((self.host, self.port))
        
        self.is_running = True
        print(f"UDP 서버 시작됨: {self.host}:{self.port}")
        
        # 멀티스레드 처리기 시작
        receiver_thread = threading.Thread(target=self.receive_messages, daemon=True)
        receiver_thread.start()
        
        # 통계 출력 스레드 (선택적)
        stats_thread = threading.Thread(target=self.print_stats, daemon=True)
        stats_thread.start()
        
        try:
            receiver_thread.join()
        except KeyboardInterrupt:
            print("서버 종료 요청 수신")
        finally:
            self.stop()
    
    def receive_messages(self):
        """메시지 수신 처리"""
        while self.is_running:
            try:
                data, client_address = self.server_socket.recvfrom(self.buffer_size)
                self.packet_counter += 1
                
                # 클라이언트 등록
                if client_address not in self.clients:
                    self.clients[client_address] = {
                        'first_seen': datetime.now(),
                        'packet_count': 0
                    }
                
                self.clients[client_address]['packet_count'] += 1
                self.clients[client_address]['last_seen'] = datetime.now()
                
                # 메시지 처리 (별도 스레드에서)
                thread = threading.Thread(
                    target=self.process_message,
                    args=(data, client_address),
                    daemon=True
                )
                thread.start()
                
            except socket.timeout:
                continue
            except Exception as e:
                print(f"데이터 수신 오류: {e}")
    
    def process_message(self, data: bytes, client_address: Tuple[str, int]):
        """메시지 처리"""
        try:
            # 메시지 디코딩 시도
            try:
                message = data.decode('utf-8')
                response = self.handle_text_message(message)
            except UnicodeDecodeError:
                # 이진 데이터 처리
                response = self.handle_binary_data(data)
            
            # 응답 전송
            if response:
                if isinstance(response, str):
                    response_data = response.encode('utf-8')
                elif isinstance(response, dict):
                    response_data = json.dumps(response).encode('utf-8')
                else:
                    response_data = response
                
                self.server_socket.sendto(response_data, client_address)
                
        except Exception as e:
            print(f"메시지 처리 오류 ({client_address}): {e}")
    
    def handle_text_message(self, message: str) -> str:
        """텍스트 메시지 처리"""
        message = message.strip()
        
        if message.upper() == "PING":
            return "PONG"
        elif message.upper() == "TIME":
            return datetime.now().isoformat()
        elif message.upper() == "STATS":
            return json.dumps({
                "total_packets": self.packet_counter,
                "active_clients": len(self.clients)
            })
        else:
            return f"ECHO: {message}"
    
    def handle_binary_data(self, data: bytes) -> bytes:
        """이진 데이터 처리"""
        # 간단한 이진 프로토콜 예시
        if len(data) >= 4:
            # 첫 4바이트를 정수로 해석
            value = struct.unpack('!I', data[:4])[0]
            # 값에 1을 더하여 반환
            return struct.pack('!I', value + 1)
        return b'INVALID'
    
    def print_stats(self):
        """서버 통계 출력"""
        import time
        while self.is_running:
            time.sleep(10)  # 10초마다 통계 출력
            print(f"\n[UDP 서버 통계]")
            print(f"총 수신 패킷: {self.packet_counter}")
            print(f"활성 클라이언트: {len(self.clients)}")
            for addr, info in list(self.clients.items())[:5]:  # 최대 5개 출력
                age = datetime.now() - info['first_seen']
                print(f"  {addr}: {info['packet_count']} packets, age: {age}")
    
    def stop(self):
        """서버 정지"""
        self.is_running = False
        if self.server_socket:
            self.server_socket.close()
        print("UDP 서버 종료됨")

# 사용 예시
if __name__ == "__main__":
    # 서버 인스턴스 생성 및 실행
    servers = [
        TCPServer(port=8888),  # TCP 서버
        AsyncTCPServer(port=8889),  # 비동기 TCP 서버
        UDPServer(port=9999)  # UDP 서버
    ]
    
    print("네트워크 서버들 시작 중...")
    print("종료하려면 Ctrl+C를 누르세요")
    
    # 각 서버를 별도 스레드에서 실행
    threads = []
    for server in servers:
        thread = threading.Thread(target=server.start if hasattr(server, 'start') else server.run, daemon=True)
        thread.start()
        threads.append(thread)
    
    # 메인 스레드가 종료되지 않도록 대기
    for thread in threads:
        thread.join()
```

## 결론

파이썬 네트워크 프로그래밍의 세 가지 주요 영역을 체계적으로 구현할 때는 다음과 같은 원칙을 고려해야 합니다:

### HTTP 클라이언트 구현 시 고려사항
1. **세션 관리와 연결 풀링**: `requests.Session`을 활용하여 연결을 재사용하고, 적절한 타임아웃과 재시도 전략을 구현하세요.
2. **비동기 처리**: 대량의 HTTP 요청을 처리할 때는 `aiohttp`를 활용한 비동기 방식을 고려하세요.
3. **에러 처리와 복원력**: 네트워크 불안정성을 고려한 재시도 로직과 적절한 예외 처리를 구현하세요.
4. **캐싱 전략**: 자주 요청되는 데이터에 대해서는 적절한 캐싱 메커니즘을 도입하세요.

### TCP 서버 설계 패턴
1. **연결 지향 통신**: TCP는 신뢰성 있는 연결을 보장하므로, 상태를 유지해야 하는 장기 연결에 적합합니다.
2. **동시성 모델 선택**: 
   - 단순한 서버: `threading`을 활용한 멀티스레드 방식
   - 고성능 서버: `asyncio`를 활용한 비동기 방식
   - 대규모 서버: `multiprocessing`을 고려
3. **프로토콜 설계**: 클라이언트-서버 간 통신 프로토콜을 명확히 정의하고, 메시지 경계 처리를 신경쓰세요.
4. **자원 관리**: 연결 누수를 방지하기 위해 적절한 연결 종료와 자원 정리 로직을 구현하세요.

### UDP 서버 구현 전략
1. **비연결형 특성 활용**: 실시간성이 중요하고 작은 패킷을 빠르게 전송해야 할 때 UDP를 선택하세요.
2. **메시지 신뢰성**: UDP는 신뢰성을 보장하지 않으므로, 필요시 애플리케이션 수준에서 확인 응답과 재전송을 구현하세요.
3. **브로드캐스트/멀티캐스트**: 네트워크 내 다수 클라이언트에 동시 전송이 필요할 때 UDP의 브로드캐스트 기능을 활용하세요.
4. **버퍼 관리**: 패킷 손실을 방지하기 위해 적절한 버퍼 크기와 흐름 제어를 구현하세요.

### 공통적인 모범 사례
1. **보안 고려사항**: 모든 네트워크 통신에 대해 입력 검증, 인증, 암호화를 고려하세요.
2. **로깅과 모니터링**: 상세한 로깅과 성능 메트릭 수집을 통해 시스템 상태를 모니터링하세요.
3. **설정화**: 호스트, 포트, 타임아웃 등의 파라미터를 설정 파일이나 환경 변수로 관리하세요.
4. **테스트 전략**: 단위 테스트와 통합 테스트를 통해 네트워크 로직의 신뢰성을 보장하세요.

이러한 원칙들을 준수하면 확장성과 유지보수성이 뛰어난 네트워크 애플리케이션을 구축할 수 있습니다. 각 프로토콜의 특성을 이해하고 요구사항에 맞는 적절한 기술을 선택하는 것이 가장 중요합니다.