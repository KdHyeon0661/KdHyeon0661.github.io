---
layout: post
title: 컴퓨터시스템 - 프로시저 호출 줄이기
date: 2025-08-01 18:20:23 +0900
category: 컴퓨터시스템
---
# 프로시저 호출 줄이기 — 원리·전략·실전 팁(많은 C 예제 포함)

프로시저(함수) 호출은 **성능의 보이지 않는 고비용 구간**이 되곤 합니다. 호출 자체 비용(call/ret, 프로로그/에필로그, 레지스터 저장/복원)뿐 아니라, **인라이닝 불가 → 상수전파·벡터화·루프 변환의 기회 상실** 같은 *간접 비용*도 큽니다. 여기서는 **언제**, **왜**, **어떻게** 호출을 줄이는지 체계적으로 정리하고, C 중심의 코드를 전/후 비교로 보여드립니다.

---

## 1) 함수 호출 비용이 왜 문제인가?

- **직접 비용**
  - `call`/`ret` 분기 + 리턴주소 예측(RAS) 미스 시 페널티
  - 프레임 프로로그/에필로그: 스택 조정, 캘리-세이브 레지스터 저장/복원, 스필/필
  - 간접 호출(함수 포인터/가상 호출)은 분기 예측이 어렵고 I-cache 로컬리티를 해침
  - 동적 링크(PLT/GOT)를 통한 외부 심볼 호출은 추가 간접화로 더 비쌀 수 있음
- **간접 비용**
  - 인라인 불가 → **상수 전파, CSE, 루프 벡터화/언롤링** 주저
  - 호출 경계에서 **별칭/부수효과** 추론이 어렵고 최적화가 보수적으로 변함
  - 작은 루프에서 **분기 예측/명령 캐시**가 호출 오버헤드에 압도됨

> 결론: 특히 **짧고 자주 호출되는 함수가 루프 내부**에 있으면, 호출 제거(혹은 통합)가 큰 이득을 줍니다.

---

## 2) 무엇을 먼저 줄일까? (우선순위 정하기)

1. **핫콜(Hot call)**: 프로파일에서 호출 횟수/누적 시간 상위인 함수
2. **루프 안의 작은 함수**: 한두 연산짜리 도우미들
3. **간접 호출**: 함수 포인터/가상 테이블 기반 호출
4. **DSO 경계 호출**: 공유 라이브러리를 통한 빈번한 호출
5. **시스템 콜/IO 호출**: 배칭(batch)으로 횟수 자체를 줄이기

---

## 3) 핵심 전략 요약

- **인라인(inline/always_inline)**: 호출 제거 + 더 강한 최적화 유도
- **호출 호이스팅(hoist)**: 루프 밖으로 함수 호출을 빼기
- **배칭(batch/fuse)**: 요소별 호출을 묶어 한 번에 처리
- **간접 호출 제거**: 함수 포인터/가상 호출 → 직접 호출/분기 구조로 변환
- **테일 호출/재귀 제거**: tail recursion → 반복문
- **링크·컴파일 최적**: LTO/PGO, 심볼 내재화(static), 인터포지션 비활성화 등
- **API 재설계**: 다건 처리 인터페이스, 불변/순수 함수로 정보 제공
- **측정 기반**: 전/후 `perf`/타이머로 검증 (중앙값, 신뢰구간)

---

## 4) 인라이닝: 가장 강력한 한 방

### 4.1 작은 도우미를 `static inline`로 (헤더 정의)
```c
// before
int clamp(int x, int lo, int hi) { return x < lo ? lo : (x > hi ? hi : x); }

// after: header inlined
static inline int clamp(int x, int lo, int hi) {
    return x < lo ? lo : (x > hi ? hi : x);
}
```
- **장점**: 호출 제거 + 상수전파/분기제거 가능
- **주의**: 너무 큰 함수 인라인 → 코드 팽창(code bloat)로 I-cache 악화

### 4.2 루프 속 인라인 (전/후)
```c
// before
for (int i=0;i<n;i++) sum += f(a[i]);  // f가 아주 작음

// after
static inline int f_inline(int x) { return (x&1)?x+3:x-3; }
for (int i=0;i<n;i++) sum += f_inline(a[i]);
```

### 4.3 컴파일러 도움
- 빌드: `-O3`(기본 인라인 강화), **LTO**(`-flto`)로 TU(translation unit) 넘어 인라인
- 매우 작은 핫함수: `__attribute__((always_inline))` + `static inline` (남용 금지)
- **PGO**(프로파일 기반 최적화)로 *핫콜*만 과감히 인라인

---

## 5) 호출 호이스팅: 루프 밖으로 빼기

반복마다 변하지 않는 호출은 **한 번만** 호출하세요.

```c
// before
for (int i=0;i<n;i++) {
    double s = scale();        // 매번 같음
    out[i] = s * in[i];
}

// after
double s = scale();
for (int i=0;i<n;i++) out[i] = s * in[i];
```

- **전제**: 호출이 *순수(pure)* 혹은 불변 입력만 사용(부수효과 없음)

---

## 6) 배칭(Batching)과 융합(Fusion)

### 6.1 per-element 호출 → 벡터 API
```c
// before
for (int i=0;i<n;i++) y[i] = f(x[i]);

// after: f_many는 내부 루프에서 분기/상수 전파/벡터화 가능
void f_many(float *restrict y, const float *restrict x, int n);
f_many(y, x, n);
```
- 효과: 호출횟수 **n → 1**, 내부에서 **SIMD/타일링** 활용 쉬움

### 6.2 API 합치기 (Fusion)
```c
// before
for (i) a[i]=g1(b[i]);
for (i) c[i]=g2(d[i]);

// after
for (i) { a[i]=g1(b[i]); c[i]=g2(d[i]); } // 메모리 통과 1번 → 호출/메모리 트래픽↓
```

---

## 7) 간접 호출(함수 포인터) 줄이기

### 7.1 루프 밖으로 함수 포인터 고정
```c
// before
for (int i=0;i<n;i++) acc += op[i](a[i]);  // 간접 호출 n번

// after
int (*op0)(int) = op[0];                   // 만약 run-time에 같다면
for (int i=0;i<n;i++) acc += op0(a[i]);
```

### 7.2 전략 패턴을 enum/switch로 치환 (분기 예측이 쉬움)
```c
// before
int (*op)(int) = choose(...);
for (int i=0;i<n;i++) s += op(a[i]);

// after
enum Mode m = choose_mode(...);
for (int i=0;i<n;i++) {
    switch(m) {
    case M_PLUS3: s += a[i] + 3; break;
    case M_TWICE: s += a[i] * 2; break;
    }
}
```
- **장점**: 직접 분기 → 예측 유리, 인라인 가능
- **주의**: 모드가 자주 바뀌면 효과↓, switch 오버헤드 ↑

---

## 8) 재귀 → 반복문 (테일 호출 제거)

### 8.1 테일 재귀
```c
// before
int sum_rec(const int *a, int n, int acc) {
    if (!n) return acc;
    return sum_rec(a+1, n-1, acc + *a);
}

// after
int sum_it(const int *a, int n, int acc) {
    while (n--) acc += *a++;
    return acc;
}
```
- **장점**: 호출 제거 + 프레임 소모/스택오버플로 방지
- 컴파일러가 *tail-call 최적화* 해줄 수도 있으나, 반복문이 더 확실

---

## 9) 라이브러리/링크 단계에서 줄이기

- **LTO**: `-flto`로 TU 간 인라인/정적 분석 확대
- **심볼 내재화**: 외부 노출 필요 없는 함수는 `static`으로 → 인라인 쉬움
- **공유 라이브러리 호출 최소화**: 아주 빈번한 호출은 **정적 링크 or 내부 구현** 고려
- (플랫폼 옵션) **심볼 인터포지션 금지**: 빌드 옵션으로 “외부에서 갈아끼울 수 있다” 가정을 끄면 더 공격적 인라인/최적화 가능(도구체인/플랫폼별 세부 차이 있음)
- (리눅스) **PLT 경유 완화**: 동적호출 간접비용을 줄이는 컴파일/링크 설정이 있음(환경/툴체인 의존—프로젝트 정책과 호환성 체크 필수)

> 빌드 플래그는 툴체인·OS에 따라 다릅니다. 팀 표준과 호환성을 꼭 확인하세요.

---

## 10) 시스템 콜/IO: **횟수를** 줄여라

- 호출 자체가 비쌈: 컨텍스트 스위치, 커널 경로
- **버퍼링/배칭**: `write()` 수천 번 → `writev()`/큰 버퍼 한 번
- **서브시스템 호출 병합**: 타이머/로그/통계 업데이트 묶기

```c
// before: n번 write
for (int i=0;i<n;i++) write(fd, buf[i], len[i]);

// after: writev로 1~몇 번으로
struct iovec v[N]; /* fill v */
writev(fd, v, n);
```

---

## 11) 호출 줄이기가 여는 2차 이득

- 인라인 후 **상수 전파/분기 제거**로 루프가 단순해지고 **자동 벡터화** 성사
- 루프 언롤링/타일링을 컴파일러가 더 과감히 적용
- 레지스터 압박 감소(스필/필 줄어듦) → CPI 개선

---

## 12) 안전 장치: 언제 줄이면 안 되는가?

- **코드 팽창**: 인라인 과다 → I-cache 미스↑, 성능↓ 가능
- **디버그 어려움**: 인라인/매크로 남용 시 추적 곤란
- **ABI 안정성**: 공개 API를 인라인하면 바이너리 호환성 이슈
- **부수효과/스레드 안전성**: 호출 제거로 실행 순서/가시성이 달라지면 버그
- **부동소수점 정확도**: 재배열이 결과 변동을 일으킬 수 있음

---

## 13) 실전 전/후 예제 모음

### 13.1 루프 내 작은 함수 제거 + 분기 제거
```c
// before
static inline int relu(int x){ return x>0?x:0; } // 이미 inline이지만 분기 존재
for (int i=0;i<n;i++) y[i] = relu(x[i]);

// after (branchless)
for (int i=0;i<n;i++) {
    int m = x[i] >> 31;           // 부호비트 확장(0 or -1)
    y[i] = (x[i] + m) ^ m;        // max(x,0) 등가
}
```
> 실제로는 컴파일러가 `cmov`/`max`류로 좋게 바꿔줄 수 있습니다. 항상 **측정**하세요.

### 13.2 배칭으로 호출 제거 + SIMD 여지 만들기
```c
// before
for (int i=0;i<n;i++) y[i] = axpy(a, x[i], y[i]); // y = y + a*x

// after
void axpy_many(float a, const float *restrict x, float *restrict y, int n) {
    for (int i=0;i<n;i++) y[i] += a * x[i];       // 이 루프는 벡터화 쉬움
}
axpy_many(a, x, y, n);
```

### 13.3 함수 포인터 제거
```c
// before
int (*op)(int) = choose_op(mode);
for (int i=0;i<n;i++) s += op(a[i]);

// after
switch (mode) {
  case M1: for (int i=0;i<n;i++) s += a[i]+3; break;
  case M2: for (int i=0;i<n;i++) s += a[i]*2; break;
}
```

### 13.4 반복문으로 재귀 제거
```c
// before
int fact(int n){ return (n<=1)?1:n*fact(n-1); }

// after
int fact_it(int n){
    int r=1; for (int i=2;i<=n;i++) r*=i; return r;
}
```

---

## 14) 컴파일러·빌드 설정 체크리스트

- [ ] `-O3` 또는 프로젝트 권장 최적화 레벨
- [ ] **LTO**: `-flto` (링커도 대응)
- [ ] 아키텍처 최적화: `-march=native`(재현성 vs 성능 트레이드오프 고려)
- [ ] **PGO**: 훈련 실행 → 재빌드 → 핫콜만 인라인 강화
- [ ] 내부 함수는 `static`으로 (외부 노출 금지)
- [ ] 헤더에 `static inline`로 작은 도우미 제공
- [ ] (툴체인별) 동적 인터포지션/PLT 경유를 줄이는 링크 옵션 검토
- [ ] 경고/어트리뷰트: `__attribute__((hot))`, `cold`로 힌트(선택)

---

## 15) 측정·검증(필수)

- **정확성**: 유닛 테스트 + 경계/난 케이스(부동소수점 오차, 오버플로)
- **성능**:
  - 타임: 여러 번 실행 → **중앙값** + 표준편차
  - 하드웨어 카운터: `perf stat -e cycles,instructions,branch-misses,cache-misses ./app`
  - `perf record`/`report`로 **콜그래프**와 핫콜 위치를 확인
- **회귀 방지**: 성능 리그레션 테스트(벤치마크 CI)

```c
// 간단 타이밍 틀
#include <time.h>
double now() { struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
               return t.tv_sec + t.tv_nsec*1e-9; }
```

---

## 16) 요약 (바로 적용 가능한 규칙)

1. **루프 안 작은 함수는 인라인**하고, 필요 시 **배칭**으로 호출 수 자체를 줄여라.  
2. **간접 호출**(함수 포인터)은 **루프 밖으로 고정**하거나 **분기 구조**로 치환하라.  
3. **재귀**는 가능하면 **반복문**으로 전환하라(테일 재귀 특히).  
4. **LTO/PGO**로 **핫콜만 똑똑하게 인라인**하라(코드 팽창 방지).  
5. 호출 제거로 생긴 기회(상수전파·분기제거·벡터화)를 **루프 최적화와 결합**하라.  
6. 항상 **측정으로 검증**하고, 정확성과 유지보수성을 함께 고려하라.
