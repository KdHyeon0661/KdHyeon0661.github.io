---
layout: post
title: 컴퓨터시스템 - 프로시저 호출 줄이기
date: 2025-08-01 18:20:23 +0900
category: 컴퓨터시스템
---
# 프로시저 호출 줄이기

## 0. 읽는 법 & 실험 기본

- **대상**: C(x86-64 System V ABI 기준) — ARM64도 유사한 원리.
- **툴체인**: `gcc/clang`, `objdump`, `perf`, `nm/readelf`, `strace`.
- **컴파일/관찰 플래그**
  - 관찰: `-O0 -g -fno-omit-frame-pointer`
  - 최적화: `-O3 -march=native` (+ LTO/PGO)
  - 인라인 금지/강제: `__attribute__((noinline))`, `__attribute__((always_inline))`
- **측정 습관**: 워밍업 → 여러 회 반복 → **중앙값/신뢰구간** 보고. `perf stat -e cycles,instructions,branch-misses,cache-misses ...`

---

## 1. 함수 호출 비용이 왜 문제인가?

### 1.1 직접 비용(μarch/ABI 관점)
- `call`/`ret`로 **컨트롤 플로우 변경**: Return Address Stack(RAS) 미스 시 페널티.
- **프롤로그/에필로그**: 스택 포인터 조정, 캘리-세이브 레지스터 저장·복원, 스필/필.
- **간접 호출**(함수 포인터/PLT·가상): 분기 표적 예측이 어려워 **mispredict**↑, I-cache 로컬리티↓.
- **DSO(공유 라이브러리) 경유**: PLT/GOT 간접 비용 + 인터포지션 제약.

### 1.2 간접 비용(컴파일러 최적화 관점)
- 호출 경계가 있으면 **상수 전파·CSE·분기 제거·루프 변환/벡터화**가 막힐 수 있다.
- 호출 매개변수/전역/포인터 별칭 정보를 **보수적**으로 가정 → 최적화 축소.
- **짧은 루프**에서 호출 오버헤드가 **루프 본문 비용을 압도**하기도 한다.

### 1.3 간단 모델
반복 내 호출 제거 전후 시간은
$$
T_\text{iter} = T_\text{body} + T_\text{call}
\,,\quad
\text{Speedup} = \frac{T_\text{body}+T_\text{call}}{T_\text{body}} \,.
$$
또는 전체 실행에서 호출이 차지하는 비율 \(p\)와 그 부분의 가속비 \(s\)에 대한 앰달 법칙:
$$
\text{Speedup}_\text{overall}=\frac{1}{(1-p)+p/s}\,.
$$

---

## 2. 무엇부터 줄일까? (우선순위)

1. **핫콜(Hot call)**: 프로파일 상 호출 누적 시간이 큰 함수.
2. **루프 안의 작은 함수**: 산술·단순 분기만 하는 도우미.
3. **간접 호출**: 함수 포인터/가상 테이블 경유.
4. **DSO 경계**: 매우 자주 부르는 외부 심볼(PLT 경유).
5. **시스템 콜/IO**: **배칭/버퍼링**으로 호출 횟수를 줄이기.

---

## 3. 측정 템플릿 — 인라이닝/호출 오버헤드 관찰

```c
// bench_call.c
#include <stdio.h>
#include <time.h>
#include <stdint.h>

static double now_s(void){ struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
  return t.tv_sec + t.tv_nsec*1e-9; }

__attribute__((noinline))
static int tiny_noinline(int x){ return (x & 1)? x+3 : x-3; }

static inline int tiny_inline(int x){ return (x & 1)? x+3 : x-3; }

int main() {
  const int N = 100000000;
  volatile int sink=0; // DCE 방지

  // noinline
  double t0=now_s();
  for(int i=0;i<N;i++) sink += tiny_noinline(i);
  double t1=now_s();
  printf("noinline: %.3f s  sink=%d\n", t1-t0, sink);

  // inline
  sink=0; t0=now_s();
  for(int i=0;i<N;i++) sink += tiny_inline(i);
  t1=now_s();
  printf("inline  : %.3f s  sink=%d\n", t1-t0, sink);
}
```

- `__attribute__((noinline))`로 **진짜 호출** 발생 보장.
- `volatile`로 **죽은 코드 제거** 방지.
- `perf stat`으로 `cycles/instructions/IPC` 비교 → 호출 제거가 **inst 감소·IPC 상승**으로 보일 것.

---

## 4. 핵심 전략 요약표

| 전략 | 요지 | 전제/주의 |
|---|---|---|
| **인라인** | 호출 제거 + 상수전파/분기제거/벡터화 유도 | 코드 팽창 주의, 핫패스 위주 |
| **호출 호이스팅** | 루프 밖으로 빼서 1회 호출 | 순수/불변성 확실해야 |
| **배칭/융합** | per-element 호출 → **배열/블록** 단위 처리 | API 재설계 필요 |
| **간접 호출 제거** | 함수 포인터→스위치/직접 호출 | 모드 변화 적을 때 유리 |
| **재귀 제거** | 테일 재귀→반복문 | 스택/프레임 제거 |
| **링크·컴파일 옵션** | LTO/PGO, 심볼 내재화 | 환경·정책 호환성 확인 |
| **IO 배칭** | write→writev, 버퍼링 | 오류 처리·부분 전송 주의 |

---

## 5. 인라이닝: 가장 강력한 한 방

### 5.1 헤더 도우미를 `static inline`로

```c
// before
int clamp(int x, int lo, int hi){ return x<lo?lo:(x>hi?hi:x); }

// after
static inline int clamp(int x, int lo, int hi){
  return x<lo?lo:(x>hi?hi:x);
}
```

- 호출 제거 + **상수 인자**가 들어오면 분기 자체가 사라질 수 있다.
- 과도한 인라인은 I-cache 압박 → **PGO/LTO로 핫콜만** 노린다.

### 5.2 루프 내 소함수 인라인

```c
// before
int g(int); // 매우 작음
for (int i=0;i<n;i++) sum += g(a[i]);

// after
static inline int g_inline(int x){ return (x&1)?x+3:x-3; }
for (int i=0;i<n;i++) sum += g_inline(a[i]);
```

### 5.3 컴파일러 힌트
- `-O3` 기본 인라인, **LTO(`-flto`)**로 **TU 간** 인라인.
- 정말 작은 핫함수: `__attribute__((always_inline)) static inline` (남용 금지).
- **PGO**와 결합: 프로파일 기반으로 **핫콜만 공격적 인라인**.

---

## 6. 호출 호이스팅(루프 밖으로 빼기)

```c
// before
for (int i=0;i<n;i++){
  double s = scale();           // 매번 같은 값
  out[i] = s * in[i];
}

// after
double s = scale();             // 1회 호출
for (int i=0;i<n;i++) out[i] = s * in[i];
```

- **전제**: `scale()`이 **순수**(부수효과·전역 변경 없음)거나 입력이 루프 동안 **불변**.
- 부동소수점에서 재배열이 **정밀도**를 바꿀 수 있음(규칙/옵션 고려).

---

## 7. 배칭(Batching) & 융합(Fusion)

### 7.1 per-element → 벡터 API

```c
// before
for (int i=0;i<n;i++) y[i] = f(x[i]);

// after: 내부에서 벡터화·타일링·분기 제거 가능
void f_many(float *restrict y, const float *restrict x, int n){
  for (int i=0;i<n;i++) y[i] = (x[i]>0.f)? x[i] : 0.f; // 예: ReLU
}
f_many(y, x, n);
```

- 호출 n회 → 1회. **SIMD/언롤/프리패치** 여지↑.

### 7.2 파이프라인 융합(메모리 통과 횟수↓)

```c
// before
for(i) a[i]=g1(b[i]);
for(i) c[i]=g2(d[i]);

// after
for(i){
  a[i]=g1(b[i]);
  c[i]=g2(d[i]);
}
```

- 캐시/대역 사용 효율↑, 호출/루프 오버헤드↓.

---

## 8. 간접 호출 줄이기(함수 포인터/가상)

### 8.1 루프 밖 고정

```c
// before
for (int i=0;i<n;i++) acc += op[i](a[i]);    // op[i]가 사실상 동일

// after
int (*f)(int) = choose_op(...);              // 루프 전 결정
for (int i=0;i<n;i++) acc += f(a[i]);
```

### 8.2 전략 패턴 → enum/switch

```c
// before
int (*op)(int) = choose(...);
for (int i=0;i<n;i++) s += op(a[i]);

// after
enum Mode { PLUS3, TWICE } m = choose_mode(...);
for (int i=0;i<n;i++){
  switch(m){
    case PLUS3: s += a[i] + 3; break;
    case TWICE: s += a[i] * 2; break;
  }
}
```

- **직접 분기**는 예측이 수월, **인라인** 가능.
- 모드가 빈번히 바뀌면 득이 줄어든다.

---

## 9. 재귀 → 반복(테일 호출 제거)

```c
// before
int sum_rec(const int *a, int n, int acc){
  if(!n) return acc;
  return sum_rec(a+1, n-1, acc + *a);
}

// after
int sum_it(const int *a, int n, int acc){
  while(n--) acc += *a++;
  return acc;
}
```

- 호출/프레임 제거 + **스택 오버플로우** 위험 완화.
- 일부 컴파일러의 **TCO**를 기대하기보다 반복으로 명시가 확실.

---

## 10. IO·시스템 콜: 횟수 자체를 줄이기

### 10.1 write → writev

```c
#include <sys/uio.h>
ssize_t flush_many(int fd, const char** buf, const size_t* len, int n){
  struct iovec v[128]; // 예: 배치 크기 제한
  int k=0; ssize_t tot=0;
  for(int i=0;i<n;){
    k=0;
    while(i<n && k<128){ v[k].iov_base=(void*)buf[i]; v[k].iov_len=len[i]; k++; i++; }
    ssize_t w = writev(fd, v, k);
    if(w<0) return -1; // 오류 처리/부분 전송 재시도 등 필요
    tot += w;
  }
  return tot;
}
```

### 10.2 버퍼링/일괄 처리
- 로그/통계/타이머 업데이트를 **주기적으로 합쳐서** 한 번에 처리.
- 파일 복사: `sendfile`/`splice`(플랫폼별)로 **커널 내 경로** 활용.

---

## 11. 링크·컴파일 단계에서의 호출 줄이기

- **LTO/ThinLTO**: `-flto` (링커 대응 필요) → **TU 간 인라인/탈가상화** 여지↑.
- **PGO**: 실제 워크로드 프로파일로 **핫콜만 인라인**(코드 팽창 억제).
- **심볼 내재화**: 외부 노출 불필요한 함수는 `static`/가시성 축소 → 인터포지션 걱정↓, 인라인↑.
- **섹션 GC/ICF**: `-ffunction-sections -fdata-sections` + 링크 `--gc-sections`로 죽은 도우미 제거.

> 세부 플래그/효과는 툴체인·OS에 따라 다르다. 팀 표준과 배포/ABI 정책을 우선한다.

---

## 12. 호출 줄이기가 여는 2차 최적화

- **상수 전파**: 인라인 후 파생 분기/코드 제거.
- **루프 단순화**: 벡터화/언롤링/소프트웨어 파이프라이닝 성사.
- **레지스터 압박 완화**: 호출 경계 레지스터 저장/복원 감소 → 스필↓, CPI↓.

---

## 13. 안전장치 — 언제 줄이면 안 되는가?

- **코드 팽창**: 인라인 과다로 I-cache/TLB 압박 → 성능 악화 가능.
- **디버깅/유지보수**: 가독성·스택 트레이스 난도 상승.
- **ABI 안정성**: 공개 API를 인라인하면 바이너리 호환성 이슈.
- **부수효과/메모리 모델**: 순서·가시성 바뀌어 버그 가능(특히 멀티스레드).
- **부동소수점**: 재배열이 결과 변동(정확도 정책 고려).

---

## 14. 전/후 예제 모음

### 14.1 루프 내 작은 함수 제거 + 브랜치리스

```c
// before
static inline int relu(int x){ return x>0?x:0; }
for (int i=0;i<n;i++) y[i] = relu(x[i]);

// after (분기 없는 형태; 실제로는 컴파일러가 cmov/max로 바꿔줄 수도 있다)
for (int i=0;i<n;i++){
  int m = x[i] >> 31;      // 0 또는 -1
  y[i] = (x[i] + m) ^ m;   // max(x,0)
}
```

### 14.2 배칭으로 호출 제거 + SIMD 여지

```c
// before
float axpy(float a, float x, float y){ return y + a*x; }
for (int i=0;i<n;i++) y[i] = axpy(a, x[i], y[i]);

// after
void axpy_many(float a, const float* __restrict x, float* __restrict y, int n){
  #pragma omp simd
  for (int i=0;i<n;i++) y[i] += a * x[i];
}
axpy_many(a, x, y, n);
```

### 14.3 함수 포인터 제거

```c
// before
int (*op)(int) = choose_op(mode);
for (int i=0;i<n;i++) sum += op(a[i]);

// after
switch(mode){
  case 0: for(int i=0;i<n;i++) sum += a[i]+3; break;
  case 1: for(int i=0;i<n;i++) sum += a[i]*2; break;
}
```

### 14.4 재귀 제거

```c
// before
int fact(int n){ return (n<=1)?1:n*fact(n-1); }

// after
int fact_it(int n){ int r=1; for(int i=2;i<=n;i++) r*=i; return r; }
```

---

## 15. 어셈으로 보는 호출 오버헤드(개념)

```asm
; caller
call  qword ptr [foo@plt] ; or direct foo
; callee
push  rbp
mov   rbp, rsp
sub   rsp, 32             ; 로컬/정렬
...                       ; 본문
leave                     ; mov rsp,rbp; pop rbp
ret
```

- **프롤로그/에필로그**와 **캘리-세이브** 때문에 본문이 작을수록 호출 비중이 커진다.
- 간접 호출(PLT/함수 포인터)은 **분기 타켓 예측**이 더 어렵다.

---

## 16. 컴파일러/빌드 체크리스트

- [ ] `-O3`(또는 프로젝트 권장 레벨)
- [ ] **LTO/ThinLTO**: `-flto`
- [ ] **PGO**: `-fprofile-generate` → 훈련 → `-fprofile-use`
- [ ] 아키텍처 최적화: `-march=native`(재현성 정책 고려)
- [ ] 내부 도우미는 `static`/헤더 `static inline`
- [ ] (플랫폼별) 인터포지션/PLT 경유 최소화 옵션 검토
- [ ] `-ffunction-sections -fdata-sections` + 링크 `--gc-sections`로 죽은 도우미 제거

---

## 17. 실험 스캐폴딩(콜 수/배칭 효과 비교)

```c
// bench_batch.c
#include <time.h>
#include <stdio.h>
#include <stdlib.h>

static double now(){ struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
  return t.tv_sec + t.tv_nsec*1e-9; }

static inline int f_inline(int x){ return (x&1)?x+3:x-3; }
__attribute__((noinline))
static int f_call(int x){ return (x&1)?x+3:x-3; }

int main(){
  const int n=1<<26;
  int *a=aligned_alloc(64, n*sizeof(int));
  volatile long sink=0;
  for(int i=0;i<n;i++) a[i]=i;

  // per-call
  double t0=now();
  for(int i=0;i<n;i++) sink += f_call(a[i]);
  double t1=now();

  // inline
  double t2=now();
  for(int i=0;i<n;i++) sink += f_inline(a[i]);
  double t3=now();

  printf("per-call: %.3f s  inline: %.3f s  sink=%ld\n", t1-t0, t3-t2, sink);
  return 0;
}
```

- `perf stat`과 함께 실행 → `instructions`, `IPC`, `branch-misses` 비교.
- 실제 효과는 **μarch·캐시·분기 패턴**에 의존 → 항상 **측정**할 것.

---

## 18. 자주 묻는 질문(FAQ)

**Q1. 매크로가 더 빠른가요?**
A. 매크로는 본질적으로 텍스트 치환이므로 **인라인**과 유사하나, **부작용 중복 평가** 위험과 디버깅 난도↑. 가능하면 `static inline` 함수를 권장.

**Q2. `always_inline`를 남발해도 되나요?**
A. 아니오. 코드 팽창으로 I-cache/ITLB 압박이 커져 전체 성능이 떨어질 수 있다. **PGO**로 **핫콜만** 타겟팅한다.

**Q3. 간접 호출을 스위치로 바꾸면 항상 이득?**
A. 모드가 **자주 바뀌지 않을 때** 유리. 모드가 빈번히 바뀌면 분기도 예측이 어렵다. 데이터/워크로드에 따라 다르므로 측정으로 판단.

**Q4. LTO만 켜면 충분?**
A. LTO는 강력하지만 **PGO**와 결합할 때 가장 좋다. 또한 **빌드 시간/메모리** 증가에 주의.

---

## 19. 마무리 요약(실천 규칙)

1. **루프 안 작은 함수는 인라인**하고, 가능하면 **배칭/융합**으로 호출 수를 줄여라.
2. **간접 호출**은 루프 밖으로 고정하거나 **enum/switch**로 치환해 인라인·예측 가능성을 높여라.
3. **재귀는 반복문**으로 바꿔 호출/프레임을 제거하라(특히 테일 재귀).
4. **LTO+PGO**로 **핫콜만 공격적 인라인** — 코드 팽창을 통제하라.
5. **시스템 콜/IO는 배칭**(writev/sendfile/버퍼링)으로 횟수 자체를 줄여라.
6. 호출 제거가 열어 준 **상수 전파·분기 제거·벡터화** 기회를 루프 최적화와 **즉시 결합**하라.
7. 모든 변화는 **테스트 + 계측**으로 검증하고, 유지보수/ABI/디버그 용이성을 함께 고려하라.
