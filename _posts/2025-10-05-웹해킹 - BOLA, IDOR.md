---
layout: post
title: 웹해킹 - BOLA, IDOR
date: 2025-10-05 22:25:23 +0900
category: 웹해킹
---
# 16. BOLA / IDOR (수평·수직 권한)

## 0) 한눈에 보기 (Executive Summary)

- **BOLA/IDOR란?**  
  - **Broken Object Level Authorization** / **Insecure Direct Object Reference**.  
  - 클라이언트가 보낸 **객체 식별자(ID)** 를 서버가 신뢰하고, **리소스 소유/권한**을 **재검증하지 않아서**  
    다른 사용자의 **데이터를 열람/수정/삭제**할 수 있게 되는 취약점.
- **수평 vs 수직 권한**
  - **수평**: 같은 역할(예: 일반 사용자 A→B의 리소스 접근).  
  - **수직**: **역할 상승**(예: 일반 사용자가 관리 기능/타 계정 소유 리소스 접근).
- **핵심 방어**
  1) **리소스 소유자/테넌트 재검증**: **쿼리 단계**에서 `WHERE owner_id = :me AND id = :id`로 **선별**  
  2) **정책 엔진**: RBAC/ABAC로 **action × object**를 중앙에서 판단  
  3) **참조 토큰화**: 외부 노출 ID는 **UUID/ULID(난수)** 또는 **Capability 토큰**. 내부 PK(순번)는 숨김  
  4) **입력 정규화·필드 화이트리스트**: **mass assignment**로 `owner_id`/`role`을 바꾸지 못하게  
  5) **다중 테넌트**: 모든 쿼리에 **tenant_id 스코프** 고정(또는 DB **RLS**)  
  6) **안전한 오류 처리**: 존재/권한 유무를 **균질**하게 응답(404/403 전략)  
  7) **로깅/탐지·테스트 자동화**: ID 열거 패턴, 404→200 전환 감지, 권한 단위 테스트

---

# 1) 전형적 공격 시나리오(개념 → 안전 재현)

## 1.1 REST: 순번 ID 열거
```
GET /api/v1/invoices/123          # 내 것
GET /api/v1/invoices/124          # 남의 것 → 200이면 BOLA
PATCH /api/v1/users/42/role=admin  # 수직 권한 상승(IDOR)
```
- **원인**: 서버가 `id=124`로 **단건 조회 후** “주인 검사”를 **깜빡**하거나, 아예 검사 없음.

**방어 요약**:  
- **조회/수정 쿼리 자체에 소유자/테넌트 조건**을 포함.  
- 외부 노출 ID는 **예측 불가(UUID/ULID)**.  
- 수정 시 **허용 필드 화이트리스트**.

## 1.2 다중 테넌트: 파라미터 바꿔 타사 데이터 접근
```
GET /api/v1/tenants/acme/orders/uuid-v7-...   # 내 테넌트
GET /api/v1/tenants/othercorp/orders/uuid-v7  # 바꿔치기
```
- **원인**: `tenant` 경로 파라미터를 신뢰하고, 서버가 `tenant_id` 재검증 누락.

**방어 요약**:  
- 인증 컨텍스트의 `tenant_id`로 **강제 필터**(`WHERE tenant_id = :ctx.tenant_id`).  
- 경로의 tenant 문자열은 **표시용**일 뿐 **권한 판단에 사용하지 않기**.

## 1.3 파일/다운로드: 직접 객체 참조
```
GET /download?file_id=1001  # 1002로 바꾸면 남의 파일?
```
- **방어**: **capability(사전 서명) URL** 또는 **owner 필터 쿼리**.  
- 사전 서명 토큰에는 **객체/행동/만료/테넌트**가 포함되어야 함.

## 1.4 GraphQL: global ID 열거
```graphql
query { user(id: "42") { email, invoices { id, total } } }
```
- **방어**: 각 리졸버에서 **컨텍스트 사용자로 재검증**,  
  필드/노드 접근은 **권한 가드**를 통과해야 반환.

---

# 2) 설계 안티패턴(피해야 할 것)

- **사후 검사(Post-check)**:  
  1) `record = findById(id)` → 2) `if (record.ownerId !== me) 403`  
  → **경쟁 상태/캐시/오류 경로**로 누락될 수 있음. **사전 필터**로 바꾸기.
- **내부 PK 노출**: 오토 인크리먼트 숫자를 URL에 그대로 노출 → **예측/열거 용이**.
- **Mass Assignment**: PATCH body에 `ownerId`, `role` 같은 민감 필드를 서버가 그대로 반영.
- **권한을 클라이언트가 주장**: `X-User-Id` 같은 헤더를 그대로 신뢰.
- **테넌트/소유자 필터 누락**: 조인·통계·검색 엔드포인트에서 빠지기 쉬움.
- **모놀리식 “isAdmin” 플래그 남용**: 세분 권한 없이 거친 분기 → 수직 권한 취약.

---

# 3) 방어 아키텍처(전체 그림)

1) **인증(WHO)**: `sub`, `tenant`, `roles`, `scopes`를 담은 토큰(JWT 등).  
2) **정책(WHAT on WHICH)**: `can(subject, action, object)` 중앙 판정(RBAC/ABAC).  
3) **데이터 접근(WHERE)**: **쿼리 단계에서 스코프 필터**(owner/tenant).  
4) **식별자(REFERENCE)**: 외부는 **난수형 ID(ULID/UUIDv7)** 또는 **Capability 토큰**.  
5) **입력/출력(EDGE)**: 필드 화이트리스트, 표준 오류, 캐시 금지.  
6) **관측/검증(OBSERVE)**: 로깅, ID 열거 탐지, 테스트/CI.

---

# 4) 코드 템플릿 (언어별)

## 4.1 Node.js (Express + Prisma)

### 4.1.1 타입/스코프 안전 조회 (사전 필터)
```ts
// auth.ts — 컨텍스트 주입
export type AuthCtx = { userId: string; tenantId: string; roles: string[] };

declare global { namespace Express { interface Request { auth?: AuthCtx } }}

// invoices.ts — BOLA 방지
router.get('/invoices/:id', async (req, res) => {
  const { userId, tenantId } = req.auth!;
  const id = String(req.params.id);                 // UUID/ULID 외부 ID
  const inv = await prisma.invoice.findFirst({
    where: { id, tenantId, ownerId: userId }        // 🔴 쿼리 단계에서 소유자/테넌트 필터
  });
  if (!inv) return res.sendStatus(404);             // 존재/권한 불문 동일 응답 전략
  res.json(inv);
});
```

### 4.1.2 수정(허용 필드 화이트리스트)
```ts
router.patch('/invoices/:id', async (req, res) => {
  const { userId, tenantId } = req.auth!;
  const id = String(req.params.id);
  const { status, memo } = pick(req.body, ['status','memo']); // ✅ 화이트리스트

  const inv = await prisma.invoice.updateMany({
    where: { id, tenantId, ownerId: userId },      // 🔴 사전 필터
    data: { status, memo }
  });
  if (inv.count === 0) return res.sendStatus(404);
  res.sendStatus(204);
});
```

### 4.1.3 수직 권한 예(RBAC + ABAC 혼합)
```ts
function can(ctx: AuthCtx, action: 'user.promote'|'invoice.refund', obj?: any) {
  if (action === 'user.promote') return ctx.roles.includes('admin');               // RBAC
  if (action === 'invoice.refund') return obj?.ownerId === ctx.userId || ctx.roles.includes('agent');
  return false;
}

router.post('/users/:id/promote', async (req,res)=>{
  if (!can(req.auth!, 'user.promote')) return res.sendStatus(403);
  // …
  res.sendStatus(204);
});
```

---

## 4.2 Spring Boot (Java) — Service + Method Security

### 4.2.1 엔티티/리포지토리
```java
@Entity class Invoice {
  @Id UUID id;
  UUID tenantId;
  UUID ownerId;
  BigDecimal total;
  String status;
}

public interface InvoiceRepo extends JpaRepository<Invoice, UUID> {
  Optional<Invoice> findByIdAndTenantIdAndOwnerId(UUID id, UUID tenantId, UUID ownerId);
  int updateStatusByIdAndTenantIdAndOwnerId(UUID id, UUID tenant, UUID owner, String status);
}
```

### 4.2.2 서비스/컨트롤러 (사전 필터 + @PreAuthorize)
```java
@Service
public class InvoiceSvc {
  @Autowired InvoiceRepo repo;

  public Invoice getForUser(UUID id, UUID tenant, UUID user) {
    return repo.findByIdAndTenantIdAndOwnerId(id, tenant, user)
               .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));
  }

  public void updateForUser(UUID id, UUID tenant, UUID user, String status) {
    int n = repo.updateStatusByIdAndTenantIdAndOwnerId(id, tenant, user, status);
    if (n == 0) throw new ResponseStatusException(HttpStatus.NOT_FOUND);
  }
}

@RestController @RequestMapping("/api/invoices")
public class InvoiceCtrl {
  @Autowired InvoiceSvc svc;

  @GetMapping("/{id}")
  public Invoice get(@PathVariable UUID id, @AuthenticationPrincipal MyUser u) {
    return svc.getForUser(id, u.getTenantId(), u.getUserId());
  }

  @PatchMapping("/{id}")
  @PreAuthorize("hasAnyRole('USER','AGENT')") // 수직 권한 필터
  public void patch(@PathVariable UUID id, @RequestBody PatchDto dto,
                    @AuthenticationPrincipal MyUser u) {
    svc.updateForUser(id, u.getTenantId(), u.getUserId(), dto.status());
  }
}
```

---

## 4.3 Django (Python) — ORM 필터 + Serializer 화이트리스트

```python
# models.py
class Invoice(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    tenant = models.ForeignKey('Tenant', on_delete=models.CASCADE)
    owner  = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    total  = models.DecimalField(max_digits=12, decimal_places=2)
    status = models.CharField(max_length=20)

# views.py (DRF)
class InvoiceView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, id):
        inv = get_object_or_404(Invoice, id=id, tenant=request.user.tenant, owner=request.user)
        return Response(InvoiceSerializer(inv).data)

    def patch(self, request, id):
        inv = get_object_or_404(Invoice, id=id, tenant=request.user.tenant, owner=request.user)
        ser = InvoicePatchSerializer(inv, data=request.data, partial=True)
        ser.is_valid(raise_exception=True)
        ser.save()  # Serializer의 fields가 화이트리스트 역할
        return Response(status=204)

# serializers.py
class InvoicePatchSerializer(serializers.ModelSerializer):
    class Meta:
        model = Invoice
        fields = ['status', 'memo']     # ✅ 허용 필드만
```

---

## 4.4 SQL 직접 사용 — “사전 필터” 원칙

```sql
-- ❌ 나쁜 예
SELECT * FROM invoices WHERE id = $1;             -- 가져온 뒤 owner 비교 (사후 검사)

-- ✅ 좋은 예 (수평 + 테넌트)
SELECT * FROM invoices
WHERE id = $1 AND tenant_id = $2 AND owner_id = $3;

-- ✅ 수정/삭제도 동일
UPDATE invoices SET status = $4
WHERE id = $1 AND tenant_id = $2 AND owner_id = $3;
```

---

## 4.5 Postgres **Row-Level Security (RLS)**

```sql
ALTER TABLE invoices ENABLE ROW LEVEL SECURITY;

-- 현재 세션에 컨텍스트 주입(미들웨어에서)
-- SELECT set_config('app.user_id',  '<uuid>', true);
-- SELECT set_config('app.tenant_id','<uuid>', true);

CREATE POLICY p_invoice_owner ON invoices
USING ( tenant_id::text = current_setting('app.tenant_id', true)
    AND owner_id::text  = current_setting('app.user_id', true) );

-- 이제 단순 쿼리도 자동으로 스코프됨
SELECT * FROM invoices WHERE id = $1;                   -- RLS가 필터링
```
> RLS는 강력하지만, **세션 컨텍스트 주입**이 확실해야 합니다. (커넥션 풀/트랜잭션 경계 주의)

---

## 4.6 GraphQL — 리졸버 권한 가드

```ts
// resolver.ts
const resolvers = {
  Query: {
    invoice: async (_: any, { id }: {id: string}, ctx: Ctx) => {
      const inv = await db.invoice.findFirst({ where: { id, ownerId: ctx.user.id, tenantId: ctx.tenant.id }});
      if (!inv) throw new NotFoundError();
      return inv;
    },
  },
  Mutation: {
    updateInvoice: async (_: any, { id, input }, ctx) => {
      if (!ctx.can('invoice.update')) throw new ForbiddenError();
      const updated = await db.invoice.updateMany({ where: { id, ownerId: ctx.user.id, tenantId: ctx.tenant.id }, data: pick(input, ['status','memo']) });
      if (updated.count === 0) throw new NotFoundError();
      return true;
    }
  }
};
```

---

# 5) **참조 토큰화**(외부 ID 설계)

## 5.1 난수형 외부 ID (UUID/ULID/UUIDv7)
- **예측 불가** + **타임 정렬(ULID/UUIDv7)** → UX/인덱스 유리.  
- 내부 PK(순번)는 **절대 외부 노출 금지**.

```ts
// Prisma 예
model Invoice {
  id        String   @id @default(uuid()) // 외부에 그대로 쓰는 난수 ID
  internal  Int      @default(autoincrement()) @unique
  tenantId  String
  ownerId   String
}
```

## 5.2 Capability / 사전 서명 토큰(다운로드·공유)
- **토큰 = 객체 + 권한 + 만료 + 서명** (예: HMAC/JWT).  
- 요청 시 토큰을 검증하고 **권한 범위**와 **만료**를 확인.

```ts
// 토큰 생성(서버)
function signDownload(objectId: string, sub: string, scope='download', ttl=600_000) {
  const payload = { obj: objectId, sub, scope, exp: Date.now()+ttl };
  const sig = hmacSHA256(JSON.stringify(payload), SECRET);
  return base64url(`${JSON.stringify(payload)}.${sig}`);
}

// 검증
function verify(token: string, requester: string) {
  const [p64, sig] = token.split('.');
  const payload = JSON.parse(base64urlDecode(p64));
  const ok = hmacSHA256(p64, SECRET) === sig && payload.exp > Date.now() && payload.sub === requester;
  return ok ? payload : null;
}
```

> **주의**: “사전서명 URL”은 **공유 범위**가 설계 그 자체입니다. **짧은 만료**와 **스코프 제한**, 필요 시 **1회성**.

---

# 6) **RBAC/ABAC** 정책

## 6.1 RBAC (역할 기반)
- 단순/명확. 엔드포인트/오퍼레이션 단위로 `role ∋ permission` 확인.

```ts
const PERMS: Record<string, string[]> = {
  admin: ['user.promote','invoice.read','invoice.update','invoice.refund'],
  user:  ['invoice.read','invoice.update:self'],
};
```

## 6.2 ABAC (속성 기반)
- **subject, object, action, context** 속성으로 세밀하게.

```ts
type Subject = { id: string, tenant: string, roles: string[] };
type Invoice = { id: string, tenantId: string, ownerId: string, status: string };

function canReadInvoice(s: Subject, inv: Invoice) {
  return s.tenant === inv.tenantId && (s.roles.includes('admin') || inv.ownerId === s.id);
}
```

## 6.3 OPA/Rego 스타일 예(개념)
```rego
package auth

default allow = false

allow {
  input.action == "invoice.read"
  input.subject.tenant == input.object.tenantId
  input.subject.id == input.object.ownerId
}

allow {
  input.action == "invoice.read"
  input.subject.roles[_] == "admin"
  input.subject.tenant == input.object.tenantId
}
```

---

# 7) **Mass Assignment** 차단

- 업데이트 입력은 **허용 필드만** 적용. `ownerId`, `role`, `tenantId`, `price` 등 민감 필드는 별도 엔드포인트/워크플로로.

```ts
function pick<T extends object>(obj: T, keys: (keyof T)[]) {
  return Object.fromEntries(Object.entries(obj).filter(([k]) => (keys as string[]).includes(k)));
}
```

---

# 8) 오류 처리 & 캐시

- **404 vs 403**:  
  - 열거 방지를 위해 **404로 통일**(존재·권한 불문) 전략이 흔함.  
  - 단, **자기 리소스**에는 403을 주는 방침도 가능(정책 일관성 필요).
- **캐시**: ID 기반 민감 엔드포인트는 `Cache-Control: no-store`.  
  **프록시 캐시**가 섞이면 권한 캐싱 사고 발생.

```nginx
add_header Cache-Control "no-store" always;
```

---

# 9) 로깅/탐지(실무)

- **필드**: `ts`, `uid`, `tenant`, `ip`, `route`, `target_id`, `result(200/404/403)`.  
- **탐지 규칙**:
  - 동일 IP/사용자가 **짧은 시간에 ID를 연속 시도**(패턴: +1, 랜덤 열거)  
  - **404 비율 급증**(특히 object 라우트)  
  - **다른 테넌트 ID 요청**  
  - 404→200로 **전환**한 ID의 비정상 속도

---

# 10) 테스트(단위/E2E/CI)

## 10.1 Node + supertest
```ts
it('다른 사용자의 청구서 접근은 404', async () => {
  const me = await loginAs('u1');    // 토큰에 userId=u1
  const other = await createInvoice({ ownerId: 'u2' });
  await request(app).get(`/api/invoices/${other.id}`).set('Authorization', me).expect(404);
});

it('PATCH 허용 필드만 반영', async () => {
  const me = await loginAs('u1');
  const inv = await createInvoice({ ownerId: 'u1' });
  await request(app).patch(`/api/invoices/${inv.id}`)
    .set('Authorization', me)
    .send({ status:'paid', ownerId:'u2' })           // ownerId 무시되어야
    .expect(204);
  const after = await getInvoice(inv.id);
  expect(after.ownerId).toBe('u1');
});
```

## 10.2 Django pytest
```python
def test_idor(client, user_a, user_b, invoice_b):
    client.force_login(user_a)
    r = client.get(f"/api/invoices/{invoice_b.id}")
    assert r.status_code == 404
```

## 10.3 스캐너/프로퍼티 테스트 아이디어
- 시드 ID에서 ±N 범위 자동 요청 → 2xx 응답 발생 시 경보.  
- GraphQL: `id` 사전·난수로 `node(id: …)` 탐색 → 권한 실패율 확인.

---

# 11) 마이그레이션 가이드(순번 ID → 난수 ID)

1) 스키마에 `public_id UUID/ULID` 추가(+ UNIQUE).  
2) 데이터 백필: `UPDATE t SET public_id = gen_random_uuid();`  
3) 엔드포인트를 `/:public_id`로 전환, 클라이언트 릴리즈.  
4) 일정 기간 리다이렉트/호환(내부 ID → public_id 매핑).  
5) 내부 ID 노출 제거.

---

# 12) 체크리스트 (현장용)

- [ ] **쿼리 단계**에서 `WHERE tenant_id = :me.tenant AND owner_id = :me.id`  
- [ ] **외부 ID는 난수(UUID/ULID/UUIDv7)**, 내부 PK 노출 금지  
- [ ] **RBAC/ABAC** 중앙 판정(`can(subject, action, object)`)  
- [ ] **허용 필드 화이트리스트**(mass assignment 차단)  
- [ ] **다중 테넌트 스코프 강제**(모든 쿼리/검색/통계)  
- [ ] **파일/다운로드는 Capability 토큰**(객체·동작·만료·서명)  
- [ ] **404/403 전략 일관** + **Cache-Control: no-store**  
- [ ] **로그/탐지**: ID 열거·404 급증·테넌트 불일치  
- [ ] **테스트/CI**: 수평/수직 권한 케이스, ID 열거 자동화  
- [ ] **문서화**: ID 규약, 정책 엔진 규칙, 에러/로그 기준

---

## 맺음말

BOLA/IDOR는 “**클라이언트가 준 ID를 믿은 대가**”입니다.  
**사전 필터(소유자·테넌트)**, **중앙 정책(RBAC/ABAC)**, **난수형 식별자·Capability 토큰**, **허용 필드 업데이트**를 기본기로 삼으면  
수평/수직 권한 취약을 **구조적으로** 줄일 수 있습니다.