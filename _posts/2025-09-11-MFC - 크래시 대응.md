---
layout: post
title: MFC - 크래시 대응
date: 2025-09-11 15:25:23 +0900
category: MFC
---
# 크래시 대응 : 미니덤프(MiniDump), 예외 필터(세 가지 계층), 재시작 매니저(ARR & RM) 완전 가이드
(Win32/MFC/ATL 기준 · x64/Win10/11 · 실전 스캐폴딩/레지스트리/배포/보안 체크리스트 포함)

이 글은 **앱이 죽을 때**(Access Violation, Stack Overflow, Divide by zero, Purecall, OOM…)  
**무엇을, 어디서, 어떻게** 남기고(덤프/로그), **어떻게 복구/재시작**할지에 대한 **엔드-투-엔드 레시피**입니다.

---

## 0) 한눈에 보기(설계 원칙)

1) **세 겹 방어**  
- (A) **VEH/Vectored Handler**: *가장 먼저* 잡아 구조화(로깅/Fail-Fast)  
- (B) **SEH/Unhandled Filter**: `__try/__except` & `SetUnhandledExceptionFilter`로 **미니덤프**  
- (C) **C/C++ 런타임 핸들러**: `_set_invalid_parameter_handler`, `_set_purecall_handler`, `new_handler` 등

2) **덤프 전략**  
- 기본은 **MiniDumpWithHandleData | WithThreadInfo | WithDataSegs**  
- 민감 데이터/대용량일 땐 **UserStream+Callback**로 **필터링/샘플링**

3) **복구 전략**  
- **Application Restart & Recovery(ARR)**: `RegisterApplicationRestart`, `RegisterApplicationRecoveryCallback`  
- (설치/업데이트/파일 잠금 해제) **Restart Manager(RM)**: `RmStartSession` 계열로 **정상 종료 후 재시작**

4) **실전 원칙**  
- **크래시 시점엔 안전하지 않은 API**를 피하고, 덤프는 **별도 프로세스**(미니덤프 헬퍼)로 만들면 더 안전  
- 덤프/로그는 **개인정보·보안** 고려(경로/암호화/보관정책)  
- 배포 전 **WER(Windows Error Reporting)** 기본 동작/로컬 덤프 정책과 **충돌하지 않게** 설계

---

## 1) 덤프란? (MiniDumpWriteDump 한 장 요약)

- **미니덤프**: 프로세스의 **메모리·스레드·레지스터·모듈 정보**를 압축 저장한 파일(`.dmp`)  
- 분석 도구: **WinDbg / Visual Studio** (PDB 심볼 필수)  
- API: `MiniDumpWriteDump(process, pid, file, MINIDUMP_TYPE, …)` (dbghelp.lib)

### 1-1. 덤프 등급(권장 조합)
- 빠르고 가볍게: `MiniDumpWithThreadInfo | MiniDumpWithHandleData`  
- 힙/전역 데이터 포함: `+ MiniDumpWithDataSegs`  
- 충돌 지점 주변 메모리: `+ MiniDumpWithIndirectlyReferencedMemory`  
- **주의**: `WithFullMemory`는 수백 MB~수 GB 가능(운영 정책 필요)

```cpp
static MINIDUMP_TYPE kDumpFlavor =
    (MINIDUMP_TYPE)(MiniDumpWithThreadInfo |
                    MiniDumpWithHandleData |
                    MiniDumpWithDataSegs |
                    MiniDumpWithIndirectlyReferencedMemory);
```

---

## 2) 예외 처리 계층: VEH → Unhandled Filter → C/C++ 런타임

### 2-1. Vectored Exception Handler(가장 먼저)
- 장점: **모든 스레드의 예외를 가장 먼저 관찰**, 로깅/Fail-Fast 전처리 가능
- `AddVectoredExceptionHandler(1, Handler);`

```cpp
LONG CALLBACK VectoredHandler(PEXCEPTION_POINTERS ep) {
    // 가벼운 로깅만(파일 I/O 금지 권장). 필수면 async-safe 버퍼링.
    OutputDebugStringW(L"[VEH] exception observed\n");
    return EXCEPTION_CONTINUE_SEARCH; // 다른 핸들러로 흘려보냄
}
```

### 2-2. Unhandled Exception Filter(프로세스-레벨 마지막 방어)
- `SetUnhandledExceptionFilter(FilterProc);`  
- OS/서드파티가 바꿀 수 있으므로 **VEH와 병행** 추천

```cpp
LONG WINAPI UnhandledFilter(EXCEPTION_POINTERS* ep) {
    // 1) 가능한 한 안전하게: 별도 헬퍼 프로세스에 덤프 위임 권장
    WriteMiniDumpSync(GetCurrentProcess(), GetCurrentProcessId(), ep);
    // 2) ARR 복구 시나리오가 있으면 ReportFault 대신 RtlRaiseException 없이 종료로
    return EXCEPTION_EXECUTE_HANDLER; // 프로세스 종료
}
```

### 2-3. C/C++ 런타임 특수 핸들러
```cpp
void MyPurecall() { OutputDebugStringW(L"[CRT] purecall\n"); }
void MyInvalidParameter(const wchar_t*, const wchar_t*, const wchar_t*, unsigned, uintptr_t) {
    OutputDebugStringW(L"[CRT] invalid parameter\n");
}
int MyNewHandler(size_t) { /* 로깅 */ return 0; } // 0=std::bad_alloc 던짐

void InstallCrtHandlers() {
    _set_purecall_handler(MyPurecall);
    _set_invalid_parameter_handler(MyInvalidParameter);
    _set_new_handler(MyNewHandler);
    _set_abort_behavior(0, _CALL_REPORTFAULT); // WER 팝업 억제
}
```

### 2-4. SEH→C++ 예외 변환(선택)
```cpp
#include <eh.h>
void SehToCpp(unsigned code, _EXCEPTION_POINTERS* ep) {
    throw code; // 혹은 custom exception
}
_set_se_translator(SehToCpp);
```

---

## 3) 미니덤프 생성 스캐폴딩(동기/헬퍼 분리)

### 3-1. 동기(dbghelp 직통) 버전 — 간단/빠름
```cpp
#include <DbgHelp.h>
#pragma comment(lib, "Dbghelp.lib")

bool WriteMiniDumpSync(HANDLE hProc, DWORD pid, EXCEPTION_POINTERS* ep) {
    SYSTEMTIME st; GetLocalTime(&st);
    wchar_t path[MAX_PATH];
    swprintf_s(path, L"%s\\MyApp_%04d%02d%02d_%02d%02d%02d.dmp",
        L"C:\\CrashDumps", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);

    HANDLE hFile = CreateFileW(path, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (hFile == INVALID_HANDLE_VALUE) return false;

    MINIDUMP_EXCEPTION_INFORMATION mei{ GetCurrentThreadId(), ep, FALSE };
    MINIDUMP_CALLBACK_INFORMATION mci{};
    // 필터링 콜백(민감 메모리 제거)을 넣으려면 mci.CallbackRoutine 설정

    BOOL ok = MiniDumpWriteDump(hProc, pid, hFile, kDumpFlavor, ep? &mei: nullptr, nullptr, &mci);
    CloseHandle(hFile);
    return !!ok;
}
```

### 3-2. 크래시-세이프(권장) — **헬퍼 프로세스 호출**
크래시 컨텍스트에서 파일/심볼 로딩/락 등은 위험합니다.  
**프로세스 A(크래시)** → **프로세스 B(헬퍼)** 로 **PID/스레드/예외 정보**를 넘겨 *B가* `MiniDumpWriteDump` 호출.

- A: `CreateProcess("Dumper.exe", L"--pid 1234 --tid 567 --ep 0x...")`  
- B: `OpenProcess(PROCESS_ALL_ACCESS, …, pid)` + `MiniDumpWriteDump`

> 예외 포인터를 핸들 간에 직접 넘길 수 없습니다. B는 `MiniDumpWriteDump`의 **`EXCEPTION_INFO` 대신 *Callback*로 스레드 컨텍스트**를 조회하거나, **WER LocalDumps** 정책을 쓰는 방안도 고려.

### 3-3. 콜백으로 민감 메모리 제거/샘플링
```cpp
BOOL CALLBACK DumpCallback(PVOID, const PMINIDUMP_CALLBACK_INPUT in, PMINIDUMP_CALLBACK_OUTPUT out) {
    if (in->CallbackType == IncludeModuleCallback) return TRUE;
    if (in->CallbackType == IncludeThreadCallback) return TRUE;
    if (in->CallbackType == MemoryCallback) {
        // 특정 모듈/주소 범위 제외 가능
        out->MemoryBase = 0; out->MemorySize = 0;
        return FALSE;
    }
    if (in->CallbackType == IsProcessSnapshotCallback) out->Status = S_FALSE;
    return TRUE;
}
```

---

## 4) WER(Windows Error Reporting) & 로컬 덤프 정책

### 4-1. WER가 기본으로 하는 일
- 크래시시 **WerFault.exe**가 개입 → 사용자에게 보고 UI, 또는 **자동 수집/서버 전송**  
- 기업 환경/개발 환경에선 **로컬 덤프**를 남기게 설정 가능

### 4-2. 로컬 덤프 레지스트리(관리자 권장; MSI에서 설정)
```reg
Windows Registry Editor Version 5.00

; 프로세스별
[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\Windows Error Reporting\LocalDumps\MyApp.exe]
"DumpType"=dword:00000002          ; 1=Mini, 2=Full
"DumpFolder"="C:\\CrashDumps"      ; 없으면 %LOCALAPPDATA%\CrashDumps
"DumpCount"=dword:00000010         ; 보관 개수
```
> **동시 사용 주의**: 우리가 별도 덤프를 쓰더라도, WER 로컬 덤프를 **백업**으로 켜두면 현장 수집의 안정성이 올라갑니다.

---

## 5) 재시작 매니저 (두 가지 의미를 모두 다룹니다)

### 5-1. ARR: **Application Restart & Recovery** (사용자 앱 **자동 재시작/복구 콜백**)
- `RegisterApplicationRestart(L"--recover", flags)`  
- `RegisterApplicationRecoveryCallback(AppRecover, ctx, pingSec, flags)`  
- 크래시/응답없음 시 OS가 **복구 콜백**을 호출(별 스레드) → 상태 저장 후 **앱 재시작**

```cpp
#include <RestartManager.h> // 실제로는 WinBase.h 포함. (ARR는 Kernel32)
typedef DWORD (WINAPI *PFNRECOVERY)(PVOID);

DWORD WINAPI AppRecoveryProc(PVOID) {
    // 60초 내(기한 내) 주기적으로 진행 보고
    for (int i=0;i<6;i++) {
        ApplicationRecoveryInProgress(nullptr); // 취소/타임아웃 감지
        // 임시 작업: 열려있는 문서 목록/작업 상태 JSON으로 쓰기
        Sleep(10*1000);
    }
    ApplicationRecoveryFinished(TRUE); // 복구 성공
    return 0;
}

void EnableARR() {
    RegisterApplicationRestart(L"--recover", RESTART_NO_CRASH | RESTART_NO_HANG); // 필요 플래그 선택
    RegisterApplicationRecoveryCallback((PFNRECOVERY)AppRecoveryProc, nullptr, 60, 0);
}
```

프로세스 시작 시 **복구 인자 처리**:
```cpp
int APIENTRY wWinMain(...) {
    // "--recover" 있으면 이전 세션 임시 저장소에서 상태 로드
    // …
}
```

> **포인트**  
> - *복구 콜백 스레드*에선 **UI 금지**(디스크 쓰기·간단한 IPC 정도만).  
> - **ApplicationRecoveryInProgress** 로 취소/타임아웃을 **반드시 확인**.

### 5-2. RM: **Restart Manager** (설치/업데이트 시 **파일 잠금 프로세스 파악·순차 종료·재시작**)
- 인스톨러/업데이터에서 주로 사용. 파일/레지/서비스를 점유 중인 프로세스를 **찾아 정상 종료/재시작**.

```cpp
#include <RestartManager.h>
#pragma comment(lib, "Rstrtmgr.lib")

void CloseLockersAndRestart(const std::vector<std::wstring>& files) {
    DWORD sess = 0; WCHAR key[CCH_RM_SESSION_KEY+1];
    RmStartSession(&sess, 0, key);

    std::vector<LPCWSTR> arr; for (auto& f:files) arr.push_back(f.c_str());
    RmRegisterResources(sess, (UINT)arr.size(), arr.data(), 0, nullptr, 0, nullptr);

    DWORD needed=0, procCount=0;
    RmGetList(sess, &needed, &procCount, nullptr, nullptr); // needed 얻기
    std::vector<RM_PROCESS_INFO> infos(needed);
    RmGetList(sess, &needed, &procCount, infos.data(), nullptr);

    // 사용자에게 저장/종료 요청 → …
    RmShutdown(sess, RmForceShutdown, nullptr); // 가능하면 RmShutdownOnlyRegistered로 부드럽게
    // 작업 후
    RmRestart(sess, 0, nullptr);
    RmEndSession(sess);
}
```

---

## 6) 특수 크래시들 & 각론

### 6-1. Stack Overflow
- `__try/__except(EXCEPTION_STACK_OVERFLOW)`로 **최소한의 처리** 후 **Fail-Fast**  
- 덤프 생성도 위험할 수 있음 → **헬퍼 프로세스** 호출만 시도

```cpp
__try {
    // 위험 함수
} __except (GetExceptionCode()==EXCEPTION_STACK_OVERFLOW ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
    // 스택 매우 얕음 → 아무것도 하지 말고 빠르게 종료 or 헬퍼 호출만
}
```

### 6-2. Deadlock/Hang(응답없음)
- ARR의 **NO_HANG** 플래그/`WER`의 **Hang 보고** 사용  
- UI 쓰레드 **Watchdog**(메시지 펌프 시간 초과 시 스택 덤프)  
  - 스택 덤프는 **DbgHelp StackWalk64** 또는 **WER의 hang dump** 활용

### 6-3. Fast Fail
- CVE 회피·보안 사고 시 `RaiseFailFastException(nullptr, nullptr, 0);`로 즉시 프로세스 종료 + WER 등록

---

## 7) 심볼 & 분석 파이프라인(WinDbg/VS)

### 7-1. 심볼 서버 설정(WinDbg)
```
.symfix
.reload
```
또는 환경변수:
```
_NT_SYMBOL_PATH=srv*C:\Symbols*https://msdl.microsoft.com/download/symbols
```

### 7-2. 덤프 열기
- WinDbg: `File → Open Crash Dump` → `!analyze -v`  
- Visual Studio: **더블 클릭 .dmp** → Call Stack/Modules/PDB 매칭

> **빌드 정책**  
> - 릴리즈 빌드도 **PDB 보관**(서버에 암호화/접근 제어).  
> - 덤프 파일은 **고객 정보**가 포함될 수 있음을 명시하고 **수집 동의/암호화 전송**.

---

## 8) MFC/애플리케이션 수준 스캐폴딩(즉시 붙여쓰는 골격)

```cpp
// CrashBootstrap.h
#pragma once
#include <DbgHelp.h>
#pragma comment(lib,"Dbghelp.lib")

extern LONG WINAPI UnhandledFilter(EXCEPTION_POINTERS* ep);
extern LONG CALLBACK VectoredHandler(PEXCEPTION_POINTERS ep);
extern void  InstallCrashHandlers();
extern void  EnableARR();

inline bool EnsureDumpDir() {
    CreateDirectoryW(L"C:\\CrashDumps", nullptr);
    return true;
}

// CrashBootstrap.cpp
#include "CrashBootstrap.h"
static MINIDUMP_TYPE S_FLAVOR = (MINIDUMP_TYPE)(MiniDumpWithThreadInfo | MiniDumpWithHandleData | MiniDumpWithDataSegs);

bool WriteMiniDumpSync(HANDLE p, DWORD pid, EXCEPTION_POINTERS* ep) {
    if (!EnsureDumpDir()) return false;
    SYSTEMTIME st; GetLocalTime(&st);
    wchar_t fn[260];
    swprintf_s(fn, L"C:\\CrashDumps\\App_%04d%02d%02d_%02d%02d%02d.dmp",
        st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
    HANDLE f = CreateFileW(fn, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (f==INVALID_HANDLE_VALUE) return false;
    MINIDUMP_EXCEPTION_INFORMATION mei{ GetCurrentThreadId(), ep, FALSE };
    BOOL ok = MiniDumpWriteDump(p, pid, f, S_FLAVOR, ep? &mei: nullptr, nullptr, nullptr);
    CloseHandle(f);
    return !!ok;
}

LONG WINAPI UnhandledFilter(EXCEPTION_POINTERS* ep) {
    WriteMiniDumpSync(GetCurrentProcess(), GetCurrentProcessId(), ep);
    return EXCEPTION_EXECUTE_HANDLER;
}

LONG CALLBACK VectoredHandler(PEXCEPTION_POINTERS ep) {
    OutputDebugStringW(L"[VEH] hit\n");
    return EXCEPTION_CONTINUE_SEARCH;
}

void InstallCrashHandlers() {
    AddVectoredExceptionHandler(1, VectoredHandler);
    SetUnhandledExceptionFilter(UnhandledFilter);
    // CRT/Lang handlers
    // _set_purecall_handler(...); _set_invalid_parameter_handler(...); etc.
    EnableARR();
}

// App.cpp (MFC/WinMain 진입 직후)
BOOL CMyApp::InitInstance() {
    InstallCrashHandlers();
    // …
    return TRUE;
}
```

---

## 9) 개인정보/규정/보안 체크리스트

- [ ] 덤프에 **메모리 전체**가 들어갈 수 있음 → **민감 데이터(토큰/비밀번호/키)**를 포함 **가능**  
- [ ] **민감 범위 제외**: 콜백으로 특정 주소 범위 제외, 또는 **WithFullMemory 금지**  
- [ ] 저장 경로/권한: `%ProgramData%\Vendor\App\CrashDumps` + **ACL 제한**  
- [ ] 전송: TLS/암호화, 고객 동의서/정책 고지  
- [ ] 보관 정책: **최대 개수/일수** 롤링, 고객 요청 시 **즉시 삭제**

---

## 10) 문제 해결(FAQ)

**Q. SetUnhandledExceptionFilter가 안 불려요.**  
A. WER/서드파티가 덮었을 수 있습니다. **VEH도 함께** 설치하고, **로컬 덤프 정책**을 백업으로.

**Q. 덤프가 0KB/작게 나와요.**  
A. 헬퍼 권한/경로/공간 확인. DLL 지연 로딩 실패 가능 → `MiniDumpWriteDump`의 **오류 코드** 확인.

**Q. StackOverflow에서 덤프가 실패합니다.**  
A. 스택 여유가 없어 **거의 아무 것도 하지 말고** 헬퍼 프로세스 호출만 시도하세요.

**Q. Hang 때는?**  
A. **WER hang dump**, 또는 **Watchdog 스레드**로 UI 스레드 **스택 캡처**를 주기적으로 수집.

---

## 11) 배포 체크리스트

- [ ] `dbghelp.dll` 버전: OS 내장 사용(권장). **자체 배포 시** OS보다 새 버전이면 문제 가능  
- [ ] **ARR** 활성: `RegisterApplicationRestart/Recovery` 호출  
- [ ] **RM** 사용(인스톨러): 파일 잠금 해제/정상 종료/재시작  
- [ ] **WER 로컬 덤프 정책**: 제품/엔터프라이즈 모드에서 기본값 설정  
- [ ] **심볼 서버/보관**: 릴리즈 PDB 안전 보관  
- [ ] **Crash 텔레메트리**: 덤프 메타(버전/모듈/예외코드)와 함께 업로드

---

## 12) 보너스: “수동 덤프 만들기”(현장지원용)

- 핫키(F12)로 **의도적 덤프**:  
  - UI 반응은 있으나 상태가 이상할 때 **현재 스레드/모든 스레드** 스냅샷을 남김
```cpp
void MakeManualDump() {
    WriteMiniDumpSync(GetCurrentProcess(), GetCurrentProcessId(), nullptr); // EXCEPTION_INFO 없이도 가능
}
```

- PowerShell: `procdump -ma <pid>`(Sysinternals) — 운영팀 배포가 쉽고 신뢰성 높음

---

### 마무리

**크래시 대응**은 “**안전하게 덤프 남기기 → 자동 복구/재시작 → 분석 파이프라인**”의 합입니다.  
위 스캐폴딩(VEH/Unhandled/CRT + MiniDump + ARR + RM + WER LocalDump)을 **초기 템플릿**에 넣어두면,  
현장에서도 **유실 없이** 증거를 확보하고 **사용자는 최소한의 중단**으로 돌아가게 할 수 있습니다.  