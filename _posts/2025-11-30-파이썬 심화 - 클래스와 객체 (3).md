---
layout: post
title: 파이썬 심화 - 클래스와 객체 (3)
date: 2025-11-30 17:25:23 +0900
category: 파이썬 심화
---
# 클래스와 객체 (3)

## 자료 구조 초기화 단순화하기

### 다양한 자료구조 초기화 패턴
```python
print("="*60)
print("자료 구조 초기화 단순화하기")
print("="*60)

# 1. 기본 초기화 패턴 개선
print("1. 기본 초기화 패턴 개선:")

# 전통적인 방법
class TraditionalUser:
    def __init__(self, name, email):
        self.name = name
        self.email = email
        self.posts = []
        self.followers = set()
        self.settings = {}
        self.metadata = {
            'created_at': None,
            'last_login': None,
            'login_count': 0
        }

# 개선된 방법
from dataclasses import dataclass, field
from typing import List, Set, Dict, Optional
from datetime import datetime

@dataclass
class ModernUser:
    """데이터 클래스를 이용한 초기화 단순화"""
    name: str
    email: str
    posts: List[str] = field(default_factory=list)
    followers: Set[str] = field(default_factory=set)
    settings: Dict[str, str] = field(default_factory=dict)
    metadata: Dict[str, any] = field(default_factory=lambda: {
        'created_at': None,
        'last_login': None,
        'login_count': 0
    })
    
    def __post_init__(self):
        """초기화 후 추가 처리"""
        if self.metadata['created_at'] is None:
            self.metadata['created_at'] = datetime.now()

# 사용 비교
print("전통적인 방식:")
user1 = TraditionalUser("김철수", "kim@example.com")
print(f"  이름: {user1.name}, 게시글: {len(user1.posts)}")

print("\n개선된 방식:")
user2 = ModernUser("이영희", "lee@example.com")
print(f"  이름: {user2.name}, 게시글: {len(user2.posts)}")
print(f"  생성시간: {user2.metadata['created_at']}")

# 2. 딕셔너리 초기화 패턴
print("\n2. 딕셔너리 초기화 패턴:")

# 전통적인 딕셔너리 초기화
traditional_dict = {
    'name': '',
    'age': 0,
    'scores': [],
    'metadata': {},
    'tags': set()
}

# 개선된 패턴들
from collections import defaultdict, ChainMap

def create_user_profile(name="", age=0):
    """딕셔너리 초기화 헬퍼 함수"""
    return {
        'name': name,
        'age': age,
        'scores': [],
        'metadata': {},
        'tags': set(),
        'history': defaultdict(list),
        'created_at': datetime.now()
    }

# defaultdict를 이용한 자동 초기화
def create_nested_structure():
    """중첩 구조 자동 초기화"""
    return defaultdict(lambda: {
        'count': 0,
        'items': [],
        'metadata': defaultdict(dict)
    })

# 사용 예시
print("기본 딕셔너리:")
profile = create_user_profile("박민수", 30)
print(f"  프로필: {profile['name']}, 나이: {profile['age']}")
print(f"  생성시간: {profile['created_at']}")

print("\n중첩 구조 딕셔너리:")
nested = create_nested_structure()
nested['category1']['count'] += 1
nested['category1']['items'].append('item1')
nested['category1']['metadata']['user']['role'] = 'admin'

print(f"  카테고리1: {dict(nested['category1'])}")

# 3. 리스트 초기화 패턴
print("\n3. 리스트 초기화 패턴:")

# 다양한 리스트 초기화 방법
size = 5

# 방법 1: 리스트 컴프리헨션
list1 = [0] * size  # 동일 객체 참조 주의!
print(f"곱셈 연산자: {list1}")

list2 = [i * 2 for i in range(size)]  # 안전한 방법
print(f"리스트 컴프리헨션: {list2}")

# 방법 2: 제너레이터 사용
def generate_matrix(rows, cols, default_value=0):
    """2차원 매트릭스 생성"""
    return [[default_value for _ in range(cols)] for _ in range(rows)]

matrix = generate_matrix(3, 3, 0)
print(f"2D 매트릭스: {matrix}")

# 방법 3: 클래스 메서드로 초기화
class Matrix:
    """매트릭스 클래스"""
    
    @classmethod
    def zeros(cls, rows, cols):
        """0으로 채워진 매트릭스 생성"""
        return [[0 for _ in range(cols)] for _ in range(rows)]
    
    @classmethod
    def identity(cls, size):
        """단위 행렬 생성"""
        return [[1 if i == j else 0 for j in range(size)] for i in range(size)]
    
    @classmethod
    def from_pattern(cls, pattern_func, rows, cols):
        """패턴 함수로 매트릭스 생성"""
        return [[pattern_func(i, j) for j in range(cols)] for i in range(rows)]

# 사용 예시
print("\n매트릭스 팩토리 메서드:")
zeros = Matrix.zeros(2, 3)
print(f"zeros(2x3): {zeros}")

identity = Matrix.identity(3)
print(f"identity(3x3): {identity}")

pattern_matrix = Matrix.from_pattern(lambda i, j: i * 10 + j, 2, 3)
print(f"pattern_matrix: {pattern_matrix}")

# 4. 세트 초기화 패턴
print("\n4. 세트 초기화 패턴:")

# 다양한 세트 초기화 방법
# 방법 1: 리터럴
set1 = {1, 2, 3, 4, 5}
print(f"리터럴: {set1}")

# 방법 2: set comprehension
set2 = {x * 2 for x in range(10) if x % 2 == 0}
print(f"세트 컴프리헨션: {set2}")

# 방법 3: 문자열에서 문자 세트
def char_set(text, filter_func=None):
    """문자열에서 문자 세트 생성"""
    if filter_func:
        return {char for char in text if filter_func(char)}
    return set(text)

text = "Hello World! 123"
letters = char_set(text, str.isalpha)
digits = char_set(text, str.isdigit)

print(f"문자만: {letters}")
print(f"숫자만: {digits}")

# 5. 복잡한 자료구조 초기화 패턴
print("\n5. 복잡한 자료구조 초기화 패턴:")

class Graph:
    """그래프 자료구조"""
    
    def __init__(self, directed=False):
        self.directed = directed
        self._adjacency_list = defaultdict(set)
        self._vertices = {}
        self._edges = []
    
    @classmethod
    def from_edges(cls, edges, directed=False):
        """간선 리스트로 그래프 생성"""
        graph = cls(directed)
        
        for u, v, *data in edges:
            graph.add_edge(u, v, *data)
        
        return graph
    
    @classmethod
    def from_adjacency_matrix(cls, matrix, vertices=None):
        """인접 행렬로 그래프 생성"""
        size = len(matrix)
        graph = cls()
        
        if vertices is None:
            vertices = list(range(size))
        
        # 정점 추가
        for i, v in enumerate(vertices):
            graph._vertices[v] = {'index': i}
        
        # 간선 추가
        for i in range(size):
            for j in range(size):
                if matrix[i][j] != 0:
                    u = vertices[i]
                    v = vertices[j]
                    graph.add_edge(u, v, weight=matrix[i][j])
        
        return graph
    
    def add_vertex(self, vertex, **attrs):
        """정점 추가"""
        self._vertices[vertex] = attrs
        return self
    
    def add_edge(self, u, v, **attrs):
        """간선 추가"""
        self._adjacency_list[u].add(v)
        self._edges.append((u, v, attrs))
        
        if not self.directed:
            self._adjacency_list[v].add(u)
            self._edges.append((v, u, attrs))
        
        return self
    
    def __repr__(self):
        return f"Graph(vertices={len(self._vertices)}, edges={len(self._edges)})"

# 사용 예시
print("간선 리스트로 그래프 생성:")
edges = [
    ('A', 'B', {'weight': 4}),
    ('A', 'C', {'weight': 2}),
    ('B', 'C', {'weight': 1}),
    ('B', 'D', {'weight': 5}),
    ('C', 'D', {'weight': 8})
]

graph1 = Graph.from_edges(edges)
print(f"그래프1: {graph1}")

print("\n인접 행렬로 그래프 생성:")
adj_matrix = [
    [0, 4, 2, 0],
    [4, 0, 1, 5],
    [2, 1, 0, 8],
    [0, 5, 8, 0]
]
vertices = ['A', 'B', 'C', 'D']

graph2 = Graph.from_adjacency_matrix(adj_matrix, vertices)
print(f"그래프2: {graph2}")

# 6. 팩토리 함수와 빌더 패턴
print("\n6. 팩토리 함수와 빌더 패턴:")

class DatabaseConfig:
    """데이터베이스 설정 빌더"""
    
    def __init__(self):
        self._host = 'localhost'
        self._port = 5432
        self._database = 'default'
        self._username = None
        self._password = None
        self._options = {}
    
    @classmethod
    def create(cls):
        """빌더 시작"""
        return cls()
    
    def host(self, host):
        self._host = host
        return self
    
    def port(self, port):
        self._port = port
        return self
    
    def database(self, database):
        self._database = database
        return self
    
    def credentials(self, username, password):
        self._username = username
        self._password = password
        return self
    
    def option(self, key, value):
        self._options[key] = value
        return self
    
    def build(self):
        """설정 객체 생성"""
        return {
            'host': self._host,
            'port': self._port,
            'database': self._database,
            'username': self._username,
            'password': self._password,
            'options': self._options.copy()
        }

# 빌더 패턴 사용
print("빌더 패턴으로 설정 생성:")
config = (DatabaseConfig.create()
          .host('db.example.com')
          .port(5432)
          .database('myapp')
          .credentials('admin', 'secret123')
          .option('pool_size', 10)
          .option('timeout', 30)
          .build())

print(f"설정: {config}")

# 7. 컨텍스트 매니저를 이용한 초기화
print("\n7. 컨텍스트 매니저를 이용한 초기화:")

from contextlib import contextmanager

@contextmanager
def temporary_data_structure(initial_data=None, auto_cleanup=True):
    """
    임시 자료구조 생성 컨텍스트 매니저
    사용 후 자동 정리
    """
    data = initial_data.copy() if initial_data else {}
    history = []
    
    try:
        yield data, history
    finally:
        if auto_cleanup:
            print(f"임시 자료구조 정리: {len(data)}개 항목 삭제")
            data.clear()
            history.clear()

# 사용 예시
print("컨텍스트 매니저로 임시 자료구조 관리:")
with temporary_data_structure() as (data, history):
    data['user'] = {'name': '김철수', 'age': 30}
    data['items'] = [1, 2, 3, 4, 5]
    history.append('데이터 추가 완료')
    
    print(f"  작업 중 데이터: {data}")
    print(f"  작업 기록: {history}")

print("컨텍스트 종료 후 자동 정리됨")

# 8. 초기화 데코레이터 패턴
print("\n8. 초기화 데코레이터 패턴:")

def auto_initialize(method):
    """
    자동 초기화 데코레이터
    메서드 호출 시 필요한 속성이 없으면 자동 생성
    """
    def wrapper(self, *args, **kwargs):
        # 필요한 속성 자동 초기화
        if not hasattr(self, '_initialized') or not self._initialized:
            self._initialize_structure()
            self._initialized = True
        
        return method(self, *args, **kwargs)
    return wrapper

class AutoInitializingCache:
    """자동 초기화 캐시"""
    
    def __init__(self):
        self._initialized = False
        self._cache = None
        self._stats = None
    
    def _initialize_structure(self):
        """내부 구조 초기화"""
        self._cache = {}
        self._stats = {
            'hits': 0,
            'misses': 0,
            'size': 0,
            'created_at': datetime.now()
        }
        print("캐시 구조 자동 초기화 완료")
    
    @auto_initialize
    def get(self, key, default=None):
        """캐시에서 값 조회"""
        if key in self._cache:
            self._stats['hits'] += 1
            return self._cache[key]
        
        self._stats['misses'] += 1
        return default
    
    @auto_initialize
    def set(self, key, value):
        """캐시에 값 저장"""
        self._cache[key] = value
        self._stats['size'] = len(self._cache)
    
    @auto_initialize
    def stats(self):
        """캐시 통계 반환"""
        return dict(self._stats)

# 사용 예시
print("자동 초기화 캐시 테스트:")
cache = AutoInitializingCache()

# 첫 호출 시 자동 초기화
cache.set('name', '김철수')
print(f"캐시 저장 후: {cache.get('name')}")
print(f"캐시 통계: {cache.stats()}")

# 9. 슬롯을 이용한 메모리 효율적 초기화
print("\n9. __slots__을 이용한 메모리 효율적 초기화:")

class EfficientUser:
    """
    __slots__을 사용한 메모리 효율적인 클래스
    속성 수가 고정된 경우 유용
    """
    __slots__ = ('name', 'email', 'age', '_cache')
    
    def __init__(self, name, email, age=0):
        self.name = name
        self.email = email
        self.age = age
        self._cache = {}  # __slots__에 정의된 속성만 가질 수 있음
    
    @property
    def display_info(self):
        """계산된 속성"""
        if 'display_info' not in self._cache:
            self._cache['display_info'] = f"{self.name} ({self.age}) <{self.email}>"
        return self._cache['display_info']
    
    def __repr__(self):
        return f"EfficientUser(name={self.name}, email={self.email})"

class RegularUser:
    """일반적인 클래스 (비교용)"""
    def __init__(self, name, email, age=0):
        self.name = name
        self.email = email
        self.age = age

# 메모리 사용량 비교
import sys

print("메모리 사용량 비교:")
efficient = EfficientUser("김철수", "kim@example.com", 30)
regular = RegularUser("이영희", "lee@example.com", 30)

print(f"EfficientUser 크기: {sys.getsizeof(efficient)} + {sys.getsizeof(efficient._cache)} 바이트")
print(f"RegularUser 크기: {sys.getsizeof(regular)} 바이트")

# 인스턴스 많은 경우의 차이
users_efficient = [EfficientUser(f"User{i}", f"user{i}@test.com", i) for i in range(1000)]
users_regular = [RegularUser(f"User{i}", f"user{i}@test.com", i) for i in range(1000)]

print(f"\n1000개 인스턴스 총 크기:")
print(f"EfficientUser: 약 {sum(sys.getsizeof(u) + sys.getsizeof(u._cache) for u in users_efficient):,} 바이트")
print(f"RegularUser: 약 {sum(sys.getsizeof(u) for u in users_regular):,} 바이트")
```

## 인터페이스와 추상 베이스 클래스

### Python에서의 인터페이스 구현 패턴
```python
print("\n" + "="*60)
print("인터페이스와 추상 베이스 클래스")
print("="*60)

# 1. 추상 베이스 클래스 (ABC) 기본
print("1. 추상 베이스 클래스 (ABC) 기본:")

from abc import ABC, abstractmethod
from typing import List, Dict, Any

class DataStorage(ABC):
    """데이터 저장소 인터페이스"""
    
    @abstractmethod
    def save(self, key: str, data: Any) -> bool:
        """데이터 저장"""
        pass
    
    @abstractmethod
    def load(self, key: str) -> Any:
        """데이터 로드"""
        pass
    
    @abstractmethod
    def delete(self, key: str) -> bool:
        """데이터 삭제"""
        pass
    
    @abstractmethod
    def list_keys(self) -> List[str]:
        """키 목록 반환"""
        pass
    
    # 선택적 메서드 (구현 강제 안함)
    def get_stats(self) -> Dict[str, Any]:
        """저장소 통계 (기본 구현 제공)"""
        return {
            'interface': self.__class__.__name__,
            'methods': ['save', 'load', 'delete', 'list_keys']
        }

# 추상 클래스 구현
class MemoryStorage(DataStorage):
    """메모리 저장소 구현"""
    
    def __init__(self):
        self._storage = {}
        self._access_count = 0
    
    def save(self, key: str, data: Any) -> bool:
        self._storage[key] = data
        self._access_count += 1
        return True
    
    def load(self, key: str) -> Any:
        self._access_count += 1
        return self._storage.get(key)
    
    def delete(self, key: str) -> bool:
        if key in self._storage:
            del self._storage[key]
            self._access_count += 1
            return True
        return False
    
    def list_keys(self) -> List[str]:
        return list(self._storage.keys())
    
    def get_stats(self) -> Dict[str, Any]:
        base_stats = super().get_stats()
        base_stats.update({
            'implementation': 'MemoryStorage',
            'item_count': len(self._storage),
            'access_count': self._access_count
        })
        return base_stats

# 사용 예시
print("메모리 저장소 테스트:")
storage = MemoryStorage()
storage.save('user:1', {'name': '김철수', 'age': 30})
storage.save('config:app', {'theme': 'dark', 'language': 'ko'})

print(f"저장된 키들: {storage.list_keys()}")
print(f"사용자 데이터: {storage.load('user:1')}")
print(f"통계: {storage.get_stats()}")

# 2. 인터페이스 검증과 등록
print("\n2. 인터페이스 검증과 등록:")

from abc import ABCMeta, abstractproperty

class PaymentProcessor(ABC):
    """결제 처리기 인터페이스"""
    
    @abstractmethod
    def process_payment(self, amount: float, currency: str) -> str:
        """결제 처리"""
        pass
    
    @abstractmethod
    def refund_payment(self, transaction_id: str) -> bool:
        """결제 환불"""
        pass
    
    @property
    @abstractmethod
    def supported_currencies(self) -> List[str]:
        """지원 통화 목록"""
        pass
    
    @classmethod
    def __subclasshook__(cls, subclass):
        """구현 검사를 위한 서브클래스 훅"""
        if cls is PaymentProcessor:
            required_methods = {'process_payment', 'refund_payment'}
            required_properties = {'supported_currencies'}
            
            # 메서드 검사
            methods_ok = all(
                hasattr(subclass, method) and callable(getattr(subclass, method))
                for method in required_methods
            )
            
            # 프로퍼티 검사
            properties_ok = all(
                hasattr(subclass, prop)
                for prop in required_properties
            )
            
            return methods_ok and properties_ok
        
        return NotImplemented

# 인터페이스 구현
class CreditCardProcessor(PaymentProcessor):
    """신용카드 결제 처리기"""
    
    def __init__(self):
        self._transactions = {}
    
    @property
    def supported_currencies(self):
        return ['USD', 'EUR', 'KRW', 'JPY']
    
    def process_payment(self, amount: float, currency: str) -> str:
        if currency not in self.supported_currencies:
            raise ValueError(f"지원하지 않는 통화: {currency}")
        
        # 결제 처리 시뮬레이션
        transaction_id = f"CC_{len(self._transactions) + 1:06d}"
        self._transactions[transaction_id] = {
            'amount': amount,
            'currency': currency,
            'status': 'completed',
            'timestamp': datetime.now()
        }
        
        return transaction_id
    
    def refund_payment(self, transaction_id: str) -> bool:
        if transaction_id in self._transactions:
            self._transactions[transaction_id]['status'] = 'refunded'
            return True
        return False

# 인터페이스 검증
print("결제 처리기 인터페이스 검증:")
processor = CreditCardProcessor()

# isinstance 검사
print(f"PaymentProcessor 구현체인가? {isinstance(processor, PaymentProcessor)}")
print(f"ABC 구현체인가? {isinstance(processor, ABC)}")

# 실제 사용
transaction_id = processor.process_payment(100.0, 'KRW')
print(f"결제 완료: {transaction_id}")
print(f"지원 통화: {processor.supported_currencies}")
print(f"환불 시도: {processor.refund_payment(transaction_id)}")

# 3. 다중 인터페이스와 믹스인
print("\n3. 다중 인터페이스와 믹스인:")

class Loggable(ABC):
    """로깅 가능 인터페이스"""
    
    @abstractmethod
    def log(self, message: str, level: str = 'INFO'):
        pass
    
    @property
    @abstractmethod
    def logger_name(self) -> str:
        pass

class Serializable(ABC):
    """직렬화 가능 인터페이스"""
    
    @abstractmethod
    def to_dict(self) -> Dict[str, Any]:
        pass
    
    @classmethod
    @abstractmethod
    def from_dict(cls, data: Dict[str, Any]):
        pass

# 믹스인 클래스
class JSONSerializableMixin:
    """JSON 직렬화 믹스인"""
    
    def to_json(self) -> str:
        import json
        return json.dumps(self.to_dict(), ensure_ascii=False)
    
    @classmethod
    def from_json(cls, json_str: str):
        import json
        data = json.loads(json_str)
        return cls.from_dict(data)

# 다중 인터페이스 구현
class UserModel(Loggable, Serializable, JSONSerializableMixin):
    """사용자 모델 - 다중 인터페이스 구현"""
    
    def __init__(self, user_id: str, name: str, email: str):
        self.user_id = user_id
        self.name = name
        self.email = email
        self._logs = []
    
    @property
    def logger_name(self) -> str:
        return f"UserModel.{self.user_id}"
    
    def log(self, message: str, level: str = 'INFO'):
        log_entry = {
            'timestamp': datetime.now(),
            'level': level,
            'message': message
        }
        self._logs.append(log_entry)
        print(f"[{level}] {self.logger_name}: {message}")
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'user_id': self.user_id,
            'name': self.name,
            'email': self.email,
            'logs': [
                {**log, 'timestamp': log['timestamp'].isoformat()}
                for log in self._logs
            ]
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]):
        instance = cls(
            user_id=data['user_id'],
            name=data['name'],
            email=data['email']
        )
        
        # 로그 복원
        for log in data.get('logs', []):
            log['timestamp'] = datetime.fromisoformat(log['timestamp'])
        
        instance._logs = data.get('logs', [])
        return instance

# 사용 예시
print("다중 인터페이스 구현 테스트:")
user = UserModel("U001", "김철수", "kim@example.com")

# Loggable 인터페이스 사용
user.log("사용자 생성됨")
user.log("프로필 업데이트", "WARNING")

# Serializable 인터페이스 사용
user_dict = user.to_dict()
print(f"사전 변환: {user_dict['user_id']}, {user_dict['name']}")

# 믹스인 메서드 사용
json_str = user.to_json()
print(f"JSON 직렬화: {json_str[:50]}...")

# 역직렬화
restored_user = UserModel.from_json(json_str)
print(f"복원된 사용자: {restored_user.name}, 로그 수: {len(restored_user._logs)}")

# 4. 프로토콜 (구조적 서브타이핑)
print("\n4. 프로토콜 (구조적 서브타이핑):")

from typing import Protocol, runtime_checkable

@runtime_checkable
class Renderable(Protocol):
    """렌더링 가능 프로토콜"""
    
    def render(self) -> str:
        """HTML 문자열로 렌더링"""
        ...
    
    @property
    def element_id(self) -> str:
        """요소 ID"""
        ...

# 프로토콜 구현 (명시적 상속 불필요)
class Button:
    """버튼 클래스 - Renderable 프로토콜 구현"""
    
    def __init__(self, text: str, element_id: str = None):
        self.text = text
        self._element_id = element_id or f"btn_{id(self)}"
    
    @property
    def element_id(self) -> str:
        return self._element_id
    
    def render(self) -> str:
        return f'<button id="{self.element_id}">{self.text}</button>'
    
    def click(self):
        """버튼 고유 메서드"""
        return f"버튼 '{self.text}' 클릭됨"

class Card:
    """카드 컴포넌트 - Renderable 프로토콜 구현"""
    
    def __init__(self, title: str, content: str):
        self.title = title
        self.content = content
    
    @property
    def element_id(self) -> str:
        return f"card_{hash(self.title)}"
    
    def render(self) -> str:
        return f'''
        <div class="card" id="{self.element_id}">
            <h3>{self.title}</h3>
            <p>{self.content}</p>
        </div>
        '''

# 프로토콜 사용
def render_component(component: Renderable) -> str:
    """Renderable 프로토콜을 따르는 컴포넌트 렌더링"""
    if not isinstance(component, Renderable):
        raise TypeError("Renderable 프로토콜을 구현해야 합니다")
    
    return component.render()

# 사용 예시
print("프로토콜 기반 렌더링:")
button = Button("저장하기")
card = Card("제목", "내용입니다")

# isinstance 검사 (런타임 체크)
print(f"버튼이 Renderable인가? {isinstance(button, Renderable)}")
print(f"카드가 Renderable인가? {isinstance(card, Renderable)}")

# 프로토콜 함수 사용
print(f"\n버튼 렌더링:\n{render_component(button)}")
print(f"\n카드 렌더링:\n{render_component(card)}")

# 5. 인터페이스 어댑터 패턴
print("\n5. 인터페이스 어댑터 패턴:")

class LegacyDatabase:
    """레거시 데이터베이스 (변경 불가능한 코드)"""
    
    def fetch_record(self, table: str, record_id: int) -> Dict:
        # 레거시 형식의 데이터 반환
        return {
            'id': record_id,
            'data': f"Record from {table}",
            'timestamp': '2024-01-15 10:30:00',
            'status': 'A'
        }
    
    def insert_record(self, table: str, data: Dict) -> bool:
        print(f"[레거시] {table}에 데이터 삽입: {data}")
        return True

# 현대적인 인터페이스
class ModernDatabase(ABC):
    """현대적인 데이터베이스 인터페이스"""
    
    @abstractmethod
    def get(self, collection: str, document_id: str) -> Dict:
        pass
    
    @abstractmethod
    def save(self, collection: str, document: Dict) -> str:
        pass

# 어댑터 구현
class LegacyDatabaseAdapter(ModernDatabase):
    """레거시 데이터베이스를 현대적 인터페이스로 변환"""
    
    def __init__(self, legacy_db: LegacyDatabase):
        self._legacy_db = legacy_db
        self._table_mapping = {
            'users': 'user_table',
            'products': 'product_table'
        }
    
    def _convert_to_modern(self, legacy_record: Dict) -> Dict:
        """레거시 형식을 현대적 형식으로 변환"""
        return {
            'id': str(legacy_record['id']),
            'data': legacy_record['data'],
            'metadata': {
                'created_at': legacy_record['timestamp'],
                'status': legacy_record['status']
            }
        }
    
    def _convert_to_legacy(self, modern_document: Dict) -> Dict:
        """현대적 형식을 레거시 형식으로 변환"""
        return {
            'id': int(modern_document['id']),
            'data': modern_document.get('data', ''),
            'timestamp': modern_document.get('metadata', {}).get('created_at', ''),
            'status': modern_document.get('metadata', {}).get('status', 'N')
        }
    
    def get(self, collection: str, document_id: str) -> Dict:
        # 컬렉션명을 테이블명으로 매핑
        table = self._table_mapping.get(collection, collection)
        
        # 레거시 메서드 호출
        legacy_record = self._legacy_db.fetch_record(
            table, 
            int(document_id)
        )
        
        # 현대적 형식으로 변환
        return self._convert_to_modern(legacy_record)
    
    def save(self, collection: str, document: Dict) -> str:
        table = self._table_mapping.get(collection, collection)
        
        # 레거시 형식으로 변환
        legacy_data = self._convert_to_legacy(document)
        
        # 레거시 메서드 호출
        success = self._legacy_db.insert_record(table, legacy_data)
        
        if success:
            return document['id']
        raise Exception("저장 실패")

# 사용 예시
print("어댑터 패턴 테스트:")
legacy_db = LegacyDatabase()
adapter = LegacyDatabaseAdapter(legacy_db)

# 현대적 인터페이스 사용
modern_user = {
    'id': '1001',
    'data': '김철수의 데이터',
    'metadata': {
        'created_at': '2024-01-15 10:30:00',
        'status': 'active'
    }
}

# 저장
document_id = adapter.save('users', modern_user)
print(f"문서 저장 완료: {document_id}")

# 조회
retrieved = adapter.get('users', '1001')
print(f"문서 조회: {retrieved}")

# 6. 인터페이스 레지스트리 패턴
print("\n6. 인터페이스 레지스트리 패턴:")

class PluginInterface(ABC):
    """플러그인 인터페이스"""
    
    @abstractmethod
    def initialize(self, context: Dict) -> bool:
        pass
    
    @abstractmethod
    def execute(self, data: Any) -> Any:
        pass
    
    @abstractmethod
    def cleanup(self):
        pass
    
    @property
    @abstractmethod
    def plugin_name(self) -> str:
        pass
    
    @property
    @abstractmethod
    def version(self) -> str:
        pass

class PluginRegistry:
    """플러그인 레지스트리"""
    
    def __init__(self):
        self._plugins = {}
        self._initialized = False
    
    def register(self, plugin_class):
        """플러그인 등록"""
        if not issubclass(plugin_class, PluginInterface):
            raise TypeError(f"{plugin_class.__name__}는 PluginInterface를 구현해야 합니다")
        
        plugin_name = plugin_class.__name__
        self._plugins[plugin_name] = plugin_class
        
        print(f"플러그인 등록: {plugin_name}")
        return self
    
    def create_plugin(self, plugin_name: str, **kwargs):
        """플러그인 인스턴스 생성"""
        if plugin_name not in self._plugins:
            raise KeyError(f"플러그인 '{plugin_name}'이 등록되지 않았습니다")
        
        plugin_class = self._plugins[plugin_name]
        return plugin_class(**kwargs)
    
    def initialize_all(self, context: Dict):
        """모든 플러그인 초기화"""
        self._instances = {}
        
        for name, plugin_class in self._plugins.items():
            try:
                instance = plugin_class()
                if instance.initialize(context):
                    self._instances[name] = instance
                    print(f"플러그인 초기화 성공: {name} v{instance.version}")
                else:
                    print(f"플러그인 초기화 실패: {name}")
            except Exception as e:
                print(f"플러그인 초기화 오류 ({name}): {e}")
        
        self._initialized = True
        return len(self._instances)
    
    def get_plugin(self, name: str):
        """플러그인 인스턴스 가져오기"""
        if not self._initialized:
            raise RuntimeError("플러그인이 초기화되지 않았습니다")
        
        return self._instances.get(name)
    
    def execute_pipeline(self, data: Any):
        """파이프라인 실행 (모든 플러그인 순차 실행)"""
        if not self._initialized:
            raise RuntimeError("플러그인이 초기화되지 않았습니다")
        
        result = data
        
        for name, instance in self._instances.items():
            try:
                print(f"[{name}] 실행 중...")
                result = instance.execute(result)
                print(f"[{name}] 실행 완료")
            except Exception as e:
                print(f"[{name}] 실행 오류: {e}")
                raise
        
        return result

# 플러그인 구현
class DataValidatorPlugin(PluginInterface):
    
    @property
    def plugin_name(self):
        return "DataValidator"
    
    @property
    def version(self):
        return "1.0.0"
    
    def initialize(self, context: Dict) -> bool:
        print(f"[{self.plugin_name}] 초기화: 설정={context.get('settings', {})}")
        return True
    
    def execute(self, data: Any) -> Any:
        if not isinstance(data, dict):
            raise ValueError("데이터는 딕셔너리여야 합니다")
        
        if 'required' not in data:
            raise ValueError("'required' 필드가 없습니다")
        
        print(f"[{self.plugin_name}] 데이터 검증 완료")
        return data
    
    def cleanup(self):
        print(f"[{self.plugin_name}] 정리 완료")

class DataTransformerPlugin(PluginInterface):
    
    @property
    def plugin_name(self):
        return "DataTransformer"
    
    @property
    def version(self):
        return "1.1.0"
    
    def initialize(self, context: Dict) -> bool:
        self.transform_rules = context.get('transform_rules', {})
        return True
    
    def execute(self, data: Any) -> Any:
        if not isinstance(data, dict):
            return data
        
        # 변환 규칙 적용
        transformed = data.copy()
        
        for key, rule in self.transform_rules.items():
            if key in transformed:
                if rule == 'uppercase' and isinstance(transformed[key], str):
                    transformed[key] = transformed[key].upper()
                elif rule == 'int' and isinstance(transformed[key], (int, float, str)):
                    try:
                        transformed[key] = int(float(transformed[key]))
                    except ValueError:
                        pass
        
        print(f"[{self.plugin_name}] 데이터 변환 완료")
        return transformed
    
    def cleanup(self):
        print(f"[{self.plugin_name}] 정리 완료")

# 레지스트리 사용
print("플러그인 레지스트리 테스트:")
registry = PluginRegistry()

# 플러그인 등록
registry.register(DataValidatorPlugin)
registry.register(DataTransformerPlugin)

# 초기화
context = {
    'settings': {'debug': True},
    'transform_rules': {'name': 'uppercase', 'age': 'int'}
}

initialized_count = registry.initialize_all(context)
print(f"초기화된 플러그인 수: {initialized_count}")

# 파이프라인 실행
input_data = {
    'required': True,
    'name': 'kim chulsoo',
    'age': '30',
    'city': 'Seoul'
}

try:
    result = registry.execute_pipeline(input_data)
    print(f"파이프라인 결과: {result}")
except Exception as e:
    print(f"파이프라인 오류: {e}")

# 7. 추상 베이스 클래스와 템플릿 메서드 패턴
print("\n7. 추상 베이스 클래스와 템플릿 메서드 패턴:")

class ReportGenerator(ABC):
    """보고서 생성기 템플릿"""
    
    def generate_report(self, data: List[Dict]) -> str:
        """
        보고서 생성 템플릿 메서드
        알고리즘의 골격을 정의
        """
        # 1. 데이터 검증
        self._validate_data(data)
        
        # 2. 데이터 전처리
        processed_data = self._preprocess_data(data)
        
        # 3. 보고서 헤더 생성
        header = self._create_header()
        
        # 4. 보고서 본문 생성
        body = self._create_body(processed_data)
        
        # 5. 보고서 푸터 생성
        footer = self._create_footer()
        
        # 6. 보고서 조립
        report = self._assemble_report(header, body, footer)
        
        # 7. 후처리
        final_report = self._postprocess_report(report)
        
        return final_report
    
    def _validate_data(self, data: List[Dict]):
        """데이터 검증 (훅 메서드)"""
        if not data:
            raise ValueError("데이터가 비어있습니다")
        print(f"[{self.__class__.__name__}] 데이터 검증 완료")
    
    def _preprocess_data(self, data: List[Dict]) -> List[Dict]:
        """데이터 전처리 (훅 메서드)"""
        # 기본 구현: 데이터 그대로 반환
        return data
    
    @abstractmethod
    def _create_header(self) -> str:
        """헤더 생성 (추상 메서드)"""
        pass
    
    @abstractmethod
    def _create_body(self, data: List[Dict]) -> str:
        """본문 생성 (추상 메서드)"""
        pass
    
    def _create_footer(self) -> str:
        """푸터 생성 (훅 메서드)"""
        # 기본 구현
        return f"\n---\n생성일: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    
    def _assemble_report(self, header: str, body: str, footer: str) -> str:
        """보고서 조립 (훅 메서드)"""
        return f"{header}\n\n{body}\n\n{footer}"
    
    def _postprocess_report(self, report: str) -> str:
        """후처리 (훅 메서드)"""
        # 기본 구현: 공백 정리
        import re
        return re.sub(r'\n{3,}', '\n\n', report.strip())

# 구체적인 구현
class HTMLReportGenerator(ReportGenerator):
    """HTML 보고서 생성기"""
    
    def _create_header(self) -> str:
        return """<!DOCTYPE html>
<html>
<head>
    <title>데이터 보고서</title>
    <style>
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h1>데이터 보고서</h1>"""
    
    def _create_body(self, data: List[Dict]) -> str:
        if not data:
            return "<p>데이터가 없습니다.</p>"
        
        # 테이블 헤더
        headers = list(data[0].keys())
        header_row = "".join(f"<th>{h}</th>" for h in headers)
        
        # 데이터 행
        rows = []
        for row in data:
            cells = "".join(f"<td>{row.get(h, '')}</td>" for h in headers)
            rows.append(f"<tr>{cells}</tr>")
        
        table_body = "\n".join(rows)
        
        return f"""
    <table>
        <thead><tr>{header_row}</tr></thead>
        <tbody>
            {table_body}
        </tbody>
    </table>"""
    
    def _create_footer(self) -> str:
        base_footer = super()._create_footer()
        return f"""
    <hr>
    <footer>
        <p>{base_footer}</p>
    </footer>"""
    
    def _assemble_report(self, header: str, body: str, footer: str) -> str:
        return f"{header}\n{body}\n{footer}\n</body>\n</html>"

class CSVReportGenerator(ReportGenerator):
    """CSV 보고서 생성기"""
    
    def _preprocess_data(self, data: List[Dict]) -> List[Dict]:
        """CSV용 데이터 전처리"""
        processed = []
        for row in data:
            # 모든 값을 문자열로 변환
            processed_row = {}
            for key, value in row.items():
                if isinstance(value, (list, dict)):
                    processed_row[key] = str(value)
                else:
                    processed_row[key] = value
            processed.append(processed_row)
        return processed
    
    def _create_header(self) -> str:
        return "CSV 보고서\n==========\n"
    
    def _create_body(self, data: List[Dict]) -> str:
        if not data:
            return "No data"
        
        import csv
        import io
        
        # CSV 문자열 생성
        output = io.StringIO()
        writer = csv.DictWriter(output, fieldnames=data[0].keys())
        
        writer.writeheader()
        writer.writerows(data)
        
        return output.getvalue()
    
    def _assemble_report(self, header: str, body: str, footer: str) -> str:
        return f"{header}\n{body}\n{footer}"

# 사용 예시
print("템플릿 메서드 패턴 테스트:")

# 샘플 데이터
sample_data = [
    {'id': 1, 'name': '김철수', 'age': 30, 'department': '개발팀'},
    {'id': 2, 'name': '이영희', 'age': 25, 'department': '디자인팀'},
    {'id': 3, 'name': '박민수', 'age': 35, 'department': '기획팀'}
]

# HTML 보고서 생성
print("\nHTML 보고서 생성:")
html_generator = HTMLReportGenerator()
html_report = html_generator.generate_report(sample_data)
print(f"HTML 보고서 길이: {len(html_report)} 문자")
print(f"처음 200자: {html_report[:200]}...")

# CSV 보고서 생성
print("\nCSV 보고서 생성:")
csv_generator = CSVReportGenerator()
csv_report = csv_generator.generate_report(sample_data)
print(f"CSV 보고서:\n{csv_report}")
```

## 결론

Python에서 자료 구조 초기화를 단순화하는 다양한 기법이 있습니다. `dataclasses` 모듈은 클래스 정의를 간소화하고 기본값을 쉽게 설정할 수 있게 해줍니다. 팩토리 함수, 빌더 패턴, 컨텍스트 매니저는 복잡한 초기화 로직을 캡슐화하여 코드 가독성을 높입니다. `__slots__`은 메모리 사용량이 중요한 경우 유용한 최적화 기법입니다. 초기화 데코레이터는 필요한 시점에 자동으로 초기화를 수행하게 해줍니다.

인터페이스와 추상 베이스 클래스(ABC)는 Python에서 객체 지향 설계의 핵심 요소입니다. ABC는 `@abstractmethod` 데코레이터를 통해 인터페이스를 명시적으로 정의하고, 서브클래스가 특정 메서드를 구현하도록 강제할 수 있습니다. Python 3.8부터는 `typing.Protocol`을 이용한 구조적 서브타이핑이 가능해져, 명시적 상속 없이도 인터페이스 호환성을 검사할 수 있습니다.

인터페이스 설계 패턴으로는:
1. **단일 인터페이스**: 하나의 책임만 가진 깔끔한 인터페이스
2. **다중 인터페이스**: 여러 인터페이스를 조합하여 복합적인 동작 정의
3. **어댑터 패턴**: 기존 클래스를 새로운 인터페이스에 맞게 변환
4. **레지스트리 패턴**: 플러그인 시스템처럼 동적으로 구현체 등록 및 관리
5. **템플릿 메서드 패턴**: 알고리즘의 골격을 정의하고 세부 구현은 서브클래스에 위임

이러한 기법들을 효과적으로 사용하면:
- **재사용성 향상**: 잘 정의된 인터페이스는 다양한 구현체 교체를 용이하게 함
- **테스트 용이성**: 모의 객체(Mock)를 이용한 테스트가 쉬워짐
- **유지보수성**: 의존성 역전 원칙을 적용하여 결합도가 낮아짐
- **확장성**: 새로운 기능 추가가 기존 코드에 영향을 최소화하면서 가능

단, Python의 동적 특성을 고려하여 필요 이상의 추상화는 피해야 합니다. 간단한 경우에는 덕 타이핑(duck typing)이 더 적합할 수 있으며, 프로토콜 기반 접근이 명시적 상속보다 유연한 경우가 많습니다. 프로젝트의 규모와 요구사항에 맞는 적절한 추상화 수준을 선택하는 것이 중요합니다.