---
layout: post
title: ê¸°ê³„í•™ìŠµ - íƒ€ì´íƒ€ë‹‰ ìƒì¡´ì ì˜ˆì¸¡
date: 2025-08-20 18:25:23 +0900
category: ê¸°ê³„í•™ìŠµ
---
# ğŸš¢ íƒ€ì´íƒ€ë‹‰ ìƒì¡´ì ì˜ˆì¸¡ (Binary Classification) â€” ëê¹Œì§€ ê°€ëŠ” ì‹¤ì „ ê°€ì´ë“œ

íƒ€ì´íƒ€ë‹‰ ìƒì¡´ì ì˜ˆì¸¡ì€ **ì´ì§„ ë¶„ë¥˜** ë¬¸ì œì˜ êµê³¼ì„œ ê°™ì€ ì˜ˆì‹œì…ë‹ˆë‹¤.  
ëª©í‘œëŠ” ìŠ¹ê°ì˜ ì†ì„±(ì„±ë³„, ë‚˜ì´, ì„ ì‹¤ ë“±)ìœ¼ë¡œ **Survived (0/1)** ë¥¼ ì˜ˆì¸¡í•˜ëŠ” ê²ƒ.

---

## 1) ë°ì´í„° ê°œìš”ì™€ íƒ€ê¹ƒ

### ì£¼ìš” ì»¬ëŸ¼
| ì»¬ëŸ¼ | ì„¤ëª… | íƒ€ì…/ì˜ˆì‹œ | ê²°ì¸¡ |
|---|---|---|---|
| Survived | ìƒì¡´ ì—¬ë¶€(íƒ€ê¹ƒ) | 0/1 | â€” |
| Pclass | ì„ ì‹¤ ë“±ê¸‰(1=ìƒ,2=ì¤‘,3=í•˜) | ì •ìˆ˜ | ê±°ì˜ ì—†ìŒ |
| Name | ì´ë¦„ (í˜¸ì¹­ í¬í•¨: Mr/Mrs/Miss/Master/â€¦) | ë¬¸ìì—´ | â€” |
| Sex | ì„±ë³„ | male/female | â€” |
| Age | ë‚˜ì´ | ì‹¤ìˆ˜ | **ë§ìŒ** |
| SibSp | í•¨ê»˜ íƒ‘ìŠ¹í•œ í˜•ì œ/ë°°ìš°ì ìˆ˜ | ì •ìˆ˜ | â€” |
| Parch | í•¨ê»˜ íƒ‘ìŠ¹í•œ ë¶€ëª¨/ìë…€ ìˆ˜ | ì •ìˆ˜ | â€” |
| Ticket | í‹°ì¼“ ë²ˆí˜¸ | ë¬¸ìì—´ | â€” |
| Fare | ìš´ì„ | ì‹¤ìˆ˜ | ì¼ë¶€ |
| Cabin | ê°ì‹¤ ë²ˆí˜¸ (ë± ê¸€ì + í˜¸ìˆ˜) | ë¬¸ìì—´ | **ëŒ€ë¶€ë¶„ ê²°ì¸¡** |
| Embarked | íƒ‘ìŠ¹ í•­ | C/Q/S | ì†Œìˆ˜ |

> **ë ˆì´ë¸” ë¶ˆê· í˜•**: ëŒ€ëµ ìƒì¡´ 38%, ì‚¬ë§ 62% ìˆ˜ì¤€ìœ¼ë¡œ ì•½í•œ ë¶ˆê· í˜•.

---

## 2) ë¬¸ì œ ì •ì˜ì™€ í‰ê°€ ì§€í‘œ

- ë¬¸ì œ: **Binary Classification**
- ì¶”ì²œ ì§€í‘œ: `Accuracy`, `F1`, `ROC-AUC` (ë¦¬ë”ë³´ë“œ ì œì¶œì€ ë³´í†µ Accuracy/ì •í™•ë„ì´ì§€ë§Œ ë‚´ë¶€ ê²€ì¦ì—ì„  F1/ROC-AUCë¥¼ í•¨ê»˜ ë³´ì„¸ìš”)
- ê²€ì¦: **Stratified K-Fold** ë˜ëŠ” **Train/Validation split + êµì°¨ê²€ì¦**

---

## 3) ì „ì²˜ë¦¬ & íŠ¹ì§• ì—”ì§€ë‹ˆì–´ë§ (Feature Engineering)

### 3.1 ê²°ì¸¡ì¹˜ ì²˜ë¦¬
- **Age**: ì¤‘ì•™ê°’/íšŒê·€ë¡œ ë³´ê°„(ê°„ë‹¨íˆëŠ” **ì¤‘ì•™ê°’**)
- **Fare**: ì¤‘ì•™ê°’
- **Embarked**: ìµœë¹ˆê°’
- **Cabin**: ëŒ€ë¶€ë¶„ ë¹„ì–´ìˆìŒ â†’ **ë± ë¬¸ìë§Œ ì¶”ì¶œ**(ì²« ê¸€ì) í›„ ê²°ì¸¡ì„ â€˜Uâ€™(Unknown)ë¡œ

### 3.2 ë²”ì£¼í˜• ì¸ì½”ë”©
- **Sex, Pclass, Embarked, Title, CabinDeck, IsAlone** â†’ **One-Hot Encoding**
- íŠ¸ë¦¬ ê¸°ë°˜ ëª¨ë¸ì€ ì›í•«/ìˆœìœ„ ì¸ì½”ë”© ëª¨ë‘ ê°€ëŠ¥í•˜ë‚˜, **íŒŒì´í”„ë¼ì¸ ì¼ê´€ì„±**ì„ ìœ„í•´ ì›í•« ì¶”ì²œ

### 3.3 ì¶”ì²œ íŒŒìƒ ë³€ìˆ˜
- **Title**: `Name`ì—ì„œ í˜¸ì¹­ ì¶”ì¶œ â†’ `{'Mr','Mrs','Miss','Master','Rare'}`ë¡œ ë¬¶ê¸°  
- **FamilySize**: `SibSp + Parch + 1`  
- **IsAlone**: `(FamilySize == 1)`  
- **CabinDeck**: `Cabin` ì²« ë¬¸ì(â€˜Aâ€™~â€˜Gâ€™), ê²°ì¸¡ì€ â€˜Uâ€™

> **ì£¼ì˜: ë°ì´í„° ëˆ„ìˆ˜ ë°©ì§€**  
> í‹°ì¼“ ê·¸ë£¹ í¬ê¸° ë“± **ì „ ë°ì´í„° í†µê³„ê°€ í•„ìš”í•œ íŒŒìƒë³€ìˆ˜**ëŠ” êµì°¨ê²€ì¦ í´ë“œ ì•ˆì—ì„œ ê³„ì‚°í•˜ì„¸ìš”(íŒŒì´í”„ë¼ì¸ ë‚´ë¶€ ì»¤ìŠ¤í…€ ë³€í™˜ê¸°ë¡œ ì²˜ë¦¬).

---

## 4) ë² ì´ìŠ¤ë¼ì¸ íŒŒì´í”„ë¼ì¸ ì„¤ê³„

- **ColumnTransformer + Pipeline** ìœ¼ë¡œ ì „ì²˜ë¦¬Â·ëª¨ë¸ì„ í•˜ë‚˜ë¡œ ë¬¶ê¸°  
- ìˆ˜ì¹˜í˜•ì€ **ì¤‘ì•™ê°’ ëŒ€ì¹˜ + (ì„ í˜•ëª¨ë¸ìš©) ìŠ¤ì¼€ì¼ë§**  
- ë²”ì£¼í˜•ì€ **ìµœë¹ˆ ëŒ€ì¹˜ + OneHotEncoder(handle_unknown='ignore')**  
- ëª¨ë¸: **Logistic Regression**, **Random Forest**, **HistGradientBoosting**(scikit-learn) ë¹„êµ

```python
# !pip install scikit-learn pandas numpy

import re
import numpy as np
import pandas as pd

from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.model_selection import StratifiedKFold, cross_validate
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.impute import SimpleImputer

from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, HistGradientBoostingClassifier

# ---------- 1) ë°ì´í„° ë¡œë“œ ----------
train = pd.read_csv("train.csv")  # Kaggle í˜•ì‹ ê°€ì • (Survived í¬í•¨)
# test = pd.read_csv("test.csv")  # ìµœì¢… ì œì¶œìš©(ì˜µì…˜)

# ---------- 2) ì»¤ìŠ¤í…€ ë³€í™˜ê¸°: íŒŒìƒë³€ìˆ˜ ----------
class TitanicFeatureBuilder(BaseEstimator, TransformerMixin):
    def __init__(self):
        self.title_map_ = None
    def fit(self, X, y=None):
        # Title ë¹ˆë„ ê¸°ë°˜ rare ì²˜ë¦¬ìš© ë§µ ìƒì„± (fit ë°ì´í„°ì—ì„œë§Œ)
        titles = X["Name"].str.extract(r",\s*([^\.]+)\.")[0].str.strip()
        titles = titles.replace({
            "Mlle":"Miss", "Ms":"Miss", "Mme":"Mrs", "Lady":"Rare", "the Countess":"Rare",
            "Capt":"Rare", "Col":"Rare", "Don":"Rare", "Dr":"Rare", "Major":"Rare",
            "Rev":"Rare", "Sir":"Rare", "Jonkheer":"Rare", "Dona":"Rare"
        })
        # ì£¼ëœ íƒ€ì´í‹€ë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ëŠ” Rare (Optional: ë¹ˆë„ ê¸°ì¤€  <15 ë“±)
        common = {"Mr","Mrs","Miss","Master"}
        self.title_map_ = titles.apply(lambda t: t if t in common else "Rare").value_counts().index.tolist()
        return self
    def transform(self, X):
        X = X.copy()
        # Title
        titles = X["Name"].str.extract(r",\s*([^\.]+)\.")[0].str.strip()
        titles = titles.replace({
            "Mlle":"Miss", "Ms":"Miss", "Mme":"Mrs", "Lady":"Rare", "the Countess":"Rare",
            "Capt":"Rare", "Col":"Rare", "Don":"Rare", "Dr":"Rare", "Major":"Rare",
            "Rev":"Rare", "Sir":"Rare", "Jonkheer":"Rare", "Dona":"Rare"
        })
        X["Title"] = titles.apply(lambda t: t if t in {"Mr","Mrs","Miss","Master"} else "Rare")
        # Family features
        X["FamilySize"] = X["SibSp"] + X["Parch"] + 1
        X["IsAlone"]    = (X["FamilySize"] == 1).astype(int)
        # Cabin deck
        X["CabinDeck"]  = X["Cabin"].astype(str).str[0]
        X["CabinDeck"]  = X["CabinDeck"].replace({np.nan:"U", "n":"U"})
        X.loc[X["CabinDeck"].isin(["N","n"]), "CabinDeck"] = "U"
        # Pclassë¥¼ ë²”ì£¼í˜•ìœ¼ë¡œ ì·¨ê¸‰
        X["Pclass"] = X["Pclass"].astype("category")
        return X[[
            "Pclass","Sex","Age","SibSp","Parch","Fare","Embarked",
            "Title","FamilySize","IsAlone","CabinDeck"
        ]]

# ---------- 3) ì „ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ ----------
num_cols  = ["Age","SibSp","Parch","Fare","FamilySize"]
cat_cols  = ["Pclass","Sex","Embarked","Title","IsAlone","CabinDeck"]

numeric_pipe = Pipeline([
    ("imputer", SimpleImputer(strategy="median")),
    ("scaler",  StandardScaler())  # ë¡œì§€ìŠ¤í‹± ë“± ì„ í˜• ëª¨ë¸ì— ìœ ë¦¬
])

categorical_pipe = Pipeline([
    ("imputer", SimpleImputer(strategy="most_frequent")),
    ("ohe",     OneHotEncoder(handle_unknown="ignore"))
])

preprocess = ColumnTransformer([
    ("num", numeric_pipe, num_cols),
    ("cat", categorical_pipe, cat_cols)
])

# ---------- 4) ì „ì²´ íŒŒì´í”„ë¼ì¸ + ëª¨ë¸ ----------
X = train.drop(columns=["Survived"])
y = train["Survived"]

def evaluate_model(model, X, y, name):
    pipe = Pipeline([
        ("feat", TitanicFeatureBuilder()),
        ("prep", preprocess),
        ("clf",  model)
    ])
    cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
    scores = cross_validate(
        pipe, X, y, cv=cv, n_jobs=-1,
        scoring=["accuracy","f1","roc_auc"]
    )
    print(f"[{name}] ACC: {scores['test_accuracy'].mean():.3f} Â± {scores['test_accuracy'].std():.3f} | "
          f"F1: {scores['test_f1'].mean():.3f} Â± {scores['test_f1'].std():.3f} | "
          f"AUC: {scores['test_roc_auc'].mean():.3f} Â± {scores['test_roc_auc'].std():.3f}")

evaluate_model(LogisticRegression(max_iter=2000, class_weight=None), X, y, "LogReg")
evaluate_model(RandomForestClassifier(n_estimators=400, max_depth=None, random_state=42), X, y, "RandomForest")
evaluate_model(HistGradientBoostingClassifier(max_depth=None, learning_rate=0.08, random_state=42), X, y, "HGB")
```

> **ì„¤ëª…**
> - `TitanicFeatureBuilder`ëŠ” **êµì°¨ê²€ì¦ì˜ ê° í•™ìŠµ í´ë“œì—ì„œë§Œ** Title í†µê³„ë¥¼ í•™ìŠµ â†’ **ëˆ„ìˆ˜ ë°©ì§€**  
> - `ColumnTransformer`ë¡œ ìˆ˜ì¹˜/ë²”ì£¼í˜• **ë™ì‹œì—** ì²˜ë¦¬ â†’ ì¶”í›„ ì¶”ë¡  ì‹œ ë™ì¼ ê·œì¹™ ì ìš©

---

## 5) í•˜ì´í¼íŒŒë¼ë¯¸í„° íŠœë‹ (RandomizedSearch ì˜ˆ)

```python
from sklearn.model_selection import RandomizedSearchCV
from scipy.stats import randint, uniform

rf = Pipeline([
    ("feat", TitanicFeatureBuilder()),
    ("prep", preprocess),
    ("clf",  RandomForestClassifier(random_state=42))
])

param_dist = {
    "clf__n_estimators": randint(300, 1000),
    "clf__max_depth": randint(3, 20),
    "clf__min_samples_split": randint(2, 20),
    "clf__min_samples_leaf": randint(1, 10),
    "clf__max_features": ["sqrt","log2", None]
}

rs = RandomizedSearchCV(
    rf, param_distributions=param_dist, n_iter=60, cv=5,
    scoring="roc_auc", n_jobs=-1, random_state=42
)
rs.fit(X, y)
print("Best AUC:", rs.best_score_)
print("Best params:", rs.best_params_)
best_model = rs.best_estimator_
```

> **íŒ**:  
> - ì„ í˜• ëª¨ë¸(ë¡œì§€ìŠ¤í‹±)ì€ `class_weight='balanced'`ë¥¼ ì‹œë„í•´ë³´ì„¸ìš”.  
> - ë¶€ìŠ¤íŒ…ë¥˜(HGB, XGBoost, LightGBM)ëŠ” `learning_rate` â†“, `n_estimators` â†‘ë¡œ ë¯¸ì„¸ ì¡°ì •.

---

## 6) ì¤‘ìš”ë„/í•´ì„(Feature Importance)

íŠ¸ë¦¬ ê¸°ë°˜ ëª¨ë¸ì€ `feature_importances_` ì œê³µ. One-Hot ì´í›„ ì»¬ëŸ¼ëª…ì€ ì¸ì½”ë”ì—ì„œ ê°€ì ¸ì˜µë‹ˆë‹¤.

```python
# íŒŒì´í”„ë¼ì¸ì—ì„œ OHE ì´í›„ì˜ ì‹¤ì œ í”¼ì²˜ ì´ë¦„ ì¶”ì¶œ
ohe = best_model.named_steps["prep"].named_transformers_["cat"].named_steps["ohe"]
cat_names = ohe.get_feature_names_out(cat_cols)
final_feature_names = np.r_[num_cols, cat_names]  # ColumnTransformer ìˆœì„œì— ë§ì¶° êµ¬ì„±

clf = best_model.named_steps["clf"]
importances = getattr(clf, "feature_importances_", None)
if importances is not None:
    imp = pd.Series(importances, index=final_feature_names).sort_values(ascending=False)
    print(imp.head(15))
```

> **ì˜ë¯¸ ìˆëŠ” ì‹ í˜¸(ê²½í—˜ì )**: `Sex`, `Pclass`, `Title`, `Age`, `Fare`, `FamilySize`, `IsAlone`, `Embarked`, `CabinDeck(U/ìƒìœ„ë±)` ë“±

---

## 7) ìµœì¢… ì˜ˆì¸¡ & ì œì¶œ íŒŒì¼ ìƒì„± (ì„ íƒ)

```python
# train ì „ì²´ë¡œ ì¬í•™ìŠµ í›„ test ì˜ˆì¸¡
# test = pd.read_csv("test.csv")
best_model.fit(X, y)
# preds = best_model.predict(test)                 # 0/1
# ë˜ëŠ” í™•ë¥  ê¸°ì¤€ ì„ê³„ê°’ ì¡°ì •:
# proba = best_model.predict_proba(test)[:,1]
# preds = (proba >= 0.5).astype(int)

# submission = pd.DataFrame({"PassengerId": test["PassengerId"], "Survived": preds})
# submission.to_csv("submission.csv", index=False)
```

> **ì„ê³„ê°’ íŠœë‹**: ë‚´ë¶€ ê²€ì¦ì—ì„œ **F1/Recall/Precision** ê· í˜•ì„ ë³´ê³  `0.45`/`0.55` ë“± **ì—…ë¬´ ëª©ì ì— ë§ëŠ” ì„ê³„ê°’**ì„ ì„ íƒí•˜ì„¸ìš”.

---

## 8) ì„±ëŠ¥ì„ ë” ëŒì–´ì˜¬ë¦¬ëŠ” íŒ

- **êµì°¨ê²€ì¦**: `StratifiedKFold(n_splits=5~10)`  
- **íŠ¹ì§• ê°•í™”**:  
  - ì—°ë ¹ëŒ€ binning(Child/Adult/Senior), ìš´ì„ log ë³€í™˜/êµ¬ê°„í™”  
  - ìƒí˜¸ì‘ìš©: `Pclass Ã— Sex`, `Title Ã— Pclass`  
- **ê·œì œ**: ë¡œì§€ìŠ¤í‹±ì˜ `C` íŠœë‹, íŠ¸ë¦¬ì˜ `max_depth/min_samples_*`  
- **ì•™ìƒë¸”**: ì„œë¡œ ë‹¤ë¥¸ ëª¨ë¸ì˜ **í™•ë¥  í‰ê· /ìŠ¤íƒœí‚¹**  
- **ë°ì´í„° ëˆ„ìˆ˜ ê¸ˆì§€**: ëª¨ë“  ì „ì²˜ë¦¬ëŠ” **í•™ìŠµ í´ë“œì—ì„œ fit â†’ ê²€ì¦/í…ŒìŠ¤íŠ¸ì— transformë§Œ**  
- **ì¬í˜„ì„±**: ì‹œë“œ ê³ ì •, í™˜ê²½/ë²„ì „ ê¸°ë¡

---

## 9) ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] íŒŒì´í”„ë¼ì¸ ë‚´ë¶€ì—ì„œ ê²°ì¸¡Â·ì¸ì½”ë”©Â·ìŠ¤ì¼€ì¼ë§ ìˆ˜í–‰  
- [ ] Stratified K-Foldë¡œ ê²€ì¦  
- [ ] ì í•©í•œ ì§€í‘œ(F1/ROC-AUC)ì™€ ì„ê³„ê°’ ì„¤ì •  
- [ ] í•˜ì´í¼íŒŒë¼ë¯¸í„° íƒìƒ‰(Random/Optuna)  
- [ ] í”¼ì²˜ ì¤‘ìš”ë„/ì—ëŸ¬ ì¼€ì´ìŠ¤ ë¶„ì„(ì˜¤ë¶„ë¥˜ ìƒ˜í”Œ í™•ì¸)  
- [ ] ìµœì¢… ëª¨ë¸ì€ **Train ì „ëŸ‰**ìœ¼ë¡œ ì¬í•™ìŠµ í›„ ì œì¶œ

---

### âœ… ì •ë¦¬
- íƒ€ì´íƒ€ë‹‰ì€ **ê¸°ë³¸ê¸° ì´ì •ë¦¬**ì— ìµœì ì¸ ì´ì§„ ë¶„ë¥˜ ë¬¸ì œ.  
- **íŒŒìƒë³€ìˆ˜(Title/Family/Deck)** + **ê²¬ê³ í•œ ì „ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸** + **ì ì ˆí•œ ê²€ì¦/íŠœë‹**ë§Œìœ¼ë¡œë„ **ê°•í•œ ë² ì´ìŠ¤ë¼ì¸**ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
- ê·¸ ìœ„ì— **ë¶€ìŠ¤íŒ…Â·ì•™ìƒë¸”Â·ì„ê³„ê°’ ìµœì í™”**ë¥¼ ì–¹ì–´ ì ì§„ì ìœ¼ë¡œ ì„±ëŠ¥ì„ ê°œì„ í•˜ì„¸ìš”.