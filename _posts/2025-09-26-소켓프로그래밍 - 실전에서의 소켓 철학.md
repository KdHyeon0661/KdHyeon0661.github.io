---
layout: post
title: 소켓프로그래밍 - 실전에서의 소켓 철학
date: 2025-09-26 21:25:23 +0900
category: 소켓프로그래밍
---
## 마무리 — **실전에서의 소켓 철학**

> 문장 하나로 요약하면:
> **“단순함(블로킹)에서 출발 → 관측/지표로 병목을 확인 → 필요한 만큼만 복잡성(epoll/스레드/zero-copy)을 추가하라.”**
> 이 장은 지금까지 만든 조각들을 **운영 관점**에서 연결하고, **업그레이드 기준**과 **다음 학습 경로**(HTTP/2, QUIC, gRPC)를 제시한다.

---

### + 관측**

“**빨리 동작하는** 것”보다 **“문제가 나면 어디가 아픈지 보이는”** 것이 먼저다.
초기 버전은 다음 4가지만 지키면 충분하다.

1) **블로킹 서버**(accept, read/write 루프)
2) **명확한 에러 모델**(반복·종료·로그 수준)
3) **타임아웃**(연결/읽기/쓰기), **백프레셔**(부분 쓰기)
4) **관측**(QPS, 처리량, 지연, 큐 길이, 에러 카운터)

#### 블로킹 서버 뼈대

```cpp
// blocking_echo_min.cpp (요지) - C++23 / 리눅스
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <array>
#include <chrono>
#include <cstdio>
#include <cstdint>

int main() {
  addrinfo hints{}, *res=nullptr;
  hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG;
  getaddrinfo(nullptr,"9000",&hints,&res);
  int lfd=-1;
  for(auto*ai=res;ai;ai=ai->ai_next){
    lfd=::socket(ai->ai_family,ai->ai_socktype,ai->ai_protocol);
    if(lfd<0) continue;
    int yes=1; setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(yes));
    if(::bind(lfd,ai->ai_addr,ai->ai_addrlen)==0 && ::listen(lfd,1024)==0) break;
    ::close(lfd); lfd=-1;
  }
  freeaddrinfo(res);
  if(lfd<0){ std::perror("listen"); return 1; }

  for(;;){
    int c=::accept(lfd,nullptr,nullptr);
    if(c<0){ if(errno==EINTR) continue; std::perror("accept"); break; }
    // 타임아웃(예: 10초)
    timeval tv{.tv_sec=10,.tv_usec=0};
    setsockopt(c,SOL_SOCKET,SO_RCVTIMEO,&tv,sizeof(tv));
    setsockopt(c,SOL_SOCKET,SO_SNDTIMEO,&tv,sizeof(tv));

    std::array<char,8192> buf{};
    for(;;){
      ssize_t n=::recv(c,buf.data(),buf.size(),0);
      if(n>0){
        ssize_t off=0;
        while(off<n){ // 부분 쓰기 대응
          ssize_t m=::send(c,buf.data()+off,n-off,0);
          if(m>0){ off+=m; continue; }
          if(m==0) continue;
          if(errno==EINTR) continue;
          std::perror("send"); goto done;
        }
        continue;
      }
      if(n==0) break;               // peer 정상 종료
      if(errno==EINTR) continue;
      if(errno==EAGAIN||errno==EWOULDBLOCK){ std::fprintf(stderr,"timeout\n"); break; }
      std::perror("recv"); break;
    }
   done:
    ::close(c);
  }
}
```

- **부분 쓰기 루프**: 스트림은 경계가 없으므로 `send()`가 일부만 보낼 수 있다.
- **타임아웃**: 타임아웃은 **정책**이다. 읽기/쓰기/연결을 분리해 시간 상한을 준다(12장).
- **로그**는 **사건**만 남긴다(예: 타임아웃, 예외 종료). 정상 흐름은 **계량화**(카운터/히스토그램)로 본다.

#### — 없으면 디버깅도 없다

- **요청율**(QPS), **평균/분위수 지연**(p50/p95/p99), **처리량**(bytes/s)
- **소켓 에러율**(ECONNRESET, ETIMEDOUT, EPIPE), **CLOSE_WAIT/TIME_WAIT** 갯수
- **커널 큐 길이**(SendQ/RecvQ) — `ss -ti` / `/proc/net/tcp`
- **애플리케이션 큐**(프레임 파서 대기, 작업 큐) 길이

작은 **계량기**부터 붙여보자.

```cpp
// metrics.hpp (요지)
#pragma once
#include <atomic>
#include <array>
#include <chrono>

struct Counter { std::atomic<uint64_t> v{0}; void inc(uint64_t x=1){ v.fetch_add(x, std::memory_order_relaxed);} };
struct Gauge   { std::atomic<int64_t> v{0}; void set(int64_t x){ v.store(x, std::memory_order_relaxed);} };
struct HdrLite {
  // 초간단 고정 버킷(로그 스케일) 히스토그램
  static constexpr int B=20; std::array<std::atomic<uint64_t>,B> b{};
  void observe_us(uint64_t us){
    int i = (us==0?0: std::min<int>(B-1, 63-__builtin_clzll(us)));
    b[i].fetch_add(1, std::memory_order_relaxed);
  }
};
```

HTTP나 Prometheus 없이도 **파일에 주기적으로 덤프**하면 충분히 문제를 좁힐 수 있다.

---

### **관측으로 병목을 찾고** 움직인다

#### 체크 순서(현장용 7단계)

1) **시스템 부하**: CPU(usr/sys), run queue, steal
2) **NIC/네트워크**: RX/TX drop, re-trans, MTU/세그오프로드
3) **커널 소켓 큐**: `ss -ti`로 Recv-Q/Send-Q, **RTT**, **cwnd**
4) **애플리케이션 큐**: 프레임 파서 대기, 워커 대기
5) **락/경합**: perf/flamegraph, mutex hot spot
6) **디스크/IO**: iowait, fsync 지연
7) **외부 의존성**: DB/캐시 호출 지연

> 규칙: **각 계층의 큐**가 늘어나면 그 앞 단계가 병목이다.

#### 기본 도구 레시피

- **패킷/흐름**: `tcpdump -i eth0 port 9000 -n -vv` / Wireshark
- **소켓**: `ss -ti '( sport = :9000 )'` → RTT, reordering, retrans
- **시스템 호출**: `strace -f -tt -e trace=network -p <pid>`
- **CPU/락**: `perf top`, `perf record`, flamegraph

---

### **복잡성 추가의 기준** — 언제 epoll/스레드/ET가 필요한가

초기 블로킹 모델은 **간결**하지만, 다음 신호가 보이면 **복잡성**을 투입한다.

- 단일(혹은 소수) 스레드로 **CPU가 70%+** → **스레드/코어 확장**
- 동시 연결 수 **수천+** → **epoll**
- **소켓 1개가 bursty**(데이터가 몰렸다 빠지는) → **엣지 트리거(ET)** + “**버퍼 소진 루프**”
- **컨텍스트 스위칭/락 경합** 증가 → **1 이벤트 루프 + 워커 풀**(11장)

#### 의사결정 트리(간단)

```
[QPS 낮음] ────[연결 수 < 1k]──▶ 블로킹, 스레드(핸들러 1개)
              └─[연결 수 1k~10k]▶ epoll(LEVEL) + 버퍼 소진
                  └─[스파이크 심함]▶ epoll(ET) + 전용 링버퍼/풀
                      └─[코어 다수]▶ SO_REUSEPORT + 코어별 리스너
```

#### 업그레이드의 최소 차이

- **논블로킹 소켓** + `epoll_wait`
- 이벤트가 오면 **read()를 EAGAIN까지 루프** (레벨 트리거라도 **소진** 관점이 좋다)

```cpp
// level_epoll_read.cpp (요지)
for(;;){
  int n = epoll_wait(ep, evs, MAX, 1000);
  for(int i=0;i<n;i++){
    int fd=evs[i].data.fd; uint32_t e=evs[i].events;
    if(e&EPOLLIN){
      for(;;){
        ssize_t m=::recv(fd, buf, sizeof(buf), 0);
        if(m>0){ parser.feed(buf,m); continue; }
        if(m==0){ close(fd); break; }
        if(errno==EAGAIN||errno==EWOULDBLOCK) break;
        // 에러 처리
      }
    }
  }
}
```

#### epoll(ET)의 **버퍼 소진 루프** 정석

- ET는 **알림이 드물다**. 알림 1회에 **recv/send를 바닥까지** 뽑아야 **스톨**이 없다.
- **원칙**: `EAGAIN`이 나올 때까지 `recv()`/`send()` 루프.

---

### **안정성**: 오류 모델 / 타임아웃 / 재시도

#### 표준 에러 맵 (요지)

- `EINTR`: **다시 시도**
- `EAGAIN/EWOULDBLOCK`: **지금 안 됨**(논블로킹) → **다시 등록/기다림**
- `ECONNRESET`: peer가 RST → **정상적인 종료 범주**로 카운트
- `ETIMEDOUT`: 네트워크 타임아웃(커널/소켓 옵션)
- `EPIPE`(+SIGPIPE): 쓰기 대상이 닫힘 → **SIGPIPE 무시** 권장

#### 타임아웃 정책(패턴)

- **연결 타임아웃**: `connect()`에 deadline
- **읽기/쓰기 타임아웃**: **데드라인 기반**으로, **조각 진행**이 있으면 **시한 갱신**
- **유휴(keepalive)**: 장시간 조용한 연결 → OS keepalive + **애플리케이션 ping** 조합
- **재시도**: 멱등 작업만. 백오프는
  $$
  \text{backoff}(k)=\min(t_{\max}, t_0\cdot 2^k)
  $$
  (12장)

#### — 데드라인 I/O

```cpp
// deadline_io.hpp (요지)
#include <poll.h>
#include <chrono>

struct Deadline{
  using clock=std::chrono::steady_clock; clock::time_point tp;
  static Deadline after_ms(int ms){ return {clock::now()+std::chrono::milliseconds(ms)}; }
  int ms() const{ auto d=std::chrono::duration_cast<std::chrono::milliseconds>(tp-clock::now()); return d.count()<0?0:(int)d.count(); }
};
inline bool wait_readable(int fd, Deadline dl){ pollfd p{fd,POLLIN,0}; int r=poll(&p,1,dl.ms()); return r>0 && (p.revents&(POLLIN|POLLHUP|POLLERR)); }
inline bool wait_writable(int fd, Deadline dl){ pollfd p{fd,POLLOUT,0}; int r=poll(&p,1,dl.ms()); return r>0 && (p.revents&(POLLOUT|POLLHUP|POLLERR)); }
```

---

### **성능**: 버퍼·프레이밍·coalescing의 균형

#### 직관: **대역폭–지연곱(BDP)**

RTT가 \( \text{RTT} \), 링크 대역이 \( \text{BW} \)일 때,
$$ \text{BDP} = \text{BW} \times \text{RTT} $$
소켓 송신 버퍼 + 애플리케이션 배치가 **BDP 수준**은 되어야 **채널 가득** 쓸 수 있다.

#### 프레이밍의 선택

- **길이-프리픽스(4B BE)**: 단순·고성능(5장). MTU/캡 정책 포함.
- **구분자 기반**: 로그/라인. 이스케이프/코드페이지 관리 필요.
- **TLV/헤더**: 버전/타입/길이/체크섬 → 확장성.

> 원칙: **수신 측 부담 최소**. 파서가 **연속 접근**하고 **copy를 줄이게** 설계.

#### 작은 메시지 vs `TCP_NODELAY`

- 요청/응답 쌍이 **작고 즉시성**이 필요 → `TCP_NODELAY=on`
- **배치**가 가능하고 지연이 조금 허용 → **coalescing**(Nagle 허용)
- 실험으로 결정: p99 지연과 QPS/CPU를 비교.

#### flush 정책 예시

```cpp
// small_msg_flush.cpp (요지)
struct OutBuf {
  std::vector<char> buf; std::chrono::steady_clock::time_point next_flush{};
  void enqueue(std::string_view m){
    // 길이-프리픽스
    uint32_t be=htonl((uint32_t)m.size());
    buf.insert(buf.end(), (char*)&be, ((char*)&be)+4);
    buf.insert(buf.end(), m.begin(), m.end());
    if(buf.size() > 32*1024) flush();
    else if(std::chrono::steady_clock::now() >= next_flush) flush();
  }
  void flush(){ /* send() 루프; 실패 시 부분만 제거 */ next_flush=std::chrono::steady_clock::now()+std::chrono::milliseconds(2); }
};
```

---

### 운영 체크리스트

#### 소켓/시스템 튜닝(요지)

- `ulimit -n`(fd 한도), `somaxconn`(백로그), `net.ipv4.ip_local_port_range`
- `tcp_tw_reuse/tw_recycle`(신중), `tcp_fin_timeout`
- `rmem_default/rmem_max`, `wmem_default/wmem_max`
- **핵심**: 변경 전/후 **지표 비교** 없이는 튜닝 금지.

#### 릴리즈/배포

- **graceful** 종료: `SIGTERM` → 리스너 중단 → 진행 중 처리 후 종료
- **건강 체크**(정적 응답 + 내부 상태 점검)
- **카나리**: 소량 트래픽만 신버전으로 보내 **지표**를 본다.

#### 보안/신뢰성

- **TLS**(14장): 전송 암호화 + 인증서 순환 계획
- **입력 검증**: 프레임 cap, JSON 스키마, 압축 폭주 보호
- **레이트 리밋**/코넥션 상한/아이들 킵얼라이브
- **로그**: PII 최소화, **샘플링**(고QPS 시스템)

---

### “다음 학습 경로” 로드맵 — HTTP/2, QUIC, gRPC, RPC

이제 **소켓 감각**을 상위 프로토콜로 올린다.

#### HTTP/1.1 → HTTP/2

- HTTP/2는 **하나의 TCP 연결** 위에 **다중 스트림**과 **헤더 압축(HPACK)**.
- **HOL(Head-of-Line) 블로킹**은 TCP 레벨에서 여전(손실 시 전체 스트림 지연).
- 우리의 **프레이밍 길이-프리픽스 + 상태머신** 감각이 **프레임/스트림 관리**로 직결된다.

**매핑 감각**
- “연결” = TCP
- “스트림” = 길이-프리픽스 단위의 **서브 채널**
- “윈도” = 흐름 제어(스트림/연결 레벨 크레딧)

#### — HTTP/3의 기반

- QUIC은 **UDP 위**에서 **암호화·핸드셰이크·재전송**까지 **유저 공간**(라이브러리)이 처리.
- **스트림별 독립적인 전달**(손실이 한 스트림에만 영향) → **HOL 완화**.
- **패킷 수명/키 로테이션** 등이 있어 **타이밍·타이머** 감각(12장)이 중요.

**수학 메모(대역 효율)**
손실률 \(p\)에서 TCP 류 처리량 근사:
$$ \text{Throughput} \approx \frac{\text{MSS}}{\text{RTT}\sqrt{p}} $$
QUIC도 **혼잡 제어**는 유사(쿠베른/BBR 등). **패킷 수식** 감각은 그대로 유효.

#### gRPC / RPC 프레임워크

- gRPC는 **HTTP/2 스트림** 위에 **프로토콜 버퍼**(바이너리 스키마)와 **메소드 호출/리트라이** 정책을 제공.
- 우리가 만든 **TLV/길이-프리픽스** → **Protobuf 프레이밍**으로 자연스레 매핑.
- **멱등성/재시도/타임아웃** 규율(12장)이 **RPC Semantics**와 그대로 연결.

#### “지금 당장 만들 수 있는” 토이 RPC 스케치

- 요청 헤더: `{version=1, method_id, req_id, len}`
- 응답 헤더: `{req_id, status, len}`
- **재시도**: `status=timeout`일 때만, **멱등 메소드**만

```cpp
// toy_rpc.hpp (요지): 길이-프리픽스 기반
struct ReqHdr { uint16_t ver, mid; uint32_t reqid, len; /* BE */ };
struct RspHdr { uint32_t reqid; uint16_t status; uint32_t len; /* BE */ };
// send_all / recv_exact 재사용
```

---

## “**진짜** 현장에서”의 업그레이드 플레이북

1) **블로킹** 버전으로 **정확성**과 **관측** 확보
2) **부하**를 단계적으로 올려 **병목 위치**를 계측
3) **에코/프레이밍** 경계에서 **부분 입출력**/타임아웃 버그 제거
4) **레벨 epoll**로 전환, **버퍼 소진 루프**를 도입
5) **엣지(ET)** + **코어별 리스너(SO_REUSEPORT)** + **워커** 투입
6) 파일/디스크 IO와 **zero-copy(sendfile, splice, writev)** 적용(16장)
7) TLS, 인증·인가, 라우팅·LB와 통합
8) 필요 시 **HTTP/2/3(gRPC/QUIC)** 채택 — “직접 빌드 vs 프레임워크” 비교

---

## 부록 — 30분 하드닝 레시피(샘플)

- **systemd** Unit 스니펫:
```ini
[Service]
LimitNOFILE=262144
Restart=always
RestartSec=1
AmbientCapabilities=CAP_NET_BIND_SERVICE
NoNewPrivileges=true
```

- **sysctl**(보수적으로 시작):
```bash
sysctl -w net.core.somaxconn=4096
sysctl -w net.ipv4.ip_local_port_range="20000 65000"
sysctl -w net.core.rmem_max=4194304
sysctl -w net.core.wmem_max=4194304
```

- **헬스 체크**: `/healthz`에서 내부 카운터 몇 개와 “OK”
- **로그**: 타임아웃/에러는 **샘플링 1%**로 스택 포함, 성공 경로는 **카운터만**
- **롤링**: 카나리 5% → 50% → 100% (지표 임계값 만족 시 확장)

---

## 핵심 원칙(정리)

- **단순함 우선**: 블로킹부터. 가독성/디버깅이 첫째다.
- **관측 주도**: 추측 금지. 숫자로 본다.
- **부분 I/O·타임아웃·백프레셔**: 스트림의 본질을 받아들여라.
- **필요 최소한의 복잡성**: epoll/스레드/ET/zero-copy는 **증상**이 있을 때만.
- **프로토콜 감각을 보존**: 프레이밍·타임아웃·재시도 원칙은 HTTP/2/QUIC/gRPC에서도 **그대로** 통한다.

> 이 장을 덮고 나면, “**어떤 트래픽**이 와도 **어디부터 고쳐야 할지**” 감이 온다.
> 그 감각이 바로 **저수준 소켓의 실전 철학**이다 — **측정하고, 단순하게, 필요한 만큼만 복잡하게.**
