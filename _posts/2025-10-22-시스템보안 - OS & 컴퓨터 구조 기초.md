---
layout: post
title: 시스템보안 - OS & 컴퓨터 구조 기초
date: 2025-10-22 14:30:23 +0900
category: 시스템보안
---
# OS & 컴퓨터 구조 기초 — 시스템 해킹을 위한 “바닥” 이해

> 목표: 보안/익스플로잇/포렌식 관점에서 **운영체제의 핵심 레이어**를 실습과 함께 이해합니다.
> 원칙: **재현 가능**(모든 명령/코드는 로컬 랩·Host-only 네트워크에서), **최소 침해**(더미 데이터만), **빠른 롤백**(스냅샷).

---

## 프로세스 / 스레드 / 스케줄러 / 메모리 관리 개요

### 프로세스와 스레드 — “자원” vs “실행 흐름”

- **프로세스(Process)**: 독립적인 **주소 공간**(코드/데이터/스택/힙)과 **핸들/파일 디스크립터**를 갖는 실행 단위.
- **스레드(Thread)**: 프로세스 안의 **실행 흐름**; **코드·데이터·파일 디스크립터**는 **공유**, **스택/레지스터**는 **개별**.
- 보안 포인트: **경계는 프로세스 단위**로 강함(주소공간 격리), 스레드는 약함(메모리 공유 → 경쟁조건/TOCTOU/데드락).

#### 간단 실습 — `fork`, `exec`, `pthread`

```c
// demo_proc_thread.c: 빌드: gcc -O2 -pthread demo_proc_thread.c -o demo
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <pthread.h>

void* worker(void* arg){
    printf("[T] thread id=%lu, addr of local=%p\n", pthread_self(), &arg);
    return NULL;
}

int main(){
    printf("[P] parent pid=%d\n", getpid());
    if(!fork()){
        printf("[C] child pid=%d (before exec)\n", getpid());
        execlp("sh","sh","-c","echo [C] after exec: $$",NULL);
        _exit(127);
    }
    pthread_t th;
    pthread_create(&th,NULL,worker,NULL);
    pthread_join(th,NULL);
    wait(NULL);
    return 0;
}
```
- 관찰 포인트
  - `fork()`로 **주소 공간 복제(COW)** → `exec()`로 **새 프로그램 로드**
  - 스레드는 **PID(=TID)**/스택이 별도, **주소 공간은 공유**

#### 간단 실습 — 프로세스/스레드 생성

```c
// win_proc_thread.c — cl /O2 win_proc_thread.c
#include <windows.h>
#include <stdio.h>

DWORD WINAPI ThreadFunc(LPVOID p){ printf("[T] id=%lu\n", GetCurrentThreadId()); return 0; }
int main(){
  STARTUPINFOA si = { sizeof(si) };
  PROCESS_INFORMATION pi;
  CreateProcessA("C:\\Windows\\System32\\cmd.exe","/C echo [C] hello",NULL,NULL,FALSE,0,NULL,NULL,&si,&pi);
  HANDLE th = CreateThread(NULL,0,ThreadFunc,NULL,0,NULL);
  WaitForSingleObject(th,INFINITE);
  WaitForSingleObject(pi.hProcess,INFINITE);
  return 0;
}
```

---

### — “누구를 언제 CPU에 태울까”

- Linux: CFS(공정 스케줄러) + RT(우선순위 기반) + cgroup(자원 격리/제한).
- Windows: 우선순위 클래스(REALTIME/HIGH/NORMAL/IDLE) & quantum, I/O 바운드/CPU 바운드 힌트.
- 보안 포인트: **부하 유발/폭주**는 탐지/격리 대상(Throttle, CPU limit). **RT 우선순위 오남용**은 타 스레드 기아(starvation) 유발 가능.

#### 라이트한 스케줄링 관찰

```bash
# 프로세스/스레드 타임슬라이스/스케줄 정책

ps -eo pid,tid,psr,pri,rtprio,ni,cls,comm --sort=pid | head
# cgroup로 CPU 제한 실습 (컨테이너/랩에서)

echo $$ > /sys/fs/cgroup/cpu/demo/cgroup.procs
echo 100000 > /sys/fs/cgroup/cpu/demo/cpu.cfs_period_us
echo 20000  > /sys/fs/cgroup/cpu/demo/cpu.cfs_quota_us   # 20% 제한
```

---

### 메모리 관리 — 힙/스택/맵 영역, 할당자, 페이지

- **가상 메모리**: 각 프로세스는 0..N의 **논리 주소 공간**을 가짐 → MMU가 **페이지 단위(보통 4KB)**로 **물리**에 매핑.
- 영역: **텍스트(.text)**, **데이터(.data/.bss)**, **힙(malloc)**, **스택**, **맵 영역(mmap)**.
- 보안 포인트: **권한 비트**(R/W/X)로 **NX** 구현, 주소는 **ASLR**로 무작위화, 실행 파일은 **PIE**로 베이스 랜덤화.

#### `/proc/<pid>/maps`로 메모리 지도 훑기

```bash
./demo & pid=$!
cat /proc/$pid/maps | sed -n '1,15p'
gdb -q -p $pid -ex 'info proc mappings' -ex q
kill $pid
```

---

## 유저/커널 경계, 시스템 콜(System Call)과 ABI

### 유저/커널 경계 — Ring3 ↔ Ring0

- **유저모드(Ring3)**: 앱/라이브러리. **직접 하드웨어 접근 금지**.
- **커널모드(Ring0)**: 시스템 콜 핸들러, 드라이버, 스케줄러, VFS, 네트워크 스택.
- 전이 메커니즘: `syscall`(x86-64), `sysenter`(x86), `int 0x80`(구형), ARM의 SVC.

### 시스템 콜 경로 — glibc → VDSO → 커널

- 사용자 코드는 보통 **libc 래퍼** 호출 → 내부에서 레지스터 세팅 후 `syscall` → 커널이 **요청/검사/실행 → 결과** 반환.
- 보안 포인트: **파라미터 검증**은 커널에서 최종 수행, 유저측은 신뢰할 수 없음.

#### 시스템 콜을 직접 치기

```c
// raw_syscall.c — gcc -O2 raw_syscall.c -o raw && ./raw
#include <sys/syscall.h>
#include <unistd.h>
#include <stdint.h>
#include <stdio.h>

long my_getpid(){
    long ret;
    asm volatile("movq $39, %%rax; syscall;": "=a"(ret)::"rcx","r11","memory"); // 39=getpid
    return ret;
}
int main(){ printf("pid=%ld vs libc=%d\n", my_getpid(), getpid()); }
```
- **ABI 포인트**: SysV x86-64에서 시스템 콜은 `rax=번호`, `rdi,rsi,rdx,r10,r8,r9` 순으로 인자.

#### 시스템 콜은 어떻게?

- 일반적으로 `ntdll.dll`의 **Zw/Nt\*** API → 내부에서 **syscall** 트램폴린 → 커널(SSDT 인덱스).
- 표면 API는 **Win32(advapi32/kernel32)** → 일부는 내부적으로 `Nt*` 호출.

### ABI(응용 바이너리 인터페이스)

- **SysV x86-64 ABI**: 인자 전달 `rdi, rsi, rdx, rcx, r8, r9`, 나머지는 스택, 스택 16바이트 정렬.
- **Windows x64 ABI**: `rcx, rdx, r8, r9`까지 레지스터, 나머지 스택, 32바이트 홈 스페이스.
- 보안 포인트: ABI 착오/정렬 위반은 **크래시/정보누출**로 이어짐.

#### 호출 규약 실수 예시

```c
// wrong_abi.c — 인자 개수를 잘못 가정하면 레지스터/스택 읽기 꼬임
#include <stdio.h>

int f(int a,int b,int c,int d,int e){ return a+b+c+d+e; }
int main(){ printf("%d\n", f(1,2,3,4,5)); }
```
- Windows x64에서 인자를 4개로 컴파일한 라이브러리를 5개로 호출하면 **오동작**.
- “플러그인/FFI/리버스”에서 **플랫폼 ABI**를 항상 확인.

---

## 가상 메모리: 페이지 테이블, ASLR, NX, PIE

### 페이지 테이블 한 눈에

- x86-64: 4-레벨(혹은 5-레벨) 페이지 테이블 → **가상주소 비트**를 단계적으로 인덱싱 → **페이지 프레임** 매핑.
- **페이지 권한**: R/W/X 비트 → **NX**(No-eXecute)로 스택/힙 실행 금지.
- **TLB**: 페이지 테이블 룩업 캐시. Flush/ASID가 성능/격리에 영향.

> 보안 포인트: NX로 **코드·데이터 분리**, ASLR/PIE로 **주소 랜덤화** → ROP/JOP/NOP-sled 방해.

### ASLR(주소 공간 배치 무작위화)

- Linux에서 `cat /proc/sys/kernel/randomize_va_space`
  - 0: 끔, 1: 보통, 2: 최대로.
- 관찰: 동일 바이너리 두 번 실행 시 `maps` 주소가 달라짐.

#### ASLR/PIE 차이

```bash
# PIE 끈 실행파일

cat <<'C' > hello.c
#include <stdio.h>

int main(){ printf("main=%p\n", main); }
C
gcc -no-pie -fno-pie hello.c -o hello_nopie
./hello_nopie; ./hello_nopie   # main 주소가 동일(베이스 고정)

# PIE 켠 실행파일

gcc -fpie -pie hello.c -o hello_pie
./hello_pie; ./hello_pie       # main이 매번 달라짐(베이스 랜덤)
```
- **보안 포인트**: PIE는 **실행 파일 자체 베이스**를 랜덤화(라이브러리뿐 아니라 본체까지 랜덤).

### 체감

```c
// nx_test.c — 의도적으로 스택 실행 시도(교육용)
// gcc -z noexecstack nx_test.c -o nx_test && ./nx_test
#include <stdio.h>
#include <string.h>

int main(){
    unsigned char code[] = "\xC3"; // ret
    void (*f)() = (void(*)())code;
    printf("about to exec on stack...\n");
    f(); // NX면 SIGSEGV 가능
}
```
- 현대 배포는 기본 **NX 활성**, `-z execstack` 같이 바꿔야 실행됨. 실전은 절대 사용 금지.

### RELRO/Canary/其他 보호와의 관계

- **RELRO**: GOT 쓰기 방지(Partial/Full).
- **Canary**: 스택 프레임 끝에 값 삽입, 덮침 탐지.
- 익스플로잇 난이도는 보호 조합(ASLR+NX+Canary+RELRO+FORTIFY)에 크게 좌우.

#### 보호 플래그

```bash
checksec --file=hello_pie || true
readelf -l hello_pie | grep GNU_STACK  # RWE? RW?
```

---

## 파일 / 디바이스 / 드라이버 / 인터럽트 개념 정리

### — “모든 것은 파일이다”

- Linux: `open/read/write/ioctl` 인터페이스 뒤에 **파일시스템 드라이버**가 숨어 있음(ext4, btrfs, procfs, sysfs…).
- Windows: NT Object Manager + I/O Manager + 파일시스템 드라이버(NTFS/FAT/ReFS), **핸들** 기반.

#### 파일 + 디바이스 파일

```bash
ls -l /dev/null /dev/tty /dev/sda
# 디바이스, major/minor 번호

# IOCTL 예시(일반 사용자에 의미 있는 장치로 대체; here: 터미널)

strace -e trace=ioctl -f bash -c 'echo hi > /dev/tty 2>/dev/null'
```

### — 커널과 하드웨어 사이

- Linux: `.ko` 모듈, `insmod/rmmod`, `dmesg`로 로그 확인, `/proc/interrupts`로 IRQ 관찰.
- Windows: `.sys` 드라이버, SCM(Service Control Manager)로 로드/언로드, 서명 요구(커널 모드 무서명 차단 옵션 기본).

> 보안 포인트: **드라이버 취약점 = 커널 권한**. IOCTL(입출력 제어) 경로 검증 실패가 잦음.

#### 인터럽트 관찰

```bash
cat /proc/interrupts | sed -n '1,15p'
# IRQ 라인에 어떤 장치/드라이버가 연결되어 있는지 확인

```

### — “즉각 응답”

- 하드웨어 인터럽트(키보드, NIC, 타이머): 커널이 **ISR(Interrupt Service Routine)**로 처리 → **소프트IRQ/Tasklet/Workqueue**로 지연 작업 분리.
- 보안 포인트: **DoS**는 종종 **IRQ 폭주/소프트IRQ 과부하**와 직결, 방화벽/Rate-limit/오프로딩 조정 필요.

---

## 보안 기능 지도: SELinux/AppArmor, Windows Integrity/UAC, Code Signing

### 리눅스 MAC: SELinux vs AppArmor

- **SELinux**: 레이블 기반(주체/객체 컨텍스트), 정책은 **Type Enforcement(TE)** 중심. 강력하지만 학습곡선 높음.
- **AppArmor**: 경로 기반 프로필, 비교적 단순/가볍고 배포 친화.

#### 현재 모드/컨텍스트 보기

```bash
getenforce              # Enforcing / Permissive / Disabled
sestatus                # 상세 상태
ps -eZ | head           # 프로세스 보안 컨텍스트
ls -Z /var/www/html     # 파일 컨텍스트
```

#### 프로필 로드/상태

```bash
sudo aa-status
sudo aa-enforce /etc/apparmor.d/usr.bin.curl   # 특정 바이너리 강제
sudo aa-disable  /etc/apparmor.d/usr.bin.curl
```

#### 최소 프로필 예시 (curl 일부만 허용, 교육용)

```
# /etc/apparmor.d/usr.bin.curl-min
#include <tunables/global>

/usr/bin/curl {
  # 기본 정책
  #include <abstractions/base>
  capability net_raw,     # (예시) 원시 소켓 허용; 실제는 제한 권장
  network inet stream,
  /etc/ssl/** r,
  owner @{HOME}/Downloads/** rw,
  deny /etc/shadow r,
}
```
```bash
sudo apparmor_parser -r /etc/apparmor.d/usr.bin.curl-min
sudo aa-enforce /etc/apparmor.d/usr.bin.curl-min
```
- 포인트: “허용 리스트(화이트리스트)”로 행동을 **미리 제약** → 악용 가능성 축소.

### Windows Integrity Level / UAC

- **Integrity Level(무결성 수준)**: Low/Medium/High/System. 프로세스 간 **쓰기 제약**을 부여(저무결 → 고무결에 쓰기 불가).
- **UAC**: 관리자 권한 상승 시 **동의/보안 데스크탑**으로 전환.
- **AppLocker/WDAC**: 실행 제어(경로/서명/해시/패키지) 정책.

#### 무결성 수준/권한 확인

```powershell
whoami /priv
(Get-Process -Id $PID).Path
# Sysinternals 'Process Explorer'에서 Integrity Level/Token 보이도록

```

#### RunAsInvoker(UAC 우회 패턴 연구는 금지; 개념만)

- **주의**: 실서비스 우회는 정책 위반/불법 가능. 연구는 **자체 VM**에서.

### 코드 서명(Code Signing)

- **목적**: 바이너리/드라이버의 **무결성과 발행자 신원** 확인, 로드/실행 정책 게이트(AppLocker/WDAC/커널 서명 강제).
- **Windows 드라이버**: 커널 모드 드라이버는 **서명 필수**(시험 모드 제외).
- **유닉스**: 커널 모듈 서명(커널 빌드 옵션), 패키지 서명, 실행파일 자체 서명은 배포체계별.

#### 서명 검증

```powershell
# signtool (Windows SDK)

signtool verify /pa C:\Windows\System32\ntdll.dll
```

#### 서명/노터라이즈

```bash
codesign -dv --verbose=4 /bin/ls
spctl --assess --verbose /bin/ls
```

#### (Linux 커널 모듈 서명 확인)

```bash
modinfo e1000e | grep -i sign
# signature/key info가 있으면 서명 내장

```

---

# [실전 미니 과제] 한 번에 훑는 통합 실습 (안전/로컬)

> **목표**: 유저→커널 경계, 시스템 콜, 메모리 레이아웃, 네트워크 트레이스, MAC, UAC/서명을 한 번에 체감.

## A. Linux 편 (Host-only/VM)

1) **메모리 레이아웃/ASLR**
   - `hello_nopie`, `hello_pie`를 빌드/실행 → `/proc/$pid/maps`로 주소 비교.

2) **시스템 콜 관찰**
   - `strace -f -o trace.log ./demo` → `openat/read/write` 흐름 파악.

3) **네트워크 트레이스**
   - `juice-shop`를 Host-only에 올리고 `curl` 한 뒤 `tcpdump -i vboxnet0 -w lab.pcap` → Wireshark로 HTTP 요청/응답 확인.

4) **MAC 적용**
   - AppArmor에서 `curl` 프로필을 **최소 권한**으로 적용 → 특정 경로만 허용, `/etc/shadow` 읽기 **deny** 로그 확인.

## B. Windows 편 (VM)

1) **프로세스/스레드**
   - `win_proc_thread.exe` 실행 → Process Explorer로 **무결성 수준/핸들** 관찰.

2) **UAC / 권한 확인**
   - `whoami /groups`, `whoami /priv`로 토큰 상태 확인. **관리자 권한**/UAC 프롬프트 구분.

3) **서명 검증**
   - `signtool verify /pa`로 시스템 DLL/드라이버의 서명 상태 점검.

---

# 자주 겪는 함정 & 보안 메모

- **ASLR 꺼진 상태에서의 연구 결과**를 실 서비스에 일반화하지 말 것. (ASLR+PIE 환경에서 재검증)
- **NX 우회**를 위한 권장되지 않는 빌드 플래그(`-z execstack`)는 **연구용 랩**에서만.
- **시스템 콜 후킹/내부 API 사용**은 OS 업데이트/보안 제품과 충돌 가능. → **공식 API** 우선.
- **드라이버 IOCTL** 핸들링은 **경계검사**가 핵심(버퍼 길이/포인터 유효성/권한).
- **MAC 정책**은 “막히면 끄는”게 아니라 **프로파일링 → 최소권한 규칙 강화**가 원칙.

---

# 참고 명령 치트시트(요약)

- 프로세스/스레드: `ps -eLf`, `top/H`, `Process Explorer`
- 스케줄러/CPU: `chrt`, `taskset`, `cgroups v2` (`cpu.max`)
- 메모리: `/proc/<pid>/maps`, `pmap -x <pid>`, `smem`, `vmmap(macOS)`
- 시스템 콜: `strace`, `ltrace`, `dtruss(macOS)`
- 네트워크: `ss -tnp`, `tcpdump`, `Wireshark`
- MAC: `getenforce/sestatus`, `aa-status/aa-enforce`
- Windows: `whoami /priv`, `signtool verify`, Process Explorer “Integrity”

---

# 마무리

이 장의 핵심은 **경계**와 **권한**입니다.
- **경계**: 유저/커널, 프로세스/프로세스, 코드/데이터, 신뢰/비신뢰
- **권한**: 실행/메모리/파일/네트워크/드라이버/서명
