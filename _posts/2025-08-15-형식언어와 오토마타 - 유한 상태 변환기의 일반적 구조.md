---
layout: post
title: 형식언어와 오토마타 - 유한 상태 변환기의 일반적 구조
date: 2025-08-15 16:20:23 +0900
category: 형식언어와 오토마타
---
# 유한 상태 변환기(Finite-State Transducer, FST)의 **일반적 구조**

유한 상태 변환기(FST)는 **입력 문자열을 출력 문자열로 변환**하는 유한상태 장치다.  
정규언어를 판정하는 DFA/NFA가 “예/아니오”만 내놓는 데 비해, FST는 **문자열→문자열(관계)** 를 다룬다.  

---

## 0. 기호와 약속

- 입력/출력 알파벳: \(\Sigma, \Gamma\) (ε는 빈문자)
- 문자열 집합: \(\Sigma^\*, \Gamma^\*\)
- 관계(변환 의미):  
  \[
  R(T)\ \subseteq\ \Sigma^\* \times \Gamma^\*
  \]
- 함수형 변환(정규 함수): 각 입력 \(x\)에 대응하는 출력이 **최대 한 개**

---

## 1. 기본 정의

### 1.1 Mealy-형(전이에서 출력)
\[
T=(Q,\Sigma,\Gamma,\delta,\lambda,q_0,F)
\]
- \(Q\): 상태, \(q_0\in Q\): 시작, \(F\subseteq Q\): (선택) 수용  
- \(\delta:Q\times\Sigma_\varepsilon \to 2^Q\), \(\lambda:Q\times\Sigma_\varepsilon \to \Gamma_\varepsilon^\*\)

한 전이에서 **입력 1기호(또는 ε) 소비** + **출력 문자열(또는 ε) 방출**.

### 1.2 Moore-형(상태 출력)
\[
T=(Q,\Sigma,\Gamma,\delta,\rho,q_0,F),\quad \rho:Q\to\Gamma^\*
\]
상태에 출력이 붙는다. 전이를 따라 **도착 상태**의 출력이 이어진다(초기 상태 출력 포함 가능).

### 1.3 (후속)순차 변환기(subsequential / DFT)
결정적 Mealy에 **최종 출력** \(\tau:F\to\Gamma^\*\)를 추가:
\[
T=(Q,\Sigma,\Gamma,\delta,\lambda,q_0,F,\tau)
\]
입력 종료 후 수용 상태 \(p\in F\)라면 **꼬리 출력** \(\tau(p)\)를 더한다.  
이 모델이 구현하는 함수류를 **정규(=순차) 함수**라 부른다.

---

## 2. 비결정과 정규 관계

- **NFT(비결정 FST)**: \(\delta\)가 다가값 → 동일 입력에 **여러 출력**이 나올 수 있어 **관계**를 표현  
- **정규 관계(rational relation)**: FST로 표현 가능한 이항 관계  
- **기능성(functionality)**: 모든 입력에 출력이 **최대 1개**인지 여부(§8.1에서 판정법)

---

## 3. ε의 네 가지 양상과 규율

- **입력 ε, 출력 기호**: 삽입(insertion)  
- **입력 기호, 출력 ε**: 삭제(deletion)  
- **ε→ε**: 무동작. **루프**가 있으면 무한 출력 위험 → 보통 제거/규범화  
- **실무 규율**: 합성 시 **ε-필터**(작은 FSA)를 곱해 **ε의 순서**를 일관되게 강제(중복 경로 제거)

---

## 4. 실행 의미(런)과 출력

입력 \(x=x_1\cdots x_n\)에 대해
\[
q_0 \xrightarrow{x_1/u_1} q_1 \xrightarrow{x_2/u_2} \cdots \xrightarrow{x_n/u_n} q_n
\]
총 출력은 \(u_1u_2\cdots u_n\)이며, 수용이면 최종 출력 \(\tau(q_n)\)를 덧붙인다.  
Moore는 상태 방문마다 \(\rho(q_i)\)가 이어진다.

---

## 5. 핵심 예제: 패턴 치환 “`ab`→`X`”, 나머지는 복사

문자 흐름을 보며 `a`를 잠시 **보류**했다가 다음 글자를 보고 치환/복사 결정을 내린다.

```text
상태: q0(기본), qA('a' 보류)
전이 (입력/출력):

q0 -- a/ε --> qA         # a는 일단 보류
q0 -- b/b --> q0         # 일반 복사
q0 -- c/c --> q0         # c는 기타 문자의 대표

qA -- b/X --> q0         # 'ab'를 'X'로
qA -- a/a --> qA         # 'aa'면 첫 a를 방출, 새 a 보류
qA -- c/a c --> q0       # 'a' 다음이 b가 아니면 'a' 방출 후 c 복사

# 종료: qA에 남아 있으면 τ(qA) = "a" (subsequential)
```

- **포인트**: subsequential(최종 출력) 없이 구현하면 입력 말미의 보류 문자가 **유실**된다.

---

## 6. 구조적 속성: 결정성·지연·정규 함수

- **결정적(sequential)**: 각 \((q,a)\)에 전이 최대 1개  
- **지연(delay)**: 같은 접두 입력에서 경로 간 출력 길이 차  
  - 지연이 **유계**(특히 **twinning property**)이면 NFT 함수는 **결정화 가능**  
- **정규 함수**: FST(특히 subsequential)로 표현되는 함수. **bimachine(양방향 DFA 2개)** 로도 표현 가능

---

## 7. 연산 — 합성·역·폐포

### 7.1 합성(composition)
\(T_1:\Sigma\to\Delta,\ T_2:\Delta\to\Gamma\) → \(T_2\circ T_1:\Sigma\to\Gamma\).  
제품 상태 \((q_1,q_2)\)로 진행하며 \(T_1\)의 출력 라벨과 \(T_2\)의 입력 라벨을 **정렬**한다.  
ε가 섞이면 **ε-필터**를 함께 곱해 경로 유일성을 확보.

### 7.2 역(inversion)
입·출력 라벨을 **교환**해 \(R^{-1}\)을 얻는다. 함수였던 것이 일반적으로 **관계**가 된다.

### 7.3 폐포
- 정규 관계: 합집합/연접/Kleene★/합성/역 등에 닫힘  
- 정규 함수: 합성 등에 닫힘이나 **역**에서 함수성 붕괴 가능

---

## 8. 정정성 검사: 기능성·동치성·포함성

### 8.1 기능성(functionality) 판정 — **square 구성 + 지연 추적**
아이디어: \(T\)를 **자기곱**하여 동일 입력에 대해 서로 다른 출력이 가능한지 본다.  
두 경로의 **출력 차이(지연)** 를 상태로 추적하다가 **모순**을 발견하면 비함수.

```text
제품 상태: (p,q,Δ)   # Δ는 출력 차이를 요약(최대 k 글자 또는 '초과' 표식)
전이:   (p,q,Δ) --a--> (p',q',Δ')  where
        p --a/u--> p',  q --a/v--> q',   Δ' = update(Δ, u, v)
수용 중 Δ ≠ ε 가능 → 비함수
```

- 구현에서는 Δ를 “두 출력의 공통접두를 제거한 잔여”로 관리(유계 지연을 가정/검출).

### 8.2 동치성(두 FST가 같은 변환인가?)
- **결정적·함수**라면: **출력 푸시(output pushing)** 로 정규형을 만든 뒤 상태 동치로 비교  
- 일반 NFT/정규 관계에서는 **포함/동치**가 전반적으로 **결정 불가능**한 경우가 많음

---

## 9. 결정화·최소화(순차 함수)

### 9.1 결정화(determinization)
- 모든 NFT가 결정화되지는 않는다.  
- **twinning property(지연 유계)** 가 성립하는 **함수 관계**는 subsequential로 결정화 가능.

### 9.2 출력 푸시(output pushing)와 최소화
- 전이/상태에 퍼져 있던 공통 **접두/접미 출력**을 이동하여 **정규형**을 만든다.  
- 그 다음, DFA와 유사한 **우언어 동치**로 상태를 병합 → **최소 순차 변환기**.

```text
# 파티션 정제 서명(결정 Mealy 기준)
Sig(q) = [ ( λ(q,a), class( δ(q,a) ) ) ]_{a∈Σ}
같은 Sig를 가진 상태만 병합
```

---

## 10. 가중 유한 상태 변환기(WFST)

### 10.1 정의
전이 \((p, a:b, w, q)\), 경로 가중은 \(\otimes\)로 누적, 대안 경로는 \(\oplus\)로 결합.  
**반가환 반환대(semiring)** \((\oplus,\otimes,\bar{0},\bar{1})\) 위에서 연산.

| 세미링 | \(\oplus\) | \(\otimes\) | 해석 |
|---|---|---|---|
| boolean | OR | AND | 언어 수용 |
| tropical | min | + | 비용/최단경로 |
| log | log-sum-exp | + | 확률 합(로그영역) |

### 10.2 알고리즘 단서
- **합성**(가중 정렬 포함), **가중 푸시(weight pushing)**, **최소화**(조건부)  
- **Viterbi**(최단 경로), **N-best**(최단경로 상위 N개), **shortest-distance**

### 10.3 예(개념)
발음사전 \(L\)과 언어모델 \(G\)를 합성 \(L\circ G\)하여 “발음→단어열”에 확률/비용을 결합 후 **N-best**를 탐색.

---

## 11. 구현 관점(엔진/자료구조/합성기)

- **저장**: 상태 배열, 각 상태의 전이를 입력 라벨별 해시/압축 테이블로  
- **런타임**: 입력 스트림을 스캔하며 일치 전이를 따라 출력 버퍼에 문자열을 이어붙임  
- **합성기**: BFS로 \((q_1,q_2)\) 제품을 확장, ε-필터 상태까지 곱하여 **정렬 규칙**을 강제

```text
# 순차 FST 실행(의사코드)
out := ""
q := q0
for x in input:
  (q', u) := step(q, x)       # δ/λ 조회
  out := out + u
  q := q'
if q ∈ F: out := out + τ(q)
return out
```

---

## 12. 실전 예시 1 — 간단 정규화 파이프라인(합성)

목표: (1) 소문자화 → (2) 숫자 그룹에 콤마 삽입 → (3) 공백 압축.

- \(T_{\text{lower}}:\) `A..Z → a..z` (1-상태 치환)  
- \(T_{\text{comma}}:\) 우측 맥락을 보며 `12345 → 12,345` (지연 사용)  
- \(T_{\text{space}}:\) `\s+ → ' '` (ε-출력/입력 혼합 가능)

구현은 세 개의 소형 FST를 만든 뒤 \(T=T_{\text{space}}\circ T_{\text{comma}}\circ T_{\text{lower}}\) 로 합성한다.  
지연과 ε가 섞이므로 **ε-필터**가 필수.

---

## 13. 실전 예시 2 — subsequential 미니 러너(파이썬)

아래 스니펫은 **결정적** subsequential FST를 단순 실행한다(테이블 기반).

```python
class DSubseqFST:
    def __init__(self, q0, finals, delta, lamb, tau):
        self.q0 = q0
        self.finals = set(finals)           # F
        self.delta = delta                  # dict[(q,a)] -> q'
        self.lamb  = lamb                   # dict[(q,a)] -> str (출력)
        self.tau   = tau                    # dict[q] -> str (최종 출력)

    def run(self, s):
        q, out = self.q0, []
        for ch in s:
            q2 = self.delta.get((q, ch))
            if q2 is None:
                raise ValueError(f"no transition from {(q, ch)}")
            out.append(self.lamb.get((q, ch), ""))
            q = q2
        if q in self.finals:
            out.append(self.tau.get(q, ""))
        return "".join(out)

# 예: 'ab'→'X' 치환, 나머지 복사
q0, qA = "q0", "qA"
delta = {(q0, 'a'): qA, (q0, 'b'): q0, (q0, 'c'): q0,
         (qA, 'b'): q0, (qA, 'a'): qA, (qA, 'c'): q0}
lamb  = {(q0, 'a'): "",  (q0, 'b'): "b", (q0, 'c'): "c",
         (qA, 'b'): "X", (qA, 'a'): "a", (qA, 'c'): "ac"}
tau   = {qA: "a"}  # 말미 보류 a 방출
fst = DSubseqFST(q0, finals={q0, qA}, delta=delta, lamb=lamb, tau=tau)

assert fst.run("z") == None  # 정의되지 않은 입력이면 예외(여기선 'z' 미정)
# 실제 사용에선 '덫 상태'를 넣어 총기계로 만드는 것을 권장
```

실무에선 **덫 상태**를 추가하여 모든 \((q,a)\)가 정의되도록 만든다(총기계).

---

## 14. 체크리스트 — 설계·검증·최적화

1) **모델 선택**: Mealy/Moore/subsequential 중 꼬리 출력 필요 여부로 선택  
2) **ε 규율**: ε-루프 제거, 합성용 **ε-필터** 설계  
3) **기능성**: 필요한가? → **square+지연**으로 검사  
4) **결정화**: twinning property(지연 유계) 확인  
5) **최소화**: **출력 푸시 → 파티션 정제**  
6) **합성 전략**: 여러 소형 변환으로 나눠 모듈화, 합성 시 상태 폭증 대비  
7) **가중 필요**: 세미링 선택, weight pushing/shortest path 고려  
8) **테스트**: 모델 기반 테스트(W-Method/HSI), **구분 입력 시퀀스**로 상태 식별

---

## 15. 흔한 함정

- **ε→ε 루프**로 무한 출력/경로 폭발  
- **지연 무한** 패턴(마지막 기호에 의존하는 앞부분 출력 등)은 **1-way 순차**로는 불가  
- NFT를 **무심코 결정화**하려다 **twinning 위반**으로 실패  
- 합성 시 **ε 정렬 규칙**을 두지 않아 **중복 경로** 생성  
- Moore↔Mealy 변환 시 **지연 0/1** 정렬을 잊어 **출력 오프셋** 오류  
- 역변환(inversion) 후 **함수성 붕괴**(관계가 됨)를 간과

---

## 16. 확장: 2-way/SST/PDT

- **2-way FST**: 입력 헤드가 양방향으로 움직여 **역순·전역 재배열** 가능  
- **SST(Streaming String Transducer)**: 유한 개의 변수에 문자열을 **상수번 복제/병합** 가능(정규 함수와 동치)  
- **PDT(푸시다운 변환기)**: 스택이 있어 **중첩/균형** 구조 처리(문맥자유급)

---

## 17. 한 페이지 요약

- FST는 유한상태로 **문자열→문자열** 관계(정규 관계/정규 함수)를 실현한다.  
- 모델: Mealy/Moore/subsequential, NFT(비결정), ε-전이/출력.  
- 연산: 합성·역·합집합·연접·Kleene★(정규 관계 폐포).  
- 검증: **기능성(square+지연)**, **동치성(출력 푸시+상태 동치)**.  
- 결정화/최소화: **twinning** 조건하 가능, **출력 푸시 → 파티션 정제**.  
- WFST: 세미링 위 가중, 합성/최단경로/N-best 등 확장.

---

## 부록 A) 동등성·포함의 난이도 요약

- **순차 함수**(결정적): 동치성은 선형 시간대(상태/전이 수 비례)로 가능  
- **정규 관계 일반**: 포함/동치가 **결정 불가능**인 경우 다수 → 실무에선 결정적 파이프라인 유지 권장

---

## 부록 B) 미니 실습 아이디어

1) §5 `ab→X`를 **Mealy**와 **Moore**로 각각 작성해 **지연+1** 차이를 눈으로 확인  
2) 단순 치환기 여러 개를 만들어 합성하고, ε-필터 유무에 따른 **경로 수 변화** 비교  
3) 임의 NFT를 만들어 **square+지연** 알고리즘으로 **기능성 위반**을 검출  
4) WFST로 소형 발음사전 \(L\)과 단어 빅그램 \(G\)를 만들고 \(L\circ G\) 후 **Viterbi** 경로를 구해보기(로그 세미링)