---
layout: post
title: 소켓프로그래밍 - 타임아웃, 재시도, 에러 모델
date: 2025-09-25 16:25:23 +0900
category: 소켓프로그래밍
---
## 타임아웃/재시도/에러 모델

> 목표: **연결/읽기/쓰기 타임아웃**을 정책으로 설계하고, C++23에서 **정밀한 구현**(논블로킹 + `poll/epoll`·데드라인)으로 옮긴다.
> **멱등성**을 기준으로 **재시도 전략(지수 백오프 + 지터)**를 정립하고, POSIX `errno` → `std::error_code` 맵을 **실무 관점**으로 정리한다.
> 끝으로 **타임아웃 주입**(지연·손실)과 **관측** 실습으로 모델을 확인한다.

---

### 무엇을 언제 “타임아웃”으로 볼 것인가

네트워킹에서 **타임아웃**은 “**기대한 이벤트가 X초 안에 일어나지 않았다**”는 **정책적 판단**이다. 3가지로 나눠 보자.

1) **연결 타임아웃(connect timeout)**
   - SYN-ACK가 일정 시간 내 오지 않거나, 3-way 핸드셰이크 완료가 지연될 때 중단.
   - **DNS**/주소해석 시간도 포함할지 정책으로 결정.

2) **읽기 타임아웃(read timeout)**
   - **프레이밍 단위**(예: 길이-프리픽스 4B + 본문 `N`B)를 기준으로 **각 구간**의 데드라인.
   - `“N 바이트를 T초 내 못 모으면 실패”` 식으로 **부분 읽기**와 구분.

3) **쓰기 타임아웃(write timeout)**
   - 커널 송신버퍼/혼잡/상대 rwnd로 인해 `send()`가 진전 안 날 때 **데드라인**을 둔다.
   - 서버에서 **느린 소비자(slow consumer)** 보호에 중요.

> 실무 규칙
> - **논블로킹 + `poll/epoll`로 데드라인** 관리: `SO_RCVTIMEO/SO_SNDTIMEO` 는 블로킹 소켓에서만 확실하게 동작, 세밀 제어가 제한적.
> - “**한 번의 프레임 처리**” 별 **소단위 데드라인**을 두자: `connect`, `READ_LEN`, `READ_BODY`, `WRITE_BODY` 각각.

---

### 데드라인 패턴(정석): 논블로킹 + `poll`/`epoll` + 고해상도 타이머

#### 공통 유틸: `now()`, `remaining(deadline)`

```cpp
#include <chrono>

using clock = std::chrono::steady_clock;
inline clock::time_point now() { return clock::now(); }

inline int remaining_ms(clock::time_point deadline) {
    if (deadline == clock::time_point::max()) return -1; // 무한 대기
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(deadline - now()).count();
    return (ms <= 0) ? 0 : (int)ms;
}
```

#### `connect` 타임아웃 (논블로킹)

- 절차: `socket` → `O_NONBLOCK` → `connect`
  - 즉시 0이면 완료, `-1` && `errno==EINPROGRESS`면 **진행 중**
- `poll(POLLOUT)`/`epoll(EPOLLOUT)`로 **완료/실패** 감지 → `getsockopt(SO_ERROR)`로 최종 결과.

```cpp
#include <sys/socket.h>
#include <fcntl.h>
#include <poll.h>
#include <expected>
#include <system_error>

std::expected<void, std::error_code>
connect_with_timeout(int s, const sockaddr* sa, socklen_t slen, clock::time_point deadline) {
    int fl = ::fcntl(s, F_GETFL, 0);
    if (fl<0 || ::fcntl(s, F_SETFL, fl|O_NONBLOCK)<0)
        return std::unexpected(std::error_code(errno, std::generic_category()));

    if (::connect(s, sa, slen) == 0) return {}; // 즉시 완료

    if (errno != EINPROGRESS) return std::unexpected(std::error_code(errno, std::generic_category()));

    pollfd p{.fd=s, .events=POLLOUT, .revents=0};
    int rc = ::poll(&p, 1, remaining_ms(deadline));
    if (rc == 0) return std::unexpected(std::make_error_code(std::errc::timed_out));
    if (rc < 0)  return std::unexpected(std::error_code(errno, std::generic_category()));

    int soerr=0; socklen_t len=sizeof(soerr);
    if (::getsockopt(s, SOL_SOCKET, SO_ERROR, &soerr, &len) < 0)
        return std::unexpected(std::error_code(errno, std::generic_category()));
    if (soerr != 0) return std::unexpected(std::error_code(soerr, std::generic_category()));
    return {};
}
```

#### `recv_exact`/`send_all` with deadline

- **길이-프리픽스** 예제에서 많이 쓰인 패턴을 데드라인 포함으로 일반화.

```cpp
#include <span>
#include <expected>
#include <system_error>

std::expected<void, std::error_code>
recv_exact_deadline(int s, std::span<std::byte> dst, clock::time_point deadline) {
    size_t have = 0;
    while (have < dst.size()) {
        pollfd p{.fd=s, .events=POLLIN, .revents=0};
        int rc = ::poll(&p, 1, remaining_ms(deadline));
        if (rc == 0) return std::unexpected(std::make_error_code(std::errc::timed_out));
        if (rc < 0)  return std::unexpected(std::error_code(errno, std::generic_category()));
        if (p.revents & (POLLERR|POLLHUP|POLLNVAL)) {
            return std::unexpected(std::make_error_code(std::errc::connection_reset));
        }

        ssize_t n = ::recv(s, dst.data()+have, dst.size()-have, 0);
        if (n > 0) { have += (size_t)n; continue; }
        if (n == 0) return std::unexpected(std::make_error_code(std::errc::connection_reset));
        if (errno == EINTR) continue;
        if (errno == EAGAIN || errno == EWOULDBLOCK) continue; // 다음 poll
        return std::unexpected(std::error_code(errno, std::generic_category()));
    }
    return {};
}

std::expected<void, std::error_code>
send_all_deadline(int s, std::span<const std::byte> src, clock::time_point deadline) {
    size_t sent = 0;
    while (sent < src.size()) {
        pollfd p{.fd=s, .events=POLLOUT, .revents=0};
        int rc = ::poll(&p, 1, remaining_ms(deadline));
        if (rc == 0) return std::unexpected(std::make_error_code(std::errc::timed_out));
        if (rc < 0)  return std::unexpected(std::error_code(errno, std::generic_category()));
        if (p.revents & (POLLERR|POLLHUP|POLLNVAL)) {
            return std::unexpected(std::make_error_code(std::errc::connection_reset));
        }

        ssize_t n = ::send(s, src.data()+sent, src.size()-sent, 0);
        if (n > 0) { sent += (size_t)n; continue; }
        if (n == 0) continue;
        if (errno == EINTR) continue;
        if (errno == EAGAIN || errno == EWOULDBLOCK) continue; // 다음 poll
        return std::unexpected(std::error_code(errno, std::generic_category()));
    }
    return {};
}
```

> **TIP**: `epoll(ET)` 환경이라면 `poll` 대신 **자체 타이머 휠 + `epoll_wait` 타임아웃**으로 데드라인을 다중 연결에 적용하자(11~10장 코드 확장).

---

### 멱등성과 재시도

#### 멱등성(idempotency) 정의

- **멱등**: 같은 요청을 **여러 번** 수행해도 **결과가 동일**.
  예) “키 `k`에 값 `42` **설정**”은 멱등, “키 `k` **증가**”는 비멱등.
- **재시도**는 **멱등**일 때만 **안전**. 비멱등 요청은 중복 실행으로 **일관성 붕괴** 가능 → **서버 측 요청 식별자**(idempotency key)나 **트랜잭션/중복억제**가 필요.

#### 지수 백오프 + 지터

- 기본식:
  $$
  \text{backoff}(k) = \min(t_{\max},\ t_0\cdot 2^k)
  $$
- **지터**(Jitter) 추가(권장): 상호 동조(thundering herd)를 피하려고 **무작위**를 섞는다.
  - 예: `Uniform(0, backoff(k))` 혹은 `backoff(k) * (0.5 + rand[0,0.5])`.

```cpp
#include <random>
#include <thread>

struct Backoff {
    std::chrono::milliseconds t0{50};
    std::chrono::milliseconds tmax{3000};
    std::mt19937 rng{std::random_device{}()};
    std::uniform_real_distribution<double> uni{0.0, 1.0};

    std::chrono::milliseconds delay_for(int k, bool jitter=true) {
        using namespace std::chrono;
        auto base = std::min(tmax, t0 * (1<<k));
        if (!jitter) return base;
        double r = uni(rng); // [0,1)
        auto d = (double)base.count() * (0.5 + 0.5*r); // 50%~100%
        return milliseconds{ (int)d };
    }
};
```

#### 재시도 래퍼(멱등만!)

- 실패 사유에 따라 **재시도 가능한 에러**만 재시도(일시적 네트워크, 타임아웃).
- **치명적 에러**(프로토콜 오류, 프레이밍 오류, 권한 문제 등)는 즉시 중단.

```cpp
enum class Retryable { Yes, No };

template <class Fn>
std::expected<typename std::invoke_result_t<Fn>::value_type, std::error_code>
retry_idempotent(Fn&& op, int max_attempts, Backoff& backoff) {
    using Ret = typename std::invoke_result_t<Fn>::value_type;
    for (int k=0; k<max_attempts; ++k) {
        auto r = op();
        if (r) return r; // 성공
        auto ec = r.error();
        // 재시도 가능성 휴리스틱
        if (ec == std::errc::timed_out ||
            ec == std::errc::connection_reset ||
            ec == std::errc::connection_refused ||
            ec == std::errc::host_unreachable ||
            ec == std::errc::network_unreachable) {
            std::this_thread::sleep_for(backoff.delay_for(k));
            continue;
        }
        return std::unexpected(ec); // 비재시도 에러
    }
    return std::unexpected(std::make_error_code(std::errc::timed_out));
}
```

> 실무 팁
> - **클라이언트 생성/송신/수신** 3단계를 **하나의 트랜잭션**으로 보고, **프레이밍** 기준으로 **멱등성**을 판단.
> - 서버가 **idempotency-key**(요청 UUID)를 받아 **중복 억제**를 해주면 **비멱등 동작**도 재시도 안전하게 만들 수 있다.

---

### 에러 코드 맵 — POSIX `errno` → `std::error_code`(C++23)

#### 기초

- C++ 표준 라이브러리: `std::generic_category()` 에서 **POSIX `errno`**를 **`std::errc`** 로 매핑.
- 예: `errno == EAGAIN` → `std::errc::resource_unavailable_try_again`.

#### **현장에서 자주 만나는 항목**(요지표)

| 상황 | `errno` | `std::errc` | 설명/대응 |
|---|---|---|---|
| 논블로킹에서 즉시 불가 | `EAGAIN`/`EWOULDBLOCK` | `resource_unavailable_try_again` | 이벤트 대기 후 재시도 |
| 연결 상대가 닫음 | `ECONNRESET` | `connection_reset` | 재시도 가능(상태에 따라) |
| 포트 미수신 | `ECONNREFUSED` | `connection_refused` | 서버 다운/리스너 없음 |
| 네트워크/호스트 불가 | `ENETUNREACH`/`EHOSTUNREACH` | `network_unreachable`/`host_unreachable` | 라우팅/링크 문제 |
| 타임아웃 | (소켓 옵션/내구성 타이머) | `timed_out` | 정책적 판단으로 생성 |
| 주소 이미 사용중 | `EADDRINUSE` | `address_in_use` | 재기동시 `SO_REUSEADDR` 고려 |
| 파일 디스크립터 한도 | `EMFILE`/`ENFILE` | `too_many_files_open` | ulimit/자원 증가 필요 |
| 접근 권한 없음 | `EACCES` | `permission_denied` | 포트<1024 바인드 등 |
| 메시지 너무 큼(UDP) | `EMSGSIZE` | `message_size` | MTU 고려/조각내기 |

> 구현 팁
> - 항상 `return std::unexpected(std::error_code(errno, std::generic_category()));` 로 **원인 보존**.
> - 라이브러리 인터페이스는 `std::expected<T, std::error_code>` 형태로 통일.

---

### “타임아웃 있는 길이-프리픽스 에코 클라이언트” (C++23)

> **데드라인** 기반 connect/read/write, **재시도(멱등)**, **지수 백오프** 포함.

```cpp
// timeout_echo_client.cpp
// 빌드: g++ -std=c++23 -O2 timeout_echo_client.cpp -o te_client
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <poll.h>
#include <print>
#include <vector>
#include <string>
#include <expected>
#include <system_error>
#include <chrono>
#include <cstring>
#include <random>

using clock = std::chrono::steady_clock;

inline clock::time_point now(){ return clock::now(); }
inline int remaining_ms(clock::time_point d){
    if (d==clock::time_point::max()) return -1;
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(d-now()).count();
    return (ms<=0)?0:(int)ms;
}

std::expected<void,std::error_code> set_nonblock(int s){
    int fl = ::fcntl(s, F_GETFL, 0);
    if (fl<0 || ::fcntl(s, F_SETFL, fl|O_NONBLOCK)<0)
        return std::unexpected(std::error_code(errno, std::generic_category()));
    return {};
}

std::expected<void,std::error_code>
connect_with_timeout(int s, const sockaddr* sa, socklen_t slen, clock::time_point deadline){
    if (::connect(s, sa, slen)==0) return {};
    if (errno!=EINPROGRESS) return std::unexpected(std::error_code(errno,std::generic_category()));
    pollfd p{.fd=s,.events=POLLOUT,.revents=0};
    int rc = ::poll(&p,1, remaining_ms(deadline));
    if (rc==0) return std::unexpected(std::make_error_code(std::errc::timed_out));
    if (rc<0)  return std::unexpected(std::error_code(errno,std::generic_category()));
    int so=0; socklen_t len=sizeof(so);
    if (::getsockopt(s,SOL_SOCKET,SO_ERROR,&so,&len)<0)
        return std::unexpected(std::error_code(errno,std::generic_category()));
    if (so!=0) return std::unexpected(std::error_code(so,std::generic_category()));
    return {};
}

std::expected<void,std::error_code>
send_all_deadline(int s, std::span<const std::byte> src, clock::time_point d){
    size_t sent=0;
    while (sent<src.size()){
        pollfd p{.fd=s,.events=POLLOUT,.revents=0};
        int rc = ::poll(&p,1,remaining_ms(d));
        if (rc==0) return std::unexpected(std::make_error_code(std::errc::timed_out));
        if (rc<0)  return std::unexpected(std::error_code(errno,std::generic_category()));
        if (p.revents&(POLLERR|POLLHUP|POLLNVAL))
            return std::unexpected(std::make_error_code(std::errc::connection_reset));
        ssize_t n = ::send(s, src.data()+sent, src.size()-sent, 0);
        if (n>0){ sent+= (size_t)n; continue; }
        if (n==0) continue;
        if (errno==EINTR) continue;
        if (errno==EAGAIN||errno==EWOULDBLOCK) continue;
        return std::unexpected(std::error_code(errno,std::generic_category()));
    }
    return {};
}

std::expected<void,std::error_code>
recv_exact_deadline(int s, std::span<std::byte> dst, clock::time_point d){
    size_t have=0;
    while (have<dst.size()){
        pollfd p{.fd=s,.events=POLLIN,.revents=0};
        int rc = ::poll(&p,1,remaining_ms(d));
        if (rc==0) return std::unexpected(std::make_error_code(std::errc::timed_out));
        if (rc<0)  return std::unexpected(std::error_code(errno,std::generic_category()));
        if (p.revents&(POLLERR|POLLHUP|POLLNVAL))
            return std::unexpected(std::make_error_code(std::errc::connection_reset));
        ssize_t n = ::recv(s, dst.data()+have, dst.size()-have, 0);
        if (n>0){ have += (size_t)n; continue; }
        if (n==0) return std::unexpected(std::make_error_code(std::errc::connection_reset));
        if (errno==EINTR) continue;
        if (errno==EAGAIN||errno==EWOULDBLOCK) continue;
        return std::unexpected(std::error_code(errno,std::generic_category()));
    }
    return {};
}

struct Backoff{
    std::chrono::milliseconds t0{50}, tmax{3000};
    std::mt19937 rng{std::random_device{}()};
    std::uniform_real_distribution<double> uni{0.0,1.0};
    std::chrono::milliseconds delay_for(int k){
        using namespace std::chrono;
        auto base = std::min(tmax, t0*(1<<k));
        double r = 0.5 + 0.5*uni(rng); // 50~100%
        return milliseconds{ (int)(base.count()*r) };
    }
};

int main(int argc, char** argv){
    if (argc<4){
        std::print(stderr,"usage: {} <host> <port> <msg>\n", argv[0]);
        return 1;
    }
    const char* host=argv[1]; const char* port=argv[2];
    std::string msg=argv[3];

    // 주소 해석
    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(host,port,&hints,&res)!=0){ perror("gai"); return 1; }

    // 재시도(멱등: 에코 요청은 안전)
    Backoff bo;
    for (int attempt=0; attempt<5; ++attempt){
        int s=-1;
        for (auto* ai=res; ai; ai=ai->ai_next){
            s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
            if (s<0) continue;
            if (!set_nonblock(s)) {;} // ok
            auto deadline = now() + std::chrono::seconds(2); // connect 2s
            auto rc = connect_with_timeout(s, ai->ai_addr, ai->ai_addrlen, deadline);
            if (rc) { break; } // connected
            ::close(s); s=-1;
        }
        if (s<0){ std::print(stderr,"connect fail (attempt {})\n", attempt+1); std::this_thread::sleep_for(bo.delay_for(attempt)); continue; }

        // 길이-프리픽스 송신
        uint32_t be = htonl((uint32_t)msg.size());
        std::vector<std::byte> out(4+msg.size());
        std::memcpy(out.data(), &be, 4);
        std::memcpy(out.data()+4, msg.data(), msg.size());

        auto wr_deadline = now() + std::chrono::seconds(2);
        auto r1 = send_all_deadline(s, out, wr_deadline);
        if (!r1){ std::print(stderr,"send error: {}\n", r1.error().message()); ::close(s); std::this_thread::sleep_for(bo.delay_for(attempt)); continue; }

        // 길이 헤더 수신
        uint32_t be_len{};
        auto rd_deadline = now() + std::chrono::seconds(2);
        auto r2 = recv_exact_deadline(s, std::as_writable_bytes(std::span{&be_len,1}), rd_deadline);
        if (!r2){ std::print(stderr,"recv header error: {}\n", r2.error().message()); ::close(s); std::this_thread::sleep_for(bo.delay_for(attempt)); continue; }
        uint32_t n = ntohl(be_len);
        if (n> (1u<<20)){ std::print(stderr,"frame too big {}\n", n); ::close(s); return 1; }

        std::vector<std::byte> body(n);
        rd_deadline = now() + std::chrono::seconds(2);
        auto r3 = recv_exact_deadline(s, body, rd_deadline);
        if (!r3){ std::print(stderr,"recv body error: {}\n", r3.error().message()); ::close(s); std::this_thread::sleep_for(bo.delay_for(attempt)); continue; }

        std::string echoed((char*)body.data(), (char*)body.data()+body.size());
        std::print("[echoed] {}\n", echoed);
        ::close(s);
        break; // 성공
    }
    freeaddrinfo(res);
}
```

---

### 서버 측 정책: 타임아웃으로 **느린 클라이언트 보호**

- **읽기 데드라인**: `READ_LEN`, `READ_BODY` 각각 `Tlen`, `Tbody` 제한(예: 5s/10s).
  - 프로토콜 위반/지연 공격 차단.
- **쓰기 데드라인**: `WRITE_BODY`에 `Twrite` (예: 5s).
  - **느린 수신자**로 인해 **송신 큐가 커지는 것**을 방지(메모리 보호).
- **유휴 타임아웃**: 연결 전체에 **Idle T**(예: 60s) 를 둬서 **무활동**이면 종료.

> 이벤트 루프(예: `epoll`)에선 **타임휠/최소 힙**에 `(deadline, fd)`를 넣고 `epoll_wait`의 타임아웃을 **다음 근접 데드라인**으로 설정하면 **수만 연결**도 무리 없이 관리 가능.

---

### 실습: **타임아웃 주입·관찰**

#### 네트워크 지연/손실 주입 (`tc netem`)

```bash
# 인터페이스(예: eth0) 지연 100ms(one-way), 손실 2%

sudo tc qdisc add dev eth0 root netem delay 100ms loss 2%

# 제거

sudo tc qdisc del dev eth0 root
```

#### 서버에서 관측

- `ss -tinp` : `Recv-Q/Send-Q`, `rto`(재전송 타이머), `pacing_rate`
- `tcpdump -i eth0 tcp port 9000` : 재전송/ACK 간격
- (리눅스) `TCP_INFO` 로 `tcpi_rtt`, `tcpi_total_retrans` 추적

```cpp
#include <netinet/tcp.h>

void log_tcp_info(int fd){
    tcp_info ti{}; socklen_t l=sizeof(ti);
    if (getsockopt(fd, IPPROTO_TCP, TCP_INFO, &ti, &l)==0){
        std::print("[rtt={}us retrans={} cwnd={}]\n", ti.tcpi_rtt, ti.tcpi_total_retrans, ti.tcpi_snd_cwnd);
    }
}
```

#### 테스트 시나리오

1) **클라 읽기 타임아웃** 확인
   - 서버를 느리게 응답(프레임 생성 전 `sleep`) → 클라 `recv_exact_deadline` 실패(T=2s) 관찰.
2) **서버 쓰기 타임아웃** 확인
   - 클라가 **읽지 않도록** 구현(혹은 TCP receive window를 인위적으로 축소) → 서버 `send_all_deadline` 타임아웃.
3) **재시도 성공률**
   - 손실률 2~5%에서 지수 백오프로 시도 횟수 vs 성공률 기록.

---

### 모델 요약 & 체크리스트

- [ ] **정책**: `connect`, `READ_LEN`, `READ_BODY`, `WRITE_BODY`, `idle` 각각 **데드라인** 정의.
- [ ] **구현**: **논블로킹 + poll/epoll + 데드라인 계산**(밀리초).
- [ ] **재시도**: **멱등 요청만** 지수 백오프(+지터)로, **재시도 가능 에러**만 선별.
- [ ] **에러 모델**: `std::expected<T, std::error_code>` 채택, `errno→errc` 매핑을 보존.
- [ ] **관측**: `TCP_INFO`, `ss`, `tcpdump`, `strace -e trace=network`로 **원인-결과**를 수치로 확인.
- [ ] **보호**: 서버에 **쓰기/읽기/유휴 타임아웃**을 적용해 **느린/불량 클라이언트**로부터 자원 보호.

---

### 수학적 직관(지연과 백오프)

- 백오프 \(k\)번째 지연:
  $$
  \text{backoff}(k)=\min(t_{\max},\ t_0\cdot 2^k)
  $$
- **지터**가 없으면 다수 클라이언트가 **동시에** 재시도하여 **스파이크**를 만든다.
  **Uniform 지터**를 곱하면 평균 대기는 같지만 **피크**가 줄고 시스템 안정성이 증가.

---

### 마무리

타임아웃/재시도/에러 모델은 **기술 + 정책**의 결합이다.
**데드라인 기반 I/O**(논블로킹 + `poll/epoll`)로 **정밀 제어**를 갖추고, **멱등성**을 기준으로 **재시도**를 관리하라.
에러는 **표준 범주(`std::error_code`)**로 표면화하고, **관측**을 통해 타임아웃 값을 **근거 있게** 조정하라.
이 모델을 **프레이밍**(5장), **혼잡/버퍼 직관**(6장), **epoll 설계**(10~11장)와 결합하면, 실무 네트워크 프로그램은 **예측 가능하고 튼튼한** 동작을 한다.
