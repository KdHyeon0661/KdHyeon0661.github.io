---
layout: post
title: 객체지향설계 - 객체 지향 설계를 적용하는 팁
date: 2025-07-31 21:20:23 +0900
category: 객체지향설계
---
# 실전에서 객체 지향 설계를 적용하는 팁 — 현장 가이드

> 요약: “작게, 명확하게, 경계부터.”  
> 도메인 언어로 모델을 만들고, 경계(인터페이스)와 불변 조건을 먼저 세운 뒤, 합성 중심으로 확장하세요. 테스트는 안전망이자 문서입니다.

---

## 1) 시작 단계 — 문제를 OO로 바라보는 습관

- **유비쿼터스 언어부터**  
  요구사항 문장(스토리) 속 **명사 → 클래스 후보**, **동사 → 책임/메서드 후보**를 표시합니다. 팀 모두가 같은 단어를 쓰게 하세요.
- **유스케이스를 줄글이 아닌 시나리오로**  
  “Given-When-Then” 형태로 3~5줄 내로 정리 → 바로 테스트/시퀀스 다이어그램으로 연결.
- **CRC 카드 10분 투자**  
  각 클래스의 `책임(Responsibility)`과 `협력자(Collaborators)`만 적어 빠르게 토론합니다. 종이/화이트보드로 충분.

---

## 2) 경계(Interfaces) 먼저, 내부는 나중에

- **포트/어댑터(Ports & Adapters)**  
  도메인/애플리케이션 레이어에서 *필요한 것*을 **인터페이스(포트)** 로 정의하고, 인프라(DB, 외부 API)는 **어댑터**로 나중에 붙입니다.
- **DTO로 외부 표현 절연**  
  HTTP/DB 스키마와 도메인 모델을 직접 결합하지 말고, DTO/매퍼를 둡니다. 변경 파급 범위를 줄여줍니다.
- **작은 인터페이스(ISP)**  
  “한 유스케이스에 꼭 필요한 메서드만” 노출하는 세밀한 인터페이스가 테스트와 교체를 쉽게 합니다.

```java
// Port (도메인이 원하는 계약)
public interface PaymentRepository {
    Optional<Payment> findById(String id);
    void save(Payment p);
}
```

---

## 3) 합성(Composition) 우선, 상속은 신중하게

- **의사결정 규칙**
  1) is-a 관계가 **엄격**히 성립하고, 2) LSP(대체 가능) 위배 우려가 없으며, 3) 공통 로직이 깊이 공유되어야 할 때만 **상속**.  
  그 외에는 **합성 + 위임**으로.
- **전략 교체는 Strategy/함수 주입으로**  
  수수료, 할인, 정렬 같은 정책은 런타임 교체 가능해야 유지보수에 유리합니다.

```java
interface FeePolicy { Money fee(Money base); }
class CardFee implements FeePolicy { ... }
class OverseasCardFee implements FeePolicy { ... }

class Checkout {
  private final FeePolicy fee;
  Checkout(FeePolicy fee) { this.fee = fee; }
}
```

---

## 4) 캡슐화와 불변 조건(Invariant) 강조

- **엔티티의 규칙은 엔티티가 지킨다**  
  출금 가능 금액, 재고 음수 금지, 상태 전이 규칙 등은 엔티티 메서드 안에서 검증.
- **값 객체(Value Object)는 불변**  
  돈/기간/전화번호 같은 값은 불변으로. 동등성/테스트/스레드 안전성이 좋아집니다.

```java
public record Money(long cents, String currency) {
  public Money add(Money m) {
    if(!currency.equals(m.currency)) throw new IllegalArgumentException();
    return new Money(cents + m.cents, currency);
  }
}
```

---

## 5) 상태와 트랜잭션의 위치

- **트랜잭션 경계는 유스케이스(애플리케이션 서비스)**  
  엔티티는 규칙만, 커밋/롤백은 서비스가.  
- **동시성은 도메인에서 의식적으로 모델링**  
  시퀀스 락/버전 필드(낙관적 락)를 고려하고, “최종 일관성” 구간을 문서화합니다.

```java
public class TransferService {
  @Transactional
  public void transfer(AccountId from, AccountId to, Money amt) { ... }
}
```

---

## 6) 테스트는 설계의 가드레일

- **도메인 테스트는 I/O 없이**  
  값 객체/엔티티/도메인 서비스는 외부 의존성 없이 빠르게 검증.
- **포트 목킹은 최소화, Fake 선호**  
  단순 저장소는 인메모리 Fake로, 외부 통신은 계약 테스트로.
- **테스트 이름 = 요구사항 문장**  
  “`withdraw_fails_when_balance_is_insufficient`” 처럼 행동을 서술.

```java
@Test
void withdraw_fails_when_balance_is_insufficient() {
    var acc = new BankAccount(new Money(1000, "KRW"));
    assertThrows(InsufficientFunds.class, () -> acc.withdraw(new Money(2000, "KRW")));
}
```

---

## 7) 설계 정돈을 위한 리팩토링 루틴

- **루틴**: Red → Green → **Refactor**를 짧게 반복.  
- **냄새 대응표**  
  - 긴 메서드 → Extract Method  
  - 거대 클래스 → Extract Class  
  - 반복 switch → Strategy/다형성  
  - 메시지 체인 → 중개자 추가/디미터 법칙
- **한 번에 하나**: 리팩토링은 원자적 커밋으로. 테스트는 항상 초록.

---

## 8) 모듈/패키지 구조 — 의존 방향 고정

```
com.example.shop
 ├─ presentation   (controllers, request/response DTO)
 ├─ application    (use cases, services, ports in/out)
 ├─ domain         (entities, value objects, domain services)
 └─ infrastructure (adapters: persistence, messaging, api)
```

- **의존 방향**: presentation → application → domain ← infrastructure(implements ports)  
- **금지**: presentation → infrastructure 직접 참조, domain이 프레임워크 의존.

---

## 9) 에러/예외, 유효성, 로깅

- **예외 정책 표준화**
  - 도메인 규칙 위반: 체크 가능한 도메인 예외(또는 런타임 도메인 예외)  
  - 시스템 실패(I/O, 타임아웃): 재시도/회로차단 정책
- **유효성 검증 레이어링**
  - DTO 수준(형식/필수값) → 도메인 수준(규칙/불변조건) 둘 다 필요.
- **관찰성(Observability)**  
  도메인 이벤트/유스케이스 성공/실패를 **구조화 로깅**(trace id 포함)으로 기록.

---

## 10) 성능과 단순성의 균형

- **측정 후 최적화**  
  “느릴 것 같다”는 추측 대신, p95/p99 지표와 프로파일러로 결정.
- **핫스팟만 가변**  
  기본은 불변/순수함수 지향, 성능이 정말 필요한 곳에만 가변 구조 허용.
- **캐시/일괄처리**  
  N+1, 채터링 호출을 피하고 배치/캐시/페이지네이션으로 경계 튜닝.

---

## 11) 보안·버전·호환성까지 설계의 일부로

- **모든 컴포넌트 경계에 인증/인가**  
  도메인 서비스에서는 권한을 입력으로 받거나 정책 오브젝트 주입.
- **SemVer + 계약 테스트**  
  공개 API/이벤트는 후방 호환 우선. Major 업은 커뮤니케이션/마이그레이션 가이드 동반.
- **개인정보/규제 고려**  
  모델에 민감 필드 표시, 마스킹/암호화 전략을 설계에 반영.

---

## 12) 프런트/백엔드/DB 간 현실적인 매핑 팁

- **프런트**: 컴포넌트(React/Vue) 경계 = 애플리케이션 유스케이스 단위. DTO는 화면용으로 가볍게.  
- **백엔드**: 도메인 모델을 직접 직렬화하지 말고 `Assembler/Mapper` 사용.  
- **DB**: ORM은 편리하지만 **도메인 모델 = DB 모델** 아님. 읽기 최적화 쿼리는 별도 리포트 모델/뷰로.

---

## 13) 팀 운영 관행

- **PR 템플릿(설계 관점 질문 포함)**  
  - 이 변경의 도메인 규칙은?  
  - 어떤 포트를 추가/수정했는가?  
  - 테스트(단위/통합/계약)는 무엇이 달라졌는가?
- **아키텍처 결정 기록(ADR)**  
  상속 vs 합성, 이벤트 vs 동기 RPC 같은 결정의 근거를 간단히 남깁니다.
- **회고 & 지표**  
  결함 밀도, 변경 리드타임, 변경 실패율, MTTR로 설계/프로세스를 점검.

---

## 14) 흔한 함정과 회피법

| 함정 | 징후 | 회피법 |
|---|---|---|
| Anemic Domain Model | 엔티티가 getter/setter뿐 | 규칙을 엔티티 메서드로 옮기기 |
| God Service | 거대한 애플리케이션 서비스 | 유스케이스별 서비스로 분할 |
| 상속 남용 | LSP 위반, 조건 분기 남발 | 합성/전략으로 교체 |
| 프레임워크 누수 | 도메인에 JPA/HTTP 타입 | 포트/DTO로 절연 |
| DTO-Entity 혼용 | 프레젠테이션→도메인 침투 | 매퍼 계층 유지 |
| 테스트 느림 | DB/네트워크 의존 | 도메인 순수 테스트, Fake/계약 테스트 분리 |

---

## 15) 적용 체크리스트 (출시 전 2분 점검)

- [ ] 도메인 규칙이 엔티티/VO 내부에서 강제되는가?  
- [ ] 외부 I/O는 포트/어댑터로 격리되었는가?  
- [ ] 합성 우선 원칙을 지켰는가(불필요한 상속 없음)?  
- [ ] 유스케이스 경계에 트랜잭션이 모였는가?  
- [ ] 도메인 테스트는 I/O 없이 빠르게 통과하는가?  
- [ ] 공개 API/이벤트는 문서화·버전 관리되는가?  
- [ ] 로그/메트릭/트레이스(관찰성)가 준비되었는가?

---

## 16) 미니 스켈레톤(붙여 쓰는 템플릿)

```java
// domain
public final class Order {
  private final OrderId id;
  private OrderStatus status;
  private final List<OrderLine> lines;

  public Money total() { ... }
  public void pay(Payment payment) {
    if (status != OrderStatus.PENDING) throw new IllegalStateException();
    // invariant check...
    status = OrderStatus.PAID;
  }
}

// application (use case)
public interface OrderRepository {
  Optional<Order> findById(OrderId id);
  void save(Order order);
}

public class PayOrderService {
  private final OrderRepository repo;
  private final PaymentGateway gateway;

  public PayOrderService(OrderRepository repo, PaymentGateway gateway) { ... }

  @Transactional
  public void pay(OrderId id, PaymentRequest req) {
    var order = repo.findById(id).orElseThrow();
    var payment = gateway.charge(req);
    order.pay(payment);
    repo.save(order);
  }
}
```

---

## 17) 마지막 팁 — “완벽한 설계” 대신 “진화 가능한 설계”

- **작게 출발, 빠른 피드백**: 초판은 최소한의 모델 + 경계만. 기능 추가 때 리팩토링으로 설계 성장.  
- **설계는 문서가 아니라 코드 + 테스트**: 다이어그램은 *의사소통* 수단, 진실은 코드와 테스트에.  
- **좋은 이름이 절반**: 도메인 용어로 클래스/메서드/테스트 이름을 정하세요.
