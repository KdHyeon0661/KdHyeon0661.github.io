---
layout: post
title: 영상처리 - 영상 클래스 설계
date: 2025-09-12 23:25:23 +0900
category: 영상처리
---
# **영상 클래스 설계: IppImage · IppDib · IppCreate**

> 이번 장은 “**직접 쓰는 가벼운 영상 클래스**”를 목표로 합니다.  
> - **IppImage**: CPU 친화적 **장치 독립(DIB-style)** 영상 버퍼 (stride/정렬/ROI/변환/기본 연산)  
> - **IppDib**: Windows **DIBSECTION 래퍼**(화면 출력 전용, `SetDIBitsToDevice`/`StretchDIBits`/`BitBlt`)  
> - **IppCreate 프로젝트**: 위 클래스로 **그레이/컬러 테스트 영상 생성 → BMP로 저장/화면 출력**까지 end-to-end

모든 **코드는 \`\`\`로 감싸고**, 수학은 **MathJax** 표기(`$...$`, `$$...$$`)를 사용합니다.  
이전 장(“BMP 파일의 이해”)에서 다룬 원리(Top-Down, stride, bpp)를 **클래스 설계에 녹여** 재사용합니다.

---

## 1. 설계 목표 & 원칙

**문제의식**
- 영상 처리에서 가장 흔한 병목은 **메모리 접근**입니다.  
- “그때그때 벡터/배열”로 구현하면 **stride/경계/정렬**이 틀어지기 쉽고, 라이프사이클 관리가 어렵습니다.

**설계 원칙**
1. **RAII**: 소유/해제 자동화 (예외 안전)  
2. **Top-Down 내부 규약**: `height>0`로 관리, `stride>=width*bytesPerPixel` (4/16/32 정렬)  
3. **얕은 뷰(ROI)**: 복사 없이 부분 영상 참조  
4. **형식(type) 명확성**: `PixelType`과 bpp/채널/정렬 정보를 일관되게  
5. **변환 규약 통일**: 출력용 **BGRX32**로 정규화 (화면 출력/디버그 용이)  
6. **복사/이동语义**: `=default`/`=delete`를 명시 (의도치 않은 깊은 복사 방지)

---

## 2. 핵심 타입 정의: `PixelType`과 헬퍼

### 2.1 픽셀 포맷 집합(실습 우선)
- **Gray8**(1ch, 8bpp), **Bgr24**(3ch, 24bpp), **Bgra32**(4ch, 32bpp)  
- 필요 시 **Gray16**, **Float32**도 확장 가능 (학습용 예제엔 선택)

```cpp
// IppPixel.h
#pragma once
#include <cstdint>
#include <stdexcept>

enum class PixelType : uint8_t {
    Gray8   = 0,   // 1ch, 8bpp
    Bgr24   = 1,   // 3ch, 24bpp (GDI 순서: B,G,R)
    Bgra32  = 2,   // 4ch, 32bpp (B,G,R,A)
    Gray16  = 3,   // 1ch, 16bpp
    Float32 = 4    // 1ch, 32bpp float (실습 선택)
};

inline int Channels(PixelType t) {
    switch (t) {
    case PixelType::Gray8:  return 1;
    case PixelType::Bgr24:  return 3;
    case PixelType::Bgra32: return 4;
    case PixelType::Gray16: return 1;
    case PixelType::Float32:return 1;
    default: throw std::runtime_error("Unknown PixelType");
    }
}
inline int BitsPerPixel(PixelType t) {
    switch (t) {
    case PixelType::Gray8:   return 8;
    case PixelType::Bgr24:   return 24;
    case PixelType::Bgra32:  return 32;
    case PixelType::Gray16:  return 16;
    case PixelType::Float32: return 32;
    default: throw std::runtime_error("Unknown PixelType");
    }
}
inline int BytesPerPixel(PixelType t) { return BitsPerPixel(t) / 8; }
inline bool IsPlanar(PixelType) { return false; } // 현재는 interleaved만
```

---

## 3. `IppImage` 클래스: 소유 버퍼(Top-Down, ROI 지원)

### 3.1 기능 개요
- **소유 버퍼**(연속 메모리) + **stride 정렬**(기본 32바이트)  
- **ROI 뷰**(얕은 참조) 생성  
- **색 변환**: Gray8 ⇄ Bgr24 (출력용 BGRX32 변환 포함)  
- **기본 연산**: fill/invert/선형변환/컨볼루션(3×3)  
- **저장**: BMP(8/24/32bpp) & PGM (선택)  

### 3.2 헤더

```cpp
// IppImage.h
#pragma once
#include <vector>
#include <cstdint>
#include <cstring>
#include <cassert>
#include <stdexcept>
#include <algorithm>
#include "IppPixel.h"

struct IppImageView; // 전방 선언

struct IppImage {
    int         width  = 0;
    int         height = 0;
    int         stride = 0;       // bytes per row
    PixelType   type   = PixelType::Gray8;
    std::vector<uint8_t> buf;     // size = stride * height

    IppImage() = default;
    IppImage(int w, int h, PixelType t, int alignBytes = 32) { create(w,h,t,alignBytes); }

    void create(int w, int h, PixelType t, int alignBytes = 32);
    bool empty() const { return width<=0 || height<=0 || stride<=0 || buf.empty(); }

    // 접근자
    uint8_t*       rowp(int y)       { return buf.data() + (size_t)y * stride; }
    const uint8_t* rowp(int y) const { return buf.data() + (size_t)y * stride; }

    // ROI 뷰
    IppImageView roi(int x, int y, int w, int h);

    // 편의
    void fill(uint8_t value);              // Gray8에서만 의미
    void invert();                         // Gray8, Bgr24, Bgra32 지원
    void linear(float alpha, int beta);    // g = clamp(alpha*f + beta)

    // 변환
    IppImage toBgrx32() const;             // 화면 출력용 BGRX32 (Top-Down)
    IppImage toGray8_fromBgr24() const;    // Bgr24 -> Gray8
    IppImage toBgr24_fromGray8() const;    // Gray8 -> Bgr24

    // 컨볼루션(Gray8, 3x3, replicate)
    IppImage boxBlur3x3_Gray8() const;
};
```

### 3.3 구현

```cpp
// IppImage.cpp
#include "IppImage.h"

static inline int aligned_stride(int width, PixelType t, int alignBytes) {
    const int raw = width * BytesPerPixel(t);
    const int rem = raw % alignBytes;
    return rem ? (raw + (alignBytes - rem)) : raw;
}

void IppImage::create(int w, int h, PixelType t, int alignBytes) {
    if (w<=0 || h<=0) throw std::runtime_error("Invalid size");
    width = w; height = h; type = t;
    stride = aligned_stride(w, t, alignBytes);
    buf.assign((size_t)stride * height, 0);
}

void IppImage::fill(uint8_t value) {
    if (empty()) return;
    if (type == PixelType::Gray8) {
        for (int y=0;y<height;++y) std::memset(rowp(y), value, width);
    } else if (type == PixelType::Bgr24) {
        for (int y=0;y<height;++y) {
            uint8_t* r = rowp(y);
            for (int x=0;x<width;++x) { r[x*3+0]=value; r[x*3+1]=value; r[x*3+2]=value; }
        }
    } else if (type == PixelType::Bgra32) {
        for (int y=0;y<height;++y) {
            uint8_t* r = rowp(y);
            for (int x=0;x<width;++x) { uint8_t* p=&r[x*4]; p[0]=p[1]=p[2]=value; p[3]=255; }
        }
    }
}

void IppImage::invert() {
    if (empty()) return;
    if (type == PixelType::Gray8) {
        for (int y=0;y<height;++y) { uint8_t* r=rowp(y); for (int x=0;x<width;++x) r[x]=uint8_t(255-r[x]); }
    } else if (type == PixelType::Bgr24) {
        for (int y=0;y<height;++y) { uint8_t* r=rowp(y); for (int x=0;x<width;++x){ uint8_t* p=&r[x*3]; p[0]=255-p[0]; p[1]=255-p[1]; p[2]=255-p[2]; } }
    } else if (type == PixelType::Bgra32) {
        for (int y=0;y<height;++y) { uint8_t* r=rowp(y); for (int x=0;x<width;++x){ uint8_t* p=&r[x*4]; p[0]=255-p[0]; p[1]=255-p[1]; p[2]=255-p[2]; /*A*/ } }
    }
}

static inline uint8_t clamp_u8(int v){ return (uint8_t)std::min(255, std::max(0, v)); }

void IppImage::linear(float alpha, int beta) {
    if (empty()) return;
    if (type == PixelType::Gray8) {
        for (int y=0;y<height;++y) { uint8_t* r=rowp(y); for (int x=0;x<width;++x){ int v=int(alpha*r[x])+beta; r[x]=clamp_u8(v);} }
    } else if (type == PixelType::Bgr24) {
        for (int y=0;y<height;++y) { uint8_t* r=rowp(y); for (int x=0;x<width;++x){ uint8_t* p=&r[x*3]; p[0]=clamp_u8(int(alpha*p[0])+beta); p[1]=clamp_u8(int(alpha*p[1])+beta); p[2]=clamp_u8(int(alpha*p[2])+beta);} }
    } else if (type == PixelType::Bgra32) {
        for (int y=0;y<height;++y) { uint8_t* r=rowp(y); for (int x=0;x<width;++x){ uint8_t* p=&r[x*4]; p[0]=clamp_u8(int(alpha*p[0])+beta); p[1]=clamp_u8(int(alpha*p[1])+beta); p[2]=clamp_u8(int(alpha*p[2])+beta);} }
    }
}

// Gray -> Bgr24
IppImage IppImage::toBgr24_fromGray8() const {
    if (type != PixelType::Gray8) throw std::runtime_error("toBgr24_fromGray8: source not Gray8");
    IppImage dst(width, height, PixelType::Bgr24);
    for (int y=0;y<height;++y){
        const uint8_t* s=rowp(y); uint8_t* d=dst.rowp(y);
        for (int x=0;x<width;++x){ uint8_t g=s[x]; d[x*3+0]=g; d[x*3+1]=g; d[x*3+2]=g; }
    }
    return dst;
}

// Bgr24 -> Gray (BT.601)
IppImage IppImage::toGray8_fromBgr24() const {
    if (type != PixelType::Bgr24) throw std::runtime_error("toGray8_fromBgr24: src not Bgr24");
    IppImage dst(width, height, PixelType::Gray8);
    for (int y=0;y<height;++y){
        const uint8_t* s=rowp(y); uint8_t* d=dst.rowp(y);
        for (int x=0;x<width;++x){
            uint8_t B=s[x*3+0], G=s[x*3+1], R=s[x*3+2];
            int Y = int(0.114f*R + 0.587f*G + 0.299f*B + 0.5f); // (의도적 B/R 뒤바뀜 방지: GDI 순서 상수 주의)
            // 정확히는 BT.601: 0.299R + 0.587G + 0.114B (채널명 혼동 주의!)
            Y = int(0.299f*R + 0.587f*G + 0.114f*B + 0.5f);
            d[x]=clamp_u8(Y);
        }
    }
    return dst;
}

// 화면 출력용: 임의 포맷 -> BGRX32
IppImage IppImage::toBgrx32() const {
    IppImage dst(width, height, PixelType::Bgra32);
    for (int y=0;y<height;++y){
        uint8_t* d = dst.rowp(y);
        if (type == PixelType::Gray8) {
            const uint8_t* s = rowp(y);
            for (int x=0;x<width;++x){ uint8_t g=s[x]; uint8_t* p=&d[x*4]; p[0]=g; p[1]=g; p[2]=g; p[3]=255; }
        } else if (type == PixelType::Bgr24) {
            const uint8_t* s = rowp(y);
            for (int x=0;x<width;++x){ const uint8_t* q=&s[x*3]; uint8_t* p=&d[x*4]; p[0]=q[0]; p[1]=q[1]; p[2]=q[2]; p[3]=255; }
        } else if (type == PixelType::Bgra32) {
            const uint8_t* s = rowp(y); std::memcpy(d, s, (size_t)width*4);
        } else {
            throw std::runtime_error("toBgrx32: unsupported type");
        }
    }
    return dst;
}

// Gray8 3x3 박스블러
IppImage IppImage::boxBlur3x3_Gray8() const {
    if (type != PixelType::Gray8) throw std::runtime_error("boxBlur3x3_Gray8: src not Gray8");
    IppImage dst(width, height, PixelType::Gray8);
    auto clampi=[&](int v,int lo,int hi){ return v<lo?lo:(v>hi?hi:v); };
    for (int y=0;y<height;++y){
        for (int x=0;x<width;++x){
            int acc=0;
            for (int j=-1;j<=1;++j){
                int yy=clampi(y+j,0,height-1);
                const uint8_t* r = rowp(yy);
                for (int i=-1;i<=1;++i){
                    int xx=clampi(x+i,0,width-1);
                    acc += r[xx];
                }
            }
            dst.rowp(y)[x]=uint8_t(acc/9);
        }
    }
    return dst;
}
```

### 3.4 ROI: 비소유 뷰 `IppImageView`

```cpp
// IppImageView.h
#pragma once
#include "IppPixel.h"
#include <cstdint>
#include <stdexcept>

struct IppImageView {
    int width=0, height=0, stride=0;
    PixelType type=PixelType::Gray8;
    uint8_t* base=nullptr; // 비소유

    IppImageView()=default;
    IppImageView(int w,int h,int s,PixelType t,uint8_t* p):width(w),height(h),stride(s),type(t),base(p){}

    uint8_t*       rowp(int y)       { return base + (size_t)y * stride; }
    const uint8_t* rowp(int y) const { return base + (size_t)y * stride; }
};

// IppImage::roi 구현
#include "IppImageView.h"
IppImageView IppImage::roi(int x,int y,int w,int h) {
    if (x<0||y<0||x+w>width||y+h>height) throw std::runtime_error("roi OOB");
    return IppImageView{ w, h, stride, type, buf.data() + (size_t)y*stride + x*BytesPerPixel(type) };
}
```

---

## 4. BMP/PGM 저장 유틸 (학습용, 무압축)

> 로더는 이전 장 예제를 재사용할 수 있습니다. 여기서는 **저장**만 포함합니다.

```cpp
// IppSave.h
#pragma once
#include <string>
#include "IppImage.h"

void SaveBMP(const std::wstring& path, const IppImage& img); // Gray8/Bgr24/Bgra32
void SavePGM(const std::wstring& path, const IppImage& img); // Gray8
```

```cpp
// IppSave.cpp
#include "IppSave.h"
#include <fstream>
#include <vector>
#include <stdexcept>
#include <cstdint>

#pragma pack(push,1)
struct BFH { uint16_t bfType; uint32_t bfSize; uint16_t r1; uint16_t r2; uint32_t bfOffBits; };
struct BIH {
    uint32_t biSize; int32_t biWidth; int32_t biHeight; uint16_t biPlanes; uint16_t biBitCount;
    uint32_t biCompression; uint32_t biSizeImage; int32_t biXPelsPerMeter; int32_t biYPelsPerMeter;
    uint32_t biClrUsed; uint32_t biClrImportant;
};
struct RGBQ { uint8_t b,g,r,a; };
#pragma pack(pop)

static uint32_t stride4(int w,int bpp){ return ((w*bpp+31)/32)*4; }

void SaveBMP(const std::wstring& path, const IppImage& img) {
    if (img.empty()) throw std::runtime_error("SaveBMP: empty");
    int bpp = BitsPerPixel(img.type);
    if (!(img.type==PixelType::Gray8 || img.type==PixelType::Bgr24 || img.type==PixelType::Bgra32))
        throw std::runtime_error("SaveBMP: unsupported type");

    const bool needPalette = (img.type==PixelType::Gray8);
    const int  fileBpp = needPalette? 8 : bpp;
    const uint32_t rowStride = stride4(img.width, fileBpp);
    const uint32_t imgSize = rowStride * img.height;

    const uint32_t paletteCount = needPalette? 256 : 0;
    const uint32_t offBits = sizeof(BFH)+sizeof(BIH)+paletteCount*sizeof(RGBQ);
    const uint32_t fileSize = offBits + imgSize;

    BFH bfh{ 0x4D42, fileSize, 0,0, offBits };
    BIH bih{};
    bih.biSize=sizeof(BIH);
    bih.biWidth=img.width;
    bih.biHeight=img.height; // Bottom-Up로 저장(관례)
    bih.biPlanes=1;
    bih.biBitCount=(uint16_t)fileBpp;
    bih.biCompression=0; // BI_RGB
    bih.biSizeImage=imgSize;

    std::ofstream f(path, std::ios::binary);
    if (!f) throw std::runtime_error("SaveBMP: open failed");

    f.write((char*)&bfh,sizeof(bfh));
    f.write((char*)&bih,sizeof(bih));

    if (needPalette) {
        for (int i=0;i<256;++i){ RGBQ q{(uint8_t)i,(uint8_t)i,(uint8_t)i,0}; f.write((char*)&q,4); }
    }

    // 파일은 Bottom-Up: 아래 행부터 기록
    std::vector<uint8_t> row(rowStride, 0);
    for (int y=img.height-1; y>=0; --y) {
        const uint8_t* s = img.rowp(y);
        if (img.type==PixelType::Gray8) {
            std::memcpy(row.data(), s, img.width);
        } else if (img.type==PixelType::Bgr24) {
            std::memcpy(row.data(), s, img.width*3);
        } else { // Bgra32 → 24로 저장해도 되지만 여기선 32도 허용
            if (fileBpp==32) std::memcpy(row.data(), s, img.width*4);
            else {
                // 32→24 다운샘플
                for (int x=0;x<img.width;++x){ const uint8_t* p=&s[x*4]; uint8_t* d=&row[x*3]; d[0]=p[0]; d[1]=p[1]; d[2]=p[2]; }
            }
        }
        f.write((char*)row.data(), rowStride);
    }
}

void SavePGM(const std::wstring& path, const IppImage& img) {
    if (img.type != PixelType::Gray8) throw std::runtime_error("SavePGM: expect Gray8");
    std::ofstream f(path, std::ios::binary);
    if (!f) throw std::runtime_error("SavePGM: open failed");
    f << "P5\n" << img.width << " " << img.height << "\n255\n";
    for (int y=0;y<img.height;++y) f.write((char*)img.rowp(y), img.width);
}
```

---

## 5. Windows 출력 클래스: `IppDib` (DIBSECTION 래퍼)

> **목적**: `IppImage::toBgrx32()` 결과를 **DC로 빠르게 출력**.  
> `CreateDIBSection`으로 만든 32bpp Top-Down 버퍼를 핸들(HBITMAP)로 보유, **`BitBlt`/`StretchDIBits`** 에 사용.

```cpp
// IppDib.h
#pragma once
#ifdef _WIN32
#include <windows.h>
#include <cstdint>
#include <vector>
#include "IppImage.h"

class IppDib {
    HBITMAP  m_hbm = nullptr;
    HDC      m_memdc = nullptr;
    void*    m_bits = nullptr;
    int      m_w=0, m_h=0, m_stride=0;

public:
    IppDib() = default;
    ~IppDib(){ destroy(); }
    IppDib(const IppDib&) = delete;
    IppDib& operator=(const IppDib&) = delete;
    IppDib(IppDib&& o) noexcept { *this = std::move(o); }
    IppDib& operator=(IppDib&& o) noexcept {
        if (this!=&o){ destroy(); m_hbm=o.m_hbm; m_memdc=o.m_memdc; m_bits=o.m_bits; m_w=o.m_w; m_h=o.m_h; m_stride=o.m_stride; o.m_hbm=nullptr; o.m_memdc=nullptr; o.m_bits=nullptr; }
        return *this;
    }

    bool create(HDC refDC, int w, int h) {
        destroy();
        BITMAPINFO bmi{};
        bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
        bmi.bmiHeader.biWidth=w;
        bmi.bmiHeader.biHeight=-h; // Top-Down
        bmi.bmiHeader.biPlanes=1;
        bmi.bmiHeader.biBitCount=32;
        bmi.bmiHeader.biCompression=BI_RGB;
        m_hbm = CreateDIBSection(refDC, &bmi, DIB_RGB_COLORS, &m_bits, nullptr, 0);
        if (!m_hbm) return false;
        m_memdc = CreateCompatibleDC(refDC);
        SelectObject(m_memdc, m_hbm);
        m_w=w; m_h=h; m_stride=w*4;
        return true;
    }

    void destroy(){
        if (m_memdc){ DeleteDC(m_memdc); m_memdc=nullptr; }
        if (m_hbm){ DeleteObject(m_hbm); m_hbm=nullptr; }
        m_bits=nullptr; m_w=m_h=m_stride=0;
    }

    int width() const { return m_w; }
    int height() const { return m_h; }
    void* bits() { return m_bits; }

    // IppImage(BGRX32)로 갱신
    void update(const IppImage& bgrx32) {
        if (bgrx32.type != PixelType::Bgra32) throw std::runtime_error("IppDib::update expects Bgra32");
        if (bgrx32.width!=m_w || bgrx32.height!=m_h) throw std::runtime_error("IppDib::size mismatch");
        for (int y=0;y<m_h;++y){
            std::memcpy((uint8_t*)m_bits + (size_t)y*m_stride, bgrx32.rowp(y), (size_t)m_w*4);
        }
    }

    // 출력: dstRect에 StretchBlt
    void draw(HDC hdc, const RECT& dst) {
        StretchBlt(hdc, dst.left, dst.top, dst.right-dst.left, dst.bottom-dst.top,
                   m_memdc, 0,0,m_w,m_h, SRCCOPY);
    }
};
#endif
```

---

## 6. **IppCreate** 프로젝트 만들기 (VS 2022, Win32 GUI)

> **목표**:  
> 1) `IppImage`로 테스트 영상 생성 (그라데이션/패턴/필터)  
> 2) **BMP 저장**  
> 3) `IppDib`로 **화면 출력** (창 리사이즈/레터박스)  
> 4) `Ctrl+S`: 저장, `Ctrl+O`: (선택) BMP 로드 연결

### 6.1 프로젝트 골격
- **형식**: **Windows Desktop Application (C++) → Empty Project**  
- **구조(권장)**:
  ```
  IppCreate/
    include/
      IppPixel.h
      IppImage.h
      IppImageView.h
      IppDib.h
      IppSave.h
    src/
      IppImage.cpp
      IppSave.cpp
      main_win.cpp
  ```

- **프로젝트 설정**
  - C++ 표준 `/std:c++17` 이상
  - 경고 `/W4`, 필요 시 `/WX`
  - 유니코드: `Use Unicode Character Set`
  - 링커 서브시스템: `Windows`

### 6.2 샘플 앱 `main_win.cpp`

```cpp
// main_win.cpp
#include <windows.h>
#include <string>
#include <stdexcept>
#include "IppImage.h"
#include "IppSave.h"
#ifdef _WIN32
#include "IppDib.h"
#endif

static HINSTANCE g_hInst;
static HWND      g_hWnd;
static IppImage  g_img;       // 내부 표현 (Gray8 또는 Bgr24)
static IppDib    g_dib;       // 화면 출력용 BGRX32
static bool      g_needRebuildDib = true;

static void ShowError(const wchar_t* msg){ MessageBoxW(g_hWnd, msg, L"Error", MB_ICONERROR); }

static IppImage MakeDemo(int w,int h) {
    IppImage img(w,h, PixelType::Gray8);
    // 체커보드 + 방사형 그라데이션
    for (int y=0;y<h;++y){
        uint8_t* r = img.rowp(y);
        for (int x=0;x<w;++x){
            int checker = ((x/32) ^ (y/32)) & 1;
            float dx = (x - w*0.5f), dy = (y - h*0.5f);
            float dist = sqrtf(dx*dx + dy*dy);
            int g = int( (checker?200:80) + 55.0f * cosf(dist*0.05f) );
            r[x] = (uint8_t)std::clamp(g,0,255);
        }
    }
    // 약간 블러
    img = img.boxBlur3x3_Gray8();
    return img;
}

static void RebuildDib(HDC refDC) {
    if (!g_needRebuildDib) return;
    if (g_img.empty()) return;
    IppImage bgrx = g_img.toBgrx32();
    if (!g_dib.create(refDC, g_img.width, g_img.height)) throw std::runtime_error("DIB create failed");
    g_dib.update(bgrx);
    g_needRebuildDib = false;
}

static void OnPaint(HWND h) {
    PAINTSTRUCT ps; HDC hdc=BeginPaint(h,&ps);
    RECT rc; GetClientRect(h,&rc);
    if (g_img.empty()) {
        const wchar_t* t=L"Ctrl+S: BMP 저장,  Space: invert,  +/-: 대비";
        TextOutW(hdc, 10,10, t, lstrlenW(t));
    } else {
        RebuildDib(hdc);
        // 레터박스 유지
        double sx=(double)(rc.right-rc.left)/g_img.width;
        double sy=(double)(rc.bottom-rc.top)/g_img.height;
        double s = min(sx,sy);
        int dw=(int)(g_img.width*s), dh=(int)(g_img.height*s);
        RECT dst{ rc.left+(rc.right-rc.left-dw)/2, rc.top+(rc.bottom-rc.top-dh)/2,
                  0,0 };
        dst.right = dst.left+dw; dst.bottom=dst.top+dh;
        g_dib.draw(hdc, dst);
    }
    EndPaint(h,&ps);
}

static void SaveDialogAndWrite() {
    if (g_img.empty()) return;
    wchar_t buf[MAX_PATH]=L"";
    OPENFILENAMEW ofn{ sizeof(ofn) };
    ofn.hwndOwner=g_hWnd;
    ofn.lpstrFilter=L"BMP (*.bmp)\0*.bmp\0PGM (*.pgm)\0*.pgm\0";
    ofn.lpstrFile=buf; ofn.nMaxFile=MAX_PATH; ofn.Flags=OFN_OVERWRITEPROMPT;
    ofn.lpstrTitle=L"Save Image";
    if (GetSaveFileNameW(&ofn)) {
        std::wstring path(buf);
        try {
            if (path.size()>=4){
                auto ext = path.substr(path.size()-4);
                for (auto& ch:ext) ch = towlower(ch);
                if (ext==L".bmp") SaveBMP(path, g_img.type==PixelType::Bgra32? g_img.toBgr24_fromGray8(): g_img);
                else if (ext==L".pgm") SavePGM(path, g_img.type==PixelType::Gray8? g_img : g_img.toGray8_fromBgr24());
                else SaveBMP(path, g_img);
            } else SaveBMP(path, g_img);
        } catch (const std::exception& e) {
            std::wstring m=L"Save failed: "; m+=std::wstring(e.what(), e.what()+strlen(e.what()));
            ShowError(m.c_str());
        }
    }
}

static LRESULT CALLBACK WndProc(HWND h, UINT m, WPARAM w, LPARAM l){
    switch(m){
    case WM_CREATE:
        g_img = MakeDemo(640,480);
        g_needRebuildDib=true;
        return 0;
    case WM_PAINT: OnPaint(h); return 0;
    case WM_SIZE: InvalidateRect(h,nullptr,FALSE); return 0;
    case WM_KEYDOWN:
        if ((GetKeyState(VK_CONTROL)&0x8000) && w=='S'){ SaveDialogAndWrite(); return 0; }
        if (w==VK_SPACE){
            g_img.invert(); g_needRebuildDib=true; InvalidateRect(h,nullptr,FALSE); return 0;
        }
        if (w==VK_OEM_PLUS || w==VK_ADD){ g_img.linear(1.1f, +5); g_needRebuildDib=true; InvalidateRect(h,nullptr,FALSE); return 0; }
        if (w==VK_OEM_MINUS|| w==VK_SUBTRACT){ g_img.linear(0.9f, -5); g_needRebuildDib=true; InvalidateRect(h,nullptr,FALSE); return 0; }
        return 0;
    case WM_DESTROY: PostQuitMessage(0); return 0;
    default: return DefWindowProcW(h,m,w,l);
    }
}

int APIENTRY wWinMain(HINSTANCE hi,HINSTANCE,LPWSTR,int nCmdShow){
    g_hInst=hi;
    const wchar_t* CN=L"IppCreateWnd";
    WNDCLASSEXW wc{ sizeof(wc) }; wc.lpfnWndProc=WndProc; wc.hInstance=hi; wc.hCursor=LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground=(HBRUSH)(COLOR_WINDOW+1); wc.lpszClassName=CN;
    if (!RegisterClassExW(&wc)) return 0;
    g_hWnd=CreateWindowExW(0,CN,L"IppCreate — Image Class Demo",WS_OVERLAPPEDWINDOW|WS_VISIBLE,
                           CW_USEDEFAULT,CW_USEDEFAULT,1024,768,nullptr,nullptr,hi,nullptr);
    if (!g_hWnd) return 0;
    ShowWindow(g_hWnd, nCmdShow); UpdateWindow(g_hWnd);
    MSG msg{};
    while (GetMessageW(&msg,nullptr,0,0)){ TranslateMessage(&msg); DispatchMessageW(&msg); }
    return (int)msg.wParam;
}
```

> **사용법**  
> - 실행 ↔ 화면에 **체커보드+그라데이션 Gray8** 출력  
> - **Space**: 반전, **+/-**: 밝기/대비 조절  
> - **Ctrl+S**: BMP/PGM로 저장 (확장자 선택)

---

## 7. 수학 메모: **선형 톤 매핑**과 클램프

밝기/대비 조정은 $g = \alpha f + \beta$ 로 표현됩니다.  
- $\alpha>1$이면 대비 증가, $0<\alpha<1$이면 대비 감소  
- $\beta$는 밝기 오프셋  
- 8-bit 영상에서는 **클램프**가 필요:
$$ g' = \min(255, \max(0,\, \alpha f + \beta )) $$

---

## 8. 확장 아이디어(선택 과제)

1. **ROI 기반 파이프라인**: `img.roi(x,y,w,h)`만 처리하고 합성  
2. **가속**: OpenMP/TBB로 행 단위 병렬화, AVX2로 32픽셀 반전  
3. **타입 확장**: `Gray16` → 가우시안/선형 필터에서 **float** 중간 표현  
4. **입출력**: WIC(Windows Imaging Component) 사용해 PNG/JPEG 저장  
5. **뷰어 UX**: 마우스 휠 줌, `CScrollView` 기반 패닝(스크롤바 자동)  
6. **테스트**: GoogleTest로 픽셀 정확도/stride 경계/ROI 안전성 검증

---

## 9. 디버그/트러블슈팅 체크리스트

- [ ] `stride` 계산이 **정렬 기준(32B)**을 만족하는가?  
- [ ] Top-Down 규약(내부) ↔ BMP Bottom-Up 저장 시 **행 순서 반전**을 했는가?  
- [ ] `Bgr24` 채널 순서(B,G,R) 혼동 X (회색/색 왜곡)  
- [ ] `IppDib::update` 시 **크기 일치** 확인  
- [ ] `InvalidateRect` 또는 `UpdateAllViews`로 **재그리기 트리거**  
- [ ] 예외 메시지를 사용자에게 가시적으로 표출

---

## 10. 요약

- **IppImage**로 **장치 독립** 이미지 버퍼를 **Top-Down/stride** 기반으로 안정 관리  
- **IppDib**으로 **CreateDIBSection→BitBlt/Stretch** 경로를 캡슐화 → **화면 출력** 단순화  
- **IppCreate** 프로젝트로 **생성→처리→저장→출력** end-to-end를 구현
