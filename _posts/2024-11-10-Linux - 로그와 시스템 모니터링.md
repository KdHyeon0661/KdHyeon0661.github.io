---
layout: post
title: Linux - 로그와 시스템 모니터링
date: 2024-11-10 19:20:23 +0900
category: Linux
---
# 로그와 시스템 모니터링 — journalctl, dmesg, logrotate

## 리눅스 로그 종류(리캡)
| 로그 | 설명 |
|---|---|
| `/var/log/syslog` 또는 `/var/log/messages` | 전반적 시스템 로그(배포판에 따라 다름) |
| `/var/log/auth.log` 또는 `/var/log/secure` | 인증/보안 이벤트 |
| `/var/log/dmesg` | 부팅 초기 커널 메시지 스냅샷 |
| `/var/log/journal/` | `systemd` **journal** 저장 디렉터리 |
| 서비스별 디렉터리 | 예) `/var/log/nginx/`, `/var/log/mysql/` |

> **systemd 환경**에서는 대부분의 로그가 journald로 먼저 수집되며, rsyslog 등 **전통 syslog 데몬**이 병행 활성일 수 있다.

---

## journald 동작과 보존(저널 저장소의 원리)
### 저장 장소와 모드
- **휘발성(메모리)**: `/run/log/journal` — 재부팅 시 사라짐  
- **영구(디스크)**: `/var/log/journal` — 재부팅 후에도 보존

**영구 보존 활성화**
```bash
sudo mkdir -p /var/log/journal
sudo systemd-tmpfiles --create --prefix /var/log/journal
sudo systemctl restart systemd-journald
```

### journald 설정 파일
```bash
sudo nano /etc/systemd/journald.conf
```
주요 키:
```ini
[Journal]
Storage=persistent            # persistent/volatile/auto
SystemMaxUse=2G               # 전체 사용량 상한
SystemKeepFree=1G             # 디스크 여유 보장
RuntimeMaxUse=512M            # /run(휘발성) 상한
MaxFileSec=1month             # 파일 단위 최대 보존 기간
MaxRetentionSec=3month        # 총 보존 기간
RateLimitIntervalSec=30s
RateLimitBurst=1000
```
적용:
```bash
sudo systemctl restart systemd-journald
```

### 디스크 사용량 확인·정리
```bash
journalctl --disk-usage
# 기간 기준 정리(30일 이전 제거)
sudo journalctl --vacuum-time=30d
# 용량 기준 정리(2GB 넘으면 정리)
sudo journalctl --vacuum-size=2G
# 파일 개수 기준
sudo journalctl --vacuum-files=20
```

---

## journalctl — 필터링·출력·탐색 실전
### 부팅별 탐색
```bash
journalctl --list-boots        # 부팅 목록과 ID
journalctl -b                  # 현재 부팅
journalctl -b -1               # 직전 부팅
journalctl -b -2 -p err        # 2회전전 부팅의 에러 이상
```

### 서비스/유닛·필드 필터
```bash
journalctl -u ssh              # sshd 유닛
journalctl -u nginx -f         # 실시간
journalctl _PID=1234           # 특정 PID
journalctl _UID=1000           # 특정 사용자 UID
journalctl _SYSTEMD_UNIT=nginx.service
journalctl SYSLOG_IDENTIFIER=cron
```

### 시간 범위
```bash
journalctl --since "2025-11-10 09:00" --until "2025-11-10 18:00"
journalctl --since "1 hour ago"
journalctl -S today -U now     # -S/--since, -U/--until 축약
```

### 심각도(우선순위) 필터
```bash
# emerg alert crit err warning notice info debug
journalctl -p err
journalctl -p 3                # 숫자 등가(emerg=0..debug=7)
```

### 출력 포맷
```bash
journalctl -n 100 -o short-iso
journalctl -o json | jq '.MESSAGE'
journalctl -o json-pretty -u myapp
journalctl -o cat -u nginx     # 메시지만
```

### 문자열 검색(정규식)
```bash
journalctl -u myapp --grep='(timeout|error)' --case-sensitive=no
```

### 마지막 재시작 이후 로그
```bash
journalctl -u myapp --since="$(systemctl show -p ActiveEnterTimestamp myapp | cut -d= -f2)"
```

---

## dmesg — 커널 메시지와 하드웨어/드라이버 이슈 추적
### 기본·실시간 모니터
```bash
dmesg -T                      # 사람이 읽기 쉬운 시간
dmesg --level=err             # 에러 이상
dmesg -wH                     # 실시간(페이지네이션)
```

### 흔한 트러블슈팅 필터
```bash
dmesg | grep -Ei 'usb|xhci|uhci'
dmesg | grep -Ei 'nvme|sda|ext4|xfs'
dmesg | grep -Ei 'oom|out of memory|killed process'
```

> 최신 배포판에서는 권한 제한으로 `dmesg`가 일부 숨김일 수 있다. 그러면 `journalctl -k`를 사용:
```bash
journalctl -k -b -p warning
```

---

## logrotate — 로그 회전/압축/보존 전략
### 동작 개요
- **주기(daily/weekly/size)**에 따라 **현재 로그를 회전**(rename)하고 새로운 파일 생성  
- 필요 시 **압축**(.gz), **보존 개수 제한**, **후처리(postrotate)** 실행

### 전역/개별 설정 경로
- 전역: `/etc/logrotate.conf`  
- 서비스별: `/etc/logrotate.d/<name>`

### NGINX 예시 (확장형)
```conf
/var/log/nginx/*.log {
    daily
    rotate 14
    dateext
    missingok
    compress
    delaycompress
    notifempty
    create 0640 www-data adm
    sharedscripts
    postrotate
        # nginx는 USR1 시그널로 로그파일 재오픈
        test -r /run/nginx.pid && kill -USR1 $(cat /run/nginx.pid)
    endscript
}
```

### copytruncate vs 시그널
- **copytruncate**: 기존 파일을 복사 후 원본을 잘라 0바이트로; **SIGHUP 미지원 앱**에 유용하나 **경합/유실** 가능
- **SIGHUP/USR1**: 앱이 로그 파일을 **재오픈**하여 안전; 가급적 선호
```conf
/var/log/myapp.log {
    size 50M
    rotate 10
    compress
    missingok
    notifempty
    # 앱이 SIGHUP을 처리 못하면 아래 사용
    # copytruncate
    postrotate
        systemctl kill -s HUP myapp.service || true
    endscript
}
```

### 용량 기준 회전
```conf
/var/log/app/*.log {
    size 100M
    rotate 20
    compress
    dateext
    missingok
    notifempty
}
```

### 상태/수동 테스트
```bash
cat /var/lib/logrotate/status   # 마지막 회전 상태
sudo logrotate -d /etc/logrotate.conf   # 드라이런
sudo logrotate -f /etc/logrotate.conf   # 강제 회전
```

### systemd 타이머(요즘 배포판)
```bash
systemctl status logrotate.timer
journalctl -u logrotate.service --since today
```

---

## 저널 vs 전통 로그 파일 — 함께 쓸 때의 포인트
- journald가 **우선 수집** 후 rsyslog가 **forward** 가능  
- 순수 journald만 써도 되지만, **어플라이언스/외부 SIEM** 호환 위해 rsyslog 유지하는 환경 다수  
- journald **vacuum**과 logrotate **회전**은 **서로 다른 저장소** 대상임: 각각 따로 관리

---

## 서비스가 journal에 로그 쓰도록(권장)
```ini
# /etc/systemd/system/myapp.service
[Service]
ExecStart=/usr/local/bin/myapp
StandardOutput=journal
StandardError=inherit
SyslogIdentifier=myapp
```
조회:
```bash
journalctl -u myapp -f
journalctl SYSLOG_IDENTIFIER=myapp -p info
```

---

## 로그 집중화/원격 수집(개요)
### systemd-journal-remote(간단한 POC)
```bash
sudo apt install systemd-journal-remote
sudo systemctl enable --now systemd-journal-remote.service
# 수집 노드에서:
systemd-journal-upload --url=https://collector:19532
```

### rsyslog(전통)
- 송신지 `/etc/rsyslog.d/50-remote.conf`:
```conf
*.* @@logs.example.com:514   # @@는 TCP, @는 UDP
```
- 수신지에서 인덱싱/ELK/Loki 등으로 후처리

### Loki/Promtail(현대적)
- Promtail이 파일/journal을 읽어 Loki로 푸시, Grafana로 조회

---

## 디스크 꽉 참 대응(로그가 범인일 때)
1) **journal 사용량 확인/정리**
```bash
journalctl --disk-usage
sudo journalctl --vacuum-size=1G
```
2) **로그 큰 순서 찾기**
```bash
sudo du -xhd1 /var/log | sort -h
sudo find /var/log -type f -size +200M -print0 | xargs -0 ls -lh
```
3) **회전/압축 정책 강화**
- logrotate에 `size`/`daily`/`rotate`/`compress` 조합
- journald `SystemMaxUse` 하향 조정

---

## 시스템 상태 모니터링: 핵심 툴 킷
### uptime — 가동 시간/부하
```bash
uptime
# 1/5/15분 평균 부하. CPU 코어수보다 지속적으로 크면 과부하 의심
```

### free — 메모리
```bash
free -h
# "available" 컬럼을 우선 참고(캐시 포함 가용 메모리 추정)
```

### vmstat — 스냅샷 스트리머
```bash
vmstat 1 10
# r(런큐), si/so(스왑), bi/bo(IO), us/sy/id/wa(CPU breakdown)
```

### iostat — 디스크 I/O(요구: sysstat)
```bash
sudo apt install -y sysstat
iostat -x 1 5
# %util(바쁨), await(대기), svctm(서비스), r/s w/s, rkB/s wkB/s
```

### mpstat — CPU 코어별
```bash
mpstat -P ALL 1
```

### sar — 기록 기반 히스토리
```bash
sar -u 1 3        # CPU
sar -r 1 3        # 메모리
sar -d 1 3        # 디스크
sar -n DEV 1 3    # 네트워크
```

### iotop — 실시간 I/O 상위
```bash
sudo iotop -o -d 2 -n 5
```

### glances — 종합 대시보드
```bash
glances -t 2
glances -w            # 웹 서버 모드(기본 61208)
```

---

## 장애 시나리오별 플레이북

### 1) 서비스 에러 시 즉시 원인 파악
```bash
# 마지막 재시작 이후의 에러
journalctl -u myapp -b -p err
# 직전 10분
journalctl -u myapp --since "-10min" -o short-iso
# 코어덤프 여부(coredumpctl)
coredumpctl list | head
```

### 2) 커널 OOM Killer 의심
```bash
journalctl -k -p warning --since "-1h" | grep -Ei 'out of memory|killed process'
free -h
vmstat 1 5
```

### 3) 디스크 I/O 병목
```bash
iostat -x 1 10            # await/%util 주시
sudo iotop -o -d 1
journalctl -k --since "-10min" | grep -Ei 'I/O error|read-only file system'
```

### 4) 인증 실패/침입 징후
```bash
journalctl -u ssh -p warning --since "today" | grep -Ei 'Failed|Invalid|refused'
# 또는 (Debian) /var/log/auth.log
sudo grep -Ei 'Failed|Invalid|refused' /var/log/auth.log
```

### 5) 로그가 너무 빨리 불어남(스팸)
```bash
# 상위 로그 파일
sudo du -xhd1 /var/log | sort -hr | head
# 특정 유닛/프로세스 스팸 확인
journalctl -u noisy.service --since "-5min" | wc -l
# journald rate limit 조정(journald.conf) 또는 서비스 fix 후 재배포
```

---

## 실전 예시 모음

### 예시 1: NGINX 실시간·최근 로그
```bash
journalctl -u nginx -f
journalctl -u nginx -n 200 -o cat
```

### 예시 2: 최근 1시간 커널 경고↑
```bash
journalctl -k -p warning --since "1 hour ago"
```

### 예시 3: ssh 접속 실패만
```bash
journalctl -u ssh --since today --grep='Failed password'
```

### 예시 4: journal 디스크 정리(30일 보존)
```bash
sudo journalctl --vacuum-time=30d
```

### 예시 5: myapp 전용 logrotate(용량 기준)
```conf
/var/log/myapp/*.log {
    size 50M
    rotate 30
    compress
    missingok
    notifempty
    dateext
    postrotate
        systemctl kill -s HUP myapp.service || true
    endscript
}
```

### 예시 6: jq로 JSON 로그 필드만 추출
```bash
journalctl -u myapp -o json | jq -r '.[ "MESSAGE" ]'
```

---

## 요약 표
| 주제 | 핵심 명령/파일 |
|---|---|
| journald 보존 | `/etc/systemd/journald.conf`, `Storage=persistent`, `SystemMaxUse`, `--vacuum-*` |
| journalctl 필터 | `-b`, `-u UNIT`, `_PID=`, `_UID=`, `-p`, `--since/--until`, `--grep` |
| 출력 포맷 | `-o short-iso|cat|json|json-pretty` |
| 커널 로그 | `journalctl -k`, `dmesg -T|-wH|--level=err` |
| logrotate | `/etc/logrotate.conf`, `/etc/logrotate.d/*`, `size/daily/rotate/compress/postrotate` |
| 회전 신호 | `copytruncate` vs `SIGHUP`/`USR1`(재오픈) |
| 집중화 | `systemd-journal-remote|upload`, `rsyslog @@host:514`, Promtail→Loki |
| 모니터링 | `uptime`, `free -h`, `vmstat`, `iostat -x`, `mpstat`, `sar`, `iotop`, `glances` |
| 디스크 절감 | `--vacuum-size/time/files`, logrotate `compress/dateext/size` |

---

## 마무리
- **운영의 첫 걸음은 로그**다. journald의 **보존·정리 정책**을 명확히 하고, 서비스는 **journal로 직접 출력**하되 필요 시 logrotate로 **파일 회전**을 병행한다.  
- 모니터링 도구(vmstat/iostat/mpstat/sar/iotop/glances)로 **증상→원인**을 신속히 좁히고, **장애 플레이북**을 정형화하여 반복 학습하라.  
- 마지막으로, 로그는 **쌓는 것만큼 지우는 것**이 중요하다. **보존 기한/용량**을 수치로 정하고 자동화에 넣어 **항상 디스크 여유를 확보**해 두자.