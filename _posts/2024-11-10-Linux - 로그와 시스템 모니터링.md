---
layout: post
title: Linux - 로그와 시스템 모니터링
date: 2024-11-10 19:20:23 +0900
category: Linux
---
# 로그와 시스템 모니터링 — journalctl, dmesg, logrotate

## 리눅스 로그 종류 개요

리눅스 시스템에서 주요 로그 파일은 다음과 같습니다:

| 로그 파일 | 설명 |
|---|---|
| `/var/log/syslog` 또는 `/var/log/messages` | 시스템 전반적인 로그 (배포판에 따라 다름) |
| `/var/log/auth.log` 또는 `/var/log/secure` | 인증 및 보안 관련 이벤트 |
| `/var/log/dmesg` | 부팅 초기 커널 메시지 스냅샷 |
| `/var/log/journal/` | `systemd`의 **journal** 저장 디렉터리 |
| 서비스별 로그 디렉터리 | 예) `/var/log/nginx/`, `/var/log/mysql/` |

> **systemd 환경**에서는 대부분의 로그가 journald로 먼저 수집되며, rsyslog와 같은 **전통적인 syslog 데몬**이 병행하여 활성화되어 있을 수 있습니다.

---

## journald 동작 원리와 보존 정책

### 저장 장소와 모드

journald는 두 가지 모드로 로그를 저장합니다:

- **휘발성(메모리) 저장**: `/run/log/journal` — 재부팅 시 사라짐
- **영구(디스크) 저장**: `/var/log/journal` — 재부팅 후에도 보존

**영구 보존 활성화 방법**:
```bash
sudo mkdir -p /var/log/journal
sudo systemd-tmpfiles --create --prefix /var/log/journal
sudo systemctl restart systemd-journald
```

### journald 설정 파일

```bash
sudo nano /etc/systemd/journald.conf
```

주요 설정 항목:
```ini
[Journal]
Storage=persistent            # persistent/volatile/auto
SystemMaxUse=2G               # 전체 사용량 상한
SystemKeepFree=1G             # 디스크 여유 공간 보장
RuntimeMaxUse=512M            # /run(휘발성) 상한
MaxFileSec=1month             # 파일 단위 최대 보존 기간
MaxRetentionSec=3month        # 총 보존 기간
RateLimitIntervalSec=30s
RateLimitBurst=1000
```

설정 적용:
```bash
sudo systemctl restart systemd-journald
```

### 디스크 사용량 확인 및 정리

```bash
journalctl --disk-usage
# 30일 이전 로그 제거
sudo journalctl --vacuum-time=30d
# 용량 기준 정리 (2GB 초과 시 정리)
sudo journalctl --vacuum-size=2G
# 파일 개수 기준 정리
sudo journalctl --vacuum-files=20
```

---

## journalctl — 실전 필터링·출력·탐색 기법

### 부팅별 로그 탐색

```bash
journalctl --list-boots        # 부팅 목록과 ID 확인
journalctl -b                  # 현재 부팅 로그
journalctl -b -1               # 직전 부팅 로그
journalctl -b -2 -p err        # 2회 전 부팅의 에러 이상 로그
```

### 서비스/유닛 및 필드 필터링

```bash
journalctl -u ssh              # sshd 서비스 로그
journalctl -u nginx -f         # 실시간 로그 모니터링
journalctl _PID=1234           # 특정 PID 로그
journalctl _UID=1000           # 특정 사용자 UID 로그
journalctl _SYSTEMD_UNIT=nginx.service
journalctl SYSLOG_IDENTIFIER=cron
```

### 시간 범위 지정

```bash
journalctl --since "2025-11-10 09:00" --until "2025-11-10 18:00"
journalctl --since "1 hour ago"
journalctl -S today -U now     # -S/--since, -U/--until 축약형
```

### 로그 레벨 필터링

```bash
# 레벨: emerg alert crit err warning notice info debug
journalctl -p err
journalctl -p 3                # 숫자 등가 (emerg=0, debug=7)
```

### 출력 포맷 지정

```bash
journalctl -n 100 -o short-iso
journalctl -o json | jq '.MESSAGE'
journalctl -o json-pretty -u myapp
journalctl -o cat -u nginx     # 메시지만 출력
```

### 문자열 검색 (정규식 지원)

```bash
journalctl -u myapp --grep='(timeout|error)' --case-sensitive=no
```

### 마지막 재시작 이후 로그 확인

```bash
journalctl -u myapp --since="$(systemctl show -p ActiveEnterTimestamp myapp | cut -d= -f2)"
```

---

## dmesg — 커널 메시지와 하드웨어/드라이버 이슈 추적

### 기본 및 실시간 모니터링

```bash
dmesg -T                      # 사람이 읽기 쉬운 시간 형식
dmesg --level=err             # 에러 레벨 이상 메시지
dmesg -wH                     # 실시간 모니터링 (페이지네이션)
```

### 트러블슈팅을 위한 일반적인 필터

```bash
dmesg | grep -Ei 'usb|xhci|uhci'
dmesg | grep -Ei 'nvme|sda|ext4|xfs'
dmesg | grep -Ei 'oom|out of memory|killed process'
```

> 최신 배포판에서는 권한 제한으로 `dmesg` 명령이 일부 메시지를 숨길 수 있습니다. 이 경우 `journalctl -k`를 사용하세요:
```bash
journalctl -k -b -p warning
```

---

## logrotate — 로그 회전, 압축, 보존 전략

### 동작 원리 개요

logrotate는 지정된 **주기(daily/weekly/size)**에 따라 **현재 로그 파일을 회전(rename)**하고 새로운 파일을 생성합니다. 필요 시 **압축(.gz)**, **보존 개수 제한**, **후처리(postrotate) 스크립트 실행**을 수행합니다.

### 설정 파일 경로

- 전역 설정: `/etc/logrotate.conf`
- 서비스별 설정: `/etc/logrotate.d/<name>`

### NGINX 로그 회전 설정 예시

```conf
/var/log/nginx/*.log {
    daily
    rotate 14
    dateext
    missingok
    compress
    delaycompress
    notifempty
    create 0640 www-data adm
    sharedscripts
    postrotate
        # nginx는 USR1 시그널로 로그 파일 재오픈
        test -r /run/nginx.pid && kill -USR1 $(cat /run/nginx.pid)
    endscript
}
```

### copytruncate vs 시그널 방식 비교

- **copytruncate**: 기존 파일을 복사한 후 원본을 0바이트로 잘라냅니다. **SIGHUP 시그널을 지원하지 않는 애플리케이션**에 유용하지만 **경합 조건이나 데이터 유실 가능성**이 있습니다.
- **SIGHUP/USR1 시그널**: 애플리케이션이 로그 파일을 **재오픈**하도록 지시하여 안전합니다. 가능한 경우 이 방식을 선호해야 합니다.

```conf
/var/log/myapp.log {
    size 50M
    rotate 10
    compress
    missingok
    notifempty
    # 애플리케이션이 SIGHUP을 처리하지 못할 경우 아래 옵션 사용
    # copytruncate
    postrotate
        systemctl kill -s HUP myapp.service || true
    endscript
}
```

### 용량 기준 회전 설정

```conf
/var/log/app/*.log {
    size 100M
    rotate 20
    compress
    dateext
    missingok
    notifempty
}
```

### 상태 확인 및 수동 테스트

```bash
cat /var/lib/logrotate/status   # 마지막 회전 상태 확인
sudo logrotate -d /etc/logrotate.conf   # 드라이런 (테스트 모드)
sudo logrotate -f /etc/logrotate.conf   # 강제 회전 실행
```

### systemd 타이머 사용 (최신 배포판)

```bash
systemctl status logrotate.timer
journalctl -u logrotate.service --since today
```

---

## 저널 vs 전통 로그 파일 — 함께 사용 시 고려사항

- journald가 **먼저 로그를 수집**한 후 rsyslog가 **전달(forward)**할 수 있습니다.
- 순수하게 journald만 사용해도 되지만, **어플라이언스나 외부 SIEM 시스템**과의 호환성을 위해 rsyslog를 유지하는 환경이 많습니다.
- journald의 **vacuum** 작업과 logrotate의 **회전** 작업은 **서로 다른 저장소**를 대상으로 하므로 각각 별도로 관리해야 합니다.

---

## 서비스가 journal에 직접 로그를 기록하도록 설정

```ini
# /etc/systemd/system/myapp.service

[Service]
ExecStart=/usr/local/bin/myapp
StandardOutput=journal
StandardError=inherit
SyslogIdentifier=myapp
```

로그 조회:
```bash
journalctl -u myapp -f
journalctl SYSLOG_IDENTIFIER=myapp -p info
```

---

## 로그 집중화와 원격 수집 개요

### systemd-journal-remote (간단한 PoC용)

```bash
sudo apt install systemd-journal-remote
sudo systemctl enable --now systemd-journal-remote.service
# 수집 노드에서:
systemd-journal-upload --url=https://collector:19532
```

### rsyslog (전통적인 방식)

송신 측 `/etc/rsyslog.d/50-remote.conf` 설정:
```conf
*.* @@logs.example.com:514   # @@는 TCP, @는 UDP 사용
```
수신 측에서 ELK, Loki 등의 시스템으로 인덱싱 및 후처리합니다.

### Loki/Promtail (현대적인 방식)

- Promtail이 파일이나 journal 로그를 읽어 Loki로 전송하고, Grafana에서 조회합니다.

---

## 디스크 가득 참 대응 (로그가 원인일 때)

1. **journal 사용량 확인 및 정리**
```bash
journalctl --disk-usage
sudo journalctl --vacuum-size=1G
```

2. **큰 로그 파일 찾기**
```bash
sudo du -xhd1 /var/log | sort -h
sudo find /var/log -type f -size +200M -print0 | xargs -0 ls -lh
```

3. **회전 및 압축 정책 강화**
- logrotate에 `size`, `daily`, `rotate`, `compress` 옵션 조합 사용
- journald의 `SystemMaxUse` 값을 낮춤

---

## 시스템 상태 모니터링 핵심 도구

### uptime — 시스템 가동 시간과 부하

```bash
uptime
# 1/5/15분 평균 부하. CPU 코어수보다 지속적으로 크면 과부하 의심
```

### free — 메모리 사용량

```bash
free -h
# "available" 컬럼을 우선 참고 (캐시를 포함한 가용 메모리 추정)
```

### vmstat — 시스템 상태 스냅샷

```bash
vmstat 1 10
# r(런큐 프로세스), si/so(스왑 입출력), bi/bo(블록 입출력), us/sy/id/wa(CPU 사용률 분포)
```

### iostat — 디스크 I/O 모니터링

```bash
sudo apt install -y sysstat
iostat -x 1 5
# %util(디스크 사용률), await(요청 대기 시간), svctm(서비스 시간), r/s w/s(초당 읽기/쓰기), rkB/s wkB/s(초당 KB 읽기/쓰기)
```

### mpstat — CPU 코어별 사용률

```bash
mpstat -P ALL 1
```

### sar — 기록 기반 성능 히스토리

```bash
sar -u 1 3        # CPU 사용률
sar -r 1 3        # 메모리 사용률
sar -d 1 3        # 디스크 활동
sar -n DEV 1 3    # 네트워크 인터페이스
```

### iotop — 실시간 I/O 상위 프로세스

```bash
sudo iotop -o -d 2 -n 5
```

### glances — 종합 시스템 모니터링 대시보드

```bash
glances -t 2
glances -w            # 웹 서버 모드 (기본 포트 61208)
```

---

## 장애 시나리오별 진단 플레이북

### 서비스 에러 시 원인 파악

```bash
# 마지막 재시작 이후의 에러 로그
journalctl -u myapp -b -p err
# 직전 10분간 로그
journalctl -u myapp --since "-10min" -o short-iso
# 코어덤프 확인
coredumpctl list | head
```

### 커널 OOM Killer 작동 의심 시

```bash
journalctl -k -p warning --since "-1h" | grep -Ei 'out of memory|killed process'
free -h
vmstat 1 5
```

### 디스크 I/O 병목 현상 진단

```bash
iostat -x 1 10            # await와 %util 확인
sudo iotop -o -d 1
journalctl -k --since "-10min" | grep -Ei 'I/O error|read-only file system'
```

### 인증 실패 또는 침입 징후 확인

```bash
journalctl -u ssh -p warning --since "today" | grep -Ei 'Failed|Invalid|refused'
# /var/log/auth.log 확인
sudo grep -Ei 'Failed|Invalid|refused' /var/log/auth.log
```

### 로그가 너무 빠르게 증가하는 경우 (스팸)

```bash
# 상위 로그 파일 확인
sudo du -xhd1 /var/log | sort -hr | head
# 특정 서비스/프로세스 로그 양 확인
journalctl -u noisy.service --since "-5min" | wc -l
```

---

## 실전 예시 모음

### 예시 1: NGINX 실시간 및 최근 로그 확인

```bash
journalctl -u nginx -f
journalctl -u nginx -n 200 -o cat
```

### 예시 2: 최근 1시간 동안의 커널 경고 로그

```bash
journalctl -k -p warning --since "1 hour ago"
```

### 예시 3: ssh 접속 실패 로그만 확인

```bash
journalctl -u ssh --since today --grep='Failed password'
```

### 예시 4: journal 로그 30일 보존 정리

```bash
sudo journalctl --vacuum-time=30d
```

### 예시 5: myapp 전용 logrotate 설정 (용량 기준)

```conf
/var/log/myapp/*.log {
    size 50M
    rotate 30
    compress
    missingok
    notifempty
    dateext
    postrotate
        systemctl kill -s HUP myapp.service || true
    endscript
}
```

### 예시 6: jq를 사용한 JSON 로그 특정 필드 추출

```bash
journalctl -u myapp -o json | jq -r '.[ "MESSAGE" ]'
```

---

## 핵심 개념 및 명령어 요약

| 주제 | 핵심 명령/파일 |
|---|---|
| journald 보존 설정 | `/etc/systemd/journald.conf`, `Storage=persistent`, `SystemMaxUse`, `--vacuum-*` |
| journalctl 필터링 | `-b`, `-u UNIT`, `_PID=`, `_UID=`, `-p`, `--since/--until`, `--grep` |
| 출력 포맷 지정 | `-o short-iso|cat|json|json-pretty` |
| 커널 로그 | `journalctl -k`, `dmesg -T|-wH|--level=err` |
| logrotate 설정 | `/etc/logrotate.conf`, `/etc/logrotate.d/*`, `size/daily/rotate/compress/postrotate` |
| 회전 신호 방식 | `copytruncate` vs `SIGHUP`/`USR1`(재오픈) |
| 로그 집중화 | `systemd-journal-remote|upload`, `rsyslog @@host:514`, Promtail→Loki |
| 시스템 모니터링 | `uptime`, `free -h`, `vmstat`, `iostat -x`, `mpstat`, `sar`, `iotop`, `glances` |
| 디스크 공간 절감 | `--vacuum-size/time/files`, logrotate `compress/dateext/size` |

---

## 결론

리눅스 시스템 운영에서 로그 관리는 가장 기본적이면서도 핵심적인 요소입니다. 효과적인 로그 관리를 위해서는 journald의 보존 및 정리 정책을 명확히 설정하고, 서비스는 journal에 직접 로그를 출력하되 필요한 경우 logrotate로 파일 회전을 병행하는 전략이 효과적입니다.

시스템 모니터링 도구(vmstat, iostat, mpstat, sar, iotop, glances 등)를 활용하여 증상에서 원인을 신속하게 좁히고, 장애 발생 시 빠르게 대응할 수 있는 플레이북을 정형화하여 운영 효율성을 높여야 합니다.

마지막으로, 로그는 쌓는 것만큼 지우는 것도 중요합니다. 보존 기한과 용량을 명확한 수치로 정하고 자동화 시스템에 통합하여 항상 디스크 여유 공간을 확보할 수 있도록 관리해야 합니다. 이러한 체계적인 로그 관리와 모니터링은 시스템의 안정성과 가용성을 보장하는 데 필수적입니다.