---
layout: post
title: 정보보안기사 - 파일 삽입 취약점
date: 2025-11-13 09:25:23 +0900
category: 정보보안기사
---
# SECTION 08 웹 애플리케이션 취약점 — 09. 파일 삽입(File Inclusion) 취약점 완전 정리 (LFI/RFI/Template Include/Log Poisoning/Zip Slip 연계 → 안전 설계·언어별 방어 템플릿·서버/클라우드 설정·체크리스트·실기 예상문제)

## 개요 — “사용자 입력이 뷰/스크립트/템플릿의 일부가 되는 순간”
**파일 삽입(File Inclusion)**은 애플리케이션이 **템플릿/스크립트/정적 파일의 경로를 사용자 입력으로 결정**해 로컬 파일을 읽거나 실행(LFI: Local File Inclusion), 혹은 **원격 URL을 포함**(RFI: Remote File Inclusion)하게 되는 취약점이다. 전통적으로 PHP의 `include/require`가 유명하지만, **JSP/JSTL, Node(EJS/Handlebars/동적 import), Python(Jinja2 include), Ruby(Rails partial)** 등 거의 모든 스택에서 **변조된 경로·이름**이 템플릿 로더/파일 로더로 흘러들면 문제가 된다.

- 공격 영향:
  - **정보노출(LFI/Path Disclosure)**: `/etc/passwd`, `.env`, 소스코드/설정/키 파일
  - **원격 코드 실행(RFI/LFI→RCE)**: **로그/세션/업로드 파일에 코드 주입 후 포함**(Log Poisoning, Session Poisoning, Upload+Include)
  - **권한 상승/피벗**: 프로세스 권한으로 시스템 파일 조작, 인증 토큰 탈취
- 보안 직관식:
  $$
  \text{Risk} \approx P(\text{Include Unsanitized}) \times I(\text{Code Execution or Sensitive Read}) \div D(\text{Detection})
  $$
  \(P\)를 낮추려면 **ID→서버 매핑, 정규화+베이스 프리픽스 검사, 원격 포함 금지**가 핵심. \(I\)는 **비밀 분리, 읽기 전용 컨테이너, 최소권한**으로 줄이고, \(D\)는 **로깅/경보, Fuzz 케이스 자동화**로 높인다.

---

## 파일 삽입의 분류와 전개

### 1. LFI(Local File Inclusion)
- **정적 포함**: 템플릿 조각/정적 파일을 읽어 렌더링(뷰 엔진, 마크다운/정적 HTML)
- **동적 실행형 포함**: 포함된 파일의 **코드가 실행**(e.g., PHP `include`로 `.php` 실행)

### 2. RFI(Remote File Inclusion)
- `http(s)://` 등 원격 리소스를 포함(전통적 PHP에서 `allow_url_include=On`일 때)
- 오늘날 보통 **기본 차단**이 많지만, **다운로드 프록시 + eval** 등 **간접 RFI**로 변형

### 3. 연계형 시나리오
- **LFI→RCE(로그/세션 주입)**: 로그/세션 파일에 코드 삽입 → LFI로 그 파일을 include → 실행
- **업로드+Include**: 업로드 디렉터리에 스크립트를 올리고 LFI로 실행(업로드 검증 실패와 결합)
- **Zip Slip + Include**: 압축 해제 시 경로 탈출로 코드 심기 → LFI로 실행

ASCII 개념도:
```
입력(name=about) -> [컨트롤러] -> include("./views/" + name + ".php")
                                        |                ^
                                        |                |
                                   [정규화/권한 없음]   사용자가 보낸 값
```

---

## 전형적 취약 패턴 (언어 불문 공통)

1) **경로를 그대로 받음**
```pseudo
include(BASE + user_input);          // 경로 조합
renderTemplate(user_input);          // 템플릿 이름 그대로
fs.readFile(user_input);             // 정적 파일 로더에 그대로
```

2) **허용 리스트/ID 매핑 부재**
- “어떤 페이지 보여줄까요?” → `?page=about` → 사실상 **임의 경로 열람**

3) **정규화/프리픽스 검사 없음**
- `../../`, 이중 인코딩, 역슬래시 혼용, 유니코드 정규화 등으로 **베이스 탈출**

4) **원격 포함 허용** (또는 간접)
- `http://attacker/...`를 직접 포함하거나, **다운로드 → 실행** 조합

5) **동적 실행과 결합**
- 파일 내용을 **코드로 평가**(예: `eval(file_get_contents(...))`), 템플릿에서 **코드 실행 권한** 등

---

## 익스플로잇 벡터와 체인

### A. LFI를 이용한 파일 열람
- `?tpl=../../../../etc/passwd`
- 윈도우: `..\..\Windows\system32\drivers\etc\hosts`
- `.env`, `config.yml`, 소스코드(`.php`, `.jsp`, `.py`), 키(`id_rsa`), 토큰/세션 파일

### B. LFI → RCE (Log/Session Poisoning)
- **조건**: 웹서버 접근 로그나 애플리케이션 로그가 **LFI 가능한 경로**에 있고, 로그에 **입력 문자열**이 반영
- **절차(개념)**:
  1. **User-Agent** 같은 헤더에 **코드 문자열** 주입(예: PHP 코드)
  2. `?tpl=../../var/log/nginx/access.log` 같은 경로로 include 시도
  3. 포함되며 코드가 실행 → RCE  
  ※ 실제 환경에선 다양한 보호 설정으로 그대로 되지 않는 경우 많다. 합법·격리된 랩에서만 실습.

### C. 업로드+Include
- 업로드 검증이 미흡하면 `.php`, `.jsp` 등 **실행 확장자** 업로드
- 파일명을 모르면 **LFI로 디렉터리 인덱스/로그/메타를 통한 추정** 후 include

### D. RFI(Remote File)
- `allow_url_include`가 켜져 있거나, **서버가 원격 리소스를 받아 곧장 실행**
- 현대 스택에선 직접 RFI는 드물지만, **다운로더 + eval/동적 require** 조합이 위험

### E. 스트림/래퍼 악용(PHP 전통)
- `php://filter/convert.base64-encode/resource=...` → 소스코드 유출
- `data://text/plain;base64,....` → 데이터 URI 실행
- `zip://archive.zip#path` → 아카이브 내부 포함
- (최신 환경에선 여러 제약 존재)

---

## 언어/스택별 취약 패턴 & 안전 구현

### 1. PHP — 가장 빈발한 역사적 타깃

**취약 예시**
```php
<?php
$page = $_GET['page'] ?? 'home';
include "views/" . $page . ".php";   // 경로·확장자 통제 없음
```

**안전 템플릿(허용 리스트 + 매핑 + realpath 프리픽스)**
```php
<?php
$BASE = realpath(__DIR__ . "/views");   // /app/views (고정)
$allow = [
  'home' => 'home.php',
  'about' => 'about.php',
  'contact' => 'contact.php'
];

$key = $_GET['page'] ?? 'home';
if (!array_key_exists($key, $allow)) { http_response_code(404); exit; }

$target = realpath($BASE . DIRECTORY_SEPARATOR . $allow[$key]);
if ($target === false || strpos($target, $BASE) !== 0) { http_response_code(403); exit; }

include $target;
```

**php.ini 보안 권장**
```ini
; 원격 포함 금지
allow_url_include = Off
allow_url_fopen   = Off        ; 필요 서비스 영향 고려

; 파일 시스템 샌드박스
open_basedir = /app:/tmp       ; 앱이 볼 수 있는 루트 제한

; 위험 함수 제한(환경에 따라)
disable_functions = exec,passthru,shell_exec,system,popen,proc_open
```

**추가 방어**
- 로그/세션 파일 권한·경로 분리, **웹루트 외부** 배치
- 템플릿 엔진(Twig 등)의 **로더 루트 고정**(sandbox)
- 업로드는 **실행 불가 디렉터리**에 저장(`.php` 실행 금지), **앙골라 MIME 검사**(Content-Type+Magic number)

---

### 2. Node.js(Express + EJS/Handlebars 등)

**취약 패턴**
```js
app.get('/view', (req, res) => {
  const v = req.query.v;            // 예: ?v=../../../../etc/passwd
  res.render(v);                    // 뷰 이름을 그대로 사용 → 템플릿 로더가 디스크 탐색
});
```

**안전한 뷰 선택(허용 키 매핑)**
```js
import express from "express";
const app = express();
app.set("views", "/app/views");      // 뷰 루트 고정
app.set("view engine", "ejs");

const ALLOW = new Set(["home", "about", "contact"]);

app.get("/view", (req, res) => {
  const key = (req.query.v || "home").toString();
  if (!ALLOW.has(key)) return res.sendStatus(404);
  res.render(key);                   // 키만 통과
});
```

**정적 파일 제공 시 안전(경로 정규화)**
```js
import path from "node:path";
import fs from "node:fs/promises";

const BASE = path.resolve("/app/public");

function safeResolve(rel) {
  const norm = path.normalize(rel).replace(/^(\.\.(\/|\\|$))+/, "");
  const abs = path.resolve(BASE, norm);
  if (!abs.startsWith(BASE + path.sep)) throw new Error("Traversal");
  return abs;
}

app.get("/download", async (req, res) => {
  try {
    const abs = safeResolve(String(req.query.rel || ""));
    await fs.access(abs);
    res.download(abs, path.basename(abs));
  } catch { res.sendStatus(400); }
});
```

---

### 3. Python(Flask/Jinja2)

**취약 패턴 (템플릿 include에 사용자 입력 관여)**
```jinja2
{# bad.html #}
{% include user_template %}  {# user_template가 쿼리로 들어옴 #}
```

**안전(패키지 로더/Dict 로더, 허용 키 매핑)**
```python
from flask import Flask, request, render_template
app = Flask(__name__)

ALLOWED = {"home": "home.html", "about": "about.html"}

@app.get("/page")
def page():
    key = request.args.get("t", "home")
    if key not in ALLOWED:
        return ("Not found", 404)
    return render_template(ALLOWED[key])
```

**파일 읽기 API 방어**
- `send_from_directory`/`safe_join` 등 프레임워크 제공 유틸을 사용
- 사용자 입력을 파일 경로로 **직접** 받지 않기

---

### 4. Java(Spring MVC/JSP)

**취약 예 (JSP 동적 include)**
```jsp
<jsp:include page="${param.p}" />   <!-- p 파라미터로 직접 페이지 지정 -->
```

**안전 (ViewResolver + Enum 매핑)**
```java
@Controller
public class PageController {
  enum ViewKey { HOME, ABOUT, CONTACT }

  @GetMapping("/page")
  public String page(@RequestParam(defaultValue="HOME") ViewKey v) {
    switch (v) {
      case ABOUT: return "about";
      case CONTACT: return "contact";
      default: return "home";
    }
  }
}
```
- **JSP include에 사용자 입력 사용 금지**, **ViewResolver로 내부 이름 매핑**
- `ResourceHttpRequestHandler` 직접 확장 시에도 **정규화+프리픽스 검사** 유지

---

### 5. Ruby on Rails

**취약 패턴**
```rb
render params[:partial]   # 사용자 입력으로 partial 선택
```

**안전 매핑**
```rb
ALLOWED = { "home" => "pages/home", "about" => "pages/about" }

def show
  key = params[:p] || "home"
  return head :not_found unless ALLOWED[key]
  render ALLOWED[key]
end
```

---

## LFI/RFI 방어의 핵심 원칙 (요지)

1) **경로/템플릿 이름은 외부에서 받지 않는다** → **항상 ID/키를 받고** 서버가 **매핑**
2) **정규화 후 베이스 프리픽스 검사**
3) **원격 포함 금지**, 다운로드/프록시도 **화이트리스트 도메인**만
4) **동적 실행 금지**: 파일 내용에 `eval`/동적 `require`를 사용하지 않음
5) **권한/소유 인가**: 파일마다 접근 정책(소유자/조직/태그) 평가
6) **업로드는 실행 불가 디렉터리** + 확장자/마임/매직넘버/크기 검증 + 서명 URL(직접 경로 노출 금지)
7) **로그/세션/캐시 파일 분리**: 웹루트 밖, 권한 최소화, 이진 로그/서명/무결성 보호
8) **템플릿 엔진의 로더 루트 고정**(sandbox), 서드파티 플러그인 코드 리뷰
9) **컨테이너/OS 격리**: 읽기 전용 루트, `noexec` 마운트, AppArmor/SELinux
10) **테스트 자동화**: Fuzz 케이스(이중 인코딩, 역슬래시 혼용, 유니코드 정규화), DAST/SAST 규칙

---

## Zip Slip(압축 해제 경로 삽입)과 결합 방어

- **문제**: 아카이브 내부 엔트리에 `../../` 포함 → 해제로 BASE 밖 쓰기 → LFI/업로드+include와 결합시 RCE
- **방어**: 엔트리마다 `resolve/normalize` 후 **BASE 프리픽스 검사**, **심볼릭 링크 거부**, 확장자/파일 개수/전체 크기 상한

Java 예시:
```java
Path dest = Paths.get("/app/unpack").toRealPath();
try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zip))) {
  ZipEntry e;
  while ((e = zis.getNextEntry()) != null) {
    Path target = dest.resolve(e.getName()).normalize();
    if (!target.startsWith(dest)) throw new SecurityException("Zip Slip");
    if (e.isDirectory()) Files.createDirectories(target);
    else {
      Files.createDirectories(target.getParent());
      Files.copy(zis, target, StandardCopyOption.REPLACE_EXISTING);
    }
  }
}
```

---

## 서버/인프라 설정 가이드

### 웹서버/리버스 프록시
- **Nginx**: 애플리케이션이 권한·경로 검증 후 `X-Accel-Redirect`로 내부 경로 전달
- **Apache**: `Options -Indexes -ExecCGI`(필요 시), 정적 디렉터리에서 스크립트 실행 금지
- **IIS**: 가상 디렉터리 매핑 시 상위 경로/핸들러 누락 주의

### 운영체제/컨테이너
- **웹루트 외부**에 민감 파일/로그/세션 저장
- 컨테이너: **읽기 전용 루트(`ro`)**, 업로드 전용 볼륨 `noexec,nosuid,nodev`
- **AppArmor/SELinux**로 프로세스 파일 접근 최소권한 정책

### 클라우드 스토리지
- S3/GCS는 **private** 기본, **서명 URL(짧은 만료)**로 제공
- **오리진 접근 통제**(Origin Access Control/Policy)로 직접 공개 차단

---

## 로깅·모니터링·탐지 룰

- **필드**: 요청자/역할, 파라미터(원본/정규화 결과), 선택된 템플릿/경로, 권한 평가 결과, 실패 사유
- **이상 탐지**:
  - 파라미터에 `..`, `%2e%2e`, `\`, 유니코드 이상치
  - `page`, `template`, `view`, `include` 파라미터에 비허용 값 빈발
  - 403/404 급증, 미스매치 로그 다발
- **SIEM 쿼리(개념)**:
  - where (url like “%include%” or param_name in (“page”,”view”)) and (param_value matches traversal-pattern)

---

## 테스트/모의진단(합법적 랩)

### Fuzz 페이로드(안전 연구용)
```
../../etc/passwd
..%2f..%2fetc%2fpasswd
..%252f..%252fetc%252fpasswd
..\..\Windows\System32\drivers\etc\hosts
php://filter/convert.base64-encode/resource=index.php
data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+
zip://archive.zip#../../evil.php
```
- **목표**: 읽기 차단, 소스 노출 차단, 원격/래퍼 포함 차단 확인

### SAST 규칙(예시)
- **PHP**: `include|require(_once)?\s*\(`에 **변수/$_GET/$_POST**가 직접 인자
- **JS/TS**: `res.render(variable)` / `require(variable)` / `import(variable)`
- **Java**: `RequestDispatcher#include/forward`/`jsp:include`에 사용자 입력

---

## 체크리스트 (현장용)

- [ ] **경로/템플릿 이름을 입력으로 받지 않는다** → **ID/키**만 받고 서버 **허용 리스트/매핑**
- [ ] 경로 조합이 불가피할 때: **정규화+BASE 프리픽스 검사**, 심볼릭 링크/레이스 방지
- [ ] **원격 포함 금지**(php.ini `allow_url_include=Off` 등), 다운로드 프록시는 **화이트리스트**
- [ ] **동적 실행 금지**: 파일 내용을 `eval/require` 하지 않음
- [ ] **업로드는 실행 불가 디렉터리**, 마임/매직넘버/확장자/크기/개수 검사, **서명 URL**
- [ ] **로그/세션 분리**: 웹루트 밖, 권한 최소화, 이진 포맷/인코딩, 무결성 보호
- [ ] 템플릿 엔진 **로더 루트 고정**, 서드파티 템플릿/플러그인 신뢰성 검증
- [ ] 컨테이너/OS **최소권한**: `ro` 루트, `noexec` 업로드, AppArmor/SELinux
- [ ] 로깅: 원본 파라미터와 정규화 결과, 실패 사유 기록 + 경보
- [ ] 정기 리그레션: 프레임워크/서버 업데이트 시 경로 처리 변화 테스트

---

## 실습 시나리오(요지, 합법적 랩 환경)

1) **취약 PHP 뷰 선택기** → `?page=../../etc/passwd`로 LFI 확인  
2) **Log Poisoning**: User-Agent에 실험용 문자열 삽입 → `?page=../../var/log/...` 포함 차단 확인  
3) **업로드 디렉터리**: `.php` 업로드 금지/실행 금지 동작 확인  
4) **php://filter** → 코드 베이스64 노출 방지 확인  
5) **S3 프리사인 URL** → 뷰/템플릿이 아닌 외부 링크 제공 방식 검증

---

## 실기 예상문제 (서술/코드 수정형)

**문제 1**  
다음 PHP 코드의 보안상 문제를 3가지 쓰고, 안전한 수정 방향을 제시하라.
```php
<?php
$page = $_GET['page'] ?? 'home';
include __DIR__ . "/views/" . $page . ".php";
```
**모범 요지**  
- 문제: (1) 사용자 입력을 경로로 직접 사용(LFI), (2) 정규화/프리픽스 검사 없음, (3) 허용 리스트/권한 검증 없음.  
- 해결: **허용 키 매핑**(ID→파일), `realpath`+BASE 프리픽스 검사, 소유권/역할 검증, 원격 포함 금지.

---

**문제 2**  
JSP에서 `<jsp:include page="${param.p}" />`가 왜 위험한가? 안전 대안을 서술하라.

**모범 요지**  
- 위험: 사용자 입력으로 **임의 JSP/리소스 포함** 가능.  
- 대안: **컨트롤러에서 enum/매핑으로 뷰 이름 결정**, ViewResolver 사용, 사용자 입력은 **키**로만 취급.

---

**문제 3**  
LFI를 RCE로 이어지게 하는 대표적 체인을 하나 설명하고 방어책을 쓰라.

**모범 요지**  
- 체인: **Log Poisoning**(헤더에 코드 → 로그 기록) + LFI로 로그 include → 실행.  
- 방어: 로그/세션/캐시를 **웹루트 밖**, **실행 불가**, **코드 해석 불가**, 입력 필터/인코딩, 권한 최소화.

---

**문제 4**  
Node/Express에서 `res.render(req.query.v)`가 위험한 이유와 안전한 구현을 코드를 포함해 설명하라.

**모범 요지**  
- 이유: 템플릿 로더가 **임의 템플릿을 로드**할 위험(경로 조작/LFI).  
- 안전 코드: **허용 키 Set**으로 화이트리스트, `app.set("views", "...")`로 루트 고정, 사용자 입력은 키로만 사용.

---

**문제 5**  
Zip Slip이 파일 삽입과 결합될 때 어떤 리스크가 있는가? 방어 방법은?

**모범 요지**  
- 리스크: 압축 해제로 **임의 경로에 스크립트 쓰기** → 이후 LFI로 실행 → RCE.  
- 방어: 엔트리별 정규화+BASE 프리픽스 검사, 링크 거부, 확장자/크기/개수 제한, 실행 디렉터리 분리.

---

## 부록: 간단 도식(권장 아키텍처)

```
   [Client]
      |
      v
[Controller] --(key)--> [Whitelist/Map] --(relative path)--> [normalize/realpath]
                                                  |               |
                                                  v               v
                                                [Policy/ACL] --> [prefix check] --> [Template Loader]
```

---

## 결론
파일 삽입은 **“경로/템플릿을 입력으로 신뢰”**할 때 발생한다. 실무에서의 방어 핵심은  
- (1) **ID/키→서버 매핑(화이트리스트)**,  
- (2) **정규화+BASE 프리픽스 검사**,  
- (3) **원격 포함/동적 실행 금지**,  
- (4) **권한/소유 검증 + 로그/세션/업로드 분리**,  
- (5) **컨테이너/OS/프록시 레벨의 최소권한**이다.  
이 원칙을 **코딩 규약/프레임워크 템플릿/CI 파이프라인의 SAST/DAST**로 고착화하면, 시험과 실무 모두에서 높은 방어력을 확보할 수 있다.