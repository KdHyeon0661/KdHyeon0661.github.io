---
layout: post
title: 알고리즘 - 우선순위 큐
date: 2025-05-08 19:20:23 +0900
category: 알고리즘
---
# ⏫ 우선순위 큐(Priority Queue)

## 1) 우선순위 큐란?

**우선순위가 높은 요소**를 먼저 꺼내는 ADT. 파이썬에서는 **이진 힙**으로 구현하는 `heapq`를 주로 사용합니다.

- Min-Heap: **가장 작은** 키가 루트(최상위)  
- Max-Heap: 파이썬 기본이 Min이므로 **부호 반전** 또는 **우선순위 음수화**로 구현

### 핵심 연산과 시간 복잡도

| 연산 | 의미 | 평균/최악 |
|--|--|--|
| `push` | 요소 삽입 | \(O(\log N)\) |
| `pop` | 최상위(최소/최대) 추출 | \(O(\log N)\) |
| `peek` | 최상위 확인 | \(O(1)\) |
| `heapify` | 무작위 배열 → 힙 | \(O(N)\) |
| `merge` | 정렬 스트림 병합 | 선형합 |

---

## 2) 힙(Heap)의 동작 원리 한 번에 이해

- **완전 이진트리** 형태를 **배열**로 저장 (인덱스 기반 부모/자식 계산)
- 삽입 시 **위로 올리기(sift-up)**, 삭제 시 **아래로 내리기(sift-down)**
- 정렬 전체치환이 아니라 **부분 순서**만 유지 ⇒ 최상위만 정렬 보장

### 빌드 힙(Heapify) vs 정렬

- `heapq.heapify(arr)`: **제자리**에서 \(O(N)\)
- 전체 정렬은 `arr.sort()`가 낫지만, **반복 추출**이 필요하면 힙 유리

---

## 3) 파이썬 `heapq` — 필수/고급 API

```python
import heapq

# 기본: Min-Heap
h = []
heapq.heappush(h, 5)
heapq.heappush(h, 1)
heapq.heappush(h, 3)
x = heapq.heappop(h)   # 1
top = h[0]             # peek: 3

# 일괄 변환
arr = [7, 2, 9, 4]
heapq.heapify(arr)     # O(N), arr는 이제 힙

# push-pop 원패스 (성능 최적화)
heapq.heappushpop(h, 2)    # push 후 pop(최소) → 한 번의 sifting
heapq.heapreplace(h, 8)    # pop 후 push(항상 하나 제거/삽입)

# n최대/최소, 스트림 병합
import heapq as HQ
HQ.nlargest(3, data)       # 내부적으로 힙 사용
HQ.nsmallest(3, data)
for x in HQ.merge(sorted_a, sorted_b, sorted_c):  # 정렬 시퀀스 병합(제너레이터)
    ...
```

> `heappushpop` vs `heapreplace`: 평균적으로 **한 번의 재정렬**만 수행해 빠를 수 있습니다.  
> **대소 비교 비용이 큰 객체**라면 키만 유지하는 것이 성능에 유리합니다.

---

## 4) Max-Heap / 사용자 우선순위 / 동률 안정성

### 4.1 Max-Heap (부호 반전)

```python
h = []
heapq.heappush(h, -value)
max_val = -heapq.heappop(h)
```

### 4.2 사용자 우선순위: `(priority, payload)` 튜플

```python
# priority가 작을수록 우선
heapq.heappush(h, (prio, item))
prio, item = heapq.heappop(h)
```

### 4.3 동점(같은 우선순위)에서 **안정성(Stable)** 확보

- **주의**: `heapq`는 **안정 정렬이 아님**. 동률에서 입력순 보장 X  
- 해결: **단조 증가 카운터**를 tie-breaker로 넣기

```python
from itertools import count
counter = count()
heapq.heappush(h, (prio, next(counter), item))
```

---

## 5) 감소-키(Decrease-Key)와 **지연 삭제(Lazy Deletion)** 패턴

`heapq`에는 **decrease-key**가 없습니다. 일반 대안:

1) **새로운 (더 좋은) 키를 푸시**하고,  
2) 팝할 때 **이 항목이 최신인지** 확인하고 **무시**(지연 삭제)

다익스트라에서 흔히 쓰는 관용구:

```python
dist = [INF]*(n+1)
dist[s] = 0
pq = [(0, s)]   # (현재까지 비용, 정점)

while pq:
    d, u = heapq.heappop(pq)
    if d != dist[u]:           # 최신 아님 → 무시
        continue
    for v, w in graph[u]:
        nd = d + w
        if nd < dist[v]:
            dist[v] = nd
            heapq.heappush(pq, (nd, v))
```

---

## 6) 실전 패턴 & 템플릿

### 6.1 K-Way Merge (k개의 정렬 리스트 병합)

```python
import heapq

def merge_sorted(lists):
    pq = []
    for li, arr in enumerate(lists):
        if arr:
            heapq.heappush(pq, (arr[0], li, 0))
    out = []
    while pq:
        val, li, idx = heapq.heappop(pq)
        out.append(val)
        if idx+1 < len(lists[li]):
            nxt = lists[li][idx+1]
            heapq.heappush(pq, (nxt, li, idx+1))
    return out
```

### 6.2 스트리밍 Top-K(가장 큰 K개 유지)

```python
import heapq

def topk_stream(iterable, k):
    h = []
    for x in iterable:
        if len(h) < k:
            heapq.heappush(h, x)
        else:
            if x > h[0]:
                heapq.heapreplace(h, x)
    return sorted(h, reverse=True)
```

### 6.3 온라인 중앙값(중앙값 유지) — 두 힙

- **Max-Heap(L)**: 하위 절반 (파이썬은 음수화)
- **Min-Heap(R)**: 상위 절반  
- 균형 유지 후 중앙값은 `L` 루트(홀수) 또는 `L/R` 조합

```python
import heapq
def median_stream(seq):
    L, R = [], []   # L: max-heap(음수), R: min-heap
    medians = []
    for x in seq:
        if not L or x <= -L[0]:
            heapq.heappush(L, -x)
        else:
            heapq.heappush(R, x)
        # balance
        if len(L) > len(R) + 1:
            heapq.heappush(R, -heapq.heappop(L))
        elif len(R) > len(L):
            heapq.heappush(L, -heapq.heappop(R))
        # median
        medians.append(-L[0])
    return medians
```

### 6.4 이벤트 시뮬레이션(시간 우선)

```python
import heapq
def simulate(events):  # events: (time, payload)
    heapq.heapify(events)
    timeline = []
    while events:
        t, payload = heapq.heappop(events)
        timeline.append((t, payload))
        # 필요 시 새 이벤트 push
    return timeline
```

---

## 7) 그래프 알고리즘에서의 우선순위 큐

### 7.1 다익스트라 — 최단 경로 (양의 가중치)

```python
import sys, heapq
input = sys.stdin.readline

V, E = map(int, input().split())
S = int(input())
G = [[] for _ in range(V+1)]
for _ in range(E):
    u, v, w = map(int, input().split())
    G[u].append((v, w))

INF = 10**18
dist = [INF]*(V+1)
dist[S] = 0
pq = [(0, S)]

while pq:
    d, u = heapq.heappop(pq)
    if d != dist[u]: 
        continue
    for v, w in G[u]:
        nd = d + w
        if nd < dist[v]:
            dist[v] = nd
            heapq.heappush(pq, (nd, v))

for i in range(1, V+1):
    print(dist[i] if dist[i] < INF else "INF")
```

### 7.2 프림(Prim) — 최소 스패닝 트리(MST)

```python
def prim_mst(n, graph, start=1):
    visited = [False]*(n+1)
    pq = [(0, start)]
    total = 0
    while pq:
        w, u = heapq.heappop(pq)
        if visited[u]: 
            continue
        visited[u] = True
        total += w
        for v, cost in graph[u]:
            if not visited[v]:
                heapq.heappush(pq, (cost, v))
    return total
```

> 간선이 희소하고 가중치가 양수일 때 PQ의 효율이 큽니다.

---

## 8) 압축/코딩 — 허프만(Huffman) 트리

```python
import heapq

def huffman_cost(freqs):
    heap = freqs[:]         # freqs: [빈도...]
    heapq.heapify(heap)
    cost = 0
    while len(heap) > 1:
        a = heapq.heappop(heap)
        b = heapq.heappop(heap)
        s = a + b
        cost += s
        heapq.heappush(heap, s)
    return cost
```

> 백준 1715/13975(파일/카드 묶음)과 동일 패턴: **가장 작은 두 개를 반복 병합**.

---

## 9) 스케줄링 & 그리디 결합

### 9.1 회의실/강의실 배정(최소 강의실 수)

- 시작시간 기준 정렬, **종료시간 Min-Heap**으로 겹침 관리

```python
import heapq

def min_rooms(intervals):
    intervals.sort()  # (start, end)
    h = []
    for s, e in intervals:
        if h and h[0] <= s:
            heapq.heapreplace(h, e)
        else:
            heapq.heappush(h, e)
    return len(h)
```

### 9.2 보석 도둑(1202) / 작업 스케줄링

- **가방 용량 오름차순**으로 진행하며, 담을 수 있는 보석의 **가치 Max-Heap** 유지
- `heapq`로 Max-Heap: **음수화** 활용

```python
import heapq

def max_value(jewels, bags):
    jewels.sort()       # (w, v)
    bags.sort()
    ans = 0
    pq = []             # max-heap by value (negated)
    i = 0
    for cap in bags:
        while i < len(jewels) and jewels[i][0] <= cap:
            w, v = jewels[i]
            heapq.heappush(pq, -v)
            i += 1
        if pq:
            ans += -heapq.heappop(pq)
    return ans
```

---

## 10) 백준 실전 문제 카탈로그

| 번호 | 제목 | 핵심 |
|--|--|--|
| **11279** | 최대 힙 | Max-Heap(음수화) |
| **1927** | 최소 힙 | Min-Heap 기본 |
| **1715** | 카드 정렬하기 | 허프만 패턴 |
| **13975** | 파일 합치기 3 | 대용량 허프만 |
| **1655** | 가운데를 말해요 | 두 힙 중앙값 |
| **7662** | 이중 우선순위 큐 | 두 힙 + 지연 삭제 |
| **11286** | 절댓값 힙 | (abs(x), sign, x) 튜플 |
| **1202** | 보석 도둑 | 가치 Max-Heap |
| **1753** | 최단경로 | 다익스트라 |
| **1197** | 최소 스패닝 트리 | 프림(PQ) |
| **11000** | 강의실 배정 | 종료시간 Min-Heap |
| **15903** | 카드 합체 놀이 | 반복 최소 병합 |
| **1781** | 컵라면 | 마감일 정렬 + Min-Heap |

### 10.1 이중 우선순위 큐(7662) — 지연 삭제 구현 예

```python
import sys, heapq
input = sys.stdin.readline

T = int(input())
for _ in range(T):
    k = int(input())
    minH, maxH = [], []
    alive = dict()  # id -> True/False
    uid = 0

    def clean(h, sign):
        # sign=+1 for minH (value), sign=-1 for maxH (negated value)
        while h and not alive.get(h[0][1], False):
            heapq.heappop(h)

    for _ in range(k):
        op, x = input().split()
        x = int(x)
        if op == 'I':
            heapq.heappush(minH, (x, uid))
            heapq.heappush(maxH, (-x, uid))
            alive[uid] = True
            uid += 1
        else:
            if x == 1:   # delete max
                clean(maxH, -1)
                if maxH:
                    _, i = heapq.heappop(maxH)
                    alive[i] = False
            else:        # delete min
                clean(minH, +1)
                if minH:
                    _, i = heapq.heappop(minH)
                    alive[i] = False
        clean(minH, +1); clean(maxH, -1)
    clean(minH, +1); clean(maxH, -1)
    if not minH or not maxH:
        print("EMPTY")
    else:
        print(-maxH[0][0], minH[0][0])
```

---

## 11) 절댓값 힙(11286) — 사용자 우선순위

```python
import heapq, sys
input = sys.stdin.readline

n = int(input())
h = []
for _ in range(n):
    x = int(input())
    if x == 0:
        print(heapq.heappop(h)[1] if h else 0)
    else:
        heapq.heappush(h, (abs(x), 1 if x>=0 else 0, x))
```

> 키를 `(abs(x), sign, x)`로 두면 `abs` 우선, 그 다음 **작은 실제값** 우선 등 다양한 동작을 만들 수 있습니다.

---

## 12) 대용량/실전 팁

- **입출력**: `sys.stdin.readline`, `sys.stdout.write` 활용
- **메모리**: 지연 삭제 사용 시 **죽은 노드 폭증**을 주의(주기적으로 `clean` 호출)
- **튜플 비교 비용**: 키를 짧게, 비교 가능한 원시형으로
- **안정성**: 동률 처리 시 **counter 넣기**
- **타 언어**: C++는 `priority_queue`가 Max-Heap 기본, 커스텀 비교자 필요

---

## 13) 누가 힙을 쓰고 누가 안 쓰나?

| 문제 유형 | 힙 권장 | 이유 |
|--|--|--|
| **반복적으로 최솟값/최댓값** 추출 | ✅ | 매 번 \(O(\log N)\) |
| 상위 K개 유지(스트리밍) | ✅ | 크기 K로 제한 |
| 병합(k-way merge) | ✅ | 각 소스의 현재 포인터만 유지 |
| 전체 정렬 | ❌ | 그냥 `sort()`가 간단/빠름 |
| key 업데이트 자주 | ⚠️ | decrease-key 미지원 → 지연 삭제 패턴 필요 |
| 0-1 가중치 최단경로 | ❌ | **0-1 BFS(덱)**가 더 낫다 |

---

## 14) 검증 체크리스트(디버깅용)

- 힙의 **정렬 축**이 문제 요구와 일치하는가? (min vs max vs 사용자 키)
- **동률 처리** 규칙이 필요한가? (필요 시 counter)
- **지연 삭제** 시 최신성 검사(`if key != best[...]`)를 빼먹지 않았나?
- **입력 범위**가 커서 `int` 오버플로우/시간 초과 위험은 없는가?
- `heapify` 가능한가? 대량 삽입이면 `heapify`가 더 빠르다.

---

## 15) 수학적 시각(힙의 높이와 복잡도)

완전 이진트리 힙의 높이 \(h\)는 \( \lfloor \log_2 N \rfloor \).  
따라서 삽입/삭제의 **상한 복잡도**는
\[
T(N) = O(\log N)
\]
빌드 힙은 **상향식**으로 각 노드의 sifting 비용이 감소해
\[
\text{heapify} = O(N)
\]
을 달성합니다.

---

## 16) 마무리 요약

| 항목 | 정리 |
|--|--|
| 본질 | **가장 중요한 것부터 처리**하는 큐(대개 힙으로 구현) |
| 파이썬 | `heapq` = Min-Heap, Max는 **음수화** |
| 고급 | `heapify`, `heappushpop`, `heapreplace`, `merge`, `nlargest` |
| 패턴 | k-way merge, Top-K, 중앙값(두 힙), 이벤트 시뮬, 다익스트라/프림, 허프만 |
| 실전 | 동률 안정성은 **counter**로, decrease-key는 **지연 삭제**로 대체 |
| 문제셋 | 11279/1927/1715/13975/1655/7662/11286/1202/1753/1197/11000/15903 등 |

우선순위 큐는 **그리디/그래프/스트리밍**의 핵심 도구입니다. 위 패턴 템플릿을 익혀 두면, “가장 작은/큰 것을 반복적으로 뽑아 처리”하는 모든 문제를 **정석대로** 풀어낼 수 있습니다.