---
layout: post
title: Linux - 아이노드와 하드/소프트 링크
date: 2024-11-21 19:20:23 +0900
category: Linux
---
# 아이노드(inode)와 하드/소프트 링크 완전 분석

## 아이노드(inode)란 무엇인가

### 핵심 개념

**아이노드(inode)**는 파일 시스템에서 파일의 메타데이터를 저장하는 구조체입니다. 파일의 실제 내용(데이터)이 아닌, 파일에 대한 정보를 담고 있습니다. 디렉토리 엔트리는 파일 이름과 아이노드 번호를 매핑한 표에 불과하며, 실제 파일의 정체성은 아이노드에 있습니다.

### 아이노드에 포함되는 주요 정보

| 항목 | 설명 |
|---|---|
| 타입/퍼미션 | `st_mode`에 저장 (정규파일/디렉토리/링크/소켓/디바이스 등) |
| 소유자/그룹 | `st_uid`, `st_gid` |
| 크기 | `st_size` (바이트) |
| 시간 | `atime`(읽기), `mtime`(쓰기), `ctime`(메타데이터 변경) |
| 링크 수 | `st_nlink` (같은 아이노드를 가리키는 **이름**의 수) |
| 데이터 위치 | 직접/간접/이중/삼중 간접 블록 포인터(ext 계열) |
| 확장 메타 | xattr/ACL, 프로젝트 ID, 플래그(chattr) 등 |

> **핵심 원리**: 파일 이름은 디렉토리에 저장되고, 파일의 정체성은 아이노드에 있습니다. 파일 이름을 삭제해도(언링크) 아이노드가 살아 있고 참조 중이면 내용은 유지됩니다.

---

## 디렉토리/경로 해석: VFS가 파일을 여는 방법

### 경로 해석 순서

리눅스 가상 파일시스템(VFS)은 경로를 다음과 같은 순서로 해석합니다:

```
/home/user/a.txt
   └ 디렉토리 '/'에서 'home' 엔트리 → inode X
       └ inode X(디렉토리)에서 'user' 엔트리 → inode Y
           └ inode Y(디렉토리)에서 'a.txt' 엔트리 → inode Z
               └ inode Z(정규 파일) → 데이터 블록
```

### 심볼릭 링크 처리

- 심볼릭 링크를 만나면 커널은 링크의 내용(대상 경로 문자열)을 읽고 다시 경로 해석을 수행합니다
- **루프 방지**를 위해 심볼릭 링크 해석 깊이 제한이 존재합니다(보통 40단계)

### 캐시 시스템

- **dentry**: 경로 컴포넌트 해석 결과 캐시
- **inode cache**: 디스크 아이노드 메타데이터 캐시
- **page cache**: 파일 내용(페이지) 캐시
- 성능 문제의 상당수는 이 캐시들과의 동기화/미스/압축과 관련됩니다

---

## 하드 링크(하드링크, `ln`): **같은 아이노드**의 또 다른 이름

### 사용 방법

```bash
ln a.txt b.txt      # 동일 파일시스템(파티션) 내에서만 가능
ls -li a.txt b.txt  # 같은 inode 번호, 링크 수 2
```
- `a.txt`와 `b.txt`는 **동일한 아이노드**를 공유합니다
- **링크 수**(`st_nlink`)가 2로 증가합니다
- 내용, 퍼미션, 소유자는 공유되며 이름만 다릅니다

### 제약사항과 특징

- **서로 다른 파일시스템 간에는 불가능**합니다(아이노드 번호는 파일시스템 로컬 ID이기 때문)
- 일반적으로 **디렉토리에 하드링크를 만들 수 없습니다** (루프/순회 혼란 방지를 위해; `.`/`..`는 특수한 경우)
- **NFS 등 일부 파일시스템**은 하드링크 제한이 있거나 지원하지 않을 수 있습니다

### 삭제와 영속성

- `rm a.txt`는 **디렉토리 엔트리만 제거**하며, 링크 수를 1 감소시킵니다
- 링크 수가 0이 되고 **열린 파일 디스크립터(FD)가 없으면** 커널이 아이노드와 데이터 블록을 해제합니다(실제 삭제)

---

## 소프트 링크(심볼릭 링크, `ln -s`): **경로 문자열**을 담은 별도 inode

### 사용 방법

```bash
ln -s a.txt link.txt
ls -li a.txt link.txt
readlink link.txt      # → a.txt (대상 경로)
```
- `link.txt`는 **새로운 아이노드**를 가집니다 (파일 타입은 **심볼릭 링크**)
- 데이터 블록에는 **문자열 "a.txt"**(혹은 절대/상대경로)가 저장됩니다
- 원본 파일이 삭제되면 **깨진 링크**가 됩니다

### 장점

- **다른 파일시스템/파티션도 참조 가능**합니다
- 디렉토리에도 링크를 만들 수 있습니다(바로가기처럼)

### 주의사항

- 경로 해석이 추가되므로 하드링크에 비해 접근 오버헤드가 있습니다
- **보안**: TOCTOU(확인-사용 시간차) 문제에 주의해야 합니다. 루트 setuid 프로그램은 symlink 추적 제한을 종종 사용합니다

---

## 하드 링크와 소프트 링크 비교 요약

| 항목 | 하드 링크 (`ln`) | 소프트 링크 (`ln -s`) |
|---|---|---|
| 아이노드 공유 | O(같음) | X(다름) |
| 디스크 블록 | 공유 | 링크 자체는 경로 문자열 저장 |
| 링크 수 증가 | O | X |
| 원본 삭제 영향 | 다른 이름 남아있으면 안전 | 원본 사라지면 깨짐 |
| 파티션 제약 | 있음 | 없음 |
| 디렉토리 링크 | 일반적으로 금지 | 가능 |
| 성능 | 경로 해석 1회 | 경로 재해석 필요 |

---

## `stat`, `lstat`, `readlink`: 진단 기본기

```bash
stat a.txt
# inode, size, mode, nlink, uid/gid, times, device 등 출력

lstat link.txt
# symlink 자신에 대한 stat(링크 대상 아님)

readlink -f link.txt
# 링크 따라가 최종 실경로(실패 시 깨진 링크)
```

### 필드 읽기 포인트

- **st_ino**: 아이노드 번호
- **st_dev**: 디바이스(파일시스템) 번호 (하드링크는 st_dev/st_ino가 동일해야 함)
- **st_nlink**: 링크 수
- **st_mode**: 파일 타입/퍼미션 비트

---

## 삭제가 안 되는 파일? — **열린 FD와 unlink**

**핵심 개념**: 파일을 삭제해도 **열린 파일 디스크립터(FD)**가 남아 있으면 **디스크 공간은 유지**됩니다. 로그 순환/용량 누수 시 반드시 확인해야 합니다.

### 재현 코드(C)

```c
// gcc -Wall -O2 -o hold hold.c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>

int main() {
    int fd = open("big.log", O_CREAT|O_WRONLY|O_TRUNC, 0644);
    if (fd < 0) return 1;
    // 큰 데이터 작성
    for (int i=0; i<100000; ++i) {
        write(fd, "0123456789\n", 11);
    }
    // 파일 이름 삭제
    unlink("big.log");
    // 하지만 FD는 살아있다 → 공간 유지
    sleep(300); // 5분 홀드
    return 0;
}
```
다른 쉘에서 확인:
```bash
df -h .                         # 공간 여전히 점유
ls -l big.log                   # 없음
lsof +L1 | grep deleted         # 삭제됐지만 열린 파일 탐지
# 또는 /proc/<pid>/fd/ 로 확인
```
**해결 방법**: 프로세스를 종료하거나 FD를 닫으면 공간이 반환됩니다

---

## 원자적 교체 패턴: **임시파일 + rename**

애플리케이션/배포에서 **깨지지 않는 갱신**을 위해 사용하는 표준 패턴입니다:

```bash
# 임시 파일에 안전하게 쓰기
echo "new config" > config.new

# 권한/소유자 맞추기
chown app:app config.new && chmod 0644 config.new

# 원자적 교체
mv -T config.new config.yml   # 같은 디렉토리(같은 FS)여야 rename()이 원자적
```
- `rename()`은 **같은 파일시스템 내에서 원자적**으로 동작합니다
- 다중 프로세스가 읽는 설정·바이너리를 **틈 없이 교체**할 수 있습니다
- C에서 `renameat2(..., RENAME_NOREPLACE|RENAME_EXCHANGE)` 등 고급 옵션도 존재합니다

---

## ext4 아이노드 내부: 블록 포인터와 희소 파일

### 블록 포인터

- **직접(Direct)** 포인터 여러 개 + **간접/이중/삼중 간접** 포인터로 대용량 파일 주소화
- ext4는 extent로 연속 블록 범위를 표현하여 조각화를 완화합니다

### 희소 파일

```bash
truncate -s 10G image.raw     # 실제로는 구멍(hole), 즉시 10G 소모하지 않음
du -h image.raw               # 실제 사용 블록만 반영
ls -ls image.raw              # 첫 열 블록 수가 작게 나옴
```
- DB/VM 디스크 이미지에서 흔히 사용됩니다
- 백업 시 **holes** 보존 옵션이 필요합니다(`cp --sparse=always`, `rsync -S`)

---

## 아이노드 고갈(df -i)과 트러블슈팅

### 증상

- `No space left on device` 오류가 발생했는데 `df -h`는 공간이 남아있는 경우 → **아이노드 고갈** 가능성
```bash
df -i
```

### 원인과 대응

- 매우 많은 **자잘한 파일**이 생성된 경우(캐시/세션/shard)
- **정리/압축/병합** 전략, 디렉토리 설계 개선이 필요
- 파일시스템 생성 시 inode 밀도 조정(`mkfs.ext4 -T small` 등), 혹은 다른 파일시스템 선택

---

## xattr/ACL/chattr: 아이노드 확장 기능

### 확장 속성(xattr)과 ACL

```bash
# 확장 속성 설정
setfattr -n user.note -v "hello" a.txt
getfattr -d a.txt

# ACL 설정
setfacl -m u:alice:rw a.txt
getfacl a.txt
```

### 파일 플래그(chattr)

```bash
sudo chattr +i critical.conf   # immutable(루트도 변경 불가, 먼저 -i 필요)
sudo chattr +a appendonly.log  # append-only
lsattr critical.conf appendonly.log
```

---

## 시간 스탬프 최적화: atime/relatime/noatime

- **atime** 갱신은 읽기마다 쓰기를 유발하여 성능 비용이 발생합니다
- 기본값은 보통 **relatime**(읽기 많은 시스템에서 절충)
- 극단적 성능이 필요하면 마운트 옵션에 **noatime**을 고려합니다(요구사항 충족 시)

---

## 하드링크 활용: dedup/백업/배포

### 스냅샷풍 백업(rsync)

```bash
rsync -a --link-dest=/backup/prev /data/ /backup/today
```
- 변경되지 않은 파일은 **하드링크**로 재사용하여 공간을 절약하고 빠른 스냅샷을 제공합니다

### 컨텐츠 주소 배포

- 동일 바이너리/에셋 중복을 하드링크로 제거합니다
- 주의: 파일 변경은 **모든 이름에 반영**되므로 **절대 직접 수정 금지**. 새 파일로 만들고 rename으로 교체합니다

---

## symlink 실전: 절대 vs 상대, 보안 스위치

### 절대 경로 vs 상대 경로

```bash
ln -s /opt/app/bin/run /usr/local/bin/run  # 절대 경로
ln -s ../lib/lib.so ./lib.so               # 상대 경로
```
- 배포/이동이 많은 프로젝트는 **상대 링크**가 이식성에 유리합니다

### 보안 기법

- 루트 setuid 바이너리는 **symlink 우회 공격** 방지가 필요합니다
- 열 때 `O_NOFOLLOW`, `openat2()`의 `RESOLVE_NO_SYMLINKS` 등 사용(프로그래밍 측면)

---

## 파일시스템별 차이 비교

| 파일시스템 | inode 개념 | 하드링크 | reflink(복사-on-write) | 비고 |
|---|---|---|---|---|
| ext4 | 명시적 inode | O | X | 범용/안정 |
| XFS | inode 유사 | O | O(신규 버전) | 대용량/병렬 |
| btrfs | inode 유사 | O | O | 스냅샷/서브볼륨 |
| ZFS | inode 유사 | O | O(`zfs clone` 개념) | 체크섬/RAID-Z |
| FAT | 전통적 inode 없음(에뮬) | 제한 | X | 하드링크 제한/미지원 많음 |
| NTFS | MFT 레코드 | 하드링크 O | O(`reflink`) | 리눅스 ntfs3 드라이버 |

> **reflink**: 데이터 복사를 논리적으로 공유하는 복사-쓰기시(COW) 방식입니다. 하드링크는 **메타데이터까지 동일**하지만, reflink는 **내용 블록 공유**만 합니다.

---

## 컨테이너/오버레이/도커 레이어

- overlayfs/aufs는 상위/하위 레이어로 구성되며, **화이트아웃**(삭제 표시) 파일을 사용합니다
- 하드링크/아이노드 의미가 **레이어 경계를 넘으면 달라집니다**
- 이미지 레이어 간 **하드링크 불가**, 컨테이너 레이어 내부에서는 가능합니다

---

## 디렉토리 링크 수와 `.`/`..`

- 디렉토리의 `st_nlink`는 전통적으로 **자식 디렉토리 수 + 2**(`.`/`..`)로 계산되었습니다(현대 파일시스템은 다르게 보일 수도 있음)
- 일반적인 하드링크로 디렉토리 생성은 금지되어 있습니다(루프 위험)

---

## NFS/네트워크 파일시스템 주의사항

- 서버/클라이언트 마운트 옵션과 버전에 따라 **하드링크, 파일 잠금, atime** 동작이 다를 수 있습니다
- 빌드 캐시/공유 홈 디렉토리에서 **아이노드 번호 안정성**을 가정하면 안 됩니다(특히 도구가 st_ino로 동일성 판단 시)

---

## 실전 명령/패턴 모음

### inode 번호로 파일 찾기

```bash
ls -li
find . -xdev -inum <INO>
```

### 깨진 심볼릭 링크 일괄 제거(주의)

```bash
find . -xtype l -print
# 검토 후
find . -xtype l -delete
```

### 아이노드/슈퍼블록 점검(ext 계열)

```bash
sudo tune2fs -l /dev/sda1 | egrep 'Inode count|Block count|Inode size'
sudo debugfs -R 'stat <inode#>' /dev/sda1   # 고급
```

### 대규모 하드링크 중복 제거(동일 파일만)

```bash
# fdupes / rdfind / jdupes 등 사용
jdupes -L /path   # 동일 파일을 하드링크로 통합(검토 필수)
```

---

## 코드 예제: `stat/lstat/readlink` 한 번에 보기(C)

```c
/*
 * stat_demo.c
 * gcc -Wall -O2 -o stat_demo stat_demo.c
 */
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <limits.h>

void show(const char* path, int follow) {
    struct stat st;
    int rc = follow ? stat(path, &st) : lstat(path, &st);
    if (rc) { perror("stat"); return; }
    printf("[%s] (%s)\n", path, follow ? "stat" : "lstat");
    printf("  dev=%lu ino=%lu nlink=%lu mode=%o size=%ld\n",
           (unsigned long)st.st_dev, (unsigned long)st.st_ino,
           (unsigned long)st.st_nlink, st.st_mode, (long)st.st_size);
}

int main(int argc, char** argv){
    if (argc < 2){ fprintf(stderr,"usage: %s PATH\n", argv[0]); return 1; }
    show(argv[1], 0);
    show(argv[1], 1);
    char buf[PATH_MAX]; ssize_t n = readlink(argv[1], buf, sizeof(buf)-1);
    if (n > 0){ buf[n]='\0'; printf("  readlink: %s -> %s\n", argv[1], buf); }
    return 0;
}
```

---

## 퀵 레시피(운영)

- **로그 로테이션 후 용량 감소 없음** → `lsof +L1`로 **삭제된 파일 FD** 확인, **서비스 재시작**
- **"No space left on device"인데 공간 남음** → `df -i`로 **아이노드 고갈** 점검
- **안전한 설정 갱신** → 임시 파일에 쓰고 `mv -T`로 **원자 교체**
- **동일 콘텐츠 중복 제거** → `--link-dest`(rsync) 또는 `jdupes -L`
- **대규모 symlink 정검** → `find -xtype l -print`로 깨진 링크 탐지
- **성능 민감** → `noatime`/`relatime` 검토, 희소파일/대형 I/O 처리 고려

---

## 실습 세트

### 하드/소프트 링크 차이 관찰

```bash
rm -f a.txt b.txt link.txt
echo "hello" > a.txt
ln a.txt b.txt
ln -s a.txt link.txt
ls -li a.txt b.txt link.txt
stat a.txt b.txt link.txt
readlink link.txt
```

### unlink + open FD 실험

```bash
( echo "logs"; exec 3>app.log; rm -f app.log; sleep 120 ) &
lsof -p $! | grep deleted
```

### 희소파일과 사용량 비교

```bash
truncate -s 5G sparse.bin
dd if=/dev/zero of=full.bin bs=1M count=512 status=none
du -h sparse.bin full.bin
```

---

## 자주 묻는 질문(FAQ)

**Q1. 왜 디렉토리에 하드링크가 안 되나요?**
A. 트리 구조가 **그래프(사이클)**가 되어 이름 순회/정합(특히 `..`)이 깨지기 때문입니다. 파일시스템 무결성/백업/복구가 어려워집니다.

**Q2. `ctime`은 create time인가요?**
A. **Change time**(메타데이터 변경 시간)입니다. 생성 시간은 파일시스템/커널에 따라 별도 `crtime`(birth time)을 지원하기도 합니다(ext4 일부, btrfs, xfs 등; `statx`로 조회 가능).

**Q3. 하드링크로 "복사"하고 수정하면 어떻게 되나요?**
A. **둘 다 동시에 바뀝니다**(같은 아이노드이기 때문). 복사본을 독립적으로 바꾸려면 **진짜 복사**를 해야 합니다.

**Q4. 하드링크/심링크 최대 몇 개까지 만들 수 있나요?**
A. 파일시스템별로 제한이 다릅니다. ext4는 링크 수가 65k 수준입니다(디렉토리는 다르게 취급). 심링크는 경로 길이 제한이 있습니다(보통 수 kB).

---

## 명령어 치트시트

| 목적 | 명령 |
|---|---|
| inode/링크 수 확인 | `ls -li`, `stat`, `find -inum` |
| 심볼릭 링크 대상 확인 | `readlink -f` |
| 삭제됐지만 열린 파일 확인 | `lsof +L1` |
| 아이노드 고갈 확인 | `df -i` |
| 희소파일 복사 보존 | `cp --sparse=always` |
| 원자적 교체 | `mv -T tmp new` |
| 확장 속성/ACL | `getfattr/setfattr`, `getfacl/setfacl` |
| 파일 플래그 | `chattr`, `lsattr` |

---

## 결론

리눅스 파일 시스템의 아이노드와 링크 개념은 시스템 운영과 개발에 있어 필수적인 이해 요소입니다. 다음 핵심 원칙들을 기억하세요:

**아이노드의 본질 이해**:
파일의 실체는 아이노드이며, 파일 이름은 단지 디렉토리 엔트리에 불과합니다. 이 이해는 파일 삭제, 링크, 복사 등 모든 파일 작업의 기반이 됩니다.

**하드링크와 심볼릭 링크의 명확한 구분**:
- 하드링크는 **같은 아이노드의 또 다른 이름**으로, 동일 파일시스템 내에서만 생성 가능하며 원본과 완전히 동등합니다
- 심볼릭 링크는 **경로 문자열을 담은 별개의 파일**로, 파일시스템 경계를 넘어 참조할 수 있지만 원본 삭제 시 깨집니다

**실무 문제 해결 접근법**:
운영 환경에서 발생하는 파일 시스템 문제(공간 누수, 깨진 링크, 경쟁 상태 등)는 대부분 아이노드, 링크, 파일 디스크립터의 상호작용을 이해하면 효과적으로 해결할 수 있습니다. 특히:
- `lsof +L1`로 삭제되었지만 열린 파일 디스크립터를 가진 파일 확인
- `df -i`로 아이노드 고갈 문제 진단
- 임시 파일 작성 후 `mv -T`로 원자적 교체 패턴 적용

**성능과 보안 고려사항**:
- atime 갱신 최적화(`relatime`, `noatime`)
- 희소 파일을 통한 공간 효율적 관리
- 심볼릭 링크 보안 문제(TOCTOU)에 대한 대비

이러한 개념들을 체계적으로 이해하고 적용하면, 파일시스템 관련 문제를 효과적으로 진단하고 해결할 수 있으며, 더 나아가 효율적이고 안전한 시스템 설계와 운영이 가능해집니다. 아이노드와 링크는 단순한 기술 개념을 넘어 리눅스 파일 시스템의 철학과 설계 원리를 이해하는 중요한 창입니다.