---
layout: post
title: Linux - 아이노드와 하드/소프트 링크  
date: 2024-11-21 19:20:23 +0900
category: Linux
---
# 리눅스 20편: 아이노드(inode)와 하드/소프트 링크 완전 분석

> 리눅스 파일 시스템이 "파일을 인식하는 방식"을 inode 중심으로 해부

---

## 📦 1. 아이노드(inode)의 구조와 역할

리눅스에서 파일은 **“이름(name)” + “아이노드(inode)”**로 구성된 구조입니다.

### 🔧 아이노드란?

- **디스크 상의 파일 메타데이터를 담은 구조체**
- 파일의 **위치, 퍼미션, 소유자, 타임스탬프** 등은 아이노드에 저장
- 파일 이름은 **디렉토리 엔트리**에 존재하며, 실제 파일의 실체는 **아이노드 번호(inode number)**로 식별

### 📌 아이노드에 저장되는 정보

| 항목 | 설명 |
|------|------|
| 파일 유형 | 디렉토리, 일반 파일, 심볼릭 링크 등 |
| 권한 | rwxr-xr-- 형식의 퍼미션 |
| 소유자 UID / 그룹 GID | 파일의 소유 사용자/그룹 |
| 생성/수정/접근 시간 | ctime, mtime, atime |
| 파일 크기 | 바이트 단위 |
| 데이터 블록 위치 | 실제 저장된 데이터의 주소 |
| 링크 수 | 같은 아이노드를 가리키는 이름의 개수 |

📌 **파일 이름은 디렉토리에 저장되며, 실제 내용은 아이노드를 통해 접근**합니다.

### 🧱 디렉토리의 구조

디렉토리는 내부적으로는 **"파일 이름 ↔ 아이노드 번호" 쌍의 리스트**입니다.

즉, 리눅스에서는 다음의 순서로 접근하게 됩니다.

```
"파일 이름" → 디렉토리 엔트리 → 아이노드 번호 → 실제 파일 내용
```

---

## 🔗 2. `ln` - 하드 링크 : 이름만 추가, 아이노드는 동일

### 🧩 내부 동작

```bash
ln file1.txt file2.txt
```

- `file1.txt`의 아이노드 번호를 조회
- 해당 아이노드 번호를 `file2.txt`라는 이름으로 **같은 디렉토리(또는 동일 파티션)**에 등록
- 결과적으로 **두 이름이 하나의 아이노드를 공유**

### 📁 아이노드 변동 사항

- **아이노드 번호: 동일**
- **링크 수(link count): 기존 1 → 2로 증가**
- 퍼미션, 소유자, 크기, 내용 등은 공유됨
- 실제 파일 내용은 하나 → 두 파일이 같은 데이터 블록을 가리킴

### 🎯 왜 이렇게 되나?

- 리눅스는 파일 이름이 아닌 **아이노드 번호**를 기준으로 파일을 조작
- 따라서 이름이 다르더라도 같은 아이노드를 가리키면 **동일한 파일**

### 🧪 예시

```bash
$ ln a.txt b.txt
$ ls -li
100120 -rw-r--r-- 2 user user  100 Jul 13 17:00 a.txt
100120 -rw-r--r-- 2 user user  100 Jul 13 17:00 b.txt
```

- 두 파일의 아이노드 번호(`100120`)가 같음
- 링크 수는 2 → 둘 다 지워져야 아이노드의 데이터가 실제로 삭제됨

---

## 🔗 3. `ln -s` - 심볼릭 링크: 새로운 파일, 경로만 저장

### 🧩 내부 동작

```bash
ln -s file1.txt symlink.txt
```

- **새로운 아이노드를 할당받음 (새로운 파일 생성)**
- 데이터 블록에는 실제 `file1.txt`의 **경로 문자열(`file1.txt`)**을 저장
- symlink.txt는 **일반 파일처럼 보이지만**, 파일 시스템은 이를 **링크 타입**으로 인식
- symlink.txt가 열릴 때, 파일 시스템이 내부적으로 `"file1.txt"`를 다시 열도록 함

### 📁 아이노드 변동 사항

- **symlink.txt는 고유한 inode를 가짐**
- 내용은 `"file1.txt"`라는 **문자열이 저장**됨
- 타입은 `symbolic link`로 설정
- 원본 파일을 지우면 심볼릭 링크는 **깨짐** (broken link)

### 🧠 왜 이렇게 되나?

- 하드 링크는 아이노드를 공유해야 해서 **같은 파티션 내에서만 사용 가능**
- 심볼릭 링크는 **다른 파티션, 디렉토리, 심지어 네트워크 경로까지 참조 가능**
- 따라서 **경로 기반으로 참조**하는 구조를 선택

### 🧪 예시

```bash
$ ln -s a.txt link.txt
$ ls -li
100121 -rw-r--r-- 1 user user    100 Jul 13 17:01 a.txt
100122 lrwxrwxrwx 1 user user      6 Jul 13 17:02 link.txt -> a.txt
```

- `link.txt`는 새로운 inode 번호(`100122`)
- 이 아이노드의 데이터 블록에는 **단순 문자열 `"a.txt"`**만 저장됨

---

## 🧬 4. 아이노드 관점에서 비교 정리

| 항목 | 하드 링크 (`ln`) | 소프트 링크 (`ln -s`) |
|------|------------------|------------------------|
| 아이노드 공유 | O (같음) | X (각자 다름) |
| 디스크 블록 공유 | O | X (심볼릭 링크는 문자열 저장) |
| 링크 수 증가 | O | X |
| 파일 삭제 시 영향 | 남은 링크가 있으면 유지 | 원본 삭제되면 깨짐 |
| 파티션 제한 | 동일 파티션만 가능 | 경로 기반이라 자유로움 |
| 디렉토리 링크 | X (제한됨) | O |
| 성능 | 빠름 (직접 접근) | 간접 참조로 느림 |

---

## 🧪 실전 구조 예시

### [하드 링크 구조]
```text
/home/user/a.txt       → inode 1000 → "Hello World"
/home/user/b.txt       → inode 1000 → "Hello World"
```

### [소프트 링크 구조]
```text
/home/user/a.txt       → inode 1000 → "Hello World"
/home/user/link.txt    → inode 2000 → "a.txt" (경로 문자열)
```

---

## 🔍 관련 명령어 정리

| 명령어 | 설명 |
|--------|------|
| `ln` | 하드 링크 생성 |
| `ln -s` | 소프트 링크 생성 |
| `ls -li` | 아이노드 번호 보기 |
| `readlink` | 심볼릭 링크가 가리키는 실제 경로 확인 |
| `stat` | 링크 여부, 아이노드 상세 정보 보기 |

---

## ✨ 마무리

아이노드는 **리눅스 파일 시스템의 핵심 개념**입니다.  
하드 링크는 **실제 아이노드를 공유**하여 완벽한 "복제"를 만들고,  
심볼릭 링크는 **경로 문자열을 저장**하는 방식으로 다양한 환경에서 유연하게 작동합니다.

> 파일 시스템을 깊이 이해하려면, "파일 이름"이 아니라 "아이노드"를 중심으로 생각하는 습관이 필요합니다.