---
layout: post
title: Linux - 아이노드와 하드/소프트 링크
date: 2024-11-21 19:20:23 +0900
category: Linux
---
# 아이노드(inode)와 하드/소프트 링크 완전 분석

## 아이노드(inode)란 무엇인가

### 핵심 요약

- **아이노드(inode)**: 파일 **메타데이터**(타입/퍼미션/소유자/타임스탬프/데이터 블록 위치/링크 수 등)를 담는 구조체.
- **디렉토리 엔트리**: `"이름" → "아이노드 번호"`의 매핑 표.
- **실제 데이터**는 아이노드의 블록 포인터를 따라가 접근한다.
- **파일 이름은 파일의 본질이 아니다**. 이름을 지워도(언링크) 아이노드가 살아 있고 열려 있으면(참조 중) 내용은 유지된다.

### 아이노드에 보통 포함되는 것(대표)

| 항목 | 설명 |
|---|---|
| 타입/퍼미션 | `st_mode`에 저장 (정규파일/디렉토리/링크/소켓/디바이스 등) |
| 소유자/그룹 | `st_uid`, `st_gid` |
| 크기 | `st_size` (바이트) |
| 시간 | `atime`(읽기), `mtime`(쓰기), `ctime`(메타데이터 변경) |
| 링크 수 | `st_nlink` (같은 아이노드를 가리키는 **이름**의 수) |
| 데이터 위치 | 직접/간접/이중/삼중 간접 블록 포인터(ext 계열) |
| 확장 메타 | xattr/ACL, 프로젝트 ID, 플래그(chattr) 등 |

> **이름은 디렉토리**에, **파일의 정체성은 아이노드**에 있다.

---

## 디렉토리/경로 해석: VFS가 파일을 여는 법

### 경로 해석 순서(개념)

```
/home/user/a.txt
   └ 디렉토리 '/'에서 'home' 엔트리 → inode X
       └ inode X(디렉토리)에서 'user' 엔트리 → inode Y
           └ inode Y(디렉토리)에서 'a.txt' 엔트리 → inode Z
               └ inode Z(정규 파일) → 데이터 블록
```

### 심볼릭 링크가 있으면?

- 커널은 symlink의 **내용 문자열(대상 경로)**을 읽고 **다시 경로 해석**을 수행한다.
- **루프 방지**를 위해 **심볼릭 링크 해석 깊이 제한**(보통 40) 존재.

### dentry/inode/page cache(요약)

- **dentry**: 경로 컴포넌트 해석 결과 캐시.
- **inode cache**: 디스크 아이노드 메타데이터 캐시.
- **page cache**: 파일 내용(페이지) 캐시.
- 성능 문제의 상당수는 이 캐시들과 동기화/미스/압축과 관련된다.

---

## 하드 링크(하드링크, `ln`): **같은 아이노드**의 또 다른 이름

### 사용/동작

```bash
ln a.txt b.txt      # 동일 FS(파티션) 내에서만
ls -li a.txt b.txt  # 같은 inode 번호, 링크 수 2
```
- `a.txt`와 `b.txt`는 **동일 아이노드**. **링크 수**(`st_nlink`)가 2가 된다.
- 내용/퍼미션/소유자는 **공유**. 이름만 다르다.

### 제약/성질

- **서로 다른 파일시스템 간 불가**(아이노드 번호는 FS 로컬 ID).
- 일반적으로 **디렉토리에 하드링크 금지**(루프/순회 혼란 방지; `.`/`..`는 특수).
- **NFS 등 일부 FS**는 하드링크 제한/미지원일 수 있다.

### 삭제/영속성

- `rm a.txt`는 **디렉토리 엔트리만 제거**. 링크 수 1 감소.
- 링크 수가 0이 되고 **열린 FD가 없으면** 커널이 아이노드/블록을 해제(실제 삭제).

---

## 소프트 링크(심볼릭 링크, `ln -s`): **경로 문자열**을 담은 별도 inode

### 사용/동작

```bash
ln -s a.txt link.txt
ls -li a.txt link.txt
readlink link.txt      # → a.txt (대상 경로)
```
- `link.txt`는 **새로운 아이노드**. 파일 타입은 **심볼릭 링크**.
- 데이터 블록에는 **문자열 "a.txt"**(혹은 절대/상대경로)가 저장.
- 원본이 삭제되면 **깨진 링크**가 된다.

### 장점

- **다른 파일시스템/파티션도 참조 가능**.
- 디렉토리 링크 가능(바로가기처럼).

### 주의

- 경로 해석이 추가되므로 하드링크에 비해 접근 오버헤드가 있다.
- **보안**: TOCTOU(확인-사용 시간차) 문제에 조심. 루트 setuid 프로그램은 symlink 추적 제한을 종종 사용.

---

## 비교 요약

| 항목 | 하드 링크 (`ln`) | 소프트 링크 (`ln -s`) |
|---|---|---|
| 아이노드 공유 | O(같음) | X(다름) |
| 디스크 블록 | 공유 | 링크 자체는 경로 문자열 저장 |
| 링크 수 증가 | O | X |
| 원본 삭제 영향 | 다른 이름 남아있으면 안전 | 원본 사라지면 깨짐 |
| 파티션 제약 | 있음 | 없음 |
| 디렉토리 링크 | 일반적으로 금지 | 가능 |
| 성능 | 경로 해석 1회 | 경로 재해석 필요 |

---

## `stat`, `lstat`, `readlink`: 진단 기본기

```bash
stat a.txt
# inode, size, mode, nlink, uid/gid, times, device 등

lstat link.txt
# symlink 자신에 대한 stat(링크 대상 아님)

readlink -f link.txt
# 링크 따라가 최종 실경로(실패 시 깨진 링크)

```

### 필드 읽기 포인트

- **st_ino**: 아이노드 번호
- **st_dev**: 디바이스(파일시스템) 번호 (하드링크는 st_dev/st_ino가 동일해야 함)
- **st_nlink**: 링크 수
- **st_mode**: 파일 타입/퍼미션 비트

---

## 삭제가 안 되는 파일? — **열린 FD와 unlink**

**핵심**: 파일을 삭제해도 **열린 파일 디스크립터(FD)**가 남아 있으면 **디스크 공간은 유지**된다. 로그 순환/용량 누수 시 반드시 확인.

### 재현 코드(C)

```c
// gcc -Wall -O2 -o hold hold.c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>

int main() {
    int fd = open("big.log", O_CREAT|O_WRONLY|O_TRUNC, 0644);
    if (fd < 0) return 1;
    // 큰 데이터 작성
    for (int i=0; i<100000; ++i) {
        write(fd, "0123456789\n", 11);
    }
    // 파일 이름 삭제
    unlink("big.log");
    // 하지만 FD는 살아있다 → 공간 유지
    sleep(300); // 5분 홀드
    return 0;
}
```
다른 쉘에서:
```bash
df -h .                         # 공간 여전히 점유
ls -l big.log                   # 없음
lsof +L1 | grep deleted         # 삭제됐지만 열린 파일 탐지
# 또는 /proc/<pid>/fd/ 로 확인

```
**해결**: 프로세스를 종료하거나 FD 닫기 → 공간 반환.

---

## 원자적 교체 패턴: **임시파일 + rename**

애플리케이션/배포에서 **깨지지 않는 갱신**을 위해 쓰는 표준 패턴:

```bash
# 임시 파일에 안전하게 쓰기

echo "new config" > config.new

# 권한/소유자 맞추기

chown app:app config.new && chmod 0644 config.new

# 원자적 교체

mv -T config.new config.yml   # 같은 디렉토리(같은 FS)여야 rename()이 원자적
```
- `rename()`은 **같은 파일시스템 내에서 원자적**.
- 다중 프로세스가 읽는 설정·바이너리를 **틈 없이 교체**할 수 있다.
- C에서 `renameat2(..., RENAME_NOREPLACE|RENAME_EXCHANGE)` 등 고급 옵션도 존재.

---

## ext4 아이노드 내부: 블록 포인터와 희소 파일

### 블록 포인터

- **직접(Direct)** 포인터 여러 개 + **간접/이중/삼중 간접** 포인터로 대용량 파일 주소화.
- ext4는 extent로 연속 블록 범위를 표현(조각화 완화).

### 희소(sparse) 파일

```bash
truncate -s 10G image.raw     # 실제로는 구멍(hole), 즉시 10G 소모 X
du -h image.raw               # 실제 사용 블록만 반영
ls -ls image.raw              # 첫 열 블록 수가 작게 나옴
```
- DB/VM 디스크 이미지에서 흔함. 백업 시 **holes** 보존 옵션 필요(`cp --sparse=always`, `rsync -S`).

---

## 아이노드 고갈(df -i)과 트러블슈팅

### 증상

- `No space left on device`인데 `df -h`는 남아있다 → **아이노드 고갈** 가능.
```bash
df -i
```

### 원인/대응

- 매우 많은 **자잘한 파일** 생성(캐시/세션/shard).
- **정리/압축/병합** 전략, 디렉토리 설계 개선.
- 파일시스템 생성시 inode 밀도 조정(`mkfs.ext4 -T small` 등), 혹은 다른 FS 선택.

---

## xattr/ACL/chattr: 아이노드 확장 기능

### xattr(확장 속성) & ACL

```bash
# xattr

setfattr -n user.note -v "hello" a.txt
getfattr -d a.txt

# ACL

setfacl -m u:alice:rw a.txt
getfacl a.txt
```

### chattr(파일 플래그)

```bash
sudo chattr +i critical.conf   # immutable(루트도 못 바꿈, 먼저 -i)
sudo chattr +a appendonly.log  # append-only
lsattr critical.conf appendonly.log
```

---

## 시간 스탬프 최적화: atime/relatime/noatime

- **atime** 갱신은 읽기마다 쓰기를 유발 → 성능 비용.
- 기본은 보통 **relatime**(읽기 많은 시스템에서 절충).
- 극단적 성능이 필요하면 마운트 옵션에 **noatime** 고려(요구사항 충족 시).

---

## 하드링크 활용: dedup/백업/배포

### 스냅샷풍 백업(rsync)

```bash
rsync -a --link-dest=/backup/prev /data/ /backup/today
```
- 바뀌지 않은 파일은 **하드링크**로 재사용 → 공간 절약/빠른 스냅샷 느낌.

### 컨텐츠 주소 배포

- 동일 바이너리/에셋 중복을 하드링크로 제거.
- 주의: 파일 변경은 **모든 이름에 반영**되므로 **절대 직접 수정 금지**. 새 파일로 만들고 rename 교체.

---

## symlink 실전: 절대 vs 상대, 보안 스위치

### 절대 vs 상대

```bash
ln -s /opt/app/bin/run /usr/local/bin/run  # 절대 경로
ln -s ../lib/lib.so ./lib.so               # 상대 경로
```
- 배포/이동 많은 프로젝트는 **상대 링크**가 이식성에 유리.

### 보안 기법

- 루트 setuid 바이너리는 **symlink 우회 공격** 방지 필요.
- 열 때 `O_NOFOLLOW`, `openat2()`의 `RESOLVE_NO_SYMLINKS` 등 사용(프로그래밍 측면).

---

## 파일시스템별 차이(한눈)

| FS | inode 개념 | 하드링크 | reflink(복사-on-write) | 비고 |
|---|---|---|---|---|
| ext4 | 명시적 inode | O | X | 범용/안정 |
| XFS | inode 유사 | O | O(신규 버전) | 대용량/병렬 |
| btrfs | inode 유사 | O | O | 스냅샷/서브볼륨 |
| ZFS | inode 유사 | O | O(`zfs clone` 개념) | 체크섬/RAID-Z |
| FAT | 전통적 inode 없음(에뮬) | 제한 | X | 하드링크 제한/미지원 많음 |
| NTFS | MFT 레코드 | 하드링크 O | O(`reflink`) | 리눅스 ntfs3 드라이버 |

> **reflink**: 데이터 복사를 논리적으로 공유(COW). 하드링크는 **메타데이터까지 동일**, reflink는 **내용 블록 공유**만.

---

## 컨테이너/오버레이/도커 레이어

- overlayfs/aufs는 상위/하위 레이어로 구성, **화이트아웃**(삭제 표시) 파일을 사용.
- 하드링크/아이노드 의미가 **레이어 경계를 넘으면 달라짐**.
- 이미지 레이어 간 **하드링크 불가**, 컨테이너 레이어 내부에서는 가능.

---

## 디렉토리 링크 수와 `.`/`..`

- 디렉토리의 `st_nlink`는 **자식 디렉토리 수 + 2**(`.`/`..`)로 나타나는 전통 규칙이 있었다(현대 FS는 다르게 보일 수도).
- 일반적인 하드링크로 디렉토리 생성은 금지(루프 위험).

---

## NFS/네트워크 FS 주의

- 서버/클라이언트 마운트 옵션과 버전에 따라 **하드링크, 파일 잠금, atime** 동작이 다를 수 있다.
- 빌드 캐시/공유 홈 디렉토리에서 **아이노드 번호 안정성**을 가정하면 안 된다(특히 도구가 st_ino로 동일성 판단 시).

---

## 실전 명령/패턴 모음

### inode 번호로 파일 찾기

```bash
ls -li
find . -xdev -inum <INO>
```

### 깨진 심링크 일괄 제거(주의)

```bash
find . -xtype l -print
# 검토 후

find . -xtype l -delete
```

### 아이노드/슈퍼블록 점검(ext 계열)

```bash
sudo tune2fs -l /dev/sda1 | egrep 'Inode count|Block count|Inode size'
sudo debugfs -R 'stat <inode#>' /dev/sda1   # 고급
```

### 대규모 하드링크 중복 제거(동일 파일만)

```bash
# fdupes / rdfind / jdupes 등 사용

jdupes -L /path   # 동일 파일을 하드링크로 통합(검토 필수)
```

---

## 코드 예제: `stat/lstat/readlink` 한 번에 보기(C)

```c
/*
 * stat_demo.c
 * gcc -Wall -O2 -o stat_demo stat_demo.c
 */
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <limits.h>

void show(const char* path, int follow) {
    struct stat st;
    int rc = follow ? stat(path, &st) : lstat(path, &st);
    if (rc) { perror("stat"); return; }
    printf("[%s] (%s)\n", path, follow ? "stat" : "lstat");
    printf("  dev=%lu ino=%lu nlink=%lu mode=%o size=%ld\n",
           (unsigned long)st.st_dev, (unsigned long)st.st_ino,
           (unsigned long)st.st_nlink, st.st_mode, (long)st.st_size);
}

int main(int argc, char** argv){
    if (argc < 2){ fprintf(stderr,"usage: %s PATH\n", argv[0]); return 1; }
    show(argv[1], 0);
    show(argv[1], 1);
    char buf[PATH_MAX]; ssize_t n = readlink(argv[1], buf, sizeof(buf)-1);
    if (n > 0){ buf[n]='\0'; printf("  readlink: %s -> %s\n", argv[1], buf); }
    return 0;
}
```

---

## 퀵 레시피(운영)

- **로그 로테이션 후 용량 감소 없음** → `lsof +L1`로 **삭제된 파일 FD** 확인, **서비스 재시작**.
- **“No space left on device”인데 공간 남음** → `df -i`로 **아이노드 고갈** 점검.
- **안전한 설정 갱신** → 임시 파일에 쓰고 `mv -T`로 **원자 교체**.
- **동일 콘텐츠 중복 제거** → `--link-dest`(rsync) 또는 `jdupes -L`.
- **대규모 symlink 정검** → `find -xtype l -print`로 깨진 링크 탐지.
- **성능 민감** → `noatime`/`relatime` 검토, 희소파일/대형 I/O 처리 고려.

---

## 실습 세트

### 하드/소프트 링크 차이 관찰

```bash
rm -f a.txt b.txt link.txt
echo "hello" > a.txt
ln a.txt b.txt
ln -s a.txt link.txt
ls -li a.txt b.txt link.txt
stat a.txt b.txt link.txt
readlink link.txt
```

### unlink + open FD

```bash
( echo "logs"; exec 3>app.log; rm -f app.log; sleep 120 ) &
lsof -p $! | grep deleted
```

### 희소파일과 사용량 비교

```bash
truncate -s 5G sparse.bin
dd if=/dev/zero of=full.bin bs=1M count=512 status=none
du -h sparse.bin full.bin
```

---

## 자주 묻는 질문(FAQ)

**Q1. 왜 디렉토리에 하드링크가 안 되나?**
A. 트리 구조가 **그래프(사이클)**가 되어 이름 순회/정합(특히 `..`)이 깨진다. 파일시스템 무결성/백업/복구가 어렵다.

**Q2. `ctime`은 create time인가?**
A. **Change time**(메타데이터 변경 시간). 생성 시간은 FS/커널에 따라 별도 `crtime`(birth time)을 지원하기도 한다(ext4 일부, btrfs, xfs 등; `statx`로 조회).

**Q3. 하드링크로 “복사”하고 수정하면?**
A. **둘 다 동시에 바뀐다**(같은 아이노드). 복사본을 독립적으로 바꾸려면 **진짜 복사**를 해야 한다.

**Q4. 하드링크/심링크 최대 몇 개?**
A. FS별 제한. ext4는 링크 수가 65k 수준(디렉토리는 다르게 취급). 심링크는 경로 길이 제한(보통 수 kB).

---

## 명령어 치트시트

| 목적 | 명령 |
|---|---|
| inode/링크 수 확인 | `ls -li`, `stat`, `find -inum` |
| 심링크 대상 | `readlink -f` |
| 삭제됐지만 열린 파일 | `lsof +L1` |
| 아이노드 고갈 확인 | `df -i` |
| 희소파일 복사 보존 | `cp --sparse=always` |
| 원자적 교체 | `mv -T tmp new` |
| xattr/ACL | `getfattr/setfattr`, `getfacl/setfacl` |
| 파일 플래그 | `chattr`, `lsattr` |

---

## 마무리

핵심은 간단하다.
- **파일의 실체는 아이노드**이며, 이름은 디렉토리의 엔트리다.
- **하드링크**는 **같은 아이노드**의 또 다른 이름, **심링크**는 **경로 문자열**을 담은 별개 파일이다.
- 운영에서의 문제(공간 누수, 깨진 링크, 경쟁 상태)는 대부분 **아이노드/링크/FD의 상호작용**을 이해하면 빠르게 해결된다.
- 여기에 **원자 교체/로그 FD/희소 파일/아이노드 고갈/보안 플래그**까지 숙지하면, 파일시스템 운용의 90%는 제어 가능하다.
