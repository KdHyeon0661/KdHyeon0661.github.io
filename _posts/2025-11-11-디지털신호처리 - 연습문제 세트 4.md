---
layout: post
title: 디지털신호처리 - 연습문제 세트 4
date: 2025-11-11 21:25:23 +0900
category: 디지털신호처리
---
# 연습문제 세트 4

# A. 이산 푸리에 급수 (DFS)

## 문제 A1 — DFS 정의와 역변환 검증(증명형 + 수치형)
**목표**: \(N\)-주기 신호의 DFS 정의를 쓰고, 직교성으로 역변환을 유도하라. 수치로 Parseval까지 확인하라.

**정의**  
주기 \(N\)인 이산 신호 \(x[n]=x[n+N]\)의 DFS 계수:
$$
c_k = \frac{1}{N}\sum_{n=0}^{N-1} x[n] e^{-j\frac{2\pi}{N}kn},\quad k=0,\dots,N-1.
$$
역변환:
$$
x[n] = \sum_{k=0}^{N-1} c_k e^{j\frac{2\pi}{N}kn}.
$$

**유도 스케치**  
복소지수 직교성:
$$
\sum_{n=0}^{N-1} e^{j\frac{2\pi}{N}(k-\ell)n} = 
\begin{cases}
N,& k=\ell \ (\mathrm{mod}\ N)\\
0,& \text{otherwise}
\end{cases}
$$
을 이용해 역변환 양변에 \(e^{-j2\pi \ell n/N}\)을 곱해 합하면 \(c_\ell\)이 복원된다.

**Parseval**  
$$
\sum_{n=0}^{N-1}|x[n]|^2 = N\sum_{k=0}^{N-1}|c_k|^2.
$$

**Octave 검증**
```octave
clear; close all; clc
N=64; n=0:N-1;
x = 1.2*cos(2*pi*5*n/N + 0.3) + 0.7*sin(2*pi*12*n/N);
% DFS 계수 (DFT와 관계: c_k = X[k]/N)
X = fft(x); c = X / N;
x_rec = zeros(1,N);
for k=0:N-1
  x_rec += c(k+1)*exp(1j*2*pi*k*n/N);
end
fprintf("recon err = %.3e\n", norm(x - real(x_rec)));

lhs = sum(abs(x).^2);
rhs = N*sum(abs(c).^2);
fprintf("Parseval diff = %.3e\n", abs(lhs-rhs));
```

---

## 문제 A2 — DFS의 시프트/변조 성질(증명형 + 수치형)
**목표**: 원형 시프트와 주파수 변조가 DFS 계수에 주는 영향을 유도하고 검증.

**성질**
- 시간 시프트 \(y[n]=x[(n-n_0)\!\!\mod N]\) → \(d_k=c_k e^{-j2\pi kn_0/N}\).
- 주파수 변조 \(y[n]=x[n] e^{j2\pi m_0 n/N}\) → \(d_k=c_{k-m_0}\) (mod \(N\)).

**Octave 검증**
```octave
clear; close all; clc
N=64; n=0:N-1; n0=7; m0=9;
x = randn(1,N); X=fft(x); c=X/N;

y1 = x(mod(n-n0,N)+1); D1 = fft(y1)/N;
y2 = x .* exp(1j*2*pi*m0*n/N); D2=fft(y2)/N;

rel1 = norm(D1 - c .* exp(-1j*2*pi*(0:N-1)*n0/N))/norm(D1);
rel2 = norm(D2 - c(mod((0:N-1)-m0,N)+1))/norm(D2);
printf("shift rel-err=%.2e | mod rel-err=%.2e\n", rel1, rel2);
```

---

# B. 샘플링과 z-영역 복원

## 문제 B1 — 에일리어싱 주파수 계산과 싱크 복원 관찰(실습형)
**상황**: 연속 근사로 5 kHz 사인을 만들고, \(F_s=8\) kHz 로 샘플링한다. 에일리어싱 후 지각되는 주파수를 계산하고, 이상 싱크 복원과 ZOH 복원을 수치로 비교하라.

**이론**  
Nyquist 초과 톤 \(f_0\)는
$$
f_a = \left| f_0 - mF_s \right| \quad \text{(Nyquist 대역 안)}.
$$
이상 복원 파형은 에일리어싱 후 톤 \(f_a\)로 나타난다.

**Octave**
```octave
clear; close all; clc
Fs=8000; T=1/Fs; f0=5000;        % 5 kHz > Nyquist(4 kHz)
N=1024; n=0:N-1; x = sin(2*pi*f0*n*T);
fa = abs(f0 - round(f0/Fs)*Fs);
fprintf("Aliased frequency ≈ %.1f Hz\n", fa);

% sinc 복원 근사
Fs_cont=200e3; tc=0:1/Fs_cont:(N-1)*T;
K=40; xr=zeros(size(tc));
for i=1:numel(tc)
  u=(tc(i)-n*T)/T;
  s=sin(pi*u)./(pi*u); s(u==0)=1;
  idx=abs(u)<=K;
  xr(i)=sum(x(idx).*s(idx));
end
% ZOH 복원
xz=zeros(size(tc));
for i=1:N
  t0=(i-1)*T; t1=t0+T; idx=(tc>=t0)&(tc<t1); xz(idx)=x(i);
end
plot(tc*1e3,xr,'r',tc*1e3,xz,'b'); grid on; xlabel('ms'); legend('sinc','ZOH');
title('Aliasing: ideal vs ZOH reconstruction');
```

---

## 문제 B2 — ZOH 주파수 드룹 보정 프리엠퍼시스 설계(실습형)
**목표**: ZOH 응답
$$
H_{\text{ZOH}}(e^{j\omega}) = T\,e^{-j\omega/2}\,\mathrm{sinc}\!\left(\frac{\omega}{2}\right)
$$
에 대해 저주파(작은 \(\omega\)) 대역에서 평탄하도록 2차 IIR 프리엠퍼시스를 근사 설계하라.

**아이디어**: \(1/\mathrm{sinc}(\omega/2)\)의 저차 Pade 근사를 디지털화하거나, 최소제곱으로 IIR 주파수 샘플 피팅.

**Octave(간단 근사; FIR로도 가능)**
```octave
clear; close all; clc
w = linspace(0,0.6*pi,512);
Hdroop = (sin(w/2)./(w/2)); Hdroop(1)=1;    % ZOH/T, 크기만
% 6차 FIR로 평탄화 타깃 근사 (firls)
b = firls(20, [0 0.55 0.6 1], [1./Hdroop(1) 1./Hdroop(ceil(0.55/0.6*512)) 0 0]); % 대략적
% 실제 평탄화: |b(e^jw)| * |Hdroop| ≈ 1
B = freqz(b,1,w);
plot(w/pi, 20*log10(abs(B).*abs(Hdroop)) ); grid on
xlabel('\omega/\pi'); ylabel('dB'); title('ZOH droop pre-emphasis (rough FIR)');
```

---

# C. DFT와 그 성질

## 문제 C1 — Parseval과 단위수정 DFT(증명형 + 수치형)
**목표**: 단위수정(양변 \(1/\sqrt{N}\)) DFT에서 Parseval이 대칭형으로 성립함을 보이고, Octave로 검증하라.

**식**  
단위수정:
$$
\tilde X[k]=\frac{1}{\sqrt{N}}\sum_n x[n]e^{-j\frac{2\pi}{N}kn},\quad
x[n]=\frac{1}{\sqrt{N}}\sum_k \tilde X[k]e^{j\frac{2\pi}{N}kn}.
$$
Parseval:
$$
\sum_n|x[n]|^2 = \sum_k|\tilde X[k]|^2.
$$

**Octave 검증**
```octave
clear; close all; clc
N=1500; x=randn(1,N)+1j*randn(1,N);
X = fft(x)/sqrt(N); xr = ifft(X)*sqrt(N);
fprintf("recon err=%.3e | Parseval diff=%.3e\n", ...
  norm(x-xr)/norm(x), abs(sum(abs(x).^2) - sum(abs(X).^2)));
```

---

## 문제 C2 — 누출/스캘러핑/창의 CG·ENBW 수치 비교(실습형)
**목표**: 비정합 주파수 톤에서 창별 누출과 스캘러핑 손실을 비교하고, 정현파 진폭 추정 시 창의 Coherent Gain(CG)을 적용해 바이어스를 줄여라.

**핵심 식**  
창 적용 후 진폭 추정(단측):
$$
\hat A \approx \frac{2}{N\cdot \mathrm{CG}}\max_k |X_w[k]|.
$$

**Octave**
```octave
clear; close all; clc; pkg load signal
Fs=48000; N=4096; n=0:N-1; t=n/Fs;
f0 = (100 + 0.37)*Fs/N; x = cos(2*pi*f0*t);
W = {ones(1,N), hann(N)', hamming(N)', blackman(N)'};
CG= [1, mean(hann(N)), mean(hamming(N)), mean(blackman(N))]; % CG=창 평균
names={'rect','hann','hamm','black'};
for i=1:numel(W)
  X = fft(x.*W{i});
  [~,k] = max(abs(X));
  Aest = (2/(N*CG(i)))*abs(X(k));
  fprintf("%s : Aest=%.4f\n", names{i}, Aest);
end
```

---

# D. DFT를 이용한 선형 콘벌루션

## 문제 D1 — 제로패딩 임계조건 실험(실습형)
**목표**: \(N=L_x+L_h-2\)와 \(N=L_x+L_h-1\) 두 조건에서 wrap-around 오차를 비교.

**Octave**
```octave
clear; close all; clc
for trial=1:5
  Lx=randi([50,200]); Lh=randi([30,100]);
  x=randn(1,Lx); h=randn(1,Lh); Ly=Lx+Lh-1;
  y_ref = conv(x,h);

  N1=Ly-1; N2=Ly;
  y1 = ifft( fft([x zeros(1,N1-Lx)]) .* fft([h zeros(1,N1-Lh)]) ); y1=y1(1:Ly);
  y2 = ifft( fft([x zeros(1,N2-Lx)]) .* fft([h zeros(1,N2-Lh)]) ); y2=y2(1:Ly);
  printf("Trial %d: N=Ly-1 err=%.2e | N=Ly err=%.2e\n", trial, rms(y1-y_ref), rms(y2-y_ref));
end
```

---

## 문제 D2 — OLA/OLS의 동치성(실습형)
**목표**: 동일 신호/필터에서 OLA, OLS, `conv` 결과를 비교하여 RMS 오차를 보고하라.

**Octave (함수 포함)**
```octave
function y = conv_ola(x, h, L)
  M = numel(h); Nfft = 2^nextpow2(L + M - 1);
  H = fft([h zeros(1,Nfft-M)]);
  y = zeros(1, numel(x)+M-1);
  in_idx=1; out_idx=1;
  while in_idx <= numel(x)
    xe = x(in_idx:min(in_idx+L-1, numel(x)));
    yb = ifft( fft([xe zeros(1,Nfft-numel(xe))]) .* H );
    y(out_idx:out_idx+Nfft-1) += yb;
    in_idx += L; out_idx += L;
  endwhile
endfunction

function y = conv_ols(x, h, Nfft)
  M=numel(h); if Nfft<M, error("Nfft>=M"); end
  L = Nfft - M + 1; H=fft([h zeros(1,Nfft-M)]);
  y = []; overlap=zeros(1,M-1); idx=1;
  while idx <= numel(x)
    xe = x(idx:min(idx+L-1, numel(x))); blk=[overlap xe];
    if numel(blk)<Nfft, blk=[blk zeros(1,Nfft-numel(blk))]; end
    yb = ifft( fft(blk).*H ); y = [y yb(M:end)(1:min(L, numel(x)-idx+1))];
    overlap = blk(end-(M-2):end); idx += L;
  endwhile
  y = [y zeros(1, (numel(x)+M-1)-numel(y))]; y=y(1:numel(x)+M-1);
endfunction

clear; close all; clc
x=randn(1,40000); h=fir1(255,0.2); y_ref=conv(x,h);
y_ola=conv_ola(x,h,2048); y_ols=conv_ols(x,h,4096);
printf("RMS(OLA-ref)=%.2e | RMS(OLS-ref)=%.2e | RMS(OLA-OLS)=%.2e\n", ...
  rms(y_ola-y_ref), rms(y_ols-y_ref), rms(y_ola-y_ols));
```

---

# E. 고속 푸리에 변환(FFT)

## 문제 E1 — Radix-2 DIT FFT 구현 및 검증(실습형)
**목표**: Radix-2 DIT FFT를 직접 구현하고, `fft`와 상대오차를 비교하라.

**핵심식**  
짝/홀 분해로
$$
X[k] = E[k] + W_N^k O[k],\quad X[k+\tfrac{N}{2}] = E[k] - W_N^k O[k].
$$

**Octave**
```octave
function y=bitrev_permute(x)
  N=numel(x); b=log2(N); y=zeros(size(x)); 
  for n=0:N-1, r=0; t=n;
    for i=1:b, r=bitshift(r,1)+bitand(t,1); t=bitshift(t,-1); end
    y(r+1)=x(n+1);
  end
end

function X=myfft_radix2(x)
  x=x(:).'; N=numel(x);
  if bitand(N,N-1)~=0, error("power-of-two"); end
  X=bitrev_permute(x);
  m=2; while m<=N
    half=m/2; W=exp(-1j*2*pi*(0:half-1)/m);
    for k=1:m:N
      i1=k:(k+half-1); i2=(k+half):(k+m-1);
      t=W.*X(i2); u=X(i1); X(i1)=u+t; X(i2)=u-t;
    end
    m*=2;
  endwhile
end

clear; close all; clc
N=1024; x=randn(1,N)+1j*randn(1,N);
X_ref=fft(x); X_my=myfft_radix2(x);
fprintf("rel-err FFT=%.3e\n", norm(X_ref-X_my)/norm(X_ref));
```

---

## 문제 E2 — Bluestein(Chirp-Z)로 소수 길이 FFT(실습형)
**목표**: 소수 길이 \(N=97\)에서 Bluestein으로 FFT를 계산하고 `fft`와 오차를 비교하라.

**Octave(간략 구현)**
```octave
function X = bluestein_fft(x)
  x=x(:).'; N=numel(x); n=0:N-1;
  a = x .* exp(-1j*pi*(n.^2)/N);
  b = exp( 1j*pi*(n.^2)/N);
  L=2*N-1; P=2^nextpow2(L);
  A=fft([a zeros(1,P-N)]); B=fft([b zeros(1,P-N)]);
  C=ifft(A.*B); c=C(1:N);
  X = exp(-1j*pi*(n.^2)/N).*c;
end

clear; close all; clc
N=97; x=randn(1,N)+1j*randn(1,N);
Xb=bluestein_fft(x); Xr=fft(x);
fprintf("N=%d | rel-err=%.3e\n", N, norm(Xb-Xr)/norm(Xr));
```

---

## 문제 E3 — FFT 연산량 카운트(증명형 + 계산형)
**목표**: Radix-2 DIT의 복소 곱/합 개수를 유도하고 코드로 확인하라.

**식**  
스테이지 \(p=\log_2 N\):  
- 복소 곱: \(\frac{N}{2}\log_2 N\)  
- 복소 합: \(N\log_2 N\)

**Octave**
```octave
function [mulc, addc]=count_ops_radix2(N)
  p=log2(N); mulc=(N/2)*p; addc=N*p;
end
for N=[8 16 1024 4096]
  [m,a]=count_ops_radix2(N);
  printf("N=%d | mul=%d add=%d\n",N,m,a);
end
```

---

# F. 종합 실습: 하나로 엮기

## 문제 F1 — DFS→DTFT 대응·샘플링·DFT·FFT 전 과정 파이프라인(실습형)
**목표**: 다음 파이프라인을 구현하고 각 단계에서 이론과 수치가 일치하는지 확인하라.

1) 주기 \(N\) 신호 \(x[n]\) 생성 → DFS \(c_k\) 계산  
2) 샘플링 주파수 \(F_s\) 설정, 물리 주파수축 \(f_k\) 맵핑  
3) DFT \(X[k]\)와 DFS 관계 \(c_k = X[k]/N\) 확인  
4) 비정합 주파수에서 창과 제로패딩으로 스펙트럼 보간  
5) DFT 곱으로 FIR 선형 필터링(제로패딩)  
6) 긴 필터에서 OLA/OLS 비교  
7) 같은 데이터를 Radix-2 자작 FFT/ Bluestein으로도 계산해 `fft`와 비교

**Octave 스케치(핵심 단계만)**
```octave
clear; close all; clc; pkg load signal
Fs=48000; N=1024; n=0:N-1; t=n/Fs;
x = 1.0*cos(2*pi*1234.5*t) + 0.4*cos(2*pi*4321.2*t + 0.3);

% 1) DFT/DFS
X=fft(x); ck=X/N; x_rec=real(ifft(X)); 
fprintf("recon err=%.3e | DFS relation err=%.3e\n", norm(x-x_rec)/norm(x), ...
  norm(ck - X/N)/norm(ck));

% 2) 주파수축
f=(0:N-1)*Fs/N;

% 3) 창/제로패딩 보간
w=hann(N)'; Xw=fft(x.*w, 16384); fw=(0:16383)*Fs/16384;

% 4) FIR 필터링 by DFT (제로패딩)
h=fir1(127, 0.2); Ly=N+numel(h)-1; Nz=2^nextpow2(Ly);
y = ifft( fft([x zeros(1,Nz-N)]) .* fft([h zeros(1,Nz-numel(h))]) );
y = y(1:Ly); y_ref=conv(x,h);
fprintf("DFT conv err=%.2e\n", rms(y-y_ref));

% 5) 긴 필터에서 OLA/OLS 비교
xlong=[x randn(1,40000)]; hlong=fir1(511,0.15);
% (여기서는 앞서 정의한 conv_ola, conv_ols 함수를 붙여넣어 사용)
```

---

# 부록. 정답/풀이 요지 요약

- **A1**: 직교합으로 역변환, Parseval은 직교기저의 에너지 보존. 수치 오차는 ~1e-15.  
- **A2**: 시프트→선형 위상, 변조→스펙트럼 시프트(DFS/DFT 모두 동일 패턴).  
- **B1**: \(f_a=|f_0-mF_s|\). 이상 복원은 \(f_a\) 톤 회복, ZOH는 계단 + 고주파 이미징.  
- **B2**: \(1/\mathrm{sinc}\) 평탄화를 FIR/IIR 근사. 대역 내 오차를 dB로 확인.  
- **C1**: 단위수정 DFT는 Parseval이 대칭형. 수치 검증.  
- **C2**: 창별 누출/스캘러핑 비교, CG로 진폭 보정.  
- **D1**: \(N\ge L_x+L_h-1\)에서 wrap 없음. \(N=Ly-1\)은 큰 오차.  
- **D2**: OLA/OLS 모두 `conv`와 일치(수치 오차 수준).  
- **E1**: Radix-2 자작 FFT가 `fft`와 상대오차 ~1e-12.  
- **E2**: Bluestein으로 소수 길이 FFT 구현 가능(`fft`와 오차 ~1e-12~1e-10).  
- **E3**: 연산 카운트는 \((N/2)\log_2N\) 곱, \(N\log_2N\) 합.  
- **F1**: 파이프라인 전체의 이론-수치 일치 확인.
