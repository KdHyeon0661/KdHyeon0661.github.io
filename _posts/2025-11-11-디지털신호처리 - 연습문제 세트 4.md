---
layout: post
title: 디지털신호처리 - 연습문제 세트 4
date: 2025-11-11 21:25:23 +0900
category: 디지털신호처리
---
# 연습문제 세트 4 풀이 — DFS·샘플링·DFT·FFT

## A. 이산 푸리에 급수 (DFS)

### A1 — DFS 정의와 역변환 검증(증명형 + 수치형)

#### A1.1 문제 재진술
주기 $$N$$ 인 이산 신호 $$x[n]=x[n+N]$$ 에 대해 DFS 계수 $$c_k$$ 를 정의하고, 복소지수 직교성을 이용해 역변환을 유도하라. 또한 Parseval 등식을 수치로 검증하라.

#### A1.2 DFS의 의미(직관)
DFS는 “**유한 길이 N 구간**에 대해, 복소지수 기저 $$e^{j\frac{2\pi}{N}kn}$$ 로 신호를 표현”하는 방식이다.

- DFS는 DTFT(연속 주파수)와 달리 **주파수가 N개로 양자화**되어 있다.
- DFS는 DFT와 같은 수학 구조를 가지며, 다만 **정규화 위치가 다름**.  
  즉, DFT를 $$X[k]$$ 라 하면  
  $$c_k = \frac{X[k]}{N}$$
  이다.

#### A1.3 복소지수 직교성 증명
핵심 성질은 다음 직교 합이다.

$$
\sum_{n=0}^{N-1} e^{j\frac{2\pi}{N}(k-\ell)n} =
\begin{cases}
N,& k=\ell \ (\text{mod }N)\\
0,& \text{otherwise}
\end{cases}
$$

**증명 스케치**:

1) $$k\neq \ell$$ 일 때, 등비수열 합을 사용한다.  
비율을 $$r = e^{j\frac{2\pi}{N}(k-\ell)}$$ 라 두면

$$
S = \sum_{n=0}^{N-1} r^n = \frac{1-r^N}{1-r}.
$$

2) $$r^N = e^{j2\pi(k-\ell)} = 1$$ 이므로

$$
S = \frac{1-1}{1-r} = 0.
$$

3) $$k=\ell$$ 일 때는 모든 항이 1이므로

$$
S = \sum_{n=0}^{N-1} 1 = N.
$$

끝.

#### A1.4 역변환 유도(정확한 증명)
DFS 정의:

$$
c_k = \frac{1}{N}\sum_{n=0}^{N-1} x[n] e^{-j\frac{2\pi}{N}kn}
$$

역변환을 보이기 위해, 후보식

$$
\hat x[n]=\sum_{k=0}^{N-1} c_k e^{j\frac{2\pi}{N}kn}
$$

이 실제 $$x[n]$$ 과 같음을 증명한다.

1) $$\hat x[n]$$ 에 DFS 정의를 대입:

$$
\hat x[n]=\sum_{k=0}^{N-1} \left(\frac{1}{N}\sum_{m=0}^{N-1} x[m] e^{-j\frac{2\pi}{N}km}\right) e^{j\frac{2\pi}{N}kn}.
$$

2) 합 순서를 교환:

$$
\hat x[n]=\frac{1}{N}\sum_{m=0}^{N-1} x[m]\sum_{k=0}^{N-1} e^{j\frac{2\pi}{N}k(n-m)}.
$$

3) 내부 합은 직교성에 의해

$$
\sum_{k=0}^{N-1} e^{j\frac{2\pi}{N}k(n-m)}=
\begin{cases}
N,& n=m\ (\text{mod }N)\\
0,& \text{otherwise}
\end{cases}
$$

4) 따라서

$$
\hat x[n]=\frac{1}{N}\sum_{m=0}^{N-1} x[m]\cdot N\cdot \delta_{n,m}
= x[n].
$$

즉 후보식이 역변환이다.

#### A1.5 Parseval 등식 유도
$$\{e^{j\frac{2\pi}{N}kn}\}$$ 는 길이 $$N$$ 공간(복소 벡터 공간)에서 직교 기저다.  
직교 기저로 전개된 계수는 에너지를 보존하므로 Parseval이 성립한다.

**증명**:

1) 역변환을 써서 에너지 계산:

$$
\sum_{n=0}^{N-1}|x[n]|^2
= \sum_{n=0}^{N-1} x[n]\overline{x[n]}.
$$

2) $$x[n]=\sum_k c_k e^{j\frac{2\pi}{N}kn}$$ 대입:

$$
\sum_n\left(\sum_k c_k e^{j\frac{2\pi}{N}kn}\right)
\left(\sum_\ell \overline{c_\ell} e^{-j\frac{2\pi}{N}\ell n}\right)
=
\sum_{k,\ell} c_k\overline{c_\ell}\sum_n e^{j\frac{2\pi}{N}(k-\ell)n}.
$$

3) 직교성으로 $$k\neq \ell$$ 항은 사라지고 $$k=\ell$$ 만 남음:

$$
= \sum_k c_k\overline{c_k}\cdot N
= N\sum_k |c_k|^2.
$$

따라서

$$
\sum_{n=0}^{N-1}|x[n]|^2 = N\sum_{k=0}^{N-1}|c_k|^2.
$$

#### A1.6 실습 포인트(수치 검증)
- FFT 오차는 보통 $$10^{-15}$$ 수준으로 작다(부동소수점 한계).
- `real()`을 붙여 복원 신호를 실수로 투영하는 건, 원래 신호가 실수일 때만 안전하다.
- Parseval 검증은 신호가 복소라도 그대로 성립한다.

**확장 Octave 코드(원본 + 추가 확인)**

```octave
clear; close all; clc

N=64; n=0:N-1;
x = 1.2*cos(2*pi*5*n/N + 0.3) + 0.7*sin(2*pi*12*n/N);

% DFS 계수
X = fft(x); 
c = X / N;

% 역변환(직접 합)
x_rec = zeros(1,N);
for k=0:N-1
  x_rec += c(k+1)*exp(1j*2*pi*k*n/N);
end

% 재구성 오차
recon_err = norm(x - real(x_rec));
fprintf("recon err = %.3e\n", recon_err);

% Parseval
lhs = sum(abs(x).^2);
rhs = N*sum(abs(c).^2);
fprintf("Parseval diff = %.3e\n", abs(lhs-rhs));

% 추가: DFT 관계 확인
fprintf("||c - X/N|| = %.3e\n", norm(c - X/N));
```

---

### A2 — DFS의 시프트/변조 성질(증명형 + 수치형)

#### A2.1 원형 시프트 성질 유도
시간 원형 시프트:

$$
y[n]=x[(n-n_0)\ \text{mod}\ N]
$$

DFS 계수를 $$d_k$$ 라 하면

$$
d_k = c_k e^{-j\frac{2\pi}{N}kn_0}.
$$

**증명**:

1) 정의에서 시작:

$$
d_k = \frac{1}{N}\sum_{n=0}^{N-1} y[n] e^{-j\frac{2\pi}{N}kn}
= \frac{1}{N}\sum_{n=0}^{N-1} x[n-n_0] e^{-j\frac{2\pi}{N}kn}.
$$

2) 치환 $$m=n-n_0$$ (원형이므로 합 구간은 그대로):

$$
d_k = \frac{1}{N}\sum_{m=0}^{N-1} x[m] e^{-j\frac{2\pi}{N}k(m+n_0)}
= e^{-j\frac{2\pi}{N}kn_0}\frac{1}{N}\sum_m x[m]e^{-j\frac{2\pi}{N}km}.
$$

3) 뒤가 $$c_k$$ 이므로 성립.

**직관**: 시간 이동은 “주파수 영역 선형 위상(phase ramp)”을 만든다.

#### A2.2 주파수 변조 성질 유도
주파수 변조(복소 지수 곱):

$$
y[n] = x[n] e^{j\frac{2\pi}{N} m_0 n}.
$$

그러면

$$
d_k = c_{k-m_0}\quad (\text{mod }N).
$$

**증명**:

$$
d_k=\frac{1}{N}\sum_n x[n] e^{j\frac{2\pi}{N}m_0 n} e^{-j\frac{2\pi}{N}kn}
=\frac{1}{N}\sum_n x[n] e^{-j\frac{2\pi}{N}(k-m_0)n}
= c_{k-m_0}.
$$

**직관**: 시간에서 복소 지수를 곱하면 스펙트럼이 옆으로 회전(이동)한다.

#### A2.3 실습 포인트
- Octave에서 `mod`는 0 기반/1 기반 인덱스가 섞이기 쉬우니  
  `mod(idx,N)+1` 패턴을 항상 유지.
- 변조는 복소 결과가 될 수 있으니 실험 신호를 실수/복소 모두 시험 가능.

**검증 코드(원본 유지)**

```octave
clear; close all; clc
N=64; n=0:N-1; n0=7; m0=9;
x = randn(1,N); X=fft(x); c=X/N;

% 원형 시프트
y1 = x(mod(n-n0,N)+1); 
D1 = fft(y1)/N;

% 주파수 변조
y2 = x .* exp(1j*2*pi*m0*n/N); 
D2 = fft(y2)/N;

rel1 = norm(D1 - c .* exp(-1j*2*pi*(0:N-1)*n0/N))/norm(D1);
rel2 = norm(D2 - c(mod((0:N-1)-m0,N)+1))/norm(D2);
printf("shift rel-err=%.2e | mod rel-err=%.2e\n", rel1, rel2);
```

---

## B. 샘플링과 z-영역 복원

### B1 — 에일리어싱 주파수 계산과 싱크 복원 관찰(실습형)

#### B1.1 문제 재진술
연속 근사로 $$5\ \text{kHz}$$ 사인을 만들고 샘플링 주파수 $$F_s=8\ \text{kHz}$$ 로 표본화한다.  
에일리어싱 후 지각되는 주파수 $$f_a$$ 를 계산하고, 이상적 sinc 복원과 ZOH 복원을 비교하라.

#### B1.2 에일리어싱 주파수 공식
Nyquist 주파수는 $$F_s/2 = 4\ \text{kHz}$$ 이므로 $$f_0=5\ \text{kHz}$$ 는 초과한다.  
샘플링 후 스펙트럼은 $$F_s$$ 마다 복제되며, **Nyquist 대역으로 접혀 들어온 주파수**가 에일리어싱 톤이다.

일반식:

$$
f_a = |f_0 - mF_s|
$$

여기서 $$m$$ 은 $$f_a$$ 가 $$[0, F_s/2]$$ 안에 들어오도록 선택하는 정수.

**이번 예**:

- $$f_0/F_s = 5000/8000 = 0.625$$ 이므로  
  가장 가까운 정수는 $$m=1$$.
- 따라서

$$
f_a=|5000-1\cdot 8000|=3000\ \text{Hz}.
$$

즉 5 kHz 톤을 8 kHz로 샘플링하면 **3 kHz 톤으로 들린다**.

#### B1.3 이상 sinc 복원 vs ZOH 복원
**이상 sinc 복원(ideal reconstruction)**  
샘플 값들을 sinc로 이어붙인 연속 신호:

$$
x_r(t)=\sum_{n=-\infty}^{\infty} x[n]\ \text{sinc}\left(\frac{t-nT}{T}\right).
$$

- 이상적 저역통과 필터로 모든 이미지가 제거된다.
- 결국 에일리어싱 된 기본 대역 $$f_a$$ 의 순수 사인만 나타난다.

**ZOH 복원(Zero-Order Hold)**  
각 샘플을 다음 샘플까지 **계단형으로 유지**:

- 시간 영역: 계단 파형 → 고주파 성분 증가.
- 주파수 영역: 크기 응답이 sinc 형태로 **드룹(droop)** 발생.

#### B1.4 실습 포인트
- sinc 복원은 무한 합이라 근사 창(커널 길이 $$K$$)이 필요.
- $$K$$ 가 커질수록 이상 복원에 가까워지지만 계산량 증가.
- ZOH는 단순하지만 주파수 왜곡이 생김 → B2에서 보정.

**실습 코드(원본 유지)**

```octave
clear; close all; clc
Fs=8000; T=1/Fs; f0=5000;
N=1024; n=0:N-1; x = sin(2*pi*f0*n*T);

fa = abs(f0 - round(f0/Fs)*Fs);
fprintf("Aliased frequency ≈ %.1f Hz\n", fa);

% sinc 복원 근사
Fs_cont=200e3; tc=0:1/Fs_cont:(N-1)*T;
K=40; xr=zeros(size(tc));
for i=1:numel(tc)
  u=(tc(i)-n*T)/T;
  s=sin(pi*u)./(pi*u); s(u==0)=1;
  idx=abs(u)<=K;
  xr(i)=sum(x(idx).*s(idx));
end

% ZOH 복원
xz=zeros(size(tc));
for i=1:N
  t0=(i-1)*T; t1=t0+T; idx=(tc>=t0)&(tc<t1); xz(idx)=x(i);
end

plot(tc*1e3,xr,'r',tc*1e3,xz,'b'); grid on; 
xlabel('ms'); legend('sinc','ZOH');
title('Aliasing: ideal vs ZOH reconstruction');
```

#### B1.5 추가 확인(FFT로 에일리어싱 톤 관찰)
샘플 $$x[n]$$ 의 DFT에서 피크가 $$f_a=3\ \text{kHz}$$ 위치에 뜨는지 확인.

```octave
N=1024; 
X=fft(x);
f=(0:N-1)*Fs/N;
[~,kmax]=max(abs(X(1:N/2)));
fprintf("DFT peak = %.1f Hz\n", f(kmax));
```

---

### B2 — ZOH 주파수 드룹 보정 프리엠퍼시스 설계(실습형)

#### B2.1 문제 재진술
ZOH 주파수 응답

$$
H_{\text{ZOH}}(e^{j\omega}) = T e^{-j\omega/2}\ \text{sinc}\left(\frac{\omega}{2}\right)
$$

의 드룹을 저주파 대역에서 평탄화하도록 2차 IIR(또는 저차 FIR) 프리엠퍼시스를 근사 설계하라.

#### B2.2 드룹의 원인과 크기 응답
ZOH는 시간에서 “사각 펄스(hold)”를 컨볼루션한 것과 같고, 그 주파수 응답은 sinc로 떨어진다.

크기만 보면(상수 $$T$$ 제외):

$$
|H_{\text{ZOH}}(e^{j\omega})| = \left|\text{sinc}\left(\frac{\omega}{2}\right)\right|.
$$

- $$\omega=0$$ 에서 1.
- $$\omega$$ 가 증가할수록 점점 감소.
- 특히 Nyquist 근처에서 크게 감소.

#### B2.3 프리엠퍼시스의 목표
프리엠퍼시스 필터 $$G(e^{j\omega})$$ 를 앞단에 달아

$$
|G(e^{j\omega})|\cdot |H_{\text{ZOH}}(e^{j\omega})|\approx 1
$$

이 되도록 만든다.  
즉

$$
|G(e^{j\omega})|\approx \frac{1}{|\text{sinc}(\omega/2)|}.
$$

#### B2.4 저주파 근사(파데/테일러 아이디어)
작은 $$x$$ 에서

$$
\text{sinc}(x)=\frac{\sin x}{x}\approx 1-\frac{x^2}{6}+\frac{x^4}{120}-\cdots
$$

따라서 역수는

$$
\frac{1}{\text{sinc}(x)}\approx 1+\frac{x^2}{6}+\cdots
$$

즉 **저주파에서 완만히 올라가는 보정**이면 된다.

2차 IIR로 맞추려면  
주파수 샘플 피팅이나 Pade 근사 후 bilinear transform 등의 절차를 쓸 수 있다.

#### B2.5 실습형 설계(주파수 샘플 피팅)
가장 간단한 실습은:
1) 원하는 대역 $$0\le \omega \le 0.6\pi$$ 에서
2) 목표 크기 $$1/\text{sinc}(\omega/2)$$ 를 만들고
3) 저차 FIR 또는 IIR로 최소제곱 근사.

사용자 코드가 그 아이디어다(FIR로 근사).

**코드(원본 유지 + 주석 보완)**

```octave
clear; close all; clc

w = linspace(0,0.6*pi,512);

% ZOH/T의 크기만: sinc(w/2)
Hdroop = (sin(w/2)./(w/2)); 
Hdroop(1)=1;  % w=0 특이점 보정

% 목표 보정 = 1/Hdroop
target = 1./Hdroop;

% FIR 최소제곱 근사 (firls)
% firls(N, F, A)에서 F는 [0..1] 정규화 주파수
Fgrid = w/(pi);  % [0..0.6] 구간
% 간단히 passband에서 target, stopband에서 0으로 두는 러프 설계
b = firls(20, [0 0.55 0.6 1], ...
             [target(1) target(round(end*0.55/0.6)) 0 0]);

B = freqz(b,1,w);

plot(w/pi, 20*log10(abs(B).*abs(Hdroop)) );
grid on
xlabel('\omega/\pi'); ylabel('dB');
title('ZOH droop pre-emphasis (rough FIR)');
```

#### B2.6 2차 IIR로 줄이는 힌트
FIR 대신 2차 IIR을 원하면:
- $$\omega$$ 샘플에서 target을 만든 뒤,
- `invfreqz(target, w, nb=2, na=2)` 같은 함수로 IIR 피팅.

예:

```octave
clear; close all; clc

w = linspace(0,0.6*pi,256);
Hdroop = (sin(w/2)./(w/2)); Hdroop(1)=1;
target = 1./Hdroop;  % 목표 보정

% 2차 IIR 피팅(분자2, 분모2)
[b,a] = invfreqz(target, w, 2, 2);

% 확인
G = freqz(b,a,w);

plot(w/pi, 20*log10(abs(G).*abs(Hdroop)));
grid on; xlabel('\omega/\pi'); ylabel('dB');
title('ZOH droop pre-emphasis (2nd-order IIR fit)');
```

---

## C. DFT와 그 성질

### C1 — Parseval과 단위수정 DFT(증명형 + 수치형)

#### C1.1 문제 재진술
단위수정(유니터리) DFT에서 Parseval이 대칭형으로 성립함을 보이고 수치로 확인하라.

#### C1.2 유니터리 DFT 정의
정규화 위치를 양쪽에 $$1/\sqrt{N}$$ 로 분배:

$$
\tilde X[k]=\frac{1}{\sqrt{N}}\sum_{n=0}^{N-1} x[n]e^{-j\frac{2\pi}{N}kn},
$$

$$
x[n]=\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1} \tilde X[k]e^{j\frac{2\pi}{N}kn}.
$$

이걸 쓰면 변환 행렬이 **유니터리(정규 직교)** 가 되어
에너지가 완전히 대칭으로 유지된다.

#### C1.3 Parseval 증명
유니터리 변환은 내적을 보존하므로

$$
\sum_n |x[n]|^2 = \sum_k |\tilde X[k]|^2.
$$

**행렬 관점 증명**:

- $$\tilde X = Ux$$, $$x = U^\ast \tilde X$$
- 유니터리 행렬 $$U^\ast U = I$$
- 따라서

$$
\|x\|^2 = x^\ast x = x^\ast (U^\ast U) x = (Ux)^\ast (Ux) = \|\tilde X\|^2.
$$

끝.

#### C1.4 실습 주의
- 복소 신호에서도 동일하게 성립.
- `ifft`는 Octave에서 $$1/N$$ 정규화 포함이라, 유니터리 역변환 시 스케일 근거를 맞춰줘야 한다.

**코드(원본 유지)**

```octave
clear; close all; clc
N=1500; x=randn(1,N)+1j*randn(1,N);

X = fft(x)/sqrt(N); 
xr = ifft(X)*sqrt(N);

fprintf("recon err=%.3e | Parseval diff=%.3e\n", ...
  norm(x-xr)/norm(x), abs(sum(abs(x).^2) - sum(abs(X).^2)));
```

---

### C2 — 누출/스캘러핑/창의 CG·ENBW 수치 비교(실습형)

#### C2.1 문제 핵심
비정합 주파수의 톤을 DFT하면 누출이 생긴다.  
서로 다른 창(직사각, Hann, Hamming, Blackman)을 적용했을 때
- 누출(Leakage)
- 스캘러핑 손실(Scalloping loss)
- 진폭 추정 편향

을 비교하고, Coherent Gain(CG)으로 보정을 수행하라.

#### C2.2 비정합 톤에서 누출이 생기는 이유
DFT는 “길이 $$N$$ 구간을 **직사각 창으로 잘라본 것**”과 동일하다.  
직사각 창의 주파수 응답이 sinc이므로,  
한 개의 톤도 sinc 모양으로 퍼지며 **사이드로브 누출**이 나온다.

비정합(즉, 톤 주파수가 격자 $$kF_s/N$$ 에 정확히 맞지 않음)일수록  
메인로브가 격자 사이에 걸려서 에너지가 넓게 흘러간다.

#### C2.3 창별 특성(정리)
| 창 | 메인로브 폭 | 사이드로브 크기 | 장점 | 단점 |
|---|---|---|---|---|
| Rect | 가장 좁음 | 큼 | 분해능 최고 | 누출 최악 |
| Hann | 넓음 | 작음 | 누출 크게 감소 | 분해능 감소 |
| Hamming | Hann보다 약간 좁음 | 사이드로브 더 낮음 | 음향/일반 FFT 안정 | 메인로브 약간 넓음 |
| Blackman | 가장 넓음 | 매우 낮음 | 누출 극소화 | 분해능/스캘러핑 손실 큼 |

#### C2.4 Coherent Gain(CG)
창을 곱하면 **진폭이 평균적으로 줄어든다**.

창 평균이 CG:

$$
\text{CG}=\frac{1}{N}\sum_{n=0}^{N-1} w[n].
$$

따라서 단일 톤 진폭 추정은

$$
\hat A \approx \frac{2}{N\cdot \text{CG}}\max_k |X_w[k]|.
$$

#### C2.5 ENBW(Equivalent Noise Bandwidth)
잡음 바닥 평가도 자주 나오는 개념:

$$
\text{ENBW} = \frac{\sum_n w[n]^2}{(\sum_n w[n])^2}\cdot N.
$$

- ENBW가 작을수록 잡음 바닥이 낮게 보임.
- Rect는 ENBW=1(최소), Hann/Hamming/Blackman은 더 큼.

#### C2.6 실습 코드(원본 유지)
```octave
clear; close all; clc; pkg load signal
Fs=48000; N=4096; n=0:N-1; t=n/Fs;
f0 = (100 + 0.37)*Fs/N; x = cos(2*pi*f0*t);

W = {ones(1,N), hann(N)', hamming(N)', blackman(N)'};
CG= [1, mean(hann(N)), mean(hamming(N)), mean(blackman(N))];
names={'rect','hann','hamm','black'};

for i=1:numel(W)
  X = fft(x.*W{i});
  [~,k] = max(abs(X));
  Aest = (2/(N*CG(i)))*abs(X(k));
  fprintf("%s : Aest=%.4f\n", names{i}, Aest);
end
```

#### C2.7 추가 실험(누출 스펙트럼 그림)
창별 메인로브/사이드로브를 직접 비교.

```octave
clear; close all; clc; pkg load signal
Fs=48000; N=4096; n=0:N-1; t=n/Fs;
f0=(100+0.37)*Fs/N; x=cos(2*pi*f0*t);

wins = {ones(1,N), hann(N)', hamming(N)', blackman(N)'};
names={'rect','hann','hamm','black'};

figure;
for i=1:4
  X=fft(x.*wins{i});
  mag=20*log10(abs(X(1:N/2))/max(abs(X)));
  f=(0:N/2-1)*Fs/N;
  plot(f,mag); hold on;
end
grid on; ylim([-120 0]);
legend(names);
xlabel('Hz'); ylabel('dB');
title('Leakage comparison across windows');
```

---

## D. DFT를 이용한 선형 콘벌루션

### D1 — 제로패딩 임계조건 실험(실습형)

#### D1.1 문제 핵심
DFT 기반 곱셈은 원래 **원형 콘벌루션**을 만든다.  
선형 콘벌루션을 얻으려면 제로패딩 길이 $$N$$ 이 충분해야 한다.

필요조건:

$$
N \ge L_x + L_h - 1.
$$

#### D1.2 왜 $$L_x+L_h-1$$ 인가
선형 콘벌루션 길이:

$$
L_y = L_x + L_h - 1.
$$

원형 콘벌루션은 길이 $$N$$ 에서 wrap-around가 생기므로,
결과가 선형 콘벌루션과 같으려면  
선형 결과가 “한 바퀴 안에서 다 들어가야” 한다.

즉 $$N \ge L_y$$.

#### D1.3 실습 포인트
- $$N=L_y-1$$ 로 하면 마지막 샘플이 앞쪽에 섞여 큰 오차 발생.
- $$N=L_y$$ 부터는 wrap-around가 사라짐.
- 실행 시 trial마다 랜덤 길이를 바꿔 통계적으로 확인.

**코드(원본 유지)**

```octave
clear; close all; clc
for trial=1:5
  Lx=randi([50,200]); Lh=randi([30,100]);
  x=randn(1,Lx); h=randn(1,Lh); Ly=Lx+Lh-1;
  y_ref = conv(x,h);

  N1=Ly-1; N2=Ly;
  y1 = ifft( fft([x zeros(1,N1-Lx)]) .* fft([h zeros(1,N1-Lh)]) ); 
  y1=y1(1:Ly);

  y2 = ifft( fft([x zeros(1,N2-Lx)]) .* fft([h zeros(1,N2-Lh)]) ); 
  y2=y2(1:Ly);

  printf("Trial %d: N=Ly-1 err=%.2e | N=Ly err=%.2e\n", ...
         trial, rms(y1-y_ref), rms(y2-y_ref));
end
```

---

### D2 — OLA/OLS의 동치성(실습형)

#### D2.1 문제 핵심
긴 신호/필터에서 FFT 기반 컨볼루션을 할 때
- OLA(Overlap-Add)
- OLS(Overlap-Save)

두 방식이 **선형 콘벌루션과 동치**임을 확인하라.

#### D2.2 OLA 개념
1) 입력을 길이 $$L$$ 블록으로 자른다.  
2) 각 블록을 제로패딩 후 FFT 컨볼루션.  
3) 블록 결과를 시간축에서 겹쳐 더한다.

중요: 블록마다 선형 콘벌루션 길이가 맞도록 FFT 길이 설정.

#### D2.3 OLS 개념
1) FFT 길이 $$N_{\text{fft}}$$ 를 잡고  
2) 한 블록에서 입력의 앞부분 $$M-1$$ 샘플(필터 길이-1)을 overlap으로 붙여 FFT 컨볼루션.  
3) 앞의 wrap 구간을 버리고(save) 뒤의 $$L=N_{\text{fft}}-M+1$$ 부분만 취한다.

#### D2.4 왜 동치인가(요지)
각 블록의 원형 콘벌루션에서 생기는 wrap-around가
- OLA는 **더하는 위치**에서 자연스럽게 선형으로 합쳐지고,
- OLS는 **버리는 구간**이 wrap-around 이므로 제거돼
결국 전체 합이 선형 콘벌루션과 같게 된다.

#### D2.5 실습 코드(원본 유지)
```octave
function y = conv_ola(x, h, L)
  M = numel(h); Nfft = 2^nextpow2(L + M - 1);
  H = fft([h zeros(1,Nfft-M)]);
  y = zeros(1, numel(x)+M-1);
  in_idx=1; out_idx=1;
  while in_idx <= numel(x)
    xe = x(in_idx:min(in_idx+L-1, numel(x)));
    yb = ifft( fft([xe zeros(1,Nfft-numel(xe))]) .* H );
    y(out_idx:out_idx+Nfft-1) += yb;
    in_idx += L; out_idx += L;
  endwhile
endfunction

function y = conv_ols(x, h, Nfft)
  M=numel(h); if Nfft<M, error("Nfft>=M"); end
  L = Nfft - M + 1; H=fft([h zeros(1,Nfft-M)]);
  y = []; overlap=zeros(1,M-1); idx=1;
  while idx <= numel(x)
    xe = x(idx:min(idx+L-1, numel(x))); blk=[overlap xe];
    if numel(blk)<Nfft, blk=[blk zeros(1,Nfft-numel(blk))]; end
    yb = ifft( fft(blk).*H ); 
    y = [y yb(M:end)(1:min(L, numel(x)-idx+1))];
    overlap = blk(end-(M-2):end); idx += L;
  endwhile
  y = [y zeros(1, (numel(x)+M-1)-numel(y))]; 
  y=y(1:numel(x)+M-1);
endfunction

clear; close all; clc
x=randn(1,40000); h=fir1(255,0.2); y_ref=conv(x,h);
y_ola=conv_ola(x,h,2048); y_ols=conv_ols(x,h,4096);

printf("RMS(OLA-ref)=%.2e | RMS(OLS-ref)=%.2e | RMS(OLA-OLS)=%.2e\n", ...
  rms(y_ola-y_ref), rms(y_ols-y_ref), rms(y_ola-y_ols));
```

---

## E. 고속 푸리에 변환(FFT)

### E1 — Radix-2 DIT FFT 구현 및 검증(실습형)

#### E1.1 목표
Radix-2 DIT(Decimation in Time) FFT를 직접 구현하고 `fft`와 오차를 비교하라.

#### E1.2 DIT 분해 원리
길이 $$N$$ (2의 거듭제곱) DFT:

$$
X[k]=\sum_{n=0}^{N-1} x[n]W_N^{kn},\quad W_N=e^{-j\frac{2\pi}{N}}.
$$

짝/홀 분해:

$$
X[k]=\sum_{r=0}^{N/2-1} x[2r]W_N^{k\cdot 2r}
+\sum_{r=0}^{N/2-1} x[2r+1]W_N^{k(2r+1)}.
$$

이를 정리하면

$$
X[k]=E[k]+W_N^k O[k],
$$

$$
X[k+\frac{N}{2}]=E[k]-W_N^k O[k].
$$

여기서 $$E[k]$$ 는 짝수 샘플 DFT, $$O[k]$$ 는 홀수 샘플 DFT.

이 구조가 재귀적으로 반복되며 연산량이 $$O(N\log N)$$ 으로 줄어든다.

#### E1.3 비트-리버설(필수 이유)
DIT FFT의 in-place 구현은
최종 출력이 자연 순서가 되도록, 입력을 비트-리버설 순서로 재배치해야 한다.

- 입력 인덱스 $$n$$ 을 이진수로 쓰고
- 비트를 뒤집은 인덱스로 재배치.

#### E1.4 실습 코드(원본 유지)
```octave
function y=bitrev_permute(x)
  N=numel(x); b=log2(N); y=zeros(size(x));
  for n=0:N-1, r=0; t=n;
    for i=1:b
      r=bitshift(r,1)+bitand(t,1); 
      t=bitshift(t,-1); 
    end
    y(r+1)=x(n+1);
  end
end

function X=myfft_radix2(x)
  x=x(:).'; N=numel(x);
  if bitand(N,N-1)~=0, error("power-of-two"); end

  X=bitrev_permute(x);

  m=2; 
  while m<=N
    half=m/2; 
    W=exp(-1j*2*pi*(0:half-1)/m);

    for k=1:m:N
      i1=k:(k+half-1); 
      i2=(k+half):(k+m-1);
      t=W.*X(i2); 
      u=X(i1); 
      X(i1)=u+t; 
      X(i2)=u-t;
    end

    m*=2;
  endwhile
end

clear; close all; clc
N=1024; x=randn(1,N)+1j*randn(1,N);
X_ref=fft(x); X_my=myfft_radix2(x);
fprintf("rel-err FFT=%.3e\n", norm(X_ref-X_my)/norm(X_ref));
```

---

### E2 — Bluestein(Chirp-Z)로 소수 길이 FFT(실습형)

#### E2.1 목표
소수 길이 $$N=97$$ 에서 Bluestein 알고리즘으로 FFT를 계산하고 `fft`와 비교하라.

#### E2.2 Bluestein 아이디어
DFT:

$$
X[k]=\sum_{n=0}^{N-1} x[n] e^{-j\frac{2\pi}{N}kn}.
$$

지수의 곱을 “제곱 항”으로 분해:

$$
kn = \frac{1}{2}\left(n^2 + k^2 - (n-k)^2\right).
$$

따라서

$$
e^{-j\frac{2\pi}{N}kn}
=
e^{-j\frac{\pi}{N}n^2}\cdot e^{-j\frac{\pi}{N}k^2}\cdot e^{j\frac{\pi}{N}(n-k)^2}.
$$

이걸 넣으면

$$
X[k]=e^{-j\frac{\pi}{N}k^2}\sum_n \left(x[n]e^{-j\frac{\pi}{N}n^2}\right)
\cdot e^{j\frac{\pi}{N}(n-k)^2}.
$$

괄호 안은 **시퀀스 a[n]**, 마지막 항은 **시퀀스 b[n]** 이고  
전체가 **선형 콘벌루션** 구조로 바뀐다.

즉 Bluestein은
“DFT를 적절한 chirp 곱 + 콘벌루션으로 변환 → FFT로 콘벌루션 계산”
이다.

#### E2.3 실습 코드(원본 유지)
```octave
function X = bluestein_fft(x)
  x=x(:).'; N=numel(x); n=0:N-1;

  a = x .* exp(-1j*pi*(n.^2)/N);
  b = exp( 1j*pi*(n.^2)/N);

  L=2*N-1; 
  P=2^nextpow2(L);

  A=fft([a zeros(1,P-N)]); 
  B=fft([b zeros(1,P-N)]);
  C=ifft(A.*B); 
  c=C(1:N);

  X = exp(-1j*pi*(n.^2)/N).*c;
end

clear; close all; clc
N=97; x=randn(1,N)+1j*randn(1,N);
Xb=bluestein_fft(x); Xr=fft(x);
fprintf("N=%d | rel-err=%.3e\n", N, norm(Xb-Xr)/norm(Xr));
```

---

### E3 — FFT 연산량 카운트(증명형 + 계산형)

#### E3.1 목표
Radix-2 DIT FFT의 복소 곱/합 연산량을 유도하고 코드로 확인하라.

#### E3.2 연산량 유도
FFT는 총 $$p=\log_2 N$$ 스테이지로 구성된다.

- 각 스테이지마다
  - 버터플라이 수 = $$N/2$$
  - 버터플라이 하나당
    - 복소 곱 1회
    - 복소 합 2회(+)와(-)

따라서

**복소 곱 수**:

$$
\frac{N}{2}\log_2 N.
$$

**복소 합 수**:

$$
N\log_2 N.
$$

#### E3.3 코드 확인(원본 유지)
```octave
function [mulc, addc]=count_ops_radix2(N)
  p=log2(N); 
  mulc=(N/2)*p; 
  addc=N*p;
end

for N=[8 16 1024 4096]
  [m,a]=count_ops_radix2(N);
  printf("N=%d | mul=%d add=%d\n",N,m,a);
end
```

---

## F. 종합 실습: 하나로 엮기

### F1 — DFS→DTFT 대응·샘플링·DFT·FFT 전 과정 파이프라인(실습형)

#### F1.1 목표
주기 신호 생성부터 DFS/DFT/창/제로패딩/DFT필터링/OLA·OLS/자작 FFT/Bluestein까지
하나의 파이프라인으로 통합하고 각 단계의 이론-수치 일치 여부를 검증하라.

#### F1.2 파이프라인 해설

1) **주기신호 생성 → DFS 계수 계산**  
   - DFS는 주기 신호의 주파수 성분을 $$N$$ 개 격자로 표현.
   - DFT와의 관계 $$c_k=X[k]/N$$ 확인.

2) **샘플링 주파수와 물리 주파수 축**  
   DFT 인덱스 $$k$$ 는 물리 주파수

   $$f_k=\frac{kF_s}{N}$$

   에 해당.

3) **비정합 톤 + 창 + 제로패딩(보간)**  
   - 창으로 누출 감소.
   - 제로패딩으로 주파수 격자 간격을 촘촘히 하여 피크를 더 정확히 위치 추정.

4) **DFT 곱으로 FIR 필터링(선형 컨볼루션)**  
   - 반드시 $$N_{\text{fft}}\ge L_x+L_h-1$$ 로 제로패딩.

5) **긴 필터에서 OLA/OLS 비교**  
   - 둘이 `conv`와 동일해야 함.

6) **자작 Radix-2 FFT / Bluestein으로도 계산**  
   - `fft`와 상대오차 비교로 구현 검증.

#### F1.3 실습 코드(원본 스케치 확장)

```octave
clear; close all; clc; pkg load signal

% ---------------------------
% 0) 기본 파라미터
% ---------------------------
Fs=48000; 
N=1024; 
n=0:N-1; 
t=n/Fs;

% ---------------------------
% 1) 주기 신호 생성
% ---------------------------
x = 1.0*cos(2*pi*1234.5*t) + 0.4*cos(2*pi*4321.2*t + 0.3);

% ---------------------------
% 2) DFT/DFS 관계 확인
% ---------------------------
X=fft(x); 
ck=X/N;
x_rec=real(ifft(X));
fprintf("recon err=%.3e | DFS relation err=%.3e\n", ...
  norm(x-x_rec)/norm(x), norm(ck - X/N)/norm(ck));

% ---------------------------
% 3) 물리 주파수 축
% ---------------------------
f=(0:N-1)*Fs/N;

% ---------------------------
% 4) 창/제로패딩 스펙트럼 보간
% ---------------------------
w=hann(N)'; 
Nz_pad=16384;
Xw=fft(x.*w, Nz_pad); 
fw=(0:Nz_pad-1)*Fs/Nz_pad;

% 피크 위치 확인
[~,kpk]=max(abs(Xw(1:Nz_pad/2)));
fprintf("Interpolated peak ≈ %.2f Hz\n", fw(kpk));

% ---------------------------
% 5) FIR 필터링 by DFT (선형 컨볼루션)
% ---------------------------
h=fir1(127, 0.2); 
Ly=N+numel(h)-1; 
Nz=2^nextpow2(Ly);

y = ifft( fft([x zeros(1,Nz-N)]) .* fft([h zeros(1,Nz-numel(h))]) );
y = y(1:Ly); 
y_ref=conv(x,h);
fprintf("DFT conv err=%.2e\n", rms(y-y_ref));

% ---------------------------
% 6) 긴 필터에서 OLA/OLS 비교
% ---------------------------
xlong=[x randn(1,40000)]; 
hlong=fir1(511,0.15);
y_ref_long=conv(xlong,hlong);

% OLA
function y = conv_ola(x, h, L)
  M = numel(h); Nfft = 2^nextpow2(L + M - 1);
  H = fft([h zeros(1,Nfft-M)]);
  y = zeros(1, numel(x)+M-1);
  in_idx=1; out_idx=1;
  while in_idx <= numel(x)
    xe = x(in_idx:min(in_idx+L-1, numel(x)));
    yb = ifft( fft([xe zeros(1,Nfft-numel(xe))]) .* H );
    y(out_idx:out_idx+Nfft-1) += yb;
    in_idx += L; out_idx += L;
  endwhile
endfunction

% OLS
function y = conv_ols(x, h, Nfft)
  M=numel(h); if Nfft<M, error("Nfft>=M"); end
  L = Nfft - M + 1; H=fft([h zeros(1,Nfft-M)]);
  y = []; overlap=zeros(1,M-1); idx=1;
  while idx <= numel(x)
    xe = x(idx:min(idx+L-1, numel(x))); blk=[overlap xe];
    if numel(blk)<Nfft, blk=[blk zeros(1,Nfft-numel(blk))]; end
    yb = ifft( fft(blk).*H ); 
    y = [y yb(M:end)(1:min(L, numel(x)-idx+1))];
    overlap = blk(end-(M-2):end); idx += L;
  endwhile
  y = [y zeros(1, (numel(x)+M-1)-numel(y))]; 
  y=y(1:numel(x)+M-1);
endfunction

y_ola=conv_ola(xlong,hlong,2048);
y_ols=conv_ols(xlong,hlong,4096);
fprintf("RMS OLA-ref=%.2e | OLS-ref=%.2e | OLA-OLS=%.2e\n", ...
  rms(y_ola-y_ref_long), rms(y_ols-y_ref_long), rms(y_ola-y_ols));

% ---------------------------
% 7) 자작 FFT / Bluestein 비교
% ---------------------------
function y=bitrev_permute(x)
  N=numel(x); b=log2(N); y=zeros(size(x));
  for n=0:N-1, r=0; t=n;
    for i=1:b, r=bitshift(r,1)+bitand(t,1); t=bitshift(t,-1); end
    y(r+1)=x(n+1);
  end
end

function X=myfft_radix2(x)
  x=x(:).'; N=numel(x);
  if bitand(N,N-1)~=0, error("power-of-two"); end
  X=bitrev_permute(x);
  m=2; while m<=N
    half=m/2; W=exp(-1j*2*pi*(0:half-1)/m);
    for k=1:m:N
      i1=k:(k+half-1); i2=(k+half):(k+m-1);
      t=W.*X(i2); u=X(i1); X(i1)=u+t; X(i2)=u-t;
    end
    m*=2;
  endwhile
end

% Radix-2 검증
x_fft = randn(1,1024)+1j*randn(1,1024);
X_ref = fft(x_fft);
X_my  = myfft_radix2(x_fft);
fprintf("Radix-2 rel-err=%.3e\n", norm(X_ref-X_my)/norm(X_ref));

% Bluestein 검증(소수 N)
function X = bluestein_fft(x)
  x=x(:).'; N=numel(x); n=0:N-1;
  a = x .* exp(-1j*pi*(n.^2)/N);
  b = exp( 1j*pi*(n.^2)/N);
  L=2*N-1; P=2^nextpow2(L);
  A=fft([a zeros(1,P-N)]); B=fft([b zeros(1,P-N)]);
  C=ifft(A.*B); c=C(1:N);
  X = exp(-1j*pi*(n.^2)/N).*c;
end

x97 = randn(1,97)+1j*randn(1,97);
Xb = bluestein_fft(x97); Xr = fft(x97);
fprintf("Bluestein N=97 rel-err=%.3e\n", norm(Xb-Xr)/norm(Xr));
```

---

## 부록 — 정답/풀이 요지(확장)

- **A1**  
  DFS/역변환은 복소지수 직교성으로 엄밀히 증명된다.  
  Parseval은 직교 기저의 에너지 보존이며, DFT와의 관계 $$c_k=X[k]/N$$ 를 수치로 확인하면 오차는 보통 $$10^{-15}$$.

- **A2**  
  원형 시프트는 스펙트럼에 선형 위상 $$e^{-j2\pi kn_0/N}$$ 를 곱한다.  
  주파수 변조는 DFS 계수를 원형 이동시킨다(스펙트럼 쉬프트).

- **B1**  
  $$F_s=8\ \text{kHz}$$ 에서 $$f_0=5\ \text{kHz}$$ 는  
  $$f_a=3\ \text{kHz}$$ 로 접혀 들린다.  
  이상 sinc 복원은 순수 $$f_a$$ 톤만 남기고, ZOH는 계단 파형 + sinc 드룹이 있다.

- **B2**  
  ZOH 드룹 $$\text{sinc}(\omega/2)$$ 의 역수를 저차 IIR/FIR로 근사하면 저주파 평탄화 가능.  
  주파수 샘플 피팅이 실습에 가장 안전.

- **C1**  
  유니터리 DFT는 변환 행렬이 유니터리라 Parseval이 대칭으로 성립.  
  복소 신호에서도 재구성/에너지 차이는 수치 오차 수준.

- **C2**  
  비정합 톤에서 Rect는 누출이 가장 심하고 Blackman이 가장 약함.  
  창 평균(CG)으로 진폭 편향을 줄이며, ENBW 개념으로 잡음 바닥을 비교할 수 있다.

- **D1**  
  $$N\ge L_x+L_h-1$$ 이면 FFT 기반 곱이 선형 콘벌루션과 일치.  
  $$N=L_y-1$$ 에서는 wrap-around로 큰 RMS 오차.

- **D2**  
  OLA/OLS는 블록화 방식만 다를 뿐 결과는 선형 콘벌루션과 동치.  
  수치상 RMS 오차는 부동소수점 잡음 수준.

- **E1**  
  Radix-2 DIT는 비트-리버설 재배치 + 스테이지별 버터플라이로 구현.  
  `fft` 대비 상대오차는 $$10^{-12}$$ 정도.

- **E2**  
  Bluestein은 소수/임의 길이 FFT를 chirp 곱 + 콘벌루션으로 변환해 계산.  
  `fft`와 거의 동일 결과.

- **E3**  
  스테이지 $$\log_2 N$$, 스테이지당 $$N/2$$ 곱·$$N$$ 합 →  
  복소 곱 $$\frac{N}{2}\log_2 N$$, 복소 합 $$N\log_2 N$$.

- **F1**  
  전체 파이프라인을 한 번에 돌려보면  
  DFS↔DFT 관계, 창/제로패딩 보간 효과, FFT 기반 선형 필터링, OLA/OLS 동치,  
  Radix-2/Bluestein 검증이 모두 한 흐름으로 확인된다.