---
layout: post
title: 운영체제 - 보안 (1)
date: 2025-10-29 22:25:23 +0900
category: 운영체제
---
# Chapter 16 — Security

## The Security Problem

### 기본 목표: CIA, AAA, Non-repudiation

- **Confidentiality(기밀성)**: 권한 없는 주체가 읽지 못하게.
- **Integrity(무결성)**: 권한 없는 변조를 막고, 변조 탐지 가능하게.
- **Availability(가용성)**: 정당한 사용자가 필요 시 사용할 수 있게(DoS 방어 포함).
- **AAA**: **Authentication(인증)**, **Authorization(인가)**, **Accounting(감사/로깅)**.
- **Non-repudiation(부인방지)**: 서명·타임스탬프로 “부인할 수 없음” 확보.

**리스크 근사**:
$$
\text{Risk} \approx \text{Likelihood} \times \text{Impact}
$$
→ 위협 모델링에서 **공격 가능성**과 **영향**을 곱으로 가늠하여 우선순위 결정.

### 위협·취약점·공격면(Attack Surface)

- **Threat(위협)**: 시스템에 해를 줄 수 있는 행위(예: 코드 인젝션, 오버플로).
- **Vulnerability(취약점)**: 위협이 악용 가능한 결함(예: 길이 검증 부재).
- **Exploit**: 실제 악용 절차/코드.
- **Attack Surface**: 입력 채널, API, 권한 상승 경로 등 노출 지점의 총합. 최소화가 핵심.

### 신뢰경계, TCB, 참조 모니터

- **Trust Boundary**: 보안 속성이 바뀌는 경계(예: 네트워크→서버).
- **TCB(Trusted Computing Base)**: 시스템 보안 속성을 강제하는 최소 구성요소(커널, 하이퍼바이저, LSM, 키 관리 등).
- **Reference Monitor** 원칙: **완전 중재**, **격리(변조 불가)**, **검증 가능**.

### 정책과 메커니즘

- **정책**: 무엇을 허용/거부할지(예: “개발자는 운영DB 읽기 금지”).
- **메커니즘**: 정책을 구현(ACL/캡빌리티/라벨/SELinux/AppArmor/seccomp 등).
- 정책↔메커니즘을 분리하고, **정책은 바꾸기 쉬워야** 한다.

### 인간·운영 요소

- **사회공학**(피싱/전화), **구성 실수**(공개 버킷), **패치 지연**, **비밀 관리 실패**가 흔한 근본 원인.
- **보안은 기능**: 쉬운 롤백/키교체/비상 차단 스위치 등 운영 UX가 품질을 좌우.

---

## Program Threats

> 교육 목적의 **취약 예시**와 **방어 코드**를 제시한다. 공격용 익스플로잇 제공은 지양하고, **원인·완화/수정**에 초점을 둔다.

### 악성코드 분류(요약)

- **Virus/Worm/Trojan/Adware/Spyware/Ransomware/Rootkit**
- 감염·전파 벡터: 취약 바이너리, 매크로, 공급망, USB, 패키지 매니저 이름 스쿼팅 등.

### 메모리 안전 결함

#### (A) 버퍼 오버플로 — 취약 코드 vs. 수정 코드

```c
// vulnerable_echo.c — 취약(예시): gets/scanf("%s") 계열은 금지
#include <stdio.h>

int main(){
  char buf[16];
  printf("say: ");
  gets(buf);            // ⚠️ 길이 검증 없음 → 오버플로
  printf("you said: %s\n", buf);
}
```

```c
// safe_echo.c — 안전: 길이 제한 + 종료문자 보장 + 포맷 지정
#include <stdio.h>
#include <string.h>

int main(){
  char buf[16];
  printf("say: ");
  if(!fgets(buf, sizeof(buf), stdin)) return 1;
  buf[strcspn(buf,"\n")] = '\0';     // 개행 제거
  printf("you said: %s\n", buf);
}
```

**완화 기술**: **ASLR**, **NX/DEP**, **Stack Canary**, **CFI**, **RELRO**, **FORTIFY_SOURCE**.
**근본 해결**: 메모리 안전 언어(Rust/Go/Java), Bounds-checked API 사용.

#### (B) 정수 오버플로 → 힙 오버플로

```c
// int_overflow_alloc.c — 취약: 곱셈 오버플로로 작은 버퍼 할당 후 큰 복사
#include <stdlib.h>
#include <string.h>

int copy_items(const char* src, size_t n){
  size_t bytes = n * sizeof(int);    // ⚠️ 오버플로 가능
  char* p = malloc(bytes);
  if(!p) return -1;
  memcpy(p, src, n*sizeof(int));     // 실제 큰 크기 복사 → 힙 오버플로
  free(p); return 0;
}
```

```c
// int_overflow_alloc_fixed.c — 안전: 곱셈 체크
#include <stdlib.h>
#include <string.h>
#include <limits.h>

int copy_items(const char* src, size_t n){
  if (n > SIZE_MAX / sizeof(int)) return -1;   // 오버플로 가드
  size_t bytes = n * sizeof(int);
  char* p = malloc(bytes);
  if(!p) return -1;
  memcpy(p, src, bytes);
  free(p); return 0;
}
```

#### (C) 포맷 스트링

```c
// format_vuln.c — 취약: 사용자 입력을 printf 포맷으로 사용
#include <stdio.h>

int main(int argc, char** argv){
  if(argc>1) printf(argv[1]);        // ⚠️ %n 등 악용 여지
}
```

```c
// format_fixed.c — 안전: "%s"로 제한
#include <stdio.h>

int main(int argc, char** argv){
  if(argc>1) printf("%s", argv[1]);
}
```

### 레이스(TOCTOU) & 파일 시스템

#### 취약 패턴: 검사 후 사용(check-then-use)

```c
// toctou_vuln.c — 심링크 경주로 다른 파일 덮어쓰기 위험
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(){
  struct stat st;
  if (stat("input.txt",&st)==0) {          // 체크
    int fd=open("input.txt", O_WRONLY|O_TRUNC);  // 사용 (사이에 심링크로 바뀔 수 있음)
    // ...
  }
}
```

#### 방어: 디렉터리 FD 기준 openat + O_NOFOLLOW + O_EXCL

```c
// toctou_fixed.c — 안전한 열기 패턴
#define _GNU_SOURCE
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main(){
  int dfd = open("/srv/data", O_DIRECTORY|O_RDONLY|O_CLOEXEC);
  int fd  = openat(dfd, "input.txt", O_CREAT|O_EXCL|O_WRONLY|O_NOFOLLOW|O_CLOEXEC, 0644);
  if(fd<0){ perror("openat"); return 1; }
  write(fd,"safe\n",5); fsync(fd); close(fd);
  close(dfd);
}
```

### 권한 상승·라이브러리 하이재킹

- **setuid** 바이너리: 환경변수(LD_*), PATH, 임시파일, 로케일, `umask`, `ulimit` 등 상호작용 주의.
- **동적 로더 하이재킹**: 잘못된 RPATH/`LD_LIBRARY_PATH` 신뢰 → 임의 라이브러리 로딩.
**대응**: **절대경로** 사용, **setuid에서는 환경 정화**, **RUNPATH 최소화**, **Signed binaries**.

### 공급망/의존성

- 패키지 **타이포스쿼팅**, **악성 스크립트**(postinstall), **서명 없는 업데이트**.
- **SBOM**, **서명 검증**, **재현 가능 빌드**, **격리 빌드(빌더·키 분리)**.

### 샌드박싱/격리

- **seccomp-bpf**: 허용 syscalls만 화이트리스트.
- **LSM(SELinux/AppArmor)**: 레이블/프로필로 접근 제어.
- **네임스페이스 + cgroups**: 파일/프로세스/네트워크 격리 + 자원 제한.

```c
// seccomp_min.c — (개념) read/write/_exit만 허용하는 초소형 필터 예시
// 실제 빌드엔 libseccomp 또는 raw BPF 세팅 필요(튜토리얼/테스트 환경에서 적용).
```

---

## System and Network Threats

### 시스템(호스트) 위협

- **루트킷**(유저/커널/부트): 훅킹, 은닉. 대응: **Secure Boot**, **커널 서명**, **무결성 검증(fs-verity)**, EDR.
- **구성 실수**: world-writable, 잘못된 권한, 디버그 포트 노출.
- **자원 고갈**: 파일 디스크립터/메모리/CPU, **알고리즘 복잡도 DoS**(해시 충돌, 정규식 폭발).

#### 간단한 ulimit/시스템 설정 예(방어)

```bash
# systemd 서비스 단위에 자원 제한

LimitNOFILE=16384
MemoryMax=1G
CPUQuota=200%
```

### 네트워크 위협

- **스푸핑/중간자(MitM)**: ARP/DNS/라우팅 조작, 공용 Wi-Fi.
- **스캐닝/침투**: 열려있는 포트/서비스 열람.
- **DoS/DDoS**: 대역폭/세션/애플리케이션 계층 고갈(SYN flood, Slowloris 등).

#### 레이트 리미팅(예: nftables)

```bash
nft add table inet filter
nft 'add chain inet filter input { type filter hook input priority 0; }'
nft 'add rule inet filter input ct state established,related accept'
nft 'add rule inet filter input tcp dport 22 limit rate 15/minute accept'
nft 'add rule inet filter input tcp dport 22 drop'
```

#### 애플리케이션 계층(예: Nginx) 레이트 리미트

```nginx
limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
server {
  location /api/ {
    limit_req zone=api burst=20 nodelay;
    proxy_pass http://backend;
  }
}
```

### DNS·ARP·TLS

- **DNS 캐시 중독**: **DNSSEC** 검증, 랜덤 소스포트/트랜잭션ID.
- **ARP 스푸핑**: 정적 ARP, 동적 감시, 스위치 보안(DAI).
- **TLS**: **HSTS**, **OCSP 스테이플링**, **ALPN**, **Perfect Forward Secrecy**.

#### 간단한 TLS 고정(핀닝) 클라이언트 (Python)

```python
# tls_pinning.py — 서버 공개키 해시(SPKI) 고정 예시

import ssl, socket, hashlib, base64
PIN_B64 = "sha256/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX="  # 사전 수집한 SPKI 핀

ctx = ssl.create_default_context()
with socket.create_connection(("example.com", 443)) as sock:
    with ctx.wrap_socket(sock, server_hostname="example.com") as ssock:
        der = ssock.getpeercert(binary_form=True)
        cert = ssl.DER_cert_to_PEM_cert(der)
        pubkey_der = ssl.PEM_cert_to_DER_cert(cert)  # 단순화(실전은 SPKI 추출 필요)
        digest = "sha256/" + base64.b64encode(hashlib.sha256(pubkey_der).digest()).decode()
        if digest != PIN_B64:
            raise RuntimeError("pin mismatch")
        print("TLS pin OK")
```
> 실제 SPKI 추출은 `cryptography` 라이브러리로 정확히 수행한다. 예시는 개념 강조용.

### 가상화/컨테이너 & 클라우드

- **하이퍼바이저 탈출** 방지: 마이크로코드/VT-x/SEV/보안패치, 디바이스 에뮬레이션 최소화.
- **메타데이터 서비스 SSRF**: 인스턴스 프로파일·크리덴셜 탈취 방지(메타데이터v2, 아웃바운드 egress 필터).
- **이미지 공급망**: 서명(SSS/Notary/Cosign), 정책 엔진(OPA/Gatekeeper).

---

## Cryptography as a Security Tool

> **원칙**: 직접 암호 알고리즘을 구현하지 말고, **검증된 라이브러리**를 사용하라. **무작위성**, **비밀 관리**, **nonce/IV 규칙**이 보안의 80%다.

### 기본 원시(Primitives)

- **대칭키 암호**(AES-GCM/ChaCha20-Poly1305): 빠르고, **AEAD**로 기밀+무결성.
- **해시**(SHA-256/512), **MAC**(HMAC, CMAC): 데이터 무결성/인증.
- **공개키 암호**(RSA, EC): **키 교환/서명** 중심으로 사용.
- **KDF**(HKDF, PBKDF2, scrypt, Argon2): 키 파생/패스워드 해시.

#### 수학 스냅샷

- **Diffie–Hellman**:
  $$K = g^{ab} \bmod p$$
- **RSA**:
  $$c \equiv m^e \bmod n,\quad m \equiv c^d \bmod n$$
- **HMAC**:
  $$\mathrm{HMAC}_k(m) = H\big((k\oplus opad) \,\|\, H((k\oplus ipad)\,\|\, m)\big)$$

### 대칭키(예: AES-GCM) — 암복호 & 인증

```python
# aes_gcm_demo.py — Python cryptography를 이용한 AEAD (교육용)

from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives import serialization
import os

key = AESGCM.generate_key(bit_length=256)      # 32바이트
aes = AESGCM(key)
nonce = os.urandom(12)                          # GCM은 96비트 추천(유일성 필수)
aad = b"header"                                 # 인증만 하는 부가데이터(선택)
cipher = aes.encrypt(nonce, b"secret message", aad)
plain  = aes.decrypt(nonce, cipher, aad)
print(plain)
```
> **주의**: GCM nonce는 **절대 재사용 금지**(같은 키로 중복 nonce→심각한 취약).

### 메시지 인증(HMAC) — 전송 무결성

```python
# hmac_demo.py — 표준 라이브러리로 HMAC-SHA256

import hmac, hashlib, secrets
key = secrets.token_bytes(32)
msg = b"log line 1"
tag = hmac.new(key, msg, hashlib.sha256).digest()

# 검증

hmac.new(key, msg, hashlib.sha256).digest() == tag
```

### 패스워드 저장 — PBKDF2(표준 라이브러리)

```python
# password_store_pbkdf2.py — 소금(salt)과 스트레칭

import os, hashlib, hmac, base64
def hash_password(pw:bytes):
  salt = os.urandom(16)
  dk = hashlib.pbkdf2_hmac('sha256', pw, salt, 200_000, dklen=32)
  return f"pbkdf2$sha256$200000${base64.b64encode(salt).decode()}${base64.b64encode(dk).decode()}"

def verify(pw:bytes, rec:str):
  _,_,iters,salt_b64,dk_b64 = rec.split('$')
  salt = base64.b64decode(salt_b64); dk=base64.b64decode(dk_b64)
  test = hashlib.pbkdf2_hmac('sha256', pw, salt, int(iters), dklen=len(dk))
  return hmac.compare_digest(test, dk)

rec = hash_password(b"s3cret!")
print(verify(b"s3cret!", rec), verify(b"nope", rec))
```
> 가능하면 **Argon2**(메모리 하드)를 권장. 표준 라이브러리만으로도 PBKDF2는 적용 가능.

### 디지털 서명 — ECDSA/RSA

```python
# sign_verify_rsa.py — RSA-PSS 서명/검증(요약)

from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization

priv = rsa.generate_private_key(public_exponent=65537, key_size=3072)
pub  = priv.public_key()
msg = b"statement"

sig = priv.sign(msg, padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH), hashes.SHA256())
pub.verify(sig, msg, padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH), hashes.SHA256())
```

### 키 관리·회전·래핑(Envelope)

- **Envelope Encryption**: 데이터 키(DEK)로 암호화 후, **마스터 키(MK)** 로 DEK를 래핑.
- **회전**: 키 식별자(KID) 포함 → 재암호화 없이도 **해독 키 교체** 가능.
- **KMS**: 접근 제어·로깅·감사·자동 회전.

### TLS/전송 보호

- **최신 프로토콜**: TLS 1.2/1.3, 취약 Suite 비활성화, **PFS**(ECDHE).
- **서버 설정**: HSTS, OCSP Stapling, 보안 쿠키(HTTPOnly, Secure, SameSite).

```nginx
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:...';
ssl_prefer_server_ciphers on;
add_header Strict-Transport-Security "max-age=31536000" always;
```

### 저장 데이터 보호

- **디스크/볼륨 암호화**(LUKS/BitLocker/FileVault), **파일 무결성**(fs-verity, dm-verity).
- **키 분리**: 애플리케이션에서 **키를 코드에 하드코딩 금지**, 런타임에 **KMS**에서 획득.

---

## 종합 실습 시나리오: “안전한 파일 교체 + 원격 동기화”

### 목표

1) **로컬 무결성**: 임시파일→`fsync`→원자 `rename`→**부모 디렉터리 `fsync`**
2) **전송 보호**: TLS(핀닝 또는 mTLS), 메시지 HMAC 검증
3) **저장 보호**: 원격 저장 전 AES-GCM으로 암호화

```python
# safe_publish.py — 안전한 파일 교체 + 전송 전 AEAD 암호화(개념)

import os, hmac, hashlib, base64, ssl, socket
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

def atomic_write(path:str, data:bytes):
  tmp = path + ".tmp"
  with open(tmp,"wb") as f:
    f.write(data); f.flush(); os.fsync(f.fileno())
  os.replace(tmp, path)
  dfd = os.open(os.path.dirname(path) or ".", os.O_RDONLY)
  os.fsync(dfd); os.close(dfd)

def encrypt_aead(key:bytes, aad:bytes, plain:bytes):
  import os
  aes = AESGCM(key); nonce = os.urandom(12)
  ct = aes.encrypt(nonce, plain, aad)
  return nonce + ct  # [nonce|cipher|tag]

def send_tls_pinned(host, port, data:bytes, pin_b64:str):
  ctx = ssl.create_default_context()
  with socket.create_connection((host,port)) as s, ctx.wrap_socket(s, server_hostname=host) as ss:
    der = ss.getpeercert(binary_form=True)
    spki_hash = "sha256/" + base64.b64encode(hashlib.sha256(der).digest()).decode()  # 단순화
    if spki_hash != pin_b64: raise RuntimeError("pin mismatch")
    ss.sendall(data)

key = AESGCM.generate_key(bit_length=256)
aad = b"file:v1"
with open("payload.bin","rb") as f:
  protected = encrypt_aead(key, aad, f.read())

atomic_write("artifact.enc", protected)
# send_tls_pinned("example.com", 443, protected, PIN_B64)  # 실제 전송

```

---

## 운영 체크리스트(핵심 정리)

- **설계**: 위협 모델링(데이터 흐름, 신뢰경계, 자산·적대자·시나리오). 공격면 최소화.
- **개발**: 안전 API, 입력 검증, **임시→fsync→rename→부모 fsync**, 에러 처리/로깅.
- **배포**: 최소 권한, 비밀 관리, 샌드박스(seccomp/SELinux), 의존성 서명, 이미지 스캔.
- **운영**: 패치 SLA, 키 회전, 백업 복호 테스트, 모니터링(지표+로그+추적), IR 런북/훈련.
- **암호**: AEAD 기본, **nonce 유일성** 보장, KMS·Envelope, 패스워드는 Argon2/PBKDF2+salt.
- **네트워크**: TLS 1.2/1.3, HSTS, 레이트 리밋, 방화벽 기본 거부+허용 목록, IDS/EDR.

---

## 한 줄 요약

- **16.1**: 보안은 정책·메커니즘·운영의 합. **TCB/참조 모니터**를 의식하며 설계하라.
- **16.2**: 프로그램 취약점은 **입력/메모리/레이스/권한**에서 발생. 안전 API·언어·샌드박스가 해법.
- **16.3**: 시스템·네트워크 위협은 **구성/가시성/자원**의 문제. 최소 권한과 **관측/제어**가 필수.
- **16.4**: 암호는 **도구**다. AEAD/HMAC/서명/KDF/TLS를 **규칙대로** 쓰고, **키·nonce**를 제대로 관리하라.
