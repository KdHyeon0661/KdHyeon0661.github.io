---
layout: post
title: 데이터 통신 - Error Detection and Correction (2)
date: 2024-07-27 19:20:23 +0900
category: DataCommunication
---
# Error Detection and Correction (2)

## Cyclic Codes

### — 개요 재정리

- **정의**: 사이클릭 코드의 대표적 **오류 검출 코드**. 비트열을 **GF(2)** 상의 다항식으로 보고, **생성다항식** $$G(x)$$ 로 나눈 **나머지**를 패리티로 부가한다.
- **송신**: 데이터 다항식 $$M(x)$$ 에 대해
  $$
  T(x)=M(x)\,x^{r}+R(x),\qquad R(x)=\big(M(x)\,x^{r}\big)\bmod G(x),\quad r=\deg G
  $$
- **수신**: 수신 다항식 $$T'(x)$$ 를 $$G(x)$$ 로 나눠 **나머지 0**이면 무결성 통과.
- **검출 특성(핵심)**
  1) 길이 $$<r$$ 인 **버스트 오류**는 **항상 검출**
  2) 적절한 $$G(x)$$ 선택 시 **단일/이중 비트** 오류 **항상 검출**
  3) $$(x+1)$$ 이 $$G(x)$$ 의 인수면 **홀수 개** 비트 오류 **항상 검출**
  4) 무작위 오류 **미검출 확률** $$\approx 2^{-r}$$

> CRC는 **검출 전용**에 최적화된 사이클릭 코드다(정정은 상위 ARQ/HARQ, 또는 별도 FEC가 담당).

---

### 다항식, 표기, 표준 생성다항식

#### GF(2) 연산 규칙

- 계수는 $$\{0,1\}$$, 덧셈은 **XOR**, 곱셈은 **AND**로 해석.
- 나눗셈은 **다항식 장제법**(뺄셈 = XOR).

#### 표준 생성다항식(대표)

| 이름 | 차수 $$r$$ | 표준 다항식(상승차수) | 16진(비반사 표기) | 특성/용도 요약 |
|---|---:|---|---|---|
| CRC-32 (IEEE 802.3) | 32 | $$x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x+1$$ | 0x04C11DB7 | 이더넷 프레임 FCS, 강한 버스트 검출 |
| CRC-32C (Castagnoli) | 32 | $$x^{32}+x^{28}+x^{27}+x^{26}+x^{25}+x^{23}+x^{22}+x^{20}+x^{19}+x^{18}+x^{14}+x^{13}+x^{11}+x^{10}+x^{9}+x^{8}+x^{6}+1$$ | 0x1EDC6F41 | 저장/네트워킹, 짧은 길이에서 우수한 성능 |
| CRC-16-IBM | 16 | $$x^{16}+x^{15}+x^{2}+1$$ | 0x8005 | 산업/시리얼 버스 전통 |
| CRC-16-CCITT(X.25) | 16 | $$x^{16}+x^{12}+x^{5}+1$$ | 0x1021 | 통신/임베디드 표준 |
| CRC-8 | 8 | $$x^{8}+x^{2}+x+1$$ | 0x07 | 소형 헤더/센서 링크 |

> 주의(관례): 구현은 **반사(reflection)**, **초기값(Init)**, **최종 XOR(XorOut)**, **비트 순서** 등의 관례를 함께 정의한다. 다항식 자체는 수학적 정의이고, 관례는 **엔지니어링 프로파일**이다.

---

### Cyclic Code Encoder Using Polynomials — 절차와 예제

#### **Systematic** 인코딩(실무 표준)

1. 데이터 $$M(x)$$ 뒤에 0을 $$r$$개 붙여 $$M(x)x^{r}$$ 형성
2. $$G(x)$$ 로 나눈 **나머지** $$R(x)$$ 계산
3. 전송 다항식 $$T(x)=M(x)x^{r}+R(x)$$ (앞쪽은 원문, 뒤쪽은 패리티)

#### **손계산 예제(소형)**

- $$G(x)=x^{3}+x+1\ (1011),\ r=3$$
- 데이터 $$M=11010011101100$$
- $$M(x)x^{3}$$ 을 $$G(x)$$ 로 나눔 → **나머지** $$R=100$$
- **전송 코드워드**: $$T=11010011101100\underline{100}$$
- 수신은 $$T(x)\bmod G(x)=0$$ 여부만 검사

#### **신드롬 관점**

- 선형 블록 코드로서 $$H$$ 를 잡으면, 수신 $$\mathbf{r}$$ 의 신드롬 $$\mathbf{s}=H\mathbf{r}^\top$$
- CRC의 “나머지”는 곧 **신드롬**: $$ \text{Remainder}(T(x),G(x))\equiv \mathbf{s} $$

---

### Cyclic Code Analysis — 거리·버스트·미검출 확률

#### 최소거리와 검출보장

- **최소 해밍거리** $$d_{\min}$$ 를 갖는 사이클릭 코드:
  $$
  \text{항상 검출 가능한 오류 수}=d_{\min}-1,\qquad
  \text{항상 정정 가능한 오류 수}=t=\left\lfloor\frac{d_{\min}-1}{2}\right\rfloor
  $$
- CRC는 **검출력 최적화**를 목표로 $$G(x)$$ 를 선택(정정 목적 아님).

#### 버스트 오류

- 오류 패턴이 **연속 구간**에 집중(길이 $$L$$).
- **정리**: $$L<r$$ 이면 **항상 검출**. $$L=r$$ 이면 **거의 항상** 검출(특정 구조 제외).

#### 홀수 오류

- $$(x+1)\mid G(x)$$ 이면 **홀수 개 비트** 반전은 **항상 검출**.

#### 미검출 확률 근사

- 랜덤 오류의 **미검출** 확률은 일반적으로
  $$
  P_{\text{undetect}}\approx 2^{-r}
  $$
  (메시지 길이·분포·다항 선택에 약간 의존. 대형 CRC일수록 급감.)

#### 실무 설계 고려

- **프레임 길이**가 짧거나 중간일 때 **CRC-32C** 계열이 우수한 통계적 거리 성능을 보이는 사례가 널리 알려져 있다.
- **길이 분포**(헤더/짧은 메시지 vs 대형 블록), **버스트 모델**, **하드웨어 지원**(병렬/반사)로 다항을 고른다.

---

### Advantages of Cyclic Codes — 왜 사이클릭인가

1. **강력한 검출력**: 버스트·복합 오류에 체계적 보장
2. **고정 오버헤드**: $$r$$ 비트 고정
3. **스트리밍 친화**: 비트가 들어오며 **직렬 LFSR**로 즉시 갱신
4. **하드웨어 효율**: 게이트 수 적고, **파이프라인/병렬화** 용이
5. **표준과 호환**: 이더넷, 저장장치, 많은 산업 버스에 포섭

---

### Other Cyclic Codes — BCH, RS 등과의 관계

- **BCH 코드**: GF$$(2^m)$$ 상에서 설계되는 **정정용 사이클릭 코드**. 생성다항 $$G(x)$$ 가 다수의 **연속한 사이클로토믹 근**을 포함하도록 선택되어, **정확히 $$t$$ 비트 오류 정정** 보장.
- **Reed–Solomon(RS)**: GF$$(2^m)$$ 상 **심볼(바이트 등)** 단위의 **사이클릭 블록 FEC**. **버스트 심볼** 정정에 탁월; 저장·광전송·방송에 널리 쓰임.
- **Shortened/Extended Cyclic Codes**: 시스템 프레임에 맞춰 길이 조정.
- **CRC-64** 계열: 대용량 블록 무결성(아카이브, 파일시스템)에서 사용.

> 포인트: **CRC는 검출**, **BCH/RS는 정정**이 주력. 시스템은 **CRC+ARQ** 또는 **RS/LDPC+CRC** 같은 **중첩 설계**를 사용한다.

---

### Hardware Implementation — LFSR, 병렬화, 실무 파라미터

#### LFSR(Linear Feedback Shift Register) 모델

- **피드백 다항식**이 $$G(x)$$ 와 동형. **입력 비트**를 시프트하며 특정 탭의 XOR로 피드백 생성.
- 직렬 구조의 **상태 레지스터** 크기는 $$r$$ 비트.

#### 직렬 vs 병렬

- **직렬 LFSR**: 한 클록당 1비트 처리 → 간단·저전력
- **병렬 언폴딩**: 한 클록당 N비트(바이트/워드) 처리. 다항식 전개로 **XOR 네트워크** 구현
- **파이프라인**: 긴 경로를 단계로 나눠 클록 상승

#### 구현 관례 파라미터

- **RefIn/RefOut**(비트 반사), **Init**(예: 0xFFFF_FFFF), **XorOut**(예: 0xFFFF_FFFF)
- **CRC 포함/제외 범위**(헤더/페이로드), **삽입 위치**(후미 FCS 등)

#### 프레임 워터마킹

- 송신 말단에서 CRC 레지스터 값을 **보수/반사** 후 **FCS 필드**에 삽입
- 수신은 **전체 프레임+FCS**를 동일 규칙으로 처리해 **잔여 0**(또는 관례적 상수)인지 확인

#### 직관적 동치성

- **다항식 장제법** ≡ **LFSR 상태 갱신**. 수학과 하드웨어가 **완벽히 일치**한다.

---

## Checksum

### Concept — 인터넷 체크섬과 변형

#### 기본 개념

- **고정 길이 워드**(보통 16비트)를 **1의 보수 덧셈**으로 모두 합산하고, 그 **보수**를 전송.
- 수신 측은 **모든 워드 + 체크섬**의 1의 보수 합이 **all-ones**(또는 **0**)가 되면 통과.

**정의(16비트 워드)**
$$
S=\bigoplus_{i=1}^{N} W_i\quad(\text{1의 보수 합, 캐리 폴딩}),\qquad
C=\sim S
$$
수신 검증:
$$
\bigoplus_{i=1}^{N} W_i \oplus C=\text{0xFFFF}
$$

#### 성질

- **가벼운 계산**(헤더 보호에 적합), **순서 독립적 재합산 가능**(라우터의 TTL 감소 등 **증분 업데이트** 용이).
- 그러나 **상쇄 오류**(워드 교환·보상)에는 약하다. 구조적 **거리 보장**이 CRC보다 낮다.

#### 예시 시나리오(헤더 위주 보호)

- IPv4/TCP/UDP는 **헤더 무결성** 중심의 16비트 체크섬을 사용(페이로드는 링크 CRC/상위 MAC으로 보강).
- 전송 스택에서는 **의사 헤더(pseudo-header)** 를 더해 **종단지간 주소·프로토콜**을 간접 보호:
  $$
  \text{Checksum} = \sim \Big(\text{sum of (header + data + pseudo-header)}\Big)
  $$

---

### Other Approaches to the Checksum — 변형/대안 기법

#### Fletcher Checksum

- 데이터 바이트열 $$b_i$$ 에 대해 **이중 누적 합**:
  $$
  A=\sum_{i=1}^{n} b_i\ \bmod\ m,\qquad
  B=\sum_{i=1}^{n} A\ \bmod\ m
  $$
  $$(A,B)$$ 를 결합해 최종 체크섬. 통상 $$m=255\ \text{or}\ 65535$$.
- **장점**: 단순 덧셈만으로 **위치 민감성**을 키움(초기 바이트 영향이 끝까지 누적).
- **한계**: CRC보다 **버스트 대응력** 약함. 그러나 1의 보수 합보다는 일반적으로 강함.

#### Adler-32

- Fletcher 계열 변형. 바이트 합을 **모듈러 소수** $$65521$$ 로 계산:
  $$
  A=\Big(\sum b_i\Big)\bmod 65521,\qquad
  B=\Big(\sum A\Big)\bmod 65521,\qquad
  \text{Adler-32}=(B\ll 16)\ \vert\ A
  $$
- **장점**: 계산 매우 경량, 소프트웨어 구현 용이.
- **한계**: **짧은 메시지**에서 검출력이 기대 이하인 것으로 널리 알려져 있으며, **CRC-32C**가 실무 대체되는 경우가 많다.

#### 가중치 합·위치 의존 체크섬

- $$\sum w_i \cdot b_i \bmod M$$ 형태(가중치 $$w_i$$ 로 위치 민감도 강화).
- 설계가 임의적이면 **거리 보장**이 약할 수 있어 주의.

#### 합성 전략

- **체크섬 + CRC**: 헤더는 체크섬(저비용), 전체 프레임은 CRC(강력)로 **중첩**.
- **체크섬 + 암호학적 MAC**: 네트워크 무결성(전송 오류)과 **변조 방지**(보안)를 역할 분담.

---

## 예제 모음(소스코드 없이 절차·수식 중심)

### 손계산

- $$G(x)=x^3+x+1,\ r=3,\ M=1010011$$
- $$M(x)x^3$$ 를 $$G(x)$$ 로 나눔 → 나머지 $$R=010$$
- 전송: $$T=1010011\underline{010}$$
- 수신: $$T(x)\bmod G(x)=0$$ 확인

### 예제 2 — 홀수 오류 보장

- $$(x+1)\mid G(x)\Rightarrow$$ 홀수 개 비트 반전 시
  $$
  \sum \text{비트} \equiv 1\pmod 2 \Rightarrow \text{나머지}\neq 0
  $$

### 예제 3 — 1의 보수 체크섬 상쇄 실패

- 두 워드가 **동일량 반대 변화**를 가질 때:
  $$
  \Delta W_1 + \Delta W_2 = 0\ \text{(end-around-carry 포함)} \Rightarrow \text{검출 실패 가능}
  $$

### 예제 4 — Fletcher-16 절차 개요(바이트 단위)

- 바이트열 $$b_1,\dots,b_n$$:
  $$
  A=\sum b_i \bmod 255,\qquad B=\sum A \bmod 255
  $$
  최종값은 $$B\cdot256+A$$ 로 패킹. 초반 바이트의 영향이 끝까지 누적되어 **순열 변화**에 민감.

---

## 비교 표 — CRC vs 인터넷 체크섬 vs Fletcher/Adler

| 기준 | CRC-32/16 | 인터넷 체크섬(1’s comp.) | Fletcher(16/32) | Adler-32 |
|---|---|---|---|---|
| 계산 복잡도 | 중(배타합+시프트, HW 가속 용이) | 매우 낮음 | 낮음 | 매우 낮음 |
| 버스트 검출 | **매우 강력**(차수 $$r$$ 기반 보장) | 약~중 | 중 | 중(짧은 메시지 약점) |
| 거리 보장 | 설계로 체계적 보장 | 불명확(경험적) | 경험적(체크섬보다 우수) | 경험적 |
| 하드웨어 | **LFSR 최적** | 단순 가산기 | 가산기 | 가산기 |
| 사용 적합 | 프레임/파일 무결성 | 헤더 경량 보호, 증분 | SW 경량, 임베디드 | SW 경량(대체 추세 있음) |

---

## 설계 가이드(요약)

1) **프레임 전체 무결성**이 중요하거나 **버스트**가 잦다 → **CRC**(CRC-32/32C/16)
2) **헤더만 보호**, 증분 업데이트 필요 → **1의 보수 체크섬**
3) **소프트웨어 경량**·중간 수준 검출 → **Fletcher**(또는 현대에는 **CRC-32C**로 대체 검토)
4) 보안까지 필요하면 **MAC/AEAD**를 별도로 덧씌운다(무결성≠진위).

---

## 부록 — 하드웨어 사고방식 도해(개념)

- **LFSR 직렬 처리**: 매 비트 입력 시
  $$
  \text{state}_{t+1} = \text{Shift}\big(\text{state}_t\big)\ \oplus\ \text{TapXOR}\big(\text{state}_t,\,\text{in}_t\big)
  $$
- **병렬 언폴딩**: 바이트/워드 단위 입력. 다항식 전개로 **조합 논리**(XOR 매트릭스) 구성.
- **검증 규칙**: 수신 시 전체(데이터+FCS)를 같은 규칙에 넣어 **잔여 0**(또는 관례적 상수)이면 통과.

---

## 결론

- **사이클릭 코드(특히 CRC)** 는 **버스트·복합 오류**를 강하게 검출하고, **LFSR** 기반으로 **고속·저자원** 구현이 가능하다.
- **체크섬**은 **헤더 경량 보호**와 **증분 갱신**에 유리하지만, 구조적 오류에 **취약**하므로 **CRC/보안 무결성**과 **중첩**하는 것이 현대적이다.
- 실제 시스템은 **CRC(FCS)** + **ARQ/HARQ** + (필요 시) **FEC** + **암호학적 무결성**을 **계층적**으로 결합해 **성능·지연·신뢰**를 균형시킨다.
