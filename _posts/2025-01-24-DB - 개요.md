---
layout: post
title: DB - 개요
date: 2025-01-24 19:20:23 +0900
category: DB
---
# 데이터베이스(Database) 개요

## 리마인드: 왜 역사가 중요한가

- 같은 “CRUD”라도 **시대별 제약**(하드웨어·네트워크·사용자 수·데이터 유형)에 따라 **설계 철학과 API**가 달라졌다.
- 오늘의 선택(예: RDB, NoSQL, NewSQL, DBaaS)은 **어제의 한계와 해결 아이디어**에서 비롯되었다.
- 아키텍처 결정을 설명할 때 “왜 그 기술인가?”를 역사적으로 뒷받침하면 **설득력**과 **유지보수성**이 올라간다.

---

## 1950–1960년대: 파일 시스템의 시대

### 문제 정리

- 저장은 **파일(텍스트/CSV/고정폭 레코드)** 중심.
- **중복·정합성·검색 성능·동시성** 문제가 빈번.
- 레코드 구조와 관계(참조)를 **응용프로그램 코드**가 직접 관리 → 유지보수 지옥.

### 대표적 접근

- **순차파일·인덱스 순차 접근(ISAM)** 등 원시적 색인 구조.
- 업무별로 파일이 쪼개져 **사일로화**.

### 예제: 인사 파일 2개를 프로그램이 직접 조인

```pseudo
open employees.csv   # 사번,이름,부서코드
open departments.csv # 부서코드,부서명
for e in employees:
    d = find_in_departments(e.dept_code)   # 선형검색 or 단일 인덱스
    print(e.empno, e.name, d.dept_name)
```
- 관계(사번↔부서코드)를 **코드가 직접** 해결. 데이터 정규화/무결성 체계가 없음.

---

## 1960–1970년대: 계층형·네트워크형 DBMS

### 문제 정리

- 파일시스템의 **참조 무질서**와 **중복**을 줄이기 위해 **구조화된 저장 모델** 필요.
- **계층형(Hierarchical)**: 트리(부모-자식)로 데이터 조직 (IBM **IMS**).
- **네트워크형(Network/CODASYL)**: 레코드 타입 간 다대다를 **세트(Set)**로 연결.

### 장단점

- 장점: 파일시대 대비 **참조 일관성·성능** 향상.
- 단점: **응용 로직이 스키마 구조(경로/세트)에 강결합**. 질의가 절차적이며 **유연성 부족**.

### 예시: 계층형을 문서(JSON)로 비유해 보기

```json
{
  "Dept": {
    "DeptCode": "D10",
    "DeptName": "R&D",
    "Employees": [
      {"EmpNo": 1001, "Name": "Kim"},
      {"EmpNo": 1002, "Name": "Lee"}
    ]
  }
}
```
- 트리 경로를 따라가야만 원하는 데이터 도달. “사번→부서” 역방향 질의가 번거롭다.

---

## 1970년대: 관계형 모델(RM)과 SQL의 탄생

### 혁신 포인트

- 에드가 F. 커드(1970): 데이터를 **릴레이션(테이블)**로, 질의를 **선언적**으로.
- **데이터 독립성**(논리/물리 분리), **수학적 기반(집합·튜플 연산)**, **정규화 이론**.
- 연구→시제품(IBM System R, Ingres)→상용(Oracle 등)로 확대.

### 관계형 핵심

- 스키마: 테이블·속성·키·제약.
- 질의: “무엇을”만 선언(SQL), “어떻게”는 옵티마이저가 결정.
- **정규화**: 이상현상 제거, 중복 최소화.

### 미니 예제: 릴레이션과 SQL

```sql
CREATE TABLE dept (
  dept_id   INT PRIMARY KEY,
  dept_name VARCHAR(100) NOT NULL
);

CREATE TABLE emp (
  emp_id    INT PRIMARY KEY,
  emp_name  VARCHAR(100) NOT NULL,
  dept_id   INT NOT NULL REFERENCES dept(dept_id)
);

INSERT INTO dept VALUES (10, 'R&D'), (20, 'Sales');
INSERT INTO emp  VALUES (1001,'Kim',10),(1002,'Lee',10),(1003,'Park',20);

-- 선언적 질의: "R&D 소속 사원 이름"
SELECT e.emp_name
FROM emp e
JOIN dept d ON d.dept_id = e.dept_id
WHERE d.dept_name = 'R&D';
```

### 관계대수 표기와 매핑

- 선택(σ), 투영(π), 조인(⨝), 집합연산(∪, −).
- 예: “R&D 소속 사원”
  $$ \pi_{\text{emp\_name}} \big( \sigma_{\text{dept\_name}='R\&D'}(dept) \ \underset{\text{dept\_id}}{\bowtie} \ emp \big) $$

---

## 1980–1990년대: RDBMS 상용화와 전성기

### 표준화와 기능 확장

- SQL-86/89/92 표준화, 트랜잭션/락/인덱스/뷰/트리거/스토어드 프로시저 등.
- **ACID** 보장으로 금융·제조·공공 기반 시스템의 신뢰성 향상.

### 인덱스·트랜잭션·정규화 빠르게 짚기

- **B-Tree/B+Tree**: 범위/정렬 질의 효율.
- **ACID**:
  - 원자성(Atomicity)
  - 일관성(Consistency)
  - 격리성(Isolation)
  - 지속성(Durability)
- 격리수준: READ COMMITTED / REPEATABLE READ / SERIALIZABLE 등.

### 예제: 트랜잭션과 인덱스

```sql
-- 인덱스
CREATE INDEX idx_emp_dept ON emp(dept_id);

-- 트랜잭션 (송금)
BEGIN;
UPDATE account SET balance = balance - 1000 WHERE acct_no = 'A001';
UPDATE account SET balance = balance + 1000 WHERE acct_no = 'B001';
-- 무결성 확인 후
COMMIT;
```

### 데이터웨어하우스·OLAP의 전조

- 운영(OLTP)과 분석(OLAP) 분리 필요성 대두.
- 스타/스노우플레이크 스키마, 집계 인덱스, 물질화 뷰.

---

## 1990년대: OODBMS와 객체관계(ORDBMS) 시도

### 동인

- 객체지향 언어 확산 → 객체와 스키마의 임피던스 불일치 해소 시도.
- **OODBMS**: 객체를 그대로 저장·탐색.
- **객체관계(ORDBMS)**: RDB에 타입/UDT/객체 기능 가미(Oracle Object, PostgreSQL 확장성).

### 교훈

- 범용 상용 성공은 제한적.
- ORM, 확장 타입, JSON 컬럼 등 **RDB 내 점진적 융합**이 주류로 귀결.

---

## 2000년대: 웹 대중화와 수평 확장·유연 스키마 요구

### 배경

- 사용자 급증, 글로벌 트래픽, 빅데이터 로그, 컨텐츠 폭증.
- 단일 RDBMS의 **수직 확장 한계**, 스키마 변경/마이그레이션 부담.

### NoSQL의 부상

- “Not Only SQL”: 선택/절충의 프레임.
- 유형:
  - **문서형**(MongoDB): JSON/BSON
  - **키값형**(Redis): 초고속 캐시/세션/카운터
  - **컬럼형**(Cassandra, HBase): 와이드 컬럼, 쓰기/수평 확장 우위
  - **그래프형**(Neo4j): 관계 중심 질의

### CAP·BASE 직관

- 네트워크 분할(P) 존재 하에 **일관성(C)** vs **가용성(A)** 절충.
- 대략적 직관:
  $$ \text{if } P \text{ occurs, choose } C \text{ or } A $$
- BASE(Basically Available, Soft state, Eventual consistency): **최종 일관성**.

### 예제: 문서형으로 상품+옵션 저장(스키마 유연)

```javascript
// products (MongoDB)
{
  "_id": "p-1001",
  "name": "Running Shoes",
  "variants": [
    {"sku": "p-1001-BL-260", "color": "Blue", "size": 260, "stock": 5},
    {"sku": "p-1001-BL-270", "color": "Blue", "size": 270, "stock": 0}
  ],
  "tags": ["sports","men"]
}

// 품절이 아닌 Blue만 찾기
db.products.find({
  "variants": { $elemMatch: { color: "Blue", stock: { $gt: 0 } } }
}, { name: 1, "variants.$": 1 })
```
- 스키마 변경이 잦은 영역에서 이점. 반면 조인이 필요하면 **중복과 업데이트 전파** 관리 필요.

---

## 2010년대–현재: NewSQL, 분산 트랜잭션, 클라우드 DBaaS

### 동인

- “SQL·트랜잭션의 생산성” + “NoSQL의 수평 확장성”을 동시에 원함.
- **분산 합의(예: Paxos/Raft)**, **전역 시계**(하이브리드 물리-논리 시계), **스케일아웃 스토리지**.

### NewSQL 개념

- 행/키 범위를 샤딩하고, 샤드 간 트랜잭션을 합의와 분산 타임스탬프로 직렬화 보장.
- 예) 범용 NewSQL/클라우드 네이티브 RDBMS.

### 클라우드 DBaaS

- **RDS, Managed PostgreSQL/MySQL**, **Serverless** 옵션, 자동 백업/페일오버/스케일링.
- 인프라 복잡도를 서비스에 위임 → 팀은 **스키마·인덱스·쿼리·보안**에 집중.

### 예제: 수평 파티셔닝을 고려한 스키마·쿼리

```sql
-- 주문을 고객ID 해시로 여러 샤드에 분산한다고 가정
CREATE TABLE orders (
  order_id     BIGINT PRIMARY KEY,
  customer_id  BIGINT NOT NULL,
  created_at   TIMESTAMP NOT NULL,
  total_amount NUMERIC(12,2) NOT NULL,
  status       VARCHAR(20) NOT NULL,
  -- 파티셔닝 키(샤딩키)로도 사용
  -- NewSQL/클라우드에 따라 PARTITION BY HASH(customer_id) 같은 구문 지원
);

-- 고객 단위 트랜잭션: 같은 파티션/샤드에 머물 가능성이 높아 유리
BEGIN;
INSERT INTO orders(order_id, customer_id, created_at, total_amount, status)
VALUES (10000001, 501, NOW(), 129000, 'PAID');
-- 고객 잔액 차감·포인트 적립 등도 같은 키 기준으로 묶으면 분산 트랜잭션 비용 감소
COMMIT;
```

---

## 빠른 연표 요약 + 대표 시스템

| 시기 | 문제의식 | 해법/모델 | 대표 시스템/키워드 |
|---|---|---|---|
| 50–60s | 파일 난립, 중복·정합성 곤란 | ISAM, 응용 코드로 관계 해소 | 메인프레임 파일 처리 |
| 60–70s | 데이터 구조화·참조 일관성 | 계층형(IMS), 네트워크(CODASYL) | IBM IMS, IDMS |
| 70s | 선언적 질의·데이터 독립성 | 관계형 모델 + SQL | System R, Ingres |
| 80–90s | 상용화·ACID·표준화 | RDBMS 전성기, DW 전초 | Oracle/DB2/SQL Server/PostgreSQL |
| 00s | 웹 규모·유연 스키마 | NoSQL, CAP/BASE | MongoDB, Cassandra, HBase, Redis, Neo4j |
| 10s~ | SQL+수평확장, 운영 단순화 | NewSQL, 분산 트랜잭션, DBaaS | Cloud RDBMS/Spanner-like, Managed PG/MySQL |

---

## 정규화·인덱스·트랜잭션: 역사에서 현재까지 이어지는 핵심

### 정규화의 목적과 실무 절충

- 1NF/2NF/3NF/BCNF → **이상현상 제거**·중복 최소화.
- 분석·검색 패턴에 따라 **반정규화(중복·물질화 뷰)**도 선택.

#### 예제: 3NF로 쪼개기

```sql
-- 비정규 테이블 OrdersWide(order_id, customer_name, customer_city, city_zip, ...)
-- 함수적 종속: customer_name -> (customer_city, city_zip)
-- 고객/도시 정보를 별도 테이블로 분리

CREATE TABLE customer (
  customer_id   BIGINT PRIMARY KEY,
  customer_name TEXT NOT NULL UNIQUE
);

CREATE TABLE city (
  city_id   BIGINT PRIMARY KEY,
  name      TEXT NOT NULL,
  zip       TEXT NOT NULL
);

CREATE TABLE customer_profile (
  customer_id BIGINT PRIMARY KEY REFERENCES customer(customer_id),
  city_id     BIGINT NOT NULL REFERENCES city(city_id)
);

CREATE TABLE orders (
  order_id     BIGINT PRIMARY KEY,
  customer_id  BIGINT NOT NULL REFERENCES customer(customer_id),
  created_at   TIMESTAMP NOT NULL,
  total_amount NUMERIC(12,2) NOT NULL
);
```

### 인덱스의 역사적 맥락

- B-Tree 계열은 범용. **조인/정렬/범위**에 강함.
- LSM-Tree 계열은 쓰기 폭주·HDD 시절 순차쓰기 최적화에서 각광, 오늘날에도 **대량 쓰기/압축/Compaction**으로 여전히 유효.

#### 예제: 조합 인덱스와 실행계획 힌트

```sql
CREATE INDEX idx_orders_customer_created ON orders(customer_id, created_at);

EXPLAIN
SELECT order_id
FROM orders
WHERE customer_id = 501
  AND created_at >= NOW() - INTERVAL '7 days'
ORDER BY created_at DESC
LIMIT 50;
```

### 트랜잭션 격리와 동시성 제어

- 80–90s: 2PL, MVCC 등 정립.
- 오늘: MVCC가 범용. 읽기 부하와 지연에 우수.

#### 예제: 격리 수준 비교

```sql
-- 세션 A
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN;
SELECT SUM(total_amount) FROM orders WHERE customer_id = 501; -- T1
-- 세션 B가 삽입/커밋 후
SELECT SUM(total_amount) FROM orders WHERE customer_id = 501; -- T2 (변할 수 있음)
COMMIT;

-- 세션 A (REPEATABLE READ)
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
SELECT SUM(total_amount) FROM orders WHERE customer_id = 501; -- T1
-- 세션 B의 커밋과 무관하게, 같은 스냅샷 유지
SELECT SUM(total_amount) FROM orders WHERE customer_id = 501; -- 여전히 T1
COMMIT;
```

---

## NoSQL 설계 감각: 문서·키값·컬럼·그래프

### 문서형(카탈로그·콘텐츠)

- 동일 문서 내 **지역적 일관성** 확보.
- 조인 대신 **중복과 버전 관리**가 관건.

```javascript
// 댓글을 문서 내 임베드
{
  "_id": "post-2001",
  "title": "History of Databases",
  "comments": [
    {"user":"Kim","body":"Great!","ts": 1730380000},
    {"user":"Lee","body":"Add IMS!","ts": 1730381000}
  ]
}
```

### 키값형(세션·캐시·카운터)

```text
SET sess:abc123 '{"uid":501,"exp":1730500000}'
INCR view:post:2001
PFADD uv:2025-11-06 user:501
```

### 컬럼형(이벤트 로그·타임시리즈)

- 와이드 로우, 파티션키 설계가 성패 좌우.
- 읽기 패턴에 맞춘 **정렬 키** 고정.

### 그래프형(추천·네트워크)

```cypher
MATCH (u:User {id:501})-[:FOLLOWS]->(f)-[:LIKES]->(p:Post)
RETURN p
ORDER BY p.score DESC
LIMIT 20;
```

---

## NewSQL/분산 트랜잭션 감각

### 직렬가능성과 전역 타임스탬프

- 직렬가능 스케줄의 직관:
  $$ \exists \ \text{순서} \ S \ \text{s.t. 결과가 동등} $$
- 분산환경: 각 샤드가 합의로 커밋 순서를 정하고, 전역 시계를 활용해 **충돌 순서**를 일관되게 판단.

### 실무 설계 팁

- **샤딩키**를 트랜잭션 경계와 일치시키기.
- 멀티 샤드 트랜잭션은 **희소**하게 만들기.
- 보조 인덱스/세컨더리 키는 라우팅 계층에서 **키→샤드 매핑**을 캐시.

---

## 마이그레이션 시나리오: “모놀리식 RDB → 하이브리드”

### 목표

- 안정적 **거래(트랜잭션) 경로**는 RDB 유지.
- **고가용·대량 쓰기**의 이벤트/로그/피드/캐시는 NoSQL로 분리.
- 점진적으로 **분할 정복**.

### 단계별 로드맵

1) **읽기 캐시** 도입(키값형) → RDB 부하 완화
2) **이벤트 로그**를 컬럼형/스트리밍 스토어로 분리
3) **스키마 잦은 도메인**은 문서형으로 독립
4) **분산 트랜잭션** 필요한 일부 도메인에 NewSQL/클라우드 RDB 고려

### 코드 스케치: CQRS + 이벤트소싱 일부 적용

```sql
-- RDB: 정합성이 중요한 주문 상태
CREATE TABLE orders (
  order_id BIGINT PRIMARY KEY,
  customer_id BIGINT NOT NULL,
  status VARCHAR(20) NOT NULL,
  created_at TIMESTAMP NOT NULL
);

-- 컬럼형/로그: 주문 이벤트 Append-Only
-- (시스템에 따라 CQL/Put/Append API로 기록)

-- 조회 API: RDB의 최신 상태 + 캐시
-- 이벤트 컨슈머: 이벤트를 비정규화 뷰(문서형/서치엔진)에 반영
```

---

## 운영·보안·컴플라이언스: 시대 불문 필수 체크

### 백업·복구

- PITR(Point-In-Time Recovery), 스냅샷·증분 백업.
- 재해복구(RPO/RTO) 목표 명문화.

### 모니터링

- 레이턴시 p95/p99, QPS, 활성 세션, 락 대기, 캐시 히트율, WAL/REDO 지연, Compaction 지표.
- 쿼리 플랜 회귀 탐지, 스키마 변경 전후 성능 비교.

### 보안

- 최소권한 원칙(테이블/스키마/열 단위).
- TDE(암호화), 전송구간 TLS, 감사로그, 키관리.
- 멀티테넌시 분리 전략(스키마 분리/행 수준 보안/별도 인스턴스).

---

## 실전 예제 모음

### “계층형→관계형” 전환 쿼리 감각 익히기

```sql
-- 원문: 한 Dept에 여러 Emp가 붙은 트리
-- 관계형: 외래키로 매핑
SELECT d.dept_name, e.emp_name
FROM dept d
JOIN emp e ON e.dept_id = d.dept_id
WHERE d.dept_name LIKE 'R%';
```

### “문서형→검색” 보조 인덱싱 파이프라인 스케치

```python
# Pseudocode: product 문서를 소비해 검색엔진 색인 문서로 변환

def index_product(doc):
    base = {
        "id": doc["_id"],
        "name": doc["name"],
        "tags": doc.get("tags", [])
    }
    for v in doc.get("variants", []):
        emit_to_search({
          **base,
          "sku": v["sku"],
          "color": v.get("color"),
          "size": v.get("size"),
          "stock": v.get("stock", 0)
        })
```

### “RDB 단일 인스턴스→샤딩” 키 설계

```sql
-- 키 충돌을 줄이고 균형 배분을 노리되, 조회 패턴을 우선
-- 고객단위 조회가 95%면 customer_id 해시 샤딩이 자연스러움.
-- 다만 "주문번호 순 최근 100건" 같은 글로벌 정렬 요구가 있으면
-- 타임+랜덤 혼합 키를 사용하고 보조 색인이나 서치엔진을 곁들임.
```

### 트랜잭션 vs 최종일관: 금액 집계와 피드

```sql
-- 금액 집계(강한 일관성 필요)
BEGIN;
UPDATE wallet SET balance = balance - 1000 WHERE user_id = 501;
UPDATE wallet SET balance = balance + 1000 WHERE user_id = 502;
COMMIT;

-- 피드/알림(약한 일관성 허용): 이벤트 저장 후 비동기 Fan-out
-- "알림이 몇 초 늦게 보여도 무방"한 UX 설계와 짝
```

---

## 역사적 키워드와 오늘의 실무 연결

- **IMS/Hierarchical** → 문서형 DB 사용 시 **경로 고정**의 장단을 떠올리자.
- **CODASYL/Network** → 그래프DB 질의가 강력하지만 **모델 설계 난이도**도 높다는 사실.
- **관계형/정규화** → 여전히 트랜잭션 도메인의 표준. 반정규화는 **측정 후 도입**.
- **NoSQL** → 데이터 모델이 API·쿼리 패턴에 **하드코딩**됨을 항상 의식.
- **NewSQL** → “거래 보장 + 수평 확장”의 대안. **샤딩키/트랜잭션 경계** 설계가 핵심.
- **DBaaS** → 운영 편하지만, **쿼리/스키마 품질**은 여전히 팀의 책임.

---

## 학습/포트폴리오 확장 제안

1) **동일 도메인**을 RDB·문서형·컬럼형·그래프형 4종으로 각각 모델링해 **장단 비교 글**을 쓰자.
2) **샤딩·인덱스 실험**: 동일 질의를 키 설계만 바꿔 성능 차이를 수치화.
3) **정규화↔반정규화 A/B**: 갱신·읽기 패턴별 비용을 프로파일링.
4) **클라우드 매니지드 vs 셀프호스팅** TCO 비교.

---

## 마무리 요약

- 파일시대의 혼돈 → 계층/네트워크의 구조화 → **관계형과 SQL의 선언성** →
  웹 규모의 도전과 **NoSQL** → **NewSQL/클라우드**로의 수렴과 재통합.
- 오늘의 DB 선택은 “**데이터 모델** × **트랜잭션 요구** × **확장/운영 제약**”의 함수.
- 역사를 알면, **왜 이 모델을 쓰는지**와 **어떻게 절충할지**가 명확해진다.

---

# 부록 A. 미니 실습 세트

## A.1 정규화 전후 비교 쿼리

```sql
-- 비정규 테이블: OrdersWide(order_id, customer_name, city, zip, total)
-- 1) 특정 도시 매출
SELECT city, SUM(total) AS sales
FROM OrdersWide
GROUP BY city;

-- 정규화 후
SELECT c.name AS city, SUM(o.total_amount) AS sales
FROM orders o
JOIN customer_profile cp ON cp.customer_id = o.customer_id
JOIN city c ON c.city_id = cp.city_id
GROUP BY c.name;
```

## A.2 조합 인덱스의 효과 관찰

```sql
CREATE INDEX idx_orders_cust_ts ON orders(customer_id, created_at);

-- 필터 + 정렬 일치 → 인덱스 스캔 + Limit
EXPLAIN ANALYZE
SELECT order_id, created_at
FROM orders
WHERE customer_id = 501
  AND created_at >= NOW() - INTERVAL '30 days'
ORDER BY created_at DESC
LIMIT 20;
```

## A.3 문서형 쿼리 패턴 튜닝

```javascript
// 불필요한 대량 필드 제외 투영, 배열 한 건만 당겨오기
db.posts.find(
  { "comments": { $elemMatch: { user: "Kim", ts: { $gt: 1730380000 } } } },
  { title: 1, "comments.$": 1 }
);
```

## A.4 CQRS 리드모델 구축(의사코드)

```python
# 이벤트 스트림 -> 읽기모델(비정규화)

def on_order_paid(event):
    # event: {order_id, customer_id, ts, amount}
    upsert_read_model(order_id=event["order_id"], view={
        "order_id": event["order_id"],
        "customer_id": event["customer_id"],
        "paid_at": event["ts"],
        "amount": event["amount"]
    })
```

---

# 부록 B. 용어 맵

- **ACID**: 트랜잭션 4대 속성.
- **BASE**: 분산 시스템에서의 느슨한 일관성 철학.
- **MVCC**: 버전 기반 동시성 제어.
- **B-Tree/LSM-Tree**: 인덱스/저장 엔진 핵심 구조.
- **CAP**: 분할 내성 하에서 C vs A 절충.
- **CQRS/EventSourcing**: 쓰기 모델과 읽기 모델 분리/이벤트 중심 상태 복원.
- **DBaaS**: 관리형 데이터베이스 서비스.
- **NewSQL**: SQL·트랜잭션 + 수평 확장.

---

# 참고 학습 과제

1) 동일 질의를 RDB SQL, 문서형(집계 파이프라인), 그래프 질의로 각각 구현.
2) 1억 건 타임시리즈를 컬럼형과 RDB 파티션 테이블에 적재해 **쓰기/읽기/보관비용** 비교.
3) 샤딩키 후보 3개 설계 후 **핫 키/스캐터 쓰기/조인 비용**을 시뮬레이션.
