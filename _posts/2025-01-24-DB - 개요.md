---
layout: post
title: DB - 개요
date: 2025-01-24 19:20:23 +0900
category: DB
---
# 데이터베이스 역사와 설계 철학의 흐름

## 서문: 역사가 중요한 이유

데이터베이스의 진화는 단순한 기술 교체가 아니라, 시대적 제약과 요구사항에 대한 지속적인 응답의 과정입니다. 같은 "CRUD" 작업이라도 하드웨어 성능, 네트워크 환경, 사용자 규모, 데이터 특성에 따라 그 설계 철학과 구현 방식은 근본적으로 달라져왔습니다. 오늘날 우리가 RDB, NoSQL, NewSQL, DBaaS 중 하나를 선택하는 것은 결국 어제의 한계를 돌파하고자 했던 수많은 시도와 해결책의 연장선에 있습니다. 따라서 기술 선택의 배경을 역사적 흐름 속에서 이해할 때, 비로소 더 설득력 있는 아키텍처 결정을 내리고, 장기적인 유지보수성을 확보할 수 있습니다.

---

## 1950-1960년대: 파일 시스템의 한계

이 시기의 데이터 관리는 순수한 파일 시스템에 의존했습니다. 데이터는 텍스트, CSV, 고정폭 레코드 파일 형태로 저장되었으며, 레코드 간의 관계와 정합성은 전적으로 응용 프로그램 코드가 관리해야 했습니다. 이로 인해 데이터 중복이 심화되고, 일관성을 유지하기 어려우며, 검색 성능과 동시성 처리에 근본적인 한계가 있었습니다. 업무별로 파일이 분리된 '사일로' 구조는 통합된 정보 관리를 불가능하게 만들었습니다.

**예시: 파일 시스템에서의 조인**
프로그램이 두 개의 CSV 파일을 열어, 선형 검색을 통해 사원과 부서 정보를 수동으로 매칭하는 방식은 데이터와 로직의 강한 결합을 보여줍니다. 데이터의 구조와 관계가 코드에 하드코딩되어, 변경이 극히 어려운 유지보수의 지옥이었습니다.

---

## 1960-1970년대: 구조화된 데이터 모델의 등장

파일 시스템의 무질서함을 해결하기 위해, 계층형과 네트워크형 데이터베이스 관리 시스템(DBMS)이 등장했습니다. IBM의 IMS는 트리 구조로 데이터를 조직화한 계층형 모델의 대표주자였으며, CODASYL이 제안한 네트워크 모델은 레코드 타입 간 다대다 관계를 '세트'로 표현했습니다.

이 모델들은 명시적인 구조와 참조를 도입해 파일 시스템 대비 일관성과 성능을 크게 향상시켰습니다. 그러나 근본적인 한계가 남아 있었습니다. 응용 프로그램의 로직이 데이터의 물리적 저장 구조(트리 경로나 세트)에 깊이 의존하게 되어, 데이터 모델을 유연하게 변경하거나 복잡한 질의를 수행하는 것이 매우 번거로웠습니다. 사용자는 '어떻게' 데이터에 접근할지를 절차적으로 명시해야 했습니다.

---

## 1970년대: 관계형 모델의 혁명

에드거 F. 커드가 1970년에 발표한 관계형 모델은 패러다임의 전환을 가져왔습니다. 데이터를 단순한 '릴레이션(테이블)'의 집합으로 추상화하고, 질의를 '무엇을' 원하는지만 선언하는 '선언적' 언어인 SQL을 도입했습니다.

이 혁신의 핵심은 **데이터 독립성**에 있었습니다. 응용 프로그램은 데이터의 논리적 구조(테이블, 열)에만 의존하고, 물리적 저장 방식(인덱스, 파일 레이아웃)으로부터 자유로워졌습니다. 수학적 집합 이론에 기반한 정규화 이론은 데이터 중복과 이상 현상을 체계적으로 제거하는 방법론을 제공했습니다. IBM System R과 Ingres 같은 연구 프로젝트를 거쳐 본격적인 상용 제품(Oracle 등)으로 확산되기 시작했습니다.

**관계형의 핵심: 선언적 질의**
사원과 부서 테이블을 정의하고, 두 테이블을 조인해 'R&D 부서 소속 사원'을 찾는 SQL 문은 그 간결함과 표현력을 보여줍니다. 데이터베이스 시스템의 옵티마이저가 최적의 실행 경로('어떻게')를 결정하게 함으로써 사용자와 개발자의 생산성을 극적으로 높였습니다.

---

## 1980-1990년대: RDBMS의 전성기와 표준화

관계형 데이터베이스는 기업 핵심 시스템의 근간으로 자리매김했습니다. SQL은 ANSI/ISO 표준으로 체계화되었고, 트랜잭션의 **ACID**(원자성, 일관성, 격리성, 지속성) 속성을 보장하는 메커니즘이 정립되었습니다. B-Tree 인덱스는 효율적인 데이터 접근 경로를 제공했고, 뷰, 트리거, 스토어드 프로시저 같은 기능이 추가되며 생태계가 풍부해졌습니다.

동시에 데이터의 폭증으로 운영 처리(OLTP)와 분석 처리(OLAP)의 분리가 대두되었고, 데이터 웨어하우징, 스타/스노우플레이크 스키마, 물질화 뷰 등의 개념이 등장하며 비즈니스 인텔리전스의 기반을 마련했습니다.

---

## 1990년대 후반-2000년대: 객체와 관계의 충돌, 그리고 웹의 도전

객체지향 프로그래밍의 부상은 메모리의 객체와 관계형 테이블 간의 '임피던스 불일치' 문제를 낳았습니다. 이를 해결하려는 OODBMS와 객체-관계형 DBMS(ORDBMS)의 시도가 있었으나, 범용적인 성공은 제한적이었습니다. 결국 ORM(Object-Relational Mapping) 도구의 발전과 PostgreSQL 같은 RDBMS의 확장 기능(JSON, 배열 타입 등)을 통한 점진적 융합이 현실적인 해법으로 자리 잡았습니다.

한편, 인터넷과 웹의 폭발적 성장은 데이터베이스에 새로운 도전을 던졌습니다. 글로벌 규모의 사용자, 초대량의 트래픽과 데이터(로그, 사용자 생성 컨텐츠), 그리고 빠른 기능 반복을 위한 유연한 스키마 변경 요구는 단일 장비의 수직 확장에 의존하는 전통적 RDBMS의 한계를 명확히 보여주었습니다.

---

## 2000년대 후반-2010년대: NoSQL 운동과 분산 시스템의 각성

이러한 도전에 대한 응답으로 **NoSQL** 운동이 태동했습니다. "Not Only SQL"이라는 이름이 의미하듯, 관계형 모델 이외의 다양한 데이터 모델을 적극적으로 수용하자는 움직임이었습니다. 그 배경에는 네트워크 분할 상황에서 일관성(C)과 가용성(A) 사이의 절충을 설명하는 **CAP 정리**, 그리고 최종적 일관성을 받아들이는 **BASE** 접근법에 대한 이해가 자리 잡고 있었습니다.

NoSQL은 주요 유형에 따라 특화된 장점을 제공했습니다:
*   **문서형(MongoDB)**: JSON 형태의 유연한 스키마로 빠른 개발 주기 지원.
*   **키-값형(Redis)**: 초고속 캐시, 세션 저장소로 사용.
*   **컬럼형(Cassandra, HBase)**: 대규모 쓰기와 수평 확장에 최적화된 와이드 컬럼 저장.
*   **그래프형(Neo4j)**: 관계 자체를 일급 시민으로 모델링해 복잡한 관계 질의에 강력.

이 시기는 하나의 '만능 해법'보다는 **작업에 맞는 도구**를 선택하는 '폴리글랏 퍼시스턴스' 사고가 정착한 시대였습니다.

---

## 2010년대 중반-현재: 재수렴의 시대: NewSQL, 분산 트랜잭션, 클라우드 DBaaS

NoSQL의 확장성과 유연성을 누리면서도, 관계형 모델의 강력한 일관성, 선언적 질의 언어(SQL), 그리고 복잡한 트랜잭션의 편리함을 포기하고 싶지 않은 필요성이 대두되었습니다. 이로 인해 **NewSQL**이라 불리는 새로운 범주의 시스템이 등장했습니다. Google Spanner, CockroachDB 등은 분산 합의 알고리즘(Paxos, Raft)과 글로벌 타임스탬프를 이용해 수평적 확장성과 강한 일관성 및 분산 트랜잭션을 동시에 제공하는 것을 목표로 했습니다.

또 한 가지 지배적인 흐름은 **클라우드 DBaaS**(Database as a Service)의 완전한 정착입니다. Amazon RDS/Aurora, Google Cloud SQL, Azure Database 같은 서비스는 인프라 프로비저닝, 패치 적용, 백업, 복제, 장애 복구 같은 복잡한 운영 부담을 클라우드 제공자에게 넘기고, 개발팀은 스키마 설계, 쿼리 최적화, 보안 정책 정의 등 비즈니스 가치에 더 집중할 수 있게 해주었습니다. 서버리스 데이터베이스는 이 흐름의 연장선상에서 사용량에 따른 정밀한 비용 최적화를 가능하게 합니다.

---

## 핵심 개념의 지속적 진화

이 모든 역사적 변화 속에서도 데이터베이스 설계의 몇 가지 근본 개념은 지속적으로 진화하며 그 중요성을 잃지 않았습니다.

*   **정규화 vs 반정규화**: 이상 현상을 제거하고 중복을 최소화하는 정규화는 데이터 무결성의 초석입니다. 그러나 대규모 분석이나 특정 읽기 패턴에서는 의도적인 반정규화(중복 허용, 물질화 뷰 생성)를 통해 성능을 획기적으로 높일 수 있습니다. 선택은 항상 트레이드오프에 대한 이해에서 출발합니다.
*   **인덱스 전략**: B-Tree와 그 변종들은 범위 질의와 정렬에 여전히 가장 효율적인 구조입니다. 반면, 쓰기 집중 환경을 위해 설계된 LSM-Tree 계열은 현대 SSD와 클라우드 스토리지 환경에서도 그 유용성을 입증하며 다양한 스토리지 엔진에 채택되고 있습니다.
*   **트랜잭션과 격리 수준**: MVCC(Multi-Version Concurrency Control)는 현대 RDBMS의 표준 동시성 제어 메커니즘이 되었으며, 읽기-쓰기 충돌을 효율적으로 관리합니다. 그러나 분산 데이터베이스 환경에서는 '격리 수준'의 보장이 더 복잡한 문제가 되며, 신중한 선택이 필요합니다.

---

## 결론: 역사에서 배우는 설계의 지혜

데이터베이스의 역사는 혼란(파일 시스템)에서 구조화(계층/네트워크)를 거쳐, 추상화와 선언성(관계형)의 정점에 도달한 후, 새로운 규모와 복잡성의 도전(웹, 빅데이터)에 직면하여 다양화(NoSQL)의 길로 나아갔습니다. 그리고 오늘날 우리는 그 모든 장점을 통합하고 운영의 복잡성을 추상화하려는 재수렴(NewSQL, DBaaS)의 시기를 살고 있습니다.

이 흐름을 이해하는 것은 단순한 지식 축적이 아닙니다. 그것은 특정 기술이 **왜**, **어떤 문제를 해결하기 위해** 탄생했는지를 이해하게 함으로써, 오늘날 우리가 맞닥뜨린 구체적인 문제(데이터 모델, 일관성 요구사항, 확장성, 운영 복잡도)에 대해 **더욱 정보에 기반한 선택**을 할 수 있게 해줍니다. 역사는 우리에게 '최선의' 도구는 없으며, 상황에 맞는 '적절한' 도구와 절충안이 존재함을 일깨워줍니다. 데이터베이스 설계의 여정은 끝나지 않았으며, 이 역사적 렌즈를 통해 우리는 미래의 변화를 더욱 현명하게 맞이할 준비를 할 수 있습니다.