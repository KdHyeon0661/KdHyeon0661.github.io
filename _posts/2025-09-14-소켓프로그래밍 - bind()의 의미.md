---
layout: post
title: 소켓프로그래밍 - bind()의 의미
date: 2025-09-14 17:25:23 +0900
category: 소켓프로그래밍
---
## 3.x `bind()`의 의미: 로컬 주소/포트 **소유권**을 선언한다

> 한 줄 핵심: **`bind()` = “이 소켓은 (로컬 IP, 로컬 포트, 프로토콜) 조합을 **내가** 쓰겠다”**라는 **커널에 대한 소유권(ownership) 선언**이다. 성공하면 커널의 포트 테이블에 **독점 등록**되고, **수신 경로**(패킷 디멀티플렉스) 및 **송신 경로**(소스 IP/포트 선택)에 영향을 준다.

---

### `bind()`가 정확히 하는 일

- **서버(TCP/UDP)**
  - **수신 측 엔드포인트**를 커널에 **등록**한다.
  - 예: `bind(0.0.0.0:9000)` / `bind(::,9000)` → 해당 포트로 들어오는 패킷이 **이 소켓**으로 배달될 수 있게 **라우팅 테이블 + 포트 테이블**에 연결된다.
  - TCP의 경우 `bind` 다음 **`listen()`** 으로 **대기열**(SYN/accept 큐)을 만든다.
- **클라이언트(TCP/UDP)**
  - 보통 `connect()`가 **자동으로** **로컬 IP**(라우팅으로 선택)와 **에페메랄 포트**를 배정하지만,
  - **원하는 소스 IP/포트 강제**가 필요하면 **직접 `bind()`** 한다. (예: 멀티홈 호스트에서 특정 NIC를 통해 나가고 싶을 때)

> 용어: “소유권”이라고 표현했지만, **실제 구현은 테이블에 엔트리 추가/참조 카운트**에 가깝다. 다만 흔히 “그 포트를 잡았다(held)”라고 말한다.

---

### 무엇을 “소유”하나 — 식별자와 스코프

- **UDP**: (로컬 IP, 로컬 포트, 프로토콜=UDP)
- **TCP (리스너)**: (로컬 IP, 로컬 포트, 프로토콜=TCP)
- **TCP (수립된 연결 소켓)**: (로컬 IP, 로컬 포트, **원격 IP, 원격 포트**, TCP) = **5-튜플**
  - 리스닝 소켓은 **와일드카드 엔드포인트**를 소유, `accept()`가 반환하는 연결 소켓이 **5-튜플 완성**.

---

### 바인딩 대상 주소의 종류

- **와일드카드(any) 바인드**
  - IPv4: `0.0.0.0`, IPv6: `::`
  - 의미: “이 머신이 가진 **모든 로컬 IP**로 들어오는 해당 포트를 모두 받겠다”.
  - 주로 서버 초심자 기본값.
- **특정 로컬 IP**
  - 예: `10.0.0.5:9000` 또는 `fe80::1%eth0`
  - 의미: **그 IP로 들어오는 것만** 받겠다. 보안/정책/다중 NIC에서 유용.
- **포트 0**
  - 의미: “**커널이 사용 가능한 포트를 자동 배정**해줘(에페메랄)”.
  - UDP 테스트/클라이언트 소스 포트 부여 시 자주 사용.
  - `getsockname()` 으로 배정된 포트를 확인할 수 있다.

---

### 실패와 에러 코드(왜 실패하는가)

- `EADDRINUSE` — **이미 점유**된 주소/포트
  - 동일 호스트 내 **다른 프로세스**가 그 (IP, PORT, PROTO)를 선점.
  - TCP의 경우 **`TIME_WAIT`** 상태도 관여. 재기동 시 쓰던 포트를 바로 쓰고 싶다면 **`SO_REUSEADDR`** (리눅스에서 TIME_WAIT 완화), **`SO_REUSEPORT`**(다중 리스너) 등을 검토.
- `EACCES` — **권한 부족**
  - 리눅스에서 1024 미만 **Well-known ports**(예: 80, 443)는 **CAP_NET_BIND_SERVICE** 또는 root 권한 필요.
- `EADDRNOTAVAIL` — **그런 로컬 IP 없음**
  - 인터페이스에 존재하지 않는 주소로 바인드 시도. (예: NIC 다운/주소 미설정)
- `EINVAL` — 옵션/상태가 맞지 않음
  - 예: IPv6 소켓인데 IPv4 주소 구조체를 건넸다든지, 길이 오류.
- `ENODEV` — 해당 인터페이스/스코프 없음
  - IPv6 링크-로컬에서 `sin6_scope_id`가 틀리면.

---

### `SO_REUSEADDR` / `SO_REUSEPORT` / `IPV6_V6ONLY` 의 의미(요약)

- **`SO_REUSEADDR`**
  - 리눅스: **TIME_WAIT/바인딩 재시작** 시 유용. 이미 TIME_WAIT로 남은 (IP,PORT)를 **재바인드 허용**.
  - BSD계: “동일 (IP,PORT) 중복 바인드 허용” 성격이 강하므로 **주의**.
  - **서버 재기동 시는 거의 필수**.
- **`SO_REUSEPORT`**
  - **동일 (IP,PORT)로 여러 소켓을 동시에 리슨** 가능. 커널이 연결을 **로드밸런싱**하여 분배.
  - 멀티코어 스케일아웃/Parallel accept 패턴에 사용.
- **`IPV6_V6ONLY`**
  - IPv6 소켓이 **IPv4-mapped** 연결을 받을지 정책을 명시. OS별 기본이 다르므로 **설정으로 고정**하자.

---

### 클라이언트에서의 `bind()` — 소스 선택/정책 제어

- 기본은 `connect()` 가 **라우팅**을 보고 소스 IP와 포트를 고른다.
- 하지만 **멀티홈 환경**(예: 내부망 `10.0.0.0/8` 과 외부망 `1.2.3.4/24`)에서, **특정 NIC로만** 나가고 싶다면:
  1) 소켓 생성
  2) **원하는 로컬 IP/포트로 `bind()`**
  3) `connect()` 수행
- UDP 클라이언트도 동일: 원천 포트/주소를 **고정**하고 싶으면 `bind()`로 먼저 소유권을 잡는다.

---

### 보안·운영적 함의

- **바인딩 주소 제한 = 노출 면적 제한**
  - 서비스가 내부 NIC에만 바인드(`127.0.0.1` 또는 사설 IP)되면 **외부에서 접근 불가**.
  - 리버스 프록시/로드밸런서를 앞에 두는 구조에서 **백엔드**는 내부망 바인드가 일반적.
- **링크-로컬 IPv6 바인드**는 반드시 **스코프 ID**(인터페이스)를 설정.
- **권한 관리**: 1024 미만 포트를 써야 한다면 **권한 분리**(바인드 후 권한 드롭) 전략을 갖춘다.

---

## 실습: **다중 주소 후보 중 성공하는 것만 선택**하는 안전한 루프

> 목표: `getaddrinfo()`가 반환한 **IPv6/IPv4 후보 리스트**를 **순회**하여, **성공하는 주소에만 `bind()`/`listen()`** 하도록 만든다. 실패는 **전부 로깅**하고, **첫 성공**을 반환한다. **C++23** 문법과 **RAII**를 사용.

---

### 준비: 공통 유틸(RAII fd, 로깅, 주소 문자열화)

```cpp
// util_fd.hpp
#pragma once
#include <unistd.h>
#include <fcntl.h>
#include <utility>

struct unique_fd {
    int fd{-1};
    unique_fd() = default;
    explicit unique_fd(int f) : fd(f) {}
    unique_fd(const unique_fd&) = delete;
    unique_fd& operator=(const unique_fd&) = delete;
    unique_fd(unique_fd&& o) noexcept : fd(std::exchange(o.fd,-1)) {}
    unique_fd& operator=(unique_fd&& o) noexcept {
        if (this!=&o) { if (fd!=-1) ::close(fd); fd = std::exchange(o.fd,-1); }
        return *this;
    }
    ~unique_fd(){ if (fd!=-1) ::close(fd); }
    void reset(int f=-1) noexcept { if (fd!=-1) ::close(fd); fd=f; }
    int get() const noexcept { return fd; }
    explicit operator bool() const noexcept { return fd!=-1; }
};

inline int set_cloexec(int fd) {
    int fl = ::fcntl(fd, F_GETFD, 0);
    if (fl==-1) return -1;
    return ::fcntl(fd, F_SETFD, fl | FD_CLOEXEC);
}
```

```cpp
// util_addr.hpp
#pragma once
#include <netdb.h>
#include <string>
#include <print>

struct addr_list {
    addrinfo* head{};
    addr_list() = default;
    addr_list(const addr_list&) = delete;
    addr_list& operator=(const addr_list&) = delete;
    ~addr_list(){ if (head) ::freeaddrinfo(head); }
};

inline addr_list resolve_strict(const char* host, const char* service,
                                int family, int socktype, int flags) {
    addrinfo hints{};
    hints.ai_family   = family;
    hints.ai_socktype = socktype;
    hints.ai_protocol = 0;
    hints.ai_flags    = flags;
    addrinfo* res=nullptr;
    int rc = ::getaddrinfo(host, service, &hints, &res);
    if (rc!=0) throw std::runtime_error(std::string("getaddrinfo: ") + gai_strerror(rc));
    addr_list L; L.head=res; return L;
}

inline std::string to_string_sa(const sockaddr* sa, socklen_t salen) {
    char host[NI_MAXHOST]{}, serv[NI_MAXSERV]{};
    if (::getnameinfo(sa, salen, host, sizeof(host), serv, sizeof(serv),
                      NI_NUMERICHOST|NI_NUMERICSERV)==0)
        return std::string(host)+":"+serv;
    return "(unknown)";
}
```

---

### 서버: **안전 루프**로 `bind()`/`listen()` (IPv4/IPv6 겸용)

```cpp
// server_bind_loop.cpp
#include "util_fd.hpp"
#include "util_addr.hpp"
#include <sys/socket.h>
#include <netinet/in.h>
#include <cstring>
#include <print>

unique_fd listen_first_success(const char* bind_host, const char* port, int backlog=256) {
    // 1) 후보 생성: host가 nullptr이면 any 바인드 후보(0.0.0.0, ::)
    int flags = AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV;
    auto L = resolve_strict(bind_host, port, AF_UNSPEC, SOCK_STREAM, flags);

    // 2) 후보를 순회하며 첫 성공을 반환
    for (addrinfo* ai = L.head; ai; ai = ai->ai_next) {
        unique_fd s{ ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol) };
        if (!s) { std::print(stderr, "[socket-fail] {}\n", std::strerror(errno)); continue; }

        set_cloexec(s.get());

        // 재기동 편의를 위해 REUSEADDR
        int yes = 1;
        ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

        // IPv6 리스너 정책(여기서는 v4-mapped 허용: 0)
        if (ai->ai_family == AF_INET6) {
            int v6only = 0; // 정책적으로 1로 강제해도 됨
            ::setsockopt(s.get(), IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
        }

        if (::bind(s.get(), ai->ai_addr, ai->ai_addrlen) != 0) {
            std::print(stderr, "[bind-fail] {} -> {}\n",
                       std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
            continue;
        }
        if (::listen(s.get(), backlog) != 0) {
            std::print(stderr, "[listen-fail] {} -> {}\n",
                       std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
            continue;
        }

        std::print("[listen-ok] {}\n", to_string_sa(ai->ai_addr, ai->ai_addrlen));
        return s; // move 반환, 여기서 루프 종료
    }
    throw std::runtime_error("listen_first_success: no address worked");
}

int main(int argc, char** argv) {
    const char* host = (argc>1 ? argv[1] : nullptr); // nullptr → any 바인드
    const char* port = (argc>2 ? argv[2] : "9000");

    try {
        auto ls = listen_first_success(host, port, 256);
        // 데모: 얕은 accept 1회
        sockaddr_storage cli{}; socklen_t clen=sizeof(cli);
        int cfd = ::accept(ls.get(), (sockaddr*)&cli, &clen);
        if (cfd >= 0) {
            std::print("[accept] peer={}\n", to_string_sa((sockaddr*)&cli, clen));
            ::close(cfd);
        }
    } catch (const std::exception& e) {
        std::print(stderr, "fatal: {}\n", e.what());
        return 1;
    }
    return 0;
}
```

#### 실행 예

```bash
# any 바인드 (0.0.0.0 또는 ::)

g++ -std=c++23 server_bind_loop.cpp -o server
./server           # port=9000
# [listen-ok] 0.0.0.0:9000   또는  [listen-ok] [::]:9000 (플랫폼/정책에 따라)

# 특정 IP로 바인드

./server 127.0.0.1 9000
# [listen-ok] 127.0.0.1:9000

```

- 실패 케이스들은 **모두 에러 로그**로 남고, **첫 성공**만 반환한다.
- 이 패턴은 **운영 환경 차이**(IPv6 여부, V4-mapped 정책, 서비스명 DB 유무)에서도 안정적으로 동작한다.

---

### UDP 서버: `bind()`만으로 수신 시작 (루프 동일)

```cpp
// udp_bind_loop.cpp
#include "util_fd.hpp"
#include "util_addr.hpp"
#include <sys/socket.h>
#include <netinet/in.h>
#include <print>
#include <array>

unique_fd udp_bind_first_success(const char* host, const char* port) {
    int flags = AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV;
    auto L = resolve_strict(host, port, AF_UNSPEC, SOCK_DGRAM, flags);

    for (addrinfo* ai=L.head; ai; ai=ai->ai_next) {
        unique_fd s{ ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol) };
        if (!s) { std::print(stderr, "[socket-fail] {}\n", std::strerror(errno)); continue; }

        set_cloexec(s.get());
        int yes=1; ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

        if (::bind(s.get(), ai->ai_addr, ai->ai_addrlen) != 0) {
            std::print(stderr, "[bind-fail] {} -> {}\n",
                       std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
            continue;
        }
        std::print("[bind-ok] {}\n", to_string_sa(ai->ai_addr, ai->ai_addrlen));
        return s;
    }
    throw std::runtime_error("udp_bind_first_success: no address worked");
}

int main(int argc, char** argv) {
    const char* host = (argc>1 ? argv[1] : nullptr);
    const char* port = (argc>2 ? argv[2] : "9999");

    try {
        auto s = udp_bind_first_success(host, port);
        std::array<char, 1500> buf{};
        sockaddr_storage peer{}; socklen_t plen=sizeof(peer);
        ssize_t n = ::recvfrom(s.get(), buf.data(), buf.size(), 0, (sockaddr*)&peer, &plen);
        if (n > 0) {
            std::print("[udp] {} bytes from {}\n", (int)n, to_string_sa((sockaddr*)&peer, plen));
            ::sendto(s.get(), buf.data(), (size_t)n, 0, (sockaddr*)&peer, plen); // 에코
        }
    } catch (const std::exception& e) {
        std::print(stderr, "fatal: {}\n", e.what());
        return 1;
    }
    return 0;
}
```

---

### 클라이언트에서 **소스 바인드**: 멀티홈 제어

```cpp
// client_bind_source.cpp
#include "util_fd.hpp"
#include "util_addr.hpp"
#include <sys/socket.h>
#include <netinet/in.h>
#include <print>

unique_fd connect_with_source(const char* dst_host, const char* dst_port,
                              const char* src_host /*nullable*/, const char* src_port /*nullable, "0" ok*/) {
    // 1) 목적지 후보
    auto D = resolve_strict(dst_host, dst_port, AF_UNSPEC, SOCK_STREAM, AI_ADDRCONFIG|AI_NUMERICSERV);

    for (addrinfo* ai=D.head; ai; ai=ai->ai_next) {
        unique_fd s{ ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol) };
        if (!s) continue;
        set_cloexec(s.get());

        // 2) 소스가 지정되면 바인드
        if (src_host || src_port) {
            auto S = resolve_strict(src_host, src_port?src_port:"0", ai->ai_family, ai->ai_socktype,
                                    AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV);
            bool bound=false;
            for (addrinfo* sj=S.head; sj; sj=sj->ai_next) {
                if (::bind(s.get(), sj->ai_addr, sj->ai_addrlen)==0) { bound=true; break; }
                std::print(stderr, "[src-bind-fail] {} -> {}\n",
                           std::strerror(errno), to_string_sa(sj->ai_addr, sj->ai_addrlen));
            }
            if (!bound) { std::print(stderr, "[skip] cannot bind source\n"); continue; }
        }

        // 3) connect 시도
        if (::connect(s.get(), ai->ai_addr, ai->ai_addrlen)==0) {
            std::print("[connected] dst={} src-set={}\n",
                       to_string_sa(ai->ai_addr, ai->ai_addrlen), src_host? "yes":"no");
            return s;
        }
        std::print(stderr, "[connect-fail] {} to {}\n",
                   std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
    }
    throw std::runtime_error("connect_with_source: no route worked");
}
```

**요점**
- **목적지 후보의 패밀리**(v4/v6)에 **맞는 소스 주소**로 바인드해야 한다.
- `src_port="0"`를 주면 커널이 **에페메랄 포트 자동 부여**.
- 이 패턴으로 **특정 NIC**를 통한 출력(정책 라우팅과 함께) 등을 단단히 제어 가능.

---

### 다중 리스너(IPv4/IPv6 분리) + `SO_REUSEPORT`로 분산

> 운영에서 자주 쓰는 패턴: **v6 리스너 1개 + v4 리스너 1개**, 또는 **코어 수만큼 동일 (IP,PORT)로 여러 리스너**.

```cpp
// multi_listen.cpp (요지)
unique_fd listen_v6(const char* port) {
    auto L = resolve_strict(nullptr, port, AF_INET6, SOCK_STREAM, AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV);
    for (auto* ai=L.head; ai; ai=ai->ai_next) {
        unique_fd s{ ::socket(AF_INET6, SOCK_STREAM, 0) };
        if (!s) continue;
        set_cloexec(s.get());
        int yes=1; ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        int v6only=1; ::setsockopt(s.get(), IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
        // (옵션) ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes));
        if (::bind(s.get(), ai->ai_addr, ai->ai_addrlen)==0 && ::listen(s.get(), 512)==0)
            return s;
    }
    throw std::runtime_error("v6 listen fail");
}

unique_fd listen_v4(const char* port) {
    auto L = resolve_strict(nullptr, port, AF_INET, SOCK_STREAM, AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV);
    for (auto* ai=L.head; ai; ai=ai->ai_next) {
        unique_fd s{ ::socket(AF_INET, SOCK_STREAM, 0) };
        if (!s) continue;
        set_cloexec(s.get());
        int yes=1; ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        // (옵션) ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes));
        if (::bind(s.get(), ai->ai_addr, ai->ai_addrlen)==0 && ::listen(s.get(), 512)==0)
            return s;
    }
    throw std::runtime_error("v4 listen fail");
}
```

- 이처럼 **분리 리스너**를 두면, OS 기본 정책과 상관없이 **각 스택을 명확히 관리**할 수 있다.
- `SO_REUSEPORT`로 **여러 프로세스/스레드**가 같은 (IP,PORT)을 공유해 **동시 accept**할 수 있다(커널이 **해시 기반**으로 분배).

---

### `bind()` 이후 관측: 제대로 잡혔는지 확인하는 법

- **`ss`**
  ```bash
  ss -tanlp '( sport = :9000 )'
  # LISTEN 상태의 소켓, 로컬 IP, 포트, 프로세스 PID/이름 확인
  ```
- **`lsof`**
  ```bash
  sudo lsof -iTCP:9000 -sTCP:LISTEN -n -P
  ```
- **`tcpdump`**
  ```bash
  sudo tcpdump -i any 'tcp port 9000' -n -vv
  # SYN이 들어오고 내 리스너가 SYN/ACK로 응답하는지 추적
  ```

---

### 흔한 함정과 대처

- **`htons` 깜박**: `sin_port`/`sin6_port`는 **네트워크 바이트 오더**. `htons` 빠뜨리면 **엉뚱한 포트**로 바인드.
- **IPv6 링크-로컬**: `sin6_scope_id` 미설정 → `EADDRNOTAVAIL`/`ENODEV`.
- **TIME_WAIT 오해**: 재기동 즉시 같은 포트 바인드 실패 시 `SO_REUSEADDR` 설정을 확인.
- **서비스명 의존**: `"myservice"` 가 시스템에 등록되어 있지 않으면 `getaddrinfo` 실패 → **숫자 포트** 사용 또는 `AI_NUMERICSERV`.
- **v4/v6 혼선**: 하나의 IPv6 리스너로 v4-mapped까지 받으려는 가정은 **플랫폼별 차이** 있음 → `IPV6_V6ONLY` 명시 또는 **분리 리스너**.

---

### 체크리스트(요약)

- [ ] **루프 패턴**: 후보 전부에 대해 `socket`→옵션→`bind`→`listen` 시도, **성공 시 즉시 반환**.
- [ ] **에러 로깅**: 실패할 때마다 **주소 문자열**과 **에러**를 남겨 디버깅 단축.
- [ ] **REUSEADDR/REUSEPORT** 정책 명시.
- [ ] IPv6 리스너의 **V6ONLY** 정책 고정.
- [ ] 클라이언트에서 **소스 바인드**가 필요한지 판단(멀티홈/정책 라우팅).
- [ ] 1024 미만 포트는 **권한** 필요.
- [ ] 링크-로컬 IPv6는 **scope_id** 필수.
- [ ] 포트 0(에페메랄) 사용 시 **`getsockname()`로 확인**.

---

### 마무리 — `bind()`는 계약이다

- `bind()`는 **로컬 엔드포인트 계약**이며, **수신/송신 경로**, **보안 경계**, **운영 재기동 행태**를 좌우한다.
- “**모든 후보를 시도** → **첫 성공만 사용**” 루프는, 이질적인 운영 환경(IPv4/IPv6, 정책 차이, DNS/서비스 DB 차이)에서도 **안정적**인 서버/클라이언트를 만드는 **근본 템플릿**이다.
