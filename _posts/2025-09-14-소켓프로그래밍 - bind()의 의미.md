---
layout: post
title: 소켓프로그래밍 - bind()의 의미
date: 2025-09-14 17:25:23 +0900
category: 소켓프로그래밍
---
# bind()의 의미 — 로컬 주소/포트 소유권, 포트 재사용, 멀티홈, 운영 패턴

## 1. 큰 그림: 소켓 엔드포인트와 커널 포트 테이블

### 1.1 TCP/UDP 엔드포인트 식별자

IP 네트워킹에서 **한 연결 또는 한 UDP 엔드포인트**는 튜플로 식별된다.

- **UDP 소켓**
  - 수신 기준:  
    \((\text{로컬 IP}, \text{로컬 포트}, \text{프로토콜=UDP})\)
- **TCP 리스너**
  - 대기 기준:  
    \((\text{로컬 IP}, \text{로컬 포트}, \text{프로토콜=TCP})\)
- **TCP 성립된 연결**
  - 전형적인 4/5-튜플:
  - \((\text{로컬 IP}, \text{로컬 포트}, \text{원격 IP}, \text{원격 포트}, \text{프로토콜=TCP})\)

리눅스 같은 커널은 내부에 **포트 테이블**(다수의 해시 테이블)을 두고, 여기에서 위 튜플을 키로 **수신 패킷을 어느 소켓에 넘길지** 결정한다.

- `bind()` 호출은 이 테이블에  
  **“이 (로컬 IP, 로컬 포트, 프로토콜) 엔트리는 지금부터 이 소켓 것이야”**  
  라는 엔트리를 추가하는 행위라고 보면 된다.

### 1.2 수신 디멀티플렉스 흐름

TCP 패킷이 NIC에 도착하면 대략 이런 순서로 흘러간다.

1. NIC → 커널 네트워크 스택으로 패킷 전달
2. IP 계층에서 라우팅/필터링
3. TCP 계층에서 연결 테이블(5-튜플) 검색
   - 성립된 연결이면 **연결 소켓으로 직접 배달**
   - 그렇지 않으면 “이건 SYN인가? 리스너가 있나?” 확인
4. 리스너 테이블에서 `(local IP, local port, TCP)` 엔트리를 찾고, 해당 리스너의 **accept 큐**에 넣는다.
5. 사용자 공간의 `accept()` 가 큐에서 꺼냄

UDP도 비슷하지만, **연결 상태(5-튜플)** 는 없고 `bind()` 되어 있는 (IP, 포트, UDP) 엔트리를 기반으로 **소켓 하나에 바로** 배달된다. (멀티캐스트, `SO_REUSEPORT` 등은 별도 규칙 추가)

---

## 2. bind()가 정확히 하는 일

### 2.1 서버 소켓(TCP/UDP)에서의 bind()

서버 입장에서 `bind()`는 **“수신 엔드포인트 등록”** 이다.

- 예: TCP 에코 서버

```cpp
int fd = ::socket(AF_INET, SOCK_STREAM, 0);

sockaddr_in sa{};
sa.sin_family = AF_INET;
sa.sin_port   = htons(9000);          // 네트워크 바이트 오더!
inet_pton(AF_INET, "0.0.0.0", &sa.sin_addr);

if (::bind(fd, (sockaddr*)&sa, sizeof(sa)) != 0) {
    perror("bind");
    std::exit(1);
}
if (::listen(fd, 128) != 0) {
    perror("listen");
    std::exit(1);
}
```

- 위 `bind(0.0.0.0:9000)` 호출이 성공하면:
  - 커널의 TCP 리스너 테이블에 `(0.0.0.0, 9000, TCP)` 엔트리가 생긴다.
  - 이 머신의 **어느 NIC로 들어오건** 목적지가 `*:9000` 인 SYN 패킷은 이 리스너로 도착한다.
- 곧이어 `listen()` 을 호출하면, 해당 소켓에 대해 **SYN 큐, accept 큐**가 준비되고, `accept()` 가 대기할 수 있게 된다.

UDP 서버도 마찬가지다.

```cpp
int fd = ::socket(AF_INET, SOCK_DGRAM, 0);
sockaddr_in sa{};
sa.sin_family = AF_INET;
sa.sin_port   = htons(9999);
sa.sin_addr.s_addr = htonl(INADDR_ANY);   // 0.0.0.0

if (::bind(fd, (sockaddr*)&sa, sizeof(sa)) != 0) {
    perror("bind");
    std::exit(1);
}
```

- 이제 `recvfrom()` 을 호출하면, 목적지 포트가 9999인 UDP 데이터그램이 **이 소켓**으로 들어온다.

### 2.2 클라이언트에서의 bind()

대부분의 TCP/UDP 클라이언트는 **명시적인 `bind()` 없이** 곧장 `connect()` 를 호출한다.

- `connect()` 도중 커널이:
  - 라우팅 테이블을 보고 **적절한 로컬 IP** 를 선택하고,
  - **에페메랄 포트(ephemeral port)** 중 하나를 골라 `(로컬 IP, 로컬 포트)` 를 자동 부여한다.

하지만, 다음과 같은 경우에는 **직접 `bind()`** 해야 한다.

- **멀티홈 호스트**에서 “이 NIC로만 나가고 싶다”
  - 예: 내부망 `10.0.0.0/8`, 외부망 `203.0.113.10/24` 를 동시에 가진 서버
- **소스 포트를 고정**하고 싶다
  - 예: 특정 방화벽 규칙에 의해 “항상 50000번 포트에서 나가는 트래픽만 허용”
- **UDP 프로토콜 설계 상** 소스 포트가 ID/세션의 일부인 경우

패턴은 간단하다.

```cpp
int fd = ::socket(AF_INET, SOCK_STREAM, 0);

// 1) 먼저 원하는 로컬 IP/포트로 bind()
sockaddr_in src{};
src.sin_family = AF_INET;
src.sin_port   = htons(50000);          // 또는 0 = 커널이 자동 에페메랄 선택
inet_pton(AF_INET, "10.0.0.5", &src.sin_addr);

if (::bind(fd, (sockaddr*)&src, sizeof(src)) != 0) {
    perror("bind");
    // 실패 시 다른 포트/주소로 재시도
}

// 2) 그 다음 connect()
sockaddr_in dst{};
dst.sin_family = AF_INET;
dst.sin_port   = htons(443);
inet_pton(AF_INET, "198.51.100.42", &dst.sin_addr);

if (::connect(fd, (sockaddr*)&dst, sizeof(dst)) != 0) {
    perror("connect");
    // ...
}
```

---

## 3. 무엇을 “소유”하나 — UDP, TCP 리스너, TCP 연결

### 3.1 UDP: (로컬 IP, 로컬 포트, UDP)

UDP 소켓이 `bind()` 를 호출하면, 그 소켓은:

- `(로컬 IP, 로컬 포트, 프로토콜=UDP)` 조합을 커널에 등록한다.
- 이후 **해당 조합을 목적지로 하는 데이터그램**은 이 소켓에 배달된다.

같은 (IP, 포트, UDP)에 대해 여러 소켓을 열 수 있을까?

- 기본적으로 **불가능**하다.
- 다만:
  - **`SO_REUSEADDR`**, **`SO_REUSEPORT`** 를 통해 일부 OS에서 **특정 조건 하에 공유** 가능 (뒤에서 자세히 다룸)

### 3.2 TCP 리스너: (로컬 IP, 로컬 포트, TCP)

TCP 리스너 소켓은 **와일드카드 엔드포인트**를 소유한다.

- `bind(0.0.0.0:9000)` 이후:
  - `(0.0.0.0, 9000, TCP)` 가 리스너 테이블에 올라간다.
- 들어오는 SYN 패킷은:
  - **5-튜플** 중 **로컬 IP/포트**가 위 리스너와 일치하면 이 리스너에게 도착한다.
- `accept()` 가 반환하는 소켓(연결 소켓)은:
  - \((\text{로컬 IP}, \text{로컬 포트}, \text{원격 IP}, \text{원격 포트}, \text{프로토콜})\) 를 키로 가지는 **별도 구조체**다.

### 3.3 TCP 연결 소켓: 5-튜플

연결 소켓은 보통 `bind()` 를 직접 호출하지 않는다.

- 대신,  
  - 리스너가 `bind()` + `listen()` 으로 **와일드카드 (로컬 IP, 로컬 포트)** 를 갖고 있다가,
  - 커널이 SYN 수신 시 `accept()` 의 결과로 **5-튜플** 을 채워 새로운 소켓을 만든다.

클라이언트 연결 소켓도 마찬가지다.

- 클라이언트는 `connect()` 호출만 해도,
  - 내부적으로 `(로컬 IP, 에페메랄 포트)` 를 골라 **로컬 부분을 바인드**하는 과정을 거친다.
  - 그 뒤 원격 튜플이 확정되면 연결 소켓이 5-튜플을 갖게 된다.

---

## 4. 바인딩 대상 주소의 종류와 의미

### 4.1 와일드카드(any) 바인드

- IPv4: `0.0.0.0`
- IPv6: `::`

**의미**: “이 머신이 가진 **모든 로컬 IP** 에 대해 이 포트를 다 받겠다.”

예:

```cpp
// ANY 바인드 TCP 서버
sockaddr_in sa{};
sa.sin_family      = AF_INET;
sa.sin_port        = htons(9000);
sa.sin_addr.s_addr = htonl(INADDR_ANY);  // 0.0.0.0
```

장점:

- 단일 리스너로, NIC가 여러 개든 IP가 여러 개든 **간단하게 커버** 가능.
- 개발/테스트 시 가장 많이 쓰는 패턴.

단점:

- **보안 측면**에서 “의도치 않게 외부에 열려버리는” 상황이 생기기 쉽다.
  - 사실은 내부에서만 쓰고 싶은 서비스인데, 외부 NIC까지 바인드.
- 운영 환경에서는 흔히:
  - 외부 접근이 필요 없는 프로세스는 `127.0.0.1` 또는 사설망 IP 에만 바인드하는 편이 낫다.

### 4.2 특정 로컬 IP 바인드

예:

```cpp
// 10.0.0.5 에만 바인드
sockaddr_in sa{};
sa.sin_family = AF_INET;
sa.sin_port   = htons(9000);
inet_pton(AF_INET, "10.0.0.5", &sa.sin_addr);
```

**의미**: “10.0.0.5:9000 으로 들어오는 것만 받겠다.”

- NAT/로드밸런서를 둔 환경에서는:
  - 외부용 NIC (`203.0.113.x`)  
  - 내부 백엔드용 NIC (`10.0.0.x`) 를 분리해
  - 서비스에 따라 서로 다른 IP/포트 조합에 바인드하는 것이 일반적이다.

IPv6 링크-로컬의 경우:

```cpp
sockaddr_in6 sa{};
sa.sin6_family = AF_INET6;
sa.sin6_port   = htons(9000);
inet_pton(AF_INET6, "fe80::1", &sa.sin6_addr);
sa.sin6_scope_id = if_nametoindex("eth0");  // 반드시 scope 지정
```

- 링크-로컬 주소(`fe80::/10`)는 **반드시 인터페이스 스코프**가 필요하다.
- `sin6_scope_id` 를 잘못 지정하면 `EADDRNOTAVAIL` 또는 `ENODEV` 에러.

### 4.3 포트 0 — 커널이 자동으로 포트 선택

`sin_port` 를 0으로 주고 `bind()` 하면, **커널이 사용 가능한 포트**를 골라준다.

```cpp
sockaddr_in sa{};
sa.sin_family      = AF_INET;
sa.sin_port        = htons(0);           // 0 포트
sa.sin_addr.s_addr = htonl(INADDR_ANY);

if (::bind(fd, (sockaddr*)&sa, sizeof(sa)) != 0) {
    perror("bind");
}

// 실제로 할당된 포트 조회
sockaddr_in bound{};
socklen_t len = sizeof(bound);
if (::getsockname(fd, (sockaddr*)&bound, &len) == 0) {
    std::printf("bound to %s:%u\n",
        "0.0.0.0",
        ntohs(bound.sin_port));
}
```

- 주로:
  - UDP 임시 서버
  - 테스트용 소켓
  - 포트 충돌을 피하고 싶은 클라이언트 소스 포트 등에서 사용.

### 4.4 에페메랄 포트 범위와 IANA 권고

**에페메랄 포트(ephemeral port)** = 클라이언트 연결 시 **커널이 자동으로 선택**하는 포트.

- IANA는 일반적으로 **49152–65535** 범위를 **Dynamic/Private(에페메랄)** 로 정의한다.
- 전체 크기는:
  $$
  N_{\text{ephemeral}} = 65535 - 49152 + 1 = 16384
  $$

실제 OS는 **이 권고 범위 안팎**에서 자신의 정책을 쓴다.

- 일부 리눅스 배포판: `cat /proc/sys/net/ipv4/ip_local_port_range` 로 현재 범위 확인 가능.
- BSD, Windows도 기본 범위가 있고, 레지스트리/커널 파라미터로 조정 가능.

중요한 포인트는:

1. **Well-known 포트(0–1023)** 는 서버/시스템 서비스용.
2. **Registered 포트(1024–49151)** 는 특정 애플리케이션/프로토콜에 할당될 수 있다.
3. **에페메랄 포트(49152–65535)** 는 대개 **클라이언트 소켓**이 자동 선택하는 영역.

운영 설계 시:

- 여러 서버 애플리케이션 포트를 잡을 때 **에페메랄 영역과 충돌하지 않도록** 정책을 세워두면 좋다.
- 방화벽/ACL 설계 시에도 에페메랄 포트 대역을 고려해야 한다.

---

## 5. bind() 실패와 errno 상세

### 5.1 `EADDRINUSE` — 이미 사용 중인 주소/포트

의미:

- 같은 (로컬 IP, 로컬 포트, 프로토콜) 조합을 다른 소켓이 이미 사용 중이거나,
- TCP에서 **`TIME_WAIT` 상태의 잔재** 때문에 즉시 재바인드가 안되는 경우.

대표적인 상황:

1. 서버 재기동 직후:

   ```text
   bind: Address already in use
   ```

   - 이전 프로세스의 연결이 종료되면서 다수의 `TIME_WAIT` 연결이 남아 있다.
   - 리눅스에서는 `SO_REUSEADDR` 로 이를 완화할 수 있다.

2. 이미 동일 포트를 리슨 중인 다른 프로세스가 존재.

   - `ss -tanlp '( sport = :9000 )'`
   - `lsof -iTCP:9000 -sTCP:LISTEN -n -P`  
     같은 명령으로 누가 잡고 있는지 확인.

### 5.2 `EACCES` — 권한 부족

대표적인 예:

- 리눅스/유닉스에서 **1024 미만 포트**(Well-known ports)를 바인드하려면:
  - root 또는
  - `CAP_NET_BIND_SERVICE`(리눅스 capabilities) 같은 권한이 필요.

전형적인 대응 패턴:

- **바인드만 root/capable 프로세스가 수행**하고,
- 그 이후 **권한을 낮춘(user/group 변경, chroot 등)** 상태에서 실제 서버 로직을 실행.

### 5.3 `EADDRNOTAVAIL` — 존재하지 않는 로컬 IP

예:

- NIC가 10.0.0.5 주소를 갖고 있지 않은데 `bind(10.0.0.5:9000)` 시도.
- IPv6 링크-로컬에서 `sin6_scope_id` 를 제대로 지정하지 않은 경우.

이 에러가 나오면:

- `ip addr` / `ipconfig` 등으로 **현재 로컬 IP/인터페이스 상태**를 먼저 확인해야 한다.

### 5.4 `EINVAL` — 인자 오류 / 상태 부적합

- `sockaddr` 길이가 잘못되었거나
- IPv6 소켓에 IPv4 `sockaddr_in` 을 잘못 건네는 등, **구조체·길이 혼선**이 있을 때.

또는:

- 이미 바인드된 소켓에 다시 `bind()` 를 호출하는 경우 등.

### 5.5 `ENODEV` — 인터페이스/스코프 없음

특히 IPv6 링크-로컬에서:

- `fe80::1%eth0` 식의 주소를 사용할 때,
  - 지정한 `ifindex` 에 해당하는 인터페이스가 없으면 `ENODEV`.

---

## 6. 포트 재사용 옵션: SO_REUSEADDR / SO_REUSEPORT / IPV6_V6ONLY

### 6.1 SO_REUSEADDR

이 옵션은 **플랫폼마다 의미가 조금 달라**서 반드시 운영체제별 차이를 이해해야 한다.

- 리눅스:
  - 이미 **`TIME_WAIT`에 남아있는 연결들** 때문에 `EADDRINUSE` 가 발생했을 때,
  - 동일 (IP, PORT)에 대해 **바인드 재시도 허용**.
  - 일반적 서버 패턴:
    - `socket()` → `setsockopt(SO_REUSEADDR)` → `bind()` → `listen()`
- BSD 계열(FreeBSD, macOS 등):
  - `SO_REUSEADDR` 이 “동일 (IP,PORT)에 **여러 리스너를 동시에 허용**”에 더 가깝게 동작하는 경우가 있어 주의.
  - 예: 여러 프로세스가 같은 포트에 `bind()` 가능해지는 효과.

실무 팁:

- 리눅스 서버라면:
  - **서버 재기동 용이성**을 위해 거의 항상 `SO_REUSEADDR` 세팅.
- 이식성을 고려할 때:
  - 여러 프로세스가 같은 포트를 쓰는 패턴은 가급적 **`SO_REUSEPORT`** 기반으로 설계하고,
  - `SO_REUSEADDR`은 주로 **TIME_WAIT 재바인드 완화**로 이해하는 편이 좋다.

### 6.2 SO_REUSEPORT

`SO_REUSEPORT`는 **같은 (IP, PORT)** 에 대해 **여러 리스너를 동시에 유지**하면서, 커널이 **로드밸런싱** 해 주도록 하는 옵션이다.

사용 예:

- 멀티코어 서버에서 **코어 수만큼 프로세스/스레드**를 띄워 각각 `bind()` + `listen()` 을 하고,
- 커널이 들어오는 연결을 **해시 기반으로 분산**.

간단한 예시 (요지):

```cpp
int fd = ::socket(AF_INET6, SOCK_STREAM, 0);
int yes = 1;
::setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
::setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes));
```

이후 **여러 프로세스**에서 동일한 코드로 동일 (IP,PORT) 에 `bind()` 할 수 있고, 커널이 연결을 나눠준다.

주의점:

- `SO_REUSEPORT` 를 사용할 때는 각 리스너가 **동일한 바인드 파라미터**를 쓰는 것이 중요.
- 옵션을 켜기 전에 이미 누군가 같은 포트로 리슨하고 있으면 실패할 수 있다(커널/버전별 세부 정책 차이).

### 6.3 IPV6_V6ONLY

IPv6 리스너에서:

- `IPV6_V6ONLY = 0` 이면:
  - 해당 소켓이 **IPv4-mapped IPv6 주소(`::ffff:IPv4`)** 에 대한 연결도 받을 수 있다.
- `IPV6_V6ONLY = 1` 이면:
  - **진짜 IPv6 연결만** 받는다.
  - IPv4는 별도 IPv4 소켓에서 리슨해야 한다.

OS별 기본값이 다를 수 있으므로, **명시적으로 설정해 놓는 편이 좋다.**

예:

```cpp
int fd = ::socket(AF_INET6, SOCK_STREAM, 0);
int v6only = 1; // IPv6 전용 리스너
::setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
```

운영 설계:

- IPv4/IPv6를 **각각 명확히 나눠 관리**하고 싶다면:
  - `IPV6_V6ONLY = 1` 로 고정하고,
  - 별도의 IPv4 리스너를 두는 구조가 이해/디버깅에 유리하다.
- 반대로:
  - “한 포트에서 IPv4/IPv6를 모두 받아도 괜찮다”면 `V6ONLY=0` 정책을 쓴다.

---

## 7. 클라이언트에서의 bind() — 멀티홈/정책 제어

### 7.1 기본 connect() 동작

아무것도 건드리지 않으면:

1. `socket()` 생성
2. `connect(dst)` 호출
3. 커널이:
   - 라우팅 테이블 기반으로 **출구 인터페이스/로컬 IP**를 결정
   - 에페메랄 포트 중 하나를 선택
   - `(로컬 IP, 에페메랄 포트)` 로 암묵적 `bind()`
4. SYN 전송 → 3-way 핸드셰이크 완료 → 연결 성립

대부분의 클라이언트 코드는 이 기본 동작으로 충분하다.

### 7.2 멀티홈 환경에서의 소스 선택

하지만 다음 같은 상황에서는 `bind()` 가 필요하다.

- 호스트가:
  - `10.0.0.5` (내부망)
  - `203.0.113.10` (외부망)
  - 두 NIC를 가진 상태.
- 어떤 연결은 반드시 `10.0.0.5` 를 소스로 사용해야 하고,
- 어떤 연결은 `203.0.113.10` 을 써야 하는 요구가 있을 때.

패턴:

```cpp
// dst_host, dst_port 에 연결하되, src_host/src_port 로 바인드하기
unique_fd connect_with_source(const char* dst_host, const char* dst_port,
                              const char* src_host /*nullable*/,
                              const char* src_port /*nullable, "0" 가능*/) {
    auto D = resolve_strict(dst_host, dst_port,
                            AF_UNSPEC, SOCK_STREAM,
                            AI_ADDRCONFIG | AI_NUMERICSERV);

    for (addrinfo* ai = D.head; ai; ai = ai->ai_next) {
        unique_fd s{ ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol) };
        if (!s) continue;
        set_cloexec(s.get());

        // 소스 바인드가 지정된 경우
        if (src_host || src_port) {
            auto S = resolve_strict(src_host, src_port ? src_port : "0",
                                    ai->ai_family, ai->ai_socktype,
                                    AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV);

            bool bound = false;
            for (addrinfo* sj = S.head; sj; sj = sj->ai_next) {
                if (::bind(s.get(), sj->ai_addr, sj->ai_addrlen) == 0) {
                    bound = true;
                    break;
                }
                std::print(stderr, "[src-bind-fail] {} -> {}\n",
                           std::strerror(errno), to_string_sa(sj->ai_addr, sj->ai_addrlen));
            }
            if (!bound) {
                std::print(stderr, "[skip] cannot bind source\n");
                continue; // 다른 dst 후보 시도
            }
        }

        if (::connect(s.get(), ai->ai_addr, ai->ai_addrlen) == 0) {
            std::print("[connected] dst={} src-set={}\n",
                       to_string_sa(ai->ai_addr, ai->ai_addrlen),
                       src_host ? "yes" : "no");
            return s;
        }
        std::print(stderr, "[connect-fail] {} to {}\n",
                   std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
    }
    throw std::runtime_error("connect_with_source: no route worked");
}
```

- **핵심**:
  - 목적지 후보의 **주소 패밀리(AF_INET/AF_INET6)** 에 맞는 소스 주소로 바인드해야 한다.
  - `src_port = "0"` 를 주면 커널이 에페메랄 포트를 선택한다.

---

## 8. 보안·운영적 함의: bind()는 “노출 계약”이다

### 8.1 바인딩 주소 제한 = 노출 면적 제한

- 서비스가 **로컬에서만 사용**될 것이라면:
  - `127.0.0.1` 또는 `::1` 에만 바인드하는 것이 안전하다.
- 리버스 프록시/로드밸런서 앞단 구조에서는:
  - 외부에 노출되는 것은 NGINX/HAProxy 같은 프록시뿐이고,
  - 백엔드 애플리케이션은 **사설망 IP** 에만 바인드하는 것이 일반적이다.

예:

```cpp
// 백엔드 서버는 내부망에만 바인드
inet_pton(AF_INET, "10.0.0.5", &sa.sin_addr);
```

- 이 경우 외부에서 직접 `10.0.0.5:9000` 으로 접근할 수 없다면,
  - 공격 표면이 줄어든다.

### 8.2 권한 관리와 저권한 운영

- 80, 443 등 **Well-known 포트**를 바인드하려면 root 또는 특권이 필요하다.
- 그러나 애플리케이션 전체를 root로 돌리는 것은 위험하다.

일반적인 패턴:

1. 프로세스 시작 시 root 권한으로 `bind(0.0.0.0:80)` 수행.
2. 바인드/리스닝 완료 후 **권한을 일반 유저로 낮춤**.
3. 이후 요청 처리 로직은 저권한으로 실행.

또는:

- 별도의 **“포트 바인딩 헬퍼”**(작은 데몬)를 두어,
- 메인 서버는 헬퍼가 생성한 fd만 받아와 사용하는 구조도 있다.

---

## 9. 실습 1 — 다중 주소 후보 중 **성공하는 것만 선택**하는 안전 루프

> 목표: `getaddrinfo()`가 반환한 IPv6/IPv4 후보 리스트를 **순회**하면서,  
> 각 후보에 대해 `socket` → 옵션 → `bind` → `listen` 을 시도하고  
> **첫 번째 성공**만 선택하는 패턴을 만든다.

### 9.1 공통 유틸: RAII fd, 주소 해석, 문자열화

```cpp
// util_fd.hpp
#pragma once
#include <unistd.h>
#include <fcntl.h>
#include <utility>

struct unique_fd {
    int fd{-1};
    unique_fd() = default;
    explicit unique_fd(int f) : fd(f) {}
    unique_fd(const unique_fd&) = delete;
    unique_fd& operator=(const unique_fd&) = delete;
    unique_fd(unique_fd&& o) noexcept : fd(std::exchange(o.fd,-1)) {}
    unique_fd& operator=(unique_fd&& o) noexcept {
        if (this!=&o) {
            if (fd!=-1) ::close(fd);
            fd = std::exchange(o.fd,-1);
        }
        return *this;
    }
    ~unique_fd(){ if (fd!=-1) ::close(fd); }
    void reset(int f=-1) noexcept {
        if (fd!=-1) ::close(fd);
        fd=f;
    }
    int get() const noexcept { return fd; }
    explicit operator bool() const noexcept { return fd!=-1; }
};

inline int set_cloexec(int fd) {
    int fl = ::fcntl(fd, F_GETFD, 0);
    if (fl==-1) return -1;
    return ::fcntl(fd, F_SETFD, fl | FD_CLOEXEC);
}
```

```cpp
// util_addr.hpp
#pragma once
#include <netdb.h>
#include <string>
#include <stdexcept>
#include <print>

struct addr_list {
    addrinfo* head{};
    addr_list() = default;
    addr_list(const addr_list&) = delete;
    addr_list& operator=(const addr_list&) = delete;
    ~addr_list(){ if (head) ::freeaddrinfo(head); }
};

inline addr_list resolve_strict(const char* host, const char* service,
                                int family, int socktype, int flags) {
    addrinfo hints{};
    hints.ai_family   = family;
    hints.ai_socktype = socktype;
    hints.ai_protocol = 0;
    hints.ai_flags    = flags;
    addrinfo* res=nullptr;
    int rc = ::getaddrinfo(host, service, &hints, &res);
    if (rc!=0) throw std::runtime_error(std::string("getaddrinfo: ") + gai_strerror(rc));
    addr_list L; L.head=res; return L;
}

inline std::string to_string_sa(const sockaddr* sa, socklen_t salen) {
    char host[NI_MAXHOST]{}, serv[NI_MAXSERV]{};
    if (::getnameinfo(sa, salen, host, sizeof(host), serv, sizeof(serv),
                      NI_NUMERICHOST|NI_NUMERICSERV)==0)
        return std::string(host)+":"+serv;
    return "(unknown)";
}
```

### 9.2 TCP 서버: 안전 바인드 루프

```cpp
// server_bind_loop.cpp
#include "util_fd.hpp"
#include "util_addr.hpp"
#include <sys/socket.h>
#include <netinet/in.h>
#include <cstring>
#include <print>

unique_fd listen_first_success(const char* bind_host,
                               const char* port,
                               int backlog=256) {
    int flags = AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV;
    auto L = resolve_strict(bind_host, port, AF_UNSPEC, SOCK_STREAM, flags);

    for (addrinfo* ai = L.head; ai; ai = ai->ai_next) {
        unique_fd s{ ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol) };
        if (!s) {
            std::print(stderr, "[socket-fail] {}\n", std::strerror(errno));
            continue;
        }

        set_cloexec(s.get());

        int yes = 1;
        ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

        if (ai->ai_family == AF_INET6) {
            int v6only = 0; // 또는 정책적으로 1로 고정
            ::setsockopt(s.get(), IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
        }

        if (::bind(s.get(), ai->ai_addr, ai->ai_addrlen) != 0) {
            std::print(stderr, "[bind-fail] {} -> {}\n",
                       std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
            continue;
        }
        if (::listen(s.get(), backlog) != 0) {
            std::print(stderr, "[listen-fail] {} -> {}\n",
                       std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
            continue;
        }

        std::print("[listen-ok] {}\n", to_string_sa(ai->ai_addr, ai->ai_addrlen));
        return s; // move
    }
    throw std::runtime_error("listen_first_success: no address worked");
}

int main(int argc, char** argv) {
    const char* host = (argc>1 ? argv[1] : nullptr); // nullptr → ANY 바인드
    const char* port = (argc>2 ? argv[2] : "9000");

    try {
        auto ls = listen_first_success(host, port, 256);
        // 데모용: accept 1회
        sockaddr_storage cli{}; socklen_t clen=sizeof(cli);
        int cfd = ::accept(ls.get(), (sockaddr*)&cli, &clen);
        if (cfd >= 0) {
            std::print("[accept] peer={}\n", to_string_sa((sockaddr*)&cli, clen));
            ::close(cfd);
        }
    } catch (const std::exception& e) {
        std::print(stderr, "fatal: {}\n", e.what());
        return 1;
    }
    return 0;
}
```

실행 예:

```bash
g++ -std=c++23 server_bind_loop.cpp -o server

# ANY 바인드
./server
# [listen-ok] 0.0.0.0:9000   혹은 [listen-ok] [::]:9000

# 특정 IP 바인드
./server 127.0.0.1 9000
# [listen-ok] 127.0.0.1:9000
```

- `bind-fail`, `listen-fail` 로그에 **주소 문자열 + 에러 메시지**를 찍어두면,  
  운영 환경 차이를 파악하는 데 큰 도움이 된다.

### 9.3 UDP 서버: 동일 패턴

```cpp
// udp_bind_loop.cpp
#include "util_fd.hpp"
#include "util_addr.hpp"
#include <sys/socket.h>
#include <netinet/in.h>
#include <print>
#include <array>

unique_fd udp_bind_first_success(const char* host, const char* port) {
    int flags = AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV;
    auto L = resolve_strict(host, port, AF_UNSPEC, SOCK_DGRAM, flags);

    for (addrinfo* ai=L.head; ai; ai=ai->ai_next) {
        unique_fd s{ ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol) };
        if (!s) {
            std::print(stderr, "[socket-fail] {}\n", std::strerror(errno));
            continue;
        }

        set_cloexec(s.get());
        int yes=1;
        ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

        if (::bind(s.get(), ai->ai_addr, ai->ai_addrlen) != 0) {
            std::print(stderr, "[bind-fail] {} -> {}\n",
                       std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
            continue;
        }
        std::print("[bind-ok] {}\n", to_string_sa(ai->ai_addr, ai->ai_addrlen));
        return s;
    }
    throw std::runtime_error("udp_bind_first_success: no address worked");
}

int main(int argc, char** argv) {
    const char* host = (argc>1 ? argv[1] : nullptr);
    const char* port = (argc>2 ? argv[2] : "9999");

    try {
        auto s = udp_bind_first_success(host, port);
        std::array<char, 1500> buf{};
        sockaddr_storage peer{}; socklen_t plen=sizeof(peer);
        ssize_t n = ::recvfrom(s.get(), buf.data(), buf.size(), 0,
                               (sockaddr*)&peer, &plen);
        if (n > 0) {
            std::print("[udp] {} bytes from {}\n",
                       (int)n, to_string_sa((sockaddr*)&peer, plen));
            ::sendto(s.get(), buf.data(), (size_t)n, 0,
                     (sockaddr*)&peer, plen); // 에코
        }
    } catch (const std::exception& e) {
        std::print(stderr, "fatal: {}\n", e.what());
        return 1;
    }
    return 0;
}
```

---

## 10. 실습 2 — SO_REUSEPORT 로 멀티코어 분산 리스닝

> 목표: 같은 (IP, PORT)에 대해 **여러 리스너**를 두고 커널이 연결을 **분산**하게 만든다.

예시(요지):

```cpp
// multi_listen.cpp (요지)
unique_fd listen_v6(const char* port) {
    auto L = resolve_strict(nullptr, port, AF_INET6, SOCK_STREAM,
                            AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV);
    for (auto* ai=L.head; ai; ai=ai->ai_next) {
        unique_fd s{ ::socket(AF_INET6, SOCK_STREAM, 0) };
        if (!s) continue;
        set_cloexec(s.get());
        int yes=1;
        ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        int v6only=1;
        ::setsockopt(s.get(), IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
        // 여러 프로세스에서 리스닝하고 싶다면:
        ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes));
        if (::bind(s.get(), ai->ai_addr, ai->ai_addrlen)==0 &&
            ::listen(s.get(), 512)==0)
            return s;
    }
    throw std::runtime_error("v6 listen fail");
}

unique_fd listen_v4(const char* port) {
    auto L = resolve_strict(nullptr, port, AF_INET, SOCK_STREAM,
                            AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV);
    for (auto* ai=L.head; ai; ai=ai->ai_next) {
        unique_fd s{ ::socket(AF_INET, SOCK_STREAM, 0) };
        if (!s) continue;
        set_cloexec(s.get());
        int yes=1;
        ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes));
        if (::bind(s.get(), ai->ai_addr, ai->ai_addrlen)==0 &&
            ::listen(s.get(), 512)==0)
            return s;
    }
    throw std::runtime_error("v4 listen fail");
}
```

- 이처럼 IPv4/IPv6를 **분리 리스너**로 두면:
  - OS 기본 정책(v4-mapped 허용 여부)에 상관없이 **각 스택을 명확하게 관리** 가능.
- `SO_REUSEPORT` 를 통해:
  - 여러 프로세스/스레드가 동일 포트에 리슨하도록 해 **병렬 accept** 구조를 만들 수 있다.

---

## 11. bind() 이후 관측 — 제대로 잡혔는지 확인하는 방법

### 11.1 ss

```bash
ss -tanlp '( sport = :9000 )'
```

- LISTEN 상태의 소켓
- 로컬 IP/포트
- 소켓을 소유한 프로세스 PID/이름

### 11.2 lsof

```bash
sudo lsof -iTCP:9000 -sTCP:LISTEN -n -P
```

- 해당 포트로 리슨 중인 프로세스 목록.

### 11.3 tcpdump

```bash
sudo tcpdump -i any 'tcp port 9000' -n -vv
```

- SYN 패킷이 들어오고,
- 해당 포트에서 SYN/ACK 로 응답하는지 **패킷 레벨**에서 확인.

---

## 12. 흔한 함정과 디버깅 포인트

### 12.1 `htons` 깜박

```cpp
sa.sin_port = 9000;         // 잘못된 코드 (리틀엔디안 시스템 기준)
```

- `sin_port` 는 **네트워크 바이트 오더**로 넣어야 한다.

```cpp
sa.sin_port = htons(9000);  // 올바른 코드
```

- 깜빡하면:
  - 서버는 엉뚱한 포트에 바인드하거나,
  - 클라이언트에서 연결 시 “왜 서버가 안 뜬 것 같지?” 같은 문제가 생긴다.

### 12.2 IPv6 링크-로컬 스코프

```cpp
sockaddr_in6 sa{};
sa.sin6_family = AF_INET6;
inet_pton(AF_INET6, "fe80::1", &sa.sin6_addr);
sa.sin6_port = htons(9000);
// sa.sin6_scope_id = if_nametoindex("eth0");  // 이걸 빼먹으면 문제
```

- 링크-로컬 주소는 **어느 인터페이스의 링크-로컬인지** 명시해야 한다.
- 스코프 ID가 틀리면 `EADDRNOTAVAIL` 또는 `ENODEV`.

### 12.3 TIME_WAIT 오해

- 서버 재기동 직후 같은 포트 바인드 실패:
  - 대부분 `SO_REUSEADDR` 가 설정되어 있지 않아서.
- 연결 수가 많은 고부하 서버에서는:
  - `TIME_WAIT` 튜닝,
  - `SO_REUSEADDR`,  
  - 필요하면 **포트 범위 확장** 등과 조합해 설계한다.

### 12.4 서비스명 의존

- `getaddrinfo("0.0.0.0", "http", ...)`  
  처럼 서비스명을 쓰는 경우:
  - `/etc/services` 나 OS 서비스 DB 에 해당 서비스명이 없으면 실패.
- **운영 환경이 섞인** 곳에서는:
  - `"9000"`처럼 **숫자 포트 명시 + `AI_NUMERICSERV`** 플래그를 사용하는 것이 더 예측 가능하다.

### 12.5 v4/v6 혼선

- “IPv6 리스너 하나로 v4까지 다 받을 수 있다”고 가정해버리면:
  - OS/배포판에 따라 **예상과 다른 동작**을 할 수 있다.
- 가장 확실한 방법:
  - `IPV6_V6ONLY` 를 명시적으로 설정하고,
  - IPv4 리스너와 IPv6 리스너를 **분리**해서 관리하는 것.

---

## 13. 수식으로 보는 포트 공간 직관

포트 번호는 16비트 부호 없는 정수이다.

- 전체 포트 공간:
  $$
  N_{\text{total}} = 2^{16} = 65536
  $$

전통적 분할:

1. Well-known ports: 0–1023
   $$
   N_{\text{well-known}} = 1024
   $$
2. Registered ports: 1024–49151
   $$
   N_{\text{registered}} = 49151 - 1024 + 1 = 48128
   $$
3. Dynamic/Ephemeral: 49152–65535
   $$
   N_{\text{ephemeral}} = 65535 - 49152 + 1 = 16384
   $$

이 포트 공간에 대해 **각 (IP, 포트, 프로토콜)** 조합을 어떻게 사용할지 결정하는 것이,  
실제로는 서비스 디플로이/방화벽/로드밸런서 설계와 직접 연결된다.

---

## 14. 체크리스트(요약)

- [ ] `bind()` = (로컬 IP, 로컬 포트, 프로토콜)의 **소유권 선언**임을 이해할 것.
- [ ] 서버:
  - [ ] `bind()` 후 `listen()` 으로 리스너 완성.
  - [ ] `SO_REUSEADDR` 로 재기동 편의 확보.
  - [ ] 필요 시 `SO_REUSEPORT` 로 멀티코어 분산 리스닝.
  - [ ] IPv6 리스너의 `IPV6_V6ONLY` 정책을 **명시적으로 고정**.
- [ ] 클라이언트:
  - [ ] 기본은 `connect()` 가 자동으로 (로컬 IP, 에페메랄 포트) 를 선택하게 둔다.
  - [ ] 멀티홈/정책 라우팅/소스 포트 고정이 필요하면 **직접 `bind()`**.
- [ ] 주소 선택:
  - [ ] 0.0.0.0/:: ANY 바인드는 간편하지만, **불필요한 노출** 가능성을 주의.
  - [ ] 내부망/루프백 전용 서비스는 **특정 IP** 에만 바인드.
- [ ] 에러 처리:
  - [ ] `EADDRINUSE` 시, TIME_WAIT/기존 리스너/REUSE 옵션을 점검.
  - [ ] `EADDRNOTAVAIL` 시, NIC/주소/링크-로컬 스코프 확인.
  - [ ] `EACCES` 시, Well-known 포트와 권한 정책 점검.
- [ ] 관측:
  - [ ] `ss`, `lsof`, `tcpdump` 로 실제 리슨 상태/패킷 흐름 확인.
- [ ] 코드 패턴:
  - [ ] `getaddrinfo()` 후보 리스트 전체에 대해 루프를 돌며, **첫 성공만 사용**.
  - [ ] 실패 케이스마다 주소와 에러를 로그에 남기기.

---

## 15. 마무리 — bind()는 로컬 엔드포인트 “계약”

`bind()` 는 단순히 “포트를 여는 함수” 가 아니라,

- **이 포트 조합을 어느 프로세스가 쓸 것인지**,
- **어느 NIC/주소를 통해 노출할 것인지**,
- **서버 재기동/스케일아웃/보안 정책을 어떻게 가져갈 것인지**를  
  운영체제에 명시하는 **계약**이다.

“`getaddrinfo`로 후보를 만들고, 루프를 돌며 `socket → 옵션 → bind → listen` 을 시도한 뒤,  
**첫 성공만 쓰고 나머지는 로그**로 남기는 패턴”은

- IPv4/IPv6 혼재,
- 운영체제별 기본 정책 차이,
- 서비스 DB 차이,

같은 현실적인 변동성 속에서도 **견고한 서버/클라이언트**를 만드는 **근본 템플릿**이 된다.