---
layout: post
title: 파이썬 심화 - 문자열과 텍스트 (4)
date: 2025-11-26 20:25:23 +0900
category: 파이썬 심화
---
# 파이썬 텍스트 처리와 파싱 기법

## 텍스트 토큰화 기법

텍스트 토큰화는 문자열을 의미 있는 단위(토큰)로 분해하는 과정으로, 텍스트 분석, 컴파일러 구현, 데이터 전처리 등 다양한 분야에서 활용됩니다.

### 기본 문자열 분할

```python
# 간단한 공백 기반 토큰화
text = "Hello World! This is Python."
tokens = text.split()
print(tokens)  # ['Hello', 'World!', 'This', 'is', 'Python.']

# 특정 구분자로 토큰화
csv_data = "apple,banana,cherry,date"
tokens = csv_data.split(',')
print(tokens)  # ['apple', 'banana', 'cherry', 'date']

# 최대 분할 횟수 지정
text = "one:two:three:four:five"
tokens = text.split(':', 2)
print(tokens)  # ['one', 'two', 'three:four:five']
```

### 정규표현식을 활용한 고급 토큰화

```python
import re

# 복잡한 패턴 토큰화
text = "John has 3 apples and 2 oranges. The price is $12.50 each."

# 단어와 숫자 토큰화
word_pattern = re.compile(r'\b\w+\b')
words = word_pattern.findall(text)
print(words)  # ['John', 'has', '3', 'apples', 'and', '2', 'oranges', 'The', 'price', 'is', '12', '50', 'each']

# 숫자만 추출
number_pattern = re.compile(r'\d+\.?\d*')
numbers = number_pattern.findall(text)
print(numbers)  # ['3', '2', '12.50']

# 다양한 패턴 혼합 토큰화
mixed_pattern = re.compile(r'''
    \d+\.?\d*    |  # 숫자 (정수 또는 소수)
    \$?\d+\.?\d* |  # 통화 기호 포함 숫자
    \b[A-Z][a-z]*\b |  # 대문자로 시작하는 단어
    \b[a-z]+\b       # 일반 단어
''', re.VERBOSE)

tokens = mixed_pattern.findall(text)
print(tokens)  # ['John', 'has', '3', 'apples', 'and', '2', 'oranges', 'The', 'price', 'is', '12.50', 'each']
```

### 제너레이터를 활용한 효율적인 토큰화

```python
def tokenize(text, pattern=r'\b\w+\b'):
    """제너레이터를 사용한 메모리 효율적인 토큰화"""
    token_pattern = re.compile(pattern)
    for match in token_pattern.finditer(text):
        yield match.group()

# 대용량 텍스트 처리에 적합
text = "This is a sample text for tokenization demonstration."
for token in tokenize(text):
    print(token, end=' ')
# 출력: This is a sample text for tokenization demonstration.
```

## 간단한 재귀 파서 작성하기

재귀 파서는 중첩된 구조를 처리하는 데 효과적입니다. 수식 파싱, JSON 파싱, 간단한 프로그래밍 언어 구현 등에 사용됩니다.

### 기본적인 산술 표현식 파서

```python
import re

class ExpressionParser:
    def __init__(self):
        self.tokens = []
        self.current = 0
    
    def parse(self, expression):
        """산술 표현식 파싱 (덧셈, 뺄셈, 곱셈, 나눗셈, 괄호 지원)"""
        # 토큰화
        token_pattern = re.compile(r'''
            \d+\.?\d*    |  # 숫자
            [+\-*/()]    |  # 연산자와 괄호
            \s+             # 공백 (무시)
        ''', re.VERBOSE)
        
        self.tokens = [token for token in token_pattern.findall(expression) 
                      if not token.isspace()]
        self.current = 0
        return self.expr()
    
    def expr(self):
        """표현식 파싱: term + term 또는 term - term"""
        result = self.term()
        
        while self.current < len(self.tokens):
            token = self.tokens[self.current]
            if token == '+':
                self.current += 1
                result += self.term()
            elif token == '-':
                self.current += 1
                result -= self.term()
            else:
                break
        
        return result
    
    def term(self):
        """항 파싱: factor * factor 또는 factor / factor"""
        result = self.factor()
        
        while self.current < len(self.tokens):
            token = self.tokens[self.current]
            if token == '*':
                self.current += 1
                result *= self.factor()
            elif token == '/':
                self.current += 1
                divisor = self.factor()
                if divisor == 0:
                    raise ZeroDivisionError("0으로 나눌 수 없습니다.")
                result /= divisor
            else:
                break
        
        return result
    
    def factor(self):
        """인자 파싱: 숫자 또는 괄호 표현식"""
        token = self.tokens[self.current]
        
        if token == '(':
            self.current += 1  # '(' 건너뛰기
            result = self.expr()  # 괄호 안의 표현식 파싱
            self.current += 1  # ')' 건너뛰기
            return result
        else:
            # 숫자 토큰
            self.current += 1
            return float(token) if '.' in token else int(token)

# 사용 예제
parser = ExpressionParser()
result = parser.parse("3 + 4 * (2 - 1)")
print(f"3 + 4 * (2 - 1) = {result}")  # 7.0

result = parser.parse("(10 + 2) * 3 / 4")
print(f"(10 + 2) * 3 / 4 = {result}")  # 9.0
```

### 간단한 JSON 파서 구현

```python
class SimpleJSONParser:
    def __init__(self):
        self.tokens = []
        self.current = 0
    
    def parse(self, json_string):
        """간단한 JSON 파서 구현"""
        # 기본 토큰화
        token_pattern = re.compile(r'''
            \{|\}         |  # 객체 괄호
            \[|\]         |  # 배열 괄호
            :|,           |  # 구분자
            true|false    |  # 불리언
            null          |  # null
            -?\d+\.?\d*   |  # 숫자
            "[^"]*"       |  # 문자열
            \s+              # 공백 (무시)
        ''', re.VERBOSE)
        
        self.tokens = [token for token in token_pattern.findall(json_string) 
                      if not token.isspace()]
        self.current = 0
        return self.parse_value()
    
    def parse_value(self):
        """값 파싱 (재귀적)"""
        token = self.tokens[self.current]
        
        if token == '{':
            return self.parse_object()
        elif token == '[':
            return self.parse_array()
        elif token.startswith('"'):
            self.current += 1
            return token[1:-1]  # 따옴표 제거
        elif token in ('true', 'false'):
            self.current += 1
            return token == 'true'
        elif token == 'null':
            self.current += 1
            return None
        else:
            # 숫자
            self.current += 1
            if '.' in token:
                return float(token)
            return int(token)
    
    def parse_object(self):
        """JSON 객체 파싱"""
        obj = {}
        self.current += 1  # '{' 건너뛰기
        
        if self.tokens[self.current] == '}':
            self.current += 1
            return obj
        
        while True:
            # 키 파싱
            key = self.tokens[self.current][1:-1]  # 따옴표 제거
            self.current += 1
            
            # ':' 건너뛰기
            self.current += 1
            
            # 값 파싱
            value = self.parse_value()
            obj[key] = value
            
            # 다음 키 확인 또는 객체 종료
            if self.tokens[self.current] == '}':
                self.current += 1
                break
            else:
                self.current += 1  # ',' 건너뛰기
        
        return obj
    
    def parse_array(self):
        """JSON 배열 파싱"""
        arr = []
        self.current += 1  # '[' 건너뛰기
        
        if self.tokens[self.current] == ']':
            self.current += 1
            return arr
        
        while True:
            # 배열 요소 파싱
            value = self.parse_value()
            arr.append(value)
            
            # 다음 요소 확인 또는 배열 종료
            if self.tokens[self.current] == ']':
                self.current += 1
                break
            else:
                self.current += 1  # ',' 건너뛰기
        
        return arr

# 사용 예제
json_parser = SimpleJSONParser()
data = json_parser.parse('{"name": "John", "age": 30, "scores": [95, 87, 92]}')
print(data)  # {'name': 'John', 'age': 30, 'scores': [95, 87, 92]}
```

## 바이트 문자열에 텍스트 연산 수행

바이트 문자열(byte string)은 이미지, 음성 파일, 네트워크 프로토콜 등 바이너리 데이터를 다룰 때 사용됩니다.

### 기본 바이트 문자열 연산

```python
# 바이트 문자열 생성
byte_data = b'Hello World'
print(byte_data)  # b'Hello World'
print(type(byte_data))  # <class 'bytes'>

# 인코딩을 통한 변환
text = "안녕하세요"
utf8_bytes = text.encode('utf-8')
print(utf8_bytes)  # b'\xec\x95\x88\xeb\x85\x95\xed\x95\x98\xec\x84\xb8\xec\x9a\x94'
print(len(utf8_bytes))  # 15 (UTF-8에서 한글은 3바이트)

# 디코딩
decoded_text = utf8_bytes.decode('utf-8')
print(decoded_text)  # '안녕하세요'
```

### 바이트 문자열의 텍스트 연산

```python
# 문자열 메서드와 유사한 연산
data = b'Hello World Python Programming'

# 분할
parts = data.split(b' ')
print(parts)  # [b'Hello', b'World', b'Python', b'Programming']

# 검색
index = data.find(b'Python')
print(f"'Python' 위치: {index}")  # 12

# 대소문자 변환
upper_data = data.upper()
print(upper_data)  # b'HELLO WORLD PYTHON PROGRAMMING'

# 시작/끝 확인
starts_with_hello = data.startswith(b'Hello')
print(starts_with_hello)  # True

# 바이트 배열로 변환 (가변 데이터)
byte_array = bytearray(data)
byte_array[0] = 74  # 'H' (72) → 'J' (74)
print(byte_array)  # b'Jello World Python Programming'
```

### 바이너리 데이터 패턴 검색

```python
# 바이너리 패턴 검색
binary_data = b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a'

# 특정 바이트 시퀀스 검색
pattern = b'\x03\x04\x05'
if pattern in binary_data:
    index = binary_data.find(pattern)
    print(f"패턴 발견 위치: {index}")  # 3

# 정규표현식과 유사한 패턴 매칭 (간단한 버전)
def find_byte_pattern(data, pattern):
    """바이트 패턴 검색"""
    pattern_length = len(pattern)
    for i in range(len(data) - pattern_length + 1):
        if data[i:i+pattern_length] == pattern:
            return i
    return -1

# 사용 예제
result = find_byte_pattern(binary_data, b'\x06\x07\x08')
print(f"패턴 위치: {result}")  # 6
```

### 네트워크 프로토콜 파싱 예제

```python
def parse_http_response(response_bytes):
    """HTTP 응답 파싱 (간단한 버전)"""
    # 헤더와 본문 분리
    header_end = response_bytes.find(b'\r\n\r\n')
    if header_end == -1:
        raise ValueError("올바른 HTTP 응답이 아닙니다.")
    
    headers_bytes = response_bytes[:header_end]
    body_bytes = response_bytes[header_end + 4:]
    
    # 헤더 파싱
    headers = {}
    header_lines = headers_bytes.split(b'\r\n')
    
    # 상태 라인
    status_line = header_lines[0].decode('utf-8')
    print(f"상태 라인: {status_line}")
    
    # 헤더 필드
    for line in header_lines[1:]:
        if b':' in line:
            key, value = line.split(b':', 1)
            headers[key.strip().decode('utf-8')] = value.strip().decode('utf-8')
    
    return headers, body_bytes

# 예제 HTTP 응답 (간소화)
http_response = b'''HTTP/1.1 200 OK\r
Content-Type: text/html; charset=utf-8\r
Content-Length: 25\r
Server: Apache\r
\r
<html>Hello World!</html>'''

headers, body = parse_http_response(http_response)
print("헤더:", headers)
print("본문:", body.decode('utf-8'))
```

### 파일 형식 식별 (매직 넘버)

```python
def identify_file_type(file_bytes):
    """파일의 매직 넘버로 형식 식별"""
    magic_numbers = {
        b'\xff\xd8\xff': 'JPEG',
        b'\x89PNG\r\n\x1a\n': 'PNG',
        b'%PDF': 'PDF',
        b'\x25\x50\x44\x46': 'PDF (alternative)',
        b'GIF87a': 'GIF87a',
        b'GIF89a': 'GIF89a',
        b'\x00\x00\x01\x00': 'ICO',
        b'\x42\x4d': 'BMP',
    }
    
    for magic, file_type in magic_numbers.items():
        if file_bytes.startswith(magic):
            return file_type
    
    return 'Unknown'

# 테스트
jpeg_header = b'\xff\xd8\xff\xe0\x00\x10JFIF'
png_header = b'\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR'

print(f"JPEG 파일: {identify_file_type(jpeg_header)}")  # JPEG
print(f"PNG 파일: {identify_file_type(png_header)}")    # PNG
```

## 결론

텍스트 토큰화는 `split()` 메서드로 간단한 분할부터 `re` 모듈의 정규표현식을 활용한 복잡한 패턴 기반 토큰화까지 다양한 수준으로 구현할 수 있습니다. 재귀 파서는 중첩된 구조를 처리하는 데 효과적인데, 표현식 파싱에서는 연산자 우선순위를 고려한 재귀적 하향 파싱을, JSON 파싱에서는 재귀적 값 파싱을 구현할 수 있습니다.

바이트 문자열 연산은 바이너리 데이터 처리를 위해 필수적입니다. 문자열 메서드와 유사한 인터페이스를 제공하지만, 인코딩/디코딩 처리가 필요하고, 바이너리 패턴 검색과 같은 저수준 연산이 가능합니다. 네트워크 프로토콜 파싱이나 파일 형식 식별과 같은 실제 응용에서는 바이트 단위의 정밀한 조작이 필요합니다.

이러한 기법들을 적절히 조합하면 텍스트 처리, 데이터 파싱, 바이너리 데이터 분석 등 다양한 문제를 효과적으로 해결할 수 있습니다. 각 기법의 특성을 이해하고 상황에 맞게 적용하는 것이 중요합니다.