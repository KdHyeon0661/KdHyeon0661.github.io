---
layout: post
title: 컴퓨터시스템 - 물리 및 가상 주소 방식
date: 2025-08-16 19:20:23 +0900
category: 컴퓨터시스템
---
# 물리(Physical) 및 가상(Virtual) 주소 방식 — 메모리 주소의 이중 세계

> 목표: **프로그램이 보는 주소(가상)**와 **DRAM 칩의 실제 선·열(물리)** 사이를 잇는 전 과정을 OS/하드웨어 관점에서 정리.  
> 키워드: **MMU, 페이지 테이블, TLB, 페이지 폴트, 보호/격리, ASLR, COW, huge page, IOMMU, EPT/NPT(가상화)**

---

## 1) 큰 그림: 왜 주소가 두 개일까?

- **물리 주소(Physical Address)**: DRAM 모듈에서 바이트를 고유하게 지칭하는 **실제 주소**.
- **가상 주소(Virtual Address)**: **각 프로세스에 독립적으로 보이는** 주소. 프로그램은 항상 “0x…” 형태의 **가상** 주소만 사용.

**이점**
1. **격리/보호**: 프로세스 간 메모리 침범 방지.
2. **유연한 배치**: 산개한 물리 프레임을 연속 가상공간처럼 보여줌.
3. **성능/기능**: COW(복사-시-쓰기), 메모리 매핑 파일, 공유 라이브러리, ASLR, 힙 확장 등.

---

## 2) 주소 변환의 배우들

- **MMU (Memory Management Unit)**: 가상→물리 주소로 **하드웨어 변환**.
- **페이지(Page)**: 변환의 최소 단위. 보통 **4KB**, 또한 **2MB/1GB(huge page)** 사용 가능.
- **페이지 테이블(Page Table)**: 가상 페이지 번호(VPN) → 물리 프레임 번호(PFN) 매핑.
- **PTE (Page Table Entry)**: 매핑과 **권한 비트**(R/W/X, U/S, Dirty, Accessed, Present …) 포함.
- **TLB (Translation Lookaside Buffer)**: **최근 변환 결과 캐시**. 대부분의 접근은 **TLB 히트**로 해결.

수학적으로:
\[
\text{Virtual Address} = \underbrace{\text{VPN}}_{\text{상위 비트}} \,\|\, \underbrace{\text{Offset}}_{\text{하위 } \log_2(\text{PageSize})}
\]
\[
\text{Physical Address} = \underbrace{\text{PFN}}_{\text{페이지 프레임}} \,\|\, \text{Offset}
\]

---

## 3) 물리 주소 방식 (직접 접근의 세계)

### 3.1 정체
- CPU가 **가상화 없이** 바로 물리 주소를 내보내는 방식(임베디드·초기 시스템).
- 현대 범용 OS에서는 **커널 내부 일부 경로**(PA 직참조, DMA/IOMMU 제외) 외엔 드묾.

### 3.2 특징
- 변환 비용 없음(간단).
- **보호/격리 부재** → 프로세스가 서로 메모리를 침범할 수 있으므로 현대 OS에는 부적합.

---

## 4) 가상 주소 방식 (현대 OS의 표준)

### 4.1 페이징(Paging)
- 가상 공간을 고정 크기 **페이지**로 나누고, 각 페이지를 **물리 프레임**에 매핑.
- **불연속** 물리 프레임을 **연속 가상 공간**으로 보이게 함.

### 4.2 보호/격리
- PTE의 권한비트로 **읽기/쓰기/실행**을 제어하고, **사용자/커널 모드** 구분.
- 잘못된 접근은 **페이지 폴트(Protection Fault)** 발생.

### 4.3 수요 페이징(Demand Paging)
- 처음 접근할 때까지 물리 메모리를 할당하지 않음(지연 로딩).
- 디스크에서 페이지를 **필요할 때만** 올려 메모리를 절약.

### 4.4 COW(Copy-On-Write)
- `fork()` 후 부모/자식이 **같은 물리 페이지**를 **읽기 전용**으로 공유.
- 어느 한 쪽이 **쓰기** 시도 → **복사 후** 각자 쓰기.

---

## 5) 주소 변환의 빠른 길: TLB

- **I-TLB**(명령) / **D-TLB**(데이터), **L2 TLB** 등 다단 캐시.
- **TLB 미스**: 하드웨어 **페이지 워크(page walk)** 로 테이블을 내려가며 PTE 탐색 → 변환 결과를 TLB에 적재.
- 성능 포인트:
  - **작은 페이지(4KB)**는 세밀하지만 **TLB 압박**↑.
  - **huge page(2MB/1GB)**는 TLB 효율↑, 페이지 워크↓(대용량 워킹셋에 유리).

---

## 6) x86-64 주소 변환 (4/5단계 테이블)

### 6.1 주소 구조(전통 48비트 canonical, 상위 sign-extension)
- **페이지 크기 4KB**일 때:
  - `Offset`: 12비트
  - 상위는 PML4 → PDPT → PD → PT (각 9비트)
- **1GB/2MB** huge page 사용 시 중간 레벨에서 종결(PSE).

```
VA[47:39] PML4  ┐
VA[38:30] PDPT  ├─ 인덱스 9비트씩
VA[29:21] PD    ┤
VA[20:12] PT    ┘
VA[11:0]  Offset
```

**과정**: TLB 히트? → 종료. 미스면 CR3(루트)부터 **4~5단계 워크**로 PTE 탐색 → 권한/존재 확인 → PFN‖Offset.

### 6.2 주요 비트
- P: Present, R/W, U/S(User/Supervisor), NX(eXecute disable), A/D(Accessed/Dirty) …
- **NX**로 W^X(Write xor Execute) 정책 구현(보안↑).

---

## 7) ARM64(AArch64) 개요

- 최대 4~5레벨 테이블, 페이지 4KB/16KB/64KB.
- **TTBR0/1** 레지스터로 사용자/커널 공간 분리.
- **PAN/PXN**(Privileged Access Never/eXecute Never) 등 세밀한 보호 비트.

---

## 8) 커널·사용자 가상 주소 배치(일반적 관례)

- **사용자 공간**: 프로세스별로 독립(예: 하위 절반 0~128TB).
- **커널 공간**: 모든 프로세스가 공유하는 단일 맵(상위 절반). 문맥 전환 비용↓.
- **ASLR**: 스택/힙/라이브러리/PIE의 배치 무작위화(익스플로잇 난이도↑).

예(리눅스 x86-64, 단순화):
```
[ 높은 주소 ]
Kernel text/data
vmalloc/ioremap
phys map (Direct map)
---------------------
User stack  (ASLR)
Shared libs (ASLR)
Heap        (ASLR)
Code (PIE)  (ASLR)
NULL page (unmapped)
[ 낮은 주소 ]
```

---

## 9) 메모리 매핑과 공유

### 9.1 파일 매핑(mmap)
```c
#include <sys/mman.h>
// 파일을 가상 주소에 매핑
void* p = mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);
```
- 페이징과 파일 캐시를 결합 → **I/O 없이 메모리처럼 접근**.
- 공유 라이브러리(.so)는 **여러 프로세스가 같은 물리 페이지**(코드/rodata)를 공유.

### 9.2 공유 메모리
- `MAP_SHARED`/POSIX shm/System V shm으로 프로세스 간 **물리 페이지 공유**.

---

## 10) 페이지 폴트(Page Fault)

- 이유: **미매핑**, **보호 위반**, **스왑 아웃**, **COW 트랩** 등.
- 커널이 원인 판별 → **합법적**이면 디스크에서 올리거나 프레임 할당(COW 처리) → PTE 갱신 → 재시도.  
  **불법**이면 `SIGSEGV`.

---

## 11) 성능 관점: TLB·캐시·지역성

- **TLB 미스**는 수십~수백 사이클의 페이지 워크 비용.  
  → **공간/시간 지역성**을 높이고, **huge page**로 TLB 압박 완화.
- **캐시 일관성과 인덱싱**:
  - VIPT(virtually indexed, physically tagged) L1D가 일반적.  
    **같은 물리 페이지**가 **여러 가상 주소(에일리어스)** 로 매핑되면 캐시 동기화 주의(커널이 관리).
- **NUMA**: 원격 노드 접근 지연↑ → **메모리 바인딩/first-touch**로 지역성 확보.

---

## 12) 보안/격리: 권한 비트와 정책

- **U/S**: 사용자 모드는 커널 페이지 접근 불가(트랩).
- **NX**: 데이터 페이지 실행 금지 → ROP/JOP 완화는 별도의 CFI/BTI 필요.
- **KASLR/SMEP/SMAP**: 커널 공간 무작위화/사용자 공간 실행·접근 제한.
- **W^X**: 한 페이지를 동시에 W와 X로 두지 않기(Just-In-Time은 두 단계로 전환).

---

## 13) I/O와 주소: DMA, IOMMU

- 장치가 메모리에 **DMA**를 하려면 **물리 주소**가 필요.
- 현대 시스템은 **IOMMU**로 장치에도 **장치-가상 주소→물리** 변환 제공:
  - 장치 격리, **버스 마스터 악용** 방지, 큰 버퍼를 **연속 가상**으로 제공.

---

## 14) 가상화: EPT/NPT의 2차 변환

- 하이퍼바이저 환경:
  - 게스트는 **가상→게스트 물리**(게스트 페이지 테이블),
  - 하드웨어는 **게스트 물리→호스트 물리**(**EPT/NPT**, 2차 테이블).
- **2차 변환**으로 TLB 비용↑ → **nested TLB/combined TLB** 등 최적화가 중요.
- 대용량 페이지(EPT huge)로 압박 완화.

---

## 15) 흔한 질문(FAQ)

**Q1. 포인터 값은 가상 주소?**  
A. 네. 사용자 코드에서 보는 포인터는 **항상 가상 주소**. 물리 주소는 커널/드라이버만 안다.

**Q2. 왜 같은 라이브러리를 여러 프로세스가 써도 메모리 낭비가 없나?**  
A. 코드/RO 데이터는 **같은 물리 페이지**를 **여러 프로세스의 가상 주소**에 매핑하여 **공유**한다.

**Q3. 64비트면 2⁶⁴ 주소를 모두 쓰나?**  
A. 아키텍처/실장에 따라 **유효 비트**만 사용(예: x86-64는 오랫동안 48-bit canonical, 최신 확장 57-bit).

---

## 16) 실습 힌트(리눅스)

### 16.1 현재 프로세스의 맵
```bash
cat /proc/$$/maps | head -20
cat /proc/$$/smaps | less
```

### 16.2 간단 C 예시: 주소와 보호
```c
#include <stdio.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>

int main(){
    size_t ps = sysconf(_SC_PAGESIZE);
    void* p = mmap(NULL, ps, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    printf("VA=%p (page size=%zu)\n", p, ps);
    strcpy((char*)p, "hello");
    // 실행 금지를 테스트 (NX): 기본은 실행 비트 없음
    // (*(void(**)(void))p)(); // 대개 SIGSEGV
    mprotect(p, ps, PROT_READ);     // 쓰기 제거
    // ((char*)p)[0]='H';           // 보호 위반 → SIGSEGV
    munmap(p, ps);
}
```

---

## 17) 체크리스트(성능·안정성)

- [ ] **TLB 히트율**을 높이자: **연속 접근**, **데이터 구조 군집화**, **huge page**(필요 시).
- [ ] **W^X/NX**로 실행/쓰기를 분리(보안↑).
- [ ] **COW/메모리 매핑**으로 복사·I/O 오버헤드 감소.
- [ ] **NUMA 바인딩/first-touch**로 원격 접근 최소화.
- [ ] DMA 장치에는 **IOMMU**/핀(pin) 정책을 이해하고 사용.

---

## 18) 한 줄 결론
현대 시스템에서 **가상 주소**는 개발자에게 **넓고 안전한 착시 공간**을 제공하고,  
**MMU·페이지 테이블·TLB**는 그 착시를 **물리 주소**로 고속·정확하게 매핑한다.  
이 구조 덕분에 우리는 **격리/보호**·**유연한 배치**·**강력한 기능(COW/매핑/ASLR)**·**성능 최적화(huge page/NUMA)** 를 동시에 누린다.