---
layout: post
title: 논리회로설계 - 퀸–맥클러스키
date: 2025-09-03 14:25:23 +0900
category: 논리회로설계
---
# 퀸–맥클러스키(Quine–McCluskey) — **비완전 명세함수(ISF)의 간략화**와 **변수가 있는 맵(Variable–Entered Map, VEM)으로 간략화**

> 표기: \(+\)=OR, \(\cdot\) 또는 생략=AND, \(\overline{A}\)=NOT \(A\).  
> 목표: (1) **don’t-care를 포함한 비완전 명세함수(ISF)** 를 Q–M 알고리즘으로 최소화하는 법, (2) **변수가 있는 맵(VEM)** 으로 고차 변수의 **인수화와 XOR/ESOP 패턴**을 빠르게 찾아내는 법을 실전 중심으로 정리한다.  
> 주의: “패트릭 방법”은 정확히 **페트릭(Petrick) 방법**이다.

---

## 1. ISF(비완전 명세함수) 최소화: Q–M 알고리즘

### 1.1 ISF와 최적화 목표
입력공간 \(\mathcal{U}\)를
\[
\mathcal{U}=\mathcal{ON}\;\dot{\cup}\;\mathcal{OFF}\;\dot{\cup}\;\mathcal{DC}
\]
로 분해한다. \(\mathcal{ON}\)은 반드시 1, \(\mathcal{OFF}\)는 반드시 0, \(\mathcal{DC}\)는 **미지정(don’t-care)**.  
**최소 SOP(합의곱)** 관점에서의 원칙:

- **결합 단계(주항 생성)**: \(\mathcal{ON}\cup\mathcal{DC}\)를 모두 사용해 **가능한 한 큰 주항(implicant)** 생성  
- **최종 커버 선택**: **열(covered minterms)은 \(\mathcal{ON}\)만** 두고 **필수 주항(EPI)**을 고른 뒤, 남은 부분은 **페트릭 방법**으로 최소 커버 선택

> 요지: **결합에는 DC를 적극 활용**, **최종 커버 판단에서 DC는 제외**.

---

### 1.2 Q–M 절차(정석)
1) **그룹화**: \(\mathcal{ON}\cup\mathcal{DC}\)를 **1의 개수(weight)** 로 버킷화  
2) **결합 반복**: 인접 버킷(차이 1인 비트)끼리 결합 → ‘–’로 don’t-care 자리를 표시  
3) **더 이상 결합 불가**: 남은 항들이 **소수 주항(PI)**  
4) **PI 차트**: 행=PI, 열=\(\mathcal{ON}\) 미니텀. 표시=PI가 그 미니텀을 덮음  
5) **EPI 선택**: 어떤 열을 **유일하게 덮는** PI는 **필수 주항(EPI)**  
6) **잔여 커버**: 남은 열에 대해 **페트릭 방법**(곱의 합 → 합의 곱 전개 후 최소항 선택)

- **비용함수**: (i) 항 개수, (ii) 전체 리터럴 수, (iii) 구현 제약(예: NAND-only, 팬인 상한)

---

### 1.3 예제 A — 4변수 ISF(기본 흐름 완주)
\[
F(A,B,C,D)=\sum m(1,3,7,11)+d(0,2)
\]
2진:
\[
m_0=0000^*,\ m_1=0001,\ m_2=0010^*,\ m_3=0011,\ m_7=0111,\ m_{11}=1011 \quad (^*\!=DC)
\]

**(a) 결합(ON∪DC)**  
- 1차 결합 예:
  - \(0000\)–\(0001 \to \mathbf{000-}\)
  - \(0010\)–\(0011 \to \mathbf{001-}\)
  - \(0011\)–\(0111 \to \mathbf{0-11}\)
  - \(0011\)–\(1011 \to \mathbf{-011}\)
- 2차 결합:
  - \(\mathbf{000-}\) & \(\mathbf{001-}\) \(\to \mathbf{00--}\)  (A=0,B=0 고정)

**PI 후보**  
\(\mathbf{00--}\Rightarrow \overline{A}\overline{B},\quad \mathbf{0-11}\Rightarrow \overline{A}CD,\quad \mathbf{-011}\Rightarrow \overline{B}CD\)

**(b) PI 차트(열=\(\mathcal{ON}=\{1,3,7,11\}\)만)**

| PI \ m | 1 | 3 | 7 | 11 |
|:--|:--:|:--:|:--:|:--:|
| \(\overline{A}\overline{B}\) | ● | ● |   |   |
| \(\overline{A}CD\)          |   | ● | ● |   |
| \(\overline{B}CD\)          |   | ● |   | ● |

- **EPI**: \(m_1\)은 \(\overline{A}\overline{B}\)만, \(m_7\)은 \(\overline{A}CD\)만, \(m_{11}\)은 \(\overline{B}CD\)만 덮음 → **세 항 모두 EPI**

**(c) 최소식**
\[
\boxed{F=\overline{A}\overline{B}+\overline{A}CD+\overline{B}CD}
\]
추가 인수화: \(\overline{A}CD+\overline{B}CD=CD(\overline{A}+\overline{B})\).

> DC 덕분에 \(\overline{A}\overline{B}\)가 큰 블록으로 등장 → 리터럴 수 감소.

---

### 1.4 예제 B — 5변수 ISF(DC 활용과 페트릭 방법)
\[
F(W,X,Y,Z,T)=\sum m(1,3,5,7,17,19,21,23)+d(0,2,16,18)
\]
- 그레이코드 순서로 **\(WXYZ\)** 를 맵 축, \(T\)는 비트로 포함되어 있다고 생각하면, DC가 하위 블록을 키워 준다.

**핵심 단계**
- 결합: \(\mathcal{ON}\cup\mathcal{DC}\) 기반으로 대형 PI 생성(예: \(W=0,X=0\) 영역에서 \(YZ\) 자유 등)
- PI 차트 작성(열은 \(\mathcal{ON}\)만)
- EPI 취한 후 남는 열에 대해 **페트릭 방법** 적용

**페트릭(Petrick) 방법 개요**  
남은 열이 \(c_1,\dots,c_k\), 이를 덮는 PI 집합이 각 열마다 \(\{p_{i1},p_{i2},\dots\}\) 라면
\[
P=(p_{11}+p_{12}+\dots)\cdot(p_{21}+p_{22}+\dots)\cdots(p_{k1}+p_{k2}+\dots)
\]
를 전개한 뒤, 항(PI들의 곱) 중 **비용 최소**(항 개수/리터럴 수) 선택.  
곱의 중복/흡수 규칙으로 간소화 후 최종 선택.

---

### 1.5 복잡도·실무적 판단
- Q–M은 \(n\)이 커지면 **지수적**으로 비용 급증(NP-난해). 보통 **4~6변수**까지 수작업 또는 Q–M, 그 이상은 **Espresso** 같은 휴리스틱을 실무에서 사용.
- 그러나 **작은 블록의 최적 SOP**가 중요한 안전·성능 임계경로에서는 여전히 Q–M+Petrick이 유효.

---

## 2. 변수가 있는 맵(VEM, Variable–Entered Map)으로 간략화

### 2.1 개념
- 일반 K-map은 각 셀에 **0/1**을 기입한다. **VEM**은 셀에 **다른 변수/부울식**을 기입해, 축 변수를 **소거**하거나 **인수화**·**XOR 패턴**을 빠르게 드러낸다.
- 기준 변수 집합 \(\mathbf{X}\)를 맵 축, 나머지 \(\mathbf{Y}\)에 대한 **코팩터** \(F|_{\mathbf{X}=\mathbf{x}}\)를 셀 내용으로 쓴다.

### 2.2 2셀 묶음 규칙(축 변수 \(Z\))
\[
\underbrace{\overline{Z}P}_{\text{셀1}} + \underbrace{ZQ}_{\text{셀2}}
\]
- **동일식** \(P=Q\Rightarrow (\overline{Z}+Z)P=P\) → \(Z\) 소거(큰 묶음 유리)  
- **보수** \(Q=\overline{P}\Rightarrow \overline{Z}P+Z\overline{P}=Z\oplus P\) (XOR/ESOP 성분)  
- **흡수** \(\overline{Z}P + Z(P+Q)=P+ZQ\)

> “같은 식”을 축 방향으로 붙여 크게 묶고, 남는 XOR/합은 **인수화**로 수축하라.

---

### 2.3 예제 1 — 5변수에서 1변수 맵-내 삽입(기본 패턴)
\[
F(A,B,C,D,E):\ \text{축}=\{A,B,C,D\},\ \text{셀 내용}=E\ \text{또는}\ \overline{E}
\]
가정: \(B=0\)인 모든 셀에 \(E\), \(B=1\)인 모든 셀에 \(\overline{E}\).

- **상하/좌우 대형 묶음**에서 \(A,C,D\)가 소거  
- 결과:
\[
\boxed{F=\overline{B}E + B\overline{E}=B \odot E}\quad \text{(XNOR)}
\]
VEM이 **축 변수 소거**와 **XOR/XNOR 패턴**을 즉시 드러냄.

---

### 2.4 예제 2 — 보수 대칭 → XOR
인접 셀(축 \(A\))이 각각 \(P,\overline{P}\)를 담으면
\[
\overline{A}P + A\overline{P} = A\oplus P
\]
다른 묶음과 결합해  
\((A\oplus P)C+(A\oplus P)\overline{C}=(A\oplus P)\) 처럼 추가 소거 가능.

---

### 2.5 예제 3 — 인수화 가시화(4변수→3변수)
\[
F(A,B,C,D)=AC + AD + \overline{A}CE \quad (E\text{는 외부 변수})
\]
- \(\{A,C\}\) 축, \(D\)는 \(C\)에 합, \(A=0\) 행에는 \(CE\)
- 상하 묶음: \(\overline{A}(CE)+A(C+D) = (A+E)C + AD\)  
\[
\Rightarrow \boxed{F=A(C+D)+EC}
\]
리터럴/항 감소 확인.

---

### 2.6 VEM과 샤논 전개/ESOP
- **샤논 전개** \(F = ZF|_{Z=1} + \overline{Z}F|_{Z=0}\) 는 VEM의 기본 원리.  
- 보수 대칭이 자주 드러나면 **ESOP(Exclusive-OR Sum of Products)**가 자연스러워짐. SOP만 고집 말고 **XOR 게이트 사용**이 유리한 경우(면적/지연) 검토.

---

## 3. ISF + VEM: 실무 최적화와 안정성

1) **DC는 결합 전용, 커버 제외**: Q–M의 황금률  
2) **비용함수 명확화**: 항/리터럴/팬인/셀가중치(예: NOR3 불리) 등을 명시  
3) **VEM 축 선택**: 반복 패턴이 **세로/가로로 일치**하도록 축을 잡아 대형 소거 유도  
4) **XOR 패턴**: 보수 대칭은 **즉시 XOR**로 바꾸고, 나머지와 인수화  
5) **해저드**: 최소 커버는 글리치 위험. K-map/VEM에서 **중첩 커버(합의항)** 로 정적 해저드 완화  
6) **다중 출력 공유**: 공통 곱항/합항을 1단에서 생성해 공유(팬아웃 타이밍은 버퍼/재생성으로 조정)

---

## 4. 손으로 해보는 페트릭(Petrick) — 미니 예제

남은 열 \(c_1,c_2,c_3\)에 대해 가능한 PI 집합이
\[
c_1:\{P,Q\},\quad c_2:\{Q,R\},\quad c_3:\{P,R\}
\]
이면
\[
P=(P+Q)(Q+R)(P+R)
\]
전개/흡수로 간소화:
\[
\begin{aligned}
(P+Q)(Q+R) &= PQ + PR + Q^2 + QR \\
           &\Rightarrow PQ + PR + Q + QR \\
           &\Rightarrow Q + PR \quad (\text{흡수 } Q+QR=Q)
\end{aligned}
\]
이제 \((Q+PR)(P+R) = QP + QR + PRP + PRR\Rightarrow QP + QR + PR\).  
**후보 세트**: \(\{Q,P\},\ \{Q,R\},\ \{P,R\}\).  
비용함수(항수/리터럴 수)에 따라 택1.

---

## 5. 파이썬으로 Q–M(+Petrick) 구현 스니펫

> 교육·검증용 구현(작은 \(n\)에 적합).  
> 입력: 변수 개수 \(n\), \(\mathcal{ON}\) 리스트, \(\mathcal{DC}\) 리스트.  
> 출력: **최소 커버**(PI의 집합)와 **사람 읽기용** 식.

```python
from itertools import combinations, product
from collections import defaultdict

def bits(n, w):
    return format(n, '0{}b'.format(w))

def combine(a, b):
    diff = 0; pos = -1
    for i,(x,y) in enumerate(zip(a,b)):
        if x!=y:
            if x!='-' and y!='-':
                diff += 1; pos = i
            else:
                return None
    if diff==1:
        out = list(a); out[pos] = '-'
        return ''.join(out)
    return None

def all_cover(term, nums):
    # term like '10-1'; nums: list of integers
    w = len(term)
    for n in nums:
        s = bits(n, w)
        ok = True
        for t,c in zip(term, s):
            if t!='-' and t!=c: ok=False; break
        if ok: yield n

def qm_prime_implicants(nvar, on_set, dc_set):
    init = [bits(m, nvar) for m in sorted(set(on_set)|set(dc_set))]
    groups = defaultdict(list)
    for t in init:
        groups[t.count('1')].append(t)
    marked = set()
    next_terms = set()
    pis = set()
    while True:
        new_groups = defaultdict(list)
        used = set()
        keys = sorted(groups.keys())
        any_combined = False
        for i in range(len(keys)-1):
            for a in groups[keys[i]]:
                for b in groups[keys[i+1]]:
                    c = combine(a,b)
                    if c:
                        any_combined = True
                        used.add(a); used.add(b)
                        new_groups[c.count('1')].append(c)
        # collect PIs
        for g in groups.values():
            for t in g:
                if t not in used:
                    pis.add(t)
        if not any_combined: break
        # unique terms per group
        groups = defaultdict(list)
        seen = set()
        for g, arr in new_groups.items():
            for t in arr:
                if t not in seen:
                    seen.add(t); groups[g].append(t)
    # filter PIs that cover ON only (they can still use DC in coverage)
    return sorted(pis)

def covers(term, m):
    s = bits(m, len(term))
    return all((t=='-' or t==c) for t,c in zip(term, s))

def essential_and_petrick(nvar, on_set, pis):
    # PI chart
    cols = sorted(on_set)
    rows = pis
    cover_map = {r: set(m for m in cols if covers(r, m)) for r in rows}
    col2rows = {m: set(r for r in rows if m in cover_map[r]) for m in cols}
    # essential
    epi = set()
    uncovered = set(cols)
    for m in cols:
        if len(col2rows[m])==1:
            r = next(iter(col2rows[m]))
            epi.add(r)
    for r in epi:
        uncovered -= cover_map[r]
    # petrick for remaining
    if not uncovered:
        return sorted(epi)
    # symbolic product of sums
    sums = []
    for m in sorted(uncovered):
        sums.append(sorted(col2rows[m]))
    products = [set([r]) for r in sums[0]]
    for s in sums[1:]:
        newp = []
        for p in products:
            for r in s:
                newp.append(p|{r})
        # absorption by set inclusion
        minimal = []
        for p in newp:
            if not any(p2 <= p and p2 != p for p2 in newp):
                minimal.append(p)
        # remove supersets inside minimal too
        products = []
        for p in minimal:
            if not any(q < p for q in minimal):
                products.append(p)
    # choose best by (num_terms, total_literals)
    def cost(sel):
        k = len(sel)
        lits = 0
        for r in sel:
            lits += len([c for c in r if c!='-'])
        return (k, lits)
    best = min(products, key=cost)
    sol = sorted(epi | set(best))
    return sol

def literal_str(term, vars_):
    out = []
    for v,c in zip(vars_, term):
        if c=='1': out.append(v)
        elif c=='0': out.append(f'\\overline{{{v}}}')
    return ''.join(out) if out else '1'

def qm_minimize(nvar, on_set, dc_set, vars_):
    pis = qm_prime_implicants(nvar, on_set, dc_set)
    sel = essential_and_petrick(nvar, on_set, pis)
    expr = ' + '.join(literal_str(t, vars_) for t in sel)
    return sel, expr

# demo
if __name__ == "__main__":
    n = 4
    ON = [1,3,7,11]
    DC = [0,2]
    vars_ = ['A','B','C','D']
    sel, expr = qm_minimize(n, ON, DC, vars_)
    print("PIs used:", sel)
    print("F =", expr)  # 기대: \overline{A}\overline{B} + \overline{A}CD + \overline{B}CD
```

- 위 스니펫은 **소규모 문제**에 적합하며, 선택 기준은 (항 수, 총 리터럴 수) 순서로 최소화한다.  
- 더 큰 문제/다중 출력/셀 가중치는 별도 확장(예: NOR3 패널티, 팬인 상한 제약 등).

---

## 6. VEM을 코드로 체감 — 샤논 전개 기반 MUX 구조화

VEM에서 **축 변수 \(Z\)** 를 따라 인접 셀 내용이 \(P,Q\) 라면:
\[
\overline{Z}P + ZQ = \mathrm{MUX}(Z,\ Q,\ P)
\]
이는 바로 **2:1 MUX** 구조. 대형 묶음은 **MUX 트리**로 자연스럽게 치환된다.

**하드웨어 스케치(Verilog 예시)**

```verilog
// F = ~Z*P + Z*Q  → 2:1 MUX
assign F = Z ? Q : P;
```

ESOP/XOR가 드러나면 LUT 기반 FPGA에서는 **XOR 전용 LUT**(또는 carry-XOR)를 활용해 지연을 줄일 수 있다.

---

## 7. 해저드(글리치)와 합의항

최소 커버는 경로 지연 차로 **정적 해저드**를 유발하기 쉽다. 예:
\[
F=AB+\overline{A}C \quad (\text{$A$ 토글 시})
\]
- **합의항** \(+BC\) 추가로 중첩 커버를 만들어 글리치를 완화:
\[
F' = AB+\overline{A}C+BC
\]
VEM/K-map에서 **겹치는 큰 묶음**을 만들면 해저드에 안정적이다.

---

## 8. 다중 출력(Multi-output)과 공유

출력
\[
F_1=AB+AC+\overline{B}D,\qquad F_2=\overline{A}C+BD
\]
- Q–M(또는 Espresso)로 **공통 곱항**(예: \(AC\), \(BD\))을 1단에서 생성해 **공유**하면 총 리터럴/게이트 수 감소  
- 공유 노드의 **팬아웃**이 크면 지연 증가 가능 → **버퍼 삽입** 또는 **부분 재생성** 트레이드오프

---

## 9. 확장 예제 — ISF×VEM 혼합 최적화 워크플로

1) **ISF 파악**: \(\mathcal{ON},\mathcal{DC}\) 분리  
2) **VEM 축 선택**: 반복 패턴/보수 대칭이 잘 보이도록 축 변수 고정  
3) **VEM 묶음**: 축 변수 소거 → 큰 인수화/ESOP 성분 도출  
4) **Q–M 보조**: 남는 부분을 Q–M으로 마무리, 페트릭으로 정확 최소화  
5) **해저드 커버**: 최소식에 합의항 추가(필요 시)  
6) **구현 맵핑**: NAND/NOR-only, LUT k-제약(k-LUT), 팬인 상한 고려

---

## 10. 검증 팁 — 등가성/커버리지

- **진리표 검증**: 파이썬으로 두 식의 모든 입력 조합을 평가해 동일성 확인  
- **포멀**: SAT/SMT 등가성 체크(규모가 커질 때)  
- **타이밍**: 합성·배치 후 SDF 백어노테이션 파형으로 글리치/마진 확인

---

## 11. 연습문제

1) **ISF–Q–M**  
   \(F(A,B,C,D)=\sum m(0,2,5,7,9,11)+d(1,3)\).  
   - (a) \(I\cup D\) 로 결합표를 만들고 PI를 도출하라.  
   - (b) **PI 차트**(열은 \(I\)만)에서 EPI를 고르라.  
   - (c) 잔여 커버는 **페트릭 방법**으로 최소 커버를 구하라(비용: 항수→리터럴수).

2) **VEM(5변수)**  
   \(\{A,B,C,D\}\) 축, 셀 내용은 \(E\).  
   - \(B=0\) 행의 어떤 열이 \(E\), 바로 오른쪽 열이 \(\overline{E}\).  
   - (a) 이 두 열을 가로로 묶었을 때의 표현을 유도하라.  
   - (b) 상하 열과 결합하여 \(A\)까지 소거하는 과정을 보이고 최종 식을 쓰라.

3) **VEM 인수화**  
   \(F=\overline{A}X + AX + AY\) (여기서 \(X,Y\)는 축 밖의 변수식).  
   - VEM에서 세 셀 묶음으로 **\(X+(AY)\)** 를 만들고,  
     \(X+AY=(X+A)(X+Y)\) 를 이용해 **선호 구현 형태** 2가지를 제시하라(예: AND-OR, MUX).

---

## 12. 포켓 요약
- **ISF 최소화**: 결합에는 DC 사용, 커버 판단은 ON만. EPI 먼저, 잔여는 **페트릭**.  
- **VEM 핵심**: **동일식 묶어 축 소거**, **보수 대칭은 XOR**. 큰 인수화는 VEM이 빠르다.  
- **실무**: 작은 블록은 Q–M+Petrick, 큰 블록은 Espresso. 해저드는 합의항/중첩으로 완화.  
- **구현**: XOR/ESOP, MUX(샤논), NAND/NOR-only, LUT k-제약과 팬인 상한을 조기 반영.