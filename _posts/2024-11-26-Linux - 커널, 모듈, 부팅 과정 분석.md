---
layout: post
title: Linux - 커널, 모듈, 부팅 과정 분석
date: 2024-11-26 19:20:23 +0900
category: Linux
---
# 커널·모듈·부팅 과정 분석

## 전체 부팅 과정 개요 (UEFI/BIOS 공통 모델)

리눅스 시스템의 부팅 과정은 여러 단계를 거쳐 진행됩니다. 각 단계에서의 전이 지점을 이해하면 문제 발생 시 효과적으로 진단할 수 있습니다:

1. **펌웨어 단계 (BIOS/UEFI)**
   - 하드웨어 초기화 (메모리, CPU, 주변 장치)
   - 부팅 장치 결정 및 검색
   - UEFI 환경: ESP(EFI System Partition)의 `EFI/BOOT/BOOTX64.EFI` 또는 벤더별 엔트리 실행

2. **부트로더 단계 (GRUB2)**
   - 커널 이미지(`vmlinuz`)와 초기 램디스크(`initrd`/`initramfs`)를 메모리에 로드
   - 커널 명령줄(kernel cmdline) 파라미터 전달

3. **커널 초기화 단계**
   - 기본 시스템 초기화 (메모리 매핑, 스케줄러, 드라이버)
   - initramfs로 진입하여 스토리지(RAID/LUKS/LVM) 및 파일시스템 활성화
   - 루트 파일시스템 마운트 후 init 프로세스 실행

4. **사용자 공간 초기화 (systemd)**
   - 타겟 및 서비스 의존성 해결
   - 네트워킹, 로그인 TTY, 그래픽 디스플레이 매니저 기동

5. **로그인 및 사용자 세션**
   - CLI 또는 GUI 로그인 프롬프트 제공
   - 런레벨/타겟에 따른 서비스 실행 완료

부팅 문제 발생 시 각 전이 경계(펌웨어→부트로더, 부트로더→커널, 커널→initramfs, initramfs→루트fs, 루트fs→systemd)에서의 증거(화면 출력, LED 상태, 로그, 콘솔 메시지)를 체계적으로 수집해야 합니다.

---

## /boot 디렉토리와 GRUB2 구조 이해

### /boot 디렉토리 구성 요소

| 파일/디렉토리 | 역할 |
|---|---|
| `vmlinuz-<version>` | 압축된 커널 이미지 (실행 진입점 포함) |
| `initrd.img-<version>` 또는 `initramfs-<version>.img` | 루트 마운트 전 필요한 초기 사용자 공간 |
| `System.map-<version>` | 커널 심볼 주소 테이블 (디버깅/프로파일링용) |
| `config-<version>` | 커널 빌드 설정 (Kconfig 결과) |
| `grub/` | GRUB 모듈, 테마, 설정 파일 |
| (UEFI) `/boot/efi/EFI/<distro>/*.efi` | EFI 실행 바이너리 파일 |

### GRUB 설정 파일 관리

GRUB 설정은 다음 파일들을 통해 관리됩니다:

- **수동 편집하지 않음**: `/boot/grub/grub.cfg`
- **편집 대상**: `/etc/default/grub`, `/etc/grub.d/*` 디렉토리
- **변경 사항 반영**:

```bash
# Debian/Ubuntu 계열
sudo nano /etc/default/grub
sudo update-grub    # /boot/grub/grub.cfg 재생성

# RHEL/Fedora 계열
sudo grub2-mkconfig -o /boot/grub2/grub.cfg
# UEFI 시스템의 경우 경로가 다를 수 있음: /boot/efi/EFI/<vendor>/grub.cfg
```

### /etc/default/grub 주요 설정 예시

```bash
GRUB_DEFAULT=0
GRUB_TIMEOUT=5
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
# 서버 환경에서는 "quiet" 제거, "loglevel=7 systemd.log_level=debug"로 설정 권장
```

일반적인 원칙은 GUI 워크스테이션에는 `quiet splash`를, 서버나 디버깅 환경에서는 조용한 모드를 제거하고 로그 레벨을 높이는 것입니다.

### UEFI 부트 엔트리 관리

```bash
sudo efibootmgr               # 현재 부트 엔트리 목록 확인
sudo efibootmgr -o 0003,0001  # 부트 순서 재정의
```

---

## 커널 이미지와 initramfs: 루트 마운트 전의 "작전 기지"

### initrd/initramfs의 필요성

initramfs는 루트 파티션 접근에 필요한 모듈과 도구(SCSI/NVMe/LVM/RAID/LUKS/네트워크 루트 등)를 메모리에 미리 준비합니다. 커널은 initramfs의 `/init` 스크립트를 실행하여 LUKS 해제, LVM 활성화, 루트 파일시스템 마운트를 수행한 후 `switch_root`로 실제 루트로 전환합니다.

### initramfs 생성 및 갱신

```bash
# Debian/Ubuntu (update-initramfs 사용)
sudo update-initramfs -c -k 6.8.0-xx    # 특정 커널용 새 initramfs 생성
sudo update-initramfs -u -k all         # 모든 커널용 initramfs 업데이트

# RHEL/Fedora 계열 (dracut 사용)
sudo dracut -f /boot/initramfs-$(uname -r).img $(uname -r)
```

### initramfs 내용 확인

```bash
# 임시 디렉토리에서 initramfs 내용 확인
mkdir /tmp/ir && cd /tmp/ir

# Ubuntu 방식
lsinitramfs /boot/initrd.img-$(uname -r) | head -50

# 또는 압축 해제하여 내용 확인
mkdir /tmp/ir2 && cd /tmp/ir2
zcat /boot/initramfs-$(uname -r).img | cpio -idmv
```

확인해야 할 주요 구성 요소:
- `/init` 스크립트의 실행 흐름
- 필요한 드라이버 모듈과 후킹 스크립트 포함 여부

---

## 커널 명령줄 파라미터: 한 줄로 부팅 특성 변경

### 현재 커널 명령줄 확인

```bash
cat /proc/cmdline
```

### 자주 사용하는 커널 파라미터

| 파라미터 | 효과/용도 |
|---|---|
| `root=/dev/…`/`UUID=` | 루트 파일시스템 위치 지정 |
| `ro`/`rw` | 루트 마운트 초기 상태 (읽기전용 권장) |
| `quiet`, `splash` | 부팅 메시지 억제/스플래시 화면 |
| `systemd.unit=rescue.target` | 구조 모드로 부팅 (최소 서비스) |
| `emergency` 또는 `emergency.target` | 비상 쉘 모드 (루트fs 읽기전용) |
| `nomodeset` | 초기 KMS 비활성화 (그래픽 문제 회피) |
| `ipv6.disable=1` | IPv6 임시 비활성화 |
| `selinux=0`/`enforcing=0` | SELinux 비활성화/허용 모드 (진단용) |
| `rd.luks.uuid=` / `rd.lvm.vg=` | dracut 기반에서 LUKS/LVM 지정 |
| `crashkernel=...` | kdump 메모리 예약 (커널 크래시 덤프용) |
| `intel_iommu=on`/`amd_iommu=on` | IOMMU/PCIe 패스스루 활성화 |

복구 시에는 `systemd.unit=emergency.target`와 함께 `rootpw`(배포판 옵션)를 사용하여 진입한 후 `/etc/fstab`, `/etc/crypttab`, 드라이버, initramfs를 점검하고 재생성합니다.

---

## 커널 모듈 관리: 로딩, 블랙리스트, DKMS

### 기본 모듈 조작 명령어

```bash
lsmod                         # 로드된 모듈 목록
modinfo e1000e                # 모듈 메타데이터 및 의존성 확인
sudo modprobe e1000e          # 모듈 로드 (의존성 포함)
sudo modprobe -r e1000e       # 모듈 제거 (사용 중이면 실패)
```

모듈 파라미터는 `/sys/module/<module>/parameters/` 디렉토리에서 확인하고 런타임에 변경할 수 있습니다.

### 영구적 모듈 로드 및 블랙리스트 설정

```bash
# 항상 로드할 모듈 설정
echo e1000e | sudo tee /etc/modules-load.d/net.conf

# 모듈 블랙리스트 설정 (충돌 드라이버 차단)
cat <<'EOF' | sudo tee /etc/modprobe.d/blacklist-legacy.conf
blacklist nouveau
options r8169 aspm=0
EOF

# 변경 사항 반영 (재부팅 또는 initramfs 재생성 필요)
sudo update-initramfs -u
```

### DKMS: 커널 업데이트와 함께 모듈 재빌드

DKMS(Dynamic Kernel Module Support)는 커널 업데이트 시 외부 모듈을 자동으로 재컴파일합니다:

```bash
# DKMS 상태 확인
dkms status

# 수동 재빌드 및 설치
sudo dkms build -m <module> -v <version>
sudo dkms install -m <module> -v <version>
```

DKMS는 "커널 업데이트 후 Wi-Fi 작동 안 함" 같은 문제를 구조적으로 방지합니다.

---

## 커널 메시지 및 로그 분석

### 즉시 확인 방법

```bash
# dmesg를 사용한 에러 메시지 필터링
dmesg -T | egrep -i 'error|fail|timeout|segfault'

# systemd 저널을 통한 커널 로그 확인
journalctl -k -b            # 현재 부팅 커널 로그
journalctl -k -b -1         # 이전 부팅 커널 로그
```

### 부팅 멈춤 시 로그 수집 팁

부팅 옵션에 다음 파라미터들을 추가하여 디버깅 정보를 수집할 수 있습니다:

- `loglevel=7`
- `systemd.log_level=debug`
- `systemd.log_target=kmsg`

직렬 콘솔 사용 (서버/VM 환경):
```bash
# KVM 게스트의 직렬 콘솔 설정 예시
GRUB_CMDLINE_LINUX_DEFAULT="console=ttyS0,115200n8 loglevel=7"
```

---

## initramfs 단계 디버깅: 루트 마운트 실패 문제

증상: "A start job is running for /dev/… (1min 30s)", "Cannot find root device"

### 진단 순서

1. `cat /proc/cmdline`에서 `root=UUID=…` 설정이 올바른지 확인
2. `lsinitramfs | grep dm-crypt|lvm|raid`로 필요한 후킹 포함 여부 확인
3. 암호화/LVM 환경에서 비밀번호 프롬프트와 키맵/콘솔 설정 확인
4. `dmesg`에서 스토리지 드라이버 타임아웃 또는 Probing 실패 메시지 확인

### initramfs 재생성

```bash
# Ubuntu
sudo update-initramfs -u -k all

# Fedora/RHEL
sudo dracut -f
```

### 응급 쉘에서의 수동 루트 전환 (개념적 예시)

initramfs 쉘에서 다음과 같은 단계로 수동 복구를 시도할 수 있습니다:

```bash
# initramfs 쉘 환경 가정
/sbin/modprobe dm-crypt
/sbin/cryptsetup open /dev/sda2 cryptroot
vgchange -ay
mount -o ro /dev/mapper/vg0-root /new_root
exec switch_root /new_root /sbin/init
```

---

## 커널 패닉 및 OOPS 대응: kdump, kexec, SysRq

### kdump 설정 개요

1. 커널 명령줄에 `crashkernel=auto` 또는 구체적인 크기 파라미터 추가
2. kdump 서비스 활성화 → 커널 패닉 시 별도 커널로 부팅하여 메모리 덤프 저장

```bash
# RHEL/Fedora 예시
sudo systemctl enable --now kdump
sudo kdumpctl status
```

덤프 파일은 `/var/crash/<date>/vmcore` 등에 저장되며, `crash` 도구로 분석할 수 있습니다.

### kexec: 재부팅 없이 커널 전환

```bash
sudo kexec -l /boot/vmlinuz-<new> --initrd=/boot/initramfs-<new>.img --command-line="$(cat /proc/cmdline)"
sudo systemctl kexec   # 새 커널로 즉시 전환 (주의 필요)
```

### Magic SysRq (시스템 정지 시 최후의 수단)

```bash
# SysRq 활성화 상태 확인
cat /proc/sys/kernel/sysrq

# 긴급 시퀀스 (키보드): Alt+SysRq+REISUB
# R: 키보드 RAW 모드, E: 프로세스 종료, I: 강제 종료
# S: 디스크 동기화, U: 읽기전용 재마운트, B: 재부팅
```

---

## 보안 및 무결성: Secure Boot, 모듈 서명, MOK

### Secure Boot 환경에서 외부 모듈 사용

Secure Boot가 활성화된 환경에서는 서명되지 않은 모듈이 거부됩니다. MOK(Machine Owner Key) 등록이 필요합니다:

```bash
sudo mokutil --import my_pubkey.der
# 재부팅 후 MOK 관리 화면에서 키 등록
```

DKMS 모듈도 사전 서명 또는 MOK 등록 후 서명 절차가 필요합니다.

### 커널 무결성 및 보안 정책

- IMA/evm, dm-verity, lockdown 모드(`lockdown=integrity`/`confidentiality`)
- SELinux(부팅 시 `enforcing=1`), AppArmor 강화

---

## 특수 아키텍처 고려사항: Device Tree 및 UEFI

- x86 시스템: ACPI를 사용한 하드웨어 기술
- ARM 시스템: Device Tree Blob(DTB)를 사용한 하드웨어 기술
- 부트로더(U-Boot)가 커널, initramfs, DTB를 전달
- 최근에는 ARM도 UEFI + GRUB로 통합되는 추세

DTB 교체나 수정 시 커널과의 정합성을 반드시 확인해야 합니다.

---

## 실전 시나리오 분석

### 시나리오 A: 커널 업데이트 후 네트워크 드라이버 작동 중지

1. `dkms status`로 외부 드라이버 빌드 상태 확인
2. 빌드되지 않은 경우 `sudo dkms autoinstall` 또는 패키지 재설치
3. `journalctl -k | grep -i firmware`로 펌웨어 요구사항 확인 → `linux-firmware` 패키지 업데이트

### 시나리오 B: GRUB에서 부팅 멈춤 (Rescue 모드 필요)

1. 라이브 USB로 부팅 → 루트 파티션 마운트
2. chroot 환경 준비 → GRUB 재설치 및 설정 업데이트

```bash
# chroot 복구 템플릿
sudo mount /dev/mapper/vg0-root /mnt
sudo mount /dev/sda1 /mnt/boot
sudo mount -t proc /proc /mnt/proc
sudo mount -t sysfs /sys /mnt/sys
sudo mount --bind /dev /mnt/dev
sudo chroot /mnt
grub-install /dev/sda
update-grub
exit
sudo reboot
```

### 시나리오 C: LUKS/LVM 루트에서 비밀번호 프롬프트 표시 안 됨

1. `lsinitramfs`로 `cryptsetup`/`lvm` 포함 여부 확인
2. 키맵/콘솔 부트 옵션(`vconsole.keymap=`/`rd.vconsole.keymap=`) 확인
3. `dracut -f` 또는 `update-initramfs -u`로 initramfs 재생성

### 시나리오 D: 그래픽 블랙스크린 문제

1. `nomodeset` 파라미터로 임시 부팅 → GUI 진입 후 드라이버/펌웨어 재설정
2. 커널 로그에서 `gpu hang`, `drm` 에러 메시지 확인

---

## 커널 빌드 및 최적화 (고급)

패키지 커널로 충분하지만, 특정 패치나 옵션 검증을 위한 최소 절차:

```bash
# Debian/Ubuntu 환경 예시
sudo apt build-dep linux
git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
cd linux
make oldconfig              # 현재 설정 기반 구성
# 또는 make menuconfig로 옵션 조정
make -j$(nproc) bindeb-pkg  # deb 패키지 생성
sudo dpkg -i ../linux-image-*.deb ../linux-headers-*.deb
sudo update-grub && sudo reboot
```

새 커널 부팅 실패에 대비해 GRUB에서 이전 커널을 항상 유지하는 것이 좋습니다.

---

## sysctl 및 /etc/sysctl.d 설정 관리

### 즉시 적용

```bash
sudo sysctl net.ipv4.ip_forward=1
sudo sysctl vm.swappiness=10
```

### 영구적 설정 (drop-in 파일 권장)

```bash
# /etc/sysctl.d/99-tuning.conf 파일 생성
echo "net.core.somaxconn = 4096
fs.inotify.max_user_watches = 1048576
vm.swappiness = 10" | sudo tee /etc/sysctl.d/99-tuning.conf

# 모든 설정 적용
sudo sysctl --system
```

---

## 실전 예제 모음

### 부팅 로그 상세화를 통한 원인 분석

```bash
# /etc/default/grub 수정
GRUB_CMDLINE_LINUX_DEFAULT="loglevel=7 systemd.log_level=debug"

sudo update-grub
```

### 특정 모듈 블랙리스트 및 대체 모듈 파라미터 설정

```bash
# /etc/modprobe.d/net-tuning.conf 생성
echo "blacklist r8169
options e1000e InterruptThrottleRate=1,1,1" | sudo tee /etc/modprobe.d/net-tuning.conf

sudo update-initramfs -u
sudo reboot
```

### kdump 활성화 (RHEL/Fedora 예시)

```bash
# 커널 명령줄에 crashkernel=auto 추가 후
sudo grub2-mkconfig -o /boot/grub2/grub.cfg
sudo systemctl enable --now kdump
sudo kdumpctl status
```

### 헤드리스 서버 부팅 로그 수집을 위한 직렬 콘솔 설정

```bash
# /etc/default/grub 수정
GRUB_CMDLINE_LINUX_DEFAULT="console=ttyS0,115200n8 loglevel=7"

sudo update-grub
```

---

## 핵심 명령어 및 파일 요약

| 도구/파일 | 용도 |
|---|---|
| `efibootmgr` | UEFI 부트 엔트리 관리 |
| `update-grub` / `grub2-mkconfig` | GRUB 설정 파일 생성 |
| `/etc/default/grub` | GRUB 템플릿 및 커널 명령줄 설정 |
| `update-initramfs` / `dracut` | initramfs 생성 및 갱신 |
| `lsinitramfs` / `cpio` | initramfs 내용 확인 |
| `lsmod`/`modprobe`/`modinfo`/`rmmod` | 커널 모듈 관리 |
| `dkms` | 외부 모듈 커널 버전 호환성 관리 |
| `dmesg` / `journalctl -k` | 커널 메시지 확인 |
| `sysctl` / `/etc/sysctl.d/*.conf` | 커널 런타임 파라미터 설정 |
| `kdumpctl` / `crash` | 커널 크래시 덤프 관리 및 분석 |
| `kexec` | 재부팅 없이 커널 전환 |

---

## 빠른 복구 루틴 (현장용 참고)

1. GRUB 메뉴에서 **이전 커널** 또는 **고급 옵션** 선택
2. 실패 원인 가설화: (a) GRUB (b) initramfs (c) 드라이버 (d) 루트 파일시스템 (e) systemd
3. 커널 명령줄 조정: `systemd.unit=rescue.target loglevel=7`
4. 네트워크/디스크 모듈 확인: `lsmod`, `modprobe`
5. initramfs 재생성: `update-initramfs -u`/`dracut -f`
6. DKMS 모듈 재빌드: `dkms autoinstall`
7. `journalctl -b -1`로 직전 부팅 실패 로그 확인
8. 최후의 방법: 라이브 미디어 → chroot → `grub-install`, `update-grub`, 루트 파일시스템 점검

---

## 결론

리눅스 시스템의 부팅 과정은 여러 단계의 연쇄적 과정으로 이해해야 합니다. 각 단계에서의 전이 지점을 명확히 파악하면 문제 발생 시 효과적으로 진단하고 해결할 수 있습니다.

운영 환경에서는 조용한 부팅 모드를 제거하고, 적절한 로그 레벨 설정, 직렬 콘솔 구성, kdump 설정 등을 통해 시스템 상태를 지속적으로 모니터링할 수 있어야 합니다. 이는 문제 발생 시 신속한 대응과 근본 원인 분석에 필수적입니다.

커널 모듈, 펌웨어, initramfs, GRUB 설정 파일의 정합성 관리와 DKMS 자동화는 "커널 업데이트 공포증"을 해소하고 시스템 안정성을 유지하는 핵심 요소입니다. 이러한 체계적인 관리 방식을 통해 예측 가능한 시스템 운영이 가능해집니다.

본 문서에서 제시한 템플릿, 루틴, 실전 예제들을 참고하여 부팅 장애의 평균 복구 시간(MTTR)을 크게 줄일 수 있습니다. 가장 중요한 것은 체계적인 접근 방식과 예방적 유지보수 습관을 개발하는 것입니다. 시스템의 부팅 과정을 깊이 이해하고 문제 해결 능력을 갖추면, 복잡한 환경에서도 안정적인 리눅스 시스템 운영이 가능해질 것입니다.