---
layout: post
title: Linux - 네트워크 디버깅과 방화벽 설정
date: 2024-11-16 19:20:23 +0900
category: Linux
---
# 네트워크 디버깅과 방화벽 설정

## 전체 진단 개요: 5분 트리아지에서 심층 분석까지

네트워크 문제 해결은 체계적인 접근이 필요합니다. 다음과 같은 계층별 접근법을 권장합니다:

1. **링크/주소 계층**: 링크 상태, IPv4/IPv6 주소, 게이트웨이 확인
2. **L3 경로 계층**: 라우팅, ARP/ND(Neighbor Discovery) 테이블, 로컬 vs 원격 통신 확인
3. **L4 소켓 계층**: LISTEN/ESTABLISHED 상태, 바인딩 주소(0.0.0.0 vs 127.0.0.1) 확인
4. **방화벽/NAT 계층**: 호스트 방화벽, 클라우드 보안 그룹, 컨테이체인 체인 확인
5. **애플리케이션 계층**: HTTP/TLS/DNS 지연, MTU/MSS 설정, 큐 관리 및 혼잡 제어

---

## 기본 건강검진: 필수 진단 명령어

문제 발생 시 먼저 실행해야 할 기본 진단 명령어입니다:

```bash
ip -br a              # 인터페이스와 IP 주소를 간결하게 표시
ip r                  # 라우팅 테이블 확인 (기본 게이트웨이 포함)
ping -c 3 8.8.8.8     # 외부 네트워크 ICMP 왕복 지연 테스트
ping -c 3 $(ip r | awk '/default/ {print $3}')  # 게이트웨이 통신 테스트
resolvectl status || cat /etc/resolv.conf       # DNS 리졸버 설정 확인
ss -tuln              # 열린 포트와 서비스 확인
sudo ss -ant state established '( sport = :22 )' # SSH 세션 상태 확인 예시
sudo traceroute -n 1.1.1.1   # 경로 단절 위치 파악
```

---

## 계층별 상세 디버깅 플레이북

### 링크/주소 계층 진단

```bash
ip link show
ip -br a
sudo ethtool eth0             # 링크 속도, 듀플렉스, 자동협상 상태 확인
journalctl -k | grep -i link  # 커널 로그에서 링크 상태 이벤트 확인
```

**주요 포인트**:
- RX/TX 드롭 증가 시: 케이블 문제, 듀플렉스 불일치, 드라이버 문제 확인
- IPv6 진단: `ip -6 r`, `ping6 -c 3 2606:4700:4700::1111` 명령 사용

### 라우팅/ARP/ND 계층 진단

```bash
ip r get 8.8.8.8
ip neigh
arp -n                     # (net-tools 패키지 필요)
```

**주요 포인트**:
- 게이트웨이 미설정 시: `ip r add default via 192.168.1.1 dev eth0` 명령으로 추가
- ARP 불일치 시: 동일 IP를 여러 MAC이 응답하는 경우 `ip neigh flush all`로 테이블 초기화 후 재학습

### DNS 계층 진단

```bash
dig +short example.com
dig @1.1.1.1 example.com
getent hosts example.com   # nsswitch.conf 설정 순서로 확인
```

**주요 포인트**:
- DNS 응답이 느린 경우: ndots, timeout 설정, split-DNS, DoT/프록시 개입 점검

### 소켓/서비스 계층 진단

```bash
ss -tulnp | grep ':80\>'               # 80/TCP 포트 리스닝 상태 및 프로세스 확인
sudo systemctl status nginx
sudo lsof -iTCP:443 -sTCP:LISTEN -P -n
```

**주요 포인트**:
- 127.0.0.1에만 바인딩되어 외부 접속이 불가능한 경우: `listen 0.0.0.0:80`으로 설정 변경 필요

### 경로 추적 및 품질 진단

```bash
sudo traceroute -n 8.8.8.8
mtr -rwzbc 200 8.8.8.8        # mtr 패키지 설치 필요
```

**주요 포인트**:
- 특정 홉 이후 패킷 손실/지연 발생 시: 경계 라우터나 업링크 문제 가능성, ISP에 문의할 근거 확보

### HTTP/TLS 애플리케이션 계층 진단

```bash
curl -I https://example.com
curl -v https://example.com --resolve example.com:443:203.0.113.10
openssl s_client -connect example.com:443 -servername example.com < /dev/null
```

**주요 포인트**:
- SNI(Server Name Indication) 미설정으로 인한 인증서 불일치 시: `--resolve` 옵션으로 특정 IP 직접 지정 테스트

### 포트 개방 및 스캔

```bash
nc -vz example.com 443
sudo nmap -sS -T4 -p 1-1024 192.168.0.10
```

**주요 포인트**:
- 외부에서 포트가 닫혀 있는 경우: 호스트 방화벽 → 클라우드 보안 그룹 → NAT 포워딩 순서로 점검

### 대역폭 및 지속 트래픽 테스트

```bash
iperf3 -s                       # 서버 모드 실행
iperf3 -c server -t 15 -R       # 클라이언트 모드 (역방향 테스트)
```

**주요 포인트**:
- 비정상적으로 낮은 대역폭 시: PMTU, 트래픽 셰이핑, Qdisc, CPU softirq, offload 옵션(ethtool) 점검

---

## MTU/PMTU/MSS 문제 진단

증상: HTTPS만 느리거나 끊김, VPN 구간에서만 실패, ICMP 차단 환경에서 패킷 분할 실패 등

```bash
# DF(Don't Fragment) 비트 설정으로 PMTU 확인
ping -M do -s 1472 8.8.8.8   # 1500 MTU 경로 테스트 (IPv4: 20바이트 IP 헤더 + 8바이트 ICMP 헤더)
ping -M do -s 8972 <peer>    # 점프스위치/Jumbo MTU 테스트
```

**해결 방법**:
- 터널/VPN 장비 MTU 축소: 예) 1500 → 1400
- 서버에서 MSS(Maximum Segment Size) 클램핑으로 SYN 패킷 시 MSS 제한

```bash
# iptables를 이용한 FORWARD 체인에서 MSS 클램핑
sudo iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN \
  -j TCPMSS --clamp-mss-to-pmtu
```

**nftables 버전**:
```bash
sudo nft add table ip mangle
sudo nft add chain ip mangle forward { type filter hook forward priority -150 \; }
sudo nft add rule ip mangle forward tcp flags syn tcp option maxseg size set clamp-to-pmtu
```

---

## 패킷 캡처를 통한 확정적 진단(tcpdump/tshark)

### 최소 재현 패킷 캡처

```bash
sudo tcpdump -i eth0 -w repro.pcap 'host 203.0.113.10 and (port 80 or port 443)'
```

### 커널 드롭 및 재전송 분석

```bash
sudo tcpdump -i eth0 -vvv 'tcp[tcpflags] & (tcp-syn|tcp-fin|tcp-rst) != 0'
tshark -r repro.pcap -z conv,tcp -q
```

### SYN은 오는데 SYN/ACK가 없는 경우

- **서버 방화벽** 차단 또는 **리스닝 포트 미기동** 확인: `ss -tuln`, `journalctl -u 서비스` 재확인

### TLS 핸드셰이크 중단

- MTU/패킷 분할/중간 장비 DPI(Deep Packet Inspection) 의심 → MSS 클램핑/PMTU 테스트 진행

---

## 연결 상태와 NAT/세션 테이블(conntrack)

```bash
sudo conntrack -L | wc -l
sudo conntrack -S           # 세션 통계
sudo conntrack -L -p tcp --dport 443 | head
```

**주요 포인트**:
- 대량 세션 환경: `net.netfilter.nf_conntrack_max` 값 상향, 해시 버킷 조정
- 세션 급증/타임아웃 문제: 서비스별 idle timeout 조정(로드밸런서/방화벽/프록시)

---

## 방화벽 실전: UFW, firewalld, nftables

### UFW (간편함, Ubuntu 친화적)

```bash
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow 22/tcp
sudo ufw allow 80,443/tcp
sudo ufw enable
sudo ufw status verbose
sudo ufw delete allow 22/tcp
```

**특정 대역만 허용**:
```bash
sudo ufw allow from 203.0.113.0/24 to any port 22 proto tcp
```

**로깅 활성화**:
```bash
sudo ufw logging on
```

### firewalld (동적 관리, RHEL/Fedora 계열)

```bash
sudo systemctl enable --now firewalld
sudo firewall-cmd --get-active-zones
sudo firewall-cmd --zone=public --add-service=http --permanent
sudo firewall-cmd --add-port=8443/tcp --permanent
sudo firewall-cmd --reload
sudo firewall-cmd --zone=public --list-all
```

**소스 대역 제한**:
```bash
sudo firewall-cmd --zone=trusted --add-source=10.10.0.0/16 --permanent
sudo firewall-cmd --reload
```

### nftables (현대 리눅스의 기본 방화벽 백엔드)

**기본 테이블 및 체인 생성**:
```bash
sudo nft add table inet filter
sudo nft add chain inet filter input { type filter hook input priority 0 \; policy drop \; }
sudo nft add chain inet filter forward { type filter hook forward priority 0 \; policy drop \; }
sudo nft add chain inet filter output { type filter hook output priority 0 \; policy accept \; }
```

**기본 허용 규칙 설정**:
```bash
# 로컬 루프백 인터페이스 허용
sudo nft add rule inet filter input iif lo accept

# 기존 연결 및 관련 연결 허용
sudo nft add rule inet filter input ct state established,related accept

# SSH, HTTP, HTTPS 포트 허용
sudo nft add rule inet filter input tcp dport {22,80,443} accept

# ICMP 프로토콜 허용 (합리적 범위)
sudo nft add rule inet filter input ip protocol icmp accept
sudo nft add rule inet filter input ip6 nexthdr icmpv6 accept

# 로깅 규칙 (속도 제한 적용)
sudo nft add rule inet filter input limit rate 5/second log prefix "NFT IN: " flags all counter
```

**규칙 저장 및 영구화**:
```bash
sudo sh -c 'nft list ruleset > /etc/nftables.conf'
sudo systemctl enable --now nftables
```

### DNAT/포트 포워딩 설정 (예: 80번 포트를 내부 10.0.0.10로 전달)

```bash
sudo nft add table ip nat
sudo nft add chain ip nat prerouting { type nat hook prerouting priority -100 \; }
sudo nft add chain ip nat postrouting { type nat hook postrouting priority 100 \; }
sudo nft add rule ip nat prerouting tcp dport 80 dnat to 10.0.0.10:80
sudo nft add rule ip nat postrouting oif eth0 masquerade
```

---

## iptables 빠른 참고 (레거시 호환)

```bash
sudo iptables -P INPUT DROP
sudo iptables -A INPUT -i lo -j ACCEPT
sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
sudo iptables -A INPUT -p tcp -m multiport --dports 22,80,443 -j ACCEPT
sudo iptables -A INPUT -p icmp -j ACCEPT
sudo iptables -A INPUT -m limit --limit 5/second -j LOG --log-prefix "IPT IN: "
```

**규칙 저장** (배포판별 차이 있음):
```bash
iptables-save > /etc/iptables/rules.v4
```

> 현대 커널은 내부적으로 **nftables 백엔드**(iptables-nft)를 사용할 수 있습니다. 혼용을 피하고 한 체계로 통일하는 것이 좋습니다.

---

## 환경별 특별 고려사항 (클라우드/컨테이너/SELinux)

- **클라우드 환경**: 호스트 방화벽 외에도 **보안 그룹(SG)**, **네트워크 ACL(NACL)**이 우선 차단할 수 있습니다. 퍼블릭 로드밸런서 뒤에 있는 경우 **타겟 그룹 헬스 체크** 상태도 확인해야 합니다.
- **Docker/Podman 환경**: 컨테이너 데몬이 자체 체인(`DOCKER`)을 설치하여 NAT/FORWARD 규칙을 변경합니다. 커스텀 방화벽과 충돌 시 **브리지/포워딩** 정책을 명확히 설정해야 합니다.
- **SELinux/AppArmor**: 네트워크 바인딩/리스닝을 보안 정책이 차단할 수 있습니다. `audit2why`, `semanage port` 등의 도구로 컨텍스트를 확인하고 조정할 수 있습니다.

---

## 시스템 튜닝 (혼잡 제어, 지연 최소화, 대규모 연결 관리)

```bash
# /etc/sysctl.d/99-net.conf 예시
net.core.somaxconn = 4096
net.ipv4.tcp_max_syn_backlog = 4096
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_syncookies = 1
net.ipv4.ip_local_port_range = 1024 65000
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.ipv4.tcp_rmem = 4096 87380 134217728
net.ipv4.tcp_wmem = 4096 65536 134217728
```

적용:
```bash
sudo sysctl --system
```

**주요 포인트**:
- 큐가 가득 찬 경우 **애플리케이션 레벨**(nginx의 `worker_connections`, JVM 스레드/큐 설정)도 병행하여 튜닝해야 합니다.

---

## 케이스 스터디: 단계별 문제 해결 예시

### 사례 1: 외부에서 HTTPS 접속 불가

1. `ss -tuln | grep ':443\>'` → 443 포트 리스닝 상태 확인
2. `curl -I https://127.0.0.1 --insecure` → 로컬에서 접속 테스트
3. `sudo nft list ruleset` / `sudo ufw status` → 방화벽 규칙 확인
4. 클라우드 보안 그룹/NACL/로드밸런서 타겟 그룹 헬스체크 확인
5. `tcpdump -i eth0 host <클라이언트IP> and port 443` → SYN/ACK 패킷 흐름 확인
6. SNI/서버 블록/프록시 설정(nginx `server_name`) 점검

### 사례 2: 내부는 빠른데 외부 접속이 느림

- `mtr` 명령으로 경로 품질 비교 (사내 네트워크 출구 혼잡 가능성 확인)
- PMTU/패킷 분할 테스트(`ping -M do -s ...`)
- 로드밸런서나 CDN 구간의 핸드셰이크/재전송 확인(tcpdump)

### 사례 3: 간헐적 타임아웃 (웹소켓/롱폴링)

- `conntrack -S`로 세션 드롭/만료 통계 확인
- 로드밸런서 idle timeout vs 애플리케이션 keepalive 설정 불일치 확인
- 방화벽 state timeout, NAT 게이트웨이 세션당 제한 확인

---

## 실전 스니펫: 반복 진단 자동화

### 서버 네트워크 상태 종합표 생성

```bash
#!/usr/bin/env bash

echo "[IP/라우팅 상태]"
ip -br a; echo; ip r; echo
echo "[DNS 확인]"
(getent hosts example.com || true) | sed 's/^/  /'
echo; echo "[리스닝 포트]"
ss -tuln | awk 'NR==1 || /LISTEN/'; echo
echo "[ESTABLISHED 상태의 80/443 포트 연결]"
ss -ant '( sport = :80 or sport = :443 )' state established | wc -l
```

### 지정 대상 포트 헬스체크 스크립트

```bash
#!/usr/bin/env bash

host=$1; port=$2
if nc -vz -w 2 "$host" "$port"; then
  echo "성공: $host:$port 접속 가능"
else
  echo "실패: $host:$port 접속 불가"
fi
```

---

## 방화벽 정책 설계 가이드라인

효과적인 방화벽 정책 설계를 위한 핵심 원칙:

- **기본 거부(DROP) 정책 적용 + 필요한 서비스만 명시적 허용**
- **상태 추적**(ESTABLISHED, RELATED) 연결 우선 허용
- 로깅은 **속도 제한**과 함께 적용 (DoS 공격 시 로그 폭탄 방지)
- ICMP 프로토콜은 과도하게 차단하지 않음 (경로 MTU 발견, 오류 통지 기능 보존)
- 관리 포트(SSH)에는 **소스 IP 제한**·키 기반 인증·fail2ban 연계
- 환경 통합: 클라우드 보안 그룹 / 호스트 방화벽 / 컨테이너 체인 간 **역할 분담**

---

## 핵심 명령어 요약

| 범주 | 대표 명령어 |
|---|---|
| 링크/주소 | `ip -br a`, `ethtool`, `journalctl -k` |
| 경로/ARP | `ip r`, `ip neigh`, `arp -n` |
| 계층별 진단 | `ping`, `traceroute`, `mtr` |
| 소켓/서비스 | `ss -tulnp`, `lsof -i`, `systemctl status` |
| 애플리케이션/HTTP/TLS | `curl -I/-v`, `openssl s_client` |
| 패킷 캡처/분석 | `tcpdump`, `tshark`, `wireshark` |
| 포트 스캔 | `nc -vz`, `nmap` |
| 대역폭 테스트 | `iperf3` |
| 방화벽(간편) | `ufw` |
| 방화벽(동적) | `firewalld` |
| 방화벽(네이티브) | `nft`, `nftables.conf` |
| NAT/세션 관리 | `conntrack -L/-S` |

---

## 결론

네트워크 문제 해결과 방화벽 관리는 리눅스 시스템 운영의 핵심 기술입니다. 체계적인 접근 방식을 통해 효율적으로 문제를 진단하고 해결할 수 있습니다.

네트워크 디버깅은 **계층별 순차적 접근**(링크 → 라우팅 → 소켓 → 방화벽/NAT → 애플리케이션)이 가장 효과적입니다. 확신이 서지 않을 때는 **패킷 캡처가 최선의 증거**가 됩니다. 실제 패킷 흐름을 분석하면 문제 원인을 명확히 파악하고 효과적으로 해결할 수 있습니다.

방화벽 구성은 **기본 거부 + 최소 허용 + 상태 추적 + 제한된 로깅**이 원칙입니다. 다양한 환경(클라우드, 컨테이너, 전통적 서버)에서의 제어 메커니즘을 이해하고 일관된 체계로 통일하는 것이 중요합니다.

MTU/MSS, 세션 타임아웃, SNI, split-DNS와 같은 미묘한 설정들이 빈번한 문제 원인이 됩니다. 체크리스트와 진단 스크립트를 팀 표준에 편입하여 재사용하면 문제 해결 속도를 크게 향상시킬 수 있습니다.

궁극적으로 네트워크 관리는 예방과 모니터링이 핵심입니다. 사전에 잘 설계된 방화벽 정책, 정기적인 진단, 그리고 문제 발생 시 체계적인 접근법을 통해 안정적이고 안전한 네트워크 환경을 유지할 수 있습니다.