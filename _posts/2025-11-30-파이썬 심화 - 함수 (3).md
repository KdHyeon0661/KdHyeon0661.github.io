---
layout: post
title: 파이썬 심화 - 함수 (3)
date: 2025-11-30 14:25:23 +0900
category: 파이썬 심화
---
# 함수 (3)

## 메소드가 하나인 클래스를 함수로 치환

### 단일 메소드 클래스의 함수화
```python
# 단일 메소드를 가진 클래스의 전형적인 예
class Logger:
    """단일 메소드 로거 클래스"""
    def __init__(self, prefix):
        self.prefix = prefix
    
    def log(self, message):
        print(f"[{self.prefix}] {message}")

# 사용 예시
logger = Logger("APP")
logger.log("애플리케이션이 시작되었습니다")
logger.log("데이터를 처리하는 중...")

# 이런 단일 메소드 클래스를 함수로 변환하는 패턴들
print("\n" + "="*60)
print("단일 메소드 클래스를 함수로 치환")
print("="*60)

# 1. 클로저를 이용한 변환
def create_logger(prefix):
    """클로저를 이용한 로거 생성 함수"""
    def log_message(message):
        print(f"[{prefix}] {message}")
    return log_message

# 사용 예시
app_logger = create_logger("APP")
app_logger("애플리케이션이 시작되었습니다")
app_logger("데이터를 처리하는 중...")

# 2. __call__ 메소드를 이용한 함수처럼 동작하는 클래스
print("\n1. __call__ 메소드를 이용한 함수-클래스:")
class CallableLogger:
    """__call__ 메소드로 함수처럼 동작하는 클래스"""
    def __init__(self, prefix):
        self.prefix = prefix
    
    def __call__(self, message):
        print(f"[{self.prefix}] {message}")
    
    def additional_method(self):
        """추가 메소드도 가질 수 있음"""
        return f"Logger with prefix: {self.prefix}"

# __call__을 구현하면 인스턴스를 함수처럼 호출 가능
callable_logger = CallableLogger("CALLABLE")
callable_logger("이것은 __call__ 메소드 호출입니다")
print(callable_logger.additional_method())

# 3. functools.partial을 이용한 부분 적용 함수
print("\n2. functools.partial을 이용한 방법:")
from functools import partial

def log_message(prefix, message):
    """기본 로그 함수"""
    print(f"[{prefix}] {message}")

# partial로 prefix를 고정한 새로운 함수 생성
app_log_partial = partial(log_message, "APP")
db_log_partial = partial(log_message, "DATABASE")

app_log_partial("애플리케이션 로그")
db_log_partial("데이터베이스 연결 성공")

# 4. lambda 함수를 이용한 변환
print("\n3. lambda를 이용한 간단한 변환:")
class Multiplier:
    """숫자 곱셈 클래스"""
    def __init__(self, factor):
        self.factor = factor
    
    def multiply(self, x):
        return x * self.factor

# lambda로 변환
def create_multiplier(factor):
    """람다를 이용한 곱셈 함수 생성"""
    return lambda x: x * factor

# 사용 비교
multiplier_class = Multiplier(5)
print(f"클래스 방식: 10 × 5 = {multiplier_class.multiply(10)}")

multiplier_func = create_multiplier(5)
print(f"람다 방식: 10 × 5 = {multiplier_func(10)}")

# 5. 실제 사례: 이벤트 핸들러
print("\n4. 이벤트 핸들러 패턴에서의 적용:")
class Button:
    """GUI 버튼 클래스 (전통적인 OOP 방식)"""
    def __init__(self, text):
        self.text = text
        self.click_handler = None
    
    def set_on_click(self, handler):
        self.click_handler = handler
    
    def click(self):
        if self.click_handler:
            self.click_handler(self.text)

# 단일 메소드 핸들러 클래스
class ButtonClickHandler:
    def __init__(self, user_name):
        self.user_name = user_name
    
    def handle_click(self, button_text):
        print(f"{self.user_name}님이 '{button_text}' 버튼을 클릭했습니다")

# 함수 기반 접근
def create_click_handler(user_name):
    """클로저를 이용한 핸들러 생성"""
    def handle_click(button_text):
        print(f"{user_name}님이 '{button_text}' 버튼을 클릭했습니다")
    return handle_click

# 사용 비교
print("클래스 방식:")
handler_class = ButtonClickHandler("김철수")
button1 = Button("저장")
button1.set_on_click(handler_class.handle_click)
button1.click()

print("\n함수 방식:")
handler_func = create_click_handler("이영희")
button2 = Button("삭제")
button2.set_on_click(handler_func)
button2.click()

# 6. 상태를 가진 함수 (함수 속성 활용)
print("\n5. 함수 속성을 이용한 상태 저장:")
def create_counter():
    """클로저 대신 함수 속성을 이용한 카운터"""
    def counter():
        counter.count += 1
        return counter.count
    
    # 함수에 속성 추가
    counter.count = 0
    return counter

# 사용 예시
counter1 = create_counter()
print(f"카운터1: {counter1()}, {counter1()}, {counter1()}")

counter2 = create_counter()
print(f"카운터2: {counter2()}, {counter2()}")

# 함수 속성 확인
print(f"카운터1의 count 속성: {counter1.count}")
print(f"카운터2의 count 속성: {counter2.count}")

# 7. 데코레이터와의 결합
print("\n6. 데코레이터와의 결합 패턴:")
class RetryOperation:
    """재시도 로직을 가진 클래스"""
    def __init__(self, max_attempts=3):
        self.max_attempts = max_attempts
    
    def execute(self, operation):
        for attempt in range(1, self.max_attempts + 1):
            try:
                return operation()
            except Exception as e:
                print(f"시도 {attempt} 실패: {e}")
                if attempt == self.max_attempts:
                    raise
        return None

# 함수로 변환
def create_retry_decorator(max_attempts=3):
    """데코레이터 형태의 재시도 함수"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(1, max_attempts + 1):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"시도 {attempt} 실패: {e}")
                    if attempt == max_attempts:
                        raise
            return None
        return wrapper
    return decorator

# 사용 비교
print("클래스 방식:")
retry_class = RetryOperation(max_attempts=2)

def risky_operation():
    import random
    if random.random() < 0.7:
        raise ValueError("임의 오류 발생")
    return "성공"

result = retry_class.execute(risky_operation)
print(f"결과: {result}")

print("\n데코레이터 방식:")
@create_retry_decorator(max_attempts=2)
def decorated_operation():
    import random
    if random.random() < 0.7:
        raise ValueError("임의 오류 발생")
    return "성공"

try:
    result = decorated_operation()
    print(f"결과: {result}")
except Exception as e:
    print(f"최종 실패: {e}")
```

## 콜백 함수에 추가적 상태 넣기

### 다양한 상태 보존 패턴
```python
print("\n" + "="*60)
print("콜백 함수에 추가적 상태 넣기")
print("="*60)

# 1. functools.partial을 이용한 상태 추가
print("1. functools.partial을 이용한 상태 추가:")

def process_data(data, threshold, prefix):
    """데이터 처리 함수 (여러 매개변수 필요)"""
    if data > threshold:
        print(f"{prefix}: 데이터 {data}가 임계값 {threshold}을 초과했습니다")
    else:
        print(f"{prefix}: 데이터 {data}는 정상 범위입니다")

# partial을 사용하여 일부 매개변수 고정
from functools import partial

# threshold와 prefix를 고정한 콜백 생성
high_alert_callback = partial(process_data, threshold=100, prefix="위험")
low_alert_callback = partial(process_data, threshold=50, prefix="주의")

# 콜백 사용
data_stream = [45, 78, 120, 65, 200]

for data in data_stream:
    if data > 150:
        high_alert_callback(data)
    elif data > 70:
        low_alert_callback(data)

# 2. 클로저를 이용한 상태 캡슐화
print("\n2. 클로저를 이용한 상태 캡슐화:")

def create_data_processor(threshold, prefix):
    """상태를 가진 데이터 프로세서 생성"""
    # 내부 상태 변수
    processed_count = 0
    total_value = 0
    
    def process(data):
        nonlocal processed_count, total_value
        
        processed_count += 1
        total_value += data
        average = total_value / processed_count
        
        if data > threshold:
            status = "초과"
        else:
            status = "정상"
        
        print(f"{prefix}: 데이터 {data} ({status})")
        print(f"  평균: {average:.2f}, 처리된 수: {processed_count}")
        
        return status
    
    return process

# 상태가 있는 콜백 생성
cpu_monitor = create_data_processor(threshold=80, prefix="CPU")
memory_monitor = create_data_processor(threshold=2048, prefix="메모리")

# 모니터링 시뮬레이션
import random

print("\nCPU 모니터링:")
for _ in range(5):
    cpu_usage = random.randint(50, 100)
    cpu_monitor(cpu_usage)

print("\n메모리 모니터링 (MB):")
for _ in range(5):
    memory_usage = random.randint(1024, 3072)
    memory_monitor(memory_usage)

# 3. 클래스 인스턴스를 콜백으로 사용
print("\n3. 클래스 인스턴스를 콜백으로 사용:")

class ProgressTracker:
    """진행 상황 추적기"""
    def __init__(self, total_steps, name="작업"):
        self.total_steps = total_steps
        self.name = name
        self.current_step = 0
        self.start_time = None
    
    def __call__(self, step_delta=1):
        """인스턴스를 함수처럼 호출"""
        import time
        
        if self.start_time is None:
            self.start_time = time.time()
        
        self.current_step += step_delta
        percentage = (self.current_step / self.total_steps) * 100
        elapsed = time.time() - self.start_time
        
        if self.current_step > 0:
            estimated_total = elapsed * (self.total_steps / self.current_step)
            remaining = estimated_total - elapsed
        else:
            remaining = 0
        
        print(f"{self.name}: {percentage:.1f}% 완료 "
              f"({self.current_step}/{self.total_steps}) "
              f"[남은 시간: {remaining:.1f}초]")
        
        if self.current_step >= self.total_steps:
            print(f"{self.name} 완료! 총 소요시간: {elapsed:.1f}초")

# 콜백으로 사용
def long_running_operation(steps, progress_callback):
    """긴 실행 작업 (진행 상황 콜백)"""
    import time
    
    for i in range(steps):
        # 작업 시뮬레이션
        time.sleep(0.1)
        
        # 진행 상황 보고
        if progress_callback:
            progress_callback(1)

# 진행 상황 추적기를 콜백으로 전달
tracker = ProgressTracker(total_steps=10, name="데이터 처리")
long_running_operation(10, tracker)

# 4. 콜백 체이닝과 상태 전달
print("\n4. 콜백 체이닝과 상태 전달:")

def create_pipeline(*callbacks):
    """여러 콜백을 연결하는 파이프라인 생성"""
    def pipeline(data, context=None):
        if context is None:
            context = {}
        
        result = data
        
        for i, callback in enumerate(callbacks):
            # 각 콜백에 컨텍스트 전달
            context['stage'] = i + 1
            context['total_stages'] = len(callbacks)
            
            try:
                result = callback(result, context)
                context[f'stage_{i}_success'] = True
            except Exception as e:
                context[f'stage_{i}_error'] = str(e)
                context[f'stage_{i}_success'] = False
                raise
        
        return result, context
    
    return pipeline

# 다양한 콜백 정의
def validate_data(data, context):
    print(f"[{context['stage']}/{context['total_stages']}] 데이터 검증: {data}")
    if not isinstance(data, (int, float)):
        raise ValueError("숫자 데이터가 필요합니다")
    return data

def normalize_data(data, context):
    print(f"[{context['stage']}/{context['total_stages']}] 데이터 정규화")
    # 0-1 범위로 정규화
    return data / 100

def log_transform(data, context):
    print(f"[{context['stage']}/{context['total_stages']}] 로그 변환")
    import math
    return math.log(data + 1)

# 파이프라인 생성 및 실행
data_pipeline = create_pipeline(validate_data, normalize_data, log_transform)

data_points = [50, 75, 100, "오류데이터", 25]

for data in data_points:
    print(f"\n데이터 처리: {data}")
    try:
        result, context = data_pipeline(data)
        print(f"  결과: {result:.4f}")
        print(f"  컨텍스트: {context}")
    except Exception as e:
        print(f"  처리 실패: {e}")

# 5. 콜백에 동적 상태 추가 (데코레이터 패턴)
print("\n5. 데코레이터를 이용한 동적 상태 추가:")

def with_retry_state(max_retries=3):
    """재시도 상태를 추가하는 데코레이터"""
    def decorator(callback):
        def wrapper(*args, **kwargs):
            wrapper.retry_count = getattr(wrapper, 'retry_count', 0)
            
            for attempt in range(max_retries):
                try:
                    result = callback(*args, **kwargs)
                    wrapper.last_success = True
                    return result
                except Exception as e:
                    wrapper.retry_count += 1
                    wrapper.last_error = str(e)
                    wrapper.last_attempt = attempt + 1
                    
                    if attempt == max_retries - 1:
                        wrapper.last_success = False
                        raise
            
            return None
        return wrapper
    return decorator

# 상태가 추가된 콜백 생성
@with_retry_state(max_retries=2)
def unstable_operation(value):
    """불안정한 작업 (가끔 실패)"""
    import random
    if random.random() < 0.5:
        raise ValueError(f"작업 실패: {value}")
    return f"성공: {value * 2}"

# 콜백 사용 및 상태 확인
print("불안정한 작업 실행:")
for i in range(3):
    try:
        result = unstable_operation(i)
        print(f"  시도 {i}: {result}")
    except Exception as e:
        print(f"  시도 {i}: 실패 - {e}")
    
    # 콜백 상태 확인
    print(f"    재시도 횟수: {unstable_operation.retry_count}")
    print(f"    마지막 성공: {getattr(unstable_operation, 'last_success', 'N/A')}")
    print(f"    마지막 오류: {getattr(unstable_operation, 'last_error', 'N/A')}")

# 6. 콜백 레지스트리와 상태 관리
print("\n6. 콜백 레지스트리와 상태 관리:")

class CallbackRegistry:
    """콜백 등록 및 관리 시스템"""
    def __init__(self):
        self.callbacks = {}
        self.callback_stats = {}
    
    def register(self, name, callback, priority=0):
        """콜백 등록"""
        if name not in self.callbacks:
            self.callbacks[name] = []
        
        self.callbacks[name].append({
            'callback': callback,
            'priority': priority,
            'call_count': 0,
            'last_called': None
        })
        
        # 우선순위 정렬
        self.callbacks[name].sort(key=lambda x: x['priority'], reverse=True)
        
        print(f"콜백 등록됨: {name} (우선순위: {priority})")
    
    def trigger(self, name, *args, **kwargs):
        """콜백 실행"""
        if name not in self.callbacks:
            print(f"경고: '{name}' 콜백이 등록되지 않았습니다")
            return []
        
        results = []
        
        for cb_info in self.callbacks[name]:
            try:
                # 콜백 통계 업데이트
                cb_info['call_count'] += 1
                cb_info['last_called'] = datetime.now()
                
                # 콜백 실행
                result = cb_info['callback'](*args, **kwargs)
                results.append(result)
                
                # 통계 기록
                if name not in self.callback_stats:
                    self.callback_stats[name] = []
                self.callback_stats[name].append({
                    'timestamp': datetime.now(),
                    'success': True,
                    'callback': cb_info['callback'].__name__
                })
                
            except Exception as e:
                print(f"콜백 실행 중 오류: {e}")
                
                if name not in self.callback_stats:
                    self.callback_stats[name] = []
                self.callback_stats[name].append({
                    'timestamp': datetime.now(),
                    'success': False,
                    'error': str(e),
                    'callback': cb_info['callback'].__name__
                })
        
        return results
    
    def get_stats(self, name=None):
        """콜백 통계 조회"""
        if name:
            if name in self.callback_stats:
                return self.callback_stats[name]
            return []
        
        return self.callback_stats

# 콜백 레지스트리 사용
registry = CallbackRegistry()

# 다양한 콜백 등록
def log_to_file(message):
    print(f"[파일로그] {message}")
    return "파일로그 완료"

def log_to_database(message):
    print(f"[DB로그] {message}")
    return "DB로그 완료"

def send_notification(message):
    print(f"[알림] {message}")
    return "알림 전송 완료"

# 우선순위에 따라 콜백 등록
registry.register("user_login", log_to_file, priority=10)
registry.register("user_login", log_to_database, priority=20)  # 가장 높은 우선순위
registry.register("user_login", send_notification, priority=5)

# 이벤트 트리거
print("\n사용자 로그인 이벤트:")
results = registry.trigger("user_login", "사용자 '김철수' 로그인")
print(f"콜백 결과: {results}")

# 통계 확인
stats = registry.get_stats("user_login")
print(f"\n콜백 통계:")
for stat in stats:
    print(f"  시간: {stat['timestamp'].strftime('%H:%M:%S')}, "
          f"성공: {stat['success']}, 콜백: {stat['callback']}")
```

## 인라인 콜백 함수

### 다양한 인라인 콜백 패턴
```python
print("\n" + "="*60)
print("인라인 콜백 함수")
print("="*60)

# 1. lambda를 이용한 간단한 인라인 콜백
print("1. lambda를 이용한 인라인 콜백:")

# 데이터 처리 함수
def process_numbers(numbers, callback):
    """숫자 리스트를 처리하는 함수"""
    results = []
    for num in numbers:
        results.append(callback(num))
    return results

# lambda를 인라인 콜백으로 사용
numbers = [1, 2, 3, 4, 5]

# 제곱 계산
squared = process_numbers(numbers, lambda x: x ** 2)
print(f"제곱: {squared}")

# 홀수/짝수 판별
odd_even = process_numbers(numbers, lambda x: "홀수" if x % 2 else "짝수")
print(f"홀수/짝수: {odd_even}")

# 조건부 처리
filtered = process_numbers(numbers, lambda x: x * 10 if x > 2 else x)
print(f"조건부 처리: {filtered}")

# 2. map/filter/reduce에서의 인라인 콜백
print("\n2. map/filter/reduce에서의 인라인 콜백:")

from functools import reduce

data = list(range(1, 11))

# map: 각 요소 변환
doubled = list(map(lambda x: x * 2, data))
print(f"map (2배): {doubled}")

# filter: 조건에 맞는 요소 선택
evens = list(filter(lambda x: x % 2 == 0, data))
print(f"filter (짝수): {evens}")

# reduce: 누적 계산
sum_squares = reduce(lambda acc, x: acc + x**2, data, 0)
print(f"reduce (제곱의 합): {sum_squares}")

# 3. 정렬에서의 인라인 콜백
print("\n3. 정렬에서의 인라인 콜백:")

students = [
    {'name': '김철수', 'score': 85, 'age': 20},
    {'name': '이영희', 'score': 92, 'age': 19},
    {'name': '박민수', 'score': 78, 'age': 21},
    {'name': '최지우', 'score': 95, 'age': 20}
]

# 점수 기준 정렬 (내림차순)
sorted_by_score = sorted(students, key=lambda s: s['score'], reverse=True)
print("점수 기준 정렬:")
for student in sorted_by_score:
    print(f"  {student['name']}: {student['score']}점")

# 복합 정렬 (점수 높은 순, 동점일 경우 나이 어린 순)
sorted_complex = sorted(students, key=lambda s: (-s['score'], s['age']))
print("\n복합 정렬 (점수↓, 나이↑):")
for student in sorted_complex:
    print(f"  {student['name']}: {student['score']}점, {student['age']}세")

# 4. GUI/이벤트 핸들링에서의 인라인 콜백
print("\n4. GUI/이벤트 핸들링에서의 인라인 콜백:")

class EventSimulator:
    """이벤트 시뮬레이터"""
    def __init__(self):
        self.handlers = {}
    
    def on(self, event_name, handler):
        """이벤트 핸들러 등록"""
        if event_name not in self.handlers:
            self.handlers[event_name] = []
        self.handlers[event_name].append(handler)
    
    def emit(self, event_name, *args, **kwargs):
        """이벤트 발생"""
        if event_name in self.handlers:
            for handler in self.handlers[event_name]:
                handler(*args, **kwargs)

# 이벤트 시스템 생성
event_system = EventSimulator()

# 인라인 핸들러 등록
event_system.on("button_click", lambda button_id: 
                print(f"버튼 {button_id} 클릭됨"))

event_system.on("data_received", lambda data, source: 
                print(f"{source}에서 데이터 수신: {data[:20]}..."))

# 중첩된 인라인 콜백
event_system.on("user_action", 
    lambda action, user: (
        print(f"사용자 {user}의 액션: {action}"),
        print(f"로그 기록 중..."),
        print(f"액션 처리 완료")
    )[-1]  # 마지막 표현식 반환
)

# 이벤트 발생
print("이벤트 발생 시뮬레이션:")
event_system.emit("button_click", "btn_save")
event_system.emit("data_received", "A" * 100, "센서1")
event_system.emit("user_action", "로그인", "김철수")

# 5. 데이터 처리 파이프라인에서의 인라인 콜백
print("\n5. 데이터 처리 파이프라인에서의 인라인 콜백:")

def create_data_pipeline(*operations):
    """인라인 연산으로 데이터 파이프라인 생성"""
    def pipeline(data):
        result = data
        
        for operation in operations:
            # operation은 인라인 람다 함수
            result = operation(result)
        
        return result
    
    return pipeline

# 인라인 파이프라인 생성
text_pipeline = create_data_pipeline(
    lambda text: text.strip(),  # 공백 제거
    lambda text: text.lower(),  # 소문자 변환
    lambda text: text.replace("  ", " "),  # 이중 공백 제거
    lambda text: text.title()  # 제목 형식으로 변환
)

# 사용 예시
texts = [
    "  hello   world  ",
    "PYTHON PROGRAMMING  ",
    "  data  analysis  with  python  "
]

print("텍스트 처리 파이프라인:")
for text in texts:
    processed = text_pipeline(text)
    print(f"  '{text}' -> '{processed}'")

# 6. 조건부 인라인 콜백 실행
print("\n6. 조건부 인라인 콜백 실행:")

def conditional_process(data, condition, true_callback, false_callback=None):
    """조건에 따라 다른 콜백 실행"""
    if condition(data):
        return true_callback(data)
    elif false_callback:
        return false_callback(data)
    return data

# 인라인 콜백 사용
numbers = [10, 25, 35, 50, 15]

results = []
for num in numbers:
    result = conditional_process(
        num,
        lambda x: x >= 30,  # 조건
        lambda x: f"{x}: 높음",  # True일 때 콜백
        lambda x: f"{x}: 낮음"   # False일 때 콜백
    )
    results.append(result)

print("조건부 처리 결과:")
for r in results:
    print(f"  {r}")

# 7. 인라인 콜백 체이닝
print("\n7. 인라인 콜백 체이닝:")

class ChainableProcessor:
    """체이닝 가능한 프로세서"""
    def __init__(self, data):
        self.data = data
    
    def apply(self, callback):
        """인라인 콜백 적용"""
        self.data = callback(self.data)
        return self  # 체이닝을 위해 self 반환
    
    def get_result(self):
        return self.data

# 체이닝 사용 예시
result = (
    ChainableProcessor([1, 2, 3, 4, 5])
    .apply(lambda lst: [x * 2 for x in lst])  # 2배
    .apply(lambda lst: [x for x in lst if x > 5])  # 5보다 큰 값 필터링
    .apply(lambda lst: sum(lst))  # 합계 계산
    .apply(lambda total: f"총합: {total}")  # 형식화
    .get_result()
)

print(f"체이닝 결과: {result}")

# 8. 인라인 콜백 팩토리
print("\n8. 인라인 콜백 팩토리:")

def create_comparator(field, reverse=False):
    """동적으로 비교자를 생성하는 팩토리"""
    if reverse:
        return lambda a, b: getattr(b, field) - getattr(a, field)
    else:
        return lambda a, b: getattr(a, field) - getattr(b, field)

class Product:
    def __init__(self, name, price, rating):
        self.name = name
        self.price = price
        self.rating = rating
    
    def __repr__(self):
        return f"{self.name}({self.price}원, 평점:{self.rating})"

# 상품 목록
products = [
    Product("노트북", 1200000, 4.5),
    Product("스마트폰", 800000, 4.2),
    Product("태블릿", 600000, 4.7),
    Product("이어폰", 150000, 4.3)
]

# 동적으로 비교자 생성
price_comparator = create_comparator('price')
rating_comparator = create_comparator('rating', reverse=True)

# 정렬 적용
from functools import cmp_to_key

print("가격 기준 정렬 (낮은 순):")
products_by_price = sorted(products, key=cmp_to_key(price_comparator))
for p in products_by_price:
    print(f"  {p}")

print("\n평점 기준 정렬 (높은 순):")
products_by_rating = sorted(products, key=cmp_to_key(rating_comparator))
for p in products_by_rating:
    print(f"  {p}")
```

## 클로저 내부에서 정의한 변수에 접근

### 클로저 변수 접근과 수정
```python
print("\n" + "="*60)
print("클로저 내부에서 정의한 변수에 접근")
print("="*60)

# 1. 기본 클로저와 변수 접근
print("1. 기본 클로저와 변수 접근:")

def outer_function(x):
    """외부 함수"""
    y = 10  # 외부 함수의 지역 변수
    
    def inner_function(z):
        """내부 함수 (클로저)"""
        # 외부 함수의 변수에 접근
        return x + y + z
    
    return inner_function

# 클로저 생성
closure = outer_function(5)

# 클로저 실행
result = closure(3)
print(f"클로저 실행 결과: {result}")
print(f"클로저 함수: {closure}")
print(f"클로저의 __closure__ 속성: {closure.__closure__}")

# 클로저에 저장된 변수 값 확인
if closure.__closure__:
    print("\n클로저에 캡처된 변수들:")
    for i, cell in enumerate(closure.__closure__):
        print(f"  cell_contents[{i}]: {cell.cell_contents}")

# 2. nonlocal을 이용한 변수 수정
print("\n2. nonlocal을 이용한 변수 수정:")

def create_counter():
    """카운터 생성 함수"""
    count = 0  # 클로저에 캡처될 변수
    
    def increment():
        nonlocal count  # 외부 변수를 수정하기 위해 nonlocal 선언
        count += 1
        return count
    
    def decrement():
        nonlocal count
        count -= 1
        return count
    
    def get_count():
        return count
    
    def reset():
        nonlocal count
        count = 0
        return count
    
    # 모든 내부 함수 반환
    return increment, decrement, get_count, reset

# 카운터 생성
inc, dec, get, reset = create_counter()

print("카운터 작동:")
print(f"초기값: {get()}")
print(f"증가: {inc()}")
print(f"증가: {inc()}")
print(f"현재값: {get()}")
print(f"감소: {dec()}")
print(f"현재값: {get()}")
print(f"리셋: {reset()}")
print(f"리셋 후: {get()}")

# 3. 여러 변수를 캡처하는 클로저
print("\n3. 여러 변수를 캡처하는 클로저:")

def create_person_manager(name, age):
    """사람 관리자 생성"""
    # 여러 변수 캡처
    person_data = {
        'name': name,
        'age': age,
        'history': []
    }
    
    def update_name(new_name):
        nonlocal person_data
        old_name = person_data['name']
        person_data['name'] = new_name
        person_data['history'].append(f"이름 변경: {old_name} -> {new_name}")
        return person_data['name']
    
    def update_age(new_age):
        nonlocal person_data
        old_age = person_data['age']
        person_data['age'] = new_age
        person_data['history'].append(f"나이 변경: {old_age} -> {new_age}")
        return person_data['age']
    
    def add_history(event):
        nonlocal person_data
        person_data['history'].append(event)
        return person_data['history'][-1]
    
    def get_info():
        return dict(person_data)
    
    return update_name, update_age, add_history, get_info

# 사람 관리자 생성
change_name, change_age, add_event, get_person_info = create_person_manager("김철수", 30)

print("사람 정보 관리:")
print(f"초기 정보: {get_person_info()}")

change_name("김영수")
change_age(31)
add_event("직업: 개발자")
add_event("결혼")

print(f"변경 후 정보: {get_person_info()}")

# 4. 클로저 변수 접근 제어 (getter/setter)
print("\n4. 클로저 변수 접근 제어 (getter/setter):")

def create_private_variable(initial_value):
    """private한 변수를 가진 클로저"""
    _value = initial_value
    _access_count = 0
    
    def get_value():
        nonlocal _access_count
        _access_count += 1
        return _value
    
    def set_value(new_value):
        nonlocal _value, _access_count
        
        # 유효성 검사
        if not isinstance(new_value, (int, float)):
            raise ValueError("숫자만 설정 가능합니다")
        
        _value = new_value
        _access_count += 1
        return _value
    
    def get_access_count():
        return _access_count
    
    def increment(amount=1):
        nonlocal _value, _access_count
        _value += amount
        _access_count += 1
        return _value
    
    # 선택적으로 내부 함수만 공개
    return {
        'get': get_value,
        'set': set_value,
        'increment': increment,
        'access_count': get_access_count
    }

# private 변수 사용
counter = create_private_variable(10)

print("private 변수 접근:")
print(f"초기값 조회: {counter['get']()}")
print(f"값 설정: {counter['set'](20)}")
print(f"증가: {counter['increment'](5)}")
print(f"현재값: {counter['get']()}")
print(f"접근 횟수: {counter['access_count']()}")

# 직접 접근 시도 (불가능)
try:
    # _value에 직접 접근할 수 없음
    print(counter._value)
except AttributeError as e:
    print(f"직접 접근 시도 실패: {e}")

# 5. 클로저를 이용한 메모이제이션
print("\n5. 클로저를 이용한 메모이제이션:")

def create_memoized_function(func):
    """메모이제이션 기능을 가진 함수 생성"""
    cache = {}  # 캐시 저장소
    
    def memoized(*args):
        # 인자를 키로 사용 (튜플은 해시 가능)
        key = args
        
        # 캐시에 없으면 계산
        if key not in cache:
            cache[key] = func(*args)
        
        return cache[key]
    
    def clear_cache():
        nonlocal cache
        cache.clear()
        return "캐시가 초기화되었습니다"
    
    def get_cache_stats():
        return {
            'size': len(cache),
            'keys': list(cache.keys())
        }
    
    # 추가 기능과 함께 반환
    memoized.clear = clear_cache
    memoized.stats = get_cache_stats
    
    return memoized

# 피보나치 함수 (재귀적, 느림)
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# 메모이제이션 적용
memoized_fib = create_memoized_function(fibonacci)

print("메모이제이션 피보나치:")
import time

# 첫 번째 실행 (캐시 없음)
start = time.time()
result1 = memoized_fib(30)
time1 = time.time() - start
print(f"fib(30) = {result1} (첫 실행: {time1:.4f}초)")

# 두 번째 실행 (캐시 히트)
start = time.time()
result2 = memoized_fib(30)
time2 = time.time() - start
print(f"fib(30) = {result2} (캐시 히트: {time2:.4f}초)")

print(f"캐시 통계: {memoized_fib.stats()}")
print(f"캐시 초기화: {memoized_fib.clear()}")
print(f"초기화 후 캐시 통계: {memoized_fib.stats()}")

# 6. 클로저 상태 디버깅
print("\n6. 클로저 상태 디버깅 및 검사:")

def create_debuggable_closure(initial_state):
    """디버깅 가능한 클로저"""
    state = initial_state.copy()
    call_history = []
    
    def operation(action, value=None):
        nonlocal state, call_history
        
        timestamp = datetime.now()
        
        if action == 'set':
            old_value = state.get('value')
            state['value'] = value
            result = f"값 설정: {old_value} -> {value}"
        
        elif action == 'increment':
            state['value'] = state.get('value', 0) + 1
            result = f"값 증가: {state['value']}"
        
        elif action == 'get':
            result = state.get('value')
        
        elif action == 'history':
            return call_history
        
        elif action == 'state':
            return dict(state)
        
        else:
            result = f"알 수 없는 액션: {action}"
        
        # 호출 기록
        call_history.append({
            'timestamp': timestamp,
            'action': action,
            'value': value,
            'result': result,
            'state': dict(state)
        })
        
        return result
    
    # 디버깅 속성 추가
    def debug_info():
        return {
            'state': dict(state),
            'history_length': len(call_history),
            'last_call': call_history[-1] if call_history else None
        }
    
    operation.debug = debug_info
    operation.__closure_vars__ = lambda: {
        'state': state,
        'call_history': call_history
    }
    
    return operation

# 디버깅 가능한 클로저 생성
debug_closure = create_debuggable_closure({'value': 0, 'initialized': True})

print("디버깅 클로저 테스트:")
print(f"초기값: {debug_closure('get')}")
print(f"증가: {debug_closure('increment')}")
print(f"증가: {debug_closure('increment')}")
print(f"설정: {debug_closure('set', 100)}")
print(f"현재값: {debug_closure('get')}")

# 디버깅 정보 출력
print("\n디버깅 정보:")
debug_info = debug_closure.debug()
print(f"상태: {debug_info['state']}")
print(f"호출 기록 길이: {debug_info['history_length']}")
print(f"마지막 호출: {debug_info['last_call']}")

# 7. 클로저를 이용한 상태 기계 (State Machine)
print("\n7. 클로저를 이용한 상태 기계:")

def create_state_machine(initial_state):
    """상태 기계 생성"""
    state = initial_state
    transition_history = []
    
    def transition(event, data=None):
        nonlocal state, transition_history
        
        old_state = state
        
        # 상태 전환 로직
        if state == 'IDLE':
            if event == 'START':
                state = 'RUNNING'
                action = "작업 시작"
            elif event == 'ERROR':
                state = 'ERROR'
                action = "오류 발생"
            else:
                action = "무시됨"
        
        elif state == 'RUNNING':
            if event == 'PAUSE':
                state = 'PAUSED'
                action = "일시 정지"
            elif event == 'COMPLETE':
                state = 'COMPLETED'
                action = "작업 완료"
            elif event == 'ERROR':
                state = 'ERROR'
                action = "오류 발생"
            else:
                action = "무시됨"
        
        elif state == 'PAUSED':
            if event == 'RESUME':
                state = 'RUNNING'
                action = "재개"
            elif event == 'CANCEL':
                state = 'CANCELLED'
                action = "취소"
            else:
                action = "무시됨"
        
        else:  # 최종 상태들
            action = f"상태 {state}에서는 전환 불가"
        
        # 기록
        transition_history.append({
            'timestamp': datetime.now(),
            'from_state': old_state,
            'event': event,
            'to_state': state,
            'action': action,
            'data': data
        })
        
        return {
            'old_state': old_state,
            'new_state': state,
            'action': action,
            'data': data
        }
    
    def get_state():
        return state
    
    def get_history():
        return transition_history.copy()
    
    def reset():
        nonlocal state, transition_history
        state = initial_state
        transition_history = []
        return "초기화 완료"
    
    return transition, get_state, get_history, reset

# 상태 기계 생성
transit, get_state, get_history, reset_machine = create_state_machine('IDLE')

print("상태 기계 테스트:")
print(f"초기 상태: {get_state()}")

# 상태 전환
events = [
    ('START', {'user': '김철수'}),
    ('PAUSE', {'reason': '점심시간'}),
    ('RESUME', None),
    ('COMPLETE', {'result': '성공'})
]

for event, data in events:
    result = transit(event, data)
    print(f"\n이벤트: {event}")
    print(f"  전환: {result['old_state']} -> {result['new_state']}")
    print(f"  액션: {result['action']}")
    print(f"  데이터: {result['data']}")

# 전환 기록 출력
print(f"\n전환 기록:")
for i, record in enumerate(get_history()):
    print(f"  {i+1}. {record['from_state']} --[{record['event']}]--> {record['to_state']}")
    print(f"     시간: {record['timestamp'].strftime('%H:%M:%S')}")
    print(f"     액션: {record['action']}")

# 8. 클로저 변수의 수명 주기 관리
print("\n8. 클로저 변수의 수명 주기 관리:")

def create_resource_manager(resource_name):
    """리소스 관리자 (수명 주기 관리)"""
    resource = None
    is_open = False
    access_count = 0
    
    def open_resource():
        nonlocal resource, is_open, access_count
        
        if is_open:
            return f"{resource_name} 이미 열려있음"
        
        # 리소스 열기 시뮬레이션
        resource = f"{resource_name}_data_{access_count}"
        is_open = True
        access_count += 1
        
        print(f"{resource_name} 열림: {resource}")
        return resource
    
    def use_resource():
        nonlocal access_count
        
        if not is_open:
            return f"{resource_name}를 먼저 열어주세요"
        
        access_count += 1
        return f"{resource} 사용 중... (사용 횟수: {access_count})"
    
    def close_resource():
        nonlocal resource, is_open
        
        if not is_open:
            return f"{resource_name} 이미 닫혀있음"
        
        print(f"{resource_name} 닫힘: {resource}")
        resource = None
        is_open = False
        
        return f"{resource_name} 정상적으로 닫힘"
    
    def get_status():
        return {
            'resource_name': resource_name,
            'is_open': is_open,
            'access_count': access_count,
            'current_resource': resource
        }
    
    # 수명 주기 종료 시 정리 함수
    def cleanup():
        nonlocal resource, is_open
        
        if is_open:
            close_resource()
        
        return f"{resource_name} 관리자 정리 완료"
    
    # 관리자 객체 반환
    class ResourceManager:
        def open(self):
            return open_resource()
        
        def use(self):
            return use_resource()
        
        def close(self):
            return close_resource()
        
        def status(self):
            return get_status()
        
        def __del__(self):
            # 객체 소멸 시 자동 정리
            print(f"{resource_name} 관리자 소멸자 호출")
            cleanup()
    
    return ResourceManager()

# 리소스 관리자 사용
print("리소스 관리자 테스트:")
file_manager = create_resource_manager("파일")

print(f"상태: {file_manager.status()}")
print(f"열기: {file_manager.open()}")
print(f"사용: {file_manager.use()}")
print(f"사용: {file_manager.use()}")
print(f"상태: {file_manager.status()}")
print(f"닫기: {file_manager.close()}")
print(f"상태: {file_manager.status()}")

# 명시적 삭제 (실제로는 가비지 컬렉터가 처리)
print("\n관리자 삭제 시뮬레이션:")
del file_manager

# 추가 테스트를 위해 새 관리자 생성
db_manager = create_resource_manager("데이터베이스")
db_manager.open()
print(f"DB 상태: {db_manager.status()}")

# 강제로 가비지 컬렉션 시뮬레이션
import gc
print("\n가비지 컬렉션 강제 실행:")
del db_manager
gc.collect()
```

## 결론

Python에서 메소드가 하나인 클래스는 종종 함수로 대체될 수 있으며, 이는 코드를 더 간결하고 함수형 스타일로 작성할 수 있게 해줍니다. `__call__` 메소드를 구현하거나 `functools.partial`을 사용하면 클래스 인스턴스를 함수처럼 사용할 수 있습니다. 특히 콜백 패턴이나 전략 패턴에서 이 기법은 매우 유용합니다.

콜백 함수에 추가적인 상태를 넣는 방법은 여러 가지가 있습니다. `functools.partial`은 함수의 일부 매개변수를 고정하는 데 사용되며, 클로저는 더 복잡한 상태 캡슐화에 적합합니다. 클래스를 콜백으로 사용할 때는 `__call__` 메소드를 구현하면 인스턴스를 함수처럼 호출할 수 있습니다.

인라인 콜백 함수는 `lambda` 표현식을 통해 간결하게 정의할 수 있으며, 특히 `map`, `filter`, `sorted` 같은 고차 함수와 함께 사용될 때 강력합니다. 하지만 복잡한 로직의 경우 명시적인 함수 정의가 가독성에 더 좋을 수 있습니다.

클로저 내부에서 정의한 변수에 접근하는 것은 Python의 강력한 기능 중 하나입니다. `nonlocal` 키워드를 사용하면 내부 함수에서 외부 함수의 변수를 수정할 수 있습니다. 클로저는 상태를 캡슐화하고 은닉하는 데 유용하며, 메모이제이션, 상태 기계, 리소스 관리 등 다양한 패턴에서 활용됩니다.

이러한 기술들을 효과적으로 조합하면:
1. **더 간결한 코드**: 불필요한 클래스 정의를 피하고 함수로 대체
2. **더 나은 캡슐화**: 클로저를 이용한 상태 은닉
3. **더 유연한 콜백**: 상태를 가진 콜백 함수 생성
4. **함수형 프로그래밍 스타일**: 고차 함수와 람다의 조합

단, 모든 상황에서 클래스를 함수로 대체해야 하는 것은 아닙니다. 클래스는 여전히 여러 메소드와 속성을 가진 복잡한 객체를 모델링하는 데 가장 적합합니다. 코드의 의도와 가독성을 고려하여 적절한 패턴을 선택하는 것이 중요합니다.

클로저와 함수형 패턴을 과도하게 사용하면 디버깅이 어려워질 수 있으므로, 적절한 문서화와 타입 힌트를 함께 사용하는 것이 좋습니다. 또한 Python 3.9+에서는 클로저 변수를 검사하는 새로운 기능들이 추가되었으므로, 최신 Python 기능을 활용하면 더 효과적으로 작업할 수 있습니다.