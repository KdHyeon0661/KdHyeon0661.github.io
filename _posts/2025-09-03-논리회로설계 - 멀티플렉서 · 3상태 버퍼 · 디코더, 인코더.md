---
layout: post
title: 논리회로설계 - 멀티플렉서 · 3상태 버퍼 · 디코더, 인코더
date: 2025-09-03 19:25:23 +0900
category: 논리회로설계
---
# 멀티플렉서(MUX) · 3상태 버퍼(Three-State Buffer) · 디코더/인코더(Decoder/Encoder) 완전 정리

> 표기: \(+\)=OR, \(\cdot\) 또는 생략=AND, \(\overline{X}\)=NOT \(X\), \(X'\equiv\overline{X}\).  
> 목표: **기능·진리표·수식**, **구현·확장·연결**, **해저드/타이밍·전력·신뢰성**까지 한 번에 끝내는 실전형 정리.  
> 원칙: 문서는 **제목은 # 한 번**, 소제목은 ##부터. 모든 **수식은 $$...$$**, 모든 **코드는 ```로** 감싼다.

---

## 1. 멀티플렉서(Multiplexer, MUX)

### 1.1 개념과 핵심 용도
- **정의**: 여러 데이터 입력 중 **하나**를 선택해 **단일 출력**으로 전달하는 선택 스위치.  
- **형식**: \(2^k\!:\!1\) MUX (데이터 입력 \(2^k\)개, 선택선 \(k\)개, 출력 1개).  
- **핵심 용도**
  - 데이터 경로 선택(포워딩/바이패스/ALU 입력 선택)
  - **샤논 전개(Shannon expansion)** 기반 **임의 조합논리 구현**
  - 버스 멀티플렉싱(핀 절감), LUT 내부 구조(MUX 트리)

### 1.2 기본식과 진리표

**2:1 MUX** (입력 \(D_0,D_1\), 선택 \(S\), 출력 \(Y\))
$$
Y=\overline{S}\,D_0 + S\,D_1
$$

```
S | D1 D0 || Y
--+--------++--
0 |  x D0  || D0
1 |  D1 x  || D1
```

**4:1 MUX** (선택 \(S_1S_0\))
$$
Y=\overline{S_1}\overline{S_0}D_0+\overline{S_1}S_0D_1+S_1\overline{S_0}D_2+S_1S_0D_3
$$

### 1.3 샤논 전개로 임의 함수 구현
샤논 전개:
$$
F(x,\mathbf{u}) = x\cdot F\!\big|_{x=1} + \overline{x}\cdot F\!\big|_{x=0}
$$
- **절차**: 선택선 \(S\leftarrow x\). 데이터 입력에 \(F|_{x=0}, F|_{x=1}\)을 배치 → **2:1 MUX = F**.  
- 변수 2개면 4:1, 3개면 8:1…으로 확장(데이터 입력은 상수/단항/부분식).

**예)** \(F(A,B,C)=\sum m(1,2,6,7)\)을 \(S\!=\!AB\)로 4:1 MUX 구현
- \(AB=00:\ D_0=0\)  
- \(AB=01:\ D_1=\overline{C}\)  
- \(AB=10:\ D_2=0\)  
- \(AB=11:\ D_3=1\)  
\(\Rightarrow F=\text{MUX}_{S_1S_0}(D_3\!=\!1,\ D_2\!=\!0,\ D_1\!=\!\overline{C},\ D_0\!=\!0)\)

### 1.4 계층화(트리)와 팬인 제약
- 큰 MUX는 **작은 MUX 트리**로 구성(예: 8:1 = 4:1 두 개 + 2:1 한 개).  
- **장점**: 입력 지연 균형, 배선 용이, 속도 향상.  
- **선택선 분할**: 하위 트리에는 하위 비트 선택, 상위 트리에서 상위 비트로 최종 선택.

### 1.5 구현 관점(게이트/HDL)

**게이트(NAND/NOR) 구현**
- 2:1은 **전송게이트/CMOS 패스/AND-OR** 등 다양. 조합 게이트로는  
  \(Y=(\overline{S}\cdot D_0) + (S\cdot D_1)\) → AND 2개 + OR 1개 + 인버터 1개.

**Verilog — 파라미터화 MUX**
```verilog
module mux #(parameter W=8, K=2) ( // 2^K:1
  input  [W-1:0] D [0:(1<<K)-1],
  input  [K-1:0] S,
  output [W-1:0] Y
);
  integer i;
  reg [W-1:0] y_r;
  always @* begin
    y_r = {W{1'b0}};
    for (i=0;i<(1<<K);i=i+1) if (S==i[K-1:0]) y_r = D[i];
  end
  assign Y = y_r;
endmodule
```

**해저드/타이밍**
- 선택선/데이터 **경로 지연 불균형** → **글리치** 가능.  
- 완화: **출력 레지스터링**, 선택선/데이터 **동일 경로 수** 확보, **버퍼 삽입**으로 지연 균형.

---

## 2. 3상태 버퍼(Three-State, Tri-State Buffer)

### 2.1 개념
- 출력이 **0, 1, Z(고임피던스)** 3가지를 가짐.  
- **OE(출력 Enable)** 로 구동/비구동 제어 → **여러 소스가 한 버스**를 공유.

### 2.2 진리표(Active-High OE)
```
입력(A) OE | 출력(Y)
-----------+--------
 0     0   |   Z
 1     0   |   Z
 0     1   |   0
 1     1   |   1
```
- Active-Low OE는 OE에 **버블**, 0일 때 구동.

### 2.3 버스 설계 안전 수칙
1) **항상 단 1개** 장치만 OE=1(주소 디코더/중재기로 상호배타 보장).  
2) **버스 충돌 금지**: 상이한 값으로 동시 구동 시 과전류·손상.  
3) **버스 키퍼(weak keeper)** 또는 풀업/풀다운으로 **부유 방지**.  
4) **전환 타이밍**: Z→구동, 구동→Z 사이 **여유 시간** 확보(\(t_{\text{dis}}, t_{\text{en}}\)).  
5) **현대 FPGA** 내부는 **진짜 Tri-State 금지** → 합성기에서 **MUX/LUT로 치환**(I/O 핀 주변만 3-state 허용).

### 2.4 Tri-State로 MUX 만들기(Decoder + 3-State)
**4:1 MUX** 절차
1) \(S_1S_0\ \xrightarrow{\text{2:4 디코더}}\ E_0..E_3\) (one-hot).  
2) 각 \(D_i\)를 3-state 버퍼로 구동, **OE=E_i**.  
3) 네 버퍼 출력은 **공통 버스**에 연결.  
→ **항상 하나만 활성**이면 MUX와 동등. (버스 충돌/공백 시간 관리 필수)

**Verilog(시뮬레이션용)**
```verilog
wire [7:0] bus;
assign bus = (E0) ? D0 : 8'bz;
assign bus = (E1) ? D1 : 8'bz;
assign bus = (E2) ? D2 : 8'bz;
assign bus = (E3) ? D3 : 8'bz; // E0..E3는 one-hot
```
> 주: 다수의 연속 assign로 같은 넷을 구동하면 시뮬레이터는 **충돌 시 'x'** 를 보여줌. 실제 FPGA 내부 합성은 **MUX**로 변환됨.

---

## 3. 디코더(Decoder)

### 3.1 개념
- 입력 \(n\)비트 이진 코드 → **\(2^n\)개의 one-hot 출력**(하나만 1).  
- 표기: \(n\!\to\!2^n\) (3→8, 4→16). **EN(Enable)** 핀 포함이 일반적.  
- **Active-High/Low** 출력 버전(출력에 버블 유무로 구분).

### 3.2 진리표·수식(3→8, Active-High)
입력 \(A,B,C\) (MSB→LSB), 출력 \(Y_0..Y_7\)
```
ABC | Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
----+-------------------------
000 | 0  0  0  0  0  0  0  1
001 | 0  0  0  0  0  0  1  0
010 | 0  0  0  0  0  1  0  0
011 | 0  0  0  0  1  0  0  0
100 | 0  0  0  1  0  0  0  0
101 | 0  0  1  0  0  0  0  0
110 | 0  1  0  0  0  0  0  0
111 | 1  0  0  0  0  0  0  0
```
예: \(Y_5=A\overline{B}C,\;Y_0=\overline{A}\,\overline{B}\,\overline{C}\)

**합성 친화 Verilog(파라미터)**
```verilog
module decoder #(parameter N=3) ( // N->2^N
  input  [N-1:0] in,
  input          en,
  output [ (1<<N)-1:0 ] y
);
  integer i; reg [(1<<N)-1:0] t;
  always @* begin
    t = '0;
    if (en) t[in] = 1'b1;
  end
  assign y = t;
endmodule
```

### 3.3 확장/캐스케이드
- **4→16**: (상위 비트로 블록 EN) + (하위 비트로 2→4 ×4)  
- **대형 디코더(예: 8→256)**: **프리디코더**(2→4, 3→8) 조합으로 팬인/배선/지연 최적화.

### 3.4 디코더로 임의 함수 구현
- \(F=\sum m(\mathcal{I})\) 이면, 해당 **디코더 출력 라인**들을 **OR** → **SOP 직접 구현**.  
- **Active-Low 출력 디코더**는 **NOR**에 바로 연결하면 **NOR–NOR 2단**을 자연스럽게 얻음.

### 3.5 해저드/타이밍
- 입력 전이 시 **두 출력 동시 1**(또는 active-low면 0)로 잠깐 겹칠 수 있음 → **글리치**.  
- 완화: **EN으로 출력 비활성** 기간 확보, **출력 레지스터링**, **관성 지연**(물리 게이트/OR) 활용.

---

## 4. 인코더(Encoder) & 우선순위 인코더(Priority Encoder)

### 4.1 기본 인코더( \(2^n\!\to n\) )
- **전제**: 입력은 **one-hot**.  
- **8→3 인코더**: 입력 \(D_7..D_0\), 출력 \(A_2A_1A_0\)
$$
\begin{aligned}
A_2&=D_4+D_5+D_6+D_7\\
A_1&=D_2+D_3+D_6+D_7\\
A_0&=D_1+D_3+D_5+D_7
\end{aligned}
$$
- **문제**: 다중 1 → **모호**. 해결: **우선순위 인코더**.

### 4.2 우선순위 인코더(상위 비트 우선)
- **정의**: 여러 입력이 1일 때 **가장 높은 인덱스**를 출력.  
- **유효 플래그 \(V\)**: \(V=\bigvee_i D_i\).  
- **마스킹식(개념)**: 상위 그룹이 1이면 하위를 마스킹.
$$
\begin{aligned}
V   &= D_7+\cdots+D_0 \\
A_2 &= D_7 + D_6 + D_5 + D_4 \\
A_1 &= D_7 + D_6 + (D_3+D_2)\cdot \overline{D_7+D_6+D_5+D_4} \\
A_0 &= D_7 + (D_5\cdot \overline{D_7}) + (D_3\cdot \overline{D_7+D_6+D_5+D_4})
       + (D_1\cdot \overline{D_7+\cdots+D_2})
\end{aligned}
$$

**합성 친화 Verilog(상위 우선)**
```verilog
module prienc8 (input  [7:0] d, output [2:0] a, output v);
  assign v = |d;
  assign a = d[7] ? 3'd7 :
             d[6] ? 3'd6 :
             d[5] ? 3'd5 :
             d[4] ? 3'd4 :
             d[3] ? 3'd3 :
             d[2] ? 3'd2 :
             d[1] ? 3'd1 : 3'd0;
endmodule
```

### 4.3 실무 포인트
- **글리치**: 마스킹 트리 지연 차 → 순간 잘못된 코드 가능 → **출력 레지스터링**.  
- **그룹/하위그룹 인코더**로 확장(키보드 스캔, 인터럽트 우선순위).

---

## 5. 서로의 구현 관계(구조적 관점)

- **MUX ↔ 디코더/3-state**
  - 디코더(one-hot) + 3-state 버퍼 = **MUX**(버스 합선)
  - 디코더 + OR/NOR = **임의 SOP/POS 구현**
- **PLA/PLD/FPGA와 연결**
  - **PLA**: 제품항(디코더/AND 어레이) + OR 어레이 → **다중 출력**에 유리
  - **FPGA LUT(주로 6-LUT)**: 내부적으로 **MUX 트리**/SRL/RAM로 동작
  - 내부 버스는 **3-state 금지**: **LUT-MUX**로 구현

---

## 6. 타이밍·전력·신뢰성 포인트

1) **버스 충돌 방지**: 3-state 병렬 연결 시 **one-hot OE** 보장(디코더·중재기).  
2) **전환 타이밍**: 구동→Z, Z→구동 사이 **겹침/공백** 관리(\(t_{\text{dis}},t_{\text{en}}\)).  
3) **글리치 억제**: 재수렴 경로(디코더/인코더/MUX)에서 **레지스터 경계**로 동기화.  
4) **팬아웃/부하**: 디코더 출력은 부하 큼 → **버퍼** 삽입.  
5) **전력**: 3-state 버스는 미구동 시 정적전력↓, **버스 키퍼**는 약전류 소모.  
6) **FPGA 합성 주의**: 내부 3-state → **MUX**로 치환(기능 동일, 전기적 특성은 다름).

---

## 7. 설계 예제 — 끝까지 전개

### 7.1 4:1 MUX 기반 임의 함수 구현(샤논 전개)

**문제**: \(F(A,B,C)=A\overline{B}+BC\) 를 **4:1 MUX** 하나로 구현.  
**풀이**: 선택선 \(S_1S_0=AB\), 데이터 \(D_i=F|_{AB=i}\)
- \(AB=00\Rightarrow F=0\) → \(D_0=0\)  
- \(AB=01\Rightarrow F=BC\) → \(D_1=C\)  
- \(AB=10\Rightarrow F=A\overline{B}=1\) → \(D_2=1\)  
- \(AB=11\Rightarrow F=BC\Rightarrow C\) → \(D_3=C\)  
\(\Rightarrow\) 4:1 MUX의 입력을 \((D_3\!=\!C,D_2\!=\!1,D_1\!=\!C,D_0\!=\!0)\)로 배치.

### 7.2 3→8 디코더 + OR로 SOP 직접 구현
**문제**: \(F(A,B,C)=\sum m(1,2,6,7)\)  
**풀이**: 3→8 디코더 출력 \(Y_1,Y_2,Y_6,Y_7\)를 OR.  
- Active-Low 디코더라면 해당 라인들을 **NOR**에 연결.

**Verilog(개념)**
```verilog
wire [7:0] y;
decoder #(.N(3)) u_dec (.in({A,B,C}), .en(1'b1), .y(y));
assign F = y[1] | y[2] | y[6] | y[7];
```

### 7.3 Tri-State MUX로 외부 병렬 버스 공유
- 두 장치 \(X,Y\)가 D[15:0] 공유:  
  \(\overline{OE_X}=\overline{SEL_X}\), \(\overline{OE_Y}=\overline{SEL_Y}\), **SEL 상호배타**.  
- **버스 키퍼** 삽입, 전환 시 **Z 공백 시간** 보장.

**Verilog(외부 I/O 가정)**
```verilog
assign D = (SEL_X) ? X_data : 16'bz;
assign D = (SEL_Y) ? Y_data : 16'bz;
```

### 7.4 8→3 우선순위 인코더 + 유효 플래그
**검증 아이디어**: 랜덤 입력에서 `v==0`이면 코드 무시, 다중 1이면 **최상위**가 출력되는지 체크.

**SystemVerilog TB 스니펫**
```verilog
logic [7:0] d; logic [2:0] a; logic v;
prienc8 dut(.d(d), .a(a), .v(v));

initial repeat (1000) begin
  d = $urandom();
  #1;
  if (d==0) assert(v==0);
  else begin
    int i;
    for (i=7;i>=0;i--) if (d[i]) begin
      assert(v==1 && a==i[2:0]); break;
    end
  end
end
```

---

## 8. 해저드/타이밍 심화

### 8.1 MUX에서의 글리치 원인
- **선택선 vs 데이터** 경로 지연이 달라, \(D_0\to D_1\) 전환 시 순간 잘못된 경로 통과.  
- **완화**:  
  1) **출력 래칭**(동기 샘플)  
  2) 선택선/데이터 **동일 논리 깊이**로 배치  
  3) **2:1 MUX 계층**으로 균형 잡힌 트리 구성

### 8.2 디코더 글리치
- 입력 비트 전환 시 **기존 minterm 해제**와 **새 minterm 설정**이 **완벽 동시**가 아님 → **OR 합산부**에서 스파이크.  
- **완화**: EN으로 비활성 기간 확보, 출력 레지스터, **합의항**(논리적 중첩) 추가(PLA 관점).

### 8.3 Tri-State 전환 타이밍
- 이전 구동기 **disable** \(t_{\text{dis}}\) 후, 다음 구동기 **enable** \(t_{\text{en}}\) 이전에 **Z 시간 확보**.  
- 반대로 공백 과도하면 **부유** → 버스 키퍼/풀업·풀다운으로 안정.

---

## 9. 구현 모듈 모음(Verilog)

### 9.1 4:1 MUX (단일 비트/버스 버전)
```verilog
module mux4 #(parameter W=1)(
  input  [W-1:0] D0,D1,D2,D3,
  input  [1:0]   S,
  output [W-1:0] Y
);
  assign Y = (S==2'b00)? D0 :
             (S==2'b01)? D1 :
             (S==2'b10)? D2 : D3;
endmodule
```

### 9.2 3→8 디코더(Active-High)
```verilog
module dec3to8(input [2:0] a, input en, output [7:0] y);
  assign y = en ? (8'b1 << a) : 8'b0;
endmodule
```

### 9.3 8→3 인코더 & 우선순위 인코더
```verilog
module enc8to3(input [7:0] d, output [2:0] a);
  // one-hot 가정
  assign a = d[7]?3'd7: d[6]?3'd6: d[5]?3'd5: d[4]?3'd4:
             d[3]?3'd3: d[2]?3'd2: d[1]?3'd1: 3'd0;
endmodule

module prienc8(input [7:0] d, output [2:0] a, output v);
  assign v = |d;
  assign a = d[7]?3'd7: d[6]?3'd6: d[5]?3'd5: d[4]?3'd4:
             d[3]?3'd3: d[2]?3'd2: d[1]?3'd1: 3'd0;
endmodule
```

### 9.4 Tri-State 버퍼(시뮬레이션용)
```verilog
module tristate #(parameter W=8) (input [W-1:0] A, input OE, inout [W-1:0] Y);
  assign Y = OE ? A : {W{1'bz}};
endmodule
```

---

## 10. 자주 하는 실수 & 체크리스트

- [ ] **Tri-State 병렬 연결**에서 OE 상호배타 보장(디코더/중재기 확실?).  
- [ ] 디코더 기반 SOP 구현 시 **글리치** 고려(EN, 레지스터링, 합의항).  
- [ ] MUX 트리에서 **선택선/데이터 경로 깊이** 균형.  
- [ ] 대형 디코더는 **프리디코더** 사용으로 팬인·배선·속도 최적화.  
- [ ] FPGA 내부 **3-state 금지** → **LUT-MUX 치환**을 전제로 타이밍/전력 분석.  
- [ ] 우선순위 인코더는 **유효 플래그(V)** 와 **다중 1**의 정의된 동작을 명시.  
- [ ] 버스 전환 \(t_{\text{dis}},t_{\text{en}}\) **타이밍 마진** 확인(공백/겹침 불가).

---

## 11. 연습문제(필요 시 해설 제공)

1) **4:1 MUX 하나**로 \(F(A,B,C)=A\overline{B}+BC\) 를 구현하라(선택선/데이터 값 제시).  
2) **3→8 디코더** + **3-state 버퍼**로 **8:1 MUX** 를 구성하고, \(t_{\text{dis}}\), \(t_{\text{en}}\)을 포함한 전환 타이밍 표를 작성하라.  
3) **8→3 우선순위 인코더**의 출력 식을 (a) 단순 OR 기반, (b) 마스킹 기반으로 제시하고, \(D_6=1, D_5=1\) 일 때 두 접근의 차이를 설명하라.  
4) **Active-Low 4→16 디코더** 두 개로 **5→32** 를 구성하는 캐스케이드(EN 로직 포함)를 그려라.  
5) **디코더 + OR**로 구현한 SOP 회로에서 글리치를 줄이는 세 가지 방법을 제시하고, K-map 중첩/합의항 관점에서 설명하라.

---

## 12. 포켓 요약
- **MUX**: 선택선으로 한 입력만 통과. **샤논 전개**로 임의 함수 구현, 트리로 지연 균형.  
- **3-State**: 0/1/Z. **버스 공유** 핵심. **충돌 금지**, 전환 타이밍 확보, **버스 키퍼** 고려.  
- **디코더**: 이진→one-hot. **SOP/POS** 구현의 기반, 메모리/IO 선택.  
- **인코더/우선순위**: one-hot/다중 1 → 이진 코드. **유효 플래그**와 마스킹 트리.  
- **현대 FPGA**: 내부 3-state 없음 → **LUT-MUX** 치환 전제로 설계/타이밍.