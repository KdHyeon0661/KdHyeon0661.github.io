---
layout: post
title: 컴퓨터시스템 - 파이프라이닝의 일반 원리
date: 2025-07-26 22:20:23 +0900
category: 컴퓨터시스템
---
# 파이프라이닝의 일반 원리 — 자세한 정리

파이프라이닝(pipelining)은 **하나의 명령어 처리를 여러 단계(stage)** 로 나누고, 서로 다른 명령어들이 **동시에 각기 다른 단계**에서 처리되도록 하여 처리량(throughput)을 높이는 기법입니다. 하드웨어 자원을 여러 단계로 분해해 동작을 병렬화함으로써, 단일 명령어의 지연(latency)은 유지되거나 약간 증가할 수 있지만 전체 시스템의 초당 수행 명령수(throughput)가 크게 증가합니다.

아래는 파이프라이닝의 목적·구조·성능·문제(위험, hazard)·해결법·설계 고려사항·컴파일러 관점 등을 포괄적으로 정리한 내용입니다.

---

## 1. 기본 개념과 목표

- **아이디어**: 명령어 처리의 단계를 분해하여 각 단계가 서로 다른 명령어의 작업을 동시에 수행하게 한다.  
- **예시(5단계 파이프라인)**: 전형적인 단순 파이프라인 단계
  1. IF — Instruction Fetch (명령 인출)
  2. ID — Instruction Decode / Register Fetch (디코드 및 레지스터 읽기)
  3. EX — Execute / Address Calculation (ALU 연산)
  4. MEM — Memory access (데이터 메모리 읽기/쓰기)
  5. WB — Write Back (레지스터에 결과 쓰기)

- **목표**: 처리량(throughput) 향상 — 이상적으론 파이프라인 단계 수 \(k\) 배의 성능 향상(ideal speedup \(\approx k\)).

---

## 2. 시간선(diagram) — 파이프라인 동작 예

다음은 3개 명령어(I1, I2, I3)가 5단계 파이프라인에서 어떻게 겹쳐서 실행되는지의 간단한 타임라인(사이클 단위)입니다.

```
Cycle:   1   2   3   4   5   6   7
I1:     IF  ID  EX  MEM WB
I2:         IF  ID  EX  MEM WB
I3:             IF  ID  EX  MEM WB
```

- 처음 몇 사이클은 파이프라인을 `채우는(fill)` 단계이고, 마지막은 `비우는(drain)` 단계입니다.
- 많은 명령어가 실행되면 평균적으로 한 사이클에 한 명령어가 완료되는 이상적 상태(=CPI ≈ 1)에 근접합니다.

---

## 3. 성능 모델

### 3.1 이상적(ideal) 성능
- 단일-사이클(비파이프라인) CPU에서 한 명령어 수행에 필요한 시간 = \(T_\text{single}\).
- 파이프라인을 \(k\) 단계로 쪼갤 수 있고, 각 단계의 **최대 지연**이 \(T_\text{stage}\)라면 파이프라인 클럭 주기 \(T_{clk} \approx T_\text{stage} + T_{reg}\) (파이프라인 레지스터 오버헤드 포함).
- 이상적인 수렴(입출력이 충분히 긴 프로그램)에서는 **처음의 채우기·비우기 오버헤드**를 무시하면 한 사이클에 한 명령어가 완료되므로:
  - 이상적 throughput ≈ \(1/T_{clk}\)
  - 이상적 속도향상 (speedup) ≈ \(\dfrac{T_\text{single}}{T_{clk}} \approx k\) (단순 근사)

### 3.2 현실적 성능
- 현실에서는 다음과 같은 요인들이 이상적 성능을 떨어뜨립니다:
  - 파이프라인 버블(bubbles) 또는 정지(stalls) — 위험(hazard) 때문에 들어오는 빈 시간
  - 파이프라인 레지스터(플립플롭) 오버헤드: 레지스터 세팅/타이밍이 추가되어 \(T_{clk}\)가 증가
  - 불균형한 스테이지 길이(일부 단계가 길어서 전체 클럭을 제한)
  - 제어 및 데이터 의존으로 발생하는 페널티

- **CPI 관계식(단일 이슈 파이프라인)**:
  \[
  \text{CPI} = 1 + \text{stalls per instruction}
  \]
  예를 들어 전체 명령 중 분기(branch)에 의해 평균 \(b\)개의 스톨이 발생하고 명령의 \(f_b\) 비율만큼 분기가 존재하면  
  \[
  \text{stalls per instruction} \approx f_b \cdot b
  \]
  따라서 실제 CPI = \(1 + f_b\cdot b + \ldots\) (다른 hazard 원인 포함)

---

## 4. 파이프라인에서 발생하는 위험(Hazards)

파이프라인의 핵심 문제는 **hazard** — 즉 한 명령어의 처리 결과가 다음 명령어의 처리 조건(데이터, 제어, 자원)에 영향을 주어 오류 또는 불일치를 초래할 가능성입니다. 위험의 세 가지 유형:

### 4.1 구조적 위험 (Structural hazard)
- **정의**: 하드웨어 자원의 부족으로 두 개 이상의 단계가 같은 자원을 동시에 사용하려 할 때 발생.
- **예시**: 명령어 접근과 데이터 접근에 같은 메모리를 사용하는 Von Neumann 구조에서 IF와 MEM이 동시에 메모리를 사용하려 할 때.
- **해결책**:
  - 자원 복제 (예: 인스트럭션 메모리와 데이터 메모리를 분리 — Harvard 구조)
  - 파이프라인 스톨(하드웨어가 더 기다리게 함)
  - 설계 시 자원 충돌이 나지 않도록 기능 분배

### 4.2 데이터 위험 (Data hazard)
- **정의**: 한 명령어가 생성하는 데이터(레지스터 값 등)를 후속 명령어가 필요로 하는 경우.
- 주요 클래스 (의존성 유형):
  - **RAW(Read After Write)**: 후속 명령어가 이전 명령어가 쓴 값을 읽음 (가장 흔함)
  - **WAR(Write After Read)**: 후속 명령어가 이전 명령어가 읽기 전에 쓰기를 수행하는 경우 (파이프라인에서 드물지만 일부 구조에서 발생)
  - **WAW(Write After Write)**: 두 명령어가 같은 목적지에 쓰는 순서 의존
- **예시 (RAW)**:
  ```
  I1: add $t0, $t1, $t2   # t0 = t1 + t2
  I2: sub $t3, $t0, $t4   # uses t0 produced by I1
  ```
- **해결책**:
  - **Forwarding / Bypassing**: ALU의 출력이 파이프라인 레지스터에 쓰여지기 전에 바로 다음 명령의 ALU 입력으로 경로를 연결해 버리는 방법. 대부분 RAW를 제거.
  - **Pipeline interlock (stall)**: 하드웨어가 자동으로 스톨을 삽입해 값이 준비될 때까지 기다리게 함 (예: load-use hazard).
  - **컴파일러 수준 스케줄링**: 명령어 재배열로 의존성 간격 벌리기 (instruction scheduling), 또는 레지스터 할당 최적화.
- **특히 load-use hazard**: 메모리에서 로드된 값은 MEM 단계에서 읽혀서 다음 명령 EX에서 필요하면 1사이클 이상의 스톨 필요. Forwarding으로도 해결 안 될 때가 있음(일부 구현에서는 MEM→EX 포워딩으로 1사이클만 고침).

### 4.3 제어 위험 (Control hazard, Branch hazard)
- **정의**: 분기(branch/jump) 명령어 때문에 다음에 실행할 명령의 주소(PC)가 불확실하여 IF 단계에서 무엇을 인출해야 할지 알 수 없는 상황.
- **문제**: 분기 결과(분기 발생/분기 대상 주소 계산)가 언제 결정되느냐에 따라 파이프라인이 잘못된 명령을 계속 인출할 수 있고, 잘못된 명령을 파이프라인에서 제거(flush)해야 함.
- **해결책**:
  - **정적 분기 예측** (e.g., predict-not-taken or predict-taken, delayed branch): 간단하지만 정확도 낮음
  - **동적 분기 예측** (branch predictor): 1-bit/2-bit saturating counter, global history, bimodal, two-level adaptive, tournament predictor 등
  - **Branch Target Buffer (BTB)**: 이전 분기대상 주소를 캐시해 즉시 fetch 지시
  - **분기 명령 빨리 해석(ID stage에서 결정)**: 분기를 ID에서 해결하면 페널티 줄어듦(상황에 따라 설계)
  - **프로그램/컴파일러 기법**: 분기 지연 슬롯(delayed branch), 코드 재배열 등
  - **Speculative execution**: 예측에 따라 명령을 실행하고, 잘못되면 결과를 폐기 (모던 CPU에서 필수적)

---

## 5. Forwarding(바이패스)와 Hazard Detection

### 5.1 Forwarding (bypass)
- **아이디어**: ALU 연산 결과가 파이프라인 레지스터에 쓰이기 전이라도 그 출력을 직접 다음 단계(예: EX의 입력)에 공급한다.
- 일반적으로 두 경로를 제공:
  - EX/MEM → EX (직접 ALU 결과를 다음 EX에 공급)
  - MEM/WB → EX (메모리에서 온 값 또는 write-back 직전 값 공급)
- **하드웨어 요소**: MUX를 ALU 입력에 두고 forwarding control logic이 어떤 소스(레지스터 파일 값 vs EX/MEM vs MEM/WB)를 선택할지 제어.
- **효과**: 대부분의 RAW hazard를 제거하여 스톨을 줄임.

### 5.2 Hazard Detection Unit (HDU)
- **역할**: 파이프라인 상태(현재 IF/ID/EX/MEM/WB 레지스터)와 명령 유형을 검사해 스톨이나 버블 삽입을 결정.
- **전형적 동작**:
  - load-use 경우: 만약 EX 단계의 명령이 `load`이고 ID 단계의 명령이 그 로드된 레지스터를 소스(reg)를 사용하면, HDU는 **IF/ID를 스톨**시키고 ID/EX에 NOP(버블)을 삽입한다.
  - 분기시: HDU는 분기 해결 전 다음 명령 fetch를 어떻게 할지(예측) 결정하고, 잘못된 경우 IF/ID 이하를 flush.

---

## 6. 분기 처리와 파이프라인 페널티

- 분기가 파이프라인에서 해결되는 **단계(stage)** 에 따라 발생하는 분기 지연(branch penalty)이 달라집니다. 예컨대 분기를 EX에서 결정하면 EX 단계까지 잘못된 명령들이 들어가고 이들을 제거해야 하므로 페널티가 길어집니다.
- **분기 페널티** = 분기 명령으로 인해 파이프라인에 삽입되어야 하는 버블(빈사이클) 수.
- **Branch prediction**이 정확하면 페널티 거의 0; 틀리면 예측으로 인출된 명령들을 모두 flush하고 올바른 경로를 인출해야 하므로 큰 페널티.
- **대체 기법**:
  - **Delayed branches**: 분기 다음의 한두 명령어를 항상 실행(컴파일러에 의해 유효한 명령 배치 필요).
  - **Early branch resolution**: branch logic을 더 빨리(예: ID 단계) 결정하도록 하드웨어 설계.
  - **Speculation + ROB**: 분기 예측 따라 실행하지만 commit은 순서대로(정밀 예외를 위해) — out-of-order CPU에서 쓰임.

---

## 7. 파이프라인 레지스터와 설계 요소

- 각 스테이지 사이에 **파이프라인 레지스터**(pipeline registers, latch/flip-flop)를 둡니다. 이들은 단계간 신호와 데이터를 보존하여 동기화합니다.
- 파이프라인 레지스터는 클록에 타이밍 제약(setup/hold time, clock-to-Q delay)을 부과하므로, **파이프라인 깊이를 늘리면 레지스터 오버헤드가 증가**해 단일 스테이지 실행 시간(\(T_{clk}\))이 줄어드는 효과를 상쇄할 수 있습니다.
- **스테이지 밸런싱(stage balancing)**: 각 스테이지의 지연을 가능한 균등하게 하여 가장 긴 스테이지에 의해 전체 클록이 제한되지 않게 함.

---

## 8. 설계 고려사항 및 트레이드오프

1. **깊이 vs 클럭 주파수**  
   - 파이프라인을 더 많은 단계로 쪼개면 이론적으로 클럭 주파수를 높일 수 있지만, 레지스터 오버헤드와 제어 복잡도, 분기·데이터 위험으로 인한 스톨 증가 등으로 기대한 성능 향상이 제한될 수 있음.

2. **파이프라인 복잡도**  
   - forwarding 경로, hazard logic, branch predictor 등의 추가는 하드웨어 복잡도와 전력 소비 증가로 이어짐.

3. **정밀한 예외 처리(precise exceptions)**  
   - 파이프라인에서 예외가 발생하면 이전에 완료된 명령만 커밋되도록 보장해야 하므로 설계를 복잡하게 만듦(예: reorder buffer 사용).

4. **명령 집합(ISA) 영향**  
   - 어떤 ISA는 분기 지연 슬롯이나 특정 주소 지정 모드 때문에 파이프라인 설계가 달라짐. (예: MIPS는 단순화된 파이프라인 친화적 ISA 설계)

5. **파이프라인의 자주 발생하는 병목**  
   - Memory access latency(캐시 미스), branch misprediction rate, long-latency operations(FP multiply/divide) 등.

---

## 9. 컴파일러와 소프트웨어 기법

- **Instruction scheduling**: 컴파일러가 독립적인 명령으로 위험을 덮도록 명령을 재배열하여 스톨을 줄임.
- **Loop unrolling**: 분기 빈도를 줄여 branch penalty를 낮추고 ILP(Instruction-Level Parallelism)를 높임.
- **Register renaming / graph coloring**: 가상 레지스터를 실제 레지스터로 매핑할 때 WAW/WAR 문제를 줄임(특히 OOO 구현에서 유용).
- **Speculation-friendly code transformations**: 예측 정확도 높이는 재배치 등.

---

## 10. 파이프라인 하드웨어 예시 (간단한 forwarding + HDU 제어 논리 의사코드)

### 10.1 Forwarding control (의사)
```text
# EX stage inputs need rs and rt (source registers)
if (EX.rs == MEM.rd and MEM.regWrite) forwardA = FROM_MEM
else if (EX.rs == WB.rd and WB.regWrite) forwardA = FROM_WB
else forwardA = FROM_REGFILE

# 동일하게 forwardB for EX.rt
```

### 10.2 Hazard detection for load-use (의사)
```text
# If instruction in EX is a load and ID stage instruction needs the loaded register:
if (EX.op == LOAD and (ID.rs == EX.rd or ID.rt == EX.rd)) {
    stall IF/ID;         # do not fetch new instruction
    insert bubble into ID/EX (i.e., set ID/EX to NOP)
    do not advance PC
}
```

---

## 11. 고급: Superscalar / Out-of-Order / Tomasulo 연계

- **Superscalar**: 한 사이클에 여러 명령을 issue (파이프라인 단일 이슈 → 다중 이슈로 확장). 이 때도 파이프라이닝 원리가 적용되지만 동일 스테이지에서 복수의 명령을 동시에 다룰 수 있는 복수의 실행 유닛이 필요.
- **Out-of-Order Execution**: 의존성에 따라 명령을 재정렬하여 실행 가능한 명령을 먼저 실행(기계적 ILP 최대화). 이를 위해 **scoreboard** 또는 **Tomasulo algorithm**과 **Reorder Buffer(ROB)** 같은 구조가 도입됨.
- **정밀성(precise exceptions)** 도 중요: OUT-OF-ORDER에서 명령이 커밋되는 시점을 제어하여 예외를 순서대로 처리.

---

## 12. 실무 설계 팁 요약

- 파이프라인을 설계할 때는 **가장 긴 단계**(critical path)를 줄이도록 노력하라.
- **Forwarding**을 구현하면 대부분의 RAW를 제거할 수 있으나, **load-use**는 별도 처리 필요.
- **Branch penalty**를 줄이기 위해 early resolution, 좋은 branch predictor, BTB, RAS(return address stack) 등을 고려하라.
- CPI 모델링: 실제 CPI = 1 + 스톨/명령을 측정·예측하여 아키텍처 설계 결정을 내리자.
- 컴파일러와 하드웨어는 서로 보완: 컴파일러로 스케줄링·루프 변환을 하면 하드웨어 부담을 줄일 수 있다.

---

## 13. 예제 — 파이프라인 스케줄링 표 (forwarding 없음 vs forwarding 있음)

### 명령어(의사 MIPS):
```
I1: lw   r1, 0(r2)      # load r1 from memory
I2: add  r3, r1, r4     # use r1 immediately
I3: add  r5, r3, r6
```

#### (A) **Forwarding 없음**
타임라인(사이클) — 각 명령의 단계:
```
Cycle:   1 2 3 4 5 6 7 8
I1      IF ID EX MEM WB
I2        IF ID -- stall EX MEM WB
I3          IF ID -- -- stall EX MEM WB
```
- I2는 I1의 로드 데이터가 MEM 단계 종료 후에야 준비되므로 I2의 EX는 I1.MEM 이후에야 가능 → 여러 버블 발생

#### (B) **Forwarding 있음 (단, load-use는 still 1-cycle stall)**  
```
Cycle:   1 2 3 4 5 6 7
I1      IF ID EX MEM WB
I2        IF ID stall EX MEM WB
I3          IF ID EX MEM WB
```
- I2와 I3의 RAW 대부분이 제거되지만 load-use는 1사이클 정지 필요.

---

## 14. 결론 (요약)

- 파이프라이닝은 **동시에 여러 명령을 병렬로 처리**하여 처리량을 높이는 핵심 기법이다.  
- 그러나 **hazard(구조적/데이터/제어)** 때문에 이상적 속도향상을 그대로 얻기는 어렵다.  
- 하드웨어 기술(포워딩, 분기 예측), 소프트웨어 기술(명령 스케줄링), 그리고 아키텍처적 트레이드오프(스테이지 수, 레지스터 오버헤드)를 함께 고려해야 한다.  
- 복잡한 현대 CPU는 파이프라이닝을 기반으로 추가적인 스칼라성(슈퍼스칼라), 동적 실행(Out-of-Order), 예측(Branch Prediction) 등을 결합하여 높은 IPC(Instruction per Cycle)를 달성한다.
