---
layout: post
title: 컴퓨터시스템 - 파이프라이닝의 일반 원리
date: 2025-07-26 22:20:23 +0900
category: 컴퓨터시스템
---
# 파이프라이닝의 일반 원리

## 0. 개요 — 왜 파이프라이닝인가?

- 단일 명령의 지연(latency)은 크게 줄지 않더라도, **서로 다른 명령을 다른 단계에서 동시에** 처리하면 **처리량(throughput)** 이 커진다.
- 설계 난점은 **해저드(hazard)** 와 **제어 복잡도**. 이를 해결하려 **포워딩·스톨/버블·플러시·분기예측** 같은 제어를 도입한다.

---

## 1. 기본 개념과 5-Stage 모델

### 1.1 스테이지 정의
- **IF** (Instruction Fetch): 명령어 인출, 다음 PC 후보 계산
- **ID** (Instruction Decode/Register Fetch): 디코드 및 레지스터 읽기, 제어신호 생성
- **EX** (Execute/Address Calc): ALU 연산, 분기조건/타겟 계산
- **MEM** (Memory): 데이터 메모리 읽기/쓰기
- **WB** (Write Back): 목적 레지스터에 결과 기록(커밋)

### 1.2 시간선(채움과 비움)
```
Cycle:  1   2   3   4   5   6   7
I1:    IF  ID  EX MEM  WB
I2:        IF  ID  EX MEM  WB
I3:            IF  ID  EX MEM  WB
```
- **Warm-up(fill)**: 초반 4사이클은 파이프를 채우는 구간.
- **Steady state**: 충분히 길면 **사이클당 1명령 완료(CPI≈1)** 에 접근.
- **Drain**: 마지막 명령이 WB까지 빠져나오는 구간.

---

## 2. 성능 모델 — 이상과 현실

### 2.1 이상적 속도향상
파이프라인이 \(k\) 단계이고 각 단계 지연의 최댓값을 \(T_\text{stage}\), 레지스터 오버헤드를 \(T_\text{reg}\)라 하면 클럭은
$$
T_{clk} \approx T_\text{stage} + T_\text{reg}.
$$
비파이프라인(단일 사이클) 지연이 \(T_\text{single}\)일 때, 충분히 긴 실행에서
$$
\text{Speedup} \approx \frac{T_\text{single}}{T_{clk}} \;\approx\; k
$$
(이상적 근사).

### 2.2 현실적 CPI
해저드로 인한 **버블/스톨** 때문에 실제 CPI는
$$
\text{CPI} \;=\; 1 \;+\; \text{stalls per instruction}.
$$
예를 들어 분기 비율 \(f_b\), 미스율 \(m\), 미스 페널티 \(p\) (사이클)면 분기 기여는
$$
\Delta\text{CPI}_{br} \approx f_b \cdot m \cdot p.
$$
여기에 **load-use 스톨**, **캐시 미스**, **멀티사이클 실행**의 추가 스톨을 더한다.

> **예시 계산**: \(f_b=0.2\), \(m=0.4\), \(p=3\)이면 \(0.2\times0.4=0.08\); \(0.08\times3=0.24\).
> load-use 평균 0.1 사이클이면 총 \(1+0.24+0.1=1.34\) → **CPI≈1.34**.

---

## 3. 파이프라인 레지스터·스테이지 균형

### 3.1 파이프라인 레지스터의 비용
- 각 경계에 **FF/Latch**가 들어가며 \(T_{reg}\) (setup/hold + clk-to-Q)만큼 오버헤드.
- 단계 수를 늘리면 \(T_\text{stage}\)는 줄어도 \(T_{reg}\) 누적이 커져 **한계 주파수**가 포화.

### 3.2 스테이지 밸런싱
- 전체 성능은 **가장 긴 스테이지(critical path)** 가 제한.
- EX가 길다면 일부 주소계산/분기판정을 ID로 당기거나, MEM을 둘로 나누는 등 **균형 조정**을 고려.

---

## 4. 해저드 총론 — 구조·데이터·제어

### 4.1 구조적(Structural)
- 동일 사이클에 동일 자원을 둘 이상이 필요.
  **예:** IF와 MEM이 **단일 포트 메모리**를 동시에 요구.
- **해결:** 자원 복제(분리 I-cache/D-cache), 멀티포트, 스케줄링으로 충돌 회피, 마지막 수단으로 **스톨**.

### 4.2 데이터(Data)
- **RAW (Read-After-Write)**: 뒤 명령이 앞 명령의 결과를 읽음 — 가장 흔함.
- **WAR/WAW**: 단일-이슈 인오더에서는 드묾(OOO/VLIW에서는 고려).
- **대표 사례(load-use):** 로드 결과는 MEM 후에야 준비 → 다음 EX에서 필요 시 **1 스톨** 필요(포워딩만으로 불가).

### 4.3 제어(Control)
- 분기/점프로 PC가 바뀔지 불확실 → 잘못된 경로 인출을 **플러시**해야 함.
- **해결:** 정적/동적 **분기예측**, **BTB(타겟 캐시)**, **RAS(리턴 주소 스택)**, 또는 **조기 판정(earlier stage resolution)**.

---

## 5. 포워딩(바이패스) — RAW를 없애는 기본기

### 5.1 아이디어
- **레지스터에 기록되기 전에** ALU 결과/로드 결과를 **곧바로** 다음 EX 입력으로 공급.
- 입력 MUX 선택: **EX/MEM → EX** 가 최우선, 그다음 **MEM/WB → EX**.

### 5.2 의사 제어(단일 소스)
```text
if (EX.rs == MEM.rd && MEM.regWrite)  forwardA = FROM_MEM;
else if (EX.rs == WB.rd && WB.regWrite) forwardA = FROM_WB;
else forwardA = FROM_REGFILE;
```
- `forwardB`도 동일.

### 5.3 한계: load-use
- 로드의 결과는 **MEM 끝**에서야 나옴.
- 다음 명령이 **바로 EX**에서 요구하면 **1 스톨**(IF/ID 유지 + ID/EX 버블)이 필요.

---

## 6. 해저드 검출(HDU) — 스톨/버블/플러시

### 6.1 load-use 규칙(전형)
```text
if (ID.uses(EX.rd) && EX.op == LOAD) {
    stall IF/ID;         # PC/IF 유지
    bubble ID/EX;        # NOP 주입
}
```

### 6.2 분기 미스(예측 실패)
- **정책 예: predict-not-taken**
  EX에서 taken 판정되면 **잘못 인출된 IF/ID 이하**를 **flush**.
- 페널티는 **분기 결정 스테이지까지의 깊이**에 비례(보통 2~3 사이클).

### 6.3 ret/간접분기
- 타겟이 **메모리에서 나오는 경우**(예: return addr) → 타겟 준비까지 **IF stall** 정책이 단순.

---

## 7. 분기예측 — 정적부터 동적까지

### 7.1 정적(간단)
- **Always-not-taken** / **Always-taken**
- **Backward-taken/Forward-not-taken**(루프 친화)

### 7.2 동적(하드웨어)
- **1-bit/2-bit 포화 카운터**: 상태기계로 최근 결과 반영.
- **Bimodal vs Gshare vs Tournament**: 전역/지역 히스토리 활용.
- **BTB**: 분기 발견 즉시 **타겟 PC** 제공 → IF 사이클 절약.
- **RAS**: `call/ret` 짝에 대해 리턴 주소 추측 정확도 상승.

### 7.3 예: 2-bit 카운터 상태
| 상태 | 예측 | 업데이트(성공/실패) |
|------|------|---------------------|
| 강한 NT | NT | 실패→약한 NT |
| 약한 NT | NT | 실패→약한 T, 성공→강한 NT |
| 약한 T  | T  | 실패→약한 NT, 성공→강한 T |
| 강한 T  | T  | 실패→약한 T |

---

## 8. 메모리·캐시와 파이프라인

### 8.1 I/D 분리(구조 해저드 제거)
- IF와 MEM이 동시에 접근 가능 → **Harvard** 구조가 파이프라인에 유리.

### 8.2 캐시 미스 스톨
- **I-miss**: IF 자체가 막힘 → 파이프 전체가 굳는다.
- **D-miss**: MEM 단계에서 대기 → 뒤 명령은 interlock으로 정지.
- **Non-blocking cache/MSHR** 로 **다중 미스**를 걸어두는 구조(복잡성↑).

---

## 9. 멀티사이클 실행 유닛과 파이프라이닝

### 9.1 FP/문자열/나눗셈 같은 **긴 지연**
- **Latency(지연)** 와 **Initiation Interval(II)** 을 분리:
  - Latency = 결과가 나오기까지의 사이클 수
  - II = 새 명령을 해당 유닛에 투입 가능한 간격
- **파이프라인된 FP MUL**: Latency=4, II=1 → 매 사이클 새 MUL 시작 가능(Throughput↑).
- **비파이프라인 DIV**: Latency=20, II=20 → 병목.

### 9.2 스케줄링/Scoreboard
- 인오더 단일-이슈라도 **장기 유닛 사용 중**이면 뒤 명령을 **스톨**하거나 **독립 명령 먼저** 실행.

---

## 10. 컴파일러와 소프트웨어 기법

### 10.1 Instruction Scheduling
- RAW 간격이 좁은 코드에 **독립 명령** 삽입/재배열로 **스톨 흡수**.
```asm
# Before
lw   r1, 0(r2)
add  r3, r1, r4   # load-use → 1스톨

# After (재배열)
lw   r1, 0(r2)
xor  r7, r7, r7   # 독립 작업으로 간격 벌림
add  r3, r1, r4
```

### 10.2 Loop Unrolling
- 분기 빈도↓, 레지스터 재사용↑, 포워딩 기회↑.

### 10.3 Software Pipelining(이름은 같지만 컴파일러 기법)
- 서로 다른 반복의 단계들을 겹치게 스케줄(II 최소화). VLIW/EPIC에서 흔함.

---

## 11. 설계·제어 의사코드 (정수 5-stage 가정)

### 11.1 포워딩 선택 (ALU A/B)
```text
# A
if (EX.rs == MEM.rd && MEM.regWrite)      selA = MEM.valE;
else if (EX.rs == WB.rd && WB.regWrite)   selA = WB.val;
else                                       selA = ID.valA;

# B
if (EX.rt == MEM.rd && MEM.regWrite)      selB = MEM.valE;
else if (EX.rt == WB.rd && WB.regWrite)   selB = WB.val;
else                                       selB = ID.valB;
```

### 11.2 load-use interlock
```text
if (EX.isLoad && (ID.rs == EX.rd || ID.rt == EX.rd)) {
    stall(IF, ID);        # PC/IF/ID 유지
    bubble(EX);           # ID/EX <- NOP
}
```

### 11.3 분기 처리 (predict-not-taken)
```text
# EX에서 분기결정
if (EX.isBranch && EX.taken) {
    flush(IF, ID);        # 잘못 인출 제거
    setPC(EX.target);
} else {
    setPC(ID.nextPC);     # 기본 valP
}
```

### 11.4 ret/간접분기
```text
if (pipeHasRET) stall(IF);         # 타겟 준비될 때까지 IF 멈춤
if (RET.targetReady) setPC(RET.pc);
```

---

## 12. 표·도표로 보는 핵심 규칙

### 12.1 위험과 해법 요약
| 위험 | 원인 | 대표 해결 |
|------|------|-----------|
| 구조 | 자원 충돌 | I/D 분리, 멀티포트, 스톨 |
| RAW  | 결과→다음 입력 | 포워딩, 스케줄링 |
| load-use | 로드 결과 늦음 | 1 스톨(+가능하면 MEM→EX 포워딩) |
| 제어 | 분기/ret | 예측+BTB/RAS, 플러시, 조기판정 |

### 12.2 분기예측 구성 요소
| 요소 | 역할 | 이점 |
|------|------|------|
| Predictor(2-bit) | taken 여부 예측 | 정확도↑ |
| BTB | 타겟 PC 캐시 | IF 즉시 타겟 인출 |
| RAS | call/ret 짝 | 리턴 추측 정확↑ |

---

## 13. 예제—타임라인 비교 (forwarding 없음 vs 있음)

### 13.1 명령열
```
I1: lw   r1, 0(r2)
I2: add  r3, r1, r4
I3: add  r5, r3, r6
```

#### (A) 포워딩 없음
```
Cycle:  1 2 3 4 5 6 7 8
I1     IF ID EX ME WB
I2       IF ID -- ST EX ME WB
I3         IF ID -- -- ST EX ME WB
```

#### (B) 포워딩 있음(단, load-use는 1 스톨)
```
Cycle:  1 2 3 4 5 6 7
I1     IF ID EX ME WB
I2       IF ID ST EX ME WB
I3         IF ID EX ME WB
```

---

## 14. 수식으로 보는 CPI 모델(확장)

총 스톨 기여를 쪼개면
$$
\text{CPI} \;=\; 1
\;+\; f_{br} \cdot m_{br} \cdot p_{br}
\;+\; f_{ld} \cdot p_{ld\text{-}use}
\;+\; r_{I\text{-}miss}\cdot L_{I}
\;+\; r_{D\text{-}miss}\cdot L_{D}
\;+\; \sum_{u\in \text{멀티사이클}} r_u \cdot p_u.
$$
- \(f_{br}\): 분기 비율, \(m_{br}\): 미스율, \(p_{br}\): 미스 페널티
- \(f_{ld}\): 로드 비율, \(p_{ld\text{-}use}\): load-use 평균 스톨
- \(r_{I\text{-}miss}, r_{D\text{-}miss}\): I/D 미스율, \(L_I,L_D\): 미스 지연(사이클)
- \(r_u\): 특정 유닛 사용률, \(p_u\): 그에 따른 추가 스톨

---

## 15. 실습용 미니 시뮬레이터(의사 코드)

> 개념 검증을 위한 **단일-이슈 5-stage** 파이프라인 프레임. 실제 코딩 시 상태·제어 신호를 구조체로 명확히 분리하라.

```c
// 핵심 파이프 상태
struct IF_ID { Instr inst; uint64_t pc; bool valid; } if_id;
struct ID_EX { Decoded d;  uint64_t pc; bool valid; } id_ex;
struct EX_MEM{ ExeOut x;   uint64_t pc; bool valid; } ex_mem;
struct MEM_WB{ MemOut m;   uint64_t pc; bool valid; } mem_wb;

// 한 사이클
void step() {
  // 1) 쓰기백
  if (mem_wb.valid) writeback(mem_wb);

  // 2) 메모리
  MemOut m = mem_stage(ex_mem);

  // 3) 실행 (포워딩)
  ExeIn xin = build_exe_inputs(id_ex, ex_mem, mem_wb); // forwarding mux
  ExeOut x  = ex_stage(xin);

  // 4) 디코드 (HDU: load-use 체크)
  bool load_use = (id_ex.valid && id_ex.d.isLoadUseHazardWith(ex_mem));
  Decoded d = (load_use ? NOP_DEC : decode(if_id.inst));

  // 5) 페치 (분기/ret 제어)
  uint64_t npc = choose_next_pc(ex_mem, mem_wb, if_id.pc);
  Instr    ins = imem[npc];

  // 6) 파이프 레지스터 갱신 (stall/flush 반영)
  if (!load_use) if_id = { ins, npc, true }; // else: IF/ID stall
  id_ex  = (flushID ? NOP_EX : (load_use ? NOP_EX : (ID_EX){ d, if_id.pc, if_id.valid }));
  ex_mem = (flushEX ? NOP_MEM : (EX_MEM){ x, id_ex.pc, id_ex.valid });
  mem_wb = (MEM_WB){ m, ex_mem.pc, ex_mem.valid };
}
```

---

## 16. 검증·디버깅·성능 계측

1. **파이프 레지스터 덤프**: 매 사이클 IF/ID·ID/EX·EX/MEM·MEM/WB의 핵심 필드 출력.
2. **포워딩 우선순위**: EX/MEM → MEM/WB → RF 순서로 최신성 보장.
3. **load-use**: 정확히 **1 버블**로 해결되는지.
4. **분기 미스**: flush 범위·PC 리다이렉트 1회로 일관되는지.
5. **캐시 미스**: I/D 미스 시 스톨 범위가 의도와 일치하는지.
6. **성능 로그**: 분기 비율·미스율·load-use 빈도·I/D 미스율을 집계해 **CPI 분해표** 작성.

---

## 17. 확장: Superscalar / OOO / Tomasulo / ROB

- **Superscalar(다중 이슈)**: 스테이지/유닛 복제 + **스케줄러** + **다중 포트 RF** 필요, **WAW/WAR** 발생 가능.
- **OOO**: **탐색적 실행**으로 ILP 극대화, **레지스터 리네이밍**으로 WAW/WAR 제거, **ROB**로 **정밀 예외** 보장.
- **Tomasulo**: RS(Reservation Station) + CDB + 동적 스케줄링/리네이밍.

> 본 문서의 원리는 **인오더 단일-이슈** 기반이지만, 상위 구조에서도 **해저드 분류·포워딩 개념·분기예측·CPI 모델링**은 그대로 확장된다.

---

## 18. 설계 체크리스트 (실전)

- [ ] I/D 메모리 구조: 단일 포트? 분리? 멀티포트?
- [ ] RF: 동사이클 W→R 순서 정의(혹은 포워딩으로 회피).
- [ ] 포워딩 경로: EX/MEM→EX, MEM/WB→EX, (가능하면) MEM→EX 로드 직결.
- [ ] HDU 규칙: load-use, ret, 분기 미스 모두 명시.
- [ ] 분기 처리: 예측 정책, BTB/RAS 유무, 플러시 폭.
- [ ] 멀티사이클 유닛: Latency/II/컨텐션 모델.
- [ ] 캐시 미스 모델: I/D 미스 스톨·MSHR 정책.
- [ ] 계측 포인트: 분기/미스/스톨 카운터, CPI 분해.
- [ ] 유닛 테스트: add/add, load/use, 분기 미스, call/ret, I/D 미스 주입.

---

## 19. 마무리 요약

- 파이프라이닝은 **동시성으로 처리량을 높이는 핵심 기법**이다.
- **구조/데이터/제어 해저드**가 이상적 성능을 갉아먹는다.
- **포워딩**으로 대부분 RAW를 제거하고, **load-use**에는 **1 스톨**, **분기**는 **예측+플러시**로 대응.
- 성능은 **분기 미스율·로드 의존·캐시 미스·멀티사이클 유닛**에 의해 좌우된다.
- 하드웨어(포워딩/예측/캐시)와 소프트웨어(스케줄링/언롤링)는 **서로 보완**한다.
- 체계적 **검증/계측**과 **CPI 분해**가 설계의 성공을 좌우한다.
