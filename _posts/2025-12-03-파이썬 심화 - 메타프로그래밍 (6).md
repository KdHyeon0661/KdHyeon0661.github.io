---
layout: post
title: 파이썬 심화 - 메타프로그래밍 (6)
date: 2025-12-03 16:30:23 +0900
category: 파이썬 심화
---
# 메타프로그래밍 (6)

## 1. 손쉬운 콘텍스트 매니저 정의

파이썬의 콘텍스트 매니저는 `with` 문과 함께 사용되는 리소스 관리 메커니즘입니다. 파일 처리, 데이터베이스 연결, 락 관리 등에서 리소스의 안전한 획득과 해제를 보장합니다.

### 1.1 클래스 기반 정의
```python
class FileContextManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
        # 예외를 처리하지 않으려면 False 반환
        return False

# 사용 예시
with FileContextManager('data.txt', 'r') as f:
    content = f.read()
```

### 1.2 contextlib을 활용한 간단한 정의
```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    file = open(filename, mode)
    try:
        yield file
    finally:
        file.close()

# 사용 예시
with file_manager('data.txt', 'w') as f:
    f.write('Hello, World!')
```

### 1.3 비동기 콘텍스트 매니저 (Python 3.5+)
```python
import asyncio
from contextlib import asynccontextmanager

@asynccontextmanager
async def async_connection(host, port):
    # 비동기 연결 설정
    reader, writer = await asyncio.open_connection(host, port)
    try:
        yield reader, writer
    finally:
        writer.close()
        await writer.wait_closed()
```

## 2. 지역변수 문제 없이 코드 실행

### 2.1 exec() 함수의 지역/전역 범위 제어
```python
# 안전한 코드 실행을 위한 템플릿
def safe_execute(code_string, context=None):
    """
    외부 코드를 안전하게 실행하는 함수
    
    Args:
        code_string: 실행할 코드 문자열
        context: 추가할 전역 변수 딕셔너리
    
    Returns:
        실행 결과와 생성된 지역변수
    """
    if context is None:
        context = {}
    
    # 기본 제공할 안전한 globals
    safe_globals = {
        '__builtins__': {
            'print': print,
            'len': len,
            'range': range,
            'list': list,
            'dict': dict,
            # 필요한 내장 함수만 선택적으로 허용
        }
    }
    safe_globals.update(context)
    
    # 지역 범위를 위한 빈 딕셔너리
    local_vars = {}
    
    try:
        exec(code_string, safe_globals, local_vars)
        return {'success': True, 'locals': local_vars}
    except Exception as e:
        return {'success': False, 'error': str(e), 'locals': local_vars}

# 사용 예시
result = safe_execute("""
x = 10
y = 20
z = x + y
for i in range(5):
    print(f"Count: {i}")
""")
```

### 2.2 네임스페이스 분리를 통한 변수 격리
```python
class CodeSandbox:
    def __init__(self):
        self.reset()
    
    def reset(self):
        """실행 환경 초기화"""
        self.globals_dict = {
            '__builtins__': self._create_safe_builtins(),
            '__name__': '__sandbox__',
            '__doc__': None,
        }
        self.locals_dict = {}
    
    def _create_safe_builtins(self):
        """안전한 내장 함수 집합 생성"""
        safe_builtins = {}
        allowed = ['abs', 'bool', 'chr', 'int', 'float', 'str', 
                  'list', 'tuple', 'dict', 'set', 'len', 'range']
        
        import builtins
        for name in allowed:
            if hasattr(builtins, name):
                safe_builtins[name] = getattr(builtins, name)
        
        return safe_builtins
    
    def execute(self, code):
        """코드 실행 및 결과 반환"""
        try:
            exec(code, self.globals_dict, self.locals_dict)
            # 실행 후 locals_dict의 복사본 반환 (원본 보호)
            return dict(self.locals_dict)
        except Exception as e:
            raise RuntimeError(f"코드 실행 실패: {e}")

# 사용 예시
sandbox = CodeSandbox()
variables = sandbox.execute("""
numbers = [1, 2, 3, 4, 5]
squares = [n**2 for n in numbers]
total = sum(squares)
""")
print(variables)  # {'numbers': [1,2,3,4,5], 'squares': [1,4,9,16,25], 'total': 55}
```

## 3. 파이썬 코드 파싱과 분석

### 3.1 ast 모듈을 활용한 추상 구문 트리 분석
```python
import ast
import inspect

class CodeAnalyzer(ast.NodeVisitor):
    """코드 분석을 위한 AST 방문자 클래스"""
    
    def __init__(self):
        self.variables = set()
        self.functions = set()
        self.imports = set()
        self.calls = []
    
    def visit_Name(self, node):
        """변수 이름 수집"""
        if isinstance(node.ctx, ast.Store):  # 할당되는 변수
            self.variables.add(node.id)
        super().generic_visit(node)
    
    def visit_FunctionDef(self, node):
        """함수 정의 수집"""
        self.functions.add(node.name)
        super().generic_visit(node)
    
    def visit_Import(self, node):
        """import 문 수집"""
        for alias in node.names:
            self.imports.add(alias.name)
        super().generic_visit(node)
    
    def visit_Call(self, node):
        """함수 호출 수집"""
        if isinstance(node.func, ast.Name):
            self.calls.append(node.func.id)
        super().generic_visit(node)
    
    def analyze(self, code):
        """코드 분석 실행"""
        tree = ast.parse(code)
        self.visit(tree)
        return {
            'variables': list(self.variables),
            'functions': list(self.functions),
            'imports': list(self.imports),
            'function_calls': self.calls
        }

# 사용 예시
code = """
import math
import os
from datetime import datetime

def calculate_area(radius):
    return math.pi * radius ** 2

def main():
    r = 5
    area = calculate_area(r)
    print(f"Area: {area}")
    current_time = datetime.now()
    return area
"""

analyzer = CodeAnalyzer()
results = analyzer.analyze(code)
print(results)
```

### 3.2 코드 메트릭스 계산
```python
import ast
from collections import Counter

class CodeMetrics:
    """코드 복잡성 및 메트릭스 분석"""
    
    @staticmethod
    def calculate_complexity(code):
        """순환 복잡도 계산 (McCabe)"""
        tree = ast.parse(code)
        complexity = 1  # 기본 복잡도
        
        class ComplexityVisitor(ast.NodeVisitor):
            def __init__(self):
                self.count = 0
            
            def visit_If(self, node):
                self.count += 1
                self.generic_visit(node)
            
            def visit_For(self, node):
                self.count += 1
                self.generic_visit(node)
            
            def visit_While(self, node):
                self.count += 1
                self.generic_visit(node)
            
            def visit_Try(self, node):
                self.count += 1
                self.generic_visit(node)
            
            def visit_BoolOp(self, node):
                # and/or 연산자마다 복잡도 증가
                self.count += len(node.values) - 1
                self.generic_visit(node)
        
        visitor = ComplexityVisitor()
        visitor.visit(tree)
        return complexity + visitor.count
    
    @staticmethod
    def get_code_statistics(code):
        """기본 코드 통계"""
        tree = ast.parse(code)
        
        stats = {
            'lines': code.count('\n') + 1,
            'characters': len(code),
            'functions': 0,
            'classes': 0,
            'imports': 0,
            'comments': 0,
        }
        
        # 주석 라인 수 계산 (간단한 버전)
        stats['comments'] = sum(1 for line in code.split('\n') 
                              if line.strip().startswith('#'))
        
        class StatsVisitor(ast.NodeVisitor):
            def visit_FunctionDef(self, node):
                stats['functions'] += 1
                self.generic_visit(node)
            
            def visit_ClassDef(self, node):
                stats['classes'] += 1
                self.generic_visit(node)
            
            def visit_Import(self, node):
                stats['imports'] += len(node.names)
                self.generic_visit(node)
            
            def visit_ImportFrom(self, node):
                stats['imports'] += len(node.names)
                self.generic_visit(node)
        
        visitor = StatsVisitor()
        visitor.visit(tree)
        stats['complexity'] = CodeMetrics.calculate_complexity(code)
        
        return stats
```

## 4. 파이썬 바이트코드 디스어셈블리

### 4.1 dis 모듈을 활용한 바이트코드 분석
```python
import dis
import types

def disassemble_function(func):
    """함수의 바이트코드를 상세하게 디스어셈블"""
    
    print(f"\n{'='*60}")
    print(f"Function: {func.__name__}")
    print(f"{'='*60}")
    
    # 함수의 코드 객체 정보 출력
    code_obj = func.__code__
    print(f"Code object information:")
    print(f"  Argument count: {code_obj.co_argcount}")
    print(f"  Positional-only arguments: {code_obj.co_posonlyargcount}")
    print(f"  Keyword-only arguments: {code_obj.co_kwonlyargcount}")
    print(f"  Number of locals: {code_obj.co_nlocals}")
    print(f"  Stack size: {code_obj.co_stacksize}")
    print(f"  Flags: {code_obj.co_flags}")
    print(f"  Constants: {code_obj.co_consts}")
    print(f"  Names: {code_obj.co_names}")
    print(f"  Variable names: {code_obj.co_varnames}")
    print(f"  Free variables: {code_obj.co_freevars}")
    print(f"  Cell variables: {code_obj.co_cellvars}")
    
    print(f"\nBytecode disassembly:")
    print(f"{'-'*60}")
    dis.dis(func)
    
    # 특정 바이트코드 명령어 분석
    print(f"\nDetailed bytecode analysis:")
    print(f"{'-'*60}")
    
    bytecode = code_obj.co_code
    for i in range(0, len(bytecode), 2):
        if i < len(bytecode):
            opcode = bytecode[i]
            arg = bytecode[i+1] if i+1 < len(bytecode) else 0
            opname = dis.opname[opcode]
            print(f"  {i:4d}: {opname:20s} {arg}")

# 예제 함수
def example_function(x, y):
    """간단한 예제 함수"""
    result = x + y
    if result > 10:
        return result * 2
    else:
        return result - 5

# 디스어셈블 실행
disassemble_function(example_function)
```

### 4.2 커스텀 바이트코드 분석기
```python
import dis
import opcode

class BytecodeAnalyzer:
    """사용자 정의 바이트코드 분석 도구"""
    
    def __init__(self):
        self.opcode_stats = {}
        self.instruction_flow = []
    
    def analyze_code_object(self, code_obj, indent=0):
        """코드 객체 재귀적으로 분석"""
        
        prefix = "  " * indent
        
        print(f"{prefix}Code: {code_obj.co_name}")
        print(f"{prefix}  Filename: {code_obj.co_filename}")
        print(f"{prefix}  First line: {code_obj.co_firstlineno}")
        
        # 바이트코드 명령어 통계 수집
        bytecode = code_obj.co_code
        for i in range(0, len(bytecode), 2):
            if i < len(bytecode):
                op = bytecode[i]
                op_name = dis.opname[op]
                self.opcode_stats[op_name] = self.opcode_stats.get(op_name, 0) + 1
                
                # 명령어 흐름 기록
                if op_name in ['LOAD_CONST', 'LOAD_FAST', 'STORE_FAST', 
                              'CALL_FUNCTION', 'RETURN_VALUE']:
                    self.instruction_flow.append({
                        'offset': i,
                        'opcode': op_name,
                        'code_name': code_obj.co_name
                    })
        
        # 내부 코드 객체 분석 (중첩 함수 등)
        for const in code_obj.co_consts:
            if isinstance(const, types.CodeType):
                self.analyze_code_object(const, indent + 1)
    
    def generate_flow_diagram(self):
        """명령어 흐름 다이어그램 생성"""
        print("\nInstruction Flow Diagram:")
        print("=" * 60)
        
        for flow in self.instruction_flow:
            arrow = "  →  "
            if flow['opcode'] == 'RETURN_VALUE':
                arrow = "  ↲  "
            elif flow['opcode'] == 'CALL_FUNCTION':
                arrow = "  ⇢  "
            
            print(f"[{flow['code_name']}] {flow['offset']:4d}: "
                  f"{flow['opcode']:15s}{arrow}")
    
    def print_statistics(self):
        """바이트코드 통계 출력"""
        print("\nOpcode Statistics:")
        print("=" * 60)
        
        total_instructions = sum(self.opcode_stats.values())
        sorted_stats = sorted(self.opcode_stats.items(), 
                            key=lambda x: x[1], reverse=True)
        
        for opcode, count in sorted_stats:
            percentage = (count / total_instructions) * 100
            print(f"  {opcode:20s}: {count:4d} ({percentage:5.1f}%)")
        
        print(f"\n  Total instructions: {total_instructions}")

# 분석 예제
def complex_example(n):
    """더 복잡한 예제 함수"""
    total = 0
    for i in range(n):
        if i % 2 == 0:
            total += i * 2
        else:
            total += i
    return total

# 분석 실행
analyzer = BytecodeAnalyzer()
analyzer.analyze_code_object(complex_example.__code__)
analyzer.print_statistics()
analyzer.generate_flow_diagram()
```

### 4.3 바이트코드 최적화 분석
```python
import dis
import timeit

def compare_bytecode(func1, func2, func_names=None):
    """두 함수의 바이트코드와 성능 비교"""
    
    if func_names is None:
        func_names = [func1.__name__, func2.__name__]
    
    print(f"\n{'='*70}")
    print(f"Bytecode Comparison: {func_names[0]} vs {func_names[1]}")
    print(f"{'='*70}")
    
    # 바이트코드 비교
    print(f"\n1. {func_names[0]} bytecode:")
    print(f"{'-'*35}")
    dis.dis(func1)
    
    print(f"\n2. {func_names[1]} bytecode:")
    print(f"{'-'*35}")
    dis.dis(func2)
    
    # 성능 비교
    print(f"\n3. Performance Comparison:")
    print(f"{'-'*35}")
    
    # 간단한 성능 테스트
    test_input = 1000  # 테스트 입력 값
    
    time1 = timeit.timeit(
        f"{func_names[0]}({test_input})",
        globals={func_names[0]: func1},
        number=10000
    )
    
    time2 = timeit.timeit(
        f"{func_names[1]}({test_input})",
        globals={func_names[1]: func2},
        number=10000
    )
    
    print(f"  {func_names[0]}: {time1:.6f} seconds (10000 calls)")
    print(f"  {func_names[1]}: {time2:.6f} seconds (10000 calls)")
    
    if time1 < time2:
        faster = func_names[0]
        speedup = (time2 - time1) / time2 * 100
    else:
        faster = func_names[1]
        speedup = (time1 - time2) / time1 * 100
    
    print(f"\n  ✓ {faster} is {abs(speedup):.1f}% faster")

# 비교할 함수들 정의
def sum_with_for(n):
    """for 루프를 사용한 합계 계산"""
    total = 0
    for i in range(n):
        total += i
    return total

def sum_with_while(n):
    """while 루프를 사용한 합계 계산"""
    total = 0
    i = 0
    while i < n:
        total += i
        i += 1
    return total

def sum_with_gauss(n):
    """가우스 공식을 사용한 합계 계산"""
    return n * (n - 1) // 2

# 바이트코드 비교 실행
compare_bytecode(sum_with_for, sum_with_while)
compare_bytecode(sum_with_for, sum_with_gauss, 
                 ["Loop (for)", "Formula (Gauss)"])
```

## 결론

파이썬의 콘텍스트 매니저부터 바이트코드 분석까지의 과정은 파이썬의 내부 동작 방식을 깊이 이해하는 데 필수적인 여정입니다. 콘텍스트 매니저를 통해 리소스 관리의 안전성을 확보하고, `exec()` 함수의 범위 제어를 통해 외부 코드 실행의 위험을 최소화할 수 있습니다. AST 분석은 코드의 구조적 이해를 도우며, 바이트코드 디스어셈블리는 파이썬 인터프리터의 실제 동작 방식을 들여다볼 수 있는 창을 제공합니다.

이러한 기술들은 코드 분석 도구 개발, 성능 최적화, 보안 강화, 교육용 도구 제작 등 다양한 분야에서 활용될 수 있습니다. 특히 바이트코드 수준의 이해는 파이썬 프로그래밍의 숙련도를 한 단계 높이고, 더 효율적이고 안전한 코드를 작성하는 데 기여합니다.

각 단계에서 적절한 도구와 방법론을 활용하면, 파이썬 코드의 실행 흐름을 완전히 통제하고 최적화할 수 있으며, 이는 고품질의 파이썬 애플리케이션 개발을 위한 강력한 기반이 됩니다.