---
layout: post
title: Java -  접근 제어자
date: 2025-07-14 21:20:23 +0900
category: Java
---
# 접근 제어자 (Access Modifiers)

## 전체 요약 표 (재확인)

| 접근 제어자 | 클래스 내부 | 같은 패키지 | 하위 클래스 (다른 패키지) | 다른 패키지 |
|---|---:|---:|---:|---:|
| `public`     | O | O | O | O |
| `protected`  | O | O | O* | X |
| *(default)*  | O | O | X | X |
| `private`    | O | X | X | X |

\* `protected`는 **“상속 경유” 접근**임에 주의(자세한 예제는 §3.2).

---

## `public` — 공개 API

### 규칙

- 어디서나 접근 가능. **API 표면**(공개 클래스/메서드)에 사용.
- 최상위(Top-level) 타입에 사용하면, **소스 파일명은 그 public 클래스명과 동일**해야 함(하나의 `.java` 파일 당 public 최상위 타입 **최대 1개**).

### 예제

```java
// File: MyClass.java
public class MyClass {
    public int number;
    public void print() { System.out.println("Hello!"); }
}
```

---

## `private` — 클래스 내부 전용

### 규칙

- **동일 클래스 내부에서만** 접근 가능.
- 중첩(내부) 클래스에도 적용되며, **private 멤버는 하위 클래스에도 보이지 않음**.
- **캡슐화 기본값**: 필드는 보통 `private` → 공개는 메서드로 통제.

### 예제: 캡슐화

```java
public class Person {
    private String name;

    public void setName(String name) { this.name = name; }
    public String getName()           { return this.name; }
}

Person p = new Person();
p.setName("John");
System.out.println(p.getName());
// p.name = "Kim"; // 컴파일 오류 (private)
```

### 내부 클래스와의 상호작용(참고)

- 자바 컴파일러는 필요 시 **synthetic accessor**(패키지-프라이빗 브리지)를 만들어
  내부/외부 클래스 간 `private` 접근을 지원하지만, **접근 제어 규칙 자체는 바뀌지 않음**.

---

## `protected` — 패키지 + 상속 경유 공개

### 규칙 요약

- **같은 패키지**: 일반 멤버처럼 접근 가능.
- **다른 패키지**: 오직 **하위 클래스에서, 상속 경유로만** 접근 가능.
  - 즉, **“자신(this) 혹은 자신의 타입으로 취급되는 참조”**를 통해서만 접근 가능.
  - **타인의 인스턴스**를 통해서는 접근 불가(예제 참조).

### 다른 패키지에서의 `protected` — 올바른/잘못된 예

```java
// package a
package a;
public class Animal {
    protected void sound() { System.out.println("Animal sound"); }
}

// package b
package b;
import a.Animal;

public class Dog extends Animal {
    public void bark() {
        sound(); // OK: 상속 경유(= this.sound())
    }
    public void test(Animal other) {
        // other.sound(); // 컴파일 오류: 다른 패키지 + 다른 인스턴스
    }
}
```
- 핵심: **하위 클래스라도 다른 패키지에서 “부모 타입 인스턴스(다른 객체)”로는 접근할 수 없다.**
  반드시 **자신의 인스턴스(또는 그 하위 타입으로 취급되는 참조)** 를 통해 접근해야 함.

### `protected` 생성자(중요)

- 다른 패키지의 코드에서 **그 클래스를 직접 `new`** 하는 것은 불가(하위 클래스가 아닌 경우).
- **하위 클래스는 자신의 생성자에서 `super(...)`로 호출** 가능.
  하위 클래스에서 부모 인스턴스를 **별도로 `new Parent()`** 하는 것은 보통 **불가**(상속 경유 규칙 위배).

---

## (default) — 패키지 전용(package-private)

### 규칙

- **아무 제어자도 붙이지 않으면** default(= package-private).
- **같은 패키지 내에서만** 접근 가능. 패키지를 **모듈적 경계**로 사용하려는 기본 수단.

### 예제

```java
class PackageClass {            // default 클래스
    void show() {               // default 메서드
        System.out.println("default method");
    }
}
```

---

## 오버라이딩과 접근 수준 — “좁히기 금지, 넓히기는 OK”

### 규칙

- 오버라이딩 시 **접근 제어자는 같거나 더 넓어야** 함.
  - `private` → 오버라이딩 대상 자체가 아님(상속되지 않음).
  - `default` → `default`/`protected`/`public` 가능.
  - `protected` → `protected`/`public` 가능.
  - `public` → 오직 `public`만 가능.
- 더 **좁히면 컴파일 오류**.

### 예제

```java
class Parent {
    protected void work() {}
}
class Child extends Parent {
    @Override
    public void work() {} // OK (protected → public)
    // @Override void work() {} // OK (동일 protected)
    // @Override private void work() {} // 컴파일 오류 (좁힘)
}
```

---

## 어디에 어떤 제어자가 “될까/안 될까” — 요소별 허용 조합

| 요소 | `public` | `protected` | (default) | `private` |
|---|---:|---:|---:|---:|
| **최상위 class / interface / enum / record** | O | X | O | X |
| **중첩(내부) 클래스/인터페이스/열거형/레코드** | O | O | O | O |
| **필드/메서드/생성자(멤버)** | O | O | O | O |

- **최상위 타입**은 `public` 또는 **default**만 가능(`protected`/`private` 불가).
- **중첩 타입**은 네 가지 모두 허용.

---

## 생성자와 접근 제어 — 생성 로직을 설계하는 레버

### 생성자 가시성 패턴

| 목적 | 권장 |
|---|---|
| 외부에서도 자유 생성 | `public` 생성자 |
| 팩토리/빌더 강제, 불변식 통제 | `private` 생성자 + `public static of()/builder()` |
| 상속용(같은 패키지 또는 하위만) | `protected` 생성자 |

### 싱글턴/유틸리티 클래스

```java
final class Utils {
    private Utils() { throw new AssertionError(); } // 인스턴스화 금지
}
final class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() { return INSTANCE; }
}
```

---

## 패키지, 모듈, 그리고 접근 제어자

- **패키지**: `(default)`, `protected`의 **행동 경계**.
- **모듈(Java 9+)**: `module-info.java`의 `exports`/`opens`는 **패키지 수준의 배포/리플렉션 가시성**을 제어.
  **접근 제어자 자체를 대체하지 않음**(소스/바이트코드의 `public/protected/...`는 그대로 의미 유지).
- 리플렉션으로 `setAccessible(true)`를 시도해도, **모듈 경계/보안 매니저/권한**에 따라 제한될 수 있음.

---

## 문자열 한 줄로 이해하는 `protected`

> **같은 패키지**이면 “그냥 보인다”.
> **다른 패키지**면 “**상속받은 내 것**처럼 쓸 때만 보인다(= `this` 경유)”.
> **남의 인스턴스**로는 안 보인다.

---

## 실전 예제 모음

### 네 가지 제어자 비교 — 패키지 경계 실험

```java
// package p1
package p1;
public class A {
    public int pub = 1;
    protected int pro = 2;
             int def = 3;
    private   int pri = 4;

    public void dumpA() {
        System.out.println(pub + "," + pro + "," + def + "," + pri);
    }
}

// package p1
package p1;
class B {
    void test() {
        A a = new A();
        System.out.println(a.pub); // OK
        System.out.println(a.pro); // OK (같은 패키지)
        System.out.println(a.def); // OK (같은 패키지)
        // System.out.println(a.pri); // 오류
    }
}

// package p2
package p2;
import p1.A;
public class C extends A {
    void test(C other, A a) {
        System.out.println(pub); // OK (상속)
        System.out.println(pro); // OK (상속)
        // System.out.println(def); // 오류 (다른 패키지)
        // System.out.println(pri); // 오류

        System.out.println(other.pro); // OK: other는 C (하위 타입)
        // System.out.println(a.pro);    // 오류: a는 A (부모 타입 참조)
    }
}
```

### 오버라이딩 시 접근 수준 확대

```java
class Super {
    protected void f() {}
}
class Sub extends Super {
    @Override public void f() {} // 더 넓힘 → OK
}
```

### `protected` 생성자와 상속

```java
// package base
package base;
public class Parent {
    protected Parent(int x) {}
}

// package child
package child;
import base.Parent;

public class Kid extends Parent {
    public Kid() { super(1); } // OK: 하위 클래스가 부모 protected 생성자 호출
    void make() {
        // new Parent(2); // 오류: 다른 패키지에서 직접 인스턴스화 불가
    }
}
```

---

## 레코드/열거형/`sealed`와 접근 제어

- **record**: 컴포넌트 필드는 **암묵적 `private final`**, 접근자는 `public`. 레코드 자체의 공개 수준은 개발자가 결정.
- **enum**: 생성자는 **암묵적 `private`**. 열거 상수만 외부에 공개.
- **sealed** 클래스(17+): **상속 가능한 타입을 제한**(접근 제어자와 별개).
  개방 범위는 `permits` 목록으로 정의하며, 각 하위 클래스는 `final`/`sealed`/`non-sealed`로 지정.

---

## 리플렉션과 접근 제어

- 리플렉션은 `setAccessible(true)`로 **언어 차원의 제어자를 일시 우회**할 수 있으나,
  **모듈/보안 설정**에 따라 제한될 수 있고, 라이브러리 설계자는 **API 계약**으로 가시성을 정의해야 합니다.
- “테스트 편의”를 이유로 접근 범위를 넓히지 말고, **패키지-프라이빗 팩토리**나 **테스트 전용 어댑터**를 고려.

---

## 설계 가이드 & 체크리스트

### 권장 기본값

| 대상 | 권장 |
|---|---|
| **필드** | `private` (상태 보호) |
| **메서드** | `public`(API) / `protected`(확장 전용) / default(패키지 내부 협력) |
| **생성자** | 용도에 맞춰 `public`/`protected`/`private` |
| **최상위 타입** | `public`(API) / default(내부 구현) |

### 리팩터링 시 유의

- **접근 확대**(예: `default`→`public`)는 **바이너리 호환**에 비교적 안전하나, API 표면 증가 → 유지보수 비용↑.
- **접근 축소**는 **호환성 파괴** 가능 → 메이저 릴리스에서만, 마이그레이션 가이드 제공.
- 상속 확장 포인트는 **명시적으로 `protected`** + **문서화**(계약/전제조건/후조건 명시).

### 체크리스트

- [ ] “정말로 외부에 보여야 하나?” → 최소 공개 원칙
- [ ] `protected` 필요? → 상속 경유 규칙 이해/테스트
- [ ] 오버라이딩 시 접근 수준 **좁히지 않기**
- [ ] 최상위 타입은 `public`/default만
- [ ] 패키지 경계 설계(내부 구현은 default로 숨기기)
- [ ] 테스트/DI를 위해 공개를 남발하지 말 것(인터페이스/팩토리/어댑터 활용)

---

## 마무리 요약 표

| 제어자 | 핵심 한 줄 |
|---|---|
| `public` | 어디서나 접근 가능 — 공개 API |
| `protected` | 같은 패키지 + **상속 경유** 접근(다른 패키지의 “남”은 불가) |
| *(default)* | 같은 패키지 전용(패키지 경계로 숨기기) |
| `private` | 클래스 내부 전용(캡슐화의 기본) |

> 결론: **최소 공개**를 기본값으로 삼고, 필요할 때만 단계적으로 넓혀라.
> 패키지·상속 경계에서의 `protected` 규칙과 **오버라이딩 접근 제약**을 정확히 지키면, **안전하고 확장 가능한 API 표면**을 설계할 수 있다.
