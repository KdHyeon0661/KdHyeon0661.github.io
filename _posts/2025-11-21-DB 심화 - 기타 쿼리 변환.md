---
layout: post
title: DB 심화 - 기타 쿼리 변환
date: 2025-11-21 18:25:23 +0900
category: DB 심화
---
# 기타 쿼리 변환

이 문서에서는 쿼리 성능 최적화를 위한 몇 가지 실용적인 변환 기법을 다룹니다. 주로 조인 컬럼에 `IS NOT NULL` 조건 추가, 암시적 필터 조건의 명시화, 조건절의 SARGABLE 작성 패턴에 집중합니다.

## 조인 컬럼에 `IS NOT NULL` 조건 추가

조인에 사용되는 컬럼에 `IS NOT NULL` 조건을 명시적으로 추가하는 것은 옵티마이저의 카디널리티 추정과 접근 경로 선택에 긍정적인 영향을 줄 수 있습니다.

### 주요 효과

1.  **조인 제거(Join Elimination) 또는 INNER 조인 유도**
    *   외래키(FK) 컬럼이 `NOT NULL` 제약을 가지고 있고, 부모 테이블의 컬럼을 SELECT나 WHERE 절에서 사용하지 않는다면, 옵티마이저는 조인 자체를 제거할 수 있습니다.
    *   FK 컬럼이 `NULLABLE`이더라도, 업무적으로 NULL 값이 무의미하다면 `IS NOT NULL` 조건을 추가함으로써 조인 전에 불필요한 행을 제거하고, 결과적으로 더 효율적인 INNER 조인으로의 변환을 유도할 수 있습니다.

2.  **카디널리티 추정 정확도 향상**
    *   옵티마이저는 컬럼의 NULL 비율을 통계에 반영합니다. `IS NOT NULL` 조건을 명시하면 옵티마이저가 조인 결과의 행 수를 더 정확히 예측하게 돕고, 이는 최적의 조인 순서와 방식을 선택하는 데 결정적입니다.

3.  **파티션 및 인덱스 프루닝 지원**
    *   파티션 키 또는 인덱스 선두 컬럼이 조인 키일 경우, `IS NOT NULL` 조건은 스캔 초기 단계에서 접근 범위를 줄이는 데 기여할 수 있습니다.

### 주의사항 및 안전성 검토

*   **INNER JOIN**: `IS NOT NULL` 조건은 일반적으로 중복됩니다(INNER JOIN 자체가 NULL을 배제). 그러나 옵티마이저의 추론에는 도움이 될 수 있습니다.
*   **LEFT OUTER JOIN**: **중요한 주의사항입니다.** 조인되는 측(보통 오른쪽 테이블)의 컬럼에 `IS NOT NULL` 조건을 WHERE 절에 추가하면, 해당 조건을 만족하지 않는 모든 행이 결과에서 제외됩니다. 이는 LEFT JOIN을 암시적으로 INNER JOIN으로 변경하는 것이며, **데이터 의미를 근본적으로 바꿉니다.** 의도적인 경우가 아니라면 심각한 버그를 초래합니다.
*   **FK 무결성**: FK가 `ENABLE VALIDATE` 상태이고 자식 테이블 컬럼이 `NOT NULL`이라면, `IS NOT NULL` 조건은 논리적으로 항상 참이므로 추가해도 무방합니다.

### 예시: LEFT JOIN에서 INNER JOIN으로의 의도적 변환

```sql
-- 원본: 모든 고객을 보여주며, 매칭되는 판매가 없으면 NULL 표시
SELECT c.cust_id, s.sales_id
FROM   d_customer c
LEFT  JOIN f_sales s ON s.cust_id = c.cust_id;

-- 변환 후: 판매 기록이 있는 고객만 필터링 (의도적으로 INNER JOIN과 동일한 결과)
SELECT c.cust_id, s.sales_id
FROM   d_customer c
LEFT  JOIN f_sales s ON s.cust_id = c.cust_id
WHERE  s.cust_id IS NOT NULL; -- LEFT JOIN의 의미를 변경함
```

---

## 암시적 필터 조건의 명시화

차원 테이블(Dimension Table)의 필터 조건을 사실 테이블(Fact Table)의 컬럼에 직접 명시하는 것은 파티션 프루닝과 인덱스 사용을 극대화하는 핵심 기술입니다.

### 동기

다음 쿼리는 `d_date` 차원을 통해 월별 필터를 적용합니다.

```sql
SELECT SUM(s.amount)
FROM   f_sales s
JOIN   d_date d ON d.dt = s.dt
WHERE  d.yyyymm = 202502;
```

**문제점:** `f_sales` 테이블은 `dt` 컬럼으로 파티션되어 있지만, 필터 조건은 `d.yyyymm`에 걸려 있습니다. 옵티마이저가 `d.yyyymm = 202502`를 `s.dt`의 범위로 변환하지 못할 경우, **파티션 프루닝이 발생하지 않고 전체 파티션을 스캔할 위험이 있습니다.**

### 해결책: 파티션 키에 직접 조건 명시

차원 테이블의 조건을 사실 테이블의 파티션 키나 인덱스 키로 "하향 전파(Downward Push)"합니다.

```sql
SELECT SUM(s.amount)
FROM   f_sales s
WHERE  s.dt >= DATE '2025-02-01'
AND    s.dt <  DATE '2025-03-01';
```

이렇게 하면 옵티마이저는 명확히 `s.dt`의 범위를 인식하고, 관련된 파티션(예: `p202502`)만 접근합니다. 조인을 제거할 수 없는 경우라도, 조인 전에 사실 테이블의 데이터를 대폭 줄일 수 있습니다.

**실전 팁:** 이 변환은 옵티마이저의 CBQT(Constraint-Based Query Transformation)가 자동으로 수행할 수도 있지만, 쿼리를 직접 작성할 때 명시적으로 조건을 추가하는 것이 가장 안정적인 방법입니다.

---

## 조건절의 SARGABLE 작성 습관

SARGABLE(Search ARGument ABLE)이란 조건절이 인덱스를 효과적으로 사용할 수 있는 형태를 의미합니다. SQL은 조건의 평가 순서를 보장하지 않지만, 작성 패턴 자체가 옵티마이저의 선택에 큰 영향을 미칩니다.

### 핵심 원칙: 컬럼은 가공하지 말고 좌변에

옵티마이저는 컬럼에 함수나 연산이 적용된 조건에 대해 인덱스 범위 스캔을 사용하기 어렵습니다.

**비SARGABLE 패턴 (나쁨)**

```sql
WHERE TO_CHAR(s.dt, 'YYYYMM') = '202502'; -- 컬럼 가공
WHERE NVL(p.brand, 'N/A') = 'Samsung';    -- 컬럼 가공
WHERE SUBSTR(c.region, 1, 2) = 'EU';      -- 컬럼 가공
WHERE amount * 1.1 > 1000;                -- 컬럼 연산
```

**SARGABLE 패턴 (좋음)**

```sql
-- 날짜 범위로 변환
WHERE s.dt >= DATE '2025-02-01' AND s.dt < DATE '2025-03-01';
-- NVL 대신 명시적 조건 분리 (선택적 파라미터 처리)
WHERE (:p_brand IS NULL OR p.brand = :p_brand);
-- LIKE를 활용 (함수기반 인덱스도 고려)
WHERE p.brand LIKE 'Samsung%';
WHERE c.region LIKE 'EU%';
-- 연산을 상수 쪽으로 이동
WHERE amount > 1000 / 1.1;
```

### 선택적 필터(Optional Filter) 처리 개선

애플리케이션에서 동적으로 조건이 바뀌는 경우, `NVL`이나 `DECODE`를 남용하면 성능이 저하됩니다.

```sql
-- 비효율적 패턴
WHERE p.category = NVL(:input_category, p.category);

-- 효율적 패턴 1: OR 분기 (옵티마이저가 USE_CONCAT 힌트 유사하게 처리할 수 있음)
WHERE (:input_category IS NULL OR p.category = :input_category);

-- 효율적 패턴 2: 동적 SQL
-- (애플리케이션 레벨에서 조건에 따라 SQL 문장 자체를 조립)
```

### OR 조건과 인덱스 사용

`OR`로 연결된 조건은 각 조건이 다른 컬럼을 참조할 때 인덱스 사용을 방해할 수 있습니다. 이 경우 `UNION ALL`로 분리하는 것이 유리할 때가 많습니다.

```sql
-- 인덱스 사용이 어려울 수 있는 OR 패턴
SELECT * FROM f_sales s
WHERE (s.cust_id = 100 AND s.dt > SYSDATE - 7)
   OR (s.prod_id = 500 AND s.dt > SYSDATE - 30);

-- UNION ALL로 분리하여 각 브랜치가 자신의 인덱스를 활용
SELECT * FROM f_sales s WHERE s.cust_id = 100 AND s.dt > SYSDATE - 7
UNION ALL
SELECT * FROM f_sales s WHERE s.prod_id = 500 AND s.dt > SYSDATE - 30;
```
*단, `UNION ALL` 사용 시 중복 행이 발생하지 않음을 보장해야 합니다.*

---

## 통합 적용 예제

**최적화 목표:** 2025년 2월('202502')에, 'ELEC' 카테고리 제품의, 유효 고객(`cust_id IS NOT NULL`)을 대상으로 한 매출 합계를 효율적으로 조회한다.

**변환 전 (여러 문제점 내포):**
```sql
SELECT SUM(s.amount)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_date    d ON d.dt      = s.dt
WHERE  p.category = NVL(:cat, p.category) -- 1. 비SARGABLE
AND    d.yyyymm   = :mm                   -- 2. 파티션 프루닝 불확실
AND    s.cust_id IS NOT NULL;             -- 3. OK. but 조인 전 필터링 유도
```

**변환 후 (명시적 최적화 적용):**
```sql
SELECT SUM(s.amount)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  (:cat IS NULL OR p.category = :cat) -- 1. SARGABLE 패턴으로 변경
AND    s.dt >= TO_DATE(:mm || '01', 'YYYYMMDD') -- 2. 파티션 키에 직접 범위 조건
AND    s.dt <  ADD_MONTHS(TO_DATE(:mm || '01', 'YYYYMMDD'), 1)
AND    s.cust_id IS NOT NULL;              -- 3. 조인 전 카디널리티 감소 및 추정 개선
```
**변환 포인트:**
1.  선택적 파라미터 `:cat`을 `OR` 조건으로 안전하게 처리.
2.  월 조건(`:mm`)을 `s.dt`의 명확한 범위 조건으로 변환하여 필수적인 파티션 프루닝 유도.
3.  `cust_id IS NOT NULL`을 유지하여, `f_sales` 테이블에서 조인에 참여할 수 없는 행을 조기 필터링하도록 유도.

---

## 결론

쿼리 변환의 궁극적 목표는 **옵티마이저가 최적의 실행 계획을 수립하도록 돕는 것**입니다. 이를 위해 다음 세 가지 원칙을 기억하십시오.

1.  **의미 보존을 최우선하라:** 특히 `IS NOT NULL` 추가나 조인 방식 변경은 쿼리의 논리적 결과를 바꾸지 않아야 합니다. LEFT JOIN을 INNER JOIN으로 바꾸는 것은 의도적이어야 합니다.
2.  **옵티마이저의 눈을 밝혀라:** 암시적인 관계(예: `yyyymm` → `dt` 범위)를 명시적으로 표현하고, 컬럼 통계 개선(`IS NOT NULL`)을 통해 옵티마이저의 카디널리티 추정을 도와주세요.
3.  **데이터 접근 경로에 친화적이게 작성하라:** 파티션 키와 인덱스가 선호하는 SARGABLE 형태로 조건을 작성하세요. 컬럼을 가공하지 말고, 상수 또는 바인드 변수를 가공하세요.

모든 변환은 마지막에 **실행 계획(DBMS_XPLAN)** 과 **실행 통계**를 비교 검증하여 실제 성능 향상을 확인하는 과정으로 완성되어야 합니다.