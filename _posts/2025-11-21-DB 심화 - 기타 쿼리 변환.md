---
layout: post
title: DB 심화 - 기타 쿼리 변환
date: 2025-11-21 18:25:23 +0900
category: DB 심화
---
# 기타 쿼리 변환 - **조인 컬럼에 `IS NOT NULL` 추가 · 필터 조건 추가 · 조건절 비교 순서**

> **요약 키포인트**
> - **조인 컬럼에 `IS NOT NULL`**:
>   - (좋음) **JOIN 제거/INNER화/파티션 프루닝** 유도, **카디널리티 개선**.
>   - (주의) **OUTER JOIN 의미를 변경**(LEFT→INNER)할 수 있음. **무결성 제약(VALIDATE)** 이 뒷받침되어야 안전.
> - **필터 조건 추가**:
>   - **제약·차원(디멘전) 기반**으로 **암시적 필터**를 **명시화**해 옵티마이저가 **조기 프루닝**/**파티션 프루닝**/**인덱스**를 잘 쓰게 돕는다.
> - **조건절 비교 순서(작성 습관)**:
>   - SQL은 **평가 순서를 보장하지 않음**(옵티마이저가 재배치).
>   - 그러나 **SARGABLE**(인덱스 사용 가능) 형태로 **열(column)은 가공하지 않고 좌변에**, **상수/바인드는 우변**에 두는 관행이 최적화에 유리.

아래 모든 예시는 앞서 쓰던 샘플 스키마를 계속 사용합니다.

```sql
-- 차원
CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

CREATE TABLE d_customer (
  cust_id   NUMBER PRIMARY KEY,
  region    VARCHAR2(8)  NOT NULL,
  tier      VARCHAR2(8)  NOT NULL
);

-- 사실
CREATE TABLE f_sales (
  sales_id  NUMBER PRIMARY KEY,
  cust_id   NUMBER         REFERENCES d_customer(cust_id), -- nullable일 수도 있다
  prod_id   NUMBER NOT NULL REFERENCES d_product(prod_id),
  dt        DATE   NOT NULL,
  qty       NUMBER NOT NULL,
  amount    NUMBER(12,2) NOT NULL
)
PARTITION BY RANGE (dt) (
  PARTITION p202501 VALUES LESS THAN (DATE '2025-02-01'),
  PARTITION p202502 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION pmax    VALUES LESS THAN (MAXVALUE)
);

CREATE INDEX ix_fs_cust_dt ON f_sales(cust_id, dt);
CREATE INDEX ix_fs_prod_dt ON f_sales(prod_id, dt);
CREATE INDEX ix_dd_ym      ON d_date(yyyymm);
CREATE INDEX ix_dp_cat     ON d_product(category, prod_id);
CREATE INDEX ix_dc_tier    ON d_customer(tier, cust_id);
```

---

## 조인 컬럼에 `IS NOT NULL` 조건 추가

### 동기와 효과

- **효과1 — INNER화/조인 제거(Join Elimination)**
  - 외래키(FK)가 **ENABLE VALIDATE**이고, 그 FK 컬럼이 **NOT NULL**이면 자식→부모 조인은 **항상 매칭**됩니다.
  - FK가 **NULLABLE**이면, 논리상 “부모가 꼭 있어야 한다”는 보장이 없으니 **`child.fk IS NOT NULL`** 을 명시하면 CBO가 **카디널리티를 낮게 추정**, 어떤 경우엔 **조인 제거**까지 유도합니다(부모 컬럼 미참조 시).
- **효과2 — 파티션/인덱스 프루닝 보조**
  - 조인키가 NULL일 수 있어도, 실제 업무상 **NULL이 의미 없는 쓰레기 값**인 경우, `IS NOT NULL`을 달아 **스캔 초기 단계에서 배제**할 수 있습니다.
- **효과3 — 카디널리티 정확도 개선**
  - 옵티마이저는 컬럼 **NULL 비율**과 **선택도**를 이용합니다. `IS NOT NULL` 명시는 통계 해석을 돕고 **더 공격적 프루닝**을 유도.

> **중요**: INNER JOIN에서 `child.fk IS NOT NULL`은 **결과집합 관점**에서는 보통 **중복**(INNER 조인 자체가 NULL 매칭을 배제).
> 그러나 **뷰/서브쿼리·외부조인·필터 재배치** 맥락에선 **계획**이 달라질 수 있습니다.

### 안전/위험 판별

| 상황 | `IS NOT NULL` 추가의 의미 |
|---|---|
| **INNER JOIN** 에서 자식→부모 조인 (`s.cust_id = c.cust_id`) | 결과 동일(대개 중복). 다만 **통계/추론** 개선 가능. |
| **LEFT OUTER JOIN** 에서 오른쪽 컬럼에 `IS NOT NULL` | **LEFT→INNER** 변환(의미 변경). **의도적**이면 좋고, **무심코 쓰면 버그**. |
| FK **ENABLE VALIDATE + NOT NULL**, 부모 컬럼 미사용 | 부모 조인 **제거**까지 가능. (CBO/CBQT가 판단) |
| FK **NULLABLE** + 실제로 NULL 존재 | `IS NOT NULL` 추가는 **행 제거**(의미 변경). 요구사항이 이를 허용해야 함. |

### 예제 1 — LEFT→INNER 의도적 전환

```sql
-- Before: 고객은 다 나오지만 매칭 없으면 s.*가 NULL
SELECT c.cust_id, s.sales_id
FROM   d_customer c
LEFT  JOIN f_sales s
       ON s.cust_id = c.cust_id;

-- After(의도): '판매가 있는 고객만' 보겠다면
SELECT c.cust_id, s.sales_id
FROM   d_customer c
LEFT  JOIN f_sales s
       ON s.cust_id = c.cust_id
WHERE  s.sales_id IS NOT NULL;        -- 또는 WHERE s.cust_id IS NOT NULL
-- == INNER JOIN과 동치
```

### 예제 2 — FK NULLABLE → JOIN 제거 유도

```sql
-- 부모 컬럼을 사용하지 않는 쿼리
SELECT /* before */ COUNT(*)
FROM   f_sales s
JOIN   d_customer c ON c.cust_id = s.cust_id;

-- FK가 NULLABLE이면 CBO는 '부모 조인 필요'로 본다.
-- 업무상 cust_id는 NULL이 아니어야 한다면(또는 해당 리포트에선 NULL을 배제해도 됨):
SELECT /* after  */ COUNT(*)
FROM   f_sales s
WHERE  s.cust_id IS NOT NULL;   -- 부모 조인 생략 가능 (조건부)

-- 검증: DBMS_XPLAN에서 부모 테이블 접근 유무 확인
```

### 예제 3 — 파티션 프루닝에 보탬

```sql
-- 날짜 차원 합류로 월 필터를 걸 때
SELECT /* before */ COUNT(*)
FROM   f_sales s
JOIN   d_date  d ON d.dt = s.dt
WHERE  d.yyyymm = 202502;

-- 파티션 키(dt)로 프루닝을 노리려면 'dt 범위'를 명시해도 좋다.
SELECT /* after  */ COUNT(*)
FROM   f_sales s
WHERE  s.dt >= DATE '2025-02-01'  AND s.dt < DATE '2025-03-01';  -- (암시적 조건의 명시화)
```
- 위는 `IS NOT NULL` 자체는 아니지만, **암시적 제약을 명시화**해 프루닝을 돕는 대표 패턴(§2에서 자세히).

---

## 필터 조건 추가(암시적 사실 → 명시적 조건)

### “디멘전/제약 기반” 암시적 조건을 **명시화**

**상황**: 아래 쿼리는 날짜 차원으로 월 필터를 준다.
```sql
SELECT SUM(s.amount)
FROM   f_sales s
JOIN   d_date d ON d.dt = s.dt
WHERE  d.yyyymm = 202502
AND    s.cust_id IS NOT NULL;               -- (예: FK NULL 필터)
```
**문제**: 파티션 키가 `s.dt`인데, 필터는 `d.yyyymm`에만 생겼다 → **파티션 프루닝이 약함**.

**개선(조건 추가)**: `yyyymm=202502` ⇒ `s.dt` 범위를 **명시화**.
```sql
SELECT SUM(s.amount)
FROM   f_sales s
WHERE  s.dt >= DATE '2025-02-01'
AND    s.dt <  DATE '2025-03-01';
```
- 옵티마이저의 **Constraint-Based Query Transformation(CBQT)** 가 자동으로 해줄 수도 있으나,
  **명시**하면 더 안정적으로 **파티션 프루닝**/**인덱스 범위 스캔** 유도.

### “무결성 제약”을 필터로 승격

- **CHECK 제약** 예: `amount >= 0`, `qty >= 0`
  - 전 행이 만족하면 **필터 추가는 의미 없음**(집합 불변).
  - 하지만 **통계 추론**엔 도움될 수 있다(특히 다중 테이블 조인에서 범위를 좁힐 때).
- **NOT NULL** 제약
  - 조인에서 `IS NOT NULL`을 명시하면, 조인 순서/선택도 평가가 바뀌어 더 좋은 플랜이 나오기도.

> **실전 팁**: 논리적으로 항상 참인 조건을 **아무 데나** 붙이는 건 의미가 없다.
> “**프루닝을 실제로 유발**”하는 조건(파티션 키/인덱스 선두/선택도 높은 컬럼)을 **명시**하라.

### “`NVL/COALESCE` 패턴”을 **OR 분기/상수 테이블 조인**으로 변환

**안 좋은 예(안전하지만 비SARGABLE)**
```sql
-- 선택적 파라미터
WHERE NVL(:p_brand, p.brand) = p.brand
AND   NVL(:lo, DATE '1900-01-01') <= s.dt
AND   NVL(:hi, DATE '9999-12-31') >  s.dt
```
- 위는 **컬럼에 함수**가 걸려 인덱스 활용이 약해진다.

**개선 — 분기화(OR-Expansion/USE_CONCAT)**
```sql
WHERE (:p_brand IS NULL OR p.brand = :p_brand)
AND   ( (:lo IS NULL OR s.dt >= :lo)
   AND (:hi IS NULL OR s.dt <  :hi) )
```

**또는 상수 테이블 조인**
```sql
WITH rng AS (SELECT :lo lo, :hi hi FROM dual)
SELECT ...
FROM f_sales s
JOIN rng
WHERE (rng.lo IS NULL OR s.dt >= rng.lo)
  AND (rng.hi IS NULL OR s.dt <  rng.hi);
```
- **컬럼을 가공하지 않도록** 재구성 → **SARGABLE**.

---

## 조건절 비교 순서 (Predicate Order) — **평가 순서**가 아니라 **작성 습관**

### 원칙: **열(컬럼)은 좌변에서 가공금지**, **상수/바인드는 우변**

- 좋음: `col = :b`, `col >= :lo`, `col LIKE :prefix || '%'`
- 나쁨: `TO_CHAR(col,'YYYYMM') = :mm`, `NVL(col, 0) = :x`, `SUBSTR(col,1,3) = 'ABC'`

**개선 예**
```sql
-- 나쁨
WHERE TO_CHAR(s.dt,'YYYYMM') = :mm

-- 좋음
WHERE s.dt >= TO_DATE(:mm || '01','YYYYMMDD')
  AND s.dt <  ADD_MONTHS(TO_DATE(:mm || '01','YYYYMMDD'), 1)

-- 나쁨
WHERE SUBSTR(p.brand,1,3) = 'SAM'

-- 좋음
WHERE p.brand LIKE 'SAM%'
-- (자주 쓰면 함수기반 인덱스: CREATE INDEX ix_fb ON d_product(SUBSTR(brand,1,3));)
```

### `AND`/`OR`의 **순서** 자체는 의미 없음 (옵티마이저가 재배치)

- Oracle SQL은 **단락평가(short-circuit)** 를 보장하지 않습니다(PL/SQL은 보장).
- “싼 것부터 먼저”처럼 **순서를 바꿔도 성능 보장은 안 됨**.
- 대신 **형태**를 바꿔 **SARGABLE**/**OR-EXPANSION**/**SEMI/ANTI 조인**으로 변환하는 것이 실제 성능에 영향.

**OR-Expansion 예**
```sql
-- 나쁨 (OR가 인덱스를 막음)
WHERE (p.category = 'ELEC' AND s.dt >= :lo AND s.dt < :hi)
   OR (p.category = 'HOME' AND s.dt >= :lo AND s.dt < :hi)

-- 좋음: USE_CONCAT 또는 UNION ALL
SELECT ...
FROM f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE p.category = 'ELEC' AND s.dt >= :lo AND s.dt < :hi
UNION ALL
SELECT ...
FROM f_sales s JOIN d_product p ON p.prod_id = s.prod_id
WHERE p.category = 'HOME' AND s.dt >= :lo AND s.dt < :hi;
```

### 비교 연산자 좌우 순서( `:b = col` vs `col = :b` )

- Oracle은 보통 **정규화**하여 동일하게 취급.
- 다만 **함수기반 인덱스**, **가상 컬럼**, **생성식 컬럼** 등에서는 **표현식 모양**이 중요 → **항상 컬럼을 좌변**에.

### 선택도 높은 조건은 **별도 인덱스** 혹은 **결합 인덱스 선두**로

- 순서를 바꾸는 게 아니라 **인덱스 설계**로 해결.
- 예: `(category, dt)` 결합 인덱스가 있으면 `category='ELEC' AND dt BETWEEN …`가 **범위 스캔**으로 잘 동작.

---

## 통합 예제 — 세 가지 변환을 한 번에

### 목표

- 2025-02 월, ELEC 카테고리, 유효 고객(`cust_id IS NOT NULL`)의 매출 합계를 **최적** 경로로.

**Before**
```sql
SELECT SUM(s.amount)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_date    d ON d.dt      = s.dt
WHERE  p.category = NVL(:cat, p.category)      -- 비SARGABLE
AND    d.yyyymm   = :mm                         -- 파티션 키 미활용 가능
AND    s.cust_id IS NOT NULL;                   -- 조기 프루닝 의도 (OK)
```

**After**
```sql
-- 1) 선택적 조건을 SARGABLE로
-- 2) 월 필터를 dt 범위로
-- 3) cust_id IS NOT NULL을 유지하여 카디널리티 추정/프루닝 도움
SELECT /*+ CARDINALITY(p 100) */
       SUM(s.amount)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  (:cat IS NULL OR p.category = :cat)
AND    s.dt >= TO_DATE(:mm || '01','YYYYMMDD')
AND    s.dt <  ADD_MONTHS(TO_DATE(:mm || '01','YYYYMMDD'), 1)
AND    s.cust_id IS NOT NULL;

-- 필요한 경우: ELEC/홈 등 소수 카테고리 집합이면 상수 테이블 조인
WITH cats AS (
  SELECT :cat AS category FROM dual
)
SELECT SUM(s.amount)
FROM   cats c
JOIN   d_product p ON p.category = c.category
JOIN   f_sales   s ON s.prod_id  = p.prod_id
WHERE  s.dt >= TO_DATE(:mm || '01','YYYYMMDD')
AND    s.dt <  ADD_MONTHS(TO_DATE(:mm || '01','YYYYMMDD'), 1)
AND    s.cust_id IS NOT NULL;
```

**검증**
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +ALIAS +PREDICATE +NOTE'));

-- 세션 통계
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN ('session logical reads','physical reads','sorts (memory)','sorts (disk)');
```

---

## 체크리스트

- **조인 컬럼 `IS NOT NULL`**
  - [ ] OUTER JOIN 의미를 바꾸지 않는가? (바꿀 거면 **의도적**인가?)
  - [ ] FK **ENABLE VALIDATE** / **NOT NULL**인가? (JOIN 제거/INNER화 기대)
  - [ ] 실제 NULL 데이터가 있다면, 비즈니스 규칙상 배제해도 되는가?
- **필터 조건 추가**
  - [ ] **파티션 키/인덱스 선두 컬럼**에 대한 **명시적 범위/동치**를 제공했는가?
  - [ ] 차원 필터(`yyyymm`) → 사실 파티션 키(`dt`)로 **변환**했는가?
  - [ ] `NVL/COALESCE` 등 **비SARGABLE** 패턴을 **OR-분기/상수 조인**으로 바꿨는가?
- **조건절 비교 “순서”**
  - [ ] **컬럼은 좌변**, **가공 금지**(함수는 바인드/상수/상수 테이블 쪽으로).
  - [ ] `OR`는 **USE_CONCAT/UNION ALL**로 분기하여 인덱스 사용을 돕는가?
  - [ ] 힌트 없이도 통계/인덱스만으로 좋은 플랜이 나오는지 확인했는가?

---

## 미니 Q&A

**Q. INNER JOIN에서 `child.fk IS NOT NULL`은 꼭 필요?**
A. 결과는 동일하나, **뷰/서브쿼리/통계 상황**에 따라 카디널리티 추정이나 **조기 프루닝**에 도움돼 **더 나은 플랜**이 나올 수 있습니다.

**Q. 파라미터가 선택적일 때 `NVL(:p, col)=col` 써도 되나요?**
A. 기능은 같지만 **인덱스 사용이 약해짐**. `(:p IS NULL OR col = :p)` 혹은 **상수 테이블 조인**으로 바꾸세요.

**Q. 조건의 나열 순서가 실행 속도에 영향이 있나요?**
A. **보장되지 않습니다**(옵티마이저가 재배치). 속도는 **형태(SARGABLE 여부, 프루닝 가능성)** 와 **통계/인덱스**가 좌우합니다.

---

### 결론

- **의미 보존**을 최우선으로 하되, **`IS NOT NULL`의 명시화**와 **필터의 파티션/인덱스 친화적 변환**, **SARGABLE 형태 유지**가 쿼리 성능의 핵심입니다.
- “순서”보다 **모양**을 바꿔라 — 컬럼은 **가공하지 말고**, **필터는 명시적으로**, **OR은 분기**하라.
- 마지막은 항상 **플랜/세션 통계**로 **전/후 검증**입니다.
