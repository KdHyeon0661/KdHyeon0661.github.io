---
layout: post
title: DB - 반정규화
date: 2025-02-07 20:20:23 +0900
category: DB
---
# 반정규화가 데이터 무결성에 미치는 영향과 관리 전략

## 개요: 성능과 무결성 사이의 균형

반정규화는 데이터베이스 성능 최적화를 위한 강력한 도구이지만, 동시에 데이터 무결성을 훼손할 수 있는 위험을 내포합니다. 이러한 위험을 체계적으로 이해하고 관리하지 않으면, 시스템은 점점 더 예측 불가능하고 유지보수하기 어려운 상태로 빠질 수 있습니다. 반정규화가 데이터 무결성에 미치는 영향을 네 가지 핵심 축에서 살펴보면 다음과 같습니다.

1.  **데이터 중복**: 동일한 정보가 여러 곳에 저장되면, 한 곳에서의 변경이 다른 모든 곳에 즉시 반영되지 않을 경우 불일치가 발생합니다.
2.  **의존성 파괴**: 정규화가 보장하던 함수적 종속성과 명확한 참조 관계가 희석되어, 데이터 간의 논리적 연결이 약화됩니다.
3.  **동시성 문제**: 여러 테이블을 동시에 갱신해야 하는 상황에서 트랜잭션 관리가 복잡해지고, 교착 상태나 부분 실패의 가능성이 높아집니다.
4.  **일시적 불일치**: 변경 사항을 비동기적으로 전파하는 방식(CDC, 배치)을 사용할 경우, 시스템이 '최종 일관성' 상태에 도달하기까지 일시적인 데이터 불일치가 발생할 수 있습니다.

성공적인 반정규화는 이러한 네 가지 위험을 인지하고, 의도적으로 설계된 메커니즘을 통해 이를 통제하는 데서 시작합니다.

---

## 사례 연구 1: 주문 테이블에 고객명 스냅샷 저장

### 배경 및 의도

주문 목록이나 리포트를 조회할 때마다 `order` 테이블과 `customer` 테이블을 조인하는 비용을 줄이기 위해, `order` 테이블에 `customer_name_snapshot` 컬럼을 추가합니다. 이로 인해 조인 연산이 제거되고, I/O가 감소하며, 인덱스 커버링이 쉬워져 쿼리 성능이 크게 향상됩니다.

### 발생할 수 있는 무결성 문제

고객의 이름이 변경되면, 원본 데이터인 `customer` 테이블과 중복 저장된 스냅샷 데이터인 `order` 테이블의 컬럼을 모두 업데이트해야 합니다. 만약 두 업데이트 중 하나라도 실패하거나 누락된다면, 시스템 내에 "홍길동"과 "홍길순"이라는 두 개의 다른 이름이 공존하는 불일치 상태가 장기간 지속될 수 있습니다.

### 해결 전략: 동기화 메커니즘 설계

이러한 불일치를 방지하기 위해, 원본과 복사본의 업데이트를 하나의 논리적 단위로 묶는 동기화 메커니즘을 반드시 도입해야 합니다.

**1. 저장 프로시저를 통한 통제된 업데이트**
가장 직접적인 방법은 이름 변경 로직을 데이터베이스 저장 프로시저로 캡슐화하는 것입니다. 애플리케이션은 이 프로시저만 호출함으로써 두 테이블의 원자적 갱신을 보장받습니다.

```sql
CREATE OR REPLACE PROCEDURE update_customer_name(
  p_customer_id BIGINT,
  p_new_name    TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE customer
     SET name = p_new_name
   WHERE customer_id = p_customer_id;

  UPDATE "order"
     SET customer_name_snapshot = p_new_name
   WHERE customer_id = p_customer_id;
END;
$$;
```
*장점*: 모든 업데이트 경로(API, 관리자 도구)가 이 단일 진입점을 통하도록 강제할 수 있습니다.
*주의점*: 프로시저 외부에서 직접 SQL을 실행하지 못하도록 접근 권한을 관리해야 합니다.

**2. 트리거를 이용한 자동 동기화**
`customer` 테이블에서 이름이 변경될 때마다 자동으로 `order` 테이블을 갱신하는 트리거를 설정할 수 있습니다.
```sql
CREATE TRIGGER sync_customer_name_after_update
AFTER UPDATE OF name ON customer
FOR EACH ROW
EXECUTE FUNCTION sync_customer_name();
```
*장점*: 애플리케이션 로직이 원본만 업데이트하면 되므로 간편합니다.
*주의점*: 대량 업데이트 시 성능 저하와 잠금 경합이 발생할 수 있으며, 트리거 연쇄 실행으로 인한 복잡성을 관리해야 합니다.

**3. 변경 데이터 캡처(CDC)를 통한 느슨한 결합**
Debezium이나 데이터베이스의 논리적 복제 기능을 사용해 `customer` 테이블의 변경 이벤트를 스트림으로 발행합니다. 별도의 컨슈머 서비스가 이 이벤트를 수신하여 `order` 테이블의 스냅샷을 비동기적으로 업데이트합니다.
*장점*: 핵심 트랜잭션 경로의 부하를 줄이고, 서비스 간 결합도를 낮춥니다.
*주의점*: 이벤트 처리 지연 동안(몇 초~몇 분) 데이터 불일치가 존재할 수 있으므로, UI나 리포트에서 이를 어떻게 표시할지 전략이 필요합니다.

**4. 정기적 무결성 검증**
어떤 동기화 방식을 사용하더라도, 주기적으로 데이터 불일치를 탐지하고 수정하는 "수리" 작업이 필요합니다.
```sql
-- 불일치 데이터 탐지 쿼리
SELECT o.order_id, o.customer_id, o.customer_name_snapshot, c.name AS current_name
FROM "order" o
JOIN customer c USING (customer_id)
WHERE o.customer_name_snapshot IS DISTINCT FROM c.name;
```
이 쿼리의 결과를 모니터링하고, 불일치 건수가 일정 수준을 초과하면 자동 또는 수동으로 수정 배치 작업을 실행할 수 있습니다.

---

## 사례 연구 2: 게시글 댓글 수 카운터

### 배경 및 의도

게시글 목록에서 각 게시글의 댓글 수를 보여주기 위해 `SELECT COUNT(*) FROM comment WHERE post_id = ?` 쿼리를 매번 실행하는 것은 비효율적입니다. 대신 `post` 테이블에 `comment_count` 컬럼을 추가하여 이 값을 실시간으로 유지합니다.

### 발생할 수 있는 무결성 문제

동시에 여러 사용자가 댓글을 작성하거나 삭제할 경우, **경쟁 상태(Race Condition)**가 발생할 수 있습니다. 두 개의 트랜잭션이 동시에 `comment_count`를 읽고, 각자 1을 더한 후 저장하면, 실제로는 2개의 댓글이 추가되었지만 카운터는 1만 증가하는 결과를 초래합니다.

### 해결 전략: 원자적 연산과 재계산

**1. 트랜잭션 내에서의 원자적 증감**
댓글 삽입/삭제와 카운터 업데이트를 반드시 하나의 트랜잭션으로 묶습니다. 데이터베이스의 행 수준 잠금이 경쟁 상태를 방지합니다.
```sql
BEGIN;
INSERT INTO comment (post_id, content) VALUES (123, '새 댓글');
UPDATE post SET comment_count = comment_count + 1 WHERE post_id = 123;
COMMIT;
```

**2. 주기적인 재계산 및 보정**
아무리 잘 설계해도 미세한 불일치가 누적될 수 있습니다. 따라서 주기적으로(예: 매일 새벽) 진실의 원천(source of truth)인 `comment` 테이블로부터 정확한 카운트를 재계산하여 `post.comment_count`를 보정하는 배치 작업을 실행합니다.
```sql
UPDATE post p
SET comment_count = (
  SELECT COUNT(*) FROM comment c WHERE c.post_id = p.post_id
);
```
이 "수리" 작업은 시스템에 일시적인 부하를 주지만, 장기적인 데이터 정확성을 보장합니다.

---

## 사례 연구 3: 일별 매출 요약 테이블

### 배경 및 의도

대시보드에서 매일의 매출 추이를 빠르게 보여주기 위해, `order` 테이블에 대한 고비용의 집계 쿼리(`SUM(amount) GROUP BY date`) 결과를 `daily_sales_summary` 테이블에 미리 계산하여 저장합니다.

### 발생할 수 있는 무결성 문제

주문이 생성, 취소, 변경될 때마다 요약 테이블을 정확히 동기화해야 합니다. 트리거로 실시간 유지할 경우 고부하 트래픽에서 성능 병목이 될 수 있고, 배치로 유지할 경우 실시간성이 떨어집니다.

### 해결 전략: 적절한 갱신 전략 선택

**트리거 기반 실시간 동기화**는 높은 정확도를 보장하지만, 주문 테이블의 모든 쓰기 작업에 추가 오버헤드를 부과합니다. **배치 기반 동기화**(예: 5분마다 최근 변경사항 반영)는 원본 트랜잭션 성능에 영향을 주지 않지만, "T+5분" 지연이 발생합니다.

선택은 비즈니스 요구사항에 달려 있습니다. 재무 보고서에는 배치 방식이 적합할 수 있으나, 실시간 모니터링 대시보드에는 트리거나 CDC 스트림 처리가 필요할 수 있습니다. 핵심은 요약 데이터의 "새로움"에 대한 명확한 서비스 수준 목표(SLO)를 정의하는 것입니다.

---

## 종합 관리 프레임워크: 관측, 수리, 개선

반정규화된 구조를 운영한다는 것은 단순히 동기화 코드를 작성하는 것을 넘어, 지속적인 관측과 유지보수의 체계를 마련하는 것을 의미합니다.

1.  **관측(Observability)**: 앞서 소개한 불일치 탐지 쿼리를 정기적으로 실행하거나, 주요 동기화 파이프라인의 지연 시간, 실패율을 모니터링합니다. 이를 통해 문제가 발생했을 때 빠르게 인지할 수 있습니다.
2.  **수리(Repair)**: 발견된 불일치를 자동 또는 반자동으로 수정하는 프로세스를 마련합니다. 이는 단순한 UPDATE 쿼리부터, 복잡한 보정 배치 작업까지 다양할 수 있습니다.
3.  **개선(Evolution)**: 반정규화로 인한 운영 부담이 예상보다 커진다면, 해당 최적화가 정말 필요한지 재평가합니다. 때로는 인덱스 추가, 쿼리 최적화, 애플리케이션 캐시 도입 등 다른 방법이 더 나은 해결책이 될 수 있습니다.

---

## 결론: 의도적 설계와 통제된 절충

반정규화는 데이터베이스 설계에서 '빠름'과 '정확함' 사이의 의식적인 절충입니다. 이는 성능이라는 확실한 이득을 제공하지만, 그 대가로 시스템에 새로운 복잡성—데이터 무결성 유지 책임—을 부과합니다.

이러한 비용을 성공적으로 관리하는 핵심은 **계획적 통제**에 있습니다. 단순히 중복 컬럼을 추가하는 데 그쳐서는 안 되며, 다음과 같은 요소를 반드시 함께 설계해야 합니다.
*   **원자성 보장 메커니즘**: 트랜잭션, 저장 프로시저, 트리거 등을 통해 중복 데이터 간의 일관성을 유지할 방법.
*   **동기화 전략**: 실시간 트리거, 배치 작업, 이벤트 기반 CDC 중 상황에 맞는 적절한 선택.
*   **감시 및 수리 체계**: 불일치를 탐지하고 자동으로 교정할 수 있는 모니터링과 운영 프로세스.
*   **롤백 계획**: 반정규화가 예상치 못한 문제를 일으킬 경우, 시스템을 안전하게 원래 상태로 되돌릴 수 있는 경로.

결국, 반정규화는 최적화 기법이기 이전에 **위험 관리 도구**입니다. 데이터의 정확성을 훼손하지 않으면서 성능을 극대화하려는 지속적인 노력의 일환으로 이해하고 접근할 때, 그 진정한 가치를 발휘할 수 있습니다.