---
layout: post
title: DB - 반정규화
date: 2025-02-07 20:20:23 +0900
category: DB
---
# 반정규화가 데이터 무결성에 미치는 영향

## 0. 무결성 관점에서의 반정규화 리스크 지도

반정규화가 개입하면 주로 다음 네 축에서 무결성 위험이 발생한다.

1) **데이터 중복**: 동일 의미 데이터가 여러 테이블/열에 산재 → 업데이트 누락/순서 경합  
2) **의존성 파괴**: 정규형이 전제한 함수적 종속·참조 제약이 약화/유실  
3) **동시성·격리**: 여러 테이블을 동시 갱신하는 과정에서 잠금/교착/부분 실패  
4) **지연 동기화**: 비동기 파이프라인(배치/CDC)에서 **최종 일관성**에 따른 일시 불일치

정확한 설계는 위 4축을 **계획적으로 통제**하는 데서 시작한다.

---

## 1. 사례 A — “고객명 스냅샷” 중복 저장

### 1.1 배경과 목적
- `order`에 `customer_name_snapshot`을 저장해 주문 목록/리포트에서 고객 테이블 조인 없이 빠르게 조회.
- 반정규화 이득: 조인 제거, I/O 감소, 인덱스 커버링 가능.

### 1.2 실패 양상
- 고객의 이름이 바뀐다면 **원본(Customer)**과 **스냅샷(Order)**을 **동시에** 갱신해야 한다.
- 갱신 누락/부분 실패 시 **불일치**가 장기간 잔존.

### 1.3 원자적(Atomic) 동기화 — 트랜잭션 + 저장 프로시저

```sql
-- PostgreSQL 예시
CREATE OR REPLACE PROCEDURE sp_update_customer_name(
  p_customer_id BIGINT,
  p_new_name    TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- 하나의 트랜잭션으로 묶어 원자성 확보
  -- (호출 측에서 CALL 앞뒤로 BEGIN/COMMIT을 사용)
  UPDATE customer
     SET name = p_new_name, updated_at = now()
   WHERE customer_id = p_customer_id;

  UPDATE "order"
     SET customer_name_snapshot = p_new_name
   WHERE customer_id = p_customer_id;
END;
$$;

-- 사용
BEGIN;
CALL sp_update_customer_name(101, '홍길순');
COMMIT;
```

장점  
- 애플리케이션이 **반드시 프로시저를 호출**하게 하면 일관성 강화.  
주의  
- 모든 갱신 경로(관리자 콘솔, 배치, API)가 **이 프로시저를 경유**해야 한다.

### 1.4 반자동 동기화 — AFTER UPDATE 트리거

```sql
CREATE OR REPLACE FUNCTION f_sync_customer_name() RETURNS trigger AS $$
BEGIN
  IF NEW.name IS DISTINCT FROM OLD.name THEN
    UPDATE "order"
       SET customer_name_snapshot = NEW.name
     WHERE customer_id = NEW.customer_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_customer_name_sync
AFTER UPDATE OF name ON customer
FOR EACH ROW
EXECUTE FUNCTION f_sync_customer_name();
```

장점  
- ‘원본 변경’만 해도 자동 전파.  
주의  
- 대량 갱신 시 **잠금/경합 증가**.  
- 트리거 체인/순서 문제로 **예상치 못한 실행 순서**가 발생할 수 있다.

### 1.5 비동기(최종 일관성) — CDC(Change Data Capture)

- Debezium/Oracle GoldenGate/Logical Replication 등으로 **원본 변경 이벤트**를 스트림으로 내보내고,  
  컨슈머가 `order.customer_name_snapshot`을 갱신.
- 장점: 핵심 트랜잭션 경로의 **지연/잠금 부하 최소화**.  
- 주의: 지연 시간 동안 **일시적 불일치 허용**(UI/리포트에서 표시/보정 전략 필요).

### 1.6 정합성 검증 쿼리(일일 점검/알람)

```sql
-- 고객-주문 스냅샷 불일치 탐지
SELECT o.order_id, o.customer_id, o.customer_name_snapshot, c.name AS canonical
FROM "order" o
JOIN customer c USING (customer_id)
WHERE o.customer_name_snapshot IS DISTINCT FROM c.name
LIMIT 100;
```

---

## 2. 사례 B — “댓글 수” 카운터 컬럼 반정규화

### 2.1 배경과 목적
- `post.comment_count`를 유지하여 `COUNT(*) WHERE post_id = ?` 조인을 피함.
- 삽입/삭제 시 카운터 증감.

### 2.2 경쟁 상태(Race Condition)·이중 반영 위험
- 동시 댓글 삽입/삭제, 재시도 로직, 중복 소비(메시지 큐)로 **카운터가 틀어질 수 있음**.

### 2.3 트랜잭션 내 증감(낙관적·비관적)

```sql
-- 동시성 고려: FK 제약 + 한 트랜잭션에서 INSERT와 증감을 처리
BEGIN;

INSERT INTO comment(post_id, author_id, content)
VALUES (:post_id, :author_id, :content);

UPDATE post
   SET comment_count = comment_count + 1
 WHERE post_id = :post_id;

COMMIT;
```

주의  
- 동시 다중 증가 시 **갱신 경합**이 커질 수 있다(행 잠금).  
- DB마다 **증감 내구성/격리 수준** 차이가 있으며, 재시도 전략이 필요하다.

### 2.4 비동기 수선(Repair) — 재계산 잡

```sql
-- 주기적으로 진실원(댓글 테이블)로부터 재계산
UPDATE post p
SET comment_count = sub.cnt
FROM (
  SELECT post_id, COUNT(*) AS cnt
  FROM comment
  GROUP BY post_id
) sub
WHERE p.post_id = sub.post_id
  AND p.comment_count IS DISTINCT FROM sub.cnt;
```

- 운영에서 “오차 추정치”가 임계 이상이면 **수선 잡**을 트리거한다.

---

## 3. 사례 C — 요약 테이블(Materialized Summary)과 회계적 일관성

### 3.1 배경과 목적
- `daily_sales_sum(d, revenue)`를 유지하여 대시보드/보고서 고속화.

### 3.2 트리거 유지 vs 배치/CDC

**트리거 유지 예시**

```sql
CREATE TABLE daily_sales_sum (
  d date PRIMARY KEY,
  revenue numeric(18,2) NOT NULL DEFAULT 0
);

CREATE OR REPLACE FUNCTION f_sum_sales_trg() RETURNS trigger AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO daily_sales_sum(d, revenue)
    VALUES (NEW.ordered_at::date, NEW.amount)
    ON CONFLICT (d) DO UPDATE
    SET revenue = daily_sales_sum.revenue + EXCLUDED.revenue;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE daily_sales_sum
       SET revenue = revenue - OLD.amount
     WHERE d = OLD.ordered_at::date;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_order_sum
AFTER INSERT OR DELETE ON "order"
FOR EACH ROW EXECUTE FUNCTION f_sum_sales_trg();
```

주의  
- **환불/수정(UPDATE)** 로직도 고려해야 한다. (INSERT/DELETE만 처리하면 불일치)  
- 고QPS 경로에서는 **락 경합**으로 지연 발생 가능.

**배치/CDC 유지**  
- 장점: 원본 트랜잭션 경량화, 지연/경합 완화.  
- 주의: **T+X 지연(최종 일관성)** 허용, “실시간” 정의를 명확히.

### 3.3 회계적 보전(Integrity) 검증

```sql
-- 원장 합계와 요약 합계 일치성 검사
WITH ledger AS (
  SELECT ordered_at::date AS d, SUM(amount) AS amt
  FROM "order"
  GROUP BY 1
)
SELECT l.d, l.amt AS ledger_amt, s.revenue AS summary_amt
FROM ledger l
LEFT JOIN daily_sales_sum s USING (d)
WHERE l.amt IS DISTINCT FROM s.revenue
ORDER BY l.d DESC
LIMIT 50;
```

---

## 4. 사례 D — 코드 테이블 삭제(하드코딩)와 무결성 약화

### 4.1 배경과 목적
- 크고 잦은 조인을 줄이기 위해 `country_code` 참조를 삭제하고 문자열로 직접 저장.

### 4.2 문제점
- 유효성(도메인) 검증 상실, 오타/레거시 값 축적, 보고서 기준 불일치.

### 4.3 대안 — 경량 캐시 + CHECK 제약

```sql
-- DB 내 최소한의 도메인 검증 유지
ALTER TABLE customer
ADD CONSTRAINT chk_country_code
CHECK (country_code ~ '^[A-Z]{2}$'); -- 형식 검증(예시)

-- 애플리케이션: 코드 테이블은 메모리 캐시/Redis로 조회(조인 제거)
```

---

## 5. 트랜잭션 설계 원칙(동시성·격리·락)

### 5.1 단일 책임 트랜잭션
- **한 변경 논리**(예: 고객명 변경) = **한 트랜잭션**.
- 필요한 모든 반정규화 대상 업데이트를 포함.

### 5.2 격리 수준 선택
- `READ COMMITTED` + 명시적 잠금/재시도: 대부분 OLTP에서 현실적인 절충.
- `SERIALIZABLE`: 논리 충돌 방지에 유리하지만 **스루풋 저하** 가능.

### 5.3 교착 회피
- **일관된 갱신 순서**(테이블/키 정렬)에 합의.  
- 작은 배치/짧은 트랜잭션/타임아웃·재시도.

---

## 6. 수학적 관점: 반정규화 오차의 기대값 스케치

- 카운터/요약 테이블을 **비동기**로 유지할 때, 단위시간당 변경 이벤트 수를 \(\lambda\),  
  컨슈머 지연을 \(T\)라 하면, UI에 표시되는 오차의 기대치는 대략:

$$
\mathbb{E}[\text{error}] \propto \lambda \cdot T
$$

- 즉, **변경률**이 높고 **동기화 지연**이 크면 **표시 오차**가 증가한다.  
- 운영에서 \(T\)의 상한을 SLO로 관리하고, 고QPS 구간은 **동기/부분 동기**로 보완한다.

---

## 7. 검증·모니터링·자동 수선(Repair) 파이프라인

### 7.1 불일치 탐지 뷰/잡

```sql
-- 1) 스냅샷 불일치(고객명)
CREATE OR REPLACE VIEW v_incons_customer_name AS
SELECT o.order_id, o.customer_id, o.customer_name_snapshot, c.name AS canonical
FROM "order" o
JOIN customer c USING (customer_id)
WHERE o.customer_name_snapshot IS DISTINCT FROM c.name;

-- 2) 카운터 불일치(댓글 수)
CREATE OR REPLACE VIEW v_incons_comment_count AS
SELECT p.post_id, p.comment_count, sub.cnt AS real_cnt
FROM post p
JOIN (
  SELECT post_id, COUNT(*) AS cnt FROM comment GROUP BY post_id
) sub USING (post_id)
WHERE p.comment_count IS DISTINCT FROM sub.cnt;
```

### 7.2 자동 수선(권장: 백그라운드 잡/운영 콘솔)

```sql
-- 고객명 스냅샷 수선
UPDATE "order" o
SET customer_name_snapshot = c.name
FROM customer c
WHERE c.customer_id = o.customer_id
  AND o.customer_name_snapshot IS DISTINCT FROM c.name;

-- 댓글 카운트 수선
UPDATE post p
SET comment_count = sub.cnt
FROM (
  SELECT post_id, COUNT(*) AS cnt FROM comment GROUP BY post_id
) sub
WHERE p.post_id = sub.post_id
  AND p.comment_count IS DISTINCT FROM sub.cnt;
```

### 7.3 운영 알람
- v_incons_* 결과가 임계 초과 시 알람(Slack/PagerDuty).  
- 요약 테이블과 원장 간 차이가 일정 금액/비율 초과 시 알람.

---

## 8. 마이그레이션·롤백 전략(반정규화 도입/철회)

### 8.1 도입(스냅샷 열 추가) 절차
1) **열 추가** (`order.customer_name_snapshot`)  
2) **백필**(한 번에 하지 말고 배치/스케줄)  
3) **검증**(불일치 뷰로 샘플링)  
4) **동기화 메커니즘 연결**(프로시저/트리거/CDC)  
5) **읽기 경로 전환**(피처 플래그)  
6) **관찰**(p95/오차율) 후 고정

### 8.2 롤백
- 플래그로 원복(조인 경로 복귀) → 동기화 중지 → 열 삭제(선택).  
- 요약 테이블은 **참조 해제 후** 보관/삭제.

---

## 9. DBMS별 구현 팁

| 주제 | PostgreSQL | MySQL(InnoDB) | Oracle |
|---|---|---|---|
| 트리거 | 성숙 | AFTER/BEFORE, 성능 주의 | 복잡 시 프로시저 패턴 권장 |
| 부분 인덱스 | 지원(조건부) | 제한적(함수/표현식 주의) | 함수 기반 인덱스 풍부 |
| 물질화 뷰 | 지원 | 미지원(직접 테이블+잡) | 물질화 뷰 강력(FAST REFRESH) |
| CDC | Logical Replication/Debezium | binlog 기반 Debezium | GoldenGate/Streams |

---

## 10. 종합 예제 — “정규화 → 반정규화 → 운영 보전”

### 10.1 초기 스키마(정규화)

```sql
CREATE TABLE customer (
  customer_id BIGSERIAL PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name  TEXT NOT NULL,
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE "order" (
  order_id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id),
  ordered_at timestamptz NOT NULL,
  amount NUMERIC(12,2) NOT NULL CHECK (amount >= 0)
);
```

### 10.2 반정규화(스냅샷 + 요약)

```sql
ALTER TABLE "order" ADD COLUMN customer_name_snapshot TEXT;

-- 백필
UPDATE "order" o
SET customer_name_snapshot = c.name
FROM customer c
WHERE c.customer_id = o.customer_id;

-- 요약 테이블
CREATE TABLE daily_customer_sales (
  customer_id BIGINT NOT NULL,
  d date NOT NULL,
  revenue NUMERIC(18,2) NOT NULL,
  PRIMARY KEY (customer_id, d)
);
```

### 10.3 동기화(프로시저 + 배치)

```sql
CREATE OR REPLACE PROCEDURE sp_update_customer_name(
  p_customer_id BIGINT, p_new_name TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE customer
     SET name = p_new_name, updated_at = now()
   WHERE customer_id = p_customer_id;

  UPDATE "order"
     SET customer_name_snapshot = p_new_name
   WHERE customer_id = p_customer_id;
END;
$$;

-- 일별 요약(배치 예시)
INSERT INTO daily_customer_sales(customer_id, d, revenue)
SELECT customer_id, ordered_at::date, SUM(amount)
FROM "order"
WHERE ordered_at::date = current_date - 1
GROUP BY 1,2
ON CONFLICT (customer_id, d) DO UPDATE
SET revenue = EXCLUDED.revenue;
```

### 10.4 검증/수선/모니터링

```sql
-- 스냅샷 불일치
SELECT COUNT(*) AS mismatch
FROM "order" o JOIN customer c USING (customer_id)
WHERE o.customer_name_snapshot IS DISTINCT FROM c.name;

-- 요약 검증
WITH ledger AS (
  SELECT customer_id, ordered_at::date AS d, SUM(amount) AS amt
  FROM "order"
  GROUP BY 1,2
)
SELECT COUNT(*) AS diff_rows
FROM ledger l
LEFT JOIN daily_customer_sales s USING (customer_id, d)
WHERE l.amt IS DISTINCT FROM s.revenue;
```

---

## 11. 체크리스트 — “반정규화 OK” 판정 전

- **정량 근거**: 실행계획/프로파일링/락 경합 로그로 병목 증명  
- **대안 실패**: 인덱스/파티션/쿼리 재작성/캐시 시도 후에도 미해결  
- **정합성 계획**: 동기화 경로(프로시저/트리거/CDC)·검증 뷰·수선 잡 설계  
- **롤백 경로**: 플래그 전환/데이터 보전/다운타임 계획  
- **모니터링**: p95/99 지연, 오차율, 실패율, 잠금 대기, 컨슈머 지연(SLA)  
- **문서화**: 스키마 주석/Playbook/운영 대시보드 링크

---

## 12. 결론

- 반정규화는 **성능을 위한 의도적 제약 완화**이며, 그 대가로 **무결성 유지 비용**이 시스템으로 이관된다.  
- 안전한 반정규화는 **원자적 트랜잭션**, **일관된 동기화 메커니즘(프로시저/트리거/CDC)**, **정기 검증·자동 수선**, **모니터링과 롤백 플랜** 위에서만 성립한다.  
- “빠름”과 “정확함”의 균형은 **설계·운영·관찰**의 닫힌 고리로 담보된다.