---
layout: post
title: 디지털신호처리 - FIR 필터 구조, 격자 필터 구조
date: 2025-11-11 23:25:23 +0900
category: 디지털신호처리
---
# FIR 필터 구조와 격자(Lattice) 필터 구조

이번 글은 그 연장선에서 **FIR 필터 구조**와 **격자(Lattice) 필터 구조**를 집중적으로 다룬다.  

- FIR 필터의 일반 구조(Transversal, Transposed, 선형 위상 구조, Polyphase 구조 등)
- 격자 FIR 필터 구조(Forward/Backward 신호, 반사계수, 구조적 특징)
- 격자-사다리(lattice–ladder) 구조의 개념적 소개  

---

## 1. 복습: FIR vs IIR — 구조 관점에서

앞 글에서 봤던 IIR 차분방정식을 다시 적어보면 다음과 같았다.

$$
y[n] = -\sum_{k=1}^{N} a_k y[n-k]
      + \sum_{k=0}^{M} b_k x[n-k]
$$

여기서 오른쪽에 과거 출력 항 \(y[n-k]\) 들이 들어가는 **피드백** 때문에 임펄스 응답이 일반적으로 무한히 길어져서 **IIR(Infinite Impulse Response)** 라고 불렀다.

FIR(Finite Impulse Response) 필터의 차분방정식은 출력 피드백이 없는 형태다.

$$
y[n] = \sum_{k=0}^{M} b_k x[n-k]
$$

- 과거 출력 \(y[\cdot]\) 이 등장하지 않는다.
- 기본 소자 관점에서 보면, **입력 지연선 + 곱셈기 + 가산기**만 있고 피드백 루프가 없다.
- 임펄스 입력 \(x[n] = \delta[n]\) 을 넣으면,

  $$
  h[n] =
  \begin{cases}
  b_n, & 0 \le n \le M \\
  0,   & \text{그 외}
  \end{cases}
  $$

  임펄스 응답이 길이 \(M+1\) 인 **유한 길이**이므로 FIR 이다.

즉, **FIR 필터 구조**란 곧

- 입력 지연선(tapped delay line)
- 각 탭마다 곱셈기(계수 곱)
- 이들을 모아서 더하는 가산기

를 어떻게 배치해 구현하느냐의 문제다.

---

## 2. FIR 필터의 일반식과 전송함수

일반적인 FIR 필터는 차수 \(M\) 에 대해 다음과 같이 표현한다.

$$
y[n] = \sum_{k=0}^{M} b_k x[n-k]
$$

여기서:

- \(b_k\): FIR 계수(탭 가중치)
- \(x[n]\): 입력
- \(y[n]\): 출력

전송함수는 다음과 같다.

$$
H(z) = \frac{Y(z)}{X(z)} = \sum_{k=0}^{M} b_k z^{-k}
$$

극점이 모두 원점에 몰려 있고(이상적인 FIR 은 분모가 1),  
따라서 **항상 BIBO 안정**이다.

이제 이 식을 어떻게 **블록 구조**로 구현하는지 본다.

---

## 3. Direct Form(Transversal) FIR 구조

### 3.1 구조 개념

가장 직관적인 FIR 구조는 **Transversal 구조(탭 지연선 구조)** 라고 부른다.  
차분방정식

$$
y[n] = b_0 x[n] + b_1 x[n-1] + \cdots + b_M x[n-M]
$$

을 그대로 블록도로 옮기면 된다.

텍스트 블록도(예: \(M=3\)):

```text
x[n] ───▶[ z⁻¹ ]──▶[ z⁻¹ ]──▶[ z⁻¹ ]
  │          │          │          │
 [×b0]     [×b1]     [×b2]     [×b3]
  │          │          │          │
  └──────────┴──────────┴──────────┘
                      │
                      ▼
                    y[n]
```

- 맨 왼쪽 탭: 지연이 0, 계수 \(b_0\)
- 그 다음 탭: 지연 1, 계수 \(b_1\)
- …

필요한 소자 수:

- 지연소자: \(M\) 개
- 곱셈기: \(M+1\) 개
- 가산기: \(M\) 개 정도 (누적 덧셈)

### 3.2 Direct Form FIR의 차분방정식과 동일성

지연선의 각 출력은 \(x[n-k]\) 이므로, 탭에서 곱셈기로 계수 \(b_k\) 를 곱하면 \(b_k x[n-k]\) 가 된다.  
이들을 모두 가산기에 모으면 정확히 위의 차분방정식이 된다.

### 3.3 GNU Octave 구현 예제 (Direct Form FIR)

가장 단순한 Direct Form FIR 구현을 GNU Octave 함수로 작성해 보자.

```matlab
function y = fir_direct(b, x)
  % FIR Direct Form (Transversal) 구조 구현
  % b: FIR 계수 (1 x (M+1) 벡터)
  % x: 입력 벡터 (행 또는 열)
  % y: 출력 벡터 (x와 동일한 크기)

  b = b(:).';              % b를 행벡터로 정규화
  x = x(:).';              % x를 행벡터로 정규화

  M = length(b) - 1;
  x_delay = zeros(1, M);   % x[n-1], x[n-2], ..., x[n-M]

  y = zeros(size(x));

  for n = 1:length(x)
    % 현재 탭들에서 읽을 샘플들 구성
    % x0 = x[n], x1 = x[n-1], ...
    x_taps = [x(n), x_delay];

    % 계수와의 내적이 곧 y[n]
    y(n) = b * x_taps.';   % 벡터 내적

    % 지연선 업데이트
    if M > 0
      x_delay(2:end) = x_delay(1:end-1);
      x_delay(1) = x(n);
    end
  end

  % 입력과 동일한 형태로 결과 반환
  if iscolumn(x)
    y = y.';
  end
end
```

사용 예:

```matlab
% 예: 간단한 이동 평균 필터 (길이 4)
b = ones(1, 4) / 4;  % [1/4 1/4 1/4 1/4]
x = [1 2 3 4 5 6 7 8];

y = fir_direct(b, x);
disp(y);
```

이 필터는 최근 4개 샘플의 평균을 계산하는 **저역통과 필터** 역할을 한다.

---

## 4. Transposed FIR 구조

### 4.1 Transposition theorem

LTI 시스템의 블록도를 **뒤집고 화살표 방향을 바꾸면** 여전히 같은 전송함수를 가진다(Transposition theorem).  
FIR Direct Form 구조에 이 정리를 적용하면 **Transposed FIR 구조**가 나온다.

Transposed 구조는 다음과 같은 특징이 있다.

- 곱셈기 바로 뒤에서 부분합을 만들어 나가는 구조
- 파이프라인/병렬화·하드웨어 구현에 유리한 경우가 많다
- 내부 노드에서 지연이 걸리므로 지연선의 위치와 의미가 Direct Form 과 다르다

### 4.2 Transposed 구조 블록도

텍스트 블록도(예: \(M=3\)):

```text
                 ┌─────────────[ z⁻¹ ]───────┐
                 │                           ▼
x[n] ─▶[×b3]──▶(+)──▶[ z⁻¹ ]──▶(+)──▶[ z⁻¹ ]──▶(+)──▶ y[n]
                 ▲            ▲             ▲
                 │            │             │
               [×b2]        [×b1]         [×b0]
                 ▲            ▲             ▲
                 └────────────┴─────────────┘
```

각 샘플 x[n] 이 들어올 때

- b3·x[n] 이 가장 먼저 첫 번째 누산기로 들어가고
- 지연을 통과하며 b2·x[n], b1·x[n], b0·x[n] 이 차례대로 더해지는 구조

(그림 표기는 교과서마다 약간 다르지만, 핵심은 “한 샘플에 대해 곱셈–가산이 상향식으로 누적되는 형태”라는 점이다.)

### 4.3 GNU Octave 구현 (Transposed 구조, 개념 코드)

Transposed 구조는 상태(state)가 “부분합”으로 유지된다.

```matlab
function y = fir_transposed(b, x)
  % b: [b0 b1 ... bM]
  b = b(:).';
  x = x(:).';

  M = length(b) - 1;

  % 상태: s(1) ~ s(M+1)
  s = zeros(1, M+1);
  y = zeros(size(x));

  for n = 1:length(x)
    % 새 입력 샘플 x(n)를 넣었을 때의 출력
    % 새 출력은 b0*x + s(1)
    y(n) = b(1) * x(n) + s(1);

    % 상태 업데이트 (뒤에서 앞으로)
    for k = 1:M
      s(k) = b(k+1) * x(n) + s(k+1);
    end
    s(M+1) = 0;   % 가장 끝 상태는 0 또는 필요에 따라 설정
  end

  if iscolumn(x)
    y = y.';
  end
end
```

실제 하드웨어 구현에서는 이보다 훨씬 정교하게 파이프라인을 나누지만,  
개념적으로는 “현재 샘플 x[n] 에 대해 b_k·x[n] 을 차례로 누산해 나가며 상태를 갱신”하는 형태로 이해할 수 있다.

---

## 5. 선형 위상 FIR 구조 (대칭 계수 활용)

FIR 필터의 큰 장점 중 하나는 **정확히 선형 위상(linear phase)** 를 가질 수 있다는 점이다.

### 5.1 선형 위상의 조건 (대칭/반대칭 계수)

FIR 계수가 다음과 같은 **대칭**을 가지면,

$$
b_k = b_{M-k}
$$

필터는 선형 위상을 갖는다(시간 지연 상쇄를 제외하면 위상이 주파수에 대해 선형).

반대로 **반대칭(antisymmetric)**

$$
b_k = -b_{M-k}
$$

이면 고역통과/대역저지에 유리한 선형 위상 구조를 만들 수 있다.

이때 중요한 점:

- 대칭 때문에 곱셈기 수를 줄일 수 있다.

예를 들어 \(M=5\) (\(6\) 탭) 대칭 FIR:

계수:

$$
b_0, b_1, b_2, b_3, b_4, b_5
$$

대칭 조건:

$$
b_0 = b_5, \quad b_1 = b_4, \quad b_2 = b_3
$$

즉, 서로 짝을 이룬다.

### 5.2 곱셈기 절반으로 줄이기

대칭 FIR 의 출력:

$$
y[n] = b_0 (x[n] + x[n-5])
     + b_1 (x[n-1] + x[n-4])
     + b_2 (x[n-2] + x[n-3])
$$

이처럼 각 짝을 먼저 더한 다음 계수를 곱하면 된다.

블록도(간략):

```text
x[n]───────┐                    ┌────▶[×b0]──▶(+)
           │                    │
x[n-5]────┘──▶(+)───────────────┘

x[n-1]────┐                    ┌────▶[×b1]──▶(+)
          │                    │
x[n-4]───┘──▶(+)───────────────┘

x[n-2]────┐                    ┌────▶[×b2]──▶(+)
          │                    │
x[n-3]───┘──▶(+)───────────────┘
```

이렇게 하면 곱셈기 수가 6개에서 3개로 줄어든다.  
대형 오디오/통신 필터에서 큰 비용 차이를 만든다.

### 5.3 GNU Octave 구현 예제 (대칭 FIR 구조)

간단히 “곱셈기 절반 최적화”를 구현한 예제를 보자.

```matlab
function y = fir_linear_phase(b, x)
  % 대칭 FIR 계수를 이용해 곱셈기 수를 줄이는 예제
  % b: 전체 계수 (길이 L), L은 짝수라고 가정 (0~M)
  x = x(:).';
  b = b(:).';

  L = length(b);
  M = L - 1;

  if mod(L, 2) ~= 0
    error('길이가 짝수인 예제만 다루는 코드입니다.');
  end

  half = L / 2;  % 짝이 되는 계수의 개수

  x_delay = zeros(1, M);  % x[n-1] ... x[n-M]
  y = zeros(size(x));

  for n = 1:length(x)
    x_taps = [x(n), x_delay];  % x[n], x[n-1], ..., x[n-M]

    acc = 0;
    for k = 1:half
      acc = acc + b(k) * (x_taps(k) + x_taps(L+1-k));
    end
    y(n) = acc;

    if M > 0
      x_delay(2:end) = x_delay(1:end-1);
      x_delay(1) = x(n);
    end
  end

  if iscolumn(x)
    y = y.';
  end
end
```

실제 설계에서는 윈도우 기법, Parks–McClellan 알고리즘 등으로  
선형 위상 FIR 계수를 먼저 얻고, 그 계수의 대칭성을 이용해 구조를 최적화한다.

---

## 6. Polyphase FIR 구조 (다중레이트 처리)

FIR 구조를 조금 더 “재배열”하면 **다중레이트(multirate) 시스템에 특화된 구조**를 만들 수 있다.  
대표적인 것이 **Polyphase 구조**다.

### 6.1 다운샘플링과 단순 FIR의 비효율

예를 들어, 샘플링 주파수 \(f_s\) 에서 FIR 필터를 통과시킨 후  
출력을 3배 다운샘플(3개 중 한 샘플만 취함)한다고 하자.

1. 우선 모든 샘플을 필터링
2. 그 중에서 3개당 1개만 꺼낸다

불필요하게 많은 곱셈을 수행한다.

### 6.2 Polyphase 분해

FIR 계수 \(b_0, b_1, \dots, b_M\) 을 다음과 같이 나눈다.

예를 들어 다운샘플링 비율이 \(L=3\) 일 때,

$$
H(z) = \sum_{k=0}^{M} b_k z^{-k}
$$

를

$$
H(z) = E_0(z^3) + z^{-1} E_1(z^3) + z^{-2} E_2(z^3)
$$

형태로 쓴다. 여기서

$$
E_0(z) = b_0 + b_3 z^{-1} + b_6 z^{-2} + \cdots
$$

$$
E_1(z) = b_1 + b_4 z^{-1} + b_7 z^{-2} + \cdots
$$

$$
E_2(z) = b_2 + b_5 z^{-1} + b_8 z^{-2} + \cdots
$$

각 \(E_i(z)\) 는 다운샘플된 시간축에서 동작하는 개별 FIR 로 볼 수 있다.

Polyphase 구조는 “FIR 필터의 내부 구조를 다운샘플러와 어울리도록 재배열”해서  
**불필요한 곱셈을 줄이는 구조**이다.

### 6.3 Polyphase 다운샘플러 구조 예 (개념)

다운샘플링 비율 3인 경우 텍스트 블록도 개념:

```text
입력 x[n]
  │
  ├─▶ Polyphase Branch 0 (계수들: b0, b3, b6, ...)
  │
  ├─▶ Polyphase Branch 1 (계수들: b1, b4, b7, ...)
  │
  └─▶ Polyphase Branch 2 (계수들: b2, b5, b8, ...)

각 브랜치 출력들을 n에 따라 번갈아가며 더해서
다운샘플된 출력 y[m] 생성
```

실제 구현에서는 “입력을 3단 지연선으로 돌리고,  
각 타임 인덱스 모듈로 3에 대해 다른 브랜치 계수를 사용”하는 식으로 짤 수 있다.

Polyphase 구조는 다음에 나올 격자 구조와는 목적이 다르지만,  
**계수를 분해하고 구조를 재배열**해서 목적(다중레이트, 수치 안정성, 적응 등)에 최적화한다는 점에서 공통된 아이디어가 있다.

---

## 7. 격자(Lattice) 필터 구조 개요

이제 본격적으로 **격자 필터 구조**를 본다. 격자 구조는 다음과 같은 이유로 중요하다.

1. **수치 안정성**  
   - 적절한 반사계수(reflection coefficient) 조건(\(|k_m| < 1\) 등)을 만족시키면 자동으로 안정해지는 구조.
2. **계수의 해석적 의미**  
   - 선형 예측(linear prediction)에서의 PARCOR(Partial Correlation) 계수와 직결.
3. **적응 필터 구조에 유리**  
   - LMS, RLS 등 적응 알고리즘을 격자 구조에서 구현하면 빠른 수렴과 좋은 수치 특성을 얻는 경우가 많다.
4. **FIR, IIR 모두 표현 가능**  
   - FIR: 순수 격자 구조 또는 격자+사다리(lattice–ladder) 구조로 표현  
   - IIR: all-pole 부분을 lattice 로, 나머지는 ladder 로 표현하는 구조 존재

여기서는 **FIR 격자 필터 구조**를 중심으로 보고, 마지막에 IIR lattice–ladder 구조를 간단히 언급한다.

---

## 8. FIR 격자 필터의 기본 아이디어

### 8.1 Forward / Backward 신호

격자 구조에서는 입력 신호를 바로 탭에 연결하는 대신,  
매 단계마다 두 종류의 신호를 정의한다.

- Forward 신호 \(f_m[n]\)  
- Backward 신호 \(b_m[n]\)

여기서 \(m\) 은 **스테이지(stage)** 인덱스다.

- \(m = 0\) 번째 스테이지의 입력:

  $$
  f_0[n] = x[n]
  $$

- \(b_0[n]\) 는 보통 \(x[n]\) 또는 \(x[n-1]\) 등으로 정의되는 변형이다(정의 방식에 따라 다름).

각 스테이지에는 **반사계수(reflection coefficient)** \(k_m\) 가 있으며,  
\(f_{m-1}, b_{m-1}\) 를 받아 \(f_m, b_m\) 를 만들어 다음 스테이지로 전달한다.

### 8.2 1단 격자 스테이지의 기본 수식

표현 방식은 교과서마다 부호와 지연 위치가 조금씩 다르지만,  
대표적인 한 형태는 다음과 같다.

스테이지 \(m\) 에서의 관계:

$$
f_m[n] = f_{m-1}[n] - k_m \, b_{m-1}[n-1]
$$

$$
b_m[n] = b_{m-1}[n-1] - k_m \, f_{m-1}[n]
$$

또는 부호가 반대인 버전도 많이 쓰인다. 중요한 것은

- \(f_m\) 와 \(b_m\) 가 **서로를 참조하며 결합**된다는 것
- \(k_m\) 이 **반사계수/부분상관계수** 역할을 한다는 것

블록도(단일 스테이지, 개념도):

```text
         k_m
b_{m-1}[n-1] ──▶[×]──┐
                      ▼
f_{m-1}[n] ─────────▶(+)──▶ f_m[n]

         k_m
f_{m-1}[n] ──▶[×]──┐
                    ▼
b_{m-1}[n-1] ─────▶(+)──▶ b_m[n]
```

(부호는 선택한 수식에 따라 (+) 대신 (-) 가 될 수 있다.)

스테이지를 여러 개 연달아 놓으면 **격자(lattice)** 모양이 된다.

---

## 9. FIR 격자 필터와 격자-사다리(Lattice–Ladder) 구조

FIR 필터 전송함수

$$
H(z) = \sum_{k=0}^{N} h_k z^{-k}
$$

를 격자 구조로 나타내려면 **ladder(사다리)** 계수를 추가로 사용한다.

- **Lattice 부분**: all-pass / all-zero 필터의 코어 구조, 반사계수 \(k_m\) 로 매개화
- **Ladder 부분**: 각 스테이지의 forward 신호에 가중치를 곱해 출력으로 합치는 부분

출력은 보통 다음과 같이 표현된다.

$$
y[n] = \sum_{m=0}^{N} v_m f_m[n]
$$

여기서

- \(f_0[n] = x[n]\)
- \(f_m[n]\): 격자 스테이지를 거친 forward 신호
- \(v_m\): ladder(사다리) 계수

이 구조를 **FIR lattice–ladder 필터**라고 부른다.

블록도 개념(텍스트, \(N\) 스테이지):

```text
x[n] = f0[n]
   │
   ├─▶ [Lattice Stage 1] ─▶ f1[n]
   │
   ├─▶ [Lattice Stage 2] ─▶ f2[n]
   │
   ├─▶ ...
   │
   └─▶ [Lattice Stage N] ─▶ fN[n]

출력 y[n] = v0*f0[n] + v1*f1[n] + ... + vN*fN[n]
```

각 Lattice Stage 에서 forward/backward 신호가 반사계수 \(k_m\) 를 통해 섞인다.

---

## 10. 2단 FIR 격자–사다리 구조 예제

구조를 구체적으로 느끼기 위해 가장 작은 예제인 **2단 FIR 격자–사다리 필터**를 보자.

### 10.1 수식 정의

한 가지 예로, 다음과 같이 정의해 보자 (부호/지연 위치는 정의에 따라 달라질 수 있다).

1) 입력:

$$
f_0[n] = x[n]
$$

2) 1단 스테이지:

$$
f_1[n] = f_0[n] - k_1 b_0[n-1]
$$

$$
b_1[n] = b_0[n-1] - k_1 f_0[n]
$$

3) 2단 스테이지:

$$
f_2[n] = f_1[n] - k_2 b_1[n-1]
$$

$$
b_2[n] = b_1[n-1] - k_2 f_1[n]
$$

4) 출력(사다리 부분):

$$
y[n] = v_0 f_0[n] + v_1 f_1[n] + v_2 f_2[n]
$$

초기 조건은 보통 \(b_0[-1] = 0\), \(b_1[-1] = 0\) 등으로 둔다.

여기서:

- \(k_1, k_2\): 반사계수
- \(v_0, v_1, v_2\): ladder 계수

적절한 \(\{k_m\}, \{v_m\}\) 를 선택하면 원하는 FIR 계수 \(\{h_k\}\) 를 얻을 수 있다.

### 10.2 GNU Octave 구현 예 (2단 FIR 격자–사다리, 샘플 단위)

위 개념을 그대로 GNU Octave 코드로 옮겨 보자.  
상태(state)를 구조체로 유지하면서 한 샘플씩 처리하는 방식이다.

```matlab
function state = fir_lattice2_init(k1, k2, v0, v1, v2)
  % 2단 FIR 격자–사다리 필터 초기화
  % k1, k2 : 반사계수
  % v0, v1, v2 : ladder 계수
  state.k1 = k1;
  state.k2 = k2;
  state.v0 = v0;
  state.v1 = v1;
  state.v2 = v2;

  % backward 신호의 이전 값들 (b0[n-1], b1[n-1])을 상태에 저장
  state.b0_prev = 0.0;
  state.b1_prev = 0.0;
end

function [y_n, state] = fir_lattice2_process_sample(x_n, state)
  % 2단 FIR 격자–사다리 필터의 샘플 단위 처리
  %
  % 입력:
  %   x_n   : 현재 입력 샘플
  %   state : 구조체 (k1, k2, v0..v2, b0_prev, b1_prev)
  % 출력:
  %   y_n   : 현재 출력 샘플
  %   state : 갱신된 상태

  % Stage 0
  f0 = x_n;
  b0 = state.b0_prev;  % b0[n-1]

  % Stage 1
  f1 = f0 - state.k1 * b0;
  b1 = b0 - state.k1 * f0;

  % Stage 2
  b1_prev = state.b1_prev;  % b1[n-1]
  f2 = f1 - state.k2 * b1_prev;
  b2 = b1_prev - state.k2 * f1;  %#ok<NASGU>  % 여기서는 b2를 따로 쓰진 않지만 개념상 존재

  % 출력(사다리)
  y_n = state.v0 * f0 + state.v1 * f1 + state.v2 * f2;

  % 상태 업데이트
  state.b0_prev = b0;
  state.b1_prev = b1;
end
```

벡터 입력을 한 번에 처리하려면:

```matlab
function [y, state] = fir_lattice2_process_vector(x, state)
  x = x(:).';
  y = zeros(size(x));

  for n = 1:length(x)
    [y(n), state] = fir_lattice2_process_sample(x(n), state);
  end

  if iscolumn(x)
    y = y.';
  end
end
```

위 코드는 인덱스/부호/지연 위치에 따라 다양한 변형이 가능하지만,

- 격자 스테이지 내부에서 forward/backward 신호를 반사계수로 섞고
- 각 stage의 forward 출력을 ladder 계수로 합산한다

는 구조적 아이디어를 GNU Octave 코드로 그대로 보여준다.

---

## 11. FIR 계수 ↔ 격자 계수 변환(개념 설명)

실무에서는 보통 다음 두 상황이 있다.

1. FIR 계수 \(h_0, h_1, \dots, h_N\) 을 이미 알고 있을 때  
   → 이를 격자 계수 \(\{k_m\}\) 와 ladder 계수 \(\{v_m\}\) 로 변환  
2. 격자 계수를 자주 업데이트(적응 필터)해야 할 때  
   → \(\{k_m\}\) 와 \(\{v_m\}\) 공간에서 동작

변환 알고리즘은 **Levinson–Durbin, step-down 알고리즘**과 유사한 구조를 가진다.

핵심 아이디어(개념 수준):

1. 전송함수 \(H(z)\) 를 차수 \(N\) 인 다항식으로 보고,  
2. 끝 계수에서부터 거꾸로 올라가며 반사계수 \(k_N\) 을 계산한다.
3. \(k_N\) 을 제거한 “줄어든 차수의 전송함수”를 만들어 \(k_{N-1}\) 을 구한다.
4. 이 과정을 반복하여 \(k_1\) 까지 구한다.
5. 남는 부분이 ladder 계수 \(\{v_m\}\) 와 관련된다.

정확한 수식과 알고리즘은 교과서/논문 수준 내용이지만,

- **FIR 계수 공간**보다 **격자 계수 공간**이 수치적으로 더 잘 조건화되는 경우가 많고
- 특히 스펙트럼 추정, 음성코딩(LPC), 적응 필터링에서 중요한 역할을 한다.

---

## 12. FIR 격자 필터의 장단점 (Direct Form 대비)

### 12.1 장점

1. **수치 안정성**  
   - 반사계수 \(|k_m| < 1\) 조건으로 안정성을 직접 제어 가능.
2. **계수의 해석력**  
   - 선형 예측에서 PARCOR 계수로 바로 해석 가능.
3. **적응 알고리즘의 좋은 수렴 특성**  
   - LMS, RLS를 격자 구조에 맞게 재구성하면 수렴 속도/수치 안정성이 좋아지는 경우가 많다.
4. **단계별 구조**  
   - 구조가 Stage-by-Stage 이므로, 차수를 늘리거나 줄이는 것이 상대적으로 쉽다.

### 12.2 단점

1. **구조가 직관적이지 않다**  
   - Direct Form FIR 에 비해 “계수 → 응답”의 관계가 덜 직관적이다.
2. **코드가 복잡**  
   - Forward/Backward 신호, 지연 인덱스를 꼼꼼히 관리해야 한다.
3. **FIR 설계 관점에서는 Direct Form이 더 일반적**  
   - 오디오 EQ, 통신용 FIR 등에서는 대부분 Direct Form/Polyphase/선형 위상 구조를 사용하고,  
     격자 구조는 주로 **스펙트럼 추정, LPC, 적응 필터** 쪽에서 많이 쓴다.

---

## 13. GNU Octave 예제: 격자 구조로 단순 FIR 동작 확인

완전한 FIR ↔ 격자 계수 변환을 구현하는 것은 길어지므로,  
여기서는 **주어진 격자 계수와 ladder 계수**로 FIR 격자–사다리 필터를 구현하고  
임의 신호에 적용해 보는 예제를 보자.

### 13.1 격자–사다리 FIR 구현 (일반 차수, 구조 강조)

다음은 forward/backward 신호를 배열로 관리하는 방식이다.  
앞에서 본 것과 마찬가지로 **구조를 이해하는 데 초점**을 둔다.

```matlab
function y = fir_lattice_ladder(k, v, x)
  % FIR Lattice–Ladder 구조 (개념 구현)
  % k: [k1, k2, ..., kN]  (reflection coefficients)
  % v: [v0, v1, ..., vN]  (ladder coefficients)
  % x: 입력 벡터
  % y: 출력 벡터
  %
  % 구조:
  % f0[n] = x[n]
  % 각 stage m에서 f_m[n], b_m[n] 업데이트
  % y[n] = sum_{m=0}^N v_m * f_m[n]

  x = x(:).';
  N = length(k);
  if length(v) ~= N+1
    error('v 길이는 N+1 이어야 합니다.');
  end

  % forward, backward 배열 (길이 N+1)
  f = zeros(1, N+1);
  b = zeros(1, N+1);

  y = zeros(size(x));

  for n = 1:length(x)
    % Stage 0
    f(1) = x(n);

    % backward의 초기값은 보통 0 또는 직전 샘플을 이용
    % 여기서는 간단히 b(1) = 0으로 둔다.
    b(1) = 0;

    % Stage 1..N
    for m = 1:N
      f_prev = f(m);
      b_prev = b(m);

      % 격자 업데이트 (한 가지 예, 부호/지연 정의에 따라 변형 가능)
      f(m+1) = f_prev - k(m) * b_prev;
      b(m+1) = b_prev - k(m) * f_prev;
    end

    % 출력: ladder 부분
    acc = 0;
    for m = 0:N
      acc = acc + v(m+1) * f(m+1);
    end
    y(n) = acc;
  end

  if iscolumn(x)
    y = y.';
  end
end
```

이 구현은 “실제 FIR 계수”와 1:1 대응시키려면  
반사계수/ladder 계수 설계와 backward 신호 지연 정의를 더 엄밀히 해야 하지만,

- Lattice–Ladder 구조가 forward/backward 신호와 반사계수, ladder 계수로 구성된다는 것
- 기본 소자(지연, 곱셈, 가산)만으로 격자 구조를 구현할 수 있다는 것

을 GNU Octave 코드로 확인할 수 있다.

### 13.2 사용 예: 잡음 신호에 격자 필터 적용

```matlab
% 임의의 반사계수, ladder 계수
k = [0.4, -0.3, 0.2];       % reflection coefficients (예시)
v = [0.5, 0.3, -0.2, 0.1];  % ladder coefficients (예시)

x = randn(1, 1000);         % 백색 잡음
y = fir_lattice_ladder(k, v, x);

subplot(2,1,1);
plot(x);
title('입력 x[n]');
xlabel('n');
ylabel('Amplitude');
grid on;

subplot(2,1,2);
plot(y);
title('격자–사다리 FIR 필터 출력 y[n]');
xlabel('n');
ylabel('Amplitude');
grid on;
```

이 필터의 정확한 주파수 응답은 \(\{k_m\}, \{v_m\}\)에 의해 결정된다.  
이 응답이 어떤 모양인지 분석하는 과정은 **FIR 계수 ↔ 격자 계수 변환** 알고리즘과 연결된다.

---

## 14. IIR 격자–사다리 구조 (개념 수준)

지금까지는 주로 **FIR 격자 구조**에 집중했지만,  
앞 글에서 IIR 필터의 중요성을 봤으므로 IIR 에서의 격자–사다리 구조도 간단히 짚고 넘어가자.

IIR 전송함수:

$$
H(z) = \frac{B(z)}{A(z)}
$$

여기서

- \(A(z)\): 분모(극점, all-pole 부분)
- \(B(z)\): 분자(영점, all-zero 부분)

IIR 격자–사다리 구조는 보통 다음과 같이 분해한다.

1. **Lattice 부분**: \(1/A(z)\) 에 해당하는 all-pole 필터를 격자 구조로 실현  
   - 반사계수 \(\{k_m\}\) 로 표현
2. **Ladder 부분**: \(B(z)\) 와 관련된 zero 부분을 ladder 계수 \(\{v_m\}\) 로 실현

블록도 개념:

```text
x[n] ─▶ [All-pole Lattice (1/A(z))] ─▶ f_N[n]
                     │
                     ├─▶ Ladder 계수로 가중합 ─▶ y[n]
                     │
```

이 구조는,

- IIR 극점의 안정성을 **반사계수의 크기 제한**으로 직접 관리할 수 있고
- 분자/분모를 구조적으로 분리해서 처리할 수 있다는 장점이 있다.

다만,

- IIR 격자 구조는 FIR 격자보다 더 복잡하고
- 대부분의 실무 FIR/IIR 필터 설계는 Direct Form, 2차 섹션(SOS) 구조를 우선적으로 사용한다.

격자–사다리 IIR 구조는 주로 **고급 음성 코덱, 레이더 신호 처리, 적응 IIR 필터** 등  
수치 안정성이 결정적인 분야에서 자주 등장한다.

---

## 15. 전체 정리

이 글에서는 앞 글의 “기본 소자, IIR 필터” 내용을 확장해서  
**FIR 필터 구조와 격자(Lattice) 필터 구조**를 구조 관점에서 정리했다.  
예제 코드는 모두 **GNU Octave** 로 구현했다.

핵심만 다시 모으면 다음과 같다.

1. FIR 필터

   - 차분방정식:

     $$
     y[n] = \sum_{k=0}^{M} b_k x[n-k]
     $$

   - 전송함수:

     $$
     H(z) = \sum_{k=0}^{M} b_k z^{-k}
     $$

   - Direct Form(Transversal): 입력 지연선 + 탭 계수 + 가산기  
   - Transposed 구조: 누산 기반 구조, 하드웨어/파이프라인에 유리  
   - 선형 위상 FIR: 계수 대칭/반대칭을 이용, 곱셈기 절반으로 줄이는 구조  
   - Polyphase 구조: 다중레이트(다운/업샘플링)에서 연산량을 줄이기 위한 분해 구조

2. 격자(Lattice) 필터

   - Forward 신호 \(f_m[n]\), Backward 신호 \(b_m[n]\) 를 각 스테이지에서 반사계수 \(k_m\) 로 섞는 구조
   - FIR lattice–ladder 구조:

     $$
     y[n] = \sum_{m=0}^{N} v_m f_m[n]
     $$

   - FIR 계수 \(\{h_k\}\) 를 격자 계수 \(\{k_m\}\), ladder 계수 \(\{v_m\}\) 로 변환하는 알고리즘 존재
   - 수치 안정성, 적응 필터, 선형 예측(LPC)에서 큰 장점
   - IIR 격자–사다리 구조: 분모(all-pole)는 lattice, 분자(all-zero)는 ladder 로 표현

3. 구조 선택의 의미

   - Direct Form FIR: 직관적, 구현 쉬움, 대부분의 일반적인 FIR 응용에 적합
   - Polyphase FIR: 다중레이트 시스템에서 필수적인 구조
   - 격자 FIR: 수치 안정성, 적응/예측 문제에서 강력한 구조
   - IIR 에서는 2차 섹션(SOS) + Direct Form/Transposed, 격자–사다리가 주된 후보들

이제 FIR 구조와 격자 구조에 대한 개념이 잡혔다면,  
다음 단계로는

- 선형 위상 FIR의 실제 설계(윈도우법, 최소 리플 설계 등)
- FIR/IIR 격자 계수 ↔ 표준 계수 변환 알고리즘(Levinson–Durbin, step-up/step-down)
- 고정소수점에서의 계수 양자화, limit cycle 비교