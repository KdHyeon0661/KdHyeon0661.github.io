---
layout: post
title: 이산수학 - 알고리즘의 복잡도
date: 2025-05-29 20:20:23 +0900
category: 이산수학
---
# ⏱ 알고리즘의 복잡도 – 시간과 공간을 측정하는 기준

## 📌 1. 복잡도란?

**알고리즘의 복잡도(Complexity)**란,  
알고리즘이 **얼마나 많은 시간**과 **얼마나 많은 공간**을 사용하는지를 나타내는 척도입니다.

---

## 📘 2. 복잡도의 종류

### ✅ 1. 시간 복잡도 (Time Complexity)

- 입력 크기 `n`이 증가할 때 **필요한 연산 횟수의 증가 정도**
- 일반적으로 가장 중요한 복잡도 지표

### ✅ 2. 공간 복잡도 (Space Complexity)

- 알고리즘 수행 중 필요한 **메모리 양**
- 배열, 재귀 호출, 스택, 임시 변수 등을 포함

---

## 🧠 3. 점근적 표기법 (Asymptotic Notation)

입력 크기가 무한히 커질 때의 연산량 추이를 추상화한 수학적 표기법

### 🎯 Big-O 표기법

> **최악의 경우(worst case)의 연산량 상한**

| 기호     | 의미                      | 예시 |
|----------|---------------------------|------|
| O(1)     | 상수 시간                  | 배열에서 인덱스로 접근 |
| O(log n) | 로그 시간                  | 이진 탐색 |
| O(n)     | 선형 시간                  | 선형 탐색 |
| O(n log n) | 준선형 시간              | 병합 정렬, 퀵 정렬 평균 |
| O(n²)    | 이중 루프                  | 버블 정렬 |
| O(2ⁿ), O(n!) | 지수/팩토리얼 시간     | 완전 탐색, 순열 생성 |

---

### ⏱ Big-O 외 다른 표기

| 기호     | 의미                                  |
|----------|---------------------------------------|
| Ω(g(n))  | 최선의 경우 하한 (best case)         |
| Θ(g(n))  | 정확한 성장률 (tight bound, 평균)     |

---

## 📊 4. 시간 복잡도 분석 방법

### 1. 반복문 분석

```python
for i in range(n):         # O(n)
    print(i)
```

```python
for i in range(n):         # O(n²)
    for j in range(n):
        print(i, j)
```

### 2. 재귀 함수 분석

피보나치 재귀:

```python
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)
```

→ 중복 호출로 인해 **O(2ⁿ)**의 시간 소요  
(메모이제이션 적용 시 O(n))

---

## 💾 5. 공간 복잡도 분석

### ✅ 고려 요소:

- **입력 크기**
- **지역 변수 및 함수 호출 스택**
- **재귀 호출 깊이**
- **사용하는 추가 배열, 해시 테이블 등**

예시:

```python
def count(n):
    arr = [0] * n    # 공간 O(n)
    for i in range(n):
        arr[i] = i
    return arr
```

→ 공간 복잡도: **O(n)**

---

## 🧮 6. 복잡도별 연산 가능 범위

| 시간 복잡도 | 현실적인 연산 한계 (1초 기준) | 예시 |
|-------------|-------------------------------|------|
| O(1), O(log n) | 10⁸ 이상 가능              | 매우 빠름 |
| O(n)        | 약 10⁷ 가능                  | 일반적인 탐색 |
| O(n log n)  | 약 10⁶ 가능                  | 효율적인 정렬 |
| O(n²)       | 약 10⁴ ~ 10⁵ 이하 적절       | 이중 루프 |
| O(2ⁿ)       | n ≤ 20 이내 추천             | 백트래킹 |
| O(n!)       | n ≤ 8 이하만 현실적           | 순열 완전탐색 |

> 입력 제한을 통해 복잡도 유추 가능

---

## 🧠 7. 알고리즘 성능 최적화의 핵심

- **시간 복잡도 개선**
  - 이중 루프 제거, 이진 탐색 사용, 누적합, 슬라이딩 윈도우 등
- **공간 복잡도 최적화**
  - 메모이제이션, 인플레이스 연산, 반복으로 재귀 대체 등

---

## 🔍 8. 실전 예제: 이중 반복 제거하기

### 문제:

1부터 n까지 수에서 두 수를 선택하여 더했을 때, 특정 값을 만들 수 있는 쌍을 구하라.

#### ❌ O(n²)

```python
for i in range(n):
    for j in range(i+1, n):
        if A[i] + A[j] == target:
            count += 1
```

#### ✅ O(n)

```python
seen = set()
for a in A:
    if target - a in seen:
        count += 1
    seen.add(a)
```

---

## 📌 9. 시간 복잡도와 자료구조

| 자료구조      | 탐색 | 삽입 | 삭제 |
|---------------|------|------|------|
| 배열(Array)   | O(1) | O(n) | O(n) |
| 연결 리스트    | O(n) | O(1) | O(1) |
| 해시 테이블    | O(1) | O(1) | O(1) |
| 이진 탐색 트리 | O(log n) | O(log n) | O(log n) |
| 힙(Heap)       | O(log n) | O(log n) | O(log n) |

---

## ✅ 마무리 요약

- **복잡도는 알고리즘의 성능을 정량적으로 측정하는 지표**
- **Big-O**는 입력이 커질 때 연산량의 최악 성장률을 표현
- 복잡도는 **자료구조 선택과 연산 방식**에 따라 달라진다
- 최적화 문제 해결 시, 반드시 **시간과 공간을 함께 고려**해야 한다