---
layout: post
title: 소켓프로그래밍 - TLS
date: 2025-09-25 18:25:23 +0900
category: 소켓프로그래밍
---
## 14. TLS 입문(전송 보안의 최소치)

> 목표: **TCP 위 TLS(1.2/1.3)** 의 큰 그림과 **ALPN**, **세션 재개(Resumption)** 를 잡고,  
> C++(OpenSSL/mbedTLS)에서 쓸 **래핑/RAII/논블로킹 통합** 설계 포인트를 익힌다.  
> 마지막으로 **평문 에코 → TLS 에코** 전환을 위한 **체크리스트 + 예제 코드**를 제시한다.  
> 기준: 리눅스/POSIX + C++23.

---

### 14.1 왜 “TCP 위 TLS”인가 — 네트워크 스택 속 자리

- **TLS**는 OSI 5~6(세션/표현) 사이쯤 역할을 하며 **L4(TCP) 위**에 **암호화/무결성/상호인증(선택)** 을 얹는다.  
- TCP로 **스트림**을 제공 → TLS가 **레코드**(보안 프레이밍)로 쪼개어 암/복호.  
- 암호 알고리즘/키교환/인증서는 **프로토콜 협상**으로 결정.  
- 대기시간 직관:
  $$
  \text{HandshakeDelay} \approx n_\text{RTT}\cdot\text{RTT}
  $$
  - TLS 1.2: 보통 **2-RTT** (서버 인증서/키교환 단계가 더 김)  
  - TLS 1.3: **1-RTT** (간소화) + 재개 시 **0-RTT**(옵션; 재전송/재주입 위험 주의)

---

### 14.2 TLS 1.2 vs 1.3, ALPN, 세션 재개 개요

#### 14.2.1 1.2 ↔ 1.3 핵심 차이
- **1.3 장점**: 핸드셰이크 **1-RTT**, **Forward Secrecy(ECDHE)** 강제, **암호군 단순화**(AES-GCM/CHACHA20-Poly1305 등), 세션 재개 **PSK/티켓** 정식화.  
- **1.2 현실**: 레거시 클라이언트/미들박스 호환성 필요 시 여전히 켜두는 경우가 있음.  
- 실무 권장: **최소 1.2**, 가능하면 **1.3 우선**.

#### 14.2.2 ALPN (Application-Layer Protocol Negotiation)
- 하나의 포트에서 **HTTP/2 vs HTTP/1.1** 등 **상위 프로토콜 선택**.  
- 클라이언트가 **후보 리스트**를 보내고 서버가 **하나 선택**.
  - 예: `"h2", "http/1.1"` 순으로 제안 → 서버가 지원하는 최선 선택.

#### 14.2.3 세션 재개(Resumption)
- 전체 핸드셰이크 없이 **이전 상태 재사용** → 지연 감소, CPU 절약.
- 메커니즘:
  - **TLS 1.3**: **PSK(Pre-Shared Key)**/**Session Ticket** 기반, 0-RTT 지원(선택).
  - **TLS 1.2**: **세션 ID/세션 티켓**.
- **0-RTT 주의**: **재주입(replay)** 위험 → 멱등 요청만 허용, 서버에서 **반드시 정책**으로 제한.

---

### 14.3 C++에서 TLS 적용 경로 — OpenSSL/mbedTLS 래핑 포인트

#### 14.3.1 RAII 설계(핵심)
- `SSL_CTX`, `SSL`, `X509`, `EVP_PKEY`, `SSL_SESSION` → **스코프 기반 소멸자**로 해제.
- 예: `unique_ssl_ctx`, `unique_ssl`, `unique_x509` 등 (커스텀 `deleter`).

```cpp
// ssl_raii.hpp (요지)
#include <openssl/ssl.h>
#include <openssl/x509.h>
#include <memory>

struct SslCtxDel { void operator()(SSL_CTX* p) const { if(p) SSL_CTX_free(p);} };
struct SslDel    { void operator()(SSL* p)     const { if(p) SSL_free(p);} };
using unique_ssl_ctx = std::unique_ptr<SSL_CTX, SslCtxDel>;
using unique_ssl     = std::unique_ptr<SSL, SslDel>;

// 생성 유틸
inline unique_ssl_ctx make_server_ctx() {
    SSL_CTX* c = SSL_CTX_new(TLS_server_method());
    return unique_ssl_ctx{c};
}
inline unique_ssl_ctx make_client_ctx() {
    SSL_CTX* c = SSL_CTX_new(TLS_client_method());
    return unique_ssl_ctx{c};
}
```

#### 14.3.2 검증/옵션(보안 기본값)
- 최소 버전 고정: `SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);`  
- **1.3 암호군**: `SSL_CTX_set_ciphersuites(ctx, "TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256");`  
- **1.2 암호군**: `SSL_CTX_set_cipher_list(ctx, "ECDHE+AESGCM:ECDHE+CHACHA20");`  
- 압축 비활성: `SSL_CTX_set_options(ctx, SSL_OP_NO_COMPRESSION);`  
- 서버: 인증서/키 로드 → `SSL_CTX_use_certificate_file`, `SSL_CTX_use_PrivateKey_file`  
- 클라이언트: **CA 신뢰 루트** 로드 → `SSL_CTX_load_verify_locations`(혹은 시스템 디폴트)  
- **서버 호스트명 검증**(클라이언트): `X509_check_host(cert, hostname, ...)` + `SSL_get_peer_certificate`  
- **SNI**(클라이언트): `SSL_set_tlsext_host_name(ssl, hostname)`  
- **ALPN**:  
  - Client: `SSL_set_alpn_protos(ssl, (const uint8_t*)"\x02h2\x08http/1.1", 2+9);` (length-prefix)  
  - Server: `SSL_CTX_set_alpn_select_cb(...)` 콜백에서 선택

#### 14.3.3 논블로킹 통합 패턴
- `SSL_*` 호출 → 반환값 검사:
  - `> 0`: 진행  
  - `<= 0`: `SSL_get_error(ssl, rc)`  
    - `SSL_ERROR_WANT_READ`: **읽기 준비**되면 다시  
    - `SSL_ERROR_WANT_WRITE`: **쓰기 준비**되면 다시  
    - 기타: 실패(세션 종료)
- 이벤트 루프(epoll/poll)에서 **TLS 상태**를 일반 소켓처럼 다루되,  
  **“얼마나 읽고/쓸 수 있는지”** 는 커널이 아니라 **SSL 내부 버퍼**도 고려(반복 호출)해야 함.

---

### 14.4 실습 1 — “평문 에코”를 “TLS 에코”로 (블로킹 최소 예시)

> 목표: 교육용으로 **가장 작은 서버/클라이언트**를 TLS로 감싸본다.  
> (운영용은 10~11장 **epoll(ET) + 비차단** 버전에 TLS를 얹어야 한다 — 14.6에서 스켈레톤 제시)

#### 14.4.1 서버(블로킹, 길이-프리픽스 에코)
```cpp
// tls_echo_server_blocking.cpp
// 빌드: g++ -std=c++23 -O2 tls_echo_server_blocking.cpp -lssl -lcrypto -o tls_s
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <vector>
#include <print>
#include <cstring>
#include <openssl/ssl.h>
#include <openssl/err.h>

static int listen_any(const char* port) {
    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(nullptr, port, &hints, &res)!=0) return -1;
    int s=-1; 
    for (auto* ai=res; ai; ai=ai->ai_next){
        s=::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        int on=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on));
        if (bind(s, ai->ai_addr, ai->ai_addrlen)==0 && listen(s, 1024)==0) { freeaddrinfo(res); return s; }
        ::close(s); s=-1;
    }
    freeaddrinfo(res); return -1;
}

int main(int argc, char** argv) {
    const char* cert = (argc>1? argv[1] : "server.crt");
    const char* key  = (argc>2? argv[2] : "server.key");
    const char* port = (argc>3? argv[3] : "9443");

    SSL_library_init(); OpenSSL_add_ssl_algorithms(); SSL_load_error_strings();
    SSL_CTX* ctx = SSL_CTX_new(TLS_server_method());
    SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);
    SSL_CTX_set_options(ctx, SSL_OP_NO_COMPRESSION);
    if (SSL_CTX_use_certificate_file(ctx, cert, SSL_FILETYPE_PEM)!=1 ||
        SSL_CTX_use_PrivateKey_file(ctx, key,  SSL_FILETYPE_PEM)!=1) {
        ERR_print_errors_fp(stderr); return 1;
    }

    int lfd = listen_any(port);
    if (lfd<0) { perror("listen"); return 1; }
    std::print("[tls-echo] listen :{}\n", port);

    for(;;){
        int cfd = ::accept(lfd, nullptr, nullptr);
        if (cfd<0) { if(errno==EINTR) continue; perror("accept"); break; }

        SSL* ssl = SSL_new(ctx);
        SSL_set_fd(ssl, cfd);
        if (SSL_accept(ssl) != 1) { ERR_print_errors_fp(stderr); SSL_free(ssl); ::close(cfd); continue; }

        // 길이-프리픽스 4B -> body 에코
        for(;;){
            uint32_t be_len=0;
            int r = SSL_read(ssl, &be_len, 4);
            if (r<=0) break;
            if (r!=4) { /*부분 읽기 대비 간단화(교육용)*/ break; }
            uint32_t n = ntohl(be_len);
            if (n > (1u<<20)) break;
            std::vector<unsigned char> body(n);
            int off=0;
            while (off < (int)n) {
                int m = SSL_read(ssl, body.data()+off, n-off);
                if (m<=0) { off=-1; break; }
                off += m;
            }
            if (off<0) break;

            // 에코
            SSL_write(ssl, &be_len, 4);
            int so=0; while (so<(int)n) {
                int m = SSL_write(ssl, body.data()+so, n-so);
                if (m<=0) { so=-1; break; }
                so += m;
            }
            if (so<0) break;
        }

        // 종료(정상 종료라면 close_notify)
        SSL_shutdown(ssl);
        SSL_free(ssl);
        ::close(cfd);
    }
    ::close(lfd);
    SSL_CTX_free(ctx);
}
```

#### 14.4.2 클라이언트(블로킹, 서버 검증/SNI/ALPN)
```cpp
// tls_echo_client_blocking.cpp
// 빌드: g++ -std=c++23 -O2 tls_echo_client_blocking.cpp -lssl -lcrypto -o tls_c
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <string>
#include <vector>
#include <print>
#include <openssl/ssl.h>
#include <openssl/err.h>

static int dial(const char* host, const char* port) {
    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(host, port, &hints, &res)!=0) return -1;
    int s=-1; 
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s=::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        if (::connect(s, ai->ai_addr, ai->ai_addrlen)==0) { freeaddrinfo(res); return s; }
        ::close(s); s=-1;
    }
    freeaddrinfo(res); return -1;
}

int main(int argc, char** argv) {
    if (argc < 4) {
        std::print(stderr, "usage: {} <host> <port> <msg>\n", argv[0]); return 1;
    }
    const char* host=argv[1]; const char* port=argv[2]; std::string msg=argv[3];

    SSL_library_init(); OpenSSL_add_ssl_algorithms(); SSL_load_error_strings();
    SSL_CTX* ctx = SSL_CTX_new(TLS_client_method());
    SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);
    SSL_CTX_set_options(ctx, SSL_OP_NO_COMPRESSION);

    // 신뢰 루트(데모: 시스템 기본)
    SSL_CTX_set_default_verify_paths(ctx);
    SSL* ssl = SSL_new(ctx);

    int fd = dial(host, port);
    if (fd<0) { perror("connect"); return 1; }
    SSL_set_fd(ssl, fd);

    // SNI + ALPN(h2, http/1.1는 예시; 여기선 의미 없음)
    SSL_set_tlsext_host_name(ssl, host);
    const unsigned char alpn[] = { 2,'h','2', 8,'h','t','t','p','/','1','.','1' };
    SSL_set_alpn_protos(ssl, alpn, sizeof(alpn));

    // 서버 인증서 검증 on
    SSL_set_verify(ssl, SSL_VERIFY_PEER, nullptr);

    if (SSL_connect(ssl) != 1) { ERR_print_errors_fp(stderr); SSL_free(ssl); ::close(fd); SSL_CTX_free(ctx); return 1; }

    uint32_t be = htonl((uint32_t)msg.size());
    SSL_write(ssl, &be, 4);
    SSL_write(ssl, msg.data(), (int)msg.size());

    uint32_t be_len{};
    if (SSL_read(ssl, &be_len, 4) != 4) { std::print(stderr,"header read fail\n"); }
    uint32_t n = ntohl(be_len);
    std::string out; out.resize(n);
    int off=0;
    while (off<(int)n) {
        int m = SSL_read(ssl, out.data()+off, n-off);
        if (m<=0) break;
        off+=m;
    }
    std::print("[echo] {}\n", out);

    SSL_shutdown(ssl);
    SSL_free(ssl);
    ::close(fd);
    SSL_CTX_free(ctx);
}
```

> **주의**: 위 코드는 **교육용 블로킹**이며, **부분 읽기/쓰기**를 간소화했다. 운영용은 **논블로킹 + epoll**로 상태 기계를 얹어야 한다.

---

### 14.5 인증서/키 준비(로컬 테스트)

> **서버 self-signed(테스트용)** — CN/SAN에 호스트명/IP 넣기

```bash
# 1) 키 생성
openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out server.key

# 2) CSR 구성 파일 (san.cnf)
cat > san.cnf <<'EOF'
[ req ]
default_bits       = 2048
prompt             = no
default_md         = sha256
req_extensions     = req_ext
distinguished_name = dn

[ dn ]
C = KR
O = Example
CN = localhost

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = localhost
IP.1  = 127.0.0.1
::    # (IPv6 테스트면 적절히 추가)
EOF

# 3) CSR + Self-Signed cert
openssl req -new -key server.key -out server.csr -config san.cnf
openssl x509 -req -in server.csr -signkey server.key -days 365 -extensions req_ext -extfile san.cnf -out server.crt
```

테스트:
```bash
./tls_s server.crt server.key 9443 &
./tls_c 127.0.0.1 9443 "hello-tls"
```

---

### 14.6 실습 2 — epoll(ET) + **논블로킹 TLS 스켈레톤**

> 지난 10~11장의 **ET 에코 서버** 골격에 TLS를 얹으려면 **핵심 전환점 3개**가 있다.

1) **핸드셰이크 상태**: `SSL_accept` / `SSL_connect` 를 이벤트 루프에서 반복 호출  
   - `WANT_READ/WRITE`에 따라 **관심 이벤트**(EPOLLIN/EPOLLOUT)를 토글
2) **읽기/쓰기 드레인**: `SSL_read` / `SSL_write` **EAGAIN 역할**을 `WANT_READ/WRITE`로 대치  
3) **종료**: 정상 종료는 `SSL_shutdown`(두 번 호출로 close_notify 왕복). 비정상은 `SSL_free` + 소켓 정리

스케치(핵심 부분만 발췌):
```cpp
// 핵심 멤버
enum class TlsStage { HANDSHAKE, OPEN, SHUTDOWN, CLOSED };
struct Conn {
    int fd{-1};
    SSL* ssl{nullptr};
    TlsStage stage{TlsStage::HANDSHAKE};
    std::vector<std::byte> in, out; // 길이-프리픽스 프레이밍 버퍼
    // ... 기존 READ_LEN/READ_BODY/WRITE_BODY 상태 그대로 유지
};

// EPOLLIN/EPOLLOUT 이벤트 처리
auto tls_handshake = [&](Conn& C){
    int rc = SSL_accept(C.ssl); // 서버 측
    if (rc == 1) { C.stage = TlsStage::OPEN; return; }
    int err = SSL_get_error(C.ssl, rc);
    if (err == SSL_ERROR_WANT_READ)  { ep_mod(ep, C.fd, EPOLLIN|EPOLLET|EPOLLRDHUP); return; }
    if (err == SSL_ERROR_WANT_WRITE) { ep_mod(ep, C.fd, EPOLLOUT|EPOLLET|EPOLLRDHUP); return; }
    // 실패
    close_conn(C.fd);
};

auto tls_read_drain = [&](Conn& C)->bool {
    for(;;){
        std::byte buf[4096];
        int n = SSL_read(C.ssl, buf, sizeof(buf));
        if (n > 0) {
            // 평문 bytes → 기존 프레이밍 상태 기계로 흡수
            // feed_plain(buf, n);
            continue;
        }
        int err = SSL_get_error(C.ssl, n);
        if (err == SSL_ERROR_WANT_READ)  return true;
        if (err == SSL_ERROR_WANT_WRITE) { ep_mod(ep, C.fd, EPOLLOUT|...); return true; }
        if (err == SSL_ERROR_ZERO_RETURN) { C.stage = TlsStage::SHUTDOWN; return false; } // close_notify 수신
        return false; // 기타 오류
    }
};

auto tls_write_drain = [&](Conn& C)->bool {
    while (!C.out.empty()){
        int n = SSL_write(C.ssl, C.out.data(), (int)C.out.size());
        if (n > 0){ C.out.erase(C.out.begin(), C.out.begin()+n); continue; }
        int err = SSL_get_error(C.ssl, n);
        if (err == SSL_ERROR_WANT_WRITE) return true;
        if (err == SSL_ERROR_WANT_READ)  { ep_mod(ep, C.fd, EPOLLIN|...); return true; }
        return false;
    }
    // 모두 보냈으면 EPOLLOUT 해제
    ep_mod(ep, C.fd, EPOLLIN|EPOLLET|EPOLLRDHUP);
    return true;
};
```

> **팁**  
> - `SSL_pending(ssl)` > 0 이면 소켓 읽기 이벤트가 없어도 **SSL 내부 버퍼**에 데이터가 대기 중 → 곧바로 `SSL_read` 호출.  
> - 레코드 경계와 **애플리케이션 프레이밍**은 무관: 상위의 길이-프리픽스 상태 기계를 그대로 사용.

---

### 14.7 ALPN 적용 예(서버/클라이언트)

- **클라이언트**(제안): `["echo/1", "h2", "http/1.1"]`  
- **서버**(선택): `echo/1` 지원하면 선택, 아니면 다음 후보로

서버 콜백:
```cpp
// 서버: ALPN 선택 콜백
int alpn_select_cb(SSL* ssl,
                   const unsigned char** out, unsigned char* outlen,
                   const unsigned char* in, unsigned int inlen, void* arg) {
    // in은 length-prefixed list
    const unsigned char* p = in; const unsigned char* end = in + inlen;
    while (p<end) {
        unsigned l = *p++; if (p+l > end) break;
        if (l==6 && std::memcmp(p, "echo/1", 6)==0) {
            *out = p; *outlen = (unsigned char)l; return SSL_TLSEXT_ERR_OK;
        }
        p += l;
    }
    return SSL_TLSEXT_ERR_NOACK;
}
// 등록
SSL_CTX_set_alpn_select_cb(server_ctx, alpn_select_cb, nullptr);
```

클라이언트 제안:
```cpp
const unsigned char alpn[] = { 6,'e','c','h','o','/','1', 2,'h','2', 8,'h','t','t','p','/','1','.','1' };
SSL_set_alpn_protos(ssl, alpn, sizeof(alpn));
```

네고 결과는 `SSL_get0_alpn_selected(ssl, &data, &len)` 로 확인.

---

### 14.8 세션 재개(Resumption) & 0-RTT 간단 예

#### 14.8.1 서버(1.3 세션 티켓)
- OpenSSL 1.1.1+에서 기본 **티켓 발급** 동작.  
- 커스텀 관리가 필요하면 `SSL_CTX_set_session_cache_mode`, `SSL_CTX_sess_set_new_cb` 등으로 세션 보관/통계 가능.

#### 14.8.2 클라이언트(세션 캐시 후 재사용)
```cpp
// 첫 연결 완료 후
SSL_SESSION* sess = SSL_get1_session(ssl); // ref +1
// ... 세션을 캐시에 보관 ...
// 다음 연결 때:
SSL* ssl2 = SSL_new(ctx);
SSL_set_session(ssl2, sess); // 재개 시도
// 0-RTT는 별도 API(early data) 고려: SSL_write_early_data(...)
SSL_SESSION_free(sess);
```

> **0-RTT 주의**: **멱등 요청만 허용**, 서버에서 **재주입 방지 윈도**와 **토큰 바인딩** 정책을 적용.

---

### 14.9 평문 → TLS 전환 **체크리스트**

1) **인증서/키/체인**  
   - 서버용 `server.crt`(체인 포함) + `server.key`  
   - SAN에 도메인/IP 기입, 키 권한(600)
2) **프로토콜/암호군 정책**  
   - **Min=TLS1.2**, **1.3 우선**  
   - 1.3: `TLS_AES_128_GCM_SHA256`, `TLS_CHACHA20_POLY1305_SHA256`  
   - 1.2: `ECDHE-ECDSA/AESGCM`, `ECDHE-RSA/CHACHA20-Poly1305`  
   - 압축/RC4/3DES/SSLv3/DSS **금지**
3) **검증/체크**  
   - 클라이언트: CA 경로 로드, **호스트명 검증** + **SNI 설정**  
   - 서버: **클라이언트 인증(mTLS)** 여부 정책
4) **ALPN**  
   - 필요 시 후보 정하고 서버 콜백으로 선택
5) **세션 재개**  
   - 재개/티켓 허용 범위, 0-RTT 정책(멱등만)
6) **성능/옵스**  
   - ECDSA vs RSA(서명 비용), 커브(X25519, P-256)  
   - 하드웨어 암호 가속(AES-NI), CHACHA20(비AES 하드웨어에 유리)  
   - TLS 종단 지점(애플리케이션 vs L7 프록시) 결정
7) **로깅/관측**  
   - 핸드셰이크 실패 사유(ERR_get_error), ALPN 결과, 재개 성공률  
   - `ss -ti`의 RTT/재전송, CPU 프로파일
8) **논블로킹 이벤트 루프 통합**  
   - `WANT_READ/WRITE`를 epoll 관심 이벤트로 **정확히 매핑**  
   - `SSL_pending` 확인, close_notify 처리

---

### 14.10 트러블슈팅 빠른 표

| 증상 | 진단 포인트 | 해결 |
|---|---|---|
| SSL\_accept 실패 | `ERR_print_errors_fp`, 인증서/키 불일치 | cert/key 재확인, 체인 포함 |
| 클라 검증 실패 | CA 경로/호스트명 검사 실패 | `SSL_CTX_set_default_verify_paths`, `X509_check_host` |
| ALPN 미선택 | 리스트 포맷 오류(length-prefix) | 바이트열 길이 접두 확인 |
| 느린 핸드셰이크 | 1.2 강제/세션재개 미사용 | 1.3 + resumption, 프론트 프록시 |
| epoll 교착 | `WANT_*` 무시 | 이벤트 토글/드레인 루프 구현 |
| 조기 종료 RST | `SSL_shutdown` 생략 | close\_notify 보내고 닫기 |

---

### 14.11 수식으로 보는 핸드셰이크 지연

- **1.2(2-RTT)**:
  $$
  \text{Delay}_{1.2} \approx 2\cdot \text{RTT} + T_{\text{crypto}}
  $$
- **1.3(1-RTT)**:
  $$
  \text{Delay}_{1.3} \approx 1\cdot \text{RTT} + T_{\text{crypto}}
  $$
- **재개(0-RTT 가능)**:
  $$
  \text{Delay}_{0\text{-RTT}} \approx 0\cdot \text{RTT} + T_{\text{early}}
  $$

---

### 14.12 마무리

TLS는 **소켓 위에 놓은 또 하나의 상태 기계**다.  
핵심은 **(1) 정책(버전/암호/검증/ALPN/재개)**, **(2) 구현(논블로킹 + WANT\_READ/WRITE)**, **(3) 운영(관측/로그/지표)**.  
이 장의 블로킹 예시로 **기초 동작**을 확인하고, 10~11장의 **epoll(ET) 프레임**에 본 장의 **핸드셰이크/드레인 스켈레톤**을 이식하라.  
그러면 **평문 에코 → TLS 에코** 전환이 “한 단계”가 아니라 **한 파일**의 차이로 바뀐다.
