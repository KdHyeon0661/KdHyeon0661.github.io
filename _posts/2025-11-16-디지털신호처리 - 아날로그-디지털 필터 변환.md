---
layout: post
title: 디지털신호처리 - 아날로그-디지털 필터 변환
date: 2025-11-16 23:25:23 +0900
category: 디지털신호처리
---
# 아날로그–디지털 필터 변환

## 전체 흐름 — 어디에서 무엇을 변환하는가?

우리가 “아날로그–디지털 필터 변환”이라고 부를 때, 보통 다음 과정을 의미한다.

1. **연속시간 아날로그 시스템**
   - 시스템 함수(전송함수):

     $$
     H_a(s) = \frac{Y(s)}{X(s)}
     $$

   - 임펄스 응답:

     $$
     h_a(t) = \mathcal{L}^{-1}\{H_a(s)\},\quad t\ge0
     $$

2. **샘플링**
   - 샘플링 주기 \(T = 1/F_s\)
   - 샘플링된 신호:

     $$
     x[n] = x_a(nT),\quad y[n] = y_a(nT)
     $$

3. **이산시간 시스템**
   - z-변환:

     $$
     H_d(z) = \sum_{n=0}^{\infty} h_d[n] z^{-n}
     $$

   - 여기에서 \(h_d[n]\) 를 어떻게 정의하느냐에 따라 **변환 방법**이 갈린다.

핵심은:

- “어떤 방식으로 \(h_a(t)\) (또는 step 응답, 주파수 응답 등)를 **디지털 영역으로 가져올 것인가**?”
- “그 과정에서 **알리아싱/워핑/위상 왜곡**은 어떻게 되는가?”

를 이해하는 것이다.

이 글에서는 **연속–이산 관계**를 먼저 정리하고,
그 위에서 **임펄스 불변법 / 계단 응답 불변법 / bilinear 변환**을 차례로 설명한다.

---

## 연속시간 vs 이산시간 — 주파수 축과 시스템의 관계

### 아날로그 시스템과 주파수응답

연속시간 LTI 시스템:

- 시스템 함수:

  $$
  H_a(s) = \int_{0}^{\infty} h_a(t) e^{-s t}\, dt
  $$

- 주파수응답:

  $$
  H_a(j\Omega) = H_a(s)\big|_{s=j\Omega}
  $$

여기서 \(\Omega\)는 **아날로그 각주파수**(rad/s)다.

### 이산시간 시스템과 주파수응답

이산시간 LTI 시스템:

- 시스템 함수:

  $$
  H_d(z) = \sum_{n=0}^{\infty} h_d[n] z^{-n}
  $$

- 주파수응답:

  $$
  H_d(e^{j\omega}) = H_d(z)\big|_{z=e^{j\omega}}
  $$

여기서 \(\omega\)는 **디지털 각주파수**(rad)이며,
주기 \(2\pi\)를 갖는다.

- 샘플링 주파수 \(F_s\)와의 관계:

  $$
  \omega = 2\pi \frac{f}{F_s}
  $$

디지털 주파수 축은 \(-\pi \le \omega \le \pi\)를 한 바퀴로 하는 **주기적 세계**다.

### 샘플링과 주파수 축 매핑

연속시간 신호 \(x_a(t)\)를 \(T\) 간격으로 샘플링하면:

$$
x[n] = x_a(nT)
$$

주파수 영역에서의 관계는

- 아날로그 스펙트럼 \(X_a(j\Omega)\)
- 디지털 스펙트럼 \(X_d(e^{j\omega})\)

사이의 **주기적 복제(알리아싱)** 형태로 기술된다.

샘플링 이론 하에서, 기본적인 관계는

$$
\Omega = \frac{\omega}{T} \quad (\text{비공식적 단순 대응})
$$

이지만, 실제로는
샘플링 이전에 **대역 제한(Lowpass anti-alias 필터)** 을 거친다는 가정 하에
**기본 대역 \(|\Omega| < \pi/T\)** 에서만 일대일 관계가 유지된다.

따라서 아날로그 필터를 디지털로 옮길 때,
- **어떤 방식으로 \(\Omega \leftrightarrow \omega\)를 매핑할 것인지**,
- 그 과정에서 **알리아싱**이 생기는지,
- 또는 **주파수 워핑**이 생기는지를 정확히 이해하는 것이 중요하다.

---

## 아날로그–디지털 필터 변환 방법 개관

대표적인 변환 기법을 크게 나누면 다음과 같다.

1. **임펄스 불변법(Impulse invariance)**
   - 아이디어: 아날로그 임펄스 응답 \(h_a(t)\)를 샘플링해서
     $$ h_d[n] = h_a(nT) $$
     로 두자.
   - 장점: 저주파 영역에서 아날로그 시스템과 **임펄스 응답이 일치** → **시간 응답**이 매우 유사.
   - 단점: 주파수 영역에서는 **알리아싱 발생** → **고역 필터**에는 부적합.

2. **계단 응답 불변법 / matched-z**
   - 아이디어: 계단응답 \(s_a(t)\)를 샘플링해서
     $$ s_d[n] = s_a(nT) $$
     로 두거나,
     아날로그 극/영점을 각각
     $$ z_k = e^{s_k T} $$
     로 매핑하는 방식.
   - 제어 시스템에서, ZOH(Zero-Order Hold) 포함 모델에서 자주 등장.

3. **bilinear 변환(BLT, Tustin 변환)**
   - 아이디어: \(s\)-평면과 \(z\)-평면 사이의 **쌍선형 매핑**:

     $$
     s = \frac{2}{T}\frac{1 - z^{-1}}{1 + z^{-1}}
     $$

   - 장점:
     - 좌반평면(LHP) ↔ 단위원 내부가 **1:1** 매핑 → 안정성 보존.
     - **알리아싱 없음.** 아날로그 전체 주파수축 \(-\infty<\Omega<\infty\) 을
       디지털 한 바퀴 \(-\pi <\omega <\pi\)에 압축.
   - 단점:
     - 주파수 축이 **비선형 워핑**.
       → **prewarping** 필요.

실무에서는 **대부분 bilinear 변환**을 사용하지만,
- **저주파 IIR 근사**나
- **컨트롤/모델링**에서는 임펄스/계단 불변법도 여전히 유효하다.

이제 각 기법을 자세히 본다.

---

## 임펄스 불변법 (Impulse Invariance)

### 정의

임펄스 불변법의 핵심 정의는 간단하다.

- 연속시간 임펄스 응답 \(h_a(t)\)가 있을 때,
- 디지털 임펄스 응답을

  $$
  h_d[n] = h_a(nT),\quad n = 0,1,2,\dots
  $$

  로 둔다.

그러면 디지털 시스템의 전송함수는

$$
H_d(z) = \sum_{n=0}^{\infty} h_a(nT)\, z^{-n}
$$

이 된다.

아날로그 시스템이 **유리함수**(유한 개의 극/영점)를 가지면,
\(h_a(t)\)는 지수들의 합으로 표현된다.

예를 들어, 아날로그 극 \(\{p_k\}\)와 잔차 \(\{c_k\}\)가 있어

$$
H_a(s) = \sum_{k=1}^{N} \frac{c_k}{s - p_k}
\quad\Rightarrow\quad
h_a(t) = \sum_{k=1}^{N} c_k e^{p_k t} u(t)
$$

일 때, 샘플링하면

$$
h_d[n] = h_a(nT)
= \sum_{k=1}^{N} c_k e^{p_k nT}
$$

따라서

$$
H_d(z)
=
\sum_{n=0}^{\infty} \left( \sum_{k=1}^{N} c_k e^{p_k nT} \right) z^{-n}
=
\sum_{k=1}^{N} \left( c_k \sum_{n=0}^{\infty} (e^{p_k T} z^{-1})^n \right)
$$

내부의 기하급수 합은

$$
\sum_{n=0}^{\infty} (e^{p_k T} z^{-1})^n =
\frac{1}{1 - e^{p_k T} z^{-1}}
$$

따라서

$$
H_d(z)
=
\sum_{k=1}^{N} \frac{c_k}{1 - e^{p_k T} z^{-1}}
=
\sum_{k=1}^{N} \frac{c_k z}{z - e^{p_k T}}
$$

즉, 임펄스 불변법은

- **아날로그 극** \(p_k\)를
- **디지털 극** \(z_k = e^{p_k T}\)로 매핑하는 효과가 있다.

(영점은 구조에 따라 다르지만, 보통 분자도 같이 변환된다.)

### 주파수 응답과 알리아싱

임펄스 불변법에서 디지털 주파수응답은

$$
H_d(e^{j\omega})
=
\frac{1}{T}
\sum_{m=-\infty}^{\infty}
H_a\left(j\frac{\omega + 2\pi m}{T}\right)
$$

형태로 표현된다.

즉, **아날로그 주파수 응답** \(H_a(j\Omega)\)가 디지털 주파수축에서 **\(2\pi/T\)** 간격으로 복제되어 **알리아싱**된다.

따라서:

- **저역 필터**, 특히
  \(|\Omega| \le \Omega_\text{max} \ll \pi/T\)인 영역만 쓰는 경우에는,
  복제 성분이 거의 겹치지 않아, **저주파 대역에서는 좋은 근사**가 된다.
- 하지만 고역까지 포함하거나, 대역통과 설계에는
  알리아싱으로 인해 **대역 외 아날로그 응답이 디지털 통과대역에 섞일 수 있다**.

그래서 임펄스 불변법은

- **저역통과(또는 저역에 국한된 대역) 필터**,
- 샘플링 주파수가 충분히 높은 경우

에 제한해서 쓰는 것이 일반적이다.

### 간단한 RC 저역통과 예제 (아날로그 → 디지털)

아날로그 1차 RC 저역통과:

$$
H_a(s) = \frac{\Omega_c}{s + \Omega_c}
$$

- \(\Omega_c = 2\pi F_c\): 컷오프 각주파수
- 임펄스 응답:

  $$
  h_a(t) = \Omega_c e^{-\Omega_c t} u(t)
  $$

임펄스 불변법:

$$
h_d[n] = h_a(nT) = \Omega_c e^{-\Omega_c nT}
$$

따라서 디지털 시스템 함수는

$$
H_d(z)
=
\sum_{n=0}^{\infty} \Omega_c e^{-\Omega_c nT} z^{-n}
=
\frac{\Omega_c}{1 - e^{-\Omega_c T} z^{-1}}
$$

양변에 \(z^{-1}\)를 곱해도 되므로,
디지털 차분방정식은

$$
y[n] = e^{-\Omega_c T} y[n-1] + (1 - e^{-\Omega_c T}) x[n]
$$

형태가 된다 (적절히 정규화했을 때).

#### GNU Octave — `impinvar` 사용 예제

GNU Octave의 signal 패키지에는 `impinvar` 함수가 있어,
아날로그 시스템 \((b,a)\)를 임펄스 불변법으로 디지털 \((bd,ad)\)로 변환할 수 있다.

```octave
pkg load signal;
clear; close all; clc;

% 아날로그 1차 저역통과: H_a(s) = Omega_c / (s + Omega_c)
Fc      = 1000;              % cutoff [Hz]
Omega_c = 2*pi*Fc;           % rad/s

b_a = [Omega_c];             % 분자
a_a = [1 Omega_c];           % 분모

Fs  = 48000;                 % 샘플링 주파수 [Hz]

% 임펄스 불변법 변환
[bd, ad] = impinvar(b_a, a_a, Fs);

% 디지털 주파수 응답
Nfft = 4096;
[H_d, w] = freqz(bd, ad, Nfft, Fs);   % digital

% 아날로그 주파수응답 (low freq only)
w_a = linspace(0, 4*pi*Fc, Nfft);      % rad/s
H_a = freqs(b_a, a_a, w_a);

figure;
subplot(2,1,1);
plot(w_a/(2*pi), 20*log10(abs(H_a)+eps), 'LineWidth', 1.2); hold on;
plot(w,            20*log10(abs(H_d)+eps), 'r--', 'LineWidth', 1.0);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title('Analog vs Digital (Impulse Invariance)');
legend('Analog H_a(j\Omega)', 'Digital H_d(e^{j\omega})', 'Location', 'SouthWest');

subplot(2,1,2);
plot(w_a/(2*pi), unwrap(angle(H_a)), 'LineWidth', 1.2); hold on;
plot(w,            unwrap(angle(H_d)), 'r--', 'LineWidth', 1.0);
grid on;
xlabel('Frequency (Hz)');
ylabel('Phase (rad)');
legend('Analog', 'Digital');
```

- 저주파 영역에서는 아날로그/디지털 크기응답이 **매우 비슷**하게 나옴을 확인할 수 있다.
- 하지만 디지털 주파수 축 끝(샘플링 주파수에 가까운 영역)에서는 아날로그 응답의 복제(알리아싱)가 영향을 미친다.

---

## 계단 응답 불변법 / matched-z

### 계단 응답 불변법 (Step invariance)

**임펄스 불변법**은

$$
h_d[n] = h_a(nT)
$$

이었고,
**계단 응답 불변법(step-invariant)**는

- 아날로그 계단 응답:

  $$
  s_a(t) = \int_{0}^{t} h_a(\tau)\, d\tau
  $$

- 디지털 계단 응답:

  $$
  s_d[n] = s_a(nT)
  $$

- 이산시간에서 \(s_d[n]\)를 차분하면 디지털 임펄스응답이 된다.

즉,

$$
h_d[n] = s_d[n] - s_d[n-1]
= s_a(nT) - s_a((n-1)T)
$$

이 되도록 디지털 필터를 정한다.
이 방법은 **유닛 스텝 입력에 대한 응답을 정확히 보존**한다.

### matched-z 변환

matched-z 변환은 조금 더 단순한 관점에서:

- 아날로그 시스템의 극/영점을 각각 **지수 매핑**:

  - 극 \(s_k\) → \(z_k = e^{s_k T}\)
  - 영점 \(z^a_\ell\) → \(z^d_\ell = e^{z^a_\ell T}\)

이 되도록 하는 것이다.
이렇게 하면, 지수 응답 \(e^{s_k t}\)가 샘플링 후 \(e^{s_k nT}\)가 되어
**계단/임펄스 응답의 주요 모드**를 잘 보존할 수 있다.

실제 제어 응용에서는 다음 세 가지 모델이 섞여 쓰인다.

1. **c2d (zero-order hold)**:
   - 연속시간 시스템 \(G(s)\)와 ZOH를 포함한 이산 모델 \(G_d(z)\)는

     $$
     G_d(z) = \mathcal{Z}\{ \mathcal{L}^{-1} \left[ \frac{G(s)}{s} \right] \big|_{t=nT} \}
     $$

   - 사실상 **계단 응답 불변법**에 해당.

2. **c2d (tustin)**:
   - bilinear 변환 기반.

3. **c2d (matched)**:
   - matched-z 또는 pole-zero 매칭.

이 글에서는 matched-z를 자세히 코드로 구현하기보다는,
“**임펄스/계단 응답을 모드 단위로 보존하려는 변환**”이라는 개념 측면에서만 정리해 둔다.
(필요하다면, 아날로그 극/영점을 찾아 각각 \(e^{sT}\)로 매핑하고 앞뒤 gain을 맞춰주는 방식으로 구현할 수 있다.)

---

## Bilinear 변환(쌍선형 변환, Tustin) — 핵심 이론

### 정의

bilinear 변환은 다음과 같이 정의되는 **쌍선형 분수 변환**이다.

$$
s = \frac{2}{T} \frac{1 - z^{-1}}{1 + z^{-1}}
$$

또는

$$
z = \frac{1 + \frac{sT}{2}}{1 - \frac{sT}{2}}
$$

이 변환의 매우 중요한 성질:

1. **LHP ↔ 단위원 내부**:
   - \(\Re\{s\} < 0\)이면, \(|z| < 1\).
   - 안정한 아날로그 시스템 → 안정한 디지털 시스템.

2. **imaginary axis ↔ 단위원**:
   - \(s = j\Omega\) → \(z = e^{j\omega}\) 형태로 매핑된다.
   - 즉, 아날로그의 **주파수 축**이 디지털의 **단위원**으로 매핑.

3. **알리아싱 없음**:
   - 아날로그 전체 주파수축 \(-\infty < \Omega < \infty\)를
     디지털 주파수축 \(-\pi < \omega < \pi\)로 **1:1** 매핑.

대신, 이 매핑은 **비선형**이다 → **주파수 워핑**.

### 주파수 워핑 관계

아날로그 \(s = j\Omega\)를 대응하는 디지털 주파수 \(\omega\)로 바꾸면,

$$
j\Omega = \frac{2}{T}\frac{1 - e^{-j\omega}}{1 + e^{-j\omega}}
$$

복소수 계산을 하면, 표준적으로

$$
\Omega = \frac{2}{T} \tan\left(\frac{\omega}{2}\right)
$$

라는 관계를 얻는다.
따라서,

- 디지털 주파수 \(\omega\)에 대응하는 아날로그 주파수는

  $$
  \Omega(\omega) = \frac{2}{T} \tan\left(\frac{\omega}{2}\right)
  $$

- 이 관계는 **비선형**이다 → 고주파 쪽으로 갈수록 **늘어짐**.

반대로,

$$
\omega(\Omega) = 2 \arctan\left(\frac{\Omega T}{2}\right)
$$

이 된다.

### Prewarping

우리가 디지털 영역에서 **원하는 컷오프 주파수** \(\omega_c\)를 지정했을 때,
bilinear 변환을 그냥 쓰면 **워핑** 때문에 실제 디지털 컷오프는 조금 다른 위치에 온다.

이를 보정하기 위해,

- 원하는 디지털 컷오프 \(\omega_c\)에 해당하는 아날로그 컷오프를 **prewarping**으로 계산:

  $$
  \Omega_c = \frac{2}{T} \tan\left(\frac{\omega_c}{2}\right)
  $$

- 이 \(\Omega_c\)를 이용해 **아날로그 프로토타입**을 설계하고,
- 그 다음 bilinear 변환을 적용하면,
  결과 디지털 필터는 정확히 \(\omega_c\)에서 원하는 특성을 갖는다.

이것이 “bilinear 변환 + prewarping”의 핵심이다.

### 아날로그–디지털 변환 절차 (bilinear + prewarping)

정리하면:

1. 디지털 스펙: \(F_s, \omega_p, \omega_s, A_p, A_s\) 등을 정한다.
2. prewarping:

   $$
   \Omega_p = \frac{2}{T} \tan\left(\frac{\omega_p}{2}\right),\quad
   \Omega_s = \frac{2}{T} \tan\left(\frac{\omega_s}{2}\right)
   $$

3. **원형 아날로그 필터 설계**:
   스펙 \((\Omega_p, \Omega_s, A_p, A_s)\)로
   Butterworth, Chebyshev, Elliptic 등을 이용해
   \(H_a(s)\)의 차수 \(N\)과 컷오프 \(\Omega_c\)를 설계.

4. \(H_a(s)\)에서 bilinear 변환

   $$
   s = \frac{2}{T} \frac{1 - z^{-1}}{1 + z^{-1}}
   $$

   을 대입하여
   \(H_d(z)\)의 계수 \(\{b_k\}, \{a_k\}\)를 얻는다.

5. `freqz`로 디지털 응답을 확인한다.

GNU Octave에서는 이 전체 과정을 `butter/cheby1/ellip` + `bilinear`로 구현할 수 있다.

---

## 예제 1 — 아날로그 Butterworth → 디지털 IIR (bilinear vs 임펄스 불변 비교)

### 설계 스펙

- 샘플링 주파수:
  $$ F_s = 48000\ \mathrm{Hz} $$
- 디지털 저역통과 스펙:
  - 통과대역 끝: \(F_p = 4\ \mathrm{kHz}\)
  - 저지대역 시작: \(F_s' = 8\ \mathrm{kHz}\)
  - 통과대역 리플: \(A_p = 1\ \mathrm{dB}\)
  - 저지대역 감쇠: \(A_s = 60\ \mathrm{dB}\)

이 스펙을 **아날로그 영역**으로 가져가서 Butterworth 프로토타입을 구한 다음,
- 임펄스 불변법
- bilinear 변환
두 가지로 디지털 필터를 만들고 비교해 보자.

### GNU Octave 코드 — 전체 설계 흐름

```octave
pkg load signal;
clear; close all; clc;

% 샘플링/디지털 스펙
Fs = 48000;
Fp = 4000;
Fs1 = 8000;
Ap = 1;      % passband ripple (dB)
As = 60;     % stopband attenuation (dB)

T  = 1/Fs;

% 1) 디지털 각주파수 -> prewarping
omega_p = 2*pi*Fp/Fs;    % digital rad
omega_s = 2*pi*Fs1/Fs;

Omega_p = (2/T)*tan(omega_p/2);
Omega_s = (2/T)*tan(omega_s/2);

printf("Prewarped: Omega_p=%g rad/s, Omega_s=%g rad/s\n", Omega_p, Omega_s);

% 2) 아날로그 Butterworth 차수 N, cutoff Omega_c 계산
Ep = sqrt(10^(Ap/10) - 1);
Es = sqrt(10^(As/10) - 1);

N_exact = log10(Es/Ep) / (2*log10(Omega_s/Omega_p));
N = ceil(N_exact);
printf("Butterworth order: N_exact=%.3f, N=%d\n", N_exact, N);

Omega_c = Omega_p / ( (10^(Ap/10) - 1)^(1/(2*N)) );
printf("Analog cutoff: Omega_c=%g rad/s (≈ %g Hz)\n", Omega_c, Omega_c/(2*pi));

% 3) 아날로그 Butterworth LPF 설계
[b_a, a_a] = butter(N, Omega_c, "s");

% 4-1) 임펄스 불변법으로 디지털 변환
[bd_imp, ad_imp] = impinvar(b_a, a_a, Fs);

% 4-2) bilinear 변환으로 디지털 변환
[bd_blt, ad_blt] = bilinear(b_a, a_a, Fs);

% 5) 디지털 응답 비교
Nfft = 4096;
[H_imp, w] = freqz(bd_imp, ad_imp, Nfft, Fs);
[H_blt, ~] = freqz(bd_blt, ad_blt, Nfft, Fs);

figure;
subplot(2,1,1);
plot(w, 20*log10(abs(H_imp)+eps), 'b', 'LineWidth', 1.2); hold on;
plot(w, 20*log10(abs(H_blt)+eps), 'r--', 'LineWidth', 1.2);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title(sprintf('Digital IIR LPF via Impulse Invariance vs Bilinear (N=%d)', N));
legend('Impulse invariance', 'Bilinear', 'Location', 'SouthWest');
xlim([0 20000]);
ylim([-100 5]);

subplot(2,1,2);
plot(w, unwrap(angle(H_imp)), 'b', 'LineWidth', 1.2); hold on;
plot(w, unwrap(angle(H_blt)), 'r--', 'LineWidth', 1.2);
grid on;
xlabel('Frequency (Hz)');
ylabel('Phase (rad)');
legend('Impulse invariance', 'Bilinear', 'Location', 'SouthWest');
xlim([0 20000]);
```

이 코드로 확인할 수 있는 것:

- 두 필터 모두 저역에서 **유사한 roll-off**를 보이지만,
- 임펄스 불변법 필터는 **고주파 대역에서 아날로그 응답의 복제(알리아싱)** 때문에
  저지대역 감쇠가 스펙과 다를 수 있다.
- bilinear 필터는 prewarping 덕분에 **지정한 \(F_p, F_s'\)에서 정확히 스펙을 맞추는** 경향이 있다.

실제로, `buttord` + `butter`를 사용하면 이 과정을 더 간단히 구현할 수 있지만,
여기서는 **“아날로그–디지털 변환”의 원리를 드러내기 위해** 수식을 그대로 코드로 적었다.

---

## Bilinear 변환의 수식적 변환 예 — 1차 아날로그 RC 필터

임펄스 불변법 예에서 사용한 같은 아날로그 필터

$$
H_a(s) = \frac{\Omega_c}{s + \Omega_c}
$$

에 bilinear 변환을 직접 적용해 보자.

### 변환 수식

bilinear:

$$
s = \frac{2}{T} \frac{1 - z^{-1}}{1 + z^{-1}}
$$

이므로,

$$
H_d(z) = H_a(s)\big|_{s=\frac{2}{T}\frac{1 - z^{-1}}{1 + z^{-1}}}
= \frac{\Omega_c}{\frac{2}{T}\frac{1 - z^{-1}}{1 + z^{-1}} + \Omega_c}
$$

분모를 통분하면,

$$
\frac{2}{T}\frac{1 - z^{-1}}{1 + z^{-1}} + \Omega_c
=
\frac{2(1 - z^{-1})}{T(1 + z^{-1})} + \Omega_c
=
\frac{2(1 - z^{-1}) + \Omega_c T(1 + z^{-1})}{T(1 + z^{-1})}
$$

따라서

$$
H_d(z) = \frac{\Omega_c}{\frac{2(1 - z^{-1}) + \Omega_c T(1 + z^{-1})}{T(1 + z^{-1})}}
= \frac{\Omega_c T (1 + z^{-1})}{2(1 - z^{-1}) + \Omega_c T(1 + z^{-1})}
$$

분자·분모를 정리하면,

- 분자: \(\Omega_c T (1 + z^{-1})\)
- 분모:

  $$
  2(1 - z^{-1}) + \Omega_c T(1 + z^{-1})
  =
  (2 + \Omega_c T) + (-2 + \Omega_c T) z^{-1}
  $$

따라서

$$
H_d(z)
=
\frac{\Omega_c T(1 + z^{-1})}{(2 + \Omega_c T) + (-2 + \Omega_c T) z^{-1}}
$$

이를 표준 형태

$$
H_d(z) = \frac{b_0 + b_1 z^{-1}}{1 + a_1 z^{-1}}
$$

로 쓰기 위해 분모를 정규화하면,

- 분모 계수:

  $$
  1 + a_1 z^{-1}
  =
  \frac{1}{2 + \Omega_c T}
  \left[ (2 + \Omega_c T) + (-2 + \Omega_c T) z^{-1} \right]
  $$

  이므로,

  $$
  a_1 = \frac{-2 + \Omega_c T}{2 + \Omega_c T}
  $$

- 분자 계수:

  $$
  b_0 = b_1 = \frac{\Omega_c T}{2 + \Omega_c T}
  $$

결론적으로, bilinear 변환 1차 IIR 필터의 차분방정식은:

$$
y[n] = -a_1 y[n-1] + b_0 x[n] + b_1 x[n-1]
$$

즉,

$$
y[n]
=
\frac{-2 + \Omega_c T}{2 + \Omega_c T} y[n-1]
+
\frac{\Omega_c T}{2 + \Omega_c T} (x[n] + x[n-1])
$$

이다.

### GNU Octave로 직접 비교

위 수식을 Octave에서 직접 구현해, `bilinear` 함수 결과와 비교해 보자.

```octave
pkg load signal;
clear; close all; clc;

Fs      = 48000;
T       = 1/Fs;
Fc      = 1000;
Omega_c = 2*pi*Fc;

% bilinear 공식을 직접 사용한 계수
a1 = (-2 + Omega_c*T) / (2 + Omega_c*T);
b0 = (Omega_c*T) / (2 + Omega_c*T);
b1 = b0;

bd_manual = [b0 b1];
ad_manual = [1  a1];

% signal 패키지 bilinear 함수 사용
b_a = [Omega_c];
a_a = [1 Omega_c];
[bd_blt, ad_blt] = bilinear(b_a, a_a, Fs);

% 비교
disp('Manual bilinear coeffs:');
bd_manual
ad_manual

disp('bilinear() coeffs:');
bd_blt
ad_blt
```

정규화 방식이 동일하다면, 두 결과는 수치적으로 매우 비슷해야 한다
(회귀 차이 수준에서만 틀릴 수 있다).

---

## 방법 선택 가이드 — 언제 어떤 아날로그–디지털 변환을 쓸 것인가?

지금까지 정리한 내용을 **실무 관점**에서 정리하면 다음과 같다.

### Impulse invariance

- **장점**
  - 낮은 주파수 대역에서 아날로그 시스템의 **임펄스/시간 응답**을 잘 재현.
  - 저주파에서의 **위상·군지연**이 아날로그와 유사.
- **단점**
  - 주파수 영역에서 **알리아싱**이 발생.
  - 고역/대역통과 필터에는 적합하지 않다.

- **권장 사용처**
  - 저역만 사용하는 경우,
    예를 들어 샘플링 주파수가 충분히 높고,
    관심 대역이 \(0 \sim F_\text{max}\)로 아날로그 필터 대역보다 훨씬 좁은 경우.

### Step invariance / matched-z

- **장점**
  - **계단 응답** 또는 pole-zero 모드 구성을 유지하려는 관점에서 자연스럽다.
  - 제어 시스템에서 ZOH 포함 모델을 사용해
    연속시간 시스템을 디지털 제어기로 설계할 때 유용.

- **단점**
  - 주파수 응답 관점에서는 bilinear만큼 정교하게 대역특성을 맞추지 못할 수 있음.
  - 구현이 상대적으로 더 복잡(특히 일반적 신호처리 라이브러리에서 지원이 덜하다).

- **권장 사용처**
  - 제어/계측 분야에서, 연속시간 모델을 기반으로 디지털 제어기를 설계할 때.
  - **ZOH 기반 c2d 변환**의 내부 원리를 이해하는 용도.

### Bilinear 변환

- **장점**
  - 안정성 보존: LHP ↔ 단위원 내부.
  - 알리아싱 없음: 주파수 축이 1:1 매핑.
  - prewarping으로 설계 스펙(\(F_p, F_s, A_p, A_s\))을 정확하게 맞추기 쉽다.
  - 대부분의 신호처리/SW 라이브러리에 **표준으로 내장**.

- **단점**
  - 주파수 워핑: 고역으로 갈수록 아날로그 주파수와 디지털 주파수가 비선형 관계.
  - 매우 정교한 위상/군지연 특성이 필요한 경우(예: group delay matching)에는 추가 설계 고려가 필요.

- **권장 사용처**
  - **대부분의 디지털 IIR 필터 설계**, 특히
    - 오디오
    - 통신
    - 신호처리 전반에서
  - Butterworth / Chebyshev / Elliptic / Bessel 아날로그 프로토타입 기반 설계.

정리하면,

- “아날로그–디지털 필터 변환”을 이야기할 때
  실무에서는 거의 항상 **bilinear 변환 + prewarping**을 의미한다.
- 임펄스/계단 불변법은 **특별한 목적(저역 시간응답 보존, 제어 시스템)**에서 사용할 수 있는
  **대안적인 도구**로 이해해 두면 된다.

---

## 연습문제 (GNU Octave 실습 포함)

마지막으로, 이 글을 기반으로 한 연습문제를 제시한다.
실제 블로그에서는 이 섹션을 별도의 글로 분리해도 좋다.

### 연습문제 1 — 1차 RC 필터의 임펄스 불변 vs bilinear

1. 아날로그 1차필터

   $$
   H_a(s) = \frac{\Omega_c}{s + \Omega_c}
   $$

   에 대해,

   - 임펄스 불변법으로 얻은 디지털 필터 \(H_d^{(\text{imp})}(z)\)의 계수를 손으로 유도하라.
   - bilinear 변환으로 얻은 디지털 필터 \(H_d^{(\text{blt})}(z)\)의 계수를 손으로 유도하라.

2. GNU Octave로 두 필터를 구현한 뒤,

   - 샘플링 주파수 \(F_s = 48\ \mathrm{kHz}\), 컷오프 \(F_c = 2\ \mathrm{kHz}\),
   - `freqz`로 크기/위상 응답을 비교하라.
   - 임펄스 응답(여러 샘플)을 `filter` 함수로 확인하고,
     두 방법의 시간 응답 차이를 관찰하라.

힌트: 위 본문에 있는 유도과정을 그대로 따라가면 된다.

### 연습문제 2 — Butterworth 4차 필터 설계 (bilinear + prewarping vs bilinear 직접 설계)

1. 디지털 스펙:

   - \(F_s = 44.1\,\mathrm{kHz}\)
   - 저역통과:
     - \(F_p = 5\,\mathrm{kHz}\)
     - \(F_s' = 7\,\mathrm{kHz}\)
     - \(A_p = 1\,\mathrm{dB}\)
     - \(A_s = 50\,\mathrm{dB}\)

2. 두 가지 방법으로 디지털 IIR를 설계하라.

   - 방법 A:
     - prewarping으로 \(\Omega_p, \Omega_s\)를 계산
     - 아날로그 Butterworth 차수/컷오프를 공식으로 계산
     - `butter(..., "s")`로 아날로그 필터 설계
     - `bilinear`로 디지털 변환.
   - 방법 B:
     - `buttord`/`butter`의 디지털 모드를 사용 (디지털 정규화 주파수로 직접 설계).

3. 두 디지털 필터의 주파수 응답을 비교하고,
   설계 스펙을 얼마나 잘 만족하는지 평가하라.

GNU Octave에서는 `buttord`가 다소 버전 의존이 있을 수 있지만,
지원되는 환경이라면 다음과 같이 사용할 수 있다.

```octave
pkg load signal;
Fs = 44100;
Fp = 5000;
Fs1 = 7000;
Ap = 1;
As = 50;

Wp = Fp/(Fs/2);
Ws = Fs1/(Fs/2);

[N, Wn] = buttord(Wp, Ws, Ap, As);
[bd, ad] = butter(N, Wn);   % 디지털 IIR LPF
```

### 연습문제 3 — Chebyshev I + bilinear vs Butterworth + bilinear

1. 같은 스펙 \((F_s, F_p, F_s', A_p, A_s)\)에 대해

   - 아날로그 Chebyshev I 프로토타입 + bilinear
   - 아날로그 Butterworth 프로토타입 + bilinear

   두 필터를 설계하라.

2. 디지털 응답에서

   - 통과대역 리플
   - 전이대역 폭
   - 저지대역 감쇠

   를 비교하라.

3. 같은 차수 \(N\)일 때 Chebyshev I / Butterworth의 차이를 주파수 응답 그래프와 숫자로 정리해 보라.

### 연습문제 4 — Bessel 원형 필터 + bilinear

1. 문헌에서 3차 또는 4차 Bessel 저역통과 필터의 분모 계수 \(\{a_k\}\)를 찾아라.
2. 이 아날로그 Bessel 필터를 bilinear 변환으로 디지털 필터로 만든 뒤,
   `grpdelay`(또는 군지연 수치 미분)를 이용해 **군지연 응답**을 플롯하라.
3. 같은 차수의 Butterworth/ Chebyshev I/ Elliptic 필터들과 군지연 응답을 비교하고,
   Bessel 필터가 **시간 영역 파형 보존** 측면에서 어떤 장점을 가지는지 토론하라.

---

## 결론

이 글에서는 **아날로그–디지털 필터 변환**을 다음의 구조로 정리했다.

1. **연속–이산 시스템 관계**
   - \(H_a(s)\), \(H_d(z)\), 임펄스/계단/주파수 응답의 관계.
   - 샘플링과 주파수 축 매핑 (\(\Omega \leftrightarrow \omega\)).

2. **변환 기법 개관**
   - 임펄스 불변법: \(h_d[n] = h_a(nT)\), 저역 시간응답을 잘 보존하지만 알리아싱 존재.
   - 계단 응답 불변법 / matched-z: ZOH 기반 제어에서 자주 등장.
   - bilinear 변환: LHP ↔ 단위원, 알리아싱 없음, prewarping 필요.

3. **bilinear 변환의 수학과 prewarping**
   - 쌍선형 매핑:
     $$ s = \frac{2}{T}\frac{1 - z^{-1}}{1 + z^{-1}} $$
   - 주파수 워핑:
     $$ \Omega = \frac{2}{T} \tan\left(\frac{\omega}{2}\right) $$
   - prewarping: 원하는 디지털 컷오프 \(\omega_c\)에 대해
     $$ \Omega_c = \frac{2}{T}\tan\left(\frac{\omega_c}{2}\right) $$
     로 아날로그 설계를 수행.

4. **GNU Octave 예제**
   - `impinvar`, `bilinear`, `freqs`, `freqz`를 사용한
     아날로그–디지털 변환 실습 코드.

5. **방법 선택 가이드**
   - 일반 디지털 신호처리/오디오/통신 → **bilinear + prewarping**
   - 저역 시간응답 중시 → **임펄스 불변법** 고려
   - 제어 시스템(ZOH 포함 모델) → **계단 응답 불변법 / matched-z / ZOH 모델** 고려

이 글은 앞선 “원형 아날로그 필터의 특성” 글과 함께,
**“아날로그 프로토타입 → 디지털 IIR” 설계 흐름**의 가운데를 메워준다.

다음 단계에서는

- 실제 응용별 스펙(오디오 이퀄라이저, 통신용 대역통과, 센서 신호 필터)에서
- 어떤 원형 필터와 어떤 변환 기법을 선택할지
- 그리고 고정소수점 환경에서 수치 안정성·계수 양자화까지 포함해

**“완전한 IIR 설계 파이프라인”**을 정리하는 방향으로 확장해 나가면 된다.
