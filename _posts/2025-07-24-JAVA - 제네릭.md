---
layout: post
title: Java - 제네릭
date: 2025-07-24 22:20:23 +0900
category: Java
---
# 자바 제네릭(Generic)

## 왜 제네릭인가 — 장점 요약

| 이점 | 설명 | 예시/효과 |
|---|---|---|
| **타입 안정성** | 컴파일 타임에 타입 위반 검출 | `List<String>`에 `Integer` 삽입 시 컴파일 에러 |
| **불필요한 캐스팅 제거** | API가 정확한 타입을 반환 | `String s = list.get(0);` |
| **자기문서화 API** | 타입 인자만 보아도 용도 파악 | `Map<String, List<Integer>>` |
| **재사용성** | 하나의 코드로 다형 타입 처리 | `Box<T>`, `Util.<T>max(...)` |

---

## 제네릭 기본 문법 — 클래스/인터페이스/메서드

### 제네릭 클래스/인터페이스

```java
// 클래스
public class Box<T> {
    private T item;
    public void set(T item) { this.item = item; }
    public T get() { return item; }
}

// 인터페이스
public interface Processor<T> {
    void process(T t);
}

class StringPrinter implements Processor<String> {
    @Override public void process(String s) { System.out.println(s.toUpperCase()); }
}
```

### 제네릭 메서드(정적/인스턴스 모두 가능)

```java
public class Util {
    public static <T> T first(T a, T b) { return a; }
    public static <T> void printAll(T[] arr) { for (T t : arr) System.out.println(t); }
}
```

### 타입 매개변수 관례

| 기호 | 의미 |
|---|---|
| `T` | Type |
| `E` | Element (컬렉션) |
| `K, V` | Key, Value (맵) |
| `N` | Number |
| `R` | Result / Return type |

---

## — 상한/하한/다중/재귀적 바운드

### 상한 바운드(extends)

```java
class NumberBox<T extends Number> {
    private T n;
    public NumberBox(T n){ this.n = n; }
    public double asDouble(){ return n.doubleValue(); }
}
```
- `T`는 `Number` 하위만 허용(`Integer`, `Double` …).

### 다중 바운드(교차 타입, 인터섹션)

```java
class MeasurableAndNamed<T extends Number & Comparable<T>> { /* ... */ }
```
- 클래스는 최대 1개 + 인터페이스 여러 개. 순서: **클래스 먼저**.

### 재귀적 바운드(F-bounded, 자기 타입)

```java
class SelfComparable<T extends SelfComparable<T>> implements Comparable<T> {
    @Override public int compareTo(T o) { return 0; }
}

static <T extends Comparable<? super T>> T max(java.util.Collection<? extends T> c) {
    T best = null;
    for (T t : c) if (best == null || t.compareTo(best) > 0) best = t;
    return best;
}
```
- **`<? super T>`** 로 비교의 **반공변** 호환 확보(아래 §4).

---

## 와일드카드 심화 — PECS/공변·반공변·불변

### PECS 원칙

- **P**roducer → **E**xtends: 생산자(읽기 전용) 입력은 `? extends T`
- **C**onsumer → **S**uper: 소비자(쓰기 대상) 입력은 `? super T`

```java
// src에서 읽어 dst로 복사
static <T> void copy(java.util.List<? super T> dst, java.util.List<? extends T> src) {
    for (T t : src) dst.add(t);
}
```

### 읽기/쓰기 가능 여부 표

| 시그니처 | 읽기(get) | 쓰기(add) | 사용 맥락 |
|---|---|---|---|
| `List<T>` | T | T | 일반적 |
| `List<? extends T>` | T (안전) | X (불가, `null`만) | **생산자**(읽기) |
| `List<? super T>` | `Object` (다운캐스팅 필요) | T (안전) | **소비자**(쓰기) |

### 커스텀 정렬/필터 예

```java
static <T> void addAll(java.util.Collection<? super T> bag, java.util.Collection<? extends T> items) {
    bag.addAll(items);
}
```

---

## — 도우미 메서드 패턴

`List<?>`는 쓰기 불가. **helper 메서드**로 캡처해 해결:

```java
public static void swap(java.util.List<?> list, int i, int j) {
    swapHelper(list, i, j); // 캡처
}
private static <T> void swapHelper(java.util.List<T> list, int i, int j) {
    T tmp = list.get(i);
    list.set(i, list.get(j));
    list.set(j, tmp);
}
```

---

## 배열과 제네릭 — 생성 금지, 대안, varargs 주의

### 제네릭 배열 생성 금지

```java
// T[] arr = new T[10]; // 불가(컴파일 오류)
@SuppressWarnings("unchecked")
static <T> T[] newArray(Class<T> type, int len) {
    return (T[]) java.lang.reflect.Array.newInstance(type, len);
}
```
- **대안**: `Class<T>`를 받아 `Array.newInstance`, 또는 `List<T>` 사용.

### varargs와 힙 오염(Heap Pollution)

```java
@SafeVarargs // 호출자가 가변 인자에 제네릭을 넘겨도 안전하다는 "약속"
static <T> java.util.List<T> listOf(T... arr) {
    return java.util.Arrays.asList(arr);
}
```
- 가변 인자에 제네릭 배열이 생성되며 **unchecked 경고** 유발. 안전성 보장 시 **`@SafeVarargs`** (static/final/private 메서드에서만).

---

## — 규칙, 제약, 브리지

### 소거 규칙

- **컴파일 시** 제네릭 정보 제거 → 런타임엔 **원시 타입(raw)** 과 유사.
```java
var a = new java.util.ArrayList<String>();
var b = new java.util.ArrayList<Integer>();
System.out.println(a.getClass() == b.getClass()); // true
```

### `instanceof`/배열/예외 제약

```java
// if (x instanceof java.util.List<String>) {}   // 불가
if (x instanceof java.util.List<?>) { /* OK */ }

// 제네릭 예외 금지
// class Problem<T> extends Exception {} // 불가
```

### 브리지 메서드(bridge method)

- 소거로 인해 오버라이드 시 **컴파일러가 브리지**를 생성해 바이너리 호환 확보.
- 일반적으로 인지하지 않아도 되며, 리플렉션 시 보일 수 있음.

### **Raw type** 사용 금지(경고)

```java
java.util.List raw = new java.util.ArrayList(); // 경고
raw.add(123); raw.add("x");                     // 타입 안전성 붕괴
```
- **항상** 매개변수화된 타입 사용: `List<?>` 또는 `List<Object>` 등.

---

## static/내부/생성자와 제네릭

- **static** 멤버는 클래스의 타입 매개변수 사용 **불가**
```java
class Holder<T> {
    // private static T cache; // 불가
    static <U> U id(U u) { return u; } // 정적 제네릭 메서드로 해결
}
```
- **제네릭 생성자**는 클래스의 타입 매개변수와 **독립적**일 수 있음.
```java
class Pair<A, B> {
    final A a; final B b;
    <X, Y> Pair(X x, Y y, java.util.function.Function<X, A> fa, java.util.function.Function<Y, B> fb) {
        this.a = fa.apply(x); this.b = fb.apply(y);
    }
}
```

---

## 타입 추론 — 다이아몬드, 메서드 추론, 타겟 타입

### 다이아몬드(`<>`)

```java
java.util.Map<String, java.util.List<Integer>> m = new java.util.HashMap<>();
```

### 메서드 타입 추론 & 타겟 타입(람다/메서드 레퍼런스)

```java
static <T> T pick(T a, T b) { return a; }

String s = pick("A", "B");             // T=String
var list = java.util.Arrays.asList(1,2,3);
list.stream().map(Object::toString).forEach(System.out::println);
```

---

## 스트림/컬렉션과 제네릭 시그니처

### `Comparator`/`Collectors`의 제네릭

```java
record User(long id, String name) {}

java.util.List<User> users = java.util.List.of(new User(1,"A"), new User(2,"B));
users.stream()
     .sorted(java.util.Comparator.comparing(User::name)) // Comparator<User>
     .forEach(System.out::println);

java.util.Map<Long, String> idToName =
    users.stream().collect(java.util.stream.Collectors.toMap(User::id, User::name));
```

### Optional — `map`/`flatMap`의 타입 전파

```java
java.util.Optional<String> os = java.util.Optional.of("hi");
java.util.Optional<Integer> len = os.map(String::length); // Optional<Integer>
```

### 제네릭 유틸 API 예시(PECS 적용)

```java
static <T extends Comparable<? super T>>
java.util.Optional<T> max(java.util.Collection<? extends T> c) {
    T best = null;
    for (T t : c) if (best == null || t.compareTo(best) > 0) best = t;
    return java.util.Optional.ofNullable(best);
}
```

---

## 실전 패턴 — 타입 안전 레지스트리/복사/타입 토큰

### 타입 안전 레지스트리: `Map<Class<T>, T>`

```java
class Registry {
    private final java.util.Map<Class<?>, Object> map = new java.util.HashMap<>();

    public <T> void put(Class<T> k, T v) { map.put(k, v); }
    public <T> T get(Class<T> k) { return k.cast(map.get(k)); } // 안전 캐스트
}

class Demo {
    public static void main(String[] args) {
        Registry r = new Registry();
        r.put(String.class, "Hello");
        r.put(Integer.class, 42);
        String s = r.get(String.class);
        Integer i = r.get(Integer.class);
        System.out.println(s + " / " + i);
    }
}
```

### 리스트 복사(PECS)

```java
static <T> void copy(java.util.List<? super T> dst, java.util.List<? extends T> src) {
    for (T t : src) dst.add(t);
}
```

### 타입 토큰/리플렉션 기반 생성

```java
static <T> T newInstance(Class<T> type) {
    try { return type.getDeclaredConstructor().newInstance(); }
    catch (ReflectiveOperationException e) { throw new IllegalArgumentException(e); }
}
```
> 라이브러리(Gson/Jackson)는 `TypeToken/TypeReference`로 **소거 한계**를 보완.

---

## 금지/주의 목록 — 제네릭 예외, raw type, instanceof, equals

- **제네릭 예외 금지**: `class MyEx<T> extends Exception {}` (불가).
- **raw type 금지**: 호환성용이지만 타입 안전 붕괴 → `List<?>`를 써라.
- **`instanceof`**: `List<?>`만 허용, `List<String>` 검사 불가.
- **equals/hashCode**: 제네릭과 무관하나, 컬렉션 키/원소로 쓰일 때 불변/동치 준수 필수.

---

## 종합 예제 — 제네릭 유틸 모듈

```java
import java.util.*;
import java.util.function.*;
import java.lang.reflect.Array;

public class GenericsKit {

  // 1) 최대값 (재귀적/반공변 바운드)
  public static <T extends Comparable<? super T>> Optional<T> max(Collection<? extends T> c) {
    T best = null;
    for (T t : c) if (best == null || t.compareTo(best) > 0) best = t;
    return Optional.ofNullable(best);
  }

  // 2) 복사 (PECS)
  public static <T> void copy(List<? super T> dst, List<? extends T> src) {
    for (T t : src) dst.add(t);
  }

  // 3) 안전한 swap (캡처 헬퍼)
  public static void swap(List<?> list, int i, int j) { swapHelper(list, i, j); }
  private static <T> void swapHelper(List<T> list, int i, int j) {
    T tmp = list.get(i); list.set(i, list.get(j)); list.set(j, tmp);
  }

  // 4) 배열 생성 대안
  @SuppressWarnings("unchecked")
  public static <T> T[] newArray(Class<T> type, int len) {
    return (T[]) Array.newInstance(type, len);
  }

  // 5) 타입 안전 레지스트리
  public static class Registry {
    private final Map<Class<?>, Object> map = new HashMap<>();
    public <T> void put(Class<T> k, T v){ map.put(k, v); }
    public <T> T get(Class<T> k){ return k.cast(map.get(k)); }
  }

  // 6) 안전 varargs 팩토리
  @SafeVarargs
  public static <T> List<T> listOf(T... items) { return Arrays.asList(items); }

  // Demo
  public static void main(String[] args) {
    System.out.println(max(List.of(3,1,4,1,5)).orElse(-1)); // 5

    List<Number> nums = new ArrayList<>();
    copy(nums, List.of(1, 2.0, 3L));
    System.out.println(nums);

    List<String> a = new ArrayList<>(List.of("A","B","C"));
    swap(a, 0, 2);
    System.out.println(a);

    String[] arr = newArray(String.class, 3);
    System.out.println(arr.length);

    Registry r = new Registry();
    r.put(Integer.class, 10); r.put(String.class, "hi");
    System.out.println(r.get(Integer.class) + " / " + r.get(String.class));

    System.out.println(listOf("x","y","z"));
  }
}
```

---

## API 시그니처 설계 베스트 프랙티스

1. **매개변수엔 와일드카드**, **반환 타입은 구체적**
   - 인수 유연성 제공 + 호출자 후처리 용이
   - 예: `boolean addAll(Collection<? super E> dst, Collection<? extends E> src)`

2. **PECS 적용**
   - 읽기(source): `? extends T`, 쓰기(sink): `? super T`.

3. **반환에 와일드카드 사용 자제**
   - `List<? extends T>` 반환은 곧바로 `add` 불가 → 보통 `List<T>` 반환.

4. **Optional/Stream과 함께 제네릭 친화**
   - `Optional<T>`, `Stream<T>` 반환 시 타입 추론에 유리.

5. **Raw type 금지, `@SuppressWarnings("unchecked")` 최소화**
   - 꼭 필요한 곳(캡슐화된 내부)에서만, 주석으로 안전성 논리 서술.

---

## 안티패턴 & 체크리스트

- [ ] Raw type 사용(`List`) → **항상** `List<?>`/`List<T>`
- [ ] `List<? extends T>`에 `add` 시도 → **불가**(PECS)
- [ ] `instanceof List<String>` → **불가**, `List<?>`로 검사
- [ ] 제네릭 배열 생성 → **불가**, `Array.newInstance` 사용
- [ ] 가변 인자 + 제네릭 경고 무시 → **@SafeVarargs** + 문서화
- [ ] static 필드에 타입 매개변수 사용 → **불가**, 정적 제네릭 메서드로
- [ ] 예외 클래스를 제네릭으로 → **불가**
- [ ] equals/hashCode 계약 무시 → 컬렉션 키/원소로 부적절

---

## 요약 표

| 주제 | 핵심 한 줄 |
|---|---|
| PECS | **Producer–extends, Consumer–super** |
| 재귀적 바운드 | `T extends Comparable<? super T>` |
| 배열/varargs | 배열 생성 금지, `@SafeVarargs`로 안전 보장 |
| 소거 | 런타임에 타입 정보 제거 → `instanceof List<?>`만 |
| 설계 | **인수는 와일드카드**, **반환은 구체 타입** |
| 캡처 | `List<?>` 쓰기는 헬퍼 `<T>`로 캡처 |
| 스트림 | `Comparator.comparing`, `Collectors.toMap` 등 제네릭 시그니처 활용 |

---

## 빠른 실습 문제

1) `min(Collection<? extends T>)`를 **`T extends Comparable<? super T>`**로 구현하라.
2) `merge(Map<K,V> a, Map<? extends K, ? extends V> b)`를 구현해 a에 b를 안전히 합쳐라.
3) `Class<T>`를 받아 기본 생성자로 인스턴스를 만들고, 실패 시 `IllegalArgumentException`으로 번역하라.

---

### 마무리

제네릭은 “**컴파일 타임 타입 안전성**을 강제하여 **런타임 오류를 사전 제거**”하는 도구입니다. 핵심은 **PECS, 바운드, 소거 제약, 캡처, 타입 추론**을 정확히 이해하고, **API 시그니처를 일관되게 설계**하는 것입니다. 위 체크리스트만 지켜도 대부분의 함정을 예방할 수 있습니다.
