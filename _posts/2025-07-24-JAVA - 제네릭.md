---
layout: post
title: Java - 제네릭
date: 2025-07-24 22:20:23 +0900
category: Java
---
# 자바의 제네릭(Generic)에 대해 자세하게 정리

자바에서 **제네릭(Generic)**은 **클래스나 메서드에서 사용할 데이터 타입을 일반화**하여 코드의 **재사용성, 타입 안전성, 가독성**을 높여주는 기능입니다. 컴파일 시점에 타입을 검사할 수 있게 해주기 때문에 **런타임 오류를 줄이고, 캐스팅을 줄이는** 장점이 있습니다.

---

## 1. 제네릭이란?

**제네릭(Generic)**은 클래스, 인터페이스, 메서드에서 사용할 데이터 타입을 **매개변수화(Parameterize)**할 수 있게 해주는 문법입니다.

### 제네릭 전 코드 (JDK 1.5 이전)
```java
List list = new ArrayList();
list.add("Hello");
String s = (String) list.get(0); // 명시적 캐스팅 필요
```

### 제네릭 사용 (JDK 1.5 이후)
```java
List<String> list = new ArrayList<>();
list.add("Hello");
String s = list.get(0); // 캐스팅 불필요
```

---

## 2. 제네릭의 이점

| 장점 | 설명 |
|------|------|
| 타입 안정성 | 컴파일 시 타입 체크 가능 |
| 코드 재사용성 | 다양한 타입에 대해 하나의 클래스/메서드로 처리 가능 |
| 명확한 API | 가독성 향상, 타입 추론 가능 |
| 불필요한 캐스팅 제거 | 명시적 형변환 생략 가능 |

---

## 3. 제네릭 클래스

```java
public class Box<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}
```

### 사용 예
```java
Box<String> stringBox = new Box<>();
stringBox.setItem("Hello");
String s = stringBox.getItem(); // 캐스팅 불필요

Box<Integer> intBox = new Box<>();
intBox.setItem(123);
Integer i = intBox.getItem();
```

- `T`는 타입 매개변수(Type Parameter)이며 관례적으로 다음과 같은 알파벳을 사용합니다:
  - `T`: Type
  - `E`: Element
  - `K`: Key
  - `V`: Value
  - `N`: Number

---

## 4. 제네릭 메서드

```java
public class Util {
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
}
```

### 사용 예
```java
Integer[] intArr = {1, 2, 3};
String[] strArr = {"A", "B", "C"};

Util.printArray(intArr);
Util.printArray(strArr);
```

- `<T>`는 메서드 선언 앞에 있어야 하며, 이 메서드는 어떤 타입이든 받아 처리할 수 있습니다.

---

## 5. 제네릭 인터페이스

```java
public interface Processor<T> {
    void process(T item);
}

public class StringProcessor implements Processor<String> {
    public void process(String item) {
        System.out.println(item.toUpperCase());
    }
}
```

---

## 6. 제네릭의 제한 (Bounded Type)

타입 매개변수에 **상한**을 둘 수 있습니다.

```java
public class NumberBox<T extends Number> {
    private T num;

    public void setNum(T num) {
        this.num = num;
    }

    public double doubleValue() {
        return num.doubleValue();
    }
}
```

- `T extends Number`는 `T`가 `Number` 또는 그 하위 클래스만 올 수 있도록 제한
- 예: `Integer`, `Double` 가능, `String` 불가

---

## 7. 와일드카드 (`?`)

와일드카드는 **불특정 타입**을 의미합니다.

### 1) `<?>` : Unbounded Wildcard
```java
public void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}
```

### 2) `<? extends T>` : Upper Bounded Wildcard
```java
public double sum(List<? extends Number> list) {
    double total = 0;
    for (Number n : list) {
        total += n.doubleValue();
    }
    return total;
}
```
- `Number`의 하위 클래스(`Integer`, `Double` 등)만 허용

### 3) `<? super T>` : Lower Bounded Wildcard
```java
public void addNumbers(List<? super Integer> list) {
    list.add(1); // Integer 하위 클래스 추가 가능
}
```
- `Integer`의 상위 클래스(`Number`, `Object` 등)만 허용

---

## 8. 제네릭 배열의 생성 불가

```java
T[] array = new T[10]; // 컴파일 오류!
```

- 자바는 타입 소거(Type Erasure)를 사용하기 때문에 컴파일 이후 `T` 정보가 사라져 배열을 만들 수 없습니다.
- 우회 방법:

```java
@SuppressWarnings("unchecked")
T[] array = (T[]) new Object[10];
```

---

## 9. 타입 소거 (Type Erasure)

자바는 **컴파일 시 제네릭 정보를 제거(Type Erasure)**합니다. 즉, 런타임에는 `List<T>`가 단순히 `List`로 동작합니다. 이 때문에 **런타임에는 제네릭 타입 정보를 사용할 수 없습니다.**

```java
List<String> list1 = new ArrayList<>();
List<Integer> list2 = new ArrayList<>();

System.out.println(list1.getClass() == list2.getClass()); // true
```

---

## 10. 제네릭과 상속

```java
List<Object> list = new ArrayList<String>(); // 컴파일 오류!
```

- 제네릭은 타입 간의 **상속 관계를 공유하지 않습니다.**
- `List<String>`은 `List<Object>`의 하위 타입이 아님
- 이럴 때는 **와일드카드**(`?`)를 사용해야 합니다.

---

## 결론

| 개념 | 요약 |
|------|------|
| 제네릭 클래스 | 타입을 매개변수로 갖는 클래스 |
| 제네릭 메서드 | 다양한 타입을 처리하는 메서드 |
| 와일드카드 | `?`, `<? extends T>`, `<? super T>` |
| 타입 제한 | `T extends Class`로 상한 제한 가능 |
| 타입 소거 | 런타임에는 제네릭 정보가 사라짐 |

제네릭은 자바에서 **타입 안정성**과 **재사용성**을 보장하기 위한 강력한 도구입니다. 코드를 더 안전하고 유연하게 만들기 위해 적극적으로 활용해야 합니다.