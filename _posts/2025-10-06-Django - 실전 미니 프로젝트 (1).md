---
layout: post
title: Django - 실전 미니 프로젝트 (1)
date: 2025-10-06 21:25:23 +0900
category: Django
---
# 12. 실전 미니 프로젝트 (1) — 커뮤니티 & 댓글  
> **목표**: Django 5.x로 “게시판(게시글) + 댓글”을 **기본 CRUD + 권한 + 캐시**까지 한 번에 구현합니다.  
> - 스택: Django 5.x, PostgreSQL, Redis(캐시), django-redis  
> - 기능: 게시글/댓글 CRUD, 로그인/권한, 좋아요, 페이징/검색, 스팸/악성 입력 방지, 캐시(per-view, per-object, low-level), 비동기 카운터(옵션)  
> - 모든 코드는 ``` 로 감싸며, 수학식은 없습니다.

---

## A. 모델 설계

### A-1. 요구사항 요약
- 게시글(Post): 제목, 본문, 작성자, 공개/비공개, 조회수, 댓글 수, 좋아요 수
- 댓글(Comment): 게시글 FK, 부모(대댓글 옵션), 본문, 작성자, 상태(정상/숨김/삭제)
- 좋아요(Like): 사용자-게시글 N:M(유니크)
- 감사/관리: 수정/삭제 감사 로그, soft-delete(옵션)
- 성능: 카운터 필드(denormalized), 인덱스 최적화

### A-2. 모델 코드

```python
# apps/community/models.py
from django.db import models
from django.conf import settings
from django.utils import timezone

class Post(models.Model):
    VISIBILITY = (("public","공개"),("private","비공개"))
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.PROTECT, related_name="posts")
    title = models.CharField(max_length=120, db_index=True)
    body = models.TextField()
    visibility = models.CharField(max_length=7, choices=VISIBILITY, default="public")
    view_count = models.PositiveIntegerField(default=0)
    comment_count = models.PositiveIntegerField(default=0)
    like_count = models.PositiveIntegerField(default=0)
    is_locked = models.BooleanField(default=False)  # 운영 잠금(수정/댓글 불가)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=["-created_at"]),
            models.Index(fields=["visibility","-created_at"]),
            models.Index(fields=["author","-created_at"]),
        ]

    def __str__(self):
        return f"[{self.pk}] {self.title}"

class Comment(models.Model):
    class Status(models.TextChoices):
        NORMAL = "normal","정상"
        HIDDEN = "hidden","숨김"
        DELETED = "deleted","삭제"
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name="comments")
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.PROTECT, related_name="comments")
    parent = models.ForeignKey("self", null=True, blank=True, on_delete=models.CASCADE, related_name="children")
    body = models.TextField(max_length=2000)
    status = models.CharField(max_length=10, choices=Status.choices, default=Status.NORMAL)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        indexes = [
            models.Index(fields=["post","-created_at"]),
            models.Index(fields=["author","-created_at"]),
        ]

class PostLike(models.Model):
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name="likes")
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="post_likes")
    created_at = models.DateTimeField(default=timezone.now)

    class Meta:
        unique_together = [("post","user")]
        indexes = [models.Index(fields=["user","-created_at"])]
```

> **설계 포인트**  
> - `comment_count`, `like_count`는 **쓰기 시 업데이트**하여 목록/상세에서 조인 없이 사용.  
> - 댓글은 `parent` 필드로 **2단 트리**(대댓글) 지원(필요 시 무제한 트리 라이브러리 사용 가능).  
> - `visibility`, `is_locked` 로 공개성/운영 잠금 제어.

---

## B. 폼 & 검증

```python
# apps/community/forms.py
from django import forms
from .models import Post, Comment

class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = ["title","body","visibility"]
        widgets = {
            "title": forms.TextInput(attrs={"maxlength":120,"placeholder":"제목"}),
            "body": forms.Textarea(attrs={"rows":10}),
        }

    def clean_title(self):
        t = self.cleaned_data["title"].strip()
        if len(t) < 2:
            raise forms.ValidationError("제목은 2자 이상")
        return t

class CommentForm(forms.ModelForm):
    class Meta:
        model = Comment
        fields = ["body","parent"]
        widgets = {"body": forms.Textarea(attrs={"rows":3,"maxlength":2000})}

    def clean_body(self):
        b = self.cleaned_data["body"].strip()
        if not b:
            raise forms.ValidationError("내용이 필요합니다.")
        # 간단한 금칙어 필터(실무: 전처리/스팸필터/욕설사전)
        if "http://" in b or "https://" in b:
            # 허용 전략 다르게 가능(링크 제한)
            pass
        return b
```

---

## C. 권한/접근 제어

### C-1. 규칙
- **읽기**: `public`은 모두, `private`은 작성자만(또는 그룹/팔로워 등 규칙 확장)
- **쓰기**: 로그인 사용자만
- **수정/삭제**: 작성자 또는 운영자(staff)
- **댓글**: `is_locked=False`인 게시글에서만 작성/수정/삭제 가능

### C-2. 헬퍼

```python
# apps/community/permissions.py
from django.http import Http404, HttpResponseForbidden

def can_view_post(request, post):
    if post.visibility == "public":
        return True
    return request.user.is_authenticated and request.user == post.author

def must_be_author_or_staff(request, obj):
    if request.user.is_superuser or request.user.is_staff:
        return True
    return request.user.is_authenticated and obj.author_id == request.user.id

def forbid_or_404(condition):
    if not condition:
        return HttpResponseForbidden("권한이 없습니다.")
    return None
```

---

## D. URL & 뷰 (CRUD)

### D-1. URL

```python
# apps/community/urls.py
from django.urls import path
from . import views

app_name = "community"
urlpatterns = [
    path("", views.PostListView.as_view(), name="post_list"),
    path("post/new/", views.PostCreateView.as_view(), name="post_create"),
    path("post/<int:pk>/", views.post_detail, name="post_detail"),
    path("post/<int:pk>/edit/", views.PostUpdateView.as_view(), name="post_edit"),
    path("post/<int:pk>/delete/", views.post_delete, name="post_delete"),

    path("post/<int:pk>/like/", views.post_like_toggle, name="post_like"),
    path("post/<int:pk>/comment/", views.comment_create, name="comment_create"),
    path("comment/<int:pk>/delete/", views.comment_delete, name="comment_delete"),
]
```

### D-2. 리스트/생성/수정 CBV + 상세 FBV (캐시를 쉽게 넣기 위해)

```python
# apps/community/views.py
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import ListView, CreateView, UpdateView
from django.shortcuts import render, get_object_or_404, redirect
from django.db.models import Q, F
from django.http import HttpResponseForbidden, JsonResponse
from django.urls import reverse_lazy
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page
from django.core.cache import cache
from .models import Post, Comment, PostLike
from .forms import PostForm, CommentForm
from .permissions import can_view_post, must_be_author_or_staff

# --- 리스트 (검색/정렬/페이징)
class PostListView(ListView):
    model = Post
    paginate_by = 20
    template_name = "community/post_list.html"

    def get_queryset(self):
        q = self.request.GET.get("q","").strip()
        qs = Post.objects.filter(visibility="public").order_by("-created_at")
        if q:
            qs = qs.filter(Q(title__icontains=q) | Q(body__icontains=q))
        return qs.select_related("author")

# --- 생성
class PostCreateView(LoginRequiredMixin, CreateView):
    form_class = PostForm
    template_name = "community/post_form.html"
    success_url = reverse_lazy("community:post_list")

    def form_valid(self, form):
        form.instance.author = self.request.user
        r = super().form_valid(form)
        # 상세 캐시 키 사전 무효화(목록은 페이지 캐시로 커버)
        cache.delete_pattern(f"post:detail:{self.object.pk}:*")
        return r

# --- 수정
class PostUpdateView(LoginRequiredMixin, UpdateView):
    form_class = PostForm
    template_name = "community/post_form.html"
    model = Post

    def dispatch(self, request, *args, **kwargs):
        self.object = self.get_object()
        if self.object.is_locked and not request.user.is_staff:
            return HttpResponseForbidden("운영 잠금된 글입니다.")
        if not must_be_author_or_staff(request, self.object):
            return HttpResponseForbidden("권한이 없습니다.")
        return super().dispatch(request, *args, **kwargs)

    def get_success_url(self):
        cache.delete_pattern(f"post:detail:{self.object.pk}:*")
        return reverse_lazy("community:post_detail", kwargs={"pk": self.object.pk})
```

### D-3. 상세 뷰 (per-view 캐시 + 조회수 안전 증가)

```python
# apps/community/views.py (계속)
from django.views.decorators.vary import vary_on_cookie
from django.db import transaction

def _post_detail_cache_key(pk, user_id=None, page=1):
    # 공개/비공개/좋아요 버튼 상태(로그인)로 변형 가능 → user_id 포함
    uid = user_id or 0
    return f"post:detail:{pk}:u{uid}:p{page}"

@vary_on_cookie  # 로그인/비로그인 Vary (쿠키 변경에 따라 캐시 분리)
@cache_page(60)  # 60초 페이지 캐시(Reverse proxy 앞단도 고려)
def post_detail(request, pk):
    post = get_object_or_404(Post.objects.select_related("author"), pk=pk)
    if not can_view_post(request, post):
        return HttpResponseForbidden("열람권한 없음")
    # 세션 기반 조회수 증가(유저별 중복 방지)
    key = f"post:viewed:{pk}:{request.session.session_key}"
    if not cache.get(key):
        with transaction.atomic():
            Post.objects.filter(pk=pk).update(view_count=F("view_count")+1)
        cache.set(key, True, 60*10)  # 10분 내 재방문 카운트 제외

    # 댓글 페이징(대댓글은 간단히 parent=None만 1차 노출)
    page = int(request.GET.get("page",1))
    per_page = 20
    comments_qs = (post.comments
                        .filter(status="normal", parent__isnull=True)
                        .select_related("author")
                        .order_by("-created_at"))
    total = comments_qs.count()
    start = (page-1)*per_page
    comments = list(comments_qs[start:start+per_page])

    # 각 댓글의 대댓글 미리 로드(옵션 최적화)
    child_map = {}
    for c in Comment.objects.filter(parent__in=[c.pk for c in comments], status="normal").select_related("author"):
        child_map.setdefault(c.parent_id, []).append(c)

    # 좋아요 여부
    liked = False
    if request.user.is_authenticated:
        liked = PostLike.objects.filter(post=post, user=request.user).exists()

    ctx = {
        "post": post,
        "comments": comments,
        "children": child_map,
        "liked": liked,
        "page": page, "total": total, "per_page": per_page
    }
    return render(request, "community/post_detail.html", ctx)
```

---

## E. 액션: 삭제/좋아요/댓글 작성·삭제

```python
# apps/community/views.py (계속)
from django.views.decorators.http import require_POST

@require_POST
def post_delete(request, pk):
    post = get_object_or_404(Post, pk=pk)
    if not must_be_author_or_staff(request, post):
        return HttpResponseForbidden("권한 없음")
    post.delete()
    cache.delete_pattern(f"post:detail:{pk}:*")
    return redirect("community:post_list")

@require_POST
def post_like_toggle(request, pk):
    if not request.user.is_authenticated:
        return HttpResponseForbidden("로그인이 필요합니다.")
    post = get_object_or_404(Post, pk=pk)
    obj, created = PostLike.objects.get_or_create(post=post, user=request.user)
    if not created:
        obj.delete()
        Post.objects.filter(pk=pk).update(like_count=F("like_count")-1)
        liked = False
    else:
        Post.objects.filter(pk=pk).update(like_count=F("like_count")+1)
        liked = True
    cache.delete_pattern(f"post:detail:{pk}:*")
    return JsonResponse({"liked": liked, "like_count": Post.objects.get(pk=pk).like_count})

@require_POST
def comment_create(request, pk):
    if not request.user.is_authenticated:
        return HttpResponseForbidden("로그인이 필요합니다.")
    post = get_object_or_404(Post, pk=pk)
    if post.is_locked and not request.user.is_staff:
        return HttpResponseForbidden("운영 잠금된 글입니다.")
    form = CommentForm(request.POST)
    if not form.is_valid():
        return JsonResponse({"ok": False, "errors": form.errors}, status=400)
    c = form.save(commit=False)
    c.author = request.user
    c.post = post
    c.save()
    Post.objects.filter(pk=pk).update(comment_count=F("comment_count")+1)
    cache.delete_pattern(f"post:detail:{pk}:*")
    return JsonResponse({"ok": True, "id": c.pk, "comment_count": Post.objects.get(pk=pk).comment_count})

@require_POST
def comment_delete(request, pk):
    c = get_object_or_404(Comment.objects.select_related("post"), pk=pk)
    if not must_be_author_or_staff(request, c):
        return HttpResponseForbidden("권한 없음")
    post_id = c.post_id
    c.status = Comment.Status.DELETED
    c.save(update_fields=["status"])
    Post.objects.filter(pk=post_id).update(comment_count=F("comment_count")-1)
    cache.delete_pattern(f"post:detail:{post_id}:*")
    return JsonResponse({"ok": True, "comment_count": Post.objects.get(pk=post_id).comment_count})
```

> **주의**  
> - 댓글 삭제는 **소프트 삭제**(`status=deleted`)로 처리 → 복구/감사 가능.  
> - 좋아요는 **토글** 방식으로 멱등에 신경.

---

## F. 템플릿(요약)

```html
{# templates/community/post_list.html #}
{% extends "base.html" %}
{% block content %}
<h1>게시글</h1>
<form method="get"><input type="search" name="q" value="{{ request.GET.q }}"><button>검색</button></form>
<a href="{% url 'community:post_create' %}">새 글</a>
<ul>
{% for p in object_list %}
  <li>
    <a href="{% url 'community:post_detail' p.pk %}">{{ p.title }}</a>
    <small>by {{ p.author }} | {{ p.created_at|date:"Y-m-d H:i" }} | 💬 {{ p.comment_count }} | ❤️ {{ p.like_count }}</small>
  </li>
{% empty %}
  <li>글이 없습니다.</li>
{% endfor %}
</ul>
{% include "partials/pagination.html" %}
{% endblock %}
```

```html
{# templates/community/post_detail.html #}
{% extends "base.html" %}
{% block content %}
<h2>{{ post.title }}</h2>
<p>by {{ post.author }} | 조회수 {{ post.view_count }} | ❤️ {{ post.like_count }}</p>
<div class="post-body">{{ post.body|linebreaksbr }}</div>

{% if request.user.is_authenticated %}
  <button id="like-btn" data-liked="{{ liked|yesno:'1,0' }}">❤️ {{ post.like_count }}</button>
  {% if request.user == post.author or request.user.is_staff %}
    <a href="{% url 'community:post_edit' post.pk %}">수정</a>
    <form action="{% url 'community:post_delete' post.pk %}" method="post" style="display:inline">{% csrf_token %}<button>삭제</button></form>
  {% endif %}
{% endif %}

<hr>
<h3>댓글 ({{ post.comment_count }})</h3>
{% if request.user.is_authenticated and not post.is_locked %}
<form id="comment-form">{% csrf_token %}
  <textarea name="body" rows="3" maxlength="2000"></textarea>
  <input type="hidden" name="parent" value="">
  <button>등록</button>
</form>
{% elif post.is_locked %}
<p>이 글은 잠금되어 댓글을 달 수 없습니다.</p>
{% else %}
<p>댓글을 달려면 로그인하세요.</p>
{% endif %}

<ul id="comment-list">
{% for c in comments %}
  <li data-id="{{ c.pk }}">
    <b>{{ c.author }}</b> {{ c.body|linebreaksbr }} <small>{{ c.created_at|date:"Y-m-d H:i" }}</small>
    {% if request.user == c.author or request.user.is_staff %}
      <button class="comment-del" data-id="{{ c.pk }}">삭제</button>
    {% endif %}
    {% if children.c.pk %}
      <ul>
      {% for ch in children.c.pk %}
        <li><b>{{ ch.author }}</b> {{ ch.body|linebreaksbr }}</li>
      {% endfor %}
      </ul>
    {% endif %}
  </li>
{% endfor %}
</ul>

<script>
document.getElementById("like-btn")?.addEventListener("click", async (e)=>{
  const res = await fetch("{% url 'community:post_like' post.pk %}", {method:"POST", headers:{"X-CSRFToken":"{{ csrf_token }}"}});
  const j = await res.json(); if(j.liked!==undefined){ e.target.textContent = "❤️ "+j.like_count; }
});
document.getElementById("comment-form")?.addEventListener("submit", async (e)=>{
  e.preventDefault();
  const fd = new FormData(e.target);
  const res = await fetch("{% url 'community:comment_create' post.pk %}", {method:"POST", headers:{"X-CSRFToken":"{{ csrf_token }}"}, body:fd});
  const j = await res.json();
  if(j.ok){ location.reload(); } else { alert("오류:"+JSON.stringify(j.errors)); }
});
document.querySelectorAll(".comment-del").forEach(btn=>{
  btn.addEventListener("click", async ()=>{
    const id = btn.dataset.id;
    const res = await fetch("{% url 'community:comment_delete' 0 %}".replace("0", id), {method:"POST", headers:{"X-CSRFToken":"{{ csrf_token }}"}})
    const j = await res.json(); if(j.ok){ location.reload(); }
  })
});
</script>
{% endblock %}
```

> 템플릿은 핵심만 예시. 실무에선 HTMX/Alpine.js/React 등으로 부분 업데이트 UX 개선 권장.

---

## G. 캐시 설계

### G-1. 레이어
1) **per-view 캐시**: `@cache_page` (상세/목록)  
2) **템플릿 프래그먼트 캐시**: 예: 댓글 블록  
3) **Low-level 캐시**: 조회수 중복 방지키, 비싼 쿼리 결과 메모

### G-2. 설정 (django-redis)

```python
# settings.py
CACHES = {
  "default": {
    "BACKEND": "django_redis.cache.RedisCache",
    "LOCATION": "redis://localhost:6379/1",
    "OPTIONS": {"CLIENT_CLASS": "django_redis.client.DefaultClient"}
  }
}
CACHE_MIDDLEWARE_SECONDS = 30
```

### G-3. 캐시 키 전략
- `post:detail:{pk}:u{uid}:p{page}` — 사용자/페이지 구분  
- 무효화: **쓰기 후 특정 키 패턴 삭제**(`delete_pattern`)  
- 높은 갱신 빈도 데이터(좋아요 수 등)는 **짧은 TTL** 또는 **실시간 반영 + 프래그먼트 캐시** 혼용

### G-4. 목록 캐시(per-view)
```python
# 목록도 간단히 적용 가능
@method_decorator(cache_page(30), name="dispatch")
class PostListView(ListView):
    ...
```

> 검색 파라미터가 많을수록 캐시 파편화 → 상위 인기 목록만 캐시, 검색은 생쿼리/ES로.

---

## H. 스팸/악성 입력 방지 & 레이트 리밋

### H-1. 간단한 레이트 리밋 (캐시 카운터)

```python
# apps/community/ratelimit.py
from django.core.cache import cache
from django.http import HttpResponseForbidden

def rate_limit(key: str, limit: int, ttl: int = 60):
    cnt = cache.get(key) or 0
    if cnt >= limit:
        return False
    cache.incr(key) if cache.get(key) else cache.set(key, 1, ttl)
    return True

# views.py (댓글 작성 시)
@require_POST
def comment_create(request, pk):
    if not rate_limit(f"rl:cmt:{request.user.id}", limit=10, ttl=60):
        return HttpResponseForbidden("잠시 후 다시 시도하세요.")
    ...
```

### H-2. XSS/스크립트 필터
- Django 템플릿 자동 이스케이프 기본 사용  
- 링크 허용 시 **bleach** 같은 화이트리스트 필터로 sanitize 권장

---

## I. 어드민/운영

```python
# apps/community/admin.py
from django.contrib import admin
from .models import Post, Comment, PostLike

@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    list_display = ("id","title","author","visibility","view_count","comment_count","like_count","created_at","is_locked")
    list_filter = ("visibility","is_locked","created_at")
    search_fields = ("title","body","author__username")
    list_select_related = ("author",)

@admin.register(Comment)
class CommentAdmin(admin.ModelAdmin):
    list_display = ("id","post","author","status","created_at")
    list_filter = ("status","created_at")
    search_fields = ("body","author__username","post__title")
    list_select_related = ("post","author")

@admin.register(PostLike)
class PostLikeAdmin(admin.ModelAdmin):
    list_display = ("id","post","user","created_at")
    list_select_related = ("post","user")
```

> 운영 잠금(`is_locked`)은 Admin에서 토글하여 **댓글/수정 차단**.

---

## J. 테스트(핵심 흐름)

```python
# apps/community/tests/test_post_comment.py
import pytest
from django.urls import reverse
from django.contrib.auth import get_user_model
from apps.community.models import Post, Comment

pytestmark = pytest.mark.django_db
User = get_user_model()

def test_post_crud(client):
    u = User.objects.create_user("u","u@x.com","pw")
    client.force_login(u)
    # create
    res = client.post(reverse("community:post_create"), {"title":"hi","body":"hello","visibility":"public"})
    assert res.status_code in (302, 200)
    p = Post.objects.get(title="hi")
    # detail
    res = client.get(reverse("community:post_detail", args=[p.pk]))
    assert res.status_code == 200
    # edit
    res = client.post(reverse("community:post_edit", args=[p.pk]), {"title":"hi2","body":"x","visibility":"public"})
    assert res.status_code in (302, 200)
    p.refresh_from_db(); assert p.title == "hi2"

def test_comment_and_like(client):
    u = User.objects.create_user("u","u@x.com","pw")
    client.force_login(u)
    p = Post.objects.create(author=u, title="t", body="b")
    # like toggle
    res = client.post(reverse("community:post_like", args=[p.pk]))
    assert res.status_code == 200
    p.refresh_from_db(); assert p.like_count == 1
    # comment
    res = client.post(reverse("community:comment_create", args=[p.pk]), {"body":"c"})
    assert res.status_code == 200
    p.refresh_from_db(); assert p.comment_count == 1
    c = Comment.objects.get(post=p)
    # delete
    res = client.post(reverse("community:comment_delete", args=[c.pk]))
    assert res.status_code == 200
    p.refresh_from_db(); assert p.comment_count == 0
```

---

## K. 성능 & 확장 팁

1) **N+1 방지**: `select_related("author")`, 댓글 대댓글은 미리 한 번에 로드  
2) **카운터 정확도**: 멀티 인스턴스에서 경합 시 **F 표현식** 사용(이미 반영)  
3) **조회수**: 완벽한 고유 카운트 대신 **세션+TTL** 근사(실무 충분)  
4) **검색**: 본문/제목 검색 빈도 높으면 **ES 읽기 모델**로 이관(앞 챕터 참고)  
5) **CDN/캐시**: 상세 페이지는 CDN 에지 캐시 TTL 짧게 + 사용자별 요소(Ajax)로 나눠서 동적화  
6) **비동기화(옵션)**: 댓글/좋아요 후 **실시간 카운트**는 Celery로 지연 반영도 가능(유저 응답은 즉시)

---

## L. 보안 체크리스트

- [ ] CSRF 적용(POST 전부)  
- [ ] 권한 검사: 수정/삭제/비공개 열람  
- [ ] 템플릿 자동 이스케이프, 허용 태그만 sanitize  
- [ ] 업로드(만약 추가 시) MIME/확장자 검증 + 바이러스 스캔  
- [ ] 레이트 리밋/봇 방지(캡차, reCAPTCHA v3 등)  
- [ ] 감사 로그(운영자 삭제/숨김 기록) 필요 시 미들웨어 추가

---

## M. 배포 체크리스트(요약)

- [ ] `django-redis` 연결 OK, 캐시 키 TTL/메모 확인  
- [ ] DB 인덱스: `Post.created_at`, `visibility`, `author`  
- [ ] 헬스체크/로깅: 5xx, 응답시간, DB 커넥션, Redis 연결  
- [ ] 정적/미디어: CDN or Nginx에서 처리  
- [ ] 백업: DB dump, 마이그레이션 롤백 스크립트

---

## N. 확장 과제(다음 단계)

- **신고(Report)**/블록/필터링 워크플로우  
- **모더레이션 큐** + 규칙 엔진(욕설/스팸)  
- **알림**: 댓글/멘션/좋아요 이벤트(Email/WebPush/WebSocket)  
- **태그/카테고리** + 트렌딩(캐시/배치)  
- **모바일 친화 UI**(HTMX/Alpine/React)

---

## O. 요약

- 본 미니 프로젝트는 **게시글·댓글 CRUD**에 **권한**과 **캐시 전략**을 더해 **현실적인 운영 기준**을 갖춘 커뮤니티의 골격입니다.  
- **per-view + low-level 캐시**, **F-표현식 카운터**, **권한/잠금/레이트리밋**을 표준 패턴으로 적용하면 작은 규모에서도 **빠르고 안전**합니다.  
- 검색/알림/모더레이션 등은 **CQRS/Outbox/ES/사가**로 점진 확장 가능합니다.
