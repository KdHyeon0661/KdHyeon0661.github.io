---
layout: post
title: 객체지향설계 - 도메인 주도 설계(DDD)
date: 2025-07-25 18:20:23 +0900
category: 객체지향설계
---
# 도메인 주도 설계(DDD, Domain-Driven Design) 간단 소개

도메인 주도 설계(DDD)는 **소프트웨어 설계와 개발을 비즈니스 도메인에 맞춰 진행하는 방법론**입니다.  
에릭 에반스(Eric Evans)가 그의 저서 *Domain-Driven Design: Tackling Complexity in the Heart of Software*에서 제시한 접근법으로, 복잡한 비즈니스 로직이 포함된 애플리케이션을 **도메인 전문가와 개발자가 공통 언어로 모델링**하여, 변경과 확장이 용이한 구조를 만들도록 합니다.

---

## 1. DDD가 필요한 이유
- **복잡한 도메인 로직**이 소프트웨어의 핵심일 때, 단순 CRUD 중심 개발은 변경에 취약합니다.
- 개발자와 비즈니스 담당자가 서로 다른 언어를 쓰면 요구사항 해석이 엇나가 버그나 재작업이 발생합니다.
- 비즈니스 규칙이 코드 전반에 산재하면 **유지보수**와 **확장성**이 떨어집니다.

DDD는 이를 해결하기 위해 **도메인 모델**을 중심에 두고 설계합니다.

---

## 2. 주요 개념

### 2.1 도메인(Domain)
- 시스템이 해결하고자 하는 **문제 영역**.
- 예: 은행 시스템에서는 *계좌, 고객, 거래* 등이 도메인.

### 2.2 서브도메인(Subdomain)
- 도메인을 **역할별로 구분**한 하위 영역.
- 예: 은행 시스템의 *대출 도메인*, *결제 도메인*, *고객 관리 도메인*.

### 2.3 유비쿼터스 언어(Ubiquitous Language)
- 개발자와 비즈니스 전문가가 **공통으로 사용하는 용어 체계**.
- 예: "계좌 개설"을 코드에서도 `openAccount()`로 그대로 표현.

### 2.4 바운디드 컨텍스트(Bounded Context)
- **특정 모델이 적용되는 경계**.
- 한 바운디드 컨텍스트 내에서는 용어와 모델의 의미가 일관되지만, 다른 컨텍스트에서는 같은 용어도 다른 의미를 가질 수 있음.
- 예: "고객"이 *마케팅 컨텍스트*에서는 잠재 고객을 의미할 수 있고, *결제 컨텍스트*에서는 결제 가능한 등록 고객만 의미할 수 있음.

---

## 3. DDD의 기본 구성 요소

### 3.1 엔티티(Entity)
- 고유 식별자를 가지며, 속성이 변해도 동일성을 유지하는 객체.
- 예: 은행 `Account` (계좌 번호로 식별)

```java
public class Account {
    private String accountNumber; // 식별자
    private Money balance;

    public void deposit(Money amount) { ... }
    public void withdraw(Money amount) { ... }
}
```

---

### 3.2 값 객체(Value Object)
- 식별자가 없고, **속성 값이 동일하면 동일 객체로 간주**되는 불변 객체.
- 예: `Money`, `Address`.

```java
public record Money(BigDecimal amount, Currency currency) { }
```

---

### 3.3 애그리게이트(Aggregate)와 애그리게이트 루트(Aggregate Root)
- **관련 객체(엔티티+값 객체)**를 하나로 묶은 집합.
- 애그리게이트 루트는 외부에서 접근 가능한 유일한 진입점.
- 예: `Order`(루트)와 그 안의 `OrderItem`.

---

### 3.4 리포지토리(Repository)
- 엔티티 집합을 저장소처럼 다루는 인터페이스.
- 예: `AccountRepository` → `findById()`, `save()` 제공.

---

### 3.5 서비스(Service)
- 도메인 객체에 속하지 않는 **비즈니스 로직**을 구현하는 객체.
- 상태보다 동작 중심.

---

## 4. DDD의 적용 절차 (간단 흐름)
1. **도메인 전문가와 협업**하여 유비쿼터스 언어를 정의.
2. 도메인 모델(엔티티, 값 객체, 애그리게이트) 설계.
3. 바운디드 컨텍스트를 구분하고, 컨텍스트 간 통신 방식 설계.
4. 리포지토리와 서비스 계층을 구현.
5. 지속적으로 모델을 리팩토링하여 도메인 지식을 반영.

---

## 5. 장점
- 비즈니스 변화에 빠르게 대응 가능.
- 코드와 도메인 지식의 **정합성** 유지.
- 모듈화와 경계 설정을 통해 대규모 시스템에서도 유지보수 용이.

---

## 6. 단점
- 초기 설계 및 학습 비용이 높음.
- 작은 프로젝트에서는 과도한 설계가 될 수 있음.

---

## 7. 마무리
DDD는 모든 프로젝트에 무조건 필요한 것은 아니지만, **복잡한 비즈니스 로직을 장기적으로 관리**해야 하는 대규모 시스템에서는 강력한 설계 도구입니다.  
핵심은 **코드가 비즈니스를 표현하게 만드는 것**이며, 이를 위해 개발자와 도메인 전문가 간의 긴밀한 협력이 필수입니다.
