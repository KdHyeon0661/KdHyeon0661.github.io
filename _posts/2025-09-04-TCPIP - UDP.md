---
layout: post
title: TCPIP - UDP
date: 2025-09-04 15:25:23 +0900
category: TCPIP
---
# TCP/IP 사용자 데이터그램 프로토콜 (UDP)

## UDP 개요, 역사 및 표준

사용자 데이터그램 프로토콜(UDP)은 TCP/IP 프로토콜 스택에서 가장 단순하면서도 필수적인 전송 계층 프로토콜입니다. 1980년 RFC 768로 표준화된 UDP는 신뢰성보다 속도와 효율성을 우선시하는 "경량" 프로토콜로 설계되었습니다.

### UDP의 설계 철학

TCP와의 근본적인 대비를 통해 UDP의 특성을 이해할 수 있습니다:

```
TCP (전화 통화 모델)          UDP (편지 모델)
- 연결 지향적                   - 비연결지향적
- 신뢰성 보장 (재전송)          - 베스트 에포트 전달
- 순서 보장                     - 순서 무보장
- 흐름 제어                    - 흐름 제어 없음
- 혼잡 제어                    - 혼잡 제어 없음
- 오버헤드 큼                   - 오버헤드 최소화
```

**UDP의 역사적 의미:**
- 1980년 초기 인터넷 표준의 일부로 채택
- TCP와 함께 TCP/IP의 "T"와 "U"를 형성
- 원래의 "Datagram Protocol" 개념을 계승
- 오늘날까지 변함없는 단순성 유지

## UDP 동작 방식

### 비연결 통신 모델

UDP는 세션 설정이나 종료 과정 없이 즉시 데이터를 전송합니다. 이는 "발사 후 망각(fire-and-forget)" 방식으로 작동합니다:

```
송신 애플리케이션 → [UDP 데이터그램] → 수신 애플리케이션
(세션 설정 없음)  (단일 패킷)       (바로 처리)
```

**UDP 통신의 특징적 흐름:**
1. **송신 측**: 애플리케이션이 데이터와 목적지 주소/포트를 UDP에 제공
2. **전송**: UDP가 헤더를 추가하고 IP 계층으로 전달
3. **수신 측**: 도착한 데이터그램을 해당 포트의 애플리케이션에 직접 전달
4. **종료**: 별도의 연결 종료 과정 없음

### 다중화와 역다중화

UDP의 포트 번호 체계는 단일 IP 주소에서 여러 애플리케이션이 동시에 통신할 수 있게 합니다:

```
IP 주소: 192.168.1.100
┌─────────────────────────────────────┐
│ 포트 53: DNS 서버  │ 포트 123: NTP 클라이언트 │
│ 포트 67: DHCP 서버 │ 포트 161: SNMP 에이전트 │
└─────────────────────────────────────┘
        ↓               ↓
수신 데이터그램을 적절한 애플리케이션으로 전달
```

**역다중화 과정:**
```
수신된 UDP 데이터그램:
[출발지 IP:포트] [목적지 IP:포트] [데이터]

UDP가 목적지 포트 번호 확인 → 해당 애플리케이션으로 전달
```

### 체크섬 기반 오류 검출

UDP는 선택적 체크섬을 통해 데이터 무결성을 기본적으로 검사합니다:

```
체크섬 계산 범위:
┌─────────────────────────────────────────┐
│ 의사 헤더 │ UDP 헤더 │      데이터        │
└─────────────────────────────────────────┘
(IP 주소, 프로토콜 번호, 길이 정보 포함)

* IPv6에서는 체크섬이 필수 사항
```

**체크섬 오류 처리:**
- 수신 측에서 체크섬 오류 감지 시 패킷 자동 폐기
- 오류 통보나 재전송 요청 없음 (신뢰성 책임 상위 계층에 위임)
- 애플리케이션 수준에서 오류 감지 및 복구 필요

## UDP 메시지 형식

UDP의 단순함은 그 메시지 형식에서 명확히 드러납니다. 고작 8바이트의 헤더만으로 필요한 모든 기능을 제공합니다.

### UDP 헤더 구조

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          출발지 포트 번호      |        목적지 포트 번호       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            데이터그램 길이      |            체크섬            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          데이터 (가변 길이)                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 각 필드의 상세 설명

#### 1. 출발지 포트 번호 (Source Port, 16비트)
- 송신 애플리케이션을 식별
- 범위: 0-65535 (0은 사용하지 않음)
- 응답을 기대할 때 필요 (클라이언트 측 임시 포트)
- 선택적 필드 (0으로 설정 가능)

#### 2. 목적지 포트 번호 (Destination Port, 16비트)
- 수신 애플리케이션 식별
- 서버 애플리케이션은 잘 알려진 포트 사용
- 역다중화의 핵심 키

#### 3. 데이터그램 길이 (Length, 16비트)
- UDP 헤더와 데이터를 포함한 총 길이 (바이트 단위)
- 최소값: 8 (헤더만 있는 경우)
- 최대값: 65535 (UDP 이론적 최대)
- 실제 제한: IP MTU - IP 헤더(20) - UDP 헤더(8) = 1500 - 28 = 1472바이트

#### 4. 체크섬 (Checksum, 16비트)
- 헤더와 데이터의 오류 검출을 위한 1의 보수 합
- IPv4: 선택적 (0은 체크섬 무시를 의미)
- IPv6: 필수 (0이어도 계산됨)
- 의사 헤더 포함 계산: 송신/수신 IP, 프로토콜, 길이

### 실제 데이터그램 예시

**DNS 쿼리 패킷 분석:**
```
UDP 헤더:
출발지 포트: 54321 (클라이언트 임시 포트)
목적지 포트: 53     (DNS 서버)
길이: 56 바이트     (헤더 8 + 데이터 48)
체크섬: 0x3A7B      (계산된 값)

데이터: DNS 질의 메시지 (www.example.com 조회)
```

### IPv4와 IPv6에서의 차이점

```
IPv4 환경:
- 체크섬 선택적 (성능 최적화 시 0 사용 가능)
- 단편화 가능 (IP 계층에서 처리)
- 최대 크기: 65507바이트 (65535 - IP헤더20 - UDP헤더8)

IPv6 환경:
- 체크섬 필수 (IPv6 헤더에 체크섬 없음)
- Jumbogram 지원 가능 (대용량 패킷)
- 단편화: 출발지에서만 (IPv6 Path MTU Discovery)
```

## UDP 일반 애플리케이션 및 서버 포트 할당

UDP는 실시간성, 단순성, 효율성이 중요한 다양한 애플리케이션에서 선호되는 프로토콜입니다.

### 주요 UDP 기반 프로토콜 및 서비스

#### 1. 도메인 이름 시스템 (DNS) - 포트 53
```
동작 방식:
클라이언트 → [UDP: 포트 53] 질의 → DNS 서버
클라이언트 ← [응답] ← DNS 서버

특징:
- 단일 질의-응답 패턴에 이상적
- TCP 폴백: 512바이트 초과 시 TCP 전환
- EDNS0 확장으로 대용량 응답 지원 가능
```

#### 2. 동적 호스트 설정 프로토콜 (DHCP) - 포트 67/68
```
4단계 프로세스 (모두 UDP):
1. DISCOVER (클라이언트 → 브로드캐스트)
2. OFFER    (서버 → 클라이언트)
3. REQUEST  (클라이언트 → 브로드캐스트)  
4. ACK      (서버 → 클라이언트)

특징:
- 브로드캐스트/유니캐스트 혼합 사용
- 신뢰성: 타임아웃과 재시도로 구현
```

#### 3. 네트워크 시간 프로토콜 (NTP) - 포트 123
```
시간 동기화:
클라이언트 → [타임스탬프 T1] → 서버
클라이언트 ← [T2, T3] ← 서버
클라이언트 ← [T4] 기록 → 왕복 지연 계산

정밀도: UDP의 낮은 지연이 초고정밀 동기화에 적합
```

#### 4. 실시간 멀티미디어 (RTP/RTCP)
```
음성/영상 스트리밍:
RTP: 실제 미디어 데이터 전송
RTCP: 품질 피드백 및 동기화

특징:
- 지연 민감성: 재전송보다 실시간 전달이 중요
- 손실 허용: 인간 지각이 일부 손실 감지 불가
```

#### 5. 단순 네트워크 관리 프로토콜 (SNMP) - 포트 161/162
```
관리 프레임워크:
Manager ←→ [UDP 161: 요청/응답] ←→ Agent
Manager ←── [UDP 162: Trap] ←────── Agent

특징:
- 경량 폴링에 효율적
- Trap: 비동기 이벤트 알림
```

### 잘 알려진 포트 할당 (0-1023)

**주요 UDP 서비스 포트:**

| 포트 | 서비스 | 설명 |
|------|--------|------|
| 7    | Echo   | 데이터 회신 (테스트용) |
| 53   | DNS    | 도메인 이름 시스템 |
| 67   | DHCP 서버 | 주소 할당 |
| 68   | DHCP 클라이언트 | 주소 요청 |
| 69   | TFTP   | 간이 파일 전송 |
| 123  | NTP    | 네트워크 시간 동기화 |
| 161  | SNMP   | 네트워크 관리 |
| 162  | SNMP Trap | 관리 이벤트 |
| 514  | Syslog | 시스템 로깅 |
| 520  | RIP    | 라우팅 정보 프로토콜 |
| 1900 | SSDP   | UPnP 장치 발견 |

### UDP의 현대적 활용 확장

#### 1. QUIC 프로토콜 (UDP 기반)
```
HTTP/3의 전송 계층:
UDP + TLS 1.3 + 혼잡 제어 + 다중화

장점:
- 연결 설정 지연 감소 (0-RTT)
- 헤드 오브 라인 블로킩 제거
- 네트워크 변경에 강건 (연결 마이그레이션)
```

#### 2. WebRTC 데이터 채널
```
브라우저 간 P2P 통신:
UDP 기반 SCTP-like 프로토콜

특징:
- 낮은 지연 메시징
- 신뢰성 모드 선택 가능 (순서 보장/무순서)
- 혼잡 제어 내장
```

#### 3. DNS over HTTPS/TLS
```
보안 DNS의 패러독스:
기본 전송은 UDP but 보안은 TCP 기반 프로토콜

해결책:
- DNS over TLS (TCP 853)
- DNS over HTTPS (TCP 443)
- DNSSEC (UDP지만 서명 검증)
```

### UDP 애플리케이션 설계 패턴

#### 패턴 1: 요청-응답 모델
```
클라이언트: 보내기 → 타임아웃 대기 → 재시도
서버: 수신 → 처리 → 응답

최적화: 트랜잭션 ID로 요청-응답 매칭
```

#### 패턴 2: 스트리밍 모델
```
송신자: 연속적인 데이터그램 전송
수신자: 버퍼링 → 재생

손실 처리: FEC(순방향 오류 정정) 또는 인터폴레이션
```

#### 패턴 3: 멀티캐스트 모델
```
송신자: 하나의 데이터그램 → 여러 수신자
수신자: 그룹 가입 → 데이터 수신

응용: 주식 시세, 미디어 배포, 서비스 발견
```

## 결론

UDP는 TCP/IP 프로토콜 스택에서 "단순함의 미학"을 구현한 프로토콜로, 40년이 넘는 시간 동안 변함없는 디자인 원칙을 유지해 왔습니다. 신뢰성, 순서 보장, 흐름 제어 같은 복잡한 메커니즘을 의도적으로 배제함으로써, UDP는 최소한의 오버헤드로 최대의 효율성을 제공하는 전송 계층의 대안을 제시합니다.

UDP의 진정한 힘은 그 유연성에 있습니다. 애플리케이션 개발자에게 전송 계층의 제약을 최소화하면서도, 필요한 경우 애플리케이션 수준에서 맞춤형 신뢰성 메커니즘을 구현할 수 있는 자유를 부여합니다. 이러한 디자인 철학은 오디오/비디오 스트리밍, 실시간 게임, DNS 조회 등 지연에 민감하거나 경량 통신이 필요한 분야에서 빛을 발합니다.

현대 인터넷에서 UDP의 역할은 더욱 확대되고 있습니다. QUIC 프로토콜은 UDP를 기반으로 하면서도 TCP의 장점을 통합한 혁신적인 접근법을 보여주며, WebRTC는 브라우저 기반 실시간 통신의 새로운 표준을 제시합니다. 이러한 발전은 UDP가 단순한 "신뢰성 없는 프로토콜"이 아니라, 현대 네트워크 요구사항에 맞춰 진화할 수 있는 유연한 플랫폼임을 입증합니다.

그러나 UDP의 단순성은 양날의 검입니다. DDoS 공격에 취약하며, 포트 스캐닝과 같은 보안 위협에 노출되어 있습니다. 또한 혼잡 제어 메커니즘이 없어 네트워크 정체를 악화시킬 수 있다는 점에서, 대규모 배포 시 신중한 설계가 필요합니다.

네트워크 엔지니어와 애플리케이션 개발자에게 UDP는 중요한 도구 선택의 기로입니다. TCP의 안정성과 UDP의 효율성 사이에서의 선택은 애플리케이션의 요구사항, 네트워크 환경, 사용자 경험 목표를 종합적으로 고려해야 하는 전략적 결정입니다. UDP를 효과적으로 활용하기 위해서는 패킷 손실, 지연 변동, 재전송 정책과 같은 네트워크 현실을 깊이 이해해야 합니다.

UDP의 지속적 관련성은 인터넷이 단일 프로토콜에 의존하지 않는 다양성과 복원력을 상징합니다. 단순함 속에 담긴 이 프로토콜의 지혜는, 기술적 복잡성이 증가하는 디지털 시대에 여전히 소중한 교훈을 전해줍니다: 때로는 덜 완벽한 것이 더 효과적일 수 있다는 사실을.