---
layout: post
title: MFC - 설정 관리
date: 2025-09-01 22:25:23 +0900
category: MFC
---
# 설정 관리: JSON/XML 기반 설정 파일, 버전 마이그레이션 (MFC/Win32 C++ 실전 총정리 + 코드 예제 다수)

이 글은 Windows C++(MFC/Win32) 애플리케이션에서 **설정(Configuration)** 을
- **JSON/XML 파일**로 관리하는 표준 패턴,
- **버전 필드 기반 마이그레이션(업/다운그레이드 대비)**,
- **안전 저장(atomic save)**, **검증/기본값/레이어 병합**, **민감 정보 암호화(DPAPI)**,
- **파일 변경 감시(핫 리로드)**, **스레드 안전성**,

까지 **생략 없이** 정리합니다.  
모든 코드는 ``` 로 감싸며 **즉시 붙여넣어** 참고 가능한 수준으로 제공합니다.

> 환경: Windows 10/11, x64, Unicode.  
> 라이브러리: 예제에서는 **nlohmann/json**(단일 헤더)·**RapidJSON**·**tinyxml2** 중 선택을 보여줍니다. (실무에서 하나만 골라 정착하세요)

---

## 0) 한눈에 보는 설계 원칙

1) **레이어드 구성(merging)**  
   - **기본값(defaults)** → **머신 전역(ProgramData)** → **사용자(앱데이터)** → **환경변수** → **명령줄** 순으로 오버레이.  
   - 각 레이어는 **불변/가변** 성격을 구분(기본값/정책=읽기 전용, 사용자=읽기/쓰기).

2) **스키마 버전 관리**  
   - 설정 루트에 `"configVersion": N`(정수) 또는 `"schemaVersion": "1.2.0"`(semver)을 **반드시** 둡니다.  
   - 앱 시작 시 **현재 버전으로 자동 마이그레이션**. 실패하면 **백업 + 롤백**.

3) **안전 저장(Atomic Save)**  
   - 같은 디렉터리의 임시 파일(`settings.json.tmp`)에 먼저 저장 → `ReplaceFileW`로 **원자 교체**.  
   - 실패 시 `.bak` 보존.

4) **검증(Validation) + 기본값 채움(Defaulting)**  
   - 필수 필드 누락/형식 오류 → 기본값 보정 + 사용자에 알림(로그/토스트).  
   - JSON Schema를 쓰면 좋지만, 경량 검증기도 충분(아래 제공).

5) **민감 정보 분리/암호화**  
   - 액세스 토큰/암호는 별도 섹션(`"secrets"`) + **DPAPI**로 암호화 후 기록.

6) **핫 리로드(Hot Reload)**  
   - `ReadDirectoryChangesW`로 변경 감시 → 파싱/검증 → UI/서비스에 **구독 브로드캐스트**.

7) **스레드 안전**  
   - 읽기는 lock-free(원자적 포인터 스왑), 쓰기는 mutex 보호.  
   - 구독자 콜백은 **UI 스레드에 PostMessage**.

---

## 1) 파일 위치/포맷/이름 규칙

### 1-1. 권장 경로 레이아웃
```
%PROGRAMDATA%\Vendor\App\policy.json           // 머신 전역(읽기 전용 정책, IT 배포)
%APPDATA%\Vendor\App\config\settings.json      // 사용자 설정(읽기/쓰기)
%APPDATA%\Vendor\App\config\secrets.json       // 민감 설정(DPAPI 암호화)
%LOCALAPPDATA%\Vendor\App\cache\...            // 캐시/임시/로그
```

### 1-2. 포맷 선택 가이드
- **JSON**: 읽기/쓰기/병합 용이, 주 포맷 추천.
- **XML**: 기존 자산 호환·계층 구조 명시성 선호 시.
- 혼용 시 규칙: **핵심 설정(JSON)** + **호환/연동(XML)**.

### 1-3. 인코딩
- **UTF-8 (BOM 유/무)** 권장. Windows API는 UTF-16이 기본이므로 변환 헬퍼를 둡니다.

---

## 2) JSON 설정: 기본 클래스 설계(단일 헤더 nlohmann/json 사용)

> 설치: `#include <nlohmann/json.hpp>` (https://github.com/nlohmann/json), `-DNOMINMAX` 권장

### 2-1. 데이터 모델(예시)

```cpp
// ConfigModel.h
#pragma once
#include <string>
#include <vector>
#include <optional>

struct Proxy {
    bool enabled = false;
    std::wstring host;
    int port = 0;
};

struct UiTheme {
    std::wstring mode = L"system"; // "light" / "dark" / "system"
    double scale = 1.0;            // UI 스케일
};

struct Account {
    std::wstring name;
    std::wstring endpoint; // URL
    bool enabled = true;
};

struct Settings {
    int configVersion = 3;               // 스키마 버전
    UiTheme ui;
    Proxy proxy;
    std::vector<Account> accounts;
    std::wstring logLevel = L"info";     // "trace","debug","info","warn","error"
};
```

### 2-2. JSON 직렬화/역직렬화 어댑터

```cpp
// ConfigJson.h
#pragma once
#include "ConfigModel.h"
#include <nlohmann/json.hpp>
using nlohmann::json;

static std::string Narrow(const std::wstring& w) {
    if (w.empty()) return {};
    int n = WideCharToMultiByte(CP_UTF8,0,w.data(),(int)w.size(),nullptr,0,nullptr,nullptr);
    std::string s(n,0);
    WideCharToMultiByte(CP_UTF8,0,w.data(),(int)w.size(),s.data(),n,nullptr,nullptr);
    return s;
}
static std::wstring Widen(const std::string& s) {
    if (s.empty()) return {};
    int n = MultiByteToWideChar(CP_UTF8,0,s.data(),(int)s.size(),nullptr,0);
    std::wstring w(n,0);
    MultiByteToWideChar(CP_UTF8,0,s.data(),(int)s.size(),w.data(),n);
    return w;
}

inline void to_json(json& j, const Proxy& v) {
    j = json{
        {"enabled", v.enabled},
        {"host", Narrow(v.host)},
        {"port", v.port}
    };
}
inline void from_json(const json& j, Proxy& v) {
    v.enabled = j.value("enabled", false);
    v.host = Widen(j.value("host", ""s));
    v.port = j.value("port", 0);
}

inline void to_json(json& j, const UiTheme& v) {
    j = json{
        {"mode",  Narrow(v.mode)},
        {"scale", v.scale}
    };
}
inline void from_json(const json& j, UiTheme& v) {
    v.mode  = Widen(j.value("mode", "system"s));
    v.scale = j.value("scale", 1.0);
}

inline void to_json(json& j, const Account& v) {
    j = json{
        {"name",     Narrow(v.name)},
        {"endpoint", Narrow(v.endpoint)},
        {"enabled",  v.enabled}
    };
}
inline void from_json(const json& j, Account& v) {
    v.name     = Widen(j.value("name", ""s));
    v.endpoint = Widen(j.value("endpoint", ""s));
    v.enabled  = j.value("enabled", true);
}

inline void to_json(json& j, const Settings& v) {
    j = json{
        {"configVersion", v.configVersion},
        {"ui", v.ui},
        {"proxy", v.proxy},
        {"accounts", v.accounts},
        {"logLevel", Narrow(v.logLevel)}
    };
}
inline void from_json(const json& j, Settings& v) {
    v.configVersion = j.value("configVersion", 1);
    if (j.contains("ui"))     v.ui = j.at("ui").get<UiTheme>();
    if (j.contains("proxy"))  v.proxy = j.at("proxy").get<Proxy>();
    if (j.contains("accounts")) v.accounts = j.at("accounts").get<std::vector<Account>>();
    v.logLevel = Widen(j.value("logLevel", "info"s));
}
```

### 2-3. 기본값/검증/보정(경량 Validator)

```cpp
// ConfigValidate.h
#pragma once
#include "ConfigModel.h"
#include <algorithm>

inline void ApplyDefaults(Settings& s) {
    if (s.ui.mode != L"light" && s.ui.mode != L"dark" && s.ui.mode != L"system")
        s.ui.mode = L"system";
    if (s.ui.scale < 0.8 || s.ui.scale > 2.0) s.ui.scale = 1.0;

    if (s.proxy.port < 0 || s.proxy.port > 65535) s.proxy.port = 0;

    // 중복 account name 제거
    std::sort(s.accounts.begin(), s.accounts.end(),
              [](auto& a, auto& b){ return a.name < b.name; });
    s.accounts.erase(std::unique(s.accounts.begin(), s.accounts.end(),
              [](auto& a, auto& b){ return a.name == b.name; }), s.accounts.end());
}

inline bool Validate(const Settings& s, std::wstring& why) {
    if (s.configVersion <= 0) { why=L"configVersion must be positive"; return false; }
    if (s.logLevel != L"trace" && s.logLevel!=L"debug" && s.logLevel!=L"info" &&
        s.logLevel!=L"warn" && s.logLevel!=L"error") {
        why = L"logLevel invalid"; return false;
    }
    for (auto& a : s.accounts) {
        if (a.name.empty())   { why=L"account.name empty"; return false; }
        if (a.endpoint.empty()){ why=L"account.endpoint empty"; return false; }
    }
    return true;
}
```

---

## 3) JSON 로드/저장 + Atomic Save + 백업

```cpp
// JsonFileIO.h
#pragma once
#include <Windows.h>
#include <filesystem>
#include <fstream>
#include <string>

inline bool WriteAllUtf8(const std::wstring& path, const std::string& utf8) {
    // 임시 파일에 쓰고 Replace
    std::filesystem::path p(path);
    auto tmp = p; tmp += L".tmp";
    auto bak = p; bak += L".bak";

    // 1) 임시 파일 쓰기
    {
        std::ofstream f(tmp, std::ios::binary | std::ios::trunc);
        if (!f) return false;
        // UTF-8 BOM(옵션) — 필요시 사용
        // const unsigned char bom[3]={0xEF,0xBB,0xBF}; f.write((char*)bom,3);
        f.write(utf8.data(), (std::streamsize)utf8.size());
        f.flush();
        if (!f.good()) return false;
    }

    // 2) 원자 교체
    BOOL ok = ReplaceFileW(p.c_str(), tmp.c_str(), bak.c_str(),
                           REPLACEFILE_WRITE_THROUGH, nullptr, nullptr);
    if (!ok) {
        // 첫 저장 등으로 대상이 없을 수 있음 → Move 대체
        ok = MoveFileExW(tmp.c_str(), p.c_str(), MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
        if (!ok) {
            DeleteFileW(tmp.c_str());
            return false;
        }
    }
    return true;
}

inline bool ReadAllUtf8(const std::wstring& path, std::string& out) {
    std::ifstream f(path, std::ios::binary);
    if (!f) return false;
    f.seekg(0, std::ios::end);
    auto n = f.tellg();
    f.seekg(0);
    out.resize((size_t)n);
    f.read(out.data(), n);
    return f.good() || f.eof();
}
```

---

## 4) 마이그레이션 파이프라인(버전 N → 최신)

### 4-1. 버전별 마이그레이션 함수 집합

```cpp
// ConfigMigrate.h
#pragma once
#include <nlohmann/json.hpp>
using nlohmann::json;

// v1 → v2: ui.scale 도입(기본 1.0), accounts[].enabled 도입(기본 true)
inline void Migrate_v1_to_v2(json& j) {
    if (!j.contains("ui")) j["ui"] = json::object();
    j["ui"]["scale"] = j["ui"].value("scale", 1.0);

    if (j.contains("accounts") && j["accounts"].is_array()) {
        for (auto& a : j["accounts"]) {
            a["enabled"] = a.value("enabled", true);
        }
    }
    j["configVersion"] = 2;
}

// v2 → v3: proxy 섹션 도입, logLevel 기본 "info"
inline void Migrate_v2_to_v3(json& j) {
    if (!j.contains("proxy")) {
        j["proxy"] = json{{"enabled", false},{"host",""},{"port",0}};
    }
    if (!j.contains("logLevel")) {
        j["logLevel"] = "info";
    }
    j["configVersion"] = 3;
}
```

### 4-2. 마이그레이션 드라이버

```cpp
// ConfigLoader.h
#pragma once
#include "ConfigModel.h"
#include "ConfigJson.h"
#include "ConfigValidate.h"
#include "JsonFileIO.h"
#include "ConfigMigrate.h"

#include <nlohmann/json.hpp>
using nlohmann::json;

inline bool LoadSettingsFromJsonFile(const std::wstring& path, Settings& out, std::wstring& err)
{
    std::string txt;
    if (!ReadAllUtf8(path, txt)) { err=L"파일 읽기 실패"; return false; }

    json j;
    try { j = json::parse(txt); }
    catch (std::exception& e) { err = L"JSON 파싱 실패"; return false; }

    int ver = j.value("configVersion", 1);

    // 연속 마이그레이션
    if (ver < 2) Migrate_v1_to_v2(j);
    if (j.value("configVersion", 1) < 3) Migrate_v2_to_v3(j);

    // 최종 모델로 매핑
    try { out = j.get<Settings>(); }
    catch (...) { err=L"모델 매핑 실패"; return false; }

    // 기본값/검증
    ApplyDefaults(out);
    if (!Validate(out, err)) return false;

    return true;
}

inline bool SaveSettingsToJsonFile(const std::wstring& path, const Settings& s, std::wstring& err)
{
    try {
        nlohmann::json j = s;
        // 가독성 있는 pretty dump
        std::string txt = j.dump(2);
        if (!WriteAllUtf8(path, txt)) { err=L"파일 쓰기 실패"; return false; }
        return true;
    } catch (...) {
        err = L"직렬화 실패";
        return false;
    }
}
```

---

## 5) 레이어 병합(기본값 → 정책 → 사용자 → 환경 → CLI)

### 5-1. 간단한 병합 함수(JSON object deep merge)

```cpp
// JsonMerge.h
#pragma once
#include <nlohmann/json.hpp>
using nlohmann::json;

inline void JsonDeepMerge(json& base, const json& overlay) {
    if (!overlay.is_object()) return;
    for (auto it = overlay.begin(); it != overlay.end(); ++it) {
        const std::string& k = it.key();
        if (base.contains(k) && base[k].is_object() && it.value().is_object())
            JsonDeepMerge(base[k], it.value());
        else
            base[k] = it.value(); // overwrite
    }
}
```

### 5-2. 적용 순서

```cpp
// Load layered settings
bool LoadLayeredSettings(Settings& out, std::wstring& why)
{
    using nlohmann::json;

    json j = {
        {"configVersion", 3},
        {"ui", {{"mode","system"}, {"scale",1.0}}},
        {"proxy", {{"enabled",false},{"host",""},{"port",0}}},
        {"accounts", json::array()},
        {"logLevel","info"}
    }; // defaults

    // 1) 정책(머신 전역)
    std::wstring policy = L"%PROGRAMDATA%\\Vendor\\App\\policy.json";
    // (환경변수 확장) 생략… 존재하면 읽어 병합
    std::string txt;
    if (ReadAllUtf8(policy, txt)) {
        try { json p = json::parse(txt); JsonDeepMerge(j, p); } catch(...) {}
    }

    // 2) 사용자
    std::wstring user = L"%APPDATA%\\Vendor\\App\\config\\settings.json";
    if (ReadAllUtf8(user, txt)) {
        try { json u = json::parse(txt); JsonDeepMerge(j, u); } catch(...) {}
    }

    // 3) 환경변수(예: APP_LOG_LEVEL)
    if (const wchar_t* v = _wgetenv(L"APP_LOG_LEVEL")) {
        j["logLevel"] = Narrow(v);
    }

    // 4) 명령줄 파싱(간단 예)
    // --ui:mode=dark --proxy:enabled=1 …
    // (실전은 파서 활용. 여기선 생략)

    // 마이그레이션 → 모델 매핑 → 기본값/검증
    // (레이어 병합은 최신 스키마를 가정하고 진행하는 편이 단순합니다)
    Settings s = j.get<Settings>();
    ApplyDefaults(s);
    if (!Validate(s, why)) return false;
    out = std::move(s);
    return true;
}
```

> 정책 파일은 **읽기 전용**으로 취급(사용자 설정에서 덮어쓰고 싶다면 정책 우선순위 규칙을 정의).  
> 기업 환경에선 “정책 > 사용자” 우선권을 권장합니다(사용자 설정이 정책을 **넘지 못하게**).

---

## 6) 민감 정보 분리/DPAPI 암호화

### 6-1. secrets.json 구조(예)

```json
{
  "configVersion": 1,
  "secrets": {
    "tokens": {
      "serviceA": "DPAPI:BLOB_BASE64",
      "serviceB": "DPAPI:BLOB_BASE64"
    }
  }
}
```

### 6-2. DPAPI 래퍼

```cpp
// SecretsDPAPI.h
#pragma once
#include <Windows.h>
#include <wincrypt.h>
#pragma comment(lib, "Crypt32.lib")
#include <vector>
#include <string>

inline bool DpapiProtectUser(const std::vector<uint8_t>& plain, std::vector<uint8_t>& blob) {
    DATA_BLOB in{ (DWORD)plain.size(), (BYTE*)plain.data() }, out{};
    if (!CryptProtectData(&in, L"", nullptr, nullptr, nullptr, 0, &out)) return false;
    blob.assign(out.pbData, out.pbData + out.cbData);
    LocalFree(out.pbData);
    return true;
}
inline bool DpapiUnprotectUser(const std::vector<uint8_t>& blob, std::vector<uint8_t>& plain) {
    DATA_BLOB in{ (DWORD)blob.size(), (BYTE*)blob.data() }, out{};
    if (!CryptUnprotectData(&in, nullptr, nullptr, nullptr, nullptr, 0, &out)) return false;
    plain.assign(out.pbData, out.pbData + out.cbData);
    LocalFree(out.pbData);
    return true;
}
inline std::string ToBase64(const std::vector<uint8_t>& v);
inline std::vector<uint8_t> FromBase64(const std::string& s);
// (Base64 구현은 생략. 프로젝트 공용 유틸 사용 권장)
```

### 6-3. secrets 저장/읽기

```cpp
// SecretsIO.h
#pragma once
#include <nlohmann/json.hpp>
#include "SecretsDPAPI.h"
#include "JsonFileIO.h"

struct Secrets {
    int configVersion = 1;
    std::map<std::wstring, std::wstring> tokens; // service -> plaintext (메모리에선 복호화 상태)
};

inline bool LoadSecrets(const std::wstring& path, Secrets& out) {
    std::string txt; if (!ReadAllUtf8(path, txt)) return false;
    auto j = nlohmann::json::parse(txt);
    out.configVersion = j.value("configVersion", 1);
    if (j.contains("secrets") && j["secrets"].contains("tokens")) {
        for (auto& [k,v] : j["secrets"]["tokens"].items()) {
            auto encB64 = v.get<std::string>();
            auto blob = FromBase64(encB64);
            std::vector<uint8_t> plain;
            if (DpapiUnprotectUser(blob, plain)) {
                out.tokens.emplace(Widen(k), Widen(std::string(plain.begin(), plain.end())));
            }
        }
    }
    return true;
}

inline bool SaveSecrets(const std::wstring& path, const Secrets& s) {
    nlohmann::json j;
    j["configVersion"] = s.configVersion;
    auto& t = j["secrets"]["tokens"] = nlohmann::json::object();
    for (auto& [svc, token] : s.tokens) {
        std::vector<uint8_t> plain(Narrow(token).begin(), Narrow(token).end());
        std::vector<uint8_t> blob;
        if (DpapiProtectUser(plain, blob)) {
            t[Narrow(svc)] = ToBase64(blob);
        }
    }
    std::string out = j.dump(2);
    return WriteAllUtf8(path, out);
}
```

---

## 7) 핫 리로드(파일 변경 감시)

```cpp
// ConfigWatcher.h
#pragma once
#include <Windows.h>
#include <functional>
#include <string>
#include <thread>
#include <atomic>

class FileWatcher {
    std::wstring m_dir;
    std::function<void()> m_onChange;
    std::thread m_thr;
    std::atomic<bool> m_stop{false};
public:
    bool Start(const std::wstring& filePath, std::function<void()> onChange) {
        m_onChange = std::move(onChange);
        // 디렉터리 핸들(감시 대상)
        std::filesystem::path p(filePath);
        m_dir = p.parent_path().wstring();
        HANDLE hDir = CreateFileW(m_dir.c_str(), FILE_LIST_DIRECTORY,
                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                    nullptr, OPEN_EXISTING,
                    FILE_FLAG_BACKUP_SEMANTICS, nullptr);
        if (hDir==INVALID_HANDLE_VALUE) return false;

        m_thr = std::thread([this, hDir, target = p.filename().wstring()]{
            std::vector<BYTE> buf(64*1024);
            OVERLAPPED ov{}; HANDLE ev = CreateEventW(nullptr, TRUE, FALSE, nullptr);
            ov.hEvent = ev;
            while(!m_stop.load()) {
                DWORD ret=0;
                BOOL ok = ReadDirectoryChangesW(hDir, buf.data(), (DWORD)buf.size(),
                    FALSE,
                    FILE_NOTIFY_CHANGE_FILE_NAME|FILE_NOTIFY_CHANGE_LAST_WRITE|FILE_NOTIFY_CHANGE_SIZE,
                    &ret, &ov, nullptr);
                if (!ok) break;
                DWORD w = WaitForSingleObject(ev, 1000);
                if (w==WAIT_OBJECT_0) {
                    // 단순화: 변경 발생 시 대상 파일인지 여부는 실제 파싱하여 필터링
                    ResetEvent(ev);
                    if (m_onChange) m_onChange();
                }
            }
            CloseHandle(ev);
            CloseHandle(hDir);
        });
        return true;
    }
    void Stop() {
        m_stop.store(true);
        if (m_thr.joinable()) m_thr.join();
    }
};
```

> 실제 구현에서는 `FILE_NOTIFY_INFORMATION` 레코드를 파싱하여 **해당 파일만 필터링** 하세요.  
> UI 갱신은 `PostMessage(hWnd, WM_APP_CONFIG_RELOADED, 0, 0)` 등으로 메인 스레드에서 처리.

---

## 8) UI 통합: 설정 다이얼로그 ↔ 모델 ↔ 파일

- 다이얼로그에서 `UpdateData(TRUE)` → 모델로 매핑 → `SaveSettingsToJsonFile()` → 성공 시 브로드캐스트(뷰/서비스 반영).
- **중간에 예외/검증 실패** 시 사용자에게 **무엇이 실패했는지** 명확히 안내.

```cpp
// Save button handler 예시
void CSettingsDlg::OnBnClickedSave() {
    Settings s = m_current;
    // 컨트롤 → s 로 반영 (DDX/DDV 또는 직접)
    std::wstring why;
    ApplyDefaults(s);
    if (!Validate(s, why)) {
        AfxMessageBox(why.c_str());
        return;
    }
    if (!SaveSettingsToJsonFile(m_userConfigPath, s, why)) {
        AfxMessageBox((L"저장 실패: " + why).c_str());
        return;
    }
    // 앱 전역 설정 갱신 브로드캐스트
    ::PostMessage(AfxGetMainWnd()->m_hWnd, WM_APP+100, 0, 0);
}
```

---

## 9) XML 설정: tinyxml2로 같은 구조 구현

> tinyxml2: https://github.com/leethomason/tinyxml2 (단일 헤더/소스)

### 9-1. 읽기/쓰기

```cpp
// XmlIO.h
#pragma once
#include "tinyxml2.h"
#include "ConfigModel.h"

inline bool LoadSettingsXml(const std::wstring& path, Settings& s) {
    std::string narrow; // 파일 읽기 + UTF-16→UTF-8 변환 생략(위 유틸 재사용)
    if (!ReadAllUtf8(path, narrow)) return false;
    tinyxml2::XMLDocument doc;
    if (doc.Parse(narrow.c_str()) != tinyxml2::XML_SUCCESS) return false;

    auto* root = doc.FirstChildElement("settings");
    if (!root) return false;
    s.configVersion = root->IntAttribute("configVersion", 1);

    auto* ui = root->FirstChildElement("ui");
    if (ui) {
        const char* mode = ui->Attribute("mode"); s.ui.mode = Widen(mode?mode:"system");
        ui->QueryDoubleAttribute("scale", &s.ui.scale);
    }
    auto* proxy = root->FirstChildElement("proxy");
    if (proxy) {
        proxy->QueryBoolAttribute("enabled", &s.proxy.enabled);
        const char* host = proxy->Attribute("host"); s.proxy.host = Widen(host?host:"");
        proxy->QueryIntAttribute("port", &s.proxy.port);
    }
    auto* accounts = root->FirstChildElement("accounts");
    if (accounts) {
        for (auto* a = accounts->FirstChildElement("account"); a; a=a->NextSiblingElement("account")) {
            Account ac;
            const char* name = a->Attribute("name");
            const char* ep   = a->Attribute("endpoint");
            if (name) ac.name=Widen(name);
            if (ep)   ac.endpoint=Widen(ep);
            a->QueryBoolAttribute("enabled", &ac.enabled);
            s.accounts.push_back(std::move(ac));
        }
    }
    const char* lvl = root->Attribute("logLevel");
    s.logLevel = Widen(lvl?lvl:"info");
    ApplyDefaults(s);
    std::wstring why;
    return Validate(s, why);
}

inline bool SaveSettingsXml(const std::wstring& path, const Settings& s) {
    tinyxml2::XMLDocument doc;
    auto* root = doc.NewElement("settings");
    root->SetAttribute("configVersion", s.configVersion);
    root->SetAttribute("logLevel", Narrow(s.logLevel).c_str());
    doc.InsertFirstChild(root);

    auto* ui = doc.NewElement("ui");
    ui->SetAttribute("mode", Narrow(s.ui.mode).c_str());
    ui->SetAttribute("scale", s.ui.scale);
    root->InsertEndChild(ui);

    auto* proxy = doc.NewElement("proxy");
    proxy->SetAttribute("enabled", s.proxy.enabled);
    proxy->SetAttribute("host", Narrow(s.proxy.host).c_str());
    proxy->SetAttribute("port", s.proxy.port);
    root->InsertEndChild(proxy);

    auto* accs = doc.NewElement("accounts");
    for (auto& a : s.accounts) {
        auto* e = doc.NewElement("account");
        e->SetAttribute("name",     Narrow(a.name).c_str());
        e->SetAttribute("endpoint", Narrow(a.endpoint).c_str());
        e->SetAttribute("enabled",  a.enabled);
        accs->InsertEndChild(e);
    }
    root->InsertEndChild(accs);

    tinyxml2::XMLPrinter prt;
    doc.Print(&prt);
    return WriteAllUtf8(path, std::string(prt.CStr()));
}
```

### 9-2. XML 마이그레이션
- JSON과 동일한 아이디어: `configVersion` 속성 기준으로 엘리먼트/속성을 추가/이동/변환.

---

## 10) JSON Schema(선택): 런타임 검증

- 라이브러리 예: **nlohmann/json-schema-validator**(외부 의존)  
- 장점: 스키마로 **형식/필수/범위** 선언 → 테스트/마이그레이션 신뢰도 ↑  
- 단점: 추가 의존/바이너리 크기 증가.

간단 검증으로 충분하면 위의 경량 Validator로도 OK.  
정책 환경/플러그인처럼 **신뢰 불가 입력**을 받을 때는 Schema 권장.

---

## 11) 테스트 시나리오 & 회귀 보호

1. **기본 로드/저장**: defaults → 저장 → 재로드 → **동등성 검증**  
2. **마이그레이션**: v1/v2 샘플 파일 → 로드 → 최신 모델 → 저장 → 기대값 비교  
3. **경합/핫리로드**: 파일 교체 중 읽기 → 예외 없이 최신 반영?  
4. **에러 파일**: 잘못된 JSON/XML → 기본값 보정 + 사용자 알림  
5. **긴 경로/권한**: `\\?\` 경로, Program Files 접근 차단 시 동작  
6. **암호/토큰**: secrets DPAPI 저장/로드 검증(사용자 바뀌면 복호화 실패가 정상)

---

## 12) 성능/안정성 팁

- JSON 파싱은 매우 빠름(수십 KB~수백 KB 설정 기준).  
- 매우 큰 설정(수 MB 이상)은 **구조 분할** 권장(프로필/모듈별 파일).  
- 저장은 **지연 쓰기(타이머 500ms)** + **배치**: 키 입력마다 디스크 I/O 방지.  
- 동시 저장 경쟁 방지: **프로세스 mutex**(`Global\\Vendor_App_Config`) + **atomic save**.

---

## 13) MFC 연동: DDX/DDV + 설정 바인딩

- 다이얼로그 표시 시 `Settings → 컨트롤(UpdateData(FALSE))`  
- 저장 시 `UpdateData(TRUE) → Settings → Save()`

```cpp
// 예: ui.mode 콤보박스 바인딩
void CSettingsDlg::ApplyToControls(const Settings& s) {
    int idx = 0;
    if (s.ui.mode==L"light") idx=1; else if (s.ui.mode==L"dark") idx=2;
    m_comboMode.SetCurSel(idx);
    CString txt; txt.Format(L"%.2f", s.ui.scale);
    SetDlgItemText(IDC_EDIT_SCALE, txt);
}
void CSettingsDlg::CollectFromControls(Settings& s) {
    int idx = m_comboMode.GetCurSel();
    if (idx==0) s.ui.mode=L"system"; else if (idx==1) s.ui.mode=L"light"; else s.ui.mode=L"dark";
    CString t; GetDlgItemText(IDC_EDIT_SCALE, t);
    s.ui.scale = _wtof(t);
}
```

---

## 14) CLI/환경 변수 병합 실전

- 명령줄 `--config="C:\path\settings.json"`  
- `--set ui.mode=dark --set proxy.enabled=true` 처럼 **경로 기반 set** 지원  
- 환경변수 표준화: `APP_UI_MODE`, `APP_PROXY_ENABLED`…

```cpp
// 매우 단순한 --set 파서: --set key=val
void ApplySetArg(nlohmann::json& j, const std::string& arg) {
    auto eq = arg.find('=');
    if (eq==std::string::npos) return;
    std::string key = arg.substr(0,eq);
    std::string val = arg.substr(eq+1);
    // key: "ui.mode" → j["ui"]["mode"]
    nlohmann::json* cur = &j;
    std::stringstream ss(key);
    std::string tok;
    std::vector<std::string> ks;
    while(std::getline(ss,tok,'.')) ks.push_back(tok);
    for (size_t i=0;i<ks.size();++i) {
        auto& k = ks[i];
        if (i+1==ks.size()) (*cur)[k] = val; // 값 형변환까지 하려면 추가 로직
        else cur = &((*cur)[k]);
    }
}
```

---

## 15) 오류 메시지/로그 UX

- 사용자에게는 **간결/행동 가능** 메시지:  
  - “설정 파싱 실패: 12행 근처. 기본값으로 시작합니다. [자세히…]”  
- 로그에는 **원문+스택/경로** 기록.  
- UI에 “설정 열기…” 버튼 제공(문제 파일을 바로 열어 수정 가능).

---

## 16) 예제: 통합 ConfigManager (스레드 안전, 구독, 핫리로드)

```cpp
// ConfigManager.h
#pragma once
#include "ConfigModel.h"
#include "ConfigLoader.h"
#include "JsonMerge.h"
#include "ConfigWatcher.h"
#include <shared_mutex>
#include <functional>

class ConfigManager {
    Settings m_cur{};
    std::wstring m_userPath;
    FileWatcher m_watch;
    std::vector<std::function<void(const Settings&)>> m_subs;
    std::shared_mutex m_mtx;

    void Notify(const Settings& s) {
        // UI 스레드로 마샬링하거나, 여기서 직접 호출(단, 스레드 주의)
        for (auto& f : m_subs) f(s);
    }
public:
    bool Init(const std::wstring& userPath) {
        m_userPath = userPath;

        std::wstring why;
        if (!LoadSettingsFromJsonFile(m_userPath, m_cur, why)) {
            // 파일이 없으면 defaults를 저장
            ApplyDefaults(m_cur);
            m_cur.configVersion = 3;
            SaveSettingsToJsonFile(m_userPath, m_cur, why);
        }
        // 감시 시작
        m_watch.Start(m_userPath, [this]{
            std::wstring why;
            Settings s;
            if (LoadSettingsFromJsonFile(m_userPath, s, why)) {
                std::unique_lock lk(m_mtx);
                m_cur = std::move(s);
                lk.unlock();
                Notify(m_cur);
            }
        });
        return true;
    }
    void Shutdown(){ m_watch.Stop(); }

    Settings Get() const {
        std::shared_lock lk(m_mtx);
        return m_cur; // 소형 구조체면 값복사 OK. 크면 shared_ptr로 설계
    }
    bool Update(const Settings& sNew, std::wstring& why) {
        Settings s = sNew;
        ApplyDefaults(s);
        if (!Validate(s, why)) return false;
        if (!SaveSettingsToJsonFile(m_userPath, s, why)) return false;

        // 디스크에 성공적으로 썼으므로 메모리 반영
        std::unique_lock lk(m_mtx);
        m_cur = s;
        lk.unlock();
        Notify(m_cur);
        return true;
    }
    void Subscribe(std::function<void(const Settings&)> cb) { m_subs.push_back(std::move(cb)); }
};
```

---

## 17) 마이그레이션 전략 심화(실무 팁)

- **단계별 순차**: 1→2→3… 중간 버전을 건너뛰어도 **연쇄 변환**으로 처리.  
- **변환 로그**: 어떤 필드를 어떻게 바꿨는지 로그/Telemetry로 수집하면 현장 이슈 추적에 유리.  
- **파괴적 변경** 최소화: 새 필드는 **선택적/기본값 포함**, 기존 필드는 **Deprecated** 기간 운영.  
- **다운그레이드** 필요 시: 3→2→1 역방향 함수 세트(또는 내보내기 전 변환).  
- **테스트 팩**: 각 버전의 샘플 파일 + 기대 결과 JSON 스냅샷.

---

## 18) XML ↔ JSON 상호 변환(마이그레이션/호환)

- 구 버전이 XML, 신 버전이 JSON이라면 **단발성 변환기** 제공:
  - **백업 → JSON으로 변환 → 저장 → 안내**.
- 변환 로직은 **모델 객체를 경유**:  
  XML→Settings→(ApplyDefaults/Validate)→JSON.

---

## 19) 대규모 설정(플러그인/프로필) 분할

- `profiles/default.json`, `profiles/userA.json`  
- `plugins/<id>/config.json`  
- 로딩 시 **각 파일의 버전**을 독립 관리(미니 마이그레이션 함수 포함).  
- 충돌 방지: 파일 단위 mutex + “마지막 저장자” 메타 기록.

---

## 20) 체크리스트 (요약)

- [ ] `configVersion`(정수/semver) **항상 포함**  
- [ ] **Atomic Save** + `.bak` 백업  
- [ ] **기본값/검증/보정** 로직 내장  
- [ ] **레이어 병합 순서** 문서화/테스트  
- [ ] **민감 정보 분리+DPAPI**  
- [ ] **핫 리로드** + 구독 콜백  
- [ ] **스레드 안전**(읽기 lock-free/쓰기 mutex)  
- [ ] **긴 경로/권한/UAC** 시나리오 테스트  
- [ ] **마이그레이션 스크립트/샘플** 지속 관리  
- [ ] **로그/에러 UX**: 사용자 행동 가능 메시지

---

## 마무리

- 설정 관리의 본질은 **신뢰성(Atomic Save)**, **진화 가능성(Versioned Migration)**, **가시성(Validation/Logging)** 입니다.  
- JSON을 기본으로 채택하고, XML은 **호환·연동**에 사용하면 운영이 간결합니다.  
- 위의 클래스를 **프로젝트 공용 모듈**로 분리( `ConfigModel/Json/Xml/IO/Validate/Migrate/Manager` )하면  
  신규 기능이 늘어나도 **형식·버전·배포** 걱정 없이 설정을 확장할 수 있습니다.
