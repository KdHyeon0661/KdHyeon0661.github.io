---
layout: post
title: DB - 윈도우 함수 (1)
date: 2025-03-18 19:20:23 +0900
category: DB
---
# 완전 정리

## 왜 윈도우 함수인가?

일반 집계는 `GROUP BY`로 **행을 줄이는** 기법이다. 반면 **윈도우 함수(Window Function)**는 **행을 그대로 유지**하면서 “그룹별/순서 기반”으로 **각 행에 요약/순위/이전-다음/누적** 값을 부여한다.
즉, **“보고서/지표”를 한 방에** 만들 수 있다.

- 일반 집계: “부서별 평균 급여”  → 부서당 **1행**
- 윈도우: “부서별 평균 급여를 모든 직원 행에 함께 보여주기” → **행 보존 + 파생값**

---

## 문법 골격과 실행 순서

### 기본 문법

```sql
<함수>( [표현식] ) OVER (
  [PARTITION BY <열 목록>]
  [ORDER BY <열 목록> [ASC|DESC] [NULLS FIRST|LAST]]
  [<프레임 절>]
)
```
- `PARTITION BY`: 집계 범위(논리적 그룹)를 나눈다.
- `ORDER BY`: 윈도우 내 **순서**를 정의한다(누적/순위/이전-다음 등).
- `<프레임 절>`: 누적합/이동 평균 등에서 **슬라이딩 범위**를 지정한다.

### 실행 순서(핵심 인지 포인트)

- SQL은 논리적 실행 순서가 `FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY`이다.
- **윈도우 함수는 SELECT 단계에서 계산**된다.
  → 따라서 **WHERE에서 윈도우 결과를 직접 필터링할 수 없다**. 서브쿼리/CTE로 감싸서 바깥 WHERE에서 필터링해야 한다.

```sql
-- ❌ 동작 불가: WHERE에서 윈도우 표현식 사용
SELECT e.*,
       ROW_NUMBER() OVER (PARTITION BY dept ORDER BY salary DESC) rn
FROM Employee e
WHERE rn <= 3;

-- ✅ CTE로 감싼 뒤 바깥 WHERE에서 필터
WITH ranked AS (
  SELECT e.*,
         ROW_NUMBER() OVER (PARTITION BY dept ORDER BY salary DESC) rn
  FROM Employee e
)
SELECT *
FROM ranked
WHERE rn <= 3;
```

---

## 대표 윈도우 함수 군

### 순위/번호

- `ROW_NUMBER()`: 파티션 내 고유 순번(동점 무시, 항상 1,2,3,…)
- `RANK()`: 동점 발생 시 다음 순위를 **건너뜀**(1,1,3,…)
- `DENSE_RANK()`: 동점 발생해도 **건너뛰지 않음**(1,1,2,…)
- `NTILE(n)`: 파티션을 n개 **버킷**으로 균등 분할(사이즈가 ±1 차이 가능)

```sql
SELECT emp_id, dept, salary,
       ROW_NUMBER()  OVER (PARTITION BY dept ORDER BY salary DESC) AS rn,
       RANK()        OVER (PARTITION BY dept ORDER BY salary DESC) AS rnk,
       DENSE_RANK()  OVER (PARTITION BY dept ORDER BY salary DESC) AS drnk,
       NTILE(4)      OVER (PARTITION BY dept ORDER BY salary DESC) AS quartile
FROM Employee;
```

### 집계(=일반 집계 + OVER)

- `SUM`, `AVG`, `COUNT`, `MAX`, `MIN`… 를 `OVER()`와 함께 쓰면 **행을 보존**한다.

```sql
-- 부서별 누적합(급여 오름차순)
SELECT emp_id, dept, salary,
       SUM(salary) OVER (PARTITION BY dept ORDER BY salary) AS running_total
FROM Employee;
```

### 이웃 참조/경계 값

- `LAG(expr, offset, default)`: 이전 행의 값
- `LEAD(expr, offset, default)`: 다음 행의 값
- `FIRST_VALUE(expr)`: 파티션 정렬 기준 **첫 값**
- `LAST_VALUE(expr)`: 파티션 정렬 기준 **마지막 값**
  → **기본 프레임에선 “현재 행까지”로 해석되는 DB가 많다**. **프레임 확장** 필요(아래 참조).

```sql
-- 고객별 거래에 대해 이전/다음 금액
SELECT customer_id, tx_date, amount,
       LAG(amount)  OVER (PARTITION BY customer_id ORDER BY tx_date) AS prev_amt,
       LEAD(amount) OVER (PARTITION BY customer_id ORDER BY tx_date) AS next_amt
FROM Transactions;

-- 파티션 내 최댓값/최솟값을 모든 행에 표기
SELECT dept, emp_id, salary,
       FIRST_VALUE(salary) OVER (PARTITION BY dept ORDER BY salary DESC
                                 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS max_in_dept,
       LAST_VALUE(salary)  OVER (PARTITION BY dept ORDER BY salary DESC
                                 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS min_in_dept
FROM Employee;
```

> **중요**: `LAST_VALUE()`는 프레임 지정 없으면 “현재 행까지”의 마지막을 의미하여 **행마다 값이 달라지는 함정**이 있다.
> 마지막 행의 값을 고정으로 보고 싶다면 **프레임을 파티션 전체**로 확장해야 한다:
> `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`

---

## 완전 해설

### 프레임의 필요성

- **누적합, 이동 평균, 슬라이딩 집계**는 “현재 행을 중심으로 앞/뒤 몇 행/범위”라는 **프레임**이 있어야 의미가 생긴다.

### 세 가지 프레임 유형

| 유형 | 기준 | 특징/주의 |
|---|---|---|
| `ROWS` | **물리적 행 개수** | 정확히 N행 단위 슬라이딩. 동점과 무관. |
| `RANGE` | **정렬 키의 값 범위** | 동점(같은 ORDER BY 값) 전체가 **동일 프레임**에 포함될 수 있음. |
| `GROUPS` | **동일 순위(동점) 묶음** | ORDER BY “피어 그룹” 단위로 슬라이딩(지원 DB 제한 있음). |

### 경계 표기

- `UNBOUNDED PRECEDING` / `UNBOUNDED FOLLOWING`: 파티션의 시작/끝
- `CURRENT ROW`: 현재 행
- `n PRECEDING / n FOLLOWING`: 현재 행 기준 n행 앞/뒤(ROWS) 또는 값 범위(특히 RANGE n FOLLOWING은 DB별 제약 및 의미 주의)

### 예제: 3-행 이동 평균 (ROWS)

```sql
SELECT emp_id, dept, salary,
       AVG(salary) OVER (
         PARTITION BY dept
         ORDER BY hire_date
         ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
       ) AS mov_avg_3
FROM Employee
ORDER BY dept, hire_date;
```

### 예제: 날짜 기반 이동 합계 (RANGE)

```sql
-- 월별 매출에서 "이전 2개월 ~ 현재월" 누적합
-- RANGE INTERVAL 문법은 DB마다 다름(PSQL/Oracle/MySQL 8+ 일부 지원)
SELECT month, amount,
       SUM(amount) OVER (
         ORDER BY month
         RANGE BETWEEN INTERVAL '2 months' PRECEDING AND CURRENT ROW
       ) AS rolling_3m_sum
FROM MonthlySales
ORDER BY month;
```

### 예제: 동점 그룹 단위 이동 (GROUPS)

```sql
-- 동일 매출액을 하나의 그룹으로 묶고, 그 그룹 단위로 이전 1그룹까지 누적
-- (일부 DB만 지원: 표준 SQL/Oracle 12c+/PSQL 11+; MySQL은 미지원)
SELECT store_id, revenue,
       SUM(revenue) OVER (
         ORDER BY revenue
         GROUPS BETWEEN 1 PRECEDING AND CURRENT ROW
       ) AS grouped_running
FROM StoreRevenue
ORDER BY revenue;
```

> **가이드**
> - 동점이 많고 “피어 그룹 단위”로 슬라이딩해야 하면 `GROUPS`가 명확하다.
> - 값 범위(예: 금액 ±100)라면 `RANGE`가 직관적이다.
> - 가장 보편적/예측 가능한 것은 `ROWS`.

---

## 윈도우 함수와 조건부 집계(필터링)

### 조건부 누적(ANSI FILTER vs CASE)

- PostgreSQL/SQLite 등은 `FILTER(WHERE ...)`를 지원.
- MySQL/SQL Server/Oracle은 `CASE WHEN` 패턴 사용.

```sql
-- PostgreSQL: FILTER
SELECT customer_id,
       SUM(amount) FILTER (WHERE status = 'PAID')     OVER (PARTITION BY customer_id ORDER BY order_date) AS paid_cum,
       SUM(amount) FILTER (WHERE status = 'CANCELLED') OVER (PARTITION BY customer_id ORDER BY order_date) AS cancel_cum
FROM Orders;

-- Cross-DB: CASE WHEN
SELECT customer_id,
       SUM(CASE WHEN status='PAID'     THEN amount ELSE 0 END)
         OVER (PARTITION BY customer_id ORDER BY order_date) AS paid_cum,
       SUM(CASE WHEN status='CANCELLED' THEN amount ELSE 0 END)
         OVER (PARTITION BY customer_id ORDER BY order_date) AS cancel_cum
FROM Orders;
```

---

## — 페이징/추천/상위 추출

```sql
-- 부서별 급여 상위 3명
WITH ranked AS (
  SELECT e.*,
         ROW_NUMBER() OVER (PARTITION BY dept ORDER BY salary DESC) AS rn
  FROM Employee e
)
SELECT *
FROM ranked
WHERE rn <= 3
ORDER BY dept, salary DESC;
```

- 동점 모두 포함이 필요하면 `DENSE_RANK()`를 쓰고 `<= 3` 필터.

---

## 중복 제거/대표 행 선택(Dedup/Latest Per Key)

```sql
-- 고객별 최신 주문 1건(동률 있을 경우 가장 큰 order_id 선택)
WITH latest AS (
  SELECT o.*,
         ROW_NUMBER() OVER (
           PARTITION BY customer_id
           ORDER BY order_date DESC, order_id DESC
         ) AS rn
  FROM Orders o
)
SELECT *
FROM latest
WHERE rn = 1;
```

- **복수 정렬 키**로 동률 처리 전략을 분명히 하자(재현성).

---

## 탐지(LAG 활용)

### “연속 날짜 그룹” 나누기

```sql
-- 사용자 로그인 날짜가 연속되는 구간을 군집화
WITH logs AS (
  SELECT user_id, login_date
  FROM Logins
),
x AS (
  SELECT user_id, login_date,
         CASE
           WHEN login_date = LAG(login_date) OVER (PARTITION BY user_id ORDER BY login_date) + INTERVAL '1 day'
             THEN 0
           ELSE 1
         END AS is_new_group
  FROM logs
),
y AS (
  SELECT user_id, login_date,
         SUM(is_new_group) OVER (PARTITION BY user_id ORDER BY login_date) AS grp
  FROM x
)
SELECT user_id,
       MIN(login_date) AS start_date,
       MAX(login_date) AS end_date,
       COUNT(*)        AS days
FROM y
GROUP BY user_id, grp
ORDER BY user_id, start_date;
```

- **아이디어**: 이전 날짜 + 1일이면 같은 섬, 아니면 새 섬 시작. 누적으로 그룹 번호 부여.

---

## LAST_VALUE 함정과 정확한 프레임

```sql
-- 잘못된 예: 파티션 내 "현재 행까지"의 마지막 급여가 나와 행마다 값이 달라짐
SELECT dept, emp_id, salary,
       LAST_VALUE(salary) OVER (PARTITION BY dept ORDER BY salary DESC) AS wrong_last
FROM Employee;

-- 올바른 예: 파티션 전체 프레임으로 확장해 '진짜 마지막 값'을 고정
SELECT dept, emp_id, salary,
       LAST_VALUE(salary) OVER (
         PARTITION BY dept ORDER BY salary DESC
         ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
       ) AS true_min_in_dept
FROM Employee;
```

---

## NULL, 정렬, 피어 그룹(동점)

- **NULL 정렬**은 DB마다 다르다: PSQL은 ASC에서 NULLS FIRST가 기본, Oracle/MySQL은 반대일 수 있다.
  → **명시**하라: `ORDER BY col ASC NULLS LAST`.
- **RANK/DENSE_RANK**는 **동점(피어)** 기준.
  **RANGE** 프레임도 피어를 함께 포함할 수 있다.
- **LAG/LEAD의 기본값**을 지정하여 첫/마지막 행에서 NULL 처리 전략을 고정하라.

---

## 성능 최적화 체크리스트

1) **정렬 비용**: `ORDER BY`가 있는 윈도우는 정렬/소트 메모리/디스크 스필이 성능을 좌우. 적절한 **인덱스(정렬 키)** 유무를 확인.
2) **프레임 폭**: `UNBOUNDED PRECEDING` ~ `CURRENT ROW`는 누적이라 상대적 비용이 낮은 편. `FOLLOWING`까지 확장하면 전 범위를 봐야 해 비용↑.
3) **파티션 크기**: `PARTITION BY`로 그룹 크기를 줄이면 정렬/집계 범위도 줄어든다.
4) **SELECT에 다수 윈도우**: 같은 파티션/정렬이면 **WINDOW 절(PostgreSQL)로 공유**하거나 동일 정의를 재사용해 엔진 최적화를 기대.
5) **필터 위치**: 윈도우 결과 필터는 **바깥 SELECT/CTE**에서 수행(조기 필터로 불필요한 소트를 줄임).
6) **물질화/CTE 힌트**: DB별로 CTE 물질화/인라인 정책이 다르니 실행계획을 확인.
7) **대체 기법**: 일부 케이스는 **세미-조인/반상관화/집합연산자**가 더 빠를 수 있다(특히 단순 상위 N 추출).

---

## 다중 윈도우 공유(WINDOW 절, PostgreSQL)

```sql
-- 같은 PARTITION/ORDER를 공유하고 다른 함수만 바꾸기
SELECT emp_id, dept, salary,
       SUM(salary)  OVER w AS run_sum,
       AVG(salary)  OVER w AS run_avg,
       ROW_NUMBER() OVER w AS rn
FROM Employee
WINDOW w AS (PARTITION BY dept ORDER BY salary);
```

- 가독성↑, 최적화에도 유리할 수 있다. (MySQL/SQL Server/Oracle은 별도 WINDOW 절이 없으므로 중복을 작성)

---

## 실무 시나리오별 레시피

### 매출 누적·이동 평균(월 단위)

```sql
-- 월 누적 매출 + 3개월 이동 평균
SELECT month,
       amount,
       SUM(amount) OVER (ORDER BY month) AS ytd,
       AVG(amount) OVER (
         ORDER BY month
         ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
       ) AS ma3
FROM MonthlySales
ORDER BY month;
```

### 고객별 “첫 구매 이후” 누적/간격

```sql
SELECT customer_id, order_date, amount,
       MIN(order_date) OVER (PARTITION BY customer_id)                                                AS first_order,
       SUM(amount)   OVER (PARTITION BY customer_id ORDER BY order_date
                           ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)                         AS cum_after_first,
       order_date -  LAG(order_date) OVER (PARTITION BY customer_id ORDER BY order_date)             AS days_since_prev
FROM Orders;
```

### 상품 카테고리별 성장률(이전 대비)

```sql
SELECT category, month, revenue,
       revenue - LAG(revenue) OVER (PARTITION BY category ORDER BY month)        AS mom_diff,
       CASE
         WHEN LAG(revenue) OVER (PARTITION BY category ORDER BY month) = 0 THEN NULL
         ELSE round( (revenue::numeric /
                      NULLIF(LAG(revenue) OVER (PARTITION BY category ORDER BY month), 0) - 1) * 100 , 2)
       END AS mom_growth_pct
FROM CategoryRevenue
ORDER BY category, month;
```
- SQL Server/Oracle/MySQL은 CAST/ROUND/NULLIF 문법만 각 DB에 맞춰 수정.

### 사용자 세션화(무활동 간격 기준)

```sql
-- 30분 이상 공백이면 새 세션
WITH x AS (
  SELECT user_id, event_time,
         CASE
           WHEN event_time - LAG(event_time) OVER (PARTITION BY user_id ORDER BY event_time)
                > INTERVAL '30 minutes' THEN 1
           ELSE 0
         END AS new_sess
  FROM UserEvents
),
y AS (
  SELECT user_id, event_time,
         SUM(new_sess) OVER (PARTITION BY user_id ORDER BY event_time) AS sess_no
  FROM x
)
SELECT user_id, sess_no, MIN(event_time) AS start_ts, MAX(event_time) AS end_ts, COUNT(*) AS events
FROM y
GROUP BY user_id, sess_no
ORDER BY user_id, sess_no;
```

### 부서 평균 이상 급여자만(윈도우→외부 WHERE)

```sql
WITH enriched AS (
  SELECT e.*,
         AVG(salary) OVER (PARTITION BY dept) AS dept_avg
  FROM Employee e
)
SELECT *
FROM enriched
WHERE salary >= dept_avg
ORDER BY dept, salary DESC;
```

---

## 수학적 직관(프레임/누적 비용)

슬라이딩 합계의 개념을 단순 수식으로 보면, 각 위치 \(i\)에서
$$
\text{mov\_sum}(i) = \sum_{k=i-w+1}^{i} x_k
$$
이고, 누적합 \(P(i)=\sum_{k=1}^{i} x_k\)를 쓰면
$$
\text{mov\_sum}(i) = P(i) - P(i-w)
$$
와 같이 **프리픽스 합**으로 계산 가능하다. DB 엔진도 내부적으로 정렬/스캔/프레임 조정으로 유사한 최적화를 활용한다(정확한 방식은 DB마다 다르다).
핵심은 **정렬**과 **프레임 업데이트**의 비용이 전체 성능을 좌우한다는 점이다.

---

## 트러블슈팅 & 베스트 프랙티스

- **LAST_VALUE 결과가 이상**: 프레임을 전체로 확장해라.
  `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`
- **윈도우 결과 WHERE에서 필터 안 됨**: CTE/서브쿼리로 감싸 바깥에서 필터.
- **NTILE 분할이 균등하지 않음**: 전체 행수를 n으로 나눌 때 나머지 행이 앞 버킷에 1개 더 들어갈 수 있다. 문서/테스트로 기대치 확인.
- **RANGE의 값 단위가 애매**: 시간/금액 등 단위와 지원 문법이 DB마다 다르므로 문서 확인. 불가하면 `ROWS`로 근사.
- **성능 저하**: 파티션/정렬 키 인덱스, 프레임 축소, 조기 필터(사전 WHERE), 동일 윈도우 정의 공유, 실행계획 점검.
- **NULL 정렬/동점 처리 혼란**: 정렬 옵션을 **명시**하고, 동점 해소용 2차 키를 추가해 재현성을 확보.

---

## DBMS 차이 메모

| 항목 | PostgreSQL | Oracle | SQL Server | MySQL 8+ |
|---|---|---|---|---|
| WINDOW 절 | 지원 | 미지원 | 미지원 | 미지원 |
| GROUPS 프레임 | 11+ 지원 | 12c+ 지원 | 2022+ 일부 | 미지원 |
| FILTER(WHERE) | 지원 | 미지원 | 미지원 | 미지원 |
| NULLS FIRST/LAST | 지원 | 지원 | 일부(ORDER BY) | 8.0+ (제약 존재) |
| RANGE 간격 구문 | INTERVAL 풍부 | 강력 | 제한 | 제한 |

> 이질성은 **테스트 케이스를 고정**하고, **이식성 구조(CTE/CASE/ROWS)**로 맞추면 완화된다.

---

## 요약(Part 1)

- 윈도우 함수는 **행을 보존**하면서 파티션과 순서에 기반한 **분석 지표**를 생성한다.
- 핵심 키워드: `OVER()`, `PARTITION BY`, `ORDER BY`, **프레임(ROWS/RANGE/GROUPS)**.
- 주력 패턴: **Top-N per group**, **누적/이동 집계**, **이전/다음 참조**, **최신/대표 행 선택**, **Gaps & Islands**.
- 주의: **LAST_VALUE 프레임 함정**, WHERE에서 윈도우 직접 사용 불가, 정렬/프레임 비용, DBMS 차이.
- 성능: 인덱스, 파티션 축소, 프레임 최적화, 동일 윈도우 공유, 실행계획 확인.

---

# 예고 — 고급 윈도우 분석

- **ROLLING WINDOW 심화**: 시간/값/그룹 기준 다양한 프레임 설계(비정형 간격, 영업일 캘린더)
- **분위수·백분위**: `CUME_DIST()`, `PERCENT_RANK()`, `NTILE()` vs 퍼센타일, `PERCENTILE_CONT`/`PERCENTILE_DISC`
- **피어 그룹 배제(EXCLUDE TIES/CURRENT ROW)**, 프레임 배제
- **가중 이동 평균/지수평활(EMA) 근사**, 이상치 감쇠
- **윈도우 + PIVOT/UNPIVOT/ROLLUP/CUBE** 결합 리포팅
