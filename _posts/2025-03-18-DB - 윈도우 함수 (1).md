---
layout: post
title: DB - 윈도우 함수 (1)
date: 2025-03-18 19:20:23 +0900
category: DB
---
# SQL 윈도우 함수 완전 정리

## 개요: 윈도우 함수의 필요성과 개념

윈도우 함수는 SQL에서 가장 강력한 분석 도구 중 하나입니다. 일반 집계 함수(`GROUP BY`)가 데이터를 그룹화하여 요약하는 반면, 윈도우 함수는 원본 행을 그대로 유지하면서 각 행에 추가적인 분석 정보를 부여합니다. 이는 데이터를 보다 풍부하게 이해하고 복잡한 비즈니스 질문에 답변하는 데 필수적입니다.

간단한 예로 살펴보겠습니다:
- **일반 집계**: "각 부서의 평균 급여는 얼마인가?" → 부서당 1행의 결과
- **윈도우 함수**: "각 직원의 급여와 함께 해당 부서의 평균 급여를 보여줘" → 모든 직원 행에 부서 평균 정보 추가

이러한 특성 때문에 윈도우 함수는 보고서 생성, 순위 결정, 누적 계산, 이동 평균 등 다양한 분석 시나리오에서 널리 사용됩니다.

---

## 윈도우 함수의 기본 문법과 실행 순서

### 기본 문법 구조
```sql
함수_이름(인자) OVER (
    [PARTITION BY 컬럼1, 컬럼2, ...]
    [ORDER BY 컬럼 [ASC|DESC] [NULLS FIRST|LAST]]
    [ROWS|RANGE|GROUPS 프레임_정의]
)
```

각 구성 요소의 역할:
- **PARTITION BY**: 데이터를 논리적 그룹으로 나눕니다. 그룹 내에서만 윈도우 함수가 적용됩니다.
- **ORDER BY**: 각 파티션 내에서 행의 순서를 정의합니다. 순위나 누적 계산에 필수적입니다.
- **프레임 절**: 현재 행을 기준으로 계산 범위를 정의합니다. 이동 평균이나 누적 합에 사용됩니다.

### 실행 순서 이해하기
윈도우 함수는 SQL 쿼리의 실행 순서에서 중요한 위치를 차지합니다:

1. FROM 및 JOIN
2. WHERE (행 필터링)
3. GROUP BY (그룹화)
4. HAVING (그룹 필터링)
5. **윈도우 함수 계산**
6. SELECT (최종 컬럼 선택)
7. DISTINCT
8. ORDER BY
9. LIMIT/OFFSET

이 순서는 중요한 함의를 가집니다: **WHERE 절에서 윈도우 함수의 결과를 직접 필터링할 수 없습니다**. 윈도우 함수는 WHERE 실행 이후에 계산되기 때문입니다.

```sql
-- 올바르지 않은 사용법 (오류 발생)
SELECT employee_id, salary,
       ROW_NUMBER() OVER (ORDER BY salary DESC) AS rank
FROM employees
WHERE rank <= 10;  -- 오류: WHERE에서 윈도우 결과 참조 불가

-- 올바른 사용법 (CTE 또는 서브쿼리 사용)
WITH ranked_employees AS (
    SELECT employee_id, salary,
           ROW_NUMBER() OVER (ORDER BY salary DESC) AS rank
    FROM employees
)
SELECT *
FROM ranked_employees
WHERE rank <= 10;
```

---

## 주요 윈도우 함수 카테고리

### 순위 및 번호 매기기 함수
이 함수들은 데이터의 순서나 위치를 나타냅니다.

```sql
-- 다양한 순위 함수 비교
SELECT 
    employee_id,
    department_id,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) AS row_num,
    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS rank,
    DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS dense_rank,
    NTILE(4) OVER (PARTITION BY department_id ORDER BY salary DESC) AS quartile
FROM employees;
```

- **ROW_NUMBER()**: 각 행에 고유한 순번을 부여합니다. 동점이 있어도 다른 번호를 부여합니다.
- **RANK()**: 동점인 행에는 같은 순위를 부여하고, 다음 순위는 건너뜁니다(예: 1, 1, 3).
- **DENSE_RANK()**: 동점인 행에는 같은 순위를 부여하지만, 다음 순위를 건너뛰지 않습니다(예: 1, 1, 2).
- **NTILE(n)**: 데이터를 n개의 그룹으로 나눕니다.

### 집계 함수 (윈도우 버전)
일반 집계 함수를 윈도우 함수로 사용하면 행을 보존하면서 집계 값을 계산할 수 있습니다.

```sql
-- 부서별 급여 누적합
SELECT 
    employee_id,
    department_id,
    salary,
    SUM(salary) OVER (
        PARTITION BY department_id 
        ORDER BY hire_date
    ) AS running_total,
    AVG(salary) OVER (PARTITION BY department_id) AS dept_avg_salary,
    MAX(salary) OVER (PARTITION BY department_id) AS dept_max_salary
FROM employees;
```

### 이웃 참조 함수
이 함수들은 현재 행의 전후 행 값을 참조할 수 있게 해줍니다.

```sql
-- 이전 및 다음 거래 금액 확인
SELECT 
    customer_id,
    transaction_date,
    amount,
    LAG(amount, 1, 0) OVER (
        PARTITION BY customer_id 
        ORDER BY transaction_date
    ) AS previous_amount,
    LEAD(amount, 1, 0) OVER (
        PARTITION BY customer_id 
        ORDER BY transaction_date
    ) AS next_amount,
    FIRST_VALUE(amount) OVER (
        PARTITION BY customer_id 
        ORDER BY transaction_date
    ) AS first_transaction_amount
FROM transactions;
```

- **LAG(column, offset, default)**: 현재 행에서 offset만큼 이전 행의 값을 반환합니다.
- **LEAD(column, offset, default)**: 현재 행에서 offset만큼 이후 행의 값을 반환합니다.
- **FIRST_VALUE(column)**: 파티션의 첫 번째 값을 반환합니다.
- **LAST_VALUE(column)**: 파티션의 마지막 값을 반환합니다.

---

## 프레임 절: 윈도우의 범위 정의

프레임 절은 윈도우 함수가 계산될 범위를 정밀하게 정의합니다. 이는 이동 평균, 누적 합계 등 시간 기반 분석에 특히 중요합니다.

### 프레임 유형
1. **ROWS**: 물리적 행 수를 기준으로 범위를 정의합니다.
2. **RANGE**: 정렬 키의 값 범위를 기준으로 범위를 정의합니다.
3. **GROUPS**: 동일한 순위(동점)를 가진 행들을 그룹으로 묶어 범위를 정의합니다.

### 프레임 경계 지정
- **UNBOUNDED PRECEDING**: 파티션의 시작부터
- **UNBOUNDED FOLLOWING**: 파티션의 끝까지
- **CURRENT ROW**: 현재 행
- **n PRECEDING**: 현재 행부터 n개 이전까지
- **n FOLLOWING**: 현재 행부터 n개 이후까지

### 실전 예제
```sql
-- 3행 이동 평균 (ROWS 사용)
SELECT 
    date,
    sales_amount,
    AVG(sales_amount) OVER (
        ORDER BY date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS moving_avg_3
FROM daily_sales;

-- 값 범위 기반 이동 합계 (RANGE 사용)
SELECT 
    transaction_date,
    amount,
    SUM(amount) OVER (
        ORDER BY transaction_date
        RANGE BETWEEN INTERVAL '7' DAY PRECEDING AND CURRENT ROW
    ) AS weekly_running_total
FROM transactions;
```

### 주의사항: LAST_VALUE의 함정
LAST_VALUE 함수를 사용할 때는 프레임을 명시적으로 정의해야 합니다. 기본 프레임은 현재 행까지이므로 예상과 다른 결과가 나올 수 있습니다.

```sql
-- 잘못된 사용: 각 행마다 다른 "마지막 값"이 나옴
SELECT 
    department_id,
    salary,
    LAST_VALUE(salary) OVER (
        PARTITION BY department_id 
        ORDER BY salary
    ) AS wrong_last_value
FROM employees;

-- 올바른 사용: 전체 파티션을 프레임으로 지정
SELECT 
    department_id,
    salary,
    LAST_VALUE(salary) OVER (
        PARTITION BY department_id 
        ORDER BY salary
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS correct_last_value
FROM employees;
```

---

## 조건부 집계와 필터링

일부 데이터베이스는 윈도우 함수 내에서 조건부 집계를 지원합니다.

```sql
-- PostgreSQL: FILTER 절 사용
SELECT 
    customer_id,
    order_date,
    SUM(amount) FILTER (WHERE status = 'COMPLETED') 
        OVER (PARTITION BY customer_id ORDER BY order_date) AS completed_cumulative,
    SUM(amount) FILTER (WHERE status = 'CANCELLED') 
        OVER (PARTITION BY customer_id ORDER BY order_date) AS cancelled_cumulative
FROM orders;

-- 모든 데이터베이스 호환: CASE 문 사용
SELECT 
    customer_id,
    order_date,
    SUM(CASE WHEN status = 'COMPLETED' THEN amount ELSE 0 END) 
        OVER (PARTITION BY customer_id ORDER BY order_date) AS completed_cumulative,
    SUM(CASE WHEN status = 'CANCELLED' THEN amount ELSE 0 END) 
        OVER (PARTITION BY customer_id ORDER BY order_date) AS cancelled_cumulative
FROM orders;
```

---

## 실전 시나리오와 패턴

### 시나리오 1: 부서별 상위 급여자 식별
```sql
-- 부서별 급여 상위 3명 추출
WITH ranked_employees AS (
    SELECT 
        employee_id,
        department_id,
        salary,
        ROW_NUMBER() OVER (
            PARTITION BY department_id 
            ORDER BY salary DESC
        ) AS salary_rank
    FROM employees
)
SELECT *
FROM ranked_employees
WHERE salary_rank <= 3
ORDER BY department_id, salary_rank;
```

### 시나리오 2: 고객별 최신 주문 추출
```sql
-- 각 고객의 가장 최근 주문 1개만 선택
WITH latest_orders AS (
    SELECT 
        customer_id,
        order_id,
        order_date,
        amount,
        ROW_NUMBER() OVER (
            PARTITION BY customer_id 
            ORDER BY order_date DESC
        ) AS recency_rank
    FROM orders
)
SELECT *
FROM latest_orders
WHERE recency_rank = 1;
```

### 시나리오 3: 연속 로그인 일수 계산
```sql
-- 사용자별 연속 로그인 일수 계산 (Gaps and Islands 패턴)
WITH login_analysis AS (
    SELECT 
        user_id,
        login_date,
        -- 이전 로그인 날짜와 비교하여 새 그룹 시작 확인
        CASE 
            WHEN login_date = LAG(login_date) 
                OVER (PARTITION BY user_id ORDER BY login_date) + INTERVAL '1 day'
            THEN 0
            ELSE 1
        END AS is_new_streak
    FROM user_logins
),
streak_groups AS (
    SELECT 
        user_id,
        login_date,
        -- 누적 합으로 그룹 번호 부여
        SUM(is_new_streak) OVER (
            PARTITION BY user_id 
            ORDER BY login_date
        ) AS streak_id
    FROM login_analysis
)
SELECT 
    user_id,
    streak_id,
    MIN(login_date) AS streak_start,
    MAX(login_date) AS streak_end,
    COUNT(*) AS streak_length
FROM streak_groups
GROUP BY user_id, streak_id
HAVING COUNT(*) >= 3  -- 3일 이상 연속 로그인만 표시
ORDER BY user_id, streak_start;
```

### 시나리오 4: 매출 성장률 분석
```sql
-- 월별 매출과 전월 대비 성장률 계산
WITH monthly_sales AS (
    SELECT 
        DATE_TRUNC('month', order_date) AS month,
        SUM(amount) AS monthly_revenue
    FROM orders
    GROUP BY DATE_TRUNC('month', order_date)
)
SELECT 
    month,
    monthly_revenue,
    LAG(monthly_revenue, 1) OVER (ORDER BY month) AS previous_month_revenue,
    ROUND(
        (monthly_revenue - LAG(monthly_revenue, 1) OVER (ORDER BY month)) * 100.0 /
        NULLIF(LAG(monthly_revenue, 1) OVER (ORDER BY month), 0),
        2
    ) AS growth_percentage
FROM monthly_sales
ORDER BY month;
```

---

## 성능 최적화 전략

윈도우 함수는 강력하지만 대용량 데이터에서 성능 문제를 일으킬 수 있습니다. 다음 전략을 통해 성능을 최적화할 수 있습니다:

### 1. 적절한 인덱스 활용
```sql
-- 윈도우 함수에 자주 사용되는 컬럼에 인덱스 생성
CREATE INDEX idx_employees_dept_salary ON employees(department_id, salary DESC);
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date DESC);
```

### 2. 데이터 양 최소화
```sql
-- 필요한 데이터만 먼저 필터링
WITH filtered_data AS (
    SELECT * 
    FROM large_table 
    WHERE date >= '2024-01-01'  -- 조기 필터링
)
SELECT 
    *,
    SUM(amount) OVER (PARTITION BY category ORDER BY date) AS running_total
FROM filtered_data;
```

### 3. 파티션 크기 최적화
가능한 한 파티션을 작게 유지하여 각 윈도우 계산의 범위를 줄이세요.

### 4. 동일 윈도우 정의 재사용 (PostgreSQL)
```sql
-- WINDOW 절을 사용하여 동일한 윈도우 정의 재사용
SELECT 
    employee_id,
    department_id,
    salary,
    ROW_NUMBER() OVER w AS rank_in_dept,
    SUM(salary) OVER w AS running_total_in_dept,
    AVG(salary) OVER w AS avg_in_dept
FROM employees
WINDOW w AS (PARTITION BY department_id ORDER BY salary DESC);
```

### 5. 실행 계획 분석
복잡한 윈도우 함수 쿼리는 실행 계획을 확인하여 병목 현상을 파악하세요.

---

## 데이터베이스별 차이점

각 데이터베이스 관리 시스템은 윈도우 함수를 조금씩 다르게 구현하고 지원합니다:

| 기능 | PostgreSQL | MySQL 8+ | SQL Server | Oracle |
|------|------------|----------|------------|--------|
| **WINDOW 절** | 지원 | 미지원 | 미지원 | 미지원 |
| **FILTER 절** | 지원 | 미지원 | 미지원 | 미지원 |
| **GROUPS 프레임** | 지원 | 미지원 | 2022+ 지원 | 12c+ 지원 |
| **RANGE with 날짜** | 제한적 지원 | 제한적 지원 | 제한적 지원 | 강력한 지원 |
| **NULL 정렬 옵션** | 지원 | 지원 | 지원 | 지원 |

이러한 차이점을 인지하고, 가능하면 가장 널리 지원되는 기능을 사용하는 것이 이식성을 높이는 데 도움이 됩니다.

---

## 자주 발생하는 문제와 해결 방법

### 문제 1: WHERE 절에서 윈도우 결과 필터링 불가
**해결**: CTE(Common Table Expression)나 서브쿼리를 사용하여 윈도우 계산을 먼저 수행한 후, 바깥 쿼리에서 필터링하세요.

### 문제 2: LAST_VALUE가 예상과 다른 결과 반환
**해결**: 명시적으로 프레임을 정의하세요. 기본 프레임은 현재 행까지이므로 전체 파티션을 보고 싶다면 `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`을 사용하세요.

### 문제 3: 성능 저하
**해결**: 
- 파티션 및 정렬 키에 인덱스 생성
- 불필요한 데이터는 WHERE 절로 먼저 필터링
- 너무 많은 윈도우 함수를 한 쿼리에 사용하지 않기
- 실행 계획을 확인하여 병목 찾기

### 문제 4: 동점 처리 불일치
**해결**: 동점이 발생할 가능성이 있다면, 2차 정렬 키를 추가하여 결정적(deterministic) 결과를 보장하세요.

### 문제 5: NULL 값 정렬 문제
**해결**: NULL 값의 위치를 명시적으로 지정하세요. `ORDER BY column NULLS FIRST` 또는 `ORDER BY column NULLS LAST`

---

## 결론

윈도우 함수는 SQL 분석 기능의 정점에 위치한 강력한 도구입니다. 이들은 데이터를 그룹화하면서도 원본 행의 맥락을 유지할 수 있게 해주어, 복잡한 비즈니스 질문에 대한 답변을 단순하고 우아하게 표현할 수 있습니다.

윈도우 함수를 효과적으로 사용하기 위한 핵심 원칙은 다음과 같습니다:

1. **적절한 함수 선택**: 문제에 맞는 함수를 선택하세요. 순위가 필요하면 ROW_NUMBER, RANK, DENSE_RANK 중 적절한 것을, 누적 계산이 필요하면 SUM이나 AVG를 윈도우 함수로 사용하세요.

2. **파티션 이해**: PARTITION BY는 데이터를 논리적 그룹으로 나눕니다. 올바른 파티션 키 선택이 분석의 정확성을 결정합니다.

3. **프레임 명시**: 이동 평균이나 누적 계산이 필요할 때는 반드시 프레임을 명시적으로 정의하세요. 특히 LAST_VALUE 함수는 주의가 필요합니다.

4. **성능 고려**: 대용량 데이터에서는 윈도우 함수의 성능 영향을 고려하세요. 적절한 인덱스와 데이터 필터링으로 성능을 최적화하세요.

5. **데이터베이스 호환성**: 프로젝트가 여러 데이터베이스를 지원해야 한다면, 각 데이터베이스의 윈도우 함수 지원 현황을 이해하고 이식성 있는 코드를 작성하세요.

윈도우 함수는 처음에는 복잡해 보일 수 있지만, 기본 개념을 이해하고 실전 예제를 통해 연습하다 보면 점차 자연스럽게 사용할 수 있게 될 것입니다. 이러한 함수들을 마스터하면 단순한 데이터 조회를 넘어 진정한 데이터 분석가로서의 역량을 갖추게 될 것입니다.

가장 중요한 것은 실전에서 적용해보는 것입니다. 실제 비즈니스 문제에 윈도우 함수를 적용해보고, 다양한 패턴을 실험해보면서 익숙해지세요. 그러면 데이터로부터 더 깊은 통찰력을 얻을 수 있는 강력한 도구를 손에 넣게 될 것입니다.