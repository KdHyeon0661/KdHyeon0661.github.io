---
layout: post
title: 디지털신호처리 - 유한 정밀도 수치 영향의 개관 · 수의 표현
date: 2025-11-11 23:25:23 +0900
category: 디지털신호처리
---
# 유한 정밀도 수치 영향의 개관 · 수의 표현

## 왜 “유한 정밀도”를 먼저 이해해야 하나

디지털 신호처리는 **연속값**을 **이산 비트열**로 근사한다. 이는 본질적으로 **양자화(quantization)**이며, 그 결과:

- **표현 오류**: 실수 대부분은 정확히 표현 불가(예: \(0.1_{10}\)).
- **연산 오류**: 덧셈/곱셈 등 모든 연산에 **라운딩 오차**가 개입.
- **수치 불안정**: 큰 수에서 작은 수를 빼면 **유효자리 소실(cancellation)**.
- **동적 범위 제한**: **오버플로/언더플로/서브노멀**.

본 글은 앞선 FFT/컨볼루션/필터 구현 글들과 맞물려, **표현(부동/고정)**·**오차 모델**·**안정 알고리즘**을 DSP 실전 관점으로 체계화한다.

---

## 수의 표현 개관

### 실수 → 유한 비트 근사

컴퓨터 표현/연산을 \(\operatorname{fl}(\cdot)\)로 표기하면, 일반적으로
$$
\widehat{x}=\operatorname{fl}(x)=x(1+\delta),\qquad |\delta|\lesssim u,
$$
여기서 \(u\)는 **unit roundoff**(라운딩 상한, 대략 반 ULP), 흔히 \(\epsilon_\mathrm{mach}/2\)라 부르기도 한다.

### IEEE 754 부동소수점 개요

정규화 수(normalized)는
$$
x=(-1)^s\cdot(1.f)_2\cdot 2^{e-\mathrm{bias}},
$$
서브노멀(subnormal)은 선도 1이 없는
$$
x=(-1)^s\cdot(0.f)_2\cdot 2^{1-\mathrm{bias}}
$$
형태다. NaN, \(\pm\infty\)도 정의된다.

| 포맷 | 총비트 | 가수 유효비트 | 지수비트 | 바이어스 | 대략 유효 10진 자리 |
|---|---:|---:|---:|---:|---:|
| binary32 (float) | 32 | 24 | 8 | 127 | 약 7 |
| binary64 (double) | 64 | 53 | 11 | 1023 | 약 16 |

**머신 엡실론**의 흔한 정의는 \(1\)과 **그 다음 representable** 사이 간격:
$$
\epsilon_\mathrm{mach}=\mathrm{eps}(1)=2^{-52}\approx 2.220446049250313\times 10^{-16}\quad(\text{binary64}).
$$
문헌에 따라 \(u=\epsilon_\mathrm{mach}/2=2^{-53}\)를 “unit roundoff”로 구분하기도 하니 표기 일관성을 유지하자.

### 고정소수점(Fixed-Point)와 Q-포맷

Q\(m.n\) 포맷(부호 1비트 가정)의 해석:

- 표현 범위: \(\big[-2^m,\; 2^m-2^{-n}\big]\)
- 해상도: \(2^{-n}\)
- 장점: 연산비용 낮고 지연/예측성 우수(임베디드/FPGA/DSP)
- 단점: 동적범위 제한, 스케일 관리 필수

---

## 라운딩, ULP, 머신 엡실론

### 라운딩 모드

기본은 **Nearest, ties-to-even**(은행가 반올림). 그 외 **Toward \(\pm\infty\)**, **Toward zero**.
라운딩 모델:
$$
\operatorname{fl}(x\circ y)=(x\circ y)(1+\delta),\quad |\delta|\le u,\ \ \circ\in\{+,-,\times,\div\}.
$$

### ULP(Unit in the Last Place)

수 \(x\)에서 인접 표현 가능 수의 **간격**. Octave/MATLAB의 `eps(x)`가 사실상 \(\mathrm{ULP}(x)\).

- binary64에서 \(\mathrm{ULP}(1)=2^{-52}\).
- 일반적으로 \(\mathrm{ULP}(x)\approx 2^{\lfloor \log_2|x|\rfloor-52}\).

### Octave 실험 — eps/ULP/half-ULP

```octave
clear; clc
printf("eps(1)              = %.20g\n", eps(1.0));         % ULP at 1
printf("unit roundoff (u)   = %.20g\n", eps(1.0)/2);        % half ULP
printf("1 + eps(1)/2 == 1 ? %d\n", 1 + eps(1.0)/2 == 1.0);  % ties-to-even → true
for E = -300:100:300
  x = 2^E;
  printf("ULP(2^%4d) ~ %g\n", E, eps(x));
end
```

---

## 표현의 함정: 0.1, 결합법칙 붕괴, 소실/폭발

### 0.1이 정확히 표현되지 않는 이유

10진분수 대부분은 2의 거듭제곱 분모로 **유한 이진 전개 불가**. 반복 근사 → 누적 오차.

```octave
clear; clc
x = 0.0;
for k=1:10, x = x + 0.1; end
printf("sum of 0.1 ten times = %.17f\n", x);
printf("diff from 1          = %.3e\n", x - 1.0);
```

### 결합법칙(associativity) 붕괴

```octave
clear; clc
a = 1e16; b = -1e16; c = 1.0;
s1 = (a + b) + c;   % 기대: 1
s2 = a + (b + c);   % 기대: 1, 실제: 0
printf("(a+b)+c = %.1f,  a+(b+c) = %.1f\n", s1, s2);
```

### 소실(cancellation): 큰 값에서 작은 값 빼기

```octave
clear; clc
A = 1e8; epsv = 1.234567;
exact = epsv; num = (A + epsv) - A;
rel_err = abs(num - exact)/abs(exact);
printf("relative error after cancellation ~ %.3e\n", rel_err);
```

**대처**: 수식 재배열, 보상합(Kahan/Neumaier), 스케일링.

---

## 언더플로/서브노멀/오버플로

### 동적 범위와 서브노멀

- binary64 **정규화 최소양수**: \(\mathrm{realmin}\approx 2^{-1022}\approx 2.225\times 10^{-308}\)
- **최소 서브노멀**: \(2^{-1074}\approx 4.94\times 10^{-324}\)

```octave
clear; clc
x = realmin('double');  % 최소 정규
y = x/2;                % 서브노멀
printf("x=%.3e, y=%.3e\n", x, y);
k=0; z=x;
while z>0, z=z/2; k=k+1; end
printf("halvings until underflow: %d (down to 0)\n", k);
```

### FTZ/DAZ 정책

일부 하드웨어는 성능을 위해 **Flush-To-Zero**(서브노멀→0), **Denormals-Are-Zero**를 사용.
장점: 성능, 단점: 극소 신호/필터 테일 소실.

### 오버플로

범위 초과 → \(\pm\infty\) 또는 NaN 전파.

```octave
clear; clc
a = realmax('double'); b = 2;
printf("a*2 = %g\n", a*b);  % Inf
```

---

## 수치적 안정성과 알고리즘 선택

- **조건수**(well/ill-conditioning): 입력 변화가 출력에 얼마나 증폭되는가.
- **수치 안정 알고리즘**: 라운딩오차가 폭발하지 않도록 설계.

### 합의 안정화 — Kahan/Neumaier 보상합

```octave
function s = kahan_sum(x)
  s = 0.0; c = 0.0;
  for i=1:numel(x)
    y = x(i) - c;
    t = s + y;
    c = (t - s) - y;
    s = t;
  end
end

function s = neumaier_sum(x)
  s = 0.0; c = 0.0;
  for i=1:numel(x)
    t = s + x(i);
    if abs(s) >= abs(x(i)), c += (s - t) + x(i);
    else,                   c += (x(i) - t) + s; end
    s = t;
  end
  s += c;
end

% 비교
clear; clc
N=1e6; x = ones(1,N)*1e-8; x(1)=1.0;
printf("naive   = %.12f\n", sum(x));
printf("kahan   = %.12f\n", kahan_sum(x));
printf("neumaier= %.12f\n", neumaier_sum(x));
```

### FMA(Fused Multiply-Add) 개념과 모의실험

하나의 라운딩으로 \(a\times b+c\) 평가 → 점곱/필터 누산 정확도 ↑.
Octave에 직접 `fma`가 없을 수 있어 **가수 p비트 양자화 모형**으로 차이를 시연한다.

```octave
function y = quantize_mant(x, p)
  % p 유효비트로 가수 양자화(개념적)
  % frexp/ldexp 대용: log2로 스케일링
  s = sign(x); ax = abs(x);
  e = floor(log2(ax)); e(ax==0)=0;
  m = ax ./ (2.^e);
  m(ax==0)=0; e(ax==0)=0;
  mq = round(m * 2^(p-1)) / 2^(p-1);
  y = s .* mq .* (2.^e);
end

function y = fma_sim(a,b,c,p)
  % 비융합: prod 먼저 양자화 → 덧셈 → 양자화
  prod = quantize_mant(a*b, p);
  y = quantize_mant(prod + c, p);
end

function y = fma_fused_sim(a,b,c,p)
  % 융합: a*b+c 전체를 한번에 양자화
  y = quantize_mant(a*b + c, p);
end

clear; clc
a = 1e8 + 1; b = 1e-8; c = -1; p=10;
y1 = fma_sim(a,b,c,p);
y2 = fma_fused_sim(a,b,c,p);
printf("non-fused=%.12g, fused=%.12g, diff=%.3e\n", y1, y2, y1-y2);
```

---

## 고정소수점(정수) 수치 영향

### 균일 양자화 모델과 잡음

양자화 스텝 \(\Delta\)의 이상적 오류 \(e_q\sim\mathcal{U}(-\frac{\Delta}{2},\frac{\Delta}{2})\), 분산
$$
\sigma_q^2=\frac{\Delta^2}{12}.
$$

```octave
clear; clc
Delta = 1/256;
e = (rand(1,1e6)-0.5)*Delta;     % 모의 양자화 오차
printf("var(e) ≈ %.4e (theory %.4e)\n", var(e), Delta^2/12);
```

### Q-포맷 연산과 포화/래핑

```octave
function y = q_round(x, nfrac)  % 최근접 반올림
  s = 2^nfrac; y = round(x*s)/s;
end

function y = q_sat(x, nfrac)    % 포화
  maxv = 1 - 2^(-nfrac); minv = -1;
  y = min(max(q_round(x, nfrac), minv), maxv);
end

clear; clc
nfrac=8;
vals = [-2, -1.1, -0.99, 0.99, 1.2];
printf("wrap vs saturate (Q1.%d)\n", nfrac);
for v = vals
  w = q_round(v, nfrac); s = q_sat(v, nfrac);
  printf("x=%6.2f -> wrap=%6.2f, sat=%6.2f\n", v, w, s);
end
```

### 계수 양자화가 IIR에 미치는 영향

극이 단위원에 근접하면 미세 양자화가 큰 응답 변화 유발.

```octave
clear; close all; clc; pkg load signal
[b,a]=cheby1(6,0.5,0.2);               % 기준
nfrac = 12;
bq = round(b*2^nfrac)/2^nfrac;
aq = round(a*2^nfrac)/2^nfrac;
[H,w]  = freqz(b,a,2048);
[Hq,~] = freqz(bq,aq,2048);
printf("max |H-Hq| = %.3e\n", max(abs(H-Hq)));
p = roots(a); pq = roots(aq);
printf("max |p|-1   = %.3e, after quant = %.3e\n", max(abs(p))-1, max(abs(pq))-1);
```

---

## 오차 전파, 조건수, 안정한 재식화

### 상대오차 전파와 조건수

함수 \(y=f(x)\)에 대해
$$
\frac{|\delta y|}{|y|}\lesssim \kappa_f(x)\cdot \frac{|\delta x|}{|x|},\qquad
\kappa_f(x)=\left|\frac{x f'(x)}{f(x)}\right|.
$$
\(\kappa_f\gg 1\)이면 ill-conditioned.

### 다항 평가: Horner가 해법

$$
p(x)=a_0+x(a_1+x(a_2+\cdots)),
$$
연산 수 최소화, 라운딩 누산 억제.

```octave
function y = poly_naive(a, x)
  y=0; n=numel(a)-1;
  for k=0:n, y += a(k+1) * x.^k; end
end
function y = poly_horner(a, x)
  y=0; n=numel(a)-1;
  for k=n:-1:0, y = y.*x + a(k+1); end
end
clear; clc
a=[1 -3 3 -1]; x = 1 + 1e-8;
printf("naive-horner diff=%.3e\n", poly_naive(a,x)-poly_horner(a,x));
```

### 안정한 수식들(필수 팁)

- **log-sum-exp**: \(\log\sum_i e^{x_i}=\alpha+\log\sum_i e^{x_i-\alpha}\), \(\alpha=\max_i x_i\)
- **log1p/exp1m**: \(\log(1+x),\ \exp(x)-1\) 전용 함수 사용
- **hypot**: \(\sqrt{x^2+y^2}\) 오버/언더플로 방지
- **sinc** 근방: \(\frac{\sin x}{x}\)는 급수/`sinc` 사용
- **이차방정식**: \(\frac{-b\pm\sqrt{b^2-4ac}}{2a}\) 대신 수치 안정형
  $$
  q = -\tfrac{1}{2}\big(b+\mathrm{sign}(b)\sqrt{b^2-4ac}\big),\quad
  x_{1,2}=\frac{q}{a},\ \frac{c}{q}.
  $$
```octave
clear; clc
a=1; b=1e8; c=1;
x1_bad = (-b + sqrt(b^2 - 4*a*c)) / (2*a);
q = -0.5*(b + sign(b)*sqrt(b^2-4*a*c));
x1_good = q/a; x2_good = c/q;
printf("bad %.6g, good %.6g\n", x1_bad, x1_good);
```

---

## 통계 모델: 양자화 잡음, SNR, 디더

### 이상적 SNR

풀스케일 사인파의 이상적 SNR:
$$
\mathrm{SNR}\approx 6.02B + 1.76\ \mathrm{dB}\quad(\text{B: 비트 수}).
$$

### 디더(dither)로 왜곡 상쇄

```octave
clear; close all; clc
Fs=48000; t=(0:1/Fs:0.02);
x = 0.9*sin(2*pi*1000*t);
q = @(z) round(z*256)/256;
y0 = q(x);
yD = q(x + (rand(size(x))-0.5)*1e-3);  % 작은 디더
printf("RMS diff(no-dither vs dither)=%.3e\n", rms(y0 - yD));
```

---

## DSP 루틴에서의 수치 팁(필수 체크리스트)

1. **정규화/스케일링**: FFT/컨볼루션/필터 입력을 안전 범위 유지.
2. **SOS + DF-II-T**: 고정소수점 IIR의 표준 구현(내부 상태 작고 스케일링 용이).
3. **보상합**: 길고 이질적인 합/점곱.
4. **FMA**: 가능하면 점곱/필터 누산에 활용(단, 재현성 주의).
5. **서브노멀 정책**: FTZ/DAZ 사용 여부를 명확히.
6. **테스트**: `eps`, `realmin/max`, `isfinite`, `isnan`, 경계 케이스 포함 유닛 테스트.
7. **동일성 비교**: 절대/상대 허용 오차 기반 `almost_equal`.

```octave
function tf = almost_equal(a,b,rtol,atol)
  if nargin<3, rtol=1e-12; end
  if nargin<4, atol=1e-15; end
  tf = all(abs(a-b) <= atol + rtol*max(abs(a),abs(b)));
end
```

---

## 종합 실험 스크립트(한 번에 훑기)

```octave
clear; close all; clc; pkg load signal

printf("== eps/ULP sanity ==\n");
printf("eps(1) = %.20g, unit roundoff = %.20g\n", eps(1.0), eps(1.0)/2);

printf("\n== 0.1 accumulation ==\n");
x=0; for k=1:10, x=x+0.1; end
printf("sum 0.1 x10 = %.17f (diff=%.3e)\n", x, x-1.0);

printf("\n== cancellation ==\n");
A=1e8; e=1.234567; num=(A+e)-A;
printf("relative error ~ %.3e\n", abs(num-e)/e);

printf("\n== Kahan/Neumaier ==\n");
function s=kahan_sum(v), s=0; c=0; for i=1:numel(v), y=v(i)-c; t=s+y; c=(t-s)-y; s=t; end; end
function s=neumaier_sum(v), s=0; c=0; for i=1:numel(v), t=s+v(i); if abs(s)>=abs(v(i)), c+=(s-t)+v(i); else c+=(v(i)-t)+s; end; s=t; end; s+=c; end
N=1e6; v=ones(1,N)*1e-8; v(1)=1;
printf("naive=%.12f, kahan=%.12f, neumaier=%.12f\n", sum(v), kahan_sum(v), neumaier_sum(v));

printf("\n== Horner vs naive poly ==\n");
function y=poly_naive(a,x), y=0; n=numel(a)-1; for k=0:n, y+=a(k+1)*x.^k; end; end
function y=poly_horner(a,x), y=0; n=numel(a)-1; for k=n:-1:0, y=y.*x+a(k+1); end; end
a=[1 -3 3 -1]; xv=1+1e-8;
printf("diff=%.3e\n", poly_naive(a,xv)-poly_horner(a,xv));

printf("\n== IIR coefficient quantization ==\n");
[b,a]=cheby1(6,0.5,0.2); nfrac=12;
bq=round(b*2^nfrac)/2^nfrac; aq=round(a*2^nfrac)/2^nfrac;
[H,w]=freqz(b,a,1024); [Hq,~]=freqz(bq,aq,1024);
printf("max |H-Hq| = %.3e\n", max(abs(H-Hq)));

printf("\n== Subnormal walk ==\n");
x=realmin('double'); k=0; while x>0 && k<20, x=x/2; k++; printf("step %2d: x=%.3e\n", k, x); end
```

---

## 수학 요약

- 라운딩 모델
  $$
  \operatorname{fl}(x\circ y)=(x\circ y)(1+\delta),\qquad |\delta|\le u\approx \tfrac{1}{2}\mathrm{ULP}(1).
  $$
- 머신 엡실론(일반적 정의)
  $$
  \epsilon_\mathrm{mach}=\mathrm{ULP}(1)=2^{-52}\ (\text{binary64}),\quad u=\epsilon_\mathrm{mach}/2.
  $$
- 양자화 잡음 분산
  $$
  \sigma_q^2=\frac{\Delta^2}{12}.
  $$
- 이상적 SNR
  $$
  \mathrm{SNR}\approx 6.02B+1.76\ \mathrm{dB}.
  $$
- 조건수
  $$
  \kappa_f(x)=\left|\frac{x f'(x)}{f(x)}\right|.
  $$

---

## 마무리 — 실전 정리

- **표현/연산 오차**는 DSP 전 과정에 침투한다. IEEE 754(라운딩/ULP/서브노멀/NaN/Inf)와 Q-포맷(포화/래핑/스케일)을 정확히 이해해야 한다.
- **안정 알고리즘**을 선택하라: 보상합, Horner, log-sum-exp, 안정형 이차해법, `hypot/log1p/expm1`.
- **필터/IIR**는 **SOS+DF-II-T**를 기본으로, 계수 양자화/스케일링/섹션 순서를 관리하라.
- **FMA/FTZ/DAZ** 등 플랫폼 특성은 성능/정확도/재현성에 영향 → 정책 문서화.
- 본문의 Octave 실험을 자신의 파이프라인(FFT·컨볼루션·필터·선형대수)에 접목해, **정확도–성능–재현성** 균형점을 수치로 검증하라.
