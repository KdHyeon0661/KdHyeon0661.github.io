---
layout: post
title: 시스템보안 - 브라우저·문서·미디어 취약점
date: 2025-10-30 16:30:23 +0900
category: 시스템보안
---
# 브라우저·문서·미디어 취약점(시스템 관점)

## 렌더러/샌드박스/IPC 경계

### 현대 브라우저 프로세스 모델(개요)

- **브라우저 프로세스(Browser/Main)**
  - UI/탭 관리, 네트워크 스택 일부, 크레덴셜/프롬프트, 파일·프린트 브로커, 정책(엔터프라이즈)
  - 고권한(상대적): OS API 접근, 키체인/자격 흐름, 네이티브 프레임워크 호출 가능
- **렌더러(Renderer)**
  - HTML/CSS/JS/JIT/WebAssembly/DOM/레이아웃/JS 엔진
  - **샌드박스**(AppContainer/Seatbelt/seccomp-bpf)로 OS 권한 크게 제한
- **유틸리티/플러그인/미디어/네트워크 서브프로세스**
  - 코덱/폰트/이미지 디코더, PDF/Print, GPU(크롬의 GPU 프로세스) 등
- **IPC(Inter-Process Communication) 채널**
  - Mojo/Chromium IPC, Edge/Chrome은 Mojo 기반, Firefox는 IPDL, Safari는 XPC 등
  - **신뢰 경계**: 렌더러(비신뢰) → 브라우저/유틸리티(상대 신뢰)로 메시지 전달

**시스템 관점 핵심**
1) **취약점은 주로 비신뢰 입력 파서(렌더러/디코더)**에서 발생
2) **샌드박스가 1차 피해를 국소화**, 이후 **IPC를 통한 권한 상승/탈주** 시도가 2단계
3) **OS 커널/드라이버 스택**(GPU/폰트/파일시스템/프린트)과의 상호작용에서 **커널 사고** 가능

---

### 샌드박스 경계(Windows/macOS/Linux)

- **Windows**
  - AppContainer(저권한 토큰, Low/Untrusted IL), Job Object, Token/ACL, **Win32k Lockdown**(win32k=GUI GDI 시스템콜 차단), LPAC, **CFG/CET**
  - Broker는 파일/레지스트리/네트워크 등 제한된 대리 실행(정책 화이트리스트)
- **macOS**
  - Seatbelt Sandbox(플랫폼 프로파일), Hardened Runtime, TCC(카메라/마이크/파일 접근 승인), Code Signing + Entitlements
- **Linux**
  - **seccomp-bpf**(syscall 필터), **namespaces**(pid/net/mount/user), **cgroup**, **AppArmor/SELinux**
  - chroot/pledge(unveil, OpenBSD) 유사 모델도 개념적으로 참고

**정책 시사점**
- 렌더러는 **파일 오픈/디바이스 접근 불가**가 기본.
- 디코더/유틸리티 프로세스도 **능력 최소화**(권한 부여는 브로커 경유)

---

### IPC 설계의 보안 원칙(브로커/렌더러)

- **권한 상승 경로 단절**: 렌더러가 직접 OS 자원에 접근하지 않게 하며, **브로커가 정책 판단**
- **데이터/제어 분리**: 메시지에 파일 경로·핸들·식별자 등 **권한 정보를 직접 싣지 말고**, 브로커가 **새로 판정**
- **유효성 검증**: **형식 검증(스키마)** + **정책 검증(ACL/경로/용량)** + **상태 검증(존재/소유/샌드박스 규칙)**
- **Idempotency**: **재전송/리플레이**에도 안전 (nonce/토큰/세션 검증)
- **Quota/Rate**: 대용량 전송/폭주 방지 (DoS 완화)

**예시: “PDF 저장” 브로커 호출 IPC 설계 스케치**
```c
// (설명용 의사 인터페이스)
message SavePdfRequest {
  bytes document_blob_sha256; // 원본 Blob 해시
  uint64 file_id;             // 브로커가 발급한 임시 파일 토큰 (권한 포함)
  uint32 max_bytes;           // 상한 (정책/프리셋)
}

message SavePdfResponse {
  enum Status { OK=0, INVALID=1, POLICY_DENY=2, QUOTA=3, INTERNAL=4 }
  Status status;
  uint64 bytes_written;
}
```
**브로커 검증 체크리스트**
1) **file_id** 토큰은 브로커가 발급한 **임시 capability**인지(세션 바인딩/만료)
2) 대상 경로는 **다운로드 디렉토리 정책** 내인지(외부 경로/링크 금지)
3) **max_bytes** 상한 + 실제 입력 길이 검증
4) **hash(bind)**: 문서 Blob이 렌더러가 보낸 것과 동일(조작 방지)

---

### IPC 취약 설계 안티패턴 → 안전 대안

**안티패턴 A — 경로 신뢰**
```c
// 렌더러가 보낸 경로를 그대로 열어버림 (취약)
OpenFileRequest { string path; }
```
- 심볼릭 링크/경로 트래버설/UNC 경로/장치 경로(`\\.\`) 오용 가능

**대안 A — 핸들/토큰 기반 + 화이트리스트**
```c
// 브로커가 먼저 저장 대상을 지정하고, 렌더러는 핸들만 사용
OpenFileRequest { uint64 handle_token; } // broker-issued
```
- 브로커가 경로/권한을 직접 결정, 렌더러는 내용만 전달

**안티패턴 B — 대용량 무제한 IPC 메시지**
```c
// payload 크기 검증 없음 → 브로커 메모리 고갈/두 번 복사
RenderToPdf { bytes payload; }
```
**대안 B — 공유 메모리/파일 매핑 + 사이즈 상한**
- **파일 매핑/SHM**을 브로커가 생성, **분할 전송**과 **최대치** 강제

**안티패턴 C — 자유 형식 메시지**
- 임의 구조체/가변 필드, **버전 호환성 없음** → 파서 취약/혼선
**대안 C — 스키마/버전 필드**(Cap’n Proto/Protobuf/Mojo)로 명세

---

### 샌드박스 정책 예(개념)

**Linux seccomp-bpf 스니펫(설명용)**
```text
# 허용: read, write, exit, futex, recvmsg, sendmsg, mmap, mprotect(readonly code), clock_gettime ...
# 차단: open/openat(O_NOFOLLOW 강제, 디렉토리 화이트리스트만 허용), ptrace, clone3, io_uring_setup, bpf, keyctl
# outbound 금지(렌더러), AF_UNIX만(브로커 IPC)

```

**Windows AppContainer(개념)**
- LowIL/UntrustedIL, **Capability 없는 레지스트리/파일 접근 금지**
- **Win32k Lockdown** on (GDI/USER32 시스템콜 차단), 필요 시 **GPU 프로세스**가 GDI 대리

---

### 방어: Site Isolation / JIT 제한 / 메모리 보호

- **Site Isolation**: 서로 다른 사이트를 **서로 다른 렌더러 프로세스**로, X-Process Origin 정책
- **JIT 제한**: JIT 페이지 권한 전환 최소화(Write XOR Execute), JITless 모드 옵션
- **CFI/CET/BTI**: 간접 호출/리턴 보호, ROP/JOP 난이도 상승
- **堆 분리/쿼런틴**: Scudo, PartitionAlloc 등 **힙 영역 분리**로 UAF 악성 상호작용 축소

---

## 폰트/이미지/코덱 파서 취약점의 OS 영향

> **공통 구조**: [컨테이너(예: MP4/Matroska)] → [스트림(비트스트림)] → [디코더(코덱)] → [표면/버퍼] → [컴포저/드라이버]
> **취약점 핫스팟**: 길이/오프셋/인덱스 계산, 허프만/가변길이 파싱, 예외 처리/오버리드, 정수 오버플로.

---

### 폰트 파서(OTF/TTF/WOFF/WOFF2)

- **테이블 기반**(glyf, CFF, cmap, kern …): **오프셋·길이**가 상호 의존
- **문제 패턴**:
  - 테이블 경계 체크 누락 → **OOB Read/Write**
  - 16-bit/32-bit 길이 연산 **정수 오버플로** → 작은 버퍼에 큰 길이 복사
  - **복잡한 지시어**(hinting) → VM/인터프리터 경계 취약
- **OS 영향**:
  - 브라우저/문서 뷰어 내 폰트 디코더에서 크래시 → 샌드박스 내 **RCE 시도**
  - GPU 텍스처 업로드/서브픽셀 렌더링 경로를 통해 **드라이버 경계**에 추가 영향 가능

**취약 예시(교육용, 간소화) — 길이 신뢰**
```cpp
// ❌ 안티패턴: 테이블 길이 len을 그대로 믿고 memcpy
bool read_table(const uint8_t* file, size_t n, uint32_t off, uint32_t len, std::vector<uint8_t>& out) {
  out.resize(len); // 큰 값이면 bad_alloc / 후속 memcpy OOB
  std::memcpy(out.data(), file + off, len); // 경계 체크 없음
  return true;
}
```

**안전 대안**(상한/경계/합산 오버플로 체크)
```cpp
bool read_table_safe(const uint8_t* file, size_t n, uint32_t off, uint32_t len, std::vector<uint8_t>& out) {
  constexpr uint32_t kMax = 1<<20;      // 1MB 상한(정책)
  if (len > kMax) return false;
  if (off > n) return false;
  if (n - off < len) return false;      // underflow 회피
  out.assign(file + off, file + off + len);
  return true;
}
```

**Fuzz 하네스(폰트 헤더 파서)**
```cpp
extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  if (size < 12) return 0; // sfnt 최소 헤더
  // 버전/numTables/offsets 검증 → 테이블 읽기 함수 호출
  // 목표: 크래시/UB 없이 실패 반환
  return 0;
}
```

---

### 이미지 파서(PNG/JPEG/WebP/AVIF/ICO…)

- **패턴 A — 색인/오프셋 계산 오류**:
  - `width * bpp` 곱셈 오버플로 → 작은 버퍼 할당 후 큰 memcpy
- **패턴 B — 런렝스/허프만 디코딩**:
  - 잘못된 토큰/부호화 → 루프 탈출 실패/오버리드
- **패턴 C — 메타(ICC/XMP/EXIF)**:
  - 길이 신뢰/중첩 구조 과다 → 파서 recursion/스택 폭발

**안티패턴 — 곱셈 오버플로**
```cpp
size_t row_bytes = width * 4;     // ❌ width 0x40000000 → overflow
std::vector<uint8_t> row(row_bytes);
memcpy(row.data(), src, row_bytes); // OOB
```

**안전 대안 — 체크드 산술**
```cpp
bool MulOverflow(size_t a, size_t b, size_t* out) {
  if (a == 0) { *out = 0; return true; }
  if (SIZE_MAX / a < b) return false;
  *out = a * b; return true;
}

size_t row_bytes;
if (!MulOverflow(width, 4, &row_bytes)) return false;
if (row_bytes > kRowMax) return false;
```

**ASan/UBSan 빌드로 파서 스모크 테스트**
```bash
clang++ -g -O1 -fsanitize=address,undefined -fno-omit-frame-pointer \
  png_reader.cpp -o png_reader_asan
```

---

### 미디어 코덱(H.264/H.265/VP9/AV1/MP3/AAC)

- **컨테이너**(MP4/MKV/WebM)와 **코덱 비트스트림**(NAL/OBU)의 **이중 파서**
- **핫스팟**:
  - 비트단위 파서(bitstream): **가변 길이**(Exp-Golomb, CABAC) 파싱 중 경계 누락
  - 프레임/슬라이스 인덱스/참조 프레임 관리 오류 → OOB
  - **하드웨어 가속 경로**(DXVA/VA-API/VideoToolbox)로 드라이버 상호작용 → **커널/드라이버 취약** 파급
- **OS 영향**:
  - 샌드박스 내 **RCE → IPC → 브로커 악용**
  - 드라이버 버그의 경우 **로컬 권한 상승/커널 크래시**로 이어질 수도

**예시(개념) — NAL 길이 파싱**
```cpp
// ❌ 안티패턴: nal_length 신뢰
uint32_t nal_length = ReadU32(be_ptr);
uint8_t* dst = new uint8_t[nal_length];
memcpy(dst, src, nal_length); // 길이·경계 검증 없음
```

**대안**
- `nal_length` 상한(코덱별 합리적 최대)
- `remaining >= nal_length` 체크
- 누적 합계 오버플로 방지 (`total + nal_length <= kStreamMax`)

---

### GPU/드라이버 경유 영향(브라우저에서 시스템으로)

- 렌더러가 디코딩한 프레임/타일/글리프는 **GPU 프로세스**나 OS 그래픽 스택에 전달
- **위험 경로**:
  - 악성 잘못형성 버퍼를 **GPU IPC/드라이버 IOCTL**로 전달 → 드라이버의 검증 미흡 시 커널 크래시/권한 상승 가능
- **방어**:
  - **GPU 프로세스 격리**, **드라이버 IOCTL 화이트리스트**, **입출력 버퍼 길이 재검증**
  - 최신 GPU 드라이버/OS 업데이트, **D3D/Metal/Vulkan 레이어**의 엄격한 검증 활성

---

### 문서 형식(PDF/Office)의 임베디드 미디어/폰트/스크립트

- **PDF**: 스트림 필터(Flate/LZW), 폰트 임베드, 이미지, **JavaScript**, 주석/링크/액션
- **Office**: OLE/OOXML, 매크로/VBA, ActiveX 임베드
- **핫스팟**: 필터/파서/색인/압축 해제, 임베디드 폰트/이미지의 **중첩 취약**
- **OS 영향**: 문서 뷰어 샌드박스 내 RCE → 파일 브로커/프린트 브로커로 권한 상승 시도

**안전 정책**
- 문서 뷰어 **샌드박스 강제**, **JS/매크로 기본 차단**
- 인쇄/파일 저장은 모두 **브로커 화이트리스트** + **사용자 제스처 필요**

---

### 미니 랩: 안전 디코더 스켈레톤 + Fuzz + Sanitizer

#### 안전 스켈레톤: “간단 이미지 헤더” 파서

```cpp
// safe_img.h
#pragma once
#include <cstddef>
#include <cstdint>
#include <optional>

struct ImgInfo { uint32_t w, h, bpp; };

std::optional<ImgInfo> ParseHeader(const uint8_t* data, size_t n);
```

```cpp
// safe_img.cpp
#include "safe_img.h"
#include <cstring>
#include <limits>

static bool ReadU32(const uint8_t* p, size_t n, size_t off, uint32_t& out) {
  if (off + 4 > n) return false;
  std::memcpy(&out, p+off, 4);
  return true;
}
static bool MulOverflow(uint32_t a, uint32_t b, uint32_t* out) {
  if (a && b > std::numeric_limits<uint32_t>::max()/a) return false;
  *out = a*b; return true;
}

std::optional<ImgInfo> ParseHeader(const uint8_t* data, size_t n) {
  if (!data || n < 12) return std::nullopt;
  uint32_t magic, w, h, bpp;
  if (!ReadU32(data, n, 0, magic) || magic != 0x31474D49) return std::nullopt; // 'IMG1'
  if (!ReadU32(data, n, 4, w) || !ReadU32(data, n, 8, h)) return std::nullopt;
  if (w == 0 || h == 0 || w > 1<<16 || h > 1<<16) return std::nullopt;
  bpp = 4; // RGBA
  uint32_t row;
  if (!MulOverflow(w, bpp, &row)) return std::nullopt;
  if (row > (1u<<24)) return std::nullopt; // 상한
  return ImgInfo{w, h, bpp};
}
```

#### Fuzz 하네스(libFuzzer)

```cpp
// fuzz_img.cpp
#include <cstddef>
#include <cstdint>
#include "safe_img.h"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  auto info = ParseHeader(data, size);
  (void)info;
  return 0;
}
```

#### 빌드 & Sanitizer

```bash
clang++ -g -O1 -fsanitize=address,undefined,fuzzer -fno-omit-frame-pointer \
  safe_img.cpp fuzz_img.cpp -o fuzz_img
./fuzz_img -max_total_time=60 -artifact_prefix=crashes/
```

- **목표**: 크래시/UB 없이 실패/성공을 명확히 반환
- **크래시 결과**는 **회귀 테스트**로 편입하여 장기 보호

---

### 운영 방어: 엔드포인트/브라우저/OS 정책

- **엔드포인트**
  - EDR/Sysmon: **프로세스 생성, 모듈 로드, 네트워크, 드라이버 로드** 감시
  - **파일 트러스트**: 문서/미디어 다운로더 경로(브라우저 캐시/Download)에서 **이상 실행 차단**
- **브라우저**
  - **업데이트 채널** 신속, **사이트 격리 켜기**, **JITless 옵션** 검토
  - **PDF/미디어/폰트**는 **유틸리티 프로세스 격리**와 **권한 최소화** 확인
- **OS**
  - Windows: **Exploit Protection**, **CFG/CET**, **AppContainer** 준수 앱 사용
  - macOS: **Hardened Runtime**, **TCC 프롬프트** 엄격화
  - Linux: **seccomp-bpf**/AppArmor/SELinux 프로파일 적용

---

### 시나리오 요점(브라우저/미디어)

1) **증상**: 특정 사이트/문서 열람 직후 탭 크래시/EDR 경보
2) **즉시 조치**:
   - **메모리 덤프**(가능 시) + **브라우저 크래시 리포트 수집**
   - 디스크 캐시/다운로드 항목(해시) 보존, URL/타임라인 추적
3) **분석**:
   - **실행 맥락**: 프로세스 트리(브라우저→유틸리티→GPU)
   - **모듈 로드**: 이미지/폰트/코덱 라이브러리 버전
   - **네트워크**: 해당 시각 egress 연결, DNS 질의
4) **완화**:
   - 브라우저/OS/드라이버 **패치**
   - 취약 코덱/폰트 **임시 비활성**(엔터프라이즈 정책)
   - URL 카테고리 차단, 게이트웨이 룰 보강

---

## 부록 A. IPC 입력 검증 유닛 테스트(개념)

```cpp
// broker_validate_unittest.cpp
#include <gtest/gtest.h>
#include "broker_validate.h"

TEST(Broker, DenyExternalPath) {
  SavePdfRequest r;
  r.file_id = 0;  // 미발급
  r.max_bytes = 100*1024*1024;
  // 경로 대신 토큰 요구 — 경로 넣으면 실패
  EXPECT_EQ(Validate(r), Status::INVALID);
}

TEST(Broker, Quota) {
  SavePdfRequest r{.file_id=IssueTempHandle(/*downloads*/true), .max_bytes=1024};
  // 2KB 전송 요청은 거절
  EXPECT_EQ(CheckQuota(r, 2048), Status::QUOTA);
}
```

---

## 부록 B. 샌드박스 정책 체크리스트

- [ ] 렌더러: **파일 오픈 금지**, 네트워크 **브로커 경유**
- [ ] 유틸리티(코덱/폰트/이미지): **별도 프로세스 격리**, **읽기 전용 FS**, **syscall 최소**
- [ ] GPU: **별도 프로세스**, IOCTL 화이트리스트/유효성 검사 강화
- [ ] IPC: **스키마/버전** + **사이즈 상한** + **토큰 기반 능력**
- [ ] 로깅: 크래시 덤프 심볼/버전 정보, **프라이버시 마스킹**
- [ ] 업데이트: 브라우저/코덱/드라이버 **자동 업데이트** 활성

---

# 결론

- 브라우저·문서·미디어 취약점은 **“파서 → 샌드박스 → IPC → OS/드라이버”**의 단계를 거치며 시스템에 영향을 미칩니다.
- **샌드박스**는 1차 피해를 국소화하지만, **IPC 설계 결함**이 있으면 브로커를 통해 **권한 상승**이 가능합니다.
- **폰트/이미지/코덱** 파서는 **경계/오버플로** 방어와 **상한·검증**이 핵심이며, **Sanitizer+Fuzz**가 실질적인 방어 품질을 좌우합니다.
- 운영 측면에서는 **격리·정책·업데이트·가시성(로그/크래시)**를 함께 설계해야 전체 체인이 안전합니다.
