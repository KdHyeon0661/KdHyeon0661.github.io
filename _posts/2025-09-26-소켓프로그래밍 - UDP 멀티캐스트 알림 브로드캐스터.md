---
layout: post
title: 소켓프로그래밍 - UDP 멀티캐스트 알림 브로드캐스터
date: 2025-09-26 20:25:23 +0900
category: 소켓프로그래밍
---
# 2) **UDP 멀티캐스트 알림 브로드캐스터** — TTL/Loopback 제어 + 재전송 정책

> 목표: 사내/클러스터 브로드캐스트에 흔히 쓰는 **UDP 멀티캐스트**로 “알림(announcement)”을 전파한다.  
> 전송 측(브로드캐스터)이 **TTL(홉 제한)**, **Loopback(자기 수신)**, **출구 인터페이스**를 정확히 제어하고,  
> **손실 보완을 위한 재전송 정책**(단순 중복 송신 / NAK 기반 재전송)을 구현한다.  
> 수신기(리시버)도 함께 제공해 **end-to-end** 확인 가능.

---

## 0. 멀티캐스트 한눈에 (IPv4/IPv6)

- **IPv4 멀티캐스트 대역**: `224.0.0.0/4`  
  - 링크-로컬 제어 트래픽: `224.0.0.x`(라우팅 X)  
  - 사설/조직 스코프(권장): `239.0.0.0/8` (RFC 2365)  
- **IPv6 멀티캐스트**: `ff00::/8` (스코프 바이트로 범위 지정: 링크/사이트/조직 등)
- **TTL / Hop Limit**  
  - IPv4: `IP_MULTICAST_TTL` (기본 1 => **로컬 링크까지만**)  
  - IPv6: `IPV6_MULTICAST_HOPS`  
- **Loopback**(자체 수신):  
  - IPv4: `IP_MULTICAST_LOOP` (기본 **켜짐**)  
  - IPv6: `IPV6_MULTICAST_LOOP`  
- **출구 인터페이스**:  
  - IPv4: `IP_MULTICAST_IF`(송신 인터페이스의 **IPv4 주소**로 지정)  
  - IPv6: `IPV6_MULTICAST_IF`(**ifindex**로 지정)

> 운영 팁  
> - 브로드캐스트 대역폭이 클수록 **스위치 IGMP 스누핑/MLD** 설정을 점검.  
> - 멀티캐스트는 **신뢰성 보장 X** → 애플리케이션 계층에서 **중복 송신/재전송/중복 억제**를 설계해야 한다.  
> - **MTU**: 멀티캐스트는 PMTUD가 제한적이다. 페이로드는 **작고 짧게**(≲1400B) 유지.

---

## 1. 와이어 포맷(알림 프레임)

UDP는 **메시지 경계**를 보존한다. 프레이밍을 최소화해 다음 헤더를 붙인다:

```c++
#pragma pack(push, 1)
struct McAnnHeader {
  uint32_t magic_be;     // "MCAN" = 0x4D43414E (big-endian 저장 권장)
  uint16_t version_be;   // v1
  uint16_t flags_be;     // bit0=ACKable(NAK 지원), etc.
  uint64_t seq_be;       // 브로드캐스터 단조 증가 시퀀스
  uint64_t ts_ns_be;     // 송신 시각(단조/모노토닉 or UTC epoch)
  uint32_t body_len_be;  // 알림 본문 길이(바이트)
  // (옵션) uint32_t crc32_be;
};
#pragma pack(pop)
```

- **`seq`**: 수신기가 **중복/손실 감지**에 사용.  
- **본문**: UTF-8 텍스트(키=값/JSON 등). **짧게 유지**(예: 1KB 이내).
- **버전/플래그**: 추후 확장(ACK/NAK, 압축 등).

---

## 2. 브로드캐스터 — C++23 단일 파일

> 기능
> - IPv4/IPv6 멀티캐스트 전송
> - **TTL/Hop Limit, Loopback, 출구 인터페이스** 설정
> - **중복 송신(repeat)** 및 **NAK 기반 재전송(선택)**  
> - **최근 N개 메시지 캐시**(NAK 재전송용)

빌드:  
```bash
g++ -std=c++23 -O2 -pthread mc_sender.cpp -o mc_sender
```

실행 예:  
```bash
# IPv4, 조직 스코프 239.1.2.3:5000, TTL=8, loopback off, eth0로 송신
./mc_sender --group 239.1.2.3 --port 5000 \
            --ttl 8 --loop 0 --iface eth0 \
            --text "deploy:ok" --interval 1000 --repeat 3 --rgap 20

# IPv6, ff15::1234 (organization-local), hop=8, ifindex 지정
./mc_sender --group ff15::1234 --port 5000 \
            --hop 8 --loop 1 --ifindex 3 \
            --stdin --repeat 2
```

### `mc_sender.cpp`

```cpp
// mc_sender.cpp — UDP 멀티캐스트 알림 브로드캐스터 (TTL/Loopback/IF 제어 + 재전송 정책)
// 빌드: g++ -std=c++23 -O2 -pthread mc_sender.cpp -o mc_sender

#include <arpa/inet.h>
#include <fcntl.h>
#include <ifaddrs.h>
#include <net/if.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#include <atomic>
#include <chrono>
#include <cstdint>
#include <cstring>
#include <deque>
#include <expected>
#include <iostream>
#include <mutex>
#include <optional>
#include <print>
#include <random>
#include <span>
#include <string>
#include <string_view>
#include <thread>
#include <vector>

using clock_mono = std::chrono::steady_clock;
using namespace std::chrono_literals;

#pragma pack(push, 1)
struct McAnnHeader {
  uint32_t magic_be;
  uint16_t version_be;
  uint16_t flags_be;
  uint64_t seq_be;
  uint64_t ts_ns_be;
  uint32_t body_len_be;
};
#pragma pack(pop)

static constexpr uint32_t MAGIC = 0x4D43414E; // "MCAN" big-endian 의미

struct Opt {
  std::string group;      // 239.1.2.3 or ff15::1234
  uint16_t port = 5000;
  int ttl = 1;            // IPv4 TTL
  int hop = 1;            // IPv6 Hop Limit
  int loop = 1;           // 1=enable loopback
  std::string iface;      // "eth0" (IPv4 주소 자동 탐색 시도), IPv6는 ifindex로 변환
  int ifindex = 0;        // 직접 지정도 가능
  bool from_stdin = false;
  std::string text;       // --stdin 대신 정적 텍스트 반복 전송
  int interval_ms = 0;    // 주기적 전송 (0이면 stdin 이벤트로만)
  int repeat = 1;         // 동일 메시지 중복 송신 횟수(손실완화)
  int rgap_ms = 10;       // 반복 간 간격(ms)
  bool enable_nak = false;// NAK 기반 재전송 활성화 여부(간단 구현)
  uint16_t nak_port = 0;  // NAK 수신용 유니캐스트 포트(0=비활성)
  size_t cache_n = 256;   // 최근 메시지 캐시
} opt;

// 최근 메시지 캐시 (seq -> raw datagram)
struct CacheItem {
  uint64_t seq;
  std::vector<std::byte> pkt;
};
static std::mutex g_cache_mu;
static std::deque<CacheItem> g_cache;

static std::atomic<uint64_t> g_seq{1};
static std::atomic<bool> g_running{true};

static void on_sig(int){ g_running.store(false); }

static std::optional<std::string> ipv4_of_iface(const std::string& ifname) {
  ifaddrs* ifs=nullptr;
  if (getifaddrs(&ifs)!=0) return std::nullopt;
  std::optional<std::string> out;
  for (auto* p=ifs; p; p=p->ifa_next) {
    if (!p->ifa_addr) continue;
    if (p->ifa_addr->sa_family != AF_INET) continue;
    if (ifname != p->ifa_name) continue;
    char buf[INET_ADDRSTRLEN]{};
    auto* in = (sockaddr_in*)p->ifa_addr;
    if (inet_ntop(AF_INET, &in->sin_addr, buf, sizeof(buf))) {
      out = buf; break;
    }
  }
  freeifaddrs(ifs);
  return out;
}

struct Sock {
  int fd{-1};
  int family{AF_UNSPEC};
  sockaddr_storage dst{};
  socklen_t dstlen{0};
};

static std::expected<Sock, std::string> open_sender() {
  addrinfo hints{}, *res=nullptr;
  hints.ai_family   = AF_UNSPEC;
  hints.ai_socktype = SOCK_DGRAM;
  hints.ai_flags    = AI_NUMERICHOST | AI_NUMERICSERV;

  char portbuf[16]; std::snprintf(portbuf, sizeof(portbuf), "%u", opt.port);
  if (getaddrinfo(opt.group.c_str(), portbuf, &hints, &res) != 0) {
    return std::unexpected("getaddrinfo failed");
  }

  Sock s{};
  for (auto* ai=res; ai; ai=ai->ai_next) {
    int fd = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
    if (fd<0) continue;
    s.fd = fd;
    s.family = ai->ai_family;
    std::memcpy(&s.dst, ai->ai_addr, ai->ai_addrlen);
    s.dstlen = (socklen_t)ai->ai_addrlen;

    // TTL/Hop Limit
    if (s.family == AF_INET) {
      unsigned char ttl = (unsigned char)std::clamp(opt.ttl, 0, 255);
      if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl))<0)
        std::print(stderr, "warn: set IP_MULTICAST_TTL failed: {}\n", strerror(errno));
      unsigned char loop = (unsigned char)(opt.loop ? 1 : 0);
      setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP, &loop, sizeof(loop));

      // 출구 인터페이스
      in_addr ifaddr{};
      if (!opt.iface.empty()) {
        if (auto ip = ipv4_of_iface(opt.iface)) {
          inet_pton(AF_INET, ip->c_str(), &ifaddr);
        } else {
          // 인터페이스명이 IPv4 주소인 경우
          if (inet_pton(AF_INET, opt.iface.c_str(), &ifaddr) != 1) {
            std::print(stderr, "warn: iface `{}` ipv4 addr not found, skip IP_MULTICAST_IF\n", opt.iface);
          }
        }
      }
      if (ifaddr.s_addr != 0) {
        if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &ifaddr, sizeof(ifaddr))<0)
          std::print(stderr, "warn: set IP_MULTICAST_IF failed: {}\n", strerror(errno));
      }
    } else if (s.family == AF_INET6) {
      int hops = std::clamp(opt.hop, 0, 255);
      if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &hops, sizeof(hops))<0)
        std::print(stderr, "warn: set IPV6_MULTICAST_HOPS failed: {}\n", strerror(errno));
      unsigned int loop = (unsigned int)(opt.loop ? 1 : 0);
      setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &loop, sizeof(loop));

      unsigned int ifx = opt.ifindex;
      if (ifx==0 && !opt.iface.empty())
        ifx = if_nametoindex(opt.iface.c_str());
      if (ifx!=0) {
        if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_IF, &ifx, sizeof(ifx))<0)
          std::print(stderr, "warn: set IPV6_MULTICAST_IF failed: {}\n", strerror(errno));
      }
    }

    freeaddrinfo(res);
    return s;
  }
  freeaddrinfo(res);
  return std::unexpected("socket open failed");
}

static std::vector<std::byte> build_datagram(std::string_view body, uint64_t seq) {
  McAnnHeader h{};
  h.magic_be    = htonl(MAGIC);
  h.version_be  = htons(1);
  h.flags_be    = htons(opt.enable_nak ? 0x0001 : 0x0000);
  h.seq_be      = htobe64(seq);
  auto now = std::chrono::duration_cast<std::chrono::nanoseconds>(clock_mono::now().time_since_epoch()).count();
  h.ts_ns_be    = htobe64((uint64_t)now);
  h.body_len_be = htonl((uint32_t)body.size());

  std::vector<std::byte> buf(sizeof(h) + body.size());
  std::memcpy(buf.data(), &h, sizeof(h));
  if (!body.empty())
    std::memcpy(buf.data()+sizeof(h), body.data(), body.size());
  return buf;
}

// 캐시에 저장 (NAK 재전송용)
static void cache_put(uint64_t seq, std::span<const std::byte> pkt){
  std::scoped_lock lk(g_cache_mu);
  if (g_cache.size() >= opt.cache_n) g_cache.pop_front();
  g_cache.push_back(CacheItem{seq, std::vector<std::byte>(pkt.begin(), pkt.end())});
}
static std::optional<std::vector<std::byte>> cache_get(uint64_t seq){
  std::scoped_lock lk(g_cache_mu);
  for (auto it = g_cache.rbegin(); it != g_cache.rend(); ++it){
    if (it->seq == seq) return it->pkt;
  }
  return std::nullopt;
}

// NAK 수신(유니캐스트 UDP) — 매우 단순한 형태: payload=잃어버린 seq(8바이트 BE)
static void nak_listener(uint16_t port, int mcast_fd, const Sock& sdesc){
  int fd = ::socket(sdesc.family, SOCK_DGRAM, 0);
  if (fd<0){ std::print(stderr,"warn: nak socket open fail: {}\n", strerror(errno)); return; }
  // 바인드(0.0.0.0 or [::])
  if (sdesc.family==AF_INET){
    sockaddr_in a{}; a.sin_family=AF_INET; a.sin_port=htons(port); a.sin_addr.s_addr=INADDR_ANY;
    if (::bind(fd, (sockaddr*)&a, sizeof(a))<0){ std::print(stderr,"nak bind fail: {}\n", strerror(errno)); ::close(fd); return; }
  } else {
    sockaddr_in6 a{}; a.sin6_family=AF_INET6; a.sin6_port=htons(port); a.sin6_addr=in6addr_any;
    if (::bind(fd, (sockaddr*)&a, sizeof(a))<0){ std::print(stderr,"nak bind6 fail: {}\n", strerror(errno)); ::close(fd); return; }
  }

  std::print("[nak] listening on port {}\n", port);
  std::array<std::byte, 16> buf{};
  while (g_running.load()){
    sockaddr_storage from{}; socklen_t fl=sizeof(from);
    ssize_t n = ::recvfrom(fd, buf.data(), buf.size(), 0, (sockaddr*)&from, &fl);
    if (n < 8) { if (n<0 && (errno==EINTR)) continue; std::this_thread::sleep_for(10ms); continue; }

    uint64_t be; std::memcpy(&be, buf.data(), 8);
    uint64_t missing = be64toh(be);
    if (auto pkt = cache_get(missing)){
      // 간단 정책: **다시 멀티캐스트** (청중 다수에게 유익)
      ssize_t m = ::sendto(mcast_fd, pkt->data(), pkt->size(), 0,
                           (const sockaddr*)&sdesc.dst, sdesc.dstlen);
      if (m<0) std::print(stderr, "nak retransmit sendto fail: {}\n", strerror(errno));
      else     std::print("[nak] retransmit seq {}\n", missing);
    }
  }
  ::close(fd);
}

static void usage(const char* prog){
  std::print(stderr,
    "usage: {} --group <addr> --port <p> [--ttl 1] [--hop 1] [--loop 0|1]\n"
    "           [--iface name|ipv4] [--ifindex N]\n"
    "           [--text STR|--stdin] [--interval ms] [--repeat N] [--rgap ms]\n"
    "           [--nak-port P --cache N]\n", prog);
}

int main(int argc, char** argv){
  // 기본값
  for (int i=1;i<argc;i++){
    std::string k=argv[i];
    auto need = [&](int& i)->std::string { if (i+1>=argc){ usage(argv[0]); std::exit(2);} return std::string(argv[++i]); };
    if (k=="--group")     opt.group = need(i);
    else if (k=="--port") opt.port  = (uint16_t)std::stoi(need(i));
    else if (k=="--ttl")  opt.ttl   = std::stoi(need(i));
    else if (k=="--hop")  opt.hop   = std::stoi(need(i));
    else if (k=="--loop") opt.loop  = std::stoi(need(i));
    else if (k=="--iface")opt.iface = need(i);
    else if (k=="--ifindex") opt.ifindex = std::stoi(need(i));
    else if (k=="--text") { opt.text = need(i); opt.from_stdin=false; }
    else if (k=="--stdin"){ opt.from_stdin=true; }
    else if (k=="--interval") opt.interval_ms = std::stoi(need(i));
    else if (k=="--repeat")   opt.repeat = std::stoi(need(i));
    else if (k=="--rgap")     opt.rgap_ms = std::stoi(need(i));
    else if (k=="--nak-port"){ opt.nak_port = (uint16_t)std::stoi(need(i)); opt.enable_nak=true; }
    else if (k=="--cache")    opt.cache_n = (size_t)std::stoul(need(i));
    else { usage(argv[0]); return 2; }
  }
  if (opt.group.empty() || !opt.port){ usage(argv[0]); return 2; }

  std::signal(SIGINT, on_sig);
  std::signal(SIGTERM, on_sig);

  auto s = open_sender();
  if (!s){ std::print(stderr,"open_sender: {}\n", s.error()); return 1; }
  std::print("[mcast] dst={} port={} fam={} ttl={} hop={} loop={} iface={} ifindex={}\n",
             opt.group, opt.port, s->family, opt.ttl, opt.hop, opt.loop, opt.iface, opt.ifindex);

  // NAK 리스너(옵션)
  std::jthread nak_thr;
  if (opt.enable_nak && opt.nak_port) {
    nak_thr = std::jthread([&]{ nak_listener(opt.nak_port, s->fd, *s); });
  }

  auto send_body = [&](std::string_view body){
    uint64_t seq = g_seq.fetch_add(1);
    auto pkt = build_datagram(body, seq);
    cache_put(seq, pkt);

    for (int i=0;i<opt.repeat;i++){
      ssize_t n = ::sendto(s->fd, pkt.data(), pkt.size(), 0,
                           (const sockaddr*)&s->dst, s->dstlen);
      if (n<0) std::print(stderr, "sendto: {}\n", strerror(errno));
      if (i+1<opt.repeat && opt.rgap_ms>0)
        std::this_thread::sleep_for(std::chrono::milliseconds(opt.rgap_ms));
    }
  };

  if (opt.from_stdin){
    // stdin에서 한 줄씩 읽어 송신 (interval_ms>0이면 그 주기로 heartbeat도 송신)
    std::string line;
    auto next = clock_mono::now();
    while (g_running.load()){
      // 논블로킹처럼: getline에 시간 제한을 두고 heartbeat
      if (opt.interval_ms>0){
        using namespace std::chrono;
        auto now = clock_mono::now();
        if (now >= next) {
          send_body(opt.text.empty() ? std::string_view{"heartbeat"} : std::string_view{opt.text});
          next = now + milliseconds(opt.interval_ms);
        }
      }
      if (std::getline(std::cin, line)){
        send_body(line);
      } else {
        // 입력 EOF면 heartbeat만 계속
        if (!opt.interval_ms) break;
        std::this_thread::sleep_for(10ms);
      }
    }
  } else if (!opt.text.empty() && opt.interval_ms>0) {
    while (g_running.load()){
      send_body(opt.text);
      std::this_thread::sleep_for(std::chrono::milliseconds(opt.interval_ms));
    }
  } else if (!opt.text.empty()) {
    send_body(opt.text);
  } else {
    usage(argv[0]);
    return 2;
  }

  return 0;
}
```

---

## 3. 리시버 — 멀티캐스트 조인 + 중복/손실 감지 + NAK 전송(옵션)

- IGMP/MLD 가입:
  - IPv4: `IP_ADD_MEMBERSHIP` (`ip_mreqn`으로 ifindex 지정 가능)  
  - IPv6: `IPV6_JOIN_GROUP`(`ipv6_mreq`)  
- **Loopback**(송신자가 자기 메시지를 받는지): 수신 소켓에도 `IP_MULTICAST_LOOP`/`IPV6_MULTICAST_LOOP`가 있다.  
- **중복 억제**: `last_seq`와 **슬라이딩 윈도우 비트셋**으로 간단한 중복/결손 검출.  
- **NAK**: 결손 감지 시, 랜덤 지터 후 **한 번만** 유니캐스트 NAK(8바이트 seq).

빌드:  
```bash
g++ -std=c++23 -O2 mc_recv.cpp -o mc_recv
```

실행 예:  
```bash
# IPv4
./mc_recv --group 239.1.2.3 --port 5000 --iface eth0 --nak-to 10.0.0.10:5500

# IPv6
./mc_recv --group ff15::1234 --port 5000 --ifindex 3
```

### `mc_recv.cpp`

```cpp
// mc_recv.cpp — UDP 멀티캐스트 리시버 (조인 + 중복/손실 감지 + NAK 송신 옵션)
#include <arpa/inet.h>
#include <ifaddrs.h>
#include <net/if.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#include <bitset>
#include <chrono>
#include <cstdint>
#include <cstring>
#include <optional>
#include <print>
#include <random>
#include <string>
#include <string_view>

using namespace std::chrono_literals;

#pragma pack(push, 1)
struct McAnnHeader {
  uint32_t magic_be;
  uint16_t version_be;
  uint16_t flags_be;
  uint64_t seq_be;
  uint64_t ts_ns_be;
  uint32_t body_len_be;
};
#pragma pack(pop)

static constexpr uint32_t MAGIC = 0x4D43414E;

struct Opt {
  std::string group;
  uint16_t port=5000;
  std::string iface;
  int ifindex=0;
  int loop=1;
  std::string nak_host; // "ip:port"
} opt;

static std::optional<std::pair<std::string,uint16_t>> parse_hp(std::string_view s){
  auto p = s.rfind(':'); if (p==std::string::npos) return std::nullopt;
  std::string host(s.substr(0,p));
  uint16_t port = (uint16_t)std::stoi(std::string(s.substr(p+1)));
  return {{host,port}};
}

static std::optional<std::string> ipv4_of_iface(const std::string& ifname) {
  ifaddrs* ifs=nullptr;
  if (getifaddrs(&ifs)!=0) return std::nullopt;
  std::optional<std::string> out;
  for (auto* p=ifs; p; p=p->ifa_next) {
    if (!p->ifa_addr) continue;
    if (p->ifa_addr->sa_family != AF_INET) continue;
    if (ifname != p->ifa_name) continue;
    char buf[INET_ADDRSTRLEN]{};
    auto* in = (sockaddr_in*)p->ifa_addr;
    if (inet_ntop(AF_INET, &in->sin_addr, buf, sizeof(buf))) {
      out = buf; break;
    }
  }
  freeifaddrs(ifs);
  return out;
}

int main(int argc, char** argv){
  for (int i=1;i<argc;i++){
    std::string k=argv[i];
    auto need=[&](int& i){ if (i+1>=argc){ std::print(stderr,"missing {}\n",k); std::exit(2);} return std::string(argv[++i]); };
    if (k=="--group")     opt.group = need(i);
    else if (k=="--port") opt.port  = (uint16_t)std::stoi(need(i));
    else if (k=="--iface")opt.iface = need(i);
    else if (k=="--ifindex") opt.ifindex = std::stoi(need(i));
    else if (k=="--loop") opt.loop = std::stoi(need(i));
    else if (k=="--nak-to") opt.nak_host = need(i);
  }
  if (opt.group.empty() || !opt.port){ std::print(stderr,"usage: --group --port\n"); return 2; }

  addrinfo hints{}, *res=nullptr;
  hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_DGRAM; hints.ai_flags=AI_NUMERICHOST|AI_NUMERICSERV;
  char pbuf[16]; std::snprintf(pbuf, sizeof(pbuf), "%u", opt.port);
  if (getaddrinfo(opt.group.c_str(), pbuf, &hints, &res)!=0){ std::print(stderr,"gai fail\n"); return 1; }

  int fd=-1, fam=AF_UNSPEC;
  sockaddr_storage bindsa{}; socklen_t blen=0;
  for (auto* ai=res; ai; ai=ai->ai_next){
    fd = ::socket(ai->ai_family, ai->ai_socktype, 0);
    if (fd<0) continue;
    fam = ai->ai_family;
    // 바인드(0.0.0.0:port / [::]:port)
    if (fam==AF_INET){
      sockaddr_in a{}; a.sin_family=AF_INET; a.sin_port=htons(opt.port); a.sin_addr.s_addr=INADDR_ANY;
      if (::bind(fd,(sockaddr*)&a,sizeof(a))<0){ ::close(fd); fd=-1; continue; }
      // LOOP
      unsigned char loop=(unsigned char)(opt.loop?1:0);
      setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP, &loop, sizeof(loop));
      // 가입
      ip_mreqn m{}; // ifindex 지정 가능
      auto* maddr = (sockaddr_in*)ai->ai_addr;
      m.imr_multiaddr = maddr->sin_addr;
      if (!opt.iface.empty()){
        if (auto ip = ipv4_of_iface(opt.iface)) inet_pton(AF_INET, ip->c_str(), &m.imr_address);
      }
      m.imr_ifindex = opt.ifindex;
      if (setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &m, sizeof(m))<0){
        std::print(stderr,"IP_ADD_MEMBERSHIP fail: {}\n", strerror(errno));
      }
      break;
    } else {
      sockaddr_in6 a{}; a.sin6_family=AF_INET6; a.sin6_port=htons(opt.port); a.sin6_addr=in6addr_any;
      if (::bind(fd,(sockaddr*)&a,sizeof(a))<0){ ::close(fd); fd=-1; continue; }
      unsigned int loop = (unsigned int)(opt.loop?1:0);
      setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &loop, sizeof(loop));
      ipv6_mreq m{};
      auto* maddr = (sockaddr_in6*)ai->ai_addr;
      m.ipv6mr_multiaddr = maddr->sin6_addr;
      m.ipv6mr_interface = (opt.ifindex? opt.ifindex : if_nametoindex(opt.iface.c_str()));
      if (setsockopt(fd, IPPROTO_IPV6, IPV6_JOIN_GROUP, &m, sizeof(m))<0){
        std::print(stderr,"IPV6_JOIN_GROUP fail: {}\n", strerror(errno));
      }
      break;
    }
  }
  freeaddrinfo(res);
  if (fd<0){ std::print(stderr,"socket/bind/join fail\n"); return 1; }
  std::print("[recv] joined {}:{} fam={} loop={}\n", opt.group, opt.port, fam, opt.loop);

  // NAK 목적지 준비(옵션)
  int nakfd=-1; sockaddr_storage nakto{}; socklen_t naklen=0;
  if (!opt.nak_host.empty()){
    if (auto hp = parse_hp(opt.nak_host)){
      addrinfo nh{}, *nr=nullptr;
      nh.ai_family=fam; nh.ai_socktype=SOCK_DGRAM; nh.ai_flags=AI_NUMERICHOST|AI_NUMERICSERV;
      char pb[16]; std::snprintf(pb, sizeof(pb), "%u", hp->second);
      if (!getaddrinfo(hp->first.c_str(), pb, &nh, &nr)){
        nakfd = ::socket(fam, SOCK_DGRAM, 0);
        std::memcpy(&nakto, nr->ai_addr, nr->ai_addrlen);
        naklen = (socklen_t)nr->ai_addrlen;
        freeaddrinfo(nr);
      }
    }
  }

  // 손실/중복 감지(최근 1024 윈도우)
  uint64_t last_seq = 0;
  static constexpr size_t W=1024;
  std::bitset<W> seen{};

  auto mark_and_missing = [&](uint64_t seq)->std::vector<uint64_t>{
    std::vector<uint64_t> miss;
    if (last_seq==0){ last_seq=seq; seen.reset(); seen.set(0); return miss; }
    if (seq<=last_seq){
      size_t dist = (size_t)(last_seq - seq);
      if (dist < W){
        if (seen.test(dist)) {
          std::print("[dup] seq {}\n", seq);
        } else {
          seen.set(dist);
        }
      } else {
        // 오래된 것: 무시
      }
      return miss;
    }
    // seq > last_seq: 새로운 범위
    uint64_t gap = seq - last_seq;
    if (gap >= W){
      // 큰 점프: 창을 리셋(이전 손실은 포기)
      seen.reset();
      last_seq = seq;
      seen.set(0);
      return miss;
    }
    // 창을 앞으로 슬라이드
    seen <<= gap;
    // 새로 들어온 seq
    seen.set(0);
    // 비트 1이 **수신됨**, 0이 **결손**
    for (uint64_t i=gap-1;i>=1 && i<gap;--i){ // i=gap-1..1
      if (!seen.test(i)) miss.push_back(last_seq + (gap - i));
    }
    last_seq = seq;
    return miss;
  };

  std::array<std::byte, 2048> buf{};
  std::mt19937 rng{std::random_device{}()};
  std::uniform_int_distribution<int> jitt(3,15); // NAK 지터(ms) — implosion 회피

  while (true){
    ssize_t n = ::recv(fd, buf.data(), buf.size(), 0);
    if (n < (ssize_t)sizeof(McAnnHeader)) { if (n<0 && errno==EINTR) continue; if (n<0) { perror("recv"); } continue; }

    McAnnHeader h{}; std::memcpy(&h, buf.data(), sizeof(h));
    if (ntohl(h.magic_be) != MAGIC) { std::print(stderr,"[warn] magic mismatch\n"); continue; }
    uint16_t ver = ntohs(h.version_be);
    uint16_t flags = ntohs(h.flags_be);
    uint64_t seq = be64toh(h.seq_be);
    uint32_t blen = ntohl(h.body_len_be);
    if (sizeof(h) + blen > (size_t)n) { std::print(stderr,"[warn] len mismatch\n"); continue; }
    std::string_view body((char*)buf.data()+sizeof(h), blen);

    auto miss = mark_and_missing(seq);
    if (!miss.empty()) {
      std::print("[loss] last={} got={} missing_count={}\n", (seq - (seq-last_seq)), seq, miss.size());
      if (nakfd>=0 && (flags & 0x0001)){
        // 결손 중 **가장 최근 것 하나만** NAK (간단화)
        uint64_t target = miss.back();
        std::this_thread::sleep_for(std::chrono::milliseconds(jitt(rng)));
        uint64_t be = htobe64(target);
        ::sendto(nakfd, &be, 8, 0, (sockaddr*)&nakto, naklen);
      }
    }

    std::print("[recv] seq={} ver={} len={} body=`{}`\n", seq, ver, blen,
               (blen>64? std::string(body.substr(0,64))+"..." : std::string(body)));
  }
}
```

---

## 4. 재전송 정책(설계 가이드)

### 4.1 단순 **중복 송신**(Repeated Multicast)
- **장점**: 리시버 피드백 필요 없음, 구현/운영 단순, 소수 손실에 강함.  
- **단점**: 네트워크 대역낭비(메시지 증가), burst 손실에는 여전히 취약.
- **권장 설정**: `--repeat 2~3`, `--rgap 10~30ms` (동일 패킷을 짧게 spacing)

### 4.2 **NAK 기반**(Negative ACK, selective retransmit)
- **아이디어**: 수신기가 **결손 seq**를 감지하면 **유니캐스트 NAK**를 송신자에게 보낸다.  
  송신자는 **캐시**에서 찾아 **재멀티캐스트**(혹은 유니캐스트)로 재전송.  
- **장점**: 대역 효율적(필요할 때만 재송).  
- **단점**: 다수 수신자 손실 시 **NAK implosion** 가능 → **지터/중복 억제** 필요.
- **지터**: NAK 전송 전 랜덤 지연(예: 3~15ms) → implosion 완화.  
- **중복 억제**: 동일 seq에 대해 수신자는 **한 번만 NAK**. 송신자는 **윈도우 동안 한 번만 재전송**.

> 본 예제는 **간단형 NAK**를 제공했다. 실전에서는:
> - 재전송은 **유니캐스트**(NAK 보낸 수신자에게만)로 전송(대역 절약)  
> - 또는 **re-multicast**(같은 손실이 다수일 때 유익)  
> - **캐시 윈도우**/메모리 상한/만료 정책(예: 최근 5초/1000개)  
> - **비연속 손실**을 일괄 요청할 수 있도록 **목록형 NAK**(연속 범위 압축)

### 4.3 ACK 기반(긍정 확인)
- 수신자가 모두 ACK를 보내면 송신자는 완료.  
- **문제**: 수신자 수가 많으면 **ACK implosion**. 일반 공지형 멀티캐스트에는 **부적합**.  
- 추천하지 않음(특별한 폐회로 토폴로지에서만 고려).

### 4.4 FEC(Forward Error Correction) — 참고
- Reed-Solomon/LDP 같은 FEC를 얹어 **k개의 데이터 + r개의 패리티** 중 **k개 도착**으로 복원.  
- **장점**: 재전송 트래픽 없이 손실 보정.  
- **단점**: 구현 복잡/CPU 오버헤드, 짧은 알림에는 과도.

---

## 5. TTL/Hop, Loopback, 인터페이스 — 동작 확인

### 5.1 TTL/Hop
- **IPv4**: `IP_MULTICAST_TTL` 값이 **홉**(라우터 수) 한계. `1`이면 **로컬 링크에만**.  
- **IPv6**: `IPV6_MULTICAST_HOPS` 동일 의미.  
- 실험: 라우터/다른 L3 네트워크에 있는 호스트에서 수신되는지 체크.

### 5.2 Loopback
- 디폴트는 **자기 자신도 수신**(테스트 편리).  
- 운영에서 송신자가 **중복 처리**를 유발하면 `--loop 0`으로 꺼라.  
- 주의: 수신 소켓 측 Loopback 옵션도 구현체별 영향이 있다(대개 송신 소켓 옵션이 결정적).

### 5.3 출구 인터페이스
- 다중 NIC/서브넷인 호스트에서 **어느 인터페이스로 멀티캐스트를 내보낼지** 명시.  
- IPv4: `IP_MULTICAST_IF`에 **인터페이스의 IPv4 주소**를 넘김(예제는 ifname→IPv4 자동탐색).  
- IPv6: `IPV6_MULTICAST_IF`에 **ifindex** 지정.

---

## 6. 테스트 시나리오

1) **단일 호스트 로컬 테스트**  
   - 송신: `./mc_sender --group 239.1.2.3 --port 5000 --text hi --repeat 3 --rgap 10 --ttl 1`  
   - 수신: `./mc_recv   --group 239.1.2.3 --port 5000`
   - → 수신기에서 `seq` 증가, `dup` 없음 확인.

2) **NAK 재전송 확인**  
   - 수신기 여러 개 띄우고, 하나에 인위적 **패킷 드롭**(tc/netem):  
     ```bash
     sudo tc qdisc add dev eth0 root netem loss 5%
     ```  
   - 송신: `./mc_sender ... --nak-port 5500 --cache 512`  
   - 수신: `./mc_recv ... --nak-to <sender-ip>:5500`  
   - → `loss` 로그 후 **[nak] retransmit** 로그 관찰.

3) **인터페이스/TTL 확인**  
   - 송신 `--iface eth0 --ttl 8` / 수신은 다른 L3 네트워크에서 조인.  
   - TTL=1로 바꾸면 **수신 안 됨** 확인.

> 테스트 종료 후 `tc qdisc del dev eth0 root`로 원복.

---

## 7. 운영 체크리스트

- [ ] 멀티캐스트 주소: **조직 스코프(IPv4 239/8, IPv6 ff15::/ff1e::)** 사용  
- [ ] TTL/Hop Limit: **링크/사이트/조직 범위**에 맞게 설정  
- [ ] Loopback: 송신/수신 **중복 여부**에 따라 끄기/켜기  
- [ ] 출구 IF: 다중 NIC일 때 **명시**  
- [ ] 페이로드: **작게(≲1400B)**, MTU 초과 X  
- [ ] 재전송: **repeat 2~3** + (옵션) **NAK**(지터, 캐시 윈도우)  
- [ ] 스위치/라우터: **IGMP/MLD 스누핑** 설정, 멀티캐스트 라우팅 정책 확인  
- [ ] 모니터링: **수신율, 손실률, 재전송률, NAK 수** / `ss -u` 큐 길이

---

## 8. 확장 & 주의

- **보안**: 사내망이라도 멀티캐스트 그룹 주소/포트는 **내부 문서화**하고, 방화벽에서 범위를 제한.  
- **암호화/인증**: 네트워크 모델에 따라 **DTLS** 또는 **메시지 서명(HMAC)** 고려.  
- **시간/주기**: 알림이 주기적이라면 **시계 드리프트**를 고려해 수신기에서 **중복 억제 TTL**(최근 5초 내 동일 메시지 무시) 적용.  
- **분산 배포**: 멀티캐스트 라우팅을 피하고 싶다면(운영 단순화) **서브넷별 릴레이(유니캐스트 fanout)** 노드도 방법.

---

## 9. 요약

- **TTL/Hop/Loopback/Interface**는 멀티캐스트의 **가시 범위**와 **자기 수신**을 좌우하는 핵심 옵션이다.  
- 신뢰성은 없으므로, **중복 송신**으로 1차 보완, 필요 시 **NAK**로 2차 보완을 하라.  
- 메시지는 짧고, 상태는 단순하게; 복잡한 신뢰성이 필요하면 **유니캐스트/HTTP/QUIC**나 **메시지 버스**를 검토하라.  
- 본 예제 두 개(`mc_sender`, `mc_recv`)만으로도 **현장 검증 가능한** 멀티캐스트 알림 시스템을 만들 수 있다.
