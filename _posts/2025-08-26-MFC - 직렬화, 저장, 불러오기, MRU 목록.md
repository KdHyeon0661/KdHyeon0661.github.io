---
layout: post
title: MFC - 직렬화, 저장, 불러오기, MRU 목록
date: 2025-08-26 18:25:23 +0900
category: MFC
---
# 직렬화(Serialization)와 저장/불러오기, MRU 목록 — MFC 문서형 앱 완전 가이드 (실전 예제 포함)

이 글은 MFC의 **문서/뷰(Document/View) 구조**에서 쓰이는 **직렬화(Serialization)**, **저장/불러오기 파이프라인**, **MRU(최근 문서 목록)**을 실전 예제 중심으로 **생략 없이** 정리합니다.  
“표준 흐름 → 커스터마이징 포인트 → 실무 체크리스트” 순으로 설명하고, 각 단계마다 **컴파일 가능한 MFC 코드 스니펫**을 제공합니다. 코드는 모두 ```로 감싸며, 본문은 ~~~markdown 블록으로 제공합니다.

---

## 0) 예제 프로젝트의 전제

- **플랫폼**: Visual Studio + MFC App (SDI/MDI 상관없음, 여기서는 SDI 기준)
- **문서 클래스**: `CMyDoc` ( `CDocument` 파생 )
- **뷰 클래스**: `CMyView` ( `CView` 파생 )
- **앱 클래스**: `CMyApp` ( `CWinApp` 파생 )
- **데이터 모델**:
  - 간단한 레코드 목록 `std::vector<Record>`  
  - 그래프 구조(노드·엣지) 예시: `CObject` 파생 타입과 MFC 직렬화 매크로 이용  
- **파일 포맷**: 헤더(매직+버전) + 본문(레코드 & 그래프)  
- **원자적 저장(Atomic Save)**: 임시 파일로 저장 후 `ReplaceFileW`로 교체  
- **MRU**: `LoadStdProfileSettings` + `AddToRecentFileList`

---

## 1) 직렬화(Serialization) 핵심 개념

### 1-1. 직렬화가 동작하는 곳

- **문서 클래스(`CDocument` 파생)**의 `Serialize(CArchive& ar)`는 **저장/불러오기 양쪽 모두의 진입점**입니다.
  - 저장 시: `ar.IsStoring() == TRUE`
  - 불러오기 시: `ar.IsStoring() == FALSE`

### 1-2. `CArchive`의 역할

- **바이너리 스트림 어댑터**: `CFile`(디스크 파일), `CMemFile`(메모리 버퍼) 등 **저장소와 객체 간** 연결
- **형식 안정성**: 기본형, `CString`, `CObject*`(런타임 클래스 정보 포함) 등을 **안전하게** 입출력
- **중복 포인터 처리**: 동일 포인터가 여러 번 등장해도 **객체 ID 맵**으로 **중복 생성 방지**(그래프/공유참조 지원)

### 1-3. 직렬화 가능한 타입

- **`CObject` 파생 + 매크로 등록**: `DECLARE_SERIAL / IMPLEMENT_SERIAL` 사용  
- **MFC 컨테이너**: `CArray`, `CList`, `CMap` 등은 요소가 직렬화 가능하면 자동 직렬화 지원  
- **STL 컨테이너**: 프레임워크 기본 지원이 아니므로 **반복문으로 직접 요소 직렬화**

### 1-4. 포맷 버전(스키마) 관리

- `IMPLEMENT_SERIAL(MyClass, Base, VERSION)`의 `VERSION`은 **MFC 스키마 번호**  
- 불러오기 시 `ar.GetObjectSchema()` 또는 객체 생성 후 `GetRuntimeClass()->m_wSchema`로 저장 당시 버전을 확인  
- **권장**: 스트림 **최앞단에 매직+파일포맷 버전**을 저장한 뒤, 버전에 따른 마이그레이션 분기를 둡니다.

---

## 2) 데이터 모델 정의 (간단 레코드 + 그래프)

### 2-1. 간단 레코드 타입 (STL 컨테이너 직렬화 예제)

```cpp
// Record.h
#pragma once
#include <afx.h>
#include <string>

struct Record
{
    int         id{};
    CString     name;     // 유니코드 문자열
    double      value{};

    // STL이므로 직접 Serialize 도우미를 작성(문서의 Serialize에서 호출)
    void Store(CArchive& ar) const
    {
        ar << id;
        ar << name;
        ar << value;
    }
    void Load(CArchive& ar)
    {
        ar >> id;
        ar >> name;
        ar >> value;
    }
};
```

### 2-2. 그래프 노드/엣지 (CObject 파생 + 매크로 직렬화)

```cpp
// Graph.h
#pragma once
#include <afx.h>

class CGraphNode : public CObject
{
    DECLARE_SERIAL(CGraphNode)
public:
    CGraphNode() = default;
    CGraphNode(int nid, const CString& label) : m_id(nid), m_label(label) {}
    virtual ~CGraphNode() {}

    int     m_id{};
    CString m_label;

    virtual void Serialize(CArchive& ar) override
    {
        CObject::Serialize(ar);
        if (ar.IsStoring())
        {
            ar << m_id << m_label;
        }
        else
        {
            ar >> m_id >> m_label;
        }
    }
};

class CGraphEdge : public CObject
{
    DECLARE_SERIAL(CGraphEdge)
public:
    CGraphEdge() = default;
    CGraphEdge(CGraphNode* s, CGraphNode* t, double w) : m_src(s), m_dst(t), m_weight(w) {}
    virtual ~CGraphEdge() {}

    // 포인터 직렬화: CObject 파생 포인터는 CArchive가 객체 ID로 관리하여 중복 생성 방지
    CGraphNode* m_src{nullptr};
    CGraphNode* m_dst{nullptr};
    double      m_weight{};

    virtual void Serialize(CArchive& ar) override
    {
        CObject::Serialize(ar);
        if (ar.IsStoring())
        {
            ar << m_src;
            ar << m_dst;
            ar << m_weight;
        }
        else
        {
            ar >> m_src;
            ar >> m_dst;
            ar >> m_weight;
        }
    }
};
```

```cpp
// Graph.cpp
#include "pch.h"
#include "Graph.h"

IMPLEMENT_SERIAL(CGraphNode, CObject, 1)
IMPLEMENT_SERIAL(CGraphEdge, CObject, 1)
```

---

## 3) 파일 헤더(매직+버전)와 문서 클래스 골격

### 3-1. 파일 헤더 구조체 정의

```cpp
// FileFormat.h
#pragma once
#include <afx.h>

static const DWORD kMyMagic = 0x4D594446; // 'MYDF' 예시
static const WORD  kMyVersion = 0x0002;   // 파일 포맷 버전 (증분)

struct FileHeader
{
    DWORD magic;
    WORD  version;
    WORD  reserved; // 정렬/확장용

    void Store(CArchive& ar) const
    {
        ar << magic;
        ar << version;
        ar << reserved;
    }
    void Load(CArchive& ar)
    {
        ar >> magic;
        ar >> version;
        ar >> reserved;
    }
};
```

### 3-2. 문서 클래스 멤버 (레코드 + 그래프)

```cpp
// MyDoc.h
#pragma once

#include <afxwin.h>
#include <vector>
#include "Record.h"
#include "Graph.h"
#include "FileFormat.h"

class CMyDoc : public CDocument
{
protected:
    CMyDoc() noexcept;
    DECLARE_DYNCREATE(CMyDoc)

public:
    // 데이터: 레코드 & 그래프
    std::vector<Record>      m_records;
    CObArray                 m_nodes; // CObject* 컨테이너 (CGraphNode*)
    CObArray                 m_edges; // CObject* 컨테이너 (CGraphEdge*)

    // 상태
    BOOL     m_bLoading{ FALSE };      // 로딩 중 플래그(UX/진행률 등에 활용)
    CString  m_lastError;              // 오류 메시지 캐시

// Overrides
public:
    virtual BOOL OnNewDocument() override;
    virtual void Serialize(CArchive& ar) override;

    // 저장/불러오기 파이프라인 커스터마이즈
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName) override;
    virtual BOOL OnSaveDocument(LPCTSTR lpszPathName) override;

// 구현 도우미
protected:
    BOOL    LoadFromArchive(CArchive& ar);
    BOOL    StoreToArchive(CArchive& ar) const;

    // 원자적 저장
    BOOL    AtomicReplaceFile(LPCTSTR lpszPathName, const CString& tempPath, BOOL bKeepBackup, CString* pErrMsg);

    // 진행률/스트리밍 (예제)
    BOOL    StreamLoadRecords(CArchive& ar, UINT count);
    BOOL    StreamStoreRecords(CArchive& ar) const;

    // MRU 유틸
    void    TouchMRU();

public:
    virtual ~CMyDoc();
    DECLARE_MESSAGE_MAP()
};
```

```cpp
// MyDoc.cpp
#include "pch.h"
#include "MyDoc.h"
#include "MyApp.h" // CMyApp 접근용 (MRU 등)
#include <filesystem>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMyDoc, CDocument)

CMyDoc::CMyDoc() noexcept {}
CMyDoc::~CMyDoc()
{
    // 소유권 관리: CObArray는 포인터만 보관하므로 직접 delete 필요
    for (INT_PTR i=0; i<m_nodes.GetCount(); ++i)
        delete reinterpret_cast<CGraphNode*>(m_nodes[i]);
    for (INT_PTR i=0; i<m_edges.GetCount(); ++i)
        delete reinterpret_cast<CGraphEdge*>(m_edges[i]);
}

BEGIN_MESSAGE_MAP(CMyDoc, CDocument)
END_MESSAGE_MAP()

BOOL CMyDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

    // 초기 상태 설정
    m_records.clear();

    // 예시 초기 데이터
    m_records.push_back({1, _T("alpha"), 1.23});
    m_records.push_back({2, _T("beta"),  4.56});

    // 그래프 초기화
    auto* n1 = new CGraphNode(1, _T("A"));
    auto* n2 = new CGraphNode(2, _T("B"));
    m_nodes.Add(n1);
    m_nodes.Add(n2);
    m_edges.Add(new CGraphEdge(n1, n2, 10.0));

    SetModifiedFlag(FALSE);
    return TRUE;
}
```

---

## 4) 문서 직렬화 구현 (Serialize → Store/Load 분리)

> 실무에서는 `Serialize` 내부를 **짧게** 두고, 실제 로직은 `StoreToArchive / LoadFromArchive`로 위임하는 패턴이 유지·테스트에 유리합니다.

```cpp
// MyDoc.cpp (계속)
void CMyDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        StoreToArchive(ar);
    }
    else
    {
        LoadFromArchive(ar);
    }
}

BOOL CMyDoc::StoreToArchive(CArchive& ar) const
{
    // 1) 파일 헤더 쓰기 (매직 + 버전)
    FileHeader hdr{};
    hdr.magic = kMyMagic;
    hdr.version = kMyVersion;
    hdr.reserved = 0;
    hdr.Store(ar);

    // 2) 레코드 개수/내용 스트리밍 저장
    UINT count = static_cast<UINT>(m_records.size());
    ar << count;
    for (const auto& rec : m_records)
        rec.Store(ar);

    // 3) 그래프 저장: 노드/엣지 개수 + CObject 포인터 직렬화
    UINT nodeCount = static_cast<UINT>(m_nodes.GetCount());
    UINT edgeCount = static_cast<UINT>(m_edges.GetCount());
    ar << nodeCount << edgeCount;

    for (UINT i=0; i<nodeCount; ++i)
    {
        // CObject* 직렬화: 객체 생성/스키마를 CArchive가 내부 관리
        ar << reinterpret_cast<CObject*>(m_nodes[i]);
    }
    for (UINT i=0; i<edgeCount; ++i)
    {
        ar << reinterpret_cast<CObject*>(m_edges[i]);
    }
    return TRUE;
}

BOOL CMyDoc::LoadFromArchive(CArchive& ar)
{
    m_bLoading = TRUE;
    m_lastError.Empty();

    TRY
    {
        // 1) 파일 헤더 읽기/검증
        FileHeader hdr{};
        hdr.Load(ar);
        if (hdr.magic != kMyMagic)
            AfxThrowArchiveException(CArchiveException::badClass, ar.m_strFileName);
        // 버전 분기 예시
        if (hdr.version > kMyVersion)
            AfxThrowArchiveException(CArchiveException::badSchema, ar.m_strFileName);

        // 2) 레코드 읽기
        UINT count = 0; ar >> count;
        m_records.clear(); m_records.reserve(count);
        for (UINT i=0; i<count; ++i)
        {
            Record r;
            r.Load(ar);
            m_records.push_back(std::move(r));
        }

        // 3) 그래프 읽기: CObject 포인터 복원
        UINT nodeCount=0, edgeCount=0;
        ar >> nodeCount >> edgeCount;

        // 기존 소유 포인터 정리
        for (INT_PTR i=0; i<m_nodes.GetCount(); ++i)
            delete reinterpret_cast<CGraphNode*>(m_nodes[i]);
        for (INT_PTR i=0; i<m_edges.GetCount(); ++i)
            delete reinterpret_cast<CGraphEdge*>(m_edges[i]);
        m_nodes.RemoveAll();
        m_edges.RemoveAll();

        for (UINT i=0; i<nodeCount; ++i)
        {
            CObject* pObj = nullptr; ar >> pObj;
            auto* pNode = DYNAMIC_DOWNCAST(CGraphNode, pObj);
            if (!pNode) AfxThrowArchiveException(CArchiveException::badClass, ar.m_strFileName);
            m_nodes.Add(pNode);
        }
        for (UINT i=0; i<edgeCount; ++i)
        {
            CObject* pObj = nullptr; ar >> pObj;
            auto* pEdge = DYNAMIC_DOWNCAST(CGraphEdge, pObj);
            if (!pEdge) AfxThrowArchiveException(CArchiveException::badClass, ar.m_strFileName);
            m_edges.Add(pEdge);
        }
    }
    CATCH(CArchiveException, e)
    {
        m_lastError.Format(_T("불러오기 실패: %s (code=%d)"), ar.m_strFileName.GetString(), e->m_cause);
        TRACE(_T("%s\n"), m_lastError.GetString());
        m_bLoading = FALSE;
        return FALSE;
    }
    AND_CATCH(CFileException, e)
    {
        m_lastError = _T("파일 오류: ") + ar.m_strFileName;
        TRACE(_T("%s\n"), m_lastError.GetString());
        m_bLoading = FALSE;
        return FALSE;
    }
    AND_CATCH_ALL(e)
    {
        m_lastError = _T("알 수 없는 오류");
        TRACE(_T("%s\n"), m_lastError.GetString());
        m_bLoading = FALSE;
        return FALSE;
    }
    END_CATCH_ALL

    m_bLoading = FALSE;
    return TRUE;
}
```

> **버전 분기 팁**: `hdr.version`이 1이면 옛 필드만 읽고, 2 이상이면 새 필드를 추가로 읽는 식으로 **조건부 파싱**을 합니다.

---

## 5) 저장/불러오기 파이프라인 (Open/Save 오버라이드)

### 5-1. 불러오기: `OnOpenDocument`

```cpp
BOOL CMyDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
    // 공통 흐름: CFile + CArchive(loading) 구성 → Serialize 호출
    TRY
    {
        CFile file(lpszPathName, CFile::modeRead | CFile::shareDenyWrite);
        CArchive ar(&file, CArchive::load);
        if (!LoadFromArchive(ar))
            return FALSE;
    }
    CATCH_ALL(e)
    {
        ReportSaveLoadException(lpszPathName, e, FALSE, AFX_IDP_FAILED_TO_OPEN_DOC);
        return FALSE;
    }
    END_CATCH_ALL

    // 성공 → 제목/캡션 동기화, 더티 플래그 초기화
    SetPathName(lpszPathName, TRUE);
    SetModifiedFlag(FALSE);

    // MRU 갱신 (보통 프레임워크가 자동 갱신하지만 명시 호출 예시)
    TouchMRU();
    return TRUE;
}
```

### 5-2. 저장: `OnSaveDocument` (원자적 저장 적용)

```cpp
BOOL CMyDoc::OnSaveDocument(LPCTSTR lpszPathName)
{
    // 1) 임시 파일 경로 구성 (같은 폴더)
    CString tempPath(lpszPathName);
    tempPath += _T(".tmp");

    // 2) 임시 파일에 저장
    BOOL bOK = FALSE;
    TRY
    {
        CFile file(tempPath, CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive);
        CArchive ar(&file, CArchive::store);
        bOK = StoreToArchive(ar);
        ar.Close();
        file.Close();
    }
    CATCH_ALL(e)
    {
        ReportSaveLoadException(tempPath, e, TRUE, AFX_IDP_FAILED_TO_SAVE_DOC);
        return FALSE;
    }
    END_CATCH_ALL

    if (!bOK)
        return FALSE;

    // 3) 원자적 교체 (백업 유지 여부 선택 가능)
    CString err;
    if (!AtomicReplaceFile(lpszPathName, tempPath, /*bKeepBackup=*/TRUE, &err))
    {
        AfxMessageBox(err, MB_ICONERROR);
        return FALSE;
    }

    // 4) 성공 처리
    SetPathName(lpszPathName, TRUE);
    SetModifiedFlag(FALSE);
    TouchMRU();
    return TRUE;
}
```

### 5-3. 원자적 교체 함수

```cpp
BOOL CMyDoc::AtomicReplaceFile(LPCTSTR lpszPathName, const CString& tempPath, BOOL bKeepBackup, CString* pErrMsg)
{
    // Windows: ReplaceFileW(기존 파일→백업, 임시 파일→최종 파일) 사용
    CString backupPath(lpszPathName);
    backupPath += _T(".bak");

    // 기존 파일이 없을 수도 있으니, 그 경우 MoveFileEx로 대체
    if (!::PathFileExists(lpszPathName))
    {
        if (MoveFileEx(tempPath, lpszPathName, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH))
            return TRUE;
        if (pErrMsg) *pErrMsg = _T("원본이 없으며 MoveFileEx 교체 실패");
        return FALSE;
    }

    // 기존 파일이 있으면 ReplaceFileW 시도
    DWORD flags = REPLACEFILE_WRITE_THROUGH;
    if (!bKeepBackup)
    {
        // 백업 보관 원치 않으면 임시 경로로 백업 후 삭제 로직도 가능
        // 여기선 ReplaceFile에 백업 경로 전달 후, bKeepBackup=false면 삭제
    }

    if (!::ReplaceFile(lpszPathName, tempPath, backupPath, flags, nullptr, nullptr))
    {
        DWORD gle = GetLastError();
        if (pErrMsg) pErrMsg->Format(_T("ReplaceFile 실패 (GLE=%lu)"), gle);
        return FALSE;
    }

    if (!bKeepBackup)
        ::DeleteFile(backupPath);

    return TRUE;
}
```

---

## 6) `DoFileSave`, `SaveModified`와 종료 시 확인

- `ID_FILE_SAVE` → `CDocument::DoFileSave()`가 저장/다른 이름 저장을 적절히 호출  
- 닫기/종료 시 `CDocument::SaveModified()`가 **더티 플래그**(`IsModified()`)를 확인해 사용자에게 묻습니다.

### 6-1. 더티 플래그의 정확한 유지

- **데이터 변경 시 즉시** `SetModifiedFlag(TRUE)`  
- **저장 성공 후** `SetModifiedFlag(FALSE)`

> 실수로 더티 플래그를 놓치면 “저장 안 묻기/항상 묻기”가 발생합니다. 데이터 조작 경로(메뉴 핸들러, 명령 핸들러, 편집 다이얼로그 등)에서 일관되게 갱신하세요.

---

## 7) MRU(최근 문서 목록) 통합

### 7-1. 앱 시작 시 MRU 활성화

```cpp
// MyApp.cpp
BOOL CMyApp::InitInstance()
{
    // ...
    SetRegistryKey(_T("MyCompany")); // HKCU\Software\MyCompany\MyApp
    LoadStdProfileSettings(/*nMaxMRU=*/10); // MRU 최대 10개
    // ...
    return TRUE;
}
```

### 7-2. 문서 저장/열기 시 MRU 갱신

```cpp
void CMyDoc::TouchMRU()
{
    // 프레임워크가 보통 SetPathName(TRUE)로 갱신하지만,
    // 명시적으로도 가능 (특수 케이스 대비)
    CWinApp* pApp = AfxGetApp();
    if (pApp && !GetPathName().IsEmpty())
        pApp->AddToRecentFileList(GetPathName());
}
```

### 7-3. 존재하지 않는 항목의 정리

- 사용자가 MRU를 눌러 열기 실패 시, 프레임워크는 자동 정리를 시도합니다.
- 커스텀 정리 로직이 필요하면 `CRecentFileList` 포인터를 얻어 수동 삭제:

```cpp
// 예: 존재하지 않는 항목 일괄 정리
void CleanBrokenMRU()
{
    auto* pApp = AfxGetApp();
    if (!pApp) return;

    CRecentFileList* pMru = pApp->m_pRecentFileList;
    if (!pMru) return;

    for (int i = 0; i < pMru->GetSize(); ++i)
    {
        CString path = (*pMru)[i];
        if (!path.IsEmpty() && !::PathFileExists(path))
            pMru->Remove(i--);
    }
}
```

---

## 8) 대용량/스트리밍/진행률 UI

### 8-1. 스트리밍 저장/불러오기 (청크 처리)

```cpp
BOOL CMyDoc::StreamStoreRecords(CArchive& ar) const
{
    const UINT count = static_cast<UINT>(m_records.size());
    ar << count;

    // 대용량이면 중간중간 OnProgress(...) 메시지 전송 등
    for (UINT i=0; i<count; ++i)
    {
        m_records[i].Store(ar);
        if ((i % 1000) == 0)
            AfxGetMainWnd()->PostMessage(WM_APP + 1, i, count); // 진행률 이벤트
    }
    return TRUE;
}

BOOL CMyDoc::StreamLoadRecords(CArchive& ar, UINT count)
{
    m_records.clear(); m_records.reserve(count);
    for (UINT i=0; i<count; ++i)
    {
        Record r; r.Load(ar);
        m_records.push_back(std::move(r));
        if ((i % 1000) == 0)
            AfxGetMainWnd()->PostMessage(WM_APP + 1, i, count);
    }
    return TRUE;
}
```

> **팁**: UI 프리징 방지를 위해 **작업자 스레드**에서 파일 I/O를 수행하고, `PostMessage`로 진행률만 메인 스레드에 보고하는 구조가 안정적입니다.

---

## 9) 예외/오류 처리와 사용자 피드백

### 9-1. 표준 보고 함수

- `CDocument::ReportSaveLoadException`는 예외를 **사용자 친화 메시지**로 변환해 줍니다.

### 9-2. 사용자 안내 강화

- 경로 접근 권한, 디스크 공간 부족, 파일 잠금 등 **구체적 원인**을 알려주면 UX 향상
- 실패 시 임시 파일/백업 파일 **자동 정리** 또는 **보존(복구 가이드)**

---

## 10) 복수 파일 형식/필터/자동 판별

### 10-1. DocTemplate DocString 구성

- 리소스에서 DocString 형식: `문서이름\n파일필터\n확장자\n문서캡션\n...`  
- 예: `"MyData\nMyData Files (*.myd)\n.myd\nMyData Document\n..."`

### 10-2. 자동 판별(헤더 시그니처)

- 확장자 대신 **헤더 매직**으로 포맷을 판별하면 사용자 실수에 강함
- `OnOpenDocument`에서 파일 헤더만 먼저 읽어 **분기** → 해당 포맷 로더 호출

---

## 11) 버전 업그레이드(마이그레이션) 전략

### 11-1. 조건 분기 예제

```cpp
// FileFormat v1: [magic(DWORD)][version(WORD)][reserved(WORD)][count][records...]
// v2: v1 + [graph nodes/edges] 추가

BOOL CMyDoc::LoadFromArchive(CArchive& ar)
{
    FileHeader hdr{}; hdr.Load(ar);

    if (hdr.magic != kMyMagic)
        AfxThrowArchiveException(CArchiveException::badClass, ar.m_strFileName);

    if (hdr.version == 0x0001)
    {
        // v1 로드: 레코드만
        UINT count=0; ar >> count;
        m_records.clear(); m_records.reserve(count);
        for (UINT i=0; i<count; ++i) { Record r; r.Load(ar); m_records.push_back(std::move(r)); }

        // v1 → v2 마이그레이션: 그래프 기본값 생성
        auto* n1 = new CGraphNode(1, _T("migrated"));
        m_nodes.Add(n1);
    }
    else if (hdr.version == 0x0002)
    {
        // v2 로드(앞서 구현한 경로)
        // ...
    }
    else
    {
        AfxThrowArchiveException(CArchiveException::badSchema, ar.m_strFileName);
    }
    return TRUE;
}
```

### 11-2. 마이그레이션 가이드

- **필드 삭제 금지**(역직렬화 호환성 저해). 대신 **무시 가능한 필드**로 남기거나 버전 분기
- 구조가 크게 바뀌면 **Import/Export 경로**(JSON/CSV)를 통해 **중간 포맷**으로 변환 후 재저장을 검토

---

## 12) JSON Export/Import(가독성/디버깅용)

> 외부 라이브러리 없이 간단히 **사람이 읽기 쉬운 텍스트**를 제공하는 경량 경로 예시입니다.  
> (정식 JSON 파서는 RapidJSON/nlohmann/json 등을 고려하세요.)

```cpp
// MyDoc_JSON.cpp (간단 Export만 예시)
#include "pch.h"
#include "MyDoc.h"

BOOL CMyDoc::ExportJson(LPCTSTR lpszPathName) const
{
    CStdioFile f;
    if (!f.Open(lpszPathName, CFile::modeCreate | CFile::modeWrite | CFile::typeText))
        return FALSE;

    f.WriteString(_T("{\n"));
    f.WriteString(_T("  \"version\": 2,\n"));
    f.WriteString(_T("  \"records\": [\n"));

    for (size_t i=0; i<m_records.size(); ++i)
    {
        const auto& r = m_records[i];
        CString line;
        line.Format(_T("    {\"id\": %d, \"name\": \"%s\", \"value\": %.6f}%s\n"),
                    r.id, r.name.GetString(), r.value, (i+1<m_records.size()? _T(",") : _T("")));
        f.WriteString(line);
    }

    f.WriteString(_T("  ],\n"));
    f.WriteString(_T("  \"graph\": {\n"));

    // 노드/엣지 수만 기록(간단화)
    CString line;
    line.Format(_T("    \"nodes\": %d,\n"), (int)m_nodes.GetCount());
    f.WriteString(line);
    line.Format(_T("    \"edges\": %d\n"),   (int)m_edges.GetCount());
    f.WriteString(line);

    f.WriteString(_T("  }\n"));
    f.WriteString(_T("}\n"));

    f.Close();
    return TRUE;
}
```

---

## 13) 테스트 전략(골든 파일 & 회귀)

- **골든 파일 테스트**: 기준 바이너리(`.myd`)를 저장해 두고, “저장→불러오기→다시 저장→바이너리 비교” 또는 **객체 동등성 비교**
- **버전 호환 회귀**: v1/v2/v3 입력 파일 셋을 준비하고, 모두 정상 불러오기/재저장 되는지 CI에서 확인
- **큰 입력 스트레스**: 10만 레코드, 그래프 수만 노드 등 스트리밍/진행률/메모리 상한 확인

---

## 14) 셸 통합/명령줄/드래그·드롭/단일 인스턴스

- **파일 연결/아이콘**: `CWinApp::RegisterShellFileTypes(TRUE)`
- **명령줄 열기**: `ParseCommandLine(CCommandLineInfo&)` → `ProcessShellCommand` 경로에서 `OpenDocumentFile()`
- **드래그·드롭**: 프레임/뷰에 `DragAcceptFiles(TRUE)` + `OnDropFiles` → 전달받은 경로로 `OpenDocumentFile()`
- **단일 인스턴스**: 기존 인스턴스 감지 후 `WM_COPYDATA` 등으로 파일 경로 전달 → 기존 인스턴스가 `OpenDocumentFile()` 실행

---

## 15) 권한/UAC/경로 인코딩

- 사용자 데이터는 **%USERPROFILE%** 하위(예: `Documents\MyApp`)에 저장
- **유니코드 경로**(UTF-16) 기본, 외부 텍스트/CSV/JSON은 **BOM/인코딩 명시**
- 네트워크 드라이브, 클라우드 동기화 폴더의 **파일 잠금/버전 충돌** 케이스 고려

---

## 16) UX 체크리스트(실무 압축 요약)

1. **헤더(매직+버전)**로 확실한 포맷 식별  
2. **원자적 저장**: 임시 파일 → `ReplaceFileW` 교체, 백업 보관 옵션  
3. **더티 플래그**를 정확히: 변경 즉시 TRUE, 저장 성공 후 FALSE  
4. **스트리밍/진행률/취소**: 대용량에서 필수 (작업자 스레드 + `PostMessage`)  
5. **MRU 10~16개** & 깨진 경로 자동 정리  
6. **직렬화 금지 목록**: 핸들/스레드/캐시/외부 리소스는 저장하지 말고 **재생성**  
7. **JSON Export**로 디버깅·서포트 용이화  
8. **에러 복구**: 임시/백업 파일 보존 & 다음 실행 시 복구 제안

---

## 17) 전체 흐름 시나리오 (끝까지 따라가기)

1. **새 문서**(`ID_FILE_NEW`) → `OnNewDocument`에서 기본 데이터 구성  
2. **편집**(레코드 추가/삭제, 그래프 수정) → 각 조작 지점에서 `SetModifiedFlag(TRUE)`  
3. **저장**(`ID_FILE_SAVE`) → `OnSaveDocument` → 임시 파일에 `Serialize(store)` → `ReplaceFileW` → MRU 갱신  
4. **닫기** → `SaveModified()`가 물어봄 → 예 → 저장 성공 → 닫기  
5. **다시 열기**(`ID_FILE_OPEN`/MRU 클릭) → `OnOpenDocument` → `Serialize(load)` → 버전 분기/마이그레이션 처리  
6. **대용량 테스트**: 레코드 20만 건 입력 → 스트리밍 + 진행률 표시 확인

---

## 18) 추가 예제: STL 컨테이너 직렬화 유틸

```cpp
// SerializeUtil.h
#pragma once
#include <afx.h>
#include <vector>

template <typename T>
void SerializeVector(CArchive& ar, std::vector<T>& vec)
{
    if (ar.IsStoring())
    {
        UINT n = (UINT)vec.size();
        ar << n;
        for (auto& v : vec) v.Store(ar);
    }
    else
    {
        UINT n=0; ar >> n;
        vec.clear(); vec.reserve(n);
        for (UINT i=0; i<n; ++i)
        {
            T v; v.Load(ar);
            vec.push_back(std::move(v));
        }
    }
}
```

사용은 간단합니다:
```cpp
// CMyDoc::Serialize 내부에서
SerializeVector(ar, m_records);
```

---

## 19) 문제 해결 가이드(원인 → 해결)

- **불러오기 예외/크래시** → 포맷 버전/매직 불일치  
  - 헤더 검사 강화, 버전 분기 보완, 알 수 없는 필드 무시  
- **저장 후 파일 손상** → 부분 쓰기 중단/크래시  
  - 원자적 저장 적용(임시 파일→교체), 디스크 공간 체크  
- **MRU 클릭 시 열기 실패** → 파일 이동/삭제  
  - 실패 시 해당 항목 제거 + 안내  
- **로드 느림**  
  - 스트리밍, 압축 사용 시 작업자 스레드 분리, 필요 시 지연 로딩  
- **더티 플래그 이상**  
  - 모든 변경 경로에서 `SetModifiedFlag(TRUE)` 호출 확인(검색으로 점검)

---

## 20) 마무리

MFC의 직렬화/저장·불러오기/MRU는 **문서형 앱**의 생산성을 크게 끌어올리는 표준 장치입니다.  
이 글의 예제(헤더 매직+버전, 원자적 저장, 그래프 포인터 직렬화, MRU 관리, 스트리밍/진행률)는 **실무에서 바로 적용**할 수 있는 최소·필수 집합입니다.  
초기 설계에 **버전/복구/테스트 전략**을 함께 넣어두면, 장기적으로 **데이터 안정성**과 **유지보수성**을 동시에 확보할 수 있습니다.
