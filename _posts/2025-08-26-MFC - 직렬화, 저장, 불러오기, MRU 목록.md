---
layout: post
title: MFC - 직렬화, 저장, 불러오기, MRU 목록
date: 2025-08-26 18:25:23 +0900
category: MFC
---
# 직렬화(Serialization)와 저장/불러오기, MRU 목록 — MFC 문서형 앱 완전 가이드

이 글은 MFC의 **문서/뷰 구조**에서 쓰이는 **직렬화(Serialization)**, **저장/불러오기 파이프라인**, **MRU(최근 문서 목록)**를 생략 없이 정리합니다. 기능의 “표준 흐름 → 커스터마이징 포인트 → 실무 체크리스트” 순으로 설명합니다. (메서드/클래스 이름은 고정폭으로 표기)

---

## 1) 직렬화(Serialization) 핵심 개념

### 1-1. 직렬화가 동작하는 곳
- **문서 클래스(`CDocument` 파생)**의 `Serialize(CArchive& ar)`는 **저장/불러오기**의 **단일 진입점**입니다.  
  - 저장 시: `ar.IsStoring() == TRUE`  
  - 불러오기 시: `ar.IsStoring() == FALSE`

### 1-2. `CArchive`의 역할
- **바이너리 스트림 어댑터**: `CFile`(디스크 파일), `CMemFile`(메모리 버퍼) 등 **“저장소”와 객체 간**을 연결.
- **형식 안정성**: 원시 타입, `CString`, `CObject*`(런타임 클래스 정보 포함) 등을 안전하게 입출력.
- **중복 포인터 처리**: 동일 포인터가 여러 번 저장될 때 **객체 ID 맵**을 이용해 **중복 생성 방지**(그래프 구조 지원).

### 1-3. 직렬화 가능한 타입
- **`CObject` 파생 + 매크로 등록**: `DECLARE_SERIAL/IMPLEMENT_SERIAL`(MFC RTTI/스키마 버전)  
- **컬렉션**: `CArray`, `CList`, `CMap` 등 MFC 컨테이너는 요소가 직렬화 가능하면 **자동 직렬화** 지원.  
- **STL 컨테이너**: 프레임워크 지원 대상이 아니므로 **반복문으로 직접 요소 직렬화**.  
- **이미지/대형 버퍼**: `CArchive::Write/Read`로 **원시 바이트**를 저장(필요 시 헤더+길이 포함).

### 1-4. 버전 업그레이드를 위한 스키마(버저닝)
- `IMPLEMENT_SERIAL(MyClass, Base, VERSION)`의 `VERSION`은 **MFC가 스트림에 저장하는 스키마 번호**입니다.  
- 불러오기 시 `ar.GetObjectSchema()` 또는 `CObject::GetRuntimeClass()->m_wSchema`(객체 생성 후)로 **저장 당시 버전**을 읽어 **필드 조건 분기**를 수행합니다.  
- 대안: 문서 헤더에 **매직 문자열 + 파일 포맷 버전**을 먼저 기록(추천). 이후 구조 변경 시 **마이그레이션 로직**을 적용합니다.

---

## 2) 저장/불러오기 표준 파이프라인

### 2-1. 새 문서 생성
- `CWinApp::InitInstance`에서 `CSingleDocTemplate/CMultiDocTemplate` 등록 → `ID_FILE_NEW` 처리 시  
  - **문서 생성** → **프레임/뷰 생성** → `CView::OnInitialUpdate` 호출  
- 초기 상태 값은 `CDocument::OnNewDocument`에서 설정 (예: 빈 데이터, 기본 옵션)

### 2-2. 파일 열기(불러오기)
- `ID_FILE_OPEN` → DocTemplate가 `OpenDocumentFile(path)` 실행 → **문서 생성 후** `CDocument::OnOpenDocument(path)` 호출  
- `OnOpenDocument` 내부에서 `CFile` + `CArchive(loading)` 구성 → `Serialize(ar)` 호출 → **데이터 로드**  
- 성공 시 `CDocument::SetPathName(path, TRUE)`로 캡션/제목 동기화, `SetModifiedFlag(FALSE)`

### 2-3. 저장/다른 이름으로 저장
- `ID_FILE_SAVE` → `CDocument::DoFileSave()`  
- `ID_FILE_SAVE_AS` → 파일 대화상자 표시 → `CDocument::OnSaveDocument(path)` 호출  
- 일반적으로 `OnSaveDocument`에서 `CFile` + `CArchive(storing)` 구성 → `Serialize(ar)` 수행 → 성공 후 `SetPathName(path, TRUE)` + `SetModifiedFlag(FALSE)`

### 2-4. 종료/닫기 시 확인
- 문서가 변경된 상태(`IsModified()==TRUE`)이면 `CDocument::SaveModified()`가 **저장 여부 묻기** 대화상자를 자동 처리(Yes/No/Cancel).  
- 저장 성공 시 플래그 해제, 취소 시 닫기를 중단.

### 2-5. 예외와 오류 보고
- 파일/아카이브 작업 중 `CFileException`, `CArchiveException` 발생 가능.  
- 프레임워크 기본 처리: `CDocument::ReportSaveLoadException`이 사용자 메시지를 구성.  
- 실무에서는 `TRY/CATCH` 블록에서 로깅, 임시 파일 정리, 사용자 친화적 메시지(경로/권한/공간 부족) 제공.

---

## 3) 안전 저장(Atomic Save) 실전 패턴

대형 파일/중요 데이터는 “부분 기록 → 크래시”로 파일이 깨질 수 있습니다. 아래 전략을 권장합니다.

1. **임시 파일**(같은 디렉터리)로 먼저 저장: `name.tmp`  
2. 스트림 **flush/close** 후 실제 파일과 **교체**(원자적 교체: `ReplaceFile` / `MoveFileEx` with `MOVEFILE_REPLACE_EXISTING`)  
3. 백업 정책(옵션): 기존 파일을 `name.bak`로 보존(최근 N개 롤링)

이 로직은 `CDocument::OnSaveDocument` 내부에서 구현합니다. 저장 완료 후만 `SetPathName`/`SetModifiedFlag(FALSE)`를 호출합니다.

---

## 4) 파일 형식/필터/복수 템플릿

### 4-1. DocTemplate와 DocString
- DocTemplate 리소스의 **DocString**에 `\n` 구분으로 **메뉴 이름/파일 필터/확장자/문서 캡션 템플릿**을 정의.  
- **파일 대화상자 필터**는 DocString에서 자동 구성되며, SDI/MDI 모두 동일하게 동작.

### 4-2. 복수 형식 지원
- 서로 다른 형식(예: `.abc`, `.xyz`)을 지원하려면 **DocTemplate를 다중 등록**하거나  
  - 하나의 문서 클래스에서 `OnOpenDocument/OnSaveDocument`가 **확장자별 분기**로 처리할 수 있습니다.  
- “불러오기” 시 헤더 매직/시그니처를 읽어 **자동 판별**하는 것이 사용자 실수에 강합니다.

---

## 5) MRU(Recent File List) — 최근 문서 목록

### 5-1. 생성과 저장 위치
- `CWinApp::LoadStdProfileSettings(nMaxMRU)` 호출 시 **MRU 리스트(`CRecentFileList`)**가 생성됩니다.  
- 저장 위치(기본): **레지스트리 HKCU** (또는 INI) — `Software\<Company>\<App>\Recent File List`  
- 기본 개수는 보통 4개, `nMaxMRU`로 16개까지 확장(메뉴 리소스 ID 범위: `ID_FILE_MRU_FILE1`~`ID_FILE_MRU_FILE16`)

### 5-2. 목록 갱신
- 문서를 열거나 저장하면 `CWinApp::AddToRecentFileList(path)`를 호출해 **맨 위로 이동**(중복 제거)  
- 메뉴는 프레임워크가 **자동 확장/축약**하여 표시(비어 있으면 숨김)  
- 사용자가 MRU 항목을 클릭하면 해당 경로로 `OpenDocumentFile()`을 호출

### 5-3. 무결성/정리
- 존재하지 않는 항목은 열기 실패 시 **자동 제거**하거나, `CRecentFileList::Remove(n)`으로 즉시 삭제  
- **경로 표기 형식**: 사용자에게는 `CRecentFileList::GetDisplayName`로 **축약 경로**(중간 생략) 표시  
- **보안/개인정보**: 공용 PC/시演 환경에서는 MRU를 **기능 옵션화**(끄기/자동 삭제 주기)

---

## 6) 데이터 구조별 직렬화 디자인

### 6-1. 레코드/테이블형 데이터
- 헤더(매직·버전·레코드 수) → 레코드 반복 → 푸터(옵션).  
- 대형 데이터는 **청크(Chunk)** 단위로 분할 저장, 불러오기는 **스트리밍/부분 로딩**(진행률 UI와 궁합).

### 6-2. 그래프/참조형 데이터(노드·엣지·공유 포인터)
- `CArchive`의 **객체 ID 맵**을 활용하면 동일 객체 중복 생성 방지 가능(`CObject*` 직렬화 경로 사용).  
- **순환 참조**나 **외부 리소스 핸들**은 직렬화 대상에서 배제(핸들은 재생성).  
- 포인터 대신 **안정적 식별자(ID)**를 저장하고 불러오기 후 **리졸브 단계**에서 포인터 연결하는 방식이 안전.

### 6-3. 텍스트/JSON 병행 전략
- 앱 내부 저장은 바이너리(MFC 직렬화)로, **호환/디버깅/내보내기** 용도로 JSON(사람이 읽을 수 있는) **Export/Import**를 제공하면 운영이 쉽습니다.  
- JSON 스키마 버전 필드를 반드시 두고 역호환 로직을 마련.

---

## 7) 성능/안정성/UX 체크리스트

- **대용량 저장**: UI 프리징 방지 → **백그라운드 쓰레드 + 진행률/취소**(문서 더티 상태는 “저장 중” 별도 플래그로 보호)  
- **메모리 사용량**: 전체를 메모리에 올리지 말고 **스트리밍**(한 덩어리씩 Serialize)  
- **에러 복구**: 임시 파일/백업, 실패 시 원본 보존. 크래시 시 **다음 실행에 복구 제안**  
- **국제화**: 파일 경로/메타는 **UTF-16**(유니코드)로 관리, 외부 텍스트는 BOM/인코딩 명시  
- **권한/UAC**: 사용자 데이터는 `%USERPROFILE%` 하위, Program Files에 쓰지 않음  
- **테스트**: “저장→불러오기→동등성 비교” 자동화(골든 파일 테스트), **버전 간 호환성** 회귀 테스트

---

## 8) 고급: 셸 통합과 명령줄/드래그·드롭

- **파일 연결/아이콘/더블클릭 열기**: `CWinApp::RegisterShellFileTypes`(관리자 설치 시 레지스트리 등록)  
- **명령줄**: `CWinApp::ParseCommandLine(CCommandLineInfo&)` + `ProcessShellCommand`로 `OpenDocumentFile` 호출  
- **드래그·드롭**: 프레임/뷰에 파일을 드롭하면 경로를 받아 동일하게 불러오기 루틴으로 라우팅  
- **단일 인스턴스 열기**: 기존 실행 인스턴스에 **IPC/WM_COPYDATA**로 파일 경로 전달, 해당 인스턴스가 `OpenDocumentFile` 수행

---

## 9) 문제 해결 가이드(원인 → 해결)

- **불러오기 예외/크래시** → 포맷 버전 불일치  
  - 헤더 매직/버전 확인, **하위 호환 분기** 추가, 알 수 없는 필드는 무시  
- **저장 후 파일 손상** → 부분 쓰기 중단  
  - **안전 저장(임시 파일 + 교체)**, 쓰기 오류/공간 부족 상세 안내  
- **MRU 눌렀더니 안 열림** → 파일 삭제/이동  
  - 실패 시 **해당 항목 제거** + 사용자 알림  
- **문서 더티 플래그 오동작**  
  - 변경 시 **항상 `SetModifiedFlag(TRUE)`**, 저장 성공 시 `FALSE`  
- **로드가 느림**  
  - 스트리밍/지연 로딩, 압축 사용 시 CPU 사용량 고려(작업자 쓰레드 분리)

---

## 10) 실무 권장 규칙(요약)

1. **헤더(매직+버전)** → 구조 변경 대비  
2. **안전 저장**(임시 파일→원자 교체) 기본 적용  
3. **더티 플래그** 정확히 관리(Undo/Redo 포함)  
4. **대형 데이터 스트리밍** + 진행률/취소 UX  
5. **MRU 최대 10~16개** + 무결성 자동 정리  
6. **직렬화 금지 목록**(핸들/캐시/스레드 상태 등)은 명확히 정의  
7. **Export/Import**(JSON 등)로 디버깅/이식성 확보

---

### 마무리
MFC의 직렬화/저장·불러오기/ MRU는 **문서형 앱의 생산성을 폭발적으로 높여주는 표준 장치**입니다.  
위의 파이프라인과 체크리스트를 초기 설계에 반영하면, **대용량·장기 호환·안전 저장** 요구까지 안정적으로 충족할 수 있습니다.