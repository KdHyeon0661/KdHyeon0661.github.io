---
layout: post
title: 이산수학 - 포함-배제 원리
date: 2025-06-21 22:20:23 +0900
category: 이산수학
---
# 포함-배제 원리 (Principle of Inclusion–Exclusion, PIE)


## 0. 핵심 직관

- **중복을 정확히 한 번만 세자.**
  처음엔 “다 더하고(포함)”, 겹친 건 “빼고(배제)”, 너무 뺐으면 “다시 더하고”… **부호를 번갈아** 적용한다.

---

## 1. 정의와 공식

### 1.1 두·세 집합

$$
|A\cup B|=|A|+|B|-|A\cap B|
$$

$$
|A\cup B\cup C|
=|A|+|B|+|C|
-|A\cap B|-|B\cap C|-|C\cap A|
+|A\cap B\cap C|
$$

### 1.2 일반형 (n개 집합)

서로 다른 집합 \(A_1,\dots,A_n\)에 대해

$$
\Big|\bigcup_{i=1}^n A_i\Big|=
\sum_{1\le i}|A_i|
-\sum_{i<j}|A_i\cap A_j|
+\sum_{i<j<k}|A_i\cap A_j\cap A_k|
-\cdots
+(-1)^{n+1}|A_1\cap\cdots\cap A_n|.
$$

- **홀수 크기 교집합**은 **더하고**, **짝수 크기 교집합**은 **뺀다**.

### 1.3 확률 버전

사건 \(A_i\)에 대해

$$
\mathbb{P}\!\Big(\bigcup_{i=1}^n A_i\Big)=
\sum_i \mathbb{P}(A_i)
-\sum_{i<j}\mathbb{P}(A_i\cap A_j)
+\cdots+(-1)^{n+1}\mathbb{P}(A_1\cap\cdots\cap A_n).
$$

> **Bonferroni 부등식**: 부분합으로 상·하한을 준다(§10).

---

## 2. 워밍업 예제 (정수의 배수)

**문제**: \(1\ldots N\) 중에서 집합 \(D=\{d_1,\dots,d_m\}\)의 **적어도 하나의 배수** 개수?

- \(A_i=\{x\le N: d_i\mid x\}\)라 두면,
- \( |A_{i_1}\cap\cdots\cap A_{i_k}|=\left\lfloor \dfrac{N}{\mathrm{lcm}(d_{i_1},\dots,d_{i_k})}\right\rfloor \).

**PIE**:

$$
\#=\sum_i \Big\lfloor\frac{N}{\mathrm{lcm}(d_i)}\Big\rfloor
-\sum_{i<j}\Big\lfloor\frac{N}{\mathrm{lcm}(d_i,d_j)}\Big\rfloor+\cdots
$$

**파이썬**:
```python
from math import lcm
from itertools import combinations

def count_multiples_upto(N: int, divs: list[int]) -> int:
    ans = 0
    m = len(divs)
    for r in range(1, m+1):
        for comb in combinations(divs, r):
            L = lcm(*comb)
            if L == 0:
                continue
            if r % 2 == 1: ans += N // L
            else:          ans -= N // L
    return ans

print(count_multiples_upto(100, [2,3,5]))  # 74
```

**팁**: LCM이 \(>N\)이면 이후 큰 조합도 모두 0이므로 **가지치기** 가능(§9.3 코드 참조).

---

## 3. 조합 마스터 예제

### 3.1 **데랑주망(derangements)**: 고정점 없는 순열 수 \( !n \)

- \(S_n\) 전체 \(n!\)에서 **적어도 하나의 고정점**을 갖는 순열을 제외.
- \(A_i\): i가 고정점인 순열 집합 \(\Rightarrow |A_i|=(n-1)!\).
- \( |A_{i_1}\cap\cdots\cap A_{i_k}|=(n-k)!\).

PIE:

$$
!n = n! - \binom{n}{1}(n-1)! + \binom{n}{2}(n-2)! - \cdots + (-1)^n\binom{n}{n}0!
= n!\sum_{k=0}^n \frac{(-1)^k}{k!}.
$$

- 근사: \( !n \approx \left\lfloor \dfrac{n!}{e}+\tfrac12 \right\rfloor \).

**코드**:
```python
import math

def derangements(n: int) -> int:
    s = 0.0
    for k in range(0, n+1):
        s += ((-1)**k) / math.factorial(k)
    return round(math.factorial(n) * s)

for n in range(1,8):
    print(n, derangements(n))
```

**Rencontres**(정확히 \(k\)개의 고정점):
\(\displaystyle D(n,k)=\binom{n}{k}\,!(n-k)\).

---

### 3.2 **전사 함수(onto)** 개수: \([n]\to[m]\)

- \(m^n\) (모든 함수)에서 **적어도 하나의 공집합 원소**를 갖는 함수 제외.
- \(A_i\): 공역의 i가 **아무도 가지지 않음**.

PIE:

$$
\#\{\text{onto}\}=\sum_{j=0}^{m}(-1)^j\binom{m}{j}(m-j)^n
= m!\,S(n,m),
$$

여기서 \(S(n,m)\)은 **스털링 수(2종)**.

**코드**:
```python
def onto_count(n: int, m: int) -> int:
    # ∑ (-1)^j C(m,j) (m-j)^n
    from math import comb
    total = 0
    for j in range(0, m+1):
        total += ((-1)**j) * comb(m, j) * (m - j)**n
    return total
```

---

### 3.3 **패스워드 제약**: “대문자/소문자/숫자 각각 **최소 1** 포함”

- 길이 \(L\), 알파벳 크기 \(U=26, Lc=26, D=10\), 전체 \((U+Lc+D)^L\).
- \(A\): 대문자 없음, \(B\): 소문자 없음, \(C\): 숫자 없음.

크기:

- \(|A|=(Lc+D)^L,\ |B|=(U+D)^L,\ |C|=(U+Lc)^L\)
- \(|A\cap B|=D^L\), \(|B\cap C|=U^L\), \(|C\cap A|=Lc^L\)
- \(|A\cap B\cap C|=0\).

정답:

$$
\text{valid}=(U+Lc+D)^L - [(Lc+D)^L+(U+D)^L+(U+Lc)^L]
+ [D^L+U^L+Lc^L].
$$

**코드 (모듈러 포함)**:
```python
MOD = 10**9+7
def strong_password_count(L: int, U=26, Lc=26, D=10, mod=MOD) -> int:
    def p(a): return pow(a, L, mod)
    tot = p(U+Lc+D)
    bad1 = (p(Lc+D) + p(U+D) + p(U+Lc)) % mod
    bad2 = (p(D) + p(U) + p(Lc)) % mod
    return (tot - bad1 + bad2) % mod

print(strong_password_count(8))
```

---

### 3.4 **오목·금지 위치와 룩 다항식** (스케치)

- \(n\times n\) 체스판의 **금지 칸** 집합 \(F\)에서 금지 칸을 침범하지 않고 non-attacking 룩 \(k\)개를 두는 경우의 수는
  **룩 다항식** \(R_F(k)\)와 연결 → **PIE로 금지 칸의 교집합을 통해 계산**.
- 이 아이디어는 **금지된 위치를 피하는 순열/배치** 일반화에 쓰임(고급 주제).

---

## 4. 정수론 예제

### 4.1 **오일러 피 함수 \(\varphi(n)\)** (PIE로 유도)

- \(\varphi(n)\) = \(1\le x\le n\) 중 \(\gcd(x,n)=1\)의 개수.
- \(n\)의 서로 다른 소인수 \(p_1,\dots,p_\ell\).
  집합 \(A_i\): \(x\le n\) 중 \(p_i\mid x\).

PIE:

$$
\varphi(n) = n - \sum_i \Big\lfloor\frac{n}{p_i}\Big\rfloor
+ \sum_{i<j}\Big\lfloor\frac{n}{p_ip_j}\Big\rfloor - \cdots
= n\prod_{p\mid n}\left(1-\frac{1}{p}\right).
$$

**코드**:
```python
def phi(n: int) -> int:
    x, ans = n, n
    p = 2
    while p*p <= x:
        if x % p == 0:
            ans -= ans // p
            while x % p == 0: x //= p
        p += 1
    if x > 1:
        ans -= ans // x
    return ans

for n in [1,2,6,12,36,100]:
    print(n, phi(n))
```

---

## 5. 확률·신뢰성 예제

### 5.1 **시스템 신뢰성**: 최소 한 컴포넌트 실패 확률

- 실패 사건 \(F_i\), “최소 하나 실패” = \(\bigcup_i F_i\).

PIE:

$$
\mathbb{P}\Big(\bigcup_i F_i\Big)=\sum_i \mathbb{P}(F_i)
-\sum_{i<j}\mathbb{P}(F_i\cap F_j)+\cdots
$$

- **독립**이면 \(\mathbb{P}(F_i\cap F_j)=\mathbb{P}(F_i)\mathbb{P}(F_j)\), …
- **의존**이면 현장 데이터/모형으로 교항 추정.

### 5.2 **Bonferroni 부등식** (부분 합 상·하한)

- 홀수번째 부분합 \(S_1-S_2+S_3-\cdots+S_{2k-1}\)는 **상한**,
- 짝수번째 부분합 \(S_1-S_2+\cdots -S_{2k}\)는 **하한**.
  (실무에서 상한/하한 추정치로 유용)

---

## 6. 문자열/패턴 카운팅 (PIE vs 자동자 DP)

**예**: 길이 \(n\)의 바이너리 문자열 중 패턴 “11”을 **적어도 한 번 포함**
→ 간단히는 보수(count of no “11”)로 계산(피보나치),
→ 여러 **금지 패턴**의 결합은 **PIE**로 다항식 결합 가능하지만,
패턴이 길/복잡하면 **Aho–Corasick + DP**가 더 적합(PIE의 교집합이 폭발).

---

## 7. 비트마스크 PIE & 부분집합 모비우스 변환

### 7.1 비트마스크로 “속성 집합” 다루기

- 속성 \(m\)개 → 부분집합은 정수 \(0..(1\ll m)-1\).
- “적어도 하나의 속성 결여/포함”을 **부분집합 합**으로 돌리기 쉽다.

**PIE 스켈레톤**:
```python
def inclusion_exclusion_over_masks(m: int, term):
    """
    term(S): 교집합 크기(또는 확률/가중치) for subset S (S != 0)
    반환: ∪S의 합(PIE)
    """
    from itertools import combinations
    ans = 0
    for r in range(1, m+1):
        for comb in combinations(range(m), r):
            mask = 0
            for b in comb: mask |= 1<<b
            contrib = term(mask)
            ans += contrib if (r % 2 == 1) else -contrib
    return ans
```

### 7.2 부분집합 **제타/모비우스** 변환 (SOS DP)

- 함수 \(f\)가 “**초집합** 합”으로 \(F(S)=\sum_{T\supseteq S} f(T)\)로 정의되면,
- **모비우스 변환**으로 \(f\) 복원:

```python
def zeta_superset(F):  # F[S] += F[S|bit]
    n = (len(F)-1).bit_length()
    for b in range(n):
        for S in range(len(F)):
            if (S>>b)&1 == 0:
                F[S] += F[S | (1<<b)]
    return F

def mobius_superset(F):  # inverse of zeta_superset
    n = (len(F)-1).bit_length()
    for b in range(n):
        for S in range(len(F)):
            if (S>>b)&1 == 0:
                F[S] -= F[S | (1<<b)]
    return F
```

> **해석**: PIE는 부분집합 격자에서의 **모비우스 반전** 그 자체.
> 큰 \(m\)에서 교집합을 직접 합치지 않고 **\(O(m2^m)\)**로 전역 처리.

---

## 8. 실전 대형 입력 팁 (정수 카운팅)

### 8.1 LCM DFS (오버플로/가지치기)

```python
from math import gcd

def count_multiples_lcm_dfs(N: int, divs: list[int]) -> int:
    divs = sorted(set(divs))  # 중복 제거
    ans = 0

    def dfs(i: int, cur_lcm: int, parity: int):
        nonlocal ans
        if i == len(divs):
            if cur_lcm > 1:
                cnt = N // cur_lcm
                ans += cnt if parity == 1 else -cnt
            return
        # skip
        dfs(i+1, cur_lcm, parity)
        # take
        d = divs[i]
        g = gcd(cur_lcm, d)
        nxt = cur_lcm // g * d
        if nxt <= N:  # 중요: LCM이 N을 넘으면 더 진행해도 모두 0
            dfs(i+1, nxt, parity ^ 1)

    dfs(0, 1, 0)
    return ans

print(count_multiples_lcm_dfs(10**12, [6, 10, 15, 21]))
```

### 8.2 모듈러 & 파워

- 큰 지수항(예: \((\cdot)^L\))은 **빠른 거듭제곱**과 모듈러 사용.
- 나눗셈이 필요할 땐 **페르마 역원**(mod prime) 또는 **확장 유클리드**.

---

## 9. 검증과 브루트포스 비교 (작은 N)

**예**: 길이 \(n\)의 0/1 문자열에서 “1이 최소 1개, 0이 최소 1개”
- 전체 \(2^n\)
- A: “1 없음” = \(1\), B: “0 없음” = \(1\), 교집합 = \(0\).
- 정답 \(=2^n-2\).

**브루트 vs PIE**:
```python
def brute(n: int) -> int:
    cnt = 0
    for x in range(1<<n):
        has0 = (x != (1<<n)-1)
        has1 = (x != 0)
        if has0 and has1:
            cnt += 1
    return cnt

def pie(n: int) -> int:
    return (1<<n) - 2

for n in range(1,10):
    assert brute(n) == pie(n)
print("OK")
```

---

## 10. 부분합 경계: Bonferroni 불등식

집합 \(A_1,\dots,A_n\)에 대해 \(S_k=\sum_{|I|=k} | \cap_{i\in I} A_i |\).

- **상한**: \( | \cup A_i | \le S_1 - S_2 + \cdots + S_{2t-1}\)
- **하한**: \( | \cup A_i | \ge S_1 - S_2 + \cdots - S_{2t}\)

**실무 사례**: 상호의존 사건이 많아 고차 교집합을 측정하기 어려울 때 **부분까지만** 계산해도 유용한 상·하한.

---

## 11. 자주 하는 실수 체크리스트

1. **교집합의 크기 계산** 오류(특히 LCM/금지조건 결합).
2. **중복 원소/약수 포함**(예: \(d_i\mid d_j\)) → LCM DFS에서 자동 처리되지만 미리 **정렬+중복 제거** 추천.
3. **오버플로/시간 폭발**: \(m\)이 크면 \(2^m\) 조합은 불가 → **모비우스/SOS**나 구조 활용.
4. **확률 PIE**에서 **독립성 가정 오남용**(의존이면 교항 직접 추정 필요).
5. **부호**(홀수 더하고/짝수 빼기) 실수.

---

## 12. 더 많은 응용 아이디어

- **그래프 색칠 수**(색 제한의 부정 조건으로 PIE 전개 → 크로마틱 다항식과 연결).
- **금지 간선 매칭 수**(룩 다항식 변형).
- **접두사/접미사 금지 문자열**(간단 패턴은 PIE, 일반은 자동자 DP 권장).
- **일정 제약 스케줄링**(“적어도 하나 충돌”을 PIE로 빼고 계산).

---

## 13. 종합 예제 세트

### 13.1 “1부터 N까지에서 \(a,b,c\)의 배수 **중복 없이** 카운트”

```python
def multiples3(N, a, b, c):
    from math import lcm
    ab = lcm(a,b); bc=lcm(b,c); ca=lcm(c,a); abc=lcm(a,b,c)
    return (N//a + N//b + N//c) - (N//ab + N//bc + N//ca) + (N//abc)
```

### 13.2 전사 함수 카운트 검증 (작은 n,m 브루트)

```python
def onto_bruteforce(n, m):
    # map [0..n-1] -> [0..m-1], count surjections (slow)
    from itertools import product
    cnt=0
    for f in product(range(m), repeat=n):
        if len(set(f))==m:
            cnt+=1
    return cnt

for n,m in [(4,2),(4,3),(5,3)]:
    assert onto_count(n,m) == onto_bruteforce(n,m)
print("onto OK (small)")
```

### 13.3 데랑주망 근사 비교

```python
import math
def derangement_approx(n): return round(math.factorial(n)/math.e)
for n in range(2,9):
    print(n, derangements(n), derangement_approx(n))
```

---

## 14. 요약

- **포함-배제**는 “적어도 하나의 조건을 만족/위반”을 정확히 세는 **정밀 도구**.
- 조합(데랑주망/전사/카탈란 관련 금지조건), 정수론(φ(n)), 확률(연합 사건), 알고리즘(배수·금지집합·강제 제약)에 **광범위**하게 적용.
- 대규모 문제는 **비트마스크 PIE**, **모비우스(SOS)**, **LCM DFS 가지치기**, **모듈러**로 실용화.
- 고차 교집합이 어려우면 **Bonferroni 부분합**으로 경계부터 확보.
