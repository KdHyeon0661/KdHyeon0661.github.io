---
layout: post
title: 컴퓨터시스템 - 메모리 매핑
date: 2025-08-24 16:20:23 +0900
category: 컴퓨터시스템
---
# 메모리 매핑(Memory Mapping)

## 0. 큰 지도(What/Why/How)

주제 | 한 줄 요약 | 주의/함정 | 언제 적합한가
---|---|---|---
개념 | 파일/메모리를 VA에 매핑, 접근 시 페이지 폴트로 로딩 | offset/길이 **페이지 단위**, 권한/공유 모드 | 랜덤 접근 대용량, 코드/DB/IPC
MAP_SHARED | 같은 페이지 캐시를 **프로세스 간 공유**, 쓰기=즉시 가시 | 내구성은 `msync/fsync` 별개 | 공용 데이터, 메모리 기반 IPC
MAP_PRIVATE | 쓰기 시 **COW(사본)**, 파일은 **변경되지 않음** | “썼는데 파일이 안 바뀜”이 정상 | 스냅샷·읽기 위주 변환
익명 매핑 | 파일 없이 **zero-fill** 페이지, swap 백업 | 영속성 없음 | 큰 버퍼/힙 대체/파이프라인
성능 | 소량 I/O 오버헤드↓, 커널↔유저 복사 제거 | **폴트 비용**·페이지 경합, 예측 어려움 | 랜덤/대용량, 메모리형 접근
함정 | SIGBUS(홀/잘못된 오프셋), 정렬, 동기화 | `msync`는 **내구성**(디스크), 가시성은 별개 | 다프로세스 동기화는 별도 원자/락/퓨텍스

---

## 1. 개념과 동작 흐름

1. `mmap()`이 **가상 주소 범위(VMA)**를 예약하고, 파일/익명/장치와 결합한다.  
2. 최초 접근 시 **페이지 폴트** → 커널이 대응 페이지를 **페이지 캐시**(또는 swap/장치)에서 준비해 매핑.  
3. 이후 동일 페이지 접근은 메모리 히트.  
4. `MAP_SHARED` 쓰기는 **동일 파일을 매핑한 타 프로세스**에 **즉시 가시**(CPU 캐시 일관성 범위 내) — 단, **디스크 내구성**은 `msync`로 별도.  
5. `MAP_PRIVATE` 쓰기는 **사본(COW)** 을 만들어 **파일에는 반영되지 않음**.

> 간이 성능 모형  
> $$T_{\text{I/O}} \approx p_{\text{fault}}\cdot t_{\text{fault}} + (1-p_{\text{fault}})\cdot t_{\text{hit}}$$  
> 여기서 \(t_{\text{fault}}\)는 디스크/SSD/FS 경유 비용, \(t_{\text{hit}}\)는 DRAM 접근 비용.

---

## 2. 매핑 유형

### 2.1 파일 매핑(File-backed)
- `fd`를 소유. 코드/데이터/라이브러리 로딩, DB 파일, 대용량 바이너리 파싱에 적합.
- **조건**: `offset`은 **페이지 크기의 배수**.

### 2.2 익명 매핑(Anonymous)
- `MAP_ANONYMOUS | MAP_PRIVATE`, `fd=-1`. zero-fill, swap이 백업.
- 큰 임시 버퍼, 스레드 스택 대체(`MAP_STACK`), 파이프라인 버퍼용.

### 2.3 장치 매핑(Device/pmem/UIO)
- `/dev/fb0`, `/dev/uio*`, pmem(DAX) 등 **MMIO/직접 접근**.
- 캐시 일관성·배리어·비정렬 접근 제약에 주의.

---

## 3. 플래그/권한 — 정확히 이해하기

```c
void* mmap(void* addr, size_t len, int prot, int flags, int fd, off_t offset);
```

구분 | 주요 값 | 의미/주의
---|---|---
`prot` | `PROT_READ/WRITE/EXEC/NONE` | 접근 권한. `mprotect`로 변경 가능
`flags(공유)` | `MAP_SHARED`, `MAP_PRIVATE` | 공유/사본(COW)
`flags(소스)` | `MAP_ANONYMOUS` | 익명 매핑
`flags(기타)` | `MAP_FIXED(_NOREPLACE)` | 고정 주소(위험)/겹치면 실패
 | `MAP_POPULATE` | 매핑 시 **사전 프리폴트**
 | `MAP_HUGETLB`/THP | HugeTLB/투명 대페이지(커널 설정 의존)
`fd 권한` | open 모드 | `MAP_SHARED+PROT_WRITE` → **fd는 쓰기 가능**해야 함. `MAP_PRIVATE+PROT_WRITE`는 read-only fd도 가능(COW)

**정렬 규칙**
- `offset`은 **페이지 크기 배수**.  
- `len`은 내부적으로 반올림.  
- `addr`은 커널이 결정(권장: NULL) — `MAP_FIXED`는 충돌 위험.

---

## 4. 페이지 캐시·COW·가시성·내구성

- **페이지 캐시**: 파일 매핑/`read()` 모두 동일 캐시를 공유.  
- **MAP_SHARED 가시성**: 같은 파일 페이지를 매핑한 타 프로세스는 **곧바로 최신 바이트**를 본다(정상적인 CPU 캐시 일관성 범위). **주문(순서)** 보장을 위해서는 **원자 연산/락/퓨텍스** 등 **사용자 수준 동기화**가 필요.  
- **내구성(durability)**: `msync(MS_SYNC)`가 디스크에 **플러시 지시**. `MS_ASYNC`는 큐잉, `fsync/fdatasync`와 차이 존재.  
- **MAP_PRIVATE**: 쓰기 시 **사본 페이지** 생성 → 파일 미변경. **스냅샷 처리**에 적합.

---

## 5. 폴트/시그널

- **Minor fault**: 메모리에 있으나 PTE 미설정 → 빠름.  
- **Major fault**: 디스크에서 읽어야 함 → 느림.  
- **SIGBUS**: 파일 **크기 밖** 접근(스파스 hole·트렁케이트 이후)·장치 접근 오류.  
- **SIGSEGV**: 권한 위반(`PROT_WRITE` 없는 쓰기 등).

---

## 6. 실전 레시피: 리눅스

### 6.1 안전한 파일 매핑 및 수정(MAP_SHARED)
```c
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

int main(int argc, char** argv){
    if (argc != 2){ fprintf(stderr, "usage: %s file\n", argv[0]); return 1; }

    int fd = open(argv[1], O_RDWR);
    if (fd < 0){ perror("open"); return 1; }

    struct stat st;
    if (fstat(fd, &st) < 0){ perror("fstat"); return 1; }
    if (st.st_size == 0){ fprintf(stderr, "empty file\n"); return 1; }

    size_t len = st.st_size;
    char* p = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED){ perror("mmap"); return 1; }

    // in-place 수정
    if (len >= 2){ p[0] = 'H'; p[1] = 'i'; }

    // 내구성 보장(동기식 플러시)
    if (msync(p, len, MS_SYNC) < 0) perror("msync");

    munmap(p, len);
    close(fd);
}
```
**포인트**
- `MAP_SHARED + PROT_WRITE` → `fd`는 **O_RDWR**로 열려야 한다.  
- **가시성**(타 프로세스)은 `msync` 없이도 즉시지만, **디스크 내구성**은 `msync/fsync` 필요.

---

### 6.2 안전한 “파일 크기 확장 후 쓰기”(SIGBUS 방지)
```c
// 파일 끝에 N바이트를 쓰고 싶다면: 1) ftruncate로 미리 크기 확장 → 2) 그 범위에 mmap → 3) 쓰기
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

int main(){
    const char* path = "append.bin";
    int fd = open(path, O_RDWR|O_CREAT, 0644);
    if (fd < 0){ perror("open"); return 1; }

    off_t old = lseek(fd, 0, SEEK_END);
    size_t add = 4096;
    if (ftruncate(fd, old + add) < 0){ perror("ftruncate"); return 1; }

    long pg = sysconf(_SC_PAGESIZE);
    off_t off = (old / pg) * pg;
    size_t delta = old - off;
    size_t maplen = delta + add;

    char* p = mmap(NULL, maplen, PROT_READ|PROT_WRITE, MAP_SHARED, fd, off);
    if (p == MAP_FAILED){ perror("mmap"); return 1; }

    memset(p + delta, 0xAB, add);           // 확장 구간에 안전하게 쓰기
    msync(p, maplen, MS_SYNC);               // 내구성 보장(선택)
    munmap(p, maplen);
    close(fd);
}
```
**왜 필요한가**: **파일 크기 밖**(스파스 hole 포함)에 쓰면 `SIGBUS`. 항상 **선(先) ftruncate**.

---

### 6.3 `madvise`/`mlock`으로 폴트 패턴 최적화
```c
// 순차/랜덤/사전 로딩/버리기 힌트
madvise(p, len, MADV_SEQUENTIAL);  // 순차
madvise(p, len, MADV_RANDOM);      // 랜덤
madvise(p, len, MADV_WILLNEED);    // 프리페치
madvise(p, len, MADV_DONTNEED);    // 캐시에서 버려도 좋음 (dirty면 writeback 이후)
```
```c
// 물리 메모리에 고정(스왑 방지) — 한도: RLIMIT_MEMLOCK
if (mlock(p, len) < 0) perror("mlock");   // 실시간/초저지연
```

---

### 6.4 프로세스 간 공유 메모리(파일 없이, `memfd_create`)
```c
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <linux/memfd.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(){
    int fd = syscall(SYS_memfd_create, "shm", MFD_CLOEXEC);
    ftruncate(fd, 4096);
    char* p = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);

    // 부모-자식 간 공유 예
    pid_t pid = fork();
    if (pid == 0){ // child
        strcpy(p, "hello from child");
        _exit(0);
    } else {
        wait(NULL);
        printf("%s\n", p);  // "hello from child"
    }
    munmap(p, 4096);
    close(fd);
}
```
- `memfd_create`는 **익명 파일**을 만들고 **파일 디스크립터 전달**로 다프로세스 공유가 쉽다.
- `shm_open("/name", …)` 기반 POSIX 공유 메모리로도 동일 패턴 가능.

---

### 6.5 링 버퍼(원형) 트릭 — *더블 매핑*
> **아이디어**: 길이 `N` 파일을 **연속 두 번** 매핑(같은 오프셋) → 논리적 주소 공간에 `2N` 연속 구간을 만들어 **wrap-around 없이** 순차 접근.

```c
// 전제: 파일 길이를 N으로 ftruncate, 페이지 배수 맞춤.
void* base = mmap(NULL, 2*N, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
mmap(base,   N, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED, fd, 0);
mmap(base+N, N, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED, fd, 0);
// 이제 [base, base+2N)에서 연속 접근 가능.  [w, w+k) 가 N 넘겨도 안전.
```
- `MAP_FIXED`는 **기존 매핑을 덮어쓸 수 있어 위험**. 충돌 없는 예약부터 신중하게 사용.

---

### 6.6 SIGBUS 핸들러 — 안전 종료/로그
```c
#include <signal.h>
#include <ucontext.h>
static void on_bus(int sig, siginfo_t* si, void* ctx){
    fprintf(stderr, "SIGBUS at addr=%p (likely beyond EOF)\n", si->si_addr);
    _exit(128+SIGBUS);
}
static void install_sigbus(void){
    struct sigaction sa = { .sa_sigaction=on_bus, .sa_flags=SA_SIGINFO };
    sigemptyset(&sa.sa_mask);
    sigaction(SIGBUS, &sa, NULL);
}
```

---

## 7. 성능/튜닝: 어디에 이점이 있는가

주제 | 설명 | 팁
---|---|---
소량 랜덤 읽기 | `read()` 대비 커널↔유저 복사/경로 단축 | `MADV_RANDOM`, 작게 자주 접근에 유리
대용량 순차 | `read()`와 유사/우세, 단 폴트 폭발 방지 | `MADV_SEQUENTIAL`, `MAP_POPULATE(부팅·배치)`
지연 예측성 | 폴트 타이밍이 **비결정** | 폴트를 **워밍업**(사전 터치)
Huge Page | DTLB 미스↓, 스캔 효율↑ | THP 켜짐 확인/`MAP_HUGETLB`(권한 필요)
NUMA | 원격 메모리 접근 비용↑ | **first-touch**, `mbind/numactl` 고려
내구성 | `msync` 비용 큼 | 배치 플러시, 저지연이면 pmem+DAX(다음 섹션 참조)

---

## 8. 디버깅/관찰

명령/파일 | 용도
---|---
`/proc/<pid>/maps`, `/proc/<pid>/smaps` | 매핑 범위/권한/anon/file/Private_Dirty 등
`pmap <pid>` | 요약
`mincore(addr,len,vec)` | **상주 여부**(page resident) 확인
`perf stat -e page-faults,majfaults` | 폴트/성능
`strace -e mmap,munmap,msync` | 호출 추적

---

## 9. 안전·보안

- **권한 일치**: `MAP_SHARED+PROT_WRITE`이면 **파일도 쓰기 가능**하게 열어야 함.  
- **W^X**: 실행 코드 페이지는 쓰기 금지 유지. JIT는 `mprotect`로 단계 전환.  
- **`MAP_FIXED` 주의**: 기존 매핑 파괴 가능 → 가능하면 `MAP_FIXED_NOREPLACE`.  
- **SELinux/AppArmor**: 라벨/프로파일이 `mmap(PROT_EXEC)` 등을 제한할 수 있음.

---

## 10. 윈도우 대응(요점)

- **열기**: `CreateFile`(또는 익명: `INVALID_HANDLE_VALUE` + `PAGE_READWRITE`)  
- **매핑 오브젝트**: `CreateFileMapping(h, …, PAGE_READWRITE/PAGE_READONLY/PAGE_EXECUTE_READ, …)`  
- **뷰 매핑**: `MapViewOfFile(hMap, FILE_MAP_WRITE/READ/EXECUTE, off_hi, off_lo, len)`  
- **Flush**: `FlushViewOfFile(p,len)` +(선택) `FlushFileBuffers(hFile)`  
- **정렬**: **오프셋은 AllocationGranularity(보통 64KB)** 배수, 길이는 자유(마지막 부분 부분매핑 가능).  
- **큰 페이지**: `SEC_LARGE_PAGES` + 권한.  
- 익명 매핑은 `CreateFileMapping(INVALID_HANDLE_VALUE, …)`.

간단 예:
```c
// Windows: file mapping
HANDLE hf = CreateFileA("file.bin", GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
HANDLE hm = CreateFileMappingA(hf, NULL, PAGE_READWRITE, 0, 0, NULL);
SYSTEM_INFO si; GetSystemInfo(&si);
DWORD gran = si.dwAllocationGranularity; // 보통 64KB
SIZE_T len = 1<<20;
LPVOID p = MapViewOfFile(hm, FILE_MAP_WRITE, 0, 0, len);
// 사용 후
FlushViewOfFile(p, len);
UnmapViewOfFile(p);
CloseHandle(hm); CloseHandle(hf);
```

---

## 11. 특수: 영속 메모리(DAX/pmem) 개요

- DAX 파일시스템의 파일을 `MAP_SYNC|MAP_SHARED_VALIDATE`로 매핑하면 **스토어가 내구성 경로**에 가까움(플러시 지시 필요할 수 있음).  
- 사용자 공간에서 **`pmem_persist`/CLWB+SFENCE**류 호출(라이브러리)로 내구성 보장.  
- 지연 민감 영속 로그/메타데이터에 유용(플랫폼 세부는 환경 의존).

---

## 12. 언제 `read/write`가 더 나은가

- **짧고 명확한 I/O 경계**와 **예측 가능한 지연**이 중요한 경우(예: 요청 단위 tracing)  
- **네트워크 파일시스템**(캐시 일관성/서버 정책과의 상호작용이 까다롭다)  
- **O_DIRECT** 기반 DB 설계(페이지 캐시를 의도적으로 우회) — `mmap`과는 철학이 다름.

---

## 13. 자주 겪는 에러와 원인

증상 | 원인 | 해결
---|---|---
`mmap: EINVAL` | offset이 페이지 배수 아님 / 길이 0 / 플래그 조합 불가 | 정렬/플래그 점검
`SIGSEGV` | `PROT_WRITE` 없이 쓰기, 잘못된 포인터 | `prot`/경계 검사
`SIGBUS` | EOF 밖 접근(스파스 홀, truncate 이후) | **ftruncate 선행**, 크기 재계산
쓰기했지만 파일 미변경 | `MAP_PRIVATE` COW | `MAP_SHARED` 사용
타 프로세스가 변경을 못 봄 | 동기화 부재(순서/원자성) | 공유 락/원자/퓨텍스 사용
`msync` 느림 | 자주 sync | 배치/범위 최소화, 비동기 `MS_ASYNC`+`fsync` 시점 제어

---

## 14. 체크리스트

- [ ] offset은 **페이지 배수**, 길이는 반올림 고려  
- [ ] `MAP_SHARED` 쓰기는 **O_RDWR**로 열었나  
- [ ] 파일 **크기 확장** 후 쓰는가(선 ftruncate)  
- [ ] **동기화**: 가시성(락/원자) vs 내구성(`msync/fsync`) 구분  
- [ ] 접근 패턴 힌트(`madvise`)와 메모리 잠금(`mlock`) 필요성 검토  
- [ ] **에러/시그널 처리**(SIGBUS/SEGV)  
- [ ] 디버깅 툴로 **폴트/상주성** 점검(`mincore`, `perf`, `smaps`)

---

## 15. 미니 예제 모음

### 15.1 메모리 매핑 파일 읽기(읽기 전용 스캔)
```c
int fd = open(path, O_RDONLY);
struct stat st; fstat(fd, &st);
const char* p = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
size_t cnt = 0;
for (size_t i=0;i<st.st_size;i++) if (p[i]=='\n') cnt++;
munmap((void*)p, st.st_size); close(fd);
```

### 15.2 공유 메모리에서 원자 카운터
```c
#include <stdatomic.h>
// p는 MAP_SHARED 메모리
typedef struct { _Atomic uint64_t c; } counter_t;
atomic_fetch_add_explicit(&p->c, 1, memory_order_relaxed);
```
> **순서 보장**이 필요한 경우 `memory_order_release/acquire` 조합 사용. 다프로세스 간에도 원자 규약은 동일.

### 15.3 `msync` 모드 비교
```c
msync(p, len, MS_SYNC);       // 호출이 완료되면 dirty가 디스크에 반영
msync(p, len, MS_ASYNC);      // 큐잉만. 시점은 FS/커널에 위임
msync(p, len, MS_INVALIDATE); // 캐시 무효화(드물게 필요)
```

---

## 16. 결론

- `mmap`은 “**메모리처럼 읽고 쓰는 I/O**”를 제공한다.  
- **MAP_SHARED vs MAP_PRIVATE**, **가시성 vs 내구성**, **폴트/정렬/시그널**만 정확히 이해하면,  
  랜덤 접근 대용량 처리·IPC·파일 기반 데이터 구조에서 **간결함과 성능**을 함께 얻는다.  
- 성능은 **폴트 패턴**과 **동기화/플러시 전략**에서 갈린다. `madvise/mlock/msync`를 적절히 조합하라.

---

## 부록 A) 자주 쓰는 스니펫

```c
// 페이지 크기/정렬
long P = sysconf(_SC_PAGESIZE);
off_t off_pg = (off/P)*P; size_t skew = off - off_pg;

// 안전한 매핑 길이 계산(끝단 포함)
size_t maplen = ALIGN(skew + need, P);

// “읽기 스냅샷” (원본 불변 보장)
char* p = mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);

// “공유 쓰기 + 내구성”
char* q = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
memcpy(q+pos, buf, n);
msync(q+pos, n, MS_SYNC);

// 사전 프리폴트(워밍업)
mmap(NULL, len, PROT_READ, MAP_PRIVATE|MAP_POPULATE, fd, 0);

// 접근 패턴 힌트
madvise(p, len, MADV_SEQUENTIAL);

// 메모리 고정(실시간)
mlock(p, len);
```

## 부록 B) 간이 벤치/관찰 포인트
- 랜덤 4KB 읽기: `read()` vs `mmap`(폴트·minor/major 측정).  
- `perf stat -e page-faults,majfaults`로 폴트율 비교.  
- `mincore`로 워밍업 효과 확인.  
- `msync` 범위/빈도에 따른 tail-latency 변화 관찰.
