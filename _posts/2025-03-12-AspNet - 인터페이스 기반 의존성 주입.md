---
layout: post
title: AspNet - 인터페이스 기반 의존성 주입
date: 2025-03-12 19:20:23 +0900
category: AspNet
---
# ASP.NET Core에서 인터페이스 기반 의존성 주입(DI)

## 0. 왜 “인터페이스 기반 DI”인가 — 기존 초안 핵심 재정리

### 강한 결합(안티 패턴)
```csharp
public class OrderService
{
    private readonly EmailSender _emailSender = new EmailSender(); // 강한 결합

    public void PlaceOrder()
    {
        // 주문 처리...
        _emailSender.Send("주문 완료");
    }
}
```
- 구체 구현(EmailSender)에 종속 → 교체/테스트 어려움.

### 인터페이스 기반 DI
```csharp
public interface IEmailSender { void Send(string message); }

public class EmailSender : IEmailSender
{
    public void Send(string message) => Console.WriteLine($"Email: {message}");
}

public class OrderService
{
    private readonly IEmailSender _email;
    public OrderService(IEmailSender email) => _email = email;

    public void PlaceOrder()
    {
        // 주문 처리...
        _email.Send("주문 완료");
    }
}
```

### 서비스 등록(초안 요지 + 확장)
```csharp
// Program.cs
builder.Services.AddScoped<IEmailSender, EmailSender>();
builder.Services.AddScoped<OrderService>(); // 구현체 스스로도 등록 가능
```

### 주입(초안 요지 + Razor Pages/MVC/Minimal API 확장)
**Razor Pages**
```csharp
public class IndexModel : PageModel
{
    private readonly OrderService _orders;
    public IndexModel(OrderService orders) => _orders = orders;
    public void OnGet() => _orders.PlaceOrder();
}
```

**MVC Controller**
```csharp
public class OrdersController : Controller
{
    private readonly OrderService _orders;
    public OrdersController(OrderService orders) => _orders = orders;

    [HttpPost("/orders")]
    public IActionResult Place() { _orders.PlaceOrder(); return Ok(); }
}
```

**Minimal API**
```csharp
app.MapPost("/orders", (OrderService orders) =>
{
    orders.PlaceOrder();
    return Results.Ok();
});
```

---

## 1. DI 핵심 규칙과 선택지 — 생성자/메서드/프로퍼티 주입

### 생성자 주입(권장)
- 불변 의존성(필수)은 생성자에서 받아 **불변성** 보장.
- 테스트/유지보수 용이.

### 메서드 주입
- 특정 동작에 **필요할 때만** 공급해야 하는 선택적 의존성.
```csharp
public class ReportService
{
    public Task RunAsync(IEmailSender? sender = null) { /* ... */ return Task.CompletedTask; }
}
```

### 프로퍼티 주입
- .NET 기본 컨테이너는 자동 프로퍼티 주입을 제공하지 않는다(직접 할당 필요).
- 꼭 필요한 경우에만(테스트 도우미, 특수 케이스) 제한적으로 사용.

---

## 2. 수명 주기(Lifetime)와 인터페이스 — 안전한 조합

| Lifetime   | 생성 시점                | 추천 용도                                     |
|------------|--------------------------|-----------------------------------------------|
| Transient  | 요청 시마다              | 경량/무상태 헬퍼, 변환기, 포맷터              |
| Scoped     | HTTP 요청당 1개          | 비즈니스 로직, `DbContext`, 유스케이스 서비스 |
| Singleton  | 앱 시작~종료까지 1개     | 캐시/카탈로그/설정, 스레드 안전 공유 객체     |

**주의:** Singleton이 Scoped/Transient를 **직접** 주입하면 수명 역전 문제가 발생한다.

### 역전 문제 해결(지연 스코프 생성)
```csharp
public class MySingleton
{
    private readonly IServiceScopeFactory _scopeFactory;
    public MySingleton(IServiceScopeFactory scopeFactory) => _scopeFactory = scopeFactory;

    public async Task ExecuteAsync()
    {
        using var scope = _scopeFactory.CreateScope();
        var scopedService = scope.ServiceProvider.GetRequiredService<IMyScopedService>();
        await scopedService.HandleAsync();
    }
}
```

---

## 3. 구현 선택 전략 — 조건/환경/테넌트에 따라 인터페이스 구현 바꾸기

### 3.1 단순 교체(초안 재확인)
```csharp
// EmailSender로 사용
builder.Services.AddScoped<IMessageSender, EmailSender>();

// SMS로 전환
// builder.Services.AddScoped<IMessageSender, SmsSender>();
```

### 3.2 런타임 선택(팩토리 패턴 — 초안 확장)
```csharp
public interface IMessageSender { void Send(string message); }
public class EmailSender : IMessageSender { public void Send(string m) => Console.WriteLine($"Email: {m}"); }
public class SmsSender   : IMessageSender { public void Send(string m) => Console.WriteLine($"SMS: {m}"); }

public class SenderFactory
{
    private readonly IServiceProvider _sp;
    public SenderFactory(IServiceProvider sp) => _sp = sp;

    public IMessageSender Get(string kind) => kind switch
    {
        "sms"   => _sp.GetRequiredService<SmsSender>(),
        "email" => _sp.GetRequiredService<EmailSender>(),
        _       => throw new InvalidOperationException("unknown sender")
    };
}
```
```csharp
builder.Services.AddScoped<EmailSender>();
builder.Services.AddScoped<SmsSender>();
builder.Services.AddSingleton<SenderFactory>();
```

### 3.3 Keyed Services(.NET 8) — “이름 있는” 구현
```csharp
// 등록
builder.Services.AddKeyedScoped<IMessageSender, EmailSender>("email");
builder.Services.AddKeyedScoped<IMessageSender, SmsSender>("sms");

// 주입(생성자 파라미터에서 키 바인딩)
public class AlertService
{
    private readonly IMessageSender _email;
    private readonly IMessageSender _sms;

    public AlertService(
        [FromKeyedServices("email")] IMessageSender email,
        [FromKeyedServices("sms")] IMessageSender sms)
    {
        _email = email; _sms = sms;
    }

    public void AlertByEmail(string msg) => _email.Send(msg);
    public void AlertBySms(string msg)   => _sms.Send(msg);
}
```

### 3.4 사용자 선호/테넌트 설정 기반 라우팅(전략 패턴)
```csharp
public interface INotificationStrategy { void Notify(string userId, string message); }

public class NotificationRouter : INotificationStrategy
{
    private readonly IServiceProvider _sp;
    private readonly IUserPreferenceStore _prefs;

    public NotificationRouter(IServiceProvider sp, IUserPreferenceStore prefs)
    { _sp = sp; _prefs = prefs; }

    public void Notify(string userId, string message)
    {
        var pref = _prefs.GetPreferredChannel(userId); // "email" | "sms"
        var sender = _sp.GetRequiredKeyedService<IMessageSender>(pref);
        sender.Send(message);
    }
}
```

---

## 4. 인터페이스와 DI 등록 방식 — 오픈 제네릭/팩터리/인스턴스/데코레이터

### 4.1 오픈 제네릭
```csharp
public interface IRepository<T> { Task AddAsync(T entity); }
public class EfRepository<T> : IRepository<T> { /* ... */ }
builder.Services.AddScoped(typeof(IRepository<>), typeof(EfRepository<>));
```

### 4.2 팩토리 델리게이트
```csharp
builder.Services.AddScoped<Func<string, IMessageSender>>(sp => key =>
{
    return key switch
    {
        "sms"   => sp.GetRequiredService<SmsSender>(),
        "email" => sp.GetRequiredService<EmailSender>(),
        _       => throw new InvalidOperationException()
    };
});
```

### 4.3 인스턴스 직접 등록
```csharp
builder.Services.AddSingleton(new StaticCatalog(new[] { "A", "B", "C" }));
```

### 4.4 데코레이터(Scrutor 활용)
```csharp
// dotnet add package Scrutor
builder.Services.AddScoped<IEmailSender, EmailSender>();
builder.Services.Decorate<IEmailSender, LoggingEmailSender>();

public class LoggingEmailSender : IEmailSender
{
    private readonly IEmailSender _inner; private readonly ILogger<LoggingEmailSender> _log;
    public LoggingEmailSender(IEmailSender inner, ILogger<LoggingEmailSender> log) { _inner = inner; _log = log; }
    public void Send(string msg)
    {
        _log.LogInformation("Sending: {Msg}", msg);
        _inner.Send(msg);
    }
}
```

---

## 5. ASP.NET Core 계층별 DI 적용 패턴

### 5.1 Razor Pages
```csharp
public class RegisterModel : PageModel
{
    private readonly IAccountService _accounts;
    public RegisterModel(IAccountService accounts) => _accounts = accounts;

    [BindProperty] public RegisterInput Input { get; set; } = new();

    public async Task<IActionResult> OnPostAsync()
    {
        if (!ModelState.IsValid) return Page();
        await _accounts.RegisterAsync(Input);
        return RedirectToPage("Success");
    }
}
```

### 5.2 MVC Controller
```csharp
public class ProductsController : Controller
{
    private readonly IProductQueries _queries; // 읽기 모델
    private readonly IProductCommands _commands; // 쓰기 모델
    public ProductsController(IProductQueries q, IProductCommands c) { _queries = q; _commands = c; }
}
```

### 5.3 Minimal API
```csharp
app.MapGet("/products/{id:int}", async (int id, IProductQueries q) =>
    Results.Ok(await q.GetByIdAsync(id)));
```

### 5.4 미들웨어(델리게이트/IMiddleware)
```csharp
// 델리게이트
app.Use(async (ctx, next) =>
{
    var svc = ctx.RequestServices.GetRequiredService<IRequestLogger>();
    await svc.LogAsync(ctx);
    await next();
});

// 클래스형
public class LoggingMiddleware : IMiddleware
{
    private readonly IRequestLogger _logger;
    public LoggingMiddleware(IRequestLogger logger) => _logger = logger;
    public Task InvokeAsync(HttpContext context, RequestDelegate next) => _logger.WrapAsync(context, next);
}
builder.Services.AddScoped<IRequestLogger, RequestLogger>();
builder.Services.AddTransient<LoggingMiddleware>();
app.UseMiddleware<LoggingMiddleware>();
```

---

## 6. 구성/옵션 + 인터페이스 — IOptions 패턴과 DI

```csharp
public class SmtpOptions
{
    public string Host { get; set; } = "";
    public int Port { get; set; } = 25;
}
builder.Services.Configure<SmtpOptions>(builder.Configuration.GetSection("Smtp"));

public class SmtpEmailSender : IEmailSender
{
    private readonly SmtpOptions _opt;
    public SmtpEmailSender(IOptions<SmtpOptions> opt) => _opt = opt.Value;
    public void Send(string m) { /* _opt.Host/_opt.Port 사용 */ }
}
```

- 요청마다 최신 설정이 필요하면 `IOptionsSnapshot<T>` (Scoped),
- 실시간 변경/콜백 필요하면 `IOptionsMonitor<T>` (Singleton)를 사용.

---

## 7. 외부 API/DB/리소스와 인터페이스 — HttpClientFactory, DbContext

### 7.1 HttpClientFactory + Typed Client
```csharp
public interface IWeatherApi { Task<string> GetAsync(string city); }
public class WeatherApi : IWeatherApi
{
    private readonly HttpClient _http;
    public WeatherApi(HttpClient http) => _http = http;
    public Task<string> GetAsync(string city) => _http.GetStringAsync($"weather?city={city}");
}
builder.Services.AddHttpClient<IWeatherApi, WeatherApi>(c =>
{
    c.BaseAddress = new Uri("https://api.example.com/");
});
```
- 인터페이스로 캡슐화, 테스트 시 대역 주입 용이.

### 7.2 EF Core DbContext + Repository
```csharp
public interface IOrderRepository { Task AddAsync(Order order); }
public class OrderRepository : IOrderRepository
{
    private readonly AppDb _db; public OrderRepository(AppDb db) => _db = db;
    public async Task AddAsync(Order order) { await _db.Orders.AddAsync(order); await _db.SaveChangesAsync(); }
}
builder.Services.AddScoped<IOrderRepository, OrderRepository>();
```

---

## 8. 검증/로깅/권한 — 인터페이스로 횡단 관심사 분리

### 유효성 검증
```csharp
public interface IValidator<T> { Task ValidateAsync(T model); }

public class RegisterValidator : IValidator<RegisterInput>
{
    public Task ValidateAsync(RegisterInput m)
    {
        if (string.IsNullOrWhiteSpace(m.Email)) throw new ValidationException("Email required");
        return Task.CompletedTask;
    }
}
```

### 로깅/권한/감사
- 인터페이스로 역할을 분리하고, 데코레이터/파이프라인으로 합성.
- 예: `ICommand<T>` 처리 전에 `IAuthorizationService` 체크, 로깅 삽입.

---

## 9. 테스트 전략 — Fake/Stub/Moq + WebApplicationFactory로 DI 오버라이드

### 9.1 단위 테스트: Fake 구현 주입
```csharp
public class FakeSender : IEmailSender
{
    public List<string> Sent = new();
    public void Send(string message) => Sent.Add(message);
}

[Fact]
public void PlaceOrder_SendsEmail()
{
    var fake = new FakeSender();
    var sut = new OrderService(fake);
    sut.PlaceOrder();
    Assert.Contains("주문 완료", fake.Sent);
}
```

### 9.2 Moq로 인터랙션 검증
```csharp
var mock = new Mock<IEmailSender>();
var sut = new OrderService(mock.Object);
sut.PlaceOrder();
mock.Verify(m => m.Send(It.Is<string>(s => s.Contains("주문 완료"))), Times.Once);
```

### 9.3 통합 테스트: WebApplicationFactory로 DI 교체
```csharp
public class MyFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureServices(svcs =>
        {
            svcs.RemoveAll<IEmailSender>();
            svcs.AddSingleton<IEmailSender, FakeSender>();
        });
    }
}
```

---

## 10. 안티 패턴 주의 — Service Locator, Static Accessor, Captive Dependency

- **Service Locator**: `IServiceProvider`를 **도메인 로직 깊숙이** 배포 → 테스트/구조 악화.
  → 팩토리나 Keyed Services를 **경계 계층**(예: Application/Infrastructure)에 한정하라.
- **Static Accessor**(정적 싱글턴): 전역 상태로 흘러 들어감 → 멀티테넌시/테스트 방해.
- **Captive Dependency**: Singleton이 Scoped를 붙잡는 구조 → 스코프 종료 후 접근 위험.

---

## 11. 성능·안전 체크리스트

- [ ] 인터페이스/구현 분리로 **느슨한 결합** 유지
- [ ] 수명 주기 준수(Transient/Scoped/Singleton) + **스레드 안전성**
- [ ] Singleton에서 Scoped 필요 시 **CreateScope** 사용
- [ ] 외부 리소스 접근은 인터페이스로 감싸 테스트/리트라이/폴리시 적용 용이하게
- [ ] Scrutor/Keyed Services로 **구현 선택/데코레이션**을 깔끔하게
- [ ] 테스트에서 **RemoveAll/Replace**로 등록 오버라이드
- [ ] 컨테이너가 생성한 IDisposable은 **수명 종료 시 자동 해제**됨을 인지

---

## 12. 실전 샘플 — “알림 시스템” 종합 예제

### 12.1 계약/구현
```csharp
public interface IMessageSender { Task SendAsync(string to, string message, CancellationToken ct = default); }

public class EmailSender : IMessageSender
{
    public Task SendAsync(string to, string message, CancellationToken ct = default)
    {
        Console.WriteLine($"EMAIL to {to}: {message}");
        return Task.CompletedTask;
    }
}

public class SmsSender : IMessageSender
{
    public Task SendAsync(string to, string message, CancellationToken ct = default)
    {
        Console.WriteLine($"SMS to {to}: {message}");
        return Task.CompletedTask;
    }
}
```

### 12.2 Keyed 등록 + 라우팅 서비스
```csharp
builder.Services.AddKeyedScoped<IMessageSender, EmailSender>("email");
builder.Services.AddKeyedScoped<IMessageSender, SmsSender>("sms");
builder.Services.AddScoped<NotificationService>();

public class NotificationService
{
    private readonly IUserPreferenceStore _prefs;
    private readonly IServiceProvider _sp;

    public NotificationService(IUserPreferenceStore prefs, IServiceProvider sp)
    { _prefs = prefs; _sp = sp; }

    public async Task NotifyAsync(string userId, string message, CancellationToken ct = default)
    {
        var channel = _prefs.GetPreferredChannel(userId); // "email" | "sms"
        var sender  = _sp.GetRequiredKeyedService<IMessageSender>(channel);
        var address = _prefs.GetAddress(userId, channel);
        await sender.SendAsync(address, message, ct);
    }
}
```

### 12.3 컨트롤러/페이지/엔드포인트
```csharp
app.MapPost("/notify/{userId}", async (string userId, string message, NotificationService svc) =>
{
    await svc.NotifyAsync(userId, message);
    return Results.Ok();
});
```

### 12.4 테스트: Fake로 대체
```csharp
public class FakeSender : IMessageSender
{
    public readonly List<(string To,string Msg)> Sent = new();
    public Task SendAsync(string to, string message, CancellationToken ct = default)
    { Sent.Add((to,message)); return Task.CompletedTask; }
}
```
```csharp
// 통합 테스트에서 DI 교체
svcs.RemoveAll<IMessageSender>();
svcs.AddKeyedSingleton<IMessageSender, FakeSender>("email");
svcs.AddKeyedSingleton<IMessageSender, FakeSender>("sms");
```

---

## 13. 전체 Program.cs 예시(집약판)
```csharp
var builder = WebApplication.CreateBuilder(args);

// MVC/Razor Pages
builder.Services.AddControllersWithViews();
builder.Services.AddRazorPages();

// 도메인 서비스
builder.Services.AddScoped<OrderService>();

// 인터페이스 기반 DI
builder.Services.AddScoped<IEmailSender, EmailSender>();
builder.Services.AddScoped<IMessageSender, EmailSender>(); // 기본값
builder.Services.AddKeyedScoped<IMessageSender, EmailSender>("email");
builder.Services.AddKeyedScoped<IMessageSender, SmsSender>("sms");

// 옵션/외부 API
builder.Services.Configure<SmtpOptions>(builder.Configuration.GetSection("Smtp"));
builder.Services.AddHttpClient<IWeatherApi, WeatherApi>(c =>
    c.BaseAddress = new Uri("https://api.example.com/"));

// 저장소/EF Core
builder.Services.AddDbContext<AppDb>(o =>
    o.UseSqlite(builder.Configuration.GetConnectionString("Default")));

// 라우팅/전략
builder.Services.AddScoped<IUserPreferenceStore, UserPreferenceStore>();
builder.Services.AddScoped<NotificationService>();

var app = builder.Build();

app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();

app.MapRazorPages();
app.MapControllers();

app.MapPost("/orders", (OrderService orders) => { orders.PlaceOrder(); return Results.Ok(); });
app.MapPost("/notify/{userId}", async (string userId, string message, NotificationService svc) =>
{
    await svc.NotifyAsync(userId, message);
    return Results.Ok();
});

app.Run();
```

---

## 14. 요약

- **인터페이스 기반 DI**는 느슨한 결합/테스트 용이성/확장성을 동시에 충족한다.
- 수명 주기 규칙(Transient/Scoped/Singleton)을 지키고, 싱글턴에서 스코프 서비스는 **지연 스코프 생성**으로 안전하게 사용한다.
- 구현 선택은 **Keyed Services(.NET 8)**, 팩토리/전략/데코레이터로 깔끔하게 해결한다.
- Razor Pages, MVC, Minimal API, 미들웨어 어디에서든 일관된 방식으로 주입한다.
- 테스트에서 Fake/Moq/WebApplicationFactory로 **DI를 손쉽게 교체**하라.

인터페이스를 중심으로 **계약을 먼저 설계**하면, 서비스가 바뀌어도 시스템은 흔들리지 않는다. 이것이 ASP.NET Core의 DI가 제공하는 가장 큰 실용적 가치다.
