---
layout: post
title: MFC - 셸 통합
date: 2025-09-06 22:25:23 +0900
category: MFC
---
# 셸 통합: 파일 형식 등록, 컨텍스트 메뉴 핸들러, 미리 보기 핸들러(개념+실전)  
(MFC/ATL/Win32 기준 · x64/Win10/11 대응 · 레지스트리/COM 스켈레톤/배포 체크리스트 포함)

이 글은 **Windows Shell 통합**의 3대 축 — **파일 형식 등록(연결)**, **컨텍스트 메뉴 핸들러(우클릭 메뉴 확장)**, **미리 보기 핸들러(Preview Handler)** — 를 **개념 → 레지스트리 구조 → 구현 스켈레톤(ATL)** → **배포/테스트 체크리스트** 순으로 ‘생략 없이’ 정리합니다.  
예제 코드는 C++17 / Unicode / ATL 기반(Visual Studio)이며, MFC 앱과 함께 쓰는 전형 패턴을 보여줍니다.

> 한눈 요약  
> - **파일 형식 등록**: `.xyz → ProgID → shell\open\command "%1"` + 아이콘/친절한 이름/배포 시 Capabilities(기본앱 UI).  
> - **컨텍스트 메뉴**: `IContextMenu + IShellExtInit`(고전) 또는 `IExplorerCommand`(현대)로 우클릭 메뉴 주입.  
> - **미리 보기**: `IPreviewHandler`(+ `IInitializeWithStream/File/Item`) 구현 DLL을 `.xyz\ShellEx\{PreviewHandlerIID}`에 연결.  
> - **필수 상식**: x64 탐색기는 **64비트 확장 DLL**만 로드. 레지스트리는 per-user(HKCU\Software\Classes) 우선. Programmatic default 제한(Win10/11).  

---

## 0) 기본 배경: 파일 연결/셸 확장/COM/레지스트리

- **파일 연결(File Association)** = 확장자 `.xyz`를 **ProgID**에 매핑, ProgID는 **명령/아이콘/표시명**을 정의.  
- **셸 확장(Shell Extension)** = **COM In-Proc**(DLL)로 로드되어 탐색기/대상 프로세스 안에서 실행.  
  - 컨텍스트 메뉴, 미리 보기, 아이콘 오버레이, 썸네일, 속성 핸들러 등 하위 타입 존재.  
- **레지스트리 뷰**:  
  - Per-user: `HKCU\Software\Classes` (HKCU가 HKCR보다 우선)  
  - Per-machine: `HKLM\Software\Classes`  
  - 통합 뷰: `HKCR`(읽기 편의용 합성 키)  
- **비트니스**: x64 Explorer는 **64-bit** 확장만 로드. 배포 시 x86/x64 **각각 DLL/REG** 제공.  
- **보안/안정**: 탐색기 프로세스에 인프로세스 DLL이 들어오므로 **성능/안정성/서명**이 매우 중요.

---

## 1) 파일 형식 등록(연결) – 개념과 레지스트리

### 1-1. 최소 구성(Per-user 등록 예: `.xyz` → `MyCompany.MyApp.xyz`)
```reg
Windows Registry Editor Version 5.00

; 1) 확장자 → ProgID 매핑
[HKEY_CURRENT_USER\Software\Classes\.xyz]
@="MyCompany.MyApp.xyz"

; 2) ProgID 정의
[HKEY_CURRENT_USER\Software\Classes\MyCompany.MyApp.xyz]
@="MyApp XYZ 문서"                           ; FriendlyTypeName(간단형)
"FriendlyTypeName"="@%ProgramFiles%\\MyCompany\\MyApp\\MyApp.exe,-101"  ; 리소스 문자열 선택형
"DefaultIcon"="%ProgramFiles%\\MyCompany\\MyApp\\MyApp.exe,0"            ; 아이콘

; 3) 기본 열기 명령 (open)
[HKEY_CURRENT_USER\Software\Classes\MyCompany.MyApp.xyz\shell\open\command]
@="\"%ProgramFiles%\\MyCompany\\MyApp\\MyApp.exe\" \"%1\""

; 4) 추가 동사(예: 편집/edit)
[HKEY_CURRENT_USER\Software\Classes\MyCompany.MyApp.xyz\shell\edit\command]
@="\"%ProgramFiles%\\MyCompany\\MyApp\\MyApp.exe\" /edit \"%1\""
```

- `"%1"` : 클릭된 파일 경로. 공백 포함 대비 **따옴표 필수**.  
- `DefaultIcon` : `,n` = 리소스 인덱스.  
- `FriendlyTypeName` : 리소스 문자열(국제화). 간단히 `@="표시명"`도 가능.

### 1-2. “기본 앱(Default Apps)” UI와 Capabilities(권장)
Win10/11은 앱이 **기본으로 강제 설정**하는 것을 제한.  
→ 배포 시 **Capabilities + RegisteredApplications**를 등록 → **사용자가 설정 UI에서 선택**.

```reg
; HKLM or HKCU(Per-user 설치)
[HKEY_LOCAL_MACHINE\Software\MyCompany\MyApp\Capabilities]
"ApplicationName"="MyApp"
"ApplicationDescription"="문서/이미지 XYZ 뷰어"
"ApplicationIcon"="C:\\Program Files\\MyCompany\\MyApp\\MyApp.exe,0"

; 파일 연결 목록
[HKEY_LOCAL_MACHINE\Software\MyCompany\MyApp\Capabilities\FileAssociations]
".xyz"="MyCompany.MyApp.xyz"

; 기본앱 UI에 노출
[HKEY_LOCAL_MACHINE\Software\RegisteredApplications]
"MyApp"="Software\\MyCompany\\MyApp\\Capabilities"
```

> 배포 포인트  
> - **MSI/Setup**에서 위 키 등록 + 사용자는 “기본 앱으로 설정”에서 `.xyz → MyApp` 선택.  
> - 프로그램 내에서 기본앱 강제 전환은 제한됨(사용자 상호작용 필요).

### 1-3. MFC 앱의 `CWinApp::ParseCommandLine` 연결
- 커맨드라인 `%1`(열기), `/edit %1` 등 **동사 분기**를 구현:

```cpp
BOOL CMyApp::InitInstance() {
    CCommandLineInfo cmd;
    ParseCommandLine(cmd);
    // cmd.m_nShellCommand : FileOpen / FileNew / AppRegister 등
    // cmd.m_strFileName   : "%1" 경로
    if (cmd.m_nShellCommand == CCommandLineInfo::FileOpen) {
        OpenDocumentFile(cmd.m_strFileName);
        return TRUE;
    }
    // ...
}
```

---

## 2) 컨텍스트 메뉴 핸들러(Context Menu Handler)

### 2-1. 등록 개념
- **범용**: `HKCR\*\shellex\ContextMenuHandlers\<Name>` 또는 `HKCR\AllFileSystemObjects\shellex\ContextMenuHandlers\<Name>`  
- **확장자/ProgID 한정**: `HKCR\.xyz\shellex\ContextMenuHandlers\<Name>` 또는 `HKCR\MyCompany.MyApp.xyz\shellex\ContextMenuHandlers\<Name>`  
- **값(Default)** = 구현 **CLSID**(핸들러 COM 클래스)

```reg
[HKEY_CURRENT_USER\Software\Classes\*\shellex\ContextMenuHandlers\MyAppMenu]
@="{11111111-2222-3333-4444-555555555555}"
```

> 스코프  
> - `*` : 모든 파일  
> - `AllFileSystemObjects` : 파일+폴더  
> - `.xyz` / ProgID : 특정 형식만

### 2-2. 구현 선택지
- **고전형**: `IShellExtInit` + `IContextMenu`  
- **현대형(권장)**: `IExplorerCommand`(+ `IEnumExplorerCommand`) — Cascading menu/아이콘 등 구성 쉬움.  
  (다만 Win7+ 대상. 여전히 많은 예제/레거시는 IContextMenu 기반)

이하 **IContextMenu** 스켈레톤:

#### (A) ATL 클래스를 만들어 In-Proc COM DLL로 구현
```cpp
// CLSID {11111111-2222-3333-4444-555555555555}
class ATL_NO_VTABLE CMyCtx :
  public CComObjectRootEx<CComSingleThreadModel>,
  public CComCoClass<CMyCtx, &CLSID_MyCtx>,
  public IShellExtInit,
  public IContextMenu
{
  std::vector<CString> m_sel; // 선택 파일 목록
public:
  // COM map
  BEGIN_COM_MAP(CMyCtx)
    COM_INTERFACE_ENTRY(IShellExtInit)
    COM_INTERFACE_ENTRY(IContextMenu)
  END_COM_MAP()
  DECLARE_NO_REGISTRY() // 배포 시 RGS/수동 등록

  // IShellExtInit: IDataObject에서 경로 추출
  IFACEMETHODIMP Initialize(LPCITEMIDLIST, IDataObject* pDO, HKEY) override {
    m_sel.clear();
    if (!pDO) return E_INVALIDARG;

    FORMATETC fmt = { CF_HDROP, nullptr, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM stg{};
    if (FAILED(pDO->GetData(&fmt, &stg))) return E_FAIL;

    HDROP h = (HDROP)GlobalLock(stg.hGlobal);
    UINT n = DragQueryFile(h, 0xFFFFFFFF, nullptr, 0);
    for (UINT i=0;i<n;++i) {
      CString path; DragQueryFile(h, i, path.GetBufferSetLength(MAX_PATH), MAX_PATH);
      path.ReleaseBuffer();
      m_sel.push_back(path);
    }
    GlobalUnlock(stg.hGlobal);
    ReleaseStgMedium(&stg);
    return S_OK;
  }

  // IContextMenu: 메뉴 삽입
  IFACEMETHODIMP QueryContextMenu(HMENU hMenu, UINT index, UINT idFirst, UINT idLast, UINT flags) override {
    if (flags & CMF_DEFAULTONLY) return MAKE_HRESULT(SEVERITY_SUCCESS, 0, 0);
    InsertMenu(hMenu, index, MF_BYPOSITION, idFirst + 0, L"MyApp로 변환(&V)");
    InsertMenu(hMenu, index+1, MF_BYPOSITION, idFirst + 1, L"메타데이터 보기(&M)");
    return MAKE_HRESULT(SEVERITY_SUCCESS, 0, 2); // 두 개 항목 삽입
  }

  // 명령 실행
  IFACEMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO p) override {
    if (HIWORD(p->lpVerb)) {
      // 문자열 verb로도 들어올 수 있음 (예: "myverb")
      if (lstrcmpiA(p->lpVerb, "myconvert")==0) return DoConvert();
      return E_FAIL;
    }
    switch (LOWORD(p->lpVerb)) {
      case 0: return DoConvert();
      case 1: return ShowMeta();
    }
    return E_FAIL;
  }

  IFACEMETHODIMP GetCommandString(UINT_PTR id, UINT uType, UINT*, LPSTR psz, UINT cch) override {
    if (uType == GCS_HELPTEXTA && id==0) lstrcpynA(psz, "선택 파일을 MyApp 포맷으로 변환", cch);
    return S_OK;
  }

private:
  HRESULT DoConvert() {
    // 다중 선택 파일을 백그라운드 변환, 오류 UI는 최소화
    for (auto& f : m_sel) {/*…*/}
    return S_OK;
  }
  HRESULT ShowMeta() {
    // MessageBox/커스텀 다이얼로그로 정보 표시
    return S_OK;
  }
};

OBJECT_ENTRY_AUTO(__uuidof(MyCtx), CMyCtx)
```

#### (B) 등록(RGS 또는 .reg)
```reg
; CLSID 등록
[HKEY_CURRENT_USER\Software\Classes\CLSID\{11111111-2222-3333-4444-555555555555}]
@="MyApp Context Menu Handler"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{11111111-2222-3333-4444-555555555555}\InprocServer32]
@="C:\\Program Files\\MyCompany\\MyApp\\MyShellExt.dll"
"ThreadingModel"="Apartment"

; 핸들러 연결(모든 파일)
[HKEY_CURRENT_USER\Software\Classes\*\shellex\ContextMenuHandlers\MyAppMenu]
@="{11111111-2222-3333-4444-555555555555}"
```

> 팁  
> - **현대형(IExplorerCommand)**는 Cascading 메뉴/아이콘/Enable 조건을 보다 선언적으로 구성 가능.  
> - **Approved 리스트**(과거 권장): `HKLM\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved`에 CLSID 등록.  

### 2-3. 성능/UX 체크리스트
- `Initialize`에서 **I/O 금지**(빠르게).  
- 대량 선택 시 메뉴 활성/비활성은 **조건만 판단**하고, 무거운 작업은 `InvokeCommand`에서 **비동기**.  
- 크래시 = 탐색기 전체 영향. 반드시 **예외 방지**·타임아웃·로깅.

---

## 3) 미리 보기 핸들러(Preview Handler)

### 3-1. 사용자 경험
- 탐색기(우측 미리 보기 창) / Outlook 미리 보기 등에서 **문서 내용을 빠르게 보여주는 뷰어**.  
- 대상 인터페이스: `IPreviewHandler` + `IInitializeWithStream`(권장), 또는 `IInitializeWithFile/IInitializeWithItem`.

### 3-2. 등록 구조
- **핸들러 CLSID 등록**  
- 대상 확장자의 `ShellEx\{GUID_PreviewHandler}`에 **핸들러 CLSID** 쓰기

```reg
; Preview Handler category GUID (고정)
; {8895b1c6-b41f-4c1c-a562-0d564250836f}

[HKEY_CURRENT_USER\Software\Classes\CLSID\{AAAAAAA0-1234-5678-9ABC-DEF012345678}]
@="MyApp Preview Handler"
[HKEY_CURRENT_USER\Software\Classes\CLSID\{AAAAAAA0-1234-5678-9ABC-DEF012345678}\InprocServer32]
@="C:\\Program Files\\MyCompany\\MyApp\\MyPreview.dll"
"ThreadingModel"="Apartment"

; .xyz 형식에 핸들러 연결
[HKEY_CURRENT_USER\Software\Classes\.xyz\ShellEx\{8895b1c6-b41f-4c1c-a562-0d564250836f}]
@="{AAAAAAA0-1234-5678-9ABC-DEF012345678}"
```

### 3-3. ATL 스켈레톤: `IPreviewHandler`(+ Initialize)

```cpp
class ATL_NO_VTABLE CMyPreview :
  public CComObjectRootEx<CComSingleThreadModel>,
  public CComCoClass<CMyPreview, &CLSID_MyPreview>,
  public IPreviewHandler,
  public IInitializeWithStream   // 또는 IInitializeWithFile / IInitializeWithItem
{
  CComPtr<IStream> m_stream;
  HWND m_hwndParent = nullptr;
  RECT m_rc{0,0,0,0};
  HWND m_hwndView = nullptr;  // 우리가 만든 child window(미리보기 캔버스)

public:
  BEGIN_COM_MAP(CMyPreview)
    COM_INTERFACE_ENTRY(IPreviewHandler)
    COM_INTERFACE_ENTRY(IInitializeWithStream)
  END_COM_MAP()
  DECLARE_NO_REGISTRY()

  // IInitializeWithStream
  IFACEMETHODIMP Initialize(IStream* pStream, DWORD) override {
    m_stream = pStream; // AddRef됨
    return S_OK;
  }

  // IPreviewHandler
  IFACEMETHODIMP SetWindow(HWND hwnd, const RECT* prc) override {
    m_hwndParent = hwnd; m_rc = *prc;
    return S_OK;
  }

  IFACEMETHODIMP SetRect(const RECT* prc) override {
    m_rc = *prc;
    if (m_hwndView) ::SetWindowPos(m_hwndView, nullptr, prc->left, prc->top,
                                   prc->right-prc->left, prc->bottom-prc->top,
                                   SWP_NOZORDER|SWP_NOACTIVATE);
    return S_OK;
  }

  IFACEMETHODIMP DoPreview() override {
    // 1) child 윈도우 생성
    m_hwndView = ::CreateWindowEx(0, L"STATIC", L"", WS_CHILD|WS_VISIBLE,
                  m_rc.left, m_rc.top, m_rc.right-m_rc.left, m_rc.bottom-m_rc.top,
                  m_hwndParent, nullptr, _AtlBaseModule.GetModuleInstance(), nullptr);

    // 2) m_stream에서 데이터를 읽어 GDI+/D2D 렌더링
    //    (큰 파일은 부분 파싱/저해상도 프리뷰 생성)
    //    WM_PAINT에서 그리도록 상태/비트맵 캐시 생성

    return S_OK;
  }

  IFACEMETHODIMP Unload() override {
    if (m_hwndView) { ::DestroyWindow(m_hwndView); m_hwndView = nullptr; }
    m_stream.Release();
    return S_OK;
  }

  IFACEMETHODIMP SetFocus() override { if (m_hwndView) ::SetFocus(m_hwndView); return S_OK; }
  IFACEMETHODIMP QueryFocus(HWND* ph) override { *ph = ::GetFocus(); return S_OK; }
  IFACEMETHODIMP TranslateAccelerator(MSG*) override { return S_FALSE; } // 기본 처리 없음
};

OBJECT_ENTRY_AUTO(__uuidof(MyPreview), CMyPreview)
```

> 실무 포인트  
> - **빠른 로딩**: 전체 파일 파싱 대신 **프리뷰 전용 경량 렌더**.  
> - **메모리 절약**: 축소 이미지/텍스트 헤더만 읽기.  
> - `IInitializeWithStream` 권장(파일 접근 권한/락 이슈 최소화).  
> - GDI+ / WIC / Direct2D를 사용해 **고해상도 텍스트/이미지** 선명도 확보.

---

## 4) 함께 알아두면 좋은 셸 핸들러들(개념만)

- **썸네일(Thumbnail) 핸들러**: `IThumbnailProvider` → 작은 이미지 반환(캐시됨).  
- **아이콘 핸들러**: `IExtractIcon / IThumbnailProvider` 조합으로 동적 아이콘.  
- **속성(Property) 핸들러**: `IPropertyStore` → 탐색기 열/상세창의 메타데이터 제공/편집.  
- **InfoTip**: `IQueryInfo` → 풍선 설명.

(등록 위치/인터페이스가 다를 뿐, **COM In-Proc DLL + 레지스트리 연결** 패턴은 동일)

---

## 5) 배포/서명/테스트 체크리스트

### 5-1. 배포
- **x64 Explorer** → **x64 DLL** 필수. (x86 앱에 붙일 별도 x86 DLL이 필요할 수도 있음)  
- MSI/Setup:  
  - COM 등록(클래스/ProgID/TypeLib)  
  - 확장 연결(Per-user/Per-machine 결정)  
  - Capabilities + RegisteredApplications (기본앱 UI 노출)  
- 업데이트/제거: **탐색기 재시작** 필요할 수 있음(`taskkill /IM explorer.exe /F` 후 자동 재시작 or 로그오프).

### 5-2. 보안/신뢰
- 코드 서명 강력 권장(스마트스크린/EDR 오탐 방지).  
- 탐색기 충돌 방지: 예외 처리/경계 조건/타임아웃.  
- **ThreadingModel=Apartment**가 일반적(셸 대부분 STA).

### 5-3. 테스트 툴/팁
- **ProcMon**(Sysinternals): 레지스트리/파일 접근 추적.  
- **ShellExView**(NirSoft): 등록된 셸 확장 On/Off.  
- **OLE/COM Object Viewer (oleview.exe)**: CLSID/인터페이스 점검.  
- **복원 버튼**: 문제 발생 시 안전 모드/셸 확장 비활성로 복구.  
- 레지 따라잡기: Per-user(HKCU) vs Per-machine(HKLM) **우선순위** 인지.

---

## 6) 실전 시나리오 3종 (요약 레시피)

### 6-1. 우리 포맷 `.xyz` 등록 + 열기/아이콘
1) ProgID: `MyCompany.MyApp.xyz` 정의(FriendlyTypeName/DefaultIcon/shell\open).  
2) `.xyz → ProgID` 매핑.  
3) Capabilities/RegisteredApplications 등록 → Default Apps에서 연결.

### 6-2. 우클릭 “MyApp로 변환” 추가(모든 파일)
1) **ATL In-Proc DLL** 만들고 `IShellExtInit/IContextMenu` 구현.  
2) `HKCU\Software\Classes\*\shellex\ContextMenuHandlers\MyAppMenu` = `{CLSID}`.  
3) 성능: Initialize에서 경로만 수집, 실제 변환은 InvokeCommand에서 백그라운드 실행.

### 6-3. `.xyz` 미리 보기 제공
1) `IPreviewHandler + IInitializeWithStream` 구현 DLL.  
2) `HKCU\Software\Classes\.xyz\ShellEx\{8895b1c6-b41f-4c1c-a562-0d564250836f}` = `{CLSID}`.  
3) DoPreview에서 child window 생성, stream에서 빠르게 파싱 후 GDI+/D2D로 렌더.

---

## 7) 예제 모음 (복붙 스니펫)

### 7-1. IDataObject → 파일 경로들 추출(컨텍스트/드롭 공통)
```cpp
static std::vector<CString> PathsFromDataObject(IDataObject* pDO) {
  std::vector<CString> out;
  if (!pDO) return out;
  FORMATETC fmt = { CF_HDROP, nullptr, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
  STGMEDIUM stg{};
  if (FAILED(pDO->GetData(&fmt, &stg))) return out;
  HDROP h = (HDROP)GlobalLock(stg.hGlobal);
  if (h) {
    UINT n = DragQueryFile(h, 0xFFFFFFFF, nullptr, 0);
    for (UINT i=0;i<n;++i) {
      CString path; DragQueryFile(h, i, path.GetBufferSetLength(MAX_PATH), MAX_PATH);
      path.ReleaseBuffer(); out.push_back(path);
    }
    GlobalUnlock(stg.hGlobal);
  }
  ReleaseStgMedium(&stg);
  return out;
}
```

### 7-2. Preview 핸들러: 스트림 전체를 메모리맵(큰 파일 주의 – 샘플)
```cpp
static std::string ReadAll(IStream* s, size_t cap = 4<<20) {
  std::string buf; buf.reserve(cap);
  BYTE tmp[8192]; ULONG read=0;
  LARGE_INTEGER zero{}; ULARGE_INTEGER pos{};
  s->Seek(zero, STREAM_SEEK_SET, &pos);
  while (S_OK == s->Read(tmp, sizeof(tmp), &read) && read) buf.append((char*)tmp, (size_t)read);
  return buf;
}
```

---

## 8) 자주 묻는 질문(FAQ)

**Q1. Reg-free COM으로 셸 확장을 배포할 수 있나요?**  
A. 사실상 **불가**로 보세요. 셸 확장은 COM 등록이 필요하고 탐색기가 전역 등록을 조회합니다.

**Q2. 32/64비트는 어떻게?**  
A. 64비트 탐색기는 64비트 DLL만 로드. **양쪽 바이너리**를 따로 빌드/설치하세요.

**Q3. 프로그램에서 기본앱을 바로 바꿀 수 있나요?**  
A. Win10/11에서는 **사용자 동의 UI**를 거쳐야 합니다. Capabilities 등록 후 **Default Apps**에서 선택하도록 안내.

**Q4. 왜 IExplorerCommand를 권장하나요?**  
A. 서브메뉴(카스케이딩), 아이콘, 조건부 표시 등의 **표현력/성능**이 좋고, 신 API. 다만 IContextMenu도 널리 사용됩니다.

**Q5. Preview와 Thumbnail을 같이 써야 하나요?**  
A. 역할이 다릅니다. 미리보기는 큰 패널(상세 뷰), 썸네일은 파일 아이콘에 들어갈 작은 이미지. 필요에 맞게 각각 구현.

---

## 9) 최종 체크리스트

- [ ] `.ext → ProgID → shell\open\command "%1"`  
- [ ] 아이콘/친절한 이름(리소스 문자열)  
- [ ] Capabilities + RegisteredApplications(기본앱 UI 노출)  
- [ ] 컨텍스트: `IShellExtInit/IContextMenu`(또는 `IExplorerCommand`) 구현 + 등록  
- [ ] 미리보기: `IPreviewHandler + IInitializeWithStream` 구현 + 등록  
- [ ] x86/x64 바이너리/레지 분리, **ThreadingModel=Apartment**  
- [ ] 예외/성능/느린 I/O 회피, 백그라운드 처리  
- [ ] 코드 서명/설치 제거 시 정리/탐색기 재시작 가이드  
- [ ] 테스트: ProcMon / ShellExView / oleview

---

### 마무리
셸 통합은 **레지스트리 + COM In-Proc + 엄격한 성능/안정성**의 합입니다.  
위 설계대로 **파일 연결 → 컨텍스트 메뉴 → 미리 보기**를 단계적으로 적용하면, 사용자에게 자연스러운 **Windows 네이티브 UX**를 제공할 수 있습니다.  