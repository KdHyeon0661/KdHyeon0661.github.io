---
layout: post
title: AWS - S3 버전 관리와 복원
date: 2025-07-18 19:20:23 +0900
category: AWS
---
# AWS S3 버전 관리와 복원

## 왜 ‘버전 관리(Versioning)’인가?

- **실수 방지**: 덮어쓰기/삭제로부터 데이터 보호
- **감사/추적**: 변경 이력 유지
- **복원력**: 특정 시점으로 **롤백** 가능
- **보안 연계**: Object Lock, MFA Delete, S3 Access Logs/CloudTrail과 결합

> 핵심: 같은 키(Key)의 객체를 다시 업로드해도 **기존 객체는 지워지지 않고** ‘과거 버전’으로 보존된다. 삭제는 기본적으로 **삭제 마커(Delete Marker)** 추가일 뿐, 실제 데이터는 버전에 남는다.

---

## 개념 정리 — 작동 원리(초안 보강)

| 작업 | 내부 동작 | 결과 |
|---|---|---|
| 버전 관리 ON | 새로 업로드되는 모든 객체에 **VersionId** 할당 | 최신 버전이 “현재”로 표시 |
| 덮어쓰기(같은 Key) | **새 VersionId**가 생성 | 과거 버전은 **보존** |
| 삭제 | **Delete Marker**라는 “가림막” 버전 추가 | 목록에서 사라져 보이나, 과거 버전은 존재 |
| 복원(되돌리기) | 특정 VersionId를 대상으로 **복사/마커 제거** | 원하는 시점으로 롤백 |

> **중요**: 버전 관리를 “활성화(Enabled)”했다가 “일시중단(Suspended)”해도 **기존 버전은 남아있다**. 일시중단 상태에서 업로드한 객체는 **null VersionId**를 가진다.

---

## 수학적으로 보는 비용 감각(간단 근사)

월별 저장 비용 근사:
$$
\text{Cost}_{\text{storage}} \approx \sum_{v=1}^{V} (G_v \cdot c_{\text{class}(v)})
$$

- \(V\): 보관 중인 **총 버전 수**
- \(G_v\): v번째 버전의 **GiB**
- \(c_{\text{class}(v)}\): 해당 버전의 **스토리지 클래스 단가(월/GiB)**

> 버전이 늘수록 저장비가 선형 증가하므로, **수명주기(Lifecycle)**로 **비최신(Noncurrent)** 버전 자동 정리/아카이빙이 핵심이다.

---

## 실습 A — 버킷 생성 & 버전 관리 활성화

### 콘솔(요약)

1) S3 → **버킷 생성** → 이름/리전 지정
2) 생성 후 버킷 → **속성(Properties) → 버전 관리 → 활성화**

### CLI

```bash
# 버킷 생성

aws s3api create-bucket \
  --bucket my-versioned-bucket \
  --create-bucket-configuration LocationConstraint=ap-northeast-2

# 버전 관리 활성화

aws s3api put-bucket-versioning \
  --bucket my-versioned-bucket \
  --versioning-configuration Status=Enabled

# 상태 확인

aws s3api get-bucket-versioning --bucket my-versioned-bucket
```

### IaC (CloudFormation 스니펫)

```yaml
Resources:
  VersionedBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: my-versioned-bucket
      VersioningConfiguration:
        Status: Enabled
```

### IaC (Terraform 스니펫)

```hcl
resource "aws_s3_bucket" "versioned" {
  bucket = "my-versioned-bucket"
}

resource "aws_s3_bucket_versioning" "versioned" {
  bucket = aws_s3_bucket.versioned.id
  versioning_configuration {
    status = "Enabled"
  }
}
```

---

## 실습 B — 업로드/수정/삭제/조회

```bash
# 업로드 1

echo "Hello Version 1" > test.txt
aws s3 cp test.txt s3://my-versioned-bucket/test.txt

# 업로드 2 (덮어쓰기 → 새 버전 생성)

echo "Hello Version 2" > test.txt
aws s3 cp test.txt s3://my-versioned-bucket/test.txt

# 삭제(실제 삭제가 아니라 Delete Marker 추가)

aws s3 rm s3://my-versioned-bucket/test.txt

# 버전/삭제 마커 조회

aws s3api list-object-versions --bucket my-versioned-bucket --prefix test.txt
```

출력의 핵심 포인트:
- `"Versions"` 배열: 객체의 실제 버전들(VersionId 포함)
- `"DeleteMarkers"` 배열: 삭제 마커(VersionId 포함, IsLatest 여부 확인)

---

## 2가지 방법

### **특정 버전을 현재 버전으로 복사**

```bash
aws s3api copy-object \
  --bucket my-versioned-bucket \
  --copy-source my-versioned-bucket/test.txt?versionId=<VERSION_ID> \
  --key test.txt
```
- 지정한 `<VERSION_ID>`를 **새 최신 버전**으로 복원(= copy-on-restore)

### **삭제 마커 제거(삭제 복구)**

```bash
aws s3api delete-object \
  --bucket my-versioned-bucket \
  --key test.txt \
  --version-id <DELETE_MARKER_VERSION_ID>
```
- 삭제 마커를 지우면, **이전 최신 객체 버전**이 다시 보인다.

> 어느 방법을 쓰든 **원본 과거 버전 자체는 유지**되며, 복원 행위도 새 버전을 만든다고 이해하면 된다.

---

## 실무 설계 — 수명주기(Lifecycle)로 **오래된 버전 자동 처리**

### 비최신 버전 자동 삭제(180일)

```json
{
  "Rules": [
    {
      "ID": "DeleteOldNoncurrentVersions",
      "Status": "Enabled",
      "Filter": { "Prefix": "" },
      "NoncurrentVersionExpiration": {
        "NoncurrentDays": 180
      }
    }
  ]
}
```

적용(예: CLI):

```bash
aws s3api put-bucket-lifecycle-configuration \
  --bucket my-versioned-bucket \
  --lifecycle-configuration file://lifecycle.json
```

### 비용 최적화: 비최신 버전을 Glacier로 전환

```json
{
  "Rules": [
    {
      "ID": "ArchiveNoncurrentToGlacier",
      "Status": "Enabled",
      "Filter": { "Prefix": "" },
      "NoncurrentVersionTransitions": [
        { "NoncurrentDays": 30, "StorageClass": "GLACIER" }
      ],
      "NoncurrentVersionExpiration": { "NoncurrentDays": 3650 }
    }
  ]
}
```

> 30일 지난 비최신 버전을 Glacier로 아카이브, 10년 후 일괄 삭제 예시.

---

## 보안 강화 — **MFA Delete**와의 결합

- **기능**: 특정 민감 조작(버전 삭제/버전 관리 상태 변경)에 **MFA 코드** 요구
- **특징**:
  - **버킷 소유자(일반적으로 루트)**만 활성화/비활성화 가능
  - **CLI/SDK**로만 설정(콘솔에서 직접 토글 불가한 점이 많음)
  - 계정/리전/거버넌스 정책 조건에 따라 사용성 제약이 있을 수 있음

### 활성화 예시(가능한 환경 가정)

```bash
# 버전 관리 'Enabled' + 'MFA Delete Enabled' 동시 적용

aws s3api put-bucket-versioning \
  --bucket my-versioned-bucket \
  --versioning-configuration Status=Enabled,MFADelete=Enabled \
  --mfa "arn:aws:iam::<ACCOUNT_ID>:mfa/root-account-mfa-device <CURRENT_OTP_CODE>"
```

> 실제 운영에선 **루트 계정 MFA**와 **정책/프로세스**를 정교히 설계해야 한다.
> MFA Delete가 어렵다면 대안으로 **Object Lock(Governance/Compliance)**를 검토(불변성 보장).

---

## 레플리케이션(Replication)과 버전

- **버전 관리된 원본** → **버전 관리된 대상**으로 **버전 포함 복제** 가능
- **CRR(Cross-Region Replication)** / **SRR(Same-Region Replication)** 지원
- **삭제 마커 복제**, **필터(접두사/태그)**, **KMS 암호화 키 권한** 주의

### 간단 스니펫(원본 버킷에 규칙 설정)

```json
{
  "Role": "arn:aws:iam::<ACCOUNT_ID>:role/s3-replication-role",
  "Rules": [
    {
      "ID": "ReplicateAll",
      "Status": "Enabled",
      "Priority": 1,
      "DeleteMarkerReplication": { "Status": "Enabled" },
      "Filter": { "Prefix": "" },
      "Destination": {
        "Bucket": "arn:aws:s3:::my-versioned-bucket-dr",
        "StorageClass": "STANDARD_IA"
      }
    }
  ]
}
```

적용:

```bash
aws s3api put-bucket-replication \
  --bucket my-versioned-bucket \
  --replication-configuration file://replication.json
```

> 대상 버킷도 **버전 관리 활성화** 필수. KMS 사용 시 CMK 권한(Encrypt/Decrypt/Replicate) 교차 허용 필요.

---

## 관측성/감사 — 변경 이력 가시화

- **CloudTrail**: `PutObject`, `DeleteObject`, `PutBucketVersioning`, `DeleteMarkerCreated` 등 이벤트 기록
- **S3 Access Logs / CloudTrail Lake / Athena**로 분석 가능
- **S3 Inventory**: 버킷 내 객체/버전 목록을 정기적으로 CSV/ORC/Parquet로 출력

### 구성 예시

```json
{
  "Destination": {
    "S3BucketDestination": {
      "AccountId": "<ACCOUNT_ID>",
      "Bucket": "arn:aws:s3:::my-inventory-bucket",
      "Format": "CSV",
      "Prefix": "inventory"
    }
  },
  "IsEnabled": true,
  "Id": "daily-inventory",
  "IncludedObjectVersions": "All",
  "Schedule": { "Frequency": "Daily" }
}
```

적용:

```bash
aws s3api put-bucket-inventory-configuration \
  --bucket my-versioned-bucket \
  --id daily-inventory \
  --inventory-configuration file://inventory.json
```

---

## 트러블슈팅

| 증상 | 원인 | 해결 |
|---|---|---|
| 삭제했는데도 과거 버전 남음 | 정상 동작(삭제 마커 추가) | 복원하려면 마커 제거 or 과거 버전 복사 |
| `AccessDenied` 복원 실패 | 권한 부족(`s3:GetObjectVersion`, `s3:CopyObject`) | IAM 정책/버킷 정책 점검 |
| 리스트에 null VersionId 보임 | 일시중단 상태 업로드 | 버전 관리 “활성화” 후 재업로드, 필요 시 수동 복원 |
| 비용 급증 | 과거/대용량 버전 누적 | Lifecycle로 비최신 전환/만료, S3 Inventory로 상시 모니터 |
| 레플리케이션 안 됨 | 대상 버킷 버전 미활성, KMS 권한, 역할 권한 | 대상 설정/권한 재점검, 실패 사유는 Replication status/metrics 확인 |

---

## S3 버전 관리 vs Object Lock (상호보완)

| 항목 | Versioning | Object Lock |
|---|---|---|
| 목적 | 이력/복원 | **삭제/수정 방지(불변성)** |
| 삭제 방지 | 기본 불가(버전 삭제 가능) | **가능**(Retention/Legal Hold) |
| 규정 준수 | 보조적 | **준수 중심(Compliance 모드)** |
| 함께 쓰기 | 권장(이력 + 불변성) | 권장(불변을 가지는 각 버전에 이력 유지) |

---

## 실전 팁(초안 확장)

- **정적 웹/배포 산출물**: 최신만 필요 → 비최신 버전 **즉시 Glacier 전환** 또는 **짧은 만료**
- **백업/로그**: 비최신 버전 **장기 보존** + **Object Lock(Governance/Compliance)**로 불변성
- **대용량 바이너리**: 멀티파트 업로드 시에도 버전은 동일 원칙. 업로더 측 **ETag/무결성** 점검
- **태그/폴 older 전개**: `env=prod`, `type=backup` 등 태깅 → Lifecycle/비용/감사 필터링에 유리

---

## 명령 치트시트

```bash
# 버킷 만들기 + 버전 관리 켜기

aws s3api create-bucket --bucket my-versioned-bucket \
  --create-bucket-configuration LocationConstraint=ap-northeast-2
aws s3api put-bucket-versioning --bucket my-versioned-bucket \
  --versioning-configuration Status=Enabled

# 업로드 2회 + 삭제

aws s3 cp a.txt s3://my-versioned-bucket/a.txt
aws s3 cp a2.txt s3://my-versioned-bucket/a.txt
aws s3 rm s3://my-versioned-bucket/a.txt

# 버전/삭제 마커 확인

aws s3api list-object-versions --bucket my-versioned-bucket --prefix a.txt

# 복원(특정 버전 복사)

aws s3api copy-object \
  --bucket my-versioned-bucket \
  --copy-source my-versioned-bucket/a.txt?versionId=<VER> \
  --key a.txt

# 삭제 복구(삭제 마커 제거)

aws s3api delete-object \
  --bucket my-versioned-bucket \
  --key a.txt \
  --version-id <DELETE_MARKER_ID>

# 수명주기 적용

aws s3api put-bucket-lifecycle-configuration \
  --bucket my-versioned-bucket \
  --lifecycle-configuration file://lifecycle.json
```

---

## 요약(핵심만 재정리)

| 항목 | 내용 |
|---|---|
| 버전 관리 핵심 | **덮어쓰기/삭제에도 과거 버전 보존** |
| 복원 | **특정 버전 복사** 또는 **삭제 마커 제거** |
| 비용 관리 | **Lifecycle**로 비최신 전환/만료, **Inventory**로 가시화 |
| 보안 결합 | **MFA Delete**, **Object Lock**, **CloudTrail** |
| 운영 원칙 | 프로덕션은 **버전 관리+정책** 기본, 복원/삭제는 **승인 절차**로 관리 |

---

## 보너스 — 안전한 “롤백 러너” 스크립트(예시)

```bash
#!/usr/bin/env bash
# 사용법: ./rollback.sh <bucket> <key> <version-id>

set -euo pipefail

B=$1
K=$2
V=$3

echo "[*] 복원 대상: s3://$B/$K (from version $V)"
aws s3api head-object --bucket "$B" --key "$K" --version-id "$V" >/dev/null

TMP="s3://$B/.restore-checkpoint/$(date +%s)-$K"
echo "[*] 안전장치: 현재 최신을 백업 -> $TMP"
aws s3 cp "s3://$B/$K" "$TMP" || echo "[!] 최신 버전이 없을 수도 있음(삭제 상태)."

echo "[*] 지정 버전 복사 -> 최신으로 승격"
aws s3api copy-object \
  --bucket "$B" \
  --copy-source "$B/$K?versionId=$V" \
  --key "$K"

echo "[*] 완료. list-object-versions로 결과 확인 권장."
```

- **롤백 전 최신본을 안전 위치에 백업**(실수 대응)
- **지정 VersionId를 새 최신으로 승격** → 즉시 복원

---

이로써 **S3 버전 관리와 복원**의 전 과정을 **개념→실습→운영→보안/비용** 관점에서 정리했다.
당신의 초안이 강조한 **실수 복구/삭제 복원**을 유지하면서, **MFA Delete, Lifecycle, Replication, Inventory, Object Lock 연계**까지 확장하여 **운영 가능한 가이드**로 승격했다.
