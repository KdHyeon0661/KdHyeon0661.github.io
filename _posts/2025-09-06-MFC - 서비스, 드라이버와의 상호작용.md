---
layout: post
title: MFC - 서비스, 드라이버와의 상호작용
date: 2025-09-06 23:25:23 +0900
category: MFC
---
# 서비스/드라이버와의 상호작용(권한/UAC/보안 관점 완전 정리)
(Win32/MFC/ATL 기준 · Windows 10/11 · x64 · 설치/권한/UAC/세션0/토큰/SDDL/SCM/SetupAPI/INF/장치 I/O/보안 체크리스트 포함)

이 글은 **사용자 모드 애플리케이션**(예: MFC GUI)이 **Windows 서비스**(User-mode, Session 0)나 **커널 드라이버**(Kernel-mode)와 **안전하게 상호작용**하는 방법을, **권한/UAC/보안** 관점에서 **생략 없이** 정리합니다.  
“**무엇을 앱이 하고, 무엇을 서비스/드라이버가 해야 하는가**”, “**어떻게 권한을 최소화하면서 IPC를 안전하게 열 것인가**”를 **구조/코드/체크리스트** 중심으로 설명합니다.

---

## 0) 한 눈에 보는 설계 원칙(요약)

1. **권한 분리(Least-Privilege)**  
   - GUI 프로세스는 **표준 권한(표준 사용자)**로; 관리자·SYSTEM 권한은 **서비스/드라이버**에서만.  
   - “Elevation(승격)”은 **설치/관리 작업**에서만 예외적으로.

2. **세션 0 격리**  
   - **서비스/드라이버는 세션 0**에서 동작, UI 금지. UI가 필요하면 **IPC로 사용자 세션 프로세스와 통신**.

3. **UAC를 코딩으로 ‘회피’하지 말 것**  
   - 관리자 권한이 필요한 작업은 **설치 시점** 또는 **전용 관리자 도구**(별 EXE)에서 수행.  
   - 일반 실행 파일은 `asInvoker` 유지(기본), 필요 시 `runas`로 **명시적 승격 UI**.

4. **보안 경계는 ‘IPC’**  
   - **Named Pipe / ALPC(고급) / RPC / Socket** 등 통신 채널에 **SDDL(ACL)**을 적용해 **허용 주체만 접속**.  
   - **인증/권한 확인**은 서비스 쪽에서 재검증(신뢰는 경계 외부).

5. **드라이버 접근은 파일 핸들과 IOCTL**  
   - `CreateFile("\\.\DeviceName")` + `DeviceIoControl`  
   - 드라이버의 **장치 오브젝트 보안**(SDDL/INF)으로 **접근 주체 제한**.

6. **로깅/감사/업데이트**  
   - 이벤트 로그(ETW/EventLog)로 감사 가능하도록.  
   - 드라이버는 **서명/EV 인증서/WHQL** 고려.  
   - 업데이트는 **서비스-중개 패턴**(elevated service가 교체).

---

## 1) UAC/토큰/권한 기초: 왜 서비스/드라이버가 필요한가?

### 1-1. UAC & 토큰 흐름 요약
- 사용자는 기본적으로 **표준 권한 토큰**으로 로그인.  
- 관리자 계정이라도 **UAC on** 환경에서는 평소 **제한 토큰**으로 실행, **승격 요청** 시에만 **높은 무결성 관리자 토큰**이 발급.  
- **커널 드라이버 작업, 시스템 보호 폴더/레지스트리 쓰기, 서비스 설치/시작** 등은 관리자(또는 SYSTEM) 권한 필요.

### 1-2. 권한 요구의 분리
- **앱(UX)**: 표준 권한 + 사용자 파일/네트워크 접근 수준만.  
- **서비스**: `LocalService`/`NetworkService`/`LocalSystem` 등 **서비스 계정**으로 필요한 권한만.  
- **드라이버**: 커널 모드로, 설치/로드/IOCTL 허용 범위는 **엄격하게 제한**.

### 1-3. 실행 레벨(Manifest)
```xml
<!-- app.exe.manifest -->
<requestedExecutionLevel level="asInvoker" uiAccess="false" />
```
> 관리자 작업이 필요한 **관리자 도구**는 별도 EXE로 `requireAdministrator`. 일반 UX는 `asInvoker` 고수.

---

## 2) 서비스(Service) 상호작용: SCM, 계정, 보안, IPC

### 2-1. 서비스 설치/제거/시작/중지 (SCM API)
관리자 도구(또는 설치자)에서만 수행:

```cpp
#include <winsvc.h>
#pragma comment(lib, "Advapi32.lib")

bool InstallService(LPCWSTR name, LPCWSTR display, LPCWSTR binPath) {
    SC_HANDLE scm = OpenSCManager(nullptr, nullptr, SC_MANAGER_CREATE_SERVICE);
    if (!scm) return false;
    SC_HANDLE svc = CreateService(
        scm, name, display,
        SERVICE_ALL_ACCESS,
        SERVICE_WIN32_OWN_PROCESS,            // 독립 프로세스
        SERVICE_AUTO_START, SERVICE_ERROR_NORMAL,
        binPath,
        nullptr, nullptr, nullptr,
        L"NT AUTHORITY\\LocalService", nullptr // 계정(권장: LocalService)
    );
    if (!svc) { CloseServiceHandle(scm); return false; }
    // 보완: SERVICE_SID_TYPE_UNRESTRICTED 설정(서비스 고유 SID)
    SERVICE_SID_INFO sidInfo{ SERVICE_SID_TYPE_UNRESTRICTED };
    ChangeServiceConfig2(svc, SERVICE_CONFIG_SERVICE_SID_INFO, &sidInfo);
    CloseServiceHandle(svc);
    CloseServiceHandle(scm);
    return true;
}
```

> **계정 선택 가이드**  
> - `LocalService`: 로컬 리소스 최소 권한 + 네트워크로는 **익명**(컴퓨터 자격 X) → 대다수 시나리오 권장  
> - `NetworkService`: 네트워크 접근 시 컴퓨터 자격으로 인증 필요할 때  
> - `LocalSystem`: 최상위. 정말 필요한 경우에만(드라이버 관리/보안감시장치 등)

### 2-2. 서비스 프로세스 뼈대
```cpp
// 서비스 메인(단일 서비스 예시)
SERVICE_STATUS_HANDLE g_sh = nullptr;
SERVICE_STATUS g_ss = { SERVICE_WIN32_OWN_PROCESS };

void Report(DWORD state, DWORD win32=NO_ERROR) {
    g_ss.dwCurrentState = state;
    g_ss.dwWin32ExitCode = win32;
    g_ss.dwControlsAccepted = (state==SERVICE_RUNNING) ? (SERVICE_ACCEPT_STOP|SERVICE_ACCEPT_SHUTDOWN) : 0;
    SetServiceStatus(g_sh, &g_ss);
}

VOID WINAPI SvcCtrlHandler(DWORD dwCtrl) {
    if (dwCtrl == SERVICE_CONTROL_STOP || dwCtrl == SERVICE_CONTROL_SHUTDOWN) {
        Report(SERVICE_STOP_PENDING);
        // 정리…
        Report(SERVICE_STOPPED);
    }
}

VOID WINAPI SvcMain(DWORD, LPWSTR*) {
    g_sh = RegisterServiceCtrlHandler(L"MySvc", SvcCtrlHandler);
    Report(SERVICE_START_PENDING);
    // 초기화(IPC 열기, 쓰레드 시작, 권한 낮추기 등)
    Report(SERVICE_RUNNING);
    // 메인 루프 또는 WaitForSingleObject on stop event …
}

int wmain() {
    SERVICE_TABLE_ENTRY st[] = {
        { const_cast<LPWSTR>(L"MySvc"), SvcMain }, { nullptr, nullptr }
    };
    StartServiceCtrlDispatcher(st);
    return 0;
}
```

### 2-3. IPC와 SDDL(보안)
**Named Pipe** 예: 사용자 세션에서 서비스로 요청을 보내는 채널.

- **서버(서비스)**: 파이프 생성 시 **보안 서술자**(SDDL)로 **허용 주체**를 제한  
- **클라(앱)**: `CreateFile(R"\\.\pipe\MyCompany\MySvc")`

#### (A) 서버 쪽 파이프 생성(SDDL)
```cpp
#include <sddl.h>

HANDLE CreateSecurePipeServer() {
    // D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GRGW;;;BU)
    // SYSTEM, Administrators: Full; Built-in Users: Read/Write (필요 최소)
    LPCWSTR sddl = L"D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GRGW;;;BU)";

    PSECURITY_DESCRIPTOR sd = nullptr;
    ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl, SDDL_REVISION_1, &sd, nullptr);

    SECURITY_ATTRIBUTES sa{ sizeof(sa), sd, FALSE };
    HANDLE h = CreateNamedPipeW(
        L"\\\\.\\pipe\\MyCompany\\MySvc",
        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE | FILE_FLAG_OVERLAPPED,
        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
        4, 64*1024, 64*1024, 0, &sa);

    LocalFree(sd); // sd는 sa 복사 안 하므로 CreateNamedPipe 후 즉시 해제 안전
    return h;
}
```

#### (B) 클라이언트에서 호출
```cpp
bool CallService(const std::string& request, std::string& reply) {
    HANDLE h = CreateFileW(L"\\\\.\\pipe\\MyCompany\\MySvc",
        GENERIC_READ|GENERIC_WRITE, 0, nullptr, OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED, nullptr);
    if (h==INVALID_HANDLE_VALUE) return false;

    DWORD wr=0, rd=0; BOOL ok;
    ok = WriteFile(h, request.data(), (DWORD)request.size(), &wr, nullptr);
    if (!ok) { CloseHandle(h); return false; }

    char buf[64*1024];
    ok = ReadFile(h, buf, sizeof(buf), &rd, nullptr);
    if (!ok) { CloseHandle(h); return false; }

    reply.assign(buf, buf+rd);
    CloseHandle(h);
    return true;
}
```

> **중요**  
> - 서비스는 `ImpersonateNamedPipeClient`로 **클라이언트 토큰**을 가져와 **사용자 자격으로 파일 작업** 수행 가능(최소 권한).  
> - 민감 명령은 **추가 인증**(서명 토큰/비밀 키/세션ID 검증)으로 강화.

### 2-4. 세션 0 ↔ 사용자 세션 알림(토스트/트레이)
- 서비스가 직접 UI를 띄우지 말고, **사용자 세션 프로세스**에 IPC로 알림을 보내 **그 프로세스가 UI 표시**.  
- 특정 사용자 세션 찾기: `WTSEnumerateSessions` → `WTSGetActiveConsoleSessionId` → `WTSQueryUserToken`  
- 그 토큰으로 `CreateProcessAsUser` or `CreateProcessWithTokenW` 하여 **사용자 세션에 헬퍼 EXE**를 실행(최소한도로).

```cpp
// 서비스에서 현재 콘솔 세션의 사용자 토큰 취득
HANDLE UserTokenFromActiveSession() {
    DWORD sid = WTSGetActiveConsoleSessionId();
    HANDLE hTok = nullptr;
    if (!WTSQueryUserToken(sid, &hTok)) return nullptr;
    return hTok; // CloseHandle 필요
}
```

---

## 3) 드라이버(Kernel-mode) 상호작용: 설치/서명/IOCTL/보안

### 3-1. 드라이버 설치/시작(서비스의 한 유형)
SCM에서 드라이버는 `SERVICE_KERNEL_DRIVER`.

```cpp
bool InstallDriver(LPCWSTR name, LPCWSTR pathSys) {
    SC_HANDLE scm = OpenSCManager(nullptr, nullptr, SC_MANAGER_CREATE_SERVICE);
    if (!scm) return false;
    SC_HANDLE svc = CreateService(
        scm, name, name,
        SERVICE_ALL_ACCESS,
        SERVICE_KERNEL_DRIVER,
        SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
        pathSys, nullptr, nullptr, nullptr, nullptr, nullptr);
    bool ok = (svc != nullptr);
    if (svc) CloseServiceHandle(svc);
    CloseServiceHandle(scm);
    return ok;
}
```

> **현실적 권장**  
> - 드라이버 설치/제거는 **설치자(MSI)** 또는 **관리자 도구**에서만.  
> - Windows 10/11 x64: **드라이버 서명 필수**(EV CodeSigning + Attestation/WHQL). 테스트는 `테스트 모드`/테스트 서명.

### 3-2. 장치 인터페이스/열기/IOCTL
드라이버가 **장치 인터페이스 GUID**를 노출하면 사용자 모드에서 `SetupDi`로 열 수 있습니다.

```cpp
#include <SetupAPI.h>
#pragma comment(lib, "Setupapi.lib")
bool OpenFirstDevice(const GUID& ifGuid, HANDLE& out) {
    HDEVINFO h = SetupDiGetClassDevs(&ifGuid, nullptr, nullptr, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
    if (h == INVALID_HANDLE_VALUE) return false;
    SP_DEVICE_INTERFACE_DATA ifdata{ sizeof(ifdata) };
    if (!SetupDiEnumDeviceInterfaces(h, nullptr, &ifGuid, 0, &ifdata)) { SetupDiDestroyDeviceInfoList(h); return false; }

    DWORD cb=0; SetupDiGetDeviceInterfaceDetail(h, &ifdata, nullptr, 0, &cb, nullptr);
    std::vector<BYTE> buf(cb);
    auto detail = reinterpret_cast<SP_DEVICE_INTERFACE_DETAIL_DATA*>(buf.data());
    detail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
    if (!SetupDiGetDeviceInterfaceDetail(h, &ifdata, detail, cb, nullptr, nullptr)) { SetupDiDestroyDeviceInfoList(h); return false; }

    out = CreateFile(detail->DevicePath, GENERIC_READ|GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
    SetupDiDestroyDeviceInfoList(h);
    return (out != INVALID_HANDLE_VALUE);
}
```

IOCTL 호출:

```cpp
#define IOCTL_MYDRV_PING CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

bool DriverPing(HANDLE dev) {
    DWORD ret=0;
    return DeviceIoControl(dev, IOCTL_MYDRV_PING, nullptr, 0, nullptr, 0, &ret, nullptr);
}
```

### 3-3. 장치 오브젝트 보안(드라이버 쪽)
- 드라이버는 **장치 오브젝트**에 **보안 서술자**를 부여해야 함(누가 `CreateFile` 가능한지).  
- 보통 **INF 파일**의 `AddReg` 또는 `Security` 섹션에서 SDDL 지정.

INF 예(개념):
```
[MyDevice.NT.Services]
AddService = MyDrv, 0x00000002, MyDrv_Service

[MyDrv_Service]
DisplayName    = "My Driver"
ServiceType    = 1 ; SERVICE_KERNEL_DRIVER
StartType      = 3 ; DEMAND
ErrorControl   = 1
ServiceBinary  = %12%\MyDrv.sys
AddReg         = MyDrv_AddReg

[MyDrv_AddReg]
HKR, , "Security", 0x00000001, "D:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;GR;;;BU)"
; SYSTEM/Administrators: Full, Users: Read(열기)만 허용 등
```

> **주의**: 장치에 대한 접근을 지나치게 넓게 열면 **권한 상승 취약점**이 됩니다. 반드시 필요한 그룹에만.

---

## 4) 권한 상승(승격) 시나리오 설계

### 4-1. ShellExecute “runas”
설정/수리/설치 등 **관리자 UI**가 필요할 때:
```cpp
SHELLEXECUTEINFOW sei{ sizeof(sei) };
sei.lpVerb = L"runas";
sei.lpFile = L"AdminTool.exe";
sei.nShow  = SW_SHOWNORMAL;
if (!ShellExecuteExW(&sei)) {
    DWORD err = GetLastError(); // 사용자 취소(ERROR_CANCELLED) 등
}
```

### 4-2. Elevated COM Moniker
COM 서버를 자동 승격(표준 UAC UI)하여 사용하는 패턴:
```cpp
CComPtr<IUnknown> unk;
BIND_OPTS3 bo{ sizeof(bo) };
bo.dwClassContext = CLSCTX_LOCAL_SERVER;
CoGetObject(L"Elevation:Administrator!new:{CLSID-여기}", &bo, IID_PPV_ARGS(&unk));
```
> 제한/정책/등록 필요. 일반 앱보단 **관리자 도구**에 어울림. 대안은 **서비스 중개**.

### 4-3. 서비스-중개 패턴(권장)
- GUI는 표준 권한.  
- **서비스가 Elevated 작업**(레지스트리 HKLM/Program Files 변경, 드라이버 교체 등)을 수행.  
- GUI → 서비스 요청 시 **의도/권한을 재검증**. (예: 로컬 관리자 그룹 여부, 서명 검증)

---

## 5) 보안: 무결성 수준/권한/감사

### 5-1. 무결성 수준(Integrity Level)
- **MIC**: Low/Medium/High/System. 브라우저 샌드박스(저무결성) 등  
- 서비스는 보통 **System**.  
- 파이프/파일 등의 **SACL**에 무결성 규칙을 추가해 **Low IL 차단** 가능:
  - 예: SDDL에 `ML;;NW;;;ME` (Medium 이상만) 등

### 5-2. 서비스 필수 권한 제한
- `SERVICE_REQUIRED_PRIVILEGES_INFO`로 서비스가 필요한 **권한 목록** 한정:
```cpp
LPWSTR reqPrivs = L"SeCreateGlobalPrivilege\0SeChangeNotifyPrivilege\0\0";
ChangeServiceConfig2(svc, SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO, &reqPrivs);
```
> 서비스 프로세스에 불필요한 권한 제거 → 공격면 축소.

### 5-3. 감사/로깅
- **Windows Event Log**에 소스 등록, 중요 이벤트 기록.  
- ETW(고급): 성능/감사 분리.  
- 보안 관점: 성공/실패 모두 충분한 맥락(사용자 SID/세션/명령)을 남겨 **사후 분석** 가능하게.

---

## 6) 흔한 요구 5종 — 안전한 패턴

### 6-1. 파일 시스템 보호 폴더 쓰기(Program Files 등)
- 앱은 쓰지 않음. **서비스(관리자)** 혹은 **설치자**가 수행.  
- 일반 앱 데이터는 `%ProgramData%` 또는 `%LocalAppData%` 사용.

### 6-2. 드라이버 업데이트
- GUI에서 **서비스에 명령** → 서비스가 `ControlService`로 중지 → 파일 교체 → 시작.  
- 교체 전 **서명 검증**(카탈로그/서명 체인) 필수.

### 6-3. 네트워크 포트 리스닝(방화벽 규칙)
- 설치자 또는 관리자 도구가 **방화벽 예외 규칙** 추가.  
- 서비스는 최소 권한 계정으로 리슨.

### 6-4. 표준 사용자로 파일 백업(관리자 소유 디렉터리)
- 서비스가 `ImpersonateNamedPipeClient`로 **사용자 자격**을 얻어 사용자 접근 가능한 경로 내에서만 백업.  
- 반대로 관리자만 접근 가능한 경로는 서비스 권한으로.

### 6-5. 다계정 PC에서 UI 알림
- 각 사용자 세션별 **트레이 헬퍼** 프로세스(표준 권한)를 [로그온 시 자동 실행]  
- 서비스 ↔ 헬퍼 간 **명명 파이프/ALPC**로 통지 → 헬퍼가 UI 표시.

---

## 7) 샘플: “관리자 작업을 서비스로 위임” (끝-끝 예제)

### 7-1. 프로토콜
- 파이프: `\\.\pipe\MyCo\Mgr`  
- 요청(JSON 예): `{"cmd":"InstallDriver","path":"C:\\Temp\\MyDrv.sys"}`  
- 응답: `{"ok":true,"err":0}`

### 7-2. 서비스 핸들러(요지)
```cpp
void HandleRequest(const std::string& req, std::string& resp) {
    auto cmd = ParseJson(req)["cmd"].get<std::string>();
    if (cmd=="InstallDriver") {
        // 추가 검증: 호출자 SID가 로컬 관리자 그룹? 서명 확인?
        bool ok = InstallDriver(L"MyDrv", L"C:\\Temp\\MyDrv.sys");
        resp = ok ? R"({"ok":true})" : R"({"ok":false,"err":1})";
    } else if (cmd=="StartDriver") {
        // ...
    } else {
        resp = R"({"ok":false,"err":"unknown"})";
    }
}
```

### 7-3. 클라이언트(MFC) 버튼 핸들러
```cpp
void CMainDlg::OnBnClickedInstallDrv() {
    std::string reply;
    if (!CallService(R"({"cmd":"InstallDriver","path":"C:\\Temp\\MyDrv.sys"})", reply)) {
        AfxMessageBox(L"서비스 연결 실패"); return;
    }
    // JSON 파싱 후 결과 안내
}
```

---

## 8) 배포/서명/업데이트

- **서비스/드라이버**는 MSI/관리자 권한 설치, **코드 서명**(특히 드라이버는 EV+WHQL/Attestation).  
- **x86/x64 분리**.  
- 제거 시: 서비스 중지/삭제, 드라이버 제거, 레지스트리/파일 정리.  
- 업데이트: 서비스가 자기 자신 교체는 X → **업데이트 서비스** 별도이거나, 서비스 중지 후 설치자 교체.

---

## 9) 문제 해결(트러블슈팅)

- **ERROR_ACCESS_DENIED**: UAC/토큰/SDDL 확인. 파이프 ACL, 서비스 계정 권한, 장치 SDDL.  
- **서비스가 UI 안 뜸**: 정상. 세션 0 격리. 사용자 세션 헬퍼/IPC 구조로.  
- **드라이버 CreateFile 실패**: 장치 경로/인터페이스 GUID/서명 상태/보안 서술자/인증서 시간.  
- **ControlService 중지 실패**: 서비스가 STOP 제어코드 처리 안 함 → `SERVICE_ACCEPT_STOP`/핸들러 구현 확인.  
- **서명 오류**: 테스트 서명/부팅 모드/EV 인증서/타임스탬프/체인.

---

## 10) 체크리스트(보안/권한/UAC)

- [ ] 앱은 `asInvoker`  
- [ ] 관리자 작업은 **별도 도구** 또는 **서비스 위임**  
- [ ] 서비스 계정은 **LocalService/NetworkService** 우선, 필요 시 권한 추가  
- [ ] `SERVICE_SID_TYPE_UNRESTRICTED` + `SERVICE_REQUIRED_PRIVILEGES_INFO`로 최소 권한  
- [ ] IPC 채널에 **SDDL** 설정, 서비스에서 **재인증**  
- [ ] 드라이버 장치/인터페이스 **SDDL 제한**, 서명/배포 정책  
- [ ] 세션 0 격리 준수(서비스는 UI 금지), 사용자 세션 헬퍼 사용  
- [ ] 이벤트 로그/ETW 로깅  
- [ ] 설치/업데이트/제거 시 **안전한 순서**(중지→교체→시작)  
- [ ] 크래시 격리/예외 처리/타임아웃(탐색기·시스템 영향 방지)

---

## 부록 A) SDDL 치트시트(자주 쓰는 패턴)

- 기본 형식: `O:<owner>S:<group>D:<DACL>S:<SACL>` (보통 `D:`만)  
- SID 약어: `SY`(SYSTEM), `BA`(Administrators), `BU`(Users), `WD`(Everyone), `RC`(Restricted), `AU`(Authenticated Users)  
- 권한: `GA`(Generic All), `GR`(Generic Read), `GW`(Generic Write)  
- 무결성: SACL에 `ML;;NW;;;ME`(Medium 이상), `LW`(Low) 등

예:
- `D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GRGW;;;BU)`  
  → SYSTEM/관리자: Full, Users: Read/Write  
- 장치 제한적 열기: `D:(A;;GR;;;SY)(A;;GR;;;BA)(A;;GR;;;S-1-5-21-...-RidOfOurAppGroup)`  
  → 특정 로컬 그룹만 열기 허용

---

## 부록 B) 권한 상승 대안 비교

| 방법 | 장점 | 단점 | 용도 |
|---|---|---|---|
| 설치자(MSI) | 정책 친화, 롤백/서명 | 개발/배포 비용 | 설치/업데이트 |
| AdminTool.exe + runas | 단순, 명시적 UAC | UX 분리 필요 | 일회성 설정 |
| Elevated COM Moniker | COM 친화 | 등록/정책 제약 | 관리 도구 |
| 서비스-중개(권장) | UX 표준권한, 보안 경계 명확 | IPC 설계 필요 | 상시 관리자 작업 |

---

## 부록 C) 최소/샘플 SVC + GUI 구조(프로젝트 템플릿 요약)

- `App.exe` : MFC GUI(표준 권한)  
- `Svc.exe` : Windows Service(LocalService, 최소 권한) — 파이프 서버, 관리자 작업 수행  
- `Drv.sys` : (선택) 드라이버 — 장치 보안 SDDL 엄격  
- `AdminTool.exe` : 관리자 도구(선택) — 설치/수리/드라이버 등록 등  
- `Setup.msi` : 설치/등록/제거

---

### 마무리
**권한/UAC/보안**을 먼저 결정하면, 서비스/드라이버 연동은 **예측 가능하고 안전**해집니다.  
핵심은 **권한 분리 + 안전한 IPC + 제한된 SDDL + 로깅**입니다.