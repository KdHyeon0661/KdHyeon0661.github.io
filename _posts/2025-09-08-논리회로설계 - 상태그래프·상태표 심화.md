---
layout: post
title: 논리회로설계 - 상태그래프·상태표 심화
date: 2025-09-08 19:25:23 +0900
category: 논리회로설계
---
# 상태그래프·상태표 심화 — **직렬 데이터 코드 변환**, **영숫자 상태그래프 표기**, **비완전 명세 상태표**

> 표기: 입력 \(x\in\{0,1\}\), 출력 \(y\in\{0,1\}\), 상태(또는 상태벡터) \(q\), 다음상태 \(q^+\).
> 모델: **동기식**(클럭형) 순서회로를 기본으로 하며 Mealy(간선 출력)·Moore(노드 출력) 모두 다룹니다.
> 본 문서는 기존 글(시퀀스 검출기/상태그래프 기본) 위에 **코드 변환 FSM**·**영숫자 표기 규칙**·**비완전 명세 최소화(ISM)** 를 추가 확장한 심화편입니다.

---

## 1. 직렬 데이터 **코드 변환(Code Conversion)**

직렬 링크의 라인코드·프레이밍은 **DC 밸런스/전이 밀도/클럭 복원**과 직결됩니다. FSM 관점에서 구현·검증하는 대표 사례들을 정리합니다.

### 1.1 NRZ ↔ **NRZI** (기억 의존형)

- **정의**
  - **NRZI 인코딩**: 데이터 \(d[k]\)가 1이면 **레벨 토글**, 0이면 **유지**.
  - **NRZI 디코딩**: **레벨 변화면 1**, **유지면 0**.
- **상태(Moore)**: 직전 라인 레벨 \(q\in\{0,1\}\).
- **다음상태/출력(인코더)**
  \[
  q^+ = q \oplus d,\qquad y = q^+
  \]
- **상태표(인코더, Moore)**

| 현재 \(q\) | \(d\) | 다음 \(q^+\) | 출력 \(y\) |
|:--:|:--:|:--:|:--:|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 |
| 1 | 0 | 1 | 1 |
| 1 | 1 | 0 | 0 |

- **상태그래프(영숫자 표기 예)**
  상태 `L0(출력0)`, `L1(출력1)` 두 노드. `d=1`이면 교차, `d=0`이면 자기루프.
  ```
  L0 --d=0--> L0  ,  L0 --d=1--> L1
  L1 --d=0--> L1  ,  L1 --d=1--> L0
  ```

- **디코더(Mealy, 출력 등록 권장)**
  \(y = r[k]\oplus r[k-1]\) (간선 출력이므로 한 클럭 **등록** 후 외부로 내보내기).

**VHDL 스니펫**

```vhdl
-- NRZI Encoder (Moore)
library ieee; use ieee.std_logic_1164.all;
entity nrzi_enc is
  port (clk, rst: in std_logic; d: in std_logic; y: out std_logic);
end;
architecture rtl of nrzi_enc is
  signal q: std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then q <= '0';
      else            q <= q xor d; -- 1이면 토글
      end if;
    end if;
  end process;
  y <= q; -- Moore: 노드 출력
end;

-- NRZI Decoder (Mealy -> registered)
entity nrzi_dec is
  port (clk, rst: in std_logic; r: in std_logic; y: out std_logic);
end;
architecture rtl of nrzi_dec is
  signal r_d, y_i: std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r_d<='0'; y_i<='0';
      else             y_i <= r xor r_d;  r_d <= r; -- 변화=1
      end if;
    end if;
  end process;
  y <= y_i;
end;
```

---

### 1.2 **맨체스터(Manchester)** (전이 중심형, 이더넷 표준 규칙)

- **규칙(IEEE 802.3)**: 비트 기간을 전/후반부로 나누고,
  \(d=1\Rightarrow\) **하이→로우**, \(d=0\Rightarrow\) **로우→하이** (비트 **중간에 전이**가 항상 존재).
- **상태**: `(half,level)` 또는 “하프클럭 위치”만 상태로 두고 **전이를 출력으로 생성**(Mealy).
- **아이디어**
  - 하프클럭 경계마다 **강제 전이** 1회(클럭 정보).
  - 데이터에 따라 **중간 전이 방향**을 결정.

**개념 상태표(하프클럭 단위, Mealy)**

| 상태 | 의미 | 입력 \(d\) | 다음 | 출력(전이) |
|:--:|:--|:--:|:--:|:--|
| A | 비트 전반부 | 0/1 | B | 없음(레벨 유지) |
| B | 비트 후반부 | 0 | A | 로우→하이 |
| B | 비트 후반부 | 1 | A | 하이→로우 |

> **디코딩**: 비트 중간의 **전이 방향**을 검출 → \(d\) 판단. PLL/CRU로 **하프클럭 정렬** 후 FSM 해석.

**Verilog 파형 생성 틀(개념)**

```verilog
// 맨체스터: half_tick은 bit_clk의 2배. d는 bit_clk 기준 샘플 가정.
always @(posedge half_clk) begin
  if (rst) begin level<=0; phase<=0; end
  else begin
    phase <= ~phase; // 전/후반부 토글
    if (phase) begin
      // 후반부: 데이터에 따른 중간 전이
      level <= (d) ? 1'b0 : 1'b1; // 1: H->L, 0: L->H
    end
    else begin
      // 전반부: 맨체스터는 비트 경계에서도 전이 존재(레벨 보정)
      level <= ~level;
    end
  end
end
assign y = level;
```

---

### 1.3 **4B/5B**, **8b/10b** (블록코딩) — FSM의 역할

- **4B/5B**: 4비트→5비트 매핑(전이 밀도 확보, 장시간 0 회피).
  - **FSM 역할**: **프레이밍/워드경계** 유지, **특수 심볼(K)** 식별, **언더런/오버런** 처리.
- **8b/10b**(Widmer–Franaszek): **Running Disparity(RD)** 를 상태로 두고, RD에 따라 **대체 코드워드**를 선택하여 DC 밸런스 유지.
  - 상태 \(RD\in\{+1,-1\}\), 전이 `(RD, 8b) → (10b, RD^+)`.
  - 실무에선 8b→(6b,3b) 분리 룩업 + **RD FSM**으로 선택/갱신.

**RD FSM(요지)**

| 현재 RD | 선택 규칙 | 다음 RD |
|:--:|:--|:--:|
| +1 | **음의 불균형** 코드워드 우선 | 입력 코드의 디스패리티에 따름 |
| -1 | **양의 불균형** 코드워드 우선 | 동일 |

> 블록코딩 본체는 **룩업(ROM)**, FSM은 **경계/동기/RD 관리**를 담당.
> 대역이 높다면 2–3단 파이프라인으로 지연·클럭 여유를 분배.

---

### 1.4 **프레이밍/워드 정렬 FSM**(동기 상태기계)

직렬 스트림에서 **프리앰블/싱크 패턴**을 감지해 **워드 경계**를 맞추는 상위 FSM:

- **상태**: `UNLOCK` → `ACQUIRE` → `LOCK`.
  - `UNLOCK`: 임의 정렬, 슬라이딩 윈도우로 패턴 탐색.
  - `ACQUIRE`: 연속 \(M\)회 성공 시 `LOCK`. 실패 시 `UNLOCK`.
  - `LOCK`: 주기적 검증, 누적 \(K\)회 실패 시 해제.

**상태표(개념)**

| 상태 | 조건 | 다음 | 보정 동작 |
|---|---|---|---|
| UNLOCK | win==SYNC | ACQUIRE | 포인터 정렬, 카운터=1 |
| ACQUIRE | 연속 M회 | LOCK | 정렬 확정 |
| ACQUIRE | 실패 | UNLOCK | 포인터 슬라이드 |
| LOCK | 연속 K회 실패 | UNLOCK | 재동기 시작 |

---

### 1.5 **64b/66b** 스크램블러(참고) — “FSM+LFSR” 하이브리드

- 64b/66b(10G/25G 이더넷)에서는 **라인코드 대신 스크램블링**으로 전이 밀도/스펙트럼 평탄화.
- **Self-synchronizing scrambler**: \(s[k]=x[k]\oplus s[k-39]\oplus s[k-58]\) 등.
  - 하드웨어: 지연선 58비트 LFSR 유사 구조 + XOR.
  - FSM은 **프레임 헤더(2비트 ‘01/10’)**, **락/언락** 및 **에러 폴리싱** 관리.

---

## 2. **영숫자 상태그래프 표기**(Alphanumeric Notation)

문서/블로그/리뷰에서 **의미가 드러나는 상태 이름**과 **일관된 라벨 규칙**을 쓰면 설계와 검증이 빠릅니다.

### 2.1 권장 규칙

- **상태 이름**
  - 의미형: `IDLE`, `LOCK`, `ERR`, `S101`(“101까지 매치”), `ACQ2`(acquire 카운트=2).
  - 소형 예제: `A,B,C,...` 또는 `S0,S1,S2...` (블로그 도식에 적합).
- **라벨**
  - Mealy: **간선**에 `입력/출력` (`x/y`). 여러 입력은 `0,1/y`로 묶기.
  - Moore: **노드**에 `이름|y=...` 또는 괄호로 표기 `S4(1)`.
- **초기 상태**: 이중 원 또는 `→A` 화살표.
- **기본/와일드카드**: `else` 또는 `–` 사용(명세가 허용하는 범위).
- **도식 배치**: 전진은 우/하향, 루프는 작은 곡선, 교차 최소화.

### 2.2 “붙여넣기용” 상태표/그래프 세트 — `1011`(Mealy, 겹침 허용)

**상태표**

| 현재 | x=0        | x=1        |
|:---:|:-----------|:-----------|
| A   | A / 0      | B / 0      |
| B   | C / 0      | B / 0      |
| C   | A / 0      | D / 0      |
| D   | C / 0      | B / **1**  |

**ASCII 상태그래프**

```
A --0/0--> A   A --1/0--> B
B --0/0--> C   B --1/0--> B
C --0/0--> A   C --1/0--> D
D --0/0--> C   D --1/1--> B
```

> 표와 그래프는 **상호 변환** 가능해야 하며, 리뷰 시 두 표현을 함께 제시하면 오류가 줄어듭니다.

---

## 3. **비완전 명세 상태표**(ISM: Incompletely Specified Machines)

현실 명세에는 “불가능 입력”, “관심 없음(don’t-care)”, “다음상태 미정”이 섞입니다. **don’t-care를 최적화에 활용**하되, **Self-start/Lockout 방지**가 최우선입니다.

### 3.1 유형

1) **불가능 입력 조합**: 프로토콜 상 동시에 1일 수 없는 신호 등.
2) **출력 don’t-care**: 특정 조합에서 출력은 시스템에 영향 없음.
3) **다음상태 미정**: “어디로 가도 됨”을 열어둔 명세.
4) **불법 상태**: 사용하지 않는 상태코드(전원 인가/SEU로 진입 가능).

### 3.2 최소화 이론(요약) — **호환(compatibility)**·**합병(merger)**·**닫힌 커버**

- **Moore 호환**: 두 상태 \(P,Q\)가 **정의된 입력**에 대해 **같은 출력**이며, 그 입력에서의 **다음상태 쌍**이 **재귀적으로 호환** ⇒ \(P,Q\)는 호환.
  - 입력이 **미정(-)** 인 곳은 **제약 없음**(나중에 유리하게 채움 가능).
- **절차**
  1) **호환 표/그래프** 작성(미정 칸은 ‘자유’).
  2) **최대 호환집합(Maximal compatibles)** 도출.
  3) **닫힌 커버(Closed cover)** 선택: 커버 내부 전이가 **커버 안**으로 닫히도록.
  4) 합병 후, 남은 미정 전이를 **닫힘/안전**을 깨지 않게 채움.
- **Mealy**: 간선 출력까지 고려(간선 라벨 동일성 필요).

### 3.3 완전 예제 — 비완전 **Moore** FSM 최소화

**초기 상태표** (상태 \(A,B,C,D\), 입력 \(x\in\{0,1\}\), 출력 \(y(A)=y(B)=y(C)=0\), \(y(D)=1\))

| 현재 | x=0 → | x=1 → |
|:--:|:--:|:--:|
| A | B | – |
| B | C | D |
| C | – | A |
| D | D | – |

**호환 판단(요지)**
- 같은 출력끼리 후보: (A,B), (A,C), (B,C).
- (B,C): x=1에서 (D,A)로 → 출력 (1,0) **불일치** ⇒ **불가**.
- (A,B): x=0에서 (B,C)를 요구 → 방금 **불가** ⇒ **불가**.
- (A,C): x=0 또는 1 중 **하나는 미정**이라 제약 없음 ⇒ **호환**.

**최대 호환집합**: {A,C}, (B), (D).
**닫힌 커버 선택** 및 **미정 채우기**:

| 새 상태 | x=0 → | x=1 → | 출력 |
|:--:|:--:|:--:|:--:|
| **AC** | B | **AC** | 0 |
| **B**  | AC | D | 0 |
| **D**  | D | **D** | 1 |

검증: 전이 **완전 정의**, \#상태 **4→3**, Self-start: \{AC,B,D\}로 닫힘.

### 3.4 ISM **설계 레시피**

1) **표를 끝까지 채우기**: 가능한 한 ‘–’로 **명시**.
2) **Self-start 기본값**: ‘–’는 **IDLE(초기)** 로 귀결(안전 우선).
3) **호환표→최대 호환집합**→**닫힌 커버** 선택.
4) **불법 코드 복구**: `when others => IDLE;` (동기복구).
5) **합성 최적화**: don’t-care를 **K-map ‘d’** 로 써서 최소화. 단, 닫힘/안전 먼저 확보.
6) **검증**: 임의 초기 상태에서 **루프 수렴**(자기시동) 어서션.

---

## 4. **테이블·그래프·코드** “바로 붙여넣기” 모음

### 4.1 NRZI 인코더 상태표/그래프

| 현재 상태 | 입력 d | 다음 | 출력 |
|:--:|:--:|:--:|:--:|
| L0 | 0 | L0 | 0 |
| L0 | 1 | L1 | 1 |
| L1 | 0 | L1 | 1 |
| L1 | 1 | L0 | 0 |

```
L0 --d=0/0--> L0   L0 --d=1/1--> L1
L1 --d=0/1--> L1   L1 --d=1/0--> L0
```

### 4.2 맨체스터 인코더(개념) 상태표

| 상태 | 의미 | d=0 | d=1 | 비고 |
|:--:|:--|:--|:--|:--|
| A | 비트 전반부 | B / (전이없음) | B / (전이없음) | half tick |
| B | 비트 후반부 | A / L→H | A / H→L | 중간 전이 |

### 4.3 프레이밍 FSM(UNLOCK/ACQUIRE/LOCK) 상태표

| 상태 | 조건 | 다음 | 동작 |
|---|---|---|---|
| UNLOCK | SYNC hit | ACQUIRE | 포인터 정렬, cnt=1 |
| ACQUIRE | cnt==M | LOCK | 정렬 확정 |
| ACQUIRE | miss | UNLOCK | 포인터 슬라이드 |
| LOCK | miss K회 | UNLOCK | 재동기 |

---

## 5. **검증/시뮬레이션** — TB & 어서션

### 5.1 NRZI **엔드-투-엔드** TB (인코더→채널→디코더)

```verilog
`timescale 1ns/1ps
module tb_nrzi;
  reg clk=0, rst=1, d=0; wire w, y;
  nrzi_enc enc(.clk(clk),.rst(rst),.d(d),.y(w));
  nrzi_dec dec(.clk(clk),.rst(rst),.r(w),.y(y));
  always #5 clk=~clk;

  // 랜덤 데이터 스트림
  integer i;
  initial begin
    repeat(2) @(posedge clk); rst=0;
    for (i=0;i<256;i++) begin
      d = $urandom_range(0,1);
      @(posedge clk);
      // 디코더 출력은 1클럭 등록 지연을 고려하여 비교
      @(posedge clk);
      if (y !== d) $display("MISCOMPARE @%0t: d=%0b y=%0b", $time, d, y);
    end
    $finish;
  end
endmodule
```

### 5.2 SVA — **프레이밍 FSM** 락/언락 속성

```verilog
// ACQUIRE에서 연속 M회 성공하면 LOCK
property p_acq_to_lock;
  @(posedge clk) disable iff (rst)
    (state==ACQUIRE && success && $stable(ptr))[->M] |=> (state==LOCK);
endproperty
assert property (p_acq_to_lock);

// LOCK에서 K회 실패하면 UNLOCK
property p_lock_to_unlock;
  @(posedge clk) disable iff (rst)
    (state==LOCK && miss)[*K] |=> (state==UNLOCK);
endproperty
assert property (p_lock_to_unlock);
```

---

## 6. **실무 체크리스트**

- [ ] **Mealy 출력 등록**: 글리치·펄스폭 보장(특히 NRZI 디코더, 프레이밍 이벤트).
- [ ] **CDC 동기화**: 외부 직렬 입력은 2단 FF 후 FSM 투입.
- [ ] **원-핫 인코딩**(FPGA): 다음상태식 작성이 단순, 라우팅 유리.
- [ ] **ISM 닫힌 커버**: 미정 전이는 IDLE/ERR로 귀결, 불법 상태 동기복구.
- [ ] **블록코딩**: 코드워드 룩업은 ROM, FSM은 **RD/경계/에러** 관리.
- [ ] **프레이밍 FSM**: UNLOCK/ACQUIRE/LOCK 구조 + 히스테리시스(M,K).
- [ ] **테스트**: 랜덤·의도적 패턴, 에러 주입(전이 손실/삽입)로 회복성 검증.
- [ ] **타이밍**: half/bit 클럭 파생 시 지터·위상 정렬(PLL/CRU) 스펙 확인.

---

## 7. 연습문제 (원하면 해설 제공)

1) NRZI 인코더/디코더를 **원-핫**과 **이진 인코딩**으로 각각 구현하고, LUT/FF 사용량과 Fmax를 비교하라.
2) 맨체스터 인코더를 **하프클럭 생성기**와 FSM으로 분리 설계하고, 2배 오버샘플러 디코더의 상태표를 작성하라.
3) 8b/10b의 **Running Disparity FSM**을 상태표로 만들고, 8b 입력에 따라 RD가 +1↔–1로 바뀌는 경계를 표시하라.
4) 프레이밍 FSM의 M,K를 변수로 두어 히스테리시스가 **락 유지 확률**에 미치는 영향을 몬테카를로로 추정하는 TB를 작성하라.
5) ISM 예제(§3.3)에서 (A,B) 호환이 불가인 이유를 **출력·전이 쌍** 기준으로 증명하라(Mealy·Moore 각각).

---

## 8. 포켓 요약

- **코드 변환 FSM**: NRZI(기억 의존), 맨체스터(전이 중심), 4B/5B·8b/10b(룩업+상태: RD·경계).
- **영숫자 표기**: 의미 있는 상태명, Mealy는 **간선 `입력/출력`**, Moore는 **노드 출력**.
- **ISM 최소화**: 호환/최대호환/닫힌커버 → **상태 합병**, 미정 전이는 **안전 귀결**로 채움.
- **검증**: Mealy 출력 **등록**, 프레이밍 히스테리시스, 랜덤·에러 주입 TB + SVA 속성으로 보장.
