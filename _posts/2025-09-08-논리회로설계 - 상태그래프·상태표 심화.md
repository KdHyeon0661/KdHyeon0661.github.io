---
layout: post
title: 논리회로설계 - 상태그래프·상태표 심화
date: 2025-09-08 19:25:23 +0900
category: 논리회로설계
---
# 상태그래프·상태표 심화 — **직렬 데이터 코드 변환**, **영숫자 상태그래프 표기**, **비완전 명세 상태표**

> 표기: 입력 \(x\in\{0,1\}\), 출력 \(y\in\{0,1\}\), 상태(또는 상태벡터) \(q\), 다음상태 \(q^+\).  
> 모델: **클럭형**(동기) 순서회로를 기본으로 하며 Mealy(간선 출력)·Moore(노드 출력)를 모두 다룹니다.

---

## 1) 직렬 데이터 **코드 변환(Code Conversion)**

직렬 전송에선 **라인코드(line code)** 와 **프레이밍**이 신호 무결성과 복원에 직접 영향을 줍니다. 순서회로(FSM)로 구현되는 대표 변환들을 **상태표/그래프** 관점에서 정리합니다.

### 1.1 NRZ ↔ **NRZI** 변환 (기억 의존형 코드)

- **정의**:  
  NRZI 인코딩: 데이터 비트 \(d[k]\)가 1이면 **출력 레벨을 토글**, 0이면 **유지**.  
  디코딩은 반대로 “레벨 변화=1, 유지=0”으로 해석.
- **상태**: 이전 출력 레벨 \(q\in\{0,1\}\) (Moore).  
- **다음상태/출력(인코더)**:
  \[
  q^+ = q \oplus d,\qquad y = q^+ \quad(\text{에지 직후의 레벨을 출력})
  \]
- **상태표(인코더, Moore)**

| 현재 \(q\) | \(d\) | 다음 \(q^+\) | 출력 \(y\) |
|:--:|:--:|:--:|:--:|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 |
| 1 | 0 | 1 | 1 |
| 1 | 1 | 0 | 0 |

- **상태그래프**: 두 노드(레벨 0/1), `d=1`이면 반대 노드로, `d=0`이면 자기 루프.

> **디코더(Mealy)**: 입력 레벨 \(r[k]\)와 직전 \(r[k-1]\) 비교 \(y = r[k]\oplus r[k-1]\). FSM 상태는 “이전 레벨” 한 비트면 충분.

---

### 1.2 **맨체스터(Manchester)** 인코딩

- **정의**: 각 비트를 **하프클럭** 두 구간으로 나눔.  
  - 일반적 규칙(IEEE 802.3): \(d=1\Rightarrow\) 하이→로우, \(d=0\Rightarrow\) 로우→하이.
- **상태**: “하프클럭 위치(전/후)” + “현재 극성” 을 저장하는 2~3상태 Mealy.  
- **전이 아이디어**: 하프클럭 경계마다 **무조건 전이**(클럭/2) 발생, 또 데이터에 따라 **비트 중간 전이 방향** 결정.
- **상태표(개념, Mealy)**

| 상태 | 하프클럭 pos | 입력 \(d\) | 다음 | 출력전이 |
|:--:|:--:|:--:|:--:|:--|
| S0 | 전반부 | 0/1 | S1 | 전이 없음(레벨 유지) |
| S1 | 후반부 | 0 | S0 | 로우→하이 |
| S1 | 후반부 | 1 | S0 | 하이→로우 |

> **복원(디코딩)**: 하프클럭 중간 전이의 **방향**을 검출 → \(d\) 결정. 2× 오버샘플링 또는 위상정렬 회로(PLL/시계복원) 후 FSM으로 해석.

---

### 1.3 **4B/5B**, **8b/10b** 등 블록코딩의 직렬화

- **4B/5B 인코딩**: 4비트 니블 → 5비트 코드워드(연속 ‘0’ 방지).  
  FSM 역할은 **프레이밍(워드 경계)**, **특수코드(K-symbol)** 인식, **언더런 에러** 처리.
- **8b/10b**: **달리기 불균형(running disparity)** 를 상태로 두는 Mealy/Moore.  
  - 상태 \(RD\in\{+1,-1\}\)에 따라 **대체 코드워드** 선택 → 다음 \(RD^+\)가 정해짐.  
  - 상태표는 `(현재 RD, 8b 데이터) -> (10b 코드, RD^+)`.

> 블록코딩 자체는 룩업(ROM)으로 구현하고, **FSM은 경계/동기/디스패리티**를 관리하는 것이 실무적입니다.

---

### 1.4 **프레이밍/단어 정렬 FSM**

직렬 스트림에서 **동기패턴(프리앰블)** 을 검출하여 **워드 경계**를 맞추는 FSM:

- 상태: `UNLOCK` → `ACQUIRE` → `LOCK` 세 단계.  
- `UNLOCK`: 임의 비트 스캔, 동기패턴 감지 시 `ACQUIRE`.  
- `ACQUIRE`: 연속 \(M\)회 패턴 성공 시 `LOCK`. 실패 시 `UNLOCK`.  
- `LOCK`: 주기적으로 패턴 확인, \(K\)회 실패 시 `UNLOCK`.

이 FSM이 **코드 변환 파이프라인의 맨 앞**에서 명세된 **단어 경계**를 보장해 줍니다.

---

### 1.5 VHDL 스니펫 — **NRZI 인코더/디코더**

```vhdl
-- NRZI Encoder (Moore)
library ieee; use ieee.std_logic_1164.all;
entity nrzi_enc is
  port (clk, rst : in std_logic;
        d        : in std_logic;   -- NRZ data
        y        : out std_logic); -- NRZI line level
end;
architecture rtl of nrzi_enc is
  signal q : std_logic := '0'; -- previous level/state
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then q <= '0';
      else            q <= q xor d;   -- toggle on '1'
      end if;
    end if;
  end process;
  y <= q;
end;

-- NRZI Decoder (Mealy -> registered)
entity nrzi_dec is
  port (clk, rst : in std_logic;
        r        : in std_logic;  -- received level
        y        : out std_logic);-- recovered NRZ bit
end;
architecture rtl of nrzi_dec is
  signal r_d, bit_i : std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r_d <= '0'; bit_i <= '0';
      else
        bit_i <= r xor r_d; -- transition => '1'
        r_d   <= r;
      end if;
    end if;
  end process;
  y <= bit_i;
end;
```

---

## 2) **영숫자 상태그래프 표기**(Alphanumeric Notation)

교재·문서에서 **상태를 A,B,C… 또는 S0,S1,…, Z0…** 같은 **영숫자**로 표기하면 **의미 부여**와 **가독성**이 좋아집니다.

### 2.1 표기 규칙(권장)

- **상태 이름**:  
  - 기능을 담은 이름: `IDLE`, `LOCK`, `ERR`, `S101`(“101까지 매치”).  
  - 간단한 예제: `A,B,C,...` (또는 `S0,S1,S2`).  
- **라벨**:  
  - **Mealy**: **간선**에 `입력/출력` (`x/y`) 표기. 여러 입력은 `0,1/y`로 축약.  
  - **Moore**: **노드**에 `상태(출력)` 또는 `상태|y=...`.  
- **기본/기타**: `else` 또는 `–`(와일드카드) 사용 가능(명세가 허용할 때).  
- **초기 상태**: **이중 원** 또는 `→A` 화살표로 표시.  
- **동일 전이 묶기**: 같은 휴리스틱(예: `x=0/0`과 `x=1/0`이 모두 자기 루프면 `*/0`로 표기).  
- **가독성**: 전진 간선은 **오른쪽/아래**, 루프는 **작은 곡선**, 교차 최소화.

### 2.2 예 — `1011` 검출기(Mealy, 중첩 허용)

```
      0/0          1/0
 A ───────▶ A ─────────▶ B
 ▲         │            │
 │         │0/0         │0/0
 │         ▼            ▼
 D ◀────── C ◀──────── B
      0/0       1/0
 D --1/1--> B    (D에서 x=1이면 검출)
```

- 상태 의미: `A`(길이0), `B`(‘1’), `C`(‘10’), `D`(‘101’).  
- 간선 `1/1`은 **검출**을 의미. 위 그래프는 **상태표**로 직결됩니다.

---

## 3) **비완전 명세 상태표**(Incompletely Specified Machines, ISM)

현실의 명세는 종종 “일부 입력 조합은 **불가능**(환경 제약)” 혹은 “**관심 없음**(don’t-care)” 입니다. 이런 **빈 칸**을 잘 활용하면 **상태 최소화**·**논리 간략화**가 큰 폭으로 가능하지만, **안전성(Self-start/Lockout)** 을 반드시 보장해야 합니다.

### 3.1 비완전 명세의 유형

1) **불가능 입력 조합**: 예) 프로토콜 상 동일 클럭에 `REQ`와 `ACK`가 함께 1일 수 없음.  
2) **출력 don’t-care**: 해당 입력·상태에서 출력이 시스템에 영향 없음.  
3) **다음상태 미지정**: 설계자가 “아무 데나 가도 됨”으로 남겨둔 경우.  
4) **불법 상태**: 초기화/에러로 진입할 수 있는 사용하지 않는 상태 코드.

### 3.2 설계 원칙

- **Self-start**: **모든** 상태에서 합법 루프에 **수렴**하게 채우기(기본값/복귀 경로).  
- **락아웃 방지**: 특정 불법 루프에 갇히지 않게 **닫힌 커버(Closed Cover)** 선택.  
- **안전 우선**: don’t-care를 최적화에 쓰되, **예상 밖 입력**에서도 안전한 동작.

### 3.3 최소화 이론(요약) — **호환(compatibility)**·**합병(merger)**

- **Moore에서의 호환**: 두 상태 \(P,Q\)가 **모든 정의된 입력**에 대해 **출력이 동일**하고, 정의된 전이의 **다음상태 쌍**이 **재귀적으로 호환**이면 \(P\)와 \(Q\)는 호환.  
  - 입력이 **미정(-)** 인 곳은 **제약 없음**(나중에 유리하게 채움 가능).  
- **절차**:  
  1) **호환 표/그래프** 작성(미정은 제약 X).  
  2) **최대 호환집합(maximal compatibles)** 구하기.  
  3) **닫힌 커버(Closed cover)** 선택: 커버 내부 전이가 **커버 안**으로 닫히게.  
  4) 새 상태로 **합병**, 미정 전이를 **충족되게 채움**.

> Mealy도 유사하나 **출력이 간선**에 있으므로 호환 조건을 간선 출력까지 포함해 판단.

---

## 4) **완전 예제** — 비완전 Moore FSM 최소화

### 4.1 초기 상태표(미정 ‘–’ 포함)

- 상태: \(A,B,C,D\), 입력 \(x\in\{0,1\}\).  
- 출력: \(y(A)=y(B)=y(C)=0,\; y(D)=1\).

| 현재 | x=0 → | x=1 → |
|:--:|:--:|:--:|
| **A** | B | – |
| **B** | C | D |
| **C** | – | A |
| **D** | D | – |

### 4.2 호환 판단(요지)

- **동일 출력**인 쌍만 후보: (A,B), (A,C), (B,C).  
- (B,C): x=1에서 (D,A)로 가므로 **출력(1,0)이 다름** → **호환 불가**.  
- (A,B): x=0에서 (B,C) 요구 → 방금 **불가**였으므로 **불가**.  
- (A,C): x=0,1 중 **적어도 하나가 미정**이라 제약 없음 → **호환**.

따라서 **최대 호환집합**: {A,C}. (B), (D)는 단독.

### 4.3 닫힌 커버 선택 및 재정의

- 새 상태들: **AC**, **B**, **D**.  
- 전이 채우기(미정 보완, 닫힘 보장):

| 새 상태 | x=0 → | x=1 → | 출력 |
|:--:|:--:|:--:|:--:|
| **AC** | B | **AC** | 0 |
| **B**  | AC | D | 0 |
| **D**  | D  | **D** | 1 |

- 설명:  
  - `AC,1→AC`는 원래 `C,1→A`를 합병한 것(닫힘 유지).  
  - `D,1→D`는 미정을 자기루프로 채워 **닫힘**·**안전** 보장.

### 4.4 결과 검증

- 모든 전이는 **정의됨**, 출력은 유지, 상태 수 4→3으로 **감소**.  
- Self-start: 임의 상태에서도 닫힌 집합 \{AC,B,D\} 안에서 순환.

---

## 5) 비완전 명세 상태표의 **실무 완성 전략**

1) **기본값 설계**: 미정 전이는 **초기/IDLE** 로 귀결(“fail-safe to IDLE”).  
2) **오류 흡수 상태**: `ERR`를 두고 미정 입력은 `ERR`로, 여기서만 명시적 복구 경로.  
3) **디버깅 편의**: 미정에 “**어설션**(시뮬에서 report)” 넣기 → 합성에서는 기본값.  
4) **불법 상태 복귀**: 레지스터 리셋 누락/SEU 대비, **모든 상태코드**에서 `IDLE`로 가는 **동기 복구** 추가.  
5) **K-map 최적화**: 미정/불가능은 **don’t-care(`d`)** 로 표기해 조합식 최소화. 단, **전이 닫힘**과 **안전 경로** 먼저 확정.

---

## 6) 상태표 ↔ 상태그래프 변환 **요령**

- **그래프→표**: 각 노드/간선을 표의 칸으로 옮기되, **모든 입력**에 대한 칸을 **완전**하게 채운다(미정은 `–`로 표기).  
- **표→그래프**: 각 칸을 간선으로, Mealy는 `x/y`, Moore는 노드에 `y`.  
- **영숫자 표기 활용**: 그래프에 `A,B,C…`를, 표엔 그 순서로 행을 배치하면 상호 검증이 쉬움.

---

## 7) VHDL 구현 팁(ISM 대응)

- **기본값**으로 닫힘/안전 보장:
```vhdl
-- one-hot 예시: default로 IDLE 귀결
case state is
  when A => if x='0' then ns <= B; else ns <= A; end if; -- 미정 채움
  when B => if x='0' then ns <= C; else ns <= D; end if;
  when C => if x='1' then ns <= A; else ns <= IDLE; end if;
  when D => ns <= D; -- 미정 1도 자기루프
  when others => ns <= IDLE; -- 불법 상태 복구
end case;
```
- **Mealy 출력의 등록**: 글리치/타이밍 문제 회피를 위해 `y_i <= expr;` 후 한 클럭 레지스터링.
- **어설션**: 시뮬 전용 `assert false report "UNSPEC" severity warning;` 를 미정 분기에 배치.

---

## 8) 체크리스트

- [ ] 코드 변환 FSM 앞단에 **프레이밍/동기 FSM**을 배치했는가?  
- [ ] 영숫자 표기: **상태 의미가 드러나는 이름**을 썼는가? 초기 상태 표시?  
- [ ] 상태표는 **완전하게** 채웠는가(미정은 `–`로 명시)?  
- [ ] 비완전 명세 최소화 시 **호환/닫힌 커버**를 확인했는가?  
- [ ] Self-start/Lockout 방지 경로가 있는가?  
- [ ] Mealy 출력은 **등록**되어 외부로 나가나?  
- [ ] 불법 상태에 대한 **동기 복구**(when others)가 있는가?

---

### 포켓 요약
- **직렬 코드 변환**은 FSM으로 “메모리(이전 레벨/상태)”를 보유해 NRZI·맨체스터·블록코딩의 **규칙**을 구현한다.  
- **영숫자 상태그래프 표기**는 가독성과 의도 전달에 유리하며, Mealy는 **간선**, Moore는 **노드**에 출력 표시.  
- **비완전 명세 상태표**는 don’t-care를 활용해 **최소화**하되, **닫힌 커버·Self-start**를 보장해야 안전하다.
