---
layout: post
title: 논리회로설계 - 비완전 명세함수 · 진리표 작성 예 · 2진수 덧셈기 & 뺄셈기 설계
date: 2025-08-28 20:25:23 +0900
category: 논리회로설계
---
# 비완전 명세함수 · 진리표 작성 예 · 2진수 덧셈기 & 뺄셈기 설계

> 표기: \(+\)=OR, \(\cdot\) 또는 생략=AND, \(\overline{A}\)=NOT \(A\), \(\oplus\)=XOR.  
> 목표: **비완전 명세함수**의 정확한 개념과 최적화 기법을 잡고, **진리표**를 바탕으로 조합논리를 설계한 뒤, **2진 덧셈기/뺄셈기**를 하프·풀·병렬 가산기까지 체계적으로 정리합니다. 생략 없음.

---

## 1) 비완전 명세함수(Incompletely Specified Function)

### 1.1 정의(집합 관점)
- 입력 변수 \(n\)개에 대한 전체 공간 \(\mathcal{U}=\{0,1\}^n\).
- **비완전 명세함수** \(F\)는 \(\mathcal{U}\)의 **일부 조합**에만 값이 지정된 함수:
  - **ON-set** \(\mathcal{ON}\): 출력이 1로 **지정**된 조합 집합
  - **OFF-set** \(\mathcal{OFF}\): 출력이 0으로 **지정**된 조합 집합
  - **Don’t-care set** \(\mathcal{DC}\): **미지정** 조합 집합  
  \[
  \mathcal{U}=\mathcal{ON}\;\dot{\cup}\;\mathcal{OFF}\;\dot{\cup}\;\mathcal{DC},\quad \dot{\cup}\;:\text{서로소 합집합}
  \]
- 구현 시에는 \(\mathcal{DC}\)의 원소를 0 또는 1로 **임의 할당**하여(확장 \(F'\)) **게이트 수/깊이 최소**를 달성.

### 1.2 실무 의의
- **코드 변환기, 디코더, 표시기** 등에서 “사용되지 않는 코드”가 많음 → \(\mathcal{DC}\)로 둬 **K-map 묶음**을 키워 최소회로.
- 순차회로의 사용되지 않는 **미정의 상태**도 조합 논리 레벨에서는 \(\mathcal{DC}\)로 취급하여 단순화 가능(단, 리셋·리커버리 경로는 별도 설계).

### 1.3 주의(안전성)
- \(\mathcal{DC}\)를 1로 활용해 묶음을 키우더라도, 시스템 차원에서 그 입력 조합이 **절대 발생하지 않음**이 보장되어야 함.
- **비동기** 환경이나 **CDC** 경계에서는 \(\mathcal{DC}\) 사용이 해저드(글리치)를 유발할 수 있으므로, 필요 시 **합의항(consensus)** 추가로 완화.

---

## 2) 진리표 작성 예(비완전 명세 포함)

### 2.1 예제 A — 3입력 함수(DC로 한 번에 단순화)
> 조건: \(F=1\)인 케이스가 \(m(1), m(3), m(5)\) 뿐이고, \(m(7)\)은 **미사용 코드**(\(X\)). 나머지는 0.

- 변수 순서 \((A,B,C)\)를 \((4,2,1)\) 가중치(MSB→LSB)로 한다.

```
A B C | F
--------------
0 0 0 | 0   (m0)
0 0 1 | 1   (m1)
0 1 0 | 0   (m2)
0 1 1 | 1   (m3)
1 0 0 | 0   (m4)
1 0 1 | 1   (m5)
1 1 0 | 0   (m6)
1 1 1 | X   (m7, don't care)
```

- **K-map(3변수, C가 열, AB가 행; X는 don’t care)**

```
      C
      0   1
AB 00 0 | 1
   01 0 | 1
   11 0 | X
   10 0 | 1
```

- **묶기:** C=1 **세 개의 1**과 **X(=1로 간주)**를 묶어 **사이즈 4** 그룹 가능 →  
  \[
  \boxed{F = C}
  \]
- 해설: \(\mathcal{DC}\) 덕분에 \(\overline{A}\overline{B}C + \overline{A}BC + A\overline{B}C\) 가 한 번에 \(C\)로 축약.

---

### 2.2 예제 B — BCD(4비트)에서 “값이 5 이상이면 1” (10~15는 DC)

- 변수 \((A,B,C,D)\)의 가중치는 \(8,4,2,1\) (A=MSB).
- **케어**: 0~9, **DC**: 10~15.  
  **F=1**: 5,6,7,8,9.

```
A B C D | F
----------------
0 1 0 1 | 1   (5)
0 1 1 0 | 1   (6)
0 1 1 1 | 1   (7)
1 0 0 0 | 1   (8)
1 0 0 1 | 1   (9)
(10~15) | X
 나머지 | 0
```

- 직관적 단순화:
  - \(A=1\)이면(8,9,또는 X) **항상** 1 → **그룹 전체를 A로 흡수**.
  - \(A=0,B=1\) 영역(4~7)에서 \(F=1\)은 **5~7**이므로 **\(C+D\)** 가 1일 때.  
  \[
  \boxed{F = A + B(C + D)}
  \]
- K-map에서 DC(10~15)를 포함하면 \(A\) 영역을 통째로 묶을 수 있어 가장 짧아짐.

---

## 3) 최소항·최대항 전개(정규형)

- **SOP(곱의 합)**:  
  \[
  F=\sum m(I)\quad\text{(출력이 1인 인덱스 집합 \(I\))}
  \]
- **POS(합의 곱)**:  
  \[
  F=\prod M(J)\quad\text{(출력이 0인 인덱스 집합 \(J\))}
  \]
- **보수와 여집합**:  
  \[
  \overline{F}=\prod M(\mathcal{U}\setminus I),\qquad
  \overline{F}=\sum m(\mathcal{U}\setminus J)
  \]
- 비완전 명세일 때는 \(\mathcal{DC}\)를 **임의로** \(I\) 또는 \(J\)에 합쳐 **최소 회로**가 되는 방향으로 전개.

---

## 4) 2진수 덧셈기 설계

### 4.1 하프 가산기(Half Adder)
- 입력: \(A,B\). 출력: 합 \(S\), 캐리 \(C\).
\[
S=A\oplus B,\qquad C=AB
\]
```
A B | S C
---------
0 0 | 0 0
0 1 | 1 0
1 0 | 1 0
1 1 | 0 1
```

### 4.2 풀 가산기(Full Adder)
- 입력: \(A,B,C_{in}\). 출력: \(S,C_{out}\).
\[
S = A\oplus B\oplus C_{in}
\]
\[
C_{out} = AB + (A\oplus B)C_{in}
\]
- **전파/생성(propagate/generate)** 표기:
\[
P=A\oplus B,\quad G=AB \Rightarrow C_{out}=G+PC_{in}
\]

### 4.3 리플 캐리 가산기(RCA, n비트)
- **구성:** 풀 가산기 \(n\)개 직렬 연결(각 자리의 \(C_{out}\)이 다음 자리의 \(C_{in}\)).
- **지연:** \(t_{RCA}\approx n\cdot t_{\text{FA,carry}}\) (선형 증가).  
  → 간단하지만 **긴 비트수에서 느림**.

### 4.4 캐리 룩어헤드(CLA, 4비트 블록)
- **정의(OR-propagate 버전)**:
\[
P_i = A_i + B_i,\quad G_i = A_i B_i
\]
\[
\begin{aligned}
C_1 &= G_0 + P_0 C_0\\
C_2 &= G_1 + P_1 G_0 + P_1 P_0 C_0\\
C_3 &= G_2 + P_2 G_1 + P_2 P_1 G_0 + P_2 P_1 P_0 C_0\\
C_4 &= G_3 + P_3 G_2 + P_3 P_2 G_1 + P_3 P_2 P_1 G_0 + P_3 P_2 P_1 P_0 C_0
\end{aligned}
\]
- **합비트**: \(S_i = A_i \oplus B_i \oplus C_i\) (여기서 \(C_i\)는 해당 자리의 캐리-인).  
- **특징:** 캐리를 **병렬 계산** → 지연이 로그·상수 수준으로 크게 감소(블록 크기 의존).  
  (파생형: Carry-Skip, Carry-Select, Prefix(Kogge–Stone, Brent–Kung) 등.)

### 4.5 상태 플래그(덧셈)
- **Carry** \(C_n\): 부호 **없는** 연산에서 범위 초과(상위 자리 캐리).
- **Overflow** \(V\): 2의 보수(부호 **있는**) 연산에서
\[
V = C_{n-1} \oplus C_n
\]
또는
\[
V = (A_{n-1}\cdot B_{n-1}\cdot \overline{S_{n-1}}) + (\overline{A_{n-1}}\cdot \overline{B_{n-1}}\cdot S_{n-1})
\]
- **Sign** \(N=S_{n-1}\), **Zero** \(Z=(S=0)\).

---

## 5) 2진수 뺄셈기 설계

### 5.1 하프/풀 서브트랙터(개념형)
- **Half Subtractor** (\(A-B\), 입력 \(A,B\))
\[
D = A\oplus B,\qquad Borrow = \overline{A}\,B
\]
- **Full Subtractor** (\(A-B-B_{in}\))
\[
D = A\oplus B\oplus B_{in}
\]
\[
B_{out} = \overline{A}(B + B_{in}) + B\,B_{in}
\]
> 그러나 실무에서는 **2의 보수 덧셈**으로 뺄셈을 구현하는 것이 표준.

### 5.2 가산기로 뺄셈 구현(Adder–Subtractor)
- **핵심 아이디어:** \(A-B = A + (\overline{B}) + 1\) (2의 보수).
- **모드 비트 \(M\)**: \(M=0\) → 덧셈, \(M=1\) → 뺄셈.  
  \[
  B'_i = B_i \oplus M,\qquad C_{in}=M
  \]
  → 회로적으로 **XOR 한 줄 + 초기 캐리=1**만 추가하면 **가감 동시 지원**.
- **Borrow 판정(부호 없는)**: 위 방식에서는  
  \[
  \text{Borrow} = \overline{C_{out}}
  \]
  (즉 \(A\ge B\)이면 최종 캐리 \(C_{out}=1\), 아니면 0)
- **Overflow(부호 있는)**: 덧셈과 동일하게 \(V=C_{n-1}\oplus C_n\).

### 5.3 예제(8비트, 부호 있는/없는)
- **부호 없는**: \(A=0011\,0100(52),\;B=0011\,1001(57)\).  
  \(A-B = A + \overline{B} + 1\) → 최종 \(C_{out}=0\Rightarrow\) Borrow=1(음수).  
- **부호 있는(2의 보수)**: \(0110\,0100(+100) + 0100\,1111(+79)\) →  
  \(C_{6}\oplus C_{7}=1\) → **오버플로 발생**(정수 범위 초과).

---

## 6) 덧셈기/뺄셈기 설계 디테일(구현·지연·안전)

1. **게이트 비용 지표**: 리터럴 수(PLA), 2입력 게이트 등가 수, **경로 지연**(critical path).  
2. **RCA**는 단순·작은 면적, **CLA**는 빠름(복잡도↑). 실제 FPGA는 **캐리 체인**이 내장되어 RCA도 매우 빠름.  
3. **해저드 완화**: 조합경로가 많은 대형 CLA/셀렉트 구조에서는 합의항 추가, 혹은 **클록 동기화**(등록기 삽입, 파이프라인)로 안정화.  
4. **서명(부호) 확장**: 뺄셈·부호 있는 연산에서는 **MSB 복제**(sign extension)가 필수.

---

## 7) 종합 예제(설계 전 과정)

**문제**  
4비트 입력 \(A,B,C,D\)(BCD)에서 “값이 **9 이상**이면 \(F=1\)” 출력. 10~15는 미사용.

1) **진리표**  
- \(F=1\): 9만(요구), DC: 10~15, 나머지 0.

```
A B C D | F
----------------
1 0 0 1 | 1   (9)
1 * * * | X   (10~15, don't care)
기타    | 0
```

2) **전개/단순화**  
- \(A=1\) 영역(8~15)을 DC로 통째로 묶으면, **9만 1이어야** 하므로 그대로 묶기는 불가.  
- BCD 특성상 “9 이상”은 사실상 “1001=9” 한 점. DC를 써도 큰 묶음 불가.  
- **정규형**: \(F=\sum m(9)\) 또는 **POS**로 \(F=\prod M(\mathcal{U}\setminus\{9\})\).  
- **최소 구현**: 디코더식(“정확히 \(A=1,B=0,C=0,D=1\)”)  
  \[
  \boxed{F = A\;\overline{B}\;\overline{C}\;D}
  \]
> 포인트: DC가 **언제나** 묶음을 키우는 건 아님 — 스펙상 9만 케어이면 단일 미니텀 그대로가 최소.

---

## 8) 연습문제 (풀세트)

1) **비완전 명세 최적화**  
   3변수 \(F\): \(F=1\) at \(m(0,2,3)\), \(X\) at \(m(6,7)\), 나머지 0.  
   - (a) SOP 정규형을 쓰고,  
   - (b) K-map으로 최소화. (힌트: \(X\)를 잘 쓰면 2개 그룹으로 끝남)

2) **서술→진리표**  
   “문(D) 또는 창문(W)이 열려 있고 **경비 해제(H=0)가 아닐 때만** 경보.”  
   - (a) 부울식  
   - (b) 3변수 진리표  
   - (c) don’t care가 있다면(예: 테스트 모드 T=1에서 출력 무시), K-map에서 어떻게 활용하는가.

3) **RCA 지연**  
   n비트 RCA에서 풀 가산기 캐리전파 지연을 \(t_{FA,c}\), 합비트 지연을 \(t_{FA,s}\)라 할 때,  
   - (a) 전체 지연 상한을 \(t_{RCA}\)로 써라.  
   - (b) CLA(4비트 블록, 블록 간 리플)의 지연 모델을 간략히 비교하라.

4) **Adder–Subtractor 설계**  
   모드 \(M\)으로 가감 연산을 제어하는 8비트 회로에서  
   - (a) \(B'\)와 \(C_{in}\)을 \(M\)으로 표현하라.  
   - (b) 부호 없는 비교 \(A\ge B\)를 한 사이클에 판단하는 방법을 써라(힌트: 최종 \(C_{out}\)).  
   - (c) 부호 있는 오버플로 \(V\)의 공식을 쓰고, \(A=0111\,1111, B=0000\,0001\)에서 \(V\)를 판단하라.

5) **서브트랙터 논리식**  
   Full Subtractor의 \(B_{out}\) 식 \(\overline{A}(B+B_{in}) + B B_{in}\)을 진리표로 검증하라.

> 해설이 필요하면 K-map 그림까지 포함해 이어서 제공합니다.

---

## 9) 핵심 정리(포켓 요약)

- **비완전 명세**: \(\mathcal{DC}\)를 0/1로 자유 할당해 **묶음 최대화 → 회로 최소화**.  
- **K-map**: 1과 X를 함께 묶되, 스펙상 **발생 불가** 조합만 X로 지정.  
- **Adder**: \(S=A\oplus B\oplus C_{in}\), \(C_{out}=AB+(A\oplus B)C_{in}\).  
- **CLA**: \(C_k=\sum G_i\prod P_j + \prod P_i C_0\) (인덱스 체인).  
- **Subtractor(2’s comp)**: \(B' = B\oplus M,\;C_{in}=M\). Borrow\(=\overline{C_{out}}\).  
- **Overflow**(2’s comp): \(V=C_{n-1}\oplus C_n\).