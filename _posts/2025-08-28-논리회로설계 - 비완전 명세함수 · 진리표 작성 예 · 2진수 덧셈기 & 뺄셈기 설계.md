---
layout: post
title: 논리회로설계 - 비완전 명세함수 · 진리표 작성 예 · 2진수 덧셈기 & 뺄셈기 설계
date: 2025-08-28 20:25:23 +0900
category: 논리회로설계
---
# 비완전 명세함수 · 진리표 작성 예 · 2진수 덧셈기 & 뺄셈기 설계 (개정판 2025)

## 개요·표기·목표

- 표기: $$+\!=\text{OR},\ \cdot\!=\text{AND}\ (\text{또는 생략}),\ \overline{A}\!=\text{NOT }A,\ \oplus\!=\text{XOR}$$
- 목표:
  1) **비완전 명세함수(Incompletely Specified Function)**의 집합·대수 관점 정리
  2) **진리표**와 **don’t care**를 이용한 체계적 최소화(K-맵/대수)
  3) **2진 가산기/감산기**를 하프·풀·RCA·CLA(및 변종)까지 설계, 플래그와 타이밍까지 총정리
  4) 예제·코드·검증 스니펫 포함 (생략 없음)

---

## 비완전 명세함수(Incompletely Specified Function)

### 정의(집합·대수 관점)

- 입력공간: \(\mathcal{U}=\{0,1\}^n\)
- 비완전 명세함수 \(F\)는 \(\mathcal{U}\)의 일부 조합에만 값이 지정:
  - **ON-set** \(\mathcal{ON}\): 반드시 \(1\)이어야 하는 조합
  - **OFF-set** \(\mathcal{OFF}\): 반드시 \(0\)이어야 하는 조합
  - **Don’t-care set** \(\mathcal{DC}\): 미지정(무관) 조합
  $$
  \mathcal{U}=\mathcal{ON}\ \dot{\cup}\ \mathcal{OFF}\ \dot{\cup}\ \mathcal{DC},\quad \dot{\cup}: \text{서로소 합집합}
  $$
- 구현 시 **확장 함수** \(F'\)를 선택:
  $$
  F':\mathcal{U}\to\{0,1\},\quad F'|_{\mathcal{ON}}=1,\ F'|_{\mathcal{OFF}}=0,\ F'|_{\mathcal{DC}}\in\{0,1\}\ \text{임의}
  $$
  → \(\mathcal{DC}\)를 0/1로 마음대로 배정해 **게이트 수·깊이 최소**.

### 설계 지침(안전·최적화)

- **안전성**: \(\mathcal{DC}\)는 시스템 전체에서 **절대 발생하지 않음이 보장**될 때만 활용.
- **최적화**: K-맵에서 1과 \(X\)를 함께 묶어 **큰 블록**을 만들수록 리터럴 수↓.
- **해저드 주의**: 비동기/CDC 경계에서는 글리치 위험. 필요 시 **합의항(consensus)** 추가:
  $$
  AB+\overline{A}C\ \xrightarrow{+\ BC}\ AB+\overline{A}C+BC
  $$

---

## 진리표 작성 예(비완전 명세 포함)

### 예제 A — 3입력, DC 활용으로 한 번에 축약

- 조건: \(F=1\) at \(m(1),m(3),m(5)\); \(m(7)\)은 미사용코드 \(X\); 나머지 \(0\)
- 변수 순서 \((A,B,C)\) = (MSB, …, LSB) = (4,2,1)

```
A B C | F
--------------
0 0 0 | 0  (m0)
0 0 1 | 1  (m1)
0 1 0 | 0  (m2)
0 1 1 | 1  (m3)
1 0 0 | 0  (m4)
1 0 1 | 1  (m5)
1 1 0 | 0  (m6)
1 1 1 | X  (m7)
```

- 3변수 K-맵(열=C, 행=AB 그레이순서):

```
      C
      0   1
AB 00 0 | 1
   01 0 | 1
   11 0 | X
   10 0 | 1
```

- 묶기: C=1 열의 (1,3,5) + \(X\)(7)을 4블록으로 →
  **결과** \( \boxed{F=C} \)
  (원래 SOP \(\overline{A}\overline{B}C+\overline{A}BC+A\overline{B}C\)가 한 번에 축약)

---

### 예제 B — BCD 4비트에서 “값이 5 이상이면 1”(10~15는 DC)

- \((A,B,C,D)=(8,4,2,1)\), 케어: 0~9, DC: 10~15
- \(F=1\) at \(\{5,6,7,8,9\}\)

```
A B C D | F
----------------
0 1 0 1 | 1   (5)
0 1 1 0 | 1   (6)
0 1 1 1 | 1   (7)
1 0 0 0 | 1   (8)
1 0 0 1 | 1   (9)
10~15   | X
기타    | 0
```

- 단순화:
  (i) \(A=1\) 블록(8~15)은 DC 포함으로 통째 그룹 → \(A\)
  (ii) \(A=0,B=1\) 영역(4~7) 중 5~7이 1 → \(C+D\)
  **결론** \( \boxed{F = A + B(C+D)} \)

---

## 정규형(SOP/POS)·보수·DC 반영

### 정규형

- **SOP**:
  $$
  F=\sum m(I)\quad(I:\ \text{출력=1 인덱스})
  $$
- **POS**:
  $$
  F=\prod M(J)\quad(J:\ \text{출력=0 인덱스})
  $$

### 보수와 여집합

- \(\overline{F}=\prod M(\mathcal{U}\setminus I)\), 또는 \(\overline{F}=\sum m(\mathcal{U}\setminus J)\)
- 비완전 명세일 때는 \(I\) 또는 \(J\)에 \(\mathcal{DC}\)를 **임의 포함**하여 최소화가 쉬운 형태 선택

---

## 2진수 덧셈기 — 하프/풀/블록/플래그

### 하프 가산기(Half Adder)

- 진리:
  $$
  S=A\oplus B,\quad C=AB
  $$
```
A B | S C
---------
0 0 | 0 0
0 1 | 1 0
1 0 | 1 0
1 1 | 0 1
```

### 풀 가산기(Full Adder)

- 합:
  $$
  S = A\oplus B\oplus C_{in}
  $$
- 캐리(Propagate/Generate 표기):
  $$
  P=A\oplus B,\quad G=AB
  $$
  $$
  C_{out} = G + P\,C_{in}
  $$

#### (Verilog) 하프/풀 가산기

```verilog
module half_adder(input A,B, output S,C);
  assign S = A ^ B;
  assign C = A & B;
endmodule

module full_adder(input A,B,Cin, output S,Cout);
  wire P = A ^ B;
  wire G = A & B;
  assign S    = P ^ Cin;
  assign Cout = G | (P & Cin);
endmodule
```

### 리플 캐리 가산기(RCA, n비트)

- 풀 가산기 n개 직렬 연결 → 단순, 면적↓, **지연 \( \approx n\cdot t_{\text{carry}} \)**
```verilog
module rca #(parameter N=8)
 (input  [N-1:0] A,B,
  input          Cin,
  output [N-1:0] S,
  output         Cout);
  wire [N:0] C; assign C[0]=Cin; assign Cout=C[N];
  genvar i;
  generate for(i=0;i<N;i=i+1) begin: FA
    full_adder fa(.A(A[i]),.B(B[i]),.Cin(C[i]),.S(S[i]),.Cout(C[i+1]));
  end endgenerate
endmodule
```
> **FPGA 메모**: 현대 FPGA는 전용 **캐리체인**을 제공해 `+` 연산이 매우 빠르게 합성됨. 하드 코딩한 CLA보다 일반적으로 `assign {Cout,S}=A+B+Cin;`이 더 좋을 때가 많음.

### 캐리 룩어헤드(CLA, 4비트)

- 비트 단위:
  $$
  P_i=A_i + B_i,\quad G_i=A_iB_i
  $$
  $$
  \begin{aligned}
  C_1 &= G_0 + P_0 C_0\\
  C_2 &= G_1 + P_1 G_0 + P_1P_0 C_0\\
  C_3 &= G_2 + P_2 G_1 + P_2P_1 G_0 + P_2P_1P_0 C_0\\
  C_4 &= G_3 + P_3 G_2 + P_3P_2 G_1 + P_3P_2P_1 G_0 + P_3P_2P_1P_0 C_0
  \end{aligned}
  $$
- 합:
  $$
  S_i = A_i \oplus B_i \oplus C_i
  $$
```verilog
module cla4(input [3:0] A,B, input Cin,
            output [3:0] S, output Cout);
  wire [3:0] P = A | B; // OR-propagate
  wire [3:0] G = A & B;
  wire C1 = G[0] | (P[0] & Cin);
  wire C2 = G[1] | (P[1] & G[0]) | (P[1]&P[0]&Cin);
  wire C3 = G[2] | (P[2] & G[1]) | (P[2]&P[1]&G[0]) | (P[2]&P[1]&P[0]&Cin);
  wire C4 = G[3] | (P[3] & G[2]) | (P[3]&P[2]&G[1])
                  | (P[3]&P[2]&P[1]&G[0])
                  | (P[3]&P[2]&P[1]&P[0]&Cin);
  assign S    = (A ^ B) ^ {C3,C2,C1,Cin};
  assign Cout = C4;
endmodule
```
> 변종: Carry-Skip, Carry-Select, Prefix(Kogge–Stone/Brent–Kung 등) — 캐리 트리로 **깊이 \(O(\log n)\)**.

### 플래그

- **Carry \(C_n\)**: 부호 **없는** 덧셈 범위 초과
- **Overflow \(V\)**(2의 보수, 부호 **있는**):
  $$
  V = C_{n-1} \oplus C_n
  $$
  또는
  $$
  V = A_{n-1}B_{n-1}\overline{S_{n-1}} + \overline{A_{n-1}}\overline{B_{n-1}}S_{n-1}
  $$
- **Sign \(N\)**: \(S_{n-1}\), **Zero \(Z\)**: 모든 합비트 0

---

## 2진수 뺄셈기 — 서브트랙터 vs 2의 보수 방식

### Half/Full Subtractor(개념)

- Half Subtractor (\(A-B\)):
  $$
  D=A\oplus B,\quad Borrow=\overline{A}\,B
  $$
- Full Subtractor (\(A-B-B_{in}\)):
  $$
  D=A\oplus B\oplus B_{in}
  $$
  $$
  B_{out} = \overline{A}(B + B_{in}) + BB_{in}
  $$

### 표준: 가산기로 뺄셈(Adder–Subtractor)

- 핵심:
  $$
  A-B = A + \overline{B} + 1
  $$
- 모드 \(M\) (0:덧셈, 1:뺄셈):
  $$
  B'_i = B_i \oplus M,\quad C_{in}=M
  $$
```verilog
module add_sub #(parameter N=8)
 (input  [N-1:0] A,B,
  input          M,         // 0: A+B, 1: A-B
  output [N-1:0] S,
  output         Cout, V);
  wire [N-1:0] Bx = B ^ {N{M}};
  wire Cin = M;
  wire [N:0] C; assign C[0]=Cin; assign Cout=C[N];
  genvar i; generate for(i=0;i<N;i=i+1) begin: FA
    full_adder fa(.A(A[i]),.B(Bx[i]),.Cin(C[i]),.S(S[i]),.Cout(C[i+1]));
  end endgenerate
  // 2's complement overflow
  assign V = C[N-1] ^ C[N];
endmodule
```
- **Borrow(부호 없는)**: \(Borrow=\overline{Cout}\)
- **Overflow(부호 있는)**: \(V=C_{n-1}\oplus C_n\) (덧셈과 동일)

### 예시

- 부호 없는: \(A=52(00110100), B=57(00111001)\) → 최종 \(Cout=0 \Rightarrow Borrow=1\)
- 부호 있는: \(01100100(+100) + 01001111(+79)\) → \(C_{6}\oplus C_7=1\) → 오버플로

---

## 고급 설계 포인트(지연·구현·안정성)

1) **지연 모델(상한)**
   - RCA: $$t_{\text{RCA}} \approx n\cdot t_{\text{FA,carry}} + t_{\text{XOR}}$$
   - CLA(4비트 블록, 블록 간 리플):
     $$t \approx t_{PG} + t_{CLA\_logic} + \left\lceil \frac{n}{4}\right\rceil t_{\text{block-carry}} + t_{\oplus}$$
2) **구현 선택**
   - ASIC: 데이터패스 폭·전력·배선에 따라 **CLA/Prefix** 채용
   - FPGA: 전용 **캐리 체인** 덕에 **RCA(+연산자)**가 대개 최선
3) **해저드**
   - 넓은 조합경로는 정적 해저드 가능 → 합의항 추가 또는 **레지스터 삽입(파이프라인)**
4) **부호 확장**
   - 부호 있는 연산에서 상위 확장 시 **MSB 반복**(sign extension) 필수:
     $$x_{ext} = \underbrace{x_{n-1}\cdots x_{n-1}}_{k\ \text{비트}}\,x_{n-1}\cdots x_0$$

---

## 종합 설계 예(끝까지)

**문제** BCD 입력 \((A,B,C,D)\)에서 “값이 **9 이상**이면 \(F=1\)”. 10~15는 DC.

1) **진리표(요지)**
   - \(F=1\) at 9만 (또는 9~15를 허용하려 한 의도가 아니라면 “이상”은 9 **단독**일 수 있음)
   - DC: 10~15

```
A B C D | F
----------------
1 0 0 1 | 1   (9)
1 * * * | X   (10~15)
기타    | 0
```

2) **전개·결론**
   - DC를 활용해도 9만 1이어야 하므로 큰 묶음 불가
   - **최소 구현**:
     $$
     \boxed{F = A\,\overline{B}\,\overline{C}\,D}
     $$

---

## 실전 검증 스니펫(파이썬) — 진리표/SOP/POS/등가성

{% raw %}
```python
from itertools import product

def truth_table(vars_, f):
    rows=[]
    for bits in product([0,1], repeat=len(vars_)):
        rows.append((*bits, int(bool(f(bits)))))
    return rows

def minterm(vars_, bits):
    return ''.join(v if b else f'\\overline{{{v}}}' for v,b in zip(vars_, bits))

def maxterm(vars_, bits):
    return '(' + ' + '.join((v if b==0 else f'\\overline{{{v}}}') for v,b in zip(vars_, bits)) + ')'

def to_sop_pos(vars_, f):
    alls=list(product([0,1], repeat=len(vars_)))
    sop=' + '.join(minterm(vars_, b) for b in alls if f(b)==1) or '0'
    pos=' '.join(maxterm(vars_, b) for b in alls if f(b)==0) or '1'
    return sop, pos

def equiv(vars_, f, g):
    for b in product([0,1], repeat=len(vars_)):
        if f(b)!=g(b):
            return False, dict(zip(vars_, b))
    return True, None

# 예: F = A + B(C + D) 검증

def F(b): A,B,C,D=b; return int(A or (B and (C or D)))
def G(b): A,B,C,D=b; return int((A==1) or (B==1 and (C==1 or D==1)))
vars_=['A','B','C','D']
print("SOP/POS:", to_sop_pos(vars_, F))
print("equiv:", equiv(vars_, F, G))
```
{% endraw %}

> 설계 초안을 SOP/POS로 찍어두고, 대수 최소화 결과와 `equiv`로 **동치 검증**하는 습관을 권장.

---

## 연습문제(해설용 힌트 포함)

1) **비완전 명세 최적화**
   \(F=1\) at \(m(0,2,3)\), \(X\) at \(m(6,7)\), others 0.
   - (a) SOP 정규형을 쓰고,
   - (b) K-맵에서 \(X\) 포함 4블록+2블록 묶음으로 최소화 결과 도출.

2) **서술→진리표**
   “문(D) 또는 창문(W)이 열려 있고 **경비 해제(H=0)가 아닐 때만** 경보.”
   - (a) \(Alarm=(D+W)\overline{H}\)
   - (b) 3변수 진리표 작성
   - (c) 테스트 모드 \(T=1\)에서 출력 무시이면 \(T\)를 DC로 넣어 K-맵 묶음 확대.

3) **RCA 지연**
   - (a) \(t_{\text{RCA}}\!\approx\!n\cdot t_{\text{FA,carry}} + t_{\oplus}\)
   - (b) CLA(4비트 블록, 블록 리플): \(t\!\approx\!t_{PG}+t_{CLA}+ \lceil n/4\rceil t_{block} + t_{\oplus}\)

4) **Adder–Subtractor**
   - (a) \(B' = B \oplus M,\ C_{in}=M\)
   - (b) 부호 없는 비교: \(Cout=1 \Leftrightarrow A\ge B\)
   - (c) \(V=C_{n-1}\oplus C_n\). 예) \(A=0111\,1111\), \(B=0000\,0001\): \(+127+1\rightarrow 1000\,0000\) → \(V=1\)

5) **Full Subtractor**
   - \(B_{out}=\overline{A}(B+B_{in}) + BB_{in}\)을 진리표로 검증(8행 모두 일치 확인).

---

## 요약 카드

- **비완전 명세**: \(\mathcal{DC}\)를 0/1로 할당해 **묶음 최댓화→회로 최소화**
- **정규형**: \(F=\sum m(I)\), \(F=\prod M(J)\), 보수는 **여집합**
- **Adder**: \(S=A\oplus B\oplus C_{in}\), \(C_{out}=AB+(A\oplus B)C_{in}\)
- **CLA**: \(C_k=\sum G_i\prod P_j + \prod P_i C_0\) (블록/프리픽스로 깊이 단축)
- **Subtractor(2’s comp)**: \(B'=B\oplus M,\, C_{in}=M,\ Borrow=\overline{Cout}\)
- **Overflow(2’s comp)**: \(V=C_{n-1}\oplus C_n\)
- **현대 FPGA**: 전용 **캐리체인**으로 `+` 합성이 최고 성능인 경우가 많음
