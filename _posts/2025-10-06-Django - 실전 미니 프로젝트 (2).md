---
layout: post
title: Django - 실전 미니 프로젝트 (2)
date: 2025-10-06 22:25:23 +0900
category: Django
---
# 12. 실전 미니 프로젝트 (2) — 쇼핑몰  
> **목표**: Django 5.x로 **장바구니 → 주문 → 결제 → 웹훅** 전 과정을 구현하고, **재고 일관성**(오버셀 방지 / 예약-확정 / 타임아웃 보상)까지 다룹니다.  
> - 스택: Django 5.x, PostgreSQL, Redis(선택: 캐시/락), Celery(선택: 만료/백오피스 잡)  
> - 기능: 상품/재고, 장바구니, 주문 생성, 결제 연동(예: Stripe/Iamport 인터페이스), **Idempotency** 웹훅 처리, **select_for_update/F** 로 재고 일관성, **예약 만료**(Saga 보상)  
> - 모든 코드는 ``` 로 감싸며, 수학식은 없습니다.

---

## A. 도메인과 흐름

### A-1. 유스케이스 흐름(간단)
1) 사용자가 **카트 담기**  
2) 카트 확인 → **주문 생성** (재고 **예약** & 금액 스냅샷)  
3) 결제 페이지로 이동 → 외부 결제  
4) **웹훅**으로 결제 성공 알림 → 주문 **확정/재고 차감 확정**  
5) 실패/취소/타임아웃 → **예약 취소**(재고 해제)

### A-2. 재고 일관성 전략
- 주문 생성 시 **비관 락**으로 해당 SKU들을 잠그고, `StockReservation` 을 기록 (**임시 예약 수량**).  
- 결제 성공 후 **예약을 소비**하여 실제 재고(`on_hand`)를 차감.  
- 실패/타임아웃 시 예약 취소(해제).  
- 동시성: `select_for_update(nowait=False, skip_locked=True)` + `F()` 표현식.  
- 읽기 모델로 `available = on_hand - reserved`를 사용.

---

## B. 모델

```python
# apps/shop/models.py
from django.db import models
from django.conf import settings
from django.utils import timezone

class Product(models.Model):
    name = models.CharField(max_length=180)
    price = models.PositiveIntegerField()  # KRW 정수
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)

class SKU(models.Model):
    """옵션 단위 재고 관리 (필요시 단일 SKU로 사용)"""
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name="skus")
    code = models.CharField(max_length=40, unique=True)
    on_hand = models.PositiveIntegerField(default=0)       # 보유 재고
    reserved = models.PositiveIntegerField(default=0)      # 예약(미확정)
    is_active = models.BooleanField(default=True)

    class Meta:
        indexes = [models.Index(fields=["product","is_active"])]

    @property
    def available(self) -> int:
        return max(0, self.on_hand - self.reserved)

class Cart(models.Model):
    """로그인 전도 허용하려면 session_key 보관 가능. 여기선 로그인 사용자 기준."""
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="carts")
    created_at = models.DateTimeField(auto_now_add=True)
    checked_out_at = models.DateTimeField(null=True, blank=True)

class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE, related_name="items")
    sku = models.ForeignKey(SKU, on_delete=models.PROTECT, related_name="cart_items")
    qty = models.PositiveIntegerField()
    added_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = [("cart","sku")]

class Order(models.Model):
    class Status(models.TextChoices):
        CREATED="CREATED","생성"
        PENDING="PENDING","결제대기"   # 외부 결제 진행 중
        PAID="PAID","결제완료"
        CANCELLED="CANCELLED","취소"
        FAILED="FAILED","실패"

    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.PROTECT, related_name="orders")
    status = models.CharField(max_length=12, choices=Status.choices, default=Status.CREATED)
    amount = models.PositiveIntegerField(default=0)
    currency = models.CharField(max_length=3, default="KRW")
    external_payment_id = models.CharField(max_length=80, blank=True)  # PG transaction id
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    expires_at = models.DateTimeField(null=True, blank=True)           # 결제 만료

class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="items")
    sku = models.ForeignKey(SKU, on_delete=models.PROTECT)
    product_name = models.CharField(max_length=180)
    sku_code = models.CharField(max_length=40)
    unit_price = models.PositiveIntegerField()  # 스냅샷
    qty = models.PositiveIntegerField()

class StockReservation(models.Model):
    """주문 생성 시 SKU별 예약 수량 기록"""
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="reservations")
    sku = models.ForeignKey(SKU, on_delete=models.CASCADE, related_name="reservations")
    qty = models.PositiveIntegerField()
    created_at = models.DateTimeField(auto_now_add=True)
    released = models.BooleanField(default=False)  # 해제됨(보상), 또는 소비됨(차감 확정)

class PaymentLog(models.Model):
    """웹훅/콜백 수신 로그(Idempotency Key 포함)"""
    provider = models.CharField(max_length=20)      # stripe/iamport 등
    event_id = models.CharField(max_length=120, db_index=True)     # 웹훅 이벤트 고유 ID (멱등)
    order = models.ForeignKey(Order, on_delete=models.SET_NULL, null=True, blank=True)
    kind = models.CharField(max_length=40)          # payment.succeeded 등
    payload = models.JSONField()
    received_at = models.DateTimeField(auto_now_add=True)
    processed = models.BooleanField(default=False)

    class Meta:
        unique_together = [("provider","event_id")]
```

---

## C. 서비스 레이어 — 카트/주문/재고/결제

### C-1. 카트 서비스

```python
# apps/shop/services/cart.py
from django.db import transaction
from django.core.exceptions import ValidationError
from ..models import Cart, CartItem, SKU

class CartService:
    def get_or_create_cart(self, user):
        return Cart.objects.get_or_create(user=user, checked_out_at=None)[0]

    @transaction.atomic
    def add(self, user, sku_id: int, qty: int):
        if qty <= 0: raise ValidationError("수량 오류")
        cart = self.get_or_create_cart(user)
        sku = SKU.objects.select_for_update().get(pk=sku_id)  # 동시 카트 담기 보호(선택)
        if not sku.is_active: raise ValidationError("판매중지 SKU")
        # 카트는 재고를 즉시 소진하지 않지만, UX를 위해 'available'을 확인
        if qty > max(1, sku.available):  # 관대하게 1개까지 허용 등 정책 가능
            raise ValidationError("재고 부족")
        item, created = CartItem.objects.get_or_create(cart=cart, sku=sku, defaults={"qty": qty})
        if not created:
            item.qty += qty
            item.save(update_fields=["qty"])
        return item

    @transaction.atomic
    def set_qty(self, user, sku_id: int, qty: int):
        cart = self.get_or_create_cart(user)
        item = CartItem.objects.select_for_update().get(cart=cart, sku_id=sku_id)
        if qty <= 0: item.delete(); return None
        item.qty = qty; item.save(update_fields=["qty"]); return item
```

### C-2. 주문 생성(재고 예약) / 확정 / 보상

```python
# apps/shop/services/order.py
from datetime import timedelta
from django.utils import timezone
from django.db import transaction
from django.db.models import F
from django.core.exceptions import ValidationError
from ..models import Cart, CartItem, Order, OrderItem, SKU, StockReservation

RESERVE_TTL_MIN = 20  # 결제 대기 만료(분)

class OrderService:
    @transaction.atomic
    def create_from_cart(self, user) -> Order:
        cart = Cart.objects.select_for_update().get(user=user, checked_out_at=None)
        items = list(CartItem.objects.select_related("sku","sku__product").filter(cart=cart))
        if not items: raise ValidationError("카트가 비어있습니다.")

        # 주문 생성
        order = Order.objects.create(
            user=user,
            status=Order.Status.PENDING,
            expires_at=timezone.now() + timedelta(minutes=RESERVE_TTL_MIN)
        )
        amount = 0

        # SKU 잠금 + 예약 증가
        sku_ids = [i.sku_id for i in items]
        locked = list(SKU.objects.select_for_update().filter(id__in=sku_ids, is_active=True))
        locked_map = {s.id: s for s in locked}

        # 재고 확인 & 예약
        for it in items:
            sku = locked_map[it.sku_id]
            if it.qty > sku.available:
                raise ValidationError(f"재고 부족: {sku.code}")
        # 예약 반영
        for it in items:
            sku = locked_map[it.sku_id]
            SKU.objects.filter(pk=sku.id).update(reserved=F("reserved") + it.qty)

        # 아이템 스냅샷 & 예약 레코드
        for it in items:
            OrderItem.objects.create(
                order=order, sku=it.sku,
                product_name=it.sku.product.name,
                sku_code=it.sku.code,
                unit_price=it.sku.product.price,
                qty=it.qty
            )
            StockReservation.objects.create(order=order, sku=it.sku, qty=it.qty)
            amount += it.sku.product.price * it.qty

        order.amount = amount
        order.save(update_fields=["amount"])
        cart.checked_out_at = timezone.now()
        cart.save(update_fields=["checked_out_at"])
        return order

    @transaction.atomic
    def confirm_paid(self, order_id: int, external_payment_id: str):
        """웹훅에서 호출: 결제 완료 → 예약을 소비하여 on_hand 차감, reserved 감소"""
        order = Order.objects.select_for_update().get(pk=order_id)
        if order.status == Order.Status.PAID:
            return order
        if order.status not in (Order.Status.PENDING, Order.Status.CREATED):
            raise ValidationError("주문 상태가 결제대기가 아님")

        # 예약 레코드 잠금
        reservations = list(StockReservation.objects.select_for_update().filter(order=order, released=False))
        # 실제 차감
        for r in reservations:
            SKU.objects.filter(pk=r.sku_id).update(
                reserved=F("reserved") - r.qty,
                on_hand=F("on_hand") - r.qty
            )
        StockReservation.objects.filter(pk__in=[r.pk for r in reservations]).update(released=True)
        order.status = Order.Status.PAID
        order.external_payment_id = external_payment_id
        order.save(update_fields=["status","external_payment_id"])
        return order

    @transaction.atomic
    def cancel_and_release(self, order_id: int, reason: str = ""):
        order = Order.objects.select_for_update().get(pk=order_id)
        if order.status in (Order.Status.CANCELLED, Order.Status.FAILED):
            return order
        if order.status == Order.Status.PAID:
            raise ValidationError("이미 결제완료된 주문은 취소 불가(환불 별도)")
        # 예약 해제(reserved 감소만; on_hand는 그대로)
        reservations = list(StockReservation.objects.select_for_update().filter(order=order, released=False))
        for r in reservations:
            SKU.objects.filter(pk=r.sku_id).update(reserved=F("reserved") - r.qty)
        StockReservation.objects.filter(pk__in=[r.pk for r in reservations]).update(released=True)
        order.status = Order.Status.CANCELLED
        order.save(update_fields=["status"])
        return order

    @transaction.atomic
    def expire_pending_orders(self):
        """Beat 잡: 만료된 대기 주문들 보상(예약 해제)"""
        qs = Order.objects.select_for_update(skip_locked=True)\
                          .filter(status=Order.Status.PENDING, expires_at__lt=timezone.now())
        for o in qs:
            self.cancel_and_release(o.id, reason="expired")
```

---

## D. 결제 연동 (인터페이스 + 어댑터 + 리다이렉트/웹훅)

### D-1. 결제 포트(인터페이스)

```python
# apps/pay/ports.py
from typing import Protocol

class PaymentGateway(Protocol):
    def create_payment(self, order_id: int, amount: int, currency: str, user_id: int) -> dict:
        """결제 세션/결제창 URL 등 리턴"""

    def verify_webhook(self, request) -> tuple[bool, dict]:
        """서명 검증 후 (ok, payload)를 반환. 실패 시 (False, {})."""
```

### D-2. 예시 어댑터(Stripe/Iamport 유사 — 실제 API 호출 부분은 주석으로 대체)

```python
# apps/pay/adapters/mockpg.py
from .ports import PaymentGateway

class MockGateway(PaymentGateway):
    """데모/테스트용 - 실제 PG 연동 시 requests 호출/서명 검증 구현"""
    def create_payment(self, order_id: int, amount: int, currency: str, user_id: int) -> dict:
        # 실제 구현: PG에 세션 생성 → 반환 URL
        return {"redirect_url": f"/pay/mock/checkout?order_id={order_id}&amount={amount}"}

    def verify_webhook(self, request) -> tuple[bool, dict]:
        # 실제 구현: 헤더 서명 검증, raw body HMAC 등
        try:
            payload = request.json if hasattr(request, "json") else {}  # DRF Request라면 request.data
        except Exception:
            payload = {}
        # 예: {"event_id":"evt_123","type":"payment.succeeded","order_id":123,"tx_id":"tx_abc"}
        ok = "event_id" in payload and "type" in payload
        return ok, payload
```

### D-3. 체크아웃 / 리다이렉트

```python
# apps/shop/views_checkout.py
from django.contrib.auth.decorators import login_required
from django.shortcuts import redirect, render, get_object_or_404
from django.http import HttpResponseBadRequest
from django.urls import reverse
from .services.order import OrderService
from apps.pay.adapters.mockpg import MockGateway

@login_required
def checkout_start(request):
    svc = OrderService()
    try:
        order = svc.create_from_cart(request.user)
    except Exception as e:
        return HttpResponseBadRequest(str(e))
    pg = MockGateway()
    data = pg.create_payment(order.id, order.amount, order.currency, request.user.id)
    return redirect(data["redirect_url"])

@login_required
def checkout_return(request):
    """사용자 브라우저 리턴 엔드포인트 (PG에 따라 성공/취소 리디렉션)"""
    # 클라이언트 리턴은 신뢰하지 말고, 주문 상세에서 상태를 보여주기만 합니다.
    order_id = request.GET.get("order_id")
    from .models import Order
    order = get_object_or_404(Order, pk=order_id, user=request.user)
    return render(request, "shop/order_result.html", {"order": order})
```

---

## E. 웹훅 — 멱등 처리 / 보상 / 보안

```python
# apps/pay/views_webhook.py
from django.views.decorators.csrf import csrf_exempt
from django.http import HttpResponse, HttpResponseBadRequest
from django.db import transaction
from apps.pay.adapters.mockpg import MockGateway
from apps.shop.models import PaymentLog, Order
from apps.shop.services.order import OrderService

@csrf_exempt
def webhook_receiver(request):
    pg = MockGateway()
    ok, payload = pg.verify_webhook(request)
    if not ok:
        return HttpResponseBadRequest("invalid")

    provider = "mockpg"
    event_id = payload.get("event_id")
    kind = payload.get("type","")
    order_id = int(payload.get("order_id", 0))
    tx_id = payload.get("tx_id","")

    # 멱등 처리: event_id 고유성 보장
    try:
        with transaction.atomic():
            log, created = PaymentLog.objects.get_or_create(
                provider=provider, event_id=event_id,
                defaults={"order_id": order_id, "kind": kind, "payload": payload}
            )
            if not created and log.processed:
                return HttpResponse("ok")  # 이미 처리 완료

            svc = OrderService()
            if kind in ("payment.succeeded", "charge.succeeded"):
                svc.confirm_paid(order_id, external_payment_id=tx_id)
            elif kind in ("payment.failed", "charge.failed", "payment.cancelled"):
                svc.cancel_and_release(order_id, reason=kind)
            # 기타 이벤트 무시 또는 로깅

            log.processed = True
            log.save(update_fields=["processed"])
    except Order.DoesNotExist:
        # 주문 미존재 → DLQ/조사 필요. 일단 200으로 끝내면 재시도 안 올 수도.
        # PG 특성에 맞게 4xx/5xx 결정. 여기선 200 OK
        pass
    return HttpResponse("ok")
```

> **포인트**  
> - **멱등성**: `PaymentLog(provider, event_id)` **unique** 로 **중복 웹훅** 방지.  
> - **보상**: 실패/취소/만료는 `cancel_and_release()` 로 예약 해제.  
> - **보안**: 실제 PG 연동 시 **서명 검증** 필수(HMAC/공개키).  
> - **신뢰**: **웹훅(서버→서버)** 를 **진실 원천**으로 삼고, 프런트 리턴은 참고만.

---

## F. URL 라우팅

```python
# apps/shop/urls.py
from django.urls import path
from .views_cart import cart_view, cart_add, cart_setqty, cart_remove
from .views_checkout import checkout_start, checkout_return

app_name = "shop"
urlpatterns = [
    path("cart/", cart_view, name="cart"),
    path("cart/add/", cart_add, name="cart_add"),
    path("cart/setqty/", cart_setqty, name="cart_setqty"),
    path("cart/remove/", cart_remove, name="cart_remove"),
    path("checkout/start/", checkout_start, name="checkout_start"),
    path("checkout/return/", checkout_return, name="checkout_return"),
]
```

```python
# apps/pay/urls.py
from django.urls import path
from .views_webhook import webhook_receiver

app_name = "pay"
urlpatterns = [
    path("webhook/", webhook_receiver, name="webhook"),
]
```

---

## G. 카트 뷰(간단 HTMX/폼)

```python
# apps/shop/views_cart.py
from django.contrib.auth.decorators import login_required
from django.shortcuts import render
from django.http import JsonResponse
from .services.cart import CartService
from .models import CartItem, SKU

@login_required
def cart_view(request):
    svc = CartService()
    cart = svc.get_or_create_cart(request.user)
    items = CartItem.objects.select_related("sku","sku__product").filter(cart=cart)
    total = sum(i.qty * i.sku.product.price for i in items)
    return render(request, "shop/cart.html", {"items": items, "total": total})

@login_required
def cart_add(request):
    svc = CartService()
    sku_id = int(request.POST.get("sku_id"))
    qty = int(request.POST.get("qty",1))
    item = svc.add(request.user, sku_id, qty)
    return JsonResponse({"ok": True, "item_id": item.id})

@login_required
def cart_setqty(request):
    svc = CartService()
    sku_id = int(request.POST.get("sku_id"))
    qty = int(request.POST.get("qty",1))
    item = svc.set_qty(request.user, sku_id, qty)
    return JsonResponse({"ok": True, "qty": (item.qty if item else 0)})

@login_required
def cart_remove(request):
    svc = CartService()
    sku_id = int(request.POST.get("sku_id"))
    svc.set_qty(request.user, sku_id, 0)
    return JsonResponse({"ok": True})
```

템플릿 요약:

```html
{# templates/shop/cart.html #}
<h1>장바구니</h1>
<table>
  <tr><th>상품</th><th>단가</th><th>수량</th><th>소계</th></tr>
  {% for i in items %}
  <tr>
    <td>{{ i.sku.product.name }} ({{ i.sku.code }})</td>
    <td>{{ i.sku.product.price }}</td>
    <td>{{ i.qty }}</td>
    <td>{{ i.qty|mul:i.sku.product.price }}</td>
  </tr>
  {% endfor %}
  <tr><td colspan="3">합계</td><td>{{ total }}</td></tr>
</table>
<a href="{% url 'shop:checkout_start' %}">결제 진행</a>
```

> `mul` 필터는 커스텀이거나 단순 계산 표시로 대체해도 됩니다.

---

## H. 재고 일관성: 경합/오류 시나리오

### H-1. 동시 주문 경쟁
- 두 사용자가 동일 SKU를 동시에 결제 시도  
- `create_from_cart()` 단계에서 **해당 SKU들을 `select_for_update()`** 로 락 → **available** 재확인  
- 하나는 성공/예약, 다른 하나는 **ValidationError(재고 부족)**

### H-2. 결제 지연/취소
- `expires_at` 도달 시 **Beat** 로 `expire_pending_orders()` 실행 → 예약 해제  
- PG가 실패 웹훅을 2번 보내도 **멱등 처리**로 안전

### H-3. 장애/재시도
- 웹훅 처리 중 예외 → 5xx 응답 시 PG 재시도  
- 우리 쪽은 `PaymentLog` 중복 검사로 다시 처리해도 **멱등**

---

## I. 캐시/성능

- 상품 목록/상세는 **per-view** 또는 **프래그먼트 캐시**  
- 카트는 사용자 전용이므로 서버 캐시는 제한적(세션 기반)  
- 재고 수치는 빈번히 변하므로 **짧은 TTL** or **실시간 DB 읽기**  
- 인기 상품/베스트는 **야간 배치** or **주기 캐시**

---

## J. 어드민/운영

```python
# apps/shop/admin.py
from django.contrib import admin
from .models import Product, SKU, Order, OrderItem, StockReservation, PaymentLog

@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ("id","name","price","is_active","created_at")
    list_filter = ("is_active",)

@admin.register(SKU)
class SKUAdmin(admin.ModelAdmin):
    list_display = ("id","product","code","on_hand","reserved","is_active")
    list_select_related = ("product",)

class OrderItemInline(admin.TabularInline):
    model = OrderItem
    extra = 0

@admin.register(Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = ("id","user","status","amount","created_at","updated_at","external_payment_id")
    list_filter = ("status","created_at")
    inlines = [OrderItemInline]

@admin.register(StockReservation)
class StockReservationAdmin(admin.ModelAdmin):
    list_display = ("id","order","sku","qty","released","created_at")
    list_select_related = ("order","sku")

@admin.register(PaymentLog)
class PaymentLogAdmin(admin.ModelAdmin):
    list_display = ("id","provider","event_id","order","kind","processed","received_at")
    search_fields = ("event_id","kind","order__id")
```

---

## K. 테스트

```python
# apps/shop/tests/test_order_flow.py
import pytest
from django.contrib.auth import get_user_model
from django.urls import reverse
from apps.shop.models import Product, SKU, CartItem, Order, StockReservation
from apps.shop.services.order import OrderService

pytestmark = pytest.mark.django_db
User = get_user_model()

def setup_sku():
    p = Product.objects.create(name="Mug", price=10000)
    s = SKU.objects.create(product=p, code="MUG-001", on_hand=5, reserved=0)
    return p, s

def test_cart_to_order_reserve():
    u = User.objects.create_user("u","u@x.com","pw")
    _, s = setup_sku()
    # 카트 담기
    from apps.shop.services.cart import CartService
    cs = CartService()
    cs.add(u, s.id, 2)

    # 주문 생성(예약)
    osvc = OrderService()
    o = osvc.create_from_cart(u)
    assert o.status == Order.Status.PENDING
    s.refresh_from_db()
    assert s.reserved == 2 and s.on_hand == 5  # 아직 실제 차감은 아님
    assert StockReservation.objects.filter(order=o, sku=s, qty=2, released=False).exists()

def test_confirm_paid_consumes_reservation():
    u = User.objects.create_user("u","u@x.com","pw")
    _, s = setup_sku()
    from apps.shop.services.cart import CartService
    CartService().add(u, s.id, 3)
    osvc = OrderService()
    o = osvc.create_from_cart(u)
    # 결제 성공
    osvc.confirm_paid(o.id, external_payment_id="tx_1")
    s.refresh_from_db()
    assert s.on_hand == 2 and s.reserved == 0
    o.refresh_from_db()
    assert o.status == Order.Status.PAID

def test_cancel_release_on_timeout():
    u = User.objects.create_user("u","u@x.com","pw")
    _, s = setup_sku()
    from apps.shop.services.cart import CartService
    CartService().add(u, s.id, 4)
    o = OrderService().create_from_cart(u)
    OrderService().cancel_and_release(o.id, "user_cancel")
    s.refresh_from_db()
    assert s.on_hand == 5 and s.reserved == 0
```

---

## L. 확장: 쿠폰/배송/세금/환불

- **쿠폰**: 주문 전 금액 계산 시 쿠폰 엔진 적용 → `amount` 스냅샷  
- **배송**: 주소/배송방법/비용 필드 추가 + 상태 전이(READY → SHIPPED → DELIVERED)  
- **세금**: 지역/국가에 따른 세율, 라인 아이템/주문 합계에 반영  
- **환불**: `Refund` 모델 + PG 환불 API + 재고 반품 정책(재입고 or 소모)

---

## M. 재고 일관성 체크리스트

- [ ] 주문 생성 시 SKU **비관 락** + `available` 재확인  
- [ ] 예약 증가 → **만료/취소 시 해제**, 결제 성공 시 **소비(실차감)**  
- [ ] **멱등 웹훅**: `PaymentLog(provider,event_id)` uniques  
- [ ] **타임아웃 보상**: Beat 잡에서 `expire_pending_orders()`  
- [ ] 운영 대시보드: 예약 잔량/만료 주문/웹훅 실패 내역

---

## N. 마무리

- 본 설계는 **장바구니 → 주문 → 결제 → 웹훅** 표준 흐름을 **재고 일관성(예약/차감/보상)** 으로 안전하게 감쌉니다.  
- 핵심은 **트랜잭션 경계**와 **select_for_update + F()**, 그리고 **멱등 웹훅**입니다.  
- 트래픽 증가 시 **Outbox + 사가**로 확장(결제/재고/주문 코디네이션), **검색/리포팅**은 읽기 모델로 분리하면 됩니다.
