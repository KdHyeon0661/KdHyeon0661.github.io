---
layout: post
title: 암호학 - 소프트웨어 스택 & 도구
date: 2025-10-17 16:30:23 +0900
category: 암호학
---
# 18. 소프트웨어 스택 & 도구

> 이 장은 **“무엇을, 언제, 어떻게 써야 안전한가?”**에 초점을 맞춥니다.
> 라이브러리 철학(OpenSSL/BoringSSL/libsodium/NaCl) → 언어별 가이드(Python/Go/Rust/Java) → 웹/모바일(WebCrypto/Android Keystore/iOS Secure Enclave) 순서로, **기본값, 안전한 레시피, 금지 패턴, 배포·빌드 팁**을 정리합니다.
> 원칙: **표준 라이브러리 우선**, **현대 알고리즘(AEAD/EdDSA/X25519) 사용**, **자작 암호 금지**, **키·난수·오류 처리**는 11·12·13장 규칙 준수.

---

## ✅ 18.1 네 가지 핵심 스택의 철학

### 18.1.1 OpenSSL
- **역사 깊음·기능 방대**: TLS, X.509, 다양한 알고리즘, 엔진/프로바이더(FIPS 모듈) 등.
- **API 난도 높음**: 오래된 API(예: EVP 이전 low-level)와 현대 EVP 고수준 혼재.
- **쓸 때 포인트**
  - **EVP 계열**만 사용(대칭 `EVP_aead*`, 서명/키교환 `EVP_PKEY*`).
  - **FIPS 모드**가 필요하면 **프로바이더 기반(OpenSSL 3.x)** 으로 설정.
  - **실수 빈발**: IV/Nonce 관리, 오류코드 누락, 패딩/스트림 혼동.

**AES-GCM 개념 C 스니펫 (EVP)**
```c
EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL);
EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, 12, NULL);
EVP_EncryptInit_ex(ctx, NULL, NULL, key, iv);
EVP_EncryptUpdate(ctx, NULL, &len, aad, aad_len);
EVP_EncryptUpdate(ctx, out, &len, in, in_len);
EVP_EncryptFinal_ex(ctx, out+len, &len2);           // GCM은 의미상 no-op
EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, 16, tag);
EVP_CIPHER_CTX_free(ctx);
```
> **주의**: Nonce(12B) **키당 고유**. AAD는 앱 문맥(tenant|table|field) 포함.

### 18.1.2 BoringSSL
- **구글 포크**: TLS 중심 **살아있는 최소화 분기**, 외부 API 호환성 **보장 안 함**.
- **장점**: 현대 TLS·AEAD 기본값, 안전 기본 설정.
- **언제?**: Android/Chrome/Envoy/구글 생태와 밀접, 자체 빌드·벤더링 가능할 때.

### 18.1.3 NaCl / libsodium
- **철학**: “**안전한 프리미티브를 간단 API로**”.
- **기본값 현대화**: `crypto_aead_chacha20poly1305`, `crypto_sign_ed25519`, `crypto_kx`, `crypto_pwhash_argon2id`.
- **장점**: 상수시간 구현, 키관리·Nonce 정책이 쉬움, 플랫폼 폭넓음.
- **언제?**: **응용암호**를 자체 조합할 때(파일·메시지 암호화, 키 교환, 서명 등) — **가장 추천** 스택 중 하나.

**libsodium 메시지 암호화 예**
```c
// aead (detached)
crypto_aead_chacha20poly1305_ietf_encrypt(
  c, &clen, m, mlen, aad, aadlen, NULL, nonce, key);
// nonce 12B: 전역 고유; key: 32B; tag 16B는 c 끝에 붙거나 별도
```

### 18.1.4 “NaCl API 철학” 3줄 요약
1) **현대·강한 기본값(ChaCha20-Poly1305, Ed25519, X25519)**
2) **단순·오류 가능성 최소화 API**(일체형 AEAD, 상수시간 비교)
3) **안전한 난수·키파생(Argon2id)** 기본 제공

---

## ✅ 18.2 언어별 가이드

### 18.2.1 Python — `pyca/cryptography`
- **선택 이유**: 광범위 사용, OpenSSL 바인딩, 높은 수준의 안전 추상화.
- **핵심 모듈**: `hazmat.primitives.ciphers.aead`(AESGCM/ChaCha20Poly1305), `hashes`, `hmac`, `kdf`(HKDF/Scrypt), `serialization`, `x509`.

**AEAD 예 (AES-GCM)**
```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os
key = AESGCM.generate_key(bit_length=256)
nonce = os.urandom(12)
aad = b"v=1|tenant=t1|table=users|field=ssn"
ct = AESGCM(key).encrypt(nonce, b"secret-bytes", aad)
pt = AESGCM(key).decrypt(nonce, ct, aad)
```

**HKDF 키 파생**
```python
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
hkdf = HKDF(algorithm=hashes.SHA256(), length=32, salt=salt, info=b"context")
k = hkdf.derive(ikm)
```

**비밀번호 해시(Argon2id)** → 외부 패키지(`argon2-cffi`) 권장.
**금지 패턴**: 직접 블록 모드 조합(CBC+HMAC 구현)·`random` 모듈로 키/nonce 생성·길이 확장 공격을 초래할 해시 연결.

**TLS/PKI**
- 서버 인증서는 `cryptography.x509`로 파싱/검증 가능하지만, **TLS 스택은 `requests`/`urllib3` 기본**을 사용(검증/OCSP는 프레임워크에 위임).

---

### 18.2.2 Go — `crypto/*` 표준 라이브러리
- **장점**: 표준에 안전 기본값 다수 포함, 간결한 API, 상수시간 함수 제공.
- **AEAD**: `crypto/cipher`의 `NewGCM`, `chacha20poly1305` 패키지.
- **키 교환/서명**: `crypto/ed25519`, `crypto/ecdsa`(P-256), `crypto/rand`로 난수.
- **TLS**: `crypto/tls` — TLS 1.3 기본, 서버·클라 설정 용이.

**AES-GCM 예**
```go
block, _ := aes.NewCipher(key)             // 16/24/32B
gcm, _ := cipher.NewGCM(block)             // 12B nonce 권장
nonce := make([]byte, gcm.NonceSize())
rand.Read(nonce)
ciphertext := gcm.Seal(nil, nonce, plaintext, aad)
pt, err := gcm.Open(nil, nonce, ciphertext, aad)
```

**X25519 키 교환**
```go
pk, sk, _ := curve25519.GenerateKey(rand.Reader)
shared, _ := curve25519.X25519(sk, peerPk)
```

**Ed25519 서명**
```go
pub, priv, _ := ed25519.GenerateKey(rand.Reader)
sig := ed25519.Sign(priv, msg)
ok := ed25519.Verify(pub, msg, sig)
```

**금지 패턴**
- `math/rand`로 키/nonce 생성, CBC 자체조합, HMAC 미검증.
- `tls.Config`에서 `InsecureSkipVerify: true` **절대 금지**.

---

### 18.2.3 Rust — `ring`, `orion`, `rustls`, `aes-gcm`/`chacha20poly1305`
- **`ring`**: 고성능, 안전한 기본 구현(Ed25519/X25519/AES-GCM/ChaCha20-Poly1305/ HKDF).
- **`orion`**: libsodium 철학의 쉬운 API(상수시간, AEAD/HKDF 등).
- **`rustls`**: TLS 1.3 전용 스택(브라우저 신뢰 저장소는 `webpki-roots` 등과 조합).
- **Crypto crates**(RustCrypto): `aes-gcm`, `chacha20poly1305`, `hkdf`, `sha2`, `ed25519-dalek` 등.

**ring AEAD 예**
```rust
use ring::aead::{LessSafeKey, UnboundKey, Aad, NONCE_LEN, AES_256_GCM, Nonce};
use ring::rand::{SystemRandom, SecureRandom};

let rng = SystemRandom::new();
let key_bytes = [0u8; 32]; // KMS/HKDF 등으로 주입
let key = LessSafeKey::new(UnboundKey::new(&AES_256_GCM, &key_bytes).unwrap());
let mut nonce_bytes = [0u8; NONCE_LEN]; rng.fill(&mut nonce_bytes).unwrap();
let nonce = Nonce::assume_unique_for_key(nonce_bytes);
let aad = Aad::from("v=1|tenant=t1");
let mut in_out = b"plaintext...".to_vec();
key.seal_in_place_append_tag(nonce, aad, &mut in_out).unwrap();
// decrypt: key.open_in_place(nonce, aad, &mut in_out).unwrap();
```

**orion 예**
```rust
use orion::aead;
let key = aead::SecretKey::default();
let ct = aead::seal(&key, b"plaintext")?;
let pt = aead::open(&key, &ct)?;
```

**금지 패턴**: 자체 `unsafe` 최적화로 상수시간 깨기, nonce 재사용, RNG를 `StdRng`로 대체.

---

### 18.2.4 Java — JCA/JCE & BouncyCastle/Tink
- **JCA/JCE**: 서비스 프로바이더(BC/SunEC/Conscrypt) 플러그형 구조.
- **권장 루트**: `Cipher`(AES/GCM), `KeyAgreement`(X25519/EC), `Signature`(Ed25519/ECDSA), `KeyStore`(HSM/PKCS#11).
- **Tink**(구글): 안전한 기본값·키 관리·프리미티브 패밀리 제공(추천).

**AES-GCM 예 (JDK 11+)**
```java
var key = KeyGenerator.getInstance("AES").generateKey(); // 128/256
var gcm = Cipher.getInstance("AES/GCM/NoPadding");
var iv = SecureRandom.getInstanceStrong().generateSeed(12);
gcm.init(Cipher.ENCRYPT_MODE, key, new GCMParameterSpec(128, iv));
gcm.updateAAD("v=1|ctx".getBytes(StandardCharsets.UTF_8));
byte[] ct = gcm.doFinal(plaintext);
```

**X25519 (JDK 11+, 일부 프로바이더 필요)**
```java
KeyPairGenerator kpg = KeyPairGenerator.getInstance("X25519");
KeyPair kp = kpg.generateKeyPair();
KeyAgreement ka = KeyAgreement.getInstance("X25519");
ka.init(kp.getPrivate());
ka.doPhase(peerPub, true);
byte[] shared = ka.generateSecret();
```

**금지 패턴**
- `AES/CBC/PKCS5Padding` + 수동 HMAC 조합(오류 가능)
- `SecureRandom` 시드 고정/직접 씨드 주입
- `trustAll` 소켓 팩토리/호스트네임 검증 비활성화

---

## ✅ 18.3 웹/모바일 플랫폼

### 18.3.1 WebCrypto (브라우저)
- **API**: `window.crypto.subtle`
- **권장**: `AES-GCM`, `HKDF`, `ECDH`(`P-256`/`X25519` 지원 여부는 브라우저에 따라), `Ed25519`는 일부 환경에서 WebAssembly 라이브러리 사용.
- **키 스토리지**: `IndexedDB` + wrap/unwrap, 또는 WebAuthn(키 보호/UV)와 결합.

**예 (AES-GCM)**
```js
const key = await crypto.subtle.generateKey(
  {name: "AES-GCM", length: 256}, true, ["encrypt","decrypt"]);
const iv = crypto.getRandomValues(new Uint8Array(12));
const aad = new TextEncoder().encode("v=1|ctx");
const ct = await crypto.subtle.encrypt(
  {name: "AES-GCM", iv, additionalData: aad, tagLength: 128},
  key, new TextEncoder().encode("secret"));
```

**주의**: 브라우저별 지원 차이/에지 케이스. **XSS 방어**로 **브라우저에 장기 토큰 저장 금지**; BFF(11장) 활용.

---

### 18.3.2 Android Keystore
- **하드웨어 백업**(TEE/StrongBox) 가능: 키는 **추출 불가**.
- **KeyGenParameterSpec**로 용도/알고리즘/사용 정책(지문/PIN 요구) 지정.
- **AES-GCM**/`EC`(P-256)/`RSA` 키 래핑·서명·TLS client cert.

**예 (AES-GCM)**
```kotlin
val keyGen = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, "AndroidKeyStore")
val spec = KeyGenParameterSpec.Builder(
    "aead-key", PURPOSE_ENCRYPT or PURPOSE_DECRYPT)
    .setBlockModes(BLOCK_MODE_GCM)
    .setEncryptionPaddings(ENCRYPTION_PADDING_NONE)
    .setUserAuthenticationRequired(true) // 생체/핀
    .setRandomizedEncryptionRequired(true)
    .build()
keyGen.init(spec)
val key = keyGen.generateKey()

val cipher = Cipher.getInstance("AES/GCM/NoPadding")
cipher.init(Cipher.ENCRYPT_MODE, key)
cipher.updateAAD("v=1|ctx".toByteArray())
val ct = cipher.doFinal(plaintext)  // [cipher||tag], IV는 cipher.iv
```

**주의**
- **Nonces는 프레임워크가 랜덤 생성**(권장). IV 별도 저장 필요.
- StrongBox 미지원 기기 고려(성능/가용성 전략).
- 키 사용 시 **사용자 인증 바인딩**(시간 제한) 옵션으로 도난 위험 완화.

---

### 18.3.3 iOS Secure Enclave & Keychain
- **Secure Enclave**: 하드웨어 격리, 키 추출 불가.
- **Keychain**: 접근 제어(생체/패스코드·디바이스 잠금 상태 조건).
- **CryptoKit**: `ChaChaPoly`, `AES.GCM`, `Curve25519`, `P256` 등.

**CryptoKit 예 (ChaCha20-Poly1305)**
```swift
import CryptoKit
let key = SymmetricKey(size: .bits256)
let sealed = try! ChaChaPoly.seal(data, using: key, authenticating: aad)
let box = sealed.combined              // nonce|cipher|tag
let opened = try! ChaChaPoly.open(ChaChaPoly.SealedBox(combined: box), using: key)
```

**Keychain 저장 예(심플)**
```swift
let query: [String: Any] = [
  kSecClass as String: kSecClassKey,
  kSecAttrApplicationTag as String: "com.example.key.aead",
  kSecValueRef as String: keyRef,
  kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
]
SecItemAdd(query as CFDictionary, nil)
```

**주의**: 앱 재설치/백업/마이그레이션 시 키 수명 정책 고려(12장).

---

## ✅ 18.4 안전 레시피 모음

### 18.4.1 파일/객체 암호화(봉투)
1) **DEK = 32B** 랜덤
2) **AEAD(AES-GCM/ChaCha20-Poly1305)** 로 파일 블록 암호화(스트리밍 가능)
3) **EDK = KMS wrap** 결과를 헤더에 저장
4) 헤더에 `v|alg|nonce|aad|edk` 기록, **Nonce 고유성 보장**
5) 복호 시 KMS unwrap → DEK 메모리 보관 최소화(13장 소거)

### 18.4.2 패스워드 기반 암호화
- **Argon2id**(메모리≥64MiB·시간≥2) → `HKDF-SHA256`으로 키 분리 → AEAD.
- **salt**≥16B(저장), **pepper**(서버 비밀) 선택.
- 파라미터는 문자열 포맷에 포함하여 **마이그레이션 자동화**.

### 18.4.3 키 교환
- **X25519** + **HKDF** 로 세션 키 생성 → **AEAD**.
- 인증 필요 시 상호 서명(Ed25519) 또는 TLS 1.3.

---

## ✅ 18.5 배포·빌드 팁

- **OpenSSL 3.x**: 프로바이더(FIPS/Default) 구성, **deprecated API 금지**.
- **정적 분석**: Go vet, Rust clippy, Java SpotBugs, C/C++ ASan/UBSan.
- **상수시간/사이드채널**: 하드웨어 가속(AES-NI/ARMv8 CE), 언어별 상수시간 API 사용(13장).
- **난수**: OS CSPRNG 사용(`getrandom`, `SecRandomCopyBytes`, `crypto/rand`, `os.urandom`).
- **테스트**: KAT(known-answer test)·프로퍼티 테스트(입출력 길이/에러 균일화).
- **버전 고정**: TLS/알고리즘/키 길이 정책을 코드·문서화.
- **FIPS 필요 시**: **검증 모듈**·운영 모드·구성 변경 시 재검증 범위 확인.

---

## ✅ 18.6 금지/주의 패턴(언어 공통)

1) **CBC/CTR 직접 조합 + 수동 HMAC** (AEAD 쓰세요)
2) **Nonce 재사용**(GCM/ChaCha20-Poly1305 치명적)
3) **운영 RNG 오용**(`rand()`/`Math.random()`로 키 생성)
4) **`InsecureSkipVerify`/`trustAll`**
5) **자체 직렬화 포맷**(서명/AAD 혼동 가능) — 13장 직렬화 규칙
6) **키/비밀 평문 로그/코어덤프**(12·13장)

---

## ✅ 18.7 미니 레퍼런스 레시피(언어별)

### Python
- **파일 암호화**: `AESGCM` + 봉투(KMS)
- **서명/검증**: `ed25519`(libsodium/pyca), 또는 `ec.SECP256R1` + `ECDSA(SHA-256)`
- **키 파생**: `HKDF(SHA-256)` / `Scrypt`, 비밀번호는 `argon2-cffi`
- **TLS**: `requests` 기본 검증 + 핀/CT 필요 시 외부 확장

### Go
- **AEAD**: `chacha20poly1305.NewX`(Nonce 24B) 또는 `cipher.NewGCM`
- **KDF**: `hkdf`
- **서명**: `ed25519`
- **TLS**: `tls.Config`에서 `MinVersion=tls.VersionTLS13`, ALPN·H2 기본

### Rust
- **AEAD**: `ring` 또는 `aes-gcm`/`chacha20poly1305`
- **KDF**: `ring::hkdf`
- **서명**: `ed25519-dalek`
- **TLS**: `rustls`(서버/클라), 루트는 `webpki-roots`

### Java
- **AEAD**: `AES/GCM/NoPadding`
- **서명**: `Ed25519`(JDK 15+), 또는 `ECDSA`(P-256)
- **KDF**: `HKDF`(표준화는 JDK 직접 없음 → Tink/BC)
- **TLS**: `HttpsURLConnection/OkHttp` 기본 검증, 핀은 `CertificatePinner`

---

## ✅ 18.8 운영 체크리스트

- [ ] **AEAD**만 사용, CBC 금지
- [ ] **Nonce 고유성**(prefix+counter 또는 라이브러리 관리)
- [ ] **CSPRNG**로 키/Nonce 생성
- [ ] **HKDF/Argon2id**로 키 파생, 파라미터 기록
- [ ] **TLS 1.3** 기본, mTLS(내부), `InsecureSkipVerify=false`
- [ ] **KMS/HSM** 연동(봉투 암호화), 키 회전/감사(12·17장)
- [ ] **오류 메시지 균일화/타이밍 완화**(13장)
- [ ] **종단 간 테스트**: 재시작/스케일아웃에서 Nonce 충돌 없음 검증
- [ ] **CI**: 린트/정적분석/동적테스트/사이드채널 스캔(dudect 등)
- [ ] **문서화**: 스펙(알고리즘·길이·정책) + 코드 주석 + 런북

---

## ✅ 18.9 자주 하는 실수(사례)

- **“간단해서 CBC 썼다”** → 패딩 오라클 위험(13장), AEAD로 교체
- **Nonce를 DB auto-increment로** → 재배포/롤백 시 충돌, **prefix(인스턴스ID)+원자 카운터** 설계
- **키/IV를 Base64로 하드코딩** → 비밀 관리 실패(12장 Secrets Store)
- **WebCrypto에서 tagLength 누락** → 기본 128비트인지 확인, 브라우저 차이 주의
- **Android Keystore에서 무작위화 강제 해제** → 결정적 암호화 시 위험, 가능한 **토큰화**로 설계 변경

---

## ✅ 18.10 실습 과제

1) **봉투 암호화** 래퍼를 (Python/Go/Rust 중 택1)로 작성하고, 헤더에 `v|alg|nonce|aad|edk`를 JSON으로 넣어라. 재암호화(회전) 절차도 구현.
2) **X25519 + HKDF → AES-GCM** 키교환-암호 스니펫을 작성하고, 상호 인증(Ed25519)까지 확장하라.
3) **WebCrypto**로 파일 조각 스트리밍 AES-GCM 암호화(ReadableStream→WritableStream) 데모를 만들어라(Nonce 충돌 방지 포함).
4) **Android**에서 사용자 인증 요구 키(`setUserAuthenticationRequired(true)`)로 암호화를 수행하고, 인증 만료 시간(`setUserAuthenticationValidityDurationSeconds`)을 실험하라.
5) **Rust ring + rustls**로 TLS 서버를 띄우고, 클라이언트 인증서(mTLS)를 적용하라. 실패/성공 로그를 **동일 에러**로 처리해 사이드채널을 줄여라.

---

## ✅ 18.11 요약 카드

- **라이브러리 선택**: 일반 응용은 **libsodium/NaCl 철학**이 가장 안전하고 단순. TLS/PKI는 **OpenSSL/BoringSSL/rustls**.
- **현대 기본값**: **AEAD(AES-GCM/ChaCha20-Poly1305)**, **X25519/Ed25519**, **HKDF**, **Argon2id**.
- **플랫폼**: WebCrypto/Android Keystore/iOS Secure Enclave로 **키 추출 불가·사용자 검증 연계**.
- **운영**: **KMS/HSM + 봉투**, **Nonce 정책**, **에러 균일화**, **CI·정적/동적 분석**.
