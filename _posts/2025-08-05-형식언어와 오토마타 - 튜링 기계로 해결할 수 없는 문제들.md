---
layout: post
title: 형식언어와 오토마타 - 튜링 기계로 해결할 수 없는 문제들
date: 2025-08-05 21:20:23 +0900
category: 형식언어와 오토마타
---
# 튜링 기계로 **해결할 수 없는 문제들** — 계산 가능성 vs 결정 가능성, 정지 문제, 그리고 **감소(변형) 기법**

이 글은 “**무엇을 계산할 수 있는가**(computability)”와 “**문제를 판정할 수 있는가**(decidability)”의 차이를 분명히 하고,  
튜링 기계의 **정지 문제**를 중심으로 **결정 불가능** 문제가 왜/어떻게 생기는지, 그리고  
이미 알려진 불가능 문제를 **새 문제로 변형(감소)** 하는 **실전 레시피**까지 정리한다.  
수식은 MathJax, 절차는 코드 블록(```)로 표기한다.

---

## 1) 계산 가능성 vs 결정 가능성

### 1.1 함수와 부분계산 가능성
- **계산 가능한 함수**: 어떤 튜링 기계 \(M\)가 **모든 입력에서 정지**하여 함수값을 출력.  
- **부분 계산 가능한 함수**(partial computable): 어떤 입력에서는 **무한 루프** 가능.  
  \[
  \varphi_M(x) = 
  \begin{cases}
  \text{출력} & (\text{정지})\\
  \uparrow & (\text{무한})
  \end{cases}
  \]

### 1.2 언어와 (반)결정 가능성
- **결정 가능(=재귀적)** 언어 \(L\): 어떤 TM이 **모든 입력에서 정지**해 Yes/No.  
- **반결정 가능(=RE, c.e.)**: \(w\in L\)이면 **언젠가 수용**하되, \(w\notin L\)에서 **돌 수도** 있음.
- 기본 정리:
  \[
  L\ \text{와}\ \overline{L}\ \text{가 둘 다 RE} \iff L\ \text{는 결정 가능}.
  \]

---

## 2) 정지 문제(Halting Problem) — 결정 불가능의 출발점

### 2.1 정의
\[
\textsf{HALT}=\{\;\langle M\rangle \# w \mid M \text{ 이 } w \text{ 에서 정지}\;\}.
\]

### 2.2 대각선/귀류 스케치
“정지 판별기” \(H\)가 있다고 가정하고,
```text
D(x):
  if H(x,x) == "halt" then loop forever
  else halt
```
를 만든 뒤 \(D(\langle D\rangle)\)을 대입하면 **모순**.  
⇒ \(\textsf{HALT}\)는 **결정 불가능**. (단, **RE**는 맞다: 정지하면 잡아낼 수 있으므로)

### 2.3 친척 문제
- \(\textsf{A\_TM}=\{\langle M\rangle\#w \mid M \text{이 } w \text{를 수용}\}\): **RE-완전**, 결정 불가능.  
- \(\overline{\textsf{A\_TM}}\): **RE 아님**(co-RE도 아님일 수 있음).  
- \(\textsf{E\_TM}=\{\langle M\rangle\mid L(M)=\varnothing\}\): **co-RE**, 결정 불가능.  
- **총정지성** \(\textsf{TOT}=\{\langle M\rangle\mid \forall w\, M(w)\downarrow\}\): 더 높은 계층(대개 \(\Pi^0_2\)-완).

---

## 3) 불가능의 범용 도구: **Rice 정리**와 **대각선**, **열거/도베일링**

### 3.1 Rice 정리(의미론적 속성 불가능성)
> **비자명한** 프로그램 의미 속성은 모두 **결정 불가능**.  
> (비자명 = 어떤 프로그램은 만족, 어떤 프로그램은 불만족)

즉, “언어가 공백/유한/모든 문자열/정규/…인가?”,  
“프로그램이 항상 배열 범위 내인가?” 같은 **의미** 속성의 **일반 판정기**는 존재 불가.

### 3.2 대각선(집합/함수 버전)
- 집합: \(K=\{e \mid \varphi_e(e)\downarrow\}\) 는 **RE-완전**.  
- 함수: Busy Beaver \(\Sigma(n)\), Kolmogorov 복잡도 \(K(x)\)는 **비계산**.

### 3.3 도베일링(dovetailing)
“양쪽이 RE면 결정 가능”의 핵심 기법. (교대 시뮬레이션)

```text
Decide(w):
  for t = 1,2,3,...:
    simulate M_yes(w) for t steps; if accept -> YES
    simulate M_no (w) for t steps; if accept -> NO
```

---

## 4) **감소(변형)**: 결정 불가능을 **전파**하는 표준 방법

우리가 하고 싶은 것:  
이미 **결정 불가능**임이 알려진 \(A\)에서, 새로운 문제 \(B\)가 **적어도** \(A\)만큼 어렵다는 걸 보이기.

### 4.1 many-one(맵핑) 감소 \((\le_m)\)
계산 가능한 \(f\)가 있어
\[
x\in A \iff f(x)\in B.
\]
- 결과: \(A\)가 결정 불가능이면 \(B\)도 결정 불가능.  
- **완전성**: “모든 RE 문제에서 \(\le_m\)로 온다” ⇒ **RE-완전**.

### 4.2 튜링 감소 \((\le_T)\)
\(B\)의 **오라클**을 사용해 \(A\)를 계산. (질의-응답 허용)  
→ \(\le_m\)보다 약하지만 실전 구성에 유연.

### 4.3 감수(감소) **레시피**
1) **출발점** 선택: \(\textsf{A\_TM}\), \(\textsf{HALT}\), **PCP** 등.  
2) **인코딩**: \(x\)를 목표 도메인(문법/오토마타/타일/수식)으로 매핑.  
3) **정직성 보장**:  
   - (⇒) “예일 때” 인코딩 구조가 **해를 만들 수 있게**.  
   - (⇐) “아니오일 때”는 **어떤 방법으로도** 해가 불가능하게 **막는 가젯**.  
4) **단방향성**(many-one): **오직 한 번의** 변환으로 양방향 논리 동치 확보.

> 팁: **구분자(#)**, **머리·꼬리 표식**, **지역 일관성 검사**(전이 규칙/타일 경계),  
> **시작/종료 강제 가젯**은 거의 모든 감소에서 재사용된다.

---

## 5) 대표적인 감소 예시 스케치

### 5.1 \(\textsf{A\_TM} \le_m \textsf{PCP}\) (MPCP 경유)
- **계산 테이블 인코딩**: 구성 \(C_i\)를 문자열로 표현,  
  “옳은 한 걸음”만 이어붙일 수 있는 **타일**을 설계.  
- **시작 강제**: 첫 타일이 초기구성 \(C_0\)을 올리도록.  
- **행 동기화**: 구분자 \(\#\) 가 맞지 않으면 절대 일치 불가.  
- 결론: \(M(w)\)가 수용 ⇔ PCP 해 존재.

### 5.2 CFG **보편성/포함성/모호성**으로의 감소
- **보편성** \(L(G)=\Sigma^*\)?  
  “잘못된 계산”을 생성하도록 \(G\)를 설계. 수용 계산이 **있으면** 모든 문자열이 “잘못된 것”으로 생성되어 **보편**.  
- **모호성**: 같은 문자열이 **두 다른 유도**를 갖게 하는 “계산/반계산” 구조를 심는다.

### 5.3 수학적 문제로의 변환
- **Wang 타일링**(평면 도미노): 1D 문자열 일치를 2D 경계 일치로 확장.  
- **Hilbert의 10번째**: 계산을 정수 방정식 해로 암호화(DPRM 정리).

---

## 6) 불가능을 **강화**하거나 **변형**하는 테크닉

### 6.1 “경계 조건” 가젯
- **시작 고정**: 첫 조각을 강제(예: MPCP의 1번 타일).  
- **끝 고정**: 수용 시 특별 마커로 닫아 다른 경로 봉쇄.

### 6.2 **지역→전역** 일치 끌어올리기
- 규칙/타일을 **국소 제약**으로 설계해, 전체 구조가 **전역적으로 합법적인 계산 테이블**이 되도록.  
  (지역 위반이 있으면 접합 실패)

### 6.3 **패딩/이진화**
- 알파벳을 2개로 **축소**해도 감소 유지(이진 PCP도 결정 불가능).  
- 길이/공간을 늘려 **복잡도 유지**(padding).

### 6.4 **인스턴스 분리/합성**
- 여러 검사를 한 인스턴스 안에서 수행하도록 **구성 병렬화**.  
- 또는 **합성 함수** \(x\mapsto \langle f_1(x),f_2(x)\rangle\) 로 다중 성질 결합.

---

## 7) 클래스 관점: RE / coRE / 그 너머

| 문제 | 속성 |
|---|---|
| \(\textsf{A\_TM}\), \(\textsf{HALT}\) | **RE-완전**, 결정 불가능 |
| \(\overline{\textsf{A\_TM}}\) | **non-RE** |
| \(\textsf{E\_TM}\) | **co-RE-완전**, 결정 불가능 |
| **PCP** | **RE-완전**, 결정 불가능 |
| **Wang 타일링** | 결정 불가능 |
| **Busy Beaver** \(\Sigma(n)\) | **비계산 함수** |
| **Kolmogorov** \(K(x)\) | **비계산** |

핵심 포함 관계:
\[
\text{Recursive} \subsetneq \text{RE} \subsetneq \mathcal{P}(\Sigma^*).
\]

---

## 8) 미니 증명 조각들

### 8.1 \(\overline{\textsf{A\_TM}}\) 은 RE가 아님
만약 RE였다면 \(\textsf{A\_TM}\)과 함께 **양쪽이 RE** ⇒ \(\textsf{A\_TM}\)은 **결정 가능**(도베일링) ⇒ 모순.

### 8.2 Busy Beaver 비계산(대각선)
“\(n\)상태 TM이 출력할 수 있는 최대 1의 개수/시간”을 계산하는 함수가 **계산 가능**이라면,  
그 값을 이용해 “그보다 1 더 하는” 기계를 구성 → 정의 모순.

### 8.3 Kolmogorov 복잡도 \(K(x)\) 비계산
만약 \(K\)가 계산 가능이면, “**프로그램보다 더 짧은 출력**”을 체계적으로 찾을 수 있어  
정의(최단 프로그램 길이)와 충돌.

---

## 9) 실전 체크리스트 — **새 undecidable 문제를 만들 때**

1) **표적 도메인** 선택: 문법/오토마타/그래프/타일/방정식 등.  
2) **상태 부호화**: TM 구성(상태·헤드·테이프)을 **문자열/타일/식**으로 _지역화_.  
3) **시작/종료 가젯**: 초기 구성 강제, 수용 시 닫힘.  
4) **지역 검증**: 인접 조각만 봐도 “합법 전이”인지 알 수 있게 규칙 설계.  
5) **정직성**: 예⇔예, 아니오⇔아니오의 **양방향 논리** 확인.  
6) **알파벳/자원 축소**: 이진화/유계화로도 불가능성이 유지되는지 점검.

---

## 10) 요약

- **계산 가능성**은 “함수를 산출할 수 있는가”, **결정 가능성**은 “Yes/No를 항상 판정하는가”.  
- **정지 문제**는 결정 불가능의 원형이고, **Rice 정리**와 **감소**로 수많은 불가능 결과가 파생된다.  
- **감소 레시피**(인코딩·지역검사·시작/종료 가젯)는 새 도메인에서도 그대로 통한다.  
- RE/비RE, coRE의 구분과 도베일링은 “어디까지 자동화 가능한가”의 근본 한계를 보여준다.

---

### 부록 A — 의사코드 스니펫: RE-완전성 증의 표준 틀

```text
# A_TM ≤m B 를 보이고 싶다.
# 입력 x = <M>#w 를 B의 인스턴스 f(x)로 변환:

reduce_to_B(x):
  parse x as <M>#w
  gadget := encode_TM_and_input_as_local_constraints(M, w)
  return instance_B(gadget)

# 올바름:
# (⇒) M이 w를 수용하면, gadget을 만족하는 해(증거)가 만들어짐 → f(x) ∈ B
# (⇐) f(x) ∈ B 라면, gadget의 지역 제약상 반드시 올바른 수용 계산이 존재 → M이 w를 수용
```