---
layout: post
title: 형식언어와 오토마타 - 튜링 기계로 해결할 수 없는 문제들
date: 2025-08-05 21:20:23 +0900
category: 형식언어와 오토마타
---
# 튜링 기계로 **해결할 수 없는 문제들** — 계산 가능성 vs 결정 가능성, 정지 문제, 그리고 **감소(변형) 기법**

이 글은 “**무엇을 계산할 수 있는가**(computability)”와 “**문제를 판정할 수 있는가**(decidability)”의 차이를 분명히 하고,
튜링 기계의 **정지 문제**를 중심으로 **결정 불가능** 문제가 왜/어떻게 생기는지, 그리고
이미 알려진 불가능 문제를 **새 문제로 변형(감소)** 하는 **실전 레시피**까지 정리한다.

---

## 1. 계산 가능성(함수) vs 결정 가능성(언어)

### 1.1 함수 관점 — (전)계산 가능 vs 부분 계산 가능
- **계산 가능한(총) 함수** \(f:\Sigma^*\to\Sigma^*\): 어떤 튜링 기계 \(M\)가 **모든 입력에서 정지**하여 \(f(x)\)를 출력.
- **부분 계산 가능한 함수**(partial computable) \(\varphi_M\): 어떤 입력에서는 **무한 루프** 가능.
  $$
  \varphi_M(x)=
  \begin{cases}
    y & (\text{정지하여 } y \text{ 출력})\\
    \uparrow & (\text{무한 루프})
  \end{cases}
  $$

### 1.2 언어(판정) 관점 — 결정 가능 vs 반결정 가능
- **결정 가능(=재귀적)** 언어 \(L\subseteq\Sigma^*\): 어떤 TM \(D\)가 **모든 입력에서 정지**해 Yes/No를 준다.
- **반결정 가능(=RE, c.e.)** 언어 \(L\): 어떤 TM \(N\)이 \(w\in L\)이면 **언젠가 수용**(accept)하지만, \(w\notin L\)이면 **영원히 돌 수도** 있다.
- 핵심 등식:
  $$
  \boxed{\,L \text{와 } \overline{L} \text{가 모두 RE} \iff L \text{는 결정 가능(Recursive)}\,}
  $$

> **직관**: RE는 “**예(수용)** 사례에 **유한한 증거**가 있어 **언젠가** 드러난다.” 결정 가능은 **예/아니오 모두** 유한 시간에 판정.

---

## 2. 정지 문제(Halting Problem) — 결정 불가능의 출발점

### 2.1 정의
$$
\textsf{HALT}=\{\langle M\rangle \# w \mid M \text{이 입력 } w \text{에서 유한 시간 내 정지}\}.
$$

### 2.2 대각선(귀류) 스케치
“정지 판별기” \(H\)가 있다고 가정하고, 아래 기계 \(D\)를 만든다.

```text
D(x):
  if H(x, x) == "halt" then loop forever
  else halt
```

이제 \(D(\langle D\rangle)\)을 넣으면:
- \(H(\langle D\rangle,\langle D\rangle)=\texttt{halt}\)라면, 정의에 의해 \(D\)는 **무한 루프**해야 함(모순).
- \(\texttt{loop}\)라면, \(D\)는 **정지**해야 함(모순).

따라서 **그런 \(H\)는 존재할 수 없다** ⇒ \(\textsf{HALT}\)는 **결정 불가능**.
단, 정지하면 잡아낼 수 있으므로 \(\textsf{HALT}\)는 **RE**이다.

### 2.3 친척 문제들과 분류(요약)

| 문제 | 정의 요약 | 분류(요지) |
|---|---|---|
| \(\textsf{A\_TM}\) | \(\{\langle M\rangle\#w \mid M \text{이 } w \text{수용}\}\) | **RE-완전**, 결정 불가능 |
| \(\overline{\textsf{A\_TM}}\) | \(\{\langle M\rangle\#w \mid M \text{이 } w \text{미수용}\}\) | **co-RE**, 결정 불가능 |
| \(\textsf{E\_TM}\) | \(\{\langle M\rangle \mid L(M)=\varnothing\}\) | **co-RE-완전**, 결정 불가능 |
| \(\textsf{NE\_TM}\) | \(\{\langle M\rangle \mid L(M)\neq\varnothing\}\) | **RE-완전**, 결정 불가능 |
| \(\textsf{TOT}\) | \(\{\langle M\rangle \mid \forall w,\, M(w)\downarrow\}\) | 대개 **\(\Pi^0_2\)-완전**, 결정 불가능 |
| \(\textsf{ALL\_TM}\) | \(\{\langle M\rangle \mid L(M)=\Sigma^*\}\) | 보통 **\(\Pi^0_2\)-완전**, RE도 co-RE도 아님 |

---

## 3. 불가능의 범용 도구: **Rice 정리**, **대각선**, **도베일링**

### 3.1 Rice 정리 — 의미(함수/언어) 속성의 일반 불가능성
> **부분 계산 가능 함수의 비자명한 의미 속성은 모두 결정 불가능**.
> (비자명 = 어떤 프로그램은 만족, 어떤 프로그램은 불만족. “의미”만 보고 결정되어야 함.)

즉, “\(L(M)\)이 **정규**인가?”, “**문맥자유**인가?”, “**공백/보편/유한/무한**인가?”, “**등가성** \(L(M_1)=L(M_2)\)?” 등은 **일반적으로 결정 불가능**.

### 3.2 대각선의 또 다른 얼굴
- 집합 버전: \(K=\{e \mid \varphi_e(e)\downarrow\}\) (자기입력 정지 집합) — **RE-완전**.
- 함수 버전: **Busy Beaver** \(\Sigma(n)\), **Kolmogorov 복잡도** \(K(x)\) — **비계산**.

### 3.3 도베일링(dovetailing) — “양쪽이 RE면 결정 가능”
두 인식기 \(M_{\text{yes}}\) (L)와 \(M_{\text{no}}\) (\(\overline{L}\))가 있으면, 교대로 조금씩 시뮬레이션하면 **언젠가 하나가 수용**:

```text
Decide(w):
  for t = 1,2,3,...
    simulate M_yes(w) for t steps; if it accepts: return YES
    simulate M_no (w) for t steps; if it accepts: return NO
```

---

## 4. **감소(변형) 기법**: 불가능을 **전파**하는 표준 방법

### 4.1 many-one(맵핑) 감소 \((\le_m)\)
계산 가능한 \(f\)에 대해
$$
x\in A \iff f(x)\in B.
$$
- \(A\)가 결정 불가능 ⇒ \(B\)도 결정 불가능.
- “모든 RE 문제에서 \(\le_m\)로 온다”면 **RE-완전**.

### 4.2 튜링 감소 \((\le_T)\)
\(B\)를 **오라클**로 사용하면 \(A\)를 계산 가능. (\(\le_m\)보다 **약하지만 유연**)

### 4.3 감수(감소) **레시피**
1) **출발점**: \(\textsf{A\_TM}\), \(\textsf{HALT}\), **PCP** 등 “원형” 불가능 문제.
2) **인코딩**: \(x\)를 목표 도메인(문법/오토마타/타일/방정식/그래프 등) **인스턴스**로 변환.
3) **정직성** 보장:
   - (⇒) 예일 때 **해(증거)**가 반드시 존재.
   - (⇐) 아니오일 때 **어떤 구성도** 조건을 만족하지 못함.
4) **국소→전역**: **지역 검사 가젯**(전이 일관성, 경계 일치)로 “올바른 계산 테이블”만 통과.

> **가젯 도감**: 구분자 `#`, 시작/종료 마커, “복사” 제약(문자 일치), 인접 전이 검사, padding/이진화.

---

## 5. 대표 감소 **작동 예시** (핵심 아이디어 포함)

### 5.1 \(\textsf{A\_TM} \le_m \textsf{NE\_TM}\) — 비공백성의 RE-완전성
입력 \(x=\langle M\rangle\#w\)에서 다음 TM \(N_x\)를 구성:

```text
N_x(u):                       # u는 N_x의 입력이지만 사실 무시
  simulate M(w)
  if M(w) accepts:
     accept                  # 모든 u 수용 → L(N_x)=Σ*
  else:
     loop forever            # 어떤 u도 수용 안 함 → L(N_x)=∅
```

그러면
$$
\langle M\rangle\#w\in A_{TM} \iff L(N_x)\neq\varnothing \iff \langle N_x\rangle\in NE_{TM}.
$$
따라서 \(NE_{TM}\)은 **RE-완전**(결정 불가능), 보수 \(E_{TM}\)은 **co-RE-완전**.

---

### 5.2 \(\textsf{A\_TM} \le_m\) **CFG 보편성** — \(L(G)=\Sigma^*\)?
목표: \(M(w)\)가 수용 ⇔ 구성한 CFG \(G\)가 **보편**.

아이디어(표준 테크닉):
- **계산 테이블 인코딩**: 각 단계 구성을 문자열로, 단계 사이를 구분자 `#`로 구획.
- **잘못된 계산**만 생성하는 CFG \(G_{\text{bad}}\)를 만든다:
  (i) 형식 위반, (ii) 전이 불일치, (iii) 시작구성 오류, (iv) 수용상태 미등장 등.
- 만약 \(M(w)\)가 **수용**한다면, “유일한 올바른 계산 스트링” **하나만** 제외하고 나머지 모든 문자열은 “잘못됨”으로 생성됨 ⇒ 사실상 \(\Sigma^*\) 전체가 생성(보편).
- 반대로 수용 경로가 없으면, 그 “올바른 계산” 스트링이 **존재하지 않으므로** \(G\)는 보편이 아님.

> 실제 구성은 “지역 전이 검사”를 BNF 규칙 패턴으로 분해하여 구현(PCP 감소와 같은 철학).

---

### 5.3 \(\textsf{A\_TM} \le_m \textsf{PCP}\) (또는 MPCP)
- **행 인코딩**: \(C_0,C_1,\ldots,C_t\)를 위/아래 문자열로 쌓아 **열 선택**으로 정렬.
- **시작 강제**: 첫 타일이 \(C_0\)을 강제.
- **전이 지역검사**: 인접 셀들만 봐도 “합법 전이”인지 알게 타일 경계 색상을 설계.
- \(M(w)\) 수용 ⇔ PCP 해 존재.

---

## 6. (반)결정 가능 분류 — RE/co-RE/더 높은 계층

### 6.1 산술 계층 한눈표
- \(\Sigma^0_1\)(=RE): “**존재적** 양화가 맨 앞” 형태
  \(x\in L \iff \exists t\, R(x,t)\), 여기서 \(R\)은 결정 가능.
- \(\Pi^0_1\)(=co-RE): “**전칭** 양화가 맨 앞”
- \(\Pi^0_2\), \(\Sigma^0_2\): \(\forall\exists\) 또는 \(\exists\forall\)의 혼합.

### 6.2 대표 문제 분류(요약 표)

| 문제 | 분류 | 코멘트 |
|---|---|---|
| \(A_{TM}, HALT\) | **RE-완전** | 멤버십/정지 “있으면 언젠가 잡힘” |
| \(NE_{TM}\) | **RE-완전** | 비공백성 |
| \(E_{TM}\) | **co-RE-완전** | 공백성 |
| \(ALL_{TM}, EQ_{TM}, SUB_{TM}, INF_{TM}, TOT\) | 대개 **\(\Pi^0_2\)-완전** | RE도 co-RE도 아님(상위 계층) |
| **PCP** | **RE-완전** | 해 존재 여부 |

---

## 7. 실무 감각: “의미 판정”의 한계와 회피 전략

- **일반 프로그램 의미**(정지/등가/보편/최적화 안전성 등)는 **Rice 정리**에 막힘:
  - “항상 배열 경계 내인가?”, “항상 데드락 없음?” 같은 전역 속성 — 일반적으로 **결정 불가능**.
- **회피책**:
  1) **제한된 모델**로 낮추기(정규/CFL/안전한 subset 언어)
  2) **보수적 근사**(거짓 양성/음성 허용), **시간 제한/휴리스틱**
  3) **증명 책임 이동**(타입 시스템/계약/증명 의무)

---

## 8. 증명 조각(클래식)

### 8.1 \(\overline{A_{TM}}\)은 **RE가 아님**
만약 \(\overline{A_{TM}}\)이 RE라면, \(A_{TM}\)과 함께 **둘 다 RE** ⇒ 도베일링으로 \(A_{TM}\) **결정 가능** ⇒ 모순.
(단, \(\overline{A_{TM}}\)은 **co-RE**임에 유의: 보수 \(A_{TM}\)이 RE이므로.)

### 8.2 Busy Beaver \(\Sigma(n)\) **비계산**
\(\Sigma(n)\)이 계산 가능하다고 가정하면, 그 값을 이용해 “그보다 1 더 오래/많이 출력”하는 기계를 구성 가능 ⇒ 정의와 모순.

### 8.3 Kolmogorov 복잡도 \(K(x)\) **비계산**
\(K\)가 계산 가능하면, “짧은 프로그램으로 생성 불가능”해야 할 문자열을 **체계적으로 찾아내는** 역설이 생김 ⇒ 모순.

---

## 9. **설계 체크리스트** — 새 undecidable 문제를 만들 때

1) **표적 도메인** 선택(문법/타일/그래프/방정식/로직 등)
2) **상태 부호화**: TM 구성(상태·헤드·테이프)을 **문자열/타일/식**으로 로컬 인코딩
3) **시작/종료 가젯**: 초기 구성 강제, 수용 시 특별 마커로 닫기
4) **지역 검사**: 인접 규칙만으로 합법 전이 판별(“로컬→글로벌” 트릭)
5) **양방향 논리**: 예⇔예, 아니오⇔아니오가 정확히 맞물리는지 점검
6) **이진화/패딩**: 알파벳 축소/자원 제한 하에서도 불가능성이 유지되는지

---

## 10. 실전 스니펫 모음

### 10.1 도베일링 — “양쪽이 RE면 결정 가능”
```text
# M_yes: L의 인식기(∈일 때 언젠가 accept)
# M_no : 보수의 인식기(∉일 때 언젠가 accept)

Decide(w):
  for t = 1,2,3,...:
    simulate M_yes(w) for t steps; if it accepts: return YES
    simulate M_no (w) for t steps; if it accepts: return NO
```

### 10.2 \(\textsf{A\_TM}\)에서 \(\textsf{NE\_TM}\)으로의 many-one 감소
```text
# 입력 x = <M>#w 에 대해 f(x) = <N_x> 를 구성
N_x(u):
  simulate M(w)
  if M(w) accepts: accept
  else: loop forever
# 올바름: <M>#w ∈ A_TM  ⇔  L(N_x) ≠ ∅  ⇔  <N_x> ∈ NE_TM
```

### 10.3 “정지”에서 “CFG 보편성”으로의 스케치
```text
# f(<M>#w) = <G> 구성 개요:
# - 문자열은 '#'-구분된 계산 테이블 C0#C1#...#Ct
# - G_bad: '잘못된 계산' 유형(i, ii, iii, iv)을 생성하는 규칙군
# - M(w) 수용이면 '올바른 계산' 1개만 제외 → 사실상 Σ* 전체 생성
# - 아니면 보편 실패
```

### 10.4 PCP로의 인코딩(개념)
```text
tiles := {
  # (top_i, bottom_i) 페어로 전이/헤드/기호를 지역검사
  # 시작 타일은 C0(초기구성) 강제, 수용 시 종료 타일 강제
}
# 해(index sequence)가 존재 ⇔ 올바른 수용 계산 존재
```

---

## 11. 연습 문제(생각거리)

1) \(A_{TM}\)에서 **CFG 모호성**으로의 감소 스케치를 제시하라.
   (힌트: 같은 문자열에 대해 “계산/반계산” 두 유도를 강제하는 가젯)
2) 아래 집합의 분류를 하라:
   \(L=\{\langle M\rangle \mid |L(M)|=\infty\}\). (답: 보통 \(\Pi^0_2\)-완전)
3) RE이지만 결정 불가능한 다른 예를 하나 더 들고, **왜 RE인지** 설명하라.
   (예: HALT, “정지” 증거는 유한 시간에 관찰 가능)

---

## 12. 한 페이지 요약

- **계산 가능성**: 함수를 산출할 **수** 있는가?
- **결정 가능성**: 모든 입력에 대해 **Yes/No를 끝까지** 말할 **수** 있는가?
- **정지 문제**: 결정 불가능의 원형.
- **Rice 정리**: “프로그램 의미”에 대한 **비자명 속성**은 일반적으로 **결정 불가능**.
- **감소(변형)**: 불가능을 다른 도메인으로 **전파**하는 실전 기술(인코딩·지역검사·시작/종료 가젯).
- **RE/co-RE/상위 계층**의 구분은 “증거가 **있으면** 보이나? **모두**에 대해 보이나?”를 가늠하게 해 준다.

---

### 부록 A — RE-완전성 증의 표준 틀(의사코드)

```text
# 목표: A_TM ≤m B
# 입력 x = <M>#w 를 B의 인스턴스 f(x)로 바꾸는 계산 가능한 f 구성

reduce_to_B(x):
  parse x as <M>#w
  gadget := encode_TM_and_input_as_local_constraints(M, w)
  return instance_of_B_built_from(gadget)

# 올바름(정직성)
# (⇒) M(w) 수용  → gadget을 충족하는 '해'가 존재 → f(x) ∈ B
# (⇐) f(x) ∈ B   → gadget의 지역 제약에 의해 '올바른 수용 계산'이 반드시 내재 → M(w) 수용
```

---

### 부록 B — 용어 미니 사전
- **RE(c.e.)**: “예면 언젠가 잡히는” 언어(반결정 가능).
- **co-RE**: 보수가 RE인 언어.
- **Recursive(결정 가능)**: 예/아니오를 **언제나 유한 시간에** 결정.
- **many-one 감소**: 단발 변환으로 예↔예, 아니오↔아니오를 맞추는 감수.
- **튜링 감소**: 오라클을 질의하며 답을 사용하는 감수(더 약함).
- **RE-완전**: 모든 RE 문제로부터 many-one 감소가 가능한 “가장 어려운” RE 문제.
