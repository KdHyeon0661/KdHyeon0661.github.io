---
layout: post
title: 형식언어와 오토마타 - 튜링 기계로 해결할 수 없는 문제들
date: 2025-08-05 21:20:23 +0900
category: 형식언어와 오토마타
---
# 튜링 기계로 해결할 수 없는 문제들 — 정지 문제, Rice 정리, 감소 기법 완전 정리

## 0. 들어가며 — “무엇을 계산할 수 있는가” vs “어떤 문제를 판정할 수 있는가”

이 글의 목표는 다음 세 가지다.

1. **계산 가능성(computability)** 과  
   **결정 가능성(decidability)** 의 차이를 **함수 관점 vs 언어 관점**에서 분명히 설명한다.
2. 튜링 기계의 **정지 문제(Halting Problem)** 를 중심으로  
   **결정 불가능(undecidable)** 문제가 왜/어떻게 생기는지,  
   그리고 그와 친척인 여러 문제들의 **분류(RE / co-RE / 더 높은 계층)** 를 정리한다.
3. 이미 알려진 불가능 문제를 **새 문제로 변형(감소)** 하는  
   **실전 레시피**를 예제와 함께 제시해,  
   “새로운 언어/문제의 결정 불가능성을 스스로 증명할 수 있는” 수준까지 이어간다.

핵심 키워드:

- **정지 문제** $$\textsf{HALT}$$
- **언어 버전 정지 문제** $$\textsf{A\_TM}$$
- **Rice 정리** (의미 기반 속성 일반 불가능)
- **대각선 논법(diagonalization)**
- **도베일링(dovetailing)** — 양쪽이 RE면 결정 가능
- **many-one 감소** $$\le_m$$, **튜링 감소** $$\le_T$$
- **RE-완전, co-RE-완전, \(\Pi^0_2\)-완전**

---

## 1. 계산 가능성 vs 결정 가능성

이 절에서는 같은 튜링 기계 모델 위에서

- “**함수**를 계산할 수 있다”와
- “**언어**에 대해 Yes/No를 항상 말해 줄 수 있다”

를 구분한다.

### 1.1 함수 관점 — (총) 계산 가능 vs 부분 계산 가능

알파벳 $$\Sigma$$ 에 대해,  
모든 입력이 유한 문자열인

$$
f : \Sigma^* \to \Sigma^*
$$

를 생각하자.

#### (1) 총 계산 가능한 함수(Computable / Total)

함수 $$f$$ 가 **총(total) 계산 가능** 이라는 뜻은:

> 어떤 튜링 기계 $$M$$ 가 존재해서 **모든 입력**에 대해  
> 유한 시간 내에 **정지**하면서 출력 테이프에 $$f(x)$$ 를 남긴다.

즉, 임의의 문자열 $$x$$ 에 대해

- 기계 $$M$$ 을 시작하면
- 언젠가는 멈추고
- 정확히 $$f(x)$$ 를 출력한다.

#### (2) 부분 계산 가능한 함수(Partial Computable)

많은 실제 프로그램은 어떤 입력에서는 영원히 돌 수도 있다.  
이를 **부분 계산 가능한(partial computable)** 함수로 모델링한다.

$$
\varphi_M(x) =
\begin{cases}
y & \text{(튜링 기계 } M \text{가 입력 } x \text{에서 정지하면서 } y \text{ 출력)} \\
\uparrow & \text{(정지하지 않고 무한 루프)}
\end{cases}
$$

- 여기서 $$\uparrow$$ 표시는 “**정의되지 않음**” / “**무한 루프**” 를 뜻한다.
- $$\varphi_M$$ 는 **모든** 튜링 기계 $$M$$ 에 대해 자동으로 정의되는 함수다.
  - 어떤 입력에서는 값이 있고,
  - 어떤 입력에서는 값이 없다.

> 요약  
> **총 계산 가능한 함수**: 모든 입력에서 정지.  
> **부분 계산 가능한 함수**: 어떤 입력에서는 정지, 어떤 입력에서는 무한 루프.

#### 예: 파이썬 프로그램으로 직관 잡기

```python
def total_f(x: int) -> int:
    # 모든 x에 대해 언젠가 반환
    return x * x  # 제곱

def partial_g(x: int) -> int:
    # x == 0이면 무한 루프
    if x == 0:
        while True:
            pass  # 영원히 루프
    return 1
```

- `total_f`는 **총 계산 가능**: 모든 입력에서 반드시 반환.
- `partial_g`는 **부분 계산 가능**:  
  - $$x \neq 0$$ 인 입력에서는 정지하고 결과 1.  
  - $$x = 0$$ 에서는 결코 정지하지 않는다.

튜링 기계 관점에서는 `partial_g`가 표현하는 함수는 일부 입력에서 **정의되지 않은 값**을 갖는다.

---

### 1.2 언어 관점 — 결정 가능 vs 반결정 가능(RE)

이제 **언어(language)** 로 시선을 옮기자.  
언어는 그저 문자열 집합이다.

$$
L \subseteq \Sigma^*
$$

튜링 기계를 “예/아니오 검사기(decider / recognizer)”로 해석하면 다음 두 계층이 나온다.

#### (1) 결정 가능(Decidable / Recursive) 언어

언어 $$L$$ 이 **결정 가능** 이라는 뜻:

> 어떤 튜링 기계 $$D$$ 가 존재해서,  
> **모든 입력** $$w \in \Sigma^*$$ 에 대해 **항상 정지**하며  
> $$w \in L$$ 이면 **수용(accept)**, $$w \notin L$$ 이면 **거부(reject)** 한다.

- **정지 여부에 대한 불확실성이 없다.**
- 항상 Yes/No를 말해주기 때문에 **디시전 프로시저**를 가진다.

#### (2) 반결정 가능(Semi-decidable / RE / c.e.) 언어

언어 $$L$$ 이 **반결정 가능(RE, recursively enumerable, computably enumerable)** 이라는 뜻:

> 어떤 튜링 기계 $$N$$ 이 존재해서,  
> $$w \in L$$ 이면 언젠가 **수용**하고 정지하지만,  
> $$w \notin L$$ 이면 **무한히 돌 수 있다**.

즉,

- **예(YES)인 경우**: 언젠가 증거를 보여 준다.  
- **아니오(NO)인 경우**:  
  - 영원히 돌 수도 있고,  
  - 중간에 거부하고 끝날 수도 있지만,  
  - “반드시 정지한다”는 보장은 없다.

#### 핵심 등식 — RE와 co-RE가 모두면 결정 가능

다음 사실이 매우 중요하다.

$$
\boxed{
L \text{와 } \overline{L} \text{가 모두 RE} 
\iff
L \text{는 결정 가능(Recursive)}
}
$$

- 앞 방향(⇒): **도베일링(dovetailing)** 기법으로 증명.
- 뒤 방향(⇐): 결정 가능하면,  
  - $$L$$ 도,  
  - 그 보수 $$\overline{L}$$ 도  
  trivially RE가 된다.

#### 도베일링 의사코드

“언젠가는 수용하는 쪽”이 반드시 있으므로,  
두 쪽을 **교대로 조금씩 실행**하면 언젠가 정답이 나온다.

```text
# M_yes : L의 인식기 (w ∈ L이면 언젠가 accept)
# M_no  : 보수의 인식기 (w ∉ L이면 언젠가 accept)

Decide(w):
  for t = 1, 2, 3, ...:
    simulate M_yes(w) for t steps; 
    if M_yes accepts within these t steps:
        return YES

    simulate M_no(w) for t steps;
    if M_no accepts within these t steps:
        return NO
```

- $$w \in L$$ 이면, **어떤 t 이후**에 $$M\_{\text{yes}}$$ 가 수용하고 정지한다.  
  따라서 그 t에서 YES를 반환.
- $$w \notin L$$ 이면, 비슷하게 $$M\_{\text{no}}$$ 가 언젠가 수용하므로 NO를 반환.

> 직관:  
> **RE는 “YES에 대한 유한한 증거가 언젠가 드러나는” 클래스**다.  
> 양쪽(RE & co-RE)이 모두 되면, YES/NO 둘 다 언젠가는 드러나므로 **완전한 판정이 가능**해진다.

---

## 2. 정지 문제(HALTING PROBLEM) — 모든 불가능의 출발점

### 2.1 정지 문제 정의

튜링 기계 $$M$$ 과 입력 $$w$$ 를 인코딩한 문자열을 $$\langle M \rangle \# w$$ 라고 표기하자.  
(여기서 $$\#$$ 는 단순 구분자.)

정지 문제 언어를 다음과 같이 정의한다.

$$
\textsf{HALT} = 
\{
\langle M \rangle \# w
\mid
M \text{ 이 입력 } w \text{ 에서 유한 시간 내 정지}
\}.
$$

> 문제:  
> 임의의 $$\langle M \rangle\#w$$ 가 주어졌을 때,  
> $$M$$ 이 $$w$$ 에서 **정지할지(YES)**,  
> 아니면 **영원히 돌지(NO)** 를 **항상 정확히** 말해주는 기계가 존재하는가?

정답: **그런 기계는 존재하지 않는다**.  
즉, $$\textsf{HALT}$$ 는 **결정 불가능**이다.

하지만, $$\textsf{HALT}$$ 는 **RE**이다.  
왜냐하면 “정지하면 언젠가 그 사실이 드러나기” 때문이다.

- “정지하는 것”은 **유한한 계산 기록로 증명**할 수 있다.
- “정지하지 않는다”는, **유한 시간에는 증명할 수 없다.**

---

### 2.2 정지 문제가 RE임을 보이기

튜링 기계 $$H\_{\text{semi}}$$ 를 다음처럼 설계할 수 있다.

```text
H_semi(⟨M⟩#w):
  simulate M on w
  if M halts:
     accept  # YES
  (halt하지 않으면 H_semi도 계속 돈다)
```

- $$\langle M \rangle\#w \in \textsf{HALT}$$ 인 경우:  
  어느 순간 $$M(w)$$ 가 정지 → $$H\_{\text{semi}}$$ 도 accept 하고 정지.
- $$\langle M \rangle\#w \notin \textsf{HALT}$$ 인 경우:  
  $$M(w)$$ 가 영원히 돌기 때문에, $$H\_{\text{semi}}$$ 도 계속 시뮬레이션만 하며 **정지하지 않을 수도** 있다.

따라서 $$\textsf{HALT}$$ 는 **반결정 가능(RE)** 이다.

---

### 2.3 정지 문제의 결정 불가능성 — 대각선 논법

이제 “**완전한 정지 판별기**”가 있을 수 없다는 것을 보인다.

#### 가정: 완전한 정지 판별기 $$H$$ 존재

$$H$$ 가 다음 성질을 가진다고 **가정**하자.

> 임의의 $$\langle M \rangle\#w$$ 에 대해  
> 항상 유한 시간 내에 정지하며  
> - $$M$$ 이 $$w$$ 에서 정지하면 `"halt"`  
> - 정지하지 않으면 `"loop"`  
> 를 출력.

이제 이 $$H$$ 를 이용해서 새로운 기계 $$D$$ 를 정의한다.

```text
D(x):
  if H(x, x) == "halt" then
      loop forever
  else
      halt
```

- $$D$$ 는 입력 $$x$$ 를 받았을 때,  
  $$H(x, x)$$ 에게 “$$x$$ 를 자기 자신에게 넣었을 때 정지하는가?”를 묻는다.
- $$H(x, x) = \texttt{"halt"}$$ 라면, **일부러** 무한 루프.
- $$H(x, x) = \texttt{"loop"}$$ 라면, **즉시 정지**.

이제 자기 자신을 입력에 넣어 보자.

$$
D(\langle D\rangle)
$$

두 가지 경우를 모두 살펴보면 모순이 된다.

1. 만약

   $$
   H(\langle D\rangle, \langle D\rangle) = \texttt{"halt"}
   $$

   라고 하자.

   - 그러면 정의에 의해 $$D(\langle D\rangle)$$ 는 **무한 루프**해야 한다.
   - 하지만 $$H$$ 는 “정지한다”고 말했으므로,
   - $$D(\langle D\rangle)$$ 는 실제로 **정지해야 한다**는 뜻 → **모순**.

2. 반대로

   $$
   H(\langle D\rangle, \langle D\rangle) = \texttt{"loop"}
   $$

   라고 하자.

   - 그러면 정의에 의해 $$D(\langle D\rangle)$$ 는 **즉시 정지**한다.
   - 하지만 $$H$$ 는 “정지하지 않는다”고 말했으므로
   - $$D(\langle D\rangle)$$ 는 **정지하지 않아야 한다** → **모순**.

둘 다 모순이다.  
따라서 **그런 $$H$$는 존재할 수 없다**.

> 결론  
> $$\textsf{HALT}$$ 는 **RE**이지만,  
> **결정 가능하게 만들 수는 없다**.  
> 즉, **RE이면서 결정 불가능인 대표적인 문제**다.

---

### 2.4 언어 버전: 수용 문제 $$\textsf{A\_TM}$$

정지 여부 대신, **수용 여부**를 묻는 언어도 자주 쓴다.

$$
\textsf{A\_TM} =
\{
\langle M \rangle \# w
\mid
M \text{ 이 입력 } w \text{를 수용(accept)}
\}
$$

- $$\textsf{A\_TM}$$ 은 **RE-완전**이고,  
  마찬가지로 **결정 불가능**이다.
- $$\textsf{A\_TM}$$ 을 통해 다른 많은 문제가 **감소(reduction)** 로  
  결정 불가능하다는 것을 증명한다.

---

## 3. 친척 문제들: 공백성, 비공백성, 보편성 등

정지 문제와 긴밀히 연결된 대표 언어들을 정리해 보자.

### 3.1 대표 언어들 정의

- 수용 문제(앞에서 본 것):

  $$
  \textsf{A\_TM} = \{\langle M \rangle\#w \mid M(w) \text{ 를 수용}\}
  $$

- 그 보수:

  $$
  \overline{\textsf{A\_TM}} = \{\langle M \rangle\#w \mid M(w) \text{ 를 수용하지 않음}\}
  $$

- 공백성(emptiness):

  $$
  \textsf{E\_TM} = \{\langle M \rangle \mid L(M) = \varnothing\}
  $$

- 비공백성(non-emptiness):

  $$
  \textsf{NE\_TM} = \{\langle M \rangle \mid L(M) \neq \varnothing\}
  $$

- 모든 입력에서 정지(totality):

  $$
  \textsf{TOT} = \{\langle M \rangle \mid \forall w,\, M(w) \downarrow \}
  $$

- 보편성(universality):

  $$
  \textsf{ALL\_TM} = \{\langle M \rangle \mid L(M) = \Sigma^*\}
  $$

여기서 $$M(w) \downarrow$$ 는 “$$M(w)$$ 가 정지한다”는 뜻이다.

### 3.2 분류 요약 표

| 문제 | 정의 요약 | 분류(요지) |
|------|-----------|------------|
| $$\textsf{A\_TM}$$ | “$$M(w)$$ 를 수용하는가?” | **RE-완전**, 결정 불가능 |
| $$\overline{\textsf{A\_TM}}$$ | “수용하지 않는가?” | **co-RE**, RE는 아님, 결정 불가능 |
| $$\textsf{E\_TM}$$ | $$L(M)=\varnothing$$ 인가? | **co-RE-완전**, 결정 불가능 |
| $$\textsf{NE\_TM}$$ | $$L(M)\neq\varnothing$$ 인가? | **RE-완전**, 결정 불가능 |
| $$\textsf{TOT}$$ | 모든 입력에서 정지? | 보통 **\(\Pi^0_2\)-완전**, RE도 co-RE도 아님 |
| $$\textsf{ALL\_TM}$$ | $$L(M)=\Sigma^*$$ ? | 역시 **\(\Pi^0_2\)-완전**, RE도 co-RE도 아님 |

이 글에서는 특히

- $$\textsf{NE\_TM}$$ 이 왜 **RE-완전**인지,
- $$\textsf{E\_TM}$$ 이 왜 **co-RE-완전**인지,

를 감소 예제로 자세히 본다.

---

## 4. 결정 불가능의 범용 도구: Rice 정리, 대각선, 도베일링

### 4.1 Rice 정리 — “의미 기반 속성은 다 불가능하다”

먼저 용어를 정리하자.

- 각 튜링 기계 $$M$$ 는 부분 계산 가능한 함수 $$\varphi_M$$ 를 정의한다.
- 프로그램이 다르더라도 **같은 부분 함수** $$\varphi$$ 를 계산할 수 있다.

이제 “프로그램의 의미(계산하는 함수)만 보고 판단되는 속성”을 생각해 보자.

- 예: “언어가 정규인가?”, “언어가 공백인가?”, “언어가 유한인가?”,  
  “언어가 특정 문자열을 포함하는가?”, “언어가 보편인가?”, …

**Rice 정리:**

> **부분 계산 가능한 함수의 비자명한 의미 속성은 모두 결정 불가능이다.**

좀 더 구체적으로:

- 어떤 속성 $$P$$ 를 생각하자.
- $$P$$ 는 각 프로그램(튜링 기계)에 대해 **참/거짓**을 말하는 조건이다.
- 다음을 만족한다고 하자.
  1. $$P$$ 는 **의미(함수)** 만을 본다.  
     즉, $$\varphi_{M_1} = \varphi_{M_2}$$ 이면  
     $$M_1, M_2$$ 에 대한 $$P$$ 값이 같다.
  2. $$P$$ 가 **비자명**하다.  
     - $$P$$ 를 만족하는 프로그램도 **적어도 하나** 존재하고,
     - $$P$$ 를 만족하지 않는 프로그램도 **적어도 하나** 존재.

그러면 $$P$$ 를 일반적으로 **결정(decide)** 하는 튜링 기계는 **존재하지 않는다.**

#### 예: Rice 정리가 적용되는 대표 속성들

- “언어 $$L(M)$$ 이 **정규언어**인가?”
- “언어 $$L(M)$$ 이 **문맥자유 언어**인가?”
- “언어 $$L(M)$$ 이 **공백**인가? (empty)”
- “언어 $$L(M)$$ 이 **유한**인가? (finite)”
- “언어 $$L(M)$$ 이 **무한**인가? (infinite)”
- “두 기계 $$M_1, M_2$$ 에 대해 $$L(M_1) = L(M_2)$$ 인가?” (등가성)
- “기계 $$M$$ 이 언어 $$L_0$$ 를 인식하는가?” 같은 구체적 의미 속성도 대부분 여기에 포함.

> 직관적 요약  
> “**프로그램이 무엇을 하는지**(실행 의미)를 완전히 이해해서  
> 그에 대한 비자명한 속성을 **항상** 판정하는 것은 불가능하다.”

이 정리가 바로 **정적 분석, 최적화, 프로그램 검증** 등 실무 분야에서  
“완벽한 도구는 불가능”한 이유를 이론적으로 설명한다.

---

### 4.2 대각선(Diagonalization) — 집합/함수 버전

정지 문제의 증명도 대각선의 한 버전이다.  
여기에서는 좀 더 **추상적인 형태**를 정리한다.

#### 집합 버전: 자기입력 정지 집합

모든 튜링 기계에 번호를 붙였다고 하자.

- $$M_0, M_1, M_2, \ldots$$  
- 각 기계는 코드 번호 $$e \in \mathbb{N}$$ 를 가진다고 생각.

다음 집합을 생각한다.

$$
K = \{ e \mid \varphi_e(e) \downarrow \}
$$

- $$\varphi_e(e) \downarrow$$ : “번호 $$e$$를 가진 기계가 자기 번호 $$e$$ 를 입력받았을 때 정지한다.”
- $$K$$ 는 “자기 자신을 입력으로 넣었을 때 정지하는 기계 번호들의 집합”이다.

이 $$K$$ 는 **RE-완전**이며, 결정 불가능이다.  
(정지 문제와 거의 같은 수준의 난이도.)

#### 함수 버전: Busy Beaver, Kolmogorov 복잡도

- **Busy Beaver 함수** $$\Sigma(n)$$:
  - 상태 수가 $$n$$ 인 튜링 기계 중,  
    공백 테이프에서 시작해서 정지할 때까지  
    **최대로 많은 1을 남길 수 있는 기계가 남기는 1의 개수**.
  - 이 함수 $$\Sigma(n)$$ 는 **어떠한 총 계산 가능한 함수보다 빠르게 증가**하며,  
    **계산 불가능**하다.

- **Kolmogorov 복잡도** $$K(x)$$:
  - 어떤 고정된 범용 튜링 기계 $$U$$ 에 대해,  
    $$U(p) = x$$ 가 되도록 하는 프로그램 $$p$$ 의 **최소 길이**.
  - $$K(x)$$ 는 **계산 불가능**하다.  
    (만약 계산 가능하다면 “스스로 압축 불가능한 문자열”을 알고리즘적으로 찾는 역설이 생긴다.)

이러한 함수/집합들의 비계산성 증명도 **대각선 아이디어**를 사용한다.

---

### 4.3 도베일링(Dovetailing) — “양쪽이 RE면 결정 가능”

앞에서 잠깐 본 것처럼, RE와 co-RE가 동시에 되는 경우,  
도베일링으로 **결정 가능**함을 보일 수 있다.

다시 한번 구조를 강조해 보자.

- $$L$$ 이 RE → 어떤 인식기 $$M\_{\text{yes}}$$ 존재:
  - $$w \in L$$ 이면 언젠가 수용.
  - $$w \notin L$$ 이면 무한 루프 가능.
- $$\overline{L}$$ 도 RE → 인식기 $$M\_{\text{no}}$$ 존재:
  - $$w \notin L$$ 이면 언젠가 수용.
  - $$w \in L$$ 이면 무한 루프 가능.

이제 **둘을 교대로 돌리면**:

- 둘 중 하나는 반드시 “자기 케이스”에서 언젠가 수용.
- 그걸 보는 즉시 YES/NO를 결정.

도베일링은 나중에  
- “RE인지 아닌지”,  
- “co-RE인지 아닌지”  
판별하는 데도 중요한 도구다.

---

## 5. 감소(Reduction) — 불가능을 새 문제로 전파하는 기법

새로운 문제의 결정 불가능성을 증명할 때 핵심 도구는 **감소(reduction)** 이다.

### 5.1 many-one 감소(머신 하나로 변환하는 정직한 매핑)

언어 $$A, B \subseteq \Sigma^*$$ 에 대해,

> **many-one 감소** $$A \le_m B$$  
> : 어떤 총 계산 가능한 함수 $$f: \Sigma^* \to \Sigma^*$$ 가 존재해서  
> $$x \in A \iff f(x) \in B$$ 를 만족한다.

이때

- $$f$$ 는 항상 유한 시간에 계산된다.
- “예/아니오”가 **보존**된다:
  - YES → YES,
  - NO  → NO.

따라서, 만약 $$B$$ 가 결정 가능하다고 하면:

- $$A$$ 에 대한 결정기는

  ```text
  Decide_A(x):
    y := f(x)
    return Decide_B(y)
  ```

  로 만들 수 있다.

> 따라서  
> **$$A$$가 결정 불가능**이고 $$A \le_m B$$ 라면  
> **$$B$$ 역시 결정 불가능**이다.

또한, 모든 RE 문제에서 $$\le_m$$으로 감소가 들어오는 최상위 난이도의 문제를  
**RE-완전(RE-complete)** 이라고 부른다.  
$$\textsf{A\_TM}$$, $$\textsf{HALT}$$ 등이 그 예다.

---

### 5.2 튜링 감소(Turing Reduction) — 오라클을 사용하는 더 약한 감소

many-one 감소보다 더 일반적인 개념이 **튜링 감소**다.

> $$A \le_T B$$ :  
> “$$B$$ 에 대한 **오라클(oracle)** 을 사용할 수 있는 튜링 기계가  
> $$A$$ 를 계산 가능하게 만든다.”

- 오라클: “질문 문자열이 $$B$$ 에 속하는가?”를 한 번에 알려주는 **블랙박스**.
- many-one 감소는 “오라클 호출은 딱 한 번, 마지막에”인 특수한 경우로 볼 수 있다.

이 글의 대부분 예제는 **many-one 감소**로 충분하다.  
튜링 감소는 **상위 계층(예: \(\Pi^0_2\)-완전성)** 을 다룰 때 자연스럽게 등장한다.

---

### 5.3 실전 레시피 요약

새 undecidable 문제를 만들 때, 전형적인 패턴은 다음과 같다.

1. **출발점 선택**  
   - $$\textsf{A\_TM}$$, $$\textsf{HALT}$$, **PCP** 같이 **이미 알려진 불가능 문제**를 하나 고른다.

2. **인코딩(encoding)**  
   - 주어진 인스턴스(예: $$\langle M \rangle\#w$$)를  
     목표 도메인의 인스턴스(예: CFG, 오토마타, 타일, 방정식, 그래프…)로 계산 가능하게 변환하는 함수 $$f$$ 를 설계한다.

3. **정직성(soundness)** 확인  
   - “예일 때 예가 되고, 아니오일 때 아니오가 되도록” 보장해야 한다.
   - 즉,

     $$
     x \in A \iff f(x) \in B
     $$

     가 정확히 성립하는지 전체 논리를 체크한다.

4. **지역→전역 가젯 설계**  
   - 계산을 문자열/타일/그래프 등에 인코딩할 때,  
     “로컬 규칙”만으로 “전역적으로 올바른 계산”을 강제하는 작은 구성요소(가젯)를 설계한다.
   - 예: 구분자 `#`, 시작/종료 마커, 인접 셀 검사, 복사 제약 등.

---

## 6. worked example 1 — $$\textsf{A\_TM} \le_m \textsf{NE\_TM}$$

언어 $$\textsf{NE\_TM}$$:

$$
\textsf{NE\_TM} = \{\langle N \rangle \mid L(N) \neq \varnothing\}
$$

즉, “어떤 입력이든 **하나라도 수용하는** 튜링 기계인가?”를 묻는 문제.

이를 $$\textsf{A\_TM}$$ 에서 many-one 감소로 얻어 RE-완전성을 보이자.

### 6.1 감소 정의

입력으로 $$x = \langle M \rangle\# w$$ 가 주어졌다고 하자.

우리는 $$x$$ 로부터 새로운 튜링 기계 $$N_x$$ 를 구성할 것이다.

아이디어:

> $$M(w)$$ 가 수용하면, $$N_x$$ 는 **모든 입력을 수용**하게 만들고,  
> 그렇지 않으면 **어떤 입력도 수용하지 않도록** 만든다.

정의:

```text
N_x(u):                      # u는 N_x의 입력이지만 실제로는 사용하지 않는다
  simulate M on input w
  if M(w) accepts:
      accept                # 모든 u에 대해 수용
  else:
      loop forever          # 어떤 u도 수용하지 않음
```

이제 두 방향을 살펴보자.

#### (⇒) $$\langle M \rangle\#w \in \textsf{A\_TM}$$ 이라면

- 즉, $$M(w)$$ 가 수용한다고 가정.
- 그러면 $$N_x(u)$$ 는 어떤 입력 $$u$$ 를 넣어도
  - 시뮬레이션에서 $$M(w)$$ 가 수용하는 순간  
    $$N_x$$ 도 즉시 수용한다.
- 따라서 $$L(N_x) = \Sigma^*$$ 이고, 특히 **공백이 아니다**.
- 즉,

  $$
  \langle M \rangle\#w \in \textsf{A\_TM} \Rightarrow \langle N_x \rangle \in \textsf{NE\_TM}
  $$

#### (⇐) $$\langle N_x \rangle \in \textsf{NE\_TM}$$ 이라면

- 즉, $$L(N_x)\neq\varnothing$$ 이라고 가정.
- 그러면 어떤 입력 $$u_0$$ 에 대해

  $$
  N_x(u_0) \text{ 가 수용한다.}
  $$

- $$N_x$$ 의 정의상, 이는 **시뮬레이션된 $$M(w)$$ 가 수용한다는 뜻**이다.
- 따라서 $$\langle M \rangle\#w \in \textsf{A\_TM}$$.

종합하면,

$$
\langle M \rangle\#w \in \textsf{A\_TM}
\iff
\langle N_x \rangle \in \textsf{NE\_TM}.
$$

또한 $$x \mapsto \langle N_x \rangle$$ 는 명백히 **계산 가능한 함수**이다.  
따라서

$$
\textsf{A\_TM} \le_m \textsf{NE\_TM}
$$

이고, $$\textsf{A\_TM}$$ 가 RE-완전, 결정 불가능이므로  
$$\textsf{NE\_TM}$$ 도 **RE-완전, 결정 불가능**이다.

보수 $$\textsf{E\_TM}$$ 는 자연스럽게 **co-RE-완전, 결정 불가능**이 된다.

---

## 7. worked example 2 — CFG 보편성(Universality)의 결정 불가능성 (스케치)

이번에는 튜링 기계 정지/수용 문제를 **문맥자유문법(CFG)** 의 보편성 문제로 옮긴다.

> CFG 보편성 문제:  
> 주어진 CFG $$G$$ 와 알파벳 $$\Sigma$$ 에 대해  
> $$L(G) = \Sigma^*$$ 인지 판정할 수 있는가?

정답: **일반적으로는 결정 불가능**이다.

### 7.1 아이디어: “잘못된 계산들만 생성하는 CFG”

입력으로 $$x = \langle M \rangle\#w$$ 가 주어졌다고 하자.

우리는 CFG $$G_x$$ 를 만들어서 다음을 만족시키려고 한다.

- 만약 $$M(w)$$ 가 수용한다면,  
  $$G_x$$ 가 생성하지 못하는 문자열은 “단 하나의 올바른 계산 기록” 뿐이고,  
  나머지는 모두 생성 → 사실상 $$\Sigma^*$$ 전체.
- 반대로 $$M(w)$$ 가 수용하지 않는다면,  
  “올바른 계산 기록” 자체가 없으므로  
  $$G_x$$ 는 보편이 아니다.

이를 위해 보통 다음 전략을 쓴다.

1. **계산 테이블 인코딩**  
   - 튜링 기계의 각 **구성(configuration)** 을 문자열로 표현:  
     상태, 테이프 내용, 헤드 위치 등을 하나의 문자열로.
   - 계산 전체를  
     $$C_0 \# C_1 \# \cdots \# C_t$$  
     같은 형태로 표현.
   - 여기서 $$C_0$$ 는 초기 구성, $$C_t$$ 는 수용 구성(accepting configuration)이어야 한다.

2. “**잘못된 계산**”을 생성하는 CFG $$G\_{\text{bad}}$$ 를 설계  
   - 잘못된 형태의 문자열을 생산:
     - 형식 자체가 틀림(구성 길이/구분자 위치 오류)
     - 인접한 구성 $$C_i, C_{i+1}$$ 가 튜링 기계 전이 규칙을 위반
     - 처음 구성이 초기 입력 $$w$$ 를 반영하지 않음
     - 마지막 구성에 수용 상태가 나타나지 않음
   - 즉, “올바른 계산 테이블”이 아니면 모조리 생성하도록 만든다.

3. 두 경우를 비교  
   - **수용하는 경우**:  
     올바른 계산 테이블 문자열이 정확히 **하나** 존재한다.  
     $$G\_{\text{bad}}$$ 는 그 외 모든 문자열을 생성.  
     이에 약간의 구성을 덧붙여, **사실상 모든 문자열을 생성하는 CFG** 를 만든다.
   - **수용하지 않는 경우**:  
     올바른 계산 테이블이 아예 없으므로,  
     $$G\_{\text{bad}}$$ 가 생성하지 못하는 문자열이 많게 남는다 → 보편성 실패.

이 인코딩과 “잘못된 계산 검출 가젯”의 구체 구현은 비교적 복잡하지만,  
Rice 정리와 달리 CFG처럼 **의미가 언어 구조에 있는 특수 모델**에 대해  
정지 문제 난이도를 이동시키는 좋은 예이다.

핵심은:

- **계산 전체를 문자열로 인코딩**
- “로컬 전이 검사를 문법 규칙으로 실현”
- “정확히 ‘올바른 계산’ 케이스만 누락되게” 문법을 설계

라는 패턴이다.

---

## 8. PCP(Post Correspondence Problem) — 또 다른 RE-완전 문제

**PCP** 는 형식 언어 이론에서 자주 쓰이는 RE-완전 문제이다.

### 8.1 PCP 정의(요약)

- 알파벳 $$\Sigma$$ 위의 문자열 쌍들

  $$
  (u_1, v_1), (u_2, v_2), \ldots, (u_k, v_k)
  $$

  가 주어진다.

- 정수 열 $$i_1, i_2, \ldots, i_m$$ (각각 $$1 \le i_j \le k$$) 이 있어서,

  $$
  u_{i_1} u_{i_2} \cdots u_{i_m}
  =
  v_{i_1} v_{i_2} \cdots v_{i_m}
  $$

  를 만족하는가?

- 이런 열이 존재하면 **해(solution)** 가 있다고 말한다.

> PCP:  
> 주어진 타일 집합에 대해 **해가 존재하는지** 묻는 문제는  
> **RE-완전, 결정 불가능**이다.

### 8.2 TM → PCP 감소 개략

튜링 기계 $$M$$ 과 입력 $$w$$ 에 대해,  
“$$M(w)$$ 가 수용하는가?”를 PCP 인스턴스로 감소하는 아이디어는 다음과 같다.

1. **계산 테이블 인코딩**  
   - 위아래 두 행에 계산을 쌓아 올리면서,  
     각각의 열이 전이 규칙에 맞게 이어지도록 타일을 설계한다.

2. **시작 강제**  
   - 첫 타일이 반드시 초기 구성 $$C_0$$ 을 나타내도록 한다.

3. **전이 지역 검사**  
   - 인접 셀들의 값이 튜링 기계의 전이 규칙을 만족하도록  
     타일 경계 색/문자 패턴을 조합한다.

4. **수용 강제**  
   - 수용 상태에 도달하지 않으면 전체 위아래 문자열이 끝까지 같아질 수 없게 한다.

그러면

- $$M(w)$$ 가 수용하면, 올바른 계산 테이블을 따라가는 타일 열이 존재 → PCP 해 존재.
- 수용하지 않으면, 어떠한 타일 열도 두 행을 같게 만들 수 없음 → PCP 해 없음.

PCP는 CFG/타일/그래프 등 다양한 구조로 감소를 이어가기 좋은 **매개 문제**다.

---

## 9. 산술 계층(Arithmetical Hierarchy) — RE / co-RE를 넘어

정지 문제와 그 변형들은 **산술 계층(arithmetical hierarchy)** 에서 위치가 다르다.

### 9.1 정의 스케치

결정 가능한 술어 $$R(x, y, \ldots)$$ 를 사용하여  
언어를 1차 논리 형태로 표현한다고 하자.

- $$\Sigma^0_1$$ ( = RE ) 형식:

  $$
  x \in L \iff \exists t\, R(x, t)
  $$

  여기서 $$R$$ 은 결정 가능 술어.

- $$\Pi^0_1$$ ( = co-RE ) 형식:

  $$
  x \in L \iff \forall t\, R(x, t)
  $$

- $$\Sigma^0_2$$, $$\Pi^0_2$$ 등은 양화자가 두 단계 이상 섞인 형태:

  - $$\Sigma^0_2$$:  
    $$x \in L \iff \exists t_1\, \forall t_2\, R(x, t_1, t_2)$$
  - $$\Pi^0_2$$:  
    $$x \in L \iff \forall t_1\, \exists t_2\, R(x, t_1, t_2)$$

등등.

### 9.2 예: 정지 문제와 TOT, ALL\_TM

- $$\textsf{HALT}, \textsf{A\_TM}$$:
  - “정지하는 순간이 **언젠가** 존재한다.”
  - 즉,

    $$
    \langle M \rangle\#w \in \textsf{HALT}
    \iff
    \exists t\, R(\langle M \rangle, w, t)
    $$

    형태로 쓸 수 있어 **\(\Sigma^0_1\)** (RE)에 속한다.

- $$\textsf{TOT}$$:
  - “모든 입력에서 정지한다.”
  - 즉,

    $$
    \langle M \rangle \in \textsf{TOT}
    \iff
    \forall w\, \exists t\, R(\langle M \rangle, w, t)
    $$

    꼴로 표현 가능 → **\(\Pi^0_2\)** 에 속하는 것이 자연스럽다.

- $$\textsf{ALL\_TM}$$ (보편성):  
  - “모든 입력 $$w$$ 에 대해, $$M$$ 이 $$w$$ 를 수용한다”는 식으로  
    역시 **\(\Pi^0_2\)** 계층에 위치하게 된다.

이처럼 단순한 정지/수용 여부를 넘어서 “모든 입력에 대해 ~~” 같은 문장을 표현하면  
한 단계 위인 **\(\Pi^0_2\)** 로 올라가고,  
그 단계에서 역시 **완비성(완전성)** 개념이 등장한다.

---

## 10. 실무 감각 — 프로그램 분석/검증에서의 한계와 전략

이제 이 모든 이론이 **실제 프로그래밍 세계**에서 어떤 의미를 갖는지 연결해 보자.

### 10.1 Rice 정리가 의미하는 것

다시 정리하면:

> “프로그램이 계산하는 **의미(함수)** 에 기반한  
> 비자명한 속성을 **완전히 자동으로** 판정하는 것은 불가능하다.”

실무에서는 이런 질문이 여기에 해당한다.

- “이 프로그램은 **항상 배열 경계 안에서만 접근**하는가?”
- “이 스레드 시스템은 **데드락에 빠지지 않는가?**”
- “이 루프는 **항상 정지하는가?**”
- “이 함수는 **비밀 정보(키, 토큰 등)** 를 외부로 절대 새지 않는가?”

이 모든 것은

- 어떤 입력에서는 무한 루프,
- 어떤 입력에서는 다른 행동,

등을 고려해야 하는 **전역 의미 속성**이다.  
일반적인 Turing-complete 언어에서는 이들이 모두 **결정 불가능**하다.

### 10.2 회피 전략

실무 도구들은 다음과 같은 “타협”으로 이 한계를 우회한다.

1. **언어/모델 제한**  
   - 정규 언어, 문맥자유 언어, 제한된 형식 시스템 등  
     튜링 완전성을 일부 포기한 모델 위에서는 많은 속성이 결정 가능해진다.
   - 예: **총함수 언어(termination이 보장되는 언어)** 같은 연구.

2. **보수적 근사(Conservative Approximation)**  
   - 정적 분석 도구는 대개 “경고를 많이 주더라도 놓치지 않는 쪽”을 택한다.
   - 즉, **거짓 양성(false positive)** 을 허용하고,  
     거짓 음성(false negative)을 최소화하려고 한다.

3. **시간/리소스 제한 + 휴리스틱**  
   - 분석에 시간 제한을 두고, 일정 시간 안에 확신이 안 서면  
     “모르겠다”, “위험할 수 있다” 등으로 보고한다.

4. **증명 책임 이동**  
   - 타입 시스템, 계약(contracts), 어노테이션…을 통해  
     개발자가 명시적으로 “이 속성이 유지됨을 보장”하는 증거를 코딩하도록 한다.
   - 검증 도구는 이 증거가 논리적으로 일관되는지 확인(형식 검증).

이 모든 전략은 **튜링 기계 수준에서의 불가능성**을  
실무 시스템 설계에서 **구체적인 설계 제약/정책**으로 바꿔 해석한 것이다.

---

## 11. 코드 스니펫: RE 언어 인식, 도베일링, TM 시뮬레이터 스켈레톤

마지막으로 이론을 코드 감각과 연결하기 위해 간단한 스니펫들을 보자.

### 11.1 RE 언어 인식기 — 정지할 때만 YES

```python
# "정지하면 accept" 를 구현한 아주 단순한 형태
# 실제로는 튜링 기계 시뮬레이터가 들어가야 한다.

def recognizer_HALT(M, w, step_limit=None):
    """
    M: 어떤 '프로그램' 객체 (튜링 기계라고 생각)
    w: 입력
    step_limit: None이면 무제한, 아니면 정해진 스텝만 돌고 종료

    반환값:
      - True  : M(w)가 주어진 step_limit 안에서 정지했다고 관찰된 경우
      - False : 아직 정지 안 했거나, step_limit이 지나서 판단 불가
    """
    steps = 0
    state = M.initial_state(w)
    while step_limit is None or steps < step_limit:
        if state.is_halted():
            return True
        state = M.next(state)
        steps += 1
    return False  # 아직 모름(무한히 돌 수도 있음)
```

- step_limit을 점점 늘려 가며 호출하면 “**정지하는 경우 언젠가는 True**” 를 얻는다.
- 그러나 정지하지 않는 경우는 영원히 False만 보고 있을 수 있다 → RE의 전형적인 모습.

### 11.2 도베일링의 구현 감각(의사코드)

```text
# M_yes, M_no : 두 프로그램(튜링 기계)
# step(M, state): M을 한 스텝 실행한 새 상태

Decide(w):
  state_yes := (M_yes의 초기 상태 with input w)
  state_no  := (M_no 의 초기 상태 with input w)

  for t = 1,2,3,... :
      # yes 쪽을 t스텝만큼 더 진행
      repeat t times:
          if state_yes is halted and accepted:
              return YES
          else if state_yes is halted and rejected:
              break  # 더 돌릴 수 없음
          else:
              state_yes := step(M_yes, state_yes)

      # no 쪽을 t스텝만큼 더 진행
      repeat t times:
          if state_no is halted and accepted:
              return NO
          else if state_no is halted and rejected:
              break
          else:
              state_no := step(M_no, state_no)
```

이 구조는  
양쪽이 RE인 경우 **무한 루프에 빠지지 않고**  
언젠가 YES 또는 NO를 반환한다.

---

## 12. 연습 문제와 생각거리

마지막으로 이 글의 내용을 스스로 정리해 보기 위한 문제들을 모았다.

1. **자기입력 정지 집합 $$K$$**
   - $$K = \{ e \mid \varphi_e(e) \downarrow \}$$ 가 RE-완전임을  
     정지 문제에서의 감소로 설명해 보라.

2. **$$\overline{\textsf{A\_TM}}$$ 가 RE가 아님을 보이기**
   - 만약 $$\overline{\textsf{A\_TM}}$$ 이 RE라고 가정하면,  
     $$\textsf{A\_TM}$$ 과 함께 양쪽 모두 RE가 되어  
     $$\textsf{A\_TM}$$ 이 결정 가능해지는 모순을 상세히 적어 보라.

3. **다른 RE-완전 문제 찾기**
   - $$\textsf{HALT}$$, $$\textsf{A\_TM}$$, PCP 외에  
     자신이 아는 RE-완전 문제 하나를 고르고,  
     왜 RE인지, 왜 결정 불가능인지의 직관을 써 보라.

4. **CFG 모호성(Ambiguity) 문제 감소 스케치**
   - 입력 $$\langle M \rangle\#w$$ 에서 CFG $$G$$ 를 만들어,
     $$M(w)$$ 가 수용하는지 여부가 $$G$$ 의 모호성과 연결되도록  
     아이디어를 정리해 보라.

5. **산술 계층에서의 위치**
   - $$\textsf{E\_TM}$$, $$\textsf{NE\_TM}$$, $$\textsf{ALL\_TM}$$ 의 정의를  
     $$\exists, \forall$$ 양화자와 결정 가능한 술어 $$R$$을 써서 미리 형태를 써 보고,  
     각각이 어느 계층(\(\Sigma^0_1\), \(\Pi^0_1\), \(\Pi^0_2\), …)에 자연스럽게 속하는지 논의해 보라.

---

## 13. 한 페이지 요약

- **계산 가능성(Computability)**  
  - 함수 관점: 튜링 기계가 모든 입력에 대해 결과를 낼 수 있는가?  
  - 총 계산 가능한 함수 vs 부분 계산 가능한 함수.

- **결정 가능성(Decidability)**  
  - 언어 관점: 주어진 문자열에 대해 항상 유한 시간 안에 Yes/No를 결정할 수 있는가?

- **정지 문제(HALTING PROBLEM)**  
  - $$\textsf{HALT}=\{\langle M \rangle\#w \mid M(w) \text{ 정지}\}$$  
  - RE이지만 **결정 불가능**.  
  - 언어 버전 $$\textsf{A\_TM}$$ 역시 RE-완전, 결정 불가능.

- **Rice 정리**  
  - “프로그램이 계산하는 의미(부분 함수)에 대한 비자명한 속성은 모두 결정 불가능.”  
  - 정규성, 공백성, 유한성, 등가성 등 **의미 기반 전체 속성**은 일반적으로 판정 불가.

- **대각선, Busy Beaver, Kolmogorov 복잡도**  
  - 자기참조/대각선으로 비계산 함수·집합을 구성할 수 있다.

- **도베일링**  
  - $$L$$과 $$\overline{L}$$이 모두 RE면, 도베일링으로 $$L$$이 결정 가능.  
  - 따라서 RE이지만 보수가 RE가 아닌 언어(예: $$\textsf{A\_TM}$$)가 존재한다.

- **감소(reduction)**  
  - many-one 감소 $$\le_m$$: “예↔예, 아니오↔아니오 를 보전하는 계산 가능한 변환”.  
  - $$A$$ 가 결정 불가능이고 $$A \le_m B$$ 이면, $$B$$도 결정 불가능.  
  - RE-완전성: 모든 RE 언어에서 many-one 감소가 들어오는 언어.

- **산술 계층(Arithmetical Hierarchy)**  
  - $$\Sigma^0_1$$ = RE, $$\Pi^0_1$$ = co-RE.  
  - “모든 입력에서 ~~” 같은 전칭-존재 패턴은 \(\Pi^0_2\) 등 상위 계층으로 올라간다.

- **실무적 함의**  
  - 튜링 완전 언어의 일반 프로그램에 대해  
    “항상 정지하는가?”, “항상 안전한가?” 같은 전역 속성을  
    완전히 자동으로 판정하는 것은 불가능.  
  - 대신 제한된 언어, 보수적 근사, 휴리스틱, 형식 검증, 타입 시스템 등을 통해  
    현실적인 수준에서 **부분적인 보장**을 얻는다.

---

이 글의 내용은 형식 언어와 오토마타 이론에서의 “상한선”을 알려준다.  
어떤 지점부터는 **도구가 아무리 똑똑해도 완벽해질 수 없다는 것**을 인정해야 한다.  
그 위에서 설계자는 “어디까지 기계를 믿고, 어디부터 사람과 규율을 동원할지”를 결정하게 된다.  
튜링 기계로 해결할 수 없는 문제들을 공부하는 이유가 바로 여기에 있다.