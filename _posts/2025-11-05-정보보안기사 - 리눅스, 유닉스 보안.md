---
layout: post
title: 정보보안기사 - 리눅스/유닉스 보안
date: 2025-11-05 22:25:23 +0900
category: 정보보안기사
---
# 리눅스/유닉스 보안(계정/권한/SELinux/AppArmor, sudo, systemd 하드닝)

## 0) 큰그림(One-Page)

- **계정/권한**: 최소권한, 서비스 계정 분리, 비대화형/대화형 로그온 분리, 암호/잠금/회전, 키 기반 SSH.  
- **파일/권한 모델**: 소유·그룹·모드 + ACL + 특수비트(SUID/SGID/Sticky) + Capability + 마운트 옵션(noexec,nodev,nosuid).  
- **MAC(강제 접근제어)**: SELinux(Type Enforcement, Booleans, Context) 또는 AppArmor(프로파일 기반).  
- **sudo**: 최소 명령 위임, iolog/ts 로그, secure_path, 환경 정리, TTY·Timestamp, Drop-in 관리(`/etc/sudoers.d`).  
- **systemd**: `NoNewPrivileges`, `CapabilityBoundingSet`, `PrivateTmp`, `ProtectSystem=strict`, `ProtectHome`, `MemoryDenyWriteExecute`,  
  `RestrictSUIDSGID`, `RestrictAddressFamilies`, `SystemCallFilter`, `ReadOnlyPaths/ReadWritePaths`, `IPAddressDeny/Allow`, `DynamicUser`.

---

# 1) 계정·권한(Identity & Access)

## 1.1 원칙(Policy)

- **업무 계정 ≠ 관리자 계정**: 승격 필요 시 `sudo`로 작업.  
- **서비스 계정 전용화**: 각 데몬/앱 별 별도 계정, 홈·쉘 제한(`/usr/sbin/nologin`).  
- **암호 정책**: 최소 길이·복잡성·재사용 금지·잠금(실패 n회)·최대 사용기간.  
- **SSH**: 루트 로그인 금지, 비밀번호 인증 금지(키만), 배스천 IP만 허용.  
- **정기 검토**: 휴면·퇴사·전환 계정 비활성, 불필요 그룹 탈퇴.

---

## 1.2 계정 생성·수정·잠금(예제)

### (A) 사용자·그룹
```bash
# 일반 사용자
sudo useradd -m -s /bin/bash devuser
echo "devuser:Init@1234" | sudo chpasswd

# 서비스 계정(비대화형)
sudo useradd -r -s /usr/sbin/nologin -d /var/lib/myapp -M myapp

# 그룹 및 속한 사용자
sudo groupadd webgrp
sudo usermod -aG webgrp devuser
id devuser
```

### (B) 만료·잠금·암호 수명(배포판 공통)
```bash
# 전역 기본값: /etc/login.defs
sudo sed -i 's/^PASS_MAX_DAYS.*/PASS_MAX_DAYS 90/' /etc/login.defs
sudo sed -i 's/^PASS_MIN_DAYS.*/PASS_MIN_DAYS 1/'  /etc/login.defs
sudo sed -i 's/^PASS_WARN_AGE.*/PASS_WARN_AGE 14/' /etc/login.defs

# 계정별
sudo chage -M 90 -m 1 -W 14 devuser
sudo chage -E 2026-12-31 projectuser

# 잠금/해제/삭제
sudo usermod -L devuser
sudo usermod -U devuser
sudo userdel -r olduser
```

### (C) 실패 잠금(PAM faillock)
- **RHEL/Alma/Rocky**:
```bash
sudo authselect select sssd with-faillock --force
sudo authselect apply-changes
# 또는 /etc/security/faillock.conf 에서 deny=5 unlock_time=900 등 설정
```
- **Debian/Ubuntu**(pam_tally2 → pam_faillock 이행 중, 배포판 가이드 확인):
```bash
# /etc/pam.d/common-auth (예시, 배포판 버전에 맞게)
auth required pam_faillock.so preauth silent deny=5 unlock_time=900
auth [success=1 default=bad] pam_unix.so
auth [default=die] pam_faillock.so authfail
account required pam_faillock.so
```

**검증**
```bash
faillock --user devuser
```
**롤백**: 변경 전 PAM 파일 백업에서 복원.

---

## 1.3 SSH 하드닝

```bash
sudo cp /etc/ssh/sshd_config{,.bak}
sudo nano /etc/ssh/sshd_config
# 핵심
PermitRootLogin no
PasswordAuthentication no
PubkeyAuthentication yes
Protocol 2
# 접근 제어(필요 시)
AllowUsers deploy@10.10.10.10 devuser@192.168.0.0/16

# KEX/Ciphers/MACs는 배포판 기본 권장값 사용 또는 보안 가이드 준수
sudo systemctl reload sshd
```

**권한**
```bash
chmod 700 ~/.ssh
chmod 600 ~/.ssh/authorized_keys
```

**검증**: 다른 터미널에서 키로 접속, 패스워드 로그인 거부 확인.  
**롤백**: `sshd_config.bak` 복원.

---

## 1.4 파일 권한·ACL·특수비트·Capability

### (A) 기본 권한·소유권
```bash
sudo chown -R www-data:webgrp /var/www/myapp
sudo find /var/www/myapp -type d -exec chmod 750 {} \;
sudo find /var/www/myapp -type f -exec chmod 640 {} \;
sudo chmod 600 /etc/myapp/secret.key
```

### (B) ACL(Default ACL)
```bash
sudo setfacl -m g:webgrp:rx /var/www/myapp
sudo setfacl -m d:g:webgrp:rx /var/www/myapp
getfacl /var/www/myapp
```

### (C) 특수비트
```bash
# SUID/SGID/Sticky 점검
sudo find / -perm /6000 -type f -exec ls -l {} \; 2>/dev/null | tee /root/suid_sgid.txt
# 불필요 SUID 제거(영향 분석 필수)
sudo chmod u-s /usr/bin/newgrp
```

### (D) Capability(최소 권한 실행)
```bash
# 1024 미만 포트 바인드에 필요한 net_bind_service만 부여
sudo setcap 'cap_net_bind_service=+ep' /usr/local/bin/myapp
getcap /usr/local/bin/myapp
```
> SUID보다 **Capability**가 더 미세 제어 가능. 가능하면 SUID 제거 후 Capability로 대체.

### (E) 확장 속성(chattr)
```bash
# 중요한 설정파일을 read-only(immutable)로
sudo chattr +i /etc/myapp/config.toml
# 수정 필요 시 해제
sudo chattr -i /etc/myapp/config.toml
```

---

## 1.5 파일시스템·마운트 옵션

- `/tmp`, `/var/tmp`: `noexec,nosuid,nodev`  
- 컨테이너 호스트/멀티테넌트: 작업 디렉터리 격리, 별도 파티션/쿼터.

```bash
# /etc/fstab 예시
tmpfs /tmp tmpfs defaults,noexec,nosuid,nodev,mode=1777 0 0
# 즉시 적용
sudo mount -o remount /tmp
```

**검증**
```bash
printf '#!/bin/sh\necho hi\n' | sudo tee /tmp/x.sh
sudo chmod +x /tmp/x.sh
/tmp/x.sh   # 실행되면 안 됨
```
**롤백**
```bash
sudo mount -o remount,exec /tmp
```

---

# 2) SELinux — Type Enforcement 기반 MAC

> RHEL/Alma/Rocky/CentOS/FC 계열 기본. Debian/Ubuntu도 설치 가능하나 AppArmor가 기본인 경우가 많습니다.

## 2.1 핵심 개념

- **모드**: `Enforcing`(차단) / `Permissive`(로그만) / `Disabled`(비권장).  
- **컨텍스트**: `user:role:type:level` (주로 **type**이 접근 통제의 핵심).  
- **정책**: Targeted(일반) / mls 등.  
- **Boolean**: 서비스 동작 옵션 토글(예: httpd가 네트워크로 나갈 수 있는지 등).  
- **라벨**: 파일·포트·프로세스에 컨텍스트 부여.

## 2.2 상태·모드 확인/변경
```bash
getenforce
sestatus
# 영구 설정: /etc/selinux/config  (SELINUX=enforcing)
sudo setenforce 1    # 일시 enforcing
sudo setenforce 0    # 일시 permissive
```

## 2.3 컨텍스트 확인·변경
```bash
# 파일 컨텍스트 확인
ls -lZ /var/www/html
# 기본 라벨 복구(패키지 정책에 정의된 기본값으로)
sudo restorecon -Rv /var/www/html

# 새로운 경로를 웹콘텐츠로 라벨링
sudo semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"
sudo restorecon -Rv /srv/www
```

## 2.4 포트/네트워크 라벨
```bash
# httpd가 8080을 쓸 수 있도록 SELinux 포트 라벨 추가
sudo semanage port -a -t http_port_t -p tcp 8080
semanage port -l | grep http
```

## 2.5 Boolean(서비스 동작 옵션)
```bash
# httpd에서 네트워크 아웃바운드 허용
getsebool -a | grep httpd
sudo setsebool -P httpd_can_network_connect on
```

## 2.6 트러블슈팅 흐름

1) **차단 이벤트** 확인:
```bash
sudo ausearch -m avc -ts recent
# 또는
sudo journalctl -t setroubleshoot --since "1 hour ago"
```
2) **임시 Permissive로 재현**하여 원인 파악(운영 주의).  
3) **정상 정책**이면 라벨 복구(`restorecon`), **필요 권한**이면 Boolean/컨텍스트/포트 정의.  
4) 불가피한 경우 **정책 모듈** 작성.

## 2.7 정책 모듈(간단 예제)

**요구**: `/usr/local/bin/myapp` 프로세스가 `/var/lib/myapp/data` 읽기 및 8080 바인드 필요.

### (A) Type/드메인 정의(.te)
```bash
# myapp.te
module myapp 1.0;

require {
  type var_lib_t;
  type init_t;
  type http_port_t;
  class tcp_socket name_bind;
  class file { read open getattr };
  class dir { search getattr };
}

type myapp_t;
type myapp_exec_t;
init_daemon_domain(myapp_t, myapp_exec_t)

# 파일 접근 허용
allow myapp_t var_lib_t:dir { search getattr };
allow myapp_t var_lib_t:file { getattr open read };

# 포트 바인드 허용(미리 8080을 http_port_t로 라벨링했다고 가정)
allow myapp_t http_port_t:tcp_socket name_bind;
```

### (B) 파일 컨텍스트(.fc)
```bash
# myapp.fc
/usr/local/bin/myapp    --  gen_context(system_u:object_r:myapp_exec_t,s0)
```

### (C) 빌드·적용
```bash
checkmodule -M -m -o myapp.mod myapp.te
semodule_package -o myapp.pp -m myapp.mod -f myapp.fc
sudo semodule -i myapp.pp

# 실행파일 라벨 재설정
sudo restorecon -v /usr/local/bin/myapp
```

**검증**: `systemctl start myapp` 후 AVC 더 이상 발생하지 않는지 확인.  
**롤백**: `sudo semodule -r myapp`.

---

# 3) AppArmor — 프로파일 기반 MAC

> Ubuntu/Debian 기본. 프로세스별 **허용 규칙**을 선언한 프로파일로 Enforce/Complain.

## 3.1 상태 확인
```bash
sudo aa-status
# AppArmor 서비스
systemctl is-enabled apparmor
```

## 3.2 모드
- **enforce**: 규칙 위반 차단.  
- **complain**: 규칙 위반은 로그만.

```bash
sudo aa-complain /etc/apparmor.d/usr.sbin.nginx
sudo aa-enforce  /etc/apparmor.d/usr.sbin.nginx
```

## 3.3 프로파일 생성/튜닝(aa-genprof)

**요구**: `/usr/local/bin/myapp`가 `/var/lib/myapp` 읽기, 8080 바인드, 특정 Capabilities만 사용.

```bash
sudo aa-genprof /usr/local/bin/myapp
# 애플리케이션 실행·기능 사용 → 프롬프트에 따라 허용/거부 기록 → 프로파일 생성
```

### 3.4 수동 프로파일 예시
```text
# /etc/apparmor.d/usr.local.bin.myapp
#include <tunables/global>

profile usr.local.bin.myapp flags=(attach_disconnected) {
  # 기본
  #include <abstractions/base>

  # 파일 접근
  /usr/local/bin/myapp mr,
  /var/lib/myapp/** r,

  # 네트워크
  network inet stream,
  network inet6 stream,

  # 바인드(일반적으로 glibc/네트워크 호출 허용으로 처리)
  capability net_bind_service,

  # 쓰기/실행 차단 예시
  deny /etc/** w,
  deny /bin/** ix,

  # 로그 감소를 위한 익셉션(필요 시)
}
```

**적용**
```bash
sudo apparmor_parser -r /etc/apparmor.d/usr.local.bin.myapp
sudo aa-enforce /etc/apparmor.d/usr.local.bin.myapp
```

**검증**: `/var/log/syslog` 혹은 `journalctl -k`에서 AppArmor DENIED 여부 확인.  
**롤백**: `aa-disable` 또는 프로파일 제거.

---

# 4) sudo 하드닝 — 최소 명령 위임 & 추적

## 4.1 기본 원칙

- `root` 직접 로그인 금지, `sudo`로 필요한 명령만 위임.  
- `/etc/sudoers`는 **`visudo`**로 편집, 개별 팀/서비스 규칙은 `/etc/sudoers.d/*`에 분리.  
- **로그·감사** 강화: iolog, timestamp, lecture, syslog 연동.  
- 환경 정리: `secure_path`, `env_reset`, `env_keep` 최소화.  
- 비대화형 자동화 계정은 필요한 경우에만 `NOPASSWD`(감사·제한 필수).

## 4.2 설정 스니펫

```bash
sudo visudo
```

```text
# /etc/sudoers 핵심(예시)
Defaults        use_pty
Defaults        logfile="/var/log/sudo.log"
Defaults        timestamp_timeout=5
Defaults        lecture=always
Defaults        insults
Defaults        secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
Defaults        requiretty    # 자동화 환경에선 비권장(SSH/CI에서 실패), 운영 환경 맞춤

# I/O 로그(세션 재생용)
Defaults iolog_dir=/var/log/sudo-io
Defaults log_output

# wheel 그룹만 sudo 허용
%wheel  ALL=(ALL)       ALL

# 배포/자동화 계정 최소 명령만 위임(예: 특정 서비스 재시작)
deploy  ALL=(root) NOPASSWD: /bin/systemctl restart myapp.service
```

**검증**
```bash
sudo -l -U deploy
sudo -k; sudo systemctl restart myapp.service
```

**롤백**: `/etc/sudoers.bak` 복원 또는 문제 규칙 제거.

---

# 5) systemd 하드닝 — 서비스 샌드박스

> 목표: **루트 없이** 실행, 파일시스템 읽기 전용, 임시 디렉터리 분리, 권한·시스콜·네트워크 제한.

## 5.1 핵심 옵션(요약)

- **권한/특권**:  
  - `User=`/`Group=` (루트 금지), `NoNewPrivileges=true`,  
  - `CapabilityBoundingSet=`, `AmbientCapabilities=`,  
  - `RestrictSUIDSGID=true`
- **파일시스템/디렉터리**:  
  - `ProtectSystem=strict`, `ProtectHome=true`, `PrivateTmp=true`,  
  - `ReadOnlyPaths=`, `ReadWritePaths=`, `InaccessiblePaths=`,  
  - `RootDirectory=`/`RootImage=`(chroot/이미지)
- **메모리/코드 실행**:  
  - `MemoryDenyWriteExecute=true`
- **네임스페이스/네트워크**:  
  - `RestrictNamespaces=true`, `PrivateDevices=true`,  
  - `RestrictAddressFamilies=AF_INET AF_INET6`,  
  - `IPAddressDeny=any` + `IPAddressAllow=…` (선허용-기본거부)
- **시스콜 필터**:  
  - `SystemCallFilter=@system-service`(+ deny 목록)
- **마스크**:  
  - `ProtectKernelTunables=true`, `ProtectKernelModules=true`, `ProtectControlGroups=true`

## 5.2 보안 점수 확인
```bash
systemd-analyze security myapp.service
```
> 일부 배포판/버전에 따라 제공.

## 5.3 예제 유닛 파일(웹 앱)

```ini
# /etc/systemd/system/myapp.service
[Unit]
Description=My Hardened App
After=network-online.target
Wants=network-online.target

[Service]
User=myapp
Group=myapp
WorkingDirectory=/var/lib/myapp
ExecStart=/usr/local/bin/myapp --config /etc/myapp/config.toml --listen 127.0.0.1:8080
Restart=on-failure

# 권한/특권
NoNewPrivileges=true
CapabilityBoundingSet=CAP_NET_BIND_SERVICE
AmbientCapabilities=
RestrictSUIDSGID=true

# 파일시스템/홈/임시
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
ReadOnlyPaths=/usr /etc
ReadWritePaths=/var/lib/myapp /var/log/myapp
InaccessiblePaths=/root /home

# 커널/CGroups 보호
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true

# 네임스페이스·디바이스
RestrictNamespaces=true
PrivateDevices=true

# 네트워크 축소
RestrictAddressFamilies=AF_INET AF_INET6
# 외부 바인드는 프록시(Nginx)에서만 → 로컬 바인드
# 필요 시 IPAddressDeny/Allow 로 egress 제한

# 메모리 W^X
MemoryDenyWriteExecute=true

# 시스콜 필터(보수적)
SystemCallFilter=@system-service
# 필요 없는 call 추가 deny 가능

# UMask
UMask=027

[Install]
WantedBy=multi-user.target
```

**적용**
```bash
sudo systemctl daemon-reload
sudo systemctl enable --now myapp
systemctl status myapp
systemd-analyze security myapp.service
```

**검증**  
- 루트 파일 쓰기/읽기 금지 확인.  
- `/tmp` 분리 확인(`/proc/$PID/root/tmp` 별도).  
- 127.0.0.1:8080만 리스닝, 외부 직접 접근 불가(Nginx 프록시로만 노출).

**롤백**  
```bash
sudo systemctl disable --now myapp
sudo rm /etc/systemd/system/myapp.service
sudo systemctl daemon-reload
```

---

# 6) 통합 시나리오(End-to-End)

## 시나리오 A — “신규 웹 서버(Reverse Proxy + App) 기본 하드닝”

1) **계정/디렉터리**
```bash
sudo useradd -r -s /usr/sbin/nologin -d /var/lib/myapp -M myapp
sudo install -o myapp -g myapp -d /var/lib/myapp /var/log/myapp
```

2) **권한/마운트**
```bash
sudo chown -R myapp:myapp /var/lib/myapp /var/log/myapp
echo "tmpfs /tmp tmpfs defaults,noexec,nosuid,nodev,mode=1777 0 0" | sudo tee -a /etc/fstab
sudo mount -o remount /tmp
```

3) **SSH**
```bash
sudo cp /etc/ssh/sshd_config{,.bak}
sudo sed -i 's/^#\?PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config
sudo sed -i 's/^#\?PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config
sudo systemctl reload sshd
```

4) **AppArmor 또는 SELinux**  
- Ubuntu: AppArmor 프로파일 생성/적용(`aa-genprof` 또는 수동).  
- RHEL: SELinux Enforcing, http_port_t 8080 등록, Boolean 검토.

5) **systemd 유닛**: 위 `myapp.service` 적용.

6) **Nginx 리버스 프록시**(로컬→외부)
```bash
# /etc/nginx/sites-available/myapp
server {
  listen 443 ssl;
  server_name myapp.example.com;
  location / {
    proxy_pass http://127.0.0.1:8080;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $remote_addr;
  }
}
```

7) **검증**  
- `nmap`으로 서버 포트 확인(22,80/443 만).  
- `/tmp` 실행 차단, `systemd-analyze security` 점수 확인.  
- AVC/AppArmor DENIED 없는지 로그 확인.

8) **롤백**  
- 프로파일/유닛/설정 원복 및 백업에서 복구.

---

## 시나리오 B — “배치 워커(파일 처리) 최소권한 + 무결성 보호”

- `/data/in` 읽기, `/data/out` 쓰기만 필요.

**권한/속성**
```bash
sudo install -o worker -g worker -d /data/in /data/out
sudo chmod 750 /data/in /data/out
sudo chattr +i /usr/local/bin/worker   # 바이너리 무결성 고정
```

**systemd**
```ini
# /etc/systemd/system/worker.service
[Service]
User=worker
Group=worker
ExecStart=/usr/local/bin/worker --in /data/in --out /data/out
NoNewPrivileges=true
ProtectSystem=strict
ReadOnlyPaths=/usr /etc /data/in
ReadWritePaths=/data/out
PrivateTmp=true
RestrictSUIDSGID=true
MemoryDenyWriteExecute=true
SystemCallFilter=@system-service
```

**검증**: `/etc` 쓰기 시도 실패, `/data/out` 정상 생성.  
**롤백**: `chattr -i`, 유닛 제거.

---

## 시나리오 C — “멀티테넌트(데이터 사이언스) 서버 정책”

- 사용자별 `home` 격리, `/tmp` noexec, `sudo` 금지, SSH 키 필수, SELinux/AppArmor Enforce.  
- 자원 통제(cgroup/quota) 병행.  
- 컨테이너(루트리스 podman/docker rootless) 권장, 기본 seccomp/AppArmor/SELinux 라벨 의무화.

---

# 7) 자동화(Ansible & Shell)

## 7.1 Ansible 플레이북(요약)

```yaml
# harden.yml
- hosts: all
  become: true
  vars:
    sshd_config: /etc/ssh/sshd_config
  tasks:
    - name: Ensure SELinux enforcing (RHEL family)
      selinux:
        policy: targeted
        state: enforcing
      when: ansible_facts['os_family'] == 'RedHat'

    - name: SSH hardening
      lineinfile:
        path: "{{ sshd_config }}"
        regexp: "^#?{{ item.key }}\\s+"
        line: "{{ item.key }} {{ item.value }}"
        state: present
      loop:
        - { key: "PermitRootLogin", value: "no" }
        - { key: "PasswordAuthentication", value: "no" }
      notify: Reload sshd

    - name: Mount /tmp noexec
      mount:
        path: /tmp
        src: tmpfs
        fstype: tmpfs
        opts: defaults,noexec,nosuid,nodev,mode=1777
        state: mounted

    - name: Deploy systemd unit
      copy:
        src: files/myapp.service
        dest: /etc/systemd/system/myapp.service
        owner: root
        group: root
        mode: '0644'
      notify:
        - Reload systemd
        - Enable myapp

  handlers:
    - name: Reload sshd
      service:
        name: sshd
        state: reloaded
    - name: Reload systemd
      command: systemctl daemon-reload
    - name: Enable myapp
      systemd:
        name: myapp
        enabled: true
        state: started
```

## 7.2 초기 하드닝 스크립트(요약)

```bash
#!/usr/bin/env bash
set -euo pipefail

backup() { [[ -f "$1" ]] && sudo cp -a "$1" "$1.bak.$(date +%s)" || true; }

# 1) SSH
backup /etc/ssh/sshd_config
sudo sed -i 's/^#\?PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config
sudo sed -i 's/^#\?PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config
sudo systemctl reload sshd

# 2) /tmp noexec
if ! grep -qE '^\s*tmpfs\s+/tmp\s+tmpfs' /etc/fstab; then
  echo "tmpfs /tmp tmpfs defaults,noexec,nosuid,nodev,mode=1777 0 0" | sudo tee -a /etc/fstab
fi
sudo mount -o remount /tmp || sudo mount /tmp

# 3) SUID 점검 보고
sudo find / -perm /6000 -type f 2>/dev/null | sudo tee /root/suid_sgid.$(hostname).txt

echo "Done. Review /root/suid_sgid.$(hostname).txt"
```

---

# 8) 점검표(Checklist)

**계정/인증**
- [ ] 루트 직접 로그인 금지, `sudo` 최소 명령 위임  
- [ ] 서비스 계정 분리(`nologin`, 전용 디렉터리)  
- [ ] 암호 정책(길이·복잡성·회전) + 실패 잠금  
- [ ] SSH: 키 기반, 배스천 IP만, 패스워드 인증 Off

**권한/파일시스템**
- [ ] 민감 경로 권한 최소화(600/640/750)  
- [ ] SUID/SGID 주기 점검, 불필요 제거  
- [ ] Capability로 대체 가능한 곳 전환  
- [ ] `/tmp` `noexec,nosuid,nodev`  
- [ ] 중요 설정 `chattr +i`(운영 프로세스 고려)

**MAC**
- [ ] SELinux/AppArmor **Enforce**  
- [ ] 컨텍스트/프로파일 재적용·검증  
- [ ] Boolean/포트 라벨 정합성

**sudo**
- [ ] `visudo` 및 Drop-in 관리  
- [ ] iolog/logfile 활성, `secure_path` 지정  
- [ ] NOPASSWD 최소, 환경 정리

**systemd**
- [ ] `User=`/`Group=` 비루트  
- [ ] `NoNewPrivileges`, `CapabilityBoundingSet`, `RestrictSUIDSGID`  
- [ ] `ProtectSystem=strict`, `ProtectHome`, `PrivateTmp`  
- [ ] `ReadOnlyPaths/ReadWritePaths` 정확화  
- [ ] `SystemCallFilter`, `MemoryDenyWriteExecute`  
- [ ] 필요 시 `IPAddressDeny/Allow`로 egress 제한

**로깅/운영**
- [ ] `systemd-analyze security` 점수 확인  
- [ ] AVC/AppArmor DENIED 로그 주기 확인  
- [ ] 변경/롤백 절차 문서화, 백업

---

# 9) 자주 묻는 질문(FAQ)

**Q1. 웹앱이 80/443 바인드를 원해 루트가 필요합니다.**  
A. 루트 실행 대신 **Capability** `CAP_NET_BIND_SERVICE`를 **실행 파일**에 부여하세요. SUID는 지양.

**Q2. SELinux가 자꾸 막아요. 끄면 안 되나요?**  
A. 비권장. **정상 라벨 복구**(`restorecon`)와 **Boolean/포트 라벨**/정책 모듈로 해결하는 게 원칙입니다.

**Q3. AppArmor에서 앱이 실패합니다.**  
A. `complain` 모드로 전환 후 로그를 바탕으로 프로파일을 보강하고 다시 `enforce`로 전환하세요.

**Q4. sudo NOPASSWD는 위험한가요?**  
A. **필요 최소 명령**에만, I/O 로깅과 함께 사용하면 통제 가능. 범용 `ALL`에 NOPASSWD는 금지.

**Q5. systemd 옵션이 많아 헷갈립니다.**  
A. 먼저 `User=`, `NoNewPrivileges=true`, `ProtectSystem=strict`, `PrivateTmp=true`부터 적용 →  
   이후 `CapabilityBoundingSet`, `RestrictSUIDSGID`, `SystemCallFilter` 등 **점진 강화**가 안전합니다.

---

# 10) 요약(암기 포인트)

- **최소권한**: 계정·그룹·권한·sudo·Capability  
- **MAC**: SELinux/AppArmor **Enforce** + 올바른 라벨/프로파일  
- **서비스 샌드박스**: systemd 보안 옵션 **단계적** 적용  
- **마운트/임시 디렉터리**: `/tmp` 실행 금지, 불필요 SUID 제거  
- **검증·롤백**: 변경 전 백업, `systemd-analyze security`/AVC·DENIED 로그 확인, 명확한 원복 경로
