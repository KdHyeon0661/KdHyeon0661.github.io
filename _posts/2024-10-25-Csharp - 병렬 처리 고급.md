---
layout: post
title: C# - ë³‘ë ¬ ì²˜ë¦¬ ê³ ê¸‰
date: 2024-10-25 19:20:23 +0900
category: Csharp
---
# C# ë³‘ë ¬ ì²˜ë¦¬ ê³ ê¸‰: Concurrent Collectionsì™€ Thread-Safe ì„¤ê³„

ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ **ë°ì´í„° ê²½ìŸ(Race Condition)**ì„ ë§‰ê³  **ì•ˆì •ì ì¸ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì„¤ê³„**ê°€ í•„ìš”í•©ë‹ˆë‹¤.  
ì´ë²ˆ ê¸€ì—ì„œëŠ” C#ì—ì„œ ì œê³µí•˜ëŠ” Thread-Safe ì»¬ë ‰ì…˜ê³¼ ëŒ€í‘œì ì¸ ë³‘ë ¬ ì„¤ê³„ ê¸°ë²•ì„ ì •ë¦¬í•©ë‹ˆë‹¤.

---

## ğŸ”· 1. ì¼ë°˜ ì»¬ë ‰ì…˜ì˜ ë¬¸ì œì 

```csharp
List<int> list = new List<int>();

Parallel.For(0, 1000, i =>
{
    list.Add(i); // ì˜ˆì™¸ ë°œìƒ ê°€ëŠ¥ (ìŠ¤ë ˆë“œ ì¶©ëŒ)
});
```

- `List<T>`, `Dictionary<K,V>` ë“±ì€ ê¸°ë³¸ì ìœ¼ë¡œ **ìŠ¤ë ˆë“œ ì•ˆì „(Thread-Safe)ì´ ì•„ë‹˜**
- ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì ‘ê·¼ ì‹œ `InvalidOperationException`, ë°ì´í„° ì†ì‹¤ ê°€ëŠ¥

---

## ğŸ”· 2. Concurrent Collections ì†Œê°œ

.NETì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ **ë™ì‹œì„± ì»¬ë ‰ì…˜**ì„ ì œê³µí•©ë‹ˆë‹¤:

| íƒ€ì… | ì„¤ëª… |
|------|------|
| `ConcurrentQueue<T>` | ì•ˆì „í•œ í(FIFO) |
| `ConcurrentStack<T>` | ì•ˆì „í•œ ìŠ¤íƒ(LIFO) |
| `ConcurrentBag<T>` | ë¬´ìˆœì„œ ì»¬ë ‰ì…˜ |
| `ConcurrentDictionary<K,V>` | ìŠ¤ë ˆë“œ ì•ˆì „í•œ í‚¤-ê°’ ì €ì¥ì†Œ |
| `BlockingCollection<T>` | ì œí•œëœ ìƒì‚°/ì†Œë¹„ íŒ¨í„´ì— ìœ ìš© |

---

## ğŸ”· 3. ConcurrentQueue ì˜ˆì œ

```csharp
ConcurrentQueue<int> queue = new ConcurrentQueue<int>();

Parallel.For(0, 1000, i =>
{
    queue.Enqueue(i);
});

while (queue.TryDequeue(out int item))
{
    Console.WriteLine(item);
}
```

---

## ğŸ”· 4. ConcurrentDictionary ì˜ˆì œ

```csharp
ConcurrentDictionary<string, int> dict = new();

Parallel.For(0, 1000, i =>
{
    dict.AddOrUpdate("count", 1, (key, oldValue) => oldValue + 1);
});

Console.WriteLine(dict["count"]); // 1000
```

---

## ğŸ”· 5. Thread-Safe íŒ¨í„´: lock ì‚¬ìš©

```csharp
object locker = new object();
int total = 0;

Parallel.For(0, 1000, i =>
{
    lock (locker)
    {
        total++;
    }
});
```

> âœ… ë‹¨ì : ë³‘ëª©(bottleneck), ê³¼ë„í•œ ë½ ê²½ìŸ

---

## ğŸ”· 6. Interlocked â€“ ë½ ì—†ëŠ” ì •ìˆ˜ ì—°ì‚°

```csharp
int total = 0;

Parallel.For(0, 1000, i =>
{
    Interlocked.Increment(ref total); // ë½ ì—†ì´ ì•ˆì „í•œ ì¦ê°€
});
```

- `Interlocked.Increment`, `Decrement`, `Add`, `CompareExchange` ë“± ì œê³µ
- **ê°€ë²¼ìš´ ë½ ì—†ì´ ì •ìˆ˜ ì—°ì‚° ì²˜ë¦¬** ê°€ëŠ¥

---

## ğŸ”· 7. Lazy<T> â€“ ì§€ì—° ì´ˆê¸°í™”ì™€ ìŠ¤ë ˆë“œ ì•ˆì „

```csharp
Lazy<MyService> service = new(() => new MyService());

var instance = service.Value; // ìµœì´ˆ ì ‘ê·¼ ì‹œ ì´ˆê¸°í™”
```

- ê¸°ë³¸ì ìœ¼ë¡œ **ìŠ¤ë ˆë“œ ì•ˆì „**
- Singleton íŒ¨í„´ êµ¬í˜„ ì‹œ ìœ ìš©

---

## ğŸ”· 8. BlockingCollection â€“ ìƒì‚°ì/ì†Œë¹„ì íŒ¨í„´

```csharp
BlockingCollection<int> buffer = new();

Task producer = Task.Run(() =>
{
    for (int i = 0; i < 10; i++)
    {
        buffer.Add(i);
    }
    buffer.CompleteAdding(); // ë” ì´ìƒ ì¶”ê°€ ì•ˆ í•¨
});

Task consumer = Task.Run(() =>
{
    foreach (int item in buffer.GetConsumingEnumerable())
    {
        Console.WriteLine($"ì†Œë¹„: {item}");
    }
});

await Task.WhenAll(producer, consumer);
```

---

## âœ… ìš”ì•½ ì •ë¦¬

| ë„êµ¬/íŒ¨í„´ | ì„¤ëª… |
|-----------|------|
| `ConcurrentDictionary` | ë½ ì—†ì´ í‚¤-ê°’ ì €ì¥ ê°€ëŠ¥ |
| `ConcurrentQueue` | ì•ˆì „í•œ FIFO í |
| `BlockingCollection` | ìƒì‚°ì-ì†Œë¹„ì êµ¬í˜„ |
| `Interlocked` | ë½ ì—†ì´ ì •ìˆ˜ ì—°ì‚° |
| `lock` | ì¼ë°˜ì ì¸ ë™ê¸°í™” ë°©ì‹ (ë‹¨ì : ë³‘ëª©) |
| `Lazy<T>` | ì§€ì—° ì´ˆê¸°í™” + ìŠ¤ë ˆë“œ ì•ˆì „ |