---
layout: post
title: C# - 병렬 처리 고급
date: 2024-10-25 19:20:23 +0900
category: Csharp
---
# C# 병렬 처리 고급: Concurrent Collections와 Thread-Safe 설계

## 소개: 멀티스레드 환경에서 안전하고 효율적인 프로그래밍

현대 애플리케이션은 대부분 병렬 처리를 통해 성능을 극대화해야 합니다. 그러나 다중 스레드 환경에서는 데이터 경쟁(Race Condition), 교착 상태(Deadlock), 메모리 가시성 문제 등 다양한 도전과제가 존재합니다. C#은 이러한 문제들을 해결하기 위해 강력한 도구와 패턴을 제공하며, 그 중심에 **Concurrent 컬렉션**과 **스레드 안전 설계 원칙**이 있습니다.

멀티스레드 프로그래밍의 목표는 단순히 락(lock)을 추가하는 것이 아니라, **데이터 무결성을 보장하면서도 최대한의 처리량(throughput)과 최소의 지연 시간(latency)**을 달성하는 것입니다. 이를 위해 우리는 적절한 동기화 메커니즘을 선택하고, 컬렉션을 올바르게 사용하며, 설계 단계부터 스레드 안전성을 고려해야 합니다.

---

## 1. 문제 인식: 일반 컬렉션이 왜 위험한가?

### 다중 스레드 환경에서의 일반 컬렉션 문제

```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        List<int> numbers = new List<int>();
        
        // 여러 스레드에서 동시에 리스트에 항목 추가
        Parallel.For(0, 10000, i =>
        {
            numbers.Add(i); // 문제 발생!
        });
        
        Console.WriteLine($"리스트 항목 수: {numbers.Count}");
        // 항상 10000이 출력되지 않을 수 있음
    }
}
```

위 코드는 다음과 같은 문제를 야기할 수 있습니다:
1. **데이터 손실**: 여러 스레드가 동시에 `Add`를 호출하면 일부 항목이 손실될 수 있습니다.
2. **예외 발생**: 내부 배열 크기 조정 중 다른 스레드가 접근하면 `IndexOutOfRangeException`이 발생할 수 있습니다.
3. **메모리 손상**: 최악의 경우 메모리 손상으로 애플리케이션이 비정상 종료될 수 있습니다.

### 문제의 근본 원인

일반적인 컬렉션 클래스(`List<T>`, `Dictionary<TKey, TValue>`, `Queue<T>` 등)는 **스레드 안전하게 설계되지 않았습니다**. 이들은 단일 스레드 환경에서 최고의 성능을 제공하기 위해 설계되었으며, 다중 스레드 접근 시 내부 상태가 손상될 수 있습니다.

---

## 2. Concurrent 컬렉션 소개

.NET은 `System.Collections.Concurrent` 네임스페이스에서 스레드 안전한 컬렉션 클래스들을 제공합니다. 이들은 내부적으로 락이나 락-프리 알고리즘을 사용하여 동시 접근을 안전하게 처리합니다.

### Concurrent 컬렉션 종류

| 컬렉션 타입 | 설명 | 사용 사례 |
|------------|------|----------|
| `ConcurrentQueue<T>` | FIFO(선입선출) 큐 | 작업 큐, 로그 버퍼, 생산자-소비자 패턴 |
| `ConcurrentStack<T>` | LIFO(후입선출) 스택 | 작업 취소, 백트래킹, 워크 스틸링 |
| `ConcurrentBag<T>` | 순서가 없는 컬렉션 | 작업 항목 수집, 높은 병렬도가 필요한 경우 |
| `ConcurrentDictionary<TKey, TValue>` | 키-값 저장소 | 공유 캐시, 카운터, 상태 저장소 |
| `BlockingCollection<T>` | 제한된 크기의 컬렉션 | 생산자-소비자 패턴(백프레셔 지원) |

---

## 3. Concurrent 컬렉션 사용법

### ConcurrentQueue<T> - 안전한 FIFO 큐

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

class ConcurrentQueueExample
{
    static void Main()
    {
        var queue = new ConcurrentQueue<int>();
        
        // 다중 생산자: 여러 스레드에서 동시에 항목 추가
        Parallel.For(0, 10000, i =>
        {
            queue.Enqueue(i);
        });
        
        // 다중 소비자: 여러 스레드에서 동시에 항목 제거
        int totalProcessed = 0;
        Parallel.For(0, 4, _ =>
        {
            while (queue.TryDequeue(out int item))
            {
                // 항목 처리
                Interlocked.Increment(ref totalProcessed);
            }
        });
        
        Console.WriteLine($"처리된 항목 수: {totalProcessed}");
    }
}
```

### ConcurrentDictionary<TKey, TValue> - 스레드 안전 사전

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

class ConcurrentDictionaryExample
{
    static void Main()
    {
        var wordCounts = new ConcurrentDictionary<string, int>();
        string[] words = { "apple", "banana", "apple", "orange", "banana", "apple" };
        
        // 단어 빈도수 계산 (스레드 안전하게)
        Parallel.ForEach(words, word =>
        {
            // AddOrUpdate: 키가 없으면 추가, 있으면 업데이트
            wordCounts.AddOrUpdate(
                word,          // 키
                1,             // 추가될 값
                (key, oldValue) => oldValue + 1  // 업데이트 함수
            );
        });
        
        foreach (var pair in wordCounts)
        {
            Console.WriteLine($"{pair.Key}: {pair.Value}회");
        }
        
        // GetOrAdd: 키가 없으면 추가 후 반환, 있으면 기존 값 반환
        int appleCount = wordCounts.GetOrAdd("apple", 0);
        Console.WriteLine($"사과 개수: {appleCount}");
        
        // TryRemove: 안전하게 항목 제거
        bool removed = wordCounts.TryRemove("orange", out int orangeCount);
        if (removed)
        {
            Console.WriteLine($"제거된 오렌지 개수: {orangeCount}");
        }
    }
}
```

### BlockingCollection<T> - 생산자-소비자 패턴 구현

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

class ProducerConsumerExample
{
    static void Main()
    {
        // 최대 10개 항목까지 저장 가능 (백프레셔 구현)
        var buffer = new BlockingCollection<int>(boundedCapacity: 10);
        
        // 생산자 태스크
        var producer = Task.Run(() =>
        {
            for (int i = 0; i < 100; i++)
            {
                buffer.Add(i);
                Console.WriteLine($"생산됨: {i}");
                Task.Delay(50).Wait(); // 생산 속도 조절
            }
            buffer.CompleteAdding(); // 더 이상 추가하지 않음을 알림
        });
        
        // 소비자 태스크
        var consumer = Task.Run(() =>
        {
            // GetConsumingEnumerable은 컬렉션이 완료될 때까지 항목을 반환
            foreach (var item in buffer.GetConsumingEnumerable())
            {
                Console.WriteLine($"소비됨: {item}");
                Task.Delay(100).Wait(); // 소비 속도 조절
            }
            Console.WriteLine("모든 항목 소비 완료");
        });
        
        Task.WaitAll(producer, consumer);
    }
}
```

---

## 4. 저수준 동기화 메커니즘

### Interlocked 클래스 - 원자적 연산

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class InterlockedExample
{
    static void Main()
    {
        int sharedCounter = 0;
        
        // 여러 스레드에서 동시에 카운터 증가
        Parallel.For(0, 10000, _ =>
        {
            // 원자적 증가 - 스레드 안전
            Interlocked.Increment(ref sharedCounter);
            
            // 원자적 추가
            Interlocked.Add(ref sharedCounter, 5);
            
            // CompareExchange: 조건부 원자적 교체
            int oldValue, newValue;
            do
            {
                oldValue = sharedCounter;
                newValue = oldValue * 2;
            } while (Interlocked.CompareExchange(
                ref sharedCounter, newValue, oldValue) != oldValue);
        });
        
        Console.WriteLine($"최종 카운터 값: {sharedCounter}");
    }
}
```

### ReaderWriterLockSlim - 읽기/쓰기 락 분리

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class ReaderWriterLockExample
{
    private static readonly ReaderWriterLockSlim _rwLock = new();
    private static int _sharedData = 0;
    
    static void Main()
    {
        // 다중 읽기자
        var readers = Task.Run(() =>
        {
            Parallel.For(0, 10, i =>
            {
                _rwLock.EnterReadLock();
                try
                {
                    Console.WriteLine($"읽기자 {i}: 데이터 = {_sharedData}");
                    Thread.Sleep(10);
                }
                finally
                {
                    _rwLock.ExitReadLock();
                }
            });
        });
        
        // 단일 쓰기자
        var writer = Task.Run(() =>
        {
            for (int i = 0; i < 5; i++)
            {
                _rwLock.EnterWriteLock();
                try
                {
                    _sharedData++;
                    Console.WriteLine($"쓰기자: 데이터를 {_sharedData}로 업데이트");
                    Thread.Sleep(50);
                }
                finally
                {
                    _rwLock.ExitWriteLock();
                }
            }
        });
        
        Task.WaitAll(readers, writer);
    }
}
```

---

## 5. 불변성(Immutability)을 통한 스레드 안전성

객체가 한 번 생성된 후 변경되지 않는다면, 다중 스레드 환경에서도 안전하게 공유할 수 있습니다.

### 불변 타입 정의

```csharp
using System;
using System.Collections.Immutable;
using System.Threading.Tasks;

// 불변 레코드 타입
public record SensorReading(
    DateTime Timestamp,
    string SensorId,
    double Value
);

class ImmutableExample
{
    static void Main()
    {
        // Immutable 컬렉션 생성
        var readings = ImmutableList<SensorReading>.Empty;
        
        // 여러 스레드에서 안전하게 읽기
        Parallel.For(0, 10, i =>
        {
            // 읽기 작업 - 안전
            if (readings.Count > 0)
            {
                var first = readings[0];
                Console.WriteLine($"스레드 {Task.CurrentId}: 첫 번째 읽기 = {first.Value}");
            }
        });
        
        // 새 컬렉션 생성 (원본은 변경되지 않음)
        var newReadings = readings.Add(new SensorReading(
            DateTime.Now,
            "sensor-1",
            25.5
        ));
        
        // 원자적 참조 교체 (스레드 안전)
        var sharedReadings = newReadings;
    }
}
```

### 불변성을 활용한 스레드 안전 캐시

```csharp
using System;
using System.Collections.Immutable;

public class ThreadSafeCache<TKey, TValue> where TKey : notnull
{
    private ImmutableDictionary<TKey, TValue> _cache = 
        ImmutableDictionary<TKey, TValue>.Empty;
    
    public TValue GetOrAdd(TKey key, Func<TKey, TValue> valueFactory)
    {
        // 먼저 캐시에서 찾기 (락 없이 읽기 안전)
        if (_cache.TryGetValue(key, out var value))
        {
            return value;
        }
        
        // 캐시에 없으면 생성
        value = valueFactory(key);
        
        // 원자적으로 새 캐시 참조로 교체
        var newCache = _cache.SetItem(key, value);
        
        // CompareExchange를 사용한 원자적 업데이트
        var original = System.Threading.Interlocked.CompareExchange(
            ref _cache, newCache, _cache);
        
        // 다른 스레드가 먼저 업데이트했으면 해당 값 사용
        if (!ReferenceEquals(original, _cache))
        {
            return _cache[key];
        }
        
        return value;
    }
    
    public bool TryGetValue(TKey key, out TValue value)
    {
        return _cache.TryGetValue(key, out value);
    }
}
```

---

## 6. 실전 패턴: 고성능 데이터 처리 파이프라인

```csharp
using System;
using System.Collections.Concurrent;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

public class DataProcessingPipeline : IDisposable
{
    private readonly BlockingCollection<string> _inputQueue;
    private readonly BlockingCollection<string> _processedQueue;
    private readonly CancellationTokenSource _cancellationTokenSource;
    private readonly Task[] _processorTasks;
    private readonly Task _writerTask;
    
    public DataProcessingPipeline(int processorCount, string outputPath)
    {
        _inputQueue = new BlockingCollection<string>(boundedCapacity: 1000);
        _processedQueue = new BlockingCollection<string>(boundedCapacity: 1000);
        _cancellationTokenSource = new CancellationTokenSource();
        
        // 데이터 처리기 작업들
        _processorTasks = new Task[processorCount];
        for (int i = 0; i < processorCount; i++)
        {
            _processorTasks[i] = Task.Run(() => ProcessData());
        }
        
        // 출력기 작업
        _writerTask = Task.Run(() => WriteData(outputPath));
    }
    
    public void AddData(string data)
    {
        _inputQueue.Add(data);
    }
    
    private void ProcessData()
    {
        foreach (var data in _inputQueue.GetConsumingEnumerable(_cancellationTokenSource.Token))
        {
            try
            {
                // 데이터 처리 (CPU 집약적 작업)
                string processed = Process(data);
                _processedQueue.Add(processed);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"처리 실패: {ex.Message}");
            }
        }
    }
    
    private void WriteData(string outputPath)
    {
        using var writer = new StreamWriter(outputPath, append: true);
        
        foreach (var data in _processedQueue.GetConsumingEnumerable(_cancellationTokenSource.Token))
        {
            writer.WriteLine(data);
        }
        
        writer.Flush();
    }
    
    private string Process(string data)
    {
        // 실제 처리 로직 (예: JSON 파싱, 데이터 변환 등)
        Thread.Sleep(10); // 처리 시간 시뮬레이션
        return $"PROCESSED: {data.ToUpper()}";
    }
    
    public void Complete()
    {
        _inputQueue.CompleteAdding();
        
        // 모든 처리기 작업 완료 대기
        Task.WaitAll(_processorTasks);
        
        _processedQueue.CompleteAdding();
        _writerTask.Wait();
    }
    
    public void Dispose()
    {
        _cancellationTokenSource.Cancel();
        Complete();
        _inputQueue.Dispose();
        _processedQueue.Dispose();
        _cancellationTokenSource.Dispose();
    }
}

class Program
{
    static async Task Main()
    {
        using var pipeline = new DataProcessingPipeline(
            processorCount: Environment.ProcessorCount,
            outputPath: "output.txt"
        );
        
        // 데이터 생산
        var producer = Task.Run(() =>
        {
            for (int i = 0; i < 100; i++)
            {
                pipeline.AddData($"Data item {i}");
                await Task.Delay(5);
            }
        });
        
        await producer;
        pipeline.Complete();
        
        Console.WriteLine("데이터 처리 완료");
    }
}
```

---

## 7. 성능 최적화와 문제 해결

### 성능 측정과 프로파일링

```csharp
using System;
using System.Diagnostics;
using System.Threading.Tasks;

class PerformanceMeasurement
{
    static void MeasureConcurrentOperation(Action action, string operationName)
    {
        var stopwatch = Stopwatch.StartNew();
        var memoryBefore = GC.GetTotalMemory(true);
        
        action();
        
        stopwatch.Stop();
        var memoryAfter = GC.GetTotalMemory(true);
        var memoryUsed = memoryAfter - memoryBefore;
        
        Console.WriteLine($"{operationName}:");
        Console.WriteLine($"  시간: {stopwatch.ElapsedMilliseconds}ms");
        Console.WriteLine($"  메모리 사용: {memoryUsed / 1024}KB");
    }
    
    static void Main()
    {
        // 락 사용 버전 성능 측정
        MeasureConcurrentOperation(() =>
        {
            object syncLock = new object();
            int counter = 0;
            
            Parallel.For(0, 1000000, _ =>
            {
                lock (syncLock)
                {
                    counter++;
                }
            });
        }, "락 사용 카운터");
        
        // Interlocked 사용 버전 성능 측정
        MeasureConcurrentOperation(() =>
        {
            int counter = 0;
            
            Parallel.For(0, 1000000, _ =>
            {
                Interlocked.Increment(ref counter);
            });
        }, "Interlocked 카운터");
    }
}
```

### 교착 상태(Deadlock) 방지

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class DeadlockPrevention
{
    // 잘못된 예: 교착 상태 가능성
    static void BadExample()
    {
        object lockA = new object();
        object lockB = new object();
        
        var task1 = Task.Run(() =>
        {
            lock (lockA)
            {
                Thread.Sleep(100);
                lock (lockB)  // lockB를 기다림
                {
                    Console.WriteLine("Task1 완료");
                }
            }
        });
        
        var task2 = Task.Run(() =>
        {
            lock (lockB)
            {
                Thread.Sleep(100);
                lock (lockA)  // lockA를 기다림 → 교착 상태!
                {
                    Console.WriteLine("Task2 완료");
                }
            }
        });
        
        Task.WaitAll(task1, task2, Task.Delay(2000));
    }
    
    // 올바른 예: 락 순서 통일
    static void GoodExample()
    {
        object lockA = new object();
        object lockB = new object();
        
        var task1 = Task.Run(() =>
        {
            lock (lockA)
            {
                Thread.Sleep(100);
                lock (lockB)
                {
                    Console.WriteLine("Task1 완료");
                }
            }
        });
        
        var task2 = Task.Run(() =>
        {
            lock (lockA)  // 같은 순서로 락 획득
            {
                Thread.Sleep(100);
                lock (lockB)
                {
                    Console.WriteLine("Task2 완료");
                }
            }
        });
        
        Task.WaitAll(task1, task2);
    }
    
    // 더 나은 예: 락 타임아웃 사용
    static void BetterExample()
    {
        object lockA = new object();
        
        if (Monitor.TryEnter(lockA, TimeSpan.FromSeconds(1)))
        {
            try
            {
                // 임계 구역 작업
                Console.WriteLine("락 획득 성공");
            }
            finally
            {
                Monitor.Exit(lockA);
            }
        }
        else
        {
            Console.WriteLine("락 획득 실패 - 타임아웃");
        }
    }
}
```

---

## 결론: 현명한 스레드 안전 설계 원칙

멀티스레드 프로그래밍은 복잡하지만, 올바른 도구와 원칙을 적용하면 안전하고 효율적인 시스템을 구축할 수 있습니다. 다음 원칙들을 기억하세요:

1. **가장 간단한 도구 선택**: 문제에 맞는 가장 간단한 동기화 메커니즘을 선택하세요. 단순한 카운터에는 `Interlocked`, 키-값 저장소에는 `ConcurrentDictionary`를 사용하세요.

2. **불변성 활용**: 가능하면 불변 타입과 불변 컬렉션을 사용하세요. 이는 동시성 문제를 근본적으로 해결합니다.

3. **락 범위 최소화**: 락을 사용해야 한다면, 락이 보호하는 임계 구역을 가능한 한 작게 유지하세요. I/O 작업이나 긴 계산은 락 외부에서 수행하세요.

4. **백프레셔 고려**: 생산자-소비자 패턴을 구현할 때는 항상 백프레셔(backpressure)를 고려하세요. `BlockingCollection`의 제한된 용량이나 `System.Threading.Channels`를 사용하세요.

5. **성능 측정**: 동시성 코드는 직관과 다르게 동작할 수 있습니다. 실제 성능을 측정하고 프로파일링하여 병목 현상을 식별하세요.

6. **예외 처리**: 다중 스레드 환경에서는 예외 처리가 특히 중요합니다. 작업 내부에서 예외를 적절히 처리하고, 작업 실패 시 시스템이 우아하게 복구되도록 설계하세요.

7. **리소스 정리**: `CancellationToken`을 사용하여 작업을 취소하고, `IDisposable`을 구현하여 리소스를 적절히 정리하세요.

스레드 안전한 코드를 작성하는 것은 기술적 능력 이상으로 설계적 통찰력이 필요합니다. 데이터 흐름을 이해하고, 경합 지점을 식별하며, 적절한 추상화를 선택하는 능력이 성공적인 동시성 프로그래밍의 핵심입니다. 이러한 원칙들을 적용하면 확장성 있고 견고한 애플리케이션을 구축할 수 있을 것입니다.