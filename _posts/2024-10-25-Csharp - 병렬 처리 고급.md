---
layout: post
title: C# - 병렬 처리 고급
date: 2024-10-25 19:20:23 +0900
category: Csharp
---
# C# 병렬 처리 고급: Concurrent Collections와 Thread-Safe 설계

멀티스레드 환경에서 **데이터 경쟁(Race Condition)**을 막고 **처리량(throughput)과 지연(latency)**을 균형 있게 끌어올리려면, 스레드 안전 컬렉션과 올바른 동기화 패턴을 선택해야 한다.
이 글은 기본기를 넘어 **Concurrent* 컬렉션 전반**, **락/락-프리(Interlocked)**, **생산자-소비자**, **지연 초기화**, **메모리 모델 포인트**, **불변(Immutable) 전략**, **실전 튜닝**까지 촘촘히 다룬다.

---

## 워밍업: 일반 컬렉션이 왜 문제인가

```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

class Demo
{
    static async Task Main()
    {
        List<int> list = new List<int>();

        await Task.Run(() => Parallel.For(0, 1000, i =>
        {
            // 다중 스레드 환경에서 List<T>.Add는 원자적이지 않다
            list.Add(i); // 충돌/예외/데이터 손실 가능
        }));

        Console.WriteLine(list.Count); // 1000 보장 안 됨
    }
}
```

- `List<T>`, `Dictionary<TKey, TValue>` 등 **표준 컬렉션은 기본적으로 스레드 안전이 아님**.
- 동시에 쓰기/읽기/열거 시 **InvalidOperationException**, **데이터 손실**, **메모리 손상**까지 유발할 수 있음.

> 해결: **Concurrent* 컬렉션**, **락(lock)**, **Interlocked**, **불변 컬렉션**, **메시지 패싱** 중 하나를 상황에 맞게 선택.

---

## .NET Concurrent Collections 한눈에

| 타입 | 시맨틱 | 용도 | 비고 |
|---|---|---|---|
| `ConcurrentQueue<T>` | FIFO | 로그/작업 큐 | 다중 생산자/소비자에 강함 |
| `ConcurrentStack<T>` | LIFO | 워크 스틸링/백트래킹 | 스택 성향 작업 |
| `ConcurrentBag<T>` | 무순서 | 높은 병렬 수집 | 스레드 로컬 버킷 기반, 순서× |
| `ConcurrentDictionary<TKey, TValue>` | 키-값 | 공유 캐시/카운터 | `AddOrUpdate`, `GetOrAdd` 제공 |
| `BlockingCollection<T>` | 제한 큐 | 생산자-소비자 | 내부적으로 큐/배그를 감싸 backpressure 제공 |

> 공통: **스레드 안전 + 잠금 최소화** 기법을 내부적으로 사용. 외부에서 별도의 `lock` 없이 동시 접근 가능.

---

## ConcurrentQueue<T> — 안전한 FIFO

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

class CQDemo
{
    static async Task Main()
    {
        var q = new ConcurrentQueue<int>();

        Parallel.For(0, 1_000, i => q.Enqueue(i));

        int count = 0;
        while (q.TryDequeue(out int item))
        {
            count++;
        }
        Console.WriteLine(count); // 1000 보장
    }
}
```

- **비차단적(락-프리)에 가까운 구현**으로 높은 처리량.
- `TryPeek`, `TryDequeue`를 사용해 안전하게 꺼낸다.
- **소비자 쪽 추출 루프**에서 과도한 busy-wait를 피하려면 `BlockingCollection`과 조합하거나, **신호(ManualResetEventSlim)**를 함께 쓸 것.

---

## ConcurrentDictionary<TKey, TValue> — 키-값의 왕도

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

class CDDemo
{
    static async Task Main()
    {
        var dict = new ConcurrentDictionary<string, int>(StringComparer.Ordinal);

        Parallel.For(0, 1000, _ =>
        {
            dict.AddOrUpdate("count", 1, (_, old) => old + 1);
        });

        Console.WriteLine(dict["count"]); // 1000
    }
}
```

### 핵심 API

- `GetOrAdd(key, valueFactory)` : 없으면 추가, 있으면 기존 값 반환.
- `AddOrUpdate(key, addValue, updateFactory)` : 원자적 추가/갱신.
- `TryUpdate(key, newValue, comparisonValue)` : 조건부 갱신(낙관적 동시성).

> **주의**: 값 타입이 **참조형**이고 내부 상태를 또 변경한다면, 그 내부 변경은 **사실상 비원자적**일 수 있다.
> 필요한 경우 값 자체를 교체하는 **불변 패턴**(copy-on-write)을 고려하라.

---

## ConcurrentBag<T> / ConcurrentStack<T>

```csharp
// Bag: 순서가 중요하지 않은 대량 수집/집계에 강함
var bag = new System.Collections.Concurrent.ConcurrentBag<int>();
Parallel.For(0, 1000, i => bag.Add(i));

int total = 0;
while (bag.TryTake(out var v)) total += v;
Console.WriteLine(total);

// Stack: LIFO 형태, 백트래킹/DFS 성격의 작업에 쓰기 좋음
var stack = new System.Collections.Concurrent.ConcurrentStack<int>();
Parallel.For(0, 10, i => stack.Push(i));
while (stack.TryPop(out var s)) Console.WriteLine(s);
```

- `ConcurrentBag<T>`는 **스레드 로컬 버킷**을 활용, 경쟁을 줄인다. 순서 보존이 필요하면 부적합.
- `ConcurrentStack<T>`는 **후입선출(LIFO)** 로컬리티가 좋은 워크로드에서 유리.

---

## BlockingCollection<T> — 생산자-소비자와 Backpressure

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

class BCDemo
{
    static async Task Main()
    {
        var buffer = new BlockingCollection<int>(boundedCapacity: 100); // capacity로 backpressure

        var producer = Task.Run(() =>
        {
            for (int i = 0; i < 1000; i++)
            {
                buffer.Add(i);       // 꽉 차면 블록
            }
            buffer.CompleteAdding();  // 생산 종료 알림
        });

        var consumer = Task.Run(() =>
        {
            foreach (var item in buffer.GetConsumingEnumerable()) // 비우면서 열거
            {
                // 처리...
            }
        });

        await Task.WhenAll(producer, consumer);
    }
}
```

- `boundedCapacity`로 **과도한 생산 억제**(backpressure) 실현.
- `CompleteAdding()`으로 종료 신호를 보낸 뒤 `GetConsumingEnumerable()`에서 **우아한 종료**.

> 대안: **System.Threading.Channels**(고성능 비차단 채널), TPL Dataflow(고수준 블록).

---

## 락 vs Interlocked — 올바른 선택

### `lock` (모니터)

```csharp
object gate = new object();
int total = 0;

Parallel.For(0, 1000, _ =>
{
    lock (gate)
    {
        total++;
    }
});
```
- **임계 구역**을 간단 확실하게 보호.
- 단점: **병목/우발적 교착상태** 위험, 장시간 보유 금지(I/O 포함 X).

### `Interlocked` — 가벼운 원자 연산

```csharp
using System.Threading;

int total = 0;
Parallel.For(0, 1000, _ =>
{
    Interlocked.Increment(ref total); // 원자적 증가
});
```

- 제공: `Increment`, `Decrement`, `Add`, `Read`, `Exchange`, `CompareExchange`.
- **정수/참조 교체** 수준의 간단한 공유 상태에 탁월.
- 복합 상태 갱신은 **CAS 루프**로 구성:

```csharp
class Counter
{
    private int _value;

    public void Add(int delta)
    {
        int oldVal, newVal;
        do
        {
            oldVal = _value;
            newVal = oldVal + delta;
            // 다른 스레드가 _value를 바꿨으면 반복
        } while (Interlocked.CompareExchange(ref _value, newVal, oldVal) != oldVal);
    }
}
```

> 복잡한 불변 스냅샷 교체는 **copy-on-write**와 조합: 참조를 `CompareExchange`로 바꿔 끼우기.

---

## 스레드 안전 초기화: `Lazy<T>` / `LazyThreadSafetyMode`

```csharp
using System;

Lazy<Expensive> service = new Lazy<Expensive>(() => new Expensive());
// 기본: ExecutionAndPublication (멀티스레드 안전)
var s = service.Value;
```

- 모드:
  - `ExecutionAndPublication`(기본): 단 1회 생성 보장.
  - `PublicationOnly`: 여러 번 만들 수도 있으나 1개만 공개.
  - `None`: 단일 스레드/이미 보장된 경우에만.

**Singleton** 안전 구현 예:
```csharp
public sealed class Singleton
{
    private static readonly Lazy<Singleton> _inst = new(() => new Singleton());
    public static Singleton Instance => _inst.Value;
    private Singleton() { }
}
```

---

## 전략 — 락 대신 설계로 해결

- **불변 객체**는 생성 후 상태가 바뀌지 않는다. 읽기 경쟁이 없음.
- **System.Collections.Immutable**: `ImmutableDictionary`, `ImmutableArray`, `ImmutableList` …
- 패턴: **새 컬렉션을 복사-수정-교체**(copy-on-write) → 참조 한 번 바꾸는 건 `Interlocked.Exchange`로 원자적.

```csharp
using System.Collections.Immutable;
using System.Threading;

class Registry
{
    private ImmutableDictionary<string, string> _map = ImmutableDictionary<string, string>.Empty;

    public void Set(string k, string v)
    {
        ImmutableDictionary<string, string> oldMap, newMap;
        do
        {
            oldMap = _map;
            newMap = oldMap.SetItem(k, v);
        } while (Interlocked.CompareExchange(ref _map, newMap, oldMap) != oldMap);
    }

    public bool TryGet(string k, out string v) => _map.TryGetValue(k, out v!);
}
```

> 읽기 비율이 높고 쓰기가 드문 워크로드에 **매우 효율적**.

---

## ReaderWriterLockSlim / SemaphoreSlim / AsyncLocal

- **ReaderWriterLockSlim**: 읽기 다중/쓰기 단일 성격에서 성능 이점.
  ```csharp
  var rw = new System.Threading.ReaderWriterLockSlim();
  rw.EnterReadLock();   // 여러 읽기 동시 허용
  rw.ExitReadLock();
  rw.EnterWriteLock();  // 단일 쓰기
  rw.ExitWriteLock();
  ```
- **SemaphoreSlim**: 동시 허용 개수 N개(비동기 `WaitAsync` 지원).
- **AsyncLocal<T>**: 비동기 컨텍스트별 로컬 데이터 저장.

---

## 생산자-소비자: Channels로 더 현대적으로

```csharp
using System;
using System.Threading.Channels;
using System.Threading.Tasks;

class ChannelDemo
{
    static async Task Main()
    {
        var channel = Channel.CreateBounded<int>(100);

        var prod = Task.Run(async () =>
        {
            for (int i = 0; i < 1000; i++)
                await channel.Writer.WriteAsync(i);
            channel.Writer.Complete();
        });

        var cons = Task.Run(async () =>
        {
            await foreach (var item in channel.Reader.ReadAllAsync())
            {
                // 처리...
            }
        });

        await Task.WhenAll(prod, cons);
    }
}
```

- **고성능, 비동기 우선**. 백프레셔는 `Bounded` 용량으로 자연스레 처리.

---

## 파티셔닝과 PLINQ, Parallel.ForEachAsync

- **Partitioner**: 큰 컬렉션을 균형 있게 나누어 작업 분배 최적화.
- **PLINQ**: `AsParallel()`로 데이터 병렬화. 순서가 중요하면 `AsOrdered()`.
- **Parallel.ForEachAsync**(.NET 6+): 비동기 작업을 병렬로 실행.

```csharp
await Parallel.ForEachAsync(source, new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount },
    async (item, ct) =>
    {
        await ProcessAsync(item, ct);
    });
```

---

## 메모리 모델 핵심: `volatile`, `Thread.MemoryBarrier`, `Volatile.Read/Write`

- **가시성(visibility)** 보장: 한 스레드의 쓰기가 다른 스레드에 보이는 시점.
- `volatile` 필드는 **읽기/쓰기 재정렬 억제** + **가시성** 보장(참조/원시 값 수준).
- 고급: `Volatile.Read/Write`, 필요 시 `Thread.MemoryBarrier()`로 명시적 장벽.
  하지만 **가능하면 고수준 동기화(락/Interlocked/Concurrent*)를 우선**.

---

## 교착상태/활성교착/기아 방지 체크리스트

- **교착(Deadlock)** 4조건 중 하나를 깨라: 상호배제, 보유-대기, 비선점, 순환대기.
  - **락 순서 통일**, 타임아웃, 락 범위 최소화.
- **활성교착(Livelock)**: 양보 경쟁 회피(지수적 backoff 등).
- **기아(Starvation)**: 우선순위 역전 방지, 공정한 큐잉.

---

## 실전: 고성능 카운터/집계기 설계

### 단순 카운터 — `Interlocked`

```csharp
class FastCounter
{
    private long _value;
    public void Inc() => Interlocked.Increment(ref _value);
    public long Value => Interlocked.Read(ref _value);
}
```

### 키-값 집계 — `ConcurrentDictionary` + 불변 값

```csharp
record Stat(long Count, long Sum);

class Aggregator
{
    private readonly ConcurrentDictionary<string, Stat> _map = new();

    public void Add(string key, long value)
    {
        _map.AddOrUpdate(
            key,
            _ => new Stat(1, value),
            (_, old) => old with { Count = old.Count + 1, Sum = old.Sum + value }
        );
    }

    public bool TryGet(string key, out Stat stat) => _map.TryGetValue(key, out stat!);
}
```

> 값 타입을 **불변 record**로 두면 내부 상태 경쟁이 사라진다(새 인스턴스 교체).

---

## 성능 직감과 간단한 모델

- 스레드 안전 컬렉션 처리량을 추정할 때, 락 충돌 확률 \(p\)와 임계구역 비용 \(C\), 비임계 비용 \(U\)가 있으면 **평균 처리 시간**:

  $$ T \approx p \cdot (C + W) + (1 - p) \cdot U $$

  여기서 \(W\)는 대기 시간(큐잉). **p를 낮추거나 C를 줄이는 설계**(짧은 임계구역, 락-프리/부분락, 파티셔닝)가 곧 성능.

---

## 진단/튜닝 루틴

1. **경합 지점 찾기**: ETW/PerfView/Concurrency Visualizer/`dotnet-trace`.
2. **락 축소**: 큰 락 → 더 작은 스코프, 분할 락(strip/partition).
3. **읽기-집중 워크로드**: `ReaderWriterLockSlim` 또는 **Immutable + COW**.
4. **순서 불필요**: `ConcurrentBag`/`Stack` 고려.
5. **대량 파이프라인**: `BlockingCollection` 또는 **Channels**.
6. **간단 카운터**: `Interlocked` 우선.
7. **정리/해제**: `Dispose`, `CompleteAdding`, 취소 토큰 선제적 반영.

---

## 종합 예제 — 로그 파이프라인(생산자-소비자 + backpressure + 종료)

```csharp
using System;
using System.Collections.Concurrent;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

public sealed class LogPipeline : IDisposable
{
    private readonly BlockingCollection<string> _queue;
    private readonly CancellationTokenSource _cts = new();
    private readonly Task _writerTask;

    public LogPipeline(string path, int capacity = 10_000)
    {
        _queue = new BlockingCollection<string>(capacity);
        _writerTask = Task.Run(async () =>
        {
            using var sw = new StreamWriter(path, append: true);
            foreach (var line in _queue.GetConsumingEnumerable(_cts.Token))
            {
                await sw.WriteLineAsync(line);
            }
            await sw.FlushAsync();
        }, _cts.Token);
    }

    public bool TryLog(string msg) => _queue.TryAdd(msg); // 꽉 차면 false

    public void Complete()
    {
        _queue.CompleteAdding();
    }

    public void Dispose()
    {
        Complete();
        _cts.Cancel();
        try { _writerTask.Wait(3000); } catch { /* 무시 */ }
        _queue.Dispose();
        _cts.Dispose();
    }
}

// 사용
// var log = new LogPipeline("app.log");
// Parallel.For(0, 100_000, i => log.TryLog($"L{i}"));
// log.Dispose();
```

- **Bounded queue**로 생산 폭주 제한.
- 종료는 `CompleteAdding()` → 소비 루프 종료 → Flush.
- I/O는 **단일 쓰레드**로 직렬화하여 락 경쟁 최소화.

---

## 체크리스트

- [ ] 일반 컬렉션에 **동시 쓰기/열거 금지**
- [ ] 순서 중요? → Queue / 중요X? → Bag/Stack
- [ ] 키-값 동시 갱신은 **AddOrUpdate / TryUpdate** 사용
- [ ] 단순 정수/참조 갱신은 **Interlocked** 우선
- [ ] 긴 임계구역/IO는 **락 밖**으로
- [ ] 생산자-소비자에는 **BlockingCollection** 또는 **Channel**
- [ ] 읽기 위주라면 **Immutable + COW**
- [ ] `Lazy<T>`로 **지연 초기화 + 스레드 안전**
- [ ] 취소/종료 경로(`CompleteAdding`, `CancellationToken`) 문서화
- [ ] 성능 문제 시 **경합 지점/락 시간**부터 측정

---

## 요약

- **Concurrent* 컬렉션**은 올바른 기본값이다. 순서/패턴에 맞는 타입을 고르자.
- 락은 간단하지만 **짧고 얇게**. 가능하면 `Interlocked`/불변 전략을 먼저 검토.
- 생산자-소비자에는 **BlockingCollection/Channels**로 **backpressure**까지 포함해 설계.
- 스레드 안전은 “문법”이 아니라 “설계”다. **데이터 구조/작업 흐름/가시성**까지 한 번에 점검하라.
