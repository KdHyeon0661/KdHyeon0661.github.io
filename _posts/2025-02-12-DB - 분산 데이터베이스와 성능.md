---
layout: post
title: DB - 분산 데이터베이스와 성능
date: 2025-02-12 21:20:23 +0900
category: DB
---
# 분산 데이터베이스 성능 설계의 핵심 원리

## 분산 환경에서의 성능 모델 이해

분산 데이터베이스의 성능은 단일 인스턴스와 근본적으로 다른 특성을 가집니다. 응답 시간은 단순히 로컬 처리 능력뿐만 아니라 네트워크 통신, 합의 프로토콜, 데이터 위치와 같은 분산 환경의 고유한 요소들에 크게 영향을 받습니다.

분산 시스템에서의 지연 시간은 대략적으로 다음 네 가지 요소의 합으로 이해할 수 있습니다:
1.  **로컬 처리**: 쿼리 파싱, 실행 계획 수립, 실제 연산 수행에 소요되는 시간
2.  **원격 I/O**: 다른 샤드나 복제본에 저장된 데이터에 접근하는 데 필요한 시간
3.  **네트워크 통신**: 노드 간 데이터 왕복에 소요되는 지연(RTT)과 통신 횟수
4.  **동기화 비용**: 합의 프로토콜 실행, 쿼럼 기반 읽기/쓰기, 트랜잭션 커밋 보장에 필요한 오버헤드

처리량(Throughput)의 관점에서는 일반적으로 더 많은 샤드와 노드를 추가함으로써 선형적으로 향상시킬 수 있지만, 이는 네트워크와 합의 프로토콜의 추가 비용이 증가하지 않을 때의 이야기입니다. 실제 시스템에서는 샤드 수가 증가함에 따라 이러한 분산 조정 비용이 함께 증가하여 이득이 점점 줄어들게 됩니다.

---

## 샤딩 전략: 데이터 분배의 과학과 예술

### 샤딩 키 설계의 세 가지 핵심 원칙

1.  **균등성**: 데이터와 작업 부하가 모든 샤드에 고르게 분배되어야 합니다. 해시 기반 샤딩이 선호되는 이유는 이 균등성을 보장하기相对容易하기 때문입니다. 균등하지 않은 분배는 특정 샤드가 과도한 부하를 받는 '핫스팟'을 생성하여 시스템 전체의 성능을 저하시킵니다.

2.  **지역성**: 범위 기반 쿼리(특정 기간의 데이터 조회 등)가 빈번한 경우, 범위 샤딩이 더 효율적일 수 있습니다. 그러나 이는 시간 순차적인 데이터가 모두 같은 샤드에 집중되어 핫스팟을 유발할 위험이 있습니다.

3.  **직접성**: 주어진 키가 어떤 샤드에 위치하는지 빠르고 명확하게 결정할 수 있어야 합니다. 복잡한 라우팅 로직은 추가적인 지연과 복잡성을 초래합니다.

**샤딩 키의 균등성 확보 전략**
단조 증가하는 키(예: 자동 증가 ID, 타임스탬프)를 그대로 샤딩 키로 사용하면 모든 새로운 데이터가 마지막 샤드로만 쓰여지게 됩니다. 이를 방지하기 위해 '버킷팅' 또는 '해시 프리픽스' 기법을 사용합니다.

```javascript
// 단순 증가 ID 대신 해시 프리픽스를 추가한 복합 키
function createShardKey(userId) {
  const prefixBucket = murmur3Hash(userId) % 128; // 0-127 버킷
  return {
    shard_prefix: prefixBucket,
    user_id: userId,
    created_at: Date.now()
  };
}
// 샤딩 키: { shard_prefix: 42, user_id: "u12345", created_at: 1730899200000 }
```
이렇게 하면 `user_id`의 해시값에 기반한 프리픽스가 데이터를 여러 샤드에 분산시키는 역할을 하면서도, 특정 사용자의 모든 데이터는 동일한 프리픽스를 공유하여 함께 위치하게 됩니다.

### 코로케이션: 관련 데이터의 물리적 그룹화

성능 최적화의 중요한 전략은 함께 자주 접근되는 데이터를 같은 샤드에 위치시키는 것입니다. 예를 들어, 특정 고객의 주문, 장바구니 항목, 결제 이벤트를 모두 `customer_id`로 샤딩하면, 해당 고객에 대한 모든 작업이 단일 샤드 내에서 처리될 수 있습니다. 이를 '코로케이션'이라 하며, 샤드 간 조인이나 분산 트랜잭션의 복잡성과 비용을 크게 줄여줍니다.

---

## 일관성 모델과 성능의 트레이드오프

분산 시스템에서는 네트워크 지연, 노드 장애와 같은 현실적 제약으로 인해 '완벽한' 일관성, 낮은 지연, 높은 가용성을 동시에 달성하는 것이 이론적으로 불가능합니다(CAP 정리). 따라서 각 애플리케이션의 요구사항에 맞는 적절한 일관성 수준을 선택하는 것이 성능 설계의 핵심입니다.

**실무에서의 일관성 수준 선택지**
*   **강한 일관성(선형화)**: 모든 읽기가 가장 최근에 성공한 쓰기의 결과를 반환함을 보장합니다. 이는 일반적으로 동기식 합의를 필요로 하여 쓰기 지연이 가장 높지만, 프로그래밍 모델이 단순합니다. 금융 거래나 재고 관리와 같은 시스템에 필요합니다.
*   **제한된 지연 일관성**: 읽기가 지정된 시간(예: 5초) 또는 버전 수 이내의 최신 데이터를 보장합니다. 강한 일관성보다 낮은 지연을 제공하면서도 예측 가능한 데이터 신선도를 유지합니다.
*   **최종 일관성**: 쓰기 후 일정 시간이 지나면 모든 복제본이 동일한 상태로 수렴함을 보장합니다. 가장 높은 가용성과 가장 낮은 지연을 제공하지만, 읽기 시 오래된 데이터를 볼 수 있습니다. 소셜 미디어 피드, 댓글 카운트 등에 적합합니다.

선택은 비즈니스 로직이 얼마나 최신 데이터에 의존하는지에 달려 있습니다. "사용자의 장바구니"는 강한 일관성이 필요할 수 있지만, "사이트의 총 방문자 수"는 최종 일관성으로 충분할 수 있습니다.

---

## 분산 트랜잭션: 2PC와 SAGA 패턴

여러 샤드에 걸친 데이터를 원자적으로 업데이트해야 할 때, 두 가지 주요 패러다임이 있습니다.

**2단계 커밋(2PC)**
전통적인 방식으로, 트랜잭션 코디네이터가 모든 참여 샤드에게 준비(1단계)를 요청하고, 모두 성공하면 커밋(2단계)을 지시합니다. 이는 강한 원자성을 보장하지만, 단점이 명확합니다: 코디네이터 장애 시 복구가 복잡하며, 모든 참여자가 응답할 때까지 블로킹되어 지연 시간이 길어집니다.

**SAGA 패턴**
하나의 큰 트랜잭션을 일련의 작은 로컬 트랜잭션으로 분해하고, 각 로컬 트랜잭션은 실패 시 이를 보상하는 '보상 트랜잭션'을 가지고 있습니다. 예를 들어, '주문 생성' SAGA는 재고 확인 → 결제 승인 → 배송 생성의 단계로 이루어질 수 있습니다. 만약 배송 생성 단계에서 실패하면, 이전에 성공한 결제 승인을 취소하는 보상 트랜잭션이 실행됩니다.

*   **2PC 선택 시기**: 데이터 범위가 작고, 강한 원자성이 절대적으로 필요한 핵심 비즈니스 로직(예: 계좌 이체)에 사용합니다.
*   **SAGA 선택 시기**: 여러 서비스에 걸쳐 있고, 고가용성과 저지연이 중요한 장시간 실행 프로세스(예: 여행 예약, 전자상거래 주문 처리)에 적합합니다.

---

## 지리적 분산과 지연 최적화

글로벌 서비스를 운영할 때, 사용자와 데이터 센터 사이의 물리적 거리는 성능에 결정적인 영향을 미칩니다. 한국 사용자가 미국 서버에 저장된 데이터를 조회할 때 발생하는 수백 ms의 지연은 사용자 경험에 치명적일 수 있습니다.

**지연 최소화 전략**
1.  **데이터 지역화**: 사용자의 데이터를 해당 사용자가 위치한 지리적 리전에 저장합니다. 예를 들어, 아시아 태평양 사용자의 데이터는 서울 또는 도쿄 리전의 샤드에 위치시킵니다.
2.  **읽기 복제본 활용**: 쓰기는 주 리전에서 처리하되, 읽기는 사용자와 가장 가까운 리전의 읽기 전용 복제본에서 처리합니다.
3.  **지연 예산 관리**: 서비스 수준 계약(SLA)으로 p95 응답 시간이 200ms라면, 이 중 데이터베이스 왕복에 할당할 수 있는 시간은 얼마인지 계산합니다. 만약 애플리케이션 로직과 네트워크가 100ms를 소모한다면, 데이터베이스 작업은 100ms 내에 완료되어야 합니다. 이 예산은 크로스 리전 호출이 허용되는지 여부를 판단하는 기준이 됩니다.

---

## 모니터링과 용량 계획

분산 데이터베이스의 성능은 정적이지 않습니다. 데이터 양의 증가, 접근 패턴의 변화, 인프라의 재배치는 지속적으로 성능에 영향을 미칩니다.

**핵심 모니터링 지표**
*   **지연 시간**: p50, p95, p99 응답 시간을 샤드별, 쿼리 유형별로 모니터링합니다. p99의 급격한 상승은 특정 샤드의 핫스팟이나 네트워크 문제를 의미할 수 있습니다.
*   **처리량**: 샤드별 초당 쿼리 수(QPS)를 추적하여 부하의 균형을 확인합니다.
*   **노드 건강도**: CPU, 메모리, 디스크 I/O, 네트워크 대역폭 사용률을 모니터링합니다.
*   **분산 특정 메트릭**: 합의 프로토콜 지연, 리더 선출 빈도, 데이터 재밸런싱 상태 등을 추적합니다.

**부하 테스트와 용량 계획**
실제 트래픽 패턴(읽기/쓰기 비율, 핫/콜드 데이터 분포)을 반영한 부하 테스트를 정기적으로 수행해야 합니다. 이를 통해 다음과 같은 질문에 답할 수 있습니다:
*   현재 인프라로 얼마나 많은 트래픽을 처리할 수 있는가?
*   트래픽이 2배로 증가하면 어떤 컴포넌트가 병목이 될 것인가?
*   새로운 샤드를 추가할 때 예상되는 재밸런싱 시간과 성능 영향은 얼마인가?

---

## 결론: 분산 데이터베이스 성능 설계의 철학

분산 데이터베이스의 성능 최적화는 단일 기술이나 설정을 조정하는 문제가 아니라, 시스템 아키텍처에 대한 근본적인 사고의 전환을 요구합니다. 성공적인 설계는 다음과 같은 질문에 명확한 답을 가지고 시작합니다:

1.  **무엇을 분산할 것인가?** (샤딩 키 선택) — 데이터와 작업 부하를 고르게 분산시켜 핫스팟을 피하면서도, 함께 접근되는 데이터는 물리적으로 가깝게 유지할 수 있는 키는 무엇인가?
2.  **어느 정도의 일관성을 유지할 것인가?** — 각 비즈니스 작업에 대해 데이터의 '신선함'에 대한 요구사항은 무엇이며, 이를 위해 얼마나 많은 지연을 감수할 수 있는가?
3.  **네트워크 비용을 어떻게 상쇄할 것인가?** — 지리적 지연을 최소화하기 위해 데이터와 컴퓨팅을 사용자에게 얼마나 가까이 배치할 수 있는가?

이러한 질문에 대한 답은 추상적인 원칙이 아니라, **지연 예산**이라는 구체적인 숫자로 표현되어야 합니다. "이 쿼리는 p95 150ms 내에 완료되어야 한다"는 목표는, 샤딩 전략이 단일 샤드 내에서 실행 가능하게 할 것인지, 크로스 리전 호출이 허용되는지와 같은 모든 후속 설계 결정을 이끌어냅니다.

분산 데이터베이스는 규모에 따른 힘을 제공하지만, 그 힘은 복잡성이라는 대가와 함께 옵니다. 이 복잡성을 관리하는 열쇠는 단순함에 있습니다: 비즈니스 요구사항에서 출발한 명확한 설계 원칙, 지속적인 모니터링을 통한 현실 인식, 그리고 데이터 성장과 함께 진화할 수 있는 유연한 아키텍처입니다.