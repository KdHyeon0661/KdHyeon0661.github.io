---
layout: post
title: DB 심화 - 인덱스 파티셔닝 선택
date: 2025-11-24 21:25:23 +0900
category: DB 심화
---
# Oracle **인덱스 파티셔닝 선택 가이드**

**주제**:
1) **글로벌 파티션 인덱스(GPI)의 효용성**
2) **로컬 Non-Prefixed 파티션 인덱스의 효용성**
3) **액세스 효율을 고려한 인덱스 파티셔닝 선택 기준**
4) **인덱스 파티셔닝 제약을 반영한 데이터베이스 설계 전략**

> 목표: “**왜/언제** GPI(글로벌) 또는 로컬 non-prefixed가 유리한지”를 **쿼리 패턴 관점**에서 설명하고,
> **DDL/실습 코드**로 성능 차이를 체감할 수 있도록 안내합니다.
> 기본 전제: B-tree 중심(필요시 Bitmap 코멘트), Oracle 11g+.

---

## 공통 실습 스키마

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';

-- 1) 월별 RANGE 파티션: 대용량 팩트 테이블 가정
DROP TABLE fact_sales PURGE;
CREATE TABLE fact_sales (
  sales_id   NUMBER       NOT NULL,
  sales_dt   DATE         NOT NULL,
  cust_id    NUMBER       NOT NULL,
  region_cd  VARCHAR2(6)  NOT NULL,
  amount     NUMBER(12,2) NOT NULL,
  CONSTRAINT pk_fact_sales PRIMARY KEY (sales_id)  -- (기본키 인덱스: 글로벌 non-partitioned로 생성)
)
PARTITION BY RANGE (sales_dt) (
  PARTITION p2025m01 VALUES LESS THAN (DATE '2025-02-01'),
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01'),
  PARTITION p2025m03 VALUES LESS THAN (DATE '2025-04-01'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

-- 2) 고객/달력 차원 (비파티션)
DROP TABLE dim_customer PURGE;
CREATE TABLE dim_customer (
  cust_id      NUMBER PRIMARY KEY,
  region_group VARCHAR2(10),
  grade        VARCHAR2(10),
  active_yn    CHAR(1)
);

DROP TABLE dim_calendar PURGE;
CREATE TABLE dim_calendar (
  cal_dt      DATE PRIMARY KEY,
  y           NUMBER,
  m           NUMBER,
  is_weekend  CHAR(1)
);

-- 3) 샘플 데이터
INSERT INTO dim_customer VALUES (101,'APAC','GOLD','Y');
INSERT INTO dim_customer VALUES (202,'AMER','SILVER','Y');
INSERT INTO dim_customer VALUES (303,'EMEA','BRONZE','N');

INSERT INTO dim_calendar VALUES (DATE '2025-02-10', 2025,2,'N');
INSERT INTO dim_calendar VALUES (DATE '2025-02-11', 2025,2,'N');
INSERT INTO dim_calendar VALUES (DATE '2025-03-01', 2025,3,'Y');

INSERT INTO fact_sales VALUES (1, DATE '2025-02-10', 101, 'KR', 100.00);
INSERT INTO fact_sales VALUES (2, DATE '2025-02-11', 202, 'US', 170.00);
INSERT INTO fact_sales VALUES (3, DATE '2025-03-01', 202, 'US', 250.00);
COMMIT;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'FACT_SALES');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_CUSTOMER');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_CALENDAR');
END;
/
```

---

# **글로벌 파티션 인덱스(GPI)의 효용성**

## 개념 리캡

- **Global Partitioned Index**: **인덱스만** 독립적으로 파티셔닝(RANGE/HASH)한 구조.
- 장점 요약
  - **전역 유일성** 보장(Unique Global Index 가능).
  - **경합 분산**: 해시/범위로 인덱스 세그먼트를 분산 → 핫 루트/브랜치 경합 완화.
  - **병렬/대용량 스캔**에 유리: 인덱스 파티션별 병렬 작업 자연스러움.
  - **비(非)파티션 키 중심 조건**(예: `cust_id = :b`)에도 **분산/스루풋 개선**.

> 단점/주의: 테이블 파티션 DDL(일부 DROP/TRUNCATE/SPLIT/EXCHANGE 등) 후 **UNUSABLE** 될 수 있어 **정책적 유지보수**(UPDATE GLOBAL INDEXES vs 재빌드)가 필요.

## GPI-HASH: **조인/필터가 고객 중심일 때**

```sql
-- 고객 기반 탐색량이 큰 환경: cust_id 기준으로 인덱스 해시 파티셔닝
CREATE INDEX fact_sales_gpi_hash
  ON fact_sales(cust_id, sales_dt)                 -- 리딩: cust_id (조인/필터)
  GLOBAL PARTITION BY HASH (cust_id)
  PARTITIONS 8;

-- 고객 중심 집계: 날짜 조건 없이 cust_id만 줄어드는 쿼리(OLAP/대시보드의 상위 고객 탐색 등)
EXPLAIN PLAN FOR
SELECT /*+ INDEX(f fact_sales_gpi_hash) */
       cust_id, COUNT(*) cnt, SUM(amount) amt
FROM   fact_sales f
WHERE  cust_id = 202
GROUP  BY cust_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PREDICATE +PARTITION'));
/*
효과 포인트:
- HASH 파티션 분산으로 특정 파티션(들)만 접근 → 인덱스 레벨 경합/스캔 분할
- 날짜 프루닝은 불가(테이블 파티션은 여전히 다수 접근 가능) → 하지만 인덱스 접근 분산/동시성이 장점
*/
```

> **언제 유용한가?**
> - **날짜 조건이 빈약하거나 없음**(= 테이블 파티션 프루닝이 약함).
> - **조인 키/필터 키(=cust_id)** 중심 접근이 잦음.
> - **DW/PQ 환경**에서 인덱스 병렬성이 중요.

## GPI-RANGE: **범주/금액대별 분산**

```sql
-- 금액대 RANGE 전역 인덱스 (데모 목적)
CREATE INDEX fact_sales_gpi_range
  ON fact_sales(amount, sales_dt)
  GLOBAL PARTITION BY RANGE (amount) (
    PARTITION gpi_low  VALUES LESS THAN (100),
    PARTITION gpi_mid  VALUES LESS THAN (1000),
    PARTITION gpi_high VALUES LESS THAN (MAXVALUE)
  );

-- 금액대 질의: 특정 금액대만 집중 스캔
EXPLAIN PLAN FOR
SELECT /*+ INDEX(f fact_sales_gpi_range) */
       COUNT(*)
FROM   fact_sales f
WHERE  amount BETWEEN 50 AND 99.99;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
/*
효과 포인트:
- 인덱스 파티션 레벨에서 스캔 범위를 좁힘(인덱스 파티션 프루닝)
- 테이블 파티션 프루닝(날짜)은 별개. 금액대 중심 탐색이 잦으면 유리.
*/
```

## GPI 유지보수 정책(필수)

```sql
-- 테이블 파티션 작업 시 전역 인덱스 unusable 방지/회복
ALTER TABLE fact_sales TRUNCATE PARTITION p2025m01 UPDATE GLOBAL INDEXES;
-- 또는 사후 재빌드
ALTER INDEX fact_sales_gpi_hash  REBUILD ONLINE;
ALTER INDEX fact_sales_gpi_range REBUILD PARTITION gpi_mid ONLINE;

-- 점검
SELECT index_name, status FROM user_indexes WHERE table_name='FACT_SALES';
```

---

# **로컬 Non-Prefixed 파티션 인덱스의 효용성**

## 개념 리캡

- **Local Partitioned Index**: 테이블 파티션과 **1:1로 맞물리는** 인덱스(파티션당 인덱스 세그먼트).
- **Non-Prefixed**: 인덱스 키의 **선두**가 테이블 파티션 키가 **아님**.
  - 예: 테이블 파티션 키 = `sales_dt`, 인덱스 = `(cust_id, sales_dt)`.

> 장점
> - **차원 키 선두(조인/필터)** + **테이블 파티션 프루닝**을 **동시에** 노림.
> - 날짜 조건이 있으면 **테이블/인덱스 파티션 프루닝**이 되고, 파티션 내부에선 **cust_id 선두 인덱스 range**가 적용.
> - **유지보수 용이**: 테이블 파티션 DDL 시 자동 정합(로컬의 최대 장점).

> 유의
> - 날짜 조건이 **없으면** 여러 인덱스 파티션을 **모두** 건드릴 수 있음(=Prefixed보다 프루닝 신호가 약함).
> - 로컬 **UNIQUE**는 테이블 파티션 키를 **반드시 포함**해야 함(규칙).

## Non-Prefixed 로컬 인덱스 생성/활용

```sql
-- Non-Prefixed Local: 리딩 컬럼 = cust_id
CREATE INDEX fact_sales_lix_nonpref
  ON fact_sales(cust_id, sales_dt)
  LOCAL;   -- 인덱스도 테이블과 동일 파티셔닝

-- (패턴 A) 날짜 + 고객 조건: 이상적 케이스
EXPLAIN PLAN FOR
SELECT /* 날짜 + 고객 → 파티션 프루닝 + cust range */
       SUM(amount)
FROM   fact_sales
WHERE  sales_dt >= DATE '2025-02-01' AND sales_dt < DATE '2025-03-01'
AND    cust_id = 202;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
/*
기대:
- PARTITION RANGE SINGLE (p2025m02만)
- 파티션 내부에서 INDEX RANGE SCAN by cust_id (리딩 컬럼)
*/

-- (패턴 B) 고객만 있을 때: 여러 인덱스 파티션 접근 가능(날짜 조건 없으므로)
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   fact_sales
WHERE  cust_id = 202;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
/*
기대:
- 다수 파티션 접근 가능성
- 그러나 로컬 구조 덕분에 파티션별 동시성/병렬로 완화 가능
*/
```

## 스타쿼리/차원 선행 조인과의 궁합

```sql
-- 차원 선행 → 해시 조인 → 조인필터(블룸) → 런타임 파티션 프루닝까지 기대
EXPLAIN PLAN FOR
SELECT /*+ LEADING(c) USE_HASH(f) */
       SUM(f.amount)
FROM   dim_customer c
JOIN   fact_sales  f
  ON   f.cust_id = c.cust_id
WHERE  c.grade IN ('GOLD','SILVER')
AND    f.sales_dt BETWEEN DATE '2025-02-01' AND DATE '2025-03-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +NOTE'));
/*
관찰:
- JOIN FILTER CREATE(USE) 표기
- f에 대해 PARTITION RANGE SINGLE + 파티션 내부 cust_id 선두 인덱스 range
- Non-Prefixed 로컬의 장점 극대화(조인키 리딩 + 파티션 프루닝 동시)
*/
```

---

# **액세스 효율을 고려한 인덱스 파티셔닝 선택 기준**

## 의사결정 매트릭스(현업 요약)

| 상황/요구 | 추천 인덱스 | 근거 |
|---|---|---|
| **날짜 범위 필터가 항상 있다**(로그성/시계열) | **로컬 Prefixed** `(sales_dt, …)` | 파티션/인덱스 프루닝이 가장 직접적. Range Scan 효율 최고. 유지보수 자동. |
| **차원키(=cust_id) 필터 + 날짜 필터가 자주 동시에 있다** | **로컬 Non-Prefixed** `(cust_id, sales_dt)` + (필요시) Prefixed 병행 | 파티션 프루닝(날짜) + 파티션 내부 조인키 range. 두 패턴 공존시 **두 인덱스 병행**이 현실적. |
| **차원키만으로 조회**하는 패턴이 많다(날짜 필터 적음) | **GPI-HASH (cust_id 해시)** | 테이블 파티션 프루닝은 약하지만 인덱스 분산/병렬/경합완화로 스루풋↑. |
| **금액대/범주 기반 대량 필터** | **GPI-RANGE (amount 등)** | 인덱스 파티션 프루닝으로 대량 범주 스캔 최적화. |
| **전 기간 유일성**(클러스터 전역 PK/UK) | **Global Unique**(non-partitioned 또는 GPI Unique) | 로컬 UNIQUE는 파티션 키 포함 제약. 전역 유일은 글로벌이 자연스러움. |
| **파티션 DDL이 매우 빈번** | **로컬 인덱스 우선** | 글로벌은 UNUSABLE 관리 필요. 로컬은 자동 정합. |
| **DW/PQ, 스타 변환** | **로컬 Bitmap**(차원키), **Non-Prefixed 로컬**(조인키 선두) + 조인필터 | 읽기 중심·카디널리티 낮을 때 강력. DML 빈번시 Bitmap은 지양. |

## 체크리스트(작성/튜닝 포인트)

- **항상 존재하는 필터**를 **리딩 컬럼**으로:
  - 날짜 중심이면 **Prefixed Local**(예: `(sales_dt, region_cd, …)`).
  - 조인키 중심이면 **Non-Prefixed Local**(예: `(cust_id, sales_dt)`).
- **파티션 프루닝 신호**를 깨지 말 것: 파티션 키에 **함수/묵시적 형변환** X.
- **혼합 패턴**이면 **보완 인덱스**를 **둘 이상**: Prefixed + Non-Prefixed 병행.
- **GPI**는 **테이블 DDL 정책**(UPDATE GLOBAL INDEXES/재빌드 배치)을 **먼저** 설계.
- **DW에서 Bitmap**: 저선택도/읽기중심/배치적재에만. OLTP 대량 DML엔 비적합.
- **컴포지트 파티션**(RANGE×HASH 등)이라면 인덱스도 **동일 축** 정렬(상-하위 프루닝 동시 유도).

---

# **인덱스 파티셔닝 제약을 고려한 데이터베이스 설계**

## 유일성/제약 설계

```sql
-- (규칙) 로컬 UNIQUE 인덱스는 '테이블 파티션 키' 포함이 필수
-- 잘못된 예: (sales_id)만으로 로컬 UNIQUE 불가
-- 올바른 예:
CREATE UNIQUE INDEX fact_sales_u_local
  ON fact_sales(sales_dt, sales_id)  -- 파티션 키(sales_dt) 포함
  LOCAL;

-- 전 기간 유일성은 글로벌 쪽이 자연스러움
CREATE UNIQUE INDEX fact_sales_u_global ON fact_sales(sales_id);
```
- **PK/UK** 설계에서 “전 기간 유일 vs 파티션 내부 유일”을 **명확히 정의**해야 함.
- 전 기간 유일은 **Global Unique**가 간단. 로컬 UNIQUE는 키에 파티션 키 포함이 전제.

## 파티션 DDL/ETL 설계

```sql
-- 교체/아카이브: EXCHANGE PARTITION → 로컬 인덱스 자동 정합
ALTER TABLE fact_sales EXCHANGE PARTITION p2025m02 WITH TABLE fact_sales_stage WITHOUT VALIDATION;

-- 글로벌 인덱스 유지 전략(둘 중 택1 또는 혼합)
-- (A) DDL 즉시 유지 (느리지만 즉시 일관)
ALTER TABLE fact_sales TRUNCATE PARTITION p2025m01 UPDATE GLOBAL INDEXES;

-- (B) 사후 배치 재빌드 (DDL 빠름, 배치 비용)
ALTER INDEX fact_sales_gpi_hash REBUILD ONLINE;
```

## 액세스 패턴 주도 스키마 설계

- **항상 날짜 필터** → **RANGE 파티션(월/일)** + **Prefixed Local** 기본.
- **테넌트/고객 중심 분산** 강함 → **GPI-HASH(cust_id)** 또는 **서브파티션 HASH(cust_id)**.
- **혼합 패턴** → **로컬 Non-Prefixed** + **Prefixed** **공존**.
- **부분 인덱싱(12c+)**: 오래된 파티션은 **INDEXING OFF**로 유지비 절감(핫 파티션만 인덱스 보유).

```sql
-- 부분 인덱싱 개념(버전/옵션에 따라 문법 상이, 아이디어 차원)
-- ALTER TABLE fact_sales MODIFY PARTITION p2024m01 INDEXING OFF;
```

## 스타 스키마/조인 필터 고려

- 차원 선행(LEADING) + 해시 조인(USE_HASH)으로 **JOIN FILTER** 생성 →
  **로컬 Non-Prefixed**의 파티션 프루닝 + 조인키 Range Scan 조합 **극대화**.
- PQ(Parallel Query) 환경이면 조인 필터 프루닝 효과가 더욱 선명.

## 운영 관점 To-Do

- **통계**: 파티션/글로벌 통계 **동시에** 관리(글로벌 통계 누락 시 플랜 왜곡).
- **모니터링**: 파티션 접근/인덱스 파티션 접근량(ASH/AWR, V$SEGMENT_STATISTICS) 확인.
- **플랜 점검**: `DBMS_XPLAN.DISPLAY_CURSOR(… '+PARTITION +PREDICATE +NOTE')`로
  **PSTART/PSTOP**, `JOIN FILTER CREATE/USE`, `KEY(INLIST)` 등을 상시 확인.

---

# 엔드-투-엔드 시나리오(실전 조합)

## “날짜+고객” 복합 패턴 지배적

- 인덱스:
  - **Prefixed Local** `(sales_dt, amount)` : 날짜 범위+정렬/Top-N
  - **Non-Prefixed Local** `(cust_id, sales_dt)` : 고객 조건 동반 시
- 쿼리 예
```sql
-- Top-N (소트 대체: Prefixed Local + amount DESC 인덱스 고려)
SELECT /*+ INDEX(f fact_sales_lix_pref?) */
       *
FROM   (
  SELECT f.*
  FROM   fact_sales f
  WHERE  f.sales_dt BETWEEN DATE '2025-02-01' AND DATE '2025-02-28'
  ORDER  BY f.amount DESC
)
WHERE  ROWNUM <= 100;

-- 고객 Top, 특정 월
SELECT /* Non-Prefixed Local 활용 */
       cust_id, SUM(amount)
FROM   fact_sales
WHERE  sales_dt BETWEEN DATE '2025-02-01' AND DATE '2025-02-28'
AND    cust_id IN (101,202)
GROUP  BY cust_id;
```

## “고객만” 또는 “금액대” 중심 탐색 다수

- 인덱스:
  - **GPI-HASH(cust_id)** + (보조로) 로컬 `(sales_dt, …)`
  - 또는 **GPI-RANGE(amount)**
- 쿼리 예
```sql
-- 날짜 조건이 없다(또는 약하다): GPI-HASH로 인덱스 분산 스캔
SELECT /*+ INDEX(f fact_sales_gpi_hash) */ COUNT(*)
FROM   fact_sales f
WHERE  cust_id = :cid;

-- 금액대 리포트: GPI-RANGE 프루닝
SELECT /*+ INDEX(f fact_sales_gpi_range) */ COUNT(*)
FROM   fact_sales f
WHERE  amount BETWEEN :low AND :high;
```

---

# 트러블슈팅/검증 팁

```sql
-- 실제 실행 플랜 확인(권장)
ALTER SESSION SET statistics_level = ALL;

SELECT /*+ MONITOR */ SUM(f.amount)
FROM   dim_customer c
JOIN   fact_sales  f
  ON   f.cust_id = c.cust_id
WHERE  c.grade IN ('GOLD','SILVER')
AND    f.sales_dt BETWEEN DATE '2025-02-01' AND DATE '2025-03-01';

SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'BASIC +ALIAS +PARTITION +PREDICATE +NOTE'));
/*
확인 포인트
- PARTITION RANGE [SINGLE/ITERATOR]
- PSTART/PSTOP = 2 2  (단일 파티션) 또는 범위
- JOIN FILTER CREATE / USE (조인필터 생성/사용)
- 인덱스 액세스: 로컬 Non-Prefixed면 파티션 내부 cust_id range scan 기대
- GPI면 인덱스 파티션 프루닝/분산 확인
*/
```

**프루닝이 약할 때 체크**
- 파티션 키에 **함수/형변환**이 걸렸는가?
- **리딩 컬럼**과 **항상 있는 필터**가 일치하는가?
- 글로벌 인덱스 **UNUSABLE**는 아닌가? (DDL 이후 점검)
- 통계 최신/균형 여부(파티션/글로벌 모두).

---

# 요약: 선택의 핵심

- **GPI의 효용성**:
  - 날짜 필터가 희박하고 **조인키/범주 중심** 탐색이 잦을 때,
  - **경합 분산/병렬/전역 유일**이 필요할 때 **탁월**.
  - 단, 테이블 DDL과 **운명 공동체** → **유지보수 정책 필수**.

- **로컬 Non-Prefixed의 효용성**:
  - “**날짜 + 차원키**” **동시** 필터가 많을 때 **베스트**(프루닝 + 리딩컬럼 range).
  - 날짜가 없을 땐 다수 파티션 접근 위험, 그러나 로컬이라 **자동 정합/병렬**로 완충.

- **선택 기준**:
  1) **항상 있는 필터**를 리딩 컬럼으로(날짜면 Prefixed Local, 조인키면 Non-Prefixed Local).
  2) **날짜가 약하고 조인키 강함** → **GPI-HASH**. 범주/금액대 중심 → **GPI-RANGE**.
  3) **혼합 패턴** → **보완 인덱스 공존**(Prefixed + Non-Prefixed + 상황별 GPI).
  4) 유지보수/ETL/EXCHANGE/아카이브 패턴 → **로컬 우선**, 글로벌은 **정책 동반**.

- **설계 반영**:
  - 유일성 요구(전 기간 vs 파티션 내부), 파티션 DDL 빈도, 통계/플랜/조인필터 전략을
    **스키마/인덱스/배치정책**에 **처음부터** 녹여라.

> 한 줄 결론: **“항상 있는 필터가 리딩 컬럼” + “파티션 프루닝 신호 보존”**이 성능 절반을 먹고 들어갑니다.
> 나머지 절반은 **GPI/로컬의 장단을 쿼리 패턴에 맞게 공존**시키는 **설계/운영의 기술**입니다.
