---
layout: post
title: DB 심화 - 인덱스 파티셔닝 선택
date: 2025-11-24 21:25:23 +0900
category: DB 심화
---
# Oracle 인덱스 파티셔닝 선택 가이드 — GPI vs 로컬 Non-Prefixed, 액세스 패턴 기반 설계/튜닝

**주제**
1) **글로벌 파티션 인덱스(GPI)의 효용성**  
2) **로컬 Non-Prefixed 파티션 인덱스의 효용성**  
3) **액세스 효율 관점의 선택 기준**  
4) **제약(유일성/유지보수/ETL)까지 포함한 설계 전략**  

---

## 0) 먼저 용어를 “단단하게” 고정하자

### 0.1 테이블 파티션 vs 인덱스 파티션

- **테이블 파티션**은 데이터(ROWID) 자체를 **물리적으로 분할**한다.  
  → 프루닝(Partition Pruning)으로 읽어야 할 데이터 범위를 크게 줄이는 게 1차 목적이다. :contentReference[oaicite:0]{index=0}
- **인덱스 파티션**은 인덱스 구조를 **세그먼트/파티션 단위로 나눠** 관리·동시성·스캔 분할을 노린다.  
  하지만 **인덱스 파티셔닝에서의 “프루닝 가능성”은 인덱스 타입(로컬/글로벌, prefixed 여부)에 따라 다르게 열리고 닫힌다.** :contentReference[oaicite:1]{index=1}

### 0.2 Local vs Global

- **Local Partitioned Index (로컬)**  
  테이블 파티션과 **1:1로 맞물려** 인덱스 파티션이 생긴다.  
  → 테이블 파티션 DDL(ADD/DROP/TRUNCATE/EXCHANGE/SPLIT 등)과 **운명 공동체**라서 **자동 정합/유지보수 용이**가 핵심 장점. :contentReference[oaicite:2]{index=2}

- **Global (Partitioned) Index = GPI(글로벌 파티션 인덱스)**  
  인덱스가 **테이블 파티션과 독립적으로** RANGE/HASH로 파티셔닝된다.  
  → “테이블은 날짜로 RANGE, 인덱스는 고객으로 HASH” 같은 **교차 축 설계**가 가능하다. :contentReference[oaicite:3]{index=3}

### 0.3 Prefixed vs Non-Prefixed (이건 “로컬 인덱스에서만” 의미가 크다)

- **Prefixed Local Index**  
  인덱스 키의 선두가 **테이블 파티션 키**와 일치(또는 그 부분집합)한다.  
  → `WHERE 파티션키 = ...`가 있으면 **인덱스 파티션 프루닝이 매우 직접적**이다. :contentReference[oaicite:4]{index=4}

- **Non-Prefixed Local Index**  
  인덱스 키 선두가 **파티션 키가 아니다.**  
  예) 테이블 파티션 키 = `sales_dt`, 인덱스 = `(cust_id, sales_dt)`  
  → **파티션 키로 프루닝을 하면서도 파티션 내부에서는 조인키/필터키(cust_id)로 Range Scan**을 먹이는 “하이브리드” 전략이다. :contentReference[oaicite:5]{index=5}

> **중요한 제약 3개**  
> 1) **Unique Local Non-Prefixed는 파티션 키가 인덱스 키에 포함돼야만 가능**(전역 유일성 불가) :contentReference[oaicite:6]{index=6}  
> 2) **Global Index는 테이블 파티션 DDL 이후 UNUSABLE이 될 수 있으므로 유지 정책이 필수** :contentReference[oaicite:7]{index=7}  
> 3) “prefixed/non-prefixed” 개념은 **로컬 인덱스의 프루닝 성질을 설명하기 위한 것**이지, GPI의 핵심 분류축은 아니다. :contentReference[oaicite:8]{index=8}  

---

## 1) 글로벌 파티션 인덱스(GPI)의 효용성

### 1.1 GPI가 “이기는” 본질적 이유 3가지

1) **테이블 파티션 축과 다른 “쿼리 축”을 인덱스에 새로 만든다**  
   - 테이블을 날짜로 RANGE 파티션해도  
     **조회가 고객(cust_id) 중심**이면 테이블 프루닝은 약해진다.  
   - 이때 인덱스를 cust_id로 HASH 파티션한 GPI는  
     “**인덱스 레벨에서 고객축 프루닝/분산**”을 만들어 준다. :contentReference[oaicite:9]{index=9}

2) **핫 블록(Hot Root/Branch/Leaf) 경합을 줄인다**  
   - 특히 OLTP성 insert가 특정 키로 몰릴 때 **단일 인덱스 블록 경합**이 치명적이다.  
   - Global **HASH-partitioned** index는 인덱스 구조를 여러 파티션으로 쪼개 **동시성/경합을 물리적으로 분산**한다. :contentReference[oaicite:10]{index=10}

3) **병렬 스캔/집계에서 인덱스 자체를 자연스럽게 분할한다**  
   - GPI는 인덱스 파티션이 독립 단위라서  
     **PX가 인덱스 파티션 단위로 스캔/집계를 나눠 갖기 쉬움**.  
   - DW/PQ에서 “인덱스로 먼저 줄이고 집계”가 유효한 패턴이면 GPI가 강하다. :contentReference[oaicite:11]{index=11}

---

### 1.2 GPI-HASH: “고객/테넌트/계정 축 조회가 잦을 때”

#### (1) DDL

```sql
-- 테이블은 sales_dt로 RANGE 파티션이라고 가정
CREATE INDEX fact_sales_gpi_hash
  ON fact_sales(cust_id, sales_dt)
  GLOBAL PARTITION BY HASH (cust_id)
  PARTITIONS 8;
```

#### (2) 쿼리 패턴

```sql
-- 날짜 조건이 약하거나 없다: 테이블 프루닝이 불리한 전형적 케이스
EXPLAIN PLAN FOR
SELECT /*+ index(f fact_sales_gpi_hash) */
       cust_id, COUNT(*) cnt, SUM(amount) amt
FROM   fact_sales f
WHERE  cust_id = :cid
GROUP  BY cust_id;

SELECT * 
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
```

#### (3) 기대 실행계획/효과

- `INDEX RANGE SCAN` 또는 조건 폭에 따라 `INDEX FAST FULL SCAN`  
- **INDEX PARTITION PRUNING**: 특정 cust_id 해시 파티션만 접근  
- **동시성/스루풋 향상**: cust_id 편중/핫블록 문제가 줄어든다. :contentReference[oaicite:12]{index=12}

#### (4) 주의점

- 테이블 파티션이 sales_dt라서 **테이블 프루닝은 여전히 약할 수 있다.**  
  → “**인덱스로 줄이고 테이블로 가는 랜덤 I/O**”가 허용되는 선택도(Selectivity)인지가 관건.

---

### 1.3 GPI-RANGE: “비파티션 키(금액/레벨/구간) 중심 대량 조회”

#### (1) DDL

```sql
CREATE INDEX fact_sales_gpi_amt
  ON fact_sales(amount, sales_dt)
  GLOBAL PARTITION BY RANGE(amount) (
    PARTITION gpi_low  VALUES LESS THAN (100),
    PARTITION gpi_mid  VALUES LESS THAN (1000),
    PARTITION gpi_high VALUES LESS THAN (MAXVALUE)
  );
```

#### (2) 쿼리 패턴

```sql
EXPLAIN PLAN FOR
SELECT /*+ index(f fact_sales_gpi_amt) */
       COUNT(*)
FROM   fact_sales f
WHERE  amount BETWEEN :low AND :high;

SELECT * 
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
```

#### (3) 기대 효과

- **INDEX PARTITION PRUNING**으로 특정 amount 구간 파티션만 읽음.  
- 테이블 파티션(날짜)과 무관하게 **“금액대 리포트/경보/대시보드”**가 빠르게 돈다. :contentReference[oaicite:13]{index=13}

---

### 1.4 GPI 유지보수 비용(이게 GPI의 “대가”)

#### (1) 왜 UNUSABLE이 되는가

- 테이블 파티션 유지보수(DROP/TRUNCATE/SPLIT/EXCHANGE 등)를 하면  
  **글로벌 인덱스는 테이블 파티션과 1:1 관계가 아니므로**  
  관련 인덱스 엔트리를 일괄 재정렬하기 어렵다.  
- 그래서 Oracle은 기본적으로 글로벌 인덱스를 **UNUSABLE로 마킹**하고,  
  사용자가 정책적으로 “업데이트” 또는 “재빌드”하도록 한다. :contentReference[oaicite:14]{index=14}

#### (2) 정책 A: DDL 시 즉시 유지

```sql
-- 파티션을 건드릴 때 글로벌 인덱스를 동시에 유지
ALTER TABLE fact_sales 
  TRUNCATE PARTITION p2025m01 UPDATE GLOBAL INDEXES;
```

- 장점: DDL 직후 **즉시 사용 가능/일관성 유지**  
- 단점: 파티션 DDL 시간이 길어짐. :contentReference[oaicite:15]{index=15}

#### (3) 정책 B: DDL은 빨리, 인덱스는 사후 배치 재빌드

```sql
ALTER INDEX fact_sales_gpi_hash REBUILD ONLINE;
-- 혹은 특정 인덱스 파티션만
ALTER INDEX fact_sales_gpi_amt REBUILD PARTITION gpi_mid ONLINE;
```

- 장점: 테이블 파티션 유지보수가 빠름  
- 단점: **재빌드 배치/운영 절차가 필수**. :contentReference[oaicite:16]{index=16}

> **핵심 결론**  
> GPI는 “쿼리축/동시성/병렬성”을 강하게 얻는 대신  
> **파티션 DDL 유지보수 정책을 반드시 설계에 포함**해야 한다.

---

## 2) 로컬 Non-Prefixed 파티션 인덱스의 효용성

### 2.1 왜 Non-Prefixed가 필요해지는가

테이블 RANGE 파티션(날짜) 기반 DW에서 실제 쿼리는 보통:

- **날짜 범위는 항상 있고**  
- **조인/필터는 cust_id 같은 차원키가 선두로 강하게 걸린다**

즉, **“날짜로 큰 덩어리를 먼저 자르고, 그 안에서 고객으로 빠르게 찾고 싶다”**가 현실이다.

Prefixed Local(선두=날짜)은 날짜 프루닝은 최고지만, 파티션 내부에서 cust_id 탐색이 약해질 수 있다.  
Non-Prefixed Local은 이 둘을 **동시에 먹이기 위한 절충 설계**다. :contentReference[oaicite:17]{index=17}

---

### 2.2 DDL & 기본 동작

```sql
CREATE INDEX fact_sales_lix_nonpref
  ON fact_sales(cust_id, sales_dt)
  LOCAL;  -- 테이블 파티션과 동일 축으로 인덱스도 로컬 파티셔닝
```

- 인덱스 파티션 = 테이블 파티션과 1:1  
- 인덱스 키 선두 = cust_id (파티션 키 sales_dt 아님)  
- 따라서 프루닝은 **WHERE절에 sales_dt가 있을 때만 강하게 걸린다.** :contentReference[oaicite:18]{index=18}

---

### 2.3 “이상적 패턴”: 날짜 + 고객(또는 차원키)

```sql
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   fact_sales
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01'
AND    cust_id   = 202;

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
```

**기대 플랜**

- `PARTITION RANGE SINGLE` 또는 `PARTITION RANGE ITERATOR`  
  → **테이블/인덱스 파티션 프루닝** 먼저  
- 파티션 내부에서 `INDEX RANGE SCAN`(leading = cust_id)  
  → 프루닝 + 조인키 탐색 **동시 최적화**

---

### 2.4 “경계 패턴”: 고객만 있고 날짜가 없다

```sql
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   fact_sales
WHERE  cust_id = 202;

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION'));
```

**해석**

- 파티션 키 조건이 없으니  
  여러(혹은 전체) 인덱스 파티션을 읽을 수 있다.  
- 하지만 로컬이므로  
  **파티션별 스캔 병렬화/유지보수 자동성**에서 여전히 장점이 남는다. :contentReference[oaicite:19]{index=19}

---

### 2.5 유일성(Unique) 제약의 핵심 룰

- **로컬 UNIQUE 인덱스는 테이블 파티션 키(sales_dt)를 반드시 포함해야 한다.**  
- Non-Prefixed 로컬 UNIQUE도 마찬가지로  
  **파티션 키가 인덱스 키의 부분집합이어야** 전역 중복을 막을 수 있다. :contentReference[oaicite:20]{index=20}

```sql
-- OK: 파티션 키 포함 → 파티션 내부 유일성 보장
CREATE UNIQUE INDEX fact_sales_u_local
  ON fact_sales(sales_dt, sales_id)
  LOCAL;

-- 전 기간 유일성(PK 등)이 필요하면 글로벌이 자연스러움
CREATE UNIQUE INDEX fact_sales_u_global
  ON fact_sales(sales_id);
```

---

## 3) 액세스 효율 관점 “선택 기준” — 패턴이 답이다

### 3.1 의사결정 매트릭스(확장판)

| 지배적 쿼리 패턴/요구 | 1순위 | 2순위/보완 | 이유 |
|---|---|---|---|
| **항상 날짜 범위가 있고, 그 안에서 찾는다** | Local **Prefixed** (sales_dt, …) | 필요 시 Non-Prefixed 병행 | 날짜 프루닝이 최우선. 유지보수 자동. |
| **날짜 + cust_id(조인키/차원키)가 동시에 강함** | Local **Non-Prefixed** (cust_id, sales_dt) | Prefixed를 추가로 병행 | 프루닝 + 파티션 내부 조인키 탐색 동시 달성. |
| **cust_id 중심 조회가 많고 날짜가 약함/없음** | **GPI-HASH(cust_id)** | 로컬 날짜 인덱스 | 테이블 프루닝이 약해도 인덱스 분산/경합 완화/병렬성이 압도. |
| **비파티션 키(금액/등급/상태)로 대량 범주 조회** | **GPI-RANGE(범주키)** | 로컬 프루닝 인덱스 | 인덱스 파티션 프루닝으로 범주 리포트 최적화. |
| **전 기간 유일성 PK/UK 필수** | Global Unique (GPI or non-partitioned) | — | 로컬 UNIQUE는 파티션키 포함 룰 때문에 전역 유일 어려움. |
| **파티션 DDL(교체/아카이브)이 매우 빈번** | **로컬 우선** | GPI는 정책 동반 시만 | 글로벌은 DDL 후 UNUSABLE 관리 필요. 로컬은 자동 정합. :contentReference[oaicite:21]{index=21} |
| **PX/DW에서 인덱스 병렬 스캔이 중요** | GPI 또는 로컬+IFFS | — | 인덱스 파티션 단위 병렬 분할이 쉬움. |

---

### 3.2 “항상 있는 필터를 리딩에 둬라”의 실제 의미

- 리딩 컬럼은 “자주 고정되는 범위/동등조건”일수록 유리하다.  
- **날짜가 항상 걸리면 → Prefixed Local**  
- **조인키가 항상 걸리면 → Non-Prefixed Local 또는 GPI-HASH**

이건 단순한 규칙이 아니라  
**프루닝 신호(Partition Access List)와 B-tree 탐색비용을 동시에 최소화**하는 구조적 원칙이다. :contentReference[oaicite:22]{index=22}

---

## 4) 제약까지 포함한 데이터베이스 설계 전략

### 4.1 테이블 파티션 DDL과의 관계

#### 로컬 인덱스

- 테이블 파티션을 DROP/EXCHANGE/SPLIT 해도  
  로컬 인덱스는 **같이 정합되거나(대부분)**, 필요한 파티션만 재구성한다.  
  → **운영이 단순**하다. :contentReference[oaicite:23]{index=23}

#### 글로벌 인덱스(GPI)

- 파티션 DDL 후 **UNUSABLE 위험**  
- **UPDATE GLOBAL INDEXES vs 사후 REBUILD** 정책을 사전에 확정해야 한다. :contentReference[oaicite:24]{index=24}

---

### 4.2 ETL/아카이브/EXCHANGE 흐름에서의 베스트 프랙티스

1) **핫 파티션에만 인덱스를 집중하는 운영**  
   - 최신 파티션: Prefixed/Non-Prefixed 로컬 인덱스 유지  
   - 콜드 파티션: 인덱싱을 끄거나(12c+) 인덱스 파티션을 드롭하여 유지비 절감  
   - 원리는 “핫-콜드 분리”다. :contentReference[oaicite:25]{index=25}

2) **EXCHANGE PARTITION을 쓰는 배치 구조**  
   - 로컬 인덱스가 자동 정합되니까  
     **스테이징 테이블 교체가 빠르고 안전**하다.  
   - GPI가 있으면 교체 후 **글로벌 인덱스 정리 작업**을 반드시 포함.

---

### 4.3 RAC/병렬 관점(선택 기준을 더 선명하게 해줌)

- **로컬 인덱스 + 테이블 동일 프루닝 축**은  
  PX/RAC에서 **데이터 지역성(Locality)**이 좋아 **GC 대기/인터커넥트 비용이 낮아진다.**
- **GPI-HASH**는 RAC에서 인덱스 핫블록 경합을 줄일 수 있으나,  
  테이블 액세스가 파티션을 가로지르면 **GC 비용이 다시 커질 수 있음**  
  → “인덱스 축”과 “테이블 액세스 축”이 얼마나 어긋나는지가 핵심.

---

## 5) 실습: 같은 쿼리를 3가지 인덱스로 비교하기

### 5.1 인덱스 3종 준비

```sql
-- A) Prefixed Local (날짜 중심)
CREATE INDEX fact_sales_lix_pref
  ON fact_sales(sales_dt, cust_id)
  LOCAL;

-- B) Non-Prefixed Local (고객+날짜 혼합)
CREATE INDEX fact_sales_lix_nonpref
  ON fact_sales(cust_id, sales_dt)
  LOCAL;

-- C) GPI-HASH (고객만 강할 때)
CREATE INDEX fact_sales_gpi_hash
  ON fact_sales(cust_id, sales_dt)
  GLOBAL PARTITION BY HASH (cust_id)
  PARTITIONS 8;
```

### 5.2 패턴 1: 날짜 + 고객

```sql
EXPLAIN PLAN FOR
SELECT /*+ index(f fact_sales_lix_nonpref) */
       SUM(amount)
FROM   fact_sales f
WHERE  f.sales_dt BETWEEN DATE '2025-02-01' AND DATE '2025-02-28'
AND    f.cust_id  = 202;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
```

- **B(Non-Prefixed Local)**이 보통 최적  
  - 파티션 프루닝 + 파티션 내부 cust_id Range Scan 동시
- A도 좋지만 cust_id 탐색이 B보다 불리할 때가 많다.

### 5.3 패턴 2: 고객만

```sql
EXPLAIN PLAN FOR
SELECT /*+ index(f fact_sales_gpi_hash) */
       SUM(amount)
FROM   fact_sales f
WHERE  f.cust_id = 202;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
```

- **C(GPI-HASH)**가 유리해지는 대표구간  
  - 인덱스 해시 파티션 프루닝/경합 분산
- B는 파티션키 조건 부재로 여러 로컬 인덱스 파티션을 건드릴 수 있다.

### 5.4 패턴 3: 날짜만

```sql
EXPLAIN PLAN FOR
SELECT /*+ index(f fact_sales_lix_pref) */
       SUM(amount)
FROM   fact_sales f
WHERE  f.sales_dt BETWEEN DATE '2025-02-01' AND DATE '2025-02-28';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARTITION +PREDICATE'));
```

- **A(Prefixed Local)**의 “교과서 구간”  
  - 프루닝/스캔 비용 최소

---

## 6) 트러블슈팅: 자주 터지는 6가지 함정

1) **파티션 키에 함수/형변환**  
   - `TRUNC(sales_dt)` / `TO_CHAR(sales_dt,…)`  
   → 프루닝 신호가 깨져 로컬 인덱스의 존재 이유가 사라진다. :contentReference[oaicite:26]{index=26}

2) **인덱스 리딩과 실제 필터가 어긋남**  
   - “항상 있는 필터”가 리딩이 아니면  
     인덱스 파티셔닝의 성능은 절반 이하로 깎인다.

3) **GPI 유지 정책 없이 파티션 DDL을 남발**  
   - 곧바로 UNUSABLE → 플랜이 FTS로 바뀌며 장애급 성능저하. :contentReference[oaicite:27]{index=27}

4) **Non-Prefixed 로컬을 “cust_id만” 패턴에 과신**  
   - 날짜 조건이 없으면 로컬 파티션을 많이 긁을 수 있다.  
   → cust_id 단독 패턴이 강하면 GPI-HASH도 고려.

5) **UNIQUE 요구를 로컬 Non-Prefixed로 해결하려다 막힘**  
   - 전역 유일성은 글로벌이 정답.  
   - 로컬 UNIQUE는 반드시 파티션키 포함 룰을 따른다. :contentReference[oaicite:28]{index=28}

6) **통계 불균형/파티션 통계 누락**  
   - 파티션별/전체(글로벌) 통계가 같이 최신이어야  
     옵티마이저가 올바른 인덱스 파티션/프루닝을 선택한다. :contentReference[oaicite:29]{index=29}

---

## 7) 최종 결론(실무형)

- **GPI가 유리한 세계**
  - **테이블 파티션 키와 다른 축(cust_id/범주/금액대) 조회가 지배적**
  - **핫블록 경합/병렬 인덱스 분할이 중요**
  - 단, **파티션 DDL 유지보수 정책 없이는 쓰지 마라.** :contentReference[oaicite:30]{index=30}

- **로컬 Non-Prefixed가 유리한 세계**
  - **“날짜 범위 + 조인키/차원키”가 동시에 자주 등장**
  - 프루닝과 조인키 Range Scan을 동시에 먹일 수 있다.
  - 유지보수가 자동이라 **ETL/아카이브/교체가 많은 DW에서 기본 해법**이다. :contentReference[oaicite:31]{index=31}

- **선택의 핵심**
  1) **항상 있는 필터를 리딩 컬럼으로**  
  2) **테이블 프루닝 축 vs 조회 축이 다르면 GPI**  
  3) **둘이 동시에 강하면 Non-Prefixed 로컬(+Prefixed 병행 고려)**  
  4) **유일성/파티션 DDL 빈도/운영정책까지 포함해서 의사결정**

> 한 줄로 정리하면:  
> **“프루닝 신호를 가장 먼저 살리고, 그 다음에 실제 조인/필터 축으로 인덱스를 분산하라.”**  
> 이 원칙만 지켜도, 인덱스 파티셔닝 선택의 80%는 자동으로 맞아 떨어진다.