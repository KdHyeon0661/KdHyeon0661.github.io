---
layout: post
title: DB 심화 - 인덱스 파티셔닝 선택
date: 2025-11-24 21:25:23 +0900
category: DB 심화
---
# Oracle 인덱스 파티셔닝 선택 가이드

## 글로벌 vs 로컬, Prefixed vs Non-Prefixed 인덱스의 설계와 튜닝

인덱스 파티셔닝은 대용량 데이터베이스 환경에서 성능과 관리 효율성을 결정하는 중요한 설계 요소입니다. 이 글에서는 다양한 인덱스 파티셔닝 방식의 특징, 적절한 사용 사례, 그리고 실무에서의 선택 기준을 체계적으로 살펴보겠습니다.

---

## 기본 개념 정리: 인덱스 파티셔닝 용어 이해

### 테이블 파티셔닝 vs 인덱스 파티셔닝

**테이블 파티셔닝**은 실제 데이터 행을 물리적으로 분할하여, 쿼리 시 불필요한 파티션을 접근하지 않도록 하는 것이 주요 목적입니다. 이로 인한 파티션 프루닝(Partition Pruning) 효과가 가장 큰 장점입니다.

**인덱스 파티셔닝**은 인덱스 구조를 세그먼트 단위로 분할하여 관리 효율성, 동시성 처리, 스캔 성능을 개선합니다. 인덱스 파티셔닝의 프루닝 가능성은 인덱스 유형에 따라 다르게 적용됩니다.

### 로컬 인덱스 vs 글로벌 인덱스

**로컬 파티션 인덱스(Local Partitioned Index)**
- 테이블 파티션과 1:1로 대응되는 인덱스
- 테이블 파티션 DDL 작업(추가/삭제/분할/교체 등)과 자동으로 동기화
- 관리 편의성과 자동 정합성이 핵심 장점

**글로벌 파티션 인덱스(Global Partitioned Index, GPI)**
- 테이블 파티션과 독립적인 파티셔닝 구조
- 테이블과 다른 축으로 인덱스를 파티셔닝 가능 (예: 테이블은 날짜별, 인덱스는 고객별)
- 유연한 설계가 가능하지만 관리 복잡도 증가

### Prefixed vs Non-Prefixed (로컬 인덱스 전용 개념)

**Prefixed 로컬 인덱스**
- 인덱스 키의 선두 컬럼이 테이블 파티션 키와 일치
- 파티션 키 조건이 있을 때 인덱스 파티션 프루닝이 매우 효과적

**Non-Prefixed 로컬 인덱스**
- 인덱스 키 선두가 테이블 파티션 키가 아님
- 파티션 프루닝과 파티션 내부의 효율적 탐색을 동시에 달성하는 하이브리드 전략

**중요 제약사항**:
1. 로컬 Non-Prefixed 유니크 인덱스는 파티션 키를 인덱스 키에 포함해야만 생성 가능
2. 글로벌 인덱스는 테이블 파티션 DDL 작업 후 UNUSABLE 상태가 될 수 있어 관리 정책 필요
3. Prefixed/Non-Prefixed 구분은 로컬 인덱스의 프루닝 특성을 설명하는 개념

---

## 글로벌 파티션 인덱스(GPI)의 장점과 활용

### GPI의 핵심 장점

1. **쿼리 축의 다변화 지원**
   테이블이 날짜로 파티셔닝되어 있어도, 실제 쿼리가 고객 중심인 경우 GPI를 고객 기준으로 파티셔닝하면 인덱스 레벨에서의 프루닝 효과를 얻을 수 있습니다.

2. **핫 블록 경합 해소**
   특정 키값에 집중되는 OLTP 삽입 작업에서 단일 인덱스 블록의 경합을 해시 파티셔닝으로 분산시킬 수 있습니다.

3. **병렬 처리 최적화**
   인덱스 파티션 단위로 자연스럽게 작업을 분할하여 병렬 스캔과 집계 성능을 향상시킵니다.

### GPI-HASH: 고객/테넌트 중심 조회 패턴

```sql
-- 테이블은 sales_dt로 RANGE 파티셔닝되어 있다고 가정
CREATE INDEX idx_sales_gpi_hash
  ON sales(cust_id, sales_dt)
  GLOBAL PARTITION BY HASH (cust_id)
  PARTITIONS 8;
```

**적합한 쿼리 패턴**:
```sql
-- 날짜 조건이 약하거나 없는 고객 중심 조회
SELECT cust_id, COUNT(*), SUM(amount)
FROM sales
WHERE cust_id = :customer_id;
```

**실행계획 특징**:
- `INDEX RANGE SCAN` 또는 `INDEX FAST FULL SCAN`
- `INDEX PARTITION PRUNING`으로 특정 cust_id 해시 파티션만 접근
- 다중 세션에서의 동시성 처리 향상

**주의사항**: 테이블 접근 시 여전히 전체 파티션 스캔이 필요할 수 있어, 선택도(Selectivity)가 충분히 높아야 효과적입니다.

### GPI-RANGE: 비파티션 키 기반 범주 조회

```sql
-- 금액대별 인덱스 파티셔닝
CREATE INDEX idx_sales_gpi_amount
  ON sales(amount, sales_dt)
  GLOBAL PARTITION BY RANGE(amount) (
    PARTITION p_low   VALUES LESS THAN (100),
    PARTITION p_mid   VALUES LESS THAN (1000),
    PARTITION p_high  VALUES LESS THAN (MAXVALUE)
  );
```

**적용 시나리오**:
- 금액대별 리포트 생성
- 등급/상태별 데이터 분석
- 범주 기반 대시보드 조회

### GPI의 관리 부담과 대책

글로벌 인덱스의 가장 큰 도전 과제는 테이블 파티션 DDL 작업 후의 관리입니다.

**문제점**: 테이블 파티션을 DROP, TRUNCATE, SPLIT, EXCHANGE할 때 관련 글로벌 인덱스가 UNUSABLE 상태로 표시될 수 있습니다.

**해결 전략 1: DDL 시점 유지**
```sql
-- 인덱스 유지와 함께 파티션 작업
ALTER TABLE sales 
  TRUNCATE PARTITION p202501 
  UPDATE GLOBAL INDEXES;
```
- 장점: 작업 직후 인덱스 사용 가능
- 단점: DDL 실행 시간 증가

**해결 전략 2: 사후 재구성**
```sql
-- 빠른 DDL 후 별도 인덱스 재구성
ALTER INDEX idx_sales_gpi_hash REBUILD ONLINE;
```
- 장점: DDL 실행 시간 최소화
- 단점: 별도 재구성 작업 필요

**핵심 원칙**: GPI 도입 시 반드시 파티션 유지보수 정책을 함께 설계해야 합니다.

---

## 로컬 Non-Prefixed 인덱스의 전략적 가치

### Non-Prefixed 인덱스가 필요한 이유

데이터 웨어하우스 환경에서의 일반적인 쿼리 패턴은 다음과 같습니다:
1. **날짜 범위 조건은 항상 존재**
2. **조인 키나 필터 키(cust_id 등)로 추가 필터링**

이러한 패턴에서 Non-Prefixed 인덱스는 "날짜로 큰 덩어리를 먼저 자르고, 그 안에서 고객으로 빠르게 찾는" 하이브리드 접근법을 제공합니다.

### Non-Prefixed 인덱스 구현

```sql
-- 테이블 파티션 키: sales_dt (날짜)
-- 인덱스 선두 키: cust_id (고객)
CREATE INDEX idx_sales_local_nonpref
  ON sales(cust_id, sales_dt)
  LOCAL;
```

**동작 특성**:
- 인덱스 파티션 = 테이블 파티션과 1:1 대응
- WHERE 절에 sales_dt 조건이 있을 때만 파티션 프루닝 발생
- 파티션 내에서는 cust_id 기준으로 효율적인 Range Scan 수행

### 이상적인 사용 패턴

```sql
-- 날짜 범위 + 고객 조건 동시 사용
SELECT SUM(amount)
FROM sales
WHERE sales_dt >= DATE '2025-01-01'
  AND sales_dt < DATE '2025-02-01'
  AND cust_id = 1001;
```

**실행계획 기대**:
- `PARTITION RANGE SINGLE/ITERATOR`: 날짜 기반 파티션 프루닝
- `INDEX RANGE SCAN`: cust_id 기반 인덱스 탐색
- 두 최적화를 동시에 달성

### 제약사항과 한계

**유니크 제약의 특별한 규칙**:
```sql
-- 가능: 파티션 키 포함
CREATE UNIQUE INDEX idx_unique_local
  ON sales(sales_dt, sales_id)  -- sales_dt가 파티션 키
  LOCAL;

-- 불가능: 파티션 키 미포함
-- CREATE UNIQUE INDEX idx_unique_local_fail
--   ON sales(sales_id)  -- 파티션 키(sales_dt) 미포함
--   LOCAL;
```

**전역 유일성이 필요할 때**: 글로벌 인덱스 사용이 더 적합합니다.

---

## 실전 선택 기준: 액세스 패턴 기반 의사결정

### 의사결정 매트릭스

| 지배적 쿼리 패턴 | 권장 인덱스 타입 | 이유 | 보완 전략 |
|-----------------|-----------------|------|-----------|
| **항상 날짜 범위 + 파티션 내 탐색** | Prefixed 로컬 | 날짜 프루닝 최적화 | 필요시 Non-Prefixed 추가 |
| **날짜 + 조인키 동시 강조** | Non-Prefixed 로컬 | 프루닝과 탐색 동시 최적화 | Prefixed와 조합 |
| **고객 중심, 날짜 조건 약함** | GPI-HASH | 인덱스 수준 분산/병렬화 | 로컬 날짜 인덱스 보완 |
| **비파티션 키(금액/등급) 중심** | GPI-RANGE | 인덱스 파티션 프루닝 | 로컬 인덱스와 조합 |
| **전역 유일성 필요** | 글로벌 유니크 | 로컬의 파티션 키 제약 회피 | - |
| **빈번한 파티션 관리** | 로컬 인덱스 | 자동 정합성 | GPI는 관리 정책 필수 |
| **대용량 병렬 처리** | GPI | 자연스러운 작업 분할 | 로컬 + IFFS 고려 |

### 선택의 핵심 원칙

1. **항상 존재하는 필터를 선두에**: 가장 자주 사용되는 조건을 인덱스 선두에 배치
2. **프루닝 우선, 탐색 후순**: 파티션 프루닝 효과를 먼저 확보한 후 파티션 내 탐색 최적화
3. **관리 비용 고려**: 운영 복잡도와 자동화 수준을 현실적으로 평가
4. **통계 정확성 유지**: 파티션별 통계와 글로벌 통계의 균형적 관리

---

## 실습: 동일 쿼리에 대한 세 가지 인덱스 비교

### 테스트 환경 설정

```sql
-- 기본 테이블 생성 (월별 RANGE 파티션)
CREATE TABLE sales (
    sales_id   NUMBER PRIMARY KEY,
    sales_dt   DATE NOT NULL,
    cust_id    NUMBER NOT NULL,
    amount     NUMBER(12,2) NOT NULL
)
PARTITION BY RANGE (sales_dt) (
    PARTITION p202501 VALUES LESS THAN (DATE '2025-02-01'),
    PARTITION p202502 VALUES LESS THAN (DATE '2025-03-01'),
    PARTITION p202503 VALUES LESS THAN (DATE '2025-04-01')
);

-- 1. Prefixed 로컬 인덱스 (날짜 중심)
CREATE INDEX idx_sales_prefixed
  ON sales(sales_dt, cust_id) LOCAL;

-- 2. Non-Prefixed 로컬 인덱스 (고객+날짜 혼합)
CREATE INDEX idx_sales_nonprefixed
  ON sales(cust_id, sales_dt) LOCAL;

-- 3. GPI-HASH (고객 중심)
CREATE INDEX idx_sales_gpi_hash
  ON sales(cust_id, sales_dt)
  GLOBAL PARTITION BY HASH (cust_id) PARTITIONS 8;
```

### 시나리오 1: 날짜 + 고객 조건 동시 사용

```sql
-- 쿼리
SELECT SUM(amount)
FROM sales
WHERE sales_dt BETWEEN DATE '2025-01-01' AND DATE '2025-01-31'
  AND cust_id = 1001;

-- 인덱스별 성능 분석
-- 1. Non-Prefixed 로컬: 최적 (프루닝 + Range Scan 동시)
-- 2. Prefixed 로컬: 양호 (프루닝 우수, 탐색 다소 불리)
-- 3. GPI-HASH: 양호 (고객 해시 프루닝, 날짜 범위 스캔)
```

### 시나리오 2: 고객 단일 조건

```sql
-- 쿼리
SELECT SUM(amount)
FROM sales
WHERE cust_id = 1001;

-- 인덱스별 성능 분석
-- 1. GPI-HASH: 최적 (인덱스 해시 프루닝)
-- 2. Non-Prefixed 로컬: 보통 (여러 파티션 스캔 필요)
-- 3. Prefixed 로컬: 불리 (인덱스 선두 불일치)
```

### 시나리오 3: 날짜 단일 조건

```sql
-- 쿼리
SELECT SUM(amount)
FROM sales
WHERE sales_dt BETWEEN DATE '2025-01-01' AND DATE '2025-01-31';

-- 인덱스별 성능 분석
-- 1. Prefixed 로컬: 최적 (완벽한 프루닝)
-- 2. Non-Prefixed 로컬: 양호 (파티션 프루닝은 동일)
-- 3. GPI-HASH: 불리 (날짜 범위 인덱스 스캔)
```

---

## 운영 관점의 고려사항

### 파티션 DDL 작업과의 관계

**로컬 인덱스의 장점**:
- 테이블 파티션 작업과 자동 동기화
- DROP, EXCHANGE, SPLIT 작업 시 추가 관리 불필요
- ETL/아카이브 작업에 적합

**글로벌 인덱스의 관리 과제**:
- 파티션 작업 후 인덱스 상태 모니터링 필요
- REBUILD 또는 UPDATE GLOBAL INDEXES 정책 수립
- 운영 프로세스에 명시적 관리 단계 포함

### ETL/아카이브 최적화 전략

1. **핫/콜드 데이터 분리 관리**
   ```sql
   -- 최신 파티션: 모든 인덱스 유지
   -- 오래된 파티션: 인덱스 파티션 드롭 또는 압축
   ALTER INDEX idx_sales_prefixed
     MODIFY PARTITION p202401 UNUSABLE;
   ```

2. **파티션 교체(EXCHANGE) 최적화**
   - 로컬 인덱스: 교체 작업이 간단하고 안전
   - 글로벌 인덱스: 교체 후 인덱스 정리 작업 필요

### RAC/병렬 처리 환경 고려

**로컬 인덱스 장점**:
- 데이터 지역성(Locality) 우수
- GC(Global Cache) 대기 감소
- 인터커넥트 트래픽 최소화

**GPI 장점**:
- 인덱스 핫블록 경합 분산
- 자연스러운 병렬 작업 분할
- 하지만 테이블 액세스 시 GC 비용 증가 가능

---

## 자주 발생하는 문제와 해결 방안

### 문제 1: 파티션 키에 함수 적용

**잘못된 패턴**:
```sql
WHERE TRUNC(sales_dt) = DATE '2025-01-01'
```

**해결책**:
```sql
WHERE sales_dt >= DATE '2025-01-01' 
  AND sales_dt < DATE '2025-01-02'
```

### 문제 2: 인덱스 선두와 실제 필터 불일치

**원인**: 자주 사용되는 조건이 인덱스 선두에 없음

**해결책**: 쿼리 패턴 분석을 통한 인덱스 재설계

### 문제 3: GPI 관리 정책 부재

**증상**: 파티션 DDL 후 인덱스 UNUSABLE로 인한 성능 저하

**해결책**: 명시적 관리 프로세스 수립 및 자동화

### 문제 4: 통계 관리 소홀

**영향**: 옵티마이저의 잘못된 인덱스 선택

**해결책**: 정기적인 통계 수집 및 파티션별 통계 관리

---

## 결론: 상황에 맞는 최적의 선택

인덱스 파티셔닝 설계는 단일 정답이 없는 상황 의존적 결정입니다. 효과적인 선택을 위한 체계적 접근법을 정리해 보겠습니다.

### 핵심 선택 기준 요약

**글로벌 파티션 인덱스(GPI) 선택 시**:
- 테이블 파티션 키와 다른 조회 축이 지배적일 때
- 핫블록 경합 해소나 병렬 처리 최적화가 중요할 때
- 전역 유일성 제약이 필요할 때
- **단, 반드시 파티션 관리 정책을 함께 수립**

**로컬 Non-Prefixed 인덱스 선택 시**:
- 날짜 범위와 조인 키가 동시에 자주 사용될 때
- 파티션 관리 작업이 빈번한 ETL/아카이브 환경
- 자동 정합성과 관리 편의성이 중요할 때

**로컬 Prefixed 인덱스 선택 시**:
- 파티션 키 조건이 항상 존재하고 선두 필터로 작용할 때
- 최대한의 파티션 프루닝 효과를 원할 때

### 실무 적용 원칙

1. **데이터 접근 패턴 분석 우선**: 실제 쿼리 로그와 실행계획을 기반으로 한 설계
2. **점진적 개선 접근**: 단계적 도입과 성능 측정을 통한 검증
3. **운영 현실 고려**: 관리 부담과 자동화 수준을 현실적으로 평가
4. **유연성 유지**: 요구사항 변화에 대응할 수 있는 여유 확보

### 최종 권고사항

인덱스 파티셔닝은 성능과 관리성 사이의 균형을 찾는 작업입니다. 다음 질문들을 스스로에게 던져보세요:

1. 우리 시스템의 지배적 쿼리 패턴은 무엇인가?
2. 파티션 관리 작업의 빈도와 복잡도는 어느 정도인가?
3. 성능 요구사항과 관리 부담의 적절한 균형점은 어디인가?
4. 미래의 데이터 성장과 접근 패턴 변화를 예상하고 있는가?

이러한 질문에 대한 명확한 답변을 바탕으로 한 설계가 장기적으로 지속 가능한 데이터베이스 아키텍처를 만드는 첫걸음입니다. 인덱스 파티셔닝은 단순한 기술 선택을 넘어, 조직의 데이터 처리 철학과 운영 역량을 반영하는 결정임을 기억하세요.