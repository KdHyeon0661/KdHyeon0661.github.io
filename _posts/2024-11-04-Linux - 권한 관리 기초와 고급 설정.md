---
layout: post
title: Linux - 권한 관리 기초와 고급 설정
date: 2024-11-04 19:20:23 +0900
category: Linux
---
# 권한 관리 기초와 고급 설정

## 파일 권한의 의미 (기초 복습 + 디렉터리 차이)

권한은 **소유자(owner)**, **그룹(group)**, **기타(others)** 세 가지 범주에 대해 **읽기(r)**, **쓰기(w)**, **실행(x)** 권한을 부여합니다.  
이때 **파일과 디렉터리의 권한 의미가 다르다는 점**이 매우 중요합니다.

| 대상 | r | w | x |
|---|---|---|---|
| **파일** | 내용 읽기 | 내용 수정/삭제 | 실행 가능 여부 |
| **디렉터리** | 목록 조회(ls) | 파일/디렉터리 생성/삭제/이름 변경 | **진입(cd) 및 탐색(traverse)** 가능 여부 |

디렉터리에 실행(x) 권한이 없으면 해당 디렉터리로 `cd`로 진입할 수 없습니다.  
읽기(r) 권한이 없어도 정확한 파일명을 알고 있다면 접근할 수 있는 경우가 있지만, 실행 권한이 함께 있어야 합니다.

**권한 표기와 8진수 변환**  
- 기호 표기: `rwxr-x---`  
- 8진수 변환: user=7(111), group=5(101), others=0(000) → `750`

권한을 8진수로 변환하는 공식은 다음과 같습니다:
$$
\text{perm} = 4 \cdot I(r) + 2 \cdot I(w) + 1 \cdot I(x)
$$

실제 적용 확인:
```bash
ls -ld some_dir
namei -l /path/to/some_dir   # 경로 전체의 권한 체인을 확인하여 탐색 실패 지점 파악
```

---

## chmod — 권한 변경 패턴 총정리 (숫자/기호/특수비트)

```bash
# 숫자 표기법
chmod 755 script.sh            # rwxr-xr-x
chmod 640 secret.txt           # rw-r-----

# 기호 표기법
chmod u+x,g-w,o= file.sh       # 소유자: 실행 추가, 그룹: 쓰기 제거, 기타: 모든 권한 제거
chmod -R u=rwX,go-rwx data/    # X: 디렉터리 또는 원래 실행 권한이 있던 파일에만 실행 부여

# 디렉터리와 파일을 구분하여 일괄 변경
find /srv/www -type d -exec chmod 755 {} \;
find /srv/www -type f -exec chmod 644 {} \;
```

**숫자 권한 요약**

| 숫자 | 권한 | 의미 |
|---|---|---|
| 7 | rwx | 읽기/쓰기/실행 |
| 6 | rw- | 읽기/쓰기 |
| 5 | r-x | 읽기/실행 |
| 4 | r-- | 읽기 전용 |
| 0 | --- | 권한 없음 |

**특수 비트 (앞자리 숫자)**  
- setuid(4), setgid(2), sticky(1)

```bash
chmod 4755 /usr/local/bin/tool   # setuid + 755
chmod 2755 /shared/teamdir       # setgid 디렉터리: 생성된 파일의 그룹 상속
chmod 1777 /tmp                  # sticky 비트: 소유자만 삭제 가능
```

setuid 실행 파일은 보안 위험이 크므로 가능하면 **Capabilities로 대체**하는 것이 좋습니다.

---

## chown / chgrp — 소유자와 그룹 제어

```bash
sudo chown user:group file.txt
sudo chown -R www-data:www-data /var/www
sudo chgrp developers /srv/repo
```
NFS/CIFS와 같은 원격 파일 시스템을 사용할 때는 서버 측의 UID/GID 매핑과 마운트 옵션에 따라 동작이 달라질 수 있습니다.

---

## umask — 기본 권한의 근본 설정

새로 생성되는 파일과 디렉터리의 기본 권한은 각각 666과 777에서 umask 값을 뺀 것입니다.

$$
\text{최종 권한} = \text{기본값} - \text{umask}
$$

예시:
- `umask 022` → 파일: 666-022=**644**, 디렉터리: 777-022=**755**
- `umask 077` → 파일: **600**, 디렉터리: **700**

```bash
umask          # 현재 umask 값 확인
umask 027      # 그룹 r-x, 기타 --- 로 설정
```

systemd 서비스의 경우 서비스 파일 내 `UMask=` 지시어나 ExecStart 전에 `umask` 명령을 호출하여 별도로 설정할 수 있습니다.

---

## 특수 비트의 실제 효과 (디렉터리와 공유 작업)

- **setgid 디렉터리**: 해당 디렉터리에서 생성되는 파일과 디렉터리의 그룹이 부모 디렉터리의 그룹으로 상속됩니다. 팀 협업 시 유용합니다.
```bash
sudo chgrp -R devs /srv/project
sudo chmod 2775 /srv/project
```
- **sticky 디렉터리**: `/tmp`처럼 여러 사용자가 공유하는 공간에서 **파일 소유자만 자신의 파일을 삭제**할 수 있도록 합니다.

---

## ACL — 세분화된 권한 관리의 핵심

기본 user/group/others 3축만으로는 부족할 때, 개별 사용자나 그룹에 추가 권한을 부여할 수 있습니다.

### 사전 준비 및 마운트 옵션

```bash
# 패키지 설치
sudo apt install -y acl        # Debian/Ubuntu
sudo dnf install -y acl        # Fedora/RHEL

# 마운트 옵션 확인 (ext4 등)
mount | grep -E ' / | acl'
# /etc/fstab에 acl 옵션 추가: defaults,acl
```

### 파일 및 디렉터리 ACL 설정

```bash
# 단일 파일
setfacl -m u:john:r-- file.txt        # john에게 읽기 권한 부여
setfacl -m g:devs:rw- project.log     # devs 그룹에 읽기/쓰기 권한 부여

# 디렉터리 재귀 적용
setfacl -Rm u:john:rwX /data/project/
# X: 디렉터리에는 실행 권한 부여, 파일에는 원래 실행 권한이 있을 때만 부여
```

### 디폴트 ACL (상속 규칙 설정)

디렉터리에 **default ACL**을 설정하면 새로 생성되는 파일과 디렉터리에 ACL 규칙이 상속됩니다.
```bash
setfacl -m d:u:john:rwX /data/project
setfacl -m d:g:devs:rwX /data/project
```

### ACL 제거 및 확인

```bash
setfacl -x u:john file.txt    # john의 ACL 엔트리 제거
setfacl -b file.txt           # 파일의 모든 ACL 제거
getfacl file.txt              # ACL 정보 확인
```

### 주의사항

ACL의 **mask** 엔트리는 추가 권한의 상한선 역할을 합니다.  
`chmod` 명령이 mask를 갱신하여 의도치 않게 권한이 제한될 수 있으므로,  
`getfacl`에서 `mask::rwx` 등을 확인하고 필요시 `setfacl -m m::rwx`로 조정해야 합니다.

---

## Linux Capabilities — setuid의 현대적 대안

setuid는 루트의 모든 권한을 부여하는 위험한 방식입니다.  
**Capabilities**를 사용하면 필요한 최소한의 권한만 부여할 수 있습니다.

### 기본 명령

```bash
# 바이너리에 Capability 부여 (영구적)
sudo setcap cap_net_bind_service=+ep /usr/local/bin/myserver   # 1024 미만 포트 바인딩 허용

# 확인
getcap /usr/local/bin/myserver
```

### 자주 사용되는 Capability 예시

- `cap_net_bind_service`: 80/443 등 **낮은 번호의 포트 바인딩** 허용
- `cap_sys_admin`: 매우 광범위한 권한 (가급적 사용 지양)
- `cap_dac_override`: 파일 접근 제어 무시 (가급적 사용 지양)

**원칙**: 정말 필요한 최소한의 권한만 부여하세요.

---

## chattr / lsattr — 확장 파일 속성

일반 권한과 별도로 **확장 파일 속성**을 설정하여 삭제나 변경을 더 강력하게 방지할 수 있습니다.

```bash
# 변경 불가 속성 (루트도 삭제/수정 불가, 속성 해제 후 가능)
sudo chattr +i /important/config.yml
sudo chattr -i /important/config.yml

# 추가 전용 속성 (추가만 가능, 로그 파일 무결성 강화)
sudo chattr +a /var/log/secure
```

확인:
```bash
lsattr /important/config.yml
```

---

## getfattr / setfattr — 확장 속성 메타데이터

애플리케이션이나 보안 시스템에서 활용할 수 있는 **키-값 형식의 메타데이터**입니다.

```bash
sudo apt install -y attr
setfattr -n user.comment -v "owned-by-data-team" data.csv
getfattr -d data.csv
```

---

## sudo / su / passwd / id — 계정 권한 승격의 모범 사례

```bash
# 현재 사용자의 UID/GID/그룹 정보
id

# 현재 사용자 이름
whoami

# 일시적 권한 승격
sudo <command>
sudo -u www-data ls /var/www
sudo -i                       # 루트 로그인 셸로 전환

# 사용자 전환 (대상 사용자의 비밀번호 필요)
su -                          # 루트 환경으로 전환
su otheruser                  # 특정 사용자로 전환

# 비밀번호 정책 관리
passwd                        # 자신의 비밀번호 변경
sudo passwd -l testuser       # 계정 잠금
```

### sudoers 안전한 편집

```bash
sudo visudo
```
예시 (비밀번호 없이 특정 명령만 허용 — 신중히 사용):
```
%deploy ALL=(root) NOPASSWD: /usr/bin/systemctl restart myapp
```

### PAM/로그인 정책 (개요)

- `/etc/login.defs`, `/etc/pam.d/`에서 **패스워드 만료, 복잡도, 재사용 금지** 등을 설정할 수 있습니다.
- 예: `pam_pwquality.so`, `pam_faillock.so`를 사용하여 시도 횟수 제한 및 계정 잠금 설정 가능.

---

## 네임스페이스/컨테이너와 권한

- 컨테이너는 user/mount/net/pid 네임스페이스를 통해 격리됩니다.
- rootless 컨테이너는 userns 매핑을 사용하여 호스트의 루트 권한을 직접 가지지 않습니다.
- 컨테이너 내부의 Capabilities는 필요한 최소한으로 유지해야 합니다.

```bash
# Podman 예시: rootless 실행
podman run --rm -it --cap-drop ALL --cap-add NET_BIND_SERVICE nginx
```

---

## SELinux와 AppArmor — 개념과 빠른 진단

**DAC(일반 권한/ACL)** 위에 **MAC(강제 접근 제어)**를 적용하여 정책 기반으로 접근을 차단합니다.

### SELinux (RHEL/Fedora/Alma/Rocky 등)

상태 확인:
```bash
getenforce
sestatus
```

로그 진단:
```bash
# 거부 로그 확인 (audit 패키지 필요)
sudo ausearch -m avc -ts recent
# 또는
sudo journalctl -t setroubleshoot
```

임시 Permissive 모드 (원인 파악용, 프로덕션 환경에서는 주의):
```bash
sudo setenforce 0
```

**정책/컨텍스트 조정**:
```bash
# 컨텍스트 라벨 확인
ls -Z /var/www/html

# httpd가 네트워크 연결 허용 (환경에 맞게 조정)
sudo setsebool -P httpd_can_network_connect on
```

파일 컨텍스트 복원:
```bash
sudo restorecon -Rv /var/www/html
```

### AppArmor (Ubuntu 등)

```bash
sudo aa-status
sudo aa-logprof     # 거부 로그를 기반으로 정책 학습
```

**핵심**: 권한과 ACL이 정상인데도 접근이 차단되면 **SELinux/AppArmor**를 의심하고 정책/컨텍스트/프로파일을 점검하세요.

---

## 실전 시나리오 모음

### 팀 공유 디렉터리 — 그룹 상속 + 기본 ACL

목표: 모든 파일이 `devs` 그룹 소유가 되도록 하고, 기본 권한을 `rw`로 보장합니다.
```bash
sudo mkdir -p /srv/project
sudo chgrp -R devs /srv/project
sudo chmod 2775 /srv/project                   # setgid 디렉터리
setfacl -m d:g:devs:rwx /srv/project           # 디폴트 ACL
setfacl -m d:o::--- /srv/project               # others 차단
```

검증:
```bash
touch /srv/project/a
ls -l /srv/project/a            # 그룹이 devs로 상속되는지 확인
getfacl /srv/project            # default ACL 확인
```

### 80/443 포트 바인딩 — setuid 없이 Capabilities 활용

```bash
sudo setcap cap_net_bind_service=+ep /usr/local/bin/myserver
getcap /usr/local/bin/myserver
```

### 로그 무결성 — append-only + sticky

```bash
sudo chattr +a /var/log/myapp.log
sudo chmod 1755 /var/log/myapplogdir     # sticky 비트 설정
```

### 배포 자동화 계정 — sudo 제한 설정

```
# visudo로 편집
%deploy ALL=(root) NOPASSWD: /usr/bin/systemctl restart myapp, /usr/bin/journalctl -u myapp
```

배포 스크립트에서 사용:
```bash
sudo -n systemctl restart myapp
```

### "권한은 맞는데 접근 실패" — 시스템적 진단 루틴

```bash
# 경로 전체의 탐색 권한 확인
namei -l /srv/app/config.yaml

# ACL/마스크 점검
getfacl /srv/app/config.yaml

# SELinux/AppArmor 확인
getenforce && sudo ausearch -m avc -ts recent
sudo aa-status
```

---

## 권한 검색/감사/리포팅 팁

**이상 권한 빠르게 찾기**
```bash
# world-writable 파일 검색
find /var/www -type f -perm -o=w -ls

# setuid/setgid 바이너리 검색
find / -perm -4000 -o -perm -2000 -xdev -type f -ls 2>/dev/null
```

**감사 로그(auditd) 설정 개요**
```bash
sudo apt install -y auditd
sudo auditctl -w /etc/shadow -p rwxa -k shadow_watch
sudo ausearch -k shadow_watch
```

---

## 빠른 계산 예시

### umask 계산

$$
\text{파일 권한} = 666 - \text{umask}, \quad \text{디렉터리 권한} = 777 - \text{umask}
$$
- `umask 027` → 파일: `640`, 디렉터리: `750`

### ACL 마스크와 유효 권한

**유효 권한** = **(기본 권한 ∪ 추가 ACL)** **∩** **마스크**  
마스크가 `r--`이면 추가로 부여한 실행(x) 권한도 차단됩니다.  
`getfacl` 출력에서 `mask::` 행을 꼭 확인하세요.

---

## 자주 하는 실수와 예방 방법

- `chmod -R 777` 남발 → **최소 권한 원칙**을 위반합니다.
- `setfacl` 설정 후 `chmod`로 마스크가 변경되어 권한이 사라진 것처럼 보일 수 있습니다.
- 디렉터리에서 실행(x) 권한이 빠져 **탐색이 불가능**해질 수 있습니다.
- NFS/컨테이너 환경에서 UID/GID 매칭 실패로 권한 오동작이 발생할 수 있습니다.
- SELinux/AppArmor를 모르고 "퍼미션이 정상인데 접근 불가" 상황을 장기화할 수 있습니다.

---

## 핵심 명령어 요약

| 범주 | 핵심 명령/파일 |
|---|---|
| 기본 권한 | `chmod`, `chown`, `chgrp`, `umask` |
| 특수 비트 | `chmod 4/2/1xxx` (setuid/setgid/sticky) |
| ACL | `setfacl`, `getfacl` (`-m`, `-x`, `-b`, `-R`, `d:`) |
| Capabilities | `setcap`, `getcap` |
| 파일 속성 | `chattr`, `lsattr` |
| 확장 속성 | `setfattr`, `getfattr` |
| 탐색/진단 | `namei -l`, `find -perm`, `stat`, `ls -lZ` |
| sudoers | `visudo`, `/etc/sudoers`, `/etc/sudoers.d/*` |
| SELinux | `getenforce`, `setenforce`, `semanage`, `restorecon`, `ausearch` |
| AppArmor | `aa-status`, `aa-logprof` |
| 감사 | `auditd`, `auditctl`, `ausearch` |

---

## 결론

리눅스 권한 관리는 **퍼미션 → ACL → Capabilities → MAC(SELinux/AppArmor)**의 계층적 구조로 이해해야 합니다. 각 계층은 상위 계층의 제한을 넘어서는 권한을 부여할 수 없으며, 실제 접근 권한은 모든 계층을 통과해야만 허용됩니다.

문제 해결 시에는 다음과 같은 체계적인 접근이 필요합니다:
1. **기본 경로 탐색 권한** 확인 (`namei -l`)
2. **ACL과 마스크** 점검 (`getfacl`)
3. **Capabilities** 확인 (`getcap`)
4. **SELinux/AppArmor** 상태와 로그 확인

실무에서는 **최소 권한 원칙**을 준수하면서도 업무 효율성을 고려해야 합니다. 팀 협업을 위한 setgid 디렉터리와 ACL, 보안을 위한 Capabilities와 MAC 정책, 무결성을 위한 파일 속성 설정 등을 상황에 맞게 조합하여 사용하세요. 이러한 권한 관리 체계를 이해하고 적용한다면 안전하면서도 효율적인 리눅스 시스템 운영이 가능할 것입니다.