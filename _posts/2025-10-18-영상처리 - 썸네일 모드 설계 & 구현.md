---
layout: post
title: 영상처리 - 썸네일 모드 설계 & 구현
date: 2025-10-18 21:25:23 +0900
category: 영상처리
---
# 썸네일 모드 설계 & 구현
> **목표**  
> - JPEG을 **1/2 또는 1/4 스케일 디코드**(libjpeg/libjpeg-turbo의 `scale_num/scale_denom`)로 썸네일을 **빠르게** 만든다.  
> - **스크롤 리스트(갤러리/파일 브라우저)**에서는 **항상** 이 경로만 사용해 **지연 없이 미리보기**를 띄운다.  
> - (선택) EXIF Orientation을 반영한 회전/반전, 간단 캐시(LRU), 비동기 로더(워커 스레드)까지 **엔드투엔드 예제** 제공.  
> - 코드는 한 번만 ``` 로 감싸며, 수식은 MathJax를 사용한다.

---

## 0) 왜 `scale_denom` 썸네일이 빠른가?

일반 디코드는 DCT를 전부 복원해 **풀 해상도**로 펼친 뒤 다운스케일한다.  
반면 **libjpeg의 축소 디코드**는 **IDCT 단계 자체를 축소형**으로 수행한다(1/2, 1/4, 1/8).  
즉, **계산량·메모리 대역**이 처음부터 줄어 체감속도가 크게 개선된다.

- 지원 축소비: \(\frac{\text{scale\_num}}{\text{scale\_denom}} \in \{\frac{1}{1}, \frac{1}{2}, \frac{1}{4}, \frac{1}{8}\}\)  
- 출력 가로/세로:  
  \[
  W_{\text{out}} \approx \left\lceil \frac{W_{\text{in}} \cdot \text{scale\_num}}{\text{scale\_denom}} \right\rceil,\quad
  H_{\text{out}} \approx \left\lceil \frac{H_{\text{in}} \cdot \text{scale\_num}}{\text{scale\_denom}} \right\rceil
  \]
  (정확한 값은 `jpeg_calc_output_dimensions` 또는 `jpeg_start_decompress` 후 필드에서 확인)

> **실전 권장**  
> - 썸네일 그리드(예: 128~320px): **1/4**을 1순위, 너무 작으면 **1/2**.  
> - 상세 보기(줌 X): **1/2**로 빠른 프리뷰 → 사용자가 클릭하면 **풀 해상도**로 재디코드.

---

## 1) 핵심: 축소 디코더(1/2, 1/4) 구현

아래 예제는 **안전한 오류 처리(setjmp)**, **APP 마커 저장 옵션**, **색공간 설정**을 포함한 **범용 썸네일 디코더**다.

```cpp
#include <jpeglib.h>
#include <cstdio>
#include <vector>
#include <string>
#include <csetjmp>
#include <memory>
#include <stdexcept>

struct FileCloser { void operator()(FILE* f) const { if (f) fclose(f); } };
using FilePtr = std::unique_ptr<FILE, FileCloser>;

struct JpegErrorMgr {
    jpeg_error_mgr pub;
    jmp_buf jb;
    static void error_exit(j_common_ptr cinfo) {
        JpegErrorMgr* self = (JpegErrorMgr*)cinfo->err;
        char buffer[JMSG_LENGTH_MAX];
        (*cinfo->err->format_message)(cinfo, buffer);
        // 메시지를 로깅하거나 디버그 출력 가능
        longjmp(self->jb, 1);
    }
};

struct ImageBGRA {
    int w=0, h=0, stride=0; // stride = w*4
    std::vector<unsigned char> data; // BGRA(또는 RGBX) 8bpc
};

enum class ThumbScale { Full=1, Half=2, Quarter=4 };

// 썸네일 디코드: scale_denom=2(1/2), 4(1/4) 지원
bool DecodeJpegScaledToBGRA(const std::string& path, ThumbScale denom, ImageBGRA& out)
{
    FilePtr fp(fopen(path.c_str(), "rb"));
    if (!fp) return false;

    JpegErrorMgr jerr{};
    jpeg_decompress_struct dinfo{};
    dinfo.err = jpeg_std_error(&jerr.pub);
    jerr.pub.error_exit = JpegErrorMgr::error_exit;

    if (setjmp(jerr.jb)) { // libjpeg 예외 → 안전 복구
        jpeg_destroy_decompress(&dinfo);
        return false;
    }

    jpeg_create_decompress(&dinfo);
    jpeg_stdio_src(&dinfo, fp.get());

    // (선택) EXIF/ICC 등 읽을 계획이 있으면 마커 세이브
    // jpeg_save_markers(&dinfo, JPEG_APP0+1, 0xFFFF); // APP1(EXIF)
    // jpeg_save_markers(&dinfo, JPEG_APP0+2, 0xFFFF); // APP2(ICC)

    if (jpeg_read_header(&dinfo, TRUE) != JPEG_HEADER_OK)
        throw std::runtime_error("bad header");

    // 축소 설정
    dinfo.scale_num = 1;
    switch(denom){
        case ThumbScale::Full:   dinfo.scale_denom = 1; break;
        case ThumbScale::Half:   dinfo.scale_denom = 2; break;
        case ThumbScale::Quarter:dinfo.scale_denom = 4; break;
    }

    // 출력 색공간: libjpeg-turbo가 있다면 BGRA(혹은 BGRX)로 바로 뽑아 GDI 전송 최적화
    // 표준 libjpeg만 쓰면 JCS_RGB로 받고 나중에 BGRX로 변환해도 됨.
#ifdef JCS_EXTENSIONS
    dinfo.out_color_space = JCS_EXT_BGRX; // BGRA와 메모리 동일(알파=0xFF)
#else
    dinfo.out_color_space = JCS_RGB;
#endif

    jpeg_calc_output_dimensions(&dinfo); // 예측 출력 크기 확인(옵션)

    jpeg_start_decompress(&dinfo);
    const int W = dinfo.output_width;
    const int H = dinfo.output_height;

#ifdef JCS_EXTENSIONS
    out.w=W; out.h=H; out.stride=W*4;
    out.data.assign((size_t)out.stride*H, 0xFF);
    while (dinfo.output_scanline < dinfo.output_height) {
        JSAMPROW row = (JSAMPROW)(out.data.data() + (size_t)out.stride * dinfo.output_scanline);
        jpeg_read_scanlines(&dinfo, &row, 1);
    }
#else
    // JCS_RGB로 받은 뒤 BGRA로 변환
    std::vector<unsigned char> tmpRGB((size_t)W*3);
    out.w=W; out.h=H; out.stride=W*4;
    out.data.assign((size_t)out.stride*H, 0xFF);
    while (dinfo.output_scanline < dinfo.output_height) {
        JSAMPROW row = tmpRGB.data();
        jpeg_read_scanlines(&dinfo, &row, 1);
        // RGB → BGRA
        unsigned char* dst = out.data.data() + (size_t)out.stride*(dinfo.output_scanline-1);
        const unsigned char* src = tmpRGB.data();
        for(int x=0; x<W; ++x){
            unsigned char r=src[3*x+0], g=src[3*x+1], b=src[3*x+2];
            dst[4*x+0]=b; dst[4*x+1]=g; dst[4*x+2]=r; dst[4*x+3]=0xFF;
        }
    }
#endif

    jpeg_finish_decompress(&dinfo);
    jpeg_destroy_decompress(&dinfo);
    return true;
}
```

**포인트**  
- `dinfo.scale_num=1; scale_denom=2 or 4` 로 축소.  
- `jpeg_calc_output_dimensions` 또는 `jpeg_start_decompress` 이후 `output_width/height`로 **실제 크기** 사용.  
- libjpeg-turbo가 있다면 **확장 색공간**(예: `JCS_EXT_BGRX`)로 **곧바로 GDI 친화 버퍼** 획득 → 추가 변환 비용 제거.

---

## 2) (선택) 썸네일에서도 EXIF Orientation 반영

썸네일이 화면에서 뒤집혀 보이지 않도록, EXIF Orientation(1~8)을 **가볍게** 반영한다.  
이미 앞서 만든 Orientation 파서가 있다면 재사용하고, 여기서는 **소형 썸네일 전용 회전/반전**만 스케치한다.

```cpp
// BGRA 썸네일에 간단 회전/반전 적용 (성능 위해 소형만)
ImageBGRA Rotate90CW(const ImageBGRA& s){
    ImageBGRA d; d.w=s.h; d.h=s.w; d.stride=d.w*4; d.data.resize((size_t)d.stride*d.h, 0xFF);
    for(int y=0;y<s.h;++y){
        const unsigned char* sp = s.data.data()+ (size_t)s.stride*y;
        for(int x=0;x<s.w;++x){
            const unsigned char* px = sp + 4*x;
            int nx=y, ny=d.h-1-x;
            unsigned char* dp = d.data.data()+ (size_t)d.stride*ny + 4*nx;
            dp[0]=px[0]; dp[1]=px[1]; dp[2]=px[2]; dp[3]=px[3];
        }
    }
    return d;
}
// FlipH/FlipV, Rot180 등도 동일 패턴(생략). Orientation 테이블은 앞서 정의대로.
```

> **실무 팁**: 썸네일은 작은 크기라 **회전/반전의 CPU 비용이 미미**하다. 반대로 **정확한 색관리(ICC 변환)**은 썸네일 단계에서는 **생략**하고, 상세 보기에서 수행해도 만족도가 높다.

---

## 3) 썸네일 캐시(LRU) — 스크롤 성능 핵심

스크롤 중 같은 이미지를 여러 번 디코드하지 않도록 **(path, denom)** 키로 **메모리 캐시**한다.

```cpp
#include <list>
#include <unordered_map>

struct ThumbKey { std::string path; int denom; };
struct KeyHash {
    size_t operator()(const ThumbKey& k) const noexcept {
        std::hash<std::string> hs; std::hash<int> hi;
        return (hs(k.path) ^ (hi(k.denom)<<1));
    }
};
struct KeyEq {
    bool operator()(const ThumbKey& a, const ThumbKey& b) const noexcept {
        return a.denom==b.denom && a.path==b.path;
    }
};

class ThumbnailCache {
    struct Node { ThumbKey key; ImageBGRA img; };
    size_t cap;
    std::list<Node> lst; // MRU front
    std::unordered_map<ThumbKey, std::list<Node>::iterator, KeyHash, KeyEq> map;
public:
    explicit ThumbnailCache(size_t capacity=128):cap(capacity){}
    bool get(const ThumbKey& k, ImageBGRA& out){
        auto it=map.find(k); if(it==map.end()) return false;
        lst.splice(lst.begin(), lst, it->second);
        out = it->second->img;
        return true;
    }
    void put(const ThumbKey& k, const ImageBGRA& img){
        auto it=map.find(k);
        if(it!=map.end()){
            it->second->img=img;
            lst.splice(lst.begin(), lst, it->second);
            return;
        }
        if(lst.size()>=cap){
            auto& back = lst.back();
            map.erase(back.key); lst.pop_back();
        }
        lst.push_front(Node{k,img});
        map.emplace(k, lst.begin());
    }
};
```

---

## 4) 비동기 로더(워커 스레드) & 취소 토큰

UI(스크롤) 스레드에서 디코드를 하면 끊긴다. **워커 스레드**에서 디코드하고, 완료 시 **UI에 포스트**하자.  
간단한 **작업 큐 + 취소 토큰** 예제:

```cpp
#include <thread>
#include <atomic>
#include <condition_variable>
#include <queue>

struct ThumbTask {
    std::string path;
    ThumbScale denom;
    std::atomic<bool>* cancel = nullptr; // 스크롤로 가려지면 true
    void(*onReady)(const std::string&, const ImageBGRA&)=nullptr; // UI 업데이트 콜백
};

class ThumbWorker {
    std::thread th;
    std::mutex m;
    std::condition_variable cv;
    std::queue<ThumbTask> q;
    std::atomic<bool> stop{false};
public:
    void start() {
        th = std::thread([this]{ run(); });
    }
    void stopSync() {
        stop=true; cv.notify_all();
        if(th.joinable()) th.join();
    }
    void enqueue(const ThumbTask& t){
        std::unique_lock<std::mutex> lk(m);
        q.push(t); cv.notify_one();
    }
private:
    void run(){
        while(!stop){
            ThumbTask t;
            {
                std::unique_lock<std::mutex> lk(m);
                cv.wait(lk, [&]{return stop || !q.empty();});
                if(stop) break;
                t=q.front(); q.pop();
            }
            if(t.cancel && *t.cancel) continue; // 이미 가려짐

            ImageBGRA img;
            if(DecodeJpegScaledToBGRA(t.path, t.denom, img)){
                if(t.cancel && *t.cancel) continue;
                if(t.onReady) t.onReady(t.path, img); // UI에 포스트(스레드 주의)
            }
        }
    }
};
```

> **UI 통합**: MFC라면 `onReady`에서 `PostMessage(hWnd, WM_APP_THUMB_READY, ...)`로 썸네일 핸들을 보내고, UI 스레드에서 DIB로 그린다.

---

## 5) MFC/Win32에서 **그리기**(StretchDIBits)

BGRA 썸네일을 **DIB**로 바로 그리면 가장 간단하다.

```cpp
// BGRA 썸네일을 (x,y,w,h)에 그리기
void BlitBGRA(HDC hdc, const ImageBGRA& img, int x, int y, int w, int h)
{
    BITMAPINFO bmi = {};
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth  = img.w;
    bmi.bmiHeader.biHeight = -img.h; // top-down
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    StretchDIBits(hdc,
        x, y, w, h,
        0, 0, img.w, img.h,
        img.data.data(), &bmi, DIB_RGB_COLORS, SRCCOPY);
}
```

> **팁**  
> - 썸네일 가로/세로를 **고정 셀**(예: 160×160)로 잡고 `StretchDIBits`로 맞춘다.  
> - 가로세로 비율 유지: 이미지 짧은 변 기준으로 fit 후 여백(레터박스/필러박스)을 칠한다.

---

## 6) 스크롤 리스트에서 **이 경로만 사용**하는 규칙

1. **가시 영역** 아이템만 작업 큐에 넣는다(가상 리스트/타일뷰).  
2. 각 아이템은 **(path, denom)** 키로 **LRU 캐시 조회** → 히트면 즉시 그림.  
3. 미스면 **워커 enqueue**(`denom = Quarter` 기본, 필요 시 Half).  
4. 스크롤 이동 시 기존 작업 **취소 토큰 true** → 쌓인 작업 낭비 방지.  
5. 사용자 클릭/확대 시에만 **풀 해상도 디코드**.

---

## 7) 품질·성능 가이드

- **denom 선택**:  
  - 썸네일 셀 크기 \(S\)와 원본 크기 \(W\times H\) 에 대해,  
    \[
    \text{denom} = 
      \begin{cases}
      4 & \text{if } \max(W,H)/4 \ge S\\
      2 & \text{else if } \max(W,H)/2 \ge S\\
      1 & \text{else}
      \end{cases}
    \]
- **색공간**: 썸네일에서는 **ICC 변환 생략**(속도 우선). 색 정확도는 상세 보기에서.  
- **Orientation**: 적용 권장(작은 비용).  
- **메모리**: 256×256×4 ≈ 256KB/썸네일. 캐시 200개면 ~50MB.  
- **에러내성**: setjmp 기반 복구, 입력 픽셀 상한(폭탄 방지) 권장.

---

## 8) 시나리오: 디렉터리 갤러리

- 파일 목록을 읽어 가상 리스트에 바인딩  
- 뷰포트 진입 시 `ThumbWorker.enqueue({path, ThumbScale::Quarter, &cancelFlags[i], OnReady});`  
- `OnReady`에서는 `cache.put({path,4}, img); PostMessage(WM_APP_THUMB_READY, idx, 0);`  
- `WM_APP_THUMB_READY` 핸들러에서 `InvalidateRect(cell)`로 재그리기

---

## 9) 트러블슈팅

| 증상 | 원인 | 해결 |
|---|---|---|
| 이미지 비율 깨짐 | Fit 계산 실수 | 짧은 변 기준 스케일, 레터박스 처리 |
| 스크롤 끊김 | UI 스레드 디코드 | **워커 스레드**로 이동, 캐시 도입 |
| 색 다름(붉거나 물빠짐) | 썸네일에서 ICC 무시 | 상세 보기에서만 ICC 적용, 썸네일은 sRGB 가정 |
| 뒤집혀 보임 | EXIF 미적용 | Orientation 빠른 적용 |
| 메모리 급증 | 캐시 무한증식 | **LRU** 용량 제한 |

---

## 10) 통합 샘플: “썸네일만 `scale_denom=2/4`”

```cpp
// 호출 예시
ThumbnailCache g_cache(256);
ThumbWorker   g_worker;

// UI 스크롤 시 가시 셀에 대해:
void RequestThumb(const std::string& path, int cellSize, std::atomic<bool>& cancelFlag,
                  void(*OnReady)(const std::string&, const ImageBGRA&))
{
    // denom 결정
    // (실제 원본 크기가 필요하면 JPEG header만 읽어 가로/세로를 얻는 경량 루틴 사용)
    ThumbScale denom = ThumbScale::Quarter; // 기본
    // 상황에 따라 Half로 올리기
    // if (expectedOutShorterSide < cellSize*0.7) denom = ThumbScale::Half;

    // 캐시 조회
    ImageBGRA img;
    if (g_cache.get({path,(int)denom}, img)) {
        OnReady(path, img);
        return;
    }
    // 워커 enqueue (썸네일 경로만 사용)
    g_worker.enqueue(ThumbTask{
        path, denom, &cancelFlag,
        // 완료 콜백: 캐시에 넣고 UI 갱신
        [](const std::string& p, const ImageBGRA& im){
            g_cache.put({p, (int)ThumbScale::Quarter /*실제 denom 전달 필요*/}, im);
            // 여기서는 간단화. 실제론 denom도 키로 넣기
            OnReady(p, im);
        }
    });
}
```

> 실제 코드에서는 `ThumbTask`에 **denom도 키로 전파**하고, Orientation 적용/캡션 텍스트/오버레이(선택)를 함께 처리하면 된다.

---

## 11) 요약

- 썸네일 리스트/스크롤 구간에서는 **항상** `scale_denom=2`(1/2) 또는 `4`(1/4) **축소 디코드 경로만** 사용하라.  
- 이것만으로 **CPU·메모리·지연**이 크게 줄어들고, 스크롤 UX가 **즉시 반응**한다.  
- **LRU 캐시 + 워커 스레드 + Orientation 보정**을 얹으면, 복잡한 최적화 없이도 **실전 수준**의 갤러리를 만들 수 있다.  
- 색 정확성(ICC)은 **상세 보기**에서 처리하되, 썸네일에서는 **속도 우선**이 현명하다.
