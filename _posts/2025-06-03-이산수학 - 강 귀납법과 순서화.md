---
layout: post
title: 이산수학 - 강한 수학적 귀납법과 순서화
date: 2025-06-03 19:20:23 +0900
category: 이산수학
---
# 강한 수학적 귀납법과 순서화 원리 (Strong Induction & Well-Ordering)


## 0. 왜 이 주제가 중요한가?

자연수 전반에 걸친 명제의 **정확한 증명**은 수학·컴퓨터과학의 기초다.  
그 핵심 도구가 **수학적 귀납법(ordinary induction)**, 그 일반화인 **강한 수학적 귀납법(strong induction)**, 그리고 **순서화 원리(well-ordering principle)**다.  
세 개념은 **논리적으로 동치**이며, 증명 전략·알고리즘 정당성·종료성 보증에 널리 쓰인다.

---

## 1. 강한 수학적 귀납법 (Strong Induction)

### 1.1 정식 스키마

자연수의 부분집합 $$S\subseteq\mathbb{N}$$ 과 명제 $$P(n)$$ 에 대하여, 어떤 기저값 $$n_0\in\mathbb{N}$$ 에 대해

1. **기초 단계**: $$P(n_0), P(n_0+1), \dots, P(n_0+r)$$ 를 증명한다(필요한 만큼 여러 개일 수 있음).
2. **귀납 단계(강한 가정)**: 임의의 $$k\ge n_0+r$$ 에 대하여  
   $$P(n_0),P(n_0+1),\dots,P(k)\ \text{가 모두 참} \ \Rightarrow\ P(k+1)\ \text{참}.$$

그러면 모든 $$n\ge n_0$$ 에 대해 $$P(n)$$ 이 참이다.

> 표준 귀납법은 “$$P(k)\Rightarrow P(k+1)$$” 하나만 가정한다. 강한 귀납법은 “$$\forall m\le k,\ P(m)$$”을 가정해 더 강력해 보이지만 **논리적 위력은 동등**하다(§4 참조).

---

### 1.2 전형적 예시 ① — 모든 정수의 소인수분해

**명제**: $$\forall n\ge 2,\ \ n\ \text{은 소수들의 곱으로 표현된다.}$$

- **기초**: $$n=2$$ 는 소수 → 성립.
- **귀납 가정(강한)**: $$2\le m\le k$$ 인 모든 $$m$$ 에 대해 명제가 성립.
- **귀납 단계**:  
  - $$k+1$$ 이 소수면 끝.  
  - 합성수면 $$k+1=ab$$ (단, $$2\le a,b\le k$$). 강한 가정으로 $$a,b$$ 는 각각 소수들의 곱 → 곱하면 $$k+1$$ 도 소수들의 곱.

---

### 1.3 전형적 예시 ② — 동전 문제(표준 반례 설계 포함)

액면가가 $$\{1,3,4\}$$ 인 동전으로 **모든 $$n\ge 1$$ 값을 지불 가능**임을 보인다.

- **기초**:  
  $$n=1(1),\ n=2(1+1),\ n=3(3),\ n=4(4)$$ 모두 가능.
- **귀납 단계**: $$k\ge 4$$ 에 대하여, $$1\le m\le k$$ 모두 가능하다고 가정.  
  $$k+1$$ 에 대해 $$k-2\ge 1$$ 이므로 $$k-2$$ 도 가능(강한 가정). 여기에 $$3$$ 을 더해 $$k+1=(k-2)+3$$ 가능.

> **포인트**: 표준 귀납법(오직 $$P(k)$$ 만 가정)으로는 위 추론이 매끄럽지 않다. 강한 귀납은 **이전의 많은 값들을 동시에 가정**해 재귀/분할 문제에 적합하다.

---

### 1.4 전형적 예시 ③ — 분할정복/재귀 알고리즘의 정확성

예: 길이 $$n$$ 배열의 최소값을 “반으로 쪼개어” 찾는 재귀 알고리즘의 정확성.

- **기초**: $$n=1$$ 일 때 trivially 이 원소가 최소.
- **귀납 단계(강한)**: 길이 $$\le k$$ 배열에 대해 알고리즘이 올바르다고 가정.  
  길이 $$k+1$$ 배열을 절반씩 나누어 각각 최소값을 구하면(귀납 가정), 전체 최소는 두 최소값의 더 작은 쪽.

---

## 2. 순서화 원리 (Well-Ordering Principle, WOP)

### 2.1 정의

$$\mathbb{N}$$ 의 **빈 집합이 아닌 모든 부분집합**은 **최소 원소**를 갖는다.

- 예: $$\{7,13,29,5,100\}$$ 의 최소는 $$5$$.
- 예: $$B=\{x\in\mathbb{N}\mid x\ge 1000,\ x\equiv 3 \pmod{5}\}$$ 의 최소는 $$1003$$.

### 2.2 최소 반례 원리(Minimal Counterexample)

명제 $$P(n)$$ 에 대해 반례들의 집합  
$$A=\{n\in\mathbb{N} \mid P(n)\ \text{이 거짓}\}$$  
이 비어있지 않다고 가정하면, WOP로 **최소 반례** $$m=\min A$$ 가 존재.  
대개 $$m$$ 의 바로 이전 값들에 대한 사실로부터 $$P(m)$$ 을 유도 → 모순.  
따라서 $$A=\emptyset$$ → 모든 $$n$$ 에 대해 $$P(n)$$ 참.

> 이 테크닉은 실전 증명에서 **가장 많이 쓰이는 귀납 변형**이다.

---

## 3. WOP, 표준 귀납, 강한 귀납의 **동치성**

세 명제는 **쌍방향으로 서로를 함의**한다.

### 3.1 WOP ⇒ (표준) 수학적 귀납법

증명 스케치: “최소 반례 원리” 사용.  
$$P(n_0)$$ 성립, 그리고 $$P(k)\Rightarrow P(k+1)$$ 이라는 귀납 단계를 가정하자.  
반례 집합 $$A$$ 가 비어있지 않다면 $$m=\min A$$ 가 존재.  
그러면 $$m>n_0$$ 이고, $$m-1\notin A$$ 이므로 $$P(m-1)$$ 참. 귀납 단계로 $$P(m)$$ 도 참이어야 해 모순.  
따라서 반례가 없고 모든 $$n\ge n_0$$ 에 대해 $$P(n)$$ 성립.

### 3.2 (표준) 수학적 귀납법 ⇒ 강한 귀납법

강한 귀납에서의 명제 $$P(n)$$ 에 대해  
새 명제 $$Q(n)\equiv(\forall m\le n\Rightarrow P(m))$$ 를 정의.  
표준 귀납을 $$Q(n)$$ 에 적용하면 $$Q(n)$$ 이 모든 $$n$$ 에 대해 참이 되고, 특히 각 $$n$$ 에 대해 $$P(n)$$ 도 참.

### 3.3 강한 귀납법 ⇒ WOP

임의의 비어있지 않은 집합 $$S\subseteq\mathbb{N}$$ 에 최소 원소가 있음을 보이려면,  
명제 $$P(n)\equiv(\exists s\in S\ \text{s.t.}\ s\le n\ \text{이 성립})$$ 에 강한 귀납을 적용한다.  
적절한 $$n_0$$ 를 잡고, “만일 $$n$$ 까지에 해당 원소가 없다면 $$n+1$$ 에도 없다”가 모순임을 보이면 **최초로 참이 되는 순간**이 존재 → 그 값이 바로 최소 원소.

> 결론: 세 원리는 **서로 동치**이며, 교재에 따라 어떤 것을 공리/정리로 삼을지 선택만 다르다.

---

## 4. 알고리즘에서의 활용

### 4.1 종료성(termination) — 순서화 원리의 즉효

**유클리드 알고리즘**이 항상 끝남:  
반복에서 나머지들이  
$$
r_0>a_1=r_1>r_2>\cdots\ge 0
$$
처럼 **자연수에서 진정 감소**한다. $$\mathbb{N}$$ 은 순서화되어 있으므로 무한히 감소할 수 없어 **유한 단계 후 0에 도달** → 종료.

```python
def gcd(a, b):
    """Euclid 알고리즘: 종료성은 나머지들이 N에서 진정 감소하므로 WOP로 보장."""
    while b != 0:
        a, b = b, a % b
    return a
```

### 4.2 정확성(correctness) — 강한 귀납의 정석

**병합 정렬**의 정확성(“정렬된 두 반쪽을 병합하면 전체가 정렬”):  
길이 $$\le k$$ 배열에 대해 올바르다고 가정(강한 가정). 길이 $$k+1$$ 은 절반씩 재귀 정렬(가정으로 정렬됨) → 병합 절차의 루프 불변식으로 정렬 보장.

### 4.3 “답에 대한 이분 탐색”의 정당화

판정 함수 $$F(m)$$ 이 **단조(True→True)** 라고 하자(예: 최소 용량으로 가능/불가능).  
최소의 True 지점의 존재성은 많은 경우 **WOP**(최소 True 인덱스 존재)로, 이분 탐색의 수렴은 **강한 귀납**으로 정당화할 수 있다.

---

## 5. 실전 예제 3선 + 코드

### 5.1 동전 최소 개수(강한 귀납의 의도와 DP 일치)

액면가 $$\{1,3,4\}$$ 로 합이 $$n$$ 이 되도록 **동전 최소 개수**를 $$C(n)$$ 이라 하자.
강한 귀납 가정: $$1\le m\le k$$ 에 대해 최적값 $$C(m)$$ 이 정의·정확하다면,
$$
C(k+1)=1+\min\{\,C(k),\ C(k-2),\ C(k-3)\,\}
$$
이 성립(가능한 전 단계로부터 1개를 더한 구조적 최적성).

```python
def min_coins(n, coins=(1,3,4)):
    INF = 10**9
    C = [0] + [INF]*n
    for x in range(1, n+1):
        for c in coins:
            if x-c >= 0 and C[x-c] + 1 < C[x]:
                C[x] = C[x-c] + 1
    return C  # 강한 귀납의 점화식이 DP 테이블로 실체화
```

### 5.2 타일 채우기(2×n 도미노) — 여러 기초 단계

$$T(n)$$: 2×n 보드를 1×2 도미노로 채우는 경우의 수.  
$$
T(0)=1,\ T(1)=1,\quad T(n)=T(n-1)+T(n-2)\ (n\ge 2)
$$
강한 귀납: 세로 도미노(왼쪽 한 열 제거) 또는 가로 두 개(왼쪽 두 열 제거) 둘 중 하나.

```python
def tilings(n):
    T = [0]*(n+2)
    T[0], T[1] = 1, 1
    for k in range(2, n+1):
        T[k] = T[k-1] + T[k-2]
    return T[n]
```

### 5.3 최소 반례 원리로 등식 증명 (가우스 합)

명제 $$P(n):\ \ \sum_{k=1}^{n}k=\dfrac{n(n+1)}{2}$$.  
반례 집합 $$A=\{n\mid P(n)\ \text{거짓}\}$$ 이 비었다고 하자. 만약 비어있지 않다면 $$m=\min A$$.  
$$m>1$$ 이고 $$m-1\notin A \Rightarrow P(m-1)$$ 참. 그러면
$$
\sum_{k=1}^{m}k=\sum_{k=1}^{m-1}k+m=\frac{(m-1)m}{2}+m=\frac{m(m+1)}{2},
$$
즉 $$P(m)$$ 도 참 → 모순. 따라서 반례 없음.

---

## 6. 자주 하는 실수와 처방

1. **기초 단계 부족**: 점화가 $$n-2,n-3$$ 등을 참조하면 **여러 기초값**이 필요.  
2. **강한 가정 사용 망설임**: 재귀·분할정복·“이전 여러 값”을 참조하는 문제는 강한 귀납이 자연스럽다.  
3. **최소 반례의 존재**를 **WOP 없이** 암묵적으로 쓰는 오류: 자연수라서 가능하다는 점을 명시.  
4. **종료성** 증명 누락: 값이 **정수에서 진정 감소**(또는 증가)함을 꼭 적어라.

---

## 7. 세 원리의 요약 비교

| 원리 | 핵심 문장 | 전형적 용도 | 한 줄 요약 |
|---|---|---|---|
| 표준 귀납 | $$P(n_0),\ P(k)\Rightarrow P(k+1)$$ | 등식·부등식 | 한 칸씩 전진 |
| **강한 귀납** | $$\bigwedge_{m\le k} P(m)\Rightarrow P(k+1)$$ | 재귀·분할정복 | 뒤를 다 끌어안고 전진 |
| **순서화 원리** | $$\emptyset\ne S\subseteq\mathbb{N}\Rightarrow \min S\ \text{존재}$$ | 종료성·최소 반례 | “가장 작은 놈”은 항상 있다 |

세 원리는 **동치**이므로 상황에 맞는 것을 골라 쓰면 된다.

---

## 8. 연습 문제 (해설 스케치 포함)

1) **베주 정리의 특수형**: $$\gcd(a,b)$$ 를 유클리드 알고리즘으로 구할 때, 알고리즘이 종료함을 WOP로 증명하라.  
→ 나머지 열이 자연수에서 진정 감소.

2) **피보나치의 항등식**: $$F_{n+2}=F_{n+1}+F_n,\ F_0=0,\ F_1=1$$ 일 때,  
$$\sum_{k=0}^{n}F_k = F_{n+2}-1$$ 을 강한 귀납으로 증명.  
→ 기초 $$n=0$$, 귀납: 좌변에 $$F_{n+1}$$ 추가 후 점화 대입.

3) **코인체인지 가능성**: 액면가가 $$\{5,7\}$$ 일 때, **모든 충분히 큰 $$n$$** 은 표현 가능함을 강한 귀납으로 증명(프뢴베르크 수와 연결).  
→ 기초 여러 개 세우고 $$n-5$$, $$n-7$$ 중 하나에 귀납 가정 적용.

---

## 9. Python 미니 실험: “최소 반례 탐색기”

증명할 등식/부등식에 대해, 작은 범위에서 **존재하면 최소 반례를 찾아** 휴리스틱 점검.

```python
def find_min_counterexample(P, n0=1, limit=1000):
    """
    P: int -> bool, n0부터 시작하는 명제 판정자
    존재하면 최소 반례를 반환, 없으면 None
    """
    for n in range(n0, limit+1):
        if not P(n):
            return n
    return None

# 예: 가우스 합(테스트)
def gauss_ok(n):
    lhs = sum(range(1, n+1))
    rhs = n * (n + 1) // 2
    return lhs == rhs

print(find_min_counterexample(gauss_ok, 1, 10000))  # None
```

> 물론 이건 “증명”이 아니라 **검산 도우미**다. 진짜 증명은 WOP/귀납으로 한다.

---

## 10. 결론

- **강한 귀납법**은 재귀/분할정복/DP 점화식의 자연어다.  
- **순서화 원리**는 종료성과 최소 반례 논법의 핵심이다.  
- 세 원리(표준 귀납·강한 귀납·WOP)는 **동치**이므로,  
  **문제의 구조**에 맞는 도구를 선택해 간결하고 견고한 증명을 세워라.

--- 

## 부록: 형식적 동치의 한 줄 증명 모음

1) **WOP ⇒ 표준 귀납**: 최소 반례 존재 가정 → 귀납 단계로 모순.  
2) **표준 ⇒ 강한**: $$Q(n)\equiv(\forall m\le n:\ P(m))$$ 에 표준 귀납 적용.  
3) **강한 ⇒ WOP**: $$P(n)\equiv(\exists s\in S: s\le n)$$ 에 강한 귀납 적용 → 최초로 참이 되는 순간이 최소 원소.

이로써 **세 원리는 서로 서로를 보증**한다.