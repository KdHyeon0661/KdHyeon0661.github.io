---
layout: post
title: JavaScript - Babel과 트랜스파일링
date: 2025-05-23 19:20:23 +0900
category: JavaScript
---
# Babel과 트랜스파일링 개념

## Babel이란? (정의·목적·수식적 비유)

- **정의**: Babel은 **소스 수준**의 변환기(**transpiler**).
  $$\text{ESNext(Source)} \xrightarrow{\text{Parse}} \text{AST} \xrightarrow{\text{Transform}} \text{AST}' \xrightarrow{\text{Generate}} \text{ES5(Output)}$$
- **목적**:
  1) 최신 **문법(feature)**을 구형 엔진도 이해 가능한 코드로 변환
  2) 부족한 **기능(builtin/API)**은 **polyfill**로 채움 (옵션)
  3) JSX, TS 등 **비표준 문법**을 JS로 변환

> **문법 변환**과 **기능 보강**은 별개입니다. 화살표 함수(문법)는 변환 가능하지만, `Promise`(기능)는 **polyfill**이 필요합니다.

---

## Babel 작동 파이프라인 (AST 관점)

1. **Parsing**: 코드 → **AST(Abstract Syntax Tree)**
2. **Transform**: 플러그인이 AST를 방문/수정
3. **Generate**: 수정된 AST → 문자열 코드 + 소스맵

```text
[Source] → [@babel/parser] → AST → [@babel/traverse + plugins] → New AST → [@babel/generator] → [Output + SourceMap]
```

---

## 트랜스파일링 vs 컴파일링

- **Compile**: 상이한 수준(언어/플랫폼) 간 변환 (C → LLVM IR/바이너리)
- **Transpile**: **동일 계층** 언어의 문법 변환 (ESNext → ES5)

### 간단 예시: 화살표 함수 + 기본 매개변수

```js
// ES6+
const greet = (name = "익명") => {
  console.log(`안녕하세요, ${name}`);
};
```

```js
// Babel ES5 출력(개념적)
"use strict";
var greet = function greet() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "익명";
  console.log("안녕하세요, " + name);
};
```

---

## 빠른 시작: 설치·기본 명령

```bash
npm init -y
npm i -D @babel/core @babel/cli @babel/preset-env
```

`babel.config.json`
```json
{
  "presets": ["@babel/preset-env"]
}
```

폴더 변환:
```bash
npx babel src --out-dir dist --source-maps
```

`package.json` 스크립트 예시:
```json
{
  "scripts": {
    "build": "babel src -d dist --source-maps",
    "watch": "babel src -d dist -w --source-maps"
  }
}
```

---

## preset-env + Browserslist: “필요한 것만” 변환/폴리필

### Browserslist로 타깃 정의

`package.json`
```json
{
  "browserslist": [
    ">0.25%",
    "not dead",
    "ie 11"
  ]
}
```

> Babel은 **caniuse-lite** 데이터로 타깃 지원 현황을 계산해, **정말 필요한 변환만** 적용합니다.

### Polyfill 전략(core-js) — `useBuiltIns`

`@babel/preset-env` 옵션:
- `useBuiltIns: "entry"`: 앱 진입점에서 **명시적으로** 폴리필 import → Babel이 타깃에 맞게 **가지치기(tree-shaking-like injection)**
- `useBuiltIns: "usage"`: 코드 사용 위치를 스캔해 **필요 시점에만** 폴리필 import 자동 삽입
- `corejs`: 사용할 core-js 버전 명시 (보통 `"3"` 혹은 `{ "version": "3.36", "proposals": true }`처럼 구체화)

설정 예:
```json
{
  "presets": [
    ["@babel/preset-env", {
      "targets": ">0.25%, not dead",
      "useBuiltIns": "usage",
      "corejs": "3.36"
    }]
  ]
}
```

**entry 방식 예** (`src/main.js`의 최상단에 추가):
```js
import "core-js/stable";
import "regenerator-runtime/runtime";
// 이후 앱 코드...
```

**usage 비교 예** (자동 주입)
```js
// ESNext 코드
const ok = [1,2,3].includes(2); // 필요하면 Array.prototype.includes polyfill만 주입
```

---

## Babel ≠ Polyfill (차이 정리)

| 구분        | Babel 변환                         | Polyfill(core-js 등)                         |
|-------------|------------------------------------|----------------------------------------------|
| 대상        | **문법**                           | **기능/빌트인**(API, 메서드)                 |
| 예          | `()=>{}` → `function(){}`          | `Array.prototype.includes`, `Promise`, `URL` |
| 적용 위치   | 코드 구조 변경                     | 전역/스코프에 기능 주입(런타임 필요)         |
| 필요 여부   | 타깃 엔진이 문법 미지원 시 필수     | 타깃 엔진이 해당 API 없음 → 선택적/필수      |

---

## @babel/plugin-transform-runtime: 헬퍼/레게너레이터 최적화

Babel은 변환 시 **헬퍼 함수**를 코드마다 삽입합니다(예: `extends`, `classCallCheck`). 프로젝트가 커지면 **중복**이 늘어날 수 있습니다.
**`@babel/plugin-transform-runtime`**은 헬퍼를 **공유 모듈(@babel/runtime)**로 바꿔 중복을 제거하고, `async/await`의 **regenerator**도 전역 오염 없이 사용하게 해줍니다.

```bash
npm i -D @babel/plugin-transform-runtime
npm i @babel/runtime
```

`babel.config.json`
```json
{
  "presets": [["@babel/preset-env", { "targets": ">0.25%, not dead" }]],
  "plugins": [
    ["@babel/plugin-transform-runtime", {
      "corejs": false,          // 폴리필은 여기서 관리하지 않음
      "helpers": true,          // 헬퍼 공유
      "regenerator": true       // async/await용
    }]
  ]
}
```

> **중요**: transform-runtime의 `corejs`를 `3`으로 켜면 “주입형 폴리필”이 아니라 **모듈 폴리필**이 사용되어 전역 보강 없이 동작하지만, **브라우저 전역을 기대하는 타 라이브러리**와 충돌할 여지가 있습니다. 브라우저 앱에서는 보통 **preset-env + core-js**(전역 폴리필) 전략이 더 흔합니다.

---

## 번들러와 연계 (Webpack/Vite/Rollup)

### Webpack

```bash
npm i -D babel-loader
```

`webpack.config.js`
```js
module.exports = {
  module: {
    rules: [{
      test: /\.m?js$/,
      exclude: /node_modules/,
      use: {
        loader: "babel-loader",
        options: {
          presets: [["@babel/preset-env", { targets: ">0.25%, not dead", useBuiltIns: "usage", corejs: "3.36" }]],
          plugins: [["@babel/plugin-transform-runtime", { helpers: true, regenerator: true }]]
        }
      }
    }]
  }
};
```

### Vite

- Vite는 기본적으로 **esbuild** 변환을 사용하지만, Babel 플러그인을 추가로 적용할 수 있습니다.
- 필요 시 `vite-plugin-babel` 또는 개별 플러그인 체인 활용.

### Rollup

```bash
npm i -D @rollup/plugin-babel
```
`rollup.config.js`
```js
import babel from "@rollup/plugin-babel";
export default {
  input: "src/main.js",
  output: { file: "dist/bundle.js", format: "iife", sourcemap: true },
  plugins: [
    babel({ babelHelpers: "runtime", exclude: /node_modules/ })
  ]
};
```

---

## JSX/TypeScript도 Babel로

### React(JSX)

```bash
npm i -D @babel/preset-react
```

`babel.config.json`
```json
{
  "presets": [
    ["@babel/preset-env", { "useBuiltIns": "usage", "corejs": "3.36" }],
    ["@babel/preset-react", { "runtime": "automatic" }]
  ]
}
```

### TypeScript

```bash
npm i -D @babel/preset-typescript
```

`babel.config.json`
```json
{
  "presets": [
    ["@babel/preset-env", { "targets": "defaults" }],
    "@babel/preset-typescript"
  ]
}
```

> Babel의 TS 변환은 **타입 제거**만 담당합니다. **타입 체크**는 `tsc --noEmit` 또는 `vue-tsc` 등으로 별도 수행하세요.

---

## Node.js 타깃 빌드 (런타임별 타깃 다르게)

```json
{
  "presets": [
    ["@babel/preset-env", { "targets": { "node": "18" } }]
  ]
}
```

- 서버 전용 빌드에서는 브라우저 폴리필이 불필요하거나 최소화됩니다.
- Node 버전이 높을수록 변환량이 감소 → 성능/번들 크기 이점.

---

## 소스맵·디버깅·성능

- `--source-maps` 또는 `sourceMaps: true`로 **원본 매핑**
- 변환량 최소화: 타깃 상향(최신 브라우저/Node), 불필요 플러그인 제거
- 폴리필 중복 방지: `usage`/`entry` 전략 일관성 유지, transform-runtime로 헬퍼 공유
- 배포 전 **`npx browserslist`**로 실제 타깃 목록 확인

---

## Babel 플러그인 직접 만들기(실전 감각)

> 예: `console.log`를 `console.debug`로 바꾸는 교육용 플러그인

```js
// plugins/console-to-debug.js
module.exports = function ({ types: t }) {
  return {
    name: "console-to-debug",
    visitor: {
      MemberExpression(path) {
        const { node } = path;
        if (
          t.isIdentifier(node.object, { name: "console" }) &&
          t.isIdentifier(node.property, { name: "log" })
        ) {
          node.property = t.identifier("debug");
        }
      }
    }
  };
};
```

`babel.config.json`
```json
{
  "presets": [["@babel/preset-env", { "targets": "defaults" }]],
  "plugins": ["./plugins/console-to-debug.js"]
}
```

테스트:
```js
// src/a.js
console.log("Hello"); // → console.debug("Hello")
```

---

## 실전 시나리오별 권장 세팅

### 레거시 브라우저 지원(IE11 포함)

- `targets`: `">0.2%, not dead, ie 11"`
- `preset-env`: `useBuiltIns: "entry"`, `corejs: "3.36"`
- 번들러: Webpack + `babel-loader`
- 주의: `Promise`, `fetch` 등 폴리필 포함 여부 검토

### 현대 브라우저 전용(SPA/사내툴)

- `targets`: `"last 2 chrome versions"` 등
- `preset-env`: 변환 최소화 → 번들 사이즈↓
- 폴리필: 필요한 일부만(usage), 또는 무폴리필

### Node 18+ 서버

- `targets`: `{ "node": "18" }`
- `transform-runtime`: 헬퍼 공유/async 지원, 폴리필 대체로 불필요
- 소스맵: `inline` 또는 외부 `.map`

### 라이브러리 배포(패키지)

- 출력: **Dual build**(ESM + CJS)
- `babelHelpers`: `"runtime"` 사용 + `@babel/runtime`를 `dependencies`로 둠
- 폴리필 **미포함** 권장(소비자 앱에서 결정하도록)

---

## Babel + 폴리필 동작 확인 (usage vs entry)

### usage

```json
{
  "presets": [
    ["@babel/preset-env", { "useBuiltIns": "usage", "corejs": "3.36" }]
  ]
}
```
```js
// src/index.js
[1,2,3].includes(2);   // 필요시 해당 메서드만 자동 주입
new Promise(()=>{});   // Promise 폴리필 삽입
```

### entry

```json
{
  "presets": [
    ["@babel/preset-env", { "useBuiltIns": "entry", "corejs": "3.36" }]
  ]
}
```
```js
// src/index.js
import "core-js/stable";
import "regenerator-runtime/runtime";
// 사용 여부와 무관하게 타깃에 필요한 전체를 주입(가지치기 적용)
```

> 팀 표준을 **하나로 통일**하세요. 혼용 시 중복/누락 이슈 발생 가능.

---

## 흔한 오류·FAQ

**Q1. “`regeneratorRuntime is not defined`”**
A. `async/await` 사용 시 발생. 해결책:
- (브라우저 전역 폴리필 전략) `import "regenerator-runtime/runtime"` 추가 또는 preset-env + core-js entry/usage로 처리
- (런타임 모듈 전략) `@babel/plugin-transform-runtime` + `@babel/runtime` 설치 및 설정

**Q2. “폴리필이 너무 커요.”**
A. `usage` 전략으로 **사용된 기능만** 주입, 타깃 상향, 중복 import 제거

**Q3. “디버깅이 힘들어요.”**
A. 소스맵 활성화 + 브라우저 DevTools에서 “원본” 보기. 개발 빌드는 변환 최소화

**Q4. “fetch가 안 돼요.”**
A. **Babel이 API를 제공하지는 않습니다.** `whatwg-fetch` 또는 Axios 등 별도 폴리필/라이브러리 필요

**Q5. “top-level await은?”**
A. 번들러가 모듈 그래프를 처리해야 합니다. 최신 Vite/Rollup/Webpack 설정에서 ESM 타깃이면 지원. 구형 타깃이면 적절한 트랜스폼/코드 스플리팅 필요

---

## 미니 실습 — REPL로 즉시 확인

- [Babel REPL](https://babeljs.io/repl)에서 **preset-env + targets**를 조절하며 어떤 코드가 변환되는지 바로 확인하세요.
- “Env Preset” → “Built-Ins”에서 `usage/entry` 차이도 실험 가능.

---

## 보안·성능 체크리스트

- ✅ **한 번의 정답**: 팀/레포 전체에서 **동일한 polyfill 전략**(usage 또는 entry)을 유지
- ✅ **Browserslist 최신화**: 정기적으로 `npx update-browserslist-db@latest`
- ✅ **변환 최소화**: 실제 타깃을 올려 빌드 성능/크기 최적화
- ✅ **소스맵**: 개발에서만 상세, 운영은 숨김/분리
- ✅ **런타임 헬퍼 공유**: 라이브러리/대형 앱은 transform-runtime 검토

---

## 끝으로 — 요약

- **Babel = 문법 변환기**, **Polyfill = 기능 보강**
- **preset-env + Browserslist**로 “필요한 만큼만” 변환/주입
- **core-js** + `useBuiltIns("usage"|"entry")`로 폴리필 전략 수립
- **transform-runtime**으로 헬퍼/레게너레이터 최적화
- 번들러와의 연계(Webpack/Vite/Rollup)까지 고려하면 **실전 배포 품질** 확보

---

## 부록 A) 단일 파일 예시 — ESNext 입력 → Babel 출력 비교

```js
// src/app.js (ESNext)
export class Counter {
  #n = 0;
  inc = () => ++this.#n;
  get value() { return this.#n; }
}

async function main() {
  const c = new Counter();
  c.inc();
  console.log(c.value?.toString() ?? "0");
  await new Promise(r => setTimeout(r, 10));
  console.log([1,2,3].includes(2));
}
main();
```

```js
// dist/app.js (개념적 ES5 출력 스니펫)
"use strict";

var _class, _descriptor, _temp;

var _privateField = new WeakMap();

var Counter = (_temp = _class = function Counter() {
  var _this = this;
  _privateField.set(this, { writable: true, value: 0 });
  this.inc = function () {
    var _ref = _privateField.get(_this);
    _ref.value = _ref.value + 1;
    return _ref.value;
  };
}, _temp);

function main() {
  return regeneratorRuntime.async(function main$(_context) {
    var c;
    while (1) switch (_context.prev = _context.next) {
      case 0:
        c = new Counter();
        c.inc();
        console.log((c.value != null ? c.value.toString() : void 0) || "0");
        _context.next = 5;
        return regeneratorRuntime.awrap(new Promise(function (r) { return setTimeout(r, 10); }));
      case 5:
        console.log([1,2,3].includes(2)); // 폴리필은 별도
      case 6:
      case "end":
        return _context.stop();
    }
  });
}
main();
```

> 실제 출력은 설정·버전에 따라 달라집니다. 위는 핵심 아이디어만 보여주는 축약 예시입니다.

---

## 부록 B) 실무 템플릿 (브라우저 앱, usage 전략)

`package.json`
```json
{
  "name": "babel-esnext-app",
  "private": true,
  "browserslist": [">0.5%", "not dead", "not op_mini all"],
  "scripts": {
    "build": "babel src -d dist --source-maps",
    "dev": "babel src -d dist -w --source-maps"
  },
  "devDependencies": {
    "@babel/cli": "^7.26.0",
    "@babel/core": "^7.26.0",
    "@babel/preset-env": "^7.26.0",
    "@babel/plugin-transform-runtime": "^7.26.0"
  },
  "dependencies": {
    "@babel/runtime": "^7.26.0",
    "core-js": "^3.36.0",
    "regenerator-runtime": "^0.14.1"
  }
}
```

`babel.config.json`
```json
{
  "presets": [
    ["@babel/preset-env", { "useBuiltIns": "usage", "corejs": "3.36" }]
  ],
  "plugins": [
    ["@babel/plugin-transform-runtime", { "helpers": true, "regenerator": true }]
  ]
}
```

`src/index.js`
```js
// 최신 문법 아무거나 사용해도 OK
const nums = [1, 2, 3];
console.log(nums.includes?.(2) ?? false);
```

---

## 참고

- 공식: https://babeljs.io
- REPL: https://babeljs.io/repl
- caniuse: https://caniuse.com
- core-js: https://github.com/zloirock/core-js

이 글을 기반으로 **팀 표준 Babel/Polyfill 가이드**를 만들어 두면, 브라우저 호환 이슈와 빌드 불일치 문제를 크게 줄일 수 있습니다. 필요하다면 **Node 타깃, 브라우저 타깃, 라이브러리 타깃** 각각에 대한 **3종 구성**을 템플릿화해 운영하세요.
