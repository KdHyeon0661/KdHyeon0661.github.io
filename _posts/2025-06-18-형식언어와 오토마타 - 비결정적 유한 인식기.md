---
layout: post
title: 형식언어와 오토마타 - 비결정적 유한 인식기
date: 2025-06-18 19:20:23 +0900
category: 형식언어와 오토마타
---
# 비결정적 유한 인식기 (NFA)

**비결정적 유한 인식기(NFA, Nondeterministic Finite Automaton)**는 결정적 유한 인식기(DFA)보다 일반화된 모델로, **하나의 입력 기호에 대해 여러 개의 가능한 상태 전이**를 허용합니다. 이로 인해 표현력이 유연하고, 일부 언어의 인식기 설계가 더 간단해지는 장점이 있습니다.

---

## 1. NFA의 정의

NFA는 다음의 5-튜플로 정의됩니다:

\\[
M = (Q, \Sigma, \delta, q_0, F)
\\]

- \\( Q \\): 유한한 상태 집합
- \\( \Sigma \\): 입력 알파벳
- \\( \delta: Q \times \Sigma \rightarrow \mathcal{P}(Q) \\): 전이 함수  
  → **하나의 상태에서 하나의 입력 기호로 여러 상태로 전이 가능**
- \\( q_0 \in Q \\): 시작 상태
- \\( F \subseteq Q \\): 종료 상태 집합

### DFA와의 차이점

| 특징 | DFA | NFA |
|------|-----|-----|
| 전이 함수 \\( \delta \\) | 단일 상태로 전이 | 다중 상태로 전이 (집합) |
| 비결정성 | 없음 | 있음 |
| ε-이동 | 불가 | 가능 (ε-NFA일 경우) |
| 인식 방식 | 유일한 경로 | 여러 경로 중 하나라도 수용되면 OK |

---

## 2. NFA의 동작 방식

입력 문자열이 주어졌을 때:

1. 여러 경로로 동시에 탐색 (비결정성)
2. 각 경로는 독립적으로 진행
3. **하나라도 종료 상태에 도달하면** 해당 문자열은 **수용(accept)**

이것은 마치 여러 명의 복제된 기계가 동시에 문자열을 읽고 있는 것처럼 생각할 수 있습니다.

---

## 3. NFA 사용 이유

### 3.1 표현 간결성

일부 정규 언어에 대해 DFA를 만들면 상태가 **폭발적으로 많아지지만**, NFA로는 매우 간단하게 표현 가능함.

예:
- `ab`를 포함하는 문자열
- 특정 패턴이 등장하는 정규식

### 3.2 정규 표현식과의 자연스러운 대응

- 정규표현식은 기본적으로 NFA와 유사한 방식으로 정의됩니다.
- 실제로 정규표현식 → NFA 변환은 매우 직관적이며 단순한 구조를 가집니다.

---

## 4. NFA 예제

다음 언어를 인식하는 NFA를 설계해보자.

> \\( L = \{ w \in \{a, b\}^* \mid w \text{에 } ab \text{가 포함됨} \} \\)

### 구성

- 상태 집합: \\( Q = \{q_0, q_1, q_2\} \\)
- 시작 상태: \\( q_0 \\)
- 종료 상태: \\( F = \{q_2\} \\)

전이 함수:

```text
δ(q0, a) = {q0, q1}
δ(q0, b) = {q0}
δ(q1, b) = {q2}
δ(q1, a) = ∅
δ(q2, a) = ∅
δ(q2, b) = ∅
```

### 전이 그래프 설명

- q0: 초기 상태, a 또는 b가 입력될 수 있음. a → q1 (ab 시퀀스 시작)
- q1: a 다음 상태. b가 들어오면 q2로 전이 (ab 완성)
- q2: 종료 상태. `ab`가 포함되었음을 의미

예:
- 입력: `babba`
  - q0 → q0 (b)
  - q0 → q1 (a)
  - q1 → q2 (b) → 수용

이처럼 입력 하나에 대해 여러 전이 가능하므로, NFA는 여러 상태를 "동시에" 추적한다고 볼 수 있습니다.

---

## 5. ε-NFA (Epsilon-NFA)

ε-NFA는 NFA의 확장으로, **입력 기호 없이도 상태 전이(ε-transition)**가 가능합니다.

- \\( \delta(q, \varepsilon) \\)에 의해 입력을 소비하지 않고 상태가 전이됨
- ε-transition을 통해 더 간단한 설계 가능
- NFA와 DFA로 변환할 때는 ε-transition을 먼저 제거한 후 처리

예:
- ε를 통해 중간 상태를 건너뛰거나 병렬 흐름을 연결

---

## 6. DFA와 NFA의 관계

### 정리

- 모든 NFA는 DFA로 변환할 수 있음 (단, 상태 수는 **지수적으로** 증가할 수 있음)
- DFA와 NFA는 **동일한 표현력**을 가짐 → **같은 정규 언어만 인식**
- 따라서 NFA ≡ DFA (인식 가능 언어 관점에서)

### NFA → DFA 변환 (Subset Construction)

1. DFA의 상태 = NFA 상태의 **부분집합들**
2. 시작 상태 = NFA 시작 상태에서 ε-closure
3. 전이 함수 = 각 부분집합에 대해 가능한 전이들을 집합으로 구성
4. 종료 상태 = NFA 종료 상태를 포함하는 DFA 상태

이 과정을 통해 NFA를 DFA로 **기계적으로** 변환할 수 있으며, NFA의 인식 언어는 정규 언어임이 보장됩니다.

---

## 7. 요약

| 항목 | 설명 |
|------|------|
| NFA 정의 | \\( (Q, \Sigma, \delta, q_0, F) \\), 다중 전이 허용 |
| 주요 특징 | 비결정성, ε-이동 가능, 병렬적 탐색 |
| 사용 이유 | 설계 단순화, 정규식 대응 용이 |
| DFA와의 관계 | NFA로 표현 가능한 언어는 모두 DFA로도 표현 가능 (정규 언어) |

---

## 결론

비결정적 유한 인식기는 **정규 언어 이론의 핵심 도구** 중 하나이며, 복잡한 언어를 간결하게 표현할 수 있는 강력한 수단입니다. DFA와 동등한 인식 능력을 가지면서도 **설계가 더 간단**한 경우가 많아, 실제 정규표현식 구현에도 NFA 개념이 사용됩니다.
