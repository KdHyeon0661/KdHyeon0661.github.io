---
layout: post
title: 형식언어와 오토마타 - 비결정적 유한 인식기
date: 2025-06-18 19:20:23 +0900
category: 형식언어와 오토마타
---
# 비결정적 유한 인식기(NFA) — 이론·설계·구현(실전 강화판)

**비결정적 유한 인식기(NFA, Nondeterministic Finite Automaton)**는 한 입력 기호에서 **여러 전이**를 허용하는 계산 모델이다.  
표현이 간결하고 정규식과 자연스럽게 맞물린다. 실행(판정) 단계에서는 **여러 경로 중 하나만 수용**이면 수용으로 본다.

> 핵심 사실: **NFA와 DFA는 표현력이 동등**하다(둘 다 정규 언어만 인식).  
> 차이는 “표현의 간결성 vs 실행의 효율”에 있다.

---

## 0. 표기(Notation)

- 알파벳: $$\Sigma$$ (유한 집합)
- 문자열: $$w\in\Sigma^\*$$, 길이 $$|w|$$, 공백 $$\varepsilon$$
- 언어: $$L\subseteq\Sigma^\*$$

---

## 1. NFA의 정의(엄밀)

> **정의.**  
> NFA는 5-튜플
> $$
> M=(Q,\Sigma,\delta,q_0,F)
> $$
> 로서,
> - $$Q$$: 유한 상태 집합
> - $$\Sigma$$: 입력 알파벳
> - $$\delta:Q\times\Sigma\to\mathcal P(Q)$$: 전이함수(집합 값 — 다중 전이)
> - $$q_0\in Q$$: 시작 상태
> - $$F\subseteq Q$$: 수용(종료) 상태 집합

### 1.1 확장 전이함수(문자열에 대한 정의)

> $$\hat\delta:Q\times\Sigma^\*\to\mathcal P(Q)$$ 를 다음으로 귀납 정의한다:
> $$
> \begin{aligned}
> \hat\delta(q,\varepsilon)&=\{q\},\\
> \hat\delta(q,xa)&=\bigcup_{p\in \hat\delta(q,x)} \delta(p,a)
> \quad (x\in\Sigma^\*,\, a\in\Sigma).
> \end{aligned}
> $$

### 1.2 수용(인식) 언어

문자열 $$w$$가 수용되는 조건:
$$
w\in L(M)\iff \hat\delta(q_0,w)\cap F\neq\emptyset.
$$
즉, *하나라도* 수용상태에 도달 가능한 경로가 있으면 수용.

---

## 2. DFA vs NFA — 무엇이 다른가(동작 관점)

| 항목 | DFA | NFA |
|---|---|---|
| 전이 | 단일 상태로 전이: $$\delta(q,a)=q'$$ | **상태 집합**으로 전이: $$\delta(q,a)\subseteq Q$$ |
| 경로 | 한 경로(결정적) | **여러 경로** 병렬 탐색(개념적) |
| 수용 | 유일 경로가 수용에 끝나면 | **하나라도** 수용 경로가 있으면 |
| ε-이동 | 없음 | ε-NFA에 한해 가능 |

**직관**: NFA는 “복제된 기계들이 동시에 달린다”로 생각하면 된다. 구현은 BFS/집합 갱신으로 **한 번에** 추적하면 된다.

---

## 3. 정규식 ↔ NFA: Thompson 조각(패턴 설계 템플릿)

정규식의 3대 연산(합·연접·Kleene ★)은 NFA로 아래처럼 구성된다(ε-NFA 관점):

- **합(OR) \(R|S\)**  
  새 시작에서 두 분기로 ε, 두 서브NFA 시작으로 분기 → 두 서브의 수용에서 새 수용으로 ε
- **연접(CONCAT) \(RS\)**  
  \(R\)의 수용에서 \(S\)의 시작으로 ε
- **별(STAR) \(R^\*\)**  
  새 시작=새 수용, 시작↔\(R\) 시작/수용 사이에 ε로 루프

> 이 패턴으로 “정규식 → ε-NFA”를 **자동화**할 수 있고, 이후 **ε-closure 포함 결정화**로 DFA를 얻는다.

---

## 4. 예제 설계(핵심 3종)

### 4.1 부분문자열 “ab”를 **포함**하는 모든 문자열
- $$\Sigma=\{a,b\}$$
- 아이디어: 어디서든 `a`를 보면 “`ab`의 a가 될 수도” 있다. 그 다음에 `b`가 오면 수용.

전이(간결 NFA):

```text
Q = {q0, q1, q2},  F = {q2}

δ(q0, a) = {q0, q1}
δ(q0, b) = {q0}
δ(q1, b) = {q2}
(그 외는 ∅)
```

작동 예: `babba`  
q0 -(b)-> q0, q0 -(a)-> {q0,q1}, {q0,q1} -(b)-> {q0,q2} → 수용.

### 4.2 접미사 “abb” 언어: \((a|b)^\*abb\)
- 어디서든 `a`가 나오면 “`abb` 후보의 첫 글자”가 될 수 있다.
- `abb`가 완성되면 수용 후 그대로 유지(흡수)해도 OK.

한 가지 NFA 구성(비ε):

```text
Q = {q0, q1, q2, q3},  F = {q3}
δ(q0, a) = {q0, q1}
δ(q0, b) = {q0}
δ(q1, b) = {q2}
δ(q2, b) = {q3}
```

### 4.3 패턴 결합: “ab 혹은 ba를 **어딘가** 포함”
ε 분기로 두 경로를 병렬 추적:

```text
Q = {s, x, y, f},  F = {f}
δ(s, ε) = {x, y}
# x: a* 뒤에 b가 보이면 f
δ(x, a) = {x}
δ(x, b) = {f}
# y: b* 뒤에 a가 보이면 f
δ(y, b) = {y}
δ(y, a) = {f}
# 수용 후 흡수
δ(f, a) = {f}, δ(f, b) = {f}
```

---

## 5. ε-NFA와 ε-closure

> **ε-closure**  
> $$
> \varepsilon\text{-closure}(q)=\{p\in Q\mid q \xRightarrow{\varepsilon^\*} p\},
> \quad
> \varepsilon\text{-closure}(S)=\bigcup_{q\in S}\varepsilon\text{-closure}(q).
> $$

성질: 자기포함, 단조성, 멱등성.  
의미: “입력을 **소비하지 않고** 갈 수 있는 곳을 한 번에 다 모아라”.

**왜 필요한가?**  
- ε-NFA를 **NFA/DFA로 전환**할 때 필수.  
- 결정화 시 전이 계산에 **반드시** ε-closure를 동반.

---

## 6. NFA → DFA: 부분집합 구성법(Determinization)

**아이디어**: “NFA의 **상태 집합**을 DFA의 한 상태로”.

- 시작: $$S_0=\varepsilon\text{-closure}(\{q_0\})$$
- 전이:
  $$
  \delta'(S,a)=\varepsilon\text{-closure}\Big(\bigcup_{q\in S}\delta(q,a)\Big)
  $$
- 수용: $$S\cap F\neq\emptyset$$ 인 모든 부분집합
- 결과 DFA는 **동치**: $$L(\text{NFA})=L(\text{DFA})$$

**증명 스케치(불변식)**  
모든 접두사 $$x$$에 대해 DFA가 도달한 부분집합은 **NFA가 \(x\)**를 읽고 도달 가능한 상태들의 ε-closure와 일치한다. 접두사 길이에 대한 귀납으로 보인다.

**주의**: 상태 수가 최악 O\((2^{|Q|})\)로 **폭증** 가능 → “도달 가능한 부분집합만 생성(BFS)”이 실전 필수.

---

## 7. 폐쇄성·설계 패턴·최적화

- **정규 언어 폐쇄성**: 합∪, 교∩, 차\, 여집합, 접두/접미/부분문자열 제약, 정규치환 등에서 닫힘  
  (곱구성, 완전화+여집합 등으로 기계적 구성 가능)
- **설계 패턴**:  
  - “부분문자열 포함”은 보통 NFA가 **압도적으로 간결**  
  - “정확한 모듈로 판정(예: 3으로 나눠떨어짐)”은 DFA가 간단
- **상태 폭발 대응**:  
  1) 도달 가능 집합만 생성(지연 결정화)  
  2) ε-closure 캐시, 집합을 비트마스크로  
  3) 결정화 후 **Hopcroft 최소화**로 상태 수 절감  
  4) 여집합/차집합을 쓸 땐 **완전 DFA**(sink)로

---

## 8. Python 레퍼런스 구현(실행 가능)

> 교육용으로 간결하게 작성. 실서비스는 입력 검증·비트셋 최적화·Hopcroft 최소화 등을 추가하세요.

### 8.1 NFA / ε-NFA 클래스와 시뮬레이터

```python
from collections import defaultdict, deque
from typing import Dict, Set, Tuple, Iterable, FrozenSet

State = str
Sym = str

class ENFA:
    """
    ε-NFA (ε 없는 순수 NFA도 이 클래스로 표현 가능; ε 전이를 쓰지 않으면 됨)
    delta[(q, a)] = {next states...},  a ∈ Σ ∪ {eps}
    """
    def __init__(self,
                 states: Iterable[State],
                 alphabet: Iterable[Sym],
                 delta: Dict[Tuple[State, Sym], Iterable[State]],
                 start: State,
                 accepts: Iterable[State],
                 eps: Sym = 'ε'):
        self.states: Set[State] = set(states)
        self.alphabet: Set[Sym] = set(alphabet)
        self.delta: Dict[Tuple[State, Sym], Set[State]] = defaultdict(set)
        for (q, a), dests in delta.items():
            self.delta[(q, a)].update(dests)
        self.start: State = start
        self.accepts: Set[State] = set(accepts)
        self.eps: Sym = eps

    # --- ε-closure & move ---

    def eclosure(self, S: Iterable[State]) -> FrozenSet[State]:
        """ε-closure for a set S"""
        stack = list(S)
        seen: Set[State] = set(S)
        while stack:
            q = stack.pop()
            for r in self.delta.get((q, self.eps), set()):
                if r not in seen:
                    seen.add(r); stack.append(r)
        return frozenset(seen)

    def move(self, S: Iterable[State], a: Sym) -> FrozenSet[State]:
        """NFA move without ε"""
        U: Set[State] = set()
        for q in S:
            U |= self.delta.get((q, a), set())
        return frozenset(U)

    # --- 인식기(run) ---

    def accepts_string(self, s: str) -> bool:
        """ε-closure를 포함한 집합 기반 시뮬레이션"""
        curr = self.eclosure({self.start})
        for ch in s:
            if ch not in self.alphabet:
                return False
            curr = self.eclosure(self.move(curr, ch))
            if not curr:
                return False
        return len(curr & self.accepts) > 0
```

### 8.2 ε-NFA → DFA(부분집합 구성) + 간단 러너

```python
def enfa_to_dfa(enfa: ENFA):
    """ε-closure를 내부에 포함하여 ENFA -> DFA 결정화(도달 상태만 생성). 불완전 DFA 허용."""
    Σ = enfa.alphabet
    S0 = enfa.eclosure({enfa.start})

    name_of: Dict[FrozenSet[State], str] = {S0: "S0"}
    rev_name: Dict[str, FrozenSet[State]] = {"S0": S0}
    next_id = 1

    def get_name(S: FrozenSet[State]) -> str:
        nonlocal next_id
        if S not in name_of:
            name = f"S{next_id}"; next_id += 1
            name_of[S] = name; rev_name[name] = S
        return name

    from collections import deque
    work = deque([S0])
    dfa_delta: Dict[Tuple[str, Sym], str] = {}
    dfa_states: Set[str] = {"S0"}
    dfa_accepts: Set[str] = set()
    if any(q in enfa.accepts for q in S0):
        dfa_accepts.add("S0")

    while work:
        T = work.popleft()
        Tn = name_of[T]
        for a in Σ:
            U = enfa.eclosure(enfa.move(T, a))
            if not U:
                continue  # 학습용으로 불완전 허용. 여집합 등을 쓰려면 sink 추가로 완전화.
            Un = get_name(U)
            dfa_delta[(Tn, a)] = Un
            if Un not in dfa_states:
                dfa_states.add(Un)
                work.append(U)
                if any(q in enfa.accepts for q in U):
                    dfa_accepts.add(Un)

    return {
        "states": dfa_states,
        "alphabet": set(Σ),
        "delta": dfa_delta,       # (q,a) -> q'
        "start": "S0",
        "accepts": dfa_accepts,
        "subset_map": {v: k for k, v in name_of.items()}  # DFA상태 -> 원래 부분집합
    }

def dfa_run(dfa, s: str) -> bool:
    q = dfa["start"]
    for ch in s:
        q = dfa["delta"].get((q, ch))
        if q is None:
            return False
    return q in dfa["accepts"]

def print_dfa(dfa):
    print("States :", sorted(dfa["states"]))
    print("Start  :", dfa["start"])
    print("Accept :", sorted(dfa["accepts"]))
    print("Delta  :")
    for (q,a), q2 in sorted(dfa["delta"].items()):
        print(f"  δ({q}, {a}) = {q2}")
```

### 8.3 예제 ① — 부분문자열 “ab” 포함 (NFA와 동작 테스트)

```python
# NFA for "contains 'ab'" over {a,b}
enfa_ab = ENFA(
    states={'q0','q1','q2'},
    alphabet={'a','b'},
    delta={
        ('q0','a'):{'q0','q1'},
        ('q0','b'):{'q0'},
        ('q1','b'):{'q2'},
        # ε 전이 없음
    },
    start='q0',
    accepts={'q2'}
)

tests = ["", "a", "b", "aa", "ba", "ab", "baba", "aaaaab", "bbb"]
print("=== NFA accepts? (contains 'ab') ===")
for t in tests:
    print(f"{t or 'ε':>6} -> {enfa_ab.accepts_string(t)}")

dfa_ab = enfa_to_dfa(enfa_ab)
print("\n=== Determinized DFA ===")
print_dfa(dfa_ab)

print("\nCross-check NFA vs DFA:")
for t in tests:
    print(f"{t or 'ε':>6} -> NFA:{enfa_ab.accepts_string(t)}  DFA:{dfa_run(dfa_ab, t)}")
```

**예상 결과**  
- `ab`, `baba`, `aaaaab` → True  
- `""`, `a`, `b`, `bbb` → False  
- NFA와 DFA 결과 일치.

### 8.4 예제 ② — “ab 또는 ba 포함”(ε-분기)

```python
enfa_ab_or_ba = ENFA(
    states={'s','x','y','f'},
    alphabet={'a','b'},
    delta={
        ('s','ε'):{'x','y'},

        ('x','a'):{'x'}, ('x','b'):{'f'},
        ('y','b'):{'y'}, ('y','a'):{'f'},

        ('f','a'):{'f'}, ('f','b'):{'f'},
    },
    start='s',
    accepts={'f'}
)

for t in ["", "a", "b", "aaab", "bbba", "abba", "bbbb", "aaaa", "aba", "baa"]:
    print(f"{t or 'ε':>6} -> {enfa_ab_or_ba.accepts_string(t)}")

dfa2 = enfa_to_dfa(enfa_ab_or_ba)
print("\n=== DFA (ab or ba somewhere) ===")
print_dfa(dfa2)
```

**예상 결과**  
- `aaab`, `bbba`, `abba`, `aba`, `baa` → True  
- `""`, `aaaa`, `bbbb` → False

### 8.5 예제 ③ — 접미사 “abb” (정규식 \((a|b)^\*abb\) 스타일)

```python
enfa_abb = ENFA(
    states={'q0','q1','q2','q3'},
    alphabet={'a','b'},
    delta={
        ('q0','a'):{'q0','q1'},
        ('q0','b'):{'q0'},
        ('q1','b'):{'q2'},
        ('q2','b'):{'q3'},
    },
    start='q0',
    accepts={'q3'}
)

for t in ["abb","aabb","ababb","aba","ab","babb","baba","bbb","aaab"]:
    print(f"{t:>6} -> {enfa_abb.accepts_string(t)}")

dfa3 = enfa_to_dfa(enfa_abb)
print("\n=== DFA for /(a|b)*abb/ ===")
print_dfa(dfa3)
```

---

## 9. 디버깅 포인트(실전에서 자주 틀리는 부분)

1) **ε-closure 누락**: 전이 후에 ε-closure를 **반드시** 취해야 한다(직접 결정화/런타임 시뮬레이션 모두).  
2) **불완전 DFA로 여집합/차집합 사용**: 여집합/차집합은 **완전 DFA**(sink 추가)로.  
3) **도달 불가 상태**: 결정화 후 시작집합에서 도달 불가한 DFA 상태는 제거.  
4) **상태 폭발**: 도달 가능한 부분집합만 생성하고, 필요시 Hopcroft 최소화 적용.  
5) **알파벳 불일치**: 입력에 알파벳 외 문자가 오면 즉시 거부.

---

## 10. 연습 문제(해설 힌트 제공)

1) **정규식 → ε-NFA**  
   정규식 `(a|bb)*ab`에 대해 Thompson 조각으로 ε-NFA를 설계하고, 본문 코드를 이용해 DFA로 변환하여 길이 ≤ 5의 모든 문자열을 테스트하라.  
   *힌트*: `bb`는 2스텝 연접, 최종 `ab`는 접미사 체인.

2) **곱구성으로 교집합 DFA 구성**  
   “`ab` 포함” ∧ “`aa` 미포함”을 각각 DFA로 만들고(결정화 + 완전화), 곱구성으로 교집합 DFA를 만든 뒤 테스트하라.

3) **여집합으로 부정 패턴**  
   “`ab` **미포함**” DFA를 4.1 예제의 DFA에서 **완전화 후 여집합**으로 얻어라. 몇 상태가 나오는가?

4) **ε-사이클 안정성**  
   ε-루프를 가진 작은 ε-NFA를 만들고 ε-closure 계산이 멱등적(한 번 수렴하면 반복해도 동일)임을 실험으로 확인하라.

---

## 결론

- **NFA**는 정규 언어 표현을 **간결**하게 만들고, 정규식 엔진의 내부 표현과도 자연스럽게 연결된다.  
- **DFA**는 실행이 빠르다. 따라서 **NFA로 설계 → DFA로 결정화(필요시 최소화)**가 표준 파이프라인이다.  
- ε-NFA의 핵심은 **ε-closure**이며, 결정화 시 필수 도구다.