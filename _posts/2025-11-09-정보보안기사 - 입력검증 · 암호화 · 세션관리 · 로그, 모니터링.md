---
layout: post
title: 정보보안기사 - 입력검증 · 암호화 · 세션관리 · 로그/모니터링
date: 2025-11-09 21:25:23 +0900
category: 정보보안기사
---
# 입력검증 · 암호화 · 세션관리 · 로그/모니터링

## 0) 전체 구조(한눈에 보기)

```
[Client] --TLS--> [API Gateway/WAF] --(스키마 1차 검증/RateLimit)--> [App]
                                                      |
                                                      v
                                           [입력검증(서버측) + 비즈니스 규칙]
                                                      |
                                                [세션/토큰 검증]
                                                      |
                                              [암호화(전송/저장/서명)]
                                                      |
                                                [DB/RLS, KMS/HSM]
                                                      |
                                       [구조화 로그 + 메트릭 + 트레이싱]
```

- **입력검증**: “형식/범위/길이/의미/상태” 5단계.  
- **암호화**: 전송(TLS1.2+), 저장(AES-GCM/ChaCha20-Poly1305), 키관리(KMS/HSM/회전).  
- **세션관리**: 쿠키(서버세션) vs JWT(무상태) — 수명·재발급·고정화 방지·CSRF.  
- **로그/모니터링**: 구조화(JSON)·PII 마스킹·TraceID·알람 규칙·대시보드·포렌식.

---

# 1) 입력검증(Input Validation)

### 1.1 원칙 (실무 7계명)
1) **서버측 검증이 진짜** — 클라이언트 검증은 UX일 뿐.  
2) **화이트리스트**(허용 규칙) 기반: 형식/범위/길이 제약.  
3) **컨텍스트 분리**: DB(SQL 바인딩), HTML/JS(출력 인코딩), OS(인자 분리).  
4) **정규화 후 검증**: 공백·케이스·Unicode(NFKC) 정규화.  
5) **스키마로 계약**: OpenAPI/JSON Schema/Pydantic.  
6) **리소스 한도**: 본문 크기·배열 크기·정규식 시간(ReDoS)·타임아웃.  
7) **오류 메시지의 최소화**: 내부 세부 정보 노출 금지.

### 1.2 JSON 스키마 검증 — Node(AJV)

```javascript
// npm i ajv ajv-formats
const Ajv = require('ajv');
const addFormats = require('ajv-formats');
const ajv = new Ajv({ allErrors: true, removeAdditional: 'failing' });
addFormats(ajv);

const schemaNewUser = {
  type: 'object',
  required: ['email','password','nickname'],
  additionalProperties: false,
  properties: {
    email: { type: 'string', format: 'email', maxLength: 254 },
    password: { type: 'string', minLength: 12, maxLength: 128 },
    nickname: { type: 'string', pattern: '^[a-zA-Z0-9._-]{3,24}$' }
  }
};

const validateNewUser = ajv.compile(schemaNewUser);

app.post('/users', (req, res) => {
  if (!validateNewUser(req.body)) {
    return res.status(400).json({ error: 'invalid_input', details: validateNewUser.errors });
  }
  // ...비즈니스 규칙 검증/생성
  res.status(201).json({ ok: true });
});
```

> **포인트**: `additionalProperties:false`로 **오염 필드 차단**, 길이·패턴·포맷 제한.

### 1.3 Python/FastAPI — 입력·출력 모델(Pydantic)

```python
from pydantic import BaseModel, Field, constr, conint

class Item(BaseModel):
    sku: constr(regex=r'^[A-Z0-9_-]{3,32}$')
    qty: conint(ge=1, le=100)

class NewOrder(BaseModel):
    items: list[Item] = Field(min_length=1)
    currency: constr(pattern=r'^(KRW|USD|EUR)$')

class Order(NewOrder):
    id: str
    owner: str
    total: conint(ge=0)

@app.post("/orders", response_model=Order, status_code=201)
def create_order(order: NewOrder, user=Depends(require_jwt)):
    # 서버측 가격 재계산: 클라 값 신뢰 금지
    total = recalc_total(order.items)
    return Order(**order.dict(), id=uuid4().hex, owner=user["sub"], total=total)
```

### 1.4 파일 업로드(타입/크기/경로)

```java
// Spring: Path Traversal 방지 + Magic Number 검사(개요)
@GetMapping("/download")
public ResponseEntity<Resource> download(@RequestParam("name") String name) throws IOException {
  Path base = Paths.get("/var/app/files").toAbsolutePath().normalize();
  Path cand = base.resolve(name).normalize();
  if(!cand.startsWith(base)) return ResponseEntity.badRequest().build(); // ../ 차단
  // Mime sniffing 금지 + Content-Disposition
  var res = new FileSystemResource(cand.toFile());
  return ResponseEntity.ok()
    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + res.getFilename() + "\"")
    .header(HttpHeaders.X_CONTENT_TYPE_OPTIONS, "nosniff")
    .body(res);
}
```

### 1.5 정규식 DoS(ReDoS) 회피

```python
import re
# ❌ (a+)+, (.*)+ 같은 백트래킹 폭발 패턴 금지
SAFE = re.compile(r"^[a-z0-9_-]{3,32}$")  # 앵커·수량자 명확
```

### 1.6 DB/OS/Template 컨텍스트별 안전 패턴

- **DB**: **프리페어드 스테이트먼트/ORM 바인딩**  
- **OS**: `shell=False`, 인자 배열 분리
```python
subprocess.run(["/usr/bin/convert", "--", input_path, output_path], check=True)
```
- **Template**: 사용자 문자열은 **변수로만** 주입(템플릿 자체 평가 금지)

### 1.7 Unicode 정규화(NFKC) 후 비교

```python
import unicodedata
def norm(s: str) -> str:
    return unicodedata.normalize('NFKC', s).strip().lower()
```

---

# 2) 암호화(Cryptography)

### 2.1 전송 중(Transport)
- **TLS 1.2+ / 1.3**: 강한 스위트(AES-GCM/ChaCha20-Poly1305), HSTS, OCSP Stapling.  
- 프록시/게이트웨이에서 **TLS 종료** + 내부는 **mTLS**(서비스 간).

### 2.2 저장 시(At Rest) — **AES-GCM** 예제

```python
# pip install cryptography
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os

key = AESGCM.generate_key(bit_length=256)  # KMS/HSM에서 공급받는 것을 권장
aes = AESGCM(key)
nonce = os.urandom(12)                     # GCM: 12바이트 권장, **중복 금지**
aad   = b"order:v1"                        # 컨텍스트(버전/스킴)
ct    = aes.encrypt(nonce, b"secret-data", aad)
pt    = aes.decrypt(nonce, ct, aad)
```

> **주의**: 같은 키에서 **nonce 재사용 금지**. 키는 **KMS/HSM**으로 보호하고 **회전**.

### 2.3 봉투(Envelope) 암호화 개념

1) 데이터 키(DEK)로 AES-GCM 암호화 → 2) DEK를 KMS의 마스터키(CMK)로 암호화 → 3) 암호문+암호화된 DEK 함께 저장 → 4) 복호화 시 KMS로 DEK 복호.

### 2.4 비밀번호는 “암호화”가 아니라 **해시(Argon2/bcrypt)**

```python
from argon2 import PasswordHasher
ph = PasswordHasher()           # 메모리/시간 파라미터 기본 안전
hash_ = ph.hash("P@ssw0rd-very-long")   # 저장
ph.verify(hash_, "P@ssw0rd-very-long")  # 검증
```

- **정책**: 길이 ≥ 12, 사전어 금지, 누출 체크(hibp API 대체 내부사전).  
- **엔트로피 근사**:  
  $$
  H \approx L \cdot \log_2 |\Sigma|
  $$

### 2.5 서명/토큰 — JWT 검증(iss/aud/exp/alg/kid)

```javascript
// npm i jsonwebtoken jwks-rsa
const jwt = require('jsonwebtoken');
const jwksRsa = require('jwks-rsa');
const client = jwksRsa({ jwksUri: 'https://idp.example.com/.well-known/jwks.json', cache: true });

function getKey(header, cb){ client.getSigningKey(header.kid, (e, k)=> cb(e, k?.getPublicKey())); }

function requireJWT(aud){
  return (req,res,next)=>{
    const t = (req.headers.authorization || '').replace(/^Bearer /,'');
    jwt.verify(t, getKey, { algorithms:['RS256','ES256'], issuer:'https://idp.example.com', audience:aud },
      (err, dec) => err ? res.sendStatus(401) : (req.user=dec, next()));
  };
}
```

### 2.6 키 파생/관리
- **HKDF**로 파생, **PBKDF2/Argon2**로 패스워드 기반 키.  
- 키/시크릿은 **소스 저장 금지**, **환경변수+비밀관리**(Vault/Parameter Store).

```python
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
import os
ikm = os.urandom(32)
hkdf = HKDF(algorithm=hashes.SHA256(), length=32, salt=None, info=b'orders:v1')
key = hkdf.derive(ikm)
```

### 2.7 무결성 비교(상수시간)

```python
import hmac
def safe_eq(a: bytes, b: bytes) -> bool:
    return hmac.compare_digest(a, b)
```

---

# 3) 세션관리(Session Management)

### 3.1 쿠키 기반(서버 세션) — **재발급/고정화 방지/CSRF**

```javascript
// npm i express express-session connect-redis ioredis helmet csurf
const session = require('express-session');
const RedisStore = require('connect-redis').default;
const Redis = require('ioredis');
const redisClient = new Redis(process.env.REDIS_URL);

app.use(helmet());
app.set('trust proxy', 1); // 프록시 뒤에 있으면 필요
app.use(session({
  store: new RedisStore({ client: redisClient }),
  name: 'sid',
  secret: process.env.SESSION_SECRET,
  resave: false, saveUninitialized: false,
  cookie: { httpOnly: true, secure: true, sameSite: 'lax', maxAge: 1000*60*30 } // 30분
}));

// 로그인 성공 시: 세션 고정화 방지 — ID 재발급
app.post('/login', (req,res,next)=>{
  // 자격 검증 성공 후
  req.session.regenerate(err=>{
    if (err) return next(err);
    req.session.user = { id: user.id, roles: user.roles };
    res.json({ ok: true });
  });
});
```

- **원칙**: `Secure; HttpOnly; SameSite=Lax|Strict`, 로그인/권한변경 시 **세션 ID 재발급**, **서버 저장소(메모리 금지)**, 로그아웃은 **세션 파기**.  
- **CSRF**: 폼/쿠키는 `csurf` 토큰으로 보호, API는 **Bearer 토큰** 권장.

### 3.2 무상태(JWT) — **짧은 수명 + Refresh 회전**

- Access는 5–15분, Refresh는 **1회용 회전**(reuse 감지 시 전체 무효화).  
- **서버에서도 꼭 검증**(게이트웨이에만 의존 금지).  
- **블랙리스트/허용리스트**: 고위험 환경은 서버 저장(세션화) 고려.

```javascript
// Refresh 회전 스케치
async function refresh(oldRefresh){
  const claims = verifyRefresh(oldRefresh);      // iss/aud/exp/nbf 검증
  if (await isUsed(oldRefresh)) throw new Error('reused');
  await markUsed(oldRefresh);                    // 1회용 처리
  return issueNewPair(claims.sub, claims.scope); // 새 access/refresh
}
```

### 3.3 동시 세션/디바이스 관리
- 최근 N개만 허용, 나머지 **서버측 무효화**(세션 저장/토큰 리스트).  
- **위치/UA 급변** 시 재인증(위험 기반 접근).

### 3.4 로그아웃/탈취 대응
- 서버 세션: `destroy()` + 쿠키 즉시 만료.  
- JWT: 서버측 **토큰 상태 저장**이 있는 경우 “해지 목록”에 추가, 없으면 **짧은 수명 + 회전**을 기본.

---

# 4) 로그/모니터링(Logging & Monitoring)

### 4.1 원칙
- **구조화(JSON)**, **시간 동기화(NTP)**, **Trace/Span ID**(분산 트레이싱), **PII/시크릿 마스킹**.  
- **감사 이벤트**(로그인/권한 변경/비밀번호 변경/결제/데이터 접근)는 **분리 보존**(WORM/불변 스토리지).  
- **보안 알람**: 401/403/5xx 급증, 429(레이트리밋) 지속, 관리자 경로 접근, 토큰 재사용 시도.

### 4.2 Node — pino 로거 + 마스킹

```javascript
// npm i pino pino-http
const pino = require('pino')({ level: process.env.LOG_LEVEL || 'info' });
const httpLogger = require('pino-http')({
  redact: { paths: ['req.headers.authorization', 'req.body.password', 'res.body.token'], censor: '[REDACTED]' }
});
app.use(httpLogger);

// 비즈니스 로그
app.post('/orders', (req,res)=>{
  req.log.info({ actor:req.user?.sub, action:'order.create', count:req.body.items?.length }, 'order create');
  // ...
  res.status(201).json({ id: '...' });
});
```

### 4.3 Python — structlog + TraceID

```python
# pip install structlog
import structlog, uuid
structlog.configure(processors=[structlog.processors.JSONRenderer()])
log = structlog.get_logger()

def with_trace(handler):
    def _inner(req):
        trace = req.headers.get('x-trace', str(uuid.uuid4()))
        return handler(req, log=log.bind(trace=trace))
    return _inner
```

### 4.4 NGINX — 접근 로그(JSON) + HSTS

```nginx
log_format json escape=json '{ "ts":"$time_iso8601","remote":"$remote_addr","host":"$host",'
                           '"method":"$request_method","uri":"$request_uri","status":$status,'
                           '"bytes":$bytes_sent,"rt":"$request_time","ua":"$http_user_agent"}';
access_log /var/log/nginx/access.json json;

add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
```

### 4.5 OpenTelemetry(개요)
- 앱/프록시/DB에 **TraceID 전파** → 느린 호출/에러 경로 가시화.  
- **보안 관점**: 오류/권한거부 위치를 **트레이스**로 확인, 재시도/루프 탐지.

### 4.6 메트릭/알람 예시
- **로그인 실패율** > 5분 평균 5% 초과 → 알람  
- **HTTP 5xx 비율** > 2% 지속 10분 → 알람  
- **레이트리밋(429)** > 특정 사용자 1분에 30회 → 알람  
- **관리자 경로 접근** (비관리자) 발생 시 즉시 알람

---

# 5) 종단 간 시나리오 & 런북

## 5.1 “주문 생성 API 폭주(봇)” 상황

**징후**
- `/orders` 429 급증, 특정 `user:bot-123`에서 1분 500회.

**즉시 조치**
1) 게이트웨이에서 **사용자/경로 기반 레이트리밋 강화**(10 r/m).  
2) 해당 사용자 **임시 차단**(IP/ClientID).  
3) 응답에 `Retry-After` 제공, 합법 트래픽 우선.

**근본 원인**
- 클라이언트 SDK 리트라이 버그 → 지수 백오프 미구현.

**재발 방지**
- **Idempotency-Key** 의무화, SDK에 **지수백오프**/재시도 한도.

```javascript
// Idempotency Cache(개요)
const cacheKey = `idem:${req.get('Idempotency-Key')}`;
```

---

## 5.2 “세션 탈취 의심(동시 타 지역 로그인)”

**징후**
- 동일 계정의 **IP/지리 급변**, 단시간 **여러 디바이스** 로그인.

**즉시 조치**
1) 해당 계정 **전체 세션 무효화**(서버세션은 저장소에서 일괄 삭제 / JWT는 블랙리스트).  
2) **MFA 재검증** 요구.  
3) 최근 **Refresh 재사용** 이벤트 조사(회전 실패 탐지).

**근본 원인**
- **HTTPOnly 미적용** 또는 피싱/악성코드.

**재발 방지**
- `Secure; HttpOnly; SameSite`, **기기 지문/위험 기반** 재인증, 피싱 훈련/경고.

---

## 5.3 “입력검증 누락으로 500 폭주”

**징후**
- `400` 대신 `500` 급증, 스택에 `KeyError/TypeError`.

**즉시 조치**
1) 컨트롤러 앞단에 **스키마 검증 미들웨어** 강제.  
2) 모든 예외를 **표준 오류 응답**으로 매핑(내부 스택 숨김).

**재발 방지**
- OpenAPI 린트/계약 테스트 도입, PR 게이트(Semgrep)로 **스키마 없는 엔드포인트** 차단.

---

# 6) 보안 체크리스트(운영·개발 공통)

### 입력검증
- [ ] **서버측 스키마**(입력/출력) 강제, `additionalProperties:false`  
- [ ] 길이/범위/패턴/포맷/배열 크기 제한  
- [ ] 파일: **크기/확장자/시그니처** 검사, 저장소 격리, 경로 정규화  
- [ ] 정규식: 안전 패턴만, 타임아웃/길이 제한

### 암호화
- [ ] TLS 1.2+/1.3, HSTS, 안전 스위트  
- [ ] 저장: AES-GCM/ChaCha20-Poly1305, **nonce 재사용 금지**  
- [ ] 키관리: KMS/HSM, **회전 정책**, 시크릿 스캔(레포 금지)  
- [ ] 비밀번호: Argon2/bcrypt, 누출 사전 검사

### 세션관리
- [ ] 쿠키: `Secure; HttpOnly; SameSite`  
- [ ] 로그인/권한변경 시 **세션 재발급**, 로그아웃 파기  
- [ ] JWT: 짧은 수명, **Refresh 회전**, `iss/aud/exp/nbf/alg/kid` 검증  
- [ ] CSRF: 폼 토큰 또는 쿠키 미사용 API(토큰 기반)

### 로그/모니터링
- [ ] 구조화(JSON)·TraceID·레벨 일관성  
- [ ] PII/시크릿 마스킹, WORM/감사 로그 분리  
- [ ] 401/403/5xx/429/관리자 접근 알람  
- [ ] 대시보드: 오류율/지연/Throughput/레이트리밋/로그인 실패율

---

# 7) 미니 연습문제(정답·해설)

1) **문**: 아래 JSON 스키마 검증에서 놓친 위험은?  
```json
{ "type":"object", "properties": { "email":{"type":"string"} } }
```  
**정답**: `required`와 `format: email`, 길이 제한, `additionalProperties:false` 누락 → 오염 필드 허용.

2) **문**: AES-GCM에서 **같은 키+nonce**로 두 메시지를 암호화하면 왜 위험한가?  
**정답**: GCM은 스트림 유사 구조로 **키스트림 재사용** → 평문 관계 노출 및 태그 위조 위험.

3) **문**: 세션 고정화 방지를 위해 로그인 시 해야 할 조치 2가지는?  
**정답**: 세션 ID **재발급**, 이전 세션 **무효화**.

4) **문**: 로그에서 어떤 필드는 반드시 마스킹해야 하는가? 3가지 이상.  
**정답**: 비밀번호/토큰/세션ID/카드 PAN/주민번호(PII) 등.

5) **문**: 로그인 실패율이 10분 동안 7%를 넘을 때 알람을 울리는 이유는?  
**정답**: 크리덴셜 스터핑/브루트포스 징후 → 레이트리밋/캡차/락아웃 필요.

---

# 8) 부록 — 코드 스니펫 모음

### 8.1 Express 오류 응답 표준화(내부 정보 숨김)

```javascript
app.use((err, req, res, next) => {
  req.log?.error({ err }, 'unhandled');
  const status = err.status || 500;
  res.status(status).json({ error: status === 500 ? 'internal_error' : err.code || 'bad_request' });
});
```

### 8.2 CSRF — API는 Bearer, 폼은 토큰

```javascript
// API 라우트는 Authorization 헤더로 보호(쿠키 세션 미사용 권장),
// 폼 라우트는 csurf 미들웨어로 토큰 검증
```

### 8.3 OpenAPI 린트(계약 검증)

```bash
npx @redocly/cli lint openapi.yaml
```

---

## 마무리

- **입력검증**이 **첫 방어선**, **암호화**가 **비밀/무결**을 보장, **세션관리**가 **신원/상태**를 안전하게 유지, **로그/모니터링**이 **증거·탐지**를 보장합니다.  
- 오늘 바로 적용할 4가지:  
  1) 모든 신규 엔드포인트에 **스키마 검증 미들웨어** 필수화  
  2) **AES-GCM** 표준화 + **KMS 키회전** 계획 확정  
  3) **세션 재발급/CSRF** 체계 점검 & JWT **Refresh 회전** 도입  
  4) **구조화 로그 + 알람 규칙**(401/403/429/5xx) 배포  