---
layout: post
title: 객체지향설계 - 클래스 도출 및 역할 분석
date: 2025-07-20 21:20:23 +0900
category: 객체지향설계
---
# 클래스 도출 및 역할 분석

클래스 도출 및 역할 분석은 요구사항을 현실적인 도메인 모델로 옮기는 핵심 활동입니다.  
아래는 **실무에서 바로 쓸 수 있는 단계별 방법**, **기법**, **판단 기준**, **예제(CRC + 코드 스켈레톤)**, **검증 체크리스트**를 포함한 상세 가이드입니다.

---

## 1. 목표 요약 — 왜 중요한가?
- 요구사항(무엇)을 **구조(누가/무엇이/어떻게)**로 바꾼다.  
- 각 클래스는 **명확한 책임(역할)**을 갖고 협력하여 시스템 행위를 실현해야 한다.  
- 잘 도출된 클래스는 유지보수·테스트·확장에 유리하다.

---

## 2. 단계별 프로세스 (8단계)

### 1) 입력 자료 수집
- 유스케이스, 사용자 스토리, SRS, 비기능 요구, 화면/API 명세, 도메인 용어집 등.

### 2) 텍스트 분석: **명사/동사(Noun-Verb) 기법**
- 요구사항 문서에서 **명사 → 후보 클래스/속성**, **동사 → 후보 책임(메서드)**로 추출.
- 예: "사용자는 상품을 장바구니에 추가할 수 있다."  
  - 명사: 사용자(User), 상품(Product), 장바구니(Cart)  
  - 동사: 추가(add) → `Cart.addItem(Product)`

### 3) 도메인 분류: 엔터티 vs 값 객체 vs 서비스
- **Entity(엔터티)**: 식별자(ID)를 가지며 생명주기 추적 필요 (예: Account, Order).  
- **Value Object(값 객체)**: 식별성이 없고 불변(예: Money, Address).  
- **Domain Service**: 단일 개체의 책임으로 들어맞지 않는 도메인 규칙(예: 환율 계산).  
- **Repository / DAO**: 지속성(저장/조회) 책임.  
- **Application Service / Controller**: 워크플로우·트랜잭션 조정.

### 4) 책임(ROLE) 할당 — CRC 카드
- **CRC (Class-Responsibility-Collaborator)** 카드로 각 후보 클래스의 책임과 협력자 정의.
- 책임은 **작고 구체적으로**—한 클래스가 많은 책임을 가지면 SRP 위반.

### 5) 관계와 제약 정의
- Association, Aggregation, Composition, Inheritance 결정  
- Multiplicity(1..*, 0..1 등), 방향성(navigability), 연관 강도(약한 의존/강한 포함) 기술

### 6) 속성/메서드 확정
- 각 클래스에 필요한 **속성(attributes)** 과 **행위(operations)** 정의  
- 공개 인터페이스(공개 메서드)와 내부 구현(private method/field) 구분

### 7) 정제·리팩토링(Heuristics 적용)
- 응집도/결합도 검사, SRP/LSP/ISP 위반 여부 점검  
- 과도한 상속 대신 합성(Composition) 권장
- 안티패턴(예: God Object, Data Class) 식별 및 분해

### 8) 시각화·검증
- UML 클래스 다이어그램 작성 → 이해관계자 리뷰 → 시나리오(시퀀스 다이어그램)로 행동 검증  
- 요구사항 ↔ 클래스 매핑(Traceability) 확보

---

## 3. 구체적 기법 & 체크리스트

### 명사/동사 분석 팁
- **명사 중 추상적·중복 표현** 정리 (예: “계정” vs “사용자 계정” 통합)  
- UI/화면 용어는 도메인 개념인지 단순 뷰인지 구분

### CRC 카드 템플릿 (한 장 예)
```
Class: BankAccount
Responsibility:
 - 잔액 유지/관리
 - 입금/출금/이체(원자적 처리)
 - 상태 검증(음수 방지)
Collaborators:
 - TransactionRepository
 - NotificationService
```

### 클래스 품질 체크 (간단)
- **SRP**: 하나의 책임?  
- **응집도**: 내부 멤버들이 같은 목적을 가지나?  
- **결합도**: 의존이 인터페이스/추상에 있는가?  
- **테스트성**: 단위 테스트가 쉬운가?  
- **명명**: 클래스 이름이 역할을 명확히 설명하는가?

---

## 4. 설계 결정: 상속 vs 합성, 엔터티 경계

### 상속을 고려할 때
- `is-a` 관계가 명확할 때만 사용 (`Square is-a Rectangle` 논쟁에 주의)  
- LSP(리스코프 치환 원칙)를 준수할 수 있어야 함

### 합성(Composition) 권장
- 역할을 조합해서 만들 수 있으면 합성을 우선 (유연성↑)  
- 예: `Order`가 `PaymentMethod`를 보유

### Aggregate / Bounded Context (DDD 관점)
- 도메인에서는 **Aggregate Root**를 정해 일관성 경계를 둠  
- 예: `Order` 루트 → `OrderLine`은 루트 내부에서만 변경

---

## 5. 클래스 설계 예제 (은행 계좌 — 도출 → 역할분석 → 스켈레톤)

### 1) 요구사항(요약)
- 사용자는 계좌 잔액 조회, 입금, 출금, 이체 가능  
- 출금은 잔액 부족 시 실패, 동시성 보장

### 2) 후보 클래스 도출 (명사/동사)
- `User`, `BankAccount`, `Transaction`, `TransactionRepository`, `AccountService`, `NotificationService`, `Money`(값 객체)

### 3) CRC 카드 (BankAccount)
```
Class: BankAccount
Responsibility:
 - 잔액 보관(balance)
 - 입금(deposit)/출금(withdraw) 처리 및 검증
 - 당좌(Overdraft) 정책 적용(선택)
Collaborators:
 - TransactionRepository (영속화)
 - NotificationService (잔액 알림)
```

### 4) Java 스켈레톤

```java
public final class Money {
    private final long amount; // cents
    private final String currency;
    // 생성자, equals/hashCode, add/subtract
}

public class BankAccount {
    private final String accountId;
    private Money balance;

    public BankAccount(String id, Money initialBalance) { ... }

    public synchronized void deposit(Money amount) {
        // 유효성 검사
        this.balance = this.balance.add(amount);
        // TransactionRepository.save(...)
    }

    public synchronized void withdraw(Money amount) {
        if (balance.compareTo(amount) < 0)
            throw new InsufficientFundsException();
        this.balance = this.balance.subtract(amount);
        // TransactionRepository.save(...)
    }

    public Money getBalance() { return balance; }
}
```

`AccountService`는 트랜잭션 단위(동시성, 분산 트랜잭션)를 조정:

```java
public class AccountService {
    private final TransactionRepository repo;
    private final NotificationService notifier;

    public void transfer(String fromId, String toId, Money amount) {
        // 트랜잭션 경계, 락 또는 DB 트랜잭션 이용
    }
}
```

---

## 6. 안티패턴과 개선 방법

### God Object (모든 책임을 한 클래스가 함)
- **증상**: 클래스가 너무 크고 많은 책임을 가짐  
- **해결**: 책임 분리(Extract Class), 서비스/리포지토리 이동

### Feature Envy (다른 객체의 데이터/행위를 과도히 사용)
- **증상**: 메서드가 자기 클래스보다 다른 클래스 필드에 더 많이 접근  
- **해결**: 메서드 이동(Move Method) 또는 역할 재분배

### Data Class (행위 없이 데이터만 노출)
- **증상**: getter/setter만 가득 → 캡슐화 깨짐  
- **해결**: 행위를 객체 내부로 이동, 불변 객체 설계

---

## 7. 검증(Validation) & 리뷰 프로세스
- **요구 ↔ 클래스 매핑**: 모든 요구는 하나 이상의 클래스/메서드로 추적 가능해야 함 (RTM)  
- **시나리오 테스트**: 유스케이스를 시퀀스 다이어그램으로 따라가면서 클래스 협력 검증  
- **코드 리뷰 & 도메인 전문가 리뷰**: 네이밍·경계·비즈니스 규칙 확인  
- **단위 테스트**: 각 클래스의 책임을 검증하는 단위 테스트 작성

---

## 8. 실무 팁 (빠른 의사결정 기준)
- 클래스 이름은 **명사**로, 동작은 **동사**로 표현  
- **작게 시작**하되 리팩토링으로 합치거나 쪼갤 수 있게 설계  
- 테스트가 어렵다면 책임이 분리되지 않은 신호  
- 인터페이스를 먼저 정의하고 구현을 나중에 작성하면 결합도 감소  
- 도메인 로직은 도메인 객체에, 인프라 로직은 서비스/리포지토리에 둔다

---

## 9. 요약 체크리스트 (도출 완료 시)
- [ ] 각 요구는 하나 이상의 클래스/메서드로 추적 가능한가?  
- [ ] 클래스는 하나의 책임(SRP)을 가졌는가?  
- [ ] 엔터티/값객체/서비스/리포지토리 역할이 명확한가?  
- [ ] 응집도는 높은가, 결합도는 낮은가?  
- [ ] 상속 대신 합성이 더 적합하지 않은가?  
- [ ] 테스트와 검증(유스케이스, 시퀀스)이 가능한가?