---
layout: post
title: DB 심화 - 고급 조인 테크닉 (1)
date: 2025-11-15 14:25:23 +0900
category: DB 심화
---
# 고급 조인 테크닉 1

## 0) 실습 공통 세팅

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;  -- DBMS_XPLAN ALLSTATS LAST 사용
```

---

# 1. 누적 매출(러닝 토털) 구하기 — “조인형”과 “윈도 함수형” 비교

### 1.1 스키마 & 샘플
```sql
DROP TABLE SALES PURGE;
CREATE TABLE SALES(
  SALES_DT  DATE        NOT NULL,
  CUST_ID   NUMBER      NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL,
  CONSTRAINT PK_SALES PRIMARY KEY (SALES_DT, CUST_ID)
);

BEGIN
  FOR d IN 0..14 LOOP
    INSERT INTO SALES SELECT DATE '2024-06-01'+d, c, ROUND(DBMS_RANDOM.VALUE(10,200),2)
    FROM (SELECT LEVEL c FROM dual CONNECT BY LEVEL <= 5);
  END LOOP;
  COMMIT;
END;
/
BEGIN DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES'); END;
/
```

### 1.2 윈도 함수(권장) — 인덱스/정렬로 매우 빠름
```sql
SELECT sales_dt
     , SUM(amount) AS day_amt
     , SUM(SUM(amount)) OVER (ORDER BY sales_dt
                              ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS run_total
FROM   SALES
GROUP  BY sales_dt
ORDER  BY sales_dt;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +IOSTATS'));
```

**포인트**
- **하루 합계**를 먼저 GROUP BY로 줄인 뒤 그 결과에 **윈도 SUM**을 적용 → **읽기량 최소화**.  
- `SALES(SALES_DT, CUST_ID)` PK가 있어 **날짜 정렬 비용 낮음**.  
- OLTP + 화면 집계라면 이 방식이 대부분 최선입니다.

### 1.3 “조인형 러닝 토털” — **자기조인**으로 Dates≤Current 일자 묶기
```sql
-- 같은 날짜 이하를 묶는 반대편 집합과 조인(전형적인 누적 자기조인)
SELECT s1.sales_dt
     , SUM(s1.amount)                          AS day_amt
     , SUM(s2.amount)                          AS run_total
FROM   SALES s1
JOIN   SALES s2
  ON   s2.sales_dt <= s1.sales_dt
GROUP  BY s1.sales_dt
ORDER  BY s1.sales_dt;
```
**장단점**
- “조인만으로 표현해야 한다”는 제약이 있을 때 사용.  
- **O(N²) 위험**(날짜 수가 크면 폭증). 실무에서 권장하지 않습니다.

### 1.4 (옵션) 월 누적 — 기간 키와 조인
```sql
WITH D AS (
  SELECT TRUNC(sales_dt,'MM') AS mon, sales_dt, SUM(amount) day_amt
  FROM   SALES
  GROUP  BY TRUNC(sales_dt,'MM'), sales_dt
), M AS (
  SELECT mon, SUM(day_amt) AS mday_amt
  FROM   D GROUP BY mon, sales_dt
)
SELECT mon
     , SUM(mday_amt) AS month_total
     , SUM(SUM(mday_amt)) OVER (ORDER BY mon) AS run_total_mon
FROM   M
GROUP  BY mon
ORDER  BY mon;
```

**튜닝 포인트**
- 누적은 **윈도 SUM**이 **정답**. 조인형은 학술/면접용 예시로만 기억.  
- 필요한 경우 **월 파티션 인덱스**(컴포지트 인덱스: `(TRUNC(sales_dt,'MM'), sales_dt)` 등)로 프루닝.

---

# 2. 선분이력 끊기(변경 구간 분절) — 유효기간 조인 + 경계 합치기

> “가격/등급/담당자 같은 **속성이 날짜 구간**으로 관리될 때, **변경 이벤트 시점**에 선분을 잘라 **구간별 이력**을 만들어야 합니다.”

### 2.1 스키마 & 샘플
```sql
DROP TABLE PRICE_EVENT PURGE;
CREATE TABLE PRICE_EVENT(
  PROD_ID   NUMBER      NOT NULL,
  EVT_DT    DATE        NOT NULL,  -- 변경 발생일(시작 경계)
  NEW_PRICE NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_PRICE_EVENT PRIMARY KEY (PROD_ID, EVT_DT)
);

-- 이벤트: 같은 상품이 여러 날에 가격 변경
INSERT INTO PRICE_EVENT VALUES (100, DATE '2024-01-01', 100);
INSERT INTO PRICE_EVENT VALUES (100, DATE '2024-01-10', 120);
INSERT INTO PRICE_EVENT VALUES (100, DATE '2024-01-25', 110);
INSERT INTO PRICE_EVENT VALUES (100, DATE '2024-02-05', 130);
COMMIT;

BEGIN DBMS_STATS.GATHER_TABLE_STATS(USER,'PRICE_EVENT'); END;
/
```

### 2.2 **LEAD**로 구간 끝 계산 → 구간 테이블 만들기
```sql
-- 선분이력(시작~끝) 산출
WITH E AS (
  SELECT prod_id
       , evt_dt                             AS start_dt
       , LEAD(evt_dt,1,DATE '9999-12-31') 
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt
       , new_price
  FROM   PRICE_EVENT
)
SELECT * FROM E ORDER BY prod_id, start_dt;
```

### 2.3 “날짜별 매출”과 **기간 조인** (선분-포인트 매칭)
```sql
DROP TABLE SALES_D PURGE;
CREATE TABLE SALES_D(
  SALES_DT DATE NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  QTY      NUMBER NOT NULL
);
-- 1월 1~31, 2월 1~10 동안 불규칙 매출 발생
BEGIN
  FOR d IN 0..40 LOOP
    INSERT INTO SALES_D VALUES (DATE '2024-01-01'+d, 100, 1 + MOD(d,3));
  END LOOP;
  COMMIT;
END;
/
BEGIN DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES_D'); END;
/

-- 기간 조인: 판매일이 속한 구간의 가격 붙이기
WITH SEG AS (
  SELECT prod_id
       , evt_dt AS start_dt
       , LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt
       , new_price
  FROM PRICE_EVENT
)
SELECT s.sales_dt, s.prod_id, s.qty, g.new_price, s.qty * g.new_price AS revenue
FROM   SALES_D s
JOIN   SEG     g
  ON   g.prod_id = s.prod_id
 AND   s.sales_dt >= g.start_dt
 AND   s.sales_dt <  g.end_dt
ORDER  BY s.sales_dt;
```

**포인트**
- **선분구간**은 `(start_dt, end_dt)`를 미리 만든 뒤, **포인트 테이블**과 **비등치 조인(기간 조인)**.  
- 구간이 많다면 `prod_id, start_dt` 인덱스 + `BETWEEN` 범위 탐색을 고려.

### 2.4 “다른 선분”과 **교집합 분절** (두 구간의 겹치는 구간만)
```sql
-- 다른 선분: 프로모션 기간 테이블
DROP TABLE PROMO PURGE;
CREATE TABLE PROMO(
  PROD_ID NUMBER NOT NULL,
  START_DT DATE NOT NULL,
  END_DT   DATE NOT NULL
);
INSERT INTO PROMO VALUES(100, DATE '2024-01-08', DATE '2024-01-15');
INSERT INTO PROMO VALUES(100, DATE '2024-02-01', DATE '2024-02-10');
COMMIT;

-- 가격 구간(SEG) x 프로모션(PROMO) 교집합 구간 만들기
WITH SEG AS (
  SELECT prod_id
       , evt_dt AS start_dt
       , LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt
       , new_price
  FROM PRICE_EVENT
),
X AS (
  SELECT s.prod_id
       , GREATEST(s.start_dt, p.start_dt) AS sdt
       , LEAST  (s.end_dt,   p.end_dt  ) AS edt
       , s.new_price
  FROM   SEG s
  JOIN   PROMO p
    ON   p.prod_id = s.prod_id
   AND   s.end_dt   > p.start_dt
   AND   s.start_dt < p.end_dt
)
SELECT * FROM X WHERE sdt < edt ORDER BY sdt;
```

**튜닝 포인트**
- **선분 교집합**은 조인 조건에 **“겹침 판정”**(s.end > p.start AND s.start < p.end)을 사용.  
- 대량이면 **파티셔닝(기간 기반)** 또는 **격자화(버킷팅)**로 후보 집합을 줄입니다.

---

# 3. 데이터 복제를 통한 “소계(Subtotal)” 구하기 — GROUPING SETS vs UNION ALL

> 팩트 한 번 읽어서 **소계/전체합**을 같이 만들고 싶다.  
> (예: 일자·상품 카테고리별 합계 + 일자별 합계 + 전체합)

### 3.1 스키마 & 샘플
```sql
DROP TABLE SALES_F PURGE;
CREATE TABLE SALES_F(
  SALES_DT  DATE         NOT NULL,
  CATEGORY  VARCHAR2(10) NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL
);

BEGIN
  FOR d IN 0..10 LOOP
    INSERT INTO SALES_F
    SELECT DATE '2024-07-01'+d,
           col,
           ROUND(DBMS_RANDOM.VALUE(10,200),2)
    FROM (SELECT 'ELEC' col FROM dual UNION ALL
          SELECT 'FOOD'     FROM dual UNION ALL
          SELECT 'TOY'      FROM dual);
  END LOOP;
  COMMIT;
END;
/
BEGIN DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES_F'); END;
/
```

### 3.2 **GROUPING SETS**(권장) — “데이터 복제” 없이 **엔진이 소계 생성**
```sql
SELECT sales_dt
     , category
     , SUM(amount) AS amt
     , GROUPING(sales_dt) AS g_dt
     , GROUPING(category) AS g_cat
FROM   SALES_F
GROUP  BY GROUPING SETS (
          (sales_dt, category),  -- 상세
          (sales_dt),            -- 일자 소계
          ()                     -- 전체합
        )
ORDER  BY sales_dt NULLS LAST, category NULLS LAST;
```
- `GROUPING()` 컬럼으로 **소계/합계 행 식별**.  
- OLAP 문법 `ROLLUP`, `CUBE`도 가능.

### 3.3 **UNION ALL**로 “데이터 복제” 후 **단일 쿼리 집계**
```sql
SELECT sales_dt, category, SUM(amount) amt
FROM (
  SELECT sales_dt, category, amount FROM SALES_F                    -- 상세
  UNION ALL
  SELECT sales_dt, NULL,     amount FROM SALES_F                    -- 일자 레벨
  UNION ALL
  SELECT NULL,     NULL,     amount FROM SALES_F                    -- 전체합
)
GROUP BY sales_dt, category
ORDER BY sales_dt NULLS LAST, category NULLS LAST;
```
**비교**
- `GROUPING SETS`가 **가독성/성능**에서 일반적으로 더 낫다.  
- 다만 **복잡한 “우선순위 소계”**가 필요하면 `UNION ALL` + `CASE`가 명확할 때도 있다.

**튜닝 포인트**
- 집계 대상이 크면 **사전 프루닝**(기간·파티션), **병렬**(`PARALLEL`), **집계 인덱스** 고려.  
- 보고/대시보드에서 **요약 테이블**(물리화 뷰)로 캐시하는 것도 빈번.

---

# 4. 상호배타적(Exclusive) 관계의 조인 — “둘 중 하나만” 매칭

> 예: 고객-상태 매핑에서 같은 키에 **A셋 또는 B셋 중 정확히 하나**만 매칭되어야 할 때,  
> *양쪽 모두 매칭* 또는 *아무쪽도 매칭 없음*을 **배제**하고 “**상호배타**”를 보장하는 패턴.

### 4.1 스키마 & 샘플
```sql
DROP TABLE A_TAG PURGE;
DROP TABLE B_TAG PURGE;

CREATE TABLE A_TAG (KEY_ID NUMBER PRIMARY KEY, NOTE VARCHAR2(20));
CREATE TABLE B_TAG (KEY_ID NUMBER PRIMARY KEY, NOTE VARCHAR2(20));

INSERT INTO A_TAG VALUES(1,'A-only-1');
INSERT INTO A_TAG VALUES(2,'A-only-2');
INSERT INTO B_TAG VALUES(3,'B-only-3');
INSERT INTO B_TAG VALUES(4,'B-only-4');
-- 예외 케이스(양쪽 다 있는 것) 만들어보기
INSERT INTO A_TAG VALUES(10,'A-dup'); INSERT INTO B_TAG VALUES(10,'B-dup');

COMMIT;
```

### 4.2 상호배타 조인 ① — **FULL OUTER** + **단독 매칭 필터**
```sql
SELECT COALESCE(a.key_id, b.key_id) AS key_id
     , a.note AS a_note
     , b.note AS b_note
FROM   A_TAG a
FULL  OUTER JOIN B_TAG b
       ON b.key_id = a.key_id
WHERE  (a.key_id IS NULL AND b.key_id IS NOT NULL)   -- B만 있는 경우
    OR (a.key_id IS NOT NULL AND b.key_id IS NULL);  -- A만 있는 경우
```
- 결과: 1,2,3,4만 출력되고 **10은 배제**(양쪽 다 매칭이라 상호배타 위배).

### 4.3 상호배타 조인 ② — **XOR(배타적 OR)** 형태
```sql
SELECT k.key_id
     , MAX(CASE WHEN src = 'A' THEN note END) AS a_note
     , MAX(CASE WHEN src = 'B' THEN note END) AS b_note
FROM (
  SELECT key_id, note, 'A' src FROM A_TAG
  UNION ALL
  SELECT key_id, note, 'B' src FROM B_TAG
) k
GROUP BY k.key_id
HAVING COUNT(DISTINCT src) = 1;  -- A 또는 B 딱 하나만
```

### 4.4 상호배타를 **무결성**으로 enforce — **체크/유니크**(설계적)
- 트리거/체크/별도 **등록 테이블**에 소유 플래그를 넣고 **유일성 제약**으로 보장하는 편이 더 안전.  
- 조인은 **검출**에, 제약은 **예방**에.

**튜닝 포인트**
- A/B가 크면 **FULL OUTER**보단 **UNION ALL → GROUPING** 기법이 더 빠를 수 있다(정렬/해시 한 번).  
- 상호배타 검출 후 **예외 목록만** 다룰 때는 **ANTI JOIN**(`NOT EXISTS`)으로 빠르게 필터링.

---

# 5. “최종 출력 건”만 남기기 — 최신/우선순위 1건 픽(ROW_NUMBER) + 조인

> 복수 상태/버전 중 **최종 1건**만 붙여서 리포팅하려면 **Top-1 per key**를 만든 뒤 **조인**하는 것이 정석.

### 5.1 스키마 & 샘플
```sql
DROP TABLE DOC PURGE;
CREATE TABLE DOC(
  DOC_ID    NUMBER      NOT NULL,
  VER       NUMBER      NOT NULL,
  STATUS    VARCHAR2(10) NOT NULL,
  UPDATE_DT DATE        NOT NULL,
  CONSTRAINT PK_DOC PRIMARY KEY (DOC_ID, VER)
);

INSERT INTO DOC VALUES(100,1,'DRAFT', DATE '2024-01-10');
INSERT INTO DOC VALUES(100,2,'REVIEW',DATE '2024-01-15');
INSERT INTO DOC VALUES(100,3,'FINAL', DATE '2024-01-20');
INSERT INTO DOC VALUES(200,1,'DRAFT', DATE '2024-02-01');
INSERT INTO DOC VALUES(200,2,'FINAL', DATE '2024-02-05');
INSERT INTO DOC VALUES(300,1,'DRAFT', DATE '2024-03-01'); -- 최종 1건만 존재
COMMIT;
BEGIN DBMS_STATS.GATHER_TABLE_STATS(USER,'DOC'); END;
/
```

### 5.2 **ROW_NUMBER()**로 최종건 산출 → 외부와 조인
```sql
WITH T AS (
  SELECT d.*
       , ROW_NUMBER() OVER (PARTITION BY doc_id ORDER BY ver DESC, update_dt DESC) AS rn
  FROM   DOC d
)
SELECT doc_id, ver, status, update_dt
FROM   T
WHERE  rn = 1
ORDER  BY doc_id;
```

- “최종판 선정 기준”은 `ORDER BY` 안에 **명시**: 버전 내림차순, 수정일 내림차순 등.  
- 이제 이 결과를 **다른 테이블**과 조인하면 항상 **최종 1건**만 붙습니다.

### 5.3 “최종건 + 메타데이터” 조인 예시
```sql
-- 문서를 고객/주문과 매핑해야 한다고 가정
DROP TABLE DOC_OWNER PURGE;
CREATE TABLE DOC_OWNER (DOC_ID NUMBER PRIMARY KEY, OWNER_ID NUMBER, KIND VARCHAR2(10));
INSERT INTO DOC_OWNER VALUES(100, 1, 'CUST');
INSERT INTO DOC_OWNER VALUES(200, 3, 'CUST');
INSERT INTO DOC_OWNER VALUES(300, 5, 'CUST');
COMMIT;

WITH LAST_DOC AS (
  SELECT doc_id, ver, status, update_dt
  FROM (
    SELECT d.*, ROW_NUMBER() OVER (PARTITION BY doc_id ORDER BY ver DESC, update_dt DESC) rn
    FROM   DOC d
  ) x
  WHERE rn = 1
)
SELECT o.owner_id, l.doc_id, l.ver, l.status, l.update_dt
FROM   DOC_OWNER o
JOIN   LAST_DOC  l ON l.doc_id = o.doc_id
ORDER  BY o.owner_id;
```

**튜닝 포인트**
- 대량이면 `DOC(doc_id, ver DESC)` **인덱스** 또는 `DOC(doc_id, update_dt DESC)` **커버링**을 고려.  
- Top-1을 **APPLY(LATERAL)**로도 빠르게 뽑을 수 있음:
```sql
SELECT o.owner_id, v.doc_id, v.ver, v.status, v.update_dt
FROM   DOC_OWNER o
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(d PK_DOC) */ d.doc_id, d.ver, d.status, d.update_dt
  FROM   DOC d
  WHERE  d.doc_id = o.doc_id
  ORDER  BY ver DESC, update_dt DESC
  FETCH FIRST 1 ROWS ONLY
) v;
```

---

# 6. 종합 시나리오

> “상품별 일자 매출에 ‘해당 일자에 유효한 가격’을 붙여 매출액을 만들고,  
> 카테고리 소계/전체합을 함께 보여주며, 각 상품은 ‘최종 등급 정보 1건’만 붙이기.  
> A/B 태깅에서 상호배타 위반(양쪽 매칭)을 제외.”

### 6.1 준비 — 상품·카테고리·등급 이력
```sql
DROP TABLE PROD PURGE;
CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(10) NOT NULL
);
INSERT INTO PROD VALUES(100,'ELEC');

DROP TABLE GRADE_EVT PURGE;
CREATE TABLE GRADE_EVT(
  PROD_ID NUMBER NOT NULL,
  EVT_DT  DATE   NOT NULL,
  GRADE   VARCHAR2(10) NOT NULL,
  CONSTRAINT PK_GE PRIMARY KEY (PROD_ID, EVT_DT)
);
INSERT INTO GRADE_EVT VALUES(100, DATE '2024-01-01','SILVER');
INSERT INTO GRADE_EVT VALUES(100, DATE '2024-02-01','GOLD');
COMMIT;

-- 최종 등급 1건
WITH GE AS (
  SELECT g.*
       , ROW_NUMBER() OVER(PARTITION BY prod_id ORDER BY evt_dt DESC) rn
  FROM   GRADE_EVT g
)
SELECT prod_id, grade FROM GE WHERE rn = 1;  -- 후에 JOIN에 사용
```

### 6.2 가격 선분 + 판매일 조인 → 매출액
```sql
WITH PRICE_SEG AS (
  SELECT prod_id
       , evt_dt AS start_dt
       , LEAD(evt_dt,1,DATE '9999-12-31') OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt
       , new_price
  FROM PRICE_EVENT
),
SALE_PRICE AS (
  SELECT s.sales_dt, s.prod_id, s.qty, p.new_price
  FROM   SALES_D s
  JOIN   PRICE_SEG p
    ON   p.prod_id = s.prod_id
   AND   s.sales_dt >= p.start_dt
   AND   s.sales_dt <  p.end_dt
)
SELECT sales_dt, prod_id, qty, new_price, qty*new_price AS revenue
FROM   SALE_PRICE
ORDER  BY sales_dt;
```

### 6.3 카테고리 소계/전체합 함께(데이터 복제 없이)
```sql
WITH SALE_CAT AS (
  SELECT sp.sales_dt, pr.category, sp.qty*sp.new_price AS revenue
  FROM   SALE_PRICE sp
  JOIN   PROD pr ON pr.prod_id = sp.prod_id
)
SELECT sales_dt, category, SUM(revenue) AS amt
     , GROUPING(sales_dt) AS g_dt, GROUPING(category) AS g_cat
FROM   SALE_CAT
GROUP  BY GROUPING SETS ((sales_dt, category), (sales_dt), ())
ORDER  BY sales_dt NULLS LAST, category NULLS LAST;
```

### 6.4 최종 등급 한 건만 붙이기
```sql
WITH LAST_G AS (
  SELECT prod_id, grade
  FROM (
    SELECT g.*, ROW_NUMBER() OVER(PARTITION BY prod_id ORDER BY evt_dt DESC) rn
    FROM   GRADE_EVT g
  )
  WHERE rn = 1
),
SALE_CAT AS (
  SELECT sp.sales_dt, pr.prod_id, pr.category, sp.qty*sp.new_price AS revenue
  FROM   SALE_PRICE sp
  JOIN   PROD pr ON pr.prod_id = sp.prod_id
)
SELECT sc.sales_dt, sc.category, lg.grade, SUM(sc.revenue) amt
FROM   SALE_CAT sc
LEFT   JOIN LAST_G lg ON lg.prod_id = sc.prod_id
GROUP  BY sc.sales_dt, sc.category, lg.grade
ORDER  BY sc.sales_dt, sc.category;
```

### 6.5 상호배타 위반 키 제외(유효 데이터만)
```sql
-- 상호배타 태그 테이블을 붙여 “둘 중 하나만” 있는 키만 허용
WITH EXCL AS (
  SELECT k, COUNT(DISTINCT src) as kinds
  FROM (
    SELECT prod_id k, 'A' src FROM A_TAG
    UNION ALL
    SELECT prod_id k, 'B' src FROM B_TAG
  )
  GROUP BY k
)
-- kinds=1만 허용, 0 또는 2는 배제
SELECT ...
FROM   (...이전 결과...) r
LEFT   JOIN EXCL e ON e.k = r.prod_id
WHERE  e.kinds = 1;
```

---

# 7. 성능·튜닝 체크리스트

- [ ] **누적합**은 윈도 `SUM OVER(ORDER BY ...)`가 기본. 자기조인은 지양.  
- [ ] **선분 이력**은 **LEAD로 구간화 → 기간 조인**이 정석. 구간끼리 교집합은 `GREATEST/LEAST`.  
- [ ] **소계/총계**는 `GROUPING SETS/ROLLUP/CUBE` 우선. 복잡 규칙은 `UNION ALL` 고려.  
- [ ] **최종건**은 `ROW_NUMBER()` Top-1 per key + 조인, 또는 `APPLY`로 Top-1.  
- [ ] **상호배타**는 `FULL OUTER + 단독 필터` 또는 `UNION ALL → HAVING COUNT(DISTINCT src)=1`.  
- [ ] 대량 데이터는 **조인 순서**(LEADING/ORDERED)·**메소드**(USE_HASH/USE_NL)·**프루닝**(파티션/인덱스)로 I/O 절감.  
- [ ] 결과 검증은 `DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')`.

---

## (부록) 빠른 인덱스 힌트 스니펫
```sql
-- 선분조인: 포인트 테이블이 드라이빙, 선분 테이블은 (prod_id, start_dt) 인덱스
SELECT /*+ ORDERED LEADING(s) USE_NL(p) INDEX(p <prod_id_startdt_idx>) */ ...

-- Top-1 per key: APPLY + 역순 인덱스
SELECT /*+ INDEX_DESC(d <doc_comp_idx>) */ ... FETCH FIRST 1 ROWS ONLY;
```

---

### 요약
- **누적 매출**: 윈도 SUM이 최선, 조인형은 교육적 참고.  
- **선분이력 끊기**: 이벤트를 **구간화**하고 **기간 조인**으로 정확하게 붙인다.  
- **소계**: `GROUPING SETS`로 **데이터 복제 없이** 한 번에.  
- **상호배타 조인**: FULL OUTER + 단독 필터 또는 XOR 집계.  
- **최종 출력 건**: `ROW_NUMBER()`(또는 APPLY)로 Top-1을 만든 뒤 조인.  
- 각 기법을 조합하면 **복잡한 비즈니스 리포트**도 **한 번의 스캔**과 **최소 I/O**로 구현할 수 있다.