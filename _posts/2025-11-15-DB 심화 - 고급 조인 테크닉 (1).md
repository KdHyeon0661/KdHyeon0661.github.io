---
layout: post
title: DB 심화 - 고급 조인 테크닉 (1)
date: 2025-11-15 14:25:23 +0900
category: DB 심화
---
# 고급 조인 테크닉: 누적, 기간, 소계, 상호배타, Top-1 조인

이 문서에서는 데이터 처리에서 자주 마주치는 복잡한 조인 패턴들을 체계적으로 다룹니다. 누적 합계 계산, 기간 기반 조인, 계층적 소계 생성, 상호배타 관계 처리, 키별 최종 행 추출 등 실무에서 필수적인 테크닉들을 실제 예제와 함께 설명합니다.

## 실습 환경 설정

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;
```

실행 계획 분석을 위한 표준 템플릿:
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL,
  'ALLSTATS LAST +PREDICATE +ALIAS +NOTE +IOSTATS +MEMSTATS'
));
```

## 1. 누적 합계(Running Total) 계산

### 기본 데이터 모델

```sql
DROP TABLE SALES PURGE;
CREATE TABLE SALES(
  SALES_DT   DATE         NOT NULL,
  CUST_ID    NUMBER       NOT NULL,
  AMOUNT     NUMBER(12,2) NOT NULL,
  CONSTRAINT PK_SALES PRIMARY KEY (SALES_DT, CUST_ID)
);

BEGIN
  FOR d IN 0..14 LOOP
    INSERT INTO SALES
    SELECT DATE '2024-06-01'+d, c, ROUND(DBMS_RANDOM.VALUE(10,200),2)
    FROM (SELECT LEVEL c FROM dual CONNECT BY LEVEL <= 5);
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES');
END;
/
```

### 윈도 함수를 이용한 최적의 누적 합계 계산

윈도 함수는 누적 합계 계산에 가장 효율적인 방법입니다:

```sql
-- 일자별 판매액과 누적 합계
SELECT sales_dt,
       SUM(amount) AS day_amount,
       SUM(SUM(amount)) OVER(
         ORDER BY sales_dt
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
       ) AS running_total
FROM   SALES
GROUP  BY sales_dt
ORDER  BY sales_dt;
```

이 쿼리의 효율성은 두 가지 최적화에서 비롯됩니다:
1. 먼저 `GROUP BY`로 일자별로 데이터를 축소합니다(75행 → 15행)
2. 축소된 결과에 윈도 함수를 적용합니다

### 고객별 누적 합계

```sql
-- 고객별 일별 판매액과 누적 합계
SELECT cust_id, sales_dt, amount,
       SUM(amount) OVER(
         PARTITION BY cust_id
         ORDER BY sales_dt
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
       ) AS customer_running_total
FROM SALES
ORDER BY cust_id, sales_dt;
```

성능 최적화를 위해 `(cust_id, sales_dt)` 인덱스를 생성하는 것이 좋습니다.

### 조인을 이용한 누적 합계(비권장)

윈도 함수를 사용할 수 없는 특수한 상황을 위한 방법입니다:

```sql
-- 비효율적인 조인 방식의 누적 합계
WITH daily_sales AS (
  SELECT sales_dt, SUM(amount) AS day_amount
  FROM SALES
  GROUP BY sales_dt
)
SELECT d1.sales_dt,
       d1.day_amount,
       SUM(d2.day_amount) AS running_total
FROM daily_sales d1
JOIN daily_sales d2 ON d2.sales_dt <= d1.sales_dt
GROUP BY d1.sales_dt, d1.day_amount
ORDER BY d1.sales_dt;
```

이 방식은 O(N²)의 시간 복잡도를 가지므로 대량 데이터에서는 성능 문제가 발생합니다.

## 2. 기간 기반 조인

### 기본 데이터 모델

```sql
-- 가격 변경 이력 테이블
DROP TABLE PRICE_EVENT PURGE;
CREATE TABLE PRICE_EVENT(
  PROD_ID   NUMBER       NOT NULL,
  EVT_DT    DATE         NOT NULL,
  NEW_PRICE NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_PRICE_EVENT PRIMARY KEY (PROD_ID, EVT_DT)
);

INSERT INTO PRICE_EVENT VALUES (100, DATE '2024-01-01', 100);
INSERT INTO PRICE_EVENT VALUES (100, DATE '2024-01-10', 120);
INSERT INTO PRICE_EVENT VALUES (100, DATE '2024-01-25', 110);
INSERT INTO PRICE_EVENT VALUES (100, DATE '2024-02-05', 130);
COMMIT;

-- 판매 테이블
DROP TABLE SALES_D PURGE;
CREATE TABLE SALES_D(
  SALES_DT DATE   NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  QTY      NUMBER NOT NULL
);

BEGIN
  FOR d IN 0..40 LOOP
    INSERT INTO SALES_D VALUES (DATE '2024-01-01'+d, 100, 1 + MOD(d,3));
  END LOOP;
  COMMIT;
END;
/
```

### 선분(Segment) 생성

```sql
-- LEAD 함수를 이용한 유효기간 선분 생성
WITH PRICE_SEGMENT AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt, 1, DATE '9999-12-31')
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM PRICE_EVENT
)
SELECT *
FROM PRICE_SEGMENT
ORDER BY prod_id, start_dt;
```

### 포인트-선분 조인

```sql
-- 판매일이 속한 가격 구간과 조인
WITH PRICE_SEGMENT AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt, 1, DATE '9999-12-31')
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM PRICE_EVENT
)
SELECT s.sales_dt, s.prod_id, s.qty,
       p.new_price,
       s.qty * p.new_price AS revenue
FROM   SALES_D s
JOIN   PRICE_SEGMENT p
  ON   p.prod_id = s.prod_id
 AND   s.sales_dt >= p.start_dt
 AND   s.sales_dt <  p.end_dt   -- 중요: end_dt는 배제적
ORDER BY s.sales_dt;
```

### 선분-선분 교집합 계산

```sql
-- 프로모션 기간 테이블
DROP TABLE PROMO PURGE;
CREATE TABLE PROMO(
  PROD_ID  NUMBER NOT NULL,
  START_DT DATE   NOT NULL,
  END_DT   DATE   NOT NULL
);

INSERT INTO PROMO VALUES(100, DATE '2024-01-08', DATE '2024-01-15');
INSERT INTO PROMO VALUES(100, DATE '2024-02-01', DATE '2024-02-10');
COMMIT;

-- 선분 교집합 계산
WITH PRICE_SEGMENT AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt, 1, DATE '9999-12-31')
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM PRICE_EVENT
)
SELECT p.prod_id,
       GREATEST(p.start_dt, r.start_dt) AS overlap_start,
       LEAST(p.end_dt, r.end_dt) AS overlap_end,
       p.new_price
FROM   PRICE_SEGMENT p
JOIN   PROMO r
  ON   r.prod_id = p.prod_id
 AND   p.end_dt > r.start_dt   -- 겹침 조건 1
 AND   p.start_dt < r.end_dt   -- 겹침 조건 2
WHERE GREATEST(p.start_dt, r.start_dt) < LEAST(p.end_dt, r.end_dt)
ORDER BY overlap_start;
```

### 성능 최적화 기법

```sql
-- 버킷(bucket) 기반 최적화
WITH PRICE_SEGMENT AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt, 1, DATE '9999-12-31')
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         TRUNC(evt_dt, 'MM') AS bucket_month,
         new_price
  FROM PRICE_EVENT
),
SALES_BUCKET AS (
  SELECT sales_dt, prod_id, qty, 
         TRUNC(sales_dt, 'MM') AS bucket_month
  FROM SALES_D
)
SELECT s.sales_dt, s.prod_id, s.qty, p.new_price
FROM   SALES_BUCKET s
JOIN   PRICE_SEGMENT p
  ON   p.prod_id = s.prod_id
 AND   p.bucket_month = s.bucket_month          -- 동등 조인으로 후보 축소
 AND   s.sales_dt >= p.start_dt
 AND   s.sales_dt <  p.end_dt;
```

## 3. 계층적 소계(Subtotal) 생성

### GROUPING SETS를 이용한 효율적인 소계 생성

```sql
-- 샘플 데이터
DROP TABLE SALES_F PURGE;
CREATE TABLE SALES_F(
  SALES_DT  DATE         NOT NULL,
  CATEGORY  VARCHAR2(10) NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL
);

BEGIN
  FOR d IN 0..10 LOOP
    INSERT INTO SALES_F
    SELECT DATE '2024-07-01'+d, category, ROUND(DBMS_RANDOM.VALUE(10,200),2)
    FROM (SELECT 'ELEC' category FROM dual UNION ALL
          SELECT 'FOOD' FROM dual UNION ALL
          SELECT 'TOY' FROM dual);
  END LOOP;
  COMMIT;
END;
/

-- GROUPING SETS를 이용한 다중 레벨 집계
SELECT sales_dt,
       category,
       SUM(amount) AS amount,
       GROUPING_ID(sales_dt, category) AS grouping_id,
       CASE GROUPING_ID(sales_dt, category)
         WHEN 0 THEN '상세'
         WHEN 1 THEN '일자별 소계'
         WHEN 3 THEN '전체 합계'
       END AS row_type
FROM   SALES_F
GROUP  BY GROUPING SETS (
          (sales_dt, category),  -- 상세 레벨
          (sales_dt),            -- 일자별 소계
          ()                     -- 전체 합계
        )
ORDER  BY sales_dt NULLS LAST, category NULLS LAST;
```

### ROLLUP과 CUBE

```sql
-- ROLLUP: 계층적 소계
SELECT sales_dt, category, SUM(amount) AS amount
FROM SALES_F
GROUP BY ROLLUP(sales_dt, category)
ORDER BY sales_dt NULLS LAST, category NULLS LAST;

-- CUBE: 모든 조합의 소계
SELECT sales_dt, category, SUM(amount) AS amount
FROM SALES_F
GROUP BY CUBE(sales_dt, category)
ORDER BY sales_dt NULLS LAST, category NULLS LAST;
```

## 4. 상호배타(Mutually Exclusive) 관계 처리

### 기본 데이터 모델

```sql
DROP TABLE A_TAG PURGE;
DROP TABLE B_TAG PURGE;

CREATE TABLE A_TAG (KEY_ID NUMBER PRIMARY KEY, NOTE VARCHAR2(20));
CREATE TABLE B_TAG (KEY_ID NUMBER PRIMARY KEY, NOTE VARCHAR2(20));

-- 상호배타 데이터
INSERT INTO A_TAG VALUES(1, 'A-only-1');
INSERT INTO A_TAG VALUES(2, 'A-only-2');
INSERT INTO B_TAG VALUES(3, 'B-only-3');
INSERT INTO B_TAG VALUES(4, 'B-only-4');

-- 중복 데이터(위배 케이스)
INSERT INTO A_TAG VALUES(10, 'A-dup');
INSERT INTO B_TAG VALUES(10, 'B-dup');

COMMIT;
```

### FULL OUTER JOIN을 이용한 상호배타 필터링

```sql
-- 한쪽에만 존재하는 키 찾기
SELECT COALESCE(a.key_id, b.key_id) AS key_id,
       a.note AS a_note,
       b.note AS b_note,
       CASE 
         WHEN a.key_id IS NULL THEN 'B only'
         WHEN b.key_id IS NULL THEN 'A only'
       END AS exclusive_type
FROM   A_TAG a
FULL  OUTER JOIN B_TAG b
       ON b.key_id = a.key_id
WHERE  a.key_id IS NULL OR b.key_id IS NULL;
```

### 집계를 이용한 효율적인 방법

```sql
-- UNION ALL과 GROUP BY를 이용한 방법
SELECT key_id,
       MAX(CASE WHEN source = 'A' THEN note END) AS a_note,
       MAX(CASE WHEN source = 'B' THEN note END) AS b_note
FROM (
  SELECT key_id, note, 'A' AS source FROM A_TAG
  UNION ALL
  SELECT key_id, note, 'B' AS source FROM B_TAG
)
GROUP BY key_id
HAVING COUNT(DISTINCT source) = 1;  -- 한쪽에만 존재하는 키만 선택
```

### 중복 검출

```sql
-- 양쪽 테이블에 모두 존재하는 키 찾기
SELECT key_id
FROM (
  SELECT key_id, 'A' AS source FROM A_TAG
  UNION ALL
  SELECT key_id, 'B' AS source FROM B_TAG
)
GROUP BY key_id
HAVING COUNT(DISTINCT source) = 2;
```

## 5. 키별 최종 행(Top-1 per key) 추출

### 기본 데이터 모델

```sql
DROP TABLE DOC PURGE;
CREATE TABLE DOC(
  DOC_ID    NUMBER       NOT NULL,
  VER       NUMBER       NOT NULL,
  STATUS    VARCHAR2(10) NOT NULL,
  UPDATE_DT DATE         NOT NULL,
  CONSTRAINT PK_DOC PRIMARY KEY (DOC_ID, VER)
);

INSERT INTO DOC VALUES(100, 1, 'DRAFT',  DATE '2024-01-10');
INSERT INTO DOC VALUES(100, 2, 'REVIEW', DATE '2024-01-15');
INSERT INTO DOC VALUES(100, 3, 'FINAL',  DATE '2024-01-20');
INSERT INTO DOC VALUES(200, 1, 'DRAFT',  DATE '2024-02-01');
INSERT INTO DOC VALUES(200, 2, 'FINAL',  DATE '2024-02-05');
INSERT INTO DOC VALUES(300, 1, 'DRAFT',  DATE '2024-03-01');

COMMIT;
```

### ROW_NUMBER()을 이용한 표준 방법

```sql
-- 문서별 최종 버전 추출
WITH DOC_RANKED AS (
  SELECT doc_id, ver, status, update_dt,
         ROW_NUMBER() OVER(
           PARTITION BY doc_id
           ORDER BY ver DESC, update_dt DESC
         ) AS rn
  FROM DOC
)
SELECT doc_id, ver, status, update_dt
FROM DOC_RANKED
WHERE rn = 1
ORDER BY doc_id;
```

### 집계 함수의 KEEP 절을 이용한 방법

```sql
-- 집계 함수를 이용한 최종 값 추출
SELECT doc_id,
       MAX(ver) KEEP (DENSE_RANK LAST ORDER BY ver, update_dt) AS last_version,
       MAX(status) KEEP (DENSE_RANK LAST ORDER BY ver, update_dt) AS last_status,
       MAX(update_dt) KEEP (DENSE_RANK LAST ORDER BY ver, update_dt) AS last_update
FROM DOC
GROUP BY doc_id
ORDER BY doc_id;
```

### LATERAL 조인을 이용한 인덱스 최적화 방법

```sql
-- 문서 소유자 테이블
DROP TABLE DOC_OWNER PURGE;
CREATE TABLE DOC_OWNER (
  DOC_ID    NUMBER PRIMARY KEY, 
  OWNER_ID  NUMBER
);

INSERT INTO DOC_OWNER VALUES(100, 1);
INSERT INTO DOC_OWNER VALUES(200, 3);
INSERT INTO DOC_OWNER VALUES(300, 5);
COMMIT;

-- LATERAL 조인을 이용한 효율적인 최종 문서 조회
SELECT o.owner_id, d.doc_id, d.ver, d.status, d.update_dt
FROM   DOC_OWNER o
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(doc PK_DOC) */
         doc_id, ver, status, update_dt
  FROM   DOC doc
  WHERE  doc.doc_id = o.doc_id
  ORDER  BY ver DESC, update_dt DESC
  FETCH  FIRST 1 ROW ONLY
) d
ORDER BY o.owner_id;
```

## 6. 통합 실전 예제

여러 고급 조인 기법을 결합한 실전 예제입니다:

```sql
-- 1. 가격 선분 생성
WITH PRICE_SEGMENT AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt, 1, DATE '9999-12-31')
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM PRICE_EVENT
),

-- 2. 판매 데이터에 가격 정보 조인
SALES_WITH_PRICE AS (
  SELECT s.sales_dt, s.prod_id, s.qty,
         p.new_price,
         s.qty * p.new_price AS revenue
  FROM   SALES_D s
  JOIN   PRICE_SEGMENT p
    ON   p.prod_id = s.prod_id
   AND   s.sales_dt >= p.start_dt
   AND   s.sales_dt <  p.end_dt
),

-- 3. 제품 정보 조인 (가상 테이블)
PRODUCT_INFO AS (
  SELECT 100 AS prod_id, 'Electronics' AS category FROM dual
  UNION ALL
  SELECT 200, 'Furniture' FROM dual
),

-- 4. 카테고리별 판매 집계
CATEGORY_SALES AS (
  SELECT sp.sales_dt,
         p.category,
         sp.revenue
  FROM   SALES_WITH_PRICE sp
  JOIN   PRODUCT_INFO p ON p.prod_id = sp.prod_id
)

-- 5. 다중 레벨 집계 결과
SELECT sales_dt,
       category,
       SUM(revenue) AS total_revenue,
       GROUPING_ID(sales_dt, category) AS grouping_level,
       CASE GROUPING_ID(sales_dt, category)
         WHEN 0 THEN 'Daily by Category'
         WHEN 1 THEN 'Daily Total'
         WHEN 3 THEN 'Grand Total'
       END AS aggregation_type
FROM   CATEGORY_SALES
GROUP  BY GROUPING SETS (
          (sales_dt, category),
          (sales_dt),
          ()
        )
ORDER  BY sales_dt NULLS LAST, category NULLS LAST;
```

## 7. 성능 모니터링 및 최적화 가이드

### 실행 계획 분석 포인트

1. **데이터 축소 효과 확인**: GROUP BY나 필터링 후의 A-Rows가 크게 줄어들었는지 확인
2. **윈도 함수 효율성**: WINDOW SORT 연산이 적절한 입력 크기에서 수행되는지 확인
3. **조인 방식 최적성**: 기간 조인이 인덱스 범위 스캔으로 수행되는지 확인
4. **메모리 사용량**: TEMP 공간 사용이 없는지(Optimal 모드) 확인

### 일반적인 최적화 기법

1. **인덱스 설계**: 조인 키와 정렬 키에 적절한 인덱스 구성
2. **데이터 사전 축소**: 가능한 경우 서브쿼리로 데이터 크기 줄이기
3. **파티셔닝 활용**: 대용량 데이터의 경우 파티셔닝으로 프루닝(Pruning) 적용
4. **통계 정보 관리**: 정확한 카디널리티 추정을 위한 통계 정보 갱신

### 주의사항

1. **윈도 함수 vs 조인**: 가능하면 윈도 함수 사용이 더 효율적
2. **기간 조인 경계**: [시작, 종료) 패턴을 일관되게 적용
3. **NULL 처리**: 집계 시 NULL 값의 영향을 고려
4. **동률 처리**: Top-1 추출 시 동률 처리 규칙 명확히 정의

## 결론

고급 조인 테크닉은 복잡한 비즈니스 요구사항을 효율적으로 구현하는 데 필수적인 기술입니다. 각 패턴마다 최적의 구현 방법과 성능 특성을 이해하는 것이 중요합니다.

**핵심 원칙 요약:**

1. **누적 계산에는 윈도 함수**: 사전 집계 후 윈도 함수 적용이 가장 효율적
2. **기간 조인은 선분화**: LEAD/LAG로 선분 생성 후 [시작, 종료) 패턴으로 조인
3. **계층적 집계는 GROUPING SETS**: 한 번의 스캔으로 다중 레벨 결과 생성
4. **상호배타는 FULL OUTER JOIN**: NULL 체크로 배타적 관계 필터링
5. **키별 최종 행은 ROW_NUMBER**: 결정적 순서 정의 후 첫 번째 행 선택

**실무 적용 시 고려사항:**

- 데이터 규모에 맞는 알고리즘 선택: 작은 데이터셋과 대용량 데이터셋의 최적 전략은 다름
- 인덱스 설계의 중요성: 적절한 인덱스 없이는 어떤 알고리즘이라도 성능 저하
- 통계 정보의 정확성: 옵티마이저의 결정을 돕는 정확한 통계 정보 필요
- 유지보수성: 복잡한 쿼리도 가독성 있고 이해하기 쉽게 작성

이러한 고급 조인 테크닉을 숙지하면 데이터 처리 요구사항이 복잡해질수록 더욱 효율적이고 정확한 솔루션을 설계할 수 있습니다. 각 상황에 맞는 최적의 패턴을 선택하고, 성능 측정을 통해 지속적으로 개선하는 접근이 필요합니다.