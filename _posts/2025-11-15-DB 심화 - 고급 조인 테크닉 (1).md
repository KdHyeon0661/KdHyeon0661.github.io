---
layout: post
title: DB 심화 - 고급 조인 테크닉 (1)
date: 2025-11-15 14:25:23 +0900
category: DB 심화
---
# 고급 조인 테크닉 1 — 누적/기간/소계/상호배타/Top-1 조인

> 목표
> 1) “조인으로도 가능하지만 윈도 함수가 정답인 패턴”을 구분한다.
> 2) “기간(유효구간) 기반 이력”을 선분화하고, 포인트/선분/선분-선분 조인을 안정적으로 한다.
> 3) “한 번의 스캔으로 소계/총계를 뽑는 집계 조인”을 만든다.
> 4) “둘 중 하나만 매칭되는 관계(상호배타)”를 빠르게 검출/구현한다.
> 5) “키별 최종 1건(Top-1 per key)”을 뽑아 조인하는 표준 루틴을 확보한다.

---

## 0) 실습 공통 세팅

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;
```

실행 후 실측 플랜은 항상:

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
         'ALLSTATS LAST +PREDICATE +ALIAS +NOTE +IOSTATS +MEMSTATS'));
```

---

## 1) 누적(Running Total) 구하기 — “조인형”과 “윈도 함수형”의 본질적 차이

### 스키마 & 샘플

```sql
DROP TABLE SALES PURGE;
CREATE TABLE SALES(
  SALES_DT   DATE         NOT NULL,
  CUST_ID    NUMBER       NOT NULL,
  AMOUNT     NUMBER(12,2) NOT NULL,
  CONSTRAINT PK_SALES PRIMARY KEY (SALES_DT, CUST_ID)
);

BEGIN
  FOR d IN 0..14 LOOP
    INSERT INTO SALES
    SELECT DATE '2024-06-01'+d, c, ROUND(DBMS_RANDOM.VALUE(10,200),2)
    FROM (SELECT LEVEL c FROM dual CONNECT BY LEVEL <= 5);
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES');
END;
/
```

**데이터 특징**
- 하루에 고객 5명, 15일 → 총 75행
- PK가 `(SALES_DT, CUST_ID)`라서 날짜 정렬/범위 접근이 매우 좋다.

---

### 윈도 누적합 — 정석, 거의 항상 최선

```sql
SELECT sales_dt,
       SUM(amount) AS day_amt,
       SUM(SUM(amount)) OVER(
         ORDER BY sales_dt
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
       ) AS run_total
FROM   SALES
GROUP  BY sales_dt
ORDER  BY sales_dt;
```

**왜 빠른가?**
1) 먼저 `GROUP BY sales_dt`로 **일자 단위로 축소(15행)**
2) 그 결과에만 윈도 SUM 수행
3) 정렬은 **15행만** 정렬하면 된다.

즉, **“사전집계 → 누적”**이 핵심이다.
원본(75행) 그대로 누적하면 비용이 더 든다.

#### RANGE vs ROWS의 차이

- `ROWS BETWEEN ...`는 **행 기준 누적**
- `RANGE BETWEEN ...`는 **값(동일 sales_dt 묶음) 기준 누적**

일자 단위 집계를 했으니 `ROWS`가 정확/빠름.
하지만 원본에서 바로 할 때 `RANGE`가 의미를 바꿀 수 있다.

```sql
-- 원본에서 누적(일자에 여러 행이 존재)
SELECT sales_dt, cust_id, amount,
       SUM(amount) OVER(
         ORDER BY sales_dt
         RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
       ) AS run_total_by_date
FROM SALES
ORDER BY sales_dt, cust_id;
```

- 같은 날짜의 여러 행이 **한 번에** 포함되며 증가한다.
- “일자별로 누적이 계단처럼 오르는” 그림이 된다.

#### PARTITION BY로 “고객별 누적”

```sql
SELECT cust_id, sales_dt, amount,
       SUM(amount) OVER(
         PARTITION BY cust_id
         ORDER BY sales_dt
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
       ) AS run_total_cust
FROM SALES
ORDER BY cust_id, sales_dt;
```

**튜닝 포인트**
- 파티션(고객)별로 정렬이 필요하므로,
  `(cust_id, sales_dt)` 인덱스가 있으면 더 좋다.
- 대량일 때는 `GROUP BY cust_id, sales_dt`로 **날짜 중복을 먼저 줄이는** 게 중요.

---

### “조인형 러닝 토털” — 학술/면접용, 실무 지양

```sql
SELECT s1.sales_dt,
       SUM(s1.amount) AS day_amt,
       SUM(s2.amount) AS run_total
FROM   SALES s1
JOIN   SALES s2
  ON   s2.sales_dt <= s1.sales_dt
GROUP  BY s1.sales_dt
ORDER  BY s1.sales_dt;
```

**왜 느려지는가?**
- 일자 수를 N이라 하면, 조인 후 후보는 대략
  $$1 + 2 + \cdots + N = \frac{N(N+1)}{2}$$
- 즉 **O(N²)**로 커진다.

N=15라서 괜찮아 보여도,
N=365(1년 일자)면 조인 후보가 6만+로 커지고
원본이 더 크면 바로 폭발한다.

#### 그래도 “조인만” 써야 할 때의 최소 개선

1) **일자 단위로 먼저 축소**
2) 그 축소본끼리 조인

```sql
WITH D AS (
  SELECT sales_dt, SUM(amount) day_amt
  FROM SALES
  GROUP BY sales_dt
)
SELECT d1.sales_dt,
       d1.day_amt,
       SUM(d2.day_amt) run_total
FROM D d1
JOIN D d2 ON d2.sales_dt <= d1.sales_dt
GROUP BY d1.sales_dt, d1.day_amt
ORDER BY d1.sales_dt;
```

- 후보가 (D의 행 수)²로 줄어 들어도, 여전히 O(N²).
- “윈도 함수가 없다”는 제약이 정말 특수한 경우에만.

---

### 월 누적 — “월 키”를 만들고 사전집계 후 누적

질문 원본에 있던 예시는 구조가 조금 혼란스러워서, **정석 루틴**으로 재정리한다.

```sql
WITH DAY_AGG AS (
  SELECT TRUNC(sales_dt,'MM') AS mon,
         sales_dt,
         SUM(amount) AS day_amt
  FROM   SALES
  GROUP  BY TRUNC(sales_dt,'MM'), sales_dt
),
MON_AGG AS (
  SELECT mon,
         SUM(day_amt) AS mon_amt
  FROM   DAY_AGG
  GROUP  BY mon
)
SELECT mon,
       mon_amt,
       SUM(mon_amt) OVER(
         ORDER BY mon
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
       ) AS run_total_mon
FROM   MON_AGG
ORDER  BY mon;
```

**포인트**
- “월 누적”은 결국 “월 집계 → 월 단위 누적”.
- **일/월의 계층적 집계는 항상 ‘먼저 줄이고’ 그 결과로 누적**한다.

**대용량 테이블에서 핵심**
- 파티션이 `sales_dt`면, 월 조건이 들어가면 **파티션 프루닝과 더 효율적으로 결합**된다.
- 월 기반 리포트가 잦으면 **월 요약 테이블**(물리화/머티리얼라이즈드 뷰)도 검토.

---

## 2) 유효기간(기간) 조인 + 구간 경계 합치기

> “속성이 날짜 구간으로 관리되는 이력(가격/등급/담당자)을
> 이벤트(변경) 테이블에서 **선분(segment)**로 만들고,
> 포인트(판매일/조회일)에 매칭하거나,
> 선분과 선분을 교집합으로 분절하는 테크닉”

### 스키마 & 샘플

```sql
DROP TABLE PRICE_EVENT PURGE;
CREATE TABLE PRICE_EVENT(
  PROD_ID   NUMBER       NOT NULL,
  EVT_DT    DATE         NOT NULL,
  NEW_PRICE NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_PRICE_EVENT PRIMARY KEY (PROD_ID, EVT_DT)
);

INSERT INTO PRICE_EVENT VALUES (100, DATE '2024-01-01', 100);
INSERT INTO PRICE_EVENT VALUES (100, DATE '2024-01-10', 120);
INSERT INTO PRICE_EVENT VALUES (100, DATE '2024-01-25', 110);
INSERT INTO PRICE_EVENT VALUES (100, DATE '2024-02-05', 130);
COMMIT;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PRICE_EVENT');
END;
/
```

---

### LEAD로 “시작~끝” 구간 만들기

```sql
WITH SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt, 1, DATE '9999-12-31')
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM   PRICE_EVENT
)
SELECT *
FROM SEG
ORDER BY prod_id, start_dt;
```

**구간 정의**
- `[start_dt, end_dt)` 형태(시작 포함, 끝 미포함).
- 마지막 구간은 `9999-12-31`로 열린 구간 처리.

#### 같은 날에 이벤트가 여러 개라면?

PK가 `(prod_id, evt_dt)`라서 같은 날 이벤트를 허용하지 않는다.
만약 실무에서 같은 날 여러 이벤트(시간 포함)가 필요하면:
- `evt_dt`에 시간까지 포함하거나
- `evt_ts TIMESTAMP`로 바꾸고
- PK를 `(prod_id, evt_ts)`로 둔다.

그럼 LEAD는 자연스럽게 작동한다.

---

### 포인트-선분(기간) 조인 — 판매일이 속한 가격 붙이기

#### 판매 테이블 준비

```sql
DROP TABLE SALES_D PURGE;
CREATE TABLE SALES_D(
  SALES_DT DATE   NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  QTY      NUMBER NOT NULL
);

BEGIN
  FOR d IN 0..40 LOOP
    INSERT INTO SALES_D VALUES (DATE '2024-01-01'+d, 100, 1 + MOD(d,3));
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES_D');
END;
/
```

#### 기간 조인

```sql
WITH SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt, 1, DATE '9999-12-31')
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM PRICE_EVENT
)
SELECT s.sales_dt, s.prod_id, s.qty,
       g.new_price,
       s.qty * g.new_price AS revenue
FROM   SALES_D s
JOIN   SEG g
  ON   g.prod_id = s.prod_id
 AND   s.sales_dt >= g.start_dt
 AND   s.sales_dt <  g.end_dt
ORDER  BY s.sales_dt;
```

**핵심**
- 포인트(판매일)를 선분(가격구간)에 넣는 **비등치 조인**.
- 조건은 반드시 `[start, end)` 규약에 맞춘다.

#### 기간 조인의 대표 실수

1) **끝 경계를 <= 로 두는 실수**
```sql
AND s.sales_dt <= g.end_dt
```
- 이렇게 하면 “end_dt에 해당하는 이벤트 당일이 두 구간에 중복”된다.
- `[start, end)` 규약이면 `< end_dt`가 정답.

2) **구간에 공백(갭)이 있는데도 INNER JOIN 쓰는 실수**
- 어떤 날짜는 가격이 없을 수도 있음.
  이 경우 정책에 따라
  - 마지막 가격을 계속 유지(열린구간),
  - NULL 허용(LEFT JOIN),
  - 예외로 처리 등을 선택해야 한다.

---

### 선분-선분 교집합 분절 — 프로모션과 가격구간의 겹치는 구간만

#### 프로모션 테이블

```sql
DROP TABLE PROMO PURGE;
CREATE TABLE PROMO(
  PROD_ID  NUMBER NOT NULL,
  START_DT DATE   NOT NULL,
  END_DT   DATE   NOT NULL
);

INSERT INTO PROMO VALUES(100, DATE '2024-01-08', DATE '2024-01-15');
INSERT INTO PROMO VALUES(100, DATE '2024-02-01', DATE '2024-02-10');
COMMIT;
```

#### 겹침 판정 + 교집합 경계 계산

```sql
WITH SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt, 1, DATE '9999-12-31')
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM PRICE_EVENT
),
X AS (
  SELECT s.prod_id,
         GREATEST(s.start_dt, p.start_dt) AS sdt,
         LEAST  (s.end_dt,   p.end_dt  ) AS edt,
         s.new_price
  FROM   SEG s
  JOIN   PROMO p
    ON   p.prod_id = s.prod_id
   AND   s.end_dt   > p.start_dt   -- 겹침 판정 1
   AND   s.start_dt < p.end_dt     -- 겹침 판정 2
)
SELECT *
FROM   X
WHERE  sdt < edt
ORDER  BY sdt;
```

**왜 겹침 판정이 이렇게 생기나?**
- 두 구간 A=[a1,a2), B=[b1,b2) 이 겹치려면
  a2 > b1 **그리고** a1 < b2 여야 한다.
- 이 조건이 없으면 교집합이 빈 구간인데도 후보로 들어간다.

#### 선분 교집합의 확장 패턴

1) **세 선분(가격×프로모션×담당자) 교집합**
- 2개 교집합을 만든 뒤 다시 3번째와 교집합을 만든다.
- 겹침 판정은 항상 동일.

2) **서로 겹치는 선분을 최대한 “잘게” 분절**
- 이벤트를 “모든 경계 집합”으로 모아 정렬하고,
- 인접 경계 사이를 최소 구간으로 본 뒤,
- 그 최소 구간에 속성을 붙인다.

---

### 대용량에서의 기간 조인 튜닝 전략

1) **선분 테이블(SEG)이 작고 포인트가 크다**
   - 포인트를 드라이빙, SEG는 인덱스로 범위 탐색
   - 인덱스: `(prod_id, start_dt)` 권장

2) **선분이 크고 포인트가 작다**
   - 포인트를 먼저 줄여서 SEG에 세미 조인

3) **양쪽 다 크다**
   - 날짜 버킷(월/주) 파티셔닝
   - 또는 “버킷 키”를 만들어 **등치 조인으로 1차 후보 축소 후** 범위 조건

예시(버킷):

```sql
WITH SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31')
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         TRUNC(evt_dt,'MM') AS bucket_mon,
         new_price
  FROM PRICE_EVENT
),
S AS (
  SELECT sales_dt, prod_id, qty, TRUNC(sales_dt,'MM') AS bucket_mon
  FROM SALES_D
)
SELECT s.sales_dt, s.prod_id, s.qty, g.new_price
FROM   S s
JOIN   SEG g
  ON   g.prod_id = s.prod_id
 AND   g.bucket_mon = s.bucket_mon          -- 등치로 후보 축소
 AND   s.sales_dt >= g.start_dt
 AND   s.sales_dt <  g.end_dt;
```

---

## 3) 데이터 복제 없이 소계(Subtotal) 만들기 — GROUPING SETS / ROLLUP / CUBE

### 스키마 & 샘플

```sql
DROP TABLE SALES_F PURGE;
CREATE TABLE SALES_F(
  SALES_DT  DATE         NOT NULL,
  CATEGORY  VARCHAR2(10) NOT NULL,
  AMOUNT    NUMBER(12,2) NOT NULL
);

BEGIN
  FOR d IN 0..10 LOOP
    INSERT INTO SALES_F
    SELECT DATE '2024-07-01'+d, col, ROUND(DBMS_RANDOM.VALUE(10,200),2)
    FROM (SELECT 'ELEC' col FROM dual UNION ALL
          SELECT 'FOOD'     FROM dual UNION ALL
          SELECT 'TOY'      FROM dual);
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES_F');
END;
/
```

- 일자 11개 × 카테고리 3개 → 33행

---

### GROUPING SETS — 한 번의 스캔으로 상세/소계/총계

```sql
SELECT sales_dt,
       category,
       SUM(amount) AS amt,
       GROUPING(sales_dt) AS g_dt,
       GROUPING(category) AS g_cat
FROM   SALES_F
GROUP  BY GROUPING SETS (
          (sales_dt, category),  -- 상세
          (sales_dt),            -- 일자 소계
          ()                     -- 전체합
        )
ORDER  BY sales_dt NULLS LAST, category NULLS LAST;
```

**작동 원리**
- 엔진이 내부적으로 “필요 그룹”을 동시에 계산한다.
- 원본을 **중복 스캔하지 않는다**.

#### GROUPING_ID로 소계 종류 “한 번에” 라벨링

```sql
SELECT sales_dt,
       category,
       SUM(amount) amt,
       GROUPING_ID(sales_dt, category) gid
FROM SALES_F
GROUP BY GROUPING SETS ((sales_dt, category), (sales_dt), ())
ORDER BY sales_dt NULLS LAST, category NULLS LAST;
```

`gid` 해석:
- 0: 상세
- 1: category가 NULL → 일자 소계
- 3: 둘 다 NULL → 전체합

(비트마스크 개념)

---

### ROLLUP / CUBE

#### ROLLUP: 계층적 소계

```sql
SELECT sales_dt, category, SUM(amount) amt
FROM SALES_F
GROUP BY ROLLUP(sales_dt, category)
ORDER BY sales_dt NULLS LAST, category NULLS LAST;
```

- `(sales_dt, category)` 상세
- `sales_dt` 소계
- 전체합

#### CUBE: 모든 조합 소계

```sql
SELECT sales_dt, category, SUM(amount) amt
FROM SALES_F
GROUP BY CUBE(sales_dt, category)
ORDER BY sales_dt NULLS LAST, category NULLS LAST;
```

- 상세 + sales_dt별 + category별 + 전체합

---

### UNION ALL 복제형 — 언제 쓰나?

```sql
SELECT sales_dt, category, SUM(amount) amt
FROM (
  SELECT sales_dt, category, amount FROM SALES_F
  UNION ALL
  SELECT sales_dt, NULL, amount FROM SALES_F
  UNION ALL
  SELECT NULL, NULL, amount FROM SALES_F
)
GROUP BY sales_dt, category
ORDER BY sales_dt NULLS LAST, category NULLS LAST;
```

**장점**
- 소계 규칙이 매우 특수할 때 “직접 조합 설계”가 쉬움.

**단점**
- 원본 데이터를 **물리적으로 2~3배 흉내**냄 → 대량에서 I/O 증가.
- GROUPING SETS가 가능한 환경이면 거의 항상 GROUPING SETS가 낫다.

---

### 대용량 집계 튜닝의 기본

1) **집계 전 필터(프루닝)**
2) **사전집계 가능하면 사전집계**
3) **Hash Group By vs Sort Group By 선택**
4) **필요하면 요약 테이블/물리화**

- 조건이 선두 인덱스/파티션 키에 걸리면 **입력이 먼저 줄어** GROUP BY가 싸진다.
- A-Rows 기준으로 Group By 입력량이 크면 “사전집계로 줄일 방법이 없는가”를 먼저 본다.

---

## 4) 상호배타 조인 — “둘 중 하나만 매칭”을 보장/검출

### 스키마 & 샘플

```sql
DROP TABLE A_TAG PURGE;
DROP TABLE B_TAG PURGE;

CREATE TABLE A_TAG (KEY_ID NUMBER PRIMARY KEY, NOTE VARCHAR2(20));
CREATE TABLE B_TAG (KEY_ID NUMBER PRIMARY KEY, NOTE VARCHAR2(20));

INSERT INTO A_TAG VALUES(1,'A-only-1');
INSERT INTO A_TAG VALUES(2,'A-only-2');
INSERT INTO B_TAG VALUES(3,'B-only-3');
INSERT INTO B_TAG VALUES(4,'B-only-4');

-- 위배 케이스
INSERT INTO A_TAG VALUES(10,'A-dup');
INSERT INTO B_TAG VALUES(10,'B-dup');

COMMIT;
```

---

### FULL OUTER + 단독 필터

```sql
SELECT COALESCE(a.key_id, b.key_id) AS key_id,
       a.note AS a_note,
       b.note AS b_note
FROM   A_TAG a
FULL  OUTER JOIN B_TAG b
       ON b.key_id = a.key_id
WHERE  (a.key_id IS NULL AND b.key_id IS NOT NULL)
    OR (a.key_id IS NOT NULL AND b.key_id IS NULL);
```

- **양쪽 모두 존재(10)**는 걸러진다.
- **한쪽만 존재**하는 키가 남는다.

---

### XOR(배타적 OR) 집계형

```sql
SELECT k.key_id,
       MAX(CASE WHEN src='A' THEN note END) AS a_note,
       MAX(CASE WHEN src='B' THEN note END) AS b_note
FROM (
  SELECT key_id, note, 'A' src FROM A_TAG
  UNION ALL
  SELECT key_id, note, 'B' src FROM B_TAG
) k
GROUP BY k.key_id
HAVING COUNT(DISTINCT src) = 1;
```

**장점**
- 정렬/해시 **1번**으로 끝날 수 있어 대량에서 유리.

---

### 위배 목록(양쪽 다 있는 키)만 뽑기

```sql
SELECT key_id
FROM (
  SELECT key_id, 'A' src FROM A_TAG
  UNION ALL
  SELECT key_id, 'B' src FROM B_TAG
)
GROUP BY key_id
HAVING COUNT(DISTINCT src) = 2;
```

- “상호배타 위배 검출 리포트”에 자주 쓰인다.

---

### 설계적으로 상호배타를 강제하는 방법

조인으로 위배를 **검출**하는 것과,
모델로 위배를 **예방**하는 것은 다르다.

예) 단일 테이블에 소속을 저장:

```sql
CREATE TABLE TAG_OWNER(
  KEY_ID NUMBER PRIMARY KEY,
  OWNER_TYPE CHAR(1) CHECK (OWNER_TYPE IN ('A','B')),
  NOTE VARCHAR2(20)
);
```

- PK로 “하나만”을 강제한다.
- 조인은 이제 단순한 lookup이 된다.

---

## 5) Top-1 per key 조인 — “키별 최종 1건”을 뽑는 표준 루틴

### 스키마 & 샘플

```sql
DROP TABLE DOC PURGE;
CREATE TABLE DOC(
  DOC_ID    NUMBER       NOT NULL,
  VER       NUMBER       NOT NULL,
  STATUS    VARCHAR2(10) NOT NULL,
  UPDATE_DT DATE         NOT NULL,
  CONSTRAINT PK_DOC PRIMARY KEY (DOC_ID, VER)
);

INSERT INTO DOC VALUES(100,1,'DRAFT',  DATE '2024-01-10');
INSERT INTO DOC VALUES(100,2,'REVIEW', DATE '2024-01-15');
INSERT INTO DOC VALUES(100,3,'FINAL',  DATE '2024-01-20');
INSERT INTO DOC VALUES(200,1,'DRAFT',  DATE '2024-02-01');
INSERT INTO DOC VALUES(200,2,'FINAL',  DATE '2024-02-05');
INSERT INTO DOC VALUES(300,1,'DRAFT',  DATE '2024-03-01');

COMMIT;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DOC');
END;
/
```

---

### ROW_NUMBER() 윈도 방식

```sql
WITH T AS (
  SELECT d.*,
         ROW_NUMBER() OVER(
           PARTITION BY doc_id
           ORDER BY ver DESC, update_dt DESC
         ) AS rn
  FROM DOC d
)
SELECT doc_id, ver, status, update_dt
FROM T
WHERE rn = 1
ORDER BY doc_id;
```

**표준 이유**
- 최종 선정 규칙이 `ORDER BY`로 **명확하다.**
- 동률 처리(버전 같을 때 최신 수정일 등)를 확실히 정의할 수 있다.

---

### KEEP(DENSE_RANK LAST) 방식 — 집계 1번으로 최종값

```sql
SELECT doc_id,
       MAX(ver) KEEP (DENSE_RANK LAST ORDER BY ver, update_dt) AS last_ver,
       MAX(status) KEEP (DENSE_RANK LAST ORDER BY ver, update_dt) AS last_status,
       MAX(update_dt) KEEP (DENSE_RANK LAST ORDER BY ver, update_dt) AS last_dt
FROM DOC
GROUP BY doc_id
ORDER BY doc_id;
```

**특징**
- “키별 최종값”만 필요할 때는 **매우 간단/빠름**.
- 최종행 전체 컬럼이 필요하면 윈도 방식이 더 편하다.

---

### LATERAL/APPLY Top-1 — 인덱스 역순 접근에 강함

```sql
DROP TABLE DOC_OWNER PURGE;
CREATE TABLE DOC_OWNER (DOC_ID NUMBER PRIMARY KEY, OWNER_ID NUMBER);
INSERT INTO DOC_OWNER VALUES(100, 1);
INSERT INTO DOC_OWNER VALUES(200, 3);
INSERT INTO DOC_OWNER VALUES(300, 5);
COMMIT;

SELECT o.owner_id, v.doc_id, v.ver, v.status, v.update_dt
FROM   DOC_OWNER o
CROSS  APPLY (
  SELECT /*+ INDEX_DESC(d PK_DOC) */
         d.doc_id, d.ver, d.status, d.update_dt
  FROM   DOC d
  WHERE  d.doc_id = o.doc_id
  ORDER  BY ver DESC, update_dt DESC
  FETCH  FIRST 1 ROWS ONLY
) v
ORDER BY o.owner_id;
```

**언제 강력한가?**
- 바깥 키가 **소량(예: 1만 이하)**이고,
- 내부 테이블이 **(key, ver DESC)** 인덱스를 타면
  각 키마다 **인덱스에서 1건만 뽑고 끝**난다.

---

### Top-1 per key 실무 실수

1) **MAX(ver)만 구하고 다른 컬럼을 그냥 SELECT**
- 최종 버전과 컬럼이 **서로 다른 행**이 될 수 있음.

2) **동률 규칙이 없는 ORDER BY**
- 버전이 같을 때 어떤 행을 최종으로 잡는지 불명확 → 결과 흔들림.

3) **대량에서 인덱스 없이 APPLY 남발**
- 바깥 키가 수십만이면 APPLY가 반복 조회가 되어 느려질 수 있음 → 윈도/집계 방식이 유리.

---

## 6) 종합 시나리오 — 여러 테크닉을 한 번에 엮기

> “상품별 일자 판매에 그 날의 유효 가격을 붙이고,
> 카테고리별 소계/전체합을 함께내며,
> 상품 등급 이력에서 최종 1건만 붙인다.
> A/B 태깅은 상호배타 위반을 제거한다.”

### 가격 선분 + 판매일 기간 조인

```sql
WITH PRICE_SEG AS (
  SELECT prod_id,
         evt_dt AS start_dt,
         LEAD(evt_dt,1,DATE '9999-12-31')
           OVER(PARTITION BY prod_id ORDER BY evt_dt) AS end_dt,
         new_price
  FROM PRICE_EVENT
),
SALE_PRICE AS (
  SELECT s.sales_dt, s.prod_id, s.qty,
         p.new_price,
         s.qty * p.new_price AS revenue
  FROM   SALES_D s
  JOIN   PRICE_SEG p
    ON   p.prod_id = s.prod_id
   AND   s.sales_dt >= p.start_dt
   AND   s.sales_dt <  p.end_dt
)
SELECT *
FROM   SALE_PRICE
ORDER  BY sales_dt;
```

### 카테고리 소계/전체합을 GSETS로 한 번에

```sql
WITH SALE_CAT AS (
  SELECT sp.sales_dt,
         pr.category,
         sp.revenue
  FROM   SALE_PRICE sp
  JOIN   PROD pr ON pr.prod_id = sp.prod_id
)
SELECT sales_dt, category, SUM(revenue) AS amt,
       GROUPING_ID(sales_dt, category) AS gid
FROM   SALE_CAT
GROUP  BY GROUPING SETS ((sales_dt, category), (sales_dt), ())
ORDER  BY sales_dt NULLS LAST, category NULLS LAST;
```

### 등급 이력에서 최종 1건만 붙이기

```sql
WITH LAST_GRADE AS (
  SELECT prod_id, grade
  FROM (
    SELECT g.*,
           ROW_NUMBER() OVER(
             PARTITION BY prod_id
             ORDER BY evt_dt DESC
           ) rn
    FROM GRADE_EVT g
  )
  WHERE rn = 1
),
SALE_CAT AS (
  SELECT sp.sales_dt, pr.prod_id, pr.category, sp.revenue
  FROM   SALE_PRICE sp
  JOIN   PROD pr ON pr.prod_id = sp.prod_id
)
SELECT sc.sales_dt, sc.category,
       lg.grade,
       SUM(sc.revenue) amt
FROM   SALE_CAT sc
LEFT   JOIN LAST_GRADE lg ON lg.prod_id = sc.prod_id
GROUP  BY sc.sales_dt, sc.category, lg.grade
ORDER  BY sc.sales_dt, sc.category;
```

### 상호배타 위반 제거

```sql
WITH EXCL AS (
  SELECT key_id, COUNT(DISTINCT src) kinds
  FROM (
    SELECT key_id, 'A' src FROM A_TAG
    UNION ALL
    SELECT key_id, 'B' src FROM B_TAG
  )
  GROUP BY key_id
)
SELECT r.*
FROM   (<이전 결과>) r
JOIN   EXCL e ON e.key_id = r.prod_id
WHERE  e.kinds = 1;
```

---

## 7) 실행계획·성능 확인 루틴

1) **원본 입력량이 줄어드는가?**
   - `HASH GROUP BY` 앞 입력 A-Rows가 작아졌는지
   - `WINDOW SORT`가 축소본 기준인지

2) **기간 조인이 의도대로 되었는가?**
   - `FILTER`가 아닌 `HASH JOIN`/`NL`로 안정됐는지
   - `PREDICATE INFORMATION`에서
     `sales_dt >= start_dt AND sales_dt < end_dt`가 access/filter로 어디에 적용됐는지

3) **소계가 “한 번 스캔”으로 나오는가?**
   - `GROUPING SETS`가 내부에서 `GROUP BY` 1번으로 처리되는지
   - UNION ALL 복제라면 원본 스캔이 2~3배로 늘어난 게 맞는지

4) **Top-1 선정이 인덱스로 단축되었는가?**
   - APPLY 사용 시 내부에서 `INDEX DESC` + `STOPKEY`로 1건만 읽는지

---

## 8) 자주 나오는 질문(FAQ)

### Q1. “누적을 꼭 조인으로 해야 한다면?”

- 사전집계한 결과(D)끼리 조인하는 것이 최소 피해.
- 그래도 행 수가 커지면 부담이 남는다.
  가능하면 윈도 함수로 바꾸는 것이 정석이다.

### Q2. “기간 조인에서 end_dt를 다음 이벤트 날짜로 잡는 이유는?”

- `[start, next_start)` 규약이 가장 깔끔하고 중복이 없다.
- `next_start-1` 같은 계산은 시간 단위가 바뀌면 깨진다.

### Q3. “소계 행을 보기 좋게 라벨링하려면?”

```sql
SELECT CASE
         WHEN GROUPING_ID(sales_dt, category)=0 THEN 'DETAIL'
         WHEN GROUPING_ID(sales_dt, category)=1 THEN 'DAY_SUBTOTAL'
         WHEN GROUPING_ID(sales_dt, category)=3 THEN 'GRAND_TOTAL'
       END AS row_type,
       sales_dt, category, SUM(amount) amt
FROM SALES_F
GROUP BY GROUPING SETS ((sales_dt, category), (sales_dt), ())
ORDER BY sales_dt NULLS LAST, category NULLS LAST;
```

### Q4. “Top-1 per key에서 동률이 많으면?”

- `ROW_NUMBER`의 ORDER BY에 **결정 규칙을 더 넣는다.**
- 최종적으로도 동률이면 `MIN(rowid)` 같은 안정 규칙을 추가.

---

## 9) 최종 체크리스트

- [ ] 누적합은 **사전집계 → 윈도 SUM**
- [ ] 기간 이력은 **LEAD로 선분화 → 포인트/선분 조인**
- [ ] 선분 교집합은 **겹침 판정 + GREATEST/LEAST**
- [ ] 소계/총계는 **GROUPING SETS/ROLLUP/CUBE**
- [ ] 상호배타는 **FULL OUTER 단독필터** 또는 **XOR 집계**
- [ ] 최종 1건은 **ROW_NUMBER Top-1** 또는 **KEEP LAST**
- [ ] 대량이면 **입력 축소(프루닝/사전집계)**가 1순위
- [ ] 결과/성능은 항상 **실측 플랜**으로 판정

---

### 결론

이 글의 모든 테크닉은 결국 한 문장으로 귀결된다.

> “조인 자체가 목적이 아니라, **입력을 먼저 줄이고(사전집계/프루닝/선분화)**
> **의미를 보존하면서 가장 싼 형태로 결합**하는 것이 목적이다.”

누적/기간/소계/상호배타/Top-1은 실무 리포팅과 이력처리의 핵심 패턴이다.
각 패턴의 **정석 형태와 예외(실수 지점)**만 확실히 잡아두면,
대부분의 복잡한 SQL은 “조합 문제”로 단순화되어 튜닝이 쉬워진다.
