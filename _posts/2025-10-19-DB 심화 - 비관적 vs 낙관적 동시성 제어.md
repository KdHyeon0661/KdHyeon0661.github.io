---
layout: post
title: DB 심화 - 비관적 vs 낙관적 동시성 제어
date: 2025-10-19 19:25:23 +0900
category: DB 심화
---
# Oracle 비관적(Pessimistic) vs 낙관적(Optimistic) 동시성 제어 (19c 기준, 실전 중심)

> 목표
> - **비관적 락 기반(2PL)** 과 **낙관적 검증 기반(OCC)** 의 **개념/차이/장단점**을 명확히 이해합니다.
> - **Oracle** 중심으로 `SELECT ... FOR UPDATE`, `NOWAIT`/`SKIP LOCKED`, ITL/락 대기 등 **비관적** 패턴의 실제 동작과 주의점을 살펴봅니다.
> - **낙관적** 패턴(버전 컬럼/해시/타임스탬프)을 활용한 **Lost Update** 방지 및 재시도 로직 설계 방법을 배웁니다.
> - **Write Skew**, **팬텀 리드** 등 복잡한 동시성 문제와 **분산 트랜잭션**에서의 선택 기준, **하이브리드 전략**을 논의합니다.
> - **진단 SQL**, **대기 이벤트**, **실전 체크리스트**를 제공합니다.

---

## 핵심 개념 비교: 비관적 vs 낙관적 제어

동시성 제어의 두 가지 근본 철학은 다음과 같습니다.

- **비관적 동시성 제어 (Pessimistic Concurrency Control)**
    - **기본 가정**: "**데이터 충돌이 자주 발생할 것이다.**"
    - **접근 방식**: 데이터를 읽거나 수정하기 **전에 미리 잠금(Lock)을 획득**하여 다른 트랜잭션의 간섭을 사전에 차단합니다.
    - **Oracle 구현 수단**: `SELECT ... FOR UPDATE`, DML 자동 행 잠금, `enq: TX` 락.

- **낙관적 동시성 제어 (Optimistic Concurrency Control, OCC)**
    - **기본 가정**: "**데이터 충돌은 드물게 발생할 것이다.**"
    - **접근 방식**: 락을 사용하지 않고 데이터를 읽고 수정합니다. **커밋 직전에** 다른 트랜잭션에 의해 해당 데이터가 변경되었는지 **검증(Validation)** 합니다. 충돌이 감지되면 트랜잭션을 롤백하고 재시도합니다.
    - **Oracle 구현 수단**: 버전 컬럼(`version_number`), 타임스탬프, 해시값을 WHERE 조건에 포함한 `UPDATE` 문.

**간단한 비유:**
- **비관적 접근**은 도서관에서 책을 빌리기 전에 **예약(락)** 을 하는 것과 같습니다. 다른 사람이 사용하지 못하게 미리 확보합니다.
- **낙관적 접근**은 책을 가져가서 읽고, 반납할 때만 "내가 읽는 동안 누가 이 책을 건드리지 않았나?" 하고 확인하는 것과 같습니다. 문제가 있으면 처음부터 다시 읽어야 합니다.

---

## 이해해야 할 동시성 문제의 기본 형태

적절한 제어 방식을 선택하기 전에, 방지해야 할 문제들을 명확히 이해해야 합니다.

- **Lost Update (갱신 손실)**: 두 트랜잭션이 동일한 데이터를 읽은 후 각자 변경을 적용할 때, 먼저 적용한 변경사항이 나중에 적용된 변경에 의해 **덮어써져 사라지는** 현상.
- **Non-Repeatable Read (반복 불가능 읽기)**: 한 트랜잭션 내에서 동일한 질의를 두 번 수행했을 때, 그 사이에 다른 트랜잭션의 커밋으로 인해 **조회 결과가 달라지는** 현상.
- **Phantom Read (팬텀 리드)**: 한 트랜잭션 내에서 동일한 조건으로 조회를 두 번 수행했을 때, 처음에는 없던 새로운 행이 다른 트랜잭션의 삽입으로 인해 **두 번째 조회에 나타나는** 현상.
- **Write Skew (쓰기 편향)**: 두 트랜잭션이 서로 다른 데이터를 읽고 수정함으로써, 전체적으로 봤을 때 **시스템의 전역 불변식(Global Invariant)을 위반하게 되는** 현상. (예: 두 의사가 동시에 휴가를 신청하여 당직 의사가 없게 됨)

비관적과 낙관적 방식은 이러한 이상 현상을 서로 다른 메커니즘으로 방지합니다.

---

## 비관적 동시성 제어 상세: Oracle에서의 구현과 운영

### 핵심 메커니즘: 2단계 잠금 (Two-Phase Locking, 2PL)
비관적 제어의 이론적 기반은 2PL입니다. 모든 트랜잭션이 **락 확장 단계(Growing Phase)** 에서만 새로운 락을 획득하고, **락 해제 단계(Shrinking Phase)** 에서는 락만 해제합니다. 가장 흔한 구현인 **Strict 2PL**은 쓰기 락(X Lock)을 **트랜잭션이 종료(커밋/롤백)될 때까지** 유지하여 복잡한 회복 로직을 단순화합니다.

### Oracle의 비관적 제어 수단
1.  **명시적 잠금 (`SELECT ... FOR UPDATE`)**: 쿼리 시점에 조건에 맞는 행에 대해 배타적 잠금을 획득합니다. 다른 세션은 해당 행을 갱신하거나 `FOR UPDATE`로 읽을 수 없습니다.
2.  **암시적 잠금**: 모든 `INSERT`, `UPDATE`, `DELETE`, `MERGE`(갱신 시) 문은 영향을 받는 행에 대해 자동으로 배타적 행 잠금을 설정합니다.
3.  **테이블 수준 잠금 (`LOCK TABLE ...`)**: 전체 테이블을 잠급니다. 주의해서 사용해야 합니다.

### 실전 예제: Lost Update 방지
```sql
-- 세션 A
SELECT qty INTO v_current_qty FROM inventory WHERE product_id = 100 FOR UPDATE;
-- 계산 로직 수행 (v_current_qty - 1)
UPDATE inventory SET qty = v_new_qty WHERE product_id = 100;
COMMIT;

-- 세션 B (세션 A의 트랜잭션 종료 전 동시 실행)
-- 아래 쿼리는 세션 A가 COMMIT할 때까지 대기 상태가 됩니다.
UPDATE inventory SET qty = qty - 2 WHERE product_id = 100;
```
세션 B는 `enq: TX - row lock contention` 이벤트를 대기하며, 세션 A의 커밋을 기다립니다. 이를 통해 갱신 손실이 방지됩니다.

### 대기 전략: `NOWAIT`, `WAIT`, `SKIP LOCKED`
- `SELECT ... FOR UPDATE NOWAIT`: 대상 행이 이미 잠겨 있다면 즉시 `ORA-00054` 에러를 발생시킵니다. 사용자에게 빠른 피드백이 필요할 때 유용합니다.
- `SELECT ... FOR UPDATE WAIT n`: 최대 `n`초 동안 락 획득을 시도합니다. 시간 초과 시 에러를 발생시킵니다.
- `SELECT ... FOR UPDATE SKIP LOCKED`: 이미 잠겨 있는 행은 결과 집합에서 제외하고, 잠금 가능한 행만 즉시 반환합니다. **작업 큐(Job Queue)를 여러 워커가 병렬로 처리할 때** 교착 상태 없이 작업을 분배하는 데 아주 효과적입니다.

```sql
-- 작업 큐에서 'READY' 상태 작업 10개를 가져와 'PROCESSING'으로 변경
SELECT * FROM job_queue
 WHERE status = 'READY'
   AND next_run_time <= SYSDATE
   FOR UPDATE SKIP LOCKED
  FETCH FIRST 10 ROWS ONLY;
```

### 주의사항: 교착 상태(Deadlock)와 ITL 경합
- **교착 상태**: 두 트랜잭션이 각자 보유한 락을 서로 기다리며 무한히 대기하는 상태입니다. Oracle은 데드락 감지기가 이를 탐지하고, 한 트랜잭션을 `ORA-00060` 에러와 함께 롤백시켜 다른 트랜잭션이 진행할 수 있게 합니다.
    - **예방법**: 트랜잭션이 항상 **동일한 순서로 오브젝트에 잠금을 걸도록** 애플리케이션을 설계하는 것이 가장 효과적입니다.
- **ITL 경합**: 하나의 데이터 블록 내에서 너무 많은 트랜잭션이 동시에 행을 갱신하려 하면, 블록 헤더의 ITL 슬롯이 부족해져 `enq: TX - allocate ITL entry` 대기가 발생할 수 있습니다.
    - **해결법**: `CREATE/ALTER TABLE ... INITRANS 8` 와 같이 초기 트랜잭션 슬롯 수를 증가시키거나, `PCTFREE` 값을 높여 블록에 여유 공간을 확보합니다.

---

## 낙관적 동시성 제어 상세: 검증과 재시도 패턴

### 핵심 메커니즘: 읽기-검증-쓰기
낙관적 제어는 락 대신 **버전 정보**를 사용합니다. 일반적인 플로우는 다음과 같습니다.
1.  **읽기 (Read)**: 데이터와 함께 그 시점의 **버전 식별자**(예: 버전 번호, 타임스탬프)를 읽어 저장합니다.
2.  **수정 (Modify)**: 애플리케이션 로직에서 데이터를 수정합니다.
3.  **검증 및 쓰기 (Validate & Write)**: 데이터를 업데이트할 때, WHERE 조건에 **읽어둔 버전 식별자가 아직 동일한지**를 포함시킵니다. 업데이트 영향을 받은 행 수(`SQL%ROWCOUNT`)가 1이면 성공, 0이면 다른 트랜잭션이 먼저 수정한 것이므로 충돌로 판단합니다.
4.  **재시도 (Retry)**: 충돌 발생 시, 애플리케이션은 트랜잭션을 롤백하고 로직을 처음부터 재시도합니다.

### Oracle에서의 낙관적 제어 구현
가장 일반적인 방법은 **버전 번호 컬럼**을 추가하는 것입니다.

```sql
-- 버전 컬럼이 있는 테이블
CREATE TABLE customer_profile (
    customer_id NUMBER PRIMARY KEY,
    email VARCHAR2(100),
    preferences CLOB,
    version NUMBER DEFAULT 0 NOT NULL
);

-- 애플리케이션 로직 (PL/SQL 예시)
DECLARE
    l_old_version NUMBER;
    l_old_email VARCHAR2(100);
    l_new_email VARCHAR2(100) := 'new.email@example.com';
BEGIN
    -- 1. 읽기: 현재 값과 버전을 가져옴
    SELECT email, version INTO l_old_email, l_old_version
    FROM customer_profile WHERE customer_id = 123;

    -- 2. 검증 및 쓰기: 버전이 변경되지 않았는지 확인하며 업데이트
    UPDATE customer_profile
       SET email = l_new_email,
           version = version + 1
     WHERE customer_id = 123
       AND version = l_old_version; -- 핵심 조건

    IF SQL%ROWCOUNT = 0 THEN
        -- 3. 충돌 처리: 다른 트랜잭션이 이미 수정함
        RAISE_APPLICATION_ERROR(-20001, '데이터가 변경되었습니다. 다시 시도해 주세요.');
        -- 또는 재시도 로직을 태움
    ELSE
        COMMIT;
    END IF;
END;
/
```

### 재시도 로직 설계의 중요성
낙관적 제어에서 충돌은 예상된 사건입니다. 따라서 **견고한 재시도 메커니즘**이 필수적입니다.
- **최대 재시도 횟수**: 무한 재시도를 방지합니다.
- **지수 백오프(Exponential Backoff)**: 재시도 간 대기 시간을 점진적으로 증가시켜 시스템에 부하를 완화합니다. (예: 50ms, 100ms, 200ms ...)
- **멱등성(Idempotency) 보장**: 재시도 과정에서 동일한 작업이 두 번 적용되어도 최종 결과가 동일하도록 로직을 설계해야 합니다. 이는 특히 외부 시스템 호출이 포함될 때 중요합니다.

### 낙관적 제어의 장단점
- **장점**:
    - **락 경합이 거의 없어** 읽기 위주의 워크로드에서 성능이 뛰어납니다.
    - **교착 상태 발생 가능성이 현저히 낮습니다**.
    - 장시간 읽기 트랜잭션이 쓰기 트랜잭션을 차단하지 않습니다.
- **단점**:
    - 충돌이 빈번한 **쓰기 집중 워크로드**에서는 재시도 오버헤드로 인해 성능이 급격히 저하될 수 있습니다.
    - 복잡한 비즈니스 로직의 재시도는 구현하기 어려울 수 있습니다.
    - `COMMIT` 시점에야 최종 실패를 알 수 있으므로, 사용자 경관에 지연된 피드백이 발생할 수 있습니다.

---

## 비관적 vs 낙관적: 실전 선택 가이드

어떤 방식을 선택해야 할지는 다음 요소들을 종합적으로 판단해야 합니다.

| 고려 요소 | 비관적 제어를 선호하는 경우 | 낙관적 제어를 선호하는 경우 |
| :--- | :--- | :--- |
| **데이터 충돌 빈도** | 높음 (예: 티켓팅, 좌석 예매) | 낮음 (예: 사용자 프로필 수정) |
| **읽기 대 쓰기 비율** | 쓰기 비중이 높음 | 읽기 비중이 매우 높음 |
| **트랜잭션 지속 시간** | 짧음 (락 점유 시간을 최소화) | 비교적 긺 (긴 읽기/계산 단계 포함) |
| **데이터 중요도** | 높음, 갱신 손실이 치명적 (예: 금융, 재고) | 상대적으로 낮음, 충돌 시 재시도 가능 |
| **사용자 경험 요구** | 즉시적인 락 점유 및 실패 피드백 필요 | 약간의 지연된 충돌 알림이 허용됨 |
| **시스템 아키텍처** | 단일 모놀리식 데이터베이스 | 마이크로서비스, 분산 캐시 사용 환경 |

### 복합적 문제: Write Skew와의 전쟁
**Write Skew**는 낙관적 제어나 특정 격리 수준(Read Committed, Snapshot)에서 더 두드러지는 문제입니다. 서로 다른 데이터를 수정함으로써 전역 규칙이 깨지는 것을 방지하려면, 데이터베이스 수준에서 강제해야 합니다.

**해결 전략:**
1.  **데이터베이스 제약 조건**: 가능하다면 `CHECK` 제약이나 **물질화된 뷰(Materialized View)** 를 활용해 비즈니스 규칙을 DB 내에 구현합니다.
2.  **직렬화 격리 수준(Serializable)**: Oracle의 Serializable 격리 수준은 이 문제를 방지하지만, `ORA-08177: Cannot serialize access` 에러와 재시도 로직이 필요합니다.
3.  **의도적 잠금(Intentional Locking)**: 전역 규칙과 관련된 **'락 테이블'** 의 특정 행을 `SELECT ... FOR UPDATE`로 잠금함으로써, 해당 규칙에 대한 수정을 직렬화합니다.
    ```sql
    -- '한 부서당 최소 1명의 관리자' 규칙을 위한 락
    SELECT 1 FROM dept_lock WHERE dept_id = :dept_id FOR UPDATE;
    -- 이후 해당 부서의 관리자 정보를 수정
    ```

---

## 하이브리드 전략: 현실 세계의 최적 해법

순수한 비관적 또는 낙관적 접근법만으로는 복잡한 애플리케이션의 요구를 충족시키기 어렵습니다. 대부분의 성공적인 시스템은 **하이브리드 접근법**을 사용합니다.

1.  **핵심 자원은 비관적, 주변 자원은 낙관적**
    - 예: **쇼핑 카트**의 재고 수량은 `SELECT ... FOR UPDATE NOWAIT`로 보호하고, 상품 설명이나 리뷰 카운터는 버전 컬럼을 사용합니다.

2.  **긴 트랜잭션의 최종 단계에서만 비관적 검사**
    - 복잡한 주문 생성 로직(읽기/계산 많음)은 낙관적으로 진행하다가, 최종 커밋 직전에 핵심 재고 행에 대해 `FOR UPDATE NOWAIT`를 시도합니다. 실패하면 낙관적 충돌로 처리합니다.

3.  **`SKIP LOCKED`를 활용한 낙관적 분산 처리**
    - 작업 큐를 여러 컨슈머가 `SKIP LOCKED`로 안전하게 가져가 처리하는 패턴은, 락을 사용하지만 교착 상태 없이 병렬성을 극대화하는 '낙관적 분산'의 좋은 예입니다.

---

## 모니터링과 진단

문제가 발생했을 때 원인을 빠르게 찾을 수 있어야 합니다.

```sql
-- 1. 현재 락 대기 세션 확인
SELECT s.sid, s.serial#, s.username, s.event, s.state,
       s.seconds_in_wait, s.blocking_session, s.sql_id
FROM   v$session s
WHERE  s.event LIKE 'enq: TX%'
   OR  s.state = 'WAITING' AND s.wait_class = 'Application';

-- 2. 세그먼트 수준 경합 통계 (핫 블록, ITL)
SELECT owner, object_name, object_type, statistic_name, value
FROM   v$segment_statistics
WHERE  statistic_name IN ('buffer busy waits', 'ITL waits')
   AND value > 0
ORDER BY value DESC;

-- 3. 특정 세션이 보유 중인 락과 대기 중인 락
SELECT sid, type, id1, id2, lmode, request, block
FROM   v$lock
WHERE  sid IN (&세션_SID, &차단_세션_SID)
ORDER BY sid, type;
```

**관측 포인트:**
- **비관적 제어 문제**: 주로 `enq: TX - row lock contention`, `buffer busy waits`, `enq: TX - allocate ITL entry` 이벤트에서 나타납니다.
- **낙관적 제어 문제**: 데이터베이스 대기 이벤트로는 잘 나타나지 않습니다. 대신 **애플리케이션 로그**에서 "충돌" 또는 "재시도" 로그의 빈도와, 업데이트 실패(`SQL%ROWCOUNT = 0`) 비율을 모니터링해야 합니다.

---

## 결론: 맥락에 맞는 전략의 선택

비관적 동시성 제어와 낙관적 동시성 제어는 우열을 가릴 수 없는, 각자의 장단점이 뚜렷한 패러다임입니다.

**비관적 제어**는 "미리 방패를 든다"는 접근으로, 충돌 가능성이 높고 그 비용이 클 때 확실한 안전장치를 제공합니다. Oracle의 견고한 락 메커니즘과 `FOR UPDATE` 구문은 이를 잘 지원합니다. 그러나 이 방패의 무게인 **락 경합과 교착 상태의 위험**은 항상 염두에 두어야 합니다.

**낙관적 제어**는 "신뢰하되, 확인하라"는 접근으로, 충돌이 드문 환경에서 뛰어난 성능과 확장성을 보여줍니다. 버전 컬럼과 재시도 로직은 이를 실현하는 핵심 도구입니다. 하지만 이 방법의 성공은 **충돌 빈도를 정확히 예측하고, 견고한 재시도 및 에러 처리 로직을 구축하는 데** 달려 있습니다.

실제 시스템에서는 이분법적 선택보다는 **하이브리드 접근법**이 더 현실적입니다. 시스템의 다른 부분에 대해 서로 다른 전략을 적용하거나, 하나의 트랜잭션 흐름 내에서 두 방식을 조합하여 사용할 수 있습니다. 가장 중요한 것은, 자신의 애플리케이션의 **데이터 접근 패턴, 비즈니스 중요도, 성능 요구사항**을 깊이 이해하고, 그에 맞춰 적절한 동시성 제어 전략을 설계하고, 지속적으로 모니터링하며 조정해 나가는 것입니다. 동시성 제어는 단순한 기술 선택이 아니라, 시스템의 신뢰성과 성능을 결정하는 근본적인 설계 결정입니다.