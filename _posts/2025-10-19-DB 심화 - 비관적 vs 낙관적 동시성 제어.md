---
layout: post
title: DB 심화 - 비관적 vs 낙관적 동시성 제어
date: 2025-10-19 19:25:23 +0900
category: DB 심화
---
# **비관적(Pessimistic) vs 낙관적(Optimistic) 동시성 제어** 완전 가이드  
— 원리, 알고리즘, 오라클 중심 실무 시나리오/코드, 튜닝·모니터링까지

> 목표  
> - **비관적 락 기반(2PL/Strict 2PL)** 과 **낙관적 검증 기반(OCC)** 의 **개념/차이/장단점**을 그림처럼 이해  
> - **Oracle** 중심으로 `SELECT ... FOR UPDATE`, `NOWAIT`/`SKIP LOCKED`, ITL/락 대기, 데드락 등 **비관적** 패턴의 실제 동작과 함정  
> - **낙관적** 패턴(버전 컬럼/해시/타임스탬프/ETag)로 **Lost Update** 방지, 재시도 로직/멱등성 설계  
> - **Write Skew**, **팬텀**, **분산 트랜잭션**에서의 선택 기준과 **하이브리드 전략**  
> - **진단 SQL**, **대기 이벤트**, **성능 체크리스트** 제공

---

## 0. 한눈 요약

- **비관적 제어**: “**충돌이 날 것**이라 가정 → **미리 잠그고** 작업”  
  - 수단: **락(S/X, 행/테이블, 범위)**, **2PL(획득→해제)**  
  - 장점: 런타임 **충돌/재시도 적음**.  
  - 단점: **락 대기/교착**, 처리량 저하 가능.
- **낙관적 제어(OCC)**: “**충돌이 드물다** 가정 → **먼저 읽고 작업 → 커밋 직전 검증**”  
  - 수단: **버전 컬럼/체크섬/타임스탬프**, **CAS 조건 업데이트**  
  - 장점: **락 경합 낮음**, 읽기 많은 워크로드에 효율적.  
  - 단점: **검증 실패→재시도 비용**, 쓰기 경합 높을수록 불리.

---

## 1. 동시성 문제의 원형: Lost Update / Non-Repeatable / Phantom / Write-Skew

- **Lost Update**: 서로가 **옛 값**을 읽고 **덮어쓰기**, 먼저 쓴 변경 유실.  
- **Non-Repeatable Read**: 같은 행을 트랜잭션 내 **다시 읽었더니 값이 바뀜**.  
- **Phantom Read**: 같은 조건으로 **행 수가 달라짐**(INSERT/DELETE).  
- **Write Skew**: 서로 **다른 행**을 변경해 **전역 제약**을 침해(스냅샷 격리에서 흔함).

비관적/낙관적 방식은 **이들 이상을 다루는 규율**이 다르다.

---

## 2. 비관적 동시성 제어 — 정의와 핵심 개념

### 2.1 정의
- **갱신 대상**(또는 범위)을 **작업 전에 잠금**(X/범위락)으로 보호.  
- **2PL(2-Phase Locking)**: 락 **획득 증가 단계** → 커밋/롤백 시 **일괄 해제**.  
  - **Strict 2PL**: X락은 **커밋까지 유지**(회복 간단, 흔한 구현).

### 2.2 Oracle에서의 주요 수단
- `SELECT ... FOR UPDATE [NOWAIT | WAIT n | SKIP LOCKED]`  
- DML 시 **행 수준 TX 락** 자동 취득.  
- **ITL(Interested Transaction List)**/버퍼 pin/`enq: TX - row lock contention` 대기.  
- 범위 잠금(팬텀 차단)은 DBMS별 차이. Oracle은 **Serializable**에서 **충돌 시 실패** 전략(범위락 자체는 제한적).

### 2.3 타임라인(일반 UPDATE)
1) **Consistent 읽기**로 후보 행 식별 →  
2) **Current** 로 행 잠금(X) 및 ITL 슬롯 확보 →  
3) 변경, 커밋 시 **LGWR flush**.

---

## 3. 비관적 제어 — 실전 예제 & 패턴

### 3.1 Lost Update 방지: `SELECT ... FOR UPDATE`
```sql
-- 준비
DROP TABLE t_inv PURGE;
CREATE TABLE t_inv (id NUMBER PRIMARY KEY, qty NUMBER NOT NULL);
INSERT INTO t_inv VALUES (1, 10);
COMMIT;

-- 세션 A: 갱신 대상 잠금(현재 읽기 + 행 락)
SELECT qty FROM t_inv WHERE id = 1 FOR UPDATE;

-- 세션 B: 동일 행 갱신 시도 → A가 커밋할 때까지 대기
UPDATE t_inv SET qty = qty - 3 WHERE id = 1;

-- 세션 A: 계산 후 갱신
UPDATE t_inv SET qty = qty - 2 WHERE id = 1;
COMMIT;         -- B는 여기서 진행됨(순서 보장)
```

**포인트**  
- `FOR UPDATE`는 **현재 버전**을 읽으며 **행 락**을 즉시 취득해 **Lost Update 차단**.  
- 대기는 **`enq: TX - row lock contention`** 으로 관측.

### 3.2 대기 전략: `NOWAIT`/`WAIT`/`SKIP LOCKED`
```sql
-- NOWAIT: 잠겨 있으면 즉시 ORA-00054
SELECT ... FOR UPDATE NOWAIT;

-- WAIT n: 최대 n초 대기
SELECT ... FOR UPDATE WAIT 5;

-- SKIP LOCKED: 잠긴 행은 건너뛰고 즉시 반환 → 작업 분할 큐 패턴
SELECT id
FROM   jobs
WHERE  status = 'READY'
FOR UPDATE SKIP LOCKED
FETCH FIRST 50 ROWS ONLY;
```
**사용처**  
- **큐/배치 워커**: `SKIP LOCKED`로 충돌 없이 **병렬 소비**.  
- **인터랙티브 화면**: `NOWAIT`로 빠른 실패 후 안내.

### 3.3 데드락(교착) 예시와 방지
```sql
-- 세션 A
UPDATE t_inv SET qty = qty - 1 WHERE id = 1; -- X락(id=1)
-- 세션 B
UPDATE t_inv SET qty = qty - 1 WHERE id = 2; -- X락(id=2)

-- A가 id=2를, B가 id=1을 추가로 잠그려 하면 교착
-- → Oracle이 한 쪽을 ORA-00060으로 종료
```
**방지**: **항상 같은 순서로 잠금**, **트랜잭션 짧게**, **범위를 축소**, **지연 재시도**.

### 3.4 ITL 부족과 핫블록
동시에 같은 블록을 많이 갱신하면 **ITL 부족**(`enq: TX - allocate ITL entry`) 및 **`buffer busy waits`** 발생.  
**대응**: `INITRANS`↑, `PCTFREE`↑(헤더 여유), 키 분산/파티셔닝.

---

## 4. 낙관적 동시성 제어(OCC) — 정의와 핵심 개념

### 4.1 정의
- **락 없이**(또는 최소화) **읽고** 작업 → **커밋 직전 검증**으로 충돌 감지.  
- 검증 실패 시 **롤백/재시도**.

### 4.2 검증 수단(대표)
- **버전 컬럼 증가(ver)**  
- **타임스탬프/SCN**  
- **행 해시(중요 칼럼들의 checksum)**  
- **ETag/If-Match**(HTTP/REST)

### 4.3 알고리즘(개념)
1) Read: **스냅샷**과 **버전(또는 해시)** 획득  
2) Work: 앱에서 계산  
3) Validate & Write: **WHERE 조건**에 **버전 일치**를 포함한 `UPDATE`  
   - 영향 행 수=0 → **충돌** → **재시도**

---

## 5. 낙관적 제어 — 실전 예제 & 패턴(Oracle)

### 5.1 버전 컬럼 기반 OCC
```sql
-- 준비
DROP TABLE t_acc PURGE;
CREATE TABLE t_acc (
  id   NUMBER PRIMARY KEY,
  bal  NUMBER NOT NULL,
  ver  NUMBER NOT NULL DEFAULT 0
);
INSERT INTO t_acc VALUES (1, 100, 0);
COMMIT;

-- 애플리케이션 흐름
-- 1) 읽기
SELECT bal, ver FROM t_acc WHERE id = 1;    -- 예: 100, ver=0

-- 2) 계산(앱)
--    new_bal = bal + 25

-- 3) 검증+쓰기: 버전 일치 시만 갱신
UPDATE t_acc
   SET bal = bal + 25,
       ver = ver + 1
 WHERE id  = 1
   AND ver = 0;   -- 최초 읽은 ver

-- 4) 영향행 확인
--    0행이면 충돌 → 재시도 루프(최대 N회, 지수 백오프)
```

**장점**: 락 대기 없음, 읽기 많은 워크로드에 **고성능**.  
**단점**: **경합↑**이면 **재시도 비율↑** → 응답 분산/최악 지연 증가.

### 5.2 해시(Checksum) 기반 OCC
```sql
-- 중요 칼럼들로 해시(의사 코드)
SELECT ora_hash(bal || ':' || status) AS h, bal, status
FROM   t_acc WHERE id=1;

-- 업데이트
UPDATE t_acc
   SET bal = :new_bal, status = :new_status
 WHERE id  = 1
   AND ora_hash(bal || ':' || status) = :old_h;
```
**주의**: 해시 충돌 확률은 낮지만 0은 아님 → **버전 컬럼**이 더 선호됨.

### 5.3 MERGE와 OCC 결합(Upsert 케이스)
```sql
MERGE INTO t_acc a
USING (SELECT :id id, :inc inc, :ver ver FROM dual) x
ON (a.id = x.id AND a.ver = x.ver)
WHEN MATCHED THEN
  UPDATE SET a.bal = a.bal + x.inc, a.ver = a.ver + 1
WHEN NOT MATCHED THEN
  INSERT (id, bal, ver) VALUES (x.id, :init_bal, 0);
```
**설명**: 존재 시 **버전 검증 후 증가**, 없으면 **삽입**.

### 5.4 PL/SQL 재시도 래퍼(기본 패턴)
```sql
DECLARE
  l_old_bal NUMBER;
  l_old_ver NUMBER;
  l_try     PLS_INTEGER := 0;
BEGIN
  LOOP
    l_try := l_try + 1;

    SELECT bal, ver INTO l_old_bal, l_old_ver
    FROM   t_acc WHERE id=1;

    -- 업무 계산: l_new_bal := l_old_bal + 25;

    UPDATE t_acc
       SET bal = l_old_bal + 25,
           ver = l_old_ver + 1
     WHERE id  = 1
       AND ver = l_old_ver;

    IF SQL%ROWCOUNT = 1 THEN
      COMMIT; EXIT;
    ELSIF l_try >= 5 THEN
      ROLLBACK; RAISE_APPLICATION_ERROR(-20001, 'OCC 충돌-재시도 초과');
    ELSE
      DBMS_LOCK.SLEEP(POWER(2, l_try) * 0.05); -- 지수 백오프
    END IF;
  END LOOP;
END;
/
```

---

## 6. 비관적 vs 낙관적 — 선택 기준

| 기준 | 비관적 권장 | 낙관적 권장 |
|---|---|---|
| **충돌 빈도** | 높음 (재시도 비용이 치명적) | 낮음 |
| **갱신 지연 허용** | 낮음(즉시성 필요) | 재시도 허용, 지연 허용 |
| **읽기:쓰기 비율** | 쓰기 비중 큼 | 읽기 비중 큼 |
| **데이터 중요도** | 돈/주문/재고 등 **유실 방지 최우선** | 통계/로그/비핵심 |
| **작업 단위** | 짧은 원자 갱신 | 비교적 긴 계산 후 커밋 |
| **인프라** | 단일 RDB, 중앙집중 | 마이크로서비스/분산, 캐시 중심 |
| **팬텀/전역 제약** | 범위락/직렬화/절차로 보장 | 전역 제약은 DB 제약/락 테이블로 보강 |

---

## 7. 둘을 섞는 하이브리드 전략

1) **읽기/계산은 낙관적**, **최종 커밋만 비관적 잠금**  
   - 예: 최종 단계에서 `SELECT ... FOR UPDATE NOWAIT` 로 충돌 즉시 실패 처리.  
2) **핵심 자원만 비관적**, **나머지 낙관적**  
   - 예: **재고/좌석 키**만 `FOR UPDATE`, 나머지는 버전 칼럼.  
3) **큐 패턴**: `SKIP LOCKED` 로 낙관적 분산 처리 + 실패 시 재큐잉.

---

## 8. Write Skew & 전역 제약 — 두 방식의 함정과 처방
- **낙관적/스냅샷 계열**에서 전형: 서로 다른 행을 갱신하여 **전역 제약**(예: 항상 1명 이상 oncall)을 침해.
- **처방**  
  - **DB 제약**(유니크/체크 + 트리거)로 **전역 규칙을 데이터 레벨에서 강제**  
  - **락 테이블**(전역 키에 대한 단일행) `SELECT ... FOR UPDATE`  
  - **Serializable** + **재시도**  
  - 애플리케이션에서 **분산 락**(주의) 또는 **리더 단일 원장** 패턴

---

## 9. 모니터링/진단(Oracle)

```sql
-- 락 대기/행 락
SELECT sid, event, state, seconds_in_wait
FROM   v$session
WHERE  event LIKE 'enq: TX%';

-- 세그먼트 경합(ITL/핫블록)
SELECT owner, object_name, statistic_name, value
FROM   v$segment_statistics
WHERE  statistic_name IN ('buffer busy waits','ITL waits')
ORDER  BY value DESC;

-- 파라미터/환경
SHOW PARAMETER initrans;
SHOW PARAMETER pctfree;
```

**관측 포인트**  
- 비관적: `enq: TX - row lock contention`, `enq: TX - allocate ITL entry`, `buffer busy waits`  
- 낙관적: 대기 적지만 **업데이트 영향행=0** 빈도, **재시도율**(앱 로그) 관찰

---

## 10. 성능·안정성 체크리스트

1) **트랜잭션 길이 단축** — 읽기→계산→쓰기 **간격 최소화**  
2) **재시도 정책** — 최대 횟수·백오프·Jitter, **멱등성**(동일 요청 중복 안전)  
3) **키/인덱스 설계** — 핫키 분산(Reverse/Hash/샤딩), 범위쿼리 최적화  
4) **ITL/헤더 여유** — 동시 갱신 블록 `INITRANS`/`PCTFREE`↑  
5) **전역 제약** — DB 제약/락 테이블/직렬화 구간으로 **Write Skew** 차단  
6) **오류 대응** — ORA-00054(NOWAIT), ORA-00060(데드락), **OCC 재시도 실패 시 사용자 메시지**  
7) **테스트** — 경합/재시도률/레이트 리밋 A/B, **장기 꼬리지연(p95/p99)** 추적

---

## 11. 수학적 감각(간단 모델)

- **낙관적 충돌 확률** \(p\), **재시도 1회 비용** \(C_r\), **기본 처리 비용** \(C_0\).  
  평균 비용(1회 성공 기대) 근사:
\[
\mathbb{E}[C] \approx C_0 + \frac{p}{1-p}\, C_r
\]
- \(p\) 가 작으면 OCC 유리, \(p\) 가 커지면 비관적이 유리.

---

## 12. 실무 시나리오 요약

- **주문 결제/재고 차감**: 비관적(핵심 키 `FOR UPDATE`), 나머지 메타는 OCC 가능.  
- **피드/로그/분석 카운터**: OCC(버전/원자 증가) + 실패 시 재시도.  
- **작업 큐**: `FOR UPDATE SKIP LOCKED`(비관적) + 멱등 작업자.  
- **프로필 저장/동시 편집**: OCC + 충돌 시 머지 UI/안내.  
- **스케줄러 슬롯**: 전역 락 테이블 1행 `FOR UPDATE`(비관적) 또는 분산 락.

---

## 13. 결론

- **비관적**: “**먼저 잠그고 쓴다**” — 충돌이 흔하고 재시도가 비싼 **핵심 자산**에 적합.  
- **낙관적**: “**먼저 일하고 마지막에 확인**” — **읽기 위주/충돌 드문** 트래픽에 탁월.  
- **정답은 혼합**: 핵심 키/불변식은 **비관적**, 주변부는 **낙관적**. **재시도·멱등성**은 낙관적의 생명선.

> 한 줄 정리:  
> **락으로 미리 막을 것인가(비관적)**, **나중에 걸러낼 것인가(낙관적)**.  
> **충돌 빈도·비용·정합성 요구**를 수치로 보고, **하이브리드**로 현실 최적점을 잡아라.