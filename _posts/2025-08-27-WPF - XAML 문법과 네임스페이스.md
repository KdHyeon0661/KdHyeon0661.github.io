---
layout: post
title: WPF - XAML 문법과 네임스페이스
date: 2025-08-27 21:25:23 +0900
category: WPF
---
# XAML: 선언적 UI 프로그래밍의 세계로 초대합니다

## XAML의 본질과 철학

XAML(eXtensible Application Markup Language)은 단순한 마크업 언어가 아닙니다. 그것은 .NET 객체의 계층 구조를 XML 형식으로 선언적으로 표현하는 메타 언어입니다. XAML의 핵심 철학은 "UI는 선언적으로, 로직은 절차적으로"입니다. 이 분리는 더 읽기 쉽고, 유지보수하기 쉬우며, 디자이너와 개발자 간의 협업을 가능하게 하는 강력한 패러다임을 제공합니다.

```xml
<!-- 이것은 단순한 XML이 아닙니다 -->
<!-- 이것은 객체 그래프의 선언입니다 -->
<Window>
    <Grid>
        <Button Content="저장" Click="OnSaveClick"/>
    </Grid>
</Window>

<!-- 위의 XAML은 아래의 C# 코드와 동일합니다 -->
/*
var window = new Window();
var grid = new Grid();
var button = new Button { Content = "저장" };
button.Click += OnSaveClick;

grid.Children.Add(button);
window.Content = grid;
*/
```

## XAML의 기본 문법 구조

### 요소와 속성: 객체의 탄생

```xml
<!-- 기본 구조: 요소는 타입, 속성은 프로퍼티 -->
<Button 
    Content="저장하기" 
    Width="120" 
    Height="40"
    HorizontalAlignment="Center"
    VerticalAlignment="Center"/>
```

### 속성 요소 구문: 복잡한 값의 표현

```xml
<!-- 속성이 단순 문자열이 아닌 경우 -->
<Button>
    <Button.Content>
        <StackPanel Orientation="Horizontal">
            <Image Source="Icons/save_16.png"/>
            <TextBlock Text="저장" Margin="6,0,0,0"/>
        </StackPanel>
    </Button.Content>
</Button>

<!-- 축약형: Content 속성은 특별한 경우 생략 가능 -->
<Button>
    <StackPanel Orientation="Horizontal">
        <Image Source="Icons/save_16.png"/>
        <TextBlock Text="저장" Margin="6,0,0,0"/>
    </StackPanel>
</Button>
```

### 컬렉션 요소: 자식 객체의 집합

```xml
<!-- StackPanel의 Children 컬렉션에 여러 요소 추가 -->
<StackPanel>
    <TextBlock Text="이름:"/>
    <TextBox x:Name="NameTextBox"/>
    <TextBlock Text="이메일:"/>
    <TextBox x:Name="EmailTextBox"/>
    <Button Content="등록"/>
</StackPanel>
```

## 네임스페이스: XAML 세계의 지도

네임스페이스는 XAML에서 가장 중요한 개념 중 하나입니다. 그것은 타입의 주소를 정의하고, 컴파일러가 어떤 .NET 타입을 참조하는지 알 수 있게 합니다.

### 기본 네임스페이스 이해하기

```xml
<!-- 표준 WPF XAML 파일 헤더 -->
<Window
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="clr-namespace:MyApp.Views"
    xmlns:vm="clr-namespace:MyApp.ViewModels"
    xmlns:sys="clr-namespace:System;assembly=System.Runtime"
    xmlns:controls="clr-namespace:MyApp.Controls;assembly=MyApp.Controls"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d">
```

### 각 네임스페이스의 역할

1. **기본 네임스페이스 (접두사 없음)**
   ```xml
   xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
   ```
   - WPF의 모든 핵심 컨트롤과 타입을 포함
   - `Button`, `Grid`, `TextBlock`, `Style`, `Brush` 등
   - 접두사가 없으므로 가장 자주 사용하는 타입들

2. **XAML 언어 네임스페이스 (x:)**
   ```xml
   xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
   ```
   - XAML 언어 자체의 키워드 제공
   - `x:Class`, `x:Name`, `x:Key`, `x:Type`, `x:Static`

3. **사용자 정의 네임스페이스**
   ```xml
   <!-- 현재 어셈블리 -->
   xmlns:local="clr-namespace:MyApp.Views"
   
   <!-- 다른 어셈블리 -->
   xmlns:controls="clr-namespace:MyApp.Controls;assembly=MyApp.Controls"
   
   <!-- 시스템 타입 -->
   xmlns:sys="clr-namespace:System;assembly=System.Runtime"
   ```

4. **디자인 타임 네임스페이스 (d:)**
   ```xml
   xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
   xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
   mc:Ignorable="d"
   ```
   - 디자인 타임에만 사용되는 속성
   - 런타임에는 무시됨

### 실제 사용 예제

```xml
<Window
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="clr-namespace:MyApp"
    xmlns:sys="clr-namespace:System;assembly=System.Runtime"
    xmlns:material="http://materialdesigninxaml.net/winfx/xaml/themes"
    Title="Main Window">

    <!-- 기본 네임스페이스 사용 (접두사 없음) -->
    <Grid>
        <Button Content="기본 버튼"/>
    </Grid>

    <!-- 사용자 정의 컨트롤 -->
    <local:CustomControl/>

    <!-- 외부 라이브러리 컨트롤 -->
    <material:Card Width="200" Height="100"/>

    <!-- 시스템 타입 -->
    <sys:DateTime>2024-01-01</sys:DateTime>
</Window>
```

## XAML 언어 기능들

### x: 접두사의 마법

```xml
<!-- 1. x:Class - 코드비하인드와 연결 -->
<Window x:Class="MyApp.MainWindow">

<!-- 2. x:Name - 런타임 접근을 위한 이름 -->
<Button x:Name="SaveButton" Content="저장"/>

<!-- 3. x:Key - 리소스 식별 -->
<Style x:Key="PrimaryButtonStyle" TargetType="Button">
    <Setter Property="Background" Value="Blue"/>
</Style>

<!-- 4. x:Type - 타입 참조 -->
<DataTemplate DataType="{x:Type local:Product}">
    <!-- Product 타입에 대한 템플릿 -->
</DataTemplate>

<!-- 5. x:Static - 정적 멤버 참조 -->
<TextBlock Text="{x:Static local:Constants.AppName}"/>

<!-- 6. x:Null - null 값 -->
<Button Tag="{x:Null}"/>

<!-- 7. x:Array - 배열 생성 -->
<x:Array Type="{x:Type sys:String}">
    <sys:String>Item 1</sys:String>
    <sys:String>Item 2</sys:String>
</x:Array>

<!-- 8. x:Reference - 다른 요소 참조 -->
<TextBox x:Name="SourceTextBox"/>
<TextBlock Text="{Binding Text, Source={x:Reference SourceTextBox}}"/>
```

### Attached Property: 다른 객체에 속성 "붙이기"

```xml
<Grid>
    <!-- Grid.Row, Grid.Column은 Button의 속성이 아니라 Grid에 "붙은" 속성 -->
    <Button Grid.Row="0" Grid.Column="1" Content="저장"/>
</Grid>

<!-- 사용자 정의 Attached Property 사용 -->
<StackPanel local:LayoutProperties.Spacing="10">
    <Button Content="Button 1"/>
    <Button Content="Button 2"/>
</StackPanel>
```

## 마크업 확장: XAML의 표현력 확장하기

마크업 확장은 중괄호(`{}`) 구문을 사용하여 XAML의 표현력을 확장합니다.

### 기본 마크업 확장

```xml
<!-- 1. Binding - 데이터 바인딩 -->
<TextBlock Text="{Binding UserName}"/>
<TextBox Text="{Binding Email, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>

<!-- 2. StaticResource - 정적 리소스 참조 -->
<Button Background="{StaticResource PrimaryBrush}"/>

<!-- 3. DynamicResource - 동적 리소스 참조 -->
<Button Background="{DynamicResource ThemeBrush}"/>

<!-- 4. RelativeSource - 상대적 바인딩 소스 -->
<TextBlock Text="{Binding DataContext.Title, 
    RelativeSource={RelativeSource AncestorType=Window}}"/>

<!-- 5. TemplateBinding - 템플릿 내에서 컨트롤 속성 참조 -->
<ControlTemplate TargetType="Button">
    <Border Background="{TemplateBinding Background}"/>
</ControlTemplate>

<!-- 6. 사용자 정의 마크업 확장 -->
<TextBlock Text="{local:LocalizedString Key=WelcomeMessage}"/>
```

### 바인딩의 다양한 형태

```xml
<!-- 기본 바인딩 -->
<TextBlock Text="{Binding Name}"/>

<!-- 경로 지정 -->
<TextBlock Text="{Binding Customer.Address.City}"/>

<!-- 컨버터 사용 -->
<TextBlock Text="{Binding BirthDate, 
    Converter={StaticResource DateConverter},
    ConverterParameter='yyyy-MM-dd'}"/>

<!-- 문자열 포맷 -->
<TextBlock Text="{Binding Price, StringFormat=C}"/>

<!-- FallbackValue와 TargetNullValue -->
<TextBlock Text="{Binding Description, 
    FallbackValue='설명 없음',
    TargetNullValue='내용 없음'}"/>

<!-- 다중 바인딩 -->
<TextBlock>
    <TextBlock.Text>
        <MultiBinding StringFormat="{}{0} ({1})">
            <Binding Path="FirstName"/>
            <Binding Path="LastName"/>
        </MultiBinding>
    </TextBlock.Text>
</TextBlock>

<!-- PriorityBinding -->
<TextBlock>
    <TextBlock.Text>
        <PriorityBinding>
            <Binding Path="FastDataSource" IsAsync="True"/>
            <Binding Path="SlowDataSource"/>
        </PriorityBinding>
    </TextBlock.Text>
</TextBlock>
```

## 리소스 시스템: 재사용 가능한 객체 관리

### 리소스의 계층 구조

```xml
<Window>
    <!-- 1. 윈도우 수준 리소스 -->
    <Window.Resources>
        <SolidColorBrush x:Key="WindowPrimaryBrush" Color="#0078D4"/>
        <Style x:Key="WindowButtonStyle" TargetType="Button">
            <Setter Property="Background" Value="{StaticResource WindowPrimaryBrush}"/>
        </Style>
    </Window.Resources>
    
    <Grid>
        <!-- 2. 그리드 수준 리소스 -->
        <Grid.Resources>
            <SolidColorBrush x:Key="GridSecondaryBrush" Color="#6C757D"/>
        </Grid.Resources>
        
        <StackPanel>
            <!-- 3. 스택패널 수준 리소스 -->
            <StackPanel.Resources>
                <Style TargetType="TextBlock">
                    <Setter Property="Margin" Value="4"/>
                </Style>
            </StackPanel.Resources>
            
            <!-- 리소스 찾기 순서: StackPanel → Grid → Window → Application -->
            <TextBlock Text="이름:"/> <!-- 암시적 스타일 적용 -->
            <Button Content="저장" Style="{StaticResource WindowButtonStyle}"/>
        </StackPanel>
    </Grid>
</Window>
```

### 애플리케이션 전역 리소스

```xml
<!-- App.xaml -->
<Application.Resources>
    <!-- 병합된 리소스 사전 -->
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <!-- 테마별 리소스 -->
            <ResourceDictionary Source="Themes/Colors.xaml"/>
            <ResourceDictionary Source="Themes/Brushes.xaml"/>
            <ResourceDictionary Source="Themes/Styles.xaml"/>
            
            <!-- 외부 라이브러리 리소스 -->
            <ResourceDictionary Source="pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Light.xaml"/>
        </ResourceDictionary.MergedDictionaries>
        
        <!-- 직접 정의한 리소스 -->
        <SolidColorBrush x:Key="GlobalPrimaryBrush" Color="#0078D4"/>
    </ResourceDictionary>
</Application.Resources>
```

### StaticResource vs DynamicResource

```csharp
public class ThemeManager
{
    public static void ToggleTheme()
    {
        // 테마 변경 시
        var newTheme = Application.Current.Resources.MergedDictionaries[0] 
            == LightTheme ? DarkTheme : LightTheme;
        
        Application.Current.Resources.MergedDictionaries[0] = newTheme;
        
        // StaticResource: 변경 반영 안됨 (로드 시점에 값 고정)
        // DynamicResource: 변경 즉시 반영됨
    }
}
```

```xml
<!-- StaticResource: 테마 변경 시 업데이트 안됨 -->
<Button Background="{StaticResource ThemeBrush}"/>

<!-- DynamicResource: 테마 변경 시 자동 업데이트 -->
<Button Background="{DynamicResource ThemeBrush}"/>
```

## 타입 변환기: 문자열을 객체로 변환하기

XAML은 문자열을 .NET 객체로 자동 변환하는 강력한 시스템을 가지고 있습니다.

### 내장 타입 변환기

```xml
<!-- ThicknessConverter -->
<Border Margin="10,5,10,5"/>  <!-- Thickness(10,5,10,5) -->
<Border Margin="10"/>         <!-- Thickness(10,10,10,10) -->

<!-- BrushConverter -->
<Button Background="Red"/>                    <!-- SolidColorBrush -->
<Button Background="#FF0000"/>               <!-- 16진수 색상 -->
<Button Background="LinearGradient ..."/>    <!-- 복잡한 브러시 -->

<!-- FontFamilyConverter -->
<TextBlock FontFamily="Segoe UI"/>

<!-- BooleanConverter -->
<CheckBox IsChecked="True"/>
<CheckBox IsChecked="False"/>

<!-- EnumConverter -->
<Button HorizontalAlignment="Left"/>
<Button HorizontalAlignment="Center"/>
<Button HorizontalAlignment="Right"/>
```

### 사용자 정의 타입 변환기

```csharp
// 사용자 정의 타입
[TypeConverter(typeof(Point3DConverter))]
public struct Point3D
{
    public double X { get; set; }
    public double Y { get; set; }
    public double Z { get; set; }
    
    public Point3D(double x, double y, double z)
    {
        X = x; Y = y; Z = z;
    }
}

// 타입 변환기 구현
public class Point3DConverter : TypeConverter
{
    public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
    {
        return sourceType == typeof(string);
    }
    
    public override object ConvertFrom(ITypeDescriptorContext context, 
        CultureInfo culture, object value)
    {
        if (value is string str)
        {
            var parts = str.Split(',');
            if (parts.Length == 3 &&
                double.TryParse(parts[0], out double x) &&
                double.TryParse(parts[1], out double y) &&
                double.TryParse(parts[2], out double z))
            {
                return new Point3D(x, y, z);
            }
        }
        return base.ConvertFrom(context, culture, value);
    }
}
```

```xml
<!-- 사용자 정의 타입 변환기 사용 -->
<local:MyControl Position="10,20,30"/>  <!-- 문자열이 Point3D로 변환됨 -->
```

## 디자인 타임 지원: 더 나은 개발 경험

### d: 디자인 타임 속성

```xml
<Window
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d">

    <!-- 런타임 DataContext -->
    <Window.DataContext>
        <local:MainViewModel/>
    </Window.DataContext>
    
    <!-- 디자인 타임 DataContext -->
    <d:Window.DataContext>
        <local:DesignTimeViewModel/>
    </d:Window.DataContext>
    
    <Grid>
        <!-- 디자인 타임에만 표시되는 내용 -->
        <TextBlock d:Text="디자인 미리보기" 
                   Text="{Binding RealText}"/>
        
        <!-- 디자인 타임 샘플 데이터 -->
        <ListBox ItemsSource="{Binding Items}">
            <d:ListBox.ItemsSource>
                <x:Array Type="{x:Type sys:String}">
                    <sys:String>샘플 항목 1</sys:String>
                    <sys:String>샘플 항목 2</sys:String>
                    <sys:String>샘플 항목 3</sys:String>
                </x:Array>
            </d:ListBox.ItemsSource>
        </ListBox>
    </Grid>
</Window>
```

### DesignInstance와 d:DataContext

```xml
<!-- 디자인 타임에 뷰모델 인스턴스 생성 -->
<Window
    d:DataContext="{d:DesignInstance Type=local:MainViewModel, 
                     IsDesignTimeCreatable=True}">
    
    <!-- 이제 디자인 타임에 실제 뷰모델 인스턴스 사용 -->
    <TextBlock Text="{Binding UserName}"/>  <!-- 디자인 타임에 값 표시 -->
</Window>
```

## 고급 XAML 패턴과 기법

### 리소스 선택과 병합

```xml
<!-- 조건부 리소스 선택 -->
<Window.Resources>
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <!-- OS 버전에 따른 리소스 선택 -->
            <ResourceDictionary Source="{Binding Source={x:Static sys:Environment.OSVersion}, 
                                          Converter={StaticResource OSVersionToThemeConverter}}"/>
            
            <!-- 사용자 설정에 따른 테마 -->
            <ResourceDictionary Source="{Binding Source={x:Static local:Settings.Current}, 
                                          Path=Theme, 
                                          Converter={StaticResource ThemeToResourceConverter}}"/>
        </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
</Window.Resources>
```

### 템플릿과 스타일의 조합

```xml
<!-- 기본 스타일에 템플릿 오버라이드 -->
<Style TargetType="Button" x:Key="CustomButton">
    <Setter Property="Template">
        <Setter.Value>
            <ControlTemplate TargetType="Button">
                <Grid>
                    <!-- 기본 배경 -->
                    <Border x:Name="BackgroundBorder"
                            Background="{TemplateBinding Background}"
                            CornerRadius="4"/>
                    
                    <!-- 콘텐츠 -->
                    <ContentPresenter HorizontalAlignment="Center"
                                      VerticalAlignment="Center"/>
                    
                    <!-- 호버 효과 -->
                    <Border x:Name="HoverOverlay"
                            Background="#20000000"
                            CornerRadius="4"
                            Opacity="0"/>
                </Grid>
                
                <ControlTemplate.Triggers>
                    <Trigger Property="IsMouseOver" Value="True">
                        <Setter TargetName="HoverOverlay" 
                                Property="Opacity" Value="1"/>
                    </Trigger>
                </ControlTemplate.Triggers>
            </ControlTemplate>
        </Setter.Value>
    </Setter>
</Style>
```

### XAML 생성기와 코드 생성

```csharp
// 런타임 XAML 생성
public static UIElement CreateDynamicXaml(string xamlString)
{
    var parserContext = new ParserContext();
    parserContext.XmlnsDictionary.Add("", "http://schemas.microsoft.com/winfx/2006/xaml/presentation");
    parserContext.XmlnsDictionary.Add("x", "http://schemas.microsoft.com/winfx/2006/xaml");
    
    return (UIElement)XamlReader.Parse(xamlString, parserContext);
}

// 사용 예
var dynamicXaml = @"
<StackPanel xmlns='http://schemas.microsoft.com/winfx/2006/xaml/presentation'
            xmlns:x='http://schemas.microsoft.com/winfx/2006/xaml'>
    <TextBlock Text='동적 생성'/>
    <Button Content='클릭'/>
</StackPanel>";

var element = CreateDynamicXaml(dynamicXaml);
```

## 성능 최적화와 모범 사례

### XAML 로딩 최적화

```xml
<!-- 지연 로딩을 위한 패턴 -->
<Grid>
    <!-- 초기 로딩 시 필요 없는 컨트롤 -->
    <TabControl>
        <TabItem Header="기본">
            <!-- 첫 탭 내용 -->
        </TabItem>
        
        <TabItem Header="세부">
            <!-- 두 번째 탭은 Frame으로 지연 로딩 -->
            <Frame Source="DetailsPage.xaml" NavigationUIVisibility="Hidden"/>
        </TabItem>
    </TabControl>
</Grid>
```

### 리소스 참조 최적화

```xml
<!-- 효율적인 리소스 사용 -->
<Window.Resources>
    <!-- Freezable 객체는 Freeze하여 공유 -->
    <SolidColorBrush x:Key="SharedBrush" Color="Blue" x:Shared="True"/>
    
    <!-- 큰 리소스는 필요한 때만 로드 -->
    <BitmapImage x:Key="LargeImage" UriSource="LargeImage.jpg"
                 CacheOption="OnLoad" DecodePixelWidth="800"/>
</Window.Resources>
```

## 디버깅과 문제 해결

### XAML 파싱 오류 디버깅

```xml
<!-- 디버깅을 위한 트레이싱 -->
<TextBlock Text="{Binding UserName, 
                PresentationTraceSources.TraceLevel=High}"/>

<!-- XAML 파서 오류 캡처 -->
<Grid>
    <Grid.LayoutTransform>
        <ScaleTransform ScaleX="{Binding Scale, FallbackValue=1}"/>
    </Grid.LayoutTransform>
    
    <!-- 오류 발생 시 대체 UI -->
    <ContentControl>
        <ContentControl.Style>
            <Style TargetType="ContentControl">
                <Style.Triggers>
                    <DataTrigger Binding="{Binding HasError}" Value="True">
                        <Setter Property="Content">
                            <Setter.Value>
                                <TextBlock Text="UI 로딩 오류" Foreground="Red"/>
                            </Setter.Value>
                        </Setter>
                    </DataTrigger>
                </Style.Triggers>
            </Style>
        </ContentControl.Style>
    </ContentControl>
</Grid>
```

### 네임스페이스 문제 해결

```csharp
public class NamespaceDebugHelper
{
    public static void DebugNamespaceMapping()
    {
        var assembly = Assembly.GetExecutingAssembly();
        
        Console.WriteLine("현재 어셈블리의 타입들:");
        foreach (var type in assembly.GetTypes().Take(10))
        {
            Console.WriteLine($"  {type.Namespace}.{type.Name}");
        }
        
        // XAML에서 사용할 네임스페이스 매핑 생성
        var namespaceMappings = assembly.GetTypes()
            .Select(t => t.Namespace)
            .Distinct()
            .Select(ns => $"xmlns:local=\"{ns}\"");
        
        Console.WriteLine("\n추천 네임스페이스 매핑:");
        foreach (var mapping in namespaceMappings)
        {
            Console.WriteLine($"  {mapping}");
        }
    }
}
```

## 실전 예제: 완전한 XAML 애플리케이션

```xml
<!-- MainWindow.xaml -->
<Window x:Class="ModernApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:ModernApp"
        xmlns:vm="clr-namespace:ModernApp.ViewModels"
        xmlns:converters="clr-namespace:ModernApp.Converters"
        xmlns:material="http://materialdesigninxaml.net/winfx/xaml/themes"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Modern WPF Application"
        Height="700" Width="1200"
        WindowStartupLocation="CenterScreen"
        d:DataContext="{d:DesignInstance Type=vm:MainViewModel, IsDesignTimeCreatable=True}">

    <Window.Resources>
        <!-- 변환기 -->
        <converters:BooleanToVisibilityConverter x:Key="BoolToVisibility"/>
        <converters:StringToImageConverter x:Key="StringToImage"/>
        
        <!-- 스타일 -->
        <Style TargetType="Button" x:Key="ModernButton">
            <Setter Property="Background" Value="{DynamicResource PrimaryHueMidBrush}"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="Padding" Value="12,8"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border Background="{TemplateBinding Background}"
                                CornerRadius="4">
                            <ContentPresenter HorizontalAlignment="Center"
                                            VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter Property="Background" 
                                        Value="{DynamicResource PrimaryHueDarkBrush}"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
        
        <!-- 데이터 템플릿 -->
        <DataTemplate DataType="{x:Type vm:ProductViewModel}">
            <Border BorderBrush="#E0E0E0" BorderThickness="1" CornerRadius="4"
                    Padding="12" Margin="4">
                <StackPanel>
                    <Image Source="{Binding ImageUrl, Converter={StaticResource StringToImage}}"
                           Height="120" Width="120" Stretch="Uniform"/>
                    <TextBlock Text="{Binding Name}" FontWeight="Bold" Margin="0,8,0,4"/>
                    <TextBlock Text="{Binding Description}" TextWrapping="Wrap"/>
                    <TextBlock Text="{Binding Price, StringFormat=C}" 
                               Foreground="Green" Margin="0,8,0,0"/>
                </StackPanel>
            </Border>
        </DataTemplate>
    </Window.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- 헤더 -->
        <Border Background="{DynamicResource PrimaryHueMidBrush}" 
                Padding="16" Grid.Row="0">
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="Modern App" Foreground="White" 
                           FontSize="20" FontWeight="Bold"/>
                <TextBlock Text="{Binding CurrentViewTitle}" Foreground="White"
                           FontSize="20" Margin="16,0,0,0"/>
            </StackPanel>
        </Border>

        <!-- 메인 콘텐츠 -->
        <Grid Grid.Row="1">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition/>
            </Grid.ColumnDefinitions>

            <!-- 네비게이션 -->
            <Border BorderBrush="#E0E0E0" BorderThickness="0,0,1,0"
                    Width="200" Grid.Column="0">
                <StackPanel Margin="16">
                    <Button Content="대시보드" Style="{StaticResource ModernButton}"
                            Command="{Binding NavigateToDashboardCommand}"/>
                    <Button Content="제품 관리" Style="{StaticResource ModernButton}"
                            Command="{Binding NavigateToProductsCommand}" Margin="0,8,0,0"/>
                    <Button Content="설정" Style="{StaticResource ModernButton}"
                            Command="{Binding NavigateToSettingsCommand}" Margin="0,8,0,0"/>
                </StackPanel>
            </Border>

            <!-- 콘텐츠 영역 -->
            <ContentControl Content="{Binding CurrentView}" Grid.Column="1">
                <ContentControl.ContentTemplate>
                    <DataTemplate>
                        <ContentPresenter Content="{Binding}"/>
                    </DataTemplate>
                </ContentControl.ContentTemplate>
            </ContentControl>
        </Grid>

        <!-- 푸터 -->
        <Border Background="#F5F5F5" Padding="12" Grid.Row="2">
            <StackPanel Orientation="Horizontal" HorizontalAlignment="Right">
                <TextBlock Text="{Binding StatusMessage}"/>
                <ProgressBar Value="{Binding Progress}" Width="100" Margin="16,0,0,0"
                             Visibility="{Binding IsBusy, 
                                         Converter={StaticResource BoolToVisibility}}"/>
            </StackPanel>
        </Border>
    </Grid>
</Window>
```

## 결론: XAML 마스터의 길

XAML은 단순한 마크업 언어가 아닙니다. 그것은 .NET 개발자가 선언적으로 복잡한 UI를 구축할 수 있게 해주는 강력한 도구입니다. XAML을 마스터하는 것은 여러 단계의 여정입니다:

### 1단계: 기본 문법 숙달
- 요소와 속성의 관계 이해
- 네임스페이스 매핑의 원리 파악
- 마크업 확장의 기본 사용법 학습

### 2단계: 고급 기능 활용
- 데이터 바인딩의 다양한 패턴 숙지
- 리소스 시스템의 계층 구조 이해
- 템플릿과 스타일의 조합 방법 학습

### 3단계: 성능과 유지보수성 고려
- 리소스 참조 최적화
- XAML 구조화 패턴 적용
- 디자인 타임 지원 구현

### 4단계: 생태계 통합
- 서드파티 라이브러리와의 통합
- CI/CD 파이프라인에서의 XAML 처리
- 크로스 플랫폼 시나리오 대응

XAML의 진정한 힘은 그 표현력에 있습니다. 같은 UI를 만드는 데 있어서 XAML은 C# 코드보다 훨씬 간결하고 읽기 쉽습니다. 하지만 이 간결함 뒤에는 복잡한 시스템이 작동하고 있습니다. DependencyProperty, 데이터 바인딩 엔진, 리소스 시스템, 렌더링 파이프라인 - 이 모든 것들이 함께 어우러져 XAML이 마법처럼 작동하게 만듭니다.

기억하세요: 좋은 XAML은 단순히 동작하는 UI를 만드는 것이 아닙니다. 그것은 읽기 쉽고, 유지보수하기 쉽고, 확장 가능한 UI를 만드는 것입니다. XAML을 작성할 때마다 스스로에게 물어보세요:

1. **가독성**: 다른 개발자가 이 코드를 이해하기 쉬운가?
2. **재사용성**: 이 구성 요소나 스타일을 다른 곳에서도 사용할 수 있는가?
3. **유지보수성**: 요구사항이 변경될 때 쉽게 수정할 수 있는가?
4. **성능**: 이 XAML이 효율적으로 렌더링되는가?

XAML은 도구일 뿐입니다. 그 도구를 어떻게 사용하느냐가 진정한 전문가와 아마추어를 구분합니다. 이 가이드가 여러분의 XAML 여정에 도움이 되길 바랍니다. 행운을 빕니다!