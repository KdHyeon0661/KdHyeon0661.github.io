---
layout: post
title: Django - 웹 기본기 묶음 (2)
date: 2025-10-01 18:25:23 +0900
category: Django
---
# 2. 웹 기본기 묶음 (2) — 미들웨어 & 메시지 프레임워크 (Django 5.x 기준)

## A. 미들웨어 — 순서/라이프사이클, 커스텀 미들웨어 작성 패턴

### A-1. 미들웨어란?

- **요청(request)** → **뷰(view)** → **응답(response)** 사이의 **횡단 관심사(cross-cutting concern)**를 처리하는 **체인**입니다.  
  (보안 헤더, 인증·세션, 로깅/트레이싱, 캐싱, GZip, CORS, CSRF 등)
- **`settings.MIDDLEWARE`** 에 나열한 **순서대로** 요청이 통과하며, 응답은 **역순**으로 통과합니다.

```
[요청]  Browser
   ↓
   MIDDLEWARE[0]  (process_request / __call__)
   ↓
   MIDDLEWARE[1]
   ↓
   ... (중략)
   ↓
   URL Resolver → View
   ↑
   ... 응답이 역순으로 올라옴 ...
   ↑
   MIDDLEWARE[n-1] (process_response)
   ↑
[응답]  Browser
```

### A-2. 순서(ORDER)의 의미

`MIDDLEWARE` 에선 **앞쪽이 “입구”** 입니다. 예:

```python
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",        # 1. 보안 헤더/HSTS
    "django.contrib.sessions.middleware.SessionMiddleware", # 2. 세션
    "django.middleware.common.CommonMiddleware",            # 3. 공통 처리(redirect 등)
    "django.middleware.csrf.CsrfViewMiddleware",            # 4. CSRF
    "django.contrib.auth.middleware.AuthenticationMiddleware", # 5. request.user
    "django.contrib.messages.middleware.MessageMiddleware", # 6. messages
    "django.middleware.clickjacking.XFrameOptionsMiddleware", # 7. 클릭재킹 방지
]
```

- **AuthenticationMiddleware** 가 **SessionMiddleware 이후**에 오도록 해야 `request.user` 가 정상 동작합니다.  
- **MessageMiddleware** 는 세션/쿠키 스토리지를 쓰므로 그 뒤에 위치.  
- **SecurityMiddleware** 는 보안 헤더/HSTS 등 **가장 앞**에서 관장하는 게 일반적.

> 실무 팁: 새 미들웨어를 추가할 때, **의존성**(세션/인증/메시지)을 고려해 위치를 정합니다.

### A-3. 라이프사이클(동기/비동기)

Django 5.x는 **동기/비동기 요청** 모두 지원합니다.

1) **미들웨어 팩토리**: `__init__(get_response)` 혹은 함수형 팩토리에서 **다음 핸들러**를 받음.  
2) `__call__(request)` 또는 async `__call__` 내에서 **사전 처리** → `response = get_response(request)` → **사후 처리**.

#### 동기 미들웨어 기본 형태

```python
# apps/common/middleware.py
class TimingMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        # 서버 부팅 시 1회 실행 (설정/리소스 준비)

    def __call__(self, request):
        # 1) 요청 전 처리
        import time
        start = time.perf_counter()

        # 2) 다음 핸들러 (다음 미들웨어 or View) 호출
        response = self.get_response(request)

        # 3) 응답 후 처리
        elapsed_ms = (time.perf_counter() - start) * 1000
        response["X-Elapsed-ms"] = f"{elapsed_ms:.2f}"

        return response
```

설정:

```python
MIDDLEWARE.insert(0, "apps.common.middleware.TimingMiddleware")
```

#### 비동기(ASGI) 대응 패턴

- Django는 **비동기 뷰**로 들어온 요청에 대해 **가능하면 async** 경로를 사용합니다.  
- 미들웨어도 **async `__call__`** 을 제공하면 자연스럽게 비동기 체인에 참여합니다.

```python
class AsyncFriendlyMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    async def __call__(self, request):
        # 비동기 사전 처리
        response = await self.get_response(request)
        # 비동기 사후 처리
        return response
```

> 동기/비동기 모두 지원하고 싶다면, `__call__` 에서 `iscoroutinefunction(self.get_response)` 를 체크하거나, Django의 내부 어댑터에 맡기고 **가능한 간단히 유지**합니다.

### A-4. 예외 처리(Exceptions)와 미들웨어

- 뷰/다음 미들웨어에서 **예외**가 발생하면, **위 방향**으로 예외가 전파되며 **위쪽 미들웨어에서 잡을 수 있습니다**.
- 공통 예외 로깅/마스킹/메트릭 수집에 유용.

```python
class ExceptionLoggingMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        try:
            return self.get_response(request)
        except Exception as exc:
            # 로그/메트릭/알림
            import logging
            logging.exception("Unhandled error: %s", exc)
            # 사용자에게는 일반화된 에러 페이지 반환(보안상 상세 숨김)
            from django.http import HttpResponseServerError
            return HttpResponseServerError("Internal Server Error")
```

> 주의: **DEBUG=True** 개발 환경에서는 Django의 디버그 페이지가 우선합니다. 운영에선 **일관된 에러 응답**을 제공하도록 미들웨어/핸들러를 구성하세요.

### A-5. Request/Response/Streaming/FileResponse 주의점

- `StreamingHttpResponse` / `FileResponse` 는 **본문이 지연 전송**됩니다.  
- 미들웨어에서 본문을 **읽거나 변형**하려면 버퍼링이 필요하지만, 일반적으로 **헤더 레벨** 작업만 수행하세요.  
- **GZip**/압축 계열 미들웨어가 스트리밍과 함께 쓰일 때 **메모리/지연**을 유의.

### A-6. 커스텀 미들웨어 작성 패턴(캔버스)

#### (1) 헤더 추가/보안 헤더

```python
class SecurityHeadersMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        resp = self.get_response(request)
        # 보안 헤더 추가
        resp.setdefault("X-Content-Type-Options", "nosniff")
        resp.setdefault("Referrer-Policy", "strict-origin-when-cross-origin")
        resp.setdefault("Permissions-Policy", "geolocation=()")
        return resp
```

#### (2) 요청 ID/트레이싱(로깅 상관 키)

```python
import uuid
import logging
from contextvars import ContextVar

request_id_var = ContextVar("request_id", default="-")

class RequestIDMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        rid = request.headers.get("X-Request-ID") or uuid.uuid4().hex
        token = request_id_var.set(rid)
        try:
            response = self.get_response(request)
            response["X-Request-ID"] = rid
            return response
        finally:
            request_id_var.reset(token)

# 로거 포맷터에서 %(request_id)s 를 사용하려면, Filter로 주입
class RequestIDLogFilter(logging.Filter):
    def filter(self, record):
        record.request_id = request_id_var.get()
        return True
```

```python
# settings.py (로깅)
LOGGING = {
  "version": 1,
  "filters": { "request_id": { "()": "apps.common.middleware.RequestIDLogFilter" } },
  "handlers": {
    "console": { "class": "logging.StreamHandler", "filters": ["request_id"] }
  },
  "root": { "handlers": ["console"], "level": "INFO" },
}
```

#### (3) IP 제한/화이트리스트(간단 예)

```python
from django.http import HttpResponseForbidden
from ipaddress import ip_network, ip_address

ALLOWED_NETS = [ip_network("203.0.113.0/24"), ip_network("10.10.0.0/16")]

class IPAllowlistMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        ip = request.META.get("REMOTE_ADDR", "")
        try:
            ip_obj = ip_address(ip)
            if not any(ip_obj in net for net in ALLOWED_NETS):
                return HttpResponseForbidden("Forbidden")
        except ValueError:
            return HttpResponseForbidden("Forbidden")
        return self.get_response(request)
```

> 운영에서는 리버스 프록시 뒤의 `X-Forwarded-For` 헤더를 **신뢰 가능한 프록시** 범위 내에서 파싱해야 합니다.

#### (4) 캐싱 키 힌트(정적 페이지 캐시 미들웨어 보조)

```python
class CacheKeyHintMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    def __call__(self, request):
        # 로그인 사용자별 캐시 분리 필요 시 Vary 헤더 추가
        response = self.get_response(request)
        if request.user.is_authenticated:
            response.setdefault("Vary", "Cookie")
        return response
```

### A-7. 미들웨어 테스트(단위/통합)

```python
# tests/test_middleware.py
import pytest
from django.test import RequestFactory
from django.http import HttpResponse
from apps.common.middleware import TimingMiddleware

@pytest.mark.django_db
def test_timing_middleware_adds_header():
    rf = RequestFactory()
    req = rf.get("/")
    def get_response(_):
        return HttpResponse("OK")

    mw = TimingMiddleware(get_response)
    resp = mw(req)
    assert "X-Elapsed-ms" in resp.headers
```

#### Client 통합 테스트에서 헤더 확인

```python
def test_security_headers(client):
    resp = client.get("/")
    assert resp["X-Content-Type-Options"] == "nosniff"
```

### A-8. 성능/안정성/보안 체크리스트

- [ ] **순서**: 세션 → 인증 → 메시지 순서 유지  
- [ ] **예외 처리**: 공통 로깅/마스킹 미들웨어 도입  
- [ ] **헤더**: 보안 헤더/캐시 헤더 일관화  
- [ ] **비동기**: async 뷰와의 호환성 검토(가능하면 **부작용 최소**)  
- [ ] **스트리밍**: 본문 변형 금지, 헤더 위주 처리  
- [ ] **구성 가능성**: 환경 변수/설정으로 on/off, 임계값 튜닝 가능하게  
- [ ] **테스트**: 단위 + 통합, 프로파일링(디버그 툴바, APM)

---

## B. 메시지 프레임워크 — 성공/오류 피드백 UX 패턴

### B-1. 개요

- Django의 **메시지 프레임워크**는 요청 간(stateful) **일회성 알림**을 다룹니다.  
  (ex) “저장되었습니다.”, “권한이 없습니다.”, “로그인되었습니다.”
- **스토리지**: 기본은 **세션**(또는 쿠키) 기반.  
- **레벨**: `DEBUG < INFO < SUCCESS < WARNING < ERROR`  
- 템플릿에서 `{% for message in messages %}` 로 표시.

### B-2. 설정 & 미들웨어

```python
INSTALLED_APPS += ["django.contrib.messages"]

MIDDLEWARE += [
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
]

from django.contrib.messages import constants as message_constants

# (선택) Bootstrap 등 CSS 클래스를 위해 레벨별 태그 매핑
MESSAGE_TAGS = {
    message_constants.DEBUG: "secondary",
    message_constants.INFO: "info",
    message_constants.SUCCESS: "success",
    message_constants.WARNING: "warning",
    message_constants.ERROR: "danger",
}

# (선택) 스토리지 변경 (기본: 'django.contrib.messages.storage.fallback.FallbackStorage')
MESSAGE_STORAGE = "django.contrib.messages.storage.session.SessionStorage"
```

스토리지 종류:
- `SessionStorage` — 세션 백엔드 사용 (일반적, 서버측 저장)  
- `CookieStorage` — 서명된 쿠키에 저장(용량 제한, 서버 상태 無)  
- `FallbackStorage` — 세션 실패 시 쿠키로 폴백(기본)

### B-3. 사용법(뷰에서 메시지 추가)

```python
from django.contrib import messages
from django.shortcuts import redirect

def save_profile(request):
    # 저장 로직...
    messages.success(request, "프로필을 저장했습니다.")
    return redirect("accounts:profile")
```

레벨별 API:

```python
messages.debug(request, "디버그 메시지")
messages.info(request, "안내 메시지")
messages.success(request, "성공 메시지")
messages.warning(request, "경고 메시지")
messages.error(request, "에러 메시지")
```

### B-4. 템플릿 렌더링(부트스트랩 예시)

부분 템플릿 `templates/includes/_messages.html`:

```html
{% if messages %}
  <div class="messages">
    {% for message in messages %}
      <div class="alert alert-{{ message.tags }} mt-2" role="alert">
        {{ message }}
      </div>
    {% endfor %}
  </div>
{% endif %}
```

레이아웃에 포함:

```html
<!-- templates/base.html -->
<body>
  {% include "includes/_messages.html" %}
  {% block content %}{% endblock %}
</body>
```

> `message.tags` 는 `MESSAGE_TAGS` 를 통해 Bootstrap 클래스와 매핑됩니다.

### B-5. CBV와 메시지 — FormView/SuccessMessageMixin

```python
from django.views.generic import CreateView
from django.contrib.messages.views import SuccessMessageMixin
from .models import Article

class ArticleCreateView(SuccessMessageMixin, CreateView):
    model = Article
    fields = ["title", "body"]
    template_name = "blog/article_form.html"
    success_url = "/blog/"
    success_message = "‘%(title)s’ 글을 작성했습니다."
```

- `SuccessMessageMixin` 은 **유효성 통과 + redirect** 시 메시지 추가.  
- 커스텀 로직이 필요하면 `form_valid()` 에서 `messages.success()` 호출.

### B-6. 유효성 실패/예외 메시지 패턴

```python
from django.contrib import messages

def submit_form(request):
    if request.method == "POST":
        form = MyForm(request.POST)
        if form.is_valid():
            # 저장
            messages.success(request, "저장되었습니다.")
            return redirect("home")
        else:
            messages.error(request, "입력값을 확인해 주세요.")
    else:
        form = MyForm()
    return render(request, "form.html", {"form": form})
```

> **Form 오류**는 일반적으로 `{{ form.errors }}` 를 통해 상세 표시하고, 메시지는 **상단 요약**이나 **전역 알림**으로 보조하면 UX가 좋아집니다.

### B-7. 사용자 경험(UX) 향상 기법

#### (1) 자동 닫힘(Toast/Alert)

```html
<script>
  // data-timeout="3000"인 alert 자동 닫기
  window.addEventListener("DOMContentLoaded", () => {
    document.querySelectorAll(".alert[data-timeout]").forEach(el => {
      const ms = parseInt(el.dataset.timeout, 10) || 3000;
      setTimeout(() => el.remove(), ms);
    });
  });
</script>
```

렌더 시:

```html
<div class="alert alert-{{ message.tags }}" data-timeout="3000">{{ message }}</div>
```

#### (2) 중복 메시지 억제 / 레벨 임계치

```python
# 메시지 추가 전, 같은 내용 있는지 확인
def add_unique_success(request, text):
    storage = messages.get_messages(request)
    have = any(str(m) == text and m.level == messages.SUCCESS for m in storage)
    storage.used = False  # iterator 소비했으니 다시 표시 가능하도록
    if not have:
        messages.success(request, text)
```

#### (3) HTMX / Partial 업데이트와 메시지

- **Partial 렌더**가 많은 앱에서는 메시지를 **별도 엔드포인트**로 렌더해 상단 영역만 교체합니다.

```python
# apps/common/views.py
from django.shortcuts import render
def messages_partial(request):
    return render(request, "includes/_messages.html")
```

프론트엔드:

```html
<div id="messages" hx-get="{% url 'common:messages_partial' %}" hx-trigger="revealed, htmx:afterOnLoad">
  {% include "includes/_messages.html" %}
</div>
```

서브 요청 후 `hx-trigger="load"` 로 재로드하도록 하거나, 응답 헤더로 `HX-Trigger` 를 발행하여 갱신합니다.

### B-8. 커스텀 레벨 & 국제화

```python
from django.contrib.messages import add_message, constants
from django.utils.translation import gettext as _

# 커스텀 레벨 (예: NOTICE)
NOTICE = 25
constants.DEFAULT_LEVELS["NOTICE"] = NOTICE  # (주의) 런타임 수정은 신중히

def notify(request, text):
    add_message(request, NOTICE, _(text))
```

`MESSAGE_TAGS` 에도 매핑 추가:

```python
MESSAGE_TAGS[NOTICE] = "primary"
```

### B-9. 메시지 스토리지 내부 동작 요약

- **요청 단위**로 메시지를 **append** → **다음 요청에서 1회성으로 소비**(표시) → **소비 후 제거**  
- `FallbackStorage` 는 세션이 없을 때 **서명 쿠키**에 메시지를 담아 넘깁니다.  
- **대용량 텍스트**를 메시지로 보내지 마세요(스토리지/쿠키 크기).

### B-10. 테스트(메시지 존재 확인)

```python
# tests/test_messages.py
import pytest
from django.contrib.messages import get_messages

@pytest.mark.django_db
def test_success_message_after_save(client, django_user_model):
    user = django_user_model.objects.create_user("u", password="p")
    client.login(username="u", password="p")
    resp = client.post("/save-profile/", {"bio": "hi"}, follow=True)
    storage = get_messages(resp.wsgi_request)
    # follow=True 로 리디렉트 따라가면 최종 요청에서 메시지 확인 가능
    texts = [str(m) for m in storage]
    assert "프로필을 저장했습니다." in texts
```

---

## C. 종합 예제 — “권한 체크 + 메시지 + 로깅/트레이싱 + 보안 헤더” 통합

### C-1. 미들웨어 2종

```python
# apps/common/middleware.py
import uuid
import logging
from contextvars import ContextVar
from django.http import HttpResponseForbidden

logger = logging.getLogger(__name__)
request_id_var = ContextVar("request_id", default="-")

class RequestIDMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    def __call__(self, request):
        rid = request.headers.get("X-Request-ID") or uuid.uuid4().hex
        token = request_id_var.set(rid)
        try:
            response = self.get_response(request)
            response["X-Request-ID"] = rid
            return response
        finally:
            request_id_var.reset(token)

class SecurityHeadersMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    def __call__(self, request):
        resp = self.get_response(request)
        resp.setdefault("X-Content-Type-Options", "nosniff")
        resp.setdefault("X-Frame-Options", "DENY")
        resp.setdefault("Referrer-Policy", "strict-origin-when-cross-origin")
        return resp
```

설정:

```python
MIDDLEWARE = [
    "apps.common.middleware.RequestIDMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "apps.common.middleware.SecurityHeadersMiddleware",
]
```

### C-2. 뷰 + 메시지

```python
# apps/accounts/views.py
from django.contrib.auth.decorators import login_required, permission_required
from django.contrib import messages
from django.shortcuts import redirect, render

@login_required
def profile_save(request):
    if request.method == "POST":
        # 유효성/저장 로직 ...
        messages.success(request, "프로필을 저장했습니다.")
        return redirect("accounts:profile")
    return render(request, "accounts/profile.html")
```

### C-3. 템플릿

```html
<!-- templates/base.html -->
<body>
  {% include "includes/_messages.html" %}
  {% block content %}{% endblock %}
</body>
```

```html
<!-- templates/includes/_messages.html -->
{% if messages %}
  <div class="messages">
    {% for message in messages %}
      <div class="alert alert-{{ message.tags }}" role="alert" data-timeout="3000">
        {{ message }}
      </div>
    {% endfor %}
  </div>
{% endif %}
<script>
  document.addEventListener("DOMContentLoaded", () => {
    document.querySelectorAll(".alert[data-timeout]").forEach(el => {
      setTimeout(() => el.remove(), parseInt(el.dataset.timeout, 10)||3000);
    });
  });
</script>
```

---

## D. 운영 체크리스트 (요약)

**미들웨어**
- [ ] 순서 검토(세션→인증→메시지). 의존성 문서화  
- [ ] 예외/로깅/트레이싱 공통 모듈화(Request ID, 사용자/세션 ID 상관 키)  
- [ ] 보안 헤더 기본값 점검(HSTS는 리버스 프록시 TLS 전략과 함께)  
- [ ] async 뷰와 호환, 스트리밍 응답 시 본문 변형 금지  
- [ ] 설정화(환경변수로 on/off, 샘플링 비율 등)

**메시지**
- [ ] LEVEL 매핑(MESSAGE_TAGS) → UI 프레임워크 연동(Bootstrap/Toast)  
- [ ] 성공/경고/오류 카피라이팅 일관화, 자동 닫기/고정 메시지 규칙  
- [ ] 스토리지(세션/쿠키) 특성 이해, 과도한 텍스트 저장 금지  
- [ ] 폼 에러 + 전역 메시지 조합(요약+세부)  
- [ ] 테스트에서 follow=True 로 리디렉트 후 메시지 검증

---

## E. FAQ

1) **미들웨어에서 DB 쿼리해도 되나요?**  
→ 가능하지만 **최소화**하세요. 특히 모든 요청에서 호출되므로 성능/락/장애 전파 위험이 큽니다.

2) **미들웨어에서 `request.user` 를 읽어도 되나요?**  
→ 가능(단, **AuthenticationMiddleware 이후**여야 함). 위치가 앞이면 `request.user` 가 Anonymous 상태일 수 있습니다.

3) **메시지가 표시되지 않습니다.**  
→ `MessageMiddleware` 가 설정에 있는지, 템플릿에 `{% for message in messages %}` 가 있는지, 리디렉트/렌더 흐름을 점검하세요. 테스트에서는 `follow=True`.

4) **쿠키 스토리지로 충분할까요?**  
→ 소규모/간단한 앱이면 가능하지만, 크기 제한/보안·감사 요구 시 **세션 스토리지**(서버측)가 일반적입니다.

5) **async 미들웨어에서 동기 I/O를 하면?**  
→ 이벤트 루프 블로킹 위험. 가능하면 async 라이브러리/오프로딩을 사용하거나, 해당 처리를 동기 경로로 제한하세요.

---

## F. 추가 스니펫 모음

### F-1. 헤더 기반 로케일 강제(간단 예)

```python
class LocaleHeaderMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    def __call__(self, request):
        lang = request.headers.get("X-Lang")
        if lang:
            request.LANGUAGE_CODE = lang  # i18n 미들웨어와의 조합은 주의
        return self.get_response(request)
```

### F-2. 응답 캐시 무효화 헬퍼

```python
from django.utils.cache import patch_cache_control

class NoCacheMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    def __call__(self, request):
        resp = self.get_response(request)
        patch_cache_control(resp, no_cache=True, no_store=True, must_revalidate=True)
        return resp
```

### F-3. 메시지를 JSON으로 내보내는 API 뷰(하이브리드 UI)

```python
# apps/common/api.py
from django.http import JsonResponse
from django.contrib.messages import get_messages

def messages_json(request):
    msgs = [{"level": m.level, "tags": m.tags, "text": str(m)} for m in get_messages(request)]
    return JsonResponse({"messages": msgs})
```

프런트엔드에서 AJAX 후 토스트로 뿌릴 수 있습니다.

---

## 마무리

- **미들웨어**는 앱 전반의 **정책/보안/로깅/성능**을 지휘하는 레이어입니다. **순서와 라이프사이클**을 정확히 이해하고, **간결·구성 가능**한 커스텀 미들웨어를 작성하세요.  
- **메시지 프레임워크**는 폼/리디렉트 중심의 Django UX에서 핵심입니다. **레벨/스토리지/표시 템플릿**을 표준화하여, **“저장/오류/권한”** 피드백을 일관성 있게 제공합니다.
