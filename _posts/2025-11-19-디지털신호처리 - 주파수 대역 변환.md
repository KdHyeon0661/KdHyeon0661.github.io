---
layout: post
title: 디지털신호처리 - 주파수 대역 변환
date: 2025-11-19 15:25:23 +0900
category: 디지털신호처리
---
# 주파수 대역 변환 — 저역통과를 고역통과·대역통과·대역저지로 바꾸는 법

## 큰 그림: 왜 “주파수 대역 변환”을 배우는가

### 설계 파이프라인 관점

전형적인 IIR 필터 설계 파이프라인을 다시 써보면:

1. **디지털 스펙**:
   - 샘플링 주파수 $$F_s$$
   - 디지털 통과/저지 대역 경계 (예: $$f_{p1}, f_{p2}, f_{s1}, f_{s2}$$ 등)
   - 통과대역 리플 $$A_p$$, 저지대역 감쇠 $$A_s$$

2. **아날로그 주파수로 사상** (bilinear 변환을 쓸 경우):
   $$
   \Omega = \frac{2}{T}\tan\left(\frac{\omega}{2}\right),\quad
   \omega = 2\pi\frac{f}{F_s},\ T = \frac{1}{F_s}
   $$

3. **단위 컷오프 저역통과 원형 아날로그 필터** 설계:
   $$
   H_p(s) = \frac{B_p(s)}{A_p(s)}
   $$

4. **주파수 대역 변환**으로 원하는 아날로그 필터 획득:
   - 저역통과 → 저역통과
   - 저역통과 → 고역통과
   - 저역통과 → 대역통과
   - 저역통과 → 대역저지

5. **아날로그 → 디지털 변환** (bilinear 등):
   $$
   s = \frac{2}{T}\cdot\frac{1 - z^{-1}}{1 + z^{-1}}
   $$

한마디로, **“저역통과 원형 필터만 잘 만들 수 있으면, 나머지 필터는 모두 변환으로 얻는다”**가 핵심이다.

### FIR vs IIR에서의 주파수 대역 변환

- **IIR** 쪽에서는
  - 보통 **아날로그 영역에서의 주파수 변환(s-평면 변환)**을 먼저 하고
  - 그 후 bilinear 등으로 디지털화한다.

- **FIR** 쪽에서는
  - 보통 디지털 영역에서 **스펙트럼 변환**을 한다.
  - 예:
    - 저역통과 FIR → 고역통과 FIR: **스펙트럼 반전**
    - 저역통과 FIR → 대역통과 FIR: **cosine 변조**
    - 대역저지: 1 – 대역통과

이 글에서는 **두 가지 관점(IIR/아날로그, FIR/디지털)** 모두를 다루고, 중간중간 GNU Octave 예제로 확인한다.

---

## 예비 사항: 표기와 전제

### 아날로그 vs 디지털 주파수

- 아날로그(연속시간):
  - $$t$$: 초 단위 시간
  - $$\Omega\ [\mathrm{rad/s}]$$: 아날로그 각주파수
  - $$s = \sigma + j\Omega$$: Laplace 변수

- 디지털(이산시간):
  - $$n$$: 샘플 인덱스
  - $$\omega\ [\mathrm{rad/sample}]$$: 디지털 각주파수
  - $$z = re^{j\omega}$$: Z-변수

샘플링 주파수 $$F_s$$, 샘플링 주기 $$T = 1/F_s$$일 때,

$$
\omega = 2\pi \frac{f}{F_s},\quad
\Omega = \frac{2}{T}\tan\left(\frac{\omega}{2}\right)
$$

은 bilinear 변환에서 사용하는 **주파수 사상** 공식이다.

### 저역통과 원형 필터의 전송함수

Butterworth를 예로 들면, 차수 $$N$$의 단위 컷오프 저역통과 원형 필터는

$$
H_p(s) = \frac{1}{\prod_{k=1}^N (s - s_k)},
$$

여기서 $$s_k$$는 단위원 위에 고르게 분포한 극점 중, **왼쪽 반평면**에 있는 것들이다.

실제 설계에서는 GNU Octave의 `buttap`, `cheb1ap`, `ellipap` 등으로 **원형 아날로그 필터** 계수를 얻는다.

---

## 아날로그 영역 주파수 대역 변환 — s-평면

### 기본 개념

저역통과 원형 필터의 전송함수:

$$
H_p(s) = B_p(s) / A_p(s)
$$

가 있다고 하자. 우리가 원하는 것은:

- 고역통과: $$H_{hp}(s')$$
- 대역통과: $$H_{bp}(s')$$
- 대역저지: $$H_{bs}(s')$$

이 때, 핵심 아이디어는

> **“새 변수 $$s'$$의 필터는, 원래 $$s$$에 적절한 치환을 넣어서 얻는다.”**

즉,

$$
H_{\text{target}}(s') = H_p( F(s') )
$$

형태의 **변수 치환**을 사용한다.

여기서 $$F(s')$$는 저역통과 → 원하는 필터 형식을 만드는 **주파수 변환 함수**다.

### 저역통과 → 저역통과 (컷오프 스케일링)

단위 컷오프 원형 필터에서 실제 컷오프 $$\Omega_c$$를 갖는 저역통과로 바꾸려면:

$$
s \leftarrow \frac{s'}{\Omega_c}
$$

즉,

$$
H_{lp}(s') = H_p\left( \frac{s'}{\Omega_c} \right)
$$

이 된다. 극점은

$$
s'_k = \Omega_c s_k
$$

로 단순 스케일링.

### 저역통과 → 고역통과 (Lowpass → Highpass)

원형 저역통과의 컷오프 1 rad/s를 실제 고역통과 컷오프 $$\Omega_c$$로 옮길 때, 표준 변환은:

$$
s \leftarrow \frac{\Omega_c}{s'}
$$

따라서

$$
H_{hp}(s') = H_p\left( \frac{\Omega_c}{s'} \right).
$$

이 변환의 의미:

- 저주파(원래 저역통과의 통과대역) ↔ 고주파(고역통과의 통과대역)가 서로 **뒤집혀** 매핑된다.
- 극점/영점의 위치도 \(s\)-평면 상에서 상호 교환적으로 이동한다.

### 저역통과 → 대역통과 (Lowpass → Bandpass)

원하는 대역통과 필터의 **중심 주파수**와 **대역폭**을

- 통과대역: $$\Omega_{p1} < |\Omega'| < \Omega_{p2}$$
- 중심 각주파수:
  $$
  \Omega_0 = \sqrt{\Omega_{p1}\Omega_{p2}}
  $$
- 대역폭:
  $$
  B = \Omega_{p2} - \Omega_{p1}
  $$

라고 할 때, 표준 대역변환은

$$
s \leftarrow \frac{s'^2 + \Omega_0^2}{B s'}
$$

이다. 따라서

$$
H_{bp}(s') = H_p\left( \frac{s'^2 + \Omega_0^2}{B s'} \right).
$$

이때 중요한 점:

- 원형 필터의 각 **극점 하나**가 **대역통과에서 극점 두 개**로 분할됨
- 차수 $$N$$의 저역통과 → 차수 $$2N$$의 대역통과

### 저역통과 → 대역저지 (Lowpass → Bandstop)

대역저지 필터는 특정 대역만 억제하고, 나머지는 통과시키는 필터다.

원하는 저지대역:

- $$\Omega_{s1} < |\Omega'| < \Omega_{s2}$$
- 중심:
  $$
  \Omega_0 = \sqrt{\Omega_{s1}\Omega_{s2}},\quad B = \Omega_{s2} - \Omega_{s1}
  $$

표준 변환은

$$
s \leftarrow \frac{B s'}{s'^2 + \Omega_0^2}
$$

이고,

$$
H_{bs}(s') = H_p\left( \frac{B s'}{s'^2 + \Omega_0^2} \right).
$$

역시 차수가 두 배로 늘어난다.

### 요약 표

간단히 정리하면:

| 변환 종류 | 치환식 \(s \leftarrow F(s')\) | 결과 차수 |
|----------|-------------------------------|-----------|
| LP → LP  | \(\displaystyle \frac{s'}{\Omega_c}\) | 동일 |
| LP → HP  | \(\displaystyle \frac{\Omega_c}{s'}\) | 동일 |
| LP → BP  | \(\displaystyle \frac{s'^2 + \Omega_0^2}{B s'}\) | 2배 |
| LP → BS  | \(\displaystyle \frac{B s'}{s'^2 + \Omega_0^2}\) | 2배 |

GNU Octave에서는 이런 변환을 직접 구현하지 않고도, `lp2lp`, `lp2hp`, `lp2bp`, `lp2bs` 함수로 처리할 수 있다.

---

## GNU Octave: 아날로그 주파수 대역 변환 예제

### 원형 Butterworth 저역통과 프로토타입 → 대역통과

스펙:

- 저역통과 **원형**의 차수: $$N = 3$$ (예시)
- 대역통과 원하는 아날로그 통과대역:
  - $$\Omega_{p1} = 2000\ \mathrm{rad/s}$$
  - $$\Omega_{p2} = 6000\ \mathrm{rad/s}$$

GNU Octave 코드:

```octave
pkg load signal;
clear; close all; clc;

% 1) 원형 Butterworth 저역통과 (cutoff=1 rad/s)
N = 3;
[Ba, Aa] = buttap(N);     % analog lowpass prototype (s-domain)

% 2) 대역통과 스펙
Op1 = 2000;               % lower passband edge [rad/s]
Op2 = 6000;               % upper passband edge [rad/s]
O0  = sqrt(Op1*Op2);      % center frequency
B   = Op2 - Op1;          % bandwidth

% 3) 저역통과 -> 대역통과 변환
[Bbp, Abp] = lp2bp(Ba, Aa, O0, B);

% 4) 아날로그 주파수 응답
w = logspace(2, 5, 1000);     % 10^2 ~ 10^5 rad/s
Ha = freqs(Ba, Aa, w);
Hbp = freqs(Bbp, Abp, w);

figure;
semilogx(w, 20*log10(abs(Ha)+eps), 'b-', 'LineWidth', 1.2); hold on;
semilogx(w, 20*log10(abs(Hbp)+eps), 'r-', 'LineWidth', 1.2);
grid on;
xlabel('Analog frequency \Omega [rad/s]');
ylabel('Magnitude (dB)');
title('3rd-order Butterworth Prototype vs Bandpass-transformed');
legend('Prototype LP (cutoff=1)', 'Bandpass (Op1=2000, Op2=6000)');
ylim([-80 5]);
```

설명:

- `buttap(N)`은 cutoff=1 rad/s Butterworth 저역통과 프로토타입의 분자/분모를 준다.
- `lp2bp`는 위에서 정리한
  $$s \leftarrow \frac{s'^2 + \Omega_0^2}{B s'}$$
  변환을 내부적으로 수행한다.
- 그림을 보면, 원형 저역통과는 1 rad/s 주변에서 떨어지고,
  변환된 대역통과는 2000~6000 rad/s 사이에서 통과대역을 가진다.

### 디지털 IIR 대역통과로 이어지는 전체 흐름

이제 위의 아날로그 대역통과를 **디지털 IIR 대역통과**로 바꾸는 예제를 보자.

스펙:

- 샘플링 주파수: $$F_s = 48000\ \mathrm{Hz}$$
- 원하는 디지털 대역통과:
  - 통과대역: 4 kHz ~ 8 kHz
  - 저지대역: 3 kHz 이하, 9 kHz 이상 (예시)
- 원형 필터는 Butterworth.

절차:

1. 디지털 주파수(Hz) → 디지털 각주파수(라디안/샘플) → 아날로그 각주파수(라디안/초, prewarp).
2. 저역통과 프로토타입 기준으로 등가 스펙 계산.
3. `buttap` + `lp2bp`로 아날로그 대역통과 설계.
4. `bilinear`로 디지털화.

GNU Octave 코드(간단형, “직접 lowpass prototype 스펙을 쓰지 않고, 바로 `butter(..., 'bandpass')`와 비교”까지 포함):

```octave
pkg load signal;
clear; close all; clc;

Fs  = 48000;    % sampling freq [Hz]
T   = 1/Fs;

% 디지털 스펙 (Hz)
Fp1 = 4000;     % lower passband edge
Fp2 = 8000;     % upper passband edge
Fs1 = 3000;     % lower stopband edge
Fs2 = 9000;     % upper stopband edge
Ap  = 1;        % passband ripple [dB]
As  = 60;       % stopband attenuation [dB]

% 1) 디지털 주파수 -> 디지털 각주파수
wp1 = 2*pi*Fp1/Fs;
wp2 = 2*pi*Fp2/Fs;
ws1 = 2*pi*Fs1/Fs;
ws2 = 2*pi*Fs2/Fs;

% 2) prewarping (bilinear)
Op1 = (2/T)*tan(wp1/2);
Op2 = (2/T)*tan(wp2/2);
Os1 = (2/T)*tan(ws1/2);
Os2 = (2/T)*tan(ws2/2);

% 대역통과 중심/대역폭
O0  = sqrt(Op1*Op2);
Bp  = Op2 - Op1;

% stopband에서도 대응하는 analog freq를 사용해도 되지만,
% 여기서는 설계 단순화를 위해 passband 중심과 bandwidth만 사용
% (정확한 아날로그 LP 스펙으로 변환하는 자세한 절차는 교과서 참조)

% 3) 원형 Butterworth LP (cutoff=1 rad/s)
N = 4;                  % 예시 차수
[Ba, Aa] = buttap(N);

% 4) LP -> BP 변환
[Bbp, Abp] = lp2bp(Ba, Aa, O0, Bp);

% 5) bilinear 변환으로 디지털 IIR 계수
[bd_bp, ad_bp] = bilinear(Bbp, Abp, Fs);

% 6) 동일 스펙으로 butter(...,'bandpass') 결과와 비교
Wp = [Fp1 Fp2]/(Fs/2);      % normalized passband
[bB, aB] = butter(N, Wp, "bandpass");

Nfft = 4096;
[H1, f] = freqz(bd_bp, ad_bp, Nfft, Fs);
[H2, ~] = freqz(bB, aB,   Nfft, Fs);

figure;
plot(f, 20*log10(abs(H1)+eps), 'b', 'LineWidth', 1.2); hold on;
plot(f, 20*log10(abs(H2)+eps), 'r--', 'LineWidth', 1.2);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title('Bandpass IIR via explicit LP->BP->bilinear vs butter(...,''bandpass'')');
legend('Explicit LP->BP->bilinear', 'butter bandpass', 'Location', 'SouthWest');
ylim([-80 5]);
xlim([0 20000]);
```

- 두 결과는 **정확히 같지는 않을 수** 있지만, 같은 차수/프로토타입일 경우 매우 유사한 특성을 보인다.
- 핵심은: **디지털 bandpass 설계 함수들은 내부에서 “저역통과 원형 + 주파수 대역 변환 + bilinear”를 수행하고 있다**는 점이다.

---

## FIR 필터에서의 주파수 대역 변환 — 스펙트럼 변환

FIR 쪽에서는 **스펙트럼 변환(spectral transformation)**이라는 이름으로 다루는 경우가 많다. 저역통과 FIR 하나를 시작점으로, 다음을 만든다:

- 저역통과 → 고역통과: **스펙트럼 반전(spectral inversion)**
- 저역통과 → 대역통과: **cosine 변조**
- 저역통과 → 대역저지: 1 – 대역통과

### 저역통과 → 고역통과: 스펙트럼 반전

선형 위상 FIR 저역통과 필터의 임펄스 응답을 $$h_{lp}[n]$$, 길이를 $$N+1$$, 중심 인덱스를 $$M = N/2$$라고 하자.

이때, **같은 차수**의 고역통과 FIR을 얻는 가장 흔한 방법은

$$
h_{hp}[n] = \delta[n-M] - h_{lp}[n]
$$

이다. 여기서 $$\delta[n]$$는 단위 임펄스.

해석:

- 단위 임펄스의 주파수 응답은 **모든 주파수에서 1**.
- 저역통과의 주파수 응답을 $$H_{lp}(e^{j\omega})$$라고 하면,
  새 필터의 응답은

  $$
  H_{hp}(e^{j\omega}) = 1 - H_{lp}(e^{j\omega})
  $$

- 저역통과의 통과대역(대략 1 근처)은 크게 줄고, 저지대역(대략 0 근처)은 1에 가까워짐 → 고역통과.

#### GNU Octave 예제 — FIR LPF → HPF

```octave
pkg load signal;
clear; close all; clc;

Fs = 48000;
Fc = 4000;
N  = 64;
Wn = Fc/(Fs/2);

% 1) Hamming 창 FIR 저역통과
b_lp = fir1(N, Wn, hamming(N+1));

% 2) 스펙트럼 반전으로 고역통과
M = N/2;
delta = zeros(1, N+1);
delta(M+1) = 1;           % delta[n-M] => index M+1
b_hp = delta - b_lp;

% 3) 주파수 응답
Nfft = 4096;
[Hlp, f] = freqz(b_lp, 1, Nfft, Fs);
[Hhp, ~] = freqz(b_hp, 1, Nfft, Fs);

figure;
subplot(2,1,1);
plot(f, 20*log10(abs(Hlp)+eps), 'b', 'LineWidth', 1.2); hold on;
plot(f, 20*log10(abs(Hhp)+eps), 'r--', 'LineWidth', 1.2);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title('FIR Lowpass vs Highpass (via spectral inversion)');
legend('Lowpass', 'Highpass');
ylim([-100 5]);
xlim([0 20000]);

subplot(2,1,2);
plot(f, unwrap(angle(Hlp)), 'b', 'LineWidth', 1.0); hold on;
plot(f, unwrap(angle(Hhp)), 'r--', 'LineWidth', 1.0);
grid on;
xlabel('Frequency (Hz)');
ylabel('Phase (rad)');
legend('Lowpass phase', 'Highpass phase');
```

### 저역통과 → 대역통과: cosine 변조(주파수 이동)

FIR에서는 **저역통과를 대역통과로 바꾸는 더 직관적인 방법**으로 “modulation”을 사용한다.

저역통과 FIR의 임펄스 응답을 다시 $$h_{lp}[n]$$, 길이 $$N+1$$, 중심 $$M = N/2$$라고 하자.

디지털 중심 각주파수를 $$\omega_0$$로 하고,
대역통과 필터의 임펄스 응답을

$$
h_{bp}[n] = 2 h_{lp}[n] \cos\{\omega_0 (n-M)\}
$$

라고 두면, 이 필터의 주파수 응답은

- 원래 저역통과 응답이 **\(\omega_0\)**를 중심으로 한 **대역통과**로 이동한 것과 같다.

조금 더 정확히 말하면:

- 저역통과의 주파수 응답: $$H_{lp}(e^{j\omega})$$
- $$h_{bp}[n] = h_{lp}[n] e^{j\omega_0(n-M)}$$ 이라면,
  주파수 응답은 $$H_{lp}(e^{j(\omega - \omega_0)})$$로 **평행 이동**된다.
- 실제로는 실수 필터를 원하므로,
  $$2\cos\{\omega_0 (n-M)\} = e^{j\omega_0 (n-M)} + e^{-j\omega_0 (n-M)}$$
  형태를 이용해 **두 개의 이동된 저역통과 응답**을 합친다.

#### GNU Octave 예제 — FIR LPF → BPF (대역통과)

스펙:

- 디지털 저역통과 FIR: cutoff 0.2 (정규화)
- 이를 중심 0.5\*π 부근의 대역통과로 이동

```octave
pkg load signal;
clear; close all; clc;

Fs = 48000;
Fc_lp = 2000;          % base lowpass cutoff
N   = 64;
Wn  = Fc_lp/(Fs/2);

% 1) 기본 저역통과 FIR (Hamming)
b_lp = fir1(N, Wn, hamming(N+1));

% 2) 원하는 중심 주파수 (예: 10kHz 근처)
Fc_center = 10000;
omega0 = 2*pi*Fc_center/Fs;

M = N/2;
n = 0:N;

b_bp = 2 * b_lp .* cos(omega0 * (n - M));  % bandpass coefficients

% 3) 주파수 응답
Nfft = 4096;
[Hlp, f] = freqz(b_lp, 1, Nfft, Fs);
[Hbp, ~] = freqz(b_bp, 1, Nfft, Fs);

figure;
subplot(2,1,1);
plot(f, 20*log10(abs(Hlp)+eps), 'b', 'LineWidth', 1.2);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title('Base Lowpass FIR');
xlim([0 24000]); ylim([-100 5]);

subplot(2,1,2);
plot(f, 20*log10(abs(Hbp)+eps), 'r', 'LineWidth', 1.2);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title('Bandpass FIR via Cosine Modulation');
xlim([0 24000]); ylim([-100 5]);
```

- 위 코드에서 `b_bp`는 **대역통과 FIR**이 된다.
- 실제 대역폭은 원래 저역통과의 컷오프와 `omega0`에 따라 결정된다.

### 저역통과 → 대역저지: 1 – 대역통과

대역저지 FIR은

- 전체를 통과시키되
- 특정 대역만 억제한다.

대역통과 필터의 응답을 $$H_{bp}(e^{j\omega})$$라고 할 때,

$$
H_{bs}(e^{j\omega}) = 1 - H_{bp}(e^{j\omega})
$$

로 두면, 원하는 **대역저지**가 된다.

임펄스 응답 관점에서는

- $$h_{bp}[n]$$: 대역통과 FIR
- $$h_{bs}[n] = \delta[n-M] - h_{bp}[n]$$ (선형 위상의 경우)

이 동일한 논리를 따라간다.

---

## GNU Octave: FIR 주파수 대역 변환 종합 예제

이번에는 하나의 기본 저역통과 FIR에서 **고역통과 / 대역통과 / 대역저지**를 모두 만들어보자.

스펙:

- $$F_s = 48000\ \mathrm{Hz}$$
- base 저역통과: cutoff = 4 kHz
- 대역통과: 중심 10 kHz, 대략 ±4 kHz 대역
- 대역저지: 위 대역통과에 대한 보완 필터

```octave
pkg load signal;
clear; close all; clc;

Fs = 48000;
Fc_lp = 4000;
N      = 64;
Wn_lp  = Fc_lp/(Fs/2);

% 1) 기본 저역통과 FIR
b_lp = fir1(N, Wn_lp, hamming(N+1));
M    = N/2;
n    = 0:N;

% 2) LP -> HP (spectral inversion)
delta = zeros(1, N+1); delta(M+1) = 1;
b_hp  = delta - b_lp;

% 3) LP -> BP (cos modulation)
Fc_center = 10000;
omega0    = 2*pi*Fc_center/Fs;
b_bp      = 2 * b_lp .* cos(omega0 * (n - M));

% 4) BP -> BS (spectral inversion)
b_bs = delta - b_bp;

% 5) 주파수 응답 비교
Nfft = 4096;
[Hlp, f] = freqz(b_lp, 1, Nfft, Fs);
[Hhp, ~] = freqz(b_hp, 1, Nfft, Fs);
[Hbp, ~] = freqz(b_bp, 1, Nfft, Fs);
[Hbs, ~] = freqz(b_bs, 1, Nfft, Fs);

figure;
subplot(2,2,1);
plot(f, 20*log10(abs(Hlp)+eps), 'LineWidth', 1.2);
grid on;
xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)');
title('Lowpass');

subplot(2,2,2);
plot(f, 20*log10(abs(Hhp)+eps), 'LineWidth', 1.2);
grid on;
xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)');
title('Highpass (LP->HP)');

subplot(2,2,3);
plot(f, 20*log10(abs(Hbp)+eps), 'LineWidth', 1.2);
grid on;
xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)');
title('Bandpass (LP->BP mod)');

subplot(2,2,4);
plot(f, 20*log10(abs(Hbs)+eps), 'LineWidth', 1.2);
grid on;
xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)');
title('Bandstop (BP->BS)');
ylim([-100 5]);
```

이 예제를 실행해 보면:

- **위 왼쪽**: 기본 저역통과
- **위 오른쪽**: 그 보완 고역통과
- **아래 왼쪽**: 중심 10 kHz 근처 대역통과
- **아래 오른쪽**: 그 보완 대역저지

가 각각 잘 나타나는 것을 확인할 수 있다.

---

## 수학 요약: 주파수 대역 변환 공식 모음

### 아날로그 영역 (s-평면)

저역통과 원형 필터 전송함수 $$H_p(s)$$에 대해:

- LP → LP:
  $$
  H_{lp}(s') = H_p\left(\frac{s'}{\Omega_c}\right)
  $$
- LP → HP:
  $$
  H_{hp}(s') = H_p\left(\frac{\Omega_c}{s'}\right)
  $$
- LP → BP:
  $$
  H_{bp}(s') = H_p\left(\frac{s'^2 + \Omega_0^2}{B s'}\right),\quad
  \Omega_0 = \sqrt{\Omega_{p1}\Omega_{p2}},\ B = \Omega_{p2} - \Omega_{p1}
  $$
- LP → BS:
  $$
  H_{bs}(s') = H_p\left(\frac{B s'}{s'^2 + \Omega_0^2}\right)
  $$

bilinear 변환을 사용할 때, 디지털 설계에서 아날로그 스펙은

$$
\Omega = \frac{2}{T}\tan\left(\frac{\omega}{2}\right),
\quad \omega = 2\pi\frac{f}{F_s}
$$

으로 얻는다.

### FIR 스펙트럼 변환

선형 위상 FIR 저역통과 $$h_{lp}[n]$$, 길이 $$N+1$$, 중심 $$M = N/2$$에 대해:

- LP → HP (스펙트럼 반전):

  $$
  h_{hp}[n] = \delta[n-M] - h_{lp}[n]
  $$

- LP → BP (cosine 변조, 중심 각주파수 $$\omega_0$$):

  $$
  h_{bp}[n] = 2\,h_{lp}[n]\cos\{\omega_0(n-M)\}
  $$

- BP → BS (보완 필터):

  $$
  h_{bs}[n] = \delta[n-M] - h_{bp}[n]
  $$

---

## 연습문제 (코드/풀이 아이디어 포함)

### 문제 1 — IIR 대역통과 vs FIR 대역통과 비교

1. 디지털 스펙:
   - $$F_s = 48000\ \mathrm{Hz}$$
   - 대역통과 통과대역: 5 kHz ~ 7 kHz
   - 대역통과 저지대역: 4 kHz 이하, 8 kHz 이상
   - $$A_p = 1\ \mathrm{dB},\ A_s = 60\ \mathrm{dB}$$
2. Butterworth IIR 대역통과:
   - `ellipord`/`ellip` 또는 `buttord`/`butter(...,"bandpass")`로 설계.
3. FIR 대역통과:
   - 창함수 FIR 저역통과 설계 후, cosine 변조로 대역통과 생성.
4. 두 필터를 모두 동일한 테스트 신호(예: 6 kHz 톤 + 2 kHz 톤 + 10 kHz 톤)에 적용하고,
   - 통과/저지 특성을 주파수 스펙트럼으로 비교
   - 위상/군지연 차이를 비교해 보라.

### 문제 2 — FIR LP → HP → BS 체인

1. `fir1`로 저역통과 FIR을 설계하라.
2. 스펙트럼 반전으로 고역통과 FIR을 만든다.
3. cosine 변조로 대역통과 FIR을 만든다.
4. 3)의 대역통과 FIR을 이용해 대역저지 FIR을 만든다.
5. 원래 저역통과, 고역통과, 대역통과, 대역저지 네 필터를 하나의 그림에 주파수 응답으로 그려라.
6. 같은 길이의 white noise를 네 필터 각각에 통과시켜, 대역별 에너지 변화를 수치로 비교해 보라.

### 문제 3 — 아날로그 주파수 대역 변환 직접 구현

1. `buttap(4)`로 4차 Butterworth 저역통과 프로토타입의 극점들을 얻어라.
2. 수식
   $$
   s \leftarrow \frac{s'^2 + \Omega_0^2}{B s'}
   $$
   을 직접 구현해 각 극점을 대역통과 극점 2개로 변환하는 코드를 작성하라.
3. 변환된 극점들로부터 다항식 분모를 재구성하고, `lp2bp`의 결과와 일치하는지 확인하라.
4. 대역저지 변환( LP → BS )도 같은 방식으로 직접 구현해 보라.

---

## 정리

이 글에서는 **주파수 대역 변환(frequency band transformation)**을

- **아날로그 영역(s-평면)**에서의 저역통과 → 고역통과/대역통과/대역저지 변환
- **디지털 FIR**에서의 스펙트럼 변환(스펙트럼 반전, cosine 변조, 보완 필터)
- **GNU Octave 구현**(Butterworth 프로토타입, `lp2bp`, `bilinear`, FIR LP→HP/BP/BS 변환)

이라는 세 가지 관점으로 정리했다.

앞에서 다룬

- 원형 아날로그 필터(Butterworth, Chebyshev, Elliptic)
- bilinear 변환을 통한 아날로그–디지털 필터 변환
- GNU Octave 기반 저역통과 FIR/IIR 설계

내용과 자연스럽게 이어지는 주제이며,
실무적으로는 **“한 번 만든 저역통과 필터를 활용해 다양한 대역 필터를 얻는 기술”**로 이해하면 된다.

이제 여기서 정리한 공식과 Octave 코드를 그대로 가져다가

- 오디오 이퀄라이저의 각 밴드,
- 통신 시스템의 채널 필터,
- 센서 데이터의 특정 대역 노이즈 제거

같은 실제 시나리오에 바로 적용해 볼 수 있다.
