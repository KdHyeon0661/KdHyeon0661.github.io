---
layout: post
title: 이산수학 - 수학적 귀납법
date: 2025-05-29 21:20:23 +0900
category: 이산수학
---
# 수학적 귀납법(Mathematical Induction)

## 0. 개요와 핵심 요약

수학적 귀납법은 자연수 집합에서 어떤 명제 $$P(n)$$ 이 **모든 충분히 큰 $$n$$**(보통 $$n\ge n_0$$)에 대해 참임을 보이는 표준 기법이다. 구조:

1) **기초 단계(Base step)**: $$P(n_0)$$ 가 참임을 보인다.
2) **귀납 단계(Inductive step)**: 임의의 $$k\ge n_0$$ 에 대해 $$P(k)$$ 가 참이라고 가정(귀납 가정)하면, $$P(k+1)$$ 도 참임을 보인다.

이 두 단계를 만족하면 **모든 $$n\ge n_0$$ 에 대해 $$P(n)$$ 이 참**이다.

변형:
- **강한 귀납법(complete induction)**: $$P(n_0), P(n_0+1),\dots, P(k)$$ 가 참이면 $$P(k+1)$$ 이 참.
- **최소 반례법(minimal counterexample)**: 반례 중 가장 작은 것을 가정해 모순 유도. 강한 귀납과 본질적으로 동치.
- **구조적 귀납법(structural induction)**: 자연수 대신 재귀적 데이터 구조(리스트, 트리 등) 크기에 대한 귀납.

---

## 1. 형식화: 귀납 공리와 동치 원리

자연수의 부분집합 $$S\subseteq\mathbb{N}$$ 가 다음 두 성질을 가지면 $$S=\{n\in\mathbb{N}: n\ge n_0\}$$ 이다.

- (i) $$n_0\in S$$
- (ii) $$k\in S\Rightarrow k+1\in S$$

이는 **자연수의 기초 성질**이며, **수학적 귀납법**의 논리적 근거다. 또한 **정렬원리(모든 비공집합의 자연수 집합은 최소원소를 갖는다)** 와 동치이며, 강한 귀납법과도 동치다.

---

## 2. 표준 귀납 스키마(서식)

증명할 명제: 모든 $$n\ge n_0$$ 에 대해 $$P(n)$$.

- **기초 단계**: $$P(n_0)$$ 를 계산 또는 정의로부터 확인.
- **귀납 단계**: 임의의 $$k\ge n_0$$ 에서 $$P(k)$$ 가 참이라 가정. 이 가정만을 사용해 대수/부등식/조합식 변형으로 $$P(k+1)$$ 을 도출.

부등식에서는 마지막에 **단조성, 양수성** 등의 조건을 빠뜨리지 않도록 주의한다.

---

## 3. 예제 A — 등차합 공식

명제 $$P(n):\ \ 1+2+\cdots+n=\dfrac{n(n+1)}{2}$$, $$n\ge 1$$.

- **기초 단계** $$n=1$$: 좌변 $$1$$, 우변 $$1(2)/2=1$$. 성립.
- **귀납 단계**: $$P(k)$$ 가정 즉 $$1+\cdots+k=\dfrac{k(k+1)}{2}$$. 그러면
$$
1+\cdots+k+(k+1)
=\frac{k(k+1)}{2}+(k+1)
=\frac{(k+1)(k+2)}{2},
$$
즉 $$P(k+1)$$ 성립.

---

## 4. 예제 B — 제곱합 공식

명제 $$P(n):\ \ 1^2+2^2+\cdots+n^2=\dfrac{n(n+1)(2n+1)}{6}$$.

- **기초 단계** $$n=1$$: 좌변 $$1$$, 우변 $$\dfrac{1\cdot2\cdot3}{6}=1$$.
- **귀납 단계**: $$P(k)$$ 가정 후
$$
\sum_{i=1}^{k+1} i^2=\sum_{i=1}^{k} i^2+(k+1)^2
=\frac{k(k+1)(2k+1)}{6}+(k+1)^2
=(k+1)\left(\frac{k(2k+1)}{6}+k+1\right)
=\frac{(k+1)(k+2)(2k+3)}{6}.
$$

---

## 5. 예제 C — 지수 vs 다항: $$2^n > n^2\ (n\ge 5)$$

- **기초 단계** $$n=5$$: $$2^5=32>25=5^2$$.
- **귀납 단계**: $$2^k>k^2$$ (가정, $$k\ge 5$$). 그러면
$$
2^{k+1}=2\cdot 2^k>2k^2.
$$
이제 $$2k^2>(k+1)^2$$ 만 보이면 된다:
$$
2k^2-(k+1)^2=k^2-2k-1=(k-1)^2-2>0\ \ (\text{모든 }k\ge 5).
$$
따라서 $$2^{k+1}>(k+1)^2$$.

보조 사실: 보다 약한 부등식 $$2^n\ge n+1\ (n\ge 0)$$ 도 동일 방식으로 귀납 가능.

---

## 6. 예제 D — 나눗셈(정수론) 귀납: $$7\mid (8^n-1)$$

명제 $$P(n):\ 8^n\equiv 1\pmod7,\ n\ge 1$$.

- **기초 단계** $$n=1$$: $$8\equiv 1\pmod 7$$.
- **귀납 단계**: $$8^k\equiv 1\pmod 7$$ 가정. 그러면
$$
8^{k+1}\equiv 8\cdot 1\equiv 1\pmod 7.
$$
따라서 모든 $$n\ge 1$$ 에서 성립.

비슷한 형태로 $$3\mid (2^{2n}-1)$$ 등을 다룰 수 있다.

---

## 7. 예제 E — 이항정리(스케치) 귀납

명제: 모든 정수 $$n\ge 0$$,
$$
(x+y)^n=\sum_{k=0}^{n}\binom{n}{k}x^{n-k}y^k.
$$

- **기초 단계** $$n=0$$: 좌변 $$1$$, 우변 $$\binom{0}{0}x^0y^0=1$$.
- **귀납 단계**: $$n=k$$ 성립 가정, $$n=k+1$$ 에 대해
$$
(x+y)^{k+1}=(x+y)\sum_{j=0}^k \binom{k}{j}x^{k-j}y^j
=\sum_{j=0}^{k} \binom{k}{j}\big(x^{k+1-j}y^{j}+x^{k-j}y^{j+1}\big)
$$
지수를 정리하고 파스칼 항등식 $$\binom{k}{j}+\binom{k}{j-1}=\binom{k+1}{j}$$ 를 적용하면 귀납이 완성된다.

---

## 8. 강한 귀납법(complete induction)

표준 귀납과 논리적으로 동치이나, 귀납 단계에서 **하나가 아닌 여러 이전 단계**를 활용한다.

### 8.1 예: 모든 정수 $$n\ge 2$$ 는 소수의 곱(산술의 기본정리의 존재성 부분)

- **기초 단계** $$n=2$$ 은 소수.
- **귀납 단계**: 임의의 $$k\ge 2$$ 에 대해, $$2\le m\le k$$ 인 모든 정수는 소수의 곱으로 표현 가능하다고 가정.
  $$k+1$$ 이 소수면 끝. 합성수이면 $$k+1=ab\ (2\le a,b\le k)$$. 귀납 가정으로 $$a,b$$ 는 소수의 곱, 곱하면 $$k+1$$ 도 소수의 곱.

### 8.2 예: 피보나치 상계
$$
F_0=0,\ F_1=1,\ F_n=F_{n-1}+F_{n-2}\ (n\ge 2).
$$
목표: $$F_n\le 2^{n-1}\ (n\ge 1)$$.
두 개의 기초 단계 $$n=1,2$$ 를 확인하고, 귀납 단계에서 $$F_{k+1}=F_k+F_{k-1}\le 2^{k-1}+2^{k-2}=2^{k-2}(2+1)=\tfrac{3}{4}\cdot 2^k<2^k$$ 등을 이용. 더 날카로운 경계는 $$\varphi^n/\sqrt5$$ 이고, 그 증명에도 강한 귀납이 잘 맞는다.

---

## 9. 최소 반례법(minimal counterexample)

명제가 거짓이라고 가정하고, 반례들의 집합이 비어있지 않다면 정렬원리로 **가장 작은 반례 $$n^\*$$** 가 존재. 그런데 보통 $$n^\*$$ 에 대해 명제가 거짓이려면 그보다 작은 값들에서의 참을 사용해 모순이 생긴다. 따라서 반례가 존재하지 않는다.

예: §8.1의 소수 곱 존재성은 최소 반례법으로도 쉽게 증명된다.

---

## 10. 구조적 귀납법(structural induction)

자연수가 아닌 **재귀적 자료구조**에 대해 귀납을 수행한다.

### 10.1 예: 이진 트리에서 간선 수 = 노드 수 − 1 (유한, 비공집합 트리)

정의:
- 빈 트리는 노드 0, 간선 0.
- 비빈 트리는 루트 1개와 좌/우 서브트리 결합.

명제 $$P(T):\ \text{트리 }T\text{ 에서 }E(T)=V(T)-1$$.

- **기초 단계**: 빈 트리는 $$0=0-1$$ 이 아님에 유의. 보통 비빈 트리를 기준으로 귀납하거나, 루트 1개 트리를 기초로 한다: $$V=1,E=0\Rightarrow 0=1-1$$.
- **귀납 단계**: $$T$$ 의 좌우 서브트리 $$L,R$$ 에 대해 $$E(L)=V(L)-1,\ E(R)=V(R)-1$$ 가정. 트리를 합치면
$$
V(T)=1+V(L)+V(R),\quad E(T)=E(L)+E(R)+1.
$$
대입하면
$$
E(T)=\big(V(L)-1\big)+\big(V(R)-1\big)+1=V(L)+V(R)-1=V(T)-1.
$$

### 10.2 예: 리스트의 길이와 연결 연산
모든 리스트 $$x,y$$ 에 대해 $$|x\mathbin{++}y|=|x|+|y|$$ 는 $$x$$ 의 구조에 대한 구조적 귀납으로 증명.

---

## 11. 이중 귀납(double induction)과 다중 귀납

두 변수의 명제 $$P(m,n)$$ 에서
- 기초 단계: 예를 들어 $$P(0,n)$$ 과 $$P(m,0)$$.
- 귀납 단계: $$P(m-1,n), P(m,n-1)$$ 로부터 $$P(m,n)$$.

### 11.1 예: 이항계수의 항등식
$$
\binom{m}{n}=\binom{m-1}{n}+\binom{m-1}{n-1}
$$
는 두 변수에 대한 귀납으로 정리 가능.

---

## 12. 역귀납(backward induction), 무한 강하(infinite descent)

- **역귀납**: 유한 단계의 게임/결정에서 마지막 상태부터 거꾸로.
- **무한 강하**: 자연수의 하강 무한열 불가를 이용(페르마의 고전 기법), 최소 반례법과 친족.

---

## 13. 알고리즘 정당성: 루프 불변식과 귀납

루프 불변식은 “루프의 각 반복 시작 시 참인 성질”.
- **초기화**: 첫 반복 전 참.
- **유지**: 한 반복을 거쳐도 참.
- **종료**: 루프 종료 조건과 함께 목표 성질 도출.
이는 **반복 인덱스에 대한 귀납**의 프로그래밍 버전이다.

### 13.1 삽입정렬(insertion sort) 불변식
불변식: 인덱스 $$i$$ 에서 부분배열 $$A[0..i-1]$$ 는 정렬되어 있다.
- 초기: $$i=1$$ 이면 길이 1은 정렬.
- 유지: 키를 앞쪽으로 이동하며 삽입하면 정렬 유지.
- 종료: $$i=n$$ 에서 전 배열 정렬.

---

## 14. 복잡도 귀납: 병합정렬의 $$O(n\log n)$$

점화 $$T(1)=\Theta(1),\ \ T(n)=2T(\lfloor n/2\rfloor)+cn$$.
목표: $$T(n)\le C n\log_2 n$$ (충분히 큰 $$n$$, 적절한 $$C$$).
귀납 가정으로 $$T(\lfloor n/2\rfloor)\le C \lfloor n/2\rfloor \log_2 \lfloor n/2\rfloor\le C\frac{n}{2}\log_2\frac{n}{2}$$.
그러면
$$
T(n)\le 2\cdot C\frac{n}{2}\left(\log_2 n-1\right)+cn
= Cn\log_2 n - Cn + cn
\le Cn\log_2 n
$$
이 되도록 $$C\ge c$$ 를 택하면 된다.
(정밀하려면 작은 $$n$$ 에 대한 기초 구간을 정하고 상수 조정.)

---

## 15. 흔한 함정과 반례

1) **중첩 영역 누락**: “모든 말의 색이 같다”라는 잘못된 귀납은 $$k\to k+1$$ 에서 두 집합의 **겹치는 개체 부재** 때문에 실패한다(특히 $$k=1\to 2$$).
2) **부등식에서 음수 곱/나눗셈**: 부등식 방향 전환 여부를 잊지 않기.
3) **기초 단계 부족**: 2차 선형 점화(예: 피보나치)에는 **두 개의 기초 단계**가 필요.
4) **정의역 오해**: $$n\ge n_0$$ 를 명확히. 진술과 기초 단계의 시작점 일치 필요.
5) **귀납 가정 남용**: $$P(k)$$ 가정에서 **정말 가정한 것만** 사용한다.

---

## 16. 파이썬으로 소규모 검증(실험은 증명이 아니지만 유익한 점검)

```python
# 등차합/제곱합/정수나눗셈/지수-다항 비교를 n의 작은 구간에서 검사
def sum_arith(n):
    return n * (n + 1) // 2

def sum_squares(n):
    return n * (n + 1) * (2 * n + 1) // 6

def check_arith(N=200):
    for n in range(1, N + 1):
        assert sum(range(1, n + 1)) == sum_arith(n)
    return True

def check_squares(N=200):
    for n in range(1, N + 1):
        assert sum(i * i for i in range(1, n + 1)) == sum_squares(n)
    return True

def check_divisibility(power=8, mod=7, N=100):
    for n in range(1, N + 1):
        assert pow(power, n, mod) == 1  # 8^n ≡ 1 (mod 7)
    return True

def check_exp_vs_poly(N=200):
    for n in range(5, N + 1):
        assert (1 << n) > n * n
    return True

print("arith:", check_arith())
print("squares:", check_squares())
print("8^n≡1 mod 7:", check_divisibility())
print("2^n > n^2 for n≥5:", check_exp_vs_poly())
```

---

## 17. 자주 쓰는 귀납 패턴 모음

- **곱셈 패턴**: $$\prod_{k=1}^n (1+a_k) = 1 + \sum a_k + \text{(고차항)}$$ 류의 전개를 귀납으로 정리.
- **분할 정복 점화**: $$T(n)=aT(n/b)+f(n)$$ 에 대해 **거듭제곱의 $$n$$** 또는 **로그 바운드** 형태로 귀납.
- **조합 항등식**: 파스칼 항등식, 합-곱 전개를 귀납으로 정리.
- **부등식**: 코시-슈바르츠, AM-GM 전개 전 귀납적 보조부등식(예: $$1+x\le e^x$$ 의 다항 근사).
- **그래프 귀납**: 정점 수에 대한 귀납으로 연결성/스패닝 트리 성질(정점 하나 제거 후 귀납 가정 적용).

---

## 18. 시작점과 다중 기초 단계

- 시작점 $$n_0$$ 가 0인지 1인지 문제에 따라 다르다. 진술과 기초 단계가 일치해야 한다.
- 선형 점화식 차수가 $$d$$ 면 **기초 단계 $$d$$ 개**가 필요(예: $$F_0,F_1$$).

---

## 19. 연습문제(해설 스케치 포함)

1) 모든 $$n\ge 1$$ 에 대해 $$\sum_{k=1}^n (2k-1)=n^2$$.
   스케치: 표준 귀납.

2) 모든 $$n\ge 1$$ 에 대해 $$n!\ge 2^{n-1}$$.
   스케치: $$k!\ge 2^{k-1}\Rightarrow (k+1)!\ge 2^k$$.

3) 모든 $$n\ge 1$$ 에 대해 $$3\mid (2^{2n}-1)$$.
   스케치: 모듈러 귀납 또는 $$2^2\equiv 1\pmod 3$$ 이용.

4) 모든 $$n\ge 1$$ 에 대해 $$\sum_{k=0}^n \binom{n}{k}=2^n$$.
   스케치: 이항정리 $$x=y=1$$ 대입 또는 이중 귀납.

5) 모든 $$n\ge 1$$ 에 대해 $$\sum_{k=1}^{n} k^3=\left(\dfrac{n(n+1)}{2}\right)^2$$.
   스케치: 등차합 제곱과의 연결을 귀납으로 확인.

6) 강한 귀납: 모든 $$n\ge 2$$ 에 대해 $$n$$ 은 소수의 곱.
   스케치: §8.1.

7) 구조적 귀납: 길이 $$n$$ 리스트를 뒤집는 연산의 자기역원성, 즉 $$\mathrm{rev}(\mathrm{rev}(x))=x$$.
   스케치: 빈 리스트와 머리-꼬리 분해에 대해 구조적 귀납.

---

## 20. 마무리 정리

- 표준 귀납은 **기초 단계 + 한 단계 전진** 구조.
- 강한 귀납/최소 반례법/정렬원리는 **상호 동치**.
- 구조적 귀납은 자연수 대신 **재귀 구조**에 대한 귀납.
- 알고리즘 정당성(루프 불변식), 점화 시간복잡도, 조합 항등식, 부등식 증명에서 **귀납은 실전 도구**다.
- 함정을 피하려면: 시작점 일치, 필요한 기초 단계 수, 가정 사용의 정당성, 부등식의 방향 관리 등을 체크리스트로 점검하라.

이상으로 수학적 귀납법의 개념, 변형, 자주 쓰는 패턴, 대표 예제, 코드 기반의 소규모 검증까지 체계적으로 정리했다. 추가로 원한다면 특정 분야(그래프, 수론, 알고리즘)의 귀납 예제만 모아 심화 편을 구성할 수 있다.
