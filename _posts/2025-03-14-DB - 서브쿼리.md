---
layout: post
title: DB - 서브쿼리
date: 2025-03-14 19:20:23 +0900
category: DB
---
# 서브쿼리(Subquery)

- 위치별(SELECT / WHERE·HAVING / FROM) + 상관/비상관 + 반환 형태(스칼라/단일행/다중행/다중열) 총정리
- **EXISTS vs IN vs ANY/ALL** 정확한 의미·NULL 함정·성능
- **튜플(다중열) 서브쿼리**와 부분 순위/그룹 상위 추출
- **인라인 뷰·파생 테이블·LATERAL(PSQL) / CROSS/OUTER APPLY(SQL Server)** 패턴
- UPDATE/DELETE/MERGE에서의 서브쿼리
- **NOT IN vs NOT EXISTS**의 진실(3치 논리, NULL 섞임)
- 최적화 전략: 인덱스·반상관화(Join Rewriting)·세미/안티 조인·CTE/윈도 대체
- 대표 실전 패턴(관계 나눗셈, “모든 카테고리를 산 고객”, Top-N per group, 최신 레코드 조인 등)

---

## 공통 샘플 스키마

```sql
CREATE TABLE Employee (
  emp_id       BIGINT PRIMARY KEY,
  name         VARCHAR(100),
  department   VARCHAR(50),
  manager_id   BIGINT NULL,
  hire_date    DATE,
  salary       DECIMAL(12,2),
  email        VARCHAR(200) NULL
);

CREATE TABLE Department (
  dept_id      BIGINT PRIMARY KEY,
  department   VARCHAR(50) UNIQUE,
  location     VARCHAR(50)
);

CREATE TABLE Orders (
  order_id     BIGINT PRIMARY KEY,
  customer_id  BIGINT,
  order_date   DATE,
  status       VARCHAR(20),
  total_amount DECIMAL(12,2)
);

CREATE TABLE Customer (
  customer_id  BIGINT PRIMARY KEY,
  name         VARCHAR(100),
  grade        VARCHAR(20),  -- VIP/GOLD/SILVER/BRONZE
  email        VARCHAR(200)
);

-- 인덱스 예시
CREATE INDEX idx_emp_dept ON Employee(department);
CREATE INDEX idx_emp_mgr  ON Employee(manager_id);
CREATE INDEX idx_ord_cust_date ON Orders(customer_id, order_date DESC);
CREATE INDEX idx_dept_name ON Department(department);
```

---

## 서브쿼리 분류 총괄

### 위치별

| 위치 | 요약 | 대표 용도 |
|---|---|---|
| SELECT | 스칼라(단일값)만 허용 | 요약값, 파생 컬럼 |
| WHERE/HAVING | 조건 생성 | 존재/비교/집합 포함 여부 |
| FROM | 인라인 뷰(파생 테이블) | 사전 집계/정렬 후 재조합 |

### 상관 여부

- **비상관 서브쿼리**: 외부 컬럼 참조 없음(독립 실행 가능) → 보통 **한 번** 평가 또는 효율적 캐시.
- **상관 서브쿼리**: 외부 컬럼 참조(행마다 반복) → **반복 실행 비용** ↑ → **반상관화(Join 변환)** 고려.

### 반환 형태

| 형태 | 연산자/용도 |
|---|---|
| 스칼라(단일값) | =, <, > 등 단일 비교 / SELECT 절 |
| 단일행 | =, <, > 등 (에러 방지: 2행 이상 나오지 않게 보장해야 함) |
| 다중행 | IN, EXISTS, ANY/SOME, ALL |
| 다중열(튜플) | `(col1, col2) IN (SELECT c1, c2 ...)` 등 |

---

## SELECT 절(스칼라 서브쿼리)

```sql
-- 모든 직원 행에 '회사 평균 급여' 붙이기 (비상관 스칼라)
SELECT
  e.emp_id, e.name, e.department, e.salary,
  (SELECT AVG(salary) FROM Employee) AS company_avg_salary
FROM Employee e;
```

- 내부 쿼리가 **1행 1열**만 반환해야 한다.
- **큰 테이블**에서 다수 파생 스칼라 서브쿼리는 비용↑.
  **대안**: 미리 CTE/인라인 뷰로 평균을 구해 **조인**.

```sql
WITH avg_sal AS (
  SELECT AVG(salary) AS company_avg_salary FROM Employee
)
SELECT e.*, a.company_avg_salary
FROM Employee e CROSS JOIN avg_sal a;
```

---

## WHERE/HAVING 절 — 비교/존재/집합

### 단일행 서브쿼리(=, >, < 등)

```sql
-- HR 부서 최고 연봉보다 높은 직원
SELECT name, salary
FROM Employee
WHERE salary > (
  SELECT MAX(salary) FROM Employee WHERE department = 'HR'
);
```

- 내부가 **정확히 1행**을 반환해야 안전(그렇지 않으면 일부 DB에서 에러).

### / ALL

#### IN

```sql
-- 서울(SEOUL) 근무 부서의 직원
SELECT e.name
FROM Employee e
WHERE e.department IN (
  SELECT d.department FROM Department d WHERE d.location = 'SEOUL'
);
```

- **집합 멤버십** 테스트. 내부 결과가 많아지면 비교 비용↑.

#### EXISTS (세미-조인)

```sql
-- 서울 부서 존재 시 그 부서 직원만 (조건 만족 즉시 TRUE)
SELECT e.name
FROM Employee e
WHERE EXISTS (
  SELECT 1 FROM Department d
  WHERE d.department = e.department
    AND d.location   = 'SEOUL'
);
```

- **조건 만족 첫 행 찾는 즉시 TRUE** → 대개 **IN보다 유리**.
- 옵티마이저가 **세미-조인**으로 변환하면 빠르다.

#### NOT IN vs NOT EXISTS (안티-조인)

```sql
-- "서울 부서가 아닌" 직원 (NULL 함정 피하려면 NOT EXISTS 권장)
SELECT e.name
FROM Employee e
WHERE NOT EXISTS (
  SELECT 1
  FROM Department d
  WHERE d.department = e.department
    AND d.location   = 'SEOUL'
);
```

> **중요**: `NOT IN (subquery)`는 **subquery 결과에 NULL이 1개라도 있으면 전체가 UNKNOWN**이 되어 **빈 결과**가 날 수 있다.
> 안전한 안티 필터는 **NOT EXISTS**.

#### ANY / SOME / ALL

```sql
-- 급여가 'HR 부서 모든 급여 중 최소 하나'보다 크다: > ANY(...)
SELECT name
FROM Employee
WHERE salary > ANY (
  SELECT salary FROM Employee WHERE department = 'HR'
);

-- 'HR 부서의 모든 급여'보다 크다: > ALL(...)
SELECT name
FROM Employee
WHERE salary > ALL (
  SELECT salary FROM Employee WHERE department = 'HR'
);
```

- `> ANY` = `>` **중 최소 하나와 비교** → **최솟값**보다 크다와 동일.
- `> ALL` = 모든 값보다 크다 → **최댓값**보다 크다.

### HAVING과 결합

```sql
-- 부서별 평균 급여가 '회사 전체 평균' 이상인 부서만
SELECT department, AVG(salary) AS avg_sal
FROM Employee
GROUP BY department
HAVING AVG(salary) >= (SELECT AVG(salary) FROM Employee);
```

---

## FROM 절 — 인라인 뷰 / 파생 테이블 / LATERAL/APPLY

### 인라인 뷰(파생 테이블)

```sql
-- 부서별 평균을 먼저 만들고, 이 테이블과 원본과 조인
SELECT e.emp_id, e.name, e.department, e.salary, d.avg_sal
FROM Employee e
JOIN (
  SELECT department, AVG(salary) AS avg_sal
  FROM Employee
  GROUP BY department
) d
ON e.department = d.department
WHERE e.salary >= d.avg_sal;
```

- **파생 결과**를 JOIN할 수 있어 복잡한 로직 분리에 유용.

### / CROSS APPLY (SQL Server)

“왼쪽 행 **마다** 오른쪽 서브쿼리를 실행”하는 **상관 FROM 서브쿼리**.

```sql
-- PostgreSQL: LATERAL
SELECT c.customer_id, c.name, x.last_order_id, x.last_date, x.last_amount
FROM Customer c
LEFT JOIN LATERAL (
  SELECT o.order_id AS last_order_id, o.order_date AS last_date, o.total_amount AS last_amount
  FROM Orders o
  WHERE o.customer_id = c.customer_id
  ORDER BY o.order_date DESC
  LIMIT 1
) x ON true;

-- SQL Server: CROSS APPLY
SELECT c.customer_id, c.name, x.last_order_id, x.last_date, x.last_amount
FROM Customer c
CROSS APPLY (
  SELECT TOP (1) o.order_id AS last_order_id, o.order_date AS last_date, o.total_amount AS last_amount
  FROM Orders o
  WHERE o.customer_id = c.customer_id
  ORDER BY o.order_date DESC
) x;
```

- **각 고객의 최신 주문 1건**을 간결하게 가져올 때 매우 강력.
- MySQL 8+는 **LATERAL 키워드 없음**. 대신 **세미 조인 + 윈도 함수**나 **서브쿼리** 트릭 사용.

---

## 서브쿼리

```sql
-- (department, manager_id) 쌍이 일치하는 직원만
SELECT emp_id, name
FROM Employee
WHERE (department, manager_id) IN (
  SELECT department, manager_id FROM Employee WHERE salary >= 10000
);
```

- DBMS별 지원 차이 있음(MySQL·PostgreSQL·Oracle·SQL Server 대부분 가능하나, 구버전/모드 차이 주의).

---

## 리라이팅

### — 느리다

```sql
SELECT e.*
FROM Employee e
WHERE e.salary >= (
  SELECT AVG(salary) FROM Employee WHERE department = e.department
);
```

### 조인 변환(권장)

```sql
WITH dept_avg AS (
  SELECT department, AVG(salary) AS avg_sal
  FROM Employee
  GROUP BY department
)
SELECT e.*
FROM Employee e
JOIN dept_avg d ON d.department = e.department
WHERE e.salary >= d.avg_sal;
```

- **평균 1회 계산 → 모든 e와 조인**. 보통 훨씬 빠르다.

---

## UPDATE/DELETE/MERGE에서 서브쿼리

```sql
-- UPDATE: 부서 평균 이상이면 3% 인상
UPDATE Employee e
SET salary = salary * 1.03
WHERE salary >= (
  SELECT AVG(salary) FROM Employee WHERE department = e.department
);

-- DELETE: 최근 1년간 주문 기록 없는 고객 삭제(안티 세미-조인)
DELETE FROM Customer c
WHERE NOT EXISTS (
  SELECT 1 FROM Orders o
  WHERE o.customer_id = c.customer_id
    AND o.order_date >= CURRENT_DATE - INTERVAL '365 days'
);

-- MERGE: Oracle/SQL Server - 서브쿼리로 upsert 조건 제어 가능
```

> DML에서 서브쿼리는 강력하지만, **테스트/락 경합/트랜잭션 크기**를 주의.

---

## 대표 실전 패턴

### “모든 카테고리를 산 고객” — 관계 나눗셈(Division)

**요구**: 고객이 **주어진 카테고리 집합 S의 모든 요소**를 구매했는가?

```sql
-- S: 관심 카테고리 집합 (예: ELECTRONICS, FASHION)
WITH S AS (
  SELECT 'ELECTRONICS' AS category UNION ALL
  SELECT 'FASHION'
),
cust_cat AS (
  SELECT DISTINCT o.customer_id, p.category
  FROM Orders o
  JOIN Products p ON p.product_id = o.product_id
)
SELECT c.customer_id
FROM Customer c
WHERE NOT EXISTS (
  SELECT 1
  FROM S
  WHERE NOT EXISTS (
    SELECT 1
    FROM cust_cat cc
    WHERE cc.customer_id = c.customer_id
      AND cc.category    = S.category
  )
);
```

- **이중 NOT EXISTS** = “S의 어떤 항목도 빠짐없이 존재한다.”

### — 상관 서브쿼리 vs 윈도

```sql
-- 각 부서 상위 3명: 상관 서브쿼리 버전(가독성↓/비용↑ 가능)
SELECT e1.*
FROM Employee e1
WHERE 3 > (
  SELECT COUNT(*)
  FROM Employee e2
  WHERE e2.department = e1.department
    AND e2.salary > e1.salary
);

-- 윈도 함수(권장)
SELECT *
FROM (
  SELECT e.*, ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC) AS rn
  FROM Employee e
) x
WHERE rn <= 3;
```

### 최신 레코드 조인 (세미-조인 + MAX 서브쿼리)

```sql
-- 고객별 최신 주문과 조인
SELECT c.customer_id, c.name, o.order_id, o.order_date, o.total_amount
FROM Customer c
JOIN Orders o
  ON o.customer_id = c.customer_id
 AND o.order_date = (
   SELECT MAX(order_date) FROM Orders WHERE customer_id = c.customer_id
 );
```

- 동률(동일 날짜 다수) 처리 필요 시 `ROW_NUMBER()` 권장.

---

## NOT IN vs NOT EXISTS — NULL의 함정

```sql
-- 위험: 서브쿼리 결과에 NULL 한 개라도 있으면 전체 UNKNOWN → 빈 결과
SELECT name
FROM Employee
WHERE department NOT IN (SELECT department FROM Department WHERE location = 'SEOUL');

-- 안전: 안티 세미-조인
SELECT name
FROM Employee e
WHERE NOT EXISTS (
  SELECT 1
  FROM Department d
  WHERE d.department = e.department
    AND d.location   = 'SEOUL'
);
```

- `NOT IN`을 쓸 때는 **서브쿼리 결과에 NULL 없음**을 보장(예: `WHERE department IS NOT NULL`)해야 한다.

---

## ANY/ALL 의미 재확인

- `x > ANY (S)` ↔ `x > MIN(S)`
- `x > ALL (S)` ↔ `x > MAX(S)`
- `= ANY(S)` ↔ `IN (S)`

NULL이 섞이면 **MIN/MAX 정의**와 비교가 복잡해질 수 있으므로 `WHERE ... IS NOT NULL` 필터를 명시.

---

## 성능 최적화 체크리스트

1) **상관 서브쿼리 → 조인 변환(반상관화)** 시도
2) **EXISTS 선호**: 대용량에서 `IN`보다 빠른 경우 다수
3) **필수 인덱스**
   - **조인/상관 조건 컬럼**에 인덱스
   - 서브쿼리 내부의 **필터 컬럼**에도 인덱스
   - **커버링 인덱스**로 랜덤 I/O 감소
4) **통계 최신화/실행계획 확인**: 해시/중첩루프/머지 조인의 선택 검증
5) **CTE(물질화 여부)**: PG는 CTE가 **최적화 배리어**였으나 최근 버전에서 개선. DB별 규칙 확인
6) **윈도 함수 대체**: Top-N, 누계, 그룹 내 비교는 윈도로 전환
7) **LIMIT/TOP**: LATERAL/APPLY 패턴과 함께 “각 키별 상위 1건” 최적화
8) **서브쿼리 캐시**: 비상관 스칼라 서브쿼리는 DB가 한 번만 평가(엔진마다 다름). 필요 시 명시적 인라인 뷰로 공유

---

## DBMS별 차이와 문법 주의

| 주제 | Oracle | SQL Server | PostgreSQL | MySQL |
|---|---|---|---|---|
| LATERAL/APPLY | 없음(대체 가능) | `CROSS/OUTER APPLY` | `LATERAL` | (직접 없음) 대체 패턴 |
| 튜플 IN | 지원 | 지원 | 지원 | 8.0+ 대부분 지원(호환 모드 주의) |
| NULL 3치 논리 | 동일 | 동일 | 동일 | 동일 |
| 옵티마이저 반상관화 | 활발 | 활발 | 활발 | 일부 제약 |

---

## 수학적 관점(간단한 직관)

서브쿼리의 비용을 단순화해서 보면, 상관 서브쿼리는 외부 행 수 \(N\)에 대해 내부 쿼리 비용 \(C_{\text{inner}}\)이 반복되어
$$
C_{\text{total}} \approx N \cdot C_{\text{inner}}
$$
가 될 수 있다. 반상관화(조인 변환)로 내부 집계를 한 번 만든 뒤 결합하면
$$
C_{\text{total}} \approx C_{\text{build}} + C_{\text{join}}
$$
으로 줄어드는 것이 핵심 직관이다. 실제 비용은 **카디널리티 추정/인덱스 선택/조인 방식**에 좌우된다.

---

## 실전 문제 세트

### “평균 이상 급여자 + 부서 평균/회사 평균 동시 표기”

```sql
WITH dept_avg AS (
  SELECT department, AVG(salary) AS avg_sal
  FROM Employee
  GROUP BY department
),
comp_avg AS (
  SELECT AVG(salary) AS avg_sal FROM Employee
)
SELECT
  e.emp_id, e.name, e.department, e.salary,
  d.avg_sal AS dept_avg,
  c.avg_sal AS comp_avg
FROM Employee e
JOIN dept_avg d ON d.department = e.department
CROSS JOIN comp_avg c
WHERE e.salary >= d.avg_sal
ORDER BY e.department, e.salary DESC;
```

### “최근 6개월 주문이 있고 총액 ≥ 500인 고객”

```sql
SELECT c.customer_id, c.name
FROM Customer c
WHERE EXISTS (
  SELECT 1 FROM Orders o
  WHERE o.customer_id = c.customer_id
    AND o.order_date >= CURRENT_DATE - INTERVAL '6 months'
  GROUP BY o.customer_id
  HAVING SUM(o.total_amount) >= 500
);
```

### 한 명 + 동률 처리”

```sql
-- 윈도 권장
SELECT emp_id, name, department, salary
FROM (
  SELECT e.*, ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC, emp_id) rn
  FROM Employee e
) x
WHERE rn = 1;
```

---

## 자주 하는 실수 & 방지 요령

- **NOT IN + NULL**: 결과가 비게 된다 → **NOT EXISTS**로 바꿔라.
- **단일행 서브쿼리에서 다중행**: 에러/예상치 못한 동작 → 집계로 1행화(`MAX/AVG`) 혹은 추가 필터.
- **상관 스칼라 서브쿼리 남용**: SELECT 절 비용 폭증 → CTE/조인으로 공통화.
- **서브쿼리 정렬/페이징 기대**: 내부 ORDER BY는 최종 SELECT 외 의미가 없을 수 있음 → 인라인 뷰로 감싼 뒤 바깥에서 ORDER BY/LIMIT.
- **인덱스 누락**: 상관 조건 컬럼에 인덱스 없으면 스캔 지옥 → 필수 인덱스 점검.

---

## 요약

- 서브쿼리는 **위치/상관/반환 형태**에 따라 의미와 비용이 달라진다.
- **EXISTS(세미-조인) / NOT EXISTS(안티-조인)**는 대용량/NULL 환경에서 안전하고 빠를 때가 많다.
- 상관 서브쿼리는 가능하면 **조인으로 반상관화**하라.
- 튜플 서브쿼리·LATERAL/APPLY로 **행별 Top-N/최신값** 문제를 우아하게 해결할 수 있다.
- UPDATE/DELETE/MERGE에서도 서브쿼리는 강력하나, **락/트랜잭션/검증**이 필수다.
- 끝으로, **윈도 함수/CTE/집합 연산자/표준 조인**과 적절히 조합하여 **읽기 쉬우면서 빠른 쿼리**를 만들라.
