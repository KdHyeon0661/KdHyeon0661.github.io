---
layout: post
title: DB - 서브쿼리
date: 2025-03-14 19:20:23 +0900
category: DB
---
# SQL 서브쿼리: 개념, 패턴, 그리고 실전 전략

## 서브쿼리의 본질과 다면성

서브쿼리는 SQL의 강력한 기능으로, 하나의 쿼리 내부에 다른 쿼리를 포함시켜 복잡한 논리를 표현할 수 있게 합니다. 이는 단순히 코드를 중첩하는 것을 넘어, 데이터베이스가 계층적이고 집합적인 사고를 할 수 있도록 하는 도구입니다. 서브쿼리는 그 위치와 용도에 따라 다양한 형태로 나타나며, 각각은 고유한 특성과 성능 특성을 가집니다.

서브쿼리를 효과적으로 사용하기 위해서는 세 가지 축을 이해해야 합니다:
1. **위치**: SELECT, WHERE, FROM 절 중 어디에 사용되는가?
2. **상관성**: 외부 쿼리의 컬럼을 참조하는가?(상관 서브쿼리) 아니면 독립적인가?(비상관 서브쿼리)
3. **반환 형태**: 단일 값, 단일 행, 다중 행, 다중 열 중 무엇을 반환하는가?

## 위치별 서브쿼리의 특성과 활용

### SELECT 절의 스칼라 서브쿼리

SELECT 절에서 사용되는 서브쿼리는 반드시 단일 값(스칼라)을 반환해야 합니다. 이는 각 행에 추가적인 계산된 정보를 제공할 때 유용합니다.

```sql
-- 모든 직원에게 회사 평균 급여를 표시
SELECT
  e.emp_id, e.name, e.department, e.salary,
  (SELECT AVG(salary) FROM Employee) AS company_avg_salary
FROM Employee e;
```

스칼라 서브쿼리는 직관적이지만 주의가 필요합니다. 외부 테이블의 모든 행에 대해 서브쿼리가 실행된다면 성능 문제가 발생할 수 있습니다. 특히 대규모 데이터셋에서는 공통된 값을 미리 계산해 조인하는 방식이 더 효율적일 수 있습니다.

### WHERE 절의 조건적 서브쿼리

WHERE 절에서의 서브쿼리는 데이터 필터링의 핵심 도구입니다. 이는 단일 행 비교, 집합 멤버십 확인, 존재성 검사 등 다양한 형태로 사용됩니다.

**단일 행 비교**
```sql
-- HR 부서의 최고 급여보다 많은 급여를 받는 직원
SELECT name, salary
FROM Employee
WHERE salary > (
  SELECT MAX(salary) FROM Employee WHERE department = 'HR'
);
```

**다중 행 비교 (IN 연산자)**
```sql
-- 서울에 위치한 부서의 직원들
SELECT e.name
FROM Employee e
WHERE e.department IN (
  SELECT d.department FROM Department d WHERE d.location = 'SEOUL'
);
```

### FROM 절의 인라인 뷰

FROM 절의 서브쿼리는 "인라인 뷰" 또는 "파생 테이블"이라고 불리며, 쿼리 실행 중에 생성되는 임시 테이블처럼 동작합니다.

```sql
-- 부서별 평균 급여를 계산한 후, 이를 원본 테이블과 조인
SELECT e.emp_id, e.name, e.department, e.salary, d.avg_sal
FROM Employee e
JOIN (
  SELECT department, AVG(salary) AS avg_sal
  FROM Employee
  GROUP BY department
) d ON e.department = d.department
WHERE e.salary >= d.avg_sal;
```

인라인 뷰는 복잡한 계산을 단계적으로 수행하거나, 중간 결과를 재사용할 때 특히 유용합니다. 그러나 데이터베이스 옵티마이저가 이를 최적화하는 방식은 시스템마다 다를 수 있습니다.

## 상관 서브쿼리: 강력함과 위험의 양면성

상관 서브쿼리는 외부 쿼리의 행 각각에 대해 실행됩니다. 이는 매우 표현력이 뛰어나지만, 성능 상의 위험을 내포합니다.

```sql
-- 각 직원의 급여가 본인 부서 평균보다 높은 경우 찾기
SELECT e.*
FROM Employee e
WHERE e.salary >= (
  SELECT AVG(salary) FROM Employee WHERE department = e.department
);
```

이 쿼리는 직원 테이블의 각 행에 대해 해당 부서의 평균 급여를 계산합니다. 직원 수가 많고 부서가 다양하다면, 이는 엄청난 수의 서브쿼리 실행을 의미할 수 있습니다.

**상관 서브쿼리의 성능 최적화**
상관 서브쿼리는 종종 조인으로 재작성(반상관화)될 수 있으며, 이는 성능을 크게 향상시킬 수 있습니다:

```sql
-- 상관 서브쿼리를 조인으로 재작성
WITH dept_avg AS (
  SELECT department, AVG(salary) AS avg_sal
  FROM Employee
  GROUP BY department
)
SELECT e.*
FROM Employee e
JOIN dept_avg d ON d.department = e.department
WHERE e.salary >= d.avg_sal;
```

이 변환은 부서별 평균 급여를 한 번만 계산한 후 모든 직원과 조인합니다. 이는 특히 대규모 데이터셋에서 훨씬 더 효율적입니다.

## EXISTS vs IN: 상황에 맞는 선택

`EXISTS`와 `IN`은 모두 집합 멤버십을 테스트하지만, 그 동작 방식과 성능 특성이 다릅니다.

**EXISTS의 동작 방식**
```sql
-- 서울에 위치한 부서의 직원 찾기 (EXISTS 사용)
SELECT e.name
FROM Employee e
WHERE EXISTS (
  SELECT 1 FROM Department d
  WHERE d.department = e.department
    AND d.location = 'SEOUL'
);
```

`EXISTS`는 조건을 만족하는 첫 번째 행을 찾는 즉시 `TRUE`를 반환합니다. 이는 서브쿼리가 큰 결과 집합을 반환할 경우 특히 효율적일 수 있습니다.

**IN의 동작 방식**
```sql
-- 동일한 쿼리 (IN 사용)
SELECT e.name
FROM Employee e
WHERE e.department IN (
  SELECT d.department FROM Department d WHERE d.location = 'SEOUL'
);
```

`IN`은 서브쿼리의 모든 결과를 수집한 후, 외부 값이 그 집합에 포함되는지 확인합니다. 서브쿼리 결과가 작을 때는 효과적이지만, 결과 집합이 크면 메모리와 비교 비용이 증가할 수 있습니다.

**성능 고려사항**
- `EXISTS`는 일반적으로 서브쿼리 결과가 크거나, 외부 테이블이 작을 때 더 효율적입니다.
- `IN`은 서브쿼리 결과가 작고, 인덱스를 효과적으로 사용할 수 있을 때 유리할 수 있습니다.
- 최신 데이터베이스 옵티마이저는 종종 두 구문을 유사한 실행 계획으로 변환하지만, 여전히 상황에 따라 차이가 있을 수 있습니다.

## NOT EXISTS vs NOT IN: NULL 함정 피하기

부정 조건에서 `NOT EXISTS`와 `NOT IN`의 차이는 특히 중요합니다. `NOT IN`은 NULL 값 처리에서 예상치 못한 동작을 보일 수 있습니다.

**위험한 NOT IN 사용**
```sql
-- 서울이 아닌 곳에 있는 부서의 직원 찾기 (잠재적 문제)
SELECT name
FROM Employee
WHERE department NOT IN (
  SELECT department FROM Department WHERE location = 'SEOUL'
);
```

이 쿼리는 `Department` 테이블의 `department` 컬럼에 NULL 값이 하나라도 있으면, 전체 결과가 빈 집합이 될 수 있습니다. 이는 SQL의 3치 논리(TRUE, FALSE, UNKNOWN) 때문입니다.

**안전한 NOT EXISTS 사용**
```sql
-- 안전한 방법
SELECT e.name
FROM Employee e
WHERE NOT EXISTS (
  SELECT 1
  FROM Department d
  WHERE d.department = e.department
    AND d.location = 'SEOUL'
);
```

`NOT EXISTS`는 NULL 값에 영향을 받지 않으며, 일반적으로 더 효율적인 실행 계획을 생성합니다.

## LATERAL 조인과 APPLY 연산자: 행별 서브쿼리의 새로운 패러다임

최신 SQL 데이터베이스는 `LATERAL`(PostgreSQL) 또는 `APPLY`(SQL Server) 연산자를 통해 FROM 절에서 상관 서브쿼리를 실행할 수 있게 합니다. 이는 특히 "각 그룹의 상위 N개"와 같은 문제를 해결할 때 강력합니다.

**고객별 최신 주문 찾기**
```sql
-- PostgreSQL: LATERAL 사용
SELECT c.customer_id, c.name, x.last_order_id, x.last_date, x.last_amount
FROM Customer c
LEFT JOIN LATERAL (
  SELECT o.order_id AS last_order_id, o.order_date AS last_date, o.total_amount AS last_amount
  FROM Orders o
  WHERE o.customer_id = c.customer_id
  ORDER BY o.order_date DESC
  LIMIT 1
) x ON true;
```

이 패턴은 각 고객에 대해 별도의 서브쿼리를 실행하여 가장 최근의 주문을 찾습니다. 이는 전통적인 상관 서브쿼리보다 더 읽기 쉽고, 종종 더 효율적입니다.

## 다중 열 서브쿼리: 복합 조건의 우아한 해결

서브쿼리는 여러 컬럼을 동시에 반환할 수 있으며, 이를 통해 복잡한 조건을 간결하게 표현할 수 있습니다.

```sql
-- (부서, 관리자) 쌍이 특정 조건을 만족하는 직원 찾기
SELECT emp_id, name
FROM Employee
WHERE (department, manager_id) IN (
  SELECT department, manager_id 
  FROM Employee 
  WHERE salary >= 10000
);
```

이 구문은 여러 개의 단일 열 서브쿼리를 중첩하는 것보다 더 읽기 쉽고, 데이터베이스가 더 효율적으로 최적화할 수 있는 기회를 제공합니다.

## 실전 패턴과 문제 해결

### 관계 나눗셈 (Relational Division)
"모든 특정 제품 카테고리를 구매한 고객 찾기"와 같은 문제는 관계 나눗셈 패턴으로 해결할 수 있습니다.

```sql
WITH target_categories AS (
  SELECT 'ELECTRONICS' AS category UNION ALL
  SELECT 'FASHION'
)
SELECT c.customer_id, c.name
FROM Customer c
WHERE NOT EXISTS (
  SELECT 1
  FROM target_categories tc
  WHERE NOT EXISTS (
    SELECT 1
    FROM Orders o
    JOIN Products p ON p.product_id = o.product_id
    WHERE o.customer_id = c.customer_id
      AND p.category = tc.category
  )
);
```

이 패턴은 이중 부정을 사용합니다: "구매하지 않은 카테고리가 존재하지 않는 고객".

### 그룹 내 상위 N개 레코드
각 부서에서 상위 3명의 고임금자를 찾는 문제는 여러 방법으로 해결할 수 있습니다.

**윈도우 함수를 사용한 현대적인 접근**
```sql
SELECT *
FROM (
  SELECT e.*, 
         ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC) AS rn
  FROM Employee e
) ranked
WHERE rn <= 3;
```

**상관 서브쿼리를 사용한 전통적인 접근**
```sql
SELECT e1.*
FROM Employee e1
WHERE 3 > (
  SELECT COUNT(*)
  FROM Employee e2
  WHERE e2.department = e1.department
    AND e2.salary > e1.salary
);
```

윈도우 함수 접근법이 일반적으로 더 읽기 쉽고 효율적이지만, 데이터베이스와 데이터 분포에 따라 최적의 접근법이 달라질 수 있습니다.

## 성능 최적화 전략

서브쿼리의 성능을 최적화하기 위한 몇 가지 핵심 전략:

1. **상관 서브쿼리의 조인 변환**: 가능한 경우 상관 서브쿼리를 조인으로 재작성하세요.
2. **적절한 인덱스 사용**: 서브쿼리 내의 조인 조건과 WHERE 조건에 인덱스를 생성하세요.
3. **EXISTS의 전략적 사용**: 특히 NOT EXISTS는 NULL 문제를 피하면서 안티 조인으로 효율적으로 실행될 수 있습니다.
4. **파생 테이블의 물질화 고려**: 복잡한 서브쿼리가 여러 번 참조된다면, CTE(Common Table Expression)를 사용해 명시적으로 물질화하는 것을 고려하세요.
5. **실행 계획 분석**: 서브쿼리가 어떻게 실행되는지 이해하기 위해 EXPLAIN(또는 유사한) 명령을 사용하세요.

## 데이터베이스별 고려사항

서브쿼리 동작은 데이터베이스 시스템마다 약간씩 다를 수 있습니다:

- **Oracle**: 강력한 서브쿼리 최적화 기능을 갖추고 있으며, 종종 서브쿼리를 조인으로 자동 변환합니다.
- **SQL Server**: `APPLY` 연산자를 통해 LATERAL 조인을 지원하며, 서브쿼리 성능 최적화에 능숙합니다.
- **PostgreSQL**: `LATERAL` 조인을 지원하며, CTE 최적화가 버전에 따라 발전하고 있습니다.
- **MySQL**: 최근 버전에서 서브쿼리 최적화가 크게 개선되었지만, 여전히 복잡한 상관 서브쿼리에 주의가 필요합니다.

## 결론: 서브쿼리의 예술

서브쿼리는 SQL의 표현력을 크게 확장하는 강력한 도구입니다. 그러나 그 힘은 신중한 사용에서 비롯됩니다. 서브쿼리를 효과적으로 사용한다는 것은 단순히 구문을 아는 것을 넘어, 데이터의 본질과 데이터베이스 시스템의 동작 방식을 이해하는 것을 의미합니다.

성공적인 서브쿼리 사용의 핵심은 적절한 도구 선택에 있습니다: 단순한 멤버십 검사에는 `IN`을, 존재성 확인에는 `EXISTS`를, 복잡한 행별 연산에는 `LATERAL` 조인을 선택하세요. 상관 서브쿼리의 성능 함정을 인지하고, 가능하면 조인으로 재작성하는 방법을 모색하세요.

가장 중요한 것은, 서브쿼리가 독립적인 해결책이 아니라 SQL 도구 상자의 일부라는 점을 기억하는 것입니다. 윈도우 함수, CTE, 조인 및 집합 연산과 조화롭게 사용할 때, 서브쿼리는 복잡한 데이터 문제를 우아하고 효율적으로 해결하는 완전한 해법의 일부가 됩니다.

데이터베이스 쿼리를 작성할 때는 항상 가독성, 유지보수성, 성능의 균형을 고려하세요. 때로는 여러 개의 간단한 쿼리나 중간 임시 테이블이 하나의 복잡한 서브쿼리보다 더 나은 선택일 수 있습니다. 궁극적으로, 가장 좋은 쿼리는 정확한 결과를 효율적으로 반환하면서도, 다른 사람(또는 미래의 여러분)이 이해하고 수정할 수 있는 쿼리입니다.