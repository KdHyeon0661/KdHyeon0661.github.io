---
layout: post
title: 파이썬 심화 - C 확장 (4)
date: 2025-12-09 19:30:23 +0900
category: 파이썬 심화
---
# C 확장 (4)
# 파이썬 C 확장: 문자열과 파일 처리의 실제 구현

## C 문자열을 파이썬 문자열로 안전하게 변환하기

C 확장 모듈에서 C 문자열(char*)을 파이썬으로 반환할 때는 단순 변환보다 인코딩 처리가 중요합니다.

```c
// 위험한 방법 - 인코딩 가정
PyObject* unsafe_string_return(const char* cstr) {
    return PyUnicode_FromString(cstr);  // UTF-8이라고 가정
}

// 안전한 방법 - 명시적 인코딩 처리
PyObject* safe_string_return(const char* cstr) {
    // 1. 로케일 인코딩 사용 (시스템 기본)
    PyObject* str = PyUnicode_DecodeLocale(cstr, "surrogateescape");
    
    // 2. 실패 시 UTF-8 시도
    if (!str) {
        PyErr_Clear();
        str = PyUnicode_DecodeUTF8(cstr, strlen(cstr), "surrogateescape");
    }
    
    // 3. 그래도 실패 시 Latin-1 폴백
    if (!str) {
        PyErr_Clear();
        str = PyUnicode_DecodeLatin1(cstr, strlen(cstr), "replace");
    }
    
    return str;
}
```

## 알 수 없는 인코딩의 C 문자열 처리 실제 사례

윈도우 API나 레거시 시스템에서 온 문자열은 예측하기 어려운 인코딩을 가질 수 있습니다.

```c
// 다양한 소스의 문자열 처리
PyObject* handle_unknown_encoding(const char* data, int source_type) {
    PyObject* result = NULL;
    
    switch(source_type) {
        case SOURCE_WINDOWS_API:
            // Windows는 보통 UTF-16이나 CP949
            result = PyUnicode_DecodeUTF16(data, strlen(data), "strict", NULL);
            if (!result) {
                PyErr_Clear();
                // 한국어 Windows 대비 CP949 시도
                result = PyUnicode_Decode("cp949", data, strlen(data), "replace");
            }
            break;
            
        case SOURCE_POSIX_FILENAME:
            // 파일시스템 인코딩 자동 감지
            result = PyUnicode_DecodeFSDefault(data);
            break;
            
        case SOURCE_NETWORK:
            // Content-Type 헤더 기반 인코딩 추측
            const char* detected_encoding = detect_encoding_from_data(data);
            if (detected_encoding) {
                result = PyUnicode_Decode(data, strlen(data), 
                                         detected_encoding, "replace");
            }
            break;
    }
    
    if (!result) {
        // 최후의 수단: 바이너리 데이터로 처리
        result = PyBytes_FromString(data);
    }
    
    return result;
}
```

## 파일 관련 데이터 C 확장으로 전달하기

### 파일 이름 전달과 열기

```c
// 파일 이름을 받아 C에서 직접 열기
static PyObject* py_open_and_process(PyObject* self, PyObject* args) {
    const char* filename;
    if (!PyArg_ParseTuple(args, "s", &filename)) {
        return NULL;
    }
    
    FILE* fp = fopen(filename, "rb");
    if (!fp) {
        PyErr_SetFromErrnoWithFilename(PyExc_OSError, filename);
        return NULL;
    }
    
    // 파일 처리 로직
    fseek(fp, 0, SEEK_END);
    long size = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    
    char* buffer = (char*)malloc(size + 1);
    fread(buffer, 1, size, fp);
    buffer[size] = '\0';
    
    fclose(fp);
    
    PyObject* result = PyUnicode_DecodeFSDefault(buffer);
    free(buffer);
    return result;
}
```

### 파이썬 파일 객체 직접 사용

```c
// 파이썬 파일 객체에서 파일 디스크립터 추출
static PyObject* py_process_file_object(PyObject* self, PyObject* args) {
    PyObject* file_obj;
    if (!PyArg_ParseTuple(args, "O", &file_obj)) {
        return NULL;
    }
    
    // 파일 객체인지 확인
    if (!PyObject_HasAttrString(file_obj, "fileno")) {
        PyErr_SetString(PyExc_TypeError, "Expected a file object");
        return NULL;
    }
    
    // 파일 디스크립터 얻기
    PyObject* fileno_method = PyObject_GetAttrString(file_obj, "fileno");
    if (!fileno_method) return NULL;
    
    PyObject* fd_obj = PyObject_CallObject(fileno_method, NULL);
    Py_DECREF(fileno_method);
    
    if (!fd_obj) return NULL;
    
    int fd = PyLong_AsLong(fd_obj);
    Py_DECREF(fd_obj);
    
    if (fd == -1 && PyErr_Occurred()) {
        return NULL;
    }
    
    // C 스트림으로 변환
    FILE* fp = fdopen(fd, "rb");
    if (!fp) {
        PyErr_SetFromErrno(PyExc_OSError);
        return NULL;
    }
    
    // dup을 사용하여 원본 파일 디스크립터 보존
    int fd2 = dup(fd);
    fclose(fp);  // 원본 fd는 건드리지 않음
    
    // fd2로 작업 계속...
    FILE* fp2 = fdopen(fd2, "rb");
    
    // 작업 완료 후 정리
    fclose(fp2);
    
    Py_RETURN_NONE;
}
```

## C에서 파일 유사 객체 읽기 (버퍼 프로토콜 활용)

```c
// 버퍼 프로토콜을 사용한 효율적인 읽기
static PyObject* py_read_bytesio(PyObject* self, PyObject* args) {
    PyObject* bytes_obj;
    if (!PyArg_ParseTuple(args, "O", &bytes_obj)) {
        return NULL;
    }
    
    Py_buffer view;
    // 버퍼 프로토콜 지원 확인 및 획득
    if (PyObject_GetBuffer(bytes_obj, &view, PyBUF_SIMPLE) != 0) {
        PyErr_SetString(PyExc_TypeError, 
                       "Expected a bytes-like object");
        return NULL;
    }
    
    // C에서 데이터 직접 접근 (복사 없음)
    unsigned char* data = (unsigned char*)view.buf;
    Py_ssize_t size = view.len;
    
    // 데이터 처리 예시: 간단한 XOR 암호화
    for (Py_ssize_t i = 0; i < size; i++) {
        data[i] ^= 0x55;  // 간단한 비트 조작
    }
    
    // 버퍼 해제
    PyBuffer_Release(&view);
    
    // 수정된 객체 반환 (일부 객체는 제자리 수정됨)
    Py_INCREF(bytes_obj);
    return bytes_obj;
}
```

## C 확장에서 순환 객체(이터레이터) 처리

```c
// 제너레이터나 이터레이터에서 데이터 스트림 처리
static PyObject* py_process_iterator(PyObject* self, PyObject* args) {
    PyObject* iterable;
    if (!PyArg_ParseTuple(args, "O", &iterable)) {
        return NULL;
    }
    
    // 이터레이터 얻기
    PyObject* iterator = PyObject_GetIter(iterable);
    if (!iterator) {
        PyErr_SetString(PyExc_TypeError, 
                       "Expected an iterable object");
        return NULL;
    }
    
    PyObject* item;
    PyObject* result_list = PyList_New(0);
    
    // 메모리 효율적으로 한 번에 하나씩 처리
    while ((item = PyIter_Next(iterator)) != NULL) {
        // 각 아이템 처리
        if (PyUnicode_Check(item)) {
            // 문자열 처리
            Py_ssize_t length;
            const char* utf8 = PyUnicode_AsUTF8AndSize(item, &length);
            if (utf8) {
                // C 레벨에서 문자열 처리
                // 예: 대문자 변환 (실제로는 파이썬에서 하는 게 나음)
            }
        }
        
        // 결과에 추가
        PyList_Append(result_list, item);
        Py_DECREF(item);  // 참조 카운트 관리 중요!
    }
    
    // 이터레이터 소진 확인
    if (PyErr_Occurred()) {
        Py_DECREF(iterator);
        Py_DECREF(result_list);
        return NULL;
    }
    
    Py_DECREF(iterator);
    return result_list;
}
```

## 세그멘테이션 오류 디버깅 실제 기법

### 디버깅용 안전한 래퍼 함수

```c
// 모든 C 확장 함수를 이렇게 래핑하여 디버깅
#define SAFE_CALL(func, ...) \
    do { \
        fprintf(stderr, "[DEBUG] Calling %s at %s:%d\n", \
                #func, __FILE__, __LINE__); \
        func(__VA_ARGS__); \
    } while(0)

// 메모리 접근 검증 매크로
#define CHECK_PTR(ptr) \
    if ((ptr) == NULL) { \
        fprintf(stderr, "NULL pointer at %s:%d\n", __FILE__, __LINE__); \
        return NULL; \
    }

// 실제 함수 예시
static PyObject* py_safe_function(PyObject* self, PyObject* args) {
    PyObject* input;
    
    CHECK_PTR(self);
    CHECK_PTR(args);
    
    if (!PyArg_ParseTuple(args, "O", &input)) {
        PyErr_Print();  // 에러 정보 출력
        return NULL;
    }
    
    CHECK_PTR(input);
    
    // 참조 카운트 디버깅
    fprintf(stderr, "Input refcount: %ld\n", Py_REFCNT(input));
    
    Py_INCREF(input);  // 참조 카운트 증가
    
    // 안전한 메모리 접근
    if (PyBytes_Check(input)) {
        char* buffer;
        Py_ssize_t length;
        
        if (PyBytes_AsStringAndSize(input, &buffer, &length) != -1) {
            CHECK_PTR(buffer);
            // 버퍼 접근...
        }
    }
    
    Py_DECREF(input);  // 참조 카운트 감소
    
    Py_RETURN_NONE;
}
```

### GDB를 이용한 실시간 디버깅 스크립트

```bash
# gdb_debug.py
import gdb
import sys

class PyObjectPrinter:
    def __init__(self, val):
        self.val = val
    
    def to_string(self):
        try:
            # PyObject 타입 정보 추출
            ob_type = self.val['ob_type']
            tp_name = ob_type['tp_name']
            return f"Python object: {tp_name.string()}"
        except:
            return "Cannot parse PyObject"

# GDB에 프린터 등록
gdb.printing.add_builtin_pretty_printer(
    'python',
    '^Py[A-Z]',
    PyObjectPrinter
)

# 세그폴트 발생 시 자동 백트레이스
def handle_sigsegv(event):
    print("=== SEGMENTATION FAULT DETECTED ===")
    gdb.execute('bt full')
    gdb.execute('info registers')
    print("=== PYTHON STACK ===")
    gdb.execute('py-bt')

gdb.events.stop.connect(handle_sigsegv)
```

## 결론: 안정적인 C 확장을 위한 체크리스트

1. **문자열 인코딩**
   - 항상 명시적 인코딩 지정
   - `surrogateescape` 에러 핸들러 사용 고려
   - 시스템 로케일 대신 UTF-8을 기본으로

2. **파일 처리**
   - 파일 객체와 파일 이름 경로 구분
   - `fdopen()` 후 원본 fd 보존 (dup 사용)
   - 크로스 플랫폼 경로 처리 (`os.path` 모듈 활용)

3. **메모리 관리**
   - 모든 `Py_INCREF`에 대응하는 `Py_DECREF`
   - 버퍼 프로토콜 사용 시 `PyBuffer_Release` 필수
   - 순환 참조 주의 (weakref 고려)

4. **에러 처리**
   - 모든 C 라이브러리 호출의 에러 체크
   - 파이썬 예외 상태 보존 (`PyErr_Occurred()` 체크)
   - 리소스 누수 방지를 위한 goto cleanup 패턴

5. **디버깅 준비**
   - 디버그 빌드에서의 `Py_DEBUG` 활용
   - Valgrind/AddressSanitizer로 정기 검사
   - 파이썬의 `faulthandler` 모듈 활성화

실제 프로덕션 코드에서는 이러한 기법들을 조합하여, 메모리 안전성과 플랫폼 호환성을 보장하면서도 파이썬다운 인터페이스를 제공하는 C 확장을 개발할 수 있습니다.