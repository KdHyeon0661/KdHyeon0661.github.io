---
layout: post
title: 디지털신호처리 - 저역통과 필터 설계
date: 2025-11-19 14:25:23 +0900
category: 디지털신호처리
---
# GNU Octave를 이용한 저역통과 필터 설계

## 개요 — 저역통과 필터 설계에서 꼭 짚고 가야 할 것들

저역통과 필터는 “**느린 변화는 통과, 빠른 변화는 억제**”하는 필터다. 디지털에서 흔히 만나는 상황은:

- 오디오 신호에서 **고주파 노이즈 제거**
- 센서 데이터(온도, 가속도 등) **스무딩**
- **안티에일리어싱**(다운샘플 전 저역통과)
- 통신 시스템에서 **채널 대역 제한**

GNU Octave에서 저역통과 필터를 설계할 때 실제로 하는 일은:

1. **스펙 정의**
   - 샘플링 주파수: $$F_s$$
   - 통과대역 끝 주파수: $$F_p$$
   - 저지대역 시작 주파수: $$F_s'$$
   - 통과대역 리플: $$A_p\ \mathrm{dB}$$
   - 저지대역 감쇠: $$A_s\ \mathrm{dB}$$
   - 필요한 경우, 군지연/선형 위상 여부, 필터 차수 제한 등

2. **구조 선택: FIR vs IIR**
   - FIR: 선형 위상, 안정성 쉬움, 차수 큼
   - IIR: 차수 효율적, 위상 비선형, 안정성·고정소수점 주의

3. **설계 기법 선택**
   - FIR
     - 창함수법: `fir1`, `kaiser` 등
     - 등리플(Equiripple): `remez`
   - IIR
     - 아날로그 프로토타입(Butterworth, Chebyshev, Elliptic 등) + bilinear 변환: `butter`, `cheby1`, `ellip` 등

4. **GNU Octave로 구현**
   - `pkg load signal`
   - 필터 계수 계산
   - `freqz`, `grpdelay`, `filter`로 주파수·시간 응답 분석
   - 테스트 신호에 적용해 전/후 비교

이 글에서는 이 흐름을 따라가며, **저역통과 필터 설계 전체를 한번에 정리**한다.

---

## 설계 스펙 정의와 주파수 정규화

### 필수 설계 변수

디지털 저역통과 필터의 대표적인 스펙은 다음과 같다.

- 샘플링 주파수: $$F_s\ [\mathrm{Hz}]$$
- 통과대역 끝 주파수: $$F_p\ [\mathrm{Hz}]$$
- 저지대역 시작 주파수: $$F_s'\ [\mathrm{Hz}]$$
- 통과대역 리플: $$A_p\ [\mathrm{dB}]$$
- 저지대역 감쇠: $$A_s\ [\mathrm{dB}]$$

또는 직접적으로 **차수** $$N$$을 정하고,

- “차수 $$N$$으로 가능한 한 원하는 스펙에 가깝게” 설계할 수도 있다.

### 정규화 주파수

GNU Octave의 많은 설계 함수는 **정규화 주파수**를 인자로 받는다.

- 정규화 주파수:
  $$
  \omega_n = \frac{2\pi f}{F_s} \quad\text{또는}\quad
  f_n = \frac{f}{F_s/2}
  $$
- `butter`, `cheby1`, `ellip` 등의 IIR 설계 함수는
  **디지털 모드**에서 $$0<f_n<1$$ 를 받으며, $$f_n = f/(F_s/2)$$ 형태다.
- `fir1`, `remez` 등 FIR 설계 함수도 일반적으로 $$[0,1]$$ 구간의 정규화 주파수(나이퀴스트 기준)를 사용한다.

예:

- 샘플링 주파수 $$F_s = 48\ \mathrm{kHz}$$
- 통과대역 끝 $$F_p = 4\ \mathrm{kHz}$$

이면,

$$
f_{p,\text{norm}} = \frac{F_p}{F_s/2} = \frac{4000}{24000} \approx 0.1667
$$

이 값을 `fir1`, `butter` 등에 그대로 넣을 수 있다.

---

## GNU Octave 환경 준비

GNU Octave에서 필터 설계 기능은 `signal` 패키지에 들어있다.

```octave
pkg load signal;   % 신호처리 관련 함수 로드 (fir1, butter, cheby1, remez 등)
clear; close all; clc;
```

- `pkg load signal`은 스크립트의 가장 위에 한 번만 호출하면 된다.
- 플로팅 함수는 기본적으로 `plot`, `freqz`, `zplane` 등을 사용한다.

---

## FIR vs IIR 저역통과 — 구조 선택 요약

### FIR 저역통과

장점:

- **항상 안정**
  - 전송함수:
    $$
    H(z) = \sum_{n=0}^{N} h[n] z^{-n}
    $$
    분모가 1이므로 극점이 모두 원점에 몰려 있어 BIBO 안정.
- **선형 위상(linear phase)** 가능
  - 계수가 대칭/반대칭이면 위상이 선형.
- 고정소수점 구현시 **극 안정성**에 대한 걱정이 적음.

단점:

- 같은 스펙을 만족할 때 **차수 $$N$$이 큼** → 곱셈·덧셈 연산량 증가.
- 실시간/임베디드에서 연산량이 부담이 될 수 있다.

### IIR 저역통과

장점:

- **차수 효율적**: 같은 진폭 특성을 FIR보다 훨씬 낮은 차수로 구현 가능.
- 아날로그 필터(Butterworth, Chebyshev, Elliptic, Bessel) 특성을 그대로 가져올 수 있음.

단점:

- 극이 단위원에 가까운 경우 고정소수점에서 **불안정성/감도 문제**.
- 위상이 비선형 → 시간 도메인 파형이 왜곡될 수 있음.
- 구조 선택(Direct Form I/II, SOS 등)에 따라 **수치 안정성 차이**가 큼.

이 글에서는

- FIR: 창함수법(`fir1`, `kaiser`), 등리플(`remez`)
- IIR: Butterworth/ Chebyshev/ Elliptic + bilinear (`butter`, `cheby1`, `ellip`)

을 중심으로 예제를 살펴본다.

---

## FIR 저역통과 — 창함수 설계 기법 (fir1, kaiser)

### 이상적인 저역통과 필터의 임펄스 응답

이상적인 저역통과 필터의 주파수 응답을

$$
H_d(e^{j\omega}) =
\begin{cases}
1, & |\omega| \le \omega_c \\
0, & \text{그 외}
\end{cases}
$$

라고 하면, 그 임펄스 응답은

$$
h_d[n]
=
\frac{\omega_c}{\pi},\quad n = 0
$$

$$
h_d[n]
=
\frac{\sin(\omega_c n)}{\pi n},\quad n \ne 0
$$

즉, **sinc 꼬리가 무한히 이어지는** 구조다.

실제 FIR 필터에서는 유한 길이로 잘라야 하므로:

- 중심을 $$n = 0$$이 아닌, 길이 $$N+1$$의 대칭 구조에서 $$n = M = N/2$$ 중심으로 놓는다.

길이 $$L = N+1$$, 중앙 인덱스 $$M = N/2$$ (짝수 차수 FIR, 대칭)일 때,

$$
h_d[n]
=
\begin{cases}
\displaystyle
\frac{\omega_c}{\pi}, & n = M \\[6pt]
\displaystyle
\frac{\sin\{\omega_c (n - M)\}}{\pi (n - M)}, & n \ne M
\end{cases}
$$

여기에 **창함수(window)** $$w[n]$$를 곱해 실제 FIR 계수를 만든다.

$$
h[n] = h_d[n]\ w[n],\quad 0\le n\le N
$$

대표적인 창:

- Rectangular, Hamming, Hanning, Blackman, Kaiser 등

각 창마다

- 주로 **사이드로브 레벨**, **전이대역 폭**이 달라진다.

### GNU Octave: `fir1`을 이용한 기본 저역통과 설계

`fir1`은 기본적인 창함수 기반 FIR 설계를 제공한다.

- 문법(저역통과):

  ```octave
  b = fir1(N, Wn, window);
  ```

  - `N`: 필터 차수
  - `Wn`: 정규화 컷오프 주파수 (0~1, 1은 Nyquist)
  - `window`: `hamming(N+1)`, `hann(N+1)`, `blackman(N+1)` 등

#### 예제 1: Hamming 창 기반 저역통과 FIR

스펙:

- $$F_s = 48000\ \mathrm{Hz}$$
- 원하는 컷오프: $$F_c = 4000\ \mathrm{Hz}$$
- 필터 차수: $$N = 64$$ (임의 선택)

```octave
pkg load signal;
clear; close all; clc;

Fs = 48000;
Fc = 4000;
N  = 64;

Wn = Fc/(Fs/2);              % 정규화 컷오프 (0~1)

% Hamming 창 기반 FIR 저역통과 필터
b = fir1(N, Wn, hamming(N+1));

% 주파수 응답
Nfft = 2048;
[H, f] = freqz(b, 1, Nfft, Fs);

figure;
subplot(2,1,1);
plot(f, 20*log10(abs(H)+eps), 'LineWidth', 1.5);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title(sprintf('Hamming-window FIR LPF (N=%d, Fc=%d Hz)', N, Fc));
ylim([-100 5]);

subplot(2,1,2);
plot(f, unwrap(angle(H)), 'LineWidth', 1.5);
grid on;
xlabel('Frequency (Hz)');
ylabel('Phase (rad)');
```

- 통과대역에서 리플, 전이대역 폭, 저지대역 감쇠를 확인해볼 수 있다.
- 차수 $$N$$을 늘리면 전이대역 폭이 줄어들고,
  창 종류를 바꾸면 사이드로브 레벨이 변한다.

### 창에 따른 특성 비교 (Rectangular vs Hamming vs Blackman)

같은 $$N, F_c$$로 창만 바꿔 비교해보자.

```octave
pkg load signal;
clear; close all; clc;

Fs = 48000;
Fc = 4000;
N  = 64;
Wn = Fc/(Fs/2);

b_rect = fir1(N, Wn, rectwin(N+1));
b_hamm = fir1(N, Wn, hamming(N+1));
b_black= fir1(N, Wn, blackman(N+1));

Nfft = 4096;
[H_rect, f] = freqz(b_rect, 1, Nfft, Fs);
[H_hamm, ~] = freqz(b_hamm, 1, Nfft, Fs);
[H_black,~] = freqz(b_black,1, Nfft, Fs);

figure;
plot(f, 20*log10(abs(H_rect)+eps), 'k-', 'LineWidth', 1.0); hold on;
plot(f, 20*log10(abs(H_hamm)+eps), 'b-', 'LineWidth', 1.0);
plot(f, 20*log10(abs(H_black)+eps),'r-', 'LineWidth', 1.0);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title(sprintf('Window Comparison (N=%d, Fc=%d Hz)', N, Fc));
legend('Rectangular', 'Hamming', 'Blackman');
ylim([-120 5]);
xlim([0 20000]);
```

대략적인 경향:

- Rectangular: 전이대역 좁지만, 사이드로브가 높음 (저지대역 감쇠 작음).
- Hamming: 사이드로브 감쇠가 좋아짐, 전이대역은 약간 넓어짐.
- Blackman: 원치 않는 사이드로브는 더 잘 억제, 전이대역 더 넓음.

### Kaiser 창과 차수 추정

Kaiser 창은 **조절 가능한 파라미터**로 사이드로브/전이대역 trade-off를 제어할 수 있다.

Kaiser 창 설계에서 자주 쓰이는 근사식:

- 원하는 저지대역 감쇠를 $$A_s$$ 라고 할 때,
  Kaiser 파라미터 $$\beta$$는 대략

  $$
  \beta =
  \begin{cases}
  0, & A_s \le 21 \\[4pt]
  0.5842 (A_s - 21)^{0.4} + 0.07886 (A_s - 21), & 21 < A_s < 50 \\[4pt]
  0.1102 (A_s - 8.7), & A_s \ge 50
  \end{cases}
  $$

- 필요한 차수 $$N$$은 대략

  $$
  N \approx
  \frac{A_s - 8}{2.285 \Delta\omega}
  $$

  여기서 $$\Delta\omega$$는 정규화된 전이대역 폭(라디안 단위)이다.

GNU Octave에서 Kaiser 창 기반 FIR 저역통과를 설계해보자.

```octave
pkg load signal;
clear; close all; clc;

Fs = 48000;
Fp = 4000;    % passband edge
Fs1= 6000;    % stopband edge
Ap = 1;       % passband ripple (dB)
As = 60;      % stopband attenuation (dB)

wp = 2*pi*Fp/Fs;
ws = 2*pi*Fs1/Fs;
Dw = ws - wp; % rad/sample

% Kaiser beta 추정
if As <= 21
  beta = 0;
elseif As < 50
  beta = 0.5842*(As - 21)^0.4 + 0.07886*(As - 21);
else
  beta = 0.1102*(As - 8.7);
end

% 차수 추정 (근사식)
N_est = ceil( (As - 8) / (2.285*Dw) );

printf("Estimated Kaiser LPF order: N ≈ %d (As=%.1f dB)\n", N_est, As);

% 설계
Wn = Fp/(Fs/2);    % cutoff near passband edge
b_kaiser = fir1(N_est, Wn, kaiser(N_est+1, beta));

% 주파수 응답
Nfft = 4096;
[Hk, f] = freqz(b_kaiser, 1, Nfft, Fs);

figure;
plot(f, 20*log10(abs(Hk)+eps), 'LineWidth', 1.5);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title(sprintf('Kaiser-window LPF (N=%d, Fp=%d Hz, Fs1=%d Hz)', N_est, Fp, Fs1));
ylim([-100 5]);
xlim([0 20000]);
```

- 전이대역 폭과 저지대역 감쇠가 스펙에 근접하는지 확인할 수 있다.
- 설계 스펙에 더 정확하게 맞추려면, `remez`와 같은 등리플 FIR 설계 기법을 사용하는 것이 일반적이다.

---

## FIR 저역통과 — 등리플 설계 기법 (remez)

창함수법 FIR 설계는 **전이대역 폭 vs 저지대역 감쇠**를 비교적 쉽게 제어하지만,
주어진 차수 $$N$$에서 **“최적”** 의미에서의 리플/전이대역 최솟값을 보장해주지는 않는다.

**등리플(equiripple) FIR 설계**는, 주어진 차수에서 **최소의 최대 오차(믿니맥스, Chebyshev sense)**를 달성하는 필터를 찾는다.

GNU Octave에서는 `remez`로 구현 가능하다.

### `remez` 기본 사용법

저역통과 설계:

```octave
b = remez(N, f, a);
```

- `N`: 필터 차수
- `f`: 정규화 주파수 벡터 (0~1, 1은 Nyquist). 밴드별 시작/끝 주파수를 나열.
- `a`: 각 밴드에서 원하는 진폭 값.

예를 들어, 정규화 주파수에서

- 저역통과: 0 ~ 0.2 에서 1
- 저지대역: 0.3 ~ 1.0 에서 0

을 원하면:

```octave
f = [0 0.2  0.3 1];   % 밴드 경계
a = [1 1    0   0];   % 각 밴드의 목표 크기
```

라고 한다.

### 예제: 등리플 저역통과 설계

스펙:

- $$F_s = 48000\ \mathrm{Hz}$$
- 통과대역 끝: $$F_p = 4000\ \mathrm{Hz}$$
- 저지대역 시작: $$F_s' = 6000\ \mathrm{Hz}$$
- 필터 차수: $$N = 64$$

```octave
pkg load signal;
clear; close all; clc;

Fs  = 48000;
Fp  = 4000;
Fs1 = 6000;
N   = 64;

% 정규화
fp = Fp/(Fs/2);
fs = Fs1/(Fs/2);

% remez용 밴드 정의
f = [0 fp fs 1];   % 0~fp: pass, fs~1: stop
a = [1 1  0 0];

b_remez = remez(N, f, a);

Nfft = 4096;
[H, w] = freqz(b_remez, 1, Nfft, Fs);

figure;
plot(w, 20*log10(abs(H)+eps), 'LineWidth', 1.5);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title(sprintf('Equiripple FIR LPF via remez (N=%d)', N));
ylim([-100 5]);
xlim([0 20000]);
```

- 창함수 설계와 비교했을 때, 같은 차수에서
  - 통과대역 리플과 저지대역 리플이 **대체로 일정(등리플)**하게 분포한다.
  - 스펙(통과/저지대역)에서의 최대 오차가 줄어드는 경향.

---

## IIR 저역통과 — Butterworth / Chebyshev / Elliptic

### 아날로그 프로토타입 + bilinear 변환

앞 글에서 정리했듯이, IIR 저역통과는 대개:

1. **원형 아날로그 필터 프로토타입** 설계
   (Butterworth, Chebyshev I/II, Elliptic, Bessel 등)
2. **주파수 사상(저역통과 변환)** 후
3. **bilinear 변환**으로 \(s\)-평면 → \(z\)-평면 매핑

을 통해 설계된다.

GNU Octave에서는 이 과정을 `butter`, `cheby1`, `ellip` 등의 함수가 내부에서 처리해 준다.

### Butterworth 저역통과 — 기본 예제

스펙:

- $$F_s = 48000\ \mathrm{Hz}$$
- 통과대역 끝: $$F_p = 4000\ \mathrm{Hz}$$
- 저지대역 시작: $$F_s' = 8000\ \mathrm{Hz}$$
- $$A_p = 1\ \mathrm{dB},\quad A_s = 60\ \mathrm{dB}$$

이 스펙을 디지털 영역에서 `buttord`/`butter`로 설계해보자.

```octave
pkg load signal;
clear; close all; clc;

Fs  = 48000;
Fp  = 4000;
Fs1 = 8000;
Ap  = 1;
As  = 60;

Wp = Fp/(Fs/2);   % 0~1
Ws = Fs1/(Fs/2);

[N, Wn] = buttord(Wp, Ws, Ap, As);

printf("Butterworth IIR LPF order: N = %d\n", N);

[bd, ad] = butter(N, Wn);   % 디지털 IIR 저역통과

Nfft = 4096;
[H, f] = freqz(bd, ad, Nfft, Fs);

figure;
subplot(2,1,1);
plot(f, 20*log10(abs(H)+eps), 'LineWidth', 1.5);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title(sprintf('Butterworth IIR LPF (N=%d)', N));
ylim([-80 5]);
xlim([0 20000]);

subplot(2,1,2);
grpdelay(bd, ad, Nfft, Fs);
grid on;
title('Group Delay');
```

- `buttord`가 필요한 차수와 정규화 컷오프를 자동으로 계산해 준다.
- `grpdelay`로 군지연 특성을 보면, FIR 선형 위상에 비해 **비선형**임을 확인할 수 있다.

### Chebyshev I / Elliptic 저역통과 비교

같은 스펙에 대해 Chebyshev I와 Elliptic 필터를 설계해 보고, Butterworth와 비교해보자.

```octave
pkg load signal;
clear; close all; clc;

Fs  = 48000;
Fp  = 4000;
Fs1 = 8000;
Ap  = 1;
As  = 60;

Wp = Fp/(Fs/2);
Ws = Fs1/(Fs/2);

% Butterworth
[NB, WnB] = buttord(Wp, Ws, Ap, As);
[bB, aB]  = butter(NB, WnB);

% Chebyshev I
[NC, WnC] = cheb1ord(Wp, Ws, Ap, As);
[bC, aC]  = cheby1(NC, Ap, WnC);

% Elliptic
[NE, WnE] = ellipord(Wp, Ws, Ap, As);
[bE, aE]  = ellip(NE, Ap, As, WnE);

Nfft = 4096;
[HB, f] = freqz(bB, aB, Nfft, Fs);
[HC, ~] = freqz(bC, aC, Nfft, Fs);
[HE, ~] = freqz(bE, aE, Nfft, Fs);

figure;
plot(f, 20*log10(abs(HB)+eps), 'k-',  'LineWidth', 1.2); hold on;
plot(f, 20*log10(abs(HC)+eps), 'b--', 'LineWidth', 1.2);
plot(f, 20*log10(abs(HE)+eps), 'r-.', 'LineWidth', 1.2);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title('Butterworth vs Chebyshev I vs Elliptic LPF');
legend('Butterworth', 'Chebyshev I', 'Elliptic', 'Location', 'SouthWest');
ylim([-80 5]);
xlim([0 20000]);
```

특성 차이:

- Butterworth: 통과대역 평탄, 전이대역 상대적으로 넓음.
- Chebyshev I: 통과대역 리플 허용, 전이대역이 더 가파름.
- Elliptic: 통과·저지대역 모두 리플 허용, 전이대역 가장 가파름(최소 차수).

---

## 실전 예제 1 — 오디오 신호에서 고주파 노이즈 제거

### 시나리오

- 샘플링 주파수: $$F_s = 48000\ \mathrm{Hz}$$
- 원 신호: 1 kHz 사인
- 고주파 간섭: 8 kHz 사인
- 목표: 1 kHz 대역은 살리고, 8 kHz 성분은 최대한 제거하는 저역통과 필터 설계

두 가지 버전으로 구현:

1. **FIR (Hamming 창) 저역통과**
2. **IIR (Butterworth) 저역통과**

### GNU Octave 코드

```octave
pkg load signal;
clear; close all; clc;

Fs = 48000;
T  = 1/Fs;
N  = Fs * 0.02;         % 0.02초짜리 신호 (960샘플)
n  = 0:N-1;
t  = n*T;

f_sig = 1000;           % desired tone
f_noise = 8000;         % high-frequency noise

x_sig   = sin(2*pi*f_sig*t);
x_noise = 0.5*sin(2*pi*f_noise*t);
x       = x_sig + x_noise;

% FIR LPF (Hamming)
Nfir = 128;
Fc   = 3000;
Wn   = Fc/(Fs/2);
b_fir = fir1(Nfir, Wn, hamming(Nfir+1));

y_fir = filter(b_fir, 1, x);

% IIR LPF (Butterworth)
Fp  = 3000;
Fs1 = 6000;
Ap  = 1;
As  = 60;
Wp  = Fp/(Fs/2);
Ws  = Fs1/(Fs/2);

[Niir, Wniir] = buttord(Wp, Ws, Ap, As);
[bd, ad]      = butter(Niir, Wniir);
y_iir         = filter(bd, ad, x);

% 시간 영역 비교
figure;
subplot(3,1,1);
plot(t*1000, x, 'LineWidth', 1.0);
grid on;
xlabel('Time (ms)');
ylabel('Amplitude');
title('Original (1kHz + 8kHz)');

subplot(3,1,2);
plot(t*1000, y_fir, 'LineWidth', 1.0);
grid on;
xlabel('Time (ms)');
ylabel('Amplitude');
title(sprintf('FIR LPF Output (N=%d, Fc=%d Hz)', Nfir, Fc));

subplot(3,1,3);
plot(t*1000, y_iir, 'LineWidth', 1.0);
grid on;
xlabel('Time (ms)');
ylabel('Amplitude');
title(sprintf('IIR Butterworth LPF Output (N=%d)', Niir));

% 주파수 영역 비교 (FFT)
Nfft = 4096;
X     = fft(x, Nfft);
Y_fir = fft(y_fir, Nfft);
Y_iir = fft(y_iir, Nfft);
faxis = (0:Nfft-1)*Fs/Nfft;

figure;
subplot(3,1,1);
plot(faxis, 20*log10(abs(X)+eps), 'LineWidth', 1.0);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title('Spectrum of Original Signal');
xlim([0 20000]);
ylim([-100 10]);

subplot(3,1,2);
plot(faxis, 20*log10(abs(Y_fir)+eps), 'LineWidth', 1.0);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title('Spectrum after FIR LPF');
xlim([0 20000]);
ylim([-100 10]);

subplot(3,1,3);
plot(faxis, 20*log10(abs(Y_iir)+eps), 'LineWidth', 1.0);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title('Spectrum after IIR LPF');
xlim([0 20000]);
ylim([-100 10]);
```

이 예제에서 확인할 수 있는 점:

- 원 신호 스펙트럼: 1 kHz, 8 kHz 피크 두 개
- FIR/IIR 필터 후: 8 kHz 피크가 크게 줄어든 것을 확인
- FIR vs IIR의 스펙트럼 형태, 필터 길이에 따른 과도 응답 등

---

## 실전 예제 2 — 센서 데이터 스무딩 (Moving Average vs 저역통과 FIR)

### 시나리오

- 100 Hz 샘플링으로 들어오는 센서 데이터(예: 온도, 가속도)를 가정.
- 실제 신호는 저주파(수 Hz 이하)인데, 측정 과정에서 고주파 잡음이 섞여 있음.
- 목표: 간단한 저역통과 필터로 노이즈를 줄여 부드러운 곡선으로 만들기.

### Moving Average FIR vs 창함수 FIR

Moving Average:

- 길이 $$M$$의 이동 평균은

  $$
  h[n] = \frac{1}{M},\quad 0\le n<M
  $$

로 정의되는 FIR 필터다.

창함수 FIR vs 이동 평균을 간단히 비교해 보자.

```octave
pkg load signal;
clear; close all; clc;

Fs = 100;              % 100 Hz sampling
T  = 1/Fs;
N  = Fs * 10;          % 10초 데이터
n  = 0:N-1;
t  = n*T;

% 저주파 추세 + 고주파 잡음
x_true = 0.5*sin(2*pi*0.2*t) + 0.1*cos(2*pi*0.05*t);  % low-freq
noise  = 0.2*randn(size(t));                          % white noise
x      = x_true + noise;

% 이동 평균 (M=11)
M = 11;
h_ma = ones(1, M)/M;
y_ma = filter(h_ma, 1, x);

% FIR LPF (Hamming, Fc=2 Hz)
Fc   = 2;
Nfir = 64;
Wn   = Fc/(Fs/2);
b_fir = fir1(Nfir, Wn, hamming(Nfir+1));
y_fir = filter(b_fir, 1, x);

figure;
subplot(3,1,1);
plot(t, x, 'Color', [0.7 0.7 0.7]); hold on;
plot(t, x_true, 'k', 'LineWidth', 1.5);
grid on;
xlabel('Time (s)');
ylabel('Value');
title('Noisy Sensor Signal (gray) and True Underlying Trend (black)');

subplot(3,1,2);
plot(t, x, 'Color', [0.8 0.8 0.8]); hold on;
plot(t, y_ma, 'b', 'LineWidth', 1.2);
grid on;
xlabel('Time (s)');
ylabel('Value');
title(sprintf('Moving Average (M=%d)', M));

subplot(3,1,3);
plot(t, x, 'Color', [0.8 0.8 0.8]); hold on;
plot(t, y_fir, 'r', 'LineWidth', 1.2);
grid on;
xlabel('Time (s)');
ylabel('Value');
title(sprintf('FIR LPF (Hamming, N=%d, Fc=%.1f Hz)', Nfir, Fc));
```

- 이동 평균은 구현이 매우 간단하지만, 주파수응답이 그리 이상적이지 않고, 통과대역 내에서도 왜곡이 크다.
- FIR LPF는 더 정교한 주파수 특성을 제공한다(전이대역, 저지대역 감쇠 등).

---

## 설계 자동화 스크립트 예 — FIR/IIR 저역통과를 함수화하기

실무/연구에서 반복해서 저역통과 필터를 설계해야 한다면, 스펙을 인자로 받아서 자동으로 FIR/IIR를 설계하는 간단한 스크립트를 만들어 둘 수 있다.

### 예: FIR 설계 함수 (창합수·등리플 옵션)

```octave
function b = design_lpf_fir(Fs, Fp, Fs1, Ap, As, method, N)
  % Fs   : sampling freq [Hz]
  % Fp   : passband edge [Hz]
  % Fs1  : stopband edge [Hz]
  % Ap   : passband ripple [dB] (창함수에서는 참고용)
  % As   : stopband attenuation [dB] (창함수에서는 Kaiser 등에서 활용)
  % method: "window", "equiripple"
  % N    : filter order (optional; 자동추정도 가능)
  %
  % 반환값: FIR 계수 b (1 x (N+1))

  if nargin < 7
    % 매우 간단한 휴리스틱: FIR 차수는 약간 크게
    % (여기에 Kaiser 근사식을 써서 자동 추정해도 됨)
    Dw = 2*pi*(Fs1 - Fp)/Fs;       % normalized rad/sample transition width
    N_est = ceil((As - 8)/(2.285*Dw));
    N = max(N_est, 20);            % 최소 차수 20 보장
  end

  Wp = Fp/(Fs/2);
  Ws = Fs1/(Fs/2);

  if strcmp(method, "window")
    % Kaiser 창을 사용해 설계
    if As <= 21
      beta = 0;
    elseif As < 50
      beta = 0.5842*(As - 21)^0.4 + 0.07886*(As - 21);
    else
      beta = 0.1102*(As - 8.7);
    end
    b = fir1(N, Wp, kaiser(N+1, beta));

  elseif strcmp(method, "equiripple")
    % 등리플 설계
    f = [0 Wp Ws 1];
    a = [1 1  0 0];
    b = remez(N, f, a);

  else
    error("Unknown method: %s (use 'window' or 'equiripple')", method);
  end
end
```

이 함수를 활용해 필터를 설계하고, 스펙을 확인하는 예:

```octave
pkg load signal;
clear; close all; clc;

Fs  = 48000;
Fp  = 4000;
Fs1 = 6000;
Ap  = 1;
As  = 60;

b_win  = design_lpf_fir(Fs, Fp, Fs1, Ap, As, "window");
b_eq   = design_lpf_fir(Fs, Fp, Fs1, Ap, As, "equiripple");

Nfft = 4096;
[H_win, f] = freqz(b_win, 1, Nfft, Fs);
[H_eq,  ~] = freqz(b_eq,  1, Nfft, Fs);

figure;
plot(f, 20*log10(abs(H_win)+eps), 'b', 'LineWidth', 1.2); hold on;
plot(f, 20*log10(abs(H_eq)+eps),  'r--', 'LineWidth', 1.2);
grid on;
xlabel('Frequency (Hz)');
ylabel('Magnitude (dB)');
title('Window-based FIR vs Equiripple FIR LPF (auto order)');
legend('Window (Kaiser)', 'Equiripple', 'Location', 'SouthWest');
ylim([-100 5]);
xlim([0 20000]);
```

---

## 고정소수점/실수 구현을 염두에 둔 저역통과 설계 체크리스트

저역통과 필터 설계는 Octave 안에서는 “실수 연산에서만” 돌아가지만, 실제 구현은 고정소수점/FPGA/마이크로컨트롤러일 수 있다. 이때 필터 설계를 할 때 미리 체크해야 할 사항들을 요약하면:

1. **FIR vs IIR 선택**
   - 극 안정성을 걱정하고 싶지 않다면: FIR
   - 연산량이 심각하게 제한되고, 약간의 위상 비선형을 허용한다면: IIR

2. **정수 폭/스케일링**
   - FIR: 계수 최대합 $$\sum |h[n]|$$을 기준으로 내부 누산기 범위를 계산.
   - IIR: 각 섹션의 극 반경, 입력/상태의 최대 진폭을 분석해 스케일링.

3. **구조**
   - FIR: Direct form, Transposed form, 선형 위상 구조 등에서 연산량·레이턴시·파이프라인 구조를 고려.
   - IIR: Direct Form II-Transposed, SOS(2차 섹션) 구조를 권장.

4. **계수 양자화 실험**
   - Octave에서 계수를 quantize:
     $$
     \tilde{b}_k = \mathrm{round}(b_k 2^Q) / 2^Q
     $$
   - `freqz`로 양자화 전/후 응답 차이를 시각화.

5. **실제 고정소수점 시뮬레이션**
   - Octave에서 `round`, `saturate` 등의 연산으로 의도적인 정수화 시뮬레이션을 작성.
   - 필터 출력이 포화/래핑 없이 원하는 수준의 SNR을 유지하는지 확인.

저역통과 필터는 흔한 구조이지만, 실제 구현 환경까지 고려하면 이런 세부적인 점들이 필터 설계에서 **성공/실패를 가르는 요소**가 된다.

---

## 연습문제

### 문제 1 — FIR vs IIR 주파수 특성 비교

- 스펙:
  - $$F_s = 48000\ \mathrm{Hz}$$
  - $$F_p = 3000\ \mathrm{Hz}$$
  - $$F_s' = 6000\ \mathrm{Hz}$$
  - $$A_p = 1\ \mathrm{dB},\quad A_s = 60\ \mathrm{dB}$$

1. `design_lpf_fir` 함수(또는 직접 설계)를 사용해
   - 창함수 FIR
   - 등리플 FIR
   두 필터를 설계하고, 크기 응답을 같은 그래프에 그려라.
2. `buttord`, `butter`를 이용해 Butterworth IIR 저역통과를 설계하여 함께 비교하라.
3. 각 필터의
   - 통과대역 리플
   - 저지대역 감쇠
   - 전이대역 폭
   을 수치로 요약해 보고, 설계 스펙과의 차이를 토론하라.

### 문제 2 — 오디오 샘플에 필터 적용하기

1. GNU Octave에서 임의 오디오 파일(예: WAV 형식)을 읽어들여라.
2. 8 kHz 이상의 고주파 잡음을 줄이기 위한 저역통과 FIR/IIR 필터를 설계하라.
   - FIR: Hamming 창 FIR (차수는 64~256 사이에서 적절히 선택)
   - IIR: 6차 Butterworth
3. 오디오에 필터를 적용한 후,
   - 스펙트럼(FFT 기반)을 비교
   - 일부 구간의 파형을 시간 도메인에서 비교
   - 주관적으로 소리를 들어보고, 고주파 성분의 감소 정도를 평가하라.

### 문제 3 — 센서 데이터 스무딩 필터의 설계

1. 100 Hz 샘플링 가상의 센서 데이터(저주파 추세 + 백색 잡음)를 생성하라.
2. Moving Average 필터, FIR 저역통과(창함수), FIR 등리플을 각각 설계/적용하고
   결과 곡선과 원래 추세(노이즈 없는 버전)를 비교하라.
3. 평균제곱오차(MSE)로 세 필터를 비교하고,
   “연산량 vs 성능” 관점에서 어떤 필터가 가장 합리적인 선택인지 논의하라.

### 문제 4 — Kaiser 창의 파라미터 변화 관찰

1. $$A_s = 40, 60, 80\ \mathrm{dB}$$ 세 경우에 대해
   Kaiser 창 FIR 저역통과를 설계하라.
2. 각 경우에 대해
   - 필터 차수 $$N$$ (근사식 기반)
   - 주파수 응답
   - 전이대역 폭
   - 저지대역 감쇠
   를 비교하라.
3. 창 파라미터 $$\beta$$와 필터 특성의 관계를 그래프와 함께 정리하라.

---

## 결론

이 글에서는 **GNU Octave를 이용한 저역통과 필터 설계**를 다음 순서로 정리했다.

1. 설계 스펙(샘플링 주파수, 통과/저지대역, 리플/감쇠)을 정의하고 정규화하는 방법
2. FIR vs IIR 선택 기준
3. FIR 저역통과 설계
   - 이상적인 저역통과 임펄스 응답
   - 창함수 설계(`fir1`, `hamming`, `kaiser`)
   - 창 종류별(직사각, Hamming, Blackman, Kaiser) 특성 비교
   - 등리플 FIR 설계(`remez`)
4. IIR 저역통과 설계
   - Butterworth / Chebyshev / Elliptic 원형 필터
   - `buttord`, `butter`, `cheby1`, `ellip`을 이용한 디지털 저역통과 설계
5. 오디오·센서 데이터에 실제로 필터를 적용하는 실전 예제
6. 설계 자동화 함수, 고정소수점 구현까지 염두에 둔 체크리스트

앞에서 정리한 **원형 아날로그 필터**, **bilinear 변환**, **양자화·계수 정밀도** 글과 연결해서 보면

- “스펙 설정 → 아날로그/디지털 설계 → 구조 선택 → 수치 검증 → 실제 적용”

까지 이어지는 **완전한 저역통과 필터 설계 파이프라인**을 구축할 수 있다.

실제로는, 이 글의 코드를 그대로 복사해 GNU Octave에서 실행하면서

- 스펙을 바꾸고,
- 차수를 바꾸고,
- 창/프로토타입 종류를 바꾸어 보는 과정에서

저역통과 필터 설계 감각이 빠르게 잡힌다.
이후에는 대역통과, 저지통과, 대역저지 등으로 확장해도 원리는 동일하다.
