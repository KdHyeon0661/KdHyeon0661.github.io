---
layout: post
title: 논리회로설계 - 스위칭 식의 대수적 간략화
date: 2025-08-28 18:25:23 +0900
category: 논리회로설계
---
# 스위칭 식의 **대수적 간략화** · **등식의 유효성 증명** · **프로그램화된 예제** · **연습문제** (개정판 2025)

> 표기: $$+\!=\text{OR},\ \cdot\!=\text{AND}\ (\text{또는 생략}),\ \overline{A}\!=\text{NOT }A,\ \oplus\!=\text{XOR}$$
> 목표: 스위칭(부울) 식을 **짧고 얕게** 만들기(게이트 수/깊이/리터럴 수 감소), 등식이 **항상 참**인지 확인하는 여러 증명법, 그리고 이를 **코드로 자동화**하는 방법까지 정리.

---

## 1. 스위칭 식의 **대수적 간략화**

### 1.1 기본 법칙(필수 도구)

$$
A+0=A,\quad A\cdot1=A;\qquad A+1=1,\quad A\cdot0=0
$$

$$
A+A=A,\quad AA=A;\qquad A+\overline{A}=1,\quad A\overline{A}=0
$$

$$
A+B=B+A,\quad AB=BA
$$

$$
(A+B)+C=A+(B+C),\quad (AB)C=A(BC)
$$

$$
A(B+C)=AB+AC,\qquad A+BC=(A+B)(A+C)
$$

$$
A+AB=A,\qquad A(A+B)=A
$$

$$
XY+\overline{X}Y=Y,\qquad XY+X\overline{Y}=X
$$

$$
AB+\overline{A}C+BC=AB+\overline{A}C
$$

$$
\overline{A+B}=\overline{A}\,\overline{B},\qquad \overline{AB}=\overline{A}+\overline{B}
$$

> **메모**
> - 분배법칙은 **두 형태 모두** 외워야 한다: $$A(B+C)\!=\!AB+AC,\ \ A+BC\!=\!(A+B)(A+C).$$
> - 합의(Consensus)는 해저드 제거/완화 설계에도 등장한다(§1.3B, §2.3 참고).

---

### 1.2 간략화 전략(체크리스트)

- [ ] **공통인수** 묶기: $$AB+AC=A(B+C)$$
- [ ] **흡수**로 불필요 항 제거: $$A+AB\rightarrow A$$
- [ ] **합의**로 중복 경로 제거(혹은 해저드 완화 시 **추가**): $$AB+\overline{A}C+BC \to AB+\overline{A}C$$
- [ ] 필요 시 **전개 → 흡수 → 인수화** 순환
- [ ] **비용 지표** 점검: 리터럴 수(PLA 친화), 곱항 수, 게이트 깊이(지연)

> **팁**: “짧은 식”이 항상 “빠른 회로”는 아니다. FPGA에선 전용 **캐리체인/루트 구조** 영향이 크다(§3.2, §3.4의 비용 함수와 함께 보정).

---

### 1.3 단계별 예제

**예제 A — 전개→흡수**

$$
(A+B)(A+\overline{B})
\Rightarrow AA+A\overline{B}+AB+B\overline{B}
\Rightarrow A + A(\overline{B}+B) + 0
\Rightarrow \boxed{A}
$$

**예제 B — 합의 정리**

$$
F=AB+\overline{A}C+BC
\Rightarrow \boxed{F=AB+\overline{A}C}
$$

> 해저드(정적-1) 완화를 원하면 합의항 $$BC$$ 를 **남겨두는** 설계가 유효(§2.3).

**예제 C — 인수화로 종결**

$$
\begin{aligned}
F&=AB+AC+\overline{A}C \\
 &= A(B+C)+\overline{A}C \\
 &= AB + C(A+\overline{A}) \\
 &= \boxed{AB + C}
\end{aligned}
$$

**예제 D — 인접성 소거**

$$
XY+\overline{X}Y=(X+\overline{X})Y = \boxed{Y}
\qquad
XY+X\overline{Y}=(Y+\overline{Y})X = \boxed{X}
$$

**예제 E — XOR 치환으로 축약**

$$
\overline{A}B + A\overline{B} \equiv \boxed{A\oplus B}
$$

> 복합식의 한 블록을 XOR/XNOR로 치환하면 **깊이**와 **게이트 수**를 동시에 줄이는 경우가 많다.

---

## 2. **등식의 유효성 증명**(Equality Validity)

### 2.1 진리표(완전탐색) — 확실함

- 변수 $$n$$개 → $$2^n$$ 입력을 모두 대입해 두 식 $$F,G$$ 의 출력이 **항상 동일**인지 확인.

> 장점: 완전. 단점: $$n$$이 크면 비용 폭증.

---

### 2.2 대수적 유도 — 사람이 읽기 좋음

- 위 **법칙들**로 한쪽을 다른쪽으로 **연쇄 변형**.

**예**: $$(A+B)(A+C)=A+BC$$

$$
\begin{aligned}
(A+B)(A+C) &= AA+AC+AB+BC \\
&= A + A(C+B) + BC \\
&= A + A + BC \\
&= \boxed{A+BC}
\end{aligned}
$$

---

### 2.3 카르노 맵(K-map) — 시각적 동치

- 같은 1-덩어리(최소 커버)를 갖는다면 **동치**.
- 합의/흡수의 효과를 **인접 묶음**으로 직관 확인.

---

### 2.4 샤논 전개(Shannon Expansion)

$$
F=x\cdot F|_{x=1}+\overline{x}\cdot F|_{x=0}
$$

- 공통 변수로 **동일 전개**해 비교하면 동치가 드러남(각 분기에서 동일함을 보이면 전체 동일).

---

### 2.5 반례(비동치 증명): XOR 차 이용

- $$H=F\oplus G$$ 를 만들어 $$H\neq 0$$ 인 입력을 찾으면 **동치 아님**.
- SAT/BDD 툴로 자동화 가능(§3.3의 코드 예제 참조).

---

## 3. **프로그램화된 예제**(Python)

> 목적: 진리표 생성, 등가성 확인, 자동 간략화(심볼릭), 간단 리라이터, 비용 측정까지 **재현 가능**하게.

### 3.1 진리표 & 등가성(완전탐색)

```python
# 진리표 생성 & 등가성 확인
from itertools import product

def truth_table(vars_, f):
    rows=[]
    for bits in product([0,1], repeat=len(vars_)):
        env=dict(zip(vars_, bits))
        rows.append((*bits, int(bool(f(**env)))))
    return rows

# 등식: (A+B)(A+C) == A+BC
def F(A,B,C): return (A or B) and (A or C)
def G(A,B,C): return A or (B and C)

vars_=['A','B','C']
tF=truth_table(vars_, F)
tG=truth_table(vars_, G)

equiv = all(r1[-1]==r2[-1] for r1,r2 in zip(tF,tG))
print("Equivalent:", equiv)  # True

# 반례 출력(있다면)
cts=[bits for bits, vf, vg in zip([r[:-1] for r in tF], [r[-1] for r in tF], [r[-1] for r in tG]) if vf!=vg]
print("Counterexamples:", cts)
```

---

### 3.2 `sympy`로 최소화(DNF/CNF) & 동치 체크

```python
# pip install sympy
from sympy import symbols
from sympy.logic.boolalg import simplify_logic, Equivalent, Xor, And, Or, Not

A,B,C,D = symbols('A B C D')

# 합의 예: AB + A' C + BC  ==  AB + A' C
F1 = Or(And(A,B), And(Not(A),C), And(B,C))
F2 = Or(And(A,B), And(Not(A),C))

print("Consensus equal?:", bool(Equivalent(F1, F2)))   # True
print("F1 DNF:", simplify_logic(F1, form='dnf'))       # A & B | ~A & C
print("F1 CNF:", simplify_logic(F1, form='cnf'))       # CNF형 간략식

# XOR 블록 치환: A'B + AB'  == A ⊕ B
X = Or(And(Not(A),B), And(A,Not(B)))
print("X == A⊕B ?", bool(Equivalent(X, Xor(A,B))))
```

---

### 3.3 SAT 스타일 반례 찾기(심볼릭)

```python
from sympy.logic.boolalg import Xor
from sympy.logic.inference import satisfiable

# 반례 찾기: H = F ⊕ G 가 만족 가능이면 동치 아님
H = Xor(And(Or(A,B), Or(A,C)), Or(A, And(B,C)))  # (A+B)(A+C) vs A+BC
print("Satisfiable(H)?", satisfiable(H))  # False -> 동치
```

---

### 3.4 간단 리라이터(흡수·인접성·합의) — 개념용

```python
# 항을 frozenset({'A','!B','C'})로 들고 다니며 규칙 적용
def absorb(terms):
    terms=set(terms)
    changed=True
    while changed:
        changed=False
        for t in list(terms):
            for u in list(terms):
                if t is u: continue
                # 흡수: t ⊆ u 이면 u 제거 (예: {'A'} absorbs {'A','B'})
                if t.issubset(u):
                    if u in terms:
                        terms.remove(u)
                        changed=True
    return terms

def adjacency_elim(terms):
    # XY + X~Y -> X   /  XY + ~X Y -> Y
    terms=set(terms); changed=True
    while changed:
        changed=False
        T=list(terms)
        for i in range(len(T)):
            for j in range(i+1,len(T)):
                a,b=T[i],T[j]
                # 후보: 두 항이 크기 2이고 한 리터럴만 부정차로 다름
                if len(a)==2 and len(b)==2:
                    pos=lambda lit: lit[0]!='!'
                    # 공통 리터럴 찾기
                    common=a & b
                    if len(common)==1:
                        c=list(common)[0]
                        # 나머지 리터럴이 보완쌍인지 검사
                        u=list(a-common)[0]; v=list(b-common)[0]
                        if u.strip('!')==v.strip('!') and (u!=v):
                            # 소거 결과: 공통 리터럴의 부정 여부 유지
                            terms.discard(a); terms.discard(b)
                            terms.add(frozenset({c}))
                            changed=True; break
            if changed: break
    return terms

def consensus(terms):
    # AB + A' C + BC  형태 탐지 시 BC 제거
    terms=set(terms); removed=True
    while removed:
        removed=False
        T=list(terms)
        for i in range(len(T)):
            for j in range(len(T)):
                if i==j: continue
                P,Q=T[i],T[j]
                # P에 X, Q에 !X가 있고 공통 Y가 있으면 Y가 합의항 후보
                posP={l for l in P if l[0] != '!'}
                negP={l[1:] for l in P if l[0] == '!'}
                posQ={l for l in Q if l[0] != '!'}
                negQ={l[1:] for l in Q if l[0] == '!'}
                Xcands=(posP & negQ) | (posQ & negP)
                if not Xcands: continue
                # 공통 Y (부정 포함)
                commons=(posP & posQ) | { '!'+y for y in (negP & negQ) }
                for Y in commons:
                    R=frozenset([Y])  # 간단화 버전
                    if R in terms:
                        terms.remove(R); removed=True; break
                if removed: break
            if removed: break
    return terms

# 예시: AB + A' C + BC -> AB + A' C
Ts={frozenset({'A','B'}), frozenset({'!A','C'}), frozenset({'B','C'})}
print("absorb:", absorb(Ts))
print("adj:", adjacency_elim(Ts))
print("consensus:", consensus(Ts))  # {'A','B'}, {'!A','C'}
```

> **주의**: 위 리라이터는 **교육용** 스케치다. 실제 최소화기는 파싱/AST·퀘인–맥클러스키/에스프레소 등을 사용.

---

### 3.5 비용 측정(간단 지표)

```python
from sympy import count_ops

def literal_count(expr):
    # ~A, A 를 1리터럴로 센다. 단, 중복은 구조에 의존(대략적 지표).
    # sympy의 atoms, Not 조합으로 근사 가능
    lits=set()
    for a in expr.atoms():
        s=str(a)
        lits.add(s)
    return len(lits)

def gate_count(expr):
    # 심볼릭 연산자 수 기반 근사
    return count_ops(expr, visual=False)

# 예: A+B(C+D)
E = Or(A, And(B, Or(C,D)))
print("literals:", literal_count(E), "gates≈", gate_count(E))
```

---

## 4. **추가 예제** — 대수+코드 병행

### 4.1 복합식 간략화

**문제**
$$
F=(A+B)(A+\overline{B})(\overline{A}+C)
$$

**풀이(대수)**

$$
(A+B)(A+\overline{B})=\boxed{A} \ \Rightarrow\ F=A(\overline{A}+C)=\boxed{AC}
$$

**검증(코드)**

```python
from sympy import symbols, And, Or, Not, Equivalent, simplify_logic
A,B,C = symbols('A B C')
F = And(And(Or(A,B), Or(A,Not(B))), Or(Not(A),C))
G = And(A,C)
print(bool(Equivalent(F,G)))          # True
print("DNF:", simplify_logic(F,'dnf'))
```

---

### 4.2 XOR 블록 + 조건부 보완

**문제**
$$
F=A\overline{B}+ \overline{A}B + AB\overline{C}
$$

**풀이(대수)**

$$
A\overline{B}+ \overline{A}B = A\oplus B
\quad\Rightarrow\quad
\boxed{F=(A\oplus B) + AB\overline{C}}
$$

> 해석: $$(A,B)=(1,1)$$ 에서 XOR가 꺼지므로, 해당 경우를 $$\overline{C}$$ 로 보완.

**검증(코드)**

```python
from sympy import Xor
F = Or(Xor(A,B), And(A,B,Not(C)))
print(simplify_logic(F,'dnf'))  # Xor 블록 + 보완항 확인
```

---

### 4.3 합의항의 설계적 의미(해저드 완화)

**두 식**
- 최소식: $$F_m=AB+\overline{A}C$$
- 합의 포함식: $$F_h=AB+\overline{A}C+BC$$

**관찰**
- $$A$$ 가 0→1 또는 1→0으로 **전이**하면서 $$B=C=1$$ 이면, 이상적 조합논리여도 **경로 지연 차**로 한 틱 0이 출력될 수 있다(정적-1 해저드).
- $$BC$$ 를 추가하면 **겹치는 커버**가 생겨 글리치가 줄어든다.

> **결론**: 최소화만이 해답은 아니다. **타이밍 견고성**도 설계 목표에 포함하라.

---

## 5. 미니 레퍼런스(정규형, 보수, DC)

### 5.1 정규형(SOP/POS)

$$
F=\sum m(I)\quad(\text{출력=1 인덱스 집합 }I),\qquad
F=\prod M(J)\quad(\text{출력=0 인덱스 집합 }J)
$$

### 5.2 보수와 여집합

$$
\overline{F}=\prod M(\mathcal{U}\setminus I),\qquad
\overline{F}=\sum m(\mathcal{U}\setminus J)
$$

### 5.3 비완전 명세(DC)

- $$\mathcal{DC}$$ 를 0/1로 임의 할당하여 **묶음 최대화 → 회로 최소화**
- 단, 시스템에서 그 조합이 **절대 발생하지 않음**을 보장할 것(안전성).

---

## 6. 연습문제(풀세트)

> 해설이 필요하면 이어서 별도 포스트로 제공. 아래 코드를 이용해 **직접 검증**해도 좋다.

### 6.1 대수적 간략화

1. $$F=(A+B)(A+\overline{B})(\overline{A}+C)$$ 를 가능한 한 간단히 하라.
2. $$F=AB+AC+\overline{A}C$$ 를 간략화하라(힌트: 인수화 후 항등).
3. $$F=A\overline{B}+ \overline{A}B + AB\overline{C}$$ 를 간략화하라(힌트: XOR 관찰).
4. $$F=(A+B)(C+D) + AB$$ 를 **SOP로 전개** 후 흡수로 최소화하라.

### 6.2 등식의 유효성 증명

5. $$(A+B)(A+C)=A+BC$$ 임을 대수/진리표로 증명하라.
6. $$A+\overline{A}B = A+B$$ 임을 보이라(대수 또는 코드).
7. $$AB+\overline{A}C+BC = AB+\overline{A}C$$ 를 합의 정리로 보이고, K-map에서 시각화 설명하라.

### 6.3 프로그램화 검증

8. Python으로 문제 5의 두 식의 등가성(True/False)을 출력하라.
9. `sympy.simplify_logic`으로 $$F=AB+\overline{A}C+BC$$ 의 DNF/CNF를 구해 **최소식**을 확인하라.
10. (선택) §3.4의 리라이터에 **흡수**만 적용해 1–2번의 결과가 기대와 일치하는지 확인하라.

---

## 7. 부록 — 실전 팁 & 함정

- **두 개의 분배**: $$A(B+C)$$ 와 $$A+BC$$ 는 서로의 쌍대. **둘 다** 자연스럽게 써야 한다.
- **부분 반전 금지**: $$\overline{A+BC}\neq \overline{A}+\overline{B}C$$ (드모르간은 **괄호 전체**).
- **XOR 오해 주의**: $$A\oplus B\oplus C$$ 는 “홀수 개 1”이지 “정확히 하나 1”이 아니다.
- **최소≠최적**: 최소 리터럴이 항상 최소 지연을 의미하진 않는다(FPGA/ASIC 타깃 최적화를 고려).
- **검증 우선**: 간략화 후엔 **진리표/심볼릭 동치**를 반드시 확인(§3.1–3.3).

---

## 8. 실전용 코드 스니펫 모음

### 8.1 등가성/반례/최소화 파이프라인

```python
# 실전 파이프라인: 정의 -> 등가성 -> 반례 -> DNF/CNF -> 비용
from sympy import symbols, And, Or, Not, Xor, Equivalent
from sympy.logic.boolalg import simplify_logic
from sympy.logic.inference import satisfiable
from sympy import count_ops

A,B,C,D = symbols('A B C D')

F = And(Or(A,B), Or(A,C))     # (A+B)(A+C)
G = Or(A, And(B,C))           # A + BC

print("Equivalent:", bool(Equivalent(F,G)))

H = Xor(F,G)
print("Counterexample (if any):", satisfiable(H))  # False면 동치

F_dnf = simplify_logic(F, form='dnf')
F_cnf = simplify_logic(F, form='cnf')
print("DNF:", F_dnf)
print("CNF:", F_cnf)

def lit_count(expr):
    # 간단 근사: 심볼 개수 + 부정 등장 반영
    lits=set()
    for a in expr.atoms():
        if a.is_Symbol: lits.add(a)
    # 부정은 Not 노드 수로 근사
    negs = sum(1 for node in preorder(expr) if getattr(node, 'func', None) is Not)
    return len(lits) + negs

from sympy import preorder
print("ops≈", count_ops(F), "lits≈", lit_count(F))
```

### 8.2 진리표 자동 생성기(LaTeX/Markdown 친화 출력)

```python
from itertools import product

def table(vars_, f):
    header = " | ".join(vars_+['F'])
    print(header); print("-"*len(header))
    for bits in product([0,1], repeat=len(vars_)):
        env=dict(zip(vars_,bits))
        print(" ".join(map(str,bits)), "|", int(bool(f(**env))))

# 예: Majority 3입력: F=AB+AC+BC
def maj(A,B,C): return (A and B) or (A and C) or (B and C)
table(['A','B','C'], maj)
```

---

## 9. 요약(포켓 카드)

- **핵심 법칙**: 항등/지배/멱등/보수, 교환/결합/분배(두 형태), 흡수, 인접성 소거, 합의, 드모르간
- **전략**: 전개→흡수→인수화 **루프**로 리터럴/깊이/게이트 수 동시 감소
- **증명**: 진리표, 대수 유도, K-map, 샤논 전개, XOR-차 SAT 반례
- **코드**: 진리표/동치/최소화 자동화로 **재현성** 확보
- **설계**: 최소화만 고집하지 말고 **타이밍 견고성(해저드)** 과 타깃(FPGA/ASIC) 특성까지 고려
