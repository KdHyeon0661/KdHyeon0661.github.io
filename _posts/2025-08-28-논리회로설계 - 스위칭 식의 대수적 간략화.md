---
layout: post
title: 논리회로설계 - 스위칭 식의 대수적 간략화
date: 2025-08-28 18:25:23 +0900
category: 논리회로설계
---
# 스위칭 식의 **대수적 간략화** · **등식의 유효성 증명** · **프로그램화된 예제** · **연습문제**

> 목표: 스위칭(부울) 식을 **짧고 얕게** 만들기(게이트 수/깊이/리터럴 수 감소), 등식이 **항상 참**인지 확인하는 여러 증명법, 그리고 이를 **코드로 자동화**하는 방법까지 정리합니다.  
> 표기: \(+\)=OR, \(\cdot\) 또는 생략=AND, \(\overline{A}\)=NOT A, \(\oplus\)=XOR.

---

## 1) 스위칭 식의 **대수적 간략화**

### 1.1 기본 법칙(필수 도구)
- **항등/지배/멱등/보수**
  \[
  A+0=A,\;A\cdot1=A;\quad A+1=1,\;A\cdot0=0;\quad
  A+A=A,\;AA=A;\quad A+\overline{A}=1,\;A\overline{A}=0
  \]
- **교환/결합/분배**
  \[
  A+B=B+A,\;AB=BA;\quad (A+B)+C=A+(B+C),\;(AB)C=A(BC)
  \]
  \[
  A(B+C)=AB+AC,\quad A+BC=(A+B)(A+C)
  \]
- **흡수**
  \[
  A+AB=A,\quad A(A+B)=A
  \]
- **인접성 소거**
  \[
  XY+\overline{X}Y=Y,\quad XY+X\overline{Y}=X
  \]
- **합의(컨센서스)**
  \[
  AB+\overline{A}C+BC=AB+\overline{A}C
  \]
- **드모르간**
  \[
  \overline{A+B}=\overline{A}\,\overline{B},\quad \overline{AB}=\overline{A}+\overline{B}
  \]

### 1.2 간략화 전략(체크리스트)
- [ ] **공통인수** 묶기: \(AB+AC=A(B+C)\)  
- [ ] **흡수**로 불필요 항 제거: \(A+AB\to A\)  
- [ ] **합의**로 중복 경로 제거(혹은 해저드 완화 시 **추가**): \(AB+\overline{A}C+BC \to AB+\overline{A}C\)  
- [ ] 필요 시 **전개→흡수→인수화** 순환  
- [ ] 비용 지표 최소화: 리터럴 수, 곱항 수(PLA), 게이트 깊이

### 1.3 단계별 예제

**예제 A**  
\[
(A+B)(A+\overline{B})
\Rightarrow AA+A\overline{B}+AB+B\overline{B}
\Rightarrow A + A(\overline{B}+B) + 0
\Rightarrow A
\]

**예제 B (합의 정리)**  
\[
F=AB+\overline{A}C+BC
\Rightarrow AB+\overline{A}C
\]
> 해저드(정적-1) 완화를 원하면 \(+BC\) 를 **남겨두는** 설계 선택이 유효.

**예제 C (인수화로 종결)**  
\[
F=AB+AC+\overline{A}C
= A(B+C)+\overline{A}C
= AB + C(A+\overline{A})
= AB + C
\]

---

## 2) **등식의 유효성 증명**(Equality Validity)

### 2.1 진리표(완전탐색) — 가장 확실
- 변수 \(n\)개 → **\(2^n\)** 가지 입력을 모두 대입해 \(F\)와 \(G\)가 항상 동일한지 확인.
- 장점: 확실. 단점: \(n\) 커지면 비용↑.

### 2.2 대수적 유도 — 사람이 읽기 좋음
- 위 **법칙들**만 사용하여 한 쪽을 다른 쪽으로 **연쇄 변형**.
- 예) \((A+B)(A+C)=A+BC\)
  \[
  (A+B)(A+C)=AA+AC+AB+BC = A + A(C+B) + BC = A + A + BC = A+BC
  \]

### 2.3 카르노 맵(K-map) — 시각적 동치
- 같은 1-덩어리(최소 커버)를 갖는다면 **동치**.  
- 특히 합의/흡수 효과를 직관적으로 확인 가능.

### 2.4 샤논 전개(Shannon Expansion)
\[
F=x\cdot F|_{x=1}+\overline{x}\cdot F|_{x=0}
\]
- **모든 변수에 대해 동일**한 전개로 둘 식을 비교하면 동치가 드러남.

### 2.5 대수적 반례(비동치 증명)
- 두 식의 **차** \(H=F\oplus G\) 를 만들어 \(H\neq 0\) 을 보이면 **동치 아님**.  
  (하나라도 입력에서 1이면 반례.)

---

## 3) **프로그램화된 예제**(Python)

> 아래 코드는 **진리표 생성**, **등가성 확인**, **자동 간략화**를 보입니다.  
> (수행 환경에 `sympy`가 있다면 `simplify_logic`, `Equivalent` 사용 가능)

### 3.1 진리표 생성 & 등가성 확인
```python
# 프로그램화된 등식 검증 (진리표 방식)
from itertools import product

def truth_table(vars, f):
    rows = []
    for bits in product([0,1], repeat=len(vars)):
        env = dict(zip(vars, bits))
        rows.append((bits, f(**env)))
    return rows

# 등식: (A+B)(A+C) == A+BC
def F(A,B,C): return (A or B) and (A or C)
def G(A,B,C): return A or (B and C)

vars = ['A','B','C']
rows_F = truth_table(vars, F)
rows_G = truth_table(vars, G)

equal = all(rf[1] == rg[1] for rf, rg in zip(rows_F, rows_G))
print("Equivalent:", equal)            # 기대: True
print("Counterexamples:",
      [bits for (bits, vf), (_, vg) in zip(rows_F, rows_G) if vf != vg])
```

### 3.2 `sympy`로 간략화(SOP/POS) & 등가성
```python
# pip install sympy  (사전 설치 필요)
from sympy import symbols
from sympy.logic.boolalg import simplify_logic, Equivalent

A,B,C = symbols('A B C')

F1 = (A & B) | (~A & C) | (B & C)
F2 = (A & B) | (~A & C)

print("Consensus equal?:", Equivalent(F1, F2))        # 기대: True
print("F1 DNF:", simplify_logic(F1, form='dnf'))      # 기대: A&B | ~A&C
print("F1 CNF:", simplify_logic(F1, form='cnf'))      # CNF형 간략식
```

### 3.3 간단 리라이터(흡수·인접성·합의 적용)
> 규칙 기반 미니 리라이터는 완전한 최소화기는 아니지만, **설계 의도**에 맞는 간략화(흡수/인접성/합의)를 자동 적용하는 데 유용합니다. (완전한 구현은 파서/AST가 필요)
```python
# 개념용 스케치: "리스트로 항을 들고 다니며" 흡수/합의 적용
# 항은 frozenset({'A', '!B', 'C'})처럼 리터럴의 집합으로 표현
def absorb(terms):
    terms = set(terms)
    changed = True
    while changed:
        changed = False
        for t in list(terms):
            for u in list(terms):
                if t is u: continue
                # 흡수: t ⊆ u 이면 u 제거 (예: A absorbs AB)
                if t.issubset(u):
                    if u in terms:
                        terms.remove(u)
                        changed = True
    return terms

def consensus(terms):
    # AB + A' C + BC  형태 탐지 시 BC 제거
    terms = set(terms)
    lits = lambda T: ({l for l in T if not l.startswith('!')},
                      {l[1:] for l in T if l.startswith('!')})
    removed = True
    while removed:
        removed = False
        T = list(terms)
        for i in range(len(T)):
            for j in range(len(T)):
                if i==j: continue
                P, Q = T[i], T[j]
                posP, negP = lits(P); posQ, negQ = lits(Q)
                # P: X 포함, Q: !X 포함, 공통 Y가 있으면 R=Y 형태 합의항 찾기
                Xcands = (posP & negQ) | (posQ & negP)
                if not Xcands: continue
                # 공통 Y 찾기
                Ys = (posP & posQ) | ({'!'+y for y in (negP & negQ)})
                for Y in Ys:
                    R = frozenset([Y])  # 합의항 후보
                    if R in terms:
                        terms.remove(R)
                        removed = True
                        break
                if removed: break
            if removed: break
    return terms

# 예제: AB + A' C + BC  (-> AB + A' C)
terms = {frozenset({'A','B'}), frozenset({'!A','C'}), frozenset({'B','C'})}
print("absorbed:", absorb(terms))
print("consensus:", consensus(terms))  # 기대: {'A','B'}, {'!A','C'}만 남음
```

---

## 4) **연습문제**

> 해설은 요청 시 별도 포스트로 제공합니다(또는 프로그램으로 검증해 보세요!).

### 4.1 대수적 간략화
1. \(F=(A+B)(A+\overline{B})(\overline{A}+C)\) 를 가능한 한 간단히.  
2. \(F=AB+AC+\overline{A}C\) 를 간략화(힌트: 인수화 후 항등).  
3. \(F=A\overline{B}+ \overline{A}B + AB\overline{C}\) 를 간략화(힌트: XOR 관찰).

### 4.2 등식의 유효성 증명
4. \((A+B)(C+D)=AC+AD+BC+BD\) 임을 증명(대수/진리표 택1).  
5. \(A+\overline{A}B = A+B\) 임을 증명(대수 또는 프로그램으로).  
6. \(AB+\overline{A}C+BC = AB+\overline{A}C\) 임을 **합의 정리**로 보이고, K-map에서 시각화 설명.

### 4.3 프로그램화 검증
7. Python으로 \(F=(A+B)(A+C)\), \(G=A+BC\) 의 등가성(True/False)을 출력.  
8. `sympy`의 `simplify_logic`으로 \(F=AB+\overline{A}C+BC\) 의 DNF/CNF를 구해 최소식을 확인.  
9. (선택) 위 3.3의 리라이터에 **흡수**만 적용해 1–2번 문제의 결과가 기대와 일치하는지 확인.

---

## 5) 마무리 포인트
- 간략화는 **분배⇄인수화**·**흡수**·**합의**의 **연쇄**다.  
- **대수/진리표/K-map/샤논 전개**는 서로를 보완하는 **증명 툴킷**이다.  
- 코드(진리표 생성, `sympy` 최소화)를 곁들이면 **오류를 줄이고** 글의 재현성을 높일 수 있다.