---
layout: post
title: 디자인패턴 - 디자인 패턴을 활용한 코드 리팩토링 사례
date: 2025-07-05 23:20:23 +0900
category: 디자인패턴
---
# 디자인 패턴을 활용한 코드 리팩토링 사례

## 들어가기 전에 — 언제 패턴으로 리팩토링할까?

### 대표 Code Smell ↔ 패턴 매핑

| 냄새(Code Smell) | 징후 | 권장 패턴 |
|---|---|---|
| 거대한 if/elif/switch 분기 | 타입·모드·정책 추가 때마다 조건 분기 확장 | Strategy, State, Chain of Responsibility |
| 전역 변수/싱글톤 남발 | 테스트 어려움, 숨은 의존성 | DI(의존성 주입), Factory, Singleton(필요 최소) |
| 생성자 인자 과다(텔레스코핑) | 선택 인자 많음, 가독성 저하 | Builder, Abstract Factory |
| 중복 코드로 기능 확장 | 기능마다 래핑 복붙 | Decorator, Proxy |
| 직렬 필터 처리 | 유효성검사→표준화→인가→로깅 순서 처리 | Chain of Responsibility, Pipeline |
| 서브시스템 호출이 난잡 | 클라이언트 코드가 하위 모듈을 너무 많이 앎 | Facade, Mediator |
| 상태 플래그 분기 | 상태 전이에 따라 행위 달라짐 | State, Memento(Undo) |
| 안정된 구조에 새 연산 추가 | AST, 도큐먼트 노드 등에 기능 추가 | Visitor |

### 복잡도 관점

- **순환 복잡도(CC)** 를 줄이는 것이 목표다. 전통 공식은 다음과 같다.

  $$M = E - N + 2P$$

  여기서 \(M\)은 사이클로매틱 복잡도, \(E\)는 간선 수, \(N\)은 노드 수, \(P\)는 연결 컴포넌트 수다. 거대한 분기를 **전략/상태 객체로 분산**하면 한 클래스의 분기 수가 줄어 \(M\)을 낮출 수 있다.

---

## 조건문/분기문 남발 → Strategy 패턴

### Before

```python
def calculate_price(product_type: str, amount: int) -> int:
    if product_type == "A":
        return amount * 100
    elif product_type == "B":
        return amount * 80
    elif product_type == "C":
        return amount * 120
    else:
        raise ValueError("Invalid product type")
```

문제
- 타입 추가 시 기존 함수를 수정(OCP 위배).
- 테스트가 product_type 조합에 종속.
- 다른 할인 정책 등으로 분기가 더 늘어남.

### After — 기본 Strategy

```python
from abc import ABC, abstractmethod

class PricingStrategy(ABC):
    @abstractmethod
    def calculate(self, amount: int) -> int: ...

class ProductA(PricingStrategy):
    def calculate(self, amount: int) -> int: return amount * 100

class ProductB(PricingStrategy):
    def calculate(self, amount: int) -> int: return amount * 80

class ProductC(PricingStrategy):
    def calculate(self, amount: int) -> int: return amount * 120

class PriceCalculator:
    def __init__(self, strategy: PricingStrategy):
        self._strategy = strategy
    def set_strategy(self, strategy: PricingStrategy):
        self._strategy = strategy
    def calculate(self, amount: int) -> int:
        return self._strategy.calculate(amount)

# 사용

calc = PriceCalculator(ProductA())
assert calc.calculate(5) == 500
calc.set_strategy(ProductC())
assert calc.calculate(2) == 240
```

### Strategy 선택 로직 외부화 — Registry/Factory/DI

```python
STRATEGY_REGISTRY = {
    "A": ProductA,
    "B": ProductB,
    "C": ProductC,
}

def create_pricing_strategy(kind: str) -> PricingStrategy:
    try:
        return STRATEGY_REGISTRY[kind]()
    except KeyError:
        raise ValueError(f"Unknown product type: {kind}")

calc = PriceCalculator(create_pricing_strategy("B"))
```

C#/.NET의 DI 예:

```csharp
// 등록
services.AddTransient<PricingStrategy, ProductA>();
services.AddTransient<ProductA>();
services.AddTransient<ProductB>();
services.AddTransient<ProductC>();
services.AddTransient<Func<string, PricingStrategy>>(sp => key =>
{
    return key switch
    {
        "A" => sp.GetRequiredService<ProductA>(),
        "B" => sp.GetRequiredService<ProductB>(),
        "C" => sp.GetRequiredService<ProductC>(),
        _ => throw new ArgumentOutOfRangeException(nameof(key))
    };
});

// 사용
public sealed class PriceCalculator
{
    private readonly Func<string, PricingStrategy> _factory;
    public PriceCalculator(Func<string, PricingStrategy> factory) => _factory = factory;
    public int Calculate(string kind, int amount) => _factory(kind).Calculate(amount);
}
```

### 테스트 포인트

- 각 전략의 독립 단위 테스트.
- 등록 누락 시 예외 동작.
- 전략 교체가 상태를 공유하지 않음을 확인(불변/무상태 권장).

---

## 전역 인스턴스 남용 → Singleton 대신 DI로 치환 (필요 최소의 Singleton)

### Before

```python
config = {"env": "prod", "endpoint": "https://api.example.com"}
def get_config(): return config  # 어디서든 쓰고, 어디서든 바뀜
```

문제
- 암묵적 전역 상태로 인해 테스트와 모킹이 어려움.
- 의존이 숨겨져 DIP 위배.

### After — 생성자 주입

```python
class Config:
    def __init__(self, env: str, endpoint: str):
        self.env = env
        self.endpoint = endpoint

class ApiClient:
    def __init__(self, cfg: Config):
        self._cfg = cfg
    def get_base(self):
        return self._cfg.endpoint
```

테스트:

```python
fake = Config(env="test", endpoint="http://localhost:5000")
client = ApiClient(fake)
assert client.get_base() == "http://localhost:5000"
```

### 정말 전역 1개가 필요한 경우의 안전한 Singleton

```python
import threading

class SafeSingleton:
    _instance = None
    _lock = threading.Lock()

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:  # fast-path
            with cls._lock:
                if cls._instance is None:  # double-checked
                    cls._instance = super().__new__(cls)
                    cls._instance.init_once(*args, **kwargs)
        return cls._instance

    def init_once(self, *args, **kwargs):
        self.env = kwargs.get("env", "prod")
```

주의
- 테스트 병렬성/순서를 깨뜨릴 수 있다. 가능하면 DI로 대체.
- 생성 시점 제어가 어렵다.

---

## 복잡한 객체 생성 → Builder로 정리

### Before

```python
# 텔레스코핑: 위치, 권한, 알림설정 등 인자 폭증

def create_user(name, email, address=None, phone=None, role="user", newsletter=False, marketing_opt_in=False, tags=None):
    return {
        "name": name, "email": email, "address": address, "phone": phone,
        "role": role, "newsletter": newsletter, "marketing_opt_in": marketing_opt_in,
        "tags": tags or []
    }
```

문제
- 인자 순서·기본값 실수 위험.
- 필수/선택 구분 불명확.

### After — Fluent Builder

```python
class User:
    def __init__(self, name, email, address=None, phone=None, role="user",
                 newsletter=False, marketing_opt_in=False, tags=None):
        self.name = name; self.email = email; self.address = address; self.phone = phone
        self.role = role; self.newsletter = newsletter; self.marketing_opt_in = marketing_opt_in
        self.tags = tags or []

class UserBuilder:
    def __init__(self, name: str, email: str):
        self._name = name; self._email = email
        self._address = None; self._phone = None; self._role = "user"
        self._newsletter = False; self._marketing_opt_in = False; self._tags = []

    def address(self, v): self._address = v; return self
    def phone(self, v): self._phone = v; return self
    def role(self, v): self._role = v; return self
    def newsletter(self, v=True): self._newsletter = v; return self
    def marketing(self, v=True): self._marketing_opt_in = v; return self
    def add_tag(self, v): self._tags.append(v); return self

    def build(self) -> User:
        return User(self._name, self._email, self._address, self._phone, self._role,
                    self._newsletter, self._marketing_opt_in, list(self._tags))

user = (UserBuilder("Alice", "alice@example.com")
        .address("Seoul")
        .role("admin")
        .newsletter()
        .add_tag("vip")
        .build())
```

확장
- **불변 모델**을 원하면 `@dataclass(frozen=True)`(Python) 또는 빌더에서만 내부 값을 조립.

---

## 상태 전환을 if로 처리 → State 패턴

### Before

```python
def discount(user_type: str) -> int:
    if user_type == "guest": return 0
    if user_type == "member": return 10
    if user_type == "vip": return 20
    raise ValueError("unknown")
```

여기서는 단순하지만, 실제로는 **전이 규칙**과 **허용 행위**가 얽혀 커진다.

### After — 상태 객체로 전이 캡슐화

```python
from abc import ABC, abstractmethod

class Context:
    def __init__(self):
        self._state: "State" = Guest()
    def set_state(self, s: "State"): self._state = s
    def discount(self) -> int: return self._state.discount(self)
    def promote(self): self._state.promote(self)

class State(ABC):
    @abstractmethod
    def discount(self, ctx: Context) -> int: ...
    @abstractmethod
    def promote(self, ctx: Context) -> None: ...

class Guest(State):
    def discount(self, ctx): return 0
    def promote(self, ctx): ctx.set_state(Member())

class Member(State):
    def discount(self, ctx): return 10
    def promote(self, ctx): ctx.set_state(VIP())

class VIP(State):
    def discount(self, ctx): return 20
    def promote(self, ctx): pass  # 상한

ctx = Context()
assert ctx.discount() == 0
ctx.promote(); assert ctx.discount() == 10
ctx.promote(); assert ctx.discount() == 20
```

전이 테이블로도 구현 가능:

```python
TRANSITIONS = {
    ("guest", "promote"): "member",
    ("member", "promote"): "vip",
}
```

---

## 직렬 필터링/검증 로직 → Chain of Responsibility

### Before

```python
def process(order):
    if not order.items: raise ValueError("empty")
    if order.total < 0: raise ValueError("negative")
    if not order.user.active: raise PermissionError()
    # 계속 분기...
    return "ok"
```

### After — 체인으로 연결

```python
from abc import ABC, abstractmethod

class Handler(ABC):
    def __init__(self, nxt: "Handler" = None): self._next = nxt
    def set_next(self, nxt: "Handler"): self._next = nxt; return nxt
    @abstractmethod
    def handle(self, order): ...

class NonEmpty(Handler):
    def handle(self, order):
        if not order.items: raise ValueError("empty")
        if self._next: self._next.handle(order)

class NonNegative(Handler):
    def handle(self, order):
        if order.total < 0: raise ValueError("negative")
        if self._next: self._next.handle(order)

class ActiveUser(Handler):
    def handle(self, order):
        if not order.user.active: raise PermissionError()
        if self._next: self._next.handle(order)

# 체인 구성

chain = NonEmpty(NonNegative(ActiveUser()))
chain.handle(order)
```

장점
- 정책 추가/순서 변경이 용이.
- 구성(조립)을 코드 밖 설정으로 옮기기 쉽다(JSON/DI).

---

## 공통 횡단 관심사 로깅/캐싱/권한 → Decorator/Proxy

### Before

```python
def get_user(uid):
    print("call db")
    u = db.fetch(uid)
    print("done")
    return u
```

모든 함수에 로깅/캐싱 추가는 중복·실수 유발.

### After — Decorator

```python
import functools, time

def log_calls(fn):
    @functools.wraps(fn)
    def wrapper(*a, **kw):
        t0 = time.time()
        try:
            return fn(*a, **kw)
        finally:
            dt = time.time() - t0
            print(f"{fn.__name__} took {dt:.3f}s")
    return wrapper

@log_calls
def get_user(uid):
    return db.fetch(uid)
```

### After — Proxy(캐시, 권한, 원격)

```python
class UserRepo:
    def get(self, uid): ...
class DbUserRepo(UserRepo):
    def get(self, uid): return db.fetch(uid)

class CachingUserRepo(UserRepo):
    def __init__(self, inner: UserRepo):
        self._inner = inner; self._cache = {}
    def get(self, uid):
        if uid in self._cache: return self._cache[uid]
        u = self._inner.get(uid)
        self._cache[uid] = u
        return u

repo = CachingUserRepo(DbUserRepo())
```

---

## Undo/Redo가 필요한 편집기·도면 도구 → Command + Memento

### Command로 행동 캡슐화

```python
from abc import ABC, abstractmethod

class Command(ABC):
    @abstractmethod
    def execute(self): ...
    @abstractmethod
    def undo(self): ...

class InsertText(Command):
    def __init__(self, doc, pos, text):
        self.doc=doc; self.pos=pos; self.text=text
    def execute(self): self.doc.insert(self.pos, self.text)
    def undo(self): self.doc.delete(self.pos, len(self.text))

class History:
    def __init__(self): self._stack=[]
    def do(self, cmd: Command):
        cmd.execute(); self._stack.append(cmd)
    def undo(self):
        if self._stack: self._stack.pop().undo()
```

### 상태 스냅샷은 Memento

```python
class Memento:
    def __init__(self, state: str): self._s=state
    def state(self): return self._s

class Editor:
    def __init__(self): self._text=""
    def set_text(self, t): self._text=t
    def text(self): return self._text
    def save(self): return Memento(self._text)
    def restore(self, m: Memento): self._text = m.state()
```

---

## 서브시스템 의존 난립 → Facade로 단순화

### Before

```python
# 컨트롤러에서 서비스/리포/외부API를 직접 얽음

def place_order(req):
    user = user_repo.find(req.uid)
    stock = inventory.check(req.sku, req.qty)
    pay = gateway.charge(req.card, req.amount)
    invoice = pdf.generate(req)
    mail.send(user.email, invoice)
    # ...
```

### After — Facade

```python
class CheckoutFacade:
    def __init__(self, user_repo, inventory, gateway, pdf, mail):
        self.user_repo=user_repo; self.inventory=inventory
        self.gateway=gateway; self.pdf=pdf; self.mail=mail

    def place(self, req):
        user = self.user_repo.find(req.uid)
        self.inventory.reserve(req.sku, req.qty)
        self.gateway.charge(req.card, req.amount)
        invoice = self.pdf.generate(req)
        self.mail.send(user.email, invoice)
        return invoice
```

컨트롤러는 Facade만 의존:

```python
def place_order(req, facade: CheckoutFacade):
    return facade.place(req)
```

---

## 안정된 구조(AST/문서)에 연산 추가 → Visitor

```python
from abc import ABC, abstractmethod

class Node(ABC):
    @abstractmethod
    def accept(self, v): ...

class Text(Node):
    def __init__(self, s): self.s=s
    def accept(self, v): return v.visit_text(self)

class Bold(Node):
    def __init__(self, child): self.child=child
    def accept(self, v): return v.visit_bold(self)

class Visitor(ABC):
    @abstractmethod
    def visit_text(self, t: Text): ...
    @abstractmethod
    def visit_bold(self, b: Bold): ...

class HtmlRender(Visitor):
    def visit_text(self, t): return t.s
    def visit_bold(self, b): return f"<b>{b.child.accept(self)}</b>"

doc = Bold(Text("hello"))
assert doc.accept(HtmlRender()) == "<b>hello</b>"
```

---

## 적용 절차 — 안전한 리팩토링 체크리스트

1) **테스트 고도화**: 리팩토링 전 관찰 가능한 행동에 대한 회귀 테스트를 미리 작성.
2) **냄새 식별**: 분기 폭발, 전역, 생성자 과다, 횡단 관심사 중 우선순위를 정한다.
3) **패턴 선택**: 전이(State)인지 교체(Strategy)인지부터 결정.
4) **인터페이스 추출**: 공통 동작 시그니처를 정의.
5) **작게 분리**: 최소 단위의 Concrete 구현을 만든다.
6) **조립으로 치환**: 직접 new 대신 팩토리/DI로 전환.
7) **회귀 테스트**: 기존 테스트를 재실행, 행동 유지 확인.
8) **문서화**: 전이 다이어그램, 체인 구성, 등록 키 등 운영 관점 문서 반영.

---

## 성능·메모리·복잡도 트레이드오프

- **클래스 수 증가**: 객체 수가 늘고 심리적 복잡도가 높아질 수 있다. 패키지 구조·네이밍 규칙으로 관리.
- **간접 호출 비용**: 대부분 미미하나, 초저지연 구간에서는 **분기 제거 vs 가상 호출**을 측정으로 판단.
- **상태 공유 금지**: Strategy/State는 가능하면 **불변**으로 설계. 공유가 필요하면 외부로 올려라.
- **캐싱**: Proxy/Decorator에서 캐시 누락/갱신 일관성을 명확히 규정.

---

## 통합 예제 — 결제 플로우 리팩토링

### 요구

- 결제 수단 선택(카드/포인트/간편결제) → Strategy
- 주문 검증 파이프라인 → Chain of Responsibility
- 외부 결제 게이트웨이 호출 로깅/재시도 → Decorator/Proxy
- 결제 시도/완료/실패 상태 전이 → State
- PDF 영수증/메일 발송 복잡도 → Facade

### 조립 코드 스케치

```python
# 결제 전략

payment = PaymentService(strategy=factory("card"))  # Strategy

# 유효성 파이프라인

validators = NonEmpty(NonNegative(StockAvailable()))
validators.handle(order)  # Chain

# 게이트웨이 호출 래핑

gateway = RetryProxy(LoggingProxy(RealGateway()))
payment.set_gateway(gateway)  # Decorator/Proxy

# 상태 전이

ctx = PaymentContext()  # State
ctx.dispatch("start")
try:
    payment.pay(order)
    ctx.dispatch("success")
except Exception:
    ctx.dispatch("fail")

# 사후 처리

invoice = CheckoutFacade(user_repo, inventory, pdf, mail).place(order)  # Facade
```

---

## 단위 테스트 예시(PyTest)

```python
def test_strategy_switch():
    svc = PriceCalculator(ProductA())
    assert svc.calculate(2) == 200
    svc.set_strategy(ProductC())
    assert svc.calculate(2) == 240

def test_chain_validation_ok(order_ok):
    chain = NonEmpty(NonNegative(ActiveUser()))
    chain.handle(order_ok)  # 예외 없어야 통과

def test_state_transitions():
    ctx = Context()
    ctx.promote()
    assert ctx.discount() == 10
    ctx.promote()
    assert ctx.discount() == 20
```

---

## 패턴 선택 결정 트리(요약)

```
문제는 "전이"인가 "교체"인가?
     ├─ 교체(알고리즘 다양) → Strategy
     └─ 전이(FSM/단계)     → State

필터를 직렬로 적용해야 하는가? → Chain of Responsibility
횡단 관심사를 섞지 않고 추가? → Decorator/Proxy
생성자 인자가 과다/선택적? → Builder
서브시스템 의존을 단순화? → Facade
Undo/Redo가 핵심? → Command + Memento
안정된 구조에 연산 추가? → Visitor
```

---

## 마무리

- **전략 vs 상태**: 교체는 Strategy, 전이는 State.
- **DI/팩토리**로 조립을 외부화하면 OCP·DIP를 자연스럽게 달성한다.
- 패턴은 목적이 아니라 수단이다. 목표는 **가독성, 테스트 용이성, 변경 용이성**이다.
- 항상 **테스트를 먼저**. 그다음에 작은 단계로 안전하게 치환하라.

---

## 부록 A. 리팩토링 작업 템플릿(체크리스트)

1) 현 코드의 외부 가시 행동을 테스트로 고정
2) 냄새를 분류하고 패턴을 1개만 먼저 적용
3) 인터페이스 추출 → 구현 분리 → 조립 외부화(DI/팩토리)
4) 회귀 테스트 통과 확인
5) 문서에 전이/체인/조립 방식을 업데이트
6) 필요 시 성능 계측 후 미세 최적화

---

## 부록 B. 간단 메트릭 가이드

- 파일당 순환복잡도 평균(CC)
- 평균 함수 길이(LOC)
- 클래스 응집도(관심사의 수)
- 결합도(직접 의존 타입 수)
- 테스트 커버리지(라인/브랜치)

리팩토링의 목표는 절대치가 아니라 **시간에 따른 개선 추세**다.
