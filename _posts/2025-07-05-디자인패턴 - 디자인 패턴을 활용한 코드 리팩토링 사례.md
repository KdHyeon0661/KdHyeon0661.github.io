---
layout: post
title: 디자인패턴 - 디자인 패턴을 활용한 코드 리팩토링 사례
date: 2025-07-05 23:20:23 +0900
category: 디자인패턴
---
# 디자인 패턴을 활용한 코드 리팩토링 사례

---

## 🎯 개요

소프트웨어가 커질수록 유지보수와 확장성은 필수 조건이 됩니다.  
하지만 처음부터 완벽한 구조로 짜긴 어렵기 때문에,  
**리팩토링(Refactoring)** 과정에서 **디자인 패턴**을 적극 활용하면  
코드의 품질을 눈에 띄게 높일 수 있습니다.

이 글에서는 실전에서 자주 마주치는 문제를 디자인 패턴으로 리팩토링하는 사례를 통해  
**Before → After** 방식으로 소개합니다.

---

## 1️⃣ 조건문/분기문 남발 → **Strategy 패턴**으로 리팩토링

### ✅ 리팩토링 전

```python
def calculate_price(product_type, amount):
    if product_type == "A":
        return amount * 100
    elif product_type == "B":
        return amount * 80
    elif product_type == "C":
        return amount * 120
    else:
        raise ValueError("Invalid product type")
```

- 새로운 타입 추가 시 if/elif 확장 필요
- OCP(Open/Closed Principle) 위배
- 테스트, 유지보수 어려움

---

### ✅ 리팩토링 후 (Strategy 패턴)

```python
class PricingStrategy:
    def calculate(self, amount): pass

class ProductA(PricingStrategy):
    def calculate(self, amount): return amount * 100

class ProductB(PricingStrategy):
    def calculate(self, amount): return amount * 80

class ProductC(PricingStrategy):
    def calculate(self, amount): return amount * 120

class PriceCalculator:
    def __init__(self, strategy: PricingStrategy):
        self.strategy = strategy

    def calculate(self, amount):
        return self.strategy.calculate(amount)

# 사용 예시
calc = PriceCalculator(ProductA())
print(calc.calculate(5))  # 500
```

### 💡 장점

- 새로운 상품이 생겨도 기존 코드를 **수정할 필요 없음**
- 각 전략이 독립적 → 테스트/관리 쉬움

---

## 2️⃣ 전역 인스턴스 남용 → **Singleton 패턴**으로 리팩토링

### ✅ 리팩토링 전

```python
config = {"env": "production"}

def get_config():
    return config
```

- 어디서든 변경 가능 → 추적 어려움
- 의존성 명시 없음 → 테스트 시 모킹 어려움

---

### ✅ 리팩토링 후 (Singleton 패턴)

```python
class Config:
    _instance = None

    def __new__(cls):
        if not cls._instance:
            cls._instance = super().__new__(cls)
            cls._instance.env = "production"
        return cls._instance

# 사용
cfg = Config()
print(cfg.env)
```

### 💡 장점

- 전역 접근은 가능하지만 **통제된 방식**으로 관리
- 상태를 가지는 전역 객체 관리에 적합

---

## 3️⃣ 복잡한 객체 생성 → **Builder 패턴**으로 리팩토링

### ✅ 리팩토링 전

```python
user = {
    "name": "Alice",
    "email": "alice@example.com",
    "address": "Seoul",
    "phone": None,
    "role": "admin"
}
```

- 선택적 인자가 많아질수록 관리 복잡
- 생성자 or dict로는 가독성 저하

---

### ✅ 리팩토링 후 (Builder 패턴)

```python
class UserBuilder:
    def __init__(self):
        self.user = {}

    def set_name(self, name): self.user["name"] = name; return self
    def set_email(self, email): self.user["email"] = email; return self
    def set_address(self, address): self.user["address"] = address; return self
    def set_phone(self, phone): self.user["phone"] = phone; return self
    def set_role(self, role): self.user["role"] = role; return self
    def build(self): return self.user

# 사용
user = (
    UserBuilder()
    .set_name("Alice")
    .set_email("alice@example.com")
    .set_role("admin")
    .build()
)
```

### 💡 장점

- 필수/선택 인자를 명확히 구분
- 메서드 체이닝으로 **가독성 향상**
- 불변 객체 생성에도 유리

---

## 4️⃣ 상태 전환을 if로 처리 → **State 패턴**으로 리팩토링

### ✅ 리팩토링 전

```python
def get_discount(user_type):
    if user_type == "guest":
        return 0
    elif user_type == "member":
        return 10
    elif user_type == "vip":
        return 20
```

- user_type이 늘어나면 조건문 증가
- 중복 로직 가능성

---

### ✅ 리팩토링 후 (State 패턴)

```python
class UserState:
    def get_discount(self): pass

class Guest(UserState):
    def get_discount(self): return 0

class Member(UserState):
    def get_discount(self): return 10

class VIP(UserState):
    def get_discount(self): return 20

# 사용
user = VIP()
print(user.get_discount())  # 20
```

### 💡 장점

- **상태 객체 간 전환도 구현 가능**
- 각 상태를 클래스로 분리 → 응집도 증가

---

## ✅ 마무리 요약

| 리팩토링 전 문제 | 사용된 패턴 | 기대 효과 |
|------------------|--------------|-------------|
| 조건문 남발 | Strategy | OCP 준수, 확장성 향상 |
| 전역 객체 | Singleton | 전역 관리 안전화 |
| 복잡한 생성자 | Builder | 가독성, 유연한 객체 생성 |
| 상태 분기문 | State | 명확한 상태 전이 모델링 |

디자인 패턴은 단순히 이론이 아니라  
**실제 코드에서 마주치는 문제를 해결하는 실용적인 도구**입니다.

---

## ✨ 보너스: 리팩토링 가이드

- 조건문이 늘어나면 → `Strategy` / `State`
- 동일한 객체를 반복 생성하면 → `Factory` / `Prototype`
- 생성자가 너무 복잡하면 → `Builder`
- 전역 객체가 많다면 → `Singleton` + `DI`
- 객체 간 통신이 복잡하면 → `Observer`, `Mediator`, `Command`