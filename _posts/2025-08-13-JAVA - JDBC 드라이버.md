---
layout: post
title: Java - JDBC 드라이버
date: 2025-08-13 23:20:23 +0900
category: Java
---
# JDBC 드라이버 개요 및 DB 연결/쿼리 실행/결과 처리

## 한눈에 핵심

| 주제 | 올바른 기본값/권장 |
|---|---|
| 드라이버 로드 | **JDBC 4+ 자동 로드**(대부분 `Class.forName(...)` 불필요) |
| 연결 관리 | `DriverManager`보다 **`DataSource` + 연결 풀(HikariCP)** |
| SQL 실행 | **`PreparedStatement`** (SQL 인젝션 방지, 캐시/배치 유리) |
| 트랜잭션 | 업무 단위로 **`setAutoCommit(false)` → `commit()/rollback()`** |
| 결과 처리 | `try-with-resources` + `ResultSet` 순회, **타입 맞춰 `getXxx()`** |
| 시간 타입 | JDBC 4.2: **`java.time.*`(LocalDate/Instant 등) 직접 바인딩/수신** |
| 대용량 조회 | **서버 커서 & fetch size**(DB/드라이버별 설정 상이) |
| 배치 | `addBatch()` + `executeBatch()` (**MySQL: `rewriteBatchedStatements=true`**) |
| 생성 키 | `RETURN_GENERATED_KEYS` 또는 DB별 `RETURNING` |
| 풀링 | **HikariCP** 기본, 커넥션 수는 부하/DB 한계/스레드 수 고려 |
| 에러 진단 | `SQLException`의 **SQLState**(표준 코드)와 벤더 코드 함께 로깅 |

---

## JDBC 드라이버 개요 (최신 관점)

### JDBC란?

- `java.sql` / `javax.sql` 패키지의 표준 인터페이스 집합
- **DBMS별 드라이버 JAR**가 이 인터페이스를 구현 → 동일 코드로 다양한 DB 사용

### 드라이버 타입(역사적 구분)

- **Type 4 (Thin, Pure Java)**: **표준**. 요즘은 사실상 전부 Type 4만 사용
- Type 1/2/3: 과거 유산(ODBC 브리지 등). **실무에서 사용 권장 X**

### 주요 드라이버(최신 기준)

| DB | Group:Artifact | 드라이버 클래스 | JDBC URL 예시 |
|---|---|---|---|
| MySQL 8+ | `mysql:mysql-connector-j` | `com.mysql.cj.jdbc.Driver` | `jdbc:mysql://host:3306/db?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC` |
| MariaDB | `org.mariadb.jdbc:mariadb-java-client` | `org.mariadb.jdbc.Driver` | `jdbc:mariadb://host:3306/db` |
| PostgreSQL | `org.postgresql:postgresql` | `org.postgresql.Driver` | `jdbc:postgresql://host:5432/db?stringtype=unspecified` |
| Oracle | `com.oracle.database.jdbc:ojdbc11` (또는 `ojdbc8`) | `oracle.jdbc.OracleDriver` | `jdbc:oracle:thin:@//host:1521/service` |
| SQL Server | `com.microsoft.sqlserver:mssql-jdbc` | `com.microsoft.sqlserver.jdbc.SQLServerDriver` | `jdbc:sqlserver://host:1433;databaseName=db;encrypt=true;trustServerCertificate=true` |
| SQLite | `org.xerial:sqlite-jdbc` | `org.sqlite.JDBC` | `jdbc:sqlite:/path/to/file.db` |

> **JDBC 4+ 자동 로딩**: 드라이버 JAR만 클래스패스/모듈패스에 있으면 보통 `Class.forName(...)` 없이 동작한다.

---

## 기본 흐름 — 연결 → 쿼리 → 결과 → 해제

### 최소 예제 (MySQL / Java 11+)

```java
import java.sql.*;

public class JdbcHello {
    public static void main(String[] args) {
        String url = "jdbc:mysql://localhost:3306/testdb?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC";
        String user = "app";
        String pass = "secret";

        // JDBC 4+ 드라이버 자동 로딩: 보통 Class.forName 불필요
        String sql = "SELECT id, name FROM users WHERE active = ? ORDER BY id LIMIT 10";

        try (Connection conn = DriverManager.getConnection(url, user, pass);
             PreparedStatement ps = conn.prepareStatement(sql)) {

            ps.setBoolean(1, true);

            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    long id = rs.getLong("id");
                    String name = rs.getString("name");
                    System.out.printf("%d - %s%n", id, name);
                }
            }

        } catch (SQLException e) {
            // 표준 SQLState + 벤더 코드 함께 로깅
            System.err.printf("SQLState=%s, ErrorCode=%d, Message=%s%n",
                    e.getSQLState(), e.getErrorCode(), e.getMessage());
        }
    }
}
```
- **`PreparedStatement`** 사용: SQL 인젝션 방지, 파라미터 캐싱 가능, 배치 유리
- `try-with-resources`: 모든 리소스(`Connection`, `Statement`, `ResultSet`)를 **항상** 닫는다

---

## `PreparedStatement` 제대로 쓰기

### 타입 안전 바인딩

```java
String sql = "INSERT INTO orders (user_id, total_amount, created_at) VALUES (?, ?, ?)";
try (PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
    ps.setLong(1, userId);
    ps.setBigDecimal(2, total); // 금액: BigDecimal 권장
    ps.setObject(3, java.time.Instant.now()); // JDBC 4.2: java.time 가능
    ps.executeUpdate();

    try (ResultSet keys = ps.getGeneratedKeys()) {
        if (keys.next()) {
            long orderId = keys.getLong(1);
            // 생성 키 사용
        }
    }
}
```
- **JDBC 4.2(=Java 8+)**부터 `setObject()/getObject()`로 `LocalDate`, `Instant` 등 **`java.time`** 타입 직접 사용 가능

### 삽입/갱신

```java
String sql = "INSERT INTO user_tag (user_id, tag) VALUES (?, ?)";
try (PreparedStatement ps = conn.prepareStatement(sql)) {
    conn.setAutoCommit(false); // 트랜잭션 시작

    for (var t : tags) {
        ps.setLong(1, userId);
        ps.setString(2, t);
        ps.addBatch();
    }
    int[] counts = ps.executeBatch();
    conn.commit();

    System.out.println("Inserted rows: " + java.util.Arrays.stream(counts).sum());
} catch (SQLException e) {
    conn.rollback();
    throw e;
}
```
**드라이버 팁**
- **MySQL**: URL에 `rewriteBatchedStatements=true` → 대량 배치 성능 향상
- **PostgreSQL**: 배치 성능 우수, `stringtype=unspecified`가 문자열 타입 추론 문제 완화에 도움될 때가 있다
- **Oracle**: `setExecuteBatch()`(구버전) 대신 표준 배치 API 사용 권장

---

## 트랜잭션 & 격리 수준

### 기본 패턴

```java
conn.setAutoCommit(false);
try {
    // 여러 DML...
    conn.commit();
} catch (SQLException e) {
    conn.rollback();
    throw e;
} finally {
    conn.setAutoCommit(true); // 풀로 반환 전에 원복(풀 구현에 따라 자동 처리되기도 함)
}
```

### 격리 수준

| 상수 | 의미 | 현상 완화 |
|---|---|---|
| `TRANSACTION_READ_UNCOMMITTED` | 커밋 전 데이터 읽기 허용 | Dirty Read X |
| `TRANSACTION_READ_COMMITTED` | **커밋된 데이터만** 읽음 | Dirty Read 방지 |
| `TRANSACTION_REPEATABLE_READ` | 같은 트랜잭션 내 같은 행 조회 결과 일관 | Non-repeatable Read 방지 |
| `TRANSACTION_SERIALIZABLE` | 완전 직렬화, 동시성 최소화 | Phantom Read 방지 |

> DB 기본값 상이(MySQL InnoDB: 보통 `REPEATABLE_READ`, PostgreSQL: `READ_COMMITTED` 등). **업무 요구에 맞춰 명시**하는 습관을 들이자.

### 세이브포인트

```java
conn.setAutoCommit(false);
Savepoint sp = null;
try {
    // Step 1
    sp = conn.setSavepoint();
    // Step 2
    // 오류 시 Step 2만 되돌리고 계속
    conn.rollback(sp);
    conn.commit();
} catch (SQLException e) {
    conn.rollback();
}
```

---

## 대용량 결과 처리 & 스트리밍

### 공통 팁

- **필요 컬럼만 SELECT** (불필요한 폭/행 수 금지)
- 페이징은 **OFFSET/LIMIT** 대신 **키셋 페이지네이션**(“`WHERE id > ? ORDER BY id`”) 고려

### 드라이버별 Fetch 전략

**PostgreSQL**
```java
conn.setAutoCommit(false); // 서버 커서 필요
try (PreparedStatement ps = conn.prepareStatement("SELECT id, name FROM big_table")) {
    ps.setFetchSize(1000);         // 서버 측 커서 개시
    try (ResultSet rs = ps.executeQuery()) {
        while (rs.next()) { /* ... */ }
    }
}
```

**MySQL (Connector/J)**
- URL에 `useCursorFetch=true` 추가
- `setFetchSize(n)` 또는 `setFetchSize(Integer.MIN_VALUE)`(드라이버 구버전 관습)
예:
```
jdbc:mysql://host/db?useCursorFetch=true&defaultFetchSize=1000
```

**Oracle**
- `setFetchSize(n)`로 라운드트립 감소
- LOB/컬럼 길면 네트워크/메모리 고려

---

## 메타데이터 활용 — 스키마/컬럼/키 정보

### DatabaseMetaData

```java
DatabaseMetaData dm = conn.getMetaData();
System.out.println(dm.getDatabaseProductName() + " " + dm.getDatabaseProductVersion());

// 테이블 나열
try (ResultSet rs = dm.getTables(null, null, "%", new String[]{"TABLE"})) {
    while (rs.next()) {
        System.out.println(rs.getString("TABLE_NAME"));
    }
}
```

### ResultSetMetaData

```java
try (ResultSet rs = ps.executeQuery()) {
    ResultSetMetaData md = rs.getMetaData();
    int cols = md.getColumnCount();
    for (int i = 1; i <= cols; i++) {
        System.out.printf("%s (%s)%n", md.getColumnName(i), md.getColumnTypeName(i));
    }
}
```

---

## `DataSource` & 연결 풀 (HikariCP 권장)

### 왜 `DriverManager` 대신 `DataSource`?

- 재사용 가능한 **풀링 커넥션** 제공
- JNDI/컨테이너 연동 용이, 장애/재연결 관리

### HikariCP 예시 (순수 자바)

```java
// build.gradle.kts
// implementation("com.zaxxer:HikariCP:5.1.0")  // 버전은 최신 안정판 사용

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import javax.sql.DataSource;

HikariConfig cfg = new HikariConfig();
cfg.setJdbcUrl("jdbc:postgresql://localhost:5432/appdb");
cfg.setUsername("app");
cfg.setPassword("secret");
cfg.setMaximumPoolSize(20);
cfg.setMinimumIdle(2);
cfg.setConnectionTimeout(3000);     // ms
cfg.setIdleTimeout(60000);          // ms
cfg.setMaxLifetime(1800000);        // 30m

DataSource ds = new HikariDataSource(cfg);

// 사용
try (Connection conn = ds.getConnection()) { /* ... */ }
```

> **풀 크기**는 “스레드 수 = 커넥션 수”가 정답이 아니다. DB 동시 처리 한계, 쿼리 시간, 외부 자원 대기 시간을 고려해 **측정 기반**으로 조정한다.

---

## `CallableStatement` — 프로시저/함수 호출

```java
String call = "{ call sp_adjust_inventory(?, ?, ?) }";
try (CallableStatement cs = conn.prepareCall(call)) {
    cs.setLong(1, skuId);
    cs.setInt(2, delta);
    cs.registerOutParameter(3, java.sql.Types.INTEGER);
    cs.execute();
    int newQty = cs.getInt(3);
}
```

> DB 벤더별 문법/권장 여부 상이. 비즈니스 로직을 DB로 밀어 넣는 전략은 운영/테스트/이식성 측면까지 고려.

---

## 예외/에러 진단 (SQLState)

`SQLException`은 **체크 예외**로, 다음 정보를 제공한다:
- `getSQLState()`: 표준 5문자 코드
  - `08`(연결 예외), `22`(데이터 예외), `23`(무결성 제약 위반), `28`(권한), `40`(트랜잭션 롤백), `42`(문법 오류)
- `getErrorCode()`: 벤더별 코드
- `getNextException()`: 체인된 예외

**로깅 예**
```java
catch (SQLException e) {
    for (Throwable t = e; t != null; t = ((SQLException)t).getNextException()) {
        if (t instanceof SQLException se) {
            log.error("SQLState={}, ErrorCode={}, Message={}", se.getSQLState(), se.getErrorCode(), se.getMessage(), se);
        }
    }
}
```

---

## 스키마/DDL/시드 — 예제 (PostgreSQL)

```sql
CREATE TABLE users (
  id BIGSERIAL PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

```java
String insert = "INSERT INTO users(email, name, created_at) VALUES (?, ?, ?) RETURNING id";
try (PreparedStatement ps = conn.prepareStatement(insert)) {
    ps.setString(1, "kim@example.com");
    ps.setString(2, "Kim");
    ps.setObject(3, java.time.OffsetDateTime.now()); // 4.2 OK
    try (ResultSet rs = ps.executeQuery()) {
        rs.next();
        long id = rs.getLong(1);
    }
}
```

---

## — 수동 RowMapper

```java
record User(long id, String email, String name, java.time.OffsetDateTime createdAt) {}

User mapRow(ResultSet rs) throws SQLException {
    return new User(
        rs.getLong("id"),
        rs.getString("email"),
        rs.getString("name"),
        rs.getObject("created_at", java.time.OffsetDateTime.class)
    );
}

List<User> findAll(Connection conn) throws SQLException {
    var sql = "SELECT id, email, name, created_at FROM users ORDER BY id";
    try (PreparedStatement ps = conn.prepareStatement(sql);
         ResultSet rs = ps.executeQuery()) {
        var out = new java.util.ArrayList<User>();
        while (rs.next()) out.add(mapRow(rs));
        return out;
    }
}
```

---

## 드라이버별 자주 겪는 이슈/옵션

**MySQL(MariaDB 유사)**
- 문자셋: `useUnicode=true&characterEncoding=UTF-8`
- 시간대: `serverTimezone=UTC`(서버 설정 상이 시)
- 배치 최적화: `rewriteBatchedStatements=true`
- 대용량 Fetch: `useCursorFetch=true&defaultFetchSize=1000`

**PostgreSQL**
- 서버 커서: `setAutoCommit(false) + setFetchSize(n)`
- 문자열 바인딩 미세 이슈: `stringtype=unspecified`(상황에 따라)

**Oracle**
- 서비스명 URL: `jdbc:oracle:thin:@//host:1521/service`
- FetchSize 적극 활용, LOB 스트리밍 확인

**SQL Server**
- TLS 기본 활성화: `encrypt=true;trustServerCertificate=true`(개발용)
- 대소문자/스키마 주의, `SET NOCOUNT ON` 영향 고려

---

## 성능 팁 & 안티패턴

- **항상 PreparedStatement**: 파싱/플랜 캐시 기여 + 보안
- 인덱스 설계: WHERE/JOIN/ORDER BY 컬럼에 적절한 인덱스
- **N+1 쿼리** 피하기: 필요한 데이터는 조인/IN 절로 묶거나 배치 조회
- 페이징: OFFSET 기반보다 **키셋 페이지네이션**(인덱스 친화적)
- 불필요한 `SELECT *` 금지(컬럼 폭/네트워크 낭비)
- 커넥션 풀 누수 방지: **항상 try-with-resources**
- `Connection`/`Statement` **스레드 안전 X**(공유 금지)

---

## 테스트 전략

- **단위 테스트**: DAO를 인터페이스로 추상화, **Fake/Mock**로 검증
- **통합 테스트**: **Testcontainers**로 DB 띄워 실제 JDBC 검사
- 스키마 마이그레이션: **Flyway/Liquibase**로 버전 관리

---

## 종합 예제 — 트랜잭션 + 배치 + 생성키 + 시간타입

```java
import javax.sql.DataSource;
import java.sql.*;
import java.time.Instant;
import java.util.List;

public class OrderRepo {
    private final DataSource ds;
    public OrderRepo(DataSource ds) { this.ds = ds; }

    public long createOrder(long userId, List<String> items) throws SQLException {
        String insertOrder = "INSERT INTO orders(user_id, created_at) VALUES(?, ?) RETURNING id";
        String insertItem  = "INSERT INTO order_item(order_id, name) VALUES(?, ?)";

        try (Connection conn = ds.getConnection()) {
            conn.setAutoCommit(false);
            try {
                long orderId;
                try (PreparedStatement ps = conn.prepareStatement(insertOrder)) {
                    ps.setLong(1, userId);
                    ps.setObject(2, Instant.now());
                    try (ResultSet rs = ps.executeQuery()) {
                        rs.next();
                        orderId = rs.getLong(1);
                    }
                }

                try (PreparedStatement ps = conn.prepareStatement(insertItem)) {
                    for (String it : items) {
                        ps.setLong(1, orderId);
                        ps.setString(2, it);
                        ps.addBatch();
                    }
                    ps.executeBatch();
                }

                conn.commit();
                return orderId;
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        }
    }
}
```

---

## 체크리스트

- [ ] 드라이버 JAR 최신/정식 릴리스 사용
- [ ] `DataSource` + 풀(HikariCP)로 연결 관리
- [ ] **`PreparedStatement` 기본** / SQL 파라미터 바인딩
- [ ] 트랜잭션 경계 명확(`setAutoCommit(false)` → `commit/rollback`)
- [ ] 시간/금액은 **`java.time` / `BigDecimal`**
- [ ] 대용량 조회: 서버 커서/FetchSize 설정
- [ ] 배치 최적화(MySQL: `rewriteBatchedStatements=true`)
- [ ] 예외 로깅: **SQLState + ErrorCode**
- [ ] try-with-resources로 누수 방지
- [ ] 테스트: Testcontainers/Flyway로 재현 가능한 환경

---

## 요약

JDBC는 여전히 **가장 표준적이고 강력한 DB 접근 레이어**다. 최신 자바(11+)에서는 **JDBC 4.2의 `java.time` 지원**, **자동 드라이버 로딩**, **풀링·배치·서버 커서** 등으로 **안전성과 성능을 동시에 확보**할 수 있다.
**핵심은**: `DataSource` 풀 + `PreparedStatement` + 명확한 트랜잭션 경계 + 올바른 타입 매핑 + 측정 기반 튜닝.
