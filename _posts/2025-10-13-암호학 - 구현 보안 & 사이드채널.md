---
layout: post
title: 암호학 - 구현 보안 & 사이드채널
date: 2025-10-13 21:30:23 +0900
category: 암호학
---
# 13. 구현 보안 & 사이드채널

> 이 장은 “**어떻게 구현이 새나가는가**”에 초점을 맞춥니다.
> **타이밍·캐시·파워·EM** 사이드채널 개요 → **완화(상수 시간, 마스킹·히딩)** → **패딩 오라클/Lucky13/비트플립** 사례 → **안전한 직렬화·메모리 소거·난수/Nonce 체크리스트**까지 한 번에 정리합니다.
> 실무 키워드: **상수 시간(constant-time), 표준 라이브러리 우선, 오류 통일화, Nonce 재사용 금지, 비밀 수명 관리**.

---

## ✅ 13.1 사이드채널 공격 개요

### 13.1.1 분류
- **타이밍(Time)**: 입력/키에 따라 연산 시간이 달라짐 → 원격에서도 통계로 유추 가능.
- **캐시(Cache)**: 데이터 의존적 메모리 접근이 L1/L2 캐시에 흔적(Prime+Probe, Flush+Reload).
- **파워(Power)**: 전력 소비 패턴(전류)이 비밀과 상관(단일 동작을 보는 SPA, 통계적 DPA).
- **EM(전자기)**: 누설되는 전자파로 내부 연산 관찰(프로브·근접 안테나).

### 13.1.2 어디서 생기나?
- **S-box/테이블 기반 AES**(캐시 인덱스가 데이터 의존).
- **RSA/ECDSA 스칼라 곱**(비트 1/0에 따라 분기/곱셈 차이).
- **비교/패딩 검증**(첫 바이트에서 틀리면 즉시 반환).
- **오류 메시지·에러 경로**(패딩/태그 실패 구분).
- **동시멀티테넌트**(클라우드의 공유 캐시/코어).

---

## ✅ 13.2 완화 전략(전반)

1) **상수 시간 연산(Constant-time)**
   - 비밀에 **의존하는 분기/메모리 인덱스 금지**.
   - 비교는 **상수 시간 비교 함수** 사용.
2) **히딩(Hiding)**
   - 잡음 추가, 실행 순서 셔플, 균일 클록/전력 필터링(주로 하드웨어/펌웨어).
3) **마스킹(Masking)**
   - 비밀을 난수 공유로 분해(예: 1차/2차 마스킹) → 각 단계에서 한 공유만 보이면 정보 없음.
4) **하드웨어 가속**
   - **AES-NI/ARM AES/PMULL**, **Ed25519/Curve25519** 등 **상수 시간 구현** 채택.
5) **오류·타이밍 균일화**
   - 실패 사유/시간을 **동일**하게 처리(패딩/태그/서명 검증).
6) **격리(Isolation)**
   - 민감 연산을 **격리된 프로세스/코어/TEE**로, 혹은 **코호스트 제한**(멀티테넌시).

---

## ✅ 13.3 타이밍 & 캐시: 구체 패턴과 방어

### 13.3.1 상수 시간 비교
**안티-패턴**
```python
# 틀린 위치에서 바로 리턴 → 타이밍이 길이/접두사에 의존
def insecure_eq(a: bytes, b: bytes) -> bool:
    if len(a) != len(b): return False
    for i in range(len(a)):
        if a[i] != b[i]:
            return False
    return True
```

**권장**
```python
import hmac
def secure_eq(a: bytes, b: bytes) -> bool:
    return hmac.compare_digest(a, b)  # 상수 시간
```

**C(개념)**
```c
int ct_memcmp(const void *a, const void *b, size_t n){
    const unsigned char *x=a,*y=b; unsigned char r=0;
    for(size_t i=0;i<n;i++) r |= x[i]^y[i];
    return r; // 0이면 같음
}
```

### 13.3.2 데이터 의존적 분기/인덱스 제거
**안티-패턴(테이블 인덱스)**
```c
uint8_t sbox[256] = {...};
uint8_t aes_sbox(uint8_t x){ return sbox[x]; }  // x가 캐시 패턴을 만든다
```
**권장**
- **AES-NI/ARM AES** 사용(테이블 접근 제거).
- 또는 **비트슬라이스/벡터화**(복잡·고난도 → 가능하면 쓰지 말고 하드웨어 사용).

### 13.3.3 ECDSA/ECDH 스칼라 곱
- **안티**: double-and-add에서 **비트=1일 때만 add** → 분기/시간 누설.
- **권장**: **Montgomery ladder**(레더), **윈도우 고정-시간** 스케일러, **Ed25519/Curve25519** 표준 구현 사용.

### 13.3.4 캐시 공격 모델
- **Flush+Reload**: 공격자가 동일 코드 페이지를 공유(.so) → 특정 라인 reload 시간으로 사용 여부 관측.
- **Prime+Probe**: 세트 어소시에이티브 캐시를 프라임→피해자 실행→프로브로 사용 세트 확인.

**완화**
- 데이터 의존 접근 금지, **페이지/라인 격리**(難), **캐시 잠금/프리페치**(제한적), **프로세스 분리**.

---

## ✅ 13.4 파워/EM: 임베디드·카드·HSM 관점

### 13.4.1 DPA/CPA 직관
- 전력 트레이스 다수를 수집해 **가설(중간값)** 과 **상관** → 키 비트 추정.
- AES의 SubBytes 직후 바이트 해밍중/해밍거리 모델 등.

### 13.4.2 방어
- **마스킹**: 입력/키/중간값을 무작위 공유로 분해 → 한 공유만 보면 무의미.
- **히딩**: 연산 순서 랜덤 셔플, 랜덤 클록/전력 노이즈.
- **회로 수준**: 듀얼레일 논리, 균형 로딩.
- **프로토콜**: 사용 횟수/속도 제한, 실패 횟수 제한, 디버그 인터페이스 차단.

> 마스킹은 **이론/구현 모두 어려움**. 직접 하지 말고 **검증 HW/라이브러리** 선택.

---

## ✅ 13.5 패딩 오라클 & Lucky13

### 13.5.1 패딩 오라클(클래식 CBC)
- **상황**: CBC 모드 + 패딩 오류와 MAC 오류를 **구분**해서 응답(혹은 시간차).
- **효과**: 공격자가 암호문 블록을 조작하며 **평문 바이트를 복구**(오라클 쿼리 수만 충분하면 성공).
- **교훈**: **암호화만(CBC)으로는 무결성 없음**. **복호 전** 태그/MAC **검증**(EtM) 또는 **AEAD 사용**.

### 13.5.2 Lucky13 (TLS-CBC) 한 줄 요약
- TLS 1.2 이하의 CBC+MAC 패딩 처리에서 **수 ns~μs 차이**로 패딩/MAC 처리 경로가 달라짐 → 통계적 타이밍 공격으로 **평문 누설**.
- **교훈**: **오류/시간 균일화 어려움**. 오늘날은 **TLS 1.3 + AEAD**로 종결.

### 13.5.3 상수 시간 패딩 제거(교육용 개념)
```c
// PKCS#7 제거 스케치: 모든 바이트를 끝까지 검사해 타이밍 균일화
int pkcs7_unpad(uint8_t *buf, size_t *n, size_t block){
    if (*n==0 || (*n%block)) return -1;
    uint8_t pad = buf[*n-1];
    size_t good = (pad>0) & (pad<=block);
    size_t i; uint8_t diff=0;
    for(i=0;i<block;i++){
        uint8_t b = buf[*n-1-i];
        diff |= (uint8_t)((i<pad)? (b ^ pad) : 0);
    }
    good &= (diff==0);
    if(!good) return -1;
    *n -= pad;
    return 0;
}
```
> 실제 CBC를 쓰지 말고 **AEAD**를 쓰세요.

---

## ✅ 13.6 “비트플립으로 AEAD 우회?” — 실패 사례와 올바른 사용

### 13.6.1 AEAD의 약속
- **무결성 태그**가 통과하지 않으면 **복호 실패**.
- **따라서** 단순 비트플립으로 **평문 조작 불가**.

### 13.6.2 그러나 이렇게 망가진다(안티-패턴)
1) **Decrypt-then-parse**가 아니라 **Parse-then-verify**
   ```python
   # ❌ 잘못된 순서: 암호문 일부를 먼저 파싱/사용 → 검증 실패 전에 부작용
   pt = aead.decrypt(nonce, ct, aad)         # ← 정상
   data = json.loads(pt)                     # ← 태그 검증 후 파싱해야 함
   ```
   *실패 유형*: 일부 시스템은 **스트림 처리 중간에** 데이터 사용 → 예외 전 **사이드 이펙트** 발생.

2) **에러 메시지 차별**
   - “태그 오류” vs “포맷 오류” vs “권한 오류”를 구분하면 **오라클**이 된다.
   - **대응**: 모든 실패를 **동일 오류 코드/지연**으로.

3) **Nonce 재사용**
   - GCM/ChaCha20-Poly1305에서 **Nonce 충돌**은 **기밀성+무결성 동시 붕괴** 가능(키스트림/해시 키 재사용).

### 13.6.3 올바른 패턴
```python
# 1. 태그 검증(=복호) 먼저, 2) 성공하면 파싱/검증/부작용
try:
    pt = aead.decrypt(nonce, ct, aad)  # 실패 → 동일 에러 처리
except Exception:
    return error()                      # 동일 코드/지연
data = parse_and_validate(pt)           # 길이/스키마/범위 검증
apply_side_effects(data)
```

---

## ✅ 13.7 안전한 직렬화 & 입력 정규화

### 13.7.1 원칙
- **자체 바이너리 포맷 금지**. **JSON/CBOR/Protobuf** 등 **잘 알려진 포맷** 사용.
- **스키마 검증**(JSON Schema/Protobuf 정의), **허용 리스트 기반** 파싱.
- **정규화**: 유니코드 정규화(NFC/NFKC), 공백/컨트롤/구분자 제거 → **서명/검증 전에** 적용.
- **정확한 길이 바인딩**: 서명/태그는 **바이트 직렬화 결과** 위에서만.

### 13.7.2 캐노니컬 직렬화
- 같은 의미 → **항상 같은 바이트열**.
- 서명/해시/태그 생성 시 **키-값 순서, 공백** 등 비결정 요소 제거.

### 13.7.3 JSON 예(파이썬)
```python
import json
def canonical_json(obj)->bytes:
    return json.dumps(obj, separators=(',', ':'), sort_keys=True).encode('utf-8')
```
> 이 바이트열을 **그대로 AEAD AAD** 또는 **서명 입력**으로 사용.

---

## ✅ 13.8 메모리 소거(Zeroization) & 비밀 수명

### 13.8.1 왜 어려운가
- **최적화**가 쓸모없다고 판단해 소거 코드를 제거할 수 있음.
- GC 언어(Python/Java/Go)는 **정확한 소거 보장 어려움**.

### 13.8.2 전략
- **언어별 지원 사용하는 게 최선**
  - C: `explicit_bzero`, `memset_s`, 라이브러리 `OPENSSL_cleanse` 등.
  - Rust: `zeroize` 크레이트(특성상 drop 시 소거).
  - Go: 1.20+ 일부 패키지에 **보안 소거** 지원(직접 바이트슬라이스 덮기, 키는 짧게 보관).
  - libsodium: `sodium_memzero`, `sodium_mlock`.
- **비밀 범위 최소화**: 가능한 **가장 안쪽 스코프/짧은 시간** 보관.
- **페이지 잠금(mlock)**: 스왑 방지.
- **덤프/크래시 핸들러**: 비밀 마스킹.

**C 예**
```c
#include <string.h>
void wipe(void *p, size_t n){
#if defined(__STDC_LIB_EXT1__)
    memset_s(p, n, 0, n);
#else
    volatile unsigned char *vp = p;
    while(n--) *vp++ = 0; // 최적화 차단
#endif
}
```

---

## ✅ 13.9 난수/Nonce 재사용 금지 — 최종 체크리스트

### 13.9.1 CSPRNG 선택
- **운영체제 제공**: `/dev/urandom`(Linux), `getrandom()`, `CryptGenRandom`/CNG(Windows), `getentropy`/`SecRandomCopyBytes`(Apple).
- **라이브러리**: OpenSSL `RAND_bytes`, libsodium `randombytes_buf`.
- **하지 말 것**: `rand()`, LCG, 시간씨드 PRNG.

### 13.9.2 Nonce/IV 규칙(모드별)
- **GCM/GMAC/ChaCha20-Poly1305/CTR**: **키마다 Nonce 고유**.
  - 권장: **12바이트 Nonce**(GCM/ChaCha20), **랜덤 96b + 카운터** 또는 **프로세스 고유 prefix + 카운터**.
  - **재시작/다중 인스턴스**: prefix로 인스턴스 구분, 카운터는 **원자적 증가**/영속화.
- **CBC**: **랜덤 IV** 필수(예측 금지).
- **XTS**: 섹터 번호 기반 **트윅**(무결성 제공 안 함).

### 13.9.3 생성/사용 패턴(파이썬)
```python
import os
nonce = os.urandom(12)  # 96-bit
# 키 스코프 내 중복 체크는 라이브러리에 위임하거나, prefix+카운터를 자체 관리
```

### 13.9.4 금지 사례
- 타임스탬프/카운터만으로 전역 고유성 보장 없이 사용.
- 재부팅/컨테이너 재생성 시 카운터 초기화.
- Nonce/키/시드를 **로그**에 남김.

---

## ✅ 13.10 오류 처리·반응 균일화

- **모든 실패는 동일 메시지/코드**: `400 Bad Request`(generic) 등.
- **지연 균일화**: 태그 실패/패딩 실패/포맷 실패가 **동일 시간대**로 반환.
- **락아웃/리트라이**: 백오프·지수 증가, 타이밍 측정 어려움 유도.
- **측정 방지**: 서버 슬로틀링, 레이트 리미트, 프록시 뒤 은닉.

---

## ✅ 13.11 테스트·검증(현실 도구)

- **상수 시간 테스트**:
  - **dudect**(통계적 타이밍 편향 검출), **ctgrind**(valgrind 플러그인)류.
- **퍼지/프로퍼티 테스트**: 입력 경계/교란(길이 0, 최대, 비정상)에서 동일 오류/지연 확인.
- **벤치 분리**: release 빌드/성능 카운터로 분기 제거 확인.
- **코드 리뷰 체크리스트**: 비밀 의존 분기/인덱스 여부, 에러 메시지, Nonce 생성부, 태그 검증 순서.

---

## ✅ 13.12 클라우드 & 컨테이너 고려

- **코호스트 위험**: 멀티테넌트에서 캐시/브랜치 히스토리 공유 → 민감 연산은 **전용 노드/전용 코어** 또는 **프로세스 격리**.
- **시간 소스**: 고해상도 타이머 접근 제한(브라우저/런타임), 샘플 윈도 축소.
- **관측 차단**: 성능 메트릭/트레이싱에 **비밀/Nonce** 노출 금지.

---

## ✅ 13.13 실수 모음(안티-패턴)

1) **AES 테이블 구현**을 클라우드에서 그대로 사용(AES-NI 미사용).
2) **`==`로 태그 비교**, 실패 지점에서 즉시 반환.
3) **패딩/태그 오류를 구분**하여 응답.
4) **AEAD 복호 전에 파싱/부작용** 발생.
5) **Nonce 재사용**(컨테이너 재시작).
6) **비밀 평문 로그/코어덤프 유출**.
7) **직렬화 비결정성**으로 서명/검증 실패(또는 의미 혼동).
8) **RSA/ECDSA 스칼라 분기**(상수 시간 구현 미사용).
9) **파워/EM 고려 없이** 임베디드에서 자체 구현.

---

## ✅ 13.14 운영 체크리스트

- **상수 시간**
  - [ ] 비밀 의존 **분기/인덱스 없음**, 상수 시간 비교 사용
  - [ ] AES-NI/ARM AES/Ed25519 등 검증 구현 사용

- **오류·타이밍 균일화**
  - [ ] 패딩/태그/포맷 실패 **동일 에러/지연**
  - [ ] 복호(검증) **→** 파싱(부작용) 순서 준수

- **Nonce/난수**
  - [ ] OS CSPRNG 사용, Nonce 고유 보장
  - [ ] 재시작/수평확장 시 prefix+카운터 설계

- **메모리/로그**
  - [ ] 비밀 **짧게 보관**, 드롭 시 **소거**
  - [ ] 로그에 비밀/Nonce/키 **금지**

- **직렬화**
  - [ ] **캐노니컬** 직렬화, 스키마 검증, 정규화
  - [ ] AAD/서명 입력은 **바이트 직렬화 결과**에 바인딩

- **테스트**
  - [ ] dudect/ctgrind/퍼지로 편향/오류 확인
  - [ ] 코드리뷰 체크리스트 운용

---

## ✅ 13.15 미니 실습 묶음

### A) 태그 오류 균일 처리(파이썬)
```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os, time

def process(aes: AESGCM, nonce, ct, aad):
    t0 = time.perf_counter_ns()
    ok = False; pt = b""
    try:
        pt = aes.decrypt(nonce, ct, aad)  # 검증+복호
        ok = True
    except Exception:
        # 실패: 동일한 지연을 맞추기 위해 더미 작업
        _ = sum(i*i for i in range(2000))
    finally:
        # 일정 시간 이상 지연을 유지하는 보정(예: 최소 200μs)
        while time.perf_counter_ns() - t0 < 200_000:
            pass
    return (ok, pt if ok else None)
```

### B) 캐노니컬 JSON + AAD
```python
import json, os
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

def canonical(obj)->bytes:
    return json.dumps(obj, separators=(',', ':'), sort_keys=True).encode()

key = ChaCha20Poly1305.generate_key(); aead = ChaCha20Poly1305(key)
nonce = os.urandom(12)

meta = {"v":1,"typ":"invoice","id":"abc"}
aad  = canonical(meta)
pt   = canonical({"amount":1000,"to":"bob"})
ct   = aead.encrypt(nonce, pt, aad)

# 수신: 동일 캐노니컬 규칙으로 AAD 구성 후 복호
pt2  = aead.decrypt(nonce, ct, aad)
```

### C) 상수 시간 선택(브랜치 제거; 파이썬 개념)
```python
def ct_select(mask: int, a: int, b: int) -> int:
    # mask ∈ {0,1}; 모든 연산을 정수 비트연산으로
    m = -int(bool(mask)) & ((1<<64)-1)  # 0xFFFF.. 또는 0
    return (a & m) | (b & ~m)
```

---

## ✅ 13.16 요약 카드

- **타이밍/캐시/파워/EM**: 구현이 곧 보안이다.
- **상수 시간·하드웨어 가속** → 데이터 의존 분기/인덱스 금지.
- **AEAD**: **검증 먼저**·에러 통일·Nonce 고유성.
- **패딩 오라클/Lucky13**: 오늘은 **AEAD**로 끝낸다.
- **직렬화**: 캐노니컬·스키마·정규화 → 바이트열에 서명/AAD 바인딩.
- **메모리 소거/수명 단축**: 언어별 안전 API 활용.
- **테스트**: dudect/ctgrind/퍼지/코드리뷰로 방어 검증.

---

## ✅ 13.17 연습문제

1) **Prime+Probe**와 **Flush+Reload**의 차이를 캐시 세트/라인 관점에서 설명하고, 테이블 기반 AES가 왜 취약한지 기술하라.
2) RSA/ECDSA 스칼라 곱에서 **Montgomery ladder**가 상수 시간 성질을 갖는 이유를 써라.
3) 패딩 오라클과 **Lucky13**의 공통점/차이점(오류 구분 vs 타이밍 미세차)과 오늘의 권장 대응을 정리하라.
4) **AEAD 복호 → 파싱** 순서가 어겨졌을 때 발생 가능한 부작용 시나리오를 최소 두 가지 제시하라.
5) **마스킹 vs 히딩**의 차이와, 임베디드에서 실제 적용 시 운영상의 어려움을 논하라.
6) 캐노니컬 직렬화가 필요한 이유를 “서명/검증”과 “리플레이/혼동 방지” 관점에서 써라.
7) 서버리스 환경에서 **Nonce 충돌**이 발생하는 전형적 경로를 서술하고, prefix+카운터 설계를 제시하라.
