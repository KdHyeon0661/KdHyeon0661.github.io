---
layout: post
title: 소켓프로그래밍 - UDP
date: 2025-09-14 22:25:23 +0900
category: 소켓프로그래밍
---
## 8. UDP — 데이터그램의 세계

> 목표: **UDP의 근본 특성(메시지 경계 보존, 손실/중복/순서 바뀜)**을 정확히 이해하고,  
> `sendto/recvfrom`와 **connected UDP**의 차이를 파고들며,  
> **브로드캐스트/멀티캐스트** 사용 시 주의점을 정리한다.  
> 끝으로 **UDP 에코 + 간단 ARQ(재전송)** 실습으로 “최소한의 신뢰성”을 직접 구현해 본다.  
> 표준: **POSIX + C++23** (리눅스 기준 설명, BSD/macOS 차이는 각 섹션에 주석)

---

### 8.1 UDP는 **데이터그램 + 비신뢰성**이다

#### 8.1.1 메시지 경계 보존
- UDP는 **데이터그램(메시지) 단위**를 **그대로** 보낸다/받는다.  
  - 송신의 한 `sendto()` 호출이 만든 **하나의 UDP 데이터그램**은 수신의 **한 번의 `recvfrom()`** 로 **최대 1개**만 읽을 수 있다.  
  - **부분 읽기**라는 개념이 없다. 버퍼가 작으면 **남는 바이트는 소실**(truncate)된다.  
- 즉, TCP와 달리 **프레이밍**을 따로 만들 필요는 없다. **이미 경계가 있다.**

#### 8.1.2 손실/중복/순서 바뀜
- UDP는 **재전송·혼잡제어·흐름제어가 없다.**  
  - **손실**: 네트워크/큐에서 드롭되면 끝.  
  - **중복**: 라우팅/재시도 경로에서 **같은 데이터그램이 두 번** 도착할 수 있다.  
  - **순서 바뀜**: A→B→C 순으로 보냈지만 **B→A→C** 순으로 도착 가능.
- 원하는 신뢰성/순서를 갖고 싶다면 **응용 계층에서** 시퀀스/ACK/재전송 타이머를 설계해야 한다.

#### 8.1.3 MTU/단편화
- UDP 데이터그램은 **IP 계층**의 MTU에 걸리면 **단편화(fragmentation)** 될 수 있다.  
  - 단편 중 하나라도 손실되면 **전체 데이터그램이 유실**.  
  - 실무에서는 **MTU보다 작은 메시지**를 보내거나, **Path MTU Discovery(PMTUD)**/**GSO/GRO** 등을 고려한다.
- 일반 이더넷 MTU 1500 기준:
  - IPv4 헤더(20) + UDP 헤더(8) → **MSS≈1472B**  
  - IPv6 헤더(40) + UDP 헤더(8) → **MSS≈1452B**  
  대략 이 크기를 넘기지 않는 것이 안전(옵션/터널링/헤더 증가 여지를 감안해 더 줄이는 경우도 많다).

---

### 8.2 기본 API: `sendto/recvfrom` vs **connected UDP**

#### 8.2.1 비연결 UDP: `sendto/recvfrom`
- **송신**: 목적지 주소를 매 호출에 넘긴다.
- **수신**: `recvfrom()`이 **보낸 사람 주소**를 함께 알려준다.
- **장점**: 하나의 소켓으로 **여러 피어**와 통신하기 좋다(서버/프록시).  
- **단점**: 매 송신마다 **주소 구조체**를 준비(약간의 비용).

```cpp
// udp_basic.cpp (요지)
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <print>
#include <vector>
#include <cstring>

int udp_fd_any_bind(const char* port) {
    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_DGRAM; hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(nullptr, port, &hints, &res)!=0) return -1;
    int s=-1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        if (::bind(s, ai->ai_addr, ai->ai_addrlen)==0) break;
        ::close(s); s=-1;
    }
    freeaddrinfo(res);
    return s;
}

int main() {
    int s = udp_fd_any_bind("9001");
    if (s<0) { perror("bind"); return 1; }
    std::vector<char> buf(2000);
    sockaddr_storage peer{}; socklen_t plen=sizeof(peer);
    ssize_t n = ::recvfrom(s, buf.data(), buf.size(), 0, (sockaddr*)&peer, &plen);
    if (n>0) {
        ::sendto(s, buf.data(), n, 0, (sockaddr*)&peer, plen); // 에코
    }
    ::close(s);
}
```

#### 8.2.2 **connected UDP**: `connect()`가 있는 UDP
- UDP 소켓에도 `connect()`를 호출할 수 있다. 의미:
  1) **기본 목적지**를 **고정** → 이후 `send()`/`recv()` 사용 가능 (`sendto/recvfrom` 불필요)  
  2) **ICMP 오류**(Port Unreachable 등)를 소켓 **에러로 전달**(일부 OS).  
  3) **다른 발신자**의 패킷은 **수신 거부**. 필터링 효과.
- **장점**: 단일 피어와의 왕복형 통신에서 **간결 + 오류 전달**.  
- **단점**: 다중 피어(서버)에는 **부적합**. 피어 변경 시 재연결 필요.

```cpp
// connected_udp.cpp (요지)
int s = ::socket(AF_INET, SOCK_DGRAM, 0);
sockaddr_in dst{}; dst.sin_family=AF_INET; dst.sin_port=htons(9001);
inet_pton(AF_INET, "127.0.0.1", &dst.sin_addr);
::connect(s, (sockaddr*)&dst, sizeof(dst)); // 이제 send/recv 가능
::send(s, "ping", 4, 0);
char buf[1500]; ssize_t n = ::recv(s, buf, sizeof(buf), 0); // 여기서 다른 발신자의 패킷은 거절
```

> **요약**  
> - **서버/프록시**: 비연결(`sendto/recvfrom`)이 기본.  
> - **단일 피어 클라이언트**: **connected UDP**가 깔끔하고 **ICMP 오류**를 받기 쉬움.

---

### 8.3 브로드캐스트/멀티캐스트

#### 8.3.1 브로드캐스트 (IPv4)
- **브로드캐스트 주소**로 보내면 같은 서브넷의 모든 호스트가 수신.  
  - 단일 네트워크에만 유효, 라우터가 넘겨주지 않는 것이 보통.  
- **송신 시** 소켓에 `SO_BROADCAST` 필요.
- **주의**: 많은 호스트가 동시에 응답하면 **반향 스톰**(broadcast storm) 가능 → **응답 제한** 설계(랜덤 지연, rate limit 등).

```cpp
int s = ::socket(AF_INET, SOCK_DGRAM, 0);
int yes=1; setsockopt(s, SOL_SOCKET, SO_BROADCAST, &yes, sizeof(yes));

sockaddr_in bc{};
bc.sin_family=AF_INET; bc.sin_port=htons(9002);
inet_pton(AF_INET, "255.255.255.255", &bc.sin_addr); // 또는 서브넷 브로드캐스트
::sendto(s, "DISCOVER", 8, 0, (sockaddr*)&bc, sizeof(bc));
```

#### 8.3.2 멀티캐스트 (IPv4/IPv6)
- **그룹 주소**(IPv4: 224.0.0.0/4, IPv6: ff00::/8)로 전송, **그룹 가입(host join)** 한 호스트만 수신.  
- 수신자는 `IP_ADD_MEMBERSHIP`(IPv6: `IPV6_ADD_MEMBERSHIP`/`IPV6_JOIN_GROUP`)로 **가입**해야 한다.  
- **TTL/hops**, **루프백**, **송신 인터페이스** 등을 조정해야 실무에서 원하는 경로/범위로 안정 동작한다.

**IPv4 멀티캐스트 수신 예**
```cpp
int s = ::socket(AF_INET, SOCK_DGRAM, 0);
int reuse=1; setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)); // 여러 프로세스 수신 허용(플랫폼별 차이)
sockaddr_in addr{}; addr.sin_family=AF_INET; addr.sin_port=htons(9003);
addr.sin_addr.s_addr = htonl(INADDR_ANY);
::bind(s, (sockaddr*)&addr, sizeof(addr));

// 그룹 가입
ip_mreq mreq{};
inet_pton(AF_INET, "239.1.2.3", &mreq.imr_multiaddr);
mreq.imr_interface.s_addr = htonl(INADDR_ANY); // 특정 NIC로 고정하려면 해당 IP
setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
```

**IPv4 멀티캐스트 송신 예**
```cpp
int s = ::socket(AF_INET, SOCK_DGRAM, 0);
unsigned char ttl = 1; // 같은 링크까지만
setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl));
unsigned char loop = 0; // 송신자가 자기 것도 받을지
setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, &loop, sizeof(loop));
// 송신 인터페이스 선택(해당 NIC의 IPv4 주소)
in_addr ifaddr{}; inet_pton(AF_INET, "10.0.0.5", &ifaddr);
setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, &ifaddr, sizeof(ifaddr));

sockaddr_in g{}; g.sin_family=AF_INET; g.sin_port=htons(9003);
inet_pton(AF_INET, "239.1.2.3", &g.sin_addr);
::sendto(s, "hello group", 11, 0, (sockaddr*)&g, sizeof(g));
```

**IPv6 멀티캐스트 수신/송신 차이**
- 옵션 이름/구조체가 다르다: `ipv6_mreq`, `IPV6_JOIN_GROUP`, `IPV6_MULTICAST_HOPS`, `IPV6_MULTICAST_IF` 등.  
- **스코프(scope)** 와 **인터페이스 인덱스** 처리 주의: 링크-로컬 멀티캐스트는 반드시 **ifindex** 지정.

---

### 8.4 UDP 에코 — 가장 작은 서버/클라이언트

#### 8.4.1 서버 (비연결 UDP)
```cpp
// udp_echo_server.cpp
// 빌드: g++ -std=c++23 -O2 -Wall udp_echo_server.cpp -o udp_echo_server
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <print>
#include <vector>
#include <array>
#include <cstring>

int main(int argc, char** argv) {
    const char* port = (argc>1? argv[1]: "9001");

    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_DGRAM; hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(nullptr, port, &hints, &res)!=0) { perror("gai"); return 1; }

    int s=-1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        if (::bind(s, ai->ai_addr, ai->ai_addrlen)==0) break;
        ::close(s); s=-1;
    }
    freeaddrinfo(res);
    if (s<0) { perror("bind"); return 1; }
    std::print("[udp-echo] listen on :{}\n", port);

    std::vector<char> buf(2048);
    for(;;){
        sockaddr_storage peer{}; socklen_t plen=sizeof(peer);
        ssize_t n = ::recvfrom(s, buf.data(), buf.size(), 0, (sockaddr*)&peer, &plen);
        if (n<0) { if (errno==EINTR) continue; perror("recvfrom"); continue; }
        // 그대로 반사
        ::sendto(s, buf.data(), n, 0, (sockaddr*)&peer, plen);
    }
}
```

#### 8.4.2 클라이언트 (connected UDP)
```cpp
// udp_echo_client.cpp
// 빌드: g++ -std=c++23 -O2 -Wall udp_echo_client.cpp -o udp_echo_client
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <print>
#include <string>
#include <vector>
#include <cstring>

int main(int argc, char** argv) {
    if (argc < 4) {
        std::print(stderr, "usage: {} <host> <port> <msg>\n", argv[0]);
        return 1;
    }
    const char* host=argv[1]; const char* port=argv[2]; std::string msg=argv[3];

    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_DGRAM; hints.ai_flags=AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(host, port, &hints, &res)!=0) { perror("gai"); return 1; }

    int s=-1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        if (::connect(s, ai->ai_addr, ai->ai_addrlen)==0) break;
        ::close(s); s=-1;
    }
    freeaddrinfo(res);
    if (s<0) { perror("connect"); return 1; }

    ::send(s, msg.data(), msg.size(), 0);
    std::vector<char> buf(2048);
    ssize_t n = ::recv(s, buf.data(), buf.size(), 0);
    if (n>0) std::print("[echo] {}\n", std::string(buf.begin(), buf.begin()+n));
    ::close(s);
}
```

---

### 8.5 “간단 신뢰성”: **손실/재전송** 미니 ARQ 설계

> UDP 위에 **시퀀스 번호 + ACK + 타임아웃/재전송**을 얹은 초간단 ARQ(Stop-and-Wait) 예제.  
> 실제 프로덕션에서는 **윈도우**, **중복 ACK**, **세분화된 타이머**, **재전송 제어** 등 더 풍부한 설계가 필요하다.

#### 8.5.1 프로토콜 스케치
- 데이터그램 포맷:
  ```
  0               1               2               3
  +---------------+---------------+---------------+---------------+
  |  TYPE (1B)    |  FLAGS (1B)   |            SEQ (16-bit)       |
  +---------------+---------------+---------------+---------------+
  |   PAYLOAD (0..MSS-4)                                      ...
  +--------------------------------------------------------------+
  ```
  - TYPE: 0x01(DATA), 0x02(ACK)  
  - SEQ: 0..65535 순환  
- 동작:
  - 송신: (DATA, seq, payload) 송신 → **타이머 T** 시작 → ACK(seq) 오면 다음 seq로 진행 → 타임아웃 시 **재전송**(N회 제한).  
  - 수신: DATA(seq) 수신 → **중복 여부** 판단(가장 최근 seq인지) → 상위에 인도 → ACK(seq) 전송.  
- Stop-and-Wait: **동시에 1개 데이터만 인플라이트**. 단순하지만 구현이 쉽다.

#### 8.5.2 공용 헤더/유틸
```cpp
// udp_arq_common.hpp
#pragma once
#include <cstdint>
#include <cstring>
#include <span>
#include <vector>
#include <optional>

constexpr uint8_t TYPE_DATA = 0x01;
constexpr uint8_t TYPE_ACK  = 0x02;

struct UdpHdr {
    uint8_t  type{};
    uint8_t  flags{};
    uint16_t seq{};
};

inline void hdr_pack(std::byte* b, const UdpHdr& h) {
    b[0] = std::byte(h.type);
    b[1] = std::byte(h.flags);
    uint16_t be = htons(h.seq);
    std::memcpy(b+2, &be, 2);
}
inline UdpHdr hdr_unpack(const std::byte* b) {
    UdpHdr h{};
    h.type  = (uint8_t)b[0];
    h.flags = (uint8_t)b[1];
    uint16_t be{}; std::memcpy(&be, b+2, 2);
    h.seq = ntohs(be);
    return h;
}
```

#### 8.5.3 서버(수신자): 에코 + ACK
```cpp
// udp_arq_server.cpp
// 빌드: g++ -std=c++23 -O2 -Wall udp_arq_server.cpp -o udp_arq_server
#include "udp_arq_common.hpp"
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <print>
#include <vector>
#include <unordered_map>

int main(int argc, char** argv) {
    const char* port = (argc>1? argv[1]: "9004");

    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_DGRAM; hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(nullptr, port, &hints, &res)!=0) { perror("gai"); return 1; }
    int s=-1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        if (::bind(s, ai->ai_addr, ai->ai_addrlen)==0) break;
        ::close(s); s=-1;
    }
    freeaddrinfo(res);
    if (s<0) { perror("bind"); return 1; }
    std::print("[arq-server] on :{}\n", port);

    std::vector<std::byte> buf(2048);
    // 피어별 최신 seq 기록(간단 버전: 4-튜플 키 생략, 데모용으로 주소문자열을 키로)
    auto to_key = [](const sockaddr_storage& sa)->std::string{
        char host[NI_MAXHOST]{}, serv[NI_MAXSERV]{};
        getnameinfo((sockaddr*)&sa, sizeof(sa), host, sizeof(host),
                    serv, sizeof(serv), NI_NUMERICHOST|NI_NUMERICSERV);
        return std::string(host)+":"+serv;
    };
    std::unordered_map<std::string,uint16_t> last_seq;

    for(;;){
        sockaddr_storage peer{}; socklen_t plen=sizeof(peer);
        ssize_t n = ::recvfrom(s, buf.data(), buf.size(), 0, (sockaddr*)&peer, &plen);
        if (n<4) continue;
        auto h = hdr_unpack(buf.data());
        if (h.type == TYPE_DATA) {
            // 중복 체크
            auto key = to_key(peer);
            bool dup = (last_seq.contains(key) && last_seq[key]==h.seq);
            // 에코(데모): 헤더 제외 페이로드를 그대로 다시 DATA로 보낼 수도 있지만,
            // 여기선 단순 ACK만 회신하고 끝.
            UdpHdr ack{.type=TYPE_ACK, .flags=0, .seq=h.seq};
            std::byte hdr[4]; hdr_pack(hdr, ack);
            ::sendto(s, hdr, 4, 0, (sockaddr*)&peer, plen);

            if (!dup) {
                last_seq[key] = h.seq;
                // 여기서 상위 레이어 처리(로그 등)
                std::string payload((char*)buf.data()+4, (char*)buf.data()+n);
                std::print("[DATA] seq={} bytes={} from {}\n", h.seq, n-4, key);
            } else {
                std::print("[DUP] seq={} from {}\n", h.seq, key);
            }
        }
    }
}
```

#### 8.5.4 클라이언트(송신자): Stop-and-Wait ARQ
```cpp
// udp_arq_client.cpp
// 빌드: g++ -std=c++23 -O2 -Wall udp_arq_client.cpp -o udp_arq_client
#include "udp_arq_common.hpp"
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <poll.h>
#include <print>
#include <string>
#include <vector>
#include <chrono>
#include <cstring>

int main(int argc, char** argv) {
    if (argc < 4) {
        std::print(stderr, "usage: {} <host> <port> <message>\n", argv[0]);
        return 1;
    }
    const char* host=argv[1]; const char* port=argv[2]; std::string msg=argv[3];

    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_DGRAM; hints.ai_flags=AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(host, port, &hints, &res)!=0) { perror("gai"); return 1; }

    int s=-1; sockaddr_storage dst{}; socklen_t dlen=0;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        std::memcpy(&dst, ai->ai_addr, ai->ai_addrlen); dlen=ai->ai_addrlen;
        break;
    }
    freeaddrinfo(res);
    if (s<0) { perror("socket"); return 1; }

    // Stop-and-Wait
    uint16_t seq = 1;
    std::vector<std::byte> pkt(4 + msg.size());
    UdpHdr h{.type=TYPE_DATA, .flags=0, .seq=seq};
    hdr_pack(pkt.data(), h);
    std::memcpy(pkt.data()+4, msg.data(), msg.size());

    int attempts = 0;
    const int MAX_ATTEMPTS = 5;
    const int TIMEOUT_MS = 500; // 재전송 타이머

    for (;;) {
        attempts++;
        ::sendto(s, pkt.data(), pkt.size(), 0, (sockaddr*)&dst, dlen);
        std::print("[send] seq={} bytes={} attempt={}\n", seq, pkt.size()-4, attempts);

        // ACK 대기
        pollfd pfd{.fd=s, .events=POLLIN, .revents=0};
        int rc = ::poll(&pfd, 1, TIMEOUT_MS);
        if (rc > 0 && (pfd.revents & POLLIN)) {
            std::byte ackbuf[64];
            sockaddr_storage peer{}; socklen_t plen=sizeof(peer);
            ssize_t n = ::recvfrom(s, ackbuf, sizeof(ackbuf), 0, (sockaddr*)&peer, &plen);
            if (n >= 4) {
                auto a = hdr_unpack(ackbuf);
                if (a.type==TYPE_ACK && a.seq==seq) {
                    std::print("[ack] seq={} ✅\n", a.seq);
                    break; // 성공
                }
            }
        } else if (rc == 0) {
            std::print("[timeout] seq={} → retransmit\n", seq);
            if (attempts >= MAX_ATTEMPTS) {
                std::print(stderr, "give up after {} attempts\n", attempts);
                break;
            }
            continue; // 재전송
        } else {
            perror("poll");
            break;
        }
    }
    ::close(s);
}
```

> 포인트  
> - **타임아웃/재시도 횟수**를 정책으로 둔다.  
> - **중복 수신**을 서버에서 감지하고 **ACK은 항상 회신**(idempotent).  
> - 실제로는 **윈도우 기반(Go-Back-N / Selective Repeat)** 으로 확장하고, **재전송 백오프**, **Jitter**, **혼잡 친화 정책** 등을 넣는다.

---

### 8.6 UDP에서 유용한 옵션/고급 주제

#### 8.6.1 소켓 버퍼/타임아웃
- `SO_RCVBUF`, `SO_SNDBUF`: 대역폭/RTT에 맞게 조정(6장 BDP 참고).  
- `SO_RCVTIMEO`, `SO_SNDTIMEO`: 블로킹 `recvfrom/sendto`의 **기본 타임아웃**. (실무에선 `poll/epoll` 선호)

```cpp
timeval tv{.tv_sec=0, .tv_usec=200000}; // 200ms
setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
```

#### 8.6.2 `IP_PKTINFO` / `IPV6_RECVPKTINFO` (수신 인터페이스/로컬 주소 확인)
- 서버가 **여러 NIC/주소**로 바인드했을 때, 수신 데이터그램의 **수신 로컬 주소**와 **들어온 인터페이스**를 알고 싶다면 `recvmsg()` + **ancillary data**(PKTINFO)를 사용.  
- 응답 시 **그 주소/그 인터페이스**로 **정확히** 보낼 수 있다(멀티홈/VRF/폴리시 라우팅 환경에서 중요).

```cpp
// 활성화
int on=1; setsockopt(fd, IPPROTO_IP, IP_PKTINFO, &on, sizeof(on));
// 수신: recvmsg()로 cmsg(IP_PKTINFO) 파싱 → in_pktinfo.ipi_spec_dst / ipi_ifindex 사용
```

#### 8.6.3 체크섬
- **IPv6**: **UDP 체크섬은 필수**(0 불가).  
- **IPv4**: UDP 체크섬은 선택이지만(0 가능) 대부분 스택은 계산한다. NIC offload가 일반적이라 비용은 낮은 편.

#### 8.6.4 NAT/방화벽과 Keepalive
- NAT는 **유휴 UDP 매핑**을 **수~수십 초** 수준으로 끊는 경우가 흔함.  
- **주기적 짧은 패킷(keepalive)** 을 보내 **매핑 유지**가 필요할 수 있다(예: STUN, TURN, ICE의 세계).

#### 8.6.5 멀티큐/성능
- 멀티코어에서 대량 UDP 처리: **SO\_REUSEPORT**로 여러 리시버를 두고 커널 분배 활용.  
- `recvmmsg/sendmmsg`(Linux)로 **배치 IO** → **syscall 수 감소**.

---

### 8.7 실험 설계 — 손실/지연에서 UDP ARQ 동작 관찰

1) **기본 에코**:  
   - 서버: `./udp_echo_server 9001`  
   - 클라: `./udp_echo_client 127.0.0.1 9001 "hello"`  
   - 메시지 경계 보존/트렁케이션(작은 버퍼) 확인.

2) **손실/지연 환경** (`tc netem`)  
   - 5% 손실, 50ms 지연:  
     ```bash
     sudo tc qdisc add dev <IF> root netem delay 25ms loss 5%
     ```
   - ARQ:  
     - 서버: `./udp_arq_server 9004`  
     - 클라: `./udp_arq_client 127.0.0.1 9004 "test-123"`  
     - **재전송 로그**로 Stop-and-Wait 동작 확인. 타임아웃/백오프를 바꾸며 성공률/지연을 비교.

3) **MTU 넘는 페이로드**로 단편화/손실 영향 보기  
   - 클라이언트에서 페이로드를 2KB/4KB/8KB로 키워 **성공률 하락** 관찰.  
   - 메시지를 **조각내기(어플리케이션 레벨)** 로 보낸 뒤 수신에서 **재조립**하도록 바꾸면 성공률 개선.

---

### 8.8 체크리스트 (요약)

- [ ] **UDP는 메시지 경계가 있다**(truncate 주의).  
- [ ] **손실/중복/순서 바뀜**은 **정상 동작**이다 → 필요한 신뢰성은 **직접 설계**.  
- [ ] **connected UDP**: 단일 피어엔 깔끔, **ICMP 오류** 전달 장점. 멀티 피어 서버엔 부적합.  
- [ ] **브로드캐스트**는 `SO_BROADCAST`가 필요, 반향 스톰 주의.  
- [ ] **멀티캐스트**: 그룹 가입, TTL/hops, 인터페이스, 루프백 등을 명시.  
- [ ] **MTU 고려**: 1472(IPv4)/1452(IPv6)보다 작게, 아니면 **조각내기**.  
- [ ] **성능**: `SO_RCVBUF/SO_SNDBUF` 튜닝, `recvmmsg/sendmmsg`, `SO_REUSEPORT`.  
- [ ] **관측/실험**: `tc netem`으로 손실/지연 주입 → ARQ 동작/성능 체감.

---

### 8.9 마무리

UDP는 **단순함**이 장점이다. **경계가 있는 데이터그램**, **낮은 오버헤드**, **멀티캐스트** 등 강력한 무기를 가진 대신, **신뢰성/순서/흐름**은 **당신의 프로토콜**이 책임진다.  
이 장의 에코/ARQ 예제는 “최소한의 안전망”을 직접 구현해 보는 출발점이다. 이후에는 **윈도우 기반 ARQ**, **손실/지연 추정**, **혼잡 친화적 전송률 조절**, **FEC(전방 오류정정)** 등으로 발전시켜라. 그러면 “UDP 위에서 TCP 같은 것”이 아니라, **당신의 요구에 딱 맞는 전송 계층**을 갖게 된다.
~~~markdown