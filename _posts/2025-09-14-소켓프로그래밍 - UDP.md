---
layout: post
title: 소켓프로그래밍 - UDP
date: 2025-09-14 22:25:23 +0900
category: 소켓프로그래밍
---
# UDP — 데이터그램 기반 비신뢰 전송 (POSIX + C++23)

## 1. UDP 개요 — “데이터그램 + 비신뢰성”

### 1.1 TCP vs UDP 한눈에 비교

UDP를 이해하려면 먼저 TCP와의 대비가 필요하다.

| 항목 | TCP | UDP |
|------|-----|-----|
| 연결 | 연결 지향(3-way handshake) | 비연결(connectionless) |
| 단위 | 바이트 스트림 | 데이터그램(메시지) |
| 신뢰성 | 재전송, 순서 보장, 흐름/혼잡 제어 | 없음(손실/중복/순서 바뀜 가능) |
| 헤더 크기 | 최소 20바이트(옵션 제외) | 8바이트 |
| 프레이밍 | 애플리케이션이 직접 설계 필요 | 메시지 경계 보존(프레이밍 내장) |
| 용도 | HTTP(S), DB, 파일 전송 등 | DNS, VoIP, 게임, 스트리밍, 실시간 텔레메트리 등 |

UDP는 **최소한의 기능**만 제공한다:

- IP 위에 얹힌 **포트 기반 데이터그램 다중화**.
- **체크섬**(IPv6에서는 필수)을 통한 데이터 손상 검출.
- 그 외 **신뢰성/순서/혼잡 제어는 전혀 없음**.

대신 얻는 장점:

- 헤더 오버헤드가 작고, **커널 상태가 거의 없다**.
- **연결 수 개념이 약하다** → 수만/수십만 피어와도 상대적으로 가벼운 상태 유지.
- **메시지 경계가 보존**되어 프레이밍에 유리.

---

## 2. 데이터그램과 메시지 경계

### 2.1 “한 번 send → 한 번 recv”의 의미

UDP에서 가장 중요한 특성은:

> 송신 측에서 `sendto()` (또는 `send()` on connected UDP) 한 번 호출한 결과가,  
> 수신 측에서 **최대 한 번의 `recvfrom()`(또는 `recv()`)** 으로 읽힌다.

즉,

- **한 데이터그램 = 하나의 메시지**.
- 메시지 사이에 **경계가 있다**.
- TCP처럼 “여러 번의 send가 섞여서 recv로 쪼개져 들어오는” 일이 없다.

그래서 UDP에서는 **프레이밍(메시지 경계 정의)** 를 별도로 만들지 않아도 된다.

### 2.2 버퍼 크기가 모자라면?

UDP에는 **부분 읽기 후 나머지를 다음에 마저 읽는** 개념이 없다.

- `recvfrom()` 에서 지정한 버퍼 크기보다 데이터그램이 크면:
  - 버퍼에 들어가는 만큼만 저장하고,
  - 나머지 바이트는 **버려진다**(truncate).
  - 커널은 해당 데이터그램을 **한 번에 큐에서 제거**한다.

즉, 수신 측에서 `recvfrom()` 호출 시점에:

- 큐(head)에 있는 **완전한 데이터그램 하나만** 꺼내고,
- 그 데이터그램이 너무 크면 잘라서 주고, 나머지는 폐기한다.

그래서 UDP 서버 설계 시:

- 예상되는 단일 메시지 최대 크기를 기준으로 **충분히 큰 수신 버퍼**를 준비해야 한다.
- 혹은 프로토콜 수준에서 “최대 페이로드 크기”를 명시적으로 제한하고, 클라이언트에게 강제해야 한다.

---

## 3. 비신뢰성: 손실/중복/순서 바뀜

### 3.1 손실

UDP는 **재전송이 없다**. 네트워크 어딘가에서 데이터그램이 드롭되면 그걸로 끝이다.

- 라우터 큐가 가득 차거나,
- MTU 단편화 조각 중 일부만 손실되거나,
- NIC 드라이버/OS의 수신 큐가 overflow 되거나,

어떤 이유로든 데이터그램이 사라질 수 있다. 애플리케이션은 이를 **정상 동작 범위**로 받아들여야 한다.

### 3.2 중복

UDP 데이터그램은 **중복 도착**할 수도 있다.

- 라우터 경로 변경 과정에서 재전송된 패킷이 돌아오거나,
- NAT/로드밸런서 장비의 동작 특이성,
- 애플리케이션 층 ARQ(재전송) 구현 시, ACK 손실로 인한 **중복 데이터 재전송** 등.

UDP 위에서 **자체 프로토콜**을 만들 때는:

- **시퀀스 번호**를 두고,
- 이미 본 시퀀스라면 **중복으로 처리**하거나 무시하는 로직을 꼭 넣어야 한다.

### 3.3 순서 바뀜

IP 계층은 패킷을 **최단 경로**가 아니라 **라우팅 정책**에 따라 전달하며, 경로가 시시각각 바뀔 수 있다.  
따라서 A → B → C 순으로 보낸 데이터그램이 수신 측에서는 B → A → C 형태로 도착하는 일도 정상이다.

- 실시간 스트리밍에서는 약간의 순서 바뀜을 허용하고,
- 게임/센서 데이터에서는 **타임스탬프/시퀀스** 기준으로 최신 값만 사용,
- 강한 순서를 요구하는 프로토콜은 **응용 계층 ARQ + 재정렬 버퍼**를 구현해야 한다.

---

## 4. MTU, IP 단편화, 안전한 페이로드 크기

### 4.1 MTU와 단편화

IP 계층에는 **MTU(Maximum Transmission Unit)** 가 있다.

- 일반적인 이더넷: MTU = 1500 바이트.
- 그 위에 IPv4/IPv6 헤더, UDP 헤더가 올라가므로, UDP가 사용할 수 있는 **실제 페이로드 한도**는 더 작다.

예:

- IPv4 헤더 20바이트 + UDP 헤더 8바이트:
  - 최대 안전 페이로드 ≈ 1500 - 20 - 8 = **1472바이트**.
- IPv6 헤더 40바이트 + UDP 헤더 8바이트:
  - 최대 안전 페이로드 ≈ 1500 - 40 - 8 = **1452바이트**.

여기에,

- IP 옵션,
- 터널링(예: VXLAN, GRE),
- VPN 헤더,

등이 추가되면 실제 허용 페이로드는 더 줄어든다.

### 4.2 단편화의 위험

데이터그램이 너무 크면 IP 계층에서 **단편화(fragmentation)** 된다.

- 하나의 UDP 데이터그램이 IP 조각 N개로 나뉘어 전송된다.
- **조각 중 하나라도 손실되면 전체 데이터그램이 폐기**된다.
- 일부 장비/방화벽은 **단편화된 패킷을 차단**하기도 한다.

따라서 실무에서는:

- 가능한 한 **단편화가 일어나지 않을 정도의 작은 페이로드**를 사용한다.
- 혹은 **Path MTU Discovery(PMTUD)** 를 사용하여 안전한 크기를 동적으로 찾는다.
- 더 큰 데이터를 보내야 한다면 **애플리케이션 레벨에서 조각내기 + 재조립**을 설계한다.

---

## 5. UDP 소켓 기본 API (POSIX)

### 5.1 소켓 생성

```cpp
int fd = ::socket(AF_INET, SOCK_DGRAM, 0);     // IPv4 UDP
// 또는
int fd6 = ::socket(AF_INET6, SOCK_DGRAM, 0);   // IPv6 UDP
```

- `AF_INET` / `AF_INET6`: 주소 패밀리 (IPv4 / IPv6).
- `SOCK_DGRAM`: UDP.
- 프로토콜 번호는 0 → OS가 UDP를 자동 선택.

### 5.2 바인드(bind)

서버/수신자는 특정 포트로 들어오는 데이터그램을 받기 위해 **bind** 해야 한다.

```cpp
sockaddr_in sa{};
sa.sin_family = AF_INET;
sa.sin_port   = htons(9001);
sa.sin_addr.s_addr = htonl(INADDR_ANY); // 모든 인터페이스에서 수신
if (::bind(fd, (sockaddr*)&sa, sizeof(sa)) < 0) {
    perror("bind");
}
```

IPv6는 `sockaddr_in6` 구조체를 사용한다.

---

## 6. 비연결 UDP: `sendto` / `recvfrom`

### 6.1 기본 패턴

비연결 UDP는 다음과 같은 패턴으로 사용한다.

- 송신 측:
  - `sendto(fd, buf, len, flags, (sockaddr*)&dst, dstlen);`
- 수신 측:
  - `recvfrom(fd, buf, len, flags, (sockaddr*)&src, &srclen);`

송신할 때마다 **목적지 주소**를 직접 넘기고, 수신할 때 **발신자 주소**를 함께 받는다.

### 6.2 단일 메시지 에코 서버 예제

```cpp
// udp_basic.cpp
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <vector>
#include <cstdio>
#include <cstring>

int udp_fd_any_bind(const char* port) {
    addrinfo hints{}, *res = nullptr;
    std::memset(&hints, 0, sizeof(hints));
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV;

    if (getaddrinfo(nullptr, port, &hints, &res) != 0) {
        return -1;
    }
    int s = -1;
    for (auto* ai = res; ai; ai = ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;
        if (::bind(s, ai->ai_addr, ai->ai_addrlen) == 0) {
            break;
        }
        ::close(s);
        s = -1;
    }
    freeaddrinfo(res);
    return s;
}

int main() {
    int s = udp_fd_any_bind("9001");
    if (s < 0) {
        std::perror("bind");
        return 1;
    }

    std::vector<char> buf(2000);
    sockaddr_storage peer{};
    socklen_t plen = sizeof(peer);

    ssize_t n = ::recvfrom(s, buf.data(), buf.size(), 0, (sockaddr*)&peer, &plen);
    if (n > 0) {
        ::sendto(s, buf.data(), n, 0, (sockaddr*)&peer, plen); // 에코
    }

    ::close(s);
}
```

위 예제는:

- 어떤 피어에서든 한 메시지를 받고,
- 그 메시지를 그대로 다시 보내는 **단순 에코 서버**의 최소 형태이다.

---

## 7. connected UDP: UDP에 대한 `connect()` 의 의미

### 7.1 connected UDP란?

UDP 소켓도 `connect()` 를 호출할 수 있다.

```cpp
int s = ::socket(AF_INET, SOCK_DGRAM, 0);

sockaddr_in dst{};
dst.sin_family = AF_INET;
dst.sin_port   = htons(9001);
inet_pton(AF_INET, "127.0.0.1", &dst.sin_addr);

if (::connect(s, (sockaddr*)&dst, sizeof(dst)) < 0) {
    std::perror("connect");
}
```

이렇게 하면:

1. 소켓에 **기본 목적지 주소**가 설정된다.
2. 이후에는 `sendto/recvfrom` 대신 **`send/recv` 를 쓸 수 있다**.
3. 다른 발신자에서 온 패킷은 **필터링**된다 (대부분 OS에서, 연결된 피어가 아닌 곳에서 오는 데이터그램은 버린다).
4. 일부 OS에서는 ICMP `Port Unreachable` 같은 에러를 **소켓 에러 상태**로 올려주어, 다음 `send`/`recv` 에서 오류를 확인할 수 있다.

### 7.2 단일 피어 클라이언트 예

```cpp
// connected_udp.cpp
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cstdio>
#include <cstring>

int main() {
    int s = ::socket(AF_INET, SOCK_DGRAM, 0);
    if (s < 0) { std::perror("socket"); return 1; }

    sockaddr_in dst{};
    dst.sin_family = AF_INET;
    dst.sin_port   = htons(9001);
    inet_pton(AF_INET, "127.0.0.1", &dst.sin_addr);

    if (::connect(s, (sockaddr*)&dst, sizeof(dst)) < 0) {
        std::perror("connect");
        ::close(s);
        return 1;
    }

    const char* msg = "ping";
    ::send(s, msg, std::strlen(msg), 0);

    char buf[1500];
    ssize_t n = ::recv(s, buf, sizeof(buf), 0);
    if (n > 0) {
        std::printf("got: %.*s\n", (int)n, buf);
    }

    ::close(s);
}
```

### 7.3 언제 비연결 / connected UDP 를 선택할까?

- **비연결(`sendto/recvfrom`)**:
  - 서버/프록시처럼 **여러 피어와 동시에 상호작용**해야 할 때.
  - 각 데이터그램의 발신자 주소 정보를 항상 알아야 할 때.
- **connected UDP**:
  - 단일 피어와의 왕복형 통신.
  - `send/recv` 를 사용하고 싶을 때.
  - ICMP 오류를 소켓 에러로 받고 싶은 경우.

---

## 8. 브로드캐스트

### 8.1 개념

브로드캐스트는 **특정 서브넷 내 모든 호스트**에게 패킷을 보내는 방식이다 (IPv4).

- 대표적인 주소:
  - **limited broadcast**: `255.255.255.255` (같은 링크에만 전달).
  - **directed broadcast**: 특정 네트워크의 브로드캐스트 주소 (예: `192.168.1.255`).

브로드캐스트 패킷은 통상 **라우터를 넘어가지 않는다.**  
따라서 보통 **로컬 서브넷 내 발견(Discovery)** 용으로 사용한다.

### 8.2 브로드캐스트 송신 예

브로드캐스트를 보내려면 소켓에 `SO_BROADCAST` 옵션을 켜야 한다.

```cpp
// udp_broadcast_sender.cpp
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cstdio>
#include <cstring>

int main() {
    int s = ::socket(AF_INET, SOCK_DGRAM, 0);
    if (s < 0) { std::perror("socket"); return 1; }

    int yes = 1;
    if (setsockopt(s, SOL_SOCKET, SO_BROADCAST, &yes, sizeof(yes)) < 0) {
        std::perror("setsockopt SO_BROADCAST");
        ::close(s);
        return 1;
    }

    sockaddr_in bc{};
    bc.sin_family = AF_INET;
    bc.sin_port   = htons(9002);
    inet_pton(AF_INET, "255.255.255.255", &bc.sin_addr); // limited broadcast

    const char* msg = "DISCOVER";
    if (::sendto(s, msg, std::strlen(msg), 0, (sockaddr*)&bc, sizeof(bc)) < 0) {
        std::perror("sendto");
    }

    ::close(s);
    return 0;
}
```

브로드캐스트 수신 측은 단순히 `INADDR_ANY` 로 바인드 하면 된다.

```cpp
// udp_broadcast_recv.cpp
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cstdio>
#include <vector>

int main() {
    int s = ::socket(AF_INET, SOCK_DGRAM, 0);
    if (s < 0) { std::perror("socket"); return 1; }

    sockaddr_in addr{};
    addr.sin_family      = AF_INET;
    addr.sin_port        = htons(9002);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (::bind(s, (sockaddr*)&addr, sizeof(addr)) < 0) {
        std::perror("bind");
        ::close(s);
        return 1;
    }

    std::vector<char> buf(1500);
    sockaddr_in src{}; socklen_t slen = sizeof(src);
    for (;;) {
        ssize_t n = ::recvfrom(s, buf.data(), buf.size(), 0, (sockaddr*)&src, &slen);
        if (n < 0) { std::perror("recvfrom"); continue; }
        buf[n] = '\0';
        char ip[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &src.sin_addr, ip, sizeof(ip));
        std::printf("from %s:%d msg=%s\n", ip, ntohs(src.sin_port), buf.data());
    }
}
```

### 8.3 주의: 브로드캐스트 스톰

브로드캐스트는 매우 강력하지만, 잘못 사용하면:

- 수많은 호스트가 동시에 응답하여 **네트워크 혼잡**을 유발할 수 있다.
- 이를 막기 위해:
  - 응답에 **랜덤 지연**을 주거나,
  - **rate limit**(단위 시간당 응답 수 제한),
  - 특정 조건에서만 응답하도록 설계해야 한다.

---

## 9. 멀티캐스트

### 9.1 개념

멀티캐스트는 **특정 그룹 주소**에 가입한 호스트에게만 패킷을 전달하는 방식이다.

- IPv4: 224.0.0.0 ~ 239.255.255.255 (Class D).
- IPv6: ff00::/8.

특징:

- 송신자는 **단 하나의 패킷**만 보낸다.
- 네트워크는 해당 그룹에 가입한 호스트들에게만 **복제/전달**한다.
- 수신자는 **그룹 가입(Join)** 을 명시적으로 해야 한다.

### 9.2 IPv4 멀티캐스트 수신 예

```cpp
// udp_multicast_recv.cpp
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cstdio>
#include <vector>
#include <cstring>

int main() {
    const char* group = "239.1.2.3";
    const int   port  = 9003;

    int s = ::socket(AF_INET, SOCK_DGRAM, 0);
    if (s < 0) { std::perror("socket"); return 1; }

    int reuse = 1;
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));

    sockaddr_in addr{};
    addr.sin_family      = AF_INET;
    addr.sin_port        = htons(port);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (::bind(s, (sockaddr*)&addr, sizeof(addr)) < 0) {
        std::perror("bind");
        ::close(s);
        return 1;
    }

    ip_mreq mreq{};
    inet_pton(AF_INET, group, &mreq.imr_multiaddr);
    mreq.imr_interface.s_addr = htonl(INADDR_ANY); // 기본 인터페이스 사용

    if (setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0) {
        std::perror("IP_ADD_MEMBERSHIP");
        ::close(s);
        return 1;
    }

    std::vector<char> buf(1500);
    for (;;) {
        ssize_t n = ::recv(s, buf.data(), buf.size(), 0);
        if (n < 0) { std::perror("recv"); continue; }
        std::printf("got %zd bytes\n", n);
    }

    ::close(s);
    return 0;
}
```

### 9.3 IPv4 멀티캐스트 송신 예

```cpp
// udp_multicast_send.cpp
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cstdio>
#include <cstring>

int main() {
    const char* group = "239.1.2.3";
    const int   port  = 9003;

    int s = ::socket(AF_INET, SOCK_DGRAM, 0);
    if (s < 0) { std::perror("socket"); return 1; }

    unsigned char ttl = 1; // 같은 링크까지만
    setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl));

    unsigned char loop = 0; // 송신자가 자기 것도 받을지 여부
    setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, &loop, sizeof(loop));

    sockaddr_in g{};
    g.sin_family = AF_INET;
    g.sin_port   = htons(port);
    inet_pton(AF_INET, group, &g.sin_addr);

    const char* msg = "hello group";
    if (::sendto(s, msg, std::strlen(msg), 0, (sockaddr*)&g, sizeof(g)) < 0) {
        std::perror("sendto");
    }

    ::close(s);
    return 0;
}
```

IPv6 멀티캐스트는 구조체/옵션 이름이 다르지만 패턴은 유사하다 (`ipv6_mreq`, `IPV6_JOIN_GROUP`, `IPV6_MULTICAST_HOPS` 등).

---

## 10. UDP 에코 서버/클라이언트 (조금 더 실제에 가까운 버전)

### 10.1 에코 서버 (비연결)

```cpp
// udp_echo_server.cpp
// 빌드: g++ -std=c++23 -O2 -Wall udp_echo_server.cpp -o udp_echo_server
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <print>
#include <vector>
#include <cstring>

int main(int argc, char** argv) {
    const char* port = (argc > 1 ? argv[1] : "9001");

    addrinfo hints{}, *res = nullptr;
    std::memset(&hints, 0, sizeof(hints));
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV;

    if (getaddrinfo(nullptr, port, &hints, &res) != 0) {
        std::perror("getaddrinfo");
        return 1;
    }

    int s = -1;
    for (auto* ai = res; ai; ai = ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;
        if (::bind(s, ai->ai_addr, ai->ai_addrlen) == 0) {
            break;
        }
        ::close(s);
        s = -1;
    }
    freeaddrinfo(res);

    if (s < 0) {
        std::perror("bind");
        return 1;
    }
    std::print("[udp-echo] listening on :{}\n", port);

    std::vector<char> buf(2048);
    for (;;) {
        sockaddr_storage peer{};
        socklen_t plen = sizeof(peer);
        ssize_t n = ::recvfrom(s, buf.data(), buf.size(), 0, (sockaddr*)&peer, &plen);
        if (n < 0) {
            if (errno == EINTR) continue;
            std::perror("recvfrom");
            continue;
        }
        // 그대로 반사
        ::sendto(s, buf.data(), n, 0, (sockaddr*)&peer, plen);
    }
}
```

### 10.2 에코 클라이언트 (connected UDP + 타임아웃)

```cpp
// udp_echo_client.cpp
// 빌드: g++ -std=c++23 -O2 -Wall udp_echo_client.cpp -o udp_echo_client
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <poll.h>
#include <print>
#include <string>
#include <vector>
#include <cstring>

int main(int argc, char** argv) {
    if (argc < 4) {
        std::print(stderr, "usage: {} <host> <port> <msg>\n", argv[0]);
        return 1;
    }
    const char* host = argv[1];
    const char* port = argv[2];
    std::string msg  = argv[3];

    addrinfo hints{}, *res = nullptr;
    std::memset(&hints, 0, sizeof(hints));
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags    = AI_ADDRCONFIG | AI_NUMERICSERV;

    if (getaddrinfo(host, port, &hints, &res) != 0) {
        std::perror("getaddrinfo");
        return 1;
    }

    int s = -1;
    for (auto* ai = res; ai; ai = ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;
        if (::connect(s, ai->ai_addr, ai->ai_addrlen) == 0) {
            break;
        }
        ::close(s);
        s = -1;
    }
    freeaddrinfo(res);
    if (s < 0) {
        std::perror("connect");
        return 1;
    }

    ::send(s, msg.data(), msg.size(), 0);

    pollfd pfd{.fd = s, .events = POLLIN, .revents = 0};
    int rc = ::poll(&pfd, 1, 1000); // 1초 대기
    if (rc > 0 && (pfd.revents & POLLIN)) {
        std::vector<char> buf(2048);
        ssize_t n = ::recv(s, buf.data(), buf.size(), 0);
        if (n > 0) {
            std::print("[echo] {}\n", std::string(buf.begin(), buf.begin() + n));
        }
    } else {
        std::print(stderr, "timeout or error\n");
    }

    ::close(s);
    return 0;
}
```

---

## 11. UDP 위의 간단 ARQ (Stop-and-Wait)

> 이제 UDP 위에 **최소한의 신뢰성**을 올려보자.  
> Stop-and-Wait ARQ는 **항상 한 개의 패킷만 인플라이트** 상태에 두는 아주 단순한 재전송 프로토콜이다.

### 11.1 프로토콜 설계

#### 11.1.1 헤더 포맷

간단한 헤더를 정의하자.

- TYPE: 데이터인지 ACK인지.
- FLAGS: 확장용.
- SEQ: 16비트 시퀀스 번호.

바이트 레이아웃:

```
0               1               2               3
+---------------+---------------+---------------+---------------+
|  TYPE (1B)    |  FLAGS (1B)   |            SEQ (16-bit)       |
+---------------+---------------+---------------+---------------+
|   PAYLOAD (0..MSS-4)                                      ...
+--------------------------------------------------------------+
```

- TYPE:
  - 0x01 = DATA
  - 0x02 = ACK
- SEQ:
  - 0..65535 순환.
  - Stop-and-Wait에서는 **각 메시지마다 1씩 증가**시키면 충분하다.

#### 11.1.2 동작

송신자:

1. (DATA, seq, payload) 패킷 전송.
2. 타임아웃 \(T\) 설정 후 ACK 대기.
3. 시간 내에 ACK(seq) 도착:
   - 성공 → 다음 seq로 진행.
4. 타임아웃 발생:
   - 같은 DATA(seq)를 재전송.
   - 재전송 횟수 제한(예: 5회)을 넘으면 실패로 간주.

수신자:

1. DATA(seq) 수신 시:
   - 중복 여부 판단:
     - 처음 보는 seq:
       - 상위 계층에 전달.
       - ACK(seq) 전송.
     - 이미 처리한 seq:
       - 상위 계층에 재전달하지 않음.
       - 그래도 ACK(seq)는 재전송 (송신 측 타임아웃을 해제하기 위함).

### 11.2 공용 헤더/유틸 코드

```cpp
// udp_arq_common.hpp
#pragma once
#include <cstdint>
#include <cstring>
#include <span>
#include <vector>

#include <arpa/inet.h>

constexpr uint8_t TYPE_DATA = 0x01;
constexpr uint8_t TYPE_ACK  = 0x02;

struct UdpHdr {
    uint8_t  type{};
    uint8_t  flags{};
    uint16_t seq{};
};

inline void hdr_pack(std::byte* b, const UdpHdr& h) {
    b[0] = std::byte(h.type);
    b[1] = std::byte(h.flags);
    uint16_t be = htons(h.seq);
    std::memcpy(b + 2, &be, 2);
}
inline UdpHdr hdr_unpack(const std::byte* b) {
    UdpHdr h{};
    h.type  = (uint8_t)b[0];
    h.flags = (uint8_t)b[1];
    uint16_t be{};
    std::memcpy(&be, b + 2, 2);
    h.seq = ntohs(be);
    return h;
}
```

---

## 12. ARQ 서버(수신자) 구현

```cpp
// udp_arq_server.cpp
// 빌드: g++ -std=c++23 -O2 -Wall udp_arq_server.cpp -o udp_arq_server
#include "udp_arq_common.hpp"

#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <print>
#include <vector>
#include <unordered_map>
#include <string>

int main(int argc, char** argv) {
    const char* port = (argc > 1 ? argv[1] : "9004");

    addrinfo hints{}, *res = nullptr;
    std::memset(&hints, 0, sizeof(hints));
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV;

    if (getaddrinfo(nullptr, port, &hints, &res) != 0) {
        std::perror("getaddrinfo");
        return 1;
    }

    int s = -1;
    for (auto* ai = res; ai; ai = ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;
        if (::bind(s, ai->ai_addr, ai->ai_addrlen) == 0) {
            break;
        }
        ::close(s);
        s = -1;
    }
    freeaddrinfo(res);

    if (s < 0) {
        std::perror("bind");
        return 1;
    }
    std::print("[arq-server] listening on :{}\n", port);

    std::vector<std::byte> buf(2048);

    auto to_key = [](const sockaddr_storage& sa, socklen_t slen) -> std::string {
        char host[NI_MAXHOST]{}, serv[NI_MAXSERV]{};
        getnameinfo((sockaddr*)&sa, slen, host, sizeof(host), serv, sizeof(serv),
                    NI_NUMERICHOST | NI_NUMERICSERV);
        return std::string(host) + ":" + serv;
    };

    std::unordered_map<std::string, uint16_t> last_seq;

    for (;;) {
        sockaddr_storage peer{};
        socklen_t plen = sizeof(peer);
        ssize_t n      = ::recvfrom(s, buf.data(), buf.size(), 0, (sockaddr*)&peer, &plen);
        if (n < 4) continue;

        auto h = hdr_unpack(buf.data());
        if (h.type == TYPE_DATA) {
            std::string key = to_key(peer, plen);
            bool dup = last_seq.contains(key) && last_seq[key] == h.seq;

            // ACK 전송 (중복이든 아니든 항상 보냄)
            UdpHdr ack{.type = TYPE_ACK, .flags = 0, .seq = h.seq};
            std::byte hdrbuf[4];
            hdr_pack(hdrbuf, ack);
            ::sendto(s, hdrbuf, 4, 0, (sockaddr*)&peer, plen);

            if (!dup) {
                last_seq[key] = h.seq;
                std::string payload((char*)buf.data() + 4, (char*)buf.data() + n);
                std::print("[DATA] from={} seq={} bytes={}\n", key, h.seq, n - 4);
                std::print("       payload='{}'\n", payload);
            } else {
                std::print("[DUP] from={} seq={}\n", key, h.seq);
            }
        }
    }

    ::close(s);
    return 0;
}
```

---

## 13. ARQ 클라이언트(송신자) 구현 — Stop-and-Wait

```cpp
// udp_arq_client.cpp
// 빌드: g++ -std=c++23 -O2 -Wall udp_arq_client.cpp -o udp_arq_client
#include "udp_arq_common.hpp"

#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <poll.h>
#include <print>
#include <string>
#include <vector>
#include <cstring>

int main(int argc, char** argv) {
    if (argc < 4) {
        std::print(stderr, "usage: {} <host> <port> <message>\n", argv[0]);
        return 1;
    }
    const char* host = argv[1];
    const char* port = argv[2];
    std::string msg  = argv[3];

    addrinfo hints{}, *res = nullptr;
    std::memset(&hints, 0, sizeof(hints));
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags    = AI_ADDRCONFIG | AI_NUMERICSERV;

    if (getaddrinfo(host, port, &hints, &res) != 0) {
        std::perror("getaddrinfo");
        return 1;
    }

    int s = -1;
    sockaddr_storage dst{};
    socklen_t dlen = 0;

    for (auto* ai = res; ai; ai = ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;
        std::memcpy(&dst, ai->ai_addr, ai->ai_addrlen);
        dlen = ai->ai_addrlen;
        break;
    }
    freeaddrinfo(res);

    if (s < 0) {
        std::perror("socket");
        return 1;
    }

    uint16_t seq = 1;
    std::vector<std::byte> pkt(4 + msg.size());
    UdpHdr h{.type = TYPE_DATA, .flags = 0, .seq = seq};
    hdr_pack(pkt.data(), h);
    std::memcpy(pkt.data() + 4, msg.data(), msg.size());

    const int TIMEOUT_MS    = 500;
    const int MAX_ATTEMPTS  = 5;
    int       attempts      = 0;

    for (;;) {
        attempts++;
        ::sendto(s, pkt.data(), pkt.size(), 0, (sockaddr*)&dst, dlen);
        std::print("[send] seq={} bytes={} attempt={}\n", seq, pkt.size() - 4, attempts);

        pollfd pfd{.fd = s, .events = POLLIN, .revents = 0};
        int rc = ::poll(&pfd, 1, TIMEOUT_MS);
        if (rc > 0 && (pfd.revents & POLLIN)) {
            std::byte ackbuf[64];
            sockaddr_storage peer{};
            socklen_t plen = sizeof(peer);
            ssize_t n = ::recvfrom(s, ackbuf, sizeof(ackbuf), 0, (sockaddr*)&peer, &plen);
            if (n >= 4) {
                auto a = hdr_unpack(ackbuf);
                if (a.type == TYPE_ACK && a.seq == seq) {
                    std::print("[ack] seq={} (success)\n", a.seq);
                    break;
                }
            }
        } else if (rc == 0) {
            std::print("[timeout] seq={} → retransmit\n", seq);
            if (attempts >= MAX_ATTEMPTS) {
                std::print(stderr, "give up after {} attempts\n", attempts);
                break;
            }
            continue; // 재전송
        } else {
            std::perror("poll");
            break;
        }
    }

    ::close(s);
    return 0;
}
```

이 예제는:

- 송신 측에서 동일 메시지를 최대 5번까지 재전송한다.
- 서버가 ACK를 보내지 않거나, 네트워크 손실이 발생하면 **타임아웃 + 재전송**이 일어난다.
- 서버는 중복 DATA를 **재전달하지 않지만**, ACK는 항상 다시 보내므로 송신 측 타임아웃을 해제할 수 있다.

---

## 14. ARQ를 윈도우 기반으로 확장할 때의 개념

Stop-and-Wait는 너무 단순해서, RTT가 긴 환경에서 **대역폭 사용률이 낮다**.  
이때 흔히 사용하는 개념이 **윈도우 기반 ARQ**(Go-Back-N, Selective Repeat 등)이다.

간단히 개념만 정리하면:

- 송신자는 **보낼 수 있는 시퀀스 번호 구간(윈도우)** 를 유지한다.
- 윈도우 내에서 여러 데이터그램을 연속해서 보낸 후,
- 각 데이터그램에 대한 ACK를 비동기적으로 받아,
- ACK가 온 것까지 **윈도우를 앞으로 슬라이드** 한다.

대역폭-지연 곱(Bandwidth-Delay Product)를 고려하면, 필요한 윈도우 크기 \(W\) 는 대략:

$$
W \approx \frac{\text{대역폭} \times \text{RTT}}{\text{세그먼트 크기}}
$$

예를 들어,

- 대역폭 10 Mbps,
- RTT 100 ms,
- UDP 페이로드 1000바이트라고 하면:

$$
\text{BDP} = 10 \times 10^6 \, \text{bps} \times 0.1 \, \text{s} = 10^6 \, \text{bit} \approx 125\,000 \, \text{byte}
$$

1000바이트 세그먼트로 나누면 약 125개 정도의 세그먼트를 동시에 날려야 **링크를 가득 채운다**는 의미가 된다.

이때:

- Stop-and-Wait는 항상 1개만 인플라이트이므로, 이론적 최대의 **1/125** 수준만 활용하는 셈이다.
- 윈도우 기반 ARQ는 이 구간을 동적으로 유지하며 대역폭 사용률을 높인다.

UDP 위에서 이런 윈도우 기반 ARQ를 직접 구현하면:

- 사실상 “TCP 비슷한 것”을 만드는 셈이 된다.
- 하지만 필요에 따라 TCP와 다른 정책(예: 지연 대신 손실 허용, 특정 우선순위, 애플리케이션 특정 혼잡 제어)을 구현할 수 있다.

---

## 15. 실무에서의 UDP 소켓 옵션/튜닝

### 15.1 소켓 버퍼 크기

- `SO_RCVBUF`: 수신 버퍼 크기.
- `SO_SNDBUF`: 송신 버퍼 크기.

대역폭과 RTT에 따라 **버퍼 크기를 넉넉히** 잡는 것이 좋다.  
버퍼가 너무 작으면 burst 상황에서 데이터그램이 쉽게 드롭된다.

```cpp
int rcvbuf = 4 * 1024 * 1024;
setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(rcvbuf));

int sndbuf = 4 * 1024 * 1024;
setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &sndbuf, sizeof(sndbuf));
```

### 15.2 블로킹 소켓에서의 타임아웃

`SO_RCVTIMEO`, `SO_SNDTIMEO`를 사용하면 블로킹 `recvfrom/sendto` 에 기본 타임아웃을 줄 수 있다.

```cpp
timeval tv{};
tv.tv_sec  = 0;
tv.tv_usec = 200000; // 200ms

setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
```

실무에서는 이벤트 루프(`poll/epoll`) 기반 설계를 더 많이 사용하지만, 간단한 프로그램에서는 유용하다.

### 15.3 `SO_REUSEADDR` / `SO_REUSEPORT`

- `SO_REUSEADDR`:
  - 같은 포트에 여러 프로세스가 바인드할 수 있도록 하는 옵션 (운영체제마다 의미/행동이 약간 다름).
  - 멀티캐스트 수신, 빠른 재시작 등에 자주 사용.
- `SO_REUSEPORT`:
  - 여러 프로세스/스레드가 동일 포트로 바인드하여 **로드밸런싱** 받은 패킷을 나눠 처리할 수 있도록 한다(리눅스).

### 15.4 배치 I/O: `recvmmsg` / `sendmmsg` (Linux)

다량의 UDP 데이터그램을 처리할 때:

- `recvmmsg`:
  - 한 번의 시스템 콜로 여러 데이터그램을 한꺼번에 읽어온다.
- `sendmmsg`:
  - 한 번의 시스템 콜로 여러 데이터그램을 한꺼번에 보낸다.

이를 통해 **시스템 콜 호출 수를 줄이고**, CPU 오버헤드를 감소시킬 수 있다.

---

## 16. 테스트/실험: 손실·지연 환경에서 ARQ 관찰

리눅스에서는 `tc netem` 을 사용해 테스트 네트워크에 **손실/지연/재정렬**을 인위적으로 주입할 수 있다.

예:

```bash
# 5% 손실, 평균 50ms 지연, 10ms 표준편차
sudo tc qdisc add dev <인터페이스> root netem delay 50ms 10ms distribution normal loss 5%
```

이 상태에서:

1. `udp_echo_server` / `udp_echo_client`를 실행해보고,
2. `udp_arq_server` / `udp_arq_client`를 실행하면,

- 에코는 종종 응답이 사라지거나 지연되는 것을 볼 수 있고,
- ARQ는 재전송 로그를 통해 신뢰성을 확보하려는 동작을 직접 관찰할 수 있다.

실험을 반복하며:

- `TIMEOUT_MS`를 크게/작게 바꾸고,
- `MAX_ATTEMPTS` 를 늘리거나 줄이고,
- 페이로드 크기를 256바이트, 1024바이트, 4096바이트 등으로 변경하면서,

각 경우의 **성공률/지연/네트워크 사용량**을 비교해 보면 실제 환경에서의 튜닝 감각을 기를 수 있다.

---

## 17. 체크리스트

UDP 기반 시스템을 설계할 때 다음을 항상 점검하자.

### 17.1 프로토콜 설계

- [ ] 단일 데이터그램 최대 크기(페이로드)를 **MTU** 고려하여 결정했는가.
- [ ] **메시지 경계**를 잘 정의했는가 (UDP는 이미 경계가 있으나, **헤더/버전/길이** 등을 명시해야 한다).
- [ ] 손실/중복/순서 바뀜을 **정상 케이스**로 보고, 시퀀스 번호/타임아웃/재전송 등 전략을 세웠는가.
- [ ] 보안(스푸핑/리플레이)에 대한 기본 대책(토큰, nonce, MAC 등)을 고려했는가.

### 17.2 소켓 옵션/운영

- [ ] `SO_RCVBUF` / `SO_SNDBUF` 크기가 서비스 대역폭/RTT에 맞게 설정되었는가.
- [ ] `SO_BROADCAST` / 멀티캐스트 옵션을 올바르게 설정했는가.
- [ ] NAT/방화벽 환경에서 **keepalive** 전략이 있는가.
- [ ] 고성능이 필요하다면 `SO_REUSEPORT`, `recvmmsg/sendmmsg` 등 배치 I/O/멀티큐를 고려했는가.

### 17.3 디버깅/모니터링

- [ ] `tcpdump`/Wireshark 로 실제 패킷을 캡처하여 **헤더/페이로드가 설계대로 나가는지** 확인했는가.
- [ ] 손실·지연 환경에서 `tc netem` 등을 사용해 **스트레스 테스트**를 했는가.
- [ ] 서버/클라이언트에 적절한 **로그**(시퀀스 번호, 재전송 횟수, RTT 등)를 넣었는가.

---

## 18. 요약

1. **UDP는 데이터그램 기반 비신뢰 전송**이다.
   - 메시지 경계가 보존되지만, 손실/중복/순서 바뀜을 보장 없이 허용한다.
2. `sendto/recvfrom` 를 사용하는 비연결 UDP는 여러 피어를 상대하는 서버/프록시에 적합하고,  
   connected UDP는 단일 피어 클라이언트에서 간결한 코드와 ICMP 오류 전달에 유리하다.
3. 브로드캐스트/멀티캐스트는 UDP만이 제공하는 강력한 기능이지만,  
   브로드캐스트 스톰, 멀티캐스트 라우팅/가입 관리 등 **운영 측면**을 신중히 설계해야 한다.
4. ARQ(재전송 프로토콜)를 UDP 위에 올리면 **최소한의 신뢰성**을 확보할 수 있다.
   - Stop-and-Wait는 구현이 쉽고 교육용으로 좋다.
   - 실제 대역폭 활용을 위해서는 윈도우 기반 ARQ와 혼잡 제어, 백오프가 필요하다.
5. 실무에서는 **MTU/단편화, 버퍼 크기, NAT/방화벽, 성능/모니터링 도구** 까지 포함한 전체 그림을 가지고 UDP 시스템을 설계해야 한다.
