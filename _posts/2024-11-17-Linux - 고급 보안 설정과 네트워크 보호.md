---
layout: post
title: Linux - 고급 보안 설정과 네트워크 보호
date: 2024-11-17 19:20:23 +0900
category: Linux
---
# 고급 보안 설정과 네트워크 보호

## 보안 운영의 기본 원칙

리눅스 시스템의 보안 설정은 단순한 기술 구현을 넘어 철학적 접근이 필요합니다. 몇 가지 핵심 원칙을 이해하는 것이 중요합니다.

- **기본 정책은 거부(DROP)**: 명시적으로 허용하지 않은 모든 트래픽은 기본적으로 차단해야 합니다.
- **필요한 서비스만 명시적 허용**: 시스템에서 실제로 필요한 서비스 포트만 개방하고, 그 외는 모두 차단합니다.
- **상태 추적(Stateful) 방화벽 활용**: ESTABLISHED, RELATED 상태의 연결은 우선적으로 허용하여 정상적인 통신을 보장합니다.
- **로그 관리의 균형**: 보안 로깅은 중요하지만, 레이트 리미팅을 적용하여 로그 폭탄 공격을 방지해야 합니다.
- **ICMP의 합리적 허용**: ICMP 트래픽을 과도하게 차단하면 PMTU(Path MTU Discovery)와 네트워크 오류 통지에 문제가 발생할 수 있습니다.
- **관리 포트의 강화**: SSH 같은 관리 포트는 소스 IP 제한, 키 기반 인증, fail2ban과 같은 추가 보안 계층으로 보호해야 합니다.
- **클라우드 환경의 역할 분담**: 클라우드 환경에서는 보안 그룹, 네트워크 ACL, 호스트 방화벽이 각자의 역할을 분담하도록 설계합니다.
- **VPN의 종합적 구성**: VPN 설정은 암호화 터널뿐만 아니라 IP 포워딩, NAT, 라우팅, DNS, MTU/MSS 조정까지 고려해야 합니다.

---

## iptables 방화벽: 기초부터 고급까지

### iptables의 기본 구조 복습

iptables는 리눅스 커널의 넷필터 프레임워크를 제어하는 도구로, 여러 테이블과 체인으로 구성됩니다.

- **filter 테이블**: 패킷 허용/거부의 기본 테이블입니다. 주요 체인으로 `INPUT`(수신), `FORWARD`(전달), `OUTPUT`(송신)이 있습니다.
- **nat 테이블**: 네트워크 주소 변환을 담당합니다. 주요 체인은 `PREROUTING`, `OUTPUT`, `POSTROUTING`입니다.
- **mangle 테이블**: 패킷 헤더 수정(TOS, TTL, 마크 등)에 사용됩니다.
- **raw 테이블**: 연결 추적(conntrack)에서 제외할 패킷을 지정합니다.

### 최소 보안 정책 템플릿 (IPv4)

다음은 실무에서 사용할 수 있는 기본적인 방화벽 설정 템플릿입니다. 기본 정책은 거부(DROP)이며, 필요한 최소한의 서비스만 허용합니다.

```bash
# 기본 정책 설정: 모든 입력과 전달은 거부, 출력은 허용
sudo iptables -P INPUT DROP
sudo iptables -P FORWARD DROP
sudo iptables -P OUTPUT ACCEPT

# 루프백 인터페이스 트래픽 허용 (시스템 내부 통신)
sudo iptables -A INPUT -i lo -j ACCEPT

# 이미 설정된 연결과 관련된 트래픽 허용 (상태 추적)
sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# 필요한 서비스 포트 허용 (SSH, HTTP, HTTPS)
sudo iptables -A INPUT -p tcp -m multiport --dports 22,80,443 -m conntrack --ctstate NEW -j ACCEPT

# 필수적인 ICMP 트래픽 허용 (핑 요청, 목적지 불가능, 시간 초과)
sudo iptables -A INPUT -p icmp -m icmp --icmp-type echo-request -j ACCEPT
sudo iptables -A INPUT -p icmp -m icmp --icmp-type destination-unreachable -j ACCEPT
sudo iptables -A INPUT -p icmp -m icmp --icmp-type time-exceeded -j ACCEPT

# 거부된 패킷 로깅 (레이트 리미팅 적용)
sudo iptables -A INPUT -m limit --limit 5/second --limit-burst 20 -j LOG --log-prefix "FW DROP IN: " --log-level 6

# 모든 나머지 입력 패킷 거부
sudo iptables -A INPUT -j DROP
```

**참고**: IPv6 환경에서는 `ip6tables`를 사용하여 유사하게 구성하거나, 더 현대적인 `nftables`로 전환하는 것을 권장합니다.

### SSH 접근 제한과 포트 녹킹

SSH는 가장 빈번한 공격 대상이므로 추가적인 보호 계층이 필요합니다.

**특정 IP 대역에서만 SSH 허용**:
```bash
# 사무실 네트워크(203.0.113.0/24)에서만 SSH 접근 허용
sudo iptables -I INPUT 3 -p tcp -s 203.0.113.0/24 --dport 22 -j ACCEPT
```

**포트 녹킹(Port Knocking) 예시**:
포트 녹킹은 보안을 위한 보조 수단으로, 특정 포트 시퀀스에 접속해야 실제 서비스 포트가 열리는 방식입니다.
```bash
# 포트 녹킹 체인 생성
sudo iptables -N KNOCKING

# 첫 번째 녹킹 포트(10001) 접근 감지
sudo iptables -A INPUT -p tcp --dport 10001 -m recent --name KNOCK1 --set -j DROP

# 두 번째 녹킹 포트(10002) - 첫 번째 후 30초 이내 접근 필요
sudo iptables -A INPUT -p tcp --dport 10002 -m recent --rcheck --seconds 30 --name KNOCK1 \
  -m recent --name KNOCK2 --set -j DROP

# 세 번째 녹킹 포트(10003) - 두 번째 후 30초 이내 접근 시 SSH 허용
sudo iptables -A INPUT -p tcp --dport 10003 -m recent --rcheck --seconds 30 --name KNOCK2 \
  -j ACCEPT
```
포트 녹킹은 보안을 위한 유일한 수단이 아닙니다. fail2ban과 같은 다른 보안 도구와 함께 사용해야 합니다.

### DDoS 및 스캔 공격 완화

```bash
# SYN 플러드 공격 방지 (초당 30개 SYN 패킷으로 제한)
sudo iptables -A INPUT -p tcp --syn -m limit --limit 30/second --limit-burst 100 -j ACCEPT

# 동일 IP의 과도한 스캔 제한 (hashlimit 모듈 사용)
sudo iptables -A INPUT -p tcp --syn -m hashlimit --hashlimit 50/second --hashlimit-burst 200 \
  --hashlimit-mode srcip --hashlimit-name synlimit -j ACCEPT

# 제한을 초과하는 모든 SYN 패킷 거부
sudo iptables -A INPUT -p tcp --syn -j DROP
```

### 애플리케이션 수준 보호 (HTTP 요청 제한)

```bash
# HTTP 요청 레이트 제한 (초당 50개 새 연결로 제한)
sudo iptables -A INPUT -p tcp --dport 80 -m state --state NEW -m limit --limit 50/second --limit-burst 200 -j ACCEPT

# 제한을 초과하는 HTTP 연결 거부
sudo iptables -A INPUT -p tcp --dport 80 -j DROP
```
보다 정교한 레이트 리미팅은 NGINX, Envoy, WAF(웹 애플리케이션 방화벽) 또는 로드 밸런서에서 구현하는 것이 좋습니다.

### NAT 및 포트 포워딩 + MSS 클램핑

**내부 네트워크를 위한 NAT 설정**:
```bash
# 내부 네트워크(10.0.0.0/24)의 트래픽을 외부 인터페이스(eth0)로 NAT
sudo iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o eth0 -j MASQUERADE
```

**PMTU 문제 방지를 위한 MSS 클램핑**:
```bash
# VPN이나 터널을 통한 통신 시 PMTU 문제 방지
sudo iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN \
  -j TCPMSS --clamp-mss-to-pmtu
```

### iptables 규칙 영구화

**Debian/Ubuntu 계열**:
```bash
sudo apt install iptables-persistent
sudo netfilter-persistent save
sudo netfilter-persistent reload
```

**수동 저장 및 복원**:
```bash
# 현재 규칙 저장
sudo iptables-save | sudo tee /etc/iptables/rules.v4

# 저장된 규칙 복원
sudo iptables-restore < /etc/iptables/rules.v4
```

---

## fail2ban: 로그 기반 자동 차단 시스템

fail2ban은 시스템 로그를 모니터링하여 반복적인 실패 시도(예: SSH 비밀번호 무차별 대입)를 감지하고, 일정 시간 동안 해당 IP를 차단하는 도구입니다.

### 설치 및 기본 구성

```bash
sudo apt install fail2ban
sudo systemctl enable --now fail2ban
```

fail2ban의 작동 원리는 다음과 같습니다: **jail**(감시 대상) → **filter**(로그 패턴 정규식) → **action**(차단 수단: iptables, firewalld, nftables 등)

### SSH 기본 Jail 설정

`/etc/fail2ban/jail.local` 파일을 생성하여 사용자 정의 설정을 추가합니다:
```ini
[DEFAULT]
banaction = iptables-multiport
bantime.increment = true        # 재범 시 차단 시간 증가
bantime.rndtime = 30m           # 차단 시간에 무작위 변동 추가
bantime.factor = 1.5            # 재범 시 차단 시간 배수
bantime = 15m                   # 기본 차단 시간
findtime = 10m                  # 실패 시도 감지 기간
maxretry = 5                    # 최대 허용 실패 횟수
ignoreip = 127.0.0.1/8 10.0.0.0/8 192.168.0.0/16  # 차단 제외 IP 대역

[sshd]
enabled = true
port    = ssh
filter  = sshd
logpath = /var/log/auth.log
backend = systemd
```
`bantime.increment=true` 설정은 반복적인 공격 시 차단 시간을 점진적으로 증가시킵니다. 운영 중 오탐(false positive)이 발생하면 `ignoreip`에 해당 IP를 추가할 수 있습니다.

### 웹 서버 보호 예시

**HTTP 기본 인증 및 워드프레스 관리 페이지 보호**:
```ini
[nginx-http-auth]
enabled  = true
port     = http,https
filter   = nginx-http-auth
logpath  = /var/log/nginx/error.log
maxretry = 3
findtime = 5m
bantime  = 1h

[nginx-404-scan]
enabled  = true
port     = http,https
filter   = nginx-404-scan
logpath  = /var/log/nginx/access.log
maxretry = 15
findtime = 5m
bantime  = 30m
```

**404 스캔 필터 정의** (`/etc/fail2ban/filter.d/nginx-404-scan.conf`):
```ini
[Definition]
failregex = ^<HOST> - - .* "GET .*(/wp-admin|/phpmyadmin|/manager|/admin).*" 404 .*
ignoreregex =
```
실제 환경의 로그 형식에 맞게 `failregex`를 조정해야 합니다.

### fail2ban 상태 관리

```bash
# 전체 fail2ban 상태 확인
sudo fail2ban-client status

# 특정 jail 상태 확인
sudo fail2ban-client status sshd

# 특정 IP 차단 해제
sudo fail2ban-client set sshd unbanip 203.0.113.55
```

### firewalld 또는 nftables 사용 시

firewalld나 nftables를 사용하는 시스템에서는 해당 백엔드를 사용하도록 설정합니다:
```ini
[DEFAULT]
banaction = firewallcmd-multiport  # firewalld 사용 시
# 또는
banaction = nftables               # nftables 사용 시
```

---

## OpenVPN: 실전 VPN 구축

VPN은 암호화 터널을 통해 안전한 원격 접속을 제공합니다. OpenVPN은 널리 사용되는 오픈소스 VPN 솔루션입니다.

### 핵심 구성 요소

VPN 구축 시 다음 요소들을 종합적으로 고려해야 합니다:
- 암호화 터널 설정
- 올바른 라우팅 구성
- DNS 설정
- NAT(네트워크 주소 변환)
- MTU/MSS 최적화

UDP 포트 1194를 사용하는 것이 일반적으로 지연과 패킷 손실에 더 강인합니다.

### 서버 준비

```bash
# OpenVPN 및 인증서 생성 도구 설치
sudo apt update && sudo apt install -y openvpn easy-rsa

# 인증서 디렉터리 생성 및 설정
make-cadir ~/openvpn-ca
cd ~/openvpn-ca
# Easy-RSA를 사용하여 CA, 서버 및 클라이언트 인증서 생성
```

### 서버 구성 파일

`/etc/openvpn/server.conf`의 주요 설정:
```conf
port 1194
proto udp
dev tun

# 현대적인 암호화 설정
tls-version-min 1.2
tls-crypt ta.key
cipher AES-256-GCM
data-ciphers AES-256-GCM:AES-128-GCM
auth SHA256
reneg-sec 0

# VPN 서브넷 설정
server 10.8.0.0 255.255.255.0
ifconfig-pool-persist ipp.txt

# 클라이언트에 전달할 설정
push "redirect-gateway def1"          # 클라이언트의 기본 게이트웨이를 VPN으로
push "dhcp-option DNS 1.1.1.1"        # DNS 서버 지정
push "dhcp-option DNS 9.9.9.9"

# 연결 유지 설정
keepalive 10 60
persist-key
persist-tun

# 클라이언트 간 통신 허용 (필요시)
client-to-client

# 권한 및 로깅
user  nobody
group nogroup
verb 3
```

### 커널 설정 및 NAT 구성

```bash
# IP 포워딩 활성화
echo "net.ipv4.ip_forward=1" | sudo tee /etc/sysctl.d/99-vpn.conf
sudo sysctl --system

# NAT 설정 (VPN 클라이언트의 인터넷 접근 허용)
sudo iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE

# MTU 문제 방지를 위한 MSS 클램핑
sudo iptables -t mangle -A FORWARD -s 10.8.0.0/24 -p tcp --tcp-flags SYN,RST SYN \
  -j TCPMSS --clamp-mss-to-pmtu
```

### 서비스 시작

```bash
sudo systemctl enable --now openvpn@server
sudo systemctl status openvpn@server
```

### 클라이언트 구성 파일 예시

`client1.ovpn` 파일 예시 (전체 트래픽을 VPN으로 라우팅):
```conf
client
dev tun
proto udp
remote vpn.example.com 1194
resolv-retry infinite
nobind
persist-key
persist-tun

remote-cert-tls server
cipher AES-256-GCM
auth SHA256
verb 3

# 전체 트래픽을 VPN으로 라우팅
redirect-gateway def1

# DNS 설정
dhcp-option DNS 1.1.1.1
dhcp-option DNS 9.9.9.9
```

### 분할 터널링 (Split Tunneling)

사내망 트래픽만 VPN을 통하도록 하려면 `.ovpn` 파일에서 `redirect-gateway`를 제거하고 필요한 라우트만 지정합니다:
```conf
# 특정 네트워크만 VPN으로 라우팅
route 10.0.0.0 255.255.0.0
route 172.16.10.0 255.255.255.0
```

### 클라이언트별 정책

클라이언트별로 고정 IP를 할당하거나 접근 제어를 설정할 수 있습니다.

1. `server.conf`에 다음 추가:
```conf
client-config-dir ccd
```

2. 클라이언트별 구성 파일 생성:
```bash
sudo mkdir /etc/openvpn/ccd
```

3. `ccd/client1` 파일 예시:
```conf
ifconfig-push 10.8.0.10 255.255.255.0
```

### TLS 보안 강화

- `tls-crypt` 사용: 메타데이터를 암호화하여 패킷 분석을 어렵게 합니다.
- `tls-auth` 사용: DoS 공격 방지에 도움이 됩니다.
- 서버 인증서의 CN(Common Name)과 SAN(Subject Alternative Name)을 정기적으로 점검합니다.
- 키와 인증서 파일의 권한을 600으로 유지합니다.

---

## WireGuard: 현대적 대안

WireGuard는 간단한 구성과 뛰어난 성능으로 인기가 높은 VPN 솔루션입니다.

### 서버 설정

```bash
# WireGuard 설치
sudo apt install wireguard

# 키 생성
wg genkey | tee /etc/wireguard/server.key | wg pubkey > /etc/wireguard/server.pub

# 구성 파일 생성
cat <<'CONF' | sudo tee /etc/wireguard/wg0.conf
[Interface]
Address = 10.9.0.1/24
ListenPort = 51820
PrivateKey = (서버 개인키)

# IP 포워딩과 NAT 설정은 OpenVPN과 동일한 원칙 적용
SaveConfig = true
CONF

# 서비스 시작
sudo systemctl enable --now wg-quick@wg0
```

### 클라이언트 설정

```conf
[Interface]
Address = 10.9.0.2/24
PrivateKey = (클라이언트 개인키)
DNS = 1.1.1.1

[Peer]
PublicKey = (서버 공개키)
AllowedIPs = 0.0.0.0/0, ::/0   # 전체 트래픽을 VPN으로 라우팅
Endpoint = vpn.example.com:51820
PersistentKeepalive = 25
```

**분할 터널링**: `AllowedIPs`에 특정 네트워크만 지정하면 해당 트래픽만 VPN으로 라우팅됩니다.

---

## SSH 보안 강화

SSH는 원격 관리의 핵심이므로 철저한 보안 설정이 필요합니다.

`/etc/ssh/sshd_config`의 권장 설정:
```bash
# 현대적인 OpenSSH 보안 지침 예시
Protocol 2                          # SSH 프로토콜 2만 사용
Port 22                             # SSH 포트 (변경 고려)
PermitRootLogin prohibit-password   # 루트 로그인은 키 인증만 허용
PasswordAuthentication no           # 비밀번호 인증 비활성화
PubkeyAuthentication yes            # 공개키 인증 활성화
ChallengeResponseAuthentication no  # 챌린지 응답 인증 비활성화
UsePAM yes                          # PAM 사용
X11Forwarding no                    # X11 포워딩 비활성화 (필요시만)
AllowUsers devkim opsuser           # 허용 사용자 명시
ClientAliveInterval 60              # 클라이언트 활성 상태 확인 간격
ClientAliveCountMax 3               # 최대 확인 시도 횟수
MaxAuthTries 3                      # 최대 인증 시도 횟수
```

이러한 설정은 방화벽의 소스 제한 및 fail2ban과 함께 사용해야 최적의 보안을 달성할 수 있습니다.

---

## 로깅과 가시성

효과적인 보안 운영을 위해서는 적절한 로깅이 필수적입니다.

### iptables 로그 수집

`/etc/rsyslog.d/20-iptables.conf` 파일 생성:
```conf
:msg, contains, "FW DROP IN:"  -/var/log/iptables_drop.log
& stop
```
```bash
# rsyslog 재시작
sudo systemctl restart rsyslog

# 로그 모니터링
tail -f /var/log/iptables_drop.log
```

### systemd 저널을 통한 서비스 로그 모니터링

```bash
# fail2ban 로그 실시간 모니터링
journalctl -u fail2ban -f

# OpenVPN 서버 로그 모니터링
journalctl -u openvpn@server -f
```

---

## 커널 네트워크 파라미터 튜닝

시스템의 네트워크 성능과 보안을 최적화하기 위해 커널 파라미터를 조정할 수 있습니다.

`/etc/sysctl.d/99-net.conf` 파일 예시:
```conf
# SYN 쿠키 활성화 (SYN 플러드 방지)
net.ipv4.tcp_syncookies = 1

# 연결 대기 큐 크기 증가
net.core.somaxconn = 4096

# SYN 백로그 큐 크기 증가
net.ipv4.tcp_max_syn_backlog = 4096

# FIN 대기 시간 감소
net.ipv4.tcp_fin_timeout = 30

# 로컬 포트 범위 확장
net.ipv4.ip_local_port_range = 1024 65000

# PMTU 탐색 활성화 (VPN/터널 환경에 중요)
net.ipv4.ip_no_pmtu_disc = 0
```
```bash
# 변경사항 적용
sudo sysctl --system
```

---

## 실전 문제 해결 시나리오

### 시나리오 A: 외부 HTTPS 접속 불가

1. **리스닝 상태 확인**: `ss -tuln | grep ':443\>'` 명령으로 443 포트가 리스닝 중인지 확인합니다.
2. **방화벽 규칙 확인**: `sudo iptables -S` 명령으로 규칙 순서와 내용을 확인합니다(규칙 순서가 중요합니다).
3. **클라우드 보안 설정**: 클라우드 환경에서는 Security Group, 로드 밸런서 리스너, 타겟 그룹 헬스 체크를 확인합니다.
4. **패킷 흐름 분석**: `tcpdump -i eth0 port 443 -w repro.pcap` 명령으로 실제 패킷 흐름을 캡처하고 분석합니다.
5. **MTU/MSS 문제**: MTU 문제가 의심되면 MSS 클램핑을 적용해 봅니다.

### 시나리오 B: SSH 무차별 대입 공격 급증

1. **fail2ban 적용**: fail2ban을 설치하고 `bantime.increment` 옵션을 활성화합니다.
2. **소스 IP 제한**: 관리 네트워크 이외의 소스에서 SSH 접근을 제한합니다.
3. **키 인증 강제**: SSH 비밀번호 인증을 비활성화하고 키 기반 인증만 허용합니다.

### 시나리오 C: VPN 연결은 되지만 인터넷 접속 불가

1. **서버 설정 확인**: 서버의 IP 포워딩과 NAT(MASQUERADE) 설정이 올바른지 확인합니다.
2. **클라이언트 라우팅**: 클라이언트의 라우팅 설정(`redirect-gateway def1` 또는 `AllowedIPs`)을 확인합니다.
3. **DNS 설정**: 클라이언트의 DNS 설정이 올바른지, DNS 누출이 없는지 확인합니다.
4. **성능 문제**: 연결이 느리다면 MSS 클램핑을 적용하거나 PMTU 테스트를 수행합니다.

---

## 명령어 및 파일 요약

| 범주 | 핵심 요소 |
|------|-----------|
| **방화벽** | `iptables`, `iptables-save`/`iptables-restore`, `iptables-persistent` |
| **자동 차단 시스템** | `fail2ban-client`, `jail.local`, `filter.d/*`, `banaction` 설정 |
| **VPN (OpenVPN)** | `openvpn@server`, `server.conf`, 클라이언트 `.ovpn` 파일, `push` 지시어, `MASQUERADE`, `TCPMSS` |
| **VPN (WireGuard)** | `wg-quick@wg0`, `wg show`, `AllowedIPs`, `Endpoint` |
| **로깅 시스템** | iptables LOG 규칙, rsyslog 설정, `journalctl` |
| **커널 튜닝** | `sysctl` 네트워크 파라미터 |

---

## 결론

리눅스 시스템의 고급 보안 설정은 여러 계층의 방어 전략을 통합적으로 구현하는 과정입니다. iptables를 통한 "기본 거부 + 최소 허용 + 상태 추적 + 제한된 로깅"의 기본 보안 선을 구축한 후, fail2ban과 같은 자동화 도구로 반복적인 공격 시도를 완화하는 것이 현대적인 보안 운영의 핵심입니다.

VPN 구성은 단순한 암호화 터널 설정을 넘어 라우팅, DNS, NAT, MTU/MSS 최적화까지 종합적으로 고려해야 진정한 배포가 완료된 것입니다. 환경이 nftables나 firewalld 중심으로 변화하고 있더라도, 이러한 보안 원칙들은 동일하게 적용됩니다.

가장 중요한 것은 조직의 실제 서비스 로그와 트래픽 패턴을 분석하여, 이 문서에서 제시한 템플릿과 수치들을 실제 환경에 맞게 조정하는 것입니다. 보안은 단순한 기술 구현이 아닌, 지속적인 모니터링, 분석, 조정의 순환 과정임을 기억해야 합니다. 이러한 접근 방식을 통해 복잡한 네트워크 환경에서도 안전하고 견고한 리눅스 시스템을 운영할 수 있을 것입니다.