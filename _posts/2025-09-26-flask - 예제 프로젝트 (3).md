---
layout: post
title: flask - 예제 프로젝트 (3) 대시보드
date: 2025-09-26 16:25:23 +0900
category: flask
---
# 대시보드: 캐싱 + 웹소켓 실시간 알림

> 이 장은 **Flask 기반 대시보드**를 예제로, **고속 캐싱(Flask-Caching/Redis)** 과 **실시간 알림(Flask-SocketIO/Socket.IO)** 을 결합해 **저지연/고가용**으로 설계·구현하는 방법을 끝까지 정리한다.

---

## 목표 & 데모 기능

- **대시보드 위젯**
  - `KPI 카드`: 오늘 주문 수, 매출 합, 활성 사용자 수
  - `시계열 차트`: 지난 24시간 주문/매출 추이
  - `최근 이벤트` 테이블: 최근 주문/알림 목록
- **캐싱 전략**
  - Redis 기반 `Flask-Caching`
  - **Dogpile 방지**(싱글 플라이트 락) + TTL/슬라이딩 TTL + 캐시 키 네임스페이스
  - 위젯 단위 캐시: `kpi:*`, `chart:*`, `table:*`
- **실시간 알림**
  - Flask-SocketIO + Redis 메시지 큐(스케일아웃용)
  - 이벤트: `order_created`, `payment_captured` → 서버에서 캐시 갱신 → `metric_update` broadcast
  - 룸/네임스페이스: 테넌트/역할 기반 join
  - 인증: JWT 기반 핸드셰이크
- **운영 포인트**
  - Gunicorn + gevent/eventlet
  - Nginx 리버스 프록시, WebSocket 업그레이드
  - 백그라운드 작업(Celery/RQ)과의 연동

---

## 프로젝트 스캐폴딩

```
dashboard_ws/
├─ .env
├─ requirements.txt
├─ wsgi.py
├─ config.py
├─ app/
│  ├─ __init__.py
│  ├─ extensions.py
│  ├─ cache_keys.py
│  ├─ auth.py
│  ├─ sockets.py
│  ├─ services/
│  │  ├─ metrics.py
│  │  └─ lock.py
│  ├─ blueprints/
│  │  ├─ dashboard.py      # HTML 페이지(샘플)
│  │  └─ api.py            # 위젯 API (캐시 히트)
│  └─ templates/
│     └─ dashboard.html
└─ worker/
   ├─ tasks.py             # 이벤트/집계 워커(옵션: Celery/RQ)
   └─ __init__.py
```

### requirements

```txt
Flask==3.0.3
Flask-SQLAlchemy==3.1.1
Flask-Migrate==4.0.7

Flask-Caching==2.3.0
redis==5.0.8

flask-socketio==5.3.6
python-socketio[client]==5.11.3
eventlet==0.35.2     # 또는 gevent==24.2.1

PyJWT==2.9.0
marshmallow==3.22.0
httpx==0.27.2

# 큐 & 워커

celery==5.4.0
# 또는 rq==1.16.2 rq-scheduler==0.13.1

```

### .env (개발 예)

```env
FLASK_APP=wsgi:app
FLASK_ENV=development
SECRET_KEY=dev-secret-change-me
DATABASE_URL=sqlite:///dev.db

REDIS_URL=redis://localhost:6379/0
CACHE_DEFAULT_TIMEOUT=30

JWT_SECRET=dev-jwt-secret
SOCKET_MESSAGE_QUEUE=redis://localhost:6379/1
```

---

## 설정 & 확장

### config.py

```python
import os, datetime

class BaseConfig:
    SECRET_KEY = os.getenv("SECRET_KEY", "change-me")
    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL", "sqlite:///app.db")
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379/0")
    CACHE_TYPE = "RedisCache"
    CACHE_REDIS_URL = REDIS_URL
    CACHE_DEFAULT_TIMEOUT = int(os.getenv("CACHE_DEFAULT_TIMEOUT", "30"))  # 초

    SOCKET_MESSAGE_QUEUE = os.getenv("SOCKET_MESSAGE_QUEUE", "redis://localhost:6379/1")

    JWT_SECRET = os.getenv("JWT_SECRET", "change-me")
    JWT_ALG = "HS256"
    JWT_EXPIRES = datetime.timedelta(hours=6)

class DevelopmentConfig(BaseConfig):
    DEBUG = True

class ProductionConfig(BaseConfig):
    DEBUG = False

def get_config():
    env = os.getenv("FLASK_ENV", "production").lower()
    return DevelopmentConfig if env.startswith("dev") else ProductionConfig
```

### app/extensions.py

```python
from flask_sqlalchemy import SQLAlchemy
from flask_caching import Cache
from flask_socketio import SocketIO

db = SQLAlchemy(session_options={"autoflush": False, "expire_on_commit": False})
cache = Cache()
socketio = SocketIO(
    cors_allowed_origins="*",           # 운영에서는 제한!
    message_queue=None,                 # create_app에서 설정
    async_mode="eventlet",              # or "gevent"
    logger=False, engineio_logger=False
)
```

### app/__init__.py

```python
from flask import Flask
from .extensions import db, cache, socketio
from config import get_config

def create_app():
    app = Flask(__name__)
    app.config.from_object(get_config())

    db.init_app(app)
    cache.init_app(app, config={
        "CACHE_TYPE": app.config["CACHE_TYPE"],
        "CACHE_REDIS_URL": app.config["CACHE_REDIS_URL"],
        "CACHE_DEFAULT_TIMEOUT": app.config["CACHE_DEFAULT_TIMEOUT"],
        "CACHE_KEY_PREFIX": "dash:"
    })
    # 소켓 메시지 큐(스케일아웃 시 필수)
    socketio.message_queue = app.config["SOCKET_MESSAGE_QUEUE"]
    socketio.init_app(app)

    # 블루프린트/소켓 등록
    from .blueprints.dashboard import bp as dash_bp
    from .blueprints.api import bp as api_bp
    app.register_blueprint(dash_bp)
    app.register_blueprint(api_bp)

    from .sockets import register_socket_handlers
    register_socket_handlers(app)

    return app
```

### wsgi.py

```python
from app import create_app
from app.extensions import socketio

app = create_app()

if __name__ == "__main__":
    # 개발용. 운영은 gunicorn + eventlet/gevent 참고 섹션
    socketio.run(app, host="0.0.0.0", port=5000)
```

---

## 캐시 키 네임스페이스

### app/cache_keys.py

```python
NS = {
    "kpi": "kpi",          # KPI 카드
    "chart": "chart",      # 시계열 차트
    "table": "table",      # 최근 이벤트
    "ver": "ver",          # 버전(캐시 무효화 전파용)
}

def ns_key(ns: str, *parts):
    # dash:<ns>:<parts...>:v<version>
    # 버전은 별도 키에 저장, 키 조회 시 suffix로 붙여 “무효화 일괄화”
    return f"{ns}:{':'.join(parts)}"

def ver_key(ns: str, tenant_id: str):
    return f"{NS['ver']}:{ns}:{tenant_id}"

def with_version(cache, raw_key: str, tenant_id: str, default_ver="1"):
    # 버전 읽어서 suffix로 붙여준다
    ver = cache.get(ver_key(raw_key.split(':',1)[0], tenant_id)) or default_ver
    return f"{raw_key}:v{ver}"

def bump_version(cache, ns: str, tenant_id: str):
    k = ver_key(ns, tenant_id)
    try:
        v = int(cache.get(k) or "1")
    except ValueError:
        v = 1
    cache.set(k, str(v+1), timeout=0)  # 0=무기한
    return v+1
```

> **버전 키**를 사용하면 **대상 네임스페이스 전체의 캐시를 O(1)로 무효화**할 수 있다(키 스캔 불필요).

---

## 싱글 플라이트 락(Dogpile 방지)

### app/services/lock.py

```python
import time, contextlib
from redis import Redis
from flask import current_app

@contextlib.contextmanager
def single_flight(lock_name: str, ttl=10, wait_timeout=5):
    """Redis 분산락. 캐시 미스 시 재계산을 한 프로세스만 수행."""
    r = Redis.from_url(current_app.config["REDIS_URL"])
    lock = r.lock(f"lock:{lock_name}", timeout=ttl, blocking_timeout=wait_timeout)
    acquired = lock.acquire(blocking=True)
    try:
        yield acquired
    finally:
        if acquired:
            try: lock.release()
            except Exception: pass
```

---

## 메트릭 서비스 (DB→캐시→API)

### app/services/metrics.py

```python
from datetime import datetime, timedelta, timezone
from sqlalchemy import func, select
from flask import current_app
from ..extensions import db, cache
from ..cache_keys import ns_key, with_version
from .lock import single_flight

UTC = timezone.utc

# 예시용 테이블(여기선 가짜 쿼리 함수로 대체 가능)
# orders(id, tenant_id, amount, status, created_at)
# user_sessions(id, tenant_id, user_id, last_seen_at)

def now():
    return datetime.now(UTC)

def _query_kpi(tenant_id: str):
    """실제 DB 집계 쿼리(여기선 샘플)"""
    # 가상 쿼리 예시(ORM 사용시):
    # today = now().date()
    # orders_today = db.session.execute(select(func.count()).select_from(Order).where(...)).scalar()
    return {
        "orders_today": 123,
        "revenue_today": 4567890,
        "active_users": 42,
        "as_of": now().isoformat()
    }

def get_kpi(tenant_id: str, ttl=20):
    base_key = ns_key("kpi", tenant_id)
    key = with_version(cache, base_key, tenant_id)
    data = cache.get(key)
    if data:
        return data

    # Dogpile 방지: 재계산 단일화
    with single_flight(f"kpi:{tenant_id}", ttl=10, wait_timeout=5) as leader:
        data = cache.get(key)
        if data:  # 잠금 기다리는 동안 선행자 갱신한 경우
            return data
        # 실제 비용 큰 쿼리 수행
        data = _query_kpi(tenant_id)
        cache.set(key, data, timeout=ttl)
        return data

def _query_chart(tenant_id: str, hours=24):
    end = now().replace(minute=0, second=0, microsecond=0)
    start = end - timedelta(hours=hours-1)
    # 가짜 데이터
    points = []
    for i in range(hours):
        t = start + timedelta(hours=i)
        points.append({"t": t.isoformat(), "orders": i % 7 + 3, "revenue": (i * 1234) % 9000 + 1000})
    return {"from": start.isoformat(), "to": end.isoformat(), "points": points}

def get_chart(tenant_id: str, ttl=60):
    base_key = ns_key("chart", tenant_id, "24h")
    key = with_version(cache, base_key, tenant_id)
    data = cache.get(key)
    if data:
        return data
    with single_flight(f"chart:{tenant_id}", ttl=15):
        data = cache.get(key)
        if data:
            return data
        data = _query_chart(tenant_id)
        cache.set(key, data, timeout=ttl)
        return data

def _query_recent_events(tenant_id: str, limit=20):
    # 가짜 이벤트 목록
    out = []
    for i in range(limit):
        out.append({"id": 1000+i, "type": "order_created", "amount": 1000+i*10, "ts": now().isoformat()})
    return out

def get_recent_events(tenant_id: str, ttl=15):
    base_key = ns_key("table", tenant_id, "recent")
    key = with_version(cache, base_key, tenant_id)
    data = cache.get(key)
    if data:
        return data
    with single_flight(f"table:{tenant_id}", ttl=8):
        if cache.get(key):
            return cache.get(key)
        data = _query_recent_events(tenant_id)
        cache.set(key, data, timeout=ttl)
        return data
```

---

## & 테넌트 추출

### app/auth.py

```python
import jwt
from datetime import datetime, timezone, timedelta
from flask import current_app, request

def issue_token(user_id: str, tenant_id: str, role="user"):
    payload = {
        "sub": user_id,
        "tenant": tenant_id,
        "role": role,
        "iat": int(datetime.now(timezone.utc).timestamp()),
        "exp": int((datetime.now(timezone.utc) + current_app.config["JWT_EXPIRES"]).timestamp())
    }
    return jwt.encode(payload, current_app.config["JWT_SECRET"], algorithm=current_app.config["JWT_ALG"])

def verify_token(token: str):
    return jwt.decode(token, current_app.config["JWT_SECRET"], algorithms=[current_app.config["JWT_ALG"]])

def current_tenant() -> str:
    # API/소켓 공통으로 사용: 헤더 또는 쿼리에서 토큰 추출
    auth = request.headers.get("Authorization", "")
    if auth.startswith("Bearer "):
        tok = auth.split(" ", 1)[1]
        payload = verify_token(tok)
        return payload["tenant"]
    # 미인증 허용하는 공개 위젯이라면 기본 'public'
    return "public"
```

---

## API 블루프린트 (캐시 히트)

### app/blueprints/api.py

```python
from flask import Blueprint, jsonify, request
from ..services.metrics import get_kpi, get_chart, get_recent_events
from ..auth import current_tenant

bp = Blueprint("api", __name__, url_prefix="/api")

@bp.get("/widgets/kpi")
def api_kpi():
    tenant_id = current_tenant()
    data = get_kpi(tenant_id)
    return jsonify(data)

@bp.get("/widgets/chart")
def api_chart():
    tenant_id = current_tenant()
    return jsonify(get_chart(tenant_id))

@bp.get("/widgets/recent")
def api_recent():
    tenant_id = current_tenant()
    return jsonify(get_recent_events(tenant_id))
```

---

## 소켓 핸들러 (실시간 알림)

### app/sockets.py

```python
from flask import request, g
from .extensions import socketio
from .auth import verify_token
from .services.metrics import get_kpi
from .cache_keys import bump_version

NAMESPACE = "/ws"

def register_socket_handlers(app):
    @socketio.on("connect", namespace=NAMESPACE)
    def on_connect():
        # 인증(JWT)
        token = request.args.get("token")
        if not token:
            return False
        try:
            payload = verify_token(token)
        except Exception:
            return False
        g.user_id = payload["sub"]
        g.tenant_id = payload["tenant"]
        room = f"tenant:{g.tenant_id}"
        socketio.join_room(room, namespace=NAMESPACE)
        # 초기 KPI push (선택)
        socketio.emit("metric_update", {"kpi": get_kpi(g.tenant_id)}, room=request.sid, namespace=NAMESPACE)

    @socketio.on("disconnect", namespace=NAMESPACE)
    def on_disconnect():
        # 자동으로 room 정리됨 (필요 시 명시적 leave_room)
        pass

    # 서버 내부 이벤트(워커/관리툴)에서 호출: 캐시 무효화 후 broadcast
    @app.route("/internal/events/order_created", methods=["POST"])
    def order_created_event():
        # JSON: {"tenant":"acme","order_id":...,"amount":...}
        payload = request.get_json() or {}
        tenant = payload.get("tenant", "public")
        # 캐시 버전 bump → 다음 API 히트 시 새 값 계산
        bump_version(app.extensions["cache"], "kpi", tenant)
        bump_version(app.extensions["cache"], "chart", tenant)
        bump_version(app.extensions["cache"], "table", tenant)
        # 선택: 즉시 계산해서 push (핫패스)
        kpi_now = get_kpi(tenant)
        socketio.emit("metric_update", {"kpi": kpi_now}, room=f"tenant:{tenant}", namespace=NAMESPACE)
        # 최근 이벤트 테이블 항목도 같이 push 가능
        return {"ok": True}
```

> 포인트
> - 클라이언트는 `io("/ws", { query: { token } })` 형태로 연결한다.
> - 다중 프로세스/서버에서 broadcast 동기화를 위해 `SocketIO(message_queue=Redis)` 를 사용했다.

---

## 대시보드 페이지 (HTML + Socket.IO 클라이언트)

### app/blueprints/dashboard.py

```python
from flask import Blueprint, render_template, request
from ..auth import issue_token

bp = Blueprint("dashboard", __name__)

@bp.get("/")
def index():
    # 데모용: 쿼리로 tenant/user 지정
    tenant = request.args.get("tenant", "public")
    user = request.args.get("user", "alice")
    token = issue_token(user, tenant, role="admin")
    return render_template("dashboard.html", token=token, tenant=tenant)
```

### app/templates/dashboard.html

{% raw %}
```html
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>대시보드: 캐싱 + 웹소켓</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
  body{font-family:system-ui,Segoe UI,Roboto;max-width:1100px;margin:0 auto;padding:1rem;}
  .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:1rem}
  .card{border:1px solid #ddd;border-radius:10px;padding:1rem;background:#fff;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .muted{color:#666}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #eee;padding:.5rem;text-align:left}
  #status{font-size:.9rem}
  </style>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
</head>
<body>
  <h1>대시보드</h1>
  <p class="muted">테넌트: <span id="tenant"></span> · <span id="status">연결 준비...</span></p>

  <section class="grid">
    <div class="card">
      <h3>오늘 주문 수</h3>
      <div id="kpi-orders" style="font-size:2rem">-</div>
      <div class="muted" id="kpi-asof"></div>
    </div>
    <div class="card">
      <h3>오늘 매출 합</h3>
      <div id="kpi-revenue" style="font-size:2rem">-</div>
      <div class="muted">(원)</div>
    </div>
    <div class="card">
      <h3>활성 사용자</h3>
      <div id="kpi-active" style="font-size:2rem">-</div>
    </div>
  </section>

  <section class="card" style="margin-top:1rem">
    <h3>최근 이벤트</h3>
    <table>
      <thead><tr><th>ID</th><th>유형</th><th>금액</th><th>시각</th></tr></thead>
      <tbody id="recent-body"></tbody>
    </table>
  </section>

  <script>
  const TOKEN = "{{ token }}";
  const TENANT = "{{ tenant }}";
  document.getElementById('tenant').innerText = TENANT;

  // 초기 로드: 캐시에서 빠르게 가져오기
  async function fetchJSON(url){
    const res = await fetch(url, { headers: { Authorization: `Bearer ${TOKEN}` }});
    if(!res.ok) throw new Error(await res.text());
    return res.json();
  }

  function renderKPI(kpi){
    if(!kpi) return;
    document.getElementById('kpi-orders').innerText = kpi.orders_today ?? '-';
    document.getElementById('kpi-revenue').innerText = kpi.revenue_today ?? '-';
    document.getElementById('kpi-active').innerText = kpi.active_users ?? '-';
    document.getElementById('kpi-asof').innerText = kpi.as_of ? `as of ${kpi.as_of}` : '';
  }

  function renderRecent(rows){
    const tbody = document.getElementById('recent-body');
    tbody.innerHTML = '';
    (rows||[]).forEach(r=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${r.id}</td><td>${r.type}</td><td>${r.amount}</td><td>${r.ts}</td>`;
      tbody.appendChild(tr);
    });
  }

  async function initialLoad(){
    try{
      const [kpi, recent] = await Promise.all([
        fetchJSON('/api/widgets/kpi'),
        fetchJSON('/api/widgets/recent')
      ]);
      renderKPI(kpi); renderRecent(recent);
    }catch(e){ console.error(e); }
  }

  // WebSocket 연결
  function connectWS(){
    const socket = io("/ws", { transports:["websocket"], query: { token: TOKEN }});
    const statusEl = document.getElementById('status');

    socket.on('connect', ()=>{
      statusEl.innerText = "연결됨";
    });
    socket.on('disconnect', (reason)=>{
      statusEl.innerText = "연결 끊김: " + reason;
    });
    socket.on('reconnect_attempt', ()=> statusEl.innerText = "재연결 시도...");
    socket.on('metric_update', (payload)=>{
      if(payload.kpi) renderKPI(payload.kpi);
      if(payload.recent) renderRecent(payload.recent);
    });
  }

  (async function(){
    await initialLoad();
    connectWS();
  })();
  </script>
</body>
</html>
```
{% endraw %}

> UX 전략
> - **초기 로드**: REST로 **캐시 히트** → 즉시 렌더
> - **실시간 업데이트**: 소켓으로 **변경분 push** → KPI/최근 이벤트만 부분 업데이트

---

## 이벤트 인입 → 캐시 갱신 → 브로드캐스트

### 웹훅/관리툴/주문시스템에서 콜

- `POST /internal/events/order_created` (이미 위에서 구현)
- 실제 운영에서는 **비밀 서명 검증**(HMAC) 또는 내부 네트워크 보호 필요

### 워커 연계(옵션: Celery)

`worker/tasks.py`:

```python
from celery import Celery
import os
from app import create_app
from app.extensions import socketio, cache
from app.services.metrics import get_kpi, get_recent_events
from app.cache_keys import bump_version

celery = Celery(__name__, broker=os.getenv("REDIS_URL", "redis://localhost:6379/0"))
flask_app = create_app()

@celery.task
def process_order_event(tenant: str, order_id: int, amount: int):
    with flask_app.app_context():
        # 캐시 무효화
        bump_version(cache, "kpi", tenant)
        bump_version(cache, "chart", tenant)
        bump_version(cache, "table", tenant)
        # 즉시 push (선택)
        kpi = get_kpi(tenant)
        recent = get_recent_events(tenant)
        socketio.emit("metric_update", {"kpi": kpi, "recent": recent}, room=f"tenant:{tenant}", namespace="/ws")
```

> **SocketIO Redis 메시지 큐** 덕분에, **웹/워커 프로세스**가 서로 다른 컨테이너여도 동일 룸에 broadcast 가능.

---

## 운영: Gunicorn + gevent/eventlet

### eventlet

```bash
pip install eventlet
gunicorn -k eventlet -w 1 -b 0.0.0.0:5000 wsgi:app
```

### gevent

```bash
pip install gevent
gunicorn -k gevent -w 2 -b 0.0.0.0:5000 wsgi:app
```

> 프로덕션에서는 **멀티 워커** + **Redis message_queue** 필수.
> 로드밸런서/프록시 레벨에서 **WebSocket 업그레이드** 허용 필요.

---

## Nginx 리버스 프록시 설정(핵심만)

```
upstream app_ws {
    server app:5000; # gunicorn 컨테이너
}

server {
    listen 80;
    server_name dashboard.local;

    location /ws/ {
        proxy_pass http://app_ws/ws/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Host $host;
        proxy_read_timeout 75s;
    }

    location / {
        proxy_pass http://app_ws/;
        proxy_set_header Host $host;
    }
}
```

---

## 캐싱 전략 심화 정리

1) **TTL 설계**
   - KPI: 10–30s
   - 차트(24h): 60–120s (집계 비용이 크면 더 길게)
   - 이벤트 테이블: 10–20s
2) **Dogpile 방지**: `single_flight` 락으로 **오직 1명만 재계산**
3) **버전 키**: 외부 이벤트 → `bump_version(ns, tenant)` → 다음 히트부터 새 데이터
   - 즉시 반영이 꼭 필요하면 **계산 후 push**(핫패스)
4) **네임스페이스 키**: `dash:kpi:<tenant>:v<ver>`
   - 테넌트 분리, 향후 **멀티테넌시**와 자연스레 호환

---

## 실시간 알림 설계 포인트

- **인증**: 핸드셰이크 쿼리의 JWT는 TLS 하에서만. 만료 시 **자동 재연결 + 새 토큰**(클라이언트 전략)
- **룸/네임스페이스**: `tenant:<id>` 단위로 join → 브로드캐스트 범위 축소
- **역할 제어**: `role` 클레임 기반 특정 이벤트만 전송 가능
- **백프레셔**: 클라이언트 측 이벤트 처리 비용이 크면 **배치 이벤트**(여러 변경을 묶어서 보냄)
- **재시도/연결 품질**: Socket.IO 기본 재시도 로직 이용, 상태 UI 제공

---

## 테스트(요약)

### API 캐시 히트 테스트

```python
# tests/test_cache_api.py

def test_kpi_cache_hit(client, monkeypatch):
    # 초기 호출
    r1 = client.get("/api/widgets/kpi", headers={"Authorization":"Bearer "+TOKEN})
    assert r1.status_code == 200
    d1 = r1.get_json()
    # 두 번째 호출: 같은 내용(캐시)
    r2 = client.get("/api/widgets/kpi", headers={"Authorization":"Bearer "+TOKEN})
    d2 = r2.get_json()
    assert d1 == d2
```

### 소켓 연결 테스트(간단 스케치)

```python
# tests/test_socket.py

import socketio

def test_ws_connect(live_server):
    sio = socketio.Client()
    sio.connect(live_server.url + "/ws", transports=["websocket"], auth=None, headers={}, query_string={"token": TOKEN})
    assert sio.connected
    sio.disconnect()
```

> 실제 테스트에서는 **Flask-SocketIO TestClient** 또는 **pytest + eventlet/gevent** 환경을 구성할 수 있다.

---

## 보안 체크리스트

- **JWT 시크릿/수명**: 짧게, 회전(rotate) 가능하게
- **CORS**: API는 신뢰 오리진만 허용
- **WS 업그레이드 헤더**: 프록시에서 **Host/Upgrade/Connection** 헤더 전달
- **레이트 리미팅**: `/internal/events/*` 는 내부망/서명 검증 + 레이트 리밋
- **캐시 키 오염 방지**: 키 구성 시 사용자 입력을 **화이트리스트 처리**
- **민감 정보**: 실시간 페이로드는 최소화(PII 로그 마스킹, 11장 정책 준수)

---

## 장애 대응(운영 팁)

- **Redis 장애**: 캐시 미사용 모드로 폴백(예: `cache.get` 실패 시 DB 직접 조회 + 짧은 TTL set 시도)
- **WS 중단**: 클라이언트 자동 재연결 + 폴백(주기적 REST pull)
- **스톰 방지**: 대량 이벤트 시 **버전 bump만** 하고 실제 계산은 **첫 히트에서** 수행
- **워커/웹 불일치**: SocketIO message_queue/버전키로 **일관성** 확보

---

## “붙여넣기” 스타터 명령

### 실행

```bash
# 의존성

pip install -r requirements.txt

# Redis 준비 (로컬)

redis-server

# 앱 기동 (개발)

python wsgi.py
# 또는

gunicorn -k eventlet -w 1 -b 0.0.0.0:5000 wsgi:app
```

### 테스트용 토큰 발급

```python
# Python REPL

from app import create_app
from app.auth import issue_token
app = create_app()
with app.app_context():
    print(issue_token("u1","public","admin"))
```

브라우저: `http://localhost:5000/?tenant=public&user=u1` 로 접속(서버가 내부적으로 토큰 생성하여 템플릿에 삽입).

### 샘플 이벤트 전송

```bash
curl -X POST http://localhost:5000/internal/events/order_created \
  -H 'Content-Type: application/json' \
  -d '{"tenant":"public","order_id":12345,"amount":9900}'
```

→ 대시보드 KPI/최근 이벤트가 **즉시 갱신**되는 것을 확인.

---

## 확장 아이디어

- **멀티 위젯 타일레이아웃** + 사용자가 **순서/크기 커스터마이징**
- **권한 기반 데이터 가리기**(부서/매장별 룸 분리)
- **에지 캐시**(Cloudflare Workers)로 공개 차트 API 가속
- **오프라인 리플레이**: 연결 끊김 동안의 이벤트를 **배치로 재생**
- **알림 규칙 엔진**: 임계값/이상 탐지 → WebSocket + Email/Slack 동시에 푸시
- **프런트 프레임워크**: React/Vite로 리팩터 → Socket.IO 클라이언트 유지

---

## 마무리

이 예제는 **대시보드 성능의 핵심인 캐싱**과 **즉시성이 핵심인 실시간 알림**을 **Flask + Redis + Socket.IO** 로 단단히 결합하는 방법을 다뤘다.

- 위젯 단위 **TTL 캐시 + 버전 키 무효화 + Dogpile 방지**로 **안정적인 응답 시간**을 확보하고,
- 외부 이벤트/워커로부터 **버전 bump → 즉시 브로드캐스트**를 통해 **초저지연 업데이트**를 구현했으며,
- 운영 레벨에서는 **Gunicorn + eventlet/gevent + Redis 메시지 큐**로 **수평 확장** 가능하게 만들었다.
