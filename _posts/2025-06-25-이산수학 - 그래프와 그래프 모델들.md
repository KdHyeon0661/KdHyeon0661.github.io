---
layout: post
title: 이산수학 - 그래프와 그래프 모델들
date: 2025-06-25 23:20:23 +0900
category: 이산수학
---
# 그래프와 그래프 모델들 (Graphs and Graph Models)

## 0) 왜 그래프인가?

그래프 \(G=(V,E)\)는 **사물(정점)**과 **연결(간선)**을 수학적으로 모델링한다.  
네트워크, 의존성, 흐름, 경로, 군집, 순서 등 **관계성 문제**는 대부분 그래프로 환원된다.

---

## 1) 정의와 기초 용어

### 1.1 그래프의 정의

$$
G=(V,E)
$$

- \(V\): 정점(vertex)들의 집합  
- \(E\): 간선(edge)들의 집합

**무방향 그래프**:  
$$E \subseteq \big\{\{u,v\}\mid u,v\in V,\ u\neq v\big\}$$

**방향 그래프(digraph)**:  
$$E \subseteq \big\{(u,v)\mid u,v\in V\big\}$$

> 자기 루프, 중복 간선 허용 여부에 따라 **단순(simple)/멀티(multi)/유사(pseudo)** 그래프로도 분류.

---

### 1.2 그래프의 기본 용어

| 용어 | 무방향 | 방향 |
|---|---|---|
| 차수(degree) | 정점에 닿는 간선 수 \(\deg(v)\) | 진입차수 \(\deg^-(v)\), 진출차수 \(\deg^+(v)\) |
| 경로(path) | 정점을 중복 없이 잇는 간선 열 | 동일 |
| 사이클(cycle) | 시작=끝인 닫힌 경로 | 유향에서는 directed cycle |
| 연결성 | 연결 그래프: 임의 두 점 간 경로 존재 | **강연결(SCC)**: 서로 도달, **약연결**: 무향화시 연결 |
| 트리 | 사이클 없는 연결 무방향 그래프 | 유향 트리는 “arborescence” |

**악수 정리** (무방향):
$$
\sum_{v\in V}\deg(v)=2|E|
$$

**유향 합차수**:
$$
\sum_{v}\deg^-(v)=\sum_{v}\deg^+(v)=|E|
$$

---

## 2) 그래프의 표현 (자료구조)

### 2.1 인접 행렬 (Adjacency Matrix)

- 크기 \(n\times n\)의 0/1(또는 가중) 행렬 \(A\)
- 공간 \(O(n^2)\), 간선 존재 확인 \(O(1)\)
- 밀집 그래프( \(m\approx n^2\) )에서 유리

**가중 그래프**는 \(\infty\) 또는 0을 비간선으로 둔다.

### 2.2 인접 리스트 (Adjacency List)

- 각 정점에 이웃 리스트 저장
- 공간 \(O(n+m)\), 탐색 \(O(n+m)\)
- 희소 그래프에 유리, 대부분의 알고리즘 기본 표현

### 2.3 간선 리스트 / CSR

- 간선 집합만 저장하거나, 대규모에서는 **CSR(Compressed Sparse Row)** 활용
- 수치/그래프 연산(특히 GPU)에서 효율

**요약 표**

| 연산 | 인접 행렬 | 인접 리스트 |
|---|---:|---:|
| 간선 존재 확인 | \(O(1)\) | 평균 \(O(\deg u)\) |
| 모든 이웃 열거 | \(O(n)\) | \(O(\deg u)\) |
| 공간 | \(O(n^2)\) | \(O(n+m)\) |

---

## 3) 그래프의 종류 & 모델링 포인트

- **방향성**: 팔로우/의존성/상태전이는 **유향**, 친구/상호연결은 **무향**.
- **가중치**: 비용/거리/용량/확률 등. 최단경로·흐름·균형 문제에 필수.
- **멀티그래프**: 중복 간선(예: 여러 통신 링크).
- **평면성**: 회로·PCB, 지리적 지도—교차 없는 임베딩 중요.
- **DAG**: 사이클 없는 유향 그래프—**위상 정렬**, 일정·빌드·데이터 라인에 핵심.
- **이분 그래프**: \(V=L\cup R\), \(E\subseteq L\times R\)—매칭/할당/추천.

---

## 4) 대표 그래프 모델 (현실 매핑)

1) **컴퓨터 네트워크**: 라우터/스위치=정점, 링크=간선(가중: 지연/대역/손실)  
   → 라우팅(최단경로), 내고장성(연결성), 최대유량(트래픽)

2) **사회 연결망**: 사용자=정점, 관계=간선(팔로우: 유향)  
   → 군집, 중심성, 전염/확산 모델

3) **지식 그래프**: 엔터티=정점, 관계=유향 레이블 간선  
   → 삼중항 (s, p, o), 경로 질의, 링크 예측

4) **도로망**: 교차로=정점, 도로=간선(가중: 거리/시간/통행료)  
   → 다익스트라/A*, 교통 시뮬, k-최단경로

5) **작업흐름/빌드 그래프**: 작업=정점, 선후=유향  
   → DAG 위상 정렬, 크리티컬 패스

6) **상태 전이**: 상태=정점, 이벤트 전이=유향  
   → DFA/NFA, 모델체킹(도달·사이클)

---

## 5) 기본 정리·판정

### 5.1 오일러/해밀토니안

- **오일러 경로/회로**(모든 간선을 정확히 1회)
  - 무방향:  
    - 회로: 모든 정점의 차수 짝수  
    - 경로: 홀수 차수 정점 2개
- **해밀토니안**(모든 정점을 1회)  
  - 일반 판정은 NP-완전. 충분조건(Dirac/Ore)은 참고용.

### 5.2 평면 그래프 & 오일러 공식(연결 평면 그래프)

$$
|V|-|E|+|F|=2
$$

- Kuratowski: \(K_5\), \(K_{3,3}\)의 subdivision을 포함하면 비평면.

### 5.3 이분 그래프 판정

- **홀수 길이 사이클**이 없으면 이분, 있으면 비이분.

---

## 6) 탐색 & 기본 알고리즘 (Python)

> 예제 그래프는 인접 리스트를 사용한다.

### 6.1 BFS (최단 간선 수, 레벨 탐색)

```python
from collections import deque

def bfs(adj, s):
    """
    adj: dict[u] = list of v
    s: source
    return: dist, parent
    """
    INF = 10**18
    dist = {u: INF for u in adj}
    parent = {u: None for u in adj}
    dist[s] = 0
    q = deque([s])
    while q:
        u = q.popleft()
        for v in adj[u]:
            if dist[v] == INF:
                dist[v] = dist[u] + 1
                parent[v] = u
                q.append(v)
    return dist, parent

# 예제
adj = {0:[1,2], 1:[0,3], 2:[0,3], 3:[1,2]}
d,p = bfs(adj, 0)
print(d)  # {0:0, 1:1, 2:1, 3:2}
```

### 6.2 DFS (시간·트리/역간선 분류, 사이클 탐지)

```python
def dfs_edges(adj):
    """
    간선 분류(유향/무향 모두 사용 가능).
    WHITE=0, GRAY=1, BLACK=2
    """
    color = {u:0 for u in adj}
    parent = {u:None for u in adj}
    entry, exit_ = {}, {}
    time = 0
    types = []  # (u,v,type)
    def dfs(u):
        nonlocal time
        color[u] = 1; time += 1; entry[u] = time
        for v in adj[u]:
            if color[v] == 0:
                parent[v] = u
                types.append((u,v,'tree'))
                dfs(v)
            elif color[v] == 1:
                types.append((u,v,'back'))
            else:
                # color[v] == 2
                types.append((u,v,'cross/forward'))
        color[u] = 2; time += 1; exit_[u] = time
    for u in adj:
        if color[u] == 0: dfs(u)
    return types, entry, exit_, parent
```

- 유향에서 **back edge**가 있으면 사이클 존재.

### 6.3 위상 정렬 (DAG)

```python
from collections import deque

def topo_sort_kahn(adj):
    indeg = {u:0 for u in adj}
    for u in adj:
        for v in adj[u]:
            indeg[v] = indeg.get(v,0) + 1
    q = deque([u for u in adj if indeg[u]==0])
    order = []
    while q:
        u = q.popleft()
        order.append(u)
        for v in adj[u]:
            indeg[v] -= 1
            if indeg[v]==0: q.append(v)
    if len(order) != len(adj):  # 사이클
        return None
    return order

# 예: 5->{2,0}, 4->{0,1}, 2->{3}, 3->{1}
adj = {5:[2,0], 4:[0,1], 2:[3], 3:[1], 1:[], 0:[]}
print(topo_sort_kahn(adj))  # 예: [4,5,0,2,3,1] 등
```

---

## 7) 최단경로 (Single-Source / All-Pairs)

### 7.1 무가중/가중 비음수: BFS / 다익스트라

```python
import heapq

def dijkstra(adj_w, s):
    """
    adj_w: dict[u] = list of (v,w), w>=0
    return: dist, parent
    """
    INF = 10**18
    dist = {u: INF for u in adj_w}
    parent = {u: None for u in adj_w}
    dist[s] = 0
    pq = [(0,s)]
    while pq:
        d,u = heapq.heappop(pq)
        if d!=dist[u]: continue
        for v,w in adj_w[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v]=nd; parent[v]=u
                heapq.heappush(pq,(nd,v))
    return dist, parent
```

> **주의**: 음수 가중치가 있으면 다익스트라는 **부정확**.

### 7.2 음수 가중치 허용: 벨만–포드 (음수 사이클 검출)

```python
def bellman_ford(n, edges, s):
    """
    n: #nodes (0..n-1), edges: list of (u,v,w)
    return: (ok, dist, parent), ok=False면 음수사이클 존재
    """
    INF = 10**18
    dist = [INF]*n; parent = [-1]*n
    dist[s] = 0
    # n-1번 완화
    for _ in range(n-1):
        updated = False
        for u,v,w in edges:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w; parent[v] = u; updated=True
        if not updated: break
    # 음수 사이클 검사
    for u,v,w in edges:
        if dist[u] + w < dist[v]:
            return (False, dist, parent)
    return (True, dist, parent)
```

### 7.3 DAG 최단경로 (음수 허용, 사이클 없음)

- 위상 정렬 후 그 순서대로 간선 완화 → \(O(n+m)\)

### 7.4 모든 쌍 최단경로: 플로이드–워셜

$$
\text{for }k,i,j:\ D[i][j]=\min(D[i][j],\ D[i][k]+D[k][j])
$$

```python
def floyd_warshall(W):
    """
    W: n*n 가중 행렬 (없음=INF, 대각=0)
    """
    n=len(W)
    D=[row[:] for row in W]
    for k in range(n):
        for i in range(n):
            dik=D[i][k]
            if dik==float('inf'): continue
            for j in range(n):
                nd=dik+ D[k][j]
                if nd< D[i][j]:
                    D[i][j]=nd
    return D
```

---

## 8) 스패닝 트리 & MST

### 8.1 정의

- **스패닝 트리**: 연결 무방향 그래프의 모든 정점을 포함, 간선 \(n-1\), 사이클 없음.
- **최소 신장 트리(MST)**: 가중치 합 최소 스패닝 트리.

### 8.2 크루스칼 (정렬 + 유니온파인드)

```python
class DSU:
    def __init__(self, n):
        self.p=list(range(n)); self.r=[0]*n
    def find(self,x):
        while x!=self.p[x]:
            self.p[x]=self.p[self.p[x]]; x=self.p[x]
        return x
    def union(self,a,b):
        a=self.find(a); b=self.find(b)
        if a==b: return False
        if self.r[a]<self.r[b]: a,b=b,a
        self.p[b]=a
        if self.r[a]==self.r[b]: self.r[a]+=1
        return True

def kruskal(n, edges):
    """
    edges: (w,u,v)
    return: total_weight, mst_edges
    """
    dsu=DSU(n); total=0; mst=[]
    for w,u,v in sorted(edges):
        if dsu.union(u,v):
            total+=w; mst.append((u,v,w))
    return total, mst
```

### 8.3 프림 (우선순위 큐, 연결 그래프)

```python
import heapq

def prim(adj_w, start=0):
    """
    adj_w: dict[u] = list of (v,w)
    """
    visited=set([start])
    pq=[]
    for v,w in adj_w[start]: heapq.heappush(pq,(w,start,v))
    total=0; mst=[]
    while pq and len(visited)<len(adj_w):
        w,u,v=heapq.heappop(pq)
        if v in visited: continue
        visited.add(v); total+=w; mst.append((u,v,w))
        for x,wx in adj_w[v]:
            if x not in visited:
                heapq.heappush(pq,(wx,v,x))
    return total, mst
```

---

## 9) 이분성, 매칭, 흐름

### 9.1 이분 그래프 판정 (2-색칠)

```python
from collections import deque

def is_bipartite(adj):
    color={}
    for s in adj:
        if s in color: continue
        color[s]=0
        q=deque([s])
        while q:
            u=q.popleft()
            for v in adj[u]:
                if v not in color:
                    color[v]=color[u]^1; q.append(v)
                elif color[v]==color[u]:
                    return False, None
    return True, color
```

### 9.2 최대 유량 (Edmonds–Karp, BFS로 증가경로)

```python
from collections import deque

def edmonds_karp(n, capacity, s, t):
    """
    capacity[u][v]: 용량 행렬
    """
    flow=[[0]*n for _ in range(n)]
    total=0
    while True:
        parent=[-1]*n; parent[s]=s
        q=deque([s])
        while q and parent[t]==-1:
            u=q.popleft()
            for v in range(n):
                if parent[v]==-1 and capacity[u][v]-flow[u][v]>0:
                    parent[v]=u; q.append(v)
        if parent[t]==-1: break
        # 증가량
        inc=10**18; v=t
        while v!=s:
            u=parent[v]
            inc=min(inc, capacity[u][v]-flow[u][v])
            v=u
        # 유량 갱신
        v=t
        while v!=s:
            u=parent[v]
            flow[u][v]+=inc
            flow[v][u]-=inc
            v=u
        total+=inc
    return total, flow
```

> 응용: **최대 이분 매칭**은 유량으로도 풀 수 있고, 전용 알고리즘(Hopcroft–Karp, \(O(\sqrt{V}E)\))도 존재.

---

## 10) 그래프 색칠/군집/중심성 (요약)

- **색칠**: 인접 정점이 다른 색. 그리디는 정점 순서에 따라 근사. 이분 그래프는 2-색 가능.
- **군집**: 모듈러리티, 커뮤니티 탐지(Louvain 등)—여기선 개념만 소개.
- **중심성**: Degree/Betweenness/Closeness/PageRank—네트워크 분석 핵심 지표.

---

## 11) 격자·지도에서의 경로탐색 (A* 예시)

**허용 휴리스틱** \(h\) (결코 과대평가하지 않음) 사용하면 A*는 최단경로를 보장.  
격자 맨해튼 거리:
$$
h((x,y),(gx,gy))=|x-gx|+|y-gy|
$$

```python
import heapq

def astar(grid, start, goal):
    R,C=len(grid),len(grid[0])
    sr,sc=start; gr,gc=goal
    def h(r,c): return abs(r-gr)+abs(c-gc)
    INF=10**9
    g=[[INF]*C for _ in range(R)]
    g[sr][sc]=0
    pq=[(h(sr,sc), 0, sr, sc, None)]
    parent={}
    while pq:
        f, cost, r, c, par = heapq.heappop(pq)
        if cost!=g[r][c]: continue
        parent[(r,c)] = par
        if (r,c)==(gr,gc):
            # 복원
            path=[]; cur=(gr,gc)
            while cur: path.append(cur); cur=parent[cur]
            return list(reversed(path)), cost
        for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            nr, nc = r+dr, c+dc
            if 0<=nr<R and 0<=nc<C and grid[nr][nc]==0:
                nd=cost+1
                if nd<g[nr][nc]:
                    g[nr][nc]=nd
                    heapq.heappush(pq,(nd+h(nr,nc), nd, nr, nc, (r,c)))
    return None, INF

# 0=통로,1=벽
grid = [
 [0,0,0,1,0],
 [1,1,0,1,0],
 [0,0,0,0,0],
 [0,1,1,1,0],
 [0,0,0,0,0],
]
path,cost = astar(grid,(0,0),(4,4))
print(cost, path[:5], '...')  # 예: 8 [(0,0),(0,1),...]
```

---

## 12) 연결 요소 & SCC

### 12.1 무향 연결 요소(Components)

- 한 번의 DFS/BFS로 방문한 집합이 하나의 요소.

```python
def connected_components(adj):
    seen=set(); comps=[]
    for s in adj:
        if s in seen: continue
        stack=[s]; comp=[]
        seen.add(s)
        while stack:
            u=stack.pop(); comp.append(u)
            for v in adj[u]:
                if v not in seen:
                    seen.add(v); stack.append(v)
        comps.append(comp)
    return comps
```

### 12.2 유향 강연결요소(SCC) — Kosaraju

```python
def kosaraju_scc(adj):
    G=adj
    R={u:[] for u in G}
    for u in G:
        for v in G[u]:
            R.setdefault(v,[]).append(u)
    seen=set(); order=[]
    def dfs1(u):
        seen.add(u)
        for v in G[u]:
            if v not in seen: dfs1(v)
        order.append(u)
    for u in G:
        if u not in seen: dfs1(u)
    comp={}
    def dfs2(u, cid):
        comp[u]=cid
        for v in R[u]:
            if v not in comp: dfs2(v, cid)
    cid=0
    for u in reversed(order):
        if u not in comp:
            dfs2(u, cid); cid+=1
    # comp: node -> component id (0..cid-1)
    return comp, cid
```

- SCC를 축약하면 항상 **DAG** (응: 위상 정렬 가능).

---

## 13) 작은 종합 예제 (모델 → 알고리즘)

**문제**: 작업 의존 그래프(유향)가 주어진다.  
1) 작업 순서를 정하라(위상 정렬).  
2) 각 작업에 소요 시간이 있을 때, 전체 최소 완료 시간을 구하라(크리티컬 패스).

**모델**: DAG, 간선 \(u\to v\)는 “u 끝나야 v 시작”.

**해법**:
1) Kahn 위상 정렬.  
2) 위상 순서대로 `finish[v] = max(finish[u]) + cost[v]` (선행 \(u\)들), 초기엔 \(finish[u]=cost[u]\) if indeg=0.

```python
from collections import deque, defaultdict

def schedule_time(adj, cost):
    indeg=defaultdict(int)
    for u in adj:
        for v in adj[u]: indeg[v]+=1
        indeg[u]+=0
    q=deque([u for u in indeg if indeg[u]==0])
    topo=[]
    while q:
        u=q.popleft(); topo.append(u)
        for v in adj[u]:
            indeg[v]-=1
            if indeg[v]==0: q.append(v)
    if len(topo)!=len(indeg): return None  # cycle
    finish={u:0 for u in indeg}
    for u in topo:
        best=0
        # 역인접 필요 없으면 입력에 선행관계도 주자. 여기선 간단히 탐색:
        # 선행을 저장했다고 가정하면 O(m) 절약 가능
        for p in indeg: pass  # 설명 단순화 위해 생략
    # 효율적 구현(선행 목록이 있다고 가정):
```

> 위 코드는 개념을 보여주기 위한 스케치다. 실제로는 **선행 리스트(pred)** 를 함께 들고 가며 `finish[v]=max(finish[p]) + cost[v]` 를 갱신한다.  
> DAG에서 동적계획으로 \(O(n+m)\).

---

## 14) 구현 팁 & 실무 주의

- **다익스트라 + 음수 간선 금지**: 음수 있으면 Bellman–Ford나 DAG 최단경로.
- **유량/매칭**: 간선 수가 크면 **인접 리스트 + 잔여그래프**로 구현(배열 인덱스 기반).
- **숫자 범위**: 거리/가중치 합이 클 수 있으니 `INF`를 충분히 크게.
- **해시 맵 키**: 문자열/튜플 정점을 쓰면 dict/set 키로 바로 가능.
- **성능**: 파이썬에서는 `heapq`, `deque`, 리스트 재활용으로 가비지 줄이기.
- **테스트**: 아주 작은 예제(손으로 답 아는 것)로 먼저 검증.

---

## 15) 추가 이론 한 입

- **Max-flow Min-cut 정리**: 최대 유량 값 = 최소 s–t 절단의 용량.  
- **MST 컷/사이클 속성**: 최소 컷의 최소 간선은 MST에 포함, 사이클의 최대 간선은 제외(안전/불안전 간선).  
- **랜덤 그래프** \(G(n,p)\): 임계현상(연결성, 거대성분).  
- **스몰월드/스케일프리**: Watts–Strogatz(높은 군집+작은 평균거리), Barabási–Albert(멱함수 차수분포).

---

## 16) 입·출력 예제 모음

### 16.1 최단경로(다익스트라)

```python
adj = {
  0:[(1,2),(2,5)],
  1:[(2,1),(3,3)],
  2:[(3,1)],
  3:[]
}
dist, par = dijkstra(adj, 0)
print(dist)  # {0:0, 1:2, 2:3, 3:4}
```

경로 복원(3까지):

```python
def restore(parent, t):
    path=[]
    while t is not None:
        path.append(t)
        t = parent[t]
    return list(reversed(path))
print(restore(par, 3))  # [0,1,2,3]
```

### 16.2 MST(크루스칼)

```python
n=4
edges=[(1,0,1),(4,0,2),(2,1,2),(3,1,3),(5,2,3)]
total, mst = kruskal(n, edges)
print(total, mst)  # 1+2+3=6, 예: [(0,1,1),(1,2,2),(1,3,3)]
```

### 16.3 이분 판정

```python
adj={0:[1,3],1:[0,2],2:[1,3],3:[0,2]}
ok, color = is_bipartite(adj)
print(ok, color)  # True, 예: {0:0,1:1,2:0,3:1}
```

---

## 17) 연습 과제

1) 무향 그래프가 주어졌을 때 **오일러 경로/회로 존재 여부**와 실제 경로를 출력(히어홀저 알고리즘).  
2) **DAG 최장경로**(가중치가 음수로 생각 가능) – 위상 정렬 + DP.  
3) **최대 이분 매칭**: 유량 기반 또는 Hopcroft–Karp 직접 구현.  
4) 격자 지도에서 **장애물 가중**(예: 모래=3, 도로=1) 반영 A* 구현.  
5) 큰 희소 그래프에서 **SCC 축약 DAG**를 만들어 위상 정렬 → 컴포넌트 레벨 파이프라인 스케줄.

---

## 18) 요약

- 그래프는 **객체 간 관계**를 표현하는 가장 강력한 추상화.  
- **표현**: 인접 리스트가 기본, 행렬은 밀집/행렬연산에 유리.  
- **탐색**: BFS/DFS는 근본. **DAG**는 위상 정렬로 푼다.  
- **최단경로**: 무가중=BFS, 비음수=Dijkstra, 음수=Bellman–Ford.  
- **MST**: Kruskal/Prim. **흐름/매칭**: Edmonds–Karp, Hopcroft–Karp.  
- **SCC/군집/색칠/평면성** 등은 모델과 문제의 본질을 드러낸다.