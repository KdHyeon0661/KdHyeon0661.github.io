---
layout: post
title: 운영체제 - 메인 메모리 (2)
date: 2025-10-25 15:30:23 +0900
category: 운영체제
---
# Example • ARMv8 Example

## Swapping

### 개념과 용어

- **Swapping(스와핑)**: 메인 메모리가 부족할 때 **프로세스의 메모리 페이지를 디스크(스왑 공간)**로 내보내고, 필요할 때 다시 불러오는 기법.
- **Swap space**: 전용 파티션 또는 파일.
- **페이지 상태**
  - **Clean page**: 디스크(파일/스왑)에 동일 내용 존재 → 퇴출 시 저장 불필요.
  - **Dirty page**: 메모리에서 변경됨 → 퇴출 시 **쓰기(backing store) 필요**.
- **Page-in / Page-out**: 스왑에서 **읽어오기** / 스왑으로 **내보내기**.

### 동작 흐름(수학적 관점)

스레드가 주소 \(VA\)를 접근 → TLB 미스 → 페이지 테이블 탐색에서 **불재주(present=0)** → **페이지 폴트**.
OS는 **교체 알고리즘**으로 프레임을 확보하고, 필요하면 희생 프레임을 스왑아웃한다.

> 유효 접근 시간(EAT) 근사:
> $$EAT \approx h\cdot(t+m) + (1-h)\cdot\bigl(t + k\cdot m\bigr) + p\cdot D,$$
> - \(h\): TLB 히트율, \(t\): TLB 접근 시간, \(m\): DRAM 접근 시간
> - \(k\): 다단계 PTE 접근 횟수(보통 2~5)
> - \(p\): 페이지 폴트 확률, \(D\): 디스크 I/O 지연(수 ms~수십 ms)
> → **\(pD\)** 항이 압도적 → 폴트 최소화가 핵심.

### 교체 정책과 스왑 오버헤드

- **LRU 이상형** vs 현실 근사(Reference bit 기반 **Clock/Second-Chance**).
- **Working set**: 최근 윈도우 \(W\) 동안 접근한 페이지 집합.
- **Thrashing**: 작업 집합보다 프레임이 부족하여 **지속적 폴트**로 처리량 급락.

#### Thrashing 유도 파이썬

```python
# thrash.py — 작은 물리 캐시(시뮬)로 큰 워크셋을 순회해 폴트율 관찰

from collections import deque
def simulate(n_frames=8, pages=64, reps=1000):
    frames, faults = deque(maxlen=n_frames), 0
    for _ in range(reps):
        for p in range(pages):   # 순차 접근은 지역성 낮을 때 폴트↑
            if p not in frames:
                faults += 1
                frames.append(p)
    return faults
print("faults:", simulate())
```

### 스왑 공간의 배치와 최적화

- **파티션 vs 파일**: 파티션이 일반적으로 **연속성/단편화** 면에서 유리, 최근 파일도 충분히 빠름(파일시스템/커널 최적화).
- **압축 스왑(zswap/zram)**: 메모리에서 **압축된 스왑 캐시** → 디스크 I/O 감소.
- **I/O 스케줄링**: 스왑 I/O는 **순차/병렬성** 확보에 민감.

### API/튜닝(리눅스 예)

- **`mlock/munlock`**: 특정 범위를 **스왑 금지**.
- **`madvise`**: 접근 패턴 힌트(`MADV_WILLNEED`, `MADV_DONTNEED`, `MADV_RANDOM/SEQUENTIAL`).
- **`posix_fadvise`**: 파일 I/O 캐시 힌트 → 페이지캐시/스왑 압력에 간접 영향.
- **`oom_killer`**: 메모리 고갈 시 희생 프로세스 선정.

#### 스왑 회피가 중요한 영역 고정

```c
// pin_mem.c — 중요 버퍼를 mlock으로 스왑에서 보호(루트 권한/리밋 필요)
#define _GNU_SOURCE
#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
  size_t sz = 8*1024*1024; // 8MB
  void* p = aligned_alloc(4096, sz);
  memset(p, 0, sz);
  if(mlock(p, sz)!=0){ perror("mlock"); }
  // ... 보안 키/핫패스 데이터 사용 ...
  // 종료 전
  munlock(p, sz); free(p);
}
```

#### 페이지 캐시 힌트로 폴트 타이밍 제어

```c
// prefetch_advise.c — 파일을 미리 읽게 하고, 사용 후 버리기
#define _GNU_SOURCE
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char** argv){
  int fd = open(argv[1], O_RDONLY);
  struct stat st; fstat(fd, &st);
  void* p = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);

  // 순차 접근 힌트: 리드어헤드↑
  posix_fadvise(fd, 0, st.st_size, POSIX_FADV_SEQUENTIAL);

  // 실제 접근 전에 커널에 미리 요구
  madvise(p, st.st_size, MADV_WILLNEED);

  // ... 순차 스캔 ...

  // 더 이상 안 씀: 캐시 잔존을 줄여 이후 스왑 압력 완화
  madvise(p, st.st_size, MADV_DONTNEED);
  munmap(p, st.st_size); close(fd);
}
```

### 스왑 관련 운영 지표(관측 체크리스트)

- **Page fault rate**(minor/major), **kswapd 활동**, **swap in/out bytes**, **dirty ratio**.
- **p95/p99 latency**와 상관관계(특히 스토리지 QoS).
- **cgroup(컨테이너)**: `memory.swap.max`, `memory.low`로 보호/제한.

---

## Example: Intel 32- and 64-bit Architectures (x86)

> x86은 **세그먼테이션 + 페이징**을 지원하지만, 현대 OS는 **세그먼트 평탄화(flat)** 후 **페이징 중심**으로 사용.

### — 페이징 개요

- **페이지 크기**: 4 KiB 기본, **4 MiB(huge)** 지원.
- **CR3**: 페이지 디렉터리(기본) 또는 PAE 모드에서 PDP 테이블의 물리 주소.
- **PAE (Physical Address Extension)**
  - 36-bit 물리 주소, **3-레벨 구조**(PDPT→PD→PT), PTE/PDE가 64-bit.
  - **NX(Execute Disable)** 비트는 PAE/64-bit 모드에서 사용 가능.

#### IA-32 주소 분해(4KiB, 2-레벨 기본)

- 32-bit VA:
  $$\text{Dir}(10) \ \text{Tbl}(10) \ \text{Offset}(12)$$

### x86-64 (AMD64/Intel 64)

- **Canonical VA**: 전통적 48-bit(상위 16비트는 sign-extend), 최신은 **LA57**(57-bit) 모드.
- **4-레벨 페이징**(기본) / **5-레벨(LA57)**:
  - 4-레벨: **PML4 → PDPT → PD → PT → Offset**
  - 5-레벨: **PML5 → PML4 → PDPT → PD → PT → Offset**
- **페이지 크기**: 4 KiB, 2 MiB(large), 1 GiB(huge; PDPT 엔트리).
- **PCID(Process-Context ID)**: TLB 태깅 → 컨텍스트 스위치 TLB flush 비용 감소.
- **INVPCID**: 특정 PCID만 무효화 등 미세 제어.
- **NX/XD**: 실행 금지(DEP).
- **Global bit (G)**: CR4.PGE 활성 시 **글로벌 TLB 엔트리** → 컨텍스트 스위치에도 유지.

#### x86-64 주소 비트 예시(4KiB 페이지, 4-레벨)

- 48-bit VA:
  $$\underbrace{\text{L4}}_{9}\ \underbrace{\text{L3}}_{9}\ \underbrace{\text{L2}}_{9}\ \underbrace{\text{L1}}_{9}\ \underbrace{\text{Offset}}_{12}$$

#### x86-64 VA 인덱스 계산(학습용)

```c
// va_decode_x86_64.c — 4-level 페이지 테이블에서 인덱스 추출(4KiB 가정)
#include <stdint.h>
#include <stdio.h>

struct idx { unsigned l4,l3,l2,l1,off; };

struct idx decode(uint64_t va){
  struct idx o;
  o.off = va & ((1u<<12)-1);
  o.l1  = (va >> 12) & 0x1FF;
  o.l2  = (va >> 21) & 0x1FF;
  o.l3  = (va >> 30) & 0x1FF;
  o.l4  = (va >> 39) & 0x1FF;
  return o;
}
int main(){
  uint64_t va = 0x00007f123456789aULL;
  struct idx i = decode(va);
  printf("L4=%u L3=%u L2=%u L1=%u off=0x%x\n", i.l4,i.l3,i.l2,i.l1,i.off);
}
```

#### x86-64 PTE 비트 스케치

```c
// pte_x86_64.h — 개념적(실제 하드웨어 정의는 조금씩 상이)
#include <stdint.h>

typedef struct {
  uint64_t present:1, rw:1, us:1, pwt:1, pcd:1, a:1, d:1, pat:1, g:1, ign:3;
  uint64_t pfn:36;
  uint64_t sw:7, protkey:4, nx:1;
} pte64_t;
```

#### 사용자 모드에서 TLB 성능 힌트(PCID는 OS가 설정)

- 애플리케이션 관점: **페이지 접근 패턴** 최적화, **huge page(THP)** 사용 여부 결정, **NUMA 배치**.

```c
// hugepage_hint.c — 투명 대페이지(THP) 힌트: madvise(MADV_HUGEPAGE)
#define _GNU_SOURCE
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>

int main(){
  size_t sz = 512*1024*1024; // 512MB
  void* p = mmap(NULL, sz, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
  madvise(p, sz, MADV_HUGEPAGE);   // THP 후보
  // 대규모 선형 스캔/행렬곱 등에서 TLB 미스↓
  // ...
  munmap(p, sz);
}
```

### 세그먼테이션(요약)과 현대 사용

- x86은 **세그먼트** + **디스크립터(GDT/LDT)** 구조를 지원하지만, 현대 64-bit 모드에선 **flat 모델**(base=0, limit=~0)과 **FS/GS**를 이용한 스레드 로컬/커널 베이스 정도만 실사용.

---

## Example: ARMv8 Architecture (AArch64)

### 주소 변환 개요

- **가상 주소 폭**: 구현 선택(일반적으로 48-bit/52-bit).
- **페이지(Granule) 크기**: **4 KiB / 16 KiB / 64 KiB** 중 택일(SoC/OS 구성).
- **TTBR0/TTBR1**: 사용자/커널(또는 하위/상위 VA 영역) 루트 테이블 포인터.
- **TCR(Translation Control Register)**: 주소 크기, granule, 공유/캐시 정책, ASID 활성화 등 제어.
- **ASID**: TLB 태깅으로 컨텍스트 스위치 flush 비용 감소.

### 단계적 테이블(레벨 0~3/4)

- granule=4 KiB, 48-bit VA 예(일반): **최대 4단계** 변환(L0→L1→L2→L3).
- **Block entry**(중간 레벨에서 큰 영역 매핑)와 **Page entry**(마지막 레벨) 구분.
- **Large page/Block**: 2 MiB/1 GiB (x86의 large/huge와 개념 유사, granule에 따라 값 다름).

#### ARMv8 4KiB Granule 인덱스

- 48-bit VA (가정):
  $$\underbrace{L0}_{n}\ \underbrace{L1}_{9}\ \underbrace{L2}_{9}\ \underbrace{L3}_{9}\ \underbrace{Offset}_{12}$$
- TCR의 **TnSZ** 값에 따라 상위 비트 사용 폭이 달라지고 L0 사용 유/무가 결정.

```python
# aarch64_va_decode.py — 단순 인덱스 추출(48-bit, 4KiB 가정, L0 생략 예)

def decode(va):
    off =  va        & ((1<<12)-1)
    l3  = (va >> 12) & 0x1FF
    l2  = (va >> 21) & 0x1FF
    l1  = (va >> 30) & 0x1FF
    # L0는 TCR 설정(T0SZ/T1SZ)에 따라 있을 수도/없을 수도
    return l1, l2, l3, off
print(decode(0x0000_7f12_3456_789a))
```

### PTE/Block 엔트리 비트(요약)

- **Valid**, **Table**(다음 레벨로 이어짐) vs **Block/Page**(매핑).
- **AP (Access Permission)**: RW/RO, EL0 접근 가능 여부.
- **UXN/PXN**: **실행 금지**(user/kernel).
- **AF(Access Flag)**: 접근 발생 표시(Clock/LRU 근사에 활용).
- **SH**: 공유 범위(Inner/Outer/None) → 캐시 일관성 도메인.
- **AttrIdx**: **MAIR** 인덱스(메모리 속성: 장치/정상, write-back/non-cacheable 등).

```c
// aarch64_pte.h — 개념적 비트 매크로 (실제 필드 배치는 ARM ARM 참고)
#define PTE_VALID   (1ull<<0)
#define PTE_TABLE   (1ull<<1)   // 1=Table, 0=Block/Page
#define PTE_AF      (1ull<<10)
#define PTE_SH_IS   (0b11ull<<8)  // Inner Shareable 예
#define PTE_AP_RW   (0b00ull<<6)  // RW
#define PTE_AP_RO   (0b10ull<<6)  // RO
#define PTE_UXN     (1ull<<54)    // EL0 execute-never
#define PTE_PXN     (1ull<<53)    // EL1 execute-never

```

### TTBR/ASID와 컨텍스트

- **TTBR0_EL1**: 일반적으로 사용자 하위 VA 영역 루트.
- **TTBR1_EL1**: 커널 상위 VA 영역 루트.
- **ASID**(TTBR 상위 비트): TLB 엔트리를 **주소 공간 식별자**로 분리 → 스위치 비용↓.
- **Context switch** 시 TTBR/ASID를 갱신하고 필요시 **TLBI**(TLB Invalidate) 발행.

### ARMv8의 큰 페이지/블록과 성능

- 메모리 대역폭/워크셋 큰 워크로드에서 **TLB 커버리지 확대**로 유리.
- 내부 단편화 vs 성능의 트레이드오프는 x86과 동일한 원리.

#### 사용자 공간에서 HugeTLB(리눅스)

```c
// hugetlb_map.c — 명시적 HugeTLB (시스템 설정 필요: /proc/sys/vm/nr_hugepages)
#define _GNU_SOURCE
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main(){
  int fd = open("/dev/hugepages/hugefile", O_CREAT|O_RDWR, 0755);
  size_t sz = 2UL*1024*1024; // 2MiB huge page
  ftruncate(fd, sz);
  void* p = mmap(NULL, sz, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
  // ... 사용 ...
  munmap(p, sz); close(fd);
}
```

*(ARMv8에서도 리눅스 레벨에서 HugeTLB/THP 개념은 유사하게 적용 가능. granule/블록 크기는 SoC/커널 설정 영향.)*

---

## 종합 실습 & 운영 체크리스트

### 실습 A — 스왑/폴트 관측

1) 큰 배열을 순차/랜덤 접근(페이지 크기보다 충분히 큼).
2) `mlock`으로 일부만 고정, 나머지는 스왑 압력 유도.
3) `perf`, `vmstat`, `sar -B`, `/proc/vmstat`로 **pgpgin/pgpgout**, **pswpin/pswpout** 등 관측.
4) **p95 지연**과 상관관계 도출.

### 실습 B — x86-64 vs ARMv8 TLB 커버리지

1) 같은 워크로드(행렬 곱, 선형 스캔)에서 **THP/HugeTLB on/off** 비교.
2) TLB miss, LLC miss, IPC 비교 → 큰 페이지의 이득/손실 정리.

### 실습 C — 다단계 테이블 비용

1) TLB 미스 강제(큰 랜덤 워크셋) 후, **4-레벨 vs 5-레벨**(가능 시)의 메모리 접근 수 차이를 모델링.
2) OS가 **walk 캐시(Page Walk Cache)** 를 어떻게 줄여주는지 조사/정리.

### 운영 체크리스트

- 스왑: **zswap/zram**, I/O QoS, cgroup swap 제한, OOM 정책.
- 큰 페이지: THP 정책(`always/madvise/never`), NUMA 바인딩, 내부 단편화 모니터링.
- x86: **PCID/INVPCID 활성** 여부, 글로벌 페이지 사용, 보안 패치(SMEP/SMAP/NX)와의 호환.
- ARMv8: TCR/MAIR/SH/AttrIdx 설정 일관성, TTBR0/1 분리 정책, ASID 관리.

---

## 핵심 요약

- **9.5 스와핑**: 디스크 백업을 통한 메모리 압력 완화. **페이지 폴트 비용**이 지배적 → **워크셋/교체정책/압축스왑**으로 최소화. `mlock/madvise` 등 힌트가 실무에 중요.
- **9.6 x86**: 32-bit PAE, 64-bit(4/5-레벨) 페이징. **PCID**, **NX**, **huge page**와 **글로벌 엔트리**로 TLB/보호/성능 조율.
- **9.7 ARMv8**: **TTBR0/1 + ASID**, **TCR/MAIR**로 세밀한 변환/속성 제어. **granule(4/16/64KiB)**, 블록 매핑으로 성능 최적화.
→ 공통적으로 **TLB 커버리지·폴트율·I/O 대기**의 균형이 성능을 좌우한다.
