---
layout: post
title: ì˜ìƒì²˜ë¦¬ - AVI íŒŒì¼ ì²˜ë¦¬í•˜ê¸°
date: 2025-10-09 15:25:23 +0900
category: ì˜ìƒì²˜ë¦¬
---
# | **AVI íŒŒì¼ ì²˜ë¦¬í•˜ê¸°**

_ì´ ì¥ì—ì„œëŠ” **RIFF/AVI êµ¬ì¡°**ë¥¼ ë¨¼ì € ì •í™•íˆ ì§šê³ , Windows **Video for Windows (VfW)** APIë¥¼ ì‚¬ìš©í•´ **í”„ë ˆì„ ì½ê¸°/ì“°ê¸°**ë¥¼ ëª¨ë‘ ì§€ì›í•˜ëŠ” `IppAvi` í´ë˜ìŠ¤ë¥¼ ì„¤ê³„Â·êµ¬í˜„í•©ë‹ˆë‹¤. ë˜í•œ **MJPEG ì••ì¶• ìŠ¤íŠ¸ë¦¼**ê³¼ **ë¹„ì••ì¶•(32bpp)** ìŠ¤íŠ¸ë¦¼ ëª¨ë‘ë¥¼ ë‹¤ë£¨ê³ , `IppDib`(BGRA32, top-down)ê³¼ ìƒí˜¸ ë³€í™˜í•˜ëŠ” ì‹¤ì „ ì½”ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤._

> ì „ì œ
> - í”Œë«í¼: Windows, C++17, Win32(ë¹„-MFC) ê¸°ì¤€.
> - ë Œë”ë§/ì‹¤ì œ ì˜ìƒ ë³´ê´€ì€ ì• ì¥ì˜ `IppDib`(Top-Down **BGRA32**)ë¥¼ ì‚¬ìš©.
> - AVI ì ‘ê·¼: **Video for Windows (VfW)** API (`vfw.h`, `Vfw32.lib`).
> - ì½”ë“œ ë¸”ë¡ì€ ëª¨ë‘ í•œ ë²ˆë§Œ ``` ë¡œ ê°ìŒ‰ë‹ˆë‹¤.

---

## AVI íŒŒì¼ì˜ êµ¬ì¡°ì™€ ì‚¬ìš©ë²•

### RIFF/AVI ê°œìš”

AVI íŒŒì¼ì€ RIFF(Resource Interchange File Format)ë¥¼ ë”°ë¦…ë‹ˆë‹¤.

- **RIFF í—¤ë”**
  - `"RIFF"` (4ë°”ì´íŠ¸) + ì „ì²´ íŒŒì¼ í¬ê¸°(4ë°”ì´íŠ¸) + `"AVI "`(4ë°”ì´íŠ¸)
- **ë¦¬ìŠ¤íŠ¸/ì²­í¬(Chunk)** ë¡œ êµ¬ì„±
  - `LIST 'hdrl'` : í—¤ë” ì˜ì—­
    - `avih` : ë©”ì¸ í—¤ë”(í”„ë ˆì„ ì‹œê°„, ì „ì²´ í”„ë ˆì„ ìˆ˜, ìŠ¤íŠ¸ë¦¼ ìˆ˜ ë“±)
    - `LIST 'strl'` : ìŠ¤íŠ¸ë¦¼ í—¤ë”/í¬ë§·
      - `strh` : ìŠ¤íŠ¸ë¦¼ í—¤ë”(ë¹„ë””ì˜¤/ì˜¤ë””ì˜¤ êµ¬ë¶„, ìŠ¤ì¼€ì¼/ë ˆì´íŠ¸ ë“±)
      - `strf` : ìŠ¤íŠ¸ë¦¼ í¬ë§·(ë¹„ë””ì˜¤=BITMAPINFOHEADER, ì˜¤ë””ì˜¤=WAVEFORMATEX)
  - `LIST 'movi'` : ì‹¤ì œ **í”„ë ˆì„ ë°ì´í„°**
    - ë¹„ë””ì˜¤ í”„ë ˆì„ ì²­í¬ ID ì˜ˆ: `"00db"`(uncompressed), `"00dc"`(compressed)
  - `idx1` : ì¸ë±ìŠ¤(ì˜µì…˜ì´ì§€ë§Œ ëŒ€ë¶€ë¶„ ì¡´ì¬)

### FPS/ê¸¸ì´/ì‚¬ì´ì¦ˆì˜ í•´ì„

- `avih.dwMicroSecPerFrame` â†’ í”„ë ˆì„ ì‹œê°„(ë§ˆì´í¬ë¡œì´ˆ)
  - FPS \(=\dfrac{1,000,000}{dwMicroSecPerFrame}\)
- `strh.dwScale`/`strh.dwRate` â†’ ìŠ¤íŠ¸ë¦¼ì˜ ì‹œê°„ ë‹¨ìœ„
  - FPS \(=\dfrac{dwRate}{dwScale}\) (ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼)
- `avih.dwTotalFrames` : ì „ì²´ í”„ë ˆì„ ìˆ˜
- `BITMAPINFOHEADER` ì˜ `biWidth`, `biHeight`, `biBitCount` ë¡œ í”½ì…€ í¬ë§· íŒŒì•…
  - `biHeight>0` â†’ **bottom-up** DIB (í•˜ë‹¨ë¶€í„° ìœ„ë¡œ)
  - `biHeight<0` â†’ **top-down** DIB (ìƒë‹¨ë¶€í„° ì•„ë˜ë¡œ)

> ì‹¤ì œ íŒŒì‹±ì„ ì§ì ‘ êµ¬í˜„í•  ìˆ˜ë„ ìˆì§€ë§Œ, Windowsì—ì„œëŠ” **VfW** ê³ ìˆ˜ì¤€ APIê°€ ì•ˆì „í•˜ê³  í¸ë¦¬í•©ë‹ˆë‹¤. ì•„ë˜ëŠ” **VfWë¡œ ì½ê¸°/ì“°ê¸°**ë¥¼ êµ¬í˜„í•œ `IppAvi` í´ë˜ìŠ¤ì…ë‹ˆë‹¤.

---

## `IppAvi` í´ë˜ìŠ¤ ì„¤ê³„

### ëª©í‘œ ê¸°ëŠ¥

- **ì½ê¸°(Read)**
  - `openRead(path)` / `close()`
  - ë©”íƒ€ ì •ë³´: `width()`, `height()`, `fps()`, `totalFrames()`
  - í”„ë ˆì„ íšë“: `readFrame(n, IppDib& out)` (0 â‰¤ n < total)
- **ì“°ê¸°(Write)**
  - `beginWrite(path, width, height, fps, FourCC)`
  - `writeFrame(const IppDib&)` (BGRA32 â†’ (BGR24/32 bottom-up)ë¡œ ë³€í™˜í•˜ì—¬ ì €ì¥)
  - `endWrite()`
- **ì••ì¶• ì˜µì…˜**
  - ê¸°ë³¸: **ë¹„ì••ì¶•(BI_RGB 24/32)**
  - ì„ íƒ: **MJPG**(ì¼ë°˜ì ìœ¼ë¡œ í­ë„“ê²Œ ì„¤ì¹˜ë˜ì–´ ìˆìŒ). `AVIMakeCompressedStream` ì‚¬ìš©

### ì˜ì¡´ì„± & ë§í‚¹

```cpp
// í•„ìš” í—¤ë”/ë¼ì´ë¸ŒëŸ¬ë¦¬
#include <vfw.h>
#pragma comment(lib, "Vfw32.lib")

```

---

## êµ¬í˜„ â€“ `IppAvi.h / IppAvi.cpp`

### í—¤ë”: `IppAvi.h`

```cpp
// IppAvi.h
#pragma once
#include <string>
#include <vector>
#include <windows.h>
#include <vfw.h>
#include "IppDib.h"

enum class AviCodec {
    Uncompressed,   // BI_RGB (24/32bpp)
    MJPG            // Motion JPEG
};

class IppAvi {
public:
    IppAvi();
    ~IppAvi();

    // ì½ê¸°
    bool openRead(const std::wstring& path);
    void close();
    bool isOpen() const { return m_file != nullptr; }
    int  width()  const { return m_w; }
    int  height() const { return m_h; }
    double fps()  const { return m_fps; }
    int  totalFrames() const { return m_total; }
    // në²ˆì§¸ í”„ë ˆì„(0-based)ì„ IppDib(BGRA32, top-down)ì— ë¡œë“œ
    bool readFrame(int n, IppDib& out);

    // ì“°ê¸°
    bool beginWrite(const std::wstring& path, int w, int h, double fps, AviCodec codec=AviCodec::Uncompressed, int quality=90);
    bool writeFrame(const IppDib& frame); // frameì€ BGRA32 top-down
    bool endWrite();

private:
    // ë‚´ë¶€ ìœ í‹¸
    void releaseRead();
    void releaseWrite();
    static void TopDownBGRA_to_BottomUpBGR24(const IppDib& src, std::vector<uint8_t>& dst);
    static void TopDownBGRA_to_BottomUpBGRA32(const IppDib& src, std::vector<uint8_t>& dst);

private:
    // ê³µí†µ
    bool m_vfwInited=false;

    // ì½ê¸°ìš©
    PAVIFILE   m_file   = nullptr;
    PAVISTREAM m_vs     = nullptr;
    PGETFRAME  m_getfrm = nullptr;
    int m_w=0, m_h=0, m_total=0;
    double m_fps=0.0;

    // ì“°ê¸°ìš©
    PAVIFILE     m_wfile   = nullptr;
    PAVISTREAM   m_wstream = nullptr;
    PAVISTREAM   m_cstream = nullptr; // ì••ì¶• ìŠ¤íŠ¸ë¦¼(ì˜µì…˜)
    LONG         m_nextFrame = 0;
    int          m_ww=0, m_hh=0;
    double       m_wfps=0.0;
    AviCodec     m_wcodec=AviCodec::Uncompressed;
    int          m_quality=90; // 0~100
};
```

### êµ¬í˜„: `IppAvi.cpp` â€” **ì½ê¸° íŒŒíŠ¸**

```cpp
// IppAvi.cpp
#include "IppAvi.h"
#include <stdexcept>
#include <cassert>

IppAvi::IppAvi(){
    AVIFileInit(); // ì „ì—­ ì´ˆê¸°í™”
    m_vfwInited = true;
}
IppAvi::~IppAvi(){
    close();
    endWrite();
    if (m_vfwInited){ AVIFileExit(); m_vfwInited=false; }
}

// ---------- ì½ê¸°(Reader) ----------
bool IppAvi::openRead(const std::wstring& path){
    close();

    HRESULT hr = AVIFileOpenW(&m_file, path.c_str(), OF_READ, nullptr);
    if (FAILED(hr)){ m_file=nullptr; return false; }

    // ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ê°€ì ¸ì˜¤ê¸°
    hr = AVIFileGetStream(m_file, &m_vs, streamtypeVIDEO /*fccType*/, 0 /*first*/);
    if (FAILED(hr)){ close(); return false; }

    // ìŠ¤íŠ¸ë¦¼ ì •ë³´
    AVISTREAMINFO si = {0};
    hr = AVIStreamInfo(m_vs, &si, sizeof(si));
    if (FAILED(hr)){ close(); return false; }

    // FPS ê³„ì‚°: rate/scale
    if (si.dwScale!=0) m_fps = (double)si.dwRate / (double)si.dwScale;
    else m_fps = 0.0;

    // ê¸¸ì´
    LONG len = AVIStreamLength(m_vs);
    m_total = (len>0)? (int)len : 0;

    // í”„ë ˆì„ í¬ê¸° ì¶”ì •: strh.rcFrame ë˜ëŠ” strf(BITMAPINFO)ì—ì„œ ê°€ì ¸ì˜´
    // GetFrameOpen ì‹œ ì „ë‹¬í•˜ëŠ” í¬ë§·ìœ¼ë¡œ ê²°ì • ê°€ëŠ¥. ì—¬ê¸°ì„œëŠ” NULLë¡œ ì „ë‹¬í•˜ì—¬ ì› í¬ë§·ìœ¼ë¡œ.
    m_getfrm = AVIStreamGetFrameOpen(m_vs, nullptr);
    if (!m_getfrm){ close(); return false; }

    // ì²« í”„ë ˆì„ìœ¼ë¡œ í¬ê¸° íŒŒì•…
    void* p = AVIStreamGetFrame(m_getfrm, 0);
    if (!p){ close(); return false; }
    BITMAPINFOHEADER* bih = (BITMAPINFOHEADER*)p;
    m_w = bih->biWidth;
    m_h = (bih->biHeight>0)? bih->biHeight : -bih->biHeight; // ì ˆëŒ€ê°’

    return true;
}

void IppAvi::releaseRead(){
    if (m_getfrm){ AVIStreamGetFrameClose(m_getfrm); m_getfrm=nullptr; }
    if (m_vs){ AVIStreamRelease(m_vs); m_vs=nullptr; }
    if (m_file){ AVIFileRelease(m_file); m_file=nullptr; }
    m_w=m_h=m_total=0; m_fps=0.0;
}

void IppAvi::close(){ releaseRead(); }

// AVIStreamGetFrame â†’ BITMAPINFOHEADER + í”½ì…€ â†’ IppDib(BGRA32, top-down)
bool IppAvi::readFrame(int n, IppDib& out){
    if (!m_getfrm || n<0 || n>=m_total) return false;
    void* p = AVIStreamGetFrame(m_getfrm, n);
    if (!p) return false;

    BITMAPINFOHEADER* bih = (BITMAPINFOHEADER*)p;
    uint8_t* bits = (uint8_t*)p + bih->biSize + (bih->biClrUsed? bih->biClrUsed*4 : 0);

    int W=bih->biWidth;
    int H=(bih->biHeight>0? bih->biHeight : -bih->biHeight);
    int bpp=bih->biBitCount;

    // ì¶œë ¥ì€ top-down BGRA32
    out.create(W,H,32);

    // ì…ë ¥ì´ bottom-upì¸ì§€ íŒë³„
    bool bottomUp = (bih->biHeight>0);

    // í–‰ë³„ ì†ŒìŠ¤ stride (DWORD ì •ë ¬)
    int srcStrideBytes;
    if (bpp==24){
        srcStrideBytes = ((W*3 + 3) / 4) * 4;
    }else if (bpp==32){
        srcStrideBytes = W*4;
    }else if (bpp==8 || bpp==16){ // ë“œë¬¼ì§€ë§Œ ëŒ€ë¹„
        // ê°„ë‹¨í™”ë¥¼ ìœ„í•´ ì—¬ê¸°ì„œëŠ” 8/16bpp ë¯¸ì§€ì› ì²˜ë¦¬
        return false;
    }else{
        return false;
    }

    // ë³µì‚¬/í™•ì¥
    for (int y=0; y<H; ++y){
        int sy = bottomUp ? (H-1-y) : y;
        const uint8_t* srow = bits + (size_t)sy*srcStrideBytes;
        uint8_t* drow = (uint8_t*)out.bits() + (size_t)y*out.stride();

        if (bpp==24){
            for (int x=0; x<W; ++x){
                uint8_t B=srow[x*3+0], G=srow[x*3+1], R=srow[x*3+2];
                drow[x*4+0]=B; drow[x*4+1]=G; drow[x*4+2]=R; drow[x*4+3]=255;
            }
        }else{ // 32
            // ëŒ€ë¶€ë¶„ BI_RGB BGRA(ì•ŒíŒŒê°€ 0) ë˜ëŠ” ë¹„íŠ¸í•„ë“œì¼ ìˆ˜ ìˆìŒ. ì—¬ê¸°ì„œëŠ” BGRA ê°€ì •.
            memcpy(drow, srow, W*4);
            // ì•ŒíŒŒ ì±„ìš°ê¸°(0ì´ë©´ 255ë¡œ)
            for (int x=0; x<W; ++x) if (drow[x*4+3]==0) drow[x*4+3]=255;
        }
    }
    return true;
}
```

### êµ¬í˜„: `IppAvi.cpp` â€” **ì“°ê¸° íŒŒíŠ¸**

```cpp
// ---------- ì“°ê¸°(Writer) ----------
bool IppAvi::beginWrite(const std::wstring& path, int w, int h, double fps, AviCodec codec, int quality){
    endWrite();
    m_ww=w; m_hh=h; m_wfps=fps; m_wcodec=codec; m_quality=std::clamp(quality,0,100);
    m_nextFrame=0;

    HRESULT hr = AVIFileOpenW(&m_wfile, path.c_str(), OF_CREATE | OF_WRITE, nullptr);
    if (FAILED(hr)){ m_wfile=nullptr; return false; }

    // ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ë§Œë“¤ê¸°
    AVISTREAMINFO si={0};
    si.fccType = streamtypeVIDEO; // 'vids'
    si.fccHandler = 0;            // ì••ì¶• ì„ íƒì€ ì´í›„ ë‹¨ê³„ì—ì„œ
    si.dwScale = 1000;            // 1ì´ˆ=1000ë‹¨ìœ„
    si.dwRate  = (DWORD)std::lround(fps*1000.0); // â†’ fps
    si.dwSuggestedBufferSize = w*h*4; // ëŒ€ëµ
    SetRect(&si.rcFrame, 0, 0, w, h);

    HRESULT hr2 = AVIFileCreateStream(m_wfile, &m_wstream, &si);
    if (FAILED(hr2)){ endWrite(); return false; }

    // ì••ì¶• ì„ íƒ: Uncompressed â†’ ë°”ë¡œ í¬ë§· ì„¸íŠ¸, MJPG â†’ ì••ì¶• ìŠ¤íŠ¸ë¦¼ ìƒì„±
    if (codec==AviCodec::Uncompressed){
        // 32bpp BI_RGB í¬ë§· ì‚¬ìš©(ì“°ê¸°/ì†ë„ í¸ì˜)
        BITMAPINFOHEADER bih={0};
        bih.biSize = sizeof(BITMAPINFOHEADER);
        bih.biWidth = w;
        bih.biHeight= h; // bottom-up
        bih.biPlanes= 1;
        bih.biBitCount = 32; // BGRA
        bih.biCompression = BI_RGB;
        bih.biSizeImage = w*h*4;

        hr2 = AVIStreamSetFormat(m_wstream, 0, &bih, sizeof(bih));
        if (FAILED(hr2)){ endWrite(); return false; }
        // ì••ì¶• ìŠ¤íŠ¸ë¦¼ì€ ì—†ìŒ
    }else{
        // MJPG ì••ì¶• ìŠ¤íŠ¸ë¦¼ ìƒì„±
        AVICOMPRESSOPTIONS opts={0};
        opts.fccType = streamtypeVIDEO;
        opts.fccHandler = mmioFOURCC('M','J','P','G');
        opts.dwQuality = (DWORD)((m_quality/100.0)*10000); // 0~10000

        PAVISTREAM tmp=nullptr;
        hr2 = AVIMakeCompressedStream(&tmp, m_wstream, &opts, nullptr);
        if (FAILED(hr2)){ endWrite(); return false; }
        m_cstream = tmp;

        // ì••ì¶• ìŠ¤íŠ¸ë¦¼ í¬ë§· ì„¤ì •(ì…ë ¥ í¬ë§·)
        BITMAPINFOHEADER bih={0};
        bih.biSize = sizeof(BITMAPINFOHEADER);
        bih.biWidth = w;
        bih.biHeight= h; // bottom-up
        bih.biPlanes= 1;
        bih.biBitCount = 24; // ëŒ€ë¶€ë¶„ MJPGëŠ” 24bpp BGR ê¸°ëŒ€
        bih.biCompression = BI_RGB;
        bih.biSizeImage = ((w*3 + 3)/4*4)*h;
        hr2 = AVIStreamSetFormat(m_cstream, 0, &bih, sizeof(bih));
        if (FAILED(hr2)){ endWrite(); return false; }
    }
    return true;
}

void IppAvi::releaseWrite(){
    if (m_cstream){ AVIStreamRelease(m_cstream); m_cstream=nullptr; }
    if (m_wstream){ AVIStreamRelease(m_wstream); m_wstream=nullptr; }
    if (m_wfile){ AVIFileRelease(m_wfile); m_wfile=nullptr; }
    m_nextFrame=0; m_ww=m_hh=0; m_wfps=0.0;
}

bool IppAvi::endWrite(){ if (!m_wfile && !m_wstream && !m_cstream) return true; releaseWrite(); return true; }

// BGRA32(top-down) â†’ BGR24(bottom-up)
void IppAvi::TopDownBGRA_to_BottomUpBGR24(const IppDib& src, std::vector<uint8_t>& dst){
    int W=src.width(), H=src.height();
    int stride = ((W*3 + 3)/4)*4;
    dst.assign((size_t)stride*H, 0);
    for (int y=0; y<H; ++y){
        const uint8_t* srow=(const uint8_t*)src.bits() + (size_t)y*src.stride();
        uint8_t* drow = dst.data() + (size_t)(H-1-y)*stride; // bottom-up
        for (int x=0; x<W; ++x){
            drow[x*3+0]=srow[x*4+0]; // B
            drow[x*3+1]=srow[x*4+1]; // G
            drow[x*3+2]=srow[x*4+2]; // R
        }
    }
}

// BGRA32(top-down) â†’ BGRA32(bottom-up)
void IppAvi::TopDownBGRA_to_BottomUpBGRA32(const IppDib& src, std::vector<uint8_t>& dst){
    int W=src.width(), H=src.height();
    int stride = W*4;
    dst.assign((size_t)stride*H, 0);
    for (int y=0; y<H; ++y){
        const uint8_t* srow=(const uint8_t*)src.bits() + (size_t)y*src.stride();
        uint8_t* drow = dst.data() + (size_t)(H-1-y)*stride; // bottom-up
        memcpy(drow, srow, W*4);
        // ì•ŒíŒŒê°€ 0ì´ë©´ 255 ì±„ìš°ê¸°(ì„ íƒ)
        for (int x=0; x<W; ++x) if (drow[x*4+3]==0) drow[x*4+3]=255;
    }
}

bool IppAvi::writeFrame(const IppDib& frame){
    if (!m_wfile || !m_wstream) return false;
    if (frame.width()!=m_ww || frame.height()!=m_hh) return false;

    HRESULT hr=E_FAIL;
    if (m_wcodec==AviCodec::Uncompressed){
        // 32bpp BI_RGBë¡œ ìŠ¤íŠ¸ë¦¼ í¬ë§· ì„¤ì •í–ˆìœ¼ë¯€ë¡œ BGRA32 bottom-up í•„ìš”
        std::vector<uint8_t> buf;
        TopDownBGRA_to_BottomUpBGRA32(frame, buf);
        LONG bytes = (LONG)buf.size();
        hr = AVIStreamWrite(m_wstream, m_nextFrame, 1, buf.data(), bytes, 0, nullptr, nullptr);
    }else{
        // MJPG: ì…ë ¥ í¬ë§·ì„ 24bpp BGRë¡œ ìš”ì²­í–ˆìŒ
        std::vector<uint8_t> buf;
        TopDownBGRA_to_BottomUpBGR24(frame, buf);
        LONG bytes = (LONG)buf.size();
        hr = AVIStreamWrite(m_cstream, m_nextFrame, 1, buf.data(), bytes, 0, nullptr, nullptr);
    }
    if (FAILED(hr)) return false;
    ++m_nextFrame;
    return true;
}
```

---

## ì‚¬ìš© ì˜ˆì œ

### ì˜ˆì œ A â€” AVI ì—´ê³  íŠ¹ì • í”„ë ˆì„ ë³´ê¸°

```cpp
// open_avi_and_show.cpp (ë°œì·Œ)
#include "IppAvi.h"
#include "IppDib.h"

// ... ì°½ í•¸ë“¤/ë„íë¨¼íŠ¸ ìœ í‹¸ì€ ì• ì¥ê³¼ ë™ì¼ ê°€ì •
void Cmd_OpenAviAndShowFrame100(){
    std::wstring path = L"sample.avi";
    IppAvi avi;
    if (!avi.openRead(path)){ MessageBoxW(nullptr, L"ì—´ê¸° ì‹¤íŒ¨", L"AVI", MB_ICONERROR); return; }

    IppDib frame;
    int n = std::min(100, avi.totalFrames()-1);
    if (!avi.readFrame(n, frame)){ MessageBoxW(nullptr, L"í”„ë ˆì„ ì½ê¸° ì‹¤íŒ¨", L"AVI", MB_ICONERROR); return; }

    // ìƒˆ ë¬¸ì„œ ì°½ì— í‘œì‹œ
    CreateDocWindowFromDib(frame, L"AVI Frame 100");
}
```

### ì˜ˆì œ B â€” BMP ì‹œí€€ìŠ¤ë¡œë¶€í„° AVI ë§Œë“¤ê¸°(30 FPS)

```cpp
// export_avi_from_bmps.cpp (ë°œì·Œ)
#include "IppAvi.h"
#include "IppDib.h"

void Cmd_ExportAviFromBmps(const std::vector<std::wstring>& bmpPaths){
    if (bmpPaths.empty()) return;

    // ì²« ì¥ í¬ê¸° í™•ì¸
    IppDib tmp; tmp.load(bmpPaths[0]); // ì• ì¥ì˜ IppDib::load ì‚¬ìš©
    int W=tmp.width(), H=tmp.height();

    IppAvi avi;
    if (!avi.beginWrite(L"out_uncompressed.avi", W,H, 30.0, AviCodec::Uncompressed)){
        MessageBoxW(nullptr, L"AVI ì“°ê¸° ì‹œì‘ ì‹¤íŒ¨", L"AVI", MB_ICONERROR); return;
    }
    for (auto& p : bmpPaths){
        IppDib f; if (!f.load(p)){ continue; }
        // í¬ê¸°ê°€ ë‹¤ë¥´ë©´ ê°„ë‹¨íˆ ì¤‘ì•™ í¬ë¡­/íŒ¨ë“œ ë˜ëŠ” ë¦¬ì‚¬ì´ì¦ˆ(ì§ì ‘ êµ¬í˜„)
        if (f.width()!=W || f.height()!=H) f = ResizeBgra32(f, W,H);
        avi.writeFrame(f);
    }
    avi.endWrite();
    MessageBoxW(nullptr, L"ë¹„ì••ì¶• AVI ì €ì¥ ì™„ë£Œ", L"AVI", MB_OK);

    // MJPGë¡œë„ ì €ì¥
    if (avi.beginWrite(L"out_mjpg.avi", W,H, 30.0, AviCodec::MJPG, 85)){
        for (auto& p : bmpPaths){
            IppDib f; f.load(p);
            if (f.width()!=W || f.height()!=H) f = ResizeBgra32(f, W,H);
            avi.writeFrame(f);
        }
        avi.endWrite();
        MessageBoxW(nullptr, L"MJPG AVI ì €ì¥ ì™„ë£Œ", L"AVI", MB_OK);
    }
}
```

### ì˜ˆì œ C â€” ê°„ë‹¨ AVI í”Œë ˆì´ì–´(íƒ€ì´ë¨¸ë¡œ ì¬ìƒ)

```cpp
// avi_player.cpp (í•µì‹¬ ë¶€ë¶„)
#include "IppAvi.h"

static IppAvi g_avi;
static IppDib g_cur;
static int g_index=0;
static UINT_PTR g_timer=0;

void StartPlay(const std::wstring& path, HWND hView){
    if (!g_avi.openRead(path)){ MessageBoxW(hView,L"ì—´ê¸°ì‹¤íŒ¨",L"AVI",MB_ICONERROR); return; }
    g_index=0;
    if (!g_avi.readFrame(g_index, g_cur)){ return; }
    InvalidateRect(hView,nullptr,FALSE);

    UINT interval = (UINT)std::max(1.0, 1000.0/g_avi.fps());
    g_timer = SetTimer(hView, 10, interval, nullptr);
}
void StopPlay(HWND hView){
    if (g_timer){ KillTimer(hView, 10); g_timer=0; }
    g_avi.close();
}
void OnTimer(HWND hView, WPARAM id){
    if (id!=10) return;
    ++g_index;
    if (g_index>=g_avi.totalFrames()) g_index=0; // ë£¨í”„ ì¬ìƒ
    if (g_avi.readFrame(g_index, g_cur)){
        InvalidateRect(hView,nullptr,FALSE);
    }
}
void OnPaint(HWND hView, HDC hdc){
    // g_cur (IppDib) ê·¸ë¦¬ê¸° â€” ì• ì¥ì˜ BitBlt/StretchDIBits ë£¨í‹´ ì´ìš©
    g_cur.draw(hdc, 0,0);
}
```

---

## ì‹¤ì „ íŒ & ì£¼ì˜ì‚¬í•­

### 32/64ë¹„íŠ¸ & ì½”ë±

- 64ë¹„íŠ¸ í™˜ê²½ì—ì„œëŠ” **ì¼ë¶€ VfW ì½”ë±ì´ ì œê³µë˜ì§€ ì•Šì„ ìˆ˜** ìˆìŠµë‹ˆë‹¤.
  - ì´ ê²½ìš° **Uncompressed** ë˜ëŠ” **MJPG** ì™€ ê°™ì€ ë²”ìš© ì½”ë± ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤.
- ìµœì‹  API(Media Foundation)ë¡œë„ êµ¬í˜„ ê°€ëŠ¥í•˜ì§€ë§Œ, **ë ˆê±°ì‹œ AVI** í˜¸í™˜ê³¼ ê°„í¸ì„±ì„ ìœ„í•´ ë³¸ ì¥ì—ì„œëŠ” **VfW** ë¥¼ ì±„íƒí–ˆìŠµë‹ˆë‹¤.

### í”½ì…€ í¬ë§· ì°¨ì´

- `AVIStreamGetFrame` ì´ ë°˜í™˜í•˜ëŠ” DIBì€ **bottom-up** ì¸ ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤.
  - `biHeight>0` ì´ë©´ bottom-upì´ë¯€ë¡œ ìœ„ ì½”ë“œì²˜ëŸ¼ yë¥¼ ë’¤ì§‘ì–´ ë³µì‚¬.
- 24bppëŠ” **BGR**, 32bppëŠ” **BGRA** ë¼ëŠ” ì ì„ ìŠì§€ ë§ˆì„¸ìš”.

### MJPG í’ˆì§ˆ/ìš©ëŸ‰ íŠ¸ë ˆì´ë“œì˜¤í”„

- `AVICOMPRESSOPTIONS.dwQuality` ëŠ” `0~10000` ë²”ìœ„ë¥¼ ì‚¬ìš©(ì—¬ê¸°ì„œëŠ” 0~100ì—ì„œ ë³€í™˜).
- **í’ˆì§ˆâ†‘ â†’ ìš©ëŸ‰â†‘**, ë°˜ëŒ€ë¡œ í’ˆì§ˆì´ ë‚®ìœ¼ë©´ ë¸”ë¡/ë§ì‰ ë“± ì••ì¶• ì•„í‹°íŒ©íŠ¸ ê°€ëŠ¥.

### ì„±ëŠ¥

- **ì½ê¸°**: `AVIStreamGetFrame` ì€ ë‚´ë¶€ ë””ì½”ë”©ì„ ìˆ˜í–‰í•˜ë¯€ë¡œ, ì„ì˜ ì ‘ê·¼ ì‹œ **ì½”ë± ì”¬í¬ ë¹„ìš©**ì´ ìˆìŠµë‹ˆë‹¤.
  - ìˆœì°¨ ì ‘ê·¼ì´ ë¹ ë¥´ë©°, ëœë¤ ì ‘ê·¼ì„ ìì£¼ í•˜ë©´ ìºì‹± ì „ëµì„ ê³ ë ¤í•˜ì„¸ìš”.
- **ì“°ê¸°**: ë¹„ì••ì¶•ì€ ë¹ ë¥´ì§€ë§Œ ìš©ëŸ‰ì´ í¼. MJPGëŠ” CPU ì••ì¶• ë¹„ìš©ì´ ë¶™ìŠµë‹ˆë‹¤.

### ì˜¤ë””ì˜¤

- ë³¸ ì¥ì€ **ë¹„ë””ì˜¤ ì „ìš©**. ì˜¤ë””ì˜¤ê¹Œì§€ ë‹¤ë£¨ë ¤ë©´ `streamtypeAUDIO` ë¡œ ë³„ë„ ìŠ¤íŠ¸ë¦¼ì„ ì¶”ê°€/ì½ê¸° í•´ì•¼ í•©ë‹ˆë‹¤(ì¶”ê°€ `strh/strf`).

---

## í†µí•© â€” ë©”ë‰´/ëª…ë ¹(ì„ íƒ)

ë‹¤ìŒ ë‘ ë©”ë‰´ë¥¼ ì¶”ê°€í•´ ë¹ ë¥´ê²Œ ì‹¤í—˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

- **File â†’ Open AVIâ€¦** : `StartPlay(path, hView)` í˜¸ì¶œ
- **File â†’ Export AVIâ€¦** : BMP ì‹œí€€ìŠ¤/í˜„ì¬ ì°½ì˜ í”„ë ˆì„ë“¤ì„ AVIë¡œ ë‚´ë³´ë‚´ê¸°

ë¦¬ì†ŒìŠ¤/ëŒ€í™” ìƒìëŠ” ì´ì „ ì¥ì˜ íŒ¨í„´ê³¼ ë™ì¼í•˜ë¯€ë¡œ ìƒëµí•©ë‹ˆë‹¤.

---

## í…ŒìŠ¤íŠ¸ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] ì„œë¡œ ë‹¤ë¥¸ í•´ìƒë„ì˜ AVIë¥¼ ì—´ì–´ í¬ê¸°/FPS/ì´ í”„ë ˆì„ì´ ì˜¬ë°”ë¥¸ì§€ í™•ì¸
- [ ] í”„ë ˆì„ 0, ì¤‘ê°„, ë§ˆì§€ë§‰ í”„ë ˆì„ì„ ì½ì–´ **ìƒ‰ìƒ/ìœ„ì•„ë˜ ë’¤ì§‘í˜** ë¬¸ì œ ì—†ë‚˜ í™•ì¸
- [ ] ë¹„ì••ì¶• / MJPG ê°ê°ìœ¼ë¡œ ì €ì¥í•œ ë’¤, ì™¸ë¶€ í”Œë ˆì´ì–´ì—ì„œ ì •ìƒ ì¬ìƒë˜ëŠ”ì§€ í™•ì¸
- [ ] íƒ€ì´ë¨¸ ì¬ìƒ ì‹œ FPS ì— ë§ì¶° ë¶€ë“œëŸ½ê²Œ ì¬ìƒë˜ëŠ”ì§€ í™•ì¸

---

## ìš”ì•½

- AVIëŠ” **RIFF** ê¸°ë°˜ ì»¨í…Œì´ë„ˆë¡œ, `hdrl`/`movi`/`idx1` êµ¬ì¡°ë¥¼ ê°–ìŠµë‹ˆë‹¤.
- Windows **VfW** APIë¥¼ ì‚¬ìš©í•˜ë©´ **ê°„ë‹¨í•˜ê³  ì•ˆì •ì ìœ¼ë¡œ** AVI **ì½ê¸°/ì“°ê¸°**ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ë³¸ ì¥ì˜ `IppAvi` ëŠ”
  - ì½ê¸°: `openRead` â†’ `readFrame(n, IppDib&)`
  - ì“°ê¸°: `beginWrite` â†’ `writeFrame` ë°˜ë³µ â†’ `endWrite`
  - ì½”ë±: **Uncompressed** / **MJPG**
  - `IppDib`(top-down BGRA32)ê³¼ **ìƒí˜¸ ë³€í™˜**ê¹Œì§€ í¬í•¨í•©ë‹ˆë‹¤.
- ì´ í´ë˜ìŠ¤ë¥¼ ë°”íƒ•ìœ¼ë¡œ **í”„ë ˆì„ ê¸°ë°˜ ì˜ìƒ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸**(í•„í„°ë§/ê²€ì¶œ/ì¶”ì )ì„ AVI ì…ì¶œë ¥ê³¼ **ìì—°ìŠ¤ëŸ½ê²Œ ì—°ê²°**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ğŸš€
