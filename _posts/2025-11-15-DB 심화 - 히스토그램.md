---
layout: post
title: DB 심화 - 히스토그램
date: 2025-11-15 21:25:23 +0900
category: DB 심화
---
# 히스토그램(Oracle)

> 실행 후에는 항상 아래로 **실측 플랜**을 확인하세요.
```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'
));
```

---

## 0) 실습 스키마 & 데이터 준비(스큐/NULL 포함)
```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

-- 깨끗이
BEGIN EXECUTE IMMEDIATE 'DROP TABLE CUST PURGE'; EXCEPTION WHEN OTHERS THEN NULL; END; /
BEGIN EXECUTE IMMEDIATE 'DROP TABLE PROD PURGE'; EXCEPTION WHEN OTHERS THEN NULL; END; /
BEGIN EXECUTE IMMEDIATE 'DROP TABLE ORD  PURGE'; EXCEPTION WHEN OTHERS THEN NULL; END; /

-- 고객/상품/주문
CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(8),           -- 스큐 + 일부 NULL
  TIER    VARCHAR2(8)            -- VIP/GOLD/SILVER/GEN
);

CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12),         -- ELEC/FOOD/TOY/HOME/FASH
  BRAND    VARCHAR2(12)          -- 스큐: 'B0' 다수, 그 외 B01~B59
);

CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  ORDER_DT DATE   NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL
);

-- 인덱스
CREATE INDEX IX_CUST_REGION   ON CUST(REGION, CUST_ID);
CREATE INDEX IX_PROD_CAT_BR   ON PROD(CATEGORY, BRAND, PROD_ID);
CREATE INDEX IX_ORD_CUST_DT   ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_ORD_PROD_DT   ON ORD(PROD_ID, ORDER_DT);

-- 데이터 주입(스큐/NULL 반영)
BEGIN
  FOR c IN 1..30000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,6)
        WHEN 0 THEN 'KOR' WHEN 1 THEN 'KOR'           -- 'KOR' 편중(≈ 2/6)
        WHEN 2 THEN 'APAC' WHEN 3 THEN 'EMEA'
        WHEN 4 THEN 'AMER' ELSE NULL                  -- 일부 NULL
      END,
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
                    WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..12000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD'
                    WHEN 2 THEN 'TOY'  WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 4000 THEN 'B0' ELSE 'B'||LPAD(TO_CHAR(MOD(p,60)),2,'0') END
    );
  END LOOP;

  FOR o IN 1..180000 LOOP
    INSERT INTO ORD VALUES(
      o,
      MOD(o,30000)+1,
      MOD(o,12000)+1,
      DATE '2024-01-01' + MOD(o,365),
      ROUND(DBMS_RANDOM.VALUE(10,700),2)
    );
  END LOOP;
  COMMIT;
END;
/

-- 초기 통계(히스토그램 없이 SIZE 1)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
END;
/
```

---

# 1. 히스토그램이란? (왜 필요인가)
옵티마이저는 **카디널리티(Cardinality)**, 즉 “조건을 만족하는 **예상 행수**”를 추정해 **실행계획**(조인 순서/방법/엑세스 경로)을 고릅니다.  
히스토그램은 **컬럼 값의 분포**를 통계적으로 담아 **선택도(Selectivity)** 추정을 정교화합니다.

- **스큐(skew)**가 없고 균등 분포면:  
  $$ \text{Selectivity}(col = v) \approx \frac{1}{\text{NDV}(col)} $$
  $$ \Rightarrow \text{Cardinality} \approx \text{NUM\_ROWS} \times \frac{1}{\text{NDV}} $$
- **스큐가 크면** 위 추정은 크게 틀립니다. 히스토그램이 필요합니다.

> 참고: 일반적으로 B*Tree 인덱스는 **모든 인덱스 컬럼이 NULL인 값**을 저장하지 않습니다(예외: FBI 등).  
> 따라서 `IS NULL` 조건은 히스토그램과 별개로 **인덱스 미사용**일 수 있습니다.

---

# 2. 히스토그램 유형 개요
Oracle은 버전에 따라 내부 구현이 조금씩 진화했지만, 개념적으로는 다음을 이해하면 충분합니다.

1) **도수분포(Frequency) 히스토그램**  
   - **카테고리형**(NDV가 작거나 상위 빈도만 필요한) 컬럼에 적합.  
   - **값별 빈도**(버킷=값)에 근거해 **정확한 선택도**를 제공합니다.  
   - **Top-Frequency**: 빈도가 높은 **상위 일부 값**만 도수분포로, 나머지는 밀도(density)로 근사.

2) **높이균형(Height-Balanced) / 하이브리드(Hybrid) 히스토그램**  
   - 연속형/NDV가 큰 컬럼에 적합.  
   - 버킷 간 **행 개수(높이)**를 비슷하게 맞추는(또는 근사) 방식으로 분포를 기록.  
   - **HYBRID**는 12c 이후 도입된 진화형으로, 범위/동일조건의 선택도를 더 자연스럽게 추정.

**어떤 유형이 생성되는가?**  
- `method_opt`를 `SIZE AUTO/SKEWONLY/254` 등으로 지정하면 Oracle이 **데이터 분포·NDV·버킷 수 한도**를 고려해 유형을 자동 결정합니다.  
- 결과는 `USER_TAB_COL_STATISTICS.HISTOGRAM` 컬럼(FREQUENCY / TOP-FREQUENCY / HEIGHT BALANCED / HYBRID)에서 확인.

---

# 3. 도수분포(Frequency) 히스토그램 — 실습

## 3.1 스큐가 큰 컬럼(예: `PROD.BRAND`)에 히스토그램 생성
```sql
-- BRAND에 도수분포 히스토그램 생성(최대 254 버킷)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND'  -- 필요 컬럼만 정밀
  );
END;
/

-- 생성 결과 확인
SELECT column_name, num_distinct, num_nulls, histogram, density, last_analyzed
FROM   user_tab_col_statistics
WHERE  table_name='PROD' AND column_name IN ('BRAND');
```

## 3.2 히스토그램 효과 관찰(카디널리티/E-Rows 변화)
```sql
-- 대량값(B0) vs 희소값(B47) 비교
EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**기대 효과**  
- `BRAND='B0'` → **E-Rows(예상 행수)** ↑ → **풀스캔/FFS** 선호 가능  
- `BRAND='B47'` → **E-Rows** ↓ → **인덱스 범위 스캔** 선호 가능

> 히스토그램이 없었다면 두 값 모두 $$\frac{1}{\text{NDV}}$$ 정도로 동일하게 취급되어 **같은 플랜**이 나올 수 있습니다.

## 3.3 Top-Frequency(상위 빈도만) 시나리오
데이터에 상위 소수 값만 매우 빈번하고 나머지는 드문 경우, Oracle은 **Top-Frequency**를 생성할 수 있습니다(자동).  
- 상위 값에는 **정확한 빈도**, 그 외 값은 **density**로 근사.  
- 보고/배치 쿼리에서 **상위값 조건**의 플랜 안정성이 좋아집니다.

---

# 4. 높이균형/하이브리드 히스토그램 — 실습

## 4.1 연속형 분포(예: `ORD.AMOUNT`)에 히스토그램 생성
```sql
-- 금액 컬럼에 히스토그램(유형은 Oracle이 결정: HYBRID/HEIGHT BALANCED 등)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'ORD',
    method_opt => 'FOR COLUMNS SIZE 254 AMOUNT'
  );
END;
/

SELECT column_name, histogram, num_distinct, density
FROM   user_tab_col_statistics
WHERE  table_name='ORD' AND column_name='AMOUNT';
```
`HISTOGRAM` 값이 **HYBRID** 또는 **HEIGHT BALANCED**로 나타날 수 있습니다(버전·분포·버킷 수에 따라 결정).

## 4.2 동등/범위 조건에서의 추정 비교
```sql
-- 동등 조건: 특정 금액(연속형에선 희소) → 매우 작은 선택도 기대
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM ORD WHERE AMOUNT = 123.45;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 범위 조건: 구간에 따라 선택도 차이가 커짐
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM ORD WHERE AMOUNT BETWEEN 10 AND 100;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT COUNT(*) FROM ORD WHERE AMOUNT BETWEEN 500 AND 700;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**관찰 포인트**  
- 하이브리드/높이균형은 **구간별 누적분포**를 근사해 **E-Rows**가 구간마다 달라집니다.  
- 히스토그램이 없다면 두 범위의 E-Rows 차이가 **현저히 덜 민감**했을 수 있습니다.

---

# 5. 바인드 변수 사용 시 카디널리티 계산 (피킹/ACS)

## 5.1 기본 개념
- **바인드 변수**는 커서 공유/플랜 재사용에 유리하지만, **값마다 선택도**가 크게 달라지는 컬럼(스큐)에선 **카디널리티 오판**을 부르기 쉽습니다.
- **Bind Peeking**: 첫 하드파싱 시 **바인드 값**을 **엿보아(peek)** 그 값에 맞는 히스토그램 선택도를 사용해 플랜을 고릅니다.
- **Adaptive Cursor Sharing(ACS)**: 실행 후, 바인드 값 패턴에 따라 **child cursor**를 분기해 **다른 플랜**으로 학습/적응.

## 5.2 실습: 동일 커서, 다른 바인드 값 → 플랜 미스매치
```sql
ALTER SYSTEM FLUSH SHARED_POOL;

VARIABLE b_brand VARCHAR2(12);

-- 1) 희소값으로 첫 파싱(인덱스 경로 가능)
EXEC :b_brand := 'B47';
SELECT /* peek-rare */ COUNT(*) FROM PROD WHERE BRAND = :b_brand;

-- 2) 동일 커서를 대량값으로 실행(여전히 인덱스 경로일 수 있음 → I/O 폭증)
EXEC :b_brand := 'B0';
SELECT /* reuse-heavy */ COUNT(*) FROM PROD WHERE BRAND = :b_brand;

-- 피킹된 바인드와 실제 카디널리티/플랜을 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS'));
```
**현상**  
- 1회차(희소값) 기준으로 **인덱스 범위 스캔** 플랜이 고정 → 2회차(대량값)에서도 **부적절한 재사용** 가능.  
- 이후 반복 실행/피드백으로 **ACS**가 동작하면, 값 구간에 따라 **서로 다른 child cursor**(플랜)를 분기합니다.

## 5.3 히스토그램이 없을 때(균등/밀도 가정)
- 바인드 사용 + 히스토그램 없음이면 선택도는 보통 **density(≈1/NDV)** 근사.  
- 값별 차이를 반영 못 해 **평균적 플랜**이 됩니다(특정 값엔 불리).

## 5.4 운영 팁
- 스큐 컬럼의 바인드 사용은 **주요 값군**(대량/희소)이 명확하면 **SQL 분리(리터럴)**도 고려.  
- 히스토그램 + ACS가 잘 학습되게 **반복 실행/피드백**을 허용.  
- 중요한 SQL은 **SQL Profile/Baseline**으로 안정화.

---

# 6. 결합 선택도(다중 조건/상관관계)

## 6.1 독립 가정의 한계
두 조건이 독립이면:
$$ \text{Sel}(A \land B) \approx \text{Sel}(A) \times \text{Sel}(B) $$
하지만 현실 데이터는 **상관관계**가 큽니다(예: `REGION='KOR'`일 때 `TIER='VIP'` 비율이 높다/낮다).

## 6.2 실습: 결합 선택도 오판 → 확장 통계로 보정
```sql
-- 확장 통계 없이 추정(E-Rows 관찰)
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   CUST
WHERE  REGION='KOR' AND TIER='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- (REGION, TIER) 확장 통계 생성 → 상관관계 반영
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/

-- 동일 쿼리 재실행(E-Rows 변화 관찰)
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   CUST
WHERE  REGION='KOR' AND TIER='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**중요 포인트**  
- 확장 통계는 **다중 컬럼 그룹의 분포/NDV**를 반영해 **결합 선택도**를 개선.  
- **다중 컬럼 히스토그램**은 별도로 존재하지 않습니다(일반적으론 **그룹 통계**로 보정).

## 6.3 조인까지 포함된 카디널리티 체인
```sql
EXPLAIN PLAN FOR
SELECT SUM(o.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
WHERE  c.region='KOR' AND c.tier='VIP'
AND    o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
- 결합 선택도 오판은 **조인 순서/방법**을 크게 흔들어 **Temp 폭증**이나 **랜덤 I/O 증가**로 이어질 수 있습니다.

---

# 7. 히스토그램 운용 베스트 프랙티스

## 7.1 언제 만들까?
- **스큐가 큰 컬럼**(상위값/드문값 차이 큼)  
- **보고서/배치의 where 조건**에 **자주 등장**  
- **바인드 값**에 따라 플랜 차이가 큰 컬럼

## 7.2 얼마나 만들까?
- 남발은 금물. 히스토그램은 **플랜 변동성**을 높일 수 있습니다(값별로 플랜이 달라짐).  
- **Top-Frequency**/`SIZE AUTO`로 **필요한 컬럼에만**, 변화가 잦은 파티션은 **증분 통계**와 함께.

## 7.3 자주 쓰는 DBMS_STATS 설정
```sql
-- 스키마 전체 기본: AUTO(필요 컬럼에만 히스토그램), 인덱스 포함
BEGIN
  DBMS_STATS.GATHER_SCHEMA_STATS(
    ownname    => USER,
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt => 'FOR ALL COLUMNS SIZE AUTO',
    cascade    => TRUE
  );
END;
/

-- 특정 컬럼만 정밀(FREQUENCY/Top-Frequency/HYBRID은 Oracle이 선택)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND, FOR ALL COLUMNS SIZE 1'
  );
END;
/

-- 변경이 잦은 파티션 테이블에서 증분 통계(개념)
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','INCREMENTAL','TRUE');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD', granularity=>'AUTO', cascade=>TRUE);
END;
/
```

---

# 8. 문제 재현 → 진단 → 해법: 미니 시나리오

### 시나리오 A: `BRAND='B0'`에서 인덱스 스캔이 잡혀 느리다
1) **증상**: E-Rows가 너무 작아 **Index Range Scan** 선택 → 튜플 많아 **랜덤 I/O 폭증**  
2) **진단**: `USER_TAB_COL_STATISTICS`에서 `BRAND` 히스토그램 없음/부정확  
3) **해법**: `BRAND`에 히스토그램 생성(도수분포/Top-Frequency). 필요 시 **FFS 유도** 힌트나 Baseline 임시 적용.  
4) **추가**: 바인드 사용 시 **ACS 학습** 또는 **SQL 분리** 검토.

### 시나리오 B: `REGION='KOR' AND TIER='VIP'`가 특정 버전/릴리스에서 갑자기 느려짐
1) **증상**: 결합 선택도 과대/과소 추정 → 조인 순서 변경  
2) **진단**: 확장 통계 없음, 또는 통계 노후화  
3) **해법**: `(REGION,TIER)` 확장 통계 + 최신 통계 수집. 필요 시 **LEADING/USE_*** 최소 힌트로 보호.  
4) **추가**: 업그레이드 시 **SQL Baseline**으로 플랜 안정화.

### 시나리오 C: 바인드 하나로 값군이 극단적으로 달라지는 리포트
1) **증상**: 첫 실행 값에 따른 피킹 플랜 고정 → 다음 실행에서 성능 급락  
2) **진단**: `DISPLAY_CURSOR + PEEKED_BINDS`로 피킹 값 확인  
3) **해법**: 히스토그램 + **반복 실행**으로 ACS 유도, 또는 **리터럴 분리**. 중요 구간은 **Baseline**.

---

# 9. 참고 수식(개념)
- **등치(EQ)**, 히스토그램 없을 때:  
  $$ \text{Sel}(col = v) \approx \text{density} \ (\approx 1/\text{NDV}) $$
- **등치(EQ)**, 도수분포 히스토그램:  
  $$ \text{Sel}(col = v) \approx \frac{\text{count}(v)}{\text{NUM\_ROWS}} $$
- **범위(RANGE)**, 하이브리드/높이균형:  
  $$ \text{Sel}(a \le col < b) \approx F(b) - F(a) $$
  여기서 \(F(x)\)는 **누적분포**의 근사(버킷 경계와 높이 정보로 계산).  
- **결합(AND)**, 독립 가정(보정 전):  
  $$ \text{Sel}(A\land B) \approx \text{Sel}(A)\times \text{Sel}(B) $$

---

# 10. 마무리 체크리스트
- [ ] 스큐 큰 컬럼에 **히스토그램**(도수분포/Top-Frequency, 또는 HYBRID).  
- [ ] **바인드** + 스큐 컬럼: **ACS**/프로파일/베이스라인/리터럴 분리 고려.  
- [ ] 결합 선택도 문제: **확장 통계(컬럼 그룹)**로 보정.  
- [ ] 히스토그램은 **필요한 컬럼만**, 남발 금지(플랜 변동성↑).  
- [ ] 변경 많은 테이블/파티션: **증분 통계**, **Pending Stats**로 검증 배포.  
- [ ] 모든 변경은 **E-Rows vs A-Rows**로 실측 검증.

---

## 부록 A. 점검/관찰 SQL 모음
```sql
-- 1) 컬럼 통계/히스토그램 확인
SELECT table_name, column_name, histogram, num_distinct, num_nulls, density, last_analyzed
FROM   user_tab_col_statistics
WHERE  table_name IN ('CUST','PROD','ORD')
ORDER  BY table_name, column_name;

-- 2) 확장 통계(컬럼 그룹) 확인
SELECT table_name, extension_name, extension, creator, droppable
FROM   user_stat_extensions
WHERE  table_name IN ('CUST','ORD');

-- 3) 실행 후 플랜/바인드 피킹 관찰
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
  'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'));
```

## 부록 B. 히스토그램 빠른 적용/철회
```sql
-- 적용: 특정 컬럼만 254 버킷
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    method_opt=>'FOR COLUMNS SIZE 254 BRAND');
END;
/

-- 철회: 히스토그램 제거(균등 가정으로 회귀)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    method_opt=>'FOR COLUMNS SIZE 1 BRAND');
END;
/
```

---

### 결론
히스토그램은 **값 분포**를 옵티마이저에게 알려 **선택도/카디널리티**를 현실화합니다.  
- **도수분포/Top-Frequency**로 **카테고리형 스큐**를,  
- **높이균형/하이브리드**로 **연속형/범위 분포**를,  
- **확장 통계**로 **결합 선택도**를,  
- **ACS/프로파일/베이스라인**으로 **바인드·플랜 안정성**을 보완하세요.  
항상 **E-Rows vs A-Rows**로 사실을 확인하며, 필요한 최소한의 히스토그램만 유지하는 것이 **안정적 성능**의 지름길입니다.