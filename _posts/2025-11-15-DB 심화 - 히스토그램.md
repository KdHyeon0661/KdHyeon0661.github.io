---
layout: post
title: DB 심화 - 히스토그램
date: 2025-11-15 21:25:23 +0900
category: DB 심화
---
# 히스토그램(Oracle)

## 실행 플랜 실측: 튜닝의 기초

히스토그램 튜닝은 데이터의 분포에 대한 이해 없이는 감에 의존하게 됩니다. 이를 체계적으로 분석하기 위해 다음 실행 플랜 옵션을 활용하세요.

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS +ALIAS +NOTE'
));
```

핵심 분석 포인트는 세 가지입니다:
*   `E-Rows`(추정 행수) vs `A-Rows`(실제 행수): 추정이 얼마나 정확한지 확인하는 근본 지표입니다.
*   `Predicate Information`의 access/filter 조건: 조건이 어떻게 적용되었는지 보여주며, 인덱스 사용 효율을 판단합니다.
*   `Notes`의 히스토그램, ACS(Adaptive Cursor Sharing), 바인드 피킹 정보: 옵티마이저의 판단 근거를 이해하는 데 필수적입니다.

---

## 히스토그램이 필요한 이유: "균등 분포"라는 가정의 한계

옵티마이저(CBO)는 **선택도(Selectivity)**를 추정하여 카디널리티를 계산하고, 이를 바탕으로 최적의 조인 순서, 조인 방법, 액세스 경로를 결정합니다.

### 히스토그램이 없을 때의 기본 가정
데이터 분포가 고르고 편향(Skew)이 없다고 가정하면 선택도는 다음과 같이 계산됩니다.
*   동등 조건: `선택도 ≈ 밀도(density) ≈ 1 / NDV(고유 값 수)`
*   카디널리티: `추정 행수 ≈ 총 행수(NUM_ROWS) × 선택도`

그러나 실제 비즈니스 데이터는 대부분 편향, 상관관계, 특정 구간 집중 현상을 보입니다. 이러한 "균등 가정"이 깨지면 `E-Rows`가 현저히 틀어지고, 결과적으로 잘못된 실행 계획이 선택되어 성능이 저하됩니다.

### 히스토그램의 역할
히스토그램은 컬럼 값의 분포를 **버킷(Bucket)** 이라는 단위로 요약하여 저장합니다. 이를 통해 옵티마이저가 특정 값이나 범위에 대한 **현실적인 선택도**를 계산할 수 있게 해줍니다. Oracle은 데이터 분포, NDV, 지정된 버킷 수에 따라 `FREQUENCY`, `TOP-FREQUENCY`, `HYBRID`, `HEIGHT BALANCED`(레거시) 히스토그램 유형 중 하나를 자동으로 선택합니다.

---

## 통계 체인에서의 히스토그램 위치

히스토그램은 컬럼 통계의 한 부분으로, 최종적인 선택도 보정을 담당합니다.

```
테이블 통계 (NUM_ROWS, BLOCKS, AVG_ROW_LEN ...)
   └─ 컬럼 통계 (NDV, DENSITY, NUM_NULLS, LOW/HIGH_VALUE ...)
        └─ 히스토그램 (버킷 정보: 엔드포인트, 반복 횟수 등)
             └─ 선택도 추정 보정
                  └─ 카디널리티(E-Rows) 보정
                       └─ 최종 실행 계획 선택
```

*   NDV와 Density는 컬럼 전체의 '평균적' 선택도를 제공합니다.
*   히스토그램은 각 값이나 구간별 '정밀한' 선택도를 제공합니다.
따라서 히스토그램은 부정확한 평균 가정을 마지막 단계에서 수정하는 **정밀 보정 장치**의 역할을 합니다.

---

## 실습 환경 구성 (편향 데이터 포함)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

-- 기존 테이블 정리
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE cust PURGE';
    EXCEPTION WHEN OTHERS THEN NULL;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE prod PURGE';
    EXCEPTION WHEN OTHERS THEN NULL;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE ord  PURGE';
    EXCEPTION WHEN OTHERS THEN NULL;
END;
/

-- 테이블 생성
CREATE TABLE cust(
  cust_id NUMBER PRIMARY KEY,
  region  VARCHAR2(8),   -- 데이터 편향 + 일부 NULL 존재
  tier    VARCHAR2(8)
);

CREATE TABLE prod(
  prod_id  NUMBER PRIMARY KEY,
  category VARCHAR2(12),
  brand    VARCHAR2(12)  -- 'B0' 브랜드로 심한 편향 생성
);

CREATE TABLE ord(
  order_id NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL,
  prod_id  NUMBER NOT NULL,
  order_dt DATE   NOT NULL,
  amount   NUMBER(12,2) NOT NULL -- 연속형 데이터
);

-- 인덱스 생성
CREATE INDEX ix_cust_region ON cust(region, cust_id);
CREATE INDEX ix_prod_cat_br ON prod(category, brand, prod_id);
CREATE INDEX ix_ord_cust_dt ON ord(cust_id, order_dt);
CREATE INDEX ix_ord_prod_dt ON ord(prod_id, order_dt);

-- 편향 데이터 삽입
BEGIN
  -- CUST: region='AMER'이 1/3을 차지하며, 일부 NULL 포함
  FOR c IN 1..30000 LOOP
    INSERT INTO cust VALUES(
      c,
      CASE MOD(c,6)
        WHEN 0 THEN 'AMER' WHEN 1 THEN 'AMER'
        WHEN 2 THEN 'EMEA' WHEN 3 THEN 'LATAM'
        WHEN 4 THEN 'NA'   ELSE NULL
      END,
      CASE MOD(c,4)
        WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  -- PROD: 브랜드 'B0'가 4000개(약 33%)로 집중됨
  FOR p IN 1..12000 LOOP
    INSERT INTO prod VALUES(
      p,
      CASE MOD(p,5)
        WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD'
        WHEN 2 THEN 'TOY'  WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 4000 THEN 'B0'
           ELSE 'B'||LPAD(TO_CHAR(MOD(p,60)),2,'0') END
    );
  END LOOP;

  -- ORD: 주문 데이터
  FOR o IN 1..180000 LOOP
    INSERT INTO ord VALUES(
      o,
      MOD(o,30000)+1,
      MOD(o,12000)+1,
      DATE '2024-01-01' + MOD(o,365),
      ROUND(DBMS_RANDOM.VALUE(10,700),2)
    );
  END LOOP;
  COMMIT;
END;
/

-- 초기 통계 수집 (히스토그램 없이)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
END;
/
```

---

## Oracle 히스토그램의 4가지 유형과 선택 기준

### 1. Frequency 히스토그램
*   **조건**: 컬럼의 고유 값 수(NDV)가 허용된 버킷 수(n, 기본 254) 이하일 때 생성됩니다.
*   **특징**: 각 고유 값이 정확히 하나의 버킷을 차지합니다. 도수분포표와 같아, 특정 값(`v`)의 선택도를 `count(v) / NUM_ROWS`로 정확히 계산할 수 있습니다. 카테고리형 컬럼이나 NDV가 작은 컬럼에 이상적입니다.

### 2. Top-Frequency 히스토그램
*   **조건**: NDV > n 이지만, 상위 n개의 인기 값이 전체 행의 대부분(p%)을 차지할 때 생성됩니다. `AUTO_SAMPLE_SIZE`로 수집될 때 이 로직이 적용됩니다.
*   **특징**: 상위 인기 값들에 대해서는 Frequency 히스토그램처럼 정확한 빈도를 기록하고, 나머지 비인기 값들에 대해서는 평균 밀도(Density)를 사용하여 추정합니다. 인기 값 조건의 카디널리티 추정 정확도를 극적으로 높여줍니다.

### 3. Hybrid 히스토그램 (12c 이상 표준)
*   **조건**: NDV > n 이지만, 상위 n개 값이 대부분을 차지하지 않아 Top-Frequency 조건을 만족하지 않을 때 생성됩니다. `AUTO_SAMPLE_SIZE` 사용 시 일반적입니다.
*   **특징**: 인기 값은 반복 횟수(`REPEAT_COUNT`)를 기록하고, 비인기 값들은 값의 순서와 누적 분포를 유지하며 버킷에 묶습니다. 이로 인해 **동등 조건과 범위 조건 모두**에 대해 현실적인 추정이 가능해집니다. 현대 Oracle 버전(19c, 21c, 23ai)에서 사실상 주력 히스토그램 유형입니다.

### 4. Height-Balanced 히스토그램 (레거시)
*   Oracle 11g까지 NDV > n인 컬럼의 기본 유형이었습니다. 각 버킷이 비슷한 수의 행을 포함하도록 경계를 나눕니다.
*   12c 이상에서는 `AUTO_SAMPLE_SIZE`로 새로 수집하면 Top-Freq 또는 Hybrid로 생성되며, 기존 Height-Balanced 히스그램은 통계를 재수집하면 새로운 유형으로 교체됩니다.

---

## 히스토그램 유형 결정 로직

| 조건 | 결과 히스토그램 유형 |
|---|---|
| NDV ≤ n | FREQUENCY |
| NDV > n AND `estimate_percent` ≠ AUTO_SAMPLE_SIZE | HEIGHT BALANCED (또는 FREQUENCY) |
| NDV > n AND `estimate_percent` = AUTO_SAMPLE_SIZE AND 상위 n개 값 점유율 ≥ p% | TOP-FREQUENCY |
| NDV > n AND `estimate_percent` = AUTO_SAMPLE_SIZE AND 상위 n개 값 점유율 < p% | HYBRID |

이 로직 때문에 `AUTO_SAMPLE_SIZE`를 사용하면 대부분 최신 유형(Top-Freq/Hybrid)이 생성되며, 수동 샘플링 비율을 지정하면 레거시 유형이 다시 나타날 수 있습니다.

---

## 히스토그램 메타정보 확인

### 컬럼 통계 조회
```sql
SELECT table_name, column_name,
       num_distinct, num_nulls, density,
       histogram, num_buckets, last_analyzed
FROM   user_tab_col_statistics
WHERE  table_name IN ('CUST','PROD','ORD')
ORDER  BY table_name, column_name;
```
*   `HISTOGRAM` 컬럼에 위 4가지 유형 중 하나가 표시됩니다.
*   `NUM_BUCKETS`는 실제 생성된 버킷 수입니다.

### 히스토그램 상세 데이터 조회
```sql
SELECT table_name, column_name,
       endpoint_number, endpoint_value,
       endpoint_repeat_count
FROM   user_histograms
WHERE  table_name='PROD' AND column_name='BRAND'
ORDER  BY endpoint_number;
```
*   `ENDPOINT_NUMBER`: 누적 행 수 (누적 빈도).
*   `ENDPOINT_VALUE`: 해당 버킷의 경계 값.
*   `ENDPOINT_REPEAT_COUNT` (Hybrid 핵심): 해당 버킷의 마지막 값이 몇 번 반복되는지 기록합니다. 이를 통해 인기 값을 식별합니다.

---

## 실습 1: 편향된 카테고리 컬럼에 히스토그램 생성 및 효과 관찰

### BRAND 컬럼에 히스토그램 생성
```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND, FOR ALL COLUMNS SIZE 1'
  );
END;
/
```

### 생성 전후 실행 계획 비교
**히스토그램 생성 전**: `brand='B0'`(인기값)과 `brand='B47'`(비인기값)에 대한 선택도 추정이 동일한 Density(≈1/NDV)를 사용하여 비슷할 것입니다. 둘 다 인덱스 스캔을 선택하거나, 둘 다 풀 테이블 스캔을 선택하는 등 비효율이 발생할 수 있습니다.

```sql
-- 히스토그램 생성 후 인기 값 조회
EXPLAIN PLAN FOR SELECT COUNT(*) FROM prod WHERE brand='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 히스토그램 생성 후 비인기 값 조회
EXPLAIN PLAN FOR SELECT COUNT(*) FROM prod WHERE brand='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**히스토그램 생성 후 기대 효과**:
*   `brand='B0'` (인기값, 많은 행): **E-Rows가 현실적으로 증가** → 풀 테이블 스캔(Full Table Scan) 또는 빠른 풀 스캔(FFS)으로의 전환 가능성 높아짐.
*   `brand='B47'` (비인기값, 적은 행): **E-Rows가 현실적으로 감소** → 인덱스 범위 스캔(Index Range Scan) 유리.

이렇게 값별로 최적의 액세스 경로를 선택할 수 있게 됩니다.

---

## 실습 2: 연속형 컬럼에 히스토그램 생성 및 범위 조건 추정 정확도 확인

### AMOUNT 컬럼에 히스토그램 생성
```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'ORD',
    method_opt => 'FOR COLUMNS SIZE 254 AMOUNT'
  );
END;
/
```

### 범위 조건별 추정 정확도 비교
```sql
-- 특정 값 동등 조회
EXPLAIN PLAN FOR SELECT COUNT(*) FROM ord WHERE amount = 123.45;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 낮은 금대 범위 조회 (데이터가 많을 가능성)
EXPLAIN PLAN FOR SELECT COUNT(*) FROM ord WHERE amount BETWEEN 10 AND 100;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 높은 금대 범위 조회 (데이터가 적을 가능성)
EXPLAIN PLAN FOR SELECT COUNT(*) FROM ord WHERE amount BETWEEN 500 AND 700;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
*   **히스토그램 없을 때**: 두 범위 조건(`10-100`, `500-700`)이 비슷한 밀도로 추정되어 `E-Rows`가 비슷하게 나올 수 있습니다.
*   **Hybrid/Height-Balanced 히스토그램 있을 때**: 버킷별 누적 분포를 기반으로 각 범위에 포함된 실제 행 수의 비율을 더 정확히 추정합니다. 데이터가 집중된 구간과 아닌 구간의 `E-Rows` 차이가 뚜렷해집니다.

---

## 바인드 변수와 히스토그램: Bind Peeking과 Adaptive Cursor Sharing(ACS)

### 문제 상황
편향된 컬럼에 바인드 변수를 사용하는 SQL이 하드 파싱되면, 첫 번째 전달된 바인드 값(`Peeked Binds`)을 기준으로 선택도와 실행 계획이 결정됩니다. 이후 완전히 다른 특성(예: 인기값 → 비인기값)의 바인드 값이 입력되어도 동일한 자식 커서(Child Cursor)가 재사용되면 최적이 아닌 실행 계획이 계속 사용될 수 있습니다.

### 실습: Bind Peeking 및 ACS 동작 관찰
```sql
ALTER SYSTEM FLUSH SHARED_POOL;

VARIABLE b_brand VARCHAR2(12);

-- 1) 첫 번째 실행: 비인기 값으로 하드 파싱 발생
EXEC :b_brand := 'B47';
SELECT /* peek-rare */ COUNT(*) FROM prod WHERE brand = :b_brand;

-- 2) 두 번째 실행: 인기 값으로 재사용 시도
EXEC :b_brand := 'B0';
SELECT /* reuse-heavy */ COUNT(*) FROM prod WHERE brand = :b_brand;

-- 실행 계획 및 바인드 정보 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS +NOTE'
));
```
**관찰 포인트**:
1.  `PEEKED_BINDS` 섹션에서 첫 실행 시 사용된 바인드 값('B47')을 확인할 수 있습니다.
2.  `Notes` 섹션에서 `adaptive plan`, `bind-aware` 등 ACS 관련 정보를 확인합니다.
3.  인기값과 비인기값의 실행 계획 효율이 극명히 다르다면, Oracle ACS가 학습하여 서로 다른 자식 커서를 생성(`BIND_AWARE`)할 수 있습니다.

### 운영 시 고려사항
*   ACS는 학습 기반이므로, 초기 잘못된 플랜으로 인한 일부 성능 저하는 피할 수 없을 수 있습니다.
*   값의 분포 군이 명확히 나뉘고(예: 인기값 2-3개, 나머지 비인기값) SQL 실행 빈도가 높다면 히스토그램과 ACS의 조합이 효과적입니다.
*   학습 지연이나 플랜 급변 리스크가 우려된다면, 애플리케이션에서 값군별로 SQL을 분리(리터럴 사용)하거나, SQL 프로파일(SQL Profile), SQL 베이스라인(SQL Baseline)을 이용해 안정적인 플랜을 고정시키는 전략을 고려해야 합니다.

---

## 히스토그램 관련 실전 문제와 해결 방향

1.  **샘플링 오차**: 너무 낮은 샘플링 비율로 인해 실제 편향이 통계에 왜곡되어 반영될 수 있습니다. `AUTO_SAMPLE_SIZE`는 대부분의 경우 정확도와 성능의 최적 균형을 제공합니다.
2.  **구식 통계**: 데이터 분포는 시간에 따라 변합니다. 특히 편향 컬럼은 통계 주기를 적절히 관리해야 합니다.
3.  **NDV 추정 오류**: NDV 자체가 부정확하면 인기값 판단 근간이 흔들립니다. 대용량 테이블에서는 `AUTO_SAMPLE_SIZE`가 NDV 추정에도 유리합니다.
4.  **Bind Peeking 실패**: 첫 바인드 값에 의한 플랜이 이후 모든 실행에 고정될 수 있습니다. ACS 활성화와 모니터링이 필요합니다.
5.  **비-검색 가능 조건**: `WHERE UPPER(brand)=...` 또는 `WHERE brand||'X' = ...`와 같이 컬럼을 가공하면 히스토그램이 사용되지 않습니다.
6.  **조인 순서 변경**: 복잡한 쿼리에서 조인 순서가 바뀌면 히스토그램이 적용되는 Query Block이 달라져 효과가 미미할 수 있습니다.
7.  **결합 선택도 문제**: 히스토그램은 단일 컬럼 분포만 보정합니다. `WHERE region='AMER' AND tier='VIP'`와 같이 컬럼 간 강한 상관관계가 있다면, **확장 통계(Extension Statistics)** 를 생성해야 정확한 추정이 가능합니다.
8.  **과도한 히스토그램**: 불필요한 컬럼까지 히스토그램을 생성하면 실행 계획의 변동성만 증가시킬 수 있습니다.
9.  **버전 업그레이드 영향**: 11g의 Height-Balanced 히스토그램이 12c 이상에서 통계 재수집 시 Hybrid/Top-Frequency로 교체되면서 실행 계획이 변경될 수 있습니다.
10. **파티션 테이블**: 글로벌 통계만 보고 판단할 경우, 파티션별로 분포가 다르다면 잘못된 파티션 프루닝(Pruning) 결정을 내릴 수 있습니다. 파티션 레벨의 통계 관리가 중요합니다.

---

## 확장 통계: 히스토그램의 한계를 넘어서는 상관관계 보정

히스토그램은 단일 컬럼의 분포만을 다룹니다. 두 개 이상의 컬럼이 서로 상관관계가 있을 때(예: `region`과 `tier`), 옵티마이저는 기본적으로 각 컬럼의 선택도를 독립적으로 가정하여 곱합니다. 이는 현실과 괴리될 수 있습니다.

### 실습: 확장 통계 생성 및 효과 확인
```sql
-- 확장 통계 생성 전 실행 계획 확인
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   cust
WHERE  region='AMER' AND tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- (REGION, TIER) 컬럼 그룹에 대한 확장 통계 생성
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/

-- 확장 통계 생성 후 실행 계획 다시 확인
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   cust
WHERE  region='AMER' AND tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
확장 통계는 컬럼 그룹에 대한 결합 NDV(Joint NDV)와 분포 정보를 수집합니다. 이를 통해 옵티마이저는 `region='AMER'` 이면서 `tier='VIP'`인 행의 비율을 더 정확히 추정할 수 있습니다. 단일 컬럼 히스토그램만으로는 해결되지 않는 과소/과대 추정 문제를 해결하는 핵심 도구입니다.

---

## 히스토그램 운영을 위한 핵심 가이드라인

### 1. 생성 기준: 정말 필요한 컬럼에만
*   **데이터 분포 편향(Skew)**이 심한 컬럼
*   **WHERE, JOIN 조건**에 자주 사용되며 성능에 중요한 컬럼
*   **바인드 변수**를 사용하면서 값에 따라 최적 액세스 경로가 확연히 다른 컬럼

### 2. 수집 방법: 현대적인 방법을 우선하라
```sql
-- 개별 테이블: AUTO_SAMPLE_SIZE와 SIZE AUTO를 사용하여 Oracle이 판단하게 함
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname          => USER,
    tabname          => '주요테이블',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt       => 'FOR ALL COLUMNS SIZE AUTO',
    cascade          => TRUE
  );
END;
/

-- 특정 컬럼에 대해 상세 통계 수집 (나머지는 기본)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND CATEGORY, FOR ALL COLUMNS SIZE 1',
    cascade    => TRUE
  );
END;
/

-- 히스토그램 제거 (문제 발생 시 회귀 테스트용)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 1 BRAND' -- SIZE 1은 히스토그램 제거
  );
END;
/
```

### 3. 선별적 수집: 실제 사용 패턴을 반영하라
```sql
-- 1. 컬럼 사용 정보 수집 시작 (예: 5분간 애플리케이션 워크로드 실행)
EXEC DBMS_STATS.SEED_COL_USAGE(NULL,NULL,300);

-- 2. 수집된 사용 이력을 바탕으로 히스토그램 생성이 필요한 컬럼 리포트 확인
SELECT DBMS_STATS.REPORT_COL_USAGE(USER, 'PROD') FROM dual;
```
이 기능을 이용하면 실제 쿼리에서 조건으로 자주 사용되고, 동등/범위 검색이 이루어진 컬럼을 식별할 수 있어, 불필요한 히스토그램 생성을 피하면서 정말 필요한 컬럼에 집중할 수 있습니다.

---

## 진단 및 해결 프로세스

### 문제 상황 A: 인기 값 조회 시 비효율적인 인덱스 스캔 발생
```sql
-- 가정: BRAND 컬럼에 히스토그램이 없는 상태
EXPLAIN PLAN FOR SELECT * FROM prod WHERE brand='B0';
-- E-Rows가 적게 추정되어 Index Range Scan 선택,但 실제 데이터는 많음(A-Rows 큼)
```
**해결**: BRAND 컬럼에 히스토그램을 생성하여 인기 값 'B0'에 대한 `E-Rows`를 현실적으로 높인다. 옵티마이저가 풀 테이블 스캔을 선택하도록 유도될 수 있습니다.

### 문제 상황 B: 바인드 변수 사용 시 한 값의 플랜으로 고정되는 문제
1.  **진단**: `V$SQL`또는 `DBMS_XPLAN.DISPLAY_CURSOR`로 `PEEKED_BINDS`와 사용된 자식 커서 수를 확인.
2.  **해결 1**: 히스토그램 존재 시, ACS가 자연스럽게 학습하도록 다양한 값을 반복 실행.
3.  **해결 2**: ACS를 보완하기 위해 SQL 베이스라인으로 양쪽 모두 효율적인 플랜(예: 인덱스 힌트 포함)을 수용하도록 관리.
4.  **해결 3** (근본적): 애플리케이션 로직에서 값의 특성(인기/비인기)에 따라 SQL을 분기.

---

## 결론

히스토그램은 Oracle 옵티마이저에게 데이터의 실제 모습을 보여주는 '안경'과 같습니다. 균등 분포라는 단순한 가정을 벗어나, 값마다 다른 특성을 반영한 현명한 실행 계획 수립을 가능하게 합니다.

*   **Frequency/Top-Frequency 히스토그램**은 도메인이 명확하고 편향이 큰 카테고리형 데이터의 선택도 추정을 정밀화합니다.
*   **Hybrid 히스토그램**은 연속형 데이터나 고유 값이 많은 컬럼에서 동등 및 범위 조건 모두에 대한 추정 품질을 높입니다.
*   **Bind Peeking과 ACS**는 히스토그램과 협력하여 바인드 변수 사용 시 발생할 수 있는 플랜 고정 문제를 완화합니다.
*   **확장 통계**는 히스토그램의 한계인 단일 컬럼 분석을 넘어, 컬럼 간의 상관관계를 고려한 결합 선택도 추정을 가능케 합니다.

효율적인 데이터베이스 성능 관리란 **정확한 기본 통계(행수, NDV)를 바탕으로, 핵심 편향 컬럼에는 히스토그램을, 강한 상관관계에는 확장 통계를 적재적소에 적용**하고, 그 결과를 **실행 계획의 `E-Rows` vs `A-Rows`를 비교하며 지속적으로 검증**하는 과정입니다. 이 체계적인 접근이 바로 예측 가능하고 안정적인 고성능 애플리케이션을 구축하는 튼튼한 기반이 됩니다.