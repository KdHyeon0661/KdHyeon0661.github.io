---
layout: post
title: DB 심화 - 히스토그램
date: 2025-11-15 21:25:23 +0900
category: DB 심화
---
# 히스토그램(Oracle)

## 실행 플랜 실측 루틴(필수)

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS +ALIAS +NOTE'
));
```

- `E-Rows`(Estimated Rows) vs `A-Rows`(Actual Rows)
- `Predicate Information`의 access/filter 이동
- `Notes`의 histogram/ACS/peek 정보
이 3가지를 보지 않으면 히스토그램 튜닝은 “감”이 된다.

---

## 히스토그램이 필요한 이유: “균등 가정”이 현실과 어긋날 때

옵티마이저(CBO)는 **선택도(Selectivity)** 를 추정해 카디널리티를 얻고, 그로부터 조인 순서/방법, 액세스 경로를 고른다.

### 히스토그램이 없을 때의 기본 가정

스큐가 없고 값이 균등하다고 가정하면:

- 동등 조건:
  $$ \text{Sel}(col = v) \approx \text{density} \approx \frac{1}{\text{NDV}(col)} $$

- 카디널리티:
  $$ \text{Card} \approx \text{NUM\_ROWS} \times \text{Sel} $$

하지만 **실제 데이터는 대부분 스큐/상관관계/구간 집중**이 존재한다.
균등 가정이 깨지면 `E-Rows`가 폭발적으로 틀어지고, 플랜이 뒤집힌다.

### 히스토그램의 역할

히스토그램은 컬럼 값 분포를 “버킷(bucket)”으로 요약해,
**값/구간별 선택도를 현실적으로 계산**하게 해 준다. Oracle은 `FREQUENCY`, `TOP-FREQUENCY`, `HYBRID`, `HEIGHT BALANCED(legacy)` 히스토그램을 지원하며, 분포/NDV/버킷 수/샘플링 방식에 따라 자동 선택한다.

---

## 히스토그램이 사용되는 통계 체인(그림)

히스토그램은 **컬럼 통계의 한 부분**이다.

```
테이블 통계(NUM_ROWS, BLOCKS, AVG_ROW_LEN ...)
   └─ 컬럼 통계(NDV, DENSITY, NUM_NULLS, LOW/HIGH_VALUE ...)
        └─ 히스토그램(버킷/엔드포인트/반복횟수)
             └─ 선택도 추정 보정
                  └─ 카디널리티(E-Rows) 보정
                       └─ 플랜 선택
```

- NDV, density는 “평균적” 선택도
- 히스토그램은 “값/구간별” 선택도
따라서 히스토그램은 **마지막 정밀 보정 장치**다.

---

## 실습 스키마(스큐/NULL 포함) & 기본 통계

> 지역 표기는 예제 목적일 뿐이며, 특정 지역 자료/통계에 의존하지 않는다.

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

BEGIN EXECUTE IMMEDIATE 'DROP TABLE cust PURGE'; EXCEPTION WHEN OTHERS THEN NULL; END; /
BEGIN EXECUTE IMMEDIATE 'DROP TABLE prod PURGE'; EXCEPTION WHEN OTHERS THEN NULL; END; /
BEGIN EXECUTE IMMEDIATE 'DROP TABLE ord  PURGE'; EXCEPTION WHEN OTHERS THEN NULL; END; /

CREATE TABLE cust(
  cust_id NUMBER PRIMARY KEY,
  region  VARCHAR2(8),   -- 스큐 + 일부 NULL
  tier    VARCHAR2(8)    -- VIP/GOLD/SILVER/GEN
);

CREATE TABLE prod(
  prod_id  NUMBER PRIMARY KEY,
  category VARCHAR2(12), -- ELEC/FOOD/TOY/HOME/FASH
  brand    VARCHAR2(12)  -- 스큐: 'B0' 다수
);

CREATE TABLE ord(
  order_id NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL,
  prod_id  NUMBER NOT NULL,
  order_dt DATE   NOT NULL,
  amount   NUMBER(12,2) NOT NULL
);

CREATE INDEX ix_cust_region ON cust(region, cust_id);
CREATE INDEX ix_prod_cat_br ON prod(category, brand, prod_id);
CREATE INDEX ix_ord_cust_dt ON ord(cust_id, order_dt);
CREATE INDEX ix_ord_prod_dt ON ord(prod_id, order_dt);

BEGIN
  FOR c IN 1..30000 LOOP
    INSERT INTO cust VALUES(
      c,
      CASE MOD(c,6)
        WHEN 0 THEN 'AMER' WHEN 1 THEN 'AMER'   -- 편중(≈ 2/6)
        WHEN 2 THEN 'EMEA' WHEN 3 THEN 'LATAM'
        WHEN 4 THEN 'NA'   ELSE NULL           -- 일부 NULL
      END,
      CASE MOD(c,4)
        WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..12000 LOOP
    INSERT INTO prod VALUES(
      p,
      CASE MOD(p,5)
        WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD'
        WHEN 2 THEN 'TOY'  WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 4000 THEN 'B0'
           ELSE 'B'||LPAD(TO_CHAR(MOD(p,60)),2,'0') END
    );
  END LOOP;

  FOR o IN 1..180000 LOOP
    INSERT INTO ord VALUES(
      o,
      MOD(o,30000)+1,
      MOD(o,12000)+1,
      DATE '2024-01-01' + MOD(o,365),
      ROUND(DBMS_RANDOM.VALUE(10,700),2)
    );
  END LOOP;
  COMMIT;
END;
/

-- 초기 통계(히스토그램 없이)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
END;
/
```

---

## 히스토그램 유형 4가지와 선택 기준

Oracle은 컬럼의 NDV, 버킷 수 `n`(기본 254), 샘플링 방식(AUTO vs 수동)을 보고 히스토그램 유형을 결정한다.

### Frequency 히스토그램

- **조건**: NDV ≤ n 이면 값마다 1버킷을 배정할 수 있어 **도수분포(FREQUENCY)** 가 생성된다.
- **특징**
  - 각 distinct 값이 버킷 하나를 가짐
  - 동등 조건 선택도:
    $$ \text{Sel}(col=v) \approx \frac{\text{count}(v)}{\text{NUM\_ROWS}} $$
  - **카테고리형 / NDV 작은 컬럼에 최적**

### Top-Frequency 히스토그램

Frequency의 변형. NDV가 꽤 크지만 “상위 인기값”이 대부분의 행을 차지하면,
그 인기값들만 정확히 기록하고 나머지는 density로 근사한다.

- **생성 조건(공식 요지)**
  1) NDV > n
  2) 상위 n개 빈도값이 차지하는 행 비율 ≥ 임계치 p
     $$ p = \left(1 - \frac{1}{n}\right)\times 100 $$
  3) `estimate_percent = AUTO_SAMPLE_SIZE`

- **효과**
  - **상위 인기값 조건의 E-Rows가 매우 정확**
  - “인기값/비인기값 플랜 안정성”을 크게 개선

### Hybrid 히스토그램(12c+ 표준)

NDV가 n보다 큰데, 상위 n값이 테이블 대부분을 먹지는 않는 경우
Top-Freq 대신 **Hybrid**가 생성된다.

- **생성 조건(공식 요지)**
  1) NDV > n
  2) Top-Freq 조건 불충족(= 상위 n값 비율 < p)
  3) `estimate_percent = AUTO_SAMPLE_SIZE`

- **특징**
  - 인기값은 “도수에 가깝게”, 나머지는 “구간 누적분포에 가깝게”
  - **동등 조건 + 범위 조건 모두**를 현실적으로 추정
  - 19c/21c/23ai에서도 사실상 **주력 히스토그램**

### Height-Balanced 히스토그램(legacy)

- 11g까지 NDV>n이면 기본으로 생성되던 방식.
- 각 버킷이 비슷한 “행 수(높이)”를 가지도록 경계를 잡는다.
- 12c 이후 AUTO_SAMPLE_SIZE로 새로 만드는 히스토그램은 Top-Freq/Hybrid가 되고
  기존 Height-Balanced는 **업그레이드 후 통계 재수집 시 교체**된다.

---

## Oracle이 히스토그램 유형을 고르는 로직(결정 테이블)

| 조건 | 결과 |
|---|---|
| NDV ≤ n | FREQUENCY |
| NDV > n AND estimate_percent ≠ AUTO | HEIGHT BALANCED(legacy) 또는 FREQUENCY |
| NDV > n AND estimate_percent = AUTO AND top n값 점유율 ≥ p | TOP-FREQUENCY |
| NDV > n AND estimate_percent = AUTO AND top n값 점유율 < p | HYBRID |

이 로직 때문에,
- **AUTO_SAMPLE_SIZE + SIZE AUTO** → Top-Freq/Hybrid 중심
- 수동 %를 주면 Height-Balanced가 다시 등장 가능
이걸 모르면 “왜 예전과 다른 유형이 나오지?”를 영원히 반복한다.

---

## 내부 저장 구조: USER_TAB_COL_STATISTICS & USER_HISTOGRAMS

### 컬럼 통계에서 보는 히스토그램 메타

```sql
SELECT table_name, column_name,
       num_distinct, num_nulls, density,
       histogram, num_buckets, last_analyzed
FROM   user_tab_col_statistics
WHERE  table_name IN ('CUST','PROD','ORD')
ORDER  BY table_name, column_name;
```

- `HISTOGRAM`:
  - `FREQUENCY / TOP-FREQUENCY / HYBRID / HEIGHT BALANCED` 로 유형 표시
- `NUM_BUCKETS`:
  - 실제 생성된 버킷 수
  - 요청한 버킷과 다를 수 있음(SIZE AUTO/분포 기반 자동 조정)

### USER_HISTOGRAMS 해석

```sql
SELECT table_name, column_name,
       endpoint_number, endpoint_value,
       endpoint_repeat_count
FROM   user_histograms
WHERE  table_name='PROD' AND column_name='BRAND'
ORDER  BY endpoint_number;
```

- `ENDPOINT_NUMBER`: 누적 빈도(= 누적 행 수)
- `ENDPOINT_VALUE`: 버킷 경계 값
- `ENDPOINT_REPEAT_COUNT`:
  - Hybrid에서 **인기값/반복값을 정확히 식별**하는 핵심

유형마다 해석 방식이 다르지만, 공통은 “경계 기반 누적 분포”라는 점이다.
Hybrid는 repeat_count로 “인기값은 도수처럼, 비인기값은 구간처럼” 결합한다.

---

## 실습 1 — 스큐 카테고리 컬럼에 Top-Frequency/Frequency 만들기

### BRAND에 히스토그램 생성

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND, FOR ALL COLUMNS SIZE 1'
  );
END;
/
```

- SIZE 254는 최대 버킷 한도(기본치)이며, Oracle이 분포를 보고
  FREQUENCY / TOP-FREQUENCY / HYBRID 중 자동 선택한다.

### 효과 관찰

```sql
EXPLAIN PLAN FOR SELECT COUNT(*) FROM prod WHERE brand='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR SELECT COUNT(*) FROM prod WHERE brand='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**기대**
- `B0`(popular): E-Rows ↑ → FTS/FFS 가능성 증가
- `B47`(nonpopular): E-Rows ↓ → Index Range Scan 가능성 증가

히스토그램이 없다면 두 값이 density(≈1/NDV)로 비슷하게 취급되어
“둘 다 인덱스” 혹은 “둘 다 풀스캔”이 되어버릴 수 있다.

---

## 실습 2 — 연속형 컬럼에 Hybrid/Height-Balanced 만들기

### AMOUNT에 히스토그램

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'ORD',
    method_opt => 'FOR COLUMNS SIZE 254 AMOUNT'
  );
END;
/
```

AUTO_SAMPLE_SIZE라면 NDV가 큰 연속형 컬럼은 대개 Hybrid로 간다.

### 동등/범위 선택도 차이

```sql
EXPLAIN PLAN FOR SELECT COUNT(*) FROM ord WHERE amount = 123.45;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR SELECT COUNT(*) FROM ord WHERE amount BETWEEN 10 AND 100;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR SELECT COUNT(*) FROM ord WHERE amount BETWEEN 500 AND 700;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- Hybrid/Height-Balanced는 **구간 누적분포 차이**를 반영해
  두 범위의 E-Rows가 크게 달라진다.
- 히스토그램이 없으면 두 범위를 “비슷한 밀도”로 근사해 둔감해진다.

---

## 선택도 계산의 핵심 수학(현업에서 반드시 필요한 부분)

### 동등 조건

- 히스토그램 없음:
  $$\text{Sel}(col=v)\approx density \approx \frac{1}{NDV}$$

- Frequency/Top-Freq의 popular값:
  $$\text{Sel}(col=v)\approx \frac{count(v)}{NUM\_ROWS}$$

- “비인기값”은 density 기반 보정이 섞인다(Top-Freq/Hybrid).

### 범위 조건

Hybrid/Height-Balanced는 버킷 경계로 누적분포 \(F(x)\)를 근사해:

$$ \text{Sel}(a \le col < b) \approx F(b) - F(a) $$

여기서 \(F\)는 **엔드포인트와 반복정보**로 계산된다.
범위 조건이 많은 DW/리포트에서 Hybrid가 사실상 필수인 이유다.

### NDV/밀도/히스토그램의 관계

- NDV가 정확해야 “평균치”가 맞음
- 히스토그램은 “평균에서 얼마나 벗어났는가”를 값별로 보정
둘은 **대체 관계가 아니라 곱셈 관계**에 가깝다.

---

## 바인드 변수 + 히스토그램: Bind Peeking과 ACS

### 문제의 본질

스큐 컬럼에 바인드를 쓰면,
- 하드파싱 시 **첫 바인드로 선택도/플랜이 고정(peeking)** 되고
- 이후 다른 바인드가 와도 같은 child cursor를 재사용해서
  “값에 따라 플랜이 완전히 달라져야 하는데” 못 달라지는 사고가 난다.

Oracle은 이를 보완하려고
- **Bind Peeking**
- **Adaptive Cursor Sharing(ACS)**
을 사용한다.

### 실습: 피킹/ACS 동작 관찰

```sql
ALTER SYSTEM FLUSH SHARED_POOL;

VARIABLE b_brand VARCHAR2(12);

-- 1) 희소값으로 첫 파싱
EXEC :b_brand := 'B47';
SELECT /* peek-rare */ COUNT(*) FROM prod WHERE brand = :b_brand;

-- 2) 대량값으로 재사용
EXEC :b_brand := 'B0';
SELECT /* reuse-heavy */ COUNT(*) FROM prod WHERE brand = :b_brand;

-- 피킹 바인드 / child cursor / 플랜 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS +NOTE'
));
```

**관찰**
- 첫 실행의 바인드가 `PEEKED_BINDS`에 보이고
- 반복 실행 후 값군이 극단적으로 다르면 ACS가 child cursor를 분기할 수 있다.

### 운영 판단

- 값군이 “인기 vs 비인기”처럼 **구간이 명확히 2~3개로 나뉘면**
  - 히스토그램 + ACS 학습이 가장 자연스럽다.
- 학습이 늦거나 플랜 급변 리스크가 크면
  - SQL을 값군별로 분리(리터럴/UNION ALL)
  - Baseline/Profile로 안전장치
를 고려한다.

---

## 실전 함정 10가지(“왜 히스토그램이 있어도 틀리나?”)

1) **샘플링이 너무 낮아 스큐가 왜곡**
   - AUTO_SAMPLE_SIZE가 풀스캔보다 정확한 경우가 많다.
2) **통계가 오래돼 분포가 바뀜**
   - “스큐 컬럼”은 데이터 drift가 빠르다.
3) **NDV 오차가 커서 인기/비인기 판단 자체가 흔들림**
4) **바인드 피킹으로 잘못된 플랜이 고정**
   - ACS가 아직 분기하지 않은 상태.
5) **OR 조건, 함수 가공으로 조건이 SARGABLE하지 않음**
6) **조인 순서가 바뀌면서 히스토그램이 적용될 QB가 달라짐**
7) **상관관계(결합 선택도) 문제를 히스토그램만으로 해결하려고 함**
   - 확장 통계가 필요.
8) **히스토그램 남발로 플랜 변동성(unstable plan) 증가**
9) **업그레이드 후 히스토그램 유형 교체**
   - 11g Height-Balanced → 12c+ Hybrid/Top-Freq로 교체될 수 있음.
10) **파티션별 분포가 다른데 GLOBAL만 보고 판단**
    - 파티션 히스토그램/증분 통계/프루닝과 함께 봐야 한다.

---

## 결합 선택도(상관관계)와 확장 통계

히스토그램은 **단일 컬럼 분포**다.
두 조건이 상관관계가 큰 경우, 독립 가정은 망가진다.

- 독립 가정:
  $$ \text{Sel}(A\land B) \approx \text{Sel}(A)\times \text{Sel}(B) $$

### 실습: 확장 통계로 보정

```sql
-- 확장 통계 없이
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   cust
WHERE  region='AMER' AND tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- (REGION,TIER) 확장 통계 생성
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/

-- 다시 측정
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   cust
WHERE  region='AMER' AND tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 확장 통계는 “다중 컬럼 그룹 NDV/분포”를 반영해 결합 선택도를 보정한다.
- 단일 컬럼 히스토그램을 아무리 잘 만들어도 상관관계 문제는 남는다.

---

## 히스토그램 운용 베스트 프랙티스

### 언제 만들까?

- 스큐가 크다(인기값/희소값 차이 큼)
- where/join 조건에 자주 등장(핵심 리포트)
- 바인드 값에 따라 플랜이 크게 달라진다

### 얼마나 만들까?

- **필요한 컬럼만 최소로**
  히스토그램은 “값에 따른 플랜 다양화”를 유도하므로,
  남발하면 플랜 변동성이 커진다.

### METHOD_OPT 레시피

```sql
-- 스키마 기본 정책: AUTO (필요한 컬럼에만 히스토그램)
BEGIN
  DBMS_STATS.GATHER_SCHEMA_STATS(
    ownname          => USER,
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt       => 'FOR ALL COLUMNS SIZE AUTO',
    cascade          => TRUE
  );
END;
/

-- 특정 컬럼만 초정밀, 나머지는 균등
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND, FOR ALL COLUMNS SIZE 1',
    cascade    => TRUE
  );
END;
/

-- 히스토그램 제거(회귀)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 1 BRAND'
  );
END;
/
```

### “컬럼 사용 이력 기반” 선별

```sql
-- 300초 동안 컬럼 사용 수집
EXEC DBMS_STATS.SEED_COL_USAGE(NULL,NULL,300);

-- 리포트로 히스토그램 후보 추출
SELECT DBMS_STATS.REPORT_COL_USAGE(USER,'PROD') FROM dual;
```

“자주 쓰이는 스큐 컬럼”만 골라 정밀히 수집하는 것이 표준이다.

---

## 문제 재현 → 진단 → 해결 루프

### 시나리오 A: 인기값에서 인덱스가 잡혀 폭망

```sql
-- 히스토그램 없음(균등 가정)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 1 BRAND',
    cascade    => TRUE
  );
END;
/

EXPLAIN PLAN FOR SELECT COUNT(*) FROM prod WHERE brand='B0';
EXPLAIN PLAN FOR SELECT COUNT(*) FROM prod WHERE brand='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**해결**
```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    cascade    => TRUE
  );
END;
/
```

- 인기값 `B0`의 E-Rows가 현실화되면 플랜이 풀스캔 쪽으로 자연스레 바뀔 수 있다.

### 시나리오 B: 바인드 하나로 값군이 극단적으로 갈리는 리포트

1) 희소로 첫 파싱 → 인덱스 플랜 고정
2) 이후 인기값에서 재사용 → 랜덤 I/O 폭증
3) 히스토그램 + 반복 실행 → ACS 분기 유도
4) 그래도 불안하면 Baseline/Profile로 보호

---

## 운영 체크리스트

- [ ] 스큐 컬럼에만 히스토그램(SIZE AUTO/254)
- [ ] AUTO_SAMPLE_SIZE로 Top-Freq/Hybrid 품질 확보
- [ ] 바인드 + 스큐 컬럼은 PEEKED_BINDS/ACS child 분기 확인
- [ ] 결합 선택도 문제는 확장 통계로 보정
- [ ] 히스토그램 남발 금지(플랜 변동성↑)
- [ ] 모든 변경은 `E-Rows vs A-Rows` 실측으로 팩트 검증

---

## 결론

히스토그램은 Oracle 옵티마이저가 “데이터가 진짜 어떻게 생겼는지”를 보게 해 주는 장치다.

- Frequency/Top-Frequency → **카테고리형 스큐** 정밀화
- Hybrid → **연속형/대 NDV/범위 조건** 현실화
- Bind Peeking/ACS와 결합 → **바인드 재사용의 약점 보완**
- 확장 통계 → **상관관계(결합 선택도) 보정**

정리하면:

> **정확한 분포(히스토그램) + 정확한 상관관계(확장 통계) + 실측 검증(ALLSTATS)**
> 이 3개가 맞물릴 때 플랜은 예측 가능하고 재현 가능한 “저비용”으로 안정화된다.
