---
layout: post
title: DB 심화 - 전략적 통계 수집
date: 2025-11-18 14:25:23 +0900
category: DB 심화
---
# — **데이터 샘플링 · 파티션 테이블 통계 · 인덱스 통계 · 커서 Invalidation · 자동 통계 · Statistics Preferences**

> 실행 후에는 반드시 **실측 플랜**으로 효과를 검증하세요.
```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'
));
```

---

## 실습 스키마(파티션 포함) 준비

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

-- 깨끗이
BEGIN
  FOR t IN (SELECT table_name FROM user_tables
            WHERE table_name IN ('D_CUSTOMER','D_PRODUCT','F_SALES','F_SALES_STG')) LOOP
    EXECUTE IMMEDIATE 'DROP TABLE '||t.table_name||' PURGE';
  END LOOP;
END;
/

-- 차원 테이블
CREATE TABLE D_CUSTOMER(
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(8),
  TIER    VARCHAR2(8)
);

CREATE TABLE D_PRODUCT(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12),
  BRAND    VARCHAR2(12)
);

-- 월 파티션 사실 테이블
CREATE TABLE F_SALES(
  SALES_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  SALES_DT DATE   NOT NULL,
  QTY      NUMBER NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL
)
PARTITION BY RANGE (SALES_DT)(
  PARTITION P202401 VALUES LESS THAN (DATE '2024-02-01'),
  PARTITION P202402 VALUES LESS THAN (DATE '2024-03-01'),
  PARTITION P202403 VALUES LESS THAN (DATE '2024-04-01'),
  PARTITION PMAX    VALUES LESS THAN (MAXVALUE)
);

-- 인덱스
CREATE INDEX IX_CUST_REGION     ON D_CUSTOMER(REGION, CUST_ID);
CREATE INDEX IX_PROD_CAT_BRAND  ON D_PRODUCT(CATEGORY, BRAND, PROD_ID);
CREATE INDEX IX_FS_CUST_DT      ON F_SALES(CUST_ID, SALES_DT) LOCAL;
CREATE INDEX IX_FS_PROD_DT      ON F_SALES(PROD_ID, SALES_DT) LOCAL;

-- 데이터(스큐 포함)
BEGIN
  FOR c IN 1..50000 LOOP
    INSERT INTO D_CUSTOMER
    VALUES(
      c,
      CASE MOD(c,6) WHEN 0 THEN 'KOR' WHEN 1 THEN 'KOR'
                    WHEN 2 THEN 'APAC' WHEN 3 THEN 'EMEA'
                    WHEN 4 THEN 'AMER' ELSE 'JPN' END,
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
                    WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..20000 LOOP
    INSERT INTO D_PRODUCT
    VALUES(
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD'
                    WHEN 2 THEN 'TOY'  WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 6000 THEN 'B0' ELSE 'B'||LPAD(TO_CHAR(MOD(p,80)),2,'0') END
    );
  END LOOP;

  FOR m IN 1..3 LOOP  -- 1~3월
    FOR r IN 1..150000 LOOP
      INSERT INTO F_SALES
      VALUES(
        (m-1)*150000 + r,
        MOD(r,50000)+1,
        MOD(r,20000)+1,
        ADD_MONTHS(DATE '2024-01-10', m-1) + MOD(r,20),
        1 + MOD(r,5),
        ROUND(DBMS_RANDOM.VALUE(10,800),2)
      );
    END LOOP;
  END LOOP;
  COMMIT;
END;
/

-- 최초 통계(히스토그램은 후술)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'D_CUSTOMER', cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'D_PRODUCT' , cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'F_SALES'   , cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1',
                                granularity=>'GLOBAL AND PARTITION');
END;
/
```

---

# **데이터 샘플링(estimate_percent)** — 정확도 vs 비용의 균형

## 기본 원칙

- **권장 기본값:** `estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE`
  - 버전에 따라 **근사 NDV(Approx NDV)**/스마트 샘플링으로 **정확도/속도** 균형
- 수동 퍼센트는 **특정 상황**만:
  - 초대형 테이블에서 시간이 과도할 때(예: 1~10%)
  - **스큐/NDV**가 매우 중요한 컬럼은 해당 테이블만 **높은 샘플** 또는 **FULL**

> 선택도/카디널리티 오차는 **힉스토그램/확장 통계**로 보정하는 게 먼저.
> 샘플링만 올리면 비용만 증가하고 플랜 안정성은 담보 못 함.

## 샘플링 비교 실습

```sql
-- ① AUTO
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'D_PRODUCT',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt       => 'FOR ALL COLUMNS SIZE AUTO',
    cascade          => TRUE);
END;
/

-- ② 저퍼센트(빠르지만 스큐 왜곡 가능)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'D_PRODUCT',
    estimate_percent => 5,
    method_opt       => 'FOR ALL COLUMNS SIZE AUTO',
    cascade          => TRUE);
END;
/

-- ③ FULL
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'D_PRODUCT',
    estimate_percent => 100,
    method_opt       => 'FOR ALL COLUMNS SIZE AUTO',
    cascade          => TRUE);
END;
/

-- 결과 비교(컬럼 통계/히스토그램/NDV)
SELECT column_name, num_distinct, histogram, density, last_analyzed
FROM   user_tab_col_statistics
WHERE  table_name='D_PRODUCT'
ORDER  BY column_name;

-- 변화 리포트(이전 vs 현재)
SELECT DBMS_STATS.DIFF_TABLE_STATS_IN_HISTORY(USER,'D_PRODUCT',
       SYSTIMESTAMP-1, SYSTIMESTAMP) AS diff
FROM   dual;
```

## 실무 팁

- **스큐가 큰 컬럼**은 자동 샘플이라도 **히스토그램**이 핵심.
- 보고서 핵심 컬럼만 **SIZE 254** 등 정밀, 나머지는 **SIZE 1**로 절약.
- Always **Pending → 검증 → Publish**(후술).

---

# **파티션 테이블 통계 수집** — 증분 통계로 빠르고 안전하게

## Granularity & Incremental

- `granularity` : `PARTITION | GLOBAL | GLOBAL AND PARTITION | AUTO(권장)`
- **증분 통계(INCREMENTAL=TRUE)**: 변경된 파티션 통계만 수집 → 내부 **시놉시스**로 **글로벌 통계 자동 합성**
  - 대형 월/일 파티션 팩트 테이블에서 필수

```sql
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','INCREMENTAL','TRUE');
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','GRANULARITY','AUTO');
END;
/
```

## 표준 플로우

```sql
-- 신월 스테이징
CREATE TABLE F_SALES_STG AS SELECT * FROM F_SALES WHERE 1=0;

-- (ETL) 신월 데이터 로드 → 스테이징 통계 선수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'F_SALES_STG',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt       => 'FOR ALL COLUMNS SIZE 1', cascade=>TRUE);
END;
/

-- 파티션 교체(메타데이터 수준 → 빠름)
ALTER TABLE F_SALES EXCHANGE PARTITION P202404 WITH TABLE F_SALES_STG WITHOUT VALIDATION;

-- 변경 파티션만 수집(증분)
BEGIN
  DBMS_STATS.GATHER_PARTITION_STATS(USER,'F_SALES','P202404', cascade=>TRUE);
END;
/

-- 확인
SELECT table_name, partition_name, num_rows, last_analyzed
FROM   user_tab_statistics
WHERE  table_name='F_SALES'
ORDER  BY partition_position NULLS LAST;
```

## Pending Stats + 검증 → Publish

```sql
-- 게시 보류(플랜 급변 방지)
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','PUBLISH','FALSE');
END;
/

-- 수집(게시 보류 상태)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'F_SALES', options=>'GATHER STALE',
                                cascade=>TRUE, granularity=>'AUTO');
END;
/

-- 검증 세션에서 Pending 사용
ALTER SESSION SET optimizer_use_pending_statistics = TRUE;

-- 핵심 리포트 쿼리 실행 → 플랜/카디널리티 확인
EXPLAIN PLAN FOR
SELECT p.category, SUM(s.amount)
FROM   F_SALES s JOIN D_PRODUCT p ON p.prod_id=s.prod_id
WHERE  s.sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
GROUP  BY p.category;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 이상 없으면 게시
BEGIN
  DBMS_STATS.PUBLISH_PENDING_STATS(USER,'F_SALES');
END;
/
```

---

# **인덱스 통계 수집** — `cascade`와 `GATHER_INDEX_STATS` 포인트

## 왜 중요한가

옵티마이저가 **BLEVEL, LEAF_BLOCKS, DISTINCT_KEYS, CLUSTERING_FACTOR(CF)** 등을 이용해
- **인덱스 탐색 비용**(트리 깊이/리프 범위)
- **테이블 랜덤 I/O**(CF 의존)를 추정합니다.

**CF 높음 = 물리 순서와 인덱스 키 순서 불일치 = 랜덤 I/O 증가** → NL/Index Range 불리

## 수집 방법

- 테이블 통계 수집 시 **`cascade=>TRUE`**로 인덱스도 동시 수집(권장)
- 인덱스만 별도: `DBMS_STATS.GATHER_INDEX_STATS`

```sql
-- 테이블 통계 + 인덱스 동시(cascade)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'D_PRODUCT',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt       => 'FOR ALL COLUMNS SIZE AUTO',
    cascade          => TRUE);
END;
/

-- 인덱스만 별도
BEGIN
  DBMS_STATS.GATHER_INDEX_STATS(USER,'IX_PROD_CAT_BRAND');
END;
/

-- 지표 확인
SELECT index_name, blevel, leaf_blocks, distinct_keys, clustering_factor, num_rows, last_analyzed
FROM   user_indexes
WHERE  table_name IN ('D_PRODUCT','F_SALES')
ORDER  BY table_name, index_name;
```

## 로컬/글로벌 파티션 인덱스

- **LOCAL 인덱스**: 파티션 통계와 함께 **파티션별 인덱스 통계** 수집
- **GLOBAL 인덱스**: 일부 파티션만 변경되어도 **글로벌 인덱스 통계 영향** 가능(주의)
- **증분 통계**는 테이블 글로벌 통계 합성에 초점, **인덱스 통계는 개별 수집**이 기본

## Rebuild/Coalesce 후 통계

- `ALTER INDEX ... REBUILD/COALESCE` 후 **LEAF_BLOCKS/CF**가 달라질 수 있음 → **통계 재수집**
- CF 자체는 **테이블 물리 순서**에 좌우 → 인덱스 Rebuild만으로 **CF 개선이 제한적**

```sql
ALTER INDEX IX_PROD_CAT_BRAND COALESCE;
BEGIN
  DBMS_STATS.GATHER_INDEX_STATS(USER,'IX_PROD_CAT_BRAND');
END;
/
```

---

# **캐싱된 커서 Invalidation** — 성능 급변을 막는 방법

## 언제 Invalidate 되는가

- 대상 객체 **통계 변화**(테이블/인덱스)
- **DDL**(구조 변경, 인덱스 생성/삭제 등)
- **환경 변화**(optimizer 관련 파라미터/환경 차이)
- 권한/동의어 등 네임스페이스 변화

Invalidate가 발생하면 기존 **child cursor**가 **재하드파싱** 대상이 되어 **CPU 상승**·**플랜 급변**이 일어날 수 있습니다.

## 통계 수집 시 제어 장치

- **`NO_INVALIDATE` Preference**
  - `'TRUE'` : 기존 커서 **즉시 무효화 방지**, 다음 하드파스 시 새 통계 반영
  - `'FALSE'`: **즉시 무효화**
  - `'DBMS_STATS.AUTO_INVALIDATE'`(기본): Oracle이 판단(버전에 따라 다름)
- **`PUBLISH`** = `FALSE` 로 **Pending Stats** 사용 → 검증 후 게시

```sql
-- 커서 무효화 지연
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','NO_INVALIDATE','TRUE');
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','PUBLISH','FALSE');
END;
/

-- 수집(게시 보류 → 커서 즉시 영향 없음)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'F_SALES', options=>'GATHER STALE', cascade=>TRUE);
END;
/

-- 검증 후 게시
BEGIN
  DBMS_STATS.PUBLISH_PENDING_STATS(USER,'F_SALES');
END;
/
```

### 관찰(간단)

```sql
-- 실행 전후 child cursor 수/하드파스 상태 변화 관찰
SELECT sql_id, child_number, plan_hash_value, executions, parsing_schema_name
FROM   v$sql
WHERE  sql_text LIKE 'SELECT p.category, SUM(s.amount)%' ESCAPE '\'
ORDER  BY sql_id, child_number;
```

> 운영에선 **NO_INVALIDATE=TRUE + Pending** 조합으로 **야간 수집→주간 안정성**을 확보하는 패턴이 많습니다.

---

# **자동 통계 수집(Auto Optimizer Stats Collection)**

## 무엇을 언제/어떻게?

- Oracle은 **자동 작업(AutoTask)** 으로 통계를 **유지**
- 기본적으로 **야간 유지보수 윈도우**에 동작
- 최근 변경/스테일 객체 우선

### 상태/스케줄 확인(권한 필요)

```sql
-- AutoTask 클라이언트 상태
SELECT client_name, status, window_group
FROM   dba_autotask_client;

-- 각 윈도우 스케줄
SELECT window_name, repeat_interval, duration, enabled
FROM   dba_scheduler_windows
ORDER  BY window_name;

-- 자동 통계 작업 활성/비활성
BEGIN
  DBMS_AUTO_TASK_ADMIN.DISABLE(
    client_name => 'auto optimizer stats collection',
    operation   => NULL, window_name => NULL);
  -- DBMS_AUTO_TASK_ADMIN.ENABLE( ... ) 로 재활성
END;
/
```

> 자동 통계의 **세부 전략**(샘플링/히스토그램/증분/NoInvalidate 등)은
> **`DBMS_STATS`의 Global/Schema/Table Preferences**로 통일해서 관리합니다.

## 자동 통계와 Preferences의 결합

- Global Prefs를 설정하면 **자동 수집도 그 정책**을 따릅니다.
```sql
-- 글로벌 선호값(운영 표준)
BEGIN
  DBMS_STATS.SET_GLOBAL_PREFS('ESTIMATE_PERCENT', 'AUTO');
  DBMS_STATS.SET_GLOBAL_PREFS('METHOD_OPT',       'FOR ALL COLUMNS SIZE AUTO');
  DBMS_STATS.SET_GLOBAL_PREFS('CASCADE',          'TRUE');
  DBMS_STATS.SET_GLOBAL_PREFS('DEGREE',           'AUTO');
  DBMS_STATS.SET_GLOBAL_PREFS('NO_INVALIDATE',    'DBMS_STATS.AUTO_INVALIDATE');
  DBMS_STATS.SET_GLOBAL_PREFS('PUBLISH',          'TRUE');     -- 기본은 즉시 게시, 테이블별로만 Pending
END;
/

-- 테이블 단위 특수 정책(예: Fact 테이블)
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','INCREMENTAL','TRUE');
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','PUBLISH','FALSE');       -- Pending로 운영
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','NO_INVALIDATE','TRUE');  -- 커서 보호
END;
/
```

---

# **Statistics Preference** — 어디에 무엇을, 어떻게 조회/설정?

## 주요 Preference 목록(대표)

- `ESTIMATE_PERCENT`
- `METHOD_OPT` (히스토그램 정책)
- `CASCADE` (인덱스 동시 수집)
- `DEGREE` (병렬)
- `NO_INVALIDATE` (커서 무효화 제어: TRUE/FALSE/AUTO)
- `PUBLISH` (Pending 사용 여부)
- `STALE_PERCENT` (Stale 판단 임계치, 예: 5~10)
- `GRANULARITY` (GLOBAL/PARTITION/AUTO)
- `INCREMENTAL` (증분 통계)
- `INCREMENTAL_STALENESS` (시놉시스 신선도 정책)

## 조회/설정

```sql
-- Global/Schema/Table 별 조회
SELECT DBMS_STATS.GET_PREFS('METHOD_OPT') AS method_opt FROM dual;
SELECT DBMS_STATS.GET_PREFS('METHOD_OPT', ownname=>USER) FROM dual;
SELECT DBMS_STATS.GET_PREFS('METHOD_OPT', ownname=>USER, tabname=>'F_SALES') FROM dual;

-- 설정
BEGIN
  DBMS_STATS.SET_SCHEMA_PREFS(USER, 'STALE_PERCENT', '5');
  DBMS_STATS.SET_TABLE_PREFS(USER, 'D_PRODUCT', 'METHOD_OPT', 'FOR COLUMNS SIZE 254 BRAND, FOR ALL COLUMNS SIZE 1');
END;
/

-- 객체별 Preference 개요(버전에 따라 제공 뷰 상이)
SELECT *
FROM   user_tab_stat_prefs
WHERE  table_name IN ('F_SALES','D_PRODUCT');
```

## 업무 사용 컬럼 기반(히스토그램 선별)

```sql
-- 일정 시간 동안 컬럼 사용 수집(예: 300초)
EXEC DBMS_STATS.SEED_COL_USAGE(NULL, NULL, 300);

-- 컬럼 사용 리포트 → 히스토그램 대상 선별
SELECT DBMS_STATS.REPORT_COL_USAGE(USER,'F_SALES') AS report FROM dual;
```

---

# 종합 시나리오 — “빠르고, 안전하고, 재현 가능하게”

## 야간 자동 + 주간 정밀

1) Global Prefs: `AUTO` 기반 + `NO_INVALIDATE=AUTO`
2) Fact 테이블: `INCREMENTAL=TRUE`, `PUBLISH=FALSE`, `NO_INVALIDATE=TRUE`
3) 자동 수집이 **Stale**만 선별
4) 아침에 **Pending 통계 검증 세션**에서 핵심 리포트/대시보드 쿼리 실측
5) 이상 없으면 **Publish**
6) 월 1회 **스큐 컬럼 히스토그램 정밀** 수집

## Fast Track

- 방금 느려진 SQL의 **E-Rows vs A-Rows** 비교 → 어떤 컬럼/조합에서 오판?
- 해당 컬럼 **히스토그램 생성/보정** 또는 **확장 통계** 추가
- **Pending**으로 수집 → 검증 후 게시
- 불가피하면 **SQL Baseline/Profile**로 안정화

---

# 문제 재현 → 진단 → 개선 (핵심 실습 모음)

### 샘플링에 따른 플랜 차이

```sql
-- 1) 히스토그램 제거(균등 가정)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'D_PRODUCT',
    estimate_percent => 10, method_opt => 'FOR COLUMNS SIZE 1 BRAND', cascade=>TRUE);
END;
/
EXPLAIN PLAN FOR SELECT COUNT(*) FROM D_PRODUCT WHERE BRAND='B0';
EXPLAIN PLAN FOR SELECT COUNT(*) FROM D_PRODUCT WHERE BRAND='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 2) 히스토그램 정밀
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'D_PRODUCT',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt       => 'FOR COLUMNS SIZE 254 BRAND, FOR ALL COLUMNS SIZE 1',
    cascade          => TRUE);
END;
/
EXPLAIN PLAN FOR SELECT COUNT(*) FROM D_PRODUCT WHERE BRAND='B0';
EXPLAIN PLAN FOR SELECT COUNT(*) FROM D_PRODUCT WHERE BRAND='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 증분 통계와 Partition Exchange

```sql
-- 신월 데이터 교체 → 변경 파티션만 수집
CREATE TABLE F_SALES_STG AS SELECT * FROM F_SALES WHERE 1=0;
/* ... ETL 로드 ... */
ALTER TABLE F_SALES EXCHANGE PARTITION P202404 WITH TABLE F_SALES_STG WITHOUT VALIDATION;
BEGIN
  DBMS_STATS.GATHER_PARTITION_STATS(USER,'F_SALES','P202404', cascade=>TRUE);
END;
/
```

### 인덱스 통계의 영향(CF/LEAF/BLEVEL)

```sql
-- 인덱스만 재수집
BEGIN
  DBMS_STATS.GATHER_INDEX_STATS(USER,'IX_FS_CUST_DT');
END;
/
SELECT index_name, blevel, leaf_blocks, clustering_factor
FROM   user_indexes
WHERE  index_name='IX_FS_CUST_DT';
```

### 커서 Invalidation 제어

```sql
-- 커서 무효화 지연 + Pending
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','NO_INVALIDATE','TRUE');
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','PUBLISH','FALSE');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'F_SALES', options=>'GATHER STALE', cascade=>TRUE);
END;
/
ALTER SESSION SET optimizer_use_pending_statistics = TRUE;
-- 핵심 쿼리 검증 후
BEGIN
  DBMS_STATS.PUBLISH_PENDING_STATS(USER,'F_SALES');
END;
/
```

---

# 운영 체크리스트

### 데이터 샘플링

- [ ] 기본은 `AUTO_SAMPLE_SIZE`
- [ ] 대형 Fact는 AUTO로 시작 → 병목 시 **저퍼센트 절충**
- [ ] 스큐 컬럼은 히스토그램으로 보정(샘플만 올리는 것은 한계)

### 파티션 통계

- [ ] `INCREMENTAL=TRUE`, `GRANULARITY=AUTO`
- [ ] **Partition Exchange** + **변경 파티션만 수집**
- [ ] Pending(비게시) → 검증 → Publish

### 인덱스 통계

- [ ] 테이블 수집 시 `cascade=>TRUE`
- [ ] Rebuild/Coalesce 후 재수집
- [ ] CF/LEAF/BLEVEL 정기 모니터링

### 커서 Invalidation

- [ ] `NO_INVALIDATE=TRUE`(대형 OLTP) + `PUBLISH=FALSE`(Pending)
- [ ] 검증 세션에서 **플랜/E-Rows** 확인 후 게시
- [ ] 변동이 큰 SQL은 **Baseline/Profile** 고려

### 자동 통계

- [ ] AutoTask 활성 상태/윈도우 확인
- [ ] Global/Schema/Table Prefs로 정책 통일
- [ ] **Stale 기준(예: 5~10%)** 조정

### Preferences 가시성

- [ ] `GET_PREFS`/`SET_*_PREFS`로 일관성 유지
- [ ] `user_tab_stat_prefs`·`dba_optstat_operations`로 이력 추적

---

## 부록 A. 자주 쓰는 `DBMS_STATS` 템플릿

```sql
-- Global
BEGIN
  DBMS_STATS.SET_GLOBAL_PREFS('ESTIMATE_PERCENT','AUTO');
  DBMS_STATS.SET_GLOBAL_PREFS('METHOD_OPT','FOR ALL COLUMNS SIZE AUTO');
  DBMS_STATS.SET_GLOBAL_PREFS('CASCADE','TRUE');
  DBMS_STATS.SET_GLOBAL_PREFS('DEGREE','AUTO');
  DBMS_STATS.SET_GLOBAL_PREFS('NO_INVALIDATE','DBMS_STATS.AUTO_INVALIDATE');
  DBMS_STATS.SET_GLOBAL_PREFS('PUBLISH','TRUE');
END;
/

-- Schema
BEGIN
  DBMS_STATS.SET_SCHEMA_PREFS(USER,'STALE_PERCENT','5');
END;
/

-- Table
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','INCREMENTAL','TRUE');
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','GRANULARITY','AUTO');
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','PUBLISH','FALSE');
  DBMS_STATS.SET_TABLE_PREFS(USER,'F_SALES','NO_INVALIDATE','TRUE');
END;
/

-- 히스토그램(선별)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'D_PRODUCT',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND, FOR ALL COLUMNS SIZE 1',
    cascade    => TRUE);
END;
/
```

## 부록 B. 모니터링/진단 SQL

```sql
-- 변경량(수집 전 Flush 권장)
EXEC DBMS_STATS.FLUSH_DATABASE_MONITORING_INFO;
SELECT table_name, inserts, updates, deletes, timestamp
FROM   user_tab_modifications
WHERE  table_name IN ('F_SALES','D_PRODUCT')
ORDER  BY timestamp DESC;

-- 통계 작업 이력
SELECT * FROM dba_optstat_operations ORDER BY start_time DESC FETCH FIRST 30 ROWS ONLY;

-- 차이 리포트
SELECT DBMS_STATS.DIFF_TABLE_STATS_IN_HISTORY(USER,'F_SALES',
       SYSTIMESTAMP-1, SYSTIMESTAMP) AS diff
FROM   dual;

-- 컬럼 사용 리포트(히스토그램 선별)
SELECT DBMS_STATS.REPORT_COL_USAGE(USER,'F_SALES') FROM dual;
```

---

## 결론

- **데이터 샘플링**은 `AUTO`를 기본으로, 스큐는 **히스토그램/확장 통계**로 정교화하세요.
- **파티션 테이블**은 **증분 통계**와 **Partition Exchange**로 “빠르게 & 최소 I/O” 전략을.
- **인덱스 통계**는 `cascade`로 동행, CF/리프/블리벨(blevel) 변화를 상시 감시.
- 커서 **Invalidation**은 `NO_INVALIDATE + Pending`으로 완충하고, **검증→게시** 루틴을 습관화.
- **자동 통계**는 **Preferences**와 결합해 조직 표준을 코드로 고정.
- 모든 변경은 끝에서 **E-Rows vs A-Rows**로 **팩트 검증**하십시오. 이것이 플랜 안정성과 성능의 핵심입니다.
