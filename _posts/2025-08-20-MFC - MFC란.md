---
layout: post
title: MFC - MFC란
date: 2025-08-20 21:25:23 +0900
category: MFC
---
# MFC란? (역사, 장단점, Win32와의 관계, 지금도 쓰는 이유) · 개발 환경 꾸미기

## MFC란 무엇인가

**MFC (Microsoft Foundation Class Library)**는 Win32 API 위에 얇은 C++ 클래스 레이어를 얹어 **윈도우 프로그래밍의 반복적 패턴(윈도우 생성, 메시지 처리, 자원 관리)을 캡슐화**한 프레임워크입니다. `CWinApp`, `CWnd`, `CDialog`, `CDocument/CView` 같은 클래스로 응용프로그램의 생명주기와 UI, 메시지 라우팅을 구조화합니다.

### 1-1. 간단 연혁

- **1992~1998**: MFC 1.x~4.x — Win16/Win32 시대 전환기, 클래스 래핑 정착
- **2000~2008**: MFC 6.0~9.0 — Visual Studio와 동반 진화, Doc/View/컨트롤 풍부화
- **2008 이후**: Feature Pack(리본/리스트/트리 향상) 통합, x64 지원, DPI·유니코드 기본화
오늘날에도 VS 최신 툴셋과 함께 유지·배포가 가능합니다.

### 1-2. 철학(Design Goals)

- **얇은 래퍼(thin wrapper)**: Win32 호출을 숨기지 않고 **안전한 RAII와 메시지 맵**로 반복 작업을 줄입니다.
- **메시지 중심 아키텍처**: `WM_*` 메시지를 **매크로 기반 라우팅**(Message Map)으로 구조화합니다.
- **문서/뷰 분리**: 데이터(`CDocument`)와 표시(`CView`) 분리, 인쇄 파이프라인 제공.

### 1-3. 장단점

**장점**
- **네이티브 성능/저부하**: GDI/GDI+와 직접 맞물리는 얇은 레이어.
- **Win32 이해 강화**: 메시지/핸들/리소스 관리 감각을 키우기 좋음.
- **레거시 자산 풍부**: 유지보수·부분 개선에 강함.
- **풍부한 샘플/문서**: 수십 년 누적된 사례.

**단점**
- **현대 UI 생산성/미려함 한계**: XAML/WPF·웹 스택 대비 디자인/데이터바인딩 약함.
- **학습 곡선**: Win32 개념(메시지·DC·리소스)을 병행 이해해야 함.
- **템플릿/매크로 중심 메시지맵**: 현대 C++ 감각과는 다소 결이 다름.

### 1-4. Win32와의 관계

MFC는 **Win32 API의 객체지향적 래핑**입니다. 내부적으로는 여전히 `HWND`, `HDC` 등 **핸들**을 사용하고, 메시지는 결국 `WndProc`로 흘러갑니다. 차이는 **메시지 맵**이 이를 C++ 멤버 함수로 **안전하게 라우팅**한다는 점입니다.

```cpp
// (비교) 순정 Win32: WndProc에서 스위치 분기
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
    case WM_PAINT: /* ... */ break;
    case WM_COMMAND: /* ... */ break;
    }
    return DefWindowProc(hWnd, msg, wParam, lParam);
}

// MFC: 메시지 맵으로 멤버 함수 바인딩
class CMainWnd : public CFrameWnd {
    afx_msg void OnPaint();
    afx_msg void OnCommand(UINT id);
    DECLARE_MESSAGE_MAP()
};
BEGIN_MESSAGE_MAP(CMainWnd, CFrameWnd)
    ON_WM_PAINT()
    ON_COMMAND(ID_FILE_NEW, &CMainWnd::OnCommand)
END_MESSAGE_MAP()
```

### 1-5. 지금도 MFC를 쓰는 이유

- **레거시 유지·확장**: 다수 기업·설비 SW가 MFC 기반. 안정성과 검증된 코드 경로.
- **딥 OS 통합**: 셸 확장, 특수 장치 제어, GDI 기반 뷰어 등 **네이티브 밀착** 요구.
- **낮은 런타임 의존성**: 단독 실행 파일 선호·폐쇄망 배포 등 환경 제약에 유리.
- **성능/지연 민감**: 하드 실시간은 아니지만 입력 지연·렌더 비용 최소화가 유리할 때.

---

## 개발 환경 꾸미기

### 2-1. 도구 설치

- **Visual Studio**: “**Desktop development with C++**” 워크로드 + **MFC for latest vXXX build tools** 선택.
- **Windows SDK**: VS 설치와 함께 포함(프로젝트가 사용하는 SDK 버전 확인).

> 팁: “x64”와 “x86” 빌드 도구를 함께 설치하세요. 드라이버·미들웨어가 32비트일 수 있습니다.

### 2-2. 프로젝트 템플릿 고르기

- **MFC App**(App Wizard) → 유형 선택
  - **Dialog-based**: 빠른 프로토타이핑·툴성 앱에 적합.
  - **SDI/MDI**: 문서/뷰 구조, 인쇄·프리뷰·MRU 등 기본 제공.
- **사용할 기능**: 리본/툴바/상태바, 문서/뷰, Printing, Common Controls v6 등 옵션 체크.

### 2-3. 정적(Static) vs 공유(Shared) MFC

프로젝트 속성 → **Use of MFC**
- **Use MFC in a Shared DLL**
  - 실행 시 `mfc*.dll`(MFC)·`vcruntime*.dll`(CRT) 등 **공유 런타임** 필요
  - **장점**: 실행 파일이 더 작고, 여러 앱이 **런타임을 공유**
  - **단점**: 배포 시 런타임 누락 위험(설치자/재배포 패키지 포함 필요)
- **Use MFC in a Static Library**
  - MFC/CRT를 실행 파일에 **정적으로 링크**
  - **장점**: 단일 exe 배포 용이, 폐쇄망·포터블 배포 선호
  - **단점**: 파일 크기 증가, 보안 업데이트 반영은 **재빌드** 필요

컴파일 타임 구분은 `_AFXDLL` 매크로로 확인할 수 있습니다.

```cpp
#ifdef _AFXDLL
#pragma message("MFC: Shared DLL 구성입니다.")
#else
#pragma message("MFC: Static Library 구성입니다.")
#endif

```

**권장 가이드**
- **엔터프라이즈 설치형(인스톨러 제공)**: Shared 권장(용량↓, 업데이트 용이)
- **단일 exe 휴대 배포/폐쇄망**: Static 권장(의존성↓)

### 2-4. Unicode 설정

오늘날 윈도우는 기본이 **Unicode(UTF-16)** 입니다. VS의 MFC 템플릿은 기본으로 `_UNICODE`/`UNICODE`를 설정합니다.

- 멀티바이트(MBCS)가 필요한 **레거시 DLL/SDK** 연동 때만 MBCS로 낮추는 것을 고려.
- 문자열 리터럴/함수는 **T-매크로** 또는 **와이드 문자열**을 사용하세요.

```cpp
// 유니코드/멀티바이트 모두 안전한 예
CString s = _T("안녕하세요 MFC");
AfxMessageBox(s);

// 특정 빌드 확인
#ifdef _UNICODE

AfxMessageBox(L"유니코드 빌드입니다.");
#else

AfxMessageBox("멀티바이트 빌드입니다.");
#endif

```

**문제 예방**
- 서드파티 헤더가 `char*` 가정 시, **오버로드(…W/A)** 혹은 **변환 함수**를 명시적으로 사용.
- 파일 I/O, 레지스트리 경로, 윈도우 캡션 등은 **UTF-16** 기준으로 다뤄집니다.

### 2-5. x86 vs x64 선택

- **x64**: 현대 윈도우의 기본. **대용량 메모리/성능/ASLR** 이점. 새 프로젝트 기본값으로 추천.
- **x86**: 다음 상황에서는 여전히 유효
  - **32비트 전용 드라이버/SDK/ActiveX** 의존
  - **프로세스 간 통신(Inject/Hook/IPC)** 대상이 32비트일 때는 **같은 비트수** 필요
- 포인터 크기/구조체 패킹 차이에 유의: `sizeof(void*)`가 4(x86) ↔ 8(x64).

```cpp
// x86/x64에서 포인터 크기 로그
CString msg;
msg.Format(_T("sizeof(void*) = %zu"), sizeof(void*));
AfxMessageBox(msg);
```

**전환 체크리스트**
- `LONG`/`DWORD`를 **포인터 보관**에 쓰지 말 것(반드시 `intptr_t/UINT_PTR`).
- 캐스팅/포맷 문자열(`%p`, `%zu`) 정합성 확인.
- COM/레지스트리(32/64 Redirect), `Program Files (x86)` 경로 차이 주의.

---

## 빠른 시작 체크리스트(권장 기본값)

1. **템플릿**: Dialog-based(프로토타입) 또는 SDI(문서/뷰 요구 시)
2. **플랫폼**: 기본 x64 + 필요 시 x86 추가
3. **문자셋**: Unicode(기본 유지)
4. **MFC 링크**: Shared DLL(설치 기반) / Static(단일 exe 배포)
5. **DPI 인식**: Manifest에서 `PerMonitorV2` 설정 고려
6. **코드 서명**: 기업 내 배포·SmartScreen 회피를 위해 인증서 준비
7. **로깅/크래시**: `TRACE`, 미니덤프 핸들러, 버전 리소스 삽입

---

## 자주 겪는 이슈와 원인

- **LNK1104: mfc*.lib not found**
  → MFC 컴포넌트 미설치. VS 설치 관리자의 “MFC for latest vXXX build tools” 추가.
- **런타임 찾기 실패(Shared)**
  → 재배포 패키지(Microsoft Visual C++ Redistributable) 또는 앱 설치자에 병행 포함.
- **CRT/MFC 혼합 설정 불일치**
  → 정적/공유, Debug/Release 런타임 라이브러리 설정이 **일관**되어야 함.
- **x86/x64 교차 의존**
  → 32비트 전용 DLL을 x64에서 로드 시 실패. 타깃 플랫폼 맞추어 빌드.

---

## 참고용 미니 코드 조각

### 5-1. 가장 작은 Dialog 이벤트 핸들링 스니펫

```cpp
// 리소스: IDD_MAIN, 버튼 IDC_BTN_HELLO
class CMainDlg : public CDialogEx {
public:
    CMainDlg() : CDialogEx(IDD_MAIN) {}
protected:
    afx_msg void OnBnClickedHello() {
        AfxMessageBox(_T("Hello, MFC!"));
    }
    DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_BN_CLICKED(IDC_BTN_HELLO, &CMainDlg::OnBnClickedHello)
END_MESSAGE_MAP()
```

### 5-2. 애플리케이션 진입점(앱 객체)

```cpp
class CMyApp : public CWinApp {
public:
    virtual BOOL InitInstance() {
        CWinApp::InitInstance();
        CMainDlg dlg;
        m_pMainWnd = &dlg;
        dlg.DoModal();     // 모달 대화상자 루프
        return FALSE;      // 대화상자 종료 후 앱 종료
    }
};

CMyApp theApp;
```

---

## 결론

- **MFC는 Win32의 본질을 보존**하면서 생산성을 높여주는 **얇은 C++ 프레임워크**입니다.
- 현대 UI/크로스플랫폼이 필요 없다면, 특히 **레거시 연장·네이티브 성능·폐쇄망 배포** 요구가 있을 때 **지금도 유효한 선택**입니다.
- 환경은 **Unicode + x64 + (배포 정책에 맞춘 Shared/Static)** 조합을 기본으로 하되, **레거시 의존성**에 맞게 x86/MBCS로 조정하세요.
