---
layout: post
title: 파이썬 - 숫자 자료형
date: 2024-07-28 19:20:23 +0900
category: Python
---
# 파이썬 숫자형

- 파이썬의 숫자형은 **정수형(int)**, **실수형(float)**가 핵심이며, 필요에 따라 **Decimal**, **Fraction**, **complex** 등을 사용합니다.
- 모든 숫자형은 **불변(immutable)** 입니다. 연산 시 **새 객체**가 만들어집니다.

---

## 1. 정수형 (int)

파이썬의 `int`는 **임의정밀도**를 가지며, 메모리가 허용하는 한 오버플로우 없이 커질 수 있습니다.

### (1) 생성과 기본 예제
```python
# 양수/음수/0
x = 42
y = -10
z = 0
print(type(x), type(y), type(z))  # <class 'int'>
```

### (2) 진법 표기와 변환
- 10진(기본): `42`
- 2진: `0b...`
- 8진: `0o...`
- 16진: `0x...`

```python
n = 42
print(bin(n))  # '0b101010'
print(oct(n))  # '0o52'
print(hex(n))  # '0x2a'

print(int("101010", 2))  # 42
print(int("2a", 16))     # 42
```

### (3) 가독성 구분자
```python
million = 1_000_000
print(million)  # 1000000
```

### (4) 산술 연산자
```python
a, b = 10, 3
print(a + b)   # 13
print(a - b)   # 7
print(a * b)   # 30
print(a / b)   # 3.3333333333333335 (float)
print(a // b)  # 3                  (정수 몫: floor)
print(a % b)   # 1
print(a ** b)  # 1000
print(divmod(a, b))  # (3, 1)
```

> **음수 주의**: `//`는 **바닥 나눗셈**입니다.
```python
print(-7 // 3)  # -3
print(-7 % 3)   # 2
# 항등식: a == (a//b)*b + (a%b)  항상 성립
```

### (5) 비트 연산 & 유틸
```python
x, y = 0b10110, 0b01011
print(bin(x & y))  # '0b01010'
print(bin(x | y))  # '0b11111'
print(bin(x ^ y))  # '0b11101'
print(bin(x << 2)) # '0b101100'
print(bin(x >> 1)) # '0b1011'

# 비트 길이/1의 개수
n = 0b1011010000
print(n.bit_length())  # 필요한 비트 수
print(n.bit_count())   # 1 비트 개수
```

### (6) 수학 유틸(`math`)
```python
import math
print(math.isqrt(10))     # 3
print(math.gcd(84, 36))   # 12
print(math.lcm(6, 15))    # 30
print(math.comb(10, 3))   # 120
print(math.perm(10, 3))   # 720
print(math.factorial(20)) # 큰 수도 정확
```

### (7) 큰 정수와 보안 난수
```python
import secrets
p = secrets.randbits(2048)     # 2048비트 난수
print(p.bit_length())          # 2048
```

---

## 2. 실수형 (float)

파이썬 `float`는 **IEEE 754 배정밀도(64-bit)** 로 표현됩니다. 많은 십진 소수는 **정확히 표현되지 않습니다**.

### (1) 기본 예제
```python
a = 3.14
b = -2.718
c = 1.0
print(type(a), type(b), type(c))  # <class 'float'>
```

### (2) 과학적 표기
```python
d = 1.23e3   # 1230.0
e = 4.56E-2  # 0.0456
```

### (3) 특수값: 무한대/NaN
```python
import math
pos_inf = float('inf')
neg_inf = float('-inf')
nan = float('nan')

print(math.isfinite(pos_inf))  # False
print(math.isnan(nan))         # True
print(nan == nan)              # False (NaN은 자기 자신과도 다르다)
```

### (4) 부동소수 오차와 비교 전략
```python
x = 0.1 + 0.2
print(x)         # 0.30000000000000004
print(x == 0.3)  # False

import math
print(math.isclose(x, 0.3))                    # True (기본 허용오차)
print(math.isclose(1.0000001, 1.0, rel_tol=1e-6))  # True
print(math.isclose(1e-12, 0.0, abs_tol=1e-9))      # True
```

### (5) 반올림: `round()`는 **은행가 반올림(half to even)**
```python
print(round(2.5))  # 2
print(round(3.5))  # 4
print(round(2.6))  # 3
print(round(2.4))  # 2
```

#### 일반적 4/5 반올림(0.5 올림) — 권장 방법: `decimal`
```python
from decimal import Decimal, ROUND_HALF_UP

def round_half_up(val, ndigits=0):
    q = Decimal(str(val)).quantize(Decimal(f'1e-{ndigits}'), rounding=ROUND_HALF_UP)
    return float(q)

print(round_half_up(1.5), round_half_up(2.5))  # 2.0 3.0
```

#### 근사 수학 방법(주의: 이진 오차 영향 가능)
```python
import math
def round_half_up_math(value, ndigits=0):
    k = 10 ** ndigits
    return math.floor(value * k + 0.5) / k
```

> **권장하지 않음**: 아주 작은 값을 더해 `round(1.5 + 1e-12)` 같은 편법은 입력/플랫폼에 따라 깨질 수 있음.

### (6) 분해/인접값(ULP)
```python
import math

x = 10.75
m, e = math.frexp(x)    # x = m * 2**e, 0.5 <= m < 1
print(m, e)
print(math.ldexp(m, e)) # 10.75 복원

print(math.nextafter(1.0, math.inf))  # 바로 다음 representable 값
print(math.nextafter(1.0, 0.0))       # 바로 이전 representable 값
```

### (7) 출력 서식
```python
x = 1234.56789
print(f"{x:.2f}")   # 1234.57
print(f"{x:.3e}")   # 1.235e+03
print(f"{x:.6g}")   # 1234.57 (유효숫자 6)
```

---

## 3. 타입 변환

### (1) 정수 → 실수, 실수 → 정수
```python
x = 42
print(float(x))  # 42.0

y = 3.99
print(int(y))    # 3 (버림)
```

### (2) 문자열 ↔ 숫자
```python
print(int("42"))       # 42
print(float("3.14"))   # 3.14

# 진법 지정
print(int("2A", 16))   # 42
print(int("101010", 2))# 42
```

---

## 4. 정확한 10진 반올림/금융 계산: `decimal`

부동소수(float)는 세금/통화처럼 **정확한 10진 반올림**이 중요한 계산에 적합하지 않습니다. `decimal.Decimal`을 사용하세요.

### (1) 기본 사용
```python
from decimal import Decimal, getcontext, ROUND_HALF_UP

getcontext().prec = 28  # 기본 정밀도
price = Decimal("19.99")
qty   = Decimal("3")
tax   = Decimal("0.1")

subtotal = price * qty
total = (subtotal * (Decimal("1") + tax)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
print(total)  # 65.97
```

> **중요**: `Decimal("...")`처럼 **문자열로 생성**하세요. `Decimal(0.1)`은 float 오차를 끌고 옵니다.

### (2) 반올림 모드
- `ROUND_HALF_UP`, `ROUND_HALF_EVEN`, `ROUND_DOWN`, `ROUND_UP`, `ROUND_FLOOR`, `ROUND_CEILING`, `ROUND_HALF_DOWN`, `ROUND_05UP`

```python
from decimal import Decimal, localcontext, ROUND_FLOOR

with localcontext() as ctx:
    ctx.rounding = ROUND_FLOOR
    print(Decimal("2.9").quantize(Decimal("1")))  # 2
```

---

## 5. 정확한 비율/분수: `fractions.Fraction` (보강)

정확한 비/기하/조합 계산에는 유리수(`Fraction`)가 편리합니다.

```python
from fractions import Fraction

f = Fraction(1, 3) + Fraction(1, 6)
print(f)  # 1/2

print(Fraction("0.1"))              # 1/10 (문자열 경유 권장)
print(Fraction(0.1))                # 아주 긴 분수(이진 오차 영향)
print(Fraction(0.1).limit_denominator())  # 1/10 근사
```

---

## 6. 복소수: `complex` (보강)

신호처리/기하/수치해석에서 사용합니다.

```python
z1 = 3 + 4j
z2 = complex(1, -2)
print(z1 + z2, z1 * z2)
print(z1.real, z1.imag)  # 3.0 4.0
```

---

## 7. 숫자는 불변(immutable)

숫자형 객체는 변경 불가이며, 연산 시 **새 객체**가 생성됩니다.

```python
a = 10
print(id(a))
a = a + 5
print(id(a))  # 다른 id (새 객체)
```

---

## 8. 실무 팁 & 자주 하는 실수

1) **부동소수 비교**에 `==` 사용 금지 → `math.isclose()` 사용  
2) **반올림 정책 명시**: float의 `round()`는 **half-to-even**  
3) 통화/세금은 **Decimal + ROUND_HALF_UP**로 계약 고정  
4) `Decimal(0.1)` 금지 → 반드시 `Decimal("0.1")`  
5) 음수 `//`는 **floor** → C/Java와 결과가 다를 수 있음  
6) `bool`은 `int`의 서브클래스: `True+True == 2` (합산 시 주의)

---

## 9. 실전 시나리오 예제

### (1) 가격 합계 + 세금(반올림 포함)
```python
from decimal import Decimal, ROUND_HALF_UP

def total_with_tax(lines, tax="0.1"):
    T = Decimal("0")
    TAX = Decimal(tax)
    for price_s, qty in lines:
        price = Decimal(price_s)
        line  = price * qty
        T += line
    return (T * (Decimal("1") + TAX)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)

print(total_with_tax([("3.333", 3), ("19.99", 2), ("0.10", 7)]))  # 65.97 등
```

### (2) 부동소수 누적 오차와 Decimal 비교
```python
from decimal import Decimal
x = sum([0.1] * 10)
y = sum([Decimal("0.1")] * 10)
print(x)  # 0.9999999999999999
print(y)  # 1.0
```

### (3) 모듈러 지수(정수) — 큰 수에서도 빠름
```python
print(pow(123456789, 987654321, 1000000007))
```

---

## 10. 참고: 표준 라이브러리 맵

- `math` : 실수 수학(삼각/로그/하이퍼볼릭, `isclose`, `nextafter`, `comb`, `perm`, `isqrt` 등)
- `decimal` : 10진 고정소수점(정밀/반올림 정책)
- `fractions` : 유리수(정확한 비율)
- `random`/`secrets` : 난수/보안난수
- `cmath` : 복소수 수학