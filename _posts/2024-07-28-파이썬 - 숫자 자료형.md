---
layout: post
title: 파이썬 - 숫자 자료형
date: 2024-07-28 19:20:23 +0900
category: Python
---
# 파이썬 숫자형

파이썬의 숫자형은 정수형(int)과 실수형(float)을 중심으로 하며, 상황에 따라 Decimal, Fraction, complex 등으로 확장됩니다. 모든 숫자형은 불변(immutable) 객체라는 점이 핵심이며, 연산을 수행하면 항상 새로운 객체가 생성됩니다.

---

## 정수형 (int)

파이썬의 `int` 타입은 임의정밀도를 지원하여 메모리 한계 내에서는 숫자 크기에 제약 없이 사용할 수 있습니다.

### 생성과 기본 활용
```python
# 양수, 음수, 0의 표현
x = 42
y = -10
z = 0
print(type(x), type(y), type(z))  # 모두 <class 'int'>
```

### 다양한 진법 표현과 변환
파이썬은 2진법(`0b`), 8진법(`0o`), 16진법(`0x`) 접두사를 지원합니다.
```python
n = 42
print(bin(n))  # '0b101010'
print(oct(n))  # '0o52'
print(hex(n))  # '0x2a'

# 문자열을 특정 진법으로 변환
print(int("101010", 2))  # 42
print(int("2a", 16))     # 42
```

### 가독성 향상을 위한 구분자
큰 숫자를 표기할 때는 언더스코어(`_`)를 구분자로 사용할 수 있습니다.
```python
million = 1_000_000
print(million)  # 1000000
```

### 산술 연산
```python
a, b = 10, 3
print(a + b)   # 13
print(a - b)   # 7
print(a * b)   # 30
print(a / b)   # 3.3333333333333335 (결과는 항상 float)
print(a // b)  # 3 (정수 나눗셈, 몫)
print(a % b)   # 1 (나머지)
print(a ** b)  # 1000 (거듭제곱)
print(divmod(a, b))  # (3, 1) (몫과 나머지 동시 반환)
```
음수에 대한 정수 나눗셈(`//`)과 나머지(`%`) 연산은 바닥 나눗셈 규칙을 따릅니다.
```python
print(-7 // 3)  # -3
print(-7 % 3)   # 2
```

### 비트 연산 및 정보 확인
```python
x, y = 0b10110, 0b01011
print(bin(x & y))  # AND: '0b01010'
print(bin(x | y))  # OR:  '0b11111'
print(bin(x ^ y))  # XOR: '0b11101'
print(bin(x << 2)) # 왼쪽 시프트: '0b101100'
print(bin(x >> 1)) # 오른쪽 시프트: '0b1011'

n = 0b1011010000
print(n.bit_length())  # 값을 표현하는 데 필요한 최소 비트 수
print(n.bit_count())   # 1인 비트의 개수 (해밍 가중치)
```

### 수학 관련 유틸리티 (`math` 모듈)
```python
import math
print(math.isqrt(10))     # 10의 정수 제곱근: 3
print(math.gcd(84, 36))   # 최대공약수: 12
print(math.lcm(6, 15))    # 최소공배수: 30
print(math.comb(10, 3))   # 조합: 120
print(math.perm(10, 3))   # 순열: 720
print(math.factorial(20)) # 큰 수의 팩토리얼도 정확하게 계산
```

### 큰 정수와 보안 난수 생성
```python
import secrets
p = secrets.randbits(2048)     # 2048비트 크기의 안전한 난수 정수 생성
print(p.bit_length())          # 2048
```

---

## 실수형 (float)

파이썬의 `float`는 IEEE 754 표준의 배정밀도(64비트) 부동소수점 숫자를 의미합니다. 많은 십진 소수는 이진법으로 정확히 표현할 수 없어 근사값으로 저장됩니다.

### 기본 생성
```python
a = 3.14
b = -2.718
c = 1.0
print(type(a), type(b), type(c))  # 모두 <class 'float'>
```

### 과학적 표기법
```python
d = 1.23e3   # 1230.0
e = 4.56E-2  # 0.0456
```

### 특수한 값: 무한대와 NaN
```python
import math
pos_inf = float('inf')
neg_inf = float('-inf')
nan = float('nan')

print(math.isfinite(pos_inf))  # False (유한한 값인지 확인)
print(math.isnan(nan))         # True (NaN인지 확인)
print(nan == nan)              # False (NaN은 자기 자신과도 비교되지 않음)
```

### 부동소수점의 정밀도 문제와 비교 방법
```python
x = 0.1 + 0.2
print(x)         # 0.30000000000000004 (정확한 0.3이 아님)
print(x == 0.3)  # False (직접 비교는 위험)

# 안전한 비교 방법: math.isclose()
import math
print(math.isclose(x, 0.3))                    # True (기본 허용오차 사용)
print(math.isclose(1.0000001, 1.0, rel_tol=1e-6))  # 상대 오차 기준
print(math.isclose(1e-12, 0.0, abs_tol=1e-9))      # 절대 오차 기준
```

### 반올림: round() 함수의 동작
파이썬 기본 `round()` 함수는 "반올림 반짝"(round half to even, 은행가 반올림) 방식을 사용합니다.
```python
print(round(2.5))  # 2 (가까운 짝수로)
print(round(3.5))  # 4 (가까운 짝수로)
print(round(2.6))  # 3
print(round(2.4))  # 2
```

#### 정확한 십진 반올림이 필요할 때: decimal 모듈 사용
```python
from decimal import Decimal, ROUND_HALF_UP

def round_half_up(val, ndigits=0):
    """전통적인 사사오입(반올림) 방식을 구현합니다."""
    q = Decimal(str(val)).quantize(Decimal(f'1e-{ndigits}'), rounding=ROUND_HALF_UP)
    return float(q) if ndigits > 0 else int(q)

print(round_half_up(1.5), round_half_up(2.5))  # 2.0, 3.0
```

### 실수의 내부 표현 탐구
```python
import math

x = 10.75
# 숫자를 가수(mantissa)와 지수(exponent)로 분해: x = m * 2**e
m, e = math.frexp(x)
print(m, e)                     # 0.671875 4
print(math.ldexp(m, e))        # 10.75 (원래 값 복원)

# 시스템에서 표현 가능한 바로 다음/이전 숫자 확인
print(math.nextafter(1.0, math.inf))  # 1.0보다 큰 가장 작은 수
print(math.nextafter(1.0, 0.0))       # 1.0보다 작은 가장 큰 수
```

### 출력 형식 지정
```python
x = 1234.56789
print(f"{x:.2f}")   # 소수점 둘째 자리까지: "1234.57"
print(f"{x:.3e}")   # 과학적 표기법: "1.235e+03"
print(f"{x:.6g}")   # 유효숫자 6자리: "1234.57"
```

---

## 타입 변환

### 정수와 실수 사이 변환
```python
x = 42
print(float(x))  # 42.0

y = 3.99
print(int(y))    # 3 (소수점 이하 버림)
```

### 문자열을 숫자로 변환
```python
print(int("42"))       # 42
print(float("3.14"))   # 3.14

# 진법 지정 변환
print(int("2A", 16))   # 42
print(int("101010", 2))# 42
```

---

## 정확한 십진 계산: `decimal` 모듈

금융 계산이나 세금 계산처럼 반올림과 정밀도가 중요한 분야에서는 `float` 대신 `decimal.Decimal`을 사용해야 합니다.

### 기본 사용법
```python
from decimal import Decimal, getcontext, ROUND_HALF_UP

# 전체 정밀도 설정 (기본값은 28자리)
getcontext().prec = 28

price = Decimal("19.99")
qty   = Decimal("3")
tax   = Decimal("0.1")

subtotal = price * qty
total = (subtotal * (Decimal("1") + tax)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
print(total)  # 65.97
```
**중요**: `Decimal(0.1)`처럼 실수로 생성하면 부동소수점 오차가 그대로 전달되므로, 반드시 문자열로 생성해야 정확한 값을 얻을 수 있습니다.

### 다양한 반올림 모드
`decimal` 모듈은 여러 반올림 방식을 제공하여 요구사항에 맞게 선택할 수 있습니다.
```python
from decimal import Decimal, localcontext, ROUND_FLOOR, ROUND_HALF_EVEN

with localcontext() as ctx:
    ctx.rounding = ROUND_FLOOR
    print(Decimal("2.9").quantize(Decimal("1")))  # 2 (내림)

# 기본 round() 함수와 동일한 반올림 (은행가 방식)
print(Decimal("2.5").quantize(Decimal("1"), rounding=ROUND_HALF_EVEN))  # 2
```

---

## 정확한 분수 표현: `fractions.Fraction`

유리수를 정확하게 표현해야 하는 계산에는 `Fraction`을 사용합니다.
```python
from fractions import Fraction

f = Fraction(1, 3) + Fraction(1, 6)
print(f)  # 1/2

# 소수를 분수로 변환 (문자열로 변환 권장)
print(Fraction("0.1"))              # 정확히 1/10
print(Fraction(0.1))                # 부정확 (부동소수점 오차 포함)
print(Fraction(0.1).limit_denominator())  # 분모를 제한하여 근사 분수 생성 (1/10)
```

---

## 복소수: `complex`

공학, 물리학, 신호 처리 분야에서 널리 사용됩니다.
```python
z1 = 3 + 4j
z2 = complex(1, -2)
print(z1 + z2)  # (4+2j)
print(z1 * z2)  # (11-2j)
print(z1.real, z1.imag)  # 실수부: 3.0, 허수부: 4.0
print(abs(z1))           # 크기(절댓값): 5.0
```

---

## 숫자형의 불변성

모든 숫자형 객체는 불변입니다. 연산을 수행하면 값이 변경되는 것이 아니라 새로운 객체가 생성됩니다.
```python
a = 10
print(id(a))  # 객체의 고유 ID
a = a + 5
print(id(a))  # 이전과 다른 ID (새로운 객체)
```

---

## 실무 적용 팁과 주의사항

1.  **부동소수점 비교**: 절대 `==` 연산자를 직접 사용하지 마세요. 항상 `math.isclose()` 함수를 통해 허용 오차 범위 내에서 비교하십시오.
2.  **반올림 정책 인지**: 내장 `round()` 함수의 동작(은행가 반올림)을 이해하고, 필요시 `decimal` 모듈을 사용해 명시적인 반올림 규칙을 적용하세요.
3.  **금융 계산**: 화폐, 세금, 이자 계산은 반드시 `decimal.Decimal` 타입을 사용하고, `ROUND_HALF_UP` 같은 명시적 반올림을 설정하세요.
4.  **Decimal 생성 주의**: `Decimal(0.1)` 대신 항상 `Decimal("0.1")` 처럼 문자열 인자로 생성하여 초기 오차를 방지하세요.
5.  **음수 나눗셈**: `//`와 `%` 연산은 음수에서의 동작이 C나 Java와 다를 수 있으므로 알고리즘을 설계할 때 유의하세요.
6.  **불린 타입의 특성**: `bool`은 `int`의 서브클래스입니다. `True + True`는 `2`로 계산되므로, 숫자 컨텍스트에서 사용할 때는 의도치 않은 결과가 나올 수 있습니다.

---

## 결론

파이썬의 숫자형 시스템은 단순한 정수와 실수를 넘어 다양한 요구사항을 충족시키도록 설계되어 있습니다. 기본 `int`와 `float`를 이해하는 것이 출발점이지만, 정밀도가 요구되는 계산에는 `decimal`, 정확한 비율에는 `fractions`, 공학적 계산에는 `complex`를 선택적으로 활용할 수 있어야 합니다. 각 타입의 내부 표현 방식과 한계(특히 부동소수점의 정밀도 문제)를 정확히 인지하고, 상황에 맞는 비교 방법과 반올림 전략을 수립하는 것이 안정적인 프로그램을 작성하는 핵심입니다.