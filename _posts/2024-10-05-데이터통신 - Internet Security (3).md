---
layout: post
title: 데이터 통신 - Internet Security (3)
date: 2024-10-01 20:20:23 +0900
category: DataCommunication
---
# Application Layer Security — Email Security, PGP, S/MIME

이 장에서는 **애플리케이션 계층에서의 이메일 보안**을 다룬다.
특히 세 가지 축에 초점을 맞춘다.

- 이메일 보안 전반(Email security)
- **PGP / OpenPGP**
- **S/MIME**

아래 내용은 네트워크 교과서 스타일을 유지하되, 실제 운영·개발에서 바로 연결될 수 있도록 예제와 상황을 풍부하게 붙였다.

---

## 이메일 보안 개요 (Email Security)

### 이메일이 특히 위험한 이유

이메일은 **기본 설계 자체가 평문 전송**을 전제로 만들어졌다.

- SMTP(전송), POP3/IMAP(수신)은 원래 **암호화·인증이 없는 텍스트 프로토콜**이었다.
- 메일은 수많은 중간 MTA(Mail Transfer Agent)를 거치며, 각 MTA는 메시지 내용을 평문으로 볼 수 있다.
- 발신자 주소(From:)는 **손쉽게 위조** 가능하다.

현대의 공격·위협은 다음을 포함한다.

- **도청**: 네트워크 상에서 메일 내용·첨부파일을 가로채 열람
- **위변조**: 메일 내용을 중간에서 수정하고도 사용자가 눈치 못 채게 만듦
- **스푸핑(spoofing)**: From 필드를 위조하여 신뢰받는 조직인 것처럼 가장
- **피싱(phishing)**: 악성 링크/첨부를 포함한 위장 메일로 계정·금융 정보 탈취
- **랜섬웨어/멀웨어 유포**: 첨부 파일이나 악성 링크를 통해 악성코드 설치

따라서 이메일 보안의 목표는 전통적인 보안 목표와 동일하지만, **메일의 특성**을 고려한 구체적인 메커니즘이 필요하다.

---

### 이메일에서 달성해야 할 보안 목표

보안 목표를 수식으로 단순화해 보면:

- 기밀성(Confidentiality): 공격자 \(A\)가 메시지 \(M\)의 내용을 알아낼 확률을
  $$P(\text{A가 } M \text{을 이해}) \approx 0$$
  으로 만드는 것.
- 무결성(Integrity): 수신자가 받은 메시지 \(M'\)가 발신자가 보낸 원본 \(M\)과 동일함을 검증 가능해야 한다.
- 인증(Authentication): 수신자는 “이 메시지를 보낸 사람이 진짜 Alice인가?”를 확인할 수 있어야 한다.
- 부인방지(Non-repudiation): 나중에 Alice가 “나 그런 메시지 안 보냈다”고 부인하기 어렵게 만드는 것.
- 가용성(Availability): 필터링·보안 장치 때문에 정당한 메일이 과도하게 차단되지 않는 것.

이메일 보안 기술들은 이 목표들을 서로 다른 레이어에서 지원한다.

---

### 보안 계층: 전송·도메인·콘텐츠

현대 이메일 보안은 **3계층**으로 보는 것이 이해하기 쉽다.

1. **전송 보안(Transport Security)**
   - SMTP, IMAP, POP3 세션을 **TLS로 암호화** (STARTTLS, SMTPS 등)
   - 공격자가 백본망에서 트래픽을 캡처해도 내용은 보지 못하도록 함
   - 미국 NIST는 이메일 전송 시 TLS를 기본 보안 메커니즘으로 사용할 것을 권고한다.

2. **도메인 수준 인증(Domain-level Authentication)**
   - 발신 도메인이 진짜인지 확인
   - **SPF, DKIM, DMARC** 등을 사용해 스푸핑·피싱 방어 강화

3. **콘텐츠 수준 보안(Content-level Security)**
   - **PGP(OpenPGP)**, **S/MIME**을 사용해 **메일 본문·첨부 자체를 암호화/전자서명**
   - 메일이 여러 서버를 통과하더라도, 최종 수신자 외에는 내용을 읽지 못하게 함
   - 이 장의 핵심이 바로 이 부분이다.

실제 환경에서는 **TLS + SPF/DKIM/DMARC + (PGP 또는 S/MIME)** 를 조합해 사용한다. 콘텐츠 보안은 **엔드 투 엔드** 특성이 강해 사용자가 직접 키를 관리해야 한다.

---

## PGP / OpenPGP

### 개념 및 설계 목표

**PGP(Pretty Good Privacy)** 는 이메일과 파일의 **암호화 및 전자 서명**을 위해 설계된 시스템이다. 현대 구현체는 IETF의 **OpenPGP 표준(RFC 4880, 4880bis 초안)** 을 따른다.

핵심 설계 목표:

- 강력한 암호 기술을 **일반 사용자가 쓸 수 있도록** 할 것
- 중앙 CA 없이도 동작 가능하도록 **웹 오브 트러스트(Web of Trust)** 모델 채택
- 텍스트, 바이너리, 첨부파일 등에 광범위하게 적용 가능
- 서명, 암호화, 압축, 키 관리 기능을 **통합한 포맷** 제공

---

### PGP의 주요 구성 요소

PGP는 내부적으로 다양한 **패킷(packet)** 으로 구성된 메시지 포맷을 사용한다. RFC 4880은 다음과 같은 요소를 정의한다.

- **공개키 패킷**: RSA, ECC 등의 공개키 정보
- **비밀키 패킷**: 패스프레이즈로 보호되는 개인키
- **서명 패킷(Signature Packet)**: 서명 알고리즘, 해시, 서명 값
- **리터럴 데이터 패킷**: 실제 메일/파일 내용
- **대칭키 암호화 패킷**: 세션키로 암호화된 콘텐츠
- **공개키 암호화 세션키 패킷**: 세션키를 수신자의 공개키로 암호화한 부분

실제 이메일에서는 이 패킷들이 텍스트 기반 ASCII armor(`-----BEGIN PGP MESSAGE-----`) 형태로 인코딩되어 전송된다.

---

### PGP의 암호·서명 절차 (이론)

PGP 메일을 암호화하고 서명하는 흐름을 수식으로 단순화해 보자.

- 발신자(Alice)와 수신자(Bob)가 있다고 하자.
- Bob의 공개키를 \(K_{B}^{pub}\), 개인키를 \(K_{B}^{priv}\)
  Alice의 공개키/개인키를 \(K_{A}^{pub}, K_{A}^{priv}\) 라 하자.
- 메시지 \(M\)에 대해:

1. **서명**:
   - 해시:
     $$h = H(M)$$
   - 개인키 서명:
     $$\sigma = \text{Sign}_{K_A^{priv}}(h)$$
   - 서명 포함 메시지: \((M, \sigma)\)

2. **세션키 생성**:
   - 대칭키 \(k\)를 랜덤하게 생성 (AES-256 등)

3. **콘텐츠 암호화**:
   -
     $$C = \text{Enc}_k(M, \sigma)$$

4. **세션키 암호화**:
   -
     $$E_k = \text{Enc}_{K_B^{pub}}(k)$$

5. 실제 전송되는 PGP 메시지:
   - \((E_k, C)\) 조합을 OpenPGP 포맷으로 인코딩

수신자 Bob은 자신의 개인키 \(K_B^{priv}\)로 \(E_k\)를 복호화해 \(k\)를 얻고, 그 \(k\)로 \(C\)를 복호화하여 \((M, \sigma)\)를 얻은 뒤, Alice의 공개키 \(K_A^{pub}\)로 서명을 검증 한다.

---

### 웹 오브 트러스트(Web of Trust)

PGP의 가장 중요한 특징은 **중앙 CA 없이도 신뢰를 구축**한다는 점이다.

- 각 사용자는 자신의 키 쌍을 생성하고, 그 **지문(fingerprint)** 을 친구·동료에게 직접 알려 준다.
- 다른 사람이 자신의 키로 그 키에 **서명**함으로써, “나는 이 키가 정말 이 사람의 것임을 믿는다”라는 선언을 한다.
- 사용자는 여러 사람의 서명을 바탕으로 “이 키가 신뢰할 만한가?”를 **주관적 기준**으로 결정한다.

예를 들어:

- Alice는 Bob을 직접 만나 Bob의 키 지문을 확인하고, 그 키에 서명한다.
- Carol은 Alice를 신뢰하므로, Alice의 서명이 찍힌 Bob의 키를 어느 정도 신뢰한다.

이 방식은 유연하지만, **대규모 조직에서 중앙 관리가 어렵다**는 단점이 있다. 그래서 엔터프라이즈 환경에서는 PGP보다 **S/MIME** 이 더 많이 사용된다.

---

### PGP 이메일 사용 예시 (상황 시나리오)

#### 상황 1: 개발자 둘이 소스코드 패치를 PGP로 교환

- Alice: 오픈소스 프로젝트의 메인테이너
- Bob: 외부 기여자

시나리오:

1. Bob은 GnuPG로 키 쌍을 생성하고, 자신의 공개키를 Alice에게 보낸다.
2. Alice는 Bob의 키 지문을 화상 회의 등으로 확인한 뒤, 그 키에 서명해 프로젝트 키 서버에 업로드한다.
3. Bob은 패치 파일을 만들고, PGP로 **암호화 + 서명**하여 메일로 전송한다.
4. Alice 메일 클라이언트(예: Thunderbird + Enigmail)는:
   - Bob의 서명을 검증해 “누가 보냈는지” 확인
   - 자신의 개인키로 메일 내용을 복호화

이렇게 하면, 메일 서버가 손상되더라도 **패치 내용은 유출되지 않고**, **누가 보냈는지** 명확히 알 수 있다.

#### 간단 GnuPG 명령 예시

```bash
# 1) 키 생성

gpg --full-generate-key

# 2) 상대 공개키 가져오기 (파일로 받은 경우)

gpg --import bob_public.asc

# 3) 상대 키에 서명 (지문 직접 확인 후)

gpg --sign-key bob@example.com

# 4) 파일을 서명 + 암호화해서 전송

gpg --encrypt --sign --armor -r bob@example.com patch.diff

# 생성된 patch.diff.asc 파일을 메일로 첨부

```

---

### PGP의 장단점 및 최신 동향

**장점**

- **엔드 투 엔드** 암호화 + 서명
- 메시지 포맷이 표준화(OpenPGP), 다수 구현체(GnuPG, OpenPGP.js 등) 존재
- 중앙 CA 없이도 개인 간 신뢰 구축 가능

**단점**

- 키 생성, 교환, 신뢰 설정 과정이 **일반 사용자에게는 매우 어렵다**.
- 기업 환경에서는 계정·조직 수준 정책과 연동하기가 까다로운 편.
- 일부 취약점(EFAIL 등)은 PGP뿐 아니라 S/MIME에도 영향을 줬고, 구현·클라이언트 설정의 중요성을 다시 상기시켰다.

**최근 동향**

- OpenPGP 포맷을 개선한 **RFC 4880bis** 작업이 진행 중이며, 현대 암호 알고리즘과 구현 상의 문제(예: AEAD, UX 개선)를 반영하고 있다.

---

## S/MIME

### 개념 및 설계 목표

**S/MIME(Secure/Multipurpose Internet Mail Extensions)** 는 **MIME 데이터의 암호화 및 서명 표준**이다.
최신 버전은 **S/MIME 4.0 (RFC 8551)** 로, 메시지 서명·암호화·압축 등에 대한 형식을 정의한다.

설계 목표:

- 이메일에 보안 기능(서명, 암호화)을 **표준 MIME 구조** 안에서 통합
- X.509 기반 **PKI(public key infrastructure)** 와 자연스럽게 연계
- 기업·기관 환경에서 중앙 집중식 키·인증서 관리 가능

PGP가 “사용자 자율”에 가까운 모델이라면, S/MIME는 “**조직 중심**” 모델에 가까운 면이 있다.

---

### S/MIME와 MIME/CMS

S/MIME는 내부적으로 **CMS(Cryptographic Message Syntax)** 를 사용하며, MIME 위에 올라간다.

- 평문 이메일은 보통 `Content-Type: text/plain` 또는 `text/html`.
- S/MIME 서명 메시지는 대략 다음과 같이 표현된다.

```text
Content-Type: multipart/signed;
    protocol="application/pkcs7-signature";
    micalg=sha-256;
    boundary="signed-message-boundary"

--signed-message-boundary
Content-Type: text/plain; charset="utf-8"

Hello, this is a signed message.

--signed-message-boundary
Content-Type: application/pkcs7-signature; name="smime.p7s"
Content-Transfer-Encoding: base64

MIAGCSqGSIb3DQEHAqCAMIACAQEx...
--signed-message-boundary--
```

- 암호화 메시지는 `application/pkcs7-mime` 타입을 사용하여 **전체 내용을 CMS 객체로 감싼다**.

---

### 인증서와 PKI

S/MIME는 **X.509 인증서** 기반이다.

- 각 사용자는 CA로부터 **개인 인증서**를 발급받는다.
- 인증서에는 다음 정보가 포함됨:
  - 소유자의 이름, 이메일 주소
  - 공개키
  - 유효기간, 일련번호
  - 발급 CA, 서명

CA/Browser Forum은 **S/MIME 인증서의 베이스라인 요구사항**을 정의하여, 메일 보안용 공개 인증서 발급에 대한 최소 기준을 제시한다.

기업 환경에서의 흐름 예:

1. IT 부서가 내부 CA 또는 외부 상용 CA를 운영/계약한다.
2. 직원 계정(예: alice@corp.com)에 대해 **서명용·암호화용 인증서**를 발급한다.
3. Outlook, Apple Mail, Thunderbird 등 메일 클라이언트에 인증서를 배포한다.
4. 사용자는 별도 작업 없이도 “메일 서명/암호화” 버튼만 눌러 사용 가능하다.

---

### S/MIME 메시지 유형

S/MIME는 크게 세 가지 유형을 제공한다.

1. **서명만(Sign-only)**
   - 서명은 있지만 내용은 평문 (예: 법적 효력 있는 승인 메일)
2. **암호화만(Encrypt-only)**
   - 기밀성은 있지만 발신자 서명이 없음
3. **서명 + 암호화(Signed-then-Encrypted)**
   - 일반적으로 가장 많이 쓰임
   - 서명 후 암호화하면, 서명 정보조차 암호화되어 **발신자 정보 보호**에도 유리

예를 들어, 서명+암호화된 메시지는 다음과 같이 보인다.

```text
Content-Type: application/pkcs7-mime;
    smime-type=enveloped-data;
    name="smime.p7m"
Content-Transfer-Encoding: base64

MIICWQYJKoZIhvcNAQcDoIICSjCCAkYCAQAxggE...
```

메일 클라이언트는 수신자의 개인키로 이를 복호화하여, 내부 CMS 객체에서 원본 메일과 서명 정보를 복원한다.

---

### 실제 사용 시나리오

#### 시나리오 1: 미국 병원의 의료 데이터 전달

- 병원 A와 병원 B는 **미국 HIPAA** 등 규제를 준수해야 한다.
- 의료 기록(검사 결과, 진료 기록)을 이메일로 전달해야 하는 상황.

운영 방식:

1. 두 병원은 동일한 루트 CA 또는 상호 신뢰된 CA 하에서 **의료진용 S/MIME 인증서**를 발급받는다.
2. 병원 A의 의사가 환자 기록을 이메일로 전송할 때:
   - 메일 클라이언트에서 “S/MIME 서명 + 암호화” 옵션을 활성화.
   - 수신자(병원 B 의사)의 인증서를 사용해 메시지를 암호화.
3. 병원 B에서는 해당 의사의 개인키로 복호화 후 기록을 확인.

이렇게 하면:

- 네트워크와 메일 서버가 모두 공격당해도, **콘텐츠는 암호화**되어 보호된다.
- X.509 서명을 통해 **발신자(의사) 인증 및 비부인성**을 제공한다.

#### 시나리오 2: 기업 인사팀의 연봉 통지

- HR 부서는 직원 개별 연봉안을 메일로 통지해야 한다.
- 같은 회사 도메인 내에서, 직원마다 다른 기밀 정보를 보낸다.

구성:

- 내부 PKI 또는 상용 CA 이용, 직원별 S/MIME 인증서 배포
- 인사 담당자 클라이언트에서 **모든 연봉 통지 메일을 S/MIME 암호화+서명**

이렇게 하면:

- 인프라 운영자(메일 서버 관리자)조차 메일 내용을 평문으로 볼 수 없음
- 법적 분쟁 시, 서명된 메일을 **증거 자료**로 활용 가능

---

### S/MIME의 장단점 및 이슈

**장점**

- 대부분의 주요 이메일 클라이언트에 **기본 내장** (Outlook, Apple Mail, 일부 모바일 클라이언트 등)
- 엔터프라이즈 환경에서 중앙 집중적인 **인증서 배포·갱신·폐기 관리**가 가능
- 이메일뿐 아니라 일반 MIME 데이터에도 적용 가능

**단점**

- **웹메일** 환경에서는 개인키 보호 문제로 구현이 까다롭다. (서버에서 개인키를 관리하면 보안이 떨어지고, 브라우저에서만 키를 유지하면 UX가 나빠짐)
- 일부 과거 취약점(EFAIL 등)에서, 암호화된 메일 내용을 특수한 HTML 구성과 함께 재전송하여 평문을 유출하는 공격이 가능했음.
  → 현대 클라이언트들은 이 문제를 완화하기 위해 렌더링 방식과 경고 메시지를 개선했다.

**PGP와의 비교(요약)**

| 항목 | PGP / OpenPGP | S/MIME |
|------|---------------|--------|
| 신뢰 모델 | 사용자의 웹 오브 트러스트 | X.509 기반 PKI, CA 중심 |
| 배포 | 키 서버, 직접 교환 | CA·디렉터리 서비스 통해 중앙 관리 |
| 엔터프라이즈 도입 | 상대적으로 적음 | 기업 환경에서 더 널리 채택  |
| 사용성 | CLI·플러그인 위주, 학습 필요 | 메일 클라이언트에 내장된 경우 많음 |

---

## 이메일 보안의 현대적 조합

실전에서의 좋은 패턴은 다음과 같다.

1. **전송 계층**: SMTP/IMAP/POP3 모두 TLS 강제 (MTA-STS, TLS-RPT 등과 조합)
2. **도메인 인증**: SPF, DKIM, DMARC 설정으로 스푸핑·피싱 방지
3. **콘텐츠 보안**:
   - 개인 간 민감한 통신 → PGP 또는 S/MIME
   - 기업/기관 전체 → S/MIME 또는 기업용 E2EE 솔루션
4. **정책·교육**:
   - 사용자에게 **서명·암호화의 의미**와 사용 방법 교육
   - 키·인증서 분실 시의 대응 프로세스 명확화 (재발급, 폐기 등)

NIST “Trustworthy Email” 가이드라인 역시 이러한 계층적 접근(TLS, 도메인 인증, 콘텐츠 암호화)을 종합적으로 적용할 것을 권고한다.

---

## 간단 예제: PGP vs S/MIME 적용 설계 비교

### PGP 기반 설계(개인 사용자 중심)

- 블로그 운영자, 개발자, 오픈소스 Maintainer 등이 독자·기여자와 안전하게 소통하고자 할 때:

1. 블로그에 본인 PGP 공개키와 지문을 게시
2. 독자는 이 키로 블로그 운영자에게 보내는 메일을 암호화
3. 운영자는 기여자의 공개키를 수집하여, 보안 공지·패치를 암호화해서 전송

이 경우, 중앙 CA 없이도 **연결된 소규모 커뮤니티**에서는 충분히 큰 보안 효과를 얻을 수 있다.

### S/MIME 기반 설계(기업·기관 중심)

- 금융기관, 병원, 대기업에서 내부·외부 파트너와 기밀 정보를 주고받을 때:

1. 내부 AD/LDAP과 연동된 엔터프라이즈 CA 운영
2. 직원 계정 생성 시 자동으로 S/MIME 인증서 발급 및 메일 클라이언트에 배포
3. DLP(Data Loss Prevention) 솔루션과 연동하여, “민감도 높은 메일은 반드시 S/MIME 암호화” 정책 적용

이 경우, 조직 차원에서 **정책·로깅·감사**를 수반한 이메일 보안 체계를 구축할 수 있다.

---

## 마무리

- **PGP(OpenPGP)**: 개인·커뮤니티 중심, 강력하지만 사용성과 운영 측면에서 진입 장벽이 높은 편.
- **S/MIME**: PKI와 밀접하게 연동되어 조직·기업 환경에서 도입하기 좋고, 주요 메일 클라이언트에 통합되어 있어 사용성이 좋다.
- 두 기술 모두 **기밀성·무결성·인증·부인방지**를 제공하지만,
  “누가 키를 발급하고, 누가 무엇을 신뢰할지”에 대해 서로 다른 철학을 가진다.

현대 이메일 보안은 하나의 기술로 끝나지 않고,
**TLS + 도메인 인증(SPF/DKIM/DMARC) + PGP 또는 S/MIME** 의 조합으로 구성된다.
이 장에서 다룬 PGP와 S/MIME은 그 중에서도 **애플리케이션 계층의 마지막 방어선**이라고 볼 수 있다.
