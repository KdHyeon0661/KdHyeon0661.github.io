---
layout: post
title: 객체지향설계 - 캡슐화
date: 2025-07-10 18:20:23 +0900
category: 객체지향설계
---
# 캡슐화 (Encapsulation)

## 캡슐화란 무엇인가?

**정의**
캡슐화는 **데이터(상태)**와 그 데이터를 다루는 **행동(메서드)**을 **하나의 객체**로 묶고, **외부로부터 내부 구현을 숨기는 메커니즘**이다. 외부는 **허용된 메시지(퍼블릭 메서드)**를 통해서만 객체 상태를 바꿀 수 있다.

**세 가지 개념의 관계**

| 개념 | 초점 | 결과 |
|---|---|---|
| 캡슐화(Encapsulation) | 상태와 행위를 ‘동일 경계’로 묶음 | 객체가 자기 일은 스스로 처리 |
| 정보 은닉(Information Hiding) | 보여줄 것 vs 숨길 것 결정 | 내부 변경의 파급 최소화 |
| 추상화(Abstraction) | 본질만 노출(역할/계약) | 의도를 표현, 구현은 교체 가능 |

---

## 왜 캡슐화가 필요한가?

1) **내부 구현 보호** — 외부가 임의로 상태를 변경할 수 없음
2) **유지보수·확장 용이** — 인터페이스 유지한 채 내부 알고리즘/저장소 교체 가능
3) **유효성·안정성** — 불변식(invariant)으로 일관성 보장
4) **책임·역할 분리** — “무엇을” 요청하고 “어떻게”는 객체 내부에서 처리

---

## 캡슐화의 구현 방법

### 접근 제어자

| 언어 | 최소 공개 원칙 | 비고 |
|---|---|---|
| Java | `private` → `package-private` → `protected` → `public` | 모듈(`module-info.java`)로 패키지 외부 차단 |
| C# | `private` → `internal` → `protected` → `public` | `sealed`/`readonly`로 의도 강화 |
| C++ | `private`/`protected`/`public` | 가상 소멸자, pImpl로 은닉 |
| Python | 관례(`_name`), `__mangle` | 모듈 경계/네임스페이스로 은닉 |
| TypeScript | `private`/`protected`/`public` | 모듈 export 제어 |

```java
public class BankAccount {
    private int balance = 0;

    public void deposit(int amount) {
        if (amount <= 0) throw new IllegalArgumentException();
        balance += amount;
    }
    public int getBalance() { return balance; }
}
```

---

## 방지

### 잘못된 예(내부 구조 새어 나감)

```java
public class Cart {
    public final List<Item> items = new ArrayList<>(); // 외부가 직접 수정 가능
}
```

### 개선(불변 뷰/방어적 복사)

```java
public class Cart {
    private final List<Item> items = new ArrayList<>();
    public List<Item> items() { return java.util.Collections.unmodifiableList(items); }
    public void add(Item i){ items.add(Objects.requireNonNull(i)); }
}
```

### 배열·날짜·식별자 반환 시

- **배열**: `clone()` 혹은 `Arrays.copyOf`
- **mutable 날짜**: `Instant`, `LocalDate` 등 불변 타입 사용
- **식별자/엔티티**: 내부 ORM 엔티티를 그대로 노출하지 말고 **DTO** 사용

```java
public record OrderView(String id, String status, String total) { }
```

---

## 계약에 의한 설계(전제/사후/불변식)

공개 메서드에는 **전제(Pre)**, **사후(Post)**, **불변식(Inv)**을 명시한다.

$$
\text{Pre} \Rightarrow \text{Post} \quad \land \quad \text{항상 Inv 유지}
$$

예: 계좌 불변식

$$
\text{Inv}: \mathrm{balance} \ge 0
$$

입금/출금 계약

$$
\text{Pre}_{\text{deposit}}: \mathrm{amount} > 0,\quad
\text{Post}: \mathrm{balance}' = \mathrm{balance} + \mathrm{amount}
$$

$$
\text{Pre}_{\text{withdraw}}: \mathrm{amount} > 0 \land \mathrm{balance} \ge \mathrm{amount},\quad
\text{Post}: \mathrm{balance}' = \mathrm{balance} - \mathrm{amount}
$$

계약은 **객체 내부에서 검사**하고, 위반 시 **도메인 예외**를 던진다.

---

## Getter/Setter 남용의 문제와 해결

### 문제

- 전역 변수와 다를 바 없이 외부가 상태를 조종
- 로직이 **객체 밖**으로 새어 나가며, 테스트와 확장이 어려움

### 해결: Tell, Don’t Ask / 디미터 법칙

**데이터를 꺼내 계산하지 말고, 객체에게 시켜라.**

```java
// 나쁜 예
int discounted = order.getBase() - order.getDiscount();
order.setBase(discounted);

// 좋은 예
order.applyDiscount(Money.of("1000", "KRW")); // 의미 있는 메시지
```

디미터 법칙: 체이닝으로 내부 구조 유출 금지
`a.getB().getC().doX()` 대신 `a.doX()` 혹은 `a.requestXFor(b)`.

---

## 값 객체(Value Object)와 불변성

금액, 날짜 범위, 이메일, 좌표 등 **개념적 값**은 **불변 VO**로 모델링하면 캡슐화가 강해진다.

```java
public final class Money {
    private final java.math.BigDecimal amount;
    private final String currency; // "KRW"

    public static Money of(String amt, String cur){
        return new Money(new java.math.BigDecimal(amt), cur);
    }
    private Money(java.math.BigDecimal a, String c){
        if (a.scale() > 2) a = a.setScale(2, java.math.RoundingMode.HALF_UP);
        if (a.compareTo(java.math.BigDecimal.ZERO) < 0) throw new IllegalArgumentException();
        this.amount = a; this.currency = Objects.requireNonNull(c);
    }
    public Money add(Money other){ ensureSameCurrency(other); return new Money(amount.add(other.amount), currency); }
    private void ensureSameCurrency(Money other){ if(!currency.equals(other.currency)) throw new IllegalArgumentException(); }
    @Override public String toString(){ return amount.toPlainString()+" "+currency; }
}
```

- 외부가 내부 표현을 바꿀 수 없으므로 **표현 노출 문제 자체를 차단**.

---

## 모듈·패키지 경계로 캡슐화 강화

- Java 9+ 모듈: 공개 패키지와 내부 패키지를 **명시적으로 분리**
- C#: `internal`로 어셈블리 경계 내에서만 사용
- Python: `__all__`와 모듈 구성으로 외부 노출 제어
- C++: **pImpl**(Pointer to Implementation)로 바이너리 호환과 은닉

```cpp
// Foo.h
class Foo {
public:
  Foo();
  ~Foo();
  Foo(Foo&&) noexcept;
  Foo& operator=(Foo&&) noexcept;
  void doWork();
private:
  struct Impl;
  std::unique_ptr<Impl> pImpl; // 구현 은닉
};
```

---

## 동시성·원자성까지 캡슐화

**락·트랜잭션**은 외부가 알 필요 없는 내부 구현이다.
외부에서 `synchronized` 대상이나 락 객체를 노출하지 말라.

```java
public final class Counter {
    private int value;
    private final Object lock = new Object(); // 외부 노출 금지

    public void inc(){
        synchronized (lock){ value++; }
    }
    public int snapshot(){
        synchronized (lock){ return value; }
    }
}
```

- 재시도·멱등키 등 **오류 복구 정책**도 내부에 감춘다.

---

## API 경계: 인터페이스·포트/어댑터와 캡슐화

도메인(핵심)은 **역할(Port)**에 의존하고, 구현은 **어댑터**로 **경계 바깥**에 둔다.
도메인은 PG·DB·시계 등의 구체 구현을 알지 못한다.

```java
public interface PaymentPort { void pay(Money amount, String idempotencyKey); }
public final class StripeAdapter implements PaymentPort { public void pay(Money a, String k){ /* 외부 호출 */ } }

public final class OrderService {
    private final PaymentPort payment;
    public OrderService(PaymentPort p){ this.payment = p; }
    public void checkout(Order o){ payment.pay(o.total(), o.id()); }
}
```

**효과**: 내부(도메인) 캡슐화가 유지되고, 외부 교체가 쉽다.

---

## 다양한 언어에서의 캡슐화 스니펫

### C#

```csharp
public sealed class User {
    private string _name;
    public string Name {
        get => _name;
        set {
            if (string.IsNullOrWhiteSpace(value)) throw new ArgumentException();
            _name = value;
        }
    }
    public int Age { get; private set; }
    public void IncreaseAge() => Age++;
}
```

### Python (속성/프로퍼티)

```python
class User:
    def __init__(self, name, age=0):
        self._name = name
        self._age = 0
        self.age = age  # setter 경유

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if value < 0:
            raise ValueError("age must be >= 0")
        self._age = value
```

### JavaScript (클로저로 은닉)

```js
function makeCounter() {
  let value = 0; // 외부에서 접근 불가
  return {
    inc() { value += 1; },
    snapshot() { return value; }
  };
}
```

---

## 캡슐화가 잘 된 예 vs 잘못된 예

### 잘못된 예

```java
public class User {
    public String name;
    public int age;
}
```

### 개선

```java
public class User {
    private String name;
    private int age;

    public void rename(String newName){
        if (newName == null || newName.isBlank()) throw new IllegalArgumentException();
        this.name = newName;
    }
    public void becomeOlder(){ this.age += 1; } // 의미 있는 메시지
    public int age(){ return age; }
}
```

---

## 도메인 시나리오: 할인 규칙을 ‘행위’로 감싸기

### 안티패턴(게터/세터로 외부 제어)

```java
int discounted = order.getBasePrice() - order.getDiscount();
order.setBasePrice(discounted);
```

### 개선(행위로 요청)

```java
order.applyDiscount(Money.of("1000", "KRW"));
```

**수식(불변식)**

$$
\text{Inv}: \text{base} \ge 0 \land \text{discount} \ge 0 \land \text{final} = \text{base} - \text{discount} \ge 0
$$

---

## 테스트 전략: 블랙박스/계약 테스트

- **블랙박스**: 퍼블릭 인터페이스만 사용해 행위를 검증
- **계약 테스트**: 역할(인터페이스)에 대한 테스트를 공유해, 구현 교체에도 안전

```java
abstract class PaymentContract {
    protected abstract PaymentPort sut();
    @org.junit.jupiter.api.Test
    void pays_positive_amount(){
        sut().pay(Money.of("1000","KRW"), "k1");
    }
}
final class StripeAdapterTest extends PaymentContract {
    @Override protected PaymentPort sut(){ return new StripeAdapter(); }
}
```

---

## 리팩토링 레시피

### 공개 필드 → 은닉 + 의미 있는 메시지

```java
// Before
public int price;

// After
private int price;
public void applySurcharge(Money fee){ /* 검증 후 price 갱신 */ }
```

### 내부 구조 노출 → 불변 뷰/스냅샷

```java
public List<Item> items(){ return List.copyOf(this.items); }
```

### 세터 남용 → 의도 명확한 생성자/팩토리/빌더

```java
public final class User {
    private final String name;
    private final int age;
    private User(String name, int age){ /* 검증 */ this.name=name; this.age=age; }
    public static User of(String name, int age){ return new User(name, age); }
}
```

### 도메인 규칙 외부 유출 → 객체로 이동

- 컨트롤러/서비스의 분기 로직을 **도메인 메서드**로 이동(Tell-Don't-Ask)

---

## 캡슐화의 한계와 주의

- **캡슐화만**으로는 설계가 좋아지지 않는다: **역할·책임**이 먼저
- 무분별한 세터/게터는 **캡슐화 파괴**
- 상속 시 `protected` 남발은 **fragile base**로 이어짐 → 합성 우선
- 공개 API에 내부 타입(ORM 엔티티, 구체 컬렉션) 노출 금지

---

## 체크리스트

- 공개 API에 **구현 세부**가 새어 나오지 않는가(구체 컬렉션/엔티티/시간 소스)?
- 상태 변경은 **의미 있는 메시지**로만 가능한가(세터 남용 금지)?
- **전제/사후/불변식**을 코드/테스트로 고정했는가?
- 컬렉션/배열 반환은 **불변 뷰/방어적 복사**인가?
- 동시성/락/트랜잭션/멱등키는 **내부에서 은닉**되는가?
- 값 개념은 **불변 VO**로 모델링했는가?
- 모듈/패키지 경계로 **내부 구현을 격리**했는가?
- 인터페이스는 **작고 역할 중심(ISP)**인가, DIP가 지켜지는가?

---

## 종합 예제: 캡슐화 중심으로 재작성한 계좌

```java
// 도메인 예외
class InsufficientFundsException extends RuntimeException { public InsufficientFundsException(){ super("insufficient funds"); } }

// 값 객체
final class Money {
    private final java.math.BigDecimal amount; private final String currency;
    public static Money of(String a, String c){ return new Money(new java.math.BigDecimal(a), c); }
    private Money(java.math.BigDecimal a, String c){
        if (a.scale() > 2) a = a.setScale(2, java.math.RoundingMode.HALF_UP);
        if (a.compareTo(java.math.BigDecimal.ZERO) < 0) throw new IllegalArgumentException();
        this.amount=a; this.currency=java.util.Objects.requireNonNull(c);
    }
    Money add(Money o){ ensure(o); return new Money(amount.add(o.amount), currency); }
    Money subtract(Money o){ ensure(o); var r=amount.subtract(o.amount); if (r.compareTo(java.math.BigDecimal.ZERO)<0) throw new InsufficientFundsException(); return new Money(r, currency); }
    private void ensure(Money o){ if(!currency.equals(o.currency)) throw new IllegalArgumentException("currency mismatch"); }
    @Override public String toString(){ return amount.toPlainString()+" "+currency; }
}

// 캡슐화된 엔티티
final class BankAccount {
    private final String number;
    private Money balance; // 외부 직접 접근 불가

    private BankAccount(String number, Money initial){ this.number=number; this.balance=initial; }
    public static BankAccount open(String number, Money initial){ if(initial==null) throw new IllegalArgumentException(); return new BankAccount(number, initial); }

    public void deposit(Money amount){ balance = balance.add(amount); }
    public void withdraw(Money amount){ balance = balance.subtract(amount); }
    public Money balance(){ return balance; } // VO는 불변이므로 안전
    public String number(){ return number; }
}
```

사용:

```java
var acc = BankAccount.open("123-456", Money.of("100000","KRW"));
acc.deposit(Money.of("5000","KRW"));
acc.withdraw(Money.of("3000","KRW"));
System.out.println(acc.balance()); // 102000 KRW
```

- 상태 변경은 **의미 있는 메시지**(`deposit/withdraw`)로만 수행
- 금액은 **불변 VO**로 캡슐화
- 예외/검증은 **내부에서만** 시행

---

## 요약

- 캡슐화는 **상태+행위의 단위화**와 **구현 은닉**으로 변경의 파급을 막는다.
- Getter/Setter 남발을 지양하고 **의미 있는 메시지**로 모델의 의도를 드러내라.
- **표현 노출**을 막기 위해 불변 VO, 불변 뷰, 방어적 복사를 사용하라.
- 계약(전제/사후/불변식)을 코드/테스트로 고정하고, 동시성·트랜잭션 같은 **운영 세부는 내부에 감추라**.
- 모듈/패키지/포트-어댑터 경계로 **캡슐화를 수평(아키텍처 레벨)으로 확장**하라.
