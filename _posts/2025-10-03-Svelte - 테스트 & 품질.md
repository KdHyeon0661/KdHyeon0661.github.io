---
layout: post
title: Svelte - 테스트 & 품질
date: 2025-10-03 19:30:23 +0900
category: Svelte
---
# 13. 테스트 & 품질
**Lighthouse / Web Vitals 모니터링 · 유닛/컴포넌트 테스트(Vitest) · E2E 테스트(Playwright) · 스토리북/비주얼 리그레션(선택) · CI 기본 파이프라인**

> 이 장은 Svelte/SvelteKit 프로젝트에서 **품질을 지속적으로 보장**하는 방법을 한 번에 정리한다.  
> - **프론트엔드 핵심 지표**(Lighthouse, Web Vitals) 모니터링  
> - **유닛/컴포넌트 테스트**(Vitest + Testing Library + MSW)  
> - **E2E 테스트**(Playwright) 시나리오와 픽스처/모킹  
> - **스토리북** + **비주얼 리그레션**(스냅샷/퍼시)  
> - GitHub Actions 기준의 **CI 파이프라인** 예제

---

## 13.0 프로젝트 준비 (의존성 & 스크립트)

```bash
# Vitest + Svelte Testing Library
pnpm add -D vitest @testing-library/svelte @testing-library/user-event \
  jsdom @sveltejs/vite-plugin-svelte @testing-library/jest-dom \
  msw @mswjs/interceptors

# Playwright (Chromium/Firefox/WebKit)
pnpm create playwright@latest  # 또는: pnpm add -D @playwright/test

# Storybook
pnpm dlx storybook@latest init

# Lighthouse CI (선택)
pnpm add -D lighthouse @lhci/cli wait-on

# a11y 자동화(선택)
pnpm add -D axe-core playwright-axe
```

`package.json` 스크립트 초안:

```json
{
  "scripts": {
    "dev": "pnpm vite",
    "build": "pnpm svelte-kit build",
    "preview": "pnpm svelte-kit preview",
    "typecheck": "svelte-kit sync && tsc -p tsconfig.json --noEmit",
    "lint": "eslint . --ext .ts,.svelte",
    "test": "vitest run",
    "test:ui": "vitest --ui",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "story": "storybook dev -p 6006",
    "build-storybook": "storybook build",
    "lh:ci": "lighthouse http://localhost:4173 --preset=desktop --output=json --output-path=.lighthouse/report.json"
  }
}
```

---

## 13.1 Lighthouse & Web Vitals 모니터링

### 13.1.1 로컬/LHCI로 성능 회귀 감시
`.lighthouserc.json`:

```json
{
  "ci": {
    "collect": {
      "url": ["http://localhost:4173/","http://localhost:4173/pricing"],
      "numberOfRuns": 3
    },
    "assert": {
      "assertions": {
        "categories:performance": ["error", {"minScore": 0.92}],
        "first-contentful-paint": ["warn", {"maxNumericValue": 1800}],
        "largest-contentful-paint": ["error", {"maxNumericValue": 2500}],
        "total-blocking-time": ["error", {"maxNumericValue": 250}],
        "cumulative-layout-shift": ["error", {"maxNumericValue": 0.1}]
      }
    }
  }
}
```

GitHub Actions 단계 예시(후술 CI 섹션에서 전체 파이프라인 제공).

### 13.1.2 Web Vitals RUM(실사용 데이터) 수집

클라이언트 수집:

```ts
// src/lib/rum/vitals.client.ts
import { onMount } from 'svelte';

type Metric = { name:string; value:number; id:string; rating:string; navigationType?:string };

async function send(metric: Metric) {
  navigator.sendBeacon?.('/api/vitals', JSON.stringify(metric)) ||
  fetch('/api/vitals', { method: 'POST', body: JSON.stringify(metric), keepalive: true, headers: { 'content-type': 'application/json' } });
}

export function initWebVitals() {
  onMount(async () => {
    const { onLCP, onCLS, onINP, onTTFB } = await import('web-vitals');
    onLCP(send); onCLS(send); onINP(send); onTTFB(send);
  });
}
```

서버 수집 엔드포인트:

```ts
// src/routes/api/vitals/+server.ts
import type { RequestHandler } from './$types';

export const POST: RequestHandler = async ({ request }) => {
  const metric = await request.json();
  // TODO: DB/로그 저장 (예: ClickHouse/BigQuery/Cloud Logging)
  // { name: 'LCP'|'CLS'|'INP'|'TTFB', value, id, rating }
  return new Response('ok');
};
```

레이아웃에서 초기화:

```svelte
<!-- src/routes/+layout.svelte -->
<script lang="ts">
  import { initWebVitals } from '$lib/rum/vitals.client';
  initWebVitals(); // 브라우저에서만 동작
</script>
<slot />
```

> 운영 팁  
> - 페이지/경로/디바이스/네트워크 상태별 분포를 저장해 **회귀 시 원인**(이미지/폰트/JS 증가)을 빠르게 찾는다.  
> - **샘플링**(예: 10%)을 적용해 비용/노이즈를 줄인다.

---

## 13.2 유닛/컴포넌트 테스트 (Vitest)

### 13.2.1 Vitest 환경 설정
`vitest.config.ts`:

```ts
import { defineConfig } from 'vitest/config';
import { sveltekit } from '@sveltejs/kit/vite';

export default defineConfig({
  plugins: [sveltekit()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./tests/setup.ts'],
    include: ['src/**/*.{test,spec}.{ts,js}'],
    coverage: {
      reporter: ['text','html'],
      reportsDirectory: './.coverage',
      exclude: ['**/*.svelte.d.ts','src/routes/**']
    }
  }
});
```

`tests/setup.ts`:

```ts
import '@testing-library/jest-dom';
import { afterAll, afterEach, beforeAll } from 'vitest';
import { server } from './test-server'; // MSW server

beforeAll(() => server.listen({ onUnhandledRequest: 'error' }));
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

### 13.2.2 MSW로 네트워크 모킹
`tests/test-server.ts`:

```ts
import { setupServer } from 'msw/node';
import { http, HttpResponse } from 'msw';

export const server = setupServer(
  http.get('http://localhost/api/products', () =>
    HttpResponse.json([{ id: 'a', name: 'Alpha' }])
  )
);
```

> 팁: SvelteKit의 `fetch` 래퍼를 테스트에서 쓰려면 **절대경로/동일 URL**을 유지하거나, API 모듈을 **의존성 주입** 방식으로 설계해 주입 가능하도록 만든다.

### 13.2.3 스토어/유틸 유닛 테스트

```ts
// src/lib/stores/counter.ts
import { writable } from 'svelte/store';
export function createCounter(initial = 0) {
  const { subscribe, set, update } = writable(initial);
  return {
    subscribe,
    inc: () => update(n => n + 1),
    dec: () => update(n => n - 1),
    reset: () => set(initial)
  };
}
```

```ts
// src/lib/stores/counter.test.ts
import { describe, it, expect } from 'vitest';
import { get } from 'svelte/store';
import { createCounter } from './counter';

describe('createCounter', () => {
  it('increments/decrements/reset', () => {
    const c = createCounter(10);
    c.inc(); c.inc();
    expect(get(c)).toBe(12);
    c.dec();
    expect(get(c)).toBe(11);
    c.reset();
    expect(get(c)).toBe(10);
  });
});
```

### 13.2.4 컴포넌트 테스트(Testing Library)

```svelte
<!-- src/lib/components/AddItem.svelte -->
<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  const dispatch = createEventDispatcher<{ add: { title:string } }>();
  let title = '';
  function add() {
    if (title.trim()) {
      dispatch('add', { title: title.trim() });
      title = '';
    }
  }
</script>

<label for="title">Title</label>
<input id="title" bind:value={title} placeholder="Enter title"/>
<button on:click={add} aria-label="add">Add</button>
```

```ts
// src/lib/components/AddItem.test.ts
import { render, screen, fireEvent } from '@testing-library/svelte';
import { describe, it, expect, vi } from 'vitest';
import AddItem from './AddItem.svelte';

describe('AddItem', () => {
  it('dispatches add with trimmed title and clears input', async () => {
    const { component } = render(AddItem);
    const handler = vi.fn();
    component.$on('add', handler);

    const input = screen.getByPlaceholderText('Enter title') as HTMLInputElement;
    await fireEvent.input(input, { target: { value: '  Hello  ' } });
    await fireEvent.click(screen.getByRole('button', { name: 'add' }));

    expect(handler).toHaveBeenCalledWith(expect.objectContaining({ detail: { title: 'Hello' } }));
    expect(input.value).toBe('');
  });
});
```

### 13.2.5 페이지 로직 테스트(+load 모킹)

```ts
// src/routes/products/+page.ts
import type { PageLoad } from './$types';
export const load: PageLoad = async ({ fetch }) => {
  const items = await fetch('/api/products').then(r => r.json());
  return { items };
};
```

```ts
// src/routes/products/page.load.test.ts
import { describe, it, expect, vi } from 'vitest';
import { load } from './+page';

describe('+page load', () => {
  it('fetches products', async () => {
    const fakeFetch = vi.fn().mockResolvedValue({ json: () => [{ id:'a' }] });
    const data = await load({ fetch: fakeFetch } as any);
    expect(data.items).toEqual([{ id:'a' }]);
    expect(fakeFetch).toHaveBeenCalledWith('/api/products');
  });
});
```

> 단위/컴포넌트 테스트의 지향점: **빠름**(초당 수백~수천), **결정적**(플레이크 없음), **실행 컨텍스트 최소화**.

---

## 13.3 E2E 테스트 (Playwright)

### 13.3.1 설정
`playwright.config.ts`:

```ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  timeout: 30_000,
  retries: 1,
  reporter: [['list'], ['html', { outputFolder: 'e2e-report' }]],
  use: {
    baseURL: 'http://localhost:4173',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },
  projects: [
    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
    { name: 'webkit', use: { ...devices['Desktop Safari'] } }
  ],
  webServer: {
    command: 'pnpm build && pnpm preview',
    port: 4173,
    reuseExistingServer: true
  }
});
```

### 13.3.2 기본 시나리오
`e2e/smoke.spec.ts`:

```ts
import { test, expect } from '@playwright/test';

test('home loads and navigates to blog', async ({ page }) => {
  await page.goto('/');
  await expect(page.getByRole('link', { name: 'Blog' })).toBeVisible();
  await page.getByRole('link', { name: 'Blog' }).click();
  await expect(page).toHaveURL(/\/blog/);
  await expect(page.getByRole('heading', { level: 1 })).toContainText(/Blog/i);
});
```

### 13.3.3 로그인/세션 픽스처(쿠키 주입)

```ts
// e2e/fixtures.ts
import { test as base } from '@playwright/test';

type MyFixtures = { loginAsDemo: () => Promise<void> };

export const test = base.extend<MyFixtures>({
  loginAsDemo: async ({ page }, use) => {
    await page.context().addCookies([{
      name: 'sid',
      value: 'demo.session.sig', // 테스트 세션 토큰(스텁)
      path: '/',
      domain: 'localhost'
    }]);
    await use();
  }
});

export { expect } from '@playwright/test';
```

사용:

```ts
// e2e/app.spec.ts
import { test, expect } from './fixtures';

test('dashboard shows user when logged in', async ({ page, loginAsDemo }) => {
  await loginAsDemo();
  await page.goto('/app');
  await expect(page.getByText(/Welcome/i)).toBeVisible();
});
```

> 실제 앱에서는 **로그인 UI를 통해 세션 생성**하거나, 테스트용 **백도어 엔드포인트**(테스트 환경 전용)로 세션을 주입한다.

### 13.3.4 폼/업로드/액션 흐름

```ts
// e2e/upload.spec.ts
import { test, expect } from '@playwright/test';
import path from 'path';

test('image upload flow', async ({ page }) => {
  await page.goto('/upload/images');
  const file = path.resolve(__dirname, './fixtures/cat.jpg');
  await page.setInputFiles('input[type="file"]', file);
  await page.getByRole('button', { name: '업로드' }).click();
  await expect(page.getByText(/저장됨/)).toBeVisible();
  // 썸네일 표출 검증
  await expect(page.locator('img[alt="webp"]')).toBeVisible();
});
```

### 13.3.5 a11y 자동 점검(선택)

```ts
// e2e/a11y.spec.ts
import { test, expect } from '@playwright/test';
import AxeBuilder from '@axe-core/playwright';

test('home has no a11y violations', async ({ page }) => {
  await page.goto('/');
  const results = await new AxeBuilder({ page }).analyze();
  expect(results.violations).toEqual([]);
});
```

> a11y 이슈는 코드리뷰/디자인 시스템 레벨에서 고정적으로 관리하자(ARIA misuse, 대비, 폼 라벨 등).

### 13.3.6 비주얼 리그레션(스냅샷)

```ts
// e2e/visual.spec.ts
import { test, expect } from '@playwright/test';

test('hero looks correct', async ({ page }) => {
  await page.goto('/');
  const hero = page.locator('main');
  await expect(hero).toHaveScreenshot('home-hero.png', { maxDiffPixels: 200 });
});
```

> 협업 시에는 브라우저/OS 차이를 고려해 **퍼시 서비스(Chromatic/Percy)**가 유지보수를 덜어준다.

---

## 13.4 스토리북 & 비주얼 리그레션(선택)

### 13.4.1 스토리 파일

```svelte
<!-- src/lib/components/Button.svelte -->
<script lang="ts">
  export let variant: 'primary'|'secondary' = 'primary';
</script>
<button class={`btn ${variant}` }><slot /></button>

<style>
  .btn{padding:.5rem 1rem;border-radius:10px;border:1px solid #e5e7eb}
  .primary{background:#0ea5e9;color:#fff}
  .secondary{background:#fff;color:#0ea5e9}
</style>
```

```ts
// src/lib/components/Button.stories.ts
import type { Meta, StoryObj } from '@storybook/svelte';
import Button from './Button.svelte';

const meta: Meta<Button> = {
  title: 'Atoms/Button',
  component: Button,
  args: { variant: 'primary', $$slots: { default: 'Click me' } as any }
};
export default meta;

export const Primary: StoryObj = {};
export const Secondary: StoryObj = { args: { variant: 'secondary' } };
```

### 13.4.2 스토리 레벨 테스트(Playwright Storybook Test or Chromatic)
- **Chromatic**: PR마다 스토리 스냅샷 → 시각 차이 리뷰/승인  
- **@storybook/test-runner**: 스토리를 테스트로 실행하여 접근성/상호작용 검사

```bash
pnpm add -D @storybook/test-runner
```

`package.json`:

```json
{ "scripts": { "test:stories": "test-storybook" } }
```

---

## 13.5 CI 기본 파이프라인 (GitHub Actions 예)

`.github/workflows/ci.yml`:

```yaml
name: ci
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v3
        with: { version: 9 }
      - uses: actions/setup-node@v4
        with: { node-version: '20', cache: 'pnpm' }

      - run: pnpm install --frozen-lockfile

      # 품질 게이트 1: 정적 분석
      - run: pnpm typecheck
      - run: pnpm lint

      # 단위/컴포넌트 테스트 + 커버리지
      - run: pnpm test -- --coverage

      # 앱 빌드 + 프리뷰 서버
      - run: pnpm build
      - run: pnpm preview & npx wait-on http://localhost:4173

      # E2E (헤드리스)
      - run: pnpm test:e2e

      # Lighthouse CI (선택)
      - run: pnpm lh:ci
      - uses: actions/upload-artifact@v4
        with:
          name: lh-report
          path: ./.lighthouse/report.json

  # 선택: 스토리북 빌드 + 비주얼 리그레션 서비스 업로드
  storybook:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v3
        with: { version: 9 }
      - uses: actions/setup-node@v4
        with: { node-version: '20', cache: 'pnpm' }
      - run: pnpm install --frozen-lockfile
      - run: pnpm build-storybook
      # 예: Chromatic
      # - run: npx chromatic --project-token=${{ secrets.CHROMATIC_PROJECT_TOKEN }}
```

> 운영 팁  
> - PR마다 **Lighthouse/LCP/TBT 회귀**를 조기 발견.  
> - 스크린샷/트레이스 업로드로 실패 재현 용이.  
> - **플레이크** 테스트는 **retry=1~2** + 네트워크/타임아웃 안정화.

---

## 13.6 테스트 데이터/모킹 전략

### 13.6.1 팩토리/빌더 패턴
```ts
// tests/factories.ts
export const userFactory = (over: Partial<any> = {}) => ({
  id: crypto.randomUUID(),
  name: 'Ada Lovelace',
  email: 'ada@example.com',
  ...over
});
```

### 13.6.2 날짜/랜덤 결정화
```ts
import { vi } from 'vitest';
vi.setSystemTime(new Date('2025-01-01T00:00:00Z'));
vi.spyOn(Math, 'random').mockReturnValue(0.42);
```

---

## 13.7 커버리지 & 테스트 전략 수립

- **유닛/유틸**: 로직 분기 100% 목표(간단/빠름)  
- **컴포넌트**: 핵심 상호작용/접근성, 스냅샷은 **남용 금지**  
- **E2E**: **주요 사용자 여정(로그인→행동→결과)** 중심의 **소수** 케이스  
- **계약 테스트**: API 스키마/타입 가드(Zod)로 I/O를 고정  
- **퍼포먼스 가드**: Lighthouse CI/Bundle size guard(rollup-plugin-visualizer 등)

---

## 13.8 예시: “할 일 앱” 품질 스택 종합

### 13.8.1 단위: 리스트 리듀서
```ts
// src/lib/todos/reducer.ts
export type Todo = { id:string; title:string; done:boolean };
export function reduce(state: Todo[], action: { type:'add'|'toggle'|'remove'; payload:any }) {
  switch (action.type) {
    case 'add': return [{ id: crypto.randomUUID(), title: action.payload, done:false }, ...state];
    case 'toggle': return state.map(t => t.id === action.payload ? { ...t, done: !t.done } : t);
    case 'remove': return state.filter(t => t.id !== action.payload);
  }
  return state;
}
```

```ts
// src/lib/todos/reducer.test.ts
import { describe, it, expect, vi } from 'vitest';
import { reduce } from './reducer';
vi.spyOn(crypto, 'randomUUID').mockReturnValue('X');

it('adds/toggles/removes', () => {
  let s = reduce([], { type:'add', payload:'Read' });
  expect(s[0]).toMatchObject({ id:'X', title:'Read', done:false });
  s = reduce(s, { type:'toggle', payload:'X' });
  expect(s[0].done).toBe(true);
  s = reduce(s, { type:'remove', payload:'X' });
  expect(s).toHaveLength(0);
});
```

### 13.8.2 컴포넌트: submit → dispatch
```svelte
<!-- src/lib/todos/AddTodo.svelte -->
<script>
  import { createEventDispatcher } from 'svelte';
  const dispatch = createEventDispatcher();
  let title = '';
  function submit(e){ e.preventDefault(); if(title.trim()){ dispatch('add', { title: title.trim() }); title=''; } }
</script>
<form on:submit|preventDefault={submit}>
  <input aria-label="title" bind:value={title} />
  <button>Add</button>
</form>
```

```ts
// src/lib/todos/AddTodo.test.ts
import { render, screen, fireEvent } from '@testing-library/svelte';
import { expect, it, vi } from 'vitest';
import AddTodo from './AddTodo.svelte';

it('adds with trimmed value', async () => {
  const { component } = render(AddTodo);
  const spy = vi.fn(); component.$on('add', spy);
  await fireEvent.input(screen.getByLabelText('title'), { target:{ value:'  Hello ' } });
  await fireEvent.click(screen.getByText('Add'));
  expect(spy).toHaveBeenCalledWith(expect.objectContaining({ detail:{ title:'Hello' }}));
});
```

### 13.8.3 E2E: 전체 플로우
```ts
// e2e/todos.spec.ts
import { test, expect } from '@playwright/test';

test('todo flow', async ({ page }) => {
  await page.goto('/todos');
  await page.getByLabel('title').fill('Read SvelteKit');
  await page.getByRole('button', { name: 'Add' }).click();
  await expect(page.getByText('Read SvelteKit')).toBeVisible();

  // toggle
  await page.getByRole('button', { name: '✓' }).first().click();
  await expect(page.getByText('Read SvelteKit')).toHaveClass(/done/);

  // remove
  await page.getByRole('button', { name: '삭제' }).first().click();
  await expect(page.getByText('Read SvelteKit')).toHaveCount(0);
});
```

---

## 13.9 운영 체크리스트 (요약)

### 품질 게이트
- [ ] **타입체크/린트**: PR 필수  
- [ ] **유닛/컴포넌트 테스트**: 빠르고 결정적, 커버리지 목표 설정  
- [ ] **E2E 스모크**: 핵심 여정 몇 개 + 트레이스/스크린샷 저장  
- [ ] **Lighthouse CI**: 성능/접근성 회귀 방지(임계값 설정)  
- [ ] **Web Vitals RUM**: LCP/INP/CLS 실측 수집 & 대시보드  
- [ ] **스토리북**: UI 카탈로그 + 디자인 리뷰 + 비주얼 리그레션(선택)

### 테스트 작성 원칙
- [ ] 하나의 테스트는 **하나의 행위/검증**에 집중  
- [ ] 셋업 단순화(픽스처/팩토리/모킹)  
- [ ] 비결정 요소(날짜/랜덤/네트워크)는 **고정**  
- [ ] 실패 시 **원인 가시성**(로그/스크린샷/트레이스)을 높인다

---

## 13.10 마무리

- **테스트 피라미드**(유닛/컴포넌트 다수, E2E 소수)를 유지하되, **사용자 여정**은 꼭 E2E로 검증하자.  
- **Lighthouse**와 **Web Vitals RUM**을 파이프라인에 넣어 **성능 회귀**를 끊임없이 감시하자.  
- **스토리북**으로 UI를 문서화하고, 필요하면 **비주얼 리그레션**으로 픽셀 회귀를 방지하자.  
- 모든 단계는 **CI**로 자동화하여 “로컬 OK = PR OK = 배포 OK”를 지키는 것이 궁극의 생산성이다.