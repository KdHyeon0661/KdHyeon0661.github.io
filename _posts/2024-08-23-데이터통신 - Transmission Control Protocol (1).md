---
layout: post
title: 데이터 통신 - Transmission Control Protocol (1)
date: 2024-08-23 22:20:23 +0900
category: DataCommunication
---
# Chapter 24. Transport Layer Protocols — UDP와 포트 번호 완전 정리

## Introduction

### Transport Layer Services

전송 계층의 핵심 역할은 **호스트 간이 아니라 프로세스(애플리케이션) 간 통신**을 제공하는 것이다.
네트워크 계층(IP)은 “이 호스트(주소)로 패킷을 보내라” 수준이지만, 전송 계층은 그 위에서 다음과 같은 서비스를 제공한다.

#### (1) 프로세스-대-프로세스 전달 (Process-to-Process Delivery)

- IP는 **“어느 호스트까지”** 만 책임진다.
- 전송 계층(TCP/UDP)은 **“그 호스트의 어느 프로세스(애플리케이션)까지”** 전달할지를 결정한다.
- 이를 위해 **포트 번호(port number)** 를 사용한다.
  - 예: `203.0.113.10:443` → IP 주소 + 포트 번호(웹 서버, HTTPS)
  - 예: `203.0.113.10:53` → DNS 서버

프로세스-대-프로세스 전달은 다음 두 기능이 핵심이다.

1. **멀티플렉싱(Multiplexing)**
   여러 애플리케이션이 동시에 네트워크를 사용해도, 전송 계층이 **여러 프로세스의 데이터 스트림을 하나의 IP 연결 위로 합쳐서 보내는 기능**.

2. **디멀티플렉싱(Demultiplexing)**
   수신 측에서는 IP로부터 올라온 패킷을 **포트 번호**를 기준으로 다시 각 애플리케이션(소켓)에 분배하는 기능.

#### (2) 신뢰성 (Reliability)과 순서 보장 (Ordering)

전송 계층 프로토콜은 크게 두 가지 방식으로 나뉜다.

- **신뢰적인 연결형 프로토콜 (예: TCP)**
  - 데이터 손실 시 재전송
  - 순서 보장
  - 흐름 제어, 혼잡 제어
  - 예: 웹, 이메일, 파일 전송 등

- **비신뢰적 연결less 프로토콜 (예: UDP)**
  - 재전송/순서 보장 없음
  - 최소한의 헤더와 빠른 전송
  - 애플리케이션이 필요하면 상위에서 직접 신뢰성 구현
  - 예: 실시간 음성/영상, 게임, DNS 질의, NTP 등

수학적으로, 신뢰성을 위해 재전송을 하면 **평균 지연**은 조금 증가하지만 **손실 확률**은 감소한다.
단순화해서 말하면 패킷 손실 확률을 \(p\)라고 할 때, **단순 재전송 전략**의 성공 확률은

$$
P(\text{성공}) = 1 - p^n
$$

처럼 여러 번 시도할수록 높아지지만, 그만큼 지연과 네트워크 부하는 증가한다.

#### (3) 흐름 제어 (Flow Control)와 혼잡 제어 (Congestion Control)

- **흐름 제어**: 송신자가 너무 빨리 보내면 수신자의 버퍼가 넘칠 수 있으므로, 수신자 능력에 맞게 속도를 조절.
- **혼잡 제어**: 네트워크 전체가 붐비는 상황에서, 송신자가 자신의 전송률을 조절해 혼잡 붕괴를 막는 기능.

> TCP는 이 두 가지를 모두 제공하지만, **UDP는 기본적으로 제공하지 않는다.**
> 대신 애플리케이션이 필요하면 자체적으로 구현한다.

#### (4) 메시지 경계 보존 vs 바이트 스트림

- TCP: **바이트 스트림(byte stream)** – “연속된 바이트의 흐름”
- UDP: **메시지 단위(datagram)** 를 보존 – `send()`에 넣은 것 한 덩어리가 그대로 하나의 UDP 데이터그램으로 간다.

실제 예를 들어 보자.

##### 예제: 채팅 vs 실시간 게임

- 텍스트 채팅:
  - 한 글자씩 늦게 도착해도 상관 없음, 대신 절대 빠지면 안 됨.
  - TCP가 적합 (신뢰성 > 지연)

- 실시간 FPS 게임 위치 정보:
  - 0.1초 전에 보낸 위치 패킷이 지금 와도 이미 의미 없음.
  - 약간의 패킷 손실은 허용되지만 **지연은 매우 민감**.
  - UDP + 상위에서 간단한 보정(보간, 예측) 사용이 적합.

---

### Port Numbers

#### (1) 포트 번호의 기본 개념

- 전송 계층의 포트 번호는 **16비트 정수**로, 범위는 **0 ~ 65535**.
- IANA가 공식적으로 포트 번호를 관리하며, 세 가지 범위로 나뉜다.

| 범위               | 이름                      | 용도 요약                                                                 |
|--------------------|---------------------------|---------------------------------------------------------------------------|
| 0–1023             | Well-known / System Ports | HTTP(80), HTTPS(443), DNS(53), NTP(123) 등 널리 알려진 서버 서비스       |
| 1024–49151         | Registered / User Ports   | 특정 애플리케이션이 등록해서 사용하는 포트 (예: 3306 MySQL, 8080 웹 등) |
| 49152–65535        | Dynamic / Private Ports   | 주로 클라이언트의 **ephemeral(임시) 포트** 로 사용                       |

실제로 운영체제는 위 범위 중 일부를 클라이언트의 **동적 포트**로 사용한다.

#### (2) 소켓과 (IP, Port) 튜플

전송 계층에서 **소켓(socket)** 은 보통 다음과 같이 식별된다.

- 단일 연결:
  $$ (\text{Source IP}, \text{Source Port}, \text{Dest IP}, \text{Dest Port}) $$

특히 서버는 “도착 포트 번호”만 보고도 어느 애플리케이션으로 보내야 할지 알 수 있다.

##### 예제: HTTPS 웹 페이지 요청

1. 클라이언트:
   - IP: `198.51.100.5`
   - OS가 임의의 포트 할당: `55000` (동적 포트)
2. 서버:
   - IP: `203.0.113.10`
   - 포트: `443` (HTTPS well-known port)

연결을 표현하면:

- 송신 4-튜플: `198.51.100.5:55000 → 203.0.113.10:443`

서버는 `443` 포트에서 대기하고 있다가, 패킷이 들어오면 소켓 테이블에서

- `(Local IP, Local Port, Remote IP, Remote Port)` 조합으로 어떤 연결인지 찾는다.

#### (3) 포트 번호 예시 표

아래는 대표적인 TCP/UDP 포트의 일부 예시이다. (IANA 등록 기준)

| 프로토콜 | 포트 | 전송 계층 | 용도 예시            |
|----------|------|-----------|----------------------|
| DNS      | 53   | UDP/TCP   | 도메인 이름 질의     |
| HTTP     | 80   | TCP       | 웹 서비스            |
| HTTPS    | 443  | TCP       | 보안 웹 서비스       |
| NTP      | 123  | UDP       | 시간 동기화          |
| DHCP     | 67/68| UDP       | IP 자동 할당         |
| SNMP     | 161  | UDP       | 네트워크 관리        |
| QUIC/HTTP3 | 443| UDP(내부) | HTTP/3 트래픽 (실제 전송은 UDP 기반 QUIC) |

#### (4) 포트 번호와 보안

- **Well-known 포트**는 방화벽, IDS/IPS 등의 룰에서 많이 활용된다.
- 동적 포트 범위는 랜덤 할당이 일반적이라, **포트 랜덤화**가 보안성(스캔/공격 난이도 상승)에 도움을 준다.
- UDP 기반의 새로운 프로토콜(예: QUIC/HTTP/3)은 **UDP 기반 DDoS 공격** 리스크 때문에 별도의 보호 메커니즘이 필요하다.

---

## User Datagram Protocol (UDP)

### User Datagram

UDP는 RFC 768에서 정의된 전송 계층 프로토콜로, **연결 설정 없이** 간단한 헤더만 붙여서 데이터그램을 전송한다.

#### (1) UDP 헤더 구조

UDP 헤더는 **고정 8바이트(64비트)** 로 매우 단순하다.

| 필드              | 길이 (비트) | 설명                                        |
|-------------------|-------------|---------------------------------------------|
| Source Port       | 16          | 송신자 포트 번호                            |
| Destination Port  | 16          | 수신자 포트 번호                            |
| Length            | 16          | 헤더 + 데이터 전체 길이(바이트 단위)       |
| Checksum          | 16          | 오류 검출용 1의 보수 합(IPv4에서 옵션)     |

간단히 그림으로 표현하면:

```text
 0      7 8     15 16    23 24    31 (비트 인덱스)
+--------+--------+--------+--------+
|   Source Port   | Destination Port|
+--------+--------+--------+--------+
|     Length      |    Checksum     |
+--------+--------+--------+--------+
|
|        데이터 (Payload) ...
+------------------------------------>
```

- **Length** 필드는 최소 8(헤더만) 이상.
- Checksum은 IPv4에서는 **0이면 사용 안 함**을 의미하지만, IPv6에서는 필수다.

UDP Checksum 계산에는 IP pseudo-header가 포함된다 (출발지/목적지 IP, 프로토콜 번호 등). 이는 IP 계층에서 잘못된 목적지로 가는 것을 감지하는 데 도움을 준다.

#### (2) 데이터그램의 개념

- 하나의 UDP 데이터그램 = **헤더(8B) + 애플리케이션 데이터**.
- IP 계층 입장에서는 “하나의 데이터 덩어리”이고, 각각 독립적으로 라우팅된다.
- IP에서 단편화(fragmentation)가 발생할 수 있지만, UDP는 그 사실을 알 필요가 없다. IP가 다시 재조립한 후 UDP로 넘긴다.

##### 예제: DNS 질의 데이터그램

- 애플리케이션: DNS 클라이언트
- 데이터: “`www.example.com` 의 A 레코드 요청” (수십 바이트)
- UDP:
  - Source Port: 53000 (동적)
  - Destination Port: 53 (DNS 서버)
  - Length: 8(헤더) + N(질의 메시지)
- IP: UDP 데이터그램을 담아 목적지 DNS 서버로 보냄.

이 구조 때문에 **소량의 요청/응답**에 매우 효율적이다.

#### (3) 오버헤드와 효율성

IPv4 + UDP 조합에서 한 데이터그램의 헤더 오버헤드는:

- IPv4 헤더: 최소 20바이트
- UDP 헤더: 8바이트
→ 합계 28바이트

Payload가 \(P\) 바이트일 때,

$$
\text{효율(%)}
= \frac{P}{P + 28} \times 100
$$

예를 들어, MTU 1500바이트인 이더넷에서 Payload를 1472바이트(1500-20-8) 사용하면

$$
\text{효율} \approx \frac{1472}{1500} \approx 98.13\%
$$

즉, 패킷당 헤더 오버헤드가 매우 적다.

---

### UDP Services

UDP가 제공하는 서비스는 “최소한의 전송 기능”에 가깝다.

#### (1) UDP가 제공하는 것

1. **프로세스-대-프로세스 전달**
   - 포트 번호를 사용한 멀티플렉싱/디멀티플렉싱 기능.

2. **메시지 경계 보존**
   - send한 단위가 그대로 하나의 데이터그램으로 전달됨.
   - TCP처럼 스트림이 아니라, **메시지 단위** 전송.

3. **간단한 오류 검출(Checksum)**
   - 데이터가 전송 중 손상되었는지 감지.
   - IPv6에서는 필수, IPv4에서는 선택이지만 요즘 구현은 대부분 사용.

4. **낮은 지연과 작은 헤더 오버헤드**
   - 8바이트 고정 헤더.
   - 연결 설정/해제 과정(3-way handshake 등) 없음.
   - 재전송, 혼잡 제어를 안 하기 때문에 처리 비용이 적고 지연이 낮다.

#### (2) UDP가 제공하지 않는 것

1. **신뢰성 보장 없음**
   - 손실, 중복, 순서 바뀜에 대한 재전송이나 교정이 없다.
   - “Best-effort” 네트워크 상에서 그대로 동작.

2. **흐름 제어 없음**
   - 수신자의 처리 속도, 버퍼를 고려한 조절 기능이 없다.
   - 송신자가 마음대로 빨리 보내면 수신 측 버퍼가 넘칠 수 있음.

3. **혼잡 제어 없음**
   - 네트워크 혼잡을 감지하고 전송률을 줄이는 메커니즘이 없다.
   - 대규모 UDP 트래픽은 적절한 애플리케이션 레벨 제어(또는 QoS 정책)가 필요하다.

4. **순서 보장 없음**
   - 수신된 데이터그램의 순서를 보장하지 않는다.
   - 애플리케이션에서 시퀀스 번호를 넣고 정렬해야 한다.

결론적으로, UDP는 **“빠르고 단순하지만, 신뢰성을 직접 챙겨야 하는 프로토콜”** 이다.

#### (3) UDP vs TCP — 헤더 비교

| 항목            | UDP                      | TCP                                      |
|-----------------|--------------------------|------------------------------------------|
| 헤더 길이       | 8바이트 고정             | 20~60바이트 (옵션에 따라 가변)          |
| 연결            | 없음 (connectionless)    | 있음 (3-way handshake)                  |
| 신뢰성          | 없음                     | 재전송, ACK, 순서 보장                  |
| 혼잡/흐름 제어  | 없음                     | 있음 (슬라이딩 윈도우, Congestion Cntl) |
| 애플리케이션 예 | VoIP, 게임, DNS, NTP     | HTTP, SMTP, FTP, DB 접속 등             |

---

### UDP Applications

#### (1) 실시간 애플리케이션

오늘날 UDP는 **실시간(Real-time)** 애플리케이션에서 매우 널리 쓰인다.

1. **VoIP(Voice over IP), 영상 회의**
   - RTP(Real-time Transport Protocol)가 UDP 위에서 동작.
   - 약간의 패킷 손실은 허용하되, 지연(jitter, latency)을 최소화.
   - 재전송으로 인해 음성이 끊기느니, 약간의 잡음/프레임 손실이 낫다.

2. **온라인 게임**
   - 위치/상태 업데이트를 초당 수십 번 전송.
   - 1~2개 패킷 손실을 재전송으로 다시 받는 것보다,
     다음 최신 상태를 받는 것이 더 중요.
   - UDP를 사용한 뒤, 게임 엔진이 **예측/보간(interpolation)** 으로 매끄럽게 보정.

3. **WebRTC 기반 실시간 통신**
   - 브라우저 간 P2P 음성/영상/데이터 전송.
   - 기본적으로 UDP를 사용해 지연을 최소화하고, 상위 프로토콜에서 FEC, 재전송, 적응형 비트레이트 등을 구현.

4. **HTTP/3 + QUIC**
   - 최신 웹 프로토콜 HTTP/3는 QUIC 위에서 동작하고, QUIC은 UDP 기반이다.
   - 손실 패킷으로 인한 HTTP/2의 Head-of-line blocking 문제를 해결하고,
     빠른 연결 수립과 멀티플렉싱을 제공한다.

#### (2) 비실시간/유틸리티 애플리케이션

UDP는 실시간만 쓰는 것이 아니라, **간단한 질의/응답**에도 적합하다.

1. **DNS**
   - 대부분의 DNS 쿼리는 매우 짧고, 한 두 번 재요청해도 큰 문제 없음.
   - UDP 53포트를 사용해서 빠르게 요청/응답.
   - 대용량 응답 또는 특정 상황에서는 TCP로 폴백.

2. **DHCP**
   - 클라이언트가 네트워크에 처음 붙을 때, IP 주소를 모르기 때문에
     브로드캐스트 기반 UDP를 사용해 IP를 할당받는다.

3. **NTP(Network Time Protocol)**
   - 매우 작은 패킷으로 시간 정보를 주고받으며, 주기적으로 갱신.
   - UDP 123 포트 사용.

4. **SNMP(Simple Network Management Protocol)**
   - 네트워크 장비 상태 모니터링/관리용.
   - 간단한 요청-응답 구조에 적합해서 UDP 사용.

#### (3) 예제: UDP 에코 서버/클라이언트

간단한 실습 예제로, UDP 에코 서버를 만들어 보자.

##### UDP 에코 서버 (Python 예제)

```python
import socket

SERVER_ADDR = ("0.0.0.0", 9999)

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind(SERVER_ADDR)

print("UDP echo server listening on port", SERVER_ADDR[1])

while True:
    data, client_addr = sock.recvfrom(2048)
    print("Received from", client_addr, ":", data.decode(errors="ignore"))
    # 그대로 다시 돌려보냄 (echo)
    sock.sendto(data, client_addr)
```

##### UDP 에코 클라이언트 (Python 예제)

```python
import socket

SERVER_ADDR = ("127.0.0.1", 9999)

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

while True:
    msg = input("Message (empty to quit): ")
    if not msg:
        break
    sock.sendto(msg.encode(), SERVER_ADDR)
    data, _ = sock.recvfrom(2048)
    print("Echo:", data.decode(errors="ignore"))
```

이 예제에서 볼 수 있는 특징:

- 서버는 `bind(0.0.0.0:9999)`로 포트 9999에 고정.
- 클라이언트는 OS가 정해주는 임시 포트(동적 포트)를 사용.
- 연결 설정 과정 없이, 바로 `sendto()` / `recvfrom()` 만으로 통신.
- 패킷 손실/순서 문제는 전혀 처리하지 않는다 (단순 예제).

---

## 정리

- 전송 계층은 **프로세스-대-프로세스** 전달, 멀티플렉싱/디멀티플렉싱, (필요시) 신뢰성과 흐름·혼잡 제어를 담당한다.
- 포트 번호는 16비트이며, IANA에 의해 **well-known / registered / dynamic** 범위로 관리된다.
- UDP는 **연결less, 비신뢰적, 메시지 단위, 고정 8바이트 헤더** 라는 특성을 가진다.
- 실시간 통신(VoIP, 게임, WebRTC, HTTP/3/QUIC 등)과 간단한 질의/응답(DNS, DHCP, NTP, SNMP)에 널리 사용된다.
- 신뢰성과 순서는 애플리케이션 레벨에서 직접 구현하거나, RTP, QUIC 등 상위 프로토콜이 책임진다.

다음 장에서 다룰 TCP와 비교하면, UDP는 **“속도와 단순성”을 택한 전송 계층 프로토콜**이라는 점을 기억해 두면 된다.
