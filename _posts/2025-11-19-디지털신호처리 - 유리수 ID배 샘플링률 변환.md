---
layout: post
title: 디지털신호처리 - 유리수 I/D배 샘플링률 변환
date: 2025-11-19 18:25:23 +0900
category: 디지털신호처리
---
# 유리수 I/D배 샘플링률 변환(Rational Sampling Rate Conversion)

## 왜 유리수 샘플링률 변환이 필요한가?

정수배 변환만으로는 현실 시스템의 샘플링률을 맞출 수 없는 경우가 많다.

대표적 실무 예:

1. **오디오 표준 간 변환**
   - 44.1 kHz(CD/음악) ↔ 48 kHz(방송/영상/DAW)
   - 비율
     $$
     \frac{48}{44.1}=\frac{48000}{44100}=\frac{160}{147}
     $$
     즉 **I=160, D=147**의 유리수 변환이 필요하다.

2. **통신/SDR**
   - ADC가 제공하는 고정 샘플링률(예: 61.44 MHz)을
     심볼률/대역폭에 맞는 임의의 비율로 변환해야 함.
   - 샘플링률이 “정수배”로 딱 떨어지는 경우는 오히려 드물다.

3. **센서·계측**
   - 장비 A는 1000 Hz, 장비 B는 1200 Hz로 로깅
   - 데이터 융합을 하려면 1.2배(=6/5) 같은 유리수 비율 변환이 필수

즉, 현실은
**“임의의 비율 = 유리수(I/D)로 근사해서 변환한다”**
가 표준 해법이다.

---

## 기본 개념 복습: 정수배 보간과 데시메이션의 결합

앞 글의 핵심:

- **보간(↑I)**: 0 삽입 → imaging 제거 LPF
- **데시메이션(↓D)**: aliasing 방지 LPF → D개 중 1개 취함

유리수 변환은 이 둘을 “한 시스템”으로 이어 붙인 것이다.

표준 구조:

```text
x[n] ──▶ (↑I) ──▶ [LPF H(z)] ──▶ (↓D) ──▶ y[n]
```

샘플링률:

$$
F_s' = \frac{I}{D}F_s
$$

즉, **I배 올리고 D배 내리면 최종적으로 I/D배가 된다.**

---

## 유리수 변환에서 가장 중요한 2가지 문제

### 문제 1: imaging과 aliasing이 “동시에” 발생

- (↑I) 직후 imaging(스펙트럼 복제) 발생
- 그 다음 (↓D)에서 aliasing 위험

따라서 필터는

1) 보간으로 생긴 **이미지 제거(anti-imaging)**
2) 데시메이션에서 생길 **접힘 방지(anti-aliasing)**

를 **동시에 만족**해야 한다.

---

### 문제 2: 계산량 폭증

직접 구현하면:

- 입력을 I배 늘려서 길이가 I배
- 그걸로 LPF 필터링(탭 M이면 M×I 연산)
- 그 중 1/D만 남기는데 필터 계산은 전부 함

즉, 정직하게 하면 큰 낭비다.

해결책:

- **폴리페이즈(polyphase)**
- **노블 아이덴티티(noble identities)**
- **다단(multistage)**
- **Farrow/시간가변 FIR(선택적)**

로 연산량을 크게 줄인다.

---

## 수식으로 보는 유리수 I/D 변환

### 업샘플링(0 삽입)

$$
v[n] =
\begin{cases}
x[n/I], & n = mI \\
0, & \text{else}
\end{cases}
$$

DTFT 관계:

$$
V(e^{j\omega}) = X(e^{j\omega I})
$$

→ 스펙트럼이 I배로 **확장 + 복제(imaging)**.

---

### LPF 통과

$$
u[n] = (h * v)[n]
$$

$$
U(e^{j\omega}) = H(e^{j\omega})V(e^{j\omega})
$$

---

### 다운샘플링

$$
y[n] = u[nD]
$$

DTFT:

$$
Y(e^{j\omega})
= \frac{1}{D}\sum_{k=0}^{D-1}
U\!\left(e^{j(\omega+2\pi k)/D}\right)
$$

즉, 필터가 aliasing을 막을 만큼 충분히 저역만 통과시키지 못하면,
복제/고역이 내려오면서 접힘이 생긴다.

---

## “하나의 LPF”가 만족해야 하는 통과대역 조건

두 조건을 동시에 만족해야 한다.

1. anti-imaging (보간 후 이미지 제거)
   - 보간 후 신호의 baseband는 $$|\omega|\le \pi/I$$

2. anti-aliasing (데시메이션에서 접힘 방지)
   - 데시메이션의 새로운 나이퀴스트는 $$\pi/D$$
   - 다운샘플 직전 스펙트럼은 $$|\omega|\le \pi/D$$ 안에 있어야 안전

따라서 LPF 컷오프는

$$
\omega_c \le \min\!\left(\frac{\pi}{I}, \frac{\pi}{D}\right)
$$

보통 I와 D가 둘 다 1보다 크므로

- 실제로는 더 작은 쪽이 지배한다.

**정규화 주파수(원래 Fs 기준)로 쓰면**

$$
W_c \le \min\!\left(\frac{1}{I},\frac{1}{D}\right)
$$

실무에서는 필터 전이대역을 고려해서

$$
W_p < W_c < W_s
$$

처럼 여유를 둔다.

---

## 파이프라인 관점: I/D 변환의 직관적 해석

### “격자 다시 그리기” 관점

유리수 변환은
**새 샘플 격자에 원 신호를 재배치하는 과정**이다.

- (↑I): 격자를 촘촘히 만들고(새로운 가상 격자)
- LPF: 그 격자에서 연속적인 파형을 “부드럽게” 복원하는 느낌
- (↓D): 그 격자에서 D개당 1개를 다시 취해 최종 격자를 얻음

결국 샘플링률이

$$
\frac{I}{D} \text{배}
$$

로 바뀐 표본이 남는다.

---

### “시간축 위상 이동” 관점

출력의 k번째 샘플은
원래 신호의 시간축에서

$$
t_k = \frac{kD}{I}T
$$

위치에 해당한다.

즉, 출력 샘플은 원본 시간축에서
**정수 위치가 아닌 “분수 위치”**에 대응한다.

그래서 I/D 변환은 본질적으로
**분수 지연(fractional delay)** 문제와 같다.

폴리페이즈/시간가변 FIR이 이 분수 지연을 구현하는 도구다.

---

## 폴리페이즈 기반의 효율적 유리수 변환

### 핵심 아이디어

LPF의 임펄스 응답을 I개의 위상으로 분해:

$$
h[n] = \sum_{m=0}^{I-1} e_m[nI - m]
$$

전송함수:

$$
H(z) = \sum_{m=0}^{I-1} z^{-m} E_m(z^I)
$$

그러면 구조가:

```text
x[n] ──▶ polyphase bank {E0..E_{I-1}} ──▶ (rate change) ──▶ y[n]
```

이때 0 삽입을 실제로 만들 필요가 없다.

---

### 실행 규칙(개념)

출력 샘플 index n에 대해
원본 샘플을 어떤 위상 필터로 계산할지는

$$
\text{phase}(n) = (nD) \bmod I
$$

처럼 “모듈로 위상 선택”으로 결정된다.

즉, 출력 샘플마다

1. 해당 위상 필터 E_phase를 고르고
2. 그 필터로 원본 x의 일부 구간만 곱·합 → y[n] 생성

이렇게 하면 계산량이 대폭 줄어든다.

---

### I와 D의 최대공약수(GCD)로 먼저 축약

항상

$$
g = \gcd(I, D),\quad I'=I/g,\ D'=D/g
$$

로 줄인 뒤 처리한다.

샘플링률 변화는

$$
\frac{I}{D} = \frac{I'}{D'}
$$

지만, 축약하면

- 위상 수(I')가 줄어
- 폴리페이즈 뱅크 크기가 작아지고
- 구현이 훨씬 가벼워진다.

---

## 설계 절차(실무 버전)

1. **목표 비율 r = Fs'/Fs 결정**
2. r을 유리수 $$I/D$$로 근사 (필요하면 분수 근사 알고리즘 사용)
3. $$g=\gcd(I,D)$$로 축약해 $$I',D'$$ 사용
4. **LPF 사양 설정**
   - 통과대역 경계 $$W_p$$ (원 신호 유효대역 기반)
   - 저지대역 시작 $$W_s \approx \min(1/I', 1/D')$$ 근처
   - 리플/감쇠(예: passband ripple ≤ 0.01 dB, stopband ≥ 80 dB)
5. **FIR 설계** (대개 선형 위상 FIR)
6. **I'-폴리페이즈 분해**
7. **모듈로 위상 스케줄링으로 출력 생성**
8. 스펙트럼/레벨/SNR/THD 검증
9. (필수 시) **다단 분해**로 연산량 더 줄임

---

## Octave 실습 1: 44.1 kHz → 48 kHz 변환 (I=160, D=147)

### 실험 시나리오

**상황**:
음악 파일(44.1 kHz)을 영상 편집 시스템(48 kHz)에 넣어야 한다.
따라서

$$
\frac{Fs'}{Fs} = \frac{48000}{44100} = \frac{160}{147}
$$

을 수행한다.

실험 목표:

1. 유리수 변환의 “정직한 구현”과 결과 확인
2. Octave의 built-in `resample`과 비교
3. 스펙트럼/진폭 일치 확인

---

### Octave 코드 (기본 resample 사용)

```octave
pkg load signal; clear; close all; clc;

Fs  = 44100;
Fs2 = 48000;
I   = 160;
D   = 147;

% test signal: 1 kHz + 10 kHz tone
t  = 0:1/Fs:1-1/Fs;
x  = 0.8*sin(2*pi*1000*t) + 0.3*sin(2*pi*10000*t);

% rational resampling using Octave resample()
y = resample(x, I, D);   % polyphase FIR inside

% time vectors
t2 = (0:length(y)-1)/Fs2;

% compare waveforms (short zoom)
figure;
subplot(2,1,1);
plot(t(1:1000), x(1:1000)); grid on; title("Original x[n] (44.1 kHz)");
subplot(2,1,2);
plot(t2(1:1000), y(1:1000)); grid on; title("Resampled y[n] (48 kHz)");

% spectrum comparison
Nfft = 16384;
X = fft(x.*hann(length(x))'); X = X(1:Nfft);
Y = fft(y.*hann(length(y))'); Y = Y(1:Nfft);

fX = (0:Nfft-1)*Fs/Nfft;
fY = (0:Nfft-1)*Fs2/Nfft;

figure;
plot(fX, 20*log10(abs(X)+eps), "linewidth", 1); hold on;
plot(fY, 20*log10(abs(Y)+eps), "linewidth", 1);
grid on; xlim([0 Fs2/2]);
legend("Original (44.1k)", "Resampled (48k)");
title("Spectrum before/after rational SRC");
```

### 결과 해석

- 1 kHz, 10 kHz 성분의 위치가 시간축에서 자연스럽게 재배치됨
- 스펙트럼에서 baseband 에너지 유지
- `resample`은 내부적으로 **폴리페이즈 FIR**를 사용해 imaging/aliasing을 동시에 억제한다.

---

## Octave 실습 2: 직접 구현하는 폴리페이즈 유리수 변환(교육용)

`resample`의 내부를 “개념적으로 재현”해보는 예제다.
실전 수준 최적화까지는 아니지만, 핵심 구조를 정확히 보여준다.

### 구현 아이디어

1. FIR LPF 설계 (원래 Fs 기준 정규화 컷오프)
2. h[n]을 I개의 위상으로 분해
3. 출력 n마다 위상 = (nD mod I)를 골라 계산

---

### Octave 코드

```octave
pkg load signal; clear; close all; clc;

Fs = 12000;
I  = 3;
D  = 2;
g  = gcd(I,D); I = I/g; D = D/g;  % reduce fraction

Fs2 = Fs*I/D;

% test signal in baseband (< min(Fs/2D, Fs/2) )
t  = 0:1/Fs:1-1/Fs;
x  = sin(2*pi*1000*t) + 0.4*sin(2*pi*2500*t);

% design LPF (anti-imaging & anti-alias)
% cutoff <= min(pi/I, pi/D) in normalized freq
Wp = 0.9*min(1/I, 1/D);   % passband edge (normalized to Nyquist=1)
M  = 96;                  % filter order example
h  = fir1(M, Wp, kaiser(M+1, 8));   % Kaiser FIR

% polyphase decomposition into I phases
Lh = length(h);
E  = cell(I,1);
for m=1:I
  E{m} = h(m:I:end);  % phase m-1
end

% polyphase resampler
Nx = length(x);
% approximate output length
Ny = floor(Nx*I/D);
y  = zeros(1, Ny);

% state buffer for convolution (store past samples)
% length equals max phase length
maxLen = max(cellfun(@length, E));
xbuf   = zeros(1, maxLen);

xi = 1;     % input index
ti = 0;     % time accumulator in units of 1/I

for n=1:Ny
  % determine which input samples are needed:
  % phase based on current ti
  phase = mod(ti, I) + 1;   % 1..I
  ep    = E{phase};

  % ensure buffer has current input sample
  while (ti >= I) && (xi <= Nx)
    % shift in new sample
    xbuf = [x(xi), xbuf(1:end-1)];
    xi   = xi + 1;
    ti   = ti - I;
  end

  % dot product with phase filter
  y(n) = ep * xbuf(1:length(ep)).';

  % advance time by D
  ti = ti + D;
end

% gain compensation by I
y = y * I;

% compare to built-in resample
y_ref = resample(x, I, D);

fprintf("Length manual=%d, builtin=%d\n", length(y), length(y_ref));
fprintf("RMS diff = %.3e\n", rms(y(1:min(end,end)) - y_ref(1:min(end,end))));

% plot short segment
t2 = (0:length(y)-1)/Fs2;
figure;
plot(t(1:500), x(1:500)); hold on;
plot(t2(1:500), y(1:500));
grid on; legend("x", "y(manual polyphase)");
title("Rational SRC by manual polyphase");
```

### 해설

- `E{m} = h(m:I:end)`가 폴리페이즈 분해 핵심
- `phase = mod(ti, I)`가 “분수 지연 위상 선택”을 수행
- `ti`는 출력 샘플이 원본 격자에서 어디에 위치하는지 누적 관리
- 최종 `*I`가 보간 이득 보상

실전 `resample`은 더 정교한 버퍼/위상 스케줄링을 쓰지만,
구조적 원리는 정확히 같다.

---

## 다단 유리수 변환(연산/메모리 최적화)

### 왜 다단이 중요한가?

예: 160/147을 한 번에 하면

- I=160 위상 폴리페이즈 뱅크
- 필터 길이가 커질수록 메모리와 캐시 부담

대신 비율을 소인수 분해해 단계화:

$$
\frac{160}{147}
= \frac{5\cdot 32}{3\cdot 7^2}
= \frac{5}{3}\cdot\frac{32}{49}
$$

같은 식으로
2~3단으로 쪼개면 각 단계 필터가 단순해져 총 비용이 감소한다.

### 다단 설계 규칙

1. 각 단계의 I, D를 작게
2. 중간 단계에서 유효대역이 변하므로
   각 단계마다 컷오프 재설정
3. 필터 차수는 단계별로 분산

---

## 시간가변 FIR(Fractional Delay)과 Farrow 구조(선택적 확장)

유리수 변환의 본질이 “분수 지연 보간”이므로
출력 샘플은

$$
y[n] = \sum_k h_\mu[k]\,x[n-k]
$$

처럼 **분수 지연 파라미터 $$\mu$$에 따라 달라지는 필터**를 요구한다.

폴리페이즈는

- $$\mu$$가 **I개의 이산 값**만 갖는 경우를 효율적으로 처리하는 방식.

한편 Farrow 구조는

- $$\mu$$가 연속적으로 변해도
- 다항식 근사로 실시간 출력이 가능하게 하는 대체 구조.

실무에서

- 변환비가 고정(예: 160/147) → 폴리페이즈가 표준
- 변환비가 가변/적응적 → Farrow가 유용

---

## 검증 지표

유리수 SRC를 설계/구현했다면 아래를 반드시 확인해야 한다.

1. **스펙트럼 왜곡**
   - baseband 리플
   - stopband 이미지/접힘 잔류

2. **레벨 일치**
   - 보간 이득 I 반영 여부
   - RMS/피크 보존

3. **위상/지연 특성**
   - 선형 위상 FIR이면 일정 group delay
   - 다단 구조면 단계 지연 합

4. **수치 정밀도**
   - 긴 FIR/큰 I에서는 계수 양자화/누산 오버플로우 점검

---

## 자주 하는 실수

1. **컷오프를 max(π/I, π/D)로 잡는 실수**
   → 반드시 **min**이다.
2. **I/D 축약(gcd) 생략**
   → 위상 수 불필요하게 증가
3. **필터 전이대역 여유 부족**
   → aliasing/이미지 잔류
4. **0 삽입을 실제로 만들어 필터링**
   → 연산 10~100배 낭비
5. **다단 없이 큰 비율을 단일 단계로 처리**
   → FIR 차수 폭발

---

## 연습문제

### 문제 14-1

샘플링률 12 kHz의 신호를 7.2 kHz로 변환하려 한다.
1) 필요한 유리수 비율 I/D는?
2) gcd로 축약한 I',D'는?
3) LPF 컷오프의 최대 정규화 값(원래 Fs 기준)은?

### 문제 14-2

I=5, D=8 변환에서
1) 폴리페이즈 위상 개수는?
2) 출력 n번째 샘플이 사용하는 위상 인덱스는 어떤 규칙으로 결정되는가?

### 문제 14-3

44.1 → 48 kHz 변환(I=160, D=147)을
2단 다단으로 근사 분해해보라.
(힌트: 소인수 분해 후 비슷한 크기의 비율로 쪼갠다.)

---

## 전체 정리

- 유리수 샘플링률 변환은
  **보간(↑I) + LPF + 데시메이션(↓D)**의 결합이다.

- 필터의 컷오프 조건은
  $$
  \omega_c \le \min\!\left(\frac{\pi}{I}, \frac{\pi}{D}\right)
  $$
  로 **imaging과 aliasing을 동시에 막는다.**

- 직접 구현은 낭비가 크므로
  **폴리페이즈 + 노블 아이덴티티 + gcd 축약 + 다단**이 표준 최적화다.

- 실전 대표 예는 44.1 ↔ 48 kHz로,
  $$160/147$$ 유리수 비율 변환이 정석이다.

이 기반이 잡히면, 다음은
**임의의 실수 비율을 유리수로 근사하는 방법(연분수/최소 오차 근사)**과
**다단 polyphase rational SRC 설계 자동화**로 자연스럽게 확장된다.
