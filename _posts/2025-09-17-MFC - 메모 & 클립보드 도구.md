---
layout: post
title: MFC - 메모 & 클립보드 도구
date: 2025-09-17 18:25:23 +0900
category: MFC
---
# 메모 & 클립보드 도구(Win32/MFC) 완전 가이드  
_트레이 아이콘 · 글로벌 단축키 · 자동 저장 · 클립보드 히스토리 · 스니펫 붙여넣기_

> “언제 어디서든 `Win+Shift+V` → 히스토리에서 골라 붙여넣기.”  
> 이 글은 MFC/Win32 C++로 **가벼운 메모+클립보드 유틸리티**를 만드는 방법을 **설계→핵심 API→코드 예제→데이터 보존→안전성**까지 생략 없이 정리합니다.  
> 샘플은 **트레이 아이콘**, **글로벌 단축키(RegisterHotKey)**, **자동 저장(원자 교체)**, **클립보드 변경 감시**, **히스토리/검색/즐겨찾기**를 포함합니다.

---

## 0) 완성 화면 개요(UX)

- **트레이 아이콘**: 좌클릭 = 팝업 열기, 우클릭 = 메뉴(환경설정/종료)
- **글로벌 단축키**: `Win+Shift+V` → **클립보드 히스토리 패널** 표시  
  `Win+Shift+N` → **빠른 메모 입력**  
- **히스토리**: 최근 N개(기본 200개), 텍스트/이미지/파일 목록 감지  
- **자동 저장**: `%APPDATA%\Vendor\Clipper\history.json`에 **주기+이벤트 기반** 저장(원자적 교체)  
- **검색/필터**: 입력 즉시 필터(부분 일치/정규식 옵션)  
- **붙여넣기**: 선택 → 대상 앱으로 **Activate+SendInput** 또는 **SetClipboardData** 후 `Ctrl+V`  
- **스니펫**: 자주 쓰는 텍스트를 단축키/약어로 확장(예: `;addr` → 주소 블록)

---

## 1) 프로젝트 스켈레톤(대화상자 기반 MFC 권장)

- MFC App Wizard → **Dialog 기반** + **유니코드** + **공유 MFC(/MDd, /MD)**  
- 리소스:  
  - `IDI_TRAY`(다중 해상도 아이콘)  
  - `IDD_MAIN`(히스토리/검색/핀 버튼/설정 버튼)  
  - `IDD_PREFS`(환경설정)  

### 1-1. 단일 인스턴스 보장(빠른 시작핵)

```cpp
// SingleInstance.h
class SingleInstance {
    HANDLE m_hMutex{};
public:
    bool Acquire(const wchar_t* key=L"Local\\Clipper_Singleton") {
        m_hMutex = ::CreateMutexW(nullptr, FALSE, key);
        if (!m_hMutex) return false;
        return (::GetLastError() != ERROR_ALREADY_EXISTS);
    }
    ~SingleInstance(){ if(m_hMutex) CloseHandle(m_hMutex); }
};
```

```cpp
// CClipperApp::InitInstance()
SingleInstance si;
if (!si.Acquire()) {
    // 이미 실행중 → 기존 인스턴스 활성화 메시지(예: WM_COPYDATA)
    return FALSE;
}
```

---

## 2) 트레이 아이콘(Shell_NotifyIcon) · 컨텍스트 메뉴

### 2-1. 추가/갱신/제거

```cpp
// Tray.h
constexpr UINT WM_TRAYICON = WM_APP + 1;

class CTrayIcon {
    NOTIFYICONDATAW nid{};
public:
    void Create(HWND hWnd, UINT id, HICON hIcon, const wchar_t* tip) {
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = id;
        nid.uFlags = NIF_MESSAGE|NIF_ICON|NIF_TIP;
        nid.uCallbackMessage = WM_TRAYICON;
        nid.hIcon = hIcon;
        wcsncpy_s(nid.szTip, tip, _TRUNCATE);
        Shell_NotifyIconW(NIM_ADD, &nid);
    }
    void SetTip(const std::wstring& tip){ wcsncpy_s(nid.szTip, tip.c_str(), _TRUNCATE); Shell_NotifyIconW(NIM_MODIFY, &nid); }
    void Destroy(){ Shell_NotifyIconW(NIM_DELETE, &nid); }
};
```

```cpp
// CMainDlg 멤버
CTrayIcon m_tray;

// OnInitDialog
m_tray.Create(m_hWnd, 1, AfxGetApp()->LoadIcon(IDI_TRAY), L"Clipper");

// 메시지 처리
afx_msg LRESULT OnTrayIcon(WPARAM id, LPARAM lParam) {
    if (LOWORD(lParam) == WM_LBUTTONUP) TogglePopup(); // 토글 표시
    else if (LOWORD(lParam) == WM_RBUTTONUP) ShowTrayMenu(); // 컨텍스트
    return 0;
}
```

```cpp
// 메뉴 표시
void CMainDlg::ShowTrayMenu() {
    CMenu m; m.LoadMenu(IDR_TRAY);
    CMenu* p = m.GetSubMenu(0);
    POINT pt; GetCursorPos(&pt);
    SetForegroundWindow(); // 트레이 메뉴 포커스 트릭
    p->TrackPopupMenu(TPM_RIGHTBUTTON, pt.x, pt.y, this);
}
```

---

## 3) 글로벌 단축키(RegisterHotKey)

- OS 전역에서 **실행중일 때만** 단축키 수신.
- 충돌 가능(다른 앱과 겹칠 수 있음) → **사용자 지정**/재등록 UX 제공.

```cpp
// Hotkey.h
enum : UINT { HK_TOGGLE=1, HK_QUICKNOTE=2 };

bool RegisterGlobalHotkeys(HWND h) {
    // Win+Shift+V (MOD_WIN | MOD_SHIFT, 'V')
    if (!::RegisterHotKey(h, HK_TOGGLE, MOD_WIN|MOD_SHIFT, 'V')) return false;
    // Win+Shift+N
    if (!::RegisterHotKey(h, HK_QUICKNOTE, MOD_WIN|MOD_SHIFT, 'N')) return false;
    return true;
}

void UnregisterGlobalHotkeys(HWND h) {
    ::UnregisterHotKey(h, HK_TOGGLE);
    ::UnregisterHotKey(h, HK_QUICKNOTE);
}
```

```cpp
// CMainDlg 메시지
afx_msg void OnHotKey(UINT id, UINT, UINT) {
    switch(id){
    case HK_TOGGLE: TogglePopup(); break;
    case HK_QUICKNOTE: OpenQuickNote(); break;
    }
}
```

> **TIP**: 실패 시 `GetLastError()==ERROR_HOTKEY_ALREADY_REGISTERED` → 다른 조합 제안.

---

## 4) 클립보드 변경 감시

### 4-1. API 선택

- Windows Vista 이상: **`AddClipboardFormatListener(hwnd)`**(권장) → `WM_CLIPBOARDUPDATE`  
- 구버전 호환: **클립보드 뷰어 체인**(`SetClipboardViewer`)

```cpp
// OnInitDialog
::AddClipboardFormatListener(m_hWnd);

// 메시지 맵
ON_MESSAGE(WM_CLIPBOARDUPDATE, &CMainDlg::OnClipboardUpdate)

LRESULT CMainDlg::OnClipboardUpdate(WPARAM, LPARAM) {
    CaptureClipboard(); // 히스토리에 추가
    return 0;
}
```

### 4-2. 클립보드 데이터 뽑기(텍스트/이미지/파일)

```cpp
struct ClipItem {
    enum Type { Text, Image, Files } type;
    std::wstring text;
    std::vector<std::wstring> files;
    HBITMAP hbm{}; // 썸네일(옵션)
    SYSTEMTIME time{};
    bool pinned=false;
};

std::optional<ClipItem> ReadClipboard() {
    if (!OpenClipboard(nullptr)) return std::nullopt;
    ClipItem item{};
    GetLocalTime(&item.time);

    if (IsClipboardFormatAvailable(CF_UNICODETEXT)) {
        auto h = GetClipboardData(CF_UNICODETEXT);
        if (auto p = (wchar_t*)GlobalLock(h)) {
            item.type = ClipItem::Text;
            item.text = p;
            GlobalUnlock(h);
            CloseClipboard();
            return item;
        }
    }
    if (IsClipboardFormatAvailable(CF_HDROP)) {
        auto h = (HDROP)GetClipboardData(CF_HDROP);
        UINT n = DragQueryFileW(h, 0xFFFFFFFF, nullptr, 0);
        item.type = ClipItem::Files;
        for (UINT i=0;i<n;++i){
            wchar_t buf[MAX_PATH]; DragQueryFileW(h,i,buf,MAX_PATH);
            item.files.push_back(buf);
        }
        CloseClipboard();
        return item;
    }
    if (IsClipboardFormatAvailable(CF_DIB) || IsClipboardFormatAvailable(CF_DIBV5)) {
        // 간단: 썸네일만 저장(원본은 파일 캐시로 따로 저장 가능)
        item.type = ClipItem::Image;
        // (생략) DIB → HBITMAP 생성
        CloseClipboard();
        return item;
    }
    CloseClipboard();
    return std::nullopt;
}
```

```cpp
void CMainDlg::CaptureClipboard() {
    if (auto o = ReadClipboard()) {
        // 중복 제거(바로 직전과 동일 텍스트 등)
        if (!m_history.empty() && o->type==ClipItem::Text && m_history.front().text == o->text)
            return;
        m_history.push_front(std::move(*o));
        TrimHistory();
        m_dirty = true;
        DebouncedSave();    // 500ms 이내 묶어서 저장
        RefreshListView();
    }
}
```

---

## 5) 히스토리 UI(검색/핀/고정 삭제 방지)

- `CListCtrl LVS_REPORT` + `LVS_EX_DOUBLEBUFFER | LVS_EX_FULLROWSELECT`  
- 열: 아이콘/미리보기 | 내용(앞부분) | 타입 | 날짜 | 핀  
- **검색 박스(EN_CHANGE)** → 필터링된 가상 리스트로 표시

```cpp
// 초기화
m_list.SetExtendedStyle(LVS_EX_DOUBLEBUFFER|LVS_EX_FULLROWSELECT|LVS_EX_INFOTIP);
m_list.InsertColumn(0, L"", LVCFMT_LEFT, 28);
m_list.InsertColumn(1, L"내용", LVCFMT_LEFT, 380);
m_list.InsertColumn(2, L"형식", LVCFMT_LEFT, 80);
m_list.InsertColumn(3, L"시간", LVCFMT_LEFT, 140);
m_list.InsertColumn(4, L"핀", LVCFMT_CENTER, 40);

// 더블클릭 → 붙여넣기, Space → 핀 토글
```

### 5-1. 빠른 포맷팅 헬퍼

```cpp
static std::wstring PrettyTime(const SYSTEMTIME& t){
    wchar_t buf[64]; swprintf_s(buf, L"%04d-%02d-%02d %02d:%02d", t.wYear,t.wMonth,t.wDay,t.wHour,t.wMinute);
    return buf;
}
```

### 5-2. 붙여넣기 동작(선택 → 대상 앱)

두 가지 방식:

1) **SetClipboardData + Ctrl+V 시뮬레이션**(안정/일반적)  
2) **프로그램적으로 창 활성화 후, 직접 SetClipboardData**만 하고 `SendInput(^V)` (IME/권한 이슈 고려)

```cpp
void PasteFromItem(const ClipItem& it) {
    // 대상 창: 히스토리 창을 숨기고 이전 포그라운드 복귀
    HWND hPrev = GetForegroundWindow();
    ShowWindow(SW_HIDE);
    if (hPrev) SetForegroundWindow(hPrev);

    if (OpenClipboard(nullptr)) {
        EmptyClipboard();
        if (it.type == ClipItem::Text) {
            size_t bytes = (it.text.size()+1) * sizeof(wchar_t);
            HGLOBAL h = GlobalAlloc(GMEM_MOVEABLE, bytes);
            memcpy(GlobalLock(h), it.text.c_str(), bytes);
            GlobalUnlock(h);
            SetClipboardData(CF_UNICODETEXT, h);
        }
        // TODO: Files/Image 케이스도 구현
        CloseClipboard();
    }

    // Ctrl+V 시뮬
    INPUT in[4] = {};
    in[0].type=INPUT_KEYBOARD; in[0].ki.wVk=VK_CONTROL;       // Ctrl down
    in[1].type=INPUT_KEYBOARD; in[1].ki.wVk='V';              // V down
    in[2].type=INPUT_KEYBOARD; in[2].ki.wVk='V'; in[2].ki.dwFlags=KEYEVENTF_KEYUP;
    in[3].type=INPUT_KEYBOARD; in[3].ki.wVk=VK_CONTROL; in[3].ki.dwFlags=KEYEVENTF_KEYUP;
    SendInput(4, in, sizeof(INPUT));
}
```

---

## 6) 자동 저장(원자 교체) · 포맷(JSON)

### 6-1. 경로 레이아웃

```
%APPDATA%\Vendor\Clipper\
  settings.json
  history.json         // 메타+본문(텍스트/파일 목록)
  cache\images\...     // 큰 이미지는 파일로 캐시
  logs\app-YYYYMMDD.txt
```

### 6-2. JSON 스키마(간단)

```json
{
  "schema": 1,
  "items": [
    { "type":"text", "data":"Hello", "time":"2025-10-26T13:03:21Z", "pinned":false },
    { "type":"files", "data":["C:\\a.txt","C:\\b.pdf"], "time":"...","pinned":true }
  ]
}
```

### 6-3. 저장 코드(디바운스 + 원자 교체)

```cpp
void CMainDlg::DebouncedSave() {
    m_saveDue = GetTickCount64() + 500;
    if (!m_saver.joinable()) {
        m_saver = std::thread([this]{
            for (;;) {
                Sleep(100);
                auto now = GetTickCount64();
                if (!m_dirty) break;
                if (now >= m_saveDue) {
                    SaveHistoryAtomic();
                    m_dirty = false;
                }
            }
        });
        m_saver.detach(); // 가벼운 백그라운드 워커(단발)
    }
}

bool CMainDlg::SaveHistoryAtomic() {
    std::string js = SerializeHistoryToJson(m_history);
    auto dir = EnsureAppData();
    auto path = dir / L"history.json";
    auto tmp  = dir / L"history.json.tmp";

    HANDLE h = CreateFileW(tmp.c_str(), GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (h==INVALID_HANDLE_VALUE) return false;
    DWORD w=0; WriteFile(h, js.data(), (DWORD)js.size(), &w, nullptr);
    FlushFileBuffers(h); CloseHandle(h);
    return !!MoveFileExW(tmp.c_str(), path.c_str(), MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH);
}
```

> **TIP**: 앱 크래시 시 `.tmp` 발견 → **복구 안내**(가장 최근 스냅샷).

---

## 7) 스니펫 & 약어 확장

- `;addr` 입력 후 글로벌 단축키 `Win+Shift+Space` → **현재 커서 위치**에 지정 텍스트 삽입
- 방법: 대상 창 활성화 → **클립보드에 텍스트** → `SendInput(Ctrl+V)`  
  (고급: 직접 **SendInput(키 시퀀스)** 로도 가능하지만 로케일/IME 복잡)

```cpp
struct Snippet { std::wstring key; std::wstring text; UINT hotkeyId; };
std::vector<Snippet> m_snippets = {
    {L";addr", L"서울특별시 중구 세종대로 110 ...", 100}
};
```

- 히스토리 창 없이도 **백그라운드에서 약어 탐지**하려면 **저수준 키보드 훅(WH_KEYBOARD_LL)** 필요 → 보안/충돌 리스크 있으니 **명시 동의**와 **예외 처리** 필수.  
  단순/안전 경로로는 **사용자 지정 핫키로 팝업 → 선택**을 추천.

---

## 8) 설정(Preferences) & 권장 기본값

- 최대 히스토리: 200 (핀 항목은 초과해도 유지)  
- 캡처 예외: **비밀번호 관리자/은행 앱** 감지 시 캡처 차단(프로세스 이름 화이트리스트/블랙리스트)  
- 자동 시작: 레지스트리 `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`  
- 프라이버시: **개인 데이터 마스킹 옵션**(이메일/주민번호 패턴 감지 시 저장 거부)

```cpp
bool SetAutoStart(bool on) {
    CRegKey k;
    if (k.Create(HKEY_CURRENT_USER, LR"(Software\Microsoft\Windows\CurrentVersion\Run)")!=ERROR_SUCCESS) return false;
    if (on) k.SetStringValue(L"Clipper", L"\"C:\\Program Files\\Clipper\\Clipper.exe\"");
    else k.DeleteValue(L"Clipper");
    return true;
}
```

---

## 9) 고급: 이미지/RTF/HTML 클립보드

- 포맷 ID:
  - 텍스트: `CF_UNICODETEXT`, HTML은 **등록된 포맷**(`RegisterClipboardFormat(L"HTML Format")`)
  - RTF: `"Rich Text Format"`
  - 이미지: `CF_DIB`/`CF_DIBV5`, PNG/BMP는 앱별 커스텀 포맷도 존재
- 전략:
  - **우선 텍스트**를 기본값으로
  - 이미지/리치 텍스트는 **메타에 포맷 이름** 저장 → 붙여넣기 시 **가장 호환되는 포맷** 선택

```cpp
UINT CF_HTML = RegisterClipboardFormatW(L"HTML Format");
UINT CF_RTF  = RegisterClipboardFormatW(L"Rich Text Format");
```

---

## 10) 성능/안정성/보안 팁

- **대량 히스토리**: 가상 리스트(`LVS_OWNERDATA`) + `LVN_GETDISPINFO` 공급  
- **이미지 캐시**는 파일로 분리(메모리 과다 방지), 썸네일만 메모리에  
- **스레드 안전**: 클립보드 접근은 UI 스레드에서, 백그라운드는 메시지로 전달  
- **민감 데이터 필터**: 정규식으로 주민번호/카드번호 탐지 시 **캡처 거부/경고**  
- **충돌 방지**: 글로벌 핫키 실패 시 대체 조합 제안, 사용자 설정에 저장  
- **다크 모드**: `DwmSetWindowAttribute(UseImmersiveDarkMode)` + 아이콘 알파

---

## 11) 테스트 시나리오(체크리스트)

- [ ] Win+Shift+V로 팝업 토글, ESC로 닫기  
- [ ] 텍스트/이미지/파일 복사 후 히스토리에 정상 추가  
- [ ] 검색어 입력 → 실시간 필터  
- [ ] 엔터/더블클릭 → 대상 앱에 붙여넣기(메모장/Word/브라우저 각각)  
- [ ] 핀한 항목은 **삭제/정리에도 보존**  
- [ ] 재시작 후 **히스토리 복원**  
- [ ] 긴 텍스트(>100KB)/이모지/한글 혼합 정상 처리  
- [ ] 멀티 모니터에서 팝업 위치(마우스 근처) 자연스럽게

---

## 12) 장애/트러블슈팅

- **붙여넣기 안 됨**:  
  - UAC 경계(관리자/일반) 다르면 `SendInput`이 무시될 수 있음 → **자체를 관리자 권한**으로 실행 or **클립보드만 갱신** 후 사용자 `Ctrl+V` 유도  
- **클립보드 잠김**:  
  - 다른 프로세스가 잠금 유지 → **재시도(백오프)** 후 포기  
- **글로벌 핫키 충돌**:  
  - 등록 실패 → UI로 즉시 알림 및 다른 조합 추천  
- **데이터 손실**:  
  - 저장은 **원자 교체** + `.bak` 보관(최근 3개 롤링)

---

## 13) 코드 조각—검색 필터(간단, 부분 일치)

```cpp
std::vector<int> CMainDlg::BuildFilteredIndex(const std::wstring& q) {
    std::vector<int> out;
    if (q.empty()) { out.resize((int)m_history.size()); std::iota(out.begin(), out.end(), 0); return out; }
    for (int i=0;i<(int)m_history.size();++i){
        const auto& it = m_history[i];
        if (it.type==ClipItem::Text) {
            if (_wcsicmp(it.text.c_str(), q.c_str())==0 || it.text.find(q)!=std::wstring::npos)
                out.push_back(i);
        } else if (it.type==ClipItem::Files) {
            for (auto& f: it.files) if (f.find(q)!=std::wstring::npos){ out.push_back(i); break; }
        }
    }
    return out;
}
```

---

## 14) 미세 UX: 포커스/애니메이션/키 처리

- 팝업 열릴 때 **현재 마우스 근처** 위치, 위/아래로 펼치기  
- 키:  
  - ↑/↓ 이동, Enter 붙여넣기, Space 핀 토글, Ctrl+F 검색 포커스  
  - ESC 닫기, Ctrl+L 전체 선택/검색 이동  
- 마지막 포커스 아이템 기억

```cpp
BOOL CMainDlg::PreTranslateMessage(MSG* p) {
    if (p->message==WM_KEYDOWN && p->wParam==VK_ESCAPE) { ShowWindow(SW_HIDE); return TRUE; }
    return CDialogEx::PreTranslateMessage(p);
}
```

---

## 15) 설정 저장/불러오기(간단 JSON)

```cpp
struct Settings {
    int maxItems=200;
    bool autoStart=true;
    std::wstring hkToggle=L"Win+Shift+V";
    std::vector<Snippet> snippets;
};

Settings g_cfg;

void LoadSettings() { /* 파일→g_cfg; 기본값 보충 */ }
void SaveSettings() { /* g_cfg→파일(원자 교체) */ }
```

---

## 16) 보안/컴플라이언스(실무)

- 개인정보/민감정보 정책:  
  - **직원 PC** 용이라면 **도메인 정책(화이트리스트 앱만 캡처)**  
  - **개인용 배포**는 opt-in 동의 + “민감 정보 자동 무시”  
- 전송 금지: 인터넷 업로드 기능은 **기본 OFF**  
- 로그: 사용자가 원할 때만 **오류 진단 로그** 제출(비식별화)

---

## 17) 배포/업데이트

- **MSI/Setup**: 자동 시작 옵션, ‘바탕화면 바로가기’ 체크  
- **코드 서명**: SmartScreen 경고 완화  
- **자동 업데이트**(선택): 서버에서 zip → 서명/해시 검증 → replace 후 재시작

---

## 18) 확장 아이디어

- **서브클립보드**: 슬롯 1~9 (Alt+1~9로 빠르게 교체/붙여넣기)  
- **템플릿 변수**: `{date}`, `{time}`, `{user}`  
- **OCR**: 이미지 → 텍스트(Windows OCR API)  
- **다중 장치 동기화**: 클라우드(선택), 단 회사 내에서는 **사내 서버** 사용

---

## 19) 전체 흐름 요약(시퀀스)

```
[시작] → 트레이 등록 → 글로벌 핫키 등록
     → AddClipboardFormatListener
     → (클립보드 변경) ──▶ ReadClipboard ─▶ 히스토리에 저장 ─▶ DebouncedSave(JSON)
[Win+Shift+V] ─▶ 팝업 표시 ─▶ 검색/선택 ─▶ Paste(클립보드 세팅 + SendInput)
[종료] ─▶ 저장/정리 ─▶ 트레이 제거/핫키 해제
```

---

## 20) 마무리

이 가이드는 **작고 안전한 구성**으로도 **충분히 쓸만한** 메모&클립보드 도구를 만드는 길을 제시합니다.  
핵심은:

1) **트레이/핫키/클립보드 감시** 3종 세트,  
2) **히스토리+검색+핀** UX,  
3) **자동 저장(원자 교체) + 복구**,  
4) **대상 앱으로의 안정적 붙여넣기**.