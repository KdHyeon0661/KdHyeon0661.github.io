---
layout: post
title: 파이썬 심화 - C 확장 (2)
date: 2025-12-09 17:30:23 +0900
category: 파이썬 심화
---
# C 확장 (2)

파이썬과 C/C++의 통합은 성능 최적화와 기존 코드 활용을 위한 핵심 기술입니다. C에서 파이썬 호출, GIL 관리, 스레드 통합, 자동화된 래핑 등 다양한 상호운용 패턴을 심층적으로 살펴보겠습니다.

## C에서 파이썬 인터프리터 호출하기

### 파이썬 C API를 활용한 직접 통합

```c
/* python_embedding.c - C에서 파이썬 인터프리터 임베딩 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stdio.h>
#include <stdlib.h>

/* Python 초기화 및 최종화 관리자 */
typedef struct {
    PyObject *main_module;
    PyObject *main_dict;
    int initialized;
} PythonEmbedder;

PythonEmbedder* create_python_embedder() {
    PythonEmbedder* embedder = malloc(sizeof(PythonEmbedder));
    if (!embedder) return NULL;
    
    embedder->main_module = NULL;
    embedder->main_dict = NULL;
    embedder->initialized = 0;
    
    // Python 인터프리터 초기화
    Py_Initialize();
    
    // 시스템 경로에 현재 디렉토리 추가
    PyRun_SimpleString("import sys\nsys.path.append('.')\n");
    
    // __main__ 모듈과 dict 가져오기
    embedder->main_module = PyImport_AddModule("__main__");
    if (embedder->main_module) {
        embedder->main_dict = PyModule_GetDict(embedder->main_module);
        Py_INCREF(embedder->main_dict);
        embedder->initialized = 1;
    }
    
    return embedder;
}

void destroy_python_embedder(PythonEmbedder* embedder) {
    if (!embedder) return;
    
    if (embedder->main_dict) {
        Py_DECREF(embedder->main_dict);
    }
    
    if (embedder->initialized) {
        Py_Finalize();
    }
    
    free(embedder);
}

/* Python 코드 실행 - 간단한 문자열 실행 */
PyObject* execute_python_code(PythonEmbedder* embedder, const char* code) {
    if (!embedder || !embedder->initialized) {
        fprintf(stderr, "Python embedder not initialized\n");
        return NULL;
    }
    
    PyObject* result = PyRun_String(code, Py_file_input, 
                                    embedder->main_dict, embedder->main_dict);
    
    if (!result) {
        PyErr_Print();  // Python 에러 출력
        return NULL;
    }
    
    Py_DECREF(result);
    return Py_None;  // 성공 시 None 반환
}

/* Python 함수 호출 */
PyObject* call_python_function(PythonEmbedder* embedder, 
                              const char* function_name, 
                              const char* format, ...) {
    if (!embedder || !embedder->initialized) return NULL;
    
    // 함수 객체 가져오기
    PyObject* func = PyDict_GetItemString(embedder->main_dict, function_name);
    if (!func || !PyCallable_Check(func)) {
        fprintf(stderr, "Function %s not found or not callable\n", function_name);
        return NULL;
    }
    
    // 인자 생성
    PyObject* args = NULL;
    PyObject* kwargs = NULL;
    PyObject* result = NULL;
    
    if (format) {
        va_list va;
        va_start(va, format);
        args = Py_VaBuildValue(format, va);
        va_end(va);
        
        if (!args) {
            PyErr_Print();
            return NULL;
        }
    } else {
        args = PyTuple_New(0);
    }
    
    // 함수 호출
    result = PyObject_Call(func, args, kwargs);
    
    Py_XDECREF(args);
    Py_XDECREF(kwargs);
    
    if (!result) {
        PyErr_Print();
        return NULL;
    }
    
    return result;
}

/* Python 모듈 로드 및 사용 */
PyObject* load_python_module(PythonEmbedder* embedder, const char* module_name) {
    PyObject* module_name_obj = PyUnicode_FromString(module_name);
    if (!module_name_obj) return NULL;
    
    PyObject* module = PyImport_Import(module_name_obj);
    Py_DECREF(module_name_obj);
    
    if (!module) {
        PyErr_Print();
        return NULL;
    }
    
    // 모듈을 전역 dict에 추가
    if (PyModule_AddObject(embedder->main_module, module_name, module) < 0) {
        Py_DECREF(module);
        return NULL;
    }
    
    return module;
}

/* C 데이터를 Python 객체로 변환 */
PyObject* c_data_to_python(double* array, int size) {
    // C 배열을 Python 리스트로 변환
    PyObject* list = PyList_New(size);
    if (!list) return NULL;
    
    for (int i = 0; i < size; i++) {
        PyObject* item = PyFloat_FromDouble(array[i]);
        if (!item) {
            Py_DECREF(list);
            return NULL;
        }
        PyList_SET_ITEM(list, i, item);
    }
    
    return list;
}

/* Python 객체를 C 데이터로 변환 */
int python_to_c_data(PyObject* list, double** array, int* size) {
    if (!PyList_Check(list)) {
        PyErr_SetString(PyExc_TypeError, "Expected a list");
        return 0;
    }
    
    *size = PyList_Size(list);
    *array = malloc(*size * sizeof(double));
    
    if (!*array) {
        PyErr_NoMemory();
        return 0;
    }
    
    for (int i = 0; i < *size; i++) {
        PyObject* item = PyList_GetItem(list, i);
        if (!PyFloat_Check(item)) {
            free(*array);
            PyErr_SetString(PyExc_TypeError, "List must contain floats");
            return 0;
        }
        (*array)[i] = PyFloat_AsDouble(item);
    }
    
    return 1;
}

/* 메인 데모 함수 */
void demonstrate_python_embedding() {
    printf("=== C에서 파이썬 호출하기 ===\n\n");
    
    PythonEmbedder* embedder = create_python_embedder();
    if (!embedder || !embedder->initialized) {
        fprintf(stderr, "Failed to initialize Python embedder\n");
        return;
    }
    
    // 1. Python 코드 실행
    printf("1. Python 코드 실행:\n");
    execute_python_code(embedder, 
        "print('Hello from Python embedded in C!')\n"
        "x = 42\n"
        "print(f'x = {x}')\n"
    );
    
    // 2. Python 함수 정의 및 호출
    printf("\n2. Python 함수 호출:\n");
    execute_python_code(embedder,
        "def add_numbers(a, b):\n"
        "    print(f'Adding {a} + {b}')\n"
        "    return a + b\n"
        "\n"
        "def process_data(data):\n"
        "    print(f'Processing data: {data}')\n"
        "    return [x * 2 for x in data]\n"
    );
    
    // C에서 Python 함수 호출
    PyObject* result = call_python_function(embedder, "add_numbers", "(ii)", 10, 20);
    if (result) {
        long sum = PyLong_AsLong(result);
        printf("Result from Python function: %ld\n", sum);
        Py_DECREF(result);
    }
    
    // 3. 데이터 변환 데모
    printf("\n3. C-Python 데이터 변환:\n");
    
    // C 데이터 준비
    double c_array[] = {1.1, 2.2, 3.3, 4.4, 5.5};
    int array_size = sizeof(c_array) / sizeof(c_array[0]);
    
    // C -> Python 변환
    PyObject* py_list = c_data_to_python(c_array, array_size);
    if (py_list) {
        // Python 함수에 전달
        PyObject* args = PyTuple_Pack(1, py_list);
        PyObject* processed = call_python_function(embedder, "process_data", "O", py_list);
        
        if (processed) {
            // Python -> C 변환
            double* output_array = NULL;
            int output_size = 0;
            
            if (python_to_c_data(processed, &output_array, &output_size)) {
                printf("Processed data from Python:\n");
                for (int i = 0; i < output_size; i++) {
                    printf("  [%d] = %.2f\n", i, output_array[i]);
                }
                free(output_array);
            }
            
            Py_DECREF(processed);
        }
        
        Py_DECREF(py_list);
        Py_DECREF(args);
    }
    
    // 4. 외부 모듈 사용
    printf("\n4. 외부 Python 모듈 사용:\n");
    
    // math 모듈 로드
    PyObject* math_module = load_python_module(embedder, "math");
    if (math_module) {
        // math.sqrt 함수 사용
        PyObject* sqrt_func = PyObject_GetAttrString(math_module, "sqrt");
        if (sqrt_func && PyCallable_Check(sqrt_func)) {
            PyObject* args = PyTuple_Pack(1, PyFloat_FromDouble(25.0));
            PyObject* sqrt_result = PyObject_CallObject(sqrt_func, args);
            
            if (sqrt_result) {
                double result_val = PyFloat_AsDouble(sqrt_result);
                printf("math.sqrt(25) = %.2f\n", result_val);
                Py_DECREF(sqrt_result);
            }
            
            Py_DECREF(args);
            Py_DECREF(sqrt_func);
        }
        Py_DECREF(math_module);
    }
    
    // 5. 오류 처리 데모
    printf("\n5. 오류 처리:\n");
    
    // 존재하지 않는 함수 호출 시도
    result = call_python_function(embedder, "non_existent_function", "");
    if (!result) {
        printf("Expected error handled gracefully\n");
    }
    
    destroy_python_embedder(embedder);
}

int main() {
    demonstrate_python_embedding();
    return 0;
}
```

### 빌드 및 실행 방법

```makefile
# Makefile
CC = gcc
CFLAGS = -I/usr/include/python3.9 -Wall -O2
LDFLAGS = -lpython3.9

# Python 경로는 시스템에 맞게 조정 필요
PYTHON_INCLUDE = $(shell python3-config --includes)
PYTHON_LIBS = $(shell python3-config --libs)

all: python_embedding

python_embedding: python_embedding.c
	$(CC) $(CFLAGS) $(PYTHON_INCLUDE) -o $@ $< $(LDFLAGS) $(PYTHON_LIBS)

clean:
	rm -f python_embedding

run: python_embedding
	./python_embedding
```

```python
# test_embedding.py - C 프로그램과 함께 사용할 Python 모듈
"""C에서 호출할 Python 모듈 예제"""

def compute_statistics(data):
    """데이터 통계 계산"""
    if not data:
        return {"error": "Empty data"}
    
    return {
        "mean": sum(data) / len(data),
        "min": min(data),
        "max": max(data),
        "sum": sum(data),
        "count": len(data)
    }

def fibonacci(n):
    """피보나치 수열 생성"""
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    
    fib = [0, 1]
    for i in range(2, n):
        fib.append(fib[i-1] + fib[i-2])
    
    return fib

class DataProcessor:
    """데이터 처리 클래스"""
    
    def __init__(self, multiplier=1.0):
        self.multiplier = multiplier
        self.process_count = 0
    
    def process(self, data):
        """데이터 처리"""
        self.process_count += 1
        return [x * self.multiplier for x in data]
    
    def get_stats(self):
        """처리 통계"""
        return {
            "process_count": self.process_count,
            "multiplier": self.multiplier
        }
```

## C 확장에서 GIL 관리와 해제

### GIL 이해와 효율적인 관리 패턴

```c
/* gil_management.c - C 확장에서 GIL 관리 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

/* CPU 집약적인 계산 함수 */
static PyObject* cpu_intensive_task(PyObject* self, PyObject* args) {
    long iterations;
    
    if (!PyArg_ParseTuple(args, "l", &iterations)) {
        return NULL;
    }
    
    double result = 0.0;
    
    // CPU 집약적인 계산
    for (long i = 0; i < iterations; i++) {
        result += 1.0 / (i + 1.0);
    }
    
    return PyFloat_FromDouble(result);
}

/* I/O 바운드 작업 (GIL 해제 예제) */
static PyObject* io_bound_task_with_gil_release(PyObject* self, PyObject* args) {
    const char* filename;
    
    if (!PyArg_ParseTuple(args, "s", &filename)) {
        return NULL;
    }
    
    /* GIL 해제 - I/O 작업 동안 다른 Python 스레드 실행 허용 */
    Py_BEGIN_ALLOW_THREADS
    
    // I/O 작업 시뮬레이션 (GIL 없이 실행)
    sleep(1);  // 파일 읽기/쓰기 시뮬레이션
    
    // 실제 파일 작업 (예시)
    FILE* file = fopen(filename, "r");
    long file_size = 0;
    
    if (file) {
        fseek(file, 0, SEEK_END);
        file_size = ftell(file);
        fclose(file);
    }
    
    /* GIL 재획득 - Python 객체 작업 전에 필요 */
    Py_END_ALLOW_THREADS
    
    return PyLong_FromLong(file_size);
}

/* GIL 상태 추적을 위한 구조체 */
typedef struct {
    PyThreadState* saved_state;
    int gil_released;
} GilManager;

/* GIL 안전한 컨텍스트 관리자 */
GilManager* begin_gil_free_zone() {
    GilManager* manager = malloc(sizeof(GilManager));
    if (!manager) return NULL;
    
    manager->gil_released = 0;
    
    /* GIL이 이미 해제되었는지 확인 */
    if (PyGILState_Check()) {
        /* GIL 해제 및 상태 저장 */
        manager->saved_state = PyEval_SaveThread();
        manager->gil_released = 1;
    }
    
    return manager;
}

void end_gil_free_zone(GilManager* manager) {
    if (!manager) return;
    
    if (manager->gil_released) {
        /* GIL 복원 */
        PyEval_RestoreThread(manager->saved_state);
    }
    
    free(manager);
}

/* 블로킹 시스템 호출을 위한 GIL 관리 래퍼 */
static PyObject* blocking_system_call(PyObject* self, PyObject* args) {
    int duration;
    
    if (!PyArg_ParseTuple(args, "i", &duration)) {
        return NULL;
    }
    
    GilManager* gil_manager = begin_gil_free_zone();
    
    // 블로킹 시스템 호출 (GIL 없이 실행)
    sleep(duration);
    
    // 시스템 호출 결과 시뮬레이션
    int result = duration * 2;
    
    end_gil_free_zone(gil_manager);
    
    return PyLong_FromLong(result);
}

/* 스레드 안전한 카운터 (GIL 세부 제어) */
typedef struct {
    PyObject_HEAD
    long value;
    pthread_mutex_t mutex;
} ThreadSafeCounter;

static void ThreadSafeCounter_dealloc(ThreadSafeCounter* self) {
    pthread_mutex_destroy(&self->mutex);
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject* ThreadSafeCounter_new(PyTypeObject* type, 
                                       PyObject* args, PyObject* kwds) {
    ThreadSafeCounter* self;
    self = (ThreadSafeCounter*)type->tp_alloc(type, 0);
    if (self) {
        self->value = 0;
        pthread_mutex_init(&self->mutex, NULL);
    }
    return (PyObject*)self;
}

static int ThreadSafeCounter_init(ThreadSafeCounter* self, 
                                  PyObject* args, PyObject* kwds) {
    static char* kwlist[] = {"initial_value", NULL};
    long initial_value = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "|l", kwlist, &initial_value)) {
        return -1;
    }
    
    self->value = initial_value;
    return 0;
}

/* 스레드 안전한 증가 연산 (세밀한 GIL 제어) */
static PyObject* ThreadSafeCounter_increment(ThreadSafeCounter* self, 
                                            PyObject* args) {
    long amount = 1;
    
    if (!PyArg_ParseTuple(args, "|l", &amount)) {
        return NULL;
    }
    
    /* 장시간 락을 잡을 수 있는 작업이므로 GIL 임시 해제 */
    Py_BEGIN_ALLOW_THREADS
    
    pthread_mutex_lock(&self->mutex);
    self->value += amount;
    long current_value = self->value;
    pthread_mutex_unlock(&self->mutex);
    
    Py_END_ALLOW_THREADS
    
    return PyLong_FromLong(current_value);
}

/* 재진입 가능한 C 함수 (GIL 관리 중요성) */
static PyObject* reentrant_computation(PyObject* self, PyObject* args) {
    long depth;
    
    if (!PyArg_ParseTuple(args, "l", &depth)) {
        return NULL;
    }
    
    if (depth <= 0) {
        return PyLong_FromLong(0);
    }
    
    /* 재귀 호출 시 GIL 상태 보존이 중요 */
    PyObject* py_result = NULL;
    
    // Python 콜백 호출 (GIL 필요)
    PyObject* callback_func = PyDict_GetItemString(
        PyModule_GetDict(PyImport_AddModule("__main__")), 
        "compute_callback"
    );
    
    if (callback_func && PyCallable_Check(callback_func)) {
        PyObject* callback_args = PyTuple_Pack(1, PyLong_FromLong(depth - 1));
        py_result = PyObject_CallObject(callback_func, callback_args);
        Py_DECREF(callback_args);
    }
    
    if (!py_result) {
        // 콜백 실패 시 C 계산 수행
        long result = depth * (depth + 1) / 2;
        py_result = PyLong_FromLong(result);
    }
    
    return py_result;
}

/* GIL 성능 비교 데모 */
static PyObject* benchmark_gil_impact(PyObject* self, PyObject* args) {
    long iterations;
    int use_gil_release;
    
    if (!PyArg_ParseTuple(args, "lp", &iterations, &use_gil_release)) {
        return NULL;
    }
    
    PyObject* result_list = PyList_New(2);
    if (!result_list) return NULL;
    
    // GIL 유지 테스트
    clock_t start_with_gil = clock();
    
    for (long i = 0; i < iterations; i++) {
        // 간단한 계산 (GIL 유지)
        volatile double x = 0.0;
        for (int j = 0; j < 1000; j++) {
            x += 1.0 / (j + 1.0);
        }
    }
    
    clock_t end_with_gil = clock();
    double time_with_gil = (double)(end_with_gil - start_with_gil) / CLOCKS_PER_SEC;
    
    PyList_SetItem(result_list, 0, PyFloat_FromDouble(time_with_gil));
    
    // GIL 해제 테스트
    clock_t start_without_gil = clock();
    
    if (use_gil_release) {
        Py_BEGIN_ALLOW_THREADS
        
        for (long i = 0; i < iterations; i++) {
            // 동일한 계산 (GIL 해제)
            volatile double x = 0.0;
            for (int j = 0; j < 1000; j++) {
                x += 1.0 / (j + 1.0);
            }
        }
        
        Py_END_ALLOW_THREADS
    } else {
        // GIL 해제 없이 동일 계산
        for (long i = 0; i < iterations; i++) {
            volatile double x = 0.0;
            for (int j = 0; j < 1000; j++) {
                x += 1.0 / (j + 1.0);
            }
        }
    }
    
    clock_t end_without_gil = clock();
    double time_without_gil = (double)(end_without_gil - start_without_gil) / CLOCKS_PER_SEC;
    
    PyList_SetItem(result_list, 1, PyFloat_FromDouble(time_without_gil));
    
    return result_list;
}

/* 모듈 메서드 정의 */
static PyMethodDef GILMethods[] = {
    {"cpu_intensive_task", cpu_intensive_task, METH_VARARGS,
     "CPU 집약적인 작업 수행"},
    {"io_bound_task_with_gil_release", io_bound_task_with_gil_release, METH_VARARGS,
     "I/O 바운드 작업 (GIL 해제 포함)"},
    {"blocking_system_call", blocking_system_call, METH_VARARGS,
     "블로킹 시스템 호출 (자동 GIL 관리)"},
    {"reentrant_computation", reentrant_computation, METH_VARARGS,
     "재진입 가능한 계산"},
    {"benchmark_gil_impact", benchmark_gil_impact, METH_VARARGS,
     "GIL 영향 벤치마크"},
    {NULL, NULL, 0, NULL}
};

/* 모듈 정의 */
static struct PyModuleDef gilmodule = {
    PyModuleDef_HEAD_INIT,
    "gil_management",
    "GIL 관리 C 확장 모듈",
    -1,
    GILMethods
};

/* 모듈 초기화 */
PyMODINIT_FUNC PyInit_gil_management(void) {
    PyObject* m;
    
    // ThreadSafeCounter 타입 등록
    static PyTypeObject ThreadSafeCounterType = {
        PyVarObject_HEAD_INIT(NULL, 0)
        .tp_name = "gil_management.ThreadSafeCounter",
        .tp_doc = "Thread-safe counter with fine-grained GIL control",
        .tp_basicsize = sizeof(ThreadSafeCounter),
        .tp_itemsize = 0,
        .tp_flags = Py_TPFLAGS_DEFAULT,
        .tp_new = ThreadSafeCounter_new,
        .tp_init = (initproc)ThreadSafeCounter_init,
        .tp_dealloc = (destructor)ThreadSafeCounter_dealloc,
        .tp_methods = NULL,
    };
    
    // 메서드 테이블 추가
    static PyMethodDef ThreadSafeCounter_methods[] = {
        {"increment", (PyCFunction)ThreadSafeCounter_increment, METH_VARARGS,
         "스레드 안전한 증가 연산"},
        {NULL, NULL, 0, NULL}
    };
    
    ThreadSafeCounterType.tp_methods = ThreadSafeCounter_methods;
    
    // 모듈 생성
    m = PyModule_Create(&gilmodule);
    if (m == NULL) return NULL;
    
    // 타입 등록
    if (PyType_Ready(&ThreadSafeCounterType) < 0) return NULL;
    Py_INCREF(&ThreadSafeCounterType);
    if (PyModule_AddObject(m, "ThreadSafeCounter", 
                          (PyObject*)&ThreadSafeCounterType) < 0) {
        Py_DECREF(&ThreadSafeCounterType);
        Py_DECREF(m);
        return NULL;
    }
    
    return m;
}
```

### Python 테스트 코드

```python
# test_gil_management.py
"""GIL 관리 C 확장 테스트"""

import gil_management
import time
import threading
import concurrent.futures

def test_cpu_intensive():
    """CPU 집약적 작업 테스트"""
    print("CPU 집약적 작업 테스트...")
    start = time.time()
    result = gil_management.cpu_intensive_task(10000000)
    elapsed = time.time() - start
    print(f"결과: {result}, 시간: {elapsed:.2f}초")

def test_io_bound():
    """I/O 바운드 작업 테스트"""
    print("\nI/O 바운드 작업 테스트...")
    start = time.time()
    
    # 여러 스레드에서 동시 실행
    def worker(filename):
        return gil_management.io_bound_task_with_gil_release(filename)
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        futures = [executor.submit(worker, f"test_{i}.txt") for i in range(3)]
        results = [f.result() for f in concurrent.futures.as_completed(futures)]
    
    elapsed = time.time() - start
    print(f"결과: {results}, 시간: {elapsed:.2f}초")

def test_blocking_call():
    """블로킹 호출 테스트"""
    print("\n블로킹 시스템 호출 테스트...")
    
    # 여러 스레드에서 실행
    results = []
    
    def worker(duration):
        return gil_management.blocking_system_call(duration)
    
    start = time.time()
    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
        futures = [executor.submit(worker, i + 1) for i in range(3)]
        results = [f.result() for f in concurrent.futures.as_completed(futures)]
    
    elapsed = time.time() - start
    print(f"결과: {results}, 총 시간: {elapsed:.2f}초")

def test_thread_safe_counter():
    """스레드 안전 카운터 테스트"""
    print("\n스레드 안전 카운터 테스트...")
    
    counter = gil_management.ThreadSafeCounter(initial_value=0)
    
    def increment_worker(counter, iterations):
        for _ in range(iterations):
            counter.increment(1)
    
    # 여러 스레드에서 동시 증가
    threads = []
    for _ in range(5):
        thread = threading.Thread(target=increment_worker, args=(counter, 10000))
        threads.append(thread)
        thread.start()
    
    for thread in threads:
        thread.join()
    
    final_value = counter.increment(0)  # 현재 값 읽기
    print(f"기대값: 50000, 실제값: {final_value}")

def test_gil_benchmark():
    """GIL 성능 벤치마크"""
    print("\nGIL 성능 벤치마크...")
    
    iterations = 1000000
    
    # GIL 유지
    print("GIL 유지 상태 테스트...")
    times_with_gil = []
    for _ in range(3):
        result = gil_management.benchmark_gil_impact(iterations, False)
        times_with_gil.append(result[0])
    
    avg_with_gil = sum(times_with_gil) / len(times_with_gil)
    print(f"GIL 유지 평균 시간: {avg_with_gil:.3f}초")
    
    # GIL 해제
    print("\nGIL 해제 상태 테스트...")
    times_without_gil = []
    for _ in range(3):
        result = gil_management.benchmark_gil_impact(iterations, True)
        times_without_gil.append(result[1])
    
    avg_without_gil = sum(times_without_gil) / len(times_without_gil)
    print(f"GIL 해제 평균 시간: {avg_without_gil:.3f}초")
    
    print(f"\n성능 향상: {(avg_with_gil / avg_without_gil - 1) * 100:.1f}%")

def test_reentrant():
    """재진입 가능한 계산 테스트"""
    print("\n재진입 가능한 계산 테스트...")
    
    # Python 콜백 함수 정의
    def compute_callback(n):
        return n * 10
    
    # 전역 네임스페이스에 추가
    import __main__
    __main__.compute_callback = compute_callback
    
    result = gil_management.reentrant_computation(5)
    print(f"재귀 계산 결과: {result}")

if __name__ == "__main__":
    print("=== C 확장에서 GIL 관리 테스트 ===")
    
    test_cpu_intensive()
    test_io_bound()
    test_blocking_call()
    test_thread_safe_counter()
    test_gil_benchmark()
    test_reentrant()
    
    print("\n모든 테스트 완료!")
```

## C와 파이썬에서의 스레드 믹싱

### 하이브리드 스레딩 아키텍처 구현

```c
/* mixed_threading.c - C와 Python 스레드 혼합 사용 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <semaphore.h>

/* 공유 데이터 구조체 */
typedef struct {
    long value;
    pthread_mutex_t mutex;
    sem_t semaphore;
    int shutdown_requested;
} SharedData;

/* Python 콜백을 위한 구조체 */
typedef struct {
    PyObject* callback;
    SharedData* shared_data;
    int thread_id;
} CallbackData;

/* Python GIL 상태 관리 */
static pthread_key_t gil_state_key;

/* C 네이티브 스레드 함수 */
static void* native_thread_function(void* arg) {
    CallbackData* data = (CallbackData*)arg;
    SharedData* shared = data->shared_data;
    
    printf("C 스레드 %d 시작\n", data->thread_id);
    
    for (int i = 0; i < 5; i++) {
        // C 스레드 작업
        pthread_mutex_lock(&shared->mutex);
        shared->value++;
        long current_value = shared->value;
        pthread_mutex_unlock(&shared->mutex);
        
        printf("C 스레드 %d: 공유 값 = %ld\n", data->thread_id, current_value);
        
        // Python 콜백 호출을 위한 GIL 획득
        PyGILState_STATE gstate = PyGILState_Ensure();
        
        // Python 콜백 호출
        if (data->callback && PyCallable_Check(data->callback)) {
            PyObject* args = PyTuple_Pack(2, 
                PyLong_FromLong(data->thread_id),
                PyLong_FromLong(current_value)
            );
            PyObject* result = PyObject_CallObject(data->callback, args);
            
            if (result) {
                Py_DECREF(result);
            } else {
                PyErr_Print();
            }
            
            Py_DECREF(args);
        }
        
        PyGILState_Release(gstate);
        
        // 세마포어 대기 (동기화)
        sem_wait(&shared->semaphore);
        
        if (shared->shutdown_requested) {
            break;
        }
        
        sleep(1);
    }
    
    printf("C 스레드 %d 종료\n", data->thread_id);
    
    free(data);
    return NULL;
}

/* Python에서 C 스레드 생성 */
static PyObject* create_native_thread(PyObject* self, PyObject* args) {
    PyObject* callback;
    int thread_id;
    
    if (!PyArg_ParseTuple(args, "Oi", &callback, &thread_id)) {
        return NULL;
    }
    
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "첫 번째 인자는 콜러블이어야 합니다");
        return NULL;
    }
    
    // 공유 데이터 가져오기
    SharedData* shared = (SharedData*)pthread_getspecific(gil_state_key);
    if (!shared) {
        PyErr_SetString(PyExc_RuntimeError, "공유 데이터 초기화되지 않음");
        return NULL;
    }
    
    // 콜백 데이터 준비
    CallbackData* cb_data = malloc(sizeof(CallbackData));
    if (!cb_data) {
        PyErr_NoMemory();
        return NULL;
    }
    
    cb_data->callback = callback;
    Py_INCREF(callback);  // 참조 카운트 증가
    cb_data->shared_data = shared;
    cb_data->thread_id = thread_id;
    
    // C 스레드 생성
    pthread_t thread;
    if (pthread_create(&thread, NULL, native_thread_function, cb_data) != 0) {
        free(cb_data);
        PyErr_SetString(PyExc_RuntimeError, "스레드 생성 실패");
        return NULL;
    }
    
    // 스레드 분리 (종료 자동 정리)
    pthread_detach(thread);
    
    Py_RETURN_NONE;
}

/* Python 스레드에서 C 함수 호출 */
static PyObject* call_from_python_thread(PyObject* self, PyObject* args) {
    int operation;
    long value;
    
    if (!PyArg_ParseTuple(args, "il", &operation, &value)) {
        return NULL;
    }
    
    SharedData* shared = (SharedData*)pthread_getspecific(gil_state_key);
    if (!shared) {
        PyErr_SetString(PyExc_RuntimeError, "공유 데이터 초기화되지 않음");
        return NULL;
    }
    
    long result = 0;
    
    // 연산 수행
    pthread_mutex_lock(&shared->mutex);
    
    switch (operation) {
        case 1:  // 더하기
            shared->value += value;
            result = shared->value;
            break;
        case 2:  // 빼기
            shared->value -= value;
            result = shared->value;
            break;
        case 3:  // 곱하기
            shared->value *= value;
            result = shared->value;
            break;
        default:
            result = shared->value;
            break;
    }
    
    pthread_mutex_unlock(&shared->mutex);
    
    // 세마포어 신호 (C 스레드 깨우기)
    sem_post(&shared->semaphore);
    
    return PyLong_FromLong(result);
}

/* 교착 상태 방지를 위한 타임아웃 뮤텍스 */
static PyObject* try_lock_with_timeout(PyObject* self, PyObject* args) {
    int timeout_ms;
    
    if (!PyArg_ParseTuple(args, "i", &timeout_ms)) {
        return NULL;
    }
    
    SharedData* shared = (SharedData*)pthread_getspecific(gil_state_key);
    if (!shared) {
        PyErr_SetString(PyExc_RuntimeError, "공유 데이터 초기화되지 않음");
        return NULL;
    }
    
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    ts.tv_nsec += (timeout_ms % 1000) * 1000000;
    ts.tv_sec += timeout_ms / 1000;
    
    int lock_result = pthread_mutex_timedlock(&shared->mutex, &ts);
    
    if (lock_result == 0) {
        // 락 성공
        long value = shared->value;
        pthread_mutex_unlock(&shared->mutex);
        return PyLong_FromLong(value);
    } else {
        // 타임아웃
        PyErr_SetString(PyExc_TimeoutError, "락 획득 타임아웃");
        return NULL;
    }
}

/* 스레드 풀 관리자 */
typedef struct {
    pthread_t* threads;
    int num_threads;
    sem_t work_semaphore;
    pthread_mutex_t work_mutex;
    void** work_queue;
    int queue_size;
    int queue_head;
    int queue_tail;
} ThreadPool;

static ThreadPool* thread_pool = NULL;

/* 스레드 풀 작업자 함수 */
static void* thread_pool_worker(void* arg) {
    ThreadPool* pool = (ThreadPool*)arg;
    
    while (1) {
        // 작업 대기
        sem_wait(&pool->work_semaphore);
        
        pthread_mutex_lock(&pool->work_mutex);
        
        if (pool->queue_head == pool->queue_tail) {
            // 종료 신호
            pthread_mutex_unlock(&pool->work_mutex);
            break;
        }
        
        // 작업 가져오기
        void* work_item = pool->work_queue[pool->queue_head];
        pool->queue_head = (pool->queue_head + 1) % pool->queue_size;
        
        pthread_mutex_unlock(&pool->work_mutex);
        
        // 작업 실행 (Python 콜백)
        if (work_item) {
            CallbackData* cb_data = (CallbackData*)work_item;
            
            PyGILState_STATE gstate = PyGILState_Ensure();
            
            if (cb_data->callback && PyCallable_Check(cb_data->callback)) {
                PyObject* args = PyTuple_Pack(1, PyLong_FromLong(cb_data->thread_id));
                PyObject* result = PyObject_CallObject(cb_data->callback, args);
                
                if (result) {
                    Py_DECREF(result);
                }
                
                Py_DECREF(args);
            }
            
            PyGILState_Release(gstate);
            
            free(cb_data);
        }
    }
    
    return NULL;
}

/* 스레드 풀 초기화 */
static PyObject* initialize_thread_pool(PyObject* self, PyObject* args) {
    int num_threads;
    
    if (!PyArg_ParseTuple(args, "i", &num_threads)) {
        return NULL;
    }
    
    if (thread_pool) {
        PyErr_SetString(PyExc_RuntimeError, "스레드 풀 이미 초기화됨");
        return NULL;
    }
    
    thread_pool = malloc(sizeof(ThreadPool));
    if (!thread_pool) {
        PyErr_NoMemory();
        return NULL;
    }
    
    thread_pool->num_threads = num_threads;
    thread_pool->threads = malloc(sizeof(pthread_t) * num_threads);
    thread_pool->queue_size = 100;
    thread_pool->work_queue = malloc(sizeof(void*) * thread_pool->queue_size);
    thread_pool->queue_head = 0;
    thread_pool->queue_tail = 0;
    
    sem_init(&thread_pool->work_semaphore, 0, 0);
    pthread_mutex_init(&thread_pool->work_mutex, NULL);
    
    // 작업자 스레드 생성
    for (int i = 0; i < num_threads; i++) {
        pthread_create(&thread_pool->threads[i], NULL, 
                      thread_pool_worker, thread_pool);
    }
    
    Py_RETURN_NONE;
}

/* 스레드 풀에 작업 제출 */
static PyObject* submit_to_thread_pool(PyObject* self, PyObject* args) {
    PyObject* callback;
    int task_id;
    
    if (!PyArg_ParseTuple(args, "Oi", &callback, &task_id)) {
        return NULL;
    }
    
    if (!thread_pool) {
        PyErr_SetString(PyExc_RuntimeError, "스레드 풀 초기화되지 않음");
        return NULL;
    }
    
    CallbackData* cb_data = malloc(sizeof(CallbackData));
    if (!cb_data) {
        PyErr_NoMemory();
        return NULL;
    }
    
    cb_data->callback = callback;
    Py_INCREF(callback);
    cb_data->thread_id = task_id;
    cb_data->shared_data = NULL;
    
    pthread_mutex_lock(&thread_pool->work_mutex);
    
    // 큐가 가득 찼는지 확인
    int next_tail = (thread_pool->queue_tail + 1) % thread_pool->queue_size;
    if (next_tail == thread_pool->queue_head) {
        pthread_mutex_unlock(&thread_pool->work_mutex);
        free(cb_data);
        PyErr_SetString(PyExc_RuntimeError, "작업 큐 가득 참");
        return NULL;
    }
    
    // 작업 큐에 추가
    thread_pool->work_queue[thread_pool->queue_tail] = cb_data;
    thread_pool->queue_tail = next_tail;
    
    pthread_mutex_unlock(&thread_pool->work_mutex);
    
    // 작업자 스레드에 신호
    sem_post(&thread_pool->work_semaphore);
    
    Py_RETURN_NONE;
}

/* 모듈 초기화 함수 */
static PyObject* initialize_mixed_threading(PyObject* self, PyObject* args) {
    // TLS 키 생성
    if (pthread_key_create(&gil_state_key, NULL) != 0) {
        PyErr_SetString(PyExc_RuntimeError, "TLS 키 생성 실패");
        return NULL;
    }
    
    // 공유 데이터 초기화
    SharedData* shared = malloc(sizeof(SharedData));
    if (!shared) {
        PyErr_NoMemory();
        return NULL;
    }
    
    shared->value = 0;
    shared->shutdown_requested = 0;
    pthread_mutex_init(&shared->mutex, NULL);
    sem_init(&shared->semaphore, 0, 0);
    
    // TLS에 저장
    pthread_setspecific(gil_state_key, shared);
    
    Py_RETURN_NONE;
}

/* 모듈 정리 함수 */
static PyObject* cleanup_mixed_threading(PyObject* self, PyObject* args) {
    // 공유 데이터 정리
    SharedData* shared = (SharedData*)pthread_getspecific(gil_state_key);
    if (shared) {
        shared->shutdown_requested = 1;
        
        // 모든 대기 중인 스레드 깨우기
        for (int i = 0; i < 10; i++) {
            sem_post(&shared->semaphore);
        }
        
        sleep(1);  // 스레드 종료 대기
        
        pthread_mutex_destroy(&shared->mutex);
        sem_destroy(&shared->semaphore);
        free(shared);
    }
    
    // 스레드 풀 정리
    if (thread_pool) {
        // 종료 신호
        for (int i = 0; i < thread_pool->num_threads; i++) {
            sem_post(&thread_pool->work_semaphore);
        }
        
        // 스레드 조인
        for (int i = 0; i < thread_pool->num_threads; i++) {
            pthread_join(thread_pool->threads[i], NULL);
        }
        
        free(thread_pool->threads);
        free(thread_pool->work_queue);
        sem_destroy(&thread_pool->work_semaphore);
        pthread_mutex_destroy(&thread_pool->work_mutex);
        free(thread_pool);
        thread_pool = NULL;
    }
    
    // TLS 키 삭제
    pthread_key_delete(gil_state_key);
    
    Py_RETURN_NONE;
}

/* 모듈 메서드 정의 */
static PyMethodDef MixedThreadingMethods[] = {
    {"initialize", initialize_mixed_threading, METH_VARARGS,
     "하이브리드 스레딩 시스템 초기화"},
    {"cleanup", cleanup_mixed_threading, METH_VARARGS,
     "하이브리드 스레딩 시스템 정리"},
    {"create_native_thread", create_native_thread, METH_VARARGS,
     "C 네이티브 스레드 생성"},
    {"call_from_python_thread", call_from_python_thread, METH_VARARGS,
     "Python 스레드에서 C 함수 호출"},
    {"try_lock_with_timeout", try_lock_with_timeout, METH_VARARGS,
     "타임아웃이 있는 락 시도"},
    {"initialize_thread_pool", initialize_thread_pool, METH_VARARGS,
     "스레드 풀 초기화"},
    {"submit_to_thread_pool", submit_to_thread_pool, METH_VARARGS,
     "스레드 풀에 작업 제출"},
    {NULL, NULL, 0, NULL}
};

/* 모듈 정의 */
static struct PyModuleDef mixedthreadingmodule = {
    PyModuleDef_HEAD_INIT,
    "mixed_threading",
    "C와 Python 하이브리드 스레딩 모듈",
    -1,
    MixedThreadingMethods
};

/* 모듈 초기화 */
PyMODINIT_FUNC PyInit_mixed_threading(void) {
    PyObject* m;
    
    m = PyModule_Create(&mixedthreadingmodule);
    if (m == NULL) return NULL;
    
    // 에러 타입 추가
    PyModule_AddObject(m, "TimeoutError", PyExc_TimeoutError);
    
    return m;
}
```

### Python 테스트 코드

```python
# test_mixed_threading.py
"""C와 Python 스레드 혼합 사용 테스트"""

import mixed_threading
import threading
import time
import queue

def python_callback(thread_id, value):
    """C 스레드에서 호출되는 Python 콜백"""
    print(f"Python 콜백: C 스레드 {thread_id}, 값 = {value}")
    return f"처리됨: {value}"

def thread_pool_callback(task_id):
    """스레드 풀 작업자 콜백"""
    print(f"스레드 풀 작업 {task_id} 시작")
    time.sleep(0.5)  # 작업 시뮬레이션
    print(f"스레드 풀 작업 {task_id} 완료")
    return task_id * 10

def test_basic_mixing():
    """기본 스레드 혼합 테스트"""
    print("=== 기본 스레드 혼합 테스트 ===")
    
    # 시스템 초기화
    mixed_threading.initialize()
    
    try:
        # Python 스레드에서 C 함수 호출
        def python_thread_worker(thread_id):
            for i in range(3):
                result = mixed_threading.call_from_python_thread(1, 10)
                print(f"Python 스레드 {thread_id}: 결과 = {result}")
                time.sleep(0.3)
        
        # 여러 Python 스레드 생성
        python_threads = []
        for i in range(3):
            thread = threading.Thread(target=python_thread_worker, args=(i,))
            python_threads.append(thread)
            thread.start()
        
        # C 네이티브 스레드 생성
        for i in range(2):
            mixed_threading.create_native_thread(python_callback, i + 100)
        
        # 모든 Python 스레드 종료 대기
        for thread in python_threads:
            thread.join()
        
        print("기본 테스트 완료, 3초 대기...")
        time.sleep(3)
        
    finally:
        mixed_threading.cleanup()

def test_thread_pool():
    """스레드 풀 테스트"""
    print("\n=== 스레드 풀 테스트 ===")
    
    mixed_threading.initialize()
    
    try:
        # 스레드 풀 초기화 (4개 작업자)
        mixed_threading.initialize_thread_pool(4)
        
        # 여러 작업 제출
        print("10개 작업 스레드 풀에 제출...")
        for i in range(10):
            mixed_threading.submit_to_thread_pool(thread_pool_callback, i)
        
        print("작업 제출 완료, 3초 대기...")
        time.sleep(3)
        
    finally:
        mixed_threading.cleanup()

def test_timeout_lock():
    """타임아웃 락 테스트"""
    print("\n=== 타임아웃 락 테스트 ===")
    
    mixed_threading.initialize()
    
    try:
        # 교착 상태 시나리오 시뮬레이션
        lock_acquired = threading.Event()
        
        def hold_lock():
            # 장시간 락 보유
            result = mixed_threading.call_from_python_thread(1, 1)
            print(f"락 보유 스레드: 결과 = {result}")
            lock_acquired.set()
            time.sleep(5)  # 장시간 락 보유
        
        def try_timeout_lock():
            lock_acquired.wait()  # 락이 획득될 때까지 대기
            time.sleep(0.5)  # 약간의 지연
            
            try:
                # 타임아웃 락 시도
                result = mixed_threading.try_lock_with_timeout(100)  # 100ms 타임아웃
                print(f"타임아웃 락 성공: {result}")
            except Exception as e:
                print(f"타임아웃 락 실패: {e}")
        
        # 스레드 실행
        holder = threading.Thread(target=hold_lock)
        tryer = threading.Thread(target=try_timeout_lock)
        
        holder.start()
        tryer.start()
        
        holder.join()
        tryer.join()
        
    finally:
        mixed_threading.cleanup()

def test_complex_scenario():
    """복합 시나리오 테스트"""
    print("\n=== 복합 시나리오 테스트 ===")
    
    mixed_threading.initialize()
    
    try:
        results_queue = queue.Queue()
        
        def complex_python_callback(thread_id, value):
            """복잡한 Python 콜백"""
            result = f"C{thread_id}-{value * 2}"
            results_queue.put(result)
            return result
        
        def python_complex_worker(worker_id):
            """복잡한 Python 워커"""
            for i in range(5):
                # 무작위 연산
                import random
                op = random.randint(1, 3)
                val = random.randint(1, 100)
                
                try:
                    result = mixed_threading.call_from_python_thread(op, val)
                    print(f"워커 {worker_id}: {op}({val}) = {result}")
                    time.sleep(random.uniform(0.1, 0.3))
                except Exception as e:
                    print(f"워커 {worker_id} 오류: {e}")
        
        # C 스레드 생성
        for i in range(3):
            mixed_threading.create_native_thread(complex_python_callback, 200 + i)
        
        # Python 스레드 생성
        python_threads = []
        for i in range(4):
            thread = threading.Thread(target=python_complex_worker, args=(i,))
            python_threads.append(thread)
            thread.start()
        
        # 결과 수집
        collected_results = []
        start_time = time.time()
        
        while time.time() - start_time < 10:  # 10초 동안 실행
            try:
                result = results_queue.get(timeout=1)
                collected_results.append(result)
                print(f"수집된 결과: {result}")
            except queue.Empty:
                continue
        
        # Python 스레드 종료 대기
        for thread in python_threads:
            thread.join(timeout=1)
        
        print(f"\n총 {len(collected_results)}개 결과 수집됨")
        print("복합 시나리오 테스트 완료")
        
    finally:
        mixed_threading.cleanup()

def performance_benchmark():
    """성능 벤치마크"""
    print("\n=== 성능 벤치마크 ===")
    
    mixed_threading.initialize()
    
    try:
        import concurrent.futures
        
        def benchmark_task(task_id):
            """벤치마크 작업"""
            start = time.time()
            
            # C 함수 호출
            for _ in range(1000):
                mixed_threading.call_from_python_thread(1, 1)
            
            elapsed = time.time() - start
            return elapsed
        
        # 스레드 수별 성능 측정
        for num_threads in [1, 2, 4, 8]:
            print(f"\n{num_threads}개 스레드 테스트...")
            
            start_total = time.time()
            
            with concurrent.futures.ThreadPoolExecutor(max_workers=num_threads) as executor:
                futures = [executor.submit(benchmark_task, i) for i in range(num_threads)]
                results = [f.result() for f in concurrent.futures.as_completed(futures)]
            
            total_time = time.time() - start_total
            avg_time = sum(results) / len(results)
            
            print(f"  총 시간: {total_time:.3f}초")
            print(f"  평균 시간: {avg_time:.3f}초")
            print(f"  처리량: {num_threads * 1000 / total_time:.1f} 작업/초")
        
    finally:
        mixed_threading.cleanup()

if __name__ == "__main__":
    print("=== C와 Python 스레드 혼합 테스트 ===")
    
    test_basic_mixing()
    test_thread_pool()
    test_timeout_lock()
    test_complex_scenario()
    performance_benchmark()
    
    print("\n모든 테스트 완료!")
```

## SWIG로 C 코드 감싸기

### 자동화된 인터페이스 생성과 바인딩

```c
/* matrix_operations.c - SWIG로 래핑할 C 라이브러리 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/* 행렬 구조체 */
typedef struct {
    int rows;
    int cols;
    double* data;
} Matrix;

/* 행렬 생성 */
Matrix* matrix_create(int rows, int cols) {
    Matrix* mat = (Matrix*)malloc(sizeof(Matrix));
    if (!mat) return NULL;
    
    mat->rows = rows;
    mat->cols = cols;
    mat->data = (double*)malloc(rows * cols * sizeof(double));
    
    if (!mat->data) {
        free(mat);
        return NULL;
    }
    
    // 0으로 초기화
    for (int i = 0; i < rows * cols; i++) {
        mat->data[i] = 0.0;
    }
    
    return mat;
}

/* 행렬 해제 */
void matrix_free(Matrix* mat) {
    if (mat) {
        if (mat->data) {
            free(mat->data);
        }
        free(mat);
    }
}

/* 행렬 값 설정 */
void matrix_set(Matrix* mat, int row, int col, double value) {
    if (row >= 0 && row < mat->rows && col >= 0 && col < mat->cols) {
        mat->data[row * mat->cols + col] = value;
    }
}

/* 행렬 값 가져오기 */
double matrix_get(const Matrix* mat, int row, int col) {
    if (row >= 0 && row < mat->rows && col >= 0 && col < mat->cols) {
        return mat->data[row * mat->cols + col];
    }
    return 0.0;
}

/* 행렬 덧셈 */
Matrix* matrix_add(const Matrix* a, const Matrix* b) {
    if (a->rows != b->rows || a->cols != b->cols) {
        return NULL;
    }
    
    Matrix* result = matrix_create(a->rows, a->cols);
    if (!result) return NULL;
    
    for (int i = 0; i < a->rows * a->cols; i++) {
        result->data[i] = a->data[i] + b->data[i];
    }
    
    return result;
}

/* 행렬 곱셈 */
Matrix* matrix_multiply(const Matrix* a, const Matrix* b) {
    if (a->cols != b->rows) {
        return NULL;
    }
    
    Matrix* result = matrix_create(a->rows, b->cols);
    if (!result) return NULL;
    
    for (int i = 0; i < a->rows; i++) {
        for (int j = 0; j < b->cols; j++) {
            double sum = 0.0;
            for (int k = 0; k < a->cols; k++) {
                sum += matrix_get(a, i, k) * matrix_get(b, k, j);
            }
            matrix_set(result, i, j, sum);
        }
    }
    
    return result;
}

/* 행렬 전치 */
Matrix* matrix_transpose(const Matrix* mat) {
    Matrix* result = matrix_create(mat->cols, mat->rows);
    if (!result) return NULL;
    
    for (int i = 0; i < mat->rows; i++) {
        for (int j = 0; j < mat->cols; j++) {
            matrix_set(result, j, i, matrix_get(mat, i, j));
        }
    }
    
    return result;
}

/* 행렬 행렬식 (2x2, 3x3만 지원) */
double matrix_determinant(const Matrix* mat) {
    if (mat->rows != mat->cols) {
        return 0.0;
    }
    
    if (mat->rows == 2) {
        return matrix_get(mat, 0, 0) * matrix_get(mat, 1, 1) - 
               matrix_get(mat, 0, 1) * matrix_get(mat, 1, 0);
    }
    else if (mat->rows == 3) {
        double a = matrix_get(mat, 0, 0);
        double b = matrix_get(mat, 0, 1);
        double c = matrix_get(mat, 0, 2);
        double d = matrix_get(mat, 1, 0);
        double e = matrix_get(mat, 1, 1);
        double f = matrix_get(mat, 1, 2);
        double g = matrix_get(mat, 2, 0);
        double h = matrix_get(mat, 2, 1);
        double i = matrix_get(mat, 2, 2);
        
        return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
    }
    
    return 0.0;
}

/* 행렬 출력 (디버깅용) */
void matrix_print(const Matrix* mat) {
    printf("Matrix %dx%d:\n", mat->rows, mat->cols);
    for (int i = 0; i < mat->rows; i++) {
        printf("  ");
        for (int j = 0; j < mat->cols; j++) {
            printf("%8.3f ", matrix_get(mat, i, j));
        }
        printf("\n");
    }
}

/* 벡터 내적 (1D 행렬로 처리) */
double vector_dot_product(const Matrix* a, const Matrix* b) {
    if (a->cols != 1 || b->cols != 1 || a->rows != b->rows) {
        return 0.0;
    }
    
    double result = 0.0;
    for (int i = 0; i < a->rows; i++) {
        result += matrix_get(a, i, 0) * matrix_get(b, i, 0);
    }
    
    return result;
}

/* 행렬 스칼라 곱 */
Matrix* matrix_scale(const Matrix* mat, double scalar) {
    Matrix* result = matrix_create(mat->rows, mat->cols);
    if (!result) return NULL;
    
    for (int i = 0; i < mat->rows * mat->cols; i++) {
        result->data[i] = mat->data[i] * scalar;
    }
    
    return result;
}
```

### SWIG 인터페이스 파일

```swig
/* matrix.i - SWIG 인터페이스 파일 */

%module matrix_operations
%{
#include "matrix_operations.h"
%}

/* 메모리 관리 힌트 제공 */
%newobject matrix_create;
%newobject matrix_add;
%newobject matrix_multiply;
%newobject matrix_transpose;
%newobject matrix_scale;
%delobject matrix_free;

/* Python 특성 추가 */
%feature("python:slot", "tp_str", functype="reprfunc") Matrix::__str__;
%feature("python:slot", "tp_repr", functype="reprfunc") Matrix::__repr__;

/* 행렬 구조체 노출 */
typedef struct {
    int rows;
    int cols;
    double* data;
} Matrix;

/* 생성자/소멸자 */
Matrix* matrix_create(int rows, int cols);
void matrix_free(Matrix* mat);

/* 메서드 */
void matrix_set(Matrix* mat, int row, int col, double value);
double matrix_get(const Matrix* mat, int row, int col);
Matrix* matrix_add(const Matrix* a, const Matrix* b);
Matrix* matrix_multiply(const Matrix* a, const Matrix* b);
Matrix* matrix_transpose(const Matrix* mat);
double matrix_determinant(const Matrix* mat);
void matrix_print(const Matrix* mat);
double vector_dot_product(const Matrix* a, const Matrix* b);
Matrix* matrix_scale(const Matrix* mat, double scalar);

/* Python 확장 메서드 */
%extend Matrix {
    /* Python 특수 메서드 */
    const char* __str__() {
        static char buffer[256];
        snprintf(buffer, sizeof(buffer), "Matrix(%dx%d)", $self->rows, $self->cols);
        return buffer;
    }
    
    const char* __repr__() {
        static char buffer[256];
        snprintf(buffer, sizeof(buffer), "Matrix(rows=%d, cols=%d)", $self->rows, $self->cols);
        return buffer;
    }
    
    /* Python 시퀀스 프로토콜 지원 */
    PyObject* __getitem__(PyObject* indices) {
        if (PyTuple_Check(indices) && PyTuple_Size(indices) == 2) {
            PyObject* row_obj = PyTuple_GetItem(indices, 0);
            PyObject* col_obj = PyTuple_GetItem(indices, 1);
            
            if (PyLong_Check(row_obj) && PyLong_Check(col_obj)) {
                long row = PyLong_AsLong(row_obj);
                long col = PyLong_AsLong(col_obj);
                
                if (row >= 0 && row < $self->rows && col >= 0 && col < $self->cols) {
                    double value = matrix_get($self, (int)row, (int)col);
                    return PyFloat_FromDouble(value);
                }
            }
        }
        PyErr_SetString(PyExc_IndexError, "Invalid indices");
        return NULL;
    }
    
    int __setitem__(PyObject* indices, PyObject* value) {
        if (PyTuple_Check(indices) && PyTuple_Size(indices) == 2) {
            PyObject* row_obj = PyTuple_GetItem(indices, 0);
            PyObject* col_obj = PyTuple_GetItem(indices, 1);
            
            if (PyLong_Check(row_obj) && PyLong_Check(col_obj) && PyFloat_Check(value)) {
                long row = PyLong_AsLong(row_obj);
                long col = PyLong_AsLong(col_obj);
                double val = PyFloat_AsDouble(value);
                
                if (row >= 0 && row < $self->rows && col >= 0 && col < $self->cols) {
                    matrix_set($self, (int)row, (int)col, val);
                    return 0;
                }
            }
        }
        PyErr_SetString(PyExc_IndexError, "Invalid indices or value");
        return -1;
    }
    
    /* 행렬 속성 */
    int __len__() {
        return $self->rows;
    }
    
    /* NumPy 배열 변환 */
    PyObject* to_numpy() {
        npy_intp dims[2] = {$self->rows, $self->cols};
        PyObject* array = PyArray_SimpleNew(2, dims, NPY_DOUBLE);
        
        if (!array) return NULL;
        
        double* data = (double*)PyArray_DATA((PyArrayObject*)array);
        for (int i = 0; i < $self->rows * $self->cols; i++) {
            data[i] = $self->data[i];
        }
        
        return array;
    }
    
    /* NumPy 배열에서 생성 */
    static Matrix* from_numpy(PyObject* array) {
        if (!PyArray_Check(array)) {
            PyErr_SetString(PyExc_TypeError, "Expected numpy array");
            return NULL;
        }
        
        PyArrayObject* np_array = (PyArrayObject*)array;
        
        if (PyArray_NDIM(np_array) != 2) {
            PyErr_SetString(PyExc_ValueError, "Expected 2D array");
            return NULL;
        }
        
        if (PyArray_TYPE(np_array) != NPY_DOUBLE) {
            PyErr_SetString(PyExc_ValueError, "Expected double array");
            return NULL;
        }
        
        npy_intp* dims = PyArray_DIMS(np_array);
        int rows = (int)dims[0];
        int cols = (int)dims[1];
        
        Matrix* mat = matrix_create(rows, cols);
        if (!mat) return NULL;
        
        double* data = (double*)PyArray_DATA(np_array);
        for (int i = 0; i < rows * cols; i++) {
            mat->data[i] = data[i];
        }
        
        return mat;
    }
}

/* 타입 맵: Python 리스트 <-> Matrix 변환 */
%typemap(in) (double* data, int size) {
    if (!PyList_Check($input)) {
        PyErr_SetString(PyExc_TypeError, "Expected a list");
        return NULL;
    }
    
    $2 = PyList_Size($input);
    $1 = (double*)malloc($2 * sizeof(double));
    
    for (int i = 0; i < $2; i++) {
        PyObject* item = PyList_GetItem($input, i);
        if (!PyFloat_Check(item)) {
            free($1);
            PyErr_SetString(PyExc_TypeError, "List must contain floats");
            return NULL;
        }
        $1[i] = PyFloat_AsDouble(item);
    }
}

%typemap(freearg) (double* data, int size) {
    if ($1) free($1);
}

/* Python 예외 처리 */
%exception {
    $action
    if (PyErr_Occurred()) SWIG_fail;
}

/* 문서화 문자열 */
%feature("autodoc", "1");
%feature("docstring") matrix_create "Create a new matrix with given dimensions";
%feature("docstring") matrix_add "Add two matrices";
%feature("docstring") matrix_multiply "Multiply two matrices";
```

### 빌드 설정 파일

```python
# setup.py - SWIG 모듈 빌드 설정
from setuptools import setup, Extension
import numpy as np
import os

# NumPy 헤더 디렉토리
numpy_include = np.get_include()

# SWIG 확장 모듈 정의
matrix_module = Extension(
    '_matrix_operations',  # SWIG 생성 모듈 이름 (언더스코어 중요)
    sources=[
        'matrix_operations_wrap.c',  # SWIG 생성 파일
        'matrix_operations.c',       # 원본 C 소스
    ],
    include_dirs=[numpy_include, '.'],
    libraries=[],
    extra_compile_args=['-O3', '-Wall'],
    language='c',
)

setup(
    name='matrix_operations',
    version='1.0.0',
    author='Your Name',
    description='Matrix operations C extension with SWIG',
    ext_modules=[matrix_module],
    py_modules=['matrix_operations'],
    
    # NumPy 설치 필요 명시
    install_requires=['numpy>=1.20'],
    
    # 패키지 메타데이터
    classifiers=[
        'Development Status :: 4 - Beta',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: MIT License',
        'Programming Language :: Python :: 3',
        'Programming Language :: C',
        'Topic :: Software Development :: Libraries :: Python Modules',
    ],
)

# swig 명령어 실행을 위한 헬퍼 함수
def generate_swig_wrapper():
    """SWIG 래퍼 파일 생성"""
    import subprocess
    
    print("Generating SWIG wrapper...")
    
    # SWIG 명령어 실행
    swig_cmd = [
        'swig',
        '-python',           # Python 타겟
        '-py3',              # Python 3 지원
        '-modern',           # 현대적인 SWIG 기능
        '-keyword',          # 키워드 인자 지원
        '-I.',               # 현재 디렉토리 포함
        '-outdir', '.',      # 출력 디렉토리
        'matrix.i'           # 인터페이스 파일
    ]
    
    try:
        subprocess.run(swig_cmd, check=True)
        print("SWIG wrapper generated successfully")
    except subprocess.CalledProcessError as e:
        print(f"SWIG generation failed: {e}")
    except FileNotFoundError:
        print("SWIG not found. Please install SWIG first.")
        print("Ubuntu/Debian: sudo apt-get install swig")
        print("macOS: brew install swig")
        print("Windows: Download from http://www.swig.org/")

if __name__ == '__main__':
    # 스크립트 실행 시 SWIG 래퍼 생성
    generate_swig_wrapper()
```

### Python 테스트 코드

```python
# test_swig_matrix.py
"""SWIG로 생성된 행렬 연산 모듈 테스트"""

import matrix_operations
import numpy as np
import time

def test_basic_operations():
    """기본 행렬 연산 테스트"""
    print("=== 기본 행렬 연산 ===")
    
    # 행렬 생성
    mat1 = matrix_operations.matrix_create(3, 3)
    mat2 = matrix_operations.matrix_create(3, 3)
    
    # 값 설정
    for i in range(3):
        for j in range(3):
            matrix_operations.matrix_set(mat1, i, j, i * 3 + j + 1)
            matrix_operations.matrix_set(mat2, i, j, (i * 3 + j + 1) * 2)
    
    # 행렬 출력
    print("Matrix 1:")
    matrix_operations.matrix_print(mat1)
    
    print("\nMatrix 2:")
    matrix_operations.matrix_print(mat2)
    
    # 행렬 덧셈
    mat_sum = matrix_operations.matrix_add(mat1, mat2)
    print("\nSum:")
    matrix_operations.matrix_print(mat_sum)
    
    # 행렬 곱셈
    mat_mul = matrix_operations.matrix_multiply(mat1, mat2)
    print("\nProduct:")
    matrix_operations.matrix_print(mat_mul)
    
    # 행렬 전치
    mat_trans = matrix_operations.matrix_transpose(mat1)
    print("\nTranspose of Matrix 1:")
    matrix_operations.matrix_print(mat_trans)
    
    # 행렬식
    det = matrix_operations.matrix_determinant(mat1)
    print(f"\nDeterminant of Matrix 1: {det:.2f}")
    
    # 메모리 정리
    matrix_operations.matrix_free(mat1)
    matrix_operations.matrix_free(mat2)
    matrix_operations.matrix_free(mat_sum)
    matrix_operations.matrix_free(mat_mul)
    matrix_operations.matrix_free(mat_trans)

def test_python_features():
    """Python 특수 기능 테스트"""
    print("\n=== Python 특수 기능 ===")
    
    # 행렬 생성 및 문자열 표현
    mat = matrix_operations.matrix_create(2, 3)
    print(f"String representation: {mat}")
    print(f"Repr: {repr(mat)}")
    
    # 시퀀스 프로토콜 테스트
    print("\nSequence protocol test:")
    
    # 값 설정
    mat[0, 0] = 1.0
    mat[0, 1] = 2.0
    mat[0, 2] = 3.0
    mat[1, 0] = 4.0
    mat[1, 1] = 5.0
    mat[1, 2] = 6.0
    
    # 값 읽기
    print(f"mat[0, 0] = {mat[0, 0]}")
    print(f"mat[1, 2] = {mat[1, 2]}")
    
    # 길이
    print(f"len(mat) = {len(mat)}")  # 행 수 반환
    
    matrix_operations.matrix_free(mat)

def test_numpy_integration():
    """NumPy 통합 테스트"""
    print("\n=== NumPy 통합 ===")
    
    # NumPy 배열에서 행렬 생성
    np_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=np.float64)
    print(f"NumPy array:\n{np_array}")
    
    # NumPy -> Matrix 변환
    mat = matrix_operations.Matrix.from_numpy(np_array)
    print(f"\nConverted Matrix:")
    matrix_operations.matrix_print(mat)
    
    # Matrix -> NumPy 변환
    converted_array = mat.to_numpy()
    print(f"\nConverted back to NumPy:\n{converted_array}")
    
    # 변환 검증
    print(f"\nConversion valid: {np.allclose(np_array, converted_array)}")
    
    # NumPy와 연산 비교
    np_result = np_array @ np_array.T  # NumPy 행렬 곱
    mat_trans = matrix_operations.matrix_transpose(mat)
    mat_result = matrix_operations.matrix_multiply(mat, mat_trans)
    mat_result_np = mat_result.to_numpy()
    
    print(f"\nNumPy multiplication:\n{np_result}")
    print(f"\nC extension multiplication:\n{mat_result_np}")
    print(f"\nResults match: {np.allclose(np_result, mat_result_np)}")
    
    matrix_operations.matrix_free(mat)
    matrix_operations.matrix_free(mat_trans)
    matrix_operations.matrix_free(mat_result)

def test_performance():
    """성능 비교 테스트"""
    print("\n=== 성능 비교 ===")
    
    # 큰 행렬 생성
    size = 100
    print(f"Testing with {size}x{size} matrices")
    
    # NumPy 행렬 생성
    np_mat1 = np.random.randn(size, size)
    np_mat2 = np.random.randn(size, size)
    
    # NumPy 성능 측정
    start = time.time()
    np_result = np_mat1 @ np_mat2
    np_time = time.time() - start
    print(f"NumPy multiplication time: {np_time:.4f} seconds")
    
    # C 확장 행렬 생성
    c_mat1 = matrix_operations.Matrix.from_numpy(np_mat1)
    c_mat2 = matrix_operations.Matrix.from_numpy(np_mat2)
    
    # C 확장 성능 측정
    start = time.time()
    c_result = matrix_operations.matrix_multiply(c_mat1, c_mat2)
    c_time = time.time() - start
    print(f"C extension multiplication time: {c_time:.4f} seconds")
    
    # 결과 비교
    c_result_np = c_result.to_numpy()
    valid = np.allclose(np_result, c_result_np, rtol=1e-10)
    print(f"Results match: {valid}")
    print(f"Speedup: {c_time/np_time:.2f}x (NumPy is {'faster' if np_time < c_time else 'slower'})")
    
    # 정리
    matrix_operations.matrix_free(c_mat1)
    matrix_operations.matrix_free(c_mat2)
    matrix_operations.matrix_free(c_result)

def test_error_handling():
    """오류 처리 테스트"""
    print("\n=== 오류 처리 ===")
    
    # 잘못된 차원으로 행렬 생성
    try:
        mat = matrix_operations.matrix_create(-1, 5)
        if mat:
            print("Created matrix with invalid dimensions")
            matrix_operations.matrix_free(mat)
    except Exception as e:
        print(f"Expected error for invalid dimensions: {e}")
    
    # 차원 불일치로 행렬 덧셈
    mat1 = matrix_operations.matrix_create(2, 3)
    mat2 = matrix_operations.matrix_create(3, 2)
    
    try:
        result = matrix_operations.matrix_add(mat1, mat2)
        if result:
            print("Added matrices with mismatched dimensions")
            matrix_operations.matrix_free(result)
    except Exception as e:
        print(f"Expected error for dimension mismatch: {e}")
    
    # 잘못된 인덱스 접근
    mat = matrix_operations.matrix_create(3, 3)
    
    try:
        value = mat[10, 10]  # 범위를 벗어난 인덱스
        print(f"Accessed invalid index: {value}")
    except Exception as e:
        print(f"Expected index error: {type(e).__name__}")
    
    # NumPy 변환 오류
    try:
        # 잘못된 타입의 배열
        invalid_array = np.array([1, 2, 3])  # 1D 배열
        mat = matrix_operations.Matrix.from_numpy(invalid_array)
        if mat:
            print("Converted invalid array")
            matrix_operations.matrix_free(mat)
    except Exception as e:
        print(f"Expected conversion error: {type(e).__name__}: {e}")
    
    # 정리
    matrix_operations.matrix_free(mat1)
    matrix_operations.matrix_free(mat2)
    matrix_operations.matrix_free(mat)

def advanced_usage_example():
    """고급 사용 예제"""
    print("\n=== 고급 사용 예제 ===")
    
    # 선형 회귀 계산 (정규 방정식)
    print("Linear regression using normal equation")
    
    # 훈련 데이터 생성
    n_samples = 100
    n_features = 3
    
    # 특성 행렬 X (n_samples x n_features)
    X_np = np.random.randn(n_samples, n_features)
    X_np[:, 0] = 1.0  # bias 항 추가
    
    # 실제 가중치
    true_weights = np.array([2.0, -1.5, 0.5, 1.0])  # bias + 3 features
    
    # 타겟 값 생성 (노이즈 추가)
    y_np = X_np @ true_weights[1:] + true_weights[0] + np.random.randn(n_samples) * 0.1
    
    # NumPy로 계산
    start = time.time()
    np_weights = np.linalg.inv(X_np.T @ X_np) @ X_np.T @ y_np
    np_time = time.time() - start
    
    # C 확장으로 계산
    X = matrix_operations.Matrix.from_numpy(X_np)
    y = matrix_operations.Matrix.from_numpy(y_np.reshape(-1, 1))
    
    start = time.time()
    
    # X^T * X 계산
    XT = matrix_operations.matrix_transpose(X)
    XTX = matrix_operations.matrix_multiply(XT, X)
    
    # (X^T * X)^-1 계산 (역행렬 - 간단한 구현)
    XTX_np = XTX.to_numpy()
    XTX_inv_np = np.linalg.inv(XTX_np)
    XTX_inv = matrix_operations.Matrix.from_numpy(XTX_inv_np)
    
    # X^T * y 계산
    XTy = matrix_operations.matrix_multiply(XT, y)
    
    # 최종 가중치 계산
    c_weights_mat = matrix_operations.matrix_multiply(XTX_inv, XTy)
    c_weights = c_weights_mat.to_numpy().flatten()
    c_time = time.time() - start
    
    print(f"True weights: {true_weights}")
    print(f"NumPy weights: {np_weights}")
    print(f"C extension weights: {c_weights}")
    print(f"\nNumPy time: {np_time:.6f}s")
    print(f"C extension time: {c_time:.6f}s")
    print(f"Speed ratio: {c_time/np_time:.2f}x")
    
    # 정리
    matrix_operations.matrix_free(X)
    matrix_operations.matrix_free(y)
    matrix_operations.matrix_free(XT)
    matrix_operations.matrix_free(XTX)
    matrix_operations.matrix_free(XTX_inv)
    matrix_operations.matrix_free(XTy)
    matrix_operations.matrix_free(c_weights_mat)

if __name__ == "__main__":
    print("=== SWIG로 생성된 행렬 연산 모듈 테스트 ===\n")
    
    test_basic_operations()
    test_python_features()
    test_numpy_integration()
    test_performance()
    test_error_handling()
    advanced_usage_example()
    
    print("\n모든 테스트 완료!")
```

## 결론

파이썬과 C/C++의 통합은 성능 최적화와 기존 코드 재사용을 위한 강력한 접근 방식입니다. 효과적인 통합을 위한 핵심 원칙은 다음과 같습니다:

1. **C에서 파이썬 호출**: Python C API를 사용하여 파이썬 인터프리터를 C 애플리케이션에 임베딩하고, 두 언어 간 데이터 변환을 효율적으로 관리해야 합니다.

2. **GIL 관리 전략**: C 확장에서 적절한 GIL 해제 시점을 판단하여 I/O 바운드 작업과 블로킹 호출 시 다른 파이썬 스레드가 실행될 수 있도록 해야 합니다. `Py_BEGIN_ALLOW_THREADS`와 `Py_END_ALLOW_THREADS` 매크로를 활용하여 블로킹 구간을 정확히 감싸야 합니다.

3. **하이브리드 스레딩**: C 네이티브 스레드와 파이썬 스레드를 혼합 사용할 때는 GIL 상태 관리, 스레드 안전성, 교착 상태 방지에 특히 주의해야 합니다. `PyGILState_Ensure()`와 `PyGILState_Release()`를 사용하여 C 스레드에서 파이썬 객체를 안전하게 접근해야 합니다.

4. **자동화된 인터페이스 생성**: SWIG, Cython, ctypes 등 도구를 활용하여 C 코드를 파이썬에서 사용하기 쉽게 래핑할 수 있습니다. SWIG는 복잡한 C 코드를 자동으로 파이썬 모듈로 변환하며, 타입 맵과 확장 메서드를 통해 자연스러운 파이썬 인터페이스를 제공할 수 있습니다.

실제 프로덕션 환경에서는 다음과 같은 추가 고려사항이 필요합니다:
- **메모리 관리**: C와 파이썬 사이의 참조 카운트 관리, 메모리 누수 방지
- **예외 처리**: C 코드에서 발생한 오류를 파이썬 예외로 변환
- **버전 호환성**: 파이썬 버전과 C 확장의 호환성 유지
- **플랫폼 이식성**: 다양한 운영체제와 아키텍처에서의 동작 보장
- **성능 프로파일링**: 병목 현상 식별과 최적화
- **디버깅 도구**: gdb, lldb와 파이썬 디버거의 통합 사용

이러한 기술들을 적절히 조합하면 파이썬의 생산성과 C의 성능을 동시에 누릴 수 있는 강력한 애플리케이션을 구축할 수 있습니다. 특히 과학 계산, 머신러닝, 고성능 서버, 임베디드 시스템 통합 등 다양한 분야에서 이러한 하이브리드 접근 방식이 효과적으로 활용됩니다.