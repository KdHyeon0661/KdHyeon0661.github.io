---
layout: post
title: AWS - KMS
date: 2025-08-03 20:20:23 +0900
category: AWS
---
# 🔐 AWS KMS를 활용한 데이터 암호화 완전 가이드

AWS KMS(Key Management Service)는 **암호화 키의 생성·관리·사용을 중앙에서 안전하게 제공**하는 서비스입니다. 이 문서는 KMS의 핵심 개념부터 실전 적용(서버사이드, 클라이언트사이드, Envelope Encryption), 운영·보안 모범 사례, 예제 코드까지 자세히 정리합니다.

---

## 목차
1. KMS 개요 — 핵심 개념  
2. 암호화 방식 요약 (SSE, client-side, envelope)  
3. KMS 주요 구성 요소와 키 유형  
4. 기본 워크플로우: 데이터 암호화/복호화(Envelope)  
5. 서비스별 연계 사용 예 (S3, EBS, RDS, Lambda 등)  
6. 실습 예제
   - S3 SSE-KMS 설정 (CLI)
   - 클라이언트 사이드(Envelope) 암호화/복호화 — Python(boto3) 예제
   - KMS로 비밀(환경변수) 암호화 (CLI)
7. 권한, 키 정책, Grants, 암호화 컨텍스트  
8. 키 관리(회전·삭제·복제)와 운영 팁  
9. 보안·감사·비용 고려사항  
10. 체크리스트(베스트 프랙티스)
11. 자주 발생하는 오류와 해결 방법

---

# 1. KMS 개요 — 핵심 개념

- **목적**: 애플리케이션이나 AWS 서비스가 데이터를 암호화/복호화할 때 사용하는 **중앙 키 관리** 제공.  
- **이점**: 키의 생성·보호·사용 기록(CloudTrail)·권한 통제·회전 관리 등을 통합 제공.
- **사용 시나리오**: S3 객체 암호화(SSE-KMS), EBS 암호화, RDS 암호화, Lambda 환경 변수 암호화, 애플리케이션의 클라이언트 사이드 암호화 등.

---

# 2. 암호화 방식 요약

- **Server-Side Encryption (SSE)**  
  - **SSE-S3**: S3가 관리하는 키로 암호화(사용자 제어 불가).  
  - **SSE-KMS**: KMS의 CMK로 S3가 객체를 암호화. **키 사용 권한**을 제어할 수 있음.  
  - **SSE-C**: 고객이 제공한 키로 S3가 암호화(복잡성 높음).

- **Client-Side Encryption (CSE)**  
  - 애플리케이션이 로컬에서 데이터를 암호화하고, 암호화된 바이트를 S3에 업로드. KMS는 **데이터 키**(Data Key)를 발급·암호화(즉, Envelope)를 담당.

- **Envelope Encryption (권장 패턴)**  
  - KMS에서 **데이터 키(대칭 키)**를 생성(GenerateDataKey) → 애플리케이션이 **데이터 키(평문)**로 데이터 암호화 → 평문 데이터키는 메모리에서 폐기하고, **암호화된 데이터 키**(CiphertextBlob)를 함께 저장. 복호화 시 KMS `Decrypt`로 복호화된 평문 데이터 키를 받아 데이터 복원.

---

# 3. KMS 주요 구성 요소와 키 유형

- **CMK (Customer Master Key)**: KMS에서 관리하는 키의 논리 단위. 두 종류:
  - **Customer-managed CMK**: 사용자가 생성하고 정책/회전을 제어.
  - **AWS-managed CMK**: AWS 서비스가 생성·관리. 기본적인 서비스 통합에 사용.
  - **AWS-owned KMS keys**: 완전히 AWS가 소유/관리(사용자 노출 없음).

- **키 유형**
  - **대칭(Symmetric)**: `Encrypt`/`Decrypt`, `GenerateDataKey` 등. 대부분의 데이터 암호화에 권장.
  - **비대칭(Asymmetric)**: `Sign/Verify`, `Encrypt/Decrypt` 용도 (RSA, ECC). 주로 서명/검증, 암호화에서 키 노출이 불가한 시나리오.

- **Custom Key Store**  
  - CloudHSM 기반 키 저장소로, 하드웨어 보안 모듈(HSM)에서 키를 관리해야 하는 규제 대응 시 사용.

- **Multi-Region CMK**  
  - 여러 리전에 걸쳐 사용 가능한 키(복제 가능). 지역 장애복구/글로벌 애플리케이션에 유용.

---

# 4. 기본 워크플로우: Envelope Encryption (권장)

1. 애플리케이션이 KMS에 `GenerateDataKey`(또는 `GenerateDataKeyWithoutPlaintext`) 호출 → 반환:
   - `Plaintext` (데이터 키 평문)
   - `CiphertextBlob` (데이터 키의 KMS 암호문)
2. 애플리케이션은 `Plaintext`를 사용해 **실제 데이터**를 암호화(예: AES-GCM)
3. 암호화된 데이터 + `CiphertextBlob`을 함께 저장(예: S3 오브젝트 메타데이터, DB 컬럼)
4. 복호화: 저장된 `CiphertextBlob`을 KMS `Decrypt`에 제출 → 복호화된 `Plaintext`로 실제 데이터를 복호화

> 이유: KMS API 호출은 비용과 지연이 있으므로, 데이터 자체를 직접 KMS로 암호화(대량 데이터)하지 않고 **데이터 키로 암호화**하는 방식이 효율적이고 안전함.

---

# 5. 서비스별 연계 사용 예 (간단 요약)

- **S3**: SSE-KMS로 객체 암호화, 또는 클라이언트 사이드(Envelope) 방식으로 저장. S3 버킷 기본 암호화 설정 권장.  
- **EBS**: EBS 볼륨 생성 시 KMS 키 지정하여 암호화(스냅샷 포함).  
- **RDS**: 인스턴스 생성 시 KMS CMK로 스토리지 암호화 가능.  
- **EFS**: 파일 시스템 암호화에 KMS 사용.  
- **Lambda**: 환경변수 암호화(특히 plain text 비밀 값 대신 KMS 암호화) — 또는 Secrets Manager 사용 권장.  
- **Secrets Manager & Parameter Store**: 내부적으로 KMS를 사용하여 비밀을 암호화.  
- **CloudWatch Logs, Redshift, Glue** 등 주요 AWS 서비스는 KMS 연동 지원.

---

# 6. 실습 예제

## 6.1 S3에서 SSE-KMS로 버킷 기본 암호화 설정 (CLI)

```bash
aws s3api put-bucket-encryption \
  --bucket my-bucket \
  --server-side-encryption-configuration '{
    "Rules":[
      {
        "ApplyServerSideEncryptionByDefault":{
          "SSEAlgorithm":"aws:kms",
          "KMSMasterKeyID":"arn:aws:kms:ap-northeast-2:123456789012:key/abcd-ef01-2345-6789"
        }
      }
    ]
  }'
```

- 객체 업로드 시 별도 옵션 없이 SSE-KMS로 자동 암호화됩니다.
- **권한**: 객체를 업로드하는 주체(사용자/서비스)는 해당 CMK에 대해 `kms:Encrypt`(또는 `kms:GenerateDataKey`) 권한이 있어야 합니다.

## 6.2 KMS 키 생성 (CLI)

```bash
aws kms create-key \
  --description "My app CMK" \
  --tags TagKey=Project,TagValue=Billing
```

생성 후 `KeyId` 또는 `Arn`을 사용.

## 6.3 클라이언트 사이드(Envelope) 암호화/복호화 — Python (boto3 + cryptography 예제)

> 사전준비: `pip install boto3 cryptography`

```python
# encrypt_file.py
import boto3
import json
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

kms = boto3.client('kms', region_name='ap-northeast-2')
S3_BUCKET = 'my-encrypted-bucket'
CMK_KEY_ID = 'arn:aws:kms:ap-northeast-2:123456789012:key/abcd-ef01-2345-6789'

def generate_data_key():
    resp = kms.generate_data_key(KeyId=CMK_KEY_ID, KeySpec='AES_256')
    # resp contains 'Plaintext' (bytes) and 'CiphertextBlob' (bytes)
    return resp['Plaintext'], resp['CiphertextBlob']

def encrypt_bytes(plaintext_bytes, data_key_plain):
    aesgcm = AESGCM(data_key_plain)
    nonce = AESGCM.generate_key(bit_length=96)  # 12 bytes nonce recommended
    # cryptography expects 12-byte nonce for AESGCM
    nonce = AESGCM.generate_key(bit_length=96)[:12]
    ct = aesgcm.encrypt(nonce, plaintext_bytes, None)
    return nonce + ct  # prepend nonce

def main():
    # 예: 간단 파일 암호화
    with open('example.txt', 'rb') as f:
        data = f.read()

    data_key_plain, data_key_encrypted = generate_data_key()
    ciphertext = encrypt_bytes(data, data_key_plain)

    # Plaintext data key는 반드시 메모리에서 즉시 폐기
    del data_key_plain

    # 저장: S3에 업로드 (예: metadata에 encrypted data key 보관)
    import boto3
    s3 = boto3.client('s3')
    s3.put_object(Bucket=S3_BUCKET, Key='example.enc',
                  Body=ciphertext,
                  Metadata={'x-amz-key': data_key_encrypted.hex()})
    print("Uploaded encrypted object with encrypted data key in metadata.")

if __name__ == '__main__':
    main()
```

복호화 예:

```python
# decrypt_file.py
import boto3
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

s3 = boto3.client('s3')
kms = boto3.client('kms', region_name='ap-northeast-2')

def decrypt_object(bucket, key):
    obj = s3.get_object(Bucket=bucket, Key=key)
    ciphertext = obj['Body'].read()
    enc_key_hex = obj['Metadata']['x-amz-key']
    enc_key = bytes.fromhex(enc_key_hex)

    # KMS에 요청하여 데이터 키 평문 획득
    resp = kms.decrypt(CiphertextBlob=enc_key)
    data_key_plain = resp['Plaintext']

    nonce = ciphertext[:12]
    ct = ciphertext[12:]
    aesgcm = AESGCM(data_key_plain)
    plaintext = aesgcm.decrypt(nonce, ct, None)

    # 메모리 정리
    del data_key_plain
    return plaintext

if __name__ == '__main__':
    print(decrypt_object('my-encrypted-bucket', 'example.enc'))
```

**주의**: 위 코드는 교육용 예제입니다. 실제 배포 시 nonce 생성 방식, 메타데이터 저장 위치, 키 노출 최소화, 메모리 클리어, 에러 처리 등 보강 필요.

## 6.4 KMS로 문자열(예: 비밀번호) 암호화(클라이언트→보관) — CLI

```bash
# 암호화
aws kms encrypt --key-id alias/my-key --plaintext "mySecretPassword" \
  --query CiphertextBlob --output text | base64 --decode > secret.bin

# 복호화
aws kms decrypt --ciphertext-blob fileb://secret.bin \
  --query Plaintext --output text | base64 --decode
```

---

# 7. 권한, 키 정책, Grants, 암호화 컨텍스트

## 7.1 키 정책(Key Policy)
- CMK의 **최상위 권한 제어 문서**입니다. 키 정책은 해당 CMK에 누가 무슨 작업을 할 수 있는지 결정합니다.
- 일반적 권장: 키 관리자(관리자 역할)와 키 사용 주체(서비스/사용자)를 명시적으로 분리하여 최소 권한으로 구성.

예(간단):

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid":"AllowUseOfTheKey",
      "Effect":"Allow",
      "Principal":{"AWS":"arn:aws:iam::111122223333:role/S3AccessRole"},
      "Action":["kms:Encrypt","kms:Decrypt","kms:GenerateDataKey*"],
      "Resource":"*"
    }
  ]
}
```

## 7.2 IAM 정책 vs 키 정책
- **IAM 정책**: 주체(사용자/역할)에 연결되는 권한.  
- **키 정책**: CMK 자체에 연결되는 권한.  
KMS 접근을 위해서는 보통 **두쪽 모두** 적절히 구성되어야 합니다(키 정책이 권한 부여를 허용하고, IAM 정책이 요청을 허용).

## 7.3 Grants
- Grants는 일시적·세밀한 키 사용 권한(예: 특정 API 허용)을 부여할 때 사용.  
- 장점: 빠른 권한 부여/취소, 특히 S3나 다른 AWS 서비스가 키를 사용하도록 권한을 위임할 때 유용.

## 7.4 암호화 컨텍스트 (Encryption Context)
- 추가적인 인증 바인딩 메타데이터. 데이터를 복호화할 때 동일한 컨텍스트가 필요하면 KMS가 거부합니다(옵션).
- 예: `{"purpose":"backup","object":"invoice/2025/07/01.json"}`  
- 사용: 민감한 데이터의 무결성/출처 검증에 유용.

---

# 8. 키 관리(회전·삭제·복제)와 운영 팁

## 8.1 키 회전 (Key Rotation)
- Customer-managed symmetric CMK는 **자동 키 회전(1년 주기)**을 활성화할 수 있음.  
- 회전 시 기존 암호문을 자동으로 재암호화하진 않습니다. 데이터 재암호화가 필요한 경우:
  - **ReEncrypt API**를 사용해 암호문을 새 CMK로 재암호화하거나,
  - 저장된 객체를 "읽고 재쓰기(복호화→암호화 with new key)" 방식으로 처리.

## 8.2 키 삭제 (ScheduleKeyDeletion)
- CMK는 즉시 삭제 불가. 삭제 예약(7~30일) 후 삭제됩니다. 이를 통해 실수 삭제 방지.
- 삭제 전에는 키 비활성화(disable-key) 권장.

## 8.3 멀티 리전 & 복제
- **Multi-Region CMK**를 사용하면 리전 간 재난 복구를 쉽게 할 수 있음(복제 지원).
- Cross-Region 암호문 사용 시 리전별 키 접근 고려 필요.

## 8.4 Custom Key Store (CloudHSM)
- 규정상 HSM에서 키를 관리해야 할 때 사용.
- 단점: 비용·운영 복잡성 증가.

---

# 9. 보안·감사·비용 고려사항

## 9.1 감사(CloudTrail)
- KMS의 모든 API 호출(Encrypt, Decrypt, GenerateDataKey, CreateKey 등)은 CloudTrail에 기록됩니다. 감사·포렌식·사용량 추적에 필수.

## 9.2 비용
- **CMK(고객 관리 키)**에 대한 월별 비용(일부 키 유형에 적용) 및 **API 호출(Encrypt/Decrypt/GenerateDataKey 등)**에 대한 사용 요금이 발생합니다. (요금은 지역·시점에 따라 달라지므로 AWS 요금 페이지 확인 권장)

## 9.3 성능·스케일
- KMS는 동시 처리량 한계·API 레이턴시가 존재.  
- 대량 데이터 암호화 시 **Envelope Encryption**을 사용하고, KMS 호출을 최소화(데이터키 재사용은 신중히)하세요.

---

# 10. 체크리스트(베스트 프랙티스)

- **최소 권한 원칙(Least Privilege)** 적용  
- CMK는 필요할 때만 생성하고 태깅으로 관리  
- **키 정책**와 **IAM 정책**을 일관되게 설계  
- **Encryption Context** 활용으로 무결성 강화  
- **Envelope Encryption** 사용 — KMS로 대용량 데이터 직접 암호화 금지  
- **자동 키 회전(Automatic key rotation)** 활성화(가능하면)  
- **CloudTrail 로깅** 활성화하여 모든 KMS 호출 감사  
- **데이터 키 평문(Plaintext)**은 메모리에서 빠르게 폐기하고 절대 로그에 남기지 않음  
- **비상 대응**을 위한 키 삭제 보호(삭제 예약 기간·비활성화 정책) 마련  
- **비용 모니터링**: KMS API 호출량과 CMK 수량 확인

---

# 11. 자주 발생하는 오류와 해결 방법

- **AccessDeniedException**  
  - 원인: 키 정책 또는 IAM 정책에 해당 주체 권한 누락.  
  - 해결: 키 정책·IAM 정책·서비스 역할·grants를 확인. S3 + KMS의 경우 `kms:ViaService` 조건 필요할 수 있음.

- **InvalidCiphertextException**  
  - 원인: 제공된 암호문이 유효하지 않음(오염 또는 잘못된 키 사용).  
  - 해결: 암호문과 대응하는 CMK 확인. 암호화 컨텍스트를 사용했다면 복호화 시 동일한 컨텍스트 전달 여부 확인.

- **ThrottlingException**  
  - 원인: KMS API 호출 초과(스루풋 제한).  
  - 해결: 호출 패턴 재설계(캐싱, 배치), AWS 지원에 요청하여 제한 상향.

---

# 부록 — 예시: S3 + KMS 사용 시 권한 예시(핵심사항)

- S3가 KMS를 사용하도록 허용하려면 CMK 키 정책에 S3 서비스 요청을 허용해야 합니다. (예: `kms:Encrypt` 권한을 S3에 위임)
- 예시 키 정책 문구(요약):

```json
{
  "Sid": "AllowS3ToUseKey",
  "Effect": "Allow",
  "Principal": { "Service": "s3.amazonaws.com" },
  "Action": [
    "kms:Encrypt",
    "kms:Decrypt",
    "kms:GenerateDataKey*",
    "kms:ReEncrypt*"
  ],
  "Resource": "*",
  "Condition": {
    "StringEquals": { "kms:ViaService": "s3.ap-northeast-2.amazonaws.com" }
  }
}
```

> 위 샘플은 개념 설명용입니다. 실제로는 `Resource`, `aws:SourceAccount` 등 조건을 더 엄격히 설정해야 합니다.

---

# 결론

AWS KMS는 **키 수명주기 관리·권한 통제·감사**를 통합 제공하여 안전한 암호화 환경을 만들 수 있게 해줍니다.  
핵심은 **Envelope Encryption 패턴을 사용**하고, **키정책·IAM정책을 엄격하게 설계**하며, **CloudTrail로 감사**하는 것입니다. 운영 측면에서는 키 회전·비상 복구·비용 관리를 함께 고려해야 안전하고 확장 가능한 암호화 전략을 설계할 수 있습니다.
