---
layout: post
title: AWS - KMS
date: 2025-08-03 20:20:23 +0900
category: AWS
---
# AWS KMS를 활용한 데이터 암호화

## 한눈에 보는 KMS

- **무엇**: AWS Key Management Service. **암호화 키의 생성/보관/사용/감사**를 중앙에서 제공.
- **왜**: 규제 준수(암호화 의무), 비밀 관리 일원화, **CloudTrail로 키 사용 추적**, IAM·리소스 정책과의 정밀 제어.
- **어떻게**:
  - 데이터 자체는 **애플리케이션 대칭키(AES-GCM 등)**로 암/복호,
  - 그 대칭키(데이터 키)는 **KMS로 생성/보호(Encrypt/Decrypt, GenerateDataKey)** → **엔벨로프 암호화**.
- **통합**: S3, EBS, RDS, EFS, Redshift, CloudWatch Logs, Secrets Manager, Parameter Store, Lambda, Glue 등 **AWS 대부분의 데이터 서비스가 KMS와 연동**.

---

## 암호화 방식 총정리 (SSE vs CSE vs Envelope)

### Server-Side Encryption (SSE)

- **SSE-S3**: S3 관리 키로 객체 암호화(키 제어 불가, 가장 단순).
- **SSE-KMS**: **KMS CMK**로 객체 암호화(권한/감사/회전 제어 가능) → **실무 표준**.
- **SSE-C**: 고객 제공 키로 암호화(운영 복잡성↑, 일반 권장 X).

### Client-Side Encryption (CSE)

- 앱이 **로컬에서 데이터 암/복호**. S3에는 암호문만 업로드.
- KMS는 **데이터 키 발급**(GenerateDataKey)과 **암호화 컨텍스트 바인딩**에 사용.

### Envelope Encryption (권장 패턴)

1) KMS `GenerateDataKey`로 **평문 데이터키 + 암호문 데이터키** 획득
2) 평문 데이터키로 데이터(AES-GCM 등) 암호화
3) 평문 데이터키 **즉시 폐기**, **암호문 데이터키**와 **암호문 데이터**를 함께 보관
4) 복호화 시 KMS `Decrypt`로 **암호문 데이터키 → 평문 데이터키 복원** → 데이터 복호화

> 대량 데이터를 직접 KMS로 Encrypt/Decrypt 하지 않는 이유: **성능/비용/한도**. 데이터 키를 활용하면 **짧은 KMS 호출로 대용량 암호화가 가능**.

---

## KMS 핵심 구성요소와 키 유형

- **CMK(고객 마스터 키; 이제는 “KMS 키”로 표기되는 경우 多)**
  - **Customer-managed**: 사용자가 생성·정책·회전 제어(가장 일반적).
  - **AWS-managed**: 서비스별 기본 제공(세부 제어 제한).
  - **AWS-owned**: 완전 내부 소유(사용자 노출 없음).

- **대칭 키(Symmetric)**: AES-256 기반. `Encrypt/Decrypt`, `GenerateDataKey`, `ReEncrypt` 등. **데이터 보호 대부분에 권장**.

- **비대칭 키(Asymmetric)**: RSA/ECC. `Sign/Verify`, `Encrypt/Decrypt` 등(키 외부 반출 불가 시나리오/서명에 유용).

- **Multi-Region 키**: 리전 간 복제 가능(재해복구·글로벌 앱).
- **Custom Key Store (CloudHSM)**: 규제가 HSM 내 키 저장 요구 시.

---

## Envelope 암호화 워크플로우 (상세)

1. `GenerateDataKey(KeyId=<CMK>, KeySpec='AES_256', EncryptionContext=...)`
   - 응답: `Plaintext`, `CiphertextBlob`
2. 앱: `Plaintext`로 데이터 AES-GCM 암호화
3. **Plaintext 즉시 폐기**(메모리 zeroization 등), `CiphertextBlob`과 암호문을 같이 저장
4. 복호화: `Decrypt(CiphertextBlob, EncryptionContext=...)` → **평문 데이터키** 획득 → 데이터 복호화

> **암호화 컨텍스트**를 강제하면 “암호문과 사용 맥락”이 바뀌면 복호화 실패 → **무결성·정합성 강화**.

---

## 서비스 연계 패턴 요약

- **S3**: 버킷 **기본 암호화(SSE-KMS)** 설정 + 업로더 역할에 `kms:Encrypt/GenerateDataKey` 권한. 필요 시 버킷 정책으로 **TLS/VPCe/KMS 필수** 강제.
- **EBS**: 볼륨/스냅샷 암호화 기본값 ON(키 지정).
- **RDS/Redshift/EFS/CloudWatch Logs/Glue**: 생성 시 KMS 키 지정.
- **Secrets Manager/Parameter Store**: 내부적으로 KMS 사용(애플리케이션은 API로 비밀을 조회).
- **Lambda**: 환경변수 암호화(혹은 Secrets 연동).
- **S3 이벤트 → Lambda → KMS**: 암호화 컨텍스트·권한 모델을 함께 설계.

---

## 실습: SSE-KMS, CSE, 비밀 암호화

### S3 버킷 기본 암호화(SSE-KMS) 설정 (CLI)

```bash
aws s3api put-bucket-encryption \
  --bucket my-bucket \
  --server-side-encryption-configuration '{
    "Rules":[
      {
        "ApplyServerSideEncryptionByDefault":{
          "SSEAlgorithm":"aws:kms",
          "KMSMasterKeyID":"arn:aws:kms:ap-northeast-2:123456789012:key/abcd-ef01-2345-6789"
        }
      }
    ]
  }'
```

- 업로더(사용자/역할)는 해당 CMK에 대해 `kms:Encrypt` 또는 `kms:GenerateDataKey*` 권한 필요.

### CMK 생성 (CLI)

```bash
aws kms create-key \
  --description "App CMK for data-at-rest" \
  --tags TagKey=Owner,TagValue=DataTeam TagKey=Env,TagValue=Prod
```

반환된 `KeyId`/`Arn`을 이후에 사용.

### 클라이언트 사이드(Envelope) — Python 예제(boto3 + cryptography)

> `pip install boto3 cryptography`

```python
# encrypt_file.py

import boto3, os
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

REGION = "ap-northeast-2"
BUCKET = "my-encrypted-bucket"
CMK_ARN = "arn:aws:kms:ap-northeast-2:123456789012:key/abcd-ef01-2345-6789"

kms = boto3.client("kms", region_name=REGION)
s3  = boto3.client("s3", region_name=REGION)

def generate_data_key():
    resp = kms.generate_data_key(KeyId=CMK_ARN, KeySpec="AES_256",
                                 EncryptionContext={"purpose":"file-encrypt","bucket":BUCKET})
    return resp["Plaintext"], resp["CiphertextBlob"]

def encrypt_bytes(plaintext: bytes, data_key_plain: bytes) -> bytes:
    aes = AESGCM(data_key_plain)        # 32 bytes key
    nonce = os.urandom(12)              # 96-bit nonce
    ct = aes.encrypt(nonce, plaintext, None)
    return nonce + ct                   # [nonce|ciphertext]

def main():
    with open("example.txt","rb") as f:
        data = f.read()
    plain, enc = generate_data_key()
    blob = encrypt_bytes(data, plain)
    # 민감: 평문키 메모리 즉시 폐기
    del plain

    # 암호문 업로드 + 암호화된 데이터키를 메타데이터에 보관
    s3.put_object(Bucket=BUCKET, Key="example.enc", Body=blob,
                  Metadata={"x-amz-key": enc.hex(), "x-ctx-purpose":"file-encrypt"})
    print("done.")

if __name__ == "__main__":
    main()
```

복호화:

```python
# decrypt_file.py

import boto3, binascii
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

REGION = "ap-northeast-2"
BUCKET = "my-encrypted-bucket"

kms = boto3.client("kms", region_name=REGION)
s3  = boto3.client("s3", region_name=REGION)

def main():
    obj = s3.get_object(Bucket=BUCKET, Key="example.enc")
    blob = obj["Body"].read()
    enc_hex = obj["Metadata"]["x-amz-key"]
    enc_key = binascii.unhexlify(enc_hex)

    # 컨텍스트가 있었다면 일치하게 전달
    resp = kms.decrypt(CiphertextBlob=enc_key,
                       EncryptionContext={"purpose":"file-encrypt","bucket":BUCKET})
    plain_key = resp["Plaintext"]

    nonce, ct = blob[:12], blob[12:]
    aes = AESGCM(plain_key)
    pt = aes.decrypt(nonce, ct, None)
    del plain_key

    print(pt.decode("utf-8"))

if __name__ == "__main__":
    main()
```

> 실전에서는 **메타데이터 대신 별도 메타스토어(DB)** 에 암호문 데이터키를 저장하거나, S3 객체 태그/메타데이터 사용 시 **크기/보안 제약**을 고려하세요.

### 문자열 비밀을 KMS로 암/복호 (CLI)

```bash
# 암호화

aws kms encrypt \
  --key-id alias/my-app \
  --plaintext "prod-db-password" \
  --query CiphertextBlob --output text > secret.b64

# 복호화

aws kms decrypt \
  --ciphertext-blob fileb://<(base64 --decode secret.b64) \
  --query Plaintext --output text | base64 --decode
```

---

## 권한 모델: 키 정책, IAM 정책, Grants, 암호화 컨텍스트

### 키 정책(Key Policy) 기본형

- **CMK에 붙는 최상위 정책**. 키 사용/관리의 최종 권위.
- 보통 **키 관리자(Administrators)**와 **키 사용자(Encrypt/Decrypt)**를 분리.

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid":"KeyAdmins",
      "Effect":"Allow",
      "Principal":{"AWS":"arn:aws:iam::111122223333:role/KMSAdmins"},
      "Action":[ "kms:*" ],
      "Resource":"*"
    },
    {
      "Sid":"KeyUsersS3",
      "Effect":"Allow",
      "Principal":{"AWS":"arn:aws:iam::111122223333:role/AppUploader"},
      "Action":[ "kms:Encrypt","kms:Decrypt","kms:GenerateDataKey*","kms:ReEncrypt*" ],
      "Resource":"*",
      "Condition":{ "StringEquals":{ "kms:ViaService":"s3.ap-northeast-2.amazonaws.com" } }
    }
  ]
}
```

> **키 정책 + IAM 정책**이 **모두** 허용해야 호출 성공(교집합). S3와 결합 시 `kms:ViaService` 등 조건으로 **서비스 경유 사용만 허용**하면 안전.

### Grants

- **일시적/세밀한 사용 위임**. 예: 특정 역할이 일정 작업만 하도록.
- S3/Redshift 등 서비스가 내부적으로 **Grant를 사용**하기도 함(성능/회복).

### 암호화 컨텍스트(Encryption Context)

- `Encrypt/Decrypt/ReEncrypt/GenerateDataKey`에 부가하는 **인증 메타데이터**.
- 복호화 시 **동일 컨텍스트**가 요구됨 → **무결성·출처 바인딩**.

```python
kms.encrypt(KeyId=CMK_ARN, Plaintext=b"...",
            EncryptionContext={"tenant":"acme","table":"orders"})
```

---

## 운영: 회전·삭제·멀티리전·HSM

### 자동 키 회전

- 대칭 CMK: **연 1회 자동회전** ON 가능.
- 기존 암호문은 그대로 유효(키 버전 내부 추적).
- 대량 재암호화 필요 시 `ReEncrypt` 또는 “읽고-다시쓰기”.

### 키 삭제

- **즉시 삭제 불가**. `ScheduleKeyDeletion(7~30일)`로 예약.
- 오입력 대비: 먼저 **Disable**, 영향 검토 후 삭제 예약.

### 멀티 리전 CMK

- **Multi-Region Key**로 리전별 복제/조합. DR/지연 최적화.
- 권한·감사·비용은 리전별로 따로 고려.

### Custom Key Store

- **CloudHSM** 요구사항 대응.
- 비용/운영 복잡성↑ → 반드시 필요한 경우에만.

---

## 보안·감사·비용·성능

### 감사

- **CloudTrail**: 모든 KMS API 호출(Encrypt/Decrypt/GDK/키관리) 기록.
- 쿼리/알람: **비정상 지역/서비스/주체** 탐지.

### 비용(개념식)

- 개략 비용 모델(예):
  $$
  \text{MonthlyCost} \approx N_{\text{keys}} \cdot C_{\text{key}} + N_{\text{API}} \cdot C_{\text{api}}
  $$
  - \(N_{\text{keys}}\): CMK 수, \(C_{\text{key}}\): CMK 월 요금(유형/지역별 상이)
  - \(N_{\text{API}}\): Encrypt/Decrypt/GenerateDataKey 호출 수
- **최적화**: **Envelope**로 대량 데이터 암/복호 최소 API 호출, 불필요한 키 남발 금지, **공유 CMK + 데이터 분류/컨텍스트**.

### 성능/한도

- KMS는 TPS/지연 **한도** 존재.
- **배치 처리** 시 데이터 키 재사용 전략(합리적 범위) + **비동기 파이프라인** 고려.
- 고TPS 필요 시 **멀티 스레드** + **로컬 캐시(단, 보안 고려)**.

---

## 서비스별 설계 스니펫 (실전)

### S3: TLS·KMS·VPCe 강제 (버킷 정책)

```json
{
  "Version":"2012-10-17",
  "Statement":[
    {
      "Sid":"DenyNonTLS",
      "Effect":"Deny",
      "Principal":"*",
      "Action":"s3:*",
      "Resource":[ "arn:aws:s3:::secure-bucket", "arn:aws:s3:::secure-bucket/*" ],
      "Condition":{ "Bool":{"aws:SecureTransport":"false"} }
    },
    {
      "Sid":"DenyNoKMSOnPut",
      "Effect":"Deny",
      "Principal":"*",
      "Action":"s3:PutObject",
      "Resource":"arn:aws:s3:::secure-bucket/*",
      "Condition":{ "Null":{"s3:x-amz-server-side-encryption":"true"} }
    },
    {
      "Sid":"AllowOnlyVpce",
      "Effect":"Deny",
      "Principal":"*",
      "Action":"s3:*",
      "Resource":[ "arn:aws:s3:::secure-bucket","arn:aws:s3:::secure-bucket/*" ],
      "Condition":{ "StringNotEquals":{"aws:SourceVpce":"vpce-0abc123"} }
    }
  ]
}
```

### KMS 키 정책(서비스 경유만 허용)

```json
{
  "Version":"2012-10-17",
  "Statement":[
    {
      "Sid":"AllowS3ViaService",
      "Effect":"Allow",
      "Principal":{"Service":"s3.amazonaws.com"},
      "Action":[ "kms:Encrypt","kms:Decrypt","kms:GenerateDataKey*","kms:ReEncrypt*" ],
      "Resource":"*",
      "Condition":{
        "StringEquals":{
          "kms:ViaService":"s3.ap-northeast-2.amazonaws.com",
          "aws:SourceAccount":"123456789012"
        }
      }
    }
  ]
}
```

### EBS/RDS: 생성 시 암호화 기본값

- 계정/리전 기본 암호화 ON + 특정 CMK 지정(거버넌스 용이).

### Lambda 환경변수 암호화

- 함수 설정에서 KMS 키 지정 또는 Secrets Manager/Parameter Store 사용.

---

## IaC: CloudFormation & CDK

### CloudFormation — CMK + 별칭 + 키 정책

```yaml
AWSTemplateFormatVersion: '2010-09-09'
Resources:
  AppKey:
    Type: AWS::KMS::Key
    Properties:
      Description: CMK for application data
      EnableKeyRotation: true
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          - Sid: Admins
            Effect: Allow
            Principal:
              AWS: arn:aws:iam::123456789012:role/KMSAdmins
            Action: 'kms:*'
            Resource: '*'
          - Sid: AppUsersViaS3
            Effect: Allow
            Principal:
              AWS: arn:aws:iam::123456789012:role/AppUploader
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:GenerateDataKey*
              - kms:ReEncrypt*
            Resource: '*'
            Condition:
              StringEquals:
                kms:ViaService: s3.ap-northeast-2.amazonaws.com
  AppKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: alias/app-data
      TargetKeyId: !Ref AppKey
```

### CDK (TypeScript)

```ts
import * as cdk from 'aws-cdk-lib';
import * as kms from 'aws-cdk-lib/aws-kms';
import * as s3  from 'aws-cdk-lib/aws-s3';

export class KmsStack extends cdk.Stack {
  constructor(scope: cdk.App, id: string, props?: cdk.StackProps){
    super(scope, id, props);

    const key = new kms.Key(this, 'AppKey', {
      enableKeyRotation: true,
      alias: 'alias/app-data',
      description: 'CMK for application data'
    });

    const bucket = new s3.Bucket(this, 'SecureBucket', {
      bucketName: 'secure-bucket-example',
      encryption: s3.BucketEncryption.KMS,
      encryptionKey: key,
      enforceSSL: true
    });

    // 필요 시 버킷 정책 보강(HTTPS/VPCe/KMS 필수)
  }
}
```

---

## 자주 겪는 오류 & 해결

| 증상 | 원인 | 점검 포인트 |
|---|---|---|
| `AccessDeniedException` | 키/ IAM 정책 불일치 | **키 정책**에 주체 허용? IAM 정책에도 허용? `kms:ViaService`/`aws:SourceAccount` 조건? |
| `InvalidCiphertextException` | 다른 키/컨텍스트로 복호 | 암호문 데이터키와 **같은 CMK/컨텍스트**인가? 손상 여부? |
| `ThrottlingException` | 호출 한도 초과 | 호출 패턴 최적화, 배치·캐시, 필요 시 한도 상향 요청 |
| S3 Put 실패 | SSE-KMS 미설정/권한 부족 | 버킷 기본 암호화, 업로더 역할의 `Encrypt/GenerateDataKey` 권한, 키 정책의 S3 ViaService |
| Cross-Account 실패 | 신뢰·키·리소스 정책 미정합 | **AssumeRole** 경로, 키 정책의 Principal/Condition, S3/Lambda 자원 정책 함께 점검 |

---

## 거버넌스 & 감사 자동화

- **CloudTrail**: KMS 호출 전수 로깅 → Athena/CloudWatch Logs Insights로 분석.
- **AWS Config**: “버킷 기본 암호화 미사용”, “EBS 기본 암호화 OFF” 등 **비준수 탐지** → 자동 수정.
- **Access Analyzer**: 외부 접근 가능한 키/버킷/함수 **분석 리포트**.
- **CI 파이프라인**: 정책 린트(와일드카드/리소스 누락), **정책 시뮬레이터** 자동실행, 변경 리뷰.

---

## 체크리스트(베스트 프랙티스)

- [ ] **Envelope Encryption** 사용; 대량 데이터 직접 KMS 암/복호 금지
- [ ] **최소 권한**: CMK 키 정책 + IAM 정책의 **교집합** 설계
- [ ] **SSE-KMS**: S3/EBS/RDS 등 **기본 암호화 ON** + KMS 키 지정
- [ ] **암호화 컨텍스트**로 무결성 바인딩
- [ ] **자동 회전** 활성화(대칭 CMK)
- [ ] **CloudTrail**로 모든 KMS 호출 감사
- [ ] **키 수명주기**: Disable → Deletion Schedule(7~30일)
- [ ] **비용/성능**: API 호출 최적화, 키 수 관리, Multi-Region 필요성 검토
- [ ] **거버넌스**: Config/Analyzer/정책 시뮬레이터 CI, 표준 태그(Owner/Env/DataClass)

---

## 확장 예제: Node.js 서버에서 SSE-KMS 업로드

```js
// npm i @aws-sdk/client-s3
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

const s3 = new S3Client({ region: 'ap-northeast-2' });

export async function upload(buf, key){
  await s3.send(new PutObjectCommand({
    Bucket: 'secure-bucket',
    Key: key,
    Body: buf,
    ServerSideEncryption: 'aws:kms',
    SSEKMSKeyId: 'arn:aws:kms:ap-northeast-2:123456789012:key/abcd-ef01-2345-6789',
    Metadata: { 'source': 'node-api' }
  }));
}
```

---

## 비용/위험 간단 모델(개념)

- **위험(노출면적)**은 **주체/액션/리소스/컨텍스트 선택도**에 비례:
$$
\text{Risk} \propto f\Big(|P|,|A|,|R|, 1-\text{Selectivity(Context)}\Big)
$$
- 대응: **주체·액션·리소스 최소화** + **컨텍스트 선택도↑** + **명시적 Deny** 가드레일(SCP/버킷정책/키정책).

---

## 마무리

- KMS는 **키 수명주기·권한 제어·감사**를 표준화하여, 데이터 보호의 **기술적 근간**을 제공합니다.
- 실전의 정답은 **Envelope 패턴** + **SSE-KMS 기본화** + **철저한 정책 교차검증(키정책×IAM×리소스정책)** + **감사/자동화**입니다.
- 초기에 모델을 정확히 잡으면(ABAC/RBAC, 컨텍스트, 거버넌스), 대규모 조직/멀티 계정/멀티 리전에서도 **안전하고 확장 가능한 암호화 전략**을 유지할 수 있습니다.
