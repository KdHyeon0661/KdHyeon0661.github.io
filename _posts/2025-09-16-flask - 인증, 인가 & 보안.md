---
layout: post
title: flask - 인증/인가 & 보안
date: 2025-09-16 20:25:23 +0900
category: flask
---
# 8. 인증/인가 & 보안

> 이 장은 **세션/쿠키 & Flask-Login(remember-me 포함)** → **인가(RBAC/ABAC) 패턴** → **JWT & OAuth2/OIDC 흐름과 구현 포인트** → **CSRF/XSS/CORS/Clickjacking 실전 설정** → **비밀번호 저장(해시/솔트)와 인증 속도 제한(레이트 리미팅)** 을 “운영 실전” 기준으로 정리한다.  
> 모든 코드는 ``` 로 감싸고, 수식이 있으면 반드시 $$...$$ 로 표기한다(이 장은 수식이 거의 없음).

---

## 8.1 세션/쿠키 기본, 안전한 설정

웹 인증의 기본은 **쿠키 기반 세션**이다. 핵심은:

- **보안 플래그**: `Secure`(HTTPS만), `HttpOnly`(JS 접근 차단), `SameSite=Lax/Strict`  
- **세션 타임아웃**: **유휴(Idle) 타임아웃** + **절대(Max) 타임아웃**  
- **세션 고정(Session Fixation) 방지**: 로그인 직후 **세션 재생성**  
- **권한 상승 시 재인증**: 민감 동작은 **fresh session** 필요(Flask-Login 지원)

### 8.1.1 앱 기본 설정

```python
# app/config.py
class BaseConfig:
    SECRET_KEY = "override-in-prod"  # 운영에선 환경변수/시크릿 매니저
    SESSION_COOKIE_SECURE = True
    SESSION_COOKIE_HTTPONLY = True
    SESSION_COOKIE_SAMESITE = "Lax"  # OAuth 등 크로스사이트 필요시 'None'(+Secure 필수)
    PERMANENT_SESSION_LIFETIME = 3600  # 1h 절대 만료(remember는 별도)
```

### 8.1.2 세션 재생성(고정 방지)

Flask의 기본 세션은 **서명 쿠키**이다. 로그인 성공 시 **세션을 비우고 재발급**한다.

```python
# app/security/session.py
from flask import session

def rotate_session():
    # 간단한 방법: 세션 키 전체를 재구성
    old = dict(session)
    session.clear()
    # 필요한 키만 재주입 (예: locale)
    for k in ("locale",):
        if k in old:
            session[k] = old[k]
```

로그인 직후 호출:

```python
# after successful password check
rotate_session()
login_user(user, remember=form.remember.data, fresh=True)
```

> 서버사이드 세션(예: Redis) 확장을 쓰면 **session id 재생성** 기능을 활용한다.

---

## 8.2 Flask-Login으로 세션 인증

### 8.2.1 초기화 & User 모델

```python
# app/extensions.py
from flask_login import LoginManager

login_mgr = LoginManager()

def init_extensions(app):
    login_mgr.init_app(app)
    login_mgr.login_view = "auth.login"           # 로그인 필요시 redirect
    login_mgr.session_protection = "strong"       # 활동 간 세션 무결성 강화
```

```python
# app/models/user.py
from app.extensions import db
from flask_login import UserMixin

class User(db.Model, UserMixin):
    __tablename__ = "users"
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(255), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    is_admin = db.Column(db.Boolean, default=False)
```

```python
# app/auth/loaders.py
from app.extensions import login_mgr
from app.models.user import User

@login_mgr.user_loader
def load_user(user_id: str) -> User | None:
    return User.query.get(int(user_id))
```

### 8.2.2 로그인/로그아웃(remember-me 포함)

```python
# app/blueprints/auth/views.py
from flask import Blueprint, render_template, request, redirect, url_for, flash
from flask_login import login_user, logout_user, login_required, current_user
from app.models.user import User
from app.security.passwords import verify_password
from app.security.session import rotate_session

auth_bp = Blueprint("auth", __name__)

@auth_bp.get("/login")
def login_form():
    return render_template("auth/login.html")

@auth_bp.post("/login")
def login_submit():
    email = request.form["email"].strip().lower()
    password = request.form["password"]
    remember = bool(request.form.get("remember"))

    user = User.query.filter_by(email=email).one_or_none()
    if not user or not verify_password(password, user.password_hash):
        flash("이메일 또는 비밀번호가 올바르지 않습니다.", "error")
        return redirect(url_for("auth.login_form"))

    if not user.is_active:
        flash("비활성화된 계정입니다.", "error")
        return redirect(url_for("auth.login_form"))

    rotate_session()
    login_user(user, remember=remember, fresh=True)  # fresh 세션
    flash("로그인 성공", "success")
    return redirect(url_for("site.home"))

@auth_bp.post("/logout")
@login_required
def logout():
    logout_user()
    flash("로그아웃 되었습니다.", "info")
    return redirect(url_for("site.home"))
```

**remember-me**: Flask-Login은 자체 **장기 쿠키**(`REMEMBER_COOKIE_DURATION` 등) 사용.

```python
# app/config.py
class BaseConfig:
    REMEMBER_COOKIE_DURATION = 60 * 60 * 24 * 30  # 30일
    REMEMBER_COOKIE_SECURE = True
    REMEMBER_COOKIE_HTTPONLY = True
    REMEMBER_COOKIE_SAMESITE = "Lax"
```

### 8.2.3 fresh login 요구(권한 상승 동작 보호)

```python
# 민감 동작: 송금/비밀번호 변경 등
from flask_login import fresh_login_required

@account_bp.post("/change-password")
@fresh_login_required
def change_pwd():
    ...
```

fresh가 아니면 Flask-Login이 `login_view`로 리다이렉트.  
“다시 비밀번호 확인” UI를 제공하는 게 일반적.

---

## 8.3 인가(Authorization): RBAC/ABAC 패턴

### 8.3.1 간단 RBAC(역할 기반)

```python
# app/security/permissions.py
from functools import wraps
from flask import abort
from flask_login import current_user, login_required

def require_roles(*roles: str):
    def deco(fn):
        @wraps(fn)
        @login_required
        def _(*a, **kw):
            if not hasattr(current_user, "roles"):
                abort(403)
            if not set(roles) & set(current_user.roles):
                abort(403)
            return fn(*a, **kw)
        return _
    return deco
```

사용:

```python
@admin_bp.get("/dashboard")
@require_roles("admin", "staff")
def admin_home():
    ...
```

### 8.3.2 ABAC(속성 기반) 예: 소유자/조직 정책

```python
# app/security/policy.py
def can_view_order(user, order) -> bool:
    if user.is_admin:
        return True
    return order.user_id == user.id
```

```python
@orders_bp.get("/<int:order_id>")
@login_required
def view_order(order_id):
    order = Order.query.get_or_404(order_id)
    if not can_view_order(current_user, order):
        abort(403)
    return render_template("orders/detail.html", order=order)
```

> **권장**: 인가 로직을 **한 곳(Policy/Service)** 에 모아두고, 뷰/핸들러에서는 호출만 하라.

---

## 8.4 JWT 기반 인증 (API/모바일/SPA)

**언제?** 세션 쿠키 대신 **Bearer 토큰**이 필요한 API/SPA.  
핵심 포인트:

- **서명 알고리즘**: 대칭(HS256) vs 비대칭(RS256/ES256). 운영은 **키 회전** 고려해 비대칭 권장.  
- **클레임**: `iss`, `sub`, `aud`, `iat`, `exp`, `nbf`, `jti`  
- **토큰 수명**: Access(짧게, 예: 5~15m) + Refresh(길게, 예: 7~30d)  
- **리프레시 토큰 회전 & 블랙리스트**(탈취 대응)  
- **전송 위치**: `Authorization: Bearer <token>` (쿠키는 CSRF 대상이 되므로 주의)

### 8.4.1 발급/검증 (PyJWT 예시, HS256)

```python
# app/jwt/tokens.py
import time, os, jwt
from typing import Dict

JWT_SECRET = os.getenv("JWT_SECRET", "dev-secret")
JWT_ISS = "https://api.example.com"
JWT_AUD = "example-client"

def issue_access(sub: str, scope: str = "user") -> str:
    now = int(time.time())
    payload = {
        "iss": JWT_ISS, "sub": sub, "aud": JWT_AUD,
        "iat": now, "nbf": now, "exp": now + 900,  # 15m
        "scope": scope, "jti": os.urandom(8).hex(),
    }
    return jwt.encode(payload, JWT_SECRET, algorithm="HS256")

def verify_token(token: str) -> Dict:
    return jwt.decode(token, JWT_SECRET, algorithms=["HS256"], audience=JWT_AUD, issuer=JWT_ISS)
```

### 8.4.2 보호 데코레이터

```python
# app/jwt/decorators.py
from functools import wraps
from flask import request, abort, g
from .tokens import verify_token

def jwt_required(fn):
    @wraps(fn)
    def _(*a, **kw):
        auth = request.headers.get("Authorization", "")
        if not auth.startswith("Bearer "):
            abort(401)
        token = auth.split(" ", 1)[1]
        try:
            claims = verify_token(token)
        except Exception:
            abort(401)
        g.jwt = claims
        return fn(*a, **kw)
    return _
```

사용:

```python
@api_v1_bp.get("/me")
@jwt_required
def me():
    return {"sub": g.jwt["sub"], "scope": g.jwt.get("scope")}
```

### 8.4.3 Refresh 토큰(회전 & 블랙리스트)

- 로그인 시 **Access + Refresh** 발급  
- `/token/refresh` 로 **새 Access** 발급, **Refresh는 1회용으로 회전**  
- 서버에 **사용한 refresh jti 저장** → 재사용 시 차단(탈취 탐지)

```python
# 개념 스케치 (실운영: Redis/DB, TTL)
USED_REFRESH = set()

@auth_bp.post("/token/refresh")
def refresh():
    rt = request.json.get("refresh_token")
    claims = verify_token(rt)  # 만료/iss/aud 검증
    jti = claims["jti"]
    if jti in USED_REFRESH:
        return {"error":"reused_refresh"}, 401
    USED_REFRESH.add(jti)
    new_access = issue_access(claims["sub"], scope=claims.get("scope","user"))
    new_refresh = issue_refresh(claims["sub"])  # 새 jti
    return {"access_token": new_access, "refresh_token": new_refresh}
```

> **중요**: Access 토큰을 **브라우저 저장소(LocalStorage)** 에 넣는 것은 XSS에 취약. SPA라면 **iframe+postMessage** 등 보다 안전한 패턴 또는 **SameSite=None; Secure 쿠키 + CSRF 헤더** 조합을 검토한다(복잡).

---

## 8.5 OAuth2 / OpenID Connect(클라이언트로서의 Flask)

대부분의 애플리케이션은 **IdP(구글/깃허브/사내 SSO)** 를 **클라이언트**로 연동한다. 권장 플로우는 **Authorization Code + PKCE**.

### 8.5.1 Authlib로 간단 구현(구글 예)

```python
# pip install authlib
# app/oauth/google.py
import os
from authlib.integrations.flask_client import OAuth

oauth = OAuth()

def init_oauth(app):
    oauth.init_app(app)
    oauth.register(
        name="google",
        client_id=os.getenv("GOOGLE_CLIENT_ID"),
        client_secret=os.getenv("GOOGLE_CLIENT_SECRET"),
        server_metadata_url="https://accounts.google.com/.well-known/openid-configuration",
        client_kwargs={"scope": "openid email profile"},
    )
```

```python
# app/blueprints/auth/oidc.py
from flask import Blueprint, url_for, redirect, session
from flask_login import login_user
from app.oauth.google import oauth
from app.models.user import User
from app.security.session import rotate_session

oidc_bp = Blueprint("oidc", __name__)

@oidc_bp.get("/login/google")
def login_google():
    redirect_uri = url_for("oidc.google_callback", _external=True)
    return oauth.google.authorize_redirect(redirect_uri)  # PKCE 내장

@oidc_bp.get("/auth/google/callback")
def google_callback():
    token = oauth.google.authorize_access_token()
    userinfo = token["userinfo"]  # OIDC 표준 클레임
    email = userinfo["email"].lower()
    # 프로비저닝 or 조회
    user = User.query.filter_by(email=email).one_or_none() or User(email=email, name=userinfo.get("name",""))
    db.session.add(user); db.session.commit()

    rotate_session()
    login_user(user, remember=True, fresh=True)
    return redirect(url_for("site.home"))
```

> **검증 포인트**: `id_token`의 `aud/iss/exp` 검증, 이메일 domain allowlist, 조직 정책(2FA 강제).

---

## 8.6 CSRF / XSS / CORS / Clickjacking — 실전 설정

### 8.6.1 CSRF

- **쿠키 세션 기반 POST**: **반드시 CSRF 토큰**(Flask-WTF 혹은 전역 CSRFProtect)  
- **Bearer 토큰 기반 API**: 쿠키 자동전송을 사용하지 않으므로 CSRF 대상 아님(대신 XSS 주의)  
- **SameSite=Lax** 로도 기본 폼 CSRF 위험을 낮출 수 있으나, 완전 대체는 아님

```python
# 전역 CSRF
from flask_wtf.csrf import CSRFProtect
csrf = CSRFProtect()
csrf.init_app(app)

# JSON API에서 헤더로 토큰 전달
# fetch(url, {method:'POST', headers:{'X-CSRFToken': token}, credentials:'include'})
```

### 8.6.2 XSS

- **템플릿 자동 이스케이프** 유지, `|safe` 최소화  
- **tojson** 으로 JSON 주입  
- **CSP**(Content-Security-Policy)로 인라인 스크립트 금지 및 도메인 제한  
- 라이브러리 최신화(리치 텍스트/Markdown 파서 등)

```python
# app/security/headers.py
def apply_security_headers(app):
    @app.after_request
    def _h(resp):
        resp.headers.setdefault("X-Content-Type-Options", "nosniff")
        resp.headers.setdefault("Referrer-Policy", "strict-origin-when-cross-origin")
        # 인라인 스크립트가 필요하면 nonce/hash 방식
        resp.headers.setdefault("Content-Security-Policy",
            "default-src 'self'; script-src 'self'; style-src 'self'; object-src 'none'; base-uri 'self'")
        return resp
```

### 8.6.3 CORS

- **flask-cors**로 최소 허용 원칙

```python
# pip install flask-cors
from flask_cors import CORS

CORS(api_v1_bp, resources={r"/*": {
    "origins": ["https://app.example.com"],
    "methods": ["GET","POST","PUT","DELETE","OPTIONS"],
    "allow_headers": ["Authorization","Content-Type","X-CSRFToken"],
    "supports_credentials": True  # 쿠키 필요 시
}})
```

### 8.6.4 Clickjacking

- `X-Frame-Options: DENY` 또는 CSP `frame-ancestors 'none'`

```python
@app.after_request
def frame_opts(resp):
    resp.headers.setdefault("X-Frame-Options", "DENY")
    resp.headers.setdefault("Content-Security-Policy", "frame-ancestors 'none';")
    return resp
```

---

## 8.7 비밀번호 보관(해시/솔트) — Argon2/Bcrypt

**절대 평문 저장 금지**. **단방향 해시** + **느린 KDF** 사용:

- **Argon2id(권장)** 또는 **bcrypt**  
- **개인 솔트는 KDF 내부에 자동 포함**  
- (선택) **애플리케이션 고정 pepper**(환경변수/시크릿)로 추가 강화  
- 해시 파라미터(작업량)는 **시간 경과에 따라 상승** — 재해시 전략

### 8.7.1 구현(argon2-cffi)

```python
# pip install argon2-cffi
# app/security/passwords.py
import os
from argon2 import PasswordHasher, exceptions

PEPPER = os.getenv("PASSWORD_PEPPER", "")  # 운영: 시크릿 스토어
ph = PasswordHasher(time_cost=2, memory_cost=256000, parallelism=8)  # 서버 스펙에 맞게 조정

def _peppered(pw: str) -> str:
    return pw + PEPPER

def hash_password(password: str) -> str:
    return ph.hash(_peppered(password))

def verify_password(password: str, hashed: str) -> bool:
    try:
        ok = ph.verify(hashed, _peppered(password))
        # 필요시 rehash (파라미터 변했을 때)
        if ph.check_needs_rehash(hashed):
            # DB에 최신 해시로 교체(로그인 시 투명 업그레이드)
            pass
        return ok
    except exceptions.VerifyMismatchError:
        return False
```

### 8.7.2 가입/로그인 예시

```python
# 가입
u = User(email=email, password_hash=hash_password(password))
db.session.add(u); db.session.commit()

# 로그인
if not verify_password(password, user.password_hash):
    ...
```

> **비밀번호 정책**: 길이(최소 12+), 유니코드 허용(패스프레이즈), 금지 목록(common password) 체크.

### 8.7.3 비밀번호 재설정(itsdangerous)

```python
# pip install itsdangerous
from itsdangerous import URLSafeTimedSerializer

ts = URLSafeTimedSerializer(app.config["SECRET_KEY"], salt="reset")

def make_reset_token(user_id: int) -> str:
    return ts.dumps({"uid": user_id})

def load_reset_token(token: str, max_age=3600) -> int | None:
    try:
        data = ts.loads(token, max_age=max_age)
        return data["uid"]
    except Exception:
        return None
```

---

## 8.8 레이트 리미팅(Brute-force 방어, API 보호)

**로그인/비밀번호 재설정/가입** 등은 **강력한 레이트 리밋**이 필수.

```python
# pip install flask-limiter
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(get_remote_address, default_limits=["200/minute"])

def init_rate_limit(app):
    limiter.init_app(app)
```

```python
# 로그인 시도 제한 (IP 기준 + 계정 기준 복합 권장)
@auth_bp.post("/login")
@limiter.limit("10/minute; 100/hour")
def login_submit():
    ...
```

사용자 기준 키:

```python
def key_func():
    email = request.form.get("email","").lower()
    return f"login:{email}"

@auth_bp.post("/login")
@limiter.limit("5/minute", key_func=key_func)
def login_submit():
    ...
```

**추가 방어**:

- 실패 횟수 누적 → 일정 시간 **계정 쿨다운**  
- 의심 활동 시 **CAPTCHA** 삽입  
- 성공 시 실패 카운터 초기화  
- 감사 로그에 IP/UA/Request-ID 기록

---

## 8.9 2FA / MFA(선택)

- **TOTP(앱 기반)**: 사용자마다 시크릿 저장, QR 발급, 30s 코드 검증  
- **WebAuthn**: 피싱 저항 강함(보안키/플랫폼 키)  
- **이메일/SMS OTP**: 편의는 높으나 피싱/가로채기 취약

> Flask에서는 **pyotp**(TOTP)나 **webauthn 라이브러리**로 구현.  
> 운영 도입 시 복구 코드/백업 수단/장치 분실 대응을 문서화.

---

## 8.10 공용 보안 헤더/감사 로깅/세션 타임아웃

### 8.10.1 헤더 묶음(재확인)

```python
@admin_bp.after_request
def security_headers(resp):
    resp.headers.setdefault("X-Content-Type-Options", "nosniff")
    resp.headers.setdefault("X-Frame-Options", "DENY")
    resp.headers.setdefault("Referrer-Policy", "strict-origin-when-cross-origin")
    resp.headers.setdefault("Permissions-Policy", "geolocation=(), microphone=()")
    return resp
```

### 8.10.2 감사 로깅(로그인/민감 동작)

```python
current_app.logger.info("auth.login", extra={
    "event": "auth.login",
    "user": user.id,
    "ip": request.remote_addr,
    "ua": request.headers.get("User-Agent"),
    "request_id": getattr(g, "request_id", None)
})
```

### 8.10.3 유휴 타임아웃

```python
# app/security/idle_timeout.py
import time
from flask import session
IDLE_LIMIT = 900  # 15분

def ping_activity():
    now = int(time.time())
    last = session.get("_last")
    session["_last"] = now
    if last and now - last > IDLE_LIMIT:
        # 강제 로그아웃
        session.clear()
        return False
    return True
```

모든 요청에서 호출:

```python
@app.before_request
def _idle_guard():
    if current_user.is_authenticated:
        if not ping_activity():
            flash("오랜 시간 활동이 없어 로그아웃되었습니다.", "info")
            return redirect(url_for("auth.login_form"))
```

---

## 8.11 운영 체크리스트

- [ ] **쿠키 보안 플래그**: Secure/HttpOnly/SameSite  
- [ ] **세션 재생성**: 로그인/권한 상승 시  
- [ ] **fresh login** 요구: 민감 동작  
- [ ] **RBAC/ABAC 정책** 중앙화 및 테스트  
- [ ] **JWT**: 키 회전, 짧은 access + 회전형 refresh, 블랙리스트/재사용 감지  
- [ ] **OAuth2/OIDC**: Code+PKCE, id_token 검증, 도메인 allowlist  
- [ ] **CSRF**: 세션 기반 요청에 토큰 필수(헤더/폼), SameSite 설정  
- [ ] **XSS**: autoescape, CSP, `safe` 최소화, 입력 정화(렌더 전)  
- [ ] **CORS**: 최소 허용, 크레덴셜 필요 시 출처 제한  
- [ ] **Clickjacking**: X-Frame-Options / frame-ancestors  
- [ ] **비밀번호**: Argon2/Bcrypt, 재해시, 금지 목록  
- [ ] **레이트 리미팅**: 로그인/재설정/가입, IP+계정 기준  
- [ ] **감사 로깅**: 로그인/민감 변경, Request-ID/Trace-ID 포함  
- [ ] **MFA**: 고위험 계정/관리자에 필수  
- [ ] **비밀키/토큰 보관**: 시크릿 매니저, 로테이션 계획

---

## 8.12 흔한 안티패턴

- **SameSite만 믿고 CSRF 미적용**  
- **Access 토큰을 LocalStorage 저장**(XSS로 탈취 가능)  
- **긴 수명의 JWT에 리프레시 미도입**(폐기 불가)  
- **remember-me를 무제한으로**(탈취 시 장기 위험)  
- **비밀번호 솔트/작업량 관리 부실**(해시 빠름=공격 쉬움)  
- **CORS 와일드카드 + 크레덴셜 허용**(브라우저 경고/위험)  
- **세션 타임아웃 없음**(공용 PC 위험)  
- **감사 로그 부재**(사고 조사 곤란)

---

## 8.13 통합 예제(요약 스캐폴딩)

```python
# app/__init__.py
from flask import Flask
from .extensions import init_extensions, login_mgr
from .security.headers import apply_security_headers
from .oauth.google import init_oauth
from .rate_limit import init_rate_limit

def create_app():
    app = Flask(__name__)
    app.config.from_mapping(
        SECRET_KEY="override",
        SESSION_COOKIE_SECURE=True, SESSION_COOKIE_HTTPONLY=True, SESSION_COOKIE_SAMESITE="Lax",
        REMEMBER_COOKIE_SECURE=True, REMEMBER_COOKIE_HTTPONLY=True, REMEMBER_COOKIE_SAMESITE="Lax",
    )
    init_extensions(app)
    init_oauth(app)
    apply_security_headers(app)
    init_rate_limit(app)

    from .blueprints.auth.views import auth_bp
    from .blueprints.auth.oidc import oidc_bp
    from .blueprints.site.views import site_bp
    from .blueprints.api.v1 import api_v1_bp

    app.register_blueprint(auth_bp, url_prefix="/auth")
    app.register_blueprint(oidc_bp)
    app.register_blueprint(site_bp)
    app.register_blueprint(api_v1_bp, url_prefix="/api/v1")
    return app
```

---

## 8.14 마무리

이 장에서는 **세션/쿠키와 Flask-Login(remember-me 포함)로의 안전한 인증**, **권한 부여(RBAC/ABAC) 패턴**, **JWT와 OAuth2/OIDC의 핵심 설계 포인트**, 그리고 **CSRF/XSS/CORS/Clickjacking 보안 헤더/전략**을 다뤘다. 또한 **비밀번호 해시(Argon2/Bcrypt)**, **레이트 리미팅**과 **감사 로깅/세션 타임아웃**까지 운영에 필요한 기초를 모두 정돈했다.