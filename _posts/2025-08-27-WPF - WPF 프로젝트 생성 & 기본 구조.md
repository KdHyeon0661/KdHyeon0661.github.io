---
layout: post
title: WPF - WPF 프로젝트 생성 & 기본 구조
date: 2025-08-27 19:25:23 +0900
category: WPF
---
# WPF 프로젝트 시작하기: 구조부터 최신 패턴까지

## WPF의 매력과 현대적 접근법

WPF(Windows Presentation Foundation)는 2006년 출시된 강력한 데스크톱 UI 프레임워크로, 데이터 바인딩, 템플릿, 스타일링, 애니메이션 등을 풍부하게 지원합니다. 2024년 현재, .NET 8의 최신 WPF는 성능이 크게 개선되었으며, 호스트 기반 DI 패턴과의 통합으로 더욱 견고한 애플리케이션을 구축할 수 있게 되었습니다.

```csharp
// 최신 WPF 프로젝트의 .csproj 파일
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <UseWPF>true</UseWPF>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <!-- Windows 11 테마 지원 -->
    <UseWindowsForms>false</UseWindowsForms>
    <ApplicationIcon>Assets\icon.ico</ApplicationIcon>
    <ApplicationManifest>app.manifest</ApplicationManifest>
  </PropertyGroup>
</Project>
```

## 프로젝트 생성: 다양한 도구와 옵션

### Visual Studio에서 생성
1. "새 프로젝트 생성" 선택
2. "WPF 애플리케이션(.NET)" 템플릿 선택
3. 프로젝트 이름과 위치 지정
4. 대상 프레임워크: .NET 8.0 (Windows) 권장
5. 추가 옵션: `Do not use top-level statements` 체크 권장

### .NET CLI 사용
```bash
# 최신 WPF 템플릿 설치
dotnet new install Microsoft.DotNet.Wpf.ProjectTemplates

# 프로젝트 생성
dotnet new wpf -n ModernWpfApp --framework net8.0-windows

# 또는 더 많은 제어를 원할 경우
dotnet new wpf -n ModernWpfApp \
  --framework net8.0-windows \
  --use-program-main \
  --output ModernWpfApp
```

### VS Code에서 개발
```bash
# 프로젝트 생성
dotnet new wpf -n MyWpfApp

# OmniSharp 확장 설치 후
# F5로 디버깅 시작
# launch.json과 tasks.json 자동 생성
```

## 프로젝트 구조 설계 철학

효율적인 WPF 프로젝트는 단순히 파일을 나열하는 것을 넘어, 역할과 책임에 따라 논리적으로 조직화되어야 합니다.

### 기본 구조 (신규 프로젝트)
```
MyWpfApp/
├── App.xaml                 # 애플리케이션 진입점
├── App.xaml.cs              # 애플리케이션 로직
├── MainWindow.xaml          # 메인 윈도우
├── MainWindow.xaml.cs       # 메인 윈도우 로직
└── Properties/
    └── AssemblyInfo.cs      # 어셈블리 메타데이터
```

### 확장된 MVVM 구조 (권장)
```
MyWpfApp/
├── App.xaml
├── App.xaml.cs
├── Program.cs               # 호스트 빌더 구성 (신규 패턴)
│
├── Views/                   # 사용자 인터페이스
│   ├── MainWindow.xaml
│   ├── LoginView.xaml
│   └── UserControls/
│       └── CustomButton.xaml
│
├── ViewModels/              # 프레젠테이션 로직
│   ├── MainViewModel.cs
│   ├── LoginViewModel.cs
│   └── ViewModelBase.cs
│
├── Models/                  # 도메인 모델
│   ├── User.cs
│   └── Product.cs
│
├── Services/                # 비즈니스 로직 및 외부 통신
│   ├── AuthenticationService.cs
│   ├── DataService.cs
│   └── DialogService.cs
│
├── Infrastructure/          # 기술적 기반 요소
│   ├── Converters/
│   ├── Behaviors/
│   └── Extensions/
│
├── Resources/               # 정적 리소스
│   ├── Images/
│   ├── Fonts/
│   └── Localization/
│
├── Themes/                  # 스타일 및 테마
│   ├── Colors.xaml
│   ├── Brushes.xaml
│   ├── Styles.xaml
│   └── Generic.xaml        # 커스텀 컨트롤 기본 스타일
│
└── AppSettings/            # 구성 및 설정
    ├── appsettings.json
    └── ConfigurationBuilder.cs
```

## 애플리케이션 생명주기 이해하기

### 전통적 접근법: StartupUri
```xml
<!-- App.xaml -->
<Application x:Class="MyWpfApp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="Views/MainWindow.xaml">
    <Application.Resources>
        <!-- 전역 리소스 정의 -->
    </Application.Resources>
</Application>
```

### 현대적 접근법: 프로그램 진입점 제어
```csharp
// Program.cs - .NET 6+ 스타일의 진입점
public class Program
{
    [STAThread]
    public static void Main(string[] args)
    {
        // 호스트 빌더 구성
        var host = Host.CreateDefaultBuilder(args)
            .ConfigureServices(services =>
            {
                ConfigureServices(services);
            })
            .Build();
        
        // 애플리케이션 시작
        var app = host.Services.GetRequiredService<App>();
        app.InitializeComponent();
        app.Run();
    }
    
    private static void ConfigureServices(IServiceCollection services)
    {
        // 서비스 등록
        services.AddSingleton<App>();
        services.AddSingleton<MainWindow>();
        services.AddSingleton<MainViewModel>();
        // ...
    }
}
```

## 리소스 관리와 Pack URI 마스터하기

### 빌드 작업의 이해
```csharp
// 이미지 파일의 빌드 작업 설정
public enum BuildAction
{
    Page,           // XAML 파일용
    Resource,       // 어셈블리 내부 포함 (Pack URI로 접근)
    Content,        // 출력 디렉토리로 복사 (경로로 접근)
    EmbeddedResource, // 전통적 임베드 리소스
    None            // 빌드에서 제외
}
```

### Pack URI 패턴
```xml
<!-- 다양한 Pack URI 사용 예 -->
<Image Source="pack://application:,,,/Resources/Images/logo.png" />
<Image Source="/Resources/Images/logo.png" />  <!-- 단축형 -->

<!-- 서브폴더의 리소스 -->
<Image Source="/Assets/Icons/home_32x32.png" />

<!-- 다른 어셈블리의 리소스 -->
<Image Source="pack://application:,,,/MyControls;component/Themes/Icons/add.png" />

<!-- 다국어 리소스 -->
<TextBlock Text="{x:Static res:Strings.WelcomeMessage}" />
```

### 동적 리소스 로딩
```csharp
public class ResourceManager
{
    public static BitmapImage LoadImage(string resourcePath)
    {
        var uri = new Uri($"pack://application:,,,/MyWpfApp;component/{resourcePath}");
        return new BitmapImage(uri);
    }
    
    public static ResourceDictionary LoadTheme(string themeName)
    {
        var uri = new Uri($"pack://application:,,,/Themes/{themeName}.xaml");
        return new ResourceDictionary { Source = uri };
    }
}
```

## 의존성 주입과 호스팅 패턴

### Generic Host 통합
```csharp
// App.xaml.cs
public partial class App : Application
{
    private readonly IHost _host;
    
    public App()
    {
        _host = CreateHostBuilder().Build();
        ServiceProvider = _host.Services;
    }
    
    public IServiceProvider ServiceProvider { get; }
    
    protected override async void OnStartup(StartupEventArgs e)
    {
        await _host.StartAsync();
        
        // 메인 윈도우 생성 (DI를 통한)
        var mainWindow = ServiceProvider.GetRequiredService<MainWindow>();
        mainWindow.Show();
        
        base.OnStartup(e);
    }
    
    protected override async void OnExit(ExitEventArgs e)
    {
        await _host.StopAsync();
        _host.Dispose();
        
        base.OnExit(e);
    }
    
    private static IHostBuilder CreateHostBuilder()
    {
        return Host.CreateDefaultBuilder()
            .ConfigureAppConfiguration((context, config) =>
            {
                config.AddJsonFile("appsettings.json", optional: true);
                config.AddEnvironmentVariables();
            })
            .ConfigureServices((context, services) =>
            {
                // 로깅 구성
                services.AddLogging(configure => 
                    configure.AddConfiguration(context.Configuration.GetSection("Logging"))
                             .AddConsole()
                             .AddDebug());
                
                // 뷰모델 등록
                services.AddSingleton<MainViewModel>();
                services.AddTransient<LoginViewModel>();
                
                // 서비스 등록
                services.AddSingleton<IAuthenticationService, AuthenticationService>();
                services.AddScoped<IDataService, DataService>();
                
                // 윈도우 등록
                services.AddSingleton<MainWindow>();
                services.AddTransient<LoginWindow>();
                
                // 호스티드 서비스
                services.AddHostedService<BackgroundWorkerService>();
            });
    }
}
```

### 뷰모델 주입 패턴
```csharp
// MainWindow.xaml.cs
public partial class MainWindow : Window
{
    public MainWindow(MainViewModel viewModel, 
                      IDialogService dialogService, 
                      ILogger<MainWindow> logger)
    {
        InitializeComponent();
        
        ViewModel = viewModel;
        DialogService = dialogService;
        Logger = logger;
        
        DataContext = ViewModel;
        
        // 로깅 예제
        Logger.LogInformation("MainWindow initialized");
    }
    
    public MainViewModel ViewModel { get; }
    public IDialogService DialogService { get; }
    public ILogger<MainWindow> Logger { get; }
}
```

## 테마와 스타일링 시스템

### 계층적 리소스 시스템
```xml
<!-- App.xaml - 전역 리소스 -->
<Application.Resources>
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <!-- 순서 중요: 나중에 선언된 것이 우선순위 높음 -->
            <ResourceDictionary Source="/Themes/Colors.xaml" />
            <ResourceDictionary Source="/Themes/Brushes.xaml" />
            <ResourceDictionary Source="/Themes/Typography.xaml" />
            <ResourceDictionary Source="/Themes/Styles.xaml" />
            <ResourceDictionary Source="/Themes/Templates.xaml" />
        </ResourceDictionary.MergedDictionaries>
        
        <!-- 직접 정의한 리소스 -->
        <SolidColorBrush x:Key="PrimaryBrush" Color="#0078D4" />
    </ResourceDictionary>
</Application.Resources>

<!-- Colors.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
    <Color x:Key="PrimaryColor">#0078D4</Color>
    <Color x:Key="SecondaryColor">#6C757D</Color>
    <Color x:Key="SuccessColor">#28A745</Color>
    <Color x:Key="DangerColor">#DC3545</Color>
</ResourceDictionary>

<!-- Styles.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    
    <!-- 기본 버튼 스타일 -->
    <Style x:Key="PrimaryButtonStyle" TargetType="Button">
        <Setter Property="Background" Value="{DynamicResource PrimaryBrush}" />
        <Setter Property="Foreground" Value="White" />
        <Setter Property="Padding" Value="12,8" />
        <Setter Property="BorderThickness" Value="0" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="Button">
                    <!-- 컨트롤 템플릿 정의 -->
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    
    <!-- 암시적 스타일 (해당 타입의 모든 컨트롤에 적용) -->
    <Style TargetType="TextBlock">
        <Setter Property="FontFamily" Value="Segoe UI" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="TextTrimming" Value="CharacterEllipsis" />
    </Style>
</ResourceDictionary>
```

### 동적 테마 전환
```csharp
public class ThemeService : IThemeService
{
    private readonly ResourceDictionary _lightTheme;
    private readonly ResourceDictionary _darkTheme;
    
    public ThemeService()
    {
        _lightTheme = new ResourceDictionary { 
            Source = new Uri("/Themes/Light.xaml", UriKind.Relative) 
        };
        _darkTheme = new ResourceDictionary { 
            Source = new Uri("/Themes/Dark.xaml", UriKind.Relative) 
        };
    }
    
    public void ApplyTheme(Theme theme)
    {
        var app = Application.Current;
        
        // 기존 테마 제거
        var existingThemes = app.Resources.MergedDictionaries
            .Where(rd => rd.Source?.OriginalString?.Contains("Themes/") == true)
            .ToList();
            
        foreach (var themeDict in existingThemes)
        {
            app.Resources.MergedDictionaries.Remove(themeDict);
        }
        
        // 새 테마 적용
        var newTheme = theme == Theme.Light ? _lightTheme : _darkTheme;
        app.Resources.MergedDictionaries.Add(newTheme);
        
        // 시스템 테마 감지
        if (theme == Theme.System)
        {
            ApplySystemTheme();
        }
    }
    
    private void ApplySystemTheme()
    {
        // Windows 시스템 테마 감지
        var systemTheme = IsDarkThemeEnabled() ? Theme.Dark : Theme.Light;
        ApplyTheme(systemTheme);
    }
}
```

## 성능 최적화와 모범 사례

### 시각적 트리 최적화
```csharp
public class PerformanceOptimization
{
    // VirtualizingStackPanel 사용 (대량 데이터 표시 시)
    public static ListBox CreateVirtualizedListBox()
    {
        return new ListBox
        {
            VirtualizingPanel.IsVirtualizing = true,
            VirtualizingPanel.VirtualizationMode = VirtualizationMode.Recycling,
            ItemsPanel = new ItemsPanelTemplate(
                new FrameworkElementFactory(typeof(VirtualizingStackPanel))
            )
        };
    }
    
    // UI 가상화 비활성화가 필요한 경우
    public static StackPanel CreateNonVirtualizedPanel()
    {
        return new StackPanel
        {
            VirtualizingPanel.IsVirtualizing = false
        };
    }
    
    // 이미지 로딩 최적화
    public static BitmapImage LoadImageOptimized(string path)
    {
        return new BitmapImage(new Uri(path))
        {
            CacheOption = BitmapCacheOption.OnLoad,  // 즉시 로딩
            CreateOptions = BitmapCreateOptions.IgnoreImageCache, // 캐시 무시
            DecodePixelWidth = 1920 // 크기 제한
        };
    }
}
```

### 데이터 바인딩 성능
```csharp
public class BindingOptimization
{
    // 바인딩 모드 최적화
    public static Binding CreateOptimizedBinding(string path)
    {
        return new Binding(path)
        {
            Mode = BindingMode.OneWay, // 필요한 경우에만 양방향
            UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged,
            Delay = 200, // 입력 지연 (검색 등)
            NotifyOnValidationError = true,
            ValidatesOnDataAnnotations = true
        };
    }
    
    // x:Bind 사용 (컴파일 타임 바인딩)
    public void ConfigureXBind()
    {
        // XAML에서:
        // <TextBlock Text="{x:Bind ViewModel.UserName, Mode=OneWay}" />
        // 더 빠르지만 디자인 타임 지원이 제한적
    }
}
```

## 배포와 패키징

### 단일 실행 파일 배포
```xml
<!-- .csproj에 추가 -->
<PropertyGroup>
  <PublishSingleFile>true</PublishSingleFile>
  <SelfContained>true</SelfContained>
  <RuntimeIdentifier>win-x64</RuntimeIdentifier>
  <IncludeNativeLibrariesForSelfExtract>true</IncludeNativeLibrariesForSelfExtract>
</PropertyGroup>
```

### ClickOnce 배포
```xml
<!-- 게시 프로필 설정 -->
<Project>
  <PropertyGroup>
    <ApplicationRevision>1</ApplicationRevision>
    <ApplicationVersion>1.0.0.*</ApplicationVersion>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <BootstrapperEnabled>true</BootstrapperEnabled>
    <UpdateRequired>true</UpdateRequired>
    <Install>true</Install>
  </PropertyGroup>
</Project>
```

### MSIX 패키징
```xml
<!-- Package.appxmanifest -->
<Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
         xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10">
  <Identity Name="MyWpfApp"
            Publisher="CN=MyCompany"
            Version="1.0.0.0" />
  
  <Properties>
    <DisplayName>My WPF App</DisplayName>
    <PublisherDisplayName>My Company</PublisherDisplayName>
    <Logo>Assets\StoreLogo.png</Logo>
  </Properties>
</Package>
```

## 결론: 현대적 WPF 개발의 핵심 원칙

WPF는 여전히 강력한 데스크톱 애플리케이션 개발 플랫폼입니다. 최신 .NET 생태계와의 통합으로 그 생명력은 더욱 강화되었습니다. 효과적인 WPF 개발을 위한 핵심 원칙을 정리해 보겠습니다:

### 1. 구조적 명확성 우선
- MVVM 패턴은 단순히 파일을 분리하는 것이 아닙니다. 각 계층의 책임을 명확히 정의하세요.
- 뷰는 오직 UI 표현만, 뷰모델은 프레젠테이션 로직만, 모델은 도메인 데이터만 담당하게 하세요.
- 서비스 계층을 도입하여 비즈니스 로직을 재사용 가능하게 분리하세요.

### 2. 현대적 도구와 패턴 활용
- Generic Host를 사용하여 DI, 구성, 로깅을 통합 관리하세요.
- async/await 패턴을 적극 활용하여 응답성을 유지하세요.
- 최신 C# 기능(records, pattern matching, nullable reference types)을 적절히 사용하세요.

### 3. 성능과 사용자 경험의 균형
- VirtualizingStackPanel로 대량 데이터 처리를 최적화하세요.
- 이미지와 리소스는 적절한 크기와 형식으로 로드하세요.
- 바인딩 모드를 상황에 맞게 선택하세요 (OneWay, TwoWay, OneTime).

### 4. 테스트 가능성 설계
- 뷰모델은 뷰에 의존하지 않게 설계하여 단위 테스트가 가능하게 하세요.
- 서비스는 인터페이스를 통해 추상화하여 목(mock) 객체로 대체 가능하게 하세요.
- DI 컨테이너를 사용하여 의존성을 관리하세요.

### 5. 접근성과 국제화 고려
- AutomationProperties를 사용하여 화면 읽기 프로그램을 지원하세요.
- 리소스 파일을 사용하여 다국어 지원을 구현하세요.
- 고대비 모드와 다양한 DPI 설정을 테스트하세요.

### 6. 점진적 개선 전략
- 기존 WinForms 애플리케이션을 한 번에 모두 WPF로 전환하지 마세요.
- UserControl을 사용하여 점진적으로 UI 컴포넌트를 교체하세요.
- 호환성 모드와 상호 운용성 기능을 활용하세요.

### 마지막 조언: 기술적 부채 관리

WPF 프로젝트에서 가장 큰 도전은 시간이 지남에 따라 쌓이는 기술적 부채입니다. 초기부터 견고한 아키텍처를 구축하고, 지속적인 리팩토링을 통해 코드 품질을 유지하세요. 팀원들과 코드 리뷰를 정기적으로 수행하고, 공통 컴포넌트와 유틸리티 라이브러리를 구축하여 생산성을 높이세요.

WPF는 단순히 UI를 그리는 도구를 넘어, 복잡한 비즈니스 요구사항을 충족시키는 강력한 애플리케이션을 구축할 수 있는 완전한 플랫폼입니다. 이 가이드가 제공하는 패턴과 원칙을 활용하여 유지보수하기 쉽고, 확장 가능하며, 사용자 친화적인 애플리케이션을 만들어 보세요.