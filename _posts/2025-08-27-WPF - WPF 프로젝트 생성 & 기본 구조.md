---
layout: post
title: WPF - WPF 프로젝트 생성 & 기본 구조
date: 2025-08-27 19:25:23 +0900
category: WPF
---
# WPF 프로젝트 생성 & 기본 구조 이해

이 글은 **WPF(.NET 6/7/8)** 기준으로, 프로젝트 생성부터 **파일/폴더 구조**, **시작 흐름(Startup)**, **리소스/빌드 액션**, **DI(의존성 주입) 기반 호스팅**까지 한 번에 잡는 실전 가이드입니다.

---

## 1. 프로젝트 생성 방법

### Visual Studio
1. **새 프로젝트** → **WPF App (.NET)** 선택  
2. 대상 프레임워크: `net8.0-windows` 권장  
3. 생성 후 `.csproj`에 `<UseWPF>true</UseWPF>` 확인

### CLI (dotnet)
```bash
dotnet new wpf -o MyWpfApp
cd MyWpfApp
dotnet run
```

### Rider / VS Code
- Rider: 새 프로젝트 → .NET → **WPF Application**  
- VS Code: `dotnet new wpf`로 생성하고 **C# 확장**을 사용해 빌드/디버깅

---

## 2. `.csproj` 핵심 옵션 이해

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0-windows</TargetFramework>
    <UseWPF>true</UseWPF>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <!-- 다중 타겟 시
    <TargetFrameworks>net8.0-windows;net6.0-windows</TargetFrameworks> -->
    <!-- 아이콘/버전/매니페스트 등도 여기서 관리 가능 -->
    <!-- <ApplicationIcon>Assets/app.ico</ApplicationIcon> -->
  </PropertyGroup>
</Project>
```

- **`UseWPF`**: WPF 빌드 파이프라인(XAML → BAML)을 활성화  
- **`netX.Y-windows`**: Windows 전용 TFM, WPF/WinForms API 사용 가능  
- 다중 타겟이 꼭 필요하지 않다면 **단일 타겟**이 빌드 속도/복잡성 측면에서 유리

---

## 3. 기본 파일 구성 & 역할

초기 생성 시 보통 다음 파일이 있습니다.

```
MyWpfApp/
├─ App.xaml            # 앱 전역 리소스/스타트업 선언(StartupUri 또는 Startup 이벤트)
├─ App.xaml.cs         # Application 파생 클래스(수명주기: Startup/Exit)
├─ MainWindow.xaml     # 기본 윈도우(뷰)
└─ MainWindow.xaml.cs  # 코드비하인드(InitializeComponent 등)
```

### App.xaml
- **전역 리소스**(`Application.Resources`)와 **시작 지점**을 정의  
- 단순 시작(자동): `StartupUri="MainWindow.xaml"`  
- 커스텀 시작(프로그램 로직/DI): `Startup="OnStartup"` 사용

```xml
<Application x:Class="MyWpfApp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Application.Resources>
    <ResourceDictionary>
      <ResourceDictionary.MergedDictionaries>
        <ResourceDictionary Source="Themes/Colors.xaml"/>
        <ResourceDictionary Source="Themes/Styles.xaml"/>
      </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
  </Application.Resources>
</Application>
```

### App.xaml.cs
- `InitializeComponent()`에서 **BAML 로드 → 객체 그래프 구성**
- `OnStartup`, `OnExit`에서 초기화/정리 작업 수행

```csharp
public partial class App : Application
{
    protected override void OnStartup(StartupEventArgs e)
    {
        base.OnStartup(e);
        var main = new MainWindow();
        main.Show();
    }
}
```

### MainWindow.xaml / .cs
- XAML에서 UI를 **선언형**으로 정의, 코드비하인드에서 필요한 최소한의 로직만
- 뷰모델 사용 시 `DataContext`를 주입(코드/DI/뷰-뷰모델 매핑 등)

```xml
<Window x:Class="MyWpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MyWpfApp" Height="420" Width="720">
  <Grid Margin="16">
    <TextBlock Text="Hello, WPF" FontSize="28" />
  </Grid>
</Window>
```

---

## 4. MVVM 지향 폴더 구조(권장)

규모가 커질수록 **역할 분리**가 중요합니다. 다음은 많이 쓰는 구조 예시입니다.

```
MyWpfApp/
├─ App.xaml / App.xaml.cs
├─ Views/                 # XAML View
│  └─ MainWindow.xaml
├─ ViewModels/            # 뷰모델(INotifyPropertyChanged)
│  └─ MainViewModel.cs
├─ Models/                # 순수 모델(POCO)
├─ Services/              # API/Repo/로컬스토리지/네이티브 연동
├─ Converters/            # IValueConverter
├─ Behaviors/             # 상호작용/Attached Behavior
├─ Controls/              # UserControl/CustomControl
├─ Resources/             # 이미지/폰트/문자열
├─ Themes/                # Colors.xaml, Styles.xaml, Generic.xaml(커스텀 컨트롤)
└─ Bootstrap/             # DI/호스트 초기화(선택)
```

---

## 5. 리소스 & Pack URI, 빌드 액션 제대로 알기

### 빌드 액션 요약

| 빌드 액션 | 용도 | 예 |
|---|---|---|
| **ApplicationDefinition** | `App.xaml` 전용 | 앱 엔트리/리소스 루트 |
| **Page** | `*.xaml`(Window/UserControl) | XAML→BAML 컴파일 |
| **Resource** | DLL 내부에 임베드, **Pack URI**로 접근 | 이미지, XAML 사전 등 |
| **Content** | 출력 폴더로 복사, **파일 경로로 접근** | 설정/샘플DB 등 |
| None/EmbeddedResource | 특수 케이스 | 필요 시 사용 |

### Pack URI 사용 예
```xml
<!-- 같은 어셈블리 내 Resource -->
<Image Source="pack://application:,,,/Resources/Images/logo.png"/>

<!-- 다른 어셈블리(MyLib) 리소스 -->
<Image Source="pack://application:,,,/MyLib;component/Themes/Icons/add.png"/>
```

> **Resource vs Content**  
> - 배포 파일 노출 없이 어셈블리 내부에 넣고 **XAML에서 바로 쓰기** → **Resource**  
> - 실행 폴더에 파일로 두고 외부 교체/업데이트 필요 → **Content + Copy to Output Directory**

---

## 6. 시작 흐름(Startup) 상세

### A) 단순 시작(StartupUri)
- 가장 간단: `App.xaml`에 `StartupUri="MainWindow.xaml"`
- 내부적으로 `MainWindow` 인스턴스 생성→`InitializeComponent`→`Show`

### B) 커스텀 시작(Startup 이벤트)
- 로그인 전/스플래시/환경 검사/다중 창 선택 등 **로직이 필요할 때**
- `App.xaml`에서 `Startup="OnStartup"` 지정 후 코드에서 창 생성/표시

```xml
<Application x:Class="MyWpfApp.App"
             ... 
             Startup="OnStartup" />
```

```csharp
public partial class App : Application
{
    protected override void OnStartup(StartupEventArgs e)
    {
        base.OnStartup(e);

        // 예: 인자/환경에 따라 다른 초기 창 선택
        Window shell = (e.Args.Contains("--admin"))
            ? new AdminWindow()
            : new MainWindow();

        shell.Show();
    }
}
```

---

## 7. DI(의존성 주입) + Generic Host로 부트스트랩(실무 추천)

WPF도 **Microsoft.Extensions.Hosting**을 써서 **구성/로깅/DI**를 통합 관리할 수 있습니다.

```csharp
// App.xaml.cs
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

public partial class App : Application
{
    private IHost? _host;

    protected override void OnStartup(StartupEventArgs e)
    {
        base.OnStartup(e);

        _host = Host.CreateDefaultBuilder(e.Args)
            .ConfigureServices(services =>
            {
                // ViewModel/Service 등록
                services.AddSingleton<MainViewModel>();
                services.AddSingleton<MainWindow>(); // 생성자에서 MainViewModel 주입
            })
            .Build();

        var main = _host.Services.GetRequiredService<MainWindow>();
        main.Show();
    }

    protected override async void OnExit(ExitEventArgs e)
    {
        if (_host is IHost h) { await h.StopAsync(); h.Dispose(); }
        base.OnExit(e);
    }
}
```

```csharp
// MainWindow.xaml.cs (생성자 주입)
public partial class MainWindow : Window
{
    public MainWindow(MainViewModel vm)
    {
        InitializeComponent();
        DataContext = vm;
    }
}
```

> 이 패턴을 쓰면 **API 클라이언트/로컬DB/설정(appsettings.json)** 등도 Host 구성에 자연스럽게 녹여서 테스트/유지보수가 쉬워집니다.

---

## 8. DPI/권한/매니페스트

고DPI/권한 설정이 필요하면 **app.manifest**를 추가해 관리합니다.

```xml
<!-- app.manifest (발췌) -->
<asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
  <asmv3:windowsSettings>
    <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true/pm</dpiAware>
  </asmv3:windowsSettings>
</asmv3:application>

<!-- 권한 상승이 필요한 경우(주의) -->
<requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
```

> 가능하면 **관리자 권한 회피** 설계가 바람직하며, DPI는 `true/pm`(Per-Monitor)로 고해상도 모니터에서도 선명도를 유지합니다.

---

## 9. 커스텀 컨트롤 라이브러리 주의점

- **CustomControl**(템플릿 기반)의 기본 스타일은 **`Themes/Generic.xaml`**에 둡니다.  
- 어셈블리 수준 `ThemeInfo` 속성이 필요합니다(최근 SDK 프로젝트는 자동 생성되는 경우가 많음).

```csharp
// Properties/AssemblyInfo.cs (필요 시)
using System.Windows;
[assembly: ThemeInfo(ResourceDictionaryLocation.None, ResourceDictionaryLocation.SourceAssembly)]
```

---

## 10. 첫 화면까지 연결되는 전체 흐름 요약

1. **App 생성자** → `InitializeComponent()`(BAML 로드, 전역 리소스 로드)  
2. **StartupUri** 또는 **OnStartup**에서 메인 윈도우 생성  
3. **MainWindow.InitializeComponent()** → XAML 로드/시각 트리 구성  
4. **DataContext** 설정(MVVM) → 바인딩 활성화  
5. 렌더링 파이프라인이 **Visual Tree**를 D3D로 컴포지션해 화면 표시

---

## 11. 빠른 체크리스트

- `.csproj`에 **`<UseWPF>true</UseWPF>`** 있는가?  
- **전역 리소스**는 `App.xaml`에, **화면별 리소스**는 각 View에  
- **Resource vs Content** 구분 및 **Pack URI** 숙지  
- MVVM 폴더 분리(특히 `ViewModels`, `Services`, `Resources/ Themes`)  
- 필요 시 **Generic Host**로 DI/설정/로깅 통합  
- **app.manifest**로 DPI/권한 정책 관리

---

필요하시면 위 구조를 바로 사용하는 **초기 템플릿(빈 MVVM/DI 골격)**도 만들어 드릴게요.  
또, 기존 솔루션을 **호스트/DI 기반으로 리팩토링**하는 단계별 스크립트도 제공 가능합니다.