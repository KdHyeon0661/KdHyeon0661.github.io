---
layout: post
title: 컴퓨터시스템 - UNIX I/O
date: 2025-08-24 20:20:23 +0900
category: 컴퓨터시스템
---
# UNIX I/O

> **정의**
> UNIX I/O는 유닉스 계열(리눅스, BSD, macOS)에서 **커널과 직접 통신**해 파일·디렉터리·파이프·소켓·디바이스를 다루는 **저수준 시스템 호출 집합**이다.
> 표준 I/O(`stdio`)보다 **세밀한 제어/일관 API/낮은 오버헤드**를 제공하지만, **버퍼링·오류 처리·부분 I/O**를 개발자가 책임져야 한다.

---

## 핵심 개념 — “모든 것은 파일이며 FD로 식별된다”

### 파일 디스크립터(File Descriptor, FD)

- **정수 핸들**. 각 프로세스는 **자기만의 FD 테이블**을 갖는다.
- 표준 FD: `0=STDIN_FILENO`, `1=STDOUT_FILENO`, `2=STDERR_FILENO`.
- **FD → Open File Description(커널 객체) → Inode/Vnode** 구조.
  - `dup/dup2/dup3` 또는 `fork()`로 복제한 FD들은 **같은 Open File Description**을 가리킬 수 있고, **파일 오프셋/플래그를 공유**한다(중요한 레이스 포인트).

### “모든 것은 파일”

- 정규 파일, 디렉터리, 파이프/소켓, TTY, 장치 노드, `eventfd`, `signalfd`, `timerfd` … **모두** 같은 인터페이스(`open/read/write/close`)로 접근.

---

## 필수 시스템 콜 — 안전한 사용 패턴까지

### `open/openat` — 열기(경쟁·보안 안전)

```c
#include <fcntl.h>

int fd = open("file.txt", O_RDONLY);                            // 기본
int dfd = open("/safe/dir", O_DIRECTORY | O_RDONLY | O_CLOEXEC);
int fd2 = openat(dfd, "cfg", O_RDONLY | O_NOFOLLOW | O_CLOEXEC);// 디렉터리 기준 안전 열기
```
- 일반 플래그: `O_RDONLY/O_WRONLY/O_RDWR`, `O_CREAT`(모드 필요), `O_TRUNC`, `O_APPEND`, `O_NONBLOCK`, `O_CLOEXEC`.
- **안전 생성**: `O_CREAT|O_EXCL`(존재 시 실패), 심볼릭 링크 금지: `O_NOFOLLOW`.
- **close-on-exec 누수 방지**는 **생성 시** `O_CLOEXEC`로(사후 `fcntl`은 레이스 여지).
- Linux 특화:
  - `O_TMPFILE`(익명 임시 파일; 같은 FS 내 `linkat`로 나중에 이름 붙이기)
  - `openat2`(보다 정교한 경로 검증)

### `read` / `write` — 부분 I/O·EINTR/EAGAIN

```c
#include <unistd.h>

ssize_t n = read(fd, buf, bufsz);   // 0: EOF, -1: 오류(errno)
ssize_t m = write(fd, buf, count);  // 요청보다 적게 쓸 수 있음 → 루프 필요
```
- **부분 I/O**(short read/write) 정상. 반드시 루프 처리.
- **EINTR**(시그널로 중단) → 재시도. **EAGAIN/EWOULDBLOCK**(논블로킹) → 준비 대기 후 재시도.

#### 안전 루프 템플릿

```c
#include <errno.h>

ssize_t read_full(int fd, void *buf, size_t want){
    size_t off=0; while (off<want){
        ssize_t r = read(fd, (char*)buf+off, want-off);
        if (r>0){ off+=r; continue; }
        if (r==0) break; // EOF
        if (errno==EINTR) continue;
        if (errno==EAGAIN) return off; // 논블로킹이면 상위에서 대기
        return -1;
    } return off;
}
ssize_t write_all(int fd, const void *buf, size_t n){
    size_t off=0; while (off<n){
        ssize_t w = write(fd, (char*)buf+off, n-off);
        if (w>0){ off+=w; continue; }
        if (w<0 && errno==EINTR) continue;
        if (w<0 && errno==EAGAIN) continue; // 상위에서 대기 후 루프 지속
        return -1;
    } return n;
}
```

### `close` — FD 수명

```c
#include <unistd.h>

int r = close(fd); // -1이면 실패(드물지만 EIO 등). EINTR는 재시도하지 않는 것이 통상 안전.
```
- `close()`는 **성공/실패 여부만** 보고, 실패 시 FD가 이미 닫혔다고 가정하는 것이 일반적 운영 관행.

### `lseek` — 파일 오프셋 제어(소켓/파이프 불가)

```c
#include <unistd.h>

off_t pos = lseek(fd, 0, SEEK_CUR); // 현재 위치
```
- **멀티스레드/복수 FD 공유 시 레이스**. 오프셋 의존 쓰기는 **`pwrite`**(원자 위치 쓰기) 권장.

### `pread/pwrite` — 오프셋 독립 I/O

```c
#include <unistd.h>

ssize_t n = pread(fd, buf, nbytes, offset);  // lseek과 독립, 레이스 없음
ssize_t m = pwrite(fd, buf, nbytes, offset); // DB/로그에 안전
```

### Scatter/Gather — `readv/writev`

{% raw %}
```c
#include <sys/uio.h>

struct iovec iov[2]={{.iov_base=hdr,.iov_len=hdrsz},{.iov_base=body,.iov_len=bodysz}};
ssize_t m = writev(fd, iov, 2); // 분산 버퍼를 한 번에 전송
```
{% endraw %}

### 고성능 편의 — `sendfile/splice/copy_file_range`

- `sendfile(out_fd, in_fd, &off, len)` : 커널 내 **제로-카피**(파일→소켓 등).
- `splice`/`tee`/`vmsplice` : 파이프 중심 데이터 경로 구성(고급).
- `copy_file_range` : 파일↔파일 복사 최적화(파일시스템 오프로딩 가능).

---

## 블로킹·논블로킹·다중화(io multiplexing)

### `select/poll/ppoll` 기본 패턴

```c
#include <poll.h>

int wait_readable(int fd, int timeout_ms){
    struct pollfd p={.fd=fd,.events=POLLIN};
    for(;;){
        int r=poll(&p,1,timeout_ms);
        if (r>0 && (p.revents&POLLIN)) return 0;
        if (r==0) { errno=ETIMEDOUT; return -1; }
        if (r<0 && errno==EINTR) continue;
        return -1;
    }
}
```
- 시그널 안전 버전: `pselect`/`ppoll`(별도 시그널 마스크).

### `epoll`(리눅스) — 많은 FD에 유리

- 엣지/레벨 트리거, O(1) 확장성. 대규모 네트워크 서버 표준.

---

## 파일 잠금과 동시성

### `flock`(어드바이저리 잠금)

```c
#include <sys/file.h>

flock(fd, LOCK_EX);   // 배타
flock(fd, LOCK_UN);
```

### `fcntl` 레코드 잠금(범위 지정)

```c
#include <fcntl.h>

struct flock lk={.l_type=F_WRLCK,.l_whence=SEEK_SET,.l_start=0,.l_len=0};
fcntl(fd, F_SETLKW, &lk);  // 파일 전체 쓰기 잠금(블록)
```
- **어드바이저리**(협조적)라서 모든 참여자가 지켜야 의미가 있다.

---

## 버퍼 캐시·Direct I/O·동기화

### 커널 버퍼 캐시

- 일반 `read/write`는 **페이지 캐시**를 거친다(읽기 재사용/쓰기 병합).

### `O_DIRECT` — 페이지 캐시 우회

- 장점: **이중 캐싱 회피**, 예측적 성능.
- 제약: **정렬/블록 크기 제약**, 응용이 직접 버퍼 정렬 관리.

### 동기화

```c
fsync(fd);         // 데이터+메타데이터
fdatasync(fd);     // 데이터 중심(메타데이터 일부 생략)
msync(addr,len,MS_SYNC); // mmap 동기화
```

### 공간 관리

```c
ftruncate(fd, size);           // 파일 길이 조정
posix_fallocate(fd, off, len); // 공간 미리 할당
```

---

## 신호와 I/O — `SIGPIPE`/`EPIPE`, `EINTR`

- 닫힌 파이프/소켓에 `write` → **`SIGPIPE`**(기본 종료) + `EPIPE`.
- 안전 패턴: 프로세스 시작 시 `signal(SIGPIPE, SIG_IGN);` 후 `EPIPE`를 오류로 처리.
- **EINTR**: 시그널로 중단된 블로킹 콜. **반드시 재시도 루프**.

---

## `dup/dup2/dup3` — FD 복제와 파이프라인

```c
#include <unistd.h>

int p[2]; pipe(p); // p[0]=read, p[1]=write]

dup2(p[1], STDOUT_FILENO); // stdout을 파이프에 연결
close(p[1]);               // 중복 FD 정리
```
- **주의**: `dup/dup2`로 복제한 FD는 **같은 오프셋**을 공유한다.
- 안전한 exec 전 FD 누수 방지: `O_CLOEXEC`/`FD_CLOEXEC`.

---

## 메모리 매핑 I/O — `mmap/munmap/mprotect`

```c
#include <sys/mman.h>

void *p = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
if (p==MAP_FAILED) { /* handle */ }
// ... p를 메모리처럼 접근 ...
msync(p, len, MS_SYNC); // 필요 시 디스크 동기화
munmap(p, len);
```
- 장점: **페이지 단위 캐싱**, 랜덤 접근 효율, IPC 공유.
- 주의: 파일 크기보다 크게 접근 시 **SIGBUS**. 권한 불일치 시 **SIGSEGV**.

---

## 파이프·FIFO·소켓의 고유 성질

- 파이프/소켓 `write`의 **원자성 보장**: 크기가 `<= PIPE_BUF`(리눅스 일반적으로 4096)인 write는 **원자적**.
- FIFO(named pipe): 파일 경로로 접근하는 파이프.
- 소켓은 주소 체계(AF_INET/UNIX 등)·옵션(`SO_REUSEADDR`, `TCP_NODELAY`) 포함.

---

## 실전 예제 모음

### 안전한 파일 복사 — `sendfile` 버전(커널 제로-카피)

```c
#include <sys/sendfile.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv){
    if (argc!=3){ fprintf(stderr,"usage: %s src dst\n",argv[0]); return 1; }

    int s = open(argv[1], O_RDONLY | O_CLOEXEC);
    if (s<0){ perror("open src"); return 1; }
    int d = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0644);
    if (d<0){ perror("open dst"); close(s); return 1; }

    struct stat st; if (fstat(s,&st)<0){ perror("fstat"); }
    off_t off = 0; ssize_t left = st.st_size;
    while (left>0){
        ssize_t sent = sendfile(d, s, &off, left);
        if (sent>0){ left -= sent; continue; }
        if (sent<0 && errno==EINTR) continue;
        perror("sendfile"); break;
    }
    close(s); close(d);
    return left?1:0;
}
```

### 논블로킹 FD + `poll`로 한 번 읽기

```c
#include <fcntl.h>

int fd = open("fifo", O_RDONLY | O_NONBLOCK | O_CLOEXEC);
char buf[4096];
struct pollfd p={.fd=fd,.events=POLLIN};
if (poll(&p,1,2000)==1 && (p.revents&POLLIN)){
    ssize_t n = read(fd, buf, sizeof buf);
    // n>=0 처리, n<0이면 EINTR/EAGAIN 고려
}
```

### 원자적 append 로그(경합 안전)

```c
int fd = open("app.log", O_WRONLY|O_CREAT|O_APPEND|O_CLOEXEC, 0644);
write_all(fd, rec, len); // O_APPEND + write는 커널이 위치 이동+쓰기를 원자적으로 수행
```

### 랜덤 쓰기 경쟁 방지 — `pwrite`

```c
// 여러 스레드/프로세스가 같은 파일 다른 위치에 쓰는 로깅
pwrite(fd, record, len, offset); // lseek 불필요, 위치 경쟁 없음
```

### 안전 생성 — 경로 조작(TOCTTOU) 방지

```c
int dfd = open("/srv/app", O_DIRECTORY|O_RDONLY|O_CLOEXEC);
int fd  = openat(dfd, "conf.json",
                 O_CREAT|O_EXCL|O_WRONLY|O_NOFOLLOW|O_CLOEXEC, 0640);
```

---

## errno·오류 처리·타임아웃(데드라인) 패턴

- 성공은 `errno`를 0으로 만들 의무가 없다 → **오류 직후에만** `errno` 사용.
- **데드라인** 기반 대기(모노토닉 시계) 권장:
```c
#include <time.h>
#include <poll.h>

int wait_rw_deadline(int fd, short ev, const struct timespec *deadline){
    for(;;){
        struct timespec now; clock_gettime(CLOCK_MONOTONIC, &now);
        long ns = (deadline->tv_sec - now.tv_sec)*1000000000L
                + (deadline->tv_nsec - now.tv_nsec);
        if (ns <= 0) { errno=ETIMEDOUT; return -1; }
        struct timespec rem={ns/1000000000L, ns%1000000000L};
        struct pollfd p={.fd=fd,.events=ev};
        int r = ppoll(&p,1,&rem,NULL);
        if (r>0 && (p.revents&ev)) return 0;
        if (r==0) { errno=ETIMEDOUT; return -1; }
        if (r<0 && errno==EINTR) continue;
        return -1;
    }
}
```

---

## UNIX I/O vs. stdio(`fopen/fread/fwrite`) — 언제 무엇을?

| 관점 | UNIX I/O | stdio |
|---|---|---|
| 버퍼링 | 없음(호출마다 커널 진입) | 내부 버퍼(작은 I/O 효율 ↑) |
| 제어 | 세밀(플래그/논블로킹/다중화) | 포맷/행 단위 편의 ↑ |
| 성능 | 대량 I/O·제로-카피·비동기 최적화 | 일반 텍스트 처리 편리 |
| 이식성 | OS 의존 세부 | ANSI C 표준 |

**가이드**
- CLI 도구/텍스트 처리: stdio 우선, 성능 병목 시 `setvbuf`/UNIX I/O로 전환.
- 서버/DB/스토리지: UNIX I/O, `epoll`/`sendfile`/`pwrite`, 비동기(io_uring 등) 조합.

---

## 고급 주제 스냅샷

- **io_uring(리눅스)**: 커널·유저 공간 큐 공유로 저오버헤드 비동기 I/O.
- **AIO(POSIX)**: 레거시 비동기 I/O(제약 다수).
- **posix_fadvise**: 프리페치/순차 접근 힌트.
- **splice/tee**: 파이프 중심 무복사 경로.
- **eventfd/timerfd/signalfd**: FD로 이벤트 통일 → `epoll` 통합.

---

## 성능·모델링 메모

페이지 캐시 적중률을 \(h\), 디스크 I/O 평균 지연을 \(T_d\), DRAM 접근을 \(T_m\)라 하면, 평균 접근 지연
$$
T \approx h\,T_m + (1-h)\,T_d
$$
→ **적중률** \(h\) 향상이 지연을 급감시킨다. 순차 접근·프리페치·적절한 페이지 크기 선택이 관건.

---

## 점검 체크리스트(실무)

- [ ] 모든 `read/write`는 **부분 I/O** 대비 루프
- [ ] `EINTR/EAGAIN` 처리, **데드라인/타임아웃** 존재
- [ ] `SIGPIPE` 무시 또는 `MSG_NOSIGNAL` 사용
- [ ] 생성은 `openat` + `O_CLOEXEC|O_NOFOLLOW|O_EXCL`
- [ ] 레이스 민감: 위치 의존 쓰기는 **`pwrite`**
- [ ] 동기화 경로: `fsync/fdatasync/msync` 오류 확인
- [ ] 멀티 FD 공유오프셋 주의(`dup/fork`)
- [ ] 대량 복사: `sendfile/copy_file_range` 검토
- [ ] 성능 관찰: `strace -ttT`, `perf`, `iotop`, `blktrace`

---

## 마무리

UNIX I/O는 **단순하지만 강력**하다.
**FD/오프셋/부분 I/O/errno/다중화**의 기초 규율만 지키면,
파일·네트워크·장치·IPC를 하나의 일관된 모델로 다루며 **최적의 제어와 성능**을 얻을 수 있다.
표준 I/O로 시작하되, **정밀 제어/고성능**이 필요해지는 지점에서 **UNIX I/O로 내려가라** — 그것이 현대 리눅스 시스템 프로그래밍의 정석이다.
