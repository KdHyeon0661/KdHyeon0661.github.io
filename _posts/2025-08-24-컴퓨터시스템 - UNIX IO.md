---
layout: post
title: 컴퓨터시스템 - UNIX I/O
date: 2025-08-24 20:20:23 +0900
category: 컴퓨터시스템
---
# UNIX I/O — 개념, 동작 원리, 특징, 예제

`UNIX I/O`는 리눅스, macOS, BSD 등 유닉스 계열 운영체제에서 제공하는 **저수준(시스템 호출 기반) 입출력 API**입니다.  
C의 표준 입출력(`stdio.h`)과 달리, **커널과 직접 통신**하여 파일, 소켓, 디바이스 등 모든 입출력 자원을 다룹니다.

---

## 1. UNIX I/O의 핵심 개념

### 1.1 모든 것은 파일이다
- 유닉스에서는 **파일, 디렉터리, 네트워크 소켓, 파이프, 장치(디스크, 터미널, 프린터 등)** 모두 파일로 취급.
- 따라서 동일한 시스템 콜(`open`, `read`, `write`, `close`)로 다양한 I/O를 처리 가능.

### 1.2 파일 디스크립터(File Descriptor, FD)
- **정수 값**으로, 커널이 관리하는 열린 파일 테이블의 인덱스.
- 프로세스마다 독립된 FD 테이블을 가지며, 표준 FD가 미리 열려 있음:
  | FD 번호 | 의미 | 헤더 상 매크로 |
  |---|---|---|
  | 0 | 표준 입력 | `STDIN_FILENO` |
  | 1 | 표준 출력 | `STDOUT_FILENO` |
  | 2 | 표준 오류 | `STDERR_FILENO` |

---

## 2. 주요 시스템 콜

### 2.1 `open` — 파일 열기
```c
#include <fcntl.h>
int fd = open("file.txt", O_RDONLY);
```
- 주요 플래그:
  - `O_RDONLY`, `O_WRONLY`, `O_RDWR`
  - `O_CREAT` (파일 없으면 생성, `mode` 필요)
  - `O_TRUNC` (열 때 길이 0으로)
  - `O_APPEND` (끝에만 쓰기)
- 반환: 파일 디스크립터 (실패 시 -1)

---

### 2.2 `read` — 읽기
```c
#include <unistd.h>
ssize_t n = read(fd, buf, sizeof buf);
```
- 반환값:
  - **양수**: 읽은 바이트 수
  - **0**: EOF (더 이상 읽을 데이터 없음)
  - **-1**: 오류

---

### 2.3 `write` — 쓰기
```c
#include <unistd.h>
ssize_t n = write(fd, buf, count);
```
- **반드시 요청한 바이트 수를 다 쓰지 않을 수 있음** → 루프 필요.

---

### 2.4 `close` — 닫기
```c
#include <unistd.h>
close(fd);
```
- FD 해제, 커널 리소스 반환.
- 프로세스 종료 시 커널이 자동으로 닫지만, 명시적으로 닫는 것이 안전.

---

## 3. 예제 — 파일 복사기

```c
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

#define BUF_SIZE 4096

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "사용법: %s <src> <dst>\n", argv[0]);
        exit(1);
    }

    int in_fd = open(argv[1], O_RDONLY);
    if (in_fd < 0) { perror("open src"); exit(1); }

    int out_fd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (out_fd < 0) { perror("open dst"); close(in_fd); exit(1); }

    char buf[BUF_SIZE];
    ssize_t n;
    while ((n = read(in_fd, buf, BUF_SIZE)) > 0) {
        ssize_t written = 0;
        while (written < n) {
            ssize_t w = write(out_fd, buf + written, n - written);
            if (w < 0) { perror("write"); close(in_fd); close(out_fd); exit(1); }
            written += w;
        }
    }

    if (n < 0) perror("read");

    close(in_fd);
    close(out_fd);
    return 0;
}
```
- **부분 쓰기 처리** 포함.
- 권장 버퍼 크기는 `PIPE_BUF` 이상(파이프) 또는 `BUFSIZ` 이상(일반 파일).

---

## 4. UNIX I/O의 특징

### 4.1 장점
- 범용성: 파일, 디바이스, 네트워크 모두 동일 API
- 세밀한 제어: 비차단 모드, 파일 잠금, 메모리 매핑 등 가능
- `select`, `poll`, `epoll` 등과 조합 가능 (비동기 I/O)

### 4.2 단점
- 버퍼링 없음 → 소량 I/O에 비효율적 (성능 저하)
- 이식성 고려 필요 (일부 플래그/동작은 OS별 차이)
- 직접 처리해야 하는 부분이 많음 (부분 쓰기, 오류 재시도 등)

---

## 5. 고급 주제

### 5.1 비차단 I/O
```c
int fd = open("fifo", O_RDONLY | O_NONBLOCK);
```
- `read`/`write`가 즉시 반환 (데이터 없으면 `EAGAIN`).

### 5.2 파일 위치 제어 — `lseek`
```c
off_t pos = lseek(fd, 0, SEEK_SET); // 파일 처음으로 이동
```
- 랜덤 접근 가능.
- `lseek`은 소켓/파이프/터미널에는 적용 불가.

### 5.3 원자적 연산
- `O_APPEND` + `write` → 원자적 append 보장 (멀티프로세스 환경)

### 5.4 Direct I/O
- `O_DIRECT`: 커널 버퍼 캐시 우회 (DBMS 등에서 사용)
- 정렬된 버퍼 필요, 성능 튜닝 목적

---

## 6. UNIX I/O vs. C 표준 I/O

| 항목 | UNIX I/O | C 표준 I/O (`stdio.h`) |
|---|---|---|
| 버퍼링 | 없음 | 내부 버퍼 있음 |
| 단위 | 바이트 단위 | 레코드/포맷 단위 가능 |
| 성능 | 소량 I/O 시 느림 | 버퍼링 덕분에 일반적으로 빠름 |
| 제어 | 낮음(직접) | 높음(고수준 기능) |
| 이식성 | OS 종속 | ANSI C 표준 |

**예시**: `printf`는 내부 버퍼 → 여러 번 `write` 대신 한 번에 호출.  
`write`는 호출 시마다 커널 진입.

---

## 7. 오류 처리 팁

- `errno`로 상세 원인 확인:
```c
#include <errno.h>
if (read(fd, buf, n) < 0) {
    perror("read");
    if (errno == EINTR) { /* 시그널로 중단 → 재시도 */ }
}
```
- **EINTR 재시도 루프**:
```c
ssize_t safe_read(int fd, void *buf, size_t n) {
    ssize_t r;
    do { r = read(fd, buf, n); } while (r < 0 && errno == EINTR);
    return r;
}
```

---

## 8. 결론

- **UNIX I/O = OS 레벨 저수준 I/O 인터페이스**
- 장점: 범용성, 직접 제어 가능
- 단점: 버퍼링 없음, 직접 관리 필요
- 고성능/고제어 환경(DBMS, 서버, OS 프로그래밍 등)에 필수
- 보통은 표준 I/O(`fopen`, `fread`)를 사용하되, **정밀 제어 시 UNIX I/O 사용**