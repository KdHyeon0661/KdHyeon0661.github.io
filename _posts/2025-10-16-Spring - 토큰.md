---
layout: post
title: Spring - 토큰
date: 2025-10-16 16:25:23 +0900
category: Spring
---
# 보안 — 토큰/실전

> 목표: **JWT**의 구조·발급·만료·리프레시 전략을 정확히 잡고, **OAuth2/OIDC(구글·네이버 로그인)**를 스프링 시큐리티로 붙여 **세션/토큰 하이브리드**를 안전하게 운영하며, **Method Security**와 **도메인 권한**을 설계·구현하는 데 필요한 모든 실전 포인트를 한 번에 정리한다.
> 환경 가정: Spring Boot 3.3+, Spring Security 6.x, Java 21. JWT 파싱은 **Nimbus**(스프링 리소스 서버 내장) 또는 **jjwt** 등. OIDC 공급자: Google, Naver.

---

## A. JWT 기초 — 구조/서명/클레임/키 회전

### A-1. 구조(JWS 기준)

`<Base64Url(header)>.<Base64Url(payload)>.<Base64Url(signature)>`

- **Header**: `{"alg":"RS256","typ":"JWT","kid":"2025-01-key"}`
- **Payload(Claims)**: 표준: `iss`(발급자), `sub`(사용자 id), `aud`(수신자), `exp`(만료), `iat`(발급시각), `nbf`(Not Before)
  - 커스텀: `roles`/`scope`, `tenant`, `email`, `name` 등
- **Signature**: `sign( base64url(header)+"."+base64url(payload), privateKey )`

> **JWS vs JWE**: 대부분은 **JWS(서명)**만 사용(가볍고 캐시 친화). 극히 민감한 페이로드라면 **JWE(암호화)** 고려.

### A-2. 알고리즘 & 키

- 대칭: **HS256**(간단, 키 유출에 취약·서버 하나만 추천)
- 비대칭: **RS256/RS512**, **ES256**(권장; 공개키 배포 쉬움, 회전 용이)
- **키 회전(Key Rotation)**: `kid` 부여 → 서버는 **JWKS(공개키 세트)**로 검증. 발급자는 현재 private key로 서명, 과거 키는 유예기간 유지.

### 기본

- **Access Token**: 짧게(5~15분) — 탈취 피해 최소화
- **Refresh Token**: 길게(7~30일) — 서버 저장/검증이 필요(회전·블랙리스트·재사용 감지)

---

## B. 스프링에서 JWT “검증” 붙이기 — Resource Server

### B-1. 의존성

```kotlin
dependencies {
  implementation("org.springframework.boot:spring-boot-starter-security")
  implementation("org.springframework.boot:spring-boot-starter-oauth2-resource-server")
}
```

### 또는 대칭키 설정

```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          # 1) OIDC 공급자(JWKS 엔드포인트) 사용 시
          issuer-uri: https://auth.example.com
          # 2) 또는 JWK 셋 직접
          # jwk-set-uri: https://auth.example.com/.well-known/jwks.json
          # 3) 또는 대칭키(HS256) — 테스트 용
          # secret: "super-secret-please-rotate"
```

### B-3. SecurityFilterChain (Stateless)

{% raw %}
```java
@Configuration
public class ApiSecurity {

  @Bean
  SecurityFilterChain api(HttpSecurity http) throws Exception {
    http
      .securityMatcher("/api/**")
      .csrf(csrf -> csrf.disable())
      .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
      .authorizeHttpRequests(auth -> auth
        .requestMatchers("/api/public/**").permitAll()
        .requestMatchers(HttpMethod.GET, "/api/orders/**").hasAuthority("SCOPE_order:read")
        .requestMatchers(HttpMethod.POST,"/api/orders/**").hasAuthority("SCOPE_order:write")
        .anyRequest().authenticated())
      .oauth2ResourceServer(oauth2 -> oauth2.jwt(jwt -> jwt
        .jwtAuthenticationConverter(jwtAuthenticationConverter())));
    return http.build();
  }

  // scope → 권한 매핑(`SCOPE_...`) 커스터마이즈
  Converter<Jwt, ? extends AbstractAuthenticationToken> jwtAuthenticationConverter() {
    var converter = new JwtGrantedAuthoritiesConverter();
    converter.setAuthorityPrefix("SCOPE_");
    converter.setAuthoritiesClaimName("scope"); // 또는 "scp", "authorities"
    return new JwtAuthenticationConverter() {{
      setJwtGrantedAuthoritiesConverter(converter);
    }};
  }
}
```
{% endraw %}

> 포인트: **리소스 서버**는 “검증만” 한다. **발급(서명)**은 별도 **Auth 서버**(내부 구현/Keycloak/Okta/스프링 Authorization Server)에서 처리.

---

## 스니펫

> 상용에선 **Spring Authorization Server** 권장. 여기서는 **커스텀 발급기**의 핵심만 스케치.

### C-1. 의존성(예: jjwt)

```kotlin
dependencies {
  implementation("io.jsonwebtoken:jjwt-api:0.12.5")
  runtimeOnly("io.jsonwebtoken:jjwt-impl:0.12.5")
  runtimeOnly("io.jsonwebtoken:jjwt-jackson:0.12.5")
}
```

### C-2. 키 관리(예: RSA)

```java
@Component
public class JwtKeys {
  private final KeyPair pair;  // load from keystore / Vault
  private final String kid = "2025-01-key";

  public JwtKeys() { this.pair = Keys.keyPairFor(SignatureAlgorithm.RS256); } // demo
  public PrivateKey privateKey(){ return pair.getPrivate(); }
  public PublicKey publicKey(){ return pair.getPublic(); }
  public String kid(){ return kid; }
}
```

### C-3. 액세스/리프레시 발급

```java
@Service
public class TokenService {

  private final JwtKeys keys;

  public record Tokens(String accessToken, String refreshToken, long accessExp, long refreshExp) {}

  public Tokens issue(String subject, List<String> scopes) {
    Instant now = Instant.now();
    long accessSec = 900;       // 15m
    long refreshSec = 1209600;  // 14d

    String at = Jwts.builder()
      .header().add("kid", keys.kid()).and()
      .subject(subject)
      .issuer("https://auth.example.com")
      .claim("scope", String.join(" ", scopes))
      .issuedAt(Date.from(now))
      .expiration(Date.from(now.plusSeconds(accessSec)))
      .signWith(keys.privateKey(), Jwts.SIG.RS256)
      .compact();

    String rt = Jwts.builder()
      .header().add("kid", keys.kid()).and()
      .subject(subject)
      .issuer("https://auth.example.com")
      .claim("type", "refresh")
      .issuedAt(Date.from(now))
      .expiration(Date.from(now.plusSeconds(refreshSec)))
      .signWith(keys.privateKey(), Jwts.SIG.RS256)
      .compact();

    return new Tokens(at, rt, now.plusSeconds(accessSec).getEpochSecond(), now.plusSeconds(refreshSec).getEpochSecond());
  }
}
```

---

## D. 리프레시 토큰 전략 — 회전/재사용 감지/블랙리스트

### D-1. 왜 회전(Rotation)인가

- RT 탈취 시 **무기한 갱신**을 차단.
- 매 갱신 때 **새 RT** 발급 + **이전 RT 폐기** → “재사용” 시도 감지 즉시 **세션 전면 무효화**.

### D-2. 서버 측 저장 모델

- 테이블: `refresh_token(id, user_id, token_hash, issued_at, expires_at, revoked, replaced_by, user_agent, ip)`
- **해시 저장**(원문 저장 금지) + 인덱스
- 갱신 시:
  1) 기존 RT **유효/미폐기** 확인
  2) 새 RT 발급, 기존 RT에 `replaced_by` 링크 / `revoked=true`
  3) **재사용 감지**: 폐기된 RT로 요청 오면 **전 계열 폐기 + 알림/로그아웃**

### D-3. API 예시

```java
@RestController
@RequestMapping("/auth")
class AuthController {

  private final TokenService tokens;
  private final RefreshTokenService rts;

  @PostMapping("/token")
  public Tokens login(@RequestBody LoginRequest req) {
    // 사용자 인증(비밀번호) → 성공 시
    var scopes = List.of("order:read","order:write");
    var t = tokens.issue(req.username(), scopes);
    rts.store(req.username(), t.refreshToken()); // hash+메타 저장
    return t;
  }

  @PostMapping("/token/refresh")
  public Tokens refresh(@RequestBody Map<String,String> body) {
    String rt = body.get("refresh_token");
    rts.validateAndRotate(rt); // 재사용 감지/블랙리스트/만료 체크
    var scopes = rts.scopesOf(rt);
    var sub = rts.subjectOf(rt);
    var t = tokens.issue(sub, scopes);
    rts.replace(rt, t.refreshToken());
    return t;
  }

  @PostMapping("/logout")
  public void logout(@RequestBody Map<String,String> body) {
    rts.revokeAllForSubject(body.get("sub")); // 모든 RT 폐기
  }
}
```

### D-4. 슬라이딩 vs 절대 만료

- **슬라이딩**: 갱신마다 RT 만료를 “연장”(UX↑, 탈취 리스크↑)
- **절대 만료**: RT는 “최대 생존시간(Absolute TTL)”을 두고 그 안에서만 회전(보안↑)

> 권장: **RT 회전 + 절대 만료(예: 30d)** + **디바이스별 RT**(기기 관리/폐기 가능).

---

## E. OAuth2/OIDC — 구글/네이버 로그인 붙이기

### E-1. 왜 OIDC인가?

- OAuth2는 “위임(Authorization)” 표준, **사용자 정보/세션 식별**엔 **OIDC**(OAuth2 위에 ID 토큰) 필요.
- 구글은 OIDC 1.0 완전 지원. 네이버는 OAuth2 + 사용자 API(프로바이더 메타 상 OIDC 미흡) → **OAuth2 Login**으로 충분.

### E-2. 의존성

```kotlin
dependencies {
  implementation("org.springframework.boot:spring-boot-starter-oauth2-client")
  implementation("org.springframework.boot:spring-boot-starter-security")
  implementation("org.springframework.boot:spring-boot-starter-web")
  implementation("org.springframework.boot:spring-boot-starter-thymeleaf") // 로그인 버튼
}
```

### E-3. application.yml (구글 + 네이버)

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: YOUR_GOOGLE_CLIENT_ID
            client-secret: YOUR_GOOGLE_CLIENT_SECRET
            scope: [ openid, profile, email ]
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
          naver:
            client-id: YOUR_NAVER_CLIENT_ID
            client-secret: YOUR_NAVER_CLIENT_SECRET
            client-authentication-method: client_secret_post
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
            scope: [ name, email ]
        provider:
          naver:
            authorization-uri: https://nid.naver.com/oauth2.0/authorize
            token-uri:         https://nid.naver.com/oauth2.0/token
            user-info-uri:     https://openapi.naver.com/v1/nid/me
            user-name-attribute: response   # 네이버는 응답 최상위가 'response'
```

### E-4. SecurityFilterChain (OAuth2 Login)

```java
@Configuration
public class WebLoginSecurity {

  @Bean
  SecurityFilterChain web(HttpSecurity http) throws Exception {
    http
      .authorizeHttpRequests(a -> a
        .requestMatchers("/", "/login", "/css/**").permitAll()
        .anyRequest().authenticated())
      .oauth2Login(o -> o
        .loginPage("/login")
        .userInfoEndpoint(ui -> ui
          .oidcUserService(oidcUserService())                // 구글
          .userService(oauth2UserService()))                 // 네이버
        .successHandler(successHandler()));
    return http.build();
  }
}
```

### E-5. 사용자 속성 매핑

```java
@Bean
OAuth2UserService<OidcUserRequest, OidcUser> oidcUserService() {
  var delegate = new OidcUserService();
  return req -> {
    OidcUser user = delegate.loadUser(req);
    // user.getClaims(): sub, email, name, picture, ...
    // 최초 로그인 시 내부 User 테이블에 upsert, 권한 매핑
    return user; // 필요 시 커스텀 OidcUser로 wrap
  };
}

@Bean
OAuth2UserService<OAuth2UserRequest, OAuth2User> oauth2UserService() {
  var delegate = new DefaultOAuth2UserService();
  return req -> {
    OAuth2User user = delegate.loadUser(req);
    Map<String, Object> attributes = user.getAttributes();
    // 네이버 구조: { resultcode, message, response: { id, email, name, ... } }
    Map<String, Object> resp = (Map<String, Object>) attributes.get("response");
    String id = (String) resp.get("id");
    String email = (String) resp.get("email");
    // 내부 사용자 upsert, 권한 매핑
    var authorities = List.of(new SimpleGrantedAuthority("ROLE_USER"));
    return new DefaultOAuth2User(authorities, resp, "id");
  };
}
```

### E-6. OAuth2 로그인 → JWT로 전환(하이브리드)

> “웹은 세션으로 로그인하지만, SPA/모바일 클라이언트에 **JWT**를 내려서 `/api/**` 호출” 패턴

- 성공 핸들러에서 **JWT 발급** + 프론트로 **전달**(쿠키/리디렉션 fragment/JS 대체):
```java
AuthenticationSuccessHandler successHandler() {
  return (req, res, auth) -> {
    var principal = (OAuth2User) auth.getPrincipal();
    String sub = principal.getName(); // 구글: sub, 네이버: id
    List<String> scopes = List.of("order:read","order:write");
    var t = tokenService.issue(sub, scopes);
    // 1) 쿠키로 내려 API만 토큰 쿠키를 사용(HTTP-only, Secure, SameSite=strict)
    ResponseCookie at = ResponseCookie.from("AT", t.accessToken())
      .httpOnly(true).secure(true).sameSite("Strict").path("/").maxAge(Duration.ofMinutes(15)).build();
    res.addHeader(HttpHeaders.SET_COOKIE, at.toString());
    // 2) 또는 리다이렉트+프런트 저장
    res.sendRedirect("/app");
  };
}
```

> API는 **Resource Server** 구성이므로, `Authorization: Bearer <AT>`로 호출. 쿠키 사용 시 백엔드에서 꺼내 헤더로 변환하는 **프록시/게이트웨이**를 두기도 한다.

---

## F. Method Security — @PreAuthorize, 권한 평가기, 도메인 권한

### F-1. 기본(SpEL)

```java
@EnableMethodSecurity
@Service
public class OrderService {

  // 본인 주문만 열람 가능하거나, ADMIN 허용
  @PreAuthorize("hasRole('ADMIN') or @orderSecurity.isOwner(#orderId, authentication)")
  public OrderView get(Long orderId) { ... }

  // 권한 문자열 기반(세분화)
  @PreAuthorize("hasAuthority('order:write')")
  public void cancel(Long orderId) { ... }
}
```

**참조 빈**(`@orderSecurity`) 구현 예:
```java
@Component("orderSecurity")
public class OrderSecurity {

  private final OrderRepository repo;

  public OrderSecurity(OrderRepository repo) { this.repo = repo; }

  public boolean isOwner(Long orderId, Authentication auth) {
    String user = auth.getName(); // sub/email
    return repo.isOwner(orderId, user);
  }
}
```

### F-2. PermissionEvaluator (객체 단위)

```java
@Component
public class DomainPermissionEvaluator implements PermissionEvaluator {
  @Override
  public boolean hasPermission(Authentication a, Object targetDomainObject, Object permission) {
    if (targetDomainObject instanceof Order order && "READ".equals(permission)) {
      return order.owner().equals(a.getName()) || a.getAuthorities().stream()
        .anyMatch(ga -> ga.getAuthority().equals("ROLE_ADMIN"));
    }
    return false;
  }
  @Override public boolean hasPermission(Authentication a, Serializable id, String type, Object perm) { return false; }
}
```

SpEL에서:
```java
@PreAuthorize("hasPermission(#order, 'READ')")
public OrderView view(Order order) { ... }
```

### F-3. 도메인 권한 모델링

- **역할(Roles)**: `ROLE_ADMIN`, `ROLE_USER` — coarse-grained
- **권한(Authorities/Scopes)**: `order:read`, `order:write` — fine-grained
- **소유권(Ownership)**: `order.owner == principal`
- **도메인 규칙**: 상태 기반 정책(예: `status in [CREATED, PAID]`)
- **멀티테넌시**: `tenant` 클레임을 JWT에 포함 → `@PreAuthorize("hasAuthority('tenant:'+#tenantId)")` 또는 컨텍스트 필터로 주입

> 권장: **역할 + 권한 + 소유권**을 조합. 외부로 토큰을 발급할 땐 **권한(스코프)**를 명시하고, 서버 내에선 메서드 레벨 정책으로 세밀화.

---

## G. 테스트 — 토큰/메서드 보안 검증

### G-1. JWT로 API 테스트(MockMvc)

```java
@Autowired JwtEncoder encoder;

String tokenFor(String sub, String... scopes) {
  var now = Instant.now();
  var claims = JwtClaimsSet.builder()
    .issuer("https://auth.example.com").subject(sub)
    .issuedAt(now).expiresAt(now.plusSeconds(900))
    .claim("scope", String.join(" ", scopes))
    .build();
  return this.encoder.encode(JwtEncoderParameters.from(claims)).getTokenValue();
}

@Test
void read_order_ok() throws Exception {
  mvc.perform(get("/api/orders/1")
      .header("Authorization", "Bearer " + tokenFor("alice","order:read")))
    .andExpect(status().isOk());
}
```

### G-2. 메서드 보안

```java
@Test
@WithMockUser(username="alice", authorities={"order:write"})
void cancel_ok() {
  service.cancel(1L); // 통과
}
```

---

## H. 운영 체크리스트 — 중요한 20가지

1) Access 5–15분 / Refresh 7–30일(절대 만료 + 회전)
2) RT **해시 저장** + **재사용 감지** + **디바이스 식별**
3) JWKS 공개 + `kid` 회전(신규 키 사전 배포)
4) `aud/iss/exp/nbf` 철저히 검증(리소스 서버 설정)
5) 토큰 크기(HTTP 헤더 한계) 고려(클레임 최소화)
6) HTTPS 필수, HSTS, 시계 동기화(NTP)
7) 로그에 토큰 **절대 노출 금지**(앞 8자만 마스킹)
8) 로그아웃=RT 폐기 + AT는 짧게
9) 스코프/권한 화이트리스트(문서화/테스트)
10) 메서드 보안 적용 범위 명확화(@EnableMethodSecurity)
11) 멱등 POST(결제 등) + 재시도 대비
12) OAuth2 redirect URI **정확 매칭** + PKCE(SPA)
13) CORS: 정확한 Origin/헤더/메서드, Credentials 일치
14) 세션 고정 방지(로그인 후 세션 갱신 — 기본)
15) 브라우저 쿠키: HttpOnly/Secure/SameSite=strict
16) 토큰 탈취 탐지(유저-에이전트/접속 위치 변동, 위험 점수)
17) 감사 로깅: 로그인/리프레시/권한 거부/관리자 행위
18) 속도 제한/브루트포스 방지(백오프, 캡차, WAF)
19) 장애 대비: Auth 서버 이중화/JWKS 캐시/키 관리 백업
20) 문서: 권한표(역할→권한 매핑), 토큰 수명·재발급 흐름, 오류코드

---

## I. 흔한 함정 & 트러블슈팅

- **“유효한데 403”**: `scope` 클레임 이름·접두사(`SCOPE_`) 미스매치 → `JwtGrantedAuthoritiesConverter` 확인
- **“sub가 공백”**: 네이버 프로필의 `id` 경로/`user-name-attribute` 잘못 지정
- **“만료 빨리 남”**: 서버 시계 불일치 → NTP 동기화
- **“리프레시 무한 재사용”**: RT 회전/폐기 미구현 → 테이블·재사용 감지 로직 필수
- **“JWT 너무 큼”**: 클레임 다이어트(roles 대신 scope 최소화, profile은 **유저 조회 API**로 분리)
- **“두 체인 충돌”**: `/api/**` 체인과 `/web/**` 체인의 **Order**/Matcher 우선순위 점검
- **“OIDC 로그인 후 API 401”**: 세션 로그인과 리소스 서버는 분리. 성공 핸들러에서 **JWT 발급/전달** 필요

---

## J. 한 페이지 요약

- **JWT**: 짧은 **AT**로 보호, **RT 회전 + 절대 만료**로 세션 수명을 관리. `kid/JWKS`로 키 회전.
- **OAuth2/OIDC**: 구글·네이버 로그인은 **OAuth2 Login**으로 붙이고, 필요하면 성공 핸들러에서 **JWT**를 발급해 API에 사용.
- **Method Security/도메인 권한**: `@PreAuthorize` + **권한/소유권/테넌트** 조합으로 정책을 코드화; 필요 시 **PermissionEvaluator**로 객체 단위 통제.
- **운영**: 로그아웃=RT 폐기, 로그 마스킹, CORS/쿠키/헤더/시간 동기화, 장애 대비(키/ JWKS/ Auth 서버 이중화).
