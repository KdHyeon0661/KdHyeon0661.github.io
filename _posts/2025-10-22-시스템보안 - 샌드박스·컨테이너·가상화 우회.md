---
layout: post
title: 시스템보안 - 샌드박스·컨테이너·가상화 우회
date: 2025-10-22 23:25:23 +0900
category: 시스템보안
---
# 샌드박스·컨테이너·가상화 우회 (방어 중심 완전 정리)

> 목표
> 1) **리눅스 격리 요소(네임스페이스/cgroup/seccomp)**를 내부에서 “어떻게” 동작하는지 이해
> 2) **Docker/Containerd** 보안 하드닝(권한, 파일시스템, 계정/UID 매핑)
> 3) **탈주가 발생하는 전형적 조합**을 방어 관점으로 모델링(마운트/소켓/`runc`류 취약 구성)
> 4) **하이퍼바이저** 구조와 VM Escape 개요, 완화 전략

---

## 네임스페이스 / cgroup / seccomp-bpf 이해

### 네임스페이스(Namespaces)

리눅스 격리의 1차 축. 같은 커널 안에서 **보이는 세계를 쪼개는** 기술.

- `mnt` : 마운트 트리(루트FS/바인드 마운트/`/proc` 노출 범위)
- `pid` : PID 트리 분리(외부 프로세스 보이지 않음)
- `net` : 네트워크 스택(인터페이스/라우팅/포트)
- `uts` : 호스트명/도메인
- `ipc` : SysV IPC/Posix 메시지 큐
- `user`: **UID/GID 매핑**(호스트의 낮은 권한 UID를 컨테이너의 root처럼 보이게)
- `cgroup`: cgroup 트리 접근 격리

**핵심 포인트**
- `userns`를 쓰면 컨테이너 내부 uid 0이 **호스트 비-root(uid 100xxx 등)**에 매핑 → “root 같은” 작업을 내부에서 해도 **호스트 권한 상승이 어려움**.
- `mnt`와 `/proc`, `/sys` 노출은 **탈주 방어의 핵심**(바인드 마운트·디바이스 노출 실수 주의).

**(랩) 네임스페이스 손으로 켜보기(안전)**
```bash
# 요구: unshare(1) 유틸
# 새 UTS/MNT/NET/IPC/PID/User 네임스페이스 생성

sudo unshare --uts --mount --net --ipc --pid --user --map-root-user --fork bash

# 새로운 호스트명

hostname container-demo

# /proc 재마운트(컨테이너 스타일)

mount -t proc proc /proc

# 격리 확인

ip a        # 루프백만 보이거나, 완전히 비어있을 수 있음(환경 따라 다름)
ps -e       # 새로운 PID 1부터 시작하는 트리
id -a       # 내부 root처럼 보이나, userns 매핑으로 호스트에서는 비-root
```
> **안전 실패 관찰**: 네임스페이스 외부 자원(호스트 네트워크/프로세스)에 직접 접근이 기본적으로 막힘.

---

### cgroup (v1 vs v2)

- **리소스 제어**: CPU, 메모리(MemoryHigh/Max), IO, PID 수 제한(PIDs controller), 장치 접근(`devices`) 등.
- **v2 단일 계층**이 현대 표준. `MemoryMax`/`CPUWeight` 등 **명확한 정책**.

**(랩) cgroup v2 예시 – 메모리 제한**
```bash
# cgroup v2 마운트 환경 가정

cg=/sys/fs/cgroup/demo.slice
sudo mkdir -p $cg
echo "+memory" | sudo tee /sys/fs/cgroup/cgroup.subtree_control >/dev/null
echo 100M | sudo tee $cg/memory.max >/dev/null

# 제한 하에서 프로세스 실행

echo $$ | sudo tee $cg/cgroup.procs >/dev/null
# (별도 터미널에서 stress-ng 등으로 메모리 압박을 걸고 OOM 이벤트/kill 관찰)

```

---

### seccomp-bpf (시스템 콜 필터)

- 커널 진입 지점(**시스템 콜**)을 **화이트리스트/블랙리스트** 형태로 필터.
- 컨테이너에서 **불필요한 syscall 차단**(예: `ptrace`, `kexec`, `mount` 등).

**(랩) Docker 표준 seccomp 프로파일 골격(JSON)**
```json
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "archMap": [{ "architecture": "SCMP_ARCH_X86_64", "subArchitectures": ["SCMP_ARCH_X86", "SCMP_ARCH_X32"] }],
  "syscalls": [
    { "names": ["read", "write", "exit", "futex", "clock_gettime"], "action": "SCMP_ACT_ALLOW" },
    { "names": ["mount", "pivot_root", "kexec_load", "ptrace"], "action": "SCMP_ACT_ERRNO" }
  ]
}
```
적용:
```bash
docker run --rm --security-opt seccomp=/path/to/profile.json alpine:3.20 id
```

**(Go + libseccomp) 최소 패턴(개념)**
```go
// go:build linux
// go get github.com/seccomp/libseccomp-golang
package main
import seccomp "github.com/seccomp/libseccomp-golang"
func main() {
  f, _ := seccomp.NewFilter(seccomp.ActErrno.SetReturnCode(1))
  _ = f.AddRule(seccomp.ScmpSyscall(syscall.SYS_READ), seccomp.ActAllow)
  _ = f.AddRule(seccomp.ScmpSyscall(syscall.SYS_WRITE), seccomp.ActAllow)
  _ = f.AddRule(seccomp.ScmpSyscall(syscall.SYS_EXIT), seccomp.ActAllow)
  _ = f.AddRule(seccomp.ScmpSyscall(syscall.SYS_FUTEX), seccomp.ActAllow)
  _ = f.Load()
  // ... 안전한 동작만 수행
}
```
> **Tip**: seccomp는 **거부 모드** 대신 **감사(Audit)**로 시작 → 업무 영향 파악 후 점진 차단.

---

## Docker/Containerd 보안: CapDrop, read-only FS, userns-remap

### 리눅스 Capabilities 최소화

컨테이너의 root라도, 켜진 capability가 적으면 **할 수 있는 게 줄어듦**.

- **기본 Cap**(엔진/버전에 따라 상이): `CAP_CHOWN`, `DAC_OVERRIDE`, `FOWNER`, `SETGID`, `SETUID`, `SETPCAP`, `NET_RAW`…
- **우선 전략**: **Drop All → 필요한 것만 Add**.

**(실전) docker run**
```bash
# 가능한 모든 cap 제거

docker run --rm -it \
  --cap-drop ALL \
  --security-opt no-new-privileges \
  --read-only \
  --tmpfs /tmp:rw,nosuid,nodev,noexec,size=16m \
  --mount type=bind,src=/data/app-config,dst=/app/config,ro \
  alpine:3.20 sh
```
- `--read-only` : 루트FS를 읽기 전용
- `--tmpfs` : 쓰기 필요한 경로만 **작게** 열기
- `--cap-drop ALL` : 0에서 시작 → 필요한 Cap만 `--cap-add`
- `--security-opt no-new-privileges` : SUID/execve 통한 권한 상승 차단

**(예) 네트워크 툴 필요 시 최소 Cap**
```bash
docker run --rm -it \
  --cap-drop ALL --cap-add NET_RAW --cap-add NET_ADMIN \
  alpine:3.20 sh
```

---

### read-only RootFS & Masked/Readonly Paths

**공격 표면**: 컨테이너 내부에서 호스트 민감 경로를 **바인드 마운트 또는 쓰기 가능**으로 노출.

- **masked paths**: `/proc/kcore`, `/proc/sysrq-trigger`, `/sys/firmware` 등 **접근 자체 마스킹**
- **readonly paths**: `/proc/sys`, `/sys` 일부

**(containerd) 예시: `/etc/containerd/config.toml` 보안 스니펫**
```toml
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
  runtime_type = "io.containerd.runc.v2"

[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
  SystemdCgroup = true
  NoNewPrivileges = true

[plugins."io.containerd.grpc.v1.cri"]
  # 기본 seccomp/profile 적용(배포판 제공 경로에 맞춤)
  enable_selinux = true
```

---

### userns-remap / rootless 컨테이너

- **userns-remap**: 컨테이너 uid 0 → 호스트의 **매핑된** 비-root UID로 변환(예: 100000).
- **rootless 모드**: 데몬/컨테이너 모두 비-root 계정으로.

**(Docker) `/etc/docker/daemon.json`**
```json
{
  "icc": false,
  "userns-remap": "default",
  "no-new-privileges": true,
  "live-restore": true,
  "log-driver": "local"
}
```
적용:
```bash
sudo systemctl reload docker
docker info | grep -i userns
```

---

### AppArmor/SELinux & seccomp 결합

- **AppArmor/SELinux**: 파일 경로·권한 레벨에서 추가 격리.
- **권장**: 표준 프로파일에서 시작 → 특정 앱에 맞게 **최소 권한 프로파일** 튜닝.

**(Kubernetes Pod 예시) — 방어적 설정**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: hardened
  annotations:
    container.apparmor.security.beta.kubernetes.io/app: runtime/default
spec:
  securityContext:
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: app
    image: alpine:3.20
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop: ["ALL"]
```

---

## 탈주 패턴: 마운트/소켓/도커 소켓, runc 사례(개념 분석)

> 아래는 **일반화된 위험 조합**을 방어 관점에서 설명합니다. 특정 취약점의 **악용 절차**나 **버전별 주소/POC**는 제공하지 않습니다.

### 마운트 조합의 위험

- 호스트 디렉터리를 컨테이너에 **쓰기 가능한 바인드 마운트**로 붙임
- 해당 경로가 **서비스 실행 경로/설정/소켓 파일**이면 **간접 코드 실행/권한 상승** 리스크
- `/proc`, `/sys`, `/dev`를 **무심코 광범위**하게 노출하면 **커널 인터페이스/디바이스** 접근 위험

**방어 체크리스트**
- [ ] **읽기 전용 바인드 마운트** 기본, 쓰기는 **최소 단위**
- [ ] `/proc`, `/sys`는 **필요 서브트리만** → 대개 기본 마운트 그대로 두기
- [ ] `/var/run`, `/run`류 소켓 바인드는 **엄격한 서비스별 네임스페이스**에서만

---

### Docker 소켓(`/var/run/docker.sock`) 노출

- 컨테이너 안에서 도커 데몬 API에 접근하면, **새 컨테이너(특권/마운트 임의 지정)를 만들 수 있음** → 호스트 제어 권한에 준함.
- **절대 금지**: 업무상 불가피하면 **리버스 프록시**로 **허용 메서드·이미지·라벨**만 통과(OPA/도커 인증 플러그인 + 네임스페이스 분리).

**(감사) 도커 소켓 바인드 탐지**
{% raw %}
```bash
docker ps --format '{{.ID}} {{.Mounts}}' | grep 'docker\.sock' || echo "OK: no socket binds"
```
{% endraw %}

---

### `--privileged`, 넓은 Cap, 호스트 네임스페이스 공유

- `--privileged`는 **장치/Cap 거의 전부** 허용 = **컨테이너 ≒ 호스트**
- `--cap-add=SYS_ADMIN` 등 **강력 Cap**은 사실상 “무제한”에 가까움
- `--pid=host`, `--net=host`, `--ipc=host` 등 호스트 네임스페이스 공유는 **격리 붕괴**

**(감사) 위험 옵션 스캔**
{% raw %}
```bash
docker ps --format 'table {{.ID}}\t{{.Command}}\t{{.Ports}}\t{{.Mounts}}'
# 별도: docker inspect 로 HostConfig.Privileged, CapAdd, PidMode, NetworkMode 점검

```
{% endraw %}

---

### runc 계열 취약 구성(개념)

- 컨테이너 런타임(예: runc)이 **파일 교체/경쟁 조건/마운트 조합**에 더해 내부에서 **특정 동작을 유도**하면 **호스트 파일시스템 쓰기/임의 실행**에 이르는 케이스가 역사적으로 존재.
- **핵심 방어**:
  - 엔진/런타임 **정기 패치**
  - **정책 게이트**: OPA/Gatekeeper/Kyverno 등으로 **금지 조합**을 Admission 단계에서 차단
  - 컨테이너 이미지 **서명/스캔**(SBOM+취약점)과 **Rootless/userns-remap** 결합

**(OPA Gatekeeper) 금지 규칙 예시**
```yaml
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sPSPPrivilegedContainer
metadata:
  name: disallow-privileged
spec:
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
```
```yaml
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sPSPCapabilities
metadata:
  name: drop-all-add-min
spec:
  match:
    kinds: [{apiGroups: [""], kinds: ["Pod"]}]
  parameters:
    requiredDropCapabilities: ["ALL"]
    allowedCapabilities: ["NET_RAW"] # 필요 최소
```

---

### 런타임 탐지(Falco/EBPF) — “행동”을 본다

**아이디어**: 실패/차단 이벤트를 **가시화**해서, 위험 설정이 **실행**으로 이어지지 않도록 초기 단에서 잡는다.

**(Falco 규칙 스케치)**
- 컨테이너에서 `mount(2)` 호출 시 경고
- 컨테이너 프로세스가 `/var/run/docker.sock` 접근 시 경고
- `/proc/*/mem`/`ptrace`/`kcore` 접근 시 경고

```yaml
- rule: Container Mount Syscall
  desc: Detect mount from container
  condition: container and evt.type=mount
  output: "Mount in container (user=%user.name proc=%proc.name file=%fd.name)"
  priority: WARNING
```

---

## 하이퍼바이저(VT-x/AMD-V)와 VM Escape 개요

### 하이퍼바이저 구조(요약)

- **Type-1**(베어메탈, KVM+Linux는 하이브리드) vs **Type-2**(호스트 OS 위)
- **VT-x/AMD-V**: 가상화 지원, **EPT/NPT**(2단계 페이지 테이블)로 메모리 격리
- **장치 에뮬레이션/가상 디바이스**: QEMU/virtio가 네트워크/디스크/입출력 가상화

**VM Escape 표면**
- **장치 에뮬레이션 취약점**(특히 복잡한 포맷 파서)
- **툴스 채널**(게스트↔호스트 유틸) 오남용
- **공유폴더/clipboard**의 신뢰 경계 약화

**방어**
- 하이퍼바이저/툴 체인 **상시 패치**
- **sVirt/SELinux**로 VM 별 MAC 격리(QEMU가 호스트 자원 접근 제한)
- **IOMMU(VT-d/AMD-Vi)**로 DMA 범위 제한
- 민감 워크로드는 **암호화 메모리(AMD SEV/Intel TDX 등)** 검토
- **스냅샷/템플릿** + 변경 불변(immutable) 베이스 이미지 운영

---

## 7.x 운영 하드닝 — 체크리스트 & 자동 감사 스크립트

### 7.x.1 컨테이너 런타임 하드닝 체크리스트

- [ ] **userns-remap** 또는 **rootless**
- [ ] `--cap-drop=ALL` + 필요한 `--cap-add`만
- [ ] `--read-only` + 필요한 `--tmpfs`/바인드 마운트 **최소/RO**
- [ ] `--security-opt no-new-privileges`
- [ ] **seccomp=RuntimeDefault/커스텀 최소 프로파일**
- [ ] AppArmor/SELinux **Enforce**
- [ ] **docker.sock 미노출**(정 필요 시 프록시+OPA)
- [ ] `--privileged` **금지**(Gatekeeper/Kyverno 정책)

### 7.x.2 빠른 감사 스크립트(안전)

{% raw %}
```bash
#!/usr/bin/env bash
# container_audit.sh — Docker 위험 설정 점검(읽기 전용)

set -euo pipefail
echo "== Docker Version =="; docker version --format '{{.Server.Version}}' || true
echo "== Userns Remap =="; docker info 2>/dev/null | grep -i 'userns'
echo "== Running Containers (risk flags) =="
for id in $(docker ps -q); do
  cfg=$(docker inspect "$id")
  name=$(echo "$cfg" | jq -r '.[0].Name')
  priv=$(echo "$cfg" | jq -r '.[0].HostConfig.Privileged')
  caps=$(echo "$cfg" | jq -r '.[0].HostConfig.CapAdd | join(",")')
  pidm=$(echo "$cfg" | jq -r '.[0].HostConfig.PidMode')
  netm=$(echo "$cfg" | jq -r '.[0].HostConfig.NetworkMode')
  soc=$(echo "$cfg" | jq -r '.[0].Mounts[]?|select(.Source|test("docker.sock")).Source' || true)
  echo "$name  privileged=$priv capadd=$caps pidmode=$pidm net=$netm docker.sock=$([ -n "$soc" ] && echo yes || echo no)"
done
```
{% endraw %}

---

## 7.x.3 개발팀을 위한 “안전 기본값” Compose 템플릿

```yaml
version: "3.9"
services:
  app:
    image: ghcr.io/acme/app:1.2.3
    read_only: true
    tmpfs:
      - /tmp:rw,nosuid,nodev,noexec,size=16m
    security_opt:
      - "no-new-privileges:true"
      - "seccomp=runtime/default"
    cap_drop:
      - ALL
    user: "10000:10000"        # 고정 비-root UID:GID
    environment:
      - "APP_ENV=prod"
    volumes:
      - type: bind
        source: /srv/app/config
        target: /app/config
        read_only: true
    restart: always
```

---

## 7.x.4 “안전 실패” 중심 테스트 시나리오(랩)

1) **과도한 권한 요구 앱**: 위 Compose로 실행 → 기능이 막히면
   - 진짜 필요한 Cap/시스템콜만 추출해 **최소 허용** 업데이트
2) **소켓/마운트 추가 시도**: CI 단계에서 OPA/`docker scan`/정적 검사로 **차단**되도록
3) **Falco/EBPF** 룰로 **mount/ptrace/docker.sock 접근** 이벤트가 나오는지 관찰(알림 경로 점검)

---

# 마무리

- 컨테이너 격리는 **네임스페이스 + cgroup + seccomp + LSM**의 합. 어느 하나라도 **완화**되면 위험한 조합이 생긴다.
- **권한(캡/privileged) + 마운트 + 소켓(docker.sock)**의 3요소가 **탈주 사고**의 대부분을 설명한다.
- **userns-remap/rootless, read-only FS, no-new-privileges**는 사고를 **구조적으로** 어렵게 만든다.
- 하이퍼바이저 레벨에서도 **장치 에뮬레이션/툴 채널**이 핵심 표면이니, **패치 + sVirt/SELinux + IOMMU**로 방어를 겹겹이.
