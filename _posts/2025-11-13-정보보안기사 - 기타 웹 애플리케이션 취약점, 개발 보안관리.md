---
layout: post
title: 정보보안기사 - 기타 웹 애플리케이션 취약점, 개발 보안관리
date: 2025-11-13 12:25:23 +0900
category: 정보보안기사
---
# SECTION 08 웹 애플리케이션 취약점 — 13. 기타 웹 애플리케이션 취약점 · 14. 개발 보안관리

## 기타 웹 애플리케이션 취약점

> 이미 다룬 항목(XSS/CSRF/SSRF/경로추적/파일업·다운로드/IDOR·HPP·Open Redirect 등)을 제외하고, 실무에서 자주 만나는 “그 외”를 **취약 시나리오 → 안전 설계/설정 → 코드 템플릿** 순으로 묶었다.

### 클릭재킹(Clickjacking)

- **핵심**: 공격자가 `<iframe>`으로 우리 사이트를 가리고 클릭을 유도 → **민감 행위** 트리거(송금/설정변경).
- **방어**: `frame-ancestors`(CSP) 또는 `X-Frame-Options: DENY|SAMEORIGIN`.

```nginx
# Nginx

add_header X-Frame-Options "DENY" always;
add_header Content-Security-Policy "frame-ancestors 'none'" always;  # 권장
```

```java
// Spring Security
http.headers(h -> h
  .contentSecurityPolicy(c -> c.policyDirectives("frame-ancestors 'none'"))
  .frameOptions().deny());
```

---

### HTTP 응답 분할/CRLF 주입(Response Splitting)

- **취약**: 헤더 값에 사용자 입력을 그대로 삽입 → `\r\n` 주입으로 **추가 헤더/바디** 삽입.
- **방어**: 헤더에 들어갈 값은 **CR/LF 제거**, **화이트리스트**(알파뉴메릭/허용문자만).

```js
// ❌ 취약: 쿼리 msg를 그대로 헤더에
res.setHeader('X-Note', req.query.msg);

// ✅ 방어
function safeHeader(s) {
  return String(s).replace(/[\r\n]/g, '').slice(0, 200);
}
res.setHeader('X-Note', safeHeader(req.query.msg));
```

---

### 서버사이드 템플릿 인젝션(SSTI)

- **취약**: 템플릿 엔진(Jinja2, Thymeleaf 등)의 **표현식**이 사용자 입력과 합쳐짐.
- **방어**: **템플릿 로직과 데이터 분리**, 표현식 해석 비활성(가능 시), 헬퍼만 노출.

{% raw %}
```python
# ❌ 취약 (Jinja2) - 사용자가 "{{ 7*7 }}" 입력 시 코드 실행

tmpl = Template(request.args.get('t'))
return tmpl.render(user=cur_user)

# ✅ 방어 - 사전 정의된 템플릿만 사용, 입력은 변수로만

tmpl = env.get_template('profile.html')  # 파일명 고정
return tmpl.render(username=safe_username)
```
{% endraw %}

---

### 취약한 역직렬화(Deserialization)

- **취약**: 신뢰할 수 없는 바이트/JSON을 **객체**로 복원하며 **임의 코드 실행/형 변조**.
- **방어**: 위험한 포맷 금지(예: Java `readObject`, .NET `BinaryFormatter`), **허용 타입 화이트리스트**, **서명/무결성**.

```java
// ✅ Java XML/JSON - polymorphic typing 제한
ObjectMapper m = new ObjectMapper();
m.activateDefaultTyping(LaissezFaireSubTypeValidator.instance,
  ObjectMapper.DefaultTyping.NON_FINAL); // ⚠️ 지양
// → 대신 @JsonTypeInfo 최소화 또는 구체 DTO만 허용

// 안전 전략: 구체 DTO로만 바인딩
class ProfileDto { public String name; public String phone; }
ProfileDto dto = mapper.readValue(json, ProfileDto.class);
```

```csharp
// .NET - BinaryFormatter 금지
// ✅ System.Text.Json + DTO + [JsonDerivedType] 제한
```

---

### XXE(XML External Entity)

- **취약**: XML 파서가 **외부 엔티티**를 로드 → 파일 읽기/SSRF.
- **방어**: 외부 엔티티/DTD 비활성.

```java
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
dbf.setFeature("http://xml.org/sax/features/external-general-entities", false);
dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
dbf.setXIncludeAware(false);
dbf.setExpandEntityReferences(false);
```

---

### Prototype Pollution(Node/브라우저)

- **취약**: `{ __proto__: { isAdmin: true } }` 병합 시 객체 체인이 오염.
- **방어**: 병합 시 **루트 키 차단**, `Object.create(null)` 사용.

```js
function safeMerge(target, src) {
  for (const [k,v] of Object.entries(src)) {
    if (k === '__proto__' || k === 'constructor' || k === 'prototype') continue;
    target[k] = v;
  }
  return target;
}
```

---

### ReDoS(정규식 DoS)

- **취약**: 정규식의 **폭발적 백트래킹**으로 CPU 소모.
- **방어**: **RE2** 같은 엔진, **앵커/수량자** 안전 설계, 시간 제한.

```js
// ❌ 취약
/^(a+)+$/          // 입력 "aaaaaaaaaaaaaaaa!"에서 폭발
// ✅ 방어
/^[a]+$/           // 중첩 제거, 또는 RE2 엔진 사용
```

---

### CORS 오구성

- **위험 조합**: `Access-Control-Allow-Origin: *` + `Credentials: true` (금지).
- **방어**: **정확한 오리진 화이트리스트** + 크리덴셜 필요성 최소화.

```js
app.use(cors({
  origin: (o,cb)=> cb(null, !o || allow.has(o)),
  credentials: true
}));
```

---

### Host Header Injection

- **취약**: 절대 URL 생성 시 `Host` 헤더 신뢰 → 패스워드 리셋 링크 하이재킹.
- **방어**: **허용 호스트 화이트리스트**.

```js
const allowedHosts = new Set(['app.example.com']);
function absoluteUrl(req, path) {
  const host = String(req.headers.host || '').toLowerCase();
  if (!allowedHosts.has(host)) throw new Error('bad host');
  return `https://${host}${path}`;
}
```

---

### HTTP Request Smuggling(프록시/백엔드 불일치)

- **개념**: 프론트(프록시)와 백엔드가 **Content-Length / Transfer-Encoding** 해석 다름.
- **방어**: 장비 최신화, **TE/CL 혼용 차단**, 게이트웨이 한쪽만 허용.

```
[Client] -> [Proxy(CL기준)] -> [Backend(TE기준)]
```

---

### 캐시 포이즈닝/키 혼동

- **취약**: 캐시 키에 **권한/언어/장치** 등 컨텍스트 미포함 → 응답 섞임.
- **방어**: `Vary`/캐시 키 정의 엄격, 민감 응답 `no-store`.

```nginx
add_header Vary "Accept-Encoding, User-Agent, Authorization";
```

---

### WebSocket 보안

- **위험**: **Origin 검증 없음**, 메시지 검증 부재.
- **방어**: **Origin 화이트리스트**, **인증 토큰 검증**, 메시지 스키마 검증.

```js
wss.on('connection', (ws, req) => {
  const origin = req.headers.origin;
  if (!allow.has(origin)) return ws.close();
  // JWT 검사, 이후 메시지 zod/ajv로 검증
});
```

---

### GraphQL 보안

- **위험**: 인트로스펙션 상시 공개, 깊이/복잡도 무제한.
- **방어**: **프로덕션 인트로스펙션 제한**, 깊이/비용 제한, **Persisted Query**.

```ts
import { createRateLimitRule } from 'graphql-rate-limit';
import depthLimit from 'graphql-depth-limit';
const server = new ApolloServer({
  validationRules: [depthLimit(8)], // ✅ 깊이 제한
});
```

---

### gRPC/HTTP2

- **권장**: **mTLS/TLS**, **권한 인터셉터**, 메시지 스키마 검증.

```go
// gRPC Unary Interceptor for Auth
func authInterceptor(...) grpc.UnaryServerInterceptor {
  return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
    if !authorize(ctx, info.FullMethod) { return nil, status.Error(codes.PermissionDenied, "no") }
    return handler(ctx, req)
  }
}
```

---

### 이메일 헤더 인젝션

```python
# ❌ CRLF 허용 시 헤더 인젝션

subject = request.form['subject']
msg['Subject'] = subject

# ✅ 방어

def strip_crlf(s): return s.replace('\r','').replace('\n','')[:120]
msg['Subject'] = strip_crlf(subject)
```

---

### 레이스 컨디션/중복 과금

- **방어**: **Idempotency-Key**, DB **유니크 제약** + 트랜잭션.

```sql
ALTER TABLE payments ADD CONSTRAINT uniq_idem UNIQUE(idempotency_key);
```

```js
await db.insertPayment({ key: idem }).onConflict('key').ignore();
```

---

### DNS Rebinding/Host 검증

- **방어**: **허용 호스트/포트 화이트리스트**, 내부 IP/메타데이터 차단.

---

### 서브도메인 테이크오버

- **방어**: DNS/클라우드 리소스 **수명주기 동기화**, 무주공산 레코드 제거, 모니터링.

---

### ESI/에지 템플릿 인젝션

- **방어**: ESI 비활성 또는 **정적 경로만**, 사용자 입력 포함 금지.

---

### 쿠키 토싱(Cookie Tossing)

- **방어**: 도메인/경로 정책 정합, **Set-Cookie 충돌 모니터링**.

---

### DOM 기반 취약점(간단 리마인드)

- **DOM XSS**: `innerHTML` 지양 → `textContent`.
- **DOM Redirect**: `location=` 할당 시 **화이트리스트**.

```js
// ❌
el.innerHTML = userInput;
// ✅
el.textContent = userInput;
```

---

### 요약 표

| 취약점 | 핵심 방어 |
|---|---|
| 클릭재킹 | CSP `frame-ancestors`, XFO |
| CRLF/응답분할 | CR/LF 제거, 헤더 화이트리스트 |
| SSTI | 템플릿 고정/데이터 분리 |
| 역직렬화 | DTO 화이트리스트, 위험 포맷 금지 |
| XXE | DTD/외부 엔티티 비활성 |
| Prototype Pollution | 위험 키 차단 |
| ReDoS | 안전 정규식/RE2 |
| CORS | 정확한 오리진, 와일드카드+Cred 금지 |
| Host Injection | 호스트 화이트리스트 |
| Smuggling | TE/CL 혼용 금지, 장비 최신 |
| Cache Poison | Vary/키 정의 |
| WS/GraphQL | Origin/깊이/Persisted Query |
| Race | Idempotency, 유니크키 |
| Subdomain | DNS/자원 동기화 |

---

## 개발 보안관리(Secure SDLC·SCA/SAST/DAST·비밀관리·CI/CD·서명/공급망·정책/코드리뷰)

### 보안 내재화 SDLC(개념 그림)

```
[요구사항] -> [설계(위협모델)] -> [구현(코딩규약)] -> [테스트(SAST/DAST/IAST)]
      -> [빌드(SBOM/서명)] -> [배포(서명검증/승인)] -> [운영(모니터링/피드백)]
```

- 각 단계 산출물: **위협모델(DFD/STRIDE)**, **보안 요구사항**, **코딩 표준**, **스캔 리포트**, **SBOM/서명**, **런북/대응계획**.

---

### 설계 단계: 위협모델(간단 예)

- **대상**: 로그인+주문 API
- **STRIDE 체크**: 스푸핑/변조/부인방지/정보누출/서비스 거부/권한 상승
- **대응**: mTLS/OTP/로그 서명/비밀 URL 금지/레이트리밋/권한검사

---

### 보안 비기능 요구사항(NFR) 샘플

| 항목 | 요구사항 예 |
|---|---|
| 인증 | OIDC + PKCE, 세션 회전 |
| 인가 | RBAC + 테넌트 RLS |
| 데이터 | PII 최소수집, 저장 시 암호화(KMS) |
| 로깅 | PII 마스킹, 무결성(서명) |
| 성능/가용 | 레이트리밋/서킷브레이커 |
| 배포 | 아티팩트 서명, SBOM 필수 |
| 운영 | 취약점 SLA(예: Critical 7일) |

---

### 코딩 규약(요지)

- 입력 검증: **스키마 기반(Zod/Bean Validation/Pydantic)**
- 출력 인코딩: 컨텍스트 별(HTML/Attr/JS/URL)
- 암호학: **고수준 라이브러리** 사용, 자체 구현 금지
- 시크릿: 코드 저장소에 금지, **KMS/Secrets Manager/Vault**
- 로깅: **민감 항목 마스킹**, 샘플링

---

### CI: SAST/SCA/Secret Scan/DAST 파이프라인

```yaml
# .github/workflows/security.yml

name: security
on: [pull_request, push]
jobs:
  scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      id-token: write  # OIDC 클라우드 접근용
    steps:
      - uses: actions/checkout@v4
      - name: SCA (OWASP Dependency-Check or Trivy)
        uses: aquasecurity/trivy-action@0.24.0
        with: { scan-type: 'fs', format: 'sarif', output: 'trivy.sarif' }
      - name: Secret Scan (gitleaks)
        uses: gitleaks/gitleaks-action@v2
      - name: SAST (Semgrep)
        uses: returntocorp/semgrep-action@v1
      - name: Upload results
        uses: github/codeql-action/upload-sarif@v3
        with: { sarif_file: "trivy.sarif" }
```

---

### SBOM/서명/공급망 보호

- **SBOM**: CycloneDX/SPDX 생성 → 아티팩트에 첨부.
- **서명**: Sigstore **cosign**으로 컨테이너/바이너리 **서명/검증**.
- **정책**: 배포 전 **서명·취약점 기준** 만족해야 통과.

```bash
# SBOM 생성 (CycloneDX 예)

cyclonedx-npm --output bom.json
# 컨테이너 서명

cosign sign --oidc --yes registry/app:1.2.3
# 검증

cosign verify --certificate-identity-regexp ".*@example\.com" registry/app:1.2.3
```

---

### 비밀관리(예: AWS Secrets Manager)

```js
import { SecretsManagerClient, GetSecretValueCommand } from "@aws-sdk/client-secrets-manager";
const sm = new SecretsManagerClient({ region: "ap-northeast-2" });

export async function dbCreds() {
  const r = await sm.send(new GetSecretValueCommand({ SecretId: "prod/db" }));
  return JSON.parse(r.SecretString);
}
```

- **원칙**: **짧은 TTL**, 애플리케이션 **자동 회전** 대응, **감사 로그**.

---

### 의존성 위생(Renovate/Bundler-Audit 등)

- **고정(lockfile)**, **자동 PR(주기적 업데이트)**, **취약 버전 차단**.

```json
// renovate.json
{
  "extends": ["config:recommended"],
  "schedule": ["after 20:00 on sunday"],
  "rangeStrategy": "bump",
  "labels": ["deps"]
}
```

---

### 브랜치 보호/리뷰 게이트

- **필수 리뷰어**(CODEOWNERS), **서명 커밋/태그**, **상태 체크 필수**(스캔 통과).
- **PR 템플릿**에 보안 체크리스트 포함.

```text
- [ ] 입력 검증/출력 인코딩 반영
- [ ] 민감정보 로깅 없음
- [ ] 시크릿 외부관리
```

---

### CI 토큰 최소권한·OIDC

- **장기 액세스 키 금지**, 워크플로우 **OIDC로 클라우드 권한 교부**(짧은 세션).

---

### 환경 분리/설정

- **프로파일별 설정**(dev/staging/prod), 민감 값은 **참조**(Secrets) 단, **하드코딩 금지**.
- **피처 플래그**로 위험 변경을 **점진 릴리즈**.

---

### 정책-코드(Policy as Code) 예: OPA/Rego

```rego
package deploy.verify

# 이미지는 cosign으로 서명되어야 한다

allow {
  input.imageSignature.valid == true
  input.vulns.critical == 0
}
```

---

### Semgrep 규칙 예(빠른 가드)

```yaml
rules:
- id: insecure-crypto-node
  patterns:
  - pattern: crypto.createHash("md5")
  message: "MD5 사용 금지"
  severity: ERROR
  languages: [javascript, typescript]
```

---

### 프리커밋 훅(개발기 레벨 가드)

```yaml
# .pre-commit-config.yaml

repos:
- repo: https://github.com/pre-commit/pre-commit-hooks
  rev: v4.6.0
  hooks:
    - id: detect-aws-credentials
    - id: check-merge-conflict
- repo: https://github.com/returntocorp/semgrep
  rev: v1.85.0
  hooks:
    - id: semgrep
```

---

### 배포 게이트(릴리즈 차단 기준)

- **정책**: Critical 취약점 0, High N 이하, SBOM 필수, 서명 검증 통과, 라이선스 정책 통과.

---

### 로그/모니터링/프라이버시

- **PII 분류** → 최소 수집/가명화 → **마스킹 규칙** → 보존 기간 준수.
- **감사로그 무결성**: 해시 체인/외부 저장.

---

### 보안 교육/챔피언

- 팀별 **Security Champion** 운영, 월간 취약점 리뷰, 실습 기반 교육(예: Juice Shop 랩).

---

### 지표(예시)

- **MTTR/MTTD**, **취약점 SLA 준수율**, **시크릿 유출 건수**, **패치 리드타임**.

수식으로 표현하면, 월간 위험 노출량 \(R\)은 대략
$$
R \approx \sum_i V_i \cdot E_i \cdot T_i
$$
- \(V_i\): 취약점 심각도(가중), \(E_i\): 외부 노출 계수, \(T_i\): 미해결 시간.
→ **SLA 단축(\(T_i \downarrow\))**, **외부 노출 축소(\(E_i \downarrow\))**가 핵심.

---

### 운영 점검 체크리스트

**설계/코드**
- [ ] 입력 스키마 검증/출력 인코딩
- [ ] 비밀 외부관리(KMS/Secrets)
- [ ] 암호학 표준 사용(자체구현 금지)
- [ ] 에러 메시지 일반화(스택 비노출)

**CI/CD**
- [ ] SAST/SCA/Secrets/DAST 파이프라인
- [ ] SBOM 생성/보관
- [ ] 아티팩트 서명/검증
- [ ] 브랜치 보호/리뷰 필수

**런타임**
- [ ] 보안 헤더(CSP/HSTS/NoSniff/Referrer)
- [ ] CORS 화이트리스트
- [ ] 레이트리밋/서킷브레이커
- [ ] 로깅 마스킹/보존정책

**취약점 운영**
- [ ] Critical 24~72h, High 7d, Medium 30d 정책
- [ ] 월간 리스크 리뷰/보안 챔피언 미팅

---

### 실습 과제(팀 내 적용 템플릿)

1) **레거시 서비스**에 CSP `frame-ancestors`/XFO 추가 후 회귀 테스트
2) **Secrets in Code** 스캔(히스토리 포함) → 회수/교체
3) **Renovate** 도입 → 주간 업데이트 파이프라인
4) **cosign**으로 컨테이너 서명/검증 → 배포 게이트 연동
5) **Semgrep** 최소 규칙(암호/HTTP/직렬화) 프로젝트 표준화

---

## 마무리

- “기타 취약점”은 잔챙이가 아니다. 실제 침투 시나리오에서 **체인을 완성**하는 연결고리다.
- 개발 보안관리는 **SDLC 전 과정**에 녹아야 한다. 스캐너만 돌리는 것으로 끝나지 않는다.
- 본 문서의 **코드 템플릿/체크리스트/파이프라인 예시**를 그대로 가져다 팀 표준에 넣고, **측정 가능한 지표와 게이트**로 운영하면 **시험·실무** 모두에서 통과 가능 수준의 보안 성숙도를 확보할 수 있다.
