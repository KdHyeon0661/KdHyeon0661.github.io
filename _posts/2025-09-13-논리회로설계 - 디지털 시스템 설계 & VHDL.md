---
layout: post
title: 논리회로설계 - 디지털 시스템 설계 & VHDL
date: 2025-09-13 18:25:23 +0900
category: 논리회로설계
---
# 디지털 시스템 설계 & VHDL — **직렬덧셈기**, **2진 곱셈기**, **2진 나눗셈기**(합성 가능 예제 포함)

> 규약  
> - 라이브러리: `ieee.std_logic_1164`, `ieee.numeric_std` (산술은 `unsigned/signed`)  
> - 클럭형 설계, 동기 리셋 가정.  
> - 코드는 **합성 가능**하도록 작성, 각 모듈은 `start/busy/done` 핸드셰이크를 제공.  
> - 수식은 MathJax: 예) 전가산기 \(s=a\oplus b\oplus c\), \(c^+=ab+(a\oplus b)c\).

---

## 1) 직렬덧셈기(Serial Adder) — 누산기 포함

### 1.1 동작 원리 (LSB-first)
- 매 클럭 **1비트**씩 \(A_i,B_i\)와 캐리 \(C\)를 전가산기에 넣어 합비트 \(S_i\) 생성.
- 다음 캐리 \(C^+=A_iB_i+(A_i\oplus B_i)C\).
- 합 비트는 누산 레지스터 `Acc`에 저장(LSB→MSB 순서로 채움).

**지연**: \(N\)비트 입력 → \(N\)클럭(+1클럭 종료 플래그).  
**장점**: 면적 최소, 타이밍 여유 큼.

### 1.2 VHDL: 병렬 로드 → 직렬 가산 → 병렬 결과
```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity serial_adder is
  generic (N : positive := 16);
  port (
    clk, rst : in  std_logic;
    ce, start: in  std_logic;
    a_in, b_in : in  std_logic_vector(N-1 downto 0);
    busy, done : out std_logic;
    sum_out    : out std_logic_vector(N downto 0)  -- 캐리 포함 N+1
  );
end entity;

architecture rtl of serial_adder is
  type S_t is (IDLE, RUN, FIN);
  signal s, ns  : S_t := IDLE;

  signal Areg, Breg : std_logic_vector(N-1 downto 0);
  signal Acc        : std_logic_vector(N downto 0);
  signal C          : std_logic := '0';
  signal idx        : unsigned(15 downto 0) := (others=>'0');
begin
  busy <= '1' when s=RUN else '0';
  sum_out <= Acc;

  -- 조합(다음상태)
  process(all) begin
    ns <= s;
    case s is
      when IDLE =>
        if start='1' then ns <= RUN; end if;
      when RUN  =>
        if idx = to_unsigned(N-1, idx'length) then ns <= FIN; end if;
      when FIN  =>
        ns <= IDLE;
    end case;
  end process;

  -- 순차(상태/데이터 경로)
  process(clk)
    variable a0,b0,sbit : std_logic;
  begin
    if rising_edge(clk) then
      if rst='1' then
        s   <= IDLE; idx <= (others=>'0'); C <= '0';
        Areg<= (others=>'0'); Breg<= (others=>'0');
        Acc <= (others=>'0'); done<='0';
      elsif ce='1' then
        s <= ns; done<='0';
        case s is
          when IDLE =>
            if start='1' then
              Areg <= a_in; Breg <= b_in;
              Acc  <= (others=>'0'); C <= '0';
              idx  <= (others=>'0');
            end if;

          when RUN =>
            a0 := Areg(0); b0 := Breg(0);
            sbit := a0 xor b0 xor C;
            -- 누산기: 현재 인덱스 위치에 합 비트 저장
            Acc(to_integer(idx)) <= sbit;

            -- 다음 캐리
            C <= (a0 and b0) or ((a0 xor b0) and C);

            -- 쉬프트(LSB 소진)
            Areg <= '0' & Areg(N-1 downto 1);
            Breg <= '0' & Breg(N-1 downto 1);

            if idx = to_unsigned(N-1, idx'length) then
              Acc(N) <= C;  -- 최종 캐리
            else
              idx <= idx + 1;
            end if;

          when FIN =>
            done <= '1';
        end case;
      end if;
    end if;
  end process;
end architecture;
```

> **스트리밍 변형**(직렬 입력 `si_a/si_b`와 `tick` 로직)도 동일 패턴으로 작성 가능하며, 내부에 SIPO(Serial-In Parallel-Out)를 붙이면 된다.

---

## 2) 2진 곱셈기 — 시프트-가산 / Booth(2’s complement)

### 2.1 시프트-가산(Unsigned) — 1클럭/비트 반복
아이디어: 승수 \(B\)의 LSB를 검사 → 1이면 `P(low N)`에 피승수 \(A\)를 더하고, `P`와 `B`를 우시프트.

#### VHDL: Iterative Unsigned Multiplier (쉬프트-가산)
```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity mul_shift_add is
  generic (N : positive := 16);
  port (
    clk, rst : in  std_logic;
    ce, start: in  std_logic;
    A, B     : in  std_logic_vector(N-1 downto 0);
    busy, done : out std_logic;
    P         : out std_logic_vector(2*N-1 downto 0)
  );
end entity;

architecture rtl of mul_shift_add is
  type S_t is (IDLE, RUN, FIN);
  signal s, ns : S_t := IDLE;

  signal Areg : unsigned(N-1 downto 0);
  signal Breg : unsigned(N-1 downto 0);
  signal Preg : unsigned(2*N-1 downto 0);
  signal cnt  : unsigned(15 downto 0) := (others=>'0');
begin
  P    <= std_logic_vector(Preg);
  busy <= '1' when s=RUN else '0';

  -- NS
  process(all) begin
    ns <= s;
    case s is
      when IDLE => if start='1' then ns<=RUN; end if;
      when RUN  => if cnt=to_unsigned(N-1,cnt'length) then ns<=FIN; end if;
      when FIN  => ns<=IDLE;
    end case;
  end process;

  -- 상태/데이터
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        s<=IDLE; done<='0'; cnt<=(others=>'0'); Preg<=(others=>'0');
      elsif ce='1' then
        s<=ns; done<='0';
        case s is
          when IDLE =>
            if start='1' then
              Areg<=unsigned(A); Breg<=unsigned(B);
              Preg<=(others=>'0'); cnt<=(others=>'0');
            end if;

          when RUN =>
            -- LSB 검사 후 필요 시 가산 (하위 N비트 영역)
            if Breg(0)='1' then
              Preg(N-1 downto 0) <= Preg(N-1 downto 0) + Areg;
            end if;
            -- 우시프트: P와 B 모두
            Preg <= '0' & Preg(2*N-1 downto 1);
            Breg <= '0' & Breg(N-1 downto 1);

            if cnt=to_unsigned(N-1,cnt'length) then
              null;
            else
              cnt<=cnt+1;
            end if;

          when FIN =>
            done<='1';
        end case;
      end if;
    end if;
  end process;
end architecture;
```

**특징**  
- 가산기는 **N비트 고정**(하위 영역), 나머지는 쉬프트 → 구조 간단, 타이밍 양호.  
- 1사이클/비트 → 총 \(N\)사이클.

---

### 2.2 Booth(서명수, 2의 보수) — Radix-2
원리: 연속된 ‘1’ 구간을 압축. \([b_i, b_{i-1}]\)가 `01`이면 `+A`, `10`이면 `-A`, `00/11`은 0.

#### VHDL: Booth Radix-2 (Signed)
```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity mul_booth_r2 is
  generic (N : positive := 16);
  port (
    clk, rst : in  std_logic;
    ce, start: in  std_logic;
    A, B     : in  std_logic_vector(N-1 downto 0);  -- 2's complement
    busy, done : out std_logic;
    P         : out std_logic_vector(2*N-1 downto 0) -- 2N-비트 결과
  );
end;

architecture rtl of mul_booth_r2 is
  type S_t is (IDLE, RUN, FIN);
  signal s, ns : S_t := IDLE;

  signal Areg : signed(N-1 downto 0);
  signal Breg : signed(N-1 downto 0);
  signal Prod : signed(2*N downto 0); -- 여유 비트
  signal b_prev : std_logic := '0';
  signal cnt  : unsigned(15 downto 0) := (others=>'0');
begin
  P    <= std_logic_vector(Prod(2*N-1 downto 0));
  busy <= '1' when s=RUN else '0';

  process(all) begin
    ns<=s;
    case s is
      when IDLE => if start='1' then ns<=RUN; end if;
      when RUN  => if cnt=to_unsigned(N-1,cnt'length) then ns<=FIN; end if;
      when FIN  => ns<=IDLE;
    end case;
  end process;

  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        s<=IDLE; done<='0'; Prod<=(others=>'0'); b_prev<='0'; cnt<=(others=>'0');
      elsif ce='1' then
        s<=ns; done<='0';
        case s is
          when IDLE =>
            if start='1' then
              Areg<=signed(A); Breg<=signed(B);
              Prod<=(others=>'0'); b_prev<='0'; cnt<=(others=>'0');
            end if;

          when RUN =>
            -- Booth 결정
            if (Breg(0)='1' and b_prev='0') then
              Prod(2*N-1 downto N) <= Prod(2*N-1 downto N) + Areg; -- +A
            elsif (Breg(0)='0' and b_prev='1') then
              Prod(2*N-1 downto N) <= Prod(2*N-1 downto N) - Areg; -- -A
            end if;

            -- 산술 우시프트
            b_prev <= Breg(0);
            Breg   <= Breg sra 1;
            Prod   <= Prod sra 1;

            if cnt=to_unsigned(N-1,cnt'length) then null; else cnt<=cnt+1; end if;

          when FIN =>
            done<='1';
        end case;
      end if;
    end if;
  end process;
end architecture;
```

**요약**  
- **서명수** 입력을 자연스럽게 지원.  
- 가산/감산 발생 횟수가 줄어 평균 클럭 수가 비슷해도 **가산기 토글** 감소.

---

## 3) 2진 나눗셈기 — 복원/비복원(Unsigned) + 부호 래퍼

### 3.1 복원(Restoring) — 상위→하위, 실패 시 복원
알고리즘:
\[
\begin{aligned}
R &\leftarrow 0\\
\text{for } i&=n-1..0:\\
\quad R &\leftarrow (R\ll 1) + N[i]\\
\quad \text{if }R\ge D:&\ R\leftarrow R-D,\ Q[i]\leftarrow1\\
\quad \text{else:}&\ Q[i]\leftarrow0
\end{aligned}
\]

#### VHDL: Unsigned Restoring Divider
```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity div_restoring is
  generic (N: positive := 16);
  port (
    clk, rst : in  std_logic;
    ce, start: in  std_logic;
    Numer, Denom : in  std_logic_vector(N-1 downto 0);
    busy, done : out std_logic;
    div0       : out std_logic;  -- 분모=0
    Quot       : out std_logic_vector(N-1 downto 0);
    Rem        : out std_logic_vector(N-1 downto 0)
  );
end;

architecture rtl of div_restoring is
  type S_t is (IDLE, RUN, FIN);
  signal s, ns : S_t := IDLE;

  signal A : unsigned(N-1 downto 0);
  signal B : unsigned(N-1 downto 0);
  signal R : unsigned(N downto 0);   -- N+1 비트
  signal Q : unsigned(N-1 downto 0);
  signal i : integer range 0 to N := 0;
begin
  busy <= '1' when s=RUN else '0';
  Quot <= std_logic_vector(Q);
  Rem  <= std_logic_vector(R(N-1 downto 0));

  process(all) begin
    ns<=s;
    case s is
      when IDLE =>
        if start='1' then
          if Denom=(others=>'0') then ns<=FIN; else ns<=RUN; end if;
        end if;
      when RUN  =>
        if i=0 then ns<=FIN; end if;
      when FIN  =>
        ns<=IDLE;
    end case;
  end process;

  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        s<=IDLE; done<='0'; div0<='0'; R<=(others=>'0'); Q<=(others=>'0');
      elsif ce='1' then
        s<=ns; done<='0'; div0<='0';
        case s is
          when IDLE =>
            if start='1' then
              if Denom=(others=>'0') then
                div0<='1';
              else
                A <= unsigned(Numer);
                B <= unsigned(Denom);
                R <= (others=>'0');
                Q <= (others=>'0');
                i <= N; -- 루프 카운트: N회
              end if;
            end if;

          when RUN =>
            -- 상위 비트부터 1비트 시프트-인
            R <= (R(N-1 downto 0) & A(i-1));
            -- 비교·복원
            if R >= ('0' & B) then
              R <= R - ('0' & B);
              Q(i-1) <= '1';
            else
              -- R 유지, Q비트=0
              null;
            end if;
            i <= i-1;

          when FIN =>
            done<='1';
        end case;
      end if;
    end if;
  end process;
end architecture;
```

---

### 3.2 비복원(Non-Restoring) — 부호 나머지 이용, 복원 단계 제거
핵심: 나머지 \(R\)의 부호로 **다음 연산을 가감산** 결정. 끝나고 \(R<0\)이면 \(R\leftarrow R+D\) 보정.

#### VHDL: Unsigned Non-Restoring Divider
```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity div_nonrestoring is
  generic (N: positive := 16);
  port (
    clk, rst : in  std_logic;
    ce, start: in  std_logic;
    Numer, Denom : in  std_logic_vector(N-1 downto 0);
    busy, done : out std_logic;
    div0       : out std_logic;
    Quot       : out std_logic_vector(N-1 downto 0);
    Rem        : out std_logic_vector(N-1 downto 0)
  );
end;

architecture rtl of div_nonrestoring is
  type S_t is (IDLE, RUN, CORR, FIN);
  signal s, ns : S_t := IDLE;

  signal A : unsigned(N-1 downto 0);
  signal B : unsigned(N-1 downto 0);
  signal R : signed(N downto 0);  -- 부호 포함 나머지
  signal Q : unsigned(N-1 downto 0);
  signal i : integer range 0 to N := 0;
begin
  busy <= '1' when (s=RUN or s=CORR) else '0';
  Quot <= std_logic_vector(Q);
  Rem  <= std_logic_vector(unsigned(R(N-1 downto 0)));

  process(all) begin
    ns<=s;
    case s is
      when IDLE =>
        if start='1' then
          if Denom=(others=>'0') then ns<=FIN; else ns<=RUN; end if;
        end if;
      when RUN  =>
        if i=0 then ns<=CORR; end if;
      when CORR =>
        ns<=FIN;
      when FIN  =>
        ns<=IDLE;
    end case;
  end process;

  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        s<=IDLE; done<='0'; div0<='0'; R<=(others=>'0'); Q<=(others=>'0');
      elsif ce='1' then
        s<=ns; done<='0'; div0<='0';
        case s is
          when IDLE =>
            if start='1' then
              if Denom=(others=>'0') then
                div0<='1';
              else
                A <= unsigned(Numer);
                B <= unsigned(Denom);
                R <= (others=>'0'); Q <= (others=>'0');
                i <= N; -- N회
              end if;
            end if;

          when RUN =>
            -- 1비트 시프트-인 (상위→하위)
            R <= shift_left(R,1) + to_signed(integer(A(i-1)), R'length);
            if R >= 0 then
              R <= R - to_signed(integer(B), R'length);
              Q(i-1) <= '1';
            else
              R <= R + to_signed(integer(B), R'length);
              Q(i-1) <= '0';
            end if;
            i <= i-1;

          when CORR =>
            if R < 0 then
              R <= R + to_signed(integer(B), R'length);
            end if;

          when FIN =>
            done<='1';
        end case;
      end if;
    end if;
  end process;
end architecture;
```

---

### 3.3 서명(2의 보수) 나눗셈 래퍼 — 부호/절대값/보정
\[
Q = \operatorname{sgn}(N)\oplus \operatorname{sgn}(D) ? -|Q| : |Q|,\quad
R = \operatorname{sgn}(N) ? -|R| : |R|
\]

#### VHDL: Signed Wrapper (복원형 코어 사용)
```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity div_signed is
  generic (N: positive := 16);
  port (
    clk, rst : in  std_logic;
    ce, start: in  std_logic;
    Numer_s, Denom_s : in  std_logic_vector(N-1 downto 0); -- 2's complement
    busy, done : out std_logic;
    div0       : out std_logic;
    Quot_s     : out std_logic_vector(N-1 downto 0);
    Rem_s      : out std_logic_vector(N-1 downto 0)
  );
end;

architecture rtl of div_signed is
  -- 부호/절대값
  signal sN, sD : std_logic;
  signal absN, absD : std_logic_vector(N-1 downto 0);

  -- 코어 연결
  signal core_busy, core_done, core_div0 : std_logic;
  signal Q_u, R_u : std_logic_vector(N-1 downto 0);

  -- 후처리
  signal Qs, Rs : signed(N-1 downto 0);
begin
  sN <= Numer_s(N-1);
  sD <= Denom_s(N-1);
  absN <= std_logic_vector(abs(signed(Numer_s)));
  absD <= std_logic_vector(abs(signed(Denom_s)));

  core: entity work.div_restoring
    generic map (N=>N)
    port map (
      clk=>clk, rst=>rst, ce=>ce, start=>start,
      Numer=>absN, Denom=>absD,
      busy=>core_busy, done=>core_done, div0=>core_div0,
      Quot=>Q_u, Rem=>R_u
    );

  busy <= core_busy; done <= core_done; div0 <= core_div0;

  -- 부호 보정
  Qs <= (others=>'0') when core_div0='1' else
        ( -signed(Q_u) ) when (sN xor sD)='1' else signed(Q_u);
  Rs <= (others=>'0') when core_div0='1' else
        ( -signed(R_u) ) when sN='1' else signed(R_u);

  Quot_s <= std_logic_vector(Qs);
  Rem_s  <= std_logic_vector(Rs);
end architecture;
```

> 주의: `MIN_INT / -1` 오버플로우는 비트폭 확장이나 포화 정책 등 별도 처리 필요.

---

## 4) 간단 테스트벤치 스니펫 (기능 확인용)

> 실제 검증에서는 랜덤 테스트 + 레퍼런스 모델(소프트웨어) 비교를 권장.

### 4.1 직렬덧셈기 TB
```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity tb_serial_adder is end;
architecture sim of tb_serial_adder is
  constant N: integer := 8;
  signal clk: std_logic:='0'; signal rst: std_logic:='1';
  signal ce,start: std_logic:='0';
  signal a,b: std_logic_vector(N-1 downto 0);
  signal busy,done: std_logic; signal s: std_logic_vector(N downto 0);
begin
  clk <= not clk after 5 ns;
  dut: entity work.serial_adder
    generic map (N=>N)
    port map (clk=>clk, rst=>rst, ce=>ce, start=>start, a_in=>a, b_in=>b,
              busy=>busy, done=>done, sum_out=>s);

  process begin
    ce<='1'; a<=x"55"; b<=x"2A"; wait for 50 ns; rst<='0';
    start<='1'; wait for 10 ns; start<='0';
    wait until done='1';
    assert s = std_logic_vector(to_unsigned(16#55#+16#2A#, N+1))
      report "Serial adder mismatch" severity error;
    assert false report "SERIAL ADDER OK" severity failure;
  end process;
end;
```

### 4.2 곱셈기 TB (쉬프트-가산)
```vhdl
entity tb_mul is end;
architecture sim of tb_mul is
  constant N: integer := 8;
  signal clk: std_logic:='0'; signal rst: std_logic:='1';
  signal ce,start: std_logic:='0';
  signal A,B: std_logic_vector(N-1 downto 0);
  signal P: std_logic_vector(2*N-1 downto 0);
  signal busy,done: std_logic;
begin
  clk <= not clk after 5 ns;
  dut: entity work.mul_shift_add
    generic map (N=>N)
    port map (clk=>clk, rst=>rst, ce=>ce, start=>start, A=>A, B=>B,
              busy=>busy, done=>done, P=>P);

  process
    variable ref: unsigned(2*N-1 downto 0);
  begin
    ce<='1'; wait for 30 ns; rst<='0';
    A<=x"13"; B<=x"27"; start<='1'; wait for 10 ns; start<='0';
    wait until done='1';
    ref := unsigned(A)*unsigned(B);
    assert P = std_logic_vector(ref) report "MUL mismatch" severity error;
    assert false report "MUL OK" severity failure;
  end process;
end;
```

### 4.3 나눗셈기 TB (복원)
```vhdl
entity tb_div is end;
architecture sim of tb_div is
  constant N: integer := 8;
  signal clk: std_logic:='0'; signal rst: std_logic:='1';
  signal ce,start: std_logic:='0';
  signal Numer, Denom: std_logic_vector(N-1 downto 0);
  signal Q,R: std_logic_vector(N-1 downto 0);
  signal busy,done,div0: std_logic;
begin
  clk <= not clk after 5 ns;
  dut: entity work.div_restoring
    generic map (N=>N)
    port map (clk=>clk, rst=>rst, ce=>ce, start=>start, Numer=>Numer, Denom=>Denom,
              busy=>busy, done=>done, div0=>div0, Quot=>Q, Rem=>R);

  process
    variable qref,rref: unsigned(N-1 downto 0);
  begin
    ce<='1'; wait for 30 ns; rst<='0';
    Numer<=x"93"; Denom<=x"0D"; start<='1'; wait for 10 ns; start<='0';
    wait until done='1';
    qref := unsigned(Numer)/unsigned(Denom);
    rref := unsigned(Numer) mod unsigned(Denom);
    assert Q = std_logic_vector(qref) report "DIV Q mismatch" severity error;
    assert R = std_logic_vector(rref) report "DIV R mismatch" severity error;
    assert false report "DIV OK" severity failure;
  end process;
end;
```

---

## 5) 설계·합성 팁 (요약)

- **타이밍**: 반복형(Serial/Iterative)은 조합 경로 짧아 **Fmax** 유리. 처리량은 클럭 수에 비례.  
- **FPGA**: 곱셈은 **DSP** 블록 매핑 고려(병렬/파이프라인), 쉬프트는 **SRL**로 자동 유도.  
- **CPLD**: 반복형이 적합(PLA 스타일), 상태 수/곱항(PT) 절약.  
- **에러 처리**: 나눗셈 `Denom=0`은 별도 `div0` 플래그로 처리.  
- **부호 연산**: `numeric_std`의 `signed/unsigned` 일관 사용, 래퍼로 부호 보정.  
- **검증**: 랜덤 백투백 트랜잭션, 경계(0/최대/최소/부호 경계) 포함.

---

### 맺음말
- 본 문서의 세 모듈(직렬덧셈기, 쉬프트-가산/Booth 곱셈기, 복원/비복원 나눗셈기)은 **동일한 FSM+데이터패스 철학**으로 작성되어 재사용·확장에 용이합니다.  
- 처리량이 필요하면 **파이프라인/병렬화**, 면적이 중요하면 **반복형**을 선택하세요.  
- VHDL 구현은 합성기 친화 코딩 규칙(동기 리셋, CE, `numeric_std`)을 지키면 **플랫폼 독립성**이 높고 유지보수가 쉬워집니다.
