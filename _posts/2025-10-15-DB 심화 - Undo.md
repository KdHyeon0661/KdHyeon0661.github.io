---
layout: post
title: DB 심화 - Undo
date: 2025-10-15 21:25:23 +0900
category: DB 심화
---
# Oracle **UNDO** 심화 — Undo 세그먼트 *Transaction Table Slot*, 데이터 블록 헤더 *ITL 슬롯*, *Row Lock Byte* 완전 가이드 (19c 기준)

> 목표  
> - **Undo 세그먼트(Transaction Table)** 의 슬롯 구조와 **XID(usn.slot.sqn)** 할당 과정을 정확히 이해  
> - **데이터 블록 헤더의 ITL(Interested Transaction List) 슬롯**이 무엇을 들고 있고, 어떻게 **행 잠금(row lock)** 과 연결되는지 파헤침  
> - **Row Lock Byte(행 헤더의 잠금 바이트)** 가 ITL과 엮여 동시성을 구현하는 방식을, *실습 SQL* · *대기 이벤트* · *블록 덤프* 예시까지 포함해 설명  
> - **일관 읽기(Consistent Read)** 와 **ORA-01555(snapshot too old)** 를 *Transaction Table → Undo 체인 → CR 재구성* 흐름으로 이해  
> - **ITL 부족(enq: TX - allocate ITL entry)** 재현 및 튜닝( `INITRANS`/`PCTFREE`/워크로드 분산 ) 방법 제공

---

## 0) 한눈 개요 — “트랜잭션은 Undo 세그먼트의 **슬롯**을 잡고, 블록의 **ITL** 을 통해 **행 잠금**을 건다”

- **Undo 세그먼트**  
  - 각 Undo 세그먼트에는 **Transaction Table**(간단히 “트랜잭션 테이블”)이 있고, 이 안에 **슬롯(slot)** 들이 있다.  
  - 트랜잭션이 시작되면 **“자기만의 슬롯”**을 하나 점유한다. 이 슬롯은 트랜잭션의 **헤드(변경 체인/상태/커밋 SCN 등)** 를 보관한다.
  - 트랜잭션 식별자는 **XID = usn.slot.sqn** (Undo Segment Number, Slot Number, Sequence Number).
- **데이터 블록 헤더의 ITL**  
  - 데이터 블록마다 **ITL 엔트리**(슬롯)가 여러 개 있다. 각 ITL은 **“이 블록을 현재 건드리고 있는 트랜잭션(XID)”** 를 가리킨다.  
  - ITL 엔트리는 **XID, Undo 포인터(최초 변경 지점), 플래그, 커밋 SCN(클린아웃)** 등의 메타를 갖는다.
- **Row Lock Byte(행 헤더의 잠금 바이트)**  
  - 각 **행 헤더**는 “어느 ITL 슬롯이 나를 잠갔는지”를 **작은 바이트 값**(슬롯 인덱스)으로 표시한다.  
  - 즉, **행 → (Lock Byte) → ITL 슬롯 → (XID) → Undo 트랜잭션 슬롯** 으로 이어지는 링크가 잠금/일관성의 연결고리다.

이 3요소가 얽혀 다음을 달성한다:

1) **행 레벨 잠금**(원자성) 2) **일관 읽기**(Undo 기반 CR) 3) **커밋/클린아웃**(내구성의 표현)

---

## 1) 트랜잭션 테이블 슬롯(Transaction Table Slot) — XID의 집

### 1.1 XID(usn.slot.sqn)과 슬롯 할당

- 트랜잭션 시작 시, 오라클은 **어떤 Undo 세그먼트(USN)** 의 **트랜잭션 테이블 슬롯** 하나를 점유하고 **XID** 를 만든다.  
- `v$transaction` 에서는 **`XIDUSN`, `XIDSLOT`, `XIDSQN`** 으로 확인 가능.

```sql
-- 현재 세션의 트랜잭션/XID/Undo 정보
SELECT s.sid, s.serial#, t.xidusn, t.xidslot, t.xidsqn, t.status, t.start_time
FROM   v$session s
JOIN   v$transaction t ON t.ses_addr = s.saddr
WHERE  s.audsid = SYS_CONTEXT('USERENV','SESSIONID');
```

- **슬롯**은 트랜잭션이 살아있는 동안 **수명**을 유지하며, 커밋/롤백 이후 재활용된다.
- 한 슬롯은 트랜잭션의 **Undo 체인**(최근 변경에서 과거로 이어지는 링크)의 **헤드 포인터** 역할을 한다.  
  - **일관 읽기** 시, 이 슬롯을 기점으로 “해당 트랜잭션의 이전 버전(Undo 레코드)”을 따라 내려가 **CR(Consistent Read) 블록**을 재조립한다.

### 1.2 슬롯이 들고 있는 것(개념)

- 트랜잭션 상태(INACTIVE/ACTIVE/COMMITTED 등 내부 코드)  
- **Undo 헤드 포인터**(가장 최근 Undo 레코드 위치)  
- **커밋 SCN**(커밋 시점 기록; Deferred Cleanout 전에 CR 판단 기준으로 쓰임)  
- 기타 트랜잭션 메타(내부 구조는 버전 따라 다소 차이)

> **핵심 직관**: “**XID → 트랜잭션 슬롯**”이 **Undo 체인**의 **루트**다. 읽기 일관성은 여기서 시작된다.

---

## 2) 데이터 블록 헤더의 **ITL 슬롯** — “이 블록은 지금 누가 만지니?”

### 2.1 ITL(Interested Transaction List)란?

- 데이터 **블록 헤더**에는 **ITL 엔트리**들이 있으며, **각 ITL = 이 블록에 관심(변경)을 가진 트랜잭션 하나** 를 의미.  
- ITL 엔트리에는 보통 다음이 들어있다(개념):  
  - **XID(usn.slot.sqn)** — 이 블록을 현재/최근 변경한 트랜잭션  
  - **Undo 포인터(해당 블록의 첫 변경 Undo 레코드 위치)**  
  - **플래그/상태**(락 모드, 커밋 여부 표시 등)  
  - **커밋 SCN(cleanout 후)** — 커밋이 완료되고 블록이 **클린아웃(cleanout)** 되면 ITL에 커밋 SCN이 찍힌다.

> **클린아웃**: 커밋 직후 또는 **지연(deferred)** 되어 나중의 읽기 시점에, 해당 ITL에 **커밋 SCN**을 적어 두는 최적화. 이후 읽기는 Undo 추적 없이도 “커밋됨”을 빠르게 판단.

### 2.2 ITL 부족과 `enq: TX - allocate ITL entry`

- 한 블록 안의 ITL 엔트리 수가 충분치 않은데 **동시에 많은 트랜잭션이 같은 블록을 갱신**하려고 하면 **ITL 부족**이 난다.  
- 대표 대기: **`enq: TX - allocate ITL entry`**  
- 완화책:
  - 오브젝트의 **`INITRANS`**(초기 ITL 수) / **헤더 여유 공간(PCTFREE)** 조정 → ITL 확장 여지  
  - **핫 블록 분산**(파티셔닝/Reverse Key/샤딩/키 설계) → 같은 블록에 몰리는 업데이트 완화

```sql
-- ITL 확장을 위한 저장 특성(주의: MOVE/REBUILD 시 재점검 필요)
ALTER TABLE  t_orders  STORAGE (INITRANS 8) PCTFREE 20;
ALTER INDEX  ix_orders_cust  STORAGE (INITRANS 8);

-- ITL 부족 대기 관측(세션/시스템)
SELECT sid, event, state, seconds_in_wait
FROM   v$session
WHERE  event LIKE 'enq: TX - allocate ITL entry';
```

---

## 3) **Row Lock Byte** — 행 헤더의 잠금 표시자

### 3.1 Row Lock Byte가 하는 일

- 각 **행 헤더**는 “**나를 잠근 ITL 엔트리 번호**(인덱스)” 를 **작은 바이트 값**으로 보관한다.  
- 이 값 덕분에, 읽는 세션은 **해당 ITL 엔트리**를 찾아가 **XID/커밋 상태** 를 확인하고, 필요시 **Undo를 따라가 CR** 을 재구성한다.

> 요약 링크: **Row →(lock byte)→ ITL(slot) → XID → Undo Slot(트랜잭션 테이블)**

### 3.2 같은 블록에서의 동시 업데이트

- 동일 블록 내 여러 행이 동시에 업데이트되면 **서로 다른 ITL 슬롯**(혹은 동일 슬롯)을 가리키는 **Row Lock Byte** 들이 생긴다.  
- ITL 슬롯 하나가 **여러 행**을 잠글 수 있다. (ITL = “해당 블록에서 그 트랜잭션의 자리표”)

---

## 4) 일관 읽기(Consistent Read): **Transaction Slot → Undo Chain → CR 블록 재구성**

### 4.1 “쿼리 SCN” 기준 스냅샷

- SELECT가 시작되면 **쿼리 SCN** 을 잡는다.  
- 읽으려는 블록의 **변경 SCN** 이 **쿼리 SCN** 보다 **신규** 이면,  
  - 해당 행의 **Row Lock Byte → ITL → XID** 를 따라가 **트랜잭션 테이블 슬롯**을 찾고,  
  - 그 슬롯이 가진 **Undo 체인**을 따라가 **해당 시점의 값**을 **CR 블록** 으로 재조립해 반환한다.

### 4.2 ORA-01555(snapshot too old)와 Undo 보존

- Undo 체인의 **필요한 레코드**가 **이미 회수(reuse)** 되어 버렸다면, CR 재구성이 불가능 → **ORA-01555**  
- 대응:
  - 충분한 **`UNDO_TABLESPACE` 용량**과 **`UNDO_RETENTION`** 설정  
  - 장시간 쿼리 ↔ 대규모 DML 시간대 **분리**  
  - **커밋 빈도**/배치 전략 조절(Undo 소비 패턴 완화)

```sql
-- Undo 설정/상태 점검
SHOW PARAMETER undo_tablespace;
SHOW PARAMETER undo_retention;

-- UNDO 소모/보존 지표(주요)
SELECT begin_time, undoblks, txncount, ssolderrcnt, tuned_undoretention
FROM   v$undostat
ORDER  BY begin_time DESC FETCH FIRST 24 ROWS ONLY;
```

- `ssolderrcnt` : snapshot too old 발생 횟수  
- `tuned_undoretention` : 오라클이 통계적으로 조정한 보존 시간(Adaptive)

---

## 5) **실습** — ITL 부족과 Row Lock Byte 동작을 체감해 보기

> 주의: **테스트 전용** 환경에서만 실행하세요.

### 5.1 실습 준비: 작은 행·좁은 블록에 동시 갱신 몰아넣기

```sql
DROP TABLE t_itl PURGE;

-- 의도적으로 작은 INITRANS + 낮은 PCTFREE로 헤더 여유를 빡빡하게
CREATE TABLE t_itl (
  id     NUMBER PRIMARY KEY,
  k      NUMBER NOT NULL,
  pad    VARCHAR2(50)
)
INITRANS 1
PCTFREE 5;

BEGIN
  FOR i IN 1..20000 LOOP
    INSERT INTO t_itl (id, k, pad)
    VALUES (i, MOD(i,10), RPAD('x',50,'x'));
    IF MOD(i,500)=0 THEN COMMIT; END IF;
  END LOOP;
  COMMIT;
END;
/
CREATE INDEX ix_itl_k ON t_itl(k);
```

### 5.2 동시 업데이트(두 세션 이상에서 반복)

```sql
-- 세션 A/B/C ... 동시에 실행해서 같은 블록에 부하 유도
UPDATE t_itl
   SET pad = RPAD('y',50,'y')
 WHERE k = 0
   AND id BETWEEN 1 AND 1000;

COMMIT;
```

### 5.3 관측: ITL 부족/버퍼 대기

```sql
-- 현재 세션 대기
SELECT sid, event, state, seconds_in_wait
FROM   v$session
WHERE  state <> 'WAITED SHORT TIME'
AND    (event LIKE 'enq: TX - allocate ITL entry'
    OR  event LIKE 'buffer busy waits'
    OR  event LIKE 'read by other session')
ORDER  BY seconds_in_wait DESC;

-- 세그먼트 통계에서 buffer busy/read by other session 상위 확인
SELECT o.owner, o.object_name, SUM(s.value) waits
FROM   v$segment_statistics s
JOIN   dba_objects o ON o.owner=s.owner AND o.object_name=s.object_name
WHERE  s.statistic_name IN ('buffer busy waits','read by other session')
AND    o.object_name IN ('T_ITL','IX_ITL_K')
GROUP  BY o.owner, o.object_name
ORDER  BY waits DESC;
```

**예상**  
- `enq: TX - allocate ITL entry` 등장(ITL 부족)  
- 상황에 따라 `buffer busy waits`/`read by other session` 도 보일 수 있음  
- 이때, **같은 블록**에 **여러 트랜잭션**이 **여러 행을 동시에 락** 걸며 Row Lock Byte ↔ ITL 슬롯 연결이 바쁘게 갱신됨

### 5.4 개선: ITL 확장(저장 특성/헤더 여유) + 핫블록 분산

```sql
-- ITL 엔트리 확장을 위한 INITRANS 증가 + 헤더 여유 확보(PCTFREE ↑)
ALTER TABLE t_itl MOVE INITRANS 8 PCTFREE 20;
ALTER INDEX ix_itl_k REBUILD INITRANS 8;

-- 키 분산(예: 해시 파티셔닝)으로 동일 블록 몰림 완화
DROP TABLE t_itl PURGE;
CREATE TABLE t_itl (
  id     NUMBER,
  k      NUMBER,
  pad    VARCHAR2(50),
  CONSTRAINT pk_t_itl PRIMARY KEY (id)
)
PCTFREE 20
INITRANS 4
PARTITION BY HASH (k)
PARTITIONS 16;

BEGIN
  FOR i IN 1..20000 LOOP
    INSERT INTO t_itl (id, k, pad)
    VALUES (i, MOD(i,10), RPAD('x',50,'x'));
    IF MOD(i,500)=0 THEN COMMIT; END IF;
  END LOOP;
  COMMIT;
END;
/
CREATE INDEX ix_itl_k ON t_itl(k) LOCAL INITRANS 4;
```

개선 후 **같은 부하 재시도** → `enq: TX - allocate ITL entry` 감소, 전반 대기 완화 기대.

---

## 6) **블록 덤프** 로 ITL/Row Lock Byte 확인하기(선택)

> 실제 **Row Lock Byte** 와 **ITL 엔트리** 는 SQL로 그대로 보이는 구조가 아니므로, **블록 덤프** 로 검증한다.  
> (테스트 환경, SYSDBA 필요. 데이터파일/블록번호 파악 → 아래 명령)

```sql
-- 어떤 행이 들어있는 블록 번호를 얻고
SELECT rowid, DBMS_ROWID.ROWID_BLOCK_NUMBER(rowid) AS blkno,
       DBMS_ROWID.ROWID_RELATIVE_FNO(rowid)        AS file#
FROM   t_itl
WHERE  id BETWEEN 1 AND 5;

-- 해당 블록 덤프(주의: 실제 파일/블록 번호로 변경)
ALTER SYSTEM DUMP DATAFILE <file#> BLOCK <blkno>;
```

덤프 출력에서 보게 되는 것(요지):
- **ITL 리스트**: 슬롯별 **XID(usn.slot.sqn)**, **flg**, **uba 포인터**, **scn**(cleanout 후) 등  
- **Row Directory/Row Header**: 각 **row** 헤더의 **lock byte** 가 **몇 번째 ITL** 을 가리키는지  
- “클린아웃 전”이면 ITL에 커밋 SCN이 없고, 읽기 시 **지연 클린아웃** 이 발생해 SCN을 채워 넣기도 함

> 덤프는 내부 구조 학습용이며, 운영 중 과도한 덤프는 지양.

---

## 7) **일관 읽기(Consistent Read)** 를 ITL/슬롯 관점으로 다시 보기

1. **SELECT 시작** → **쿼리 SCN** 고정  
2. 블록을 읽음 → 특정 **행의 Row Lock Byte** 가 **ITL 슬롯 n** 을 가리킴  
3. ITL 슬롯 n을 열어 **XID** 와 **커밋 상태** 확인  
   - **커밋 SCN이 기록되어 있고(클린아웃 완료)** 그 값이 **쿼리 SCN 이하**면 “과거 시점에서 커밋 완료”로 판단 → **현재 값** 사용  
   - 커밋 SCN 정보가 부족/미기록(클린아웃 전) → **트랜잭션 테이블 슬롯** 조회하여 커밋 여부/SCN 확인  
4. **필요하면 Undo 체인** 을 따라가 해당 행의 **과거 이미지** 로 **CR 블록** 재구성  
5. 최종 결과 반환

> 이 과정에서 Undo 체인 일부가 재사용되었다면 **ORA-01555**. Undo 보존/용량/배치 시간 조절이 필요.

---

## 8) 고전적 혼동 정리 — “락 vs 핀 vs ITL vs TX”

- **TX enqueue(행 락)**: **행 레벨 논리 잠금**. 커밋/롤백까지 지속.  
- **ITL 슬롯**: “**이 블록을 만지는 트랜잭션**” 의 자리표. **Row Lock Byte** 가 그것을 가리켜 행-트랜잭션 연결을 형성.  
- **버퍼 핀(pin)**: **메모리 버퍼 프레임 보호**(대체 방지/동시 수정 방지). 매우 단기.  
- **래치/뮤텍스**: ITL/체인/헤더 등 **공유 구조체 보호**(초단기).  
→ 실전에서 “버퍼 락 걸렸다” 같은 말은 종종 **버퍼 핀/래치 충돌**과 **TX/ITL** 을 혼용. 각각 레이어가 다름을 기억.

---

## 9) Undo/ITL/Row Lock 관련 **대기 이벤트** 요약

- **`enq: TX - allocate ITL entry`** : ITL 부족 → 헤더 공간 모자라 ITL 못 잡는 상태  
- **`buffer busy waits`** : 같은 블록에서 **다른 세션이 쓰는 중/읽는 중** 등으로 접근 대기  
- **`read by other session`** : 다른 세션이 해당 블록 **물리 읽기** 중; 완료 공유 대기  
- **`gc buffer busy`** (RAC) : 글로벌 캐시에서 핫 블록 경합  
- **`enq: TX - row lock contention`** : **행 락 충돌**(서로 같은 행 업데이트 충돌)

---

## 10) 운영 튜닝 체크리스트

1. **핫 블록** 탐지:  
   - `v$segment_statistics` 의 `buffer busy waits` / `row lock waits` 상위  
   - `x$bh.tch` 상위(핫 블록) — SYS에서만, 운영 과다 조회 지양
2. **ITL 설정**:  
   - 동시 업데이트 많은 테이블/인덱스는 `INITRANS` 확대, `PCTFREE` 로 헤더 확장 여지 확보  
   - 재구성 작업( `MOVE` / `REBUILD` ) 시 손실되지 않도록 주의
3. **키/파티셔닝 설계**:  
   - **해시/범위 파티셔닝**, **Reverse Key Index**, **카운터 샤딩** 등으로 **동일 블록 집중** 완화
4. **Undo 보존/용량**:  
   - `UNDO_RETENTION` 및 `v$undostat.tuned_undoretention` 감시  
   - 장시간 보고서 vs 대규모 DML **시간 분리**
5. **행 크기/블록 공간**:  
   - `PCTFREE` / `PCTUSED`(ASSM 환경은 자동 관리)로 업데이트 후 행 확장/헤더 여유 고려
6. **업무 패턴**:  
   - 과도한 **자잘한 커밋**은 Undo/Redo 파편화 + LGWR sync 증가  
   - 가능 시 **배치 단위 커밋**(업무 일관성 정책과 맞춰 조정)

---

## 11) 추가 실습 — “Row Lock Byte ↔ ITL” 체감용 미니 시나리오

### 11.1 테이블/데이터 준비

```sql
DROP TABLE t_lock PURGE;

CREATE TABLE t_lock (
  id   NUMBER PRIMARY KEY,
  g    NUMBER NOT NULL,
  pad  VARCHAR2(40)
)
INITRANS 1 PCTFREE 5;

BEGIN
  FOR i IN 1..5000 LOOP
    INSERT INTO t_lock VALUES (i, MOD(i,5), RPAD('a', 40, 'a'));
    IF MOD(i,500)=0 THEN COMMIT; END IF;
  END LOOP;
  COMMIT;
END;
/
CREATE INDEX ix_lock_g ON t_lock(g);
```

### 11.2 두 세션에서 “같은 그룹의 좁은 범위” 동시 갱신

```sql
-- 세션 A
UPDATE t_lock SET pad = 'A' WHERE g = 0 AND id BETWEEN 1 AND 500;
-- 커밋 지연(아직 커밋하지 말고 다른 세션 작업 관찰)

-- 세션 B
UPDATE t_lock SET pad = 'B' WHERE g = 0 AND id BETWEEN 400 AND 900;
```

- 일부 **같은 블록 내 행들** 에 대해 **Row Lock Byte** 가 세션 A의 ITL을 가리키고 있어 세션 B에서 **TX/버퍼 대기** 발생 가능.

### 11.3 세션/대기 관측

```sql
SELECT sid, event, state, seconds_in_wait
FROM   v$session
WHERE  state <> 'WAITED SHORT TIME'
AND    (event LIKE 'enq: TX - row lock contention'
    OR  event LIKE 'enq: TX - allocate ITL entry'
    OR  event LIKE 'buffer busy waits')
ORDER  BY seconds_in_wait DESC;
```

### 11.4 해결(커밋/롤백/확장)

- 세션 A 커밋 → **클린아웃** 진행 → ITL에 **커밋 SCN** 찍힘 → 차후 읽기/갱신 시 Undo 추적 감소  
- 잦은 ITL 부족이면 `INITRANS`/`PCTFREE` 상향, 파티셔닝으로 키 분산

---

## 12) 레퍼런스 SQL 묶음(진단 단축키)

```sql
-- 12.1 내 세션의 트랜잭션 XID / Undo 세그먼트 슬롯
SELECT s.sid, t.xidusn, t.xidslot, t.xidsqn, t.status, t.start_time
FROM   v$session s JOIN v$transaction t ON t.ses_addr = s.saddr
WHERE  s.audsid = SYS_CONTEXT('USERENV','SESSIONID');

-- 12.2 Undo 사용량/보존 추이
SELECT begin_time, undoblks, txncount, ssolderrcnt, tuned_undoretention
FROM   v$undostat
ORDER  BY begin_time DESC FETCH FIRST 30 ROWS ONLY;

-- 12.3 세그먼트별 버퍼 대기/락 대기
SELECT o.owner, o.object_name, o.object_type,
       SUM(CASE WHEN s.statistic_name='buffer busy waits' THEN s.value ELSE 0 END) AS buf_busy,
       SUM(CASE WHEN s.statistic_name='row lock waits'     THEN s.value ELSE 0 END) AS row_lock
FROM   v$segment_statistics s
JOIN   dba_objects o ON o.owner=s.owner AND o.object_name=s.object_name
GROUP  BY o.owner, o.object_name, o.object_type
ORDER  BY buf_busy DESC FETCH FIRST 15 ROWS ONLY;

-- 12.4 ITL 부족 대기 세션
SELECT sid, event, state, seconds_in_wait
FROM   v$session
WHERE  event LIKE 'enq: TX - allocate ITL entry';

-- 12.5 블록 덤프를 위한 파일/블록 번호 찾기(샘플)
SELECT rowid, DBMS_ROWID.ROWID_RELATIVE_FNO(rowid) AS file#,
               DBMS_ROWID.ROWID_BLOCK_NUMBER(rowid) AS block#
FROM   t_itl
WHERE  id BETWEEN 1 AND 3;
-- ALTER SYSTEM DUMP DATAFILE <file#> BLOCK <block#>;
```

---

## 13) 마무리 요약

- **Undo 세그먼트의 트랜잭션 테이블 슬롯** = **XID의 집**. 커밋/상태/Undo 체인을 관리하며 **일관 읽기**의 출발점이다.  
- **데이터 블록 헤더의 ITL 슬롯** = **이 블록을 만지는 트랜잭션의 자리표**. **Row Lock Byte(행 헤더)** 가 ITL을 가리켜 **행 ↔ 트랜잭션** 을 연결한다.  
- **클린아웃** 으로 ITL에 **커밋 SCN** 이 남으면, 추후 읽기가 Undo 추적 없이 빠르게 “커밋됨”을 판정한다.  
- **ITL 부족** 은 `enq: TX - allocate ITL entry` 로 드러나며, `INITRANS`/`PCTFREE`/키 분산/파티셔닝 등으로 해결한다.  
- **ORA-01555** 는 Undo 보존/용량/배치 타이밍 문제. `v$undostat` 로 추적하고 `UNDO_RETENTION`/용량/운영 창 분리로 대응한다.

> 한 줄 정리:  
> **Row Lock Byte → ITL → XID → Undo Slot** 이 이어지는 링크가  
> **행 잠금·일관 읽기·커밋 판정** 을 **정교하고 싸게** 해 주는 오라클의 핵심 메커니즘이다.
