---
layout: post
title: DB 심화 - Undo
date: 2025-10-15 21:25:23 +0900
category: DB 심화
---
# Oracle **UNDO** (19c 기준)

> 목표
> - **Undo 세그먼트(Transaction Table)** 의 슬롯 구조와 **XID(usn.slot.sqn)** 할당 과정을 정확히 이해합니다.
> - **데이터 블록 헤더의 ITL(Interested Transaction List) 슬롯**이 무엇을 저장하고 있으며, 어떻게 **행 잠금(row lock)** 과 연결되는지 파헤칩니다.
> - **Row Lock Byte(행 헤더의 잠금 바이트)** 가 ITL과 연계되어 동시성을 구현하는 방식을, *실습 SQL* · *대기 이벤트* · *블록 덤프* 예시까지 포함해 설명합니다.
> - **일관 읽기(Consistent Read)** 와 **ORA-01555(snapshot too old)** 를 *Transaction Table → Undo 체인 → CR 재구성* 흐름으로 이해합니다.
> - **ITL 부족(enq: TX - allocate ITL entry)** 재현 및 튜닝( `INITRANS`/`PCTFREE`/워크로드 분산 ) 방법을 제공합니다.

---

## 한눈에 보는 개요 — “트랜잭션은 Undo 세그먼트의 **슬롯**을 점유하고, 블록의 **ITL** 을 통해 **행 잠금**을 겁니다”

오라클의 트랜잭션 관리와 동시성 제어는 세 가지 핵심 요소가 얽혀 이루어집니다.

- **Undo 세그먼트의 트랜잭션 테이블 슬롯**
  - 각 Undo 세그먼트에는 **Transaction Table**(트랜잭션 테이블)이 존재하며, 그 안에는 **슬롯(slot)** 이 있습니다.
  - 트랜잭션이 시작되면 **자신만의 슬롯** 하나를 점유합니다. 이 슬롯은 트랜잭션의 **헤드(변경 체인, 상태, 커밋 SCN 등)** 정보를 보관합니다.
  - 트랜잭션 식별자는 **XID = usn.slot.sqn** (Undo Segment Number, Slot Number, Sequence Number) 형태를 가집니다.
- **데이터 블록 헤더의 ITL(Interested Transaction List) 슬롯**
  - 모든 데이터 블록 헤더에는 **ITL 엔트리**(슬롯)가 여러 개 존재합니다. 각 ITL은 **“이 블록을 현재 변경 중인 트랜잭션(XID)”** 을 가리킵니다.
  - ITL 엔트리는 **XID, Undo 포인터(최초 변경 지점), 플래그, 커밋 SCN(클린아웃 후)** 등의 메타데이터를 보유합니다.
- **Row Lock Byte(행 헤더의 잠금 바이트)**
  - 각 **행 헤더**는 “어느 ITL 슬롯이 나를 잠갔는지”를 **작은 바이트 값**(슬롯 인덱스)으로 표시합니다.
  - 이를 통해 **행 → (Lock Byte) → ITL 슬롯 → (XID) → Undo 트랜잭션 슬롯** 으로 이어지는 명확한 연결 고리가 형성됩니다.

이 세 요소가 상호작용하여 다음과 같은 핵심 기능을 달성합니다.

1) **행 레벨 잠금(Row-level Locking)** 으로 트랜잭션의 원자성(Atomicity)을 보장합니다.
2) **Undo 데이터를 기반으로 한 일관 읽기(Consistent Read)** 를 통해 격리성(Isolation)을 구현합니다.
3) **커밋과 클린아웃(Cleanout)** 메커니즘을 통해 내구성(Durability)을 표현하고 성능을 최적화합니다.

---

## Undo 세그먼트 — XID의 집

### XID(usn.slot.sqn)과 슬롯 할당 과정

트랜잭션이 시작되면, 오라클은 **특정 Undo 세그먼트(USN)** 의 **트랜잭션 테이블 슬롯** 하나를 점유하고 고유한 **XID** 를 생성합니다. 이 정보는 `v$transaction` 뷰에서 확인할 수 있습니다.

```sql
-- 현재 세션의 트랜잭션/XID/Undo 정보 확인
SELECT s.sid, s.serial#, t.xidusn, t.xidslot, t.xidsqn, t.status, t.start_time
FROM   v$session s
JOIN   v$transaction t ON t.ses_addr = s.saddr
WHERE  s.audsid = SYS_CONTEXT('USERENV','SESSIONID');
```

- **슬롯**은 트랜잭션이 활성 상태인 동안 유지되며, 커밋 또는 롤백 이후 재사용을 위해 해제됩니다.
- 각 슬롯은 트랜잭션의 **Undo 체인**(가장 최근 변경에서 과거로 이어지는 링크드 리스트)의 **헤드 포인터** 역할을 합니다.
  - **일관 읽기** 수행 시, 이 슬롯을 시작점으로 “해당 트랜잭션이 생성한 이전 버전의 데이터(Undo 레코드)”를 따라가며 **CR(Consistent Read) 블록**을 재구성합니다.

### 슬롯이 저장하는 정보(개념적)

- 트랜잭션의 내부 상태 코드(예: INACTIVE, ACTIVE, COMMITTED 등)
- **Undo 헤드 포인터** (가장 최근에 생성된 Undo 레코드의 위치)
- **커밋 SCN** (트랜잭션이 커밋된 시점. 지연 클린아웃 시 CR 판단 기준으로 사용됨)
- 기타 트랜잭션 관련 메타데이터 (내부 구조는 버전별로 약간의 차이가 있을 수 있음)

> **핵심 직관**: “**XID → 트랜잭션 슬롯**”은 **Undo 체인**의 **루트(Root)** 입니다. 모든 읽기 일관성 작업은 이 지점에서부터 시작됩니다.

---

## 데이터 블록 헤더의 **ITL 슬롯** — “이 블록은 지금 누가 변경 중인가?”

### ITL(Interested Transaction List)의 정의와 역할

데이터 **블록 헤더** 내에는 **ITL 엔트리** 목록이 존재하며, **각 ITL 엔트리는 이 블록에 변경 작업을 수행한(또는 수행 중인) 트랜잭션 하나** 에 해당합니다.

ITL 엔트리에는 일반적으로 다음과 같은 정보가 포함됩니다(개념적 설명).

  - **XID(usn.slot.sqn)** — 이 블록을 변경한 트랜잭션의 식별자
  - **Undo 포인터** (이 블록에 대한 첫 번째 변경을 기록한 Undo 레코드의 위치)
  - **플래그/상태 비트** (락 모드, 커밋 여부 등을 나타냄)
  - **커밋 SCN(cleanout 이후)** — 트랜잭션이 커밋되고 블록이 **클린아웃(cleanout)** 처리되면 ITL에 커밋 SCN이 기록됩니다.

> **클린아웃(Cleanout)** 이란: 트랜잭션 커밋 직후 또는 나중에 **지연(deferred)** 되어 발생하는 최적화 작업입니다. 해당 트랜잭션이 변경한 블록의 ITL에 **커밋 SCN**을 기록합니다. 이후 이 블록을 읽는 세션은 Undo 영역을 추적할 필요 없이, ITL의 커밋 SCN을 보고 “이 변경은 이미 커밋되었구나”를 빠르게 판단할 수 있습니다.

### ITL 부족 현상과 `enq: TX - allocate ITL entry` 대기

하나의 블록 내에서 사용 가능한 ITL 엔트리의 수는 제한되어 있습니다. **동시에 많은 트랜잭션이 같은 블록 내의 서로 다른 행을 갱신하려고 하면 ITL 엔트리가 고갈**될 수 있습니다.

이때 발생하는 대표적인 대기 이벤트가 **`enq: TX - allocate ITL entry`** 입니다.

완화 방법은 다음과 같습니다.
  - 오브젝트 생성 시 또는 변경 시 **`INITRANS`** 파라미터 값을 증가시켜 초기 ITL 수를 늘립니다.
  - **`PCTFREE`** 값을 적절히 높여 블록 헤더에 ITL이 확장될 수 있는 공간을 확보합니다.
  - **핫 블록(Hot Block) 현상을 분산**시킵니다. 파티셔닝, Reverse Key 인덱스, 샤딩(Sharding), 키 값 설계 변경 등을 통해 동일한 블록에 트랜잭션이 몰리지 않도록 합니다.

```sql
-- ITL 확장을 위한 저장 특성 변경 (주의: MOVE/REBUILD 작업 시 적용)
ALTER TABLE  t_orders  STORAGE (INITRANS 8) PCTFREE 20;
ALTER INDEX  ix_orders_cust  STORAGE (INITRANS 8);

-- ITL 부족 대기 이벤트를 겪고 있는 세션 확인
SELECT sid, event, state, seconds_in_wait
FROM   v$session
WHERE  event LIKE 'enq: TX - allocate ITL entry';
```

---

## **Row Lock Byte** — 행 헤더의 잠금 표시자

### Row Lock Byte의 역할

각 **행의 헤더(row header)** 에는 “**나를 잠근 트랜잭션이 사용하는 ITL 엔트리의 번호(인덱스)**” 가 **작은 바이트 값**으로 저장되어 있습니다.

이 값 덕분에, 데이터를 읽거나 변경하려는 세션은 **해당 행의 Row Lock Byte를 보고 특정 ITL 엔트리로 이동**할 수 있습니다. 그리고 그 ITL 엔트리에서 **XID와 커밋 상태**를 확인한 후, 필요하다면 **Undo 체인을 따라가 CR 블록을 재구성**합니다.

> 연결 구조 요약: **행(Row) →(Row Lock Byte)→ ITL 슬롯 → XID → Undo 세그먼트의 트랜잭션 테이블 슬롯**

### 동일 블록 내 다중 트랜잭션 동시 갱신 시나리오

동일한 블록 내의 여러 행이 서로 다른 트랜잭션에 의해 동시에 업데이트되는 경우, 각 행의 **Row Lock Byte**는 서로 다른 ITL 슬롯(또는 동일한 ITL 슬롯)을 가리키게 됩니다.

하나의 ITL 슬롯은 **동일한 트랜잭션이 변경한 여러 행**을 참조할 수 있습니다. 즉, ITL 슬롯은 “**해당 블록에서 그 트랜잭션이 차지한 자리표**” 역할을 합니다.

---

## 일관 읽기의 내부 메커니즘: **Transaction Slot → Undo Chain → CR 블록 재구성**

### “쿼리 SCN” 기준의 스냅샷 읽기

SELECT 문이 시작되면 먼저 **쿼리 SCN** 이 결정됩니다.
읽으려는 블록의 **마지막 변경 SCN** 이 **쿼리 SCN** 보다 **더 최신**인 경우, 다음과 같은 과정이 일어납니다.
  1. 해당 행의 **Row Lock Byte**를 확인하여 참조 중인 **ITL 슬롯**을 찾습니다.
  2. ITL 슬롯에서 **XID** 정보를 얻습니다.
  3. 이 XID를 통해 **Undo 세그먼트의 트랜잭션 테이블 슬롯**을 찾습니다.
  4. 해당 슬롯이 관리하는 **Undo 체인**을 따라가서, **쿼리 SCN 시점에 유효했던 데이터 값**을 찾습니다.
  5. 이 값을 이용해 **CR 블록**을 메모리에 재구성하고, 이를 결과로 반환합니다.

### ORA-01555(snapshot too old) 오류와 Undo 보존 정책

CR 블록을 재구성하는 데 필요한 **Undo 체인의 특정 레코드**가 **이미 재사용(reuse)** 되어 디스크에서 사라졌다면, 재구성이 불가능해집니다. 이때 발생하는 오류가 **ORA-01555 “snapshot too old”** 입니다.

주요 대응 방안은 다음과 같습니다.
  - 충분한 크기의 **`UNDO_TABLESPACE`** 와 적절한 **`UNDO_RETENTION`** 설정을 유지합니다.
  - 장시간 실행되는 리포트성 쿼리와 대규모 DML 작업이 동시에 수행되지 않도록 **작업 시간대를 분리**합니다.
  - 불필요하게 **빈번한 커밋**은 Undo 공간의 재사용을 촉진하므로, 배치 작업의 **커밋 단위를 조정**합니다.

```sql
-- 현재 Undo 관련 파라미터 설정 확인
SHOW PARAMETER undo_tablespace;
SHOW PARAMETER undo_retention;

-- Undo 통계 및 보존 상태 모니터링 (주요 컬럼)
SELECT begin_time, undoblks, txncount, ssolderrcnt, tuned_undoretention
FROM   v$undostat
ORDER  BY begin_time DESC FETCH FIRST 24 ROWS ONLY;
```

- `ssolderrcnt` : 조회 기간 동안 발생한 snapshot too old 오류 횟수입니다.
- `tuned_undoretention` : 오라클이 시스템 부하를 기반으로 자동 조정한 Undo 보존 시간입니다(Adaptive Undo Retention).

---

## **실습** — ITL 부족과 Row Lock Byte 동작 체험하기

> 주의: **테스트 전용** 환경에서만 실행하세요.

### 실습 준비: 작은 행과 좁은 블록을 만들어 동시 갱신을 유도합니다.

```sql
DROP TABLE t_itl PURGE;

-- 의도적으로 작은 INITRANS 값과 낮은 PCTFREE로 블록 헤더 공간을 제한합니다.
CREATE TABLE t_itl (
  id     NUMBER PRIMARY KEY,
  k      NUMBER NOT NULL,
  pad    VARCHAR2(50)
)
INITRANS 1
PCTFREE 5;

BEGIN
  FOR i IN 1..20000 LOOP
    INSERT INTO t_itl (id, k, pad)
    VALUES (i, MOD(i,10), RPAD('x',50,'x'));
    IF MOD(i,500)=0 THEN COMMIT; END IF;
  END LOOP;
  COMMIT;
END;
/
CREATE INDEX ix_itl_k ON t_itl(k);
```

### 동시 업데이트 수행 (두 개 이상의 세션에서 실행)

```sql
-- 세션 A, B, C ... 에서 동시에 실행하여 같은 블록에 부하를 집중시킵니다.
UPDATE t_itl
   SET pad = RPAD('y',50,'y')
 WHERE k = 0
   AND id BETWEEN 1 AND 1000;

COMMIT;
```

### 관측: ITL 부족 및 버퍼 관련 대기 이벤트 확인

```sql
-- 현재 발생 중인 대기 이벤트 확인
SELECT sid, event, state, seconds_in_wait
FROM   v$session
WHERE  state <> 'WAITED SHORT TIME'
AND    (event LIKE 'enq: TX - allocate ITL entry'
    OR  event LIKE 'buffer busy waits'
    OR  event LIKE 'read by other session')
ORDER  BY seconds_in_wait DESC;

-- 세그먼트 통계를 통해 버퍼 경합이 많은 오브젝트 식별
SELECT o.owner, o.object_name, SUM(s.value) waits
FROM   v$segment_statistics s
JOIN   dba_objects o ON o.owner=s.owner AND o.object_name=s.object_name
WHERE  s.statistic_name IN ('buffer busy waits','read by other session')
AND    o.object_name IN ('T_ITL','IX_ITL_K')
GROUP  BY o.owner, o.object_name
ORDER  BY waits DESC;
```

**예상되는 현상**
- `enq: TX - allocate ITL entry` 대기 이벤트가 관찰될 수 있습니다 (ITL 부족).
- 상황에 따라 `buffer busy waits`나 `read by other session` 이벤트도 함께 나타날 수 있습니다.
- 이 시나리오에서 **동일한 블록** 내에서 **여러 트랜잭션**이 **여러 행에 락을 걸며 경합**하므로, Row Lock Byte와 ITL 슬롯 간의 연결이 빈번하게 갱신됩니다.

### 개선: 핫블록 분산을 통한 완화

```sql
-- ITL 엔트리 수를 늘리고(PCTFREE 증가) 헤더 공간을 확보합니다.
ALTER TABLE t_itl MOVE INITRANS 8 PCTFREE 20;
ALTER INDEX ix_itl_k REBUILD INITRANS 8;

-- 해시 파티셔닝을 도입하여 동일 블록 집중 현상을 근본적으로 완화합니다.
DROP TABLE t_itl PURGE;
CREATE TABLE t_itl (
  id     NUMBER,
  k      NUMBER,
  pad    VARCHAR2(50),
  CONSTRAINT pk_t_itl PRIMARY KEY (id)
)
PCTFREE 20
INITRANS 4
PARTITION BY HASH (k)
PARTITIONS 16;

BEGIN
  FOR i IN 1..20000 LOOP
    INSERT INTO t_itl (id, k, pad)
    VALUES (i, MOD(i,10), RPAD('x',50,'x'));
    IF MOD(i,500)=0 THEN COMMIT; END IF;
  END LOOP;
  COMMIT;
END;
/
CREATE INDEX ix_itl_k ON t_itl(k) LOCAL INITRANS 4;
```

개선 후 **동일한 부하를 다시 시도**하면 `enq: TX - allocate ITL entry` 대기가 감소하고, 전반적인 버퍼 경합이 완화될 것으로 기대할 수 있습니다.

---

## **블록 덤프** 로 ITL과 Row Lock Byte 확인하기 (심화 학습)

> 실제 **Row Lock Byte** 와 **ITL 엔트리** 의 상세한 내용은 일반 SQL로 조회할 수 없으며, **블록 덤프(Block Dump)** 를 통해 내부 구조를 검증할 수 있습니다.
> (SYSDBA 권한이 필요하며, 테스트 환경에서 실행하세요. 먼저 데이터파일 번호와 블록 번호를 확인합니다.)

```sql
-- 특정 행이 위치한 블록 번호와 파일 번호를 확인합니다.
SELECT rowid, DBMS_ROWID.ROWID_BLOCK_NUMBER(rowid) AS blkno,
       DBMS_ROWID.ROWID_RELATIVE_FNO(rowid)        AS file#
FROM   t_itl
WHERE  id BETWEEN 1 AND 5;

-- 확인된 파일 번호와 블록 번호를 사용해 블록을 덤프합니다. (실제 값으로 대체 필요)
ALTER SYSTEM DUMP DATAFILE <file#> BLOCK <blkno>;
```

덤프 출력에서 주목할 부분은 다음과 같습니다.
- **ITL 리스트**: 각 슬롯별 **XID(usn.slot.sqn)**, 상태 플래그(**flg**), Undo 블록 주소(**uba**), **SCN**(클린아웃 후) 등의 정보
- **Row Directory/Row Header**: 각 **행(row)** 헤더의 **lock byte** 값이 **몇 번째 ITL**을 가리키는지 확인
- “클린아웃 전” 상태라면 ITL에 커밋 SCN이 기록되지 않아 있으며, 이후 읽기 시 **지연 클린아웃**이 발생하여 SCN이 채워질 수 있음

> 블록 덤프는 내부 구조 학습에 유용하나, 운영 중인 시스템에서 과도하게 수행하는 것은 피해야 합니다.

---

## **일관 읽기(Consistent Read)** 를 ITL/슬롯 관점에서 재구성

1.  **SELECT 시작** → **쿼리 SCN** 이 고정됩니다.
2.  데이터 블록을 읽습니다 → 특정 **행의 Row Lock Byte** 가 **ITL 슬롯 n** 을 가리키고 있음을 확인합니다.
3.  ITL 슬롯 n을 검사하여 **XID** 와 **커밋 상태**를 확인합니다.
    - **커밋 SCN이 기록되어 있고(클린아웃 완료)** 그 값이 **쿼리 SCN 이하**라면, “이 변경은 쿼리 시작 전에 커밋된 것”으로 판단 → 블록의 **현재 값**을 사용합니다.
    - 커밋 SCN 정보가 없거나 불충분하다면(클린아웃 전) → **트랜잭션 테이블 슬롯**을 추가로 조회하여 커밋 여부와 SCN을 확인합니다.
4.  쿼리 SCN 기준으로 **과거의 데이터 이미지**가 필요하다면, **Undo 체인** 을 따라가 해당 행의 **이전 값**으로 **CR 블록**을 재구성합니다.
5.  최종 결과를 반환합니다.

> 이 과정에서 필요한 Undo 체인의 일부가 재사용되어 사라졌다면 **ORA-01555** 오류가 발생합니다. 이는 Undo 공간의 보존 정책, 용량 계획, 배치 작업의 타이밍 조절을 통해 관리해야 합니다.

---

## 개념 정리 — “락(Row Lock), 핀(Pin), ITL, TX의 관계”

- **TX enqueue (행 수준 락)**: **행 레벨의 논리적 잠금**입니다. 트랜잭션이 커밋되거나 롤백될 때까지 유지됩니다.
- **ITL 슬롯**: **“이 블록을 변경 중인 트랜잭션”의 정보를 보관하는 슬롯**입니다. **Row Lock Byte**가 이를 가리킴으로써 특정 행과 특정 트랜잭션을 연결합니다.
- **버퍼 핀(pin)**: **메모리 내 버퍼 프레임을 보호**하는 매우 단기적인 메커니즘입니다. 버퍼가 디스크로 내려가지 않도록 방지하거나, 동시 수정을 막는 데 사용됩니다.
- **래치(Latch) / 뮤텍스(Mutex)**: ITL, Undo 체인, 블록 헤더 등의 **공유 메모리 구조체를 보호**하는 초단기 락입니다.

→ 실무에서 “버퍼에 락이 걸렸다”는 표현은 종종 **버퍼 핀/래치 충돌**과 **TX/ITL 관련 대기**를 혼용하여 쓰입니다. 각 메커니즘이 작용하는 레이어가 다르다는 점을 이해하는 것이 중요합니다.

---

## Undo/ITL/Row Lock 관련 **주요 대기 이벤트** 요약

- **`enq: TX - allocate ITL entry`** : 블록 헤더에 새로운 ITL 엔트리를 할당할 공간이 부족할 때 발생합니다.
- **`buffer busy waits`** : 다른 세션이 동일한 블록을 읽거나 쓰는 작업을 진행 중이라 접근을 기다려야 할 때 발생합니다.
- **`read by other session`** : 다른 세션이 해당 블록을 **물리적 읽기(physical read)** 중일 때, 그 읽기가 완료되기를 기다리는 대기입니다.
- **`gc buffer busy`** (RAC 환경) : 글로벌 캐시(Global Cache)에서 핫 블록에 대한 경합이 발생할 때 나타납니다.
- **`enq: TX - row lock contention`** : 서로 다른 트랜잭션이 **동일한 행을 업데이트**하려고 할 때 발생하는 **행 락 충돌** 대기입니다.

---

## 운영 관점에서의 점검 포인트

1.  **핫 블록(Hot Block) 탐지**
    - `v$segment_statistics` 뷰에서 `buffer busy waits` 와 `row lock waits` 통계가 높은 오브젝트를 식별합니다.
    - `x$bh` 내부 뷰의 `tch`(터치 카운트) 값을 통해 접근 빈도가 매우 높은 블록을 찾을 수 있습니다(SYS 권한 필요, 운영 중 과도한 조회는 지양).
2.  **ITL 관련 파라미터 설정 검토**
    - 동시 업데이트가 빈번한 테이블과 인덱스는 `INITRANS` 값을 충분히 높게 설정합니다.
    - `PCTFREE` 값을 적절히 조정하여 블록 헤더에 ITL이 확장될 수 있는 여유 공간을 확보합니다.
    - `MOVE` 또는 `REBUILD` 와 같은 오브젝트 재구성 작업 수행 시, 이러한 설정이 유지되도록 주의합니다.
3.  **데이터 분산 설계**
    - **해시 또는 범위 파티셔닝**, **Reverse Key 인덱스**, **카운터 샤딩** 등 키 설계 기법을 활용하여 **동일 블록에 트랜잭션이 집중되는 현상을 근본적으로 완화**합니다.
4.  **Undo 공간 관리**
    - `UNDO_RETENTION` 파라미터 설정과 `v$undostat.tuned_undoretention` 값을 주기적으로 모니터링합니다.
    - 장시간 실행되는 리포트 쿼리와 대규모 DML 작업의 **실행 시간대를 가능한 한 분리**합니다.
5.  **행 크기 및 블록 공간 관리**
    - `PCTFREE` 와 `PCTUSED`(ASSM 환경에서는 자동 관리) 파라미터를 통해 업데이트로 인한 행 확장과 블록 내 빈 공간을 관리합니다.
6.  **업무 트랜잭션 패턴 검토**
    - 불필요하게 **자잘한 커밋**을 반복하면 Undo/Redo 영역의 파편화를 유발하고 LGWR의 동기화 빈도를 증가시킬 수 있습니다.
    - 업무 요건을 해치지 않는 선에서 **배치 단위 커밋**을 고려하여 트랜잭션 오버헤드를 줄입니다.

---

## 추가 실습 — “Row Lock Byte ↔ ITL 연결”을 체감하는 미니 시나리오

### 테이블 및 테스트 데이터 준비

```sql
DROP TABLE t_lock PURGE;

CREATE TABLE t_lock (
  id   NUMBER PRIMARY KEY,
  g    NUMBER NOT NULL,
  pad  VARCHAR2(40)
)
INITRANS 1 PCTFREE 5;

BEGIN
  FOR i IN 1..5000 LOOP
    INSERT INTO t_lock VALUES (i, MOD(i,5), RPAD('a', 40, 'a'));
    IF MOD(i,500)=0 THEN COMMIT; END IF;
  END LOOP;
  COMMIT;
END;
/
CREATE INDEX ix_lock_g ON t_lock(g);
```

### 두 세션에서 동일 그룹의 행들을 동시에 갱신

```sql
-- 세션 A에서 실행 (아직 커밋하지 않습니다)
UPDATE t_lock SET pad = 'A' WHERE g = 0 AND id BETWEEN 1 AND 500;

-- 세션 B에서 실행 (세션 A의 작업이 진행 중일 때)
UPDATE t_lock SET pad = 'B' WHERE g = 0 AND id BETWEEN 400 AND 900;
```

- 두 업데이트 범위가 일부 겹칩니다(예: id 400~500). 이 경우 **동일한 블록 내의 일부 행들**에 대해 **Row Lock Byte** 가 세션 A의 ITL을 이미 가리키고 있으므로, 세션 B는 **TX 락 대기 또는 버퍼 대기**에 빠질 가능성이 높습니다.

### 세션 대기 상태 관측

```sql
SELECT sid, event, state, seconds_in_wait
FROM   v$session
WHERE  state <> 'WAITED SHORT TIME'
AND    (event LIKE 'enq: TX - row lock contention'
    OR  event LIKE 'enq: TX - allocate ITL entry'
    OR  event LIKE 'buffer busy waits')
ORDER  BY seconds_in_wait DESC;
```

### 해결: 커밋 수행 및 구조적 개선

- 세션 A에서 커밋을 수행하면 → **클린아웃**이 진행되어 관련 블록들의 ITL에 **커밋 SCN**이 기록됩니다. → 이후 다른 세션의 읽기/갱신 작업 시 Undo 영역을 추적할 필요가 줄어들어 성능이 개선됩니다.
- 이와 같은 **ITL 부족 또는 행 락 경합**이 빈번하게 관측된다면, 앞서 설명한 `INITRANS`/`PCTFREE` 상향 조정이나 파티셔닝을 통한 데이터 분산을 고려해야 합니다.

---

## 진단을 위한 참조 SQL 모음

```sql
-- 현재 세션의 트랜잭션 XID 및 Undo 슬롯 정보
SELECT s.sid, t.xidusn, t.xidslot, t.xidsqn, t.status, t.start_time
FROM   v$session s JOIN v$transaction t ON t.ses_addr = s.saddr
WHERE  s.audsid = SYS_CONTEXT('USERENV','SESSIONID');

-- Undo 사용량 및 보존 상태 추이 확인
SELECT begin_time, undoblks, txncount, ssolderrcnt, tuned_undoretention
FROM   v$undostat
ORDER  BY begin_time DESC FETCH FIRST 30 ROWS ONLY;

-- 세그먼트별 버퍼 경합 및 행 락 대기 통계
SELECT o.owner, o.object_name, o.object_type,
       SUM(CASE WHEN s.statistic_name='buffer busy waits' THEN s.value ELSE 0 END) AS buf_busy,
       SUM(CASE WHEN s.statistic_name='row lock waits'     THEN s.value ELSE 0 END) AS row_lock
FROM   v$segment_statistics s
JOIN   dba_objects o ON o.owner=s.owner AND o.object_name=s.object_name
GROUP  BY o.owner, o.object_name, o.object_type
ORDER  BY buf_busy DESC FETCH FIRST 15 ROWS ONLY;

-- ITL 부족 대기에 빠진 세션 확인
SELECT sid, event, state, seconds_in_wait
FROM   v$session
WHERE  event LIKE 'enq: TX - allocate ITL entry';

-- 특정 행의 블록 덤프를 위한 파일/블록 번호 조회 (예시)
SELECT rowid, DBMS_ROWID.ROWID_RELATIVE_FNO(rowid) AS file#,
               DBMS_ROWID.ROWID_BLOCK_NUMBER(rowid) AS block#
FROM   t_itl
WHERE  id BETWEEN 1 AND 3;
-- 이후 SYSDBA로: ALTER SYSTEM DUMP DATAFILE <file#> BLOCK <block#>;
```

---

## 결론

오라클 데이터베이스의 정교한 트랜잭션 관리와 동시성 제어는 **Undo 메커니즘, ITL 슬롯, Row Lock Byte**라는 세 축이 유기적으로 연결되어 구현됩니다. **Undo 세그먼트의 트랜잭션 테이블 슬롯**은 각 트랜잭션의 정체성(XID)과 변경 이력(Undo 체인)의 출발점을 정의합니다. **데이터 블록 헤더의 ITL 슬롯**은 해당 블록과 상호작용하는 트랜잭션들의 현황을 기록하는 게시판과 같습니다. 마지막으로 **행 헤더의 Row Lock Byte**는 각 행을 특정 ITL 슬롯, 즉 특정 트랜잭션에 연결하는 가벼우면서도 강력한 연결고리입니다.

이 삼각 구조는 **행 레벨 잠금**을 효율적으로 구현하고, **MVCC(Multi-Version Concurrency Control)** 기반의 **완벽한 일관 읽기**를 가능하게 하며, **커밋 후 클린아웃**을 통한 성능 최적화를 달성합니다. 실무에서 마주치는 `enq: TX - allocate ITL entry`나 `ORA-01555`와 같은 문제는 궁극적으로 이 구조에 대한 이해를 바탕으로 해결 방향을 찾을 수 있습니다. 테이블 설계 시 `INITRANS`, `PCTFREE`와 같은 기본 파라미터를 고려하고, 핫스팟(Hotspot)을 만들지 않는 데이터 분산 전략을 수립하는 것이 안정적이고 성능良好的인 시스템 운영의 지름길입니다.

> 한 마디로 정리하자면,
> **Row Lock Byte → ITL 슬롯 → XID → Undo 트랜잭션 슬롯** 으로 이어지는 명확한 연결 고리가
> **행 수준 잠금, 격리된 일관 읽기, 효율적인 커밋 처리**라는 오라클의 핵심 기능을 **정교하고도 낮은 비용으로** 구현해내는 기반입니다.