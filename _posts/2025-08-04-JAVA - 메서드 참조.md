---
layout: post
title: Java - 메서드 참조
date: 2025-08-04 19:20:23 +0900
category: Java
---
# 메서드 참조(Method Reference)

## 0. 한눈에 보는 핵심

- 메서드 참조는 **람다식이 “기존 메서드 1회 호출”만 수행**할 때의 **축약 문법**이다.
- **형태 4가지**
  1) 정적: `Class::staticMethod`
  2) 특정 객체 인스턴스: `instance::instanceMethod` (**bound**)
  3) 특정 클래스의 임의 객체 인스턴스: `Class::instanceMethod` (**unbound**)
  4) 생성자/배열 생성자: `Class::new`, `Type[]::new`
- **타깃 타입(함수형 인터페이스)의 추상 메서드 시그니처와 호환**되어야 한다.
- **언바운드 참조**는 “첫 번째 매개변수 = 수신 객체(receiver)” 규칙을 가진다.
- 오버로드가 섞이면 **명시적 캐스트**로 모호성을 해소한다.
- 런타임 구현은 람다와 동일 계열(`invokedynamic`)이라 **성능상 거의 동일** — 가독성이 기준.

---

## 1. 메서드 참조란?

람다:
```java
list.forEach(s -> System.out.println(s));
```

메서드 참조:
```java
list.forEach(System.out::println);
```

- `System.out::println`은 **이미 존재하는 메서드**를 **이름으로만 참조**하여 람다를 대체한다.
- “값을 변환하거나 합성하는 등 복잡한 로직”이 아니라, **그 메서드를 그대로 호출**할 때 사용한다.

---

## 2. 4가지 형태와 의미(시그니처 매핑 포함)

| 형태 | 표기 | 의미(람다로 전개) | 비고 |
|---|---|---|---|
| ① 정적 메서드 | `Class::staticMethod` | `x -> Class.staticMethod(x)` | 유틸리티/팩토리 등 |
| ② 인스턴스(바운드) | `instance::instanceMethod` | `args -> instance.instanceMethod(args)` | **수신 객체가 고정(bound)** |
| ③ 인스턴스(언바운드) | `Class::instanceMethod` | `(recv, args) -> recv.instanceMethod(args)` | **첫 인자 = 수신 객체** |
| ④ 생성자 | `Class::new` / `Type[]::new` | `args -> new Class(args)` / `len -> new Type[len]` | 컬렉션 변환·배열 toArray 등 |

### 2.1 정적 메서드 참조
```java
Function<String, Integer> strToInt = Integer::parseInt;
// == s -> Integer.parseInt(s)
```

### 2.2 인스턴스 메서드(바운드) 참조
```java
String s = "hello";
Supplier<String> toUpper = s::toUpperCase; // () -> s.toUpperCase()
```

### 2.3 인스턴스 메서드(언바운드) 참조
```java
// 첫 번째 매개변수가 수신 객체가 된다.
Function<String, Integer> len = String::length;         // s -> s.length()
BiPredicate<String, String> startsWith = String::startsWith; // (s, prefix) -> s.startsWith(prefix)
```

### 2.4 생성자/배열 생성자 참조
```java
Supplier<List<String>> listSupplier = ArrayList::new;           // () -> new ArrayList<>()
Function<Integer, List<String>> listWithSize = ArrayList::new;  // n -> new ArrayList<>(n)

String[] arr = names.toArray(String[]::new); // len -> new String[len]
```

---

## 3. 타깃 타입(함수형 인터페이스)과 시그니처 호환

메서드 참조는 **타깃 타입**(예: `Function<T,R>`, `Supplier<T>`, `BiConsumer<T,U>` 등)의 **추상 메서드 시그니처**와 **참조 메서드 시그니처**가 호환되어야 한다.

```java
@FunctionalInterface
interface Converter<F, T> { T convert(F from); }

Converter<String, Integer> c = Integer::parseInt; // (String)->int/Integer OK
System.out.println(c.convert("123")); // 123
```

- 오토박싱/언박싱 포함하여 호환 판단.
- 언바운드 인스턴스 참조는 **첫 인자가 수신 객체 타입**으로 맞아야 한다.

---

## 4. 오버로드와 모호성 — 캐스트로 해결

여러 오버로드가 후보가 되어 **컴파일러가 타깃을 결정 못하는 경우** 명시적 캐스트로 타깃 타입을 지정한다.

```java
void foo(Runnable r) {}
void foo(Callable<Integer> c) {}

foo((Callable<Integer>) () -> 1); // or
foo((Callable<Integer>) Integer::valueOf); // (String)->Integer와 혼동 없게 명시
```

**메서드 참조도 동일**:
```java
// 예: println 오버로드 다수 → Consumer<Object>로 명시
Consumer<Object> p = System.out::println;
```

---

## 5. 제네릭/varargs/가시성/예외 — 디테일

### 5.1 제네릭 메서드 참조
```java
// Comparator.comparing은 제네릭 정적 메서드
Comparator<Person> byName = Comparator.comparing(Person::name);
Comparator<Person> byNameThenAge =
    Comparator.comparing(Person::name).thenComparingInt(Person::age);
```

### 5.2 varargs 메서드 참조
varargs는 호출 시 **배열로 수렴**하므로 일반 참조처럼 사용 가능.
```java
Function<List<String>, String[]> toArray = l -> l.toArray(String[]::new);
```

### 5.3 접근 제어(가시성)
- 참조 대상 메서드는 **접근 가능**해야 한다(같은 가시성 규칙).
- `private`/`package` 등 범위에 유의.

### 5.4 체크 예외
- 람다와 동일하게 **타깃 함수형 인터페이스가 `throws`** 를 갖고 있어야 한다.
```java
@FunctionalInterface interface IOFunc<T,R> { R apply(T t) throws IOException; }
IOFunc<Path, String> readAll = Files::readString; // JDK 11+, throws IOException
```

### 5.5 `super` 한정 메서드 참조
- 내부 컨텍스트에서 `SomeInterface.super::method` 같은 형태로 **상위 디폴트 메서드**를 참조할 수 있다(드문 케이스, 인터페이스 디폴트 메서드 충돌 해결 문맥에서 사용).

---

## 6. 스트림/컬렉터/Optional/동시성 — 실전 레시피

### 6.1 기본 파이프라인
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.stream()
     .map(String::toUpperCase)
     .forEach(System.out::println);
```

### 6.2 Comparator 빌드(가독성 최고 레시피)
```java
record Person(String name, int age) {}
List<Person> people = List.of(new Person("Kim", 30), new Person("Lee", 28), new Person("Kim", 25));

people.stream()
      .sorted(Comparator.comparing(Person::name)          // 1차 키: 이름
                        .thenComparingInt(Person::age))   // 2차 키: 나이
      .forEach(System.out::println);
```

### 6.3 수집기(Collector)와 함께
```java
// joining
String joined = names.stream().collect(Collectors.joining(", "));

// groupingBy + 메서드 참조
Map<Integer, List<String>> byLen =
    names.stream().collect(Collectors.groupingBy(String::length));

// toMap 키/값 추출에 메서드 참조(중복 키 주의)
record User(long id, String name) {}
List<User> users = List.of(new User(1,"A"), new User(2,"B"));
Map<Long, String> idToName =
    users.stream().collect(Collectors.toMap(User::id, User::name));
```

### 6.4 `collect(Supplier, BiConsumer, BiConsumer)` 3항 형태
```java
List<String> upper = names.stream()
  .map(String::toUpperCase)
  .collect(ArrayList::new, ArrayList::add, ArrayList::addAll); // 생성자/추가/병합 모두 참조
```

### 6.5 배열 변환 — `toArray(String[]::new)`가 정석
```java
String[] arr = names.stream().filter(s -> s.length() > 3)
                    .toArray(String[]::new);
```

### 6.6 Optional과의 조합
```java
Optional<String> firstK = names.stream()
    .filter(s -> s.startsWith("K"))
    .findFirst();

firstK.ifPresent(System.out::println);
```

### 6.7 동시성 API: `CompletableFuture`와 결합
```java
ExecutorService ex = Executors.newFixedThreadPool(4);
CompletableFuture.supplyAsync(() -> "hi", ex)
                 .thenApply(String::toUpperCase)
                 .thenAccept(System.out::println);
ex.shutdown();
```

---

## 7. 바운드/언바운드 차이를 감각적으로 이해하기

### 7.1 바운드(bound)
```java
var printer = System.out::println; // Consumer<String>로 추론 가능
// 수신 객체(System.out)가 **이미 고정**되어 있다.
```

### 7.2 언바운드(unbound)
```java
// 첫 인자가 수신 객체가 됨
BiPredicate<String, String> endsWith = String::endsWith;
// (s, suf) -> s.endsWith(suf)
```

> **규칙**: **언바운드 참조 = (receiver, args) → receiver.method(args)**

---

## 8. 가독성과 성능 — 언제 메서드 참조를 쓸까?

- **성능**: 메서드 참조와 동등 람다는 둘 다 `invokedynamic` 기반 → **차이 미미**(동일하다고 봐도 됨).
- **가독성/의도 표현**이 기준:
  - **단순 호출**이면 ***메서드 참조***가 더 읽기 좋다.
  - **중간에 전처리/후처리/분기**가 있으면 ***람다***가 낫다.

**예시(가독성 비교)**

```java
// 메서드 참조가 의도를 더 직설적으로 보여줌
list.stream().map(String::trim).filter(String::isEmpty).count();

// 로직이 길면 명명된 메서드로 분리 후 참조
list.stream().filter(MyFilters::isAllowed).map(MyMappers::toDto).toList();
```

---

## 9. 안티패턴 & 주의점

1) **시그니처 불일치**
```java
Function<Integer, String> g = String::toUpperCase; // 컴파일 에러 (수신/매개변수 불일치)
```

2) **의미 혼동**
```java
list.sort(String::compareTo); // 자연 오름차순
// 내림차순 의도면 람다/Comparator.reverseOrder로 명시:
list.sort((a, b) -> b.compareTo(a));
// 또는 Comparator.comparing(String::toString).reversed()
```

3) **캡처가 필요하면 람다 사용**
```java
String suffix = "_x";
// 메서드 참조로는 suffix 캡처 불가 → 람다로:
Function<String, String> f = s -> s + suffix;
```

4) **오버로드 모호성 방치 금지** → **캐스트로 타깃 타입 지정**
5) **toMap 중복 키 예외** 주의: 합병 함수 제공
```java
Map<String, Long> freq = words.stream()
  .collect(Collectors.toMap(Function.identity(), w -> 1L, Long::sum));
```

---

## 10. 고급 테크닉 모음

### 10.1 커스텀 함수형 인터페이스와 결합
```java
@FunctionalInterface interface TriFunction<A,B,C,R> { R apply(A a,B b,C c); }
TriFunction<Integer, Integer, Integer, String> f = String::format; // (fmt, a, b)? 불일치 주의
// 올바른 예:
TriFunction<String, Object, Object, String> fmt = String::format; // (format, a, b) -> String
```

### 10.2 생성자 참조로 팩토리 주입
```java
interface RepoFactory<R> { R create(DataSource ds); }
class UserRepo { UserRepo(DataSource ds) { ... } }

RepoFactory<UserRepo> factory = UserRepo::new;
UserRepo repo = factory.create(ds);
```

### 10.3 메서드 참조로 조합기를 구성
```java
Function<String, Integer> toLen = String::length;
Function<Integer, String> toStr = Object::toString;
Function<String, String> lenStr = toLen.andThen(toStr);
```

### 10.4 배열/버퍼 변환
```java
IntFunction<int[]> mk = int[]::new; // n -> new int[n]
int[] a = mk.apply(10);
```

### 10.5 `super` 디폴트 메서드 선택 (인터페이스 충돌 해결 맥락)
```java
interface A { default String n(){ return "A"; } }
interface B { default String n(){ return "B"; } }
class C implements A,B {
  public String n(){ return A.super.n(); } // 필요 시 메서드 참조로 전달 가능: A.super::n (사용 맥락 제한적)
}
```

> `A.super::n`은 **해당 컨텍스트 내부**에서만 사용 가능하고, 사용 사례가 제한적입니다.

---

## 11. 실전 예제 모음

### 11.1 로그/출력 파이프
```java
Stream.of("a","b","c").forEach(System.out::println);
```

### 11.2 파일 읽기(예외 시그니처 호환)
```java
@FunctionalInterface interface IOFunc<T,R> { R apply(T t) throws IOException; }
IOFunc<Path, String> reader = Files::readString; // JDK 11+, throws IOException
```

### 11.3 도메인 변환 파이프라인
```java
record User(long id, String name) {}
record UserDto(long id, String name) {}

Function<User, UserDto> toDto = u -> new UserDto(u.id(), u.name());
List<UserDto> dtos = users.stream().map(toDto).toList();
// 변환 메서드로 분리 후 참조
class Mappers { static UserDto toDto(User u){ return new UserDto(u.id(), u.name()); } }
List<UserDto> dtos2 = users.stream().map(Mappers::toDto).toList();
```

### 11.4 컬렉션 팩토리/머지 연산
```java
List<String> dst = src.stream().collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
```

### 11.5 숫자 통계/요약
```java
IntSummaryStatistics stats = people.stream()
                                   .collect(Collectors.summarizingInt(Person::age));
```

---

## 12. FAQ

- **Q. 메서드 참조가 람다보다 빠른가요?**
  A. 일반적으로 **동일**합니다. 둘 다 `invokedynamic`을 통해 런타임에 구현 인스턴스를 생성합니다.

- **Q. 언제 람다를 쓰고 언제 메서드 참조를 쓰나요?**
  A. **단순 호출**은 메서드 참조, **로직/분기/캡처 필요** 시 람다.

- **Q. 언바운드 참조가 왜 헷갈리나요?**
  A. “첫 인자 = 수신 객체” 규칙을 **항상 기억**하세요. `(recv, args) -> recv.method(args)`.

---

## 13. 베스트 프랙티스 체크리스트

- [ ] 단순 호출이면 **메서드 참조**로 의도 명확화
- [ ] **언바운드 규칙**: 첫 인자가 receiver임을 기억
- [ ] **오버로드 모호성**은 **명시적 캐스트**로 해소
- [ ] **예외 시그니처**(checked) 호환 여부 확인
- [ ] `toArray(String[]::new)`처럼 **배열 생성자 참조** 적극 사용
- [ ] `Comparator.comparing(X::key).thenComparingInt(X::other)` 패턴 습관화
- [ ] 캡처가 필요하면 **람다/명명 메서드 분리**
- [ ] 가독성 우선 — 과한 축약보다 **의도 전달**이 중요

---

## 14. 종합 요약

- 메서드 참조는 **람다의 축약형**으로, **타깃 함수형 인터페이스**와 **시그니처 호환**이 핵심이다.
- **정적/바운드/언바운드/생성자** 4가지 형태와 **언바운드의 receiver 규칙**을 이해하면 대부분의 혼란이 사라진다.
- 스트림/컬렉터/Optional/CompletableFuture 등에서 **표현력을 크게 높이는 도구**이며, 성능상 손해 없이 **가독성**을 개선한다.
- **오버로드/예외/가시성**의 세부 규칙만 챙기면, 실무에서 가장 많이 쓰이는 함수형 표현식의 **정석**으로 자리 잡을 수 있다.

---
```java
// 부록: 주요 표준 함수형 인터페이스와 예시 참조
Supplier<List<String>> mkList = ArrayList::new;                 // () -> List<String>
Function<String, Integer> toInt = Integer::parseInt;            // (String) -> Integer
Predicate<String> isEmpty = String::isEmpty;                    // (String) -> boolean
BiPredicate<String, String> sw = String::startsWith;            // (s, pre) -> boolean
UnaryOperator<String> trim = String::trim;                      // (String) -> String
BinaryOperator<Integer> max = Integer::max;                     // (a, b) -> Integer
BiFunction<String, String, Integer> cmp = String::compareTo;    // (a, b) -> int (언바운드)
IntFunction<String[]> mkArray = String[]::new;                  // (len) -> new String[len]
```
