---
layout: post
title: JavaScript - 이벤트 처리
date: 2025-05-13 20:20:23 +0900
category: JavaScript
---
# 자바스크립트 이벤트 처리

## 큰 그림: 이벤트 루프와 이벤트 타이밍 한 줄 요약

- 이벤트 콜백은 **콜 스택이 비는 시점**에 **태스크 큐**에서 **마이크로태스크(프라미스 등) 이후** 실행됩니다.
- 동일 프레임에서 **“캡처링 → 타겟 → 버블링”** 순서로 전파됩니다.

---

## `addEventListener` — 기본과 옵션

```js
element.addEventListener(type, listener, options);
// options: boolean | { capture?, once?, passive?, signal? }
```

### 필수 패턴

```js
const button = document.querySelector('#myButton');

button.addEventListener('click', (e) => {
  console.log('clicked', e.type, e.target, e.currentTarget);
});
```

### 옵션 설명

| 옵션 | 효과 | 기본값 | 메모 |
|---|---|---|---|
| `capture` | 캡처 단계에서 실행 | `false` | 버블링 기본 흐름을 바꾸고 싶을 때 |
| `once` | 한 번만 실행 후 자동 해제 | `false` | 수동 해제 불필요 → 누수 방지 |
| `passive` | `preventDefault()` 금지(무시) | `false` | 스크롤/터치 성능 최적화 |
| `signal` | `AbortController`로 **일괄 해제** | 없음 | 리스너 수명 명확화(강력 추천) |

```js
// 자동 해제: once
window.addEventListener('resize', onFirstResize, { once: true });

// 스크롤 성능: passive
window.addEventListener('scroll', onScroll, { passive: true });

// 수명 관리: AbortController
const controller = new AbortController();
document.addEventListener('click', handler, { signal: controller.signal });
// ...나중에 한번에 해제
controller.abort();
```

---

## 이벤트 객체 핵심 프로퍼티

```js
element.addEventListener('click', (event) => {
  console.log(event.type);          // "click"
  console.log(event.target);        // 실제 클릭된 가장 안쪽 노드
  console.log(event.currentTarget); // 리스너가 바인딩된 노드
});
```

자주 쓰는 메서드:

- `event.preventDefault()` : 기본 동작 취소(링크 탐색/폼 제출 등)
- `event.stopPropagation()` : 상위로 전파 중단
- `event.stopImmediatePropagation()` : **같은 노드의 다른 리스너**도 중단
- `event.composedPath()` : Shadow DOM 포함 실제 전파 경로 배열

> `passive: true` 리스너에서 `preventDefault()`를 호출하면 **무시**됩니다(콘솔 경고).

---

## 전파 흐름: 캡처링 → 타겟 → 버블링

```html
<div id="outer">
  <button id="inner">클릭</button>
</div>
```

```js
const outer = document.getElementById('outer');
const inner = document.getElementById('inner');

outer.addEventListener('click', () => console.log('outer capture'), { capture: true });
inner.addEventListener('click', () => console.log('inner'));
outer.addEventListener('click', () => console.log('outer bubble'));

// 클릭 순서:
// 1) outer capture
// 2) inner (타겟 단계)
// 3) outer bubble
```

전파 제어:

```js
inner.addEventListener('click', (e) => {
  e.stopPropagation(); // 'outer bubble'은 더 이상 실행되지 않음
});
```

> `focus/blur`는 버블링하지 않지만, `focusin/focusout`은 버블링합니다.

---

## 이벤트 위임(Event Delegation) — 동적 DOM의 정석

많은 자식마다 리스너를 붙이지 말고, **부모에 1개 리스너**를 붙여 **목표를 판별**합니다.

```html
<ul id="todo">
  <li data-id="1"><button class="del">삭제</button></li>
  <li data-id="2"><button class="del">삭제</button></li>
</ul>
```

```js
const list = document.getElementById('todo');

list.addEventListener('click', (e) => {
  const btn = e.target.closest('button.del');
  if (!btn || !list.contains(btn)) return; // 위임 경계 보장
  const li = btn.closest('li');
  console.log('delete id:', li.dataset.id);
  li.remove();
});
```

장점
- 동적으로 추가된 항목도 동작
- 리스너 수 감소 → 메모리/성능 이점

주의
- `stopPropagation()`이 중간에서 호출되면 위임 부모까지 도달하지 못할 수 있음
- Shadow DOM 경계는 `event.target`만으로 모호해질 수 있으니 `composedPath()` 활용

---

## 기본 동작 취소와 접근성

### 기본 동작 취소

```js
// 링크 탐색 취소
document.querySelector('a.block').addEventListener('click', (e) => {
  e.preventDefault();
  // SPA 라우팅 처리 등
});
```

### 폼 전송 제어

```js
form.addEventListener('submit', (e) => {
  if (!form.checkValidity()) {
    e.preventDefault();
  }
});
```

### 접근성/키보드 대응

- **버튼 역할**은 실제 `<button>` 사용(엔터/스페이스 키, 포커스 링 자동 처리)
- 커스텀 위젯은 `role`, `tabindex`, 키 핸들링(`keydown`)을 명시적으로 구현

```js
el.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault(); // 스페이스 스크롤 방지
    el.click();
  }
});
```

---

## 키보드/입력 이벤트 심화

| 이벤트 | 타이밍/설명 |
|---|---|
| `keydown` | 키를 누르는 순간(반복 발생 가능) |
| `keyup` | 키에서 손을 뗄 때 |
| `input` | 값이 실제로 바뀌는 즉시(IME 합성 완료 후) |
| `beforeinput` | 값 변경 **직전**(취소 가능), 리치 에디터에서 유용 |
| `compositionstart/…/end` | 한글/일본어 등 IME 합성 과정 |

포인트:

- 단축키는 **`keydown`** 기준이 편리
- IME가 있는 언어는 `composition` 이벤트 흐름 고려
- 키 판별은 `event.key`(문자/명칭), 레이아웃 무시 물리 키는 `event.code`

---

## 포인터/마우스/터치 — 현대 브라우저 표준은 Pointer Events

| 이벤트 계열 | 장치 | 비고 |
|---|---|---|
| Mouse Events (`click`, `mousemove`…) | 마우스 | 구 표준, 데스크톱 중심 |
| Touch Events (`touchstart`…) | 터치 | iOS 사파리 호환 고려 시 필요 |
| **Pointer Events** (`pointerdown`…) | 마우스/터치/펜 통합 | **권장**: 일관 API, `pointerId`/`pressure` 등 |

```js
el.addEventListener('pointerdown', onDown);
el.addEventListener('pointermove', onMove);
el.addEventListener('pointerup', onUp);

// 드래그 중 포인터 캡처(터치/펜가 다른 요소로 벗어나도 추적 지속)
function onDown(e) {
  el.setPointerCapture(e.pointerId);
}
```

자주 헷갈리는 페어:

- `mouseover`/`mouseout` : 버블링함(자식 간 이동도 발생)
- `mouseenter`/`mouseleave` : **버블링 안 함**, 순수 진입/이탈만

휠:

```js
container.addEventListener('wheel', onWheel, { passive: false });
function onWheel(e) {
  // 수평 스크롤 UI 등에서 필요 시
  e.preventDefault();
}
```

---

## 스크롤/제스처 성능 — `passive`와 스로틀/디바운스

### `passive: true`로 레이아웃 차단 방지

```js
window.addEventListener('scroll', onScroll, { passive: true });
```

### 스로틀/디바운스 유틸

```js
const throttle = (fn, wait) => {
  let last = 0;
  return (...args) => {
    const now = Date.now();
    if (now - last >= wait) {
      last = now; fn(...args);
    }
  };
};

const debounce = (fn, wait) => {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), wait);
  };
};

// 예: 리사이즈
window.addEventListener('resize', throttle(reflow, 100));
```

---

## 리스너 수명과 누수 방지

### 자동 해제 옵션

- `{ once: true }` : 1회 후 자동 제거
- `{ signal }` : 컨트롤러로 일괄 해제

```js
const controller = new AbortController();

function mount() {
  document.addEventListener('click', onDoc, { signal: controller.signal });
}
function unmount() {
  controller.abort(); // onDoc 자동 해제
}
```

### 수동 해제

```js
function handler() {}
el.addEventListener('click', handler);
// ...
el.removeEventListener('click', handler);
```

> 같은 참조의 함수여야 해제됩니다(익명 화살표로 등록한 것은 해제 어려움).

---

## 커스텀 이벤트와 `EventTarget`

### `CustomEvent`

```js
const ev = new CustomEvent('cart:add', {
  detail: { id: 123, qty: 2 },
  bubbles: true,
  composed: true // Shadow DOM 바깥으로도 버블링
});
button.dispatchEvent(ev);

document.addEventListener('cart:add', (e) => {
  console.log('added', e.detail);
});
```

### 독립 `EventTarget`로 미니 이벤트 버스

```js
class Bus extends EventTarget {
  emit(type, detail) { this.dispatchEvent(new CustomEvent(type, { detail })); }
}
const bus = new Bus();
bus.addEventListener('ping', e => console.log(e.detail));
bus.emit('ping', { t: Date.now() });
```

---

## Shadow DOM/웹 컴포넌트 전파

- Shadow 경계 안에서 발생한 이벤트는 기본적으로 **구성된 경로**를 따라 전파
- 바깥에서 `event.target`은 종종 **“슬롯팅된 노드/호스트”**로 보정됨
- 진짜 경로가 필요하면 `event.composedPath()` 사용

```js
host.addEventListener('click', (e) => {
  const path = e.composedPath();
  // path[0]는 실제 내부 최하위 타겟
});
```

`CustomEvent`를 외부로 버블링하려면 `composed: true` 설정.

---

## 실전 시나리오 모음

### 외부 클릭 감지(모달 닫기)

```js
function bindOutsideClick($panel, onClose, controller) {
  document.addEventListener('pointerdown', (e) => {
    if (!$panel.contains(e.target)) onClose();
  }, { signal: controller.signal });
}

// 사용
const ctl = new AbortController();
bindOutsideClick(panel, () => { panel.hidden = true; ctl.abort(); }, ctl);
```

### 드래그-셀렉트(기본 드래그 취소)

```js
canvas.addEventListener('dragstart', (e) => e.preventDefault()); // 이미지 드래그 방지
canvas.addEventListener('pointerdown', startDrag);
```

### 키보드 내비게이션(리스트)

```js
list.addEventListener('keydown', (e) => {
  const items = [...list.querySelectorAll('[role="option"]')];
  const idx = items.findIndex(el => el === document.activeElement);
  if (e.key === 'ArrowDown') items[Math.min(idx + 1, items.length - 1)]?.focus();
  if (e.key === 'ArrowUp') items[Math.max(idx - 1, 0)]?.focus();
});
```

---

## 디버깅/툴링 팁

- **Chrome DevTools → Event Listeners** 패널에서 바인딩 확인/제거
- **`getEventListeners(node)`**(DevTools 콘솔)로 연결된 리스너 나열
- 전역 디버깅용 래퍼:

```js
function logAll(el, types) {
  types.forEach(t => el.addEventListener(t, (e) => {
    console.log(`[${t}]`, { target: e.target, currentTarget: e.currentTarget, phase: e.eventPhase });
  }));
}
logAll(document, ['click', 'keydown']);
```

---

## 체크리스트

- [ ] **위임 가능한가?**(성능/동적 DOM) → 부모 1개로 처리
- [ ] **`passive` 가능?**(스크롤/터치) → `preventDefault()` 필요 여부 확인
- [ ] **수명 관리**: `{ once }` 또는 `{ signal }`로 누수 방지
- [ ] **접근성**: `<button>`/폼 기본 동작 유지, 키보드 지원
- [ ] **Shadow DOM**: `composedPath()`/`composed: true` 필요 여부
- [ ] **중복 바인딩 방지**: 동일 핸들러 참조/해제 경로 확보

---

## 자주 하는 실수와 교정

| 실수 | 문제 | 해결 |
|---|---|---|
| 스크롤 리스너에서 레이아웃 변경 + `passive` 미사용 | 버벅임 | `{ passive: true }` + 스로틀 |
| 각 아이템마다 리스너 바인딩 | 메모리/성능 낭비 | 이벤트 **위임** |
| 익명 함수로 바인딩 후 해제 시도 | 해제 실패 | **이름 있는 함수**/참조 보관 |
| Anchor로 버튼 역할 구현 | 엔터/스페이스/ARIA 문제 | `<button>` 사용 또는 역할/키 핸들 구현 |
| 터치 제스처에서 기본 스크롤과 충돌 | 화면 튐 | `touch-action` CSS 또는 적절한 `preventDefault()` |

---

## 요약

- 이벤트는 **캡처링 → 타겟 → 버블링** 단계로 전파.
- **위임**은 동적 UI의 기본 설계.
- 성능은 **`passive` + 스로틀/디바운스**로 확보.
- 수명 관리는 **`once` / `AbortController(signal)`**로 누수 방지.
- 포인터 이벤트로 **장치 통합** 처리, Shadow DOM은 **`composedPath()`**로 추적.
- 접근성과 기본 동작을 존중하면서 필요한 경우에만 **`preventDefault()`**를 사용.

이 가이드를 바탕으로, 복잡한 인터랙션을 **짧고 견고하고 빠르게** 구현할 수 있습니다.
