---
layout: post
title: DB 심화 - PL/SQL 함수의 특징과 성능 부하
date: 2025-11-01 22:25:23 +0900
category: DB 심화
---
# PL/SQL 함수의 특징과 성능 부하 — 원리·주의점·올바른 사용 기준 (Oracle 중심)

> **핵심 요약**
> - **PL/SQL 함수**는 SQL 엔진 안에서 **행마다** 호출될 수 있고, 호출할 때마다 **SQL↔PL/SQL 컨텍스트 전환**과 함수 본문 실행 비용이 발생한다.  
> - 함수 내부에 **추가 SQL(재귀 호출, recursive call)** 이 없더라도 **호출 수가 많으면** CPU가 급격히 증가한다.  
> - 함수 내부에서 **SELECT/INSERT 등 SQL을 수행**하면 **각 행마다 또 다른 SQL**이 실행되어 **I/O·락·대기**가 폭증한다(전형적인 **N+1** 패턴).  
> - **필터 조건 WHERE 절**에서 **열에 함수를 씌우면** 인덱스 접근이 깨져 **SARGability**(인덱스 활용성)를 잃는다 → **함수 기반 인덱스** 또는 **함수 없이 쓰는 식**(또는 **SQL 매크로**)으로 재작성해야 한다.  
> - SELECT의 **읽기 일관성(consistent read)** 규칙은 함수 안에서 실행되는 SQL에도 적용되지만, **자율 트랜잭션**, **외부 자원**, **비결정성**(SYSDATE/SEQUENCE 등)이 섞이면 일관성·결정성이 깨질 수 있다.  
> - **올바른 사용 기준**: (1) **SQL로 해결 가능한 계산은 SQL로**, (2) 불가피한 함수는 **비용이 작은 위치**(필터 이후·결과 투영)에서, (3) **재귀 SQL 금지** 또는 **배치/조인·캐시로 대체**, (4) 인덱스가 필요한 필터라면 **함수 기반 인덱스**나 **식 변환**으로 SARG 유지, (5) **PRAGMA UDF/RESULT_CACHE/DETERMINISTIC** 등 최적화 장치의 **의미와 한계**를 이해하고 선택.

---

## 1. PL/SQL 함수의 특징

### 1.1 호출 맥락과 컨텍스트 전환
- SQL 문장 안에서 **스칼라 함수**를 호출하면, 각 행(또는 필요 시점)마다 **SQL 엔진 → PL/SQL 엔진**으로 제어가 넘어갔다가 돌아옴.  
- 이때 발생하는 **컨텍스트 스위칭 비용**은 함수 본문이 아주 가벼워도 **호출 횟수에 비례**해 누적된다.

> 간단 근사:
> $$
> \text{총비용} \approx N_{\text{calls}} \times (\text{컨텍스트 전환 비용} + \text{함수 본문 CPU})
> $$

### 1.2 결정성·순수성
- `DETERMINISTIC` : **같은 입력 → 같은 출력**을 약속하는 표식(옵티마이저 힌트가 아님).  
  - 자체 캐시를 자동으로 제공하지 않는다(= **성능 보장 아님**).  
- `RESULT_CACHE` : **결과 캐시** 사용. 동일 입력(및 의존 객체 상태 불변)일 때 **메모리 캐시 히트** 가능.  
- `PRAGMA UDF` : SQL 안에서 자주 호출되는 가벼운 함수의 **컨텍스트 전환 비용**을 낮추기 위해 도입된 최적화 힌트(12cR2+).  
  - **순수 계산형**(문자열 변환, 수치 연산, 가벼운 파싱 등)에서 효과.

### 1.3 함수 카테고리
1) **순수 계산형**(재귀 SQL 없음): 문자열 정규화, 단순 수학 변환 등  
2) **자원 접근형**: 패키지 전역 상태/파일/네트워크/외부 프로시저… (*일반적으로 SQL 안에서 금지/지양*)  
3) **재귀 SQL형**: 함수 내부에서 `SELECT/INSERT/UPDATE/DELETE` 수행 (**주의**: 성능 병목의 주범)

---

## 2. 재귀 호출이 **없는** 함수의 성능 부하

### 2.1 예제: 간단 정규화 함수(순수 계산 + PRAGMA UDF)
```sql
CREATE OR REPLACE FUNCTION normalize_region(p_txt VARCHAR2)
  RETURN VARCHAR2
  PARALLEL_ENABLE
  RESULT_CACHE
  PRAGMA UDF
IS
  v VARCHAR2(30);
BEGIN
  v := UPPER(TRIM(p_txt));
  IF v IN ('APAC','ASIA PACIFIC') THEN RETURN 'APAC';
  ELSIF v IN ('EMEA','EUROPE')    THEN RETURN 'EMEA';
  ELSIF v IN ('AMER','US','NA')   THEN RETURN 'AMER';
  ELSE RETURN 'OTHER';
  END IF;
END;
/
```

- **특징**:  
  - **컨텍스트 스위칭** + **본문 CPU**만 비용 요소.  
  - **재귀 SQL 없음** → I/O·락 대기 유발 X.  
  - `PRAGMA UDF`로 컨텍스트 전환 최적화, `RESULT_CACHE`로 **동일 인자 반복 호출** 시 캐시 히트 가능.

### 2.2 사용과 비용 위치
```sql
-- (A) 필터에 사용: 인덱스가 깨질 수 있음(뒤에서 자세히)
SELECT * FROM sales WHERE normalize_region(region) = 'APAC';

-- (B) 투영(SELECT-LIST)에서 사용: 필터/조인 이후 소수 행에만 호출 → 비용 작음 (권장 위치)
SELECT normalize_region(region) AS region_norm, amount
FROM   sales
WHERE  region IN ('APAC','EMEA');
```

- **권장**: 가능한 한 **최대한 늦게**(필터·조인으로 줄인 뒤) 호출해 **호출 수**를 최소화.

---

## 3. 재귀 호출을 **포함하는** 함수의 성능 부하

### 3.1 문제 예: 행마다 룩업 쿼리(N+1)
```sql
CREATE OR REPLACE FUNCTION get_status_name(p_code NUMBER)
  RETURN VARCHAR2
IS
  v VARCHAR2(30);
BEGIN
  SELECT status_name INTO v FROM dim_status WHERE status_code = p_code;
  RETURN v;
EXCEPTION WHEN NO_DATA_FOUND THEN
  RETURN 'UNKNOWN';
END;
/
```

```sql
-- 나쁜 사용: WHERE, SELECT-LIST 양쪽 모두에서 매행 호출될 수 있음
SELECT order_id, get_status_name(status_code)
FROM   orders
WHERE  get_status_name(status_code) = 'OK';
```

- **문제점**  
  - `orders`의 **행 수만큼** `dim_status`에 **재귀 SELECT** 발생 → **N+1**  
  - 인덱스가 좋아도 **호출 횟수**(=랜덤 I/O/래치/뮤텍스) 때문에 응답시간 급증  
  - TKPROF에서 `recursive calls`/`db file sequential read` 증가, AWR에서 **Recursive CPU** up

### 3.2 올바른 재작성 (JOIN/스칼라 서브쿼리)
```sql
-- JOIN으로 대체
SELECT o.order_id, s.status_name
FROM   orders o
JOIN   dim_status s
ON     s.status_code = o.status_code
WHERE  s.status_name = 'OK';
```

- **효과**: SQL 엔진이 **조인 배치**로 최적화 → **호출 1회**에 일괄 처리, 인덱스 사용·카디널리티 추정·조인 순서 최적화 가능.

### 3.3 그래도 함수가 필요하다면 — **캐시/배치/프리페치**
- **패키지 전역 캐시**(associative array)로 **이미 본 코드**는 메모리에서 해결  
- **함수 결과 캐시(RESULT_CACHE)** : 입력값에 대한 결과를 엔진 캐시에 저장  
- **배치 프리페치**: 메인 쿼리에서 **필요 코드 집합**을 먼저 모아 **IN-list/GTT**로 한 번에 조인

```plsql
CREATE OR REPLACE PACKAGE status_cache_pkg IS
  TYPE t_map IS TABLE OF VARCHAR2(30) INDEX BY PLS_INTEGER;
  g_map t_map;
  FUNCTION get_status_name_cached(p_code NUMBER) RETURN VARCHAR2;
END;
/

CREATE OR REPLACE PACKAGE BODY status_cache_pkg IS
  FUNCTION get_status_name_cached(p_code NUMBER) RETURN VARCHAR2 IS
    v VARCHAR2(30);
  BEGIN
    IF g_map.EXISTS(p_code) THEN
      RETURN g_map(p_code);
    END IF;
    SELECT status_name INTO v FROM dim_status WHERE status_code=p_code;
    g_map(p_code) := v;
    RETURN v;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    g_map(p_code) := 'UNKNOWN';
    RETURN 'UNKNOWN';
  END;
END;
/
```
> **주의**: 전역 캐시는 **세션 범위**. 세션별 메모리·동기화·무효화 전략을 고려해야 한다.

---

## 4. 함수를 **필터 조건**에 사용할 때 주의 사항 (SARGability)

### 4.1 열에 함수를 적용하면 인덱스가 깨진다
```sql
-- 인덱스: CREATE INDEX ix_sales_region ON sales(region);
-- 아래 조건은 인덱스를 사용하지 못해 Full Scan으로 갈 가능성 큼
WHERE normalize_region(region) = 'APAC';
```

- **원인**: **함수 적용 후의 값**은 인덱스에 저장된 **원래 값**과 다름 → **직접 탐색 불가**  
- **대응**  
  1) **함수 기반 인덱스(FBI)**:
     ```sql
     CREATE INDEX ix_sales_region_norm ON sales(normalize_region(region));
     ```
  2) **함수 없는 식**을 사용:
     ```sql
     WHERE region IN ('APAC','ASIA PACIFIC')  -- 동일 의미, 인덱스 활용 가능
     ```
  3) **입력(바인드)에 함수 적용**(열이 아니라 바인드 쪽):
     ```sql
     WHERE region = normalize_region(:b_region)  -- 열은 그대로, 인덱스 사용 가능
     ```

### 4.2 정렬/범위 조건도 동일
- `WHERE TRUNC(order_dt) = :d` → 인덱스 `(order_dt)` 사용 곤란  
  - 대안: `WHERE order_dt >= :d AND order_dt < :d + 1`  
- `WHERE SUBSTR(code,1,3)='ABC'` → 가능하면 **역정규화/파생 컬럼** + 인덱스

---

## 5. 함수와 **읽기 일관성(Consistent Read)**

### 5.1 기본 규칙
- SELECT는 **문장 수준**의 **SCN 스냅샷**으로 읽는다.  
- SQL 안에서 호출된 함수가 **내부 SELECT**를 수행하면, **가능한 한 같은 SCN**으로 **일관 읽기**가 적용된다.

### 5.2 일관성을 깨는 요소
1) **자율 트랜잭션**(`PRAGMA AUTONOMOUS_TRANSACTION`)을 함수에서 사용 → **다른 SCN/커밋 경계**로 동작  
2) **비결정 함수**: `SYSDATE`, `SYSTIMESTAMP`, `DBMS_RANDOM`, `SEQUENCE.NEXTVAL` 등  
3) **외부 자원/네트워크**: DB 일관성과 무관  
4) **함수 결과 캐시(RESULT_CACHE)** 사용 시, **테이블 변경**이 있었으나 캐시 무효화가 적시에 이뤄지지 않으면 **오래된 값**이 나올 수도 있음(의존성 주의)

> **정책**: **SELECT의 결과 정합성**이 중요한 화면(리포트/감사)은 **자율 트랜잭션·외부자원 접근 함수 금지**. 필요하면 **AS OF SCN** 사용으로 일관성 고정.

---

## 6. 올바른 사용 기준(Decision Tree)

1) **SQL로 표현 가능한가?**  
   - 집계/윈도우/CASE/정규식/함수 기반 인덱스/SQL 매크로(19c+)로 대체 가능하면 **PL/SQL 함수 배제**.
2) **필터에 필수인가?**  
   - 필터에 걸면 인덱스 깨짐 → **FBI 생성** 또는 **식 변환**으로 SARG 확보. 가능하면 **투영 단계**에서 사용.
3) **재귀 SQL이 필요한가?**  
   - **금지**. **JOIN/스칼라 서브쿼리/CTE/GTT/배치 프리페치**로 재작성.
4) **호출 횟수는?**  
   - 수백만 행 호출이면 설계 재검토. **PRAGMA UDF + RESULT_CACHE**도 **호출 수 폭증**은 못 이김.
5) **결정성/캐시**  
   - 순수 함수 & 반복 인자 → `RESULT_CACHE` 고려. 외부자원/시점의존값과 **혼용 금지**.
6) **측정**  
   - TKPROF/SQL Monitor/ASH로 **전/후** 비교: `recursive calls`, `elapsed`(Execute/Fetch), 상위 대기 이벤트.

---

## 7. 실전 예제 — 나쁜 예 → 좋은 예로 바꾸기

### 7.1 케이스 #1: 지역 정규화 필터
**나쁜 예**
```sql
SELECT COUNT(*)
FROM   sales
WHERE  normalize_region(region) = 'APAC';
```
**문제**: 인덱스 `(region)` 무력화 → Full Scan 위험.

**개선 A) 바인드에 함수 적용**
```sql
VAR r VARCHAR2(10); EXEC :r := 'apac ';
SELECT COUNT(*) FROM sales WHERE region = normalize_region(:r);
```
**개선 B) 함수기반 인덱스**
```sql
CREATE INDEX ix_sales_region_norm ON sales(normalize_region(region));
SELECT COUNT(*) FROM sales WHERE normalize_region(region) = 'APAC';
```
**개선 C) SQL만으로**
```sql
SELECT COUNT(*)
FROM   sales
WHERE  region IN ('APAC','ASIA PACIFIC');   -- 데이터 사전이 고정적이면 이상적
```

### 7.2 케이스 #2: 코드→명칭 매핑
**나쁜 예(함수 내부 재귀 SELECT)**
```sql
SELECT o.order_id, get_status_name(o.status_code)
FROM   orders o
WHERE  get_status_name(o.status_code) = 'OK';
```
**개선(조인)**
```sql
SELECT o.order_id, s.status_name
FROM   orders o
JOIN   dim_status s ON s.status_code = o.status_code
WHERE  s.status_name = 'OK';
```
**대량 값일 때(프리페치)**
```sql
-- 1) 필요한 코드만 임시 테이블에 적재
CREATE GLOBAL TEMPORARY TABLE t_codes(code NUMBER) ON COMMIT DELETE ROWS;
-- 2) 조인으로 일괄 변환
SELECT o.order_id, s.status_name
FROM   orders o
JOIN   t_codes c ON c.code = o.status_code
JOIN   dim_status s ON s.status_code = c.code;
```

### 7.3 케이스 #3: 날짜 절단
**나쁜 예**
```sql
WHERE TRUNC(order_dt) = :d
```
**개선**
```sql
WHERE order_dt >= :d AND order_dt < :d + 1
```
또는 필요 시
```sql
CREATE INDEX ix_orders_trunc_dt ON orders(TRUNC(order_dt));
WHERE TRUNC(order_dt) = :d
```
> 후자는 FBI 관리 비용이 든다. 가능하면 **범위 조건**으로.

---

## 8. 최적화 옵션의 **의미와 한계**

### 8.1 `PRAGMA UDF`
- **컨텍스트 전환** 최적화 → **가벼운 순수 함수**에서 유효  
- **재귀 SQL**이나 **무거운 로직**에는 **근본 해결 아님**

### 8.2 `RESULT_CACHE`
- **같은 입력**이 **여러 번** 등장할 때 효과  
- 변경이 잦은 테이블에 의존하거나, 입력 다양성이 크면 히트율 낮음  
- 무효화 정책·의존성 주의(정합성 요구 화면은 사용 신중)

### 8.3 `DETERMINISTIC`
- **의미 표식**일 뿐, 자체 캐시 제공 X.  
- 옵티마이저나 SQL 엔진이 **무조건** 같은 입력을 같은 결과로 단정하고 **재사용**하리라 기대하면 안 됨.

### 8.4 **SQL 매크로(19c+)**
- 함수처럼 **재사용 가능한 SQL 조각**을 안전하게 확장 → **SARG 유지**·플랜 최적화 우호적  
- 가능하면 **매크로**로 패턴화하고 **PL/SQL 함수는 계산 전용**으로.

---

## 9. 벤치마크 가이드(간단 절차)

1) **데이터 준비**: 100만~1000만 행  
2) **A안(나쁜 예)**, **B안(개선)** SQL 각각 10~30회 반복  
3) **SQL Trace/TKPROF** 또는 **SQL Monitor**로 비교  
   - `recursive calls`, `Fetch count`, `consistent gets`/`physical reads`, `Elapsed`  
4) **결론**: 행마다 함수+재귀SQL → **폭발적 악화** / 조인·SARG·배치 → **선형 시간**

---

## 10. 체크리스트(배포 전 최종 점검)

- [ ] **WHERE/ORDER/LIMIT 경로**에 함수가 있는가? → **SARG** 깨지지 않는가?  
- [ ] 함수 내부에 **재귀 SQL** 있는가? → **JOIN/프리페치/GTT**로 대체했는가?  
- [ ] **호출 수**가 충분히 작도록 설계했는가?(필터/조인 후 호출)  
- [ ] **PRAGMA UDF/RESULT_CACHE**는 **순수 계산형·재사용 높은** 경우에만 붙였는가?  
- [ ] 정합성 요구 화면에서 **자율 트랜잭션/비결정 요소**를 배제했는가?  
- [ ] TKPROF/AWR로 **전/후 수치**(elapsed/I-O/recursive calls)로 개선을 확인했는가?

---

## 결론

- PL/SQL 함수는 **강력한 캡슐화 도구**지만, **SQL 안에서 무분별하게 호출**하면 **컨텍스트 전환**과 **(재귀 SQL 시) N+1 I/O** 때문에 **성능 폭탄**이 된다.  
- 원칙은 간단하다:
  1) **SQL로 될 일은 SQL로**(조인·윈도우·CASE·정규식·SQL 매크로),  
  2) 함수는 **필터 이후·투영 단계**에서 최소 호출,  
  3) **재귀 SQL 금지**, 필요하면 **조인/배치/캐시**로,  
  4) 필터에 불가피하면 **함수 기반 인덱스** 또는 **식 변환**으로 **SARG 유지**,  
  5) 정합성 요구 시 **자율 트랜잭션/비결정성** 배제.  
- 그리고 항상 **측정**하라. TKPROF·AWR·SQL Monitor는 **함수 한 줄**이 만든 병목을 숨김없이 보여준다.

---

```sql
-- 요약 실전 예: '좋은' 형태
SELECT o.order_id,
       normalize_region(o.region) AS region_norm   -- 투영에서만 사용
FROM   orders o
JOIN   dim_status s
  ON   s.status_code = o.status_code              -- 재귀함수 대신 조인
WHERE  o.customer_id = :cust
AND    s.status_name = 'OK'                       -- 필터는 SARG 유지
ORDER  BY o.created_at DESC
FETCH FIRST 50 ROWS ONLY;                         -- 부분범위처리(Stopkey)
```