---
layout: post
title: DB 심화 - PL/SQL 함수의 특징과 성능 부하
date: 2025-11-01 22:25:23 +0900
category: DB 심화
---
# PL/SQL 함수의 특징과 성능 — 원리, 주의점, 올바른 사용법 (Oracle 중심)

> **핵심 요약**
> PL/SQL 함수는 SQL 문장 내에서 사용될 때 성능상 중요한 특성을 가집니다. 각 행마다 SQL 엔진과 PL/SQL 엔진 사이의 컨텍스트 전환이 발생하며, 함수 내부에 SQL이 포함되어 있으면 재귀 호출로 인한 성능 저하가 극심해질 수 있습니다. 특히 WHERE 절에서 컬럼에 함수를 적용하면 인덱스 사용이 불가능해져 전체 테이블 스캔으로 이어질 수 있습니다. 이 문서는 이러한 문제점들을 이해하고, 올바른 설계와 최적화 기법을 제공합니다.

---

## PL/SQL 함수의 기본 이해

### 실행 컨텍스트와 비용
SQL 문장 내에서 PL/SQL 함수를 호출할 때마다, 데이터베이스 엔진은 SQL 실행 컨텍스트에서 PL/SQL 실행 컨텍스트로 전환해야 합니다. 이 컨텍스트 스위칭에는 오버헤드가 수반되며, 함수 본문의 실행 비용과 더해져 호출 횟수에 비례하여 누적됩니다. 단순해 보이는 함수라도 수백만 행을 처리하는 쿼리에서는 상당한 성능 저하를 초래할 수 있습니다.

### 함수의 결정성과 순수성
- **DETERMINISTIC**: 동일한 입력에 대해 항상 동일한 결과를 반환함을 선언하는 키워드입니다. 이는 옵티마이저에게 최적화 힌트를 제공할 수 있지만, 자동으로 성능을 보장하지는 않습니다.
- **RESULT_CACHE**: 함수 결과 캐싱을 활성화합니다. 동일한 입력값에 대해 캐시된 결과를 반환하여 재계산을 방지합니다. 그러나 캐시 무효화 정책과 메모리 사용을 고려해야 합니다.
- **PRAGMA UDF**: Oracle 12cR2부터 도입된 최적화 힌트로, SQL 내에서 빈번히 호출되는 가벼운 함수의 컨텍스트 전환 오버헤드를 줄여줍니다. 순수 계산 함수에 가장 효과적입니다.

### 함수 유형 분류
1. **순수 계산 함수**: 외부 리소스나 SQL을 호출하지 않고, 입력값을 처리하여 결과를 반환합니다. (예: 문자열 포맷팅, 수학 연산)
2. **자원 접근 함수**: 파일 I/O, 네트워크 호출, 패키지 상태 변수 접근 등 외부 리소스를 사용합니다. SQL 내부에서 사용은 일반적으로 지양됩니다.
3. **재귀 SQL 함수**: 함수 본문 내에서 `SELECT`, `INSERT`, `UPDATE`, `DELETE` 문을 실행합니다. 이는 N+1 쿼리 문제와 심각한 성능 저하를 유발할 수 있습니다.

---

## 재귀 호출이 없는 함수의 성능 영향

### 예제: 지역 코드 정규화 함수
```sql
CREATE OR REPLACE FUNCTION normalize_region(p_txt VARCHAR2)
  RETURN VARCHAR2
  PARALLEL_ENABLE
  RESULT_CACHE
  PRAGMA UDF
IS
  v VARCHAR2(30);
BEGIN
  v := UPPER(TRIM(p_txt));
  IF v IN ('APAC','ASIA PACIFIC') THEN RETURN 'APAC';
  ELSIF v IN ('EMEA','EUROPE')    THEN RETURN 'EMEA';
  ELSIF v IN ('AMER','US','NA')   THEN RETURN 'AMER';
  ELSE RETURN 'OTHER';
  END IF;
END;
/
```
이 함수는 재귀 SQL이 없지만, 수백만 행을 처리하는 쿼리에서는 여전히 상당한 컨텍스트 전환 비용이 발생할 수 있습니다.

### 호출 위치에 따른 영향
- **WHERE 절에서 사용**: 인덱스 사용을 방해할 수 있으며, 필터링 전 모든 행에 대해 함수가 호출됩니다.
- **SELECT 리스트에서 사용**: WHERE 절과 조인으로 결과 집합이 크게 줄어든 후 호출되므로 상대적으로 영향이 적습니다.

**권장사항**: 가능하면 함수 호출을 데이터 처리 파이프라인의 후반부(결과 투영 단계)로 미루어 호출 횟수를 최소화하세요.

---

## 재귀 호출을 포함하는 함수의 심각한 성능 문제

### 문제의 본질: N+1 쿼리 패턴
함수 내부에서 SQL을 실행하면, 메인 쿼리의 각 행마다 별도의 SQL이 실행됩니다. 이는 데이터베이스에 대한 반복적인 라운드트립을 발생시켜 I/O, 락 경합, CPU 사용을 폭증시킵니다.

**나쁜 예시:**
```sql
CREATE OR REPLACE FUNCTION get_status_name(p_code NUMBER)
  RETURN VARCHAR2
IS
  v VARCHAR2(30);
BEGIN
  SELECT status_name INTO v FROM dim_status WHERE status_code = p_code;
  RETURN v;
END;
/

-- 문제의 쿼리: orders 테이블의 각 행마다 dim_status 조회 발생
SELECT order_id, get_status_name(status_code)
FROM orders;
```

### 올바른 해결책: 조인 사용
```sql
SELECT o.order_id, s.status_name
FROM orders o
JOIN dim_status s ON s.status_code = o.status_code;
```
조인을 사용하면 데이터베이스 엔진이 최적의 실행 계획을 수립할 수 있으며, 일괄 처리로 효율적으로 작업을 수행합니다.

### 캐싱을 통한 개선
함수를 완전히 제거할 수 없는 경우, 결과 캐싱을 통해 성능을 개선할 수 있습니다:
```plsql
CREATE OR REPLACE PACKAGE status_cache_pkg IS
  TYPE t_map IS TABLE OF VARCHAR2(30) INDEX BY PLS_INTEGER;
  g_map t_map;
  
  FUNCTION get_status_name_cached(p_code NUMBER) RETURN VARCHAR2;
END;
/
```
패키지 레벨의 연관 배열을 사용하면 세션 내에서 동일한 코드에 대한 반복 조회를 방지할 수 있습니다. 단, 캐시 무효화와 메모리 사용을 고려해야 합니다.

---

## WHERE 절에서 함수 사용과 인덱스 문제 (SARGability)

### SARGability의 중요성
SARGable(Search ARGument able) 조건은 인덱스를 효과적으로 사용할 수 있는 조건을 의미합니다. 컬럼에 함수를 적용하면 일반적으로 인덱스 사용이 불가능해집니다.

**문제 예시:**
```sql
-- region 컬럼에 인덱스가 있더라도 사용할 수 없음
WHERE normalize_region(region) = 'APAC';
```

### 해결 방안
1. **함수 기반 인덱스(FBI) 생성:**
   ```sql
   CREATE INDEX ix_sales_region_norm ON sales(normalize_region(region));
   ```

2. **원본 조건으로 재작성:**
   ```sql
   WHERE region IN ('APAC', 'ASIA PACIFIC')
   ```

3. **바인드 변수에 함수 적용:**
   ```sql
   WHERE region = normalize_region(:input_region)
   ```

4. **범위 조건으로 변환:**
   ```sql
   -- 나쁜 예: WHERE TRUNC(order_date) = DATE '2023-01-01'
   -- 좋은 예: 
   WHERE order_date >= DATE '2023-01-01' 
     AND order_date < DATE '2023-01-02'
   ```

---

## 함수와 데이터 일관성

### 읽기 일관성의 기본
Oracle은 기본적으로 문장 수준 읽기 일관성을 제공합니다. SQL 문장 내에서 호출되는 함수도 동일한 SCN(System Change Number)으로 데이터를 읽습니다.

### 일관성을 해치는 요소
- **자율 트랜잭션**: `PRAGMA AUTONOMOUS_TRANSACTION`을 사용하는 함수는 독립적인 트랜잭션으로 실행되어 메인 쿼리와 다른 데이터 스냅샷을 볼 수 있습니다.
- **비결정적 함수**: `SYSDATE`, `DBMS_RANDOM`, 시퀀스 등은 호출 시점에 따라 다른 결과를 반환합니다.
- **외부 자원**: 데이터베이스 외부의 파일, 네트워크 서비스 등에 접근하는 함수는 데이터 일관성을 보장할 수 없습니다.

**권장사항**: 정합성이 중요한 보고서나 감사 용도의 쿼리에서는 자율 트랜잭션과 비결정적 요소를 피하세요. 필요한 경우 `AS OF SCN` 또는 `AS OF TIMESTAMP`를 사용하여 명시적인 읽기 일관성 지점을 지정하세요.

---

## 최적화 옵션의 이해와 적절한 사용

### PRAGMA UDF
컨텍스트 전환 오버헤드를 줄이지만, 함수 본문의 비용이 크거나 재귀 SQL이 포함된 경우에는 근본적인 해결책이 되지 않습니다.

### RESULT_CACHE
동일 입력이 반복되는 시나리오에서 효과적입니다. 그러나 함수가 의존하는 테이블이 자주 변경되거나 입력 다양성이 높으면 캐시 히트율이 낮아집니다.

### DETERMINISTIC
옵티마이저에 최적화 힌트를 제공하지만, 자체적인 성능 향상은 제공하지 않습니다. 함수의 의미적 특성을 명시하는 데 사용하세요.

### SQL 매크로 (Oracle 19c 이상)
함수처럼 재사용 가능한 SQL 조각을 정의할 수 있으며, 실행 시 인라인 확장되어 원본 SQL에 통합됩니다. 이는 SARGability를 유지하면서 코드 재사용성을 제공합니다.

---

## 실전 개선 사례

### 사례 1: 지역 정규화 필터링
**문제점:**
```sql
SELECT COUNT(*) FROM sales WHERE normalize_region(region) = 'APAC';
```

**해결책:**
1. 바인드 변수에 함수 적용
   ```sql
   SELECT COUNT(*) FROM sales WHERE region = normalize_region(:input);
   ```
2. 원시 값으로 직접 비교
   ```sql
   SELECT COUNT(*) FROM sales WHERE region IN ('APAC', 'ASIA PACIFIC');
   ```
3. 함수 기반 인덱스 생성
   ```sql
   CREATE INDEX ix_sales_fbi ON sales(normalize_region(region));
   ```

### 사례 2: 코드-명칭 매핑
**문제점 (재귀 SQL 함수):**
```sql
SELECT order_id, get_status_name(status_code) FROM orders;
```

**해결책 (조인 사용):**
```sql
SELECT o.order_id, s.status_name 
FROM orders o 
JOIN dim_status s ON s.status_code = o.status_code;
```

**대안 (배치 프리페치):**
```sql
-- 필요한 코드 집합을 먼저 수집
WITH status_codes AS (
  SELECT DISTINCT status_code FROM orders WHERE customer_id = :cust_id
)
SELECT o.order_id, s.status_name
FROM orders o
JOIN dim_status s ON s.status_code = o.status_code
WHERE o.status_code IN (SELECT status_code FROM status_codes);
```

### 사례 3: 날짜 기반 필터링
**문제점:**
```sql
WHERE TRUNC(order_date) = DATE '2023-01-01'
```

**해결책:**
```sql
WHERE order_date >= DATE '2023-01-01' 
  AND order_date < DATE '2023-01-02'
```

---

## 성능 측정과 벤치마킹

함수 사용 전후의 성능을 반드시 측정하세요. 다음 도구들을 활용할 수 있습니다:

1. **TKPROF**: 재귀 호출 횟수, 일관적 읽기, 물리적 읽기 등을 분석
2. **SQL Monitor**: 실시간 실행 계획과 리소스 사용량 모니터링
3. **AWR/ASH 리포트**: 시스템 수준의 성능 영향 분석

측정 시 고려할 주요 지표:
- 실행 시간(Elapsed Time)
- 일관적 읽기(Consistent Gets)
- 재귀 호출 횟수(Recursive Calls)
- 대기 이벤트(Wait Events)

---

## 결론: PL/SQL 함수의 올바른 사용 원칙

PL/SQL 함수는 코드 재사용성과 모듈화를 제공하는 강력한 도구이지만, SQL 문장 내에서 사용할 때는 신중한 접근이 필요합니다. 다음 원칙을 준수하세요:

1. **SQL 우선 원칙**: 조인, 윈도우 함수, CASE 표현식 등 SQL 자체 기능으로 해결할 수 있는 문제는 PL/SQL 함수를 사용하지 마세요.

2. **호출 위치 최적화**: 함수 호출을 가능한 한 데이터 처리 파이프라인의 후반부로 미루세요. WHERE 절보다 SELECT 리스트에서, 조인과 필터링 이후에 호출하도록 설계하세요.

3. **재귀 SQL 금지**: 함수 내부에서 SQL을 실행하는 패턴은 반드시 피하세요. 조인, 서브쿼리, CTE(Common Table Expression) 등으로 대체하세요.

4. **SARGability 보존**: WHERE 절에서 컬럼에 함수를 적용하지 마세요. 필요한 경우 함수 기반 인덱스를 생성하거나 조건식을 SARGable하게 재작성하세요.

5. **적절한 최적화 옵션 사용**: 
   - 가벼운 순수 계산 함수에는 `PRAGMA UDF`를 고려하세요.
   - 동일 입력 반복이 예상되는 함수에는 `RESULT_CACHE`를 적용하세요.
   - Oracle 19c 이상에서는 SQL 매크로를 활용하세요.

6. **데이터 일관성 고려**: 정합성이 중요한 쿼리에서는 자율 트랜잭션, 비결정적 함수, 외부 자원 접근을 피하세요.

7. **측정과 검증**: 모든 변경 사항을 성능 테스트로 검증하세요. 실제 데이터 볼륨과 워크로드 패턴에서의 영향을 평가하세요.

최종적으로, PL/SQL 함수 사용에 대한 결정은 성능, 유지보수성, 재사용성 사이의 균형을 고려해야 합니다. 함수의 편리함이 성능 저하로 이어지지 않도록, 항상 전체 시스템 관점에서 설계하고 구현하세요.

**올바른 사용의 예시:**
```sql
SELECT o.order_id,
       normalize_region(o.region) AS region_norm,  -- SELECT 리스트에서만 호출
       s.status_name                               -- 재귀 함수 대신 조인
FROM orders o
JOIN dim_status s ON s.status_code = o.status_code
WHERE o.customer_id = :cust_id                     -- SARGable 조건
  AND o.order_date >= :start_date                  -- 인덱스 활용 가능
  AND o.order_date < :end_date
ORDER BY o.created_date DESC
FETCH FIRST 100 ROWS ONLY;                         -- 부분 범위 처리
```