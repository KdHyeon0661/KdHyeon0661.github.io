---
layout: post
title: CSS - 레이아웃을 구성하는 패턴
date: 2025-04-21 19:20:23 +0900
category: CSS
---
# 레이아웃 패턴 완전 정리: Header · Sidebar · Content · Footer

## 목표와 원칙

- **시맨틱 마크업**: `<header>`, `<nav>`, `<main>`, `<aside>`, `<footer>` 활용
- **레이아웃과 콘텐츠 분리**: DOM 구조는 단순, 배치는 CSS로
- **반응형 우선**: 모바일 퍼스트 + 미디어쿼리/컨테이너쿼리
- **접근성(A11y)**: 스킵 링크, landmark, aria-속성, 키보드 탐색
- **성능/안정성**: CLS(레이아웃 시프트) 최소화, 합성 단계(transform/opacity) 기반 상호작용

---

## 역할과 기본 구조

| 영역 | 핵심 역할 | 참고 |
|---|---|---|
| Header | 사이트 브랜드/글로벌 내비/유틸(검색, 알림, 사용자) | sticky/fixed, 축소 헤더 |
| Sidebar (`nav`) | 섹션 내 계층 메뉴, 필터 | 접힘/펼침, 오버레이, 아코디언 |
| Main | 실제 본문/대시보드/목록 | 스크롤 주체, 그리드/카드/테이블 |
| Footer | 저작권/정책/추가 링크 | sticky footer 패턴, 최소 높이 |

### 시맨틱 HTML 골격

```html
<body>
  <a href="#main" class="skip-link">본문으로 건너뛰기</a>
  <header role="banner">
    <div class="brand">MyApp</div>
    <nav aria-label="글로벌 내비게이션">
      <!-- 글로벌 메뉴 -->
    </nav>
  </header>

  <div class="layout">
    <aside class="sidebar" aria-label="보조 내비게이션">
      <!-- 카테고리/섹션 메뉴 -->
    </aside>
    <main id="main" tabindex="-1">
      <!-- 본문 콘텐츠 -->
    </main>
  </div>

  <footer role="contentinfo">
    © 2025 MyApp
  </footer>
</body>
```

> `skip-link`와 `tabindex="-1"`로 키보드/스크린리더 사용자의 빠른 본문 접근을 보장합니다.

```css
/* 화면에서 숨기되 포커스 시 보이게 */
.skip-link {
  position: absolute; left: -9999px; top: auto; width: 1px; height: 1px; overflow: hidden;
}
.skip-link:focus {
  left: 16px; top: 16px; width: auto; height: auto; padding: .5rem .75rem;
  background: #111; color: #fff; border-radius: 8px;
}
```

---

## Flexbox로 구현 (1차원 중심)

### 최소 구현

```css
:root {
  --sidebar-width: 260px;
  --gap: 16px;
}

* { box-sizing: border-box; }
html, body { height: 100%; }
body {
  margin: 0;
  font-family: system-ui, -apple-system, "Noto Sans KR", sans-serif;
  color: #0f172a;
  background: #f8fafc;
  display: flex;
  flex-direction: column;
  min-height: 100dvh; /* 모바일 주소창 높이 변화 대응 */
}

header, footer {
  background: #111827; color: #fff;
  padding: 1rem;
}

.layout {
  display: flex;
  flex: 1 1 auto;          /* 남은 세로 공간 채우기 */
  gap: var(--gap);         /* Flex도 gap 지원 */
  padding: var(--gap);
  align-items: stretch;    /* 동일 높이 */
}

.sidebar {
  width: var(--sidebar-width);
  background: #e5e7eb;
  border-radius: 12px;
  padding: 1rem;
}

main {
  flex: 1 1 0;             /* 남은 가로 공간 확장 */
  background: #ffffff;
  border-radius: 12px;
  padding: 1.25rem;
  min-width: 0;            /* 긴 콘텐츠(코드/테이블) 줄바꿈 허용 */
}

footer { text-align: center; }
```

### 반응형 (모바일 퍼스트)

```css
/* 모바일: 사이드바를 상단/아래로 이동(수직) */
@media (max-width: 768px) {
  .layout { flex-direction: column; }
  .sidebar { width: 100%; order: 2; }
  main { order: 1; }
}
```

**특징**
- 구현이 단순하고 예측 가능
- 고정 폭 사이드바 + 유연 메인에 적합
- 2차원(행/열) 제어·재배치가 많은 페이지는 Grid가 더 명확

---

## Grid로 구현 (2차원 중심)

### `grid-template-areas` 기반

```css
:root {
  --sidebar-width: 260px;
}

body {
  display: grid;
  grid-template-columns: var(--sidebar-width) 1fr;
  grid-template-rows: auto 1fr auto;
  grid-template-areas:
    "header header"
    "sidebar main"
    "footer footer";
  min-height: 100dvh;
  margin: 0;
  gap: 16px;
  padding: 16px;
  background: #f8fafc;
  color: #0f172a;
  font-family: system-ui, -apple-system, "Noto Sans KR", sans-serif;
}

header { grid-area: header; background:#111827; color:#fff; border-radius:12px; padding:1rem; }
.sidebar { grid-area: sidebar; background:#e5e7eb; border-radius:12px; padding:1rem; }
main   { grid-area: main; background:#fff; border-radius:12px; padding:1.25rem; min-width:0; }
footer { grid-area: footer; background:#111827; color:#fff; border-radius:12px; padding:1rem; text-align:center; }
```

### 반응형 (열 → 1열)

```css
@media (max-width: 768px) {
  body {
    grid-template-columns: 1fr;
    grid-template-areas:
      "header"
      "main"
      "sidebar"
      "footer";
  }
}
```

**특징**
- 2차원 배치·재배치가 명확
- 페이지 전반 레이아웃의 **설계 의도**가 코드로 드러남
- 서브 레이아웃(카드 그리드/테이블 영역)도 그리드로 중첩 설계 용이

---

## 확장 패턴

### Sticky 헤더 / Sticky 사이드바

```css
header { position: sticky; top: 0; z-index: 1000; }
.sidebar {
  position: sticky;
  top: calc(1rem + 56px); /* 헤더 높이 + 여백 */
  align-self: start;      /* Grid에서 높이 늘어남 방지 */
  max-height: calc(100dvh - 96px);
  overflow: auto;
}
```

### 접히는 사이드바(토글)

```html
<button class="sidebar-toggle" aria-expanded="true" aria-controls="side">메뉴</button>
<aside id="side" class="sidebar is-open">...</aside>
```

```css
.sidebar {
  width: var(--sidebar-width);
  transition: width .2s ease, transform .2s ease, opacity .2s ease;
  will-change: transform;
}
.sidebar:not(.is-open) {
  width: 0;
  padding: 0;
  border: 0;
  overflow: hidden;
}
@media (max-width: 768px) {
  /* 모바일은 오버레이 드로어 패턴 */
  .sidebar {
    position: fixed; inset: 0 auto 0 0; width: 80%;
    transform: translateX(-100%); opacity: 0;
    box-shadow: 0 16px 40px rgba(0,0,0,.24);
    border-radius: 0 12px 12px 0;
    background:#fff;
    z-index: 1100;
  }
  .sidebar.is-open { transform: translateX(0); opacity: 1; }
  .overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,.35);
    opacity: 0; pointer-events: none; transition: opacity .2s ease; z-index: 1090;
  }
  .overlay.is-open { opacity: 1; pointer-events: auto; }
}
```

```js
const btn = document.querySelector('.sidebar-toggle');
const side = document.getElementById('side');
const overlay = document.querySelector('.overlay');

function toggleSide(open) {
  const willOpen = (open ?? !side.classList.contains('is-open'));
  side.classList.toggle('is-open', willOpen);
  overlay?.classList.toggle('is-open', willOpen);
  btn.setAttribute('aria-expanded', String(willOpen));
  if (!willOpen) btn.focus();
}
btn.addEventListener('click', () => toggleSide());
overlay?.addEventListener('click', () => toggleSide(false));
```

> **접근성**: 오픈 시 포커스 트랩/`aria-modal`까지 고려(간단 예시는 생략).

### Sticky Footer(콘텐츠가 짧아도 하단 고정)

- Flex 방식: `body`를 column 플렉스, `main`에 `flex:1`
- Grid 방식: `grid-template-rows: auto 1fr auto` 사용

이미 위 예제가 sticky footer 충족.

### Holy Grail 레이아웃(양쪽 사이드바)

```css
/* Grid 3컬럼 패턴 */
:root { --left: 220px; --right: 280px; }
body {
  display: grid;
  grid-template-columns: var(--left) 1fr var(--right);
  grid-template-rows: auto 1fr auto;
  grid-template-areas:
    "header header header"
    "left   main   right"
    "footer footer footer";
  gap: 16px;
}
.left  { grid-area: left;  }
.right { grid-area: right; }
```

모바일 전환 시 1열로 스택:

```css
@media (max-width: 960px) {
  body {
    grid-template-columns: 1fr;
    grid-template-areas:
      "header"
      "main"
      "left"
      "right"
      "footer";
  }
}
```

---

## 실전 페이지 예제(HTML/CSS/JS 통합)

**요구사항**
- 헤더: sticky, 모바일 메뉴 버튼
- 사이드바: 데스크톱 고정, 모바일 드로어
- 메인: 카드 그리드
- 푸터: sticky
- 다크 모드 토글, 반응형, 접근성, 모션 배려

```html
<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Header · Sidebar · Content · Footer Layout</title>
<style>
:root{
  --sidebar-w:260px;
  --gap:16px;
  --radius:12px;
  --bg:#f8fafc; --panel:#fff; --ink:#0f172a; --muted:#475569;
  --brand:#111827;
}
:root.dark{
  --bg:#0b1220; --panel:#0f172a; --ink:#e2e8f0; --muted:#94a3b8; --brand:#0b1220;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; font-family:system-ui,-apple-system,"Noto Sans KR",sans-serif;
  color:var(--ink); background:var(--bg);
  display:grid;
  grid-template-columns: var(--sidebar-w) 1fr;
  grid-template-rows: auto 1fr auto;
  grid-template-areas:
    "header header"
    "sidebar main"
    "footer footer";
  gap:var(--gap); padding:var(--gap); min-height:100dvh;
}
.skip-link{position:absolute;left:-9999px}
.skip-link:focus{left:16px;top:16px;background:#111;color:#fff;padding:.5rem .75rem;border-radius:8px}

header{grid-area:header;background:var(--brand);color:#fff;border-radius:var(--radius);padding:.75rem 1rem;display:flex;align-items:center;gap:12px;position:sticky;top:0;z-index:1000}
header .brand{font-weight:700}
header .spacer{flex:1}
header button{border:0;border-radius:8px;padding:.5rem .75rem;background:#1f2937;color:#fff;cursor:pointer}
header button:hover{background:#374151}

.sidebar{
  grid-area:sidebar;background:var(--panel);border-radius:var(--radius);padding:1rem;
  position:sticky; top: calc(.75rem + 56px);
  align-self:start; max-height: calc(100dvh - 96px); overflow:auto;
  box-shadow: 0 1px 2px rgba(0,0,0,.06);
}
.sidebar h3{margin:.25rem 0 1rem;font-size:1rem;color:var(--muted)}
.sidebar nav a{display:block;padding:.5rem .25rem;border-radius:8px;color:inherit;text-decoration:none}
.sidebar nav a:hover{background:rgba(2,6,23,.06)}

main{
  grid-area:main;background:var(--panel);border-radius:var(--radius);padding:1.25rem;min-width:0;
  box-shadow: 0 1px 2px rgba(0,0,0,.06);
}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:var(--gap)}
.card{background:rgba(255,255,255,.6);backdrop-filter:saturate(1.1) blur(0px);border-radius:14px;padding:1rem;box-shadow:0 1px 2px rgba(0,0,0,.06);transition:transform .18s cubic-bezier(.2,.6,.2,1), box-shadow .18s ease}
.dark .card{background:rgba(15,23,42,.7)}
.card:hover{transform:translateY(-4px);box-shadow:0 10px 24px rgba(0,0,0,.14)}

footer{grid-area:footer;background:var(--brand);color:#fff;border-radius:var(--radius);padding:1rem;text-align:center}

/* 모바일: 드로어 사이드바 */
@media (max-width: 768px) {
  body{
    grid-template-columns: 1fr;
    grid-template-areas:
      "header"
      "main"
      "footer";
  }
  .sidebar{
    position:fixed; inset:0 auto 0 0; width:min(80%, 320px);
    transform: translateX(-100%); opacity:0; pointer-events:none;
    box-shadow: 0 16px 40px rgba(0,0,0,.24); border-radius:0 12px 12px 0; z-index:1100;
  }
  .sidebar.is-open{ transform: translateX(0); opacity:1; pointer-events:auto; }
  .overlay{
    position:fixed; inset:0; background:rgba(0,0,0,.35);
    opacity:0; pointer-events:none; transition: opacity .2s ease; z-index:1090;
  }
  .overlay.is-open{ opacity:1; pointer-events:auto; }
}

/* 모션 민감 사용자 */
@media (prefers-reduced-motion: reduce) {
  *{transition:none !important; animation:none !important}
}
</style>
</head>
<body>
  <a href="#main" class="skip-link">본문으로 건너뛰기</a>

  <header>
    <button id="menu" aria-expanded="false" aria-controls="side">메뉴</button>
    <div class="brand">MyApp</div>
    <div class="spacer"></div>
    <button id="theme">테마 전환</button>
  </header>

  <aside id="side" class="sidebar" aria-label="사이드바 내비게이션">
    <h3>섹션</h3>
    <nav>
      <a href="#">대시보드</a>
      <a href="#">프로젝트</a>
      <a href="#">팀</a>
      <a href="#">설정</a>
    </nav>
  </aside>
  <div class="overlay" hidden></div>

  <main id="main" tabindex="-1">
    <h1>메인 콘텐츠</h1>
    <p>반응형 Grid 카드 레이아웃 예시:</p>
    <div class="grid">
      <article class="card"><h3>카드 A</h3><p>설명 텍스트...</p></article>
      <article class="card"><h3>카드 B</h3><p>설명 텍스트...</p></article>
      <article class="card"><h3>카드 C</h3><p>설명 텍스트...</p></article>
      <article class="card"><h3>카드 D</h3><p>설명 텍스트...</p></article>
    </div>
  </main>

  <footer>© 2025 MyApp</footer>

<script>
const $ = sel => document.querySelector(sel);
const btnMenu = $('#menu');
const sidebar = $('#side');
const overlay = document.querySelector('.overlay');
const btnTheme = $('#theme');

function setOverlay(open){
  if(!overlay) return;
  overlay.toggleAttribute('hidden', !open);
  overlay.classList.toggle('is-open', open);
}
function toggleSide(open){
  const willOpen = (open ?? !sidebar.classList.contains('is-open'));
  sidebar.classList.toggle('is-open', willOpen);
  btnMenu.setAttribute('aria-expanded', String(willOpen));
  setOverlay(willOpen);
  if(!willOpen) btnMenu.focus();
}
btnMenu.addEventListener('click', () => toggleSide());
overlay?.addEventListener('click', () => toggleSide(false));
document.addEventListener('keydown', (e) => { if(e.key === 'Escape') toggleSide(false); });

btnTheme.addEventListener('click', () => {
  document.documentElement.classList.toggle('dark');
});
</script>
</body>
</html>
```

**포인트**
- 데스크톱: 좌측 고정 사이드바, sticky 헤더
- 모바일: 사이드바 드로어 + 오버레이(ESC/클릭 닫힘)
- `prefers-reduced-motion` 대응, 다크 모드 토글
- 카드 hover는 **transform/box-shadow**로 합성 단계 처리

---

## Grid vs Flex 선택 가이드

| 시나리오 | 권장 |
|---|---|
| 페이지 전체 레이아웃(헤더/사이드/메인/푸터), 영역 재배치 | **Grid** |
| 툴바/버튼그룹/탭/네비 항목 정렬(1차원 흐름) | **Flex** |
| 카드 갤러리(반응형 열 수 자동) | Grid의 `repeat(auto-fit, minmax())` |
| Sticky 사이드 + 유연 메인 | Flex/Grid 모두 가능(개인 선호) |

---

## 접근성과 내비게이션

- Landmark 역할: `<header role="banner">`, `<main>`, `<nav>`, `<footer role="contentinfo">`
- `aria-label`로 내비 의미 명료화, 스킵 링크 제공
- 모바일 드로어 오픈 시: **포커스 트랩**(Tab 순환)과 **배경 스크롤 잠금**(오버레이 + `body { overflow: hidden; }`) 고려
- 키보드만으로도 모든 기능 사용 가능해야 함

---

## 스크롤/레이어/안전 영역

- iOS notch: bottom 탭/푸터 padding에 `env(safe-area-inset-bottom)` 고려
```css
footer { padding-bottom: calc(1rem + env(safe-area-inset-bottom)); }
```
- 레이어 토큰으로 z-index 관리
```css
:root { --z-header:1000; --z-drawer:1100; --z-overlay:1090; }
```
- sticky 사용 시 부모의 `overflow`가 `hidden/auto`면 동작 제한 가능 → 컨테이너 구조 점검

---

## 성능/안정성 체크리스트

- CLS 방지: 폰트/이미지/광고 슬롯의 크기 예약(`aspect-ratio`, 고정 높이)
- 애니메이션: `transform/opacity` 중심, `transition: all` 지양
- 스크립트 최소화: 레이아웃은 CSS, JS는 상태 토글/접근성에 집중
- DevTools 성능 패널로 레이아웃/페인트/합성 확인

---

## 변형 패턴 모음

### 헤더 + 탭 + 컨텐츠

```css
.header { position:sticky; top:0; z-index:var(--z-header) }
.tabs { display:flex; gap:8px; border-bottom:1px solid #e5e7eb; }
.tabs a{ padding:.75rem 1rem; border-radius:10px 10px 0 0; }
```

### 콘텐츠 + 보조 패널(오른쪽)

```css
.wrapper{ display:grid; grid-template-columns: 1fr 320px; gap:16px; }
@media (max-width: 1024px){ .wrapper{ grid-template-columns: 1fr; } }
```

### 필터 바가 접히는 목록 페이지

```css
.filters{ transition: height .25s ease; overflow: hidden; }
.filters[aria-hidden="true"]{ height: 0; }
```

---

## 컨테이너 쿼리로 세밀 제어(지원 브라우저에서)

```css
/* 카드 그리드 내부가 충분히 넓을 때만 3열 */
.cards { container-type: inline-size; }
@container (min-width: 720px) {
  .cards { grid-template-columns: repeat(3, 1fr); }
}
```

---

## 테스트/디버깅 팁

- 다크/라이트 전환, 폰트 확대(200%), 키보드 전용 탐색, 리더 테스트
- 다양한 뷰포트(320~1920px) + 고밀도(2x/3x)
- 긴 텍스트/로캘(긴 단어)/RTL 케이스(`direction: rtl`)
- 낮은 성능 기기에서 스크롤/전환 부드러움 확인

---

## 요약

- **Flex**: 1차원 정렬/정렬/공간 분배에 탁월
- **Grid**: 헤더/사이드/메인/푸터 **페이지 전체 레이아웃**에 최적
- **Sticky 헤더/사이드, 드로어 사이드바, 오버레이**로 현대적 UX 패턴 구현
- **접근성/반응형/성능**을 동시에 고려한 설계로 유지보수성 향상

이 문서의 코드 스니펫만으로도 **관리자 대시보드/블로그/상거래 카탈로그** 등 대부분의 기본 레이아웃을 바로 구성할 수 있습니다.
