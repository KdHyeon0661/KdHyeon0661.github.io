---
layout: post
title: 알고리즘 - 이분 탐색
date: 2025-04-17 20:20:23 +0900
category: 알고리즘
---
# 이분 탐색(Binary Search)

## 1. 이분 탐색이란?

정렬된 범위(또는 **정답의 범위가 선형/연속으로 정렬되어 있고 판정값이 단조적**)에서 **중간값을 기준으로 탐색 구간을 절반**으로 줄여 가며 원하는 값을 찾는 기법입니다.

- 시간복잡도: $$O(\log N)$$ 또는 $$O(\log R)$$ (구간 길이 \(R\)에 대한 이분)
- 전제: 정렬 또는 **단조성(monotonicity)**

---

## 2. 시간 복잡도 직관

| N | \(\log_2 N\) 근사 탐색 회수 |
|---|---|
| \(10^3\) | ≈ 10 |
| \(10^6\) | ≈ 20 |
| \(10^9\) | ≈ 30 |

---

## 3. 값 존재 탐색(정확히 같은 값)

가장 기본형입니다. 배열이 **오름차순 정렬**되어 있다는 전제.

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return True
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return False
```

> 실무/대회에서는 값의 **존재 여부**뿐 아니라 “**첫 번째 위치**/**마지막 위치**”가 필요한 경우가 많습니다.

---

## 4. 경계값 탐색 템플릿(중복 처리)

### 4.1 `lower_bound` (첫 번째 위치)
- 정의: **정렬 배열**에서 `x` 이상(`>= x`)이 처음 등장하는 **가장 작은 인덱스**
- 없으면 `len(arr)` 반환

```python
def lower_bound(arr, x):
    left, right = 0, len(arr)  # [left, right)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] >= x:
            right = mid
        else:
            left = mid + 1
    return left
```

### 4.2 `upper_bound` (마지막 다음 위치)
- 정의: `x`보다 큰(`> x`) 값이 처음 등장하는 인덱스

```python
def upper_bound(arr, x):
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] > x:
            right = mid
        else:
            left = mid + 1
    return left
```

### 4.3 값 `x`의 개수 세기
```python
cnt = upper_bound(arr, x) - lower_bound(arr, x)
```

---

## 5. 파이썬 내장 `bisect` 활용

```python
from bisect import bisect_left, bisect_right, insort

arr = [1,2,2,2,3,5]
L = bisect_left(arr, 2)   # 2가 처음 나타나는 위치(=2)
R = bisect_right(arr, 2)  # 2보다 큰 값 첫 위치(=5)
count_2 = R - L           # 3
insort(arr, 4)            # 정렬된 상태 유지 삽입
```

---

## 6. Parametric Search(이분으로 정답 찾기)

> **정답의 후보 범위** \([lo, hi]\)에서, 어떤 판정 함수 `ok(mid)`가 **단조적(True 구간이 연속)**일 때
> - **최댓값**을 찾을 때: `ok(mid)==True`면 오른쪽으로
> - **최솟값**을 찾을 때: `ok(mid)==True`면 왼쪽으로

### 6.1 최대 **가능 값** 찾기(랜선 자르기, 나무 자르기 등)
```python
def max_feasible(lo, hi, ok):
    ans = lo - 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if ok(mid):      # mid가 가능
            ans = mid
            lo = mid + 1 # 더 크게 도전
        else:
            hi = mid - 1
    return ans
```

### 6.2 최소 **가능 값** 찾기(블루레이 최소 크기 등)
```python
def min_feasible(lo, hi, ok):
    ans = hi + 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if ok(mid):        # mid가 가능
            ans = mid
            hi = mid - 1   # 더 작은 값 도전
        else:
            lo = mid + 1
    return ans
```

> 핵심: `ok(mid)`가 **단조**여야 이분이 성립합니다.

---

## 7. 실전 예제(백준)

### 7.1 1920 수 찾기 — 값 존재
```python
n = int(input())
arr = sorted(map(int, input().split()))
m = int(input())
targets = list(map(int, input().split()))

def contains(x):
    left, right = 0, n-1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == x: return 1
        if arr[mid] < x:  left = mid + 1
        else:             right = mid - 1
    return 0

for t in targets:
    print(contains(t))
```

### 7.2 1654 랜선 자르기 — 최대 길이(최대 가능)
```python
k, n = map(int, input().split())
lines = [int(input()) for _ in range(k)]

def ok(L):
    if L == 0: return True  # 방어(실제로는 left=1로 시작)
    return sum(x // L for x in lines) >= n

print(max_feasible(1, max(lines), ok))
```

### 7.3 2805 나무 자르기 — 절단 높이의 최대(최대 가능)
```python
n, m = map(int, input().split())
trees = list(map(int, input().split()))

def ok(h):
    return sum((t - h) for t in trees if t > h) >= m

print(max_feasible(0, max(trees), ok))
```

### 7.4 2343 기타 레슨 — 블루레이 최소 크기(최소 가능)
> 강의 순서 유지, 블루레이 개수 \( \le M \), **크기 최소화**

```python
n, m = map(int, input().split())
A = list(map(int, input().split()))

def ok(cap):
    if cap < max(A): return False
    cnt, cur = 1, 0
    for x in A:
        if cur + x <= cap:
            cur += x
        else:
            cnt += 1
            cur = x
    return cnt <= m

lo, hi = max(A), sum(A)
print(min_feasible(lo, hi, ok))
```

### 7.5 1300 K번째 수 — 값 공간에서 이분
> \(N \times N\) 곱셈표에서 **\(\le x\)** 개수 카운트로 판정

```python
n = int(input())
k = int(input())

def count_le(x):
    cnt = 0
    for i in range(1, n+1):
        cnt += min(n, x // i)
    return cnt

def kth_in_table():
    lo, hi = 1, k
    ans = hi
    while lo <= hi:
        mid = (lo + hi) // 2
        if count_le(mid) >= k:
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans

print(kth_in_table())
```

### 7.6 2110 공유기 설치 — 최소 거리의 최대화(최대 가능)
```python
n, c = map(int, input().split())
X = sorted(int(input()) for _ in range(n))

def ok(dist):
    # dist 이상의 간격으로 c개 이상 설치 가능한가
    cnt, last = 1, X[0]
    for i in range(1, n):
        if X[i] - last >= dist:
            cnt += 1
            last = X[i]
    return cnt >= c

print(max_feasible(1, X[-1]-X[0], ok))
```

### 7.7 2512 예산 — 상한선(최대 가능)
```python
n = int(input())
req = list(map(int, input().split()))
M = int(input())

def ok(cap):
    return sum(min(x, cap) for x in req) <= M

print(max_feasible(0, max(req), ok))
```

### 7.8 6236 용돈 관리 — 인출 금액 최소(최소 가능)
```python
n, m = map(int, input().split())
A = [int(input()) for _ in range(n)]

def ok(K):
    if K < max(A): return False
    cnt, cur = 1, K
    for x in A:
        if cur >= x:
            cur -= x
        else:
            cnt += 1
            cur = K - x
    return cnt <= m

print(min_feasible(max(A), sum(A), ok))
```

---

## 8. 실수(연속값) 이분 탐색

값이 **실수**일 때는 반복 횟수(또는 허용 오차 \(\varepsilon\))로 수렴시킵니다.

```python
def binary_search_real(lo, hi, ok, eps=1e-9, maximize=True):
    # maximize=True: True가 되는 구간의 최대 경계
    for _ in range(100):  # log2((hi-lo)/eps) 정도면 충분
        mid = (lo + hi) / 2
        if ok(mid):
            if maximize:
                lo = mid
            else:
                hi = mid
        else:
            if maximize:
                hi = mid
            else:
                lo = mid
    return (lo + hi) / 2
```

예: 어떤 연속 함수의 역함수처럼 “**조건을 만족하는 최소/최대 실수**” 찾기.

---

## 9. 디버깅/경계값 주의

1) **무한 루프 방지**
   - `while left <= right` vs `while left < right`의 차이를 이해하고, 갱신 시 **정확히 수렴**하도록 조건 설계
2) **정답 갱신 지점**
   - 최대 가능: `ok(mid)==True` → `ans=mid`, `left=mid+1`
   - 최소 가능: `ok(mid)==True` → `ans=mid`, `right=mid-1`
3) **중복 원소**
   - 첫/마지막 위치를 정확히 구하려면 `lower/upper_bound` 패턴 사용
4) **정렬/단조성 전제** 확인
   - 값 탐색은 **정렬된 배열**
   - Parametric은 **단조 판정식** 확보
5) **경계의 초기값**
   - `lo/hi`의 **의미**(불가능/가능의 경계)와 포함 여부를 명확히

---

## 10. 이분 탐색 체크리스트(Parametric)

- 문제를 “**예/아니오(가능/불가능) 판정**”으로 바꾸면 단조인가?
- 탐색 범위의 **하한/상한**을 안전하게 설정했는가?
- **최대/최소** 중 무엇을 찾는가? → 템플릿 선택
- `ok(mid)`는 **한 번 계산이 충분히 빠른가?** (이분은 `log`번만 호출되므로 보통 괜찮음)
- 정수/실수 케이스 구분, 실수는 **오차**로 수렴

---

## 11. 보너스: LIS(최장 증가 부분수열)에서의 이분 응용

길이 \(L\)를 유지하는 배열 `tail`, 각 길이별 **가장 작은 끝값** 저장.
다음 원소 \(x\)가 오면 `bisect_left(tail, x)` 위치에 갱신.

```python
from bisect import bisect_left

def lis_length(arr):
    tail = []
    for x in arr:
        i = bisect_left(tail, x)
        if i == len(tail):
            tail.append(x)
        else:
            tail[i] = x
    return len(tail)
```

시간복잡도 \(O(n \log n)\).

---

## 12. 이분 탐색 vs 투 포인터 선택 기준

- **이분 탐색**: 정답이 값/용량/거리/시간 등 **스칼라 범위**에서 **단조 판정** 가능할 때
- **투 포인터**: **정렬된 배열에서 두 인덱스로 이동하며 조건**을 만족(주로 **합/길이**), 배열 값이 **양수**일 때 유리(예: 1806 부분합)

---

## 13. 수학적 관점(경계 정식화)

이분은 “**단조 부울 함수** \(f(x)\)”에 대해 경계점을 찾는 과정입니다.

- 최대 가능:
  $$
  \max\{x \mid f(x)=\mathrm{True}\}
  $$
- 최소 가능:
  $$
  \min\{x \mid f(x)=\mathrm{True}\}
  $$

여기서 \(f\)는 **단조**(예: \(x\)가 커질수록 True/False가 바뀌지 않음)해야 합니다.

---

## 14. 정리

| 항목 | 요약 |
|---|---|
| 본질 | 정렬/단조를 이용해 탐색 공간을 반으로 줄이는 기법 |
| 유형 | 값 존재/위치 탐색, 경계값(최소/최대 가능) 탐색 |
| 툴 | `lower_bound`/`upper_bound`, `bisect_left/right` |
| Parametric | `ok(mid)` 단조성, 최대/최소 템플릿 |
| 실수형 | 오차 허용 반복으로 수렴 |
| 주의 | 무한루프·정답 갱신·경계 초기화·중복 처리 |

이분 탐색은 “정렬/단조”라는 한 가지만 확보되면, **값 자체**든 **정답의 범위**든 효율적으로 파고드는 만능 공구입니다. 위 템플릿을 습관처럼 적용하면 대부분의 경계형 최적화 문제를 안정적으로 해결할 수 있습니다.
