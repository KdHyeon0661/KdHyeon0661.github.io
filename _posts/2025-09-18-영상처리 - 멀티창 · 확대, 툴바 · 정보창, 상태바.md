---
layout: post
title: 영상처리 - 멀티창 · 확대/툴바 · 정보창/상태바
date: 2025-09-18 18:25:23 +0900
category: 영상처리
---
# 멀티창 · 확대/툴바 · 정보창/상태바 — **ImageTool** 고도화
---

## 목표 기능

### 5.3 | 영상을 **새 창**으로 띄우기
- 프로그램 구조: **Window-per-Document** (문서마다 독립 **상단 메뉴/툴바/상태바/출력창** 포함)
- 메뉴 항목: **File → New Window**, **Open**, **Save As**, **Copy**, **Paste**
- 복사/붙여넣기: `IppDib::copyToClipboard / pasteFromClipboard` 사용

### 5.4 | 영상을 **확대하여 보기** (툴바/메뉴)
- 뷰의 **Zoom** 상태(배율 %) 유지
- 메뉴/단축키: **Zoom In(+), Zoom Out(-), 100%(0)**  
- 툴바 버튼: **＋ / － / 100%** (텍스트 버튼, 이미지 리소스 불필요)

### 5.5 | 영상 정보 표시 (출력창 + 상태바)
- 출력창: 하단 **멀티라인 Read-only EDIT** (로그/메타 정보 라인 추가)
- 상태바: 4구역 (①크기 ②배율 ③마우스 좌표 ④파일명)  
  → 마우스를 영상 위로 움직이면 **픽셀 좌표**가 실시간 표시

---

# 전체 코드

> 프로젝트 구조(권장)
```
ImageTool/
  include/
    IppDib.h
    IppInterOp.h
  src/
    IppDib.cpp
    IppInterOp.cpp
    main_multiwin.cpp   ← 본문 핵심(멀티창/툴바/상태바/출력창)
  res/
    resource.h
    ImageTool.rc
```

아래에는 **리소스 헤더 → RC → 메인 소스** 순으로 제시합니다. (`IppDib.* / IppInterOp.*` 는 앞 장의 것을 사용)

---

## (1) `res/resource.h`

```cpp
#pragma once

// Dialogs (미사용 예비)
#define IDD_DUMMY                       101

// Main Menu
#define IDR_MAINMENU                    200
#define IDR_ACCEL                       201

// Commands
#define ID_APP_NEWWINDOW                40001
#define ID_FILE_OPEN                    40002
#define ID_FILE_SAVEAS                  40003
#define ID_EDIT_COPY                    40010
#define ID_EDIT_PASTE                   40011
#define ID_VIEW_ZOOMIN                  40020
#define ID_VIEW_ZOOMOUT                 40021
#define ID_VIEW_ZOOMRESET               40022

// Toolbar (가상 ID들: 버튼 식별용)
#define IDC_TOOLBAR                     50001
#define IDC_STATUSBAR                   50002
#define IDC_OUTPUT                      50003

// 기타
#define IDS_APP_TITLE                   60001
```

---

## (2) `res/ImageTool.rc`

> Visual Studio 리소스 편집기로 만들어도 되지만, 텍스트 RC로 제공하며 바로 빌드됩니다.

```rc
#include <windows.h>
#include "resource.h"

IDS_APP_TITLE STRINGTABLE
BEGIN
    IDS_APP_TITLE, "ImageTool"
END

IDR_MAINMENU MENU
BEGIN
    POPUP "&File"
    BEGIN
        MENUITEM "New &Window\tCtrl+N",      ID_APP_NEWWINDOW
        MENUITEM "&Open...\tCtrl+O",         ID_FILE_OPEN
        MENUITEM "Save &As...\tCtrl+S",      ID_FILE_SAVEAS
        MENUITEM SEPARATOR
        MENUITEM "E&xit",                    0xF060   // SC_CLOSE
    END
    POPUP "&Edit"
    BEGIN
        MENUITEM "&Copy\tCtrl+C",            ID_EDIT_COPY
        MENUITEM "&Paste\tCtrl+V",           ID_EDIT_PASTE
    END
    POPUP "&View"
    BEGIN
        MENUITEM "Zoom &In\t+",              ID_VIEW_ZOOMIN
        MENUITEM "Zoom &Out\t-",             ID_VIEW_ZOOMOUT
        MENUITEM "&Actual Size 100%\t0",     ID_VIEW_ZOOMRESET
    END
END

IDR_ACCEL ACCELERATORS
BEGIN
    "N",  ID_APP_NEWWINDOW, VIRTKEY, CONTROL
    "O",  ID_FILE_OPEN,     VIRTKEY, CONTROL
    "S",  ID_FILE_SAVEAS,   VIRTKEY, CONTROL
    "C",  ID_EDIT_COPY,     VIRTKEY, CONTROL
    "V",  ID_EDIT_PASTE,    VIRTKEY, CONTROL
    VK_OEM_PLUS,   ID_VIEW_ZOOMIN,   VIRTKEY, NOINVERT
    VK_ADD,        ID_VIEW_ZOOMIN,   VIRTKEY, NOINVERT
    VK_OEM_MINUS,  ID_VIEW_ZOOMOUT,  VIRTKEY, NOINVERT
    VK_SUBTRACT,   ID_VIEW_ZOOMOUT,  VIRTKEY, NOINVERT
    "0",           ID_VIEW_ZOOMRESET, VIRTKEY, NOINVERT
END
```

---

## (3) `src/main_multiwin.cpp`

> **멀티창** 구조, **툴바/상태바/출력창** 레이아웃, **복사/붙여넣기/확대/축소**/정보표시가 모두 들어있습니다.

```cpp
// main_multiwin.cpp
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <string>
#include <vector>
#include <cwchar>
#include <cmath>
#include "resource.h"
#include "IppDib.h"
#include "IppInterOp.h"

#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "comdlg32.lib")
#pragma comment(lib, "shlwapi.lib")

// ---------- 앱/윈도우 글로발 ----------
static HINSTANCE g_hInst = nullptr;
static const wchar_t* kWndClass = L"ImageTool.Frame";
static const int PADDING = 16;

// ---------- 뷰 상태 ----------
struct ViewState {
    IppDib      dib;
    std::wstring path;
    double      zoom = 1.0;     // 1.0 = 100%
    HWND        hToolbar = nullptr;
    HWND        hStatus  = nullptr;
    HWND        hOutput  = nullptr;
    SIZE        lastClient = {0,0}; // 레이아웃 캐시
};

// ---------- 유틸 ----------
static void ErrorBox(HWND owner, const wchar_t* msg) {
    MessageBoxW(owner, msg, L"ImageTool Error", MB_OK | MB_ICONERROR);
}
static void InfoAppend(HWND hEdit, const std::wstring& line) {
    int len = GetWindowTextLengthW(hEdit);
    SendMessageW(hEdit, EM_SETSEL, (WPARAM)len, (LPARAM)len);
    SendMessageW(hEdit, EM_REPLACESEL, FALSE, (LPARAM)line.c_str());
    SendMessageW(hEdit, EM_REPLACESEL, FALSE, (LPARAM)L"\r\n");
}
static std::wstring BaseNameOf(const std::wstring& p) {
    wchar_t fname[_MAX_FNAME]{}, ext[_MAX_EXT]{};
    _wsplitpath_s(p.c_str(), nullptr, 0, nullptr, 0, fname, _MAX_FNAME, ext, _MAX_EXT);
    return std::wstring(fname) + std::wstring(ext);
}

// ---------- 파일 다이얼로그 ----------
static bool OpenFileDialog(HWND owner, std::wstring& outPath) {
    wchar_t buf[MAX_PATH]=L"";
    OPENFILENAMEW ofn{ sizeof(ofn) };
    ofn.hwndOwner=owner;
    ofn.lpstrFilter=L"BMP files (*.bmp)\0*.bmp\0All files (*.*)\0*.*\0";
    ofn.lpstrFile=buf; ofn.nMaxFile=MAX_PATH;
    ofn.Flags=OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
    ofn.lpstrTitle=L"Open BMP";
    if (GetOpenFileNameW(&ofn)) { outPath=buf; return true; }
    return false;
}
static bool SaveFileDialog(HWND owner, std::wstring& outPath) {
    wchar_t buf[MAX_PATH]=L"";
    OPENFILENAMEW ofn{ sizeof(ofn) };
    ofn.hwndOwner=owner;
    ofn.lpstrFilter=L"BMP files (*.bmp)\0*.bmp\0";
    ofn.lpstrFile=buf; ofn.nMaxFile=MAX_PATH;
    ofn.Flags=OFN_OVERWRITEPROMPT;
    ofn.lpstrTitle=L"Save As";
    if (GetSaveFileNameW(&ofn)) { outPath=buf; return true; }
    return false;
}

// ---------- 상태바/출력창 텍스트 ----------
static void StatusSet(HWND hStatus, int part, const std::wstring& s) {
    SendMessageW(hStatus, SB_SETTEXT, part, (LPARAM)s.c_str());
}
static void UpdateStatusBasic(HWND hWnd, ViewState* st, POINT mouseClient = {INT_MIN,INT_MIN}) {
    if (!st || !st->hStatus) return;
    if (!st->dib) {
        StatusSet(st->hStatus, 0, L"- x -");
        StatusSet(st->hStatus, 1, L"- %");
        StatusSet(st->hStatus, 2, L"(x,y)");
        StatusSet(st->hStatus, 3, L"(no file)");
        return;
    }
    StatusSet(st->hStatus, 0, std::to_wstring(st->dib.width()) + L" x " + std::to_wstring(st->dib.height()));
    int zoomPct = (int)std::lround(st->zoom*100.0);
    StatusSet(st->hStatus, 1, std::to_wstring(zoomPct) + L"%");
    StatusSet(st->hStatus, 3, st->path.empty()? L"(unsaved)" : BaseNameOf(st->path));

    // 마우스 좌표 → 이미지 좌표
    if (mouseClient.x != INT_MIN) {
        // 현재 레이아웃 기준 이미지 표시 사각형 계산
        RECT rcClient; GetClientRect(hWnd, &rcClient);
        // 툴바/상태바/출력창 영역을 제외한 작업영역 계산
        RECT rcToolbar{0,0,0,0}; if (st->hToolbar) { GetWindowRect(st->hToolbar,&rcToolbar); MapWindowPoints(HWND_DESKTOP,hWnd,(LPPOINT)&rcToolbar,2); }
        RECT rcStatus{0,0,0,0};  if (st->hStatus)  { GetWindowRect(st->hStatus,&rcStatus);  MapWindowPoints(HWND_DESKTOP,hWnd,(LPPOINT)&rcStatus,2); }
        RECT rcOutput{0,0,0,0};  if (st->hOutput)  { GetWindowRect(st->hOutput,&rcOutput);  MapWindowPoints(HWND_DESKTOP,hWnd,(LPPOINT)&rcOutput,2); }
        int topY = rcToolbar.bottom;
        int bottomY = rcStatus.top;
        if (st->hOutput) bottomY = rcOutput.top;  // 출력창이 상태바 위에 위치
        // 이미지 사각형
        int iw = (int)std::lround(st->dib.width()  * st->zoom);
        int ih = (int)std::lround(st->dib.height() * st->zoom);
        RECT rcImg {
            rcClient.left + PADDING,
            topY + PADDING,
            rcClient.left + PADDING + iw,
            topY + PADDING + ih
        };
        int ix = (int)std::floor((mouseClient.x - rcImg.left)/st->zoom);
        int iy = (int)std::floor((mouseClient.y - rcImg.top )/st->zoom);
        if (ix>=0 && iy>=0 && ix<st->dib.width() && iy<st->dib.height()) {
            StatusSet(st->hStatus, 2, L"(" + std::to_wstring(ix) + L"," + std::to_wstring(iy) + L")");
        } else {
            StatusSet(st->hStatus, 2, L"(x,y)");
        }
    }
}
static void OutputBasicInfo(ViewState* st) {
    if (!st || !st->hOutput) return;
    if (!st->dib) { SetWindowTextW(st->hOutput, L""); return; }
    std::wstring msg;
    msg += L"File: " + (st->path.empty()? L"(unsaved)" : st->path) + L"\r\n";
    msg += L"Size: " + std::to_wstring(st->dib.width()) + L" x " + std::to_wstring(st->dib.height()) + L"\r\n";
    msg += L"Stride: " + std::to_wstring(st->dib.stride()) + L", Format: BGRA32 Top-Down\r\n";
    msg += L"Zoom: " + std::to_wstring((int)std::lround(st->zoom*100.0)) + L"%\r\n";
    SetWindowTextW(st->hOutput, msg.c_str());
}

// ---------- 레이아웃 ----------
static void DoLayout(HWND hWnd, ViewState* st) {
    if (!st) return;
    RECT rc; GetClientRect(hWnd, &rc);
    int W = rc.right - rc.left;
    int H = rc.bottom - rc.top;
    st->lastClient = { W, H };

    // 1) 툴바 최상단
    int tbH = 0;
    if (st->hToolbar) {
        SendMessageW(st->hToolbar, TB_AUTOSIZE, 0, 0);
        RECT r; GetWindowRect(st->hToolbar, &r); tbH = r.bottom - r.top;
        MoveWindow(st->hToolbar, 0, 0, W, tbH, TRUE);
    }

    // 2) 상태바 최하단
    int sbH = 0;
    if (st->hStatus) {
        SendMessageW(st->hStatus, WM_SIZE, 0, 0); // 자동 위치
        RECT r; GetWindowRect(st->hStatus, &r); sbH = r.bottom - r.top;
        MoveWindow(st->hStatus, 0, H - sbH, W, sbH, TRUE);
        // 파트 분할: 4개(크기, 배율, 좌표, 파일명)
        int parts[4] = { 120, 200, 300, W - 10 };
        SendMessageW(st->hStatus, SB_SETPARTS, 4, (LPARAM)parts);
    }

    // 3) 출력창: 상태바 바로 위, 높이 120
    int outH = 120;
    if (st->hOutput) {
        MoveWindow(st->hOutput, 0, H - sbH - outH, W, outH, TRUE);
    }
    // 4) 나머지 영역은 Paint에서 사용 (이미지 위치 계산은 Paint/Status 갱신 시점에 수행)
}

// ---------- 배경 빗금 ----------
static void FillOutsideHatchEx(HWND hWnd, HDC hdc, ViewState* st, const RECT& rcClient) {
    // 작업 상단/하단 y
    RECT rTB{0}, rSB{0}, rOut{0};
    if (st->hToolbar) { GetWindowRect(st->hToolbar,&rTB); MapWindowPoints(HWND_DESKTOP,hWnd,(LPPOINT)&rTB,2); }
    if (st->hStatus)  { GetWindowRect(st->hStatus,&rSB);  MapWindowPoints(HWND_DESKTOP,hWnd,(LPPOINT)&rSB,2); }
    RECT rEdit{0}; if (st->hOutput) { GetWindowRect(st->hOutput,&rEdit); MapWindowPoints(HWND_DESKTOP,hWnd,(LPPOINT)&rEdit,2); }

    int topY = rTB.bottom;
    int bottomY = rSB.top;
    if (st->hOutput) bottomY = rEdit.top;

    // 이미지 표시 사각형
    int iw = st->dib ? (int)std::lround(st->dib.width()*st->zoom)  : 0;
    int ih = st->dib ? (int)std::lround(st->dib.height()*st->zoom) : 0;
    RECT rcImg {
        rcClient.left + PADDING,
        topY + PADDING,
        rcClient.left + PADDING + iw,
        topY + PADDING + ih
    };

    // (client_work - rcImg) 영역 해치
    RECT work { rcClient.left, topY, rcClient.right, bottomY };
    HRGN rWork  = CreateRectRgn(work.left, work.top, work.right, work.bottom);
    HRGN rImage = CreateRectRgn(rcImg.left, rcImg.top, rcImg.right, rcImg.bottom);
    HRGN rDiff  = CreateRectRgn(0,0,0,0);
    CombineRgn(rDiff, rWork, rImage, RGN_DIFF);

    HBRUSH hatch = CreateHatchBrush(HS_BDIAGONAL, RGB(180,180,180));
    HBRUSH oldB  = (HBRUSH)SelectObject(hdc, hatch);
    COLORREF oldBk = SetBkColor(hdc, RGB(245,245,245));
    COLORREF oldTx = SetTextColor(hdc, RGB(180,180,180));
    FillRgn(hdc, rDiff, hatch);
    SetTextColor(hdc, oldTx); SetBkColor(hdc, oldBk);
    SelectObject(hdc, oldB);
    DeleteObject(hatch); DeleteObject(rWork); DeleteObject(rImage); DeleteObject(rDiff);
}

// ---------- 그리기 ----------
static void OnPaint(HWND hWnd, ViewState* st) {
    PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &ps);
    RECT rc; GetClientRect(hWnd, &rc);

    FillOutsideHatchEx(hWnd, hdc, st, rc);

    if (st->dib) {
        RECT rTB{0}, rSB{0}, rEdit{0};
        if (st->hToolbar){ GetWindowRect(st->hToolbar,&rTB); MapWindowPoints(HWND_DESKTOP,hWnd,(LPPOINT)&rTB,2); }
        if (st->hStatus ){ GetWindowRect(st->hStatus,&rSB);  MapWindowPoints(HWND_DESKTOP,hWnd,(LPPOINT)&rSB,2); }
        if (st->hOutput ){ GetWindowRect(st->hOutput,&rEdit);MapWindowPoints(HWND_DESKTOP,hWnd,(LPPOINT)&rEdit,2); }

        int topY = rTB.bottom;
        int iw = (int)std::lround(st->dib.width()  * st->zoom);
        int ih = (int)std::lround(st->dib.height() * st->zoom);
        RECT dst { rc.left + PADDING, topY + PADDING, 0, 0 };
        dst.right  = dst.left + iw;
        dst.bottom = dst.top  + ih;

        st->dib.draw(hdc, dst, SRCCOPY, HALFTONE);
    } else {
        const wchar_t* t = L"Ctrl+N: New Window  |  Ctrl+O: Open BMP  |  Drag & Drop: Open";
        TextOutW(hdc, 10, 10, t, lstrlenW(t));
    }

    EndPaint(hWnd, &ps);
}

// ---------- 툴바/상태바/출력창 만들기 ----------
static HWND CreateAppToolbar(HWND hWnd) {
    INITCOMMONCONTROLSEX icc{ sizeof(icc), ICC_BAR_CLASSES };
    InitCommonControlsEx(&icc);

    HWND hTB = CreateWindowExW(0, TOOLBARCLASSNAMEW, nullptr,
        WS_CHILD | WS_VISIBLE | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS,
        0,0,0,0, hWnd, (HMENU)IDC_TOOLBAR, g_hInst, nullptr);
    if (!hTB) return nullptr;

    SendMessageW(hTB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    // 텍스트 리소스 추가
    const wchar_t* labels = L"Zoom +\0Zoom -\0100%\0";
    INT_PTR strBase = (INT_PTR)SendMessageW(hTB, TB_ADDSTRING, 0, (LPARAM)labels);

    TBBUTTON btns[3]{};
    btns[0].iBitmap = I_IMAGENONE; btns[0].idCommand = ID_VIEW_ZOOMIN;   btns[0].fsState=TBSTATE_ENABLED; btns[0].fsStyle=BTNS_BUTTON; btns[0].iString=strBase+0;
    btns[1].iBitmap = I_IMAGENONE; btns[1].idCommand = ID_VIEW_ZOOMOUT;  btns[1].fsState=TBSTATE_ENABLED; btns[1].fsStyle=BTNS_BUTTON; btns[1].iString=strBase+1;
    btns[2].iBitmap = I_IMAGENONE; btns[2].idCommand = ID_VIEW_ZOOMRESET;btns[2].fsState=TBSTATE_ENABLED; btns[2].fsStyle=BTNS_BUTTON; btns[2].iString=strBase+2;

    SendMessageW(hTB, TB_ADDBUTTONS, (WPARAM)3, (LPARAM)btns);
    SendMessageW(hTB, TB_AUTOSIZE, 0, 0);
    ShowWindow(hTB, SW_SHOW);
    return hTB;
}
static HWND CreateAppStatus(HWND hWnd) {
    HWND hSB = CreateStatusWindowW(WS_CHILD | WS_VISIBLE, L"", hWnd, IDC_STATUSBAR);
    return hSB;
}
static HWND CreateOutputBox(HWND hWnd) {
    HWND hEdit = CreateWindowExW(WS_EX_CLIENTEDGE, L"EDIT", L"",
        WS_CHILD | WS_VISIBLE | ES_LEFT | ES_MULTILINE | ES_READONLY | WS_VSCROLL,
        0,0,0,0, hWnd, (HMENU)IDC_OUTPUT, g_hInst, nullptr);
    SendMessageW(hEdit, EM_SETLIMITTEXT, 1024*1024, 0);
    return hEdit;
}

// ---------- 이미지 로드/저장 ----------
static bool DoOpen(ViewState* st, HWND hWnd, const std::wstring& path) {
    if (!st->dib.loadBMP(path)) { ErrorBox(hWnd, L"Failed to load BMP"); return false; }
    st->path = path;
    st->zoom = 1.0;
    OutputBasicInfo(st);
    UpdateStatusBasic(hWnd, st);
    InvalidateRect(hWnd, nullptr, FALSE);
    return true;
}
static bool DoOpenDialog(ViewState* st, HWND hWnd) {
    std::wstring p; if (!OpenFileDialog(hWnd, p)) return false; return DoOpen(st, hWnd, p);
}
static bool DoSaveDialog(ViewState* st, HWND hWnd) {
    if (!st->dib) return false;
    std::wstring p; if (!SaveFileDialog(hWnd, p)) return false;
    if (!st->dib.saveBMP(p, 24)) { ErrorBox(hWnd, L"Failed to save BMP"); return false; }
    st->path = p;
    OutputBasicInfo(st);
    UpdateStatusBasic(hWnd, st);
    return true;
}

// ---------- 줌 ----------
static void SetZoom(ViewState* st, HWND hWnd, double z) {
    if (z < 0.05) z = 0.05;
    if (z > 32.0) z = 32.0;
    st->zoom = z;
    OutputBasicInfo(st);
    UpdateStatusBasic(hWnd, st);
    InvalidateRect(hWnd, nullptr, FALSE);
}
static void ZoomIn(ViewState* st, HWND hWnd)    { SetZoom(st, hWnd, st->zoom * 1.25); }
static void ZoomOut(ViewState* st, HWND hWnd)   { SetZoom(st, hWnd, st->zoom / 1.25); }
static void ZoomReset(ViewState* st, HWND hWnd) { SetZoom(st, hWnd, 1.0); }

// ---------- 클립보드 ----------
static void DoCopy(ViewState* st, HWND hWnd) {
    if (!st->dib) return;
    st->dib.copyToClipboard(hWnd);
    InfoAppend(st->hOutput, L"Copied to clipboard.");
}
static void DoPaste(ViewState* st, HWND hWnd) {
    if (st->dib.pasteFromClipboard(hWnd)) {
        st->path.clear();
        st->zoom = 1.0;
        OutputBasicInfo(st);
        UpdateStatusBasic(hWnd, st);
        InvalidateRect(hWnd, nullptr, FALSE);
        InfoAppend(st->hOutput, L"Pasted from clipboard.");
    } else {
        InfoAppend(st->hOutput, L"(Paste failed)");
    }
}

// ---------- 드래그&드롭 ----------
static void OnDropFiles(HWND hWnd, ViewState* st, HDROP hDrop) {
    wchar_t path[MAX_PATH]; DragQueryFileW(hDrop, 0, path, MAX_PATH);
    DragFinish(hDrop);
    DoOpen(st, hWnd, path);
}

// ---------- 새 프레임 윈도우 ----------
static HWND CreateFrame(const std::wstring& optionalOpenPath = L"") {
    HWND h = CreateWindowExW(0, kWndClass, L"ImageTool",
        WS_OVERLAPPEDWINDOW | WS_VISIBLE,
        CW_USEDEFAULT, CW_USEDEFAULT, 1024, 768,
        nullptr, nullptr, g_hInst, nullptr);
    if (!h) return nullptr;

    auto* st = new ViewState();
    SetWindowLongPtrW(h, GWLP_USERDATA, (LONG_PTR)st);

    // 메뉴
    HMENU hMenu = LoadMenuW(g_hInst, MAKEINTRESOURCEW(IDR_MAINMENU));
    SetMenu(h, hMenu);

    // 툴바/상태바/출력창
    st->hToolbar = CreateAppToolbar(h);
    st->hStatus  = CreateAppStatus(h);
    st->hOutput  = CreateOutputBox(h);

    DragAcceptFiles(h, TRUE);

    DoLayout(h, st);
    UpdateStatusBasic(h, st);
    OutputBasicInfo(st);

    if (!optionalOpenPath.empty()) {
        DoOpen(st, h, optionalOpenPath);
        SetWindowTextW(h, (L"ImageTool - " + BaseNameOf(optionalOpenPath)).c_str());
    } else {
        SetWindowTextW(h, L"ImageTool");
    }
    return h;
}

// ---------- 메시지 핸들러 ----------
static LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    auto* st = reinterpret_cast<ViewState*>(GetWindowLongPtrW(hWnd, GWLP_USERDATA));
    switch (msg) {
    case WM_CREATE:
        return 0;

    case WM_SIZE:
        if (st) DoLayout(hWnd, st);
        return 0;

    case WM_PAINT:
        if (st) OnPaint(hWnd, st);
        return 0;

    case WM_MOUSEMOVE:
        if (st && st->hStatus) {
            POINT pt { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
            UpdateStatusBasic(hWnd, st, pt);
        }
        return 0;

    case WM_DROPFILES:
        if (st) OnDropFiles(hWnd, st, (HDROP)wParam);
        return 0;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case ID_APP_NEWWINDOW:
            CreateFrame(); return 0;
        case ID_FILE_OPEN:
            if (st) DoOpenDialog(st, hWnd); return 0;
        case ID_FILE_SAVEAS:
            if (st) DoSaveDialog(st, hWnd); return 0;
        case ID_EDIT_COPY:
            if (st) DoCopy(st, hWnd); return 0;
        case ID_EDIT_PASTE:
            if (st) DoPaste(st, hWnd); return 0;
        case ID_VIEW_ZOOMIN:
            if (st) ZoomIn(st, hWnd); return 0;
        case ID_VIEW_ZOOMOUT:
            if (st) ZoomOut(st, hWnd); return 0;
        case ID_VIEW_ZOOMRESET:
            if (st) ZoomReset(st, hWnd); return 0;
        default: break;
        }
        break;

    case WM_DESTROY:
        if (st) {
            delete st;
            SetWindowLongPtrW(hWnd, GWLP_USERDATA, 0);
        }
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProcW(hWnd, msg, wParam, lParam);
}

// ---------- WinMain ----------
int APIENTRY wWinMain(HINSTANCE hInst, HINSTANCE, LPWSTR, int nCmdShow) {
    g_hInst = hInst;

    // 공용 컨트롤
    INITCOMMONCONTROLSEX icc{ sizeof(icc), ICC_WIN95_CLASSES | ICC_BAR_CLASSES | ICC_TAB_CLASSES };
    InitCommonControlsEx(&icc);

    // 창 클래스 등록
    WNDCLASSEXW wc { sizeof(wc) };
    wc.lpfnWndProc   = WndProc;
    wc.hInstance     = g_hInst;
    wc.hCursor       = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszClassName = kWndClass;
    if (!RegisterClassExW(&wc)) return 0;

    // 커맨드라인에서 첫 파일을 자동 오픈(선택)
    std::wstring openArg;
    {
        int argc=0; LPWSTR* argv = CommandLineToArgvW(GetCommandLineW(), &argc);
        if (argv) {
            for (int i=1;i<argc;++i){ if (PathFileExistsW(argv[i])) { openArg=argv[i]; break; } }
            LocalFree(argv);
        }
    }

    HWND hFirst = CreateFrame(openArg);
    if (!hFirst) return 0;
    ShowWindow(hFirst, nCmdShow);
    UpdateWindow(hFirst);

    // 가속기
    HACCEL hAccel = LoadAcceleratorsW(g_hInst, MAKEINTRESOURCEW(IDR_ACCEL));

    // 메시지 루프
    MSG msg;
    while (GetMessageW(&msg, nullptr, 0, 0)) {
        if (!TranslateAcceleratorW(msg.hwnd, hAccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessageW(&msg);
        }
    }
    return (int)msg.wParam;
}
```

---

# 섹션별 해설

## 5.3 | 영상을 **새 창으로 띄우기** — 프로그램 구조

- **Window-per-Document**: 영상마다 **독립 윈도우**를 생성 (`CreateFrame`)  
  - 각 창은 자체 `ViewState`(DIB, 경로, 줌, 컨트롤 핸들)을 가짐  
  - **장점**: 간단한 코드로 멀티 문서(MDI 수준의 UX) 제공  
- **새 메뉴 항목**: `ID_APP_NEWWINDOW`  
  - 처리기: `WM_COMMAND / ID_APP_NEWWINDOW → CreateFrame()`

### 복사/붙여넣기
- **Copy**: `IppDib::copyToClipboard(hWnd)`  
- **Paste**: `IppDib::pasteFromClipboard(hWnd)` → 성공 시 `zoom=1.0`, 정보/상태 갱신

> 붙여넣기는 `CF_DIBV5 → CF_DIB → CF_BITMAP` 순으로 처리(이전 장의 IppDib 구현).  
> 클립보드에 올린 핸들은 OS 소유가 되므로 추가 해제 금지!

---

## 5.4 | **확대하여 보기** — 툴바/메뉴/단축키

- 툴바: `TBSTYLE_FLAT` 텍스트 버튼 **Zoom + / Zoom − / 100%**  
- 배율 상태: `ViewState::zoom` (배율 ×1.25 / ÷1.25 / =1.0)  
- 출력: `HALFTONE` StretchBlt 경로 (`IppDib::draw(hdc, dst, SRCCOPY, HALFTONE)`)  
- 단축키: `+`/`-`/`0` (RC의 `ACCELERATORS` 테이블)

**증분 팁**
- 배율 경계: 5%~3200% 사이로 클램프  
- 초대형 확대 시 퍼포먼스 고려: `COLORONCOLOR`로 바꾸면 속도↑(품질↓)

---

## 5.5 | **영상 정보 표시** — 출력창 & 상태바

- 출력창: 하단 **EDIT(READONLY, MULTILINE, VSCROLL, CLIENTEDGE)**  
  - `OutputBasicInfo()`로 파일/크기/Stride/Format/Zoom 텍스트 표시  
  - `InfoAppend()` 유틸로 로그 라인 추가
- 상태바: `CreateStatusWindowW` + `SB_SETPARTS`(4분할)
  1. **Size**: `WxH`
  2. **Zoom**: `NNN%`
  3. **Cursor**: `(x,y)` — 영상 위 마우스 이동 시 실시간 갱신
  4. **File**: 파일명

**좌표 계산 요령**
- 툴바/출력창/상태바의 y 범위를 **제외한 작업 영역**을 먼저 계산
- 그 안에서 `rcImg = (padding, padding, padding+iw, padding+ih)`  
- `ix=(mx-rcImg.left)/zoom`, `iy=(my-rcImg.top)/zoom`  
- 범위 체크 후 상태바 ③에 `"(ix,iy)"` 출력

---

# 검증 체크리스트

- [ ] 새 창/멀티 창 모두 **독립적으로缩放/복붙/불러오기/저장** 동작  
- [ ] 대형/소형 창 리사이즈 시 **툴바/출력창/상태바 레이아웃** 유지 (`DoLayout`)  
- [ ] 줌/마우스 좌표가 **정밀**하게 동작(픽셀 센터 기준 정수 좌표)  
- [ ] 드래그&드롭/단축키/메뉴가 일관 동작  
- [ ] 저장 후 상태바 파일명/출력창 정보 갱신

---

# 확장 아이디어

- **마우스 휠**로 줌(CTRL+Wheel) + 캔버스 중심 기준 확대  
- **스크롤바**(확대 시 캔버스가 클 때) — `WS_HSCROLL | WS_VSCROLL`  
- **히스토그램** 탭 추가(출력창 대신 탭컨트롤)  
- **PNG/JPEG 입출력**(WIC) 및 EXIF/ICC  
- **픽셀 값(Gray/RGB)** 상태바 즉시 표시(영상 클릭 시 해당 픽셀 샘플링)

---

# 요약

- 5.3: **새 창 구조**로 다중 영상 관리 + **복사/붙여넣기** 완비  
- 5.4: **툴바** + **줌 인/아웃/리셋** 구현, `HALFTONE` 스케일 출력  
- 5.5: **출력창**(텍스트 로그)과 **상태바(4분할)** 로 영상/좌표/배율/파일명을 명확히 표출