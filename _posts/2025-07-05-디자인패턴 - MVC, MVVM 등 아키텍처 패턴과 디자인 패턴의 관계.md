---
layout: post
title: 디자인패턴 - MVC, MVVM 등 아키텍처 패턴과 디자인 패턴의 관계
date: 2025-07-05 19:20:23 +0900
category: 디자인패턴
---
# MVC, MVVM 등 아키텍처 패턴과 디자인 패턴의 관계

## 아키텍처 패턴 vs 디자인 패턴: 개념 정리

| 항목 | 아키텍처 패턴 | 디자인 패턴 |
|---|---|---|
| 정의 | 시스템 전체의 구조·의존·책임 분리 규범 | 모듈/클래스/객체 간 협력 해법 |
| 범위 | 앱/도메인 전체 | 특정 컴포넌트/모듈 내부 |
| 목적 | 변경 용이성과 독립 배포, 테스트 경계 수립 | 반복 설계 난제의 재사용 가능한 해결책 |
| 예시 | MVC, MVVM, MVP, Flux/Redux, Clean, Hexagonal, Layered | Strategy, Observer, Command, State, Factory, Composite, Mediator, Repository, Memento 등 |
| 위치 | 상위 설계(경계·흐름) | 하위 구현(행동·생성·구조) |

요약 비유:
- 아키텍처 패턴 = 건물의 설계도(골조, 동선, 존).
- 디자인 패턴 = 문·창·배선·도어락처럼 **세부 기성품**.

---

## 공통 오해 정정

| 오해 | 바로잡기 |
|---|---|
| MVC/MVVM은 디자인 패턴이다 | 아키텍처 패턴이다. Controller/ViewModel 등 “역할의 분리”가 핵심 |
| 아키텍처 패턴만 있으면 된다 | 내부 구현이 헐거워지면 유지보수가 불가. 디자인 패턴으로 결속 필요 |
| 디자인 패턴은 옛날 GoF만 쓴다 | 현대 프런트/모바일/클라우드도 Strategy/Observer/Command/State/Factory는 그대로 쓰며, CQRS/ES, DI 등도 사실상 패턴의 집합적 응용 |

---

## 대표 아키텍처 패턴 브리핑

### MVC (Model–View–Controller)

| 구성 | 책임 | 내부에서 흔히 쓰는 디자인 패턴 |
|---|---|---|
| Model | 도메인 상태·규칙 | Repository, Factory, Aggregate, Domain Service |
| View | 표현·렌더링 | Composite, Decorator, Template Method |
| Controller | 입력→동작 매핑, 흐름 제어 | Command, Strategy, Mediator, Adapter |

특징: 웹 서버 사이드 렌더링(SSR)에서 고전적이며, 컨트롤러가 **유스케이스**를 오케스트레이션한다.

---

### MVVM (Model–View–ViewModel)

| 구성 | 책임 | 내부 디자인 패턴 |
|---|---|---|
| Model | 도메인 | Repository, Factory |
| View | UI와 바인딩 타깃 | Composite, Template Method |
| ViewModel | 상태·명령(커맨드)·검증 | Observer(데이터바인딩), Command(ICommand), Mediator(Event Aggregator), Strategy(검증/포맷) |

특징: 양방향 바인딩 기반 UI(WPF, SwiftUI, Jetpack Compose, Avalonia 등)에 최적.

---

### MVP (Model–View–Presenter)

| 구성 | 책임 | 내부 디자인 패턴 |
|---|---|---|
| Model | 도메인 | Repository |
| View | 수동 뷰(인터페이스) | Proxy, Adapter |
| Presenter | View에 의존하지만 View는 Presenter를 모름 | Strategy, Mediator, Observer(이벤트) |

특징: 바인딩이 약한 플랫폼(WinForms, 초창기 Android)에 적합.

---

### Flux/Redux, MVI

| 구조 | 요점 | 내부 패턴 |
|---|---|---|
| Flux/Redux | 단일 스토어 상태, 불변 업데이트, 액션→리듀서 | Command(액션), Strategy(리듀서 선택), Memento(타임트래블/히스토리), Observer(구독) |
| MVI | Intent→Reducer→State 단방향 데이터 흐름 | 동일 |

---

### Layered / Clean / Hexagonal (Ports & Adapters)

| 아키텍처 | 핵심 | 내부 패턴 |
|---|---|---|
| Layered | Presentation/Domain/Data 계층화 | Facade, Adapter, Repository |
| Clean | UseCase(인터랙터) 중심, 의존 규칙(안쪽이 바깥을 모름) | Boundary Interface, DI, Factory, Command |
| Hexagonal | Port(추상)·Adapter(구현)로 IO 격리 | Adapter, Strategy, Repository, Factory |

---

## “아키텍처 요소 ↔ 디자인 패턴” 매핑 표

| 아키텍처 요소 | 대표 디자인 패턴 |
|---|---|
| Controller/UseCase 오케스트레이션 | Command, Strategy, Template Method, Mediator |
| ViewModel 상태·명령 | Observer(NotifyPropertyChanged), Command(ICommand), State(페이지 상태) |
| 이벤트 버스/교차 통지 | Mediator, Observer, Event Aggregator |
| 데이터 접근 계층 | Repository, Unit of Work, Factory, Proxy |
| 객체 생성/조립 | Factory Method, Abstract Factory, Builder, DI(Container) |
| 에러·검증·권한 | Chain of Responsibility, Strategy, Specification |
| Undo/Redo | Memento(+ Command) |
| 복합 UI | Composite, Decorator |

---

## 실무 시나리오별 미니 설계도

### WPF/Avalonia — MVVM 기본기 (Observer + Command)

#### ViewModel: INotifyPropertyChanged + RelayCommand

```csharp
using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows.Input;

public sealed class RelayCommand : ICommand
{
    private readonly Action<object?> _exec;
    private readonly Func<object?, bool>? _can;
    public RelayCommand(Action<object?> exec, Func<object?, bool>? can = null)
    { _exec = exec; _can = can; }
    public bool CanExecute(object? p) => _can?.Invoke(p) ?? true;
    public void Execute(object? p) => _exec(p);
    public event EventHandler? CanExecuteChanged;
    public void RaiseCanExecuteChanged() => CanExecuteChanged?.Invoke(this, EventArgs.Empty);
}

public class CounterViewModel : INotifyPropertyChanged
{
    private int _count;
    public int Count
    {
        get => _count;
        private set { _count = value; OnPropertyChanged(); }
    }
    public ICommand IncCommand { get; }
    public ICommand DecCommand { get; }

    public CounterViewModel()
    {
        IncCommand = new RelayCommand(_ => Count++);
        DecCommand = new RelayCommand(_ => Count--, _ => Count > 0);
    }

    public event PropertyChangedEventHandler? PropertyChanged;
    private void OnPropertyChanged([CallerMemberName] string? n = null)
        => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(n));
}
```

핵심 포인트:
- **Observer**: `INotifyPropertyChanged`로 View가 변경을 구독한다.
- **Command**: 버튼 행동을 `ICommand`로 추상화하여 테스트/바인딩이 쉬워진다.
- View(XAML)는 순수 바인딩만 담당(Template Method 스타일의 XAML 템플릿 재사용).

#### Event Aggregator로 화면 간 통신 (Mediator)

```csharp
public interface IEvent { }
public sealed class UserLoggedIn : IEvent { public string UserId { get; init; } = ""; }

public interface IEventAggregator
{
    void Publish<T>(T evt) where T : IEvent;
    void Subscribe<T>(Action<T> handler) where T : IEvent;
}

public sealed class EventAggregator : IEventAggregator
{
    private readonly Dictionary<Type, List<Delegate>> _subs = new();
    public void Publish<T>(T evt) where T : IEvent
    {
        if (_subs.TryGetValue(typeof(T), out var list))
            foreach (var h in list) ((Action<T>)h)(evt);
    }
    public void Subscribe<T>(Action<T> handler) where T : IEvent
    {
        if (!_subs.ContainsKey(typeof(T))) _subs[typeof(T)] = new();
        _subs[typeof(T)].Add(handler);
    }
}
```
- **Mediator**로 ViewModel 간 직접 참조를 제거.

---

### ASP.NET Core MVC — Controller + Command 핸들러 + Repository

#### Domain + Repository

```csharp
public sealed class Order
{
    public Guid Id { get; } = Guid.NewGuid();
    public string CustomerId { get; private set; }
    public decimal Amount { get; private set; }
    public Order(string customerId, decimal amount)
    {
        CustomerId = customerId; Amount = amount;
    }
}

public interface IOrderRepository
{
    Task<Order?> GetAsync(Guid id);
    Task AddAsync(Order order);
}
```

#### UseCase(Command 핸들러)

```csharp
public sealed record PlaceOrder(string CustomerId, decimal Amount);

public sealed class PlaceOrderHandler
{
    private readonly IOrderRepository _repo;
    public PlaceOrderHandler(IOrderRepository repo) => _repo = repo;

    public async Task<Guid> HandleAsync(PlaceOrder cmd)
    {
        // Validation(Strategy) 분리 가능
        var order = new Order(cmd.CustomerId, cmd.Amount);
        await _repo.AddAsync(order);
        return order.Id;
    }
}
```

#### Controller

```csharp
[ApiController]
[Route("api/orders")]
public class OrdersController : ControllerBase
{
    private readonly PlaceOrderHandler _place;
    public OrdersController(PlaceOrderHandler place) => _place = place;

    [HttpPost]
    public async Task<IActionResult> Place([FromBody] PlaceOrder req)
    {
        var id = await _place.HandleAsync(req); // Command
        return CreatedAtAction(nameof(Get), new { id }, new { id });
    }

    [HttpGet("{id:guid}")]
    public async Task<IActionResult> Get([FromServices] IOrderRepository repo, Guid id)
    {
        var order = await repo.GetAsync(id);
        return order is null ? NotFound() : Ok(order);
    }
}
```

포인트:
- Controller는 오케스트레이션(Facade 역할)만, **비즈니스는 Command 핸들러**가 담당.
- **Repository**로 인프라 교체 용이(ORM→Dapper 등).

---

### React + Redux — Flux 변형에서의 패턴 매핑

- 액션 = **Command**
- 리듀서 선택/합성 = **Strategy/Composite**
- 스토어 구독 = **Observer**
- 타임 트래블(히스토리) = **Memento** 응용

```typescript
// actions.ts
export const addTodo = (title: string) => ({ type: "ADD_TODO", payload: { title } } as const);
export type Action = ReturnType<typeof addTodo>;

// reducer.ts
export type State = { todos: string[] };
const init: State = { todos: [] };

export function reducer(s: State = init, a: Action): State {
  switch (a.type) {
    case "ADD_TODO": return { ...s, todos: [...s.todos, a.payload.title] };
    default: return s;
  }
}
```

---

### Android MVP — View 인터페이스 + Presenter(Strategy)

```kotlin
interface LoginView {
    fun showLoading()
    fun hideLoading()
    fun showError(msg: String)
    fun navigateHome()
}

class LoginPresenter(private val auth: AuthService, private val view: LoginView) {
    fun login(id: String, pw: String) {
        view.showLoading()
        auth.signIn(id, pw,
            onSuccess = { view.hideLoading(); view.navigateHome() },
            onFailure = { e -> view.hideLoading(); view.showError(e.message ?: "error") })
    }
}
```

- View는 인터페이스(테스트 대체 용이), Presenter는 **Strategy/Mediator**.

---

## 의존 규칙과 경계 관리

아키텍처 품질은 **의존 방향**이 결정한다. Clean/Hexagonal에서는 “안쪽 정책이 바깥 구현을 모르게” 한다.

간단 모델(불변식):
- 도메인(UseCase/Entity)은 UI/DB/외부서비스를 **모른다**.
- 바깥이 안쪽에 **의존**한다(포트/인터페이스). 어댑터가 그 인터페이스를 **구현**한다.

의존 복잡도 감을 주는 지표(매커비 안정성 지수 예시):
- Afferent(내가 참조받는 수) = \( C_a \), Efferent(내가 참조하는 수) = \( C_e \)
- 불안정도:
  $$ I = \frac{C_e}{C_a + C_e} $$
- 핵심 도메인은 \( I \)가 낮게(안쪽으로 끌림), 어댑터/외부는 \( I \)가 높게 배치.

---

## 패턴 레시피(조합 가이드)

| 문제 | 권장 조합 |
|---|---|
| UI 상태 관리와 명령 바인딩 | MVVM + Observer(INPC) + Command(ICommand) |
| 입력 검증/권한/로깅 파이프라인 | Chain of Responsibility + Strategy |
| 복잡한 워크플로(여러 서브시스템 오케스트레이션) | Facade + Mediator + Command |
| Undo/Redo가 중요한 편집기 | Memento + Command(역연산) + Transaction Batch |
| 다양한 알고리즘 전환 | Strategy + Factory(선택/생성) |
| 모듈 간 이벤트 브로드캐스트 | Mediator(Event Aggregator) + Observer |
| 안정적 DB 경계 | Repository + Unit of Work + Specification |

---

## 테스트 전략

- **MVVM**: ViewModel은 순수 POCO/POD로, 단위 테스트가 용이(명령 CanExecute/실행 결과, 검증 전략).
- **MVC**: Controller는 핸들러/서비스를 **Mock** 주입하여 **입력→출력 매핑**만 검증.
- **Hexagonal**: Port 인터페이스에 대한 어댑터의 계약 테스트(인수테스트) + 도메인 규칙의 순수 단위 테스트.
- **Redux**: 리듀서는 순수 함수 → 스냅샷 테스트, 액션 크리에이터는 효과/부수 테스트를 별도.

체크리스트:
- [ ] 도메인 테스트가 UI/DB 없이 실행되는가
- [ ] 외부 시스템은 포트 인터페이스로 격리되었는가
- [ ] 비즈니스 규칙은 시간/난수 의존을 주입으로 치환했는가(Strategy/Provider)

---

## 성능·동시성·변경내성

- **Observer 과다 통지**: 배치 업데이트/스로틀링/DistinctUntilChanged 적용.
- **Command 폭증**: 매크로/컴포지트 커맨드로 묶고, 로깅 레벨 분리.
- **Memento 메모리**: 용량 제한(capacity), 간헐 스냅샷 + Diff 혼합.
- **Mediator 비대화**: 서브채널 분할, 규칙을 Chain으로 쪼개기.

---

## 마이그레이션 힌트 (MVC → MVVM/Flux)

1) Controller의 화면 상태 로직을 ViewModel/Store로 이동(상태-명령 분리).
2) 서버 렌더 의존을 줄이고, View는 데이터바인딩/구독만 담당.
3) 폼 검증/권한/로깅은 파이프라인(Chain)으로 모듈화.
4) 이벤트 브리지를 Mediator/EventBus로 표준화.

---

## 아키텍처 선택 가이드

| 상황 | 추천 |
|---|---|
| 데스크톱/모바일 양방향 바인딩 UI | MVVM |
| 서버 사이드 웹, 라우팅 중심 | MVC + UseCase(Command) |
| 바인딩 약한 GUI, 테스트가 View 인터페이스 기반 | MVP |
| 단방향 상태흐름, 타임트래블·개발자도구 | Flux/Redux/MVI |
| 외부 시스템 많은 엔터프라이즈 | Hexagonal/Clean + Ports/Adapters |

---

## 결합

```csharp
// DI 등록
services.AddScoped<IOrderRepository, EfOrderRepository>();
services.AddScoped<PlaceOrderHandler>();

// Repository 구현은 어댑터(Infra) 레이어
public sealed class EfOrderRepository : IOrderRepository
{
    private readonly AppDb _db;
    public EfOrderRepository(AppDb db) => _db = db;
    public Task<Order?> GetAsync(Guid id) => _db.Orders.FindAsync(id).AsTask();
    public async Task AddAsync(Order order) { await _db.Orders.AddAsync(order); await _db.SaveChangesAsync(); }
}
```

패턴 시너지:
- 포트(인터페이스) = Repository, 어댑터 = EF 구현, 조립은 DI 컨테이너(Factory/Builder 역할).

---

## 문서화/다이어그램 팁(ASCII 예시)

### MVVM 흐름

```
[View] <==binding/INPC==> [ViewModel] --(Repository/Service)--> [Model/Domain]
           ^                       |
           | (Mediator/EventBus)   v (Command)
        other VMs <-----------> Actions
```

### Hexagonal(포트/어댑터)

```
          ┌───────────── Application Core ─────────────┐
          │   UseCases   ──>  Ports(Interfaces)        │
          │      ^                                      │
          └──────|──────────────────────────────────────┘
                 | implements
   Adapters(In)  v                         Adapters(Out)
[HTTP Controller] --> UseCase          [DB Repo][3rd Party API]
```

---

## 운영·유지보수 체크리스트

- [ ] 아키텍처 계층 간 **순환 의존**이 없는가
- [ ] View와 비즈니스 로직이 분리되어 테스트 가능한가
- [ ] 이벤트/명령/상태 흐름 문서가 최신인가(시퀀스 다이어그램)
- [ ] 트랜잭션 경계를 UseCase 레벨에서 선언적으로 관리하는가
- [ ] 예외/검증/권한이 공통 파이프라인(Chain)으로 일관 처리되는가
- [ ] 모듈 Public API가 최소한인가(정보 은닉)

---

## FAQ

- Q: MVVM에서 비동기 호출 어디에?
  A: ViewModel. `Command` 내부 혹은 `AsyncCommand`로 캡슐화. Repository/Service는 순수 호출.

- Q: MVC Controller가 비대해질 때?
  A: UseCase(Command 핸들러)로 분리. Controller는 DTO 바인딩과 결과 매핑만.

- Q: Flux에서 폼 검증은?
  A: 입력→Action→Reducer로 최소 상태만 반영, 상세 검증은 **Strategy**로 분리하여 미들웨어/Thunk에서 실행.

---

## 결론

- 아키텍처 패턴은 **경계와 의존 규칙**을, 디자인 패턴은 **구체 협력 메커니즘**을 제공한다.
- MVC/MVVM/MVP/Flux/Hexagonal 같은 상위 구조 안에서, **Observer/Command/Strategy/Mediator/Repository/Factory/State/Memento**가 상호작용하며 구현을 완성한다.
- 선택 요령: **플랫폼 UI 특성(바인딩/단방향), 외부 시스템 수, 테스트 전략**을 기준으로 아키텍처를 고르고, 내부는 **디자인 패턴 레시피**로 일관성 있게 채워라.

이 문서의 표·유스케이스·코드 스니펫을 바탕으로, 팀의 표준 템플릿(솔루션 스캐폴딩)과 체크리스트를 마련하면 **변경 내성**과 **테스트 용이성**을 장기적으로 확보할 수 있다.
