---
layout: post
title: TCPIP - TCP 포맷과 데이터 전송
date: 2025-09-04 18:25:23 +0900
category: TCPIP
---
# TCP 메시지 포맷과 데이터 전송

## TCP 메시지 (세그먼트) 형식

TCP 세그먼트는 신뢰성 있는 데이터 전송을 위한 모든 제어 정보를 포함하는 복잡한 구조를 가집니다. 각 세그먼트는 기본적으로 20바이트의 헤더와 선택적 옵션 필드, 그리고 실제 데이터 페이로드로 구성됩니다.

### TCP 헤더 구조

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          출발지 포트 번호      |          목적지 포트 번호      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        시퀀스 번호                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     확인 응답 번호                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  데이터 오프셋 | 예약 |  제어 비트  |         윈도우 크기       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         체크섬                |         긴급 포인터           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    옵션 (가변 길이)           |    패딩        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            데이터                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 헤더 필드 상세 설명

#### 1. 포트 번호 (각 16비트)
- **출발지 포트**: 송신 애플리케이션 식별
- **목적지 포트**: 수신 애플리케이션 식별
- 조합: `<출발지 IP, 출발지 포트, 목적지 IP, 목적지 포트>`는 유일한 연결 식별자

#### 2. 시퀀스 번호 (Sequence Number, 32비트)
- **역할**: 세그먼트 내 첫 번째 데이터 바이트의 위치 식별
- **초기값**: 연결 설정 시 무작위로 선택 (ISN, Initial Sequence Number)
- **증가분**: 전송한 데이터 바이트 수만큼 증가
- **순환**: 2^32-1에서 0으로 순환

```
데이터 전송 예시:
시퀀스 번호: 1000
데이터 크기: 500바이트
다음 시퀀스 번호: 1500
```

#### 3. 확인 응답 번호 (Acknowledgment Number, 32비트)
- **역할**: 다음으로 기대하는 바이트 번호
- **조건**: ACK 플래그가 1일 때만 유효
- **의미**: "이 번호까지의 모든 데이터를 성공적으로 수신했다"

```
수신 확인 예시:
수신한 시퀀스 번호 범위: 1000-1499
확인 응답 번호: 1500
("1500번 바이트부터 보내주세요")
```

#### 4. 데이터 오프셋 (Data Offset, 4비트)
- **역할**: TCP 헤더의 길이를 32비트 워드 단위로 표시
- **최소값**: 5 (20바이트 기본 헤더)
- **최대값**: 15 (60바이트, 옵션 최대 40바이트)

#### 5. 제어 비트 (Control Flags, 6비트)

**각 플래그의 의미:**

| 비트 | 이름 | 설명 |
|------|------|------|
| URG | Urgent | 긴급 포인터 유효 (현재는 거의 사용 안 함) |
| ACK | Acknowledgment | 확인 응답 번호 유효 |
| PSH | Push | 수신 측에 즉시 데이터 전달 요청 |
| RST | Reset | 연결 강제 재설정 (오류 상태) |
| SYN | Synchronize | 연결 설정 요청 (시퀀스 번호 동기화) |
| FIN | Finish | 연결 종료 요청 |

#### 6. 윈도우 크기 (Window Size, 16비트)
- **역할**: 수신 가능한 데이터 양 통지 (흐름 제어)
- **단위**: 바이트 수
- **확장**: 윈도우 스케일 옵션으로 30비트까지 확장 가능
- **동적 변화**: 네트워크 상태에 따라 조정

#### 7. 긴급 포인터 (Urgent Pointer, 16비트)
- **역할**: URG 플래그가 설정될 때 긴급 데이터의 끝 위치 표시
- **계산**: 시퀀스 번호 + 긴급 포인터 = 긴급 데이터 끝

## TCP 체크섬 계산과 TCP "의사 헤더"

### 체크섬의 중요성
TCP는 종단 간(end-to-end) 데이터 무결성을 보장하기 위해 강력한 체크섬 메커니즘을 사용합니다. UDP의 선택적 체크섬과 달리, TCP 체크섬은 필수 사항입니다.

### 의사 헤더 구조
체크섬 계산에는 TCP 헤더와 데이터뿐만 아니라 IP 헤더의 일부 정보도 포함됩니다. 이는 계층 간 무결성 검사를 가능하게 합니다.

```
의사 헤더 구조 (12바이트):
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       출발지 IP 주소                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       목적지 IP 주소                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   예약 (0)    |    프로토콜   |        TCP 세그먼트 길이      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**체크섬 계산 범위:**
```
[ 의사 헤더 ][ TCP 헤더 ][ TCP 데이터 ][ 패딩(필요시) ]
       12      20-60       가변          0-1바이트
```

### 체크섬 계산 알고리즘
1. **의사 헤더 생성**: IP 주소, 프로토콜 번호(6), TCP 길이
2. **16비트 워드 정렬**: 데이터가 홀수 바이트이면 0으로 패딩
3. **1의 보수 합산**: 모든 16비트 워드를 더함
4. **1의 보수 취함**: 합계의 비트를 반전
5. **검증**: 수신 측에서 동일 계산, 결과가 0이어야 함

**계산 예시:**
```
데이터: "Hello" (5바이트)
1. 패딩: "Hello" + 0x00 → 6바이트
2. 분할: 'He'(0x4865), 'll'(0x6C6C), 'o\x00'(0x6F00)
3. 합산: 0x4865 + 0x6C6C + 0x6F00 = 0x123D1
4. 캐리 처리: 0x23D1 + 0x0001 = 0x23D2
5. 보수: ~0x23D2 = 0xDC2D (최종 체크섬)
```

### 체크섬 오류 처리
- 수신 측에서 체크섬 오류 감지 시 세그먼트 자동 폐기
- 송신 측은 확인 응답 미수신으로 재전송 트리거
- 이 메커니즘이 TCP 신뢰성의 기초를 형성

## TCP 최대 세그먼트 크기와 IP 데이터그램 크기 관계

### MSS 개념
최대 세그먼트 크기(Maximum Segment Size, MSS)는 TCP가 한 번에 전송할 수 있는 최대 데이터 양을 의미합니다. 이는 TCP 헤더와 IP 헤더를 제외한 순수 데이터의 크기입니다.

**중요한 구분:**
- **MTU**: 데이터 링크 계층 프레임 크기 (이더넷: 1500바이트)
- **IP 데이터그램 크기**: IP 헤더 + TCP 헤더 + 데이터
- **MSS**: TCP 데이터만 (일반적으로 1460바이트)

### 계산 공식
```
이더넷 환경에서:
MTU = 1500바이트
IP 헤더 = 20바이트 (옵션 없을 때)
TCP 헤더 = 20바이트 (옵션 없을 때)
MSS = MTU - IP 헤더 - TCP 헤더
    = 1500 - 20 - 20 = 1460바이트
```

### MSS 협상 과정
3-way 핸드셰이크 동안 양측이 자신의 MSS를 알립니다:

```
클라이언트 → 서버: SYN (MSS=1460)
클라이언트 ← 서버: SYN-ACK (MSS=1452) [PPPoE 고려]
클라이언트 → 서버: ACK (MSS=min(1460,1452)=1452)
```

### 경로 MTU 발견과의 연동
TCP는 Path MTU Discovery를 통해 실제 경로의 MTU를 탐색합니다:

```
과정:
1. DF(Don't Fragment) 비트 설정하고 큰 패킷 전송
2. 중간 라우터가 ICMP "패킷 너무 큼" 메시지 반환
3. MSS 조정 후 재전송
4. 최적의 MSS 결정
```

### 다양한 네트워크 환경의 MSS

| 네트워크 유형 | MTU | IP 헤더 | TCP 헤더 | MSS |
|---------------|-----|---------|----------|-----|
| 이더넷 | 1500 | 20 | 20 | 1460 |
| PPPoE | 1492 | 20 | 20 | 1452 |
| 토큰링 | 4464 | 20 | 20 | 4424 |
| 인터넷 기본 | 576 | 20 | 20 | 536 |
| IPv6 기본 | 1280 | 40 | 20 | 1220 |

**실제 고려사항:**
- TCP 옵션 사용 시 MSS 감소
- VPN 터널링 시 추가 헤더로 MSS 더 감소
- Jumbo Frame(9000바이트) 지원 환경에서 큰 MSS 가능

## TCP 슬라이딩 윈도우 데이터 전송과 확인 응답 메커니즘

### 슬라이딩 윈도우 기본 개념
TCP는 효율적인 전송을 위해 슬라이딩 윈도우 프로토콜을 사용합니다. 이는 한 번에 여러 세그먼트를 전송할 수 있게 하면서도 수신 측의 처리 능력을 고려합니다.

```
윈도우 시각화:
[이미 전송][전송 가능][전송 불가]
     ↓
송신 윈도우: [1000............2000] (크기 1000)
전송된 데이터: 1000-1500
확인된 데이터: 1000-1300 (ACK 1301)
전송 가능: 1501-2000
```

### 윈도우 관리의 세 가지 측면

#### 1. 흐름 제어 (Flow Control)
- 수신 측의 버퍼 공간 보호
- 윈도우 크기 필드로 현재 수신 가능량 통지
- 제로 윈도우: 버퍼 가득 차면 윈도우 크기 0 통지

#### 2. 오류 제어 (Error Control)
- 누적 확인 응답: "N번까지 모두 받았다"
- 선택적 재전송: SACK 옵션으로 특정 세그먼트만 재전송
- 빠른 재전송: 3개의 중복 ACK 수신 시 즉시 재전송

#### 3. 혼잡 제어 (Congestion Control)
- 네트워크 정체 방지
- 슬로 스타트, 혼잡 회피, 빠른 회복 알고리즘
- 윈도우 크기 = min(수신 윈도우, 혼잡 윈도우)

### 확인 응답 전략

#### 1. 누적 확인 응답
```
수신한 세그먼트: 1000-1499, 1500-1999, 2000-2499
확인 응답: ACK 2500 (모두 수신 완료)
```

#### 2. 지연된 확인 응답
- 효율성을 위해 여러 세그먼트에 대해 하나의 ACK로 응답
- 일반적으로 200ms 이내로 지연
- 자신의 데이터가 있을 때는 함께 전송

#### 3. 선택적 확인 응답 (SACK)
```
수신: 1000-1499, 2000-2499 (중간 손실)
SACK: ACK 1500, SACK 블록 2000-2500
의미: "1500번이 필요하고, 2000-2500은 이미 받았다"
```

### 슬라이딩 윈도우 동작 예시

```
초기 상태:
송신 측: 윈도우 [1000-2000], cwnd=1000, ssthresh=65535
수신 측: 버퍼 공간 1000바이트

단계별 진행:
1. 세그먼트 1000-1460 전송 (460바이트)
2. 세그먼트 1461-1920 전송 (460바이트) 
3. ACK 1461 수신 → 윈도우 [1461-2461]로 슬라이드
4. 세그먼트 1921-2380 전송
5. ACK 1921 수신 → 윈도우 [1921-2921]
... (계속)
```

### 빠른 재전송과 빠른 회복

```
시나리오: 세그먼트 1000-1460 손실
1. 수신 측: ACK 1000 반복 전송 (중복 ACK)
2. 송신 측: 3개 중복 ACK(1000) 수신
3. 빠른 재전송: 세그먼트 1000-1460 즉시 재전송
4. 빠른 회복: cwnd = ssthresh + 3*MSS
5. ACK 2000 수신 시 cwnd = ssthresh로 복귀
```

## TCP 즉시 데이터 전송: "푸시" 기능

### PSH 플래그의 역할
PSH(Push) 플래그는 데이터 버퍼링을 최소화하고 즉시 응용 프로그램에 데이터를 전달하도록 요청합니다.

**일반적 데이터 흐름 vs PSH 사용 시:**
```
일반적:
송신 버퍼 → [세그먼트화] → 네트워크 → 수신 버퍼 → 애플리케이션
(버퍼 가득 차거나 타임아웃 시 전송)

PSH 사용:
송신 버퍼 → [PSH 플래그 설정] → 즉시 전송 → 즉시 애플리케이션 전달
```

### PSH의 실제 동작

#### 송신 측에서:
- PSH 플래그가 설정된 세그먼트는 버퍼링 없이 즉시 전송
- 보통 마지막 데이터 세그먼트에 PSH 설정
- 애플리케이션이 `socket.write()` 대신 `socket.send()` 사용 시 자동 설정

#### 수신 측에서:
- PSH 플래그가 설정된 세그먼트는 버퍼 대기 없이 즉시 애플리케이션에 전달
- 지연된 확인 응답 규칙 무시하고 즉시 ACK 전송

### 사용 사례

#### 1. 대화형 애플리케이션
```
텔넷/Telnet:
사용자 키 입력 → 즉시 전송 필요 → PSH 사용
서버 응답 → 즉시 표시 필요 → PSH 사용
```

#### 2. 요청-응답 프로토콜
```
HTTP 요청:
GET /index.html HTTP/1.1
Host: example.com
(빈 줄) → PSH 플래그로 즉시 전송
```

#### 3. 실시간 데이터 스트림
```
금융 시세:
가격 변동 데이터 → 지연 없이 즉시 전달 → PSH 사용
```

### 현대 시스템에서의 PSH 처리
- 많은 구현에서 PSH를 권고 사항으로 처리
- 성능 최적화를 위해 버퍼링 우선시
- 애플리케이션 개발자가 직접 제어 어려움
- Nagle 알고리즘과의 상호작용 복잡

## TCP 우선순위 데이터 전송: "긴급" 기능

### URG 플래그와 긴급 포인터
URG(Urgent) 플래그는 특정 데이터를 일반 데이터 스트림보다 우선적으로 처리하도록 표시합니다. 긴급 포인터는 이 우선 데이터의 범위를 정의합니다.

**긴급 데이터 위치:**
```
시퀀스 공간: [일반 데이터][긴급 데이터][일반 데이터]
             ↑           ↑           ↑
             시퀀스      긴급        긴급
             번호        시작        끝
                        (시퀀스 번호 + 긴급 포인터)
```

### 긴급 모드의 동작

#### 송신 측:
1. 애플리케이션이 긴급 데이터 지정 (예: `send(..., MSG_OOB)`)
2. TCP가 URG 플래그 설정 및 긴급 포인터 계산
3. 긴급 데이터를 가능한 한 빨리 전송

#### 수신 측:
1. URG 플래그 감지 시 긴급 데이터 즉시 처리
2. 소켓 API를 통해 별도로 접근 가능 (`recv(..., MSG_OOB)`)
3. 일반 데이터 스트림과 별도로 처리

### 역사적 사용과 현대적 의미

#### 원래 용도: 외부 대역 신호
```
텔넷에서:
Ctrl+C (중단 신호) → 긴급 데이터로 전송
수신 측에서 즉시 처리하여 세션 중단
```

#### 현실적 제한:
1. **구현 불일치**: OS별로 긴급 데이터 처리 방식 상이
2. **단일 바이트 제한**: 대부분 구현에서 1바이트만 긴급 데이터로 인식
3. **보안 우려**: 우선순위 기능 악용 가능성
4. **대체 기술**: 별도 채널이나 연결 사용이 더 일반적

### 긴급 데이터 vs 외부 대역 데이터

**흔한 오해:**
- 긴급 데이터 = 외부 대역 데이터 (X)
- URG 플래그 ≠ 외부 대역 전송 보장 (O)

**실제:**
- 긴급 데이터는 일반 데이터 스트림 내에 존재
- 단지 처리 우선순위가 표시될 뿐
- 네트워크에서의 실제 전송 우선순위는 QoS에서 처리

### 현대적 대안

#### 1. 별도 연결 사용
```
제어 채널: 신호 전용 TCP/UDP 연결
데이터 채널: 실제 데이터 전송
```

#### 2. 애플리케이션 계층 프로토콜
```
WebSocket: 제어 프레임과 데이터 프레임 구분
HTTP/2: 스트림 우선순위 설정
```

#### 3. DSCP(Differentiated Services Code Point)
```
IP 헤더의 서비스 유형 필드로 트래픽 분류
라우터 수준에서의 실제 우선순위 처리
```

## 결론

TCP의 메시지 포맷과 데이터 전송 메커니즘은 40년이 넘는 시간 동안 인터넷의 신뢰성 있는 통신을 뒷받침해 온 공학적 기적입니다. 단순한 데이터 전송을 넘어, TCP는 흐름 제어, 오류 제어, 혼잡 제어를 통합한 종합적인 전송 솔루션을 제공합니다.

TCP 헤더의 각 필드는 철저히 계산된 설계의 결과물입니다. 시퀀스 번호와 확인 응답 번호의 조합은 데이터 순서와 무결성을 보장하고, 체크섬 메커니즘은 종단 간 데이터 정확성을 검증합니다. MSS 협상은 다양한 네트워크 환경에서 최적의 성능을 이끌어내며, 슬라이딩 윈도우는 효율성과 공정성을 동시에 추구합니다.

PSH와 URG 기능은 TCP의 유연성을 보여주지만, 현대 네트워크에서 이들의 역할은 재평가되고 있습니다. PSH는 성능 최적화와의 충돌로 인해 점차 구현 의존적 기능이 되었고, URG는 보안 문제와 구현 불일치로 인해 거의 사용되지 않습니다. 이는 프로토콜 설계에서 이상과 현실의 간극을 보여주는 교훈적인 사례입니다.

TCP의 진정한 가치는 그 복잡성 속에 숨겨진 단순함에 있습니다. 수많은 매개변수와 알고리즘이 조화를 이루어, 애플리케이션 개발자에게는 단순한 바이트 스트림 인터페이스를 제공하면서도, 네트워크 수준에서는 정교한 제어를 가능하게 합니다. 이러한 추상화 레벨의 분리는 TCP가 수십 년간 변함없이 인터넷의 핵심을 차지할 수 있게 한 비결입니다.

현대 네트워크 환경에서 TCP는 계속해서 진화하고 있습니다. TCP Fast Open, Proportional Rate Reduction, Bottleneck Bandwidth and RRT와 같은 새로운 확장들이 기존 TCP의 한계를 극복하기 위해 개발되고 있습니다. 그러나 이러한 모든 발전의 기초는 여전히 고전적인 TCP 메시지 포맷과 전송 메커니즘 위에 구축되어 있습니다.

네트워크 엔지니어에게 TCP의 내부 동작을 이해하는 것은 단순한 학문적 호기심이 아닌 필수적 역량입니다. 성능 문제 진단, 보안 취약점 분석, 애플리케이션 최적화 모두 TCP의 미세한 동작 원리에 대한 이해를 요구합니다. TCP의 견고한 설계는 우리에게 중요한 교훈을 전합니다: 진정한 탁월함은 복잡성을 숨기고 단순함을 제공하는 데 있습니다.