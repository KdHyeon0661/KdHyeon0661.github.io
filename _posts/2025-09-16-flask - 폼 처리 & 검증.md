---
layout: post
title: flask - 폼 처리 & 검증
date: 2025-09-16 15:25:23 +0900
category: flask
---
# 폼 처리 & 검증

## CSRF 기본기 — 왜 필요한가?

**CSRF(Cross-Site Request Forgery)** 는 사용자가 의도하지 않았음에도 브라우저가 **자동으로 쿠키와 자격증명**을 첨부하는 특성을 악용하여, 다른 사이트의 **상태를 변경하는 요청**(POST, PUT, PATCH, DELETE 등)을 **타 도메인에서 유도**하는 공격입니다.

핵심 포인트:

- **조건**: 피해 사이트가 **쿠키(세션 쿠키)** 를 인증에 사용하고, 브라우저가 이를 자동으로 전송합니다.
- **대응**:
  1. **CSRF 토큰**(폼/헤더에 임의 난수, 서버 측 검증) — 가장 표준적인 방법
  2. **SameSite 쿠키**(Lax/Strict) — 1차 방어막, 하지만 SSO/외부 임베드 시 예외가 많음
  3. **쿠키 대신 토큰(Authorization: Bearer)** — SPA/API 패턴, CSRF 원천 차단(쿠키 미사용)
  4. **Referrer/Origin 검사** — 보조 수단, 프록시/앱 구성이 복잡하면 누락 가능

Flask-WTF는 **(1) CSRF 토큰**을 **폼마다 자동 삽입 및 검증**하는 방식을 제공합니다.

---

## Flask-WTF/WTForms 톺아보기

### 설치 & 기본 설정

```bash
pip install flask-wtf wtforms email-validator
```

```python
# app/config.py

import os

class BaseConfig:
    SECRET_KEY = os.getenv("SECRET_KEY", "dev-secret-key")  # CSRF 서명에 사용
    WTF_CSRF_TIME_LIMIT = 3600        # 토큰 만료(초), None이면 무기한
    WTF_CSRF_ENABLED = True           # 테스트에서만 False로
```

```python
# app/__init__.py

from flask import Flask
from flask_wtf.csrf import CSRFProtect

csrf = CSRFProtect()

def create_app(config_name=None):
    app = Flask(__name__)
    # ... app.config 로딩 ...
    csrf.init_app(app)  # 전역 CSRF 보호(Flask-WTF)
    return app
```

전역 `CSRFProtect` 를 활성화하면 **블루프린트/뷰 단위 제외(exempt)** 를 통해 API 일부만 비활성화할 수 있습니다.

### WTForms 기본 폼

```python
# app/forms/auth.py

from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField
from wtforms.validators import DataRequired, Length, Email

class LoginForm(FlaskForm):
    email = StringField("이메일", validators=[DataRequired(), Email(), Length(max=120)])
    password = PasswordField("비밀번호", validators=[DataRequired(), Length(min=8, max=72)])
    remember = BooleanField("로그인 상태 유지")
```

렌더링:

{% raw %}
```html
<!-- templates/auth/login.html -->
{% extends "base.html" %}
{% block title %}로그인{% endblock %}
{% block content %}
  <h1>로그인</h1>
  <form method="post" action="{{ url_for('auth.login') }}">
    {{ form.csrf_token }}  {# CSRF 토큰 필수! #}

    <div>
      <label>{{ form.email.label }} {{ form.email(size=32) }}</label>
      {% if form.email.errors %}<p class="err">{{ form.email.errors|join(', ') }}</p>{% endif %}
    </div>

    <div>
      <label>{{ form.password.label }} {{ form.password() }}</label>
      {% if form.password.errors %}<p class="err">{{ form.password.errors|join(', ') }}</p>{% endif %}
    </div>

    <div>
      <label>{{ form.remember() }} {{ form.remember.label }}</label>
    </div>

    <button type="submit">로그인</button>
  </form>
{% endblock %}
```
{% endraw %}

뷰:

```python
# app/blueprints/auth/views.py

from flask import Blueprint, render_template, redirect, url_for, flash
from app.forms.auth import LoginForm

auth_bp = Blueprint("auth", __name__)

@auth_bp.route("/login", methods=["GET", "POST"])
def login():
    form = LoginForm()
    if form.validate_on_submit():   # POST + CSRF + 필드 검증
        # 사용자 인증 로직 ...
        flash("로그인 성공", "success")
        return redirect(url_for("site.home"))  # PRG 패턴
    return render_template("auth/login.html", form=form), 200
```

**PRG(Post-Redirect-Get) 패턴**: POST 처리 후 **redirect**를 통해 새로고침 시 중복 제출을 방지하고 UX 일관성을 유지합니다.

### 메시지 & i18n

- `flash("메시지", "success")` 로 플래시 메시지를 설정하고 레이아웃에서 렌더링합니다.
- `email-validator` 를 설치하면 Email 검증 품질이 향상됩니다.
- i18n(Flask-Babel) 적용 시 필드와 검증 메시지를 번역할 수 있습니다.

---

## 커스텀 검증(필드/폼 레벨)

### 필드 레벨 커스텀

```python
from wtforms.validators import ValidationError

def NotDisposableEmail(form, field):
    domain = field.data.split("@")[-1].lower()
    if domain in {"tempmail.com", "mailinator.com"}:
        raise ValidationError("일회용 이메일은 사용할 수 없습니다.")
```

```python
class RegisterForm(FlaskForm):
    email = StringField("이메일", validators=[DataRequired(), Email(), NotDisposableEmail])
```

### 폼 레벨 교차 검증

```python
class ChangePasswordForm(FlaskForm):
    old = PasswordField("현재 비밀번호", validators=[DataRequired()])
    new = PasswordField("새 비밀번호", validators=[DataRequired(), Length(min=12)])
    confirm = PasswordField("새 비밀번호 확인", validators=[DataRequired()])

    def validate(self, extra_validators=None):
        ok = super().validate(extra_validators)
        if not ok:
            return False
        if self.new.data == self.old.data:
            self.new.errors.append("새 비밀번호가 이전 비밀번호와 같습니다.")
            return False
        if self.new.data != self.confirm.data:
            self.confirm.errors.append("비밀번호 확인이 일치하지 않습니다.")
            return False
        return True
```

---

## FieldList/FormField — 동적/반복 입력

```python
from wtforms import FieldList, FormField, Form, StringField
from wtforms.validators import DataRequired, Length

class TagForm(Form):
    name = StringField("태그", validators=[DataRequired(), Length(max=20)])

class PostForm(FlaskForm):
    title = StringField("제목", validators=[DataRequired()])
    tags = FieldList(FormField(TagForm), min_entries=1, max_entries=5)
```

템플릿:

{% raw %}
```html
{% for subform in form.tags %}
  <div>{{ subform.name.label }} {{ subform.name() }}</div>
  {% if subform.name.errors %}<p class="err">{{ subform.name.errors|join(', ') }}</p>{% endif %}
{% endfor %}
<button type="button" id="add-tag">태그 추가</button>
<script>
  // JS로 FieldList 항목 추가(서버는 max_entries로 안전장치)
</script>
```
{% endraw %}

---

## CSRF 심화

### API(JSON)와 CSRF

- **쿠키 세션 + JSON API**: 브라우저가 자동으로 쿠키를 첨부하므로 **CSRF 대상**이 됩니다.
  - 해결책: **헤더에 CSRF 토큰**(예: `X-CSRFToken`)을 요구하고 서버에서 검증합니다.
- **Bearer 토큰(Authorization) 기반 API**: **CSRF 대상이 아닙니다**(쿠키 자동 전송을 사용하지 않기 때문).
  - 대신 **XSS/토큰 탈취** 방어가 중요합니다(CSP/SameSite/Lax + 저장 위치 주의).

Flask-WTF는 폼 기반에 특화되어 있지만, **전역 CSRFProtect** 는 **헤더 방식**도 지원합니다.

```python
# CSRF 헤더 이름: X-CSRFToken 또는 X-CSRF-Token 등
# fetch('/api', {method:'POST', headers:{'X-CSRFToken': token}, credentials: 'include'})
```

### 토큰 렌더링 & Ajax

템플릿에서 전역 토큰을 주입:

{% raw %}
```html
<meta name="csrf-token" content="{{ csrf_token() }}">
<script>
  const CSRF = document.querySelector('meta[name="csrf-token"]').content;
  async function postJSON(url, body) {
    return fetch(url, {
      method: 'POST',
      headers: {'Content-Type':'application/json', 'X-CSRFToken': CSRF},
      credentials: 'include'
    });
  }
</script>
```
{% endraw %}

### 제외 처리

파일 업로드 외부 콜백 등 **검증이 불가능한 엔드포인트**는 제외할 수 있습니다:

```python
from app import csrf

@csrf.exempt
@auth_bp.post("/webhook/payment")
def payment_webhook():
    # 서명 헤더로 별도 검증
    ...
```

제외 처리는 최소한으로 사용하고, 가능하다면 **서명/시크릿 검증**을 추가하는 것이 좋습니다.

---

## 파일 업로드 — 보안 & 검증

### 폼/템플릿/뷰 기본

```python
# app/forms/assets.py

from flask_wtf import FlaskForm
from wtforms import FileField, StringField
from wtforms.validators import DataRequired, Length

class UploadForm(FlaskForm):
    title = StringField("제목", validators=[DataRequired(), Length(max=120)])
    file = FileField("파일", validators=[DataRequired()])
```

{% raw %}
```html
<!-- templates/assets/upload.html -->
{% extends "base.html" %}
{% block content %}
  <h1>업로드</h1>
  <form method="post" enctype="multipart/form-data">
    {{ form.csrf_token }}
    <div>
      {{ form.title.label }} {{ form.title() }}
      {% if form.title.errors %}<p class="err">{{ form.title.errors|join(', ') }}</p>{% endif %}
    </div>
    <div>
      {{ form.file.label }} {{ form.file() }}
      {% if form.file.errors %}<p class="err">{{ form.file.errors|join(', ') }}</p>{% endif %}
    </div>
    <button type="submit">업로드</button>
  </form>
{% endblock %}
```
{% endraw %}

```python
# app/blueprints/assets/views.py

from flask import Blueprint, render_template, redirect, url_for, flash, current_app, abort
from werkzeug.utils import secure_filename
from pathlib import Path
from app.forms.assets import UploadForm

assets_bp = Blueprint("assets", __name__)
UPLOAD_DIR = Path("/var/app/uploads")

ALLOWED_EXTS = {"jpg","jpeg","png","gif","pdf"}  # 화이트리스트
MAX_FILE_MB = 16

@assets_bp.route("/upload", methods=["GET","POST"])
def upload():
    form = UploadForm()
    if form.validate_on_submit():
        f = form.file.data           # werkzeug.datastructures.FileStorage
        if not f or f.filename == "":
            form.file.errors.append("파일이 없습니다.")
            return render_template("assets/upload.html", form=form), 400

        # 1) 파일명 정제
        filename = secure_filename(f.filename)
        if "." not in filename:
            form.file.errors.append("확장자가 필요합니다.")
            return render_template("assets/upload.html", form=form), 400

        # 2) 확장자 화이트리스트
        ext = filename.rsplit(".",1)[-1].lower()
        if ext not in ALLOWED_EXTS:
            form.file.errors.append("허용되지 않는 파일 형식입니다.")
            return render_template("assets/upload.html", form=form), 400

        # 3) 요청 크기 제한(Flask 전역 옵션 + 추가 검사)
        # Flask 전역: app.config["MAX_CONTENT_LENGTH"] = 16*1024*1024
        f.stream.seek(0,2)  # EOF
        size = f.stream.tell()
        f.stream.seek(0)
        if size > MAX_FILE_MB * 1024 * 1024:
            form.file.errors.append(f"파일이 {MAX_FILE_MB}MB를 초과합니다.")
            return render_template("assets/upload.html", form=form), 413

        # 4) MIME 스니핑(선택) — python-magic 등으로 콘텐츠 기반 판별
        # import magic; mime = magic.from_buffer(f.read(2048), mime=True); f.stream.seek(0)
        # if not mime.startswith(("image/","application/pdf")): ...

        # 5) 저장 디렉터리 준비 & 충돌 회피
        UPLOAD_DIR.mkdir(parents=True, exist_ok=True)
        dest = UPLOAD_DIR / filename
        if dest.exists():
            # 파일명 충돌 시 유니크 이름
            from uuid import uuid4
            dest = UPLOAD_DIR / f"{dest.stem}_{uuid4().hex[:8]}.{ext}"

        # 6) 저장
        f.save(dest)

        # 7) 바이러스 스캔/후처리 훅(비동기 권장)
        # enqueue_scan(dest)

        flash("업로드 완료", "success")
        return redirect(url_for("assets.upload"))
    return render_template("assets/upload.html", form=form)
```

**전역 요청 크기 제한**:

```python
# app/config.py

class BaseConfig:
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB 초과 시 413
```

### 보안 체크리스트

- **secure_filename** 으로 경로 탐색(../) 차단
- **확장자 화이트리스트** + (선택) **MIME 스니핑**
- **요청 크기 제한**(MAX_CONTENT_LENGTH) + 애플리케이션 레벨 이중 체크
- **격리 저장소**: 실행/서빙 디렉터리와 분리(예: `/var/app/uploads`)
- **악성 콘텐츠 스캔**: ClamAV/상용 솔루션(비동기 큐)
- **이미지 처리 안전성**: Pillow 등 디코더 취약점 패치(최신화)
- **다운로드 시 Content-Disposition** 강제, inline 렌더링 주의
- **직접 서빙 금지**: Nginx/X-Accel-Redirect 로 다운로드 프록시(권한 체크 이후만 접근)
- **보존/삭제 정책**: 만료/소유자 검증/감사 로그

### Nginx와의 연계(고성능 다운로드)

업로드 저장은 애플리케이션이 처리하고, **다운로드는 Nginx** 가 담당하도록 구성합니다:

```python
# 권한 체크 후 내부 경로로 위임

from flask import make_response

@assets_bp.get("/download/<path:name>")
def download(name):
    # 권한/소유자 검증...
    resp = make_response("", 200)
    resp.headers["X-Accel-Redirect"] = f"/protected/{name}"
    resp.headers["Content-Disposition"] = f'attachment; filename="{name}"'
    resp.headers["Content-Type"] = "application/octet-stream"
    return resp
```

Nginx 설정:

```
location /protected/ {
  internal;
  alias /var/app/uploads/;
}
```

---

## 서버-사이드 검증 패턴

### Flash 메시지와 앵커 패턴

- POST → 검증 성공 → **redirect** 로 성공 페이지/상세 페이지로 이동
- 검증 실패 → **원래 폼 렌더링** + **오류 메시지** 표시
- 새로고침 중복 방지, URL 공유 가능, 히스토리 일관성 유지

### 서비스 계층 분리

컨트롤러(뷰)는 **입출력**에 집중하고, **도메인 로직**은 **서비스/유스케이스**로 분리하여 테스트 용이성을 높입니다.

```python
# app/services/auth.py

from dataclasses import dataclass

@dataclass
class LoginResult:
    ok: bool
    user_id: int | None
    reason: str | None = None

def login_user(email: str, password: str) -> LoginResult:
    # DB 조회/암호 검증 ...
    if email == "admin@example.com" and password == "P@ssword123!":
        return LoginResult(ok=True, user_id=1)
    return LoginResult(ok=False, user_id=None, reason="자격 증명이 올바르지 않습니다.")
```

```python
# app/blueprints/auth/views.py (발췌)

from app.services.auth import login_user

@auth_bp.route("/login", methods=["GET","POST"])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        r = login_user(form.email.data, form.password.data)
        if r.ok:
            # 세션 세팅...
            flash("로그인 성공","success")
            return redirect(url_for("site.home"))
        form.password.errors.append(r.reason or "로그인 실패")
    return render_template("auth/login.html", form=form), 200
```

### 스키마 기반 검증(REST API 공용)

WTForms는 HTML 폼에 특화되어 있습니다. **REST JSON** 은 **Marshmallow/Pydantic** 등으로 스키마 검증을 수행합니다:

```python
# app/schemas/item.py

from marshmallow import Schema, fields, validate

class ItemCreate(Schema):
    name = fields.String(required=True, validate=validate.Length(max=100))
    price = fields.Float(required=True)
```

```python
# app/blueprints/api/items.py

from flask import request, jsonify
from app.schemas.item import ItemCreate

@api_bp.post("/items")
def create_item():
    data = request.get_json(silent=False)
    errors = ItemCreate().validate(data)
    if errors:
        return {"error":"validation","fields":errors}, 422
    # 서비스 호출/저장 ...
    return jsonify(id=123, **data), 201
```

**장점**: **웹 폼**(WTForms)과 **API**(Marshmallow/Pydantic) 를 **역할 분리**할 수 있습니다. 도메인 규칙은 서비스 계층으로 일원화합니다.

### 에러 응답 규약(예: JSON)

```json
{
  "error": "validation",
  "fields": {
    "email": ["올바른 이메일 형식이 아닙니다."],
    "password": ["최소 12자를 입력하세요."]
  }
}
```

- **일관된 스키마**로 프런트엔드/모바일 클라이언트가 처리하기 용이합니다.
- 400/422 등 상태 코드를 명확하게 구분합니다.
- 로깅/관측 시 **필드별 오류 건수**를 카운팅할 수 있습니다.

---

## 템플릿 측 렌더링 패턴(매크로)

### 필드 렌더 매크로

{% raw %}
```html
<!-- templates/macros/forms.html -->
{% macro render_field(field) -%}
  <div class="field {{ 'invalid' if field.errors }}">
    <label for="{{ field.id }}">{{ field.label.text }}</label>
    {{ field(**kwargs) }}
    {% if field.description %}<small>{{ field.description }}</small>{% endif %}
    {% if field.errors %}<p class="err">{{ field.errors|join(', ') }}</p>{% endif %}
  </div>
{%- endmacro %}
```
{% endraw %}

사용 예시:

{% raw %}
```html
{% import "macros/forms.html" as F %}
<form method="post">
  {{ form.csrf_token }}
  {{ F.render_field(form.email, class="input", placeholder="you@example.com") }}
  {{ F.render_field(form.password, class="input") }}
  <button type="submit">로그인</button>
</form>
```
{% endraw %}

---

## 테스트 전략(pytest)

### CSRF 비활성(단위 테스트)

```python
# tests/conftest.py

import pytest
from app import create_app

@pytest.fixture()
def app():
    app = create_app("testing")
    app.config.update(WTF_CSRF_ENABLED=False)  # 폼 단위 테스트에서 편의
    yield app

@pytest.fixture()
def client(app):
    return app.test_client()
```

### 폼 검증/PRG 테스트

```python
def test_login_form_valid(client):
    r = client.post("/login", data={"email":"a@b.com","password":"P@ssword123!"}, follow_redirects=False)
    assert r.status_code in (302, 303)  # PRG

def test_upload_validation(client, tmp_path, monkeypatch):
    # 1바이트짜리 가짜 파일
    import io
    data = {
      "title": "x",
      "file": (io.BytesIO(b"a"), "x.txt"),  # 확장자 화이트리스트에 없다고 가정
    }
    r = client.post("/upload", data=data, content_type="multipart/form-data")
    assert r.status_code in (200, 400)
    assert b"\xed\x97\x88\xec\x9a\xa9\xeb\x90\x98\xec\xa7\x80 \xec\x95\x8a" in r.data  # "허용되지 않" 바이트 존재
```

통합 테스트에서는 **CSRF 활성화** + **토큰 추출** 후 제출하는 경로를 검토하는 것이 좋습니다(폼 렌더→토큰 파싱→POST).

---

## 흔한 안티패턴

- **SameSite만 믿고 CSRF 토큰 미도입**: SSO/서드파티 상황에서 실패할 수 있습니다.
- **파일명을 그대로 저장**: 경로 traversal/덮어쓰기/스크립트 실행 위험이 있습니다.
- **확장자 블랙리스트**: 우회가 쉬우므로 **화이트리스트**가 기본이어야 합니다.
- **쿠키+JSON API에 CSRF 없음**: 브라우저가 자동 쿠키 첨부로 고위험 상태가 됩니다.
- **검증 실패 시 200+빈 페이지**: UX/테스트 모두 불편하므로 에러 메시지 렌더/422 사용이 필요합니다.
- **업로드 디렉터리에서 직접 서빙**: 권한 우회/임의 실행 위험이 있으므로 프록시 내부 경로로 분리해야 합니다.

---

## 결론

이번 섹션에서는 Flask 애플리케이션에서 폼 처리와 검증을 효과적으로 구현하는 방법을 다루었습니다. CSRF의 원리와 Flask-WTF를 통한 실전 적용 방법부터 시작하여, WTForms를 활용한 다양한 폼 처리 기법과 커스텀 검증 로직 구현까지 살펴보았습니다.

파일 업로드 보안은 특히 중요한 주제로, 파일명 정제, 확장자 화이트리스트, 크기 제한, MIME 검증, 악성 콘텐츠 스캔 등 다층적인 보안 접근법을 다루었습니다. Nginx와의 연계를 통한 효율적인 파일 서빙 전략도 소개했습니다.

서버-사이드 검증 패턴에서는 PRG 패턴, 서비스 계층 분리, 스키마 기반 검증 등 현대적인 웹 애플리케이션 아키텍처를 적용하는 방법을 다루었습니다. 특히 웹 폼과 REST API의 검증 방식을 역할에 맞게 분리하는 접근법은 유연하고 확장 가능한 시스템 설계에 도움이 됩니다.

템플릿 매크로를 통한 재사용 가능한 폼 렌더링 컴포넌트와 pytest를 활용한 테스트 전략은 실제 프로젝트에서 생산성을 높이는 데 기여합니다. 보안과 사용성 사이의 균형을 맞추면서도 개발 효율성을 유지하는 것이 폼 처리와 검증 시스템 설계의 핵심이라고 할 수 있습니다. 이러한 패턴들을 적절히 조합하여 비즈니스 요구사항에 맞는 견고한 폼 처리 시스템을 구축할 수 있을 것입니다.