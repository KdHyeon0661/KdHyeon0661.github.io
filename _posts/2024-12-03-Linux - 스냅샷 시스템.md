---
layout: post
title: Linux - 스냅샷 시스템
date: 2024-12-03 19:20:23 +0900
category: Linux
---
# 스냅샷 시스템(Btrfs, ZFS)과 공간 절약 전략

## 1. 스냅샷의 본질: Copy-on-Write(CoW)와 참조

스냅샷은 특정 시점의 파일 시스템 상태를 보존하는 기술로, Copy-on-Write(CoW) 메커니즘을 기반으로 합니다. 스냅샷 생성 시점에는 실제 데이터 블록을 복사하는 대신 **메타데이터(블록 맵)만 기록**하여 블록을 공유합니다. 데이터 변경이 발생하면 **원본 블록을 보존**한 채 **새 블록에 쓰기**를 수행합니다.

### 핵심 개념

- 스냅샷 생성 시: **메타데이터만 복제** → 즉시 완료되고 비용이 낮음
- 이후 변경: **변경된 블록만** 새로 할당 → 스냅샷과 현재 버전이 공간을 공유
- 스냅샷 삭제: 해당 스냅샷만 참조하던 블록이 있으면 **그 블록만 회수**

### 간단한 비용 모델

스냅샷 생성 후 총 추가 사용 공간(S), 변경 비율(p), 총 데이터 크기(D)의 관계:
$$
S \approx p \cdot D
$$
스냅샷이 많을수록 **중복 참조 구간**이 늘어나며, 오래된 스냅샷 삭제 시 회수되는 공간은 **유일하게 참조되는 블록**의 합에 가깝습니다.

---

## 2. Btrfs — 서브볼륨, 스냅샷, CoW 운영

Btrfs는 **서브볼륨(subvolume)** 단위로 스냅샷을 생성합니다. 루트에 여러 서브볼륨을 두고 마운트 단위로 관리하는 레이아웃이 권장됩니다.

### 레이아웃 설계(예시)

```text
/mnt/btrfs
  ├─ @           (루트용 서브볼륨, / 로 마운트)
  ├─ @home       (/home)
  ├─ @var        (/var)       ← 잦은 쓰기 분리, 필요 시 nocow/옵션 조정
  └─ @snapshots  (스냅샷 보관용 마운트 포인트)
```

### 서브볼륨/스냅샷 기초 명령

```bash
# 파티션 마운트 후 서브볼륨 생성
sudo mount /dev/sdX1 /mnt
sudo btrfs subvolume create /mnt/@
sudo btrfs subvolume create /mnt/@home
sudo btrfs subvolume create /mnt/@var

# 읽기-쓰기 스냅샷
sudo btrfs subvolume snapshot /mnt/@ /mnt/@_snap_$(date +%F)

# 읽기-전용 스냅샷(백업/전송 기점용으로 권장)
sudo btrfs subvolume snapshot -r /mnt/@ /mnt/@_ro_$(date +%F)

# 나열/삭제/정보
sudo btrfs subvolume list -o /mnt
sudo btrfs subvolume delete /mnt/@_ro_2025-11-11
sudo btrfs filesystem df /mnt     # 논리/실제 사용량
```

### fstab 마운트(압축/atime 최적화)

```fstab
UUID=<UUID>  /               btrfs  subvol=@,compress=zstd:3,noatime,space_cache=v2  0  0
UUID=<UUID>  /home           btrfs  subvol=@home,compress=zstd:3,noatime             0  0
UUID=<UUID>  /var            btrfs  subvol=@var,compress=zstd:3                      0  0
UUID=<UUID>  /.snapshots     btrfs  subvol=@snapshots,ro                             0  0
```
- `compress=zstd[:level]`: 속도/압축율 균형. zstd:3~6 권장(범용)
- `noatime`: 읽기 성능 향상
- `space_cache=v2`: 최신 공간 캐시
- 스냅샷 보관용 마운트는 **ro**로 읽기 전용 노출해 "함부로 수정" 방지

### nocow(주의사항)

데이터베이스/VM 이미지 등 **랜덤 쓰기 대용량 파일**에 CoW가 오버헤드일 수 있습니다. 파일 생성 **이전**에 NOCOW 속성 부여:

```bash
# 해당 디렉토리(또는 파일)에 nocow: xattr + chattr(SSD/TRIM/Checksum 영향 고려)
sudo chattr +C /var/lib/mydb
# 이후 생성되는 파일에만 적용(Cow 비활성화). 이미 존재하는 파일엔 소급 적용 안 됨
```

> NOCOW는 Btrfs의 체크섬/스크럽 이점 일부 상쇄합니다. 정말 필요한 워크로드에만 사용하세요.

### 공간 유지/회수 도구

```bash
# — 부분적/프로필별 권장
sudo btrfs balance start -dlimit=5 -mlimit=5 /      # 조금씩

# 체크섬 검증/복구(프로필/RAID 조건 하에서)
sudo btrfs scrub start -Bd /

# 논리 vs 실제 공간, 각 프로필 사용량
sudo btrfs filesystem usage /
```

- **balance**: 과도한 사용은 성능/내구성에 지장을 줄 수 있으므로 작은 단위로 점진적으로 수행
- **scrub**: 정기 수행(예: 월 1회) 권장 → 조기 오류 감지/복구

### 증분 전송(send/receive)

```bash
# 읽기전용 스냅샷 2개 기반의 증분 전송
sudo btrfs send -p /mnt/@_ro_2025-11-01 /mnt/@_ro_2025-11-11 | ssh backup 'btrfs receive /backup/@'

# 초기 전송(베이스 없음)
sudo btrfs send /mnt/@_ro_base | ssh backup 'btrfs receive /backup/@'
```

- Btrfs는 네이티브 증분(`-p <parent>`) 기능을 제공합니다
- WAN 전송 시 압축 스트림(`zstdmt`) 파이프 조합 가능

---

## 3. ZFS — 데이터셋/풀, 스냅샷/클론, 전송

ZFS는 **풀(zpool)** 위에 **데이터셋(dataset)**을 생성합니다. 스냅샷은 `dataset@name`, 클론은 `dataset/clone`으로 표현됩니다.

### 풀/데이터셋 생성(예시)

```bash
# 디스크 2개 미러 풀
sudo zpool create -o ashift=12 tank mirror /dev/sdb /dev/sdc

# 생성 및 옵션
sudo zfs create -o compression=lz4 -o atime=off tank/home
sudo zfs create -o compression=zstd tank/data
sudo zfs list
```

- `ashift=12`: 4K 섹터 정렬(현대 디스크 기본)
- 압축: lz4(경량), zstd(고압축)
- `recordsize`는 워크로드별 조정(DB 16K/8K, 대용량 파일 1M 권장)

### 스냅샷/클론/롤백

```bash
# 스냅샷 생성/나열/삭제
sudo zfs snapshot tank/data@daily-2025-11-11
sudo zfs list -t snapshot
sudo zfs destroy tank/data@daily-2025-11-01

# 롤백(데이터셋을 스냅샷 시점으로 되돌림)
sudo zfs rollback tank/data@daily-2025-11-11

# 클론(쓰기가능한 분기 브랜치; 원 스냅샷 종속)
sudo zfs clone tank/data@daily-2025-11-11 tank/data-test
```

### 증분 전송(send/receive)

```bash
# 전체 전송(초기)
sudo zfs send tank/data@base | ssh backup 'zfs receive -u backup/data'

# 증분(부모 스냅샷 기준)
sudo zfs send -I tank/data@base tank/data@daily-2025-11-11 | ssh backup 'zfs receive -u backup/data'

# 중단 대응: -t 스트림 bookmark/hold를 써서 이어붙이기 가능
```

- `-i`(일반 증분), `-I`(중간 스냅 모두 포함 증분)
- `zfs hold/release`로 스냅샷 실수 삭제 방지
- `-u` 수신하면 즉시 마운트하지 않음(후처리 마운트)

### 무결성, ARC/L2ARC, SLOG

- **체크섬**: 모든 블록 보호. `zpool scrub`으로 정기 검사/자기복구
- **ARC/L2ARC**: 메모리 캐시/SSD 보조 캐시. 읽기 성능 향상
- **ZIL/SLOG**: 동기쓰기 가속 장치(저지연 SSD). DB/VM 동기 로그에 효과적

```bash
sudo zpool scrub tank
sudo zpool status
```

### 공간/성능 조정 옵션

```bash
# 레코드사이즈(대용량 순차 IO에 유리)
sudo zfs set recordsize=1M tank/media

# 동기쓰기 정책(워크로드별 신중히)
sudo zfs set sync=standard tank/data

# 압축/중복제거
sudo zfs set compression=zstd tank/data
sudo zfs set dedup=on tank/archive   # 메모리/CPU 부담 큼. 정말 중복 많은 워크로드에만!
```

---

## 4. 공간 절약 전략 총정리

### CoW + 압축

- **CoW**: 변경된 블록만 추가 저장 → 스냅샷 비용 감소
- **압축**: zstd/lz4 등으로 저장 효율 향상, IO 감소 → 실제 체감 속도 향상
  - Btrfs: `compress=zstd[:level]`
  - ZFS: `zfs set compression=zstd|lz4`

### 중복 제거(Dedup)

- **ZFS dedup**: 동일한 블록 해시로 **1회만 저장**
  - 메모리/CPU 오버헤드 큼(해시 테이블). **백업 리포지토리/아카이브**처럼 진짜 중복이 많은 워크로드에만 사용
- **Btrfs dedup**: 온라인/오프라인 도구로 유저랜드 수준(예: `duperemove`, `beesd`). 운영 난이도 고려 필요

### 공간 회수/정리

- Btrfs: **balance(절제)**, **defrag(큰 파일/메타데이터 대상)**, **scrub(무결성)**
- ZFS: **snapshot prune + send/receive 증분**, **scrub**, **예약/쿼타로 데이터셋 경계 관리**

### 스냅샷 보존 정책(예시)

- 매시간 24개, 매일 7개, 매주 5개, 매월 6개 → **Grandfather-Father-Son(GFS)** 정책
  - 로컬 스냅샷(단기 복구) + 원격 증분 전송(재해복구)

---

## 5. 실전 레시피: 현장에서 그대로 쓰는 스크립트

### Btrfs: `/home` 일일 스냅샷 + 14일 보존

```bash
#!/usr/bin/env bash

set -euo pipefail

SRC=/home
DST_PARENT=/.snapshots/home
DATE=$(date +%F)

sudo mkdir -p "$DST_PARENT"
sudo btrfs subvolume snapshot -r "$SRC" "$DST_PARENT/@home_$DATE"

# 15일 이전 스냅샷 삭제
find "$DST_PARENT" -maxdepth 1 -type d -name '@home_*' -daystart -mtime +14 -print0 \
  | xargs -0r sudo btrfs subvolume delete
```

`cron` 등록:
```bash
0 2 * * * root /usr/local/sbin/btrfs-home-daily
```

### ZFS: 일일 스냅샷 + 원격 증분 전송 + 30일 보존

```bash
#!/usr/bin/env bash

set -euo pipefail

SRC="tank/data"
SNAP="daily-$(date +%F)"
DST="backup/data"
REMOTE="backup-host"

# 스냅샷 생성
sudo zfs snapshot ${SRC}@${SNAP}

# 마지막 스냅샷 찾기(없으면 전체 전송)
LAST=$(sudo zfs list -t snapshot -o name -s creation -H | grep "^${SRC}@" | tail -2 | head -1 || true)

if [[ -n "${LAST}" ]]; then
  sudo zfs send -I "${LAST}" "${SRC}@${SNAP}" | ssh "${REMOTE}" "zfs receive -u ${DST}"
else
  sudo zfs send "${SRC}@${SNAP}" | ssh "${REMOTE}" "zfs receive -u ${DST}"
fi

# 로컬 30일 이전 스냅샷 삭제
sudo zfs list -t snapshot -o name,creation -s creation -H \
 | awk -v src="${SRC}@" '$1 ~ "^"src {print}' \
 | head -n -30 | awk '{print $1}' \
 | xargs -r -n1 sudo zfs destroy
```

### Btrfs: 빠른 시험용 롤백(부팅 전환 시나리오)

1) 현재 루트를 읽기전용 스냅샷으로 보관
2) 패키지/업그레이드
3) 문제가 있으면 **스냅샷을 루트로 교체**

```bash
# 루트 스냅샷
sudo btrfs subvolume snapshot -r / /.snapshots/@root_pre_upgrade_$(date +%F)

# 문제 발생 시: 부트 파라미터로 subvol=@root_pre_upgrade_... 지정 또는
# 스냅샷을 새로운 @ 로 복제 후 마운트 교체
sudo btrfs subvolume delete /@                  # 조심! 오프라인/라이브CD에서
sudo btrfs subvolume snapshot /.snapshots/@root_pre_upgrade_2025-11-11 /@
```

---

## 6. 운영 점검(필수 명령 모음)

### Btrfs

```bash
sudo btrfs subvolume list /
sudo btrfs filesystem usage /
sudo btrfs scrub start -Bd /
sudo btrfs balance start -dlimit=3 -mlimit=3 /
sudo btrfs check --readonly /dev/sdX1     # 오프라인 점검(주의)
```

### ZFS

```bash
sudo zpool status
sudo zpool scrub tank
sudo zfs list -t snapshot
sudo zfs get all tank/data | less
```

---

## 7. Timeshift/Snapper/Sanoid/zrepl — 운영 자동화 툴

- **Timeshift(Btrfs/rsync)**: 데스크탑 복구 지향(GUI/CLI), 시스템 스냅샷 스케줄러
- **Snapper(Btrfs)**: openSUSE 출신. yast/zypper와 훌륭한 통합. 프루닝 정책 강력

```bash
sudo snapper -c root create-config /
sudo snapper -c root create --type single --cleanup-algorithm number --description "manual"
sudo snapper -c root list
```

- **Sanoid/Syncoid(ZFS)**: 스냅샷 정책/보존 + send/receive 자동화의 데팩토 표준
- **zrepl(ZFS)**: 폴러/푸셔 모델, 잡/필터 기반의 현대적 증분 복제 프레임워크

---

## 8. 주의할 점(안전 지침)

1) **스냅샷 ≠ 백업**
   - 같은 장비/풀에만 있다면 **장치 고장/실수/랜섬웨어**에 취약합니다
   - **오프사이트/오프라인**(다른 서버/스토리지)에 **증분 전송**을 반드시 추가하세요

2) **데프래그/밸런스 남용 금지**
   - CoW 파일시스템은 메타데이터 업데이트가 빈번합니다. 비용 큰 작업은 **부분적/계획적으로 수행**하세요

3) **ZFS dedup는 신중히 사용**
   - 메모리 및 성능 비용이 큽니다. **아카이브/이미지 저장소** 등 중복 블록이 압도적으로 많은 곳에만 사용하세요

4) **NOCOW 사용은 최소화**
   - 무결성/체크섬 이점을 잃습니다. DB/VM 등 필요한 대상만 사전에 지정하세요

5) **부트 통합**
   - 루트 서브볼륨 전환 시 GRUB/호출자에게 `subvol=` 파라미터가 정확히 전달되어야 합니다

---

## 9. 공간/성능 직관식 공식

### 압축으로 절약되는 공간 근사

압축률을 \(r \in (0,1]\)라 하면, 데이터 \(D\)에 대해 저장 공간 \(D'\)는:
$$
D' \approx r \cdot D
$$
`zstd`는 일반적으로 텍스트/로그/소스코드에서 \(r \ll 1\) (고압축), 영상/이미지(이미 압축 포맷)는 \(r \approx 1\)입니다.

### 증분 전송량

스냅샷 사이 변경량을 \(\Delta\)라 하면 전송량은:
$$
T \approx \Delta + \epsilon
$$
(\(\epsilon\)은 메타데이터/헤더 오버헤드). **짧은 주기 스냅샷**은 \(\Delta\)를 작게 유지 → 백업 창구/대역폭 안정화

### 블록 크기와 랜덤 IO

레코드사이즈(또는 Btrfs 내부 청크/노드)의 최적화는 워크로드별 **랜덤 vs 순차** 패턴과 관련됩니다:
- 순차 대용량 파일: 큰 recordsize(예: ZFS 1M) → 대역폭 효율 향상
- DB/로그: 작은 recordsize(예: 16K/8K) → 부분 업데이트 효율 향상

---

## 10. 빠른 레퍼런스(요약 표)

| 주제 | Btrfs | ZFS |
|---|---|---|
| 스냅샷 단위 | Subvolume | Dataset |
| 스냅샷 종류 | rw/ro(권장 ro) | ro, clone으로 rw 브랜치 |
| 증분 전송 | `btrfs send/receive -p` | `zfs send/receive -i/-I` |
| 압축 | `compress=zstd` | `compression=zstd|lz4` |
| 중복제거 | 유저랜드 도구/실험적 | `dedup=on`(주의) |
| 무결성/스크럽 | `btrfs scrub` | `zpool scrub` |
| 공간 회수 | balance(절제), defrag | 스냅 프루닝 위주 |
| 권장 툴 | snapper/timeshift | sanoid/syncoid, zrepl |

---

## 결론

Btrfs와 ZFS는 현대적인 파일 시스템으로서 스냅샷과 공간 절약 기능을 강력하게 제공합니다. 효과적인 운영을 위해 다음 원칙들을 기억하세요:

**기술적 이해**:
- 스냅샷은 Copy-on-Write(CoW) 메커니즘을 통해 빠르고 경제적으로 생성됩니다
- Btrfs는 서브볼륨 기반으로 데스크탑과 서버 환경 모두에서 유연성을 제공합니다
- ZFS는 강력한 무결성 보장, 복제 기능, 세밀한 튜닝 옵션을 제공합니다

**체계적인 운영 접근법**:
1. **신중한 레이아웃 설계**: 서브볼륨/데이터셋 구조를 환경에 맞게 설계
2. **최적화 설정**: 압축, 마운트 옵션, 레코드 크기 등을 워크로드에 맞게 조정
3. **자동화된 스냅샷 관리**: 정기적 스냅샷 생성과 보존 정책 구현
4. **증분 백업 시스템**: 로컬 및 원격 증분 전송으로 데이터 보호
5. **정기적 유지보수**: 스크럽, 밸런스 작업을 계획적으로 수행

**안전성 고려사항**:
- 스냅샷은 로컬 복구용이지 완전한 백업 솔루션이 아닙니다
- 반드시 오프사이트 백업을 병행하여 재해 복구 준비
- 성능과 안정성 사이의 균형을 유지하며 튜닝 작업 수행

**도구 활용**:
- Snapper, Sanoid, zrepl 등의 자동화 도구를 활용하여 운영 효율성 향상
- Timeshift와 같은 사용자 친화적 도구로 데스크탑 환경 관리 간소화

이러한 원칙들을 바탕으로 Btrfs나 ZFS를 효과적으로 활용하면 데이터 보호, 공간 효율성, 시스템 복구 능력을 크게 향상시킬 수 있습니다. 각 환경의 특성과 요구사항에 맞게 적절히 조정하고 지속적으로 최적화하는 것이 장기적인 성공의 핵심입니다.