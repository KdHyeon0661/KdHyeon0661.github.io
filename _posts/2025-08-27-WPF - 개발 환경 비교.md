---
layout: post
title: WPF - 개발 환경 비교
date: 2025-08-27 15:25:23 +0900
category: WPF
---
# 개발 환경 비교: Visual Studio / JetBrains Rider / VS Code + 확장 도구

## 1. 전체 개요 — 왜 “IDE 선택”이 중요한가

WPF는 **XAML + C#** 조합으로, 다음 요소에 크게 의존한다.

- XAML 편집/자동완성/디자이너
- 데이터 바인딩 오류/리소스 오류 진단
- UI 스레드 디버깅, 프레임 드랍·메모리 누수 분석
- MVVM 패턴을 쓸 때의 **프로젝트 구조/리팩토링 도구**

이 때문에 단순 코드 에디터보다, **WPF에 특화된 기능**이 풍부한 IDE가 유리하다.

### 1.1 비교 대상 도구

- **Visual Studio 2022 (Community/Professional/Enterprise)**  
  - Windows 전용, WPF 1순위 IDE  
  - **XAML 디자이너, Hot Reload, Live Visual Tree** 등 WPF 특화 기능 지원 :contentReference[oaicite:1]{index=1}  

- **JetBrains Rider**  
  - 크로스플랫폼 .NET IDE (Windows / macOS / Linux) :contentReference[oaicite:2]{index=2}  
  - **ReSharper 엔진 내장**으로 대형 솔루션/리팩토링에 강함

- **Visual Studio Code + C# Dev Kit**  
  - 멀티 플랫폼 경량 에디터  
  - **C# Dev Kit**을 통해 솔루션 탐색기, 테스트 탐색기, 디버깅 등 제공 :contentReference[oaicite:3]{index=3}  
  - WPF 전용 디자이너/Hot Reload는 없고, **CLI + 디버거 기반 워크플로**가 중심

### 1.2 OS / 라이선스 / 주요 특징 한눈에

| 항목 | Visual Studio 2022 | Rider | VS Code + C# Dev Kit |
|---|---|---|---|
| OS | Windows | Windows / macOS / Linux | Windows / macOS / Linux |
| WPF 디자이너 | 완전 지원 (XAML Designer, Blend) | 제한적(텍스트+간단 프리뷰 중심) | 없음 (텍스트만) |
| XAML Hot Reload | WPF .NET/Framework 모두 지원 :contentReference[oaicite:4]{index=4} | 일부 지원(코드 변경 Live Edit 중심) | 공식 XAML Hot Reload 미지원 |
| WPF 주 개발용 추천 | 가장 강력 (1순위) | 대형 솔루션/리팩토링용 보조 1순위, Windows에서 WPF 개발 가능 | 경량 수정/리뷰/CLI 빌드용 |
| 라이선스 | Community (개인·소규모 무료), Pro/Enterprise 상용 | 상용 서브스크립션 | VS Code는 무료, C# Dev Kit는 VS와 동일한 라이선스 모델 적용 :contentReference[oaicite:5]{index=5} |

---

## 2. Visual Studio (권장: Community/Professional/Enterprise)

### 2.1 강점 정리

- **WPF 1급 지원 IDE**  
  - XAML Designer, Blend, XAML Hot Reload, Live Visual Tree, Live Property Explorer, Binding 오류 뷰 등 WPF 전용 기능이 집약 :contentReference[oaicite:6]{index=6}
- **.NET 8 / .NET 9 / 이후 버전 지원**  
  - Visual Studio 2022는 .NET 8 LTS와 .NET 9 STS를 지원하고, Windows Desktop(WinForms/WPF) 워크로드 포함 :contentReference[oaicite:7]{index=7}
- **MSBuild/테스트/프로파일링/디버깅 통합**
  - 단위테스트, 코드 커버리지, 성능/메모리 프로파일, CPU 샘플러까지 **한 IDE에서 완결**

Visual Studio를 기준으로 잡고, Rider/VS Code를 “언제 보조로 쓸 것인가”를 결정하면 전체 설계가 깔끔해진다.

---

### 2.2 필수 설치 옵션

1. **Visual Studio Installer** 실행  
2. 워크로드: **“.NET 데스크톱 개발”** 선택  
3. 개별 구성요소 확인
   - .NET SDK (8.x 이상, 필요 시 9.x)
   - Windows 10/11 SDK (고 DPI/WinUI interop, WinAppSDK 연동 등에 유리)
4. WPF 프로젝트 템플릿 포함 여부 확인

> Visual Studio 2022는 Windows 10 버전 1909 이상, Windows 11 환경에서 공식 지원된다.   

---

### 2.3 새 WPF 프로젝트 만들기

#### GUI에서

1. “새 프로젝트 만들기”  
2. 템플릿 검색: `WPF App`  
   - `.NET Framework`가 붙은 템플릿과 `.NET`만 붙은 템플릿 구분  
   - 새로운 프로젝트는 **WPF App (.NET)** 권장
3. 대상 프레임워크: `net8.0-windows`, 필요 시 `net9.0-windows`  
4. 솔루션 구조/경로 지정

#### CLI에서 (VS/VS Code/Rider 공통)

```bash
dotnet new wpf -o MyWpfApp
cd MyWpfApp
dotnet run
```

#### 다중 타깃 + WPF용 .csproj 예시

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <!-- WPF 사용 선언 -->
    <UseWPF>true</UseWPF>

    <!-- .NET 8/9 동시 타깃 예시 -->
    <TargetFrameworks>net8.0-windows;net9.0-windows</TargetFrameworks>

    <!-- 공통 옵션 -->
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <AssemblyName>MyWpfApp</AssemblyName>
    <RootNamespace>MyWpfApp</RootNamespace>
  </PropertyGroup>

  <!-- Release 빌드 튜닝 -->
  <PropertyGroup Condition="'$(Configuration)'=='Release'">
    <Optimize>true</Optimize>
    <DebugType>portable</DebugType>
    <PublishReadyToRun>true</PublishReadyToRun>
  </PropertyGroup>

</Project>
```

---

### 2.4 XAML 작업 생산성 — 디자이너, 리소스, 테마

#### App.xaml에서 테마/스타일 병합

```xml
<Application x:Class="MyWpfApp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="Views/MainWindow.xaml">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Themes/Colors.xaml" />
                <ResourceDictionary Source="Themes/Styles.xaml" />
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
</Application>
```

- **Colors.xaml**: 팔레트/브러시 정의
- **Styles.xaml**: Button/TextBox/ListView 등 컨트롤 스타일

이 구조를 쓰면 **프로젝트 전반에 일관된 테마**를 적용하기 쉬워진다.

#### XAML Designer / Live Visual Tree 활용

- Designer에서 **디자인 모드**로 컨트롤 배치/스타일 조정
- 앱 실행 후 **Live Visual Tree**에서 실제 시각 트리 확인
- Live Property Explorer에서 런타임 스타일/트리거/템플릿 적용 상황을 파악 :contentReference[oaicite:9]{index=9}  

---

### 2.5 XAML Hot Reload / Edit & Continue

**XAML Hot Reload**는 WPF 앱을 실행한 상태에서 XAML을 수정하면, 재시작 없이 UI가 갱신되도록 해 준다. :contentReference[oaicite:10]{index=10}  

- WPF .NET / .NET Framework 모두 지원
- Visual Studio 2022 최신 버전에서는 디버깅 중뿐 아니라, 특정 시나리오에서 **디버깅 없이도 Hot Reload**(Preview 기능) 가능

예시 워크플로:

1. F5로 WPF 앱 실행
2. `MainWindow.xaml`에서 버튼 텍스트/색상/레이아웃 수정
3. 파일 저장(`Ctrl+S`) → 실행 중인 UI에 즉시 반영
4. 코드 비하인드(C#) 변경은 **Edit & Continue** 범위 내에서 지원 (메서드 본문 변경 등)

> 대화형 UI 튜닝에 매우 유리하므로, WPF를 본격적으로 한다면 Hot Reload에 익숙해지는 것이 좋다.

---

### 2.6 Blend for Visual Studio — 인터랙션/애니메이션/상태

Blend는 WPF/Silverlight 시절부터 존재하던 **디자이너 중심 IDE**로, 현재는 Visual Studio에 통합되어 있다. :contentReference[oaicite:11]{index=11}  

주요 활용:

- **Visual State Manager(VSM)** 기반 화면 전환, Hover/Pressed/Disabled 등 상태 스타일링
- Storyboard 기반 애니메이션(Opacity, TranslateTransform, ScaleTransform 등)
- ControlTemplate 편집 (버튼, 체크박스, 리스트 등)

전형적인 패턴:

1. 솔루션 탐색기에서 프로젝트 우클릭 → “Blend에서 열기”
2. ControlTemplate/VisualState 등을 시각적으로 편집
3. 생성된 XAML 리소스를 다시 Visual Studio에서 유지/관리

> 복잡한 UI 애니메이션을 많이 사용하는 프로젝트라면, **Blend + Visual Studio 병행**을 강하게 추천한다.

---

### 2.7 디버깅 / 프로파일링 팁

- **Exception Settings**  
  - `View → Other Windows → Exception Settings`  
  - 예: `System.NullReferenceException`을 “Break on thrown”으로 설정해, 발생 즉시 브레이크

- **Binding 오류 추적**  
  - 출력 창의 `System.Windows.Data` 로그
  - Live Visual Tree에서 `DataContext` 확인
  - 바인딩 디버깅용 특성:

```xml
<TextBlock Text="{Binding Name,
                  PresentationTraceSources.TraceLevel=High}" />
```

- **Diagnostic Tools / Performance Profiler** :contentReference[oaicite:12]{index=12}  
  - CPU usage, Memory usage, UI Responsiveness, .NET Object Allocation 추적  
  - 프레임 드랍·GC 스톨·메모리 누수 감지에 유용

---

### 2.8 추천 확장 (Extension)

- XAML 정리:
  - **XAML Styler** (정렬/속성 정돈)
- 코드 품질:
  - **Roslynator**, **StyleCop.Analyzers**
- 생산성:
  - **IntelliCode** (AI 기반), **Productivity Power Tools**
- ReSharper (유료)
  - Rider와 유사한 리팩토링/네비게이션 기능을 Visual Studio에 제공

예: `.editorconfig`와 XAML Styler를 함께 사용해 **프로젝트 전체 포맷 일관성**을 유지할 수 있다.

---

### 2.9 작은 MVVM 예제 — Visual Studio 기반 워크플로

#### 프로젝트 구조 예시

- `MyWpfApp`
  - `Views/MainWindow.xaml`
  - `ViewModels/MainWindowViewModel.cs`
  - `App.xaml`

#### ViewModel (CommunityToolkit.Mvvm 사용)

```bash
dotnet add package CommunityToolkit.Mvvm
```

```csharp
// ViewModels/MainWindowViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Collections.ObjectModel;

namespace MyWpfApp.ViewModels;

public partial class MainWindowViewModel : ObservableObject
{
    [ObservableProperty]
    private string title = "WPF + MVVM 샘플";

    [ObservableProperty]
    private ObservableCollection<string> items = new();

    [ObservableProperty]
    private string? newItem;

    public MainWindowViewModel()
    {
        Items.Add("초기 항목 1");
        Items.Add("초기 항목 2");
    }

    [RelayCommand]
    private void AddItem()
    {
        if (!string.IsNullOrWhiteSpace(NewItem))
        {
            Items.Add(NewItem!);
            NewItem = string.Empty;
        }
    }
}
```

#### View (MainWindow.xaml)

```xml
<Window x:Class="MyWpfApp.Views.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:vm="clr-namespace:MyWpfApp.ViewModels"
        mc:Ignorable="d"
        Title="{Binding Title}" Height="400" Width="600">

    <Window.DataContext>
        <vm:MainWindowViewModel />
    </Window.DataContext>

    <DockPanel Margin="16">
        <TextBlock DockPanel.Dock="Top"
                   Text="{Binding Title}" FontSize="18" FontWeight="Bold" />

        <StackPanel DockPanel.Dock="Bottom" Orientation="Horizontal" Margin="0,12,0,0">
            <TextBox Width="200" Margin="0,0,8,0"
                     Text="{Binding NewItem, UpdateSourceTrigger=PropertyChanged}" />
            <Button Content="추가"
                    Command="{Binding AddItemCommand}" />
        </StackPanel>

        <ListBox ItemsSource="{Binding Items}" />
    </DockPanel>
</Window>
```

이 정도 구성을 Visual Studio XAML Designer + Hot Reload와 함께 사용하면, **MVVM 패턴 학습/개발 속도가 매우 빨라진다**.

---

## 3. JetBrains Rider

> Rider는 “**ReSharper가 들어 있는 가벼운 크로스플랫폼 .NET IDE**”로, 대형 솔루션/리팩토링/코드 분석에 강점이 있다. :contentReference[oaicite:13]{index=13}  

### 3.1 강점

- ReSharper 엔진 내장
  - “Rename”, “Extract Method”, “Change Signature”, “Inline Variable” 등 **고급 리팩토링**을 WPF/XAML 코드에도 적용
  - **Find Usages** / **Navigate to declaration** 등 네비게이션이 매우 빠름
- 멀티 플랫폼
  - Windows에서 WPF 개발, macOS/Linux에서는 ASP.NET Core, 라이브러리, 백엔드 개발에도 동일한 IDE 사용
- 내장 Unit Test Runner, 코드 커버리지, Profiler (에디션에 따라 구성)

### 3.2 WPF 프로젝트 생성/열기

- 새 프로젝트
  - “New Solution → .NET → WPF Application” 선택
- 기존 Visual Studio 솔루션(`.sln`) 열기
  - Rider는 Visual Studio 솔루션/프로젝트 포맷과 호환되므로, **동일 저장소에서 VS와 Rider를 번갈아 사용하는 것**도 가능하다. :contentReference[oaicite:14]{index=14}  

### 3.3 WPF/XAML 편집 경험

- XAML에 대한 **코드 분석/자동완성/바인딩 네비게이션** 지원
- `Ctrl+클릭`으로 ViewModel/리소스 정의로 이동
- 리팩토링
  - 속성 이름 변경 → 관련 XAML 바인딩도 함께 업데이트
  - 네임스페이스 정리/불필요 using 제거

> 단, Rider의 WPF **시각 디자이너(XAML Designer)는 Visual Studio만큼 성숙하지 않다**. 복잡한 UI는 VS Designer/Blend로 작업하고, **대형 리팩토링/코드 탐색은 Rider**로 수행하는 하이브리드 사용이 현실적인 조합이다.

### 3.4 Rider에서 할 때 좋은 작업들

- 프로젝트가 수십/수백 개에 달하는 **대형 솔루션**에서:
  - 전체 솔루션 리팩토링
  - 종속성 다이어그램/프로젝션
  - “불필요한 프로젝트 참조 정리”, “사용하지 않는 공용 API 탐지”
- 복잡한 LINQ/비즈니스 로직에서:
  - 코드 인스펙션 경고를 통해 잠재 버그/성능 문제 조기 탐지

---

## 4. Visual Studio Code (+ C# Dev Kit)

> VS Code는 WPF 전용 IDE는 아니지만, **CLI 중심 .NET 개발 + 경량 편집기**로 좋은 선택이며, C# Dev Kit을 통해 IDE에 가까운 경험을 제공한다. :contentReference[oaicite:15]{index=15}  

### 4.1 필수 구성

1. **.NET SDK** (8.x 이상 설치)
2. VS Code 확장
   - **C# (공식)**  
   - **C# Dev Kit** (Solution Explorer, Test Explorer, IntelliCode 등 제공)
3. XML/XAML용 기본 문법 하이라이팅 확장

C# Dev Kit은 Visual Studio 라이선스 모델을 따르며, 개인/학생/오픈소스 기여자는 무료, 기업 환경에서는 Visual Studio 구독과 유사한 라이선스 정책을 적용한다. :contentReference[oaicite:16]{index=16}  

### 4.2 WPF 프로젝트 빌드/실행

프로젝트 생성은 모두 **dotnet CLI**로 처리한다.

```bash
dotnet new wpf -o MyWpfApp
cd MyWpfApp
dotnet build
dotnet run
```

VS Code에서:

- `Ctrl+Shift+P → .NET: Generate Assets for Build and Debug` 실행  
  - `launch.json`, `tasks.json` 자동 생성
- F5로 디버깅

예시 `tasks.json`:

```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "build",
      "command": "dotnet",
      "type": "process",
      "args": [ "build", "${workspaceFolder}/MyWpfApp.csproj" ],
      "problemMatcher": "$msCompile"
    }
  ]
}
```

예시 `launch.json`:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": ".NET Core Launch WPF",
      "type": "coreclr",
      "request": "launch",
      "preLaunchTask": "build",
      "program": "${workspaceFolder}/bin/Debug/net8.0-windows/MyWpfApp.exe",
      "cwd": "${workspaceFolder}",
      "console": "internalConsole",
      "stopAtEntry": false
    }
  ]
}
```

### 4.3 Hot Reload / 디자이너 관련 한계

- VS Code에는 **WPF XAML 디자이너가 없다.**
- .NET Hot Reload는 콘솔/웹 등에서 `dotnet watch`로 활용할 수 있지만, **WPF XAML Hot Reload 수준의 경험은 Visual Studio가 제공하는 기능**이다. :contentReference[oaicite:17]{index=17}  

따라서 VS Code는:

- 경량 편집/리뷰
- CLI 기반 빌드/테스트
- Git·코드 리뷰·멀티 OS 개발

에 좋은 선택이고, **풍부한 WPF UI 작업은 Visual Studio로 전환**하는 패턴이 자연스럽다.

---

## 5. 공통 생산성 팁 (세 환경 공통)

### 5.1 NuGet 패키지

- MVVM
  - `CommunityToolkit.Mvvm`
  - `Prism.DryIoc`, `Prism.Unity`
  - `ReactiveUI`
- UI
  - `MahApps.Metro`
  - `MaterialDesignThemes`, `MaterialDesignColors`
  - `FluentWPF`
- 그래프/차트
  - `LiveChartsCore` (LiveCharts2)
  - `OxyPlot`
- DI/로그
  - `Microsoft.Extensions.DependencyInjection`
  - `Serilog`, `Serilog.Sinks.File`

```bash
dotnet add package CommunityToolkit.Mvvm
dotnet add package MaterialDesignThemes
```

### 5.2 솔루션 구조 예시 (MVVM + 계층 분리)

- `MyApp.App` (WPF UI, View/XAML)
- `MyApp.Core` (도메인/서비스/모델, ViewModel 포함 가능)
- `MyApp.Infrastructure` (API, DB, 로깅, DI 구성)
- `MyApp.Tests` (단위/통합 테스트)

이 구조는 Visual Studio / Rider / VS Code 어디서든 잘 동작하며, CI/CD에도 적합하다.

---

## 6. 빌드 구성과 품질 분석

### 6.1 빌드 구성

```xml
<PropertyGroup Condition="'$(Configuration)'=='Release'">
  <Optimize>true</Optimize>
  <DebugType>portable</DebugType>
  <PublishReadyToRun>true</PublishReadyToRun>
</PropertyGroup>
```

- Debug: 개발, Hot Reload/디버깅, 풍부한 로그
- Release: JIT 최적화, ReadyToRun, 트리밍(필요 시) 등 적용

### 6.2 코드 품질 설정

```xml
<PropertyGroup>
  <Nullable>enable</Nullable>
  <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
  <AnalysisMode>AllEnabledByDefault</AnalysisMode>
</PropertyGroup>
```

- **Nullable Reference Type** 활성화로 NRE 방지
- 코드 분석 규칙(CA) 활성화로 기본 품질 바닥 확보

`.editorconfig`를 사용하면 Visual Studio / Rider / VS Code 모두에서 같은 규칙을 공유할 수 있다.

---

## 7. 테스트 및 CI (GitHub Actions 예시)

```yaml
# .github/workflows/ci.yml
name: .NET CI

on: [push, pull_request]

jobs:
  build:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
      - run: dotnet restore
      - run: dotnet build --configuration Release --no-restore
      - run: dotnet test --no-build --verbosity normal
```

- WPF UI 테스트는 별도 도구가 필요하지만, ViewModel/서비스/도메인 로직은 **일반 .NET 테스트 프로젝트**에서 쉽게 검증 가능

---

## 8. IDE 선택 가이드 (확장 버전)

### 8.1 상황별 추천 조합

1. **개인/포트폴리오용 WPF 프로젝트**
   - 메인: Visual Studio Community
   - 보조: VS Code (가볍게 수정/리뷰), Rider(있다면 리팩토링 시)

2. **중소 규모 팀, WPF + 백엔드 혼합**
   - WPF: Visual Studio
   - 백엔드/라이브러리: Rider 또는 VS Code도 병행
   - 팀 내 컨벤션: `.editorconfig`, `Directory.Packages.props` 등 공통화

3. **대형 솔루션, 장기 유지보수**
   - Visual Studio + Rider 동시 사용
     - VS: 디자이너/Hot Reload, WPF UI 작업
     - Rider: 대규모 리팩토링/코드 탐색/정적 분석
   - VS Code: DevOps 스크립트, 컨테이너, YAML, 기타 경량 작업

### 8.2 요약 비교 표 (세 IDE)

| 항목 | Visual Studio | Rider | VS Code + C# Dev Kit |
|---|---|---|---|
| WPF XAML 디자이너 | 완전 지원 | 제한적 | 없음 |
| XAML Hot Reload | WPF .NET/Framework 지원 | 코드 변경 Live Edit 중심 | 공식 지원 없음 |
| 대형 솔루션 처리 | 좋음 | 매우 좋음 | 좋음 (기능은 적지만 가벼움) |
| 리팩토링/네비 | 좋음(확장 필요) | 최고 (ReSharper) | 보통 |
| 테스트/프로파일링 | 풍부한 내장 도구 | 풍부한 내장 도구 | 확장/CLI 조합 |
| 학습 곡선 | 낮음 | 중간 | 낮음 |
| 주 용도 | WPF 메인 개발 | 대규모 리팩토링/복합 .NET | 경량 편집/멀티 OS/CLI |

---

## 9. 자주 겪는 이슈 & 체크리스트

### 9.1 디자이너 성능/붕괴

- 무거운 리소스를 디자인 타임에 불러오지 않도록 `d:DesignHeight`, `d:DesignWidth`, `d:DataContext` 등을 활용
- 코드 비하인드에서 디자인 모드 분기:

```csharp
using System.ComponentModel;
using System.Windows;

if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))
{
    // 디자인 모드 전용 코드
}
```

### 9.2 바인딩 에러

- 출력 창에서 `System.Windows.Data` 필터 사용
- Live Visual Tree로 DataContext/경로 확인
- 상수/변수 이름 변경 시 **리팩토링을 통해** 수정 (수동 문자열 편집 최소화)

### 9.3 고 DPI

- `App.manifest`에서 DPI Aware 설정 확인
- 벡터 그래픽(Geometry/IconFont) + 레이아웃 기반 스케일링 사용

### 9.4 빌드/복구 느림

- `Directory.Packages.props`로 NuGet 버전 중앙 관리
- 사용하지 않는 TargetFramework 제거
- 필요 시 `RestoreLockedMode` 활용

---

## 10. 결론

- **WPF를 진지하게 개발한다면 Visual Studio가 기본 선택**이다.  
  - XAML Designer, Hot Reload, Live Visual Tree, Blend, 풍부한 디버깅/프로파일링 도구 등 **WPF 전용 기능**이 핵심 생산성을 좌우한다. :contentReference[oaicite:18]{index=18}  
- **Rider는 대형 솔루션/리팩토링/코드 분석에 최강**이며, Visual Studio와 함께 사용할 때 가장 큰 효과를 낸다. :contentReference[oaicite:19]{index=19}  
- **VS Code + C# Dev Kit**는 멀티 OS·경량 작업·CLI 기반 빌드/디버깅에 최적화되어 있고, Visual Studio for Mac 종료 이후 cross-platform .NET 개발의 중요한 축이 되었다. :contentReference[oaicite:20]{index=20}  

실전에서는 세 도구를 **대체 관계가 아니라 역할 분담**으로 보는 것이 좋다.

- UI/디자인/Hot Reload → Visual Studio  
- 대규모 리팩토링/코드 품질 → Rider  
- 경량 편집/스크립트/멀티 OS → VS Code  

이 글의 내용을 기반으로, 자신이 만드는 WPF 프로젝트의 **규모, 팀 구성, 운영 환경**에 맞는 조합을 선택하면 된다.