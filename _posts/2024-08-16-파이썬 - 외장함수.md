---
layout: post
title: 파이썬 - 외장함수
date: 2024-08-16 19:20:23 +0900
category: Python
---
# 파이썬 외장 모듈 정리 – 표준 라이브러리 핵심 요약

## 0) 목차 & 한눈에 보는 추천 모듈

- 고차 함수/데코레이터: **`functools`**
- 반복 처리/조합론: **`itertools`**
- 운영체제/경로: **`os`**, **`pathlib`**
- 인터프리터/런타임: **`sys`**
- 날짜/시간/타임존: **`datetime`**, **`zoneinfo`**
- 해시/무결성: **`hashlib`**, (보안 토큰: `secrets`)
- 파일/디렉터리/압축: **`shutil`**, **`zipfile`**, **`tarfile`**, **`tempfile`**
- 고급 자료형: **`collections`**
- 로깅/진단: **`logging`**
- 직렬화: **`json`**, **`csv`**, **`pickle`(주의)**
- 서브프로세스/CLI: **`subprocess`**, **`argparse`**

※ 요청 주제의 중심은 초안의 8개 모듈이지만, 실무 맥락을 위해 꼭 함께 쓰이는 모듈을 최소한으로 보강했습니다.

---

## 1. `functools` – 고차 함수/데코레이터 필수 모듈

### 1.1 핵심 함수 요약

| 함수 | 요약 | 사용 포인트 |
|---|---|---|
| `lru_cache(maxsize=128)` | 결과 **메모이제이션** | 순수함수/IO 없음/입력이 해시 가능할 때 |
| `cache` | 무제한 LRU(=dict 캐시) | 입력 도메인 작고 반복 호출 |
| `partial(func, *args, **kw)` | **인자 일부 고정** | 콜백/핸들러에 특정 인자 주입 |
| `reduce(func, iterable, init?)` | 누적 폴드 | 합/곱/최댓값/커스텀 누적 |
| `total_ordering` | 비교 연산자 자동 보완 | `__lt__`와 `__eq__`만 구현해도 됨 |
| `wraps` | 데코레이터 작성 시 **메타데이터 보존** | `@wraps(fn)` 꼭 붙이기 |
| `singledispatch` | 인자 1개 타입별 **함수 분기** | 함수형 오버로딩 |
| `singledispatchmethod` | 메서드 버전 | 클래스 내 타입별 분기 |

### 1.2 예제

```python
from functools import lru_cache, partial, reduce, total_ordering, wraps, singledispatch

@lru_cache(maxsize=1024)
def fib(n: int) -> int:
    return n if n < 2 else fib(n-1) + fib(n-2)

def add(a, b): return a + b
add10 = partial(add, 10)
print(add10(5))  # 15

print(reduce(lambda x, y: x * y, [1, 2, 3, 4]))  # 24

def logging_deco(fn):
    @wraps(fn)
    def wrapper(*a, **k):
        print(f"[call] {fn.__name__}{a}{k}")
        return fn(*a, **k)
    return wrapper

@logging_deco
def greet(name): return f"hi {name}"

print(greet("Kim"))  # wraps 없으면 __name__ 등 메타데이터 깨짐

@singledispatch
def show(x):
    print("obj:", x)

@show.register
def _(x: int): print("int:", x)

@show.register
def _(x: str): print("str:", x)

show(42); show("abc"); show([1,2,3])
```

### 1.3 실무 팁/주의
- `lru_cache`는 **인자/반환**이 **해시 가능(immutable)** 해야 안전. 딕셔너리/리스트는 불가.
- 상태/외부 IO(파일/DB/HTTP) 포함 함수는 캐시 **무효화 전략** 고려(버전 키, TTL 캐시 필요 시 `cachetools` 같은 외부 라이브러리).
- `reduce`는 가독성 저해될 수 있음. 가능한 **명시 루프**나 **`sum`, `max`** 우선.

---

## 2. `itertools` – 빠르고 메모리 효율적인 반복 처리

### 2.1 핵심 함수 요약

| 함수 | 설명 | 대표 쓰임 |
|---|---|---|
| `count(start=0, step=1)` | 무한 카운터 | ID/타임스탬프 시퀀스 |
| `cycle(iterable)` | 무한 순환 | 라운드로빈 |
| `repeat(obj, times?)` | 값 반복 | 더미 값 채우기 |
| `accumulate(iter, func=operator.add)` | 누적값 | 누적합/누적최대 |
| `chain(*iters)` | 연결 | 납작화(flatten 1-depth) |
| `islice(iter, start, stop, step)` | 슬라이싱 | 스트림 일부만 꺼내기 |
| `compress(data, selectors)` | 마스크 필터 | 조건 마스킹 |
| `dropwhile/pairwise/takewhile` | 조건 기반 취득 | 프리/포스트 필터 |
| `product/permutations/combinations/combinations_with_replacement` | 곱/순열/조합 | 탐색/브루트포스 |

### 2.2 레시피

```python
from itertools import count, cycle, chain, combinations, islice, accumulate, pairwise
import operator

# count + islice: 10, 12, 14
print(list(islice(count(10, 2), 3)))

# chain: 납작 연결
print(list(chain("ABC", "DEF")))  # ['A','B','C','D','E','F']

# 조합
print(list(combinations([1,2,3], 2)))  # [(1,2),(1,3),(2,3)]

# 누적합/누적최대
print(list(accumulate([3, 1, 4, 2], operator.add)))   # [3,4,8,10]
print(list(accumulate([3, 1, 4, 2], max)))            # [3,3,4,4]

# pairwise (3.10+)
print(list(pairwise([10, 20, 35, 55])))  # [(10,20),(20,35),(35,55)]
```

### 2.3 실무 팁
- 거대한 입력 처리 시 **제너레이터/이터레이터** 조합으로 **메모리 O(1)** 유지.
- 리스트로 강제 캐스팅(`list(...)`)은 **필요할 때만**.

---

## 3. `os` & `pathlib` – 운영체제/경로 다루기의 정석

> **신규 코드**에서는 `os.path` 대신 **`pathlib`** 권장. 객체지향 경로, `/` 연산자, 메서드 체인이 매우 깔끔함.

### 3.1 `os` 필수 항목

| 항목 | 설명 |
|---|---|
| `os.name` | `'posix'`, `'nt'` |
| `os.getcwd()` | 현재 작업 디렉터리 |
| `os.listdir(path)` | 파일 목록 |
| `os.makedirs(path, exist_ok=True)` | 재귀 생성 |
| `os.environ` | 환경 변수 dict |
| `os.remove`, `os.rmdir`, `os.rename` | 파일/디렉터리 조작 |

```python
import os

print(os.name, os.getcwd())
os.makedirs("example_dir/sub", exist_ok=True)
print(os.listdir("example_dir"))
```

### 3.2 `pathlib` 기본

```python
from pathlib import Path

p = Path("example_dir") / "sub" / "data.txt"
p.parent.mkdir(parents=True, exist_ok=True)
p.write_text("hello\n", encoding="utf-8")
print(p.read_text(encoding="utf-8"))
print(p.resolve())
```

### 3.3 실무 팁
- 경로 결합은 **`/` 연산자**로(운영체제별 구분자 자동 처리).
- 대용량 파일 복사/이동은 `shutil`과 병행(아래 참고).

---

## 4. `sys` – 인터프리터/런타임 제어

| 항목 | 설명/용도 |
|---|---|
| `sys.argv` | CLI 인자 (문자열 리스트) |
| `sys.exit(code)` | 종료 코드 반환 |
| `sys.path` | import 경로 |
| `sys.version`/`version_info` | 런타임 버전 |
| `sys.stdin/out/err` | 표준 스트림 핸들 |

```python
import sys

if "--version" in sys.argv:
    print(sys.version)
    sys.exit(0)
```

**팁**: 복잡한 CLI는 `argparse` 사용(아래 부록).

---

## 5. `datetime` & `zoneinfo` – 날짜/시간/타임존

### 5.1 기본

```python
from datetime import datetime, timedelta, timezone

now = datetime.now(timezone.utc)  # TZ 인식 aware datetime
print(now.isoformat())

in_7 = now + timedelta(days=7)
print(in_7.strftime("%Y-%m-%d %H:%M"))
```

### 5.2 타임존 (3.9+: `zoneinfo`)

```python
from datetime import datetime
from zoneinfo import ZoneInfo

seoul = ZoneInfo("Asia/Seoul")
nyc = ZoneInfo("America/New_York")

dt = datetime(2025, 11, 10, 15, 0, tzinfo=seoul)
print(dt.astimezone(nyc))
```

**주의**:  
- 항상 **타임존 인식(`tzinfo`)** datetime 사용.  
- 저장은 **UTC** 권장, 표시할 때 지역 타임존으로 변환.

---

## 6. `hashlib` – 해시/무결성(보안 유의)

```python
import hashlib, pathlib

data = "password123".encode()
print(hashlib.sha256(data).hexdigest())

# 파일 무결성
h = hashlib.sha256()
with open("big.bin", "rb") as f:
    for chunk in iter(lambda: f.read(1 << 16), b""):
        h.update(chunk)
print(h.hexdigest())
```

**보안 유의**:  
- 해시만으로 비밀번호 저장 X. 비밀번호는 **bcrypt/argon2/scrypt** 같은 **느린 KDF** 사용(외부 라이브러리).  
- 무결성 검증/중복 제거/캐싱 키로 `sha256` 추천.

---

## 7. `shutil` (+ `zipfile`/`tarfile`/`tempfile`) – 파일/디렉터리/압축

### 7.1 고급 파일 작업

```python
import shutil, os, tempfile, pathlib

# 복사/이동
shutil.copy("a.txt", "backup.txt")
shutil.move("backup.txt", "archive/backup.txt")

# 디렉터리 압축
shutil.make_archive("my-archive", "zip", "myfolder")

# 일시 폴더/파일
with tempfile.TemporaryDirectory() as tmpdir:
    p = pathlib.Path(tmpdir) / "note.txt"
    p.write_text("temp data")
    print("created:", p)
# 여기서 자동 삭제
```

### 7.2 압축 세부 제어

```python
import zipfile

with zipfile.ZipFile("bundle.zip", "w", compression=zipfile.ZIP_DEFLATED) as zf:
    zf.write("a.txt")
    zf.writestr("inline.txt", "hello")
```

**주의**:  
- `shutil.rmtree(path, ignore_errors=True)`는 위험(조용히 실패). 가능하면 예외 처리로 원인 파악.  
- 임시 파일은 **`tempfile` 컨텍스트**로 자동 정리.

---

## 8. `collections` – 고급 자료형

| 자료형 | 요약 | 포인트 |
|---|---|---|
| `Counter` | 요소 개수 세기 | 로그/토큰/빈도 |
| `deque(maxlen=None)` | 양방향 큐 | O(1) 좌우 삽입/팝, 슬라이딩 윈도 |
| `defaultdict(default_factory)` | 기본값 dict | 누적/그룹핑 |
| `namedtuple` / `dataclass` | 경량 레코드 | 불변 튜플 필드명 |
| `OrderedDict` | 삽입순 dict(참고) | 3.7+ 기본 dict가 삽입순 |

### 8.1 예제

```python
from collections import Counter, deque, defaultdict, namedtuple

# Counter
c = Counter("aabcdd")
print(c.most_common(1))  # [('a', 2)] 또는 [('d', 2)]

# deque
dq = deque([1,2,3], maxlen=5)
dq.appendleft(0); dq.append(4)
print(dq)  # deque([0,1,2,3,4], maxlen=5)

# defaultdict
dd = defaultdict(list)
for k, v in [("a",1), ("a",2), ("b",3)]:
    dd[k].append(v)
print(dd)  # {'a':[1,2], 'b':[3]}

# namedtuple
Point = namedtuple("Point", "x y")
p = Point(3, 4)
print(p.x, p.y)
```

**팁**: 레코드가 많고 변경도 필요하면 **`dataclasses`**(외장 아님이지만 표준) 고려.

---

## 9. `itertools`/`collections`를 엮은 실전 레시피

### 9.1 로그에서 상위 N 오류코드

```python
from collections import Counter

def top_n_codes(lines, n=5):
    codes = (line.split()[0] for line in lines)  # 예: "404 GET /"
    return Counter(codes).most_common(n)

# with open("access.log") as f: print(top_n_codes(f, 10))
```

### 9.2 슬라이딩 윈도 이동 평균

```python
from collections import deque
def moving_avg(seq, k):
    q, s = deque(), 0.0
    for x in seq:
        q.append(x); s += x
        if len(q) > k: s -= q.popleft()
        if len(q) == k: yield s / k

print(list(moving_avg([1,2,3,4,5,6], 3)))  # [2.0, 3.0, 4.0, 5.0]
```

---

## 10. 로깅/직렬화/CLI (현업에서 함께 쓰이는 표준 모듈)

### 10.1 `logging` 최소 설정

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(name)s: %(message)s"
)
log = logging.getLogger("app")

log.info("service start")
try:
    1/0
except ZeroDivisionError:
    log.exception("failed")
```

### 10.2 `json`/`csv`

```python
import json, csv

# JSON
data = {"name":"Kim", "score":[90,85]}
s = json.dumps(data, ensure_ascii=False)
obj = json.loads(s)

# CSV
with open("scores.csv", "w", newline="", encoding="utf-8") as f:
    w = csv.writer(f)
    w.writerow(["name","score"])
    w.writerow(["Kim", 90])

with open("scores.csv", newline="", encoding="utf-8") as f:
    for row in csv.DictReader(f):
        print(row["name"], row["score"])
```

### 10.3 `subprocess` + `argparse`

```python
# cli.py
import argparse, subprocess

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--count", type=int, default=3)
    args = p.parse_args()

    out = subprocess.check_output(["python", "-c", "print('x'*3)"])
    print(out.decode().strip() * args.count)

if __name__ == "__main__":
    main()
```

---

## 11. 보안/난수 관련 표준 모듈 (한 줄 팁)

- **`secrets`**: 보안 토큰/랜덤(세션 키, OTP 시드) → `secrets.token_urlsafe(32)`
- **`uuid`**: 고유 식별자 → `uuid.uuid4()`
- **`hmac`**: 메시지 인증코드(HMAC) → 안전한 무결성 검증

```python
import secrets, uuid, hmac, hashlib

token = secrets.token_urlsafe(32)
uid = uuid.uuid4()
sig = hmac.new(b"key", b"message", hashlib.sha256).hexdigest()
```

---

## 12. 원문 초안 보강 정리표 (요약)

| 모듈 | 주요 기능 | 필수 레시피 |
|---|---|---|
| `functools` | LRU 캐시, partial, 싱글디스패치 | `@lru_cache`, `@wraps`, `singledispatch` |
| `itertools` | 반복/조합/누적 | `accumulate`, `islice`, `combinations` |
| `os`/`pathlib` | OS 연동/경로 | **`pathlib.Path`** 기반 파일 IO |
| `sys` | 인터프리터/CLI | `sys.argv`, `sys.exit` |
| `datetime`/`zoneinfo` | 시간/타임존 | **UTC 보관, 현지화 표시** |
| `hashlib` | 해싱 | 파일 청크 해싱, 비밀번호는 외부 KDF |
| `shutil`/`zipfile` | 파일/압축/임시 | `make_archive`, `TemporaryDirectory` |
| `collections` | 자료구조 | `Counter`, `deque`, `defaultdict` |
| (보강) `logging` | 로깅 | `basicConfig`, `log.exception` |
| (보강) `json`/`csv` | 직렬화/표 | `json.dumps/loads`, `csv.DictReader` |
| (보강) `subprocess` | 외부 프로세스 | `check_output`(보안 주의) |

---

## 13. 성능/안정성/보안 체크리스트

- [ ] 큰 파일은 **스트리밍(chunks)** 로딩 (`read()` 남용 금지)
- [ ] 경로 결합은 **`pathlib`**; 문자열 덧셈 금지
- [ ] 날짜/시간은 **타임존 인식 aware**로, 저장은 **UTC**
- [ ] 비밀번호는 **KDF(Argon2/bcrypt)**, 해시는 무결성 용도
- [ ] 임시 파일·디렉터리는 **`tempfile` 컨텍스트**
- [ ] 캐시 함수는 **순수성** 확인 후 `lru_cache`
- [ ] 반복 처리·조합은 **`itertools`** + **제너레이터** 우선
- [ ] 예외·이벤트는 **`logging`** 으로 남기고 표준 출력 남발 금지

---

## 14. 미니 과제(실전형)

1) **디렉터리 전체를 ZIP으로 묶되, 크기/개수 요약 JSON**  
- `pathlib`로 순회 → 파일 크기 누적(`itertools.accumulate`도 가능) → `zipfile`로 압축 → 요약을 `summary.json` 저장.

2) **로그 파일에서 상위 10 에러코드 + 이동 평균**  
- `collections.Counter`로 상위 10 → 에러 발생 타임시리즈에 `deque`로 이동 평균(윈도우 60분).

3) **API 응답 캐시 서버 사이드 LRU**  
- 순수 GET 요청(파라미터가 해시 가능) → `@lru_cache`로 결과 캐시 → 캐시 무효화 전략(버전 키) 구현.

---

### 끝맺음

위 모듈들만 손에 익어도 **스크립트 → 유틸리티 → 서비스 운영 보조**까지 대부분의 작업을 표준 라이브러리로 소화할 수 있습니다.  
필요하면 다음 편에서 **병렬/비동기(`concurrent.futures`, `asyncio`)**, **형식 지정(`dataclasses`, `typing`)**, **프로파일링(`timeit`, `cProfile`)**로 넓혀가면 좋습니다.